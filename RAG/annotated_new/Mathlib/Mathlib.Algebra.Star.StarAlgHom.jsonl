{"name":"NonUnitalStarAlgHom.mk.sizeOf_spec","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁹ : Monoid R\ninst✝⁸ : NonUnitalNonAssocSemiring A\ninst✝⁷ : DistribMulAction R A\ninst✝⁶ : Star A\ninst✝⁵ : NonUnitalNonAssocSemiring B\ninst✝⁴ : DistribMulAction R B\ninst✝³ : Star B\ninst✝² : SizeOf R\ninst✝¹ : SizeOf A\ninst✝ : SizeOf B\ntoNonUnitalAlgHom : NonUnitalAlgHom (MonoidHom.id R) A B\nmap_star' : ∀ (a : A), Eq (toNonUnitalAlgHom.toFun (Star.star a)) (Star.star (toNonUnitalAlgHom.toFun a))\n⊢ Eq (SizeOf.sizeOf { toNonUnitalAlgHom := toNonUnitalAlgHom, map_star' := map_star' }) (HAdd.hAdd 1 (SizeOf.sizeOf toNonUnitalAlgHom))","decl":"/-- A *non-unital ⋆-algebra homomorphism* is a non-unital algebra homomorphism between\nnon-unital `R`-algebras `A` and `B` equipped with a `star` operation, and this homomorphism is\nalso `star`-preserving. -/\nstructure NonUnitalStarAlgHom (R A B : Type*) [Monoid R] [NonUnitalNonAssocSemiring A]\n  [DistribMulAction R A] [Star A] [NonUnitalNonAssocSemiring B] [DistribMulAction R B]\n  [Star B] extends A →ₙₐ[R] B where\n  /-- By definition, a non-unital ⋆-algebra homomorphism preserves the `star` operation. -/\n  map_star' : ∀ a : A, toFun (star a) = star (toFun a)\n\n"}
{"name":"NonUnitalStarAlgHom.mk.injEq","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : Monoid R\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : Star A\ninst✝² : NonUnitalNonAssocSemiring B\ninst✝¹ : DistribMulAction R B\ninst✝ : Star B\ntoNonUnitalAlgHom✝ : NonUnitalAlgHom (MonoidHom.id R) A B\nmap_star'✝ : ∀ (a : A), Eq (toNonUnitalAlgHom✝.toFun (Star.star a)) (Star.star (toNonUnitalAlgHom✝.toFun a))\ntoNonUnitalAlgHom : NonUnitalAlgHom (MonoidHom.id R) A B\nmap_star' : ∀ (a : A), Eq (toNonUnitalAlgHom.toFun (Star.star a)) (Star.star (toNonUnitalAlgHom.toFun a))\n⊢ Eq (Eq { toNonUnitalAlgHom := toNonUnitalAlgHom✝, map_star' := map_star'✝ } { toNonUnitalAlgHom := toNonUnitalAlgHom, map_star' := map_star' }) (Eq toNonUnitalAlgHom✝ toNonUnitalAlgHom)","decl":"/-- A *non-unital ⋆-algebra homomorphism* is a non-unital algebra homomorphism between\nnon-unital `R`-algebras `A` and `B` equipped with a `star` operation, and this homomorphism is\nalso `star`-preserving. -/\nstructure NonUnitalStarAlgHom (R A B : Type*) [Monoid R] [NonUnitalNonAssocSemiring A]\n  [DistribMulAction R A] [Star A] [NonUnitalNonAssocSemiring B] [DistribMulAction R B]\n  [Star B] extends A →ₙₐ[R] B where\n  /-- By definition, a non-unital ⋆-algebra homomorphism preserves the `star` operation. -/\n  map_star' : ∀ a : A, toFun (star a) = star (toFun a)\n\n"}
{"name":"NonUnitalStarAlgHom.map_star'","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : Monoid R\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : Star A\ninst✝² : NonUnitalNonAssocSemiring B\ninst✝¹ : DistribMulAction R B\ninst✝ : Star B\nself : NonUnitalStarAlgHom R A B\na : A\n⊢ Eq (self.toFun (Star.star a)) (Star.star (self.toFun a))","decl":"/-- A *non-unital ⋆-algebra homomorphism* is a non-unital algebra homomorphism between\nnon-unital `R`-algebras `A` and `B` equipped with a `star` operation, and this homomorphism is\nalso `star`-preserving. -/\nstructure NonUnitalStarAlgHom (R A B : Type*) [Monoid R] [NonUnitalNonAssocSemiring A]\n  [DistribMulAction R A] [Star A] [NonUnitalNonAssocSemiring B] [DistribMulAction R B]\n  [Star B] extends A →ₙₐ[R] B where\n  /-- By definition, a non-unital ⋆-algebra homomorphism preserves the `star` operation. -/\n  map_star' : ∀ a : A, toFun (star a) = star (toFun a)\n\n"}
{"name":"NonUnitalStarAlgHom.mk.inj","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : Monoid R\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : Star A\ninst✝² : NonUnitalNonAssocSemiring B\ninst✝¹ : DistribMulAction R B\ninst✝ : Star B\ntoNonUnitalAlgHom✝ : NonUnitalAlgHom (MonoidHom.id R) A B\nmap_star'✝ : ∀ (a : A), Eq (toNonUnitalAlgHom✝.toFun (Star.star a)) (Star.star (toNonUnitalAlgHom✝.toFun a))\ntoNonUnitalAlgHom : NonUnitalAlgHom (MonoidHom.id R) A B\nmap_star' : ∀ (a : A), Eq (toNonUnitalAlgHom.toFun (Star.star a)) (Star.star (toNonUnitalAlgHom.toFun a))\nx✝ : Eq { toNonUnitalAlgHom := toNonUnitalAlgHom✝, map_star' := map_star'✝ } { toNonUnitalAlgHom := toNonUnitalAlgHom, map_star' := map_star' }\n⊢ Eq toNonUnitalAlgHom✝ toNonUnitalAlgHom","decl":"/-- A *non-unital ⋆-algebra homomorphism* is a non-unital algebra homomorphism between\nnon-unital `R`-algebras `A` and `B` equipped with a `star` operation, and this homomorphism is\nalso `star`-preserving. -/\nstructure NonUnitalStarAlgHom (R A B : Type*) [Monoid R] [NonUnitalNonAssocSemiring A]\n  [DistribMulAction R A] [Star A] [NonUnitalNonAssocSemiring B] [DistribMulAction R B]\n  [Star B] extends A →ₙₐ[R] B where\n  /-- By definition, a non-unital ⋆-algebra homomorphism preserves the `star` operation. -/\n  map_star' : ∀ a : A, toFun (star a) = star (toFun a)\n\n"}
{"name":"NonUnitalStarAlgHomClass.toStarHomClass","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"F : Type u_1\nR : outParam (Type u_2)\nA : outParam (Type u_3)\nB : outParam (Type u_4)\ninst✝⁸ : Monoid R\ninst✝⁷ : Star A\ninst✝⁶ : Star B\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : NonUnitalNonAssocSemiring B\ninst✝³ : DistribMulAction R A\ninst✝² : DistribMulAction R B\ninst✝¹ : FunLike F A B\ninst✝ : NonUnitalAlgHomClass F R A B\nself : NonUnitalStarAlgHomClass F R A B\n⊢ StarHomClass F A B","decl":"/-- `NonUnitalStarAlgHomClass F R A B` asserts `F` is a type of bundled non-unital ⋆-algebra\nhomomorphisms from `A` to `B`. -/\n@[deprecated StarHomClass (since := \"2024-09-08\")]\nclass NonUnitalStarAlgHomClass (F : Type*) (R A B : outParam Type*)\n  [Monoid R] [Star A] [Star B] [NonUnitalNonAssocSemiring A] [NonUnitalNonAssocSemiring B]\n  [DistribMulAction R A] [DistribMulAction R B] [FunLike F A B] [NonUnitalAlgHomClass F R A B]\n  extends StarHomClass F A B : Prop\n\n"}
{"name":"NonUnitalStarAlgHomClass.instNonUnitalStarRingHomClassOfStarHomClass","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"F : Type u_1\nR : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁹ : Monoid R\ninst✝⁸ : NonUnitalNonAssocSemiring A\ninst✝⁷ : DistribMulAction R A\ninst✝⁶ : Star A\ninst✝⁵ : NonUnitalNonAssocSemiring B\ninst✝⁴ : DistribMulAction R B\ninst✝³ : Star B\ninst✝² : FunLike F A B\ninst✝¹ : NonUnitalAlgHomClass F R A B\ninst✝ : StarHomClass F A B\n⊢ NonUnitalStarRingHomClass F A B","decl":"instance [StarHomClass F A B] : NonUnitalStarRingHomClass F A B :=\n  NonUnitalStarRingHomClass.mk\n\n"}
{"name":"NonUnitalStarAlgHom.instNonUnitalAlgHomClass","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : Monoid R\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : Star A\ninst✝² : NonUnitalNonAssocSemiring B\ninst✝¹ : DistribMulAction R B\ninst✝ : Star B\n⊢ NonUnitalAlgHomClass (NonUnitalStarAlgHom R A B) R A B","decl":"instance : NonUnitalAlgHomClass (A →⋆ₙₐ[R] B) R A B where\n  map_smulₛₗ f := f.map_smul'\n  map_add f := f.map_add'\n  map_zero f := f.map_zero'\n  map_mul f := f.map_mul'\n\n"}
{"name":"NonUnitalStarAlgHom.instStarHomClass","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : Monoid R\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : Star A\ninst✝² : NonUnitalNonAssocSemiring B\ninst✝¹ : DistribMulAction R B\ninst✝ : Star B\n⊢ StarHomClass (NonUnitalStarAlgHom R A B) A B","decl":"instance : StarHomClass (A →⋆ₙₐ[R] B) A B where\n  map_star f := f.map_star'\n\n-- Porting note: in mathlib3 we didn't need the `Simps.apply` hint.\n"}
{"name":"NonUnitalStarAlgHom.coe_coe","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁹ : Monoid R\ninst✝⁸ : NonUnitalNonAssocSemiring A\ninst✝⁷ : DistribMulAction R A\ninst✝⁶ : Star A\ninst✝⁵ : NonUnitalNonAssocSemiring B\ninst✝⁴ : DistribMulAction R B\ninst✝³ : Star B\nF : Type u_6\ninst✝² : FunLike F A B\ninst✝¹ : NonUnitalAlgHomClass F R A B\ninst✝ : StarHomClass F A B\nf : F\n⊢ Eq ⇑↑f ⇑f","decl":"@[simp]\nprotected theorem coe_coe {F : Type*} [FunLike F A B] [NonUnitalAlgHomClass F R A B]\n    [StarHomClass F A B] (f : F) :\n    ⇑(f : A →⋆ₙₐ[R] B) = f := rfl\n\n"}
{"name":"NonUnitalStarAlgHom.coe_toNonUnitalAlgHom","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : Monoid R\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : Star A\ninst✝² : NonUnitalNonAssocSemiring B\ninst✝¹ : DistribMulAction R B\ninst✝ : Star B\nf : NonUnitalStarAlgHom R A B\n⊢ Eq ⇑f.toNonUnitalAlgHom ⇑f","decl":"@[simp]\ntheorem coe_toNonUnitalAlgHom {f : A →⋆ₙₐ[R] B} : (f.toNonUnitalAlgHom : A → B) = f :=\n  rfl\n\n"}
{"name":"NonUnitalStarAlgHom.ext_iff","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : Monoid R\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : Star A\ninst✝² : NonUnitalNonAssocSemiring B\ninst✝¹ : DistribMulAction R B\ninst✝ : Star B\nf g : NonUnitalStarAlgHom R A B\n⊢ Iff (Eq f g) (∀ (x : A), Eq (f x) (g x))","decl":"@[ext]\ntheorem ext {f g : A →⋆ₙₐ[R] B} (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"NonUnitalStarAlgHom.ext","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : Monoid R\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : Star A\ninst✝² : NonUnitalNonAssocSemiring B\ninst✝¹ : DistribMulAction R B\ninst✝ : Star B\nf g : NonUnitalStarAlgHom R A B\nh : ∀ (x : A), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {f g : A →⋆ₙₐ[R] B} (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"NonUnitalStarAlgHom.coe_copy","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : Monoid R\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : Star A\ninst✝² : NonUnitalNonAssocSemiring B\ninst✝¹ : DistribMulAction R B\ninst✝ : Star B\nf : NonUnitalStarAlgHom R A B\nf' : A → B\nh : Eq f' ⇑f\n⊢ Eq (⇑(f.copy f' h)) f'","decl":"@[simp]\ntheorem coe_copy (f : A →⋆ₙₐ[R] B) (f' : A → B) (h : f' = f) : ⇑(f.copy f' h) = f' :=\n  rfl\n\n"}
{"name":"NonUnitalStarAlgHom.copy_eq","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : Monoid R\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : Star A\ninst✝² : NonUnitalNonAssocSemiring B\ninst✝¹ : DistribMulAction R B\ninst✝ : Star B\nf : NonUnitalStarAlgHom R A B\nf' : A → B\nh : Eq f' ⇑f\n⊢ Eq (f.copy f' h) f","decl":"theorem copy_eq (f : A →⋆ₙₐ[R] B) (f' : A → B) (h : f' = f) : f.copy f' h = f :=\n  DFunLike.ext' h\n\n"}
{"name":"NonUnitalStarAlgHom.coe_mk","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : Monoid R\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : Star A\ninst✝² : NonUnitalNonAssocSemiring B\ninst✝¹ : DistribMulAction R B\ninst✝ : Star B\nf : A → B\nh₁ : ∀ (m : R) (x : A), Eq (f (HSMul.hSMul m x)) (HSMul.hSMul ((MonoidHom.id R) m) (f x))\nh₂ : Eq ({ toFun := f, map_smul' := h₁ }.toFun 0) 0\nh₃ : ∀ (x y : A), Eq ({ toFun := f, map_smul' := h₁ }.toFun (HAdd.hAdd x y)) (HAdd.hAdd ({ toFun := f, map_smul' := h₁ }.toFun x) ({ toFun := f, map_smul' := h₁ }.toFun y))\nh₄ : ∀ (x y : A), Eq ({ toFun := f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃ }.toFun (HMul.hMul x y)) (HMul.hMul ({ toFun := f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃ }.toFun x) ({ toFun := f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃ }.toFun y))\nh₅ : ∀ (a : A), Eq ({ toFun := f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃, map_mul' := h₄ }.toFun (Star.star a)) (Star.star ({ toFun := f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃, map_mul' := h₄ }.toFun a))\n⊢ Eq (⇑{ toFun := f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃, map_mul' := h₄, map_star' := h₅ }) f","decl":"@[simp]\ntheorem coe_mk (f : A → B) (h₁ h₂ h₃ h₄ h₅) :\n    ((⟨⟨⟨⟨f, h₁⟩, h₂, h₃⟩, h₄⟩, h₅⟩ : A →⋆ₙₐ[R] B) : A → B) = f :=\n  rfl\n\n-- this is probably the more useful lemma for Lean 4 and should likely replace `coe_mk` above\n"}
{"name":"NonUnitalStarAlgHom.coe_mk'","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : Monoid R\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : Star A\ninst✝² : NonUnitalNonAssocSemiring B\ninst✝¹ : DistribMulAction R B\ninst✝ : Star B\nf : NonUnitalAlgHom (MonoidHom.id R) A B\nh : ∀ (a : A), Eq (f.toFun (Star.star a)) (Star.star (f.toFun a))\n⊢ Eq ⇑{ toNonUnitalAlgHom := f, map_star' := h } ⇑f","decl":"@[simp]\ntheorem coe_mk' (f : A →ₙₐ[R] B) (h) :\n    ((⟨f, h⟩ : A →⋆ₙₐ[R] B) : A → B) = f :=\n  rfl\n\n"}
{"name":"NonUnitalStarAlgHom.mk_coe","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : Monoid R\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : Star A\ninst✝² : NonUnitalNonAssocSemiring B\ninst✝¹ : DistribMulAction R B\ninst✝ : Star B\nf : NonUnitalStarAlgHom R A B\nh₁ : ∀ (m : R) (x : A), Eq (f (HSMul.hSMul m x)) (HSMul.hSMul ((MonoidHom.id R) m) (f x))\nh₂ : Eq ({ toFun := ⇑f, map_smul' := h₁ }.toFun 0) 0\nh₃ : ∀ (x y : A), Eq ({ toFun := ⇑f, map_smul' := h₁ }.toFun (HAdd.hAdd x y)) (HAdd.hAdd ({ toFun := ⇑f, map_smul' := h₁ }.toFun x) ({ toFun := ⇑f, map_smul' := h₁ }.toFun y))\nh₄ : ∀ (x y : A), Eq ({ toFun := ⇑f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃ }.toFun (HMul.hMul x y)) (HMul.hMul ({ toFun := ⇑f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃ }.toFun x) ({ toFun := ⇑f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃ }.toFun y))\nh₅ : ∀ (a : A), Eq ({ toFun := ⇑f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃, map_mul' := h₄ }.toFun (Star.star a)) (Star.star ({ toFun := ⇑f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃, map_mul' := h₄ }.toFun a))\n⊢ Eq { toFun := ⇑f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃, map_mul' := h₄, map_star' := h₅ } f","decl":"@[simp]\ntheorem mk_coe (f : A →⋆ₙₐ[R] B) (h₁ h₂ h₃ h₄ h₅) :\n    (⟨⟨⟨⟨f, h₁⟩, h₂, h₃⟩, h₄⟩, h₅⟩ : A →⋆ₙₐ[R] B) = f := by\n  ext\n  rfl\n\n"}
{"name":"NonUnitalStarAlgHom.coe_id","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : Monoid R\ninst✝² : NonUnitalNonAssocSemiring A\ninst✝¹ : DistribMulAction R A\ninst✝ : Star A\n⊢ Eq (⇑(NonUnitalStarAlgHom.id R A)) id","decl":"@[simp, norm_cast]\ntheorem coe_id : ⇑(NonUnitalStarAlgHom.id R A) = id :=\n  rfl\n\n"}
{"name":"NonUnitalStarAlgHom.coe_comp","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁹ : Monoid R\ninst✝⁸ : NonUnitalNonAssocSemiring A\ninst✝⁷ : DistribMulAction R A\ninst✝⁶ : Star A\ninst✝⁵ : NonUnitalNonAssocSemiring B\ninst✝⁴ : DistribMulAction R B\ninst✝³ : Star B\ninst✝² : NonUnitalNonAssocSemiring C\ninst✝¹ : DistribMulAction R C\ninst✝ : Star C\nf : NonUnitalStarAlgHom R B C\ng : NonUnitalStarAlgHom R A B\n⊢ Eq (⇑(f.comp g)) (Function.comp ⇑f ⇑g)","decl":"@[simp]\ntheorem coe_comp (f : B →⋆ₙₐ[R] C) (g : A →⋆ₙₐ[R] B) : ⇑(comp f g) = f ∘ g :=\n  rfl\n\n"}
{"name":"NonUnitalStarAlgHom.comp_apply","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁹ : Monoid R\ninst✝⁸ : NonUnitalNonAssocSemiring A\ninst✝⁷ : DistribMulAction R A\ninst✝⁶ : Star A\ninst✝⁵ : NonUnitalNonAssocSemiring B\ninst✝⁴ : DistribMulAction R B\ninst✝³ : Star B\ninst✝² : NonUnitalNonAssocSemiring C\ninst✝¹ : DistribMulAction R C\ninst✝ : Star C\nf : NonUnitalStarAlgHom R B C\ng : NonUnitalStarAlgHom R A B\na : A\n⊢ Eq ((f.comp g) a) (f (g a))","decl":"@[simp]\ntheorem comp_apply (f : B →⋆ₙₐ[R] C) (g : A →⋆ₙₐ[R] B) (a : A) : comp f g a = f (g a) :=\n  rfl\n\n"}
{"name":"NonUnitalStarAlgHom.comp_assoc","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nC : Type u_4\nD : Type u_5\ninst✝¹² : Monoid R\ninst✝¹¹ : NonUnitalNonAssocSemiring A\ninst✝¹⁰ : DistribMulAction R A\ninst✝⁹ : Star A\ninst✝⁸ : NonUnitalNonAssocSemiring B\ninst✝⁷ : DistribMulAction R B\ninst✝⁶ : Star B\ninst✝⁵ : NonUnitalNonAssocSemiring C\ninst✝⁴ : DistribMulAction R C\ninst✝³ : Star C\ninst✝² : NonUnitalNonAssocSemiring D\ninst✝¹ : DistribMulAction R D\ninst✝ : Star D\nf : NonUnitalStarAlgHom R C D\ng : NonUnitalStarAlgHom R B C\nh : NonUnitalStarAlgHom R A B\n⊢ Eq ((f.comp g).comp h) (f.comp (g.comp h))","decl":"@[simp]\ntheorem comp_assoc (f : C →⋆ₙₐ[R] D) (g : B →⋆ₙₐ[R] C) (h : A →⋆ₙₐ[R] B) :\n    (f.comp g).comp h = f.comp (g.comp h) :=\n  rfl\n\n"}
{"name":"NonUnitalStarAlgHom.id_comp","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : Monoid R\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : Star A\ninst✝² : NonUnitalNonAssocSemiring B\ninst✝¹ : DistribMulAction R B\ninst✝ : Star B\nf : NonUnitalStarAlgHom R A B\n⊢ Eq ((NonUnitalStarAlgHom.id R B).comp f) f","decl":"@[simp]\ntheorem id_comp (f : A →⋆ₙₐ[R] B) : (NonUnitalStarAlgHom.id _ _).comp f = f :=\n  ext fun _ => rfl\n\n"}
{"name":"NonUnitalStarAlgHom.comp_id","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : Monoid R\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : Star A\ninst✝² : NonUnitalNonAssocSemiring B\ninst✝¹ : DistribMulAction R B\ninst✝ : Star B\nf : NonUnitalStarAlgHom R A B\n⊢ Eq (f.comp (NonUnitalStarAlgHom.id R A)) f","decl":"@[simp]\ntheorem comp_id (f : A →⋆ₙₐ[R] B) : f.comp (NonUnitalStarAlgHom.id _ _) = f :=\n  ext fun _ => rfl\n\n"}
{"name":"NonUnitalStarAlgHom.coe_one","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : Monoid R\ninst✝² : NonUnitalNonAssocSemiring A\ninst✝¹ : DistribMulAction R A\ninst✝ : Star A\n⊢ Eq (⇑1) id","decl":"@[simp]\ntheorem coe_one : ((1 : A →⋆ₙₐ[R] A) : A → A) = id :=\n  rfl\n\n"}
{"name":"NonUnitalStarAlgHom.one_apply","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : Monoid R\ninst✝² : NonUnitalNonAssocSemiring A\ninst✝¹ : DistribMulAction R A\ninst✝ : Star A\na : A\n⊢ Eq (1 a) a","decl":"theorem one_apply (a : A) : (1 : A →⋆ₙₐ[R] A) a = a :=\n  rfl\n\n"}
{"name":"NonUnitalStarAlgHom.coe_zero","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : Monoid R\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : StarAddMonoid A\ninst✝² : NonUnitalNonAssocSemiring B\ninst✝¹ : DistribMulAction R B\ninst✝ : StarAddMonoid B\n⊢ Eq (⇑0) 0","decl":"@[simp]\ntheorem coe_zero : ((0 : A →⋆ₙₐ[R] B) : A → B) = 0 :=\n  rfl\n\n"}
{"name":"NonUnitalStarAlgHom.zero_apply","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : Monoid R\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : StarAddMonoid A\ninst✝² : NonUnitalNonAssocSemiring B\ninst✝¹ : DistribMulAction R B\ninst✝ : StarAddMonoid B\na : A\n⊢ Eq (0 a) 0","decl":"theorem zero_apply (a : A) : (0 : A →⋆ₙₐ[R] B) a = 0 :=\n  rfl\n\n"}
{"name":"NonUnitalStarAlgHom.restrictScalars_apply","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝¹² : Monoid R\ninst✝¹¹ : Monoid S\ninst✝¹⁰ : Star A\ninst✝⁹ : Star B\ninst✝⁸ : NonUnitalNonAssocSemiring A\ninst✝⁷ : NonUnitalNonAssocSemiring B\ninst✝⁶ : MulAction R S\ninst✝⁵ : DistribMulAction S A\ninst✝⁴ : DistribMulAction S B\ninst✝³ : DistribMulAction R A\ninst✝² : DistribMulAction R B\ninst✝¹ : IsScalarTower R S A\ninst✝ : IsScalarTower R S B\nf : NonUnitalStarAlgHom S A B\nx : A\n⊢ Eq ((NonUnitalStarAlgHom.restrictScalars R f) x) (f x)","decl":"@[simp]\nlemma restrictScalars_apply (f : A →⋆ₙₐ[S] B) (x : A) : f.restrictScalars R x = f x := rfl\n\n"}
{"name":"NonUnitalStarAlgHom.coe_restrictScalars","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝¹² : Monoid R\ninst✝¹¹ : Monoid S\ninst✝¹⁰ : Star A\ninst✝⁹ : Star B\ninst✝⁸ : NonUnitalNonAssocSemiring A\ninst✝⁷ : NonUnitalNonAssocSemiring B\ninst✝⁶ : MulAction R S\ninst✝⁵ : DistribMulAction S A\ninst✝⁴ : DistribMulAction S B\ninst✝³ : DistribMulAction R A\ninst✝² : DistribMulAction R B\ninst✝¹ : IsScalarTower R S A\ninst✝ : IsScalarTower R S B\nf : NonUnitalStarAlgHom S A B\n⊢ Eq ↑(NonUnitalStarAlgHom.restrictScalars R f) ↑f","decl":"lemma coe_restrictScalars (f : A →⋆ₙₐ[S] B) : (f.restrictScalars R : A →ₙ+* B) = f := rfl\n\n"}
{"name":"NonUnitalStarAlgHom.coe_restrictScalars'","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝¹² : Monoid R\ninst✝¹¹ : Monoid S\ninst✝¹⁰ : Star A\ninst✝⁹ : Star B\ninst✝⁸ : NonUnitalNonAssocSemiring A\ninst✝⁷ : NonUnitalNonAssocSemiring B\ninst✝⁶ : MulAction R S\ninst✝⁵ : DistribMulAction S A\ninst✝⁴ : DistribMulAction S B\ninst✝³ : DistribMulAction R A\ninst✝² : DistribMulAction R B\ninst✝¹ : IsScalarTower R S A\ninst✝ : IsScalarTower R S B\nf : NonUnitalStarAlgHom S A B\n⊢ Eq ⇑(NonUnitalStarAlgHom.restrictScalars R f) ⇑f","decl":"lemma coe_restrictScalars' (f : A →⋆ₙₐ[S] B) : (f.restrictScalars R : A → B) = f := rfl\n\n"}
{"name":"NonUnitalStarAlgHom.restrictScalars_injective","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝¹² : Monoid R\ninst✝¹¹ : Monoid S\ninst✝¹⁰ : Star A\ninst✝⁹ : Star B\ninst✝⁸ : NonUnitalNonAssocSemiring A\ninst✝⁷ : NonUnitalNonAssocSemiring B\ninst✝⁶ : MulAction R S\ninst✝⁵ : DistribMulAction S A\ninst✝⁴ : DistribMulAction S B\ninst✝³ : DistribMulAction R A\ninst✝² : DistribMulAction R B\ninst✝¹ : IsScalarTower R S A\ninst✝ : IsScalarTower R S B\n⊢ Function.Injective (NonUnitalStarAlgHom.restrictScalars R)","decl":"theorem restrictScalars_injective :\n    Function.Injective (restrictScalars R : (A →⋆ₙₐ[S] B) → A →⋆ₙₐ[R] B) :=\n  fun _ _ h ↦ ext (DFunLike.congr_fun h :)\n\n"}
{"name":"StarAlgHom.mk.injEq","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Star A\ninst✝² : Semiring B\ninst✝¹ : Algebra R B\ninst✝ : Star B\ntoAlgHom✝ : AlgHom R A B\nmap_star'✝ : ∀ (x : A), Eq ((↑↑toAlgHom✝.toRingHom).toFun (Star.star x)) (Star.star ((↑↑toAlgHom✝.toRingHom).toFun x))\ntoAlgHom : AlgHom R A B\nmap_star' : ∀ (x : A), Eq ((↑↑toAlgHom.toRingHom).toFun (Star.star x)) (Star.star ((↑↑toAlgHom.toRingHom).toFun x))\n⊢ Eq (Eq { toAlgHom := toAlgHom✝, map_star' := map_star'✝ } { toAlgHom := toAlgHom, map_star' := map_star' }) (Eq toAlgHom✝ toAlgHom)","decl":"/-- A *⋆-algebra homomorphism* is an algebra homomorphism between `R`-algebras `A` and `B`\nequipped with a `star` operation, and this homomorphism is also `star`-preserving. -/\nstructure StarAlgHom (R A B : Type*) [CommSemiring R] [Semiring A] [Algebra R A] [Star A]\n  [Semiring B] [Algebra R B] [Star B] extends AlgHom R A B where\n  /-- By definition, a ⋆-algebra homomorphism preserves the `star` operation. -/\n  map_star' : ∀ x : A, toFun (star x) = star (toFun x)\n\n"}
{"name":"StarAlgHom.mk.inj","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Star A\ninst✝² : Semiring B\ninst✝¹ : Algebra R B\ninst✝ : Star B\ntoAlgHom✝ : AlgHom R A B\nmap_star'✝ : ∀ (x : A), Eq ((↑↑toAlgHom✝.toRingHom).toFun (Star.star x)) (Star.star ((↑↑toAlgHom✝.toRingHom).toFun x))\ntoAlgHom : AlgHom R A B\nmap_star' : ∀ (x : A), Eq ((↑↑toAlgHom.toRingHom).toFun (Star.star x)) (Star.star ((↑↑toAlgHom.toRingHom).toFun x))\nx✝ : Eq { toAlgHom := toAlgHom✝, map_star' := map_star'✝ } { toAlgHom := toAlgHom, map_star' := map_star' }\n⊢ Eq toAlgHom✝ toAlgHom","decl":"/-- A *⋆-algebra homomorphism* is an algebra homomorphism between `R`-algebras `A` and `B`\nequipped with a `star` operation, and this homomorphism is also `star`-preserving. -/\nstructure StarAlgHom (R A B : Type*) [CommSemiring R] [Semiring A] [Algebra R A] [Star A]\n  [Semiring B] [Algebra R B] [Star B] extends AlgHom R A B where\n  /-- By definition, a ⋆-algebra homomorphism preserves the `star` operation. -/\n  map_star' : ∀ x : A, toFun (star x) = star (toFun x)\n\n"}
{"name":"StarAlgHom.mk.sizeOf_spec","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁹ : CommSemiring R\ninst✝⁸ : Semiring A\ninst✝⁷ : Algebra R A\ninst✝⁶ : Star A\ninst✝⁵ : Semiring B\ninst✝⁴ : Algebra R B\ninst✝³ : Star B\ninst✝² : SizeOf R\ninst✝¹ : SizeOf A\ninst✝ : SizeOf B\ntoAlgHom : AlgHom R A B\nmap_star' : ∀ (x : A), Eq ((↑↑toAlgHom.toRingHom).toFun (Star.star x)) (Star.star ((↑↑toAlgHom.toRingHom).toFun x))\n⊢ Eq (SizeOf.sizeOf { toAlgHom := toAlgHom, map_star' := map_star' }) (HAdd.hAdd 1 (SizeOf.sizeOf toAlgHom))","decl":"/-- A *⋆-algebra homomorphism* is an algebra homomorphism between `R`-algebras `A` and `B`\nequipped with a `star` operation, and this homomorphism is also `star`-preserving. -/\nstructure StarAlgHom (R A B : Type*) [CommSemiring R] [Semiring A] [Algebra R A] [Star A]\n  [Semiring B] [Algebra R B] [Star B] extends AlgHom R A B where\n  /-- By definition, a ⋆-algebra homomorphism preserves the `star` operation. -/\n  map_star' : ∀ x : A, toFun (star x) = star (toFun x)\n\n"}
{"name":"StarAlgHom.map_star'","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Star A\ninst✝² : Semiring B\ninst✝¹ : Algebra R B\ninst✝ : Star B\nself : StarAlgHom R A B\nx : A\n⊢ Eq ((↑↑self.toRingHom).toFun (Star.star x)) (Star.star ((↑↑self.toRingHom).toFun x))","decl":"/-- A *⋆-algebra homomorphism* is an algebra homomorphism between `R`-algebras `A` and `B`\nequipped with a `star` operation, and this homomorphism is also `star`-preserving. -/\nstructure StarAlgHom (R A B : Type*) [CommSemiring R] [Semiring A] [Algebra R A] [Star A]\n  [Semiring B] [Algebra R B] [Star B] extends AlgHom R A B where\n  /-- By definition, a ⋆-algebra homomorphism preserves the `star` operation. -/\n  map_star' : ∀ x : A, toFun (star x) = star (toFun x)\n\n"}
{"name":"StarAlgHomClass.toStarHomClass","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"F : Type u_1\nR : outParam (Type u_2)\nA : outParam (Type u_3)\nB : outParam (Type u_4)\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Semiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : Star A\ninst✝⁴ : Semiring B\ninst✝³ : Algebra R B\ninst✝² : Star B\ninst✝¹ : FunLike F A B\ninst✝ : AlgHomClass F R A B\nself : StarAlgHomClass F R A B\n⊢ StarHomClass F A B","decl":"/-- `StarAlgHomClass F R A B` states that `F` is a type of ⋆-algebra homomorphisms.\nYou should also extend this typeclass when you extend `StarAlgHom`. -/\n@[deprecated StarHomClass (since := \"2024-09-08\")]\nclass StarAlgHomClass (F : Type*) (R A B : outParam Type*)\n    [CommSemiring R] [Semiring A] [Algebra R A] [Star A] [Semiring B] [Algebra R B] [Star B]\n    [FunLike F A B] [AlgHomClass F R A B] extends StarHomClass F A B : Prop\n"}
{"name":"StarAlgHom.instAlgHomClass","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Star A\ninst✝² : Semiring B\ninst✝¹ : Algebra R B\ninst✝ : Star B\n⊢ AlgHomClass (StarAlgHom R A B) R A B","decl":"instance : AlgHomClass (A →⋆ₐ[R] B) R A B where\n  map_mul f := f.map_mul'\n  map_one f := f.map_one'\n  map_add f := f.map_add'\n  map_zero f := f.map_zero'\n  commutes f := f.commutes'\n\n"}
{"name":"StarAlgHom.instStarHomClass","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Star A\ninst✝² : Semiring B\ninst✝¹ : Algebra R B\ninst✝ : Star B\n⊢ StarHomClass (StarAlgHom R A B) A B","decl":"instance : StarHomClass (A →⋆ₐ[R] B) A B where\n  map_star f := f.map_star'\n\n"}
{"name":"StarAlgHom.coe_coe","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁹ : CommSemiring R\ninst✝⁸ : Semiring A\ninst✝⁷ : Algebra R A\ninst✝⁶ : Star A\ninst✝⁵ : Semiring B\ninst✝⁴ : Algebra R B\ninst✝³ : Star B\nF : Type u_7\ninst✝² : FunLike F A B\ninst✝¹ : AlgHomClass F R A B\ninst✝ : StarHomClass F A B\nf : F\n⊢ Eq ⇑↑f ⇑f","decl":"@[simp]\nprotected theorem coe_coe {F : Type*} [FunLike F A B] [AlgHomClass F R A B]\n    [StarHomClass F A B] (f : F) :\n    ⇑(f : A →⋆ₐ[R] B) = f :=\n  rfl\n\n-- Porting note: in mathlib3 we didn't need the `Simps.apply` hint.\n"}
{"name":"StarAlgHom.coe_toAlgHom","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Star A\ninst✝² : Semiring B\ninst✝¹ : Algebra R B\ninst✝ : Star B\nf : StarAlgHom R A B\n⊢ Eq ⇑f.toAlgHom ⇑f","decl":"@[simp]\ntheorem coe_toAlgHom {f : A →⋆ₐ[R] B} : (f.toAlgHom : A → B) = f :=\n  rfl\n\n"}
{"name":"StarAlgHom.ext","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Star A\ninst✝² : Semiring B\ninst✝¹ : Algebra R B\ninst✝ : Star B\nf g : StarAlgHom R A B\nh : ∀ (x : A), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {f g : A →⋆ₐ[R] B} (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"StarAlgHom.ext_iff","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Star A\ninst✝² : Semiring B\ninst✝¹ : Algebra R B\ninst✝ : Star B\nf g : StarAlgHom R A B\n⊢ Iff (Eq f g) (∀ (x : A), Eq (f x) (g x))","decl":"@[ext]\ntheorem ext {f g : A →⋆ₐ[R] B} (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"StarAlgHom.coe_copy","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Star A\ninst✝² : Semiring B\ninst✝¹ : Algebra R B\ninst✝ : Star B\nf : StarAlgHom R A B\nf' : A → B\nh : Eq f' ⇑f\n⊢ Eq (⇑(f.copy f' h)) f'","decl":"@[simp]\ntheorem coe_copy (f : A →⋆ₐ[R] B) (f' : A → B) (h : f' = f) : ⇑(f.copy f' h) = f' :=\n  rfl\n\n"}
{"name":"StarAlgHom.copy_eq","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Star A\ninst✝² : Semiring B\ninst✝¹ : Algebra R B\ninst✝ : Star B\nf : StarAlgHom R A B\nf' : A → B\nh : Eq f' ⇑f\n⊢ Eq (f.copy f' h) f","decl":"theorem copy_eq (f : A →⋆ₐ[R] B) (f' : A → B) (h : f' = f) : f.copy f' h = f :=\n  DFunLike.ext' h\n\n"}
{"name":"StarAlgHom.coe_mk","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Star A\ninst✝² : Semiring B\ninst✝¹ : Algebra R B\ninst✝ : Star B\nf : A → B\nh₁ : Eq (f 1) 1\nh₂ : ∀ (x y : A), Eq ({ toFun := f, map_one' := h₁ }.toFun (HMul.hMul x y)) (HMul.hMul ({ toFun := f, map_one' := h₁ }.toFun x) ({ toFun := f, map_one' := h₁ }.toFun y))\nh₃ : Eq ((↑{ toFun := f, map_one' := h₁, map_mul' := h₂ }).toFun 0) 0\nh₄ : ∀ (x y : A), Eq ((↑{ toFun := f, map_one' := h₁, map_mul' := h₂ }).toFun (HAdd.hAdd x y)) (HAdd.hAdd ((↑{ toFun := f, map_one' := h₁, map_mul' := h₂ }).toFun x) ((↑{ toFun := f, map_one' := h₁, map_mul' := h₂ }).toFun y))\nh₅ : ∀ (r : R), Eq ((↑↑{ toFun := f, map_one' := h₁, map_mul' := h₂, map_zero' := h₃, map_add' := h₄ }).toFun ((algebraMap R A) r)) ((algebraMap R B) r)\nh₆ : ∀ (x : A), Eq ((↑↑{ toFun := f, map_one' := h₁, map_mul' := h₂, map_zero' := h₃, map_add' := h₄, commutes' := h₅ }.toRingHom).toFun (Star.star x)) (Star.star ((↑↑{ toFun := f, map_one' := h₁, map_mul' := h₂, map_zero' := h₃, map_add' := h₄, commutes' := h₅ }.toRingHom).toFun x))\n⊢ Eq (⇑{ toFun := f, map_one' := h₁, map_mul' := h₂, map_zero' := h₃, map_add' := h₄, commutes' := h₅, map_star' := h₆ }) f","decl":"@[simp]\ntheorem coe_mk (f : A → B) (h₁ h₂ h₃ h₄ h₅ h₆) :\n    ((⟨⟨⟨⟨⟨f, h₁⟩, h₂⟩, h₃, h₄⟩, h₅⟩, h₆⟩ : A →⋆ₐ[R] B) : A → B) = f :=\n  rfl\n\n-- this is probably the more useful lemma for Lean 4 and should likely replace `coe_mk` above\n"}
{"name":"StarAlgHom.coe_mk'","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Star A\ninst✝² : Semiring B\ninst✝¹ : Algebra R B\ninst✝ : Star B\nf : AlgHom R A B\nh : ∀ (x : A), Eq ((↑↑f.toRingHom).toFun (Star.star x)) (Star.star ((↑↑f.toRingHom).toFun x))\n⊢ Eq ⇑{ toAlgHom := f, map_star' := h } ⇑f","decl":"@[simp]\ntheorem coe_mk' (f : A →ₐ[R] B) (h) :\n    ((⟨f, h⟩ : A →⋆ₐ[R] B) : A → B) = f :=\n  rfl\n\n"}
{"name":"StarAlgHom.mk_coe","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Star A\ninst✝² : Semiring B\ninst✝¹ : Algebra R B\ninst✝ : Star B\nf : StarAlgHom R A B\nh₁ : Eq (f 1) 1\nh₂ : ∀ (x y : A), Eq ({ toFun := ⇑f, map_one' := h₁ }.toFun (HMul.hMul x y)) (HMul.hMul ({ toFun := ⇑f, map_one' := h₁ }.toFun x) ({ toFun := ⇑f, map_one' := h₁ }.toFun y))\nh₃ : Eq ((↑{ toFun := ⇑f, map_one' := h₁, map_mul' := h₂ }).toFun 0) 0\nh₄ : ∀ (x y : A), Eq ((↑{ toFun := ⇑f, map_one' := h₁, map_mul' := h₂ }).toFun (HAdd.hAdd x y)) (HAdd.hAdd ((↑{ toFun := ⇑f, map_one' := h₁, map_mul' := h₂ }).toFun x) ((↑{ toFun := ⇑f, map_one' := h₁, map_mul' := h₂ }).toFun y))\nh₅ : ∀ (r : R), Eq ((↑↑{ toFun := ⇑f, map_one' := h₁, map_mul' := h₂, map_zero' := h₃, map_add' := h₄ }).toFun ((algebraMap R A) r)) ((algebraMap R B) r)\nh₆ : ∀ (x : A), Eq ((↑↑{ toFun := ⇑f, map_one' := h₁, map_mul' := h₂, map_zero' := h₃, map_add' := h₄, commutes' := h₅ }.toRingHom).toFun (Star.star x)) (Star.star ((↑↑{ toFun := ⇑f, map_one' := h₁, map_mul' := h₂, map_zero' := h₃, map_add' := h₄, commutes' := h₅ }.toRingHom).toFun x))\n⊢ Eq { toFun := ⇑f, map_one' := h₁, map_mul' := h₂, map_zero' := h₃, map_add' := h₄, commutes' := h₅, map_star' := h₆ } f","decl":"@[simp]\ntheorem mk_coe (f : A →⋆ₐ[R] B) (h₁ h₂ h₃ h₄ h₅ h₆) :\n    (⟨⟨⟨⟨⟨f, h₁⟩, h₂⟩, h₃, h₄⟩, h₅⟩, h₆⟩ : A →⋆ₐ[R] B) = f := by\n  ext\n  rfl\n\n"}
{"name":"StarAlgHom.coe_id","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\ninst✝³ : CommSemiring R\ninst✝² : Semiring A\ninst✝¹ : Algebra R A\ninst✝ : Star A\n⊢ Eq (⇑(StarAlgHom.id R A)) id","decl":"@[simp, norm_cast]\ntheorem coe_id : ⇑(StarAlgHom.id R A) = id :=\n  rfl\n\n"}
{"name":"StarAlgHom.ofId_apply","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_7\nA : Type u_8\ninst✝⁵ : CommSemiring R\ninst✝⁴ : StarRing R\ninst✝³ : Semiring A\ninst✝² : StarMul A\ninst✝¹ : Algebra R A\ninst✝ : StarModule R A\na : R\n⊢ Eq ((StarAlgHom.ofId R A) a) ((algebraMap R A) a)","decl":"/-- `algebraMap R A` as a `StarAlgHom` when `A` is a star algebra over `R`. -/\n@[simps]\ndef ofId (R A : Type*) [CommSemiring R] [StarRing R] [Semiring A] [StarMul A]\n    [Algebra R A] [StarModule R A] : R →⋆ₐ[R] A :=\n  { Algebra.ofId R A with\n    toFun := algebraMap R A\n    map_star' := by simp [Algebra.algebraMap_eq_smul_one] }\n\n"}
{"name":"StarAlgHom.coe_comp","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\nC : Type u_5\ninst✝⁹ : CommSemiring R\ninst✝⁸ : Semiring A\ninst✝⁷ : Algebra R A\ninst✝⁶ : Star A\ninst✝⁵ : Semiring B\ninst✝⁴ : Algebra R B\ninst✝³ : Star B\ninst✝² : Semiring C\ninst✝¹ : Algebra R C\ninst✝ : Star C\nf : StarAlgHom R B C\ng : StarAlgHom R A B\n⊢ Eq (⇑(f.comp g)) (Function.comp ⇑f ⇑g)","decl":"@[simp]\ntheorem coe_comp (f : B →⋆ₐ[R] C) (g : A →⋆ₐ[R] B) : ⇑(comp f g) = f ∘ g :=\n  rfl\n\n"}
{"name":"StarAlgHom.comp_apply","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\nC : Type u_5\ninst✝⁹ : CommSemiring R\ninst✝⁸ : Semiring A\ninst✝⁷ : Algebra R A\ninst✝⁶ : Star A\ninst✝⁵ : Semiring B\ninst✝⁴ : Algebra R B\ninst✝³ : Star B\ninst✝² : Semiring C\ninst✝¹ : Algebra R C\ninst✝ : Star C\nf : StarAlgHom R B C\ng : StarAlgHom R A B\na : A\n⊢ Eq ((f.comp g) a) (f (g a))","decl":"@[simp]\ntheorem comp_apply (f : B →⋆ₐ[R] C) (g : A →⋆ₐ[R] B) (a : A) : comp f g a = f (g a) :=\n  rfl\n\n"}
{"name":"StarAlgHom.comp_assoc","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\nC : Type u_5\nD : Type u_6\ninst✝¹² : CommSemiring R\ninst✝¹¹ : Semiring A\ninst✝¹⁰ : Algebra R A\ninst✝⁹ : Star A\ninst✝⁸ : Semiring B\ninst✝⁷ : Algebra R B\ninst✝⁶ : Star B\ninst✝⁵ : Semiring C\ninst✝⁴ : Algebra R C\ninst✝³ : Star C\ninst✝² : Semiring D\ninst✝¹ : Algebra R D\ninst✝ : Star D\nf : StarAlgHom R C D\ng : StarAlgHom R B C\nh : StarAlgHom R A B\n⊢ Eq ((f.comp g).comp h) (f.comp (g.comp h))","decl":"@[simp]\ntheorem comp_assoc (f : C →⋆ₐ[R] D) (g : B →⋆ₐ[R] C) (h : A →⋆ₐ[R] B) :\n    (f.comp g).comp h = f.comp (g.comp h) :=\n  rfl\n\n"}
{"name":"StarAlgHom.id_comp","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Star A\ninst✝² : Semiring B\ninst✝¹ : Algebra R B\ninst✝ : Star B\nf : StarAlgHom R A B\n⊢ Eq ((StarAlgHom.id R B).comp f) f","decl":"@[simp]\ntheorem id_comp (f : A →⋆ₐ[R] B) : (StarAlgHom.id _ _).comp f = f :=\n  ext fun _ => rfl\n\n"}
{"name":"StarAlgHom.comp_id","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Star A\ninst✝² : Semiring B\ninst✝¹ : Algebra R B\ninst✝ : Star B\nf : StarAlgHom R A B\n⊢ Eq (f.comp (StarAlgHom.id R A)) f","decl":"@[simp]\ntheorem comp_id (f : A →⋆ₐ[R] B) : f.comp (StarAlgHom.id _ _) = f :=\n  ext fun _ => rfl\n\n"}
{"name":"StarAlgHom.coe_toNonUnitalStarAlgHom","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Star A\ninst✝² : Semiring B\ninst✝¹ : Algebra R B\ninst✝ : Star B\nf : StarAlgHom R A B\n⊢ Eq ⇑f.toNonUnitalStarAlgHom ⇑f","decl":"@[simp]\ntheorem coe_toNonUnitalStarAlgHom (f : A →⋆ₐ[R] B) : (f.toNonUnitalStarAlgHom : A → B) = f :=\n  rfl\n\n"}
{"name":"NonUnitalStarAlgHom.fst_apply","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : Monoid R\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : Star A\ninst✝² : NonUnitalNonAssocSemiring B\ninst✝¹ : DistribMulAction R B\ninst✝ : Star B\nself : Prod A B\n⊢ Eq ((NonUnitalStarAlgHom.fst R A B) self) self.1","decl":"/-- The first projection of a product is a non-unital ⋆-algebra homomorphism. -/\n@[simps!]\ndef fst : A × B →⋆ₙₐ[R] A :=\n  { NonUnitalAlgHom.fst R A B with map_star' := fun _ => rfl }\n\n"}
{"name":"NonUnitalStarAlgHom.snd_apply","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : Monoid R\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : Star A\ninst✝² : NonUnitalNonAssocSemiring B\ninst✝¹ : DistribMulAction R B\ninst✝ : Star B\nself : Prod A B\n⊢ Eq ((NonUnitalStarAlgHom.snd R A B) self) self.2","decl":"/-- The second projection of a product is a non-unital ⋆-algebra homomorphism. -/\n@[simps!]\ndef snd : A × B →⋆ₙₐ[R] B :=\n  { NonUnitalAlgHom.snd R A B with map_star' := fun _ => rfl }\n\n"}
{"name":"NonUnitalStarAlgHom.prod_apply","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁹ : Monoid R\ninst✝⁸ : NonUnitalNonAssocSemiring A\ninst✝⁷ : DistribMulAction R A\ninst✝⁶ : Star A\ninst✝⁵ : NonUnitalNonAssocSemiring B\ninst✝⁴ : DistribMulAction R B\ninst✝³ : Star B\ninst✝² : NonUnitalNonAssocSemiring C\ninst✝¹ : DistribMulAction R C\ninst✝ : Star C\nf : NonUnitalStarAlgHom R A B\ng : NonUnitalStarAlgHom R A C\ni : A\n⊢ Eq ((f.prod g) i) { fst := f i, snd := g i }","decl":"/-- The `Pi.prod` of two morphisms is a morphism. -/\n@[simps!]\ndef prod (f : A →⋆ₙₐ[R] B) (g : A →⋆ₙₐ[R] C) : A →⋆ₙₐ[R] B × C :=\n  { f.toNonUnitalAlgHom.prod g.toNonUnitalAlgHom with\n    map_star' := fun x => by simp [map_star, Prod.star_def] }\n\n"}
{"name":"NonUnitalStarAlgHom.coe_prod","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁹ : Monoid R\ninst✝⁸ : NonUnitalNonAssocSemiring A\ninst✝⁷ : DistribMulAction R A\ninst✝⁶ : Star A\ninst✝⁵ : NonUnitalNonAssocSemiring B\ninst✝⁴ : DistribMulAction R B\ninst✝³ : Star B\ninst✝² : NonUnitalNonAssocSemiring C\ninst✝¹ : DistribMulAction R C\ninst✝ : Star C\nf : NonUnitalStarAlgHom R A B\ng : NonUnitalStarAlgHom R A C\n⊢ Eq (⇑(f.prod g)) (Pi.prod ⇑f ⇑g)","decl":"theorem coe_prod (f : A →⋆ₙₐ[R] B) (g : A →⋆ₙₐ[R] C) : ⇑(f.prod g) = Pi.prod f g :=\n  rfl\n\n"}
{"name":"NonUnitalStarAlgHom.fst_prod","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁹ : Monoid R\ninst✝⁸ : NonUnitalNonAssocSemiring A\ninst✝⁷ : DistribMulAction R A\ninst✝⁶ : Star A\ninst✝⁵ : NonUnitalNonAssocSemiring B\ninst✝⁴ : DistribMulAction R B\ninst✝³ : Star B\ninst✝² : NonUnitalNonAssocSemiring C\ninst✝¹ : DistribMulAction R C\ninst✝ : Star C\nf : NonUnitalStarAlgHom R A B\ng : NonUnitalStarAlgHom R A C\n⊢ Eq ((NonUnitalStarAlgHom.fst R B C).comp (f.prod g)) f","decl":"@[simp]\ntheorem fst_prod (f : A →⋆ₙₐ[R] B) (g : A →⋆ₙₐ[R] C) : (fst R B C).comp (prod f g) = f := by\n  ext; rfl\n\n"}
{"name":"NonUnitalStarAlgHom.snd_prod","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁹ : Monoid R\ninst✝⁸ : NonUnitalNonAssocSemiring A\ninst✝⁷ : DistribMulAction R A\ninst✝⁶ : Star A\ninst✝⁵ : NonUnitalNonAssocSemiring B\ninst✝⁴ : DistribMulAction R B\ninst✝³ : Star B\ninst✝² : NonUnitalNonAssocSemiring C\ninst✝¹ : DistribMulAction R C\ninst✝ : Star C\nf : NonUnitalStarAlgHom R A B\ng : NonUnitalStarAlgHom R A C\n⊢ Eq ((NonUnitalStarAlgHom.snd R B C).comp (f.prod g)) g","decl":"@[simp]\ntheorem snd_prod (f : A →⋆ₙₐ[R] B) (g : A →⋆ₙₐ[R] C) : (snd R B C).comp (prod f g) = g := by\n  ext; rfl\n\n"}
{"name":"NonUnitalStarAlgHom.prod_fst_snd","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : Monoid R\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : Star A\ninst✝² : NonUnitalNonAssocSemiring B\ninst✝¹ : DistribMulAction R B\ninst✝ : Star B\n⊢ Eq ((NonUnitalStarAlgHom.fst R A B).prod (NonUnitalStarAlgHom.snd R A B)) 1","decl":"@[simp]\ntheorem prod_fst_snd : prod (fst R A B) (snd R A B) = 1 :=\n  DFunLike.coe_injective Pi.prod_fst_snd\n\n"}
{"name":"NonUnitalStarAlgHom.prodEquiv_apply","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁹ : Monoid R\ninst✝⁸ : NonUnitalNonAssocSemiring A\ninst✝⁷ : DistribMulAction R A\ninst✝⁶ : Star A\ninst✝⁵ : NonUnitalNonAssocSemiring B\ninst✝⁴ : DistribMulAction R B\ninst✝³ : Star B\ninst✝² : NonUnitalNonAssocSemiring C\ninst✝¹ : DistribMulAction R C\ninst✝ : Star C\nf : Prod (NonUnitalStarAlgHom R A B) (NonUnitalStarAlgHom R A C)\n⊢ Eq (NonUnitalStarAlgHom.prodEquiv f) (f.1.prod f.2)","decl":"/-- Taking the product of two maps with the same domain is equivalent to taking the product of\ntheir codomains. -/\n@[simps]\ndef prodEquiv : (A →⋆ₙₐ[R] B) × (A →⋆ₙₐ[R] C) ≃ (A →⋆ₙₐ[R] B × C) where\n  toFun f := f.1.prod f.2\n  invFun f := ((fst _ _ _).comp f, (snd _ _ _).comp f)\n  left_inv f := by ext <;> rfl\n  right_inv f := by ext <;> rfl\n\n"}
{"name":"NonUnitalStarAlgHom.prodEquiv_symm_apply","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁹ : Monoid R\ninst✝⁸ : NonUnitalNonAssocSemiring A\ninst✝⁷ : DistribMulAction R A\ninst✝⁶ : Star A\ninst✝⁵ : NonUnitalNonAssocSemiring B\ninst✝⁴ : DistribMulAction R B\ninst✝³ : Star B\ninst✝² : NonUnitalNonAssocSemiring C\ninst✝¹ : DistribMulAction R C\ninst✝ : Star C\nf : NonUnitalStarAlgHom R A (Prod B C)\n⊢ Eq (NonUnitalStarAlgHom.prodEquiv.symm f) { fst := (NonUnitalStarAlgHom.fst R B C).comp f, snd := (NonUnitalStarAlgHom.snd R B C).comp f }","decl":"/-- Taking the product of two maps with the same domain is equivalent to taking the product of\ntheir codomains. -/\n@[simps]\ndef prodEquiv : (A →⋆ₙₐ[R] B) × (A →⋆ₙₐ[R] C) ≃ (A →⋆ₙₐ[R] B × C) where\n  toFun f := f.1.prod f.2\n  invFun f := ((fst _ _ _).comp f, (snd _ _ _).comp f)\n  left_inv f := by ext <;> rfl\n  right_inv f := by ext <;> rfl\n\n"}
{"name":"NonUnitalStarAlgHom.coe_inl","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : Monoid R\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : StarAddMonoid A\ninst✝² : NonUnitalNonAssocSemiring B\ninst✝¹ : DistribMulAction R B\ninst✝ : StarAddMonoid B\n⊢ Eq ⇑(NonUnitalStarAlgHom.inl R A B) fun x => { fst := x, snd := 0 }","decl":"@[simp]\ntheorem coe_inl : (inl R A B : A → A × B) = fun x => (x, 0) :=\n  rfl\n\n"}
{"name":"NonUnitalStarAlgHom.inl_apply","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : Monoid R\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : StarAddMonoid A\ninst✝² : NonUnitalNonAssocSemiring B\ninst✝¹ : DistribMulAction R B\ninst✝ : StarAddMonoid B\nx : A\n⊢ Eq ((NonUnitalStarAlgHom.inl R A B) x) { fst := x, snd := 0 }","decl":"theorem inl_apply (x : A) : inl R A B x = (x, 0) :=\n  rfl\n\n"}
{"name":"NonUnitalStarAlgHom.coe_inr","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : Monoid R\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : StarAddMonoid A\ninst✝² : NonUnitalNonAssocSemiring B\ninst✝¹ : DistribMulAction R B\ninst✝ : StarAddMonoid B\n⊢ Eq (⇑(NonUnitalStarAlgHom.inr R A B)) (Prod.mk 0)","decl":"@[simp]\ntheorem coe_inr : (inr R A B : B → A × B) = Prod.mk 0 :=\n  rfl\n\n"}
{"name":"NonUnitalStarAlgHom.inr_apply","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : Monoid R\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : StarAddMonoid A\ninst✝² : NonUnitalNonAssocSemiring B\ninst✝¹ : DistribMulAction R B\ninst✝ : StarAddMonoid B\nx : B\n⊢ Eq ((NonUnitalStarAlgHom.inr R A B) x) { fst := 0, snd := x }","decl":"theorem inr_apply (x : B) : inr R A B x = (0, x) :=\n  rfl\n\n"}
{"name":"StarAlgHom.fst_apply","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Star A\ninst✝² : Semiring B\ninst✝¹ : Algebra R B\ninst✝ : Star B\nself : Prod A B\n⊢ Eq ((StarAlgHom.fst R A B) self) self.1","decl":"/-- The first projection of a product is a ⋆-algebra homomorphism. -/\n@[simps!]\ndef fst : A × B →⋆ₐ[R] A :=\n  { AlgHom.fst R A B with map_star' := fun _ => rfl }\n\n"}
{"name":"StarAlgHom.snd_apply","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Star A\ninst✝² : Semiring B\ninst✝¹ : Algebra R B\ninst✝ : Star B\nself : Prod A B\n⊢ Eq ((StarAlgHom.snd R A B) self) self.2","decl":"/-- The second projection of a product is a ⋆-algebra homomorphism. -/\n@[simps!]\ndef snd : A × B →⋆ₐ[R] B :=\n  { AlgHom.snd R A B with map_star' := fun _ => rfl }\n\n"}
{"name":"StarAlgHom.prod_apply","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁹ : CommSemiring R\ninst✝⁸ : Semiring A\ninst✝⁷ : Algebra R A\ninst✝⁶ : Star A\ninst✝⁵ : Semiring B\ninst✝⁴ : Algebra R B\ninst✝³ : Star B\ninst✝² : Semiring C\ninst✝¹ : Algebra R C\ninst✝ : Star C\nf : StarAlgHom R A B\ng : StarAlgHom R A C\nx : A\n⊢ Eq ((f.prod g) x) { fst := f x, snd := g x }","decl":"/-- The `Pi.prod` of two morphisms is a morphism. -/\n@[simps!]\ndef prod (f : A →⋆ₐ[R] B) (g : A →⋆ₐ[R] C) : A →⋆ₐ[R] B × C :=\n  { f.toAlgHom.prod g.toAlgHom with map_star' := fun x => by simp [Prod.star_def, map_star] }\n\n"}
{"name":"StarAlgHom.coe_prod","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁹ : CommSemiring R\ninst✝⁸ : Semiring A\ninst✝⁷ : Algebra R A\ninst✝⁶ : Star A\ninst✝⁵ : Semiring B\ninst✝⁴ : Algebra R B\ninst✝³ : Star B\ninst✝² : Semiring C\ninst✝¹ : Algebra R C\ninst✝ : Star C\nf : StarAlgHom R A B\ng : StarAlgHom R A C\n⊢ Eq (⇑(f.prod g)) (Pi.prod ⇑f ⇑g)","decl":"theorem coe_prod (f : A →⋆ₐ[R] B) (g : A →⋆ₐ[R] C) : ⇑(f.prod g) = Pi.prod f g :=\n  rfl\n\n"}
{"name":"StarAlgHom.fst_prod","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁹ : CommSemiring R\ninst✝⁸ : Semiring A\ninst✝⁷ : Algebra R A\ninst✝⁶ : Star A\ninst✝⁵ : Semiring B\ninst✝⁴ : Algebra R B\ninst✝³ : Star B\ninst✝² : Semiring C\ninst✝¹ : Algebra R C\ninst✝ : Star C\nf : StarAlgHom R A B\ng : StarAlgHom R A C\n⊢ Eq ((StarAlgHom.fst R B C).comp (f.prod g)) f","decl":"@[simp]\ntheorem fst_prod (f : A →⋆ₐ[R] B) (g : A →⋆ₐ[R] C) : (fst R B C).comp (prod f g) = f := by\n  ext; rfl\n\n"}
{"name":"StarAlgHom.snd_prod","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁹ : CommSemiring R\ninst✝⁸ : Semiring A\ninst✝⁷ : Algebra R A\ninst✝⁶ : Star A\ninst✝⁵ : Semiring B\ninst✝⁴ : Algebra R B\ninst✝³ : Star B\ninst✝² : Semiring C\ninst✝¹ : Algebra R C\ninst✝ : Star C\nf : StarAlgHom R A B\ng : StarAlgHom R A C\n⊢ Eq ((StarAlgHom.snd R B C).comp (f.prod g)) g","decl":"@[simp]\ntheorem snd_prod (f : A →⋆ₐ[R] B) (g : A →⋆ₐ[R] C) : (snd R B C).comp (prod f g) = g := by\n  ext; rfl\n\n"}
{"name":"StarAlgHom.prod_fst_snd","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Star A\ninst✝² : Semiring B\ninst✝¹ : Algebra R B\ninst✝ : Star B\n⊢ Eq ((StarAlgHom.fst R A B).prod (StarAlgHom.snd R A B)) 1","decl":"@[simp]\ntheorem prod_fst_snd : prod (fst R A B) (snd R A B) = 1 :=\n  DFunLike.coe_injective Pi.prod_fst_snd\n\n"}
{"name":"StarAlgHom.prodEquiv_symm_apply","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁹ : CommSemiring R\ninst✝⁸ : Semiring A\ninst✝⁷ : Algebra R A\ninst✝⁶ : Star A\ninst✝⁵ : Semiring B\ninst✝⁴ : Algebra R B\ninst✝³ : Star B\ninst✝² : Semiring C\ninst✝¹ : Algebra R C\ninst✝ : Star C\nf : StarAlgHom R A (Prod B C)\n⊢ Eq (StarAlgHom.prodEquiv.symm f) { fst := (StarAlgHom.fst R B C).comp f, snd := (StarAlgHom.snd R B C).comp f }","decl":"/-- Taking the product of two maps with the same domain is equivalent to taking the product of\ntheir codomains. -/\n@[simps]\ndef prodEquiv : (A →⋆ₐ[R] B) × (A →⋆ₐ[R] C) ≃ (A →⋆ₐ[R] B × C) where\n  toFun f := f.1.prod f.2\n  invFun f := ((fst _ _ _).comp f, (snd _ _ _).comp f)\n  left_inv f := by ext <;> rfl\n  right_inv f := by ext <;> rfl\n\n"}
{"name":"StarAlgHom.prodEquiv_apply","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁹ : CommSemiring R\ninst✝⁸ : Semiring A\ninst✝⁷ : Algebra R A\ninst✝⁶ : Star A\ninst✝⁵ : Semiring B\ninst✝⁴ : Algebra R B\ninst✝³ : Star B\ninst✝² : Semiring C\ninst✝¹ : Algebra R C\ninst✝ : Star C\nf : Prod (StarAlgHom R A B) (StarAlgHom R A C)\n⊢ Eq (StarAlgHom.prodEquiv f) (f.1.prod f.2)","decl":"/-- Taking the product of two maps with the same domain is equivalent to taking the product of\ntheir codomains. -/\n@[simps]\ndef prodEquiv : (A →⋆ₐ[R] B) × (A →⋆ₐ[R] C) ≃ (A →⋆ₐ[R] B × C) where\n  toFun f := f.1.prod f.2\n  invFun f := ((fst _ _ _).comp f, (snd _ _ _).comp f)\n  left_inv f := by ext <;> rfl\n  right_inv f := by ext <;> rfl\n\n"}
{"name":"StarAlgEquiv.map_smul'","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁷ : Add A\ninst✝⁶ : Add B\ninst✝⁵ : Mul A\ninst✝⁴ : Mul B\ninst✝³ : SMul R A\ninst✝² : SMul R B\ninst✝¹ : Star A\ninst✝ : Star B\nself : StarAlgEquiv R A B\nr : R\na : A\n⊢ Eq (self.toFun (HSMul.hSMul r a)) (HSMul.hSMul r (self.toFun a))","decl":"/-- A *⋆-algebra* equivalence is an equivalence preserving addition, multiplication, scalar\nmultiplication and the star operation, which allows for considering both unital and non-unital\nequivalences with a single structure. Currently, `AlgEquiv` requires unital algebras, which is\nwhy this structure does not extend it. -/\nstructure StarAlgEquiv (R A B : Type*) [Add A] [Add B] [Mul A] [Mul B] [SMul R A] [SMul R B]\n  [Star A] [Star B] extends A ≃+* B where\n  /-- By definition, a ⋆-algebra equivalence preserves the `star` operation. -/\n  map_star' : ∀ a : A, toFun (star a) = star (toFun a)\n  /-- By definition, a ⋆-algebra equivalence commutes with the action of scalars. -/\n  map_smul' : ∀ (r : R) (a : A), toFun (r • a) = r • toFun a\n\n"}
{"name":"StarAlgEquiv.mk.sizeOf_spec","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝¹⁰ : Add A\ninst✝⁹ : Add B\ninst✝⁸ : Mul A\ninst✝⁷ : Mul B\ninst✝⁶ : SMul R A\ninst✝⁵ : SMul R B\ninst✝⁴ : Star A\ninst✝³ : Star B\ninst✝² : SizeOf R\ninst✝¹ : SizeOf A\ninst✝ : SizeOf B\ntoRingEquiv : RingEquiv A B\nmap_star' : ∀ (a : A), Eq (toRingEquiv.toFun (Star.star a)) (Star.star (toRingEquiv.toFun a))\nmap_smul' : ∀ (r : R) (a : A), Eq (toRingEquiv.toFun (HSMul.hSMul r a)) (HSMul.hSMul r (toRingEquiv.toFun a))\n⊢ Eq (SizeOf.sizeOf { toRingEquiv := toRingEquiv, map_star' := map_star', map_smul' := map_smul' }) (HAdd.hAdd 1 (SizeOf.sizeOf toRingEquiv))","decl":"/-- A *⋆-algebra* equivalence is an equivalence preserving addition, multiplication, scalar\nmultiplication and the star operation, which allows for considering both unital and non-unital\nequivalences with a single structure. Currently, `AlgEquiv` requires unital algebras, which is\nwhy this structure does not extend it. -/\nstructure StarAlgEquiv (R A B : Type*) [Add A] [Add B] [Mul A] [Mul B] [SMul R A] [SMul R B]\n  [Star A] [Star B] extends A ≃+* B where\n  /-- By definition, a ⋆-algebra equivalence preserves the `star` operation. -/\n  map_star' : ∀ a : A, toFun (star a) = star (toFun a)\n  /-- By definition, a ⋆-algebra equivalence commutes with the action of scalars. -/\n  map_smul' : ∀ (r : R) (a : A), toFun (r • a) = r • toFun a\n\n"}
{"name":"StarAlgEquiv.mk.injEq","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁷ : Add A\ninst✝⁶ : Add B\ninst✝⁵ : Mul A\ninst✝⁴ : Mul B\ninst✝³ : SMul R A\ninst✝² : SMul R B\ninst✝¹ : Star A\ninst✝ : Star B\ntoRingEquiv✝ : RingEquiv A B\nmap_star'✝ : ∀ (a : A), Eq (toRingEquiv✝.toFun (Star.star a)) (Star.star (toRingEquiv✝.toFun a))\nmap_smul'✝ : ∀ (r : R) (a : A), Eq (toRingEquiv✝.toFun (HSMul.hSMul r a)) (HSMul.hSMul r (toRingEquiv✝.toFun a))\ntoRingEquiv : RingEquiv A B\nmap_star' : ∀ (a : A), Eq (toRingEquiv.toFun (Star.star a)) (Star.star (toRingEquiv.toFun a))\nmap_smul' : ∀ (r : R) (a : A), Eq (toRingEquiv.toFun (HSMul.hSMul r a)) (HSMul.hSMul r (toRingEquiv.toFun a))\n⊢ Eq (Eq { toRingEquiv := toRingEquiv✝, map_star' := map_star'✝, map_smul' := map_smul'✝ } { toRingEquiv := toRingEquiv, map_star' := map_star', map_smul' := map_smul' }) (Eq toRingEquiv✝ toRingEquiv)","decl":"/-- A *⋆-algebra* equivalence is an equivalence preserving addition, multiplication, scalar\nmultiplication and the star operation, which allows for considering both unital and non-unital\nequivalences with a single structure. Currently, `AlgEquiv` requires unital algebras, which is\nwhy this structure does not extend it. -/\nstructure StarAlgEquiv (R A B : Type*) [Add A] [Add B] [Mul A] [Mul B] [SMul R A] [SMul R B]\n  [Star A] [Star B] extends A ≃+* B where\n  /-- By definition, a ⋆-algebra equivalence preserves the `star` operation. -/\n  map_star' : ∀ a : A, toFun (star a) = star (toFun a)\n  /-- By definition, a ⋆-algebra equivalence commutes with the action of scalars. -/\n  map_smul' : ∀ (r : R) (a : A), toFun (r • a) = r • toFun a\n\n"}
{"name":"StarAlgEquiv.map_star'","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁷ : Add A\ninst✝⁶ : Add B\ninst✝⁵ : Mul A\ninst✝⁴ : Mul B\ninst✝³ : SMul R A\ninst✝² : SMul R B\ninst✝¹ : Star A\ninst✝ : Star B\nself : StarAlgEquiv R A B\na : A\n⊢ Eq (self.toFun (Star.star a)) (Star.star (self.toFun a))","decl":"/-- A *⋆-algebra* equivalence is an equivalence preserving addition, multiplication, scalar\nmultiplication and the star operation, which allows for considering both unital and non-unital\nequivalences with a single structure. Currently, `AlgEquiv` requires unital algebras, which is\nwhy this structure does not extend it. -/\nstructure StarAlgEquiv (R A B : Type*) [Add A] [Add B] [Mul A] [Mul B] [SMul R A] [SMul R B]\n  [Star A] [Star B] extends A ≃+* B where\n  /-- By definition, a ⋆-algebra equivalence preserves the `star` operation. -/\n  map_star' : ∀ a : A, toFun (star a) = star (toFun a)\n  /-- By definition, a ⋆-algebra equivalence commutes with the action of scalars. -/\n  map_smul' : ∀ (r : R) (a : A), toFun (r • a) = r • toFun a\n\n"}
{"name":"StarAlgEquiv.mk.inj","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁷ : Add A\ninst✝⁶ : Add B\ninst✝⁵ : Mul A\ninst✝⁴ : Mul B\ninst✝³ : SMul R A\ninst✝² : SMul R B\ninst✝¹ : Star A\ninst✝ : Star B\ntoRingEquiv✝ : RingEquiv A B\nmap_star'✝ : ∀ (a : A), Eq (toRingEquiv✝.toFun (Star.star a)) (Star.star (toRingEquiv✝.toFun a))\nmap_smul'✝ : ∀ (r : R) (a : A), Eq (toRingEquiv✝.toFun (HSMul.hSMul r a)) (HSMul.hSMul r (toRingEquiv✝.toFun a))\ntoRingEquiv : RingEquiv A B\nmap_star' : ∀ (a : A), Eq (toRingEquiv.toFun (Star.star a)) (Star.star (toRingEquiv.toFun a))\nmap_smul' : ∀ (r : R) (a : A), Eq (toRingEquiv.toFun (HSMul.hSMul r a)) (HSMul.hSMul r (toRingEquiv.toFun a))\nx✝ : Eq { toRingEquiv := toRingEquiv✝, map_star' := map_star'✝, map_smul' := map_smul'✝ } { toRingEquiv := toRingEquiv, map_star' := map_star', map_smul' := map_smul' }\n⊢ Eq toRingEquiv✝ toRingEquiv","decl":"/-- A *⋆-algebra* equivalence is an equivalence preserving addition, multiplication, scalar\nmultiplication and the star operation, which allows for considering both unital and non-unital\nequivalences with a single structure. Currently, `AlgEquiv` requires unital algebras, which is\nwhy this structure does not extend it. -/\nstructure StarAlgEquiv (R A B : Type*) [Add A] [Add B] [Mul A] [Mul B] [SMul R A] [SMul R B]\n  [Star A] [Star B] extends A ≃+* B where\n  /-- By definition, a ⋆-algebra equivalence preserves the `star` operation. -/\n  map_star' : ∀ a : A, toFun (star a) = star (toFun a)\n  /-- By definition, a ⋆-algebra equivalence commutes with the action of scalars. -/\n  map_smul' : ∀ (r : R) (a : A), toFun (r • a) = r • toFun a\n\n"}
{"name":"NonUnitalAlgEquivClass.toRingEquivClass","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"F : Type u_1\nR : outParam (Type u_2)\nA : outParam (Type u_3)\nB : outParam (Type u_4)\ninst✝⁶ : Add A\ninst✝⁵ : Mul A\ninst✝⁴ : SMul R A\ninst✝³ : Add B\ninst✝² : Mul B\ninst✝¹ : SMul R B\ninst✝ : EquivLike F A B\nself : NonUnitalAlgEquivClass F R A B\n⊢ RingEquivClass F A B","decl":"/-- The class that directly extends `RingEquivClass` and `SMulHomClass`.\n\nMostly an implementation detail for `StarAlgEquivClass`.\n-/\nclass NonUnitalAlgEquivClass (F : Type*) (R A B : outParam Type*)\n  [Add A] [Mul A] [SMul R A] [Add B] [Mul B] [SMul R B] [EquivLike F A B]\n  extends RingEquivClass F A B, MulActionSemiHomClass F (@id R) A B : Prop where\n\n"}
{"name":"NonUnitalAlgEquivClass.toMulActionSemiHomClass","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"F : Type u_1\nR : outParam (Type u_2)\nA : outParam (Type u_3)\nB : outParam (Type u_4)\ninst✝⁶ : Add A\ninst✝⁵ : Mul A\ninst✝⁴ : SMul R A\ninst✝³ : Add B\ninst✝² : Mul B\ninst✝¹ : SMul R B\ninst✝ : EquivLike F A B\nself : NonUnitalAlgEquivClass F R A B\n⊢ MulActionSemiHomClass F id A B","decl":"/-- The class that directly extends `RingEquivClass` and `SMulHomClass`.\n\nMostly an implementation detail for `StarAlgEquivClass`.\n-/\nclass NonUnitalAlgEquivClass (F : Type*) (R A B : outParam Type*)\n  [Add A] [Mul A] [SMul R A] [Add B] [Mul B] [SMul R B] [EquivLike F A B]\n  extends RingEquivClass F A B, MulActionSemiHomClass F (@id R) A B : Prop where\n\n"}
{"name":"StarAlgEquivClass.map_star","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"F : Type u_1\nR : outParam (Type u_2)\nA : outParam (Type u_3)\nB : outParam (Type u_4)\ninst✝⁹ : Add A\ninst✝⁸ : Mul A\ninst✝⁷ : SMul R A\ninst✝⁶ : Star A\ninst✝⁵ : Add B\ninst✝⁴ : Mul B\ninst✝³ : SMul R B\ninst✝² : Star B\ninst✝¹ : EquivLike F A B\ninst✝ : NonUnitalAlgEquivClass F R A B\nself : StarAlgEquivClass F R A B\nf : F\na : A\n⊢ Eq (f (Star.star a)) (Star.star (f a))","decl":"/-- `StarAlgEquivClass F R A B` asserts `F` is a type of bundled ⋆-algebra equivalences between\n`A` and `B`.\nYou should also extend this typeclass when you extend `StarAlgEquiv`. -/\n@[deprecated StarHomClass (since := \"2024-09-08\")]\nclass StarAlgEquivClass (F : Type*) (R A B : outParam Type*)\n  [Add A] [Mul A] [SMul R A] [Star A] [Add B] [Mul B] [SMul R B]\n  [Star B] [EquivLike F A B] [NonUnitalAlgEquivClass F R A B] : Prop where\n  /-- By definition, a ⋆-algebra equivalence preserves the `star` operation. -/\n  protected map_star : ∀ (f : F) (a : A), f (star a) = star (f a)\n\n"}
{"name":"StarAlgEquivClass.instNonUnitalAlgHomClassOfNonUnitalAlgEquivClass","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"F : Type u_1\nR : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁶ : Monoid R\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : DistribMulAction R A\ninst✝³ : NonUnitalNonAssocSemiring B\ninst✝² : DistribMulAction R B\ninst✝¹ : EquivLike F A B\ninst✝ : NonUnitalAlgEquivClass F R A B\n⊢ NonUnitalAlgHomClass F R A B","decl":"instance (priority := 100) {F R A B : Type*} [Monoid R] [NonUnitalNonAssocSemiring A]\n    [DistribMulAction R A] [NonUnitalNonAssocSemiring B] [DistribMulAction R B] [EquivLike F A B]\n    [NonUnitalAlgEquivClass F R A B] :\n    NonUnitalAlgHomClass F R A B :=\n  { }\n\n-- See note [lower instance priority]\n"}
{"name":"StarAlgEquivClass.instAlgHomClass","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"F : Type u_1\nR : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Semiring B\ninst✝² : Algebra R B\ninst✝¹ : EquivLike F A B\ninst✝ : NonUnitalAlgEquivClass F R A B\n⊢ AlgEquivClass F R A B","decl":"instance (priority := 100) instAlgHomClass (F R A B : Type*) [CommSemiring R] [Semiring A]\n    [Algebra R A] [Semiring B] [Algebra R B] [EquivLike F A B] [NonUnitalAlgEquivClass F R A B] :\n    AlgEquivClass F R A B :=\n  { commutes := fun f r => by simp only [Algebra.algebraMap_eq_smul_one, map_smul, map_one] }\n\n"}
{"name":"StarAlgEquiv.instNonUnitalAlgEquivClass","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁷ : Add A\ninst✝⁶ : Add B\ninst✝⁵ : Mul A\ninst✝⁴ : Mul B\ninst✝³ : SMul R A\ninst✝² : SMul R B\ninst✝¹ : Star A\ninst✝ : Star B\n⊢ NonUnitalAlgEquivClass (StarAlgEquiv R A B) R A B","decl":"instance : NonUnitalAlgEquivClass (A ≃⋆ₐ[R] B) R A B where\n  map_mul f := f.map_mul'\n  map_add f := f.map_add'\n  map_smulₛₗ := map_smul'\n\n"}
{"name":"StarAlgEquiv.instStarHomClass","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁷ : Add A\ninst✝⁶ : Add B\ninst✝⁵ : Mul A\ninst✝⁴ : Mul B\ninst✝³ : SMul R A\ninst✝² : SMul R B\ninst✝¹ : Star A\ninst✝ : Star B\n⊢ StarHomClass (StarAlgEquiv R A B) A B","decl":"instance : StarHomClass (A ≃⋆ₐ[R] B) A B where\n  map_star := map_star'\n\n"}
{"name":"StarAlgEquiv.toRingEquiv_eq_coe","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁷ : Add A\ninst✝⁶ : Add B\ninst✝⁵ : Mul A\ninst✝⁴ : Mul B\ninst✝³ : SMul R A\ninst✝² : SMul R B\ninst✝¹ : Star A\ninst✝ : Star B\ne : StarAlgEquiv R A B\n⊢ Eq e.toRingEquiv ↑e","decl":"@[simp]\ntheorem toRingEquiv_eq_coe (e : A ≃⋆ₐ[R] B) : e.toRingEquiv = e :=\n  rfl\n\n"}
{"name":"StarAlgEquiv.ext","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁷ : Add A\ninst✝⁶ : Add B\ninst✝⁵ : Mul A\ninst✝⁴ : Mul B\ninst✝³ : SMul R A\ninst✝² : SMul R B\ninst✝¹ : Star A\ninst✝ : Star B\nf g : StarAlgEquiv R A B\nh : ∀ (a : A), Eq (f a) (g a)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {f g : A ≃⋆ₐ[R] B} (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"StarAlgEquiv.ext_iff","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁷ : Add A\ninst✝⁶ : Add B\ninst✝⁵ : Mul A\ninst✝⁴ : Mul B\ninst✝³ : SMul R A\ninst✝² : SMul R B\ninst✝¹ : Star A\ninst✝ : Star B\nf g : StarAlgEquiv R A B\n⊢ Iff (Eq f g) (∀ (a : A), Eq (f a) (g a))","decl":"@[ext]\ntheorem ext {f g : A ≃⋆ₐ[R] B} (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"StarAlgEquiv.coe_refl","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\ninst✝³ : Add A\ninst✝² : Mul A\ninst✝¹ : SMul R A\ninst✝ : Star A\n⊢ Eq (⇑StarAlgEquiv.refl) id","decl":"@[simp]\ntheorem coe_refl : ⇑(refl : A ≃⋆ₐ[R] A) = id :=\n  rfl\n\n-- Porting note: changed proof a bit by using `EquivLike` to avoid lots of coercions\n"}
{"name":"StarAlgEquiv.invFun_eq_symm","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁷ : Add A\ninst✝⁶ : Add B\ninst✝⁵ : Mul A\ninst✝⁴ : Mul B\ninst✝³ : SMul R A\ninst✝² : SMul R B\ninst✝¹ : Star A\ninst✝ : Star B\ne : StarAlgEquiv R A B\n⊢ Eq (EquivLike.inv e) ⇑e.symm","decl":"@[simp]\ntheorem invFun_eq_symm {e : A ≃⋆ₐ[R] B} : EquivLike.inv e = e.symm :=\n  rfl\n\n"}
{"name":"StarAlgEquiv.symm_symm","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁷ : Add A\ninst✝⁶ : Add B\ninst✝⁵ : Mul A\ninst✝⁴ : Mul B\ninst✝³ : SMul R A\ninst✝² : SMul R B\ninst✝¹ : Star A\ninst✝ : Star B\ne : StarAlgEquiv R A B\n⊢ Eq e.symm.symm e","decl":"@[simp]\ntheorem symm_symm (e : A ≃⋆ₐ[R] B) : e.symm.symm = e := rfl\n\n"}
{"name":"StarAlgEquiv.symm_bijective","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁷ : Add A\ninst✝⁶ : Add B\ninst✝⁵ : Mul A\ninst✝⁴ : Mul B\ninst✝³ : SMul R A\ninst✝² : SMul R B\ninst✝¹ : Star A\ninst✝ : Star B\n⊢ Function.Bijective StarAlgEquiv.symm","decl":"theorem symm_bijective : Function.Bijective (symm : (A ≃⋆ₐ[R] B) → B ≃⋆ₐ[R] A) :=\n  Function.bijective_iff_has_inverse.mpr ⟨_, symm_symm, symm_symm⟩\n\n"}
{"name":"StarAlgEquiv.coe_mk","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁷ : Add A\ninst✝⁶ : Add B\ninst✝⁵ : Mul A\ninst✝⁴ : Mul B\ninst✝³ : SMul R A\ninst✝² : SMul R B\ninst✝¹ : Star A\ninst✝ : Star B\ne : RingEquiv A B\nh₁ : ∀ (a : A), Eq (e.toFun (Star.star a)) (Star.star (e.toFun a))\nh₂ : ∀ (r : R) (a : A), Eq (e.toFun (HSMul.hSMul r a)) (HSMul.hSMul r (e.toFun a))\n⊢ Eq ⇑{ toRingEquiv := e, map_star' := h₁, map_smul' := h₂ } ⇑e","decl":"@[simp]\ntheorem coe_mk (e h₁ h₂) : ⇑(⟨e, h₁, h₂⟩ : A ≃⋆ₐ[R] B) = e := rfl\n\n"}
{"name":"StarAlgEquiv.mk_coe","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁷ : Add A\ninst✝⁶ : Add B\ninst✝⁵ : Mul A\ninst✝⁴ : Mul B\ninst✝³ : SMul R A\ninst✝² : SMul R B\ninst✝¹ : Star A\ninst✝ : Star B\ne : StarAlgEquiv R A B\ne' : B → A\nh₁ : Function.LeftInverse e' ⇑e\nh₂ : Function.RightInverse e' ⇑e\nh₃ : ∀ (x y : A), Eq ({ toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂ }.toFun (HMul.hMul x y)) (HMul.hMul ({ toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂ }.toFun x) ({ toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂ }.toFun y))\nh₄ : ∀ (x y : A), Eq ({ toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂ }.toFun (HAdd.hAdd x y)) (HAdd.hAdd ({ toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂ }.toFun x) ({ toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂ }.toFun y))\nh₅ : ∀ (a : A), Eq ({ toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂, map_mul' := h₃, map_add' := h₄ }.toFun (Star.star a)) (Star.star ({ toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂, map_mul' := h₃, map_add' := h₄ }.toFun a))\nh₆ : ∀ (r : R) (a : A), Eq ({ toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂, map_mul' := h₃, map_add' := h₄ }.toFun (HSMul.hSMul r a)) (HSMul.hSMul r ({ toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂, map_mul' := h₃, map_add' := h₄ }.toFun a))\n⊢ Eq { toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂, map_mul' := h₃, map_add' := h₄, map_star' := h₅, map_smul' := h₆ } e","decl":"@[simp]\ntheorem mk_coe (e : A ≃⋆ₐ[R] B) (e' h₁ h₂ h₃ h₄ h₅ h₆) :\n    (⟨⟨⟨e, e', h₁, h₂⟩, h₃, h₄⟩, h₅, h₆⟩ : A ≃⋆ₐ[R] B) = e := ext fun _ => rfl\n\n"}
{"name":"StarAlgEquiv.symm_mk","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁷ : Add A\ninst✝⁶ : Add B\ninst✝⁵ : Mul A\ninst✝⁴ : Mul B\ninst✝³ : SMul R A\ninst✝² : SMul R B\ninst✝¹ : Star A\ninst✝ : Star B\nf : A → B\nf' : B → A\nh₁ : Function.LeftInverse f' f\nh₂ : Function.RightInverse f' f\nh₃ : ∀ (x y : A), Eq ({ toFun := f, invFun := f', left_inv := h₁, right_inv := h₂ }.toFun (HMul.hMul x y)) (HMul.hMul ({ toFun := f, invFun := f', left_inv := h₁, right_inv := h₂ }.toFun x) ({ toFun := f, invFun := f', left_inv := h₁, right_inv := h₂ }.toFun y))\nh₄ : ∀ (x y : A), Eq ({ toFun := f, invFun := f', left_inv := h₁, right_inv := h₂ }.toFun (HAdd.hAdd x y)) (HAdd.hAdd ({ toFun := f, invFun := f', left_inv := h₁, right_inv := h₂ }.toFun x) ({ toFun := f, invFun := f', left_inv := h₁, right_inv := h₂ }.toFun y))\nh₅ : ∀ (a : A), Eq ({ toFun := f, invFun := f', left_inv := h₁, right_inv := h₂, map_mul' := h₃, map_add' := h₄ }.toFun (Star.star a)) (Star.star ({ toFun := f, invFun := f', left_inv := h₁, right_inv := h₂, map_mul' := h₃, map_add' := h₄ }.toFun a))\nh₆ : ∀ (r : R) (a : A), Eq ({ toFun := f, invFun := f', left_inv := h₁, right_inv := h₂, map_mul' := h₃, map_add' := h₄ }.toFun (HSMul.hSMul r a)) (HSMul.hSMul r ({ toFun := f, invFun := f', left_inv := h₁, right_inv := h₂, map_mul' := h₃, map_add' := h₄ }.toFun a))\n⊢ Eq { toFun := f, invFun := f', left_inv := h₁, right_inv := h₂, map_mul' := h₃, map_add' := h₄, map_star' := h₅, map_smul' := h₆ }.symm\n    (let __src := StarAlgEquiv.symm_mk.aux f f' h₁ h₂ h₃ h₄ h₅ h₆;\n    { toFun := f', invFun := f, left_inv := ⋯, right_inv := ⋯, map_mul' := ⋯, map_add' := ⋯, map_star' := ⋯, map_smul' := ⋯ })","decl":"@[simp]\ntheorem symm_mk (f f') (h₁ h₂ h₃ h₄ h₅ h₆) :\n    (⟨⟨⟨f, f', h₁, h₂⟩, h₃, h₄⟩, h₅, h₆⟩ : A ≃⋆ₐ[R] B).symm =\n      { symm_mk.aux f f' h₁ h₂ h₃ h₄ h₅ h₆ with\n        toFun := f'\n        invFun := f } :=\n  rfl\n\n"}
{"name":"StarAlgEquiv.refl_symm","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\ninst✝³ : Add A\ninst✝² : Mul A\ninst✝¹ : SMul R A\ninst✝ : Star A\n⊢ Eq StarAlgEquiv.refl.symm StarAlgEquiv.refl","decl":"@[simp]\ntheorem refl_symm : (StarAlgEquiv.refl : A ≃⋆ₐ[R] A).symm = StarAlgEquiv.refl :=\n  rfl\n\n-- should be a `simp` lemma, but causes a linter timeout\n"}
{"name":"StarAlgEquiv.to_ringEquiv_symm","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁷ : Add A\ninst✝⁶ : Add B\ninst✝⁵ : Mul A\ninst✝⁴ : Mul B\ninst✝³ : SMul R A\ninst✝² : SMul R B\ninst✝¹ : Star A\ninst✝ : Star B\nf : StarAlgEquiv R A B\n⊢ Eq (↑f).symm ↑f.symm","decl":"theorem to_ringEquiv_symm (f : A ≃⋆ₐ[R] B) : (f : A ≃+* B).symm = f.symm :=\n  rfl\n\n"}
{"name":"StarAlgEquiv.symm_to_ringEquiv","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁷ : Add A\ninst✝⁶ : Add B\ninst✝⁵ : Mul A\ninst✝⁴ : Mul B\ninst✝³ : SMul R A\ninst✝² : SMul R B\ninst✝¹ : Star A\ninst✝ : Star B\ne : StarAlgEquiv R A B\n⊢ Eq (↑e.symm) (↑e).symm","decl":"@[simp]\ntheorem symm_to_ringEquiv (e : A ≃⋆ₐ[R] B) : (e.symm : B ≃+* A) = (e : A ≃+* B).symm :=\n  rfl\n\n"}
{"name":"StarAlgEquiv.apply_symm_apply","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁷ : Add A\ninst✝⁶ : Add B\ninst✝⁵ : Mul A\ninst✝⁴ : Mul B\ninst✝³ : SMul R A\ninst✝² : SMul R B\ninst✝¹ : Star A\ninst✝ : Star B\ne : StarAlgEquiv R A B\nx : B\n⊢ Eq (e (e.symm x)) x","decl":"@[simp]\ntheorem apply_symm_apply (e : A ≃⋆ₐ[R] B) : ∀ x, e (e.symm x) = x :=\n  e.toRingEquiv.apply_symm_apply\n\n"}
{"name":"StarAlgEquiv.symm_apply_apply","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁷ : Add A\ninst✝⁶ : Add B\ninst✝⁵ : Mul A\ninst✝⁴ : Mul B\ninst✝³ : SMul R A\ninst✝² : SMul R B\ninst✝¹ : Star A\ninst✝ : Star B\ne : StarAlgEquiv R A B\nx : A\n⊢ Eq (e.symm (e x)) x","decl":"@[simp]\ntheorem symm_apply_apply (e : A ≃⋆ₐ[R] B) : ∀ x, e.symm (e x) = x :=\n  e.toRingEquiv.symm_apply_apply\n\n"}
{"name":"StarAlgEquiv.symm_trans_apply","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\nC : Type u_5\ninst✝¹¹ : Add A\ninst✝¹⁰ : Add B\ninst✝⁹ : Mul A\ninst✝⁸ : Mul B\ninst✝⁷ : SMul R A\ninst✝⁶ : SMul R B\ninst✝⁵ : Star A\ninst✝⁴ : Star B\ninst✝³ : Add C\ninst✝² : Mul C\ninst✝¹ : SMul R C\ninst✝ : Star C\ne₁ : StarAlgEquiv R A B\ne₂ : StarAlgEquiv R B C\nx : C\n⊢ Eq ((e₁.trans e₂).symm x) (e₁.symm (e₂.symm x))","decl":"@[simp]\ntheorem symm_trans_apply (e₁ : A ≃⋆ₐ[R] B) (e₂ : B ≃⋆ₐ[R] C) (x : C) :\n    (e₁.trans e₂).symm x = e₁.symm (e₂.symm x) :=\n  rfl\n\n"}
{"name":"StarAlgEquiv.coe_trans","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\nC : Type u_5\ninst✝¹¹ : Add A\ninst✝¹⁰ : Add B\ninst✝⁹ : Mul A\ninst✝⁸ : Mul B\ninst✝⁷ : SMul R A\ninst✝⁶ : SMul R B\ninst✝⁵ : Star A\ninst✝⁴ : Star B\ninst✝³ : Add C\ninst✝² : Mul C\ninst✝¹ : SMul R C\ninst✝ : Star C\ne₁ : StarAlgEquiv R A B\ne₂ : StarAlgEquiv R B C\n⊢ Eq (⇑(e₁.trans e₂)) (Function.comp ⇑e₂ ⇑e₁)","decl":"@[simp]\ntheorem coe_trans (e₁ : A ≃⋆ₐ[R] B) (e₂ : B ≃⋆ₐ[R] C) : ⇑(e₁.trans e₂) = e₂ ∘ e₁ :=\n  rfl\n\n"}
{"name":"StarAlgEquiv.trans_apply","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\nC : Type u_5\ninst✝¹¹ : Add A\ninst✝¹⁰ : Add B\ninst✝⁹ : Mul A\ninst✝⁸ : Mul B\ninst✝⁷ : SMul R A\ninst✝⁶ : SMul R B\ninst✝⁵ : Star A\ninst✝⁴ : Star B\ninst✝³ : Add C\ninst✝² : Mul C\ninst✝¹ : SMul R C\ninst✝ : Star C\ne₁ : StarAlgEquiv R A B\ne₂ : StarAlgEquiv R B C\nx : A\n⊢ Eq ((e₁.trans e₂) x) (e₂ (e₁ x))","decl":"@[simp]\ntheorem trans_apply (e₁ : A ≃⋆ₐ[R] B) (e₂ : B ≃⋆ₐ[R] C) (x : A) : (e₁.trans e₂) x = e₂ (e₁ x) :=\n  rfl\n\n"}
{"name":"StarAlgEquiv.leftInverse_symm","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁷ : Add A\ninst✝⁶ : Add B\ninst✝⁵ : Mul A\ninst✝⁴ : Mul B\ninst✝³ : SMul R A\ninst✝² : SMul R B\ninst✝¹ : Star A\ninst✝ : Star B\ne : StarAlgEquiv R A B\n⊢ Function.LeftInverse ⇑e.symm ⇑e","decl":"theorem leftInverse_symm (e : A ≃⋆ₐ[R] B) : Function.LeftInverse e.symm e :=\n  e.left_inv\n\n"}
{"name":"StarAlgEquiv.rightInverse_symm","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"R : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁷ : Add A\ninst✝⁶ : Add B\ninst✝⁵ : Mul A\ninst✝⁴ : Mul B\ninst✝³ : SMul R A\ninst✝² : SMul R B\ninst✝¹ : Star A\ninst✝ : Star B\ne : StarAlgEquiv R A B\n⊢ Function.RightInverse ⇑e.symm ⇑e","decl":"theorem rightInverse_symm (e : A ≃⋆ₐ[R] B) : Function.RightInverse e.symm e :=\n  e.right_inv\n\n"}
{"name":"StarAlgEquiv.ofStarAlgHom_apply","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"F : Type u_1\nG : Type u_2\nR : Type u_3\nA : Type u_4\nB : Type u_5\ninst✝¹⁰ : Monoid R\ninst✝⁹ : NonUnitalNonAssocSemiring A\ninst✝⁸ : DistribMulAction R A\ninst✝⁷ : Star A\ninst✝⁶ : NonUnitalNonAssocSemiring B\ninst✝⁵ : DistribMulAction R B\ninst✝⁴ : Star B\ninst✝³ : FunLike F A B\ninst✝² : NonUnitalAlgHomClass F R A B\ninst✝¹ : StarHomClass F A B\ninst✝ : FunLike G B A\nf : F\ng : G\nh₁ : ∀ (x : A), Eq (g (f x)) x\nh₂ : ∀ (x : B), Eq (f (g x)) x\na : A\n⊢ Eq ((StarAlgEquiv.ofStarAlgHom f g h₁ h₂) a) (f a)","decl":"/-- If a (unital or non-unital) star algebra morphism has an inverse, it is an isomorphism of\nstar algebras. -/\n@[simps]\ndef ofStarAlgHom (f : F) (g : G) (h₁ : ∀ x, g (f x) = x) (h₂ : ∀ x, f (g x) = x) : A ≃⋆ₐ[R] B where\n  toFun := f\n  invFun := g\n  left_inv := h₁\n  right_inv := h₂\n  map_add' := map_add f\n  map_mul' := map_mul f\n  map_smul' := map_smul f\n  map_star' := map_star f\n\n"}
{"name":"StarAlgEquiv.ofStarAlgHom_symm_apply","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"F : Type u_1\nG : Type u_2\nR : Type u_3\nA : Type u_4\nB : Type u_5\ninst✝¹⁰ : Monoid R\ninst✝⁹ : NonUnitalNonAssocSemiring A\ninst✝⁸ : DistribMulAction R A\ninst✝⁷ : Star A\ninst✝⁶ : NonUnitalNonAssocSemiring B\ninst✝⁵ : DistribMulAction R B\ninst✝⁴ : Star B\ninst✝³ : FunLike F A B\ninst✝² : NonUnitalAlgHomClass F R A B\ninst✝¹ : StarHomClass F A B\ninst✝ : FunLike G B A\nf : F\ng : G\nh₁ : ∀ (x : A), Eq (g (f x)) x\nh₂ : ∀ (x : B), Eq (f (g x)) x\na : B\n⊢ Eq ((StarAlgEquiv.ofStarAlgHom f g h₁ h₂).symm a) (g a)","decl":"/-- If a (unital or non-unital) star algebra morphism has an inverse, it is an isomorphism of\nstar algebras. -/\n@[simps]\ndef ofStarAlgHom (f : F) (g : G) (h₁ : ∀ x, g (f x) = x) (h₂ : ∀ x, f (g x) = x) : A ≃⋆ₐ[R] B where\n  toFun := f\n  invFun := g\n  left_inv := h₁\n  right_inv := h₂\n  map_add' := map_add f\n  map_mul' := map_mul f\n  map_smul' := map_smul f\n  map_star' := map_star f\n\n"}
{"name":"StarAlgEquiv.coe_ofBijective","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"F : Type u_1\nR : Type u_3\nA : Type u_4\nB : Type u_5\ninst✝⁹ : Monoid R\ninst✝⁸ : NonUnitalNonAssocSemiring A\ninst✝⁷ : DistribMulAction R A\ninst✝⁶ : Star A\ninst✝⁵ : NonUnitalNonAssocSemiring B\ninst✝⁴ : DistribMulAction R B\ninst✝³ : Star B\ninst✝² : FunLike F A B\ninst✝¹ : NonUnitalAlgHomClass F R A B\ninst✝ : StarHomClass F A B\nf : F\nhf : Function.Bijective ⇑f\n⊢ Eq ⇑(StarAlgEquiv.ofBijective f hf) ⇑f","decl":"@[simp]\ntheorem coe_ofBijective {f : F} (hf : Function.Bijective f) :\n    (StarAlgEquiv.ofBijective f hf : A → B) = f :=\n  rfl\n\n"}
{"name":"StarAlgEquiv.ofBijective_apply","module":"Mathlib.Algebra.Star.StarAlgHom","initialProofState":"F : Type u_1\nR : Type u_3\nA : Type u_4\nB : Type u_5\ninst✝⁹ : Monoid R\ninst✝⁸ : NonUnitalNonAssocSemiring A\ninst✝⁷ : DistribMulAction R A\ninst✝⁶ : Star A\ninst✝⁵ : NonUnitalNonAssocSemiring B\ninst✝⁴ : DistribMulAction R B\ninst✝³ : Star B\ninst✝² : FunLike F A B\ninst✝¹ : NonUnitalAlgHomClass F R A B\ninst✝ : StarHomClass F A B\nf : F\nhf : Function.Bijective ⇑f\na : A\n⊢ Eq ((StarAlgEquiv.ofBijective f hf) a) (f a)","decl":"theorem ofBijective_apply {f : F} (hf : Function.Bijective f) (a : A) :\n    (StarAlgEquiv.ofBijective f hf) a = f a :=\n  rfl\n\n"}
