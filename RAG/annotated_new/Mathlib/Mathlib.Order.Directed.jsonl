{"name":"directedOn_iff_directed","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nr : α → α → Prop\ns : Set α\n⊢ Iff (DirectedOn r s) (Directed r Subtype.val)","decl":"theorem directedOn_iff_directed {s} : @DirectedOn α r s ↔ Directed r (Subtype.val : s → α) := by\n  simp only [DirectedOn, Directed, Subtype.exists, exists_and_left, exists_prop, Subtype.forall]\n  exact forall₂_congr fun x _ => by simp [And.comm, and_assoc]\n\n"}
{"name":"DirectedOn.directed_val","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nr : α → α → Prop\ns : Set α\na✝ : DirectedOn r s\n⊢ Directed r Subtype.val","decl":"alias ⟨DirectedOn.directed_val, _⟩ := directedOn_iff_directed\n\n"}
{"name":"directedOn_range","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nι : Sort w\nr : α → α → Prop\nf : ι → α\n⊢ Iff (Directed r f) (DirectedOn r (Set.range f))","decl":"theorem directedOn_range {f : ι → α} : Directed r f ↔ DirectedOn r (Set.range f) := by\n  simp_rw [Directed, DirectedOn, Set.forall_mem_range, Set.exists_range_iff]\n\n"}
{"name":"Directed.directedOn_range","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nι : Sort w\nr : α → α → Prop\nf : ι → α\na✝ : Directed r f\n⊢ DirectedOn r (Set.range f)","decl":"protected alias ⟨Directed.directedOn_range, _⟩ := directedOn_range\n\n"}
{"name":"directedOn_image","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nβ : Type v\nr : α → α → Prop\ns : Set β\nf : β → α\n⊢ Iff (DirectedOn r (Set.image f s)) (DirectedOn (Order.Preimage f r) s)","decl":"theorem directedOn_image {s : Set β} {f : β → α} :\n    DirectedOn r (f '' s) ↔ DirectedOn (f ⁻¹'o r) s := by\n  simp only [DirectedOn, Set.mem_image, exists_exists_and_eq_and, forall_exists_index, and_imp,\n    forall_apply_eq_imp_iff₂, Order.Preimage]\n\n"}
{"name":"DirectedOn.mono'","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nr r' : α → α → Prop\ns : Set α\nhs : DirectedOn r s\nh : ∀ ⦃a : α⦄, Membership.mem s a → ∀ ⦃b : α⦄, Membership.mem s b → r a b → r' a b\n⊢ DirectedOn r' s","decl":"theorem DirectedOn.mono' {s : Set α} (hs : DirectedOn r s)\n    (h : ∀ ⦃a⦄, a ∈ s → ∀ ⦃b⦄, b ∈ s → r a b → r' a b) : DirectedOn r' s := fun _ hx _ hy =>\n  let ⟨z, hz, hxz, hyz⟩ := hs _ hx _ hy\n  ⟨z, hz, h hx hz hxz, h hy hz hyz⟩\n\n"}
{"name":"DirectedOn.mono","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nr r' : α → α → Prop\ns : Set α\nh : DirectedOn r s\nH : ∀ ⦃a b : α⦄, r a b → r' a b\n⊢ DirectedOn r' s","decl":"theorem DirectedOn.mono {s : Set α} (h : DirectedOn r s) (H : ∀ ⦃a b⦄, r a b → r' a b) :\n    DirectedOn r' s :=\n  h.mono' fun _ _ _ _ h ↦ H h\n\n"}
{"name":"directed_comp","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nβ : Type v\nr : α → α → Prop\nι : Sort u_1\nf : ι → β\ng : β → α\n⊢ Iff (Directed r (Function.comp g f)) (Directed (Order.Preimage g r) f)","decl":"theorem directed_comp {ι} {f : ι → β} {g : β → α} : Directed r (g ∘ f) ↔ Directed (g ⁻¹'o r) f :=\n  Iff.rfl\n\n"}
{"name":"Directed.mono","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nr s : α → α → Prop\nι : Sort u_1\nf : ι → α\nH : ∀ (a b : α), r a b → s a b\nh : Directed r f\n⊢ Directed s f","decl":"theorem Directed.mono {s : α → α → Prop} {ι} {f : ι → α} (H : ∀ a b, r a b → s a b)\n    (h : Directed r f) : Directed s f := fun a b =>\n  let ⟨c, h₁, h₂⟩ := h a b\n  ⟨c, H _ _ h₁, H _ _ h₂⟩\n\n-- Porting note: due to some interaction with the local notation, `r` became explicit here in lean3\n"}
{"name":"Directed.mono_comp","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nβ : Type v\nr : α → α → Prop\nι : Sort u_1\nrb : β → β → Prop\ng : α → β\nf : ι → α\nhg : ∀ ⦃x y : α⦄, r x y → rb (g x) (g y)\nhf : Directed r f\n⊢ Directed rb (Function.comp g f)","decl":"theorem Directed.mono_comp (r : α → α → Prop) {ι} {rb : β → β → Prop} {g : α → β} {f : ι → α}\n    (hg : ∀ ⦃x y⦄, r x y → rb (g x) (g y)) (hf : Directed r f) : Directed rb (g ∘ f) :=\n  directed_comp.2 <| hf.mono hg\n\n"}
{"name":"DirectedOn.mono_comp","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nβ : Type v\nr : α → α → Prop\nrb : β → β → Prop\ng : α → β\ns : Set α\nhg : ∀ ⦃x y : α⦄, r x y → rb (g x) (g y)\nhf : DirectedOn r s\n⊢ DirectedOn rb (Set.image g s)","decl":"theorem DirectedOn.mono_comp {r : α → α → Prop} {rb : β → β → Prop} {g : α → β} {s : Set α}\n    (hg : ∀ ⦃x y⦄, r x y → rb (g x) (g y)) (hf : DirectedOn r s) : DirectedOn rb (g '' s) :=\n  directedOn_image.mpr (hf.mono hg)\n\n"}
{"name":"directedOn_of_sup_mem","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\nS : Set α\nH : ∀ ⦃i j : α⦄, Membership.mem S i → Membership.mem S j → Membership.mem S (Max.max i j)\n⊢ DirectedOn (fun x1 x2 => LE.le x1 x2) S","decl":"/-- A set stable by supremum is `≤`-directed. -/\ntheorem directedOn_of_sup_mem [SemilatticeSup α] {S : Set α}\n    (H : ∀ ⦃i j⦄, i ∈ S → j ∈ S → i ⊔ j ∈ S) : DirectedOn (· ≤ ·) S := fun a ha b hb =>\n  ⟨a ⊔ b, H ha hb, le_sup_left, le_sup_right⟩\n\n"}
{"name":"Directed.extend_bot","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nβ : Type v\nι : Sort w\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\ne : ι → β\nf : ι → α\nhf : Directed (fun x1 x2 => LE.le x1 x2) f\nhe : Function.Injective e\n⊢ Directed (fun x1 x2 => LE.le x1 x2) (Function.extend e f Bot.bot)","decl":"theorem Directed.extend_bot [Preorder α] [OrderBot α] {e : ι → β} {f : ι → α}\n    (hf : Directed (· ≤ ·) f) (he : Function.Injective e) :\n    Directed (· ≤ ·) (Function.extend e f ⊥) := by\n  intro a b\n  rcases (em (∃ i, e i = a)).symm with (ha | ⟨i, rfl⟩)\n  · use b\n    simp [Function.extend_apply' _ _ _ ha]\n  rcases (em (∃ i, e i = b)).symm with (hb | ⟨j, rfl⟩)\n  · use e i\n    simp [Function.extend_apply' _ _ _ hb]\n  rcases hf i j with ⟨k, hi, hj⟩\n  use e k\n  simp only [he.extend_apply, *, true_and]\n\n"}
{"name":"directedOn_of_inf_mem","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\nS : Set α\nH : ∀ ⦃i j : α⦄, Membership.mem S i → Membership.mem S j → Membership.mem S (Min.min i j)\n⊢ DirectedOn (fun x1 x2 => GE.ge x1 x2) S","decl":"/-- A set stable by infimum is `≥`-directed. -/\ntheorem directedOn_of_inf_mem [SemilatticeInf α] {S : Set α}\n    (H : ∀ ⦃i j⦄, i ∈ S → j ∈ S → i ⊓ j ∈ S) : DirectedOn (· ≥ ·) S :=\n  directedOn_of_sup_mem (α := αᵒᵈ) H\n\n"}
{"name":"IsTotal.directed","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nι : Sort w\nr : α → α → Prop\ninst✝ : IsTotal α r\nf : ι → α\n⊢ Directed r f","decl":"theorem IsTotal.directed [IsTotal α r] (f : ι → α) : Directed r f := fun i j =>\n  Or.casesOn (total_of r (f i) (f j)) (fun h => ⟨j, h, refl _⟩) fun h => ⟨i, refl _, h⟩\n\n"}
{"name":"IsDirected.directed","module":"Mathlib.Order.Directed","initialProofState":"α : Type u_1\nr : α → α → Prop\nself : IsDirected α r\na b : α\n⊢ Exists fun c => And (r a c) (r b c)","decl":"/-- `IsDirected α r` states that for any elements `a`, `b` there exists an element `c` such that\n`r a c` and `r b c`. -/\nclass IsDirected (α : Type*) (r : α → α → Prop) : Prop where\n  /-- For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` -/\n  directed (a b : α) : ∃ c, r a c ∧ r b c\n\n"}
{"name":"directed_of","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsDirected α r\na b : α\n⊢ Exists fun c => And (r a c) (r b c)","decl":"theorem directed_of (r : α → α → Prop) [IsDirected α r] (a b : α) : ∃ c, r a c ∧ r b c :=\n  IsDirected.directed _ _\n\n"}
{"name":"directed_of₃","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝¹ : IsDirected α r\ninst✝ : IsTrans α r\na b c : α\n⊢ Exists fun d => And (r a d) (And (r b d) (r c d))","decl":"theorem directed_of₃ (r : α → α → Prop) [IsDirected α r] [IsTrans α r] (a b c : α) :\n    ∃ d, r a d ∧ r b d ∧ r c d :=\n  have ⟨e, hae, hbe⟩ := directed_of r a b\n  have ⟨f, hef, hcf⟩ := directed_of r e c\n  ⟨f, Trans.trans hae hef, Trans.trans hbe hef, hcf⟩\n\n"}
{"name":"directed_id","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsDirected α r\n⊢ Directed r id","decl":"theorem directed_id [IsDirected α r] : Directed r id := directed_of r\n\n"}
{"name":"directed_id_iff","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nr : α → α → Prop\n⊢ Iff (Directed r id) (IsDirected α r)","decl":"theorem directed_id_iff : Directed r id ↔ IsDirected α r :=\n  ⟨fun h => ⟨h⟩, @directed_id _ _⟩\n\n"}
{"name":"directedOn_univ","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsDirected α r\n⊢ DirectedOn r Set.univ","decl":"theorem directedOn_univ [IsDirected α r] : DirectedOn r Set.univ := fun a _ b _ =>\n  let ⟨c, hc⟩ := directed_of r a b\n  ⟨c, trivial, hc⟩\n\n"}
{"name":"directedOn_univ_iff","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nr : α → α → Prop\n⊢ Iff (DirectedOn r Set.univ) (IsDirected α r)","decl":"theorem directedOn_univ_iff : DirectedOn r Set.univ ↔ IsDirected α r :=\n  ⟨fun h =>\n    ⟨fun a b =>\n      let ⟨c, _, hc⟩ := h a trivial b trivial\n      ⟨c, hc⟩⟩,\n    @directedOn_univ _ _⟩\n\n-- see Note [lower instance priority]\n"}
{"name":"IsTotal.to_isDirected","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsTotal α r\n⊢ IsDirected α r","decl":"instance (priority := 100) IsTotal.to_isDirected [IsTotal α r] : IsDirected α r :=\n  directed_id_iff.1 <| IsTotal.directed _\n\n"}
{"name":"isDirected_mono","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nr s : α → α → Prop\ninst✝ : IsDirected α r\nh : ∀ ⦃a b : α⦄, r a b → s a b\n⊢ IsDirected α s","decl":"theorem isDirected_mono [IsDirected α r] (h : ∀ ⦃a b⦄, r a b → s a b) : IsDirected α s :=\n  ⟨fun a b =>\n    let ⟨c, ha, hb⟩ := IsDirected.directed a b\n    ⟨c, h ha, h hb⟩⟩\n\n"}
{"name":"exists_ge_ge","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\ninst✝¹ : LE α\ninst✝ : IsDirected α fun x1 x2 => LE.le x1 x2\na b : α\n⊢ Exists fun c => And (LE.le a c) (LE.le b c)","decl":"theorem exists_ge_ge [LE α] [IsDirected α (· ≤ ·)] (a b : α) : ∃ c, a ≤ c ∧ b ≤ c :=\n  directed_of (· ≤ ·) a b\n\n"}
{"name":"exists_le_le","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\ninst✝¹ : LE α\ninst✝ : IsDirected α fun x1 x2 => GE.ge x1 x2\na b : α\n⊢ Exists fun c => And (LE.le c a) (LE.le c b)","decl":"theorem exists_le_le [LE α] [IsDirected α (· ≥ ·)] (a b : α) : ∃ c, c ≤ a ∧ c ≤ b :=\n  directed_of (· ≥ ·) a b\n\n"}
{"name":"OrderDual.isDirected_ge","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\ninst✝¹ : LE α\ninst✝ : IsDirected α fun x1 x2 => LE.le x1 x2\n⊢ IsDirected (OrderDual α) fun x1 x2 => GE.ge x1 x2","decl":"instance OrderDual.isDirected_ge [LE α] [IsDirected α (· ≤ ·)] : IsDirected αᵒᵈ (· ≥ ·) := by\n  assumption\n\n"}
{"name":"OrderDual.isDirected_le","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\ninst✝¹ : LE α\ninst✝ : IsDirected α fun x1 x2 => GE.ge x1 x2\n⊢ IsDirected (OrderDual α) fun x1 x2 => LE.le x1 x2","decl":"instance OrderDual.isDirected_le [LE α] [IsDirected α (· ≥ ·)] : IsDirected αᵒᵈ (· ≤ ·) := by\n  assumption\n\n"}
{"name":"directed_of_isDirected_le","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LE α\ninst✝ : IsDirected α fun x1 x2 => LE.le x1 x2\nf : α → β\nr : β → β → Prop\nH : ∀ ⦃i j : α⦄, LE.le i j → r (f i) (f j)\n⊢ Directed r f","decl":"/-- A monotone function on an upwards-directed type is directed. -/\ntheorem directed_of_isDirected_le [LE α] [IsDirected α (· ≤ ·)] {f : α → β} {r : β → β → Prop}\n    (H : ∀ ⦃i j⦄, i ≤ j → r (f i) (f j)) : Directed r f :=\n  directed_id.mono_comp _ H\n\n"}
{"name":"Monotone.directed_le","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nβ : Type v\ninst✝² : Preorder α\ninst✝¹ : IsDirected α fun x1 x2 => LE.le x1 x2\ninst✝ : Preorder β\nf : α → β\na✝ : Monotone f\n⊢ Directed (fun x1 x2 => LE.le x1 x2) f","decl":"theorem Monotone.directed_le [Preorder α] [IsDirected α (· ≤ ·)] [Preorder β] {f : α → β} :\n    Monotone f → Directed (· ≤ ·) f :=\n  directed_of_isDirected_le\n\n"}
{"name":"Antitone.directed_ge","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nβ : Type v\ninst✝² : Preorder α\ninst✝¹ : IsDirected α fun x1 x2 => LE.le x1 x2\ninst✝ : Preorder β\nf : α → β\nhf : Antitone f\n⊢ Directed (fun x1 x2 => GE.ge x1 x2) f","decl":"theorem Antitone.directed_ge [Preorder α] [IsDirected α (· ≤ ·)] [Preorder β] {f : α → β}\n    (hf : Antitone f) : Directed (· ≥ ·) f :=\n  directed_of_isDirected_le hf\n\n"}
{"name":"directed_of_isDirected_ge","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LE α\ninst✝ : IsDirected α fun x1 x2 => GE.ge x1 x2\nr : β → β → Prop\nf : α → β\nhf : ∀ (a₁ a₂ : α), LE.le a₁ a₂ → r (f a₂) (f a₁)\n⊢ Directed r f","decl":"/-- An antitone function on a downwards-directed type is directed. -/\ntheorem directed_of_isDirected_ge [LE α] [IsDirected α (· ≥ ·)] {r : β → β → Prop} {f : α → β}\n    (hf : ∀ a₁ a₂, a₁ ≤ a₂ → r (f a₂) (f a₁)) : Directed r f :=\n  directed_of_isDirected_le (α := αᵒᵈ) fun _ _ ↦ hf _ _\n\n"}
{"name":"Monotone.directed_ge","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nβ : Type v\ninst✝² : Preorder α\ninst✝¹ : IsDirected α fun x1 x2 => GE.ge x1 x2\ninst✝ : Preorder β\nf : α → β\nhf : Monotone f\n⊢ Directed (fun x1 x2 => GE.ge x1 x2) f","decl":"theorem Monotone.directed_ge [Preorder α] [IsDirected α (· ≥ ·)] [Preorder β] {f : α → β}\n    (hf : Monotone f) : Directed (· ≥ ·) f :=\n  directed_of_isDirected_ge hf\n\n"}
{"name":"Antitone.directed_le","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nβ : Type v\ninst✝² : Preorder α\ninst✝¹ : IsDirected α fun x1 x2 => GE.ge x1 x2\ninst✝ : Preorder β\nf : α → β\nhf : Antitone f\n⊢ Directed (fun x1 x2 => LE.le x1 x2) f","decl":"theorem Antitone.directed_le [Preorder α] [IsDirected α (· ≥ ·)] [Preorder β] {f : α → β}\n    (hf : Antitone f) : Directed (· ≤ ·) f :=\n  directed_of_isDirected_ge hf\n\n"}
{"name":"DirectedOn.insert","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nr : α → α → Prop\nh : Reflexive r\na : α\ns : Set α\nhd : DirectedOn r s\nha : ∀ (b : α), Membership.mem s b → Exists fun c => And (Membership.mem s c) (And (r a c) (r b c))\n⊢ DirectedOn r (Insert.insert a s)","decl":"protected theorem DirectedOn.insert (h : Reflexive r) (a : α) {s : Set α} (hd : DirectedOn r s)\n    (ha : ∀ b ∈ s, ∃ c ∈ s, a ≼ c ∧ b ≼ c) : DirectedOn r (insert a s) := by\n  rintro x (rfl | hx) y (rfl | hy)\n  · exact ⟨y, Set.mem_insert _ _, h _, h _⟩\n  · obtain ⟨w, hws, hwr⟩ := ha y hy\n    exact ⟨w, Set.mem_insert_of_mem _ hws, hwr⟩\n  · obtain ⟨w, hws, hwr⟩ := ha x hx\n    exact ⟨w, Set.mem_insert_of_mem _ hws, hwr.symm⟩\n  · obtain ⟨w, hws, hwr⟩ := hd x hx y hy\n    exact ⟨w, Set.mem_insert_of_mem _ hws, hwr⟩\n\n"}
{"name":"directedOn_singleton","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nr : α → α → Prop\nh : Reflexive r\na : α\n⊢ DirectedOn r (Singleton.singleton a)","decl":"theorem directedOn_singleton (h : Reflexive r) (a : α) : DirectedOn r ({a} : Set α) :=\n  fun x hx _ hy => ⟨x, hx, h _, hx.symm ▸ hy.symm ▸ h _⟩\n\n"}
{"name":"directedOn_pair","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nr : α → α → Prop\nh : Reflexive r\na b : α\nhab : r a b\n⊢ DirectedOn r (Insert.insert a (Singleton.singleton b))","decl":"theorem directedOn_pair (h : Reflexive r) {a b : α} (hab : a ≼ b) : DirectedOn r ({a, b} : Set α) :=\n  (directedOn_singleton h _).insert h _ fun c hc => ⟨c, hc, hc.symm ▸ hab, h _⟩\n\n"}
{"name":"directedOn_pair'","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nr : α → α → Prop\nh : Reflexive r\na b : α\nhab : r a b\n⊢ DirectedOn r (Insert.insert b (Singleton.singleton a))","decl":"theorem directedOn_pair' (h : Reflexive r) {a b : α} (hab : a ≼ b) :\n    DirectedOn r ({b, a} : Set α) := by\n  rw [Set.pair_comm]\n  apply directedOn_pair h hab\n\n"}
{"name":"IsMin.isBot","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\ninst✝¹ : Preorder α\na : α\ninst✝ : IsDirected α fun x1 x2 => GE.ge x1 x2\nh : IsMin a\n⊢ IsBot a","decl":"protected theorem IsMin.isBot [IsDirected α (· ≥ ·)] (h : IsMin a) : IsBot a := fun b =>\n  let ⟨_, hca, hcb⟩ := exists_le_le a b\n  (h hca).trans hcb\n\n"}
{"name":"IsMax.isTop","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\ninst✝¹ : Preorder α\na : α\ninst✝ : IsDirected α fun x1 x2 => LE.le x1 x2\nh : IsMax a\n⊢ IsTop a","decl":"protected theorem IsMax.isTop [IsDirected α (· ≤ ·)] (h : IsMax a) : IsTop a :=\n  h.toDual.isBot\n\n"}
{"name":"DirectedOn.is_bot_of_is_min","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\nhd : DirectedOn (fun x1 x2 => GE.ge x1 x2) s\nm : α\nhm : Membership.mem s m\nhmin : ∀ (a : α), Membership.mem s a → LE.le a m → LE.le m a\na : α\na✝ : Membership.mem s a\n⊢ LE.le m a","decl":"lemma DirectedOn.is_bot_of_is_min {s : Set α} (hd : DirectedOn (· ≥ ·) s)\n    {m} (hm : m ∈ s) (hmin : ∀ a ∈ s, a ≤ m → m ≤ a) : ∀ a ∈ s, m ≤ a := fun a as =>\n  let ⟨x, xs, xm, xa⟩ := hd m hm a as\n  (hmin x xs xm).trans xa\n\n"}
{"name":"DirectedOn.is_top_of_is_max","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\ninst✝ : Preorder α\ns : Set α\nhd : DirectedOn (fun x1 x2 => LE.le x1 x2) s\nm : α\nhm : Membership.mem s m\nhmax : ∀ (a : α), Membership.mem s a → LE.le m a → LE.le a m\na : α\na✝ : Membership.mem s a\n⊢ LE.le a m","decl":"lemma DirectedOn.is_top_of_is_max {s : Set α} (hd : DirectedOn (· ≤ ·) s)\n    {m} (hm : m ∈ s) (hmax : ∀ a ∈ s, m ≤ a → a ≤ m) : ∀ a ∈ s, a ≤ m :=\n  @DirectedOn.is_bot_of_is_min αᵒᵈ _ s hd m hm hmax\n\n"}
{"name":"isTop_or_exists_gt","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : IsDirected α fun x1 x2 => LE.le x1 x2\na : α\n⊢ Or (IsTop a) (Exists fun b => LT.lt a b)","decl":"theorem isTop_or_exists_gt [IsDirected α (· ≤ ·)] (a : α) : IsTop a ∨ ∃ b, a < b :=\n  (em (IsMax a)).imp IsMax.isTop not_isMax_iff.mp\n\n"}
{"name":"isBot_or_exists_lt","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : IsDirected α fun x1 x2 => GE.ge x1 x2\na : α\n⊢ Or (IsBot a) (Exists fun b => LT.lt b a)","decl":"theorem isBot_or_exists_lt [IsDirected α (· ≥ ·)] (a : α) : IsBot a ∨ ∃ b, b < a :=\n  @isTop_or_exists_gt αᵒᵈ _ _ a\n\n"}
{"name":"isBot_iff_isMin","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\ninst✝¹ : Preorder α\na : α\ninst✝ : IsDirected α fun x1 x2 => GE.ge x1 x2\n⊢ Iff (IsBot a) (IsMin a)","decl":"theorem isBot_iff_isMin [IsDirected α (· ≥ ·)] : IsBot a ↔ IsMin a :=\n  ⟨IsBot.isMin, IsMin.isBot⟩\n\n"}
{"name":"isTop_iff_isMax","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\ninst✝¹ : Preorder α\na : α\ninst✝ : IsDirected α fun x1 x2 => LE.le x1 x2\n⊢ Iff (IsTop a) (IsMax a)","decl":"theorem isTop_iff_isMax [IsDirected α (· ≤ ·)] : IsTop a ↔ IsMax a :=\n  ⟨IsTop.isMax, IsMax.isTop⟩\n\n"}
{"name":"exists_lt_of_directed_ge","module":"Mathlib.Order.Directed","initialProofState":"β : Type v\ninst✝² : PartialOrder β\ninst✝¹ : Nontrivial β\ninst✝ : IsDirected β fun x1 x2 => GE.ge x1 x2\n⊢ Exists fun a => Exists fun b => LT.lt a b","decl":"variable (β) in\ntheorem exists_lt_of_directed_ge [IsDirected β (· ≥ ·)] :\n    ∃ a b : β, a < b := by\n  rcases exists_pair_ne β with ⟨a, b, hne⟩\n  rcases isBot_or_exists_lt a with (ha | ⟨c, hc⟩)\n  exacts [⟨a, b, (ha b).lt_of_ne hne⟩, ⟨_, _, hc⟩]\n\n"}
{"name":"exists_lt_of_directed_le","module":"Mathlib.Order.Directed","initialProofState":"β : Type v\ninst✝² : PartialOrder β\ninst✝¹ : Nontrivial β\ninst✝ : IsDirected β fun x1 x2 => LE.le x1 x2\n⊢ Exists fun a => Exists fun b => LT.lt a b","decl":"variable (β) in\ntheorem exists_lt_of_directed_le [IsDirected β (· ≤ ·)] :\n    ∃ a b : β, a < b :=\n  let ⟨a, b, h⟩ := exists_lt_of_directed_ge βᵒᵈ\n  ⟨b, a, h⟩\n\n"}
{"name":"IsMin.not_isMax","module":"Mathlib.Order.Directed","initialProofState":"β : Type v\ninst✝² : PartialOrder β\ninst✝¹ : Nontrivial β\ninst✝ : IsDirected β fun x1 x2 => GE.ge x1 x2\nb : β\nhb : IsMin b\n⊢ Not (IsMax b)","decl":"protected theorem IsMin.not_isMax [IsDirected β (· ≥ ·)] {b : β} (hb : IsMin b) : ¬ IsMax b := by\n  intro hb'\n  obtain ⟨a, c, hac⟩ := exists_lt_of_directed_ge β\n  have := hb.isBot a\n  obtain rfl := (hb' <| this).antisymm this\n  exact hb'.not_lt hac\n\n"}
{"name":"IsMin.not_isMax'","module":"Mathlib.Order.Directed","initialProofState":"β : Type v\ninst✝² : PartialOrder β\ninst✝¹ : Nontrivial β\ninst✝ : IsDirected β fun x1 x2 => LE.le x1 x2\nb : β\nhb : IsMin b\n⊢ Not (IsMax b)","decl":"protected theorem IsMin.not_isMax' [IsDirected β (· ≤ ·)] {b : β} (hb : IsMin b) : ¬ IsMax b :=\n  fun hb' ↦ hb'.toDual.not_isMax hb.toDual\n\n"}
{"name":"IsMax.not_isMin","module":"Mathlib.Order.Directed","initialProofState":"β : Type v\ninst✝² : PartialOrder β\ninst✝¹ : Nontrivial β\ninst✝ : IsDirected β fun x1 x2 => LE.le x1 x2\nb : β\nhb : IsMax b\n⊢ Not (IsMin b)","decl":"protected theorem IsMax.not_isMin [IsDirected β (· ≤ ·)] {b : β} (hb : IsMax b) : ¬ IsMin b :=\n  fun hb' ↦ hb.toDual.not_isMax hb'.toDual\n\n"}
{"name":"IsMax.not_isMin'","module":"Mathlib.Order.Directed","initialProofState":"β : Type v\ninst✝² : PartialOrder β\ninst✝¹ : Nontrivial β\ninst✝ : IsDirected β fun x1 x2 => GE.ge x1 x2\nb : β\nhb : IsMax b\n⊢ Not (IsMin b)","decl":"protected theorem IsMax.not_isMin' [IsDirected β (· ≥ ·)] {b : β} (hb : IsMax b) : ¬ IsMin b :=\n  fun hb' ↦ hb'.toDual.not_isMin hb.toDual\n\n"}
{"name":"constant_of_monotone_antitone","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nβ : Type v\ninst✝² : PartialOrder β\ninst✝¹ : Preorder α\nf : α → β\ninst✝ : IsDirected α fun x1 x2 => LE.le x1 x2\nhf : Monotone f\nhf' : Antitone f\na b : α\n⊢ Eq (f a) (f b)","decl":"/-- If `f` is monotone and antitone on a directed order, then `f` is constant. -/\nlemma constant_of_monotone_antitone [IsDirected α (· ≤ ·)] (hf : Monotone f) (hf' : Antitone f)\n    (a b : α) : f a = f b := by\n  obtain ⟨c, hac, hbc⟩ := exists_ge_ge a b\n  exact le_antisymm ((hf hac).trans <| hf' hbc) ((hf hbc).trans <| hf' hac)\n\n"}
{"name":"constant_of_monotoneOn_antitoneOn","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PartialOrder β\ninst✝ : Preorder α\nf : α → β\ns : Set α\nhf : MonotoneOn f s\nhf' : AntitoneOn f s\nhs : DirectedOn (fun x1 x2 => LE.le x1 x2) s\na : α\na✝¹ : Membership.mem s a\nb : α\na✝ : Membership.mem s b\n⊢ Eq (f a) (f b)","decl":"/-- If `f` is monotone and antitone on a directed set `s`, then `f` is constant on `s`. -/\nlemma constant_of_monotoneOn_antitoneOn (hf : MonotoneOn f s) (hf' : AntitoneOn f s)\n    (hs : DirectedOn (· ≤ ·) s) : ∀ ⦃a⦄, a ∈ s → ∀ ⦃b⦄, b ∈ s → f a = f b := by\n  rintro a ha b hb\n  obtain ⟨c, hc, hac, hbc⟩ := hs _ ha _ hb\n  exact le_antisymm ((hf ha hc hac).trans <| hf' hb hc hbc) ((hf hb hc hbc).trans <| hf' ha hc hac)\n\n"}
{"name":"SemilatticeSup.to_isDirected_le","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\ninst✝ : SemilatticeSup α\n⊢ IsDirected α fun x1 x2 => LE.le x1 x2","decl":"instance (priority := 100) SemilatticeSup.to_isDirected_le [SemilatticeSup α] :\n    IsDirected α (· ≤ ·) :=\n  ⟨fun a b => ⟨a ⊔ b, le_sup_left, le_sup_right⟩⟩\n\n-- see Note [lower instance priority]\n"}
{"name":"SemilatticeInf.to_isDirected_ge","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\ninst✝ : SemilatticeInf α\n⊢ IsDirected α fun x1 x2 => GE.ge x1 x2","decl":"instance (priority := 100) SemilatticeInf.to_isDirected_ge [SemilatticeInf α] :\n    IsDirected α (· ≥ ·) :=\n  ⟨fun a b => ⟨a ⊓ b, inf_le_left, inf_le_right⟩⟩\n\n-- see Note [lower instance priority]\n"}
{"name":"OrderTop.to_isDirected_le","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\ninst✝¹ : LE α\ninst✝ : OrderTop α\n⊢ IsDirected α fun x1 x2 => LE.le x1 x2","decl":"instance (priority := 100) OrderTop.to_isDirected_le [LE α] [OrderTop α] : IsDirected α (· ≤ ·) :=\n  ⟨fun _ _ => ⟨⊤, le_top _, le_top _⟩⟩\n\n-- see Note [lower instance priority]\n"}
{"name":"OrderBot.to_isDirected_ge","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\ninst✝¹ : LE α\ninst✝ : OrderBot α\n⊢ IsDirected α fun x1 x2 => GE.ge x1 x2","decl":"instance (priority := 100) OrderBot.to_isDirected_ge [LE α] [OrderBot α] : IsDirected α (· ≥ ·) :=\n  ⟨fun _ _ => ⟨⊥, bot_le _, bot_le _⟩⟩\n\n"}
{"name":"DirectedOn.proj","module":"Mathlib.Order.Directed","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nr : (i : ι) → α i → α i → Prop\nd : Set ((i : ι) → α i)\nhd : DirectedOn (fun x y => ∀ (i : ι), r i (x i) (y i)) d\ni : ι\n⊢ DirectedOn (r i) (Set.image (fun a => a i) d)","decl":"lemma proj {d : Set (Π i, α i)} (hd : DirectedOn (fun x y => ∀ i, r i (x i) (y i)) d) (i : ι) :\n    DirectedOn (r i) ((fun a => a i) '' d) :=\n  DirectedOn.mono_comp (fun _ _ h => h) (mono hd fun ⦃_ _⦄ h ↦ h i)\n\n"}
{"name":"DirectedOn.pi","module":"Mathlib.Order.Directed","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nr : (i : ι) → α i → α i → Prop\nd : (i : ι) → Set (α i)\nhd : ∀ (i : ι), DirectedOn (r i) (d i)\n⊢ DirectedOn (fun x y => ∀ (i : ι), r i (x i) (y i)) (Set.univ.pi d)","decl":"lemma pi {d : (i : ι) → Set (α i)} (hd : ∀ (i : ι), DirectedOn (r i) (d i)) :\n    DirectedOn (fun x y => ∀ i, r i (x i) (y i)) (Set.pi Set.univ d) := by\n  intro a ha b hb\n  choose f hfd haf hbf using fun i => hd i (a i) (ha i trivial) (b i) (hb i trivial)\n  exact ⟨f, fun i _ => hfd i, haf, hbf⟩\n\n"}
{"name":"DirectedOn.fst","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nβ : Type v\nr : α → α → Prop\nr₂ : β → β → Prop\nd : Set (Prod α β)\nhd : DirectedOn (fun p q => And (r p.1 q.1) (r₂ p.2 q.2)) d\n⊢ DirectedOn (fun x1 x2 => r x1 x2) (Set.image Prod.fst d)","decl":"lemma fst {d : Set (α × β)} (hd : DirectedOn (fun p q ↦ p.1 ≼₁ q.1 ∧ p.2 ≼₂ q.2) d) :\n    DirectedOn (· ≼₁ ·) (Prod.fst '' d) :=\n  DirectedOn.mono_comp (fun ⦃_ _⦄ h ↦ h) (mono hd fun ⦃_ _⦄ h ↦ h.1)\n\n"}
{"name":"DirectedOn.snd","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nβ : Type v\nr : α → α → Prop\nr₂ : β → β → Prop\nd : Set (Prod α β)\nhd : DirectedOn (fun p q => And (r p.1 q.1) (r₂ p.2 q.2)) d\n⊢ DirectedOn (fun x1 x2 => r₂ x1 x2) (Set.image Prod.snd d)","decl":"lemma snd {d : Set (α × β)} (hd : DirectedOn (fun p q ↦ p.1 ≼₁ q.1 ∧ p.2 ≼₂ q.2) d) :\n    DirectedOn (· ≼₂ ·) (Prod.snd '' d) :=\n  DirectedOn.mono_comp (fun ⦃_ _⦄ h ↦ h) (mono hd fun ⦃_ _⦄ h ↦ h.2)\n\n"}
{"name":"DirectedOn.prod","module":"Mathlib.Order.Directed","initialProofState":"α : Type u\nβ : Type v\nr : α → α → Prop\nr₂ : β → β → Prop\nd₁ : Set α\nd₂ : Set β\nh₁ : DirectedOn (fun x1 x2 => r x1 x2) d₁\nh₂ : DirectedOn (fun x1 x2 => r₂ x1 x2) d₂\n⊢ DirectedOn (fun p q => And (r p.1 q.1) (r₂ p.2 q.2)) (SProd.sprod d₁ d₂)","decl":"lemma prod {d₁ : Set α} {d₂ : Set β} (h₁ : DirectedOn (· ≼₁ ·) d₁) (h₂ : DirectedOn (· ≼₂ ·) d₂) :\n    DirectedOn (fun p q ↦ p.1 ≼₁ q.1 ∧ p.2 ≼₂ q.2) (d₁ ×ˢ d₂) := fun _ hpd _ hqd => by\n  obtain ⟨r₁, hdr₁, hpr₁, hqr₁⟩ := h₁ _ hpd.1 _ hqd.1\n  obtain ⟨r₂, hdr₂, hpr₂, hqr₂⟩ := h₂ _ hpd.2 _ hqd.2\n  exact ⟨⟨r₁, r₂⟩, ⟨hdr₁, hdr₂⟩, ⟨hpr₁, hpr₂⟩, ⟨hqr₁, hqr₂⟩⟩\n\n"}
