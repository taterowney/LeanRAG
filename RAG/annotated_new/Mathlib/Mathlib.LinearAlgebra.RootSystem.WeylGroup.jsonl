{"name":"RootPairing.reflection_mem_weylGroup","module":"Mathlib.LinearAlgebra.RootSystem.WeylGroup","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\n⊢ Membership.mem P.weylGroup (RootPairing.Equiv.reflection P i)","decl":"lemma reflection_mem_weylGroup : Equiv.reflection P i ∈ P.weylGroup :=\n  Subgroup.subset_closure <| mem_range_self i\n\n"}
{"name":"RootPairing.range_weylGroup_weightHom","module":"Mathlib.LinearAlgebra.RootSystem.WeylGroup","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ Eq ((RootPairing.Equiv.weightHom P).restrict P.weylGroup).range (Subgroup.closure (Set.range P.reflection))","decl":"lemma range_weylGroup_weightHom :\n    MonoidHom.range ((Equiv.weightHom P).restrict P.weylGroup) =\n      Subgroup.closure (range P.reflection) := by\n  refine (Subgroup.closure_eq_of_le _ ?_ ?_).symm\n  · rintro - ⟨i, rfl⟩\n    simp only [MonoidHom.restrict_range, Subgroup.coe_map, Equiv.weightHom_apply, mem_image,\n      SetLike.mem_coe]\n    use Equiv.reflection P i\n    exact ⟨reflection_mem_weylGroup P i, Equiv.reflection_weightEquiv P i⟩\n  · rintro fg ⟨⟨w, hw⟩, rfl⟩\n    induction hw using Subgroup.closure_induction'' with\n    | one =>\n      change ((Equiv.weightHom P).restrict P.weylGroup) 1 ∈ _\n      simpa only [map_one] using Subgroup.one_mem _\n    | mem w' hw' =>\n      obtain ⟨i, rfl⟩ := hw'\n      simp only [MonoidHom.restrict_apply, Equiv.weightHom_apply, Equiv.reflection_weightEquiv]\n      simpa only [reflection_mem_weylGroup] using Subgroup.subset_closure (mem_range_self i)\n    | inv_mem w' hw' =>\n      obtain ⟨i, rfl⟩ := hw'\n      simp only [Equiv.reflection_inv, MonoidHom.restrict_apply, Equiv.weightHom_apply,\n        Equiv.reflection_weightEquiv]\n      simpa only [reflection_mem_weylGroup] using Subgroup.subset_closure (mem_range_self i)\n    | mul w₁ w₂ hw₁ hw₂ h₁ h₂ =>\n      simpa only [← Submonoid.mk_mul_mk _ w₁ w₂ hw₁ hw₂, map_mul] using Subgroup.mul_mem _ h₁ h₂\n\n"}
{"name":"RootPairing.range_weylGroup_coweightHom","module":"Mathlib.LinearAlgebra.RootSystem.WeylGroup","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ Eq ((RootPairing.Equiv.coweightHom P).restrict P.weylGroup).range (Subgroup.closure (Set.range (Function.comp MulOpposite.op P.coreflection)))","decl":"lemma range_weylGroup_coweightHom :\n    MonoidHom.range ((Equiv.coweightHom P).restrict P.weylGroup) =\n      Subgroup.closure (range (MulOpposite.op ∘ P.coreflection)) := by\n  refine (Subgroup.closure_eq_of_le _ ?_ ?_).symm\n  · rintro - ⟨i, rfl⟩\n    simp only [MonoidHom.restrict_range, Subgroup.coe_map, Equiv.weightHom_apply, mem_image,\n      SetLike.mem_coe]\n    use Equiv.reflection P i\n    refine ⟨reflection_mem_weylGroup P i, by simp⟩\n  · rintro fg ⟨⟨w, hw⟩, rfl⟩\n    induction hw using Subgroup.closure_induction'' with\n    | one =>\n      change ((Equiv.coweightHom P).restrict P.weylGroup) 1 ∈ _\n      simpa only [map_one] using Subgroup.one_mem _\n    | mem w' hw' =>\n      obtain ⟨i, rfl⟩ := hw'\n      simp only [MonoidHom.restrict_apply, Equiv.coweightHom_apply, Equiv.reflection_coweightEquiv]\n      simpa only [reflection_mem_weylGroup] using Subgroup.subset_closure (mem_range_self i)\n    | inv_mem w' hw' =>\n      obtain ⟨i, rfl⟩ := hw'\n      simp only [Equiv.reflection_inv, MonoidHom.restrict_apply, Equiv.coweightHom_apply,\n        Equiv.reflection_coweightEquiv]\n      simpa only [reflection_mem_weylGroup] using Subgroup.subset_closure (mem_range_self i)\n    | mul w₁ w₂ hw₁ hw₂ h₁ h₂ =>\n      simpa only [← Submonoid.mk_mul_mk _ w₁ w₂ hw₁ hw₂, map_mul] using Subgroup.mul_mem _ h₁ h₂\n\n"}
{"name":"RootPairing.range_weylGroupToPerm","module":"Mathlib.LinearAlgebra.RootSystem.WeylGroup","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ Eq P.weylGroupToPerm.range (Subgroup.closure (Set.range P.reflection_perm))","decl":"lemma range_weylGroupToPerm :\n    P.weylGroupToPerm.range = Subgroup.closure (range P.reflection_perm) := by\n  refine (Subgroup.closure_eq_of_le _ ?_ ?_).symm\n  · rintro - ⟨i, rfl⟩\n    simp only [MonoidHom.restrict_range, Subgroup.coe_map, Equiv.weightHom_apply, mem_image,\n      SetLike.mem_coe]\n    use Equiv.reflection P i\n    refine ⟨reflection_mem_weylGroup P i, by simp⟩\n  · rintro fg ⟨⟨w, hw⟩, rfl⟩\n    induction hw using Subgroup.closure_induction'' with\n    | one =>\n      change ((Equiv.indexHom P).restrict P.weylGroup) 1 ∈ _\n      simpa only [map_one] using Subgroup.one_mem _\n    | mem w' hw' =>\n      obtain ⟨i, rfl⟩ := hw'\n      simp only [MonoidHom.restrict_apply, Equiv.indexHom_apply, Equiv.reflection_indexEquiv]\n      simpa only [reflection_mem_weylGroup] using Subgroup.subset_closure (mem_range_self i)\n    | inv_mem w' hw' =>\n      obtain ⟨i, rfl⟩ := hw'\n      simp only [Equiv.reflection_inv, MonoidHom.restrict_apply, Equiv.indexHom_apply,\n        Equiv.reflection_indexEquiv]\n      simpa only [reflection_mem_weylGroup] using Subgroup.subset_closure (mem_range_self i)\n    | mul w₁ w₂ hw₁ hw₂ h₁ h₂ =>\n      simpa only [← Submonoid.mk_mul_mk _ w₁ w₂ hw₁ hw₂, map_mul] using Subgroup.mul_mem _ h₁ h₂\n\n"}
