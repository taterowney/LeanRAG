{"name":"ENat.sum_iSup","module":"Mathlib.Data.ENat.BigOperators","initialProofState":"α : Type u_1\nι : Type u_2\ns : Finset α\nf : α → ι → ENat\nhf : ∀ (i j : ι), Exists fun k => ∀ (a : α), And (LE.le (f a i) (f a k)) (LE.le (f a j) (f a k))\n⊢ Eq (s.sum fun a => iSup fun i => f a i) (iSup fun i => s.sum fun a => f a i)","decl":"lemma sum_iSup {α ι : Type*} {s : Finset α} {f : α → ι → ℕ∞}\n    (hf : ∀ i j, ∃ k, ∀ a, f a i ≤ f a k ∧ f a j ≤ f a k) :\n    ∑ a ∈ s, ⨆ i, f a i = ⨆ i, ∑ a ∈ s, f a i := by\n  induction' s using Finset.cons_induction with a s ha ihs\n  · simp\n  simp_rw [Finset.sum_cons, ihs]\n  refine iSup_add_iSup fun i j ↦ (hf i j).imp fun k hk ↦ ?_\n  gcongr\n  exacts [(hk a).1, (hk _).2]\n\n"}
{"name":"ENat.sum_iSup_of_monotone","module":"Mathlib.Data.ENat.BigOperators","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝¹ : Preorder ι\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\ns : Finset α\nf : α → ι → ENat\nhf : ∀ (a : α), Monotone (f a)\n⊢ Eq (s.sum fun a => iSup (f a)) (iSup fun n => s.sum fun a => f a n)","decl":"lemma sum_iSup_of_monotone {α ι : Type*} [Preorder ι] [IsDirected ι (· ≤ ·)] {s : Finset α}\n    {f : α → ι → ℕ∞} (hf : ∀ a, Monotone (f a)) : (∑ a ∈ s, iSup (f a)) = ⨆ n, ∑ a ∈ s, f a n :=\n  sum_iSup fun i j ↦ (exists_ge_ge i j).imp fun _k ⟨hi, hj⟩ a ↦ ⟨hf a hi, hf a hj⟩\n\n"}
