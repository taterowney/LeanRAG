{"name":"FixedDetMatrices.ext'","module":"Mathlib.LinearAlgebra.Matrix.FixedDetMatrices","initialProofState":"n : Type u_1\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type u_2\ninst✝ : CommRing R\nm : R\nA B : FixedDetMatrix n R m\nh : Eq ↑A ↑B\n⊢ Eq A B","decl":"/--Extensionality theorem for `FixedDetMatrix` with respect to the underlying matrix, not\nentriwise. -/\nlemma ext' {m : R} {A B : FixedDetMatrix n R m} (h : A.1 = B.1) : A = B := by\n  cases A; cases B\n  congr\n\n"}
{"name":"FixedDetMatrices.ext_iff","module":"Mathlib.LinearAlgebra.Matrix.FixedDetMatrices","initialProofState":"n : Type u_1\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type u_2\ninst✝ : CommRing R\nm : R\nA B : FixedDetMatrix n R m\n⊢ Iff (Eq A B) (∀ (i j : n), Eq (↑A i j) (↑B i j))","decl":"@[ext]\nlemma ext {m : R} {A B : FixedDetMatrix n R m} (h : ∀ i j , A.1 i j = B.1 i j) : A = B := by\n  apply ext'\n  ext i j\n  apply h\n\n"}
{"name":"FixedDetMatrices.ext","module":"Mathlib.LinearAlgebra.Matrix.FixedDetMatrices","initialProofState":"n : Type u_1\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type u_2\ninst✝ : CommRing R\nm : R\nA B : FixedDetMatrix n R m\nh : ∀ (i j : n), Eq (↑A i j) (↑B i j)\n⊢ Eq A B","decl":"@[ext]\nlemma ext {m : R} {A B : FixedDetMatrix n R m} (h : ∀ i j , A.1 i j = B.1 i j) : A = B := by\n  apply ext'\n  ext i j\n  apply h\n\n"}
{"name":"FixedDetMatrices.smul_def","module":"Mathlib.LinearAlgebra.Matrix.FixedDetMatrices","initialProofState":"n : Type u_1\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type u_2\ninst✝ : CommRing R\nm : R\ng : Matrix.SpecialLinearGroup n R\nA : FixedDetMatrix n R m\n⊢ Eq (HSMul.hSMul g A) ⟨HMul.hMul ↑g ↑A, ⋯⟩","decl":"lemma smul_def (m : R) (g : SpecialLinearGroup n R) (A : (FixedDetMatrix n R m)) :\n    g • A = ⟨g * A.1, by simp only [det_mul, SpecialLinearGroup.det_coe, A.2, one_mul]⟩ :=\n  rfl\n\n"}
{"name":"FixedDetMatrices.smul_coe","module":"Mathlib.LinearAlgebra.Matrix.FixedDetMatrices","initialProofState":"n : Type u_1\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type u_2\ninst✝ : CommRing R\nm : R\ng : Matrix.SpecialLinearGroup n R\nA : FixedDetMatrix n R m\n⊢ Eq (↑(HSMul.hSMul g A)) (HMul.hMul ↑g ↑A)","decl":"lemma smul_coe (m : R) (g : SpecialLinearGroup n R) (A : FixedDetMatrix n R m) :\n    (g • A).1 = g * A.1 := by\n  rw [smul_def]\n\n"}
{"name":"FixedDetMatrices.reduce_of_pos","module":"Mathlib.LinearAlgebra.Matrix.FixedDetMatrices","initialProofState":"m : Int\nA : FixedDetMatrix (Fin 2) Int m\nhc : Eq (↑A 1 0) 0\nha : LT.lt 0 (↑A 0 0)\n⊢ Eq (FixedDetMatrices.reduce A) (HSMul.hSMul (HPow.hPow ModularGroup.T (Neg.neg (HDiv.hDiv (↑A 0 1) (↑A 1 1)))) A)","decl":"lemma reduce_of_pos {A : Δ m} (hc : (A.1 1 0) = 0) (ha : 0 < A.1 0 0) :\n    reduce A = (T ^ (-(A.1 0 1 / A.1 1 1))) • A := by\n  rw [reduce]\n  simp only [zpow_neg, Int.ediv_neg, neg_neg] at *\n  simp_rw [if_pos hc, if_pos ha]\n\n"}
{"name":"FixedDetMatrices.reduce_of_not_pos","module":"Mathlib.LinearAlgebra.Matrix.FixedDetMatrices","initialProofState":"m : Int\nA : FixedDetMatrix (Fin 2) Int m\nhc : Eq (↑A 1 0) 0\nha : Not (LT.lt 0 (↑A 0 0))\n⊢ Eq (FixedDetMatrices.reduce A) (HSMul.hSMul (HPow.hPow ModularGroup.T (Neg.neg (HDiv.hDiv (Neg.neg (↑A 0 1)) (Neg.neg (↑A 1 1))))) (HSMul.hSMul ModularGroup.S (HSMul.hSMul ModularGroup.S A)))","decl":"lemma reduce_of_not_pos {A : Δ m} (hc : (A.1 1 0) = 0) (ha : ¬ 0 < A.1 0 0) :\n    reduce A = (T ^ (-(-A.1 0 1 / -A.1 1 1))) • (S • (S • A)) := by\n  rw [reduce]\n  simp only [abs_eq_zero, zpow_neg, Int.ediv_neg, neg_neg] at *\n  simp_rw [if_pos hc, if_neg ha]\n\n"}
{"name":"FixedDetMatrices.reduce_reduceStep","module":"Mathlib.LinearAlgebra.Matrix.FixedDetMatrices","initialProofState":"m : Int\nA : FixedDetMatrix (Fin 2) Int m\nhc : Ne (↑A 1 0) 0\n⊢ Eq (FixedDetMatrices.reduce (FixedDetMatrices.reduceStep A)) (FixedDetMatrices.reduce A)","decl":"@[simp]\nlemma reduce_reduceStep {A : Δ m} (hc : (A.1 1 0) ≠ 0) :\n    reduce (reduceStep A) = reduce A := by\n  symm\n  rw [reduce, if_neg hc]\n\n"}
{"name":"FixedDetMatrices.reps_entries_le_m'","module":"Mathlib.LinearAlgebra.Matrix.FixedDetMatrices","initialProofState":"m : Int\nA : FixedDetMatrix (Fin 2) Int m\nh : Membership.mem (FixedDetMatrices.reps m) A\ni j : Fin 2\n⊢ Membership.mem (Finset.Icc (Neg.neg (abs m)) (abs m)) (↑A i j)","decl":"/--An auxiliary result bounding the size of the entries of the representatives in `reps`. -/\nlemma reps_entries_le_m' {A : Δ m} (h : A ∈ reps m) (i j : Fin 2) :\n    A.1 i j ∈ Finset.Icc (-|m|) |m| := by\n  suffices |A.1 i j| ≤ |m| from Finset.mem_Icc.mpr <| abs_le.mp this\n  obtain ⟨h10, h00, h01, h11⟩ := h\n  have h1 : 0 < |A.1 1 1| := (abs_nonneg _).trans_lt h11\n  have h2 : 0 < |A.1 0 0| := abs_pos.mpr h00.ne'\n  fin_cases i <;> fin_cases j\n  · simpa only [← abs_mul, A_c_eq_zero h10] using (le_mul_iff_one_le_right h2).mpr h1\n  · simpa only [← abs_mul, A_c_eq_zero h10] using h11.le.trans (le_mul_of_one_le_left h1.le h2)\n  · simp_all\n  · simpa only [← abs_mul, A_c_eq_zero h10] using (le_mul_iff_one_le_left h1).mpr h2\n\n"}
{"name":"FixedDetMatrices.reps_zero_empty","module":"Mathlib.LinearAlgebra.Matrix.FixedDetMatrices","initialProofState":"⊢ Eq (FixedDetMatrices.reps 0) EmptyCollection.emptyCollection","decl":"@[simp]\nlemma reps_zero_empty : reps 0 = ∅ := by\n  rw [reps, Set.eq_empty_iff_forall_not_mem]\n  rintro A ⟨h₁, h₂, -, h₄⟩\n  suffices |A.1 0 1| < 0 by linarith [abs_nonneg (A.1 0 1)]\n  have := A_c_eq_zero h₁\n  simp_all [h₂.ne']\n\n"}
{"name":"FixedDetMatrices.S_smul_four","module":"Mathlib.LinearAlgebra.Matrix.FixedDetMatrices","initialProofState":"m : Int\nA : FixedDetMatrix (Fin 2) Int m\n⊢ Eq (HSMul.hSMul ModularGroup.S (HSMul.hSMul ModularGroup.S (HSMul.hSMul ModularGroup.S (HSMul.hSMul ModularGroup.S A)))) A","decl":"@[simp]\nlemma S_smul_four (A : Δ m) : S • S • S • S • A = A := by\n  simp only [smul_def, ← mul_assoc, S_mul_S_eq, neg_mul, one_mul, mul_neg, neg_neg, Subtype.coe_eta]\n\n"}
{"name":"FixedDetMatrices.T_S_rel_smul","module":"Mathlib.LinearAlgebra.Matrix.FixedDetMatrices","initialProofState":"m : Int\nA : FixedDetMatrix (Fin 2) Int m\n⊢ Eq (HSMul.hSMul ModularGroup.S (HSMul.hSMul ModularGroup.S (HSMul.hSMul ModularGroup.S (HSMul.hSMul ModularGroup.T (HSMul.hSMul ModularGroup.S (HSMul.hSMul ModularGroup.T (HSMul.hSMul ModularGroup.S A))))))) (HSMul.hSMul (Inv.inv ModularGroup.T) A)","decl":"@[simp]\nlemma T_S_rel_smul (A : Δ m) : S • S • S • T • S • T • S • A = T⁻¹ • A := by\n  simp_rw [← T_S_rel, ← smul_assoc]\n\n"}
{"name":"FixedDetMatrices.reduce_mem_reps","module":"Mathlib.LinearAlgebra.Matrix.FixedDetMatrices","initialProofState":"m : Int\nhm : Ne m 0\nA : FixedDetMatrix (Fin 2) Int m\n⊢ Membership.mem (FixedDetMatrices.reps m) (FixedDetMatrices.reduce A)","decl":"lemma reduce_mem_reps {m : ℤ} (hm : m ≠ 0) (A : Δ m) : reduce A ∈ reps m := by\n  induction A using reduce_rec with\n  | step A h1 h2 => simpa only [reduce_reduceStep h1] using h2\n  | base A h =>\n    have hd := A_d_ne_zero h hm\n    by_cases h1 : 0 < A.1 0 0\n    · simp only [reduce_of_pos h h1]\n      have h2 := Int.emod_def (A.1 0 1) (A.1 1 1)\n      have h4 := Int.ediv_mul_le (A.1 0 1) hd\n      set n : ℤ := A.1 0 1 / A.1 1 1\n      have h3 := Int.emod_lt (A.1 0 1) hd\n      rw [← abs_eq_self.mpr <| Int.emod_nonneg _ hd] at h3\n      simp only [smul_def, Fin.isValue, coe_T_zpow]\n      suffices A.1 1 0 = 0 ∧ n * A.1 1 0 < A.1 0 0 ∧\n          n * A.1 1 1 ≤ A.1 0 1 ∧ |A.1 0 1 + -(n * A.1 1 1)| < |A.1 1 1| by\n        simpa only [reps, Fin.isValue, cons_mul, Nat.succ_eq_add_one, Nat.reduceAdd, empty_mul,\n          Equiv.symm_apply_apply, Set.mem_setOf_eq, of_apply, cons_val', vecMul, cons_dotProduct,\n          vecHead, one_mul, vecTail, Function.comp_apply, Fin.succ_zero_eq_one, neg_mul,\n          dotProduct_empty, add_zero, zero_mul, zero_add, empty_val', cons_val_fin_one,\n          cons_val_one, cons_val_zero, lt_add_neg_iff_add_lt, le_add_neg_iff_add_le]\n      simp_all only [h, mul_comm n, zero_mul, ← sub_eq_add_neg, ← h2,\n        Fin.isValue, h1, h3, and_true, true_and]\n    · simp only [reps, Fin.isValue, reduce_of_not_pos h h1, Int.ediv_neg, neg_neg, smul_def, ←\n        mul_assoc, S_mul_S_eq, neg_mul, one_mul, coe_T_zpow, mul_neg, cons_mul, Nat.succ_eq_add_one,\n        Nat.reduceAdd, empty_mul, Equiv.symm_apply_apply, neg_of, neg_cons, neg_empty,\n        Set.mem_setOf_eq, of_apply, cons_val', Pi.neg_apply, vecMul, cons_dotProduct, vecHead,\n        vecTail, Function.comp_apply, Fin.succ_zero_eq_one, h, mul_zero, dotProduct_empty, add_zero,\n        zero_mul, neg_zero, empty_val', cons_val_fin_one, cons_val_one, cons_val_zero, lt_neg,\n        neg_add_rev, zero_add, le_add_neg_iff_add_le, ← le_neg, abs_neg, true_and]\n      refine ⟨?_, Int.ediv_mul_le _ hd, ?_⟩\n      · simp only [Int.lt_iff_le_and_ne]\n        exact ⟨not_lt.mp h1, A_a_ne_zero h hm⟩\n      · rw [mul_comm, add_comm, ← Int.sub_eq_add_neg, ← Int.emod_def,\n         abs_eq_self.mpr <| Int.emod_nonneg _ hd]\n        exact Int.emod_lt _ hd\n\n"}
{"name":"FixedDetMatrices.induction_on","module":"Mathlib.LinearAlgebra.Matrix.FixedDetMatrices","initialProofState":"m : Int\nC : FixedDetMatrix (Fin 2) Int m → Prop\nA : FixedDetMatrix (Fin 2) Int m\nhm : Ne m 0\nh0 : ∀ (A : FixedDetMatrix (Fin 2) Int m), Eq (↑A 1 0) 0 → LT.lt 0 (↑A 0 0) → LE.le 0 (↑A 0 1) → LT.lt (abs (↑A 0 1)) (abs (↑A 1 1)) → C A\nhS : ∀ (B : FixedDetMatrix (Fin 2) Int m), C B → C (HSMul.hSMul ModularGroup.S B)\nhT : ∀ (B : FixedDetMatrix (Fin 2) Int m), C B → C (HSMul.hSMul ModularGroup.T B)\n⊢ C A","decl":"@[elab_as_elim]\ntheorem induction_on {C : Δ m → Prop} {A : Δ m} (hm : m ≠ 0)\n    (h0 : ∀ A : Δ m, A.1 1 0 = 0 → 0 < A.1 0 0 → 0 ≤ A.1 0 1 → |(A.1 0 1)| < |(A.1 1 1)| → C A)\n    (hS : ∀ B, C B → C (S • B)) (hT : ∀ B, C B → C (T • B)) : C A := by\n  have h_reduce : C (reduce A) := by\n    rcases reduce_mem_reps hm A with ⟨H1, H2, H3, H4⟩\n    exact h0 _ H1 H2 H3 H4\n  suffices ∀ A : Δ m, C (reduce A) → C A from this _ h_reduce\n  apply reduce_rec\n  · intro A h\n    by_cases h1 : 0 < A.1 0 0\n    · simp only [reduce_of_pos h h1, prop_red_T_pow hS hT, imp_self]\n    · simp only [reduce_of_not_pos h h1, prop_red_T_pow hS hT, prop_red_S hS, imp_self]\n  intro A hc ih hA\n  rw [← reduce_reduceStep hc] at hA\n  simpa only [reduceStep, prop_red_S hS, prop_red_T_pow hS hT] using ih hA\n\n"}
{"name":"FixedDetMatrices.reps_one_id","module":"Mathlib.LinearAlgebra.Matrix.FixedDetMatrices","initialProofState":"A : FixedDetMatrix (Fin 2) Int 1\na1 : Eq (↑A 1 0) 0\na4 : LT.lt 0 (↑A 0 0)\na6 : LT.lt (abs (↑A 0 1)) (abs (↑A 1 1))\n⊢ Eq A 1","decl":"lemma reps_one_id (A : FixedDetMatrix (Fin 2) ℤ 1) (a1 : A.1 1 0 = 0) (a4 : 0 < A.1 0 0)\n    (a6 : |A.1 0 1| < |(A.1 1 1)|) : A = (1 : SL(2, ℤ)) := by\n  have := Int.mul_eq_one_iff_eq_one_or_neg_one.mp (A_c_eq_zero a1)\n  ext i j\n  fin_cases i <;> fin_cases j <;> aesop\n\n"}
{"name":"SpecialLinearGroup.SL2Z_generators","module":"Mathlib.LinearAlgebra.Matrix.FixedDetMatrices","initialProofState":"⊢ Eq (Subgroup.closure (Insert.insert ModularGroup.S (Singleton.singleton ModularGroup.T))) Top.top","decl":"/-- `SL(2, ℤ)` is generated by `S` and `T`. -/\nlemma SpecialLinearGroup.SL2Z_generators : closure {S, T} = ⊤ := by\n  rw [eq_top_iff']\n  intro A\n  induction A using (induction_on one_ne_zero) with\n  | h0 A a1 a4 _ a6 =>\n    rw [reps_one_id A a1 a4 a6]\n    exact one_mem _\n  | hS B hb =>\n    exact mul_mem (subset_closure (Set.mem_insert S {T})) hb\n  | hT B hb =>\n    exact mul_mem (subset_closure (Set.mem_insert_of_mem S rfl)) hb\n\n"}
