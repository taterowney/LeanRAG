{"name":"Ideal.coe_torsionOf","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\n⊢ Eq (↑(Ideal.torsionOf R M x)) (Set.preimage (⇑(LinearMap.toSpanSingleton R M x)) (Singleton.singleton 0))","decl":"/-- The torsion ideal of `x`, containing all `a` such that `a • x = 0`. -/\n@[simps!]\ndef torsionOf (x : M) : Ideal R :=\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11036): broken dot notation on LinearMap.ker https://github.com/leanprover/lean4/issues/1629\n  LinearMap.ker (LinearMap.toSpanSingleton R M x)\n\n"}
{"name":"Ideal.torsionOf_zero","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (Ideal.torsionOf R M 0) Top.top","decl":"@[simp]\ntheorem torsionOf_zero : torsionOf R M (0 : M) = ⊤ := by simp [torsionOf]\n\n"}
{"name":"Ideal.mem_torsionOf_iff","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\na : R\n⊢ Iff (Membership.mem (Ideal.torsionOf R M x) a) (Eq (HSMul.hSMul a x) 0)","decl":"@[simp]\ntheorem mem_torsionOf_iff (x : M) (a : R) : a ∈ torsionOf R M x ↔ a • x = 0 :=\n  Iff.rfl\n\n"}
{"name":"Ideal.torsionOf_eq_top_iff","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nm : M\n⊢ Iff (Eq (Ideal.torsionOf R M m) Top.top) (Eq m 0)","decl":"@[simp]\ntheorem torsionOf_eq_top_iff (m : M) : torsionOf R M m = ⊤ ↔ m = 0 := by\n  refine ⟨fun h => ?_, fun h => by simp [h]⟩\n  rw [← one_smul R m, ← mem_torsionOf_iff m (1 : R), h]\n  exact Submodule.mem_top\n\n"}
{"name":"Ideal.torsionOf_eq_bot_iff_of_noZeroSMulDivisors","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Nontrivial R\ninst✝ : NoZeroSMulDivisors R M\nm : M\n⊢ Iff (Eq (Ideal.torsionOf R M m) Bot.bot) (Ne m 0)","decl":"@[simp]\ntheorem torsionOf_eq_bot_iff_of_noZeroSMulDivisors [Nontrivial R] [NoZeroSMulDivisors R M] (m : M) :\n    torsionOf R M m = ⊥ ↔ m ≠ 0 := by\n  refine ⟨fun h contra => ?_, fun h => (Submodule.eq_bot_iff _).mpr fun r hr => ?_⟩\n  · rw [contra, torsionOf_zero] at h\n    exact bot_ne_top.symm h\n  · rw [mem_torsionOf_iff, smul_eq_zero] at hr\n    tauto\n\n"}
{"name":"Ideal.iSupIndep.linearIndependent'","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"ι : Type u_3\nR : Type u_4\nM : Type u_5\nv : ι → M\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nhv : iSupIndep fun i => Submodule.span R (Singleton.singleton (v i))\nh_ne_zero : ∀ (i : ι), Eq (Ideal.torsionOf R M (v i)) Bot.bot\n⊢ LinearIndependent R v","decl":"/-- See also `iSupIndep.linearIndependent` which provides the same conclusion\nbut requires the stronger hypothesis `NoZeroSMulDivisors R M`. -/\ntheorem iSupIndep.linearIndependent' {ι R M : Type*} {v : ι → M} [Ring R]\n    [AddCommGroup M] [Module R M] (hv : iSupIndep fun i => R ∙ v i)\n    (h_ne_zero : ∀ i, Ideal.torsionOf R M (v i) = ⊥) : LinearIndependent R v := by\n  refine linearIndependent_iff_not_smul_mem_span.mpr fun i r hi => ?_\n  replace hv := iSupIndep_def.mp hv i\n  simp only [iSup_subtype', ← Submodule.span_range_eq_iSup (ι := Subtype _), disjoint_iff] at hv\n  have : r • v i ∈ (⊥ : Submodule R M) := by\n    rw [← hv, Submodule.mem_inf]\n    refine ⟨Submodule.mem_span_singleton.mpr ⟨r, rfl⟩, ?_⟩\n    convert hi\n    ext\n    simp\n  rw [← Submodule.mem_bot R, ← h_ne_zero i]\n  simpa using this\n\n"}
{"name":"Ideal.CompleteLattice.Independent.linear_independent'","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"ι : Type u_3\nR : Type u_4\nM : Type u_5\nv : ι → M\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nhv : iSupIndep fun i => Submodule.span R (Singleton.singleton (v i))\nh_ne_zero : ∀ (i : ι), Eq (Ideal.torsionOf R M (v i)) Bot.bot\n⊢ LinearIndependent R v","decl":"@[deprecated (since := \"2024-11-24\")]\nalias CompleteLattice.Independent.linear_independent' := iSupIndep.linearIndependent'\n\n"}
{"name":"Ideal.quotTorsionOfEquivSpanSingleton_apply_mk","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx : M\na : R\n⊢ Eq ((Ideal.quotTorsionOfEquivSpanSingleton R M x) (Submodule.Quotient.mk a)) (HSMul.hSMul a ⟨x, ⋯⟩)","decl":"@[simp]\ntheorem quotTorsionOfEquivSpanSingleton_apply_mk (x : M) (a : R) :\n    quotTorsionOfEquivSpanSingleton R M x (Submodule.Quotient.mk a) =\n      a • ⟨x, Submodule.mem_span_singleton_self x⟩ :=\n  rfl\n\n"}
{"name":"Submodule.coe_torsionBy","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na : R\n⊢ Eq (↑(Submodule.torsionBy R M a)) (Set.preimage (⇑(DistribMulAction.toLinearMap R M a)) (Singleton.singleton 0))","decl":"/-- The `a`-torsion submodule for `a` in `R`, containing all elements `x` of `M` such that\n  `a • x = 0`. -/\n@[simps!]\ndef torsionBy (a : R) : Submodule R M :=\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11036): broken dot notation on LinearMap.ker https://github.com/leanprover/lean4/issues/1629\n  LinearMap.ker (DistribMulAction.toLinearMap R M a)\n\n"}
{"name":"Submodule.coe_torsionBySet","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set R\n⊢ Eq (↑(Submodule.torsionBySet R M s)) (Set.iInter fun y => Set.iInter fun x => Set.preimage (⇑(DistribMulAction.toLinearMap R M y)) (Singleton.singleton 0))","decl":"/-- The submodule containing all elements `x` of `M` such that `a • x = 0` for all `a` in `s`. -/\n@[simps!]\ndef torsionBySet (s : Set R) : Submodule R M :=\n  sInf (torsionBy R M '' s)\n\n-- Porting note: torsion' had metavariables and factoring out this fixed it\n-- perhaps there is a better fix\n"}
{"name":"Submodule.coe_torsion'AddSubMonoid","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"M : Type u_2\ninst✝² : AddCommMonoid M\nS : Type u_3\ninst✝¹ : CommMonoid S\ninst✝ : DistribMulAction S M\n⊢ Eq (↑(Submodule.torsion'AddSubMonoid M S)) (setOf fun x => Exists fun a => Eq (HSMul.hSMul a x) 0)","decl":"/-- The additive submonoid of all elements `x` of `M` such that `a • x = 0`\nfor some `a` in `S`. -/\n@[simps!]\ndef torsion'AddSubMonoid (S : Type*) [CommMonoid S] [DistribMulAction S M] :\n    AddSubmonoid M where\n  carrier := { x | ∃ a : S, a • x = 0 }\n  add_mem' := by\n    intro x y ⟨a,hx⟩ ⟨b,hy⟩\n    use b * a\n    rw [smul_add, mul_smul, mul_comm, mul_smul, hx, hy, smul_zero, smul_zero, add_zero]\n  zero_mem' := ⟨1, smul_zero 1⟩\n\n"}
{"name":"Submodule.coe_torsion'","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nS : Type u_3\ninst✝² : CommMonoid S\ninst✝¹ : DistribMulAction S M\ninst✝ : SMulCommClass S R M\n⊢ Eq (↑(Submodule.torsion' R M S)) (setOf fun x => Exists fun a => Eq (HSMul.hSMul a x) 0)","decl":"/-- The `S`-torsion submodule, containing all elements `x` of `M` such that `a • x = 0` for some\n`a` in `S`. -/\n@[simps!]\ndef torsion' (S : Type*) [CommMonoid S] [DistribMulAction S M] [SMulCommClass S R M] :\n    Submodule R M :=\n  { torsion'AddSubMonoid M S with\n    smul_mem' := fun a x ⟨b, h⟩ => ⟨b, by rw [smul_comm, h, smul_zero]⟩}\n\n"}
{"name":"Module.isTorsionBySet_annihilator","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Module.IsTorsionBySet R M ↑(Module.annihilator R M)","decl":"theorem isTorsionBySet_annihilator : IsTorsionBySet R M (Module.annihilator R M) :=\n  fun _ r ↦ Module.mem_annihilator.mp r.2 _\n\n"}
{"name":"isSMulRegular_iff_torsionBy_eq_bot","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_2\nM : Type u_1\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nr : R\n⊢ Iff (IsSMulRegular M r) (Eq (Submodule.torsionBy R M r) Bot.bot)","decl":"lemma isSMulRegular_iff_torsionBy_eq_bot {R} (M : Type*)\n    [CommRing R] [AddCommGroup M] [Module R M] (r : R) :\n    IsSMulRegular M r ↔ Submodule.torsionBy R M r = ⊥ :=\n  Iff.symm (DistribMulAction.toLinearMap R M r).ker_eq_bot\n\n"}
{"name":"Submodule.smul_torsionBy","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na : R\nx : Subtype fun x => Membership.mem (Submodule.torsionBy R M a) x\n⊢ Eq (HSMul.hSMul a x) 0","decl":"@[simp]\ntheorem smul_torsionBy (x : torsionBy R M a) : a • x = 0 :=\n  Subtype.ext x.prop\n\n"}
{"name":"Submodule.smul_coe_torsionBy","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na : R\nx : Subtype fun x => Membership.mem (Submodule.torsionBy R M a) x\n⊢ Eq (HSMul.hSMul a ↑x) 0","decl":"@[simp]\ntheorem smul_coe_torsionBy (x : torsionBy R M a) : a • (x : M) = 0 :=\n  x.prop\n\n"}
{"name":"Submodule.mem_torsionBy_iff","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na : R\nx : M\n⊢ Iff (Membership.mem (Submodule.torsionBy R M a) x) (Eq (HSMul.hSMul a x) 0)","decl":"@[simp]\ntheorem mem_torsionBy_iff (x : M) : x ∈ torsionBy R M a ↔ a • x = 0 :=\n  Iff.rfl\n\n"}
{"name":"Submodule.mem_torsionBySet_iff","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set R\nx : M\n⊢ Iff (Membership.mem (Submodule.torsionBySet R M s) x) (∀ (a : ↑s), Eq (HSMul.hSMul (↑a) x) 0)","decl":"@[simp]\ntheorem mem_torsionBySet_iff (x : M) : x ∈ torsionBySet R M s ↔ ∀ a : s, (a : R) • x = 0 := by\n  refine ⟨fun h ⟨a, ha⟩ => mem_sInf.mp h _ (Set.mem_image_of_mem _ ha), fun h => mem_sInf.mpr ?_⟩\n  rintro _ ⟨a, ha, rfl⟩; exact h ⟨a, ha⟩\n\n"}
{"name":"Submodule.torsionBySet_singleton_eq","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na : R\n⊢ Eq (Submodule.torsionBySet R M (Singleton.singleton a)) (Submodule.torsionBy R M a)","decl":"@[simp]\ntheorem torsionBySet_singleton_eq : torsionBySet R M {a} = torsionBy R M a := by\n  ext x\n  simp only [mem_torsionBySet_iff, SetCoe.forall, Subtype.coe_mk, Set.mem_singleton_iff,\n    forall_eq, mem_torsionBy_iff]\n\n"}
{"name":"Submodule.torsionBySet_le_torsionBySet_of_subset","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns t : Set R\nst : HasSubset.Subset s t\n⊢ LE.le (Submodule.torsionBySet R M t) (Submodule.torsionBySet R M s)","decl":"theorem torsionBySet_le_torsionBySet_of_subset {s t : Set R} (st : s ⊆ t) :\n    torsionBySet R M t ≤ torsionBySet R M s :=\n  sInf_le_sInf fun _ ⟨a, ha, h⟩ => ⟨a, st ha, h⟩\n\n"}
{"name":"Submodule.torsionBySet_eq_torsionBySet_span","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set R\n⊢ Eq (Submodule.torsionBySet R M s) (Submodule.torsionBySet R M ↑(Ideal.span s))","decl":"/-- Torsion by a set is torsion by the ideal generated by it. -/\ntheorem torsionBySet_eq_torsionBySet_span :\n    torsionBySet R M s = torsionBySet R M (Ideal.span s) := by\n  refine le_antisymm (fun x hx => ?_) (torsionBySet_le_torsionBySet_of_subset subset_span)\n  rw [mem_torsionBySet_iff] at hx ⊢\n  suffices Ideal.span s ≤ Ideal.torsionOf R M x by\n    rintro ⟨a, ha⟩\n    exact this ha\n  rw [Ideal.span_le]\n  exact fun a ha => hx ⟨a, ha⟩\n\n"}
{"name":"Submodule.torsionBySet_span_singleton_eq","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na : R\n⊢ Eq (Submodule.torsionBySet R M ↑(Submodule.span R (Singleton.singleton a))) (Submodule.torsionBy R M a)","decl":"theorem torsionBySet_span_singleton_eq : torsionBySet R M (R ∙ a) = torsionBy R M a :=\n  (torsionBySet_eq_torsionBySet_span _).symm.trans <| torsionBySet_singleton_eq _\n\n"}
{"name":"Submodule.torsionBy_le_torsionBy_of_dvd","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na b : R\ndvd : Dvd.dvd a b\n⊢ LE.le (Submodule.torsionBy R M a) (Submodule.torsionBy R M b)","decl":"theorem torsionBy_le_torsionBy_of_dvd (a b : R) (dvd : a ∣ b) :\n    torsionBy R M a ≤ torsionBy R M b := by\n  rw [← torsionBySet_span_singleton_eq, ← torsionBySet_singleton_eq]\n  apply torsionBySet_le_torsionBySet_of_subset\n  rintro c (rfl : c = b); exact Ideal.mem_span_singleton.mpr dvd\n\n"}
{"name":"Submodule.torsionBy_one","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (Submodule.torsionBy R M 1) Bot.bot","decl":"@[simp]\ntheorem torsionBy_one : torsionBy R M 1 = ⊥ :=\n  eq_bot_iff.mpr fun _ h => by\n    rw [mem_torsionBy_iff, one_smul] at h\n    exact h\n\n"}
{"name":"Submodule.torsionBySet_univ","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (Submodule.torsionBySet R M Set.univ) Bot.bot","decl":"@[simp]\ntheorem torsionBySet_univ : torsionBySet R M Set.univ = ⊥ := by\n  rw [eq_bot_iff, ← torsionBy_one, ← torsionBySet_singleton_eq]\n  exact torsionBySet_le_torsionBySet_of_subset fun _ _ => trivial\n\n"}
{"name":"Module.isTorsionBySet_singleton_iff","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na : R\n⊢ Iff (Module.IsTorsionBySet R M (Singleton.singleton a)) (Module.IsTorsionBy R M a)","decl":"@[simp]\ntheorem isTorsionBySet_singleton_iff : IsTorsionBySet R M {a} ↔ IsTorsionBy R M a := by\n  refine ⟨fun h x => @h _ ⟨_, Set.mem_singleton _⟩, fun h x => ?_⟩\n  rintro ⟨b, rfl : b = a⟩; exact @h _\n\n"}
{"name":"Module.isTorsionBySet_iff_torsionBySet_eq_top","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set R\n⊢ Iff (Module.IsTorsionBySet R M s) (Eq (Submodule.torsionBySet R M s) Top.top)","decl":"theorem isTorsionBySet_iff_torsionBySet_eq_top :\n    IsTorsionBySet R M s ↔ Submodule.torsionBySet R M s = ⊤ :=\n  ⟨fun h => eq_top_iff.mpr fun _ _ => (mem_torsionBySet_iff _ _).mpr <| @h _, fun h x => by\n    rw [← mem_torsionBySet_iff, h]\n    trivial⟩\n\n"}
{"name":"Module.isTorsionBy_iff_torsionBy_eq_top","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na : R\n⊢ Iff (Module.IsTorsionBy R M a) (Eq (Submodule.torsionBy R M a) Top.top)","decl":"/-- An `a`-torsion module is a module whose `a`-torsion submodule is the full space. -/\ntheorem isTorsionBy_iff_torsionBy_eq_top : IsTorsionBy R M a ↔ torsionBy R M a = ⊤ := by\n  rw [← torsionBySet_singleton_eq, ← isTorsionBySet_singleton_iff,\n    isTorsionBySet_iff_torsionBySet_eq_top]\n\n"}
{"name":"Module.isTorsionBySet_iff_is_torsion_by_span","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set R\n⊢ Iff (Module.IsTorsionBySet R M s) (Module.IsTorsionBySet R M ↑(Ideal.span s))","decl":"theorem isTorsionBySet_iff_is_torsion_by_span :\n    IsTorsionBySet R M s ↔ IsTorsionBySet R M (Ideal.span s) := by\n  rw [isTorsionBySet_iff_torsionBySet_eq_top, isTorsionBySet_iff_torsionBySet_eq_top,\n    torsionBySet_eq_torsionBySet_span]\n\n"}
{"name":"Module.isTorsionBySet_span_singleton_iff","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na : R\n⊢ Iff (Module.IsTorsionBySet R M ↑(Submodule.span R (Singleton.singleton a))) (Module.IsTorsionBy R M a)","decl":"theorem isTorsionBySet_span_singleton_iff : IsTorsionBySet R M (R ∙ a) ↔ IsTorsionBy R M a :=\n  (isTorsionBySet_iff_is_torsion_by_span _).symm.trans <| isTorsionBySet_singleton_iff _\n\n"}
{"name":"Module.isTorsionBySet_iff_subseteq_ker_lsmul","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set R\n⊢ Iff (Module.IsTorsionBySet R M s) (HasSubset.Subset s ↑(LinearMap.ker (LinearMap.lsmul R M)))","decl":"theorem isTorsionBySet_iff_subseteq_ker_lsmul :\n    IsTorsionBySet R M s ↔ s ⊆ LinearMap.ker (LinearMap.lsmul R M) where\n  mp h r hr := LinearMap.mem_ker.mpr <| LinearMap.ext fun x => @h x ⟨r, hr⟩\n  mpr | h, x, ⟨_, hr⟩ => DFunLike.congr_fun (LinearMap.mem_ker.mp (h hr)) x\n\n"}
{"name":"Module.isTorsionBy_iff_mem_ker_lsmul","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na : R\n⊢ Iff (Module.IsTorsionBy R M a) (Membership.mem (LinearMap.ker (LinearMap.lsmul R M)) a)","decl":"theorem isTorsionBy_iff_mem_ker_lsmul :\n    IsTorsionBy R M a ↔ a ∈ LinearMap.ker (LinearMap.lsmul R M) :=\n  Iff.symm LinearMap.ext_iff\n\n"}
{"name":"Submodule.torsionBySet_isTorsionBySet","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set R\n⊢ Module.IsTorsionBySet R (Subtype fun x => Membership.mem (Submodule.torsionBySet R M s) x) s","decl":"theorem torsionBySet_isTorsionBySet : IsTorsionBySet R (torsionBySet R M s) s :=\n  fun ⟨_, hx⟩ a => Subtype.ext <| (mem_torsionBySet_iff _ _).mp hx a\n\n"}
{"name":"Submodule.torsionBy_isTorsionBy","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na : R\n⊢ Module.IsTorsionBy R (Subtype fun x => Membership.mem (Submodule.torsionBy R M a) x) a","decl":"/-- The `a`-torsion submodule is an `a`-torsion module. -/\ntheorem torsionBy_isTorsionBy : IsTorsionBy R (torsionBy R M a) a := smul_torsionBy a\n\n"}
{"name":"Submodule.torsionBy_torsionBy_eq_top","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na : R\n⊢ Eq (Submodule.torsionBy R (Subtype fun x => Membership.mem (Submodule.torsionBy R M a) x) a) Top.top","decl":"@[simp]\ntheorem torsionBy_torsionBy_eq_top : torsionBy R (torsionBy R M a) a = ⊤ :=\n  (isTorsionBy_iff_torsionBy_eq_top a).mp <| torsionBy_isTorsionBy a\n\n"}
{"name":"Submodule.torsionBySet_torsionBySet_eq_top","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set R\n⊢ Eq (Submodule.torsionBySet R (Subtype fun x => Membership.mem (Submodule.torsionBySet R M s) x) s) Top.top","decl":"@[simp]\ntheorem torsionBySet_torsionBySet_eq_top : torsionBySet R (torsionBySet R M s) s = ⊤ :=\n  (isTorsionBySet_iff_torsionBySet_eq_top s).mp <| torsionBySet_isTorsionBySet s\n\n"}
{"name":"Submodule.torsion_gc","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ GaloisConnection Submodule.annihilator fun I => Submodule.torsionBySet R M ↑(OrderDual.ofDual I)","decl":"theorem torsion_gc :\n    @GaloisConnection (Submodule R M) (Ideal R)ᵒᵈ _ _ annihilator fun I =>\n      torsionBySet R M ↑(OrderDual.ofDual I) :=\n  fun _ _ =>\n  ⟨fun h x hx => (mem_torsionBySet_iff _ _).mpr fun ⟨_, ha⟩ => mem_annihilator.mp (h ha) x hx,\n    fun h a ha => mem_annihilator.mpr fun _ hx => (mem_torsionBySet_iff _ _).mp (h hx) ⟨a, ha⟩⟩\n\n"}
{"name":"Submodule.iSup_torsionBySet_ideal_eq_torsionBySet_iInf","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Type u_3\np : ι → Ideal R\nS : Finset ι\nhp : (↑S).Pairwise fun i j => Eq (Max.max (p i) (p j)) Top.top\n⊢ Eq (iSup fun i => iSup fun h => Submodule.torsionBySet R M ↑(p i)) (Submodule.torsionBySet R M ↑(iInf fun i => iInf fun h => p i))","decl":"theorem iSup_torsionBySet_ideal_eq_torsionBySet_iInf\n    (hp : (S : Set ι).Pairwise fun i j => p i ⊔ p j = ⊤) :\n    ⨆ i ∈ S, torsionBySet R M (p i) = torsionBySet R M ↑(⨅ i ∈ S, p i) := by\n  rcases S.eq_empty_or_nonempty with h | h\n  · simp [h]\n  apply le_antisymm\n  · apply iSup_le _\n    intro i\n    apply iSup_le _\n    intro is\n    apply torsionBySet_le_torsionBySet_of_subset\n    exact (iInf_le (fun i => ⨅ _ : i ∈ S, p i) i).trans (iInf_le _ is)\n  · intro x hx\n    rw [mem_iSup_finset_iff_exists_sum]\n    obtain ⟨μ, hμ⟩ :=\n      (mem_iSup_finset_iff_exists_sum _ _).mp\n        ((Ideal.eq_top_iff_one _).mp <| (Ideal.iSup_iInf_eq_top_iff_pairwise h _).mpr hp)\n    refine ⟨fun i => ⟨(μ i : R) • x, ?_⟩, ?_⟩\n    · rw [mem_torsionBySet_iff] at hx ⊢\n      rintro ⟨a, ha⟩\n      rw [smul_smul]\n      suffices a * μ i ∈ ⨅ i ∈ S, p i from hx ⟨_, this⟩\n      rw [mem_iInf]\n      intro j\n      rw [mem_iInf]\n      intro hj\n      by_cases ij : j = i\n      · rw [ij]\n        exact Ideal.mul_mem_right _ _ ha\n      · have := coe_mem (μ i)\n        simp only [mem_iInf] at this\n        exact Ideal.mul_mem_left _ _ (this j hj ij)\n    · rw [← Finset.sum_smul, hμ, one_smul]\n\n-- Porting note: iSup_torsionBySet_ideal_eq_torsionBySet_iInf now requires DecidableEq ι\n"}
{"name":"Submodule.supIndep_torsionBySet_ideal","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Type u_3\np : ι → Ideal R\nS : Finset ι\nhp : (↑S).Pairwise fun i j => Eq (Max.max (p i) (p j)) Top.top\n⊢ S.SupIndep fun i => Submodule.torsionBySet R M ↑(p i)","decl":"theorem supIndep_torsionBySet_ideal (hp : (S : Set ι).Pairwise fun i j => p i ⊔ p j = ⊤) :\n    S.SupIndep fun i => torsionBySet R M <| p i :=\n  fun T hT i hi hiT => by\n  rw [disjoint_iff, Finset.sup_eq_iSup,\n    iSup_torsionBySet_ideal_eq_torsionBySet_iInf fun i hi j hj ij => hp (hT hi) (hT hj) ij]\n  have := GaloisConnection.u_inf\n    (b₁ := OrderDual.toDual (p i)) (b₂ := OrderDual.toDual (⨅ i ∈ T, p i)) (torsion_gc R M)\n  dsimp at this ⊢\n  rw [← this, Ideal.sup_iInf_eq_top, top_coe, torsionBySet_univ]\n  intro j hj; apply hp hi (hT hj); rintro rfl; exact hiT hj\n\n"}
{"name":"Submodule.iSup_torsionBy_eq_torsionBy_prod","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Type u_3\nS : Finset ι\nq : ι → R\nhq : (↑S).Pairwise (Function.onFun IsCoprime q)\n⊢ Eq (iSup fun i => iSup fun h => Submodule.torsionBy R M (q i)) (Submodule.torsionBy R M (S.prod fun i => q i))","decl":"theorem iSup_torsionBy_eq_torsionBy_prod (hq : (S : Set ι).Pairwise <| (IsCoprime on q)) :\n    ⨆ i ∈ S, torsionBy R M (q i) = torsionBy R M (∏ i ∈ S, q i) := by\n  rw [← torsionBySet_span_singleton_eq, Ideal.submodule_span_eq, ←\n    Ideal.finset_inf_span_singleton _ _ hq, Finset.inf_eq_iInf, ←\n    iSup_torsionBySet_ideal_eq_torsionBySet_iInf]\n  · congr\n    ext : 1\n    congr\n    ext : 1\n    exact (torsionBySet_span_singleton_eq _).symm\n  exact fun i hi j hj ij => (Ideal.sup_eq_top_iff_isCoprime _ _).mpr (hq hi hj ij)\n\n"}
{"name":"Submodule.supIndep_torsionBy","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Type u_3\nS : Finset ι\nq : ι → R\nhq : (↑S).Pairwise (Function.onFun IsCoprime q)\n⊢ S.SupIndep fun i => Submodule.torsionBy R M (q i)","decl":"theorem supIndep_torsionBy (hq : (S : Set ι).Pairwise <| (IsCoprime on q)) :\n    S.SupIndep fun i => torsionBy R M <| q i := by\n  convert supIndep_torsionBySet_ideal (M := M) fun i hi j hj ij =>\n      (Ideal.sup_eq_top_iff_isCoprime (q i) _).mpr <| hq hi hj ij\n  exact (torsionBySet_span_singleton_eq (R := R) (M := M) _).symm\n\n"}
{"name":"Submodule.torsionBySet_isInternal","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nι : Type u_3\ninst✝ : DecidableEq ι\nS : Finset ι\np : ι → Ideal R\nhp : (↑S).Pairwise fun i j => Eq (Max.max (p i) (p j)) Top.top\nhM : Module.IsTorsionBySet R M ↑(iInf fun i => iInf fun h => p i)\n⊢ DirectSum.IsInternal fun i => Submodule.torsionBySet R M ↑(p ↑i)","decl":"/-- If the `p i` are pairwise coprime, a `⨅ i, p i`-torsion module is the internal direct sum of\nits `p i`-torsion submodules. -/\ntheorem torsionBySet_isInternal {p : ι → Ideal R}\n    (hp : (S : Set ι).Pairwise fun i j => p i ⊔ p j = ⊤)\n    (hM : Module.IsTorsionBySet R M (⨅ i ∈ S, p i : Ideal R)) :\n    DirectSum.IsInternal fun i : S => torsionBySet R M <| p i :=\n  DirectSum.isInternal_submodule_of_iSupIndep_of_iSup_eq_top\n    (iSupIndep_iff_supIndep.mpr <| supIndep_torsionBySet_ideal hp)\n    (by\n      apply (iSup_subtype'' ↑S fun i => torsionBySet R M <| p i).trans\n      -- Porting note: times out if we change apply below to <|\n      apply (iSup_torsionBySet_ideal_eq_torsionBySet_iInf hp).trans <|\n        (Module.isTorsionBySet_iff_torsionBySet_eq_top _).mp hM)\n\n"}
{"name":"Submodule.torsionBy_isInternal","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nι : Type u_3\ninst✝ : DecidableEq ι\nS : Finset ι\nq : ι → R\nhq : (↑S).Pairwise (Function.onFun IsCoprime q)\nhM : Module.IsTorsionBy R M (S.prod fun i => q i)\n⊢ DirectSum.IsInternal fun i => Submodule.torsionBy R M (q ↑i)","decl":"open scoped Function in -- required for scoped `on` notation\n/-- If the `q i` are pairwise coprime, a `∏ i, q i`-torsion module is the internal direct sum of\nits `q i`-torsion submodules. -/\ntheorem torsionBy_isInternal {q : ι → R} (hq : (S : Set ι).Pairwise <| (IsCoprime on q))\n    (hM : Module.IsTorsionBy R M <| ∏ i ∈ S, q i) :\n    DirectSum.IsInternal fun i : S => torsionBy R M <| q i := by\n  rw [← Module.isTorsionBySet_span_singleton_iff, Ideal.submodule_span_eq, ←\n    Ideal.finset_inf_span_singleton _ _ hq, Finset.inf_eq_iInf] at hM\n  convert torsionBySet_isInternal\n      (fun i hi j hj ij => (Ideal.sup_eq_top_iff_isCoprime (q i) _).mpr <| hq hi hj ij) hM\n  exact (torsionBySet_span_singleton_eq _ (R := R) (M := M)).symm\n\n"}
{"name":"Module.IsTorsionBySet.mk_smul","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nhM : Module.IsTorsionBySet R M ↑I\nb : R\nx : M\n⊢ Eq (HSMul.hSMul ((Ideal.Quotient.mk I) b) x) (HSMul.hSMul b x)","decl":"@[simp]\ntheorem IsTorsionBySet.mk_smul (hM : IsTorsionBySet R M I) (b : R) (x : M) :\n    haveI := hM.hasSMul\n    Ideal.Quotient.mk I b • x = b • x :=\n  rfl\n\n"}
{"name":"Module.IsTorsionBy.mk_smul","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nr : R\nhM : Module.IsTorsionBy R M r\nb : R\nx : M\n⊢ Eq (HSMul.hSMul ((Ideal.Quotient.mk (Ideal.span (Singleton.singleton r))) b) x) (HSMul.hSMul b x)","decl":"@[simp]\ntheorem IsTorsionBy.mk_smul (hM : IsTorsionBy R M r) (b : R) (x : M) :\n    haveI := hM.hasSMul\n    Ideal.Quotient.mk (Ideal.span {r}) b • x = b • x :=\n  rfl\n\n"}
{"name":"Module.IsTorsionBySet.isScalarTower","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nI : Ideal R\nhM : Module.IsTorsionBySet R M ↑I\nS : Type u_3\ninst✝³ : SMul S R\ninst✝² : SMul S M\ninst✝¹ : IsScalarTower S R M\ninst✝ : IsScalarTower S R R\n⊢ IsScalarTower S (HasQuotient.Quotient R I) M","decl":"instance IsTorsionBySet.isScalarTower (hM : IsTorsionBySet R M I)\n    {S : Type*} [SMul S R] [SMul S M] [IsScalarTower S R M] [IsScalarTower S R R] :\n    @IsScalarTower S (R ⧸ I) M _ (IsTorsionBySet.module hM).toSMul _ :=\n  -- Porting note: still needed to be fed the Module R / I M instance\n  @IsScalarTower.mk S (R ⧸ I) M _ (IsTorsionBySet.module hM).toSMul _\n    (fun b d x => Quotient.inductionOn' d fun c => (smul_assoc b c x :))\n\n"}
{"name":"Module.isTorsionBy_quotient_iff","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nN : Submodule R M\nr : R\n⊢ Iff (Module.IsTorsionBy R (HasQuotient.Quotient M N) r) (∀ (x : M), Membership.mem N (HSMul.hSMul r x))","decl":"theorem isTorsionBy_quotient_iff (N : Submodule R M) (r : R) :\n    IsTorsionBy R (M⧸N) r ↔ ∀ x, r • x ∈ N :=\n  Iff.trans N.mkQ_surjective.forall <| forall_congr' fun _ =>\n    Submodule.Quotient.mk_eq_zero N\n\n"}
{"name":"Module.IsTorsionBy.quotient","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nN : Submodule R M\nr : R\nh : Module.IsTorsionBy R M r\n⊢ Module.IsTorsionBy R (HasQuotient.Quotient M N) r","decl":"theorem IsTorsionBy.quotient (N : Submodule R M) {r : R}\n    (h : IsTorsionBy R M r) : IsTorsionBy R (M⧸N) r :=\n  (isTorsionBy_quotient_iff N r).mpr fun x => @h x ▸ N.zero_mem\n\n"}
{"name":"Module.isTorsionBySet_quotient_iff","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nN : Submodule R M\ns : Set R\n⊢ Iff (Module.IsTorsionBySet R (HasQuotient.Quotient M N) s) (∀ (x : M) (r : R), Membership.mem s r → Membership.mem N (HSMul.hSMul r x))","decl":"theorem isTorsionBySet_quotient_iff (N : Submodule R M) (s : Set R) :\n    IsTorsionBySet R (M⧸N) s ↔ ∀ x, ∀ r ∈ s, r • x ∈ N :=\n  Iff.trans N.mkQ_surjective.forall <| forall_congr' fun _ =>\n    Iff.trans Subtype.forall <| forall₂_congr fun _ _ =>\n      Submodule.Quotient.mk_eq_zero N\n\n"}
{"name":"Module.IsTorsionBySet.quotient","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nN : Submodule R M\ns : Set R\nh : Module.IsTorsionBySet R M s\n⊢ Module.IsTorsionBySet R (HasQuotient.Quotient M N) s","decl":"theorem IsTorsionBySet.quotient (N : Submodule R M) {s}\n    (h : IsTorsionBySet R M s) : IsTorsionBySet R (M⧸N) s :=\n  (isTorsionBySet_quotient_iff N s).mpr fun x r h' => @h x ⟨r, h'⟩ ▸ N.zero_mem\n\n"}
{"name":"Module.isTorsionBySet_quotient_set_smul","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ns : Set R\n⊢ Module.IsTorsionBySet R (HasQuotient.Quotient M (HSMul.hSMul s Top.top)) s","decl":"lemma isTorsionBySet_quotient_set_smul :\n    IsTorsionBySet R (M⧸s • (⊤ : Submodule R M)) s :=\n  (isTorsionBySet_quotient_iff _ _).mpr fun _ _ h =>\n    mem_set_smul_of_mem_mem h mem_top\n\n"}
{"name":"Module.isTorsionBy_quotient_element_smul","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nr : R\n⊢ Module.IsTorsionBy R (HasQuotient.Quotient M (HSMul.hSMul r Top.top)) r","decl":"lemma isTorsionBy_quotient_element_smul :\n    IsTorsionBy R (M⧸r • (⊤ : Submodule R M)) r :=\n  (isTorsionBy_quotient_iff _ _).mpr (smul_mem_pointwise_smul · r ⊤ ⟨⟩)\n\n"}
{"name":"Module.isTorsionBySet_quotient_ideal_smul","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\n⊢ Module.IsTorsionBySet R (HasQuotient.Quotient M (HSMul.hSMul I Top.top)) ↑I","decl":"lemma isTorsionBySet_quotient_ideal_smul :\n    IsTorsionBySet R (M⧸I • (⊤ : Submodule R M)) I :=\n  (isTorsionBySet_quotient_iff _ _).mpr fun _ _ h => smul_mem_smul h ⟨⟩\n\n"}
{"name":"Module.Quotient.mk_smul_mk","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nr : R\nm : M\n⊢ Eq (HSMul.hSMul ((Ideal.Quotient.mk I) r) (Submodule.Quotient.mk m)) (Submodule.Quotient.mk (HSMul.hSMul r m))","decl":"lemma Quotient.mk_smul_mk (r : R) (m : M) :\n    Ideal.Quotient.mk I r •\n      Submodule.Quotient.mk (p := (I • ⊤ : Submodule R M)) m =\n      Submodule.Quotient.mk (p := (I • ⊤ : Submodule R M)) (r • m) :=\n  rfl\n\n"}
{"name":"Submodule.torsionBySet.mk_smul","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nb : R\nx : Subtype fun x => Membership.mem (Submodule.torsionBySet R M ↑I) x\n⊢ Eq (HSMul.hSMul ((Ideal.Quotient.mk I) b) x) (HSMul.hSMul b x)","decl":"@[simp]\ntheorem torsionBySet.mk_smul (I : Ideal R) (b : R) (x : torsionBySet R M I) :\n    Ideal.Quotient.mk I b • x = b • x :=\n  rfl\n\n"}
{"name":"Submodule.instIsScalarTowerQuotientIdealSubtypeMemTorsionBySetCoe","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nI : Ideal R\nS : Type u_3\ninst✝³ : SMul S R\ninst✝² : SMul S M\ninst✝¹ : IsScalarTower S R M\ninst✝ : IsScalarTower S R R\n⊢ IsScalarTower S (HasQuotient.Quotient R I) (Subtype fun x => Membership.mem (Submodule.torsionBySet R M ↑I) x)","decl":"instance (I : Ideal R) {S : Type*} [SMul S R] [SMul S M] [IsScalarTower S R M]\n    [IsScalarTower S R R] : IsScalarTower S (R ⧸ I) (torsionBySet R M I) :=\n  inferInstance\n\n"}
{"name":"Submodule.torsionBy.mk_ideal_smul","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\na b : R\nx : Subtype fun x => Membership.mem (Submodule.torsionBy R M a) x\n⊢ Eq (HSMul.hSMul ((Ideal.Quotient.mk (Ideal.span (Singleton.singleton a))) b) x) (HSMul.hSMul b x)","decl":"@[simp]\ntheorem torsionBy.mk_ideal_smul (a b : R) (x : torsionBy R M a) :\n    (Ideal.Quotient.mk (Ideal.span {a})) b • x = b • x :=\n  rfl\n\n"}
{"name":"Submodule.torsionBy.mk_smul","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\na b : R\nx : Subtype fun x => Membership.mem (Submodule.torsionBy R M a) x\n⊢ Eq (HSMul.hSMul ((Ideal.Quotient.mk (Submodule.span R (Singleton.singleton a))) b) x) (HSMul.hSMul b x)","decl":"theorem torsionBy.mk_smul (a b : R) (x : torsionBy R M a) :\n    Ideal.Quotient.mk (R ∙ a) b • x = b • x :=\n  rfl\n\n"}
{"name":"Submodule.instIsScalarTowerQuotientSpanSingletonSetSubtypeMemTorsionBy","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\na : R\nS : Type u_3\ninst✝³ : SMul S R\ninst✝² : SMul S M\ninst✝¹ : IsScalarTower S R M\ninst✝ : IsScalarTower S R R\n⊢ IsScalarTower S (HasQuotient.Quotient R (Submodule.span R (Singleton.singleton a))) (Subtype fun x => Membership.mem (Submodule.torsionBy R M a) x)","decl":"instance (a : R) {S : Type*} [SMul S R] [SMul S M] [IsScalarTower S R M] [IsScalarTower S R R] :\n    IsScalarTower S (R ⧸ R ∙ a) (torsionBy R M a) :=\n  inferInstance\n\n"}
{"name":"Submodule.mem_torsion'_iff","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nS : Type u_3\ninst✝² : CommMonoid S\ninst✝¹ : DistribMulAction S M\ninst✝ : SMulCommClass S R M\nx : M\n⊢ Iff (Membership.mem (Submodule.torsion' R M S) x) (Exists fun a => Eq (HSMul.hSMul a x) 0)","decl":"@[simp]\ntheorem mem_torsion'_iff (x : M) : x ∈ torsion' R M S ↔ ∃ a : S, a • x = 0 :=\n  Iff.rfl\n\n"}
{"name":"Submodule.mem_torsion_iff","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\n⊢ Iff (Membership.mem (Submodule.torsion R M) x) (Exists fun a => Eq (HSMul.hSMul a x) 0)","decl":"theorem mem_torsion_iff (x : M) : x ∈ torsion R M ↔ ∃ a : R⁰, a • x = 0 :=\n  Iff.rfl\n\n"}
{"name":"Submodule.instSMulSubtypeMemTorsion'_smul_coe","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nS : Type u_3\ninst✝² : CommMonoid S\ninst✝¹ : DistribMulAction S M\ninst✝ : SMulCommClass S R M\ns : S\nx : Subtype fun x => Membership.mem (Submodule.torsion' R M S) x\n⊢ Eq (↑(HSMul.hSMul s x)) (HSMul.hSMul s ↑x)","decl":"@[simps]\ninstance : SMul S (torsion' R M S) :=\n  ⟨fun s x =>\n    ⟨s • (x : M), by\n      obtain ⟨x, a, h⟩ := x\n      use a\n      dsimp\n      rw [smul_comm, h, smul_zero]⟩⟩\n\n"}
{"name":"Submodule.instSMulCommClassSubtypeMemTorsion'","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nS : Type u_3\ninst✝² : CommMonoid S\ninst✝¹ : DistribMulAction S M\ninst✝ : SMulCommClass S R M\n⊢ SMulCommClass S R (Subtype fun x => Membership.mem (Submodule.torsion' R M S) x)","decl":"instance : SMulCommClass S R (torsion' R M S) :=\n  ⟨fun _ _ _ => Subtype.ext <| smul_comm _ _ _⟩\n\n"}
{"name":"Submodule.isTorsion'_iff_torsion'_eq_top","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nS : Type u_3\ninst✝² : CommMonoid S\ninst✝¹ : DistribMulAction S M\ninst✝ : SMulCommClass S R M\n⊢ Iff (Module.IsTorsion' M S) (Eq (Submodule.torsion' R M S) Top.top)","decl":"/-- An `S`-torsion module is a module whose `S`-torsion submodule is the full space. -/\ntheorem isTorsion'_iff_torsion'_eq_top : IsTorsion' M S ↔ torsion' R M S = ⊤ :=\n  ⟨fun h => eq_top_iff.mpr fun _ _ => @h _, fun h x => by\n    rw [← @mem_torsion'_iff R, h]\n    trivial⟩\n\n"}
{"name":"Submodule.torsion'_isTorsion'","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nS : Type u_3\ninst✝² : CommMonoid S\ninst✝¹ : DistribMulAction S M\ninst✝ : SMulCommClass S R M\n⊢ Module.IsTorsion' (Subtype fun x => Membership.mem (Submodule.torsion' R M S) x) S","decl":"/-- The `S`-torsion submodule is an `S`-torsion module. -/\ntheorem torsion'_isTorsion' : IsTorsion' (torsion' R M S) S := fun ⟨_, ⟨a, h⟩⟩ => ⟨a, Subtype.ext h⟩\n\n"}
{"name":"Submodule.torsion'_torsion'_eq_top","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nS : Type u_3\ninst✝² : CommMonoid S\ninst✝¹ : DistribMulAction S M\ninst✝ : SMulCommClass S R M\n⊢ Eq (Submodule.torsion' R (Subtype fun x => Membership.mem (Submodule.torsion' R M S) x) S) Top.top","decl":"@[simp]\ntheorem torsion'_torsion'_eq_top : torsion' R (torsion' R M S) S = ⊤ :=\n  (isTorsion'_iff_torsion'_eq_top S).mp <| torsion'_isTorsion' S\n\n"}
{"name":"Submodule.torsion_torsion_eq_top","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (Submodule.torsion R (Subtype fun x => Membership.mem (Submodule.torsion R M) x)) Top.top","decl":"/-- The torsion submodule of the torsion submodule (viewed as a module) is the full\ntorsion module. -/\ntheorem torsion_torsion_eq_top : torsion R (torsion R M) = ⊤ :=\n  torsion'_torsion'_eq_top R⁰\n\n"}
{"name":"Submodule.torsion_isTorsion","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Module.IsTorsion R (Subtype fun x => Membership.mem (Submodule.torsion R M) x)","decl":"/-- The torsion submodule is always a torsion module. -/\ntheorem torsion_isTorsion : Module.IsTorsion R (torsion R M) :=\n  torsion'_isTorsion' R⁰\n\n"}
{"name":"Module.isTorsionBySet_annihilator_top","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Module.IsTorsionBySet R M ↑Top.top.annihilator","decl":"theorem _root_.Module.isTorsionBySet_annihilator_top :\n    Module.IsTorsionBySet R M (⊤ : Submodule R M).annihilator := fun x ha =>\n  mem_annihilator.mp ha.prop x mem_top\n\n"}
{"name":"Submodule.annihilator_top_inter_nonZeroDivisors","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Module.Finite R M\nhM : Module.IsTorsion R M\n⊢ Ne (Inter.inter ↑Top.top.annihilator ↑(nonZeroDivisors R)) EmptyCollection.emptyCollection","decl":"theorem _root_.Submodule.annihilator_top_inter_nonZeroDivisors [Module.Finite R M]\n    (hM : Module.IsTorsion R M) : ((⊤ : Submodule R M).annihilator : Set R) ∩ R⁰ ≠ ∅ := by\n  obtain ⟨S, hS⟩ := ‹Module.Finite R M›.fg_top\n  refine Set.Nonempty.ne_empty ⟨_, ?_, (∏ x ∈ S, (@hM x).choose : R⁰).prop⟩\n  rw [Submonoid.coe_finset_prod, SetLike.mem_coe, ← hS, mem_annihilator_span]\n  intro n\n  letI := Classical.decEq M\n  rw [← Finset.prod_erase_mul _ _ n.prop, mul_smul, ← Submonoid.smul_def, (@hM n).choose_spec,\n    smul_zero]\n\n"}
{"name":"Submodule.coe_torsion_eq_annihilator_ne_bot","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : NoZeroDivisors R\ninst✝ : Nontrivial R\n⊢ Eq (↑(Submodule.torsion R M)) (setOf fun x => Ne (Submodule.span R (Singleton.singleton x)).annihilator Bot.bot)","decl":"theorem coe_torsion_eq_annihilator_ne_bot :\n    (torsion R M : Set M) = { x : M | (R ∙ x).annihilator ≠ ⊥ } := by\n  ext x; simp_rw [Submodule.ne_bot_iff, mem_annihilator, mem_span_singleton]\n  exact\n    ⟨fun ⟨a, hax⟩ =>\n      ⟨a, fun _ ⟨b, hb⟩ => by rw [← hb, smul_comm, ← Submonoid.smul_def, hax, smul_zero],\n        nonZeroDivisors.coe_ne_zero _⟩,\n      fun ⟨a, hax, ha⟩ => ⟨⟨_, mem_nonZeroDivisors_of_ne_zero ha⟩, hax x ⟨1, one_smul _ _⟩⟩⟩\n\n"}
{"name":"Submodule.noZeroSMulDivisors_iff_torsion_eq_bot","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : NoZeroDivisors R\ninst✝ : Nontrivial R\n⊢ Iff (NoZeroSMulDivisors R M) (Eq (Submodule.torsion R M) Bot.bot)","decl":"/-- A module over a domain has `NoZeroSMulDivisors` iff its torsion submodule is trivial. -/\ntheorem noZeroSMulDivisors_iff_torsion_eq_bot : NoZeroSMulDivisors R M ↔ torsion R M = ⊥ := by\n  constructor <;> intro h\n  · haveI : NoZeroSMulDivisors R M := h\n    rw [eq_bot_iff]\n    rintro x ⟨a, hax⟩\n    change (a : R) • x = 0 at hax\n    cases' eq_zero_or_eq_zero_of_smul_eq_zero hax with h0 h0\n    · exfalso\n      exact nonZeroDivisors.coe_ne_zero a h0\n    · exact h0\n  · exact\n      { eq_zero_or_eq_zero_of_smul_eq_zero := fun {a} {x} hax => by\n          by_cases ha : a = 0\n          · left\n            exact ha\n          · right\n            rw [← mem_bot R, ← h]\n            exact ⟨⟨a, mem_nonZeroDivisors_of_ne_zero ha⟩, hax⟩ }\n\n"}
{"name":"Submodule.torsion_int","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"G : Type u_3\ninst✝ : AddCommGroup G\n⊢ Eq (Submodule.torsion Int G).toAddSubgroup (AddCommGroup.torsion G)","decl":"lemma torsion_int {G} [AddCommGroup G] :\n    (torsion ℤ G).toAddSubgroup = AddCommGroup.torsion G := by\n  ext x\n  refine ((isOfFinAddOrder_iff_zsmul_eq_zero (x := x)).trans ?_).symm\n  simp [mem_nonZeroDivisors_iff_ne_zero]\n\n"}
{"name":"Submodule.QuotientTorsion.torsion_eq_bot","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Eq (Submodule.torsion R (HasQuotient.Quotient M (Submodule.torsion R M))) Bot.bot","decl":"/-- Quotienting by the torsion submodule gives a torsion-free module. -/\n@[simp]\ntheorem torsion_eq_bot : torsion R (M ⧸ torsion R M) = ⊥ :=\n  eq_bot_iff.mpr fun z =>\n    Quotient.inductionOn' z fun x ⟨a, hax⟩ => by\n      rw [Quotient.mk''_eq_mk, ← Quotient.mk_smul, Quotient.mk_eq_zero] at hax\n      rw [mem_bot, Quotient.mk''_eq_mk, Quotient.mk_eq_zero]\n      cases' hax with b h\n      exact ⟨b * a, (mul_smul _ _ _).trans h⟩\n\n"}
{"name":"Submodule.QuotientTorsion.noZeroSMulDivisors","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsDomain R\n⊢ NoZeroSMulDivisors R (HasQuotient.Quotient M (Submodule.torsion R M))","decl":"instance noZeroSMulDivisors [IsDomain R] : NoZeroSMulDivisors R (M ⧸ torsion R M) :=\n  noZeroSMulDivisors_iff_torsion_eq_bot.mpr torsion_eq_bot\n\n"}
{"name":"Submodule.isTorsion'_powers_iff","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Monoid R\ninst✝¹ : AddCommMonoid M\ninst✝ : DistribMulAction R M\np : R\n⊢ Iff (Module.IsTorsion' M (Subtype fun x => Membership.mem (Submonoid.powers p) x)) (∀ (x : M), Exists fun n => Eq (HSMul.hSMul (HPow.hPow p n) x) 0)","decl":"theorem isTorsion'_powers_iff (p : R) :\n    IsTorsion' M (Submonoid.powers p) ↔ ∀ x : M, ∃ n : ℕ, p ^ n • x = 0 := by\n  -- Porting note: previous term proof was having trouble elaborating\n  constructor\n  · intro h x\n    let ⟨⟨a, ⟨n, hn⟩⟩, hx⟩ := @h x\n    dsimp at hn\n    use n\n    rw [hn]\n    apply hx\n  · intro h x\n    let ⟨n, hn⟩ := h x\n    exact ⟨⟨_, ⟨n, rfl⟩⟩, hn⟩\n\n"}
{"name":"Submodule.pow_pOrder_smul","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Monoid R\ninst✝² : AddCommMonoid M\ninst✝¹ : DistribMulAction R M\np : R\nhM : Module.IsTorsion' M (Subtype fun x => Membership.mem (Submonoid.powers p) x)\nx : M\ninst✝ : (n : Nat) → Decidable (Eq (HSMul.hSMul (HPow.hPow p n) x) 0)\n⊢ Eq (HSMul.hSMul (HPow.hPow p (Submodule.pOrder hM x)) x) 0","decl":"@[simp]\ntheorem pow_pOrder_smul {p : R} (hM : IsTorsion' M <| Submonoid.powers p) (x : M)\n    [∀ n : ℕ, Decidable (p ^ n • x = 0)] : p ^ pOrder hM x • x = 0 :=\n  Nat.find_spec <| (isTorsion'_powers_iff p).mp hM x\n\n"}
{"name":"Submodule.exists_isTorsionBy","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : (x : M) → Decidable (Eq x 0)\np : R\nhM : Module.IsTorsion' M (Subtype fun x => Membership.mem (Submonoid.powers p) x)\nd : Nat\nhd : Ne d 0\ns : Fin d → M\nhs : Eq (Submodule.span R (Set.range s)) Top.top\n⊢ Exists fun j => Module.IsTorsionBy R M (HPow.hPow p (Submodule.pOrder hM (s j)))","decl":"theorem exists_isTorsionBy {p : R} (hM : IsTorsion' M <| Submonoid.powers p) (d : ℕ) (hd : d ≠ 0)\n    (s : Fin d → M) (hs : span R (Set.range s) = ⊤) :\n    ∃ j : Fin d, Module.IsTorsionBy R M (p ^ pOrder hM (s j)) := by\n  let oj := List.argmax (fun i => pOrder hM <| s i) (List.finRange d)\n  have hoj : oj.isSome :=\n    Option.ne_none_iff_isSome.mp fun eq_none =>\n      hd <| List.finRange_eq_nil.mp <| List.argmax_eq_none.mp eq_none\n  use Option.get _ hoj\n  rw [isTorsionBy_iff_torsionBy_eq_top, eq_top_iff, ← hs, Submodule.span_le,\n    Set.range_subset_iff]\n  intro i; change (p ^ pOrder hM (s (Option.get oj hoj))) • s i = 0\n  have : pOrder hM (s i) ≤ pOrder hM (s <| Option.get _ hoj) :=\n    List.le_of_mem_argmax (List.mem_finRange i) (Option.get_mem hoj)\n  rw [← Nat.sub_add_cancel this, pow_add, mul_smul, pow_pOrder_smul, smul_zero]\n\n"}
{"name":"Ideal.Quotient.torsionBy_eq_span_singleton","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type w\ninst✝ : CommRing R\na b : R\nha : Membership.mem (nonZeroDivisors R) a\n⊢ Eq (Submodule.torsionBy R (HasQuotient.Quotient R (Submodule.span R (Singleton.singleton (HMul.hMul a b)))) a) (Submodule.span R (Singleton.singleton ((Ideal.Quotient.mk (Submodule.span R (Singleton.singleton (HMul.hMul a b)))) b)))","decl":"theorem torsionBy_eq_span_singleton {R : Type w} [CommRing R] (a b : R) (ha : a ∈ R⁰) :\n    torsionBy R (R ⧸ R ∙ a * b) a = R ∙ mk (R ∙ a * b) b := by\n  ext x; rw [mem_torsionBy_iff, Submodule.mem_span_singleton]\n  obtain ⟨x, rfl⟩ := mk_surjective x; constructor <;> intro h\n  · rw [← mk_eq_mk, ← Quotient.mk_smul, Quotient.mk_eq_zero, Submodule.mem_span_singleton] at h\n    obtain ⟨c, h⟩ := h\n    rw [smul_eq_mul, smul_eq_mul, mul_comm, mul_assoc, mul_cancel_left_mem_nonZeroDivisors ha,\n      mul_comm] at h\n    use c\n    rw [← h, ← mk_eq_mk, ← Quotient.mk_smul, smul_eq_mul, mk_eq_mk]\n  · obtain ⟨c, h⟩ := h\n    rw [← h, smul_comm, ← mk_eq_mk, ← Quotient.mk_smul,\n      (Quotient.mk_eq_zero _).mpr <| mem_span_singleton_self _, smul_zero]\n\n"}
{"name":"AddMonoid.isTorsion_iff_isTorsion_nat","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"M : Type u_2\ninst✝ : AddCommMonoid M\n⊢ Iff (AddMonoid.IsTorsion M) (Module.IsTorsion Nat M)","decl":"theorem isTorsion_iff_isTorsion_nat [AddCommMonoid M] :\n    AddMonoid.IsTorsion M ↔ Module.IsTorsion ℕ M := by\n  refine ⟨fun h x => ?_, fun h x => ?_⟩\n  · obtain ⟨n, h0, hn⟩ := (h x).exists_nsmul_eq_zero\n    exact ⟨⟨n, mem_nonZeroDivisors_of_ne_zero <| ne_of_gt h0⟩, hn⟩\n  · rw [isOfFinAddOrder_iff_nsmul_eq_zero]\n    obtain ⟨n, hn⟩ := @h x\n    exact ⟨n, Nat.pos_of_ne_zero (nonZeroDivisors.coe_ne_zero _), hn⟩\n\n"}
{"name":"AddMonoid.isTorsion_iff_isTorsion_int","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"M : Type u_2\ninst✝ : AddCommGroup M\n⊢ Iff (AddMonoid.IsTorsion M) (Module.IsTorsion Int M)","decl":"theorem isTorsion_iff_isTorsion_int [AddCommGroup M] :\n    AddMonoid.IsTorsion M ↔ Module.IsTorsion ℤ M := by\n  refine ⟨fun h x => ?_, fun h x => ?_⟩\n  · obtain ⟨n, h0, hn⟩ := (h x).exists_nsmul_eq_zero\n    exact\n      ⟨⟨n, mem_nonZeroDivisors_of_ne_zero <| ne_of_gt <| Int.natCast_pos.mpr h0⟩,\n        (natCast_zsmul _ _).trans hn⟩\n  · rw [isOfFinAddOrder_iff_nsmul_eq_zero]\n    obtain ⟨n, hn⟩ := @h x\n    exact ⟨_, Int.natAbs_pos.2 (nonZeroDivisors.coe_ne_zero n), natAbs_nsmul_eq_zero.2 hn⟩\n\n"}
{"name":"AddSubgroup.torsionBy.neg","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"A : Type u_3\ninst✝ : AddCommGroup A\nn : Int\n⊢ Eq (AddSubgroup.torsionBy A (Neg.neg n)) (AddSubgroup.torsionBy A n)","decl":"lemma torsionBy.neg : A[-n] = A[n] := by\n  ext a\n  simp\n\n"}
{"name":"AddSubgroup.torsionBy.nsmul","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"A : Type u_3\ninst✝ : AddCommGroup A\nn : Nat\nx : Subtype fun x => Membership.mem (AddSubgroup.torsionBy A ↑n) x\n⊢ Eq (HSMul.hSMul n x) 0","decl":"@[simp]\nlemma torsionBy.nsmul (x : A[n]) : n • x = 0 :=\n  Nat.cast_smul_eq_nsmul ℤ n x ▸ Submodule.smul_torsionBy ..\n\n"}
{"name":"AddSubgroup.torsionBy.nsmul_iff","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"A : Type u_3\ninst✝ : AddCommGroup A\nn : Nat\nx : A\n⊢ Iff (Membership.mem (AddSubgroup.torsionBy A ↑n) x) (Eq (HSMul.hSMul n x) 0)","decl":"lemma torsionBy.nsmul_iff {x : A} :\n    x ∈ A[n] ↔ n • x = 0 :=\n  Nat.cast_smul_eq_nsmul ℤ n x ▸ Submodule.mem_torsionBy_iff ..\n\n"}
{"name":"AddSubgroup.torsionBy.mod_self_nsmul","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"A : Type u_3\ninst✝ : AddCommGroup A\nn s : Nat\nx : Subtype fun x => Membership.mem (AddSubgroup.torsionBy A ↑n) x\n⊢ Eq (HSMul.hSMul s x) (HSMul.hSMul (HMod.hMod s n) x)","decl":"lemma torsionBy.mod_self_nsmul (s : ℕ) (x : A[n])  :\n    s • x = (s % n) • x :=\n  nsmul_eq_mod_nsmul s (torsionBy.nsmul x)\n\n"}
{"name":"AddSubgroup.torsionBy.mod_self_nsmul'","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"A : Type u_3\ninst✝ : AddCommGroup A\nn s : Nat\nx : A\nh : Membership.mem (AddSubgroup.torsionBy A ↑n) x\n⊢ Eq (HSMul.hSMul s x) (HSMul.hSMul (HMod.hMod s n) x)","decl":"lemma torsionBy.mod_self_nsmul' (s : ℕ) {x : A} (h : x ∈ A[n]) :\n    s • x = (s % n) • x :=\n  nsmul_eq_mod_nsmul s (torsionBy.nsmul_iff.mp h)\n\n"}
{"name":"infinite_range_add_smul_iff","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : AddCommGroup M\ninst✝³ : Ring R\ninst✝² : Module R M\ninst✝¹ : Infinite R\ninst✝ : NoZeroSMulDivisors R M\nx y : M\n⊢ Iff (Set.range fun r => HAdd.hAdd x (HSMul.hSMul r y)).Infinite (Ne y 0)","decl":"@[simp]\nlemma infinite_range_add_smul_iff\n    [AddCommGroup M] [Ring R] [Module R M] [Infinite R] [NoZeroSMulDivisors R M] (x y : M) :\n    (Set.range <| fun r : R ↦ x + r • y).Infinite ↔ y ≠ 0 := by\n  refine ⟨fun h hy ↦ by simp [hy] at h, fun h ↦ Set.infinite_range_of_injective fun r s hrs ↦ ?_⟩\n  rw [add_right_inj] at hrs\n  exact smul_left_injective _ h hrs\n\n"}
{"name":"infinite_range_add_nsmul_iff","module":"Mathlib.Algebra.Module.Torsion","initialProofState":"M : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : NoZeroSMulDivisors Int M\nx y : M\n⊢ Iff (Set.range fun n => HAdd.hAdd x (HSMul.hSMul n y)).Infinite (Ne y 0)","decl":"@[simp]\nlemma infinite_range_add_nsmul_iff [AddCommGroup M] [NoZeroSMulDivisors ℤ M] (x y : M) :\n    (Set.range <| fun n : ℕ ↦ x + n • y).Infinite ↔ y ≠ 0 := by\n  refine ⟨fun h hy ↦ by simp [hy] at h, fun h ↦ Set.infinite_range_of_injective fun r s hrs ↦ ?_⟩\n  rw [add_right_inj, ← natCast_zsmul, ← natCast_zsmul] at hrs\n  simpa using smul_left_injective _ h hrs\n\n"}
