{"name":"MvPowerSeries.lexOrder_def_of_ne_zero","module":"Mathlib.RingTheory.MvPowerSeries.LexOrder","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝² : Semiring R\ninst✝¹ : LinearOrder σ\ninst✝ : WellFoundedGT σ\nφ : MvPowerSeries σ R\nhφ : Ne φ 0\n⊢ Exists fun ne => Eq φ.lexOrder ↑(⋯.min (Set.image (⇑toLex) (Function.support φ)) ne)","decl":"theorem lexOrder_def_of_ne_zero {φ : MvPowerSeries σ R} (hφ : φ ≠ 0) :\n    ∃ (ne : Set.Nonempty (toLex '' φ.support)),\n      lexOrder φ = WithTop.some ((@wellFounded_lt (Lex (σ →₀ ℕ))\n        (instLTLex) (Lex.wellFoundedLT)).min (toLex '' φ.support) ne) := by\n  suffices ne : Set.Nonempty (toLex '' φ.support) by\n    use ne\n    unfold lexOrder\n    simp only [dif_neg hφ]\n  simp only [Set.image_nonempty, Function.support_nonempty_iff, ne_eq, hφ, not_false_eq_true]\n\n"}
{"name":"MvPowerSeries.lexOrder_eq_top_iff_eq_zero","module":"Mathlib.RingTheory.MvPowerSeries.LexOrder","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝² : Semiring R\ninst✝¹ : LinearOrder σ\ninst✝ : WellFoundedGT σ\nφ : MvPowerSeries σ R\n⊢ Iff (Eq φ.lexOrder Top.top) (Eq φ 0)","decl":"@[simp]\ntheorem lexOrder_eq_top_iff_eq_zero (φ : MvPowerSeries σ R) :\n    lexOrder φ = ⊤ ↔ φ = 0 := by\n  unfold lexOrder\n  split_ifs with h\n  · simp only [h]\n  · simp only [h, WithTop.coe_ne_top]\n\n"}
{"name":"MvPowerSeries.lexOrder_zero","module":"Mathlib.RingTheory.MvPowerSeries.LexOrder","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝² : Semiring R\ninst✝¹ : LinearOrder σ\ninst✝ : WellFoundedGT σ\n⊢ Eq (MvPowerSeries.lexOrder 0) Top.top","decl":"theorem lexOrder_zero : lexOrder (0 : MvPowerSeries σ R) = ⊤ := by\n  unfold lexOrder\n  rw [dif_pos rfl]\n\n"}
{"name":"MvPowerSeries.exists_finsupp_eq_lexOrder_of_ne_zero","module":"Mathlib.RingTheory.MvPowerSeries.LexOrder","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝² : Semiring R\ninst✝¹ : LinearOrder σ\ninst✝ : WellFoundedGT σ\nφ : MvPowerSeries σ R\nhφ : Ne φ 0\n⊢ Exists fun d => Eq φ.lexOrder ↑(toLex d)","decl":"theorem exists_finsupp_eq_lexOrder_of_ne_zero {φ : MvPowerSeries σ R} (hφ : φ ≠ 0) :\n    ∃ (d : σ →₀ ℕ), lexOrder φ = toLex d := by\n  simp only [ne_eq, ← lexOrder_eq_top_iff_eq_zero, WithTop.ne_top_iff_exists] at hφ\n  obtain ⟨p, hp⟩ := hφ\n  exact ⟨ofLex p, by simp only [toLex_ofLex, hp]⟩\n\n"}
{"name":"MvPowerSeries.coeff_ne_zero_of_lexOrder","module":"Mathlib.RingTheory.MvPowerSeries.LexOrder","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝² : Semiring R\ninst✝¹ : LinearOrder σ\ninst✝ : WellFoundedGT σ\nφ : MvPowerSeries σ R\nd : Finsupp σ Nat\nh : Eq (↑(toLex d)) φ.lexOrder\n⊢ Ne ((MvPowerSeries.coeff R d) φ) 0","decl":"theorem coeff_ne_zero_of_lexOrder {φ : MvPowerSeries σ R} {d : σ →₀ ℕ}\n    (h : toLex d = lexOrder φ) : coeff R d φ ≠ 0 := by\n  have hφ : φ ≠ 0 := by\n    simp only [ne_eq, ← lexOrder_eq_top_iff_eq_zero, ← h, WithTop.coe_ne_top, not_false_eq_true]\n  have hφ' := lexOrder_def_of_ne_zero hφ\n  rcases hφ' with ⟨ne, hφ'⟩\n  simp only [← h, WithTop.coe_eq_coe] at hφ'\n  suffices toLex d ∈ toLex '' φ.support by\n    simp only [Set.mem_image_equiv, toLex_symm_eq, ofLex_toLex, Function.mem_support, ne_eq] at this\n    apply this\n  rw [hφ']\n  apply WellFounded.min_mem\n\n"}
{"name":"MvPowerSeries.coeff_eq_zero_of_lt_lexOrder","module":"Mathlib.RingTheory.MvPowerSeries.LexOrder","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝² : Semiring R\ninst✝¹ : LinearOrder σ\ninst✝ : WellFoundedGT σ\nφ : MvPowerSeries σ R\nd : Finsupp σ Nat\nh : LT.lt (↑(toLex d)) φ.lexOrder\n⊢ Eq ((MvPowerSeries.coeff R d) φ) 0","decl":"theorem coeff_eq_zero_of_lt_lexOrder {φ : MvPowerSeries σ R} {d : σ →₀ ℕ}\n    (h : toLex d < lexOrder φ) : coeff R d φ = 0 := by\n  by_cases hφ : φ = 0\n  · simp only [hφ, map_zero]\n  · rcases lexOrder_def_of_ne_zero hφ with ⟨ne, hφ'⟩\n    rw [hφ', WithTop.coe_lt_coe] at h\n    by_contra h'\n    exact WellFounded.not_lt_min _ (toLex '' φ.support) ne (Set.mem_image_equiv.mpr h') h\n\n"}
{"name":"MvPowerSeries.lexOrder_le_of_coeff_ne_zero","module":"Mathlib.RingTheory.MvPowerSeries.LexOrder","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝² : Semiring R\ninst✝¹ : LinearOrder σ\ninst✝ : WellFoundedGT σ\nφ : MvPowerSeries σ R\nd : Finsupp σ Nat\nh : Ne ((MvPowerSeries.coeff R d) φ) 0\n⊢ LE.le φ.lexOrder ↑(toLex d)","decl":"theorem lexOrder_le_of_coeff_ne_zero {φ : MvPowerSeries σ R} {d : σ →₀ ℕ}\n    (h : coeff R d φ ≠ 0) : lexOrder φ ≤ toLex d := by\n  rw [← not_lt]\n  intro h'\n  exact h (coeff_eq_zero_of_lt_lexOrder h')\n\n"}
{"name":"MvPowerSeries.le_lexOrder_iff","module":"Mathlib.RingTheory.MvPowerSeries.LexOrder","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝² : Semiring R\ninst✝¹ : LinearOrder σ\ninst✝ : WellFoundedGT σ\nφ : MvPowerSeries σ R\nw : WithTop (Lex (Finsupp σ Nat))\n⊢ Iff (LE.le w φ.lexOrder) (∀ (d : Finsupp σ Nat), LT.lt (↑(toLex d)) w → Eq ((MvPowerSeries.coeff R d) φ) 0)","decl":"theorem le_lexOrder_iff {φ : MvPowerSeries σ R} {w : WithTop (Lex (σ →₀ ℕ))} :\n    w ≤ lexOrder φ ↔ (∀ (d : σ →₀ ℕ) (_ : toLex d < w), coeff R d φ = 0) := by\n  constructor\n  · intro h d hd\n    apply coeff_eq_zero_of_lt_lexOrder\n    exact lt_of_lt_of_le hd h\n  · intro h\n    rw [← not_lt]\n    intro h'\n    have hφ : φ ≠ 0 := by\n      rw [ne_eq, ← lexOrder_eq_top_iff_eq_zero]\n      exact ne_top_of_lt h'\n    obtain ⟨d, hd⟩ := exists_finsupp_eq_lexOrder_of_ne_zero hφ\n    refine coeff_ne_zero_of_lexOrder hd.symm (h d ?_)\n    rwa [← hd]\n\n"}
{"name":"MvPowerSeries.min_lexOrder_le","module":"Mathlib.RingTheory.MvPowerSeries.LexOrder","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝² : Semiring R\ninst✝¹ : LinearOrder σ\ninst✝ : WellFoundedGT σ\nφ ψ : MvPowerSeries σ R\n⊢ LE.le (Min.min φ.lexOrder ψ.lexOrder) (HAdd.hAdd φ ψ).lexOrder","decl":"theorem min_lexOrder_le {φ ψ : MvPowerSeries σ R} :\n    min (lexOrder φ) (lexOrder ψ) ≤ lexOrder (φ + ψ)  := by\n  rw [le_lexOrder_iff]\n  intro d hd\n  simp only [lt_min_iff] at hd\n  rw [map_add, coeff_eq_zero_of_lt_lexOrder hd.1, coeff_eq_zero_of_lt_lexOrder hd.2, add_zero]\n\n"}
{"name":"MvPowerSeries.coeff_mul_of_add_lexOrder","module":"Mathlib.RingTheory.MvPowerSeries.LexOrder","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝² : Semiring R\ninst✝¹ : LinearOrder σ\ninst✝ : WellFoundedGT σ\nφ ψ : MvPowerSeries σ R\np q : Finsupp σ Nat\nhp : Eq φ.lexOrder ↑(toLex p)\nhq : Eq ψ.lexOrder ↑(toLex q)\n⊢ Eq ((MvPowerSeries.coeff R (HAdd.hAdd p q)) (HMul.hMul φ ψ)) (HMul.hMul ((MvPowerSeries.coeff R p) φ) ((MvPowerSeries.coeff R q) ψ))","decl":"theorem coeff_mul_of_add_lexOrder {φ ψ : MvPowerSeries σ R}\n    {p q : σ →₀ ℕ} (hp : lexOrder φ = toLex p) (hq : lexOrder ψ = toLex q) :\n    coeff R (p + q) (φ * ψ) = coeff R p φ * coeff R q ψ := by\n  rw [coeff_mul]\n  apply Finset.sum_eq_single (⟨p, q⟩ : (σ →₀ ℕ) × (σ →₀ ℕ))\n  · rintro ⟨u, v⟩ h h'\n    simp only [Finset.mem_antidiagonal] at h\n    simp only\n    by_cases hu : toLex u < toLex p\n    · rw [coeff_eq_zero_of_lt_lexOrder (R := R) (d := u), zero_mul]\n      simp only [hp, WithTop.coe_lt_coe, hu]\n    · rw [coeff_eq_zero_of_lt_lexOrder (d := v), mul_zero]\n      simp only [hq, WithTop.coe_lt_coe, ← not_le]\n      simp only [not_lt] at hu\n      intro hv\n      simp only [WithTop.coe_le_coe] at hv\n      apply h'\n      simp only [Prod.mk.injEq]\n      constructor\n      · apply toLex.injective\n        apply Or.resolve_right (eq_or_gt_of_le hu)\n        intro hu'\n        exact not_le.mpr (add_lt_add_of_lt_of_le hu' hv) (le_of_eq h)\n      · apply toLex.injective\n        apply Or.resolve_right (eq_or_gt_of_le hv)\n        intro hv'\n        exact not_le.mpr (add_lt_add_of_le_of_lt hu hv') (le_of_eq h)\n  · intro h\n    simp only [Finset.mem_antidiagonal, not_true_eq_false] at h\n\n"}
{"name":"MvPowerSeries.le_lexOrder_mul","module":"Mathlib.RingTheory.MvPowerSeries.LexOrder","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝² : Semiring R\ninst✝¹ : LinearOrder σ\ninst✝ : WellFoundedGT σ\nφ ψ : MvPowerSeries σ R\n⊢ LE.le (HAdd.hAdd φ.lexOrder ψ.lexOrder) (HMul.hMul φ ψ).lexOrder","decl":"theorem le_lexOrder_mul (φ ψ : MvPowerSeries σ R) :\n    lexOrder φ + lexOrder ψ ≤ lexOrder (φ * ψ) := by\n  rw [le_lexOrder_iff]\n  intro d hd\n  rw [coeff_mul]\n  apply Finset.sum_eq_zero\n  rintro ⟨u, v⟩ h\n  simp only [Finset.mem_antidiagonal] at h\n  simp only\n  suffices toLex u < lexOrder φ ∨ toLex v < lexOrder ψ by\n    rcases this with (hu | hv)\n    · rw [coeff_eq_zero_of_lt_lexOrder hu, zero_mul]\n    · rw [coeff_eq_zero_of_lt_lexOrder hv, mul_zero]\n  rw [or_iff_not_imp_left, not_lt, ← not_le]\n  intro hu hv\n  rw [← not_le] at hd\n  apply hd\n  simp only [← h, toLex_add, WithTop.coe_add, add_le_add hu hv]\n\n"}
{"name":"MvPowerSeries.lexOrder_mul_ge","module":"Mathlib.RingTheory.MvPowerSeries.LexOrder","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝² : Semiring R\ninst✝¹ : LinearOrder σ\ninst✝ : WellFoundedGT σ\nφ ψ : MvPowerSeries σ R\n⊢ LE.le (HAdd.hAdd φ.lexOrder ψ.lexOrder) (HMul.hMul φ ψ).lexOrder","decl":"alias lexOrder_mul_ge := le_lexOrder_mul\n\n"}
{"name":"MvPowerSeries.lexOrder_mul","module":"Mathlib.RingTheory.MvPowerSeries.LexOrder","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝³ : Semiring R\ninst✝² : LinearOrder σ\ninst✝¹ : WellFoundedGT σ\ninst✝ : NoZeroDivisors R\nφ ψ : MvPowerSeries σ R\n⊢ Eq (HMul.hMul φ ψ).lexOrder (HAdd.hAdd φ.lexOrder ψ.lexOrder)","decl":"theorem lexOrder_mul [NoZeroDivisors R] (φ ψ : MvPowerSeries σ R) :\n    lexOrder (φ * ψ) = lexOrder φ + lexOrder ψ := by\n  by_cases hφ : φ = 0\n  · simp only [hφ, zero_mul, lexOrder_zero, top_add]\n  by_cases hψ : ψ = 0\n  · simp only [hψ, mul_zero, lexOrder_zero, add_top]\n  rcases exists_finsupp_eq_lexOrder_of_ne_zero hφ with ⟨p, hp⟩\n  rcases exists_finsupp_eq_lexOrder_of_ne_zero hψ with ⟨q, hq⟩\n  apply le_antisymm _ (lexOrder_mul_ge φ ψ)\n  rw [hp, hq]\n  apply lexOrder_le_of_coeff_ne_zero (d := p + q)\n  rw [coeff_mul_of_add_lexOrder hp hq, mul_ne_zero_iff]\n  exact ⟨coeff_ne_zero_of_lexOrder hp.symm, coeff_ne_zero_of_lexOrder hq.symm⟩\n\n"}
