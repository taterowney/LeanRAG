{"name":"GromovHausdorff.HD_below_aux1","module":"Mathlib.Topology.MetricSpace.GromovHausdorffRealized","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : MetricSpace X\ninst✝ : MetricSpace Y\nf : GromovHausdorff.Cb X Y\nC : Real\nx : X\n⊢ BddBelow (Set.range fun y => HAdd.hAdd (f { fst := Sum.inl x, snd := Sum.inr y }) C)","decl":"theorem HD_below_aux1 {f : Cb X Y} (C : ℝ) {x : X} :\n    BddBelow (range fun y : Y => f (inl x, inr y) + C) :=\n  let ⟨cf, hcf⟩ := f.isBounded_range.bddBelow\n  ⟨cf + C, forall_mem_range.2 fun _ => add_le_add_right ((fun x => hcf (mem_range_self x)) _) _⟩\n\n"}
{"name":"GromovHausdorff.HD_below_aux2","module":"Mathlib.Topology.MetricSpace.GromovHausdorffRealized","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : MetricSpace X\ninst✝ : MetricSpace Y\nf : GromovHausdorff.Cb X Y\nC : Real\ny : Y\n⊢ BddBelow (Set.range fun x => HAdd.hAdd (f { fst := Sum.inl x, snd := Sum.inr y }) C)","decl":"theorem HD_below_aux2 {f : Cb X Y} (C : ℝ) {y : Y} :\n    BddBelow (range fun x : X => f (inl x, inr y) + C) :=\n  let ⟨cf, hcf⟩ := f.isBounded_range.bddBelow\n  ⟨cf + C, forall_mem_range.2 fun _ => add_le_add_right ((fun x => hcf (mem_range_self x)) _) _⟩\n\n"}
{"name":"GromovHausdorff.candidatesBOfCandidates_mem","module":"Mathlib.Topology.MetricSpace.GromovHausdorffRealized","initialProofState":"X : Type u\nY : Type v\ninst✝³ : MetricSpace X\ninst✝² : MetricSpace Y\ninst✝¹ : CompactSpace X\ninst✝ : CompactSpace Y\nf : GromovHausdorff.ProdSpaceFun X Y\nfA : Membership.mem (GromovHausdorff.candidates X Y) f\n⊢ Membership.mem (GromovHausdorff.candidatesB X Y) (GromovHausdorff.candidatesBOfCandidates f fA)","decl":"theorem candidatesBOfCandidates_mem (f : ProdSpaceFun X Y) (fA : f ∈ candidates X Y) :\n    candidatesBOfCandidates f fA ∈ candidatesB X Y :=\n  fA\n\n"}
{"name":"GromovHausdorff.candidatesBDist_mem_candidatesB","module":"Mathlib.Topology.MetricSpace.GromovHausdorffRealized","initialProofState":"X : Type u\nY : Type v\ninst✝⁵ : MetricSpace X\ninst✝⁴ : MetricSpace Y\ninst✝³ : CompactSpace X\ninst✝² : CompactSpace Y\ninst✝¹ : Nonempty X\ninst✝ : Nonempty Y\n⊢ Membership.mem (GromovHausdorff.candidatesB X Y) (GromovHausdorff.candidatesBDist X Y)","decl":"theorem candidatesBDist_mem_candidatesB :\n    candidatesBDist X Y ∈ candidatesB X Y :=\n  candidatesBOfCandidates_mem _ _\n\n"}
{"name":"GromovHausdorff.HD_candidatesBDist_le","module":"Mathlib.Topology.MetricSpace.GromovHausdorffRealized","initialProofState":"X : Type u\nY : Type v\ninst✝⁵ : MetricSpace X\ninst✝⁴ : MetricSpace Y\ninst✝³ : CompactSpace X\ninst✝² : CompactSpace Y\ninst✝¹ : Nonempty X\ninst✝ : Nonempty Y\n⊢ LE.le (GromovHausdorff.HD (GromovHausdorff.candidatesBDist X Y)) (HAdd.hAdd (HAdd.hAdd (Metric.diam Set.univ) 1) (Metric.diam Set.univ))","decl":"/-- Explicit bound on `HD (dist)`. This means that when looking for minimizers it will\nbe sufficient to look for functions with `HD(f)` bounded by this bound. -/\ntheorem HD_candidatesBDist_le :\n    HD (candidatesBDist X Y) ≤ diam (univ : Set X) + 1 + diam (univ : Set Y) := by\n  refine max_le (ciSup_le fun x => ?_) (ciSup_le fun y => ?_)\n  · have A : ⨅ y, candidatesBDist X Y (inl x, inr y) ≤ candidatesBDist X Y (inl x, inr default) :=\n      ciInf_le (by simpa using HD_below_aux1 0) default\n    have B : dist (inl x) (inr default) ≤ diam (univ : Set X) + 1 + diam (univ : Set Y) :=\n      calc\n        dist (inl x) (inr (default : Y)) = dist x (default : X) + 1 + dist default default := rfl\n        _ ≤ diam (univ : Set X) + 1 + diam (univ : Set Y) := by\n          gcongr <;>\n            exact dist_le_diam_of_mem isBounded_of_compactSpace (mem_univ _) (mem_univ _)\n    exact le_trans A B\n  · have A : ⨅ x, candidatesBDist X Y (inl x, inr y) ≤ candidatesBDist X Y (inl default, inr y) :=\n      ciInf_le (by simpa using HD_below_aux2 0) default\n    have B : dist (inl default) (inr y) ≤ diam (univ : Set X) + 1 + diam (univ : Set Y) :=\n      calc\n        dist (inl (default : X)) (inr y) = dist default default + 1 + dist default y := rfl\n        _ ≤ diam (univ : Set X) + 1 + diam (univ : Set Y) := by\n          gcongr <;>\n            exact dist_le_diam_of_mem isBounded_of_compactSpace (mem_univ _) (mem_univ _)\n    exact le_trans A B\n\n"}
{"name":"GromovHausdorff.isometry_optimalGHInjl","module":"Mathlib.Topology.MetricSpace.GromovHausdorffRealized","initialProofState":"X : Type u\nY : Type v\ninst✝⁵ : MetricSpace X\ninst✝⁴ : CompactSpace X\ninst✝³ : Nonempty X\ninst✝² : MetricSpace Y\ninst✝¹ : CompactSpace Y\ninst✝ : Nonempty Y\n⊢ Isometry (GromovHausdorff.optimalGHInjl X Y)","decl":"/-- The injection of `X` in the optimal coupling between `X` and `Y` is an isometry. -/\ntheorem isometry_optimalGHInjl : Isometry (optimalGHInjl X Y) :=\n  Isometry.of_dist_eq fun _ _ => candidates_dist_inl (optimalGHDist_mem_candidatesB X Y) _ _\n\n"}
{"name":"GromovHausdorff.isometry_optimalGHInjr","module":"Mathlib.Topology.MetricSpace.GromovHausdorffRealized","initialProofState":"X : Type u\nY : Type v\ninst✝⁵ : MetricSpace X\ninst✝⁴ : CompactSpace X\ninst✝³ : Nonempty X\ninst✝² : MetricSpace Y\ninst✝¹ : CompactSpace Y\ninst✝ : Nonempty Y\n⊢ Isometry (GromovHausdorff.optimalGHInjr X Y)","decl":"/-- The injection of `Y` in the optimal coupling between `X` and `Y` is an isometry. -/\ntheorem isometry_optimalGHInjr : Isometry (optimalGHInjr X Y) :=\n  Isometry.of_dist_eq fun _ _ => candidates_dist_inr (optimalGHDist_mem_candidatesB X Y) _ _\n\n"}
{"name":"GromovHausdorff.compactSpace_optimalGHCoupling","module":"Mathlib.Topology.MetricSpace.GromovHausdorffRealized","initialProofState":"X : Type u\nY : Type v\ninst✝⁵ : MetricSpace X\ninst✝⁴ : CompactSpace X\ninst✝³ : Nonempty X\ninst✝² : MetricSpace Y\ninst✝¹ : CompactSpace Y\ninst✝ : Nonempty Y\n⊢ CompactSpace (GromovHausdorff.OptimalGHCoupling X Y)","decl":"/-- The optimal coupling between two compact spaces `X` and `Y` is still a compact space -/\ninstance compactSpace_optimalGHCoupling : CompactSpace (OptimalGHCoupling X Y) := ⟨by\n  rw [← range_quotient_mk']\n  exact isCompact_range (continuous_sum_dom.2\n    ⟨(isometry_optimalGHInjl X Y).continuous, (isometry_optimalGHInjr X Y).continuous⟩)⟩\n\n"}
{"name":"GromovHausdorff.hausdorffDist_optimal_le_HD","module":"Mathlib.Topology.MetricSpace.GromovHausdorffRealized","initialProofState":"X : Type u\nY : Type v\ninst✝⁵ : MetricSpace X\ninst✝⁴ : CompactSpace X\ninst✝³ : Nonempty X\ninst✝² : MetricSpace Y\ninst✝¹ : CompactSpace Y\ninst✝ : Nonempty Y\nf : GromovHausdorff.Cb X Y\nh : Membership.mem (GromovHausdorff.candidatesB X Y) f\n⊢ LE.le (Metric.hausdorffDist (Set.range (GromovHausdorff.optimalGHInjl X Y)) (Set.range (GromovHausdorff.optimalGHInjr X Y))) (GromovHausdorff.HD f)","decl":"/-- For any candidate `f`, `HD(f)` is larger than or equal to the Hausdorff distance in the\noptimal coupling. This follows from the fact that `HD` of the optimal candidate is exactly\nthe Hausdorff distance in the optimal coupling, although we only prove here the inequality\nwe need. -/\ntheorem hausdorffDist_optimal_le_HD {f} (h : f ∈ candidatesB X Y) :\n    hausdorffDist (range (optimalGHInjl X Y)) (range (optimalGHInjr X Y)) ≤ HD f := by\n  refine le_trans (le_of_forall_gt_imp_ge_of_dense fun r hr => ?_) (HD_optimalGHDist_le X Y f h)\n  have A : ∀ x ∈ range (optimalGHInjl X Y), ∃ y ∈ range (optimalGHInjr X Y), dist x y ≤ r := by\n    rintro _ ⟨z, rfl⟩\n    have I1 : (⨆ x, ⨅ y, optimalGHDist X Y (inl x, inr y)) < r :=\n      lt_of_le_of_lt (le_max_left _ _) hr\n    have I2 :\n        ⨅ y, optimalGHDist X Y (inl z, inr y) ≤ ⨆ x, ⨅ y, optimalGHDist X Y (inl x, inr y) :=\n      le_csSup (by simpa using HD_bound_aux1 _ 0) (mem_range_self _)\n    have I : ⨅ y, optimalGHDist X Y (inl z, inr y) < r := lt_of_le_of_lt I2 I1\n    rcases exists_lt_of_csInf_lt (range_nonempty _) I with ⟨r', ⟨z', rfl⟩, hr'⟩\n    exact ⟨optimalGHInjr X Y z', mem_range_self _, le_of_lt hr'⟩\n  refine hausdorffDist_le_of_mem_dist ?_ A ?_\n  · inhabit X\n    rcases A _ (mem_range_self default) with ⟨y, -, hy⟩\n    exact le_trans dist_nonneg hy\n  · rintro _ ⟨z, rfl⟩\n    have I1 : (⨆ y, ⨅ x, optimalGHDist X Y (inl x, inr y)) < r :=\n      lt_of_le_of_lt (le_max_right _ _) hr\n    have I2 :\n        ⨅ x, optimalGHDist X Y (inl x, inr z) ≤ ⨆ y, ⨅ x, optimalGHDist X Y (inl x, inr y) :=\n      le_csSup (by simpa using HD_bound_aux2 _ 0) (mem_range_self _)\n    have I : ⨅ x, optimalGHDist X Y (inl x, inr z) < r := lt_of_le_of_lt I2 I1\n    rcases exists_lt_of_csInf_lt (range_nonempty _) I with ⟨r', ⟨z', rfl⟩, hr'⟩\n    refine ⟨optimalGHInjl X Y z', mem_range_self _, le_of_lt ?_⟩\n    rwa [dist_comm]\n\n"}
