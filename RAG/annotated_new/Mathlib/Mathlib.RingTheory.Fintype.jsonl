{"name":"Finset.univ_of_card_le_two","module":"Mathlib.RingTheory.Fintype","initialProofState":"R : Type u_1\ninst✝² : Ring R\ninst✝¹ : Fintype R\ninst✝ : DecidableEq R\nh : LE.le (Fintype.card R) 2\n⊢ Eq Finset.univ (Insert.insert 0 (Singleton.singleton 1))","decl":"lemma Finset.univ_of_card_le_two (h : Fintype.card R ≤ 2) :\n    (univ : Finset R) = {0, 1} := by\n  rcases subsingleton_or_nontrivial R\n  · exact le_antisymm (fun a _ ↦ by simp [Subsingleton.elim a 0]) (Finset.subset_univ _)\n  · refine (eq_of_subset_of_card_le (subset_univ _) ?_).symm\n    convert h\n    simp\n\n"}
{"name":"Finset.univ_of_card_le_three","module":"Mathlib.RingTheory.Fintype","initialProofState":"R : Type u_1\ninst✝² : Ring R\ninst✝¹ : Fintype R\ninst✝ : DecidableEq R\nh : LE.le (Fintype.card R) 3\n⊢ Eq Finset.univ (Insert.insert 0 (Insert.insert 1 (Singleton.singleton (-1))))","decl":"lemma Finset.univ_of_card_le_three (h : Fintype.card R ≤ 3) :\n    (univ : Finset R) = {0, 1, -1} := by\n  refine (eq_of_subset_of_card_le (subset_univ _) ?_).symm\n  rcases lt_or_eq_of_le h with h | h\n  · apply card_le_card\n    rw [Finset.univ_of_card_le_two (Nat.lt_succ_iff.1 h)]\n    intro a ha\n    simp only [mem_insert, mem_singleton] at ha\n    rcases ha with rfl | rfl <;> simp\n  · have : Nontrivial R := by\n      refine Fintype.one_lt_card_iff_nontrivial.1 ?_\n      rw [h]\n      norm_num\n    rw [card_univ, h, card_insert_of_not_mem, card_insert_of_not_mem, card_singleton]\n    · rw [mem_singleton]\n      intro H\n      rw [← add_eq_zero_iff_eq_neg, one_add_one_eq_two] at H\n      apply_fun (ringEquivOfPrime R Nat.prime_three h).symm at H\n      simp only [map_ofNat, map_zero] at H\n      replace H : ((2 : ℕ) : ZMod 3) = 0 := H\n      rw [natCast_zmod_eq_zero_iff_dvd] at H\n      norm_num at H\n    · intro h\n      simp only [mem_insert, mem_singleton, zero_eq_neg] at h\n      rcases h with (h | h)\n      · exact zero_ne_one h\n      · exact zero_ne_one h.symm\n\n"}
{"name":"card_units_lt","module":"Mathlib.RingTheory.Fintype","initialProofState":"M₀ : Type u_2\ninst✝² : MonoidWithZero M₀\ninst✝¹ : Nontrivial M₀\ninst✝ : Fintype M₀\n⊢ LT.lt (Fintype.card (Units M₀)) (Fintype.card M₀)","decl":"open scoped Classical in\ntheorem card_units_lt (M₀ : Type*) [MonoidWithZero M₀] [Nontrivial M₀] [Fintype M₀] :\n    Fintype.card M₀ˣ < Fintype.card M₀ :=\n  Fintype.card_lt_of_injective_of_not_mem Units.val Units.ext not_isUnit_zero\n"}
