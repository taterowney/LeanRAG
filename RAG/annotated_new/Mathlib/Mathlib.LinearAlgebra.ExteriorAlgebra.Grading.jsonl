{"name":"ExteriorAlgebra.GradedAlgebra.ι_apply","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Grading","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nm : M\n⊢ Eq ((ExteriorAlgebra.GradedAlgebra.ι R M) m) ((DirectSum.of (fun i => Subtype fun x => Membership.mem (ExteriorAlgebra.exteriorPower R i M) x) 1) ⟨(ExteriorAlgebra.ι R) m, ⋯⟩)","decl":"theorem GradedAlgebra.ι_apply (m : M) :\n    GradedAlgebra.ι R M m =\n      DirectSum.of (fun i : ℕ => ⋀[R]^i M) 1\n        ⟨ι R m, by simpa only [pow_one] using LinearMap.mem_range_self _ m⟩ :=\n  rfl\n\n-- Defining this instance manually, because Lean doesn't seem to be able to synthesize it.\n-- Strangely, this problem only appears when we use the abbreviation or notation for the\n-- exterior powers.\n"}
{"name":"ExteriorAlgebra.instGradedMonoidNatSubmoduleExteriorPower","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Grading","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ SetLike.GradedMonoid fun i => ExteriorAlgebra.exteriorPower R i M","decl":"instance : SetLike.GradedMonoid fun i : ℕ ↦ ⋀[R]^i M :=\n  Submodule.nat_power_gradedMonoid (LinearMap.range (ι R : M →ₗ[R] ExteriorAlgebra R M))\n\n-- Porting note: Lean needs to be reminded of this instance otherwise it cannot\n-- synthesize 0 in the next theorem\n"}
{"name":"ExteriorAlgebra.GradedAlgebra.ι_sq_zero","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Grading","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nm : M\n⊢ Eq (HMul.hMul ((ExteriorAlgebra.GradedAlgebra.ι R M) m) ((ExteriorAlgebra.GradedAlgebra.ι R M) m)) 0","decl":"attribute [local instance 1100] MulZeroClass.toZero in\ntheorem GradedAlgebra.ι_sq_zero (m : M) : GradedAlgebra.ι R M m * GradedAlgebra.ι R M m = 0 := by\n  rw [GradedAlgebra.ι_apply, DirectSum.of_mul_of]\n  exact DFinsupp.single_eq_zero.mpr (Subtype.ext <| ExteriorAlgebra.ι_sq_zero _)\n\n"}
{"name":"ExteriorAlgebra.GradedAlgebra.liftι_eq","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Grading","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ni : Nat\nx : Subtype fun x => Membership.mem (ExteriorAlgebra.exteriorPower R i M) x\n⊢ Eq ((ExteriorAlgebra.GradedAlgebra.liftι R M) ↑x) ((DirectSum.of (fun i => Subtype fun x => Membership.mem (ExteriorAlgebra.exteriorPower R i M) x) i) x)","decl":"theorem GradedAlgebra.liftι_eq (i : ℕ) (x : ⋀[R]^i M) :\n    GradedAlgebra.liftι R M x = DirectSum.of (fun i => ⋀[R]^i M) i x := by\n  cases' x with x hx\n  dsimp only [Subtype.coe_mk, DirectSum.lof_eq_of]\n  induction hx using Submodule.pow_induction_on_left' with\n  | algebraMap => simp_rw [AlgHom.commutes, DirectSum.algebraMap_apply]; rfl\n  | add _ _ _ _ _ ihx ihy => simp_rw [map_add, ihx, ihy, ← AddMonoidHom.map_add]; rfl\n  | mem_mul _ hm _ _ _ ih =>\n      obtain ⟨_, rfl⟩ := hm\n      simp_rw [map_mul, ih, GradedAlgebra.liftι, lift_ι_apply, GradedAlgebra.ι_apply R M,\n        DirectSum.of_mul_of]\n      exact DirectSum.of_eq_of_gradedMonoid_eq (Sigma.subtype_ext (add_comm _ _) rfl)\n\n"}
{"name":"ExteriorAlgebra.ιMulti_span","module":"Mathlib.LinearAlgebra.ExteriorAlgebra.Grading","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Eq (Submodule.span R (Set.range fun x => (ExteriorAlgebra.ιMulti R x.fst) x.snd)) Top.top","decl":"/-- The union of the images of the maps `ExteriorAlgebra.ιMulti R n` for `n` running through\nall natural numbers spans the exterior algebra. -/\nlemma ιMulti_span :\n    Submodule.span R (Set.range fun x : Σ n, (Fin n → M) => ιMulti R x.1 x.2) = ⊤ := by\n  rw [Submodule.eq_top_iff']\n  intro x\n  induction x using DirectSum.Decomposition.inductionOn fun i => ⋀[R]^i M with\n  | h_zero => exact Submodule.zero_mem _\n  | h_add _ _ hm hm' => exact Submodule.add_mem _ hm hm'\n  | h_homogeneous hm =>\n    let ⟨m, hm⟩ := hm\n    apply Set.mem_of_mem_of_subset hm\n    rw [← ιMulti_span_fixedDegree]\n    refine Submodule.span_mono fun _ hx ↦ ?_\n    obtain ⟨y, rfl⟩ := hx\n    exact ⟨⟨_, y⟩, rfl⟩\n\n"}
