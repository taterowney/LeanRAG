{"name":"ContinuousMap.idealOfSet_closed","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nR : Type u_2\ninst✝⁴ : TopologicalSpace X\ninst✝³ : Semiring R\ninst✝² : TopologicalSpace R\ninst✝¹ : TopologicalSemiring R\ninst✝ : T2Space R\ns : Set X\n⊢ IsClosed ↑(ContinuousMap.idealOfSet R s)","decl":"theorem idealOfSet_closed [T2Space R] (s : Set X) :\n    IsClosed (idealOfSet R s : Set C(X, R)) := by\n  simp only [idealOfSet, Submodule.coe_set_mk, Set.setOf_forall]\n  exact isClosed_iInter fun x => isClosed_iInter fun _ =>\n    isClosed_eq (continuous_eval_const x) continuous_const\n\n"}
{"name":"ContinuousMap.mem_idealOfSet","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nR : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : Semiring R\ninst✝¹ : TopologicalSpace R\ninst✝ : TopologicalSemiring R\ns : Set X\nf : ContinuousMap X R\n⊢ Iff (Membership.mem (ContinuousMap.idealOfSet R s) f) (∀ ⦃x : X⦄, Membership.mem (HasCompl.compl s) x → Eq (f x) 0)","decl":"theorem mem_idealOfSet {s : Set X} {f : C(X, R)} :\n    f ∈ idealOfSet R s ↔ ∀ ⦃x : X⦄, x ∈ sᶜ → f x = 0 := by\n  convert Iff.rfl\n\n"}
{"name":"ContinuousMap.not_mem_idealOfSet","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nR : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : Semiring R\ninst✝¹ : TopologicalSpace R\ninst✝ : TopologicalSemiring R\ns : Set X\nf : ContinuousMap X R\n⊢ Iff (Not (Membership.mem (ContinuousMap.idealOfSet R s) f)) (Exists fun x => And (Membership.mem (HasCompl.compl s) x) (Ne (f x) 0))","decl":"theorem not_mem_idealOfSet {s : Set X} {f : C(X, R)} : f ∉ idealOfSet R s ↔ ∃ x ∈ sᶜ, f x ≠ 0 := by\n  simp_rw [mem_idealOfSet]; push_neg; rfl\n\n"}
{"name":"ContinuousMap.not_mem_setOfIdeal","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nR : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : Semiring R\ninst✝¹ : TopologicalSpace R\ninst✝ : TopologicalSemiring R\nI : Ideal (ContinuousMap X R)\nx : X\n⊢ Iff (Not (Membership.mem (ContinuousMap.setOfIdeal I) x)) (∀ ⦃f : ContinuousMap X R⦄, Membership.mem I f → Eq (f x) 0)","decl":"theorem not_mem_setOfIdeal {I : Ideal C(X, R)} {x : X} :\n    x ∉ setOfIdeal I ↔ ∀ ⦃f : C(X, R)⦄, f ∈ I → f x = 0 := by\n  rw [← Set.mem_compl_iff, setOfIdeal, compl_compl, Set.mem_setOf]\n\n"}
{"name":"ContinuousMap.mem_setOfIdeal","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nR : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : Semiring R\ninst✝¹ : TopologicalSpace R\ninst✝ : TopologicalSemiring R\nI : Ideal (ContinuousMap X R)\nx : X\n⊢ Iff (Membership.mem (ContinuousMap.setOfIdeal I) x) (Exists fun f => And (Membership.mem I f) (Ne (f x) 0))","decl":"theorem mem_setOfIdeal {I : Ideal C(X, R)} {x : X} :\n    x ∈ setOfIdeal I ↔ ∃ f ∈ I, (f : C(X, R)) x ≠ 0 := by\n  simp_rw [setOfIdeal, Set.mem_compl_iff, Set.mem_setOf]; push_neg; rfl\n\n"}
{"name":"ContinuousMap.setOfIdeal_open","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nR : Type u_2\ninst✝⁴ : TopologicalSpace X\ninst✝³ : Semiring R\ninst✝² : TopologicalSpace R\ninst✝¹ : TopologicalSemiring R\ninst✝ : T2Space R\nI : Ideal (ContinuousMap X R)\n⊢ IsOpen (ContinuousMap.setOfIdeal I)","decl":"theorem setOfIdeal_open [T2Space R] (I : Ideal C(X, R)) : IsOpen (setOfIdeal I) := by\n  simp only [setOfIdeal, Set.setOf_forall, isOpen_compl_iff]\n  exact\n    isClosed_iInter fun f =>\n      isClosed_iInter fun _ => isClosed_eq (map_continuous f) continuous_const\n\n"}
{"name":"ContinuousMap.coe_opensOfIdeal","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nR : Type u_2\ninst✝⁴ : TopologicalSpace X\ninst✝³ : Semiring R\ninst✝² : TopologicalSpace R\ninst✝¹ : TopologicalSemiring R\ninst✝ : T2Space R\nI : Ideal (ContinuousMap X R)\n⊢ Eq (↑(ContinuousMap.opensOfIdeal I)) (ContinuousMap.setOfIdeal I)","decl":"/-- The open set `ContinuousMap.setOfIdeal I` realized as a term of `opens X`. -/\n@[simps]\ndef opensOfIdeal [T2Space R] (I : Ideal C(X, R)) : Opens X :=\n  ⟨setOfIdeal I, setOfIdeal_open I⟩\n\n"}
{"name":"ContinuousMap.setOfTop_eq_univ","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nR : Type u_2\ninst✝⁴ : TopologicalSpace X\ninst✝³ : Semiring R\ninst✝² : TopologicalSpace R\ninst✝¹ : TopologicalSemiring R\ninst✝ : Nontrivial R\n⊢ Eq (ContinuousMap.setOfIdeal Top.top) Set.univ","decl":"@[simp]\ntheorem setOfTop_eq_univ [Nontrivial R] : setOfIdeal (⊤ : Ideal C(X, R)) = Set.univ :=\n  Set.univ_subset_iff.mp fun _ _ => mem_setOfIdeal.mpr ⟨1, Submodule.mem_top, one_ne_zero⟩\n\n"}
{"name":"ContinuousMap.idealOfEmpty_eq_bot","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nR : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : Semiring R\ninst✝¹ : TopologicalSpace R\ninst✝ : TopologicalSemiring R\n⊢ Eq (ContinuousMap.idealOfSet R EmptyCollection.emptyCollection) Bot.bot","decl":"@[simp]\ntheorem idealOfEmpty_eq_bot : idealOfSet R (∅ : Set X) = ⊥ :=\n  Ideal.ext fun f => by\n    simp only [mem_idealOfSet, Set.compl_empty, Set.mem_univ, forall_true_left, Ideal.mem_bot,\n      DFunLike.ext_iff, zero_apply]\n\n"}
{"name":"ContinuousMap.mem_idealOfSet_compl_singleton","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nR : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : Semiring R\ninst✝¹ : TopologicalSpace R\ninst✝ : TopologicalSemiring R\nx : X\nf : ContinuousMap X R\n⊢ Iff (Membership.mem (ContinuousMap.idealOfSet R (HasCompl.compl (Singleton.singleton x))) f) (Eq (f x) 0)","decl":"@[simp]\ntheorem mem_idealOfSet_compl_singleton (x : X) (f : C(X, R)) :\n    f ∈ idealOfSet R ({x}ᶜ : Set X) ↔ f x = 0 := by\n  simp only [mem_idealOfSet, compl_compl, Set.mem_singleton_iff, forall_eq]\n\n"}
{"name":"ContinuousMap.ideal_gc","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nR : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : Semiring R\ninst✝¹ : TopologicalSpace R\ninst✝ : TopologicalSemiring R\n⊢ GaloisConnection ContinuousMap.setOfIdeal (ContinuousMap.idealOfSet R)","decl":"theorem ideal_gc : GaloisConnection (setOfIdeal : Ideal C(X, R) → Set X) (idealOfSet R) := by\n  refine fun I s => ⟨fun h f hf => ?_, fun h x hx => ?_⟩\n  · by_contra h'\n    rcases not_mem_idealOfSet.mp h' with ⟨x, hx, hfx⟩\n    exact hfx (not_mem_setOfIdeal.mp (mt (@h x) hx) hf)\n  · obtain ⟨f, hf, hfx⟩ := mem_setOfIdeal.mp hx\n    by_contra hx'\n    exact not_mem_idealOfSet.mpr ⟨x, hx', hfx⟩ (h hf)\n\n"}
{"name":"ContinuousMap.exists_mul_le_one_eqOn_ge","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nf : ContinuousMap X NNReal\nc : NNReal\nhc : LT.lt 0 c\n⊢ Exists fun g => And (∀ (x : X), LE.le ((HMul.hMul g f) x) 1) (Set.EqOn (⇑(HMul.hMul g f)) 1 (setOf fun x => LE.le c (f x)))","decl":"/-- An auxiliary lemma used in the proof of `ContinuousMap.idealOfSet_ofIdeal_eq_closure` which may\nbe useful on its own. -/\ntheorem exists_mul_le_one_eqOn_ge (f : C(X, ℝ≥0)) {c : ℝ≥0} (hc : 0 < c) :\n    ∃ g : C(X, ℝ≥0), (∀ x : X, (g * f) x ≤ 1) ∧ {x : X | c ≤ f x}.EqOn (g * f) 1 :=\n  ⟨{  toFun := (f ⊔ const X c)⁻¹\n      continuous_toFun :=\n        ((map_continuous f).sup <| map_continuous _).inv₀ fun _ => (hc.trans_le le_sup_right).ne' },\n    fun x =>\n    (inv_mul_le_iff₀ (hc.trans_le le_sup_right)).mpr ((mul_one (f x ⊔ c)).symm ▸ le_sup_left),\n    fun x hx => by\n    simpa only [coe_const, mul_apply, coe_mk, Pi.inv_apply, Pi.sup_apply,\n      Function.const_apply, sup_eq_left.mpr (Set.mem_setOf.mp hx), ne_eq, Pi.one_apply]\n      using inv_mul_cancel₀ (hc.trans_le hx).ne' ⟩\n\n"}
{"name":"ContinuousMap.idealOfSet_ofIdeal_eq_closure","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\n𝕜 : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : TopologicalSpace X\ninst✝¹ : CompactSpace X\ninst✝ : T2Space X\nI : Ideal (ContinuousMap X 𝕜)\n⊢ Eq (ContinuousMap.idealOfSet 𝕜 (ContinuousMap.setOfIdeal I)) I.closure","decl":"@[simp]\ntheorem idealOfSet_ofIdeal_eq_closure (I : Ideal C(X, 𝕜)) :\n    idealOfSet 𝕜 (setOfIdeal I) = I.closure := by\n  /- Since `idealOfSet 𝕜 (setOfIdeal I)` is closed and contains `I`, it contains `I.closure`.\n    For the reverse inclusion, given `f ∈ idealOfSet 𝕜 (setOfIdeal I)` and `(ε : ℝ≥0) > 0` it\n    suffices to show that `f` is within `ε` of `I`. -/\n  refine le_antisymm ?_\n      ((idealOfSet_closed 𝕜 <| setOfIdeal I).closure_subset_iff.mpr fun f hf x hx =>\n        not_mem_setOfIdeal.mp hx hf)\n  refine (fun f hf => Metric.mem_closure_iff.mpr fun ε hε => ?_)\n  lift ε to ℝ≥0 using hε.lt.le\n  replace hε := show (0 : ℝ≥0) < ε from hε\n  simp_rw [dist_nndist]\n  norm_cast\n  -- Let `t := {x : X | ε / 2 ≤ ‖f x‖₊}}` which is closed and disjoint from `set_of_ideal I`.\n  set t := {x : X | ε / 2 ≤ ‖f x‖₊}\n  have ht : IsClosed t := isClosed_le continuous_const (map_continuous f).nnnorm\n  have htI : Disjoint t (setOfIdeal I)ᶜ := by\n    refine Set.subset_compl_iff_disjoint_left.mp fun x hx => ?_\n    simpa only [t, Set.mem_setOf, Set.mem_compl_iff, not_le] using\n      (nnnorm_eq_zero.mpr (mem_idealOfSet.mp hf hx)).trans_lt (half_pos hε)\n  /- It suffices to produce `g : C(X, ℝ≥0)` which takes values in `[0,1]` and is constantly `1` on\n    `t` such that when composed with the natural embedding of `ℝ≥0` into `𝕜` lies in the ideal `I`.\n    Indeed, then `‖f - f * ↑g‖ ≤ ‖f * (1 - ↑g)‖ ≤ ⨆ ‖f * (1 - ↑g) x‖`. When `x ∉ t`, `‖f x‖ < ε / 2`\n    and `‖(1 - ↑g) x‖ ≤ 1`, and when `x ∈ t`, `(1 - ↑g) x = 0`, and clearly `f * ↑g ∈ I`. -/\n  suffices\n    ∃ g : C(X, ℝ≥0), (algebraMapCLM ℝ≥0 𝕜 : C(ℝ≥0, 𝕜)).comp g ∈ I ∧ (∀ x, g x ≤ 1) ∧ t.EqOn g 1 by\n    obtain ⟨g, hgI, hg, hgt⟩ := this\n    refine ⟨f * (algebraMapCLM ℝ≥0 𝕜 : C(ℝ≥0, 𝕜)).comp g, I.mul_mem_left f hgI, ?_⟩\n    rw [nndist_eq_nnnorm]\n    refine (nnnorm_lt_iff _ hε).2 fun x => ?_\n    simp only [coe_sub, coe_mul, Pi.sub_apply, Pi.mul_apply]\n    by_cases hx : x ∈ t\n    · simpa only [hgt hx, comp_apply, Pi.one_apply, ContinuousMap.coe_coe, algebraMapCLM_apply,\n        map_one, mul_one, sub_self, nnnorm_zero] using hε\n    · refine lt_of_le_of_lt ?_ (half_lt_self hε)\n      have :=\n        calc\n          ‖((1 - (algebraMapCLM ℝ≥0 𝕜 : C(ℝ≥0, 𝕜)).comp g) x : 𝕜)‖₊ =\n              ‖1 - algebraMap ℝ≥0 𝕜 (g x)‖₊ := by\n            simp only [coe_sub, coe_one, coe_comp, ContinuousMap.coe_coe, Pi.sub_apply,\n              Pi.one_apply, Function.comp_apply, algebraMapCLM_apply]\n          _ = ‖algebraMap ℝ≥0 𝕜 (1 - g x)‖₊ := by\n            simp only [Algebra.algebraMap_eq_smul_one, NNReal.smul_def, NNReal.coe_sub (hg x),\n              NNReal.coe_one, sub_smul, one_smul]\n          _ ≤ 1 := (nnnorm_algebraMap_nnreal 𝕜 (1 - g x)).trans_le tsub_le_self\n      calc\n        ‖f x - f x * (algebraMapCLM ℝ≥0 𝕜 : C(ℝ≥0, 𝕜)).comp g x‖₊ =\n            ‖f x * (1 - (algebraMapCLM ℝ≥0 𝕜 : C(ℝ≥0, 𝕜)).comp g) x‖₊ := by\n          simp only [mul_sub, coe_sub, coe_one, Pi.sub_apply, Pi.one_apply, mul_one]\n        _ ≤ ε / 2 * ‖(1 - (algebraMapCLM ℝ≥0 𝕜 : C(ℝ≥0, 𝕜)).comp g) x‖₊ :=\n          ((nnnorm_mul_le _ _).trans\n            (mul_le_mul_right' (not_le.mp <| show ¬ε / 2 ≤ ‖f x‖₊ from hx).le _))\n        _ ≤ ε / 2 := by simpa only [mul_one] using mul_le_mul_left' this _\n  /- There is some `g' : C(X, ℝ≥0)` which is strictly positive on `t` such that the composition\n    `↑g` with the natural embedding of `ℝ≥0` into `𝕜` lies in `I`. This follows from compactness of\n    `t` and that we can do it in any neighborhood of a point `x ∈ t`. Indeed, since `x ∈ t`, then\n    `fₓ x ≠ 0` for some `fₓ ∈ I` and so `fun y ↦ ‖(star fₓ * fₓ) y‖₊` is strictly posiive in a\n    neighborhood of `y`. Moreover, `(‖(star fₓ * fₓ) y‖₊ : 𝕜) = (star fₓ * fₓ) y`, so composition of\n    this map with the natural embedding is just `star fₓ * fₓ ∈ I`. -/\n  have : ∃ g' : C(X, ℝ≥0), (algebraMapCLM ℝ≥0 𝕜 : C(ℝ≥0, 𝕜)).comp g' ∈ I ∧ ∀ x ∈ t, 0 < g' x := by\n    refine ht.isCompact.induction_on ?_ ?_ ?_ ?_\n    · refine ⟨0, ?_, fun x hx => False.elim hx⟩\n      convert I.zero_mem\n      ext\n      simp only [comp_apply, zero_apply, ContinuousMap.coe_coe, map_zero]\n    · rintro s₁ s₂ hs ⟨g, hI, hgt⟩; exact ⟨g, hI, fun x hx => hgt x (hs hx)⟩\n    · rintro s₁ s₂ ⟨g₁, hI₁, hgt₁⟩ ⟨g₂, hI₂, hgt₂⟩\n      refine ⟨g₁ + g₂, ?_, fun x hx => ?_⟩\n      · convert I.add_mem hI₁ hI₂\n        ext y\n        simp only [coe_add, Pi.add_apply, map_add, coe_comp, Function.comp_apply,\n          ContinuousMap.coe_coe]\n      · rcases hx with (hx | hx)\n        · simpa only [zero_add] using add_lt_add_of_lt_of_le (hgt₁ x hx) zero_le'\n        · simpa only [zero_add] using add_lt_add_of_le_of_lt zero_le' (hgt₂ x hx)\n    · intro x hx\n      replace hx := htI.subset_compl_right hx\n      rw [compl_compl, mem_setOfIdeal] at hx\n      obtain ⟨g, hI, hgx⟩ := hx\n      have := (map_continuous g).continuousAt.eventually_ne hgx\n      refine\n        ⟨{y : X | g y ≠ 0} ∩ t,\n          mem_nhdsWithin_iff_exists_mem_nhds_inter.mpr ⟨_, this, Set.Subset.rfl⟩,\n          ⟨⟨fun x => ‖g x‖₊ ^ 2, (map_continuous g).nnnorm.pow 2⟩, ?_, fun x hx =>\n            pow_pos (norm_pos_iff.mpr hx.1) 2⟩⟩\n      convert I.mul_mem_left (star g) hI\n      ext\n      simp only [comp_apply, ContinuousMap.coe_coe, coe_mk, algebraMapCLM_apply, map_pow,\n        mul_apply, star_apply, star_def]\n      simp only [normSq_eq_def', RCLike.conj_mul, ofReal_pow]\n      rfl\n  /- Get the function `g'` which is guaranteed to exist above. By the extreme value theorem and\n    compactness of `t`, there is some `0 < c` such that `c ≤ g' x` for all `x ∈ t`. Then by\n    `exists_mul_le_one_eqOn_ge` there is some `g` for which `g * g'` is the desired function. -/\n  obtain ⟨g', hI', hgt'⟩ := this\n  obtain ⟨c, hc, hgc'⟩ : ∃ c > 0, ∀ y : X, y ∈ t → c ≤ g' y :=\n    t.eq_empty_or_nonempty.elim\n      (fun ht' => ⟨1, zero_lt_one, fun y hy => False.elim (by rwa [ht'] at hy)⟩) fun ht' =>\n      let ⟨x, hx, hx'⟩ := ht.isCompact.exists_isMinOn ht' (map_continuous g').continuousOn\n      ⟨g' x, hgt' x hx, hx'⟩\n  obtain ⟨g, hg, hgc⟩ := exists_mul_le_one_eqOn_ge g' hc\n  refine ⟨g * g', ?_, hg, hgc.mono hgc'⟩\n  convert I.mul_mem_left ((algebraMapCLM ℝ≥0 𝕜 : C(ℝ≥0, 𝕜)).comp g) hI'\n  ext\n  simp only [algebraMapCLM_coe, comp_apply, mul_apply, ContinuousMap.coe_coe, map_mul]\n\n"}
{"name":"ContinuousMap.idealOfSet_ofIdeal_isClosed","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\n𝕜 : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : TopologicalSpace X\ninst✝¹ : CompactSpace X\ninst✝ : T2Space X\nI : Ideal (ContinuousMap X 𝕜)\nhI : IsClosed ↑I\n⊢ Eq (ContinuousMap.idealOfSet 𝕜 (ContinuousMap.setOfIdeal I)) I","decl":"theorem idealOfSet_ofIdeal_isClosed {I : Ideal C(X, 𝕜)} (hI : IsClosed (I : Set C(X, 𝕜))) :\n    idealOfSet 𝕜 (setOfIdeal I) = I :=\n  (idealOfSet_ofIdeal_eq_closure I).trans (Ideal.ext <| Set.ext_iff.mp hI.closure_eq)\n\n"}
{"name":"ContinuousMap.setOfIdeal_ofSet_eq_interior","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\n𝕜 : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : TopologicalSpace X\ninst✝¹ : CompactSpace X\ninst✝ : T2Space X\ns : Set X\n⊢ Eq (ContinuousMap.setOfIdeal (ContinuousMap.idealOfSet 𝕜 s)) (interior s)","decl":"@[simp]\ntheorem setOfIdeal_ofSet_eq_interior (s : Set X) : setOfIdeal (idealOfSet 𝕜 s) = interior s := by\n  refine\n    Set.Subset.antisymm\n      ((setOfIdeal_open (idealOfSet 𝕜 s)).subset_interior_iff.mpr fun x hx =>\n        let ⟨f, hf, hfx⟩ := mem_setOfIdeal.mp hx\n        Set.not_mem_compl_iff.mp (mt (@hf x) hfx))\n      fun x hx => ?_\n  -- If `x ∉ closure sᶜ`, we must produce `f : C(X, 𝕜)` which is zero on `sᶜ` and `f x ≠ 0`.\n  rw [← compl_compl (interior s), ← closure_compl] at hx\n  simp_rw [mem_setOfIdeal, mem_idealOfSet]\n  /- Apply Urysohn's lemma to get `g : C(X, ℝ)` which is zero on `sᶜ` and `g x ≠ 0`, then compose\n    with the natural embedding `ℝ ↪ 𝕜` to produce the desired `f`. -/\n  obtain ⟨g, hgs, hgx : Set.EqOn g 1 {x}, -⟩ :=\n    exists_continuous_zero_one_of_isClosed isClosed_closure isClosed_singleton\n      (Set.disjoint_singleton_right.mpr hx)\n  exact\n    ⟨⟨fun x => g x, continuous_ofReal.comp (map_continuous g)⟩, by\n      simpa only [coe_mk, ofReal_eq_zero] using fun x hx => hgs (subset_closure hx), by\n      simpa only [coe_mk, hgx (Set.mem_singleton x), Pi.one_apply, RCLike.ofReal_one] using\n        one_ne_zero⟩\n\n"}
{"name":"ContinuousMap.setOfIdeal_ofSet_of_isOpen","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\n𝕜 : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : TopologicalSpace X\ninst✝¹ : CompactSpace X\ninst✝ : T2Space X\ns : Set X\nhs : IsOpen s\n⊢ Eq (ContinuousMap.setOfIdeal (ContinuousMap.idealOfSet 𝕜 s)) s","decl":"theorem setOfIdeal_ofSet_of_isOpen {s : Set X} (hs : IsOpen s) : setOfIdeal (idealOfSet 𝕜 s) = s :=\n  (setOfIdeal_ofSet_eq_interior 𝕜 s).trans hs.interior_eq\n\n"}
{"name":"ContinuousMap.idealOpensGI_choice","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\n𝕜 : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : TopologicalSpace X\ninst✝¹ : CompactSpace X\ninst✝ : T2Space X\nI : Ideal (ContinuousMap X 𝕜)\nx✝ : LE.le (ContinuousMap.idealOfSet 𝕜 ↑(ContinuousMap.opensOfIdeal I)) I\n⊢ Eq ((ContinuousMap.idealOpensGI X 𝕜).choice I x✝) (ContinuousMap.opensOfIdeal I.closure)","decl":"/-- The Galois insertion `ContinuousMap.opensOfIdeal : Ideal C(X, 𝕜) → Opens X` and\n`fun s ↦ ContinuousMap.idealOfSet ↑s`. -/\n@[simps]\ndef idealOpensGI :\n    GaloisInsertion (opensOfIdeal : Ideal C(X, 𝕜) → Opens X) fun s => idealOfSet 𝕜 s where\n  choice I _ := opensOfIdeal I.closure\n  gc I s := ideal_gc X 𝕜 I s\n  le_l_u s := (setOfIdeal_ofSet_of_isOpen 𝕜 s.isOpen).ge\n  choice_eq I hI :=\n    congr_arg _ <|\n      Ideal.ext\n        (Set.ext_iff.mp\n          (isClosed_of_closure_subset <|\n              (idealOfSet_ofIdeal_eq_closure I ▸ hI : I.closure ≤ I)).closure_eq)\n\n"}
{"name":"ContinuousMap.idealOfSet_isMaximal_iff","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\n𝕜 : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : TopologicalSpace X\ninst✝¹ : CompactSpace X\ninst✝ : T2Space X\ns : TopologicalSpace.Opens X\n⊢ Iff (ContinuousMap.idealOfSet 𝕜 ↑s).IsMaximal (IsCoatom s)","decl":"theorem idealOfSet_isMaximal_iff (s : Opens X) :\n    (idealOfSet 𝕜 (s : Set X)).IsMaximal ↔ IsCoatom s := by\n  rw [Ideal.isMaximal_def]\n  refine (idealOpensGI X 𝕜).isCoatom_iff (fun I hI => ?_) s\n  rw [← Ideal.isMaximal_def] at hI\n  exact idealOfSet_ofIdeal_isClosed inferInstance\n\n"}
{"name":"ContinuousMap.idealOf_compl_singleton_isMaximal","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\n𝕜 : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : TopologicalSpace X\ninst✝¹ : CompactSpace X\ninst✝ : T2Space X\nx : X\n⊢ (ContinuousMap.idealOfSet 𝕜 (HasCompl.compl (Singleton.singleton x))).IsMaximal","decl":"theorem idealOf_compl_singleton_isMaximal (x : X) : (idealOfSet 𝕜 ({x}ᶜ : Set X)).IsMaximal :=\n  (idealOfSet_isMaximal_iff 𝕜 (Closeds.singleton x).compl).mpr <| Opens.isCoatom_iff.mpr ⟨x, rfl⟩\n\n"}
{"name":"ContinuousMap.setOfIdeal_eq_compl_singleton","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\n𝕜 : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : TopologicalSpace X\ninst✝¹ : CompactSpace X\ninst✝ : T2Space X\nI : Ideal (ContinuousMap X 𝕜)\nhI : I.IsMaximal\n⊢ Exists fun x => Eq (ContinuousMap.setOfIdeal I) (HasCompl.compl (Singleton.singleton x))","decl":"theorem setOfIdeal_eq_compl_singleton (I : Ideal C(X, 𝕜)) [hI : I.IsMaximal] :\n    ∃ x : X, setOfIdeal I = {x}ᶜ := by\n  have h : (idealOfSet 𝕜 (setOfIdeal I)).IsMaximal :=\n    (idealOfSet_ofIdeal_isClosed (inferInstance : IsClosed (I : Set C(X, 𝕜)))).symm ▸ hI\n  obtain ⟨x, hx⟩ := Opens.isCoatom_iff.1 ((idealOfSet_isMaximal_iff 𝕜 (opensOfIdeal I)).1 h)\n  exact ⟨x, congr_arg (fun (s : Opens X) => (s : Set X)) hx⟩\n\n"}
{"name":"ContinuousMap.ideal_isMaximal_iff","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\n𝕜 : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : TopologicalSpace X\ninst✝¹ : CompactSpace X\ninst✝ : T2Space X\nI : Ideal (ContinuousMap X 𝕜)\nhI : IsClosed ↑I\n⊢ Iff I.IsMaximal (Exists fun x => Eq (ContinuousMap.idealOfSet 𝕜 (HasCompl.compl (Singleton.singleton x))) I)","decl":"theorem ideal_isMaximal_iff (I : Ideal C(X, 𝕜)) [hI : IsClosed (I : Set C(X, 𝕜))] :\n    I.IsMaximal ↔ ∃ x : X, idealOfSet 𝕜 {x}ᶜ = I := by\n  refine\n    ⟨?_, fun h =>\n      let ⟨x, hx⟩ := h\n      hx ▸ idealOf_compl_singleton_isMaximal 𝕜 x⟩\n  intro hI'\n  obtain ⟨x, hx⟩ := setOfIdeal_eq_compl_singleton I\n  exact\n    ⟨x, by\n      simpa only [idealOfSet_ofIdeal_eq_closure, I.closure_eq_of_isClosed hI] using\n        congr_arg (idealOfSet 𝕜) hx.symm⟩\n\n"}
{"name":"WeakDual.CharacterSpace.continuousMapEval_apply_apply","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\n𝕜 : Type u_2\ninst✝⁵ : TopologicalSpace X\ninst✝⁴ : CommRing 𝕜\ninst✝³ : TopologicalSpace 𝕜\ninst✝² : TopologicalRing 𝕜\ninst✝¹ : Nontrivial 𝕜\ninst✝ : NoZeroDivisors 𝕜\nx : X\nf : ContinuousMap X 𝕜\n⊢ Eq (((WeakDual.CharacterSpace.continuousMapEval X 𝕜) x) f) (f x)","decl":"@[simp]\ntheorem continuousMapEval_apply_apply (x : X) (f : C(X, 𝕜)) : continuousMapEval X 𝕜 x f = f x :=\n  rfl\n\n"}
{"name":"WeakDual.CharacterSpace.continuousMapEval_bijective","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\n𝕜 : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : CompactSpace X\ninst✝¹ : T2Space X\ninst✝ : RCLike 𝕜\n⊢ Function.Bijective ⇑(WeakDual.CharacterSpace.continuousMapEval X 𝕜)","decl":"theorem continuousMapEval_bijective : Bijective (continuousMapEval X 𝕜) := by\n  refine ⟨fun x y hxy => ?_, fun φ => ?_⟩\n  · contrapose! hxy\n    rcases exists_continuous_zero_one_of_isClosed (isClosed_singleton : _root_.IsClosed {x})\n        (isClosed_singleton : _root_.IsClosed {y}) (Set.disjoint_singleton.mpr hxy) with\n      ⟨f, fx, fy, -⟩\n    rw [DFunLike.ne_iff]\n    use (⟨fun (x : ℝ) => (x : 𝕜), RCLike.continuous_ofReal⟩ : C(ℝ, 𝕜)).comp f\n    simpa only [continuousMapEval_apply_apply, ContinuousMap.comp_apply, coe_mk, Ne,\n      RCLike.ofReal_inj] using\n      ((fx (Set.mem_singleton x)).symm ▸ (fy (Set.mem_singleton y)).symm ▸ zero_ne_one : f x ≠ f y)\n  · obtain ⟨x, hx⟩ := (ideal_isMaximal_iff (RingHom.ker φ)).mp inferInstance\n    refine ⟨x, CharacterSpace.ext_ker <| Ideal.ext fun f => ?_⟩\n    simpa only [RingHom.mem_ker, continuousMapEval_apply_apply, mem_idealOfSet_compl_singleton,\n      RingHom.mem_ker] using SetLike.ext_iff.mp hx f\n\n"}
