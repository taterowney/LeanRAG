{"name":"ContinuousMap.idealOfSet_closed","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nR : Type u_2\ninstâœâ´ : TopologicalSpace X\ninstâœÂ³ : Semiring R\ninstâœÂ² : TopologicalSpace R\ninstâœÂ¹ : TopologicalSemiring R\ninstâœ : T2Space R\ns : Set X\nâŠ¢ IsClosed â†‘(ContinuousMap.idealOfSet R s)","decl":"theorem idealOfSet_closed [T2Space R] (s : Set X) :\n    IsClosed (idealOfSet R s : Set C(X, R)) := by\n  simp only [idealOfSet, Submodule.coe_set_mk, Set.setOf_forall]\n  exact isClosed_iInter fun x => isClosed_iInter fun _ =>\n    isClosed_eq (continuous_eval_const x) continuous_const\n\n"}
{"name":"ContinuousMap.mem_idealOfSet","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nR : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : Semiring R\ninstâœÂ¹ : TopologicalSpace R\ninstâœ : TopologicalSemiring R\ns : Set X\nf : ContinuousMap X R\nâŠ¢ Iff (Membership.mem (ContinuousMap.idealOfSet R s) f) (âˆ€ â¦ƒx : Xâ¦„, Membership.mem (HasCompl.compl s) x â†’ Eq (f x) 0)","decl":"theorem mem_idealOfSet {s : Set X} {f : C(X, R)} :\n    f âˆˆ idealOfSet R s â†” âˆ€ â¦ƒx : Xâ¦„, x âˆˆ sá¶œ â†’ f x = 0 := by\n  convert Iff.rfl\n\n"}
{"name":"ContinuousMap.not_mem_idealOfSet","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nR : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : Semiring R\ninstâœÂ¹ : TopologicalSpace R\ninstâœ : TopologicalSemiring R\ns : Set X\nf : ContinuousMap X R\nâŠ¢ Iff (Not (Membership.mem (ContinuousMap.idealOfSet R s) f)) (Exists fun x => And (Membership.mem (HasCompl.compl s) x) (Ne (f x) 0))","decl":"theorem not_mem_idealOfSet {s : Set X} {f : C(X, R)} : f âˆ‰ idealOfSet R s â†” âˆƒ x âˆˆ sá¶œ, f x â‰  0 := by\n  simp_rw [mem_idealOfSet]; push_neg; rfl\n\n"}
{"name":"ContinuousMap.not_mem_setOfIdeal","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nR : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : Semiring R\ninstâœÂ¹ : TopologicalSpace R\ninstâœ : TopologicalSemiring R\nI : Ideal (ContinuousMap X R)\nx : X\nâŠ¢ Iff (Not (Membership.mem (ContinuousMap.setOfIdeal I) x)) (âˆ€ â¦ƒf : ContinuousMap X Râ¦„, Membership.mem I f â†’ Eq (f x) 0)","decl":"theorem not_mem_setOfIdeal {I : Ideal C(X, R)} {x : X} :\n    x âˆ‰ setOfIdeal I â†” âˆ€ â¦ƒf : C(X, R)â¦„, f âˆˆ I â†’ f x = 0 := by\n  rw [â† Set.mem_compl_iff, setOfIdeal, compl_compl, Set.mem_setOf]\n\n"}
{"name":"ContinuousMap.mem_setOfIdeal","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nR : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : Semiring R\ninstâœÂ¹ : TopologicalSpace R\ninstâœ : TopologicalSemiring R\nI : Ideal (ContinuousMap X R)\nx : X\nâŠ¢ Iff (Membership.mem (ContinuousMap.setOfIdeal I) x) (Exists fun f => And (Membership.mem I f) (Ne (f x) 0))","decl":"theorem mem_setOfIdeal {I : Ideal C(X, R)} {x : X} :\n    x âˆˆ setOfIdeal I â†” âˆƒ f âˆˆ I, (f : C(X, R)) x â‰  0 := by\n  simp_rw [setOfIdeal, Set.mem_compl_iff, Set.mem_setOf]; push_neg; rfl\n\n"}
{"name":"ContinuousMap.setOfIdeal_open","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nR : Type u_2\ninstâœâ´ : TopologicalSpace X\ninstâœÂ³ : Semiring R\ninstâœÂ² : TopologicalSpace R\ninstâœÂ¹ : TopologicalSemiring R\ninstâœ : T2Space R\nI : Ideal (ContinuousMap X R)\nâŠ¢ IsOpen (ContinuousMap.setOfIdeal I)","decl":"theorem setOfIdeal_open [T2Space R] (I : Ideal C(X, R)) : IsOpen (setOfIdeal I) := by\n  simp only [setOfIdeal, Set.setOf_forall, isOpen_compl_iff]\n  exact\n    isClosed_iInter fun f =>\n      isClosed_iInter fun _ => isClosed_eq (map_continuous f) continuous_const\n\n"}
{"name":"ContinuousMap.coe_opensOfIdeal","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nR : Type u_2\ninstâœâ´ : TopologicalSpace X\ninstâœÂ³ : Semiring R\ninstâœÂ² : TopologicalSpace R\ninstâœÂ¹ : TopologicalSemiring R\ninstâœ : T2Space R\nI : Ideal (ContinuousMap X R)\nâŠ¢ Eq (â†‘(ContinuousMap.opensOfIdeal I)) (ContinuousMap.setOfIdeal I)","decl":"/-- The open set `ContinuousMap.setOfIdeal I` realized as a term of `opens X`. -/\n@[simps]\ndef opensOfIdeal [T2Space R] (I : Ideal C(X, R)) : Opens X :=\n  âŸ¨setOfIdeal I, setOfIdeal_open IâŸ©\n\n"}
{"name":"ContinuousMap.setOfTop_eq_univ","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nR : Type u_2\ninstâœâ´ : TopologicalSpace X\ninstâœÂ³ : Semiring R\ninstâœÂ² : TopologicalSpace R\ninstâœÂ¹ : TopologicalSemiring R\ninstâœ : Nontrivial R\nâŠ¢ Eq (ContinuousMap.setOfIdeal Top.top) Set.univ","decl":"@[simp]\ntheorem setOfTop_eq_univ [Nontrivial R] : setOfIdeal (âŠ¤ : Ideal C(X, R)) = Set.univ :=\n  Set.univ_subset_iff.mp fun _ _ => mem_setOfIdeal.mpr âŸ¨1, Submodule.mem_top, one_ne_zeroâŸ©\n\n"}
{"name":"ContinuousMap.idealOfEmpty_eq_bot","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nR : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : Semiring R\ninstâœÂ¹ : TopologicalSpace R\ninstâœ : TopologicalSemiring R\nâŠ¢ Eq (ContinuousMap.idealOfSet R EmptyCollection.emptyCollection) Bot.bot","decl":"@[simp]\ntheorem idealOfEmpty_eq_bot : idealOfSet R (âˆ… : Set X) = âŠ¥ :=\n  Ideal.ext fun f => by\n    simp only [mem_idealOfSet, Set.compl_empty, Set.mem_univ, forall_true_left, Ideal.mem_bot,\n      DFunLike.ext_iff, zero_apply]\n\n"}
{"name":"ContinuousMap.mem_idealOfSet_compl_singleton","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nR : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : Semiring R\ninstâœÂ¹ : TopologicalSpace R\ninstâœ : TopologicalSemiring R\nx : X\nf : ContinuousMap X R\nâŠ¢ Iff (Membership.mem (ContinuousMap.idealOfSet R (HasCompl.compl (Singleton.singleton x))) f) (Eq (f x) 0)","decl":"@[simp]\ntheorem mem_idealOfSet_compl_singleton (x : X) (f : C(X, R)) :\n    f âˆˆ idealOfSet R ({x}á¶œ : Set X) â†” f x = 0 := by\n  simp only [mem_idealOfSet, compl_compl, Set.mem_singleton_iff, forall_eq]\n\n"}
{"name":"ContinuousMap.ideal_gc","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nR : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : Semiring R\ninstâœÂ¹ : TopologicalSpace R\ninstâœ : TopologicalSemiring R\nâŠ¢ GaloisConnection ContinuousMap.setOfIdeal (ContinuousMap.idealOfSet R)","decl":"theorem ideal_gc : GaloisConnection (setOfIdeal : Ideal C(X, R) â†’ Set X) (idealOfSet R) := by\n  refine fun I s => âŸ¨fun h f hf => ?_, fun h x hx => ?_âŸ©\n  Â· by_contra h'\n    rcases not_mem_idealOfSet.mp h' with âŸ¨x, hx, hfxâŸ©\n    exact hfx (not_mem_setOfIdeal.mp (mt (@h x) hx) hf)\n  Â· obtain âŸ¨f, hf, hfxâŸ© := mem_setOfIdeal.mp hx\n    by_contra hx'\n    exact not_mem_idealOfSet.mpr âŸ¨x, hx', hfxâŸ© (h hf)\n\n"}
{"name":"ContinuousMap.exists_mul_le_one_eqOn_ge","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nf : ContinuousMap X NNReal\nc : NNReal\nhc : LT.lt 0 c\nâŠ¢ Exists fun g => And (âˆ€ (x : X), LE.le ((HMul.hMul g f) x) 1) (Set.EqOn (â‡‘(HMul.hMul g f)) 1 (setOf fun x => LE.le c (f x)))","decl":"/-- An auxiliary lemma used in the proof of `ContinuousMap.idealOfSet_ofIdeal_eq_closure` which may\nbe useful on its own. -/\ntheorem exists_mul_le_one_eqOn_ge (f : C(X, â„â‰¥0)) {c : â„â‰¥0} (hc : 0 < c) :\n    âˆƒ g : C(X, â„â‰¥0), (âˆ€ x : X, (g * f) x â‰¤ 1) âˆ§ {x : X | c â‰¤ f x}.EqOn (g * f) 1 :=\n  âŸ¨{  toFun := (f âŠ” const X c)â»Â¹\n      continuous_toFun :=\n        ((map_continuous f).sup <| map_continuous _).invâ‚€ fun _ => (hc.trans_le le_sup_right).ne' },\n    fun x =>\n    (inv_mul_le_iffâ‚€ (hc.trans_le le_sup_right)).mpr ((mul_one (f x âŠ” c)).symm â–¸ le_sup_left),\n    fun x hx => by\n    simpa only [coe_const, mul_apply, coe_mk, Pi.inv_apply, Pi.sup_apply,\n      Function.const_apply, sup_eq_left.mpr (Set.mem_setOf.mp hx), ne_eq, Pi.one_apply]\n      using inv_mul_cancelâ‚€ (hc.trans_le hx).ne' âŸ©\n\n"}
{"name":"ContinuousMap.idealOfSet_ofIdeal_eq_closure","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nğ•œ : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : CompactSpace X\ninstâœ : T2Space X\nI : Ideal (ContinuousMap X ğ•œ)\nâŠ¢ Eq (ContinuousMap.idealOfSet ğ•œ (ContinuousMap.setOfIdeal I)) I.closure","decl":"@[simp]\ntheorem idealOfSet_ofIdeal_eq_closure (I : Ideal C(X, ğ•œ)) :\n    idealOfSet ğ•œ (setOfIdeal I) = I.closure := by\n  /- Since `idealOfSet ğ•œ (setOfIdeal I)` is closed and contains `I`, it contains `I.closure`.\n    For the reverse inclusion, given `f âˆˆ idealOfSet ğ•œ (setOfIdeal I)` and `(Îµ : â„â‰¥0) > 0` it\n    suffices to show that `f` is within `Îµ` of `I`. -/\n  refine le_antisymm ?_\n      ((idealOfSet_closed ğ•œ <| setOfIdeal I).closure_subset_iff.mpr fun f hf x hx =>\n        not_mem_setOfIdeal.mp hx hf)\n  refine (fun f hf => Metric.mem_closure_iff.mpr fun Îµ hÎµ => ?_)\n  lift Îµ to â„â‰¥0 using hÎµ.lt.le\n  replace hÎµ := show (0 : â„â‰¥0) < Îµ from hÎµ\n  simp_rw [dist_nndist]\n  norm_cast\n  -- Let `t := {x : X | Îµ / 2 â‰¤ â€–f xâ€–â‚Š}}` which is closed and disjoint from `set_of_ideal I`.\n  set t := {x : X | Îµ / 2 â‰¤ â€–f xâ€–â‚Š}\n  have ht : IsClosed t := isClosed_le continuous_const (map_continuous f).nnnorm\n  have htI : Disjoint t (setOfIdeal I)á¶œ := by\n    refine Set.subset_compl_iff_disjoint_left.mp fun x hx => ?_\n    simpa only [t, Set.mem_setOf, Set.mem_compl_iff, not_le] using\n      (nnnorm_eq_zero.mpr (mem_idealOfSet.mp hf hx)).trans_lt (half_pos hÎµ)\n  /- It suffices to produce `g : C(X, â„â‰¥0)` which takes values in `[0,1]` and is constantly `1` on\n    `t` such that when composed with the natural embedding of `â„â‰¥0` into `ğ•œ` lies in the ideal `I`.\n    Indeed, then `â€–f - f * â†‘gâ€– â‰¤ â€–f * (1 - â†‘g)â€– â‰¤ â¨† â€–f * (1 - â†‘g) xâ€–`. When `x âˆ‰ t`, `â€–f xâ€– < Îµ / 2`\n    and `â€–(1 - â†‘g) xâ€– â‰¤ 1`, and when `x âˆˆ t`, `(1 - â†‘g) x = 0`, and clearly `f * â†‘g âˆˆ I`. -/\n  suffices\n    âˆƒ g : C(X, â„â‰¥0), (algebraMapCLM â„â‰¥0 ğ•œ : C(â„â‰¥0, ğ•œ)).comp g âˆˆ I âˆ§ (âˆ€ x, g x â‰¤ 1) âˆ§ t.EqOn g 1 by\n    obtain âŸ¨g, hgI, hg, hgtâŸ© := this\n    refine âŸ¨f * (algebraMapCLM â„â‰¥0 ğ•œ : C(â„â‰¥0, ğ•œ)).comp g, I.mul_mem_left f hgI, ?_âŸ©\n    rw [nndist_eq_nnnorm]\n    refine (nnnorm_lt_iff _ hÎµ).2 fun x => ?_\n    simp only [coe_sub, coe_mul, Pi.sub_apply, Pi.mul_apply]\n    by_cases hx : x âˆˆ t\n    Â· simpa only [hgt hx, comp_apply, Pi.one_apply, ContinuousMap.coe_coe, algebraMapCLM_apply,\n        map_one, mul_one, sub_self, nnnorm_zero] using hÎµ\n    Â· refine lt_of_le_of_lt ?_ (half_lt_self hÎµ)\n      have :=\n        calc\n          â€–((1 - (algebraMapCLM â„â‰¥0 ğ•œ : C(â„â‰¥0, ğ•œ)).comp g) x : ğ•œ)â€–â‚Š =\n              â€–1 - algebraMap â„â‰¥0 ğ•œ (g x)â€–â‚Š := by\n            simp only [coe_sub, coe_one, coe_comp, ContinuousMap.coe_coe, Pi.sub_apply,\n              Pi.one_apply, Function.comp_apply, algebraMapCLM_apply]\n          _ = â€–algebraMap â„â‰¥0 ğ•œ (1 - g x)â€–â‚Š := by\n            simp only [Algebra.algebraMap_eq_smul_one, NNReal.smul_def, NNReal.coe_sub (hg x),\n              NNReal.coe_one, sub_smul, one_smul]\n          _ â‰¤ 1 := (nnnorm_algebraMap_nnreal ğ•œ (1 - g x)).trans_le tsub_le_self\n      calc\n        â€–f x - f x * (algebraMapCLM â„â‰¥0 ğ•œ : C(â„â‰¥0, ğ•œ)).comp g xâ€–â‚Š =\n            â€–f x * (1 - (algebraMapCLM â„â‰¥0 ğ•œ : C(â„â‰¥0, ğ•œ)).comp g) xâ€–â‚Š := by\n          simp only [mul_sub, coe_sub, coe_one, Pi.sub_apply, Pi.one_apply, mul_one]\n        _ â‰¤ Îµ / 2 * â€–(1 - (algebraMapCLM â„â‰¥0 ğ•œ : C(â„â‰¥0, ğ•œ)).comp g) xâ€–â‚Š :=\n          ((nnnorm_mul_le _ _).trans\n            (mul_le_mul_right' (not_le.mp <| show Â¬Îµ / 2 â‰¤ â€–f xâ€–â‚Š from hx).le _))\n        _ â‰¤ Îµ / 2 := by simpa only [mul_one] using mul_le_mul_left' this _\n  /- There is some `g' : C(X, â„â‰¥0)` which is strictly positive on `t` such that the composition\n    `â†‘g` with the natural embedding of `â„â‰¥0` into `ğ•œ` lies in `I`. This follows from compactness of\n    `t` and that we can do it in any neighborhood of a point `x âˆˆ t`. Indeed, since `x âˆˆ t`, then\n    `fâ‚“ x â‰  0` for some `fâ‚“ âˆˆ I` and so `fun y â†¦ â€–(star fâ‚“ * fâ‚“) yâ€–â‚Š` is strictly posiive in a\n    neighborhood of `y`. Moreover, `(â€–(star fâ‚“ * fâ‚“) yâ€–â‚Š : ğ•œ) = (star fâ‚“ * fâ‚“) y`, so composition of\n    this map with the natural embedding is just `star fâ‚“ * fâ‚“ âˆˆ I`. -/\n  have : âˆƒ g' : C(X, â„â‰¥0), (algebraMapCLM â„â‰¥0 ğ•œ : C(â„â‰¥0, ğ•œ)).comp g' âˆˆ I âˆ§ âˆ€ x âˆˆ t, 0 < g' x := by\n    refine ht.isCompact.induction_on ?_ ?_ ?_ ?_\n    Â· refine âŸ¨0, ?_, fun x hx => False.elim hxâŸ©\n      convert I.zero_mem\n      ext\n      simp only [comp_apply, zero_apply, ContinuousMap.coe_coe, map_zero]\n    Â· rintro sâ‚ sâ‚‚ hs âŸ¨g, hI, hgtâŸ©; exact âŸ¨g, hI, fun x hx => hgt x (hs hx)âŸ©\n    Â· rintro sâ‚ sâ‚‚ âŸ¨gâ‚, hIâ‚, hgtâ‚âŸ© âŸ¨gâ‚‚, hIâ‚‚, hgtâ‚‚âŸ©\n      refine âŸ¨gâ‚ + gâ‚‚, ?_, fun x hx => ?_âŸ©\n      Â· convert I.add_mem hIâ‚ hIâ‚‚\n        ext y\n        simp only [coe_add, Pi.add_apply, map_add, coe_comp, Function.comp_apply,\n          ContinuousMap.coe_coe]\n      Â· rcases hx with (hx | hx)\n        Â· simpa only [zero_add] using add_lt_add_of_lt_of_le (hgtâ‚ x hx) zero_le'\n        Â· simpa only [zero_add] using add_lt_add_of_le_of_lt zero_le' (hgtâ‚‚ x hx)\n    Â· intro x hx\n      replace hx := htI.subset_compl_right hx\n      rw [compl_compl, mem_setOfIdeal] at hx\n      obtain âŸ¨g, hI, hgxâŸ© := hx\n      have := (map_continuous g).continuousAt.eventually_ne hgx\n      refine\n        âŸ¨{y : X | g y â‰  0} âˆ© t,\n          mem_nhdsWithin_iff_exists_mem_nhds_inter.mpr âŸ¨_, this, Set.Subset.rflâŸ©,\n          âŸ¨âŸ¨fun x => â€–g xâ€–â‚Š ^ 2, (map_continuous g).nnnorm.pow 2âŸ©, ?_, fun x hx =>\n            pow_pos (norm_pos_iff.mpr hx.1) 2âŸ©âŸ©\n      convert I.mul_mem_left (star g) hI\n      ext\n      simp only [comp_apply, ContinuousMap.coe_coe, coe_mk, algebraMapCLM_apply, map_pow,\n        mul_apply, star_apply, star_def]\n      simp only [normSq_eq_def', RCLike.conj_mul, ofReal_pow]\n      rfl\n  /- Get the function `g'` which is guaranteed to exist above. By the extreme value theorem and\n    compactness of `t`, there is some `0 < c` such that `c â‰¤ g' x` for all `x âˆˆ t`. Then by\n    `exists_mul_le_one_eqOn_ge` there is some `g` for which `g * g'` is the desired function. -/\n  obtain âŸ¨g', hI', hgt'âŸ© := this\n  obtain âŸ¨c, hc, hgc'âŸ© : âˆƒ c > 0, âˆ€ y : X, y âˆˆ t â†’ c â‰¤ g' y :=\n    t.eq_empty_or_nonempty.elim\n      (fun ht' => âŸ¨1, zero_lt_one, fun y hy => False.elim (by rwa [ht'] at hy)âŸ©) fun ht' =>\n      let âŸ¨x, hx, hx'âŸ© := ht.isCompact.exists_isMinOn ht' (map_continuous g').continuousOn\n      âŸ¨g' x, hgt' x hx, hx'âŸ©\n  obtain âŸ¨g, hg, hgcâŸ© := exists_mul_le_one_eqOn_ge g' hc\n  refine âŸ¨g * g', ?_, hg, hgc.mono hgc'âŸ©\n  convert I.mul_mem_left ((algebraMapCLM â„â‰¥0 ğ•œ : C(â„â‰¥0, ğ•œ)).comp g) hI'\n  ext\n  simp only [algebraMapCLM_coe, comp_apply, mul_apply, ContinuousMap.coe_coe, map_mul]\n\n"}
{"name":"ContinuousMap.idealOfSet_ofIdeal_isClosed","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nğ•œ : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : CompactSpace X\ninstâœ : T2Space X\nI : Ideal (ContinuousMap X ğ•œ)\nhI : IsClosed â†‘I\nâŠ¢ Eq (ContinuousMap.idealOfSet ğ•œ (ContinuousMap.setOfIdeal I)) I","decl":"theorem idealOfSet_ofIdeal_isClosed {I : Ideal C(X, ğ•œ)} (hI : IsClosed (I : Set C(X, ğ•œ))) :\n    idealOfSet ğ•œ (setOfIdeal I) = I :=\n  (idealOfSet_ofIdeal_eq_closure I).trans (Ideal.ext <| Set.ext_iff.mp hI.closure_eq)\n\n"}
{"name":"ContinuousMap.setOfIdeal_ofSet_eq_interior","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nğ•œ : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : CompactSpace X\ninstâœ : T2Space X\ns : Set X\nâŠ¢ Eq (ContinuousMap.setOfIdeal (ContinuousMap.idealOfSet ğ•œ s)) (interior s)","decl":"@[simp]\ntheorem setOfIdeal_ofSet_eq_interior (s : Set X) : setOfIdeal (idealOfSet ğ•œ s) = interior s := by\n  refine\n    Set.Subset.antisymm\n      ((setOfIdeal_open (idealOfSet ğ•œ s)).subset_interior_iff.mpr fun x hx =>\n        let âŸ¨f, hf, hfxâŸ© := mem_setOfIdeal.mp hx\n        Set.not_mem_compl_iff.mp (mt (@hf x) hfx))\n      fun x hx => ?_\n  -- If `x âˆ‰ closure sá¶œ`, we must produce `f : C(X, ğ•œ)` which is zero on `sá¶œ` and `f x â‰  0`.\n  rw [â† compl_compl (interior s), â† closure_compl] at hx\n  simp_rw [mem_setOfIdeal, mem_idealOfSet]\n  /- Apply Urysohn's lemma to get `g : C(X, â„)` which is zero on `sá¶œ` and `g x â‰  0`, then compose\n    with the natural embedding `â„ â†ª ğ•œ` to produce the desired `f`. -/\n  obtain âŸ¨g, hgs, hgx : Set.EqOn g 1 {x}, -âŸ© :=\n    exists_continuous_zero_one_of_isClosed isClosed_closure isClosed_singleton\n      (Set.disjoint_singleton_right.mpr hx)\n  exact\n    âŸ¨âŸ¨fun x => g x, continuous_ofReal.comp (map_continuous g)âŸ©, by\n      simpa only [coe_mk, ofReal_eq_zero] using fun x hx => hgs (subset_closure hx), by\n      simpa only [coe_mk, hgx (Set.mem_singleton x), Pi.one_apply, RCLike.ofReal_one] using\n        one_ne_zeroâŸ©\n\n"}
{"name":"ContinuousMap.setOfIdeal_ofSet_of_isOpen","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nğ•œ : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : CompactSpace X\ninstâœ : T2Space X\ns : Set X\nhs : IsOpen s\nâŠ¢ Eq (ContinuousMap.setOfIdeal (ContinuousMap.idealOfSet ğ•œ s)) s","decl":"theorem setOfIdeal_ofSet_of_isOpen {s : Set X} (hs : IsOpen s) : setOfIdeal (idealOfSet ğ•œ s) = s :=\n  (setOfIdeal_ofSet_eq_interior ğ•œ s).trans hs.interior_eq\n\n"}
{"name":"ContinuousMap.idealOpensGI_choice","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nğ•œ : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : CompactSpace X\ninstâœ : T2Space X\nI : Ideal (ContinuousMap X ğ•œ)\nxâœ : LE.le (ContinuousMap.idealOfSet ğ•œ â†‘(ContinuousMap.opensOfIdeal I)) I\nâŠ¢ Eq ((ContinuousMap.idealOpensGI X ğ•œ).choice I xâœ) (ContinuousMap.opensOfIdeal I.closure)","decl":"/-- The Galois insertion `ContinuousMap.opensOfIdeal : Ideal C(X, ğ•œ) â†’ Opens X` and\n`fun s â†¦ ContinuousMap.idealOfSet â†‘s`. -/\n@[simps]\ndef idealOpensGI :\n    GaloisInsertion (opensOfIdeal : Ideal C(X, ğ•œ) â†’ Opens X) fun s => idealOfSet ğ•œ s where\n  choice I _ := opensOfIdeal I.closure\n  gc I s := ideal_gc X ğ•œ I s\n  le_l_u s := (setOfIdeal_ofSet_of_isOpen ğ•œ s.isOpen).ge\n  choice_eq I hI :=\n    congr_arg _ <|\n      Ideal.ext\n        (Set.ext_iff.mp\n          (isClosed_of_closure_subset <|\n              (idealOfSet_ofIdeal_eq_closure I â–¸ hI : I.closure â‰¤ I)).closure_eq)\n\n"}
{"name":"ContinuousMap.idealOfSet_isMaximal_iff","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nğ•œ : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : CompactSpace X\ninstâœ : T2Space X\ns : TopologicalSpace.Opens X\nâŠ¢ Iff (ContinuousMap.idealOfSet ğ•œ â†‘s).IsMaximal (IsCoatom s)","decl":"theorem idealOfSet_isMaximal_iff (s : Opens X) :\n    (idealOfSet ğ•œ (s : Set X)).IsMaximal â†” IsCoatom s := by\n  rw [Ideal.isMaximal_def]\n  refine (idealOpensGI X ğ•œ).isCoatom_iff (fun I hI => ?_) s\n  rw [â† Ideal.isMaximal_def] at hI\n  exact idealOfSet_ofIdeal_isClosed inferInstance\n\n"}
{"name":"ContinuousMap.idealOf_compl_singleton_isMaximal","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nğ•œ : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : CompactSpace X\ninstâœ : T2Space X\nx : X\nâŠ¢ (ContinuousMap.idealOfSet ğ•œ (HasCompl.compl (Singleton.singleton x))).IsMaximal","decl":"theorem idealOf_compl_singleton_isMaximal (x : X) : (idealOfSet ğ•œ ({x}á¶œ : Set X)).IsMaximal :=\n  (idealOfSet_isMaximal_iff ğ•œ (Closeds.singleton x).compl).mpr <| Opens.isCoatom_iff.mpr âŸ¨x, rflâŸ©\n\n"}
{"name":"ContinuousMap.setOfIdeal_eq_compl_singleton","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nğ•œ : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : CompactSpace X\ninstâœ : T2Space X\nI : Ideal (ContinuousMap X ğ•œ)\nhI : I.IsMaximal\nâŠ¢ Exists fun x => Eq (ContinuousMap.setOfIdeal I) (HasCompl.compl (Singleton.singleton x))","decl":"theorem setOfIdeal_eq_compl_singleton (I : Ideal C(X, ğ•œ)) [hI : I.IsMaximal] :\n    âˆƒ x : X, setOfIdeal I = {x}á¶œ := by\n  have h : (idealOfSet ğ•œ (setOfIdeal I)).IsMaximal :=\n    (idealOfSet_ofIdeal_isClosed (inferInstance : IsClosed (I : Set C(X, ğ•œ)))).symm â–¸ hI\n  obtain âŸ¨x, hxâŸ© := Opens.isCoatom_iff.1 ((idealOfSet_isMaximal_iff ğ•œ (opensOfIdeal I)).1 h)\n  exact âŸ¨x, congr_arg (fun (s : Opens X) => (s : Set X)) hxâŸ©\n\n"}
{"name":"ContinuousMap.ideal_isMaximal_iff","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nğ•œ : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : CompactSpace X\ninstâœ : T2Space X\nI : Ideal (ContinuousMap X ğ•œ)\nhI : IsClosed â†‘I\nâŠ¢ Iff I.IsMaximal (Exists fun x => Eq (ContinuousMap.idealOfSet ğ•œ (HasCompl.compl (Singleton.singleton x))) I)","decl":"theorem ideal_isMaximal_iff (I : Ideal C(X, ğ•œ)) [hI : IsClosed (I : Set C(X, ğ•œ))] :\n    I.IsMaximal â†” âˆƒ x : X, idealOfSet ğ•œ {x}á¶œ = I := by\n  refine\n    âŸ¨?_, fun h =>\n      let âŸ¨x, hxâŸ© := h\n      hx â–¸ idealOf_compl_singleton_isMaximal ğ•œ xâŸ©\n  intro hI'\n  obtain âŸ¨x, hxâŸ© := setOfIdeal_eq_compl_singleton I\n  exact\n    âŸ¨x, by\n      simpa only [idealOfSet_ofIdeal_eq_closure, I.closure_eq_of_isClosed hI] using\n        congr_arg (idealOfSet ğ•œ) hx.symmâŸ©\n\n"}
{"name":"WeakDual.CharacterSpace.continuousMapEval_apply_apply","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nğ•œ : Type u_2\ninstâœâµ : TopologicalSpace X\ninstâœâ´ : CommRing ğ•œ\ninstâœÂ³ : TopologicalSpace ğ•œ\ninstâœÂ² : TopologicalRing ğ•œ\ninstâœÂ¹ : Nontrivial ğ•œ\ninstâœ : NoZeroDivisors ğ•œ\nx : X\nf : ContinuousMap X ğ•œ\nâŠ¢ Eq (((WeakDual.CharacterSpace.continuousMapEval X ğ•œ) x) f) (f x)","decl":"@[simp]\ntheorem continuousMapEval_apply_apply (x : X) (f : C(X, ğ•œ)) : continuousMapEval X ğ•œ x f = f x :=\n  rfl\n\n"}
{"name":"WeakDual.CharacterSpace.continuousMapEval_bijective","module":"Mathlib.Topology.ContinuousMap.Ideals","initialProofState":"X : Type u_1\nğ•œ : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : CompactSpace X\ninstâœÂ¹ : T2Space X\ninstâœ : RCLike ğ•œ\nâŠ¢ Function.Bijective â‡‘(WeakDual.CharacterSpace.continuousMapEval X ğ•œ)","decl":"theorem continuousMapEval_bijective : Bijective (continuousMapEval X ğ•œ) := by\n  refine âŸ¨fun x y hxy => ?_, fun Ï† => ?_âŸ©\n  Â· contrapose! hxy\n    rcases exists_continuous_zero_one_of_isClosed (isClosed_singleton : _root_.IsClosed {x})\n        (isClosed_singleton : _root_.IsClosed {y}) (Set.disjoint_singleton.mpr hxy) with\n      âŸ¨f, fx, fy, -âŸ©\n    rw [DFunLike.ne_iff]\n    use (âŸ¨fun (x : â„) => (x : ğ•œ), RCLike.continuous_ofRealâŸ© : C(â„, ğ•œ)).comp f\n    simpa only [continuousMapEval_apply_apply, ContinuousMap.comp_apply, coe_mk, Ne,\n      RCLike.ofReal_inj] using\n      ((fx (Set.mem_singleton x)).symm â–¸ (fy (Set.mem_singleton y)).symm â–¸ zero_ne_one : f x â‰  f y)\n  Â· obtain âŸ¨x, hxâŸ© := (ideal_isMaximal_iff (RingHom.ker Ï†)).mp inferInstance\n    refine âŸ¨x, CharacterSpace.ext_ker <| Ideal.ext fun f => ?_âŸ©\n    simpa only [RingHom.mem_ker, continuousMapEval_apply_apply, mem_idealOfSet_compl_singleton,\n      RingHom.mem_ker] using SetLike.ext_iff.mp hx f\n\n"}
