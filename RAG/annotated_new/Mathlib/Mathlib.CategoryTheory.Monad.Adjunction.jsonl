{"name":"CategoryTheory.Adjunction.toMonad_Œ∑","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\n‚ä¢ Eq h.toMonad.Œ∑ h.unit","decl":"/-- For a pair of functors `L : C ‚•§ D`, `R : D ‚•§ C`, an adjunction `h : L ‚ä£ R` induces a monad on\nthe category `C`.\n-/\n-- Porting note: Specifying simps projections manually to match mathlib3 behavior.\n@[simps! coe Œ∑ Œº]\ndef toMonad (h : L ‚ä£ R) : Monad C where\n  toFunctor := L ‚ãô R\n  Œ∑ := h.unit\n  Œº := whiskerRight (whiskerLeft L h.counit) R\n  assoc X := by\n    dsimp\n    rw [‚Üê R.map_comp]\n    simp\n  right_unit X := by\n    dsimp\n    rw [‚Üê R.map_comp]\n    simp\n\n"}
{"name":"CategoryTheory.Adjunction.toMonad_Œº","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\n‚ä¢ Eq h.toMonad.Œº (CategoryTheory.whiskerRight (CategoryTheory.whiskerLeft L h.counit) R)","decl":"/-- For a pair of functors `L : C ‚•§ D`, `R : D ‚•§ C`, an adjunction `h : L ‚ä£ R` induces a monad on\nthe category `C`.\n-/\n-- Porting note: Specifying simps projections manually to match mathlib3 behavior.\n@[simps! coe Œ∑ Œº]\ndef toMonad (h : L ‚ä£ R) : Monad C where\n  toFunctor := L ‚ãô R\n  Œ∑ := h.unit\n  Œº := whiskerRight (whiskerLeft L h.counit) R\n  assoc X := by\n    dsimp\n    rw [‚Üê R.map_comp]\n    simp\n  right_unit X := by\n    dsimp\n    rw [‚Üê R.map_comp]\n    simp\n\n"}
{"name":"CategoryTheory.Adjunction.toMonad_coe","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\n‚ä¢ Eq h.toMonad.toFunctor (L.comp R)","decl":"/-- For a pair of functors `L : C ‚•§ D`, `R : D ‚•§ C`, an adjunction `h : L ‚ä£ R` induces a monad on\nthe category `C`.\n-/\n-- Porting note: Specifying simps projections manually to match mathlib3 behavior.\n@[simps! coe Œ∑ Œº]\ndef toMonad (h : L ‚ä£ R) : Monad C where\n  toFunctor := L ‚ãô R\n  Œ∑ := h.unit\n  Œº := whiskerRight (whiskerLeft L h.counit) R\n  assoc X := by\n    dsimp\n    rw [‚Üê R.map_comp]\n    simp\n  right_unit X := by\n    dsimp\n    rw [‚Üê R.map_comp]\n    simp\n\n"}
{"name":"CategoryTheory.Adjunction.toComonad_coe","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\n‚ä¢ Eq h.toComonad.toFunctor (R.comp L)","decl":"/-- For a pair of functors `L : C ‚•§ D`, `R : D ‚•§ C`, an adjunction `h : L ‚ä£ R` induces a comonad on\nthe category `D`.\n-/\n-- Porting note: Specifying simps projections manually to match mathlib3 behavior.\n@[simps coe Œµ Œ¥]\ndef toComonad (h : L ‚ä£ R) : Comonad D where\n  toFunctor := R ‚ãô L\n  Œµ := h.counit\n  Œ¥ := whiskerRight (whiskerLeft R h.unit) L\n  coassoc X := by\n    dsimp\n    rw [‚Üê L.map_comp]\n    simp\n  right_counit X := by\n    dsimp\n    rw [‚Üê L.map_comp]\n    simp\n\n"}
{"name":"CategoryTheory.Adjunction.toComonad_Œµ","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\n‚ä¢ Eq h.toComonad.Œµ h.counit","decl":"/-- For a pair of functors `L : C ‚•§ D`, `R : D ‚•§ C`, an adjunction `h : L ‚ä£ R` induces a comonad on\nthe category `D`.\n-/\n-- Porting note: Specifying simps projections manually to match mathlib3 behavior.\n@[simps coe Œµ Œ¥]\ndef toComonad (h : L ‚ä£ R) : Comonad D where\n  toFunctor := R ‚ãô L\n  Œµ := h.counit\n  Œ¥ := whiskerRight (whiskerLeft R h.unit) L\n  coassoc X := by\n    dsimp\n    rw [‚Üê L.map_comp]\n    simp\n  right_counit X := by\n    dsimp\n    rw [‚Üê L.map_comp]\n    simp\n\n"}
{"name":"CategoryTheory.Adjunction.toComonad_Œ¥","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\n‚ä¢ Eq h.toComonad.Œ¥ (CategoryTheory.whiskerRight (CategoryTheory.whiskerLeft R h.unit) L)","decl":"/-- For a pair of functors `L : C ‚•§ D`, `R : D ‚•§ C`, an adjunction `h : L ‚ä£ R` induces a comonad on\nthe category `D`.\n-/\n-- Porting note: Specifying simps projections manually to match mathlib3 behavior.\n@[simps coe Œµ Œ¥]\ndef toComonad (h : L ‚ä£ R) : Comonad D where\n  toFunctor := R ‚ãô L\n  Œµ := h.counit\n  Œ¥ := whiskerRight (whiskerLeft R h.unit) L\n  coassoc X := by\n    dsimp\n    rw [‚Üê L.map_comp]\n    simp\n  right_counit X := by\n    dsimp\n    rw [‚Üê L.map_comp]\n    simp\n\n"}
{"name":"CategoryTheory.Adjunction.adjToMonadIso_inv_toNatTrans_app","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nX : C\n‚ä¢ Eq ((CategoryTheory.Adjunction.adjToMonadIso T).inv.app X) (CategoryTheory.CategoryStruct.id (T.obj X))","decl":"/-- The monad induced by the Eilenberg-Moore adjunction is the original monad. -/\n@[simps!]\ndef adjToMonadIso (T : Monad C) : T.adj.toMonad ‚âÖ T :=\n  MonadIso.mk (NatIso.ofComponents fun _ => Iso.refl _)\n\n"}
{"name":"CategoryTheory.Adjunction.adjToMonadIso_hom_toNatTrans_app","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nX : C\n‚ä¢ Eq ((CategoryTheory.Adjunction.adjToMonadIso T).hom.app X) (CategoryTheory.CategoryStruct.id (T.obj X))","decl":"/-- The monad induced by the Eilenberg-Moore adjunction is the original monad. -/\n@[simps!]\ndef adjToMonadIso (T : Monad C) : T.adj.toMonad ‚âÖ T :=\n  MonadIso.mk (NatIso.ofComponents fun _ => Iso.refl _)\n\n"}
{"name":"CategoryTheory.Adjunction.adjToComonadIso_inv_toNatTrans_app","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\nX : C\n‚ä¢ Eq ((CategoryTheory.Adjunction.adjToComonadIso G).inv.app X) (CategoryTheory.CategoryStruct.id (G.obj X))","decl":"/-- The comonad induced by the Eilenberg-Moore adjunction is the original comonad. -/\n@[simps!]\ndef adjToComonadIso (G : Comonad C) : G.adj.toComonad ‚âÖ G :=\n  ComonadIso.mk (NatIso.ofComponents fun _ => Iso.refl _)\n\n"}
{"name":"CategoryTheory.Adjunction.adjToComonadIso_hom_toNatTrans_app","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\nX : C\n‚ä¢ Eq ((CategoryTheory.Adjunction.adjToComonadIso G).hom.app X) (CategoryTheory.CategoryStruct.id (G.obj X))","decl":"/-- The comonad induced by the Eilenberg-Moore adjunction is the original comonad. -/\n@[simps!]\ndef adjToComonadIso (G : Comonad C) : G.adj.toComonad ‚âÖ G :=\n  ComonadIso.mk (NatIso.ofComponents fun _ => Iso.refl _)\n\n"}
{"name":"CategoryTheory.Adjunction.isIso_unit_of_iso","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction L R\ni : CategoryTheory.Iso (L.comp R) (CategoryTheory.Functor.id C)\n‚ä¢ CategoryTheory.IsIso adj.unit","decl":"lemma isIso_unit_of_iso (adj : L ‚ä£ R) (i : L ‚ãô R ‚âÖ ùü≠ C) : IsIso adj.unit :=\n  (inferInstanceAs (IsIso (unitAsIsoOfIso adj i).hom))\n\n"}
{"name":"CategoryTheory.Adjunction.isIso_counit_of_iso","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction L R\nj : CategoryTheory.Iso (R.comp L) (CategoryTheory.Functor.id D)\n‚ä¢ CategoryTheory.IsIso adj.counit","decl":"lemma isIso_counit_of_iso (adj : L ‚ä£ R) (j : R ‚ãô L ‚âÖ ùü≠ D) : IsIso adj.counit :=\n  inferInstanceAs (IsIso (counitAsIsoOfIso adj j).hom)\n\n"}
{"name":"CategoryTheory.Monad.comparison_obj_a","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\nX : D\n‚ä¢ Eq ((CategoryTheory.Monad.comparison h).obj X).a (R.map (h.counit.app X))","decl":"/-- Given any adjunction `L ‚ä£ R`, there is a comparison functor `CategoryTheory.Monad.comparison R`\nsending objects `Y : D` to Eilenberg-Moore algebras for `L ‚ãô R` with underlying object `R.obj X`.\n\nWe later show that this is full when `R` is full, faithful when `R` is faithful,\nand essentially surjective when `R` is reflective.\n-/\n@[simps]\ndef Monad.comparison (h : L ‚ä£ R) : D ‚•§ h.toMonad.Algebra where\n  obj X :=\n    { A := R.obj X\n      a := R.map (h.counit.app X)\n      assoc := by\n        dsimp\n        rw [‚Üê R.map_comp, ‚Üê Adjunction.counit_naturality, R.map_comp] }\n  map f :=\n    { f := R.map f\n      h := by\n        dsimp\n        rw [‚Üê R.map_comp, Adjunction.counit_naturality, R.map_comp] }\n\n"}
{"name":"CategoryTheory.Monad.comparison_map_f","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\nX‚úù Y‚úù : D\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Monad.comparison h).map f).f (R.map f)","decl":"/-- Given any adjunction `L ‚ä£ R`, there is a comparison functor `CategoryTheory.Monad.comparison R`\nsending objects `Y : D` to Eilenberg-Moore algebras for `L ‚ãô R` with underlying object `R.obj X`.\n\nWe later show that this is full when `R` is full, faithful when `R` is faithful,\nand essentially surjective when `R` is reflective.\n-/\n@[simps]\ndef Monad.comparison (h : L ‚ä£ R) : D ‚•§ h.toMonad.Algebra where\n  obj X :=\n    { A := R.obj X\n      a := R.map (h.counit.app X)\n      assoc := by\n        dsimp\n        rw [‚Üê R.map_comp, ‚Üê Adjunction.counit_naturality, R.map_comp] }\n  map f :=\n    { f := R.map f\n      h := by\n        dsimp\n        rw [‚Üê R.map_comp, Adjunction.counit_naturality, R.map_comp] }\n\n"}
{"name":"CategoryTheory.Monad.comparison_obj_A","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\nX : D\n‚ä¢ Eq ((CategoryTheory.Monad.comparison h).obj X).A (R.obj X)","decl":"/-- Given any adjunction `L ‚ä£ R`, there is a comparison functor `CategoryTheory.Monad.comparison R`\nsending objects `Y : D` to Eilenberg-Moore algebras for `L ‚ãô R` with underlying object `R.obj X`.\n\nWe later show that this is full when `R` is full, faithful when `R` is faithful,\nand essentially surjective when `R` is reflective.\n-/\n@[simps]\ndef Monad.comparison (h : L ‚ä£ R) : D ‚•§ h.toMonad.Algebra where\n  obj X :=\n    { A := R.obj X\n      a := R.map (h.counit.app X)\n      assoc := by\n        dsimp\n        rw [‚Üê R.map_comp, ‚Üê Adjunction.counit_naturality, R.map_comp] }\n  map f :=\n    { f := R.map f\n      h := by\n        dsimp\n        rw [‚Üê R.map_comp, Adjunction.counit_naturality, R.map_comp] }\n\n"}
{"name":"CategoryTheory.Monad.comparisonForget_hom_app","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\nx‚úù : D\n‚ä¢ Eq ((CategoryTheory.Monad.comparisonForget h).hom.app x‚úù) (CategoryTheory.CategoryStruct.id (((CategoryTheory.Monad.comparison h).comp h.toMonad.forget).obj x‚úù))","decl":"/-- The underlying object of `(Monad.comparison R).obj X` is just `R.obj X`.\n-/\n@[simps]\ndef Monad.comparisonForget (h : L ‚ä£ R) : Monad.comparison h ‚ãô h.toMonad.forget ‚âÖ R where\n  hom := { app := fun _ => ùüô _ }\n  inv := { app := fun _ => ùüô _ }\n\n"}
{"name":"CategoryTheory.Monad.comparisonForget_inv_app","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\nx‚úù : D\n‚ä¢ Eq ((CategoryTheory.Monad.comparisonForget h).inv.app x‚úù) (CategoryTheory.CategoryStruct.id (R.obj x‚úù))","decl":"/-- The underlying object of `(Monad.comparison R).obj X` is just `R.obj X`.\n-/\n@[simps]\ndef Monad.comparisonForget (h : L ‚ä£ R) : Monad.comparison h ‚ãô h.toMonad.forget ‚âÖ R where\n  hom := { app := fun _ => ùüô _ }\n  inv := { app := fun _ => ùüô _ }\n\n"}
{"name":"CategoryTheory.Monad.left_comparison","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\n‚ä¢ Eq (L.comp (CategoryTheory.Monad.comparison h)) h.toMonad.free","decl":"theorem Monad.left_comparison (h : L ‚ä£ R) : L ‚ãô Monad.comparison h = h.toMonad.free :=\n  rfl\n\n"}
{"name":"CategoryTheory.instFaithfulAlgebraToMonadComparison","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\ninst‚úù : R.Faithful\nh : CategoryTheory.Adjunction L R\n‚ä¢ (CategoryTheory.Monad.comparison h).Faithful","decl":"instance [R.Faithful] (h : L ‚ä£ R) : (Monad.comparison h).Faithful where\n  map_injective {_ _} _ _ w := R.map_injective (congr_arg Monad.Algebra.Hom.f w :)\n\n"}
{"name":"CategoryTheory.instFullAlgebraToMonadAdjComparison","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\n‚ä¢ (CategoryTheory.Monad.comparison T.adj).Full","decl":"instance (T : Monad C) : (Monad.comparison T.adj).Full where\n  map_surjective {_ _} f := ‚ü®‚ü®f.f, by simpa using f.h‚ü©, rfl‚ü©\n\n"}
{"name":"CategoryTheory.instEssSurjAlgebraToMonadAdjComparison","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\n‚ä¢ (CategoryTheory.Monad.comparison T.adj).EssSurj","decl":"instance (T : Monad C) : (Monad.comparison T.adj).EssSurj where\n  mem_essImage X :=\n    ‚ü®{  A := X.A\n        a := X.a\n        unit := by simpa using X.unit\n        assoc := by simpa using X.assoc },\n    ‚ü®Monad.Algebra.isoMk (Iso.refl _)‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Comonad.comparison_obj_a","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\nX : C\n‚ä¢ Eq ((CategoryTheory.Comonad.comparison h).obj X).a (L.map (h.unit.app X))","decl":"/--\nGiven any adjunction `L ‚ä£ R`, there is a comparison functor `CategoryTheory.Comonad.comparison L`\nsending objects `X : C` to Eilenberg-Moore coalgebras for `L ‚ãô R` with underlying object\n`L.obj X`.\n-/\n@[simps]\ndef Comonad.comparison (h : L ‚ä£ R) : C ‚•§ h.toComonad.Coalgebra where\n  obj X :=\n    { A := L.obj X\n      a := L.map (h.unit.app X)\n      coassoc := by\n        dsimp\n        rw [‚Üê L.map_comp, ‚Üê Adjunction.unit_naturality, L.map_comp] }\n  map f :=\n    { f := L.map f\n      h := by\n        dsimp\n        rw [‚Üê L.map_comp]\n        simp }\n\n"}
{"name":"CategoryTheory.Comonad.comparison_obj_A","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\nX : C\n‚ä¢ Eq ((CategoryTheory.Comonad.comparison h).obj X).A (L.obj X)","decl":"/--\nGiven any adjunction `L ‚ä£ R`, there is a comparison functor `CategoryTheory.Comonad.comparison L`\nsending objects `X : C` to Eilenberg-Moore coalgebras for `L ‚ãô R` with underlying object\n`L.obj X`.\n-/\n@[simps]\ndef Comonad.comparison (h : L ‚ä£ R) : C ‚•§ h.toComonad.Coalgebra where\n  obj X :=\n    { A := L.obj X\n      a := L.map (h.unit.app X)\n      coassoc := by\n        dsimp\n        rw [‚Üê L.map_comp, ‚Üê Adjunction.unit_naturality, L.map_comp] }\n  map f :=\n    { f := L.map f\n      h := by\n        dsimp\n        rw [‚Üê L.map_comp]\n        simp }\n\n"}
{"name":"CategoryTheory.Comonad.comparison_map_f","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Comonad.comparison h).map f).f (L.map f)","decl":"/--\nGiven any adjunction `L ‚ä£ R`, there is a comparison functor `CategoryTheory.Comonad.comparison L`\nsending objects `X : C` to Eilenberg-Moore coalgebras for `L ‚ãô R` with underlying object\n`L.obj X`.\n-/\n@[simps]\ndef Comonad.comparison (h : L ‚ä£ R) : C ‚•§ h.toComonad.Coalgebra where\n  obj X :=\n    { A := L.obj X\n      a := L.map (h.unit.app X)\n      coassoc := by\n        dsimp\n        rw [‚Üê L.map_comp, ‚Üê Adjunction.unit_naturality, L.map_comp] }\n  map f :=\n    { f := L.map f\n      h := by\n        dsimp\n        rw [‚Üê L.map_comp]\n        simp }\n\n"}
{"name":"CategoryTheory.Comonad.comparisonForget_inv_app","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\nx‚úù : C\n‚ä¢ Eq ((CategoryTheory.Comonad.comparisonForget h).inv.app x‚úù) (CategoryTheory.CategoryStruct.id (L.obj x‚úù))","decl":"/-- The underlying object of `(Comonad.comparison L).obj X` is just `L.obj X`.\n-/\n@[simps]\ndef Comonad.comparisonForget {L : C ‚•§ D} {R : D ‚•§ C} (h : L ‚ä£ R) :\n    Comonad.comparison h ‚ãô h.toComonad.forget ‚âÖ L where\n  hom := { app := fun _ => ùüô _ }\n  inv := { app := fun _ => ùüô _ }\n\n"}
{"name":"CategoryTheory.Comonad.comparisonForget_hom_app","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\nx‚úù : C\n‚ä¢ Eq ((CategoryTheory.Comonad.comparisonForget h).hom.app x‚úù) (CategoryTheory.CategoryStruct.id (((CategoryTheory.Comonad.comparison h).comp h.toComonad.forget).obj x‚úù))","decl":"/-- The underlying object of `(Comonad.comparison L).obj X` is just `L.obj X`.\n-/\n@[simps]\ndef Comonad.comparisonForget {L : C ‚•§ D} {R : D ‚•§ C} (h : L ‚ä£ R) :\n    Comonad.comparison h ‚ãô h.toComonad.forget ‚âÖ L where\n  hom := { app := fun _ => ùüô _ }\n  inv := { app := fun _ => ùüô _ }\n\n"}
{"name":"CategoryTheory.Comonad.left_comparison","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L R\n‚ä¢ Eq (R.comp (CategoryTheory.Comonad.comparison h)) h.toComonad.cofree","decl":"theorem Comonad.left_comparison (h : L ‚ä£ R) : R ‚ãô Comonad.comparison h = h.toComonad.cofree :=\n  rfl\n\n"}
{"name":"CategoryTheory.Comonad.comparison_faithful_of_faithful","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\ninst‚úù : L.Faithful\nh : CategoryTheory.Adjunction L R\n‚ä¢ (CategoryTheory.Comonad.comparison h).Faithful","decl":"instance Comonad.comparison_faithful_of_faithful [L.Faithful] (h : L ‚ä£ R) :\n    (Comonad.comparison h).Faithful where\n  map_injective {_ _} _ _ w := L.map_injective (congr_arg Comonad.Coalgebra.Hom.f w :)\n\n"}
{"name":"CategoryTheory.instFullCoalgebraToComonadAdjComparison","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\n‚ä¢ (CategoryTheory.Comonad.comparison G.adj).Full","decl":"instance (G : Comonad C) : (Comonad.comparison G.adj).Full where\n  map_surjective f := ‚ü®‚ü®f.f, by simpa using f.h‚ü©, rfl‚ü©\n\n"}
{"name":"CategoryTheory.instEssSurjCoalgebraToComonadAdjComparison","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\n‚ä¢ (CategoryTheory.Comonad.comparison G.adj).EssSurj","decl":"instance (G : Comonad C) : (Comonad.comparison G.adj).EssSurj where\n  mem_essImage X :=\n    ‚ü®{  A := X.A\n        a := X.a\n        counit := by simpa using X.counit\n        coassoc := by simpa using X.coassoc },\n      ‚ü®Comonad.Coalgebra.isoMk (Iso.refl _)‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.MonadicRightAdjoint.eqv","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nR : CategoryTheory.Functor D C\nself : CategoryTheory.MonadicRightAdjoint R\n‚ä¢ (CategoryTheory.Monad.comparison CategoryTheory.MonadicRightAdjoint.adj).IsEquivalence","decl":"/-- A right adjoint functor `R : D ‚•§ C` is *monadic* if the comparison functor `Monad.comparison R`\nfrom `D` to the category of Eilenberg-Moore algebras for the adjunction is an equivalence.\n-/\nclass MonadicRightAdjoint (R : D ‚•§ C) where\n  /-- a choice of left adjoint for `R` -/\n  L : C ‚•§ D\n  /-- `R` is a right adjoint -/\n  adj : L ‚ä£ R\n  eqv : (Monad.comparison adj).IsEquivalence\n\n"}
{"name":"CategoryTheory.instIsEquivalenceAlgebraToMonadMonadicAdjunctionComparison","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nR : CategoryTheory.Functor D C\ninst‚úù : CategoryTheory.MonadicRightAdjoint R\n‚ä¢ (CategoryTheory.Monad.comparison (CategoryTheory.monadicAdjunction R)).IsEquivalence","decl":"instance (R : D ‚•§ C) [MonadicRightAdjoint R] :\n    (Monad.comparison (monadicAdjunction R)).IsEquivalence :=\n  MonadicRightAdjoint.eqv\n\n"}
{"name":"CategoryTheory.instIsRightAdjointOfMonadicRightAdjoint","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nR : CategoryTheory.Functor D C\ninst‚úù : CategoryTheory.MonadicRightAdjoint R\n‚ä¢ R.IsRightAdjoint","decl":"instance (R : D ‚•§ C) [MonadicRightAdjoint R] : R.IsRightAdjoint :=\n  (monadicAdjunction R).isRightAdjoint\n\n"}
{"name":"CategoryTheory.ComonadicLeftAdjoint.eqv","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\nself : CategoryTheory.ComonadicLeftAdjoint L\n‚ä¢ (CategoryTheory.Comonad.comparison CategoryTheory.ComonadicLeftAdjoint.adj).IsEquivalence","decl":"/--\nA left adjoint functor `L : C ‚•§ D` is *comonadic* if the comparison functor `Comonad.comparison L`\nfrom `C` to the category of Eilenberg-Moore algebras for the adjunction is an equivalence.\n-/\nclass ComonadicLeftAdjoint (L : C ‚•§ D) where\n  /-- a choice of right adjoint for `L` -/\n  R : D ‚•§ C\n  /-- `L` is a left adjoint -/\n  adj : L ‚ä£ R\n  eqv : (Comonad.comparison adj).IsEquivalence\n\n"}
{"name":"CategoryTheory.instIsEquivalenceCoalgebraToComonadComonadicAdjunctionComparison","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.ComonadicLeftAdjoint L\n‚ä¢ (CategoryTheory.Comonad.comparison (CategoryTheory.comonadicAdjunction L)).IsEquivalence","decl":"instance (L : C ‚•§ D) [ComonadicLeftAdjoint L] :\n    (Comonad.comparison (comonadicAdjunction L)).IsEquivalence :=\n  ComonadicLeftAdjoint.eqv\n\n"}
{"name":"CategoryTheory.instIsLeftAdjointOfComonadicLeftAdjoint","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.ComonadicLeftAdjoint L\n‚ä¢ L.IsLeftAdjoint","decl":"instance (L : C ‚•§ D) [ComonadicLeftAdjoint L] : L.IsLeftAdjoint :=\n  (comonadicAdjunction L).isLeftAdjoint\n\n"}
{"name":"CategoryTheory.Œº_iso_of_reflective","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nR : CategoryTheory.Functor D C\ninst‚úù : CategoryTheory.Reflective R\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.reflectorAdjunction R).toMonad.Œº","decl":"instance Œº_iso_of_reflective [Reflective R] : IsIso (reflectorAdjunction R).toMonad.Œº := by\n  dsimp\n  infer_instance\n\n"}
{"name":"CategoryTheory.Œ¥_iso_of_coreflective","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nR : CategoryTheory.Functor D C\ninst‚úù : CategoryTheory.Coreflective R\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.coreflectorAdjunction R).toComonad.Œ¥","decl":"instance Œ¥_iso_of_coreflective [Coreflective R] : IsIso (coreflectorAdjunction R).toComonad.Œ¥ := by\n  dsimp\n  infer_instance\n\n"}
{"name":"CategoryTheory.Reflective.instIsIsoAppUnitReflectorAdjunctionA","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nR : CategoryTheory.Functor D C\ninst‚úù : CategoryTheory.Reflective R\nX : (CategoryTheory.reflectorAdjunction R).toMonad.Algebra\n‚ä¢ CategoryTheory.IsIso ((CategoryTheory.reflectorAdjunction R).unit.app X.A)","decl":"instance [Reflective R] (X : (reflectorAdjunction R).toMonad.Algebra) :\n    IsIso ((reflectorAdjunction R).unit.app X.A) :=\n  ‚ü®‚ü®X.a,\n      ‚ü®X.unit, by\n        dsimp only [Functor.id_obj]\n        rw [‚Üê (reflectorAdjunction R).unit_naturality]\n        dsimp only [Functor.comp_obj, Adjunction.toMonad_coe]\n        rw [unit_obj_eq_map_unit, ‚Üê Functor.map_comp, ‚Üê Functor.map_comp]\n        erw [X.unit]\n        simp‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Reflective.comparison_essSurj","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nR : CategoryTheory.Functor D C\ninst‚úù : CategoryTheory.Reflective R\n‚ä¢ (CategoryTheory.Monad.comparison (CategoryTheory.reflectorAdjunction R)).EssSurj","decl":"instance comparison_essSurj [Reflective R] :\n    (Monad.comparison (reflectorAdjunction R)).EssSurj := by\n  refine ‚ü®fun X => ‚ü®(reflector R).obj X.A, ‚ü®?_‚ü©‚ü©‚ü©\n  symm\n  refine Monad.Algebra.isoMk ?_ ?_\n  ¬∑ exact asIso ((reflectorAdjunction R).unit.app X.A)\n  dsimp only [Functor.comp_map, Monad.comparison_obj_a, asIso_hom, Functor.comp_obj,\n    Monad.comparison_obj_A, Adjunction.toMonad_coe]\n  rw [‚Üê cancel_epi ((reflectorAdjunction R).unit.app X.A)]\n  dsimp only [Functor.id_obj, Functor.comp_obj]\n  rw [Adjunction.unit_naturality_assoc,\n    Adjunction.right_triangle_components, comp_id]\n  apply (X.unit_assoc _).symm\n\n"}
{"name":"CategoryTheory.Reflective.comparison_full","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nR : CategoryTheory.Functor D C\ninst‚úù : R.Full\nL : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction L R\n‚ä¢ (CategoryTheory.Monad.comparison adj).Full","decl":"lemma comparison_full [R.Full] {L : C ‚•§ D} (adj : L ‚ä£ R) :\n    (Monad.comparison adj).Full where\n  map_surjective f := ‚ü®R.preimage f.f, by aesop_cat‚ü©\n\n"}
{"name":"CategoryTheory.Coreflective.instIsIsoAppCounitCoreflectorAdjunctionA","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nR : CategoryTheory.Functor D C\ninst‚úù : CategoryTheory.Coreflective R\nX : (CategoryTheory.coreflectorAdjunction R).toComonad.Coalgebra\n‚ä¢ CategoryTheory.IsIso ((CategoryTheory.coreflectorAdjunction R).counit.app X.A)","decl":"instance [Coreflective R] (X : (coreflectorAdjunction R).toComonad.Coalgebra) :\n    IsIso ((coreflectorAdjunction R).counit.app X.A) :=\n  ‚ü®‚ü®X.a,\n      ‚ü®by\n        dsimp only [Functor.id_obj]\n        rw [‚Üê (coreflectorAdjunction R).counit_naturality]\n        dsimp only [Functor.comp_obj, Adjunction.toMonad_coe]\n        rw [counit_obj_eq_map_counit, ‚Üê Functor.map_comp, ‚Üê Functor.map_comp]\n        erw [X.counit]\n        simp, X.counit‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Coreflective.comparison_essSurj","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nR : CategoryTheory.Functor D C\ninst‚úù : CategoryTheory.Coreflective R\n‚ä¢ (CategoryTheory.Comonad.comparison (CategoryTheory.coreflectorAdjunction R)).EssSurj","decl":"instance comparison_essSurj [Coreflective R] :\n    (Comonad.comparison (coreflectorAdjunction R)).EssSurj := by\n  refine ‚ü®fun X => ‚ü®(coreflector R).obj X.A, ‚ü®?_‚ü©‚ü©‚ü©\n  refine Comonad.Coalgebra.isoMk ?_ ?_\n  ¬∑ exact (asIso ((coreflectorAdjunction R).counit.app X.A))\n  rw [‚Üê cancel_mono ((coreflectorAdjunction R).counit.app X.A)]\n  simp only [Adjunction.counit_naturality, Functor.comp_obj, Functor.id_obj,\n    Adjunction.left_triangle_components_assoc, assoc]\n  erw [X.counit]\n  simp\n\n"}
{"name":"CategoryTheory.Coreflective.comparison_full","module":"Mathlib.CategoryTheory.Monad.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nR : CategoryTheory.Functor D C\ninst‚úù : R.Full\nL : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction R L\n‚ä¢ (CategoryTheory.Comonad.comparison adj).Full","decl":"lemma comparison_full [R.Full] {L : C ‚•§ D} (adj : R ‚ä£ L) :\n    (Comonad.comparison adj).Full where\n  map_surjective f := ‚ü®R.preimage f.f, by aesop_cat‚ü©\n\n"}
