{"name":"OreLocalization.ind","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : Monoid R\nS : Submonoid R\ninst✝¹ : OreLocalization.OreSet S\nX : Type u_2\ninst✝ : MulAction R X\nβ : OreLocalization S X → Prop\nc : ∀ (r : X) (s : Subtype fun x => Membership.mem S x), β (OreLocalization.oreDiv r s)\nq : OreLocalization S X\n⊢ β q","decl":"@[to_additive (attr := elab_as_elim, cases_eliminator, induction_eliminator)]\nprotected theorem ind {β : X[S⁻¹] → Prop}\n    (c : ∀ (r : X) (s : S), β (r /ₒ s)) : ∀ q, β q := by\n  apply Quotient.ind\n  rintro ⟨r, s⟩\n  exact c r s\n\n"}
{"name":"AddOreLocalization.ind","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : AddMonoid R\nS : AddSubmonoid R\ninst✝¹ : AddOreLocalization.AddOreSet S\nX : Type u_2\ninst✝ : AddAction R X\nβ : AddOreLocalization S X → Prop\nc : ∀ (r : X) (s : Subtype fun x => Membership.mem S x), β (AddOreLocalization.oreSub r s)\nq : AddOreLocalization S X\n⊢ β q","decl":"@[to_additive (attr := elab_as_elim, cases_eliminator, induction_eliminator)]\nprotected theorem ind {β : X[S⁻¹] → Prop}\n    (c : ∀ (r : X) (s : S), β (r /ₒ s)) : ∀ q, β q := by\n  apply Quotient.ind\n  rintro ⟨r, s⟩\n  exact c r s\n\n"}
{"name":"OreLocalization.oreDiv_eq_iff","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : Monoid R\nS : Submonoid R\ninst✝¹ : OreLocalization.OreSet S\nX : Type u_2\ninst✝ : MulAction R X\nr₁ r₂ : X\ns₁ s₂ : Subtype fun x => Membership.mem S x\n⊢ Iff (Eq (OreLocalization.oreDiv r₁ s₁) (OreLocalization.oreDiv r₂ s₂)) (Exists fun u => Exists fun v => And (Eq (HSMul.hSMul u r₂) (HSMul.hSMul v r₁)) (Eq (HMul.hMul ↑u ↑s₂) (HMul.hMul v ↑s₁)))","decl":"@[to_additive]\ntheorem oreDiv_eq_iff {r₁ r₂ : X} {s₁ s₂ : S} :\n    r₁ /ₒ s₁ = r₂ /ₒ s₂ ↔ ∃ (u : S) (v : R), u • r₂ = v • r₁ ∧ u * s₂ = v * s₁ :=\n  Quotient.eq''\n\n"}
{"name":"AddOreLocalization.oreSub_eq_iff","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : AddMonoid R\nS : AddSubmonoid R\ninst✝¹ : AddOreLocalization.AddOreSet S\nX : Type u_2\ninst✝ : AddAction R X\nr₁ r₂ : X\ns₁ s₂ : Subtype fun x => Membership.mem S x\n⊢ Iff (Eq (AddOreLocalization.oreSub r₁ s₁) (AddOreLocalization.oreSub r₂ s₂)) (Exists fun u => Exists fun v => And (Eq (HVAdd.hVAdd u r₂) (HVAdd.hVAdd v r₁)) (Eq (HAdd.hAdd ↑u ↑s₂) (HAdd.hAdd v ↑s₁)))","decl":"@[to_additive]\ntheorem oreDiv_eq_iff {r₁ r₂ : X} {s₁ s₂ : S} :\n    r₁ /ₒ s₁ = r₂ /ₒ s₂ ↔ ∃ (u : S) (v : R), u • r₂ = v • r₁ ∧ u * s₂ = v * s₁ :=\n  Quotient.eq''\n\n"}
{"name":"AddOreLocalization.expand","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : AddMonoid R\nS : AddSubmonoid R\ninst✝¹ : AddOreLocalization.AddOreSet S\nX : Type u_2\ninst✝ : AddAction R X\nr : X\ns : Subtype fun x => Membership.mem S x\nt : R\nhst : Membership.mem S (HAdd.hAdd t ↑s)\n⊢ Eq (AddOreLocalization.oreSub r s) (AddOreLocalization.oreSub (HVAdd.hVAdd t r) ⟨HAdd.hAdd t ↑s, hst⟩)","decl":"/-- A fraction `r /ₒ s` is equal to its expansion by an arbitrary factor `t` if `t * s ∈ S`. -/\n@[to_additive \"A difference `r -ₒ s` is equal to its expansion by an\narbitrary translation `t` if `t + s ∈ S`.\"]\nprotected theorem expand (r : X) (s : S) (t : R) (hst : t * (s : R) ∈ S) :\n    r /ₒ s = t • r /ₒ ⟨t * s, hst⟩ := by\n  apply Quotient.sound\n  exact ⟨s, s * t, by rw [mul_smul, Submonoid.smul_def], by rw [← mul_assoc]⟩\n\n"}
{"name":"OreLocalization.expand","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : Monoid R\nS : Submonoid R\ninst✝¹ : OreLocalization.OreSet S\nX : Type u_2\ninst✝ : MulAction R X\nr : X\ns : Subtype fun x => Membership.mem S x\nt : R\nhst : Membership.mem S (HMul.hMul t ↑s)\n⊢ Eq (OreLocalization.oreDiv r s) (OreLocalization.oreDiv (HSMul.hSMul t r) ⟨HMul.hMul t ↑s, hst⟩)","decl":"/-- A fraction `r /ₒ s` is equal to its expansion by an arbitrary factor `t` if `t * s ∈ S`. -/\n@[to_additive \"A difference `r -ₒ s` is equal to its expansion by an\narbitrary translation `t` if `t + s ∈ S`.\"]\nprotected theorem expand (r : X) (s : S) (t : R) (hst : t * (s : R) ∈ S) :\n    r /ₒ s = t • r /ₒ ⟨t * s, hst⟩ := by\n  apply Quotient.sound\n  exact ⟨s, s * t, by rw [mul_smul, Submonoid.smul_def], by rw [← mul_assoc]⟩\n\n"}
{"name":"OreLocalization.expand'","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : Monoid R\nS : Submonoid R\ninst✝¹ : OreLocalization.OreSet S\nX : Type u_2\ninst✝ : MulAction R X\nr : X\ns s' : Subtype fun x => Membership.mem S x\n⊢ Eq (OreLocalization.oreDiv r s) (OreLocalization.oreDiv (HSMul.hSMul s' r) (HMul.hMul s' s))","decl":"/-- A fraction is equal to its expansion by a factor from `S`. -/\n@[to_additive \"A difference is equal to its expansion by a summand from `S`.\"]\nprotected theorem expand' (r : X) (s s' : S) : r /ₒ s = s' • r /ₒ (s' * s) :=\n  OreLocalization.expand r s s' (by norm_cast; apply SetLike.coe_mem)\n\n"}
{"name":"AddOreLocalization.expand'","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : AddMonoid R\nS : AddSubmonoid R\ninst✝¹ : AddOreLocalization.AddOreSet S\nX : Type u_2\ninst✝ : AddAction R X\nr : X\ns s' : Subtype fun x => Membership.mem S x\n⊢ Eq (AddOreLocalization.oreSub r s) (AddOreLocalization.oreSub (HVAdd.hVAdd s' r) (HAdd.hAdd s' s))","decl":"/-- A fraction is equal to its expansion by a factor from `S`. -/\n@[to_additive \"A difference is equal to its expansion by a summand from `S`.\"]\nprotected theorem expand' (r : X) (s s' : S) : r /ₒ s = s' • r /ₒ (s' * s) :=\n  OreLocalization.expand r s s' (by norm_cast; apply SetLike.coe_mem)\n\n"}
{"name":"OreLocalization.eq_of_num_factor_eq","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Monoid R\nS : Submonoid R\ninst✝ : OreLocalization.OreSet S\nr r' r₁ r₂ : R\ns t : Subtype fun x => Membership.mem S x\nh : Eq (HMul.hMul (↑t) r) (HMul.hMul (↑t) r')\n⊢ Eq (OreLocalization.oreDiv (HMul.hMul (HMul.hMul r₁ r) r₂) s) (OreLocalization.oreDiv (HMul.hMul (HMul.hMul r₁ r') r₂) s)","decl":"/-- Fractions which differ by a factor of the numerator can be proven equal if\nthose factors expand to equal elements of `R`. -/\n@[to_additive \"Differences whose minuends differ by a common summand can be proven equal if\nthose summands expand to equal elements of `R`.\"]\nprotected theorem eq_of_num_factor_eq {r r' r₁ r₂ : R} {s t : S} (h : t * r = t * r') :\n    r₁ * r * r₂ /ₒ s = r₁ * r' * r₂ /ₒ s := by\n  rcases oreCondition r₁ t with ⟨r₁', t', hr₁⟩\n  rw [OreLocalization.expand' _ s t', OreLocalization.expand' _ s t']\n  congr 1\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: use `assoc_rw`?\n  calc (t' : R) * (r₁ * r * r₂)\n      = t' * r₁ * r * r₂ := by simp [← mul_assoc]\n    _ = r₁' * t * r * r₂ := by rw [hr₁]\n    _ = r₁' * (t * r) * r₂ := by simp [← mul_assoc]\n    _ = r₁' * (t * r') * r₂ := by rw [h]\n    _ = r₁' * t * r' * r₂ := by simp [← mul_assoc]\n    _ = t' * r₁ * r' * r₂ := by rw [hr₁]\n    _ = t' * (r₁ * r' * r₂) := by simp [← mul_assoc]\n\n"}
{"name":"AddOreLocalization.eq_of_num_factor_eq","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoid R\nS : AddSubmonoid R\ninst✝ : AddOreLocalization.AddOreSet S\nr r' r₁ r₂ : R\ns t : Subtype fun x => Membership.mem S x\nh : Eq (HAdd.hAdd (↑t) r) (HAdd.hAdd (↑t) r')\n⊢ Eq (AddOreLocalization.oreSub (HAdd.hAdd (HAdd.hAdd r₁ r) r₂) s) (AddOreLocalization.oreSub (HAdd.hAdd (HAdd.hAdd r₁ r') r₂) s)","decl":"/-- Fractions which differ by a factor of the numerator can be proven equal if\nthose factors expand to equal elements of `R`. -/\n@[to_additive \"Differences whose minuends differ by a common summand can be proven equal if\nthose summands expand to equal elements of `R`.\"]\nprotected theorem eq_of_num_factor_eq {r r' r₁ r₂ : R} {s t : S} (h : t * r = t * r') :\n    r₁ * r * r₂ /ₒ s = r₁ * r' * r₂ /ₒ s := by\n  rcases oreCondition r₁ t with ⟨r₁', t', hr₁⟩\n  rw [OreLocalization.expand' _ s t', OreLocalization.expand' _ s t']\n  congr 1\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: use `assoc_rw`?\n  calc (t' : R) * (r₁ * r * r₂)\n      = t' * r₁ * r * r₂ := by simp [← mul_assoc]\n    _ = r₁' * t * r * r₂ := by rw [hr₁]\n    _ = r₁' * (t * r) * r₂ := by simp [← mul_assoc]\n    _ = r₁' * (t * r') * r₂ := by rw [h]\n    _ = r₁' * t * r' * r₂ := by simp [← mul_assoc]\n    _ = t' * r₁ * r' * r₂ := by rw [hr₁]\n    _ = t' * (r₁ * r' * r₂) := by simp [← mul_assoc]\n\n"}
{"name":"OreLocalization.liftExpand_of","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : Monoid R\nS : Submonoid R\ninst✝¹ : OreLocalization.OreSet S\nX : Type u_3\ninst✝ : MulAction R X\nC : Sort u_2\nP : X → (Subtype fun x => Membership.mem S x) → C\nhP : ∀ (r : X) (t : R) (s : Subtype fun x => Membership.mem S x) (ht : Membership.mem S (HMul.hMul t ↑s)), Eq (P r s) (P (HSMul.hSMul t r) ⟨HMul.hMul t ↑s, ht⟩)\nr : X\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (OreLocalization.liftExpand P hP (OreLocalization.oreDiv r s)) (P r s)","decl":"@[to_additive (attr := simp)]\ntheorem liftExpand_of {C : Sort*} {P : X → S → C}\n    {hP : ∀ (r : X) (t : R) (s : S) (ht : t * s ∈ S), P r s = P (t • r) ⟨t * s, ht⟩} (r : X)\n    (s : S) : liftExpand P hP (r /ₒ s) = P r s :=\n  rfl\n\n"}
{"name":"AddOreLocalization.liftExpand_of","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : AddMonoid R\nS : AddSubmonoid R\ninst✝¹ : AddOreLocalization.AddOreSet S\nX : Type u_3\ninst✝ : AddAction R X\nC : Sort u_2\nP : X → (Subtype fun x => Membership.mem S x) → C\nhP : ∀ (r : X) (t : R) (s : Subtype fun x => Membership.mem S x) (ht : Membership.mem S (HAdd.hAdd t ↑s)), Eq (P r s) (P (HVAdd.hVAdd t r) ⟨HAdd.hAdd t ↑s, ht⟩)\nr : X\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (AddOreLocalization.liftExpand P hP (AddOreLocalization.oreSub r s)) (P r s)","decl":"@[to_additive (attr := simp)]\ntheorem liftExpand_of {C : Sort*} {P : X → S → C}\n    {hP : ∀ (r : X) (t : R) (s : S) (ht : t * s ∈ S), P r s = P (t • r) ⟨t * s, ht⟩} (r : X)\n    (s : S) : liftExpand P hP (r /ₒ s) = P r s :=\n  rfl\n\n"}
{"name":"AddOreLocalization.lift₂Expand_of","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : AddMonoid R\nS : AddSubmonoid R\ninst✝¹ : AddOreLocalization.AddOreSet S\nX : Type u_3\ninst✝ : AddAction R X\nC : Sort u_2\nP : X → (Subtype fun x => Membership.mem S x) → X → (Subtype fun x => Membership.mem S x) → C\nhP : ∀ (r₁ : X) (t₁ : R) (s₁ : Subtype fun x => Membership.mem S x) (ht₁ : Membership.mem S (HAdd.hAdd t₁ ↑s₁)) (r₂ : X) (t₂ : R) (s₂ : Subtype fun x => Membership.mem S x) (ht₂ : Membership.mem S (HAdd.hAdd t₂ ↑s₂)), Eq (P r₁ s₁ r₂ s₂) (P (HVAdd.hVAdd t₁ r₁) ⟨HAdd.hAdd t₁ ↑s₁, ht₁⟩ (HVAdd.hVAdd t₂ r₂) ⟨HAdd.hAdd t₂ ↑s₂, ht₂⟩)\nr₁ : X\ns₁ : Subtype fun x => Membership.mem S x\nr₂ : X\ns₂ : Subtype fun x => Membership.mem S x\n⊢ Eq (AddOreLocalization.lift₂Expand P hP (AddOreLocalization.oreSub r₁ s₁) (AddOreLocalization.oreSub r₂ s₂)) (P r₁ s₁ r₂ s₂)","decl":"@[to_additive (attr := simp)]\ntheorem lift₂Expand_of {C : Sort*} {P : X → S → X → S → C}\n    {hP :\n      ∀ (r₁ : X) (t₁ : R) (s₁ : S) (ht₁ : t₁ * s₁ ∈ S) (r₂ : X) (t₂ : R) (s₂ : S)\n        (ht₂ : t₂ * s₂ ∈ S),\n        P r₁ s₁ r₂ s₂ = P (t₁ • r₁) ⟨t₁ * s₁, ht₁⟩ (t₂ • r₂) ⟨t₂ * s₂, ht₂⟩}\n    (r₁ : X) (s₁ : S) (r₂ : X) (s₂ : S) : lift₂Expand P hP (r₁ /ₒ s₁) (r₂ /ₒ s₂) = P r₁ s₁ r₂ s₂ :=\n  rfl\n\n"}
{"name":"OreLocalization.lift₂Expand_of","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : Monoid R\nS : Submonoid R\ninst✝¹ : OreLocalization.OreSet S\nX : Type u_3\ninst✝ : MulAction R X\nC : Sort u_2\nP : X → (Subtype fun x => Membership.mem S x) → X → (Subtype fun x => Membership.mem S x) → C\nhP : ∀ (r₁ : X) (t₁ : R) (s₁ : Subtype fun x => Membership.mem S x) (ht₁ : Membership.mem S (HMul.hMul t₁ ↑s₁)) (r₂ : X) (t₂ : R) (s₂ : Subtype fun x => Membership.mem S x) (ht₂ : Membership.mem S (HMul.hMul t₂ ↑s₂)), Eq (P r₁ s₁ r₂ s₂) (P (HSMul.hSMul t₁ r₁) ⟨HMul.hMul t₁ ↑s₁, ht₁⟩ (HSMul.hSMul t₂ r₂) ⟨HMul.hMul t₂ ↑s₂, ht₂⟩)\nr₁ : X\ns₁ : Subtype fun x => Membership.mem S x\nr₂ : X\ns₂ : Subtype fun x => Membership.mem S x\n⊢ Eq (OreLocalization.lift₂Expand P hP (OreLocalization.oreDiv r₁ s₁) (OreLocalization.oreDiv r₂ s₂)) (P r₁ s₁ r₂ s₂)","decl":"@[to_additive (attr := simp)]\ntheorem lift₂Expand_of {C : Sort*} {P : X → S → X → S → C}\n    {hP :\n      ∀ (r₁ : X) (t₁ : R) (s₁ : S) (ht₁ : t₁ * s₁ ∈ S) (r₂ : X) (t₂ : R) (s₂ : S)\n        (ht₂ : t₂ * s₂ ∈ S),\n        P r₁ s₁ r₂ s₂ = P (t₁ • r₁) ⟨t₁ * s₁, ht₁⟩ (t₂ • r₂) ⟨t₂ * s₂, ht₂⟩}\n    (r₁ : X) (s₁ : S) (r₂ : X) (s₂ : S) : lift₂Expand P hP (r₁ /ₒ s₁) (r₂ /ₒ s₂) = P r₁ s₁ r₂ s₂ :=\n  rfl\n\n"}
{"name":"OreLocalization.oreDiv_smul_oreDiv","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : Monoid R\nS : Submonoid R\ninst✝¹ : OreLocalization.OreSet S\nX : Type u_2\ninst✝ : MulAction R X\nr₁ : R\nr₂ : X\ns₁ s₂ : Subtype fun x => Membership.mem S x\n⊢ Eq (HSMul.hSMul (OreLocalization.oreDiv r₁ s₁) (OreLocalization.oreDiv r₂ s₂)) (OreLocalization.oreDiv (HSMul.hSMul (OreLocalization.oreNum r₁ s₂) r₂) (HMul.hMul (OreLocalization.oreDenom r₁ s₂) s₁))","decl":"@[to_additive]\ntheorem oreDiv_smul_oreDiv {r₁ : R} {r₂ : X} {s₁ s₂ : S} :\n    (r₁ /ₒ s₁) • (r₂ /ₒ s₂) = oreNum r₁ s₂ • r₂ /ₒ (oreDenom r₁ s₂ * s₁) := by\n  with_unfolding_all rfl\n\n"}
{"name":"AddOreLocalization.oreSub_vadd_oreSub","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : AddMonoid R\nS : AddSubmonoid R\ninst✝¹ : AddOreLocalization.AddOreSet S\nX : Type u_2\ninst✝ : AddAction R X\nr₁ : R\nr₂ : X\ns₁ s₂ : Subtype fun x => Membership.mem S x\n⊢ Eq (HVAdd.hVAdd (AddOreLocalization.oreSub r₁ s₁) (AddOreLocalization.oreSub r₂ s₂)) (AddOreLocalization.oreSub (HVAdd.hVAdd (AddOreLocalization.oreMin r₁ s₂) r₂) (HAdd.hAdd (AddOreLocalization.oreSubtra r₁ s₂) s₁))","decl":"@[to_additive]\ntheorem oreDiv_smul_oreDiv {r₁ : R} {r₂ : X} {s₁ s₂ : S} :\n    (r₁ /ₒ s₁) • (r₂ /ₒ s₂) = oreNum r₁ s₂ • r₂ /ₒ (oreDenom r₁ s₂ * s₁) := by\n  with_unfolding_all rfl\n\n"}
{"name":"OreLocalization.oreDiv_mul_oreDiv","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Monoid R\nS : Submonoid R\ninst✝ : OreLocalization.OreSet S\nr₁ r₂ : R\ns₁ s₂ : Subtype fun x => Membership.mem S x\n⊢ Eq (HMul.hMul (OreLocalization.oreDiv r₁ s₁) (OreLocalization.oreDiv r₂ s₂)) (OreLocalization.oreDiv (HMul.hMul (OreLocalization.oreNum r₁ s₂) r₂) (HMul.hMul (OreLocalization.oreDenom r₁ s₂) s₁))","decl":"@[to_additive]\ntheorem oreDiv_mul_oreDiv {r₁ : R} {r₂ : R} {s₁ s₂ : S} :\n    (r₁ /ₒ s₁) * (r₂ /ₒ s₂) = oreNum r₁ s₂ * r₂ /ₒ (oreDenom r₁ s₂ * s₁) := by\n  with_unfolding_all rfl\n\n"}
{"name":"AddOreLocalization.oreSub_add_oreSub","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoid R\nS : AddSubmonoid R\ninst✝ : AddOreLocalization.AddOreSet S\nr₁ r₂ : R\ns₁ s₂ : Subtype fun x => Membership.mem S x\n⊢ Eq (HAdd.hAdd (AddOreLocalization.oreSub r₁ s₁) (AddOreLocalization.oreSub r₂ s₂)) (AddOreLocalization.oreSub (HAdd.hAdd (AddOreLocalization.oreMin r₁ s₂) r₂) (HAdd.hAdd (AddOreLocalization.oreSubtra r₁ s₂) s₁))","decl":"@[to_additive]\ntheorem oreDiv_mul_oreDiv {r₁ : R} {r₂ : R} {s₁ s₂ : S} :\n    (r₁ /ₒ s₁) * (r₂ /ₒ s₂) = oreNum r₁ s₂ * r₂ /ₒ (oreDenom r₁ s₂ * s₁) := by\n  with_unfolding_all rfl\n\n"}
{"name":"AddOreLocalization.oreSub_vadd_char","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : AddMonoid R\nS : AddSubmonoid R\ninst✝¹ : AddOreLocalization.AddOreSet S\nX : Type u_2\ninst✝ : AddAction R X\nr₁ : R\nr₂ : X\ns₁ s₂ : Subtype fun x => Membership.mem S x\nr' : R\ns' : Subtype fun x => Membership.mem S x\nhuv : Eq (HAdd.hAdd (↑s') r₁) (HAdd.hAdd r' ↑s₂)\n⊢ Eq (HVAdd.hVAdd (AddOreLocalization.oreSub r₁ s₁) (AddOreLocalization.oreSub r₂ s₂)) (AddOreLocalization.oreSub (HVAdd.hVAdd r' r₂) (HAdd.hAdd s' s₁))","decl":"/-- A characterization lemma for the scalar multiplication on the Ore localization,\nallowing for a choice of Ore numerator and Ore denominator. -/\n@[to_additive \"A characterization lemma for the vector addition on the Ore localization,\nallowing for a choice of Ore minuend and Ore subtrahend.\"]\ntheorem oreDiv_smul_char (r₁ : R) (r₂ : X) (s₁ s₂ : S) (r' : R) (s' : S) (huv : s' * r₁ = r' * s₂) :\n    (r₁ /ₒ s₁) • (r₂ /ₒ s₂) = r' • r₂ /ₒ (s' * s₁) := by\n  with_unfolding_all exact smul'_char r₁ r₂ s₁ s₂ s' r' huv\n\n"}
{"name":"OreLocalization.oreDiv_smul_char","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : Monoid R\nS : Submonoid R\ninst✝¹ : OreLocalization.OreSet S\nX : Type u_2\ninst✝ : MulAction R X\nr₁ : R\nr₂ : X\ns₁ s₂ : Subtype fun x => Membership.mem S x\nr' : R\ns' : Subtype fun x => Membership.mem S x\nhuv : Eq (HMul.hMul (↑s') r₁) (HMul.hMul r' ↑s₂)\n⊢ Eq (HSMul.hSMul (OreLocalization.oreDiv r₁ s₁) (OreLocalization.oreDiv r₂ s₂)) (OreLocalization.oreDiv (HSMul.hSMul r' r₂) (HMul.hMul s' s₁))","decl":"/-- A characterization lemma for the scalar multiplication on the Ore localization,\nallowing for a choice of Ore numerator and Ore denominator. -/\n@[to_additive \"A characterization lemma for the vector addition on the Ore localization,\nallowing for a choice of Ore minuend and Ore subtrahend.\"]\ntheorem oreDiv_smul_char (r₁ : R) (r₂ : X) (s₁ s₂ : S) (r' : R) (s' : S) (huv : s' * r₁ = r' * s₂) :\n    (r₁ /ₒ s₁) • (r₂ /ₒ s₂) = r' • r₂ /ₒ (s' * s₁) := by\n  with_unfolding_all exact smul'_char r₁ r₂ s₁ s₂ s' r' huv\n\n"}
{"name":"AddOreLocalization.oreSub_add_char","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoid R\nS : AddSubmonoid R\ninst✝ : AddOreLocalization.AddOreSet S\nr₁ r₂ : R\ns₁ s₂ : Subtype fun x => Membership.mem S x\nr' : R\ns' : Subtype fun x => Membership.mem S x\nhuv : Eq (HAdd.hAdd (↑s') r₁) (HAdd.hAdd r' ↑s₂)\n⊢ Eq (HAdd.hAdd (AddOreLocalization.oreSub r₁ s₁) (AddOreLocalization.oreSub r₂ s₂)) (AddOreLocalization.oreSub (HAdd.hAdd r' r₂) (HAdd.hAdd s' s₁))","decl":"/-- A characterization lemma for the multiplication on the Ore localization, allowing for a choice\nof Ore numerator and Ore denominator. -/\n@[to_additive \"A characterization lemma for the addition on the Ore localization,\nallowing for a choice of Ore minuend and Ore subtrahend.\"]\ntheorem oreDiv_mul_char (r₁ r₂ : R) (s₁ s₂ : S) (r' : R) (s' : S) (huv : s' * r₁ = r' * s₂) :\n    r₁ /ₒ s₁ * (r₂ /ₒ s₂) = r' * r₂ /ₒ (s' * s₁) := by\n  with_unfolding_all exact smul'_char r₁ r₂ s₁ s₂ s' r' huv\n\n"}
{"name":"OreLocalization.oreDiv_mul_char","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Monoid R\nS : Submonoid R\ninst✝ : OreLocalization.OreSet S\nr₁ r₂ : R\ns₁ s₂ : Subtype fun x => Membership.mem S x\nr' : R\ns' : Subtype fun x => Membership.mem S x\nhuv : Eq (HMul.hMul (↑s') r₁) (HMul.hMul r' ↑s₂)\n⊢ Eq (HMul.hMul (OreLocalization.oreDiv r₁ s₁) (OreLocalization.oreDiv r₂ s₂)) (OreLocalization.oreDiv (HMul.hMul r' r₂) (HMul.hMul s' s₁))","decl":"/-- A characterization lemma for the multiplication on the Ore localization, allowing for a choice\nof Ore numerator and Ore denominator. -/\n@[to_additive \"A characterization lemma for the addition on the Ore localization,\nallowing for a choice of Ore minuend and Ore subtrahend.\"]\ntheorem oreDiv_mul_char (r₁ r₂ : R) (s₁ s₂ : S) (r' : R) (s' : S) (huv : s' * r₁ = r' * s₂) :\n    r₁ /ₒ s₁ * (r₂ /ₒ s₂) = r' * r₂ /ₒ (s' * s₁) := by\n  with_unfolding_all exact smul'_char r₁ r₂ s₁ s₂ s' r' huv\n\n"}
{"name":"OreLocalization.one_def","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Monoid R\nS : Submonoid R\ninst✝ : OreLocalization.OreSet S\n⊢ Eq 1 (OreLocalization.oreDiv 1 1)","decl":"@[to_additive]\nprotected theorem one_def : (1 : R[S⁻¹]) = 1 /ₒ 1 := by\n  with_unfolding_all rfl\n\n"}
{"name":"AddOreLocalization.zero_def","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoid R\nS : AddSubmonoid R\ninst✝ : AddOreLocalization.AddOreSet S\n⊢ Eq 0 (AddOreLocalization.oreSub 0 0)","decl":"@[to_additive]\nprotected theorem one_def : (1 : R[S⁻¹]) = 1 /ₒ 1 := by\n  with_unfolding_all rfl\n\n"}
{"name":"OreLocalization.div_eq_one'","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Monoid R\nS : Submonoid R\ninst✝ : OreLocalization.OreSet S\nr : R\nhr : Membership.mem S r\n⊢ Eq (OreLocalization.oreDiv r ⟨r, hr⟩) 1","decl":"@[to_additive (attr := simp)]\nprotected theorem div_eq_one' {r : R} (hr : r ∈ S) : r /ₒ ⟨r, hr⟩ = 1 := by\n  rw [OreLocalization.one_def, oreDiv_eq_iff]\n  exact ⟨⟨r, hr⟩, 1, by simp, by simp⟩\n\n"}
{"name":"AddOreLocalization.sub_eq_zero'","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoid R\nS : AddSubmonoid R\ninst✝ : AddOreLocalization.AddOreSet S\nr : R\nhr : Membership.mem S r\n⊢ Eq (AddOreLocalization.oreSub r ⟨r, hr⟩) 0","decl":"@[to_additive (attr := simp)]\nprotected theorem div_eq_one' {r : R} (hr : r ∈ S) : r /ₒ ⟨r, hr⟩ = 1 := by\n  rw [OreLocalization.one_def, oreDiv_eq_iff]\n  exact ⟨⟨r, hr⟩, 1, by simp, by simp⟩\n\n"}
{"name":"AddOreLocalization.sub_eq_zero","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoid R\nS : AddSubmonoid R\ninst✝ : AddOreLocalization.AddOreSet S\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (AddOreLocalization.oreSub (↑s) s) 0","decl":"@[to_additive (attr := simp)]\nprotected theorem div_eq_one {s : S} : (s : R) /ₒ s = 1 :=\n  OreLocalization.div_eq_one' _\n\n"}
{"name":"OreLocalization.div_eq_one","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Monoid R\nS : Submonoid R\ninst✝ : OreLocalization.OreSet S\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (OreLocalization.oreDiv (↑s) s) 1","decl":"@[to_additive (attr := simp)]\nprotected theorem div_eq_one {s : S} : (s : R) /ₒ s = 1 :=\n  OreLocalization.div_eq_one' _\n\n"}
{"name":"OreLocalization.one_smul","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : Monoid R\nS : Submonoid R\ninst✝¹ : OreLocalization.OreSet S\nX : Type u_2\ninst✝ : MulAction R X\nx : OreLocalization S X\n⊢ Eq (HSMul.hSMul 1 x) x","decl":"@[to_additive]\nprotected theorem one_smul (x : X[S⁻¹]) : (1 : R[S⁻¹]) • x = x := by\n  induction' x with r s\n  simp [OreLocalization.one_def, oreDiv_smul_char 1 r 1 s 1 s (by simp)]\n\n"}
{"name":"AddOreLocalization.zero_vadd","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : AddMonoid R\nS : AddSubmonoid R\ninst✝¹ : AddOreLocalization.AddOreSet S\nX : Type u_2\ninst✝ : AddAction R X\nx : AddOreLocalization S X\n⊢ Eq (HVAdd.hVAdd 0 x) x","decl":"@[to_additive]\nprotected theorem one_smul (x : X[S⁻¹]) : (1 : R[S⁻¹]) • x = x := by\n  induction' x with r s\n  simp [OreLocalization.one_def, oreDiv_smul_char 1 r 1 s 1 s (by simp)]\n\n"}
{"name":"AddOreLocalization.zero_add","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoid R\nS : AddSubmonoid R\ninst✝ : AddOreLocalization.AddOreSet S\nx : AddOreLocalization S R\n⊢ Eq (HAdd.hAdd 0 x) x","decl":"@[to_additive]\nprotected theorem one_mul (x : R[S⁻¹]) : 1 * x = x :=\n  OreLocalization.one_smul x\n\n"}
{"name":"OreLocalization.one_mul","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Monoid R\nS : Submonoid R\ninst✝ : OreLocalization.OreSet S\nx : OreLocalization S R\n⊢ Eq (HMul.hMul 1 x) x","decl":"@[to_additive]\nprotected theorem one_mul (x : R[S⁻¹]) : 1 * x = x :=\n  OreLocalization.one_smul x\n\n"}
{"name":"AddOreLocalization.add_zero","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoid R\nS : AddSubmonoid R\ninst✝ : AddOreLocalization.AddOreSet S\nx : AddOreLocalization S R\n⊢ Eq (HAdd.hAdd x 0) x","decl":"@[to_additive]\nprotected theorem mul_one (x : R[S⁻¹]) : x * 1 = x := by\n  induction' x with r s\n  simp [OreLocalization.one_def, oreDiv_mul_char r (1 : R) s (1 : S) r 1 (by simp)]\n\n"}
{"name":"OreLocalization.mul_one","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Monoid R\nS : Submonoid R\ninst✝ : OreLocalization.OreSet S\nx : OreLocalization S R\n⊢ Eq (HMul.hMul x 1) x","decl":"@[to_additive]\nprotected theorem mul_one (x : R[S⁻¹]) : x * 1 = x := by\n  induction' x with r s\n  simp [OreLocalization.one_def, oreDiv_mul_char r (1 : R) s (1 : S) r 1 (by simp)]\n\n"}
{"name":"AddOreLocalization.add_vadd","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : AddMonoid R\nS : AddSubmonoid R\ninst✝¹ : AddOreLocalization.AddOreSet S\nX : Type u_2\ninst✝ : AddAction R X\nx y : AddOreLocalization S R\nz : AddOreLocalization S X\n⊢ Eq (HVAdd.hVAdd (HAdd.hAdd x y) z) (HVAdd.hVAdd x (HVAdd.hVAdd y z))","decl":"@[to_additive]\nprotected theorem mul_smul (x y : R[S⁻¹]) (z : X[S⁻¹]) : (x * y) • z = x • y • z := by\n  -- Porting note: `assoc_rw` was not ported yet\n  induction' x with r₁ s₁\n  induction' y with r₂ s₂\n  induction' z with r₃ s₃\n  rcases oreDivMulChar' r₁ r₂ s₁ s₂ with ⟨ra, sa, ha, ha'⟩; rw [ha']; clear ha'\n  rcases oreDivSMulChar' r₂ r₃ s₂ s₃ with ⟨rb, sb, hb, hb'⟩; rw [hb']; clear hb'\n  rcases oreCondition ra sb with ⟨rc, sc, hc⟩\n  rw [oreDiv_smul_char (ra * r₂) r₃ (sa * s₁) s₃ (rc * rb) sc]; swap\n  · rw [← mul_assoc _ ra, hc, mul_assoc, hb, ← mul_assoc]\n  rw [← mul_assoc, mul_smul]\n  symm; apply oreDiv_smul_char\n  rw [Submonoid.coe_mul, Submonoid.coe_mul, ← mul_assoc, ← hc, mul_assoc _ ra, ← ha, mul_assoc]\n\n"}
{"name":"OreLocalization.mul_smul","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : Monoid R\nS : Submonoid R\ninst✝¹ : OreLocalization.OreSet S\nX : Type u_2\ninst✝ : MulAction R X\nx y : OreLocalization S R\nz : OreLocalization S X\n⊢ Eq (HSMul.hSMul (HMul.hMul x y) z) (HSMul.hSMul x (HSMul.hSMul y z))","decl":"@[to_additive]\nprotected theorem mul_smul (x y : R[S⁻¹]) (z : X[S⁻¹]) : (x * y) • z = x • y • z := by\n  -- Porting note: `assoc_rw` was not ported yet\n  induction' x with r₁ s₁\n  induction' y with r₂ s₂\n  induction' z with r₃ s₃\n  rcases oreDivMulChar' r₁ r₂ s₁ s₂ with ⟨ra, sa, ha, ha'⟩; rw [ha']; clear ha'\n  rcases oreDivSMulChar' r₂ r₃ s₂ s₃ with ⟨rb, sb, hb, hb'⟩; rw [hb']; clear hb'\n  rcases oreCondition ra sb with ⟨rc, sc, hc⟩\n  rw [oreDiv_smul_char (ra * r₂) r₃ (sa * s₁) s₃ (rc * rb) sc]; swap\n  · rw [← mul_assoc _ ra, hc, mul_assoc, hb, ← mul_assoc]\n  rw [← mul_assoc, mul_smul]\n  symm; apply oreDiv_smul_char\n  rw [Submonoid.coe_mul, Submonoid.coe_mul, ← mul_assoc, ← hc, mul_assoc _ ra, ← ha, mul_assoc]\n\n"}
{"name":"OreLocalization.mul_assoc","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Monoid R\nS : Submonoid R\ninst✝ : OreLocalization.OreSet S\nx y z : OreLocalization S R\n⊢ Eq (HMul.hMul (HMul.hMul x y) z) (HMul.hMul x (HMul.hMul y z))","decl":"@[to_additive]\nprotected theorem mul_assoc (x y z : R[S⁻¹]) : x * y * z = x * (y * z) :=\n  OreLocalization.mul_smul x y z\n\n"}
{"name":"AddOreLocalization.add_assoc","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoid R\nS : AddSubmonoid R\ninst✝ : AddOreLocalization.AddOreSet S\nx y z : AddOreLocalization S R\n⊢ Eq (HAdd.hAdd (HAdd.hAdd x y) z) (HAdd.hAdd x (HAdd.hAdd y z))","decl":"@[to_additive]\nprotected theorem mul_assoc (x y z : R[S⁻¹]) : x * y * z = x * (y * z) :=\n  OreLocalization.mul_smul x y z\n\n"}
{"name":"OreLocalization.mul_inv","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Monoid R\nS : Submonoid R\ninst✝ : OreLocalization.OreSet S\ns s' : Subtype fun x => Membership.mem S x\n⊢ Eq (HMul.hMul (OreLocalization.oreDiv (↑s) s') (OreLocalization.oreDiv (↑s') s)) 1","decl":"@[to_additive]\nprotected theorem mul_inv (s s' : S) : ((s : R) /ₒ s') * ((s' : R) /ₒ s) = 1 := by\n  simp [oreDiv_mul_char (s : R) s' s' s 1 1 (by simp)]\n\n"}
{"name":"AddOreLocalization.add_neg","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoid R\nS : AddSubmonoid R\ninst✝ : AddOreLocalization.AddOreSet S\ns s' : Subtype fun x => Membership.mem S x\n⊢ Eq (HAdd.hAdd (AddOreLocalization.oreSub (↑s) s') (AddOreLocalization.oreSub (↑s') s)) 0","decl":"@[to_additive]\nprotected theorem mul_inv (s s' : S) : ((s : R) /ₒ s') * ((s' : R) /ₒ s) = 1 := by\n  simp [oreDiv_mul_char (s : R) s' s' s 1 1 (by simp)]\n\n"}
{"name":"OreLocalization.one_div_smul","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : Monoid R\nS : Submonoid R\ninst✝¹ : OreLocalization.OreSet S\nX : Type u_2\ninst✝ : MulAction R X\nr : X\ns t : Subtype fun x => Membership.mem S x\n⊢ Eq (HSMul.hSMul (OreLocalization.oreDiv 1 t) (OreLocalization.oreDiv r s)) (OreLocalization.oreDiv r (HMul.hMul s t))","decl":"@[to_additive (attr := simp)]\nprotected theorem one_div_smul {r : X} {s t : S} : ((1 : R) /ₒ t) • (r /ₒ s) = r /ₒ (s * t) := by\n  simp [oreDiv_smul_char 1 r t s 1 s (by simp)]\n\n"}
{"name":"AddOreLocalization.zero_sub_vadd","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : AddMonoid R\nS : AddSubmonoid R\ninst✝¹ : AddOreLocalization.AddOreSet S\nX : Type u_2\ninst✝ : AddAction R X\nr : X\ns t : Subtype fun x => Membership.mem S x\n⊢ Eq (HVAdd.hVAdd (AddOreLocalization.oreSub 0 t) (AddOreLocalization.oreSub r s)) (AddOreLocalization.oreSub r (HAdd.hAdd s t))","decl":"@[to_additive (attr := simp)]\nprotected theorem one_div_smul {r : X} {s t : S} : ((1 : R) /ₒ t) • (r /ₒ s) = r /ₒ (s * t) := by\n  simp [oreDiv_smul_char 1 r t s 1 s (by simp)]\n\n"}
{"name":"AddOreLocalization.zero_sub_add","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoid R\nS : AddSubmonoid R\ninst✝ : AddOreLocalization.AddOreSet S\nr : R\ns t : Subtype fun x => Membership.mem S x\n⊢ Eq (HAdd.hAdd (AddOreLocalization.oreSub 0 t) (AddOreLocalization.oreSub r s)) (AddOreLocalization.oreSub r (HAdd.hAdd s t))","decl":"@[to_additive (attr := simp)]\nprotected theorem one_div_mul {r : R} {s t : S} : (1 /ₒ t) * (r /ₒ s) = r /ₒ (s * t) := by\n  simp [oreDiv_mul_char 1 r t s 1 s (by simp)]\n\n"}
{"name":"OreLocalization.one_div_mul","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Monoid R\nS : Submonoid R\ninst✝ : OreLocalization.OreSet S\nr : R\ns t : Subtype fun x => Membership.mem S x\n⊢ Eq (HMul.hMul (OreLocalization.oreDiv 1 t) (OreLocalization.oreDiv r s)) (OreLocalization.oreDiv r (HMul.hMul s t))","decl":"@[to_additive (attr := simp)]\nprotected theorem one_div_mul {r : R} {s t : S} : (1 /ₒ t) * (r /ₒ s) = r /ₒ (s * t) := by\n  simp [oreDiv_mul_char 1 r t s 1 s (by simp)]\n\n"}
{"name":"AddOreLocalization.vadd_cancel","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : AddMonoid R\nS : AddSubmonoid R\ninst✝¹ : AddOreLocalization.AddOreSet S\nX : Type u_2\ninst✝ : AddAction R X\nr : X\ns t : Subtype fun x => Membership.mem S x\n⊢ Eq (HVAdd.hVAdd (AddOreLocalization.oreSub (↑s) t) (AddOreLocalization.oreSub r s)) (AddOreLocalization.oreSub r t)","decl":"@[to_additive (attr := simp)]\nprotected theorem smul_cancel {r : X} {s t : S} : ((s : R) /ₒ t) • (r /ₒ s) = r /ₒ t := by\n  simp [oreDiv_smul_char s.1 r t s 1 1 (by simp)]\n\n"}
{"name":"OreLocalization.smul_cancel","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : Monoid R\nS : Submonoid R\ninst✝¹ : OreLocalization.OreSet S\nX : Type u_2\ninst✝ : MulAction R X\nr : X\ns t : Subtype fun x => Membership.mem S x\n⊢ Eq (HSMul.hSMul (OreLocalization.oreDiv (↑s) t) (OreLocalization.oreDiv r s)) (OreLocalization.oreDiv r t)","decl":"@[to_additive (attr := simp)]\nprotected theorem smul_cancel {r : X} {s t : S} : ((s : R) /ₒ t) • (r /ₒ s) = r /ₒ t := by\n  simp [oreDiv_smul_char s.1 r t s 1 1 (by simp)]\n\n"}
{"name":"AddOreLocalization.add_cancel","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoid R\nS : AddSubmonoid R\ninst✝ : AddOreLocalization.AddOreSet S\nr : R\ns t : Subtype fun x => Membership.mem S x\n⊢ Eq (HAdd.hAdd (AddOreLocalization.oreSub (↑s) t) (AddOreLocalization.oreSub r s)) (AddOreLocalization.oreSub r t)","decl":"@[to_additive (attr := simp)]\nprotected theorem mul_cancel {r : R} {s t : S} : ((s : R) /ₒ t) * (r /ₒ s) = r /ₒ t := by\n  simp [oreDiv_mul_char s.1 r t s 1 1 (by simp)]\n\n"}
{"name":"OreLocalization.mul_cancel","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Monoid R\nS : Submonoid R\ninst✝ : OreLocalization.OreSet S\nr : R\ns t : Subtype fun x => Membership.mem S x\n⊢ Eq (HMul.hMul (OreLocalization.oreDiv (↑s) t) (OreLocalization.oreDiv r s)) (OreLocalization.oreDiv r t)","decl":"@[to_additive (attr := simp)]\nprotected theorem mul_cancel {r : R} {s t : S} : ((s : R) /ₒ t) * (r /ₒ s) = r /ₒ t := by\n  simp [oreDiv_mul_char s.1 r t s 1 1 (by simp)]\n\n"}
{"name":"OreLocalization.smul_cancel'","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : Monoid R\nS : Submonoid R\ninst✝¹ : OreLocalization.OreSet S\nX : Type u_2\ninst✝ : MulAction R X\nr₁ : R\nr₂ : X\ns t : Subtype fun x => Membership.mem S x\n⊢ Eq (HSMul.hSMul (OreLocalization.oreDiv (HMul.hMul r₁ ↑s) t) (OreLocalization.oreDiv r₂ s)) (OreLocalization.oreDiv (HSMul.hSMul r₁ r₂) t)","decl":"@[to_additive (attr := simp)]\nprotected theorem smul_cancel' {r₁ : R} {r₂ : X} {s t : S} :\n    ((r₁ * s) /ₒ t) • (r₂ /ₒ s) = (r₁ • r₂) /ₒ t := by\n  simp [oreDiv_smul_char (r₁ * s) r₂ t s r₁ 1 (by simp)]\n\n"}
{"name":"AddOreLocalization.vadd_cancel'","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : AddMonoid R\nS : AddSubmonoid R\ninst✝¹ : AddOreLocalization.AddOreSet S\nX : Type u_2\ninst✝ : AddAction R X\nr₁ : R\nr₂ : X\ns t : Subtype fun x => Membership.mem S x\n⊢ Eq (HVAdd.hVAdd (AddOreLocalization.oreSub (HAdd.hAdd r₁ ↑s) t) (AddOreLocalization.oreSub r₂ s)) (AddOreLocalization.oreSub (HVAdd.hVAdd r₁ r₂) t)","decl":"@[to_additive (attr := simp)]\nprotected theorem smul_cancel' {r₁ : R} {r₂ : X} {s t : S} :\n    ((r₁ * s) /ₒ t) • (r₂ /ₒ s) = (r₁ • r₂) /ₒ t := by\n  simp [oreDiv_smul_char (r₁ * s) r₂ t s r₁ 1 (by simp)]\n\n"}
{"name":"OreLocalization.mul_cancel'","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Monoid R\nS : Submonoid R\ninst✝ : OreLocalization.OreSet S\nr₁ r₂ : R\ns t : Subtype fun x => Membership.mem S x\n⊢ Eq (HMul.hMul (OreLocalization.oreDiv (HMul.hMul r₁ ↑s) t) (OreLocalization.oreDiv r₂ s)) (OreLocalization.oreDiv (HMul.hMul r₁ r₂) t)","decl":"@[to_additive (attr := simp)]\nprotected theorem mul_cancel' {r₁ r₂ : R} {s t : S} :\n    ((r₁ * s) /ₒ t) * (r₂ /ₒ s) = (r₁ * r₂) /ₒ t := by\n  simp [oreDiv_mul_char (r₁ * s) r₂ t s r₁ 1 (by simp)]\n\n"}
{"name":"AddOreLocalization.add_cancel'","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoid R\nS : AddSubmonoid R\ninst✝ : AddOreLocalization.AddOreSet S\nr₁ r₂ : R\ns t : Subtype fun x => Membership.mem S x\n⊢ Eq (HAdd.hAdd (AddOreLocalization.oreSub (HAdd.hAdd r₁ ↑s) t) (AddOreLocalization.oreSub r₂ s)) (AddOreLocalization.oreSub (HAdd.hAdd r₁ r₂) t)","decl":"@[to_additive (attr := simp)]\nprotected theorem mul_cancel' {r₁ r₂ : R} {s t : S} :\n    ((r₁ * s) /ₒ t) * (r₂ /ₒ s) = (r₁ * r₂) /ₒ t := by\n  simp [oreDiv_mul_char (r₁ * s) r₂ t s r₁ 1 (by simp)]\n\n"}
{"name":"AddOreLocalization.vadd_sub_zero","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : AddMonoid R\nS : AddSubmonoid R\ninst✝¹ : AddOreLocalization.AddOreSet S\nX : Type u_2\ninst✝ : AddAction R X\np : R\nr : X\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (HVAdd.hVAdd (AddOreLocalization.oreSub p s) (AddOreLocalization.oreSub r 0)) (AddOreLocalization.oreSub (HVAdd.hVAdd p r) s)","decl":"@[to_additive (attr := simp)]\ntheorem smul_div_one {p : R} {r : X} {s : S} : (p /ₒ s) • (r /ₒ 1) = (p • r) /ₒ s := by\n  simp [oreDiv_smul_char p r s 1 p 1 (by simp)]\n\n"}
{"name":"OreLocalization.smul_div_one","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : Monoid R\nS : Submonoid R\ninst✝¹ : OreLocalization.OreSet S\nX : Type u_2\ninst✝ : MulAction R X\np : R\nr : X\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (HSMul.hSMul (OreLocalization.oreDiv p s) (OreLocalization.oreDiv r 1)) (OreLocalization.oreDiv (HSMul.hSMul p r) s)","decl":"@[to_additive (attr := simp)]\ntheorem smul_div_one {p : R} {r : X} {s : S} : (p /ₒ s) • (r /ₒ 1) = (p • r) /ₒ s := by\n  simp [oreDiv_smul_char p r s 1 p 1 (by simp)]\n\n"}
{"name":"AddOreLocalization.add_sub_zero","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoid R\nS : AddSubmonoid R\ninst✝ : AddOreLocalization.AddOreSet S\np r : R\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (HAdd.hAdd (AddOreLocalization.oreSub p s) (AddOreLocalization.oreSub r 0)) (AddOreLocalization.oreSub (HAdd.hAdd p r) s)","decl":"@[to_additive (attr := simp)]\ntheorem mul_div_one {p r : R} {s : S} : (p /ₒ s) * (r /ₒ 1) = (p * r) /ₒ s := by\n  --TODO use coercion r ↦ r /ₒ 1\n  simp [oreDiv_mul_char p r s 1 p 1 (by simp)]\n\n"}
{"name":"OreLocalization.mul_div_one","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Monoid R\nS : Submonoid R\ninst✝ : OreLocalization.OreSet S\np r : R\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (HMul.hMul (OreLocalization.oreDiv p s) (OreLocalization.oreDiv r 1)) (OreLocalization.oreDiv (HMul.hMul p r) s)","decl":"@[to_additive (attr := simp)]\ntheorem mul_div_one {p r : R} {s : S} : (p /ₒ s) * (r /ₒ 1) = (p * r) /ₒ s := by\n  --TODO use coercion r ↦ r /ₒ 1\n  simp [oreDiv_mul_char p r s 1 p 1 (by simp)]\n\n"}
{"name":"OreLocalization.numeratorHom_apply","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Monoid R\nS : Submonoid R\ninst✝ : OreLocalization.OreSet S\nr : R\n⊢ Eq (OreLocalization.numeratorHom r) (OreLocalization.oreDiv r 1)","decl":"@[to_additive]\ntheorem numeratorHom_apply {r : R} : numeratorHom r = r /ₒ (1 : S) :=\n  rfl\n\n"}
{"name":"AddOreLocalization.numeratorHom_apply","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoid R\nS : AddSubmonoid R\ninst✝ : AddOreLocalization.AddOreSet S\nr : R\n⊢ Eq (AddOreLocalization.numeratorHom r) (AddOreLocalization.oreSub r 0)","decl":"@[to_additive]\ntheorem numeratorHom_apply {r : R} : numeratorHom r = r /ₒ (1 : S) :=\n  rfl\n\n"}
{"name":"OreLocalization.numerator_isUnit","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Monoid R\nS : Submonoid R\ninst✝ : OreLocalization.OreSet S\ns : Subtype fun x => Membership.mem S x\n⊢ IsUnit (OreLocalization.numeratorHom ↑s)","decl":"@[to_additive]\ntheorem numerator_isUnit (s : S) : IsUnit (numeratorHom (s : R) : R[S⁻¹]) :=\n  ⟨numeratorUnit s, rfl⟩\n\n"}
{"name":"AddOreLocalization.numerator_isAddUnit","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoid R\nS : AddSubmonoid R\ninst✝ : AddOreLocalization.AddOreSet S\ns : Subtype fun x => Membership.mem S x\n⊢ IsAddUnit (AddOreLocalization.numeratorHom ↑s)","decl":"@[to_additive]\ntheorem numerator_isUnit (s : S) : IsUnit (numeratorHom (s : R) : R[S⁻¹]) :=\n  ⟨numeratorUnit s, rfl⟩\n\n"}
{"name":"AddOreLocalization.universalAddHom_apply","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : AddMonoid R\nS : AddSubmonoid R\ninst✝¹ : AddOreLocalization.AddOreSet S\nT : Type u_2\ninst✝ : AddMonoid T\nf : AddMonoidHom R T\nfS : AddMonoidHom (Subtype fun x => Membership.mem S x) (AddUnits T)\nhf : ∀ (s : Subtype fun x => Membership.mem S x), Eq (f ↑s) ↑(fS s)\nr : R\ns : Subtype fun x => Membership.mem S x\n⊢ Eq ((AddOreLocalization.universalAddHom f fS hf) (AddOreLocalization.oreSub r s)) (HAdd.hAdd (↑(Neg.neg (fS s))) (f r))","decl":"@[to_additive]\ntheorem universalMulHom_apply {r : R} {s : S} :\n    universalMulHom f fS hf (r /ₒ s) = ((fS s)⁻¹ : Units T) * f r :=\n  rfl\n\n"}
{"name":"OreLocalization.universalMulHom_apply","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : Monoid R\nS : Submonoid R\ninst✝¹ : OreLocalization.OreSet S\nT : Type u_2\ninst✝ : Monoid T\nf : MonoidHom R T\nfS : MonoidHom (Subtype fun x => Membership.mem S x) (Units T)\nhf : ∀ (s : Subtype fun x => Membership.mem S x), Eq (f ↑s) ↑(fS s)\nr : R\ns : Subtype fun x => Membership.mem S x\n⊢ Eq ((OreLocalization.universalMulHom f fS hf) (OreLocalization.oreDiv r s)) (HMul.hMul (↑(Inv.inv (fS s))) (f r))","decl":"@[to_additive]\ntheorem universalMulHom_apply {r : R} {s : S} :\n    universalMulHom f fS hf (r /ₒ s) = ((fS s)⁻¹ : Units T) * f r :=\n  rfl\n\n"}
{"name":"OreLocalization.universalMulHom_commutes","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : Monoid R\nS : Submonoid R\ninst✝¹ : OreLocalization.OreSet S\nT : Type u_2\ninst✝ : Monoid T\nf : MonoidHom R T\nfS : MonoidHom (Subtype fun x => Membership.mem S x) (Units T)\nhf : ∀ (s : Subtype fun x => Membership.mem S x), Eq (f ↑s) ↑(fS s)\nr : R\n⊢ Eq ((OreLocalization.universalMulHom f fS hf) (OreLocalization.numeratorHom r)) (f r)","decl":"@[to_additive]\ntheorem universalMulHom_commutes {r : R} : universalMulHom f fS hf (numeratorHom r) = f r := by\n  simp [numeratorHom_apply, universalMulHom_apply]\n\n"}
{"name":"AddOreLocalization.universalAddHom_commutes","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : AddMonoid R\nS : AddSubmonoid R\ninst✝¹ : AddOreLocalization.AddOreSet S\nT : Type u_2\ninst✝ : AddMonoid T\nf : AddMonoidHom R T\nfS : AddMonoidHom (Subtype fun x => Membership.mem S x) (AddUnits T)\nhf : ∀ (s : Subtype fun x => Membership.mem S x), Eq (f ↑s) ↑(fS s)\nr : R\n⊢ Eq ((AddOreLocalization.universalAddHom f fS hf) (AddOreLocalization.numeratorHom r)) (f r)","decl":"@[to_additive]\ntheorem universalMulHom_commutes {r : R} : universalMulHom f fS hf (numeratorHom r) = f r := by\n  simp [numeratorHom_apply, universalMulHom_apply]\n\n"}
{"name":"OreLocalization.universalMulHom_unique","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : Monoid R\nS : Submonoid R\ninst✝¹ : OreLocalization.OreSet S\nT : Type u_2\ninst✝ : Monoid T\nf : MonoidHom R T\nfS : MonoidHom (Subtype fun x => Membership.mem S x) (Units T)\nhf : ∀ (s : Subtype fun x => Membership.mem S x), Eq (f ↑s) ↑(fS s)\nφ : MonoidHom (OreLocalization S R) T\nhuniv : ∀ (r : R), Eq (φ (OreLocalization.numeratorHom r)) (f r)\n⊢ Eq φ (OreLocalization.universalMulHom f fS hf)","decl":"/-- The universal morphism `universalMulHom` is unique. -/\n@[to_additive \"The universal morphism `universalAddHom` is unique.\"]\ntheorem universalMulHom_unique (φ : R[S⁻¹] →* T) (huniv : ∀ r : R, φ (numeratorHom r) = f r) :\n    φ = universalMulHom f fS hf := by\n  ext x; induction' x with r s\n  rw [universalMulHom_apply, ← huniv r, numeratorHom_apply, ← one_mul (φ (r /ₒ s)), ←\n    Units.val_one, ← inv_mul_cancel (fS s), Units.val_mul, mul_assoc, ← hf, ← huniv, ← φ.map_mul,\n    numeratorHom_apply, OreLocalization.mul_cancel]\n\n"}
{"name":"AddOreLocalization.universalAddHom_unique","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝² : AddMonoid R\nS : AddSubmonoid R\ninst✝¹ : AddOreLocalization.AddOreSet S\nT : Type u_2\ninst✝ : AddMonoid T\nf : AddMonoidHom R T\nfS : AddMonoidHom (Subtype fun x => Membership.mem S x) (AddUnits T)\nhf : ∀ (s : Subtype fun x => Membership.mem S x), Eq (f ↑s) ↑(fS s)\nφ : AddMonoidHom (AddOreLocalization S R) T\nhuniv : ∀ (r : R), Eq (φ (AddOreLocalization.numeratorHom r)) (f r)\n⊢ Eq φ (AddOreLocalization.universalAddHom f fS hf)","decl":"/-- The universal morphism `universalMulHom` is unique. -/\n@[to_additive \"The universal morphism `universalAddHom` is unique.\"]\ntheorem universalMulHom_unique (φ : R[S⁻¹] →* T) (huniv : ∀ r : R, φ (numeratorHom r) = f r) :\n    φ = universalMulHom f fS hf := by\n  ext x; induction' x with r s\n  rw [universalMulHom_apply, ← huniv r, numeratorHom_apply, ← one_mul (φ (r /ₒ s)), ←\n    Units.val_one, ← inv_mul_cancel (fS s), Units.val_mul, mul_assoc, ← hf, ← huniv, ← φ.map_mul,\n    numeratorHom_apply, OreLocalization.mul_cancel]\n\n"}
{"name":"OreLocalization.smul_oreDiv","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\nM : Type u_3\nX : Type u_4\ninst✝⁶ : Monoid M\nS : Submonoid M\ninst✝⁵ : OreLocalization.OreSet S\ninst✝⁴ : MulAction M X\ninst✝³ : SMul R X\ninst✝² : SMul R M\ninst✝¹ : IsScalarTower R M M\ninst✝ : IsScalarTower R M X\nr : R\nx : X\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (HSMul.hSMul r (OreLocalization.oreDiv x s)) (OreLocalization.oreDiv (HSMul.hSMul (OreLocalization.oreNum (HSMul.hSMul r 1) s) x) (OreLocalization.oreDenom (HSMul.hSMul r 1) s))","decl":"@[to_additive]\ntheorem smul_oreDiv (r : R) (x : X) (s : S) :\n    r • (x /ₒ s) = oreNum (r • 1) s • x /ₒ oreDenom (r • 1) s := by with_unfolding_all rfl\n\n"}
{"name":"AddOreLocalization.vadd_oreSub","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\nM : Type u_3\nX : Type u_4\ninst✝⁶ : AddMonoid M\nS : AddSubmonoid M\ninst✝⁵ : AddOreLocalization.AddOreSet S\ninst✝⁴ : AddAction M X\ninst✝³ : VAdd R X\ninst✝² : VAdd R M\ninst✝¹ : VAddAssocClass R M M\ninst✝ : VAddAssocClass R M X\nr : R\nx : X\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (HVAdd.hVAdd r (AddOreLocalization.oreSub x s)) (AddOreLocalization.oreSub (HVAdd.hVAdd (AddOreLocalization.oreMin (HVAdd.hVAdd r 0) s) x) (AddOreLocalization.oreSubtra (HVAdd.hVAdd r 0) s))","decl":"@[to_additive]\ntheorem smul_oreDiv (r : R) (x : X) (s : S) :\n    r • (x /ₒ s) = oreNum (r • 1) s • x /ₒ oreDenom (r • 1) s := by with_unfolding_all rfl\n\n"}
{"name":"OreLocalization.oreDiv_one_smul","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"M : Type u_3\nX : Type u_4\ninst✝² : Monoid M\nS : Submonoid M\ninst✝¹ : OreLocalization.OreSet S\ninst✝ : MulAction M X\nr : M\nx : OreLocalization S X\n⊢ Eq (HSMul.hSMul (OreLocalization.oreDiv r 1) x) (HSMul.hSMul r x)","decl":"@[to_additive (attr := simp)]\ntheorem oreDiv_one_smul (r : M) (x : X[S⁻¹]) : (r /ₒ (1 : S)) • x = r • x := by\n  induction' x using OreLocalization.ind with r' s\n  rw [smul_oreDiv, oreDiv_smul_oreDiv, mul_one, smul_eq_mul, mul_one]\n\n"}
{"name":"AddOreLocalization.oreSub_zero_vadd","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"M : Type u_3\nX : Type u_4\ninst✝² : AddMonoid M\nS : AddSubmonoid M\ninst✝¹ : AddOreLocalization.AddOreSet S\ninst✝ : AddAction M X\nr : M\nx : AddOreLocalization S X\n⊢ Eq (HVAdd.hVAdd (AddOreLocalization.oreSub r 0) x) (HVAdd.hVAdd r x)","decl":"@[to_additive (attr := simp)]\ntheorem oreDiv_one_smul (r : M) (x : X[S⁻¹]) : (r /ₒ (1 : S)) • x = r • x := by\n  induction' x using OreLocalization.ind with r' s\n  rw [smul_oreDiv, oreDiv_smul_oreDiv, mul_one, smul_eq_mul, mul_one]\n\n"}
{"name":"AddOreLocalization.vadd_zero_vadd","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\nM : Type u_3\nX : Type u_4\ninst✝⁶ : AddMonoid M\nS : AddSubmonoid M\ninst✝⁵ : AddOreLocalization.AddOreSet S\ninst✝⁴ : AddAction M X\ninst✝³ : VAdd R X\ninst✝² : VAdd R M\ninst✝¹ : VAddAssocClass R M M\ninst✝ : VAddAssocClass R M X\nr : R\nx : AddOreLocalization S X\n⊢ Eq (HVAdd.hVAdd (HVAdd.hVAdd r 0) x) (HVAdd.hVAdd r x)","decl":"@[to_additive]\ntheorem smul_one_smul (r : R) (x : X[S⁻¹]) : (r • 1 : M) • x = r • x := by\n  induction' x using OreLocalization.ind with r' s\n  simp only [smul_oreDiv, smul_eq_mul, mul_one]\n\n"}
{"name":"OreLocalization.smul_one_smul","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\nM : Type u_3\nX : Type u_4\ninst✝⁶ : Monoid M\nS : Submonoid M\ninst✝⁵ : OreLocalization.OreSet S\ninst✝⁴ : MulAction M X\ninst✝³ : SMul R X\ninst✝² : SMul R M\ninst✝¹ : IsScalarTower R M M\ninst✝ : IsScalarTower R M X\nr : R\nx : OreLocalization S X\n⊢ Eq (HSMul.hSMul (HSMul.hSMul r 1) x) (HSMul.hSMul r x)","decl":"@[to_additive]\ntheorem smul_one_smul (r : R) (x : X[S⁻¹]) : (r • 1 : M) • x = r • x := by\n  induction' x using OreLocalization.ind with r' s\n  simp only [smul_oreDiv, smul_eq_mul, mul_one]\n\n"}
{"name":"OreLocalization.smul_one_oreDiv_one_smul","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\nM : Type u_3\nX : Type u_4\ninst✝⁶ : Monoid M\nS : Submonoid M\ninst✝⁵ : OreLocalization.OreSet S\ninst✝⁴ : MulAction M X\ninst✝³ : SMul R X\ninst✝² : SMul R M\ninst✝¹ : IsScalarTower R M M\ninst✝ : IsScalarTower R M X\nr : R\nx : OreLocalization S X\n⊢ Eq (HSMul.hSMul (OreLocalization.oreDiv (HSMul.hSMul r 1) 1) x) (HSMul.hSMul r x)","decl":"@[to_additive]\ntheorem smul_one_oreDiv_one_smul (r : R) (x : X[S⁻¹]) :\n    ((r • 1 : M) /ₒ (1 : S)) • x = r • x := by\n  rw [oreDiv_one_smul, smul_one_smul]\n\n"}
{"name":"AddOreLocalization.vadd_zero_oreSub_zero_vadd","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\nM : Type u_3\nX : Type u_4\ninst✝⁶ : AddMonoid M\nS : AddSubmonoid M\ninst✝⁵ : AddOreLocalization.AddOreSet S\ninst✝⁴ : AddAction M X\ninst✝³ : VAdd R X\ninst✝² : VAdd R M\ninst✝¹ : VAddAssocClass R M M\ninst✝ : VAddAssocClass R M X\nr : R\nx : AddOreLocalization S X\n⊢ Eq (HVAdd.hVAdd (AddOreLocalization.oreSub (HVAdd.hVAdd r 0) 0) x) (HVAdd.hVAdd r x)","decl":"@[to_additive]\ntheorem smul_one_oreDiv_one_smul (r : R) (x : X[S⁻¹]) :\n    ((r • 1 : M) /ₒ (1 : S)) • x = r • x := by\n  rw [oreDiv_one_smul, smul_one_smul]\n\n"}
{"name":"AddOreLocalization.instIsScalarTower","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\nR' : Type u_2\nM : Type u_3\nX : Type u_4\ninst✝¹¹ : AddMonoid M\nS : AddSubmonoid M\ninst✝¹⁰ : AddOreLocalization.AddOreSet S\ninst✝⁹ : AddAction M X\ninst✝⁸ : VAdd R X\ninst✝⁷ : VAdd R M\ninst✝⁶ : VAddAssocClass R M M\ninst✝⁵ : VAddAssocClass R M X\ninst✝⁴ : VAdd R' X\ninst✝³ : VAdd R' M\ninst✝² : VAddAssocClass R' M M\ninst✝¹ : VAddAssocClass R' M X\ninst✝ : VAdd R R'\n⊢ VAddAssocClass R R' (AddOreLocalization S X)","decl":"@[to_additive]\ninstance : IsScalarTower R R' X[S⁻¹] where\n  smul_assoc r m x := by\n    rw [← smul_one_oreDiv_one_smul, ← smul_one_oreDiv_one_smul, ← smul_one_oreDiv_one_smul,\n      ← mul_smul, mul_div_one]\n    simp only [smul_eq_mul, mul_one, smul_mul_assoc, smul_assoc, one_mul]\n\n"}
{"name":"OreLocalization.instIsScalarTower","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\nR' : Type u_2\nM : Type u_3\nX : Type u_4\ninst✝¹¹ : Monoid M\nS : Submonoid M\ninst✝¹⁰ : OreLocalization.OreSet S\ninst✝⁹ : MulAction M X\ninst✝⁸ : SMul R X\ninst✝⁷ : SMul R M\ninst✝⁶ : IsScalarTower R M M\ninst✝⁵ : IsScalarTower R M X\ninst✝⁴ : SMul R' X\ninst✝³ : SMul R' M\ninst✝² : IsScalarTower R' M M\ninst✝¹ : IsScalarTower R' M X\ninst✝ : SMul R R'\n⊢ IsScalarTower R R' (OreLocalization S X)","decl":"@[to_additive]\ninstance : IsScalarTower R R' X[S⁻¹] where\n  smul_assoc r m x := by\n    rw [← smul_one_oreDiv_one_smul, ← smul_one_oreDiv_one_smul, ← smul_one_oreDiv_one_smul,\n      ← mul_smul, mul_div_one]\n    simp only [smul_eq_mul, mul_one, smul_mul_assoc, smul_assoc, one_mul]\n\n"}
{"name":"AddOreLocalization.instVAddCommClass","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\nR' : Type u_2\nM : Type u_3\nX : Type u_4\ninst✝¹¹ : AddMonoid M\nS : AddSubmonoid M\ninst✝¹⁰ : AddOreLocalization.AddOreSet S\ninst✝⁹ : AddAction M X\ninst✝⁸ : VAdd R X\ninst✝⁷ : VAdd R M\ninst✝⁶ : VAddAssocClass R M M\ninst✝⁵ : VAddAssocClass R M X\ninst✝⁴ : VAdd R' X\ninst✝³ : VAdd R' M\ninst✝² : VAddAssocClass R' M M\ninst✝¹ : VAddAssocClass R' M X\ninst✝ : VAddCommClass R R' M\n⊢ VAddCommClass R R' (AddOreLocalization S X)","decl":"@[to_additive]\ninstance [SMulCommClass R R' M] : SMulCommClass R R' X[S⁻¹] where\n  smul_comm r m x := by\n    rw [← smul_one_smul m, ← smul_assoc, smul_comm, smul_assoc, smul_one_smul]\n\n"}
{"name":"OreLocalization.instSMulCommClass","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\nR' : Type u_2\nM : Type u_3\nX : Type u_4\ninst✝¹¹ : Monoid M\nS : Submonoid M\ninst✝¹⁰ : OreLocalization.OreSet S\ninst✝⁹ : MulAction M X\ninst✝⁸ : SMul R X\ninst✝⁷ : SMul R M\ninst✝⁶ : IsScalarTower R M M\ninst✝⁵ : IsScalarTower R M X\ninst✝⁴ : SMul R' X\ninst✝³ : SMul R' M\ninst✝² : IsScalarTower R' M M\ninst✝¹ : IsScalarTower R' M X\ninst✝ : SMulCommClass R R' M\n⊢ SMulCommClass R R' (OreLocalization S X)","decl":"@[to_additive]\ninstance [SMulCommClass R R' M] : SMulCommClass R R' X[S⁻¹] where\n  smul_comm r m x := by\n    rw [← smul_one_smul m, ← smul_assoc, smul_comm, smul_assoc, smul_one_smul]\n\n"}
{"name":"OreLocalization.instIsScalarTower_1","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\nM : Type u_3\nX : Type u_4\ninst✝⁶ : Monoid M\nS : Submonoid M\ninst✝⁵ : OreLocalization.OreSet S\ninst✝⁴ : MulAction M X\ninst✝³ : SMul R X\ninst✝² : SMul R M\ninst✝¹ : IsScalarTower R M M\ninst✝ : IsScalarTower R M X\n⊢ IsScalarTower R (OreLocalization S M) (OreLocalization S X)","decl":"@[to_additive]\ninstance : IsScalarTower R M[S⁻¹] X[S⁻¹] where\n  smul_assoc r m x := by\n    rw [← smul_one_oreDiv_one_smul, ← smul_one_oreDiv_one_smul, ← mul_smul, smul_eq_mul]\n\n"}
{"name":"AddOreLocalization.instIsScalarTower_1","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\nM : Type u_3\nX : Type u_4\ninst✝⁶ : AddMonoid M\nS : AddSubmonoid M\ninst✝⁵ : AddOreLocalization.AddOreSet S\ninst✝⁴ : AddAction M X\ninst✝³ : VAdd R X\ninst✝² : VAdd R M\ninst✝¹ : VAddAssocClass R M M\ninst✝ : VAddAssocClass R M X\n⊢ VAddAssocClass R (AddOreLocalization S M) (AddOreLocalization S X)","decl":"@[to_additive]\ninstance : IsScalarTower R M[S⁻¹] X[S⁻¹] where\n  smul_assoc r m x := by\n    rw [← smul_one_oreDiv_one_smul, ← smul_one_oreDiv_one_smul, ← mul_smul, smul_eq_mul]\n\n"}
{"name":"OreLocalization.instSMulCommClass_1","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\nM : Type u_3\nX : Type u_4\ninst✝⁷ : Monoid M\nS : Submonoid M\ninst✝⁶ : OreLocalization.OreSet S\ninst✝⁵ : MulAction M X\ninst✝⁴ : SMul R X\ninst✝³ : SMul R M\ninst✝² : IsScalarTower R M M\ninst✝¹ : IsScalarTower R M X\ninst✝ : SMulCommClass R M M\n⊢ SMulCommClass R (OreLocalization S M) (OreLocalization S X)","decl":"@[to_additive]\ninstance [SMulCommClass R M M] : SMulCommClass R M[S⁻¹] X[S⁻¹] where\n  smul_comm r x y := by\n    induction' x using OreLocalization.ind with r₁ s₁\n    induction' y using OreLocalization.ind with r₂ s₂\n    rw [← smul_one_oreDiv_one_smul, ← smul_one_oreDiv_one_smul, smul_smul, smul_smul,\n      mul_div_one, oreDiv_mul_char _ _ _ _ (r • 1) s₁ (by simp), mul_one]\n    simp\n\n"}
{"name":"AddOreLocalization.instVAddCommClass_1","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\nM : Type u_3\nX : Type u_4\ninst✝⁷ : AddMonoid M\nS : AddSubmonoid M\ninst✝⁶ : AddOreLocalization.AddOreSet S\ninst✝⁵ : AddAction M X\ninst✝⁴ : VAdd R X\ninst✝³ : VAdd R M\ninst✝² : VAddAssocClass R M M\ninst✝¹ : VAddAssocClass R M X\ninst✝ : VAddCommClass R M M\n⊢ VAddCommClass R (AddOreLocalization S M) (AddOreLocalization S X)","decl":"@[to_additive]\ninstance [SMulCommClass R M M] : SMulCommClass R M[S⁻¹] X[S⁻¹] where\n  smul_comm r x y := by\n    induction' x using OreLocalization.ind with r₁ s₁\n    induction' y using OreLocalization.ind with r₂ s₂\n    rw [← smul_one_oreDiv_one_smul, ← smul_one_oreDiv_one_smul, smul_smul, smul_smul,\n      mul_div_one, oreDiv_mul_char _ _ _ _ (r • 1) s₁ (by simp), mul_one]\n    simp\n\n"}
{"name":"OreLocalization.instIsCentralScalar","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\nM : Type u_3\nX : Type u_4\ninst✝¹¹ : Monoid M\nS : Submonoid M\ninst✝¹⁰ : OreLocalization.OreSet S\ninst✝⁹ : MulAction M X\ninst✝⁸ : SMul R X\ninst✝⁷ : SMul R M\ninst✝⁶ : IsScalarTower R M M\ninst✝⁵ : IsScalarTower R M X\ninst✝⁴ : SMul (MulOpposite R) M\ninst✝³ : SMul (MulOpposite R) X\ninst✝² : IsScalarTower (MulOpposite R) M M\ninst✝¹ : IsScalarTower (MulOpposite R) M X\ninst✝ : IsCentralScalar R M\n⊢ IsCentralScalar R (OreLocalization S X)","decl":"@[to_additive]\ninstance [SMul Rᵐᵒᵖ M] [SMul Rᵐᵒᵖ X] [IsScalarTower Rᵐᵒᵖ M M] [IsScalarTower Rᵐᵒᵖ M X]\n  [IsCentralScalar R M] : IsCentralScalar R X[S⁻¹] where\n  op_smul_eq_smul r x := by\n    rw [← smul_one_oreDiv_one_smul, ← smul_one_oreDiv_one_smul, op_smul_eq_smul]\n\n"}
{"name":"AddOreLocalization.instIsCentralVAdd","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\nM : Type u_3\nX : Type u_4\ninst✝¹¹ : AddMonoid M\nS : AddSubmonoid M\ninst✝¹⁰ : AddOreLocalization.AddOreSet S\ninst✝⁹ : AddAction M X\ninst✝⁸ : VAdd R X\ninst✝⁷ : VAdd R M\ninst✝⁶ : VAddAssocClass R M M\ninst✝⁵ : VAddAssocClass R M X\ninst✝⁴ : VAdd (AddOpposite R) M\ninst✝³ : VAdd (AddOpposite R) X\ninst✝² : VAddAssocClass (AddOpposite R) M M\ninst✝¹ : VAddAssocClass (AddOpposite R) M X\ninst✝ : IsCentralVAdd R M\n⊢ IsCentralVAdd R (AddOreLocalization S X)","decl":"@[to_additive]\ninstance [SMul Rᵐᵒᵖ M] [SMul Rᵐᵒᵖ X] [IsScalarTower Rᵐᵒᵖ M M] [IsScalarTower Rᵐᵒᵖ M X]\n  [IsCentralScalar R M] : IsCentralScalar R X[S⁻¹] where\n  op_smul_eq_smul r x := by\n    rw [← smul_one_oreDiv_one_smul, ← smul_one_oreDiv_one_smul, op_smul_eq_smul]\n\n"}
{"name":"AddOreLocalization.vadd_oreSub_zero","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\nM : Type u_3\nX : Type u_4\ninst✝⁶ : AddMonoid M\nS : AddSubmonoid M\ninst✝⁵ : AddOreLocalization.AddOreSet S\ninst✝⁴ : AddAction M X\ninst✝³ : VAdd R X\ninst✝² : VAdd R M\ninst✝¹ : VAddAssocClass R M M\ninst✝ : VAddAssocClass R M X\nr : R\nx : X\n⊢ Eq (HVAdd.hVAdd r (AddOreLocalization.oreSub x 0)) (AddOreLocalization.oreSub (HVAdd.hVAdd r x) 0)","decl":"@[to_additive]\ntheorem smul_oreDiv_one (r : R) (x : X) : r • (x /ₒ (1 : S)) = (r • x) /ₒ (1 : S) := by\n  rw [← smul_one_oreDiv_one_smul, smul_div_one, smul_assoc, one_smul]\n\n"}
{"name":"OreLocalization.smul_oreDiv_one","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\nM : Type u_3\nX : Type u_4\ninst✝⁶ : Monoid M\nS : Submonoid M\ninst✝⁵ : OreLocalization.OreSet S\ninst✝⁴ : MulAction M X\ninst✝³ : SMul R X\ninst✝² : SMul R M\ninst✝¹ : IsScalarTower R M M\ninst✝ : IsScalarTower R M X\nr : R\nx : X\n⊢ Eq (HSMul.hSMul r (OreLocalization.oreDiv x 1)) (OreLocalization.oreDiv (HSMul.hSMul r x) 1)","decl":"@[to_additive]\ntheorem smul_oreDiv_one (r : R) (x : X) : r • (x /ₒ (1 : S)) = (r • x) /ₒ (1 : S) := by\n  rw [← smul_one_oreDiv_one_smul, smul_div_one, smul_assoc, one_smul]\n\n"}
{"name":"OreLocalization.oreDiv_mul_oreDiv_comm","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nS : Submonoid R\ninst✝ : OreLocalization.OreSet S\nr₁ r₂ : R\ns₁ s₂ : Subtype fun x => Membership.mem S x\n⊢ Eq (HMul.hMul (OreLocalization.oreDiv r₁ s₁) (OreLocalization.oreDiv r₂ s₂)) (OreLocalization.oreDiv (HMul.hMul r₁ r₂) (HMul.hMul s₁ s₂))","decl":"@[to_additive]\ntheorem oreDiv_mul_oreDiv_comm {r₁ r₂ : R} {s₁ s₂ : S} :\n    r₁ /ₒ s₁ * (r₂ /ₒ s₂) = r₁ * r₂ /ₒ (s₁ * s₂) := by\n  rw [oreDiv_mul_char r₁ r₂ s₁ s₂ r₁ s₂ (by simp [mul_comm]), mul_comm s₂]\n\n"}
{"name":"AddOreLocalization.oreSub_add_oreSub_comm","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝¹ : AddCommMonoid R\nS : AddSubmonoid R\ninst✝ : AddOreLocalization.AddOreSet S\nr₁ r₂ : R\ns₁ s₂ : Subtype fun x => Membership.mem S x\n⊢ Eq (HAdd.hAdd (AddOreLocalization.oreSub r₁ s₁) (AddOreLocalization.oreSub r₂ s₂)) (AddOreLocalization.oreSub (HAdd.hAdd r₁ r₂) (HAdd.hAdd s₁ s₂))","decl":"@[to_additive]\ntheorem oreDiv_mul_oreDiv_comm {r₁ r₂ : R} {s₁ s₂ : S} :\n    r₁ /ₒ s₁ * (r₂ /ₒ s₂) = r₁ * r₂ /ₒ (s₁ * s₂) := by\n  rw [oreDiv_mul_char r₁ r₂ s₁ s₂ r₁ s₂ (by simp [mul_comm]), mul_comm s₂]\n\n"}
{"name":"OreLocalization.zero_def","module":"Mathlib.GroupTheory.OreLocalization.Basic","initialProofState":"R : Type u_1\ninst✝³ : Monoid R\nS : Submonoid R\ninst✝² : OreLocalization.OreSet S\nX : Type u_2\ninst✝¹ : Zero X\ninst✝ : MulAction R X\n⊢ Eq 0 (OreLocalization.oreDiv 0 1)","decl":"protected theorem zero_def : (0 : X[S⁻¹]) = 0 /ₒ 1 := by\n  with_unfolding_all rfl\n\n"}
