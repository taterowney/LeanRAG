{"name":"LinearMap.BilinForm.IsRefl.eq_zero","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nB : LinearMap.BilinForm R M\nH : B.IsRefl\nx y : M\na✝ : Eq ((B x) y) 0\n⊢ Eq ((B y) x) 0","decl":"theorem eq_zero (H : B.IsRefl) : ∀ {x y : M}, B x y = 0 → B y x = 0 := fun {x y} => H x y\n\n"}
{"name":"LinearMap.BilinForm.IsRefl.neg","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R₁ : Type u_3\nM₁ : Type u_4\ninst✝² : CommRing R₁\ninst✝¹ : AddCommGroup M₁\ninst✝ : Module R₁ M₁\nB : LinearMap.BilinForm R₁ M₁\nhB : B.IsRefl\n⊢ (Neg.neg B).IsRefl","decl":"protected theorem neg {B : BilinForm R₁ M₁} (hB : B.IsRefl) : (-B).IsRefl := fun x y =>\n  neg_eq_zero.mpr ∘ hB x y ∘ neg_eq_zero.mp\n\n"}
{"name":"LinearMap.BilinForm.IsRefl.smul","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nα : Type u_8\ninst✝³ : CommSemiring α\ninst✝² : Module α R\ninst✝¹ : SMulCommClass R α R\ninst✝ : NoZeroSMulDivisors α R\na : α\nB : LinearMap.BilinForm R M\nhB : B.IsRefl\n⊢ (HSMul.hSMul a B).IsRefl","decl":"protected theorem smul {α} [CommSemiring α] [Module α R] [SMulCommClass R α R]\n    [NoZeroSMulDivisors α R] (a : α) {B : BilinForm R M} (hB : B.IsRefl) :\n    (a • B).IsRefl := fun _ _ h =>\n  (smul_eq_zero.mp h).elim (fun ha => smul_eq_zero_of_left ha _) fun hBz =>\n    smul_eq_zero_of_right _ (hB _ _ hBz)\n\n"}
{"name":"LinearMap.BilinForm.IsRefl.groupSMul","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nα : Type u_8\ninst✝² : Group α\ninst✝¹ : DistribMulAction α R\ninst✝ : SMulCommClass R α R\na : α\nB : LinearMap.BilinForm R M\nhB : B.IsRefl\n⊢ (HSMul.hSMul a B).IsRefl","decl":"protected theorem groupSMul {α} [Group α] [DistribMulAction α R] [SMulCommClass R α R] (a : α)\n    {B : BilinForm R M} (hB : B.IsRefl) : (a • B).IsRefl := fun x y =>\n  (smul_eq_zero_iff_eq _).mpr ∘ hB x y ∘ (smul_eq_zero_iff_eq _).mp\n\n"}
{"name":"LinearMap.BilinForm.isRefl_zero","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ LinearMap.BilinForm.IsRefl 0","decl":"@[simp]\ntheorem isRefl_zero : (0 : BilinForm R M).IsRefl := fun _ _ _ => rfl\n\n"}
{"name":"LinearMap.BilinForm.isRefl_neg","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R₁ : Type u_3\nM₁ : Type u_4\ninst✝² : CommRing R₁\ninst✝¹ : AddCommGroup M₁\ninst✝ : Module R₁ M₁\nB : LinearMap.BilinForm R₁ M₁\n⊢ Iff (Neg.neg B).IsRefl B.IsRefl","decl":"@[simp]\ntheorem isRefl_neg {B : BilinForm R₁ M₁} : (-B).IsRefl ↔ B.IsRefl :=\n  ⟨fun h => neg_neg B ▸ h.neg, IsRefl.neg⟩\n\n"}
{"name":"LinearMap.BilinForm.IsSymm.eq","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nB : LinearMap.BilinForm R M\nH : B.IsSymm\nx y : M\n⊢ Eq ((B x) y) ((B y) x)","decl":"protected theorem eq (H : B.IsSymm) (x y : M) : B x y = B y x :=\n  H x y\n\n"}
{"name":"LinearMap.BilinForm.IsSymm.isRefl","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nB : LinearMap.BilinForm R M\nH : B.IsSymm\n⊢ B.IsRefl","decl":"theorem isRefl (H : B.IsSymm) : B.IsRefl := fun x y H1 => H x y ▸ H1\n\n"}
{"name":"LinearMap.BilinForm.IsSymm.add","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nB₁ B₂ : LinearMap.BilinForm R M\nhB₁ : B₁.IsSymm\nhB₂ : B₂.IsSymm\n⊢ (HAdd.hAdd B₁ B₂).IsSymm","decl":"protected theorem add {B₁ B₂ : BilinForm R M} (hB₁ : B₁.IsSymm) (hB₂ : B₂.IsSymm) :\n    (B₁ + B₂).IsSymm := fun x y => (congr_arg₂ (· + ·) (hB₁ x y) (hB₂ x y) :)\n\n"}
{"name":"LinearMap.BilinForm.IsSymm.sub","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R₁ : Type u_3\nM₁ : Type u_4\ninst✝² : CommRing R₁\ninst✝¹ : AddCommGroup M₁\ninst✝ : Module R₁ M₁\nB₁ B₂ : LinearMap.BilinForm R₁ M₁\nhB₁ : B₁.IsSymm\nhB₂ : B₂.IsSymm\n⊢ (HSub.hSub B₁ B₂).IsSymm","decl":"protected theorem sub {B₁ B₂ : BilinForm R₁ M₁} (hB₁ : B₁.IsSymm) (hB₂ : B₂.IsSymm) :\n    (B₁ - B₂).IsSymm := fun x y => (congr_arg₂ Sub.sub (hB₁ x y) (hB₂ x y) :)\n\n"}
{"name":"LinearMap.BilinForm.IsSymm.neg","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R₁ : Type u_3\nM₁ : Type u_4\ninst✝² : CommRing R₁\ninst✝¹ : AddCommGroup M₁\ninst✝ : Module R₁ M₁\nB : LinearMap.BilinForm R₁ M₁\nhB : B.IsSymm\n⊢ (Neg.neg B).IsSymm","decl":"protected theorem neg {B : BilinForm R₁ M₁} (hB : B.IsSymm) : (-B).IsSymm := fun x y =>\n  congr_arg Neg.neg (hB x y)\n\n"}
{"name":"LinearMap.BilinForm.IsSymm.smul","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nα : Type u_8\ninst✝² : Monoid α\ninst✝¹ : DistribMulAction α R\ninst✝ : SMulCommClass R α R\na : α\nB : LinearMap.BilinForm R M\nhB : B.IsSymm\n⊢ (HSMul.hSMul a B).IsSymm","decl":"protected theorem smul {α} [Monoid α] [DistribMulAction α R] [SMulCommClass R α R] (a : α)\n    {B : BilinForm R M} (hB : B.IsSymm) : (a • B).IsSymm := fun x y =>\n  congr_arg (a • ·) (hB x y)\n\n"}
{"name":"LinearMap.BilinForm.IsSymm.restrict","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nB : LinearMap.BilinForm R M\nb : B.IsSymm\nW : Submodule R M\n⊢ (B.restrict W).IsSymm","decl":"/-- The restriction of a symmetric bilinear form on a submodule is also symmetric. -/\ntheorem restrict {B : BilinForm R M} (b : B.IsSymm) (W : Submodule R M) :\n    (B.restrict W).IsSymm := fun x y => b x y\n\n"}
{"name":"LinearMap.BilinForm.isSymm_zero","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ LinearMap.BilinForm.IsSymm 0","decl":"@[simp]\ntheorem isSymm_zero : (0 : BilinForm R M).IsSymm := fun _ _ => rfl\n\n"}
{"name":"LinearMap.BilinForm.isSymm_neg","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R₁ : Type u_3\nM₁ : Type u_4\ninst✝² : CommRing R₁\ninst✝¹ : AddCommGroup M₁\ninst✝ : Module R₁ M₁\nB : LinearMap.BilinForm R₁ M₁\n⊢ Iff (Neg.neg B).IsSymm B.IsSymm","decl":"@[simp]\ntheorem isSymm_neg {B : BilinForm R₁ M₁} : (-B).IsSymm ↔ B.IsSymm :=\n  ⟨fun h => neg_neg B ▸ h.neg, IsSymm.neg⟩\n\n"}
{"name":"LinearMap.BilinForm.isSymm_iff_flip","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nB : LinearMap.BilinForm R M\n⊢ Iff B.IsSymm (Eq (LinearMap.BilinForm.flipHom B) B)","decl":"theorem isSymm_iff_flip : B.IsSymm ↔ flipHom B = B :=\n  (forall₂_congr fun _ _ => by exact eq_comm).trans BilinForm.ext_iff.symm\n\n"}
{"name":"LinearMap.BilinForm.IsAlt.self_eq_zero","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nB : LinearMap.BilinForm R M\nH : B.IsAlt\nx : M\n⊢ Eq ((B x) x) 0","decl":"theorem self_eq_zero (H : B.IsAlt) (x : M) : B x x = 0 := LinearMap.IsAlt.self_eq_zero H x\n\n"}
{"name":"LinearMap.BilinForm.IsAlt.neg_eq","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R₁ : Type u_3\nM₁ : Type u_4\ninst✝² : CommRing R₁\ninst✝¹ : AddCommGroup M₁\ninst✝ : Module R₁ M₁\nB₁ : LinearMap.BilinForm R₁ M₁\nH : B₁.IsAlt\nx y : M₁\n⊢ Eq (Neg.neg ((B₁ x) y)) ((B₁ y) x)","decl":"theorem neg_eq (H : B₁.IsAlt) (x y : M₁) : -B₁ x y = B₁ y x := LinearMap.IsAlt.neg H x y\n\n"}
{"name":"LinearMap.BilinForm.IsAlt.isRefl","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R₁ : Type u_3\nM₁ : Type u_4\ninst✝² : CommRing R₁\ninst✝¹ : AddCommGroup M₁\ninst✝ : Module R₁ M₁\nB₁ : LinearMap.BilinForm R₁ M₁\nH : B₁.IsAlt\n⊢ B₁.IsRefl","decl":"theorem isRefl (H : B₁.IsAlt) : B₁.IsRefl := LinearMap.IsAlt.isRefl H\n\n"}
{"name":"LinearMap.BilinForm.IsAlt.eq_of_add_add_eq_zero","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nB : LinearMap.BilinForm R M\ninst✝ : IsCancelAdd R\na b c : M\nH : B.IsAlt\nhAdd : Eq (HAdd.hAdd (HAdd.hAdd a b) c) 0\n⊢ Eq ((B a) b) ((B b) c)","decl":"theorem eq_of_add_add_eq_zero [IsCancelAdd R] {a b c : M} (H : B.IsAlt) (hAdd : a + b + c = 0) :\n    B a b = B b c := LinearMap.IsAlt.eq_of_add_add_eq_zero H hAdd\n\n"}
{"name":"LinearMap.BilinForm.IsAlt.add","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nB₁ B₂ : LinearMap.BilinForm R M\nhB₁ : B₁.IsAlt\nhB₂ : B₂.IsAlt\n⊢ (HAdd.hAdd B₁ B₂).IsAlt","decl":"protected theorem add {B₁ B₂ : BilinForm R M} (hB₁ : B₁.IsAlt) (hB₂ : B₂.IsAlt) : (B₁ + B₂).IsAlt :=\n  fun x => (congr_arg₂ (· + ·) (hB₁ x) (hB₂ x) :).trans <| add_zero _\n\n"}
{"name":"LinearMap.BilinForm.IsAlt.sub","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R₁ : Type u_3\nM₁ : Type u_4\ninst✝² : CommRing R₁\ninst✝¹ : AddCommGroup M₁\ninst✝ : Module R₁ M₁\nB₁ B₂ : LinearMap.BilinForm R₁ M₁\nhB₁ : B₁.IsAlt\nhB₂ : B₂.IsAlt\n⊢ (HSub.hSub B₁ B₂).IsAlt","decl":"protected theorem sub {B₁ B₂ : BilinForm R₁ M₁} (hB₁ : B₁.IsAlt) (hB₂ : B₂.IsAlt) :\n    (B₁ - B₂).IsAlt := fun x => (congr_arg₂ Sub.sub (hB₁ x) (hB₂ x)).trans <| sub_zero _\n\n"}
{"name":"LinearMap.BilinForm.IsAlt.neg","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R₁ : Type u_3\nM₁ : Type u_4\ninst✝² : CommRing R₁\ninst✝¹ : AddCommGroup M₁\ninst✝ : Module R₁ M₁\nB : LinearMap.BilinForm R₁ M₁\nhB : B.IsAlt\n⊢ (Neg.neg B).IsAlt","decl":"protected theorem neg {B : BilinForm R₁ M₁} (hB : B.IsAlt) : (-B).IsAlt := fun x =>\n  neg_eq_zero.mpr <| hB x\n\n"}
{"name":"LinearMap.BilinForm.IsAlt.smul","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nα : Type u_8\ninst✝² : Monoid α\ninst✝¹ : DistribMulAction α R\ninst✝ : SMulCommClass R α R\na : α\nB : LinearMap.BilinForm R M\nhB : B.IsAlt\n⊢ (HSMul.hSMul a B).IsAlt","decl":"protected theorem smul {α} [Monoid α] [DistribMulAction α R] [SMulCommClass R α R] (a : α)\n    {B : BilinForm R M} (hB : B.IsAlt) : (a • B).IsAlt := fun x =>\n  (congr_arg (a • ·) (hB x)).trans <| smul_zero _\n\n"}
{"name":"LinearMap.BilinForm.isAlt_zero","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ LinearMap.BilinForm.IsAlt 0","decl":"@[simp]\ntheorem isAlt_zero : (0 : BilinForm R M).IsAlt := fun _ => rfl\n\n"}
{"name":"LinearMap.BilinForm.isAlt_neg","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R₁ : Type u_3\nM₁ : Type u_4\ninst✝² : CommRing R₁\ninst✝¹ : AddCommGroup M₁\ninst✝ : Module R₁ M₁\nB : LinearMap.BilinForm R₁ M₁\n⊢ Iff (Neg.neg B).IsAlt B.IsAlt","decl":"@[simp]\ntheorem isAlt_neg {B : BilinForm R₁ M₁} : (-B).IsAlt ↔ B.IsAlt :=\n  ⟨fun h => neg_neg B ▸ h.neg, IsAlt.neg⟩\n\n"}
{"name":"LinearMap.BilinForm.not_nondegenerate_zero","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Nontrivial M\n⊢ Not (LinearMap.BilinForm.Nondegenerate 0)","decl":"/-- In a non-trivial module, zero is not non-degenerate. -/\ntheorem not_nondegenerate_zero [Nontrivial M] : ¬(0 : BilinForm R M).Nondegenerate :=\n  let ⟨m, hm⟩ := exists_ne (0 : M)\n  fun h => hm (h m fun _ => rfl)\n\n"}
{"name":"LinearMap.BilinForm.Nondegenerate.ne_zero","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Nontrivial M\nB : LinearMap.BilinForm R M\nh : B.Nondegenerate\n⊢ Ne B 0","decl":"theorem Nondegenerate.ne_zero [Nontrivial M] {B : BilinForm R M} (h : B.Nondegenerate) : B ≠ 0 :=\n  fun h0 => not_nondegenerate_zero R M <| h0 ▸ h\n\n"}
{"name":"LinearMap.BilinForm.Nondegenerate.congr","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nM' : Type u_8\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nB : LinearMap.BilinForm R M\ne : LinearEquiv (RingHom.id R) M M'\nh : B.Nondegenerate\n⊢ ((LinearMap.BilinForm.congr e) B).Nondegenerate","decl":"theorem Nondegenerate.congr {B : BilinForm R M} (e : M ≃ₗ[R] M') (h : B.Nondegenerate) :\n    (congr e B).Nondegenerate := fun m hm =>\n  e.symm.map_eq_zero_iff.1 <|\n    h (e.symm m) fun n => (congr_arg _ (e.symm_apply_apply n).symm).trans (hm (e n))\n\n"}
{"name":"LinearMap.BilinForm.nondegenerate_congr_iff","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nM' : Type u_8\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nB : LinearMap.BilinForm R M\ne : LinearEquiv (RingHom.id R) M M'\n⊢ Iff ((LinearMap.BilinForm.congr e) B).Nondegenerate B.Nondegenerate","decl":"@[simp]\ntheorem nondegenerate_congr_iff {B : BilinForm R M} (e : M ≃ₗ[R] M') :\n    (congr e B).Nondegenerate ↔ B.Nondegenerate :=\n  ⟨fun h => by\n    convert h.congr e.symm\n    rw [congr_congr, e.self_trans_symm, congr_refl, LinearEquiv.refl_apply], Nondegenerate.congr e⟩\n\n"}
{"name":"LinearMap.BilinForm.nondegenerate_iff_ker_eq_bot","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nB : LinearMap.BilinForm R M\n⊢ Iff B.Nondegenerate (Eq (LinearMap.ker B) Bot.bot)","decl":"/-- A bilinear form is nondegenerate if and only if it has a trivial kernel. -/\ntheorem nondegenerate_iff_ker_eq_bot {B : BilinForm R M} :\n    B.Nondegenerate ↔ LinearMap.ker B = ⊥ := by\n  rw [LinearMap.ker_eq_bot']\n  constructor <;> intro h\n  · refine fun m hm => h _ fun x => ?_\n    rw [hm]\n    rfl\n  · intro m hm\n    apply h\n    ext x\n    exact hm x\n\n"}
{"name":"LinearMap.BilinForm.Nondegenerate.ker_eq_bot","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nB : LinearMap.BilinForm R M\nh : B.Nondegenerate\n⊢ Eq (LinearMap.ker B) Bot.bot","decl":"theorem Nondegenerate.ker_eq_bot {B : BilinForm R M} (h : B.Nondegenerate) :\n    LinearMap.ker B = ⊥ := nondegenerate_iff_ker_eq_bot.mp h\n\n"}
{"name":"LinearMap.BilinForm.compLeft_injective","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R₁ : Type u_3\nM₁ : Type u_4\ninst✝² : CommRing R₁\ninst✝¹ : AddCommGroup M₁\ninst✝ : Module R₁ M₁\nB : LinearMap.BilinForm R₁ M₁\nb : B.Nondegenerate\n⊢ Function.Injective B.compLeft","decl":"theorem compLeft_injective (B : BilinForm R₁ M₁) (b : B.Nondegenerate) :\n    Function.Injective B.compLeft := fun φ ψ h => by\n  ext w\n  refine eq_of_sub_eq_zero (b _ ?_)\n  intro v\n  rw [sub_left, ← compLeft_apply, ← compLeft_apply, ← h, sub_self]\n\n"}
{"name":"LinearMap.BilinForm.isAdjointPair_unique_of_nondegenerate","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"R₁ : Type u_3\nM₁ : Type u_4\ninst✝² : CommRing R₁\ninst✝¹ : AddCommGroup M₁\ninst✝ : Module R₁ M₁\nB : LinearMap.BilinForm R₁ M₁\nb : B.Nondegenerate\nφ ψ₁ ψ₂ : LinearMap (RingHom.id R₁) M₁ M₁\nhψ₁ : LinearMap.IsAdjointPair B B ⇑ψ₁ ⇑φ\nhψ₂ : LinearMap.IsAdjointPair B B ⇑ψ₂ ⇑φ\n⊢ Eq ψ₁ ψ₂","decl":"theorem isAdjointPair_unique_of_nondegenerate (B : BilinForm R₁ M₁) (b : B.Nondegenerate)\n    (φ ψ₁ ψ₂ : M₁ →ₗ[R₁] M₁) (hψ₁ : IsAdjointPair B B ψ₁ φ) (hψ₂ : IsAdjointPair B B ψ₂ φ) :\n    ψ₁ = ψ₂ :=\n  B.compLeft_injective b <| ext fun v w => by rw [compLeft_apply, compLeft_apply, hψ₁, hψ₂]\n\n"}
{"name":"LinearMap.BilinForm.toDual_def","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"V : Type u_5\nK : Type u_6\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nB : LinearMap.BilinForm K V\nb : LinearMap.SeparatingLeft B\nm n : V\n⊢ Eq (((B.toDual b) m) n) ((B m) n)","decl":"theorem toDual_def {B : BilinForm K V} (b : B.SeparatingLeft) {m n : V} : B.toDual b m n = B m n :=\n  rfl\n\n"}
{"name":"LinearMap.BilinForm.apply_toDual_symm_apply","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"V : Type u_5\nK : Type u_6\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nB : LinearMap.BilinForm K V\nhB : B.Nondegenerate\nf : Module.Dual K V\nv : V\n⊢ Eq ((B ((B.toDual hB).symm f)) v) (f v)","decl":"@[simp]\nlemma apply_toDual_symm_apply {B : BilinForm K V} {hB : B.Nondegenerate}\n    (f : Module.Dual K V) (v : V) :\n    B ((B.toDual hB).symm f) v = f v := by\n  change B.toDual hB ((B.toDual hB).symm f) v = f v\n  simp only [LinearEquiv.apply_symm_apply]\n\n"}
{"name":"LinearMap.BilinForm.Nondegenerate.flip","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"V : Type u_5\nK : Type u_6\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nB : LinearMap.BilinForm K V\nhB : B.Nondegenerate\n⊢ B.flip.Nondegenerate","decl":"lemma Nondegenerate.flip {B : BilinForm K V} (hB : B.Nondegenerate) :\n    B.flip.Nondegenerate := by\n  intro x hx\n  apply (Module.evalEquiv K V).injective\n  ext f\n  obtain ⟨y, rfl⟩ := (B.toDual hB).surjective f\n  simpa using hx y\n\n"}
{"name":"LinearMap.BilinForm.nonDegenerateFlip_iff","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"V : Type u_5\nK : Type u_6\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nB : LinearMap.BilinForm K V\n⊢ Iff B.flip.Nondegenerate B.Nondegenerate","decl":"lemma nonDegenerateFlip_iff {B : BilinForm K V} :\n    B.flip.Nondegenerate ↔ B.Nondegenerate := ⟨Nondegenerate.flip, Nondegenerate.flip⟩\n\n"}
{"name":"LinearMap.BilinForm.dualBasis_repr_apply","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"V : Type u_5\nK : Type u_6\ninst✝⁴ : Field K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\nι : Type u_9\ninst✝¹ : DecidableEq ι\ninst✝ : Finite ι\nB : LinearMap.BilinForm K V\nhB : B.Nondegenerate\nb : Basis ι K V\nx : V\ni : ι\n⊢ Eq (((B.dualBasis hB b).repr x) i) ((B x) (b i))","decl":"@[simp]\ntheorem dualBasis_repr_apply\n    (B : BilinForm K V) (hB : B.Nondegenerate) (b : Basis ι K V) (x i) :\n    (B.dualBasis hB b).repr x i = B x (b i) := by\n  #adaptation_note /-- https://github.com/leanprover/lean4/pull/4814\n  we did not need the `@` in front of `toDual_def` in the `rw`.\n  I'm confused! -/\n  rw [dualBasis, Basis.map_repr, LinearEquiv.symm_symm, LinearEquiv.trans_apply,\n    Basis.dualBasis_repr, @toDual_def]\n\n"}
{"name":"LinearMap.BilinForm.apply_dualBasis_left","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"V : Type u_5\nK : Type u_6\ninst✝⁴ : Field K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\nι : Type u_9\ninst✝¹ : DecidableEq ι\ninst✝ : Finite ι\nB : LinearMap.BilinForm K V\nhB : B.Nondegenerate\nb : Basis ι K V\ni j : ι\n⊢ Eq ((B ((B.dualBasis hB b) i)) (b j)) (ite (Eq j i) 1 0)","decl":"theorem apply_dualBasis_left (B : BilinForm K V) (hB : B.Nondegenerate) (b : Basis ι K V) (i j) :\n    B (B.dualBasis hB b i) (b j) = if j = i then 1 else 0 := by\n  have := FiniteDimensional.of_fintype_basis b\n  rw [dualBasis, Basis.map_apply, Basis.coe_dualBasis, ← toDual_def hB,\n    LinearEquiv.apply_symm_apply, Basis.coord_apply, Basis.repr_self, Finsupp.single_apply]\n\n"}
{"name":"LinearMap.BilinForm.apply_dualBasis_right","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"V : Type u_5\nK : Type u_6\ninst✝⁴ : Field K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\nι : Type u_9\ninst✝¹ : DecidableEq ι\ninst✝ : Finite ι\nB : LinearMap.BilinForm K V\nhB : B.Nondegenerate\nsym : B.IsSymm\nb : Basis ι K V\ni j : ι\n⊢ Eq ((B (b i)) ((B.dualBasis hB b) j)) (ite (Eq i j) 1 0)","decl":"theorem apply_dualBasis_right (B : BilinForm K V) (hB : B.Nondegenerate) (sym : B.IsSymm)\n    (b : Basis ι K V) (i j) : B (b i) (B.dualBasis hB b j) = if i = j then 1 else 0 := by\n  rw [sym.eq, apply_dualBasis_left]\n\n"}
{"name":"LinearMap.BilinForm.dualBasis_dualBasis_flip","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"V : Type u_5\nK : Type u_6\ninst✝⁵ : Field K\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module K V\ninst✝² : FiniteDimensional K V\nB : LinearMap.BilinForm K V\nhB : B.Nondegenerate\nι : Type u_10\ninst✝¹ : Finite ι\ninst✝ : DecidableEq ι\nb : Basis ι K V\n⊢ Eq (B.dualBasis hB (B.flip.dualBasis ⋯ b)) b","decl":"@[simp]\nlemma dualBasis_dualBasis_flip [FiniteDimensional K V]\n    (B : BilinForm K V) (hB : B.Nondegenerate) {ι : Type*}\n    [Finite ι] [DecidableEq ι] (b : Basis ι K V) :\n    B.dualBasis hB (B.flip.dualBasis hB.flip b) = b := by\n  ext i\n  refine LinearMap.ker_eq_bot.mp hB.ker_eq_bot ((B.flip.dualBasis hB.flip b).ext (fun j ↦ ?_))\n  simp_rw [apply_dualBasis_left, ← B.flip_apply, apply_dualBasis_left, @eq_comm _ i j]\n\n"}
{"name":"LinearMap.BilinForm.dualBasis_flip_dualBasis","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"V : Type u_5\nK : Type u_6\ninst✝⁵ : Field K\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module K V\nB : LinearMap.BilinForm K V\nhB : B.Nondegenerate\nι : Type u_10\ninst✝² : Finite ι\ninst✝¹ : DecidableEq ι\ninst✝ : FiniteDimensional K V\nb : Basis ι K V\n⊢ Eq (B.flip.dualBasis ⋯ (B.dualBasis hB b)) b","decl":"@[simp]\nlemma dualBasis_flip_dualBasis (B : BilinForm K V) (hB : B.Nondegenerate) {ι}\n    [Finite ι] [DecidableEq ι] [FiniteDimensional K V] (b : Basis ι K V) :\n    B.flip.dualBasis hB.flip (B.dualBasis hB b) = b :=\n  dualBasis_dualBasis_flip _ hB.flip b\n\n"}
{"name":"LinearMap.BilinForm.dualBasis_dualBasis","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"V : Type u_5\nK : Type u_6\ninst✝⁵ : Field K\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module K V\nB : LinearMap.BilinForm K V\nhB : B.Nondegenerate\nhB' : B.IsSymm\nι : Type u_10\ninst✝² : Finite ι\ninst✝¹ : DecidableEq ι\ninst✝ : FiniteDimensional K V\nb : Basis ι K V\n⊢ Eq (B.dualBasis hB (B.dualBasis hB b)) b","decl":"@[simp]\nlemma dualBasis_dualBasis (B : BilinForm K V) (hB : B.Nondegenerate) (hB' : B.IsSymm) {ι}\n    [Finite ι] [DecidableEq ι] [FiniteDimensional K V] (b : Basis ι K V) :\n    B.dualBasis hB (B.dualBasis hB b) = b := by\n  convert dualBasis_dualBasis_flip _ hB.flip b\n  rwa [eq_comm, ← isSymm_iff_flip]\n\n"}
{"name":"LinearMap.BilinForm.comp_symmCompOfNondegenerate_apply","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"V : Type u_5\nK : Type u_6\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nB₁ B₂ : LinearMap.BilinForm K V\nb₂ : B₂.Nondegenerate\nv : V\n⊢ Eq (B₂ ((B₁.symmCompOfNondegenerate B₂ b₂) v)) (B₁ v)","decl":"theorem comp_symmCompOfNondegenerate_apply (B₁ : BilinForm K V) {B₂ : BilinForm K V}\n    (b₂ : B₂.Nondegenerate) (v : V) :\n    B₂ (B₁.symmCompOfNondegenerate B₂ b₂ v) = B₁ v := by\n  rw [symmCompOfNondegenerate]\n  simp only [coe_comp, LinearEquiv.coe_coe, Function.comp_apply, DFunLike.coe_fn_eq]\n  erw [LinearEquiv.apply_symm_apply (B₂.toDual b₂)]\n\n"}
{"name":"LinearMap.BilinForm.symmCompOfNondegenerate_left_apply","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"V : Type u_5\nK : Type u_6\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nB₁ B₂ : LinearMap.BilinForm K V\nb₂ : B₂.Nondegenerate\nv w : V\n⊢ Eq ((B₂ ((B₁.symmCompOfNondegenerate B₂ b₂) w)) v) ((B₁ w) v)","decl":"@[simp]\ntheorem symmCompOfNondegenerate_left_apply (B₁ : BilinForm K V) {B₂ : BilinForm K V}\n    (b₂ : B₂.Nondegenerate) (v w : V) : B₂ (symmCompOfNondegenerate B₁ B₂ b₂ w) v = B₁ w v := by\n  conv_lhs => rw [comp_symmCompOfNondegenerate_apply]\n\n"}
{"name":"LinearMap.BilinForm.isAdjointPairLeftAdjointOfNondegenerate","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"V : Type u_5\nK : Type u_6\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nB : LinearMap.BilinForm K V\nb : B.Nondegenerate\nφ : LinearMap (RingHom.id K) V V\n⊢ LinearMap.IsAdjointPair B B ⇑(B.leftAdjointOfNondegenerate b φ) ⇑φ","decl":"theorem isAdjointPairLeftAdjointOfNondegenerate (B : BilinForm K V) (b : B.Nondegenerate)\n    (φ : V →ₗ[K] V) : IsAdjointPair B B (B.leftAdjointOfNondegenerate b φ) φ := fun x y =>\n  (B.compRight φ).symmCompOfNondegenerate_left_apply b y x\n\n"}
{"name":"LinearMap.BilinForm.isAdjointPair_iff_eq_of_nondegenerate","module":"Mathlib.LinearAlgebra.BilinearForm.Properties","initialProofState":"V : Type u_5\nK : Type u_6\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nB : LinearMap.BilinForm K V\nb : B.Nondegenerate\nψ φ : LinearMap (RingHom.id K) V V\n⊢ Iff (LinearMap.IsAdjointPair B B ⇑ψ ⇑φ) (Eq ψ (B.leftAdjointOfNondegenerate b φ))","decl":"/-- Given the nondegenerate bilinear form `B`, the linear map `φ` has a unique left adjoint given by\n`BilinForm.leftAdjointOfNondegenerate`. -/\ntheorem isAdjointPair_iff_eq_of_nondegenerate (B : BilinForm K V) (b : B.Nondegenerate)\n    (ψ φ : V →ₗ[K] V) : IsAdjointPair B B ψ φ ↔ ψ = B.leftAdjointOfNondegenerate b φ :=\n  ⟨fun h =>\n    B.isAdjointPair_unique_of_nondegenerate b φ ψ _ h\n      (isAdjointPairLeftAdjointOfNondegenerate _ _ _),\n    fun h => h.symm ▸ isAdjointPairLeftAdjointOfNondegenerate _ _ _⟩\n\n"}
