{"name":"CategoryTheory.Codiscrete.ext_iff","module":"Mathlib.CategoryTheory.CodiscreteCategory","initialProofState":"Œ± : Type u\nx y : CategoryTheory.Codiscrete Œ±\n‚ä¢ Iff (Eq x y) (Eq x.as y.as)","decl":"/-- A wrapper for promoting any type to a category,\nwith a unique morphisms between any two objects of the category.\n-/\n@[ext, aesop safe cases (rule_sets := [CategoryTheory])]\nstructure Codiscrete (Œ± : Type u) where\n  /-- A wrapper for promoting any type to a category,\n  with a unique morphisms between any two objects of the category. -/\n  as : Œ±\n\n"}
{"name":"CategoryTheory.Codiscrete.mk.inj","module":"Mathlib.CategoryTheory.CodiscreteCategory","initialProofState":"Œ± : Type u\nas‚úù as : Œ±\nx‚úù : Eq { as := as‚úù } { as := as }\n‚ä¢ Eq as‚úù as","decl":"/-- A wrapper for promoting any type to a category,\nwith a unique morphisms between any two objects of the category.\n-/\n@[ext, aesop safe cases (rule_sets := [CategoryTheory])]\nstructure Codiscrete (Œ± : Type u) where\n  /-- A wrapper for promoting any type to a category,\n  with a unique morphisms between any two objects of the category. -/\n  as : Œ±\n\n"}
{"name":"CategoryTheory.Codiscrete.ext","module":"Mathlib.CategoryTheory.CodiscreteCategory","initialProofState":"Œ± : Type u\nx y : CategoryTheory.Codiscrete Œ±\nas : Eq x.as y.as\n‚ä¢ Eq x y","decl":"/-- A wrapper for promoting any type to a category,\nwith a unique morphisms between any two objects of the category.\n-/\n@[ext, aesop safe cases (rule_sets := [CategoryTheory])]\nstructure Codiscrete (Œ± : Type u) where\n  /-- A wrapper for promoting any type to a category,\n  with a unique morphisms between any two objects of the category. -/\n  as : Œ±\n\n"}
{"name":"CategoryTheory.Codiscrete.mk.injEq","module":"Mathlib.CategoryTheory.CodiscreteCategory","initialProofState":"Œ± : Type u\nas‚úù as : Œ±\n‚ä¢ Eq (Eq { as := as‚úù } { as := as }) (Eq as‚úù as)","decl":"/-- A wrapper for promoting any type to a category,\nwith a unique morphisms between any two objects of the category.\n-/\n@[ext, aesop safe cases (rule_sets := [CategoryTheory])]\nstructure Codiscrete (Œ± : Type u) where\n  /-- A wrapper for promoting any type to a category,\n  with a unique morphisms between any two objects of the category. -/\n  as : Œ±\n\n"}
{"name":"CategoryTheory.Codiscrete.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.CodiscreteCategory","initialProofState":"Œ± : Type u\ninst‚úù : SizeOf Œ±\nas : Œ±\n‚ä¢ Eq (SizeOf.sizeOf { as := as }) (HAdd.hAdd 1 (SizeOf.sizeOf as))","decl":"/-- A wrapper for promoting any type to a category,\nwith a unique morphisms between any two objects of the category.\n-/\n@[ext, aesop safe cases (rule_sets := [CategoryTheory])]\nstructure Codiscrete (Œ± : Type u) where\n  /-- A wrapper for promoting any type to a category,\n  with a unique morphisms between any two objects of the category. -/\n  as : Œ±\n\n"}
{"name":"CategoryTheory.Codiscrete.mk_as","module":"Mathlib.CategoryTheory.CodiscreteCategory","initialProofState":"Œ± : Type u\nX : CategoryTheory.Codiscrete Œ±\n‚ä¢ Eq { as := X.as } X","decl":"@[simp]\ntheorem Codiscrete.mk_as {Œ± : Type u} (X : Codiscrete Œ±) : Codiscrete.mk X.as = X := rfl\n\n"}
{"name":"CategoryTheory.codiscreteEquiv_symm_apply_as","module":"Mathlib.CategoryTheory.CodiscreteCategory","initialProofState":"Œ± : Type u\nas : Œ±\n‚ä¢ Eq (CategoryTheory.codiscreteEquiv.symm as).as as","decl":"/-- `Codiscrete Œ±` is equivalent to the original type `Œ±`. -/\n@[simps]\ndef codiscreteEquiv {Œ± : Type u} : Codiscrete Œ± ‚âÉ Œ± where\n  toFun := Codiscrete.as\n  invFun := Codiscrete.mk\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.codiscreteEquiv_apply","module":"Mathlib.CategoryTheory.CodiscreteCategory","initialProofState":"Œ± : Type u\nself : CategoryTheory.Codiscrete Œ±\n‚ä¢ Eq (CategoryTheory.codiscreteEquiv self) self.as","decl":"/-- `Codiscrete Œ±` is equivalent to the original type `Œ±`. -/\n@[simps]\ndef codiscreteEquiv {Œ± : Type u} : Codiscrete Œ± ‚âÉ Œ± where\n  toFun := Codiscrete.as\n  invFun := Codiscrete.mk\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.Codiscrete.natIsoFunctor_hom_app","module":"Mathlib.CategoryTheory.CodiscreteCategory","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : Type w\nF : CategoryTheory.Functor C (CategoryTheory.Codiscrete A)\nX : C\n‚ä¢ Eq (CategoryTheory.Codiscrete.natIsoFunctor.hom.app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- Every functor `F` to a codiscrete category is naturally isomorphic {(actually, equal)} to\n  `Codiscrete.as ‚àò F.obj`. -/\n@[simps!]\ndef natIsoFunctor {F : C ‚•§ Codiscrete A} : F ‚âÖ functor (Codiscrete.as ‚àò F.obj) := Iso.refl _\n\n"}
{"name":"CategoryTheory.Codiscrete.natIsoFunctor_inv_app","module":"Mathlib.CategoryTheory.CodiscreteCategory","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : Type w\nF : CategoryTheory.Functor C (CategoryTheory.Codiscrete A)\nX : C\n‚ä¢ Eq (CategoryTheory.Codiscrete.natIsoFunctor.inv.app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- Every functor `F` to a codiscrete category is naturally isomorphic {(actually, equal)} to\n  `Codiscrete.as ‚àò F.obj`. -/\n@[simps!]\ndef natIsoFunctor {F : C ‚•§ Codiscrete A} : F ‚âÖ functor (Codiscrete.as ‚àò F.obj) := Iso.refl _\n\n"}
{"name":"CategoryTheory.Codiscrete.adj_unit_app","module":"Mathlib.CategoryTheory.CodiscreteCategory","initialProofState":"X : CategoryTheory.Cat\n‚ä¢ Eq (CategoryTheory.Codiscrete.adj.unit.app X) (CategoryTheory.Codiscrete.unitApp ‚ÜëX)","decl":"lemma adj_unit_app (X : Cat.{0, u}) :\n    adj.unit.app X = unitApp X := rfl\n\n"}
{"name":"CategoryTheory.Codiscrete.adj_counit_app","module":"Mathlib.CategoryTheory.CodiscreteCategory","initialProofState":"A : Type u\n‚ä¢ Eq (CategoryTheory.Codiscrete.adj.counit.app A) (CategoryTheory.Codiscrete.counitApp A)","decl":"lemma adj_counit_app (A : Type u) :\n    adj.counit.app A = counitApp A := rfl\n\n"}
{"name":"CategoryTheory.Codiscrete.left_triangle_components","module":"Mathlib.CategoryTheory.CodiscreteCategory","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ Eq (Function.comp (CategoryTheory.Codiscrete.counitApp C) (CategoryTheory.Codiscrete.unitApp C).obj) id","decl":"/-- Left triangle equality of the adjunction `Cat.objects ‚ä£ Codiscrete.functorToCat`,\nas a universe polymorphic statement. -/\nlemma left_triangle_components (C : Type u) [Category.{v} C] :\n    (counitApp C).comp (unitApp C).obj = id :=\n  rfl\n\n"}
{"name":"CategoryTheory.Codiscrete.right_triangle_components","module":"Mathlib.CategoryTheory.CodiscreteCategory","initialProofState":"X : Type u\n‚ä¢ Eq ((CategoryTheory.Codiscrete.unitApp (CategoryTheory.Codiscrete X)).comp (CategoryTheory.Codiscrete.functorOfFun (CategoryTheory.Codiscrete.counitApp X))) (CategoryTheory.Functor.id (CategoryTheory.Codiscrete X))","decl":"/-- Right triangle equality of the adjunction `Cat.objects ‚ä£ Codiscrete.functorToCat`,\nstated using a composition of functors. -/\nlemma right_triangle_components (X : Type u) :\n    unitApp (Codiscrete X) ‚ãô functorOfFun (counitApp X) = ùü≠ (Codiscrete X) :=\n  rfl\n\n"}
