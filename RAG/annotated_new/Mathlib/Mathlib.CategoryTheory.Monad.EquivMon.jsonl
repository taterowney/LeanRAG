{"name":"CategoryTheory.Monad.toMon_one","module":"Mathlib.CategoryTheory.Monad.EquivMon","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nM : CategoryTheory.Monad C\nâŠ¢ Eq M.toMon.one M.Î·","decl":"/-- To every `Monad C` we associated a monoid object in `C â¥¤ C`. -/\n@[simps]\ndef toMon (M : Monad C) : Mon_ (C â¥¤ C) where\n  X := (M : C â¥¤ C)\n  one := M.Î·\n  mul := M.Î¼\n  mul_assoc := by ext; simp [M.assoc]\n\n"}
{"name":"CategoryTheory.Monad.toMon_mul","module":"Mathlib.CategoryTheory.Monad.EquivMon","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nM : CategoryTheory.Monad C\nâŠ¢ Eq M.toMon.mul M.Î¼","decl":"/-- To every `Monad C` we associated a monoid object in `C â¥¤ C`. -/\n@[simps]\ndef toMon (M : Monad C) : Mon_ (C â¥¤ C) where\n  X := (M : C â¥¤ C)\n  one := M.Î·\n  mul := M.Î¼\n  mul_assoc := by ext; simp [M.assoc]\n\n"}
{"name":"CategoryTheory.Monad.toMon_X","module":"Mathlib.CategoryTheory.Monad.EquivMon","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nM : CategoryTheory.Monad C\nâŠ¢ Eq M.toMon.X M.toFunctor","decl":"/-- To every `Monad C` we associated a monoid object in `C â¥¤ C`. -/\n@[simps]\ndef toMon (M : Monad C) : Mon_ (C â¥¤ C) where\n  X := (M : C â¥¤ C)\n  one := M.Î·\n  mul := M.Î¼\n  mul_assoc := by ext; simp [M.assoc]\n\n"}
{"name":"CategoryTheory.Monad.monadToMon_obj","module":"Mathlib.CategoryTheory.Monad.EquivMon","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nM : CategoryTheory.Monad C\nâŠ¢ Eq ((CategoryTheory.Monad.monadToMon C).obj M) M.toMon","decl":"/-- Passing from `Monad C` to `Mon_ (C â¥¤ C)` is functorial. -/\n@[simps]\ndef monadToMon : Monad C â¥¤ Mon_ (C â¥¤ C) where\n  obj := toMon\n  map f := { hom := f.toNatTrans }\n\n"}
{"name":"CategoryTheory.Monad.monadToMon_map_hom","module":"Mathlib.CategoryTheory.Monad.EquivMon","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nXâœ Yâœ : CategoryTheory.Monad C\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Monad.monadToMon C).map f).hom f.toNatTrans","decl":"/-- Passing from `Monad C` to `Mon_ (C â¥¤ C)` is functorial. -/\n@[simps]\ndef monadToMon : Monad C â¥¤ Mon_ (C â¥¤ C) where\n  obj := toMon\n  map f := { hom := f.toNatTrans }\n\n"}
{"name":"CategoryTheory.Monad.ofMon_Î·","module":"Mathlib.CategoryTheory.Monad.EquivMon","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nM : Mon_ (CategoryTheory.Functor C C)\nâŠ¢ Eq (CategoryTheory.Monad.ofMon M).Î· M.one","decl":"/-- To every monoid object in `C â¥¤ C` we associate a `Monad C`. -/\n@[simps Î· Î¼]\ndef ofMon (M : Mon_ (C â¥¤ C)) : Monad C where\n  toFunctor := M.X\n  Î· := M.one\n  Î¼ := M.mul\n  left_unit := fun X => by\n    -- Porting note: now using `erw`\n    erw [â† whiskerLeft_app, â† NatTrans.comp_app, M.mul_one]\n    rfl\n  right_unit := fun X => by\n    -- Porting note: now using `erw`\n    erw [â† whiskerRight_app, â† NatTrans.comp_app, M.one_mul]\n    rfl\n  assoc := fun X => by\n    rw [â† whiskerLeft_app, â† whiskerRight_app, â† NatTrans.comp_app]\n    -- Porting note: had to add this step:\n    erw [M.mul_assoc]\n    simp\n\n-- Porting note: `@[simps]` fails to generate `ofMon_obj`:\n"}
{"name":"CategoryTheory.Monad.ofMon_Î¼","module":"Mathlib.CategoryTheory.Monad.EquivMon","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nM : Mon_ (CategoryTheory.Functor C C)\nâŠ¢ Eq (CategoryTheory.Monad.ofMon M).Î¼ M.mul","decl":"/-- To every monoid object in `C â¥¤ C` we associate a `Monad C`. -/\n@[simps Î· Î¼]\ndef ofMon (M : Mon_ (C â¥¤ C)) : Monad C where\n  toFunctor := M.X\n  Î· := M.one\n  Î¼ := M.mul\n  left_unit := fun X => by\n    -- Porting note: now using `erw`\n    erw [â† whiskerLeft_app, â† NatTrans.comp_app, M.mul_one]\n    rfl\n  right_unit := fun X => by\n    -- Porting note: now using `erw`\n    erw [â† whiskerRight_app, â† NatTrans.comp_app, M.one_mul]\n    rfl\n  assoc := fun X => by\n    rw [â† whiskerLeft_app, â† whiskerRight_app, â† NatTrans.comp_app]\n    -- Porting note: had to add this step:\n    erw [M.mul_assoc]\n    simp\n\n-- Porting note: `@[simps]` fails to generate `ofMon_obj`:\n"}
{"name":"CategoryTheory.Monad.ofMon_obj","module":"Mathlib.CategoryTheory.Monad.EquivMon","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nM : Mon_ (CategoryTheory.Functor C C)\nX : C\nâŠ¢ Eq ((CategoryTheory.Monad.ofMon M).obj X) (M.X.obj X)","decl":"@[simp] lemma ofMon_obj (M : Mon_ (C â¥¤ C)) (X : C) : (ofMon M).obj X = M.X.obj X := rfl\n\n"}
{"name":"CategoryTheory.Monad.monToMonad_map_toNatTrans","module":"Mathlib.CategoryTheory.Monad.EquivMon","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nX Y : Mon_ (CategoryTheory.Functor C C)\nf : Quiver.Hom X Y\nâŠ¢ Eq ((CategoryTheory.Monad.monToMonad C).map f).toNatTrans f.hom","decl":"/-- Passing from `Mon_ (C â¥¤ C)` to `Monad C` is functorial. -/\n@[simps]\ndef monToMonad : Mon_ (C â¥¤ C) â¥¤ Monad C where\n  obj := ofMon\n  map {X Y} f :=\n    { f.hom with\n      app_Î· := by\n        intro X\n        erw [â† NatTrans.comp_app, f.one_hom]\n        simp only [Functor.id_obj, ofMon_obj, ofMon_Î·]\n      app_Î¼ := by\n        intro Z\n        erw [â† NatTrans.comp_app, f.mul_hom]\n        dsimp\n        simp only [Category.assoc, NatTrans.naturality, ofMon_obj, ofMon] }\n\n"}
{"name":"CategoryTheory.Monad.monToMonad_obj","module":"Mathlib.CategoryTheory.Monad.EquivMon","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nM : Mon_ (CategoryTheory.Functor C C)\nâŠ¢ Eq ((CategoryTheory.Monad.monToMonad C).obj M) (CategoryTheory.Monad.ofMon M)","decl":"/-- Passing from `Mon_ (C â¥¤ C)` to `Monad C` is functorial. -/\n@[simps]\ndef monToMonad : Mon_ (C â¥¤ C) â¥¤ Monad C where\n  obj := ofMon\n  map {X Y} f :=\n    { f.hom with\n      app_Î· := by\n        intro X\n        erw [â† NatTrans.comp_app, f.one_hom]\n        simp only [Functor.id_obj, ofMon_obj, ofMon_Î·]\n      app_Î¼ := by\n        intro Z\n        erw [â† NatTrans.comp_app, f.mul_hom]\n        dsimp\n        simp only [Category.assoc, NatTrans.naturality, ofMon_obj, ofMon] }\n\n"}
{"name":"CategoryTheory.Monad.monadMonEquiv_counitIso_hom_app_hom","module":"Mathlib.CategoryTheory.Monad.EquivMon","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nxâœ : Mon_ (CategoryTheory.Functor C C)\nâŠ¢ Eq ((CategoryTheory.Monad.monadMonEquiv C).counitIso.hom.app xâœ).hom (CategoryTheory.CategoryStruct.id (((CategoryTheory.Monad.monToMonad C).comp (CategoryTheory.Monad.monadToMon C)).obj xâœ).X)","decl":"/-- Oh, monads are just monoids in the category of endofunctors (equivalence of categories). -/\n@[simps]\ndef monadMonEquiv : Monad C â‰Œ Mon_ (C â¥¤ C) where\n  functor := monadToMon _\n  inverse := monToMonad _\n  unitIso :=\n  { hom := { app := fun _ => { app := fun _ => ğŸ™ _ } }\n    inv := { app := fun _ => { app := fun _ => ğŸ™ _ } } }\n  counitIso :=\n  { hom := { app := fun _ => { hom := ğŸ™ _ } }\n    inv := { app := fun _ => { hom := ğŸ™ _ } } }\n\n-- Sanity check\n"}
{"name":"CategoryTheory.Monad.monadMonEquiv_inverse","module":"Mathlib.CategoryTheory.Monad.EquivMon","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nâŠ¢ Eq (CategoryTheory.Monad.monadMonEquiv C).inverse (CategoryTheory.Monad.monToMonad C)","decl":"/-- Oh, monads are just monoids in the category of endofunctors (equivalence of categories). -/\n@[simps]\ndef monadMonEquiv : Monad C â‰Œ Mon_ (C â¥¤ C) where\n  functor := monadToMon _\n  inverse := monToMonad _\n  unitIso :=\n  { hom := { app := fun _ => { app := fun _ => ğŸ™ _ } }\n    inv := { app := fun _ => { app := fun _ => ğŸ™ _ } } }\n  counitIso :=\n  { hom := { app := fun _ => { hom := ğŸ™ _ } }\n    inv := { app := fun _ => { hom := ğŸ™ _ } } }\n\n-- Sanity check\n"}
{"name":"CategoryTheory.Monad.monadMonEquiv_counitIso_inv_app_hom","module":"Mathlib.CategoryTheory.Monad.EquivMon","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nxâœ : Mon_ (CategoryTheory.Functor C C)\nâŠ¢ Eq ((CategoryTheory.Monad.monadMonEquiv C).counitIso.inv.app xâœ).hom (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.id (Mon_ (CategoryTheory.Functor C C))).obj xâœ).X)","decl":"/-- Oh, monads are just monoids in the category of endofunctors (equivalence of categories). -/\n@[simps]\ndef monadMonEquiv : Monad C â‰Œ Mon_ (C â¥¤ C) where\n  functor := monadToMon _\n  inverse := monToMonad _\n  unitIso :=\n  { hom := { app := fun _ => { app := fun _ => ğŸ™ _ } }\n    inv := { app := fun _ => { app := fun _ => ğŸ™ _ } } }\n  counitIso :=\n  { hom := { app := fun _ => { hom := ğŸ™ _ } }\n    inv := { app := fun _ => { hom := ğŸ™ _ } } }\n\n-- Sanity check\n"}
{"name":"CategoryTheory.Monad.monadMonEquiv_unitIso_hom_app_toNatTrans_app","module":"Mathlib.CategoryTheory.Monad.EquivMon","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nxâœÂ¹ : CategoryTheory.Monad C\nxâœ : C\nâŠ¢ Eq (((CategoryTheory.Monad.monadMonEquiv C).unitIso.hom.app xâœÂ¹).app xâœ) (CategoryTheory.CategoryStruct.id (((CategoryTheory.Functor.id (CategoryTheory.Monad C)).obj xâœÂ¹).obj xâœ))","decl":"/-- Oh, monads are just monoids in the category of endofunctors (equivalence of categories). -/\n@[simps]\ndef monadMonEquiv : Monad C â‰Œ Mon_ (C â¥¤ C) where\n  functor := monadToMon _\n  inverse := monToMonad _\n  unitIso :=\n  { hom := { app := fun _ => { app := fun _ => ğŸ™ _ } }\n    inv := { app := fun _ => { app := fun _ => ğŸ™ _ } } }\n  counitIso :=\n  { hom := { app := fun _ => { hom := ğŸ™ _ } }\n    inv := { app := fun _ => { hom := ğŸ™ _ } } }\n\n-- Sanity check\n"}
{"name":"CategoryTheory.Monad.monadMonEquiv_unitIso_inv_app_toNatTrans_app","module":"Mathlib.CategoryTheory.Monad.EquivMon","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nxâœÂ¹ : CategoryTheory.Monad C\nxâœ : C\nâŠ¢ Eq (((CategoryTheory.Monad.monadMonEquiv C).unitIso.inv.app xâœÂ¹).app xâœ) (CategoryTheory.CategoryStruct.id ((((CategoryTheory.Monad.monadToMon C).comp (CategoryTheory.Monad.monToMonad C)).obj xâœÂ¹).obj xâœ))","decl":"/-- Oh, monads are just monoids in the category of endofunctors (equivalence of categories). -/\n@[simps]\ndef monadMonEquiv : Monad C â‰Œ Mon_ (C â¥¤ C) where\n  functor := monadToMon _\n  inverse := monToMonad _\n  unitIso :=\n  { hom := { app := fun _ => { app := fun _ => ğŸ™ _ } }\n    inv := { app := fun _ => { app := fun _ => ğŸ™ _ } } }\n  counitIso :=\n  { hom := { app := fun _ => { hom := ğŸ™ _ } }\n    inv := { app := fun _ => { hom := ğŸ™ _ } } }\n\n-- Sanity check\n"}
{"name":"CategoryTheory.Monad.monadMonEquiv_functor","module":"Mathlib.CategoryTheory.Monad.EquivMon","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nâŠ¢ Eq (CategoryTheory.Monad.monadMonEquiv C).functor (CategoryTheory.Monad.monadToMon C)","decl":"/-- Oh, monads are just monoids in the category of endofunctors (equivalence of categories). -/\n@[simps]\ndef monadMonEquiv : Monad C â‰Œ Mon_ (C â¥¤ C) where\n  functor := monadToMon _\n  inverse := monToMonad _\n  unitIso :=\n  { hom := { app := fun _ => { app := fun _ => ğŸ™ _ } }\n    inv := { app := fun _ => { app := fun _ => ğŸ™ _ } } }\n  counitIso :=\n  { hom := { app := fun _ => { hom := ğŸ™ _ } }\n    inv := { app := fun _ => { hom := ğŸ™ _ } } }\n\n-- Sanity check\n"}
