{"name":"CategoryTheory.Monad.toMon_one","module":"Mathlib.CategoryTheory.Monad.EquivMon","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nM : CategoryTheory.Monad C\n⊢ Eq M.toMon.one M.η","decl":"/-- To every `Monad C` we associated a monoid object in `C ⥤ C`. -/\n@[simps]\ndef toMon (M : Monad C) : Mon_ (C ⥤ C) where\n  X := (M : C ⥤ C)\n  one := M.η\n  mul := M.μ\n  mul_assoc := by ext; simp [M.assoc]\n\n"}
{"name":"CategoryTheory.Monad.toMon_mul","module":"Mathlib.CategoryTheory.Monad.EquivMon","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nM : CategoryTheory.Monad C\n⊢ Eq M.toMon.mul M.μ","decl":"/-- To every `Monad C` we associated a monoid object in `C ⥤ C`. -/\n@[simps]\ndef toMon (M : Monad C) : Mon_ (C ⥤ C) where\n  X := (M : C ⥤ C)\n  one := M.η\n  mul := M.μ\n  mul_assoc := by ext; simp [M.assoc]\n\n"}
{"name":"CategoryTheory.Monad.toMon_X","module":"Mathlib.CategoryTheory.Monad.EquivMon","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nM : CategoryTheory.Monad C\n⊢ Eq M.toMon.X M.toFunctor","decl":"/-- To every `Monad C` we associated a monoid object in `C ⥤ C`. -/\n@[simps]\ndef toMon (M : Monad C) : Mon_ (C ⥤ C) where\n  X := (M : C ⥤ C)\n  one := M.η\n  mul := M.μ\n  mul_assoc := by ext; simp [M.assoc]\n\n"}
{"name":"CategoryTheory.Monad.monadToMon_obj","module":"Mathlib.CategoryTheory.Monad.EquivMon","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nM : CategoryTheory.Monad C\n⊢ Eq ((CategoryTheory.Monad.monadToMon C).obj M) M.toMon","decl":"/-- Passing from `Monad C` to `Mon_ (C ⥤ C)` is functorial. -/\n@[simps]\ndef monadToMon : Monad C ⥤ Mon_ (C ⥤ C) where\n  obj := toMon\n  map f := { hom := f.toNatTrans }\n\n"}
{"name":"CategoryTheory.Monad.monadToMon_map_hom","module":"Mathlib.CategoryTheory.Monad.EquivMon","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.Monad C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Monad.monadToMon C).map f).hom f.toNatTrans","decl":"/-- Passing from `Monad C` to `Mon_ (C ⥤ C)` is functorial. -/\n@[simps]\ndef monadToMon : Monad C ⥤ Mon_ (C ⥤ C) where\n  obj := toMon\n  map f := { hom := f.toNatTrans }\n\n"}
{"name":"CategoryTheory.Monad.ofMon_η","module":"Mathlib.CategoryTheory.Monad.EquivMon","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nM : Mon_ (CategoryTheory.Functor C C)\n⊢ Eq (CategoryTheory.Monad.ofMon M).η M.one","decl":"/-- To every monoid object in `C ⥤ C` we associate a `Monad C`. -/\n@[simps η μ]\ndef ofMon (M : Mon_ (C ⥤ C)) : Monad C where\n  toFunctor := M.X\n  η := M.one\n  μ := M.mul\n  left_unit := fun X => by\n    -- Porting note: now using `erw`\n    erw [← whiskerLeft_app, ← NatTrans.comp_app, M.mul_one]\n    rfl\n  right_unit := fun X => by\n    -- Porting note: now using `erw`\n    erw [← whiskerRight_app, ← NatTrans.comp_app, M.one_mul]\n    rfl\n  assoc := fun X => by\n    rw [← whiskerLeft_app, ← whiskerRight_app, ← NatTrans.comp_app]\n    -- Porting note: had to add this step:\n    erw [M.mul_assoc]\n    simp\n\n-- Porting note: `@[simps]` fails to generate `ofMon_obj`:\n"}
{"name":"CategoryTheory.Monad.ofMon_μ","module":"Mathlib.CategoryTheory.Monad.EquivMon","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nM : Mon_ (CategoryTheory.Functor C C)\n⊢ Eq (CategoryTheory.Monad.ofMon M).μ M.mul","decl":"/-- To every monoid object in `C ⥤ C` we associate a `Monad C`. -/\n@[simps η μ]\ndef ofMon (M : Mon_ (C ⥤ C)) : Monad C where\n  toFunctor := M.X\n  η := M.one\n  μ := M.mul\n  left_unit := fun X => by\n    -- Porting note: now using `erw`\n    erw [← whiskerLeft_app, ← NatTrans.comp_app, M.mul_one]\n    rfl\n  right_unit := fun X => by\n    -- Porting note: now using `erw`\n    erw [← whiskerRight_app, ← NatTrans.comp_app, M.one_mul]\n    rfl\n  assoc := fun X => by\n    rw [← whiskerLeft_app, ← whiskerRight_app, ← NatTrans.comp_app]\n    -- Porting note: had to add this step:\n    erw [M.mul_assoc]\n    simp\n\n-- Porting note: `@[simps]` fails to generate `ofMon_obj`:\n"}
{"name":"CategoryTheory.Monad.ofMon_obj","module":"Mathlib.CategoryTheory.Monad.EquivMon","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nM : Mon_ (CategoryTheory.Functor C C)\nX : C\n⊢ Eq ((CategoryTheory.Monad.ofMon M).obj X) (M.X.obj X)","decl":"@[simp] lemma ofMon_obj (M : Mon_ (C ⥤ C)) (X : C) : (ofMon M).obj X = M.X.obj X := rfl\n\n"}
{"name":"CategoryTheory.Monad.monToMonad_map_toNatTrans","module":"Mathlib.CategoryTheory.Monad.EquivMon","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : Mon_ (CategoryTheory.Functor C C)\nf : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.Monad.monToMonad C).map f).toNatTrans f.hom","decl":"/-- Passing from `Mon_ (C ⥤ C)` to `Monad C` is functorial. -/\n@[simps]\ndef monToMonad : Mon_ (C ⥤ C) ⥤ Monad C where\n  obj := ofMon\n  map {X Y} f :=\n    { f.hom with\n      app_η := by\n        intro X\n        erw [← NatTrans.comp_app, f.one_hom]\n        simp only [Functor.id_obj, ofMon_obj, ofMon_η]\n      app_μ := by\n        intro Z\n        erw [← NatTrans.comp_app, f.mul_hom]\n        dsimp\n        simp only [Category.assoc, NatTrans.naturality, ofMon_obj, ofMon] }\n\n"}
{"name":"CategoryTheory.Monad.monToMonad_obj","module":"Mathlib.CategoryTheory.Monad.EquivMon","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nM : Mon_ (CategoryTheory.Functor C C)\n⊢ Eq ((CategoryTheory.Monad.monToMonad C).obj M) (CategoryTheory.Monad.ofMon M)","decl":"/-- Passing from `Mon_ (C ⥤ C)` to `Monad C` is functorial. -/\n@[simps]\ndef monToMonad : Mon_ (C ⥤ C) ⥤ Monad C where\n  obj := ofMon\n  map {X Y} f :=\n    { f.hom with\n      app_η := by\n        intro X\n        erw [← NatTrans.comp_app, f.one_hom]\n        simp only [Functor.id_obj, ofMon_obj, ofMon_η]\n      app_μ := by\n        intro Z\n        erw [← NatTrans.comp_app, f.mul_hom]\n        dsimp\n        simp only [Category.assoc, NatTrans.naturality, ofMon_obj, ofMon] }\n\n"}
{"name":"CategoryTheory.Monad.monadMonEquiv_counitIso_hom_app_hom","module":"Mathlib.CategoryTheory.Monad.EquivMon","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nx✝ : Mon_ (CategoryTheory.Functor C C)\n⊢ Eq ((CategoryTheory.Monad.monadMonEquiv C).counitIso.hom.app x✝).hom (CategoryTheory.CategoryStruct.id (((CategoryTheory.Monad.monToMonad C).comp (CategoryTheory.Monad.monadToMon C)).obj x✝).X)","decl":"/-- Oh, monads are just monoids in the category of endofunctors (equivalence of categories). -/\n@[simps]\ndef monadMonEquiv : Monad C ≌ Mon_ (C ⥤ C) where\n  functor := monadToMon _\n  inverse := monToMonad _\n  unitIso :=\n  { hom := { app := fun _ => { app := fun _ => 𝟙 _ } }\n    inv := { app := fun _ => { app := fun _ => 𝟙 _ } } }\n  counitIso :=\n  { hom := { app := fun _ => { hom := 𝟙 _ } }\n    inv := { app := fun _ => { hom := 𝟙 _ } } }\n\n-- Sanity check\n"}
{"name":"CategoryTheory.Monad.monadMonEquiv_inverse","module":"Mathlib.CategoryTheory.Monad.EquivMon","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Eq (CategoryTheory.Monad.monadMonEquiv C).inverse (CategoryTheory.Monad.monToMonad C)","decl":"/-- Oh, monads are just monoids in the category of endofunctors (equivalence of categories). -/\n@[simps]\ndef monadMonEquiv : Monad C ≌ Mon_ (C ⥤ C) where\n  functor := monadToMon _\n  inverse := monToMonad _\n  unitIso :=\n  { hom := { app := fun _ => { app := fun _ => 𝟙 _ } }\n    inv := { app := fun _ => { app := fun _ => 𝟙 _ } } }\n  counitIso :=\n  { hom := { app := fun _ => { hom := 𝟙 _ } }\n    inv := { app := fun _ => { hom := 𝟙 _ } } }\n\n-- Sanity check\n"}
{"name":"CategoryTheory.Monad.monadMonEquiv_counitIso_inv_app_hom","module":"Mathlib.CategoryTheory.Monad.EquivMon","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nx✝ : Mon_ (CategoryTheory.Functor C C)\n⊢ Eq ((CategoryTheory.Monad.monadMonEquiv C).counitIso.inv.app x✝).hom (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.id (Mon_ (CategoryTheory.Functor C C))).obj x✝).X)","decl":"/-- Oh, monads are just monoids in the category of endofunctors (equivalence of categories). -/\n@[simps]\ndef monadMonEquiv : Monad C ≌ Mon_ (C ⥤ C) where\n  functor := monadToMon _\n  inverse := monToMonad _\n  unitIso :=\n  { hom := { app := fun _ => { app := fun _ => 𝟙 _ } }\n    inv := { app := fun _ => { app := fun _ => 𝟙 _ } } }\n  counitIso :=\n  { hom := { app := fun _ => { hom := 𝟙 _ } }\n    inv := { app := fun _ => { hom := 𝟙 _ } } }\n\n-- Sanity check\n"}
{"name":"CategoryTheory.Monad.monadMonEquiv_unitIso_hom_app_toNatTrans_app","module":"Mathlib.CategoryTheory.Monad.EquivMon","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nx✝¹ : CategoryTheory.Monad C\nx✝ : C\n⊢ Eq (((CategoryTheory.Monad.monadMonEquiv C).unitIso.hom.app x✝¹).app x✝) (CategoryTheory.CategoryStruct.id (((CategoryTheory.Functor.id (CategoryTheory.Monad C)).obj x✝¹).obj x✝))","decl":"/-- Oh, monads are just monoids in the category of endofunctors (equivalence of categories). -/\n@[simps]\ndef monadMonEquiv : Monad C ≌ Mon_ (C ⥤ C) where\n  functor := monadToMon _\n  inverse := monToMonad _\n  unitIso :=\n  { hom := { app := fun _ => { app := fun _ => 𝟙 _ } }\n    inv := { app := fun _ => { app := fun _ => 𝟙 _ } } }\n  counitIso :=\n  { hom := { app := fun _ => { hom := 𝟙 _ } }\n    inv := { app := fun _ => { hom := 𝟙 _ } } }\n\n-- Sanity check\n"}
{"name":"CategoryTheory.Monad.monadMonEquiv_unitIso_inv_app_toNatTrans_app","module":"Mathlib.CategoryTheory.Monad.EquivMon","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nx✝¹ : CategoryTheory.Monad C\nx✝ : C\n⊢ Eq (((CategoryTheory.Monad.monadMonEquiv C).unitIso.inv.app x✝¹).app x✝) (CategoryTheory.CategoryStruct.id ((((CategoryTheory.Monad.monadToMon C).comp (CategoryTheory.Monad.monToMonad C)).obj x✝¹).obj x✝))","decl":"/-- Oh, monads are just monoids in the category of endofunctors (equivalence of categories). -/\n@[simps]\ndef monadMonEquiv : Monad C ≌ Mon_ (C ⥤ C) where\n  functor := monadToMon _\n  inverse := monToMonad _\n  unitIso :=\n  { hom := { app := fun _ => { app := fun _ => 𝟙 _ } }\n    inv := { app := fun _ => { app := fun _ => 𝟙 _ } } }\n  counitIso :=\n  { hom := { app := fun _ => { hom := 𝟙 _ } }\n    inv := { app := fun _ => { hom := 𝟙 _ } } }\n\n-- Sanity check\n"}
{"name":"CategoryTheory.Monad.monadMonEquiv_functor","module":"Mathlib.CategoryTheory.Monad.EquivMon","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Eq (CategoryTheory.Monad.monadMonEquiv C).functor (CategoryTheory.Monad.monadToMon C)","decl":"/-- Oh, monads are just monoids in the category of endofunctors (equivalence of categories). -/\n@[simps]\ndef monadMonEquiv : Monad C ≌ Mon_ (C ⥤ C) where\n  functor := monadToMon _\n  inverse := monToMonad _\n  unitIso :=\n  { hom := { app := fun _ => { app := fun _ => 𝟙 _ } }\n    inv := { app := fun _ => { app := fun _ => 𝟙 _ } } }\n  counitIso :=\n  { hom := { app := fun _ => { hom := 𝟙 _ } }\n    inv := { app := fun _ => { hom := 𝟙 _ } } }\n\n-- Sanity check\n"}
