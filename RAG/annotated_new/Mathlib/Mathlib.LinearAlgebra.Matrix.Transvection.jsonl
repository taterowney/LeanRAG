{"name":"Matrix.transvection_zero","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type u₂\ninst✝¹ : DecidableEq n\ninst✝ : CommRing R\ni j : n\n⊢ Eq (Matrix.transvection i j 0) 1","decl":"@[simp]\ntheorem transvection_zero : transvection i j (0 : R) = 1 := by simp [transvection]\n\n"}
{"name":"Matrix.updateRow_eq_transvection","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type u₂\ninst✝² : DecidableEq n\ninst✝¹ : CommRing R\ni j : n\ninst✝ : Finite n\nc : R\n⊢ Eq (Matrix.updateRow 1 i (HAdd.hAdd (1 i) (HSMul.hSMul c (1 j)))) (Matrix.transvection i j c)","decl":"/-- A transvection matrix is obtained from the identity by adding `c` times the `j`-th row to\nthe `i`-th row. -/\ntheorem updateRow_eq_transvection [Finite n] (c : R) :\n    updateRow (1 : Matrix n n R) i ((1 : Matrix n n R) i + c • (1 : Matrix n n R) j) =\n      transvection i j c := by\n  cases nonempty_fintype n\n  ext a b\n  by_cases ha : i = a\n  · by_cases hb : j = b\n    · simp only [ha, updateRow_self, Pi.add_apply, one_apply, Pi.smul_apply, hb, ↓reduceIte,\n        smul_eq_mul, mul_one, transvection, add_apply, StdBasisMatrix.apply_same]\n    · simp only [ha, updateRow_self, Pi.add_apply, one_apply, Pi.smul_apply, hb, ↓reduceIte,\n        smul_eq_mul, mul_zero, add_zero, transvection, add_apply, and_false, not_false_eq_true,\n        StdBasisMatrix.apply_of_ne]\n  · simp only [updateRow_ne, transvection, ha, Ne.symm ha, StdBasisMatrix.apply_of_ne, add_zero,\n      Algebra.id.smul_eq_mul, Ne, not_false_iff, DMatrix.add_apply, Pi.smul_apply,\n      mul_zero, false_and, add_apply]\n\n"}
{"name":"Matrix.transvection_mul_transvection_same","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type u₂\ninst✝² : DecidableEq n\ninst✝¹ : CommRing R\ni j : n\ninst✝ : Fintype n\nh : Ne i j\nc d : R\n⊢ Eq (HMul.hMul (Matrix.transvection i j c) (Matrix.transvection i j d)) (Matrix.transvection i j (HAdd.hAdd c d))","decl":"theorem transvection_mul_transvection_same (h : i ≠ j) (c d : R) :\n    transvection i j c * transvection i j d = transvection i j (c + d) := by\n  simp [transvection, Matrix.add_mul, Matrix.mul_add, h, h.symm, add_smul, add_assoc,\n    stdBasisMatrix_add]\n\n"}
{"name":"Matrix.transvection_mul_apply_same","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type u₂\ninst✝² : DecidableEq n\ninst✝¹ : CommRing R\ni j : n\ninst✝ : Fintype n\nb : n\nc : R\nM : Matrix n n R\n⊢ Eq (HMul.hMul (Matrix.transvection i j c) M i b) (HAdd.hAdd (M i b) (HMul.hMul c (M j b)))","decl":"@[simp]\ntheorem transvection_mul_apply_same (b : n) (c : R) (M : Matrix n n R) :\n    (transvection i j c * M) i b = M i b + c * M j b := by simp [transvection, Matrix.add_mul]\n\n"}
{"name":"Matrix.mul_transvection_apply_same","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type u₂\ninst✝² : DecidableEq n\ninst✝¹ : CommRing R\ni j : n\ninst✝ : Fintype n\na : n\nc : R\nM : Matrix n n R\n⊢ Eq (HMul.hMul M (Matrix.transvection i j c) a j) (HAdd.hAdd (M a j) (HMul.hMul c (M a i)))","decl":"@[simp]\ntheorem mul_transvection_apply_same (a : n) (c : R) (M : Matrix n n R) :\n    (M * transvection i j c) a j = M a j + c * M a i := by\n  simp [transvection, Matrix.mul_add, mul_comm]\n\n"}
{"name":"Matrix.transvection_mul_apply_of_ne","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type u₂\ninst✝² : DecidableEq n\ninst✝¹ : CommRing R\ni j : n\ninst✝ : Fintype n\na b : n\nha : Ne a i\nc : R\nM : Matrix n n R\n⊢ Eq (HMul.hMul (Matrix.transvection i j c) M a b) (M a b)","decl":"@[simp]\ntheorem transvection_mul_apply_of_ne (a b : n) (ha : a ≠ i) (c : R) (M : Matrix n n R) :\n    (transvection i j c * M) a b = M a b := by simp [transvection, Matrix.add_mul, ha]\n\n"}
{"name":"Matrix.mul_transvection_apply_of_ne","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type u₂\ninst✝² : DecidableEq n\ninst✝¹ : CommRing R\ni j : n\ninst✝ : Fintype n\na b : n\nhb : Ne b j\nc : R\nM : Matrix n n R\n⊢ Eq (HMul.hMul M (Matrix.transvection i j c) a b) (M a b)","decl":"@[simp]\ntheorem mul_transvection_apply_of_ne (a b : n) (hb : b ≠ j) (c : R) (M : Matrix n n R) :\n    (M * transvection i j c) a b = M a b := by simp [transvection, Matrix.mul_add, hb]\n\n"}
{"name":"Matrix.det_transvection_of_ne","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type u₂\ninst✝² : DecidableEq n\ninst✝¹ : CommRing R\ni j : n\ninst✝ : Fintype n\nh : Ne i j\nc : R\n⊢ Eq (Matrix.transvection i j c).det 1","decl":"@[simp]\ntheorem det_transvection_of_ne (h : i ≠ j) (c : R) : det (transvection i j c) = 1 := by\n  rw [← updateRow_eq_transvection i j, det_updateRow_add_smul_self _ h, det_one]\n\n"}
{"name":"Matrix.TransvectionStruct.hij","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type u₂\nself : Matrix.TransvectionStruct n R\n⊢ Ne self.i self.j","decl":"/-- A structure containing all the information from which one can build a nontrivial transvection.\nThis structure is easier to manipulate than transvections as one has a direct access to all the\nrelevant fields. -/\nstructure TransvectionStruct where\n  (i j : n)\n  hij : i ≠ j\n  c : R\n\n"}
{"name":"Matrix.TransvectionStruct.mk.injEq","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type u₂\ni✝ j✝ : n\nhij✝ : Ne i✝ j✝\nc✝ : R\ni j : n\nhij : Ne i j\nc : R\n⊢ Eq (Eq { i := i✝, j := j✝, hij := hij✝, c := c✝ } { i := i, j := j, hij := hij, c := c }) (And (Eq i✝ i) (And (Eq j✝ j) (Eq c✝ c)))","decl":"/-- A structure containing all the information from which one can build a nontrivial transvection.\nThis structure is easier to manipulate than transvections as one has a direct access to all the\nrelevant fields. -/\nstructure TransvectionStruct where\n  (i j : n)\n  hij : i ≠ j\n  c : R\n\n"}
{"name":"Matrix.TransvectionStruct.mk.inj","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type u₂\ni✝ j✝ : n\nhij✝ : Ne i✝ j✝\nc✝ : R\ni j : n\nhij : Ne i j\nc : R\nx✝ : Eq { i := i✝, j := j✝, hij := hij✝, c := c✝ } { i := i, j := j, hij := hij, c := c }\n⊢ And (Eq i✝ i) (And (Eq j✝ j) (Eq c✝ c))","decl":"/-- A structure containing all the information from which one can build a nontrivial transvection.\nThis structure is easier to manipulate than transvections as one has a direct access to all the\nrelevant fields. -/\nstructure TransvectionStruct where\n  (i j : n)\n  hij : i ≠ j\n  c : R\n\n"}
{"name":"Matrix.TransvectionStruct.mk.sizeOf_spec","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type u₂\ninst✝¹ : SizeOf n\ninst✝ : SizeOf R\ni j : n\nhij : Ne i j\nc : R\n⊢ Eq (SizeOf.sizeOf { i := i, j := j, hij := hij, c := c }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf i)) (SizeOf.sizeOf j)) (SizeOf.sizeOf c))","decl":"/-- A structure containing all the information from which one can build a nontrivial transvection.\nThis structure is easier to manipulate than transvections as one has a direct access to all the\nrelevant fields. -/\nstructure TransvectionStruct where\n  (i j : n)\n  hij : i ≠ j\n  c : R\n\n"}
{"name":"Matrix.instNonemptyTransvectionStructOfNontrivial","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type u₂\ninst✝ : Nontrivial n\n⊢ Nonempty (Matrix.TransvectionStruct n R)","decl":"instance [Nontrivial n] : Nonempty (TransvectionStruct n R) := by\n  choose x y hxy using exists_pair_ne n\n  exact ⟨⟨x, y, hxy, 0⟩⟩\n\n"}
{"name":"Matrix.TransvectionStruct.toMatrix_mk","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type u₂\ninst✝¹ : DecidableEq n\ninst✝ : CommRing R\ni j : n\nhij : Ne i j\nc : R\n⊢ Eq { i := i, j := j, hij := hij, c := c }.toMatrix (Matrix.transvection i j c)","decl":"@[simp]\ntheorem toMatrix_mk (i j : n) (hij : i ≠ j) (c : R) :\n    TransvectionStruct.toMatrix ⟨i, j, hij, c⟩ = transvection i j c :=\n  rfl\n\n"}
{"name":"Matrix.TransvectionStruct.det","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type u₂\ninst✝² : DecidableEq n\ninst✝¹ : CommRing R\ninst✝ : Fintype n\nt : Matrix.TransvectionStruct n R\n⊢ Eq t.toMatrix.det 1","decl":"@[simp]\nprotected theorem det [Fintype n] (t : TransvectionStruct n R) : det t.toMatrix = 1 :=\n  det_transvection_of_ne _ _ t.hij _\n\n"}
{"name":"Matrix.TransvectionStruct.det_toMatrix_prod","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\n𝕜 : Type u_3\ninst✝² : Field 𝕜\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nL : List (Matrix.TransvectionStruct n 𝕜)\n⊢ Eq (List.map Matrix.TransvectionStruct.toMatrix L).prod.det 1","decl":"@[simp]\ntheorem det_toMatrix_prod [Fintype n] (L : List (TransvectionStruct n 𝕜)) :\n    det (L.map toMatrix).prod = 1 := by\n  induction' L with t L IH\n  · simp\n  · simp [IH]\n\n"}
{"name":"Matrix.TransvectionStruct.inv_j","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type u₂\ninst✝ : CommRing R\nt : Matrix.TransvectionStruct n R\n⊢ Eq t.inv.j t.j","decl":"/-- The inverse of a `TransvectionStruct`, designed so that `t.inv.toMatrix` is the inverse of\n`t.toMatrix`. -/\n@[simps]\nprotected def inv (t : TransvectionStruct n R) : TransvectionStruct n R where\n  i := t.i\n  j := t.j\n  hij := t.hij\n  c := -t.c\n\n"}
{"name":"Matrix.TransvectionStruct.inv_c","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type u₂\ninst✝ : CommRing R\nt : Matrix.TransvectionStruct n R\n⊢ Eq t.inv.c (Neg.neg t.c)","decl":"/-- The inverse of a `TransvectionStruct`, designed so that `t.inv.toMatrix` is the inverse of\n`t.toMatrix`. -/\n@[simps]\nprotected def inv (t : TransvectionStruct n R) : TransvectionStruct n R where\n  i := t.i\n  j := t.j\n  hij := t.hij\n  c := -t.c\n\n"}
{"name":"Matrix.TransvectionStruct.inv_i","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type u₂\ninst✝ : CommRing R\nt : Matrix.TransvectionStruct n R\n⊢ Eq t.inv.i t.i","decl":"/-- The inverse of a `TransvectionStruct`, designed so that `t.inv.toMatrix` is the inverse of\n`t.toMatrix`. -/\n@[simps]\nprotected def inv (t : TransvectionStruct n R) : TransvectionStruct n R where\n  i := t.i\n  j := t.j\n  hij := t.hij\n  c := -t.c\n\n"}
{"name":"Matrix.TransvectionStruct.inv_mul","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type u₂\ninst✝² : DecidableEq n\ninst✝¹ : CommRing R\ninst✝ : Fintype n\nt : Matrix.TransvectionStruct n R\n⊢ Eq (HMul.hMul t.inv.toMatrix t.toMatrix) 1","decl":"theorem inv_mul (t : TransvectionStruct n R) : t.inv.toMatrix * t.toMatrix = 1 := by\n  rcases t with ⟨_, _, t_hij⟩\n  simp [toMatrix, transvection_mul_transvection_same, t_hij]\n\n"}
{"name":"Matrix.TransvectionStruct.mul_inv","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type u₂\ninst✝² : DecidableEq n\ninst✝¹ : CommRing R\ninst✝ : Fintype n\nt : Matrix.TransvectionStruct n R\n⊢ Eq (HMul.hMul t.toMatrix t.inv.toMatrix) 1","decl":"theorem mul_inv (t : TransvectionStruct n R) : t.toMatrix * t.inv.toMatrix = 1 := by\n  rcases t with ⟨_, _, t_hij⟩\n  simp [toMatrix, transvection_mul_transvection_same, t_hij]\n\n"}
{"name":"Matrix.TransvectionStruct.reverse_inv_prod_mul_prod","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type u₂\ninst✝² : DecidableEq n\ninst✝¹ : CommRing R\ninst✝ : Fintype n\nL : List (Matrix.TransvectionStruct n R)\n⊢ Eq (HMul.hMul (List.map (Function.comp Matrix.TransvectionStruct.toMatrix Matrix.TransvectionStruct.inv) L.reverse).prod (List.map Matrix.TransvectionStruct.toMatrix L).prod) 1","decl":"theorem reverse_inv_prod_mul_prod (L : List (TransvectionStruct n R)) :\n    (L.reverse.map (toMatrix ∘ TransvectionStruct.inv)).prod * (L.map toMatrix).prod = 1 := by\n  induction' L with t L IH\n  · simp\n  · suffices\n      (L.reverse.map (toMatrix ∘ TransvectionStruct.inv)).prod * (t.inv.toMatrix * t.toMatrix) *\n          (L.map toMatrix).prod = 1\n      by simpa [Matrix.mul_assoc]\n    simpa [inv_mul] using IH\n\n"}
{"name":"Matrix.TransvectionStruct.prod_mul_reverse_inv_prod","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type u₂\ninst✝² : DecidableEq n\ninst✝¹ : CommRing R\ninst✝ : Fintype n\nL : List (Matrix.TransvectionStruct n R)\n⊢ Eq (HMul.hMul (List.map Matrix.TransvectionStruct.toMatrix L).prod (List.map (Function.comp Matrix.TransvectionStruct.toMatrix Matrix.TransvectionStruct.inv) L.reverse).prod) 1","decl":"theorem prod_mul_reverse_inv_prod (L : List (TransvectionStruct n R)) :\n    (L.map toMatrix).prod * (L.reverse.map (toMatrix ∘ TransvectionStruct.inv)).prod = 1 := by\n  induction' L with t L IH\n  · simp\n  · suffices\n      t.toMatrix *\n            ((L.map toMatrix).prod * (L.reverse.map (toMatrix ∘ TransvectionStruct.inv)).prod) *\n          t.inv.toMatrix = 1\n      by simpa [Matrix.mul_assoc]\n    simp_rw [IH, Matrix.mul_one, t.mul_inv]\n\n"}
{"name":"Matrix.mem_range_scalar_of_commute_transvectionStruct","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type u₂\ninst✝² : DecidableEq n\ninst✝¹ : CommRing R\ninst✝ : Fintype n\nM : Matrix n n R\nhM : ∀ (t : Matrix.TransvectionStruct n R), Commute t.toMatrix M\n⊢ Membership.mem (Set.range ⇑(Matrix.scalar n)) M","decl":"/-- `M` is a scalar matrix if it commutes with every nontrivial transvection (elementary matrix). -/\ntheorem _root_.Matrix.mem_range_scalar_of_commute_transvectionStruct {M : Matrix n n R}\n    (hM : ∀ t : TransvectionStruct n R, Commute t.toMatrix M) :\n    M ∈ Set.range (Matrix.scalar n) := by\n  refine mem_range_scalar_of_commute_stdBasisMatrix ?_\n  intro i j hij\n  simpa [transvection, mul_add, add_mul] using (hM ⟨i, j, hij, 1⟩).eq\n\n"}
{"name":"Matrix.mem_range_scalar_iff_commute_transvectionStruct","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type u₂\ninst✝² : DecidableEq n\ninst✝¹ : CommRing R\ninst✝ : Fintype n\nM : Matrix n n R\n⊢ Iff (Membership.mem (Set.range ⇑(Matrix.scalar n)) M) (∀ (t : Matrix.TransvectionStruct n R), Commute t.toMatrix M)","decl":"theorem _root_.Matrix.mem_range_scalar_iff_commute_transvectionStruct {M : Matrix n n R} :\n    M ∈ Set.range (Matrix.scalar n) ↔ ∀ t : TransvectionStruct n R, Commute t.toMatrix M := by\n  refine ⟨fun h t => ?_, mem_range_scalar_of_commute_transvectionStruct⟩\n  rw [mem_range_scalar_iff_commute_stdBasisMatrix] at h\n  refine (Commute.one_left M).add_left ?_\n  convert (h _ _ t.hij).smul_left t.c using 1\n  rw [smul_stdBasisMatrix, smul_eq_mul, mul_one]\n\n"}
{"name":"Matrix.TransvectionStruct.toMatrix_sumInl","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\np : Type u_2\nR : Type u₂\ninst✝² : DecidableEq n\ninst✝¹ : DecidableEq p\ninst✝ : CommRing R\nt : Matrix.TransvectionStruct n R\n⊢ Eq (Matrix.TransvectionStruct.sumInl p t).toMatrix (Matrix.fromBlocks t.toMatrix 0 0 1)","decl":"theorem toMatrix_sumInl (t : TransvectionStruct n R) :\n    (t.sumInl p).toMatrix = fromBlocks t.toMatrix 0 0 1 := by\n  cases t\n  ext a b\n  cases' a with a a <;> cases' b with b b\n  · by_cases h : a = b <;> simp [TransvectionStruct.sumInl, transvection, h, stdBasisMatrix]\n  · simp [TransvectionStruct.sumInl, transvection]\n  · simp [TransvectionStruct.sumInl, transvection]\n  · by_cases h : a = b <;> simp [TransvectionStruct.sumInl, transvection, h]\n\n"}
{"name":"Matrix.TransvectionStruct.sumInl_toMatrix_prod_mul","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\np : Type u_2\nR : Type u₂\ninst✝⁴ : DecidableEq n\ninst✝³ : DecidableEq p\ninst✝² : CommRing R\ninst✝¹ : Fintype n\ninst✝ : Fintype p\nM : Matrix n n R\nL : List (Matrix.TransvectionStruct n R)\nN : Matrix p p R\n⊢ Eq (HMul.hMul (List.map (Function.comp Matrix.TransvectionStruct.toMatrix (Matrix.TransvectionStruct.sumInl p)) L).prod (Matrix.fromBlocks M 0 0 N)) (Matrix.fromBlocks (HMul.hMul (List.map Matrix.TransvectionStruct.toMatrix L).prod M) 0 0 N)","decl":"@[simp]\ntheorem sumInl_toMatrix_prod_mul [Fintype n] [Fintype p] (M : Matrix n n R)\n    (L : List (TransvectionStruct n R)) (N : Matrix p p R) :\n    (L.map (toMatrix ∘ sumInl p)).prod * fromBlocks M 0 0 N =\n      fromBlocks ((L.map toMatrix).prod * M) 0 0 N := by\n  induction' L with t L IH\n  · simp\n  · simp [Matrix.mul_assoc, IH, toMatrix_sumInl, fromBlocks_multiply]\n\n"}
{"name":"Matrix.TransvectionStruct.mul_sumInl_toMatrix_prod","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\np : Type u_2\nR : Type u₂\ninst✝⁴ : DecidableEq n\ninst✝³ : DecidableEq p\ninst✝² : CommRing R\ninst✝¹ : Fintype n\ninst✝ : Fintype p\nM : Matrix n n R\nL : List (Matrix.TransvectionStruct n R)\nN : Matrix p p R\n⊢ Eq (HMul.hMul (Matrix.fromBlocks M 0 0 N) (List.map (Function.comp Matrix.TransvectionStruct.toMatrix (Matrix.TransvectionStruct.sumInl p)) L).prod) (Matrix.fromBlocks (HMul.hMul M (List.map Matrix.TransvectionStruct.toMatrix L).prod) 0 0 N)","decl":"@[simp]\ntheorem mul_sumInl_toMatrix_prod [Fintype n] [Fintype p] (M : Matrix n n R)\n    (L : List (TransvectionStruct n R)) (N : Matrix p p R) :\n    fromBlocks M 0 0 N * (L.map (toMatrix ∘ sumInl p)).prod =\n      fromBlocks (M * (L.map toMatrix).prod) 0 0 N := by\n  induction' L with t L IH generalizing M N\n  · simp\n  · simp [IH, toMatrix_sumInl, fromBlocks_multiply]\n\n"}
{"name":"Matrix.TransvectionStruct.toMatrix_reindexEquiv","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\np : Type u_2\nR : Type u₂\ninst✝⁴ : DecidableEq n\ninst✝³ : DecidableEq p\ninst✝² : CommRing R\ninst✝¹ : Fintype n\ninst✝ : Fintype p\ne : Equiv n p\nt : Matrix.TransvectionStruct n R\n⊢ Eq (Matrix.TransvectionStruct.reindexEquiv e t).toMatrix ((Matrix.reindexAlgEquiv R R e) t.toMatrix)","decl":"theorem toMatrix_reindexEquiv (e : n ≃ p) (t : TransvectionStruct n R) :\n    (t.reindexEquiv e).toMatrix = reindexAlgEquiv R _ e t.toMatrix := by\n  rcases t with ⟨t_i, t_j, _⟩\n  ext a b\n  simp only [reindexEquiv, transvection, mul_boole, Algebra.id.smul_eq_mul, toMatrix_mk,\n    submatrix_apply, reindex_apply, DMatrix.add_apply, Pi.smul_apply, reindexAlgEquiv_apply]\n  by_cases ha : e t_i = a <;> by_cases hb : e t_j = b <;> by_cases hab : a = b <;>\n    simp [ha, hb, hab, ← e.apply_eq_iff_eq_symm_apply, stdBasisMatrix]\n\n"}
{"name":"Matrix.TransvectionStruct.toMatrix_reindexEquiv_prod","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\np : Type u_2\nR : Type u₂\ninst✝⁴ : DecidableEq n\ninst✝³ : DecidableEq p\ninst✝² : CommRing R\ninst✝¹ : Fintype n\ninst✝ : Fintype p\ne : Equiv n p\nL : List (Matrix.TransvectionStruct n R)\n⊢ Eq (List.map (Function.comp Matrix.TransvectionStruct.toMatrix (Matrix.TransvectionStruct.reindexEquiv e)) L).prod ((Matrix.reindexAlgEquiv R R e) (List.map Matrix.TransvectionStruct.toMatrix L).prod)","decl":"theorem toMatrix_reindexEquiv_prod (e : n ≃ p) (L : List (TransvectionStruct n R)) :\n    (L.map (toMatrix ∘ reindexEquiv e)).prod = reindexAlgEquiv R _ e (L.map toMatrix).prod := by\n  induction' L with t L IH\n  · simp\n  · simp only [toMatrix_reindexEquiv, IH, Function.comp_apply, List.prod_cons,\n      reindexAlgEquiv_apply, List.map]\n    exact (reindexAlgEquiv_mul R _ _ _ _).symm\n\n"}
{"name":"Matrix.Pivot.length_listTransvecCol","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"𝕜 : Type u_3\ninst✝ : Field 𝕜\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) 𝕜\n⊢ Eq (Matrix.Pivot.listTransvecCol M).length r","decl":"@[simp]\ntheorem length_listTransvecCol : (listTransvecCol M).length = r := by simp [listTransvecCol]\n\n"}
{"name":"Matrix.Pivot.listTransvecCol_getElem","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"𝕜 : Type u_3\ninst✝ : Field 𝕜\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) 𝕜\ni : Nat\nh : LT.lt i (Matrix.Pivot.listTransvecCol M).length\n⊢ Eq (GetElem.getElem (Matrix.Pivot.listTransvecCol M) i ⋯) (Matrix.transvection (Sum.inl ⟨i, ⋯⟩) (Sum.inr Unit.unit) (HDiv.hDiv (Neg.neg (M (Sum.inl ⟨i, ⋯⟩) (Sum.inr Unit.unit))) (M (Sum.inr Unit.unit) (Sum.inr Unit.unit))))","decl":"theorem listTransvecCol_getElem {i : ℕ} (h : i < (listTransvecCol M).length) :\n    (listTransvecCol M)[i] =\n      letI i' : Fin r := ⟨i, length_listTransvecCol M ▸ h⟩\n      transvection (inl i') (inr unit) <| -M (inl i') (inr unit) / M (inr unit) (inr unit) := by\n  simp [listTransvecCol]\n\n"}
{"name":"Matrix.Pivot.listTransvecCol_get","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"𝕜 : Type u_3\ninst✝ : Field 𝕜\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) 𝕜\ni : Fin (Matrix.Pivot.listTransvecCol M).length\n⊢ Eq ((Matrix.Pivot.listTransvecCol M).get i) (Matrix.transvection (Sum.inl (Fin.cast ⋯ i)) (Sum.inr Unit.unit) (HDiv.hDiv (Neg.neg (M (Sum.inl (Fin.cast ⋯ i)) (Sum.inr Unit.unit))) (M (Sum.inr Unit.unit) (Sum.inr Unit.unit))))","decl":"@[deprecated listTransvecCol_getElem (since := \"2024-08-03\")]\ntheorem listTransvecCol_get (i : Fin (listTransvecCol M).length) :\n    (listTransvecCol M).get i =\n      letI i' := Fin.cast (length_listTransvecCol M) i\n      transvection (inl i') (inr unit) <| -M (inl i') (inr unit) / M (inr unit) (inr unit) :=\n  listTransvecCol_getElem _ i.isLt\n\n"}
{"name":"Matrix.Pivot.length_listTransvecRow","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"𝕜 : Type u_3\ninst✝ : Field 𝕜\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) 𝕜\n⊢ Eq (Matrix.Pivot.listTransvecRow M).length r","decl":"@[simp]\ntheorem length_listTransvecRow : (listTransvecRow M).length = r := by simp [listTransvecRow]\n\n"}
{"name":"Matrix.Pivot.listTransvecRow_getElem","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"𝕜 : Type u_3\ninst✝ : Field 𝕜\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) 𝕜\ni : Nat\nh : LT.lt i (Matrix.Pivot.listTransvecRow M).length\n⊢ Eq (GetElem.getElem (Matrix.Pivot.listTransvecRow M) i ⋯) (Matrix.transvection (Sum.inr Unit.unit) (Sum.inl ⟨i, ⋯⟩) (HDiv.hDiv (Neg.neg (M (Sum.inr Unit.unit) (Sum.inl ⟨i, ⋯⟩))) (M (Sum.inr Unit.unit) (Sum.inr Unit.unit))))","decl":"theorem listTransvecRow_getElem {i : ℕ} (h : i < (listTransvecRow M).length) :\n    (listTransvecRow M)[i] =\n      letI i' : Fin r := ⟨i, length_listTransvecRow M ▸ h⟩\n      transvection (inr unit) (inl i') <| -M (inr unit) (inl i') / M (inr unit) (inr unit) := by\n  simp [listTransvecRow, Fin.cast]\n\n"}
{"name":"Matrix.Pivot.listTransvecRow_get","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"𝕜 : Type u_3\ninst✝ : Field 𝕜\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) 𝕜\ni : Fin (Matrix.Pivot.listTransvecRow M).length\n⊢ Eq ((Matrix.Pivot.listTransvecRow M).get i) (Matrix.transvection (Sum.inr Unit.unit) (Sum.inl (Fin.cast ⋯ i)) (HDiv.hDiv (Neg.neg (M (Sum.inr Unit.unit) (Sum.inl (Fin.cast ⋯ i)))) (M (Sum.inr Unit.unit) (Sum.inr Unit.unit))))","decl":"@[deprecated listTransvecRow_getElem (since := \"2024-08-03\")]\ntheorem listTransvecRow_get (i : Fin (listTransvecRow M).length) :\n    (listTransvecRow M).get i =\n      letI i' := Fin.cast (length_listTransvecRow M) i\n      transvection (inr unit) (inl i') <| -M (inr unit) (inl i') / M (inr unit) (inr unit) :=\n  listTransvecRow_getElem _ i.isLt\n\n"}
{"name":"Matrix.Pivot.listTransvecCol_mul_last_row_drop","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"𝕜 : Type u_3\ninst✝ : Field 𝕜\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) 𝕜\ni : Sum (Fin r) Unit\nk : Nat\nhk : LE.le k r\n⊢ Eq (HMul.hMul (List.drop k (Matrix.Pivot.listTransvecCol M)).prod M (Sum.inr Unit.unit) i) (M (Sum.inr Unit.unit) i)","decl":"/-- Multiplying by some of the matrices in `listTransvecCol M` does not change the last row. -/\ntheorem listTransvecCol_mul_last_row_drop (i : Fin r ⊕ Unit) {k : ℕ} (hk : k ≤ r) :\n    (((listTransvecCol M).drop k).prod * M) (inr unit) i = M (inr unit) i := by\n  induction hk using Nat.decreasingInduction with\n  | of_succ n hn IH =>\n    have hn' : n < (listTransvecCol M).length := by simpa [listTransvecCol] using hn\n    rw [List.drop_eq_getElem_cons hn']\n    simpa [listTransvecCol, Matrix.mul_assoc]\n  | self =>\n    simp only [length_listTransvecCol, le_refl, List.drop_eq_nil_of_le, List.prod_nil,\n      Matrix.one_mul]\n\n"}
{"name":"Matrix.Pivot.listTransvecCol_mul_last_row","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"𝕜 : Type u_3\ninst✝ : Field 𝕜\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) 𝕜\ni : Sum (Fin r) Unit\n⊢ Eq (HMul.hMul (Matrix.Pivot.listTransvecCol M).prod M (Sum.inr Unit.unit) i) (M (Sum.inr Unit.unit) i)","decl":"/-- Multiplying by all the matrices in `listTransvecCol M` does not change the last row. -/\ntheorem listTransvecCol_mul_last_row (i : Fin r ⊕ Unit) :\n    ((listTransvecCol M).prod * M) (inr unit) i = M (inr unit) i := by\n  simpa using listTransvecCol_mul_last_row_drop M i (zero_le _)\n\n"}
{"name":"Matrix.Pivot.listTransvecCol_mul_last_col","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"𝕜 : Type u_3\ninst✝ : Field 𝕜\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) 𝕜\nhM : Ne (M (Sum.inr Unit.unit) (Sum.inr Unit.unit)) 0\ni : Fin r\n⊢ Eq (HMul.hMul (Matrix.Pivot.listTransvecCol M).prod M (Sum.inl i) (Sum.inr Unit.unit)) 0","decl":"/-- Multiplying by all the matrices in `listTransvecCol M` kills all the coefficients in the\nlast column but the last one. -/\ntheorem listTransvecCol_mul_last_col (hM : M (inr unit) (inr unit) ≠ 0) (i : Fin r) :\n    ((listTransvecCol M).prod * M) (inl i) (inr unit) = 0 := by\n  suffices H :\n    ∀ k : ℕ,\n      k ≤ r →\n        (((listTransvecCol M).drop k).prod * M) (inl i) (inr unit) =\n          if k ≤ i then 0 else M (inl i) (inr unit) by\n    simpa only [List.drop, _root_.zero_le, ite_true] using H 0 (zero_le _)\n  intro k hk\n  induction hk using Nat.decreasingInduction with\n  | of_succ n hn IH =>\n    have hn' : n < (listTransvecCol M).length := by simpa [listTransvecCol] using hn\n    let n' : Fin r := ⟨n, hn⟩\n    rw [List.drop_eq_getElem_cons hn']\n    have A :\n      (listTransvecCol M)[n] =\n        transvection (inl n') (inr unit) (-M (inl n') (inr unit) / M (inr unit) (inr unit)) := by\n      simp [n', listTransvecCol]\n    simp only [Matrix.mul_assoc, A, List.prod_cons]\n    by_cases h : n' = i\n    · have hni : n = i := by\n        cases i\n        simp only [n', Fin.mk_eq_mk] at h\n        simp [h]\n      simp only [h, transvection_mul_apply_same, IH, ← hni, add_le_iff_nonpos_right,\n          listTransvecCol_mul_last_row_drop _ _ hn]\n      field_simp [hM]\n    · have hni : n ≠ i := by\n        rintro rfl\n        cases i\n        simp [n'] at h\n      simp only [ne_eq, inl.injEq, Ne.symm h, not_false_eq_true, transvection_mul_apply_of_ne]\n      rw [IH]\n      rcases le_or_lt (n + 1) i with (hi | hi)\n      · simp only [hi, n.le_succ.trans hi, if_true]\n      · rw [if_neg, if_neg]\n        · simpa only [hni.symm, not_le, or_false] using Nat.lt_succ_iff_lt_or_eq.1 hi\n        · simpa only [not_le] using hi\n  | self =>\n    simp only [length_listTransvecCol, le_refl, List.drop_eq_nil_of_le, List.prod_nil,\n      Matrix.one_mul]\n    rw [if_neg]\n    simpa only [not_le] using i.2\n\n"}
{"name":"Matrix.Pivot.mul_listTransvecRow_last_col_take","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"𝕜 : Type u_3\ninst✝ : Field 𝕜\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) 𝕜\ni : Sum (Fin r) Unit\nk : Nat\nhk : LE.le k r\n⊢ Eq (HMul.hMul M (List.take k (Matrix.Pivot.listTransvecRow M)).prod i (Sum.inr Unit.unit)) (M i (Sum.inr Unit.unit))","decl":"/-- Multiplying by some of the matrices in `listTransvecRow M` does not change the last column. -/\ntheorem mul_listTransvecRow_last_col_take (i : Fin r ⊕ Unit) {k : ℕ} (hk : k ≤ r) :\n    (M * ((listTransvecRow M).take k).prod) i (inr unit) = M i (inr unit) := by\n  induction' k with k IH\n  · simp only [Matrix.mul_one, List.take_zero, List.prod_nil, List.take, Matrix.mul_one]\n  · have hkr : k < r := hk\n    let k' : Fin r := ⟨k, hkr⟩\n    have :\n      (listTransvecRow M)[k]? =\n        ↑(transvection (inr Unit.unit) (inl k')\n            (-M (inr Unit.unit) (inl k') / M (inr Unit.unit) (inr Unit.unit))) := by\n      simp only [k', listTransvecRow, List.ofFnNthVal, hkr, dif_pos, List.getElem?_ofFn]\n    simp only [List.take_succ, ← Matrix.mul_assoc, this, List.prod_append, Matrix.mul_one,\n      List.prod_cons, List.prod_nil, Option.toList_some]\n    rw [mul_transvection_apply_of_ne, IH hkr.le]\n    simp only [Ne, not_false_iff, reduceCtorEq]\n\n"}
{"name":"Matrix.Pivot.mul_listTransvecRow_last_col","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"𝕜 : Type u_3\ninst✝ : Field 𝕜\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) 𝕜\ni : Sum (Fin r) Unit\n⊢ Eq (HMul.hMul M (Matrix.Pivot.listTransvecRow M).prod i (Sum.inr Unit.unit)) (M i (Sum.inr Unit.unit))","decl":"/-- Multiplying by all the matrices in `listTransvecRow M` does not change the last column. -/\ntheorem mul_listTransvecRow_last_col (i : Fin r ⊕ Unit) :\n    (M * (listTransvecRow M).prod) i (inr unit) = M i (inr unit) := by\n  have A : (listTransvecRow M).length = r := by simp [listTransvecRow]\n  rw [← List.take_length (listTransvecRow M), A]\n  simpa using mul_listTransvecRow_last_col_take M i le_rfl\n\n"}
{"name":"Matrix.Pivot.mul_listTransvecRow_last_row","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"𝕜 : Type u_3\ninst✝ : Field 𝕜\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) 𝕜\nhM : Ne (M (Sum.inr Unit.unit) (Sum.inr Unit.unit)) 0\ni : Fin r\n⊢ Eq (HMul.hMul M (Matrix.Pivot.listTransvecRow M).prod (Sum.inr Unit.unit) (Sum.inl i)) 0","decl":"/-- Multiplying by all the matrices in `listTransvecRow M` kills all the coefficients in the\nlast row but the last one. -/\ntheorem mul_listTransvecRow_last_row (hM : M (inr unit) (inr unit) ≠ 0) (i : Fin r) :\n    (M * (listTransvecRow M).prod) (inr unit) (inl i) = 0 := by\n  suffices H :\n    ∀ k : ℕ,\n      k ≤ r →\n        (M * ((listTransvecRow M).take k).prod) (inr unit) (inl i) =\n          if k ≤ i then M (inr unit) (inl i) else 0 by\n    have A : (listTransvecRow M).length = r := by simp [listTransvecRow]\n    rw [← List.take_length (listTransvecRow M), A]\n    have : ¬r ≤ i := by simp\n    simpa only [this, ite_eq_right_iff] using H r le_rfl\n  intro k hk\n  induction' k with n IH\n  · simp only [if_true, Matrix.mul_one, List.take_zero, zero_le', List.prod_nil]\n  · have hnr : n < r := hk\n    let n' : Fin r := ⟨n, hnr⟩\n    have A :\n      (listTransvecRow M)[n]? =\n        ↑(transvection (inr unit) (inl n')\n        (-M (inr unit) (inl n') / M (inr unit) (inr unit))) := by\n      simp only [n', listTransvecRow, List.ofFnNthVal, hnr, dif_pos, List.getElem?_ofFn]\n    simp only [List.take_succ, A, ← Matrix.mul_assoc, List.prod_append, Matrix.mul_one,\n      List.prod_cons, List.prod_nil, Option.toList_some]\n    by_cases h : n' = i\n    · have hni : n = i := by\n        cases i\n        simp only [n', Fin.mk_eq_mk] at h\n        simp only [h]\n      have : ¬n.succ ≤ i := by simp only [← hni, n.lt_succ_self, not_le]\n      simp only [h, mul_transvection_apply_same, List.take, if_false,\n        mul_listTransvecRow_last_col_take _ _ hnr.le, hni.le, this, if_true, IH hnr.le]\n      field_simp [hM]\n    · have hni : n ≠ i := by\n        rintro rfl\n        cases i\n        tauto\n      simp only [IH hnr.le, Ne, mul_transvection_apply_of_ne, Ne.symm h, inl.injEq,\n        not_false_eq_true]\n      rcases le_or_lt (n + 1) i with (hi | hi)\n      · simp [hi, n.le_succ.trans hi, if_true]\n      · rw [if_neg, if_neg]\n        · simpa only [not_le] using hi\n        · simpa only [hni.symm, not_le, or_false] using Nat.lt_succ_iff_lt_or_eq.1 hi\n\n"}
{"name":"Matrix.Pivot.listTransvecCol_mul_mul_listTransvecRow_last_col","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"𝕜 : Type u_3\ninst✝ : Field 𝕜\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) 𝕜\nhM : Ne (M (Sum.inr Unit.unit) (Sum.inr Unit.unit)) 0\ni : Fin r\n⊢ Eq (HMul.hMul (HMul.hMul (Matrix.Pivot.listTransvecCol M).prod M) (Matrix.Pivot.listTransvecRow M).prod (Sum.inr Unit.unit) (Sum.inl i)) 0","decl":"/-- Multiplying by all the matrices either in `listTransvecCol M` and `listTransvecRow M` kills\nall the coefficients in the last row but the last one. -/\ntheorem listTransvecCol_mul_mul_listTransvecRow_last_col (hM : M (inr unit) (inr unit) ≠ 0)\n    (i : Fin r) :\n    ((listTransvecCol M).prod * M * (listTransvecRow M).prod) (inr unit) (inl i) = 0 := by\n  have : listTransvecRow M = listTransvecRow ((listTransvecCol M).prod * M) := by\n    simp [listTransvecRow, listTransvecCol_mul_last_row]\n  rw [this]\n  apply mul_listTransvecRow_last_row\n  simpa [listTransvecCol_mul_last_row] using hM\n\n"}
{"name":"Matrix.Pivot.listTransvecCol_mul_mul_listTransvecRow_last_row","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"𝕜 : Type u_3\ninst✝ : Field 𝕜\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) 𝕜\nhM : Ne (M (Sum.inr Unit.unit) (Sum.inr Unit.unit)) 0\ni : Fin r\n⊢ Eq (HMul.hMul (HMul.hMul (Matrix.Pivot.listTransvecCol M).prod M) (Matrix.Pivot.listTransvecRow M).prod (Sum.inl i) (Sum.inr Unit.unit)) 0","decl":"/-- Multiplying by all the matrices either in `listTransvecCol M` and `listTransvecRow M` kills\nall the coefficients in the last column but the last one. -/\ntheorem listTransvecCol_mul_mul_listTransvecRow_last_row (hM : M (inr unit) (inr unit) ≠ 0)\n    (i : Fin r) :\n    ((listTransvecCol M).prod * M * (listTransvecRow M).prod) (inl i) (inr unit) = 0 := by\n  have : listTransvecCol M = listTransvecCol (M * (listTransvecRow M).prod) := by\n    simp [listTransvecCol, mul_listTransvecRow_last_col]\n  rw [this, Matrix.mul_assoc]\n  apply listTransvecCol_mul_last_col\n  simpa [mul_listTransvecRow_last_col] using hM\n\n"}
{"name":"Matrix.Pivot.isTwoBlockDiagonal_listTransvecCol_mul_mul_listTransvecRow","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"𝕜 : Type u_3\ninst✝ : Field 𝕜\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) 𝕜\nhM : Ne (M (Sum.inr Unit.unit) (Sum.inr Unit.unit)) 0\n⊢ (HMul.hMul (HMul.hMul (Matrix.Pivot.listTransvecCol M).prod M) (Matrix.Pivot.listTransvecRow M).prod).IsTwoBlockDiagonal","decl":"/-- Multiplying by all the matrices either in `listTransvecCol M` and `listTransvecRow M` turns\nthe matrix in block-diagonal form. -/\ntheorem isTwoBlockDiagonal_listTransvecCol_mul_mul_listTransvecRow\n    (hM : M (inr unit) (inr unit) ≠ 0) :\n    IsTwoBlockDiagonal ((listTransvecCol M).prod * M * (listTransvecRow M).prod) := by\n  constructor\n  · ext i j\n    have : j = unit := by simp only [eq_iff_true_of_subsingleton]\n    simp [toBlocks₁₂, this, listTransvecCol_mul_mul_listTransvecRow_last_row M hM]\n  · ext i j\n    have : i = unit := by simp only [eq_iff_true_of_subsingleton]\n    simp [toBlocks₂₁, this, listTransvecCol_mul_mul_listTransvecRow_last_col M hM]\n\n"}
{"name":"Matrix.Pivot.exists_isTwoBlockDiagonal_of_ne_zero","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"𝕜 : Type u_3\ninst✝ : Field 𝕜\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) 𝕜\nhM : Ne (M (Sum.inr Unit.unit) (Sum.inr Unit.unit)) 0\n⊢ Exists fun L => Exists fun L' => (HMul.hMul (HMul.hMul (List.map Matrix.TransvectionStruct.toMatrix L).prod M) (List.map Matrix.TransvectionStruct.toMatrix L').prod).IsTwoBlockDiagonal","decl":"/-- There exist two lists of `TransvectionStruct` such that multiplying by them on the left and\non the right makes a matrix block-diagonal, when the last coefficient is nonzero. -/\ntheorem exists_isTwoBlockDiagonal_of_ne_zero (hM : M (inr unit) (inr unit) ≠ 0) :\n    ∃ L L' : List (TransvectionStruct (Fin r ⊕ Unit) 𝕜),\n      IsTwoBlockDiagonal ((L.map toMatrix).prod * M * (L'.map toMatrix).prod) := by\n  let L : List (TransvectionStruct (Fin r ⊕ Unit) 𝕜) :=\n    List.ofFn fun i : Fin r =>\n      ⟨inl i, inr unit, by simp, -M (inl i) (inr unit) / M (inr unit) (inr unit)⟩\n  let L' : List (TransvectionStruct (Fin r ⊕ Unit) 𝕜) :=\n    List.ofFn fun i : Fin r =>\n      ⟨inr unit, inl i, by simp, -M (inr unit) (inl i) / M (inr unit) (inr unit)⟩\n  refine ⟨L, L', ?_⟩\n  have A : L.map toMatrix = listTransvecCol M := by simp [L, listTransvecCol, Function.comp_def]\n  have B : L'.map toMatrix = listTransvecRow M := by simp [L', listTransvecRow, Function.comp_def]\n  rw [A, B]\n  exact isTwoBlockDiagonal_listTransvecCol_mul_mul_listTransvecRow M hM\n\n"}
{"name":"Matrix.Pivot.exists_isTwoBlockDiagonal_list_transvec_mul_mul_list_transvec","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"𝕜 : Type u_3\ninst✝ : Field 𝕜\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) 𝕜\n⊢ Exists fun L => Exists fun L' => (HMul.hMul (HMul.hMul (List.map Matrix.TransvectionStruct.toMatrix L).prod M) (List.map Matrix.TransvectionStruct.toMatrix L').prod).IsTwoBlockDiagonal","decl":"/-- There exist two lists of `TransvectionStruct` such that multiplying by them on the left and\non the right makes a matrix block-diagonal. -/\ntheorem exists_isTwoBlockDiagonal_list_transvec_mul_mul_list_transvec\n    (M : Matrix (Fin r ⊕ Unit) (Fin r ⊕ Unit) 𝕜) :\n    ∃ L L' : List (TransvectionStruct (Fin r ⊕ Unit) 𝕜),\n      IsTwoBlockDiagonal ((L.map toMatrix).prod * M * (L'.map toMatrix).prod) := by\n  by_cases H : IsTwoBlockDiagonal M\n  · refine ⟨List.nil, List.nil, by simpa using H⟩\n  -- we have already proved this when the last coefficient is nonzero\n  by_cases hM : M (inr unit) (inr unit) ≠ 0\n  · exact exists_isTwoBlockDiagonal_of_ne_zero M hM\n  -- when the last coefficient is zero but there is a nonzero coefficient on the last row or the\n  -- last column, we will first put this nonzero coefficient in last position, and then argue as\n  -- above.\n  push_neg at hM\n  simp only [not_and_or, IsTwoBlockDiagonal, toBlocks₁₂, toBlocks₂₁, ← Matrix.ext_iff] at H\n  have : ∃ i : Fin r, M (inl i) (inr unit) ≠ 0 ∨ M (inr unit) (inl i) ≠ 0 := by\n    cases' H with H H\n    · contrapose! H\n      rintro i ⟨⟩\n      exact (H i).1\n    · contrapose! H\n      rintro ⟨⟩ j\n      exact (H j).2\n  rcases this with ⟨i, h | h⟩\n  · let M' := transvection (inr Unit.unit) (inl i) 1 * M\n    have hM' : M' (inr unit) (inr unit) ≠ 0 := by simpa [M', hM]\n    rcases exists_isTwoBlockDiagonal_of_ne_zero M' hM' with ⟨L, L', hLL'⟩\n    rw [Matrix.mul_assoc] at hLL'\n    refine ⟨L ++ [⟨inr unit, inl i, by simp, 1⟩], L', ?_⟩\n    simp only [List.map_append, List.prod_append, Matrix.mul_one, toMatrix_mk, List.prod_cons,\n      List.prod_nil, List.map, Matrix.mul_assoc (L.map toMatrix).prod]\n    exact hLL'\n  · let M' := M * transvection (inl i) (inr unit) 1\n    have hM' : M' (inr unit) (inr unit) ≠ 0 := by simpa [M', hM]\n    rcases exists_isTwoBlockDiagonal_of_ne_zero M' hM' with ⟨L, L', hLL'⟩\n    refine ⟨L, ⟨inl i, inr unit, by simp, 1⟩::L', ?_⟩\n    simp only [← Matrix.mul_assoc, toMatrix_mk, List.prod_cons, List.map]\n    rw [Matrix.mul_assoc (L.map toMatrix).prod]\n    exact hLL'\n\n"}
{"name":"Matrix.Pivot.exists_list_transvec_mul_mul_list_transvec_eq_diagonal_induction","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"𝕜 : Type u_3\ninst✝ : Field 𝕜\nr : Nat\nIH : ∀ (M : Matrix (Fin r) (Fin r) 𝕜), Exists fun L₀ => Exists fun L₀' => Exists fun D₀ => Eq (HMul.hMul (HMul.hMul (List.map Matrix.TransvectionStruct.toMatrix L₀).prod M) (List.map Matrix.TransvectionStruct.toMatrix L₀').prod) (Matrix.diagonal D₀)\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) 𝕜\n⊢ Exists fun L => Exists fun L' => Exists fun D => Eq (HMul.hMul (HMul.hMul (List.map Matrix.TransvectionStruct.toMatrix L).prod M) (List.map Matrix.TransvectionStruct.toMatrix L').prod) (Matrix.diagonal D)","decl":"/-- Inductive step for the reduction: if one knows that any size `r` matrix can be reduced to\ndiagonal form by elementary operations, then one deduces it for matrices over `Fin r ⊕ Unit`. -/\ntheorem exists_list_transvec_mul_mul_list_transvec_eq_diagonal_induction\n    (IH :\n      ∀ M : Matrix (Fin r) (Fin r) 𝕜,\n        ∃ (L₀ L₀' : List (TransvectionStruct (Fin r) 𝕜)) (D₀ : Fin r → 𝕜),\n          (L₀.map toMatrix).prod * M * (L₀'.map toMatrix).prod = diagonal D₀)\n    (M : Matrix (Fin r ⊕ Unit) (Fin r ⊕ Unit) 𝕜) :\n    ∃ (L L' : List (TransvectionStruct (Fin r ⊕ Unit) 𝕜)) (D : Fin r ⊕ Unit → 𝕜),\n      (L.map toMatrix).prod * M * (L'.map toMatrix).prod = diagonal D := by\n  rcases exists_isTwoBlockDiagonal_list_transvec_mul_mul_list_transvec M with ⟨L₁, L₁', hM⟩\n  let M' := (L₁.map toMatrix).prod * M * (L₁'.map toMatrix).prod\n  let M'' := toBlocks₁₁ M'\n  rcases IH M'' with ⟨L₀, L₀', D₀, h₀⟩\n  set c := M' (inr unit) (inr unit)\n  refine\n    ⟨L₀.map (sumInl Unit) ++ L₁, L₁' ++ L₀'.map (sumInl Unit),\n      Sum.elim D₀ fun _ => M' (inr unit) (inr unit), ?_⟩\n  suffices (L₀.map (toMatrix ∘ sumInl Unit)).prod * M' * (L₀'.map (toMatrix ∘ sumInl Unit)).prod =\n      diagonal (Sum.elim D₀ fun _ => c) by\n    simpa [M', c, Matrix.mul_assoc]\n  have : M' = fromBlocks M'' 0 0 (diagonal fun _ => c) := by\n    -- Porting note: simplified proof, because `congr` didn't work anymore\n    rw [← fromBlocks_toBlocks M', hM.1, hM.2]\n    rfl\n  rw [this]\n  simp [h₀]\n\n"}
{"name":"Matrix.Pivot.reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\np : Type u_2\n𝕜 : Type u_3\ninst✝⁴ : Field 𝕜\ninst✝³ : DecidableEq n\ninst✝² : DecidableEq p\ninst✝¹ : Fintype n\ninst✝ : Fintype p\nM : Matrix p p 𝕜\ne : Equiv p n\nH : Exists fun L => Exists fun L' => Exists fun D => Eq (HMul.hMul (HMul.hMul (List.map Matrix.TransvectionStruct.toMatrix L).prod ((Matrix.reindexAlgEquiv 𝕜 𝕜 e) M)) (List.map Matrix.TransvectionStruct.toMatrix L').prod) (Matrix.diagonal D)\n⊢ Exists fun L => Exists fun L' => Exists fun D => Eq (HMul.hMul (HMul.hMul (List.map Matrix.TransvectionStruct.toMatrix L).prod M) (List.map Matrix.TransvectionStruct.toMatrix L').prod) (Matrix.diagonal D)","decl":"/-- Reduction to diagonal form by elementary operations is invariant under reindexing. -/\ntheorem reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal (M : Matrix p p 𝕜)\n    (e : p ≃ n)\n    (H :\n      ∃ (L L' : List (TransvectionStruct n 𝕜)) (D : n → 𝕜),\n        (L.map toMatrix).prod * Matrix.reindexAlgEquiv 𝕜 _ e M * (L'.map toMatrix).prod =\n          diagonal D) :\n    ∃ (L L' : List (TransvectionStruct p 𝕜)) (D : p → 𝕜),\n      (L.map toMatrix).prod * M * (L'.map toMatrix).prod = diagonal D := by\n  rcases H with ⟨L₀, L₀', D₀, h₀⟩\n  refine ⟨L₀.map (reindexEquiv e.symm), L₀'.map (reindexEquiv e.symm), D₀ ∘ e, ?_⟩\n  have : M = reindexAlgEquiv 𝕜 _ e.symm (reindexAlgEquiv 𝕜 _ e M) := by\n    simp only [Equiv.symm_symm, submatrix_submatrix, reindex_apply, submatrix_id_id,\n      Equiv.symm_comp_self, reindexAlgEquiv_apply]\n  rw [this]\n  simp only [toMatrix_reindexEquiv_prod, List.map_map, reindexAlgEquiv_apply]\n  simp only [← reindexAlgEquiv_apply 𝕜, ← reindexAlgEquiv_mul, h₀]\n  simp only [Equiv.symm_symm, reindex_apply, submatrix_diagonal_equiv, reindexAlgEquiv_apply]\n\n"}
{"name":"Matrix.Pivot.exists_list_transvec_mul_mul_list_transvec_eq_diagonal_aux","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"𝕜 : Type u_3\ninst✝² : Field 𝕜\nn : Type\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nM : Matrix n n 𝕜\n⊢ Exists fun L => Exists fun L' => Exists fun D => Eq (HMul.hMul (HMul.hMul (List.map Matrix.TransvectionStruct.toMatrix L).prod M) (List.map Matrix.TransvectionStruct.toMatrix L').prod) (Matrix.diagonal D)","decl":"/-- Any matrix can be reduced to diagonal form by elementary operations. Formulated here on `Type 0`\nbecause we will make an induction using `Fin r`.\nSee `exists_list_transvec_mul_mul_list_transvec_eq_diagonal` for the general version (which follows\nfrom this one and reindexing). -/\ntheorem exists_list_transvec_mul_mul_list_transvec_eq_diagonal_aux (n : Type) [Fintype n]\n    [DecidableEq n] (M : Matrix n n 𝕜) :\n    ∃ (L L' : List (TransvectionStruct n 𝕜)) (D : n → 𝕜),\n      (L.map toMatrix).prod * M * (L'.map toMatrix).prod = diagonal D := by\n  induction' hn : Fintype.card n with r IH generalizing n M\n  · refine ⟨List.nil, List.nil, fun _ => 1, ?_⟩\n    ext i j\n    rw [Fintype.card_eq_zero_iff] at hn\n    exact hn.elim' i\n  · have e : n ≃ Fin r ⊕ Unit := by\n      refine Fintype.equivOfCardEq ?_\n      rw [hn]\n      rw [@Fintype.card_sum (Fin r) Unit _ _]\n      simp\n    apply reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal M e\n    apply\n      exists_list_transvec_mul_mul_list_transvec_eq_diagonal_induction fun N =>\n        IH (Fin r) N (by simp)\n\n"}
{"name":"Matrix.Pivot.exists_list_transvec_mul_mul_list_transvec_eq_diagonal","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\n𝕜 : Type u_3\ninst✝² : Field 𝕜\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n 𝕜\n⊢ Exists fun L => Exists fun L' => Exists fun D => Eq (HMul.hMul (HMul.hMul (List.map Matrix.TransvectionStruct.toMatrix L).prod M) (List.map Matrix.TransvectionStruct.toMatrix L').prod) (Matrix.diagonal D)","decl":"/-- Any matrix can be reduced to diagonal form by elementary operations. -/\ntheorem exists_list_transvec_mul_mul_list_transvec_eq_diagonal (M : Matrix n n 𝕜) :\n    ∃ (L L' : List (TransvectionStruct n 𝕜)) (D : n → 𝕜),\n      (L.map toMatrix).prod * M * (L'.map toMatrix).prod = diagonal D := by\n  have e : n ≃ Fin (Fintype.card n) := Fintype.equivOfCardEq (by simp)\n  apply reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal M e\n  apply exists_list_transvec_mul_mul_list_transvec_eq_diagonal_aux\n\n"}
{"name":"Matrix.Pivot.exists_list_transvec_mul_diagonal_mul_list_transvec","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\n𝕜 : Type u_3\ninst✝² : Field 𝕜\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n 𝕜\n⊢ Exists fun L => Exists fun L' => Exists fun D => Eq M (HMul.hMul (HMul.hMul (List.map Matrix.TransvectionStruct.toMatrix L).prod (Matrix.diagonal D)) (List.map Matrix.TransvectionStruct.toMatrix L').prod)","decl":"/-- Any matrix can be written as the product of transvections, a diagonal matrix, and\ntransvections. -/\ntheorem exists_list_transvec_mul_diagonal_mul_list_transvec (M : Matrix n n 𝕜) :\n    ∃ (L L' : List (TransvectionStruct n 𝕜)) (D : n → 𝕜),\n      M = (L.map toMatrix).prod * diagonal D * (L'.map toMatrix).prod := by\n  rcases exists_list_transvec_mul_mul_list_transvec_eq_diagonal M with ⟨L, L', D, h⟩\n  refine ⟨L.reverse.map TransvectionStruct.inv, L'.reverse.map TransvectionStruct.inv, D, ?_⟩\n  suffices\n    M =\n      (L.reverse.map (toMatrix ∘ TransvectionStruct.inv)).prod * (L.map toMatrix).prod * M *\n        ((L'.map toMatrix).prod * (L'.reverse.map (toMatrix ∘ TransvectionStruct.inv)).prod)\n    by simpa [← h, Matrix.mul_assoc]\n  rw [reverse_inv_prod_mul_prod, prod_mul_reverse_inv_prod, Matrix.one_mul, Matrix.mul_one]\n\n"}
{"name":"Matrix.diagonal_transvection_induction","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\n𝕜 : Type u_3\ninst✝² : Field 𝕜\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nP : Matrix n n 𝕜 → Prop\nM : Matrix n n 𝕜\nhdiag : ∀ (D : n → 𝕜), Eq (Matrix.diagonal D).det M.det → P (Matrix.diagonal D)\nhtransvec : ∀ (t : Matrix.TransvectionStruct n 𝕜), P t.toMatrix\nhmul : ∀ (A B : Matrix n n 𝕜), P A → P B → P (HMul.hMul A B)\n⊢ P M","decl":"/-- Induction principle for matrices based on transvections: if a property is true for all diagonal\nmatrices, all transvections, and is stable under product, then it is true for all matrices. This is\nthe useful way to say that matrices are generated by diagonal matrices and transvections.\n\nWe state a slightly more general version: to prove a property for a matrix `M`, it suffices to\nassume that the diagonal matrices we consider have the same determinant as `M`. This is useful to\nobtain similar principles for `SLₙ` or `GLₙ`. -/\ntheorem diagonal_transvection_induction (P : Matrix n n 𝕜 → Prop) (M : Matrix n n 𝕜)\n    (hdiag : ∀ D : n → 𝕜, det (diagonal D) = det M → P (diagonal D))\n    (htransvec : ∀ t : TransvectionStruct n 𝕜, P t.toMatrix) (hmul : ∀ A B, P A → P B → P (A * B)) :\n    P M := by\n  rcases exists_list_transvec_mul_diagonal_mul_list_transvec M with ⟨L, L', D, h⟩\n  have PD : P (diagonal D) := hdiag D (by simp [h])\n  suffices H :\n    ∀ (L₁ L₂ : List (TransvectionStruct n 𝕜)) (E : Matrix n n 𝕜),\n      P E → P ((L₁.map toMatrix).prod * E * (L₂.map toMatrix).prod) by\n    rw [h]\n    apply H L L'\n    exact PD\n  intro L₁ L₂ E PE\n  induction' L₁ with t L₁ IH\n  · simp only [Matrix.one_mul, List.prod_nil, List.map]\n    induction' L₂ with t L₂ IH generalizing E\n    · simpa\n    · simp only [← Matrix.mul_assoc, List.prod_cons, List.map]\n      apply IH\n      exact hmul _ _ PE (htransvec _)\n  · simp only [Matrix.mul_assoc, List.prod_cons, List.map] at IH ⊢\n    exact hmul _ _ (htransvec _) IH\n\n"}
{"name":"Matrix.diagonal_transvection_induction_of_det_ne_zero","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\n𝕜 : Type u_3\ninst✝² : Field 𝕜\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nP : Matrix n n 𝕜 → Prop\nM : Matrix n n 𝕜\nhMdet : Ne M.det 0\nhdiag : ∀ (D : n → 𝕜), Ne (Matrix.diagonal D).det 0 → P (Matrix.diagonal D)\nhtransvec : ∀ (t : Matrix.TransvectionStruct n 𝕜), P t.toMatrix\nhmul : ∀ (A B : Matrix n n 𝕜), Ne A.det 0 → Ne B.det 0 → P A → P B → P (HMul.hMul A B)\n⊢ P M","decl":"/-- Induction principle for invertible matrices based on transvections: if a property is true for\nall invertible diagonal matrices, all transvections, and is stable under product of invertible\nmatrices, then it is true for all invertible matrices. This is the useful way to say that\ninvertible matrices are generated by invertible diagonal matrices and transvections. -/\ntheorem diagonal_transvection_induction_of_det_ne_zero (P : Matrix n n 𝕜 → Prop) (M : Matrix n n 𝕜)\n    (hMdet : det M ≠ 0) (hdiag : ∀ D : n → 𝕜, det (diagonal D) ≠ 0 → P (diagonal D))\n    (htransvec : ∀ t : TransvectionStruct n 𝕜, P t.toMatrix)\n    (hmul : ∀ A B, det A ≠ 0 → det B ≠ 0 → P A → P B → P (A * B)) : P M := by\n  let Q : Matrix n n 𝕜 → Prop := fun N => det N ≠ 0 ∧ P N\n  have : Q M := by\n    apply diagonal_transvection_induction Q M\n    · intro D hD\n      have detD : det (diagonal D) ≠ 0 := by\n        rw [hD]\n        exact hMdet\n      exact ⟨detD, hdiag _ detD⟩\n    · intro t\n      exact ⟨by simp, htransvec t⟩\n    · intro A B QA QB\n      exact ⟨by simp [QA.1, QB.1], hmul A B QA.1 QB.1 QA.2 QB.2⟩\n  exact this.2\n\n"}
