{"name":"Matrix.transvection_zero","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type uâ‚‚\ninstâœÂ¹ : DecidableEq n\ninstâœ : CommRing R\ni j : n\nâŠ¢ Eq (Matrix.transvection i j 0) 1","decl":"@[simp]\ntheorem transvection_zero : transvection i j (0 : R) = 1 := by simp [transvection]\n\n"}
{"name":"Matrix.updateRow_eq_transvection","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type uâ‚‚\ninstâœÂ² : DecidableEq n\ninstâœÂ¹ : CommRing R\ni j : n\ninstâœ : Finite n\nc : R\nâŠ¢ Eq (Matrix.updateRow 1 i (HAdd.hAdd (1 i) (HSMul.hSMul c (1 j)))) (Matrix.transvection i j c)","decl":"/-- A transvection matrix is obtained from the identity by adding `c` times the `j`-th row to\nthe `i`-th row. -/\ntheorem updateRow_eq_transvection [Finite n] (c : R) :\n    updateRow (1 : Matrix n n R) i ((1 : Matrix n n R) i + c â€¢ (1 : Matrix n n R) j) =\n      transvection i j c := by\n  cases nonempty_fintype n\n  ext a b\n  by_cases ha : i = a\n  Â· by_cases hb : j = b\n    Â· simp only [ha, updateRow_self, Pi.add_apply, one_apply, Pi.smul_apply, hb, â†“reduceIte,\n        smul_eq_mul, mul_one, transvection, add_apply, StdBasisMatrix.apply_same]\n    Â· simp only [ha, updateRow_self, Pi.add_apply, one_apply, Pi.smul_apply, hb, â†“reduceIte,\n        smul_eq_mul, mul_zero, add_zero, transvection, add_apply, and_false, not_false_eq_true,\n        StdBasisMatrix.apply_of_ne]\n  Â· simp only [updateRow_ne, transvection, ha, Ne.symm ha, StdBasisMatrix.apply_of_ne, add_zero,\n      Algebra.id.smul_eq_mul, Ne, not_false_iff, DMatrix.add_apply, Pi.smul_apply,\n      mul_zero, false_and, add_apply]\n\n"}
{"name":"Matrix.transvection_mul_transvection_same","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type uâ‚‚\ninstâœÂ² : DecidableEq n\ninstâœÂ¹ : CommRing R\ni j : n\ninstâœ : Fintype n\nh : Ne i j\nc d : R\nâŠ¢ Eq (HMul.hMul (Matrix.transvection i j c) (Matrix.transvection i j d)) (Matrix.transvection i j (HAdd.hAdd c d))","decl":"theorem transvection_mul_transvection_same (h : i â‰  j) (c d : R) :\n    transvection i j c * transvection i j d = transvection i j (c + d) := by\n  simp [transvection, Matrix.add_mul, Matrix.mul_add, h, h.symm, add_smul, add_assoc,\n    stdBasisMatrix_add]\n\n"}
{"name":"Matrix.transvection_mul_apply_same","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type uâ‚‚\ninstâœÂ² : DecidableEq n\ninstâœÂ¹ : CommRing R\ni j : n\ninstâœ : Fintype n\nb : n\nc : R\nM : Matrix n n R\nâŠ¢ Eq (HMul.hMul (Matrix.transvection i j c) M i b) (HAdd.hAdd (M i b) (HMul.hMul c (M j b)))","decl":"@[simp]\ntheorem transvection_mul_apply_same (b : n) (c : R) (M : Matrix n n R) :\n    (transvection i j c * M) i b = M i b + c * M j b := by simp [transvection, Matrix.add_mul]\n\n"}
{"name":"Matrix.mul_transvection_apply_same","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type uâ‚‚\ninstâœÂ² : DecidableEq n\ninstâœÂ¹ : CommRing R\ni j : n\ninstâœ : Fintype n\na : n\nc : R\nM : Matrix n n R\nâŠ¢ Eq (HMul.hMul M (Matrix.transvection i j c) a j) (HAdd.hAdd (M a j) (HMul.hMul c (M a i)))","decl":"@[simp]\ntheorem mul_transvection_apply_same (a : n) (c : R) (M : Matrix n n R) :\n    (M * transvection i j c) a j = M a j + c * M a i := by\n  simp [transvection, Matrix.mul_add, mul_comm]\n\n"}
{"name":"Matrix.transvection_mul_apply_of_ne","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type uâ‚‚\ninstâœÂ² : DecidableEq n\ninstâœÂ¹ : CommRing R\ni j : n\ninstâœ : Fintype n\na b : n\nha : Ne a i\nc : R\nM : Matrix n n R\nâŠ¢ Eq (HMul.hMul (Matrix.transvection i j c) M a b) (M a b)","decl":"@[simp]\ntheorem transvection_mul_apply_of_ne (a b : n) (ha : a â‰  i) (c : R) (M : Matrix n n R) :\n    (transvection i j c * M) a b = M a b := by simp [transvection, Matrix.add_mul, ha]\n\n"}
{"name":"Matrix.mul_transvection_apply_of_ne","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type uâ‚‚\ninstâœÂ² : DecidableEq n\ninstâœÂ¹ : CommRing R\ni j : n\ninstâœ : Fintype n\na b : n\nhb : Ne b j\nc : R\nM : Matrix n n R\nâŠ¢ Eq (HMul.hMul M (Matrix.transvection i j c) a b) (M a b)","decl":"@[simp]\ntheorem mul_transvection_apply_of_ne (a b : n) (hb : b â‰  j) (c : R) (M : Matrix n n R) :\n    (M * transvection i j c) a b = M a b := by simp [transvection, Matrix.mul_add, hb]\n\n"}
{"name":"Matrix.det_transvection_of_ne","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type uâ‚‚\ninstâœÂ² : DecidableEq n\ninstâœÂ¹ : CommRing R\ni j : n\ninstâœ : Fintype n\nh : Ne i j\nc : R\nâŠ¢ Eq (Matrix.transvection i j c).det 1","decl":"@[simp]\ntheorem det_transvection_of_ne (h : i â‰  j) (c : R) : det (transvection i j c) = 1 := by\n  rw [â† updateRow_eq_transvection i j, det_updateRow_add_smul_self _ h, det_one]\n\n"}
{"name":"Matrix.TransvectionStruct.hij","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type uâ‚‚\nself : Matrix.TransvectionStruct n R\nâŠ¢ Ne self.i self.j","decl":"/-- A structure containing all the information from which one can build a nontrivial transvection.\nThis structure is easier to manipulate than transvections as one has a direct access to all the\nrelevant fields. -/\nstructure TransvectionStruct where\n  (i j : n)\n  hij : i â‰  j\n  c : R\n\n"}
{"name":"Matrix.TransvectionStruct.mk.injEq","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type uâ‚‚\niâœ jâœ : n\nhijâœ : Ne iâœ jâœ\ncâœ : R\ni j : n\nhij : Ne i j\nc : R\nâŠ¢ Eq (Eq { i := iâœ, j := jâœ, hij := hijâœ, c := câœ } { i := i, j := j, hij := hij, c := c }) (And (Eq iâœ i) (And (Eq jâœ j) (Eq câœ c)))","decl":"/-- A structure containing all the information from which one can build a nontrivial transvection.\nThis structure is easier to manipulate than transvections as one has a direct access to all the\nrelevant fields. -/\nstructure TransvectionStruct where\n  (i j : n)\n  hij : i â‰  j\n  c : R\n\n"}
{"name":"Matrix.TransvectionStruct.mk.inj","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type uâ‚‚\niâœ jâœ : n\nhijâœ : Ne iâœ jâœ\ncâœ : R\ni j : n\nhij : Ne i j\nc : R\nxâœ : Eq { i := iâœ, j := jâœ, hij := hijâœ, c := câœ } { i := i, j := j, hij := hij, c := c }\nâŠ¢ And (Eq iâœ i) (And (Eq jâœ j) (Eq câœ c))","decl":"/-- A structure containing all the information from which one can build a nontrivial transvection.\nThis structure is easier to manipulate than transvections as one has a direct access to all the\nrelevant fields. -/\nstructure TransvectionStruct where\n  (i j : n)\n  hij : i â‰  j\n  c : R\n\n"}
{"name":"Matrix.TransvectionStruct.mk.sizeOf_spec","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type uâ‚‚\ninstâœÂ¹ : SizeOf n\ninstâœ : SizeOf R\ni j : n\nhij : Ne i j\nc : R\nâŠ¢ Eq (SizeOf.sizeOf { i := i, j := j, hij := hij, c := c }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf i)) (SizeOf.sizeOf j)) (SizeOf.sizeOf c))","decl":"/-- A structure containing all the information from which one can build a nontrivial transvection.\nThis structure is easier to manipulate than transvections as one has a direct access to all the\nrelevant fields. -/\nstructure TransvectionStruct where\n  (i j : n)\n  hij : i â‰  j\n  c : R\n\n"}
{"name":"Matrix.instNonemptyTransvectionStructOfNontrivial","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type uâ‚‚\ninstâœ : Nontrivial n\nâŠ¢ Nonempty (Matrix.TransvectionStruct n R)","decl":"instance [Nontrivial n] : Nonempty (TransvectionStruct n R) := by\n  choose x y hxy using exists_pair_ne n\n  exact âŸ¨âŸ¨x, y, hxy, 0âŸ©âŸ©\n\n"}
{"name":"Matrix.TransvectionStruct.toMatrix_mk","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type uâ‚‚\ninstâœÂ¹ : DecidableEq n\ninstâœ : CommRing R\ni j : n\nhij : Ne i j\nc : R\nâŠ¢ Eq { i := i, j := j, hij := hij, c := c }.toMatrix (Matrix.transvection i j c)","decl":"@[simp]\ntheorem toMatrix_mk (i j : n) (hij : i â‰  j) (c : R) :\n    TransvectionStruct.toMatrix âŸ¨i, j, hij, câŸ© = transvection i j c :=\n  rfl\n\n"}
{"name":"Matrix.TransvectionStruct.det","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type uâ‚‚\ninstâœÂ² : DecidableEq n\ninstâœÂ¹ : CommRing R\ninstâœ : Fintype n\nt : Matrix.TransvectionStruct n R\nâŠ¢ Eq t.toMatrix.det 1","decl":"@[simp]\nprotected theorem det [Fintype n] (t : TransvectionStruct n R) : det t.toMatrix = 1 :=\n  det_transvection_of_ne _ _ t.hij _\n\n"}
{"name":"Matrix.TransvectionStruct.det_toMatrix_prod","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nğ•œ : Type u_3\ninstâœÂ² : Field ğ•œ\ninstâœÂ¹ : DecidableEq n\ninstâœ : Fintype n\nL : List (Matrix.TransvectionStruct n ğ•œ)\nâŠ¢ Eq (List.map Matrix.TransvectionStruct.toMatrix L).prod.det 1","decl":"@[simp]\ntheorem det_toMatrix_prod [Fintype n] (L : List (TransvectionStruct n ğ•œ)) :\n    det (L.map toMatrix).prod = 1 := by\n  induction' L with t L IH\n  Â· simp\n  Â· simp [IH]\n\n"}
{"name":"Matrix.TransvectionStruct.inv_j","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type uâ‚‚\ninstâœ : CommRing R\nt : Matrix.TransvectionStruct n R\nâŠ¢ Eq t.inv.j t.j","decl":"/-- The inverse of a `TransvectionStruct`, designed so that `t.inv.toMatrix` is the inverse of\n`t.toMatrix`. -/\n@[simps]\nprotected def inv (t : TransvectionStruct n R) : TransvectionStruct n R where\n  i := t.i\n  j := t.j\n  hij := t.hij\n  c := -t.c\n\n"}
{"name":"Matrix.TransvectionStruct.inv_c","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type uâ‚‚\ninstâœ : CommRing R\nt : Matrix.TransvectionStruct n R\nâŠ¢ Eq t.inv.c (Neg.neg t.c)","decl":"/-- The inverse of a `TransvectionStruct`, designed so that `t.inv.toMatrix` is the inverse of\n`t.toMatrix`. -/\n@[simps]\nprotected def inv (t : TransvectionStruct n R) : TransvectionStruct n R where\n  i := t.i\n  j := t.j\n  hij := t.hij\n  c := -t.c\n\n"}
{"name":"Matrix.TransvectionStruct.inv_i","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type uâ‚‚\ninstâœ : CommRing R\nt : Matrix.TransvectionStruct n R\nâŠ¢ Eq t.inv.i t.i","decl":"/-- The inverse of a `TransvectionStruct`, designed so that `t.inv.toMatrix` is the inverse of\n`t.toMatrix`. -/\n@[simps]\nprotected def inv (t : TransvectionStruct n R) : TransvectionStruct n R where\n  i := t.i\n  j := t.j\n  hij := t.hij\n  c := -t.c\n\n"}
{"name":"Matrix.TransvectionStruct.inv_mul","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type uâ‚‚\ninstâœÂ² : DecidableEq n\ninstâœÂ¹ : CommRing R\ninstâœ : Fintype n\nt : Matrix.TransvectionStruct n R\nâŠ¢ Eq (HMul.hMul t.inv.toMatrix t.toMatrix) 1","decl":"theorem inv_mul (t : TransvectionStruct n R) : t.inv.toMatrix * t.toMatrix = 1 := by\n  rcases t with âŸ¨_, _, t_hijâŸ©\n  simp [toMatrix, transvection_mul_transvection_same, t_hij]\n\n"}
{"name":"Matrix.TransvectionStruct.mul_inv","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type uâ‚‚\ninstâœÂ² : DecidableEq n\ninstâœÂ¹ : CommRing R\ninstâœ : Fintype n\nt : Matrix.TransvectionStruct n R\nâŠ¢ Eq (HMul.hMul t.toMatrix t.inv.toMatrix) 1","decl":"theorem mul_inv (t : TransvectionStruct n R) : t.toMatrix * t.inv.toMatrix = 1 := by\n  rcases t with âŸ¨_, _, t_hijâŸ©\n  simp [toMatrix, transvection_mul_transvection_same, t_hij]\n\n"}
{"name":"Matrix.TransvectionStruct.reverse_inv_prod_mul_prod","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type uâ‚‚\ninstâœÂ² : DecidableEq n\ninstâœÂ¹ : CommRing R\ninstâœ : Fintype n\nL : List (Matrix.TransvectionStruct n R)\nâŠ¢ Eq (HMul.hMul (List.map (Function.comp Matrix.TransvectionStruct.toMatrix Matrix.TransvectionStruct.inv) L.reverse).prod (List.map Matrix.TransvectionStruct.toMatrix L).prod) 1","decl":"theorem reverse_inv_prod_mul_prod (L : List (TransvectionStruct n R)) :\n    (L.reverse.map (toMatrix âˆ˜ TransvectionStruct.inv)).prod * (L.map toMatrix).prod = 1 := by\n  induction' L with t L IH\n  Â· simp\n  Â· suffices\n      (L.reverse.map (toMatrix âˆ˜ TransvectionStruct.inv)).prod * (t.inv.toMatrix * t.toMatrix) *\n          (L.map toMatrix).prod = 1\n      by simpa [Matrix.mul_assoc]\n    simpa [inv_mul] using IH\n\n"}
{"name":"Matrix.TransvectionStruct.prod_mul_reverse_inv_prod","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type uâ‚‚\ninstâœÂ² : DecidableEq n\ninstâœÂ¹ : CommRing R\ninstâœ : Fintype n\nL : List (Matrix.TransvectionStruct n R)\nâŠ¢ Eq (HMul.hMul (List.map Matrix.TransvectionStruct.toMatrix L).prod (List.map (Function.comp Matrix.TransvectionStruct.toMatrix Matrix.TransvectionStruct.inv) L.reverse).prod) 1","decl":"theorem prod_mul_reverse_inv_prod (L : List (TransvectionStruct n R)) :\n    (L.map toMatrix).prod * (L.reverse.map (toMatrix âˆ˜ TransvectionStruct.inv)).prod = 1 := by\n  induction' L with t L IH\n  Â· simp\n  Â· suffices\n      t.toMatrix *\n            ((L.map toMatrix).prod * (L.reverse.map (toMatrix âˆ˜ TransvectionStruct.inv)).prod) *\n          t.inv.toMatrix = 1\n      by simpa [Matrix.mul_assoc]\n    simp_rw [IH, Matrix.mul_one, t.mul_inv]\n\n"}
{"name":"Matrix.mem_range_scalar_of_commute_transvectionStruct","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type uâ‚‚\ninstâœÂ² : DecidableEq n\ninstâœÂ¹ : CommRing R\ninstâœ : Fintype n\nM : Matrix n n R\nhM : âˆ€ (t : Matrix.TransvectionStruct n R), Commute t.toMatrix M\nâŠ¢ Membership.mem (Set.range â‡‘(Matrix.scalar n)) M","decl":"/-- `M` is a scalar matrix if it commutes with every nontrivial transvection (elementary matrix). -/\ntheorem _root_.Matrix.mem_range_scalar_of_commute_transvectionStruct {M : Matrix n n R}\n    (hM : âˆ€ t : TransvectionStruct n R, Commute t.toMatrix M) :\n    M âˆˆ Set.range (Matrix.scalar n) := by\n  refine mem_range_scalar_of_commute_stdBasisMatrix ?_\n  intro i j hij\n  simpa [transvection, mul_add, add_mul] using (hM âŸ¨i, j, hij, 1âŸ©).eq\n\n"}
{"name":"Matrix.mem_range_scalar_iff_commute_transvectionStruct","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nR : Type uâ‚‚\ninstâœÂ² : DecidableEq n\ninstâœÂ¹ : CommRing R\ninstâœ : Fintype n\nM : Matrix n n R\nâŠ¢ Iff (Membership.mem (Set.range â‡‘(Matrix.scalar n)) M) (âˆ€ (t : Matrix.TransvectionStruct n R), Commute t.toMatrix M)","decl":"theorem _root_.Matrix.mem_range_scalar_iff_commute_transvectionStruct {M : Matrix n n R} :\n    M âˆˆ Set.range (Matrix.scalar n) â†” âˆ€ t : TransvectionStruct n R, Commute t.toMatrix M := by\n  refine âŸ¨fun h t => ?_, mem_range_scalar_of_commute_transvectionStructâŸ©\n  rw [mem_range_scalar_iff_commute_stdBasisMatrix] at h\n  refine (Commute.one_left M).add_left ?_\n  convert (h _ _ t.hij).smul_left t.c using 1\n  rw [smul_stdBasisMatrix, smul_eq_mul, mul_one]\n\n"}
{"name":"Matrix.TransvectionStruct.toMatrix_sumInl","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\np : Type u_2\nR : Type uâ‚‚\ninstâœÂ² : DecidableEq n\ninstâœÂ¹ : DecidableEq p\ninstâœ : CommRing R\nt : Matrix.TransvectionStruct n R\nâŠ¢ Eq (Matrix.TransvectionStruct.sumInl p t).toMatrix (Matrix.fromBlocks t.toMatrix 0 0 1)","decl":"theorem toMatrix_sumInl (t : TransvectionStruct n R) :\n    (t.sumInl p).toMatrix = fromBlocks t.toMatrix 0 0 1 := by\n  cases t\n  ext a b\n  cases' a with a a <;> cases' b with b b\n  Â· by_cases h : a = b <;> simp [TransvectionStruct.sumInl, transvection, h, stdBasisMatrix]\n  Â· simp [TransvectionStruct.sumInl, transvection]\n  Â· simp [TransvectionStruct.sumInl, transvection]\n  Â· by_cases h : a = b <;> simp [TransvectionStruct.sumInl, transvection, h]\n\n"}
{"name":"Matrix.TransvectionStruct.sumInl_toMatrix_prod_mul","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\np : Type u_2\nR : Type uâ‚‚\ninstâœâ´ : DecidableEq n\ninstâœÂ³ : DecidableEq p\ninstâœÂ² : CommRing R\ninstâœÂ¹ : Fintype n\ninstâœ : Fintype p\nM : Matrix n n R\nL : List (Matrix.TransvectionStruct n R)\nN : Matrix p p R\nâŠ¢ Eq (HMul.hMul (List.map (Function.comp Matrix.TransvectionStruct.toMatrix (Matrix.TransvectionStruct.sumInl p)) L).prod (Matrix.fromBlocks M 0 0 N)) (Matrix.fromBlocks (HMul.hMul (List.map Matrix.TransvectionStruct.toMatrix L).prod M) 0 0 N)","decl":"@[simp]\ntheorem sumInl_toMatrix_prod_mul [Fintype n] [Fintype p] (M : Matrix n n R)\n    (L : List (TransvectionStruct n R)) (N : Matrix p p R) :\n    (L.map (toMatrix âˆ˜ sumInl p)).prod * fromBlocks M 0 0 N =\n      fromBlocks ((L.map toMatrix).prod * M) 0 0 N := by\n  induction' L with t L IH\n  Â· simp\n  Â· simp [Matrix.mul_assoc, IH, toMatrix_sumInl, fromBlocks_multiply]\n\n"}
{"name":"Matrix.TransvectionStruct.mul_sumInl_toMatrix_prod","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\np : Type u_2\nR : Type uâ‚‚\ninstâœâ´ : DecidableEq n\ninstâœÂ³ : DecidableEq p\ninstâœÂ² : CommRing R\ninstâœÂ¹ : Fintype n\ninstâœ : Fintype p\nM : Matrix n n R\nL : List (Matrix.TransvectionStruct n R)\nN : Matrix p p R\nâŠ¢ Eq (HMul.hMul (Matrix.fromBlocks M 0 0 N) (List.map (Function.comp Matrix.TransvectionStruct.toMatrix (Matrix.TransvectionStruct.sumInl p)) L).prod) (Matrix.fromBlocks (HMul.hMul M (List.map Matrix.TransvectionStruct.toMatrix L).prod) 0 0 N)","decl":"@[simp]\ntheorem mul_sumInl_toMatrix_prod [Fintype n] [Fintype p] (M : Matrix n n R)\n    (L : List (TransvectionStruct n R)) (N : Matrix p p R) :\n    fromBlocks M 0 0 N * (L.map (toMatrix âˆ˜ sumInl p)).prod =\n      fromBlocks (M * (L.map toMatrix).prod) 0 0 N := by\n  induction' L with t L IH generalizing M N\n  Â· simp\n  Â· simp [IH, toMatrix_sumInl, fromBlocks_multiply]\n\n"}
{"name":"Matrix.TransvectionStruct.toMatrix_reindexEquiv","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\np : Type u_2\nR : Type uâ‚‚\ninstâœâ´ : DecidableEq n\ninstâœÂ³ : DecidableEq p\ninstâœÂ² : CommRing R\ninstâœÂ¹ : Fintype n\ninstâœ : Fintype p\ne : Equiv n p\nt : Matrix.TransvectionStruct n R\nâŠ¢ Eq (Matrix.TransvectionStruct.reindexEquiv e t).toMatrix ((Matrix.reindexAlgEquiv R R e) t.toMatrix)","decl":"theorem toMatrix_reindexEquiv (e : n â‰ƒ p) (t : TransvectionStruct n R) :\n    (t.reindexEquiv e).toMatrix = reindexAlgEquiv R _ e t.toMatrix := by\n  rcases t with âŸ¨t_i, t_j, _âŸ©\n  ext a b\n  simp only [reindexEquiv, transvection, mul_boole, Algebra.id.smul_eq_mul, toMatrix_mk,\n    submatrix_apply, reindex_apply, DMatrix.add_apply, Pi.smul_apply, reindexAlgEquiv_apply]\n  by_cases ha : e t_i = a <;> by_cases hb : e t_j = b <;> by_cases hab : a = b <;>\n    simp [ha, hb, hab, â† e.apply_eq_iff_eq_symm_apply, stdBasisMatrix]\n\n"}
{"name":"Matrix.TransvectionStruct.toMatrix_reindexEquiv_prod","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\np : Type u_2\nR : Type uâ‚‚\ninstâœâ´ : DecidableEq n\ninstâœÂ³ : DecidableEq p\ninstâœÂ² : CommRing R\ninstâœÂ¹ : Fintype n\ninstâœ : Fintype p\ne : Equiv n p\nL : List (Matrix.TransvectionStruct n R)\nâŠ¢ Eq (List.map (Function.comp Matrix.TransvectionStruct.toMatrix (Matrix.TransvectionStruct.reindexEquiv e)) L).prod ((Matrix.reindexAlgEquiv R R e) (List.map Matrix.TransvectionStruct.toMatrix L).prod)","decl":"theorem toMatrix_reindexEquiv_prod (e : n â‰ƒ p) (L : List (TransvectionStruct n R)) :\n    (L.map (toMatrix âˆ˜ reindexEquiv e)).prod = reindexAlgEquiv R _ e (L.map toMatrix).prod := by\n  induction' L with t L IH\n  Â· simp\n  Â· simp only [toMatrix_reindexEquiv, IH, Function.comp_apply, List.prod_cons,\n      reindexAlgEquiv_apply, List.map]\n    exact (reindexAlgEquiv_mul R _ _ _ _).symm\n\n"}
{"name":"Matrix.Pivot.length_listTransvecCol","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"ğ•œ : Type u_3\ninstâœ : Field ğ•œ\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) ğ•œ\nâŠ¢ Eq (Matrix.Pivot.listTransvecCol M).length r","decl":"@[simp]\ntheorem length_listTransvecCol : (listTransvecCol M).length = r := by simp [listTransvecCol]\n\n"}
{"name":"Matrix.Pivot.listTransvecCol_getElem","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"ğ•œ : Type u_3\ninstâœ : Field ğ•œ\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) ğ•œ\ni : Nat\nh : LT.lt i (Matrix.Pivot.listTransvecCol M).length\nâŠ¢ Eq (GetElem.getElem (Matrix.Pivot.listTransvecCol M) i â‹¯) (Matrix.transvection (Sum.inl âŸ¨i, â‹¯âŸ©) (Sum.inr Unit.unit) (HDiv.hDiv (Neg.neg (M (Sum.inl âŸ¨i, â‹¯âŸ©) (Sum.inr Unit.unit))) (M (Sum.inr Unit.unit) (Sum.inr Unit.unit))))","decl":"theorem listTransvecCol_getElem {i : â„•} (h : i < (listTransvecCol M).length) :\n    (listTransvecCol M)[i] =\n      letI i' : Fin r := âŸ¨i, length_listTransvecCol M â–¸ hâŸ©\n      transvection (inl i') (inr unit) <| -M (inl i') (inr unit) / M (inr unit) (inr unit) := by\n  simp [listTransvecCol]\n\n"}
{"name":"Matrix.Pivot.listTransvecCol_get","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"ğ•œ : Type u_3\ninstâœ : Field ğ•œ\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) ğ•œ\ni : Fin (Matrix.Pivot.listTransvecCol M).length\nâŠ¢ Eq ((Matrix.Pivot.listTransvecCol M).get i) (Matrix.transvection (Sum.inl (Fin.cast â‹¯ i)) (Sum.inr Unit.unit) (HDiv.hDiv (Neg.neg (M (Sum.inl (Fin.cast â‹¯ i)) (Sum.inr Unit.unit))) (M (Sum.inr Unit.unit) (Sum.inr Unit.unit))))","decl":"@[deprecated listTransvecCol_getElem (since := \"2024-08-03\")]\ntheorem listTransvecCol_get (i : Fin (listTransvecCol M).length) :\n    (listTransvecCol M).get i =\n      letI i' := Fin.cast (length_listTransvecCol M) i\n      transvection (inl i') (inr unit) <| -M (inl i') (inr unit) / M (inr unit) (inr unit) :=\n  listTransvecCol_getElem _ i.isLt\n\n"}
{"name":"Matrix.Pivot.length_listTransvecRow","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"ğ•œ : Type u_3\ninstâœ : Field ğ•œ\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) ğ•œ\nâŠ¢ Eq (Matrix.Pivot.listTransvecRow M).length r","decl":"@[simp]\ntheorem length_listTransvecRow : (listTransvecRow M).length = r := by simp [listTransvecRow]\n\n"}
{"name":"Matrix.Pivot.listTransvecRow_getElem","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"ğ•œ : Type u_3\ninstâœ : Field ğ•œ\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) ğ•œ\ni : Nat\nh : LT.lt i (Matrix.Pivot.listTransvecRow M).length\nâŠ¢ Eq (GetElem.getElem (Matrix.Pivot.listTransvecRow M) i â‹¯) (Matrix.transvection (Sum.inr Unit.unit) (Sum.inl âŸ¨i, â‹¯âŸ©) (HDiv.hDiv (Neg.neg (M (Sum.inr Unit.unit) (Sum.inl âŸ¨i, â‹¯âŸ©))) (M (Sum.inr Unit.unit) (Sum.inr Unit.unit))))","decl":"theorem listTransvecRow_getElem {i : â„•} (h : i < (listTransvecRow M).length) :\n    (listTransvecRow M)[i] =\n      letI i' : Fin r := âŸ¨i, length_listTransvecRow M â–¸ hâŸ©\n      transvection (inr unit) (inl i') <| -M (inr unit) (inl i') / M (inr unit) (inr unit) := by\n  simp [listTransvecRow, Fin.cast]\n\n"}
{"name":"Matrix.Pivot.listTransvecRow_get","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"ğ•œ : Type u_3\ninstâœ : Field ğ•œ\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) ğ•œ\ni : Fin (Matrix.Pivot.listTransvecRow M).length\nâŠ¢ Eq ((Matrix.Pivot.listTransvecRow M).get i) (Matrix.transvection (Sum.inr Unit.unit) (Sum.inl (Fin.cast â‹¯ i)) (HDiv.hDiv (Neg.neg (M (Sum.inr Unit.unit) (Sum.inl (Fin.cast â‹¯ i)))) (M (Sum.inr Unit.unit) (Sum.inr Unit.unit))))","decl":"@[deprecated listTransvecRow_getElem (since := \"2024-08-03\")]\ntheorem listTransvecRow_get (i : Fin (listTransvecRow M).length) :\n    (listTransvecRow M).get i =\n      letI i' := Fin.cast (length_listTransvecRow M) i\n      transvection (inr unit) (inl i') <| -M (inr unit) (inl i') / M (inr unit) (inr unit) :=\n  listTransvecRow_getElem _ i.isLt\n\n"}
{"name":"Matrix.Pivot.listTransvecCol_mul_last_row_drop","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"ğ•œ : Type u_3\ninstâœ : Field ğ•œ\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) ğ•œ\ni : Sum (Fin r) Unit\nk : Nat\nhk : LE.le k r\nâŠ¢ Eq (HMul.hMul (List.drop k (Matrix.Pivot.listTransvecCol M)).prod M (Sum.inr Unit.unit) i) (M (Sum.inr Unit.unit) i)","decl":"/-- Multiplying by some of the matrices in `listTransvecCol M` does not change the last row. -/\ntheorem listTransvecCol_mul_last_row_drop (i : Fin r âŠ• Unit) {k : â„•} (hk : k â‰¤ r) :\n    (((listTransvecCol M).drop k).prod * M) (inr unit) i = M (inr unit) i := by\n  induction hk using Nat.decreasingInduction with\n  | of_succ n hn IH =>\n    have hn' : n < (listTransvecCol M).length := by simpa [listTransvecCol] using hn\n    rw [List.drop_eq_getElem_cons hn']\n    simpa [listTransvecCol, Matrix.mul_assoc]\n  | self =>\n    simp only [length_listTransvecCol, le_refl, List.drop_eq_nil_of_le, List.prod_nil,\n      Matrix.one_mul]\n\n"}
{"name":"Matrix.Pivot.listTransvecCol_mul_last_row","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"ğ•œ : Type u_3\ninstâœ : Field ğ•œ\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) ğ•œ\ni : Sum (Fin r) Unit\nâŠ¢ Eq (HMul.hMul (Matrix.Pivot.listTransvecCol M).prod M (Sum.inr Unit.unit) i) (M (Sum.inr Unit.unit) i)","decl":"/-- Multiplying by all the matrices in `listTransvecCol M` does not change the last row. -/\ntheorem listTransvecCol_mul_last_row (i : Fin r âŠ• Unit) :\n    ((listTransvecCol M).prod * M) (inr unit) i = M (inr unit) i := by\n  simpa using listTransvecCol_mul_last_row_drop M i (zero_le _)\n\n"}
{"name":"Matrix.Pivot.listTransvecCol_mul_last_col","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"ğ•œ : Type u_3\ninstâœ : Field ğ•œ\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) ğ•œ\nhM : Ne (M (Sum.inr Unit.unit) (Sum.inr Unit.unit)) 0\ni : Fin r\nâŠ¢ Eq (HMul.hMul (Matrix.Pivot.listTransvecCol M).prod M (Sum.inl i) (Sum.inr Unit.unit)) 0","decl":"/-- Multiplying by all the matrices in `listTransvecCol M` kills all the coefficients in the\nlast column but the last one. -/\ntheorem listTransvecCol_mul_last_col (hM : M (inr unit) (inr unit) â‰  0) (i : Fin r) :\n    ((listTransvecCol M).prod * M) (inl i) (inr unit) = 0 := by\n  suffices H :\n    âˆ€ k : â„•,\n      k â‰¤ r â†’\n        (((listTransvecCol M).drop k).prod * M) (inl i) (inr unit) =\n          if k â‰¤ i then 0 else M (inl i) (inr unit) by\n    simpa only [List.drop, _root_.zero_le, ite_true] using H 0 (zero_le _)\n  intro k hk\n  induction hk using Nat.decreasingInduction with\n  | of_succ n hn IH =>\n    have hn' : n < (listTransvecCol M).length := by simpa [listTransvecCol] using hn\n    let n' : Fin r := âŸ¨n, hnâŸ©\n    rw [List.drop_eq_getElem_cons hn']\n    have A :\n      (listTransvecCol M)[n] =\n        transvection (inl n') (inr unit) (-M (inl n') (inr unit) / M (inr unit) (inr unit)) := by\n      simp [n', listTransvecCol]\n    simp only [Matrix.mul_assoc, A, List.prod_cons]\n    by_cases h : n' = i\n    Â· have hni : n = i := by\n        cases i\n        simp only [n', Fin.mk_eq_mk] at h\n        simp [h]\n      simp only [h, transvection_mul_apply_same, IH, â† hni, add_le_iff_nonpos_right,\n          listTransvecCol_mul_last_row_drop _ _ hn]\n      field_simp [hM]\n    Â· have hni : n â‰  i := by\n        rintro rfl\n        cases i\n        simp [n'] at h\n      simp only [ne_eq, inl.injEq, Ne.symm h, not_false_eq_true, transvection_mul_apply_of_ne]\n      rw [IH]\n      rcases le_or_lt (n + 1) i with (hi | hi)\n      Â· simp only [hi, n.le_succ.trans hi, if_true]\n      Â· rw [if_neg, if_neg]\n        Â· simpa only [hni.symm, not_le, or_false] using Nat.lt_succ_iff_lt_or_eq.1 hi\n        Â· simpa only [not_le] using hi\n  | self =>\n    simp only [length_listTransvecCol, le_refl, List.drop_eq_nil_of_le, List.prod_nil,\n      Matrix.one_mul]\n    rw [if_neg]\n    simpa only [not_le] using i.2\n\n"}
{"name":"Matrix.Pivot.mul_listTransvecRow_last_col_take","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"ğ•œ : Type u_3\ninstâœ : Field ğ•œ\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) ğ•œ\ni : Sum (Fin r) Unit\nk : Nat\nhk : LE.le k r\nâŠ¢ Eq (HMul.hMul M (List.take k (Matrix.Pivot.listTransvecRow M)).prod i (Sum.inr Unit.unit)) (M i (Sum.inr Unit.unit))","decl":"/-- Multiplying by some of the matrices in `listTransvecRow M` does not change the last column. -/\ntheorem mul_listTransvecRow_last_col_take (i : Fin r âŠ• Unit) {k : â„•} (hk : k â‰¤ r) :\n    (M * ((listTransvecRow M).take k).prod) i (inr unit) = M i (inr unit) := by\n  induction' k with k IH\n  Â· simp only [Matrix.mul_one, List.take_zero, List.prod_nil, List.take, Matrix.mul_one]\n  Â· have hkr : k < r := hk\n    let k' : Fin r := âŸ¨k, hkrâŸ©\n    have :\n      (listTransvecRow M)[k]? =\n        â†‘(transvection (inr Unit.unit) (inl k')\n            (-M (inr Unit.unit) (inl k') / M (inr Unit.unit) (inr Unit.unit))) := by\n      simp only [k', listTransvecRow, List.ofFnNthVal, hkr, dif_pos, List.getElem?_ofFn]\n    simp only [List.take_succ, â† Matrix.mul_assoc, this, List.prod_append, Matrix.mul_one,\n      List.prod_cons, List.prod_nil, Option.toList_some]\n    rw [mul_transvection_apply_of_ne, IH hkr.le]\n    simp only [Ne, not_false_iff, reduceCtorEq]\n\n"}
{"name":"Matrix.Pivot.mul_listTransvecRow_last_col","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"ğ•œ : Type u_3\ninstâœ : Field ğ•œ\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) ğ•œ\ni : Sum (Fin r) Unit\nâŠ¢ Eq (HMul.hMul M (Matrix.Pivot.listTransvecRow M).prod i (Sum.inr Unit.unit)) (M i (Sum.inr Unit.unit))","decl":"/-- Multiplying by all the matrices in `listTransvecRow M` does not change the last column. -/\ntheorem mul_listTransvecRow_last_col (i : Fin r âŠ• Unit) :\n    (M * (listTransvecRow M).prod) i (inr unit) = M i (inr unit) := by\n  have A : (listTransvecRow M).length = r := by simp [listTransvecRow]\n  rw [â† List.take_length (listTransvecRow M), A]\n  simpa using mul_listTransvecRow_last_col_take M i le_rfl\n\n"}
{"name":"Matrix.Pivot.mul_listTransvecRow_last_row","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"ğ•œ : Type u_3\ninstâœ : Field ğ•œ\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) ğ•œ\nhM : Ne (M (Sum.inr Unit.unit) (Sum.inr Unit.unit)) 0\ni : Fin r\nâŠ¢ Eq (HMul.hMul M (Matrix.Pivot.listTransvecRow M).prod (Sum.inr Unit.unit) (Sum.inl i)) 0","decl":"/-- Multiplying by all the matrices in `listTransvecRow M` kills all the coefficients in the\nlast row but the last one. -/\ntheorem mul_listTransvecRow_last_row (hM : M (inr unit) (inr unit) â‰  0) (i : Fin r) :\n    (M * (listTransvecRow M).prod) (inr unit) (inl i) = 0 := by\n  suffices H :\n    âˆ€ k : â„•,\n      k â‰¤ r â†’\n        (M * ((listTransvecRow M).take k).prod) (inr unit) (inl i) =\n          if k â‰¤ i then M (inr unit) (inl i) else 0 by\n    have A : (listTransvecRow M).length = r := by simp [listTransvecRow]\n    rw [â† List.take_length (listTransvecRow M), A]\n    have : Â¬r â‰¤ i := by simp\n    simpa only [this, ite_eq_right_iff] using H r le_rfl\n  intro k hk\n  induction' k with n IH\n  Â· simp only [if_true, Matrix.mul_one, List.take_zero, zero_le', List.prod_nil]\n  Â· have hnr : n < r := hk\n    let n' : Fin r := âŸ¨n, hnrâŸ©\n    have A :\n      (listTransvecRow M)[n]? =\n        â†‘(transvection (inr unit) (inl n')\n        (-M (inr unit) (inl n') / M (inr unit) (inr unit))) := by\n      simp only [n', listTransvecRow, List.ofFnNthVal, hnr, dif_pos, List.getElem?_ofFn]\n    simp only [List.take_succ, A, â† Matrix.mul_assoc, List.prod_append, Matrix.mul_one,\n      List.prod_cons, List.prod_nil, Option.toList_some]\n    by_cases h : n' = i\n    Â· have hni : n = i := by\n        cases i\n        simp only [n', Fin.mk_eq_mk] at h\n        simp only [h]\n      have : Â¬n.succ â‰¤ i := by simp only [â† hni, n.lt_succ_self, not_le]\n      simp only [h, mul_transvection_apply_same, List.take, if_false,\n        mul_listTransvecRow_last_col_take _ _ hnr.le, hni.le, this, if_true, IH hnr.le]\n      field_simp [hM]\n    Â· have hni : n â‰  i := by\n        rintro rfl\n        cases i\n        tauto\n      simp only [IH hnr.le, Ne, mul_transvection_apply_of_ne, Ne.symm h, inl.injEq,\n        not_false_eq_true]\n      rcases le_or_lt (n + 1) i with (hi | hi)\n      Â· simp [hi, n.le_succ.trans hi, if_true]\n      Â· rw [if_neg, if_neg]\n        Â· simpa only [not_le] using hi\n        Â· simpa only [hni.symm, not_le, or_false] using Nat.lt_succ_iff_lt_or_eq.1 hi\n\n"}
{"name":"Matrix.Pivot.listTransvecCol_mul_mul_listTransvecRow_last_col","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"ğ•œ : Type u_3\ninstâœ : Field ğ•œ\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) ğ•œ\nhM : Ne (M (Sum.inr Unit.unit) (Sum.inr Unit.unit)) 0\ni : Fin r\nâŠ¢ Eq (HMul.hMul (HMul.hMul (Matrix.Pivot.listTransvecCol M).prod M) (Matrix.Pivot.listTransvecRow M).prod (Sum.inr Unit.unit) (Sum.inl i)) 0","decl":"/-- Multiplying by all the matrices either in `listTransvecCol M` and `listTransvecRow M` kills\nall the coefficients in the last row but the last one. -/\ntheorem listTransvecCol_mul_mul_listTransvecRow_last_col (hM : M (inr unit) (inr unit) â‰  0)\n    (i : Fin r) :\n    ((listTransvecCol M).prod * M * (listTransvecRow M).prod) (inr unit) (inl i) = 0 := by\n  have : listTransvecRow M = listTransvecRow ((listTransvecCol M).prod * M) := by\n    simp [listTransvecRow, listTransvecCol_mul_last_row]\n  rw [this]\n  apply mul_listTransvecRow_last_row\n  simpa [listTransvecCol_mul_last_row] using hM\n\n"}
{"name":"Matrix.Pivot.listTransvecCol_mul_mul_listTransvecRow_last_row","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"ğ•œ : Type u_3\ninstâœ : Field ğ•œ\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) ğ•œ\nhM : Ne (M (Sum.inr Unit.unit) (Sum.inr Unit.unit)) 0\ni : Fin r\nâŠ¢ Eq (HMul.hMul (HMul.hMul (Matrix.Pivot.listTransvecCol M).prod M) (Matrix.Pivot.listTransvecRow M).prod (Sum.inl i) (Sum.inr Unit.unit)) 0","decl":"/-- Multiplying by all the matrices either in `listTransvecCol M` and `listTransvecRow M` kills\nall the coefficients in the last column but the last one. -/\ntheorem listTransvecCol_mul_mul_listTransvecRow_last_row (hM : M (inr unit) (inr unit) â‰  0)\n    (i : Fin r) :\n    ((listTransvecCol M).prod * M * (listTransvecRow M).prod) (inl i) (inr unit) = 0 := by\n  have : listTransvecCol M = listTransvecCol (M * (listTransvecRow M).prod) := by\n    simp [listTransvecCol, mul_listTransvecRow_last_col]\n  rw [this, Matrix.mul_assoc]\n  apply listTransvecCol_mul_last_col\n  simpa [mul_listTransvecRow_last_col] using hM\n\n"}
{"name":"Matrix.Pivot.isTwoBlockDiagonal_listTransvecCol_mul_mul_listTransvecRow","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"ğ•œ : Type u_3\ninstâœ : Field ğ•œ\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) ğ•œ\nhM : Ne (M (Sum.inr Unit.unit) (Sum.inr Unit.unit)) 0\nâŠ¢ (HMul.hMul (HMul.hMul (Matrix.Pivot.listTransvecCol M).prod M) (Matrix.Pivot.listTransvecRow M).prod).IsTwoBlockDiagonal","decl":"/-- Multiplying by all the matrices either in `listTransvecCol M` and `listTransvecRow M` turns\nthe matrix in block-diagonal form. -/\ntheorem isTwoBlockDiagonal_listTransvecCol_mul_mul_listTransvecRow\n    (hM : M (inr unit) (inr unit) â‰  0) :\n    IsTwoBlockDiagonal ((listTransvecCol M).prod * M * (listTransvecRow M).prod) := by\n  constructor\n  Â· ext i j\n    have : j = unit := by simp only [eq_iff_true_of_subsingleton]\n    simp [toBlocksâ‚â‚‚, this, listTransvecCol_mul_mul_listTransvecRow_last_row M hM]\n  Â· ext i j\n    have : i = unit := by simp only [eq_iff_true_of_subsingleton]\n    simp [toBlocksâ‚‚â‚, this, listTransvecCol_mul_mul_listTransvecRow_last_col M hM]\n\n"}
{"name":"Matrix.Pivot.exists_isTwoBlockDiagonal_of_ne_zero","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"ğ•œ : Type u_3\ninstâœ : Field ğ•œ\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) ğ•œ\nhM : Ne (M (Sum.inr Unit.unit) (Sum.inr Unit.unit)) 0\nâŠ¢ Exists fun L => Exists fun L' => (HMul.hMul (HMul.hMul (List.map Matrix.TransvectionStruct.toMatrix L).prod M) (List.map Matrix.TransvectionStruct.toMatrix L').prod).IsTwoBlockDiagonal","decl":"/-- There exist two lists of `TransvectionStruct` such that multiplying by them on the left and\non the right makes a matrix block-diagonal, when the last coefficient is nonzero. -/\ntheorem exists_isTwoBlockDiagonal_of_ne_zero (hM : M (inr unit) (inr unit) â‰  0) :\n    âˆƒ L L' : List (TransvectionStruct (Fin r âŠ• Unit) ğ•œ),\n      IsTwoBlockDiagonal ((L.map toMatrix).prod * M * (L'.map toMatrix).prod) := by\n  let L : List (TransvectionStruct (Fin r âŠ• Unit) ğ•œ) :=\n    List.ofFn fun i : Fin r =>\n      âŸ¨inl i, inr unit, by simp, -M (inl i) (inr unit) / M (inr unit) (inr unit)âŸ©\n  let L' : List (TransvectionStruct (Fin r âŠ• Unit) ğ•œ) :=\n    List.ofFn fun i : Fin r =>\n      âŸ¨inr unit, inl i, by simp, -M (inr unit) (inl i) / M (inr unit) (inr unit)âŸ©\n  refine âŸ¨L, L', ?_âŸ©\n  have A : L.map toMatrix = listTransvecCol M := by simp [L, listTransvecCol, Function.comp_def]\n  have B : L'.map toMatrix = listTransvecRow M := by simp [L', listTransvecRow, Function.comp_def]\n  rw [A, B]\n  exact isTwoBlockDiagonal_listTransvecCol_mul_mul_listTransvecRow M hM\n\n"}
{"name":"Matrix.Pivot.exists_isTwoBlockDiagonal_list_transvec_mul_mul_list_transvec","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"ğ•œ : Type u_3\ninstâœ : Field ğ•œ\nr : Nat\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) ğ•œ\nâŠ¢ Exists fun L => Exists fun L' => (HMul.hMul (HMul.hMul (List.map Matrix.TransvectionStruct.toMatrix L).prod M) (List.map Matrix.TransvectionStruct.toMatrix L').prod).IsTwoBlockDiagonal","decl":"/-- There exist two lists of `TransvectionStruct` such that multiplying by them on the left and\non the right makes a matrix block-diagonal. -/\ntheorem exists_isTwoBlockDiagonal_list_transvec_mul_mul_list_transvec\n    (M : Matrix (Fin r âŠ• Unit) (Fin r âŠ• Unit) ğ•œ) :\n    âˆƒ L L' : List (TransvectionStruct (Fin r âŠ• Unit) ğ•œ),\n      IsTwoBlockDiagonal ((L.map toMatrix).prod * M * (L'.map toMatrix).prod) := by\n  by_cases H : IsTwoBlockDiagonal M\n  Â· refine âŸ¨List.nil, List.nil, by simpa using HâŸ©\n  -- we have already proved this when the last coefficient is nonzero\n  by_cases hM : M (inr unit) (inr unit) â‰  0\n  Â· exact exists_isTwoBlockDiagonal_of_ne_zero M hM\n  -- when the last coefficient is zero but there is a nonzero coefficient on the last row or the\n  -- last column, we will first put this nonzero coefficient in last position, and then argue as\n  -- above.\n  push_neg at hM\n  simp only [not_and_or, IsTwoBlockDiagonal, toBlocksâ‚â‚‚, toBlocksâ‚‚â‚, â† Matrix.ext_iff] at H\n  have : âˆƒ i : Fin r, M (inl i) (inr unit) â‰  0 âˆ¨ M (inr unit) (inl i) â‰  0 := by\n    cases' H with H H\n    Â· contrapose! H\n      rintro i âŸ¨âŸ©\n      exact (H i).1\n    Â· contrapose! H\n      rintro âŸ¨âŸ© j\n      exact (H j).2\n  rcases this with âŸ¨i, h | hâŸ©\n  Â· let M' := transvection (inr Unit.unit) (inl i) 1 * M\n    have hM' : M' (inr unit) (inr unit) â‰  0 := by simpa [M', hM]\n    rcases exists_isTwoBlockDiagonal_of_ne_zero M' hM' with âŸ¨L, L', hLL'âŸ©\n    rw [Matrix.mul_assoc] at hLL'\n    refine âŸ¨L ++ [âŸ¨inr unit, inl i, by simp, 1âŸ©], L', ?_âŸ©\n    simp only [List.map_append, List.prod_append, Matrix.mul_one, toMatrix_mk, List.prod_cons,\n      List.prod_nil, List.map, Matrix.mul_assoc (L.map toMatrix).prod]\n    exact hLL'\n  Â· let M' := M * transvection (inl i) (inr unit) 1\n    have hM' : M' (inr unit) (inr unit) â‰  0 := by simpa [M', hM]\n    rcases exists_isTwoBlockDiagonal_of_ne_zero M' hM' with âŸ¨L, L', hLL'âŸ©\n    refine âŸ¨L, âŸ¨inl i, inr unit, by simp, 1âŸ©::L', ?_âŸ©\n    simp only [â† Matrix.mul_assoc, toMatrix_mk, List.prod_cons, List.map]\n    rw [Matrix.mul_assoc (L.map toMatrix).prod]\n    exact hLL'\n\n"}
{"name":"Matrix.Pivot.exists_list_transvec_mul_mul_list_transvec_eq_diagonal_induction","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"ğ•œ : Type u_3\ninstâœ : Field ğ•œ\nr : Nat\nIH : âˆ€ (M : Matrix (Fin r) (Fin r) ğ•œ), Exists fun Lâ‚€ => Exists fun Lâ‚€' => Exists fun Dâ‚€ => Eq (HMul.hMul (HMul.hMul (List.map Matrix.TransvectionStruct.toMatrix Lâ‚€).prod M) (List.map Matrix.TransvectionStruct.toMatrix Lâ‚€').prod) (Matrix.diagonal Dâ‚€)\nM : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) ğ•œ\nâŠ¢ Exists fun L => Exists fun L' => Exists fun D => Eq (HMul.hMul (HMul.hMul (List.map Matrix.TransvectionStruct.toMatrix L).prod M) (List.map Matrix.TransvectionStruct.toMatrix L').prod) (Matrix.diagonal D)","decl":"/-- Inductive step for the reduction: if one knows that any size `r` matrix can be reduced to\ndiagonal form by elementary operations, then one deduces it for matrices over `Fin r âŠ• Unit`. -/\ntheorem exists_list_transvec_mul_mul_list_transvec_eq_diagonal_induction\n    (IH :\n      âˆ€ M : Matrix (Fin r) (Fin r) ğ•œ,\n        âˆƒ (Lâ‚€ Lâ‚€' : List (TransvectionStruct (Fin r) ğ•œ)) (Dâ‚€ : Fin r â†’ ğ•œ),\n          (Lâ‚€.map toMatrix).prod * M * (Lâ‚€'.map toMatrix).prod = diagonal Dâ‚€)\n    (M : Matrix (Fin r âŠ• Unit) (Fin r âŠ• Unit) ğ•œ) :\n    âˆƒ (L L' : List (TransvectionStruct (Fin r âŠ• Unit) ğ•œ)) (D : Fin r âŠ• Unit â†’ ğ•œ),\n      (L.map toMatrix).prod * M * (L'.map toMatrix).prod = diagonal D := by\n  rcases exists_isTwoBlockDiagonal_list_transvec_mul_mul_list_transvec M with âŸ¨Lâ‚, Lâ‚', hMâŸ©\n  let M' := (Lâ‚.map toMatrix).prod * M * (Lâ‚'.map toMatrix).prod\n  let M'' := toBlocksâ‚â‚ M'\n  rcases IH M'' with âŸ¨Lâ‚€, Lâ‚€', Dâ‚€, hâ‚€âŸ©\n  set c := M' (inr unit) (inr unit)\n  refine\n    âŸ¨Lâ‚€.map (sumInl Unit) ++ Lâ‚, Lâ‚' ++ Lâ‚€'.map (sumInl Unit),\n      Sum.elim Dâ‚€ fun _ => M' (inr unit) (inr unit), ?_âŸ©\n  suffices (Lâ‚€.map (toMatrix âˆ˜ sumInl Unit)).prod * M' * (Lâ‚€'.map (toMatrix âˆ˜ sumInl Unit)).prod =\n      diagonal (Sum.elim Dâ‚€ fun _ => c) by\n    simpa [M', c, Matrix.mul_assoc]\n  have : M' = fromBlocks M'' 0 0 (diagonal fun _ => c) := by\n    -- Porting note: simplified proof, because `congr` didn't work anymore\n    rw [â† fromBlocks_toBlocks M', hM.1, hM.2]\n    rfl\n  rw [this]\n  simp [hâ‚€]\n\n"}
{"name":"Matrix.Pivot.reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\np : Type u_2\nğ•œ : Type u_3\ninstâœâ´ : Field ğ•œ\ninstâœÂ³ : DecidableEq n\ninstâœÂ² : DecidableEq p\ninstâœÂ¹ : Fintype n\ninstâœ : Fintype p\nM : Matrix p p ğ•œ\ne : Equiv p n\nH : Exists fun L => Exists fun L' => Exists fun D => Eq (HMul.hMul (HMul.hMul (List.map Matrix.TransvectionStruct.toMatrix L).prod ((Matrix.reindexAlgEquiv ğ•œ ğ•œ e) M)) (List.map Matrix.TransvectionStruct.toMatrix L').prod) (Matrix.diagonal D)\nâŠ¢ Exists fun L => Exists fun L' => Exists fun D => Eq (HMul.hMul (HMul.hMul (List.map Matrix.TransvectionStruct.toMatrix L).prod M) (List.map Matrix.TransvectionStruct.toMatrix L').prod) (Matrix.diagonal D)","decl":"/-- Reduction to diagonal form by elementary operations is invariant under reindexing. -/\ntheorem reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal (M : Matrix p p ğ•œ)\n    (e : p â‰ƒ n)\n    (H :\n      âˆƒ (L L' : List (TransvectionStruct n ğ•œ)) (D : n â†’ ğ•œ),\n        (L.map toMatrix).prod * Matrix.reindexAlgEquiv ğ•œ _ e M * (L'.map toMatrix).prod =\n          diagonal D) :\n    âˆƒ (L L' : List (TransvectionStruct p ğ•œ)) (D : p â†’ ğ•œ),\n      (L.map toMatrix).prod * M * (L'.map toMatrix).prod = diagonal D := by\n  rcases H with âŸ¨Lâ‚€, Lâ‚€', Dâ‚€, hâ‚€âŸ©\n  refine âŸ¨Lâ‚€.map (reindexEquiv e.symm), Lâ‚€'.map (reindexEquiv e.symm), Dâ‚€ âˆ˜ e, ?_âŸ©\n  have : M = reindexAlgEquiv ğ•œ _ e.symm (reindexAlgEquiv ğ•œ _ e M) := by\n    simp only [Equiv.symm_symm, submatrix_submatrix, reindex_apply, submatrix_id_id,\n      Equiv.symm_comp_self, reindexAlgEquiv_apply]\n  rw [this]\n  simp only [toMatrix_reindexEquiv_prod, List.map_map, reindexAlgEquiv_apply]\n  simp only [â† reindexAlgEquiv_apply ğ•œ, â† reindexAlgEquiv_mul, hâ‚€]\n  simp only [Equiv.symm_symm, reindex_apply, submatrix_diagonal_equiv, reindexAlgEquiv_apply]\n\n"}
{"name":"Matrix.Pivot.exists_list_transvec_mul_mul_list_transvec_eq_diagonal_aux","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"ğ•œ : Type u_3\ninstâœÂ² : Field ğ•œ\nn : Type\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nM : Matrix n n ğ•œ\nâŠ¢ Exists fun L => Exists fun L' => Exists fun D => Eq (HMul.hMul (HMul.hMul (List.map Matrix.TransvectionStruct.toMatrix L).prod M) (List.map Matrix.TransvectionStruct.toMatrix L').prod) (Matrix.diagonal D)","decl":"/-- Any matrix can be reduced to diagonal form by elementary operations. Formulated here on `Type 0`\nbecause we will make an induction using `Fin r`.\nSee `exists_list_transvec_mul_mul_list_transvec_eq_diagonal` for the general version (which follows\nfrom this one and reindexing). -/\ntheorem exists_list_transvec_mul_mul_list_transvec_eq_diagonal_aux (n : Type) [Fintype n]\n    [DecidableEq n] (M : Matrix n n ğ•œ) :\n    âˆƒ (L L' : List (TransvectionStruct n ğ•œ)) (D : n â†’ ğ•œ),\n      (L.map toMatrix).prod * M * (L'.map toMatrix).prod = diagonal D := by\n  induction' hn : Fintype.card n with r IH generalizing n M\n  Â· refine âŸ¨List.nil, List.nil, fun _ => 1, ?_âŸ©\n    ext i j\n    rw [Fintype.card_eq_zero_iff] at hn\n    exact hn.elim' i\n  Â· have e : n â‰ƒ Fin r âŠ• Unit := by\n      refine Fintype.equivOfCardEq ?_\n      rw [hn]\n      rw [@Fintype.card_sum (Fin r) Unit _ _]\n      simp\n    apply reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal M e\n    apply\n      exists_list_transvec_mul_mul_list_transvec_eq_diagonal_induction fun N =>\n        IH (Fin r) N (by simp)\n\n"}
{"name":"Matrix.Pivot.exists_list_transvec_mul_mul_list_transvec_eq_diagonal","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nğ•œ : Type u_3\ninstâœÂ² : Field ğ•œ\ninstâœÂ¹ : DecidableEq n\ninstâœ : Fintype n\nM : Matrix n n ğ•œ\nâŠ¢ Exists fun L => Exists fun L' => Exists fun D => Eq (HMul.hMul (HMul.hMul (List.map Matrix.TransvectionStruct.toMatrix L).prod M) (List.map Matrix.TransvectionStruct.toMatrix L').prod) (Matrix.diagonal D)","decl":"/-- Any matrix can be reduced to diagonal form by elementary operations. -/\ntheorem exists_list_transvec_mul_mul_list_transvec_eq_diagonal (M : Matrix n n ğ•œ) :\n    âˆƒ (L L' : List (TransvectionStruct n ğ•œ)) (D : n â†’ ğ•œ),\n      (L.map toMatrix).prod * M * (L'.map toMatrix).prod = diagonal D := by\n  have e : n â‰ƒ Fin (Fintype.card n) := Fintype.equivOfCardEq (by simp)\n  apply reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal M e\n  apply exists_list_transvec_mul_mul_list_transvec_eq_diagonal_aux\n\n"}
{"name":"Matrix.Pivot.exists_list_transvec_mul_diagonal_mul_list_transvec","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nğ•œ : Type u_3\ninstâœÂ² : Field ğ•œ\ninstâœÂ¹ : DecidableEq n\ninstâœ : Fintype n\nM : Matrix n n ğ•œ\nâŠ¢ Exists fun L => Exists fun L' => Exists fun D => Eq M (HMul.hMul (HMul.hMul (List.map Matrix.TransvectionStruct.toMatrix L).prod (Matrix.diagonal D)) (List.map Matrix.TransvectionStruct.toMatrix L').prod)","decl":"/-- Any matrix can be written as the product of transvections, a diagonal matrix, and\ntransvections. -/\ntheorem exists_list_transvec_mul_diagonal_mul_list_transvec (M : Matrix n n ğ•œ) :\n    âˆƒ (L L' : List (TransvectionStruct n ğ•œ)) (D : n â†’ ğ•œ),\n      M = (L.map toMatrix).prod * diagonal D * (L'.map toMatrix).prod := by\n  rcases exists_list_transvec_mul_mul_list_transvec_eq_diagonal M with âŸ¨L, L', D, hâŸ©\n  refine âŸ¨L.reverse.map TransvectionStruct.inv, L'.reverse.map TransvectionStruct.inv, D, ?_âŸ©\n  suffices\n    M =\n      (L.reverse.map (toMatrix âˆ˜ TransvectionStruct.inv)).prod * (L.map toMatrix).prod * M *\n        ((L'.map toMatrix).prod * (L'.reverse.map (toMatrix âˆ˜ TransvectionStruct.inv)).prod)\n    by simpa [â† h, Matrix.mul_assoc]\n  rw [reverse_inv_prod_mul_prod, prod_mul_reverse_inv_prod, Matrix.one_mul, Matrix.mul_one]\n\n"}
{"name":"Matrix.diagonal_transvection_induction","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nğ•œ : Type u_3\ninstâœÂ² : Field ğ•œ\ninstâœÂ¹ : DecidableEq n\ninstâœ : Fintype n\nP : Matrix n n ğ•œ â†’ Prop\nM : Matrix n n ğ•œ\nhdiag : âˆ€ (D : n â†’ ğ•œ), Eq (Matrix.diagonal D).det M.det â†’ P (Matrix.diagonal D)\nhtransvec : âˆ€ (t : Matrix.TransvectionStruct n ğ•œ), P t.toMatrix\nhmul : âˆ€ (A B : Matrix n n ğ•œ), P A â†’ P B â†’ P (HMul.hMul A B)\nâŠ¢ P M","decl":"/-- Induction principle for matrices based on transvections: if a property is true for all diagonal\nmatrices, all transvections, and is stable under product, then it is true for all matrices. This is\nthe useful way to say that matrices are generated by diagonal matrices and transvections.\n\nWe state a slightly more general version: to prove a property for a matrix `M`, it suffices to\nassume that the diagonal matrices we consider have the same determinant as `M`. This is useful to\nobtain similar principles for `SLâ‚™` or `GLâ‚™`. -/\ntheorem diagonal_transvection_induction (P : Matrix n n ğ•œ â†’ Prop) (M : Matrix n n ğ•œ)\n    (hdiag : âˆ€ D : n â†’ ğ•œ, det (diagonal D) = det M â†’ P (diagonal D))\n    (htransvec : âˆ€ t : TransvectionStruct n ğ•œ, P t.toMatrix) (hmul : âˆ€ A B, P A â†’ P B â†’ P (A * B)) :\n    P M := by\n  rcases exists_list_transvec_mul_diagonal_mul_list_transvec M with âŸ¨L, L', D, hâŸ©\n  have PD : P (diagonal D) := hdiag D (by simp [h])\n  suffices H :\n    âˆ€ (Lâ‚ Lâ‚‚ : List (TransvectionStruct n ğ•œ)) (E : Matrix n n ğ•œ),\n      P E â†’ P ((Lâ‚.map toMatrix).prod * E * (Lâ‚‚.map toMatrix).prod) by\n    rw [h]\n    apply H L L'\n    exact PD\n  intro Lâ‚ Lâ‚‚ E PE\n  induction' Lâ‚ with t Lâ‚ IH\n  Â· simp only [Matrix.one_mul, List.prod_nil, List.map]\n    induction' Lâ‚‚ with t Lâ‚‚ IH generalizing E\n    Â· simpa\n    Â· simp only [â† Matrix.mul_assoc, List.prod_cons, List.map]\n      apply IH\n      exact hmul _ _ PE (htransvec _)\n  Â· simp only [Matrix.mul_assoc, List.prod_cons, List.map] at IH âŠ¢\n    exact hmul _ _ (htransvec _) IH\n\n"}
{"name":"Matrix.diagonal_transvection_induction_of_det_ne_zero","module":"Mathlib.LinearAlgebra.Matrix.Transvection","initialProofState":"n : Type u_1\nğ•œ : Type u_3\ninstâœÂ² : Field ğ•œ\ninstâœÂ¹ : DecidableEq n\ninstâœ : Fintype n\nP : Matrix n n ğ•œ â†’ Prop\nM : Matrix n n ğ•œ\nhMdet : Ne M.det 0\nhdiag : âˆ€ (D : n â†’ ğ•œ), Ne (Matrix.diagonal D).det 0 â†’ P (Matrix.diagonal D)\nhtransvec : âˆ€ (t : Matrix.TransvectionStruct n ğ•œ), P t.toMatrix\nhmul : âˆ€ (A B : Matrix n n ğ•œ), Ne A.det 0 â†’ Ne B.det 0 â†’ P A â†’ P B â†’ P (HMul.hMul A B)\nâŠ¢ P M","decl":"/-- Induction principle for invertible matrices based on transvections: if a property is true for\nall invertible diagonal matrices, all transvections, and is stable under product of invertible\nmatrices, then it is true for all invertible matrices. This is the useful way to say that\ninvertible matrices are generated by invertible diagonal matrices and transvections. -/\ntheorem diagonal_transvection_induction_of_det_ne_zero (P : Matrix n n ğ•œ â†’ Prop) (M : Matrix n n ğ•œ)\n    (hMdet : det M â‰  0) (hdiag : âˆ€ D : n â†’ ğ•œ, det (diagonal D) â‰  0 â†’ P (diagonal D))\n    (htransvec : âˆ€ t : TransvectionStruct n ğ•œ, P t.toMatrix)\n    (hmul : âˆ€ A B, det A â‰  0 â†’ det B â‰  0 â†’ P A â†’ P B â†’ P (A * B)) : P M := by\n  let Q : Matrix n n ğ•œ â†’ Prop := fun N => det N â‰  0 âˆ§ P N\n  have : Q M := by\n    apply diagonal_transvection_induction Q M\n    Â· intro D hD\n      have detD : det (diagonal D) â‰  0 := by\n        rw [hD]\n        exact hMdet\n      exact âŸ¨detD, hdiag _ detDâŸ©\n    Â· intro t\n      exact âŸ¨by simp, htransvec tâŸ©\n    Â· intro A B QA QB\n      exact âŸ¨by simp [QA.1, QB.1], hmul A B QA.1 QB.1 QA.2 QB.2âŸ©\n  exact this.2\n\n"}
