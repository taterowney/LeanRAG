{"name":"CategoryTheory.IsPushout.IsVanKampen.flip","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\nH : CategoryTheory.IsPushout f g h i\nH' : H.IsVanKampen\n⊢ ⋯.IsVanKampen","decl":"theorem IsPushout.IsVanKampen.flip {H : IsPushout f g h i} (H' : H.IsVanKampen) :\n    H.flip.IsVanKampen := by\n  introv W' hf hg hh hi w\n  simpa only [IsPushout.flip_iff, IsPullback.flip_iff, and_comm] using\n    H' g' f' i' h' αW αY αX αZ hg hf hi hh w.flip\n\n"}
{"name":"CategoryTheory.IsPushout.isVanKampen_iff","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\nH : CategoryTheory.IsPushout f g h i\n⊢ Iff H.IsVanKampen (CategoryTheory.IsVanKampenColimit (CategoryTheory.Limits.PushoutCocone.mk h i ⋯))","decl":"theorem IsPushout.isVanKampen_iff (H : IsPushout f g h i) :\n    H.IsVanKampen ↔ IsVanKampenColimit (PushoutCocone.mk h i H.w) := by\n  constructor\n  · intro H F' c' α fα eα hα\n    refine Iff.trans ?_\n        ((H (F'.map WalkingSpan.Hom.fst) (F'.map WalkingSpan.Hom.snd) (c'.ι.app _) (c'.ι.app _)\n          (α.app _) (α.app _) (α.app _) fα (by convert hα WalkingSpan.Hom.fst)\n          (by convert hα WalkingSpan.Hom.snd) ?_ ?_ ?_).trans ?_)\n    · have : F'.map WalkingSpan.Hom.fst ≫ c'.ι.app WalkingSpan.left =\n          F'.map WalkingSpan.Hom.snd ≫ c'.ι.app WalkingSpan.right := by\n        simp only [Cocone.w]\n      rw [(IsColimit.equivOfNatIsoOfIso (diagramIsoSpan F') c' (PushoutCocone.mk _ _ this)\n            _).nonempty_congr]\n      · exact ⟨fun h => ⟨⟨this⟩, h⟩, fun h => h.2⟩\n      · refine Cocones.ext (Iso.refl c'.pt) ?_\n        rintro (_ | _ | _) <;> dsimp <;>\n          simp only [c'.w, Category.assoc, Category.id_comp, Category.comp_id]\n    · exact ⟨NatTrans.congr_app eα.symm _⟩\n    · exact ⟨NatTrans.congr_app eα.symm _⟩\n    · exact ⟨by simp⟩\n    constructor\n    · rintro ⟨h₁, h₂⟩ (_ | _ | _)\n      · rw [← c'.w WalkingSpan.Hom.fst]; exact (hα WalkingSpan.Hom.fst).paste_horiz h₁\n      exacts [h₁, h₂]\n    · intro h; exact ⟨h _, h _⟩\n  · introv H W' hf hg hh hi w\n    refine\n      Iff.trans ?_ ((H w.cocone ⟨by rintro (_ | _ | _); exacts [αW, αX, αY], ?_⟩ αZ ?_ ?_).trans ?_)\n    rotate_left\n    · rintro i _ (_ | _ | _)\n      · dsimp; simp only [Functor.map_id, Category.comp_id, Category.id_comp]\n      exacts [hf.w, hg.w]\n    · ext (_ | _ | _)\n      · dsimp; rw [PushoutCocone.condition_zero]; erw [Category.assoc, hh.w, hf.w_assoc]\n      exacts [hh.w.symm, hi.w.symm]\n    · rintro i _ (_ | _ | _)\n      · dsimp; simp_rw [Functor.map_id]\n        exact IsPullback.of_horiz_isIso ⟨by rw [Category.comp_id, Category.id_comp]⟩\n      exacts [hf, hg]\n    · constructor\n      · intro h; exact ⟨h WalkingCospan.left, h WalkingCospan.right⟩\n      · rintro ⟨h₁, h₂⟩ (_ | _ | _)\n        · dsimp; rw [PushoutCocone.condition_zero]; exact hf.paste_horiz h₁\n        exacts [h₁, h₂]\n    · exact ⟨fun h => h.2, fun h => ⟨w, h⟩⟩\n\n"}
{"name":"CategoryTheory.is_coprod_iff_isPushout","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX E Y YE : C\nc : CategoryTheory.Limits.BinaryCofan X E\nhc : CategoryTheory.Limits.IsColimit c\nf : Quiver.Hom X Y\niY : Quiver.Hom Y YE\nfE : Quiver.Hom c.pt YE\nH : CategoryTheory.CommSq f c.inl iY fE\n⊢ Iff (Nonempty (CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.BinaryCofan.mk (CategoryTheory.CategoryStruct.comp c.inr fE) iY))) (CategoryTheory.IsPushout f c.inl iY fE)","decl":"theorem is_coprod_iff_isPushout {X E Y YE : C} (c : BinaryCofan X E) (hc : IsColimit c) {f : X ⟶ Y}\n    {iY : Y ⟶ YE} {fE : c.pt ⟶ YE} (H : CommSq f c.inl iY fE) :\n    Nonempty (IsColimit (BinaryCofan.mk (c.inr ≫ fE) iY)) ↔ IsPushout f c.inl iY fE := by\n  constructor\n  · rintro ⟨h⟩\n    refine ⟨H, ⟨Limits.PushoutCocone.isColimitAux' _ ?_⟩⟩\n    intro s\n    dsimp only [PushoutCocone.inr, PushoutCocone.mk] -- Porting note: Originally `dsimp`\n    refine ⟨h.desc (BinaryCofan.mk (c.inr ≫ s.inr) s.inl), h.fac _ ⟨WalkingPair.right⟩, ?_, ?_⟩\n    · apply BinaryCofan.IsColimit.hom_ext hc\n      · rw [← H.w_assoc]; erw [h.fac _ ⟨WalkingPair.right⟩]; exact s.condition\n      · rw [← Category.assoc]; exact h.fac _ ⟨WalkingPair.left⟩\n    · intro m e₁ e₂\n      apply BinaryCofan.IsColimit.hom_ext h\n      · dsimp only [BinaryCofan.mk, id] -- Porting note: Originally `dsimp`\n        rw [Category.assoc, e₂, eq_comm]; exact h.fac _ ⟨WalkingPair.left⟩\n      · refine e₁.trans (Eq.symm ?_); exact h.fac _ _\n  · refine fun H => ⟨?_⟩\n    fapply Limits.BinaryCofan.isColimitMk\n    · exact fun s => H.isColimit.desc (PushoutCocone.mk s.inr _ <|\n        (hc.fac (BinaryCofan.mk (f ≫ s.inr) s.inl) ⟨WalkingPair.left⟩).symm)\n    · intro s\n      erw [Category.assoc, H.isColimit.fac _ WalkingSpan.right, hc.fac]; rfl\n    · intro s; exact H.isColimit.fac _ WalkingSpan.left\n    · intro s m e₁ e₂\n      apply PushoutCocone.IsColimit.hom_ext H.isColimit\n      · symm; exact (H.isColimit.fac _ WalkingSpan.left).trans e₂.symm\n      · rw [H.isColimit.fac _ WalkingSpan.right]\n        apply BinaryCofan.IsColimit.hom_ext hc\n        · erw [hc.fac, ← H.w_assoc, e₂]; rfl\n        · refine ((Category.assoc _ _ _).symm.trans e₁).trans ?_; symm; exact hc.fac _ _\n\n"}
{"name":"CategoryTheory.IsPushout.isVanKampen_inl","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW E X Z : C\nc : CategoryTheory.Limits.BinaryCofan W E\ninst✝¹ : CategoryTheory.FinitaryExtensive C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nhc : CategoryTheory.Limits.IsColimit c\nf : Quiver.Hom W X\nh : Quiver.Hom X Z\ni : Quiver.Hom c.pt Z\nH : CategoryTheory.IsPushout f c.inl h i\n⊢ H.IsVanKampen","decl":"theorem IsPushout.isVanKampen_inl {W E X Z : C} (c : BinaryCofan W E) [FinitaryExtensive C]\n    [HasPullbacks C] (hc : IsColimit c) (f : W ⟶ X) (h : X ⟶ Z) (i : c.pt ⟶ Z)\n    (H : IsPushout f c.inl h i) : H.IsVanKampen := by\n  obtain ⟨hc₁⟩ := (is_coprod_iff_isPushout c hc H.1).mpr H\n  introv W' hf hg hh hi w\n  obtain ⟨hc₂⟩ := ((BinaryCofan.isVanKampen_iff _).mp (FinitaryExtensive.vanKampen c hc)\n    (BinaryCofan.mk _ (pullback.fst _ _)) _ _ _ hg.w.symm pullback.condition.symm).mpr\n    ⟨hg, IsPullback.of_hasPullback αY c.inr⟩\n  refine (is_coprod_iff_isPushout _ hc₂ w).symm.trans ?_\n  refine ((BinaryCofan.isVanKampen_iff _).mp (FinitaryExtensive.vanKampen _ hc₁)\n    (BinaryCofan.mk _ _) (pullback.snd _ _) _ _ ?_ hh.w.symm).trans ?_\n  · dsimp; rw [← pullback.condition_assoc, Category.assoc, hi.w]\n  constructor\n  · rintro ⟨hc₃, hc₄⟩\n    refine ⟨hc₄, ?_⟩\n    let Y'' := pullback αZ i\n    let cmp : Y' ⟶ Y'' := pullback.lift i' αY hi.w\n    have e₁ : (g' ≫ cmp) ≫ pullback.snd _ _ = αW ≫ c.inl := by\n      rw [Category.assoc, pullback.lift_snd, hg.w]\n    have e₂ : (pullback.fst _ _ ≫ cmp : pullback αY c.inr ⟶ _) ≫ pullback.snd _ _ =\n        pullback.snd _ _ ≫ c.inr := by\n      rw [Category.assoc, pullback.lift_snd, pullback.condition]\n    obtain ⟨hc₄⟩ := ((BinaryCofan.isVanKampen_iff _).mp (FinitaryExtensive.vanKampen c hc)\n      (BinaryCofan.mk _ _) αW _ _ e₁.symm e₂.symm).mpr <| by\n        constructor\n        · apply IsPullback.of_right _ e₁ (IsPullback.of_hasPullback _ _)\n          rw [Category.assoc, pullback.lift_fst, ← H.w, ← w.w]; exact hf.paste_horiz hc₄\n        · apply IsPullback.of_right _ e₂ (IsPullback.of_hasPullback _ _)\n          rw [Category.assoc, pullback.lift_fst]; exact hc₃\n    rw [← Category.id_comp αZ, ← show cmp ≫ pullback.snd _ _ = αY from pullback.lift_snd _ _ _]\n    apply IsPullback.paste_vert _ (IsPullback.of_hasPullback αZ i)\n    have : cmp = (hc₂.coconePointUniqueUpToIso hc₄).hom := by\n      apply BinaryCofan.IsColimit.hom_ext hc₂\n      exacts [(hc₂.comp_coconePointUniqueUpToIso_hom hc₄ ⟨WalkingPair.left⟩).symm,\n        (hc₂.comp_coconePointUniqueUpToIso_hom hc₄ ⟨WalkingPair.right⟩).symm]\n    rw [this]\n    exact IsPullback.of_vert_isIso ⟨by rw [← this, Category.comp_id, pullback.lift_fst]⟩\n  · rintro ⟨hc₃, hc₄⟩\n    exact ⟨(IsPullback.of_hasPullback αY c.inr).paste_horiz hc₄, hc₃⟩\n\n"}
{"name":"CategoryTheory.IsPushout.IsVanKampen.isPullback_of_mono_left","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Mono f\nH : CategoryTheory.IsPushout f g h i\nH' : H.IsVanKampen\n⊢ CategoryTheory.IsPullback f g h i","decl":"theorem IsPushout.IsVanKampen.isPullback_of_mono_left [Mono f] {H : IsPushout f g h i}\n    (H' : H.IsVanKampen) : IsPullback f g h i :=\n  ((H' (𝟙 _) g g (𝟙 Y) (𝟙 _) f (𝟙 _) i (IsKernelPair.id_of_mono f)\n      (IsPullback.of_vert_isIso ⟨by simp⟩) H.1.flip ⟨rfl⟩ ⟨by simp⟩).mp\n    (IsPushout.of_horiz_isIso ⟨by simp⟩)).1.flip\n\n"}
{"name":"CategoryTheory.IsPushout.IsVanKampen.isPullback_of_mono_right","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Mono g\nH : CategoryTheory.IsPushout f g h i\nH' : H.IsVanKampen\n⊢ CategoryTheory.IsPullback f g h i","decl":"theorem IsPushout.IsVanKampen.isPullback_of_mono_right [Mono g] {H : IsPushout f g h i}\n    (H' : H.IsVanKampen) : IsPullback f g h i :=\n  ((H' f (𝟙 _) (𝟙 _) f (𝟙 _) (𝟙 _) g h (IsPullback.of_vert_isIso ⟨by simp⟩)\n      (IsKernelPair.id_of_mono g) ⟨rfl⟩ H.1 ⟨by simp⟩).mp\n    (IsPushout.of_vert_isIso ⟨by simp⟩)).2\n\n"}
{"name":"CategoryTheory.IsPushout.IsVanKampen.mono_of_mono_left","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Mono f\nH : CategoryTheory.IsPushout f g h i\nH' : H.IsVanKampen\n⊢ CategoryTheory.Mono i","decl":"theorem IsPushout.IsVanKampen.mono_of_mono_left [Mono f] {H : IsPushout f g h i}\n    (H' : H.IsVanKampen) : Mono i :=\n  IsKernelPair.mono_of_isIso_fst\n    ((H' (𝟙 _) g g (𝟙 Y) (𝟙 _) f (𝟙 _) i (IsKernelPair.id_of_mono f)\n        (IsPullback.of_vert_isIso ⟨by simp⟩) H.1.flip ⟨rfl⟩ ⟨by simp⟩).mp\n      (IsPushout.of_horiz_isIso ⟨by simp⟩)).2\n\n"}
{"name":"CategoryTheory.IsPushout.IsVanKampen.mono_of_mono_right","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Mono g\nH : CategoryTheory.IsPushout f g h i\nH' : H.IsVanKampen\n⊢ CategoryTheory.Mono h","decl":"theorem IsPushout.IsVanKampen.mono_of_mono_right [Mono g] {H : IsPushout f g h i}\n    (H' : H.IsVanKampen) : Mono h :=\n  IsKernelPair.mono_of_isIso_fst\n    ((H' f (𝟙 _) (𝟙 _) f (𝟙 _) (𝟙 _) g h (IsPullback.of_vert_isIso ⟨by simp⟩)\n        (IsKernelPair.id_of_mono g) ⟨rfl⟩ H.1 ⟨by simp⟩).mp\n      (IsPushout.of_vert_isIso ⟨by simp⟩)).1\n\n"}
{"name":"CategoryTheory.Adhesive.van_kampen","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Adhesive C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Mono f\nH : CategoryTheory.IsPushout f g h i\n⊢ H.IsVanKampen","decl":"/-- A category is adhesive if it has pushouts and pullbacks along monomorphisms,\nand such pushouts are van Kampen. -/\nclass Adhesive (C : Type u) [Category.{v} C] : Prop where\n  [hasPullback_of_mono_left : ∀ {X Y S : C} (f : X ⟶ S) (g : Y ⟶ S) [Mono f], HasPullback f g]\n  [hasPushout_of_mono_left : ∀ {X Y S : C} (f : S ⟶ X) (g : S ⟶ Y) [Mono f], HasPushout f g]\n  van_kampen : ∀ {W X Y Z : C} {f : W ⟶ X} {g : W ⟶ Y} {h : X ⟶ Z} {i : Y ⟶ Z} [Mono f]\n    (H : IsPushout f g h i), H.IsVanKampen\n\n"}
{"name":"CategoryTheory.Adhesive.hasPushout_of_mono_left","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Adhesive C\nX Y S : C\nf : Quiver.Hom S X\ng : Quiver.Hom S Y\ninst✝ : CategoryTheory.Mono f\n⊢ CategoryTheory.Limits.HasPushout f g","decl":"/-- A category is adhesive if it has pushouts and pullbacks along monomorphisms,\nand such pushouts are van Kampen. -/\nclass Adhesive (C : Type u) [Category.{v} C] : Prop where\n  [hasPullback_of_mono_left : ∀ {X Y S : C} (f : X ⟶ S) (g : Y ⟶ S) [Mono f], HasPullback f g]\n  [hasPushout_of_mono_left : ∀ {X Y S : C} (f : S ⟶ X) (g : S ⟶ Y) [Mono f], HasPushout f g]\n  van_kampen : ∀ {W X Y Z : C} {f : W ⟶ X} {g : W ⟶ Y} {h : X ⟶ Z} {i : Y ⟶ Z} [Mono f]\n    (H : IsPushout f g h i), H.IsVanKampen\n\n"}
{"name":"CategoryTheory.Adhesive.hasPullback_of_mono_left","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Adhesive C\nX Y S : C\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\ninst✝ : CategoryTheory.Mono f\n⊢ CategoryTheory.Limits.HasPullback f g","decl":"/-- A category is adhesive if it has pushouts and pullbacks along monomorphisms,\nand such pushouts are van Kampen. -/\nclass Adhesive (C : Type u) [Category.{v} C] : Prop where\n  [hasPullback_of_mono_left : ∀ {X Y S : C} (f : X ⟶ S) (g : Y ⟶ S) [Mono f], HasPullback f g]\n  [hasPushout_of_mono_left : ∀ {X Y S : C} (f : S ⟶ X) (g : S ⟶ Y) [Mono f], HasPushout f g]\n  van_kampen : ∀ {W X Y Z : C} {f : W ⟶ X} {g : W ⟶ Y} {h : X ⟶ Z} {i : Y ⟶ Z} [Mono f]\n    (H : IsPushout f g h i), H.IsVanKampen\n\n"}
{"name":"CategoryTheory.Adhesive.van_kampen'","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.Adhesive C\ninst✝ : CategoryTheory.Mono g\nH : CategoryTheory.IsPushout f g h i\n⊢ H.IsVanKampen","decl":"theorem Adhesive.van_kampen' [Adhesive C] [Mono g] (H : IsPushout f g h i) : H.IsVanKampen :=\n  (Adhesive.van_kampen H.flip).flip\n\n"}
{"name":"CategoryTheory.Adhesive.isPullback_of_isPushout_of_mono_left","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.Adhesive C\nH : CategoryTheory.IsPushout f g h i\ninst✝ : CategoryTheory.Mono f\n⊢ CategoryTheory.IsPullback f g h i","decl":"theorem Adhesive.isPullback_of_isPushout_of_mono_left [Adhesive C] (H : IsPushout f g h i)\n    [Mono f] : IsPullback f g h i :=\n  (Adhesive.van_kampen H).isPullback_of_mono_left\n\n"}
{"name":"CategoryTheory.Adhesive.isPullback_of_isPushout_of_mono_right","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.Adhesive C\nH : CategoryTheory.IsPushout f g h i\ninst✝ : CategoryTheory.Mono g\n⊢ CategoryTheory.IsPullback f g h i","decl":"theorem Adhesive.isPullback_of_isPushout_of_mono_right [Adhesive C] (H : IsPushout f g h i)\n    [Mono g] : IsPullback f g h i :=\n  (Adhesive.van_kampen' H).isPullback_of_mono_right\n\n"}
{"name":"CategoryTheory.Adhesive.mono_of_isPushout_of_mono_left","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.Adhesive C\nH : CategoryTheory.IsPushout f g h i\ninst✝ : CategoryTheory.Mono f\n⊢ CategoryTheory.Mono i","decl":"theorem Adhesive.mono_of_isPushout_of_mono_left [Adhesive C] (H : IsPushout f g h i) [Mono f] :\n    Mono i :=\n  (Adhesive.van_kampen H).mono_of_mono_left\n\n"}
{"name":"CategoryTheory.Adhesive.mono_of_isPushout_of_mono_right","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.Adhesive C\nH : CategoryTheory.IsPushout f g h i\ninst✝ : CategoryTheory.Mono g\n⊢ CategoryTheory.Mono h","decl":"theorem Adhesive.mono_of_isPushout_of_mono_right [Adhesive C] (H : IsPushout f g h i) [Mono g] :\n    Mono h :=\n  (Adhesive.van_kampen' H).mono_of_mono_right\n\n"}
{"name":"CategoryTheory.Type.adhesive","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"⊢ CategoryTheory.Adhesive (Type u)","decl":"instance Type.adhesive : Adhesive (Type u) :=\n  ⟨fun {_ _ _ _ f _ _ _ _} H =>\n    (IsPushout.isVanKampen_inl _ (Types.isCoprodOfMono f) _ _ _ H.flip).flip⟩\n\n"}
{"name":"CategoryTheory.Adhesive.toRegularMonoCategory","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Adhesive C\n⊢ CategoryTheory.IsRegularMonoCategory C","decl":"noncomputable instance (priority := 100) Adhesive.toRegularMonoCategory [Adhesive C] :\n    IsRegularMonoCategory C :=\n  ⟨fun f _ => ⟨{\n      Z := pushout f f\n      left := pushout.inl _ _\n      right := pushout.inr _ _\n      w := pushout.condition\n      isLimit := (Adhesive.isPullback_of_isPushout_of_mono_left\n        (IsPushout.of_hasPushout f f)).isLimitFork }⟩⟩\n\n-- This then implies that adhesive categories are balanced\n"}
{"name":"CategoryTheory.adhesive_functor","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u''\ninst✝³ : CategoryTheory.Category.{v'', u''} D\ninst✝² : CategoryTheory.Adhesive C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\ninst✝ : CategoryTheory.Limits.HasPushouts C\n⊢ CategoryTheory.Adhesive (CategoryTheory.Functor D C)","decl":"instance adhesive_functor [Adhesive C] [HasPullbacks C] [HasPushouts C] :\n    Adhesive (D ⥤ C) := by\n  constructor\n  intros W X Y Z f g h i hf H\n  rw [IsPushout.isVanKampen_iff]\n  apply isVanKampenColimit_of_evaluation\n  intro x\n  refine (IsVanKampenColimit.precompose_isIso_iff (diagramIsoSpan _).inv).mp ?_\n  refine IsVanKampenColimit.of_iso ?_ (PushoutCocone.isoMk _).symm\n  refine (IsPushout.isVanKampen_iff (H.map ((evaluation _ _).obj x))).mp ?_\n  apply Adhesive.van_kampen\n\n"}
{"name":"CategoryTheory.adhesive_of_preserves_and_reflects","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u''\ninst✝⁵ : CategoryTheory.Category.{v'', u''} D\nF : CategoryTheory.Functor C D\ninst✝⁴ : CategoryTheory.Adhesive D\nH₁ : ∀ {X Y S : C} (f : Quiver.Hom X S) (g : Quiver.Hom Y S) [inst : CategoryTheory.Mono f], CategoryTheory.Limits.HasPullback f g\nH₂ : ∀ {X Y S : C} (f : Quiver.Hom S X) (g : Quiver.Hom S Y) [inst : CategoryTheory.Mono f], CategoryTheory.Limits.HasPushout f g\ninst✝³ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingCospan F\ninst✝² : CategoryTheory.Limits.ReflectsLimitsOfShape CategoryTheory.Limits.WalkingCospan F\ninst✝¹ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingSpan F\ninst✝ : CategoryTheory.Limits.ReflectsColimitsOfShape CategoryTheory.Limits.WalkingSpan F\n⊢ CategoryTheory.Adhesive C","decl":"theorem adhesive_of_preserves_and_reflects (F : C ⥤ D) [Adhesive D]\n    [H₁ : ∀ {X Y S : C} (f : X ⟶ S) (g : Y ⟶ S) [Mono f], HasPullback f g]\n    [H₂ : ∀ {X Y S : C} (f : S ⟶ X) (g : S ⟶ Y) [Mono f], HasPushout f g]\n    [PreservesLimitsOfShape WalkingCospan F]\n    [ReflectsLimitsOfShape WalkingCospan F]\n    [PreservesColimitsOfShape WalkingSpan F]\n    [ReflectsColimitsOfShape WalkingSpan F] :\n    Adhesive C := by\n  apply Adhesive.mk (hasPullback_of_mono_left := H₁) (hasPushout_of_mono_left := H₂)\n  intros W X Y Z f g h i hf H\n  rw [IsPushout.isVanKampen_iff]\n  refine IsVanKampenColimit.of_mapCocone F ?_\n  refine (IsVanKampenColimit.precompose_isIso_iff (diagramIsoSpan _).inv).mp ?_\n  refine IsVanKampenColimit.of_iso ?_ (PushoutCocone.isoMk _).symm\n  refine (IsPushout.isVanKampen_iff (H.map F)).mp ?_\n  apply Adhesive.van_kampen\n\n"}
{"name":"CategoryTheory.adhesive_of_preserves_and_reflects_isomorphism","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst✝⁷ : CategoryTheory.Category.{v, u} C\nD : Type u''\ninst✝⁶ : CategoryTheory.Category.{v'', u''} D\nF : CategoryTheory.Functor C D\ninst✝⁵ : CategoryTheory.Adhesive D\ninst✝⁴ : CategoryTheory.Limits.HasPullbacks C\ninst✝³ : CategoryTheory.Limits.HasPushouts C\ninst✝² : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingCospan F\ninst✝¹ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingSpan F\ninst✝ : F.ReflectsIsomorphisms\n⊢ CategoryTheory.Adhesive C","decl":"theorem adhesive_of_preserves_and_reflects_isomorphism (F : C ⥤ D)\n    [Adhesive D] [HasPullbacks C] [HasPushouts C]\n    [PreservesLimitsOfShape WalkingCospan F]\n    [PreservesColimitsOfShape WalkingSpan F]\n    [F.ReflectsIsomorphisms] :\n    Adhesive C := by\n  haveI : ReflectsLimitsOfShape WalkingCospan F :=\n    reflectsLimitsOfShape_of_reflectsIsomorphisms\n  haveI : ReflectsColimitsOfShape WalkingSpan F :=\n    reflectsColimitsOfShape_of_reflectsIsomorphisms\n  exact adhesive_of_preserves_and_reflects F\n\n"}
{"name":"CategoryTheory.adhesive_of_reflective","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst✝⁸ : CategoryTheory.Category.{v, u} C\nD : Type u''\ninst✝⁷ : CategoryTheory.Category.{v'', u''} D\ninst✝⁶ : CategoryTheory.Limits.HasPullbacks D\ninst✝⁵ : CategoryTheory.Adhesive C\ninst✝⁴ : CategoryTheory.Limits.HasPullbacks C\ninst✝³ : CategoryTheory.Limits.HasPushouts C\nH₂ : ∀ {X Y S : D} (f : Quiver.Hom S X) (g : Quiver.Hom S Y) [inst : CategoryTheory.Mono f], CategoryTheory.Limits.HasPushout f g\nGl : CategoryTheory.Functor C D\nGr : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction Gl Gr\ninst✝² : Gr.Full\ninst✝¹ : Gr.Faithful\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingCospan Gl\n⊢ CategoryTheory.Adhesive D","decl":"theorem adhesive_of_reflective [HasPullbacks D] [Adhesive C] [HasPullbacks C] [HasPushouts C]\n    [H₂ : ∀ {X Y S : D} (f : S ⟶ X) (g : S ⟶ Y) [Mono f], HasPushout f g]\n    {Gl : C ⥤ D} {Gr : D ⥤ C} (adj : Gl ⊣ Gr) [Gr.Full] [Gr.Faithful]\n    [PreservesLimitsOfShape WalkingCospan Gl] :\n    Adhesive D := by\n  have := adj.leftAdjoint_preservesColimits\n  have := adj.rightAdjoint_preservesLimits\n  apply Adhesive.mk (hasPushout_of_mono_left := H₂)\n  intro W X Y Z f g h i _ H\n  have := Adhesive.van_kampen (IsPushout.of_hasPushout (Gr.map f) (Gr.map g))\n  rw [IsPushout.isVanKampen_iff] at this ⊢\n  refine (IsVanKampenColimit.precompose_isIso_iff\n    (isoWhiskerLeft _ (asIso adj.counit) ≪≫ Functor.rightUnitor _).hom).mp ?_\n  refine ((this.precompose_isIso (spanCompIso _ _ _).hom).map_reflective adj).of_iso\n    (IsColimit.uniqueUpToIso ?_ ?_)\n  · exact isColimitOfPreserves Gl ((IsColimit.precomposeHomEquiv _ _).symm <| pushoutIsPushout _ _)\n  · exact (IsColimit.precomposeHomEquiv _ _).symm H.isColimit\n\n"}
