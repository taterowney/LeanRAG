{"name":"CategoryTheory.IsPushout.IsVanKampen.flip","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\nH : CategoryTheory.IsPushout f g h i\nH' : H.IsVanKampen\n‚ä¢ ‚ãØ.IsVanKampen","decl":"theorem IsPushout.IsVanKampen.flip {H : IsPushout f g h i} (H' : H.IsVanKampen) :\n    H.flip.IsVanKampen := by\n  introv W' hf hg hh hi w\n  simpa only [IsPushout.flip_iff, IsPullback.flip_iff, and_comm] using\n    H' g' f' i' h' Œ±W Œ±Y Œ±X Œ±Z hg hf hi hh w.flip\n\n"}
{"name":"CategoryTheory.IsPushout.isVanKampen_iff","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\nH : CategoryTheory.IsPushout f g h i\n‚ä¢ Iff H.IsVanKampen (CategoryTheory.IsVanKampenColimit (CategoryTheory.Limits.PushoutCocone.mk h i ‚ãØ))","decl":"theorem IsPushout.isVanKampen_iff (H : IsPushout f g h i) :\n    H.IsVanKampen ‚Üî IsVanKampenColimit (PushoutCocone.mk h i H.w) := by\n  constructor\n  ¬∑ intro H F' c' Œ± fŒ± eŒ± hŒ±\n    refine Iff.trans ?_\n        ((H (F'.map WalkingSpan.Hom.fst) (F'.map WalkingSpan.Hom.snd) (c'.Œπ.app _) (c'.Œπ.app _)\n          (Œ±.app _) (Œ±.app _) (Œ±.app _) fŒ± (by convert hŒ± WalkingSpan.Hom.fst)\n          (by convert hŒ± WalkingSpan.Hom.snd) ?_ ?_ ?_).trans ?_)\n    ¬∑ have : F'.map WalkingSpan.Hom.fst ‚â´ c'.Œπ.app WalkingSpan.left =\n          F'.map WalkingSpan.Hom.snd ‚â´ c'.Œπ.app WalkingSpan.right := by\n        simp only [Cocone.w]\n      rw [(IsColimit.equivOfNatIsoOfIso (diagramIsoSpan F') c' (PushoutCocone.mk _ _ this)\n            _).nonempty_congr]\n      ¬∑ exact ‚ü®fun h => ‚ü®‚ü®this‚ü©, h‚ü©, fun h => h.2‚ü©\n      ¬∑ refine Cocones.ext (Iso.refl c'.pt) ?_\n        rintro (_ | _ | _) <;> dsimp <;>\n          simp only [c'.w, Category.assoc, Category.id_comp, Category.comp_id]\n    ¬∑ exact ‚ü®NatTrans.congr_app eŒ±.symm _‚ü©\n    ¬∑ exact ‚ü®NatTrans.congr_app eŒ±.symm _‚ü©\n    ¬∑ exact ‚ü®by simp‚ü©\n    constructor\n    ¬∑ rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© (_ | _ | _)\n      ¬∑ rw [‚Üê c'.w WalkingSpan.Hom.fst]; exact (hŒ± WalkingSpan.Hom.fst).paste_horiz h‚ÇÅ\n      exacts [h‚ÇÅ, h‚ÇÇ]\n    ¬∑ intro h; exact ‚ü®h _, h _‚ü©\n  ¬∑ introv H W' hf hg hh hi w\n    refine\n      Iff.trans ?_ ((H w.cocone ‚ü®by rintro (_ | _ | _); exacts [Œ±W, Œ±X, Œ±Y], ?_‚ü© Œ±Z ?_ ?_).trans ?_)\n    rotate_left\n    ¬∑ rintro i _ (_ | _ | _)\n      ¬∑ dsimp; simp only [Functor.map_id, Category.comp_id, Category.id_comp]\n      exacts [hf.w, hg.w]\n    ¬∑ ext (_ | _ | _)\n      ¬∑ dsimp; rw [PushoutCocone.condition_zero]; erw [Category.assoc, hh.w, hf.w_assoc]\n      exacts [hh.w.symm, hi.w.symm]\n    ¬∑ rintro i _ (_ | _ | _)\n      ¬∑ dsimp; simp_rw [Functor.map_id]\n        exact IsPullback.of_horiz_isIso ‚ü®by rw [Category.comp_id, Category.id_comp]‚ü©\n      exacts [hf, hg]\n    ¬∑ constructor\n      ¬∑ intro h; exact ‚ü®h WalkingCospan.left, h WalkingCospan.right‚ü©\n      ¬∑ rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© (_ | _ | _)\n        ¬∑ dsimp; rw [PushoutCocone.condition_zero]; exact hf.paste_horiz h‚ÇÅ\n        exacts [h‚ÇÅ, h‚ÇÇ]\n    ¬∑ exact ‚ü®fun h => h.2, fun h => ‚ü®w, h‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.is_coprod_iff_isPushout","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX E Y YE : C\nc : CategoryTheory.Limits.BinaryCofan X E\nhc : CategoryTheory.Limits.IsColimit c\nf : Quiver.Hom X Y\niY : Quiver.Hom Y YE\nfE : Quiver.Hom c.pt YE\nH : CategoryTheory.CommSq f c.inl iY fE\n‚ä¢ Iff (Nonempty (CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.BinaryCofan.mk (CategoryTheory.CategoryStruct.comp c.inr fE) iY))) (CategoryTheory.IsPushout f c.inl iY fE)","decl":"theorem is_coprod_iff_isPushout {X E Y YE : C} (c : BinaryCofan X E) (hc : IsColimit c) {f : X ‚ü∂ Y}\n    {iY : Y ‚ü∂ YE} {fE : c.pt ‚ü∂ YE} (H : CommSq f c.inl iY fE) :\n    Nonempty (IsColimit (BinaryCofan.mk (c.inr ‚â´ fE) iY)) ‚Üî IsPushout f c.inl iY fE := by\n  constructor\n  ¬∑ rintro ‚ü®h‚ü©\n    refine ‚ü®H, ‚ü®Limits.PushoutCocone.isColimitAux' _ ?_‚ü©‚ü©\n    intro s\n    dsimp only [PushoutCocone.inr, PushoutCocone.mk] -- Porting note: Originally `dsimp`\n    refine ‚ü®h.desc (BinaryCofan.mk (c.inr ‚â´ s.inr) s.inl), h.fac _ ‚ü®WalkingPair.right‚ü©, ?_, ?_‚ü©\n    ¬∑ apply BinaryCofan.IsColimit.hom_ext hc\n      ¬∑ rw [‚Üê H.w_assoc]; erw [h.fac _ ‚ü®WalkingPair.right‚ü©]; exact s.condition\n      ¬∑ rw [‚Üê Category.assoc]; exact h.fac _ ‚ü®WalkingPair.left‚ü©\n    ¬∑ intro m e‚ÇÅ e‚ÇÇ\n      apply BinaryCofan.IsColimit.hom_ext h\n      ¬∑ dsimp only [BinaryCofan.mk, id] -- Porting note: Originally `dsimp`\n        rw [Category.assoc, e‚ÇÇ, eq_comm]; exact h.fac _ ‚ü®WalkingPair.left‚ü©\n      ¬∑ refine e‚ÇÅ.trans (Eq.symm ?_); exact h.fac _ _\n  ¬∑ refine fun H => ‚ü®?_‚ü©\n    fapply Limits.BinaryCofan.isColimitMk\n    ¬∑ exact fun s => H.isColimit.desc (PushoutCocone.mk s.inr _ <|\n        (hc.fac (BinaryCofan.mk (f ‚â´ s.inr) s.inl) ‚ü®WalkingPair.left‚ü©).symm)\n    ¬∑ intro s\n      erw [Category.assoc, H.isColimit.fac _ WalkingSpan.right, hc.fac]; rfl\n    ¬∑ intro s; exact H.isColimit.fac _ WalkingSpan.left\n    ¬∑ intro s m e‚ÇÅ e‚ÇÇ\n      apply PushoutCocone.IsColimit.hom_ext H.isColimit\n      ¬∑ symm; exact (H.isColimit.fac _ WalkingSpan.left).trans e‚ÇÇ.symm\n      ¬∑ rw [H.isColimit.fac _ WalkingSpan.right]\n        apply BinaryCofan.IsColimit.hom_ext hc\n        ¬∑ erw [hc.fac, ‚Üê H.w_assoc, e‚ÇÇ]; rfl\n        ¬∑ refine ((Category.assoc _ _ _).symm.trans e‚ÇÅ).trans ?_; symm; exact hc.fac _ _\n\n"}
{"name":"CategoryTheory.IsPushout.isVanKampen_inl","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nW E X Z : C\nc : CategoryTheory.Limits.BinaryCofan W E\ninst‚úù¬π : CategoryTheory.FinitaryExtensive C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nhc : CategoryTheory.Limits.IsColimit c\nf : Quiver.Hom W X\nh : Quiver.Hom X Z\ni : Quiver.Hom c.pt Z\nH : CategoryTheory.IsPushout f c.inl h i\n‚ä¢ H.IsVanKampen","decl":"theorem IsPushout.isVanKampen_inl {W E X Z : C} (c : BinaryCofan W E) [FinitaryExtensive C]\n    [HasPullbacks C] (hc : IsColimit c) (f : W ‚ü∂ X) (h : X ‚ü∂ Z) (i : c.pt ‚ü∂ Z)\n    (H : IsPushout f c.inl h i) : H.IsVanKampen := by\n  obtain ‚ü®hc‚ÇÅ‚ü© := (is_coprod_iff_isPushout c hc H.1).mpr H\n  introv W' hf hg hh hi w\n  obtain ‚ü®hc‚ÇÇ‚ü© := ((BinaryCofan.isVanKampen_iff _).mp (FinitaryExtensive.vanKampen c hc)\n    (BinaryCofan.mk _ (pullback.fst _ _)) _ _ _ hg.w.symm pullback.condition.symm).mpr\n    ‚ü®hg, IsPullback.of_hasPullback Œ±Y c.inr‚ü©\n  refine (is_coprod_iff_isPushout _ hc‚ÇÇ w).symm.trans ?_\n  refine ((BinaryCofan.isVanKampen_iff _).mp (FinitaryExtensive.vanKampen _ hc‚ÇÅ)\n    (BinaryCofan.mk _ _) (pullback.snd _ _) _ _ ?_ hh.w.symm).trans ?_\n  ¬∑ dsimp; rw [‚Üê pullback.condition_assoc, Category.assoc, hi.w]\n  constructor\n  ¬∑ rintro ‚ü®hc‚ÇÉ, hc‚ÇÑ‚ü©\n    refine ‚ü®hc‚ÇÑ, ?_‚ü©\n    let Y'' := pullback Œ±Z i\n    let cmp : Y' ‚ü∂ Y'' := pullback.lift i' Œ±Y hi.w\n    have e‚ÇÅ : (g' ‚â´ cmp) ‚â´ pullback.snd _ _ = Œ±W ‚â´ c.inl := by\n      rw [Category.assoc, pullback.lift_snd, hg.w]\n    have e‚ÇÇ : (pullback.fst _ _ ‚â´ cmp : pullback Œ±Y c.inr ‚ü∂ _) ‚â´ pullback.snd _ _ =\n        pullback.snd _ _ ‚â´ c.inr := by\n      rw [Category.assoc, pullback.lift_snd, pullback.condition]\n    obtain ‚ü®hc‚ÇÑ‚ü© := ((BinaryCofan.isVanKampen_iff _).mp (FinitaryExtensive.vanKampen c hc)\n      (BinaryCofan.mk _ _) Œ±W _ _ e‚ÇÅ.symm e‚ÇÇ.symm).mpr <| by\n        constructor\n        ¬∑ apply IsPullback.of_right _ e‚ÇÅ (IsPullback.of_hasPullback _ _)\n          rw [Category.assoc, pullback.lift_fst, ‚Üê H.w, ‚Üê w.w]; exact hf.paste_horiz hc‚ÇÑ\n        ¬∑ apply IsPullback.of_right _ e‚ÇÇ (IsPullback.of_hasPullback _ _)\n          rw [Category.assoc, pullback.lift_fst]; exact hc‚ÇÉ\n    rw [‚Üê Category.id_comp Œ±Z, ‚Üê show cmp ‚â´ pullback.snd _ _ = Œ±Y from pullback.lift_snd _ _ _]\n    apply IsPullback.paste_vert _ (IsPullback.of_hasPullback Œ±Z i)\n    have : cmp = (hc‚ÇÇ.coconePointUniqueUpToIso hc‚ÇÑ).hom := by\n      apply BinaryCofan.IsColimit.hom_ext hc‚ÇÇ\n      exacts [(hc‚ÇÇ.comp_coconePointUniqueUpToIso_hom hc‚ÇÑ ‚ü®WalkingPair.left‚ü©).symm,\n        (hc‚ÇÇ.comp_coconePointUniqueUpToIso_hom hc‚ÇÑ ‚ü®WalkingPair.right‚ü©).symm]\n    rw [this]\n    exact IsPullback.of_vert_isIso ‚ü®by rw [‚Üê this, Category.comp_id, pullback.lift_fst]‚ü©\n  ¬∑ rintro ‚ü®hc‚ÇÉ, hc‚ÇÑ‚ü©\n    exact ‚ü®(IsPullback.of_hasPullback Œ±Y c.inr).paste_horiz hc‚ÇÑ, hc‚ÇÉ‚ü©\n\n"}
{"name":"CategoryTheory.IsPushout.IsVanKampen.isPullback_of_mono_left","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.Mono f\nH : CategoryTheory.IsPushout f g h i\nH' : H.IsVanKampen\n‚ä¢ CategoryTheory.IsPullback f g h i","decl":"theorem IsPushout.IsVanKampen.isPullback_of_mono_left [Mono f] {H : IsPushout f g h i}\n    (H' : H.IsVanKampen) : IsPullback f g h i :=\n  ((H' (ùüô _) g g (ùüô Y) (ùüô _) f (ùüô _) i (IsKernelPair.id_of_mono f)\n      (IsPullback.of_vert_isIso ‚ü®by simp‚ü©) H.1.flip ‚ü®rfl‚ü© ‚ü®by simp‚ü©).mp\n    (IsPushout.of_horiz_isIso ‚ü®by simp‚ü©)).1.flip\n\n"}
{"name":"CategoryTheory.IsPushout.IsVanKampen.isPullback_of_mono_right","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.Mono g\nH : CategoryTheory.IsPushout f g h i\nH' : H.IsVanKampen\n‚ä¢ CategoryTheory.IsPullback f g h i","decl":"theorem IsPushout.IsVanKampen.isPullback_of_mono_right [Mono g] {H : IsPushout f g h i}\n    (H' : H.IsVanKampen) : IsPullback f g h i :=\n  ((H' f (ùüô _) (ùüô _) f (ùüô _) (ùüô _) g h (IsPullback.of_vert_isIso ‚ü®by simp‚ü©)\n      (IsKernelPair.id_of_mono g) ‚ü®rfl‚ü© H.1 ‚ü®by simp‚ü©).mp\n    (IsPushout.of_vert_isIso ‚ü®by simp‚ü©)).2\n\n"}
{"name":"CategoryTheory.IsPushout.IsVanKampen.mono_of_mono_left","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.Mono f\nH : CategoryTheory.IsPushout f g h i\nH' : H.IsVanKampen\n‚ä¢ CategoryTheory.Mono i","decl":"theorem IsPushout.IsVanKampen.mono_of_mono_left [Mono f] {H : IsPushout f g h i}\n    (H' : H.IsVanKampen) : Mono i :=\n  IsKernelPair.mono_of_isIso_fst\n    ((H' (ùüô _) g g (ùüô Y) (ùüô _) f (ùüô _) i (IsKernelPair.id_of_mono f)\n        (IsPullback.of_vert_isIso ‚ü®by simp‚ü©) H.1.flip ‚ü®rfl‚ü© ‚ü®by simp‚ü©).mp\n      (IsPushout.of_horiz_isIso ‚ü®by simp‚ü©)).2\n\n"}
{"name":"CategoryTheory.IsPushout.IsVanKampen.mono_of_mono_right","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.Mono g\nH : CategoryTheory.IsPushout f g h i\nH' : H.IsVanKampen\n‚ä¢ CategoryTheory.Mono h","decl":"theorem IsPushout.IsVanKampen.mono_of_mono_right [Mono g] {H : IsPushout f g h i}\n    (H' : H.IsVanKampen) : Mono h :=\n  IsKernelPair.mono_of_isIso_fst\n    ((H' f (ùüô _) (ùüô _) f (ùüô _) (ùüô _) g h (IsPullback.of_vert_isIso ‚ü®by simp‚ü©)\n        (IsKernelPair.id_of_mono g) ‚ü®rfl‚ü© H.1 ‚ü®by simp‚ü©).mp\n      (IsPushout.of_vert_isIso ‚ü®by simp‚ü©)).1\n\n"}
{"name":"CategoryTheory.Adhesive.van_kampen","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Adhesive C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.Mono f\nH : CategoryTheory.IsPushout f g h i\n‚ä¢ H.IsVanKampen","decl":"/-- A category is adhesive if it has pushouts and pullbacks along monomorphisms,\nand such pushouts are van Kampen. -/\nclass Adhesive (C : Type u) [Category.{v} C] : Prop where\n  [hasPullback_of_mono_left : ‚àÄ {X Y S : C} (f : X ‚ü∂ S) (g : Y ‚ü∂ S) [Mono f], HasPullback f g]\n  [hasPushout_of_mono_left : ‚àÄ {X Y S : C} (f : S ‚ü∂ X) (g : S ‚ü∂ Y) [Mono f], HasPushout f g]\n  van_kampen : ‚àÄ {W X Y Z : C} {f : W ‚ü∂ X} {g : W ‚ü∂ Y} {h : X ‚ü∂ Z} {i : Y ‚ü∂ Z} [Mono f]\n    (H : IsPushout f g h i), H.IsVanKampen\n\n"}
{"name":"CategoryTheory.Adhesive.hasPushout_of_mono_left","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Adhesive C\nX Y S : C\nf : Quiver.Hom S X\ng : Quiver.Hom S Y\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ CategoryTheory.Limits.HasPushout f g","decl":"/-- A category is adhesive if it has pushouts and pullbacks along monomorphisms,\nand such pushouts are van Kampen. -/\nclass Adhesive (C : Type u) [Category.{v} C] : Prop where\n  [hasPullback_of_mono_left : ‚àÄ {X Y S : C} (f : X ‚ü∂ S) (g : Y ‚ü∂ S) [Mono f], HasPullback f g]\n  [hasPushout_of_mono_left : ‚àÄ {X Y S : C} (f : S ‚ü∂ X) (g : S ‚ü∂ Y) [Mono f], HasPushout f g]\n  van_kampen : ‚àÄ {W X Y Z : C} {f : W ‚ü∂ X} {g : W ‚ü∂ Y} {h : X ‚ü∂ Z} {i : Y ‚ü∂ Z} [Mono f]\n    (H : IsPushout f g h i), H.IsVanKampen\n\n"}
{"name":"CategoryTheory.Adhesive.hasPullback_of_mono_left","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Adhesive C\nX Y S : C\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ CategoryTheory.Limits.HasPullback f g","decl":"/-- A category is adhesive if it has pushouts and pullbacks along monomorphisms,\nand such pushouts are van Kampen. -/\nclass Adhesive (C : Type u) [Category.{v} C] : Prop where\n  [hasPullback_of_mono_left : ‚àÄ {X Y S : C} (f : X ‚ü∂ S) (g : Y ‚ü∂ S) [Mono f], HasPullback f g]\n  [hasPushout_of_mono_left : ‚àÄ {X Y S : C} (f : S ‚ü∂ X) (g : S ‚ü∂ Y) [Mono f], HasPushout f g]\n  van_kampen : ‚àÄ {W X Y Z : C} {f : W ‚ü∂ X} {g : W ‚ü∂ Y} {h : X ‚ü∂ Z} {i : Y ‚ü∂ Z} [Mono f]\n    (H : IsPushout f g h i), H.IsVanKampen\n\n"}
{"name":"CategoryTheory.Adhesive.van_kampen'","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.Adhesive C\ninst‚úù : CategoryTheory.Mono g\nH : CategoryTheory.IsPushout f g h i\n‚ä¢ H.IsVanKampen","decl":"theorem Adhesive.van_kampen' [Adhesive C] [Mono g] (H : IsPushout f g h i) : H.IsVanKampen :=\n  (Adhesive.van_kampen H.flip).flip\n\n"}
{"name":"CategoryTheory.Adhesive.isPullback_of_isPushout_of_mono_left","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.Adhesive C\nH : CategoryTheory.IsPushout f g h i\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ CategoryTheory.IsPullback f g h i","decl":"theorem Adhesive.isPullback_of_isPushout_of_mono_left [Adhesive C] (H : IsPushout f g h i)\n    [Mono f] : IsPullback f g h i :=\n  (Adhesive.van_kampen H).isPullback_of_mono_left\n\n"}
{"name":"CategoryTheory.Adhesive.isPullback_of_isPushout_of_mono_right","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.Adhesive C\nH : CategoryTheory.IsPushout f g h i\ninst‚úù : CategoryTheory.Mono g\n‚ä¢ CategoryTheory.IsPullback f g h i","decl":"theorem Adhesive.isPullback_of_isPushout_of_mono_right [Adhesive C] (H : IsPushout f g h i)\n    [Mono g] : IsPullback f g h i :=\n  (Adhesive.van_kampen' H).isPullback_of_mono_right\n\n"}
{"name":"CategoryTheory.Adhesive.mono_of_isPushout_of_mono_left","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.Adhesive C\nH : CategoryTheory.IsPushout f g h i\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ CategoryTheory.Mono i","decl":"theorem Adhesive.mono_of_isPushout_of_mono_left [Adhesive C] (H : IsPushout f g h i) [Mono f] :\n    Mono i :=\n  (Adhesive.van_kampen H).mono_of_mono_left\n\n"}
{"name":"CategoryTheory.Adhesive.mono_of_isPushout_of_mono_right","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.Adhesive C\nH : CategoryTheory.IsPushout f g h i\ninst‚úù : CategoryTheory.Mono g\n‚ä¢ CategoryTheory.Mono h","decl":"theorem Adhesive.mono_of_isPushout_of_mono_right [Adhesive C] (H : IsPushout f g h i) [Mono g] :\n    Mono h :=\n  (Adhesive.van_kampen' H).mono_of_mono_right\n\n"}
{"name":"CategoryTheory.Type.adhesive","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"‚ä¢ CategoryTheory.Adhesive (Type u)","decl":"instance Type.adhesive : Adhesive (Type u) :=\n  ‚ü®fun {_ _ _ _ f _ _ _ _} H =>\n    (IsPushout.isVanKampen_inl _ (Types.isCoprodOfMono f) _ _ _ H.flip).flip‚ü©\n\n"}
{"name":"CategoryTheory.Adhesive.toRegularMonoCategory","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Adhesive C\n‚ä¢ CategoryTheory.IsRegularMonoCategory C","decl":"noncomputable instance (priority := 100) Adhesive.toRegularMonoCategory [Adhesive C] :\n    IsRegularMonoCategory C :=\n  ‚ü®fun f _ => ‚ü®{\n      Z := pushout f f\n      left := pushout.inl _ _\n      right := pushout.inr _ _\n      w := pushout.condition\n      isLimit := (Adhesive.isPullback_of_isPushout_of_mono_left\n        (IsPushout.of_hasPushout f f)).isLimitFork }‚ü©‚ü©\n\n-- This then implies that adhesive categories are balanced\n"}
{"name":"CategoryTheory.adhesive_functor","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nD : Type u''\ninst‚úù¬≥ : CategoryTheory.Category.{v'', u''} D\ninst‚úù¬≤ : CategoryTheory.Adhesive C\ninst‚úù¬π : CategoryTheory.Limits.HasPullbacks C\ninst‚úù : CategoryTheory.Limits.HasPushouts C\n‚ä¢ CategoryTheory.Adhesive (CategoryTheory.Functor D C)","decl":"instance adhesive_functor [Adhesive C] [HasPullbacks C] [HasPushouts C] :\n    Adhesive (D ‚•§ C) := by\n  constructor\n  intros W X Y Z f g h i hf H\n  rw [IsPushout.isVanKampen_iff]\n  apply isVanKampenColimit_of_evaluation\n  intro x\n  refine (IsVanKampenColimit.precompose_isIso_iff (diagramIsoSpan _).inv).mp ?_\n  refine IsVanKampenColimit.of_iso ?_ (PushoutCocone.isoMk _).symm\n  refine (IsPushout.isVanKampen_iff (H.map ((evaluation _ _).obj x))).mp ?_\n  apply Adhesive.van_kampen\n\n"}
{"name":"CategoryTheory.adhesive_of_preserves_and_reflects","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nD : Type u''\ninst‚úù‚Åµ : CategoryTheory.Category.{v'', u''} D\nF : CategoryTheory.Functor C D\ninst‚úù‚Å¥ : CategoryTheory.Adhesive D\nH‚ÇÅ : ‚àÄ {X Y S : C} (f : Quiver.Hom X S) (g : Quiver.Hom Y S) [inst : CategoryTheory.Mono f], CategoryTheory.Limits.HasPullback f g\nH‚ÇÇ : ‚àÄ {X Y S : C} (f : Quiver.Hom S X) (g : Quiver.Hom S Y) [inst : CategoryTheory.Mono f], CategoryTheory.Limits.HasPushout f g\ninst‚úù¬≥ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingCospan F\ninst‚úù¬≤ : CategoryTheory.Limits.ReflectsLimitsOfShape CategoryTheory.Limits.WalkingCospan F\ninst‚úù¬π : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingSpan F\ninst‚úù : CategoryTheory.Limits.ReflectsColimitsOfShape CategoryTheory.Limits.WalkingSpan F\n‚ä¢ CategoryTheory.Adhesive C","decl":"theorem adhesive_of_preserves_and_reflects (F : C ‚•§ D) [Adhesive D]\n    [H‚ÇÅ : ‚àÄ {X Y S : C} (f : X ‚ü∂ S) (g : Y ‚ü∂ S) [Mono f], HasPullback f g]\n    [H‚ÇÇ : ‚àÄ {X Y S : C} (f : S ‚ü∂ X) (g : S ‚ü∂ Y) [Mono f], HasPushout f g]\n    [PreservesLimitsOfShape WalkingCospan F]\n    [ReflectsLimitsOfShape WalkingCospan F]\n    [PreservesColimitsOfShape WalkingSpan F]\n    [ReflectsColimitsOfShape WalkingSpan F] :\n    Adhesive C := by\n  apply Adhesive.mk (hasPullback_of_mono_left := H‚ÇÅ) (hasPushout_of_mono_left := H‚ÇÇ)\n  intros W X Y Z f g h i hf H\n  rw [IsPushout.isVanKampen_iff]\n  refine IsVanKampenColimit.of_mapCocone F ?_\n  refine (IsVanKampenColimit.precompose_isIso_iff (diagramIsoSpan _).inv).mp ?_\n  refine IsVanKampenColimit.of_iso ?_ (PushoutCocone.isoMk _).symm\n  refine (IsPushout.isVanKampen_iff (H.map F)).mp ?_\n  apply Adhesive.van_kampen\n\n"}
{"name":"CategoryTheory.adhesive_of_preserves_and_reflects_isomorphism","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst‚úù‚Å∑ : CategoryTheory.Category.{v, u} C\nD : Type u''\ninst‚úù‚Å∂ : CategoryTheory.Category.{v'', u''} D\nF : CategoryTheory.Functor C D\ninst‚úù‚Åµ : CategoryTheory.Adhesive D\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasPullbacks C\ninst‚úù¬≥ : CategoryTheory.Limits.HasPushouts C\ninst‚úù¬≤ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingCospan F\ninst‚úù¬π : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingSpan F\ninst‚úù : F.ReflectsIsomorphisms\n‚ä¢ CategoryTheory.Adhesive C","decl":"theorem adhesive_of_preserves_and_reflects_isomorphism (F : C ‚•§ D)\n    [Adhesive D] [HasPullbacks C] [HasPushouts C]\n    [PreservesLimitsOfShape WalkingCospan F]\n    [PreservesColimitsOfShape WalkingSpan F]\n    [F.ReflectsIsomorphisms] :\n    Adhesive C := by\n  haveI : ReflectsLimitsOfShape WalkingCospan F :=\n    reflectsLimitsOfShape_of_reflectsIsomorphisms\n  haveI : ReflectsColimitsOfShape WalkingSpan F :=\n    reflectsColimitsOfShape_of_reflectsIsomorphisms\n  exact adhesive_of_preserves_and_reflects F\n\n"}
{"name":"CategoryTheory.adhesive_of_reflective","module":"Mathlib.CategoryTheory.Adhesive","initialProofState":"C : Type u\ninst‚úù‚Å∏ : CategoryTheory.Category.{v, u} C\nD : Type u''\ninst‚úù‚Å∑ : CategoryTheory.Category.{v'', u''} D\ninst‚úù‚Å∂ : CategoryTheory.Limits.HasPullbacks D\ninst‚úù‚Åµ : CategoryTheory.Adhesive C\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasPullbacks C\ninst‚úù¬≥ : CategoryTheory.Limits.HasPushouts C\nH‚ÇÇ : ‚àÄ {X Y S : D} (f : Quiver.Hom S X) (g : Quiver.Hom S Y) [inst : CategoryTheory.Mono f], CategoryTheory.Limits.HasPushout f g\nGl : CategoryTheory.Functor C D\nGr : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction Gl Gr\ninst‚úù¬≤ : Gr.Full\ninst‚úù¬π : Gr.Faithful\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingCospan Gl\n‚ä¢ CategoryTheory.Adhesive D","decl":"theorem adhesive_of_reflective [HasPullbacks D] [Adhesive C] [HasPullbacks C] [HasPushouts C]\n    [H‚ÇÇ : ‚àÄ {X Y S : D} (f : S ‚ü∂ X) (g : S ‚ü∂ Y) [Mono f], HasPushout f g]\n    {Gl : C ‚•§ D} {Gr : D ‚•§ C} (adj : Gl ‚ä£ Gr) [Gr.Full] [Gr.Faithful]\n    [PreservesLimitsOfShape WalkingCospan Gl] :\n    Adhesive D := by\n  have := adj.leftAdjoint_preservesColimits\n  have := adj.rightAdjoint_preservesLimits\n  apply Adhesive.mk (hasPushout_of_mono_left := H‚ÇÇ)\n  intro W X Y Z f g h i _ H\n  have := Adhesive.van_kampen (IsPushout.of_hasPushout (Gr.map f) (Gr.map g))\n  rw [IsPushout.isVanKampen_iff] at this ‚ä¢\n  refine (IsVanKampenColimit.precompose_isIso_iff\n    (isoWhiskerLeft _ (asIso adj.counit) ‚â™‚â´ Functor.rightUnitor _).hom).mp ?_\n  refine ((this.precompose_isIso (spanCompIso _ _ _).hom).map_reflective adj).of_iso\n    (IsColimit.uniqueUpToIso ?_ ?_)\n  ¬∑ exact isColimitOfPreserves Gl ((IsColimit.precomposeHomEquiv _ _).symm <| pushoutIsPushout _ _)\n  ¬∑ exact (IsColimit.precomposeHomEquiv _ _).symm H.isColimit\n\n"}
