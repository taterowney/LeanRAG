{"name":"Array.extract_eq_nil_of_start_eq_end","module":"Mathlib.Data.Array.ExtractLemmas","initialProofState":"α : Type u\ni : Nat\na : Array α\n⊢ Eq (a.extract i i) List.nil.toArray","decl":"@[simp]\ntheorem extract_eq_nil_of_start_eq_end {a : Array α} :\n    a.extract i i = #[] := by\n  refine extract_empty_of_stop_le_start a ?h\n  exact Nat.le_refl i\n\n"}
{"name":"Array.extract_append_left","module":"Mathlib.Data.Array.ExtractLemmas","initialProofState":"α : Type u\na b : Array α\ni j : Nat\nh : LE.le j a.size\n⊢ Eq ((HAppend.hAppend a b).extract i j) (a.extract i j)","decl":"theorem extract_append_left {a b : Array α} {i j : Nat} (h : j ≤ a.size) :\n    (a ++ b).extract i j = a.extract i j := by\n  apply ext\n  · simp only [size_extract, size_append]\n    omega\n  · intro h1 h2 h3\n    rw [getElem_extract, getElem_append_left, getElem_extract]\n\n"}
{"name":"Array.extract_append_right","module":"Mathlib.Data.Array.ExtractLemmas","initialProofState":"α : Type u\na b : Array α\ni j : Nat\nh : LE.le a.size i\n⊢ Eq ((HAppend.hAppend a b).extract i j) (b.extract (HSub.hSub i a.size) (HSub.hSub j a.size))","decl":"theorem extract_append_right {a b : Array α} {i j : Nat} (h : a.size ≤ i) :\n    (a ++ b).extract i j = b.extract (i - a.size) (j - a.size) := by\n  apply ext\n  · rw [size_extract, size_extract, size_append]\n    omega\n  · intro k hi h2\n    rw [getElem_extract, getElem_extract,\n      getElem_append_right (show size a ≤ i + k by omega)]\n    congr\n    omega\n\n"}
{"name":"Array.extract_eq_of_size_le_end","module":"Mathlib.Data.Array.ExtractLemmas","initialProofState":"α : Type u\nl p : Nat\na : Array α\nh : LE.le a.size l\n⊢ Eq (a.extract p l) (a.extract p a.size)","decl":"theorem extract_eq_of_size_le_end {l p : Nat} {a : Array α} (h : a.size ≤ l) :\n    a.extract p l = a.extract p a.size := by\n  simp only [extract, Nat.min_eq_right h, Nat.sub_eq, mkEmpty_eq, Nat.min_self]\n\n"}
{"name":"Array.extract_extract","module":"Mathlib.Data.Array.ExtractLemmas","initialProofState":"α : Type u\ns1 e2 e1 s2 : Nat\na : Array α\nh : LE.le (HAdd.hAdd s1 e2) e1\n⊢ Eq ((a.extract s1 e1).extract s2 e2) (a.extract (HAdd.hAdd s1 s2) (HAdd.hAdd s1 e2))","decl":"theorem extract_extract {s1 e2 e1 s2 : Nat} {a : Array α} (h : s1 + e2 ≤ e1) :\n    (a.extract s1 e1).extract s2 e2 = a.extract (s1 + s2) (s1 + e2) := by\n  apply ext\n  · simp only [size_extract]\n    omega\n  · intro i h1 h2\n    simp only [getElem_extract, Nat.add_assoc]\n\n"}
