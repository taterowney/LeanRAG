{"name":"List.keys_nil","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\n⊢ Eq List.nil.keys List.nil","decl":"@[simp]\ntheorem keys_nil : @keys α β [] = [] :=\n  rfl\n\n"}
{"name":"List.keys_cons","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ns : Sigma β\nl : List (Sigma β)\n⊢ Eq (List.cons s l).keys (List.cons s.fst l.keys)","decl":"@[simp]\ntheorem keys_cons {s} {l : List (Sigma β)} : (s :: l).keys = s.1 :: l.keys :=\n  rfl\n\n"}
{"name":"List.mem_keys_of_mem","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ns : Sigma β\nl : List (Sigma β)\na✝ : Membership.mem l s\n⊢ Membership.mem l.keys s.fst","decl":"theorem mem_keys_of_mem {s : Sigma β} {l : List (Sigma β)} : s ∈ l → s.1 ∈ l.keys :=\n  mem_map_of_mem Sigma.fst\n\n"}
{"name":"List.exists_of_mem_keys","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\na : α\nl : List (Sigma β)\nh : Membership.mem l.keys a\n⊢ Exists fun b => Membership.mem l ⟨a, b⟩","decl":"theorem exists_of_mem_keys {a} {l : List (Sigma β)} (h : a ∈ l.keys) :\n    ∃ b : β a, Sigma.mk a b ∈ l :=\n  let ⟨⟨_, b'⟩, m, e⟩ := exists_of_mem_map h\n  Eq.recOn e (Exists.intro b' m)\n\n"}
{"name":"List.mem_keys","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\na : α\nl : List (Sigma β)\n⊢ Iff (Membership.mem l.keys a) (Exists fun b => Membership.mem l ⟨a, b⟩)","decl":"theorem mem_keys {a} {l : List (Sigma β)} : a ∈ l.keys ↔ ∃ b : β a, Sigma.mk a b ∈ l :=\n  ⟨exists_of_mem_keys, fun ⟨_, h⟩ => mem_keys_of_mem h⟩\n\n"}
{"name":"List.not_mem_keys","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\na : α\nl : List (Sigma β)\n⊢ Iff (Not (Membership.mem l.keys a)) (∀ (b : β a), Not (Membership.mem l ⟨a, b⟩))","decl":"theorem not_mem_keys {a} {l : List (Sigma β)} : a ∉ l.keys ↔ ∀ b : β a, Sigma.mk a b ∉ l :=\n  (not_congr mem_keys).trans not_exists\n\n"}
{"name":"List.not_eq_key","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\na : α\nl : List (Sigma β)\n⊢ Iff (Not (Membership.mem l.keys a)) (∀ (s : Sigma β), Membership.mem l s → Ne a s.fst)","decl":"theorem not_eq_key {a} {l : List (Sigma β)} : a ∉ l.keys ↔ ∀ s : Sigma β, s ∈ l → a ≠ s.1 :=\n  Iff.intro (fun h₁ s h₂ e => absurd (mem_keys_of_mem h₂) (by rwa [e] at h₁)) fun f h₁ =>\n    let ⟨_, h₂⟩ := exists_of_mem_keys h₁\n    f _ h₂ rfl\n\n"}
{"name":"List.nodupKeys_iff_pairwise","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\nl : List (Sigma β)\n⊢ Iff l.NodupKeys (List.Pairwise (fun s s' => Ne s.fst s'.fst) l)","decl":"theorem nodupKeys_iff_pairwise {l} : NodupKeys l ↔ Pairwise (fun s s' : Sigma β => s.1 ≠ s'.1) l :=\n  pairwise_map\n\n"}
{"name":"List.NodupKeys.pairwise_ne","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\nl : List (Sigma β)\nh : l.NodupKeys\n⊢ List.Pairwise (fun s s' => Ne s.fst s'.fst) l","decl":"theorem NodupKeys.pairwise_ne {l} (h : NodupKeys l) :\n    Pairwise (fun s s' : Sigma β => s.1 ≠ s'.1) l :=\n  nodupKeys_iff_pairwise.1 h\n\n"}
{"name":"List.nodupKeys_nil","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\n⊢ List.nil.NodupKeys","decl":"@[simp]\ntheorem nodupKeys_nil : @NodupKeys α β [] :=\n  Pairwise.nil\n\n"}
{"name":"List.nodupKeys_cons","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ns : Sigma β\nl : List (Sigma β)\n⊢ Iff (List.cons s l).NodupKeys (And (Not (Membership.mem l.keys s.fst)) l.NodupKeys)","decl":"@[simp]\ntheorem nodupKeys_cons {s : Sigma β} {l : List (Sigma β)} :\n    NodupKeys (s :: l) ↔ s.1 ∉ l.keys ∧ NodupKeys l := by simp [keys, NodupKeys]\n\n"}
{"name":"List.not_mem_keys_of_nodupKeys_cons","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ns : Sigma β\nl : List (Sigma β)\nh : (List.cons s l).NodupKeys\n⊢ Not (Membership.mem l.keys s.fst)","decl":"theorem not_mem_keys_of_nodupKeys_cons {s : Sigma β} {l : List (Sigma β)} (h : NodupKeys (s :: l)) :\n    s.1 ∉ l.keys :=\n  (nodupKeys_cons.1 h).1\n\n"}
{"name":"List.nodupKeys_of_nodupKeys_cons","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ns : Sigma β\nl : List (Sigma β)\nh : (List.cons s l).NodupKeys\n⊢ l.NodupKeys","decl":"theorem nodupKeys_of_nodupKeys_cons {s : Sigma β} {l : List (Sigma β)} (h : NodupKeys (s :: l)) :\n    NodupKeys l :=\n  (nodupKeys_cons.1 h).2\n\n"}
{"name":"List.NodupKeys.eq_of_fst_eq","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\nl : List (Sigma β)\nnd : l.NodupKeys\ns s' : Sigma β\nh : Membership.mem l s\nh' : Membership.mem l s'\na✝ : Eq s.fst s'.fst\n⊢ Eq s s'","decl":"theorem NodupKeys.eq_of_fst_eq {l : List (Sigma β)} (nd : NodupKeys l) {s s' : Sigma β} (h : s ∈ l)\n    (h' : s' ∈ l) : s.1 = s'.1 → s = s' :=\n  @Pairwise.forall_of_forall _ (fun s s' : Sigma β => s.1 = s'.1 → s = s') _\n    (fun _ _ H h => (H h.symm).symm) (fun _ _ _ => rfl)\n    ((nodupKeys_iff_pairwise.1 nd).imp fun h h' => (h h').elim) _ h _ h'\n\n"}
{"name":"List.NodupKeys.eq_of_mk_mem","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\na : α\nb b' : β a\nl : List (Sigma β)\nnd : l.NodupKeys\nh : Membership.mem l ⟨a, b⟩\nh' : Membership.mem l ⟨a, b'⟩\n⊢ Eq b b'","decl":"theorem NodupKeys.eq_of_mk_mem {a : α} {b b' : β a} {l : List (Sigma β)} (nd : NodupKeys l)\n    (h : Sigma.mk a b ∈ l) (h' : Sigma.mk a b' ∈ l) : b = b' := by\n  cases nd.eq_of_fst_eq h h' rfl; rfl\n\n"}
{"name":"List.nodupKeys_singleton","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ns : Sigma β\n⊢ (List.cons s List.nil).NodupKeys","decl":"theorem nodupKeys_singleton (s : Sigma β) : NodupKeys [s] :=\n  nodup_singleton _\n\n"}
{"name":"List.NodupKeys.sublist","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\nl₁ l₂ : List (Sigma β)\nh : l₁.Sublist l₂\na✝ : l₂.NodupKeys\n⊢ l₁.NodupKeys","decl":"theorem NodupKeys.sublist {l₁ l₂ : List (Sigma β)} (h : l₁ <+ l₂) : NodupKeys l₂ → NodupKeys l₁ :=\n  Nodup.sublist <| h.map _\n\n"}
{"name":"List.NodupKeys.nodup","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\nl : List (Sigma β)\na✝ : l.NodupKeys\n⊢ l.Nodup","decl":"protected theorem NodupKeys.nodup {l : List (Sigma β)} : NodupKeys l → Nodup l :=\n  Nodup.of_map _\n\n"}
{"name":"List.perm_nodupKeys","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\nl₁ l₂ : List (Sigma β)\nh : l₁.Perm l₂\n⊢ Iff l₁.NodupKeys l₂.NodupKeys","decl":"theorem perm_nodupKeys {l₁ l₂ : List (Sigma β)} (h : l₁ ~ l₂) : NodupKeys l₁ ↔ NodupKeys l₂ :=\n  (h.map _).nodup_iff\n\n"}
{"name":"List.nodupKeys_flatten","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\nL : List (List (Sigma β))\n⊢ Iff L.flatten.NodupKeys (And (∀ (l : List (Sigma β)), Membership.mem L l → l.NodupKeys) (List.Pairwise List.Disjoint (List.map List.keys L)))","decl":"theorem nodupKeys_flatten {L : List (List (Sigma β))} :\n    NodupKeys (flatten L) ↔ (∀ l ∈ L, NodupKeys l) ∧ Pairwise Disjoint (L.map keys) := by\n  rw [nodupKeys_iff_pairwise, pairwise_flatten, pairwise_map]\n  refine and_congr (forall₂_congr fun l _ => by simp [nodupKeys_iff_pairwise]) ?_\n  apply iff_of_eq; congr with (l₁ l₂)\n  simp [keys, disjoint_iff_ne, Sigma.forall]\n\n"}
{"name":"List.nodupKeys_join","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\nL : List (List (Sigma β))\n⊢ Iff L.flatten.NodupKeys (And (∀ (l : List (Sigma β)), Membership.mem L l → l.NodupKeys) (List.Pairwise List.Disjoint (List.map List.keys L)))","decl":"@[deprecated (since := \"2024-10-15\")] alias nodupKeys_join := nodupKeys_flatten\n\n"}
{"name":"List.nodup_enum_map_fst","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nl : List α\n⊢ (List.map Prod.fst l.enum).Nodup","decl":"theorem nodup_enum_map_fst (l : List α) : (l.enum.map Prod.fst).Nodup := by simp [List.nodup_range]\n\n"}
{"name":"List.mem_ext","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\nl₀ l₁ : List (Sigma β)\nnd₀ : l₀.Nodup\nnd₁ : l₁.Nodup\nh : ∀ (x : Sigma β), Iff (Membership.mem l₀ x) (Membership.mem l₁ x)\n⊢ l₀.Perm l₁","decl":"theorem mem_ext {l₀ l₁ : List (Sigma β)} (nd₀ : l₀.Nodup) (nd₁ : l₁.Nodup)\n    (h : ∀ x, x ∈ l₀ ↔ x ∈ l₁) : l₀ ~ l₁ :=\n  (perm_ext_iff_of_nodup nd₀ nd₁).2 h\n\n"}
{"name":"List.dlookup_nil","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\n⊢ Eq (List.dlookup a List.nil) Option.none","decl":"@[simp]\ntheorem dlookup_nil (a : α) : dlookup a [] = @none (β a) :=\n  rfl\n\n"}
{"name":"List.dlookup_cons_eq","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\nl : List (Sigma β)\na : α\nb : β a\n⊢ Eq (List.dlookup a (List.cons ⟨a, b⟩ l)) (Option.some b)","decl":"@[simp]\ntheorem dlookup_cons_eq (l) (a : α) (b : β a) : dlookup a (⟨a, b⟩ :: l) = some b :=\n  dif_pos rfl\n\n"}
{"name":"List.dlookup_cons_ne","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\nl : List (Sigma β)\na : α\ns : Sigma β\na✝ : Ne a s.fst\n⊢ Eq (List.dlookup a (List.cons s l)) (List.dlookup a l)","decl":"@[simp]\ntheorem dlookup_cons_ne (l) {a} : ∀ s : Sigma β, a ≠ s.1 → dlookup a (s :: l) = dlookup a l\n  | ⟨_, _⟩, h => dif_neg h.symm\n\n"}
{"name":"List.dlookup_isSome","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nl : List (Sigma β)\n⊢ Iff (Eq (List.dlookup a l).isSome Bool.true) (Membership.mem l.keys a)","decl":"theorem dlookup_isSome {a : α} : ∀ {l : List (Sigma β)}, (dlookup a l).isSome ↔ a ∈ l.keys\n  | [] => by simp\n  | ⟨a', b⟩ :: l => by\n    by_cases h : a = a'\n    · subst a'\n      simp\n    · simp [h, dlookup_isSome]\n\n"}
{"name":"List.dlookup_eq_none","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nl : List (Sigma β)\n⊢ Iff (Eq (List.dlookup a l) Option.none) (Not (Membership.mem l.keys a))","decl":"theorem dlookup_eq_none {a : α} {l : List (Sigma β)} : dlookup a l = none ↔ a ∉ l.keys := by\n  simp [← dlookup_isSome, Option.isNone_iff_eq_none]\n\n"}
{"name":"List.of_mem_dlookup","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\nl : List (Sigma β)\na✝ : Membership.mem (List.dlookup a l) b\n⊢ Membership.mem l ⟨a, b⟩","decl":"theorem of_mem_dlookup {a : α} {b : β a} :\n    ∀ {l : List (Sigma β)}, b ∈ dlookup a l → Sigma.mk a b ∈ l\n  | ⟨a', b'⟩ :: l, H => by\n    by_cases h : a = a'\n    · subst a'\n      simp? at H says simp only [dlookup_cons_eq, Option.mem_def, Option.some.injEq] at H\n      simp [H]\n    · simp only [ne_eq, h, not_false_iff, dlookup_cons_ne] at H\n      simp [of_mem_dlookup H]\n\n"}
{"name":"List.mem_dlookup","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\nl : List (Sigma β)\nnd : l.NodupKeys\nh : Membership.mem l ⟨a, b⟩\n⊢ Membership.mem (List.dlookup a l) b","decl":"theorem mem_dlookup {a} {b : β a} {l : List (Sigma β)} (nd : l.NodupKeys) (h : Sigma.mk a b ∈ l) :\n    b ∈ dlookup a l := by\n  cases' Option.isSome_iff_exists.mp (dlookup_isSome.mpr (mem_keys_of_mem h)) with b' h'\n  cases nd.eq_of_mk_mem h (of_mem_dlookup h')\n  exact h'\n\n"}
{"name":"List.map_dlookup_eq_find","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nl : List (Sigma β)\n⊢ Eq (Option.map (Sigma.mk a) (List.dlookup a l)) (List.find? (fun s => Decidable.decide (Eq a s.fst)) l)","decl":"theorem map_dlookup_eq_find (a : α) :\n    ∀ l : List (Sigma β), (dlookup a l).map (Sigma.mk a) = find? (fun s => a = s.1) l\n  | [] => rfl\n  | ⟨a', b'⟩ :: l => by\n    by_cases h : a = a'\n    · subst a'\n      simp\n    · simpa [h] using map_dlookup_eq_find a l\n\n"}
{"name":"List.mem_dlookup_iff","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\nl : List (Sigma β)\nnd : l.NodupKeys\n⊢ Iff (Membership.mem (List.dlookup a l) b) (Membership.mem l ⟨a, b⟩)","decl":"theorem mem_dlookup_iff {a : α} {b : β a} {l : List (Sigma β)} (nd : l.NodupKeys) :\n    b ∈ dlookup a l ↔ Sigma.mk a b ∈ l :=\n  ⟨of_mem_dlookup, mem_dlookup nd⟩\n\n"}
{"name":"List.perm_dlookup","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nl₁ l₂ : List (Sigma β)\nnd₁ : l₁.NodupKeys\nnd₂ : l₂.NodupKeys\np : l₁.Perm l₂\n⊢ Eq (List.dlookup a l₁) (List.dlookup a l₂)","decl":"theorem perm_dlookup (a : α) {l₁ l₂ : List (Sigma β)} (nd₁ : l₁.NodupKeys) (nd₂ : l₂.NodupKeys)\n    (p : l₁ ~ l₂) : dlookup a l₁ = dlookup a l₂ := by\n  ext b; simp only [mem_dlookup_iff nd₁, mem_dlookup_iff nd₂]; exact p.mem_iff\n\n"}
{"name":"List.lookup_ext","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\nl₀ l₁ : List (Sigma β)\nnd₀ : l₀.NodupKeys\nnd₁ : l₁.NodupKeys\nh : ∀ (x : α) (y : β x), Iff (Membership.mem (List.dlookup x l₀) y) (Membership.mem (List.dlookup x l₁) y)\n⊢ l₀.Perm l₁","decl":"theorem lookup_ext {l₀ l₁ : List (Sigma β)} (nd₀ : l₀.NodupKeys) (nd₁ : l₁.NodupKeys)\n    (h : ∀ x y, y ∈ l₀.dlookup x ↔ y ∈ l₁.dlookup x) : l₀ ~ l₁ :=\n  mem_ext nd₀.nodup nd₁.nodup fun ⟨a, b⟩ => by\n    rw [← mem_dlookup_iff, ← mem_dlookup_iff, h] <;> assumption\n\n"}
{"name":"List.dlookup_map","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nα' : Type u'\nβ : α → Type v\nβ' : α' → Type v'\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq α'\nl : List (Sigma β)\nf : α → α'\nhf : Function.Injective f\ng : (a : α) → β a → β' (f a)\na : α\n⊢ Eq (List.dlookup (f a) (List.map (fun x => ⟨f x.fst, g x.fst x.snd⟩) l)) (Option.map (g a) (List.dlookup a l))","decl":"theorem dlookup_map (l : List (Sigma β))\n    {f : α → α'} (hf : Function.Injective f) (g : ∀ a, β a → β' (f a)) (a : α) :\n    (l.map fun x => ⟨f x.1, g _ x.2⟩).dlookup (f a) = (l.dlookup a).map (g a) := by\n  induction' l with b l IH\n  · rw [map_nil, dlookup_nil, dlookup_nil, Option.map_none']\n  · rw [map_cons]\n    obtain rfl | h := eq_or_ne a b.1\n    · rw [dlookup_cons_eq, dlookup_cons_eq, Option.map_some']\n    · rw [dlookup_cons_ne _ _ h, dlookup_cons_ne _ _ (fun he => h <| hf he), IH]\n\n"}
{"name":"List.dlookup_map₁","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nα' : Type u'\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq α'\nβ : Type v\nl : List (Sigma fun x => β)\nf : α → α'\nhf : Function.Injective f\na : α\n⊢ Eq (List.dlookup (f a) (List.map (fun x => ⟨f x.fst, x.snd⟩) l)) (List.dlookup a l)","decl":"theorem dlookup_map₁ {β : Type v} (l : List (Σ _ : α, β))\n    {f : α → α'} (hf : Function.Injective f) (a : α) :\n    (l.map fun x => ⟨f x.1, x.2⟩ : List (Σ _ : α', β)).dlookup (f a) = l.dlookup a := by\n  rw [dlookup_map (β' := fun _ => β) l hf (fun _ x => x) a, Option.map_id']\n\n"}
{"name":"List.dlookup_map₂","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\ninst✝ : DecidableEq α\nγ : α → Type u_1\nδ : α → Type u_2\nl : List (Sigma fun a => γ a)\nf : (a : α) → γ a → δ a\na : α\n⊢ Eq (List.dlookup a (List.map (fun x => ⟨x.fst, f x.fst x.snd⟩) l)) (Option.map (f a) (List.dlookup a l))","decl":"theorem dlookup_map₂ {γ δ : α → Type*} {l : List (Σ a, γ a)} {f : ∀ a, γ a → δ a} (a : α) :\n    (l.map fun x => ⟨x.1, f _ x.2⟩ : List (Σ a, δ a)).dlookup a = (l.dlookup a).map (f a) :=\n  dlookup_map l Function.injective_id _ _\n\n"}
{"name":"List.lookupAll_nil","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\n⊢ Eq (List.lookupAll a List.nil) List.nil","decl":"@[simp]\ntheorem lookupAll_nil (a : α) : lookupAll a [] = @nil (β a) :=\n  rfl\n\n"}
{"name":"List.lookupAll_cons_eq","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\nl : List (Sigma β)\na : α\nb : β a\n⊢ Eq (List.lookupAll a (List.cons ⟨a, b⟩ l)) (List.cons b (List.lookupAll a l))","decl":"@[simp]\ntheorem lookupAll_cons_eq (l) (a : α) (b : β a) : lookupAll a (⟨a, b⟩ :: l) = b :: lookupAll a l :=\n  dif_pos rfl\n\n"}
{"name":"List.lookupAll_cons_ne","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\nl : List (Sigma β)\na : α\ns : Sigma β\na✝ : Ne a s.fst\n⊢ Eq (List.lookupAll a (List.cons s l)) (List.lookupAll a l)","decl":"@[simp]\ntheorem lookupAll_cons_ne (l) {a} : ∀ s : Sigma β, a ≠ s.1 → lookupAll a (s :: l) = lookupAll a l\n  | ⟨_, _⟩, h => dif_neg h.symm\n\n"}
{"name":"List.lookupAll_eq_nil","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nl : List (Sigma β)\n⊢ Iff (Eq (List.lookupAll a l) List.nil) (∀ (b : β a), Not (Membership.mem l ⟨a, b⟩))","decl":"theorem lookupAll_eq_nil {a : α} :\n    ∀ {l : List (Sigma β)}, lookupAll a l = [] ↔ ∀ b : β a, Sigma.mk a b ∉ l\n  | [] => by simp\n  | ⟨a', b⟩ :: l => by\n    by_cases h : a = a'\n    · subst a'\n      simp only [lookupAll_cons_eq, mem_cons, Sigma.mk.inj_iff, heq_eq_eq, true_and, not_or,\n        false_iff, not_forall, not_and, not_not, reduceCtorEq]\n      use b\n      simp\n    · simp [h, lookupAll_eq_nil]\n\n"}
{"name":"List.head?_lookupAll","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nl : List (Sigma β)\n⊢ Eq (List.lookupAll a l).head? (List.dlookup a l)","decl":"theorem head?_lookupAll (a : α) : ∀ l : List (Sigma β), head? (lookupAll a l) = dlookup a l\n  | [] => by simp\n  | ⟨a', b⟩ :: l => by\n    by_cases h : a = a'\n    · subst h; simp\n    · rw [lookupAll_cons_ne, dlookup_cons_ne, head?_lookupAll a l] <;> assumption\n\n"}
{"name":"List.mem_lookupAll","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\nl : List (Sigma β)\n⊢ Iff (Membership.mem (List.lookupAll a l) b) (Membership.mem l ⟨a, b⟩)","decl":"theorem mem_lookupAll {a : α} {b : β a} :\n    ∀ {l : List (Sigma β)}, b ∈ lookupAll a l ↔ Sigma.mk a b ∈ l\n  | [] => by simp\n  | ⟨a', b'⟩ :: l => by\n    by_cases h : a = a'\n    · subst h\n      simp [*, mem_lookupAll]\n    · simp [*, mem_lookupAll]\n\n"}
{"name":"List.lookupAll_sublist","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nl : List (Sigma β)\n⊢ (List.map (Sigma.mk a) (List.lookupAll a l)).Sublist l","decl":"theorem lookupAll_sublist (a : α) : ∀ l : List (Sigma β), (lookupAll a l).map (Sigma.mk a) <+ l\n  | [] => by simp\n  | ⟨a', b'⟩ :: l => by\n    by_cases h : a = a'\n    · subst h\n      simp only [ne_eq, not_true, lookupAll_cons_eq, List.map]\n      exact (lookupAll_sublist a l).cons₂ _\n    · simp only [ne_eq, h, not_false_iff, lookupAll_cons_ne]\n      exact (lookupAll_sublist a l).cons _\n\n"}
{"name":"List.lookupAll_length_le_one","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nl : List (Sigma β)\nh : l.NodupKeys\n⊢ LE.le (List.lookupAll a l).length 1","decl":"theorem lookupAll_length_le_one (a : α) {l : List (Sigma β)} (h : l.NodupKeys) :\n    length (lookupAll a l) ≤ 1 := by\n  have := Nodup.sublist ((lookupAll_sublist a l).map _) h\n  rw [map_map] at this\n  rwa [← nodup_replicate, ← map_const]\n\n"}
{"name":"List.lookupAll_eq_dlookup","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nl : List (Sigma β)\nh : l.NodupKeys\n⊢ Eq (List.lookupAll a l) (List.dlookup a l).toList","decl":"theorem lookupAll_eq_dlookup (a : α) {l : List (Sigma β)} (h : l.NodupKeys) :\n    lookupAll a l = (dlookup a l).toList := by\n  rw [← head?_lookupAll]\n  have h1 := lookupAll_length_le_one a h; revert h1\n  rcases lookupAll a l with (_ | ⟨b, _ | ⟨c, l⟩⟩) <;> intro h1 <;> try rfl\n  exact absurd h1 (by simp)\n\n"}
{"name":"List.lookupAll_nodup","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nl : List (Sigma β)\nh : l.NodupKeys\n⊢ (List.lookupAll a l).Nodup","decl":"theorem lookupAll_nodup (a : α) {l : List (Sigma β)} (h : l.NodupKeys) : (lookupAll a l).Nodup := by\n  (rw [lookupAll_eq_dlookup a h]; apply Option.toList_nodup)\n\n"}
{"name":"List.perm_lookupAll","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nl₁ l₂ : List (Sigma β)\nnd₁ : l₁.NodupKeys\nnd₂ : l₂.NodupKeys\np : l₁.Perm l₂\n⊢ Eq (List.lookupAll a l₁) (List.lookupAll a l₂)","decl":"theorem perm_lookupAll (a : α) {l₁ l₂ : List (Sigma β)} (nd₁ : l₁.NodupKeys) (nd₂ : l₂.NodupKeys)\n    (p : l₁ ~ l₂) : lookupAll a l₁ = lookupAll a l₂ := by\n  simp [lookupAll_eq_dlookup, nd₁, nd₂, perm_dlookup a nd₁ nd₂ p]\n\n"}
{"name":"List.dlookup_append","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\nl₁ l₂ : List (Sigma β)\na : α\n⊢ Eq (List.dlookup a (HAppend.hAppend l₁ l₂)) ((List.dlookup a l₁).or (List.dlookup a l₂))","decl":"theorem dlookup_append (l₁ l₂ : List (Sigma β)) (a : α) :\n    (l₁ ++ l₂).dlookup a = (l₁.dlookup a).or (l₂.dlookup a) := by\n  induction l₁ with\n  | nil => rfl\n  | cons x l₁ IH =>\n    rw [cons_append]\n    obtain rfl | hb := Decidable.eq_or_ne a x.1\n    · rw [dlookup_cons_eq, dlookup_cons_eq, Option.or]\n    · rw [dlookup_cons_ne _ _ hb, dlookup_cons_ne _ _ hb, IH]\n\n"}
{"name":"List.kreplace_of_forall_not","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\nl : List (Sigma β)\nH : ∀ (b : β a), Not (Membership.mem l ⟨a, b⟩)\n⊢ Eq (List.kreplace a b l) l","decl":"theorem kreplace_of_forall_not (a : α) (b : β a) {l : List (Sigma β)}\n    (H : ∀ b : β a, Sigma.mk a b ∉ l) : kreplace a b l = l :=\n  lookmap_of_forall_not _ <| by\n    rintro ⟨a', b'⟩ h; dsimp; split_ifs\n    · subst a'\n      exact H _ h\n    · rfl\n\n"}
{"name":"List.kreplace_self","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\nl : List (Sigma β)\nnd : l.NodupKeys\nh : Membership.mem l ⟨a, b⟩\n⊢ Eq (List.kreplace a b l) l","decl":"theorem kreplace_self {a : α} {b : β a} {l : List (Sigma β)} (nd : NodupKeys l)\n    (h : Sigma.mk a b ∈ l) : kreplace a b l = l := by\n  refine (lookmap_congr ?_).trans (lookmap_id' (Option.guard fun (s : Sigma β) => a = s.1) ?_ _)\n  · rintro ⟨a', b'⟩ h'\n    dsimp [Option.guard]\n    split_ifs\n    · subst a'\n      simp [nd.eq_of_mk_mem h h']\n    · rfl\n  · rintro ⟨a₁, b₁⟩ ⟨a₂, b₂⟩\n    dsimp [Option.guard]\n    split_ifs\n    · simp\n    · rintro ⟨⟩\n\n"}
{"name":"List.keys_kreplace","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\nl : List (Sigma β)\n⊢ Eq (List.kreplace a b l).keys l.keys","decl":"theorem keys_kreplace (a : α) (b : β a) : ∀ l : List (Sigma β), (kreplace a b l).keys = l.keys :=\n  lookmap_map_eq _ _ <| by\n    rintro ⟨a₁, b₂⟩ ⟨a₂, b₂⟩\n    dsimp\n    split_ifs with h <;> simp +contextual [h]\n\n"}
{"name":"List.kreplace_nodupKeys","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\nl : List (Sigma β)\n⊢ Iff (List.kreplace a b l).NodupKeys l.NodupKeys","decl":"theorem kreplace_nodupKeys (a : α) (b : β a) {l : List (Sigma β)} :\n    (kreplace a b l).NodupKeys ↔ l.NodupKeys := by simp [NodupKeys, keys_kreplace]\n\n"}
{"name":"List.Perm.kreplace","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\nl₁ l₂ : List (Sigma β)\nnd : l₁.NodupKeys\na✝ : l₁.Perm l₂\n⊢ (List.kreplace a b l₁).Perm (List.kreplace a b l₂)","decl":"theorem Perm.kreplace {a : α} {b : β a} {l₁ l₂ : List (Sigma β)} (nd : l₁.NodupKeys) :\n    l₁ ~ l₂ → kreplace a b l₁ ~ kreplace a b l₂ :=\n  perm_lookmap _ <| by\n    refine nd.pairwise_ne.imp ?_\n    intro x y h z h₁ w h₂\n    split_ifs at h₁ h₂ with h_2 h_1 <;> cases h₁ <;> cases h₂\n    exact (h (h_2.symm.trans h_1)).elim\n\n"}
{"name":"List.kerase_nil","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\n⊢ Eq (List.kerase a List.nil) List.nil","decl":"@[simp]\ntheorem kerase_nil {a} : @kerase _ β _ a [] = [] :=\n  rfl\n\n"}
{"name":"List.kerase_cons_eq","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\ns : Sigma β\nl : List (Sigma β)\nh : Eq a s.fst\n⊢ Eq (List.kerase a (List.cons s l)) l","decl":"@[simp]\ntheorem kerase_cons_eq {a} {s : Sigma β} {l : List (Sigma β)} (h : a = s.1) :\n    kerase a (s :: l) = l := by simp [kerase, h]\n\n"}
{"name":"List.kerase_cons_ne","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\ns : Sigma β\nl : List (Sigma β)\nh : Ne a s.fst\n⊢ Eq (List.kerase a (List.cons s l)) (List.cons s (List.kerase a l))","decl":"@[simp]\ntheorem kerase_cons_ne {a} {s : Sigma β} {l : List (Sigma β)} (h : a ≠ s.1) :\n    kerase a (s :: l) = s :: kerase a l := by simp [kerase, h]\n\n"}
{"name":"List.kerase_of_not_mem_keys","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nl : List (Sigma β)\nh : Not (Membership.mem l.keys a)\n⊢ Eq (List.kerase a l) l","decl":"@[simp]\ntheorem kerase_of_not_mem_keys {a} {l : List (Sigma β)} (h : a ∉ l.keys) : kerase a l = l := by\n  induction l with\n  | nil => rfl\n  | cons _ _ ih => simp [not_or] at h; simp [h.1, ih h.2]\n\n"}
{"name":"List.kerase_sublist","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nl : List (Sigma β)\n⊢ (List.kerase a l).Sublist l","decl":"theorem kerase_sublist (a : α) (l : List (Sigma β)) : kerase a l <+ l :=\n  eraseP_sublist _\n\n"}
{"name":"List.kerase_keys_subset","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nl : List (Sigma β)\n⊢ HasSubset.Subset (List.kerase a l).keys l.keys","decl":"theorem kerase_keys_subset (a) (l : List (Sigma β)) : (kerase a l).keys ⊆ l.keys :=\n  ((kerase_sublist a l).map _).subset\n\n"}
{"name":"List.mem_keys_of_mem_keys_kerase","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na₁ a₂ : α\nl : List (Sigma β)\na✝ : Membership.mem (List.kerase a₂ l).keys a₁\n⊢ Membership.mem l.keys a₁","decl":"theorem mem_keys_of_mem_keys_kerase {a₁ a₂} {l : List (Sigma β)} :\n    a₁ ∈ (kerase a₂ l).keys → a₁ ∈ l.keys :=\n  @kerase_keys_subset _ _ _ _ _ _\n\n"}
{"name":"List.exists_of_kerase","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nl : List (Sigma β)\nh : Membership.mem l.keys a\n⊢ Exists fun b => Exists fun l₁ => Exists fun l₂ => And (Not (Membership.mem l₁.keys a)) (And (Eq l (HAppend.hAppend l₁ (List.cons ⟨a, b⟩ l₂))) (Eq (List.kerase a l) (HAppend.hAppend l₁ l₂)))","decl":"theorem exists_of_kerase {a : α} {l : List (Sigma β)} (h : a ∈ l.keys) :\n    ∃ (b : β a) (l₁ l₂ : List (Sigma β)),\n      a ∉ l₁.keys ∧ l = l₁ ++ ⟨a, b⟩ :: l₂ ∧ kerase a l = l₁ ++ l₂ := by\n  induction l with\n  | nil => cases h\n  | cons hd tl ih =>\n    by_cases e : a = hd.1\n    · subst e\n      exact ⟨hd.2, [], tl, by simp, by cases hd; rfl, by simp⟩\n    · simp only [keys_cons, mem_cons] at h\n      cases' h with h h\n      · exact absurd h e\n      rcases ih h with ⟨b, tl₁, tl₂, h₁, h₂, h₃⟩\n      exact ⟨b, hd :: tl₁, tl₂, not_mem_cons_of_ne_of_not_mem e h₁, by (rw [h₂]; rfl), by\n            simp [e, h₃]⟩\n\n"}
{"name":"List.mem_keys_kerase_of_ne","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na₁ a₂ : α\nl : List (Sigma β)\nh : Ne a₁ a₂\n⊢ Iff (Membership.mem (List.kerase a₂ l).keys a₁) (Membership.mem l.keys a₁)","decl":"@[simp]\ntheorem mem_keys_kerase_of_ne {a₁ a₂} {l : List (Sigma β)} (h : a₁ ≠ a₂) :\n    a₁ ∈ (kerase a₂ l).keys ↔ a₁ ∈ l.keys :=\n  (Iff.intro mem_keys_of_mem_keys_kerase) fun p =>\n    if q : a₂ ∈ l.keys then\n      match l, kerase a₂ l, exists_of_kerase q, p with\n      | _, _, ⟨_, _, _, _, rfl, rfl⟩, p => by simpa [keys, h] using p\n    else by simp [q, p]\n\n"}
{"name":"List.keys_kerase","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nl : List (Sigma β)\n⊢ Eq (List.kerase a l).keys (l.keys.erase a)","decl":"theorem keys_kerase {a} {l : List (Sigma β)} : (kerase a l).keys = l.keys.erase a := by\n  rw [keys, kerase, erase_eq_eraseP, eraseP_map, Function.comp_def]\n  congr\n\n"}
{"name":"List.kerase_kerase","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na a' : α\nl : List (Sigma β)\n⊢ Eq (List.kerase a (List.kerase a' l)) (List.kerase a' (List.kerase a l))","decl":"theorem kerase_kerase {a a'} {l : List (Sigma β)} :\n    (kerase a' l).kerase a = (kerase a l).kerase a' := by\n  by_cases h : a = a'\n  · subst a'; rfl\n  induction' l with x xs\n  · rfl\n  · by_cases a' = x.1\n    · subst a'\n      simp [kerase_cons_ne h, kerase_cons_eq rfl]\n    by_cases h' : a = x.1\n    · subst a\n      simp [kerase_cons_eq rfl, kerase_cons_ne (Ne.symm h)]\n    · simp [kerase_cons_ne, *]\n\n"}
{"name":"List.NodupKeys.kerase","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\nl : List (Sigma β)\ninst✝ : DecidableEq α\na : α\na✝ : l.NodupKeys\n⊢ (List.kerase a l).NodupKeys","decl":"theorem NodupKeys.kerase (a : α) : NodupKeys l → (kerase a l).NodupKeys :=\n  NodupKeys.sublist <| kerase_sublist _ _\n\n"}
{"name":"List.Perm.kerase","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nl₁ l₂ : List (Sigma β)\nnd : l₁.NodupKeys\na✝ : l₁.Perm l₂\n⊢ (List.kerase a l₁).Perm (List.kerase a l₂)","decl":"theorem Perm.kerase {a : α} {l₁ l₂ : List (Sigma β)} (nd : l₁.NodupKeys) :\n    l₁ ~ l₂ → kerase a l₁ ~ kerase a l₂ := by\n  apply Perm.eraseP\n  apply (nodupKeys_iff_pairwise.1 nd).imp\n  intros; simp_all\n\n"}
{"name":"List.not_mem_keys_kerase","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nl : List (Sigma β)\nnd : l.NodupKeys\n⊢ Not (Membership.mem (List.kerase a l).keys a)","decl":"@[simp]\ntheorem not_mem_keys_kerase (a) {l : List (Sigma β)} (nd : l.NodupKeys) :\n    a ∉ (kerase a l).keys := by\n  induction l with\n  | nil => simp\n  | cons hd tl ih =>\n    simp? at nd says simp only [nodupKeys_cons] at nd\n    by_cases h : a = hd.1\n    · subst h\n      simp [nd.1]\n    · simp [h, ih nd.2]\n\n"}
{"name":"List.dlookup_kerase","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nl : List (Sigma β)\nnd : l.NodupKeys\n⊢ Eq (List.dlookup a (List.kerase a l)) Option.none","decl":"@[simp]\ntheorem dlookup_kerase (a) {l : List (Sigma β)} (nd : l.NodupKeys) :\n    dlookup a (kerase a l) = none :=\n  dlookup_eq_none.mpr (not_mem_keys_kerase a nd)\n\n"}
{"name":"List.dlookup_kerase_ne","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na a' : α\nl : List (Sigma β)\nh : Ne a a'\n⊢ Eq (List.dlookup a (List.kerase a' l)) (List.dlookup a l)","decl":"@[simp]\ntheorem dlookup_kerase_ne {a a'} {l : List (Sigma β)} (h : a ≠ a') :\n    dlookup a (kerase a' l) = dlookup a l := by\n  induction l with\n  | nil => rfl\n  | cons hd tl ih =>\n    cases' hd with ah bh\n    by_cases h₁ : a = ah <;> by_cases h₂ : a' = ah\n    · substs h₁ h₂\n      cases Ne.irrefl h\n    · subst h₁\n      simp [h₂]\n    · subst h₂\n      simp [h]\n    · simp [h₁, h₂, ih]\n\n"}
{"name":"List.kerase_append_left","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nl₁ l₂ : List (Sigma β)\na✝ : Membership.mem l₁.keys a\n⊢ Eq (List.kerase a (HAppend.hAppend l₁ l₂)) (HAppend.hAppend (List.kerase a l₁) l₂)","decl":"theorem kerase_append_left {a} :\n    ∀ {l₁ l₂ : List (Sigma β)}, a ∈ l₁.keys → kerase a (l₁ ++ l₂) = kerase a l₁ ++ l₂\n  | [], _, h => by cases h\n  | s :: l₁, l₂, h₁ => by\n    if h₂ : a = s.1 then simp [h₂]\n    else simp at h₁; cases' h₁ with h₁ h₁ <;> [exact absurd h₁ h₂; simp [h₂, kerase_append_left h₁]]\n\n"}
{"name":"List.kerase_append_right","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nl₁ l₂ : List (Sigma β)\na✝ : Not (Membership.mem l₁.keys a)\n⊢ Eq (List.kerase a (HAppend.hAppend l₁ l₂)) (HAppend.hAppend l₁ (List.kerase a l₂))","decl":"theorem kerase_append_right {a} :\n    ∀ {l₁ l₂ : List (Sigma β)}, a ∉ l₁.keys → kerase a (l₁ ++ l₂) = l₁ ++ kerase a l₂\n  | [], _, _ => rfl\n  | _ :: l₁, l₂, h => by\n    simp only [keys_cons, mem_cons, not_or] at h\n    simp [h.1, kerase_append_right h.2]\n\n"}
{"name":"List.kerase_comm","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na₁ a₂ : α\nl : List (Sigma β)\n⊢ Eq (List.kerase a₂ (List.kerase a₁ l)) (List.kerase a₁ (List.kerase a₂ l))","decl":"theorem kerase_comm (a₁ a₂) (l : List (Sigma β)) :\n    kerase a₂ (kerase a₁ l) = kerase a₁ (kerase a₂ l) :=\n  if h : a₁ = a₂ then by simp [h]\n  else\n    if ha₁ : a₁ ∈ l.keys then\n      if ha₂ : a₂ ∈ l.keys then\n        match l, kerase a₁ l, exists_of_kerase ha₁, ha₂ with\n        | _, _, ⟨b₁, l₁, l₂, a₁_nin_l₁, rfl, rfl⟩, _ =>\n          if h' : a₂ ∈ l₁.keys then by\n            simp [kerase_append_left h',\n              kerase_append_right (mt (mem_keys_kerase_of_ne h).mp a₁_nin_l₁)]\n          else by\n            simp [kerase_append_right h', kerase_append_right a₁_nin_l₁,\n              @kerase_cons_ne _ _ _ a₂ ⟨a₁, b₁⟩ _ (Ne.symm h)]\n      else by simp [ha₂, mt mem_keys_of_mem_keys_kerase ha₂]\n    else by simp [ha₁, mt mem_keys_of_mem_keys_kerase ha₁]\n\n"}
{"name":"List.sizeOf_kerase","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝¹ : DecidableEq α\ninst✝ : SizeOf (Sigma β)\nx : α\nxs : List (Sigma β)\n⊢ LE.le (SizeOf.sizeOf (List.kerase x xs)) (SizeOf.sizeOf xs)","decl":"theorem sizeOf_kerase [SizeOf (Sigma β)] (x : α)\n    (xs : List (Sigma β)) : SizeOf.sizeOf (List.kerase x xs) ≤ SizeOf.sizeOf xs := by\n  simp only [SizeOf.sizeOf, _sizeOf_1]\n  induction' xs with y ys\n  · simp\n  · by_cases x = y.1 <;> simp [*]\n\n"}
{"name":"List.kinsert_def","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\nl : List (Sigma β)\n⊢ Eq (List.kinsert a b l) (List.cons ⟨a, b⟩ (List.kerase a l))","decl":"@[simp]\ntheorem kinsert_def {a} {b : β a} {l : List (Sigma β)} : kinsert a b l = ⟨a, b⟩ :: kerase a l :=\n  rfl\n\n"}
{"name":"List.mem_keys_kinsert","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na a' : α\nb' : β a'\nl : List (Sigma β)\n⊢ Iff (Membership.mem (List.kinsert a' b' l).keys a) (Or (Eq a a') (Membership.mem l.keys a))","decl":"theorem mem_keys_kinsert {a a'} {b' : β a'} {l : List (Sigma β)} :\n    a ∈ (kinsert a' b' l).keys ↔ a = a' ∨ a ∈ l.keys := by by_cases h : a = a' <;> simp [h]\n\n"}
{"name":"List.kinsert_nodupKeys","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\nl : List (Sigma β)\nnd : l.NodupKeys\n⊢ (List.kinsert a b l).NodupKeys","decl":"theorem kinsert_nodupKeys (a) (b : β a) {l : List (Sigma β)} (nd : l.NodupKeys) :\n    (kinsert a b l).NodupKeys :=\n  nodupKeys_cons.mpr ⟨not_mem_keys_kerase a nd, nd.kerase a⟩\n\n"}
{"name":"List.Perm.kinsert","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\nl₁ l₂ : List (Sigma β)\nnd₁ : l₁.NodupKeys\np : l₁.Perm l₂\n⊢ (List.kinsert a b l₁).Perm (List.kinsert a b l₂)","decl":"theorem Perm.kinsert {a} {b : β a} {l₁ l₂ : List (Sigma β)} (nd₁ : l₁.NodupKeys) (p : l₁ ~ l₂) :\n    kinsert a b l₁ ~ kinsert a b l₂ :=\n  (p.kerase nd₁).cons _\n\n"}
{"name":"List.dlookup_kinsert","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\nl : List (Sigma β)\n⊢ Eq (List.dlookup a (List.kinsert a b l)) (Option.some b)","decl":"theorem dlookup_kinsert {a} {b : β a} (l : List (Sigma β)) :\n    dlookup a (kinsert a b l) = some b := by\n  simp only [kinsert, dlookup_cons_eq]\n\n"}
{"name":"List.dlookup_kinsert_ne","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na a' : α\nb' : β a'\nl : List (Sigma β)\nh : Ne a a'\n⊢ Eq (List.dlookup a (List.kinsert a' b' l)) (List.dlookup a l)","decl":"theorem dlookup_kinsert_ne {a a'} {b' : β a'} {l : List (Sigma β)} (h : a ≠ a') :\n    dlookup a (kinsert a' b' l) = dlookup a l := by simp [h]\n\n"}
{"name":"List.kextract_eq_dlookup_kerase","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nl : List (Sigma β)\n⊢ Eq (List.kextract a l) { fst := List.dlookup a l, snd := List.kerase a l }","decl":"@[simp]\ntheorem kextract_eq_dlookup_kerase (a : α) :\n    ∀ l : List (Sigma β), kextract a l = (dlookup a l, kerase a l)\n  | [] => rfl\n  | ⟨a', b⟩ :: l => by\n    simp only [kextract]; dsimp; split_ifs with h\n    · subst a'\n      simp [kerase]\n    · simp [kextract, Ne.symm h, kextract_eq_dlookup_kerase a l, kerase]\n\n"}
{"name":"List.dedupKeys_cons","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\nx : Sigma β\nl : List (Sigma β)\n⊢ Eq (List.cons x l).dedupKeys (List.kinsert x.fst x.snd l.dedupKeys)","decl":"theorem dedupKeys_cons {x : Sigma β} (l : List (Sigma β)) :\n    dedupKeys (x :: l) = kinsert x.1 x.2 (dedupKeys l) :=\n  rfl\n\n\n"}
{"name":"List.nodupKeys_dedupKeys","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\nl : List (Sigma β)\n⊢ l.dedupKeys.NodupKeys","decl":"theorem nodupKeys_dedupKeys (l : List (Sigma β)) : NodupKeys (dedupKeys l) := by\n  dsimp [dedupKeys]\n  generalize hl : nil = l'\n  have : NodupKeys l' := by\n    rw [← hl]\n    apply nodup_nil\n  clear hl\n  induction' l with x xs l_ih\n  · apply this\n  · cases x\n    simp only [foldr_cons, kinsert_def, nodupKeys_cons, ne_eq, not_true]\n    constructor\n    · simp only [keys_kerase]\n      apply l_ih.not_mem_erase\n    · exact l_ih.kerase _\n\n"}
{"name":"List.dlookup_dedupKeys","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nl : List (Sigma β)\n⊢ Eq (List.dlookup a l.dedupKeys) (List.dlookup a l)","decl":"theorem dlookup_dedupKeys (a : α) (l : List (Sigma β)) : dlookup a (dedupKeys l) = dlookup a l := by\n  induction' l with l_hd _ l_ih\n  · rfl\n  cases' l_hd with a' b\n  by_cases h : a = a'\n  · subst a'\n    rw [dedupKeys_cons, dlookup_kinsert, dlookup_cons_eq]\n  · rw [dedupKeys_cons, dlookup_kinsert_ne h, l_ih, dlookup_cons_ne]\n    exact h\n\n"}
{"name":"List.sizeOf_dedupKeys","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝¹ : DecidableEq α\ninst✝ : SizeOf (Sigma β)\nxs : List (Sigma β)\n⊢ LE.le (SizeOf.sizeOf xs.dedupKeys) (SizeOf.sizeOf xs)","decl":"theorem sizeOf_dedupKeys [SizeOf (Sigma β)]\n    (xs : List (Sigma β)) : SizeOf.sizeOf (dedupKeys xs) ≤ SizeOf.sizeOf xs := by\n  simp only [SizeOf.sizeOf, _sizeOf_1]\n  induction' xs with x xs\n  · simp [dedupKeys]\n  · simp only [dedupKeys_cons, kinsert_def, Nat.add_le_add_iff_left, Sigma.eta]\n    trans\n    · apply sizeOf_kerase\n    · assumption\n\n"}
{"name":"List.nil_kunion","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\nl : List (Sigma β)\n⊢ Eq (List.nil.kunion l) l","decl":"@[simp]\ntheorem nil_kunion {l : List (Sigma β)} : kunion [] l = l :=\n  rfl\n\n"}
{"name":"List.kunion_nil","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\nl : List (Sigma β)\n⊢ Eq (l.kunion List.nil) l","decl":"@[simp]\ntheorem kunion_nil : ∀ {l : List (Sigma β)}, kunion l [] = l\n  | [] => rfl\n  | _ :: l => by rw [kunion, kerase_nil, kunion_nil]\n\n"}
{"name":"List.kunion_cons","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\ns : Sigma β\nl₁ l₂ : List (Sigma β)\n⊢ Eq ((List.cons s l₁).kunion l₂) (List.cons s (l₁.kunion (List.kerase s.fst l₂)))","decl":"@[simp]\ntheorem kunion_cons {s} {l₁ l₂ : List (Sigma β)} :\n    kunion (s :: l₁) l₂ = s :: kunion l₁ (kerase s.1 l₂) :=\n  rfl\n\n"}
{"name":"List.mem_keys_kunion","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nl₁ l₂ : List (Sigma β)\n⊢ Iff (Membership.mem (l₁.kunion l₂).keys a) (Or (Membership.mem l₁.keys a) (Membership.mem l₂.keys a))","decl":"@[simp]\ntheorem mem_keys_kunion {a} {l₁ l₂ : List (Sigma β)} :\n    a ∈ (kunion l₁ l₂).keys ↔ a ∈ l₁.keys ∨ a ∈ l₂.keys := by\n  induction l₁ generalizing l₂ with\n  | nil => simp\n  | cons s l₁ ih => by_cases h : a = s.1 <;> [simp [h]; simp [h, ih]]\n\n"}
{"name":"List.kunion_kerase","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nl₁ l₂ : List (Sigma β)\n⊢ Eq ((List.kerase a l₁).kunion (List.kerase a l₂)) (List.kerase a (l₁.kunion l₂))","decl":"@[simp]\ntheorem kunion_kerase {a} :\n    ∀ {l₁ l₂ : List (Sigma β)}, kunion (kerase a l₁) (kerase a l₂) = kerase a (kunion l₁ l₂)\n  | [], _ => rfl\n  | s :: _, l => by by_cases h : a = s.1 <;> simp [h, kerase_comm a s.1 l, kunion_kerase]\n\n"}
{"name":"List.NodupKeys.kunion","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\nl₁ l₂ : List (Sigma β)\ninst✝ : DecidableEq α\nnd₁ : l₁.NodupKeys\nnd₂ : l₂.NodupKeys\n⊢ (l₁.kunion l₂).NodupKeys","decl":"theorem NodupKeys.kunion (nd₁ : l₁.NodupKeys) (nd₂ : l₂.NodupKeys) : (kunion l₁ l₂).NodupKeys := by\n  induction l₁ generalizing l₂ with\n  | nil => simp only [nil_kunion, nd₂]\n  | cons s l₁ ih =>\n    simp? at nd₁ says simp only [nodupKeys_cons] at nd₁\n    simp [not_or, nd₁.1, nd₂, ih nd₁.2 (nd₂.kerase s.1)]\n\n"}
{"name":"List.Perm.kunion_right","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\nl₁ l₂ : List (Sigma β)\np : l₁.Perm l₂\nl : List (Sigma β)\n⊢ (l₁.kunion l).Perm (l₂.kunion l)","decl":"theorem Perm.kunion_right {l₁ l₂ : List (Sigma β)} (p : l₁ ~ l₂) (l) :\n    kunion l₁ l ~ kunion l₂ l := by\n  induction p generalizing l with\n  | nil => rfl\n  | cons hd _ ih =>\n    simp [ih (List.kerase _ _), Perm.cons]\n  | swap s₁ s₂ l => simp [kerase_comm, Perm.swap]\n  | trans _ _ ih₁₂ ih₂₃ => exact Perm.trans (ih₁₂ l) (ih₂₃ l)\n\n"}
{"name":"List.Perm.kunion_left","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\nl l₁ l₂ : List (Sigma β)\na✝¹ : l₁.NodupKeys\na✝ : l₁.Perm l₂\n⊢ (l.kunion l₁).Perm (l.kunion l₂)","decl":"theorem Perm.kunion_left :\n    ∀ (l) {l₁ l₂ : List (Sigma β)}, l₁.NodupKeys → l₁ ~ l₂ → kunion l l₁ ~ kunion l l₂\n  | [], _, _, _, p => p\n  | s :: l, _, _, nd₁, p => ((p.kerase nd₁).kunion_left l <| nd₁.kerase s.1).cons s\n\n"}
{"name":"List.Perm.kunion","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\nl₁ l₂ l₃ l₄ : List (Sigma β)\nnd₃ : l₃.NodupKeys\np₁₂ : l₁.Perm l₂\np₃₄ : l₃.Perm l₄\n⊢ (l₁.kunion l₃).Perm (l₂.kunion l₄)","decl":"theorem Perm.kunion {l₁ l₂ l₃ l₄ : List (Sigma β)} (nd₃ : l₃.NodupKeys) (p₁₂ : l₁ ~ l₂)\n    (p₃₄ : l₃ ~ l₄) : kunion l₁ l₃ ~ kunion l₂ l₄ :=\n  (p₁₂.kunion_right l₃).trans (p₃₄.kunion_left l₂ nd₃)\n\n"}
{"name":"List.dlookup_kunion_left","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nl₁ l₂ : List (Sigma β)\nh : Membership.mem l₁.keys a\n⊢ Eq (List.dlookup a (l₁.kunion l₂)) (List.dlookup a l₁)","decl":"@[simp]\ntheorem dlookup_kunion_left {a} {l₁ l₂ : List (Sigma β)} (h : a ∈ l₁.keys) :\n    dlookup a (kunion l₁ l₂) = dlookup a l₁ := by\n  induction' l₁ with s _ ih generalizing l₂ <;> simp at h; cases' h with h h <;> cases' s with a'\n  · subst h\n    simp\n  · rw [kunion_cons]\n    by_cases h' : a = a'\n    · subst h'\n      simp\n    · simp [h', ih h]\n\n"}
{"name":"List.dlookup_kunion_right","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nl₁ l₂ : List (Sigma β)\nh : Not (Membership.mem l₁.keys a)\n⊢ Eq (List.dlookup a (l₁.kunion l₂)) (List.dlookup a l₂)","decl":"@[simp]\ntheorem dlookup_kunion_right {a} {l₁ l₂ : List (Sigma β)} (h : a ∉ l₁.keys) :\n    dlookup a (kunion l₁ l₂) = dlookup a l₂ := by\n  induction l₁ generalizing l₂ with\n  | nil => simp\n  | cons _ _ ih => simp_all [not_or]\n\n"}
{"name":"List.mem_dlookup_kunion","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\nl₁ l₂ : List (Sigma β)\n⊢ Iff (Membership.mem (List.dlookup a (l₁.kunion l₂)) b) (Or (Membership.mem (List.dlookup a l₁) b) (And (Not (Membership.mem l₁.keys a)) (Membership.mem (List.dlookup a l₂) b)))","decl":"theorem mem_dlookup_kunion {a} {b : β a} {l₁ l₂ : List (Sigma β)} :\n    b ∈ dlookup a (kunion l₁ l₂) ↔ b ∈ dlookup a l₁ ∨ a ∉ l₁.keys ∧ b ∈ dlookup a l₂ := by\n  induction l₁ generalizing l₂ with\n  | nil => simp\n  | cons s _ ih =>\n    cases' s with a'\n    by_cases h₁ : a = a'\n    · subst h₁\n      simp\n    · let h₂ := @ih (kerase a' l₂)\n      simp? [h₁] at h₂ says\n        simp only [Option.mem_def, ne_eq, h₁, not_false_eq_true, dlookup_kerase_ne] at h₂\n      simp [h₁, h₂]\n\n"}
{"name":"List.dlookup_kunion_eq_some","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\nl₁ l₂ : List (Sigma β)\n⊢ Iff (Eq (List.dlookup a (l₁.kunion l₂)) (Option.some b)) (Or (Eq (List.dlookup a l₁) (Option.some b)) (And (Not (Membership.mem l₁.keys a)) (Eq (List.dlookup a l₂) (Option.some b))))","decl":"@[simp]\ntheorem dlookup_kunion_eq_some {a} {b : β a} {l₁ l₂ : List (Sigma β)} :\n    dlookup a (kunion l₁ l₂) = some b ↔\n      dlookup a l₁ = some b ∨ a ∉ l₁.keys ∧ dlookup a l₂ = some b :=\n  mem_dlookup_kunion\n\n"}
{"name":"List.mem_dlookup_kunion_middle","module":"Mathlib.Data.List.Sigma","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\nl₁ l₂ l₃ : List (Sigma β)\nh₁ : Membership.mem (List.dlookup a (l₁.kunion l₃)) b\nh₂ : Not (Membership.mem l₂.keys a)\n⊢ Membership.mem (List.dlookup a ((l₁.kunion l₂).kunion l₃)) b","decl":"theorem mem_dlookup_kunion_middle {a} {b : β a} {l₁ l₂ l₃ : List (Sigma β)}\n    (h₁ : b ∈ dlookup a (kunion l₁ l₃)) (h₂ : a ∉ keys l₂) :\n    b ∈ dlookup a (kunion (kunion l₁ l₂) l₃) :=\n  match mem_dlookup_kunion.mp h₁ with\n  | Or.inl h => mem_dlookup_kunion.mpr (Or.inl (mem_dlookup_kunion.mpr (Or.inl h)))\n  | Or.inr h => mem_dlookup_kunion.mpr <| Or.inr ⟨mt mem_keys_kunion.mp (not_or.mpr ⟨h.1, h₂⟩), h.2⟩\n\n"}
