{"name":"List.map₂Left'_nil_right","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : α → Option β → γ\nas : List α\n⊢ Eq (List.map₂Left' f as List.nil) { fst := List.map (fun a => f a Option.none) as, snd := List.nil }","decl":"@[simp]\ntheorem map₂Left'_nil_right (f : α → Option β → γ) (as) :\n    map₂Left' f as [] = (as.map fun a => f a none, []) := by cases as <;> rfl\n\n"}
{"name":"List.map₂Right'_nil_left","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : Option α → β → γ\nbs : List β\n⊢ Eq (List.map₂Right' f List.nil bs) { fst := List.map (f Option.none) bs, snd := List.nil }","decl":"@[simp]\ntheorem map₂Right'_nil_left : map₂Right' f [] bs = (bs.map (f none), []) := by cases bs <;> rfl\n\n"}
{"name":"List.map₂Right'_nil_right","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : Option α → β → γ\nas : List α\n⊢ Eq (List.map₂Right' f as List.nil) { fst := List.nil, snd := as }","decl":"@[simp]\ntheorem map₂Right'_nil_right : map₂Right' f as [] = ([], as) :=\n  rfl\n\n"}
{"name":"List.map₂Right'_nil_cons","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : Option α → β → γ\nb : β\nbs : List β\n⊢ Eq (List.map₂Right' f List.nil (List.cons b bs)) { fst := List.cons (f Option.none b) (List.map (f Option.none) bs), snd := List.nil }","decl":"@[simp]\ntheorem map₂Right'_nil_cons : map₂Right' f [] (b :: bs) = (f none b :: bs.map (f none), []) :=\n  rfl\n\n"}
{"name":"List.map₂Right'_cons_cons","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : Option α → β → γ\na : α\nas : List α\nb : β\nbs : List β\n⊢ Eq (List.map₂Right' f (List.cons a as) (List.cons b bs))\n    (let r := List.map₂Right' f as bs;\n    { fst := List.cons (f (Option.some a) b) r.fst, snd := r.snd })","decl":"@[simp]\ntheorem map₂Right'_cons_cons :\n    map₂Right' f (a :: as) (b :: bs) =\n      let r := map₂Right' f as bs\n      (f (some a) b :: r.fst, r.snd) :=\n  rfl\n\n"}
{"name":"List.nil_zipWith","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : α → β → γ\nl : List β\n⊢ Eq (List.zipWith f List.nil l) List.nil","decl":"theorem nil_zipWith (f : α → β → γ) (l : List β) : zipWith f [] l = [] := by cases l <;> rfl\n\n"}
{"name":"List.zipWith_nil","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : α → β → γ\nl : List α\n⊢ Eq (List.zipWith f l List.nil) List.nil","decl":"theorem zipWith_nil (f : α → β → γ) (l : List α) : zipWith f l [] = [] := by cases l <;> rfl\n\n"}
{"name":"List.zipWith_flip","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : α → β → γ\nas : List α\nbs : List β\n⊢ Eq (List.zipWith (flip f) bs as) (List.zipWith f as bs)","decl":"@[simp]\ntheorem zipWith_flip (f : α → β → γ) : ∀ as bs, zipWith (flip f) bs as = zipWith f as bs\n  | [], [] => rfl\n  | [], _ :: _ => rfl\n  | _ :: _, [] => rfl\n  | a :: as, b :: bs => by\n    simp! [zipWith_flip]\n    rfl\n\n\n"}
{"name":"List.zipLeft'_nil_right","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\nas : List α\n⊢ Eq (as.zipLeft' List.nil) { fst := List.map (fun a => { fst := a, snd := Option.none }) as, snd := List.nil }","decl":"@[simp]\ntheorem zipLeft'_nil_right : zipLeft' as ([] : List β) = (as.map fun a => (a, none), []) := by\n  cases as <;> rfl\n\n"}
{"name":"List.zipLeft'_nil_left","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\nbs : List β\n⊢ Eq (List.nil.zipLeft' bs) { fst := List.nil, snd := bs }","decl":"@[simp]\ntheorem zipLeft'_nil_left : zipLeft' ([] : List α) bs = ([], bs) :=\n  rfl\n\n"}
{"name":"List.zipLeft'_cons_nil","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\na : α\nas : List α\n⊢ Eq ((List.cons a as).zipLeft' List.nil) { fst := List.cons { fst := a, snd := Option.none } (List.map (fun a => { fst := a, snd := Option.none }) as), snd := List.nil }","decl":"@[simp]\ntheorem zipLeft'_cons_nil :\n    zipLeft' (a :: as) ([] : List β) = ((a, none) :: as.map fun a => (a, none), []) :=\n  rfl\n\n"}
{"name":"List.zipLeft'_cons_cons","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\na : α\nas : List α\nb : β\nbs : List β\n⊢ Eq ((List.cons a as).zipLeft' (List.cons b bs))\n    (let r := as.zipLeft' bs;\n    { fst := List.cons { fst := a, snd := Option.some b } r.fst, snd := r.snd })","decl":"@[simp]\ntheorem zipLeft'_cons_cons :\n    zipLeft' (a :: as) (b :: bs) =\n      let r := zipLeft' as bs\n      ((a, some b) :: r.fst, r.snd) :=\n  rfl\n\n"}
{"name":"List.zipRight'_nil_left","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\nbs : List β\n⊢ Eq (List.nil.zipRight' bs) { fst := List.map (fun b => { fst := Option.none, snd := b }) bs, snd := List.nil }","decl":"@[simp]\ntheorem zipRight'_nil_left : zipRight' ([] : List α) bs = (bs.map fun b => (none, b), []) := by\n  cases bs <;> rfl\n\n"}
{"name":"List.zipRight'_nil_right","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\nas : List α\n⊢ Eq (as.zipRight' List.nil) { fst := List.nil, snd := as }","decl":"@[simp]\ntheorem zipRight'_nil_right : zipRight' as ([] : List β) = ([], as) :=\n  rfl\n\n"}
{"name":"List.zipRight'_nil_cons","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\nb : β\nbs : List β\n⊢ Eq (List.nil.zipRight' (List.cons b bs)) { fst := List.cons { fst := Option.none, snd := b } (List.map (fun b => { fst := Option.none, snd := b }) bs), snd := List.nil }","decl":"@[simp]\ntheorem zipRight'_nil_cons :\n    zipRight' ([] : List α) (b :: bs) = ((none, b) :: bs.map fun b => (none, b), []) :=\n  rfl\n\n"}
{"name":"List.zipRight'_cons_cons","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\na : α\nas : List α\nb : β\nbs : List β\n⊢ Eq ((List.cons a as).zipRight' (List.cons b bs))\n    (let r := as.zipRight' bs;\n    { fst := List.cons { fst := Option.some a, snd := b } r.fst, snd := r.snd })","decl":"@[simp]\ntheorem zipRight'_cons_cons :\n    zipRight' (a :: as) (b :: bs) =\n      let r := zipRight' as bs\n      ((some a, b) :: r.fst, r.snd) :=\n  rfl\n\n"}
{"name":"List.map₂Left_nil_right","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : α → Option β → γ\nas : List α\n⊢ Eq (List.map₂Left f as List.nil) (List.map (fun a => f a Option.none) as)","decl":"@[simp]\ntheorem map₂Left_nil_right : map₂Left f as [] = as.map fun a => f a none := by cases as <;> rfl\n\n"}
{"name":"List.map₂Left_eq_map₂Left'","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : α → Option β → γ\nas : List α\nbs : List β\n⊢ Eq (List.map₂Left f as bs) (List.map₂Left' f as bs).fst","decl":"theorem map₂Left_eq_map₂Left' : ∀ as bs, map₂Left f as bs = (map₂Left' f as bs).fst\n  | [], _ => by simp\n  | a :: as, [] => by simp\n  | a :: as, b :: bs => by simp [map₂Left_eq_map₂Left']\n\n"}
{"name":"List.map₂Left_eq_zipWith","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : α → Option β → γ\nas : List α\nbs : List β\na✝ : LE.le as.length bs.length\n⊢ Eq (List.map₂Left f as bs) (List.zipWith (fun a b => f a (Option.some b)) as bs)","decl":"theorem map₂Left_eq_zipWith :\n    ∀ as bs, length as ≤ length bs → map₂Left f as bs = zipWith (fun a b => f a (some b)) as bs\n  | [], [], _ => by simp\n  | [], _ :: _, _ => by simp\n  | a :: as, [], h => by\n    simp at h\n  | a :: as, b :: bs, h => by\n    simp only [length_cons, succ_le_succ_iff] at h\n    simp [h, map₂Left_eq_zipWith]\n\n"}
{"name":"List.map₂Right_nil_left","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : Option α → β → γ\nbs : List β\n⊢ Eq (List.map₂Right f List.nil bs) (List.map (f Option.none) bs)","decl":"@[simp]\ntheorem map₂Right_nil_left : map₂Right f [] bs = bs.map (f none) := by cases bs <;> rfl\n\n"}
{"name":"List.map₂Right_nil_right","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : Option α → β → γ\nas : List α\n⊢ Eq (List.map₂Right f as List.nil) List.nil","decl":"@[simp]\ntheorem map₂Right_nil_right : map₂Right f as [] = [] :=\n  rfl\n\n"}
{"name":"List.map₂Right_nil_cons","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : Option α → β → γ\nb : β\nbs : List β\n⊢ Eq (List.map₂Right f List.nil (List.cons b bs)) (List.cons (f Option.none b) (List.map (f Option.none) bs))","decl":"@[simp]\ntheorem map₂Right_nil_cons : map₂Right f [] (b :: bs) = f none b :: bs.map (f none) :=\n  rfl\n\n"}
{"name":"List.map₂Right_cons_cons","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : Option α → β → γ\na : α\nas : List α\nb : β\nbs : List β\n⊢ Eq (List.map₂Right f (List.cons a as) (List.cons b bs)) (List.cons (f (Option.some a) b) (List.map₂Right f as bs))","decl":"@[simp]\ntheorem map₂Right_cons_cons :\n    map₂Right f (a :: as) (b :: bs) = f (some a) b :: map₂Right f as bs :=\n  rfl\n\n"}
{"name":"List.map₂Right_eq_map₂Right'","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : Option α → β → γ\nas : List α\nbs : List β\n⊢ Eq (List.map₂Right f as bs) (List.map₂Right' f as bs).fst","decl":"theorem map₂Right_eq_map₂Right' : map₂Right f as bs = (map₂Right' f as bs).fst := by\n  simp only [map₂Right, map₂Right', map₂Left_eq_map₂Left']\n\n"}
{"name":"List.map₂Right_eq_zipWith","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : Option α → β → γ\nas : List α\nbs : List β\nh : LE.le bs.length as.length\n⊢ Eq (List.map₂Right f as bs) (List.zipWith (fun a b => f (Option.some a) b) as bs)","decl":"theorem map₂Right_eq_zipWith (h : length bs ≤ length as) :\n    map₂Right f as bs = zipWith (fun a b => f (some a) b) as bs := by\n  have : (fun a b => flip f a (some b)) = flip fun a b => f (some a) b := rfl\n  simp only [map₂Right, map₂Left_eq_zipWith, zipWith_flip, *]\n\n"}
{"name":"List.zipLeft_nil_right","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\nas : List α\n⊢ Eq (as.zipLeft List.nil) (List.map (fun a => { fst := a, snd := Option.none }) as)","decl":"@[simp]\ntheorem zipLeft_nil_right : zipLeft as ([] : List β) = as.map fun a => (a, none) := by\n  cases as <;> rfl\n\n"}
{"name":"List.zipLeft_nil_left","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\nbs : List β\n⊢ Eq (List.nil.zipLeft bs) List.nil","decl":"@[simp]\ntheorem zipLeft_nil_left : zipLeft ([] : List α) bs = [] :=\n  rfl\n\n"}
{"name":"List.zipLeft_cons_nil","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\na : α\nas : List α\n⊢ Eq ((List.cons a as).zipLeft List.nil) (List.cons { fst := a, snd := Option.none } (List.map (fun a => { fst := a, snd := Option.none }) as))","decl":"@[simp]\ntheorem zipLeft_cons_nil :\n    zipLeft (a :: as) ([] : List β) = (a, none) :: as.map fun a => (a, none) :=\n  rfl\n\n"}
{"name":"List.zipLeft_cons_cons","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\na : α\nas : List α\nb : β\nbs : List β\n⊢ Eq ((List.cons a as).zipLeft (List.cons b bs)) (List.cons { fst := a, snd := Option.some b } (as.zipLeft bs))","decl":"@[simp]\ntheorem zipLeft_cons_cons : zipLeft (a :: as) (b :: bs) = (a, some b) :: zipLeft as bs :=\n  rfl\n\n-- Porting note: arguments explicit for recursion\n"}
{"name":"List.zipLeft_eq_zipLeft'","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\nas : List α\nbs : List β\n⊢ Eq (as.zipLeft bs) (as.zipLeft' bs).fst","decl":"theorem zipLeft_eq_zipLeft' (as : List α) (bs : List β) : zipLeft as bs = (zipLeft' as bs).fst := by\n  rw [zipLeft, zipLeft']\n  cases as with\n  | nil => rfl\n  | cons _ atl =>\n    cases bs with\n    | nil => rfl\n    | cons _ btl =>\n      rw [zipWithLeft, zipWithLeft', cons_inj_right]\n      exact @zipLeft_eq_zipLeft' atl btl\n\n"}
{"name":"List.zipRight_nil_left","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\nbs : List β\n⊢ Eq (List.nil.zipRight bs) (List.map (fun b => { fst := Option.none, snd := b }) bs)","decl":"@[simp]\ntheorem zipRight_nil_left : zipRight ([] : List α) bs = bs.map fun b => (none, b) := by\n  cases bs <;> rfl\n\n"}
{"name":"List.zipRight_nil_right","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\nas : List α\n⊢ Eq (as.zipRight List.nil) List.nil","decl":"@[simp]\ntheorem zipRight_nil_right : zipRight as ([] : List β) = [] :=\n  rfl\n\n"}
{"name":"List.zipRight_nil_cons","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\nb : β\nbs : List β\n⊢ Eq (List.nil.zipRight (List.cons b bs)) (List.cons { fst := Option.none, snd := b } (List.map (fun b => { fst := Option.none, snd := b }) bs))","decl":"@[simp]\ntheorem zipRight_nil_cons :\n    zipRight ([] : List α) (b :: bs) = (none, b) :: bs.map fun b => (none, b) :=\n  rfl\n\n"}
{"name":"List.zipRight_cons_cons","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\na : α\nas : List α\nb : β\nbs : List β\n⊢ Eq ((List.cons a as).zipRight (List.cons b bs)) (List.cons { fst := Option.some a, snd := b } (as.zipRight bs))","decl":"@[simp]\ntheorem zipRight_cons_cons : zipRight (a :: as) (b :: bs) = (some a, b) :: zipRight as bs :=\n  rfl\n\n"}
{"name":"List.zipRight_eq_zipRight'","module":"Mathlib.Data.List.Map2","initialProofState":"α : Type u\nβ : Type v\nas : List α\nbs : List β\n⊢ Eq (as.zipRight bs) (as.zipRight' bs).fst","decl":"theorem zipRight_eq_zipRight' : zipRight as bs = (zipRight' as bs).fst := by\n  induction as generalizing bs <;> cases bs <;> simp [*]\n\n"}
