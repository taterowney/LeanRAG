{"name":"PresentedMonoid.inductionOn","module":"Mathlib.Algebra.PresentedMonoid.Basic","initialProofState":"α₁ : Type u_2\nrels₁ : FreeMonoid α₁ → FreeMonoid α₁ → Prop\nδ : PresentedMonoid rels₁ → Prop\nq : PresentedMonoid rels₁\nh : ∀ (a : FreeMonoid α₁), δ ((PresentedMonoid.mk rels₁) a)\n⊢ δ q","decl":"@[to_additive (attr := elab_as_elim), induction_eliminator]\nprotected theorem inductionOn {δ : P₁ → Prop} (q : P₁) (h : ∀ a, δ (mk rels₁ a)) : δ q :=\n  Quotient.ind h q\n\n"}
{"name":"PresentedAddMonoid.inductionOn","module":"Mathlib.Algebra.PresentedMonoid.Basic","initialProofState":"α₁ : Type u_2\nrels₁ : FreeAddMonoid α₁ → FreeAddMonoid α₁ → Prop\nδ : PresentedAddMonoid rels₁ → Prop\nq : PresentedAddMonoid rels₁\nh : ∀ (a : FreeAddMonoid α₁), δ ((PresentedAddMonoid.mk rels₁) a)\n⊢ δ q","decl":"@[to_additive (attr := elab_as_elim), induction_eliminator]\nprotected theorem inductionOn {δ : P₁ → Prop} (q : P₁) (h : ∀ a, δ (mk rels₁ a)) : δ q :=\n  Quotient.ind h q\n\n"}
{"name":"PresentedMonoid.inductionOn₂","module":"Mathlib.Algebra.PresentedMonoid.Basic","initialProofState":"α₁ : Type u_2\nα₂ : Type u_3\nrels₁ : FreeMonoid α₁ → FreeMonoid α₁ → Prop\nrels₂ : FreeMonoid α₂ → FreeMonoid α₂ → Prop\nδ : PresentedMonoid rels₁ → PresentedMonoid rels₂ → Prop\nq₁ : PresentedMonoid rels₁\nq₂ : PresentedMonoid rels₂\nh : ∀ (a : FreeMonoid α₁) (b : FreeMonoid α₂), δ ((PresentedMonoid.mk rels₁) a) ((PresentedMonoid.mk rels₂) b)\n⊢ δ q₁ q₂","decl":"@[to_additive (attr := elab_as_elim)]\nprotected theorem inductionOn₂ {δ : P₁ → P₂ → Prop} (q₁ : P₁) (q₂ : P₂)\n    (h : ∀ a b, δ (mk rels₁ a) (mk rels₂ b)) : δ q₁ q₂ :=\n  Quotient.inductionOn₂ q₁ q₂ h\n\n"}
{"name":"PresentedAddMonoid.inductionOn₂","module":"Mathlib.Algebra.PresentedMonoid.Basic","initialProofState":"α₁ : Type u_2\nα₂ : Type u_3\nrels₁ : FreeAddMonoid α₁ → FreeAddMonoid α₁ → Prop\nrels₂ : FreeAddMonoid α₂ → FreeAddMonoid α₂ → Prop\nδ : PresentedAddMonoid rels₁ → PresentedAddMonoid rels₂ → Prop\nq₁ : PresentedAddMonoid rels₁\nq₂ : PresentedAddMonoid rels₂\nh : ∀ (a : FreeAddMonoid α₁) (b : FreeAddMonoid α₂), δ ((PresentedAddMonoid.mk rels₁) a) ((PresentedAddMonoid.mk rels₂) b)\n⊢ δ q₁ q₂","decl":"@[to_additive (attr := elab_as_elim)]\nprotected theorem inductionOn₂ {δ : P₁ → P₂ → Prop} (q₁ : P₁) (q₂ : P₂)\n    (h : ∀ a b, δ (mk rels₁ a) (mk rels₂ b)) : δ q₁ q₂ :=\n  Quotient.inductionOn₂ q₁ q₂ h\n\n"}
{"name":"PresentedAddMonoid.inductionOn₃","module":"Mathlib.Algebra.PresentedMonoid.Basic","initialProofState":"α₁ : Type u_2\nα₂ : Type u_3\nα₃ : Type u_4\nrels₁ : FreeAddMonoid α₁ → FreeAddMonoid α₁ → Prop\nrels₂ : FreeAddMonoid α₂ → FreeAddMonoid α₂ → Prop\nrels₃ : FreeAddMonoid α₃ → FreeAddMonoid α₃ → Prop\nδ : PresentedAddMonoid rels₁ → PresentedAddMonoid rels₂ → PresentedAddMonoid rels₃ → Prop\nq₁ : PresentedAddMonoid rels₁\nq₂ : PresentedAddMonoid rels₂\nq₃ : PresentedAddMonoid rels₃\nh : ∀ (a : FreeAddMonoid α₁) (b : FreeAddMonoid α₂) (c : FreeAddMonoid α₃), δ ((PresentedAddMonoid.mk rels₁) a) ((PresentedAddMonoid.mk rels₂) b) ((PresentedAddMonoid.mk rels₃) c)\n⊢ δ q₁ q₂ q₃","decl":"@[to_additive (attr := elab_as_elim)]\nprotected theorem inductionOn₃ {δ : P₁ → P₂ → P₃ → Prop} (q₁ : P₁)\n    (q₂ : P₂) (q₃ : P₃) (h : ∀ a b c, δ (mk rels₁ a) (mk rels₂ b) (mk rels₃ c)) :\n    δ q₁ q₂ q₃ :=\n  Quotient.inductionOn₃ q₁ q₂ q₃ h\n\n"}
{"name":"PresentedMonoid.inductionOn₃","module":"Mathlib.Algebra.PresentedMonoid.Basic","initialProofState":"α₁ : Type u_2\nα₂ : Type u_3\nα₃ : Type u_4\nrels₁ : FreeMonoid α₁ → FreeMonoid α₁ → Prop\nrels₂ : FreeMonoid α₂ → FreeMonoid α₂ → Prop\nrels₃ : FreeMonoid α₃ → FreeMonoid α₃ → Prop\nδ : PresentedMonoid rels₁ → PresentedMonoid rels₂ → PresentedMonoid rels₃ → Prop\nq₁ : PresentedMonoid rels₁\nq₂ : PresentedMonoid rels₂\nq₃ : PresentedMonoid rels₃\nh : ∀ (a : FreeMonoid α₁) (b : FreeMonoid α₂) (c : FreeMonoid α₃), δ ((PresentedMonoid.mk rels₁) a) ((PresentedMonoid.mk rels₂) b) ((PresentedMonoid.mk rels₃) c)\n⊢ δ q₁ q₂ q₃","decl":"@[to_additive (attr := elab_as_elim)]\nprotected theorem inductionOn₃ {δ : P₁ → P₂ → P₃ → Prop} (q₁ : P₁)\n    (q₂ : P₂) (q₃ : P₃) (h : ∀ a b c, δ (mk rels₁ a) (mk rels₂ b) (mk rels₃ c)) :\n    δ q₁ q₂ q₃ :=\n  Quotient.inductionOn₃ q₁ q₂ q₃ h\n\n"}
{"name":"PresentedAddMonoid.closure_range_of","module":"Mathlib.Algebra.PresentedMonoid.Basic","initialProofState":"α : Type u_2\nrels : FreeAddMonoid α → FreeAddMonoid α → Prop\n⊢ Eq (AddSubmonoid.closure (Set.range (PresentedAddMonoid.of rels))) Top.top","decl":"/-- The generators of a presented monoid generate the presented monoid. That is, the submonoid\nclosure of the set of generators equals `⊤`. -/\n@[to_additive (attr := simp) \"The generators of a presented additive monoid generate the presented\nadditive monoid. That is, the additive submonoid closure of the set of generators equals `⊤`\"]\ntheorem closure_range_of (rels : FreeMonoid α → FreeMonoid α → Prop) :\n    Submonoid.closure (Set.range (PresentedMonoid.of rels)) = ⊤ := by\n  rw [Submonoid.eq_top_iff']\n  intro x\n  induction' x with a\n  induction a\n  · exact Submonoid.one_mem _\n  · rename_i x\n    exact subset_closure (Exists.intro x rfl)\n  rename_i x y hx hy\n  exact Submonoid.mul_mem _ hx hy\n\n"}
{"name":"PresentedMonoid.closure_range_of","module":"Mathlib.Algebra.PresentedMonoid.Basic","initialProofState":"α : Type u_2\nrels : FreeMonoid α → FreeMonoid α → Prop\n⊢ Eq (Submonoid.closure (Set.range (PresentedMonoid.of rels))) Top.top","decl":"/-- The generators of a presented monoid generate the presented monoid. That is, the submonoid\nclosure of the set of generators equals `⊤`. -/\n@[to_additive (attr := simp) \"The generators of a presented additive monoid generate the presented\nadditive monoid. That is, the additive submonoid closure of the set of generators equals `⊤`\"]\ntheorem closure_range_of (rels : FreeMonoid α → FreeMonoid α → Prop) :\n    Submonoid.closure (Set.range (PresentedMonoid.of rels)) = ⊤ := by\n  rw [Submonoid.eq_top_iff']\n  intro x\n  induction' x with a\n  induction a\n  · exact Submonoid.one_mem _\n  · rename_i x\n    exact subset_closure (Exists.intro x rfl)\n  rename_i x y hx hy\n  exact Submonoid.mul_mem _ hx hy\n\n"}
{"name":"PresentedMonoid.surjective_mk","module":"Mathlib.Algebra.PresentedMonoid.Basic","initialProofState":"α : Type u_2\nrels : FreeMonoid α → FreeMonoid α → Prop\n⊢ Function.Surjective ⇑(PresentedMonoid.mk rels)","decl":"@[to_additive]\ntheorem surjective_mk {rels : FreeMonoid α → FreeMonoid α → Prop} :\n    Function.Surjective (mk rels) := fun x ↦ PresentedMonoid.inductionOn x fun a ↦ .intro a rfl\n\n"}
{"name":"PresentedAddMonoid.surjective_mk","module":"Mathlib.Algebra.PresentedMonoid.Basic","initialProofState":"α : Type u_2\nrels : FreeAddMonoid α → FreeAddMonoid α → Prop\n⊢ Function.Surjective ⇑(PresentedAddMonoid.mk rels)","decl":"@[to_additive]\ntheorem surjective_mk {rels : FreeMonoid α → FreeMonoid α → Prop} :\n    Function.Surjective (mk rels) := fun x ↦ PresentedMonoid.inductionOn x fun a ↦ .intro a rfl\n\n"}
{"name":"PresentedAddMonoid.toMonoid.unique","module":"Mathlib.Algebra.PresentedMonoid.Basic","initialProofState":"α : Type u_3\nM : Type u_4\ninst✝ : AddMonoid M\nf : α → M\nrels : FreeAddMonoid α → FreeAddMonoid α → Prop\nh : ∀ (a b : FreeAddMonoid α), rels a b → Eq ((FreeAddMonoid.lift f) a) ((FreeAddMonoid.lift f) b)\ng : AddMonoidHom (addConGen rels).Quotient M\nhg : ∀ (a : α), Eq (g (PresentedAddMonoid.of rels a)) (f a)\n⊢ Eq g (PresentedAddMonoid.lift f h)","decl":"@[to_additive]\ntheorem toMonoid.unique (g : MonoidHom (conGen rels).Quotient M)\n    (hg : ∀ a : α, g (of rels a) = f a) : g = lift f h :=\n  Con.lift_unique (Con.conGen_le h) g (FreeMonoid.hom_eq fun x ↦ let_fun this := hg x; this)\n\n"}
{"name":"PresentedMonoid.toMonoid.unique","module":"Mathlib.Algebra.PresentedMonoid.Basic","initialProofState":"α : Type u_3\nM : Type u_4\ninst✝ : Monoid M\nf : α → M\nrels : FreeMonoid α → FreeMonoid α → Prop\nh : ∀ (a b : FreeMonoid α), rels a b → Eq ((FreeMonoid.lift f) a) ((FreeMonoid.lift f) b)\ng : MonoidHom (conGen rels).Quotient M\nhg : ∀ (a : α), Eq (g (PresentedMonoid.of rels a)) (f a)\n⊢ Eq g (PresentedMonoid.lift f h)","decl":"@[to_additive]\ntheorem toMonoid.unique (g : MonoidHom (conGen rels).Quotient M)\n    (hg : ∀ a : α, g (of rels a) = f a) : g = lift f h :=\n  Con.lift_unique (Con.conGen_le h) g (FreeMonoid.hom_eq fun x ↦ let_fun this := hg x; this)\n\n"}
{"name":"PresentedAddMonoid.lift_of","module":"Mathlib.Algebra.PresentedMonoid.Basic","initialProofState":"α : Type u_3\nM : Type u_4\ninst✝ : AddMonoid M\nf : α → M\nrels : FreeAddMonoid α → FreeAddMonoid α → Prop\nh : ∀ (a b : FreeAddMonoid α), rels a b → Eq ((FreeAddMonoid.lift f) a) ((FreeAddMonoid.lift f) b)\nx : α\n⊢ Eq ((PresentedAddMonoid.lift f h) (PresentedAddMonoid.of rels x)) (f x)","decl":"@[to_additive (attr := simp)]\ntheorem lift_of {x : α} : lift f h (of rels x) = f x := rfl\n\n"}
{"name":"PresentedMonoid.lift_of","module":"Mathlib.Algebra.PresentedMonoid.Basic","initialProofState":"α : Type u_3\nM : Type u_4\ninst✝ : Monoid M\nf : α → M\nrels : FreeMonoid α → FreeMonoid α → Prop\nh : ∀ (a b : FreeMonoid α), rels a b → Eq ((FreeMonoid.lift f) a) ((FreeMonoid.lift f) b)\nx : α\n⊢ Eq ((PresentedMonoid.lift f h) (PresentedMonoid.of rels x)) (f x)","decl":"@[to_additive (attr := simp)]\ntheorem lift_of {x : α} : lift f h (of rels x) = f x := rfl\n\n"}
{"name":"PresentedAddMonoid.ext","module":"Mathlib.Algebra.PresentedMonoid.Basic","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝ : AddMonoid M\nrels : FreeAddMonoid α → FreeAddMonoid α → Prop\nφ ψ : AddMonoidHom (PresentedAddMonoid rels) M\nhx : ∀ (x : α), Eq (φ (PresentedAddMonoid.of rels x)) (ψ (PresentedAddMonoid.of rels x))\n⊢ Eq φ ψ","decl":"@[to_additive (attr := ext)]\ntheorem ext {M : Type*} [Monoid M] (rels : FreeMonoid α → FreeMonoid α → Prop)\n    {φ ψ : PresentedMonoid rels →* M} (hx : ∀ (x : α), φ (.of rels x) = ψ (.of rels x)) :\n    φ = ψ := by\n  apply MonoidHom.eq_of_eqOn_denseM (closure_range_of _)\n  apply eqOn_range.mpr\n  ext\n  rw [Function.comp_apply]\n  exact hx _\n\n"}
{"name":"PresentedMonoid.ext","module":"Mathlib.Algebra.PresentedMonoid.Basic","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝ : Monoid M\nrels : FreeMonoid α → FreeMonoid α → Prop\nφ ψ : MonoidHom (PresentedMonoid rels) M\nhx : ∀ (x : α), Eq (φ (PresentedMonoid.of rels x)) (ψ (PresentedMonoid.of rels x))\n⊢ Eq φ ψ","decl":"@[to_additive (attr := ext)]\ntheorem ext {M : Type*} [Monoid M] (rels : FreeMonoid α → FreeMonoid α → Prop)\n    {φ ψ : PresentedMonoid rels →* M} (hx : ∀ (x : α), φ (.of rels x) = ψ (.of rels x)) :\n    φ = ψ := by\n  apply MonoidHom.eq_of_eqOn_denseM (closure_range_of _)\n  apply eqOn_range.mpr\n  ext\n  rw [Function.comp_apply]\n  exact hx _\n\n"}
{"name":"PresentedMonoid.ext_iff","module":"Mathlib.Algebra.PresentedMonoid.Basic","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝ : Monoid M\nrels : FreeMonoid α → FreeMonoid α → Prop\nφ ψ : MonoidHom (PresentedMonoid rels) M\n⊢ Iff (Eq φ ψ) (∀ (x : α), Eq (φ (PresentedMonoid.of rels x)) (ψ (PresentedMonoid.of rels x)))","decl":"@[to_additive (attr := ext)]\ntheorem ext {M : Type*} [Monoid M] (rels : FreeMonoid α → FreeMonoid α → Prop)\n    {φ ψ : PresentedMonoid rels →* M} (hx : ∀ (x : α), φ (.of rels x) = ψ (.of rels x)) :\n    φ = ψ := by\n  apply MonoidHom.eq_of_eqOn_denseM (closure_range_of _)\n  apply eqOn_range.mpr\n  ext\n  rw [Function.comp_apply]\n  exact hx _\n\n"}
{"name":"PresentedAddMonoid.ext_iff","module":"Mathlib.Algebra.PresentedMonoid.Basic","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝ : AddMonoid M\nrels : FreeAddMonoid α → FreeAddMonoid α → Prop\nφ ψ : AddMonoidHom (PresentedAddMonoid rels) M\n⊢ Iff (Eq φ ψ) (∀ (x : α), Eq (φ (PresentedAddMonoid.of rels x)) (ψ (PresentedAddMonoid.of rels x)))","decl":"@[to_additive (attr := ext)]\ntheorem ext {M : Type*} [Monoid M] (rels : FreeMonoid α → FreeMonoid α → Prop)\n    {φ ψ : PresentedMonoid rels →* M} (hx : ∀ (x : α), φ (.of rels x) = ψ (.of rels x)) :\n    φ = ψ := by\n  apply MonoidHom.eq_of_eqOn_denseM (closure_range_of _)\n  apply eqOn_range.mpr\n  ext\n  rw [Function.comp_apply]\n  exact hx _\n\n"}
