{"name":"Algebra.subset_adjoin","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\ns : Set A\n⊢ HasSubset.Subset s ↑(Algebra.adjoin R s)","decl":"@[aesop safe 20 apply (rule_sets := [SetLike])]\ntheorem subset_adjoin : s ⊆ adjoin R s :=\n  Algebra.gc.le_u_l s\n\n"}
{"name":"Algebra.adjoin_le","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\ns : Set A\nS : Subalgebra R A\nH : HasSubset.Subset s ↑S\n⊢ LE.le (Algebra.adjoin R s) S","decl":"theorem adjoin_le {S : Subalgebra R A} (H : s ⊆ S) : adjoin R s ≤ S :=\n  Algebra.gc.l_le H\n\n"}
{"name":"Algebra.adjoin_eq_sInf","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\ns : Set A\n⊢ Eq (Algebra.adjoin R s) (InfSet.sInf (setOf fun p => HasSubset.Subset s ↑p))","decl":"theorem adjoin_eq_sInf : adjoin R s = sInf { p : Subalgebra R A | s ⊆ p } :=\n  le_antisymm (le_sInf fun _ h => adjoin_le h) (sInf_le subset_adjoin)\n\n"}
{"name":"Algebra.adjoin_le_iff","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\ns : Set A\nS : Subalgebra R A\n⊢ Iff (LE.le (Algebra.adjoin R s) S) (HasSubset.Subset s ↑S)","decl":"theorem adjoin_le_iff {S : Subalgebra R A} : adjoin R s ≤ S ↔ s ⊆ S :=\n  Algebra.gc _ _\n\n"}
{"name":"Algebra.adjoin_mono","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\ns t : Set A\nH : HasSubset.Subset s t\n⊢ LE.le (Algebra.adjoin R s) (Algebra.adjoin R t)","decl":"theorem adjoin_mono (H : s ⊆ t) : adjoin R s ≤ adjoin R t :=\n  Algebra.gc.monotone_l H\n\n"}
{"name":"Algebra.adjoin_eq_of_le","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\ns : Set A\nS : Subalgebra R A\nh₁ : HasSubset.Subset s ↑S\nh₂ : LE.le S (Algebra.adjoin R s)\n⊢ Eq (Algebra.adjoin R s) S","decl":"theorem adjoin_eq_of_le (S : Subalgebra R A) (h₁ : s ⊆ S) (h₂ : S ≤ adjoin R s) : adjoin R s = S :=\n  le_antisymm (adjoin_le h₁) h₂\n\n"}
{"name":"Algebra.adjoin_eq","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nS : Subalgebra R A\n⊢ Eq (Algebra.adjoin R ↑S) S","decl":"theorem adjoin_eq (S : Subalgebra R A) : adjoin R ↑S = S :=\n  adjoin_eq_of_le _ (Set.Subset.refl _) subset_adjoin\n\n"}
{"name":"Algebra.adjoin_iUnion","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nα : Type u_1\ns : α → Set A\n⊢ Eq (Algebra.adjoin R (Set.iUnion s)) (iSup fun i => Algebra.adjoin R (s i))","decl":"theorem adjoin_iUnion {α : Type*} (s : α → Set A) :\n    adjoin R (Set.iUnion s) = ⨆ i : α, adjoin R (s i) :=\n  (@Algebra.gc R A _ _ _).l_iSup\n\n"}
{"name":"Algebra.adjoin_attach_biUnion","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝³ : CommSemiring R\ninst✝² : Semiring A\ninst✝¹ : Algebra R A\ninst✝ : DecidableEq A\nα : Type u_1\ns : Finset α\nf : (Subtype fun x => Membership.mem s x) → Finset A\n⊢ Eq (Algebra.adjoin R ↑(s.attach.biUnion f)) (iSup fun x => Algebra.adjoin R ↑(f x))","decl":"theorem adjoin_attach_biUnion [DecidableEq A] {α : Type*} {s : Finset α} (f : s → Finset A) :\n    adjoin R (s.attach.biUnion f : Set A) = ⨆ x, adjoin R (f x) := by simp [adjoin_iUnion]\n\n"}
{"name":"Algebra.adjoin_induction","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\ns : Set A\np : (x : A) → Membership.mem (Algebra.adjoin R s) x → Prop\nmem : ∀ (x : A) (hx : Membership.mem s x), p x ⋯\nalgebraMap : ∀ (r : R), p ((_root_.algebraMap R A) r) ⋯\nadd : ∀ (x y : A) (hx : Membership.mem (Algebra.adjoin R s) x) (hy : Membership.mem (Algebra.adjoin R s) y), p x hx → p y hy → p (HAdd.hAdd x y) ⋯\nmul : ∀ (x y : A) (hx : Membership.mem (Algebra.adjoin R s) x) (hy : Membership.mem (Algebra.adjoin R s) y), p x hx → p y hy → p (HMul.hMul x y) ⋯\nx : A\nhx : Membership.mem (Algebra.adjoin R s) x\n⊢ p x hx","decl":"@[elab_as_elim]\ntheorem adjoin_induction {p : (x : A) → x ∈ adjoin R s → Prop}\n    (mem : ∀ (x) (hx : x ∈ s), p x (subset_adjoin hx))\n    (algebraMap : ∀ r, p (algebraMap R A r) (algebraMap_mem _ r))\n    (add : ∀ x y hx hy, p x hx → p y hy → p (x + y) (add_mem hx hy))\n    (mul : ∀ x y hx hy, p x hx → p y hy → p (x * y) (mul_mem hx hy))\n    {x : A} (hx : x ∈ adjoin R s) : p x hx :=\n  let S : Subalgebra R A :=\n    { carrier := { x | ∃ hx, p x hx }\n      mul_mem' := by rintro _ _ ⟨_, hpx⟩ ⟨_, hpy⟩; exact ⟨_, mul _ _ _ _ hpx hpy⟩\n      add_mem' := by rintro _ _ ⟨_, hpx⟩ ⟨_, hpy⟩; exact ⟨_, add _ _ _ _ hpx hpy⟩\n      algebraMap_mem' := fun r ↦ ⟨_, algebraMap r⟩ }\n  adjoin_le (S := S) (fun y hy ↦ ⟨subset_adjoin hy, mem y hy⟩) hx |>.elim fun _ ↦ _root_.id\n\n"}
{"name":"Algebra.adjoin_induction''","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\ns : Set A\np : (x : A) → Membership.mem (Algebra.adjoin R s) x → Prop\nmem : ∀ (x : A) (hx : Membership.mem s x), p x ⋯\nalgebraMap : ∀ (r : R), p ((_root_.algebraMap R A) r) ⋯\nadd : ∀ (x y : A) (hx : Membership.mem (Algebra.adjoin R s) x) (hy : Membership.mem (Algebra.adjoin R s) y), p x hx → p y hy → p (HAdd.hAdd x y) ⋯\nmul : ∀ (x y : A) (hx : Membership.mem (Algebra.adjoin R s) x) (hy : Membership.mem (Algebra.adjoin R s) y), p x hx → p y hy → p (HMul.hMul x y) ⋯\nx : A\nhx : Membership.mem (Algebra.adjoin R s) x\n⊢ p x hx","decl":"@[deprecated adjoin_induction (since := \"2024-10-10\")]\nalias adjoin_induction'' := adjoin_induction\n\n"}
{"name":"Algebra.adjoin_induction₂","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\ns : Set A\np : (x y : A) → Membership.mem (Algebra.adjoin R s) x → Membership.mem (Algebra.adjoin R s) y → Prop\nmem_mem : ∀ (x y : A) (hx : Membership.mem s x) (hy : Membership.mem s y), p x y ⋯ ⋯\nalgebraMap_both : ∀ (r₁ r₂ : R), p ((algebraMap R A) r₁) ((algebraMap R A) r₂) ⋯ ⋯\nalgebraMap_left : ∀ (r : R) (x : A) (hx : Membership.mem s x), p ((algebraMap R A) r) x ⋯ ⋯\nalgebraMap_right : ∀ (r : R) (x : A) (hx : Membership.mem s x), p x ((algebraMap R A) r) ⋯ ⋯\nadd_left : ∀ (x y z : A) (hx : Membership.mem (Algebra.adjoin R s) x) (hy : Membership.mem (Algebra.adjoin R s) y) (hz : Membership.mem (Algebra.adjoin R s) z), p x z hx hz → p y z hy hz → p (HAdd.hAdd x y) z ⋯ hz\nadd_right : ∀ (x y z : A) (hx : Membership.mem (Algebra.adjoin R s) x) (hy : Membership.mem (Algebra.adjoin R s) y) (hz : Membership.mem (Algebra.adjoin R s) z), p x y hx hy → p x z hx hz → p x (HAdd.hAdd y z) hx ⋯\nmul_left : ∀ (x y z : A) (hx : Membership.mem (Algebra.adjoin R s) x) (hy : Membership.mem (Algebra.adjoin R s) y) (hz : Membership.mem (Algebra.adjoin R s) z), p x z hx hz → p y z hy hz → p (HMul.hMul x y) z ⋯ hz\nmul_right : ∀ (x y z : A) (hx : Membership.mem (Algebra.adjoin R s) x) (hy : Membership.mem (Algebra.adjoin R s) y) (hz : Membership.mem (Algebra.adjoin R s) z), p x y hx hy → p x z hx hz → p x (HMul.hMul y z) hx ⋯\nx y : A\nhx : Membership.mem (Algebra.adjoin R s) x\nhy : Membership.mem (Algebra.adjoin R s) y\n⊢ p x y hx hy","decl":"/-- Induction principle for the algebra generated by a set `s`: show that `p x y` holds for any\n`x y ∈ adjoin R s` given that it holds for `x y ∈ s` and that it satisfies a number of\nnatural properties. -/\n@[elab_as_elim]\ntheorem adjoin_induction₂ {s : Set A} {p : (x y : A) → x ∈ adjoin R s → y ∈ adjoin R s → Prop}\n    (mem_mem : ∀ (x) (y) (hx : x ∈ s) (hy : y ∈ s), p x y (subset_adjoin hx) (subset_adjoin hy))\n    (algebraMap_both : ∀ r₁ r₂, p (algebraMap R A r₁) (algebraMap R A r₂) (algebraMap_mem _ r₁)\n      (algebraMap_mem _ r₂))\n    (algebraMap_left : ∀ (r) (x) (hx : x ∈ s), p (algebraMap R A r) x (algebraMap_mem _ r)\n      (subset_adjoin hx))\n    (algebraMap_right : ∀ (r) (x) (hx : x ∈ s), p x (algebraMap R A r) (subset_adjoin hx)\n      (algebraMap_mem _ r))\n    (add_left : ∀ x y z hx hy hz, p x z hx hz → p y z hy hz → p (x + y) z (add_mem hx hy) hz)\n    (add_right : ∀ x y z hx hy hz, p x y hx hy → p x z hx hz → p x (y + z) hx (add_mem hy hz))\n    (mul_left : ∀ x y z hx hy hz, p x z hx hz → p y z hy hz → p (x * y) z (mul_mem hx hy) hz)\n    (mul_right : ∀ x y z hx hy hz, p x y hx hy → p x z hx hz → p x (y * z) hx (mul_mem hy hz))\n    {x y : A} (hx : x ∈ adjoin R s) (hy : y ∈ adjoin R s) :\n    p x y hx hy := by\n  induction hy using adjoin_induction with\n  | mem z hz => induction hx using adjoin_induction with\n    | mem _ h => exact mem_mem _ _ h hz\n    | algebraMap _ => exact algebraMap_left _ _ hz\n    | mul _ _ _ _ h₁ h₂ => exact mul_left _ _ _ _ _ _ h₁ h₂\n    | add _ _ _ _ h₁ h₂ => exact add_left _ _ _ _ _ _ h₁ h₂\n  | algebraMap r =>\n    induction hx using adjoin_induction with\n    | mem _ h => exact algebraMap_right _ _ h\n    | algebraMap _ => exact algebraMap_both _ _\n    | mul _ _ _ _ h₁ h₂ => exact mul_left _ _ _ _ _ _ h₁ h₂\n    | add _ _ _ _ h₁ h₂ => exact add_left _ _ _ _ _ _ h₁ h₂\n  | mul _ _ _ _ h₁ h₂ => exact mul_right _ _ _ _ _ _ h₁ h₂\n  | add _ _ _ _ h₁ h₂ => exact add_right _ _ _ _ _ _ h₁ h₂\n\n"}
{"name":"Algebra.adjoin_induction'","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\ns : Set A\np : (Subtype fun x => Membership.mem (Algebra.adjoin R s) x) → Prop\nmem : ∀ (x : A) (h : Membership.mem s x), p ⟨x, ⋯⟩\nalgebraMap : ∀ (r : R), p ((_root_.algebraMap R (Subtype fun x => Membership.mem (Algebra.adjoin R s) x)) r)\nadd : ∀ (x y : Subtype fun x => Membership.mem (Algebra.adjoin R s) x), p x → p y → p (HAdd.hAdd x y)\nmul : ∀ (x y : Subtype fun x => Membership.mem (Algebra.adjoin R s) x), p x → p y → p (HMul.hMul x y)\nx : Subtype fun x => Membership.mem (Algebra.adjoin R s) x\n⊢ p x","decl":"/-- The difference with `Algebra.adjoin_induction` is that this acts on the subtype. -/\n@[elab_as_elim, deprecated adjoin_induction (since := \"2024-10-11\")]\ntheorem adjoin_induction' {p : adjoin R s → Prop} (mem : ∀ (x) (h : x ∈ s), p ⟨x, subset_adjoin h⟩)\n    (algebraMap : ∀ r, p (algebraMap R _ r)) (add : ∀ x y, p x → p y → p (x + y))\n    (mul : ∀ x y, p x → p y → p (x * y)) (x : adjoin R s) : p x :=\n  Subtype.recOn x fun x hx => by\n    induction hx using adjoin_induction with\n    | mem _ h => exact mem _ h\n    | algebraMap _ => exact algebraMap _\n    | mul _ _ _ _ h₁ h₂ => exact mul _ _ h₁ h₂\n    | add _ _ _ _ h₁ h₂ => exact add _ _ h₁ h₂\n\n"}
{"name":"Algebra.adjoin_adjoin_coe_preimage","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\ns : Set A\n⊢ Eq (Algebra.adjoin R (Set.preimage Subtype.val s)) Top.top","decl":"@[simp]\ntheorem adjoin_adjoin_coe_preimage {s : Set A} : adjoin R (((↑) : adjoin R s → A) ⁻¹' s) = ⊤ := by\n  refine eq_top_iff.2 fun ⟨x, hx⟩ ↦\n      adjoin_induction (fun a ha ↦ ?_) (fun r ↦ ?_) (fun _ _ _ _ ↦ ?_) (fun _ _ _ _ ↦ ?_) hx\n  · exact subset_adjoin ha\n  · exact Subalgebra.algebraMap_mem _ r\n  · exact Subalgebra.add_mem _\n  · exact Subalgebra.mul_mem _\n\n"}
{"name":"Algebra.adjoin_union","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\ns t : Set A\n⊢ Eq (Algebra.adjoin R (Union.union s t)) (Max.max (Algebra.adjoin R s) (Algebra.adjoin R t))","decl":"theorem adjoin_union (s t : Set A) : adjoin R (s ∪ t) = adjoin R s ⊔ adjoin R t :=\n  (Algebra.gc : GaloisConnection _ ((↑) : Subalgebra R A → Set A)).l_sup\n\n"}
{"name":"Algebra.adjoin_empty","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\n⊢ Eq (Algebra.adjoin R EmptyCollection.emptyCollection) Bot.bot","decl":"@[simp]\ntheorem adjoin_empty : adjoin R (∅ : Set A) = ⊥ :=\n  show adjoin R ⊥ = ⊥ by\n    apply GaloisConnection.l_bot\n    exact Algebra.gc\n\n"}
{"name":"Algebra.adjoin_univ","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\n⊢ Eq (Algebra.adjoin R Set.univ) Top.top","decl":"@[simp]\ntheorem adjoin_univ : adjoin R (Set.univ : Set A) = ⊤ :=\n  eq_top_iff.2 fun _x => subset_adjoin <| Set.mem_univ _\n\n"}
{"name":"Algebra.adjoin_eq_span","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\ns : Set A\n⊢ Eq (Subalgebra.toSubmodule (Algebra.adjoin R s)) (Submodule.span R ↑(Submonoid.closure s))","decl":"theorem adjoin_eq_span : Subalgebra.toSubmodule (adjoin R s) = span R (Submonoid.closure s) := by\n  apply le_antisymm\n  · intro r hr\n    rcases Subsemiring.mem_closure_iff_exists_list.1 hr with ⟨L, HL, rfl⟩\n    clear hr\n    induction' L with hd tl ih\n    · exact zero_mem _\n    rw [List.forall_mem_cons] at HL\n    rw [List.map_cons, List.sum_cons]\n    refine Submodule.add_mem _ ?_ (ih HL.2)\n    replace HL := HL.1\n    clear ih tl\n    suffices ∃ (z r : _) (_hr : r ∈ Submonoid.closure s), z • r = List.prod hd by\n      rcases this with ⟨z, r, hr, hzr⟩\n      rw [← hzr]\n      exact smul_mem _ _ (subset_span hr)\n    induction' hd with hd tl ih\n    · exact ⟨1, 1, (Submonoid.closure s).one_mem', one_smul _ _⟩\n    rw [List.forall_mem_cons] at HL\n    rcases ih HL.2 with ⟨z, r, hr, hzr⟩\n    rw [List.prod_cons, ← hzr]\n    rcases HL.1 with (⟨hd, rfl⟩ | hs)\n    · refine ⟨hd * z, r, hr, ?_⟩\n      rw [Algebra.smul_def, Algebra.smul_def, (algebraMap _ _).map_mul, _root_.mul_assoc]\n    · exact\n        ⟨z, hd * r, Submonoid.mul_mem _ (Submonoid.subset_closure hs) hr,\n          (mul_smul_comm _ _ _).symm⟩\n  refine span_le.2 ?_\n  change Submonoid.closure s ≤ (adjoin R s).toSubsemiring.toSubmonoid\n  exact Submonoid.closure_le.2 subset_adjoin\n\n"}
{"name":"Algebra.span_le_adjoin","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\ns : Set A\n⊢ LE.le (Submodule.span R s) (Subalgebra.toSubmodule (Algebra.adjoin R s))","decl":"theorem span_le_adjoin (s : Set A) : span R s ≤ Subalgebra.toSubmodule (adjoin R s) :=\n  span_le.mpr subset_adjoin\n\n"}
{"name":"Algebra.adjoin_toSubmodule_le","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\ns : Set A\nt : Submodule R A\n⊢ Iff (LE.le (Subalgebra.toSubmodule (Algebra.adjoin R s)) t) (HasSubset.Subset ↑(Submonoid.closure s) ↑t)","decl":"theorem adjoin_toSubmodule_le {s : Set A} {t : Submodule R A} :\n    Subalgebra.toSubmodule (adjoin R s) ≤ t ↔ ↑(Submonoid.closure s) ⊆ (t : Set A) := by\n  rw [adjoin_eq_span, span_le]\n\n"}
{"name":"Algebra.adjoin_eq_span_of_subset","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\ns : Set A\nhs : HasSubset.Subset ↑(Submonoid.closure s) ↑(Submodule.span R s)\n⊢ Eq (Subalgebra.toSubmodule (Algebra.adjoin R s)) (Submodule.span R s)","decl":"theorem adjoin_eq_span_of_subset {s : Set A} (hs : ↑(Submonoid.closure s) ⊆ (span R s : Set A)) :\n    Subalgebra.toSubmodule (adjoin R s) = span R s :=\n  le_antisymm ((adjoin_toSubmodule_le R).mpr hs) (span_le_adjoin R s)\n\n"}
{"name":"Algebra.adjoin_span","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\ns : Set A\n⊢ Eq (Algebra.adjoin R ↑(Submodule.span R s)) (Algebra.adjoin R s)","decl":"@[simp]\ntheorem adjoin_span {s : Set A} : adjoin R (Submodule.span R s : Set A) = adjoin R s :=\n  le_antisymm (adjoin_le (span_le_adjoin _ _)) (adjoin_mono Submodule.subset_span)\n\n"}
{"name":"Algebra.adjoin_image","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf : AlgHom R A B\ns : Set A\n⊢ Eq (Algebra.adjoin R (Set.image (⇑f) s)) (Subalgebra.map f (Algebra.adjoin R s))","decl":"theorem adjoin_image (f : A →ₐ[R] B) (s : Set A) : adjoin R (f '' s) = (adjoin R s).map f :=\n  le_antisymm (adjoin_le <| Set.image_subset _ subset_adjoin) <|\n    Subalgebra.map_le.2 <| adjoin_le <| Set.image_subset_iff.1 <| by\n      -- Porting note: I don't understand how this worked in Lean 3 with just `subset_adjoin`\n      simp only [Set.image_id', coe_carrier_toSubmonoid, Subalgebra.coe_toSubsemiring,\n        Subalgebra.coe_comap]\n      exact fun x hx => subset_adjoin ⟨x, hx, rfl⟩\n\n"}
{"name":"Algebra.adjoin_insert_adjoin","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\ns : Set A\nx : A\n⊢ Eq (Algebra.adjoin R (Insert.insert x ↑(Algebra.adjoin R s))) (Algebra.adjoin R (Insert.insert x s))","decl":"@[simp]\ntheorem adjoin_insert_adjoin (x : A) : adjoin R (insert x ↑(adjoin R s)) = adjoin R (insert x s) :=\n  le_antisymm\n    (adjoin_le\n      (Set.insert_subset_iff.mpr\n        ⟨subset_adjoin (Set.mem_insert _ _), adjoin_mono (Set.subset_insert _ _)⟩))\n    (Algebra.adjoin_mono (Set.insert_subset_insert Algebra.subset_adjoin))\n\n"}
{"name":"Algebra.adjoin_prod_le","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\ns : Set A\nt : Set B\n⊢ LE.le (Algebra.adjoin R (SProd.sprod s t)) ((Algebra.adjoin R s).prod (Algebra.adjoin R t))","decl":"theorem adjoin_prod_le (s : Set A) (t : Set B) :\n    adjoin R (s ×ˢ t) ≤ (adjoin R s).prod (adjoin R t) :=\n  adjoin_le <| Set.prod_mono subset_adjoin subset_adjoin\n\n"}
{"name":"Algebra.mem_adjoin_of_map_mul","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\ns : Set A\nx : A\nf : LinearMap (RingHom.id R) A B\nhf : ∀ (a₁ a₂ : A), Eq (f (HMul.hMul a₁ a₂)) (HMul.hMul (f a₁) (f a₂))\nh : Membership.mem (Algebra.adjoin R s) x\n⊢ Membership.mem (Algebra.adjoin R (Set.image (⇑f) (Union.union s (Singleton.singleton 1)))) (f x)","decl":"theorem mem_adjoin_of_map_mul {s} {x : A} {f : A →ₗ[R] B} (hf : ∀ a₁ a₂, f (a₁ * a₂) = f a₁ * f a₂)\n    (h : x ∈ adjoin R s) : f x ∈ adjoin R (f '' (s ∪ {1})) := by\n  induction h using adjoin_induction with\n  | mem a ha => exact subset_adjoin ⟨a, ⟨Set.subset_union_left ha, rfl⟩⟩\n  | algebraMap r =>\n    have : f 1 ∈ adjoin R (f '' (s ∪ {1})) :=\n      subset_adjoin ⟨1, ⟨Set.subset_union_right <| Set.mem_singleton 1, rfl⟩⟩\n    convert Subalgebra.smul_mem (adjoin R (f '' (s ∪ {1}))) this r\n    rw [algebraMap_eq_smul_one]\n    exact f.map_smul _ _\n  | add y z _ _ hy hz => simpa [hy, hz] using Subalgebra.add_mem _ hy hz\n  | mul y z _ _ hy hz => simpa [hf, hy, hz] using Subalgebra.mul_mem _ hy hz\n\n"}
{"name":"Algebra.adjoin_inl_union_inr_eq_prod","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\ns : Set A\nt : Set B\n⊢ Eq (Algebra.adjoin R (Union.union (Set.image (⇑(LinearMap.inl R A B)) (Union.union s (Singleton.singleton 1))) (Set.image (⇑(LinearMap.inr R A B)) (Union.union t (Singleton.singleton 1))))) ((Algebra.adjoin R s).prod (Algebra.adjoin R t))","decl":"theorem adjoin_inl_union_inr_eq_prod (s) (t) :\n    adjoin R (LinearMap.inl R A B '' (s ∪ {1}) ∪ LinearMap.inr R A B '' (t ∪ {1})) =\n      (adjoin R s).prod (adjoin R t) := by\n  apply le_antisymm\n  · simp only [adjoin_le_iff, Set.insert_subset_iff, Subalgebra.zero_mem, Subalgebra.one_mem,\n      subset_adjoin,-- the rest comes from `squeeze_simp`\n      Set.union_subset_iff,\n      LinearMap.coe_inl, Set.mk_preimage_prod_right, Set.image_subset_iff, SetLike.mem_coe,\n      Set.mk_preimage_prod_left, LinearMap.coe_inr, and_self_iff, Set.union_singleton,\n      Subalgebra.coe_prod]\n  · rintro ⟨a, b⟩ ⟨ha, hb⟩\n    let P := adjoin R (LinearMap.inl R A B '' (s ∪ {1}) ∪ LinearMap.inr R A B '' (t ∪ {1}))\n    have Ha : (a, (0 : B)) ∈ adjoin R (LinearMap.inl R A B '' (s ∪ {1})) :=\n      mem_adjoin_of_map_mul R LinearMap.inl_map_mul ha\n    have Hb : ((0 : A), b) ∈ adjoin R (LinearMap.inr R A B '' (t ∪ {1})) :=\n      mem_adjoin_of_map_mul R LinearMap.inr_map_mul hb\n    replace Ha : (a, (0 : B)) ∈ P := adjoin_mono Set.subset_union_left Ha\n    replace Hb : ((0 : A), b) ∈ P := adjoin_mono Set.subset_union_right Hb\n    simpa [P] using Subalgebra.add_mem _ Ha Hb\n\n"}
{"name":"Algebra.adjoin_le_centralizer_centralizer","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\ns : Set A\n⊢ LE.le (Algebra.adjoin R s) (Subalgebra.centralizer R ↑(Subalgebra.centralizer R s))","decl":"lemma adjoin_le_centralizer_centralizer (s : Set A) :\n    adjoin R s ≤ Subalgebra.centralizer R (Subalgebra.centralizer R s) :=\n  adjoin_le Set.subset_centralizer_centralizer\n\n"}
{"name":"Algebra.commute_of_mem_adjoin_of_forall_mem_commute","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\na b : A\ns : Set A\nhb : Membership.mem (Algebra.adjoin R s) b\nh : ∀ (b : A), Membership.mem s b → Commute a b\n⊢ Commute a b","decl":"lemma commute_of_mem_adjoin_of_forall_mem_commute {a b : A} {s : Set A}\n    (hb : b ∈ adjoin R s) (h : ∀ b ∈ s, Commute a b) :\n    Commute a b := by\n  induction hb using adjoin_induction with\n  | mem x hx => exact h x hx\n  | algebraMap r => exact commutes r a |>.symm\n  | add y z _ _ hy hz => exact hy.add_right hz\n  | mul y z _ _ hy hz => exact hy.mul_right hz\n\n"}
{"name":"Algebra.commute_of_mem_adjoin_singleton_of_commute","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\na b c : A\nhc : Membership.mem (Algebra.adjoin R (Singleton.singleton b)) c\nh : Commute a b\n⊢ Commute a c","decl":"lemma commute_of_mem_adjoin_singleton_of_commute {a b c : A}\n    (hc : c ∈ adjoin R {b}) (h : Commute a b) :\n    Commute a c :=\n  commute_of_mem_adjoin_of_forall_mem_commute hc <| by simpa\n\n"}
{"name":"Algebra.commute_of_mem_adjoin_self","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\na b : A\nhb : Membership.mem (Algebra.adjoin R (Singleton.singleton a)) b\n⊢ Commute a b","decl":"lemma commute_of_mem_adjoin_self {a b : A} (hb : b ∈ adjoin R {a}) :\n    Commute a b :=\n  commute_of_mem_adjoin_singleton_of_commute hb rfl\n\n"}
{"name":"Algebra.adjoin_singleton_one","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\n⊢ Eq (Algebra.adjoin R (Singleton.singleton 1)) Bot.bot","decl":"theorem adjoin_singleton_one : adjoin R ({1} : Set A) = ⊥ :=\n  eq_bot_iff.2 <| adjoin_le <| Set.singleton_subset_iff.2 <| SetLike.mem_coe.2 <| one_mem _\n\n"}
{"name":"Algebra.self_mem_adjoin_singleton","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nx : A\n⊢ Membership.mem (Algebra.adjoin R (Singleton.singleton x)) x","decl":"theorem self_mem_adjoin_singleton (x : A) : x ∈ adjoin R ({x} : Set A) :=\n  Algebra.subset_adjoin (Set.mem_singleton_iff.mpr rfl)\n\n"}
{"name":"Algebra.adjoin_algebraMap","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Semiring A\ninst✝³ : Algebra R S\ninst✝² : Algebra R A\ninst✝¹ : Algebra S A\ninst✝ : IsScalarTower R S A\ns : Set S\n⊢ Eq (Algebra.adjoin R (Set.image (⇑(algebraMap S A)) s)) (Subalgebra.map (IsScalarTower.toAlgHom R S A) (Algebra.adjoin R s))","decl":"variable (A) in\ntheorem adjoin_algebraMap (s : Set S) :\n    adjoin R (algebraMap S A '' s) = (adjoin R s).map (IsScalarTower.toAlgHom R S A) :=\n  adjoin_image R (IsScalarTower.toAlgHom R S A) s\n\n"}
{"name":"Algebra.adjoin_algebraMap_image_union_eq_adjoin_adjoin","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Semiring A\ninst✝³ : Algebra R S\ninst✝² : Algebra R A\ninst✝¹ : Algebra S A\ninst✝ : IsScalarTower R S A\ns : Set S\nt : Set A\n⊢ Eq (Algebra.adjoin R (Union.union (Set.image (⇑(algebraMap S A)) s) t)) (Subalgebra.restrictScalars R (Algebra.adjoin (Subtype fun x => Membership.mem (Algebra.adjoin R s) x) t))","decl":"theorem adjoin_algebraMap_image_union_eq_adjoin_adjoin (s : Set S) (t : Set A) :\n    adjoin R (algebraMap S A '' s ∪ t) = (adjoin (adjoin R s) t).restrictScalars R :=\n  le_antisymm\n    (closure_mono <|\n      Set.union_subset (Set.range_subset_iff.2 fun r => Or.inl ⟨algebraMap R (adjoin R s) r,\n        (IsScalarTower.algebraMap_apply _ _ _ _).symm⟩)\n        (Set.union_subset_union_left _ fun _ ⟨_x, hx, hxs⟩ => hxs ▸ ⟨⟨_, subset_adjoin hx⟩, rfl⟩))\n    (closure_le.2 <|\n      Set.union_subset (Set.range_subset_iff.2 fun x => adjoin_mono Set.subset_union_left <|\n        Algebra.adjoin_algebraMap R A s ▸ ⟨x, x.prop, rfl⟩)\n        (Set.Subset.trans Set.subset_union_right subset_adjoin))\n\n"}
{"name":"Algebra.adjoin_adjoin_of_tower","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Semiring A\ninst✝³ : Algebra R S\ninst✝² : Algebra R A\ninst✝¹ : Algebra S A\ninst✝ : IsScalarTower R S A\ns : Set A\n⊢ Eq (Algebra.adjoin S ↑(Algebra.adjoin R s)) (Algebra.adjoin S s)","decl":"theorem adjoin_adjoin_of_tower (s : Set A) : adjoin S (adjoin R s : Set A) = adjoin S s := by\n  apply le_antisymm (adjoin_le _)\n  · exact adjoin_mono subset_adjoin\n  · change adjoin R s ≤ (adjoin S s).restrictScalars R\n    refine adjoin_le ?_\n    -- Porting note: unclear why this was broken\n    have : (Subalgebra.restrictScalars R (adjoin S s) : Set A) = adjoin S s := rfl\n    rw [this]\n    exact subset_adjoin\n\n"}
{"name":"Algebra.Subalgebra.restrictScalars_adjoin","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Semiring A\ninst✝³ : Algebra R S\ninst✝² : Algebra R A\ninst✝¹ : Algebra S A\ninst✝ : IsScalarTower R S A\ns : Set A\n⊢ Eq (Subalgebra.restrictScalars R (Algebra.adjoin S s)) (Max.max (IsScalarTower.toAlgHom R S A).range (Algebra.adjoin R s))","decl":"theorem Subalgebra.restrictScalars_adjoin {s : Set A} :\n    (adjoin S s).restrictScalars R = (IsScalarTower.toAlgHom R S A).range ⊔ adjoin R s := by\n  refine le_antisymm (fun _ hx ↦ adjoin_induction\n    (fun x hx ↦ le_sup_right (α := Subalgebra R A) (subset_adjoin hx))\n    (fun x ↦ le_sup_left (α := Subalgebra R A) ⟨x, rfl⟩)\n    (fun _ _ _ _ ↦ add_mem) (fun _ _ _ _ ↦ mul_mem) <|\n    (Subalgebra.mem_restrictScalars _).mp hx) (sup_le ?_ <| adjoin_le subset_adjoin)\n  rintro _ ⟨x, rfl⟩; exact algebraMap_mem (adjoin S s) x\n\n"}
{"name":"Algebra.adjoin_top","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nS : Type uS\ninst✝⁴ : CommSemiring R\ninst✝³ : CommSemiring S\ninst✝² : Algebra R S\nA : Type u_1\ninst✝¹ : Semiring A\ninst✝ : Algebra S A\nt : Set A\n⊢ Eq (Algebra.adjoin (Subtype fun x => Membership.mem Top.top x) t) (Subalgebra.restrictScalars (Subtype fun x => Membership.mem Top.top x) (Algebra.adjoin S t))","decl":"@[simp]\ntheorem adjoin_top {A} [Semiring A] [Algebra S A] (t : Set A) :\n    adjoin (⊤ : Subalgebra R S) t = (adjoin S t).restrictScalars (⊤ : Subalgebra R S) :=\n  let equivTop : Subalgebra (⊤ : Subalgebra R S) A ≃o Subalgebra S A :=\n    { toFun := fun s => { s with algebraMap_mem' := fun r => s.algebraMap_mem ⟨r, trivial⟩ }\n      invFun := fun s => s.restrictScalars _\n      left_inv := fun _ => SetLike.coe_injective rfl\n      right_inv := fun _ => SetLike.coe_injective rfl\n      map_rel_iff' := @fun _ _ => Iff.rfl }\n  le_antisymm\n    (adjoin_le <| show t ⊆ adjoin S t from subset_adjoin)\n    (equivTop.symm_apply_le.mpr <|\n      adjoin_le <| show t ⊆ adjoin (⊤ : Subalgebra R S) t from subset_adjoin)\n\n"}
{"name":"Algebra.adjoin_union_eq_adjoin_adjoin","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring A\ninst✝ : Algebra R A\ns t : Set A\n⊢ Eq (Algebra.adjoin R (Union.union s t)) (Subalgebra.restrictScalars R (Algebra.adjoin (Subtype fun x => Membership.mem (Algebra.adjoin R s) x) t))","decl":"theorem adjoin_union_eq_adjoin_adjoin :\n    adjoin R (s ∪ t) = (adjoin (adjoin R s) t).restrictScalars R := by\n  simpa using adjoin_algebraMap_image_union_eq_adjoin_adjoin R s t\n\n"}
{"name":"Algebra.adjoin_union_coe_submodule","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring A\ninst✝ : Algebra R A\ns t : Set A\n⊢ Eq (Subalgebra.toSubmodule (Algebra.adjoin R (Union.union s t))) (HMul.hMul (Subalgebra.toSubmodule (Algebra.adjoin R s)) (Subalgebra.toSubmodule (Algebra.adjoin R t)))","decl":"theorem adjoin_union_coe_submodule :\n    Subalgebra.toSubmodule (adjoin R (s ∪ t)) =\n      Subalgebra.toSubmodule (adjoin R s) * Subalgebra.toSubmodule (adjoin R t) := by\n  rw [adjoin_eq_span, adjoin_eq_span, adjoin_eq_span, span_mul_span]\n  congr 1 with z; simp [Submonoid.closure_union, Submonoid.mem_sup, Set.mem_mul]\n\n"}
{"name":"Algebra.pow_smul_mem_of_smul_subset_of_mem_adjoin","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring A\ninst✝⁴ : Algebra R A\ninst✝³ : CommSemiring B\ninst✝² : Algebra R B\ninst✝¹ : Algebra A B\ninst✝ : IsScalarTower R A B\nr : A\ns : Set B\nB' : Subalgebra R B\nhs : HasSubset.Subset (HSMul.hSMul r s) ↑B'\nx : B\nhx : Membership.mem (Algebra.adjoin R s) x\nhr : Membership.mem B' ((algebraMap A B) r)\n⊢ Exists fun n₀ => ∀ (n : Nat), GE.ge n n₀ → Membership.mem B' (HSMul.hSMul (HPow.hPow r n) x)","decl":"theorem pow_smul_mem_of_smul_subset_of_mem_adjoin [CommSemiring B] [Algebra R B] [Algebra A B]\n    [IsScalarTower R A B] (r : A) (s : Set B) (B' : Subalgebra R B) (hs : r • s ⊆ B') {x : B}\n    (hx : x ∈ adjoin R s) (hr : algebraMap A B r ∈ B') : ∃ n₀ : ℕ, ∀ n ≥ n₀, r ^ n • x ∈ B' := by\n  change x ∈ Subalgebra.toSubmodule (adjoin R s) at hx\n  rw [adjoin_eq_span, Finsupp.mem_span_iff_linearCombination] at hx\n  rcases hx with ⟨l, rfl : (l.sum fun (i : Submonoid.closure s) (c : R) => c • (i : B)) = x⟩\n  choose n₁ n₂ using fun x : Submonoid.closure s => Submonoid.pow_smul_mem_closure_smul r s x.prop\n  use l.support.sup n₁\n  intro n hn\n  rw [Finsupp.smul_sum]\n  refine B'.toSubmodule.sum_mem ?_\n  intro a ha\n  have : n ≥ n₁ a := le_trans (Finset.le_sup ha) hn\n  dsimp only\n  rw [← tsub_add_cancel_of_le this, pow_add, ← smul_smul, ←\n    IsScalarTower.algebraMap_smul A (l a) (a : B), smul_smul (r ^ n₁ a), mul_comm, ← smul_smul,\n    smul_def, map_pow, IsScalarTower.algebraMap_smul]\n  apply Subalgebra.mul_mem _ (Subalgebra.pow_mem _ hr _) _\n  refine Subalgebra.smul_mem _ ?_ _\n  change _ ∈ B'.toSubmonoid\n  rw [← Submonoid.closure_eq B'.toSubmonoid]\n  apply Submonoid.closure_mono hs (n₂ a)\n\n"}
{"name":"Algebra.pow_smul_mem_adjoin_smul","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring A\ninst✝ : Algebra R A\nr : R\ns : Set A\nx : A\nhx : Membership.mem (Algebra.adjoin R s) x\n⊢ Exists fun n₀ => ∀ (n : Nat), GE.ge n n₀ → Membership.mem (Algebra.adjoin R (HSMul.hSMul r s)) (HSMul.hSMul (HPow.hPow r n) x)","decl":"theorem pow_smul_mem_adjoin_smul (r : R) (s : Set A) {x : A} (hx : x ∈ adjoin R s) :\n    ∃ n₀ : ℕ, ∀ n ≥ n₀, r ^ n • x ∈ adjoin R (r • s) :=\n  pow_smul_mem_of_smul_subset_of_mem_adjoin r s _ subset_adjoin hx (Subalgebra.algebraMap_mem _ _)\n\n"}
{"name":"Algebra.adjoin_nonUnitalSubalgebra_eq_span","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring A\ninst✝ : Algebra R A\ns : NonUnitalSubalgebra R A\n⊢ Eq (Subalgebra.toSubmodule (Algebra.adjoin R ↑s)) (Max.max (Submodule.span R (Singleton.singleton 1)) s.toSubmodule)","decl":"lemma adjoin_nonUnitalSubalgebra_eq_span (s : NonUnitalSubalgebra R A) :\n    Subalgebra.toSubmodule (adjoin R (s : Set A)) = span R {1} ⊔ s.toSubmodule := by\n  rw [adjoin_eq_span, Submonoid.closure_eq_one_union, span_union, ← NonUnitalAlgebra.adjoin_eq_span,\n      NonUnitalAlgebra.adjoin_eq]\n\n"}
{"name":"Algebra.mem_adjoin_iff","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\ns : Set A\nx : A\n⊢ Iff (Membership.mem (Algebra.adjoin R s) x) (Membership.mem (Subring.closure (Union.union (Set.range ⇑(algebraMap R A)) s)) x)","decl":"theorem mem_adjoin_iff {s : Set A} {x : A} :\n    x ∈ adjoin R s ↔ x ∈ Subring.closure (Set.range (algebraMap R A) ∪ s) :=\n  ⟨fun hx =>\n    Subsemiring.closure_induction Subring.subset_closure (Subring.zero_mem _) (Subring.one_mem _)\n      (fun _ _ _ _ => Subring.add_mem _) (fun _ _ _ _ => Subring.mul_mem _) hx,\n    suffices Subring.closure (Set.range (algebraMap R A) ∪ s) ≤ (adjoin R s).toSubring\n      from (show (_ : Set A) ⊆ _ from this) (a := x)\n    -- Porting note: Lean doesn't seem to recognize the defeq between the order on subobjects and\n    -- subsets of their coercions to sets as easily as in Lean 3\n    Subring.closure_le.2 Subsemiring.subset_closure⟩\n\n"}
{"name":"Algebra.adjoin_eq_ring_closure","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\ns : Set A\n⊢ Eq (Algebra.adjoin R s).toSubring (Subring.closure (Union.union (Set.range ⇑(algebraMap R A)) s))","decl":"theorem adjoin_eq_ring_closure (s : Set A) :\n    (adjoin R s).toSubring = Subring.closure (Set.range (algebraMap R A) ∪ s) :=\n  Subring.ext fun _x => mem_adjoin_iff\n\n"}
{"name":"AlgHom.map_adjoin","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nφ : AlgHom R A B\ns : Set A\n⊢ Eq (Subalgebra.map φ (Algebra.adjoin R s)) (Algebra.adjoin R (Set.image (⇑φ) s))","decl":"theorem map_adjoin (φ : A →ₐ[R] B) (s : Set A) : (adjoin R s).map φ = adjoin R (φ '' s) :=\n  (adjoin_image _ _ _).symm\n\n"}
{"name":"AlgHom.map_adjoin_singleton","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\ne : AlgHom R A B\nx : A\n⊢ Eq (Subalgebra.map e (Algebra.adjoin R (Singleton.singleton x))) (Algebra.adjoin R (Singleton.singleton (e x)))","decl":"@[simp]\ntheorem map_adjoin_singleton (e : A →ₐ[R] B) (x : A) :\n    (adjoin R {x}).map e = adjoin R {e x} := by\n  rw [map_adjoin, Set.image_singleton]\n\n"}
{"name":"AlgHom.adjoin_le_equalizer","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nφ₁ φ₂ : AlgHom R A B\ns : Set A\nh : Set.EqOn (⇑φ₁) (⇑φ₂) s\n⊢ LE.le (Algebra.adjoin R s) (AlgHom.equalizer φ₁ φ₂)","decl":"theorem adjoin_le_equalizer (φ₁ φ₂ : A →ₐ[R] B) {s : Set A} (h : s.EqOn φ₁ φ₂) :\n    adjoin R s ≤ equalizer φ₁ φ₂ :=\n  adjoin_le h\n\n"}
{"name":"AlgHom.ext_of_adjoin_eq_top","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\ns : Set A\nh : Eq (Algebra.adjoin R s) Top.top\nφ₁ φ₂ : AlgHom R A B\nhs : Set.EqOn (⇑φ₁) (⇑φ₂) s\n⊢ Eq φ₁ φ₂","decl":"theorem ext_of_adjoin_eq_top {s : Set A} (h : adjoin R s = ⊤) ⦃φ₁ φ₂ : A →ₐ[R] B⦄\n    (hs : s.EqOn φ₁ φ₂) : φ₁ = φ₂ :=\n  ext fun _x => adjoin_le_equalizer φ₁ φ₂ hs <| h.symm ▸ trivial\n\n"}
{"name":"AlgHom.eqOn_adjoin_iff","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nφ ψ : AlgHom R A B\ns : Set A\n⊢ Iff (Set.EqOn ⇑φ ⇑ψ ↑(Algebra.adjoin R s)) (Set.EqOn (⇑φ) (⇑ψ) s)","decl":"/-- Two algebra morphisms are equal on `Algebra.span s`iff they are equal on s -/\ntheorem eqOn_adjoin_iff {φ ψ : A →ₐ[R] B} {s : Set A}  :\n    Set.EqOn φ ψ (adjoin R s) ↔ Set.EqOn φ ψ s := by\n  have (S : Set A) : S ≤ equalizer φ ψ ↔ Set.EqOn φ ψ S := Iff.rfl\n  simp only [← this, Set.le_eq_subset, SetLike.coe_subset_coe, adjoin_le_iff]\n\n"}
{"name":"AlgHom.adjoin_ext","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\ns : Set A\nφ₁ φ₂ : AlgHom R (Subtype fun x => Membership.mem (Algebra.adjoin R s) x) B\nh : ∀ (x : A) (hx : Membership.mem s x), Eq (φ₁ ⟨x, ⋯⟩) (φ₂ ⟨x, ⋯⟩)\n⊢ Eq φ₁ φ₂","decl":"theorem adjoin_ext {s : Set A} ⦃φ₁ φ₂ : adjoin R s →ₐ[R] B⦄\n    (h : ∀ x hx, φ₁ ⟨x, subset_adjoin hx⟩ = φ₂ ⟨x, subset_adjoin hx⟩) : φ₁ = φ₂ :=\n  ext fun ⟨x, hx⟩ ↦ adjoin_induction h (fun _ ↦ φ₂.commutes _ ▸ φ₁.commutes _)\n    (fun _ _ _ _ h₁ h₂ ↦ by convert congr_arg₂ (· + ·) h₁ h₂ <;> rw [← map_add] <;> rfl)\n    (fun _ _ _ _ h₁ h₂ ↦ by convert congr_arg₂ (· * ·) h₁ h₂ <;> rw [← map_mul] <;> rfl) hx\n\n"}
{"name":"AlgHom.ext_of_eq_adjoin","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nS : Subalgebra R A\ns : Set A\nhS : Eq S (Algebra.adjoin R s)\nφ₁ φ₂ : AlgHom R (Subtype fun x => Membership.mem S x) B\nh : ∀ (x : A) (hx : Membership.mem s x), Eq (φ₁ ⟨x, ⋯⟩) (φ₂ ⟨x, ⋯⟩)\n⊢ Eq φ₁ φ₂","decl":"theorem ext_of_eq_adjoin {S : Subalgebra R A} {s : Set A} (hS : S = adjoin R s) ⦃φ₁ φ₂ : S →ₐ[R] B⦄\n    (h : ∀ x hx, φ₁ ⟨x, hS.ge (subset_adjoin hx)⟩ = φ₂ ⟨x, hS.ge (subset_adjoin hx)⟩) :\n    φ₁ = φ₂ := by\n  subst hS; exact adjoin_ext h\n\n"}
{"name":"Algebra.adjoin_nat","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\ns : Set R\n⊢ Eq (Algebra.adjoin Nat s) (subalgebraOfSubsemiring (Subsemiring.closure s))","decl":"theorem Algebra.adjoin_nat {R : Type*} [Semiring R] (s : Set R) :\n    adjoin ℕ s = subalgebraOfSubsemiring (Subsemiring.closure s) :=\n  le_antisymm (adjoin_le Subsemiring.subset_closure)\n    (Subsemiring.closure_le.2 subset_adjoin : Subsemiring.closure s ≤ (adjoin ℕ s).toSubsemiring)\n\n"}
{"name":"Algebra.adjoin_int","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type u_1\ninst✝ : Ring R\ns : Set R\n⊢ Eq (Algebra.adjoin Int s) (subalgebraOfSubring (Subring.closure s))","decl":"theorem Algebra.adjoin_int {R : Type*} [Ring R] (s : Set R) :\n    adjoin ℤ s = subalgebraOfSubring (Subring.closure s) :=\n  le_antisymm (adjoin_le Subring.subset_closure)\n    (Subring.closure_le.2 subset_adjoin : Subring.closure s ≤ (adjoin ℤ s).toSubring)\n\n"}
{"name":"Submonoid.adjoin_eq_span_of_eq_span","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁶ : CommSemiring E\ninst✝⁵ : Semiring K\ninst✝⁴ : SMul F E\ninst✝³ : Algebra E K\ninst✝² : Semiring F\ninst✝¹ : Module F K\ninst✝ : IsScalarTower F E K\nL : Submonoid K\nS : Set K\nh : Eq ↑L ↑(Submodule.span F S)\n⊢ Eq (Subalgebra.toSubmodule (Algebra.adjoin E ↑L)) (Submodule.span E S)","decl":"/-- If `K / E / F` is a ring extension tower, `L` is a submonoid of `K / F` which is generated by\n`S` as an `F`-module, then `E[L]` is generated by `S` as an `E`-module. -/\ntheorem Submonoid.adjoin_eq_span_of_eq_span [Semiring F] [Module F K] [IsScalarTower F E K]\n    (L : Submonoid K) {S : Set K} (h : (L : Set K) = span F S) :\n    toSubmodule (adjoin E (L : Set K)) = span E S := by\n  rw [adjoin_eq_span, L.closure_eq, h]\n  exact (span_le.mpr <| span_subset_span _ _ _).antisymm (span_mono subset_span)\n\n"}
{"name":"Subalgebra.adjoin_eq_span_of_eq_span","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁶ : CommSemiring E\ninst✝⁵ : Semiring K\ninst✝⁴ : SMul F E\ninst✝³ : Algebra E K\ninst✝² : CommSemiring F\ninst✝¹ : Algebra F K\ninst✝ : IsScalarTower F E K\nL : Subalgebra F K\nS : Set K\nh : Eq (Subalgebra.toSubmodule L) (Submodule.span F S)\n⊢ Eq (Subalgebra.toSubmodule (Algebra.adjoin E ↑L)) (Submodule.span E S)","decl":"/-- If `K / E / F` is a ring extension tower, `L` is a subalgebra of `K / F` which is generated by\n`S` as an `F`-module, then `E[L]` is generated by `S` as an `E`-module. -/\ntheorem Subalgebra.adjoin_eq_span_of_eq_span {S : Set K} (h : toSubmodule L = span F S) :\n    toSubmodule (adjoin E (L : Set K)) = span E S :=\n  L.toSubmonoid.adjoin_eq_span_of_eq_span F E (congr_arg ((↑) : _ → Set K) h)\n\n"}
{"name":"Subalgebra.adjoin_eq_span_basis","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁶ : CommSemiring E\ninst✝⁵ : Semiring K\ninst✝⁴ : SMul F E\ninst✝³ : Algebra E K\ninst✝² : CommSemiring F\ninst✝¹ : Algebra F K\ninst✝ : IsScalarTower F E K\nL : Subalgebra F K\nι : Type u_4\nbL : Basis ι F (Subtype fun x => Membership.mem L x)\n⊢ Eq (Subalgebra.toSubmodule (Algebra.adjoin E ↑L)) (Submodule.span E (Set.range fun i => ↑(bL i)))","decl":"/-- If `K / E / F` is a ring extension tower, `L` is a subalgebra of `K / F`,\nthen `E[L]` is generated by any basis of `L / F` as an `E`-module. -/\ntheorem Subalgebra.adjoin_eq_span_basis {ι : Type*} (bL : Basis ι F L) :\n    toSubmodule (adjoin E (L : Set K)) = span E (Set.range fun i : ι ↦ (bL i).1) :=\n  L.adjoin_eq_span_of_eq_span E <| by\n    simpa only [← L.range_val, Submodule.map_span, Submodule.map_top, ← Set.range_comp]\n      using congr_arg (Submodule.map L.val) bL.span_eq.symm\n\n"}
{"name":"Algebra.restrictScalars_adjoin","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"F : Type u_4\ninst✝² : CommSemiring F\nE : Type u_5\ninst✝¹ : CommSemiring E\ninst✝ : Algebra F E\nK : Subalgebra F E\nS : Set E\n⊢ Eq (Subalgebra.restrictScalars F (Algebra.adjoin (Subtype fun x => Membership.mem K x) S)) (Algebra.adjoin F (Union.union (↑K) S))","decl":"theorem Algebra.restrictScalars_adjoin (F : Type*) [CommSemiring F] {E : Type*} [CommSemiring E]\n    [Algebra F E] (K : Subalgebra F E) (S : Set E) :\n    (Algebra.adjoin K S).restrictScalars F = Algebra.adjoin F (K ∪ S) := by\n  conv_lhs => rw [← Algebra.adjoin_eq K, ← Algebra.adjoin_union_eq_adjoin_adjoin]\n\n"}
{"name":"Algebra.restrictScalars_adjoin_of_algEquiv","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"F : Type u_4\nE : Type u_5\nL : Type u_6\nL' : Type u_7\ninst✝¹⁰ : CommSemiring F\ninst✝⁹ : CommSemiring L\ninst✝⁸ : CommSemiring L'\ninst✝⁷ : Semiring E\ninst✝⁶ : Algebra F L\ninst✝⁵ : Algebra L E\ninst✝⁴ : Algebra F L'\ninst✝³ : Algebra L' E\ninst✝² : Algebra F E\ninst✝¹ : IsScalarTower F L E\ninst✝ : IsScalarTower F L' E\ni : AlgEquiv F L L'\nhi : Eq (⇑(algebraMap L E)) (Function.comp ⇑(algebraMap L' E) ⇑i)\nS : Set E\n⊢ Eq (Subalgebra.restrictScalars F (Algebra.adjoin L S)) (Subalgebra.restrictScalars F (Algebra.adjoin L' S))","decl":"/-- If `E / L / F` and `E / L' / F` are two ring extension towers, `L ≃ₐ[F] L'` is an isomorphism\ncompatible with `E / L` and `E / L'`, then for any subset `S` of `E`, `L[S]` and `L'[S]` are\nequal as subalgebras of `E / F`. -/\ntheorem Algebra.restrictScalars_adjoin_of_algEquiv\n    {F E L L' : Type*} [CommSemiring F] [CommSemiring L] [CommSemiring L'] [Semiring E]\n    [Algebra F L] [Algebra L E] [Algebra F L'] [Algebra L' E] [Algebra F E]\n    [IsScalarTower F L E] [IsScalarTower F L' E] (i : L ≃ₐ[F] L')\n    (hi : algebraMap L E = (algebraMap L' E) ∘ i) (S : Set E) :\n    (Algebra.adjoin L S).restrictScalars F = (Algebra.adjoin L' S).restrictScalars F := by\n  apply_fun Subalgebra.toSubsemiring using fun K K' h ↦ by rwa [SetLike.ext'_iff] at h ⊢\n  change Subsemiring.closure _ = Subsemiring.closure _\n  erw [hi, Set.range_comp, i.toEquiv.range_eq_univ, Set.image_univ]\n\n"}
{"name":"NonUnitalAlgebra.adjoin_le_algebra_adjoin","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\ns : Set A\n⊢ LE.le (NonUnitalAlgebra.adjoin R s) (Algebra.adjoin R s).toNonUnitalSubalgebra","decl":"lemma NonUnitalAlgebra.adjoin_le_algebra_adjoin (s : Set A) :\n    adjoin R s ≤ (Algebra.adjoin R s).toNonUnitalSubalgebra := adjoin_le Algebra.subset_adjoin\n\n"}
{"name":"Algebra.adjoin_nonUnitalSubalgebra","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\ns : Set A\n⊢ Eq (Algebra.adjoin R ↑(NonUnitalAlgebra.adjoin R s)) (Algebra.adjoin R s)","decl":"lemma Algebra.adjoin_nonUnitalSubalgebra (s : Set A) :\n    adjoin R (NonUnitalAlgebra.adjoin R s : Set A) = adjoin R s :=\n  le_antisymm\n    (adjoin_le <| NonUnitalAlgebra.adjoin_le_algebra_adjoin R s)\n    (adjoin_le <| (NonUnitalAlgebra.subset_adjoin R).trans subset_adjoin)\n\n"}
{"name":"Subalgebra.comap_map_eq","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : Ring A\ninst✝² : Algebra R A\ninst✝¹ : Ring B\ninst✝ : Algebra R B\nf : AlgHom R A B\nS : Subalgebra R A\n⊢ Eq (Subalgebra.comap f (Subalgebra.map f S)) (Max.max S (Algebra.adjoin R (Set.preimage (⇑f) (Singleton.singleton 0))))","decl":"theorem comap_map_eq (f : A →ₐ[R] B) (S : Subalgebra R A) :\n    (S.map f).comap f = S ⊔ Algebra.adjoin R (f ⁻¹' {0}) := by\n  apply le_antisymm\n  · intro x hx\n    rw [mem_comap, mem_map] at hx\n    obtain ⟨y, hy, hxy⟩ := hx\n    replace hxy : x - y ∈ f ⁻¹' {0} := by simp [hxy]\n    rw [← Algebra.adjoin_eq S, ← Algebra.adjoin_union, ← add_sub_cancel y x]\n    exact Subalgebra.add_mem _\n      (Algebra.subset_adjoin <| Or.inl hy) (Algebra.subset_adjoin <| Or.inr hxy)\n  · rw [← map_le, Algebra.map_sup, f.map_adjoin]\n    apply le_of_eq\n    rw [sup_eq_left, Algebra.adjoin_le_iff]\n    exact (Set.image_preimage_subset f {0}).trans (Set.singleton_subset_iff.2 (S.map f).zero_mem)\n\n"}
{"name":"Subalgebra.comap_map_eq_self","module":"Mathlib.RingTheory.Adjoin.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : Ring A\ninst✝² : Algebra R A\ninst✝¹ : Ring B\ninst✝ : Algebra R B\nf : AlgHom R A B\nS : Subalgebra R A\nh : HasSubset.Subset (Set.preimage (⇑f) (Singleton.singleton 0)) ↑S\n⊢ Eq (Subalgebra.comap f (Subalgebra.map f S)) S","decl":"theorem comap_map_eq_self {f : A →ₐ[R] B} {S : Subalgebra R A}\n    (h : f ⁻¹' {0} ⊆ S) : (S.map f).comap f = S := by\n  convert comap_map_eq f S\n  rwa [left_eq_sup, Algebra.adjoin_le_iff]\n\n"}
