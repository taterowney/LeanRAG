{"name":"ZSpan.span_top","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\nK : Type u_3\ninst✝² : NormedLinearOrderedField K\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace K E\nb : Basis ι K E\n⊢ Eq (Submodule.span K ↑(Submodule.span Int (Set.range ⇑b))) Top.top","decl":"theorem span_top : span K (span ℤ (Set.range b) : Set E) = ⊤ := by simp [span_span_of_tower]\n\n"}
{"name":"ZSpan.map","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\nK : Type u_3\ninst✝⁴ : NormedLinearOrderedField K\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace K E\nb : Basis ι K E\nF : Type u_4\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace K F\nf : LinearEquiv (RingHom.id K) E F\n⊢ Eq (Submodule.map (LinearEquiv.restrictScalars Int f) (Submodule.span Int (Set.range ⇑b))) (Submodule.span Int (Set.range ⇑(b.map f)))","decl":"theorem map {F : Type*} [NormedAddCommGroup F] [NormedSpace K F] (f : E ≃ₗ[K] F) :\n    Submodule.map (f.restrictScalars ℤ) (span ℤ (Set.range b)) = span ℤ (Set.range (b.map f)) := by\n  simp_rw [Submodule.map_span, LinearEquiv.restrictScalars_apply, Basis.coe_map, Set.range_comp]\n\n"}
{"name":"ZSpan.smul","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\nK : Type u_3\ninst✝² : NormedLinearOrderedField K\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace K E\nb : Basis ι K E\nc : K\nhc : Ne c 0\n⊢ Eq (HSMul.hSMul c (Submodule.span Int (Set.range ⇑b))) (Submodule.span Int (Set.range ⇑(b.isUnitSMul ⋯)))","decl":"open scoped Pointwise in\ntheorem smul {c : K} (hc : c ≠ 0) :\n    c • span ℤ (Set.range b) = span ℤ (Set.range (b.isUnitSMul (fun _ ↦ hc.isUnit))) := by\n  rw [smul_span, Set.smul_set_range]\n  congr!\n  rw [Basis.isUnitSMul_apply]\n\n"}
{"name":"ZSpan.mem_fundamentalDomain","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\nK : Type u_3\ninst✝² : NormedLinearOrderedField K\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace K E\nb : Basis ι K E\nm : E\n⊢ Iff (Membership.mem (ZSpan.fundamentalDomain b) m) (∀ (i : ι), Membership.mem (Set.Ico 0 1) ((b.repr m) i))","decl":"@[simp]\ntheorem mem_fundamentalDomain {m : E} :\n    m ∈ fundamentalDomain b ↔ ∀ i, b.repr m i ∈ Set.Ico (0 : K) 1 := Iff.rfl\n\n"}
{"name":"ZSpan.map_fundamentalDomain","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\nK : Type u_3\ninst✝⁴ : NormedLinearOrderedField K\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace K E\nb : Basis ι K E\nF : Type u_4\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace K F\nf : LinearEquiv (RingHom.id K) E F\n⊢ Eq (Set.image (⇑f) (ZSpan.fundamentalDomain b)) (ZSpan.fundamentalDomain (b.map f))","decl":"theorem map_fundamentalDomain {F : Type*} [NormedAddCommGroup F] [NormedSpace K F] (f : E ≃ₗ[K] F) :\n    f '' (fundamentalDomain b) = fundamentalDomain (b.map f) := by\n  ext x\n  rw [mem_fundamentalDomain, Basis.map_repr, LinearEquiv.trans_apply, ← mem_fundamentalDomain,\n    show f.symm x = f.toEquiv.symm x by rfl, ← Set.mem_image_equiv]\n  rfl\n\n"}
{"name":"ZSpan.fundamentalDomain_reindex","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\nK : Type u_3\ninst✝² : NormedLinearOrderedField K\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace K E\nb : Basis ι K E\nι' : Type u_4\ne : Equiv ι ι'\n⊢ Eq (ZSpan.fundamentalDomain (b.reindex e)) (ZSpan.fundamentalDomain b)","decl":"@[simp]\ntheorem fundamentalDomain_reindex {ι' : Type*} (e : ι ≃ ι') :\n    fundamentalDomain (b.reindex e) = fundamentalDomain b := by\n  ext\n  simp_rw [mem_fundamentalDomain, Basis.repr_reindex_apply]\n  rw [Equiv.forall_congr' e]\n  simp_rw [implies_true]\n\n"}
{"name":"ZSpan.fundamentalDomain_pi_basisFun","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"ι : Type u_2\ninst✝ : Fintype ι\n⊢ Eq (ZSpan.fundamentalDomain (Pi.basisFun Real ι)) (Set.univ.pi fun x => Set.Ico 0 1)","decl":"lemma fundamentalDomain_pi_basisFun [Fintype ι] :\n    fundamentalDomain (Pi.basisFun ℝ ι) = Set.pi Set.univ fun _ : ι ↦ Set.Ico (0 : ℝ) 1 := by\n  ext; simp\n\n"}
{"name":"ZSpan.repr_floor_apply","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\nK : Type u_3\ninst✝⁴ : NormedLinearOrderedField K\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace K E\nb : Basis ι K E\ninst✝¹ : FloorRing K\ninst✝ : Fintype ι\nm : E\ni : ι\n⊢ Eq ((b.repr ↑(ZSpan.floor b m)) i) ↑(Int.floor ((b.repr m) i))","decl":"@[simp]\ntheorem repr_floor_apply (m : E) (i : ι) : b.repr (floor b m) i = ⌊b.repr m i⌋ := by\n  classical simp only [floor, ← Int.cast_smul_eq_zsmul K, b.repr.map_smul, Finsupp.single_apply,\n    Finset.sum_apply', Basis.repr_self, Finsupp.smul_single', mul_one, Finset.sum_ite_eq', coe_sum,\n    Finset.mem_univ, if_true, coe_smul_of_tower, Basis.restrictScalars_apply, map_sum]\n\n"}
{"name":"ZSpan.repr_ceil_apply","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\nK : Type u_3\ninst✝⁴ : NormedLinearOrderedField K\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace K E\nb : Basis ι K E\ninst✝¹ : FloorRing K\ninst✝ : Fintype ι\nm : E\ni : ι\n⊢ Eq ((b.repr ↑(ZSpan.ceil b m)) i) ↑(Int.ceil ((b.repr m) i))","decl":"@[simp]\ntheorem repr_ceil_apply (m : E) (i : ι) : b.repr (ceil b m) i = ⌈b.repr m i⌉ := by\n  classical simp only [ceil, ← Int.cast_smul_eq_zsmul K, b.repr.map_smul, Finsupp.single_apply,\n    Finset.sum_apply', Basis.repr_self, Finsupp.smul_single', mul_one, Finset.sum_ite_eq', coe_sum,\n    Finset.mem_univ, if_true, coe_smul_of_tower, Basis.restrictScalars_apply, map_sum]\n\n"}
{"name":"ZSpan.floor_eq_self_of_mem","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\nK : Type u_3\ninst✝⁴ : NormedLinearOrderedField K\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace K E\nb : Basis ι K E\ninst✝¹ : FloorRing K\ninst✝ : Fintype ι\nm : E\nh : Membership.mem (Submodule.span Int (Set.range ⇑b)) m\n⊢ Eq (↑(ZSpan.floor b m)) m","decl":"@[simp]\ntheorem floor_eq_self_of_mem (m : E) (h : m ∈ span ℤ (Set.range b)) : (floor b m : E) = m := by\n  apply b.ext_elem\n  simp_rw [repr_floor_apply b]\n  intro i\n  obtain ⟨z, hz⟩ := (b.mem_span_iff_repr_mem ℤ _).mp h i\n  rw [← hz]\n  exact congr_arg (Int.cast : ℤ → K) (Int.floor_intCast z)\n\n"}
{"name":"ZSpan.ceil_eq_self_of_mem","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\nK : Type u_3\ninst✝⁴ : NormedLinearOrderedField K\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace K E\nb : Basis ι K E\ninst✝¹ : FloorRing K\ninst✝ : Fintype ι\nm : E\nh : Membership.mem (Submodule.span Int (Set.range ⇑b)) m\n⊢ Eq (↑(ZSpan.ceil b m)) m","decl":"@[simp]\ntheorem ceil_eq_self_of_mem (m : E) (h : m ∈ span ℤ (Set.range b)) : (ceil b m : E) = m := by\n  apply b.ext_elem\n  simp_rw [repr_ceil_apply b]\n  intro i\n  obtain ⟨z, hz⟩ := (b.mem_span_iff_repr_mem ℤ _).mp h i\n  rw [← hz]\n  exact congr_arg (Int.cast : ℤ → K) (Int.ceil_intCast z)\n\n"}
{"name":"ZSpan.fract_apply","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\nK : Type u_3\ninst✝⁴ : NormedLinearOrderedField K\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace K E\nb : Basis ι K E\ninst✝¹ : FloorRing K\ninst✝ : Fintype ι\nm : E\n⊢ Eq (ZSpan.fract b m) (HSub.hSub m ↑(ZSpan.floor b m))","decl":"theorem fract_apply (m : E) : fract b m = m - floor b m := rfl\n\n"}
{"name":"ZSpan.repr_fract_apply","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\nK : Type u_3\ninst✝⁴ : NormedLinearOrderedField K\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace K E\nb : Basis ι K E\ninst✝¹ : FloorRing K\ninst✝ : Fintype ι\nm : E\ni : ι\n⊢ Eq ((b.repr (ZSpan.fract b m)) i) (Int.fract ((b.repr m) i))","decl":"@[simp]\ntheorem repr_fract_apply (m : E) (i : ι) : b.repr (fract b m) i = Int.fract (b.repr m i) := by\n  rw [fract, map_sub, Finsupp.coe_sub, Pi.sub_apply, repr_floor_apply, Int.fract]\n\n"}
{"name":"ZSpan.fract_fract","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\nK : Type u_3\ninst✝⁴ : NormedLinearOrderedField K\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace K E\nb : Basis ι K E\ninst✝¹ : FloorRing K\ninst✝ : Fintype ι\nm : E\n⊢ Eq (ZSpan.fract b (ZSpan.fract b m)) (ZSpan.fract b m)","decl":"@[simp]\ntheorem fract_fract (m : E) : fract b (fract b m) = fract b m :=\n  Basis.ext_elem b fun _ => by classical simp only [repr_fract_apply, Int.fract_fract]\n\n"}
{"name":"ZSpan.fract_zSpan_add","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\nK : Type u_3\ninst✝⁴ : NormedLinearOrderedField K\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace K E\nb : Basis ι K E\ninst✝¹ : FloorRing K\ninst✝ : Fintype ι\nm v : E\nh : Membership.mem (Submodule.span Int (Set.range ⇑b)) v\n⊢ Eq (ZSpan.fract b (HAdd.hAdd v m)) (ZSpan.fract b m)","decl":"@[simp]\ntheorem fract_zSpan_add (m : E) {v : E} (h : v ∈ span ℤ (Set.range b)) :\n    fract b (v + m) = fract b m := by\n  classical\n  refine (Basis.ext_elem_iff b).mpr fun i => ?_\n  simp_rw [repr_fract_apply, Int.fract_eq_fract]\n  use (b.restrictScalars ℤ).repr ⟨v, h⟩ i\n  rw [map_add, Finsupp.coe_add, Pi.add_apply, add_tsub_cancel_right,\n    ← eq_intCast (algebraMap ℤ K) _, Basis.restrictScalars_repr_apply, coe_mk]\n\n"}
{"name":"ZSpan.fract_add_ZSpan","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\nK : Type u_3\ninst✝⁴ : NormedLinearOrderedField K\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace K E\nb : Basis ι K E\ninst✝¹ : FloorRing K\ninst✝ : Fintype ι\nm v : E\nh : Membership.mem (Submodule.span Int (Set.range ⇑b)) v\n⊢ Eq (ZSpan.fract b (HAdd.hAdd m v)) (ZSpan.fract b m)","decl":"@[simp]\ntheorem fract_add_ZSpan (m : E) {v : E} (h : v ∈ span ℤ (Set.range b)) :\n    fract b (m + v) = fract b m := by rw [add_comm, fract_zSpan_add b m h]\n\n"}
{"name":"ZSpan.fract_eq_self","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\nK : Type u_3\ninst✝⁴ : NormedLinearOrderedField K\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace K E\nb : Basis ι K E\ninst✝¹ : FloorRing K\ninst✝ : Fintype ι\nx : E\n⊢ Iff (Eq (ZSpan.fract b x) x) (Membership.mem (ZSpan.fundamentalDomain b) x)","decl":"theorem fract_eq_self {x : E} : fract b x = x ↔ x ∈ fundamentalDomain b := by\n  classical simp only [Basis.ext_elem_iff b, repr_fract_apply, Int.fract_eq_self,\n    mem_fundamentalDomain, Set.mem_Ico]\n\n"}
{"name":"ZSpan.fract_mem_fundamentalDomain","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\nK : Type u_3\ninst✝⁴ : NormedLinearOrderedField K\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace K E\nb : Basis ι K E\ninst✝¹ : FloorRing K\ninst✝ : Fintype ι\nx : E\n⊢ Membership.mem (ZSpan.fundamentalDomain b) (ZSpan.fract b x)","decl":"theorem fract_mem_fundamentalDomain (x : E) : fract b x ∈ fundamentalDomain b :=\n  fract_eq_self.mp (fract_fract b _)\n\n"}
{"name":"ZSpan.fractRestrict_surjective","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\nK : Type u_3\ninst✝⁴ : NormedLinearOrderedField K\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace K E\nb : Basis ι K E\ninst✝¹ : FloorRing K\ninst✝ : Fintype ι\n⊢ Function.Surjective (ZSpan.fractRestrict b)","decl":"theorem fractRestrict_surjective : Function.Surjective (fractRestrict b) :=\n  fun x => ⟨↑x, Subtype.eq (fract_eq_self.mpr (Subtype.mem x))⟩\n\n"}
{"name":"ZSpan.fractRestrict_apply","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\nK : Type u_3\ninst✝⁴ : NormedLinearOrderedField K\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace K E\nb : Basis ι K E\ninst✝¹ : FloorRing K\ninst✝ : Fintype ι\nx : E\n⊢ Eq (↑(ZSpan.fractRestrict b x)) (ZSpan.fract b x)","decl":"@[simp]\ntheorem fractRestrict_apply (x : E) : (fractRestrict b x : E) = fract b x := rfl\n\n"}
{"name":"ZSpan.fract_eq_fract","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\nK : Type u_3\ninst✝⁴ : NormedLinearOrderedField K\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace K E\nb : Basis ι K E\ninst✝¹ : FloorRing K\ninst✝ : Fintype ι\nm n : E\n⊢ Iff (Eq (ZSpan.fract b m) (ZSpan.fract b n)) (Membership.mem (Submodule.span Int (Set.range ⇑b)) (HAdd.hAdd (Neg.neg m) n))","decl":"theorem fract_eq_fract (m n : E) : fract b m = fract b n ↔ -m + n ∈ span ℤ (Set.range b) := by\n  classical\n  rw [eq_comm, Basis.ext_elem_iff b]\n  simp_rw [repr_fract_apply, Int.fract_eq_fract, eq_comm, Basis.mem_span_iff_repr_mem,\n    sub_eq_neg_add, map_add, map_neg, Finsupp.coe_add, Finsupp.coe_neg, Pi.add_apply,\n    Pi.neg_apply, ← eq_intCast (algebraMap ℤ K) _, Set.mem_range]\n\n"}
{"name":"ZSpan.norm_fract_le","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\nK : Type u_3\ninst✝⁵ : NormedLinearOrderedField K\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace K E\nb : Basis ι K E\ninst✝² : FloorRing K\ninst✝¹ : Fintype ι\ninst✝ : HasSolidNorm K\nm : E\n⊢ LE.le (Norm.norm (ZSpan.fract b m)) (Finset.univ.sum fun i => Norm.norm (b i))","decl":"theorem norm_fract_le [HasSolidNorm K] (m : E) : ‖fract b m‖ ≤ ∑ i, ‖b i‖ := by\n  classical\n  calc\n    ‖fract b m‖ = ‖∑ i, b.repr (fract b m) i • b i‖ := by rw [b.sum_repr]\n    _ = ‖∑ i, Int.fract (b.repr m i) • b i‖ := by simp_rw [repr_fract_apply]\n    _ ≤ ∑ i, ‖Int.fract (b.repr m i) • b i‖ := norm_sum_le _ _\n    _ = ∑ i, ‖Int.fract (b.repr m i)‖ * ‖b i‖ := by simp_rw [norm_smul]\n    _ ≤ ∑ i, ‖b i‖ := Finset.sum_le_sum fun i _ => ?_\n  suffices ‖Int.fract ((b.repr m) i)‖ ≤ 1 by\n    convert mul_le_mul_of_nonneg_right this (norm_nonneg _ : 0 ≤ ‖b i‖)\n    exact (one_mul _).symm\n  rw [(norm_one.symm : 1 = ‖(1 : K)‖)]\n  apply norm_le_norm_of_abs_le_abs\n  rw [abs_one, Int.abs_fract]\n  exact le_of_lt (Int.fract_lt_one _)\n\n"}
{"name":"ZSpan.coe_floor_self","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"ι : Type u_2\nK : Type u_3\ninst✝³ : NormedLinearOrderedField K\ninst✝² : FloorRing K\ninst✝¹ : Fintype ι\ninst✝ : Unique ι\nk : K\n⊢ Eq ↑(ZSpan.floor (Basis.singleton ι K) k) ↑(Int.floor k)","decl":"@[simp]\ntheorem coe_floor_self (k : K) : (floor (Basis.singleton ι K) k : K) = ⌊k⌋ :=\n  Basis.ext_elem (Basis.singleton ι K) fun _ => by\n    rw [repr_floor_apply, Basis.singleton_repr, Basis.singleton_repr]\n\n"}
{"name":"ZSpan.coe_fract_self","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"ι : Type u_2\nK : Type u_3\ninst✝³ : NormedLinearOrderedField K\ninst✝² : FloorRing K\ninst✝¹ : Fintype ι\ninst✝ : Unique ι\nk : K\n⊢ Eq (ZSpan.fract (Basis.singleton ι K) k) (Int.fract k)","decl":"@[simp]\ntheorem coe_fract_self (k : K) : (fract (Basis.singleton ι K) k : K) = Int.fract k :=\n  Basis.ext_elem (Basis.singleton ι K) fun _ => by\n    rw [repr_fract_apply, Basis.singleton_repr, Basis.singleton_repr]\n\n"}
{"name":"ZSpan.fundamentalDomain_isBounded","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\nK : Type u_3\ninst✝⁵ : NormedLinearOrderedField K\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace K E\nb : Basis ι K E\ninst✝² : FloorRing K\ninst✝¹ : Finite ι\ninst✝ : HasSolidNorm K\n⊢ Bornology.IsBounded (ZSpan.fundamentalDomain b)","decl":"theorem fundamentalDomain_isBounded [Finite ι] [HasSolidNorm K] :\n    IsBounded (fundamentalDomain b) := by\n  cases nonempty_fintype ι\n  refine isBounded_iff_forall_norm_le.2 ⟨∑ j, ‖b j‖, fun x hx ↦ ?_⟩\n  rw [← fract_eq_self.mpr hx]\n  apply norm_fract_le\n\n"}
{"name":"ZSpan.vadd_mem_fundamentalDomain","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\nK : Type u_3\ninst✝⁴ : NormedLinearOrderedField K\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace K E\nb : Basis ι K E\ninst✝¹ : FloorRing K\ninst✝ : Fintype ι\ny : Subtype fun x => Membership.mem (Submodule.span Int (Set.range ⇑b)) x\nx : E\n⊢ Iff (Membership.mem (ZSpan.fundamentalDomain b) (HVAdd.hVAdd y x)) (Eq y (Neg.neg (ZSpan.floor b x)))","decl":"theorem vadd_mem_fundamentalDomain [Fintype ι] (y : span ℤ (Set.range b)) (x : E) :\n    y +ᵥ x ∈ fundamentalDomain b ↔ y = -floor b x := by\n  rw [Subtype.ext_iff, ← add_right_inj x, NegMemClass.coe_neg, ← sub_eq_add_neg, ← fract_apply,\n    ← fract_zSpan_add b _ (Subtype.mem y), add_comm, ← vadd_eq_add, ← vadd_def, eq_comm, ←\n    fract_eq_self]\n\n"}
{"name":"ZSpan.exist_unique_vadd_mem_fundamentalDomain","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\nK : Type u_3\ninst✝⁴ : NormedLinearOrderedField K\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace K E\nb : Basis ι K E\ninst✝¹ : FloorRing K\ninst✝ : Finite ι\nx : E\n⊢ ExistsUnique fun v => Membership.mem (ZSpan.fundamentalDomain b) (HVAdd.hVAdd v x)","decl":"theorem exist_unique_vadd_mem_fundamentalDomain [Finite ι] (x : E) :\n    ∃! v : span ℤ (Set.range b), v +ᵥ x ∈ fundamentalDomain b := by\n  cases nonempty_fintype ι\n  refine ⟨-floor b x, ?_, fun y h => ?_⟩\n  · exact (vadd_mem_fundamentalDomain b (-floor b x) x).mpr rfl\n  · exact (vadd_mem_fundamentalDomain b y x).mp h\n\n"}
{"name":"ZSpan.quotientEquiv_apply_mk","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\nK : Type u_3\ninst✝⁴ : NormedLinearOrderedField K\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace K E\nb : Basis ι K E\ninst✝¹ : FloorRing K\ninst✝ : Fintype ι\nx : E\n⊢ Eq ((ZSpan.quotientEquiv b) (Submodule.Quotient.mk x)) (ZSpan.fractRestrict b x)","decl":"@[simp]\ntheorem quotientEquiv_apply_mk [Fintype ι] (x : E) :\n    quotientEquiv b (Submodule.Quotient.mk x) = fractRestrict b x := rfl\n\n"}
{"name":"ZSpan.quotientEquiv.symm_apply","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\nK : Type u_3\ninst✝⁴ : NormedLinearOrderedField K\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace K E\nb : Basis ι K E\ninst✝¹ : FloorRing K\ninst✝ : Fintype ι\nx : ↑(ZSpan.fundamentalDomain b)\n⊢ Eq ((ZSpan.quotientEquiv b).symm x) (Submodule.Quotient.mk ↑x)","decl":"@[simp]\ntheorem quotientEquiv.symm_apply [Fintype ι] (x : fundamentalDomain b) :\n    (quotientEquiv b).symm x = Submodule.Quotient.mk ↑x := by\n  rw [Equiv.symm_apply_eq, quotientEquiv_apply_mk b ↑x, Subtype.ext_iff, fractRestrict_apply]\n  exact (fract_eq_self.mpr x.prop).symm\n\n"}
{"name":"ZSpan.discreteTopology_pi_basisFun","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"ι : Type u_2\ninst✝ : Finite ι\n⊢ DiscreteTopology (Subtype fun x => Membership.mem (Submodule.span Int (Set.range ⇑(Pi.basisFun Real ι))) x)","decl":"theorem discreteTopology_pi_basisFun [Finite ι] :\n    DiscreteTopology (span ℤ (Set.range (Pi.basisFun ℝ ι))) := by\n  cases nonempty_fintype ι\n  refine discreteTopology_iff_isOpen_singleton_zero.mpr ⟨Metric.ball 0 1, Metric.isOpen_ball, ?_⟩\n  ext x\n  rw [Set.mem_preimage, mem_ball_zero_iff, pi_norm_lt_iff zero_lt_one, Set.mem_singleton_iff]\n  simp_rw [← coe_eq_zero, funext_iff, Pi.zero_apply, Real.norm_eq_abs]\n  refine forall_congr' (fun i => ?_)\n  rsuffices ⟨y, hy⟩ : ∃ (y : ℤ), (y : ℝ) = (x : ι → ℝ) i\n  · rw [← hy, ← Int.cast_abs, ← Int.cast_one,  Int.cast_lt, Int.abs_lt_one_iff, Int.cast_eq_zero]\n  exact ((Pi.basisFun ℝ ι).mem_span_iff_repr_mem ℤ x).mp (SetLike.coe_mem x) i\n\n"}
{"name":"ZSpan.fundamentalDomain_subset_parallelepiped","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nb : Basis ι Real E\ninst✝ : Fintype ι\n⊢ HasSubset.Subset (ZSpan.fundamentalDomain b) (parallelepiped ⇑b)","decl":"theorem fundamentalDomain_subset_parallelepiped [Fintype ι] :\n    fundamentalDomain b ⊆ parallelepiped b := by\n  rw [fundamentalDomain, parallelepiped_basis_eq, Set.setOf_subset_setOf]\n  exact fun _ h i ↦ Set.Ico_subset_Icc_self (h i)\n\n"}
{"name":"ZSpan.instDiscreteTopologySubtypeMemSubmoduleIntSpanRangeCoeBasisRealOfFinite","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nb : Basis ι Real E\ninst✝ : Finite ι\n⊢ DiscreteTopology (Subtype fun x => Membership.mem (Submodule.span Int (Set.range ⇑b)) x)","decl":"instance [Finite ι] : DiscreteTopology (span ℤ (Set.range b)) := by\n  have h : Set.MapsTo b.equivFun (span ℤ (Set.range b)) (span ℤ (Set.range (Pi.basisFun ℝ ι))) := by\n    intro _ hx\n    rwa [SetLike.mem_coe, Basis.mem_span_iff_repr_mem] at hx ⊢\n  convert DiscreteTopology.of_continuous_injective ((continuous_equivFun_basis b).restrict h) ?_\n  · exact discreteTopology_pi_basisFun\n  · refine Subtype.map_injective _ (Basis.equivFun b).injective\n\n"}
{"name":"ZSpan.instDiscreteTopologySubtypeMemAddSubgroupToAddSubgroupIntSpanRangeCoeBasisRealOfFinite","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nb : Basis ι Real E\ninst✝ : Finite ι\n⊢ DiscreteTopology (Subtype fun x => Membership.mem (Submodule.span Int (Set.range ⇑b)).toAddSubgroup x)","decl":"instance [Finite ι] : DiscreteTopology (span ℤ (Set.range b)).toAddSubgroup :=\n  inferInstanceAs <| DiscreteTopology (span ℤ (Set.range b))\n\n"}
{"name":"ZSpan.setFinite_inter","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\nb : Basis ι Real E\ninst✝¹ : ProperSpace E\ninst✝ : Finite ι\ns : Set E\nhs : Bornology.IsBounded s\n⊢ (Inter.inter s ↑(Submodule.span Int (Set.range ⇑b))).Finite","decl":"theorem setFinite_inter [ProperSpace E] [Finite ι] {s : Set E} (hs : Bornology.IsBounded s) :\n    Set.Finite (s ∩ span ℤ (Set.range b)) := by\n  have : DiscreteTopology (span ℤ (Set.range b)) := inferInstance\n  refine Metric.finite_isBounded_inter_isClosed hs ?_\n  change IsClosed ((span ℤ (Set.range b)).toAddSubgroup : Set E)\n  exact AddSubgroup.isClosed_of_discrete\n\n"}
{"name":"ZSpan.fundamentalDomain_measurableSet","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\nb : Basis ι Real E\ninst✝² : MeasurableSpace E\ninst✝¹ : OpensMeasurableSpace E\ninst✝ : Finite ι\n⊢ MeasurableSet (ZSpan.fundamentalDomain b)","decl":"@[measurability]\ntheorem fundamentalDomain_measurableSet [MeasurableSpace E] [OpensMeasurableSpace E] [Finite ι] :\n    MeasurableSet (fundamentalDomain b) := by\n  cases nonempty_fintype ι\n  haveI : FiniteDimensional ℝ E := FiniteDimensional.of_fintype_basis b\n  let D : Set (ι → ℝ) := Set.pi Set.univ fun _ : ι => Set.Ico (0 : ℝ) 1\n  rw [(_ : fundamentalDomain b = b.equivFun.toLinearMap ⁻¹' D)]\n  · refine measurableSet_preimage (LinearMap.continuous_of_finiteDimensional _).measurable ?_\n    exact MeasurableSet.pi Set.countable_univ fun _ _ => measurableSet_Ico\n  · ext\n    simp only [D, fundamentalDomain, Set.mem_Ico, Set.mem_setOf_eq, LinearEquiv.coe_coe,\n      Set.mem_preimage, Basis.equivFun_apply, Set.mem_pi, Set.mem_univ, forall_true_left]\n\n"}
{"name":"ZSpan.isAddFundamentalDomain","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\nb : Basis ι Real E\ninst✝² : Finite ι\ninst✝¹ : MeasurableSpace E\ninst✝ : OpensMeasurableSpace E\nμ : MeasureTheory.Measure E\n⊢ MeasureTheory.IsAddFundamentalDomain (Subtype fun x => Membership.mem (Submodule.span Int (Set.range ⇑b)) x) (ZSpan.fundamentalDomain b) μ","decl":"/-- For a ℤ-lattice `Submodule.span ℤ (Set.range b)`, proves that the set defined\nby `ZSpan.fundamentalDomain` is a fundamental domain. -/\nprotected theorem isAddFundamentalDomain [Finite ι] [MeasurableSpace E] [OpensMeasurableSpace E]\n    (μ : Measure E) :\n    IsAddFundamentalDomain (span ℤ (Set.range b)) (fundamentalDomain b) μ := by\n  cases nonempty_fintype ι\n  exact IsAddFundamentalDomain.mk' (nullMeasurableSet (fundamentalDomain_measurableSet b))\n    fun x => exist_unique_vadd_mem_fundamentalDomain b x\n\n"}
{"name":"ZSpan.isAddFundamentalDomain'","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\nb : Basis ι Real E\ninst✝² : Finite ι\ninst✝¹ : MeasurableSpace E\ninst✝ : OpensMeasurableSpace E\nμ : MeasureTheory.Measure E\n⊢ MeasureTheory.IsAddFundamentalDomain (Subtype fun x => Membership.mem (Submodule.span Int (Set.range ⇑b)).toAddSubgroup x) (ZSpan.fundamentalDomain b) μ","decl":"/-- A version of `ZSpan.isAddFundamentalDomain` for `AddSubgroup`. -/\nprotected theorem isAddFundamentalDomain' [Finite ι] [MeasurableSpace E] [OpensMeasurableSpace E]\n    (μ : Measure E) :\n    IsAddFundamentalDomain (span ℤ (Set.range b)).toAddSubgroup (fundamentalDomain b) μ :=\n  ZSpan.isAddFundamentalDomain b μ\n\n"}
{"name":"ZSpan.measure_fundamentalDomain_ne_zero","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\nb : Basis ι Real E\ninst✝³ : Finite ι\ninst✝² : MeasurableSpace E\ninst✝¹ : BorelSpace E\nμ : MeasureTheory.Measure E\ninst✝ : μ.IsAddHaarMeasure\n⊢ Ne (μ (ZSpan.fundamentalDomain b)) 0","decl":"theorem measure_fundamentalDomain_ne_zero [Finite ι] [MeasurableSpace E] [BorelSpace E]\n    {μ : Measure E} [Measure.IsAddHaarMeasure μ] :\n    μ (fundamentalDomain b) ≠ 0 := by\n  convert (ZSpan.isAddFundamentalDomain b μ).measure_ne_zero (NeZero.ne μ)\n  exact inferInstanceAs <| VAddInvariantMeasure (span ℤ (Set.range b)).toAddSubgroup E μ\n\n"}
{"name":"ZSpan.measure_fundamentalDomain","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Real E\nb : Basis ι Real E\ninst✝⁴ : Fintype ι\ninst✝³ : DecidableEq ι\ninst✝² : MeasurableSpace E\nμ : MeasureTheory.Measure E\ninst✝¹ : BorelSpace E\ninst✝ : μ.IsAddHaarMeasure\nb₀ : Basis ι Real E\n⊢ Eq (μ (ZSpan.fundamentalDomain b)) (HMul.hMul (ENNReal.ofReal (abs (b₀.det ⇑b))) (μ (ZSpan.fundamentalDomain b₀)))","decl":"theorem measure_fundamentalDomain [Fintype ι] [DecidableEq ι] [MeasurableSpace E] (μ : Measure E)\n    [BorelSpace E] [Measure.IsAddHaarMeasure μ] (b₀ : Basis ι ℝ E) :\n    μ (fundamentalDomain b) = ENNReal.ofReal |b₀.det b| * μ (fundamentalDomain b₀) := by\n  have : FiniteDimensional ℝ E := FiniteDimensional.of_fintype_basis b\n  convert μ.addHaar_preimage_linearEquiv (b.equiv b₀ (Equiv.refl ι)) (fundamentalDomain b₀)\n  · rw [Set.eq_preimage_iff_image_eq (LinearEquiv.bijective _), map_fundamentalDomain,\n      Basis.map_equiv, Equiv.refl_symm, Basis.reindex_refl]\n  · rw [← LinearMap.det_toMatrix b₀, Basis.equiv_symm, Equiv.refl_symm, Basis.det_apply]\n    congr\n    ext\n    simp [Basis.toMatrix_apply, LinearMap.toMatrix_apply, LinearEquiv.coe_coe, Basis.equiv_apply]\n\n"}
{"name":"ZSpan.volume_fundamentalDomain","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"ι : Type u_2\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nb : Basis ι Real (ι → Real)\n⊢ Eq (MeasureTheory.MeasureSpace.volume (ZSpan.fundamentalDomain b)) (ENNReal.ofReal (abs (Matrix.of ⇑b).det))","decl":"@[simp]\ntheorem volume_fundamentalDomain [Fintype ι] [DecidableEq ι] (b : Basis ι ℝ (ι → ℝ)) :\n    volume (fundamentalDomain b) = ENNReal.ofReal |(Matrix.of b).det| := by\n  rw [measure_fundamentalDomain b volume (b₀ := Pi.basisFun ℝ ι), fundamentalDomain_pi_basisFun,\n    volume_pi, Measure.pi_pi, Real.volume_Ico, sub_zero, ENNReal.ofReal_one, Finset.prod_const_one,\n    mul_one, ← Matrix.det_transpose]\n  rfl\n\n"}
{"name":"ZSpan.fundamentalDomain_ae_parallelepiped","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\nb : Basis ι Real E\ninst✝³ : Fintype ι\ninst✝² : MeasurableSpace E\nμ : MeasureTheory.Measure E\ninst✝¹ : BorelSpace E\ninst✝ : μ.IsAddHaarMeasure\n⊢ (MeasureTheory.ae μ).EventuallyEq (ZSpan.fundamentalDomain b) (parallelepiped ⇑b)","decl":"theorem fundamentalDomain_ae_parallelepiped [Fintype ι] [MeasurableSpace E] (μ : Measure E)\n    [BorelSpace E] [Measure.IsAddHaarMeasure μ] :\n    fundamentalDomain b =ᵐ[μ] parallelepiped b := by\n  classical\n  have : FiniteDimensional ℝ E := FiniteDimensional.of_fintype_basis b\n  rw [← measure_symmDiff_eq_zero_iff, symmDiff_of_le (fundamentalDomain_subset_parallelepiped b)]\n  suffices (parallelepiped b \\ fundamentalDomain b) ⊆ ⋃ i,\n      AffineSubspace.mk' (b i) (span ℝ (b '' (Set.univ \\ {i}))) by\n    refine measure_mono_null this\n      (measure_iUnion_null_iff.mpr fun i ↦ Measure.addHaar_affineSubspace μ _ ?_)\n    refine (ne_of_mem_of_not_mem' (AffineSubspace.mem_top _ _ 0)\n      (AffineSubspace.mem_mk'_iff_vsub_mem.not.mpr ?_)).symm\n    simp_rw [vsub_eq_sub, zero_sub, neg_mem_iff]\n    exact linearIndependent_iff_not_mem_span.mp b.linearIndependent i\n  intro x hx\n  simp_rw [parallelepiped_basis_eq, Set.mem_Icc, Set.mem_diff, Set.mem_setOf_eq,\n    mem_fundamentalDomain, Set.mem_Ico, not_forall, not_and, not_lt] at hx\n  obtain ⟨i, hi⟩ := hx.2\n  have : b.repr x i = 1 := le_antisymm (hx.1 i).2 (hi (hx.1 i).1)\n  rw [← b.sum_repr x, ← Finset.sum_erase_add _ _ (Finset.mem_univ i), this, one_smul, ← vadd_eq_add]\n  refine Set.mem_iUnion.mpr ⟨i, AffineSubspace.vadd_mem_mk' _\n    (sum_smul_mem _ _ (fun i hi ↦ Submodule.subset_span ?_))⟩\n  exact ⟨i, Set.mem_diff_singleton.mpr ⟨trivial, Finset.ne_of_mem_erase hi⟩, rfl⟩\n\n"}
{"name":"IsZLattice.span_top","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"K : Type u_1\ninst✝³ : NormedField K\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace K E\nL : Submodule Int E\ninst✝ : DiscreteTopology (Subtype fun x => Membership.mem L x)\nself : IsZLattice K L\n⊢ Eq (Submodule.span K ↑L) Top.top","decl":"/-- `L : Submodule ℤ E` where `E` is a vector space over a normed field `K` is a `ℤ`-lattice if\nit is discrete and spans `E` over `K`. -/\nclass IsZLattice (K : Type*) [NormedField K] {E : Type*} [NormedAddCommGroup E] [NormedSpace K E]\n    (L : Submodule ℤ E) [DiscreteTopology L] : Prop where\n  /-- `L` spans the full space `E` over `K`. -/\n  span_top : span K (L : Set E) = ⊤\n\n"}
{"name":"ZSpan.isZLattice","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_1\nι : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : Finite ι\nb : Basis ι Real E\n⊢ IsZLattice Real (Submodule.span Int (Set.range ⇑b))","decl":"theorem _root_.ZSpan.isZLattice {E ι : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]\n    [Finite ι] (b : Basis ι ℝ E) :\n    IsZLattice ℝ (span ℤ (Set.range b)) where\n  span_top := ZSpan.span_top b\n\n"}
{"name":"Zlattice.FG","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"K : Type u_1\ninst✝⁷ : NormedLinearOrderedField K\ninst✝⁶ : HasSolidNorm K\ninst✝⁵ : FloorRing K\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace K E\ninst✝² : FiniteDimensional K E\ninst✝¹ : ProperSpace E\nL : Submodule Int E\ninst✝ : DiscreteTopology (Subtype fun x => Membership.mem L x)\nhs : IsZLattice K L\n⊢ L.FG","decl":"theorem Zlattice.FG [hs : IsZLattice K L] : L.FG := by\n  obtain ⟨s, ⟨h_incl, ⟨h_span, h_lind⟩⟩⟩ := exists_linearIndependent K (L : Set E)\n  -- Let `s` be a maximal `K`-linear independent family of elements of `L`. We show that\n  -- `L` is finitely generated (as a ℤ-module) because it fits in the exact sequence\n  -- `0 → span ℤ s → L → L ⧸ span ℤ s → 0` with `span ℤ s` and `L ⧸ span ℤ s` finitely generated.\n  refine fg_of_fg_map_of_fg_inf_ker (span ℤ s).mkQ ?_ ?_\n  · -- Let `b` be the `K`-basis of `E` formed by the vectors in `s`. The elements of\n    -- `L ⧸ span ℤ s = L ⧸ span ℤ b` are in bijection with elements of `L ∩ fundamentalDomain b`\n    -- so there are finitely many since `fundamentalDomain b` is bounded.\n    refine fg_def.mpr ⟨map (span ℤ s).mkQ L, ?_, span_eq _⟩\n    let b := Basis.mk h_lind (by\n      rw [← hs.span_top, ← h_span]\n      exact span_mono (by simp only [Subtype.range_coe_subtype, Set.setOf_mem_eq, subset_rfl]))\n    rw [show span ℤ s = span ℤ (Set.range b) by simp [b, Basis.coe_mk, Subtype.range_coe_subtype]]\n    have : Fintype s := h_lind.setFinite.fintype\n    refine Set.Finite.of_finite_image (f := ((↑) : _ →  E) ∘ quotientEquiv b) ?_\n      (Function.Injective.injOn (Subtype.coe_injective.comp (quotientEquiv b).injective))\n    have : ((fundamentalDomain b) ∩ L).Finite := by\n      change ((fundamentalDomain b) ∩ L.toAddSubgroup).Finite\n      have : DiscreteTopology L.toAddSubgroup := (inferInstance : DiscreteTopology L)\n      exact Metric.finite_isBounded_inter_isClosed (fundamentalDomain_isBounded b) inferInstance\n    refine Set.Finite.subset this ?_\n    rintro _ ⟨_, ⟨⟨x, ⟨h_mem, rfl⟩⟩, rfl⟩⟩\n    rw [Function.comp_apply, mkQ_apply, quotientEquiv_apply_mk, fractRestrict_apply]\n    refine ⟨?_, ?_⟩\n    · exact fract_mem_fundamentalDomain b x\n    · rw [fract, SetLike.mem_coe, sub_eq_add_neg]\n      refine Submodule.add_mem _ h_mem\n        (neg_mem (Set.mem_of_subset_of_mem ?_ (Subtype.mem (floor b x))))\n      rw [SetLike.coe_subset_coe, Basis.coe_mk, Subtype.range_coe_subtype, Set.setOf_mem_eq]\n      exact span_le.mpr h_incl\n  · -- `span ℤ s` is finitely generated because `s` is finite\n    rw [ker_mkQ, inf_of_le_right (span_le.mpr h_incl)]\n    exact fg_span (LinearIndependent.setFinite h_lind)\n\n"}
{"name":"ZLattice.module_finite","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"K : Type u_1\ninst✝⁸ : NormedLinearOrderedField K\ninst✝⁷ : HasSolidNorm K\ninst✝⁶ : FloorRing K\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace K E\ninst✝³ : FiniteDimensional K E\ninst✝² : ProperSpace E\nL : Submodule Int E\ninst✝¹ : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst✝ : IsZLattice K L\n⊢ Module.Finite Int (Subtype fun x => Membership.mem L x)","decl":"theorem ZLattice.module_finite [IsZLattice K L] : Module.Finite ℤ L :=\n  Module.Finite.iff_fg.mpr (Zlattice.FG K L)\n\n"}
{"name":"instModuleFinite_of_discrete_submodule","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : FiniteDimensional Real E\nL : Submodule Int E\ninst✝ : DiscreteTopology (Subtype fun x => Membership.mem L x)\n⊢ Module.Finite Int (Subtype fun x => Membership.mem L x)","decl":"instance instModuleFinite_of_discrete_submodule {E : Type*} [NormedAddCommGroup E]\n    [NormedSpace ℝ E] [FiniteDimensional ℝ E] (L : Submodule ℤ E) [DiscreteTopology L] :\n    Module.Finite ℤ L := by\n  let f := (span ℝ (L : Set E)).subtype\n  let L₀ := L.comap (f.restrictScalars ℤ)\n  have h_img : f '' L₀ = L := by\n    rw [← LinearMap.coe_restrictScalars ℤ f, ← Submodule.map_coe (f.restrictScalars ℤ),\n      Submodule.map_comap_eq_self]\n    exact fun x hx ↦ LinearMap.mem_range.mpr ⟨⟨x, Submodule.subset_span hx⟩, rfl⟩\n  suffices Module.Finite ℤ L₀ by\n    have : L₀.map (f.restrictScalars ℤ) = L :=\n      SetLike.ext'_iff.mpr h_img\n    convert this ▸ Module.Finite.map L₀ (f.restrictScalars ℤ)\n  have : DiscreteTopology L₀ := by\n    refine DiscreteTopology.preimage_of_continuous_injective (L : Set E) ?_ (injective_subtype _)\n    exact LinearMap.continuous_of_finiteDimensional f\n  have : IsZLattice ℝ L₀ := ⟨by\n    rw [← (Submodule.map_injective_of_injective (injective_subtype _)).eq_iff, Submodule.map_span,\n      Submodule.map_top, range_subtype, h_img]⟩\n  exact ZLattice.module_finite ℝ L₀\n\n"}
{"name":"ZLattice.module_free","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"K : Type u_1\ninst✝⁸ : NormedLinearOrderedField K\ninst✝⁷ : HasSolidNorm K\ninst✝⁶ : FloorRing K\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace K E\ninst✝³ : FiniteDimensional K E\ninst✝² : ProperSpace E\nL : Submodule Int E\ninst✝¹ : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst✝ : IsZLattice K L\n⊢ Module.Free Int (Subtype fun x => Membership.mem L x)","decl":"theorem ZLattice.module_free [IsZLattice K L] : Module.Free ℤ L := by\n  have : Module.Finite ℤ L := module_finite K L\n  have : Module ℚ E := Module.compHom E (algebraMap ℚ K)\n  infer_instance\n\n"}
{"name":"instModuleFree_of_discrete_submodule","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : FiniteDimensional Real E\nL : Submodule Int E\ninst✝ : DiscreteTopology (Subtype fun x => Membership.mem L x)\n⊢ Module.Free Int (Subtype fun x => Membership.mem L x)","decl":"instance instModuleFree_of_discrete_submodule {E : Type*} [NormedAddCommGroup E]\n    [NormedSpace ℝ E] [FiniteDimensional ℝ E] (L : Submodule ℤ E) [DiscreteTopology L] :\n    Module.Free ℤ L := by\n  have : Module ℚ E := Module.compHom E (algebraMap ℚ ℝ)\n  infer_instance\n\n"}
{"name":"ZLattice.rank","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"K : Type u_1\ninst✝⁷ : NormedLinearOrderedField K\ninst✝⁶ : HasSolidNorm K\ninst✝⁵ : FloorRing K\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace K E\ninst✝² : FiniteDimensional K E\ninst✝¹ : ProperSpace E\nL : Submodule Int E\ninst✝ : DiscreteTopology (Subtype fun x => Membership.mem L x)\nhs : IsZLattice K L\n⊢ Eq (Module.finrank Int (Subtype fun x => Membership.mem L x)) (Module.finrank K E)","decl":"theorem ZLattice.rank [hs : IsZLattice K L] : finrank ℤ L = finrank K E := by\n  classical\n  have : Module.Finite ℤ L := module_finite K L\n  have : Module.Free ℤ L := module_free K L\n  have : Module ℚ E := Module.compHom E (algebraMap ℚ K)\n  let b₀ := Module.Free.chooseBasis ℤ L\n  -- Let `b` be a `ℤ`-basis of `L` formed of vectors of `E`\n  let b := Subtype.val ∘ b₀\n  have : LinearIndependent ℤ b :=\n    LinearIndependent.map' b₀.linearIndependent (L.subtype) (ker_subtype _)\n  -- We prove some assertions that will be useful later on\n  have h_spanL : span ℤ (Set.range b) = L := by\n    convert congrArg (map (Submodule.subtype L)) b₀.span_eq\n    · rw [map_span, Set.range_comp]\n      rfl\n    · exact (map_subtype_top _).symm\n  have h_spanE : span K (Set.range b) = ⊤ := by\n    rw [← span_span_of_tower (R := ℤ), h_spanL]\n    exact hs.span_top\n  have h_card : Fintype.card (Module.Free.ChooseBasisIndex ℤ L) =\n      (Set.range b).toFinset.card := by\n    rw [Set.toFinset_range, Finset.univ.card_image_of_injective]\n    · rfl\n    · exact Subtype.coe_injective.comp (Basis.injective _)\n  rw [finrank_eq_card_chooseBasisIndex]\n    -- We prove that `finrank ℤ L ≤ finrank K E` and `finrank K E ≤ finrank ℤ L`\n  refine le_antisymm ?_ ?_\n  · -- To prove that `finrank ℤ L ≤ finrank K E`, we proceed by contradiction and prove that, in\n    -- this case, there is a ℤ-relation between the vectors of `b`\n    obtain ⟨t, ⟨ht_inc, ⟨ht_span, ht_lin⟩⟩⟩ := exists_linearIndependent K (Set.range b)\n    -- `e` is a `K`-basis of `E` formed of vectors of `b`\n    let e : Basis t K E := Basis.mk ht_lin (by simp [ht_span, h_spanE])\n    have : Fintype t := Set.Finite.fintype ((Set.range b).toFinite.subset ht_inc)\n    have h : LinearIndependent ℤ (fun x : (Set.range b) => (x : E)) := by\n      rwa [linearIndependent_subtype_range (Subtype.coe_injective.comp b₀.injective)]\n    contrapose! h\n    -- Since `finrank ℤ L > finrank K E`, there exists a vector `v ∈ b` with `v ∉ e`\n    obtain ⟨v, hv⟩ : (Set.range b \\ Set.range e).Nonempty := by\n      rw [Basis.coe_mk, Subtype.range_coe_subtype, Set.setOf_mem_eq, ← Set.toFinset_nonempty]\n      contrapose h\n      rw [Finset.not_nonempty_iff_eq_empty, Set.toFinset_diff,\n        Finset.sdiff_eq_empty_iff_subset] at h\n      replace h := Finset.card_le_card h\n      rwa [not_lt, h_card, ← topEquiv.finrank_eq, ← h_spanE, ← ht_span,\n        finrank_span_set_eq_card ht_lin]\n    -- Assume that `e ∪ {v}` is not `ℤ`-linear independent then we get the contradiction\n    suffices ¬ LinearIndependent ℤ (fun x : ↥(insert v (Set.range e)) => (x : E)) by\n      contrapose! this\n      refine LinearIndependent.mono ?_ this\n      exact Set.insert_subset (Set.mem_of_mem_diff hv) (by simp [e, ht_inc])\n    -- We prove finally that `e ∪ {v}` is not ℤ-linear independent or, equivalently,\n    -- not ℚ-linear independent by showing that `v ∈ span ℚ e`.\n    rw [LinearIndependent.iff_fractionRing ℤ ℚ,\n      linearIndependent_insert (Set.not_mem_of_mem_diff hv),  not_and, not_not]\n    intro _\n    -- But that follows from the fact that there exist `n, m : ℕ`, `n ≠ m`\n    -- such that `(n - m) • v ∈ span ℤ e` which is true since `n ↦ ZSpan.fract e (n • v)`\n    -- takes value into the finite set `fundamentalDomain e ∩ L`\n    have h_mapsto : Set.MapsTo (fun n : ℤ => fract e (n • v)) Set.univ\n        (Metric.closedBall 0 (∑ i, ‖e i‖) ∩ (L : Set E)) := by\n      rw [Set.mapsTo_inter, Set.mapsTo_univ_iff, Set.mapsTo_univ_iff]\n      refine ⟨fun _ ↦ mem_closedBall_zero_iff.mpr (norm_fract_le e _), fun _ => ?_⟩\n      · rw [← h_spanL]\n        refine sub_mem ?_ ?_\n        · exact zsmul_mem (subset_span (Set.diff_subset hv)) _\n        · exact span_mono (by simp [e, ht_inc]) (coe_mem _)\n    have h_finite : Set.Finite (Metric.closedBall 0 (∑ i, ‖e i‖) ∩ (L : Set E)) := by\n      change ((_ : Set E) ∩ L.toAddSubgroup).Finite\n      have : DiscreteTopology L.toAddSubgroup := (inferInstance : DiscreteTopology L)\n      exact Metric.finite_isBounded_inter_isClosed  Metric.isBounded_closedBall inferInstance\n    obtain ⟨n, -, m, -, h_neq, h_eq⟩ := Set.Infinite.exists_ne_map_eq_of_mapsTo\n      Set.infinite_univ h_mapsto h_finite\n    have h_nz : (-n + m : ℚ) ≠ 0 := by\n      rwa [Ne, add_eq_zero_iff_eq_neg.not, neg_inj, Rat.coe_int_inj, ← Ne]\n    apply (smul_mem_iff _ h_nz).mp\n    refine span_subset_span ℤ ℚ _ ?_\n    rwa [add_smul, neg_smul, SetLike.mem_coe, ← fract_eq_fract, Int.cast_smul_eq_zsmul ℚ,\n      Int.cast_smul_eq_zsmul ℚ]\n  · -- To prove that `finrank K E ≤ finrank ℤ L`, we use the fact `b` generates `E` over `K`\n    -- and thus `finrank K E ≤ card b = finrank ℤ L`\n    rw [← topEquiv.finrank_eq, ← h_spanE]\n    convert finrank_span_le_card (R := K) (Set.range b)\n\n"}
{"name":"Basis.ofZLatticeBasis_apply","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"K : Type u_1\ninst✝⁷ : NormedLinearOrderedField K\ninst✝⁶ : HasSolidNorm K\ninst✝⁵ : FloorRing K\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace K E\ninst✝² : FiniteDimensional K E\ninst✝¹ : ProperSpace E\nL : Submodule Int E\ninst✝ : DiscreteTopology (Subtype fun x => Membership.mem L x)\nι : Type u_3\nhs : IsZLattice K L\nb : Basis ι Int (Subtype fun x => Membership.mem L x)\ni : ι\n⊢ Eq ((Basis.ofZLatticeBasis K L b) i) ↑(b i)","decl":"@[simp]\ntheorem Basis.ofZLatticeBasis_apply (i : ι) :\n    b.ofZLatticeBasis K L i = b i := by simp [Basis.ofZLatticeBasis]\n\n"}
{"name":"Basis.ofZLatticeBasis_repr_apply","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"K : Type u_1\ninst✝⁷ : NormedLinearOrderedField K\ninst✝⁶ : HasSolidNorm K\ninst✝⁵ : FloorRing K\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace K E\ninst✝² : FiniteDimensional K E\ninst✝¹ : ProperSpace E\nL : Submodule Int E\ninst✝ : DiscreteTopology (Subtype fun x => Membership.mem L x)\nι : Type u_3\nhs : IsZLattice K L\nb : Basis ι Int (Subtype fun x => Membership.mem L x)\nx : Subtype fun x => Membership.mem L x\ni : ι\n⊢ Eq (((Basis.ofZLatticeBasis K L b).repr ↑x) i) ↑((b.repr x) i)","decl":"@[simp]\ntheorem Basis.ofZLatticeBasis_repr_apply (x : L) (i : ι) :\n    (b.ofZLatticeBasis K L).repr x i = b.repr x i := by\n  suffices ((b.ofZLatticeBasis K L).repr.toLinearMap.restrictScalars ℤ) ∘ₗ L.subtype\n      = Finsupp.mapRange.linearMap (Algebra.linearMap ℤ K) ∘ₗ b.repr.toLinearMap by\n    exact DFunLike.congr_fun (LinearMap.congr_fun this x) i\n  refine Basis.ext b fun i ↦ ?_\n  simp_rw [LinearMap.coe_comp, Function.comp_apply, LinearMap.coe_restrictScalars,\n    LinearEquiv.coe_coe, coe_subtype, ← b.ofZLatticeBasis_apply K, repr_self,\n    Finsupp.mapRange.linearMap_apply, Finsupp.mapRange_single, Algebra.linearMap_apply, map_one]\n\n"}
{"name":"Basis.ofZLatticeBasis_span","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"K : Type u_1\ninst✝⁷ : NormedLinearOrderedField K\ninst✝⁶ : HasSolidNorm K\ninst✝⁵ : FloorRing K\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace K E\ninst✝² : FiniteDimensional K E\ninst✝¹ : ProperSpace E\nL : Submodule Int E\ninst✝ : DiscreteTopology (Subtype fun x => Membership.mem L x)\nι : Type u_3\nhs : IsZLattice K L\nb : Basis ι Int (Subtype fun x => Membership.mem L x)\n⊢ Eq (Submodule.span Int (Set.range ⇑(Basis.ofZLatticeBasis K L b))) L","decl":"theorem Basis.ofZLatticeBasis_span :\n    (span ℤ (Set.range (b.ofZLatticeBasis K))) = L := by\n  calc (span ℤ (Set.range (b.ofZLatticeBasis K)))\n    _ = (span ℤ (L.subtype '' (Set.range b))) := by congr; ext; simp\n    _ = (map L.subtype (span ℤ (Set.range b))) := by rw [Submodule.map_span]\n    _ = L := by simp [b.span_eq]\n\n"}
{"name":"ZLattice.isAddFundamentalDomain","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"ι : Type u_3\nE : Type u_4\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace Real E\ninst✝⁵ : FiniteDimensional Real E\nL : Submodule Int E\ninst✝⁴ : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst✝³ : IsZLattice Real L\ninst✝² : Finite ι\nb : Basis ι Int (Subtype fun x => Membership.mem L x)\ninst✝¹ : MeasurableSpace E\ninst✝ : OpensMeasurableSpace E\nμ : MeasureTheory.Measure E\n⊢ MeasureTheory.IsAddFundamentalDomain (Subtype fun x => Membership.mem L x) (ZSpan.fundamentalDomain (Basis.ofZLatticeBasis Real L b)) μ","decl":"open MeasureTheory in\ntheorem ZLattice.isAddFundamentalDomain {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]\n    [FiniteDimensional ℝ E] {L : Submodule ℤ E} [DiscreteTopology L] [IsZLattice ℝ L] [Finite ι]\n    (b : Basis ι ℤ L) [MeasurableSpace E] [OpensMeasurableSpace E] (μ : Measure E) :\n    IsAddFundamentalDomain L (fundamentalDomain (b.ofZLatticeBasis ℝ)) μ := by\n  convert ZSpan.isAddFundamentalDomain (b.ofZLatticeBasis ℝ) μ\n  all_goals exact (b.ofZLatticeBasis_span ℝ).symm\n\n"}
{"name":"instCountable_of_discrete_submodule","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"E : Type u_4\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : FiniteDimensional Real E\nL : Submodule Int E\ninst✝¹ : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst✝ : IsZLattice Real L\n⊢ Countable (Subtype fun x => Membership.mem L x)","decl":"instance instCountable_of_discrete_submodule {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]\n    [FiniteDimensional ℝ E] (L : Submodule ℤ E) [DiscreteTopology L] [IsZLattice ℝ L] :\n    Countable L := by\n  simp_rw [← (Module.Free.chooseBasis ℤ L).ofZLatticeBasis_span ℝ]\n  infer_instance\n\n"}
{"name":"ZLattice.coe_comap","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"K : Type u_1\ninst✝⁴ : NormedField K\nE : Type u_2\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace K E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace K F\nL : Submodule Int E\ne : LinearMap (RingHom.id K) F E\n⊢ Eq (↑(ZLattice.comap K L e)) (Set.preimage ⇑e ↑L)","decl":"@[simp]\ntheorem ZLattice.coe_comap (e : F →ₗ[K] E) :\n    (ZLattice.comap K L e : Set F) = e⁻¹' L := rfl\n\n"}
{"name":"ZLattice.comap_refl","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"K : Type u_1\ninst✝² : NormedField K\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace K E\nL : Submodule Int E\n⊢ Eq (ZLattice.comap K L 1) L","decl":"theorem ZLattice.comap_refl :\n    ZLattice.comap K L (1 : E →ₗ[K] E)= L := Submodule.comap_id L\n\n"}
{"name":"ZLattice.comap_discreteTopology","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"K : Type u_1\ninst✝⁴ : NormedField K\nE : Type u_2\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace K E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace K F\nL : Submodule Int E\nhL : DiscreteTopology (Subtype fun x => Membership.mem L x)\ne : LinearMap (RingHom.id K) F E\nhe₁ : Continuous ⇑e\nhe₂ : Function.Injective ⇑e\n⊢ DiscreteTopology (Subtype fun x => Membership.mem (ZLattice.comap K L e) x)","decl":"theorem ZLattice.comap_discreteTopology [hL : DiscreteTopology L] {e : F →ₗ[K] E}\n    (he₁ : Continuous e) (he₂ : Function.Injective e) :\n    DiscreteTopology (ZLattice.comap K L e) := by\n  exact DiscreteTopology.preimage_of_continuous_injective L he₁ he₂\n\n"}
{"name":"instDiscreteTopologySubtypeMemSubmoduleIntComap","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"K : Type u_1\ninst✝⁵ : NormedField K\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace K E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace K F\nL : Submodule Int E\ninst✝ : DiscreteTopology (Subtype fun x => Membership.mem L x)\ne : ContinuousLinearEquiv (RingHom.id K) F E\n⊢ DiscreteTopology (Subtype fun x => Membership.mem (ZLattice.comap K L ↑e.toLinearEquiv) x)","decl":"instance [DiscreteTopology L] (e : F ≃L[K] E) :\n    DiscreteTopology (ZLattice.comap K L e.toLinearMap) :=\n  ZLattice.comap_discreteTopology K L e.continuous e.injective\n\n"}
{"name":"ZLattice.comap_span_top","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"K : Type u_1\ninst✝⁴ : NormedField K\nE : Type u_2\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace K E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace K F\nL : Submodule Int E\nhL : Eq (Submodule.span K ↑L) Top.top\ne : LinearMap (RingHom.id K) F E\nhe : HasSubset.Subset ↑L ↑(LinearMap.range e)\n⊢ Eq (Submodule.span K ↑(ZLattice.comap K L e)) Top.top","decl":"theorem ZLattice.comap_span_top (hL : span K (L : Set E) = ⊤) {e : F →ₗ[K] E}\n    (he : (L : Set E) ⊆ LinearMap.range e) :\n    span K (ZLattice.comap K L e : Set F) = ⊤ := by\n  rw [ZLattice.coe_comap, Submodule.span_preimage_eq (Submodule.nonempty L) he, hL, comap_top]\n\n"}
{"name":"instIsZLatticeComap","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"K : Type u_1\ninst✝⁶ : NormedField K\nE : Type u_2\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace K E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace K F\nL : Submodule Int E\ninst✝¹ : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst✝ : IsZLattice K L\ne : ContinuousLinearEquiv (RingHom.id K) F E\n⊢ IsZLattice K (ZLattice.comap K L ↑e.toLinearEquiv)","decl":"instance instIsZLatticeComap [DiscreteTopology L] [IsZLattice K L] (e : F ≃L[K] E) :\n    IsZLattice K (ZLattice.comap K L e.toLinearMap) where\n  span_top := by\n    rw [ZLattice.coe_comap, LinearEquiv.coe_coe, e.coe_toLinearEquiv, ← e.image_symm_eq_preimage,\n      ← Submodule.map_span, IsZLattice.span_top, Submodule.map_top, LinearEquivClass.range]\n\n"}
{"name":"ZLattice.comap_comp","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"K : Type u_1\ninst✝⁶ : NormedField K\nE : Type u_2\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace K E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace K F\nL : Submodule Int E\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace K G\ne : LinearMap (RingHom.id K) F E\ne' : LinearMap (RingHom.id K) G F\n⊢ Eq (ZLattice.comap K (ZLattice.comap K L e) e') (ZLattice.comap K L (e.comp e'))","decl":"theorem ZLattice.comap_comp {G : Type*} [NormedAddCommGroup G] [NormedSpace K G]\n    (e : F →ₗ[K] E) (e' : G →ₗ[K] F) :\n    (ZLattice.comap K (ZLattice.comap K L e) e') = ZLattice.comap K L (e ∘ₗ e') :=\n  (Submodule.comap_comp _ _ L).symm\n\n"}
{"name":"ZLattice.comap_equiv_apply","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"K : Type u_1\ninst✝⁴ : NormedField K\nE : Type u_2\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace K E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace K F\nL : Submodule Int E\ne : LinearEquiv (RingHom.id K) F E\nx : Subtype fun x => Membership.mem L x\n⊢ Eq (↑((ZLattice.comap_equiv K L e) x)) (e.symm ↑x)","decl":"@[simp]\ntheorem ZLattice.comap_equiv_apply (e : F ≃ₗ[K] E) (x : L) :\n    ZLattice.comap_equiv K L e x = e.symm x := rfl\n\n"}
{"name":"Basis.ofZLatticeComap_apply","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"K : Type u_1\ninst✝⁴ : NormedField K\nE : Type u_2\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace K E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace K F\nL : Submodule Int E\ne : LinearEquiv (RingHom.id K) F E\nι : Type u_4\nb : Basis ι Int (Subtype fun x => Membership.mem L x)\ni : ι\n⊢ Eq (↑((Basis.ofZLatticeComap K L e b) i)) (e.symm ↑(b i))","decl":"@[simp]\ntheorem Basis.ofZLatticeComap_apply (e : F ≃ₗ[K] E) {ι : Type*}\n    (b : Basis ι ℤ L) (i : ι) :\n    b.ofZLatticeComap K L e i = e.symm (b i) := by simp [Basis.ofZLatticeComap]\n\n"}
{"name":"Basis.ofZLatticeComap_repr_apply","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"K : Type u_1\ninst✝⁴ : NormedField K\nE : Type u_2\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace K E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace K F\nL : Submodule Int E\ne : LinearEquiv (RingHom.id K) F E\nι : Type u_4\nb : Basis ι Int (Subtype fun x => Membership.mem L x)\nx : Subtype fun x => Membership.mem L x\ni : ι\n⊢ Eq (((Basis.ofZLatticeComap K L e b).repr ((ZLattice.comap_equiv K L e) x)) i) ((b.repr x) i)","decl":"@[simp]\ntheorem Basis.ofZLatticeComap_repr_apply (e : F ≃ₗ[K] E) {ι : Type*} (b : Basis ι ℤ L) (x : L)\n    (i : ι) :\n    (b.ofZLatticeComap K L e).repr (ZLattice.comap_equiv K L e x) i = b.repr x i := by\n  simp [Basis.ofZLatticeComap]\n\n"}
{"name":"Basis.ofZLatticeBasis_comap","module":"Mathlib.Algebra.Module.ZLattice.Basic","initialProofState":"K : Type u_1\ninst✝¹² : NormedLinearOrderedField K\ninst✝¹¹ : HasSolidNorm K\ninst✝¹⁰ : FloorRing K\nE : Type u_2\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace K E\ninst✝⁷ : FiniteDimensional K E\ninst✝⁶ : ProperSpace E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace K F\ninst✝³ : FiniteDimensional K F\ninst✝² : ProperSpace F\nL : Submodule Int E\ninst✝¹ : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst✝ : IsZLattice K L\ne : ContinuousLinearEquiv (RingHom.id K) F E\nι : Type u_4\nb : Basis ι Int (Subtype fun x => Membership.mem L x)\n⊢ Eq (Basis.ofZLatticeBasis K (ZLattice.comap K L ↑e.toLinearEquiv) (Basis.ofZLatticeComap K L e.toLinearEquiv b)) ((Basis.ofZLatticeBasis K L b).map e.symm.toLinearEquiv)","decl":"theorem Basis.ofZLatticeBasis_comap (e : F ≃L[K] E) {ι : Type*} (b : Basis ι ℤ L) :\n    (b.ofZLatticeComap K L e.toLinearEquiv).ofZLatticeBasis K (ZLattice.comap K L e.toLinearMap) =\n    (b.ofZLatticeBasis K L).map e.symm.toLinearEquiv := by\n  ext\n  simp\n\n"}
