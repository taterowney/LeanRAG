{"name":"Polynomial.derivative_apply","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\n⊢ Eq (Polynomial.derivative p) (p.sum fun n a => HMul.hMul (Polynomial.C (HMul.hMul a ↑n)) (HPow.hPow Polynomial.X (HSub.hSub n 1)))","decl":"theorem derivative_apply (p : R[X]) : derivative p = p.sum fun n a => C (a * n) * X ^ (n - 1) :=\n  rfl\n\n"}
{"name":"Polynomial.coeff_derivative","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nn : Nat\n⊢ Eq ((Polynomial.derivative p).coeff n) (HMul.hMul (p.coeff (HAdd.hAdd n 1)) (HAdd.hAdd (↑n) 1))","decl":"theorem coeff_derivative (p : R[X]) (n : ℕ) :\n    coeff (derivative p) n = coeff p (n + 1) * (n + 1) := by\n  rw [derivative_apply]\n  simp only [coeff_X_pow, coeff_sum, coeff_C_mul]\n  rw [sum, Finset.sum_eq_single (n + 1)]\n  · simp only [Nat.add_succ_sub_one, add_zero, mul_one, if_true, eq_self_iff_true]; norm_cast\n  · intro b\n    cases b\n    · intros\n      rw [Nat.cast_zero, mul_zero, zero_mul]\n    · intro _ H\n      rw [Nat.add_one_sub_one, if_neg (mt (congr_arg Nat.succ) H.symm), mul_zero]\n  · rw [if_pos (add_tsub_cancel_right n 1).symm, mul_one, Nat.cast_add, Nat.cast_one,\n      mem_support_iff]\n    intro h\n    push_neg at h\n    simp [h]\n\n"}
{"name":"Polynomial.derivative_zero","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Eq (Polynomial.derivative 0) 0","decl":"@[simp]\ntheorem derivative_zero : derivative (0 : R[X]) = 0 :=\n  derivative.map_zero\n\n"}
{"name":"Polynomial.iterate_derivative_zero","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\nk : Nat\n⊢ Eq (Nat.iterate (⇑Polynomial.derivative) k 0) 0","decl":"theorem iterate_derivative_zero {k : ℕ} : derivative^[k] (0 : R[X]) = 0 :=\n  iterate_map_zero derivative k\n\n"}
{"name":"Polynomial.derivative_monomial","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\na : R\nn : Nat\n⊢ Eq (Polynomial.derivative ((Polynomial.monomial n) a)) ((Polynomial.monomial (HSub.hSub n 1)) (HMul.hMul a ↑n))","decl":"@[simp]\ntheorem derivative_monomial (a : R) (n : ℕ) :\n    derivative (monomial n a) = monomial (n - 1) (a * n) := by\n  rw [derivative_apply, sum_monomial_index, C_mul_X_pow_eq_monomial]\n  simp\n\n"}
{"name":"Polynomial.derivative_C_mul_X","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\na : R\n⊢ Eq (Polynomial.derivative (HMul.hMul (Polynomial.C a) Polynomial.X)) (Polynomial.C a)","decl":"theorem derivative_C_mul_X (a : R) : derivative (C a * X) = C a := by\n  simp [C_mul_X_eq_monomial, derivative_monomial, Nat.cast_one, mul_one]\n\n"}
{"name":"Polynomial.derivative_C_mul_X_pow","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\na : R\nn : Nat\n⊢ Eq (Polynomial.derivative (HMul.hMul (Polynomial.C a) (HPow.hPow Polynomial.X n))) (HMul.hMul (Polynomial.C (HMul.hMul a ↑n)) (HPow.hPow Polynomial.X (HSub.hSub n 1)))","decl":"theorem derivative_C_mul_X_pow (a : R) (n : ℕ) :\n    derivative (C a * X ^ n) = C (a * n) * X ^ (n - 1) := by\n  rw [C_mul_X_pow_eq_monomial, C_mul_X_pow_eq_monomial, derivative_monomial]\n\n"}
{"name":"Polynomial.derivative_C_mul_X_sq","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\na : R\n⊢ Eq (Polynomial.derivative (HMul.hMul (Polynomial.C a) (HPow.hPow Polynomial.X 2))) (HMul.hMul (Polynomial.C (HMul.hMul a 2)) Polynomial.X)","decl":"theorem derivative_C_mul_X_sq (a : R) : derivative (C a * X ^ 2) = C (a * 2) * X := by\n  rw [derivative_C_mul_X_pow, Nat.cast_two, pow_one]\n\n"}
{"name":"Polynomial.derivative_X_pow","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\n⊢ Eq (Polynomial.derivative (HPow.hPow Polynomial.X n)) (HMul.hMul (Polynomial.C ↑n) (HPow.hPow Polynomial.X (HSub.hSub n 1)))","decl":"@[simp]\ntheorem derivative_X_pow (n : ℕ) : derivative (X ^ n : R[X]) = C (n : R) * X ^ (n - 1) := by\n  convert derivative_C_mul_X_pow (1 : R) n <;> simp\n\n"}
{"name":"Polynomial.derivative_X_sq","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Eq (Polynomial.derivative (HPow.hPow Polynomial.X 2)) (HMul.hMul (Polynomial.C 2) Polynomial.X)","decl":"theorem derivative_X_sq : derivative (X ^ 2 : R[X]) = C 2 * X := by\n  rw [derivative_X_pow, Nat.cast_two, pow_one]\n\n"}
{"name":"Polynomial.derivative_C","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\na : R\n⊢ Eq (Polynomial.derivative (Polynomial.C a)) 0","decl":"@[simp]\ntheorem derivative_C {a : R} : derivative (C a) = 0 := by simp [derivative_apply]\n\n"}
{"name":"Polynomial.derivative_of_natDegree_zero","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nhp : Eq p.natDegree 0\n⊢ Eq (Polynomial.derivative p) 0","decl":"theorem derivative_of_natDegree_zero {p : R[X]} (hp : p.natDegree = 0) : derivative p = 0 := by\n  rw [eq_C_of_natDegree_eq_zero hp, derivative_C]\n\n"}
{"name":"Polynomial.derivative_X","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Eq (Polynomial.derivative Polynomial.X) 1","decl":"@[simp]\ntheorem derivative_X : derivative (X : R[X]) = 1 :=\n  (derivative_monomial _ _).trans <| by simp\n\n"}
{"name":"Polynomial.derivative_one","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Eq (Polynomial.derivative 1) 0","decl":"@[simp]\ntheorem derivative_one : derivative (1 : R[X]) = 0 :=\n  derivative_C\n\n"}
{"name":"Polynomial.derivative_add","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\nf g : Polynomial R\n⊢ Eq (Polynomial.derivative (HAdd.hAdd f g)) (HAdd.hAdd (Polynomial.derivative f) (Polynomial.derivative g))","decl":"@[simp]\ntheorem derivative_add {f g : R[X]} : derivative (f + g) = derivative f + derivative g :=\n  derivative.map_add f g\n\n"}
{"name":"Polynomial.derivative_X_add_C","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\nc : R\n⊢ Eq (Polynomial.derivative (HAdd.hAdd Polynomial.X (Polynomial.C c))) 1","decl":"theorem derivative_X_add_C (c : R) : derivative (X + C c) = 1 := by\n  rw [derivative_add, derivative_X, derivative_C, add_zero]\n\n"}
{"name":"Polynomial.derivative_sum","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\nι : Type y\ninst✝ : Semiring R\ns : Finset ι\nf : ι → Polynomial R\n⊢ Eq (Polynomial.derivative (s.sum fun b => f b)) (s.sum fun b => Polynomial.derivative (f b))","decl":"theorem derivative_sum {s : Finset ι} {f : ι → R[X]} :\n    derivative (∑ b ∈ s, f b) = ∑ b ∈ s, derivative (f b) :=\n  map_sum ..\n\n"}
{"name":"Polynomial.iterate_derivative_sum","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\nι : Type y\ninst✝ : Semiring R\nk : Nat\ns : Finset ι\nf : ι → Polynomial R\n⊢ Eq (Nat.iterate (⇑Polynomial.derivative) k (s.sum fun b => f b)) (s.sum fun b => Nat.iterate (⇑Polynomial.derivative) k (f b))","decl":"theorem iterate_derivative_sum (k : ℕ) (s : Finset ι) (f : ι → R[X]) :\n    derivative^[k] (∑ b ∈ s, f b) = ∑ b ∈ s, derivative^[k] (f b) := by\n  simp_rw [← LinearMap.pow_apply, map_sum]\n\n"}
{"name":"Polynomial.derivative_smul","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝³ : Semiring R\nS : Type u_1\ninst✝² : Monoid S\ninst✝¹ : DistribMulAction S R\ninst✝ : IsScalarTower S R R\ns : S\np : Polynomial R\n⊢ Eq (Polynomial.derivative (HSMul.hSMul s p)) (HSMul.hSMul s (Polynomial.derivative p))","decl":"theorem derivative_smul {S : Type*} [Monoid S] [DistribMulAction S R] [IsScalarTower S R R] (s : S)\n    (p : R[X]) : derivative (s • p) = s • derivative p :=\n  derivative.map_smul_of_tower s p\n\n"}
{"name":"Polynomial.iterate_derivative_smul","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝³ : Semiring R\nS : Type u_1\ninst✝² : Monoid S\ninst✝¹ : DistribMulAction S R\ninst✝ : IsScalarTower S R R\ns : S\np : Polynomial R\nk : Nat\n⊢ Eq (Nat.iterate (⇑Polynomial.derivative) k (HSMul.hSMul s p)) (HSMul.hSMul s (Nat.iterate (⇑Polynomial.derivative) k p))","decl":"@[simp]\ntheorem iterate_derivative_smul {S : Type*} [Monoid S] [DistribMulAction S R] [IsScalarTower S R R]\n    (s : S) (p : R[X]) (k : ℕ) : derivative^[k] (s • p) = s • derivative^[k] p := by\n  induction k generalizing p with\n  | zero => simp\n  | succ k ih => simp [ih]\n\n"}
{"name":"Polynomial.iterate_derivative_C_mul","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\na : R\np : Polynomial R\nk : Nat\n⊢ Eq (Nat.iterate (⇑Polynomial.derivative) k (HMul.hMul (Polynomial.C a) p)) (HMul.hMul (Polynomial.C a) (Nat.iterate (⇑Polynomial.derivative) k p))","decl":"@[simp]\ntheorem iterate_derivative_C_mul (a : R) (p : R[X]) (k : ℕ) :\n    derivative^[k] (C a * p) = C a * derivative^[k] p := by\n  simp_rw [← smul_eq_C_mul, iterate_derivative_smul]\n\n"}
{"name":"Polynomial.derivative_C_mul","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\na : R\np : Polynomial R\n⊢ Eq (Polynomial.derivative (HMul.hMul (Polynomial.C a) p)) (HMul.hMul (Polynomial.C a) (Polynomial.derivative p))","decl":"theorem derivative_C_mul (a : R) (p : R[X]) :\n    derivative (C a * p) = C a * derivative p := iterate_derivative_C_mul _ _ 1\n\n"}
{"name":"Polynomial.of_mem_support_derivative","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nn : Nat\nh : Membership.mem (Polynomial.derivative p).support n\n⊢ Membership.mem p.support (HAdd.hAdd n 1)","decl":"theorem of_mem_support_derivative {p : R[X]} {n : ℕ} (h : n ∈ p.derivative.support) :\n    n + 1 ∈ p.support :=\n  mem_support_iff.2 fun h1 : p.coeff (n + 1) = 0 =>\n    mem_support_iff.1 h <| show p.derivative.coeff n = 0 by rw [coeff_derivative, h1, zero_mul]\n\n"}
{"name":"Polynomial.degree_derivative_lt","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nhp : Ne p 0\n⊢ LT.lt (Polynomial.derivative p).degree p.degree","decl":"theorem degree_derivative_lt {p : R[X]} (hp : p ≠ 0) : p.derivative.degree < p.degree :=\n  (Finset.sup_lt_iff <| bot_lt_iff_ne_bot.2 <| mt degree_eq_bot.1 hp).2 fun n hp =>\n    lt_of_lt_of_le (WithBot.coe_lt_coe.2 n.lt_succ_self) <|\n      Finset.le_sup <| of_mem_support_derivative hp\n\n"}
{"name":"Polynomial.degree_derivative_le","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\n⊢ LE.le (Polynomial.derivative p).degree p.degree","decl":"theorem degree_derivative_le {p : R[X]} : p.derivative.degree ≤ p.degree :=\n  letI := Classical.decEq R\n  if H : p = 0 then le_of_eq <| by rw [H, derivative_zero] else (degree_derivative_lt H).le\n\n"}
{"name":"Polynomial.natDegree_derivative_lt","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nhp : Ne p.natDegree 0\n⊢ LT.lt (Polynomial.derivative p).natDegree p.natDegree","decl":"theorem natDegree_derivative_lt {p : R[X]} (hp : p.natDegree ≠ 0) :\n    p.derivative.natDegree < p.natDegree := by\n  rcases eq_or_ne (derivative p) 0 with hp' | hp'\n  · rw [hp', Polynomial.natDegree_zero]\n    exact hp.bot_lt\n  · rw [natDegree_lt_natDegree_iff hp']\n    exact degree_derivative_lt fun h => hp (h.symm ▸ natDegree_zero)\n\n"}
{"name":"Polynomial.natDegree_derivative_le","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\n⊢ LE.le (Polynomial.derivative p).natDegree (HSub.hSub p.natDegree 1)","decl":"theorem natDegree_derivative_le (p : R[X]) : p.derivative.natDegree ≤ p.natDegree - 1 := by\n  by_cases p0 : p.natDegree = 0\n  · simp [p0, derivative_of_natDegree_zero]\n  · exact Nat.le_sub_one_of_lt (natDegree_derivative_lt p0)\n\n"}
{"name":"Polynomial.natDegree_iterate_derivative","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nk : Nat\n⊢ LE.le (Nat.iterate (⇑Polynomial.derivative) k p).natDegree (HSub.hSub p.natDegree k)","decl":"theorem natDegree_iterate_derivative (p : R[X]) (k : ℕ) :\n    (derivative^[k] p).natDegree ≤ p.natDegree - k := by\n  induction k with\n  | zero => rw [Function.iterate_zero_apply, Nat.sub_zero]\n  | succ d hd =>\n      rw [Function.iterate_succ_apply', Nat.sub_succ']\n      exact (natDegree_derivative_le _).trans <| Nat.sub_le_sub_right hd 1\n\n"}
{"name":"Polynomial.derivative_natCast","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\n⊢ Eq (Polynomial.derivative ↑n) 0","decl":"@[simp]\ntheorem derivative_natCast {n : ℕ} : derivative (n : R[X]) = 0 := by\n  rw [← map_natCast C n]\n  exact derivative_C\n\n"}
{"name":"Polynomial.derivative_ofNat","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (Polynomial.derivative (OfNat.ofNat n)) 0","decl":"@[simp]\ntheorem derivative_ofNat (n : ℕ) [n.AtLeastTwo] :\n    derivative (ofNat(n) : R[X]) = 0 :=\n  derivative_natCast\n\n"}
{"name":"Polynomial.iterate_derivative_eq_zero","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nx : Nat\nhx : LT.lt p.natDegree x\n⊢ Eq (Nat.iterate (⇑Polynomial.derivative) x p) 0","decl":"theorem iterate_derivative_eq_zero {p : R[X]} {x : ℕ} (hx : p.natDegree < x) :\n    Polynomial.derivative^[x] p = 0 := by\n  induction' h : p.natDegree using Nat.strong_induction_on with _ ih generalizing p x\n  subst h\n  obtain ⟨t, rfl⟩ := Nat.exists_eq_succ_of_ne_zero (pos_of_gt hx).ne'\n  rw [Function.iterate_succ_apply]\n  by_cases hp : p.natDegree = 0\n  · rw [derivative_of_natDegree_zero hp, iterate_derivative_zero]\n  have := natDegree_derivative_lt hp\n  exact ih _ this (this.trans_le <| Nat.le_of_lt_succ hx) rfl\n\n"}
{"name":"Polynomial.iterate_derivative_C","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\na : R\ninst✝ : Semiring R\nk : Nat\nh : LT.lt 0 k\n⊢ Eq (Nat.iterate (⇑Polynomial.derivative) k (Polynomial.C a)) 0","decl":"@[simp]\ntheorem iterate_derivative_C {k} (h : 0 < k) : derivative^[k] (C a : R[X]) = 0 :=\n  iterate_derivative_eq_zero <| (natDegree_C _).trans_lt h\n\n"}
{"name":"Polynomial.iterate_derivative_one","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\nk : Nat\nh : LT.lt 0 k\n⊢ Eq (Nat.iterate (⇑Polynomial.derivative) k 1) 0","decl":"@[simp]\ntheorem iterate_derivative_one {k} (h : 0 < k) : derivative^[k] (1 : R[X]) = 0 :=\n  iterate_derivative_C h\n\n"}
{"name":"Polynomial.iterate_derivative_X","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\nk : Nat\nh : LT.lt 1 k\n⊢ Eq (Nat.iterate (⇑Polynomial.derivative) k Polynomial.X) 0","decl":"@[simp]\ntheorem iterate_derivative_X {k} (h : 1 < k) : derivative^[k] (X : R[X]) = 0 :=\n  iterate_derivative_eq_zero <| natDegree_X_le.trans_lt h\n\n"}
{"name":"Polynomial.natDegree_eq_zero_of_derivative_eq_zero","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : NoZeroSMulDivisors Nat R\nf : Polynomial R\nh : Eq (Polynomial.derivative f) 0\n⊢ Eq f.natDegree 0","decl":"theorem natDegree_eq_zero_of_derivative_eq_zero [NoZeroSMulDivisors ℕ R] {f : R[X]}\n    (h : derivative f = 0) : f.natDegree = 0 := by\n  rcases eq_or_ne f 0 with (rfl | hf)\n  · exact natDegree_zero\n  rw [natDegree_eq_zero_iff_degree_le_zero]\n  by_contra! f_nat_degree_pos\n  rw [← natDegree_pos_iff_degree_pos] at f_nat_degree_pos\n  let m := f.natDegree - 1\n  have hm : m + 1 = f.natDegree := tsub_add_cancel_of_le f_nat_degree_pos\n  have h2 := coeff_derivative f m\n  rw [Polynomial.ext_iff] at h\n  rw [h m, coeff_zero, ← Nat.cast_add_one, ← nsmul_eq_mul', eq_comm, smul_eq_zero] at h2\n  replace h2 := h2.resolve_left m.succ_ne_zero\n  rw [hm, ← leadingCoeff, leadingCoeff_eq_zero] at h2\n  exact hf h2\n\n"}
{"name":"Polynomial.eq_C_of_derivative_eq_zero","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : NoZeroSMulDivisors Nat R\nf : Polynomial R\nh : Eq (Polynomial.derivative f) 0\n⊢ Eq f (Polynomial.C (f.coeff 0))","decl":"theorem eq_C_of_derivative_eq_zero [NoZeroSMulDivisors ℕ R] {f : R[X]} (h : derivative f = 0) :\n    f = C (f.coeff 0) :=\n  eq_C_of_natDegree_eq_zero <| natDegree_eq_zero_of_derivative_eq_zero h\n\n"}
{"name":"Polynomial.derivative_mul","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\nf g : Polynomial R\n⊢ Eq (Polynomial.derivative (HMul.hMul f g)) (HAdd.hAdd (HMul.hMul (Polynomial.derivative f) g) (HMul.hMul f (Polynomial.derivative g)))","decl":"@[simp]\ntheorem derivative_mul {f g : R[X]} : derivative (f * g) = derivative f * g + f * derivative g := by\n  induction f using Polynomial.induction_on' with\n  | h_add => simp only [add_mul, map_add, add_assoc, add_left_comm, *]\n  | h_monomial m a =>\n  induction g using Polynomial.induction_on' with\n  | h_add => simp only [mul_add, map_add, add_assoc, add_left_comm, *]\n  | h_monomial n b =>\n  simp only [monomial_mul_monomial, derivative_monomial]\n  simp only [mul_assoc, (Nat.cast_commute _ _).eq, Nat.cast_add, mul_add, map_add]\n  cases m with\n  | zero => simp only [zero_add, Nat.cast_zero, mul_zero, map_zero]\n  | succ m =>\n  cases n with\n  | zero => simp only [add_zero, Nat.cast_zero, mul_zero, map_zero]\n  | succ n =>\n  simp only [Nat.add_succ_sub_one, add_tsub_cancel_right]\n  rw [add_assoc, add_comm n 1]\n\n"}
{"name":"Polynomial.derivative_eval","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nx : R\n⊢ Eq (Polynomial.eval x (Polynomial.derivative p)) (p.sum fun n a => HMul.hMul (HMul.hMul a ↑n) (HPow.hPow x (HSub.hSub n 1)))","decl":"theorem derivative_eval (p : R[X]) (x : R) :\n    p.derivative.eval x = p.sum fun n a => a * n * x ^ (n - 1) := by\n  simp_rw [derivative_apply, eval_sum, eval_mul_X_pow, eval_C]\n\n"}
{"name":"Polynomial.derivative_map","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\np : Polynomial R\nf : RingHom R S\n⊢ Eq (Polynomial.derivative (Polynomial.map f p)) (Polynomial.map f (Polynomial.derivative p))","decl":"@[simp]\ntheorem derivative_map [Semiring S] (p : R[X]) (f : R →+* S) :\n    derivative (p.map f) = p.derivative.map f := by\n  let n := max p.natDegree (map f p).natDegree\n  rw [derivative_apply, derivative_apply]\n  rw [sum_over_range' _ _ (n + 1) ((le_max_left _ _).trans_lt (lt_add_one _))]\n  on_goal 1 => rw [sum_over_range' _ _ (n + 1) ((le_max_right _ _).trans_lt (lt_add_one _))]\n  · simp only [Polynomial.map_sum, Polynomial.map_mul, Polynomial.map_C, map_mul, coeff_map,\n      map_natCast, Polynomial.map_natCast, Polynomial.map_pow, map_X]\n  all_goals intro n; rw [zero_mul, C_0, zero_mul]\n\n"}
{"name":"Polynomial.iterate_derivative_map","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\np : Polynomial R\nf : RingHom R S\nk : Nat\n⊢ Eq (Nat.iterate (⇑Polynomial.derivative) k (Polynomial.map f p)) (Polynomial.map f (Nat.iterate (⇑Polynomial.derivative) k p))","decl":"@[simp]\ntheorem iterate_derivative_map [Semiring S] (p : R[X]) (f : R →+* S) (k : ℕ) :\n    Polynomial.derivative^[k] (p.map f) = (Polynomial.derivative^[k] p).map f := by\n  induction' k with k ih generalizing p\n  · simp\n  · simp only [ih, Function.iterate_succ, Polynomial.derivative_map, Function.comp_apply]\n\n"}
{"name":"Polynomial.derivative_natCast_mul","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\nf : Polynomial R\n⊢ Eq (Polynomial.derivative (HMul.hMul (↑n) f)) (HMul.hMul (↑n) (Polynomial.derivative f))","decl":"theorem derivative_natCast_mul {n : ℕ} {f : R[X]} :\n    derivative ((n : R[X]) * f) = n * derivative f := by\n  simp\n\n"}
{"name":"Polynomial.iterate_derivative_natCast_mul","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\nn k : Nat\nf : Polynomial R\n⊢ Eq (Nat.iterate (⇑Polynomial.derivative) k (HMul.hMul (↑n) f)) (HMul.hMul (↑n) (Nat.iterate (⇑Polynomial.derivative) k f))","decl":"@[simp]\ntheorem iterate_derivative_natCast_mul {n k : ℕ} {f : R[X]} :\n    derivative^[k] ((n : R[X]) * f) = n * derivative^[k] f := by\n  induction' k with k ih generalizing f <;> simp [*]\n\n"}
{"name":"Polynomial.mem_support_derivative","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : NoZeroSMulDivisors Nat R\np : Polynomial R\nn : Nat\n⊢ Iff (Membership.mem (Polynomial.derivative p).support n) (Membership.mem p.support (HAdd.hAdd n 1))","decl":"theorem mem_support_derivative [NoZeroSMulDivisors ℕ R] (p : R[X]) (n : ℕ) :\n    n ∈ (derivative p).support ↔ n + 1 ∈ p.support := by\n  suffices ¬p.coeff (n + 1) * (n + 1 : ℕ) = 0 ↔ coeff p (n + 1) ≠ 0 by\n    simpa only [mem_support_iff, coeff_derivative, Ne, Nat.cast_succ]\n  rw [← nsmul_eq_mul', smul_eq_zero]\n  simp only [Nat.succ_ne_zero, false_or]\n\n"}
{"name":"Polynomial.degree_derivative_eq","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : NoZeroSMulDivisors Nat R\np : Polynomial R\nhp : LT.lt 0 p.natDegree\n⊢ Eq (Polynomial.derivative p).degree ↑(HSub.hSub p.natDegree 1)","decl":"@[simp]\ntheorem degree_derivative_eq [NoZeroSMulDivisors ℕ R] (p : R[X]) (hp : 0 < natDegree p) :\n    degree (derivative p) = (natDegree p - 1 : ℕ) := by\n  apply le_antisymm\n  · rw [derivative_apply]\n    apply le_trans (degree_sum_le _ _) (Finset.sup_le _)\n    intro n hn\n    apply le_trans (degree_C_mul_X_pow_le _ _) (WithBot.coe_le_coe.2 (tsub_le_tsub_right _ _))\n    apply le_natDegree_of_mem_supp _ hn\n  · refine le_sup ?_\n    rw [mem_support_derivative, tsub_add_cancel_of_le, mem_support_iff]\n    · rw [coeff_natDegree, Ne, leadingCoeff_eq_zero]\n      intro h\n      rw [h, natDegree_zero] at hp\n      exact hp.false\n    exact hp\n\n"}
{"name":"Polynomial.coeff_iterate_derivative","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\nk : Nat\np : Polynomial R\nm : Nat\n⊢ Eq ((Nat.iterate (⇑Polynomial.derivative) k p).coeff m) (HSMul.hSMul ((HAdd.hAdd m k).descFactorial k) (p.coeff (HAdd.hAdd m k)))","decl":"theorem coeff_iterate_derivative {k} (p : R[X]) (m : ℕ) :\n    (derivative^[k] p).coeff m = (m + k).descFactorial k • p.coeff (m + k) := by\n  induction k generalizing m with\n  | zero => simp\n  | succ k ih =>\n      calc\n        (derivative^[k + 1] p).coeff m\n        _ = Nat.descFactorial (Nat.succ (m + k)) k • p.coeff (m + k.succ) * (m + 1) := by\n          rw [Function.iterate_succ_apply', coeff_derivative, ih m.succ, Nat.succ_add, Nat.add_succ]\n        _ = ((m + 1) * Nat.descFactorial (Nat.succ (m + k)) k) • p.coeff (m + k.succ) := by\n          rw [← Nat.cast_add_one, ← nsmul_eq_mul', smul_smul]\n        _ = Nat.descFactorial (m.succ + k) k.succ • p.coeff (m + k.succ) := by\n          rw [← Nat.succ_add, Nat.descFactorial_succ, add_tsub_cancel_right]\n        _ = Nat.descFactorial (m + k.succ) k.succ • p.coeff (m + k.succ) := by\n          rw [Nat.succ_add_eq_add_succ]\n\n"}
{"name":"Polynomial.iterate_derivative_eq_sum","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nk : Nat\n⊢ Eq (Nat.iterate (⇑Polynomial.derivative) k p) ((Nat.iterate (⇑Polynomial.derivative) k p).support.sum fun x => HMul.hMul (Polynomial.C (HSMul.hSMul ((HAdd.hAdd x k).descFactorial k) (p.coeff (HAdd.hAdd x k)))) (HPow.hPow Polynomial.X x))","decl":"theorem iterate_derivative_eq_sum (p : R[X]) (k : ℕ) :\n    derivative^[k] p =\n      ∑ x ∈ (derivative^[k] p).support, C ((x + k).descFactorial k • p.coeff (x + k)) * X ^ x := by\n  conv_lhs => rw [(derivative^[k] p).as_sum_support_C_mul_X_pow]\n  refine sum_congr rfl fun i _ ↦ ?_\n  rw [coeff_iterate_derivative, Nat.descFactorial_eq_factorial_mul_choose]\n\n"}
{"name":"Polynomial.iterate_derivative_eq_factorial_smul_sum","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nk : Nat\n⊢ Eq (Nat.iterate (⇑Polynomial.derivative) k p) (HSMul.hSMul k.factorial ((Nat.iterate (⇑Polynomial.derivative) k p).support.sum fun x => HMul.hMul (Polynomial.C (HSMul.hSMul ((HAdd.hAdd x k).choose k) (p.coeff (HAdd.hAdd x k)))) (HPow.hPow Polynomial.X x)))","decl":"theorem iterate_derivative_eq_factorial_smul_sum (p : R[X]) (k : ℕ) :\n    derivative^[k] p = k ! •\n      ∑ x ∈ (derivative^[k] p).support, C ((x + k).choose k • p.coeff (x + k)) * X ^ x := by\n  conv_lhs => rw [iterate_derivative_eq_sum]\n  rw [smul_sum]\n  refine sum_congr rfl fun i _ ↦ ?_\n  rw [← smul_mul_assoc, smul_C, smul_smul, Nat.descFactorial_eq_factorial_mul_choose]\n\n"}
{"name":"Polynomial.iterate_derivative_mul","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\np q : Polynomial R\n⊢ Eq (Nat.iterate (⇑Polynomial.derivative) n (HMul.hMul p q)) ((Finset.range n.succ).sum fun k => HSMul.hSMul (n.choose k) (HMul.hMul (Nat.iterate (⇑Polynomial.derivative) (HSub.hSub n k) p) (Nat.iterate (⇑Polynomial.derivative) k q)))","decl":"theorem iterate_derivative_mul {n} (p q : R[X]) :\n    derivative^[n] (p * q) =\n      ∑ k ∈ range n.succ, (n.choose k • (derivative^[n - k] p * derivative^[k] q)) := by\n  induction n with\n  | zero =>\n    simp [Finset.range]\n  | succ n IH =>\n    calc\n      derivative^[n + 1] (p * q) =\n          derivative (∑ k ∈ range n.succ,\n              n.choose k • (derivative^[n - k] p * derivative^[k] q)) := by\n        rw [Function.iterate_succ_apply', IH]\n      _ = (∑ k ∈ range n.succ,\n            n.choose k • (derivative^[n - k + 1] p * derivative^[k] q)) +\n          ∑ k ∈ range n.succ,\n            n.choose k • (derivative^[n - k] p * derivative^[k + 1] q) := by\n        simp_rw [derivative_sum, derivative_smul, derivative_mul, Function.iterate_succ_apply',\n          smul_add, sum_add_distrib]\n      _ = (∑ k ∈ range n.succ,\n                n.choose k.succ • (derivative^[n - k] p * derivative^[k + 1] q)) +\n              1 • (derivative^[n + 1] p * derivative^[0] q) +\n            ∑ k ∈ range n.succ, n.choose k • (derivative^[n - k] p * derivative^[k + 1] q) :=\n        ?_\n      _ = ((∑ k ∈ range n.succ, n.choose k • (derivative^[n - k] p * derivative^[k + 1] q)) +\n              ∑ k ∈ range n.succ,\n                n.choose k.succ • (derivative^[n - k] p * derivative^[k + 1] q)) +\n            1 • (derivative^[n + 1] p * derivative^[0] q) := by\n        rw [add_comm, add_assoc]\n      _ = (∑ i ∈ range n.succ,\n              (n + 1).choose (i + 1) • (derivative^[n + 1 - (i + 1)] p * derivative^[i + 1] q)) +\n            1 • (derivative^[n + 1] p * derivative^[0] q) := by\n        simp_rw [Nat.choose_succ_succ, Nat.succ_sub_succ, add_smul, sum_add_distrib]\n      _ = ∑ k ∈ range n.succ.succ,\n            n.succ.choose k • (derivative^[n.succ - k] p * derivative^[k] q) := by\n        rw [sum_range_succ' _ n.succ, Nat.choose_zero_right, tsub_zero]\n    congr\n    refine (sum_range_succ' _ _).trans (congr_arg₂ (· + ·) ?_ ?_)\n    · rw [sum_range_succ, Nat.choose_succ_self, zero_smul, add_zero]\n      refine sum_congr rfl fun k hk => ?_\n      rw [mem_range] at hk\n      congr\n      omega\n    · rw [Nat.choose_zero_right, tsub_zero]\n\n"}
{"name":"Polynomial.derivativeFinsupp_apply_toFun","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nx✝ : Nat\n⊢ Eq ((Polynomial.derivativeFinsupp p) x✝) (Nat.iterate (⇑Polynomial.derivative) x✝ p)","decl":"/--\nIterated derivatives as a finite support function.\n-/\n@[simps! apply_toFun]\nnoncomputable def derivativeFinsupp : R[X] →ₗ[R] ℕ →₀ R[X] where\n  toFun p := .onFinset (range (p.natDegree + 1)) (derivative^[·] p) fun i ↦ by\n    contrapose; simp_all [iterate_derivative_eq_zero, Nat.succ_le]\n  map_add' _ _ := by ext; simp\n  map_smul' _ _ := by ext; simp\n\n"}
{"name":"Polynomial.support_derivativeFinsupp_subset_range","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nn : Nat\nh : LT.lt p.natDegree n\n⊢ HasSubset.Subset (Polynomial.derivativeFinsupp p).support (Finset.range n)","decl":"@[simp]\ntheorem support_derivativeFinsupp_subset_range {p : R[X]} {n : ℕ} (h : p.natDegree < n) :\n    (derivativeFinsupp p).support ⊆ range n := by\n  dsimp [derivativeFinsupp]\n  exact Finsupp.support_onFinset_subset.trans (Finset.range_subset.mpr h)\n\n"}
{"name":"Polynomial.derivativeFinsupp_C","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\nr : R\n⊢ Eq (Polynomial.derivativeFinsupp (Polynomial.C r)) (Finsupp.single 0 (Polynomial.C r))","decl":"@[simp]\ntheorem derivativeFinsupp_C (r : R) : derivativeFinsupp (C r : R[X]) = .single 0 (C r) := by\n  ext i : 1\n  match i with\n  | 0 => simp\n  | i + 1 => simp\n\n"}
{"name":"Polynomial.derivativeFinsupp_one","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Eq (Polynomial.derivativeFinsupp 1) (Finsupp.single 0 1)","decl":"@[simp]\ntheorem derivativeFinsupp_one : derivativeFinsupp (1 : R[X]) = .single 0 1 := by\n  simpa using derivativeFinsupp_C (1 : R)\n\n"}
{"name":"Polynomial.derivativeFinsupp_X","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Eq (Polynomial.derivativeFinsupp Polynomial.X) (HAdd.hAdd (Finsupp.single 0 Polynomial.X) (Finsupp.single 1 1))","decl":"@[simp]\ntheorem derivativeFinsupp_X : derivativeFinsupp (X : R[X]) = .single 0 X + .single 1 1 := by\n  ext i : 1\n  match i with\n  | 0 => simp\n  | 1 => simp\n  | (n + 2) => simp\n\n"}
{"name":"Polynomial.derivativeFinsupp_map","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\np : Polynomial R\nf : RingHom R S\n⊢ Eq (Polynomial.derivativeFinsupp (Polynomial.map f p)) (Finsupp.mapRange (fun x => Polynomial.map f x) ⋯ (Polynomial.derivativeFinsupp p))","decl":"theorem derivativeFinsupp_map [Semiring S] (p : R[X]) (f : R →+* S) :\n    derivativeFinsupp (p.map f) = (derivativeFinsupp p).mapRange (·.map f) (by simp) := by\n  ext i : 1\n  simp\n\n"}
{"name":"Polynomial.derivativeFinsupp_derivative","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\n⊢ Eq (Polynomial.derivativeFinsupp (Polynomial.derivative p)) (Finsupp.comapDomain Nat.succ (Polynomial.derivativeFinsupp p) ⋯)","decl":"theorem derivativeFinsupp_derivative (p : R[X]) :\n    derivativeFinsupp (derivative p) =\n      (derivativeFinsupp p).comapDomain Nat.succ Nat.succ_injective.injOn := by\n  ext i : 1\n  simp\n\n"}
{"name":"Polynomial.derivative_pow_succ","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : Polynomial R\nn : Nat\n⊢ Eq (Polynomial.derivative (HPow.hPow p (HAdd.hAdd n 1))) (HMul.hMul (HMul.hMul (Polynomial.C (HAdd.hAdd (↑n) 1)) (HPow.hPow p n)) (Polynomial.derivative p))","decl":"theorem derivative_pow_succ (p : R[X]) (n : ℕ) :\n    derivative (p ^ (n + 1)) = C (n + 1 : R) * p ^ n * derivative p :=\n  Nat.recOn n (by simp) fun n ih => by\n    rw [pow_succ, derivative_mul, ih, Nat.add_one, mul_right_comm, C_add,\n      add_mul, add_mul, pow_succ, ← mul_assoc, C_1, one_mul]; simp [add_mul]\n\n"}
{"name":"Polynomial.derivative_pow","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : Polynomial R\nn : Nat\n⊢ Eq (Polynomial.derivative (HPow.hPow p n)) (HMul.hMul (HMul.hMul (Polynomial.C ↑n) (HPow.hPow p (HSub.hSub n 1))) (Polynomial.derivative p))","decl":"theorem derivative_pow (p : R[X]) (n : ℕ) :\n    derivative (p ^ n) = C (n : R) * p ^ (n - 1) * derivative p :=\n  Nat.casesOn n (by rw [pow_zero, derivative_one, Nat.cast_zero, C_0, zero_mul, zero_mul]) fun n =>\n    by rw [p.derivative_pow_succ n, Nat.add_one_sub_one, n.cast_succ]\n\n"}
{"name":"Polynomial.derivative_sq","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : Polynomial R\n⊢ Eq (Polynomial.derivative (HPow.hPow p 2)) (HMul.hMul (HMul.hMul (Polynomial.C 2) p) (Polynomial.derivative p))","decl":"theorem derivative_sq (p : R[X]) : derivative (p ^ 2) = C 2 * p * derivative p := by\n  rw [derivative_pow_succ, Nat.cast_one, one_add_one_eq_two, pow_one]\n\n"}
{"name":"Polynomial.pow_sub_one_dvd_derivative_of_pow_dvd","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np q : Polynomial R\nn : Nat\ndvd : Dvd.dvd (HPow.hPow q n) p\n⊢ Dvd.dvd (HPow.hPow q (HSub.hSub n 1)) (Polynomial.derivative p)","decl":"theorem pow_sub_one_dvd_derivative_of_pow_dvd {p q : R[X]} {n : ℕ}\n    (dvd : q ^ n ∣ p) : q ^ (n - 1) ∣ derivative p := by\n  obtain ⟨r, rfl⟩ := dvd\n  rw [derivative_mul, derivative_pow]\n  exact (((dvd_mul_left _ _).mul_right _).mul_right _).add ((pow_dvd_pow q n.pred_le).mul_right _)\n\n"}
{"name":"Polynomial.pow_sub_dvd_iterate_derivative_of_pow_dvd","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np q : Polynomial R\nn m : Nat\ndvd : Dvd.dvd (HPow.hPow q n) p\n⊢ Dvd.dvd (HPow.hPow q (HSub.hSub n m)) (Nat.iterate (⇑Polynomial.derivative) m p)","decl":"theorem pow_sub_dvd_iterate_derivative_of_pow_dvd {p q : R[X]} {n : ℕ} (m : ℕ)\n    (dvd : q ^ n ∣ p) : q ^ (n - m) ∣ derivative^[m] p := by\n  induction m generalizing p with\n  | zero => simpa\n  | succ m ih =>\n    rw [Nat.sub_succ, Function.iterate_succ']\n    exact pow_sub_one_dvd_derivative_of_pow_dvd (ih dvd)\n\n"}
{"name":"Polynomial.pow_sub_dvd_iterate_derivative_pow","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : Polynomial R\nn m : Nat\n⊢ Dvd.dvd (HPow.hPow p (HSub.hSub n m)) (Nat.iterate (⇑Polynomial.derivative) m (HPow.hPow p n))","decl":"theorem pow_sub_dvd_iterate_derivative_pow (p : R[X]) (n m : ℕ) :\n    p ^ (n - m) ∣ derivative^[m] (p ^ n) := pow_sub_dvd_iterate_derivative_of_pow_dvd m dvd_rfl\n\n"}
{"name":"Polynomial.dvd_iterate_derivative_pow","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf : Polynomial R\nn m : Nat\nc : R\nhm : Ne m 0\n⊢ Dvd.dvd (↑n) (Polynomial.eval c (Nat.iterate (⇑Polynomial.derivative) m (HPow.hPow f n)))","decl":"theorem dvd_iterate_derivative_pow (f : R[X]) (n : ℕ) {m : ℕ} (c : R) (hm : m ≠ 0) :\n    (n : R) ∣ eval c (derivative^[m] (f ^ n)) := by\n  obtain ⟨m, rfl⟩ := Nat.exists_eq_succ_of_ne_zero hm\n  rw [Function.iterate_succ_apply, derivative_pow, mul_assoc, C_eq_natCast,\n    iterate_derivative_natCast_mul, eval_mul, eval_natCast]\n  exact dvd_mul_right _ _\n\n"}
{"name":"Polynomial.iterate_derivative_X_pow_eq_natCast_mul","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nn k : Nat\n⊢ Eq (Nat.iterate (⇑Polynomial.derivative) k (HPow.hPow Polynomial.X n)) (HMul.hMul (↑(n.descFactorial k)) (HPow.hPow Polynomial.X (HSub.hSub n k)))","decl":"theorem iterate_derivative_X_pow_eq_natCast_mul (n k : ℕ) :\n    derivative^[k] (X ^ n : R[X]) = ↑(Nat.descFactorial n k : R[X]) * X ^ (n - k) := by\n  induction k with\n  | zero =>\n    rw [Function.iterate_zero_apply, tsub_zero, Nat.descFactorial_zero, Nat.cast_one, one_mul]\n  | succ k ih =>\n    rw [Function.iterate_succ_apply', ih, derivative_natCast_mul, derivative_X_pow, C_eq_natCast,\n      Nat.descFactorial_succ, Nat.sub_sub, Nat.cast_mul]\n    simp [mul_comm, mul_assoc, mul_left_comm]\n\n"}
{"name":"Polynomial.iterate_derivative_X_pow_eq_C_mul","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nn k : Nat\n⊢ Eq (Nat.iterate (⇑Polynomial.derivative) k (HPow.hPow Polynomial.X n)) (HMul.hMul (Polynomial.C ↑(n.descFactorial k)) (HPow.hPow Polynomial.X (HSub.hSub n k)))","decl":"theorem iterate_derivative_X_pow_eq_C_mul (n k : ℕ) :\n    derivative^[k] (X ^ n : R[X]) = C (Nat.descFactorial n k : R) * X ^ (n - k) := by\n  rw [iterate_derivative_X_pow_eq_natCast_mul n k, C_eq_natCast]\n\n"}
{"name":"Polynomial.iterate_derivative_X_pow_eq_smul","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nn k : Nat\n⊢ Eq (Nat.iterate (⇑Polynomial.derivative) k (HPow.hPow Polynomial.X n)) (HSMul.hSMul (↑(n.descFactorial k)) (HPow.hPow Polynomial.X (HSub.hSub n k)))","decl":"theorem iterate_derivative_X_pow_eq_smul (n : ℕ) (k : ℕ) :\n    derivative^[k] (X ^ n : R[X]) = (Nat.descFactorial n k : R) • X ^ (n - k) := by\n  rw [iterate_derivative_X_pow_eq_C_mul n k, smul_eq_C_mul]\n\n"}
{"name":"Polynomial.derivative_X_add_C_pow","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nc : R\nm : Nat\n⊢ Eq (Polynomial.derivative (HPow.hPow (HAdd.hAdd Polynomial.X (Polynomial.C c)) m)) (HMul.hMul (Polynomial.C ↑m) (HPow.hPow (HAdd.hAdd Polynomial.X (Polynomial.C c)) (HSub.hSub m 1)))","decl":"theorem derivative_X_add_C_pow (c : R) (m : ℕ) :\n    derivative ((X + C c) ^ m) = C (m : R) * (X + C c) ^ (m - 1) := by\n  rw [derivative_pow, derivative_X_add_C, mul_one]\n\n"}
{"name":"Polynomial.derivative_X_add_C_sq","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nc : R\n⊢ Eq (Polynomial.derivative (HPow.hPow (HAdd.hAdd Polynomial.X (Polynomial.C c)) 2)) (HMul.hMul (Polynomial.C 2) (HAdd.hAdd Polynomial.X (Polynomial.C c)))","decl":"theorem derivative_X_add_C_sq (c : R) : derivative ((X + C c) ^ 2) = C 2 * (X + C c) := by\n  rw [derivative_sq, derivative_X_add_C, mul_one]\n\n"}
{"name":"Polynomial.iterate_derivative_X_add_pow","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nn k : Nat\nc : R\n⊢ Eq (Nat.iterate (⇑Polynomial.derivative) k (HPow.hPow (HAdd.hAdd Polynomial.X (Polynomial.C c)) n)) (HSMul.hSMul (n.descFactorial k) (HPow.hPow (HAdd.hAdd Polynomial.X (Polynomial.C c)) (HSub.hSub n k)))","decl":"theorem iterate_derivative_X_add_pow (n k : ℕ) (c : R) :\n    derivative^[k] ((X + C c) ^ n) = Nat.descFactorial n k • (X + C c) ^ (n - k) := by\n  induction k with\n  | zero => simp\n  | succ k IH =>\n      rw [Nat.sub_succ', Function.iterate_succ_apply', IH, derivative_smul,\n        derivative_X_add_C_pow, map_natCast, Nat.descFactorial_succ, nsmul_eq_mul, nsmul_eq_mul,\n        Nat.cast_mul]\n      ring\n\n"}
{"name":"Polynomial.derivative_comp","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np q : Polynomial R\n⊢ Eq (Polynomial.derivative (p.comp q)) (HMul.hMul (Polynomial.derivative q) ((Polynomial.derivative p).comp q))","decl":"theorem derivative_comp (p q : R[X]) :\n    derivative (p.comp q) = derivative q * p.derivative.comp q := by\n  induction p using Polynomial.induction_on'\n  · simp [*, mul_add]\n  · simp only [derivative_pow, derivative_mul, monomial_comp, derivative_monomial, derivative_C,\n      zero_mul, C_eq_natCast, zero_add, RingHom.map_mul]\n    ring\n\n"}
{"name":"Polynomial.derivative_eval₂_C","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np q : Polynomial R\n⊢ Eq (Polynomial.derivative (Polynomial.eval₂ Polynomial.C q p)) (HMul.hMul (Polynomial.eval₂ Polynomial.C q (Polynomial.derivative p)) (Polynomial.derivative q))","decl":"/-- Chain rule for formal derivative of polynomials. -/\ntheorem derivative_eval₂_C (p q : R[X]) :\n    derivative (p.eval₂ C q) = p.derivative.eval₂ C q * derivative q :=\n  Polynomial.induction_on p (fun r => by rw [eval₂_C, derivative_C, eval₂_zero, zero_mul])\n    (fun p₁ p₂ ih₁ ih₂ => by\n      rw [eval₂_add, derivative_add, ih₁, ih₂, derivative_add, eval₂_add, add_mul])\n    fun n r ih => by\n    rw [pow_succ, ← mul_assoc, eval₂_mul, eval₂_X, derivative_mul, ih, @derivative_mul _ _ _ X,\n      derivative_X, mul_one, eval₂_add, @eval₂_mul _ _ _ _ X, eval₂_X, add_mul, mul_right_comm]\n\n"}
{"name":"Polynomial.derivative_prod","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\nι : Type y\ninst✝¹ : CommSemiring R\ninst✝ : DecidableEq ι\ns : Multiset ι\nf : ι → Polynomial R\n⊢ Eq (Polynomial.derivative (Multiset.map f s).prod) (Multiset.map (fun i => HMul.hMul (Multiset.map f (s.erase i)).prod (Polynomial.derivative (f i))) s).sum","decl":"theorem derivative_prod [DecidableEq ι] {s : Multiset ι} {f : ι → R[X]} :\n    derivative (Multiset.map f s).prod =\n      (Multiset.map (fun i => (Multiset.map f (s.erase i)).prod * derivative (f i)) s).sum := by\n  refine Multiset.induction_on s (by simp) fun i s h => ?_\n  rw [Multiset.map_cons, Multiset.prod_cons, derivative_mul, Multiset.map_cons _ i s,\n    Multiset.sum_cons, Multiset.erase_cons_head, mul_comm (derivative (f i))]\n  congr\n  rw [h, ← AddMonoidHom.coe_mulLeft, (AddMonoidHom.mulLeft (f i)).map_multiset_sum _,\n    AddMonoidHom.coe_mulLeft]\n  simp only [Function.comp_apply, Multiset.map_map]\n  refine congr_arg _ (Multiset.map_congr rfl fun j hj => ?_)\n  rw [← mul_assoc, ← Multiset.prod_cons, ← Multiset.map_cons]\n  by_cases hij : i = j\n  · simp [hij, ← Multiset.prod_cons, ← Multiset.map_cons, Multiset.cons_erase hj]\n  · simp [hij]\n\n"}
{"name":"Polynomial.derivative_neg","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Ring R\nf : Polynomial R\n⊢ Eq (Polynomial.derivative (Neg.neg f)) (Neg.neg (Polynomial.derivative f))","decl":"@[simp]\ntheorem derivative_neg (f : R[X]) : derivative (-f) = -derivative f :=\n  LinearMap.map_neg derivative f\n\n"}
{"name":"Polynomial.iterate_derivative_neg","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Ring R\nf : Polynomial R\nk : Nat\n⊢ Eq (Nat.iterate (⇑Polynomial.derivative) k (Neg.neg f)) (Neg.neg (Nat.iterate (⇑Polynomial.derivative) k f))","decl":"theorem iterate_derivative_neg {f : R[X]} {k : ℕ} : derivative^[k] (-f) = -derivative^[k] f :=\n  iterate_map_neg derivative k f\n\n"}
{"name":"Polynomial.derivative_sub","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Ring R\nf g : Polynomial R\n⊢ Eq (Polynomial.derivative (HSub.hSub f g)) (HSub.hSub (Polynomial.derivative f) (Polynomial.derivative g))","decl":"@[simp]\ntheorem derivative_sub {f g : R[X]} : derivative (f - g) = derivative f - derivative g :=\n  LinearMap.map_sub derivative f g\n\n"}
{"name":"Polynomial.derivative_X_sub_C","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Ring R\nc : R\n⊢ Eq (Polynomial.derivative (HSub.hSub Polynomial.X (Polynomial.C c))) 1","decl":"theorem derivative_X_sub_C (c : R) : derivative (X - C c) = 1 := by\n  rw [derivative_sub, derivative_X, derivative_C, sub_zero]\n\n"}
{"name":"Polynomial.iterate_derivative_sub","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Ring R\nk : Nat\nf g : Polynomial R\n⊢ Eq (Nat.iterate (⇑Polynomial.derivative) k (HSub.hSub f g)) (HSub.hSub (Nat.iterate (⇑Polynomial.derivative) k f) (Nat.iterate (⇑Polynomial.derivative) k g))","decl":"theorem iterate_derivative_sub {k : ℕ} {f g : R[X]} :\n    derivative^[k] (f - g) = derivative^[k] f - derivative^[k] g :=\n  iterate_map_sub derivative k f g\n\n"}
{"name":"Polynomial.derivative_intCast","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Ring R\nn : Int\n⊢ Eq (Polynomial.derivative ↑n) 0","decl":"@[simp]\ntheorem derivative_intCast {n : ℤ} : derivative (n : R[X]) = 0 := by\n  rw [← C_eq_intCast n]\n  exact derivative_C\n\n"}
{"name":"Polynomial.derivative_intCast_mul","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Ring R\nn : Int\nf : Polynomial R\n⊢ Eq (Polynomial.derivative (HMul.hMul (↑n) f)) (HMul.hMul (↑n) (Polynomial.derivative f))","decl":"theorem derivative_intCast_mul {n : ℤ} {f : R[X]} : derivative ((n : R[X]) * f) =\n    n * derivative f := by\n  simp\n\n"}
{"name":"Polynomial.iterate_derivative_intCast_mul","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : Ring R\nn : Int\nk : Nat\nf : Polynomial R\n⊢ Eq (Nat.iterate (⇑Polynomial.derivative) k (HMul.hMul (↑n) f)) (HMul.hMul (↑n) (Nat.iterate (⇑Polynomial.derivative) k f))","decl":"@[simp]\ntheorem iterate_derivative_intCast_mul {n : ℤ} {k : ℕ} {f : R[X]} :\n    derivative^[k] ((n : R[X]) * f) = n * derivative^[k] f := by\n  induction' k with k ih generalizing f <;> simp [*]\n\n"}
{"name":"Polynomial.derivative_comp_one_sub_X","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\n⊢ Eq (Polynomial.derivative (p.comp (HSub.hSub 1 Polynomial.X))) (Neg.neg ((Polynomial.derivative p).comp (HSub.hSub 1 Polynomial.X)))","decl":"theorem derivative_comp_one_sub_X (p : R[X]) :\n    derivative (p.comp (1 - X)) = -p.derivative.comp (1 - X) := by simp [derivative_comp]\n\n"}
{"name":"Polynomial.iterate_derivative_comp_one_sub_X","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\nk : Nat\n⊢ Eq (Nat.iterate (⇑Polynomial.derivative) k (p.comp (HSub.hSub 1 Polynomial.X))) (HMul.hMul (HPow.hPow (-1) k) ((Nat.iterate (⇑Polynomial.derivative) k p).comp (HSub.hSub 1 Polynomial.X)))","decl":"@[simp]\ntheorem iterate_derivative_comp_one_sub_X (p : R[X]) (k : ℕ) :\n    derivative^[k] (p.comp (1 - X)) = (-1) ^ k * (derivative^[k] p).comp (1 - X) := by\n  induction' k with k ih generalizing p\n  · simp\n  · simp [ih (derivative p), iterate_derivative_neg, derivative_comp, pow_succ]\n\n"}
{"name":"Polynomial.eval_multiset_prod_X_sub_C_derivative","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : DecidableEq R\nS : Multiset R\nr : R\nhr : Membership.mem S r\n⊢ Eq (Polynomial.eval r (Polynomial.derivative (Multiset.map (fun a => HSub.hSub Polynomial.X (Polynomial.C a)) S).prod)) (Multiset.map (fun a => HSub.hSub r a) (S.erase r)).prod","decl":"theorem eval_multiset_prod_X_sub_C_derivative [DecidableEq R]\n    {S : Multiset R} {r : R} (hr : r ∈ S) :\n    eval r (derivative (Multiset.map (fun a => X - C a) S).prod) =\n      (Multiset.map (fun a => r - a) (S.erase r)).prod := by\n  nth_rw 1 [← Multiset.cons_erase hr]\n  have := (evalRingHom r).map_multiset_prod (Multiset.map (fun a => X - C a) (S.erase r))\n  simpa using this\n\n"}
{"name":"Polynomial.derivative_X_sub_C_pow","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : CommRing R\nc : R\nm : Nat\n⊢ Eq (Polynomial.derivative (HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C c)) m)) (HMul.hMul (Polynomial.C ↑m) (HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C c)) (HSub.hSub m 1)))","decl":"theorem derivative_X_sub_C_pow (c : R) (m : ℕ) :\n    derivative ((X - C c) ^ m) = C (m : R) * (X - C c) ^ (m - 1) := by\n  rw [derivative_pow, derivative_X_sub_C, mul_one]\n\n"}
{"name":"Polynomial.derivative_X_sub_C_sq","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : CommRing R\nc : R\n⊢ Eq (Polynomial.derivative (HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C c)) 2)) (HMul.hMul (Polynomial.C 2) (HSub.hSub Polynomial.X (Polynomial.C c)))","decl":"theorem derivative_X_sub_C_sq (c : R) : derivative ((X - C c) ^ 2) = C 2 * (X - C c) := by\n  rw [derivative_sq, derivative_X_sub_C, mul_one]\n\n"}
{"name":"Polynomial.iterate_derivative_X_sub_pow","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : CommRing R\nn k : Nat\nc : R\n⊢ Eq (Nat.iterate (⇑Polynomial.derivative) k (HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C c)) n)) (HSMul.hSMul (n.descFactorial k) (HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C c)) (HSub.hSub n k)))","decl":"theorem iterate_derivative_X_sub_pow (n k : ℕ) (c : R) :\n    derivative^[k] ((X - C c) ^ n) = n.descFactorial k • (X - C c) ^ (n - k) := by\n  rw [sub_eq_add_neg, ← C_neg, iterate_derivative_X_add_pow]\n\n"}
{"name":"Polynomial.iterate_derivative_X_sub_pow_self","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝ : CommRing R\nn : Nat\nc : R\n⊢ Eq (Nat.iterate (⇑Polynomial.derivative) n (HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C c)) n)) ↑n.factorial","decl":"theorem iterate_derivative_X_sub_pow_self (n : ℕ) (c : R) :\n    derivative^[n] ((X - C c) ^ n) = n.factorial := by\n  rw [iterate_derivative_X_sub_pow, n.sub_self, pow_zero, nsmul_one, n.descFactorial_self]\n\n"}
{"name":"Polynomial.dvd_derivative_iff","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : NoZeroDivisors R\nP : Polynomial R\n⊢ Iff (Dvd.dvd P (Polynomial.derivative P)) (Eq (Polynomial.derivative P) 0)","decl":"@[simp]\ntheorem dvd_derivative_iff {P : R[X]} : P ∣ derivative P ↔ derivative P = 0 where\n  mp h := by\n    by_cases hP : P = 0\n    · simp only [hP, derivative_zero]\n    exact eq_zero_of_dvd_of_degree_lt h (degree_derivative_lt hP)\n  mpr h := by simp [h]\n\n"}
{"name":"Polynomial.derivative_pow_eq_zero","module":"Mathlib.Algebra.Polynomial.Derivative","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : NoZeroDivisors R\nn : Nat\nchn : Ne (↑n) 0\na : Polynomial R\n⊢ Iff (Eq (Polynomial.derivative (HPow.hPow a n)) 0) (Eq (Polynomial.derivative a) 0)","decl":"theorem derivative_pow_eq_zero {n : ℕ} (chn : (n : R) ≠ 0) {a : R[X]} :\n    derivative (a ^ n) = 0 ↔ derivative a = 0 := by\n  nontriviality R\n  rw [← C_ne_zero, C_eq_natCast] at chn\n  simp +contextual [derivative_pow, or_imp, chn]\n\n"}
