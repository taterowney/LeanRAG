{"name":"Nat.bitwise_zero_left","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"f : Bool → Bool → Bool\nm : Nat\n⊢ Eq (Nat.bitwise f 0 m) (ite (Eq (f Bool.false Bool.true) Bool.true) m 0)","decl":"@[simp]\nlemma bitwise_zero_left (m : Nat) : bitwise f 0 m = if f false true then m else 0 := by\n  simp [bitwise]\n\n"}
{"name":"Nat.bitwise_zero_right","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"f : Bool → Bool → Bool\nn : Nat\n⊢ Eq (Nat.bitwise f n 0) (ite (Eq (f Bool.true Bool.false) Bool.true) n 0)","decl":"@[simp]\nlemma bitwise_zero_right (n : Nat) : bitwise f n 0 = if f true false then n else 0 := by\n  unfold bitwise\n  simp only [ite_self, decide_false, Nat.zero_div, ite_true, ite_eq_right_iff]\n  rintro ⟨⟩\n  split_ifs <;> rfl\n\n"}
{"name":"Nat.bitwise_zero","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"f : Bool → Bool → Bool\n⊢ Eq (Nat.bitwise f 0 0) 0","decl":"lemma bitwise_zero : bitwise f 0 0 = 0 := by\n  simp only [bitwise_zero_right, ite_self]\n\n"}
{"name":"Nat.bitwise_of_ne_zero","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"f : Bool → Bool → Bool\nn m : Nat\nhn : Ne n 0\nhm : Ne m 0\n⊢ Eq (Nat.bitwise f n m) (Nat.bit (f n.bodd m.bodd) (Nat.bitwise f (HDiv.hDiv n 2) (HDiv.hDiv m 2)))","decl":"lemma bitwise_of_ne_zero {n m : Nat} (hn : n ≠ 0) (hm : m ≠ 0) :\n    bitwise f n m = bit (f (bodd n) (bodd m)) (bitwise f (n / 2) (m / 2)) := by\n  conv_lhs => unfold bitwise\n  have mod_two_iff_bod x : (x % 2 = 1 : Bool) = bodd x := by\n    simp only [mod_two_of_bodd, cond]; cases bodd x <;> rfl\n  simp only [hn, hm, mod_two_iff_bod, ite_false, bit, two_mul, Bool.cond_eq_ite]\n  split_ifs <;> rfl\n\n"}
{"name":"Nat.binaryRec_of_ne_zero","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"C : Nat → Sort u_1\nz : C 0\nf : (b : Bool) → (n : Nat) → C n → C (Nat.bit b n)\nn : Nat\nh : Ne n 0\n⊢ Eq (Nat.binaryRec z f n) (Eq.rec (f n.bodd n.div2 (Nat.binaryRec z f n.div2)) ⋯)","decl":"theorem binaryRec_of_ne_zero {C : Nat → Sort*} (z : C 0) (f : ∀ b n, C n → C (bit b n)) {n}\n    (h : n ≠ 0) :\n    binaryRec z f n = bit_decomp n ▸ f (bodd n) (div2 n) (binaryRec z f (div2 n)) := by\n  cases n using bitCasesOn with\n  | h b n =>\n    rw [binaryRec_eq _ _ (by right; simpa [bit_eq_zero_iff] using h)]\n    generalize_proofs h; revert h\n    rw [bodd_bit, div2_bit]\n    simp\n\n"}
{"name":"Nat.bitwise_bit","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"f : Bool → Bool → Bool\nh : autoParam (Eq (f Bool.false Bool.false) Bool.false) _auto✝\na : Bool\nm : Nat\nb : Bool\nn : Nat\n⊢ Eq (Nat.bitwise f (Nat.bit a m) (Nat.bit b n)) (Nat.bit (f a b) (Nat.bitwise f m n))","decl":"@[simp]\nlemma bitwise_bit {f : Bool → Bool → Bool} (h : f false false = false := by rfl) (a m b n) :\n    bitwise f (bit a m) (bit b n) = bit (f a b) (bitwise f m n) := by\n  conv_lhs => unfold bitwise\n  simp only [bit, ite_apply, Bool.cond_eq_ite]\n  have h4 x : (x + x + 1) / 2 = x := by rw [← two_mul, add_comm]; simp [add_mul_div_left]\n  cases a <;> cases b <;> simp [h4] <;> split_ifs\n    <;> simp_all +decide [two_mul]\n\n"}
{"name":"Nat.bit_mod_two_eq_zero_iff","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"a : Bool\nx : Nat\n⊢ Iff (Eq (HMod.hMod (Nat.bit a x) 2) 0) (Eq a.not Bool.true)","decl":"lemma bit_mod_two_eq_zero_iff (a x) :\n    bit a x % 2 = 0 ↔ !a := by\n  simp\n\n"}
{"name":"Nat.bit_mod_two_eq_one_iff","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"a : Bool\nx : Nat\n⊢ Iff (Eq (HMod.hMod (Nat.bit a x) 2) 1) (Eq a Bool.true)","decl":"lemma bit_mod_two_eq_one_iff (a x) :\n    bit a x % 2 = 1 ↔ a := by\n  simp\n\n"}
{"name":"Nat.lor_bit","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"a : Bool\nm : Nat\nb : Bool\nn : Nat\n⊢ Eq (HOr.hOr (Nat.bit a m) (Nat.bit b n)) (Nat.bit (a.or b) (HOr.hOr m n))","decl":"@[simp]\ntheorem lor_bit : ∀ a m b n, bit a m ||| bit b n = bit (a || b) (m ||| n) :=\n  bitwise_bit\n\n"}
{"name":"Nat.land_bit","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"a : Bool\nm : Nat\nb : Bool\nn : Nat\n⊢ Eq (HAnd.hAnd (Nat.bit a m) (Nat.bit b n)) (Nat.bit (a.and b) (HAnd.hAnd m n))","decl":"@[simp]\ntheorem land_bit : ∀ a m b n, bit a m &&& bit b n = bit (a && b) (m &&& n) :=\n  bitwise_bit\n\n"}
{"name":"Nat.ldiff_bit","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"a : Bool\nm : Nat\nb : Bool\nn : Nat\n⊢ Eq ((Nat.bit a m).ldiff (Nat.bit b n)) (Nat.bit (a.and b.not) (m.ldiff n))","decl":"@[simp]\ntheorem ldiff_bit : ∀ a m b n, ldiff (bit a m) (bit b n) = bit (a && not b) (ldiff m n) :=\n  bitwise_bit\n\n"}
{"name":"Nat.xor_bit","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"a : Bool\nm : Nat\nb : Bool\nn : Nat\n⊢ Eq (HXor.hXor (Nat.bit a m) (Nat.bit b n)) (Nat.bit (bne a b) (HXor.hXor m n))","decl":"@[simp]\ntheorem xor_bit : ∀ a m b n, bit a m ^^^ bit b n = bit (bne a b) (m ^^^ n) :=\n  bitwise_bit\n\n"}
{"name":"Nat.testBit_lor","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"m n k : Nat\n⊢ Eq ((HOr.hOr m n).testBit k) ((m.testBit k).or (n.testBit k))","decl":"theorem testBit_lor : ∀ m n k, testBit (m ||| n) k = (testBit m k || testBit n k) :=\n  testBit_bitwise rfl\n\n"}
{"name":"Nat.testBit_land","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"m n k : Nat\n⊢ Eq ((HAnd.hAnd m n).testBit k) ((m.testBit k).and (n.testBit k))","decl":"theorem testBit_land : ∀ m n k, testBit (m &&& n) k = (testBit m k && testBit n k) :=\n  testBit_bitwise rfl\n\n"}
{"name":"Nat.testBit_ldiff","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"m n k : Nat\n⊢ Eq ((m.ldiff n).testBit k) ((m.testBit k).and (n.testBit k).not)","decl":"@[simp]\ntheorem testBit_ldiff : ∀ m n k, testBit (ldiff m n) k = (testBit m k && not (testBit n k)) :=\n  testBit_bitwise rfl\n\n"}
{"name":"Nat.bit_false","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"⊢ Eq (Nat.bit Bool.false) fun x => HMul.hMul 2 x","decl":"@[simp]\ntheorem bit_false : bit false = (2 * ·) :=\n  rfl\n\n"}
{"name":"Nat.bit_true","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"⊢ Eq (Nat.bit Bool.true) fun x => HAdd.hAdd (HMul.hMul 2 x) 1","decl":"@[simp]\ntheorem bit_true : bit true = (2 * · + 1) :=\n  rfl\n\n"}
{"name":"Nat.bit_eq_zero","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"n : Nat\nb : Bool\n⊢ Iff (Eq (Nat.bit b n) 0) (And (Eq n 0) (Eq b Bool.false))","decl":"@[deprecated (since := \"2024-10-19\")] alias bit_eq_zero := bit_eq_zero_iff\n\n"}
{"name":"Nat.bit_ne_zero_iff","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"n : Nat\nb : Bool\n⊢ Iff (Ne (Nat.bit b n) 0) (Eq n 0 → Eq b Bool.true)","decl":"theorem bit_ne_zero_iff {n : ℕ} {b : Bool} : n.bit b ≠ 0 ↔ n = 0 → b = true := by\n  simp\n\n"}
{"name":"Nat.bitwise_bit'","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"f : Bool → Bool → Bool\na : Bool\nm : Nat\nb : Bool\nn : Nat\nham : Eq m 0 → Eq a Bool.true\nhbn : Eq n 0 → Eq b Bool.true\n⊢ Eq (Nat.bitwise f (Nat.bit a m) (Nat.bit b n)) (Nat.bit (f a b) (Nat.bitwise f m n))","decl":"/-- An alternative for `bitwise_bit` which replaces the `f false false = false` assumption\nwith assumptions that neither `bit a m` nor `bit b n` are `0`\n(albeit, phrased as the implications `m = 0 → a = true` and `n = 0 → b = true`) -/\nlemma bitwise_bit' {f : Bool → Bool → Bool} (a : Bool) (m : Nat) (b : Bool) (n : Nat)\n    (ham : m = 0 → a = true) (hbn : n = 0 → b = true) :\n    bitwise f (bit a m) (bit b n) = bit (f a b) (bitwise f m n) := by\n  conv_lhs => unfold bitwise\n  rw [← bit_ne_zero_iff] at ham hbn\n  simp only [ham, hbn, bit_mod_two_eq_one_iff, Bool.decide_coe, ← div2_val, div2_bit, ne_eq,\n    ite_false]\n  conv_rhs => simp only [bit, two_mul, Bool.cond_eq_ite]\n  split_ifs with hf <;> rfl\n\n"}
{"name":"Nat.bitwise_eq_binaryRec","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"f : Bool → Bool → Bool\n⊢ Eq (Nat.bitwise f) fun n => Nat.binaryRec (motive := fun x => Nat → Nat) (fun n => cond (f Bool.false Bool.true) n 0) (fun a m Ia n => Nat.binaryRec (cond (f Bool.true Bool.false) (Nat.bit a m) 0) (fun b n x => Nat.bit (f a b) (Ia n)) n) n","decl":"lemma bitwise_eq_binaryRec (f : Bool → Bool → Bool) :\n    bitwise f =\n    binaryRec (fun n => cond (f false true) n 0) fun a m Ia =>\n      binaryRec (cond (f true false) (bit a m) 0) fun b n _ => bit (f a b) (Ia n) := by\n  funext x y\n  induction x using binaryRec' generalizing y with\n  | z => simp only [bitwise_zero_left, binaryRec_zero, Bool.cond_eq_ite]\n  | f xb x hxb ih =>\n    rw [← bit_ne_zero_iff] at hxb\n    simp_rw [binaryRec_of_ne_zero _ _ hxb, bodd_bit, div2_bit, eq_rec_constant]\n    induction y using binaryRec' with\n    | z => simp only [bitwise_zero_right, binaryRec_zero, Bool.cond_eq_ite]\n    | f yb y hyb =>\n      rw [← bit_ne_zero_iff] at hyb\n      simp_rw [binaryRec_of_ne_zero _ _ hyb, bitwise_of_ne_zero hxb hyb, bodd_bit, ← div2_val,\n        div2_bit, eq_rec_constant, ih]\n\n"}
{"name":"Nat.zero_of_testBit_eq_false","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"n : Nat\nh : ∀ (i : Nat), Eq (n.testBit i) Bool.false\n⊢ Eq n 0","decl":"theorem zero_of_testBit_eq_false {n : ℕ} (h : ∀ i, testBit n i = false) : n = 0 := by\n  induction' n using Nat.binaryRec with b n hn\n  · rfl\n  · have : b = false := by simpa using h 0\n    rw [this, bit_false, hn fun i => by rw [← h (i + 1), testBit_bit_succ]]\n\n"}
{"name":"Nat.testBit_eq_false_of_lt","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"n i : Nat\nh : LT.lt n (HPow.hPow 2 i)\n⊢ Eq (n.testBit i) Bool.false","decl":"theorem testBit_eq_false_of_lt {n i} (h : n < 2 ^ i) : n.testBit i = false := by\n  simp [testBit, shiftRight_eq_div_pow, Nat.div_eq_of_lt h]\n\n"}
{"name":"Nat.testBit_eq_inth","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"n i : Nat\n⊢ Eq (n.testBit i) (n.bits.getI i)","decl":"/-- The ith bit is the ith element of `n.bits`. -/\ntheorem testBit_eq_inth (n i : ℕ) : n.testBit i = n.bits.getI i := by\n  induction' i with i ih generalizing n\n  · simp only [testBit, zero_eq, shiftRight_zero, one_and_eq_mod_two, mod_two_of_bodd,\n      bodd_eq_bits_head, List.getI_zero_eq_headI]\n    cases List.headI (bits n) <;> rfl\n  conv_lhs => rw [← bit_decomp n]\n  rw [testBit_bit_succ, ih n.div2, div2_bits_eq_tail]\n  cases n.bits <;> simp\n\n"}
{"name":"Nat.exists_most_significant_bit","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"n : Nat\nh : Ne n 0\n⊢ Exists fun i => And (Eq (n.testBit i) Bool.true) (∀ (j : Nat), LT.lt i j → Eq (n.testBit j) Bool.false)","decl":"theorem exists_most_significant_bit {n : ℕ} (h : n ≠ 0) :\n    ∃ i, testBit n i = true ∧ ∀ j, i < j → testBit n j = false := by\n  induction' n using Nat.binaryRec with b n hn\n  · exact False.elim (h rfl)\n  by_cases h' : n = 0\n  · subst h'\n    rw [show b = true by\n        revert h\n        cases b <;> simp]\n    refine ⟨0, ⟨by rw [testBit_bit_zero], fun j hj => ?_⟩⟩\n    obtain ⟨j', rfl⟩ := exists_eq_succ_of_ne_zero (ne_of_gt hj)\n    rw [testBit_bit_succ, zero_testBit]\n  · obtain ⟨k, ⟨hk, hk'⟩⟩ := hn h'\n    refine ⟨k + 1, ⟨by rw [testBit_bit_succ, hk], fun j hj => ?_⟩⟩\n    obtain ⟨j', rfl⟩ := exists_eq_succ_of_ne_zero (show j ≠ 0 by intro x; subst x; simp at hj)\n    exact (testBit_bit_succ _ _ _).trans (hk' _ (lt_of_succ_lt_succ hj))\n\n"}
{"name":"Nat.lt_of_testBit","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"n m i : Nat\nhn : Eq (n.testBit i) Bool.false\nhm : Eq (m.testBit i) Bool.true\nhnm : ∀ (j : Nat), LT.lt i j → Eq (n.testBit j) (m.testBit j)\n⊢ LT.lt n m","decl":"theorem lt_of_testBit {n m : ℕ} (i : ℕ) (hn : testBit n i = false) (hm : testBit m i = true)\n    (hnm : ∀ j, i < j → testBit n j = testBit m j) : n < m := by\n  induction' n using Nat.binaryRec with b n hn' generalizing i m\n  · rw [Nat.pos_iff_ne_zero]\n    rintro rfl\n    simp at hm\n  induction' m using Nat.binaryRec with b' m hm' generalizing i\n  · exact False.elim (Bool.false_ne_true ((zero_testBit i).symm.trans hm))\n  by_cases hi : i = 0\n  · subst hi\n    simp only [testBit_bit_zero] at hn hm\n    have : n = m :=\n      eq_of_testBit_eq fun i => by convert hnm (i + 1) (Nat.zero_lt_succ _) using 1\n      <;> rw [testBit_bit_succ]\n    rw [hn, hm, this, bit_false, bit_true]\n    exact Nat.lt_succ_self _\n  · obtain ⟨i', rfl⟩ := exists_eq_succ_of_ne_zero hi\n    simp only [testBit_bit_succ] at hn hm\n    have := hn' _ hn hm fun j hj => by\n      convert hnm j.succ (succ_lt_succ hj) using 1 <;> rw [testBit_bit_succ]\n    have this' : 2 * n < 2 * m := Nat.mul_lt_mul_of_le_of_lt (le_refl _) this Nat.two_pos\n    cases b <;> cases b'\n    <;> simp only [bit_false, bit_true]\n    · exact this'\n    · exact Nat.lt_add_right 1 this'\n    · calc\n        2 * n + 1 < 2 * n + 2 := lt.base _\n        _ ≤ 2 * m := mul_le_mul_left 2 this\n    · exact Nat.succ_lt_succ this'\n\n"}
{"name":"Nat.bitwise_swap","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"f : Bool → Bool → Bool\n⊢ Eq (Nat.bitwise (Function.swap f)) (Function.swap (Nat.bitwise f))","decl":"theorem bitwise_swap {f : Bool → Bool → Bool} :\n    bitwise (Function.swap f) = Function.swap (bitwise f) := by\n  funext m n\n  simp only [Function.swap]\n  induction' m using Nat.strongRecOn with m ih generalizing n\n  cases' m with m\n  <;> cases' n with n\n  <;> try rw [bitwise_zero_left, bitwise_zero_right]\n  · specialize ih ((m+1) / 2) (div_lt_self' ..)\n    simp [bitwise_of_ne_zero, ih]\n\n"}
{"name":"Nat.bitwise_comm","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"f : Bool → Bool → Bool\nhf : ∀ (b b' : Bool), Eq (f b b') (f b' b)\nn m : Nat\n⊢ Eq (Nat.bitwise f n m) (Nat.bitwise f m n)","decl":"/-- If `f` is a commutative operation on bools such that `f false false = false`, then `bitwise f`\n    is also commutative. -/\ntheorem bitwise_comm {f : Bool → Bool → Bool} (hf : ∀ b b', f b b' = f b' b) (n m : ℕ) :\n    bitwise f n m = bitwise f m n :=\n  suffices bitwise f = swap (bitwise f) by conv_lhs => rw [this]\n  calc\n    bitwise f = bitwise (swap f) := congr_arg _ <| funext fun _ => funext <| hf _\n    _ = swap (bitwise f) := bitwise_swap\n\n"}
{"name":"Nat.lor_comm","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"n m : Nat\n⊢ Eq (HOr.hOr n m) (HOr.hOr m n)","decl":"theorem lor_comm (n m : ℕ) : n ||| m = m ||| n :=\n  bitwise_comm Bool.or_comm n m\n\n"}
{"name":"Nat.land_comm","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"n m : Nat\n⊢ Eq (HAnd.hAnd n m) (HAnd.hAnd m n)","decl":"theorem land_comm (n m : ℕ) : n &&& m = m &&& n :=\n  bitwise_comm Bool.and_comm n m\n\n"}
{"name":"Nat.and_two_pow","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"n i : Nat\n⊢ Eq (HAnd.hAnd n (HPow.hPow 2 i)) (HMul.hMul (n.testBit i).toNat (HPow.hPow 2 i))","decl":"lemma and_two_pow (n i : ℕ) : n &&& 2 ^ i = (n.testBit i).toNat * 2 ^ i := by\n  refine eq_of_testBit_eq fun j => ?_\n  obtain rfl | hij := Decidable.eq_or_ne i j <;> cases' h : n.testBit i\n  · simp [h]\n  · simp [h]\n  · simp [h, testBit_two_pow_of_ne hij]\n  · simp [h, testBit_two_pow_of_ne hij]\n\n"}
{"name":"Nat.two_pow_and","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"n i : Nat\n⊢ Eq (HAnd.hAnd (HPow.hPow 2 i) n) (HMul.hMul (HPow.hPow 2 i) (n.testBit i).toNat)","decl":"lemma two_pow_and (n i : ℕ) : 2 ^ i &&& n = 2 ^ i * (n.testBit i).toNat := by\n  rw [mul_comm, land_comm, and_two_pow]\n\n"}
{"name":"Nat.land_assoc","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"n m k : Nat\n⊢ Eq (HAnd.hAnd (HAnd.hAnd n m) k) (HAnd.hAnd n (HAnd.hAnd m k))","decl":"theorem land_assoc (n m k : ℕ) : (n &&& m) &&& k = n &&& (m &&& k) := by bitwise_assoc_tac\n\n"}
{"name":"Nat.lor_assoc","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"n m k : Nat\n⊢ Eq (HOr.hOr (HOr.hOr n m) k) (HOr.hOr n (HOr.hOr m k))","decl":"theorem lor_assoc (n m k : ℕ) : (n ||| m) ||| k = n ||| (m ||| k) := by bitwise_assoc_tac\n\n-- These lemmas match `mul_inv_cancel_right` and `mul_inv_cancel_left`.\n"}
{"name":"Nat.xor_cancel_right","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"n m : Nat\n⊢ Eq (HXor.hXor (HXor.hXor m n) n) m","decl":"theorem xor_cancel_right (n m : ℕ) : (m ^^^ n) ^^^ n = m := by\n  rw [Nat.xor_assoc, Nat.xor_self, xor_zero]\n\n"}
{"name":"Nat.xor_cancel_left","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"n m : Nat\n⊢ Eq (HXor.hXor n (HXor.hXor n m)) m","decl":"theorem xor_cancel_left (n m : ℕ) : n ^^^ (n ^^^ m) = m := by\n  rw [← Nat.xor_assoc, Nat.xor_self, zero_xor]\n\n"}
{"name":"Nat.xor_right_injective","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"n : Nat\n⊢ Function.Injective (HXor.hXor n)","decl":"theorem xor_right_injective {n : ℕ} : Function.Injective (HXor.hXor n : ℕ → ℕ) := fun m m' h => by\n  rw [← xor_cancel_left n m, ← xor_cancel_left n m', h]\n\n"}
{"name":"Nat.xor_left_injective","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"n : Nat\n⊢ Function.Injective fun m => HXor.hXor m n","decl":"theorem xor_left_injective {n : ℕ} : Function.Injective fun m => m ^^^ n :=\n  fun m m' (h : m ^^^ n = m' ^^^ n) => by\n  rw [← xor_cancel_right n m, ← xor_cancel_right n m', h]\n\n"}
{"name":"Nat.xor_right_inj","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"n m m' : Nat\n⊢ Iff (Eq (HXor.hXor n m) (HXor.hXor n m')) (Eq m m')","decl":"@[simp]\ntheorem xor_right_inj {n m m' : ℕ} : n ^^^ m = n ^^^ m' ↔ m = m' :=\n  xor_right_injective.eq_iff\n\n"}
{"name":"Nat.xor_left_inj","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"n m m' : Nat\n⊢ Iff (Eq (HXor.hXor m n) (HXor.hXor m' n)) (Eq m m')","decl":"@[simp]\ntheorem xor_left_inj {n m m' : ℕ} : m ^^^ n = m' ^^^ n ↔ m = m' :=\n  xor_left_injective.eq_iff\n\n"}
{"name":"Nat.xor_eq_zero","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"n m : Nat\n⊢ Iff (Eq (HXor.hXor n m) 0) (Eq n m)","decl":"@[simp]\ntheorem xor_eq_zero {n m : ℕ} : n ^^^ m = 0 ↔ n = m := by\n  rw [← Nat.xor_self n, xor_right_inj, eq_comm]\n\n"}
{"name":"Nat.xor_ne_zero","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"n m : Nat\n⊢ Iff (Ne (HXor.hXor n m) 0) (Ne n m)","decl":"theorem xor_ne_zero {n m : ℕ} : n ^^^ m ≠ 0 ↔ n ≠ m :=\n  xor_eq_zero.not\n\n"}
{"name":"Nat.xor_trichotomy","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"a b c : Nat\nh : Ne (HXor.hXor (HXor.hXor a b) c) 0\n⊢ Or (LT.lt (HXor.hXor b c) a) (Or (LT.lt (HXor.hXor c a) b) (LT.lt (HXor.hXor a b) c))","decl":"theorem xor_trichotomy {a b c : ℕ} (h : a ^^^ b ^^^ c ≠ 0) :\n    b ^^^ c < a ∨ c ^^^ a < b ∨ a ^^^ b < c := by\n  set v := a ^^^ b ^^^ c with hv\n  -- The xor of any two of `a`, `b`, `c` is the xor of `v` and the third.\n  have hab : a ^^^ b = c ^^^ v := by\n    rw [Nat.xor_comm c, xor_cancel_right]\n  have hbc : b ^^^ c = a ^^^ v := by\n    rw [← Nat.xor_assoc, xor_cancel_left]\n  have hca : c ^^^ a = b ^^^ v := by\n    rw [hv, Nat.xor_assoc, Nat.xor_comm a, ← Nat.xor_assoc, xor_cancel_left]\n  -- If `i` is the position of the most significant bit of `v`, then at least one of `a`, `b`, `c`\n  -- has a one bit at position `i`.\n  obtain ⟨i, ⟨hi, hi'⟩⟩ := exists_most_significant_bit h\n  have : testBit a i ∨ testBit b i ∨ testBit c i := by\n    contrapose! hi\n    simp_rw [Bool.eq_false_eq_not_eq_true] at hi ⊢\n    rw [testBit_xor, testBit_xor, hi.1, hi.2.1, hi.2.2]\n    rfl\n  -- If, say, `a` has a one bit at position `i`, then `a xor v` has a zero bit at position `i`, but\n  -- the same bits as `a` in positions greater than `j`, so `a xor v < a`.\n  obtain h | h | h := this\n  on_goal 1 => left; rw [hbc]\n  on_goal 2 => right; left; rw [hca]\n  on_goal 3 => right; right; rw [hab]\n  all_goals\n    refine lt_of_testBit i ?_ h fun j hj => ?_\n    · rw [testBit_xor, h, hi]\n      rfl\n    · simp only [testBit_xor, hi' _ hj, Bool.bne_false]\n\n"}
{"name":"Nat.lt_xor_cases","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"a b c : Nat\nh : LT.lt a (HXor.hXor b c)\n⊢ Or (LT.lt (HXor.hXor a c) b) (LT.lt (HXor.hXor a b) c)","decl":"theorem lt_xor_cases {a b c : ℕ} (h : a < b ^^^ c) : a ^^^ c < b ∨ a ^^^ b < c := by\n  obtain ha | hb | hc := xor_trichotomy <| Nat.xor_assoc _ _ _ ▸ xor_ne_zero.2 h.ne\n  exacts [(h.asymm ha).elim, Or.inl <| Nat.xor_comm _ _ ▸ hb, Or.inr hc]\n\n"}
{"name":"Nat.xor_mod_two_eq","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"m n : Nat\n⊢ Eq (HMod.hMod (HXor.hXor m n) 2) (HMod.hMod (HAdd.hAdd m n) 2)","decl":"@[simp]\ntheorem xor_mod_two_eq {m n : ℕ} : (m ^^^ n) % 2 = (m + n) % 2 := by\n  by_cases h : (m + n) % 2 = 0\n  · simp only [h, mod_two_eq_zero_iff_testBit_zero, testBit_zero, xor_mod_two_eq_one, decide_not,\n      Bool.decide_iff_dist, Bool.not_eq_false', beq_iff_eq, decide_eq_decide]\n    omega\n  · simp only [mod_two_ne_zero] at h\n    simp only [h, xor_mod_two_eq_one]\n    omega\n\n"}
{"name":"Nat.even_xor","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"m n : Nat\n⊢ Iff (Even (HXor.hXor m n)) (Iff (Even m) (Even n))","decl":"@[simp]\ntheorem even_xor {m n : ℕ} : Even (m ^^^ n) ↔ (Even m ↔ Even n) := by\n  simp only [even_iff, xor_mod_two_eq]\n  omega\n\n"}
{"name":"Nat.bit_lt_two_pow_succ_iff","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"b : Bool\nx n : Nat\n⊢ Iff (LT.lt (Nat.bit b x) (HPow.hPow 2 (HAdd.hAdd n 1))) (LT.lt x (HPow.hPow 2 n))","decl":"@[simp] theorem bit_lt_two_pow_succ_iff {b x n} : bit b x < 2 ^ (n + 1) ↔ x < 2 ^ n := by\n  cases b <;> simp <;> omega\n\n"}
{"name":"Nat.bitwise_lt","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"x n y : Nat\nf : Bool → Bool → Bool\nleft : LT.lt x (HPow.hPow 2 n)\nright : LT.lt y (HPow.hPow 2 n)\n⊢ LT.lt (Nat.bitwise f x y) (HPow.hPow 2 n)","decl":"@[deprecated bitwise_lt_two_pow (since := \"2024-12-28\")]\nalias bitwise_lt := bitwise_lt_two_pow\n\n"}
{"name":"Nat.shiftLeft_lt","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"x n m : Nat\nh : LT.lt x (HPow.hPow 2 n)\n⊢ LT.lt (HShiftLeft.hShiftLeft x m) (HPow.hPow 2 (HAdd.hAdd n m))","decl":"lemma shiftLeft_lt {x n m : ℕ} (h : x < 2 ^ n) : x <<< m < 2 ^ (n + m) := by\n  simp only [Nat.pow_add, shiftLeft_eq, Nat.mul_lt_mul_right (Nat.two_pow_pos _), h]\n\n"}
{"name":"Nat.append_lt","module":"Mathlib.Data.Nat.Bitwise","initialProofState":"x y n m : Nat\nhx : LT.lt x (HPow.hPow 2 n)\nhy : LT.lt y (HPow.hPow 2 m)\n⊢ LT.lt (HOr.hOr (HShiftLeft.hShiftLeft y n) x) (HPow.hPow 2 (HAdd.hAdd n m))","decl":"/-- Note that the LHS is the expression used within `Std.BitVec.append`, hence the name. -/\nlemma append_lt {x y n m} (hx : x < 2 ^ n) (hy : y < 2 ^ m) : y <<< n ||| x < 2 ^ (n + m) := by\n  apply bitwise_lt_two_pow\n  · rw [add_comm]; apply shiftLeft_lt hy\n  · apply lt_of_lt_of_le hx <| Nat.pow_le_pow_right (le_succ _) (le_add_right _ _)\n\n"}
