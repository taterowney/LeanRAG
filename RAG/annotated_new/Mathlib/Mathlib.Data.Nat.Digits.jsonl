{"name":"Nat.digitsAux_zero","module":"Mathlib.Data.Nat.Digits","initialProofState":"b : Nat\nh : LE.le 2 b\n⊢ Eq (b.digitsAux h 0) List.nil","decl":"@[simp]\ntheorem digitsAux_zero (b : ℕ) (h : 2 ≤ b) : digitsAux b h 0 = [] := by rw [digitsAux]\n\n"}
{"name":"Nat.digitsAux_def","module":"Mathlib.Data.Nat.Digits","initialProofState":"b : Nat\nh : LE.le 2 b\nn : Nat\nw : LT.lt 0 n\n⊢ Eq (b.digitsAux h n) (List.cons (HMod.hMod n b) (b.digitsAux h (HDiv.hDiv n b)))","decl":"theorem digitsAux_def (b : ℕ) (h : 2 ≤ b) (n : ℕ) (w : 0 < n) :\n    digitsAux b h n = (n % b) :: digitsAux b h (n / b) := by\n  cases n\n  · cases w\n  · rw [digitsAux]\n\n"}
{"name":"Nat.digits_zero","module":"Mathlib.Data.Nat.Digits","initialProofState":"b : Nat\n⊢ Eq (b.digits 0) List.nil","decl":"@[simp]\ntheorem digits_zero (b : ℕ) : digits b 0 = [] := by\n  rcases b with (_ | ⟨_ | ⟨_⟩⟩) <;> simp [digits, digitsAux0, digitsAux1]\n\n"}
{"name":"Nat.digits_zero_zero","module":"Mathlib.Data.Nat.Digits","initialProofState":"⊢ Eq (Nat.digits 0 0) List.nil","decl":"theorem digits_zero_zero : digits 0 0 = [] :=\n  rfl\n\n"}
{"name":"Nat.digits_zero_succ","module":"Mathlib.Data.Nat.Digits","initialProofState":"n : Nat\n⊢ Eq (Nat.digits 0 n.succ) (List.cons (HAdd.hAdd n 1) List.nil)","decl":"@[simp]\ntheorem digits_zero_succ (n : ℕ) : digits 0 n.succ = [n + 1] :=\n  rfl\n\n"}
{"name":"Nat.digits_zero_succ'","module":"Mathlib.Data.Nat.Digits","initialProofState":"n : Nat\na✝ : Ne n 0\n⊢ Eq (Nat.digits 0 n) (List.cons n List.nil)","decl":"theorem digits_zero_succ' : ∀ {n : ℕ}, n ≠ 0 → digits 0 n = [n]\n  | 0, h => (h rfl).elim\n  | _ + 1, _ => rfl\n\n"}
{"name":"Nat.digits_one","module":"Mathlib.Data.Nat.Digits","initialProofState":"n : Nat\n⊢ Eq (Nat.digits 1 n) (List.replicate n 1)","decl":"@[simp]\ntheorem digits_one (n : ℕ) : digits 1 n = List.replicate n 1 :=\n  rfl\n\n-- @[simp] -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10685): dsimp can prove this\n"}
{"name":"Nat.digits_one_succ","module":"Mathlib.Data.Nat.Digits","initialProofState":"n : Nat\n⊢ Eq (Nat.digits 1 (HAdd.hAdd n 1)) (List.cons 1 (Nat.digits 1 n))","decl":"theorem digits_one_succ (n : ℕ) : digits 1 (n + 1) = 1 :: digits 1 n :=\n  rfl\n\n"}
{"name":"Nat.digits_add_two_add_one","module":"Mathlib.Data.Nat.Digits","initialProofState":"b n : Nat\n⊢ Eq ((HAdd.hAdd b 2).digits (HAdd.hAdd n 1)) (List.cons (HMod.hMod (HAdd.hAdd n 1) (HAdd.hAdd b 2)) ((HAdd.hAdd b 2).digits (HDiv.hDiv (HAdd.hAdd n 1) (HAdd.hAdd b 2))))","decl":"theorem digits_add_two_add_one (b n : ℕ) :\n    digits (b + 2) (n + 1) = ((n + 1) % (b + 2)) :: digits (b + 2) ((n + 1) / (b + 2)) := by\n  simp [digits, digitsAux_def]\n\n"}
{"name":"Nat.digits_of_two_le_of_pos","module":"Mathlib.Data.Nat.Digits","initialProofState":"n b : Nat\nhb : LE.le 2 b\nhn : LT.lt 0 n\n⊢ Eq (b.digits n) (List.cons (HMod.hMod n b) (b.digits (HDiv.hDiv n b)))","decl":"@[simp]\nlemma digits_of_two_le_of_pos {b : ℕ} (hb : 2 ≤ b) (hn : 0 < n) :\n    Nat.digits b n = n % b :: Nat.digits b (n / b) := by\n  rw [Nat.eq_add_of_sub_eq hb rfl, Nat.eq_add_of_sub_eq hn rfl, Nat.digits_add_two_add_one]\n\n"}
{"name":"Nat.digits_def'","module":"Mathlib.Data.Nat.Digits","initialProofState":"b : Nat\nx✝¹ : LT.lt 1 b\nn : Nat\nx✝ : LT.lt 0 n\n⊢ Eq (b.digits n) (List.cons (HMod.hMod n b) (b.digits (HDiv.hDiv n b)))","decl":"theorem digits_def' :\n    ∀ {b : ℕ} (_ : 1 < b) {n : ℕ} (_ : 0 < n), digits b n = (n % b) :: digits b (n / b)\n  | 0, h => absurd h (by decide)\n  | 1, h => absurd h (by decide)\n  | b + 2, _ => digitsAux_def _ (by simp) _\n\n"}
{"name":"Nat.digits_of_lt","module":"Mathlib.Data.Nat.Digits","initialProofState":"b x : Nat\nhx : Ne x 0\nhxb : LT.lt x b\n⊢ Eq (b.digits x) (List.cons x List.nil)","decl":"@[simp]\ntheorem digits_of_lt (b x : ℕ) (hx : x ≠ 0) (hxb : x < b) : digits b x = [x] := by\n  rcases exists_eq_succ_of_ne_zero hx with ⟨x, rfl⟩\n  rcases Nat.exists_eq_add_of_le' ((Nat.le_add_left 1 x).trans_lt hxb) with ⟨b, rfl⟩\n  rw [digits_add_two_add_one, div_eq_of_lt hxb, digits_zero, mod_eq_of_lt hxb]\n\n"}
{"name":"Nat.digits_add","module":"Mathlib.Data.Nat.Digits","initialProofState":"b : Nat\nh : LT.lt 1 b\nx y : Nat\nhxb : LT.lt x b\nhxy : Or (Ne x 0) (Ne y 0)\n⊢ Eq (b.digits (HAdd.hAdd x (HMul.hMul b y))) (List.cons x (b.digits y))","decl":"theorem digits_add (b : ℕ) (h : 1 < b) (x y : ℕ) (hxb : x < b) (hxy : x ≠ 0 ∨ y ≠ 0) :\n    digits b (x + b * y) = x :: digits b y := by\n  rcases Nat.exists_eq_add_of_le' h with ⟨b, rfl : _ = _ + 2⟩\n  cases y\n  · simp [hxb, hxy.resolve_right (absurd rfl)]\n  dsimp [digits]\n  rw [digitsAux_def]\n  · congr\n    · simp [Nat.add_mod, mod_eq_of_lt hxb]\n    · simp [add_mul_div_left, div_eq_of_lt hxb]\n  · apply Nat.succ_pos\n\n-- If we had a function converting a list into a polynomial,\n-- and appropriate lemmas about that function,\n-- we could rewrite this in terms of that.\n"}
{"name":"Nat.ofDigits_eq_foldr","module":"Mathlib.Data.Nat.Digits","initialProofState":"α : Type u_1\ninst✝ : Semiring α\nb : α\nL : List Nat\n⊢ Eq (Nat.ofDigits b L) (List.foldr (fun x y => HAdd.hAdd (↑x) (HMul.hMul b y)) 0 L)","decl":"theorem ofDigits_eq_foldr {α : Type*} [Semiring α] (b : α) (L : List ℕ) :\n    ofDigits b L = List.foldr (fun x y => ↑x + b * y) 0 L := by\n  induction' L with d L ih\n  · rfl\n  · dsimp [ofDigits]\n    rw [ih]\n\n"}
{"name":"Nat.ofDigits_eq_sum_map_with_index_aux","module":"Mathlib.Data.Nat.Digits","initialProofState":"b : Nat\nl : List Nat\n⊢ Eq (List.zipWith (fun i a => HMul.hMul a (HPow.hPow b (HAdd.hAdd i 1))) (List.range l.length) l).sum (HMul.hMul b (List.zipWith (fun i a => HMul.hMul a (HPow.hPow b i)) (List.range l.length) l).sum)","decl":"theorem ofDigits_eq_sum_map_with_index_aux (b : ℕ) (l : List ℕ) :\n    ((List.range l.length).zipWith ((fun i a : ℕ => a * b ^ (i + 1))) l).sum =\n      b * ((List.range l.length).zipWith (fun i a => a * b ^ i) l).sum := by\n  suffices\n    (List.range l.length).zipWith (fun i a : ℕ => a * b ^ (i + 1)) l =\n      (List.range l.length).zipWith (fun i a => b * (a * b ^ i)) l\n    by simp [this]\n  congr; ext; simp [pow_succ]; ring\n\n"}
{"name":"Nat.ofDigits_eq_sum_mapIdx","module":"Mathlib.Data.Nat.Digits","initialProofState":"b : Nat\nL : List Nat\n⊢ Eq (Nat.ofDigits b L) (List.mapIdx (fun i a => HMul.hMul a (HPow.hPow b i)) L).sum","decl":"theorem ofDigits_eq_sum_mapIdx (b : ℕ) (L : List ℕ) :\n    ofDigits b L = (L.mapIdx fun i a => a * b ^ i).sum := by\n  rw [List.mapIdx_eq_enum_map, List.enum_eq_zip_range, List.map_uncurry_zip_eq_zipWith,\n    ofDigits_eq_foldr]\n  induction' L with hd tl hl\n  · simp\n  · simpa [List.range_succ_eq_map, List.zipWith_map_left, ofDigits_eq_sum_map_with_index_aux] using\n      Or.inl hl\n\n"}
{"name":"Nat.ofDigits_nil","module":"Mathlib.Data.Nat.Digits","initialProofState":"b : Nat\n⊢ Eq (Nat.ofDigits b List.nil) 0","decl":"@[simp]\ntheorem ofDigits_nil {b : ℕ} : ofDigits b [] = 0 := rfl\n\n"}
{"name":"Nat.ofDigits_singleton","module":"Mathlib.Data.Nat.Digits","initialProofState":"b n : Nat\n⊢ Eq (Nat.ofDigits b (List.cons n List.nil)) n","decl":"@[simp]\ntheorem ofDigits_singleton {b n : ℕ} : ofDigits b [n] = n := by simp [ofDigits]\n\n"}
{"name":"Nat.ofDigits_one_cons","module":"Mathlib.Data.Nat.Digits","initialProofState":"α : Type u_1\ninst✝ : Semiring α\nh : Nat\nL : List Nat\n⊢ Eq (Nat.ofDigits 1 (List.cons h L)) (HAdd.hAdd (↑h) (Nat.ofDigits 1 L))","decl":"@[simp]\ntheorem ofDigits_one_cons {α : Type*} [Semiring α] (h : ℕ) (L : List ℕ) :\n    ofDigits (1 : α) (h :: L) = h + ofDigits 1 L := by simp [ofDigits]\n\n"}
{"name":"Nat.ofDigits_cons","module":"Mathlib.Data.Nat.Digits","initialProofState":"b hd : Nat\ntl : List Nat\n⊢ Eq (Nat.ofDigits b (List.cons hd tl)) (HAdd.hAdd hd (HMul.hMul b (Nat.ofDigits b tl)))","decl":"theorem ofDigits_cons {b hd} {tl : List ℕ} :\n    ofDigits b (hd :: tl) = hd + b * ofDigits b tl := rfl\n\n"}
{"name":"Nat.ofDigits_append","module":"Mathlib.Data.Nat.Digits","initialProofState":"b : Nat\nl1 l2 : List Nat\n⊢ Eq (Nat.ofDigits b (HAppend.hAppend l1 l2)) (HAdd.hAdd (Nat.ofDigits b l1) (HMul.hMul (HPow.hPow b l1.length) (Nat.ofDigits b l2)))","decl":"theorem ofDigits_append {b : ℕ} {l1 l2 : List ℕ} :\n    ofDigits b (l1 ++ l2) = ofDigits b l1 + b ^ l1.length * ofDigits b l2 := by\n  induction' l1 with hd tl IH\n  · simp [ofDigits]\n  · rw [ofDigits, List.cons_append, ofDigits, IH, List.length_cons, pow_succ']\n    ring\n\n"}
{"name":"Nat.coe_ofDigits","module":"Mathlib.Data.Nat.Digits","initialProofState":"α : Type u_1\ninst✝ : Semiring α\nb : Nat\nL : List Nat\n⊢ Eq (↑(Nat.ofDigits b L)) (Nat.ofDigits (↑b) L)","decl":"@[norm_cast]\ntheorem coe_ofDigits (α : Type*) [Semiring α] (b : ℕ) (L : List ℕ) :\n    ((ofDigits b L : ℕ) : α) = ofDigits (b : α) L := by\n  induction' L with d L ih\n  · simp [ofDigits]\n  · dsimp [ofDigits]; push_cast; rw [ih]\n\n"}
{"name":"Nat.coe_int_ofDigits","module":"Mathlib.Data.Nat.Digits","initialProofState":"b : Nat\nL : List Nat\n⊢ Eq (↑(Nat.ofDigits b L)) (Nat.ofDigits (↑b) L)","decl":"@[norm_cast]\ntheorem coe_int_ofDigits (b : ℕ) (L : List ℕ) : ((ofDigits b L : ℕ) : ℤ) = ofDigits (b : ℤ) L := by\n  induction' L with d L _\n  · rfl\n  · dsimp [ofDigits]; push_cast; simp only\n\n"}
{"name":"Nat.digits_zero_of_eq_zero","module":"Mathlib.Data.Nat.Digits","initialProofState":"b : Nat\nh : Ne b 0\nL : List Nat\nx✝ : Eq (Nat.ofDigits b L) 0\nl : Nat\na✝ : Membership.mem L l\n⊢ Eq l 0","decl":"theorem digits_zero_of_eq_zero {b : ℕ} (h : b ≠ 0) :\n    ∀ {L : List ℕ} (_ : ofDigits b L = 0), ∀ l ∈ L, l = 0\n  | _ :: _, h0, _, List.Mem.head .. => Nat.eq_zero_of_add_eq_zero_right h0\n  | _ :: _, h0, _, List.Mem.tail _ hL =>\n    digits_zero_of_eq_zero h (mul_right_injective₀ h (Nat.eq_zero_of_add_eq_zero_left h0)) _ hL\n\n"}
{"name":"Nat.digits_ofDigits","module":"Mathlib.Data.Nat.Digits","initialProofState":"b : Nat\nh : LT.lt 1 b\nL : List Nat\nw₁ : ∀ (l : Nat), Membership.mem L l → LT.lt l b\nw₂ : ∀ (h : Ne L List.nil), Ne (L.getLast h) 0\n⊢ Eq (b.digits (Nat.ofDigits b L)) L","decl":"theorem digits_ofDigits (b : ℕ) (h : 1 < b) (L : List ℕ) (w₁ : ∀ l ∈ L, l < b)\n    (w₂ : ∀ h : L ≠ [], L.getLast h ≠ 0) : digits b (ofDigits b L) = L := by\n  induction' L with d L ih\n  · dsimp [ofDigits]\n    simp\n  · dsimp [ofDigits]\n    replace w₂ := w₂ (by simp)\n    rw [digits_add b h]\n    · rw [ih]\n      · intro l m\n        apply w₁\n        exact List.mem_cons_of_mem _ m\n      · intro h\n        rw [List.getLast_cons h] at w₂\n        convert w₂\n    · exact w₁ d (List.mem_cons_self _ _)\n    · by_cases h' : L = []\n      · rcases h' with rfl\n        left\n        simpa using w₂\n      · right\n        contrapose! w₂\n        refine digits_zero_of_eq_zero h.ne_bot w₂ _ ?_\n        rw [List.getLast_cons h']\n        exact List.getLast_mem h'\n\n"}
{"name":"Nat.ofDigits_digits","module":"Mathlib.Data.Nat.Digits","initialProofState":"b n : Nat\n⊢ Eq (Nat.ofDigits b (b.digits n)) n","decl":"theorem ofDigits_digits (b n : ℕ) : ofDigits b (digits b n) = n := by\n  cases' b with b\n  · cases' n with n\n    · rfl\n    · change ofDigits 0 [n + 1] = n + 1\n      dsimp [ofDigits]\n  · cases' b with b\n    · induction' n with n ih\n      · rfl\n      · rw [Nat.zero_add] at ih ⊢\n        simp only [ih, add_comm 1, ofDigits_one_cons, Nat.cast_id, digits_one_succ]\n    · induction n using Nat.strongRecOn with | ind n h => ?_\n      cases n\n      · rw [digits_zero]\n        rfl\n      · simp only [Nat.succ_eq_add_one, digits_add_two_add_one]\n        dsimp [ofDigits]\n        rw [h _ (Nat.div_lt_self' _ b)]\n        rw [Nat.mod_add_div]\n\n"}
{"name":"Nat.ofDigits_one","module":"Mathlib.Data.Nat.Digits","initialProofState":"L : List Nat\n⊢ Eq (Nat.ofDigits 1 L) L.sum","decl":"theorem ofDigits_one (L : List ℕ) : ofDigits 1 L = L.sum := by\n  induction L with\n  | nil => rfl\n  | cons _ _ ih => simp [ofDigits, List.sum_cons, ih]\n\n"}
{"name":"Nat.digits_eq_nil_iff_eq_zero","module":"Mathlib.Data.Nat.Digits","initialProofState":"b n : Nat\n⊢ Iff (Eq (b.digits n) List.nil) (Eq n 0)","decl":"theorem digits_eq_nil_iff_eq_zero {b n : ℕ} : digits b n = [] ↔ n = 0 := by\n  constructor\n  · intro h\n    have : ofDigits b (digits b n) = ofDigits b [] := by rw [h]\n    convert this\n    rw [ofDigits_digits]\n  · rintro rfl\n    simp\n\n"}
{"name":"Nat.digits_ne_nil_iff_ne_zero","module":"Mathlib.Data.Nat.Digits","initialProofState":"b n : Nat\n⊢ Iff (Ne (b.digits n) List.nil) (Ne n 0)","decl":"theorem digits_ne_nil_iff_ne_zero {b n : ℕ} : digits b n ≠ [] ↔ n ≠ 0 :=\n  not_congr digits_eq_nil_iff_eq_zero\n\n"}
{"name":"Nat.digits_eq_cons_digits_div","module":"Mathlib.Data.Nat.Digits","initialProofState":"b n : Nat\nh : LT.lt 1 b\nw : Ne n 0\n⊢ Eq (b.digits n) (List.cons (HMod.hMod n b) (b.digits (HDiv.hDiv n b)))","decl":"theorem digits_eq_cons_digits_div {b n : ℕ} (h : 1 < b) (w : n ≠ 0) :\n    digits b n = (n % b) :: digits b (n / b) := by\n  rcases b with (_ | _ | b)\n  · rw [digits_zero_succ' w, Nat.mod_zero, Nat.div_zero, Nat.digits_zero_zero]\n  · norm_num at h\n  rcases n with (_ | n)\n  · norm_num at w\n  · simp only [digits_add_two_add_one, ne_eq]\n\n"}
{"name":"Nat.digits_getLast","module":"Mathlib.Data.Nat.Digits","initialProofState":"b m : Nat\nh : LT.lt 1 b\np : Ne (b.digits m) List.nil\nq : Ne (b.digits (HDiv.hDiv m b)) List.nil\n⊢ Eq ((b.digits m).getLast p) ((b.digits (HDiv.hDiv m b)).getLast q)","decl":"theorem digits_getLast {b : ℕ} (m : ℕ) (h : 1 < b) (p q) :\n    (digits b m).getLast p = (digits b (m / b)).getLast q := by\n  by_cases hm : m = 0\n  · simp [hm]\n  simp only [digits_eq_cons_digits_div h hm]\n  rw [List.getLast_cons]\n\n"}
{"name":"Nat.digits.injective","module":"Mathlib.Data.Nat.Digits","initialProofState":"b : Nat\n⊢ Function.Injective b.digits","decl":"theorem digits.injective (b : ℕ) : Function.Injective b.digits :=\n  Function.LeftInverse.injective (ofDigits_digits b)\n\n"}
{"name":"Nat.digits_inj_iff","module":"Mathlib.Data.Nat.Digits","initialProofState":"b n m : Nat\n⊢ Iff (Eq (b.digits n) (b.digits m)) (Eq n m)","decl":"@[simp]\ntheorem digits_inj_iff {b n m : ℕ} : b.digits n = b.digits m ↔ n = m :=\n  (digits.injective b).eq_iff\n\n"}
{"name":"Nat.digits_len","module":"Mathlib.Data.Nat.Digits","initialProofState":"b n : Nat\nhb : LT.lt 1 b\nhn : Ne n 0\n⊢ Eq (b.digits n).length (HAdd.hAdd (Nat.log b n) 1)","decl":"theorem digits_len (b n : ℕ) (hb : 1 < b) (hn : n ≠ 0) : (b.digits n).length = b.log n + 1 := by\n  induction' n using Nat.strong_induction_on with n IH\n  rw [digits_eq_cons_digits_div hb hn, List.length]\n  by_cases h : n / b = 0\n  · simp [IH, h]\n    aesop\n  · have : n / b < n := div_lt_self (Nat.pos_of_ne_zero hn) hb\n    rw [IH _ this h, log_div_base, tsub_add_cancel_of_le]\n    refine Nat.succ_le_of_lt (log_pos hb ?_)\n    contrapose! h\n    exact div_eq_of_lt h\n\n"}
{"name":"Nat.getLast_digit_ne_zero","module":"Mathlib.Data.Nat.Digits","initialProofState":"b m : Nat\nhm : Ne m 0\n⊢ Ne ((b.digits m).getLast ⋯) 0","decl":"theorem getLast_digit_ne_zero (b : ℕ) {m : ℕ} (hm : m ≠ 0) :\n    (digits b m).getLast (digits_ne_nil_iff_ne_zero.mpr hm) ≠ 0 := by\n  rcases b with (_ | _ | b)\n  · cases m\n    · cases hm rfl\n    · simp\n  · cases m\n    · cases hm rfl\n    rename ℕ => m\n    simp only [zero_add, digits_one, List.getLast_replicate_succ m 1]\n    exact Nat.one_ne_zero\n  revert hm\n  induction m using Nat.strongRecOn with | ind n IH => ?_\n  intro hn\n  by_cases hnb : n < b + 2\n  · simpa only [digits_of_lt (b + 2) n hn hnb]\n  · rw [digits_getLast n (le_add_left 2 b)]\n    refine IH _ (Nat.div_lt_self hn.bot_lt (one_lt_succ_succ b)) ?_\n    rw [← pos_iff_ne_zero]\n    exact Nat.div_pos (le_of_not_lt hnb) (zero_lt_succ (succ b))\n\n"}
{"name":"Nat.mul_ofDigits","module":"Mathlib.Data.Nat.Digits","initialProofState":"n b : Nat\nl : List Nat\n⊢ Eq (HMul.hMul n (Nat.ofDigits b l)) (Nat.ofDigits b (List.map (fun x => HMul.hMul n x) l))","decl":"theorem mul_ofDigits (n : ℕ) {b : ℕ} {l : List ℕ} :\n    n * ofDigits b l = ofDigits b (l.map (n * ·)) := by\n  induction l with\n  | nil => rfl\n  | cons hd tl ih =>\n    rw [List.map_cons, ofDigits_cons, ofDigits_cons, ← ih]\n    ring\n\n"}
{"name":"Nat.ofDigits_add_ofDigits_eq_ofDigits_zipWith_of_length_eq","module":"Mathlib.Data.Nat.Digits","initialProofState":"b : Nat\nl1 l2 : List Nat\nh : Eq l1.length l2.length\n⊢ Eq (HAdd.hAdd (Nat.ofDigits b l1) (Nat.ofDigits b l2)) (Nat.ofDigits b (List.zipWith (fun x1 x2 => HAdd.hAdd x1 x2) l1 l2))","decl":"/-- The addition of ofDigits of two lists is equal to ofDigits of digit-wise addition of them -/\ntheorem ofDigits_add_ofDigits_eq_ofDigits_zipWith_of_length_eq {b : ℕ} {l1 l2 : List ℕ}\n    (h : l1.length = l2.length) :\n    ofDigits b l1 + ofDigits b l2 = ofDigits b (l1.zipWith (· + ·) l2) := by\n  induction l1 generalizing l2 with\n  | nil => simp_all [eq_comm, List.length_eq_zero, ofDigits]\n  | cons hd₁ tl₁ ih₁ =>\n    induction l2 generalizing tl₁ with\n    | nil => simp_all\n    | cons hd₂ tl₂ ih₂ =>\n      simp_all only [List.length_cons, succ_eq_add_one, ofDigits_cons, add_left_inj,\n        eq_comm, List.zipWith_cons_cons, add_eq]\n      rw [← ih₁ h.symm, mul_add]\n      ac_rfl\n\n"}
{"name":"Nat.digits_lt_base'","module":"Mathlib.Data.Nat.Digits","initialProofState":"b m d : Nat\na✝ : Membership.mem ((HAdd.hAdd b 2).digits m) d\n⊢ LT.lt d (HAdd.hAdd b 2)","decl":"/-- The digits in the base b+2 expansion of n are all less than b+2 -/\ntheorem digits_lt_base' {b m : ℕ} : ∀ {d}, d ∈ digits (b + 2) m → d < b + 2 := by\n  induction m using Nat.strongRecOn with | ind n IH => ?_\n  intro d hd\n  cases' n with n\n  · rw [digits_zero] at hd\n    cases hd\n  -- base b+2 expansion of 0 has no digits\n  rw [digits_add_two_add_one] at hd\n  cases hd\n  · exact n.succ.mod_lt (by simp)\n  -- Porting note: Previous code (single line) contained linarith.\n  -- . exact IH _ (Nat.div_lt_self (Nat.succ_pos _) (by linarith)) hd\n  · apply IH ((n + 1) / (b + 2))\n    · apply Nat.div_lt_self <;> omega\n    · assumption\n\n"}
{"name":"Nat.digits_lt_base","module":"Mathlib.Data.Nat.Digits","initialProofState":"b m d : Nat\nhb : LT.lt 1 b\nhd : Membership.mem (b.digits m) d\n⊢ LT.lt d b","decl":"/-- The digits in the base b expansion of n are all less than b, if b ≥ 2 -/\ntheorem digits_lt_base {b m d : ℕ} (hb : 1 < b) (hd : d ∈ digits b m) : d < b := by\n  rcases b with (_ | _ | b) <;> try simp_all\n  exact digits_lt_base' hd\n\n"}
{"name":"Nat.ofDigits_lt_base_pow_length'","module":"Mathlib.Data.Nat.Digits","initialProofState":"b : Nat\nl : List Nat\nhl : ∀ (x : Nat), Membership.mem l x → LT.lt x (HAdd.hAdd b 2)\n⊢ LT.lt (Nat.ofDigits (HAdd.hAdd b 2) l) (HPow.hPow (HAdd.hAdd b 2) l.length)","decl":"/-- an n-digit number in base b + 2 is less than (b + 2)^n -/\ntheorem ofDigits_lt_base_pow_length' {b : ℕ} {l : List ℕ} (hl : ∀ x ∈ l, x < b + 2) :\n    ofDigits (b + 2) l < (b + 2) ^ l.length := by\n  induction' l with hd tl IH\n  · simp [ofDigits]\n  · rw [ofDigits, List.length_cons, pow_succ]\n    have : (ofDigits (b + 2) tl + 1) * (b + 2) ≤ (b + 2) ^ tl.length * (b + 2) :=\n      mul_le_mul (IH fun x hx => hl _ (List.mem_cons_of_mem _ hx)) (by rfl) (by simp only [zero_le])\n        (Nat.zero_le _)\n    suffices ↑hd < b + 2 by linarith\n    exact hl hd (List.mem_cons_self _ _)\n\n"}
{"name":"Nat.ofDigits_lt_base_pow_length","module":"Mathlib.Data.Nat.Digits","initialProofState":"b : Nat\nl : List Nat\nhb : LT.lt 1 b\nhl : ∀ (x : Nat), Membership.mem l x → LT.lt x b\n⊢ LT.lt (Nat.ofDigits b l) (HPow.hPow b l.length)","decl":"/-- an n-digit number in base b is less than b^n if b > 1 -/\ntheorem ofDigits_lt_base_pow_length {b : ℕ} {l : List ℕ} (hb : 1 < b) (hl : ∀ x ∈ l, x < b) :\n    ofDigits b l < b ^ l.length := by\n  rcases b with (_ | _ | b) <;> try simp_all\n  exact ofDigits_lt_base_pow_length' hl\n\n"}
{"name":"Nat.lt_base_pow_length_digits'","module":"Mathlib.Data.Nat.Digits","initialProofState":"b m : Nat\n⊢ LT.lt m (HPow.hPow (HAdd.hAdd b 2) ((HAdd.hAdd b 2).digits m).length)","decl":"/-- Any number m is less than (b+2)^(number of digits in the base b + 2 representation of m) -/\ntheorem lt_base_pow_length_digits' {b m : ℕ} : m < (b + 2) ^ (digits (b + 2) m).length := by\n  convert @ofDigits_lt_base_pow_length' b (digits (b + 2) m) fun _ => digits_lt_base'\n  rw [ofDigits_digits (b + 2) m]\n\n"}
{"name":"Nat.lt_base_pow_length_digits","module":"Mathlib.Data.Nat.Digits","initialProofState":"b m : Nat\nhb : LT.lt 1 b\n⊢ LT.lt m (HPow.hPow b (b.digits m).length)","decl":"/-- Any number m is less than b^(number of digits in the base b representation of m) -/\ntheorem lt_base_pow_length_digits {b m : ℕ} (hb : 1 < b) : m < b ^ (digits b m).length := by\n  rcases b with (_ | _ | b) <;> try simp_all\n  exact lt_base_pow_length_digits'\n\n"}
{"name":"Nat.digits_base_pow_mul","module":"Mathlib.Data.Nat.Digits","initialProofState":"b k m : Nat\nhb : LT.lt 1 b\nhm : LT.lt 0 m\n⊢ Eq (b.digits (HMul.hMul (HPow.hPow b k) m)) (HAppend.hAppend (List.replicate k 0) (b.digits m))","decl":"theorem digits_base_pow_mul {b k m : ℕ} (hb : 1 < b) (hm : 0 < m) :\n    digits b (b ^ k * m) = List.replicate k 0 ++ digits b m := by\n  induction k generalizing m with\n  | zero => simp\n  | succ k ih =>\n    have hmb : 0 < m * b := lt_mul_of_lt_of_one_lt' hm hb\n    let h1 := digits_def' hb hmb\n    have h2 : m = m * b / b :=\n      Nat.eq_div_of_mul_eq_left (not_eq_zero_of_lt hb) rfl\n    simp only [mul_mod_left, ← h2] at h1\n    rw [List.replicate_succ', List.append_assoc, List.singleton_append, ← h1, ← ih hmb]\n    ring_nf\n\n"}
{"name":"Nat.ofDigits_digits_append_digits","module":"Mathlib.Data.Nat.Digits","initialProofState":"b m n : Nat\n⊢ Eq (Nat.ofDigits b (HAppend.hAppend (b.digits n) (b.digits m))) (HAdd.hAdd n (HMul.hMul (HPow.hPow b (b.digits n).length) m))","decl":"theorem ofDigits_digits_append_digits {b m n : ℕ} :\n    ofDigits b (digits b n ++ digits b m) = n + b ^ (digits b n).length * m := by\n  rw [ofDigits_append, ofDigits_digits, ofDigits_digits]\n\n"}
{"name":"Nat.digits_append_digits","module":"Mathlib.Data.Nat.Digits","initialProofState":"b m n : Nat\nhb : LT.lt 0 b\n⊢ Eq (HAppend.hAppend (b.digits n) (b.digits m)) (b.digits (HAdd.hAdd n (HMul.hMul (HPow.hPow b (b.digits n).length) m)))","decl":"theorem digits_append_digits {b m n : ℕ} (hb : 0 < b) :\n    digits b n ++ digits b m = digits b (n + b ^ (digits b n).length * m) := by\n  rcases eq_or_lt_of_le (Nat.succ_le_of_lt hb) with (rfl | hb)\n  · simp\n  rw [← ofDigits_digits_append_digits]\n  refine (digits_ofDigits b hb _ (fun l hl => ?_) (fun h_append => ?_)).symm\n  · rcases (List.mem_append.mp hl) with (h | h) <;> exact digits_lt_base hb h\n  · by_cases h : digits b m = []\n    · simp only [h, List.append_nil] at h_append ⊢\n      exact getLast_digit_ne_zero b <| digits_ne_nil_iff_ne_zero.mp h_append\n    · exact (List.getLast_append' _ _ h) ▸\n          (getLast_digit_ne_zero _ <| digits_ne_nil_iff_ne_zero.mp h)\n\n"}
{"name":"Nat.digits_append_zeroes_append_digits","module":"Mathlib.Data.Nat.Digits","initialProofState":"b k m n : Nat\nhb : LT.lt 1 b\nhm : LT.lt 0 m\n⊢ Eq (HAppend.hAppend (HAppend.hAppend (b.digits n) (List.replicate k 0)) (b.digits m)) (b.digits (HAdd.hAdd n (HMul.hMul (HPow.hPow b (HAdd.hAdd (b.digits n).length k)) m)))","decl":"theorem digits_append_zeroes_append_digits {b k m n : ℕ} (hb : 1 < b) (hm : 0 < m) :\n    digits b n ++ List.replicate k 0 ++ digits b m =\n    digits b (n + b ^ ((digits b n).length + k) * m) := by\n  rw [List.append_assoc, ← digits_base_pow_mul hb hm]\n  simp only [digits_append_digits (zero_lt_of_lt hb), digits_inj_iff, add_right_inj]\n  ring\n\n"}
{"name":"Nat.digits_len_le_digits_len_succ","module":"Mathlib.Data.Nat.Digits","initialProofState":"b n : Nat\n⊢ LE.le (b.digits n).length (b.digits (HAdd.hAdd n 1)).length","decl":"theorem digits_len_le_digits_len_succ (b n : ℕ) :\n    (digits b n).length ≤ (digits b (n + 1)).length := by\n  rcases Decidable.eq_or_ne n 0 with (rfl | hn)\n  · simp\n  rcases le_or_lt b 1 with hb | hb\n  · interval_cases b <;> simp_arith [digits_zero_succ', hn]\n  simpa [digits_len, hb, hn] using log_mono_right (le_succ _)\n\n"}
{"name":"Nat.le_digits_len_le","module":"Mathlib.Data.Nat.Digits","initialProofState":"b n m : Nat\nh : LE.le n m\n⊢ LE.le (b.digits n).length (b.digits m).length","decl":"theorem le_digits_len_le (b n m : ℕ) (h : n ≤ m) : (digits b n).length ≤ (digits b m).length :=\n  monotone_nat_of_le_succ (digits_len_le_digits_len_succ b) h\n\n"}
{"name":"Nat.ofDigits_monotone","module":"Mathlib.Data.Nat.Digits","initialProofState":"p q : Nat\nL : List Nat\nh : LE.le p q\n⊢ LE.le (Nat.ofDigits p L) (Nat.ofDigits q L)","decl":"@[mono]\ntheorem ofDigits_monotone {p q : ℕ} (L : List ℕ) (h : p ≤ q) : ofDigits p L ≤ ofDigits q L := by\n  induction L with\n  | nil => rfl\n  | cons _ _ hi =>\n    simp only [ofDigits, cast_id, add_le_add_iff_left]\n    exact Nat.mul_le_mul h hi\n\n"}
{"name":"Nat.sum_le_ofDigits","module":"Mathlib.Data.Nat.Digits","initialProofState":"p : Nat\nL : List Nat\nh : LE.le 1 p\n⊢ LE.le L.sum (Nat.ofDigits p L)","decl":"theorem sum_le_ofDigits {p : ℕ} (L : List ℕ) (h : 1 ≤ p) : L.sum ≤ ofDigits p L :=\n  (ofDigits_one L).symm ▸ ofDigits_monotone L h\n\n"}
{"name":"Nat.digit_sum_le","module":"Mathlib.Data.Nat.Digits","initialProofState":"p n : Nat\n⊢ LE.le (p.digits n).sum n","decl":"theorem digit_sum_le (p n : ℕ) : List.sum (digits p n) ≤ n := by\n  induction' n with n\n  · exact digits_zero _ ▸ Nat.le_refl (List.sum [])\n  · induction' p with p\n    · rw [digits_zero_succ, List.sum_cons, List.sum_nil, add_zero]\n    · nth_rw 2 [← ofDigits_digits p.succ (n + 1)]\n      rw [← ofDigits_one <| digits p.succ n.succ]\n      exact ofDigits_monotone (digits p.succ n.succ) <| Nat.succ_pos p\n\n"}
{"name":"Nat.pow_length_le_mul_ofDigits","module":"Mathlib.Data.Nat.Digits","initialProofState":"b : Nat\nl : List Nat\nhl : Ne l List.nil\nhl2 : Ne (l.getLast hl) 0\n⊢ LE.le (HPow.hPow (HAdd.hAdd b 2) l.length) (HMul.hMul (HAdd.hAdd b 2) (Nat.ofDigits (HAdd.hAdd b 2) l))","decl":"theorem pow_length_le_mul_ofDigits {b : ℕ} {l : List ℕ} (hl : l ≠ []) (hl2 : l.getLast hl ≠ 0) :\n    (b + 2) ^ l.length ≤ (b + 2) * ofDigits (b + 2) l := by\n  rw [← List.dropLast_append_getLast hl]\n  simp only [List.length_append, List.length, zero_add, List.length_dropLast, ofDigits_append,\n    List.length_dropLast, ofDigits_singleton, add_comm (l.length - 1), pow_add, pow_one]\n  apply Nat.mul_le_mul_left\n  refine le_trans ?_ (Nat.le_add_left _ _)\n  have : 0 < l.getLast hl := by rwa [pos_iff_ne_zero]\n  convert Nat.mul_le_mul_left ((b + 2) ^ (l.length - 1)) this using 1\n  rw [Nat.mul_one]\n\n"}
{"name":"Nat.base_pow_length_digits_le'","module":"Mathlib.Data.Nat.Digits","initialProofState":"b m : Nat\nhm : Ne m 0\n⊢ LE.le (HPow.hPow (HAdd.hAdd b 2) ((HAdd.hAdd b 2).digits m).length) (HMul.hMul (HAdd.hAdd b 2) m)","decl":"/-- Any non-zero natural number `m` is greater than\n(b+2)^((number of digits in the base (b+2) representation of m) - 1)\n-/\ntheorem base_pow_length_digits_le' (b m : ℕ) (hm : m ≠ 0) :\n    (b + 2) ^ (digits (b + 2) m).length ≤ (b + 2) * m := by\n  have : digits (b + 2) m ≠ [] := digits_ne_nil_iff_ne_zero.mpr hm\n  convert @pow_length_le_mul_ofDigits b (digits (b+2) m)\n    this (getLast_digit_ne_zero _ hm)\n  rw [ofDigits_digits]\n\n"}
{"name":"Nat.base_pow_length_digits_le","module":"Mathlib.Data.Nat.Digits","initialProofState":"b m : Nat\nhb : LT.lt 1 b\na✝ : Ne m 0\n⊢ LE.le (HPow.hPow b (b.digits m).length) (HMul.hMul b m)","decl":"/-- Any non-zero natural number `m` is greater than\nb^((number of digits in the base b representation of m) - 1)\n-/\ntheorem base_pow_length_digits_le (b m : ℕ) (hb : 1 < b) :\n    m ≠ 0 → b ^ (digits b m).length ≤ b * m := by\n  rcases b with (_ | _ | b) <;> try simp_all\n  exact base_pow_length_digits_le' b m\n\n"}
{"name":"Nat.ofDigits_div_eq_ofDigits_tail","module":"Mathlib.Data.Nat.Digits","initialProofState":"p : Nat\nhpos : LT.lt 0 p\ndigits : List Nat\nw₁ : ∀ (l : Nat), Membership.mem digits l → LT.lt l p\n⊢ Eq (HDiv.hDiv (Nat.ofDigits p digits) p) (Nat.ofDigits p digits.tail)","decl":"/-- Interpreting as a base `p` number and dividing by `p` is the same as interpreting the tail.\n-/\nlemma ofDigits_div_eq_ofDigits_tail {p : ℕ} (hpos : 0 < p) (digits : List ℕ)\n    (w₁ : ∀ l ∈ digits, l < p) : ofDigits p digits / p = ofDigits p digits.tail := by\n  induction' digits with hd tl\n  · simp [ofDigits]\n  · refine Eq.trans (add_mul_div_left hd _ hpos) ?_\n    rw [Nat.div_eq_of_lt <| w₁ _ <| List.mem_cons_self _ _, zero_add]\n    rfl\n\n"}
{"name":"Nat.ofDigits_div_pow_eq_ofDigits_drop","module":"Mathlib.Data.Nat.Digits","initialProofState":"p i : Nat\nhpos : LT.lt 0 p\ndigits : List Nat\nw₁ : ∀ (l : Nat), Membership.mem digits l → LT.lt l p\n⊢ Eq (HDiv.hDiv (Nat.ofDigits p digits) (HPow.hPow p i)) (Nat.ofDigits p (List.drop i digits))","decl":"/-- Interpreting as a base `p` number and dividing by `p^i` is the same as dropping `i`.\n-/\nlemma ofDigits_div_pow_eq_ofDigits_drop\n    {p : ℕ} (i : ℕ) (hpos : 0 < p) (digits : List ℕ) (w₁ : ∀ l ∈ digits, l < p) :\n    ofDigits p digits / p ^ i = ofDigits p (digits.drop i) := by\n  induction' i with i hi\n  · simp\n  · rw [Nat.pow_succ, ← Nat.div_div_eq_div_mul, hi, ofDigits_div_eq_ofDigits_tail hpos\n      (List.drop i digits) fun x hx ↦ w₁ x <| List.mem_of_mem_drop hx, ← List.drop_one,\n      List.drop_drop, add_comm]\n\n"}
{"name":"Nat.self_div_pow_eq_ofDigits_drop","module":"Mathlib.Data.Nat.Digits","initialProofState":"p i n : Nat\nh : LE.le 2 p\n⊢ Eq (HDiv.hDiv n (HPow.hPow p i)) (Nat.ofDigits p (List.drop i (p.digits n)))","decl":"/-- Dividing `n` by `p^i` is like truncating the first `i` digits of `n` in base `p`.\n-/\nlemma self_div_pow_eq_ofDigits_drop {p : ℕ} (i n : ℕ) (h : 2 ≤ p) :\n    n / p ^ i = ofDigits p ((p.digits n).drop i) := by\n  convert ofDigits_div_pow_eq_ofDigits_drop i (zero_lt_of_lt h) (p.digits n)\n    (fun l hl ↦ digits_lt_base h hl)\n  exact (ofDigits_digits p n).symm\n\n"}
{"name":"Nat.sub_one_mul_sum_div_pow_eq_sub_sum_digits","module":"Mathlib.Data.Nat.Digits","initialProofState":"p : Nat\nL : List Nat\nh_nonempty : Ne L List.nil\nh_ne_zero : Ne (L.getLast h_nonempty) 0\nh_lt : ∀ (l : Nat), Membership.mem L l → LT.lt l p\n⊢ Eq (HMul.hMul (HSub.hSub p 1) ((Finset.range L.length).sum fun i => HDiv.hDiv (Nat.ofDigits p L) (HPow.hPow p i.succ))) (HSub.hSub (Nat.ofDigits p L) L.sum)","decl":"theorem sub_one_mul_sum_div_pow_eq_sub_sum_digits {p : ℕ}\n    (L : List ℕ) {h_nonempty} (h_ne_zero : L.getLast h_nonempty ≠ 0) (h_lt : ∀ l ∈ L, l < p) :\n    (p - 1) * ∑ i ∈ range L.length, (ofDigits p L) / p ^ i.succ = (ofDigits p L) - L.sum := by\n  obtain h | rfl | h : 1 < p ∨ 1 = p ∨ p < 1 := trichotomous 1 p\n  · induction' L with hd tl ih\n    · simp [ofDigits]\n    · simp only [List.length_cons, List.sum_cons, self_div_pow_eq_ofDigits_drop _ _ h,\n          digits_ofDigits p h (hd :: tl) h_lt (fun _ => h_ne_zero)]\n      simp only [ofDigits]\n      rw [sum_range_succ, Nat.cast_id]\n      simp only [List.drop, List.drop_length]\n      obtain rfl | h' := em <| tl = []\n      · simp [ofDigits]\n      · have w₁' := fun l hl ↦ h_lt l <| List.mem_cons_of_mem hd hl\n        have w₂' := fun (h : tl ≠ []) ↦ (List.getLast_cons h) ▸ h_ne_zero\n        have ih := ih (w₂' h') w₁'\n        simp only [self_div_pow_eq_ofDigits_drop _ _ h, digits_ofDigits p h tl w₁' w₂',\n          ← Nat.one_add] at ih\n        have := sum_singleton (fun x ↦ ofDigits p <| tl.drop x) tl.length\n        rw [← Ico_succ_singleton, List.drop_length, ofDigits] at this\n        have h₁ : 1 ≤ tl.length := List.length_pos.mpr h'\n        rw [← sum_range_add_sum_Ico _ <| h₁, ← add_zero (∑ x ∈ Ico _ _, ofDigits p (tl.drop x)),\n            ← this, sum_Ico_consecutive _  h₁ <| (le_add_right tl.length 1),\n            ← sum_Ico_add _ 0 tl.length 1,\n            Ico_zero_eq_range, mul_add, mul_add, ih, range_one, sum_singleton, List.drop, ofDigits,\n            mul_zero, add_zero, ← Nat.add_sub_assoc <| sum_le_ofDigits _ <| Nat.le_of_lt h]\n        nth_rw 2 [← one_mul <| ofDigits p tl]\n        rw [← add_mul, Nat.sub_add_cancel (one_le_of_lt h), Nat.add_sub_add_left]\n  · simp [ofDigits_one]\n  · simp [lt_one_iff.mp h]\n    cases L\n    · rfl\n    · simp [ofDigits]\n\n"}
{"name":"Nat.sub_one_mul_sum_log_div_pow_eq_sub_sum_digits","module":"Mathlib.Data.Nat.Digits","initialProofState":"p n : Nat\n⊢ Eq (HMul.hMul (HSub.hSub p 1) ((Finset.range (Nat.log p n).succ).sum fun i => HDiv.hDiv n (HPow.hPow p i.succ))) (HSub.hSub n (p.digits n).sum)","decl":"theorem sub_one_mul_sum_log_div_pow_eq_sub_sum_digits {p : ℕ} (n : ℕ) :\n    (p - 1) * ∑ i ∈ range (log p n).succ, n / p ^ i.succ = n - (p.digits n).sum := by\n  obtain h | rfl | h : 1 < p ∨ 1 = p ∨ p < 1 := trichotomous 1 p\n  · rcases eq_or_ne n 0 with rfl | hn\n    · simp\n    · convert sub_one_mul_sum_div_pow_eq_sub_sum_digits (p.digits n) (getLast_digit_ne_zero p hn) <|\n          (fun l a ↦ digits_lt_base h a)\n      · refine (digits_len p n h hn).symm\n      all_goals exact (ofDigits_digits p n).symm\n  · simp\n  · simp [lt_one_iff.mp h]\n    cases n\n    all_goals simp\n\n"}
{"name":"Nat.digits_two_eq_bits","module":"Mathlib.Data.Nat.Digits","initialProofState":"n : Nat\n⊢ Eq (Nat.digits 2 n) (List.map (fun b => cond b 1 0) n.bits)","decl":"theorem digits_two_eq_bits (n : ℕ) : digits 2 n = n.bits.map fun b => cond b 1 0 := by\n  induction' n using Nat.binaryRecFromOne with b n h ih\n  · simp\n  · simp\n  rw [bits_append_bit _ _ fun hn => absurd hn h]\n  cases b\n  · rw [digits_def' one_lt_two]\n    · simpa [Nat.bit]\n    · simpa [Nat.bit, pos_iff_ne_zero]\n  · simpa [Nat.bit, add_comm, digits_add 2 one_lt_two 1 n, Nat.add_mul_div_left]\n\n"}
{"name":"Nat.dvd_ofDigits_sub_ofDigits","module":"Mathlib.Data.Nat.Digits","initialProofState":"α : Type u_1\ninst✝ : CommRing α\na b k : α\nh : Dvd.dvd k (HSub.hSub a b)\nL : List Nat\n⊢ Dvd.dvd k (HSub.hSub (Nat.ofDigits a L) (Nat.ofDigits b L))","decl":"theorem dvd_ofDigits_sub_ofDigits {α : Type*} [CommRing α] {a b k : α} (h : k ∣ a - b)\n    (L : List ℕ) : k ∣ ofDigits a L - ofDigits b L := by\n  induction' L with d L ih\n  · change k ∣ 0 - 0\n    simp\n  · simp only [ofDigits, add_sub_add_left_eq_sub]\n    exact dvd_mul_sub_mul h ih\n\n"}
{"name":"Nat.ofDigits_modEq'","module":"Mathlib.Data.Nat.Digits","initialProofState":"b b' k : Nat\nh : k.ModEq b b'\nL : List Nat\n⊢ k.ModEq (Nat.ofDigits b L) (Nat.ofDigits b' L)","decl":"theorem ofDigits_modEq' (b b' : ℕ) (k : ℕ) (h : b ≡ b' [MOD k]) (L : List ℕ) :\n    ofDigits b L ≡ ofDigits b' L [MOD k] := by\n  induction' L with d L ih\n  · rfl\n  · dsimp [ofDigits]\n    dsimp [Nat.ModEq] at *\n    conv_lhs => rw [Nat.add_mod, Nat.mul_mod, h, ih]\n    conv_rhs => rw [Nat.add_mod, Nat.mul_mod]\n\n"}
{"name":"Nat.ofDigits_modEq","module":"Mathlib.Data.Nat.Digits","initialProofState":"b k : Nat\nL : List Nat\n⊢ k.ModEq (Nat.ofDigits b L) (Nat.ofDigits (HMod.hMod b k) L)","decl":"theorem ofDigits_modEq (b k : ℕ) (L : List ℕ) : ofDigits b L ≡ ofDigits (b % k) L [MOD k] :=\n  ofDigits_modEq' b (b % k) k (b.mod_modEq k).symm L\n\n"}
{"name":"Nat.ofDigits_mod","module":"Mathlib.Data.Nat.Digits","initialProofState":"b k : Nat\nL : List Nat\n⊢ Eq (HMod.hMod (Nat.ofDigits b L) k) (HMod.hMod (Nat.ofDigits (HMod.hMod b k) L) k)","decl":"theorem ofDigits_mod (b k : ℕ) (L : List ℕ) : ofDigits b L % k = ofDigits (b % k) L % k :=\n  ofDigits_modEq b k L\n\n"}
{"name":"Nat.ofDigits_mod_eq_head!","module":"Mathlib.Data.Nat.Digits","initialProofState":"b : Nat\nl : List Nat\n⊢ Eq (HMod.hMod (Nat.ofDigits b l) b) (HMod.hMod l.head! b)","decl":"theorem ofDigits_mod_eq_head! (b : ℕ) (l : List ℕ) : ofDigits b l % b = l.head! % b := by\n  induction l <;> simp [Nat.ofDigits, Int.ModEq]\n\n"}
{"name":"Nat.head!_digits","module":"Mathlib.Data.Nat.Digits","initialProofState":"b n : Nat\nh : Ne b 1\n⊢ Eq (b.digits n).head! (HMod.hMod n b)","decl":"theorem head!_digits {b n : ℕ} (h : b ≠ 1) : (Nat.digits b n).head! = n % b := by\n  by_cases hb : 1 < b\n  · rcases n with _ | n\n    · simp\n    · nth_rw 2 [← Nat.ofDigits_digits b (n + 1)]\n      rw [Nat.ofDigits_mod_eq_head! _ _]\n      exact (Nat.mod_eq_of_lt (Nat.digits_lt_base hb <| List.head!_mem_self <|\n          Nat.digits_ne_nil_iff_ne_zero.mpr <| Nat.succ_ne_zero n)).symm\n  · rcases n with _ | _ <;> simp_all [show b = 0 by omega]\n\n"}
{"name":"Nat.ofDigits_zmodeq'","module":"Mathlib.Data.Nat.Digits","initialProofState":"b b' : Int\nk : Nat\nh : (↑k).ModEq b b'\nL : List Nat\n⊢ (↑k).ModEq (Nat.ofDigits b L) (Nat.ofDigits b' L)","decl":"theorem ofDigits_zmodeq' (b b' : ℤ) (k : ℕ) (h : b ≡ b' [ZMOD k]) (L : List ℕ) :\n    ofDigits b L ≡ ofDigits b' L [ZMOD k] := by\n  induction' L with d L ih\n  · rfl\n  · dsimp [ofDigits]\n    dsimp [Int.ModEq] at *\n    conv_lhs => rw [Int.add_emod, Int.mul_emod, h, ih]\n    conv_rhs => rw [Int.add_emod, Int.mul_emod]\n\n"}
{"name":"Nat.ofDigits_zmodeq","module":"Mathlib.Data.Nat.Digits","initialProofState":"b : Int\nk : Nat\nL : List Nat\n⊢ (↑k).ModEq (Nat.ofDigits b L) (Nat.ofDigits (HMod.hMod b ↑k) L)","decl":"theorem ofDigits_zmodeq (b : ℤ) (k : ℕ) (L : List ℕ) : ofDigits b L ≡ ofDigits (b % k) L [ZMOD k] :=\n  ofDigits_zmodeq' b (b % k) k (b.mod_modEq ↑k).symm L\n\n"}
{"name":"Nat.ofDigits_zmod","module":"Mathlib.Data.Nat.Digits","initialProofState":"b : Int\nk : Nat\nL : List Nat\n⊢ Eq (HMod.hMod (Nat.ofDigits b L) ↑k) (HMod.hMod (Nat.ofDigits (HMod.hMod b ↑k) L) ↑k)","decl":"theorem ofDigits_zmod (b : ℤ) (k : ℕ) (L : List ℕ) : ofDigits b L % k = ofDigits (b % k) L % k :=\n  ofDigits_zmodeq b k L\n\n"}
{"name":"Nat.modEq_digits_sum","module":"Mathlib.Data.Nat.Digits","initialProofState":"b b' : Nat\nh : Eq (HMod.hMod b' b) 1\nn : Nat\n⊢ b.ModEq n (b'.digits n).sum","decl":"theorem modEq_digits_sum (b b' : ℕ) (h : b' % b = 1) (n : ℕ) : n ≡ (digits b' n).sum [MOD b] := by\n  rw [← ofDigits_one]\n  conv =>\n    congr\n    · skip\n    · rw [← ofDigits_digits b' n]\n  convert ofDigits_modEq b' b (digits b' n)\n  exact h.symm\n\n"}
{"name":"Nat.modEq_three_digits_sum","module":"Mathlib.Data.Nat.Digits","initialProofState":"n : Nat\n⊢ Nat.ModEq 3 n (Nat.digits 10 n).sum","decl":"theorem modEq_three_digits_sum (n : ℕ) : n ≡ (digits 10 n).sum [MOD 3] :=\n  modEq_digits_sum 3 10 (by norm_num) n\n\n"}
{"name":"Nat.modEq_nine_digits_sum","module":"Mathlib.Data.Nat.Digits","initialProofState":"n : Nat\n⊢ Nat.ModEq 9 n (Nat.digits 10 n).sum","decl":"theorem modEq_nine_digits_sum (n : ℕ) : n ≡ (digits 10 n).sum [MOD 9] :=\n  modEq_digits_sum 9 10 (by norm_num) n\n\n"}
{"name":"Nat.zmodeq_ofDigits_digits","module":"Mathlib.Data.Nat.Digits","initialProofState":"b b' : Nat\nc : Int\nh : (↑b).ModEq (↑b') c\nn : Nat\n⊢ (↑b).ModEq (↑n) (Nat.ofDigits c (b'.digits n))","decl":"theorem zmodeq_ofDigits_digits (b b' : ℕ) (c : ℤ) (h : b' ≡ c [ZMOD b]) (n : ℕ) :\n    n ≡ ofDigits c (digits b' n) [ZMOD b] := by\n  conv =>\n    congr\n    · skip\n    · rw [← ofDigits_digits b' n]\n  rw [coe_int_ofDigits]\n  apply ofDigits_zmodeq' _ _ _ h\n\n"}
{"name":"Nat.ofDigits_neg_one","module":"Mathlib.Data.Nat.Digits","initialProofState":"L : List Nat\n⊢ Eq (Nat.ofDigits (-1) L) (List.map (fun n => ↑n) L).alternatingSum","decl":"theorem ofDigits_neg_one :\n    ∀ L : List ℕ, ofDigits (-1 : ℤ) L = (L.map fun n : ℕ => (n : ℤ)).alternatingSum\n  | [] => rfl\n  | [n] => by simp [ofDigits, List.alternatingSum]\n  | a :: b :: t => by\n    simp only [ofDigits, List.alternatingSum, List.map_cons, ofDigits_neg_one t]\n    ring\n\n"}
{"name":"Nat.modEq_eleven_digits_sum","module":"Mathlib.Data.Nat.Digits","initialProofState":"n : Nat\n⊢ Int.ModEq 11 (↑n) (List.map (fun n => ↑n) (Nat.digits 10 n)).alternatingSum","decl":"theorem modEq_eleven_digits_sum (n : ℕ) :\n    n ≡ ((digits 10 n).map fun n : ℕ => (n : ℤ)).alternatingSum [ZMOD 11] := by\n  have t := zmodeq_ofDigits_digits 11 10 (-1 : ℤ) (by unfold Int.ModEq; rfl) n\n  rwa [ofDigits_neg_one] at t\n\n"}
{"name":"Nat.dvd_iff_dvd_digits_sum","module":"Mathlib.Data.Nat.Digits","initialProofState":"b b' : Nat\nh : Eq (HMod.hMod b' b) 1\nn : Nat\n⊢ Iff (Dvd.dvd b n) (Dvd.dvd b (b'.digits n).sum)","decl":"theorem dvd_iff_dvd_digits_sum (b b' : ℕ) (h : b' % b = 1) (n : ℕ) :\n    b ∣ n ↔ b ∣ (digits b' n).sum := by\n  rw [← ofDigits_one]\n  conv_lhs => rw [← ofDigits_digits b' n]\n  rw [Nat.dvd_iff_mod_eq_zero, Nat.dvd_iff_mod_eq_zero, ofDigits_mod, h]\n\n"}
{"name":"Nat.three_dvd_iff","module":"Mathlib.Data.Nat.Digits","initialProofState":"n : Nat\n⊢ Iff (Dvd.dvd 3 n) (Dvd.dvd 3 (Nat.digits 10 n).sum)","decl":"/-- **Divisibility by 3 Rule** -/\ntheorem three_dvd_iff (n : ℕ) : 3 ∣ n ↔ 3 ∣ (digits 10 n).sum :=\n  dvd_iff_dvd_digits_sum 3 10 (by norm_num) n\n\n"}
{"name":"Nat.nine_dvd_iff","module":"Mathlib.Data.Nat.Digits","initialProofState":"n : Nat\n⊢ Iff (Dvd.dvd 9 n) (Dvd.dvd 9 (Nat.digits 10 n).sum)","decl":"theorem nine_dvd_iff (n : ℕ) : 9 ∣ n ↔ 9 ∣ (digits 10 n).sum :=\n  dvd_iff_dvd_digits_sum 9 10 (by norm_num) n\n\n"}
{"name":"Nat.dvd_iff_dvd_ofDigits","module":"Mathlib.Data.Nat.Digits","initialProofState":"b b' : Nat\nc : Int\nh : Dvd.dvd (↑b) (HSub.hSub (↑b') c)\nn : Nat\n⊢ Iff (Dvd.dvd b n) (Dvd.dvd (↑b) (Nat.ofDigits c (b'.digits n)))","decl":"theorem dvd_iff_dvd_ofDigits (b b' : ℕ) (c : ℤ) (h : (b : ℤ) ∣ (b' : ℤ) - c) (n : ℕ) :\n    b ∣ n ↔ (b : ℤ) ∣ ofDigits c (digits b' n) := by\n  rw [← Int.natCast_dvd_natCast]\n  exact\n    dvd_iff_dvd_of_dvd_sub (zmodeq_ofDigits_digits b b' c (Int.modEq_iff_dvd.2 h).symm _).symm.dvd\n\n"}
{"name":"Nat.eleven_dvd_iff","module":"Mathlib.Data.Nat.Digits","initialProofState":"n : Nat\n⊢ Iff (Dvd.dvd 11 n) (Dvd.dvd 11 (List.map (fun n => ↑n) (Nat.digits 10 n)).alternatingSum)","decl":"theorem eleven_dvd_iff :\n    11 ∣ n ↔ (11 : ℤ) ∣ ((digits 10 n).map fun n : ℕ => (n : ℤ)).alternatingSum := by\n  have t := dvd_iff_dvd_ofDigits 11 10 (-1 : ℤ) (by norm_num) n\n  rw [ofDigits_neg_one] at t\n  exact t\n\n"}
{"name":"Nat.eleven_dvd_of_palindrome","module":"Mathlib.Data.Nat.Digits","initialProofState":"n : Nat\np : (Nat.digits 10 n).Palindrome\nh : Even (Nat.digits 10 n).length\n⊢ Dvd.dvd 11 n","decl":"theorem eleven_dvd_of_palindrome (p : (digits 10 n).Palindrome) (h : Even (digits 10 n).length) :\n    11 ∣ n := by\n  let dig := (digits 10 n).map fun n : ℕ => (n : ℤ)\n  replace h : Even dig.length := by rwa [List.length_map]\n  refine eleven_dvd_iff.2 ⟨0, (?_ : dig.alternatingSum = 0)⟩\n  have := dig.alternatingSum_reverse\n  rw [(p.map _).reverse_eq, _root_.pow_succ', h.neg_one_pow, mul_one, neg_one_zsmul] at this\n  exact eq_zero_of_neg_eq this.symm\n\n"}
{"name":"Nat.toDigitsCore_lens_eq_aux","module":"Mathlib.Data.Nat.Digits","initialProofState":"b f n : Nat\nl1 l2 : List Char\na✝ : Eq l1.length l2.length\n⊢ Eq (b.toDigitsCore f n l1).length (b.toDigitsCore f n l2).length","decl":"lemma toDigitsCore_lens_eq_aux (b f : Nat) :\n    ∀ (n : Nat) (l1 l2 : List Char), l1.length = l2.length →\n    (Nat.toDigitsCore b f n l1).length = (Nat.toDigitsCore b f n l2).length := by\n  induction f with (simp only [Nat.toDigitsCore, List.length]; intro n l1 l2 hlen)\n  | zero => assumption\n  | succ f ih =>\n    if hx : n / b = 0 then\n      simp only [hx, if_true, List.length, congrArg (fun l ↦ l + 1) hlen]\n    else\n      simp only [hx, if_false]\n      specialize ih (n / b) (Nat.digitChar (n % b) :: l1) (Nat.digitChar (n % b) :: l2)\n      simp only [List.length, congrArg (fun l ↦ l + 1) hlen] at ih\n      exact ih trivial\n\n"}
{"name":"Nat.toDigitsCore_lens_eq","module":"Mathlib.Data.Nat.Digits","initialProofState":"b f n : Nat\nc : Char\ntl : List Char\n⊢ Eq (b.toDigitsCore f n (List.cons c tl)).length (HAdd.hAdd (b.toDigitsCore f n tl).length 1)","decl":"lemma toDigitsCore_lens_eq (b f : Nat) : ∀ (n : Nat) (c : Char) (tl : List Char),\n    (Nat.toDigitsCore b f n (c :: tl)).length = (Nat.toDigitsCore b f n tl).length + 1 := by\n  induction f with (intro n c tl; simp only [Nat.toDigitsCore, List.length])\n  | succ f ih =>\n    if hnb : (n / b) = 0 then\n      simp only [hnb, if_true, List.length]\n    else\n      generalize hx : Nat.digitChar (n % b) = x\n      simp only [hx, hnb, if_false] at ih\n      simp only [hnb, if_false]\n      specialize ih (n / b) c (x :: tl)\n      rw [← ih]\n      have lens_eq : (x :: (c :: tl)).length = (c :: x :: tl).length := by simp\n      apply toDigitsCore_lens_eq_aux\n      exact lens_eq\n\n"}
{"name":"Nat.nat_repr_len_aux","module":"Mathlib.Data.Nat.Digits","initialProofState":"n b e : Nat\nh_b_pos : LT.lt 0 b\na✝ : LT.lt n (HPow.hPow b e.succ)\n⊢ LT.lt (HDiv.hDiv n b) (HPow.hPow b e)","decl":"lemma nat_repr_len_aux (n b e : Nat) (h_b_pos : 0 < b) :  n < b ^ e.succ → n / b < b ^ e := by\n  simp only [Nat.pow_succ]\n  exact (@Nat.div_lt_iff_lt_mul b n (b ^ e) h_b_pos).mpr\n\n"}
{"name":"Nat.toDigitsCore_length","module":"Mathlib.Data.Nat.Digits","initialProofState":"b : Nat\nh : LE.le 2 b\nf n e : Nat\nhlt : LT.lt n (HPow.hPow b e)\nh_e_pos : LT.lt 0 e\n⊢ LE.le (b.toDigitsCore f n List.nil).length e","decl":"/-- The String representation produced by toDigitsCore has the proper length relative to\nthe number of digits in `n < e` for some base `b`. Since this works with any base greater\nthan one, it can be used for binary, decimal, and hex. -/\nlemma toDigitsCore_length (b : Nat) (h : 2 <= b) (f n e : Nat)\n    (hlt : n < b ^ e) (h_e_pos : 0 < e) : (Nat.toDigitsCore b f n []).length <= e := by\n  induction f generalizing n e hlt h_e_pos with\n    simp only [Nat.toDigitsCore, List.length, Nat.zero_le]\n  | succ f ih =>\n    cases e with\n    | zero => exact False.elim (Nat.lt_irrefl 0 h_e_pos)\n    | succ e =>\n      if h_pred_pos : 0 < e then\n        have _ : 0 < b := Nat.lt_trans (by decide) h\n        specialize ih (n / b) e (nat_repr_len_aux n b e ‹0 < b› hlt) h_pred_pos\n        if hdiv_ten : n / b = 0 then\n          simp only [hdiv_ten]; exact Nat.le.step h_pred_pos\n        else\n          simp only [hdiv_ten,\n            toDigitsCore_lens_eq b f (n / b) (Nat.digitChar <| n % b), if_false]\n          exact Nat.succ_le_succ ih\n      else\n        obtain rfl : e = 0 := Nat.eq_zero_of_not_pos h_pred_pos\n        have _ : b ^ 1 = b := by simp only [Nat.pow_succ, pow_zero, Nat.one_mul]\n        have _ : n < b := ‹b ^ 1 = b› ▸ hlt\n        simp [(@Nat.div_eq_of_lt n b ‹n < b› : n / b = 0)]\n\n"}
{"name":"Nat.repr_length","module":"Mathlib.Data.Nat.Digits","initialProofState":"n e : Nat\na✝¹ : LT.lt 0 e\na✝ : LT.lt n (HPow.hPow 10 e)\n⊢ LE.le n.repr.length e","decl":"/-- The core implementation of `Nat.repr` returns a String with length less than or equal to the\nnumber of digits in the decimal number (represented by `e`). For example, the decimal string\nrepresentation of any number less than 1000 (10 ^ 3) has a length less than or equal to 3. -/\nlemma repr_length (n e : Nat) : 0 < e → n < 10 ^ e → (Nat.repr n).length <= e := by\n  cases n with\n    (intro e0 he; simp only [Nat.repr, Nat.toDigits, String.length, List.asString])\n  | zero => assumption\n  | succ n =>\n    if hterm : n.succ / 10 = 0 then\n      simp only [hterm, Nat.toDigitsCore]; assumption\n    else\n      exact toDigitsCore_length 10 (by decide) (Nat.succ n + 1) (Nat.succ n) e he e0\n\n"}
{"name":"Nat.NormDigits.digits_succ","module":"Mathlib.Data.Nat.Digits","initialProofState":"b n m r : Nat\nl : List Nat\ne : Eq (HAdd.hAdd r (HMul.hMul b m)) n\nhr : LT.lt r b\nh : And (Eq (b.digits m) l) (And (LT.lt 1 b) (LT.lt 0 m))\n⊢ And (Eq (b.digits n) (List.cons r l)) (And (LT.lt 1 b) (LT.lt 0 n))","decl":"theorem digits_succ (b n m r l) (e : r + b * m = n) (hr : r < b)\n    (h : Nat.digits b m = l ∧ 1 < b ∧ 0 < m) : (Nat.digits b n = r :: l) ∧ 1 < b ∧ 0 < n := by\n  rcases h with ⟨h, b2, m0⟩\n  have b0 : 0 < b := by omega\n  have n0 : 0 < n := by linarith [mul_pos b0 m0]\n  refine ⟨?_, b2, n0⟩\n  obtain ⟨rfl, rfl⟩ := (Nat.div_mod_unique b0).2 ⟨e, hr⟩\n  subst h; exact Nat.digits_def' b2 n0\n\n"}
{"name":"Nat.NormDigits.digits_one","module":"Mathlib.Data.Nat.Digits","initialProofState":"b n : Nat\nn0 : LT.lt 0 n\nnb : LT.lt n b\n⊢ And (Eq (b.digits n) (List.cons n List.nil)) (And (LT.lt 1 b) (LT.lt 0 n))","decl":"theorem digits_one (b n) (n0 : 0 < n) (nb : n < b) : Nat.digits b n = [n] ∧ 1 < b ∧ 0 < n := by\n  have b2 : 1 < b :=\n    lt_iff_add_one_le.mpr (le_trans (add_le_add_right (lt_iff_add_one_le.mp n0) 1) nb)\n  refine ⟨?_, b2, n0⟩\n  rw [Nat.digits_def' b2 n0, Nat.mod_eq_of_lt nb, Nat.div_eq_zero_iff.2 <| .inr nb, Nat.digits_zero]\n\n/-\nPorting note: this part of the file is tactic related.\n\nopen Tactic\n-- failed to format: unknown constant 'term.pseudo.antiquot'\n/-- Helper function for the `norm_digits` tactic. -/ unsafe\n  def\n    eval_aux\n    ( eb : expr ) ( b : ℕ ) : expr → ℕ → instance_cache → tactic ( instance_cache × expr × expr )\n    |\n      en , n , ic\n      =>\n      do\n        let m := n / b\n          let r := n % b\n          let ( ic , er ) ← ic . ofNat r\n          let ( ic , pr ) ← norm_num.prove_lt_nat ic er eb\n          if\n            m = 0\n            then\n            do\n              let ( _ , pn0 ) ← norm_num.prove_pos ic en\n                return\n                  (\n                    ic\n                      ,\n                      q( ( [ $ ( en ) ] : List Nat ) )\n                        ,\n                        q( digits_one $ ( eb ) $ ( en ) $ ( pn0 ) $ ( pr ) )\n                    )\n            else\n            do\n              let em ← expr.of_nat q( ℕ ) m\n                let ( _ , pe ) ← norm_num.derive q( ( $ ( er ) + $ ( eb ) * $ ( em ) : ℕ ) )\n                let ( ic , el , p ) ← eval_aux em m ic\n                return\n                  (\n                    ic\n                      ,\n                      q( @ List.cons ℕ $ ( er ) $ ( el ) )\n                        ,\n                        q(\n                          digits_succ\n                            $ ( eb ) $ ( en ) $ ( em ) $ ( er ) $ ( el ) $ ( pe ) $ ( pr ) $ ( p )\n                          )\n                    )\n\n/-- A tactic for normalizing expressions of the form `Nat.digits a b = l` where\n`a` and `b` are numerals.\n\n```\nexample : Nat.digits 10 123 = [3,2,1] := by norm_num\n```\n-/\n@[norm_num]\nunsafe def eval : expr → tactic (expr × expr)\n  | q(Nat.digits $(eb) $(en)) => do\n    let b ← expr.to_nat eb\n    let n ← expr.to_nat en\n    if n = 0 then return (q(([] : List ℕ)), q(Nat.digits_zero $(eb)))\n      else\n        if b = 0 then do\n          let ic ← mk_instance_cache q(ℕ)\n          let (_, pn0) ← norm_num.prove_ne_zero' ic en\n          return (q(([$(en)] : List ℕ)), q(@Nat.digits_zero_succ' $(en) $(pn0)))\n        else\n          if b = 1 then do\n            let ic ← mk_instance_cache q(ℕ)\n            let s ← simp_lemmas.add_simp simp_lemmas.mk `list.replicate\n            let (rhs, p2, _) ← simplify s [] q(List.replicate $(en) 1)\n            let p ← mk_eq_trans q(Nat.digits_one $(en)) p2\n            return (rhs, p)\n          else do\n            let ic ← mk_instance_cache q(ℕ)\n            let (_, l, p) ← eval_aux eb b en n ic\n            let p ← mk_app `` And.left [p]\n            return (l, p)\n  | _ => failed\n-/\n\n"}
