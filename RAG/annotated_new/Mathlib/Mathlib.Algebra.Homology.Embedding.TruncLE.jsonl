{"name":"HomologicalComplex.truncLE'_d_eq","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_3} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninstâœÂ¹ : e.IsTruncLE\ninstâœ : âˆ€ (i' : Î¹'), K.HasHomology i'\ni j : Î¹\nhij : c.Rel i j\ni' j' : Î¹'\nhi' : Eq (e.f i) i'\nhj' : Eq (e.f j) j'\nhj : Not (e.BoundaryLE j)\nâŠ¢ Eq ((K.truncLE' e).d i j) (CategoryTheory.CategoryStruct.comp (K.truncLE'XIso e hi' â‹¯).hom (CategoryTheory.CategoryStruct.comp (K.d i' j') (K.truncLE'XIso e hj' hj).inv))","decl":"lemma truncLE'_d_eq {i j : Î¹} (hij : c.Rel i j) {i' j' : Î¹'}\n    (hi' : e.f i = i') (hj' : e.f j = j') (hj : Â¬ e.BoundaryLE j) :\n    (K.truncLE' e).d i j = (K.truncLE'XIso e hi' (e.not_boundaryLE_prev hij)).hom â‰« K.d i' j' â‰«\n        (K.truncLE'XIso e hj' hj).inv :=\n  Quiver.Hom.op_inj (by simpa using K.op.truncGE'_d_eq e.op hij hj' hi' (by simpa))\n\n"}
{"name":"HomologicalComplex.truncLE'_d_eq_toCycles","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_3} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninstâœÂ¹ : e.IsTruncLE\ninstâœ : âˆ€ (i' : Î¹'), K.HasHomology i'\ni j : Î¹\nhij : c.Rel i j\ni' j' : Î¹'\nhi' : Eq (e.f i) i'\nhj' : Eq (e.f j) j'\nhj : e.BoundaryLE j\nâŠ¢ Eq ((K.truncLE' e).d i j) (CategoryTheory.CategoryStruct.comp (K.truncLE'XIso e hi' â‹¯).hom (CategoryTheory.CategoryStruct.comp (K.toCycles i' j') (K.truncLE'XIsoCycles e hj' hj).inv))","decl":"lemma truncLE'_d_eq_toCycles {i j : Î¹} (hij : c.Rel i j) {i' j' : Î¹'}\n    (hi' : e.f i = i') (hj' : e.f j = j') (hj : e.BoundaryLE j) :\n    (K.truncLE' e).d i j = (K.truncLE'XIso e hi' (e.not_boundaryLE_prev hij)).hom â‰«\n      K.toCycles i' j' â‰« (K.truncLE'XIsoCycles e hj' hj).inv :=\n  Quiver.Hom.op_inj (by\n    simpa [truncLE', truncLE'XIso, truncLE'XIsoCycles]\n      using K.op.truncGE'_d_eq_fromOpcycles e.op hij hj' hi' (by simpa))\n\n"}
{"name":"HomologicalComplex.truncLE'Map_f_eq_cyclesMap","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_4, u_3} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nK L : HomologicalComplex C c'\nÏ† : Quiver.Hom K L\ne : c.Embedding c'\ninstâœÂ² : e.IsTruncLE\ninstâœÂ¹ : âˆ€ (i' : Î¹'), K.HasHomology i'\ninstâœ : âˆ€ (i' : Î¹'), L.HasHomology i'\ni : Î¹\nhi : e.BoundaryLE i\ni' : Î¹'\nh : Eq (e.f i) i'\nâŠ¢ Eq ((HomologicalComplex.truncLE'Map Ï† e).f i) (CategoryTheory.CategoryStruct.comp (K.truncLE'XIsoCycles e h hi).hom (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cyclesMap Ï† i') (L.truncLE'XIsoCycles e h hi).inv))","decl":"lemma truncLE'Map_f_eq_cyclesMap {i : Î¹} (hi : e.BoundaryLE i) {i' : Î¹'} (h : e.f i = i') :\n    (truncLE'Map Ï† e).f i =\n      (K.truncLE'XIsoCycles e h hi).hom â‰« cyclesMap Ï† i' â‰«\n        (L.truncLE'XIsoCycles e h hi).inv := by\n  apply Quiver.Hom.op_inj\n  dsimp [truncLE'Map, truncLE'XIsoCycles]\n  rw [assoc, assoc, truncGE'Map_f_eq_opcyclesMap _ e.op (by simpa) h,\n    opcyclesOpIso_inv_naturality_assoc, Iso.hom_inv_id_assoc]\n\n"}
{"name":"HomologicalComplex.truncLE'Map_f_eq","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_4, u_3} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nK L : HomologicalComplex C c'\nÏ† : Quiver.Hom K L\ne : c.Embedding c'\ninstâœÂ² : e.IsTruncLE\ninstâœÂ¹ : âˆ€ (i' : Î¹'), K.HasHomology i'\ninstâœ : âˆ€ (i' : Î¹'), L.HasHomology i'\ni : Î¹\nhi : Not (e.BoundaryLE i)\ni' : Î¹'\nh : Eq (e.f i) i'\nâŠ¢ Eq ((HomologicalComplex.truncLE'Map Ï† e).f i) (CategoryTheory.CategoryStruct.comp (K.truncLE'XIso e h hi).hom (CategoryTheory.CategoryStruct.comp (Ï†.f i') (L.truncLE'XIso e h hi).inv))","decl":"lemma truncLE'Map_f_eq {i : Î¹} (hi : Â¬ e.BoundaryLE i) {i' : Î¹'} (h : e.f i = i') :\n    (truncLE'Map Ï† e).f i =\n      (K.truncLE'XIso e h hi).hom â‰« Ï†.f i' â‰« (L.truncLE'XIso e h hi).inv :=\n  Quiver.Hom.op_inj\n    (by simpa using truncGE'Map_f_eq ((opFunctor C c').map Ï†.op) e.op (by simpa) h)\n\n"}
{"name":"HomologicalComplex.truncLE'Map_id","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_3} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninstâœÂ¹ : e.IsTruncLE\ninstâœ : âˆ€ (i' : Î¹'), K.HasHomology i'\nâŠ¢ Eq (HomologicalComplex.truncLE'Map (CategoryTheory.CategoryStruct.id K) e) (CategoryTheory.CategoryStruct.id (K.truncLE' e))","decl":"variable (K) in\n@[simp]\nlemma truncLE'Map_id : truncLE'Map (ğŸ™ K) e = ğŸ™ _ :=\n  (unopFunctor C c.symm).congr_map (congr_arg Quiver.Hom.op (K.op.truncGE'Map_id e.op))\n\n"}
{"name":"HomologicalComplex.truncLE'Map_comp","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœâµ : CategoryTheory.Category.{u_4, u_3} C\ninstâœâ´ : CategoryTheory.Limits.HasZeroMorphisms C\nK L M : HomologicalComplex C c'\nÏ† : Quiver.Hom K L\nÏ†' : Quiver.Hom L M\ne : c.Embedding c'\ninstâœÂ³ : e.IsTruncLE\ninstâœÂ² : âˆ€ (i' : Î¹'), K.HasHomology i'\ninstâœÂ¹ : âˆ€ (i' : Î¹'), L.HasHomology i'\ninstâœ : âˆ€ (i' : Î¹'), M.HasHomology i'\nâŠ¢ Eq (HomologicalComplex.truncLE'Map (CategoryTheory.CategoryStruct.comp Ï† Ï†') e) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.truncLE'Map Ï† e) (HomologicalComplex.truncLE'Map Ï†' e))","decl":"@[reassoc, simp]\nlemma truncLE'Map_comp : truncLE'Map (Ï† â‰« Ï†') e = truncLE'Map Ï† e â‰« truncLE'Map Ï†' e :=\n  (unopFunctor C c.symm).congr_map (congr_arg Quiver.Hom.op\n    (truncGE'Map_comp ((opFunctor C c').map Ï†'.op) ((opFunctor C c').map Ï†.op) e.op))\n\n"}
{"name":"HomologicalComplex.truncLE'Map_comp_assoc","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœâµ : CategoryTheory.Category.{u_4, u_3} C\ninstâœâ´ : CategoryTheory.Limits.HasZeroMorphisms C\nK L M : HomologicalComplex C c'\nÏ† : Quiver.Hom K L\nÏ†' : Quiver.Hom L M\ne : c.Embedding c'\ninstâœÂ³ : e.IsTruncLE\ninstâœÂ² : âˆ€ (i' : Î¹'), K.HasHomology i'\ninstâœÂ¹ : âˆ€ (i' : Î¹'), L.HasHomology i'\ninstâœ : âˆ€ (i' : Î¹'), M.HasHomology i'\nZ : HomologicalComplex C c\nh : Quiver.Hom (M.truncLE' e) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.truncLE'Map (CategoryTheory.CategoryStruct.comp Ï† Ï†') e) h) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.truncLE'Map Ï† e) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.truncLE'Map Ï†' e) h))","decl":"@[reassoc, simp]\nlemma truncLE'Map_comp : truncLE'Map (Ï† â‰« Ï†') e = truncLE'Map Ï† e â‰« truncLE'Map Ï†' e :=\n  (unopFunctor C c.symm).congr_map (congr_arg Quiver.Hom.op\n    (truncGE'Map_comp ((opFunctor C c').map Ï†'.op) ((opFunctor C c').map Ï†.op) e.op))\n\n"}
{"name":"HomologicalComplex.truncLEMap_id","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_4, u_3} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninstâœÂ² : e.IsTruncLE\ninstâœÂ¹ : âˆ€ (i' : Î¹'), K.HasHomology i'\ninstâœ : CategoryTheory.Limits.HasZeroObject C\nâŠ¢ Eq (HomologicalComplex.truncLEMap (CategoryTheory.CategoryStruct.id K) e) (CategoryTheory.CategoryStruct.id (K.truncLE e))","decl":"variable (K) in\n@[simp]\nlemma truncLEMap_id : truncLEMap (ğŸ™ K) e = ğŸ™ _ :=\n  (unopFunctor C c'.symm).congr_map (congr_arg Quiver.Hom.op (K.op.truncGEMap_id e.op))\n\n"}
{"name":"HomologicalComplex.truncLEMap_comp","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœâ¶ : CategoryTheory.Category.{u_4, u_3} C\ninstâœâµ : CategoryTheory.Limits.HasZeroMorphisms C\nK L M : HomologicalComplex C c'\nÏ† : Quiver.Hom K L\nÏ†' : Quiver.Hom L M\ne : c.Embedding c'\ninstâœâ´ : e.IsTruncLE\ninstâœÂ³ : âˆ€ (i' : Î¹'), K.HasHomology i'\ninstâœÂ² : âˆ€ (i' : Î¹'), L.HasHomology i'\ninstâœÂ¹ : âˆ€ (i' : Î¹'), M.HasHomology i'\ninstâœ : CategoryTheory.Limits.HasZeroObject C\nâŠ¢ Eq (HomologicalComplex.truncLEMap (CategoryTheory.CategoryStruct.comp Ï† Ï†') e) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.truncLEMap Ï† e) (HomologicalComplex.truncLEMap Ï†' e))","decl":"@[reassoc, simp]\nlemma truncLEMap_comp : truncLEMap (Ï† â‰« Ï†') e = truncLEMap Ï† e â‰« truncLEMap Ï†' e :=\n  (unopFunctor C c'.symm).congr_map (congr_arg Quiver.Hom.op\n    (truncGEMap_comp ((opFunctor C c').map Ï†'.op) ((opFunctor C c').map Ï†.op) e.op))\n\n"}
{"name":"HomologicalComplex.truncLEMap_comp_assoc","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœâ¶ : CategoryTheory.Category.{u_4, u_3} C\ninstâœâµ : CategoryTheory.Limits.HasZeroMorphisms C\nK L M : HomologicalComplex C c'\nÏ† : Quiver.Hom K L\nÏ†' : Quiver.Hom L M\ne : c.Embedding c'\ninstâœâ´ : e.IsTruncLE\ninstâœÂ³ : âˆ€ (i' : Î¹'), K.HasHomology i'\ninstâœÂ² : âˆ€ (i' : Î¹'), L.HasHomology i'\ninstâœÂ¹ : âˆ€ (i' : Î¹'), M.HasHomology i'\ninstâœ : CategoryTheory.Limits.HasZeroObject C\nZ : HomologicalComplex C c'\nh : Quiver.Hom (M.truncLE e) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.truncLEMap (CategoryTheory.CategoryStruct.comp Ï† Ï†') e) h) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.truncLEMap Ï† e) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.truncLEMap Ï†' e) h))","decl":"@[reassoc, simp]\nlemma truncLEMap_comp : truncLEMap (Ï† â‰« Ï†') e = truncLEMap Ï† e â‰« truncLEMap Ï†' e :=\n  (unopFunctor C c'.symm).congr_map (congr_arg Quiver.Hom.op\n    (truncGEMap_comp ((opFunctor C c').map Ï†'.op) ((opFunctor C c').map Ï†.op) e.op))\n\n"}
{"name":"HomologicalComplex.isIso_truncLE'ToRestriction","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_3} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninstâœÂ¹ : e.IsTruncLE\ninstâœ : âˆ€ (i' : Î¹'), K.HasHomology i'\ni : Î¹\nhi : Not (e.BoundaryLE i)\nâŠ¢ CategoryTheory.IsIso ((K.truncLE'ToRestriction e).f i)","decl":"/-- `(K.truncLE'ToRestriction e).f i` is an isomorphism when `Â¬ e.BoundaryLE i`. -/\nlemma isIso_truncLE'ToRestriction (i : Î¹) (hi : Â¬ e.BoundaryLE i) :\n    IsIso ((K.truncLE'ToRestriction e).f i) := by\n  change IsIso ((K.op.restrictionToTruncGE' e.op).f i).unop\n  have := K.op.isIso_restrictionToTruncGE' e.op i (by simpa)\n  infer_instance\n\n"}
{"name":"HomologicalComplex.truncLE'ToRestriction_naturality_assoc","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_4, u_3} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nK L : HomologicalComplex C c'\nÏ† : Quiver.Hom K L\ne : c.Embedding c'\ninstâœÂ² : e.IsTruncLE\ninstâœÂ¹ : âˆ€ (i' : Î¹'), K.HasHomology i'\ninstâœ : âˆ€ (i' : Î¹'), L.HasHomology i'\nZ : HomologicalComplex C c\nh : Quiver.Hom (L.restriction e) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.truncLE'Map Ï† e) (CategoryTheory.CategoryStruct.comp (L.truncLE'ToRestriction e) h)) (CategoryTheory.CategoryStruct.comp (K.truncLE'ToRestriction e) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.restrictionMap Ï† e) h))","decl":"variable {K L} in\n@[reassoc (attr := simp)]\nlemma truncLE'ToRestriction_naturality :\n    truncLE'Map Ï† e â‰« L.truncLE'ToRestriction e =\n      K.truncLE'ToRestriction e â‰« restrictionMap Ï† e :=\n  (unopFunctor C c.symm).congr_map (congr_arg Quiver.Hom.op\n    (restrictionToTruncGE'_naturality ((opFunctor C c').map Ï†.op) e.op))\n\n"}
{"name":"HomologicalComplex.truncLE'ToRestriction_naturality","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_4, u_3} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nK L : HomologicalComplex C c'\nÏ† : Quiver.Hom K L\ne : c.Embedding c'\ninstâœÂ² : e.IsTruncLE\ninstâœÂ¹ : âˆ€ (i' : Î¹'), K.HasHomology i'\ninstâœ : âˆ€ (i' : Î¹'), L.HasHomology i'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.truncLE'Map Ï† e) (L.truncLE'ToRestriction e)) (CategoryTheory.CategoryStruct.comp (K.truncLE'ToRestriction e) (HomologicalComplex.restrictionMap Ï† e))","decl":"variable {K L} in\n@[reassoc (attr := simp)]\nlemma truncLE'ToRestriction_naturality :\n    truncLE'Map Ï† e â‰« L.truncLE'ToRestriction e =\n      K.truncLE'ToRestriction e â‰« restrictionMap Ï† e :=\n  (unopFunctor C c.symm).congr_map (congr_arg Quiver.Hom.op\n    (restrictionToTruncGE'_naturality ((opFunctor C c').map Ï†.op) e.op))\n\n"}
{"name":"HomologicalComplex.instMonoFTruncLE'ToRestriction","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_3} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninstâœÂ¹ : e.IsTruncLE\ninstâœ : âˆ€ (i' : Î¹'), K.HasHomology i'\ni : Î¹\nâŠ¢ CategoryTheory.Mono ((K.truncLE'ToRestriction e).f i)","decl":"instance (i : Î¹) : Mono ((K.truncLE'ToRestriction e).f i) :=\n  inferInstanceAs (Mono ((K.op.restrictionToTruncGE' e.op).f i).unop)\n\n"}
{"name":"HomologicalComplex.instIsIsoFTruncLE'ToRestrictionOfIsStrictlySupported","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_4, u_3} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninstâœÂ² : e.IsTruncLE\ninstâœÂ¹ : âˆ€ (i' : Î¹'), K.HasHomology i'\ninstâœ : K.IsStrictlySupported e\ni : Î¹\nâŠ¢ CategoryTheory.IsIso ((K.truncLE'ToRestriction e).f i)","decl":"instance [K.IsStrictlySupported e] (i : Î¹) :\n    IsIso ((K.truncLE'ToRestriction e).f i) :=\n  inferInstanceAs (IsIso ((K.op.restrictionToTruncGE' e.op).f i).unop)\n\n"}
{"name":"HomologicalComplex.instMonoFÎ¹TruncLE","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_4, u_3} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninstâœÂ² : e.IsTruncLE\ninstâœÂ¹ : âˆ€ (i' : Î¹'), K.HasHomology i'\ninstâœ : CategoryTheory.Limits.HasZeroObject C\ni' : Î¹'\nâŠ¢ CategoryTheory.Mono ((K.Î¹TruncLE e).f i')","decl":"instance (i' : Î¹') : Mono ((K.Î¹TruncLE e).f i') :=\n  inferInstanceAs (Mono ((K.op.Ï€TruncGE e.op).f i').unop)\n\n"}
{"name":"HomologicalComplex.instMonoÎ¹TruncLE","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_4, u_3} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninstâœÂ² : e.IsTruncLE\ninstâœÂ¹ : âˆ€ (i' : Î¹'), K.HasHomology i'\ninstâœ : CategoryTheory.Limits.HasZeroObject C\nâŠ¢ CategoryTheory.Mono (K.Î¹TruncLE e)","decl":"instance : Mono (K.Î¹TruncLE e) := mono_of_mono_f _ (fun _ => inferInstance)\n\n"}
{"name":"HomologicalComplex.instIsStrictlySupportedTruncLE","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_4, u_3} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninstâœÂ² : e.IsTruncLE\ninstâœÂ¹ : âˆ€ (i' : Î¹'), K.HasHomology i'\ninstâœ : CategoryTheory.Limits.HasZeroObject C\nâŠ¢ (K.truncLE e).IsStrictlySupported e","decl":"instance : (K.truncLE e).IsStrictlySupported e := by\n  rw [â† isStrictlySupported_op_iff]\n  exact inferInstanceAs ((K.op.truncGE e.op).IsStrictlySupported e.op)\n\n"}
{"name":"HomologicalComplex.Î¹TruncLE_naturality_assoc","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœâµ : CategoryTheory.Category.{u_4, u_3} C\ninstâœâ´ : CategoryTheory.Limits.HasZeroMorphisms C\nK L : HomologicalComplex C c'\nÏ† : Quiver.Hom K L\ne : c.Embedding c'\ninstâœÂ³ : e.IsTruncLE\ninstâœÂ² : âˆ€ (i' : Î¹'), K.HasHomology i'\ninstâœÂ¹ : âˆ€ (i' : Î¹'), L.HasHomology i'\ninstâœ : CategoryTheory.Limits.HasZeroObject C\nZ : HomologicalComplex C c'\nh : Quiver.Hom L Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.truncLEMap Ï† e) (CategoryTheory.CategoryStruct.comp (L.Î¹TruncLE e) h)) (CategoryTheory.CategoryStruct.comp (K.Î¹TruncLE e) (CategoryTheory.CategoryStruct.comp Ï† h))","decl":"variable {K L} in\n@[reassoc (attr := simp)]\nlemma Î¹TruncLE_naturality :\n    truncLEMap Ï† e â‰« L.Î¹TruncLE e = K.Î¹TruncLE e â‰« Ï† :=\n  (unopFunctor C c'.symm).congr_map (congr_arg Quiver.Hom.op\n    (Ï€TruncGE_naturality ((opFunctor C c').map Ï†.op) e.op))\n\n"}
{"name":"HomologicalComplex.Î¹TruncLE_naturality","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœâµ : CategoryTheory.Category.{u_4, u_3} C\ninstâœâ´ : CategoryTheory.Limits.HasZeroMorphisms C\nK L : HomologicalComplex C c'\nÏ† : Quiver.Hom K L\ne : c.Embedding c'\ninstâœÂ³ : e.IsTruncLE\ninstâœÂ² : âˆ€ (i' : Î¹'), K.HasHomology i'\ninstâœÂ¹ : âˆ€ (i' : Î¹'), L.HasHomology i'\ninstâœ : CategoryTheory.Limits.HasZeroObject C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.truncLEMap Ï† e) (L.Î¹TruncLE e)) (CategoryTheory.CategoryStruct.comp (K.Î¹TruncLE e) Ï†)","decl":"variable {K L} in\n@[reassoc (attr := simp)]\nlemma Î¹TruncLE_naturality :\n    truncLEMap Ï† e â‰« L.Î¹TruncLE e = K.Î¹TruncLE e â‰« Ï† :=\n  (unopFunctor C c'.symm).congr_map (congr_arg Quiver.Hom.op\n    (Ï€TruncGE_naturality ((opFunctor C c').map Ï†.op) e.op))\n\n"}
{"name":"HomologicalComplex.instIsStrictlySupportedTruncLE_1","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœâµ : CategoryTheory.Category.{u_5, u_3} C\ninstâœâ´ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninstâœÂ³ : e.IsTruncLE\ninstâœÂ² : âˆ€ (i' : Î¹'), K.HasHomology i'\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroObject C\nÎ¹'' : Type u_4\nc'' : ComplexShape Î¹''\ne' : c''.Embedding c'\ninstâœ : K.IsStrictlySupported e'\nâŠ¢ (K.truncLE e).IsStrictlySupported e'","decl":"instance {Î¹'' : Type*} {c'' : ComplexShape Î¹''} (e' : c''.Embedding c')\n    [K.IsStrictlySupported e'] : (K.truncLE e).IsStrictlySupported e' := by\n  rw [â† isStrictlySupported_op_iff]\n  exact inferInstanceAs ((K.op.truncGE e.op).IsStrictlySupported e'.op)\n\n"}
{"name":"HomologicalComplex.instIsIsoÎ¹TruncLEOfIsStrictlySupported","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœâµ : CategoryTheory.Category.{u_4, u_3} C\ninstâœâ´ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninstâœÂ³ : e.IsTruncLE\ninstâœÂ² : âˆ€ (i' : Î¹'), K.HasHomology i'\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroObject C\ninstâœ : K.IsStrictlySupported e\nâŠ¢ CategoryTheory.IsIso (K.Î¹TruncLE e)","decl":"instance [K.IsStrictlySupported e] : IsIso (K.Î¹TruncLE e) :=\n  inferInstanceAs (IsIso ((unopFunctor C c'.symm).map (K.op.Ï€TruncGE e.op).op))\n\n"}
{"name":"ComplexShape.Embedding.truncLE'Functor_obj","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\ne : c.Embedding c'\ninstâœÂ³ : e.IsTruncLE\nC : Type u_4\ninstâœÂ² : CategoryTheory.Category.{u_5, u_4} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.CategoryWithHomology C\nK : HomologicalComplex C c'\nâŠ¢ Eq ((e.truncLE'Functor C).obj K) (K.truncLE' e)","decl":"/-- Given an embedding `e : Embedding c c'` of complex shapes which satisfy `e.IsTruncLE`,\nthis is the (canonical) truncation functor\n`HomologicalComplex C c' â¥¤ HomologicalComplex C c`. -/\n@[simps]\nnoncomputable def truncLE'Functor :\n    HomologicalComplex C c' â¥¤ HomologicalComplex C c where\n  obj K := K.truncLE' e\n  map Ï† := HomologicalComplex.truncLE'Map Ï† e\n\n"}
{"name":"ComplexShape.Embedding.truncLE'Functor_map","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\ne : c.Embedding c'\ninstâœÂ³ : e.IsTruncLE\nC : Type u_4\ninstâœÂ² : CategoryTheory.Category.{u_5, u_4} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.CategoryWithHomology C\nXâœ Yâœ : HomologicalComplex C c'\nÏ† : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((e.truncLE'Functor C).map Ï†) (HomologicalComplex.truncLE'Map Ï† e)","decl":"/-- Given an embedding `e : Embedding c c'` of complex shapes which satisfy `e.IsTruncLE`,\nthis is the (canonical) truncation functor\n`HomologicalComplex C c' â¥¤ HomologicalComplex C c`. -/\n@[simps]\nnoncomputable def truncLE'Functor :\n    HomologicalComplex C c' â¥¤ HomologicalComplex C c where\n  obj K := K.truncLE' e\n  map Ï† := HomologicalComplex.truncLE'Map Ï† e\n\n"}
{"name":"ComplexShape.Embedding.truncLE'ToRestrictionNatTrans_app","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\ne : c.Embedding c'\ninstâœÂ³ : e.IsTruncLE\nC : Type u_4\ninstâœÂ² : CategoryTheory.Category.{u_5, u_4} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.CategoryWithHomology C\nK : HomologicalComplex C c'\nâŠ¢ Eq ((e.truncLE'ToRestrictionNatTrans C).app K) (K.truncLE'ToRestriction e)","decl":"/-- The natural transformation `K.truncGE' e âŸ¶ K.restriction e` for all `K`. -/\n@[simps]\nnoncomputable def truncLE'ToRestrictionNatTrans :\n    e.truncLE'Functor C âŸ¶ e.restrictionFunctor C where\n  app K := K.truncLE'ToRestriction e\n\n"}
{"name":"ComplexShape.Embedding.truncLEFunctor_obj","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\ne : c.Embedding c'\ninstâœâ´ : e.IsTruncLE\nC : Type u_4\ninstâœÂ³ : CategoryTheory.Category.{u_5, u_4} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroObject C\ninstâœ : CategoryTheory.CategoryWithHomology C\nK : HomologicalComplex C c'\nâŠ¢ Eq ((e.truncLEFunctor C).obj K) (K.truncLE e)","decl":"/-- Given an embedding `e : Embedding c c'` of complex shapes which satisfy `e.IsTruncLE`,\nthis is the (canonical) truncation functor\n`HomologicalComplex C c' â¥¤ HomologicalComplex C c'`. -/\n@[simps]\nnoncomputable def truncLEFunctor :\n    HomologicalComplex C c' â¥¤ HomologicalComplex C c' where\n  obj K := K.truncLE e\n  map Ï† := HomologicalComplex.truncLEMap Ï† e\n\n"}
{"name":"ComplexShape.Embedding.truncLEFunctor_map","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\ne : c.Embedding c'\ninstâœâ´ : e.IsTruncLE\nC : Type u_4\ninstâœÂ³ : CategoryTheory.Category.{u_5, u_4} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroObject C\ninstâœ : CategoryTheory.CategoryWithHomology C\nXâœ Yâœ : HomologicalComplex C c'\nÏ† : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((e.truncLEFunctor C).map Ï†) (HomologicalComplex.truncLEMap Ï† e)","decl":"/-- Given an embedding `e : Embedding c c'` of complex shapes which satisfy `e.IsTruncLE`,\nthis is the (canonical) truncation functor\n`HomologicalComplex C c' â¥¤ HomologicalComplex C c'`. -/\n@[simps]\nnoncomputable def truncLEFunctor :\n    HomologicalComplex C c' â¥¤ HomologicalComplex C c' where\n  obj K := K.truncLE e\n  map Ï† := HomologicalComplex.truncLEMap Ï† e\n\n"}
{"name":"ComplexShape.Embedding.Î¹TruncLENatTrans_app","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\ne : c.Embedding c'\ninstâœâ´ : e.IsTruncLE\nC : Type u_4\ninstâœÂ³ : CategoryTheory.Category.{u_5, u_4} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroObject C\ninstâœ : CategoryTheory.CategoryWithHomology C\nK : HomologicalComplex C c'\nâŠ¢ Eq ((e.Î¹TruncLENatTrans C).app K) (K.Î¹TruncLE e)","decl":"/-- The natural transformation `K.Î¹TruncLE e : K.truncLE e âŸ¶ K` for all `K`. -/\n@[simps]\nnoncomputable def Î¹TruncLENatTrans : e.truncLEFunctor C âŸ¶ ğŸ­ _ where\n  app K := K.Î¹TruncLE e\n\n"}
