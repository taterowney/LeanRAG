{"name":"HomologicalComplex.truncLE'_d_eq","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_3} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninst✝¹ : e.IsTruncLE\ninst✝ : ∀ (i' : ι'), K.HasHomology i'\ni j : ι\nhij : c.Rel i j\ni' j' : ι'\nhi' : Eq (e.f i) i'\nhj' : Eq (e.f j) j'\nhj : Not (e.BoundaryLE j)\n⊢ Eq ((K.truncLE' e).d i j) (CategoryTheory.CategoryStruct.comp (K.truncLE'XIso e hi' ⋯).hom (CategoryTheory.CategoryStruct.comp (K.d i' j') (K.truncLE'XIso e hj' hj).inv))","decl":"lemma truncLE'_d_eq {i j : ι} (hij : c.Rel i j) {i' j' : ι'}\n    (hi' : e.f i = i') (hj' : e.f j = j') (hj : ¬ e.BoundaryLE j) :\n    (K.truncLE' e).d i j = (K.truncLE'XIso e hi' (e.not_boundaryLE_prev hij)).hom ≫ K.d i' j' ≫\n        (K.truncLE'XIso e hj' hj).inv :=\n  Quiver.Hom.op_inj (by simpa using K.op.truncGE'_d_eq e.op hij hj' hi' (by simpa))\n\n"}
{"name":"HomologicalComplex.truncLE'_d_eq_toCycles","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_3} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninst✝¹ : e.IsTruncLE\ninst✝ : ∀ (i' : ι'), K.HasHomology i'\ni j : ι\nhij : c.Rel i j\ni' j' : ι'\nhi' : Eq (e.f i) i'\nhj' : Eq (e.f j) j'\nhj : e.BoundaryLE j\n⊢ Eq ((K.truncLE' e).d i j) (CategoryTheory.CategoryStruct.comp (K.truncLE'XIso e hi' ⋯).hom (CategoryTheory.CategoryStruct.comp (K.toCycles i' j') (K.truncLE'XIsoCycles e hj' hj).inv))","decl":"lemma truncLE'_d_eq_toCycles {i j : ι} (hij : c.Rel i j) {i' j' : ι'}\n    (hi' : e.f i = i') (hj' : e.f j = j') (hj : e.BoundaryLE j) :\n    (K.truncLE' e).d i j = (K.truncLE'XIso e hi' (e.not_boundaryLE_prev hij)).hom ≫\n      K.toCycles i' j' ≫ (K.truncLE'XIsoCycles e hj' hj).inv :=\n  Quiver.Hom.op_inj (by\n    simpa [truncLE', truncLE'XIso, truncLE'XIsoCycles]\n      using K.op.truncGE'_d_eq_fromOpcycles e.op hij hj' hi' (by simpa))\n\n"}
{"name":"HomologicalComplex.truncLE'Map_f_eq_cyclesMap","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nK L : HomologicalComplex C c'\nφ : Quiver.Hom K L\ne : c.Embedding c'\ninst✝² : e.IsTruncLE\ninst✝¹ : ∀ (i' : ι'), K.HasHomology i'\ninst✝ : ∀ (i' : ι'), L.HasHomology i'\ni : ι\nhi : e.BoundaryLE i\ni' : ι'\nh : Eq (e.f i) i'\n⊢ Eq ((HomologicalComplex.truncLE'Map φ e).f i) (CategoryTheory.CategoryStruct.comp (K.truncLE'XIsoCycles e h hi).hom (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cyclesMap φ i') (L.truncLE'XIsoCycles e h hi).inv))","decl":"lemma truncLE'Map_f_eq_cyclesMap {i : ι} (hi : e.BoundaryLE i) {i' : ι'} (h : e.f i = i') :\n    (truncLE'Map φ e).f i =\n      (K.truncLE'XIsoCycles e h hi).hom ≫ cyclesMap φ i' ≫\n        (L.truncLE'XIsoCycles e h hi).inv := by\n  apply Quiver.Hom.op_inj\n  dsimp [truncLE'Map, truncLE'XIsoCycles]\n  rw [assoc, assoc, truncGE'Map_f_eq_opcyclesMap _ e.op (by simpa) h,\n    opcyclesOpIso_inv_naturality_assoc, Iso.hom_inv_id_assoc]\n\n"}
{"name":"HomologicalComplex.truncLE'Map_f_eq","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nK L : HomologicalComplex C c'\nφ : Quiver.Hom K L\ne : c.Embedding c'\ninst✝² : e.IsTruncLE\ninst✝¹ : ∀ (i' : ι'), K.HasHomology i'\ninst✝ : ∀ (i' : ι'), L.HasHomology i'\ni : ι\nhi : Not (e.BoundaryLE i)\ni' : ι'\nh : Eq (e.f i) i'\n⊢ Eq ((HomologicalComplex.truncLE'Map φ e).f i) (CategoryTheory.CategoryStruct.comp (K.truncLE'XIso e h hi).hom (CategoryTheory.CategoryStruct.comp (φ.f i') (L.truncLE'XIso e h hi).inv))","decl":"lemma truncLE'Map_f_eq {i : ι} (hi : ¬ e.BoundaryLE i) {i' : ι'} (h : e.f i = i') :\n    (truncLE'Map φ e).f i =\n      (K.truncLE'XIso e h hi).hom ≫ φ.f i' ≫ (L.truncLE'XIso e h hi).inv :=\n  Quiver.Hom.op_inj\n    (by simpa using truncGE'Map_f_eq ((opFunctor C c').map φ.op) e.op (by simpa) h)\n\n"}
{"name":"HomologicalComplex.truncLE'Map_id","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_3} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninst✝¹ : e.IsTruncLE\ninst✝ : ∀ (i' : ι'), K.HasHomology i'\n⊢ Eq (HomologicalComplex.truncLE'Map (CategoryTheory.CategoryStruct.id K) e) (CategoryTheory.CategoryStruct.id (K.truncLE' e))","decl":"variable (K) in\n@[simp]\nlemma truncLE'Map_id : truncLE'Map (𝟙 K) e = 𝟙 _ :=\n  (unopFunctor C c.symm).congr_map (congr_arg Quiver.Hom.op (K.op.truncGE'Map_id e.op))\n\n"}
{"name":"HomologicalComplex.truncLE'Map_comp","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁵ : CategoryTheory.Category.{u_4, u_3} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\nK L M : HomologicalComplex C c'\nφ : Quiver.Hom K L\nφ' : Quiver.Hom L M\ne : c.Embedding c'\ninst✝³ : e.IsTruncLE\ninst✝² : ∀ (i' : ι'), K.HasHomology i'\ninst✝¹ : ∀ (i' : ι'), L.HasHomology i'\ninst✝ : ∀ (i' : ι'), M.HasHomology i'\n⊢ Eq (HomologicalComplex.truncLE'Map (CategoryTheory.CategoryStruct.comp φ φ') e) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.truncLE'Map φ e) (HomologicalComplex.truncLE'Map φ' e))","decl":"@[reassoc, simp]\nlemma truncLE'Map_comp : truncLE'Map (φ ≫ φ') e = truncLE'Map φ e ≫ truncLE'Map φ' e :=\n  (unopFunctor C c.symm).congr_map (congr_arg Quiver.Hom.op\n    (truncGE'Map_comp ((opFunctor C c').map φ'.op) ((opFunctor C c').map φ.op) e.op))\n\n"}
{"name":"HomologicalComplex.truncLE'Map_comp_assoc","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁵ : CategoryTheory.Category.{u_4, u_3} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\nK L M : HomologicalComplex C c'\nφ : Quiver.Hom K L\nφ' : Quiver.Hom L M\ne : c.Embedding c'\ninst✝³ : e.IsTruncLE\ninst✝² : ∀ (i' : ι'), K.HasHomology i'\ninst✝¹ : ∀ (i' : ι'), L.HasHomology i'\ninst✝ : ∀ (i' : ι'), M.HasHomology i'\nZ : HomologicalComplex C c\nh : Quiver.Hom (M.truncLE' e) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.truncLE'Map (CategoryTheory.CategoryStruct.comp φ φ') e) h) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.truncLE'Map φ e) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.truncLE'Map φ' e) h))","decl":"@[reassoc, simp]\nlemma truncLE'Map_comp : truncLE'Map (φ ≫ φ') e = truncLE'Map φ e ≫ truncLE'Map φ' e :=\n  (unopFunctor C c.symm).congr_map (congr_arg Quiver.Hom.op\n    (truncGE'Map_comp ((opFunctor C c').map φ'.op) ((opFunctor C c').map φ.op) e.op))\n\n"}
{"name":"HomologicalComplex.truncLEMap_id","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninst✝² : e.IsTruncLE\ninst✝¹ : ∀ (i' : ι'), K.HasHomology i'\ninst✝ : CategoryTheory.Limits.HasZeroObject C\n⊢ Eq (HomologicalComplex.truncLEMap (CategoryTheory.CategoryStruct.id K) e) (CategoryTheory.CategoryStruct.id (K.truncLE e))","decl":"variable (K) in\n@[simp]\nlemma truncLEMap_id : truncLEMap (𝟙 K) e = 𝟙 _ :=\n  (unopFunctor C c'.symm).congr_map (congr_arg Quiver.Hom.op (K.op.truncGEMap_id e.op))\n\n"}
{"name":"HomologicalComplex.truncLEMap_comp","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁶ : CategoryTheory.Category.{u_4, u_3} C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms C\nK L M : HomologicalComplex C c'\nφ : Quiver.Hom K L\nφ' : Quiver.Hom L M\ne : c.Embedding c'\ninst✝⁴ : e.IsTruncLE\ninst✝³ : ∀ (i' : ι'), K.HasHomology i'\ninst✝² : ∀ (i' : ι'), L.HasHomology i'\ninst✝¹ : ∀ (i' : ι'), M.HasHomology i'\ninst✝ : CategoryTheory.Limits.HasZeroObject C\n⊢ Eq (HomologicalComplex.truncLEMap (CategoryTheory.CategoryStruct.comp φ φ') e) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.truncLEMap φ e) (HomologicalComplex.truncLEMap φ' e))","decl":"@[reassoc, simp]\nlemma truncLEMap_comp : truncLEMap (φ ≫ φ') e = truncLEMap φ e ≫ truncLEMap φ' e :=\n  (unopFunctor C c'.symm).congr_map (congr_arg Quiver.Hom.op\n    (truncGEMap_comp ((opFunctor C c').map φ'.op) ((opFunctor C c').map φ.op) e.op))\n\n"}
{"name":"HomologicalComplex.truncLEMap_comp_assoc","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁶ : CategoryTheory.Category.{u_4, u_3} C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms C\nK L M : HomologicalComplex C c'\nφ : Quiver.Hom K L\nφ' : Quiver.Hom L M\ne : c.Embedding c'\ninst✝⁴ : e.IsTruncLE\ninst✝³ : ∀ (i' : ι'), K.HasHomology i'\ninst✝² : ∀ (i' : ι'), L.HasHomology i'\ninst✝¹ : ∀ (i' : ι'), M.HasHomology i'\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nZ : HomologicalComplex C c'\nh : Quiver.Hom (M.truncLE e) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.truncLEMap (CategoryTheory.CategoryStruct.comp φ φ') e) h) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.truncLEMap φ e) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.truncLEMap φ' e) h))","decl":"@[reassoc, simp]\nlemma truncLEMap_comp : truncLEMap (φ ≫ φ') e = truncLEMap φ e ≫ truncLEMap φ' e :=\n  (unopFunctor C c'.symm).congr_map (congr_arg Quiver.Hom.op\n    (truncGEMap_comp ((opFunctor C c').map φ'.op) ((opFunctor C c').map φ.op) e.op))\n\n"}
{"name":"HomologicalComplex.isIso_truncLE'ToRestriction","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_3} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninst✝¹ : e.IsTruncLE\ninst✝ : ∀ (i' : ι'), K.HasHomology i'\ni : ι\nhi : Not (e.BoundaryLE i)\n⊢ CategoryTheory.IsIso ((K.truncLE'ToRestriction e).f i)","decl":"/-- `(K.truncLE'ToRestriction e).f i` is an isomorphism when `¬ e.BoundaryLE i`. -/\nlemma isIso_truncLE'ToRestriction (i : ι) (hi : ¬ e.BoundaryLE i) :\n    IsIso ((K.truncLE'ToRestriction e).f i) := by\n  change IsIso ((K.op.restrictionToTruncGE' e.op).f i).unop\n  have := K.op.isIso_restrictionToTruncGE' e.op i (by simpa)\n  infer_instance\n\n"}
{"name":"HomologicalComplex.truncLE'ToRestriction_naturality_assoc","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nK L : HomologicalComplex C c'\nφ : Quiver.Hom K L\ne : c.Embedding c'\ninst✝² : e.IsTruncLE\ninst✝¹ : ∀ (i' : ι'), K.HasHomology i'\ninst✝ : ∀ (i' : ι'), L.HasHomology i'\nZ : HomologicalComplex C c\nh : Quiver.Hom (L.restriction e) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.truncLE'Map φ e) (CategoryTheory.CategoryStruct.comp (L.truncLE'ToRestriction e) h)) (CategoryTheory.CategoryStruct.comp (K.truncLE'ToRestriction e) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.restrictionMap φ e) h))","decl":"variable {K L} in\n@[reassoc (attr := simp)]\nlemma truncLE'ToRestriction_naturality :\n    truncLE'Map φ e ≫ L.truncLE'ToRestriction e =\n      K.truncLE'ToRestriction e ≫ restrictionMap φ e :=\n  (unopFunctor C c.symm).congr_map (congr_arg Quiver.Hom.op\n    (restrictionToTruncGE'_naturality ((opFunctor C c').map φ.op) e.op))\n\n"}
{"name":"HomologicalComplex.truncLE'ToRestriction_naturality","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nK L : HomologicalComplex C c'\nφ : Quiver.Hom K L\ne : c.Embedding c'\ninst✝² : e.IsTruncLE\ninst✝¹ : ∀ (i' : ι'), K.HasHomology i'\ninst✝ : ∀ (i' : ι'), L.HasHomology i'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.truncLE'Map φ e) (L.truncLE'ToRestriction e)) (CategoryTheory.CategoryStruct.comp (K.truncLE'ToRestriction e) (HomologicalComplex.restrictionMap φ e))","decl":"variable {K L} in\n@[reassoc (attr := simp)]\nlemma truncLE'ToRestriction_naturality :\n    truncLE'Map φ e ≫ L.truncLE'ToRestriction e =\n      K.truncLE'ToRestriction e ≫ restrictionMap φ e :=\n  (unopFunctor C c.symm).congr_map (congr_arg Quiver.Hom.op\n    (restrictionToTruncGE'_naturality ((opFunctor C c').map φ.op) e.op))\n\n"}
{"name":"HomologicalComplex.instMonoFTruncLE'ToRestriction","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_3} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninst✝¹ : e.IsTruncLE\ninst✝ : ∀ (i' : ι'), K.HasHomology i'\ni : ι\n⊢ CategoryTheory.Mono ((K.truncLE'ToRestriction e).f i)","decl":"instance (i : ι) : Mono ((K.truncLE'ToRestriction e).f i) :=\n  inferInstanceAs (Mono ((K.op.restrictionToTruncGE' e.op).f i).unop)\n\n"}
{"name":"HomologicalComplex.instIsIsoFTruncLE'ToRestrictionOfIsStrictlySupported","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninst✝² : e.IsTruncLE\ninst✝¹ : ∀ (i' : ι'), K.HasHomology i'\ninst✝ : K.IsStrictlySupported e\ni : ι\n⊢ CategoryTheory.IsIso ((K.truncLE'ToRestriction e).f i)","decl":"instance [K.IsStrictlySupported e] (i : ι) :\n    IsIso ((K.truncLE'ToRestriction e).f i) :=\n  inferInstanceAs (IsIso ((K.op.restrictionToTruncGE' e.op).f i).unop)\n\n"}
{"name":"HomologicalComplex.instMonoFιTruncLE","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninst✝² : e.IsTruncLE\ninst✝¹ : ∀ (i' : ι'), K.HasHomology i'\ninst✝ : CategoryTheory.Limits.HasZeroObject C\ni' : ι'\n⊢ CategoryTheory.Mono ((K.ιTruncLE e).f i')","decl":"instance (i' : ι') : Mono ((K.ιTruncLE e).f i') :=\n  inferInstanceAs (Mono ((K.op.πTruncGE e.op).f i').unop)\n\n"}
{"name":"HomologicalComplex.instMonoιTruncLE","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninst✝² : e.IsTruncLE\ninst✝¹ : ∀ (i' : ι'), K.HasHomology i'\ninst✝ : CategoryTheory.Limits.HasZeroObject C\n⊢ CategoryTheory.Mono (K.ιTruncLE e)","decl":"instance : Mono (K.ιTruncLE e) := mono_of_mono_f _ (fun _ => inferInstance)\n\n"}
{"name":"HomologicalComplex.instIsStrictlySupportedTruncLE","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninst✝² : e.IsTruncLE\ninst✝¹ : ∀ (i' : ι'), K.HasHomology i'\ninst✝ : CategoryTheory.Limits.HasZeroObject C\n⊢ (K.truncLE e).IsStrictlySupported e","decl":"instance : (K.truncLE e).IsStrictlySupported e := by\n  rw [← isStrictlySupported_op_iff]\n  exact inferInstanceAs ((K.op.truncGE e.op).IsStrictlySupported e.op)\n\n"}
{"name":"HomologicalComplex.ιTruncLE_naturality_assoc","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁵ : CategoryTheory.Category.{u_4, u_3} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\nK L : HomologicalComplex C c'\nφ : Quiver.Hom K L\ne : c.Embedding c'\ninst✝³ : e.IsTruncLE\ninst✝² : ∀ (i' : ι'), K.HasHomology i'\ninst✝¹ : ∀ (i' : ι'), L.HasHomology i'\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nZ : HomologicalComplex C c'\nh : Quiver.Hom L Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.truncLEMap φ e) (CategoryTheory.CategoryStruct.comp (L.ιTruncLE e) h)) (CategoryTheory.CategoryStruct.comp (K.ιTruncLE e) (CategoryTheory.CategoryStruct.comp φ h))","decl":"variable {K L} in\n@[reassoc (attr := simp)]\nlemma ιTruncLE_naturality :\n    truncLEMap φ e ≫ L.ιTruncLE e = K.ιTruncLE e ≫ φ :=\n  (unopFunctor C c'.symm).congr_map (congr_arg Quiver.Hom.op\n    (πTruncGE_naturality ((opFunctor C c').map φ.op) e.op))\n\n"}
{"name":"HomologicalComplex.ιTruncLE_naturality","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁵ : CategoryTheory.Category.{u_4, u_3} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\nK L : HomologicalComplex C c'\nφ : Quiver.Hom K L\ne : c.Embedding c'\ninst✝³ : e.IsTruncLE\ninst✝² : ∀ (i' : ι'), K.HasHomology i'\ninst✝¹ : ∀ (i' : ι'), L.HasHomology i'\ninst✝ : CategoryTheory.Limits.HasZeroObject C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.truncLEMap φ e) (L.ιTruncLE e)) (CategoryTheory.CategoryStruct.comp (K.ιTruncLE e) φ)","decl":"variable {K L} in\n@[reassoc (attr := simp)]\nlemma ιTruncLE_naturality :\n    truncLEMap φ e ≫ L.ιTruncLE e = K.ιTruncLE e ≫ φ :=\n  (unopFunctor C c'.symm).congr_map (congr_arg Quiver.Hom.op\n    (πTruncGE_naturality ((opFunctor C c').map φ.op) e.op))\n\n"}
{"name":"HomologicalComplex.instIsStrictlySupportedTruncLE_1","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁵ : CategoryTheory.Category.{u_5, u_3} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninst✝³ : e.IsTruncLE\ninst✝² : ∀ (i' : ι'), K.HasHomology i'\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\nι'' : Type u_4\nc'' : ComplexShape ι''\ne' : c''.Embedding c'\ninst✝ : K.IsStrictlySupported e'\n⊢ (K.truncLE e).IsStrictlySupported e'","decl":"instance {ι'' : Type*} {c'' : ComplexShape ι''} (e' : c''.Embedding c')\n    [K.IsStrictlySupported e'] : (K.truncLE e).IsStrictlySupported e' := by\n  rw [← isStrictlySupported_op_iff]\n  exact inferInstanceAs ((K.op.truncGE e.op).IsStrictlySupported e'.op)\n\n"}
{"name":"HomologicalComplex.instIsIsoιTruncLEOfIsStrictlySupported","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝⁵ : CategoryTheory.Category.{u_4, u_3} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninst✝³ : e.IsTruncLE\ninst✝² : ∀ (i' : ι'), K.HasHomology i'\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : K.IsStrictlySupported e\n⊢ CategoryTheory.IsIso (K.ιTruncLE e)","decl":"instance [K.IsStrictlySupported e] : IsIso (K.ιTruncLE e) :=\n  inferInstanceAs (IsIso ((unopFunctor C c'.symm).map (K.op.πTruncGE e.op).op))\n\n"}
{"name":"ComplexShape.Embedding.truncLE'Functor_obj","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\ninst✝³ : e.IsTruncLE\nC : Type u_4\ninst✝² : CategoryTheory.Category.{u_5, u_4} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.CategoryWithHomology C\nK : HomologicalComplex C c'\n⊢ Eq ((e.truncLE'Functor C).obj K) (K.truncLE' e)","decl":"/-- Given an embedding `e : Embedding c c'` of complex shapes which satisfy `e.IsTruncLE`,\nthis is the (canonical) truncation functor\n`HomologicalComplex C c' ⥤ HomologicalComplex C c`. -/\n@[simps]\nnoncomputable def truncLE'Functor :\n    HomologicalComplex C c' ⥤ HomologicalComplex C c where\n  obj K := K.truncLE' e\n  map φ := HomologicalComplex.truncLE'Map φ e\n\n"}
{"name":"ComplexShape.Embedding.truncLE'Functor_map","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\ninst✝³ : e.IsTruncLE\nC : Type u_4\ninst✝² : CategoryTheory.Category.{u_5, u_4} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.CategoryWithHomology C\nX✝ Y✝ : HomologicalComplex C c'\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq ((e.truncLE'Functor C).map φ) (HomologicalComplex.truncLE'Map φ e)","decl":"/-- Given an embedding `e : Embedding c c'` of complex shapes which satisfy `e.IsTruncLE`,\nthis is the (canonical) truncation functor\n`HomologicalComplex C c' ⥤ HomologicalComplex C c`. -/\n@[simps]\nnoncomputable def truncLE'Functor :\n    HomologicalComplex C c' ⥤ HomologicalComplex C c where\n  obj K := K.truncLE' e\n  map φ := HomologicalComplex.truncLE'Map φ e\n\n"}
{"name":"ComplexShape.Embedding.truncLE'ToRestrictionNatTrans_app","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\ninst✝³ : e.IsTruncLE\nC : Type u_4\ninst✝² : CategoryTheory.Category.{u_5, u_4} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.CategoryWithHomology C\nK : HomologicalComplex C c'\n⊢ Eq ((e.truncLE'ToRestrictionNatTrans C).app K) (K.truncLE'ToRestriction e)","decl":"/-- The natural transformation `K.truncGE' e ⟶ K.restriction e` for all `K`. -/\n@[simps]\nnoncomputable def truncLE'ToRestrictionNatTrans :\n    e.truncLE'Functor C ⟶ e.restrictionFunctor C where\n  app K := K.truncLE'ToRestriction e\n\n"}
{"name":"ComplexShape.Embedding.truncLEFunctor_obj","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\ninst✝⁴ : e.IsTruncLE\nC : Type u_4\ninst✝³ : CategoryTheory.Category.{u_5, u_4} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.CategoryWithHomology C\nK : HomologicalComplex C c'\n⊢ Eq ((e.truncLEFunctor C).obj K) (K.truncLE e)","decl":"/-- Given an embedding `e : Embedding c c'` of complex shapes which satisfy `e.IsTruncLE`,\nthis is the (canonical) truncation functor\n`HomologicalComplex C c' ⥤ HomologicalComplex C c'`. -/\n@[simps]\nnoncomputable def truncLEFunctor :\n    HomologicalComplex C c' ⥤ HomologicalComplex C c' where\n  obj K := K.truncLE e\n  map φ := HomologicalComplex.truncLEMap φ e\n\n"}
{"name":"ComplexShape.Embedding.truncLEFunctor_map","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\ninst✝⁴ : e.IsTruncLE\nC : Type u_4\ninst✝³ : CategoryTheory.Category.{u_5, u_4} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.CategoryWithHomology C\nX✝ Y✝ : HomologicalComplex C c'\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq ((e.truncLEFunctor C).map φ) (HomologicalComplex.truncLEMap φ e)","decl":"/-- Given an embedding `e : Embedding c c'` of complex shapes which satisfy `e.IsTruncLE`,\nthis is the (canonical) truncation functor\n`HomologicalComplex C c' ⥤ HomologicalComplex C c'`. -/\n@[simps]\nnoncomputable def truncLEFunctor :\n    HomologicalComplex C c' ⥤ HomologicalComplex C c' where\n  obj K := K.truncLE e\n  map φ := HomologicalComplex.truncLEMap φ e\n\n"}
{"name":"ComplexShape.Embedding.ιTruncLENatTrans_app","module":"Mathlib.Algebra.Homology.Embedding.TruncLE","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\ninst✝⁴ : e.IsTruncLE\nC : Type u_4\ninst✝³ : CategoryTheory.Category.{u_5, u_4} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.CategoryWithHomology C\nK : HomologicalComplex C c'\n⊢ Eq ((e.ιTruncLENatTrans C).app K) (K.ιTruncLE e)","decl":"/-- The natural transformation `K.ιTruncLE e : K.truncLE e ⟶ K` for all `K`. -/\n@[simps]\nnoncomputable def ιTruncLENatTrans : e.truncLEFunctor C ⟶ 𝟭 _ where\n  app K := K.ιTruncLE e\n\n"}
