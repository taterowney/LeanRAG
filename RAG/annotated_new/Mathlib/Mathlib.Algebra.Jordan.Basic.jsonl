{"name":"IsJordan.rmul_comm_rmul_rmul","module":"Mathlib.Algebra.Jordan.Basic","initialProofState":"A : Type u_1\ninst✝ : Mul A\nself : IsJordan A\na b : A\n⊢ Eq (HMul.hMul (HMul.hMul b a) (HMul.hMul a a)) (HMul.hMul (HMul.hMul b (HMul.hMul a a)) a)","decl":"/-- A (non-commutative) Jordan multiplication. -/\nclass IsJordan [Mul A] : Prop where\n  lmul_comm_rmul : ∀ a b : A, a * b * a = a * (b * a)\n  lmul_lmul_comm_lmul : ∀ a b : A, a * a * (a * b) = a * (a * a * b)\n  lmul_lmul_comm_rmul : ∀ a b : A, a * a * (b * a) = a * a * b * a\n  lmul_comm_rmul_rmul : ∀ a b : A, a * b * (a * a) = a * (b * (a * a))\n  rmul_comm_rmul_rmul : ∀ a b : A, b * a * (a * a) = b * (a * a) * a\n\n"}
{"name":"IsJordan.lmul_lmul_comm_rmul","module":"Mathlib.Algebra.Jordan.Basic","initialProofState":"A : Type u_1\ninst✝ : Mul A\nself : IsJordan A\na b : A\n⊢ Eq (HMul.hMul (HMul.hMul a a) (HMul.hMul b a)) (HMul.hMul (HMul.hMul (HMul.hMul a a) b) a)","decl":"/-- A (non-commutative) Jordan multiplication. -/\nclass IsJordan [Mul A] : Prop where\n  lmul_comm_rmul : ∀ a b : A, a * b * a = a * (b * a)\n  lmul_lmul_comm_lmul : ∀ a b : A, a * a * (a * b) = a * (a * a * b)\n  lmul_lmul_comm_rmul : ∀ a b : A, a * a * (b * a) = a * a * b * a\n  lmul_comm_rmul_rmul : ∀ a b : A, a * b * (a * a) = a * (b * (a * a))\n  rmul_comm_rmul_rmul : ∀ a b : A, b * a * (a * a) = b * (a * a) * a\n\n"}
{"name":"IsJordan.lmul_comm_rmul","module":"Mathlib.Algebra.Jordan.Basic","initialProofState":"A : Type u_1\ninst✝ : Mul A\nself : IsJordan A\na b : A\n⊢ Eq (HMul.hMul (HMul.hMul a b) a) (HMul.hMul a (HMul.hMul b a))","decl":"/-- A (non-commutative) Jordan multiplication. -/\nclass IsJordan [Mul A] : Prop where\n  lmul_comm_rmul : ∀ a b : A, a * b * a = a * (b * a)\n  lmul_lmul_comm_lmul : ∀ a b : A, a * a * (a * b) = a * (a * a * b)\n  lmul_lmul_comm_rmul : ∀ a b : A, a * a * (b * a) = a * a * b * a\n  lmul_comm_rmul_rmul : ∀ a b : A, a * b * (a * a) = a * (b * (a * a))\n  rmul_comm_rmul_rmul : ∀ a b : A, b * a * (a * a) = b * (a * a) * a\n\n"}
{"name":"IsJordan.lmul_comm_rmul_rmul","module":"Mathlib.Algebra.Jordan.Basic","initialProofState":"A : Type u_1\ninst✝ : Mul A\nself : IsJordan A\na b : A\n⊢ Eq (HMul.hMul (HMul.hMul a b) (HMul.hMul a a)) (HMul.hMul a (HMul.hMul b (HMul.hMul a a)))","decl":"/-- A (non-commutative) Jordan multiplication. -/\nclass IsJordan [Mul A] : Prop where\n  lmul_comm_rmul : ∀ a b : A, a * b * a = a * (b * a)\n  lmul_lmul_comm_lmul : ∀ a b : A, a * a * (a * b) = a * (a * a * b)\n  lmul_lmul_comm_rmul : ∀ a b : A, a * a * (b * a) = a * a * b * a\n  lmul_comm_rmul_rmul : ∀ a b : A, a * b * (a * a) = a * (b * (a * a))\n  rmul_comm_rmul_rmul : ∀ a b : A, b * a * (a * a) = b * (a * a) * a\n\n"}
{"name":"IsJordan.lmul_lmul_comm_lmul","module":"Mathlib.Algebra.Jordan.Basic","initialProofState":"A : Type u_1\ninst✝ : Mul A\nself : IsJordan A\na b : A\n⊢ Eq (HMul.hMul (HMul.hMul a a) (HMul.hMul a b)) (HMul.hMul a (HMul.hMul (HMul.hMul a a) b))","decl":"/-- A (non-commutative) Jordan multiplication. -/\nclass IsJordan [Mul A] : Prop where\n  lmul_comm_rmul : ∀ a b : A, a * b * a = a * (b * a)\n  lmul_lmul_comm_lmul : ∀ a b : A, a * a * (a * b) = a * (a * a * b)\n  lmul_lmul_comm_rmul : ∀ a b : A, a * a * (b * a) = a * a * b * a\n  lmul_comm_rmul_rmul : ∀ a b : A, a * b * (a * a) = a * (b * (a * a))\n  rmul_comm_rmul_rmul : ∀ a b : A, b * a * (a * a) = b * (a * a) * a\n\n"}
{"name":"IsCommJordan.lmul_comm_rmul_rmul","module":"Mathlib.Algebra.Jordan.Basic","initialProofState":"A : Type u_1\ninst✝ : CommMagma A\nself : IsCommJordan A\na b : A\n⊢ Eq (HMul.hMul (HMul.hMul a b) (HMul.hMul a a)) (HMul.hMul a (HMul.hMul b (HMul.hMul a a)))","decl":"/-- A commutative Jordan multiplication -/\nclass IsCommJordan [CommMagma A] : Prop where\n  lmul_comm_rmul_rmul : ∀ a b : A, a * b * (a * a) = a * (b * (a * a))\n\n-- see Note [lower instance priority]\n"}
{"name":"IsCommJordan.toIsJordan","module":"Mathlib.Algebra.Jordan.Basic","initialProofState":"A : Type u_1\ninst✝¹ : CommMagma A\ninst✝ : IsCommJordan A\n⊢ IsJordan A","decl":"/-- A (commutative) Jordan multiplication is also a Jordan multiplication -/\ninstance (priority := 100) IsCommJordan.toIsJordan [CommMagma A] [IsCommJordan A] : IsJordan A where\n  lmul_comm_rmul a b := by rw [mul_comm, mul_comm a b]\n  lmul_lmul_comm_lmul a b := by\n    rw [mul_comm (a * a) (a * b), IsCommJordan.lmul_comm_rmul_rmul,\n      mul_comm b (a * a)]\n  lmul_comm_rmul_rmul := IsCommJordan.lmul_comm_rmul_rmul\n  lmul_lmul_comm_rmul a b := by\n    rw [mul_comm (a * a) (b * a), mul_comm b a,\n      IsCommJordan.lmul_comm_rmul_rmul, mul_comm, mul_comm b (a * a)]\n  rmul_comm_rmul_rmul a b := by\n    rw [mul_comm b a, IsCommJordan.lmul_comm_rmul_rmul, mul_comm]\n\n-- see Note [lower instance priority]\n"}
{"name":"Semigroup.isJordan","module":"Mathlib.Algebra.Jordan.Basic","initialProofState":"A : Type u_1\ninst✝ : Semigroup A\n⊢ IsJordan A","decl":"/-- Semigroup multiplication satisfies the (non-commutative) Jordan axioms -/\ninstance (priority := 100) Semigroup.isJordan [Semigroup A] : IsJordan A where\n  lmul_comm_rmul a b := by rw [mul_assoc]\n  lmul_lmul_comm_lmul a b := by rw [mul_assoc, mul_assoc]\n  lmul_comm_rmul_rmul a b := by rw [mul_assoc]\n  lmul_lmul_comm_rmul a b := by rw [← mul_assoc]\n  rmul_comm_rmul_rmul a b := by rw [← mul_assoc, ← mul_assoc]\n\n-- see Note [lower instance priority]\n"}
{"name":"CommSemigroup.isCommJordan","module":"Mathlib.Algebra.Jordan.Basic","initialProofState":"A : Type u_1\ninst✝ : CommSemigroup A\n⊢ IsCommJordan A","decl":"instance (priority := 100) CommSemigroup.isCommJordan [CommSemigroup A] : IsCommJordan A where\n  lmul_comm_rmul_rmul _ _ := mul_assoc _ _ _\n\n"}
{"name":"commute_lmul_rmul","module":"Mathlib.Algebra.Jordan.Basic","initialProofState":"A : Type u_1\ninst✝¹ : NonUnitalNonAssocRing A\ninst✝ : IsJordan A\na : A\n⊢ Commute (AddMonoid.End.mulLeft a) (AddMonoid.End.mulRight a)","decl":"@[simp]\ntheorem commute_lmul_rmul (a : A) : Commute (L a) (R a) :=\n  AddMonoidHom.ext fun _ => (IsJordan.lmul_comm_rmul _ _).symm\n\n"}
{"name":"commute_lmul_lmul_sq","module":"Mathlib.Algebra.Jordan.Basic","initialProofState":"A : Type u_1\ninst✝¹ : NonUnitalNonAssocRing A\ninst✝ : IsJordan A\na : A\n⊢ Commute (AddMonoid.End.mulLeft a) (AddMonoid.End.mulLeft (HMul.hMul a a))","decl":"@[simp]\ntheorem commute_lmul_lmul_sq (a : A) : Commute (L a) (L (a * a)) :=\n  AddMonoidHom.ext fun _ => (IsJordan.lmul_lmul_comm_lmul _ _).symm\n\n"}
{"name":"commute_lmul_rmul_sq","module":"Mathlib.Algebra.Jordan.Basic","initialProofState":"A : Type u_1\ninst✝¹ : NonUnitalNonAssocRing A\ninst✝ : IsJordan A\na : A\n⊢ Commute (AddMonoid.End.mulLeft a) (AddMonoid.End.mulRight (HMul.hMul a a))","decl":"@[simp]\ntheorem commute_lmul_rmul_sq (a : A) : Commute (L a) (R (a * a)) :=\n  AddMonoidHom.ext fun _ => (IsJordan.lmul_comm_rmul_rmul _ _).symm\n\n"}
{"name":"commute_lmul_sq_rmul","module":"Mathlib.Algebra.Jordan.Basic","initialProofState":"A : Type u_1\ninst✝¹ : NonUnitalNonAssocRing A\ninst✝ : IsJordan A\na : A\n⊢ Commute (AddMonoid.End.mulLeft (HMul.hMul a a)) (AddMonoid.End.mulRight a)","decl":"@[simp]\ntheorem commute_lmul_sq_rmul (a : A) : Commute (L (a * a)) (R a) :=\n  AddMonoidHom.ext fun _ => IsJordan.lmul_lmul_comm_rmul _ _\n\n"}
{"name":"commute_rmul_rmul_sq","module":"Mathlib.Algebra.Jordan.Basic","initialProofState":"A : Type u_1\ninst✝¹ : NonUnitalNonAssocRing A\ninst✝ : IsJordan A\na : A\n⊢ Commute (AddMonoid.End.mulRight a) (AddMonoid.End.mulRight (HMul.hMul a a))","decl":"@[simp]\ntheorem commute_rmul_rmul_sq (a : A) : Commute (R a) (R (a * a)) :=\n  AddMonoidHom.ext fun _ => (IsJordan.rmul_comm_rmul_rmul _ _).symm\n\n"}
{"name":"two_nsmul_lie_lmul_lmul_add_eq_lie_lmul_lmul_add","module":"Mathlib.Algebra.Jordan.Basic","initialProofState":"A : Type u_1\ninst✝¹ : NonUnitalNonAssocCommRing A\ninst✝ : IsCommJordan A\na b : A\n⊢ Eq (HSMul.hSMul 2 (HAdd.hAdd (Bracket.bracket (AddMonoid.End.mulLeft a) (AddMonoid.End.mulLeft (HMul.hMul a b))) (Bracket.bracket (AddMonoid.End.mulLeft b) (AddMonoid.End.mulLeft (HMul.hMul b a))))) (HAdd.hAdd (Bracket.bracket (AddMonoid.End.mulLeft (HMul.hMul a a)) (AddMonoid.End.mulLeft b)) (Bracket.bracket (AddMonoid.End.mulLeft (HMul.hMul b b)) (AddMonoid.End.mulLeft a)))","decl":"theorem two_nsmul_lie_lmul_lmul_add_eq_lie_lmul_lmul_add [IsCommJordan A] (a b : A) :\n    2 • (⁅L a, L (a * b)⁆ + ⁅L b, L (b * a)⁆) = ⁅L (a * a), L b⁆ + ⁅L (b * b), L a⁆ := by\n  suffices 2 • ⁅L a, L (a * b)⁆ + 2 • ⁅L b, L (b * a)⁆ + ⁅L b, L (a * a)⁆ + ⁅L a, L (b * b)⁆ = 0 by\n    rwa [← sub_eq_zero, ← sub_sub, sub_eq_add_neg, sub_eq_add_neg, lie_skew, lie_skew, nsmul_add]\n  convert (commute_lmul_lmul_sq (a + b)).lie_eq using 1\n  simp only [add_mul, mul_add, map_add, lie_add, add_lie, mul_comm b a,\n    (commute_lmul_lmul_sq a).lie_eq, (commute_lmul_lmul_sq b).lie_eq, zero_add, add_zero, two_smul]\n  abel\n\n-- Porting note: the monolithic `calc`-based proof of `two_nsmul_lie_lmul_lmul_add_add_eq_zero`\n-- has had four auxiliary parts `aux{0,1,2,3}` split off from it.\n"}
{"name":"two_nsmul_lie_lmul_lmul_add_add_eq_zero","module":"Mathlib.Algebra.Jordan.Basic","initialProofState":"A : Type u_1\ninst✝¹ : NonUnitalNonAssocCommRing A\ninst✝ : IsCommJordan A\na b c : A\n⊢ Eq (HSMul.hSMul 2 (HAdd.hAdd (HAdd.hAdd (Bracket.bracket (AddMonoid.End.mulLeft a) (AddMonoid.End.mulLeft (HMul.hMul b c))) (Bracket.bracket (AddMonoid.End.mulLeft b) (AddMonoid.End.mulLeft (HMul.hMul c a)))) (Bracket.bracket (AddMonoid.End.mulLeft c) (AddMonoid.End.mulLeft (HMul.hMul a b))))) 0","decl":"theorem two_nsmul_lie_lmul_lmul_add_add_eq_zero (a b c : A) :\n    2 • (⁅L a, L (b * c)⁆ + ⁅L b, L (c * a)⁆ + ⁅L c, L (a * b)⁆) = 0 := by\n  symm\n  calc\n    0 = ⁅L (a + b + c), L ((a + b + c) * (a + b + c))⁆ := by\n      rw [(commute_lmul_lmul_sq (a + b + c)).lie_eq]\n    _ = _ := by rw [aux0, aux1, aux2, aux3, nsmul_add, nsmul_add]\n"}
