{"name":"AddMonoid.exponent_additive","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Monoid G\n⊢ Eq (AddMonoid.exponent (Additive G)) (Monoid.exponent G)","decl":"@[simp]\ntheorem _root_.AddMonoid.exponent_additive :\n    AddMonoid.exponent (Additive G) = exponent G := rfl\n\n"}
{"name":"Monoid.exponent_multiplicative","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\n⊢ Eq (Monoid.exponent (Multiplicative G)) (AddMonoid.exponent G)","decl":"@[simp]\ntheorem exponent_multiplicative {G : Type*} [AddMonoid G] :\n    exponent (Multiplicative G) = AddMonoid.exponent G := rfl\n\n"}
{"name":"AddOpposite.exponent","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddMonoid G\n⊢ Eq (AddMonoid.exponent (AddOpposite G)) (AddMonoid.exponent G)","decl":"open MulOpposite in\n@[to_additive (attr := simp)]\ntheorem _root_.MulOpposite.exponent : exponent (MulOpposite G) = exponent G := by\n  simp only [Monoid.exponent, ExponentExists]\n  congr!\n  all_goals exact ⟨(op_injective <| · <| op ·), (unop_injective <| · <| unop ·)⟩\n\n"}
{"name":"MulOpposite.exponent","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Monoid G\n⊢ Eq (Monoid.exponent (MulOpposite G)) (Monoid.exponent G)","decl":"open MulOpposite in\n@[to_additive (attr := simp)]\ntheorem _root_.MulOpposite.exponent : exponent (MulOpposite G) = exponent G := by\n  simp only [Monoid.exponent, ExponentExists]\n  congr!\n  all_goals exact ⟨(op_injective <| · <| op ·), (unop_injective <| · <| unop ·)⟩\n\n"}
{"name":"AddMonoid.ExponentExists.isOfFinAddOrder","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddMonoid G\nh : AddMonoid.ExponentExists G\ng : G\n⊢ IsOfFinAddOrder g","decl":"@[to_additive]\ntheorem ExponentExists.isOfFinOrder (h : ExponentExists G) {g : G} : IsOfFinOrder g :=\n  isOfFinOrder_iff_pow_eq_one.mpr <| by peel 2 h; exact this g\n\n"}
{"name":"Monoid.ExponentExists.isOfFinOrder","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Monoid G\nh : Monoid.ExponentExists G\ng : G\n⊢ IsOfFinOrder g","decl":"@[to_additive]\ntheorem ExponentExists.isOfFinOrder (h : ExponentExists G) {g : G} : IsOfFinOrder g :=\n  isOfFinOrder_iff_pow_eq_one.mpr <| by peel 2 h; exact this g\n\n"}
{"name":"Monoid.ExponentExists.orderOf_pos","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Monoid G\nh : Monoid.ExponentExists G\ng : G\n⊢ LT.lt 0 (orderOf g)","decl":"@[to_additive]\ntheorem ExponentExists.orderOf_pos (h : ExponentExists G) (g : G) : 0 < orderOf g :=\n  h.isOfFinOrder.orderOf_pos\n\n"}
{"name":"AddMonoid.ExponentExists.addOrderOf_pos","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddMonoid G\nh : AddMonoid.ExponentExists G\ng : G\n⊢ LT.lt 0 (addOrderOf g)","decl":"@[to_additive]\ntheorem ExponentExists.orderOf_pos (h : ExponentExists G) (g : G) : 0 < orderOf g :=\n  h.isOfFinOrder.orderOf_pos\n\n"}
{"name":"AddMonoid.exponent_ne_zero","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddMonoid G\n⊢ Iff (Ne (AddMonoid.exponent G) 0) (AddMonoid.ExponentExists G)","decl":"@[to_additive]\ntheorem exponent_ne_zero : exponent G ≠ 0 ↔ ExponentExists G := by\n  rw [exponent]\n  split_ifs with h\n  · simp [h, @not_lt_zero' ℕ]\n  --if this isn't done this way, `to_additive` freaks\n  · tauto\n\n"}
{"name":"Monoid.exponent_ne_zero","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Monoid G\n⊢ Iff (Ne (Monoid.exponent G) 0) (Monoid.ExponentExists G)","decl":"@[to_additive]\ntheorem exponent_ne_zero : exponent G ≠ 0 ↔ ExponentExists G := by\n  rw [exponent]\n  split_ifs with h\n  · simp [h, @not_lt_zero' ℕ]\n  --if this isn't done this way, `to_additive` freaks\n  · tauto\n\n"}
{"name":"Monoid.ExponentExists.exponent_ne_zero","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Monoid G\na✝ : Monoid.ExponentExists G\n⊢ Ne (Monoid.exponent G) 0","decl":"@[to_additive]\nprotected alias ⟨_, ExponentExists.exponent_ne_zero⟩ := exponent_ne_zero\n\n"}
{"name":"AddMonoid.ExponentExists.exponent_ne_zero","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddMonoid G\na✝ : AddMonoid.ExponentExists G\n⊢ Ne (AddMonoid.exponent G) 0","decl":"@[to_additive]\nprotected alias ⟨_, ExponentExists.exponent_ne_zero⟩ := exponent_ne_zero\n\n"}
{"name":"AddMonoid.exponent_pos","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddMonoid G\n⊢ Iff (LT.lt 0 (AddMonoid.exponent G)) (AddMonoid.ExponentExists G)","decl":"@[to_additive]\ntheorem exponent_pos : 0 < exponent G ↔ ExponentExists G :=\n  pos_iff_ne_zero.trans exponent_ne_zero\n\n"}
{"name":"Monoid.exponent_pos","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Monoid G\n⊢ Iff (LT.lt 0 (Monoid.exponent G)) (Monoid.ExponentExists G)","decl":"@[to_additive]\ntheorem exponent_pos : 0 < exponent G ↔ ExponentExists G :=\n  pos_iff_ne_zero.trans exponent_ne_zero\n\n"}
{"name":"AddMonoid.ExponentExists.exponent_pos","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddMonoid G\na✝ : AddMonoid.ExponentExists G\n⊢ LT.lt 0 (AddMonoid.exponent G)","decl":"@[to_additive]\nprotected alias ⟨_, ExponentExists.exponent_pos⟩ := exponent_pos\n\n"}
{"name":"Monoid.ExponentExists.exponent_pos","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Monoid G\na✝ : Monoid.ExponentExists G\n⊢ LT.lt 0 (Monoid.exponent G)","decl":"@[to_additive]\nprotected alias ⟨_, ExponentExists.exponent_pos⟩ := exponent_pos\n\n"}
{"name":"Monoid.exponent_eq_zero_iff","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Monoid G\n⊢ Iff (Eq (Monoid.exponent G) 0) (Not (Monoid.ExponentExists G))","decl":"@[to_additive]\ntheorem exponent_eq_zero_iff : exponent G = 0 ↔ ¬ExponentExists G :=\n  exponent_ne_zero.not_right\n\n"}
{"name":"AddMonoid.exponent_eq_zero_iff","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddMonoid G\n⊢ Iff (Eq (AddMonoid.exponent G) 0) (Not (AddMonoid.ExponentExists G))","decl":"@[to_additive]\ntheorem exponent_eq_zero_iff : exponent G = 0 ↔ ¬ExponentExists G :=\n  exponent_ne_zero.not_right\n\n"}
{"name":"Monoid.exponent_eq_zero_of_order_zero","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Monoid G\ng : G\nhg : Eq (orderOf g) 0\n⊢ Eq (Monoid.exponent G) 0","decl":"@[to_additive exponent_eq_zero_addOrder_zero]\ntheorem exponent_eq_zero_of_order_zero {g : G} (hg : orderOf g = 0) : exponent G = 0 :=\n  exponent_eq_zero_iff.mpr fun h ↦ h.orderOf_pos g |>.ne' hg\n\n"}
{"name":"AddMonoid.exponent_eq_zero_addOrder_zero","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddMonoid G\ng : G\nhg : Eq (addOrderOf g) 0\n⊢ Eq (AddMonoid.exponent G) 0","decl":"@[to_additive exponent_eq_zero_addOrder_zero]\ntheorem exponent_eq_zero_of_order_zero {g : G} (hg : orderOf g = 0) : exponent G = 0 :=\n  exponent_eq_zero_iff.mpr fun h ↦ h.orderOf_pos g |>.ne' hg\n\n"}
{"name":"AddMonoid.exponent_eq_zero_iff_forall","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddMonoid G\n⊢ Iff (Eq (AddMonoid.exponent G) 0) (∀ (n : Nat), GT.gt n 0 → Exists fun g => Ne (HSMul.hSMul n g) 0)","decl":"/-- The exponent is zero iff for all nonzero `n`, one can find a `g` such that `g ^ n ≠ 1`. -/\n@[to_additive \"The exponent is zero iff for all nonzero `n`, one can find a `g` such that\n`n • g ≠ 0`.\"]\ntheorem exponent_eq_zero_iff_forall : exponent G = 0 ↔ ∀ n > 0, ∃ g : G, g ^ n ≠ 1 := by\n  rw [exponent_eq_zero_iff, ExponentExists]\n  push_neg\n  rfl\n\n"}
{"name":"Monoid.exponent_eq_zero_iff_forall","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Monoid G\n⊢ Iff (Eq (Monoid.exponent G) 0) (∀ (n : Nat), GT.gt n 0 → Exists fun g => Ne (HPow.hPow g n) 1)","decl":"/-- The exponent is zero iff for all nonzero `n`, one can find a `g` such that `g ^ n ≠ 1`. -/\n@[to_additive \"The exponent is zero iff for all nonzero `n`, one can find a `g` such that\n`n • g ≠ 0`.\"]\ntheorem exponent_eq_zero_iff_forall : exponent G = 0 ↔ ∀ n > 0, ∃ g : G, g ^ n ≠ 1 := by\n  rw [exponent_eq_zero_iff, ExponentExists]\n  push_neg\n  rfl\n\n"}
{"name":"AddMonoid.exponent_nsmul_eq_zero","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddMonoid G\ng : G\n⊢ Eq (HSMul.hSMul (AddMonoid.exponent G) g) 0","decl":"@[to_additive exponent_nsmul_eq_zero]\ntheorem pow_exponent_eq_one (g : G) : g ^ exponent G = 1 := by\n  classical\n  by_cases h : ExponentExists G\n  · simp_rw [exponent, dif_pos h]\n    exact (Nat.find_spec h).2 g\n  · simp_rw [exponent, dif_neg h, pow_zero]\n\n"}
{"name":"Monoid.pow_exponent_eq_one","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Monoid G\ng : G\n⊢ Eq (HPow.hPow g (Monoid.exponent G)) 1","decl":"@[to_additive exponent_nsmul_eq_zero]\ntheorem pow_exponent_eq_one (g : G) : g ^ exponent G = 1 := by\n  classical\n  by_cases h : ExponentExists G\n  · simp_rw [exponent, dif_pos h]\n    exact (Nat.find_spec h).2 g\n  · simp_rw [exponent, dif_neg h, pow_zero]\n\n"}
{"name":"Monoid.pow_eq_mod_exponent","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Monoid G\nn : Nat\ng : G\n⊢ Eq (HPow.hPow g n) (HPow.hPow g (HMod.hMod n (Monoid.exponent G)))","decl":"@[to_additive]\ntheorem pow_eq_mod_exponent {n : ℕ} (g : G) : g ^ n = g ^ (n % exponent G) :=\n  calc\n    g ^ n = g ^ (n % exponent G + exponent G * (n / exponent G)) := by rw [Nat.mod_add_div]\n    _ = g ^ (n % exponent G) := by simp [pow_add, pow_mul, pow_exponent_eq_one]\n\n"}
{"name":"AddMonoid.nsmul_eq_mod_exponent","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddMonoid G\nn : Nat\ng : G\n⊢ Eq (HSMul.hSMul n g) (HSMul.hSMul (HMod.hMod n (AddMonoid.exponent G)) g)","decl":"@[to_additive]\ntheorem pow_eq_mod_exponent {n : ℕ} (g : G) : g ^ n = g ^ (n % exponent G) :=\n  calc\n    g ^ n = g ^ (n % exponent G + exponent G * (n / exponent G)) := by rw [Nat.mod_add_div]\n    _ = g ^ (n % exponent G) := by simp [pow_add, pow_mul, pow_exponent_eq_one]\n\n"}
{"name":"AddMonoid.exponent_pos_of_exists","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddMonoid G\nn : Nat\nhpos : LT.lt 0 n\nhG : ∀ (g : G), Eq (HSMul.hSMul n g) 0\n⊢ LT.lt 0 (AddMonoid.exponent G)","decl":"@[to_additive]\ntheorem exponent_pos_of_exists (n : ℕ) (hpos : 0 < n) (hG : ∀ g : G, g ^ n = 1) :\n    0 < exponent G :=\n  ExponentExists.exponent_pos ⟨n, hpos, hG⟩\n\n"}
{"name":"Monoid.exponent_pos_of_exists","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Monoid G\nn : Nat\nhpos : LT.lt 0 n\nhG : ∀ (g : G), Eq (HPow.hPow g n) 1\n⊢ LT.lt 0 (Monoid.exponent G)","decl":"@[to_additive]\ntheorem exponent_pos_of_exists (n : ℕ) (hpos : 0 < n) (hG : ∀ g : G, g ^ n = 1) :\n    0 < exponent G :=\n  ExponentExists.exponent_pos ⟨n, hpos, hG⟩\n\n"}
{"name":"Monoid.exponent_min'","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Monoid G\nn : Nat\nhpos : LT.lt 0 n\nhG : ∀ (g : G), Eq (HPow.hPow g n) 1\n⊢ LE.le (Monoid.exponent G) n","decl":"@[to_additive]\ntheorem exponent_min' (n : ℕ) (hpos : 0 < n) (hG : ∀ g : G, g ^ n = 1) : exponent G ≤ n := by\n  classical\n  rw [exponent, dif_pos]\n  · apply Nat.find_min'\n    exact ⟨hpos, hG⟩\n  · exact ⟨n, hpos, hG⟩\n\n"}
{"name":"AddMonoid.exponent_min'","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddMonoid G\nn : Nat\nhpos : LT.lt 0 n\nhG : ∀ (g : G), Eq (HSMul.hSMul n g) 0\n⊢ LE.le (AddMonoid.exponent G) n","decl":"@[to_additive]\ntheorem exponent_min' (n : ℕ) (hpos : 0 < n) (hG : ∀ g : G, g ^ n = 1) : exponent G ≤ n := by\n  classical\n  rw [exponent, dif_pos]\n  · apply Nat.find_min'\n    exact ⟨hpos, hG⟩\n  · exact ⟨n, hpos, hG⟩\n\n"}
{"name":"Monoid.exponent_min","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Monoid G\nm : Nat\nhpos : LT.lt 0 m\nhm : LT.lt m (Monoid.exponent G)\n⊢ Exists fun g => Ne (HPow.hPow g m) 1","decl":"@[to_additive]\ntheorem exponent_min (m : ℕ) (hpos : 0 < m) (hm : m < exponent G) : ∃ g : G, g ^ m ≠ 1 := by\n  by_contra! h\n  have hcon : exponent G ≤ m := exponent_min' m hpos h\n  omega\n\n"}
{"name":"AddMonoid.exponent_min","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddMonoid G\nm : Nat\nhpos : LT.lt 0 m\nhm : LT.lt m (AddMonoid.exponent G)\n⊢ Exists fun g => Ne (HSMul.hSMul m g) 0","decl":"@[to_additive]\ntheorem exponent_min (m : ℕ) (hpos : 0 < m) (hm : m < exponent G) : ∃ g : G, g ^ m ≠ 1 := by\n  by_contra! h\n  have hcon : exponent G ≤ m := exponent_min' m hpos h\n  omega\n\n"}
{"name":"Monoid.exp_eq_one_iff","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Monoid G\n⊢ Iff (Eq (Monoid.exponent G) 1) (Subsingleton G)","decl":"@[to_additive AddMonoid.exp_eq_one_iff]\ntheorem exp_eq_one_iff : exponent G = 1 ↔ Subsingleton G := by\n  refine ⟨fun eq_one => ⟨fun a b => ?a_eq_b⟩, fun h => le_antisymm ?le ?ge⟩\n  · rw [← pow_one a, ← pow_one b, ← eq_one, Monoid.pow_exponent_eq_one, Monoid.pow_exponent_eq_one]\n  · apply exponent_min' _ Nat.one_pos\n    simp [eq_iff_true_of_subsingleton]\n  · apply Nat.succ_le_of_lt\n    apply exponent_pos_of_exists 1 Nat.one_pos\n    simp [eq_iff_true_of_subsingleton]\n\n"}
{"name":"AddMonoid.exp_eq_one_iff","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddMonoid G\n⊢ Iff (Eq (AddMonoid.exponent G) 1) (Subsingleton G)","decl":"@[to_additive AddMonoid.exp_eq_one_iff]\ntheorem exp_eq_one_iff : exponent G = 1 ↔ Subsingleton G := by\n  refine ⟨fun eq_one => ⟨fun a b => ?a_eq_b⟩, fun h => le_antisymm ?le ?ge⟩\n  · rw [← pow_one a, ← pow_one b, ← eq_one, Monoid.pow_exponent_eq_one, Monoid.pow_exponent_eq_one]\n  · apply exponent_min' _ Nat.one_pos\n    simp [eq_iff_true_of_subsingleton]\n  · apply Nat.succ_le_of_lt\n    apply exponent_pos_of_exists 1 Nat.one_pos\n    simp [eq_iff_true_of_subsingleton]\n\n"}
{"name":"Monoid.exp_eq_one_of_subsingleton","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Monoid G\nhs : Subsingleton G\n⊢ Eq (Monoid.exponent G) 1","decl":"@[to_additive (attr := simp) AddMonoid.exp_eq_one_of_subsingleton]\ntheorem exp_eq_one_of_subsingleton [hs : Subsingleton G] : exponent G = 1 :=\n  exp_eq_one_iff.mpr hs\n\n"}
{"name":"AddMonoid.exp_eq_one_of_subsingleton","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddMonoid G\nhs : Subsingleton G\n⊢ Eq (AddMonoid.exponent G) 1","decl":"@[to_additive (attr := simp) AddMonoid.exp_eq_one_of_subsingleton]\ntheorem exp_eq_one_of_subsingleton [hs : Subsingleton G] : exponent G = 1 :=\n  exp_eq_one_iff.mpr hs\n\n"}
{"name":"AddMonoid.addOrder_dvd_exponent","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddMonoid G\ng : G\n⊢ Dvd.dvd (addOrderOf g) (AddMonoid.exponent G)","decl":"@[to_additive addOrder_dvd_exponent]\ntheorem order_dvd_exponent (g : G) : orderOf g ∣ exponent G :=\n  orderOf_dvd_of_pow_eq_one <| pow_exponent_eq_one g\n\n"}
{"name":"Monoid.order_dvd_exponent","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Monoid G\ng : G\n⊢ Dvd.dvd (orderOf g) (Monoid.exponent G)","decl":"@[to_additive addOrder_dvd_exponent]\ntheorem order_dvd_exponent (g : G) : orderOf g ∣ exponent G :=\n  orderOf_dvd_of_pow_eq_one <| pow_exponent_eq_one g\n\n"}
{"name":"AddMonoid.addOrderOf_le_exponent","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddMonoid G\nh : AddMonoid.ExponentExists G\ng : G\n⊢ LE.le (addOrderOf g) (AddMonoid.exponent G)","decl":"@[to_additive]\ntheorem orderOf_le_exponent (h : ExponentExists G) (g : G) : orderOf g ≤ exponent G :=\n  Nat.le_of_dvd h.exponent_pos (order_dvd_exponent g)\n\n"}
{"name":"Monoid.orderOf_le_exponent","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Monoid G\nh : Monoid.ExponentExists G\ng : G\n⊢ LE.le (orderOf g) (Monoid.exponent G)","decl":"@[to_additive]\ntheorem orderOf_le_exponent (h : ExponentExists G) (g : G) : orderOf g ≤ exponent G :=\n  Nat.le_of_dvd h.exponent_pos (order_dvd_exponent g)\n\n"}
{"name":"Monoid.exponent_dvd_iff_forall_pow_eq_one","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Monoid G\nn : Nat\n⊢ Iff (Dvd.dvd (Monoid.exponent G) n) (∀ (g : G), Eq (HPow.hPow g n) 1)","decl":"@[to_additive]\ntheorem exponent_dvd_iff_forall_pow_eq_one {n : ℕ} : exponent G ∣ n ↔ ∀ g : G, g ^ n = 1 := by\n  rcases n.eq_zero_or_pos with (rfl | hpos)\n  · simp\n  constructor\n  · intro h g\n    rw [Nat.dvd_iff_mod_eq_zero] at h\n    rw [pow_eq_mod_exponent, h, pow_zero]\n  · intro hG\n    by_contra h\n    rw [Nat.dvd_iff_mod_eq_zero, ← Ne, ← pos_iff_ne_zero] at h\n    have h₂ : n % exponent G < exponent G := Nat.mod_lt _ (exponent_pos_of_exists n hpos hG)\n    have h₃ : exponent G ≤ n % exponent G := by\n      apply exponent_min' _ h\n      simp_rw [← pow_eq_mod_exponent]\n      exact hG\n    exact h₂.not_le h₃\n\n"}
{"name":"AddMonoid.exponent_dvd_iff_forall_nsmul_eq_zero","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddMonoid G\nn : Nat\n⊢ Iff (Dvd.dvd (AddMonoid.exponent G) n) (∀ (g : G), Eq (HSMul.hSMul n g) 0)","decl":"@[to_additive]\ntheorem exponent_dvd_iff_forall_pow_eq_one {n : ℕ} : exponent G ∣ n ↔ ∀ g : G, g ^ n = 1 := by\n  rcases n.eq_zero_or_pos with (rfl | hpos)\n  · simp\n  constructor\n  · intro h g\n    rw [Nat.dvd_iff_mod_eq_zero] at h\n    rw [pow_eq_mod_exponent, h, pow_zero]\n  · intro hG\n    by_contra h\n    rw [Nat.dvd_iff_mod_eq_zero, ← Ne, ← pos_iff_ne_zero] at h\n    have h₂ : n % exponent G < exponent G := Nat.mod_lt _ (exponent_pos_of_exists n hpos hG)\n    have h₃ : exponent G ≤ n % exponent G := by\n      apply exponent_min' _ h\n      simp_rw [← pow_eq_mod_exponent]\n      exact hG\n    exact h₂.not_le h₃\n\n"}
{"name":"AddMonoid.exponent_dvd_of_forall_nsmul_eq_zero","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddMonoid G\nn : Nat\na✝ : ∀ (g : G), Eq (HSMul.hSMul n g) 0\n⊢ Dvd.dvd (AddMonoid.exponent G) n","decl":"@[to_additive]\nalias ⟨_, exponent_dvd_of_forall_pow_eq_one⟩ := exponent_dvd_iff_forall_pow_eq_one\n\n"}
{"name":"Monoid.exponent_dvd_of_forall_pow_eq_one","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Monoid G\nn : Nat\na✝ : ∀ (g : G), Eq (HPow.hPow g n) 1\n⊢ Dvd.dvd (Monoid.exponent G) n","decl":"@[to_additive]\nalias ⟨_, exponent_dvd_of_forall_pow_eq_one⟩ := exponent_dvd_iff_forall_pow_eq_one\n\n"}
{"name":"AddMonoid.exponent_dvd","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddMonoid G\nn : Nat\n⊢ Iff (Dvd.dvd (AddMonoid.exponent G) n) (∀ (g : G), Dvd.dvd (addOrderOf g) n)","decl":"@[to_additive]\ntheorem exponent_dvd {n : ℕ} : exponent G ∣ n ↔ ∀ g : G, orderOf g ∣ n := by\n  simp_rw [exponent_dvd_iff_forall_pow_eq_one, orderOf_dvd_iff_pow_eq_one]\n\n"}
{"name":"Monoid.exponent_dvd","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Monoid G\nn : Nat\n⊢ Iff (Dvd.dvd (Monoid.exponent G) n) (∀ (g : G), Dvd.dvd (orderOf g) n)","decl":"@[to_additive]\ntheorem exponent_dvd {n : ℕ} : exponent G ∣ n ↔ ∀ g : G, orderOf g ∣ n := by\n  simp_rw [exponent_dvd_iff_forall_pow_eq_one, orderOf_dvd_iff_pow_eq_one]\n\n"}
{"name":"Monoid.lcm_orderOf_dvd_exponent","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝¹ : Monoid G\ninst✝ : Fintype G\n⊢ Dvd.dvd (Finset.univ.lcm orderOf) (Monoid.exponent G)","decl":"@[to_additive]\ntheorem lcm_orderOf_dvd_exponent [Fintype G] :\n    (Finset.univ : Finset G).lcm orderOf ∣ exponent G := by\n  apply Finset.lcm_dvd\n  intro g _\n  exact order_dvd_exponent g\n\n"}
{"name":"AddMonoid.lcm_addOrderOf_dvd_exponent","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝¹ : AddMonoid G\ninst✝ : Fintype G\n⊢ Dvd.dvd (Finset.univ.lcm addOrderOf) (AddMonoid.exponent G)","decl":"@[to_additive]\ntheorem lcm_orderOf_dvd_exponent [Fintype G] :\n    (Finset.univ : Finset G).lcm orderOf ∣ exponent G := by\n  apply Finset.lcm_dvd\n  intro g _\n  exact order_dvd_exponent g\n\n"}
{"name":"Nat.Prime.exists_orderOf_eq_pow_factorization_exponent","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Monoid G\np : Nat\nhp : Nat.Prime p\n⊢ Exists fun g => Eq (orderOf g) (HPow.hPow p ((Monoid.exponent G).factorization p))","decl":"@[to_additive exists_addOrderOf_eq_pow_padic_val_nat_add_exponent]\ntheorem _root_.Nat.Prime.exists_orderOf_eq_pow_factorization_exponent {p : ℕ} (hp : p.Prime) :\n    ∃ g : G, orderOf g = p ^ (exponent G).factorization p := by\n  haveI := Fact.mk hp\n  rcases eq_or_ne ((exponent G).factorization p) 0 with (h | h)\n  · refine ⟨1, by rw [h, pow_zero, orderOf_one]⟩\n  have he : 0 < exponent G :=\n    Ne.bot_lt fun ht => by\n      rw [ht] at h\n      apply h\n      rw [bot_eq_zero, Nat.factorization_zero, Finsupp.zero_apply]\n  rw [← Finsupp.mem_support_iff] at h\n  obtain ⟨g, hg⟩ : ∃ g : G, g ^ (exponent G / p) ≠ 1 := by\n    suffices key : ¬exponent G ∣ exponent G / p by\n      rwa [exponent_dvd_iff_forall_pow_eq_one, not_forall] at key\n    exact fun hd =>\n      hp.one_lt.not_le\n        ((mul_le_iff_le_one_left he).mp <|\n          Nat.le_of_dvd he <| Nat.mul_dvd_of_dvd_div (Nat.dvd_of_mem_primeFactors h) hd)\n  obtain ⟨k, hk : exponent G = p ^ _ * k⟩ := Nat.ordProj_dvd _ _\n  obtain ⟨t, ht⟩ := Nat.exists_eq_succ_of_ne_zero (Finsupp.mem_support_iff.mp h)\n  refine ⟨g ^ k, ?_⟩\n  rw [ht]\n  apply orderOf_eq_prime_pow\n  · rwa [hk, mul_comm, ht, pow_succ, ← mul_assoc, Nat.mul_div_cancel _ hp.pos, pow_mul] at hg\n  · rw [← Nat.succ_eq_add_one, ← ht, ← pow_mul, mul_comm, ← hk]\n    exact pow_exponent_eq_one g\n\n"}
{"name":"Nat.Prime.exists_addOrderOf_eq_pow_padic_val_nat_add_exponent","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddMonoid G\np : Nat\nhp : Nat.Prime p\n⊢ Exists fun g => Eq (addOrderOf g) (HPow.hPow p ((AddMonoid.exponent G).factorization p))","decl":"@[to_additive exists_addOrderOf_eq_pow_padic_val_nat_add_exponent]\ntheorem _root_.Nat.Prime.exists_orderOf_eq_pow_factorization_exponent {p : ℕ} (hp : p.Prime) :\n    ∃ g : G, orderOf g = p ^ (exponent G).factorization p := by\n  haveI := Fact.mk hp\n  rcases eq_or_ne ((exponent G).factorization p) 0 with (h | h)\n  · refine ⟨1, by rw [h, pow_zero, orderOf_one]⟩\n  have he : 0 < exponent G :=\n    Ne.bot_lt fun ht => by\n      rw [ht] at h\n      apply h\n      rw [bot_eq_zero, Nat.factorization_zero, Finsupp.zero_apply]\n  rw [← Finsupp.mem_support_iff] at h\n  obtain ⟨g, hg⟩ : ∃ g : G, g ^ (exponent G / p) ≠ 1 := by\n    suffices key : ¬exponent G ∣ exponent G / p by\n      rwa [exponent_dvd_iff_forall_pow_eq_one, not_forall] at key\n    exact fun hd =>\n      hp.one_lt.not_le\n        ((mul_le_iff_le_one_left he).mp <|\n          Nat.le_of_dvd he <| Nat.mul_dvd_of_dvd_div (Nat.dvd_of_mem_primeFactors h) hd)\n  obtain ⟨k, hk : exponent G = p ^ _ * k⟩ := Nat.ordProj_dvd _ _\n  obtain ⟨t, ht⟩ := Nat.exists_eq_succ_of_ne_zero (Finsupp.mem_support_iff.mp h)\n  refine ⟨g ^ k, ?_⟩\n  rw [ht]\n  apply orderOf_eq_prime_pow\n  · rwa [hk, mul_comm, ht, pow_succ, ← mul_assoc, Nat.mul_div_cancel _ hp.pos, pow_mul] at hg\n  · rw [← Nat.succ_eq_add_one, ← ht, ← pow_mul, mul_comm, ← hk]\n    exact pow_exponent_eq_one g\n\n"}
{"name":"Commute.orderOf_mul_pow_eq_lcm","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Monoid G\nx y : G\nh : Commute x y\nhx : Ne (orderOf x) 0\nhy : Ne (orderOf y) 0\n⊢ Eq (orderOf (HMul.hMul (HPow.hPow x (HDiv.hDiv (orderOf x) ((orderOf x).factorizationLCMLeft (orderOf y)))) (HPow.hPow y (HDiv.hDiv (orderOf y) ((orderOf x).factorizationLCMRight (orderOf y)))))) ((orderOf x).lcm (orderOf y))","decl":"variable {G} in\nopen Nat in\n/-- If two commuting elements `x` and `y` of a monoid have order `n` and `m`, there is an element\nof order `lcm n m`. The result actually gives an explicit (computable) element, written as the\nproduct of a power of `x` and a power of `y`. See also the result below if you don't need the\nexplicit formula. -/\n@[to_additive \"If two commuting elements `x` and `y` of an additive monoid have order `n` and `m`,\nthere is an element of order `lcm n m`. The result actually gives an explicit (computable) element,\nwritten as the sum of a multiple of `x` and a multiple of `y`. See also the result below if you\ndon't need the explicit formula.\"]\nlemma _root_.Commute.orderOf_mul_pow_eq_lcm {x y : G} (h : Commute x y) (hx : orderOf x ≠ 0)\n    (hy : orderOf y ≠ 0) :\n    orderOf (x ^ (orderOf x / (factorizationLCMLeft (orderOf x) (orderOf y))) *\n      y ^ (orderOf y / factorizationLCMRight (orderOf x) (orderOf y))) =\n      Nat.lcm (orderOf x) (orderOf y) := by\n  rw [(h.pow_pow _ _).orderOf_mul_eq_mul_orderOf_of_coprime]\n  all_goals iterate 2 rw [orderOf_pow_orderOf_div]; try rw [Coprime]\n  all_goals simp [factorizationLCMLeft_mul_factorizationLCMRight, factorizationLCMLeft_dvd_left,\n    factorizationLCMRight_dvd_right, coprime_factorizationLCMLeft_factorizationLCMRight, hx, hy]\n\n"}
{"name":"AddCommute.addOrderOf_add_nsmul_eq_lcm","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddMonoid G\nx y : G\nh : AddCommute x y\nhx : Ne (addOrderOf x) 0\nhy : Ne (addOrderOf y) 0\n⊢ Eq (addOrderOf (HAdd.hAdd (HSMul.hSMul (HDiv.hDiv (addOrderOf x) ((addOrderOf x).factorizationLCMLeft (addOrderOf y))) x) (HSMul.hSMul (HDiv.hDiv (addOrderOf y) ((addOrderOf x).factorizationLCMRight (addOrderOf y))) y))) ((addOrderOf x).lcm (addOrderOf y))","decl":"variable {G} in\nopen Nat in\n/-- If two commuting elements `x` and `y` of a monoid have order `n` and `m`, there is an element\nof order `lcm n m`. The result actually gives an explicit (computable) element, written as the\nproduct of a power of `x` and a power of `y`. See also the result below if you don't need the\nexplicit formula. -/\n@[to_additive \"If two commuting elements `x` and `y` of an additive monoid have order `n` and `m`,\nthere is an element of order `lcm n m`. The result actually gives an explicit (computable) element,\nwritten as the sum of a multiple of `x` and a multiple of `y`. See also the result below if you\ndon't need the explicit formula.\"]\nlemma _root_.Commute.orderOf_mul_pow_eq_lcm {x y : G} (h : Commute x y) (hx : orderOf x ≠ 0)\n    (hy : orderOf y ≠ 0) :\n    orderOf (x ^ (orderOf x / (factorizationLCMLeft (orderOf x) (orderOf y))) *\n      y ^ (orderOf y / factorizationLCMRight (orderOf x) (orderOf y))) =\n      Nat.lcm (orderOf x) (orderOf y) := by\n  rw [(h.pow_pow _ _).orderOf_mul_eq_mul_orderOf_of_coprime]\n  all_goals iterate 2 rw [orderOf_pow_orderOf_div]; try rw [Coprime]\n  all_goals simp [factorizationLCMLeft_mul_factorizationLCMRight, factorizationLCMLeft_dvd_left,\n    factorizationLCMRight_dvd_right, coprime_factorizationLCMLeft_factorizationLCMRight, hx, hy]\n\n"}
{"name":"AddCommute.exists_addOrderOf_eq_lcm","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddMonoid G\nx y : G\nh : AddCommute x y\n⊢ Exists fun z => And (Membership.mem (AddSubmonoid.closure (Insert.insert x (Singleton.singleton y))) z) (Eq (addOrderOf z) ((addOrderOf x).lcm (addOrderOf y)))","decl":"open Submonoid in\n/-- If two commuting elements `x` and `y` of a monoid have order `n` and `m`, then there is an\nelement of order `lcm n m` that lies in the subgroup generated by `x` and `y`. -/\n@[to_additive \"If two commuting elements `x` and `y` of an additive monoid have order `n` and `m`,\nthen there is an element of order `lcm n m` that lies in the additive subgroup generated by `x`\nand `y`.\"]\ntheorem _root_.Commute.exists_orderOf_eq_lcm {x y : G} (h : Commute x y) :\n    ∃ z ∈ closure {x, y}, orderOf z = Nat.lcm (orderOf x) (orderOf y) := by\n  by_cases hx : orderOf x = 0 <;> by_cases hy : orderOf y = 0\n  · exact ⟨x, subset_closure (by simp), by simp [hx]⟩\n  · exact ⟨x, subset_closure (by simp), by simp [hx]⟩\n  · exact ⟨y, subset_closure (by simp), by simp [hy]⟩\n  · exact ⟨_, mul_mem (pow_mem (subset_closure (by simp)) _) (pow_mem (subset_closure (by simp)) _),\n      h.orderOf_mul_pow_eq_lcm hx hy⟩\n\n"}
{"name":"Commute.exists_orderOf_eq_lcm","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Monoid G\nx y : G\nh : Commute x y\n⊢ Exists fun z => And (Membership.mem (Submonoid.closure (Insert.insert x (Singleton.singleton y))) z) (Eq (orderOf z) ((orderOf x).lcm (orderOf y)))","decl":"open Submonoid in\n/-- If two commuting elements `x` and `y` of a monoid have order `n` and `m`, then there is an\nelement of order `lcm n m` that lies in the subgroup generated by `x` and `y`. -/\n@[to_additive \"If two commuting elements `x` and `y` of an additive monoid have order `n` and `m`,\nthen there is an element of order `lcm n m` that lies in the additive subgroup generated by `x`\nand `y`.\"]\ntheorem _root_.Commute.exists_orderOf_eq_lcm {x y : G} (h : Commute x y) :\n    ∃ z ∈ closure {x, y}, orderOf z = Nat.lcm (orderOf x) (orderOf y) := by\n  by_cases hx : orderOf x = 0 <;> by_cases hy : orderOf y = 0\n  · exact ⟨x, subset_closure (by simp), by simp [hx]⟩\n  · exact ⟨x, subset_closure (by simp), by simp [hx]⟩\n  · exact ⟨y, subset_closure (by simp), by simp [hy]⟩\n  · exact ⟨_, mul_mem (pow_mem (subset_closure (by simp)) _) (pow_mem (subset_closure (by simp)) _),\n      h.orderOf_mul_pow_eq_lcm hx hy⟩\n\n"}
{"name":"AddMonoid.exponent_eq_prime_iff","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u_1\ninst✝¹ : AddMonoid G\ninst✝ : Nontrivial G\np : Nat\nhp : Nat.Prime p\n⊢ Iff (Eq (AddMonoid.exponent G) p) (∀ (g : G), Ne g 0 → Eq (addOrderOf g) p)","decl":"/-- A nontrivial monoid has prime exponent `p` if and only if every non-identity element has\norder `p`. -/\n@[to_additive]\nlemma exponent_eq_prime_iff {G : Type*} [Monoid G] [Nontrivial G] {p : ℕ} (hp : p.Prime) :\n    Monoid.exponent G = p ↔ ∀ g : G, g ≠ 1 → orderOf g = p := by\n  refine ⟨fun hG g hg ↦ ?_, fun h ↦ dvd_antisymm ?_ ?_⟩\n  · rw [Ne, ← orderOf_eq_one_iff] at hg\n    exact Eq.symm <| (hp.dvd_iff_eq hg).mp <| hG ▸ Monoid.order_dvd_exponent g\n  · rw [exponent_dvd]\n    intro g\n    by_cases hg : g = 1\n    · simp [hg]\n    · rw [h g hg]\n  · obtain ⟨g, hg⟩ := exists_ne (1 : G)\n    simpa [h g hg] using Monoid.order_dvd_exponent g\n\n"}
{"name":"Monoid.exponent_eq_prime_iff","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u_1\ninst✝¹ : Monoid G\ninst✝ : Nontrivial G\np : Nat\nhp : Nat.Prime p\n⊢ Iff (Eq (Monoid.exponent G) p) (∀ (g : G), Ne g 1 → Eq (orderOf g) p)","decl":"/-- A nontrivial monoid has prime exponent `p` if and only if every non-identity element has\norder `p`. -/\n@[to_additive]\nlemma exponent_eq_prime_iff {G : Type*} [Monoid G] [Nontrivial G] {p : ℕ} (hp : p.Prime) :\n    Monoid.exponent G = p ↔ ∀ g : G, g ≠ 1 → orderOf g = p := by\n  refine ⟨fun hG g hg ↦ ?_, fun h ↦ dvd_antisymm ?_ ?_⟩\n  · rw [Ne, ← orderOf_eq_one_iff] at hg\n    exact Eq.symm <| (hp.dvd_iff_eq hg).mp <| hG ▸ Monoid.order_dvd_exponent g\n  · rw [exponent_dvd]\n    intro g\n    by_cases hg : g = 1\n    · simp [hg]\n    · rw [h g hg]\n  · obtain ⟨g, hg⟩ := exists_ne (1 : G)\n    simpa [h g hg] using Monoid.order_dvd_exponent g\n\n"}
{"name":"AddMonoid.exponent_ne_zero_iff_range_addOrderOf_finite","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddMonoid G\nh : ∀ (g : G), LT.lt 0 (addOrderOf g)\n⊢ Iff (Ne (AddMonoid.exponent G) 0) (Set.range addOrderOf).Finite","decl":"@[to_additive]\ntheorem exponent_ne_zero_iff_range_orderOf_finite (h : ∀ g : G, 0 < orderOf g) :\n    exponent G ≠ 0 ↔ (Set.range (orderOf : G → ℕ)).Finite := by\n  refine ⟨fun he => ?_, fun he => ?_⟩\n  · by_contra h\n    obtain ⟨m, ⟨t, rfl⟩, het⟩ := Set.Infinite.exists_gt h (exponent G)\n    exact pow_ne_one_of_lt_orderOf he het (pow_exponent_eq_one t)\n  · lift Set.range (orderOf (G := G)) to Finset ℕ using he with t ht\n    have htpos : 0 < t.prod id := by\n      refine Finset.prod_pos fun a ha => ?_\n      rw [← Finset.mem_coe, ht] at ha\n      obtain ⟨k, rfl⟩ := ha\n      exact h k\n    suffices exponent G ∣ t.prod id by\n      intro h\n      rw [h, zero_dvd_iff] at this\n      exact htpos.ne' this\n    rw [exponent_dvd]\n    intro g\n    apply Finset.dvd_prod_of_mem id (?_ : orderOf g ∈ _)\n    rw [← Finset.mem_coe, ht]\n    exact Set.mem_range_self g\n\n"}
{"name":"Monoid.exponent_ne_zero_iff_range_orderOf_finite","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Monoid G\nh : ∀ (g : G), LT.lt 0 (orderOf g)\n⊢ Iff (Ne (Monoid.exponent G) 0) (Set.range orderOf).Finite","decl":"@[to_additive]\ntheorem exponent_ne_zero_iff_range_orderOf_finite (h : ∀ g : G, 0 < orderOf g) :\n    exponent G ≠ 0 ↔ (Set.range (orderOf : G → ℕ)).Finite := by\n  refine ⟨fun he => ?_, fun he => ?_⟩\n  · by_contra h\n    obtain ⟨m, ⟨t, rfl⟩, het⟩ := Set.Infinite.exists_gt h (exponent G)\n    exact pow_ne_one_of_lt_orderOf he het (pow_exponent_eq_one t)\n  · lift Set.range (orderOf (G := G)) to Finset ℕ using he with t ht\n    have htpos : 0 < t.prod id := by\n      refine Finset.prod_pos fun a ha => ?_\n      rw [← Finset.mem_coe, ht] at ha\n      obtain ⟨k, rfl⟩ := ha\n      exact h k\n    suffices exponent G ∣ t.prod id by\n      intro h\n      rw [h, zero_dvd_iff] at this\n      exact htpos.ne' this\n    rw [exponent_dvd]\n    intro g\n    apply Finset.dvd_prod_of_mem id (?_ : orderOf g ∈ _)\n    rw [← Finset.mem_coe, ht]\n    exact Set.mem_range_self g\n\n"}
{"name":"Monoid.exponent_eq_zero_iff_range_orderOf_infinite","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Monoid G\nh : ∀ (g : G), LT.lt 0 (orderOf g)\n⊢ Iff (Eq (Monoid.exponent G) 0) (Set.range orderOf).Infinite","decl":"@[to_additive]\ntheorem exponent_eq_zero_iff_range_orderOf_infinite (h : ∀ g : G, 0 < orderOf g) :\n    exponent G = 0 ↔ (Set.range (orderOf : G → ℕ)).Infinite := by\n  have := exponent_ne_zero_iff_range_orderOf_finite h\n  rwa [Ne, not_iff_comm, Iff.comm] at this\n\n"}
{"name":"AddMonoid.exponent_eq_zero_iff_range_addOrderOf_infinite","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddMonoid G\nh : ∀ (g : G), LT.lt 0 (addOrderOf g)\n⊢ Iff (Eq (AddMonoid.exponent G) 0) (Set.range addOrderOf).Infinite","decl":"@[to_additive]\ntheorem exponent_eq_zero_iff_range_orderOf_infinite (h : ∀ g : G, 0 < orderOf g) :\n    exponent G = 0 ↔ (Set.range (orderOf : G → ℕ)).Infinite := by\n  have := exponent_ne_zero_iff_range_orderOf_finite h\n  rwa [Ne, not_iff_comm, Iff.comm] at this\n\n"}
{"name":"AddMonoid.lcm_addOrderOf_eq_exponent","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝¹ : AddMonoid G\ninst✝ : Fintype G\n⊢ Eq (Finset.univ.lcm addOrderOf) (AddMonoid.exponent G)","decl":"@[to_additive]\ntheorem lcm_orderOf_eq_exponent [Fintype G] : (Finset.univ : Finset G).lcm orderOf = exponent G :=\n  Nat.dvd_antisymm\n    (lcm_orderOf_dvd_exponent G)\n    (exponent_dvd.mpr fun g => Finset.dvd_lcm (Finset.mem_univ g))\n\n"}
{"name":"Monoid.lcm_orderOf_eq_exponent","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝¹ : Monoid G\ninst✝ : Fintype G\n⊢ Eq (Finset.univ.lcm orderOf) (Monoid.exponent G)","decl":"@[to_additive]\ntheorem lcm_orderOf_eq_exponent [Fintype G] : (Finset.univ : Finset G).lcm orderOf = exponent G :=\n  Nat.dvd_antisymm\n    (lcm_orderOf_dvd_exponent G)\n    (exponent_dvd.mpr fun g => Finset.dvd_lcm (Finset.mem_univ g))\n\n"}
{"name":"AddMonoid.exponent_dvd_of_addMonoidHom","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝¹ : AddMonoid G\nH : Type u_1\ninst✝ : AddMonoid H\ne : AddMonoidHom G H\ne_inj : Function.Injective ⇑e\n⊢ Dvd.dvd (AddMonoid.exponent G) (AddMonoid.exponent H)","decl":"/--\nIf there exists an injective, multiplication-preserving map from `G` to `H`,\nthen the exponent of `G` divides the exponent of `H`.\n-/\n@[to_additive \"If there exists an injective, addition-preserving map from `G` to `H`,\nthen the exponent of `G` divides the exponent of `H`.\"]\ntheorem exponent_dvd_of_monoidHom (e : G →* H) (e_inj : Function.Injective e) :\n    Monoid.exponent G ∣ Monoid.exponent H :=\n  exponent_dvd_of_forall_pow_eq_one fun g => e_inj (by\n    rw [map_pow, pow_exponent_eq_one, map_one])\n\n"}
{"name":"Monoid.exponent_dvd_of_monoidHom","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝¹ : Monoid G\nH : Type u_1\ninst✝ : Monoid H\ne : MonoidHom G H\ne_inj : Function.Injective ⇑e\n⊢ Dvd.dvd (Monoid.exponent G) (Monoid.exponent H)","decl":"/--\nIf there exists an injective, multiplication-preserving map from `G` to `H`,\nthen the exponent of `G` divides the exponent of `H`.\n-/\n@[to_additive \"If there exists an injective, addition-preserving map from `G` to `H`,\nthen the exponent of `G` divides the exponent of `H`.\"]\ntheorem exponent_dvd_of_monoidHom (e : G →* H) (e_inj : Function.Injective e) :\n    Monoid.exponent G ∣ Monoid.exponent H :=\n  exponent_dvd_of_forall_pow_eq_one fun g => e_inj (by\n    rw [map_pow, pow_exponent_eq_one, map_one])\n\n"}
{"name":"Monoid.exponent_eq_of_mulEquiv","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝¹ : Monoid G\nH : Type u_1\ninst✝ : Monoid H\ne : MulEquiv G H\n⊢ Eq (Monoid.exponent G) (Monoid.exponent H)","decl":"/--\nIf there exists a multiplication-preserving equivalence between `G` and `H`,\nthen the exponent of `G` is equal to the exponent of `H`.\n-/\n@[to_additive \"If there exists a addition-preserving equivalence between `G` and `H`,\nthen the exponent of `G` is equal to the exponent of `H`.\"]\ntheorem exponent_eq_of_mulEquiv (e : G ≃* H) : Monoid.exponent G = Monoid.exponent H :=\n  Nat.dvd_antisymm\n    (exponent_dvd_of_monoidHom e e.injective)\n    (exponent_dvd_of_monoidHom e.symm e.symm.injective)\n\n"}
{"name":"AddMonoid.exponent_eq_of_addEquiv","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝¹ : AddMonoid G\nH : Type u_1\ninst✝ : AddMonoid H\ne : AddEquiv G H\n⊢ Eq (AddMonoid.exponent G) (AddMonoid.exponent H)","decl":"/--\nIf there exists a multiplication-preserving equivalence between `G` and `H`,\nthen the exponent of `G` is equal to the exponent of `H`.\n-/\n@[to_additive \"If there exists a addition-preserving equivalence between `G` and `H`,\nthen the exponent of `G` is equal to the exponent of `H`.\"]\ntheorem exponent_eq_of_mulEquiv (e : G ≃* H) : Monoid.exponent G = Monoid.exponent H :=\n  Nat.dvd_antisymm\n    (exponent_dvd_of_monoidHom e e.injective)\n    (exponent_dvd_of_monoidHom e.symm e.symm.injective)\n\n"}
{"name":"AddSubmonoid.exponent_top","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddMonoid G\n⊢ Eq (AddMonoid.exponent (Subtype fun x => Membership.mem Top.top x)) (AddMonoid.exponent G)","decl":"variable (G) in\n@[to_additive (attr := simp)]\ntheorem _root_.Submonoid.exponent_top :\n    Monoid.exponent (⊤ : Submonoid G) = Monoid.exponent G :=\n  exponent_eq_of_mulEquiv Submonoid.topEquiv\n\n"}
{"name":"Submonoid.exponent_top","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Monoid G\n⊢ Eq (Monoid.exponent (Subtype fun x => Membership.mem Top.top x)) (Monoid.exponent G)","decl":"variable (G) in\n@[to_additive (attr := simp)]\ntheorem _root_.Submonoid.exponent_top :\n    Monoid.exponent (⊤ : Submonoid G) = Monoid.exponent G :=\n  exponent_eq_of_mulEquiv Submonoid.topEquiv\n\n"}
{"name":"Submonoid.pow_exponent_eq_one","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Monoid G\nS : Submonoid G\ng : G\ng_in_s : Membership.mem S g\n⊢ Eq (HPow.hPow g (Monoid.exponent (Subtype fun x => Membership.mem S x))) 1","decl":"@[to_additive]\ntheorem _root_.Submonoid.pow_exponent_eq_one {S : Submonoid G} {g : G} (g_in_s : g ∈ S) :\n    g ^ (Monoid.exponent S) = 1 := by\n  have := Monoid.pow_exponent_eq_one (⟨g, g_in_s⟩ : S)\n  rwa [SubmonoidClass.mk_pow, ← OneMemClass.coe_eq_one] at this\n\n"}
{"name":"AddSubmonoid.nsmul_exponent_eq_zero","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddMonoid G\nS : AddSubmonoid G\ng : G\ng_in_s : Membership.mem S g\n⊢ Eq (HSMul.hSMul (AddMonoid.exponent (Subtype fun x => Membership.mem S x)) g) 0","decl":"@[to_additive]\ntheorem _root_.Submonoid.pow_exponent_eq_one {S : Submonoid G} {g : G} (g_in_s : g ∈ S) :\n    g ^ (Monoid.exponent S) = 1 := by\n  have := Monoid.pow_exponent_eq_one (⟨g, g_in_s⟩ : S)\n  rwa [SubmonoidClass.mk_pow, ← OneMemClass.coe_eq_one] at this\n\n"}
{"name":"AddMonoid.ExponentExists.of_finite","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝¹ : AddLeftCancelMonoid G\ninst✝ : Finite G\n⊢ AddMonoid.ExponentExists G","decl":"@[to_additive]\ntheorem ExponentExists.of_finite : ExponentExists G := by\n  let _inst := Fintype.ofFinite G\n  simp only [Monoid.ExponentExists]\n  refine ⟨(Finset.univ : Finset G).lcm orderOf, ?_, fun g => ?_⟩\n  · simpa [pos_iff_ne_zero, Finset.lcm_eq_zero_iff] using fun x => (_root_.orderOf_pos x).ne'\n  · rw [← orderOf_dvd_iff_pow_eq_one, lcm_orderOf_eq_exponent]\n    exact order_dvd_exponent g\n\n"}
{"name":"Monoid.ExponentExists.of_finite","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝¹ : LeftCancelMonoid G\ninst✝ : Finite G\n⊢ Monoid.ExponentExists G","decl":"@[to_additive]\ntheorem ExponentExists.of_finite : ExponentExists G := by\n  let _inst := Fintype.ofFinite G\n  simp only [Monoid.ExponentExists]\n  refine ⟨(Finset.univ : Finset G).lcm orderOf, ?_, fun g => ?_⟩\n  · simpa [pos_iff_ne_zero, Finset.lcm_eq_zero_iff] using fun x => (_root_.orderOf_pos x).ne'\n  · rw [← orderOf_dvd_iff_pow_eq_one, lcm_orderOf_eq_exponent]\n    exact order_dvd_exponent g\n\n"}
{"name":"AddMonoid.exponent_ne_zero_of_finite","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝¹ : AddLeftCancelMonoid G\ninst✝ : Finite G\n⊢ Ne (AddMonoid.exponent G) 0","decl":"@[to_additive]\ntheorem exponent_ne_zero_of_finite : exponent G ≠ 0 :=\n  ExponentExists.of_finite.exponent_ne_zero\n\n"}
{"name":"Monoid.exponent_ne_zero_of_finite","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝¹ : LeftCancelMonoid G\ninst✝ : Finite G\n⊢ Ne (Monoid.exponent G) 0","decl":"@[to_additive]\ntheorem exponent_ne_zero_of_finite : exponent G ≠ 0 :=\n  ExponentExists.of_finite.exponent_ne_zero\n\n"}
{"name":"AddMonoid.one_lt_exponent","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝² : AddLeftCancelMonoid G\ninst✝¹ : Finite G\ninst✝ : Nontrivial G\n⊢ LT.lt 1 (AddMonoid.exponent G)","decl":"@[to_additive AddMonoid.one_lt_exponent]\nlemma one_lt_exponent [Nontrivial G] : 1 < Monoid.exponent G := by\n  rw [Nat.one_lt_iff_ne_zero_and_ne_one]\n  exact ⟨exponent_ne_zero_of_finite, mt exp_eq_one_iff.mp (not_subsingleton G)⟩\n\n"}
{"name":"Monoid.one_lt_exponent","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝² : LeftCancelMonoid G\ninst✝¹ : Finite G\ninst✝ : Nontrivial G\n⊢ LT.lt 1 (Monoid.exponent G)","decl":"@[to_additive AddMonoid.one_lt_exponent]\nlemma one_lt_exponent [Nontrivial G] : 1 < Monoid.exponent G := by\n  rw [Nat.one_lt_iff_ne_zero_and_ne_one]\n  exact ⟨exponent_ne_zero_of_finite, mt exp_eq_one_iff.mp (not_subsingleton G)⟩\n\n"}
{"name":"Monoid.neZero_exponent_of_finite","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝¹ : LeftCancelMonoid G\ninst✝ : Finite G\n⊢ NeZero (Monoid.exponent G)","decl":"@[to_additive]\ninstance neZero_exponent_of_finite : NeZero <| Monoid.exponent G :=\n  ⟨Monoid.exponent_ne_zero_of_finite⟩\n\n"}
{"name":"AddMonoid.neZero_exponent_of_finite","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝¹ : AddLeftCancelMonoid G\ninst✝ : Finite G\n⊢ NeZero (AddMonoid.exponent G)","decl":"@[to_additive]\ninstance neZero_exponent_of_finite : NeZero <| Monoid.exponent G :=\n  ⟨Monoid.exponent_ne_zero_of_finite⟩\n\n"}
{"name":"Monoid.exists_orderOf_eq_exponent","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : CommMonoid G\nhG : Monoid.ExponentExists G\n⊢ Exists fun g => Eq (orderOf g) (Monoid.exponent G)","decl":"@[to_additive]\ntheorem exists_orderOf_eq_exponent (hG : ExponentExists G) : ∃ g : G, orderOf g = exponent G := by\n  have he := hG.exponent_ne_zero\n  have hne : (Set.range (orderOf : G → ℕ)).Nonempty := ⟨1, 1, orderOf_one⟩\n  have hfin : (Set.range (orderOf : G → ℕ)).Finite := by\n    rwa [← exponent_ne_zero_iff_range_orderOf_finite hG.orderOf_pos]\n  obtain ⟨t, ht⟩ := hne.csSup_mem hfin\n  use t\n  apply Nat.dvd_antisymm (order_dvd_exponent _)\n  refine Nat.dvd_of_primeFactorsList_subperm he ?_\n  rw [List.subperm_ext_iff]\n  by_contra! h\n  obtain ⟨p, hp, hpe⟩ := h\n  replace hp := Nat.prime_of_mem_primeFactorsList hp\n  simp only [Nat.primeFactorsList_count_eq] at hpe\n  set k := (orderOf t).factorization p with hk\n  obtain ⟨g, hg⟩ := hp.exists_orderOf_eq_pow_factorization_exponent G\n  suffices orderOf t < orderOf (t ^ p ^ k * g) by\n    rw [ht] at this\n    exact this.not_le (le_csSup hfin.bddAbove <| Set.mem_range_self _)\n  have hpk : p ^ k ∣ orderOf t := Nat.ordProj_dvd _ _\n  have hpk' : orderOf (t ^ p ^ k) = orderOf t / p ^ k := by\n    rw [orderOf_pow' t (pow_ne_zero k hp.ne_zero), Nat.gcd_eq_right hpk]\n  obtain ⟨a, ha⟩ := Nat.exists_eq_add_of_lt hpe\n  have hcoprime : (orderOf (t ^ p ^ k)).Coprime (orderOf g) := by\n    rw [hg, Nat.coprime_pow_right_iff (pos_of_gt hpe), Nat.coprime_comm]\n    apply Or.resolve_right (Nat.coprime_or_dvd_of_prime hp _)\n    nth_rw 1 [← pow_one p]\n    have : 1 = (Nat.factorization (orderOf (t ^ p ^ k))) p + 1 := by\n     rw [hpk', Nat.factorization_div hpk]\n     simp [k, hp]\n    rw [this]\n    -- Porting note: convert made to_additive complain\n    apply Nat.pow_succ_factorization_not_dvd (hG.orderOf_pos <| t ^ p ^ k).ne' hp\n  rw [(Commute.all _ g).orderOf_mul_eq_mul_orderOf_of_coprime hcoprime, hpk',\n    hg, ha, hk, pow_add, pow_add, pow_one, ← mul_assoc, ← mul_assoc,\n    Nat.div_mul_cancel, mul_assoc, lt_mul_iff_one_lt_right <| hG.orderOf_pos t, ← pow_succ]\n  · exact one_lt_pow₀ hp.one_lt a.succ_ne_zero\n  · exact hpk\n\n"}
{"name":"AddMonoid.exists_addOrderOf_eq_exponent","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddCommMonoid G\nhG : AddMonoid.ExponentExists G\n⊢ Exists fun g => Eq (addOrderOf g) (AddMonoid.exponent G)","decl":"@[to_additive]\ntheorem exists_orderOf_eq_exponent (hG : ExponentExists G) : ∃ g : G, orderOf g = exponent G := by\n  have he := hG.exponent_ne_zero\n  have hne : (Set.range (orderOf : G → ℕ)).Nonempty := ⟨1, 1, orderOf_one⟩\n  have hfin : (Set.range (orderOf : G → ℕ)).Finite := by\n    rwa [← exponent_ne_zero_iff_range_orderOf_finite hG.orderOf_pos]\n  obtain ⟨t, ht⟩ := hne.csSup_mem hfin\n  use t\n  apply Nat.dvd_antisymm (order_dvd_exponent _)\n  refine Nat.dvd_of_primeFactorsList_subperm he ?_\n  rw [List.subperm_ext_iff]\n  by_contra! h\n  obtain ⟨p, hp, hpe⟩ := h\n  replace hp := Nat.prime_of_mem_primeFactorsList hp\n  simp only [Nat.primeFactorsList_count_eq] at hpe\n  set k := (orderOf t).factorization p with hk\n  obtain ⟨g, hg⟩ := hp.exists_orderOf_eq_pow_factorization_exponent G\n  suffices orderOf t < orderOf (t ^ p ^ k * g) by\n    rw [ht] at this\n    exact this.not_le (le_csSup hfin.bddAbove <| Set.mem_range_self _)\n  have hpk : p ^ k ∣ orderOf t := Nat.ordProj_dvd _ _\n  have hpk' : orderOf (t ^ p ^ k) = orderOf t / p ^ k := by\n    rw [orderOf_pow' t (pow_ne_zero k hp.ne_zero), Nat.gcd_eq_right hpk]\n  obtain ⟨a, ha⟩ := Nat.exists_eq_add_of_lt hpe\n  have hcoprime : (orderOf (t ^ p ^ k)).Coprime (orderOf g) := by\n    rw [hg, Nat.coprime_pow_right_iff (pos_of_gt hpe), Nat.coprime_comm]\n    apply Or.resolve_right (Nat.coprime_or_dvd_of_prime hp _)\n    nth_rw 1 [← pow_one p]\n    have : 1 = (Nat.factorization (orderOf (t ^ p ^ k))) p + 1 := by\n     rw [hpk', Nat.factorization_div hpk]\n     simp [k, hp]\n    rw [this]\n    -- Porting note: convert made to_additive complain\n    apply Nat.pow_succ_factorization_not_dvd (hG.orderOf_pos <| t ^ p ^ k).ne' hp\n  rw [(Commute.all _ g).orderOf_mul_eq_mul_orderOf_of_coprime hcoprime, hpk',\n    hg, ha, hk, pow_add, pow_add, pow_one, ← mul_assoc, ← mul_assoc,\n    Nat.div_mul_cancel, mul_assoc, lt_mul_iff_one_lt_right <| hG.orderOf_pos t, ← pow_succ]\n  · exact one_lt_pow₀ hp.one_lt a.succ_ne_zero\n  · exact hpk\n\n"}
{"name":"AddMonoid.exponent_eq_iSup_addOrderOf","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddCommMonoid G\nh : ∀ (g : G), LT.lt 0 (addOrderOf g)\n⊢ Eq (AddMonoid.exponent G) (iSup fun g => addOrderOf g)","decl":"@[to_additive]\ntheorem exponent_eq_iSup_orderOf (h : ∀ g : G, 0 < orderOf g) :\n    exponent G = ⨆ g : G, orderOf g := by\n  rw [iSup]\n  by_cases ExponentExists G\n  case neg he =>\n    rw [← exponent_eq_zero_iff] at he\n    rw [he, Set.Infinite.Nat.sSup_eq_zero <| (exponent_eq_zero_iff_range_orderOf_infinite h).1 he]\n  case pos he =>\n    rw [csSup_eq_of_forall_le_of_forall_lt_exists_gt (Set.range_nonempty _)]\n    · simp_rw [Set.mem_range, forall_exists_index, forall_apply_eq_imp_iff]\n      exact orderOf_le_exponent he\n    intro x hx\n    obtain ⟨g, hg⟩ := exists_orderOf_eq_exponent he\n    rw [← hg] at hx\n    simp_rw [Set.mem_range, exists_exists_eq_and]\n    exact ⟨g, hx⟩\n\n"}
{"name":"Monoid.exponent_eq_iSup_orderOf","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : CommMonoid G\nh : ∀ (g : G), LT.lt 0 (orderOf g)\n⊢ Eq (Monoid.exponent G) (iSup fun g => orderOf g)","decl":"@[to_additive]\ntheorem exponent_eq_iSup_orderOf (h : ∀ g : G, 0 < orderOf g) :\n    exponent G = ⨆ g : G, orderOf g := by\n  rw [iSup]\n  by_cases ExponentExists G\n  case neg he =>\n    rw [← exponent_eq_zero_iff] at he\n    rw [he, Set.Infinite.Nat.sSup_eq_zero <| (exponent_eq_zero_iff_range_orderOf_infinite h).1 he]\n  case pos he =>\n    rw [csSup_eq_of_forall_le_of_forall_lt_exists_gt (Set.range_nonempty _)]\n    · simp_rw [Set.mem_range, forall_exists_index, forall_apply_eq_imp_iff]\n      exact orderOf_le_exponent he\n    intro x hx\n    obtain ⟨g, hg⟩ := exists_orderOf_eq_exponent he\n    rw [← hg] at hx\n    simp_rw [Set.mem_range, exists_exists_eq_and]\n    exact ⟨g, hx⟩\n\n"}
{"name":"Monoid.exponent_eq_iSup_orderOf'","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : CommMonoid G\n⊢ Eq (Monoid.exponent G) (ite (Exists fun g => Eq (orderOf g) 0) 0 (iSup fun g => orderOf g))","decl":"open scoped Classical in\n@[to_additive]\ntheorem exponent_eq_iSup_orderOf' :\n    exponent G = if ∃ g : G, orderOf g = 0 then 0 else ⨆ g : G, orderOf g := by\n  split_ifs with h\n  · obtain ⟨g, hg⟩ := h\n    exact exponent_eq_zero_of_order_zero hg\n  · have := not_exists.mp h\n    exact exponent_eq_iSup_orderOf fun g => Ne.bot_lt <| this g\n\n"}
{"name":"AddMonoid.exponent_eq_iSup_addOrderOf'","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddCommMonoid G\n⊢ Eq (AddMonoid.exponent G) (ite (Exists fun g => Eq (addOrderOf g) 0) 0 (iSup fun g => addOrderOf g))","decl":"open scoped Classical in\n@[to_additive]\ntheorem exponent_eq_iSup_orderOf' :\n    exponent G = if ∃ g : G, orderOf g = 0 then 0 else ⨆ g : G, orderOf g := by\n  split_ifs with h\n  · obtain ⟨g, hg⟩ := h\n    exact exponent_eq_zero_of_order_zero hg\n  · have := not_exists.mp h\n    exact exponent_eq_iSup_orderOf fun g => Ne.bot_lt <| this g\n\n"}
{"name":"Monoid.exponent_eq_max'_orderOf","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝¹ : CancelCommMonoid G\ninst✝ : Fintype G\n⊢ Eq (Monoid.exponent G) ((Finset.image orderOf Finset.univ).max' ⋯)","decl":"@[to_additive]\ntheorem exponent_eq_max'_orderOf [Fintype G] :\n    exponent G = ((@Finset.univ G _).image orderOf).max' ⟨1, by simp⟩ := by\n  rw [← Finset.Nonempty.csSup_eq_max', Finset.coe_image, Finset.coe_univ, Set.image_univ, ← iSup]\n  exact exponent_eq_iSup_orderOf orderOf_pos\n\n"}
{"name":"AddMonoid.exponent_eq_max'_addOrderOf","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝¹ : AddCancelCommMonoid G\ninst✝ : Fintype G\n⊢ Eq (AddMonoid.exponent G) ((Finset.image addOrderOf Finset.univ).max' ⋯)","decl":"@[to_additive]\ntheorem exponent_eq_max'_orderOf [Fintype G] :\n    exponent G = ((@Finset.univ G _).image orderOf).max' ⟨1, by simp⟩ := by\n  rw [← Finset.Nonempty.csSup_eq_max', Finset.coe_image, Finset.coe_univ, Set.image_univ, ← iSup]\n  exact exponent_eq_iSup_orderOf orderOf_pos\n\n"}
{"name":"AddGroup.exponent_dvd_card","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝¹ : AddGroup G\ninst✝ : Fintype G\n⊢ Dvd.dvd (AddMonoid.exponent G) (Fintype.card G)","decl":"@[to_additive]\ntheorem Group.exponent_dvd_card [Fintype G] : Monoid.exponent G ∣ Fintype.card G :=\n  Monoid.exponent_dvd.mpr <| fun _ => orderOf_dvd_card\n\n"}
{"name":"Group.exponent_dvd_card","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝¹ : Group G\ninst✝ : Fintype G\n⊢ Dvd.dvd (Monoid.exponent G) (Fintype.card G)","decl":"@[to_additive]\ntheorem Group.exponent_dvd_card [Fintype G] : Monoid.exponent G ∣ Fintype.card G :=\n  Monoid.exponent_dvd.mpr <| fun _ => orderOf_dvd_card\n\n"}
{"name":"AddGroup.exponent_dvd_nat_card","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddGroup G\n⊢ Dvd.dvd (AddMonoid.exponent G) (Nat.card G)","decl":"@[to_additive]\ntheorem Group.exponent_dvd_nat_card : Monoid.exponent G ∣ Nat.card G :=\n  Monoid.exponent_dvd.mpr orderOf_dvd_natCard\n\n"}
{"name":"Group.exponent_dvd_nat_card","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Group G\n⊢ Dvd.dvd (Monoid.exponent G) (Nat.card G)","decl":"@[to_additive]\ntheorem Group.exponent_dvd_nat_card : Monoid.exponent G ∣ Nat.card G :=\n  Monoid.exponent_dvd.mpr orderOf_dvd_natCard\n\n"}
{"name":"AddSubgroup.exponent_toAddSubmonoid","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Eq (AddMonoid.exponent (Subtype fun x => Membership.mem H.toAddSubmonoid x)) (AddMonoid.exponent (Subtype fun x => Membership.mem H x))","decl":"@[to_additive]\ntheorem Subgroup.exponent_toSubmonoid (H : Subgroup G) :\n    Monoid.exponent H.toSubmonoid = Monoid.exponent H :=\n  Monoid.exponent_eq_of_mulEquiv (MulEquiv.subgroupCongr rfl)\n\n"}
{"name":"Subgroup.exponent_toSubmonoid","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Group G\nH : Subgroup G\n⊢ Eq (Monoid.exponent (Subtype fun x => Membership.mem H.toSubmonoid x)) (Monoid.exponent (Subtype fun x => Membership.mem H x))","decl":"@[to_additive]\ntheorem Subgroup.exponent_toSubmonoid (H : Subgroup G) :\n    Monoid.exponent H.toSubmonoid = Monoid.exponent H :=\n  Monoid.exponent_eq_of_mulEquiv (MulEquiv.subgroupCongr rfl)\n\n"}
{"name":"AddSubgroup.exponent_top","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddGroup G\n⊢ Eq (AddMonoid.exponent (Subtype fun x => Membership.mem Top.top x)) (AddMonoid.exponent G)","decl":"@[to_additive (attr := simp)]\ntheorem Subgroup.exponent_top : Monoid.exponent (⊤ : Subgroup G) = Monoid.exponent G :=\n  Monoid.exponent_eq_of_mulEquiv topEquiv\n\n"}
{"name":"Subgroup.exponent_top","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Group G\n⊢ Eq (Monoid.exponent (Subtype fun x => Membership.mem Top.top x)) (Monoid.exponent G)","decl":"@[to_additive (attr := simp)]\ntheorem Subgroup.exponent_top : Monoid.exponent (⊤ : Subgroup G) = Monoid.exponent G :=\n  Monoid.exponent_eq_of_mulEquiv topEquiv\n\n"}
{"name":"AddSubgroup.nsmul_exponent_eq_zero","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddGroup G\nH : AddSubgroup G\ng : G\ng_in_H : Membership.mem H g\n⊢ Eq (HSMul.hSMul (AddMonoid.exponent (Subtype fun x => Membership.mem H x)) g) 0","decl":"@[to_additive]\ntheorem Subgroup.pow_exponent_eq_one {H : Subgroup G} {g : G} (g_in_H : g ∈ H) :\n    g ^ Monoid.exponent H = 1 := exponent_toSubmonoid H ▸ Submonoid.pow_exponent_eq_one g_in_H\n\n"}
{"name":"Subgroup.pow_exponent_eq_one","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Group G\nH : Subgroup G\ng : G\ng_in_H : Membership.mem H g\n⊢ Eq (HPow.hPow g (Monoid.exponent (Subtype fun x => Membership.mem H x))) 1","decl":"@[to_additive]\ntheorem Subgroup.pow_exponent_eq_one {H : Subgroup G} {g : G} (g_in_H : g ∈ H) :\n    g ^ Monoid.exponent H = 1 := exponent_toSubmonoid H ▸ Submonoid.pow_exponent_eq_one g_in_H\n\n"}
{"name":"Group.exponent_dvd_iff_forall_zpow_eq_one","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Group G\nn : Int\n⊢ Iff (Dvd.dvd (↑(Monoid.exponent G)) n) (∀ (g : G), Eq (HPow.hPow g n) 1)","decl":"@[to_additive]\ntheorem Group.exponent_dvd_iff_forall_zpow_eq_one :\n    (Monoid.exponent G : ℤ) ∣ n ↔ ∀ g : G, g ^ n = 1 := by\n  simp_rw [Int.natCast_dvd, Monoid.exponent_dvd_iff_forall_pow_eq_one, pow_natAbs_eq_one]\n\n"}
{"name":"AddGroup.exponent_dvd_iff_forall_zsmul_eq_zero","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddGroup G\nn : Int\n⊢ Iff (Dvd.dvd (↑(AddMonoid.exponent G)) n) (∀ (g : G), Eq (HSMul.hSMul n g) 0)","decl":"@[to_additive]\ntheorem Group.exponent_dvd_iff_forall_zpow_eq_one :\n    (Monoid.exponent G : ℤ) ∣ n ↔ ∀ g : G, g ^ n = 1 := by\n  simp_rw [Int.natCast_dvd, Monoid.exponent_dvd_iff_forall_pow_eq_one, pow_natAbs_eq_one]\n\n"}
{"name":"AddGroup.exponent_dvd_sub_iff_zsmul_eq_zsmul","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddGroup G\nn m : Int\n⊢ Iff (Dvd.dvd (↑(AddMonoid.exponent G)) (HSub.hSub n m)) (∀ (g : G), Eq (HSMul.hSMul n g) (HSMul.hSMul m g))","decl":"@[to_additive]\ntheorem Group.exponent_dvd_sub_iff_zpow_eq_zpow :\n    (Monoid.exponent G : ℤ) ∣ n - m ↔ ∀ g : G, g ^ n = g ^ m := by\n  simp_rw [Group.exponent_dvd_iff_forall_zpow_eq_one, zpow_sub, mul_inv_eq_one]\n\n"}
{"name":"Group.exponent_dvd_sub_iff_zpow_eq_zpow","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Group G\nn m : Int\n⊢ Iff (Dvd.dvd (↑(Monoid.exponent G)) (HSub.hSub n m)) (∀ (g : G), Eq (HPow.hPow g n) (HPow.hPow g m))","decl":"@[to_additive]\ntheorem Group.exponent_dvd_sub_iff_zpow_eq_zpow :\n    (Monoid.exponent G : ℤ) ∣ n - m ↔ ∀ g : G, g ^ n = g ^ m := by\n  simp_rw [Group.exponent_dvd_iff_forall_zpow_eq_one, zpow_sub, mul_inv_eq_one]\n\n"}
{"name":"Monoid.exponent_pi_eq_zero","module":"Mathlib.GroupTheory.Exponent","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\nj : ι\nhj : Eq (Monoid.exponent (M j)) 0\n⊢ Eq (Monoid.exponent ((i : ι) → M i)) 0","decl":"@[to_additive]\ntheorem Monoid.exponent_pi_eq_zero {ι : Type*} {M : ι → Type*} [∀ i, Monoid (M i)] {j : ι}\n    (hj : exponent (M j) = 0) : exponent ((i : ι) → M i) = 0 := by\n  classical\n  rw [@exponent_eq_zero_iff, ExponentExists] at hj ⊢\n  push_neg at hj ⊢\n  peel hj with n hn _\n  obtain ⟨m, hm⟩ := this\n  refine ⟨Pi.mulSingle j m, fun h ↦ hm ?_⟩\n  simpa using congr_fun h j\n\n"}
{"name":"AddMonoid.exponent_pi_eq_zero","module":"Mathlib.GroupTheory.Exponent","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → AddMonoid (M i)\nj : ι\nhj : Eq (AddMonoid.exponent (M j)) 0\n⊢ Eq (AddMonoid.exponent ((i : ι) → M i)) 0","decl":"@[to_additive]\ntheorem Monoid.exponent_pi_eq_zero {ι : Type*} {M : ι → Type*} [∀ i, Monoid (M i)] {j : ι}\n    (hj : exponent (M j) = 0) : exponent ((i : ι) → M i) = 0 := by\n  classical\n  rw [@exponent_eq_zero_iff, ExponentExists] at hj ⊢\n  push_neg at hj ⊢\n  peel hj with n hn _\n  obtain ⟨m, hm⟩ := this\n  refine ⟨Pi.mulSingle j m, fun h ↦ hm ?_⟩\n  simpa using congr_fun h j\n\n"}
{"name":"MonoidHom.exponent_dvd","module":"Mathlib.GroupTheory.Exponent","initialProofState":"F : Type u_1\nM₁ : Type u_2\nM₂ : Type u_3\ninst✝³ : Monoid M₁\ninst✝² : Monoid M₂\ninst✝¹ : FunLike F M₁ M₂\ninst✝ : MonoidHomClass F M₁ M₂\nf : F\nhf : Function.Surjective ⇑f\n⊢ Dvd.dvd (Monoid.exponent M₂) (Monoid.exponent M₁)","decl":"/-- If `f : M₁ →⋆ M₂` is surjective, then the exponent of `M₂` divides the exponent of `M₁`. -/\n@[to_additive]\ntheorem MonoidHom.exponent_dvd {F M₁ M₂ : Type*} [Monoid M₁] [Monoid M₂]\n    [FunLike F M₁ M₂] [MonoidHomClass F M₁ M₂]\n    {f : F} (hf : Function.Surjective f) : exponent M₂ ∣ exponent M₁ := by\n  refine Monoid.exponent_dvd_of_forall_pow_eq_one fun m₂ ↦ ?_\n  obtain ⟨m₁, rfl⟩ := hf m₂\n  rw [← map_pow, pow_exponent_eq_one, map_one]\n\n"}
{"name":"AddMonoidHom.exponent_dvd","module":"Mathlib.GroupTheory.Exponent","initialProofState":"F : Type u_1\nM₁ : Type u_2\nM₂ : Type u_3\ninst✝³ : AddMonoid M₁\ninst✝² : AddMonoid M₂\ninst✝¹ : FunLike F M₁ M₂\ninst✝ : AddMonoidHomClass F M₁ M₂\nf : F\nhf : Function.Surjective ⇑f\n⊢ Dvd.dvd (AddMonoid.exponent M₂) (AddMonoid.exponent M₁)","decl":"/-- If `f : M₁ →⋆ M₂` is surjective, then the exponent of `M₂` divides the exponent of `M₁`. -/\n@[to_additive]\ntheorem MonoidHom.exponent_dvd {F M₁ M₂ : Type*} [Monoid M₁] [Monoid M₂]\n    [FunLike F M₁ M₂] [MonoidHomClass F M₁ M₂]\n    {f : F} (hf : Function.Surjective f) : exponent M₂ ∣ exponent M₁ := by\n  refine Monoid.exponent_dvd_of_forall_pow_eq_one fun m₂ ↦ ?_\n  obtain ⟨m₁, rfl⟩ := hf m₂\n  rw [← map_pow, pow_exponent_eq_one, map_one]\n\n"}
{"name":"Monoid.exponent_pi","module":"Mathlib.GroupTheory.Exponent","initialProofState":"ι : Type u_1\ninst✝¹ : Fintype ι\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\n⊢ Eq (Monoid.exponent ((i : ι) → M i)) (Finset.univ.lcm fun x => Monoid.exponent (M x))","decl":"/-- The exponent of finite product of monoids is the `Finset.lcm` of the exponents of the\nconstituent monoids. -/\n@[to_additive \"The exponent of finite product of additive monoids is the `Finset.lcm` of the\nexponents of the constituent additive monoids.\"]\ntheorem Monoid.exponent_pi {ι : Type*} [Fintype ι] {M : ι → Type*} [∀ i, Monoid (M i)] :\n    exponent ((i : ι) → M i) = lcm univ (exponent <| M ·) := by\n  refine dvd_antisymm ?_ ?_\n  · refine exponent_dvd_of_forall_pow_eq_one fun m ↦ ?_\n    ext i\n    rw [Pi.pow_apply, Pi.one_apply, ← orderOf_dvd_iff_pow_eq_one]\n    apply dvd_trans (Monoid.order_dvd_exponent (m i))\n    exact Finset.dvd_lcm (mem_univ i)\n  · apply Finset.lcm_dvd fun i _ ↦ ?_\n    exact MonoidHom.exponent_dvd (f := Pi.evalMonoidHom (M ·) i) (Function.surjective_eval i)\n\n"}
{"name":"AddMonoid.exponent_pi","module":"Mathlib.GroupTheory.Exponent","initialProofState":"ι : Type u_1\ninst✝¹ : Fintype ι\nM : ι → Type u_2\ninst✝ : (i : ι) → AddMonoid (M i)\n⊢ Eq (AddMonoid.exponent ((i : ι) → M i)) (Finset.univ.lcm fun x => AddMonoid.exponent (M x))","decl":"/-- The exponent of finite product of monoids is the `Finset.lcm` of the exponents of the\nconstituent monoids. -/\n@[to_additive \"The exponent of finite product of additive monoids is the `Finset.lcm` of the\nexponents of the constituent additive monoids.\"]\ntheorem Monoid.exponent_pi {ι : Type*} [Fintype ι] {M : ι → Type*} [∀ i, Monoid (M i)] :\n    exponent ((i : ι) → M i) = lcm univ (exponent <| M ·) := by\n  refine dvd_antisymm ?_ ?_\n  · refine exponent_dvd_of_forall_pow_eq_one fun m ↦ ?_\n    ext i\n    rw [Pi.pow_apply, Pi.one_apply, ← orderOf_dvd_iff_pow_eq_one]\n    apply dvd_trans (Monoid.order_dvd_exponent (m i))\n    exact Finset.dvd_lcm (mem_univ i)\n  · apply Finset.lcm_dvd fun i _ ↦ ?_\n    exact MonoidHom.exponent_dvd (f := Pi.evalMonoidHom (M ·) i) (Function.surjective_eval i)\n\n"}
{"name":"AddMonoid.exponent_prod","module":"Mathlib.GroupTheory.Exponent","initialProofState":"M₁ : Type u_1\nM₂ : Type u_2\ninst✝¹ : AddMonoid M₁\ninst✝ : AddMonoid M₂\n⊢ Eq (AddMonoid.exponent (Prod M₁ M₂)) (GCDMonoid.lcm (AddMonoid.exponent M₁) (AddMonoid.exponent M₂))","decl":"/-- The exponent of product of two monoids is the `lcm` of the exponents of the\nindividuaul monoids. -/\n@[to_additive AddMonoid.exponent_prod \"The exponent of product of two additive monoids is the `lcm`\nof the exponents of the individuaul additive monoids.\"]\ntheorem Monoid.exponent_prod {M₁ M₂ : Type*} [Monoid M₁] [Monoid M₂] :\n    exponent (M₁ × M₂) = lcm (exponent M₁) (exponent M₂) := by\n  refine dvd_antisymm ?_ (lcm_dvd ?_ ?_)\n  · refine exponent_dvd_of_forall_pow_eq_one fun g ↦ ?_\n    ext1\n    · rw [Prod.pow_fst, Prod.fst_one, ← orderOf_dvd_iff_pow_eq_one]\n      exact dvd_trans (Monoid.order_dvd_exponent (g.1)) <| dvd_lcm_left _ _\n    · rw [Prod.pow_snd, Prod.snd_one, ← orderOf_dvd_iff_pow_eq_one]\n      exact dvd_trans (Monoid.order_dvd_exponent (g.2)) <| dvd_lcm_right _ _\n  · exact MonoidHom.exponent_dvd (f := MonoidHom.fst M₁ M₂) Prod.fst_surjective\n  · exact MonoidHom.exponent_dvd (f := MonoidHom.snd M₁ M₂) Prod.snd_surjective\n\n"}
{"name":"Monoid.exponent_prod","module":"Mathlib.GroupTheory.Exponent","initialProofState":"M₁ : Type u_1\nM₂ : Type u_2\ninst✝¹ : Monoid M₁\ninst✝ : Monoid M₂\n⊢ Eq (Monoid.exponent (Prod M₁ M₂)) (GCDMonoid.lcm (Monoid.exponent M₁) (Monoid.exponent M₂))","decl":"/-- The exponent of product of two monoids is the `lcm` of the exponents of the\nindividuaul monoids. -/\n@[to_additive AddMonoid.exponent_prod \"The exponent of product of two additive monoids is the `lcm`\nof the exponents of the individuaul additive monoids.\"]\ntheorem Monoid.exponent_prod {M₁ M₂ : Type*} [Monoid M₁] [Monoid M₂] :\n    exponent (M₁ × M₂) = lcm (exponent M₁) (exponent M₂) := by\n  refine dvd_antisymm ?_ (lcm_dvd ?_ ?_)\n  · refine exponent_dvd_of_forall_pow_eq_one fun g ↦ ?_\n    ext1\n    · rw [Prod.pow_fst, Prod.fst_one, ← orderOf_dvd_iff_pow_eq_one]\n      exact dvd_trans (Monoid.order_dvd_exponent (g.1)) <| dvd_lcm_left _ _\n    · rw [Prod.pow_snd, Prod.snd_one, ← orderOf_dvd_iff_pow_eq_one]\n      exact dvd_trans (Monoid.order_dvd_exponent (g.2)) <| dvd_lcm_right _ _\n  · exact MonoidHom.exponent_dvd (f := MonoidHom.fst M₁ M₂) Prod.fst_surjective\n  · exact MonoidHom.exponent_dvd (f := MonoidHom.snd M₁ M₂) Prod.snd_surjective\n\n"}
{"name":"addOrderOf_eq_two_iff","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddMonoid G\nhG : Eq (AddMonoid.exponent G) 2\nx : G\n⊢ Iff (Eq (addOrderOf x) 2) (Ne x 0)","decl":"@[to_additive]\nlemma orderOf_eq_two_iff (hG : Monoid.exponent G = 2) {x : G} :\n    orderOf x = 2 ↔ x ≠ 1 :=\n  ⟨by rintro hx rfl; norm_num at hx, orderOf_eq_prime (hG ▸ Monoid.pow_exponent_eq_one x)⟩\n\n"}
{"name":"orderOf_eq_two_iff","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Monoid G\nhG : Eq (Monoid.exponent G) 2\nx : G\n⊢ Iff (Eq (orderOf x) 2) (Ne x 1)","decl":"@[to_additive]\nlemma orderOf_eq_two_iff (hG : Monoid.exponent G = 2) {x : G} :\n    orderOf x = 2 ↔ x ≠ 1 :=\n  ⟨by rintro hx rfl; norm_num at hx, orderOf_eq_prime (hG ▸ Monoid.pow_exponent_eq_one x)⟩\n\n"}
{"name":"AddCommute.of_addOrderOf_dvd_two","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝¹ : AddMonoid G\ninst✝ : IsCancelAdd G\nh : ∀ (g : G), Dvd.dvd (addOrderOf g) 2\na b : G\n⊢ AddCommute a b","decl":"@[to_additive]\ntheorem Commute.of_orderOf_dvd_two [IsCancelMul G] (h : ∀ g : G, orderOf g ∣ 2) (a b : G) :\n    Commute a b := by\n  simp_rw [orderOf_dvd_iff_pow_eq_one] at h\n  rw [commute_iff_eq, ← mul_right_inj a, ← mul_left_inj b]\n  calc\n    a * (a * b) * b = a ^ 2 * b ^ 2 := by simp only [pow_two]; group\n    _ = 1 := by rw [h, h, mul_one]\n    _ = (a * b) ^ 2 := by rw [h]\n    _ = a * (b * a) * b := by simp only [pow_two]; group\n\n"}
{"name":"Commute.of_orderOf_dvd_two","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝¹ : Monoid G\ninst✝ : IsCancelMul G\nh : ∀ (g : G), Dvd.dvd (orderOf g) 2\na b : G\n⊢ Commute a b","decl":"@[to_additive]\ntheorem Commute.of_orderOf_dvd_two [IsCancelMul G] (h : ∀ g : G, orderOf g ∣ 2) (a b : G) :\n    Commute a b := by\n  simp_rw [orderOf_dvd_iff_pow_eq_one] at h\n  rw [commute_iff_eq, ← mul_right_inj a, ← mul_left_inj b]\n  calc\n    a * (a * b) * b = a ^ 2 * b ^ 2 := by simp only [pow_two]; group\n    _ = 1 := by rw [h, h, mul_one]\n    _ = (a * b) ^ 2 := by rw [h]\n    _ = a * (b * a) * b := by simp only [pow_two]; group\n\n"}
{"name":"add_comm_of_exponent_two","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝¹ : AddMonoid G\ninst✝ : IsCancelAdd G\nhG : Eq (AddMonoid.exponent G) 2\na b : G\n⊢ Eq (HAdd.hAdd a b) (HAdd.hAdd b a)","decl":"/-- In a cancellative monoid of exponent two, all elements commute. -/\n@[to_additive]\nlemma mul_comm_of_exponent_two [IsCancelMul G] (hG : Monoid.exponent G = 2) (a b : G) :\n    a * b = b * a :=\n  Commute.of_orderOf_dvd_two (fun g => hG ▸ Monoid.order_dvd_exponent g) a b\n\n"}
{"name":"mul_comm_of_exponent_two","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝¹ : Monoid G\ninst✝ : IsCancelMul G\nhG : Eq (Monoid.exponent G) 2\na b : G\n⊢ Eq (HMul.hMul a b) (HMul.hMul b a)","decl":"/-- In a cancellative monoid of exponent two, all elements commute. -/\n@[to_additive]\nlemma mul_comm_of_exponent_two [IsCancelMul G] (hG : Monoid.exponent G = 2) (a b : G) :\n    a * b = b * a :=\n  Commute.of_orderOf_dvd_two (fun g => hG ▸ Monoid.order_dvd_exponent g) a b\n\n"}
{"name":"neg_eq_self_of_exponent_two","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddGroup G\nhG : Eq (AddMonoid.exponent G) 2\nx : G\n⊢ Eq (Neg.neg x) x","decl":"/-- In a group of exponent two, every element is its own inverse. -/\n@[to_additive]\nlemma inv_eq_self_of_exponent_two (hG : Monoid.exponent G = 2) (x : G) :\n    x⁻¹ = x :=\n  inv_eq_of_mul_eq_one_left <| pow_two (a := x) ▸ hG ▸ Monoid.pow_exponent_eq_one x\n\n"}
{"name":"inv_eq_self_of_exponent_two","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Group G\nhG : Eq (Monoid.exponent G) 2\nx : G\n⊢ Eq (Inv.inv x) x","decl":"/-- In a group of exponent two, every element is its own inverse. -/\n@[to_additive]\nlemma inv_eq_self_of_exponent_two (hG : Monoid.exponent G = 2) (x : G) :\n    x⁻¹ = x :=\n  inv_eq_of_mul_eq_one_left <| pow_two (a := x) ▸ hG ▸ Monoid.pow_exponent_eq_one x\n\n"}
{"name":"neg_eq_self_of_addOrderOf_eq_two","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddGroup G\nx : G\nhx : Eq (addOrderOf x) 2\n⊢ Eq (Neg.neg x) x","decl":"/-- If an element in a group has order two, then it is its own inverse. -/\n@[to_additive]\nlemma inv_eq_self_of_orderOf_eq_two {x : G} (hx : orderOf x = 2) :\n    x⁻¹ = x :=\n  inv_eq_of_mul_eq_one_left <| pow_two (a := x) ▸ hx ▸ pow_orderOf_eq_one x\n\n"}
{"name":"inv_eq_self_of_orderOf_eq_two","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Group G\nx : G\nhx : Eq (orderOf x) 2\n⊢ Eq (Inv.inv x) x","decl":"/-- If an element in a group has order two, then it is its own inverse. -/\n@[to_additive]\nlemma inv_eq_self_of_orderOf_eq_two {x : G} (hx : orderOf x = 2) :\n    x⁻¹ = x :=\n  inv_eq_of_mul_eq_one_left <| pow_two (a := x) ▸ hx ▸ pow_orderOf_eq_one x\n\n"}
{"name":"mul_not_mem_of_orderOf_eq_two","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Group G\nx y : G\nhx : Eq (orderOf x) 2\nhy : Eq (orderOf y) 2\nhxy : Ne x y\n⊢ Not (Membership.mem (Insert.insert x (Insert.insert y (Singleton.singleton 1))) (HMul.hMul x y))","decl":"@[to_additive]\nlemma mul_not_mem_of_orderOf_eq_two {x y : G} (hx : orderOf x = 2)\n    (hy : orderOf y = 2) (hxy : x ≠ y) : x * y ∉ ({x, y, 1} : Set G) := by\n  simp only [Set.mem_singleton_iff, Set.mem_insert_iff, mul_right_eq_self, mul_left_eq_self,\n    mul_eq_one_iff_eq_inv, inv_eq_self_of_orderOf_eq_two hy, not_or]\n  aesop\n\n"}
{"name":"add_not_mem_of_addOrderOf_eq_two","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddGroup G\nx y : G\nhx : Eq (addOrderOf x) 2\nhy : Eq (addOrderOf y) 2\nhxy : Ne x y\n⊢ Not (Membership.mem (Insert.insert x (Insert.insert y (Singleton.singleton 0))) (HAdd.hAdd x y))","decl":"@[to_additive]\nlemma mul_not_mem_of_orderOf_eq_two {x y : G} (hx : orderOf x = 2)\n    (hy : orderOf y = 2) (hxy : x ≠ y) : x * y ∉ ({x, y, 1} : Set G) := by\n  simp only [Set.mem_singleton_iff, Set.mem_insert_iff, mul_right_eq_self, mul_left_eq_self,\n    mul_eq_one_iff_eq_inv, inv_eq_self_of_orderOf_eq_two hy, not_or]\n  aesop\n\n"}
{"name":"add_not_mem_of_exponent_two","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : AddGroup G\nh : Eq (AddMonoid.exponent G) 2\nx y : G\nhx : Ne x 0\nhy : Ne y 0\nhxy : Ne x y\n⊢ Not (Membership.mem (Insert.insert x (Insert.insert y (Singleton.singleton 0))) (HAdd.hAdd x y))","decl":"@[to_additive]\nlemma mul_not_mem_of_exponent_two (h : Monoid.exponent G = 2) {x y : G}\n    (hx : x ≠ 1) (hy : y ≠ 1) (hxy : x ≠ y) : x * y ∉ ({x, y, 1} : Set G) :=\n  mul_not_mem_of_orderOf_eq_two (orderOf_eq_prime (h ▸ Monoid.pow_exponent_eq_one x) hx)\n    (orderOf_eq_prime (h ▸ Monoid.pow_exponent_eq_one y) hy) hxy\n\n"}
{"name":"mul_not_mem_of_exponent_two","module":"Mathlib.GroupTheory.Exponent","initialProofState":"G : Type u\ninst✝ : Group G\nh : Eq (Monoid.exponent G) 2\nx y : G\nhx : Ne x 1\nhy : Ne y 1\nhxy : Ne x y\n⊢ Not (Membership.mem (Insert.insert x (Insert.insert y (Singleton.singleton 1))) (HMul.hMul x y))","decl":"@[to_additive]\nlemma mul_not_mem_of_exponent_two (h : Monoid.exponent G = 2) {x y : G}\n    (hx : x ≠ 1) (hy : y ≠ 1) (hxy : x ≠ y) : x * y ∉ ({x, y, 1} : Set G) :=\n  mul_not_mem_of_orderOf_eq_two (orderOf_eq_prime (h ▸ Monoid.pow_exponent_eq_one x) hx)\n    (orderOf_eq_prime (h ▸ Monoid.pow_exponent_eq_one y) hy) hxy\n\n"}
