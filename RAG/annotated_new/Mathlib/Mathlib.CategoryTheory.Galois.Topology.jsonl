{"name":"CategoryTheory.PreGaloisCategory.autEmbedding_apply","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\nσ : CategoryTheory.Aut F\nX : C\n⊢ Eq ((CategoryTheory.PreGaloisCategory.autEmbedding F) σ X) (CategoryTheory.Iso.app σ X)","decl":"@[simp]\nlemma autEmbedding_apply (σ : Aut F) (X : C) : autEmbedding F σ X = σ.app X :=\n  rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autEmbedding_injective","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\n⊢ Function.Injective ⇑(CategoryTheory.PreGaloisCategory.autEmbedding F)","decl":"lemma autEmbedding_injective : Function.Injective (autEmbedding F) := by\n  intro σ τ h\n  ext X x\n  have : σ.app X = τ.app X := congr_fun h X\n  rw [← Iso.app_hom, ← Iso.app_hom, this]\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.obj_discreteTopology","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\nX : C\n⊢ DiscreteTopology ↑(F.obj X)","decl":"@[scoped instance]\nlemma obj_discreteTopology (X : C) : DiscreteTopology (F.obj X) := ⟨rfl⟩\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.aut_discreteTopology","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\nX : C\n⊢ DiscreteTopology (CategoryTheory.Aut (F.obj X))","decl":"@[scoped instance]\nlemma aut_discreteTopology (X : C) : DiscreteTopology (Aut (F.obj X)) := ⟨rfl⟩\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autEmbedding_range","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\n⊢ Eq (Set.range ⇑(CategoryTheory.PreGaloisCategory.autEmbedding F)) (Set.iInter fun f => setOf fun a => Eq (CategoryTheory.CategoryStruct.comp (F.map f.hom) (a f.right).hom) (CategoryTheory.CategoryStruct.comp (a f.left).hom (F.map f.hom)))","decl":"/-- The image of `Aut F` in `∀ X, Aut (F.obj X)` are precisely the compatible families of\nautomorphisms. -/\nlemma autEmbedding_range :\n    Set.range (autEmbedding F) =\n      ⋂ (f : Arrow C), { a | F.map f.hom ≫ (a f.right).hom = (a f.left).hom ≫ F.map f.hom } := by\n  ext a\n  simp only [Set.mem_range, id_obj, Set.mem_iInter, Set.mem_setOf_eq]\n  refine ⟨fun ⟨σ, h⟩ i ↦ h.symm ▸ σ.hom.naturality i.hom, fun h ↦ ?_⟩\n  · use NatIso.ofComponents a (fun {X Y} f ↦ h ⟨X, Y, f⟩)\n    rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autEmbedding_range_isClosed","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\n⊢ IsClosed (Set.range ⇑(CategoryTheory.PreGaloisCategory.autEmbedding F))","decl":"/-- The image of `Aut F` in `∀ X, Aut (F.obj X)` is closed. -/\nlemma autEmbedding_range_isClosed : IsClosed (Set.range (autEmbedding F)) := by\n  rw [autEmbedding_range]\n  refine isClosed_iInter (fun f ↦ isClosed_eq (X := F.obj f.left → F.obj f.right) ?_ ?_)\n  · fun_prop\n  · fun_prop\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autEmbedding_isClosedEmbedding","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\n⊢ Topology.IsClosedEmbedding ⇑(CategoryTheory.PreGaloisCategory.autEmbedding F)","decl":"lemma autEmbedding_isClosedEmbedding : IsClosedEmbedding (autEmbedding F) where\n  eq_induced := rfl\n  injective := autEmbedding_injective F\n  isClosed_range := autEmbedding_range_isClosed F\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autEmbedding_closedEmbedding","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\n⊢ Topology.IsClosedEmbedding ⇑(CategoryTheory.PreGaloisCategory.autEmbedding F)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias autEmbedding_closedEmbedding := autEmbedding_isClosedEmbedding\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.instCompactSpaceAutFunctorFintypeCat","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\n⊢ CompactSpace (CategoryTheory.Aut F)","decl":"instance : CompactSpace (Aut F) := (autEmbedding_isClosedEmbedding F).compactSpace\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.instT2SpaceAutFunctorFintypeCat","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\n⊢ T2Space (CategoryTheory.Aut F)","decl":"instance : T2Space (Aut F) :=\n  T2Space.of_injective_continuous (autEmbedding_injective F) continuous_induced_dom\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.instTotallyDisconnectedSpaceAutFunctorFintypeCat","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\n⊢ TotallyDisconnectedSpace (CategoryTheory.Aut F)","decl":"instance : TotallyDisconnectedSpace (Aut F) :=\n  (autEmbedding_isClosedEmbedding F).isEmbedding.isTotallyDisconnected_range.mp\n    (isTotallyDisconnected_of_totallyDisconnectedSpace _)\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.instContinuousMulAutFunctorFintypeCat","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\n⊢ ContinuousMul (CategoryTheory.Aut F)","decl":"instance : ContinuousMul (Aut F) :=\n  (autEmbedding_isClosedEmbedding F).isInducing.continuousMul (autEmbedding F)\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.instContinuousInvAutFunctorFintypeCat","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\n⊢ ContinuousInv (CategoryTheory.Aut F)","decl":"instance : ContinuousInv (Aut F) :=\n  (autEmbedding_isClosedEmbedding F).isInducing.continuousInv fun _ ↦ rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.instTopologicalGroupAutFunctorFintypeCat","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\n⊢ TopologicalGroup (CategoryTheory.Aut F)","decl":"instance : TopologicalGroup (Aut F) := ⟨⟩\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.instContinuousSMulAutFintypeCatObjαFintype","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\nX : C\n⊢ ContinuousSMul (CategoryTheory.Aut (F.obj X)) ↑(F.obj X)","decl":"instance (X : C) : ContinuousSMul (Aut (F.obj X)) (F.obj X) := by\n  constructor\n  fun_prop\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.continuousSMul_aut_fiber","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\nX : C\n⊢ ContinuousSMul (CategoryTheory.Aut F) ↑(F.obj X)","decl":"instance continuousSMul_aut_fiber (X : C) : ContinuousSMul (Aut F) (F.obj X) where\n  continuous_smul := by\n    let g : Aut (F.obj X) × F.obj X → F.obj X := fun ⟨σ, x⟩ ↦ σ.hom x\n    let h (q : Aut F × F.obj X) : Aut (F.obj X) × F.obj X :=\n      ⟨((fun p ↦ p X) ∘ autEmbedding F) q.1, q.2⟩\n    show Continuous (g ∘ h)\n    fun_prop\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.exists_set_ker_evaluation_subset_of_isOpen","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\ninst✝¹ : CategoryTheory.GaloisCategory C\ninst✝ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nH : Set (CategoryTheory.Aut F)\nh1 : Membership.mem H 1\nh : IsOpen H\n⊢ Exists fun I => Exists fun x => And (∀ (X : C), Membership.mem I X → CategoryTheory.PreGaloisCategory.IsConnected X) (∀ (σ : CategoryTheory.Aut F), (∀ (X : ↑I), Eq (σ.hom.app ↑X) (CategoryTheory.CategoryStruct.id (F.obj ↑X))) → Membership.mem H σ)","decl":"/--\nIf `H` is an open subset of `Aut F` such that `1 ∈ H`, there exists a finite\nset `I` of connected objects of `C` such that every `σ : Aut F` that induces the identity\non `F.obj X` for all `X ∈ I` is contained in `H`. In other words: The kernel\nof the evaluation map `Aut F →* ∏ X : I ↦ Aut (F.obj X)` is contained in `H`.\n-/\nlemma exists_set_ker_evaluation_subset_of_isOpen\n    {H : Set (Aut F)} (h1 : 1 ∈ H) (h : IsOpen H) :\n    ∃ (I : Set C) (_ : Fintype I), (∀ X ∈ I, IsConnected X) ∧\n      (∀ σ : Aut F, (∀ X : I, σ.hom.app X = 𝟙 (F.obj X)) → σ ∈ H) := by\n  obtain ⟨U, hUopen, rfl⟩ := isOpen_induced_iff.mp h\n  obtain ⟨I, u, ho, ha⟩ := isOpen_pi_iff.mp hUopen 1 h1\n  choose fι ff fc h4 h5 h6 using (fun X : I => has_decomp_connected_components X.val)\n  refine ⟨⋃ X, Set.range (ff X), Fintype.ofFinite _, ?_, ?_⟩\n  · rintro X ⟨A, ⟨Y, rfl⟩, hA2⟩\n    obtain ⟨i, rfl⟩ := hA2\n    exact h5 Y i\n  · refine fun σ h ↦ ha (fun X XinI ↦ ?_)\n    suffices h : autEmbedding F σ X = 1 by\n      rw [h]\n      exact (ho X XinI).right\n    have h : σ.hom.app X = 𝟙 (F.obj X) := by\n      have : Fintype (fι ⟨X, XinI⟩) := Fintype.ofFinite _\n      ext x\n      obtain ⟨⟨j⟩, a, ha : F.map _ a = x⟩ := Limits.FintypeCat.jointly_surjective\n        (Discrete.functor (ff ⟨X, XinI⟩) ⋙ F) _ (Limits.isColimitOfPreserves F (h4 ⟨X, XinI⟩)) x\n      rw [FintypeCat.id_apply, ← ha, FunctorToFintypeCat.naturality]\n      simp [h ⟨(ff _) j, ⟨Set.range (ff ⟨X, XinI⟩), ⟨⟨_, rfl⟩, ⟨j, rfl⟩⟩⟩⟩]\n    exact Iso.ext h\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.nhds_one_has_basis_stabilizers","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\nF : CategoryTheory.Functor C FintypeCat\ninst✝¹ : CategoryTheory.GaloisCategory C\ninst✝ : CategoryTheory.PreGaloisCategory.FiberFunctor F\n⊢ (nhds 1).HasBasis (fun x => True) fun X => ↑(MulAction.stabilizer (CategoryTheory.Aut F) X.pt)","decl":"/-- The stabilizers of points in the fibers of Galois objects form a neighbourhood basis\nof the identity in `Aut F`. -/\nlemma nhds_one_has_basis_stabilizers : (nhds (1 : Aut F)).HasBasis (fun _ ↦ True)\n    (fun X : PointedGaloisObject F ↦ MulAction.stabilizer (Aut F) X.pt) where\n  mem_iff' S := by\n    rw [mem_nhds_iff]\n    refine ⟨?_, ?_⟩\n    · intro ⟨U, hU, hUopen, hUone⟩\n      obtain ⟨I, _, hc, hmem⟩ := exists_set_ker_evaluation_subset_of_isOpen F hUone hUopen\n      let P : C := ∏ᶜ fun X : I ↦ X.val\n      obtain ⟨A, a, hgal, hbij⟩ := exists_galois_representative F P\n      refine ⟨⟨A, a, hgal⟩, trivial, ?_⟩\n      intro t (ht : t.hom.app A a = a)\n      apply hU\n      apply hmem\n      haveI (X : I) : IsConnected X.val := hc X.val X.property\n      haveI (X : I) : Nonempty (F.obj X.val) := nonempty_fiber_of_isConnected F X\n      intro X\n      ext x\n      simp only [FintypeCat.id_apply]\n      obtain ⟨z, rfl⟩ :=\n        surjective_of_nonempty_fiber_of_isConnected F (Pi.π (fun X : I ↦ X.val) X) x\n      obtain ⟨f, rfl⟩ := hbij.surjective z\n      rw [FunctorToFintypeCat.naturality, FunctorToFintypeCat.naturality, ht]\n    · intro ⟨X, _, h⟩\n      exact ⟨MulAction.stabilizer (Aut F) X.pt, h, stabilizer_isOpen (Aut F) X.pt,\n        Subgroup.one_mem _⟩\n\n"}
