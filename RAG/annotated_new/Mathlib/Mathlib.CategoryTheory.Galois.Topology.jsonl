{"name":"CategoryTheory.PreGaloisCategory.autEmbedding_apply","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nF : CategoryTheory.Functor C FintypeCat\nœÉ : CategoryTheory.Aut F\nX : C\n‚ä¢ Eq ((CategoryTheory.PreGaloisCategory.autEmbedding F) œÉ X) (CategoryTheory.Iso.app œÉ X)","decl":"@[simp]\nlemma autEmbedding_apply (œÉ : Aut F) (X : C) : autEmbedding F œÉ X = œÉ.app X :=\n  rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autEmbedding_injective","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nF : CategoryTheory.Functor C FintypeCat\n‚ä¢ Function.Injective ‚áë(CategoryTheory.PreGaloisCategory.autEmbedding F)","decl":"lemma autEmbedding_injective : Function.Injective (autEmbedding F) := by\n  intro œÉ œÑ h\n  ext X x\n  have : œÉ.app X = œÑ.app X := congr_fun h X\n  rw [‚Üê Iso.app_hom, ‚Üê Iso.app_hom, this]\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.obj_discreteTopology","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nF : CategoryTheory.Functor C FintypeCat\nX : C\n‚ä¢ DiscreteTopology ‚Üë(F.obj X)","decl":"@[scoped instance]\nlemma obj_discreteTopology (X : C) : DiscreteTopology (F.obj X) := ‚ü®rfl‚ü©\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.aut_discreteTopology","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nF : CategoryTheory.Functor C FintypeCat\nX : C\n‚ä¢ DiscreteTopology (CategoryTheory.Aut (F.obj X))","decl":"@[scoped instance]\nlemma aut_discreteTopology (X : C) : DiscreteTopology (Aut (F.obj X)) := ‚ü®rfl‚ü©\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autEmbedding_range","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nF : CategoryTheory.Functor C FintypeCat\n‚ä¢ Eq (Set.range ‚áë(CategoryTheory.PreGaloisCategory.autEmbedding F)) (Set.iInter fun f => setOf fun a => Eq (CategoryTheory.CategoryStruct.comp (F.map f.hom) (a f.right).hom) (CategoryTheory.CategoryStruct.comp (a f.left).hom (F.map f.hom)))","decl":"/-- The image of `Aut F` in `‚àÄ X, Aut (F.obj X)` are precisely the compatible families of\nautomorphisms. -/\nlemma autEmbedding_range :\n    Set.range (autEmbedding F) =\n      ‚ãÇ (f : Arrow C), { a | F.map f.hom ‚â´ (a f.right).hom = (a f.left).hom ‚â´ F.map f.hom } := by\n  ext a\n  simp only [Set.mem_range, id_obj, Set.mem_iInter, Set.mem_setOf_eq]\n  refine ‚ü®fun ‚ü®œÉ, h‚ü© i ‚Ü¶ h.symm ‚ñ∏ œÉ.hom.naturality i.hom, fun h ‚Ü¶ ?_‚ü©\n  ¬∑ use NatIso.ofComponents a (fun {X Y} f ‚Ü¶ h ‚ü®X, Y, f‚ü©)\n    rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autEmbedding_range_isClosed","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nF : CategoryTheory.Functor C FintypeCat\n‚ä¢ IsClosed (Set.range ‚áë(CategoryTheory.PreGaloisCategory.autEmbedding F))","decl":"/-- The image of `Aut F` in `‚àÄ X, Aut (F.obj X)` is closed. -/\nlemma autEmbedding_range_isClosed : IsClosed (Set.range (autEmbedding F)) := by\n  rw [autEmbedding_range]\n  refine isClosed_iInter (fun f ‚Ü¶ isClosed_eq (X := F.obj f.left ‚Üí F.obj f.right) ?_ ?_)\n  ¬∑ fun_prop\n  ¬∑ fun_prop\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autEmbedding_isClosedEmbedding","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nF : CategoryTheory.Functor C FintypeCat\n‚ä¢ Topology.IsClosedEmbedding ‚áë(CategoryTheory.PreGaloisCategory.autEmbedding F)","decl":"lemma autEmbedding_isClosedEmbedding : IsClosedEmbedding (autEmbedding F) where\n  eq_induced := rfl\n  injective := autEmbedding_injective F\n  isClosed_range := autEmbedding_range_isClosed F\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.autEmbedding_closedEmbedding","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nF : CategoryTheory.Functor C FintypeCat\n‚ä¢ Topology.IsClosedEmbedding ‚áë(CategoryTheory.PreGaloisCategory.autEmbedding F)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias autEmbedding_closedEmbedding := autEmbedding_isClosedEmbedding\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.instCompactSpaceAutFunctorFintypeCat","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nF : CategoryTheory.Functor C FintypeCat\n‚ä¢ CompactSpace (CategoryTheory.Aut F)","decl":"instance : CompactSpace (Aut F) := (autEmbedding_isClosedEmbedding F).compactSpace\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.instT2SpaceAutFunctorFintypeCat","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nF : CategoryTheory.Functor C FintypeCat\n‚ä¢ T2Space (CategoryTheory.Aut F)","decl":"instance : T2Space (Aut F) :=\n  T2Space.of_injective_continuous (autEmbedding_injective F) continuous_induced_dom\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.instTotallyDisconnectedSpaceAutFunctorFintypeCat","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nF : CategoryTheory.Functor C FintypeCat\n‚ä¢ TotallyDisconnectedSpace (CategoryTheory.Aut F)","decl":"instance : TotallyDisconnectedSpace (Aut F) :=\n  (autEmbedding_isClosedEmbedding F).isEmbedding.isTotallyDisconnected_range.mp\n    (isTotallyDisconnected_of_totallyDisconnectedSpace _)\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.instContinuousMulAutFunctorFintypeCat","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nF : CategoryTheory.Functor C FintypeCat\n‚ä¢ ContinuousMul (CategoryTheory.Aut F)","decl":"instance : ContinuousMul (Aut F) :=\n  (autEmbedding_isClosedEmbedding F).isInducing.continuousMul (autEmbedding F)\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.instContinuousInvAutFunctorFintypeCat","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nF : CategoryTheory.Functor C FintypeCat\n‚ä¢ ContinuousInv (CategoryTheory.Aut F)","decl":"instance : ContinuousInv (Aut F) :=\n  (autEmbedding_isClosedEmbedding F).isInducing.continuousInv fun _ ‚Ü¶ rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.instTopologicalGroupAutFunctorFintypeCat","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nF : CategoryTheory.Functor C FintypeCat\n‚ä¢ TopologicalGroup (CategoryTheory.Aut F)","decl":"instance : TopologicalGroup (Aut F) := ‚ü®‚ü©\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.instContinuousSMulAutFintypeCatObjŒ±Fintype","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nF : CategoryTheory.Functor C FintypeCat\nX : C\n‚ä¢ ContinuousSMul (CategoryTheory.Aut (F.obj X)) ‚Üë(F.obj X)","decl":"instance (X : C) : ContinuousSMul (Aut (F.obj X)) (F.obj X) := by\n  constructor\n  fun_prop\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.continuousSMul_aut_fiber","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nF : CategoryTheory.Functor C FintypeCat\nX : C\n‚ä¢ ContinuousSMul (CategoryTheory.Aut F) ‚Üë(F.obj X)","decl":"instance continuousSMul_aut_fiber (X : C) : ContinuousSMul (Aut F) (F.obj X) where\n  continuous_smul := by\n    let g : Aut (F.obj X) √ó F.obj X ‚Üí F.obj X := fun ‚ü®œÉ, x‚ü© ‚Ü¶ œÉ.hom x\n    let h (q : Aut F √ó F.obj X) : Aut (F.obj X) √ó F.obj X :=\n      ‚ü®((fun p ‚Ü¶ p X) ‚àò autEmbedding F) q.1, q.2‚ü©\n    show Continuous (g ‚àò h)\n    fun_prop\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.exists_set_ker_evaluation_subset_of_isOpen","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nF : CategoryTheory.Functor C FintypeCat\ninst‚úù¬π : CategoryTheory.GaloisCategory C\ninst‚úù : CategoryTheory.PreGaloisCategory.FiberFunctor F\nH : Set (CategoryTheory.Aut F)\nh1 : Membership.mem H 1\nh : IsOpen H\n‚ä¢ Exists fun I => Exists fun x => And (‚àÄ (X : C), Membership.mem I X ‚Üí CategoryTheory.PreGaloisCategory.IsConnected X) (‚àÄ (œÉ : CategoryTheory.Aut F), (‚àÄ (X : ‚ÜëI), Eq (œÉ.hom.app ‚ÜëX) (CategoryTheory.CategoryStruct.id (F.obj ‚ÜëX))) ‚Üí Membership.mem H œÉ)","decl":"/--\nIf `H` is an open subset of `Aut F` such that `1 ‚àà H`, there exists a finite\nset `I` of connected objects of `C` such that every `œÉ : Aut F` that induces the identity\non `F.obj X` for all `X ‚àà I` is contained in `H`. In other words: The kernel\nof the evaluation map `Aut F ‚Üí* ‚àè X : I ‚Ü¶ Aut (F.obj X)` is contained in `H`.\n-/\nlemma exists_set_ker_evaluation_subset_of_isOpen\n    {H : Set (Aut F)} (h1 : 1 ‚àà H) (h : IsOpen H) :\n    ‚àÉ (I : Set C) (_ : Fintype I), (‚àÄ X ‚àà I, IsConnected X) ‚àß\n      (‚àÄ œÉ : Aut F, (‚àÄ X : I, œÉ.hom.app X = ùüô (F.obj X)) ‚Üí œÉ ‚àà H) := by\n  obtain ‚ü®U, hUopen, rfl‚ü© := isOpen_induced_iff.mp h\n  obtain ‚ü®I, u, ho, ha‚ü© := isOpen_pi_iff.mp hUopen 1 h1\n  choose fŒπ ff fc h4 h5 h6 using (fun X : I => has_decomp_connected_components X.val)\n  refine ‚ü®‚ãÉ X, Set.range (ff X), Fintype.ofFinite _, ?_, ?_‚ü©\n  ¬∑ rintro X ‚ü®A, ‚ü®Y, rfl‚ü©, hA2‚ü©\n    obtain ‚ü®i, rfl‚ü© := hA2\n    exact h5 Y i\n  ¬∑ refine fun œÉ h ‚Ü¶ ha (fun X XinI ‚Ü¶ ?_)\n    suffices h : autEmbedding F œÉ X = 1 by\n      rw [h]\n      exact (ho X XinI).right\n    have h : œÉ.hom.app X = ùüô (F.obj X) := by\n      have : Fintype (fŒπ ‚ü®X, XinI‚ü©) := Fintype.ofFinite _\n      ext x\n      obtain ‚ü®‚ü®j‚ü©, a, ha : F.map _ a = x‚ü© := Limits.FintypeCat.jointly_surjective\n        (Discrete.functor (ff ‚ü®X, XinI‚ü©) ‚ãô F) _ (Limits.isColimitOfPreserves F (h4 ‚ü®X, XinI‚ü©)) x\n      rw [FintypeCat.id_apply, ‚Üê ha, FunctorToFintypeCat.naturality]\n      simp [h ‚ü®(ff _) j, ‚ü®Set.range (ff ‚ü®X, XinI‚ü©), ‚ü®‚ü®_, rfl‚ü©, ‚ü®j, rfl‚ü©‚ü©‚ü©‚ü©]\n    exact Iso.ext h\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.nhds_one_has_basis_stabilizers","module":"Mathlib.CategoryTheory.Galois.Topology","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nF : CategoryTheory.Functor C FintypeCat\ninst‚úù¬π : CategoryTheory.GaloisCategory C\ninst‚úù : CategoryTheory.PreGaloisCategory.FiberFunctor F\n‚ä¢ (nhds 1).HasBasis (fun x => True) fun X => ‚Üë(MulAction.stabilizer (CategoryTheory.Aut F) X.pt)","decl":"/-- The stabilizers of points in the fibers of Galois objects form a neighbourhood basis\nof the identity in `Aut F`. -/\nlemma nhds_one_has_basis_stabilizers : (nhds (1 : Aut F)).HasBasis (fun _ ‚Ü¶ True)\n    (fun X : PointedGaloisObject F ‚Ü¶ MulAction.stabilizer (Aut F) X.pt) where\n  mem_iff' S := by\n    rw [mem_nhds_iff]\n    refine ‚ü®?_, ?_‚ü©\n    ¬∑ intro ‚ü®U, hU, hUopen, hUone‚ü©\n      obtain ‚ü®I, _, hc, hmem‚ü© := exists_set_ker_evaluation_subset_of_isOpen F hUone hUopen\n      let P : C := ‚àè·∂ú fun X : I ‚Ü¶ X.val\n      obtain ‚ü®A, a, hgal, hbij‚ü© := exists_galois_representative F P\n      refine ‚ü®‚ü®A, a, hgal‚ü©, trivial, ?_‚ü©\n      intro t (ht : t.hom.app A a = a)\n      apply hU\n      apply hmem\n      haveI (X : I) : IsConnected X.val := hc X.val X.property\n      haveI (X : I) : Nonempty (F.obj X.val) := nonempty_fiber_of_isConnected F X\n      intro X\n      ext x\n      simp only [FintypeCat.id_apply]\n      obtain ‚ü®z, rfl‚ü© :=\n        surjective_of_nonempty_fiber_of_isConnected F (Pi.œÄ (fun X : I ‚Ü¶ X.val) X) x\n      obtain ‚ü®f, rfl‚ü© := hbij.surjective z\n      rw [FunctorToFintypeCat.naturality, FunctorToFintypeCat.naturality, ht]\n    ¬∑ intro ‚ü®X, _, h‚ü©\n      exact ‚ü®MulAction.stabilizer (Aut F) X.pt, h, stabilizer_isOpen (Aut F) X.pt,\n        Subgroup.one_mem _‚ü©\n\n"}
