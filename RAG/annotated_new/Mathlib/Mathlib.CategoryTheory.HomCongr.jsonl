{"name":"CategoryTheory.Iso.homCongr_symm_apply","module":"Mathlib.CategoryTheory.HomCongr","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y X₁ Y₁ : C\nα : CategoryTheory.Iso X X₁\nβ : CategoryTheory.Iso Y Y₁\nf : Quiver.Hom X₁ Y₁\n⊢ Eq ((α.homCongr β).symm f) (CategoryTheory.CategoryStruct.comp α.hom (CategoryTheory.CategoryStruct.comp f β.inv))","decl":"/-- If `X` is isomorphic to `X₁` and `Y` is isomorphic to `Y₁`, then\nthere is a natural bijection between `X ⟶ Y` and `X₁ ⟶ Y₁`. See also `Equiv.arrowCongr`. -/\n@[simps]\ndef homCongr {X Y X₁ Y₁ : C} (α : X ≅ X₁) (β : Y ≅ Y₁) : (X ⟶ Y) ≃ (X₁ ⟶ Y₁) where\n  toFun f := α.inv ≫ f ≫ β.hom\n  invFun f := α.hom ≫ f ≫ β.inv\n  left_inv f :=\n    show α.hom ≫ (α.inv ≫ f ≫ β.hom) ≫ β.inv = f by\n      rw [Category.assoc, Category.assoc, β.hom_inv_id, α.hom_inv_id_assoc, Category.comp_id]\n  right_inv f :=\n    show α.inv ≫ (α.hom ≫ f ≫ β.inv) ≫ β.hom = f by\n      rw [Category.assoc, Category.assoc, β.inv_hom_id, α.inv_hom_id_assoc, Category.comp_id]\n\n"}
{"name":"CategoryTheory.Iso.homCongr_apply","module":"Mathlib.CategoryTheory.HomCongr","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y X₁ Y₁ : C\nα : CategoryTheory.Iso X X₁\nβ : CategoryTheory.Iso Y Y₁\nf : Quiver.Hom X Y\n⊢ Eq ((α.homCongr β) f) (CategoryTheory.CategoryStruct.comp α.inv (CategoryTheory.CategoryStruct.comp f β.hom))","decl":"/-- If `X` is isomorphic to `X₁` and `Y` is isomorphic to `Y₁`, then\nthere is a natural bijection between `X ⟶ Y` and `X₁ ⟶ Y₁`. See also `Equiv.arrowCongr`. -/\n@[simps]\ndef homCongr {X Y X₁ Y₁ : C} (α : X ≅ X₁) (β : Y ≅ Y₁) : (X ⟶ Y) ≃ (X₁ ⟶ Y₁) where\n  toFun f := α.inv ≫ f ≫ β.hom\n  invFun f := α.hom ≫ f ≫ β.inv\n  left_inv f :=\n    show α.hom ≫ (α.inv ≫ f ≫ β.hom) ≫ β.inv = f by\n      rw [Category.assoc, Category.assoc, β.hom_inv_id, α.hom_inv_id_assoc, Category.comp_id]\n  right_inv f :=\n    show α.inv ≫ (α.hom ≫ f ≫ β.inv) ≫ β.hom = f by\n      rw [Category.assoc, Category.assoc, β.inv_hom_id, α.inv_hom_id_assoc, Category.comp_id]\n\n"}
{"name":"CategoryTheory.Iso.homCongr_comp","module":"Mathlib.CategoryTheory.HomCongr","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z X₁ Y₁ Z₁ : C\nα : CategoryTheory.Iso X X₁\nβ : CategoryTheory.Iso Y Y₁\nγ : CategoryTheory.Iso Z Z₁\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq ((α.homCongr γ) (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp ((α.homCongr β) f) ((β.homCongr γ) g))","decl":"theorem homCongr_comp {X Y Z X₁ Y₁ Z₁ : C} (α : X ≅ X₁) (β : Y ≅ Y₁) (γ : Z ≅ Z₁) (f : X ⟶ Y)\n    (g : Y ⟶ Z) : α.homCongr γ (f ≫ g) = α.homCongr β f ≫ β.homCongr γ g := by simp\n\n"}
{"name":"CategoryTheory.Iso.homCongr_refl","module":"Mathlib.CategoryTheory.HomCongr","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (((CategoryTheory.Iso.refl X).homCongr (CategoryTheory.Iso.refl Y)) f) f","decl":"theorem homCongr_refl {X Y : C} (f : X ⟶ Y) : (Iso.refl X).homCongr (Iso.refl Y) f = f := by simp\n\n"}
{"name":"CategoryTheory.Iso.homCongr_trans","module":"Mathlib.CategoryTheory.HomCongr","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX₁ Y₁ X₂ Y₂ X₃ Y₃ : C\nα₁ : CategoryTheory.Iso X₁ X₂\nβ₁ : CategoryTheory.Iso Y₁ Y₂\nα₂ : CategoryTheory.Iso X₂ X₃\nβ₂ : CategoryTheory.Iso Y₂ Y₃\nf : Quiver.Hom X₁ Y₁\n⊢ Eq (((α₁.trans α₂).homCongr (β₁.trans β₂)) f) (((α₁.homCongr β₁).trans (α₂.homCongr β₂)) f)","decl":"theorem homCongr_trans {X₁ Y₁ X₂ Y₂ X₃ Y₃ : C} (α₁ : X₁ ≅ X₂) (β₁ : Y₁ ≅ Y₂) (α₂ : X₂ ≅ X₃)\n    (β₂ : Y₂ ≅ Y₃) (f : X₁ ⟶ Y₁) :\n    (α₁ ≪≫ α₂).homCongr (β₁ ≪≫ β₂) f = (α₁.homCongr β₁).trans (α₂.homCongr β₂) f := by simp\n\n"}
{"name":"CategoryTheory.Iso.homCongr_symm","module":"Mathlib.CategoryTheory.HomCongr","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX₁ Y₁ X₂ Y₂ : C\nα : CategoryTheory.Iso X₁ X₂\nβ : CategoryTheory.Iso Y₁ Y₂\n⊢ Eq (α.homCongr β).symm (α.symm.homCongr β.symm)","decl":"@[simp]\ntheorem homCongr_symm {X₁ Y₁ X₂ Y₂ : C} (α : X₁ ≅ X₂) (β : Y₁ ≅ Y₂) :\n    (α.homCongr β).symm = α.symm.homCongr β.symm :=\n  rfl\n\n"}
{"name":"CategoryTheory.Iso.isoCongr_apply","module":"Mathlib.CategoryTheory.HomCongr","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX₁ Y₁ X₂ Y₂ : C\nf : CategoryTheory.Iso X₁ X₂\ng : CategoryTheory.Iso Y₁ Y₂\nh : CategoryTheory.Iso X₁ Y₁\n⊢ Eq ((f.isoCongr g) h) (f.symm.trans (h.trans g))","decl":"/-- If `X` is isomorphic to `X₁` and `Y` is isomorphic to `Y₁`, then\nthere is a bijection between `X ≅ Y` and `X₁ ≅ Y₁`. -/\n@[simps]\ndef isoCongr {X₁ Y₁ X₂ Y₂ : C} (f : X₁ ≅ X₂) (g : Y₁ ≅ Y₂) : (X₁ ≅ Y₁) ≃ (X₂ ≅ Y₂) where\n  toFun h := f.symm.trans <| h.trans <| g\n  invFun h := f.trans <| h.trans <| g.symm\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.Iso.isoCongr_symm_apply","module":"Mathlib.CategoryTheory.HomCongr","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX₁ Y₁ X₂ Y₂ : C\nf : CategoryTheory.Iso X₁ X₂\ng : CategoryTheory.Iso Y₁ Y₂\nh : CategoryTheory.Iso X₂ Y₂\n⊢ Eq ((f.isoCongr g).symm h) (f.trans (h.trans g.symm))","decl":"/-- If `X` is isomorphic to `X₁` and `Y` is isomorphic to `Y₁`, then\nthere is a bijection between `X ≅ Y` and `X₁ ≅ Y₁`. -/\n@[simps]\ndef isoCongr {X₁ Y₁ X₂ Y₂ : C} (f : X₁ ≅ X₂) (g : Y₁ ≅ Y₂) : (X₁ ≅ Y₁) ≃ (X₂ ≅ Y₂) where\n  toFun h := f.symm.trans <| h.trans <| g\n  invFun h := f.trans <| h.trans <| g.symm\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.map_homCongr","module":"Mathlib.CategoryTheory.HomCongr","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nF : CategoryTheory.Functor C D\nX Y X₁ Y₁ : C\nα : CategoryTheory.Iso X X₁\nβ : CategoryTheory.Iso Y Y₁\nf : Quiver.Hom X Y\n⊢ Eq (F.map ((α.homCongr β) f)) (((F.mapIso α).homCongr (F.mapIso β)) (F.map f))","decl":"theorem map_homCongr {X Y X₁ Y₁ : C} (α : X ≅ X₁) (β : Y ≅ Y₁) (f : X ⟶ Y) :\n    F.map (Iso.homCongr α β f) = Iso.homCongr (F.mapIso α) (F.mapIso β) (F.map f) := by simp\n\n"}
{"name":"CategoryTheory.Functor.map_isoCongr","module":"Mathlib.CategoryTheory.HomCongr","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nF : CategoryTheory.Functor C D\nX Y X₁ Y₁ : C\nα : CategoryTheory.Iso X X₁\nβ : CategoryTheory.Iso Y Y₁\nf : CategoryTheory.Iso X Y\n⊢ Eq (F.mapIso ((α.isoCongr β) f)) (((F.mapIso α).isoCongr (F.mapIso β)) (F.mapIso f))","decl":"theorem map_isoCongr {X Y X₁ Y₁ : C} (α : X ≅ X₁) (β : Y ≅ Y₁) (f : X ≅ Y) :\n    F.mapIso (Iso.isoCongr α β f) = Iso.isoCongr (F.mapIso α) (F.mapIso β) (F.mapIso f) := by\n  ext\n  simp\n\n"}
