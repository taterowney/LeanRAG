{"name":"HolderWith.memHolder","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\nr : NNReal\nf : X → Y\nC : NNReal\nhf : HolderWith C r f\n⊢ MemHolder r f","decl":"lemma HolderWith.memHolder {C : ℝ≥0} (hf : HolderWith C r f) : MemHolder r f := ⟨C, hf⟩\n\n"}
{"name":"eHolderNorm_lt_top","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\nr : NNReal\nf : X → Y\n⊢ Iff (LT.lt (eHolderNorm r f) Top.top) (MemHolder r f)","decl":"@[simp] lemma eHolderNorm_lt_top : eHolderNorm r f < ∞ ↔ MemHolder r f := by\n  refine ⟨fun h => ?_,\n    fun hf => let ⟨C, hC⟩ := hf; iInf_lt_top.2 ⟨C, iInf_lt_top.2 ⟨hC, coe_lt_top⟩⟩⟩\n  simp_rw [eHolderNorm, iInf_lt_top] at h\n  let ⟨C, hC, _⟩ := h\n  exact ⟨C, hC⟩\n\n"}
{"name":"eHolderNorm_ne_top","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\nr : NNReal\nf : X → Y\n⊢ Iff (Ne (eHolderNorm r f) Top.top) (MemHolder r f)","decl":"lemma eHolderNorm_ne_top : eHolderNorm r f ≠ ∞ ↔ MemHolder r f := by\n  rw [← eHolderNorm_lt_top, lt_top_iff_ne_top]\n\n"}
{"name":"eHolderNorm_eq_top","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\nr : NNReal\nf : X → Y\n⊢ Iff (Eq (eHolderNorm r f) Top.top) (Not (MemHolder r f))","decl":"@[simp] lemma eHolderNorm_eq_top : eHolderNorm r f = ∞ ↔ ¬ MemHolder r f := by\n  rw [← eHolderNorm_ne_top, not_not]\n\n"}
{"name":"MemHolder.eHolderNorm_lt_top","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\nr : NNReal\nf : X → Y\na✝ : MemHolder r f\n⊢ LT.lt (eHolderNorm r f) Top.top","decl":"protected alias ⟨_, MemHolder.eHolderNorm_lt_top⟩ := eHolderNorm_lt_top\n"}
{"name":"MemHolder.eHolderNorm_ne_top","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\nr : NNReal\nf : X → Y\na✝ : MemHolder r f\n⊢ Ne (eHolderNorm r f) Top.top","decl":"protected alias ⟨_, MemHolder.eHolderNorm_ne_top⟩ := eHolderNorm_ne_top\n\n"}
{"name":"coe_nnHolderNorm_le_eHolderNorm","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\nr : NNReal\nf : X → Y\n⊢ LE.le (↑(nnHolderNorm r f)) (eHolderNorm r f)","decl":"lemma coe_nnHolderNorm_le_eHolderNorm {r : ℝ≥0} {f : X → Y} :\n    (nnHolderNorm r f : ℝ≥0∞) ≤ eHolderNorm r f :=\n  coe_toNNReal_le_self\n\n"}
{"name":"eHolderNorm_const","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\nr : NNReal\nc : Y\n⊢ Eq (eHolderNorm r (Function.const X c)) 0","decl":"variable (X) in\n@[simp]\nlemma eHolderNorm_const (r : ℝ≥0) (c : Y) : eHolderNorm r (Function.const X c) = 0 := by\n  rw [eHolderNorm, ← ENNReal.bot_eq_zero, iInf₂_eq_bot]\n  exact fun C' hC' => ⟨0, .const, hC'⟩\n\n"}
{"name":"eHolderNorm_zero","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : PseudoEMetricSpace X\ninst✝¹ : PseudoEMetricSpace Y\ninst✝ : Zero Y\nr : NNReal\n⊢ Eq (eHolderNorm r 0) 0","decl":"variable (X) in\n@[simp]\nlemma eHolderNorm_zero [Zero Y] (r : ℝ≥0) : eHolderNorm r (0 : X → Y) = 0 :=\n  eHolderNorm_const X r 0\n\n"}
{"name":"nnHolderNorm_const","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\nr : NNReal\nc : Y\n⊢ Eq (nnHolderNorm r (Function.const X c)) 0","decl":"variable (X) in\n@[simp]\nlemma nnHolderNorm_const (r : ℝ≥0) (c : Y) : nnHolderNorm r (Function.const X c) = 0 := by\n  refine le_antisymm (ENNReal.coe_le_coe.1 <|\n    le_trans coe_nnHolderNorm_le_eHolderNorm ?_) (zero_le _)\n  rw [eHolderNorm_const, ENNReal.coe_zero]\n\n"}
{"name":"nnHolderNorm_zero","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : PseudoEMetricSpace X\ninst✝¹ : PseudoEMetricSpace Y\ninst✝ : Zero Y\nr : NNReal\n⊢ Eq (nnHolderNorm r 0) 0","decl":"variable (X) in\n@[simp]\nlemma nnHolderNorm_zero [Zero Y] (r : ℝ≥0) : nnHolderNorm r (0 : X → Y) = 0 :=\n  nnHolderNorm_const X r 0\n\n"}
{"name":"eHolderNorm_of_isEmpty","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\nr : NNReal\nf : X → Y\nhX : IsEmpty X\n⊢ Eq (eHolderNorm r f) 0","decl":"lemma eHolderNorm_of_isEmpty [hX : IsEmpty X] :\n    eHolderNorm r f = 0 := by\n  rw [eHolderNorm, ← ENNReal.bot_eq_zero, iInf₂_eq_bot]\n  exact fun ε hε => ⟨0, .of_isEmpty, hε⟩\n\n"}
{"name":"HolderWith.eHolderNorm_le","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\nr : NNReal\nf : X → Y\nC : NNReal\nhf : HolderWith C r f\n⊢ LE.le (eHolderNorm r f) ↑C","decl":"lemma HolderWith.eHolderNorm_le {C : ℝ≥0} (hf : HolderWith C r f) :\n    eHolderNorm r f ≤ C :=\n  iInf₂_le C hf\n\n"}
{"name":"memHolder_const","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\nr : NNReal\nc : Y\n⊢ MemHolder r (Function.const X c)","decl":"/-- See also `memHolder_const` for the version with the spelling `fun _ ↦ c`. -/\n@[simp]\nlemma memHolder_const {c : Y} : MemHolder r (Function.const X c) :=\n  (HolderWith.const (C := 0)).memHolder\n\n"}
{"name":"memHolder_const'","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : PseudoEMetricSpace X\ninst✝ : PseudoEMetricSpace Y\nr : NNReal\nc : Y\n⊢ MemHolder r fun x => c","decl":"/-- Version of `memHolder_const` with the spelling `fun _ ↦ c` for the constant function. -/\n@[simp]\nlemma memHolder_const' {c : Y} : MemHolder r (fun _ ↦ c : X → Y) :=\n  memHolder_const\n\n"}
{"name":"memHolder_zero","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : PseudoEMetricSpace X\ninst✝¹ : PseudoEMetricSpace Y\nr : NNReal\ninst✝ : Zero Y\n⊢ MemHolder r 0","decl":"@[simp]\nlemma memHolder_zero [Zero Y] : MemHolder r (0 : X → Y) :=\n  memHolder_const\n\n"}
{"name":"eHolderNorm_eq_zero","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : MetricSpace X\ninst✝ : EMetricSpace Y\nr : NNReal\nf : X → Y\n⊢ Iff (Eq (eHolderNorm r f) 0) (∀ (x₁ x₂ : X), Eq (f x₁) (f x₂))","decl":"lemma eHolderNorm_eq_zero {r : ℝ≥0} {f : X → Y} :\n    eHolderNorm r f = 0 ↔ ∀ x₁ x₂, f x₁ = f x₂ := by\n  constructor\n  · refine fun h x₁ x₂ => ?_\n    by_cases hx : x₁ = x₂\n    · rw [hx]\n    · rw [eHolderNorm, ← ENNReal.bot_eq_zero, iInf₂_eq_bot] at h\n      rw [← edist_eq_zero, ← le_zero_iff]\n      refine le_of_forall_lt' fun b hb => ?_\n      obtain ⟨C, hC, hC'⟩ := h (b / edist x₁ x₂ ^ (r : ℝ))\n        (ENNReal.div_pos hb.ne.symm (ENNReal.rpow_lt_top_of_nonneg zero_le_coe\n          (edist_lt_top x₁ x₂).ne).ne)\n      exact lt_of_le_of_lt (hC x₁ x₂) <| ENNReal.mul_lt_of_lt_div hC'\n  · intro h\n    cases' isEmpty_or_nonempty X with hX hX\n    · haveI := hX\n      exact eHolderNorm_of_isEmpty\n    · rw [← eHolderNorm_const X r (f hX.some)]\n      congr\n      simp [funext_iff, h _ hX.some]\n\n"}
{"name":"MemHolder.holderWith","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : MetricSpace X\ninst✝ : EMetricSpace Y\nr : NNReal\nf : X → Y\nhf : MemHolder r f\n⊢ HolderWith (nnHolderNorm r f) r f","decl":"lemma MemHolder.holderWith {r : ℝ≥0} {f : X → Y} (hf : MemHolder r f) :\n    HolderWith (nnHolderNorm r f) r f := by\n  intros x₁ x₂\n  by_cases hx : x₁ = x₂\n  · simp only [hx, edist_self, zero_le]\n  rw [nnHolderNorm, eHolderNorm, coe_toNNReal]\n  on_goal 2 => exact hf.eHolderNorm_lt_top.ne\n  have h₁ : edist x₁ x₂ ^ (r : ℝ) ≠ 0 :=\n    (Ne.symm <| ne_of_lt <| ENNReal.rpow_pos (edist_pos.2 hx) (edist_lt_top x₁ x₂).ne)\n  have h₂ : edist x₁ x₂ ^ (r : ℝ) ≠ ∞ := by\n    simp [(edist_lt_top x₁ x₂).ne]\n  rw [← ENNReal.div_le_iff h₁ h₂]\n  refine le_iInf₂ fun C hC => ?_\n  rw [ENNReal.div_le_iff h₁ h₂]\n  exact hC x₁ x₂\n\n"}
{"name":"memHolder_iff_holderWith","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : MetricSpace X\ninst✝ : EMetricSpace Y\nr : NNReal\nf : X → Y\n⊢ Iff (MemHolder r f) (HolderWith (nnHolderNorm r f) r f)","decl":"lemma memHolder_iff_holderWith {r : ℝ≥0} {f : X → Y} :\n    MemHolder r f ↔ HolderWith (nnHolderNorm r f) r f :=\n  ⟨MemHolder.holderWith, HolderWith.memHolder⟩\n\n"}
{"name":"MemHolder.coe_nnHolderNorm_eq_eHolderNorm","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : MetricSpace X\ninst✝ : EMetricSpace Y\nr : NNReal\nf : X → Y\nhf : MemHolder r f\n⊢ Eq (↑(nnHolderNorm r f)) (eHolderNorm r f)","decl":"lemma MemHolder.coe_nnHolderNorm_eq_eHolderNorm\n    {r : ℝ≥0} {f : X → Y} (hf : MemHolder r f) :\n    (nnHolderNorm r f : ℝ≥0∞) = eHolderNorm r f := by\n  rw [nnHolderNorm, coe_toNNReal]\n  exact ne_of_lt <| lt_of_le_of_lt hf.holderWith.eHolderNorm_le <| coe_lt_top\n\n"}
{"name":"HolderWith.nnholderNorm_le","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : MetricSpace X\ninst✝ : EMetricSpace Y\nC r : NNReal\nf : X → Y\nhf : HolderWith C r f\n⊢ LE.le (nnHolderNorm r f) C","decl":"lemma HolderWith.nnholderNorm_le {C r : ℝ≥0} {f : X → Y} (hf : HolderWith C r f) :\n    nnHolderNorm r f ≤ C := by\n  rw [← ENNReal.coe_le_coe, hf.memHolder.coe_nnHolderNorm_eq_eHolderNorm]\n  exact hf.eHolderNorm_le\n\n"}
{"name":"MemHolder.comp","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : MetricSpace X\ninst✝¹ : EMetricSpace Y\nr s : NNReal\nZ : Type u_3\ninst✝ : MetricSpace Z\nf : Z → X\ng : X → Y\nhf : MemHolder r f\nhg : MemHolder s g\n⊢ MemHolder (HMul.hMul s r) (Function.comp g f)","decl":"lemma MemHolder.comp {r s : ℝ≥0} {Z : Type*} [MetricSpace Z] {f : Z → X} {g : X → Y}\n    (hf : MemHolder r f) (hg : MemHolder s g) : MemHolder (s * r) (g ∘ f) :=\n  (hg.holderWith.comp hf.holderWith).memHolder\n\n"}
{"name":"MemHolder.nnHolderNorm_eq_zero","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : MetricSpace X\ninst✝ : EMetricSpace Y\nr : NNReal\nf : X → Y\nhf : MemHolder r f\n⊢ Iff (Eq (nnHolderNorm r f) 0) (∀ (x₁ x₂ : X), Eq (f x₁) (f x₂))","decl":"lemma MemHolder.nnHolderNorm_eq_zero {r : ℝ≥0} {f : X → Y} (hf : MemHolder r f) :\n    nnHolderNorm r f = 0 ↔ ∀ x₁ x₂, f x₁ = f x₂ := by\n  rw [← ENNReal.coe_eq_zero, hf.coe_nnHolderNorm_eq_eHolderNorm, eHolderNorm_eq_zero]\n\n"}
{"name":"MemHolder.add","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : MetricSpace X\ninst✝ : NormedAddCommGroup Y\nr : NNReal\nf g : X → Y\nhf : MemHolder r f\nhg : MemHolder r g\n⊢ MemHolder r (HAdd.hAdd f g)","decl":"lemma MemHolder.add (hf : MemHolder r f) (hg : MemHolder r g) : MemHolder r (f + g) :=\n  (hf.holderWith.add hg.holderWith).memHolder\n\n"}
{"name":"MemHolder.smul","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝⁴ : MetricSpace X\ninst✝³ : NormedAddCommGroup Y\nr : NNReal\nf : X → Y\n𝕜 : Type u_3\ninst✝² : NormedDivisionRing 𝕜\ninst✝¹ : Module 𝕜 Y\ninst✝ : BoundedSMul 𝕜 Y\nc : 𝕜\nhf : MemHolder r f\n⊢ MemHolder r (HSMul.hSMul c f)","decl":"lemma MemHolder.smul {𝕜} [NormedDivisionRing 𝕜] [Module 𝕜 Y] [BoundedSMul 𝕜 Y]\n    {c : 𝕜} (hf : MemHolder r f) : MemHolder r (c • f) :=\n  (hf.holderWith.smul c).memHolder\n\n"}
{"name":"MemHolder.nsmul","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝³ : MetricSpace X\ninst✝² : NormedAddCommGroup Y\nr : NNReal\nf : X → Y\ninst✝¹ : Module Real Y\ninst✝ : BoundedSMul Real Y\nn : Nat\nhf : MemHolder r f\n⊢ MemHolder r (HSMul.hSMul n f)","decl":"lemma MemHolder.nsmul [Module ℝ Y] [BoundedSMul ℝ Y] (n : ℕ) (hf : MemHolder r f) :\n    MemHolder r (n • f) := by\n  simp [← Nat.cast_smul_eq_nsmul (R := ℝ), hf.smul]\n\n"}
{"name":"MemHolder.nnHolderNorm_add_le","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : MetricSpace X\ninst✝ : NormedAddCommGroup Y\nr : NNReal\nf g : X → Y\nhf : MemHolder r f\nhg : MemHolder r g\n⊢ LE.le (nnHolderNorm r (HAdd.hAdd f g)) (HAdd.hAdd (nnHolderNorm r f) (nnHolderNorm r g))","decl":"lemma MemHolder.nnHolderNorm_add_le (hf : MemHolder r f) (hg : MemHolder r g) :\n    nnHolderNorm r (f + g) ≤ nnHolderNorm r f + nnHolderNorm r g :=\n  (hf.add hg).holderWith.nnholderNorm_le.trans <|\n    coe_le_coe.2 (hf.holderWith.add hg.holderWith).nnholderNorm_le\n\n"}
{"name":"eHolderNorm_add_le","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : MetricSpace X\ninst✝ : NormedAddCommGroup Y\nr : NNReal\nf g : X → Y\n⊢ LE.le (eHolderNorm r (HAdd.hAdd f g)) (HAdd.hAdd (eHolderNorm r f) (eHolderNorm r g))","decl":"lemma eHolderNorm_add_le :\n    eHolderNorm r (f + g) ≤ eHolderNorm r f + eHolderNorm r g := by\n  by_cases hfg : MemHolder r f  ∧ MemHolder r g\n  · obtain ⟨hf, hg⟩ := hfg\n    rw [← hf.coe_nnHolderNorm_eq_eHolderNorm, ← hg.coe_nnHolderNorm_eq_eHolderNorm,\n      ← (hf.add hg).coe_nnHolderNorm_eq_eHolderNorm, ← coe_add, ENNReal.coe_le_coe]\n    exact hf.nnHolderNorm_add_le hg\n  · rw [Classical.not_and_iff_or_not_not, ← eHolderNorm_eq_top, ← eHolderNorm_eq_top] at hfg\n    obtain (h | h) := hfg\n    all_goals simp [h]\n\n"}
{"name":"eHolderNorm_smul","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝⁴ : MetricSpace X\ninst✝³ : NormedAddCommGroup Y\nr : NNReal\nf : X → Y\nα : Type u_3\ninst✝² : NormedDivisionRing α\ninst✝¹ : Module α Y\ninst✝ : BoundedSMul α Y\nc : α\n⊢ Eq (eHolderNorm r (HSMul.hSMul c f)) (HMul.hMul (↑(NNNorm.nnnorm c)) (eHolderNorm r f))","decl":"lemma eHolderNorm_smul {α} [NormedDivisionRing α] [Module α Y] [BoundedSMul α Y] (c : α) :\n    eHolderNorm r (c • f) = ‖c‖₊ * eHolderNorm r f := by\n  by_cases hc : ‖c‖₊ = 0\n  · rw [nnnorm_eq_zero] at hc\n    simp [hc]\n  by_cases hf : MemHolder r f\n  · refine le_antisymm ((hf.holderWith.smul c).eHolderNorm_le.trans ?_) <| mul_le_of_le_div' ?_\n    · rw [coe_mul, hf.coe_nnHolderNorm_eq_eHolderNorm, mul_comm]\n    · rw [← (hf.holderWith.smul c).memHolder.coe_nnHolderNorm_eq_eHolderNorm, ← coe_div hc]\n      refine HolderWith.eHolderNorm_le fun x₁ x₂ => ?_\n      rw [coe_div hc, ← ENNReal.mul_div_right_comm,\n        ENNReal.le_div_iff_mul_le (Or.inl <| coe_ne_zero.2 hc) <| Or.inl coe_ne_top,\n        mul_comm, ← smul_eq_mul, ← ENNReal.smul_def, ← edist_smul₀, ← Pi.smul_apply,\n        ← Pi.smul_apply]\n      exact hf.smul.holderWith x₁ x₂\n  · rw [← eHolderNorm_eq_top] at hf\n    rw [hf, mul_top <| coe_ne_zero.2 hc, eHolderNorm_eq_top]\n    rw [nnnorm_eq_zero] at hc\n    intro h\n    have := h.smul (c := c⁻¹)\n    rw [inv_smul_smul₀ hc] at this\n    exact this.eHolderNorm_lt_top.ne hf\n\n"}
{"name":"MemHolder.nnHolderNorm_smul","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝⁴ : MetricSpace X\ninst✝³ : NormedAddCommGroup Y\nr : NNReal\nf : X → Y\nα : Type u_3\ninst✝² : NormedDivisionRing α\ninst✝¹ : Module α Y\ninst✝ : BoundedSMul α Y\nhf : MemHolder r f\nc : α\n⊢ Eq (nnHolderNorm r (HSMul.hSMul c f)) (HMul.hMul (NNNorm.nnnorm c) (nnHolderNorm r f))","decl":"lemma MemHolder.nnHolderNorm_smul {α} [NormedDivisionRing α] [Module α Y] [BoundedSMul α Y]\n    (hf : MemHolder r f) (c : α) :\n    nnHolderNorm r (c • f) = ‖c‖₊ * nnHolderNorm r f := by\n  rw [← ENNReal.coe_inj, coe_mul, hf.coe_nnHolderNorm_eq_eHolderNorm,\n    hf.smul.coe_nnHolderNorm_eq_eHolderNorm, eHolderNorm_smul]\n\n"}
{"name":"eHolderNorm_nsmul","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝³ : MetricSpace X\ninst✝² : NormedAddCommGroup Y\nr : NNReal\nf : X → Y\ninst✝¹ : Module Real Y\ninst✝ : BoundedSMul Real Y\nn : Nat\n⊢ Eq (eHolderNorm r (HSMul.hSMul n f)) (HSMul.hSMul n (eHolderNorm r f))","decl":"lemma eHolderNorm_nsmul [Module ℝ Y] [BoundedSMul ℝ Y] (n : ℕ) :\n    eHolderNorm r (n • f) = n • eHolderNorm r f := by\n  simp [← Nat.cast_smul_eq_nsmul (R := ℝ), eHolderNorm_smul]\n\n"}
{"name":"MemHolder.nnHolderNorm_nsmul","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝³ : MetricSpace X\ninst✝² : NormedAddCommGroup Y\nr : NNReal\nf : X → Y\ninst✝¹ : Module Real Y\ninst✝ : BoundedSMul Real Y\nn : Nat\nhf : MemHolder r f\n⊢ Eq (nnHolderNorm r (HSMul.hSMul n f)) (HSMul.hSMul n (nnHolderNorm r f))","decl":"lemma MemHolder.nnHolderNorm_nsmul [Module ℝ Y] [BoundedSMul ℝ Y] (n : ℕ) (hf : MemHolder r f) :\n    nnHolderNorm r (n • f) = n • nnHolderNorm r f := by\n  simp [← Nat.cast_smul_eq_nsmul (R := ℝ), hf.nnHolderNorm_smul]\n\n"}
