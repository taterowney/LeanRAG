{"name":"HolderWith.memHolder","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nr : NNReal\nf : X ‚Üí Y\nC : NNReal\nhf : HolderWith C r f\n‚ä¢ MemHolder r f","decl":"lemma HolderWith.memHolder {C : ‚Ñù‚â•0} (hf : HolderWith C r f) : MemHolder r f := ‚ü®C, hf‚ü©\n\n"}
{"name":"eHolderNorm_lt_top","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nr : NNReal\nf : X ‚Üí Y\n‚ä¢ Iff (LT.lt (eHolderNorm r f) Top.top) (MemHolder r f)","decl":"@[simp] lemma eHolderNorm_lt_top : eHolderNorm r f < ‚àû ‚Üî MemHolder r f := by\n  refine ‚ü®fun h => ?_,\n    fun hf => let ‚ü®C, hC‚ü© := hf; iInf_lt_top.2 ‚ü®C, iInf_lt_top.2 ‚ü®hC, coe_lt_top‚ü©‚ü©‚ü©\n  simp_rw [eHolderNorm, iInf_lt_top] at h\n  let ‚ü®C, hC, _‚ü© := h\n  exact ‚ü®C, hC‚ü©\n\n"}
{"name":"eHolderNorm_ne_top","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nr : NNReal\nf : X ‚Üí Y\n‚ä¢ Iff (Ne (eHolderNorm r f) Top.top) (MemHolder r f)","decl":"lemma eHolderNorm_ne_top : eHolderNorm r f ‚â† ‚àû ‚Üî MemHolder r f := by\n  rw [‚Üê eHolderNorm_lt_top, lt_top_iff_ne_top]\n\n"}
{"name":"eHolderNorm_eq_top","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nr : NNReal\nf : X ‚Üí Y\n‚ä¢ Iff (Eq (eHolderNorm r f) Top.top) (Not (MemHolder r f))","decl":"@[simp] lemma eHolderNorm_eq_top : eHolderNorm r f = ‚àû ‚Üî ¬¨ MemHolder r f := by\n  rw [‚Üê eHolderNorm_ne_top, not_not]\n\n"}
{"name":"MemHolder.eHolderNorm_lt_top","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nr : NNReal\nf : X ‚Üí Y\na‚úù : MemHolder r f\n‚ä¢ LT.lt (eHolderNorm r f) Top.top","decl":"protected alias ‚ü®_, MemHolder.eHolderNorm_lt_top‚ü© := eHolderNorm_lt_top\n"}
{"name":"MemHolder.eHolderNorm_ne_top","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nr : NNReal\nf : X ‚Üí Y\na‚úù : MemHolder r f\n‚ä¢ Ne (eHolderNorm r f) Top.top","decl":"protected alias ‚ü®_, MemHolder.eHolderNorm_ne_top‚ü© := eHolderNorm_ne_top\n\n"}
{"name":"coe_nnHolderNorm_le_eHolderNorm","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nr : NNReal\nf : X ‚Üí Y\n‚ä¢ LE.le (‚Üë(nnHolderNorm r f)) (eHolderNorm r f)","decl":"lemma coe_nnHolderNorm_le_eHolderNorm {r : ‚Ñù‚â•0} {f : X ‚Üí Y} :\n    (nnHolderNorm r f : ‚Ñù‚â•0‚àû) ‚â§ eHolderNorm r f :=\n  coe_toNNReal_le_self\n\n"}
{"name":"eHolderNorm_const","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nr : NNReal\nc : Y\n‚ä¢ Eq (eHolderNorm r (Function.const X c)) 0","decl":"variable (X) in\n@[simp]\nlemma eHolderNorm_const (r : ‚Ñù‚â•0) (c : Y) : eHolderNorm r (Function.const X c) = 0 := by\n  rw [eHolderNorm, ‚Üê ENNReal.bot_eq_zero, iInf‚ÇÇ_eq_bot]\n  exact fun C' hC' => ‚ü®0, .const, hC'‚ü©\n\n"}
{"name":"eHolderNorm_zero","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : PseudoEMetricSpace X\ninst‚úù¬π : PseudoEMetricSpace Y\ninst‚úù : Zero Y\nr : NNReal\n‚ä¢ Eq (eHolderNorm r 0) 0","decl":"variable (X) in\n@[simp]\nlemma eHolderNorm_zero [Zero Y] (r : ‚Ñù‚â•0) : eHolderNorm r (0 : X ‚Üí Y) = 0 :=\n  eHolderNorm_const X r 0\n\n"}
{"name":"nnHolderNorm_const","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nr : NNReal\nc : Y\n‚ä¢ Eq (nnHolderNorm r (Function.const X c)) 0","decl":"variable (X) in\n@[simp]\nlemma nnHolderNorm_const (r : ‚Ñù‚â•0) (c : Y) : nnHolderNorm r (Function.const X c) = 0 := by\n  refine le_antisymm (ENNReal.coe_le_coe.1 <|\n    le_trans coe_nnHolderNorm_le_eHolderNorm ?_) (zero_le _)\n  rw [eHolderNorm_const, ENNReal.coe_zero]\n\n"}
{"name":"nnHolderNorm_zero","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : PseudoEMetricSpace X\ninst‚úù¬π : PseudoEMetricSpace Y\ninst‚úù : Zero Y\nr : NNReal\n‚ä¢ Eq (nnHolderNorm r 0) 0","decl":"variable (X) in\n@[simp]\nlemma nnHolderNorm_zero [Zero Y] (r : ‚Ñù‚â•0) : nnHolderNorm r (0 : X ‚Üí Y) = 0 :=\n  nnHolderNorm_const X r 0\n\n"}
{"name":"eHolderNorm_of_isEmpty","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nr : NNReal\nf : X ‚Üí Y\nhX : IsEmpty X\n‚ä¢ Eq (eHolderNorm r f) 0","decl":"lemma eHolderNorm_of_isEmpty [hX : IsEmpty X] :\n    eHolderNorm r f = 0 := by\n  rw [eHolderNorm, ‚Üê ENNReal.bot_eq_zero, iInf‚ÇÇ_eq_bot]\n  exact fun Œµ hŒµ => ‚ü®0, .of_isEmpty, hŒµ‚ü©\n\n"}
{"name":"HolderWith.eHolderNorm_le","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nr : NNReal\nf : X ‚Üí Y\nC : NNReal\nhf : HolderWith C r f\n‚ä¢ LE.le (eHolderNorm r f) ‚ÜëC","decl":"lemma HolderWith.eHolderNorm_le {C : ‚Ñù‚â•0} (hf : HolderWith C r f) :\n    eHolderNorm r f ‚â§ C :=\n  iInf‚ÇÇ_le C hf\n\n"}
{"name":"memHolder_const","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nr : NNReal\nc : Y\n‚ä¢ MemHolder r (Function.const X c)","decl":"/-- See also `memHolder_const` for the version with the spelling `fun _ ‚Ü¶ c`. -/\n@[simp]\nlemma memHolder_const {c : Y} : MemHolder r (Function.const X c) :=\n  (HolderWith.const (C := 0)).memHolder\n\n"}
{"name":"memHolder_const'","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : PseudoEMetricSpace X\ninst‚úù : PseudoEMetricSpace Y\nr : NNReal\nc : Y\n‚ä¢ MemHolder r fun x => c","decl":"/-- Version of `memHolder_const` with the spelling `fun _ ‚Ü¶ c` for the constant function. -/\n@[simp]\nlemma memHolder_const' {c : Y} : MemHolder r (fun _ ‚Ü¶ c : X ‚Üí Y) :=\n  memHolder_const\n\n"}
{"name":"memHolder_zero","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : PseudoEMetricSpace X\ninst‚úù¬π : PseudoEMetricSpace Y\nr : NNReal\ninst‚úù : Zero Y\n‚ä¢ MemHolder r 0","decl":"@[simp]\nlemma memHolder_zero [Zero Y] : MemHolder r (0 : X ‚Üí Y) :=\n  memHolder_const\n\n"}
{"name":"eHolderNorm_eq_zero","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : MetricSpace X\ninst‚úù : EMetricSpace Y\nr : NNReal\nf : X ‚Üí Y\n‚ä¢ Iff (Eq (eHolderNorm r f) 0) (‚àÄ (x‚ÇÅ x‚ÇÇ : X), Eq (f x‚ÇÅ) (f x‚ÇÇ))","decl":"lemma eHolderNorm_eq_zero {r : ‚Ñù‚â•0} {f : X ‚Üí Y} :\n    eHolderNorm r f = 0 ‚Üî ‚àÄ x‚ÇÅ x‚ÇÇ, f x‚ÇÅ = f x‚ÇÇ := by\n  constructor\n  ¬∑ refine fun h x‚ÇÅ x‚ÇÇ => ?_\n    by_cases hx : x‚ÇÅ = x‚ÇÇ\n    ¬∑ rw [hx]\n    ¬∑ rw [eHolderNorm, ‚Üê ENNReal.bot_eq_zero, iInf‚ÇÇ_eq_bot] at h\n      rw [‚Üê edist_eq_zero, ‚Üê le_zero_iff]\n      refine le_of_forall_lt' fun b hb => ?_\n      obtain ‚ü®C, hC, hC'‚ü© := h (b / edist x‚ÇÅ x‚ÇÇ ^ (r : ‚Ñù))\n        (ENNReal.div_pos hb.ne.symm (ENNReal.rpow_lt_top_of_nonneg zero_le_coe\n          (edist_lt_top x‚ÇÅ x‚ÇÇ).ne).ne)\n      exact lt_of_le_of_lt (hC x‚ÇÅ x‚ÇÇ) <| ENNReal.mul_lt_of_lt_div hC'\n  ¬∑ intro h\n    cases' isEmpty_or_nonempty X with hX hX\n    ¬∑ haveI := hX\n      exact eHolderNorm_of_isEmpty\n    ¬∑ rw [‚Üê eHolderNorm_const X r (f hX.some)]\n      congr\n      simp [funext_iff, h _ hX.some]\n\n"}
{"name":"MemHolder.holderWith","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : MetricSpace X\ninst‚úù : EMetricSpace Y\nr : NNReal\nf : X ‚Üí Y\nhf : MemHolder r f\n‚ä¢ HolderWith (nnHolderNorm r f) r f","decl":"lemma MemHolder.holderWith {r : ‚Ñù‚â•0} {f : X ‚Üí Y} (hf : MemHolder r f) :\n    HolderWith (nnHolderNorm r f) r f := by\n  intros x‚ÇÅ x‚ÇÇ\n  by_cases hx : x‚ÇÅ = x‚ÇÇ\n  ¬∑ simp only [hx, edist_self, zero_le]\n  rw [nnHolderNorm, eHolderNorm, coe_toNNReal]\n  on_goal 2 => exact hf.eHolderNorm_lt_top.ne\n  have h‚ÇÅ : edist x‚ÇÅ x‚ÇÇ ^ (r : ‚Ñù) ‚â† 0 :=\n    (Ne.symm <| ne_of_lt <| ENNReal.rpow_pos (edist_pos.2 hx) (edist_lt_top x‚ÇÅ x‚ÇÇ).ne)\n  have h‚ÇÇ : edist x‚ÇÅ x‚ÇÇ ^ (r : ‚Ñù) ‚â† ‚àû := by\n    simp [(edist_lt_top x‚ÇÅ x‚ÇÇ).ne]\n  rw [‚Üê ENNReal.div_le_iff h‚ÇÅ h‚ÇÇ]\n  refine le_iInf‚ÇÇ fun C hC => ?_\n  rw [ENNReal.div_le_iff h‚ÇÅ h‚ÇÇ]\n  exact hC x‚ÇÅ x‚ÇÇ\n\n"}
{"name":"memHolder_iff_holderWith","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : MetricSpace X\ninst‚úù : EMetricSpace Y\nr : NNReal\nf : X ‚Üí Y\n‚ä¢ Iff (MemHolder r f) (HolderWith (nnHolderNorm r f) r f)","decl":"lemma memHolder_iff_holderWith {r : ‚Ñù‚â•0} {f : X ‚Üí Y} :\n    MemHolder r f ‚Üî HolderWith (nnHolderNorm r f) r f :=\n  ‚ü®MemHolder.holderWith, HolderWith.memHolder‚ü©\n\n"}
{"name":"MemHolder.coe_nnHolderNorm_eq_eHolderNorm","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : MetricSpace X\ninst‚úù : EMetricSpace Y\nr : NNReal\nf : X ‚Üí Y\nhf : MemHolder r f\n‚ä¢ Eq (‚Üë(nnHolderNorm r f)) (eHolderNorm r f)","decl":"lemma MemHolder.coe_nnHolderNorm_eq_eHolderNorm\n    {r : ‚Ñù‚â•0} {f : X ‚Üí Y} (hf : MemHolder r f) :\n    (nnHolderNorm r f : ‚Ñù‚â•0‚àû) = eHolderNorm r f := by\n  rw [nnHolderNorm, coe_toNNReal]\n  exact ne_of_lt <| lt_of_le_of_lt hf.holderWith.eHolderNorm_le <| coe_lt_top\n\n"}
{"name":"HolderWith.nnholderNorm_le","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : MetricSpace X\ninst‚úù : EMetricSpace Y\nC r : NNReal\nf : X ‚Üí Y\nhf : HolderWith C r f\n‚ä¢ LE.le (nnHolderNorm r f) C","decl":"lemma HolderWith.nnholderNorm_le {C r : ‚Ñù‚â•0} {f : X ‚Üí Y} (hf : HolderWith C r f) :\n    nnHolderNorm r f ‚â§ C := by\n  rw [‚Üê ENNReal.coe_le_coe, hf.memHolder.coe_nnHolderNorm_eq_eHolderNorm]\n  exact hf.eHolderNorm_le\n\n"}
{"name":"MemHolder.comp","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : MetricSpace X\ninst‚úù¬π : EMetricSpace Y\nr s : NNReal\nZ : Type u_3\ninst‚úù : MetricSpace Z\nf : Z ‚Üí X\ng : X ‚Üí Y\nhf : MemHolder r f\nhg : MemHolder s g\n‚ä¢ MemHolder (HMul.hMul s r) (Function.comp g f)","decl":"lemma MemHolder.comp {r s : ‚Ñù‚â•0} {Z : Type*} [MetricSpace Z] {f : Z ‚Üí X} {g : X ‚Üí Y}\n    (hf : MemHolder r f) (hg : MemHolder s g) : MemHolder (s * r) (g ‚àò f) :=\n  (hg.holderWith.comp hf.holderWith).memHolder\n\n"}
{"name":"MemHolder.nnHolderNorm_eq_zero","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : MetricSpace X\ninst‚úù : EMetricSpace Y\nr : NNReal\nf : X ‚Üí Y\nhf : MemHolder r f\n‚ä¢ Iff (Eq (nnHolderNorm r f) 0) (‚àÄ (x‚ÇÅ x‚ÇÇ : X), Eq (f x‚ÇÅ) (f x‚ÇÇ))","decl":"lemma MemHolder.nnHolderNorm_eq_zero {r : ‚Ñù‚â•0} {f : X ‚Üí Y} (hf : MemHolder r f) :\n    nnHolderNorm r f = 0 ‚Üî ‚àÄ x‚ÇÅ x‚ÇÇ, f x‚ÇÅ = f x‚ÇÇ := by\n  rw [‚Üê ENNReal.coe_eq_zero, hf.coe_nnHolderNorm_eq_eHolderNorm, eHolderNorm_eq_zero]\n\n"}
{"name":"MemHolder.add","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : MetricSpace X\ninst‚úù : NormedAddCommGroup Y\nr : NNReal\nf g : X ‚Üí Y\nhf : MemHolder r f\nhg : MemHolder r g\n‚ä¢ MemHolder r (HAdd.hAdd f g)","decl":"lemma MemHolder.add (hf : MemHolder r f) (hg : MemHolder r g) : MemHolder r (f + g) :=\n  (hf.holderWith.add hg.holderWith).memHolder\n\n"}
{"name":"MemHolder.smul","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù‚Å¥ : MetricSpace X\ninst‚úù¬≥ : NormedAddCommGroup Y\nr : NNReal\nf : X ‚Üí Y\nùïú : Type u_3\ninst‚úù¬≤ : NormedDivisionRing ùïú\ninst‚úù¬π : Module ùïú Y\ninst‚úù : BoundedSMul ùïú Y\nc : ùïú\nhf : MemHolder r f\n‚ä¢ MemHolder r (HSMul.hSMul c f)","decl":"lemma MemHolder.smul {ùïú} [NormedDivisionRing ùïú] [Module ùïú Y] [BoundedSMul ùïú Y]\n    {c : ùïú} (hf : MemHolder r f) : MemHolder r (c ‚Ä¢ f) :=\n  (hf.holderWith.smul c).memHolder\n\n"}
{"name":"MemHolder.nsmul","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≥ : MetricSpace X\ninst‚úù¬≤ : NormedAddCommGroup Y\nr : NNReal\nf : X ‚Üí Y\ninst‚úù¬π : Module Real Y\ninst‚úù : BoundedSMul Real Y\nn : Nat\nhf : MemHolder r f\n‚ä¢ MemHolder r (HSMul.hSMul n f)","decl":"lemma MemHolder.nsmul [Module ‚Ñù Y] [BoundedSMul ‚Ñù Y] (n : ‚Ñï) (hf : MemHolder r f) :\n    MemHolder r (n ‚Ä¢ f) := by\n  simp [‚Üê Nat.cast_smul_eq_nsmul (R := ‚Ñù), hf.smul]\n\n"}
{"name":"MemHolder.nnHolderNorm_add_le","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : MetricSpace X\ninst‚úù : NormedAddCommGroup Y\nr : NNReal\nf g : X ‚Üí Y\nhf : MemHolder r f\nhg : MemHolder r g\n‚ä¢ LE.le (nnHolderNorm r (HAdd.hAdd f g)) (HAdd.hAdd (nnHolderNorm r f) (nnHolderNorm r g))","decl":"lemma MemHolder.nnHolderNorm_add_le (hf : MemHolder r f) (hg : MemHolder r g) :\n    nnHolderNorm r (f + g) ‚â§ nnHolderNorm r f + nnHolderNorm r g :=\n  (hf.add hg).holderWith.nnholderNorm_le.trans <|\n    coe_le_coe.2 (hf.holderWith.add hg.holderWith).nnholderNorm_le\n\n"}
{"name":"eHolderNorm_add_le","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : MetricSpace X\ninst‚úù : NormedAddCommGroup Y\nr : NNReal\nf g : X ‚Üí Y\n‚ä¢ LE.le (eHolderNorm r (HAdd.hAdd f g)) (HAdd.hAdd (eHolderNorm r f) (eHolderNorm r g))","decl":"lemma eHolderNorm_add_le :\n    eHolderNorm r (f + g) ‚â§ eHolderNorm r f + eHolderNorm r g := by\n  by_cases hfg : MemHolder r f  ‚àß MemHolder r g\n  ¬∑ obtain ‚ü®hf, hg‚ü© := hfg\n    rw [‚Üê hf.coe_nnHolderNorm_eq_eHolderNorm, ‚Üê hg.coe_nnHolderNorm_eq_eHolderNorm,\n      ‚Üê (hf.add hg).coe_nnHolderNorm_eq_eHolderNorm, ‚Üê coe_add, ENNReal.coe_le_coe]\n    exact hf.nnHolderNorm_add_le hg\n  ¬∑ rw [Classical.not_and_iff_or_not_not, ‚Üê eHolderNorm_eq_top, ‚Üê eHolderNorm_eq_top] at hfg\n    obtain (h | h) := hfg\n    all_goals simp [h]\n\n"}
{"name":"eHolderNorm_smul","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù‚Å¥ : MetricSpace X\ninst‚úù¬≥ : NormedAddCommGroup Y\nr : NNReal\nf : X ‚Üí Y\nŒ± : Type u_3\ninst‚úù¬≤ : NormedDivisionRing Œ±\ninst‚úù¬π : Module Œ± Y\ninst‚úù : BoundedSMul Œ± Y\nc : Œ±\n‚ä¢ Eq (eHolderNorm r (HSMul.hSMul c f)) (HMul.hMul (‚Üë(NNNorm.nnnorm c)) (eHolderNorm r f))","decl":"lemma eHolderNorm_smul {Œ±} [NormedDivisionRing Œ±] [Module Œ± Y] [BoundedSMul Œ± Y] (c : Œ±) :\n    eHolderNorm r (c ‚Ä¢ f) = ‚Äñc‚Äñ‚Çä * eHolderNorm r f := by\n  by_cases hc : ‚Äñc‚Äñ‚Çä = 0\n  ¬∑ rw [nnnorm_eq_zero] at hc\n    simp [hc]\n  by_cases hf : MemHolder r f\n  ¬∑ refine le_antisymm ((hf.holderWith.smul c).eHolderNorm_le.trans ?_) <| mul_le_of_le_div' ?_\n    ¬∑ rw [coe_mul, hf.coe_nnHolderNorm_eq_eHolderNorm, mul_comm]\n    ¬∑ rw [‚Üê (hf.holderWith.smul c).memHolder.coe_nnHolderNorm_eq_eHolderNorm, ‚Üê coe_div hc]\n      refine HolderWith.eHolderNorm_le fun x‚ÇÅ x‚ÇÇ => ?_\n      rw [coe_div hc, ‚Üê ENNReal.mul_div_right_comm,\n        ENNReal.le_div_iff_mul_le (Or.inl <| coe_ne_zero.2 hc) <| Or.inl coe_ne_top,\n        mul_comm, ‚Üê smul_eq_mul, ‚Üê ENNReal.smul_def, ‚Üê edist_smul‚ÇÄ, ‚Üê Pi.smul_apply,\n        ‚Üê Pi.smul_apply]\n      exact hf.smul.holderWith x‚ÇÅ x‚ÇÇ\n  ¬∑ rw [‚Üê eHolderNorm_eq_top] at hf\n    rw [hf, mul_top <| coe_ne_zero.2 hc, eHolderNorm_eq_top]\n    rw [nnnorm_eq_zero] at hc\n    intro h\n    have := h.smul (c := c‚Åª¬π)\n    rw [inv_smul_smul‚ÇÄ hc] at this\n    exact this.eHolderNorm_lt_top.ne hf\n\n"}
{"name":"MemHolder.nnHolderNorm_smul","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù‚Å¥ : MetricSpace X\ninst‚úù¬≥ : NormedAddCommGroup Y\nr : NNReal\nf : X ‚Üí Y\nŒ± : Type u_3\ninst‚úù¬≤ : NormedDivisionRing Œ±\ninst‚úù¬π : Module Œ± Y\ninst‚úù : BoundedSMul Œ± Y\nhf : MemHolder r f\nc : Œ±\n‚ä¢ Eq (nnHolderNorm r (HSMul.hSMul c f)) (HMul.hMul (NNNorm.nnnorm c) (nnHolderNorm r f))","decl":"lemma MemHolder.nnHolderNorm_smul {Œ±} [NormedDivisionRing Œ±] [Module Œ± Y] [BoundedSMul Œ± Y]\n    (hf : MemHolder r f) (c : Œ±) :\n    nnHolderNorm r (c ‚Ä¢ f) = ‚Äñc‚Äñ‚Çä * nnHolderNorm r f := by\n  rw [‚Üê ENNReal.coe_inj, coe_mul, hf.coe_nnHolderNorm_eq_eHolderNorm,\n    hf.smul.coe_nnHolderNorm_eq_eHolderNorm, eHolderNorm_smul]\n\n"}
{"name":"eHolderNorm_nsmul","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≥ : MetricSpace X\ninst‚úù¬≤ : NormedAddCommGroup Y\nr : NNReal\nf : X ‚Üí Y\ninst‚úù¬π : Module Real Y\ninst‚úù : BoundedSMul Real Y\nn : Nat\n‚ä¢ Eq (eHolderNorm r (HSMul.hSMul n f)) (HSMul.hSMul n (eHolderNorm r f))","decl":"lemma eHolderNorm_nsmul [Module ‚Ñù Y] [BoundedSMul ‚Ñù Y] (n : ‚Ñï) :\n    eHolderNorm r (n ‚Ä¢ f) = n ‚Ä¢ eHolderNorm r f := by\n  simp [‚Üê Nat.cast_smul_eq_nsmul (R := ‚Ñù), eHolderNorm_smul]\n\n"}
{"name":"MemHolder.nnHolderNorm_nsmul","module":"Mathlib.Topology.MetricSpace.HolderNorm","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≥ : MetricSpace X\ninst‚úù¬≤ : NormedAddCommGroup Y\nr : NNReal\nf : X ‚Üí Y\ninst‚úù¬π : Module Real Y\ninst‚úù : BoundedSMul Real Y\nn : Nat\nhf : MemHolder r f\n‚ä¢ Eq (nnHolderNorm r (HSMul.hSMul n f)) (HSMul.hSMul n (nnHolderNorm r f))","decl":"lemma MemHolder.nnHolderNorm_nsmul [Module ‚Ñù Y] [BoundedSMul ‚Ñù Y] (n : ‚Ñï) (hf : MemHolder r f) :\n    nnHolderNorm r (n ‚Ä¢ f) = n ‚Ä¢ nnHolderNorm r f := by\n  simp [‚Üê Nat.cast_smul_eq_nsmul (R := ‚Ñù), hf.nnHolderNorm_smul]\n\n"}
