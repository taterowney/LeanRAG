{"name":"map_dvd_iff","module":"Mathlib.Algebra.Ring.Divisibility.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Semigroup α\ninst✝² : Semigroup β\nF : Type u_3\ninst✝¹ : EquivLike F α β\ninst✝ : MulEquivClass F α β\nf : F\na b : α\n⊢ Iff (Dvd.dvd (f a) (f b)) (Dvd.dvd a b)","decl":"theorem map_dvd_iff (f : F) {a b} : f a ∣ f b ↔ a ∣ b :=\n  let f := MulEquivClass.toMulEquiv f\n  ⟨fun h ↦ by rw [← f.left_inv a, ← f.left_inv b]; exact map_dvd f.symm h, map_dvd f⟩\n\n"}
{"name":"MulEquiv.decompositionMonoid","module":"Mathlib.Algebra.Ring.Divisibility.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Semigroup α\ninst✝³ : Semigroup β\nF : Type u_3\ninst✝² : EquivLike F α β\ninst✝¹ : MulEquivClass F α β\nf : F\ninst✝ : DecompositionMonoid β\n⊢ DecompositionMonoid α","decl":"theorem MulEquiv.decompositionMonoid (f : F) [DecompositionMonoid β] : DecompositionMonoid α where\n  primal a b c h := by\n    rw [← map_dvd_iff f, map_mul] at h\n    obtain ⟨a₁, a₂, h⟩ := DecompositionMonoid.primal _ h\n    refine ⟨symm f a₁, symm f a₂, ?_⟩\n    simp_rw [← map_dvd_iff f, ← map_mul, eq_symm_apply]\n    iterate 2 erw [(f : α ≃* β).apply_symm_apply]\n    exact h\n\n"}
{"name":"dvd_add","module":"Mathlib.Algebra.Ring.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : Semigroup α\ninst✝ : LeftDistribClass α\na b c : α\nh₁ : Dvd.dvd a b\nh₂ : Dvd.dvd a c\n⊢ Dvd.dvd a (HAdd.hAdd b c)","decl":"theorem dvd_add [LeftDistribClass α] {a b c : α} (h₁ : a ∣ b) (h₂ : a ∣ c) : a ∣ b + c :=\n  Dvd.elim h₁ fun d hd => Dvd.elim h₂ fun e he => Dvd.intro (d + e) (by simp [left_distrib, hd, he])\n\n"}
{"name":"Dvd.dvd.add","module":"Mathlib.Algebra.Ring.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : Semigroup α\ninst✝ : LeftDistribClass α\na b c : α\nh₁ : Dvd.dvd a b\nh₂ : Dvd.dvd a c\n⊢ Dvd.dvd a (HAdd.hAdd b c)","decl":"alias Dvd.dvd.add := dvd_add\n\n"}
{"name":"min_pow_dvd_add","module":"Mathlib.Algebra.Ring.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : Semiring α\na b c : α\nm n : Nat\nha : Dvd.dvd (HPow.hPow c m) a\nhb : Dvd.dvd (HPow.hPow c n) b\n⊢ Dvd.dvd (HPow.hPow c (Min.min m n)) (HAdd.hAdd a b)","decl":"lemma min_pow_dvd_add (ha : c ^ m ∣ a) (hb : c ^ n ∣ b) : c ^ min m n ∣ a + b :=\n  ((pow_dvd_pow c (m.min_le_left n)).trans ha).add ((pow_dvd_pow c (m.min_le_right n)).trans hb)\n\n"}
{"name":"Dvd.dvd.linear_comb","module":"Mathlib.Algebra.Ring.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : NonUnitalCommSemiring α\nd x y : α\nhdx : Dvd.dvd d x\nhdy : Dvd.dvd d y\na b : α\n⊢ Dvd.dvd d (HAdd.hAdd (HMul.hMul a x) (HMul.hMul b y))","decl":"theorem Dvd.dvd.linear_comb {d x y : α} (hdx : d ∣ x) (hdy : d ∣ y) (a b : α) : d ∣ a * x + b * y :=\n  dvd_add (hdx.mul_left a) (hdy.mul_left b)\n\n"}
{"name":"dvd_neg","module":"Mathlib.Algebra.Ring.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Semigroup α\ninst✝ : HasDistribNeg α\na b : α\n⊢ Iff (Dvd.dvd a (Neg.neg b)) (Dvd.dvd a b)","decl":"/-- An element `a` of a semigroup with a distributive negation divides the negation of an element\n`b` iff `a` divides `b`. -/\n@[simp]\ntheorem dvd_neg : a ∣ -b ↔ a ∣ b :=\n  (Equiv.neg _).exists_congr_left.trans <| by\n    simp only [Equiv.neg_symm, Equiv.neg_apply, mul_neg, neg_inj, Dvd.dvd]\n\n"}
{"name":"neg_dvd","module":"Mathlib.Algebra.Ring.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Semigroup α\ninst✝ : HasDistribNeg α\na b : α\n⊢ Iff (Dvd.dvd (Neg.neg a) b) (Dvd.dvd a b)","decl":"/-- The negation of an element `a` of a semigroup with a distributive negation divides another\nelement `b` iff `a` divides `b`. -/\n@[simp]\ntheorem neg_dvd : -a ∣ b ↔ a ∣ b :=\n  (Equiv.neg _).exists_congr_left.trans <| by\n    simp only [Equiv.neg_symm, Equiv.neg_apply, mul_neg, neg_mul, neg_neg, Dvd.dvd]\n\n"}
{"name":"Dvd.dvd.of_neg_left","module":"Mathlib.Algebra.Ring.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Semigroup α\ninst✝ : HasDistribNeg α\na b : α\na✝ : Dvd.dvd (Neg.neg a) b\n⊢ Dvd.dvd a b","decl":"alias ⟨Dvd.dvd.of_neg_left, Dvd.dvd.neg_left⟩ := neg_dvd\n\n"}
{"name":"Dvd.dvd.neg_left","module":"Mathlib.Algebra.Ring.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Semigroup α\ninst✝ : HasDistribNeg α\na b : α\na✝ : Dvd.dvd a b\n⊢ Dvd.dvd (Neg.neg a) b","decl":"alias ⟨Dvd.dvd.of_neg_left, Dvd.dvd.neg_left⟩ := neg_dvd\n\n"}
{"name":"Dvd.dvd.of_neg_right","module":"Mathlib.Algebra.Ring.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Semigroup α\ninst✝ : HasDistribNeg α\na b : α\na✝ : Dvd.dvd a (Neg.neg b)\n⊢ Dvd.dvd a b","decl":"alias ⟨Dvd.dvd.of_neg_right, Dvd.dvd.neg_right⟩ := dvd_neg\n\n"}
{"name":"Dvd.dvd.neg_right","module":"Mathlib.Algebra.Ring.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Semigroup α\ninst✝ : HasDistribNeg α\na b : α\na✝ : Dvd.dvd a b\n⊢ Dvd.dvd a (Neg.neg b)","decl":"alias ⟨Dvd.dvd.of_neg_right, Dvd.dvd.neg_right⟩ := dvd_neg\n\n"}
{"name":"dvd_sub","module":"Mathlib.Algebra.Ring.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : NonUnitalRing α\na b c : α\nh₁ : Dvd.dvd a b\nh₂ : Dvd.dvd a c\n⊢ Dvd.dvd a (HSub.hSub b c)","decl":"theorem dvd_sub (h₁ : a ∣ b) (h₂ : a ∣ c) : a ∣ b - c := by\n  simpa only [← sub_eq_add_neg] using h₁.add h₂.neg_right\n\n"}
{"name":"Dvd.dvd.sub","module":"Mathlib.Algebra.Ring.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : NonUnitalRing α\na b c : α\nh₁ : Dvd.dvd a b\nh₂ : Dvd.dvd a c\n⊢ Dvd.dvd a (HSub.hSub b c)","decl":"alias Dvd.dvd.sub := dvd_sub\n\n"}
{"name":"dvd_add_left","module":"Mathlib.Algebra.Ring.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : NonUnitalRing α\na b c : α\nh : Dvd.dvd a c\n⊢ Iff (Dvd.dvd a (HAdd.hAdd b c)) (Dvd.dvd a b)","decl":"/-- If an element `a` divides another element `c` in a ring, `a` divides the sum of another element\n`b` with `c` iff `a` divides `b`. -/\ntheorem dvd_add_left (h : a ∣ c) : a ∣ b + c ↔ a ∣ b :=\n  ⟨fun H => by simpa only [add_sub_cancel_right] using dvd_sub H h, fun h₂ => dvd_add h₂ h⟩\n\n"}
{"name":"dvd_add_right","module":"Mathlib.Algebra.Ring.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : NonUnitalRing α\na b c : α\nh : Dvd.dvd a b\n⊢ Iff (Dvd.dvd a (HAdd.hAdd b c)) (Dvd.dvd a c)","decl":"/-- If an element `a` divides another element `b` in a ring, `a` divides the sum of `b` and another\nelement `c` iff `a` divides `c`. -/\ntheorem dvd_add_right (h : a ∣ b) : a ∣ b + c ↔ a ∣ c := by rw [add_comm]; exact dvd_add_left h\n\n"}
{"name":"dvd_sub_left","module":"Mathlib.Algebra.Ring.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : NonUnitalRing α\na b c : α\nh : Dvd.dvd a c\n⊢ Iff (Dvd.dvd a (HSub.hSub b c)) (Dvd.dvd a b)","decl":"/-- If an element `a` divides another element `c` in a ring, `a` divides the difference of another\nelement `b` with `c` iff `a` divides `b`. -/\ntheorem dvd_sub_left (h : a ∣ c) : a ∣ b - c ↔ a ∣ b := by\n  -- Porting note: Needed to give `α` explicitly\n  simpa only [← sub_eq_add_neg] using dvd_add_left ((dvd_neg (α := α)).2 h)\n\n"}
{"name":"dvd_sub_right","module":"Mathlib.Algebra.Ring.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : NonUnitalRing α\na b c : α\nh : Dvd.dvd a b\n⊢ Iff (Dvd.dvd a (HSub.hSub b c)) (Dvd.dvd a c)","decl":"/-- If an element `a` divides another element `b` in a ring, `a` divides the difference of `b` and\nanother element `c` iff `a` divides `c`. -/\ntheorem dvd_sub_right (h : a ∣ b) : a ∣ b - c ↔ a ∣ c := by\n  -- Porting note: Needed to give `α` explicitly\n  rw [sub_eq_add_neg, dvd_add_right h, dvd_neg (α := α)]\n\n"}
{"name":"dvd_iff_dvd_of_dvd_sub","module":"Mathlib.Algebra.Ring.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : NonUnitalRing α\na b c : α\nh : Dvd.dvd a (HSub.hSub b c)\n⊢ Iff (Dvd.dvd a b) (Dvd.dvd a c)","decl":"theorem dvd_iff_dvd_of_dvd_sub (h : a ∣ b - c) : a ∣ b ↔ a ∣ c := by\n  rw [← sub_add_cancel b c, dvd_add_right h]\n\n-- Porting note: Needed to give `α` explicitly\n"}
{"name":"dvd_sub_comm","module":"Mathlib.Algebra.Ring.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : NonUnitalRing α\na b c : α\n⊢ Iff (Dvd.dvd a (HSub.hSub b c)) (Dvd.dvd a (HSub.hSub c b))","decl":"theorem dvd_sub_comm : a ∣ b - c ↔ a ∣ c - b := by rw [← dvd_neg (α := α), neg_sub]\n\n"}
{"name":"dvd_add_self_left","module":"Mathlib.Algebra.Ring.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : Ring α\na b : α\n⊢ Iff (Dvd.dvd a (HAdd.hAdd a b)) (Dvd.dvd a b)","decl":"/-- An element a divides the sum a + b if and only if a divides b. -/\n@[simp]\ntheorem dvd_add_self_left {a b : α} : a ∣ a + b ↔ a ∣ b :=\n  dvd_add_right (dvd_refl a)\n\n"}
{"name":"dvd_add_self_right","module":"Mathlib.Algebra.Ring.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : Ring α\na b : α\n⊢ Iff (Dvd.dvd a (HAdd.hAdd b a)) (Dvd.dvd a b)","decl":"/-- An element a divides the sum b + a if and only if a divides b. -/\n@[simp]\ntheorem dvd_add_self_right {a b : α} : a ∣ b + a ↔ a ∣ b :=\n  dvd_add_left (dvd_refl a)\n\n"}
{"name":"dvd_sub_self_left","module":"Mathlib.Algebra.Ring.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : Ring α\na b : α\n⊢ Iff (Dvd.dvd a (HSub.hSub a b)) (Dvd.dvd a b)","decl":"/-- An element `a` divides the difference `a - b` if and only if `a` divides `b`. -/\n@[simp]\ntheorem dvd_sub_self_left : a ∣ a - b ↔ a ∣ b :=\n  dvd_sub_right dvd_rfl\n\n"}
{"name":"dvd_sub_self_right","module":"Mathlib.Algebra.Ring.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : Ring α\na b : α\n⊢ Iff (Dvd.dvd a (HSub.hSub b a)) (Dvd.dvd a b)","decl":"/-- An element `a` divides the difference `b - a` if and only if `a` divides `b`. -/\n@[simp]\ntheorem dvd_sub_self_right : a ∣ b - a ↔ a ∣ b :=\n  dvd_sub_left dvd_rfl\n\n"}
{"name":"dvd_mul_sub_mul","module":"Mathlib.Algebra.Ring.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : NonUnitalCommRing α\nk a b x y : α\nhab : Dvd.dvd k (HSub.hSub a b)\nhxy : Dvd.dvd k (HSub.hSub x y)\n⊢ Dvd.dvd k (HSub.hSub (HMul.hMul a x) (HMul.hMul b y))","decl":"theorem dvd_mul_sub_mul {k a b x y : α} (hab : k ∣ a - b) (hxy : k ∣ x - y) :\n    k ∣ a * x - b * y := by\n  convert dvd_add (hxy.mul_left a) (hab.mul_right y) using 1\n  rw [mul_sub_left_distrib, mul_sub_right_distrib]\n  simp only [sub_eq_add_neg, add_assoc, neg_add_cancel_left]\n\n"}
