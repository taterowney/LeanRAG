{"name":"Computability.Encoding.mk.sizeOf_spec","module":"Mathlib.Computability.Encoding","initialProofState":"α : Type u\ninst✝ : SizeOf α\nΓ : Type v\nencode : α → List Γ\ndecode : List Γ → Option α\ndecode_encode : ∀ (x : α), Eq (decode (encode x)) (Option.some x)\n⊢ Eq (SizeOf.sizeOf { Γ := Γ, encode := encode, decode := decode, decode_encode := decode_encode }) (HAdd.hAdd 1 (SizeOf.sizeOf Γ))","decl":"/-- An encoding of a type in a certain alphabet, together with a decoding. -/\nstructure Encoding (α : Type u) where\n  Γ : Type v\n  encode : α → List Γ\n  decode : List Γ → Option α\n  decode_encode : ∀ x, decode (encode x) = some x\n\n"}
{"name":"Computability.Encoding.decode_encode","module":"Mathlib.Computability.Encoding","initialProofState":"α : Type u\nself : Computability.Encoding α\nx : α\n⊢ Eq (self.decode (self.encode x)) (Option.some x)","decl":"/-- An encoding of a type in a certain alphabet, together with a decoding. -/\nstructure Encoding (α : Type u) where\n  Γ : Type v\n  encode : α → List Γ\n  decode : List Γ → Option α\n  decode_encode : ∀ x, decode (encode x) = some x\n\n"}
{"name":"Computability.Encoding.mk.injEq","module":"Mathlib.Computability.Encoding","initialProofState":"α : Type u\nΓ✝ : Type v\nencode✝ : α → List Γ✝\ndecode✝ : List Γ✝ → Option α\ndecode_encode✝ : ∀ (x : α), Eq (decode✝ (encode✝ x)) (Option.some x)\nΓ : Type v\nencode : α → List Γ\ndecode : List Γ → Option α\ndecode_encode : ∀ (x : α), Eq (decode (encode x)) (Option.some x)\n⊢ Eq (Eq { Γ := Γ✝, encode := encode✝, decode := decode✝, decode_encode := decode_encode✝ } { Γ := Γ, encode := encode, decode := decode, decode_encode := decode_encode }) (And (Eq Γ✝ Γ) (And (HEq encode✝ encode) (HEq decode✝ decode)))","decl":"/-- An encoding of a type in a certain alphabet, together with a decoding. -/\nstructure Encoding (α : Type u) where\n  Γ : Type v\n  encode : α → List Γ\n  decode : List Γ → Option α\n  decode_encode : ∀ x, decode (encode x) = some x\n\n"}
{"name":"Computability.Encoding.mk.inj","module":"Mathlib.Computability.Encoding","initialProofState":"α : Type u\nΓ✝ : Type v\nencode✝ : α → List Γ✝\ndecode✝ : List Γ✝ → Option α\ndecode_encode✝ : ∀ (x : α), Eq (decode✝ (encode✝ x)) (Option.some x)\nΓ : Type v\nencode : α → List Γ\ndecode : List Γ → Option α\ndecode_encode : ∀ (x : α), Eq (decode (encode x)) (Option.some x)\nx✝ : Eq { Γ := Γ✝, encode := encode✝, decode := decode✝, decode_encode := decode_encode✝ } { Γ := Γ, encode := encode, decode := decode, decode_encode := decode_encode }\n⊢ And (Eq Γ✝ Γ) (And (HEq encode✝ encode) (HEq decode✝ decode))","decl":"/-- An encoding of a type in a certain alphabet, together with a decoding. -/\nstructure Encoding (α : Type u) where\n  Γ : Type v\n  encode : α → List Γ\n  decode : List Γ → Option α\n  decode_encode : ∀ x, decode (encode x) = some x\n\n"}
{"name":"Computability.Encoding.encode_injective","module":"Mathlib.Computability.Encoding","initialProofState":"α : Type u\ne : Computability.Encoding α\n⊢ Function.Injective e.encode","decl":"theorem Encoding.encode_injective {α : Type u} (e : Encoding α) : Function.Injective e.encode := by\n  refine fun _ _ h => Option.some_injective _ ?_\n  rw [← e.decode_encode, ← e.decode_encode, h]\n\n"}
{"name":"Computability.FinEncoding.mk.injEq","module":"Mathlib.Computability.Encoding","initialProofState":"α : Type u\ntoEncoding✝ : Computability.Encoding α\nΓFin✝ : Fintype toEncoding✝.Γ\ntoEncoding : Computability.Encoding α\nΓFin : Fintype toEncoding.Γ\n⊢ Eq (Eq { toEncoding := toEncoding✝, ΓFin := ΓFin✝ } { toEncoding := toEncoding, ΓFin := ΓFin }) (And (Eq toEncoding✝ toEncoding) (HEq ΓFin✝ ΓFin))","decl":"/-- An encoding plus a guarantee of finiteness of the alphabet. -/\nstructure FinEncoding (α : Type u) extends Encoding.{u, 0} α where\n  ΓFin : Fintype Γ\n\n"}
{"name":"Computability.FinEncoding.mk.sizeOf_spec","module":"Mathlib.Computability.Encoding","initialProofState":"α : Type u\ninst✝ : SizeOf α\ntoEncoding : Computability.Encoding α\nΓFin : Fintype toEncoding.Γ\n⊢ Eq (SizeOf.sizeOf { toEncoding := toEncoding, ΓFin := ΓFin }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toEncoding)) (SizeOf.sizeOf ΓFin))","decl":"/-- An encoding plus a guarantee of finiteness of the alphabet. -/\nstructure FinEncoding (α : Type u) extends Encoding.{u, 0} α where\n  ΓFin : Fintype Γ\n\n"}
{"name":"Computability.FinEncoding.mk.inj","module":"Mathlib.Computability.Encoding","initialProofState":"α : Type u\ntoEncoding✝ : Computability.Encoding α\nΓFin✝ : Fintype toEncoding✝.Γ\ntoEncoding : Computability.Encoding α\nΓFin : Fintype toEncoding.Γ\nx✝ : Eq { toEncoding := toEncoding✝, ΓFin := ΓFin✝ } { toEncoding := toEncoding, ΓFin := ΓFin }\n⊢ And (Eq toEncoding✝ toEncoding) (HEq ΓFin✝ ΓFin)","decl":"/-- An encoding plus a guarantee of finiteness of the alphabet. -/\nstructure FinEncoding (α : Type u) extends Encoding.{u, 0} α where\n  ΓFin : Fintype Γ\n\n"}
{"name":"Computability.Γ'.bit.sizeOf_spec","module":"Mathlib.Computability.Encoding","initialProofState":"b : Bool\n⊢ Eq (SizeOf.sizeOf (Computability.Γ'.bit b)) (HAdd.hAdd 1 (SizeOf.sizeOf b))","decl":"/-- A standard Turing machine alphabet, consisting of blank,bit0,bit1,bra,ket,comma. -/\ninductive Γ'\n  | blank\n  | bit (b : Bool)\n  | bra\n  | ket\n  | comma\n  deriving DecidableEq, Fintype\n\n"}
{"name":"Computability.Γ'.blank.sizeOf_spec","module":"Mathlib.Computability.Encoding","initialProofState":"⊢ Eq (SizeOf.sizeOf Computability.Γ'.blank) 1","decl":"/-- A standard Turing machine alphabet, consisting of blank,bit0,bit1,bra,ket,comma. -/\ninductive Γ'\n  | blank\n  | bit (b : Bool)\n  | bra\n  | ket\n  | comma\n  deriving DecidableEq, Fintype\n\n"}
{"name":"Computability.Γ'.ket.sizeOf_spec","module":"Mathlib.Computability.Encoding","initialProofState":"⊢ Eq (SizeOf.sizeOf Computability.Γ'.ket) 1","decl":"/-- A standard Turing machine alphabet, consisting of blank,bit0,bit1,bra,ket,comma. -/\ninductive Γ'\n  | blank\n  | bit (b : Bool)\n  | bra\n  | ket\n  | comma\n  deriving DecidableEq, Fintype\n\n"}
{"name":"Computability.Γ'.bit.inj","module":"Mathlib.Computability.Encoding","initialProofState":"b✝ b : Bool\nx✝ : Eq (Computability.Γ'.bit b✝) (Computability.Γ'.bit b)\n⊢ Eq b✝ b","decl":"/-- A standard Turing machine alphabet, consisting of blank,bit0,bit1,bra,ket,comma. -/\ninductive Γ'\n  | blank\n  | bit (b : Bool)\n  | bra\n  | ket\n  | comma\n  deriving DecidableEq, Fintype\n\n"}
{"name":"Computability.Γ'.bit.injEq","module":"Mathlib.Computability.Encoding","initialProofState":"b✝ b : Bool\n⊢ Eq (Eq (Computability.Γ'.bit b✝) (Computability.Γ'.bit b)) (Eq b✝ b)","decl":"/-- A standard Turing machine alphabet, consisting of blank,bit0,bit1,bra,ket,comma. -/\ninductive Γ'\n  | blank\n  | bit (b : Bool)\n  | bra\n  | ket\n  | comma\n  deriving DecidableEq, Fintype\n\n"}
{"name":"Computability.Γ'.comma.sizeOf_spec","module":"Mathlib.Computability.Encoding","initialProofState":"⊢ Eq (SizeOf.sizeOf Computability.Γ'.comma) 1","decl":"/-- A standard Turing machine alphabet, consisting of blank,bit0,bit1,bra,ket,comma. -/\ninductive Γ'\n  | blank\n  | bit (b : Bool)\n  | bra\n  | ket\n  | comma\n  deriving DecidableEq, Fintype\n\n"}
{"name":"Computability.Γ'.bra.sizeOf_spec","module":"Mathlib.Computability.Encoding","initialProofState":"⊢ Eq (SizeOf.sizeOf Computability.Γ'.bra) 1","decl":"/-- A standard Turing machine alphabet, consisting of blank,bit0,bit1,bra,ket,comma. -/\ninductive Γ'\n  | blank\n  | bit (b : Bool)\n  | bra\n  | ket\n  | comma\n  deriving DecidableEq, Fintype\n\n"}
{"name":"Computability.sectionΓ'Bool_inclusionBoolΓ'","module":"Mathlib.Computability.Encoding","initialProofState":"b : Bool\n⊢ Eq (Computability.sectionΓ'Bool (Computability.inclusionBoolΓ' b)) b","decl":"@[simp]\ntheorem sectionΓ'Bool_inclusionBoolΓ' {b} : sectionΓ'Bool (inclusionBoolΓ' b) = b := by\n  cases b <;> rfl\n\n"}
{"name":"Computability.leftInverse_section_inclusion","module":"Mathlib.Computability.Encoding","initialProofState":"⊢ Function.LeftInverse Computability.sectionΓ'Bool Computability.inclusionBoolΓ'","decl":"@[deprecated sectionΓ'Bool_inclusionBoolΓ' (since := \"2025-01-21\")]\ntheorem leftInverse_section_inclusion : Function.LeftInverse sectionΓ'Bool inclusionBoolΓ' :=\n  fun x => Bool.casesOn x rfl rfl\n\n"}
{"name":"Computability.inclusionBoolΓ'_injective","module":"Mathlib.Computability.Encoding","initialProofState":"⊢ Function.Injective Computability.inclusionBoolΓ'","decl":"theorem inclusionBoolΓ'_injective : Function.Injective inclusionBoolΓ' :=\n  Function.HasLeftInverse.injective ⟨_, (fun _ => sectionΓ'Bool_inclusionBoolΓ')⟩\n\n"}
{"name":"Computability.encodePosNum_nonempty","module":"Mathlib.Computability.Encoding","initialProofState":"n : PosNum\n⊢ Ne (Computability.encodePosNum n) List.nil","decl":"theorem encodePosNum_nonempty (n : PosNum) : encodePosNum n ≠ [] :=\n  PosNum.casesOn n (List.cons_ne_nil _ _) (fun _m => List.cons_ne_nil _ _) fun _m =>\n    List.cons_ne_nil _ _\n\n"}
{"name":"Computability.decode_encodePosNum","module":"Mathlib.Computability.Encoding","initialProofState":"n : PosNum\n⊢ Eq (Computability.decodePosNum (Computability.encodePosNum n)) n","decl":"@[simp] theorem decode_encodePosNum : ∀ n, decodePosNum (encodePosNum n) = n := by\n  intro n\n  induction' n with m hm m hm <;> unfold encodePosNum decodePosNum\n  · rfl\n  · rw [hm]\n    exact if_neg (encodePosNum_nonempty m)\n  · exact congr_arg PosNum.bit0 hm\n\n"}
{"name":"Computability.decode_encodeNum","module":"Mathlib.Computability.Encoding","initialProofState":"n : Num\n⊢ Eq (Computability.decodeNum (Computability.encodeNum n)) n","decl":"@[simp] theorem decode_encodeNum : ∀ n, decodeNum (encodeNum n) = n := by\n  intro n\n  cases' n with n <;> unfold encodeNum decodeNum\n  · rfl\n  rw [decode_encodePosNum n]\n  rw [PosNum.cast_to_num]\n  exact if_neg (encodePosNum_nonempty n)\n\n"}
{"name":"Computability.decode_encodeNat","module":"Mathlib.Computability.Encoding","initialProofState":"n : Nat\n⊢ Eq (Computability.decodeNat (Computability.encodeNat n)) n","decl":"@[simp] theorem decode_encodeNat : ∀ n, decodeNat (encodeNat n) = n := by\n  intro n\n  conv_rhs => rw [← Num.to_of_nat n]\n  exact congr_arg ((↑) : Num → ℕ) (decode_encodeNum n)\n\n"}
{"name":"Computability.unary_decode_encode_nat","module":"Mathlib.Computability.Encoding","initialProofState":"n : Nat\n⊢ Eq (Computability.unaryDecodeNat (Computability.unaryEncodeNat n)) n","decl":"@[simp] theorem unary_decode_encode_nat : ∀ n, unaryDecodeNat (unaryEncodeNat n) = n := fun n =>\n  Nat.rec rfl (fun (_m : ℕ) hm => (congr_arg Nat.succ hm.symm).symm) n\n\n"}
{"name":"Computability.decode_encodeBool","module":"Mathlib.Computability.Encoding","initialProofState":"b : Bool\n⊢ Eq (Computability.decodeBool (Computability.encodeBool b)) b","decl":"@[simp] theorem decode_encodeBool (b : Bool) : decodeBool (encodeBool b) = b := rfl\n\n"}
{"name":"Computability.Encoding.card_le_card_list","module":"Mathlib.Computability.Encoding","initialProofState":"α : Type u\ne : Computability.Encoding α\n⊢ LE.le (Cardinal.lift.{v, u} (Cardinal.mk α)) (Cardinal.lift.{u, v} (Cardinal.mk (List e.Γ)))","decl":"theorem Encoding.card_le_card_list {α : Type u} (e : Encoding.{u, v} α) :\n    Cardinal.lift.{v} #α ≤ Cardinal.lift.{u} #(List e.Γ) :=\n  Cardinal.lift_mk_le'.2 ⟨⟨e.encode, e.encode_injective⟩⟩\n\n"}
{"name":"Computability.Encoding.card_le_aleph0","module":"Mathlib.Computability.Encoding","initialProofState":"α : Type u\ne : Computability.Encoding α\ninst✝ : Countable e.Γ\n⊢ LE.le (Cardinal.mk α) Cardinal.aleph0","decl":"theorem Encoding.card_le_aleph0 {α : Type u} (e : Encoding.{u, v} α) [Countable e.Γ] :\n    #α ≤ ℵ₀ :=\n  haveI : Countable α := e.encode_injective.countable\n  Cardinal.mk_le_aleph0\n\n"}
{"name":"Computability.FinEncoding.card_le_aleph0","module":"Mathlib.Computability.Encoding","initialProofState":"α : Type u\ne : Computability.FinEncoding α\n⊢ LE.le (Cardinal.mk α) Cardinal.aleph0","decl":"theorem FinEncoding.card_le_aleph0 {α : Type u} (e : FinEncoding α) : #α ≤ ℵ₀ :=\n  e.toEncoding.card_le_aleph0\n\n"}
