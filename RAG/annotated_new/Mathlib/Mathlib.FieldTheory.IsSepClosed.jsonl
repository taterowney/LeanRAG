{"name":"IsSepClosed.splits_of_separable","module":"Mathlib.FieldTheory.IsSepClosed","initialProofState":"k : Type u\ninst✝ : Field k\nself : IsSepClosed k\np : Polynomial k\na✝ : p.Separable\n⊢ Polynomial.Splits (RingHom.id k) p","decl":"/-- Typeclass for separably closed fields.\n\nTo show `Polynomial.Splits p f` for an arbitrary ring homomorphism `f`,\nsee `IsSepClosed.splits_codomain` and `IsSepClosed.splits_domain`.\n-/\nclass IsSepClosed : Prop where\n  splits_of_separable : ∀ p : k[X], p.Separable → (p.Splits <| RingHom.id k)\n\n"}
{"name":"IsSepClosed.of_isAlgClosed","module":"Mathlib.FieldTheory.IsSepClosed","initialProofState":"k : Type u\ninst✝¹ : Field k\ninst✝ : IsAlgClosed k\n⊢ IsSepClosed k","decl":"/-- An algebraically closed field is also separably closed. -/\ninstance IsSepClosed.of_isAlgClosed [IsAlgClosed k] : IsSepClosed k :=\n  ⟨fun p _ ↦ IsAlgClosed.splits p⟩\n\n"}
{"name":"IsSepClosed.splits_codomain","module":"Mathlib.FieldTheory.IsSepClosed","initialProofState":"k : Type u\ninst✝² : Field k\nK : Type v\ninst✝¹ : Field K\ninst✝ : IsSepClosed K\nf : RingHom k K\np : Polynomial k\nh : p.Separable\n⊢ Polynomial.Splits f p","decl":"/-- Every separable polynomial splits in the field extension `f : k →+* K` if `K` is\nseparably closed.\n\nSee also `IsSepClosed.splits_domain` for the case where `k` is separably closed.\n-/\ntheorem IsSepClosed.splits_codomain [IsSepClosed K] {f : k →+* K}\n    (p : k[X]) (h : p.Separable) : p.Splits f := by\n  convert IsSepClosed.splits_of_separable (p.map f) (Separable.map h); simp [splits_map_iff]\n\n"}
{"name":"IsSepClosed.splits_domain","module":"Mathlib.FieldTheory.IsSepClosed","initialProofState":"k : Type u\ninst✝² : Field k\nK : Type v\ninst✝¹ : Field K\ninst✝ : IsSepClosed k\nf : RingHom k K\np : Polynomial k\nh : p.Separable\n⊢ Polynomial.Splits f p","decl":"/-- Every separable polynomial splits in the field extension `f : k →+* K` if `k` is\nseparably closed.\n\nSee also `IsSepClosed.splits_codomain` for the case where `k` is separably closed.\n-/\ntheorem IsSepClosed.splits_domain [IsSepClosed k] {f : k →+* K}\n    (p : k[X]) (h : p.Separable) : p.Splits f :=\n  Polynomial.splits_of_splits_id _ <| IsSepClosed.splits_of_separable _ h\n\n"}
{"name":"IsSepClosed.exists_root","module":"Mathlib.FieldTheory.IsSepClosed","initialProofState":"k : Type u\ninst✝¹ : Field k\ninst✝ : IsSepClosed k\np : Polynomial k\nhp : Ne p.degree 0\nhsep : p.Separable\n⊢ Exists fun x => p.IsRoot x","decl":"theorem exists_root [IsSepClosed k] (p : k[X]) (hp : p.degree ≠ 0) (hsep : p.Separable) :\n    ∃ x, IsRoot p x :=\n  exists_root_of_splits _ (IsSepClosed.splits_of_separable p hsep) hp\n\n"}
{"name":"IsSepClosed.exists_root_C_mul_X_pow_add_C_mul_X_add_C","module":"Mathlib.FieldTheory.IsSepClosed","initialProofState":"k : Type u\ninst✝¹ : Field k\ninst✝ : IsSepClosed k\nn : Nat\na b c : k\nhn : Eq (↑n) 0\nhn' : LE.le 2 n\nhb : Ne b 0\n⊢ Exists fun x => Eq (HAdd.hAdd (HAdd.hAdd (HMul.hMul a (HPow.hPow x n)) (HMul.hMul b x)) c) 0","decl":"/-- If `n ≥ 2` equals zero in a separably closed field `k`, `b ≠ 0`,\nthen there exists `x` in `k` such that `a * x ^ n + b * x + c = 0`. -/\ntheorem exists_root_C_mul_X_pow_add_C_mul_X_add_C\n    [IsSepClosed k] {n : ℕ} (a b c : k) (hn : (n : k) = 0) (hn' : 2 ≤ n) (hb : b ≠ 0) :\n    ∃ x, a * x ^ n + b * x + c = 0 := by\n  let f : k[X] := C a * X ^ n + C b * X + C c\n  have hdeg : f.degree ≠ 0 := degree_ne_of_natDegree_ne <| by\n    by_cases ha : a = 0\n    · suffices f.natDegree = 1 from this ▸ one_ne_zero\n      simp_rw [f, ha, map_zero, zero_mul, zero_add]\n      compute_degree!\n    · suffices f.natDegree = n from this ▸ (lt_of_lt_of_le zero_lt_two hn').ne'\n      simp_rw [f]\n      have h0 : n ≠ 0 := by linarith only [hn']\n      have h1 : n ≠ 1 := by linarith only [hn']\n      have : 1 ≤ n := le_trans one_le_two hn'\n      compute_degree!\n      simp [h0, h1, ha]\n  have hsep : f.Separable := separable_C_mul_X_pow_add_C_mul_X_add_C a b c hn hb.isUnit\n  obtain ⟨x, hx⟩ := exists_root f hdeg hsep\n  exact ⟨x, by simpa [f] using hx⟩\n\n"}
{"name":"IsSepClosed.exists_root_C_mul_X_pow_add_C_mul_X_add_C'","module":"Mathlib.FieldTheory.IsSepClosed","initialProofState":"k : Type u\ninst✝² : Field k\ninst✝¹ : IsSepClosed k\np n : Nat\na b c : k\ninst✝ : CharP k p\nhn : Dvd.dvd p n\nhn' : LE.le 2 n\nhb : Ne b 0\n⊢ Exists fun x => Eq (HAdd.hAdd (HAdd.hAdd (HMul.hMul a (HPow.hPow x n)) (HMul.hMul b x)) c) 0","decl":"/-- If a separably closed field `k` is of characteristic `p`, `n ≥ 2` is such that `p ∣ n`, `b ≠ 0`,\nthen there exists `x` in `k` such that `a * x ^ n + b * x + c = 0`. -/\ntheorem exists_root_C_mul_X_pow_add_C_mul_X_add_C'\n    [IsSepClosed k] (p n : ℕ) (a b c : k) [CharP k p] (hn : p ∣ n) (hn' : 2 ≤ n) (hb : b ≠ 0) :\n    ∃ x, a * x ^ n + b * x + c = 0 :=\n  exists_root_C_mul_X_pow_add_C_mul_X_add_C a b c ((CharP.cast_eq_zero_iff k p n).2 hn) hn' hb\n\n"}
{"name":"IsSepClosed.isAlgClosed_of_perfectField","module":"Mathlib.FieldTheory.IsSepClosed","initialProofState":"k : Type u\ninst✝² : Field k\ninst✝¹ : IsSepClosed k\ninst✝ : PerfectField k\n⊢ IsAlgClosed k","decl":"variable (k) in\n/-- A separably closed perfect field is also algebraically closed. -/\ninstance (priority := 100) isAlgClosed_of_perfectField [IsSepClosed k] [PerfectField k] :\n    IsAlgClosed k :=\n  IsAlgClosed.of_exists_root k fun p _ h ↦ exists_root p ((degree_pos_of_irreducible h).ne')\n    (PerfectField.separable_of_irreducible h)\n\n"}
{"name":"IsSepClosed.exists_pow_nat_eq","module":"Mathlib.FieldTheory.IsSepClosed","initialProofState":"k : Type u\ninst✝¹ : Field k\ninst✝ : IsSepClosed k\nx : k\nn : Nat\nhn : NeZero ↑n\n⊢ Exists fun z => Eq (HPow.hPow z n) x","decl":"theorem exists_pow_nat_eq [IsSepClosed k] (x : k) (n : ℕ) [hn : NeZero (n : k)] :\n    ∃ z, z ^ n = x := by\n  have hn' : 0 < n := Nat.pos_of_ne_zero fun h => by\n    rw [h, Nat.cast_zero] at hn\n    exact hn.out rfl\n  have : degree (X ^ n - C x) ≠ 0 := by\n    rw [degree_X_pow_sub_C hn' x]\n    exact (WithBot.coe_lt_coe.2 hn').ne'\n  by_cases hx : x = 0\n  · exact ⟨0, by rw [hx, pow_eq_zero_iff hn'.ne']⟩\n  · obtain ⟨z, hz⟩ := exists_root _ this <| separable_X_pow_sub_C x hn.out hx\n    use z\n    simpa [eval_C, eval_X, eval_pow, eval_sub, IsRoot.def, sub_eq_zero] using hz\n\n"}
{"name":"IsSepClosed.exists_eq_mul_self","module":"Mathlib.FieldTheory.IsSepClosed","initialProofState":"k : Type u\ninst✝¹ : Field k\ninst✝ : IsSepClosed k\nx : k\nh2 : NeZero 2\n⊢ Exists fun z => Eq x (HMul.hMul z z)","decl":"theorem exists_eq_mul_self [IsSepClosed k] (x : k) [h2 : NeZero (2 : k)] : ∃ z, x = z * z := by\n  rcases exists_pow_nat_eq x 2 with ⟨z, rfl⟩\n  exact ⟨z, sq z⟩\n\n"}
{"name":"IsSepClosed.roots_eq_zero_iff","module":"Mathlib.FieldTheory.IsSepClosed","initialProofState":"k : Type u\ninst✝¹ : Field k\ninst✝ : IsSepClosed k\np : Polynomial k\nhsep : p.Separable\n⊢ Iff (Eq p.roots 0) (Eq p (Polynomial.C (p.coeff 0)))","decl":"theorem roots_eq_zero_iff [IsSepClosed k] {p : k[X]} (hsep : p.Separable) :\n    p.roots = 0 ↔ p = Polynomial.C (p.coeff 0) := by\n  refine ⟨fun h => ?_, fun hp => by rw [hp, roots_C]⟩\n  rcases le_or_lt (degree p) 0 with hd | hd\n  · exact eq_C_of_degree_le_zero hd\n  · obtain ⟨z, hz⟩ := IsSepClosed.exists_root p hd.ne' hsep\n    rw [← mem_roots (ne_zero_of_degree_gt hd), h] at hz\n    simp at hz\n\n"}
{"name":"IsSepClosed.exists_eval₂_eq_zero","module":"Mathlib.FieldTheory.IsSepClosed","initialProofState":"k : Type u\ninst✝² : Field k\nK : Type v\ninst✝¹ : Field K\ninst✝ : IsSepClosed K\nf : RingHom k K\np : Polynomial k\nhp : Ne p.degree 0\nhsep : p.Separable\n⊢ Exists fun x => Eq (Polynomial.eval₂ f x p) 0","decl":"theorem exists_eval₂_eq_zero [IsSepClosed K] (f : k →+* K)\n    (p : k[X]) (hp : p.degree ≠ 0) (hsep : p.Separable) :\n    ∃ x, p.eval₂ f x = 0 :=\n  let ⟨x, hx⟩ := exists_root (p.map f) (by rwa [degree_map_eq_of_injective f.injective])\n    (Separable.map hsep)\n  ⟨x, by rwa [eval₂_eq_eval_map, ← IsRoot]⟩\n\n"}
{"name":"IsSepClosed.exists_aeval_eq_zero","module":"Mathlib.FieldTheory.IsSepClosed","initialProofState":"k : Type u\ninst✝³ : Field k\nK : Type v\ninst✝² : Field K\ninst✝¹ : IsSepClosed K\ninst✝ : Algebra k K\np : Polynomial k\nhp : Ne p.degree 0\nhsep : p.Separable\n⊢ Exists fun x => Eq ((Polynomial.aeval x) p) 0","decl":"theorem exists_aeval_eq_zero [IsSepClosed K] [Algebra k K] (p : k[X])\n    (hp : p.degree ≠ 0) (hsep : p.Separable) : ∃ x : K, aeval x p = 0 :=\n  exists_eval₂_eq_zero (algebraMap k K) p hp hsep\n\n"}
{"name":"IsSepClosed.of_exists_root","module":"Mathlib.FieldTheory.IsSepClosed","initialProofState":"k : Type u\ninst✝ : Field k\nH : ∀ (p : Polynomial k), p.Monic → Irreducible p → p.Separable → Exists fun x => Eq (Polynomial.eval x p) 0\n⊢ IsSepClosed k","decl":"theorem of_exists_root (H : ∀ p : k[X], p.Monic → Irreducible p → Separable p → ∃ x, p.eval x = 0) :\n    IsSepClosed k := by\n  refine ⟨fun p hsep ↦ Or.inr ?_⟩\n  intro q hq hdvd\n  simp only [map_id] at hdvd\n  have hlc : IsUnit (leadingCoeff q)⁻¹ := IsUnit.inv <| Ne.isUnit <|\n    leadingCoeff_ne_zero.2 <| Irreducible.ne_zero hq\n  have hsep' : Separable (q * C (leadingCoeff q)⁻¹) :=\n    Separable.mul (Separable.of_dvd hsep hdvd) ((separable_C _).2 hlc)\n    (by simpa only [← isCoprime_mul_unit_right_right (isUnit_C.2 hlc) q 1, one_mul]\n      using isCoprime_one_right (x := q))\n  have hirr' := hq\n  rw [← irreducible_mul_isUnit (isUnit_C.2 hlc)] at hirr'\n  obtain ⟨x, hx⟩ := H (q * C (leadingCoeff q)⁻¹) (monic_mul_leadingCoeff_inv hq.ne_zero) hirr' hsep'\n  exact degree_mul_leadingCoeff_inv q hq.ne_zero ▸ degree_eq_one_of_irreducible_of_root hirr' hx\n\n"}
{"name":"IsSepClosed.degree_eq_one_of_irreducible","module":"Mathlib.FieldTheory.IsSepClosed","initialProofState":"k : Type u\ninst✝¹ : Field k\ninst✝ : IsSepClosed k\np : Polynomial k\nhp : Irreducible p\nhsep : p.Separable\n⊢ Eq p.degree 1","decl":"theorem degree_eq_one_of_irreducible [IsSepClosed k] {p : k[X]}\n    (hp : Irreducible p) (hsep : p.Separable) : p.degree = 1 :=\n  degree_eq_one_of_irreducible_of_splits hp (IsSepClosed.splits_codomain p hsep)\n\n"}
{"name":"IsSepClosed.algebraMap_surjective","module":"Mathlib.FieldTheory.IsSepClosed","initialProofState":"k : Type u\ninst✝⁴ : Field k\nK : Type v\ninst✝³ : Field K\ninst✝² : IsSepClosed k\ninst✝¹ : Algebra k K\ninst✝ : Algebra.IsSeparable k K\n⊢ Function.Surjective ⇑(algebraMap k K)","decl":"theorem algebraMap_surjective\n    [IsSepClosed k] [Algebra k K] [Algebra.IsSeparable k K] :\n    Function.Surjective (algebraMap k K) := by\n  refine fun x => ⟨-(minpoly k x).coeff 0, ?_⟩\n  have hq : (minpoly k x).leadingCoeff = 1 := minpoly.monic (Algebra.IsSeparable.isIntegral k x)\n  have hsep : IsSeparable k x := Algebra.IsSeparable.isSeparable k x\n  have h : (minpoly k x).degree = 1 :=\n    degree_eq_one_of_irreducible k (minpoly.irreducible (Algebra.IsSeparable.isIntegral k x)) hsep\n  have : aeval x (minpoly k x) = 0 := minpoly.aeval k x\n  rw [eq_X_add_C_of_degree_eq_one h, hq, C_1, one_mul, aeval_add, aeval_X, aeval_C,\n    add_eq_zero_iff_eq_neg] at this\n  exact (RingHom.map_neg (algebraMap k K) ((minpoly k x).coeff 0)).symm ▸ this.symm\n\n"}
{"name":"IntermediateField.eq_bot_of_isSepClosed_of_isSeparable","module":"Mathlib.FieldTheory.IsSepClosed","initialProofState":"k : Type u\ninst✝⁴ : Field k\nK : Type v\ninst✝³ : Field K\ninst✝² : IsSepClosed k\ninst✝¹ : Algebra k K\nL : IntermediateField k K\ninst✝ : Algebra.IsSeparable k (Subtype fun x => Membership.mem L x)\n⊢ Eq L Bot.bot","decl":"/-- If `k` is separably closed, `K / k` is a field extension, `L / k` is an intermediate field\nwhich is separable, then `L` is equal to `k`. A corollary of `IsSepClosed.algebraMap_surjective`. -/\ntheorem IntermediateField.eq_bot_of_isSepClosed_of_isSeparable [IsSepClosed k] [Algebra k K]\n    (L : IntermediateField k K) [Algebra.IsSeparable k L] : L = ⊥ := bot_unique fun x hx ↦ by\n  obtain ⟨y, hy⟩ := IsSepClosed.algebraMap_surjective k L ⟨x, hx⟩\n  exact ⟨y, congr_arg (algebraMap L K) hy⟩\n\n"}
{"name":"IsSepClosure.sep_closed","module":"Mathlib.FieldTheory.IsSepClosed","initialProofState":"k : Type u\ninst✝² : Field k\nK : Type v\ninst✝¹ : Field K\ninst✝ : Algebra k K\nself : IsSepClosure k K\n⊢ IsSepClosed K","decl":"/-- Typeclass for an extension being a separable closure. -/\nclass IsSepClosure [Algebra k K] : Prop where\n  sep_closed : IsSepClosed K\n  separable : Algebra.IsSeparable k K\n\n"}
{"name":"IsSepClosure.separable","module":"Mathlib.FieldTheory.IsSepClosed","initialProofState":"k : Type u\ninst✝² : Field k\nK : Type v\ninst✝¹ : Field K\ninst✝ : Algebra k K\nself : IsSepClosure k K\n⊢ Algebra.IsSeparable k K","decl":"/-- Typeclass for an extension being a separable closure. -/\nclass IsSepClosure [Algebra k K] : Prop where\n  sep_closed : IsSepClosed K\n  separable : Algebra.IsSeparable k K\n\n"}
{"name":"IsSepClosure.self_of_isSepClosed","module":"Mathlib.FieldTheory.IsSepClosed","initialProofState":"k : Type u\ninst✝¹ : Field k\ninst✝ : IsSepClosed k\n⊢ IsSepClosure k k","decl":"/-- A separably closed field is its separable closure. -/\ninstance IsSepClosure.self_of_isSepClosed [IsSepClosed k] : IsSepClosure k k :=\n  ⟨by assumption, Algebra.isSeparable_self k⟩\n\n"}
{"name":"IsSepClosure.isAlgClosure_of_perfectField_top","module":"Mathlib.FieldTheory.IsSepClosed","initialProofState":"k : Type u\ninst✝⁴ : Field k\nK : Type v\ninst✝³ : Field K\ninst✝² : Algebra k K\ninst✝¹ : IsSepClosure k K\ninst✝ : PerfectField K\n⊢ IsAlgClosure k K","decl":"/-- If `K` is perfect and is a separable closure of `k`,\nthen it is also an algebraic closure of `k`. -/\ninstance (priority := 100) IsSepClosure.isAlgClosure_of_perfectField_top\n    [Algebra k K] [IsSepClosure k K] [PerfectField K] : IsAlgClosure k K :=\n  haveI : IsSepClosed K := IsSepClosure.sep_closed k\n  ⟨inferInstance, IsSepClosure.separable.isAlgebraic⟩\n\n"}
{"name":"IsSepClosure.isAlgClosure_of_perfectField","module":"Mathlib.FieldTheory.IsSepClosed","initialProofState":"k : Type u\ninst✝⁴ : Field k\nK : Type v\ninst✝³ : Field K\ninst✝² : Algebra k K\ninst✝¹ : IsSepClosure k K\ninst✝ : PerfectField k\n⊢ IsAlgClosure k K","decl":"/-- If `k` is perfect, `K` is a separable closure of `k`,\nthen it is also an algebraic closure of `k`. -/\ninstance (priority := 100) IsSepClosure.isAlgClosure_of_perfectField\n    [Algebra k K] [IsSepClosure k K] [PerfectField k] : IsAlgClosure k K :=\n  have halg : Algebra.IsAlgebraic k K := IsSepClosure.separable.isAlgebraic\n  haveI := halg.perfectField; inferInstance\n\n"}
{"name":"IsSepClosure.of_isAlgClosure_of_perfectField","module":"Mathlib.FieldTheory.IsSepClosed","initialProofState":"k : Type u\ninst✝⁴ : Field k\nK : Type v\ninst✝³ : Field K\ninst✝² : Algebra k K\ninst✝¹ : IsAlgClosure k K\ninst✝ : PerfectField k\n⊢ IsSepClosure k K","decl":"/-- If `k` is perfect, `K` is an algebraic closure of `k`,\nthen it is also a separable closure of `k`. -/\ninstance (priority := 100) IsSepClosure.of_isAlgClosure_of_perfectField\n    [Algebra k K] [IsAlgClosure k K] [PerfectField k] : IsSepClosure k K :=\n  ⟨haveI := IsAlgClosure.isAlgClosed (R := k) (K := K); inferInstance,\n    (IsAlgClosure.isAlgebraic (R := k) (K := K)).isSeparable_of_perfectField⟩\n\n"}
{"name":"isSepClosure_iff","module":"Mathlib.FieldTheory.IsSepClosed","initialProofState":"k : Type u\ninst✝² : Field k\nK : Type v\ninst✝¹ : Field K\ninst✝ : Algebra k K\n⊢ Iff (IsSepClosure k K) (And (IsSepClosed K) (Algebra.IsSeparable k K))","decl":"theorem isSepClosure_iff [Algebra k K] :\n    IsSepClosure k K ↔ IsSepClosed K ∧ Algebra.IsSeparable k K :=\n  ⟨fun h ↦ ⟨h.1, h.2⟩, fun h ↦ ⟨h.1, h.2⟩⟩\n\n"}
{"name":"IsSepClosure.isSeparable","module":"Mathlib.FieldTheory.IsSepClosed","initialProofState":"k : Type u\ninst✝³ : Field k\nK : Type v\ninst✝² : Field K\ninst✝¹ : Algebra k K\ninst✝ : IsSepClosure k K\n⊢ Algebra.IsSeparable k K","decl":"instance isSeparable [Algebra k K] [IsSepClosure k K] : Algebra.IsSeparable k K :=\n  IsSepClosure.separable\n\n"}
{"name":"IsSepClosure.isGalois","module":"Mathlib.FieldTheory.IsSepClosed","initialProofState":"k : Type u\ninst✝³ : Field k\nK : Type v\ninst✝² : Field K\ninst✝¹ : Algebra k K\ninst✝ : IsSepClosure k K\n⊢ IsGalois k K","decl":"instance (priority := 100) isGalois [Algebra k K] [IsSepClosure k K] : IsGalois k K where\n  to_isSeparable := IsSepClosure.separable\n  to_normal.toIsAlgebraic :=  inferInstance\n  to_normal.splits' x := (IsSepClosure.sep_closed k).splits_codomain _\n    (Algebra.IsSeparable.isSeparable k x)\n\n"}
{"name":"IsSepClosed.surjective_restrictDomain_of_isSeparable","module":"Mathlib.FieldTheory.IsSepClosed","initialProofState":"K : Type u\nL : Type v\nM : Type w\ninst✝¹⁰ : Field K\ninst✝⁹ : Field L\ninst✝⁸ : Algebra K L\ninst✝⁷ : Field M\ninst✝⁶ : Algebra K M\ninst✝⁵ : IsSepClosed M\nE : Type u_1\ninst✝⁴ : Field E\ninst✝³ : Algebra K E\ninst✝² : Algebra L E\ninst✝¹ : IsScalarTower K L E\ninst✝ : Algebra.IsSeparable L E\n⊢ Function.Surjective fun φ => AlgHom.restrictDomain L φ","decl":"theorem surjective_restrictDomain_of_isSeparable {E : Type*}\n    [Field E] [Algebra K E] [Algebra L E] [IsScalarTower K L E] [Algebra.IsSeparable L E] :\n    Function.Surjective fun φ : E →ₐ[K] M ↦ φ.restrictDomain L :=\n  fun f ↦ IntermediateField.exists_algHom_of_splits' (E := E) f\n    fun s ↦ ⟨Algebra.IsSeparable.isIntegral L s,\n      IsSepClosed.splits_codomain _ <| Algebra.IsSeparable.isSeparable L s⟩\n\n"}
{"name":"IsSepClosed.surjective_comp_algebraMap_of_isSeparable","module":"Mathlib.FieldTheory.IsSepClosed","initialProofState":"K : Type u\nL : Type v\nM : Type w\ninst✝¹⁰ : Field K\ninst✝⁹ : Field L\ninst✝⁸ : Algebra K L\ninst✝⁷ : Field M\ninst✝⁶ : Algebra K M\ninst✝⁵ : IsSepClosed M\nE : Type u_1\ninst✝⁴ : Field E\ninst✝³ : Algebra K E\ninst✝² : Algebra L E\ninst✝¹ : IsScalarTower K L E\ninst✝ : Algebra.IsSeparable L E\n⊢ Function.Surjective fun φ => AlgHom.restrictDomain L φ","decl":"@[deprecated (since := \"2024-11-15\")]\nalias surjective_comp_algebraMap_of_isSeparable := surjective_restrictDomain_of_isSeparable\n\n"}
{"name":"IsSepClosed.lift_def","module":"Mathlib.FieldTheory.IsSepClosed","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : Field K\ninst✝⁵ : Field L\ninst✝⁴ : Algebra K L\ninst✝³ : Field M\ninst✝² : Algebra K M\ninst✝¹ : IsSepClosed M\ninst✝ : Algebra.IsSeparable K L\n⊢ Eq IsSepClosed.lift (Classical.choice ⋯)","decl":"/-- A (random) homomorphism from a separable extension L of K into a separably\n  closed extension M of K. -/\nnoncomputable irreducible_def lift : L →ₐ[K] M :=\n  Classical.choice <| IntermediateField.nonempty_algHom_of_adjoin_splits\n    (fun x _ ↦ ⟨Algebra.IsSeparable.isIntegral K x,\n      splits_codomain _ (Algebra.IsSeparable.isSeparable K x)⟩)\n    (IntermediateField.adjoin_univ K L)\n\n"}
