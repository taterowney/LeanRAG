{"name":"Filter.Tendsto.atTop_mul_atTop","module":"Mathlib.Order.Filter.AtTopBot.Ring","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : OrderedSemiring α\nl : Filter β\nf g : β → α\nhf : Filter.Tendsto f l Filter.atTop\nhg : Filter.Tendsto g l Filter.atTop\n⊢ Filter.Tendsto (fun x => HMul.hMul (f x) (g x)) l Filter.atTop","decl":"theorem Tendsto.atTop_mul_atTop (hf : Tendsto f l atTop) (hg : Tendsto g l atTop) :\n    Tendsto (fun x => f x * g x) l atTop := by\n  refine tendsto_atTop_mono' _ ?_ hg\n  filter_upwards [hg.eventually (eventually_ge_atTop 0),\n    hf.eventually (eventually_ge_atTop 1)] with _ using le_mul_of_one_le_left\n\n"}
{"name":"Filter.tendsto_mul_self_atTop","module":"Mathlib.Order.Filter.AtTopBot.Ring","initialProofState":"α : Type u_1\ninst✝ : OrderedSemiring α\n⊢ Filter.Tendsto (fun x => HMul.hMul x x) Filter.atTop Filter.atTop","decl":"theorem tendsto_mul_self_atTop : Tendsto (fun x : α => x * x) atTop atTop :=\n  tendsto_id.atTop_mul_atTop tendsto_id\n\n"}
{"name":"Filter.tendsto_pow_atTop","module":"Mathlib.Order.Filter.AtTopBot.Ring","initialProofState":"α : Type u_1\ninst✝ : OrderedSemiring α\nn : Nat\nhn : Ne n 0\n⊢ Filter.Tendsto (fun x => HPow.hPow x n) Filter.atTop Filter.atTop","decl":"/-- The monomial function `x^n` tends to `+∞` at `+∞` for any positive natural `n`.\nA version for positive real powers exists as `tendsto_rpow_atTop`. -/\ntheorem tendsto_pow_atTop {n : ℕ} (hn : n ≠ 0) : Tendsto (fun x : α => x ^ n) atTop atTop :=\n  tendsto_atTop_mono' _ ((eventually_ge_atTop 1).mono fun _x hx => le_self_pow₀ hx hn) tendsto_id\n\n"}
{"name":"Filter.zero_pow_eventuallyEq","module":"Mathlib.Order.Filter.AtTopBot.Ring","initialProofState":"α : Type u_1\ninst✝ : MonoidWithZero α\n⊢ Filter.atTop.EventuallyEq (fun n => HPow.hPow 0 n) fun x => 0","decl":"theorem zero_pow_eventuallyEq [MonoidWithZero α] :\n    (fun n : ℕ => (0 : α) ^ n) =ᶠ[atTop] fun _ => 0 :=\n  eventually_atTop.2 ⟨1, fun _n hn ↦ zero_pow <| Nat.one_le_iff_ne_zero.1 hn⟩\n\n"}
{"name":"Filter.Tendsto.atTop_mul_atBot","module":"Mathlib.Order.Filter.AtTopBot.Ring","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : OrderedRing α\nl : Filter β\nf g : β → α\nhf : Filter.Tendsto f l Filter.atTop\nhg : Filter.Tendsto g l Filter.atBot\n⊢ Filter.Tendsto (fun x => HMul.hMul (f x) (g x)) l Filter.atBot","decl":"theorem Tendsto.atTop_mul_atBot (hf : Tendsto f l atTop) (hg : Tendsto g l atBot) :\n    Tendsto (fun x => f x * g x) l atBot := by\n  have := hf.atTop_mul_atTop <| tendsto_neg_atBot_atTop.comp hg\n  simpa only [Function.comp_def, neg_mul_eq_mul_neg, neg_neg] using\n    tendsto_neg_atTop_atBot.comp this\n\n"}
{"name":"Filter.Tendsto.atBot_mul_atTop","module":"Mathlib.Order.Filter.AtTopBot.Ring","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : OrderedRing α\nl : Filter β\nf g : β → α\nhf : Filter.Tendsto f l Filter.atBot\nhg : Filter.Tendsto g l Filter.atTop\n⊢ Filter.Tendsto (fun x => HMul.hMul (f x) (g x)) l Filter.atBot","decl":"theorem Tendsto.atBot_mul_atTop (hf : Tendsto f l atBot) (hg : Tendsto g l atTop) :\n    Tendsto (fun x => f x * g x) l atBot := by\n  have : Tendsto (fun x => -f x * g x) l atTop :=\n    (tendsto_neg_atBot_atTop.comp hf).atTop_mul_atTop hg\n  simpa only [Function.comp_def, neg_mul_eq_neg_mul, neg_neg] using\n    tendsto_neg_atTop_atBot.comp this\n\n"}
{"name":"Filter.Tendsto.atBot_mul_atBot","module":"Mathlib.Order.Filter.AtTopBot.Ring","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : OrderedRing α\nl : Filter β\nf g : β → α\nhf : Filter.Tendsto f l Filter.atBot\nhg : Filter.Tendsto g l Filter.atBot\n⊢ Filter.Tendsto (fun x => HMul.hMul (f x) (g x)) l Filter.atTop","decl":"theorem Tendsto.atBot_mul_atBot (hf : Tendsto f l atBot) (hg : Tendsto g l atBot) :\n    Tendsto (fun x => f x * g x) l atTop := by\n  have : Tendsto (fun x => -f x * -g x) l atTop :=\n    (tendsto_neg_atBot_atTop.comp hf).atTop_mul_atTop (tendsto_neg_atBot_atTop.comp hg)\n  simpa only [neg_mul_neg] using this\n\n"}
{"name":"Filter.Tendsto.atTop_of_const_mul","module":"Mathlib.Order.Filter.AtTopBot.Ring","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrderedSemiring α\nl : Filter β\nf : β → α\nc : α\nhc : LT.lt 0 c\nhf : Filter.Tendsto (fun x => HMul.hMul c (f x)) l Filter.atTop\n⊢ Filter.Tendsto f l Filter.atTop","decl":"theorem Tendsto.atTop_of_const_mul {c : α} (hc : 0 < c) (hf : Tendsto (fun x => c * f x) l atTop) :\n    Tendsto f l atTop :=\n  tendsto_atTop.2 fun b => (tendsto_atTop.1 hf (c * b)).mono\n    fun _x hx => le_of_mul_le_mul_left hx hc\n\n"}
{"name":"Filter.Tendsto.atTop_of_mul_const","module":"Mathlib.Order.Filter.AtTopBot.Ring","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrderedSemiring α\nl : Filter β\nf : β → α\nc : α\nhc : LT.lt 0 c\nhf : Filter.Tendsto (fun x => HMul.hMul (f x) c) l Filter.atTop\n⊢ Filter.Tendsto f l Filter.atTop","decl":"theorem Tendsto.atTop_of_mul_const {c : α} (hc : 0 < c) (hf : Tendsto (fun x => f x * c) l atTop) :\n    Tendsto f l atTop :=\n  tendsto_atTop.2 fun b => (tendsto_atTop.1 hf (b * c)).mono\n    fun _x hx => le_of_mul_le_mul_right hx hc\n\n"}
{"name":"Filter.tendsto_pow_atTop_iff","module":"Mathlib.Order.Filter.AtTopBot.Ring","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedSemiring α\nn : Nat\n⊢ Iff (Filter.Tendsto (fun x => HPow.hPow x n) Filter.atTop Filter.atTop) (Ne n 0)","decl":"@[simp]\ntheorem tendsto_pow_atTop_iff {n : ℕ} : Tendsto (fun x : α => x ^ n) atTop atTop ↔ n ≠ 0 :=\n  ⟨fun h hn => by simp only [hn, pow_zero, not_tendsto_const_atTop] at h, tendsto_pow_atTop⟩\n\n"}
{"name":"Filter.not_tendsto_pow_atTop_atBot","module":"Mathlib.Order.Filter.AtTopBot.Ring","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\nn : Nat\n⊢ Not (Filter.Tendsto (fun x => HPow.hPow x n) Filter.atTop Filter.atBot)","decl":"theorem not_tendsto_pow_atTop_atBot [LinearOrderedRing α] :\n    ∀ {n : ℕ}, ¬Tendsto (fun x : α => x ^ n) atTop atBot\n  | 0 => by simp [not_tendsto_const_atBot]\n  | n + 1 => (tendsto_pow_atTop n.succ_ne_zero).not_tendsto disjoint_atTop_atBot\n\n"}
{"name":"exists_lt_mul_self","module":"Mathlib.Order.Filter.AtTopBot.Ring","initialProofState":"R : Type u_3\ninst✝ : LinearOrderedSemiring R\na : R\n⊢ Exists fun x => And (GE.ge x 0) (LT.lt a (HMul.hMul x x))","decl":"theorem exists_lt_mul_self (a : R) : ∃ x ≥ 0, a < x * x :=\n  let ⟨x, hxa, hx0⟩ :=\n    ((tendsto_mul_self_atTop.eventually (eventually_gt_atTop a)).and (eventually_ge_atTop 0)).exists\n  ⟨x, hx0, hxa⟩\n\n"}
{"name":"exists_le_mul_self","module":"Mathlib.Order.Filter.AtTopBot.Ring","initialProofState":"R : Type u_3\ninst✝ : LinearOrderedSemiring R\na : R\n⊢ Exists fun x => And (GE.ge x 0) (LE.le a (HMul.hMul x x))","decl":"theorem exists_le_mul_self (a : R) : ∃ x ≥ 0, a ≤ x * x :=\n  let ⟨x, hx0, hxa⟩ := exists_lt_mul_self a\n  ⟨x, hx0, hxa.le⟩\n"}
