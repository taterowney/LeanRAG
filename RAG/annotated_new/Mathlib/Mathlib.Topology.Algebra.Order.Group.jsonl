{"name":"LinearOrderedAddCommGroup.topologicalAddGroup","module":"Mathlib.Topology.Algebra.Order.Group","initialProofState":"G : Type u_2\ninst✝² : TopologicalSpace G\ninst✝¹ : LinearOrderedAddCommGroup G\ninst✝ : OrderTopology G\n⊢ TopologicalAddGroup G","decl":"instance (priority := 100) LinearOrderedAddCommGroup.topologicalAddGroup :\n    TopologicalAddGroup G where\n  continuous_add := by\n    refine continuous_iff_continuousAt.2 ?_\n    rintro ⟨a, b⟩\n    refine LinearOrderedAddCommGroup.tendsto_nhds.2 fun ε ε0 => ?_\n    rcases dense_or_discrete 0 ε with (⟨δ, δ0, δε⟩ | ⟨_h₁, h₂⟩)\n    · -- If there exists `δ ∈ (0, ε)`, then we choose `δ`-nhd of `a` and `(ε-δ)`-nhd of `b`\n      filter_upwards [(eventually_abs_sub_lt a δ0).prod_nhds\n          (eventually_abs_sub_lt b (sub_pos.2 δε))]\n      rintro ⟨x, y⟩ ⟨hx : |x - a| < δ, hy : |y - b| < ε - δ⟩\n      rw [add_sub_add_comm]\n      calc\n        |x - a + (y - b)| ≤ |x - a| + |y - b| := abs_add _ _\n        _ < δ + (ε - δ) := add_lt_add hx hy\n        _ = ε := add_sub_cancel _ _\n    · -- Otherwise `ε`-nhd of each point `a` is `{a}`\n      have hε : ∀ {x y}, |x - y| < ε → x = y := by\n        intro x y h\n        simpa [sub_eq_zero] using h₂ _ h\n      filter_upwards [(eventually_abs_sub_lt a ε0).prod_nhds (eventually_abs_sub_lt b ε0)]\n      rintro ⟨x, y⟩ ⟨hx : |x - a| < ε, hy : |y - b| < ε⟩\n      simpa [hε hx, hε hy]\n  continuous_neg :=\n    continuous_iff_continuousAt.2 fun a =>\n      LinearOrderedAddCommGroup.tendsto_nhds.2 fun ε ε0 =>\n        (eventually_abs_sub_lt a ε0).mono fun x hx => by rwa [neg_sub_neg, abs_sub_comm]\n\n"}
{"name":"continuous_abs","module":"Mathlib.Topology.Algebra.Order.Group","initialProofState":"G : Type u_2\ninst✝² : TopologicalSpace G\ninst✝¹ : LinearOrderedAddCommGroup G\ninst✝ : OrderTopology G\n⊢ Continuous abs","decl":"@[continuity]\ntheorem continuous_abs : Continuous (abs : G → G) :=\n  continuous_id.max continuous_neg\n\n"}
{"name":"Filter.Tendsto.abs","module":"Mathlib.Topology.Algebra.Order.Group","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : TopologicalSpace G\ninst✝¹ : LinearOrderedAddCommGroup G\ninst✝ : OrderTopology G\nl : Filter α\nf : α → G\na : G\nh : Filter.Tendsto f l (nhds a)\n⊢ Filter.Tendsto (fun x => abs (f x)) l (nhds (abs a))","decl":"protected theorem Filter.Tendsto.abs {a : G} (h : Tendsto f l (𝓝 a)) :\n    Tendsto (fun x => |f x|) l (𝓝 |a|) :=\n  (continuous_abs.tendsto _).comp h\n\n"}
{"name":"tendsto_zero_iff_abs_tendsto_zero","module":"Mathlib.Topology.Algebra.Order.Group","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : TopologicalSpace G\ninst✝¹ : LinearOrderedAddCommGroup G\ninst✝ : OrderTopology G\nl : Filter α\nf : α → G\n⊢ Iff (Filter.Tendsto f l (nhds 0)) (Filter.Tendsto (Function.comp abs f) l (nhds 0))","decl":"theorem tendsto_zero_iff_abs_tendsto_zero (f : α → G) :\n    Tendsto f l (𝓝 0) ↔ Tendsto (abs ∘ f) l (𝓝 0) := by\n  refine ⟨fun h => (abs_zero : |(0 : G)| = 0) ▸ h.abs, fun h => ?_⟩\n  have : Tendsto (fun a => -|f a|) l (𝓝 0) := (neg_zero : -(0 : G) = 0) ▸ h.neg\n  exact\n    tendsto_of_tendsto_of_tendsto_of_le_of_le this h (fun x => neg_abs_le <| f x) fun x =>\n      le_abs_self <| f x\n\n"}
{"name":"Continuous.abs","module":"Mathlib.Topology.Algebra.Order.Group","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝³ : TopologicalSpace G\ninst✝² : LinearOrderedAddCommGroup G\ninst✝¹ : OrderTopology G\nf : α → G\ninst✝ : TopologicalSpace α\nh : Continuous f\n⊢ Continuous fun x => abs (f x)","decl":"@[fun_prop]\nprotected theorem Continuous.abs (h : Continuous f) : Continuous fun x => |f x| :=\n  continuous_abs.comp h\n\n"}
{"name":"ContinuousAt.abs","module":"Mathlib.Topology.Algebra.Order.Group","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝³ : TopologicalSpace G\ninst✝² : LinearOrderedAddCommGroup G\ninst✝¹ : OrderTopology G\nf : α → G\ninst✝ : TopologicalSpace α\na : α\nh : ContinuousAt f a\n⊢ ContinuousAt (fun x => abs (f x)) a","decl":"@[fun_prop]\nprotected theorem ContinuousAt.abs (h : ContinuousAt f a) : ContinuousAt (fun x => |f x|) a :=\n  Filter.Tendsto.abs h\n\n"}
{"name":"ContinuousWithinAt.abs","module":"Mathlib.Topology.Algebra.Order.Group","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝³ : TopologicalSpace G\ninst✝² : LinearOrderedAddCommGroup G\ninst✝¹ : OrderTopology G\nf : α → G\ninst✝ : TopologicalSpace α\na : α\ns : Set α\nh : ContinuousWithinAt f s a\n⊢ ContinuousWithinAt (fun x => abs (f x)) s a","decl":"protected theorem ContinuousWithinAt.abs (h : ContinuousWithinAt f s a) :\n    ContinuousWithinAt (fun x => |f x|) s a :=\n  Filter.Tendsto.abs h\n\n"}
{"name":"ContinuousOn.abs","module":"Mathlib.Topology.Algebra.Order.Group","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝³ : TopologicalSpace G\ninst✝² : LinearOrderedAddCommGroup G\ninst✝¹ : OrderTopology G\nf : α → G\ninst✝ : TopologicalSpace α\ns : Set α\nh : ContinuousOn f s\n⊢ ContinuousOn (fun x => abs (f x)) s","decl":"@[fun_prop]\nprotected theorem ContinuousOn.abs (h : ContinuousOn f s) : ContinuousOn (fun x => |f x|) s :=\n  fun x hx => (h x hx).abs\n\n"}
{"name":"tendsto_abs_nhdsWithin_zero","module":"Mathlib.Topology.Algebra.Order.Group","initialProofState":"G : Type u_2\ninst✝² : TopologicalSpace G\ninst✝¹ : LinearOrderedAddCommGroup G\ninst✝ : OrderTopology G\n⊢ Filter.Tendsto abs (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))) (nhdsWithin 0 (Set.Ioi 0))","decl":"theorem tendsto_abs_nhdsWithin_zero : Tendsto (abs : G → G) (𝓝[≠] 0) (𝓝[>] 0) :=\n  (continuous_abs.tendsto' (0 : G) 0 abs_zero).inf <|\n    tendsto_principal_principal.2 fun _x => abs_pos.2\n\n"}
{"name":"denseRange_zsmul_iff_surjective","module":"Mathlib.Topology.Algebra.Order.Group","initialProofState":"G : Type u_2\ninst✝² : TopologicalSpace G\ninst✝¹ : LinearOrderedAddCommGroup G\ninst✝ : OrderTopology G\na : G\n⊢ Iff (DenseRange fun x => HSMul.hSMul x a) (Function.Surjective fun x => HSMul.hSMul x a)","decl":"/-- In a linearly ordered additive group, the integer multiples of an element are dense\niff they are the whole group. -/\ntheorem denseRange_zsmul_iff_surjective {a : G} :\n    DenseRange (· • a : ℤ → G) ↔ Surjective (· • a : ℤ → G) := by\n  refine ⟨fun h ↦ ?_, fun h ↦ h.denseRange⟩\n  wlog ha₀ : 0 < a generalizing a\n  · simp only [← range_eq_univ, DenseRange] at *\n    rcases (not_lt.1 ha₀).eq_or_lt with rfl | hlt\n    · simpa only [smul_zero, range_const, dense_iff_closure_eq, closure_singleton] using h\n    · have H : range (· • -a : ℤ → G) = range (· • a : ℤ → G) := by\n        simpa only [smul_neg, ← neg_smul] using neg_surjective.range_comp (· • a)\n      rw [← H]\n      apply this <;> simpa only [H, neg_pos]\n  intro b\n  obtain ⟨m, hm, hm'⟩ : ∃ m : ℤ, m • a ∈ Ioo b (b + a + a) := by\n    have hne : (Ioo b (b + a + a)).Nonempty := ⟨b + a, by simpa⟩\n    simpa using h.exists_mem_open isOpen_Ioo hne\n  rcases eq_or_ne b ((m - 1) • a) with rfl | hne; · simp\n  suffices (Ioo (m • a) ((m + 1) • a)).Nonempty by\n    rcases h.exists_mem_open isOpen_Ioo this with ⟨l, hl⟩\n    have : m < l ∧ l < m + 1 := by simpa [zsmul_lt_zsmul_iff_left ha₀] using hl\n    omega\n  rcases hne.lt_or_lt with hlt | hlt\n  · refine ⟨b + a + a, hm', ?_⟩\n    simpa only [add_smul, sub_smul, one_smul, lt_sub_iff_add_lt, add_lt_add_iff_right] using hlt\n  · use b + a\n    simp only [mem_Ioo, add_smul, sub_smul, one_smul, add_lt_add_iff_right] at hlt ⊢\n    exact ⟨sub_lt_iff_lt_add.1 hlt, hm⟩\n\n"}
{"name":"not_denseRange_zsmul","module":"Mathlib.Topology.Algebra.Order.Group","initialProofState":"G : Type u_2\ninst✝⁴ : TopologicalSpace G\ninst✝³ : LinearOrderedAddCommGroup G\ninst✝² : OrderTopology G\ninst✝¹ : Nontrivial G\ninst✝ : DenselyOrdered G\na : G\n⊢ Not (DenseRange fun x => HSMul.hSMul x a)","decl":"/-- In a nontrivial densely linearly ordered additive group,\nthe integer multiples of an element can't be dense. -/\ntheorem not_denseRange_zsmul [Nontrivial G] [DenselyOrdered G] {a : G} :\n    ¬DenseRange (· • a : ℤ → G) :=\n  denseRange_zsmul_iff_surjective.not.mpr fun h ↦\n    not_isAddCyclic_of_denselyOrdered G ⟨⟨a, h⟩⟩\n"}
