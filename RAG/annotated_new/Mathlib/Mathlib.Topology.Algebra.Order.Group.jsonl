{"name":"LinearOrderedAddCommGroup.topologicalAddGroup","module":"Mathlib.Topology.Algebra.Order.Group","initialProofState":"G : Type u_2\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : LinearOrderedAddCommGroup G\ninstâœ : OrderTopology G\nâŠ¢ TopologicalAddGroup G","decl":"instance (priority := 100) LinearOrderedAddCommGroup.topologicalAddGroup :\n    TopologicalAddGroup G where\n  continuous_add := by\n    refine continuous_iff_continuousAt.2 ?_\n    rintro âŸ¨a, bâŸ©\n    refine LinearOrderedAddCommGroup.tendsto_nhds.2 fun Îµ Îµ0 => ?_\n    rcases dense_or_discrete 0 Îµ with (âŸ¨Î´, Î´0, Î´ÎµâŸ© | âŸ¨_hâ‚, hâ‚‚âŸ©)\n    Â· -- If there exists `Î´ âˆˆ (0, Îµ)`, then we choose `Î´`-nhd of `a` and `(Îµ-Î´)`-nhd of `b`\n      filter_upwards [(eventually_abs_sub_lt a Î´0).prod_nhds\n          (eventually_abs_sub_lt b (sub_pos.2 Î´Îµ))]\n      rintro âŸ¨x, yâŸ© âŸ¨hx : |x - a| < Î´, hy : |y - b| < Îµ - Î´âŸ©\n      rw [add_sub_add_comm]\n      calc\n        |x - a + (y - b)| â‰¤ |x - a| + |y - b| := abs_add _ _\n        _ < Î´ + (Îµ - Î´) := add_lt_add hx hy\n        _ = Îµ := add_sub_cancel _ _\n    Â· -- Otherwise `Îµ`-nhd of each point `a` is `{a}`\n      have hÎµ : âˆ€ {x y}, |x - y| < Îµ â†’ x = y := by\n        intro x y h\n        simpa [sub_eq_zero] using hâ‚‚ _ h\n      filter_upwards [(eventually_abs_sub_lt a Îµ0).prod_nhds (eventually_abs_sub_lt b Îµ0)]\n      rintro âŸ¨x, yâŸ© âŸ¨hx : |x - a| < Îµ, hy : |y - b| < ÎµâŸ©\n      simpa [hÎµ hx, hÎµ hy]\n  continuous_neg :=\n    continuous_iff_continuousAt.2 fun a =>\n      LinearOrderedAddCommGroup.tendsto_nhds.2 fun Îµ Îµ0 =>\n        (eventually_abs_sub_lt a Îµ0).mono fun x hx => by rwa [neg_sub_neg, abs_sub_comm]\n\n"}
{"name":"continuous_abs","module":"Mathlib.Topology.Algebra.Order.Group","initialProofState":"G : Type u_2\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : LinearOrderedAddCommGroup G\ninstâœ : OrderTopology G\nâŠ¢ Continuous abs","decl":"@[continuity]\ntheorem continuous_abs : Continuous (abs : G â†’ G) :=\n  continuous_id.max continuous_neg\n\n"}
{"name":"Filter.Tendsto.abs","module":"Mathlib.Topology.Algebra.Order.Group","initialProofState":"Î± : Type u_1\nG : Type u_2\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : LinearOrderedAddCommGroup G\ninstâœ : OrderTopology G\nl : Filter Î±\nf : Î± â†’ G\na : G\nh : Filter.Tendsto f l (nhds a)\nâŠ¢ Filter.Tendsto (fun x => abs (f x)) l (nhds (abs a))","decl":"protected theorem Filter.Tendsto.abs {a : G} (h : Tendsto f l (ğ“ a)) :\n    Tendsto (fun x => |f x|) l (ğ“ |a|) :=\n  (continuous_abs.tendsto _).comp h\n\n"}
{"name":"tendsto_zero_iff_abs_tendsto_zero","module":"Mathlib.Topology.Algebra.Order.Group","initialProofState":"Î± : Type u_1\nG : Type u_2\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : LinearOrderedAddCommGroup G\ninstâœ : OrderTopology G\nl : Filter Î±\nf : Î± â†’ G\nâŠ¢ Iff (Filter.Tendsto f l (nhds 0)) (Filter.Tendsto (Function.comp abs f) l (nhds 0))","decl":"theorem tendsto_zero_iff_abs_tendsto_zero (f : Î± â†’ G) :\n    Tendsto f l (ğ“ 0) â†” Tendsto (abs âˆ˜ f) l (ğ“ 0) := by\n  refine âŸ¨fun h => (abs_zero : |(0 : G)| = 0) â–¸ h.abs, fun h => ?_âŸ©\n  have : Tendsto (fun a => -|f a|) l (ğ“ 0) := (neg_zero : -(0 : G) = 0) â–¸ h.neg\n  exact\n    tendsto_of_tendsto_of_tendsto_of_le_of_le this h (fun x => neg_abs_le <| f x) fun x =>\n      le_abs_self <| f x\n\n"}
{"name":"Continuous.abs","module":"Mathlib.Topology.Algebra.Order.Group","initialProofState":"Î± : Type u_1\nG : Type u_2\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : LinearOrderedAddCommGroup G\ninstâœÂ¹ : OrderTopology G\nf : Î± â†’ G\ninstâœ : TopologicalSpace Î±\nh : Continuous f\nâŠ¢ Continuous fun x => abs (f x)","decl":"@[fun_prop]\nprotected theorem Continuous.abs (h : Continuous f) : Continuous fun x => |f x| :=\n  continuous_abs.comp h\n\n"}
{"name":"ContinuousAt.abs","module":"Mathlib.Topology.Algebra.Order.Group","initialProofState":"Î± : Type u_1\nG : Type u_2\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : LinearOrderedAddCommGroup G\ninstâœÂ¹ : OrderTopology G\nf : Î± â†’ G\ninstâœ : TopologicalSpace Î±\na : Î±\nh : ContinuousAt f a\nâŠ¢ ContinuousAt (fun x => abs (f x)) a","decl":"@[fun_prop]\nprotected theorem ContinuousAt.abs (h : ContinuousAt f a) : ContinuousAt (fun x => |f x|) a :=\n  Filter.Tendsto.abs h\n\n"}
{"name":"ContinuousWithinAt.abs","module":"Mathlib.Topology.Algebra.Order.Group","initialProofState":"Î± : Type u_1\nG : Type u_2\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : LinearOrderedAddCommGroup G\ninstâœÂ¹ : OrderTopology G\nf : Î± â†’ G\ninstâœ : TopologicalSpace Î±\na : Î±\ns : Set Î±\nh : ContinuousWithinAt f s a\nâŠ¢ ContinuousWithinAt (fun x => abs (f x)) s a","decl":"protected theorem ContinuousWithinAt.abs (h : ContinuousWithinAt f s a) :\n    ContinuousWithinAt (fun x => |f x|) s a :=\n  Filter.Tendsto.abs h\n\n"}
{"name":"ContinuousOn.abs","module":"Mathlib.Topology.Algebra.Order.Group","initialProofState":"Î± : Type u_1\nG : Type u_2\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : LinearOrderedAddCommGroup G\ninstâœÂ¹ : OrderTopology G\nf : Î± â†’ G\ninstâœ : TopologicalSpace Î±\ns : Set Î±\nh : ContinuousOn f s\nâŠ¢ ContinuousOn (fun x => abs (f x)) s","decl":"@[fun_prop]\nprotected theorem ContinuousOn.abs (h : ContinuousOn f s) : ContinuousOn (fun x => |f x|) s :=\n  fun x hx => (h x hx).abs\n\n"}
{"name":"tendsto_abs_nhdsWithin_zero","module":"Mathlib.Topology.Algebra.Order.Group","initialProofState":"G : Type u_2\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : LinearOrderedAddCommGroup G\ninstâœ : OrderTopology G\nâŠ¢ Filter.Tendsto abs (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))) (nhdsWithin 0 (Set.Ioi 0))","decl":"theorem tendsto_abs_nhdsWithin_zero : Tendsto (abs : G â†’ G) (ğ“[â‰ ] 0) (ğ“[>] 0) :=\n  (continuous_abs.tendsto' (0 : G) 0 abs_zero).inf <|\n    tendsto_principal_principal.2 fun _x => abs_pos.2\n\n"}
{"name":"denseRange_zsmul_iff_surjective","module":"Mathlib.Topology.Algebra.Order.Group","initialProofState":"G : Type u_2\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : LinearOrderedAddCommGroup G\ninstâœ : OrderTopology G\na : G\nâŠ¢ Iff (DenseRange fun x => HSMul.hSMul x a) (Function.Surjective fun x => HSMul.hSMul x a)","decl":"/-- In a linearly ordered additive group, the integer multiples of an element are dense\niff they are the whole group. -/\ntheorem denseRange_zsmul_iff_surjective {a : G} :\n    DenseRange (Â· â€¢ a : â„¤ â†’ G) â†” Surjective (Â· â€¢ a : â„¤ â†’ G) := by\n  refine âŸ¨fun h â†¦ ?_, fun h â†¦ h.denseRangeâŸ©\n  wlog haâ‚€ : 0 < a generalizing a\n  Â· simp only [â† range_eq_univ, DenseRange] at *\n    rcases (not_lt.1 haâ‚€).eq_or_lt with rfl | hlt\n    Â· simpa only [smul_zero, range_const, dense_iff_closure_eq, closure_singleton] using h\n    Â· have H : range (Â· â€¢ -a : â„¤ â†’ G) = range (Â· â€¢ a : â„¤ â†’ G) := by\n        simpa only [smul_neg, â† neg_smul] using neg_surjective.range_comp (Â· â€¢ a)\n      rw [â† H]\n      apply this <;> simpa only [H, neg_pos]\n  intro b\n  obtain âŸ¨m, hm, hm'âŸ© : âˆƒ m : â„¤, m â€¢ a âˆˆ Ioo b (b + a + a) := by\n    have hne : (Ioo b (b + a + a)).Nonempty := âŸ¨b + a, by simpaâŸ©\n    simpa using h.exists_mem_open isOpen_Ioo hne\n  rcases eq_or_ne b ((m - 1) â€¢ a) with rfl | hne; Â· simp\n  suffices (Ioo (m â€¢ a) ((m + 1) â€¢ a)).Nonempty by\n    rcases h.exists_mem_open isOpen_Ioo this with âŸ¨l, hlâŸ©\n    have : m < l âˆ§ l < m + 1 := by simpa [zsmul_lt_zsmul_iff_left haâ‚€] using hl\n    omega\n  rcases hne.lt_or_lt with hlt | hlt\n  Â· refine âŸ¨b + a + a, hm', ?_âŸ©\n    simpa only [add_smul, sub_smul, one_smul, lt_sub_iff_add_lt, add_lt_add_iff_right] using hlt\n  Â· use b + a\n    simp only [mem_Ioo, add_smul, sub_smul, one_smul, add_lt_add_iff_right] at hlt âŠ¢\n    exact âŸ¨sub_lt_iff_lt_add.1 hlt, hmâŸ©\n\n"}
{"name":"not_denseRange_zsmul","module":"Mathlib.Topology.Algebra.Order.Group","initialProofState":"G : Type u_2\ninstâœâ´ : TopologicalSpace G\ninstâœÂ³ : LinearOrderedAddCommGroup G\ninstâœÂ² : OrderTopology G\ninstâœÂ¹ : Nontrivial G\ninstâœ : DenselyOrdered G\na : G\nâŠ¢ Not (DenseRange fun x => HSMul.hSMul x a)","decl":"/-- In a nontrivial densely linearly ordered additive group,\nthe integer multiples of an element can't be dense. -/\ntheorem not_denseRange_zsmul [Nontrivial G] [DenselyOrdered G] {a : G} :\n    Â¬DenseRange (Â· â€¢ a : â„¤ â†’ G) :=\n  denseRange_zsmul_iff_surjective.not.mpr fun h â†¦\n    not_isAddCyclic_of_denselyOrdered G âŸ¨âŸ¨a, hâŸ©âŸ©\n"}
