{"name":"algebraicIndependent_unique_type_iff","module":"Mathlib.RingTheory.AlgebraicIndependent.Transcendental","initialProofState":"ι : Type u_1\nR : Type u_2\nA : Type u_3\nx : ι → A\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\ninst✝ : Unique ι\n⊢ Iff (AlgebraicIndependent R x) (Transcendental R (x Inhabited.default))","decl":"/-- A one-element family `x` is algebraically independent if and only if\nits element is transcendental. -/\n@[simp]\ntheorem algebraicIndependent_unique_type_iff [Unique ι] :\n    AlgebraicIndependent R x ↔ Transcendental R (x default) := by\n  rw [transcendental_iff_injective, algebraicIndependent_iff_injective_aeval]\n  let i := (renameEquiv R (Equiv.equivPUnit.{_, 1} ι)).trans (pUnitAlgEquiv R)\n  have key : aeval (R := R) x = (Polynomial.aeval (R := R) (x default)).comp i := by\n    ext y\n    simp [i, Subsingleton.elim y default]\n  simp [key]\n\n"}
{"name":"algebraicIndependent_singleton_iff","module":"Mathlib.RingTheory.AlgebraicIndependent.Transcendental","initialProofState":"ι : Type u_1\nR : Type u_2\nA : Type u_3\nx : ι → A\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\ninst✝ : Subsingleton ι\ni : ι\n⊢ Iff (AlgebraicIndependent R x) (Transcendental R (x i))","decl":"theorem algebraicIndependent_singleton_iff [Subsingleton ι] (i : ι) :\n    AlgebraicIndependent R x ↔ Transcendental R (x i) :=\n  letI := uniqueOfSubsingleton i\n  algebraicIndependent_unique_type_iff\n\n"}
{"name":"algebraicIndependent_iff_transcendental","module":"Mathlib.RingTheory.AlgebraicIndependent.Transcendental","initialProofState":"R : Type u_2\nA : Type u_3\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nx : A\n⊢ Iff (AlgebraicIndependent R (Matrix.vecCons x Matrix.vecEmpty)) (Transcendental R x)","decl":"/-- The one-element family `![x]` is algebraically independent if and only if\n`x` is transcendental. -/\ntheorem algebraicIndependent_iff_transcendental {x : A} :\n    AlgebraicIndependent R ![x] ↔ Transcendental R x := by\n  simp\n\n"}
{"name":"AlgebraicIndependent.transcendental","module":"Mathlib.RingTheory.AlgebraicIndependent.Transcendental","initialProofState":"ι : Type u_1\nR : Type u_2\nA : Type u_3\nx : ι → A\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nhx : AlgebraicIndependent R x\ni : ι\n⊢ Transcendental R (x i)","decl":"/-- If a family `x` is algebraically independent, then any of its element is transcendental. -/\ntheorem transcendental (i : ι) : Transcendental R (x i) := by\n  have := hx.comp ![i] (Function.injective_of_subsingleton _)\n  have : AlgebraicIndependent R ![x i] := by rwa [← FinVec.map_eq] at this\n  rwa [← algebraicIndependent_iff_transcendental]\n\n"}
{"name":"AlgebraicIndependent.isEmpty_of_isAlgebraic","module":"Mathlib.RingTheory.AlgebraicIndependent.Transcendental","initialProofState":"ι : Type u_1\nR : Type u_2\nA : Type u_3\nx : ι → A\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\nhx : AlgebraicIndependent R x\ninst✝ : Algebra.IsAlgebraic R A\n⊢ IsEmpty ι","decl":"/-- If `A/R` is algebraic, then all algebraically independent families are empty. -/\ntheorem isEmpty_of_isAlgebraic [Algebra.IsAlgebraic R A] : IsEmpty ι := by\n  rcases isEmpty_or_nonempty ι with h | ⟨⟨i⟩⟩\n  · exact h\n  exact False.elim (hx.transcendental i (Algebra.IsAlgebraic.isAlgebraic _))\n\n"}
{"name":"AlgebraicIndependent.option_iff","module":"Mathlib.RingTheory.AlgebraicIndependent.Transcendental","initialProofState":"ι : Type u_1\nR : Type u_2\nA : Type u_3\nx : ι → A\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nhx : AlgebraicIndependent R x\na : A\n⊢ Iff (AlgebraicIndependent R fun o => o.elim a x) (Transcendental (Subtype fun x_1 => Membership.mem (Algebra.adjoin R (Set.range x)) x_1) a)","decl":"theorem AlgebraicIndependent.option_iff (hx : AlgebraicIndependent R x) (a : A) :\n    (AlgebraicIndependent R fun o : Option ι => o.elim a x) ↔\n      Transcendental (adjoin R (Set.range x)) a := by\n  rw [algebraicIndependent_iff_injective_aeval, transcendental_iff_injective,\n    ← AlgHom.coe_toRingHom, ← hx.aeval_comp_mvPolynomialOptionEquivPolynomialAdjoin,\n    RingHom.coe_comp]\n  exact Injective.of_comp_iff' (Polynomial.aeval a)\n    (mvPolynomialOptionEquivPolynomialAdjoin hx).bijective\n\n"}
{"name":"algebraicIndependent_of_finite_type'","module":"Mathlib.RingTheory.AlgebraicIndependent.Transcendental","initialProofState":"ι : Type u_1\nR : Type u_2\nA : Type u_3\nx : ι → A\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nhinj : Function.Injective ⇑(algebraMap R A)\nH : ∀ (t : Set ι), t.Finite → (AlgebraicIndependent R fun i => x ↑i) → ∀ (i : ι), Not (Membership.mem t i) → Transcendental (Subtype fun x_1 => Membership.mem (Algebra.adjoin R (Set.image x t)) x_1) (x i)\n⊢ AlgebraicIndependent R x","decl":"/-- Variant of `algebraicIndependent_of_finite_type` using `Transcendental`. -/\ntheorem algebraicIndependent_of_finite_type'\n    (hinj : Injective (algebraMap R A))\n    (H : ∀ t : Set ι, t.Finite → AlgebraicIndependent R (fun i : t ↦ x i) →\n      ∀ i : ι, i ∉ t → Transcendental (adjoin R (x '' t)) (x i)) :\n    AlgebraicIndependent R x := by\n  classical\n  refine algebraicIndependent_of_finite_type fun t hfin ↦ hfin.induction_on_subset _\n    (algebraicIndependent_empty_type_iff.mpr hinj) fun {a u} ha hu ha' h ↦ ?_\n  convert ((Set.image_eq_range _ _ ▸ h.option_iff <| x a).2 <| H u (hfin.subset hu) h _ ha').comp _\n    (Set.subtypeInsertEquivOption ha').injective with x\n  by_cases h : ↑x = a <;> simp [h, Set.subtypeInsertEquivOption]\n\n"}
{"name":"algebraicIndependent_of_finite'","module":"Mathlib.RingTheory.AlgebraicIndependent.Transcendental","initialProofState":"R : Type u_2\nA : Type u_3\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\ns : Set A\nhinj : Function.Injective ⇑(algebraMap R A)\nH : ∀ (t : Set A), HasSubset.Subset t s → t.Finite → AlgebraicIndependent R Subtype.val → ∀ (a : A), Membership.mem s a → Not (Membership.mem t a) → Transcendental (Subtype fun x => Membership.mem (Algebra.adjoin R t) x) a\n⊢ AlgebraicIndependent R Subtype.val","decl":"/-- Variant of `algebraicIndependent_of_finite` using `Transcendental`. -/\ntheorem algebraicIndependent_of_finite' (s : Set A)\n    (hinj : Injective (algebraMap R A))\n    (H : ∀ t ⊆ s, t.Finite → AlgebraicIndependent R ((↑) : t → A) →\n      ∀ a ∈ s, a ∉ t → Transcendental (adjoin R t) a) :\n    AlgebraicIndependent R ((↑) : s → A) :=\n  algebraicIndependent_of_finite_type' hinj fun t hfin h i hi ↦ H _\n    (by rintro _ ⟨x, _, rfl⟩; exact x.2) (hfin.image _) h.image _ i.2\n    (mt Subtype.val_injective.mem_set_image.mp hi)\n\n"}
{"name":"AlgebraicIndependent.adjoin_of_disjoint","module":"Mathlib.RingTheory.AlgebraicIndependent.Transcendental","initialProofState":"ι : Type u_1\nR : Type u_2\nA : Type u_3\nx : ι → A\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nhx : AlgebraicIndependent R x\ns t : Set ι\nh : Disjoint s t\n⊢ AlgebraicIndependent (Subtype fun x_1 => Membership.mem (Algebra.adjoin R (Set.image x s)) x_1) fun i => x ↑i","decl":"theorem adjoin_of_disjoint {s t : Set ι} (h : Disjoint s t) :\n    AlgebraicIndependent (adjoin R (x '' s)) fun i : t ↦ x i := by\n  let e := (sumAlgEquiv R t s).trans (mapAlgEquiv t (hx.comp _ Subtype.val_injective).aevalEquiv)\n  have : ((aeval fun i : t ↦ x i).restrictScalars R).comp e.toAlgHom =\n      (aeval x).comp (rename <| Sum.elim Subtype.val Subtype.val) := by\n    ext (_|_) <;> simp [e, algebraMap_aevalEquiv]\n  have _ := @MvPolynomial.isScalarTower\n  rw [Set.image_eq_range, AlgebraicIndependent, ← AlgHom.coe_restrictScalars' R, ← e.injective_comp]\n  show Injective ((AlgHom.restrictScalars R <| aeval _).comp e.toAlgHom)\n  rw [this, AlgHom.coe_comp]\n  exact .comp hx (rename_injective _ <| Subtype.val_injective.sum_elim\n    Subtype.val_injective fun i j eq ↦ h.ne_of_mem j.2 i.2 eq.symm)\n\n"}
{"name":"AlgebraicIndependent.adjoin_iff_disjoint","module":"Mathlib.RingTheory.AlgebraicIndependent.Transcendental","initialProofState":"ι : Type u_1\nR : Type u_2\nA : Type u_3\nx : ι → A\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\nhx : AlgebraicIndependent R x\ninst✝ : Nontrivial A\ns t : Set ι\n⊢ Iff (AlgebraicIndependent (Subtype fun x_1 => Membership.mem (Algebra.adjoin R (Set.image x s)) x_1) fun i => x ↑i) (Disjoint s t)","decl":"theorem adjoin_iff_disjoint [Nontrivial A] {s t : Set ι} :\n    (AlgebraicIndependent (adjoin R (x '' s)) fun i : t ↦ x i) ↔ Disjoint s t := by\n  refine ⟨fun ind ↦ of_not_not fun ndisj ↦ ?_, adjoin_of_disjoint hx⟩\n  have ⟨i, hs, ht⟩ := Set.not_disjoint_iff.mp ndisj\n  refine ind.transcendental ⟨i, ht⟩ (isAlgebraic_algebraMap (⟨_, subset_adjoin ?_⟩ : adjoin R _))\n  exact ⟨i, hs, rfl⟩\n\n"}
{"name":"AlgebraicIndependent.transcendental_adjoin","module":"Mathlib.RingTheory.AlgebraicIndependent.Transcendental","initialProofState":"ι : Type u_1\nR : Type u_2\nA : Type u_3\nx : ι → A\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nhx : AlgebraicIndependent R x\ns : Set ι\ni : ι\nhi : Not (Membership.mem s i)\n⊢ Transcendental (Subtype fun x_1 => Membership.mem (Algebra.adjoin R (Set.image x s)) x_1) (x i)","decl":"theorem transcendental_adjoin {s : Set ι} {i : ι} (hi : i ∉ s) :\n    Transcendental (adjoin R (x '' s)) (x i) := by\n  convert ← hx.adjoin_of_disjoint (Set.disjoint_singleton_right.mpr hi)\n  rw [algebraicIndependent_singleton_iff ⟨i, rfl⟩]\n\n"}
{"name":"AlgebraicIndependent.transcendental_adjoin_iff","module":"Mathlib.RingTheory.AlgebraicIndependent.Transcendental","initialProofState":"ι : Type u_1\nR : Type u_2\nA : Type u_3\nx : ι → A\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\nhx : AlgebraicIndependent R x\ninst✝ : Nontrivial A\ns : Set ι\ni : ι\n⊢ Iff (Transcendental (Subtype fun x_1 => Membership.mem (Algebra.adjoin R (Set.image x s)) x_1) (x i)) (Not (Membership.mem s i))","decl":"theorem transcendental_adjoin_iff [Nontrivial A] {s : Set ι} {i : ι} :\n    Transcendental (adjoin R (x '' s)) (x i) ↔ i ∉ s := by\n  rw [← Set.disjoint_singleton_right]\n  convert ← hx.adjoin_iff_disjoint (t := {i})\n  rw [algebraicIndependent_singleton_iff ⟨i, rfl⟩]\n\n"}
{"name":"MvPolynomial.algebraicIndependent_polynomial_aeval_X","module":"Mathlib.RingTheory.AlgebraicIndependent.Transcendental","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝ : CommRing R\nf : ι → Polynomial R\nhf : ∀ (i : ι), Transcendental R (f i)\n⊢ AlgebraicIndependent R fun i => (Polynomial.aeval (MvPolynomial.X i)) (f i)","decl":"/-- If for each `i : ι`, `f_i : R[X]` is transcendental over `R`, then `{f_i(X_i) | i : ι}`\nin `MvPolynomial ι R` is algebraically independent over `R`. -/\ntheorem algebraicIndependent_polynomial_aeval_X\n    (f : ι → Polynomial R) (hf : ∀ i, Transcendental R (f i)) :\n    AlgebraicIndependent R fun i ↦ Polynomial.aeval (X i : MvPolynomial ι R) (f i) := by\n  set x := fun i ↦ Polynomial.aeval (X i : MvPolynomial ι R) (f i)\n  refine algebraicIndependent_of_finite_type' (C_injective _ _) fun t _ _ i hi ↦ ?_\n  have hle : adjoin R (x '' t) ≤ supported R t := by\n    rw [Algebra.adjoin_le_iff, Set.image_subset_iff]\n    intro _ h\n    rw [Set.mem_preimage]\n    refine Algebra.adjoin_mono ?_ (Polynomial.aeval_mem_adjoin_singleton R _)\n    simp_rw [singleton_subset_iff, Set.mem_image_of_mem _ h]\n  exact (transcendental_supported_polynomial_aeval_X R hi (hf i)).of_tower_top_of_subalgebra_le hle\n\n"}
{"name":"AlgebraicIndependent.polynomial_aeval_of_transcendental","module":"Mathlib.RingTheory.AlgebraicIndependent.Transcendental","initialProofState":"ι : Type u_1\nR : Type u_2\nA : Type u_3\nx : ι → A\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nhx : AlgebraicIndependent R x\nf : ι → Polynomial R\nhf : ∀ (i : ι), Transcendental R (f i)\n⊢ AlgebraicIndependent R fun i => (Polynomial.aeval (x i)) (f i)","decl":"/-- If `{x_i : A | i : ι}` is algebraically independent over `R`, and for each `i`,\n`f_i : R[X]` is transcendental over `R`, then `{f_i(x_i) | i : ι}` is also\nalgebraically independent over `R`. -/\ntheorem AlgebraicIndependent.polynomial_aeval_of_transcendental\n    (hx : AlgebraicIndependent R x)\n    {f : ι → Polynomial R} (hf : ∀ i, Transcendental R (f i)) :\n    AlgebraicIndependent R fun i ↦ Polynomial.aeval (x i) (f i) := by\n  convert aeval_of_algebraicIndependent hx (algebraicIndependent_polynomial_aeval_X _ hf)\n  rw [← AlgHom.comp_apply]\n  congr 1; ext1; simp\n"}
