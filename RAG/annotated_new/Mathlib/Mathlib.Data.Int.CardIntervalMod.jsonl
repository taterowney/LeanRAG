{"name":"Int.Ico_filter_modEq_eq","module":"Mathlib.Data.Int.CardIntervalMod","initialProofState":"a b r v : Int\n⊢ Eq (Finset.filter (fun x => r.ModEq x v) (Finset.Ico a b)) (Finset.map { toFun := fun x => HAdd.hAdd x v, inj' := ⋯ } (Finset.filter (fun x => Dvd.dvd r x) (Finset.Ico (HSub.hSub a v) (HSub.hSub b v))))","decl":"lemma Ico_filter_modEq_eq (v : ℤ) :\n    {x ∈ Ico a b | x ≡ v [ZMOD r]} =\n    {x ∈ Ico (a - v) (b - v) | r ∣ x}.map ⟨(· + v), add_left_injective v⟩ := by\n  ext x\n  simp_rw [mem_map, mem_filter, mem_Ico, Function.Embedding.coeFn_mk, ← eq_sub_iff_add_eq,\n    exists_eq_right, modEq_comm, modEq_iff_dvd, sub_lt_sub_iff_right, sub_le_sub_iff_right]\n\n"}
{"name":"Int.Ioc_filter_modEq_eq","module":"Mathlib.Data.Int.CardIntervalMod","initialProofState":"a b r v : Int\n⊢ Eq (Finset.filter (fun x => r.ModEq x v) (Finset.Ioc a b)) (Finset.map { toFun := fun x => HAdd.hAdd x v, inj' := ⋯ } (Finset.filter (fun x => Dvd.dvd r x) (Finset.Ioc (HSub.hSub a v) (HSub.hSub b v))))","decl":"lemma Ioc_filter_modEq_eq (v : ℤ) :\n    {x ∈ Ioc a b | x ≡ v [ZMOD r]} =\n    {x ∈ Ioc (a - v) (b - v) | r ∣ x}.map ⟨(· + v), add_left_injective v⟩ := by\n  ext x\n  simp_rw [mem_map, mem_filter, mem_Ioc, Function.Embedding.coeFn_mk, ← eq_sub_iff_add_eq,\n    exists_eq_right, modEq_comm, modEq_iff_dvd, sub_lt_sub_iff_right, sub_le_sub_iff_right]\n\n"}
{"name":"Int.Ico_filter_dvd_eq","module":"Mathlib.Data.Int.CardIntervalMod","initialProofState":"a b r : Int\nhr : LT.lt 0 r\n⊢ Eq (Finset.filter (fun x => Dvd.dvd r x) (Finset.Ico a b)) (Finset.map { toFun := fun x => HMul.hMul x r, inj' := ⋯ } (Finset.Ico (Int.ceil (HDiv.hDiv ↑a ↑r)) (Int.ceil (HDiv.hDiv ↑b ↑r))))","decl":"lemma Ico_filter_dvd_eq :\n    {x ∈ Ico a b | r ∣ x} =\n      (Ico ⌈a / (r : ℚ)⌉ ⌈b / (r : ℚ)⌉).map ⟨(· * r), mul_left_injective₀ hr.ne'⟩ := by\n  ext x\n  simp only [mem_map, mem_filter, mem_Ico, ceil_le, lt_ceil, div_le_iff₀, lt_div_iff₀,\n    dvd_iff_exists_eq_mul_left, cast_pos.2 hr, ← cast_mul, cast_lt, cast_le]\n  aesop\n\n"}
{"name":"Int.Ioc_filter_dvd_eq","module":"Mathlib.Data.Int.CardIntervalMod","initialProofState":"a b r : Int\nhr : LT.lt 0 r\n⊢ Eq (Finset.filter (fun x => Dvd.dvd r x) (Finset.Ioc a b)) (Finset.map { toFun := fun x => HMul.hMul x r, inj' := ⋯ } (Finset.Ioc (Int.floor (HDiv.hDiv ↑a ↑r)) (Int.floor (HDiv.hDiv ↑b ↑r))))","decl":"lemma Ioc_filter_dvd_eq :\n    {x ∈ Ioc a b | r ∣ x} =\n      (Ioc ⌊a / (r : ℚ)⌋ ⌊b / (r : ℚ)⌋).map ⟨(· * r), mul_left_injective₀ hr.ne'⟩ := by\n  ext x\n  simp only [mem_map, mem_filter, mem_Ioc, floor_lt, le_floor, div_lt_iff₀, le_div_iff₀,\n    dvd_iff_exists_eq_mul_left, cast_pos.2 hr, ← cast_mul, cast_lt, cast_le]\n  aesop\n\n"}
{"name":"Int.Ico_filter_dvd_card","module":"Mathlib.Data.Int.CardIntervalMod","initialProofState":"a b r : Int\nhr : LT.lt 0 r\n⊢ Eq (↑(Finset.filter (fun x => Dvd.dvd r x) (Finset.Ico a b)).card) (Max.max (HSub.hSub (Int.ceil (HDiv.hDiv ↑b ↑r)) (Int.ceil (HDiv.hDiv ↑a ↑r))) 0)","decl":"/-- There are `⌈b / r⌉ - ⌈a / r⌉` multiples of `r` in `[a, b)`, if `a ≤ b`. -/\ntheorem Ico_filter_dvd_card : #{x ∈ Ico a b | r ∣ x} = max (⌈b / (r : ℚ)⌉ - ⌈a / (r : ℚ)⌉) 0 := by\n  rw [Ico_filter_dvd_eq _ _ hr, card_map, card_Ico, toNat_eq_max]\n\n"}
{"name":"Int.Ioc_filter_dvd_card","module":"Mathlib.Data.Int.CardIntervalMod","initialProofState":"a b r : Int\nhr : LT.lt 0 r\n⊢ Eq (↑(Finset.filter (fun x => Dvd.dvd r x) (Finset.Ioc a b)).card) (Max.max (HSub.hSub (Int.floor (HDiv.hDiv ↑b ↑r)) (Int.floor (HDiv.hDiv ↑a ↑r))) 0)","decl":"/-- There are `⌊b / r⌋ - ⌊a / r⌋` multiples of `r` in `(a, b]`, if `a ≤ b`. -/\ntheorem Ioc_filter_dvd_card : #{x ∈ Ioc a b | r ∣ x} = max (⌊b / (r : ℚ)⌋ - ⌊a / (r : ℚ)⌋) 0 := by\n  rw [Ioc_filter_dvd_eq _ _ hr, card_map, card_Ioc, toNat_eq_max]\n\n"}
{"name":"Int.Ico_filter_modEq_card","module":"Mathlib.Data.Int.CardIntervalMod","initialProofState":"a b r : Int\nhr : LT.lt 0 r\nv : Int\n⊢ Eq (↑(Finset.filter (fun x => r.ModEq x v) (Finset.Ico a b)).card) (Max.max (HSub.hSub (Int.ceil (HDiv.hDiv (HSub.hSub ↑b ↑v) ↑r)) (Int.ceil (HDiv.hDiv (HSub.hSub ↑a ↑v) ↑r))) 0)","decl":"/-- There are `⌈(b - v) / r⌉ - ⌈(a - v) / r⌉` numbers congruent to `v` mod `r` in `[a, b)`,\nif `a ≤ b`. -/\ntheorem Ico_filter_modEq_card (v : ℤ) :\n    #{x ∈ Ico a b | x ≡ v [ZMOD r]} = max (⌈(b - v) / (r : ℚ)⌉ - ⌈(a - v) / (r : ℚ)⌉) 0 := by\n  simp [Ico_filter_modEq_eq, Ico_filter_dvd_eq, toNat_eq_max, hr]\n\n"}
{"name":"Int.Ioc_filter_modEq_card","module":"Mathlib.Data.Int.CardIntervalMod","initialProofState":"a b r : Int\nhr : LT.lt 0 r\nv : Int\n⊢ Eq (↑(Finset.filter (fun x => r.ModEq x v) (Finset.Ioc a b)).card) (Max.max (HSub.hSub (Int.floor (HDiv.hDiv (HSub.hSub ↑b ↑v) ↑r)) (Int.floor (HDiv.hDiv (HSub.hSub ↑a ↑v) ↑r))) 0)","decl":"/-- There are `⌊(b - v) / r⌋ - ⌊(a - v) / r⌋` numbers congruent to `v` mod `r` in `(a, b]`,\nif `a ≤ b`. -/\ntheorem Ioc_filter_modEq_card (v : ℤ) :\n    #{x ∈ Ioc a b | x ≡ v [ZMOD r]} = max (⌊(b - v) / (r : ℚ)⌋ - ⌊(a - v) / (r : ℚ)⌋) 0 := by\n  simp [Ioc_filter_modEq_eq, Ioc_filter_dvd_eq, toNat_eq_max, hr]\n\n"}
{"name":"Nat.Ico_filter_modEq_cast","module":"Mathlib.Data.Int.CardIntervalMod","initialProofState":"a b r v : Nat\n⊢ Eq (Finset.map Nat.castEmbedding (Finset.filter (fun x => r.ModEq x v) (Finset.Ico a b))) (Finset.filter (fun x => (↑r).ModEq x ↑v) (Finset.Ico ↑a ↑b))","decl":"lemma Ico_filter_modEq_cast {v : ℕ} :\n    {x ∈ Ico a b | x ≡ v [MOD r]}.map castEmbedding =\n      {x ∈ Ico (a : ℤ) (b : ℤ) | x ≡ v [ZMOD r]} := by\n  ext x\n  simp only [mem_map, mem_filter, mem_Ico, castEmbedding_apply]\n  constructor\n  · simp_rw [forall_exists_index, ← natCast_modEq_iff]; intro y ⟨h, c⟩; subst c; exact_mod_cast h\n  · intro h; lift x to ℕ using (by omega); exact ⟨x, by simp_all [natCast_modEq_iff]⟩\n\n"}
{"name":"Nat.Ioc_filter_modEq_cast","module":"Mathlib.Data.Int.CardIntervalMod","initialProofState":"a b r v : Nat\n⊢ Eq (Finset.map Nat.castEmbedding (Finset.filter (fun x => r.ModEq x v) (Finset.Ioc a b))) (Finset.filter (fun x => (↑r).ModEq x ↑v) (Finset.Ioc ↑a ↑b))","decl":"lemma Ioc_filter_modEq_cast {v : ℕ} :\n    {x ∈ Ioc a b | x ≡ v [MOD r]}.map castEmbedding =\n      {x ∈ Ioc (a : ℤ) (b : ℤ) | x ≡ v [ZMOD r]} := by\n  ext x\n  simp only [mem_map, mem_filter, mem_Ioc, castEmbedding_apply]\n  constructor\n  · simp_rw [forall_exists_index, ← natCast_modEq_iff]; intro y ⟨h, c⟩; subst c; exact_mod_cast h\n  · intro h; lift x to ℕ using (by omega); exact ⟨x, by simp_all [natCast_modEq_iff]⟩\n\n"}
{"name":"Nat.Ico_filter_modEq_card","module":"Mathlib.Data.Int.CardIntervalMod","initialProofState":"a b r : Nat\nhr : LT.lt 0 r\nv : Nat\n⊢ Eq (↑(Finset.filter (fun x => r.ModEq x v) (Finset.Ico a b)).card) (Max.max (HSub.hSub (Int.ceil (HDiv.hDiv (HSub.hSub ↑b ↑v) ↑r)) (Int.ceil (HDiv.hDiv (HSub.hSub ↑a ↑v) ↑r))) 0)","decl":"/-- There are `⌈(b - v) / r⌉ - ⌈(a - v) / r⌉` numbers congruent to `v` mod `r` in `[a, b)`,\nif `a ≤ b`. `Nat` version of `Int.Ico_filter_modEq_card`. -/\ntheorem Ico_filter_modEq_card (v : ℕ) :\n    #{x ∈ Ico a b | x ≡ v [MOD r]} = max (⌈(b - v) / (r : ℚ)⌉ - ⌈(a - v) / (r : ℚ)⌉) 0 := by\n  simp_rw [← Ico_filter_modEq_cast _ _ ▸ card_map _,\n    Int.Ico_filter_modEq_card _ _ (cast_lt.mpr hr), Int.cast_natCast]\n\n"}
{"name":"Nat.Ioc_filter_modEq_card","module":"Mathlib.Data.Int.CardIntervalMod","initialProofState":"a b r : Nat\nhr : LT.lt 0 r\nv : Nat\n⊢ Eq (↑(Finset.filter (fun x => r.ModEq x v) (Finset.Ioc a b)).card) (Max.max (HSub.hSub (Int.floor (HDiv.hDiv (HSub.hSub ↑b ↑v) ↑r)) (Int.floor (HDiv.hDiv (HSub.hSub ↑a ↑v) ↑r))) 0)","decl":"/-- There are `⌊(b - v) / r⌋ - ⌊(a - v) / r⌋` numbers congruent to `v` mod `r` in `(a, b]`,\nif `a ≤ b`. `Nat` version of `Int.Ioc_filter_modEq_card`. -/\ntheorem Ioc_filter_modEq_card (v : ℕ) :\n    #{x ∈ Ioc a b | x ≡ v [MOD r]} = max (⌊(b - v) / (r : ℚ)⌋ - ⌊(a - v) / (r : ℚ)⌋) 0 := by\n  simp_rw [← Ioc_filter_modEq_cast _ _ ▸ card_map _,\n    Int.Ioc_filter_modEq_card _ _ (cast_lt.mpr hr), Int.cast_natCast]\n\n"}
{"name":"Nat.count_modEq_card_eq_ceil","module":"Mathlib.Data.Int.CardIntervalMod","initialProofState":"b r : Nat\nhr : LT.lt 0 r\nv : Nat\n⊢ Eq (↑(Nat.count (fun x => r.ModEq x v) b)) (Int.ceil (HDiv.hDiv (HSub.hSub ↑b ↑(HMod.hMod v r)) ↑r))","decl":"/-- There are `⌈(b - v % r) / r⌉` numbers in `[0, b)` congruent to `v` mod `r`. -/\ntheorem count_modEq_card_eq_ceil (v : ℕ) :\n    b.count (· ≡ v [MOD r]) = ⌈(b - (v % r : ℕ)) / (r : ℚ)⌉ := by\n  have hr' : 0 < (r : ℚ) := by positivity\n  rw [count_eq_card_filter_range, ← Ico_zero_eq_range, Ico_filter_modEq_card _ _ hr,\n    max_eq_left (sub_nonneg.mpr <| by gcongr <;> positivity)]\n  conv_lhs =>\n    rw [← div_add_mod v r, cast_add, cast_mul, add_comm]\n    tactic => simp_rw [← sub_sub, sub_div (_ - _), mul_div_cancel_left₀ _ hr'.ne', ceil_sub_nat]\n    rw [sub_sub_sub_cancel_right, cast_zero, zero_sub]\n  rw [sub_eq_self, ceil_eq_zero_iff, Set.mem_Ioc, div_le_iff₀ hr', lt_div_iff₀ hr', neg_one_mul,\n    zero_mul, neg_lt_neg_iff, cast_lt]\n  exact ⟨mod_lt _ hr, by simp⟩\n\n"}
{"name":"Nat.count_modEq_card","module":"Mathlib.Data.Int.CardIntervalMod","initialProofState":"b r : Nat\nhr : LT.lt 0 r\nv : Nat\n⊢ Eq (Nat.count (fun x => r.ModEq x v) b) (HAdd.hAdd (HDiv.hDiv b r) (ite (LT.lt (HMod.hMod v r) (HMod.hMod b r)) 1 0))","decl":"/-- There are `b / r + [v % r < b % r]` numbers in `[0, b)` congruent to `v` mod `r`,\nwhere `[·]` is the Iverson bracket. -/\ntheorem count_modEq_card (v : ℕ) :\n    b.count (· ≡ v [MOD r]) = b / r + if v % r < b % r then 1 else 0 := by\n  have hr' : 0 < (r : ℚ) := by positivity\n  rw [← ofNat_inj, count_modEq_card_eq_ceil _ hr, cast_add]\n  conv_lhs => rw [← div_add_mod b r, cast_add, cast_mul, ← add_sub, _root_.add_div,\n    mul_div_cancel_left₀ _ hr'.ne', add_comm, Int.ceil_add_nat, add_comm]\n  rw [add_right_inj]\n  split_ifs with h\n  · rw [← cast_sub h.le, Int.ceil_eq_iff, div_le_iff₀ hr', lt_div_iff₀ hr', cast_one, Int.cast_one,\n      sub_self, zero_mul, cast_pos, tsub_pos_iff_lt, one_mul, cast_le, tsub_le_iff_right]\n    exact ⟨h, ((mod_lt _ hr).trans_le (by simp)).le⟩\n  · rw [cast_zero, ceil_eq_zero_iff, Set.mem_Ioc, div_le_iff₀ hr', lt_div_iff₀ hr', zero_mul,\n      tsub_nonpos, ← neg_eq_neg_one_mul, neg_lt_sub_iff_lt_add, ← cast_add, cast_lt, cast_le]\n    exact ⟨(mod_lt _ hr).trans_le (by simp), not_lt.mp h⟩\n\n"}
