{"name":"Rel.ext","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr s : Rel α β\na✝ : ∀ (a : α), Eq (r a) (s a)\n⊢ Eq r s","decl":"@[ext] theorem ext {r s : Rel α β} : (∀ a, r a = s a) → r = s := funext\n\n"}
{"name":"Rel.ext_iff","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr s : Rel α β\n⊢ Iff (Eq r s) (∀ (a : α), Eq (r a) (s a))","decl":"@[ext] theorem ext {r s : Rel α β} : (∀ a, r a = s a) → r = s := funext\n\n"}
{"name":"Rel.inv_def","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\nx : α\ny : β\n⊢ Iff (r.inv y x) (r x y)","decl":"theorem inv_def (x : α) (y : β) : r.inv y x ↔ r x y :=\n  Iff.rfl\n\n"}
{"name":"Rel.inv_inv","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\n⊢ Eq r.inv.inv r","decl":"theorem inv_inv : inv (inv r) = r := by\n  ext x y\n  rfl\n\n"}
{"name":"Rel.dom_mono","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr s : Rel α β\nh : LE.le r s\n⊢ HasSubset.Subset r.dom s.dom","decl":"theorem dom_mono {r s : Rel α β} (h : r ≤ s) : dom r ⊆ dom s := fun a ⟨b, hx⟩ => ⟨b, h a b hx⟩\n\n"}
{"name":"Rel.codom_inv","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\n⊢ Eq r.inv.codom r.dom","decl":"theorem codom_inv : r.inv.codom = r.dom := by\n  ext x\n  rfl\n\n"}
{"name":"Rel.dom_inv","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\n⊢ Eq r.inv.dom r.codom","decl":"theorem dom_inv : r.inv.dom = r.codom := by\n  ext x\n  rfl\n\n"}
{"name":"Rel.comp_assoc","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nr : Rel α β\ns : Rel β γ\nt : Rel γ δ\n⊢ Eq ((r.comp s).comp t) (r.comp (s.comp t))","decl":"theorem comp_assoc {δ : Type*} (r : Rel α β) (s : Rel β γ) (t : Rel γ δ) :\n    (r • s) • t = r • (s • t) := by\n  unfold comp; ext (x w); constructor\n  · rintro ⟨z, ⟨y, rxy, syz⟩, tzw⟩; exact ⟨y, rxy, z, syz, tzw⟩\n  · rintro ⟨y, rxy, z, syz, tzw⟩; exact ⟨z, ⟨y, rxy, syz⟩, tzw⟩\n\n"}
{"name":"Rel.comp_right_id","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\n⊢ Eq (r.comp Eq) r","decl":"@[simp]\ntheorem comp_right_id (r : Rel α β) : r • @Eq β = r := by\n  unfold comp\n  ext y\n  simp\n\n"}
{"name":"Rel.comp_left_id","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\n⊢ Eq (Rel.comp Eq r) r","decl":"@[simp]\ntheorem comp_left_id (r : Rel α β) : @Eq α • r = r := by\n  unfold comp\n  ext x\n  simp\n\n"}
{"name":"Rel.comp_right_bot","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr : Rel α β\n⊢ Eq (r.comp Bot.bot) Bot.bot","decl":"@[simp]\ntheorem comp_right_bot (r : Rel α β) : r • (⊥ : Rel β γ) = ⊥ := by\n  ext x y\n  simp [comp, Bot.bot]\n\n"}
{"name":"Rel.comp_left_bot","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr : Rel α β\n⊢ Eq (Bot.bot.comp r) Bot.bot","decl":"@[simp]\ntheorem comp_left_bot (r : Rel α β) : (⊥ : Rel γ α) • r = ⊥ := by\n  ext x y\n  simp [comp, Bot.bot]\n\n"}
{"name":"Rel.comp_right_top","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr : Rel α β\n⊢ Eq (r.comp Top.top) fun x x_1 => Membership.mem r.dom x","decl":"@[simp]\ntheorem comp_right_top (r : Rel α β) : r • (⊤ : Rel β γ) = fun x _ ↦ x ∈ r.dom := by\n  ext x z\n  simp [comp, Top.top, dom]\n\n"}
{"name":"Rel.comp_left_top","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr : Rel α β\n⊢ Eq (Top.top.comp r) fun x y => Membership.mem r.codom y","decl":"@[simp]\ntheorem comp_left_top (r : Rel α β) : (⊤ : Rel γ α) • r = fun _ y ↦ y ∈ r.codom := by\n  ext x z\n  simp [comp, Top.top, codom]\n\n"}
{"name":"Rel.inv_id","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\n⊢ Eq (Rel.inv Eq) Eq","decl":"theorem inv_id : inv (@Eq α) = @Eq α := by\n  ext x y\n  constructor <;> apply Eq.symm\n\n"}
{"name":"Rel.inv_comp","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr : Rel α β\ns : Rel β γ\n⊢ Eq (r.comp s).inv (s.inv.comp r.inv)","decl":"theorem inv_comp (r : Rel α β) (s : Rel β γ) : inv (r • s) = inv s • inv r := by\n  ext x z\n  simp [comp, inv, flip, and_comm]\n\n"}
{"name":"Rel.inv_bot","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Eq Bot.bot.inv Bot.bot","decl":"@[simp]\ntheorem inv_bot : (⊥ : Rel α β).inv = (⊥ : Rel β α) := by\n  simp [Bot.bot, inv, Function.flip_def]\n\n"}
{"name":"Rel.inv_top","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Eq Top.top.inv Top.top","decl":"@[simp]\ntheorem inv_top : (⊤ : Rel α β).inv = (⊤ : Rel β α) := by\n  simp [Top.top, inv, Function.flip_def]\n\n"}
{"name":"Rel.mem_image","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\ny : β\ns : Set α\n⊢ Iff (Membership.mem (r.image s) y) (Exists fun x => And (Membership.mem s x) (r x y))","decl":"theorem mem_image (y : β) (s : Set α) : y ∈ image r s ↔ ∃ x ∈ s, r x y :=\n  Iff.rfl\n\n"}
{"name":"Rel.image_subset","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\n⊢ Relator.LiftFun (fun x1 x2 => HasSubset.Subset x1 x2) (fun x1 x2 => HasSubset.Subset x1 x2) r.image r.image","decl":"theorem image_subset : ((· ⊆ ·) ⇒ (· ⊆ ·)) r.image r.image := fun _ _ h _ ⟨x, xs, rxy⟩ =>\n  ⟨x, h xs, rxy⟩\n\n"}
{"name":"Rel.image_mono","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\n⊢ Monotone r.image","decl":"theorem image_mono : Monotone r.image :=\n  r.image_subset\n\n"}
{"name":"Rel.image_inter","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\ns t : Set α\n⊢ HasSubset.Subset (r.image (Inter.inter s t)) (Inter.inter (r.image s) (r.image t))","decl":"theorem image_inter (s t : Set α) : r.image (s ∩ t) ⊆ r.image s ∩ r.image t :=\n  r.image_mono.map_inf_le s t\n\n"}
{"name":"Rel.image_union","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\ns t : Set α\n⊢ Eq (r.image (Union.union s t)) (Union.union (r.image s) (r.image t))","decl":"theorem image_union (s t : Set α) : r.image (s ∪ t) = r.image s ∪ r.image t :=\n  le_antisymm\n    (fun _y ⟨x, xst, rxy⟩ =>\n      xst.elim (fun xs => Or.inl ⟨x, ⟨xs, rxy⟩⟩) fun xt => Or.inr ⟨x, ⟨xt, rxy⟩⟩)\n    (r.image_mono.le_map_sup s t)\n\n"}
{"name":"Rel.image_id","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (Rel.image Eq s) s","decl":"@[simp]\ntheorem image_id (s : Set α) : image (@Eq α) s = s := by\n  ext x\n  simp [mem_image]\n\n"}
{"name":"Rel.image_comp","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr : Rel α β\ns : Rel β γ\nt : Set α\n⊢ Eq ((r.comp s).image t) (s.image (r.image t))","decl":"theorem image_comp (s : Rel β γ) (t : Set α) : image (r • s) t = image s (image r t) := by\n  ext z; simp only [mem_image]; constructor\n  · rintro ⟨x, xt, y, rxy, syz⟩; exact ⟨y, ⟨x, xt, rxy⟩, syz⟩\n  · rintro ⟨y, ⟨x, xt, rxy⟩, syz⟩; exact ⟨x, xt, y, rxy, syz⟩\n\n"}
{"name":"Rel.image_univ","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\n⊢ Eq (r.image Set.univ) r.codom","decl":"theorem image_univ : r.image Set.univ = r.codom := by\n  ext y\n  simp [mem_image, codom]\n\n"}
{"name":"Rel.image_empty","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\n⊢ Eq (r.image EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem image_empty : r.image ∅ = ∅ := by\n  ext x\n  simp [mem_image]\n\n"}
{"name":"Rel.image_bot","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\n⊢ Eq (Bot.bot.image s) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem image_bot (s : Set α) : (⊥ : Rel α β).image s = ∅ := by\n  rw [Set.eq_empty_iff_forall_not_mem]\n  intro x h\n  simp [mem_image, Bot.bot] at h\n\n"}
{"name":"Rel.image_top","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nh : s.Nonempty\n⊢ Eq (Top.top.image s) Set.univ","decl":"@[simp]\ntheorem image_top {s : Set α} (h : Set.Nonempty s) :\n    (⊤ : Rel α β).image s = Set.univ :=\n  Set.eq_univ_of_forall fun _ ↦ ⟨h.some, by simp [h.some_mem, Top.top]⟩\n\n"}
{"name":"Rel.mem_preimage","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\nx : α\ns : Set β\n⊢ Iff (Membership.mem (r.preimage s) x) (Exists fun y => And (Membership.mem s y) (r x y))","decl":"theorem mem_preimage (x : α) (s : Set β) : x ∈ r.preimage s ↔ ∃ y ∈ s, r x y :=\n  Iff.rfl\n\n"}
{"name":"Rel.preimage_def","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\ns : Set β\n⊢ Eq (r.preimage s) (setOf fun x => Exists fun y => And (Membership.mem s y) (r x y))","decl":"theorem preimage_def (s : Set β) : preimage r s = { x | ∃ y ∈ s, r x y } :=\n  Set.ext fun _ => mem_preimage _ _ _\n\n"}
{"name":"Rel.preimage_mono","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\ns t : Set β\nh : HasSubset.Subset s t\n⊢ HasSubset.Subset (r.preimage s) (r.preimage t)","decl":"theorem preimage_mono {s t : Set β} (h : s ⊆ t) : r.preimage s ⊆ r.preimage t :=\n  image_mono _ h\n\n"}
{"name":"Rel.preimage_inter","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\ns t : Set β\n⊢ HasSubset.Subset (r.preimage (Inter.inter s t)) (Inter.inter (r.preimage s) (r.preimage t))","decl":"theorem preimage_inter (s t : Set β) : r.preimage (s ∩ t) ⊆ r.preimage s ∩ r.preimage t :=\n  image_inter _ s t\n\n"}
{"name":"Rel.preimage_union","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\ns t : Set β\n⊢ Eq (r.preimage (Union.union s t)) (Union.union (r.preimage s) (r.preimage t))","decl":"theorem preimage_union (s t : Set β) : r.preimage (s ∪ t) = r.preimage s ∪ r.preimage t :=\n  image_union _ s t\n\n"}
{"name":"Rel.preimage_id","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (Rel.preimage Eq s) s","decl":"theorem preimage_id (s : Set α) : preimage (@Eq α) s = s := by\n  simp only [preimage, inv_id, image_id]\n\n"}
{"name":"Rel.preimage_comp","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr : Rel α β\ns : Rel β γ\nt : Set γ\n⊢ Eq ((r.comp s).preimage t) (r.preimage (s.preimage t))","decl":"theorem preimage_comp (s : Rel β γ) (t : Set γ) :\n    preimage (r • s) t = preimage r (preimage s t) := by simp only [preimage, inv_comp, image_comp]\n\n"}
{"name":"Rel.preimage_univ","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\n⊢ Eq (r.preimage Set.univ) r.dom","decl":"theorem preimage_univ : r.preimage Set.univ = r.dom := by rw [preimage, image_univ, codom_inv]\n\n"}
{"name":"Rel.preimage_empty","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\n⊢ Eq (r.preimage EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem preimage_empty : r.preimage ∅ = ∅ := by rw [preimage, image_empty]\n\n"}
{"name":"Rel.preimage_inv","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\ns : Set α\n⊢ Eq (r.inv.preimage s) (r.image s)","decl":"@[simp]\ntheorem preimage_inv (s : Set α) : r.inv.preimage s = r.image s := by rw [preimage, inv_inv]\n\n"}
{"name":"Rel.preimage_bot","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set β\n⊢ Eq (Bot.bot.preimage s) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem preimage_bot (s : Set β) : (⊥ : Rel α β).preimage s = ∅ := by\n  rw [preimage, inv_bot, image_bot]\n\n"}
{"name":"Rel.preimage_top","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set β\nh : s.Nonempty\n⊢ Eq (Top.top.preimage s) Set.univ","decl":"@[simp]\ntheorem preimage_top {s : Set β} (h : Set.Nonempty s) :\n    (⊤ : Rel α β).preimage s = Set.univ := by rwa [← inv_top, preimage, inv_inv, image_top]\n\n"}
{"name":"Rel.image_eq_dom_of_codomain_subset","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\ns : Set β\nh : HasSubset.Subset r.codom s\n⊢ Eq (r.preimage s) r.dom","decl":"theorem image_eq_dom_of_codomain_subset {s : Set β} (h : r.codom ⊆ s) : r.preimage s = r.dom := by\n  rw [← preimage_univ]\n  apply Set.eq_of_subset_of_subset\n  · exact image_subset _ (Set.subset_univ _)\n  · intro x hx\n    simp only [mem_preimage, Set.mem_univ, true_and] at hx\n    rcases hx with ⟨y, ryx⟩\n    have hy : y ∈ s := h ⟨x, ryx⟩\n    exact ⟨y, ⟨hy, ryx⟩⟩\n\n"}
{"name":"Rel.preimage_eq_codom_of_domain_subset","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\ns : Set α\nh : HasSubset.Subset r.dom s\n⊢ Eq (r.image s) r.codom","decl":"theorem preimage_eq_codom_of_domain_subset {s : Set α} (h : r.dom ⊆ s) : r.image s = r.codom := by\n  apply r.inv.image_eq_dom_of_codomain_subset (by rwa [← codom_inv] at h)\n\n"}
{"name":"Rel.image_inter_dom_eq","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\ns : Set α\n⊢ Eq (r.image (Inter.inter s r.dom)) (r.image s)","decl":"theorem image_inter_dom_eq (s : Set α) : r.image (s ∩ r.dom) = r.image s := by\n  apply Set.eq_of_subset_of_subset\n  · apply r.image_mono (by simp)\n  · intro x h\n    rw [mem_image] at *\n    rcases h with ⟨y, hy, ryx⟩\n    use y\n    suffices h : y ∈ r.dom by simp_all only [Set.mem_inter_iff, and_self]\n    rw [dom, Set.mem_setOf_eq]\n    use x\n\n"}
{"name":"Rel.preimage_inter_codom_eq","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\ns : Set β\n⊢ Eq (r.preimage (Inter.inter s r.codom)) (r.preimage s)","decl":"@[simp]\ntheorem preimage_inter_codom_eq (s : Set β) : r.preimage (s ∩ r.codom) = r.preimage s := by\n  rw [← dom_inv, preimage, preimage, image_inter_dom_eq]\n\n"}
{"name":"Rel.inter_dom_subset_preimage_image","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\ns : Set α\n⊢ HasSubset.Subset (Inter.inter s r.dom) (r.preimage (r.image s))","decl":"theorem inter_dom_subset_preimage_image (s : Set α) : s ∩ r.dom ⊆ r.preimage (r.image s) := by\n  intro x hx\n  simp only [Set.mem_inter_iff, dom] at hx\n  rcases hx with ⟨hx, ⟨y, rxy⟩⟩\n  use y\n  simp only [image, Set.mem_setOf_eq]\n  exact ⟨⟨x, hx, rxy⟩, rxy⟩\n\n"}
{"name":"Rel.image_preimage_subset_inter_codom","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\ns : Set β\n⊢ HasSubset.Subset (Inter.inter s r.codom) (r.image (r.preimage s))","decl":"theorem image_preimage_subset_inter_codom (s : Set β) : s ∩ r.codom ⊆ r.image (r.preimage s) := by\n  rw [← dom_inv, ← preimage_inv]\n  apply inter_dom_subset_preimage_image\n\n"}
{"name":"Rel.mem_core","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\nx : α\ns : Set β\n⊢ Iff (Membership.mem (r.core s) x) (∀ (y : β), r x y → Membership.mem s y)","decl":"theorem mem_core (x : α) (s : Set β) : x ∈ r.core s ↔ ∀ y, r x y → y ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Rel.core_subset","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\n⊢ Relator.LiftFun (fun x1 x2 => HasSubset.Subset x1 x2) (fun x1 x2 => HasSubset.Subset x1 x2) r.core r.core","decl":"theorem core_subset : ((· ⊆ ·) ⇒ (· ⊆ ·)) r.core r.core := fun _s _t h _x h' y rxy => h (h' y rxy)\n\n"}
{"name":"Rel.core_mono","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\n⊢ Monotone r.core","decl":"theorem core_mono : Monotone r.core :=\n  r.core_subset\n\n"}
{"name":"Rel.core_inter","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\ns t : Set β\n⊢ Eq (r.core (Inter.inter s t)) (Inter.inter (r.core s) (r.core t))","decl":"theorem core_inter (s t : Set β) : r.core (s ∩ t) = r.core s ∩ r.core t :=\n  Set.ext (by simp [mem_core, imp_and, forall_and])\n\n"}
{"name":"Rel.core_union","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\ns t : Set β\n⊢ HasSubset.Subset (Union.union (r.core s) (r.core t)) (r.core (Union.union s t))","decl":"theorem core_union (s t : Set β) : r.core s ∪ r.core t ⊆ r.core (s ∪ t) :=\n  r.core_mono.le_map_sup s t\n\n"}
{"name":"Rel.core_univ","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\n⊢ Eq (r.core Set.univ) Set.univ","decl":"@[simp]\ntheorem core_univ : r.core Set.univ = Set.univ :=\n  Set.ext (by simp [mem_core])\n\n"}
{"name":"Rel.core_id","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (Rel.core Eq s) s","decl":"theorem core_id (s : Set α) : core (@Eq α) s = s := by simp [core]\n\n"}
{"name":"Rel.core_comp","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr : Rel α β\ns : Rel β γ\nt : Set γ\n⊢ Eq ((r.comp s).core t) (r.core (s.core t))","decl":"theorem core_comp (s : Rel β γ) (t : Set γ) : core (r • s) t = core r (core s t) := by\n  ext x; simp only [core, comp, forall_exists_index, and_imp, Set.mem_setOf_eq]; constructor\n  · exact fun h y rxy z => h z y rxy\n  · exact fun h z y rzy => h y rzy z\n\n"}
{"name":"Rel.image_subset_iff","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\ns : Set α\nt : Set β\n⊢ Iff (HasSubset.Subset (r.image s) t) (HasSubset.Subset s (r.core t))","decl":"theorem image_subset_iff (s : Set α) (t : Set β) : image r s ⊆ t ↔ s ⊆ core r t :=\n  Iff.intro (fun h x xs _y rxy => h ⟨x, xs, rxy⟩) fun h y ⟨_x, xs, rxy⟩ => h xs y rxy\n\n"}
{"name":"Rel.image_core_gc","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\n⊢ GaloisConnection r.image r.core","decl":"theorem image_core_gc : GaloisConnection r.image r.core :=\n  image_subset_iff _\n\n"}
{"name":"Function.graph_def","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nx : α\ny : β\n⊢ Iff (Function.graph f x y) (Eq (f x) y)","decl":"@[simp] lemma graph_def (f : α → β) (x y) : f.graph x y ↔ (f x = y) := Iff.rfl\n\n"}
{"name":"Function.graph_injective","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Function.Injective Function.graph","decl":"theorem graph_injective : Injective (graph : (α → β) → Rel α β) := by\n  intro _ g h\n  ext x\n  have h2 := congr_fun₂ h x (g x)\n  simp only [graph_def, eq_iff_iff, iff_true] at h2\n  exact h2\n\n"}
{"name":"Function.graph_inj","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → β\n⊢ Iff (Eq (Function.graph f) (Function.graph g)) (Eq f g)","decl":"@[simp] lemma graph_inj {f g : α → β} : f.graph = g.graph ↔ f = g := graph_injective.eq_iff\n\n"}
{"name":"Function.graph_id","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\n⊢ Eq (Function.graph id) Eq","decl":"theorem graph_id : graph id = @Eq α := by simp (config := { unfoldPartialApp := true }) [graph]\n\n"}
{"name":"Function.graph_comp","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : β → γ\ng : α → β\n⊢ Eq (Function.graph (Function.comp f g)) ((Function.graph g).comp (Function.graph f))","decl":"theorem graph_comp {f : β → γ} {g : α → β} : graph (f ∘ g) = Rel.comp (graph g) (graph f) := by\n  ext x y\n  simp [Rel.comp]\n\n"}
{"name":"Equiv.graph_inv","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Equiv α β\n⊢ Eq (Function.graph ⇑f.symm) (Function.graph ⇑f).inv","decl":"theorem Equiv.graph_inv (f : α ≃ β) : (f.symm : β → α).graph = Rel.inv (f : α → β).graph := by\n  ext x y\n  aesop (add norm Rel.inv_def)\n\n"}
{"name":"Relation.is_graph_iff","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Rel α β\n⊢ Iff (ExistsUnique fun f => Eq (Function.graph f) r) (∀ (x : α), ExistsUnique fun y => r x y)","decl":"theorem Relation.is_graph_iff (r : Rel α β) : (∃! f, Function.graph f = r) ↔ ∀ x, ∃! y, r x y := by\n  unfold Function.graph\n  constructor\n  · rintro ⟨f, rfl, _⟩ x\n    use f x\n    simp only [forall_eq', and_self]\n  · intro h\n    choose f hf using fun x ↦ (h x).exists\n    use f\n    constructor\n    · ext x _\n      constructor\n      · rintro rfl\n        exact hf x\n      · exact (h x).unique (hf x)\n    · rintro _ rfl\n      exact funext hf\n\n"}
{"name":"Set.image_eq","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\n⊢ Eq (Set.image f s) ((Function.graph f).image s)","decl":"theorem image_eq (f : α → β) (s : Set α) : f '' s = (Function.graph f).image s := by\n  rfl\n\n"}
{"name":"Set.preimage_eq","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set β\n⊢ Eq (Set.preimage f s) ((Function.graph f).preimage s)","decl":"theorem preimage_eq (f : α → β) (s : Set β) : f ⁻¹' s = (Function.graph f).preimage s := by\n  simp [Set.preimage, Rel.preimage, Rel.inv, flip, Rel.image]\n\n"}
{"name":"Set.preimage_eq_core","module":"Mathlib.Data.Rel","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set β\n⊢ Eq (Set.preimage f s) ((Function.graph f).core s)","decl":"theorem preimage_eq_core (f : α → β) (s : Set β) : f ⁻¹' s = (Function.graph f).core s := by\n  simp [Set.preimage, Rel.core]\n\n"}
