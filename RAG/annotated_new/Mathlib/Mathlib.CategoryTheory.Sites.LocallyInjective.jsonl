{"name":"CategoryTheory.Presheaf.equalizerSieve_apply","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} D\ninst✝ : CategoryTheory.HasForget D\nF : CategoryTheory.Functor (Opposite C) D\nX : Opposite C\nx y : (CategoryTheory.forget D).obj (F.obj X)\nx✝ : C\nf : Quiver.Hom x✝ (Opposite.unop X)\n⊢ Eq ((CategoryTheory.Presheaf.equalizerSieve x y).arrows f) (Eq ((F.map f.op) x) ((F.map f.op) y))","decl":"/-- If `F : Cᵒᵖ ⥤ D` is a presheaf with values in a concrete category, if `x` and `y` are\nelements in `F.obj X`, this is the sieve of `X.unop` consisting of morphisms `f`\nsuch that `F.map f.op x = F.map f.op y`. -/\n@[simps]\ndef equalizerSieve {F : Cᵒᵖ ⥤ D} {X : Cᵒᵖ} (x y : F.obj X) : Sieve X.unop where\n  arrows _ f := F.map f.op x = F.map f.op y\n  downward_closed {X Y} f hf g := by\n    dsimp at hf ⊢\n    simp [hf]\n\n"}
{"name":"CategoryTheory.Presheaf.equalizerSieve_self_eq_top","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} D\ninst✝ : CategoryTheory.HasForget D\nF : CategoryTheory.Functor (Opposite C) D\nX : Opposite C\nx : (CategoryTheory.forget D).obj (F.obj X)\n⊢ Eq (CategoryTheory.Presheaf.equalizerSieve x x) Top.top","decl":"@[simp]\nlemma equalizerSieve_self_eq_top {F : Cᵒᵖ ⥤ D} {X : Cᵒᵖ} (x : F.obj X) :\n    equalizerSieve x x = ⊤ := by aesop\n\n"}
{"name":"CategoryTheory.Presheaf.equalizerSieve_eq_top_iff","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} D\ninst✝ : CategoryTheory.HasForget D\nF : CategoryTheory.Functor (Opposite C) D\nX : Opposite C\nx y : (CategoryTheory.forget D).obj (F.obj X)\n⊢ Iff (Eq (CategoryTheory.Presheaf.equalizerSieve x y) Top.top) (Eq x y)","decl":"@[simp]\nlemma equalizerSieve_eq_top_iff {F : Cᵒᵖ ⥤ D} {X : Cᵒᵖ} (x y : F.obj X) :\n    equalizerSieve x y = ⊤ ↔ x = y := by\n  constructor\n  · intro h\n    simpa using (show equalizerSieve x y (𝟙 _) by simp [h])\n  · rintro rfl\n    apply equalizerSieve_self_eq_top\n\n"}
{"name":"CategoryTheory.Presheaf.IsLocallyInjective.equalizerSieve_mem","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} D\ninst✝ : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF₁ F₂ : CategoryTheory.Functor (Opposite C) D\nφ : Quiver.Hom F₁ F₂\nself : CategoryTheory.Presheaf.IsLocallyInjective J φ\nX : Opposite C\nx y : (CategoryTheory.forget D).obj (F₁.obj X)\nh : Eq ((φ.app X) x) ((φ.app X) y)\n⊢ Membership.mem (J (Opposite.unop X)) (CategoryTheory.Presheaf.equalizerSieve x y)","decl":"/-- A morphism `φ : F₁ ⟶ F₂` of presheaves `Cᵒᵖ ⥤ D` (with `D` a concrete category)\nis locally injective for a Grothendieck topology `J` on `C` if\nwhenever two sections of `F₁` are sent to the same section of `F₂`, then these two\nsections coincide locally. -/\nclass IsLocallyInjective : Prop where\n  equalizerSieve_mem {X : Cᵒᵖ} (x y : F₁.obj X) (h : φ.app X x = φ.app X y) :\n    equalizerSieve x y ∈ J X.unop\n\n"}
{"name":"CategoryTheory.Presheaf.equalizerSieve_mem","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} D\ninst✝¹ : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF₁ F₂ : CategoryTheory.Functor (Opposite C) D\nφ : Quiver.Hom F₁ F₂\ninst✝ : CategoryTheory.Presheaf.IsLocallyInjective J φ\nX : Opposite C\nx y : (CategoryTheory.forget D).obj (F₁.obj X)\nh : Eq ((φ.app X) x) ((φ.app X) y)\n⊢ Membership.mem (J (Opposite.unop X)) (CategoryTheory.Presheaf.equalizerSieve x y)","decl":"lemma equalizerSieve_mem [IsLocallyInjective J φ]\n    {X : Cᵒᵖ} (x y : F₁.obj X) (h : φ.app X x = φ.app X y) :\n    equalizerSieve x y ∈ J X.unop :=\n  IsLocallyInjective.equalizerSieve_mem x y h\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallyInjective_of_injective","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} D\ninst✝ : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF₁ F₂ : CategoryTheory.Functor (Opposite C) D\nφ : Quiver.Hom F₁ F₂\nhφ : ∀ (X : Opposite C), Function.Injective ⇑(φ.app X)\n⊢ CategoryTheory.Presheaf.IsLocallyInjective J φ","decl":"lemma isLocallyInjective_of_injective (hφ : ∀ (X : Cᵒᵖ), Function.Injective (φ.app X)) :\n    IsLocallyInjective J φ where\n  equalizerSieve_mem {X} x y h := by\n    convert J.top_mem X.unop\n    ext Y f\n    simp only [equalizerSieve_apply, op_unop, Sieve.top_apply, iff_true]\n    apply hφ\n    simp [h]\n\n"}
{"name":"CategoryTheory.Presheaf.instIsLocallyInjectiveOfIsIsoFunctorOpposite","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} D\ninst✝¹ : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF₁ F₂ : CategoryTheory.Functor (Opposite C) D\nφ : Quiver.Hom F₁ F₂\ninst✝ : CategoryTheory.IsIso φ\n⊢ CategoryTheory.Presheaf.IsLocallyInjective J φ","decl":"instance [IsIso φ] : IsLocallyInjective J φ :=\n  isLocallyInjective_of_injective J φ (fun X => Function.Bijective.injective (by\n    rw [← isIso_iff_bijective]\n    change IsIso ((forget D).map (φ.app X))\n    infer_instance))\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallyInjective_forget","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} D\ninst✝¹ : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF₁ F₂ : CategoryTheory.Functor (Opposite C) D\nφ : Quiver.Hom F₁ F₂\ninst✝ : CategoryTheory.Presheaf.IsLocallyInjective J φ\n⊢ CategoryTheory.Presheaf.IsLocallyInjective J (CategoryTheory.whiskerRight φ (CategoryTheory.forget D))","decl":"instance isLocallyInjective_forget [IsLocallyInjective J φ] :\n    IsLocallyInjective J (whiskerRight φ (forget D)) where\n  equalizerSieve_mem x y h := equalizerSieve_mem J φ x y h\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallyInjective_forget_iff","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} D\ninst✝ : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF₁ F₂ : CategoryTheory.Functor (Opposite C) D\nφ : Quiver.Hom F₁ F₂\n⊢ Iff (CategoryTheory.Presheaf.IsLocallyInjective J (CategoryTheory.whiskerRight φ (CategoryTheory.forget D))) (CategoryTheory.Presheaf.IsLocallyInjective J φ)","decl":"lemma isLocallyInjective_forget_iff :\n    IsLocallyInjective J (whiskerRight φ (forget D)) ↔ IsLocallyInjective J φ := by\n  constructor\n  · intro\n    exact ⟨fun x y h => equalizerSieve_mem J (whiskerRight φ (forget D)) x y h⟩\n  · intro\n    infer_instance\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallyInjective_iff_equalizerSieve_mem_imp","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} D\ninst✝ : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF₁ F₂ : CategoryTheory.Functor (Opposite C) D\nφ : Quiver.Hom F₁ F₂\n⊢ Iff (CategoryTheory.Presheaf.IsLocallyInjective J φ) (∀ ⦃X : Opposite C⦄ (x y : (CategoryTheory.forget D).obj (F₁.obj X)), Membership.mem (J (Opposite.unop X)) (CategoryTheory.Presheaf.equalizerSieve ((φ.app X) x) ((φ.app X) y)) → Membership.mem (J (Opposite.unop X)) (CategoryTheory.Presheaf.equalizerSieve x y))","decl":"lemma isLocallyInjective_iff_equalizerSieve_mem_imp :\n    IsLocallyInjective J φ ↔ ∀ ⦃X : Cᵒᵖ⦄ (x y : F₁.obj X),\n      equalizerSieve (φ.app _ x) (φ.app _ y) ∈ J X.unop → equalizerSieve x y ∈ J X.unop := by\n  constructor\n  · intro _ X x y h\n    let S := equalizerSieve (φ.app _ x) (φ.app _ y)\n    let T : ∀ ⦃Y : C⦄ ⦃f : Y ⟶ X.unop⦄ (_ : S f), Sieve Y := fun Y f _ =>\n      equalizerSieve (F₁.map f.op x) ((F₁.map f.op y))\n    refine J.superset_covering ?_ (J.transitive h (Sieve.bind S.1 T) ?_)\n    · rintro Y f ⟨Z, a, g, hg, ha, rfl⟩\n      simpa using ha\n    · intro Y f hf\n      refine J.superset_covering (Sieve.le_pullback_bind S.1 T _ hf)\n        (equalizerSieve_mem J φ _ _ ?_)\n      rw [NatTrans.naturality_apply, NatTrans.naturality_apply]\n      exact hf\n  · intro hφ\n    exact ⟨fun {X} x y h => hφ x y (by simp [h])⟩\n\n"}
{"name":"CategoryTheory.Presheaf.equalizerSieve_mem_of_equalizerSieve_app_mem","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} D\ninst✝¹ : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF₁ F₂ : CategoryTheory.Functor (Opposite C) D\nφ : Quiver.Hom F₁ F₂\nX : Opposite C\nx y : (CategoryTheory.forget D).obj (F₁.obj X)\nh : Membership.mem (J (Opposite.unop X)) (CategoryTheory.Presheaf.equalizerSieve ((φ.app X) x) ((φ.app X) y))\ninst✝ : CategoryTheory.Presheaf.IsLocallyInjective J φ\n⊢ Membership.mem (J (Opposite.unop X)) (CategoryTheory.Presheaf.equalizerSieve x y)","decl":"lemma equalizerSieve_mem_of_equalizerSieve_app_mem\n    {X : Cᵒᵖ} (x y : F₁.obj X) (h : equalizerSieve (φ.app _ x) (φ.app _ y) ∈ J X.unop)\n    [IsLocallyInjective J φ] :\n    equalizerSieve x y ∈ J X.unop :=\n  (isLocallyInjective_iff_equalizerSieve_mem_imp J φ).1 inferInstance x y h\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallyInjective_comp","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} D\ninst✝² : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF₁ F₂ F₃ : CategoryTheory.Functor (Opposite C) D\nφ : Quiver.Hom F₁ F₂\nψ : Quiver.Hom F₂ F₃\ninst✝¹ : CategoryTheory.Presheaf.IsLocallyInjective J φ\ninst✝ : CategoryTheory.Presheaf.IsLocallyInjective J ψ\n⊢ CategoryTheory.Presheaf.IsLocallyInjective J (CategoryTheory.CategoryStruct.comp φ ψ)","decl":"instance isLocallyInjective_comp [IsLocallyInjective J φ] [IsLocallyInjective J ψ] :\n    IsLocallyInjective J (φ ≫ ψ) where\n  equalizerSieve_mem {X} x y h := by\n    apply equalizerSieve_mem_of_equalizerSieve_app_mem J φ\n    exact equalizerSieve_mem J ψ _ _ (by simpa using h)\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallyInjective_of_isLocallyInjective","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} D\ninst✝¹ : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF₁ F₂ F₃ : CategoryTheory.Functor (Opposite C) D\nφ : Quiver.Hom F₁ F₂\nψ : Quiver.Hom F₂ F₃\ninst✝ : CategoryTheory.Presheaf.IsLocallyInjective J (CategoryTheory.CategoryStruct.comp φ ψ)\n⊢ CategoryTheory.Presheaf.IsLocallyInjective J φ","decl":"lemma isLocallyInjective_of_isLocallyInjective [IsLocallyInjective J (φ ≫ ψ)] :\n    IsLocallyInjective J φ where\n  equalizerSieve_mem {X} x y h := equalizerSieve_mem J (φ ≫ ψ) x y (by simp [h])\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallyInjective_of_isLocallyInjective_fac","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} D\ninst✝¹ : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF₁ F₂ F₃ : CategoryTheory.Functor (Opposite C) D\nφ : Quiver.Hom F₁ F₂\nψ : Quiver.Hom F₂ F₃\nφψ : Quiver.Hom F₁ F₃\nfac : Eq (CategoryTheory.CategoryStruct.comp φ ψ) φψ\ninst✝ : CategoryTheory.Presheaf.IsLocallyInjective J φψ\n⊢ CategoryTheory.Presheaf.IsLocallyInjective J φ","decl":"lemma isLocallyInjective_of_isLocallyInjective_fac {φψ : F₁ ⟶ F₃} (fac : φ ≫ ψ = φψ)\n    [IsLocallyInjective J φψ] : IsLocallyInjective J φ := by\n  subst fac\n  exact isLocallyInjective_of_isLocallyInjective J φ ψ\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallyInjective_iff_of_fac","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} D\ninst✝¹ : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF₁ F₂ F₃ : CategoryTheory.Functor (Opposite C) D\nφ : Quiver.Hom F₁ F₂\nψ : Quiver.Hom F₂ F₃\nφψ : Quiver.Hom F₁ F₃\nfac : Eq (CategoryTheory.CategoryStruct.comp φ ψ) φψ\ninst✝ : CategoryTheory.Presheaf.IsLocallyInjective J ψ\n⊢ Iff (CategoryTheory.Presheaf.IsLocallyInjective J φψ) (CategoryTheory.Presheaf.IsLocallyInjective J φ)","decl":"lemma isLocallyInjective_iff_of_fac {φψ : F₁ ⟶ F₃} (fac : φ ≫ ψ = φψ) [IsLocallyInjective J ψ] :\n    IsLocallyInjective J φψ ↔ IsLocallyInjective J φ := by\n  constructor\n  · intro\n    exact isLocallyInjective_of_isLocallyInjective_fac J fac\n  · intro\n    rw [← fac]\n    infer_instance\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallyInjective_comp_iff","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} D\ninst✝¹ : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF₁ F₂ F₃ : CategoryTheory.Functor (Opposite C) D\nφ : Quiver.Hom F₁ F₂\nψ : Quiver.Hom F₂ F₃\ninst✝ : CategoryTheory.Presheaf.IsLocallyInjective J ψ\n⊢ Iff (CategoryTheory.Presheaf.IsLocallyInjective J (CategoryTheory.CategoryStruct.comp φ ψ)) (CategoryTheory.Presheaf.IsLocallyInjective J φ)","decl":"lemma isLocallyInjective_comp_iff [IsLocallyInjective J ψ] :\n    IsLocallyInjective J (φ ≫ ψ) ↔ IsLocallyInjective J φ :=\n  isLocallyInjective_iff_of_fac J rfl\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallyInjective_iff_injective_of_separated","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} D\ninst✝ : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF₁ F₂ : CategoryTheory.Functor (Opposite C) D\nφ : Quiver.Hom F₁ F₂\nhsep : CategoryTheory.Presieve.IsSeparated J (F₁.comp (CategoryTheory.forget D))\n⊢ Iff (CategoryTheory.Presheaf.IsLocallyInjective J φ) (∀ (X : Opposite C), Function.Injective ⇑(φ.app X))","decl":"lemma isLocallyInjective_iff_injective_of_separated\n    (hsep : Presieve.IsSeparated J (F₁ ⋙ forget D)) :\n    IsLocallyInjective J φ ↔ ∀ (X : Cᵒᵖ), Function.Injective (φ.app X) := by\n  constructor\n  · intro _ X x y h\n    exact (hsep _ (equalizerSieve_mem J φ x y h)).ext (fun _ _ hf => hf)\n  · apply isLocallyInjective_of_injective\n\n"}
{"name":"CategoryTheory.Presheaf.instIsLocallyInjectiveι","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nG : CategoryTheory.Subpresheaf F\n⊢ CategoryTheory.Presheaf.IsLocallyInjective J G.ι","decl":"instance (F : Cᵒᵖ ⥤ Type w) (G : Subpresheaf F) :\n    IsLocallyInjective J G.ι :=\n  isLocallyInjective_of_injective _ _ (fun X => by\n    intro ⟨x, _⟩ ⟨y, _⟩ h\n    exact Subtype.ext h)\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallyInjective_toPlus","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) (Type (max u v))\n⊢ CategoryTheory.Presheaf.IsLocallyInjective J (J.toPlus P)","decl":"instance isLocallyInjective_toPlus (P : Cᵒᵖ ⥤ Type max u v) :\n    IsLocallyInjective J (J.toPlus P) where\n  equalizerSieve_mem {X} x y h := by\n    rw [toPlus_eq_mk, toPlus_eq_mk, eq_mk_iff_exists] at h\n    obtain ⟨W, h₁, h₂, eq⟩ := h\n    exact J.superset_covering (fun Y f hf => congr_fun (congr_arg Subtype.val eq) ⟨Y, f, hf⟩) W.2\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallyInjective_toSheafify","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) (Type (max u v))\n⊢ CategoryTheory.Presheaf.IsLocallyInjective J (J.toSheafify P)","decl":"instance isLocallyInjective_toSheafify (P : Cᵒᵖ ⥤ Type max u v) :\n    IsLocallyInjective J (J.toSheafify P) := by\n  dsimp [GrothendieckTopology.toSheafify]\n  rw [GrothendieckTopology.plusMap_toPlus]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallyInjective_toSheafify'","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} D\nJ : CategoryTheory.GrothendieckTopology C\ninst✝³ : CategoryTheory.HasForget D\nP : CategoryTheory.Functor (Opposite C) D\ninst✝² : CategoryTheory.HasWeakSheafify J D\ninst✝¹ : J.HasSheafCompose (CategoryTheory.forget D)\ninst✝ : J.PreservesSheafification (CategoryTheory.forget D)\n⊢ CategoryTheory.Presheaf.IsLocallyInjective J (CategoryTheory.toSheafify J P)","decl":"instance isLocallyInjective_toSheafify' [HasForget.{max u v} D]\n    (P : Cᵒᵖ ⥤ D) [HasWeakSheafify J D] [J.HasSheafCompose (forget D)]\n    [J.PreservesSheafification (forget D)] :\n    IsLocallyInjective J (toSheafify J P) := by\n  rw [← isLocallyInjective_forget_iff, ← sheafComposeIso_hom_fac,\n    ← toSheafify_plusPlusIsoSheafify_hom]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Sheaf.isLocallyInjective_sheafToPresheaf_map_iff","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} D\ninst✝ : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF₁ F₂ : CategoryTheory.Sheaf J D\nφ : Quiver.Hom F₁ F₂\n⊢ Iff (CategoryTheory.Presheaf.IsLocallyInjective J ((CategoryTheory.sheafToPresheaf J D).map φ)) (CategoryTheory.Sheaf.IsLocallyInjective φ)","decl":"lemma isLocallyInjective_sheafToPresheaf_map_iff :\n    Presheaf.IsLocallyInjective J ((sheafToPresheaf J D).map φ) ↔ IsLocallyInjective φ := by rfl\n\n"}
{"name":"CategoryTheory.Sheaf.isLocallyInjective_of_iso","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} D\ninst✝¹ : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF₁ F₂ : CategoryTheory.Sheaf J D\nφ : Quiver.Hom F₁ F₂\ninst✝ : CategoryTheory.IsIso φ\n⊢ CategoryTheory.Sheaf.IsLocallyInjective φ","decl":"instance isLocallyInjective_of_iso [IsIso φ] : IsLocallyInjective φ := by\n  change Presheaf.IsLocallyInjective J ((sheafToPresheaf _ _).map φ)\n  infer_instance\n\n"}
{"name":"CategoryTheory.Sheaf.mono_of_injective","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} D\ninst✝ : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF₁ F₂ : CategoryTheory.Sheaf J D\nφ : Quiver.Hom F₁ F₂\nhφ : ∀ (X : Opposite C), Function.Injective ⇑(φ.val.app X)\n⊢ CategoryTheory.Mono φ","decl":"lemma mono_of_injective\n    (hφ : ∀ (X : Cᵒᵖ), Function.Injective (φ.val.app X)) : Mono φ :=\n  have := fun X ↦ ConcreteCategory.mono_of_injective _ (hφ X)\n  (sheafToPresheaf _ _).mono_of_mono_map (NatTrans.mono_of_mono_app φ.1)\n\n"}
{"name":"CategoryTheory.Sheaf.isLocallyInjective_forget","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} D\ninst✝² : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF₁ F₂ : CategoryTheory.Sheaf J D\nφ : Quiver.Hom F₁ F₂\ninst✝¹ : J.HasSheafCompose (CategoryTheory.forget D)\ninst✝ : CategoryTheory.Sheaf.IsLocallyInjective φ\n⊢ CategoryTheory.Sheaf.IsLocallyInjective ((CategoryTheory.sheafCompose J (CategoryTheory.forget D)).map φ)","decl":"instance isLocallyInjective_forget [IsLocallyInjective φ] :\n    IsLocallyInjective ((sheafCompose J (forget D)).map φ) :=\n  Presheaf.isLocallyInjective_forget J φ.1\n\n"}
{"name":"CategoryTheory.Sheaf.isLocallyInjective_iff_injective","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} D\ninst✝¹ : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF₁ F₂ : CategoryTheory.Sheaf J D\nφ : Quiver.Hom F₁ F₂\ninst✝ : J.HasSheafCompose (CategoryTheory.forget D)\n⊢ Iff (CategoryTheory.Sheaf.IsLocallyInjective φ) (∀ (X : Opposite C), Function.Injective ⇑(φ.val.app X))","decl":"lemma isLocallyInjective_iff_injective :\n    IsLocallyInjective φ ↔ ∀ (X : Cᵒᵖ), Function.Injective (φ.val.app X) :=\n  Presheaf.isLocallyInjective_iff_injective_of_separated _ _ (by\n    apply Presieve.isSeparated_of_isSheaf\n    rw [← isSheaf_iff_isSheaf_of_type]\n    exact ((sheafCompose J (forget D)).obj F₁).2)\n\n"}
{"name":"CategoryTheory.Sheaf.mono_of_isLocallyInjective","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} D\ninst✝² : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF₁ F₂ : CategoryTheory.Sheaf J D\nφ : Quiver.Hom F₁ F₂\ninst✝¹ : J.HasSheafCompose (CategoryTheory.forget D)\ninst✝ : CategoryTheory.Sheaf.IsLocallyInjective φ\n⊢ CategoryTheory.Mono φ","decl":"lemma mono_of_isLocallyInjective [IsLocallyInjective φ] : Mono φ := by\n  apply mono_of_injective\n  rw [← isLocallyInjective_iff_injective]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Sheaf.instIsLocallyInjectiveImageι","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF G : CategoryTheory.Sheaf J (Type w)\nf : Quiver.Hom F G\n⊢ CategoryTheory.Sheaf.IsLocallyInjective (CategoryTheory.Sheaf.imageι f)","decl":"instance {F G : Sheaf J (Type w)} (f : F ⟶ G) :\n    IsLocallyInjective (Sheaf.imageι f) := by\n  dsimp [Sheaf.imageι]\n  infer_instance\n\n"}
