{"name":"CategoryTheory.Presheaf.equalizerSieve_apply","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬π : CategoryTheory.Category.{v', u'} D\ninst‚úù : CategoryTheory.HasForget D\nF : CategoryTheory.Functor (Opposite C) D\nX : Opposite C\nx y : (CategoryTheory.forget D).obj (F.obj X)\nx‚úù : C\nf : Quiver.Hom x‚úù (Opposite.unop X)\n‚ä¢ Eq ((CategoryTheory.Presheaf.equalizerSieve x y).arrows f) (Eq ((F.map f.op) x) ((F.map f.op) y))","decl":"/-- If `F : C·µí·µñ ‚•§ D` is a presheaf with values in a concrete category, if `x` and `y` are\nelements in `F.obj X`, this is the sieve of `X.unop` consisting of morphisms `f`\nsuch that `F.map f.op x = F.map f.op y`. -/\n@[simps]\ndef equalizerSieve {F : C·µí·µñ ‚•§ D} {X : C·µí·µñ} (x y : F.obj X) : Sieve X.unop where\n  arrows _ f := F.map f.op x = F.map f.op y\n  downward_closed {X Y} f hf g := by\n    dsimp at hf ‚ä¢\n    simp [hf]\n\n"}
{"name":"CategoryTheory.Presheaf.equalizerSieve_self_eq_top","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬π : CategoryTheory.Category.{v', u'} D\ninst‚úù : CategoryTheory.HasForget D\nF : CategoryTheory.Functor (Opposite C) D\nX : Opposite C\nx : (CategoryTheory.forget D).obj (F.obj X)\n‚ä¢ Eq (CategoryTheory.Presheaf.equalizerSieve x x) Top.top","decl":"@[simp]\nlemma equalizerSieve_self_eq_top {F : C·µí·µñ ‚•§ D} {X : C·µí·µñ} (x : F.obj X) :\n    equalizerSieve x x = ‚ä§ := by aesop\n\n"}
{"name":"CategoryTheory.Presheaf.equalizerSieve_eq_top_iff","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬π : CategoryTheory.Category.{v', u'} D\ninst‚úù : CategoryTheory.HasForget D\nF : CategoryTheory.Functor (Opposite C) D\nX : Opposite C\nx y : (CategoryTheory.forget D).obj (F.obj X)\n‚ä¢ Iff (Eq (CategoryTheory.Presheaf.equalizerSieve x y) Top.top) (Eq x y)","decl":"@[simp]\nlemma equalizerSieve_eq_top_iff {F : C·µí·µñ ‚•§ D} {X : C·µí·µñ} (x y : F.obj X) :\n    equalizerSieve x y = ‚ä§ ‚Üî x = y := by\n  constructor\n  ¬∑ intro h\n    simpa using (show equalizerSieve x y (ùüô _) by simp [h])\n  ¬∑ rintro rfl\n    apply equalizerSieve_self_eq_top\n\n"}
{"name":"CategoryTheory.Presheaf.IsLocallyInjective.equalizerSieve_mem","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬π : CategoryTheory.Category.{v', u'} D\ninst‚úù : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor (Opposite C) D\nœÜ : Quiver.Hom F‚ÇÅ F‚ÇÇ\nself : CategoryTheory.Presheaf.IsLocallyInjective J œÜ\nX : Opposite C\nx y : (CategoryTheory.forget D).obj (F‚ÇÅ.obj X)\nh : Eq ((œÜ.app X) x) ((œÜ.app X) y)\n‚ä¢ Membership.mem (J (Opposite.unop X)) (CategoryTheory.Presheaf.equalizerSieve x y)","decl":"/-- A morphism `œÜ : F‚ÇÅ ‚ü∂ F‚ÇÇ` of presheaves `C·µí·µñ ‚•§ D` (with `D` a concrete category)\nis locally injective for a Grothendieck topology `J` on `C` if\nwhenever two sections of `F‚ÇÅ` are sent to the same section of `F‚ÇÇ`, then these two\nsections coincide locally. -/\nclass IsLocallyInjective : Prop where\n  equalizerSieve_mem {X : C·µí·µñ} (x y : F‚ÇÅ.obj X) (h : œÜ.app X x = œÜ.app X y) :\n    equalizerSieve x y ‚àà J X.unop\n\n"}
{"name":"CategoryTheory.Presheaf.equalizerSieve_mem","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬≤ : CategoryTheory.Category.{v', u'} D\ninst‚úù¬π : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor (Opposite C) D\nœÜ : Quiver.Hom F‚ÇÅ F‚ÇÇ\ninst‚úù : CategoryTheory.Presheaf.IsLocallyInjective J œÜ\nX : Opposite C\nx y : (CategoryTheory.forget D).obj (F‚ÇÅ.obj X)\nh : Eq ((œÜ.app X) x) ((œÜ.app X) y)\n‚ä¢ Membership.mem (J (Opposite.unop X)) (CategoryTheory.Presheaf.equalizerSieve x y)","decl":"lemma equalizerSieve_mem [IsLocallyInjective J œÜ]\n    {X : C·µí·µñ} (x y : F‚ÇÅ.obj X) (h : œÜ.app X x = œÜ.app X y) :\n    equalizerSieve x y ‚àà J X.unop :=\n  IsLocallyInjective.equalizerSieve_mem x y h\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallyInjective_of_injective","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬π : CategoryTheory.Category.{v', u'} D\ninst‚úù : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor (Opposite C) D\nœÜ : Quiver.Hom F‚ÇÅ F‚ÇÇ\nhœÜ : ‚àÄ (X : Opposite C), Function.Injective ‚áë(œÜ.app X)\n‚ä¢ CategoryTheory.Presheaf.IsLocallyInjective J œÜ","decl":"lemma isLocallyInjective_of_injective (hœÜ : ‚àÄ (X : C·µí·µñ), Function.Injective (œÜ.app X)) :\n    IsLocallyInjective J œÜ where\n  equalizerSieve_mem {X} x y h := by\n    convert J.top_mem X.unop\n    ext Y f\n    simp only [equalizerSieve_apply, op_unop, Sieve.top_apply, iff_true]\n    apply hœÜ\n    simp [h]\n\n"}
{"name":"CategoryTheory.Presheaf.instIsLocallyInjectiveOfIsIsoFunctorOpposite","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬≤ : CategoryTheory.Category.{v', u'} D\ninst‚úù¬π : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor (Opposite C) D\nœÜ : Quiver.Hom F‚ÇÅ F‚ÇÇ\ninst‚úù : CategoryTheory.IsIso œÜ\n‚ä¢ CategoryTheory.Presheaf.IsLocallyInjective J œÜ","decl":"instance [IsIso œÜ] : IsLocallyInjective J œÜ :=\n  isLocallyInjective_of_injective J œÜ (fun X => Function.Bijective.injective (by\n    rw [‚Üê isIso_iff_bijective]\n    change IsIso ((forget D).map (œÜ.app X))\n    infer_instance))\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallyInjective_forget","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬≤ : CategoryTheory.Category.{v', u'} D\ninst‚úù¬π : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor (Opposite C) D\nœÜ : Quiver.Hom F‚ÇÅ F‚ÇÇ\ninst‚úù : CategoryTheory.Presheaf.IsLocallyInjective J œÜ\n‚ä¢ CategoryTheory.Presheaf.IsLocallyInjective J (CategoryTheory.whiskerRight œÜ (CategoryTheory.forget D))","decl":"instance isLocallyInjective_forget [IsLocallyInjective J œÜ] :\n    IsLocallyInjective J (whiskerRight œÜ (forget D)) where\n  equalizerSieve_mem x y h := equalizerSieve_mem J œÜ x y h\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallyInjective_forget_iff","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬π : CategoryTheory.Category.{v', u'} D\ninst‚úù : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor (Opposite C) D\nœÜ : Quiver.Hom F‚ÇÅ F‚ÇÇ\n‚ä¢ Iff (CategoryTheory.Presheaf.IsLocallyInjective J (CategoryTheory.whiskerRight œÜ (CategoryTheory.forget D))) (CategoryTheory.Presheaf.IsLocallyInjective J œÜ)","decl":"lemma isLocallyInjective_forget_iff :\n    IsLocallyInjective J (whiskerRight œÜ (forget D)) ‚Üî IsLocallyInjective J œÜ := by\n  constructor\n  ¬∑ intro\n    exact ‚ü®fun x y h => equalizerSieve_mem J (whiskerRight œÜ (forget D)) x y h‚ü©\n  ¬∑ intro\n    infer_instance\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallyInjective_iff_equalizerSieve_mem_imp","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬π : CategoryTheory.Category.{v', u'} D\ninst‚úù : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor (Opposite C) D\nœÜ : Quiver.Hom F‚ÇÅ F‚ÇÇ\n‚ä¢ Iff (CategoryTheory.Presheaf.IsLocallyInjective J œÜ) (‚àÄ ‚¶ÉX : Opposite C‚¶Ñ (x y : (CategoryTheory.forget D).obj (F‚ÇÅ.obj X)), Membership.mem (J (Opposite.unop X)) (CategoryTheory.Presheaf.equalizerSieve ((œÜ.app X) x) ((œÜ.app X) y)) ‚Üí Membership.mem (J (Opposite.unop X)) (CategoryTheory.Presheaf.equalizerSieve x y))","decl":"lemma isLocallyInjective_iff_equalizerSieve_mem_imp :\n    IsLocallyInjective J œÜ ‚Üî ‚àÄ ‚¶ÉX : C·µí·µñ‚¶Ñ (x y : F‚ÇÅ.obj X),\n      equalizerSieve (œÜ.app _ x) (œÜ.app _ y) ‚àà J X.unop ‚Üí equalizerSieve x y ‚àà J X.unop := by\n  constructor\n  ¬∑ intro _ X x y h\n    let S := equalizerSieve (œÜ.app _ x) (œÜ.app _ y)\n    let T : ‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Y ‚ü∂ X.unop‚¶Ñ (_ : S f), Sieve Y := fun Y f _ =>\n      equalizerSieve (F‚ÇÅ.map f.op x) ((F‚ÇÅ.map f.op y))\n    refine J.superset_covering ?_ (J.transitive h (Sieve.bind S.1 T) ?_)\n    ¬∑ rintro Y f ‚ü®Z, a, g, hg, ha, rfl‚ü©\n      simpa using ha\n    ¬∑ intro Y f hf\n      refine J.superset_covering (Sieve.le_pullback_bind S.1 T _ hf)\n        (equalizerSieve_mem J œÜ _ _ ?_)\n      rw [NatTrans.naturality_apply, NatTrans.naturality_apply]\n      exact hf\n  ¬∑ intro hœÜ\n    exact ‚ü®fun {X} x y h => hœÜ x y (by simp [h])‚ü©\n\n"}
{"name":"CategoryTheory.Presheaf.equalizerSieve_mem_of_equalizerSieve_app_mem","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬≤ : CategoryTheory.Category.{v', u'} D\ninst‚úù¬π : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor (Opposite C) D\nœÜ : Quiver.Hom F‚ÇÅ F‚ÇÇ\nX : Opposite C\nx y : (CategoryTheory.forget D).obj (F‚ÇÅ.obj X)\nh : Membership.mem (J (Opposite.unop X)) (CategoryTheory.Presheaf.equalizerSieve ((œÜ.app X) x) ((œÜ.app X) y))\ninst‚úù : CategoryTheory.Presheaf.IsLocallyInjective J œÜ\n‚ä¢ Membership.mem (J (Opposite.unop X)) (CategoryTheory.Presheaf.equalizerSieve x y)","decl":"lemma equalizerSieve_mem_of_equalizerSieve_app_mem\n    {X : C·µí·µñ} (x y : F‚ÇÅ.obj X) (h : equalizerSieve (œÜ.app _ x) (œÜ.app _ y) ‚àà J X.unop)\n    [IsLocallyInjective J œÜ] :\n    equalizerSieve x y ‚àà J X.unop :=\n  (isLocallyInjective_iff_equalizerSieve_mem_imp J œÜ).1 inferInstance x y h\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallyInjective_comp","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬≥ : CategoryTheory.Category.{v', u'} D\ninst‚úù¬≤ : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF‚ÇÅ F‚ÇÇ F‚ÇÉ : CategoryTheory.Functor (Opposite C) D\nœÜ : Quiver.Hom F‚ÇÅ F‚ÇÇ\nœà : Quiver.Hom F‚ÇÇ F‚ÇÉ\ninst‚úù¬π : CategoryTheory.Presheaf.IsLocallyInjective J œÜ\ninst‚úù : CategoryTheory.Presheaf.IsLocallyInjective J œà\n‚ä¢ CategoryTheory.Presheaf.IsLocallyInjective J (CategoryTheory.CategoryStruct.comp œÜ œà)","decl":"instance isLocallyInjective_comp [IsLocallyInjective J œÜ] [IsLocallyInjective J œà] :\n    IsLocallyInjective J (œÜ ‚â´ œà) where\n  equalizerSieve_mem {X} x y h := by\n    apply equalizerSieve_mem_of_equalizerSieve_app_mem J œÜ\n    exact equalizerSieve_mem J œà _ _ (by simpa using h)\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallyInjective_of_isLocallyInjective","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬≤ : CategoryTheory.Category.{v', u'} D\ninst‚úù¬π : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF‚ÇÅ F‚ÇÇ F‚ÇÉ : CategoryTheory.Functor (Opposite C) D\nœÜ : Quiver.Hom F‚ÇÅ F‚ÇÇ\nœà : Quiver.Hom F‚ÇÇ F‚ÇÉ\ninst‚úù : CategoryTheory.Presheaf.IsLocallyInjective J (CategoryTheory.CategoryStruct.comp œÜ œà)\n‚ä¢ CategoryTheory.Presheaf.IsLocallyInjective J œÜ","decl":"lemma isLocallyInjective_of_isLocallyInjective [IsLocallyInjective J (œÜ ‚â´ œà)] :\n    IsLocallyInjective J œÜ where\n  equalizerSieve_mem {X} x y h := equalizerSieve_mem J (œÜ ‚â´ œà) x y (by simp [h])\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallyInjective_of_isLocallyInjective_fac","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬≤ : CategoryTheory.Category.{v', u'} D\ninst‚úù¬π : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF‚ÇÅ F‚ÇÇ F‚ÇÉ : CategoryTheory.Functor (Opposite C) D\nœÜ : Quiver.Hom F‚ÇÅ F‚ÇÇ\nœà : Quiver.Hom F‚ÇÇ F‚ÇÉ\nœÜœà : Quiver.Hom F‚ÇÅ F‚ÇÉ\nfac : Eq (CategoryTheory.CategoryStruct.comp œÜ œà) œÜœà\ninst‚úù : CategoryTheory.Presheaf.IsLocallyInjective J œÜœà\n‚ä¢ CategoryTheory.Presheaf.IsLocallyInjective J œÜ","decl":"lemma isLocallyInjective_of_isLocallyInjective_fac {œÜœà : F‚ÇÅ ‚ü∂ F‚ÇÉ} (fac : œÜ ‚â´ œà = œÜœà)\n    [IsLocallyInjective J œÜœà] : IsLocallyInjective J œÜ := by\n  subst fac\n  exact isLocallyInjective_of_isLocallyInjective J œÜ œà\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallyInjective_iff_of_fac","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬≤ : CategoryTheory.Category.{v', u'} D\ninst‚úù¬π : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF‚ÇÅ F‚ÇÇ F‚ÇÉ : CategoryTheory.Functor (Opposite C) D\nœÜ : Quiver.Hom F‚ÇÅ F‚ÇÇ\nœà : Quiver.Hom F‚ÇÇ F‚ÇÉ\nœÜœà : Quiver.Hom F‚ÇÅ F‚ÇÉ\nfac : Eq (CategoryTheory.CategoryStruct.comp œÜ œà) œÜœà\ninst‚úù : CategoryTheory.Presheaf.IsLocallyInjective J œà\n‚ä¢ Iff (CategoryTheory.Presheaf.IsLocallyInjective J œÜœà) (CategoryTheory.Presheaf.IsLocallyInjective J œÜ)","decl":"lemma isLocallyInjective_iff_of_fac {œÜœà : F‚ÇÅ ‚ü∂ F‚ÇÉ} (fac : œÜ ‚â´ œà = œÜœà) [IsLocallyInjective J œà] :\n    IsLocallyInjective J œÜœà ‚Üî IsLocallyInjective J œÜ := by\n  constructor\n  ¬∑ intro\n    exact isLocallyInjective_of_isLocallyInjective_fac J fac\n  ¬∑ intro\n    rw [‚Üê fac]\n    infer_instance\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallyInjective_comp_iff","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬≤ : CategoryTheory.Category.{v', u'} D\ninst‚úù¬π : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF‚ÇÅ F‚ÇÇ F‚ÇÉ : CategoryTheory.Functor (Opposite C) D\nœÜ : Quiver.Hom F‚ÇÅ F‚ÇÇ\nœà : Quiver.Hom F‚ÇÇ F‚ÇÉ\ninst‚úù : CategoryTheory.Presheaf.IsLocallyInjective J œà\n‚ä¢ Iff (CategoryTheory.Presheaf.IsLocallyInjective J (CategoryTheory.CategoryStruct.comp œÜ œà)) (CategoryTheory.Presheaf.IsLocallyInjective J œÜ)","decl":"lemma isLocallyInjective_comp_iff [IsLocallyInjective J œà] :\n    IsLocallyInjective J (œÜ ‚â´ œà) ‚Üî IsLocallyInjective J œÜ :=\n  isLocallyInjective_iff_of_fac J rfl\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallyInjective_iff_injective_of_separated","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬π : CategoryTheory.Category.{v', u'} D\ninst‚úù : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor (Opposite C) D\nœÜ : Quiver.Hom F‚ÇÅ F‚ÇÇ\nhsep : CategoryTheory.Presieve.IsSeparated J (F‚ÇÅ.comp (CategoryTheory.forget D))\n‚ä¢ Iff (CategoryTheory.Presheaf.IsLocallyInjective J œÜ) (‚àÄ (X : Opposite C), Function.Injective ‚áë(œÜ.app X))","decl":"lemma isLocallyInjective_iff_injective_of_separated\n    (hsep : Presieve.IsSeparated J (F‚ÇÅ ‚ãô forget D)) :\n    IsLocallyInjective J œÜ ‚Üî ‚àÄ (X : C·µí·µñ), Function.Injective (œÜ.app X) := by\n  constructor\n  ¬∑ intro _ X x y h\n    exact (hsep _ (equalizerSieve_mem J œÜ x y h)).ext (fun _ _ hf => hf)\n  ¬∑ apply isLocallyInjective_of_injective\n\n"}
{"name":"CategoryTheory.Presheaf.instIsLocallyInjectiveŒπ","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nG : CategoryTheory.Subpresheaf F\n‚ä¢ CategoryTheory.Presheaf.IsLocallyInjective J G.Œπ","decl":"instance (F : C·µí·µñ ‚•§ Type w) (G : Subpresheaf F) :\n    IsLocallyInjective J G.Œπ :=\n  isLocallyInjective_of_injective _ _ (fun X => by\n    intro ‚ü®x, _‚ü© ‚ü®y, _‚ü© h\n    exact Subtype.ext h)\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallyInjective_toPlus","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) (Type (max u v))\n‚ä¢ CategoryTheory.Presheaf.IsLocallyInjective J (J.toPlus P)","decl":"instance isLocallyInjective_toPlus (P : C·µí·µñ ‚•§ Type max u v) :\n    IsLocallyInjective J (J.toPlus P) where\n  equalizerSieve_mem {X} x y h := by\n    rw [toPlus_eq_mk, toPlus_eq_mk, eq_mk_iff_exists] at h\n    obtain ‚ü®W, h‚ÇÅ, h‚ÇÇ, eq‚ü© := h\n    exact J.superset_covering (fun Y f hf => congr_fun (congr_arg Subtype.val eq) ‚ü®Y, f, hf‚ü©) W.2\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallyInjective_toSheafify","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) (Type (max u v))\n‚ä¢ CategoryTheory.Presheaf.IsLocallyInjective J (J.toSheafify P)","decl":"instance isLocallyInjective_toSheafify (P : C·µí·µñ ‚•§ Type max u v) :\n    IsLocallyInjective J (J.toSheafify P) := by\n  dsimp [GrothendieckTopology.toSheafify]\n  rw [GrothendieckTopology.plusMap_toPlus]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Presheaf.isLocallyInjective_toSheafify'","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù‚Å¥ : CategoryTheory.Category.{v', u'} D\nJ : CategoryTheory.GrothendieckTopology C\ninst‚úù¬≥ : CategoryTheory.HasForget D\nP : CategoryTheory.Functor (Opposite C) D\ninst‚úù¬≤ : CategoryTheory.HasWeakSheafify J D\ninst‚úù¬π : J.HasSheafCompose (CategoryTheory.forget D)\ninst‚úù : J.PreservesSheafification (CategoryTheory.forget D)\n‚ä¢ CategoryTheory.Presheaf.IsLocallyInjective J (CategoryTheory.toSheafify J P)","decl":"instance isLocallyInjective_toSheafify' [HasForget.{max u v} D]\n    (P : C·µí·µñ ‚•§ D) [HasWeakSheafify J D] [J.HasSheafCompose (forget D)]\n    [J.PreservesSheafification (forget D)] :\n    IsLocallyInjective J (toSheafify J P) := by\n  rw [‚Üê isLocallyInjective_forget_iff, ‚Üê sheafComposeIso_hom_fac,\n    ‚Üê toSheafify_plusPlusIsoSheafify_hom]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Sheaf.isLocallyInjective_sheafToPresheaf_map_iff","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬π : CategoryTheory.Category.{v', u'} D\ninst‚úù : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Sheaf J D\nœÜ : Quiver.Hom F‚ÇÅ F‚ÇÇ\n‚ä¢ Iff (CategoryTheory.Presheaf.IsLocallyInjective J ((CategoryTheory.sheafToPresheaf J D).map œÜ)) (CategoryTheory.Sheaf.IsLocallyInjective œÜ)","decl":"lemma isLocallyInjective_sheafToPresheaf_map_iff :\n    Presheaf.IsLocallyInjective J ((sheafToPresheaf J D).map œÜ) ‚Üî IsLocallyInjective œÜ := by rfl\n\n"}
{"name":"CategoryTheory.Sheaf.isLocallyInjective_of_iso","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬≤ : CategoryTheory.Category.{v', u'} D\ninst‚úù¬π : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Sheaf J D\nœÜ : Quiver.Hom F‚ÇÅ F‚ÇÇ\ninst‚úù : CategoryTheory.IsIso œÜ\n‚ä¢ CategoryTheory.Sheaf.IsLocallyInjective œÜ","decl":"instance isLocallyInjective_of_iso [IsIso œÜ] : IsLocallyInjective œÜ := by\n  change Presheaf.IsLocallyInjective J ((sheafToPresheaf _ _).map œÜ)\n  infer_instance\n\n"}
{"name":"CategoryTheory.Sheaf.mono_of_injective","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬π : CategoryTheory.Category.{v', u'} D\ninst‚úù : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Sheaf J D\nœÜ : Quiver.Hom F‚ÇÅ F‚ÇÇ\nhœÜ : ‚àÄ (X : Opposite C), Function.Injective ‚áë(œÜ.val.app X)\n‚ä¢ CategoryTheory.Mono œÜ","decl":"lemma mono_of_injective\n    (hœÜ : ‚àÄ (X : C·µí·µñ), Function.Injective (œÜ.val.app X)) : Mono œÜ :=\n  have := fun X ‚Ü¶ ConcreteCategory.mono_of_injective _ (hœÜ X)\n  (sheafToPresheaf _ _).mono_of_mono_map (NatTrans.mono_of_mono_app œÜ.1)\n\n"}
{"name":"CategoryTheory.Sheaf.isLocallyInjective_forget","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬≥ : CategoryTheory.Category.{v', u'} D\ninst‚úù¬≤ : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Sheaf J D\nœÜ : Quiver.Hom F‚ÇÅ F‚ÇÇ\ninst‚úù¬π : J.HasSheafCompose (CategoryTheory.forget D)\ninst‚úù : CategoryTheory.Sheaf.IsLocallyInjective œÜ\n‚ä¢ CategoryTheory.Sheaf.IsLocallyInjective ((CategoryTheory.sheafCompose J (CategoryTheory.forget D)).map œÜ)","decl":"instance isLocallyInjective_forget [IsLocallyInjective œÜ] :\n    IsLocallyInjective ((sheafCompose J (forget D)).map œÜ) :=\n  Presheaf.isLocallyInjective_forget J œÜ.1\n\n"}
{"name":"CategoryTheory.Sheaf.isLocallyInjective_iff_injective","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬≤ : CategoryTheory.Category.{v', u'} D\ninst‚úù¬π : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Sheaf J D\nœÜ : Quiver.Hom F‚ÇÅ F‚ÇÇ\ninst‚úù : J.HasSheafCompose (CategoryTheory.forget D)\n‚ä¢ Iff (CategoryTheory.Sheaf.IsLocallyInjective œÜ) (‚àÄ (X : Opposite C), Function.Injective ‚áë(œÜ.val.app X))","decl":"lemma isLocallyInjective_iff_injective :\n    IsLocallyInjective œÜ ‚Üî ‚àÄ (X : C·µí·µñ), Function.Injective (œÜ.val.app X) :=\n  Presheaf.isLocallyInjective_iff_injective_of_separated _ _ (by\n    apply Presieve.isSeparated_of_isSheaf\n    rw [‚Üê isSheaf_iff_isSheaf_of_type]\n    exact ((sheafCompose J (forget D)).obj F‚ÇÅ).2)\n\n"}
{"name":"CategoryTheory.Sheaf.mono_of_isLocallyInjective","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬≥ : CategoryTheory.Category.{v', u'} D\ninst‚úù¬≤ : CategoryTheory.HasForget D\nJ : CategoryTheory.GrothendieckTopology C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Sheaf J D\nœÜ : Quiver.Hom F‚ÇÅ F‚ÇÇ\ninst‚úù¬π : J.HasSheafCompose (CategoryTheory.forget D)\ninst‚úù : CategoryTheory.Sheaf.IsLocallyInjective œÜ\n‚ä¢ CategoryTheory.Mono œÜ","decl":"lemma mono_of_isLocallyInjective [IsLocallyInjective œÜ] : Mono œÜ := by\n  apply mono_of_injective\n  rw [‚Üê isLocallyInjective_iff_injective]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Sheaf.instIsLocallyInjectiveImageŒπ","module":"Mathlib.CategoryTheory.Sites.LocallyInjective","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF G : CategoryTheory.Sheaf J (Type w)\nf : Quiver.Hom F G\n‚ä¢ CategoryTheory.Sheaf.IsLocallyInjective (CategoryTheory.Sheaf.imageŒπ f)","decl":"instance {F G : Sheaf J (Type w)} (f : F ‚ü∂ G) :\n    IsLocallyInjective (Sheaf.imageŒπ f) := by\n  dsimp [Sheaf.imageŒπ]\n  infer_instance\n\n"}
