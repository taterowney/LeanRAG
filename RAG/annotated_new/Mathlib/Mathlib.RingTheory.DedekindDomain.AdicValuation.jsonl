{"name":"IsDedekindDomain.HeightOneSpectrum.intValuationDef_if_pos","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\nr : R\nhr : Eq r 0\n⊢ Eq (v.intValuationDef r) 0","decl":"theorem intValuationDef_if_pos {r : R} (hr : r = 0) : v.intValuationDef r = 0 :=\n  if_pos hr\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.intValuationDef_zero","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\n⊢ Eq (v.intValuationDef 0) 0","decl":"@[simp]\ntheorem intValuationDef_zero : v.intValuationDef 0 = 0 :=\n  if_pos rfl\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.intValuationDef_if_neg","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\nr : R\nhr : Ne r 0\n⊢ Eq (v.intValuationDef r) ↑(Multiplicative.ofAdd (Neg.neg ↑((Associates.mk v.asIdeal).count (Associates.mk (Ideal.span (Singleton.singleton r))).factors)))","decl":"open scoped Classical in\ntheorem intValuationDef_if_neg {r : R} (hr : r ≠ 0) :\n    v.intValuationDef r =\n      Multiplicative.ofAdd\n        (-(Associates.mk v.asIdeal).count (Associates.mk (Ideal.span {r} : Ideal R)).factors : ℤ) :=\n  if_neg hr\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.intValuation_ne_zero","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\nx : R\nhx : Ne x 0\n⊢ Ne (v.intValuationDef x) 0","decl":"/-- Nonzero elements have nonzero adic valuation. -/\ntheorem intValuation_ne_zero (x : R) (hx : x ≠ 0) : v.intValuationDef x ≠ 0 := by\n  rw [intValuationDef, if_neg hx]\n  exact WithZero.coe_ne_zero\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.intValuation_ne_zero'","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\nx : Subtype fun x => Membership.mem (nonZeroDivisors R) x\n⊢ Ne (v.intValuationDef ↑x) 0","decl":"/-- Nonzero divisors have nonzero valuation. -/\ntheorem intValuation_ne_zero' (x : nonZeroDivisors R) : v.intValuationDef x ≠ 0 :=\n  v.intValuation_ne_zero x (nonZeroDivisors.coe_ne_zero x)\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.intValuation_zero_le","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\nx : Subtype fun x => Membership.mem (nonZeroDivisors R) x\n⊢ LT.lt 0 (v.intValuationDef ↑x)","decl":"/-- Nonzero divisors have valuation greater than zero. -/\ntheorem intValuation_zero_le (x : nonZeroDivisors R) : 0 < v.intValuationDef x := by\n  rw [v.intValuationDef_if_neg (nonZeroDivisors.coe_ne_zero x)]\n  exact WithZero.zero_lt_coe _\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.intValuation_le_one","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\nx : R\n⊢ LE.le (v.intValuationDef x) 1","decl":"/-- The `v`-adic valuation on `R` is bounded above by 1. -/\ntheorem intValuation_le_one (x : R) : v.intValuationDef x ≤ 1 := by\n  rw [intValuationDef]\n  by_cases hx : x = 0\n  · rw [if_pos hx]; exact WithZero.zero_le 1\n  · rw [if_neg hx, ← WithZero.coe_one, ← ofAdd_zero, WithZero.coe_le_coe, ofAdd_le,\n      Right.neg_nonpos_iff]\n    exact Int.natCast_nonneg _\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.intValuation_lt_one_iff_dvd","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\nr : R\n⊢ Iff (LT.lt (v.intValuationDef r) 1) (Dvd.dvd v.asIdeal (Ideal.span (Singleton.singleton r)))","decl":"/-- The `v`-adic valuation of `r ∈ R` is less than 1 if and only if `v` divides the ideal `(r)`. -/\ntheorem intValuation_lt_one_iff_dvd (r : R) :\n    v.intValuationDef r < 1 ↔ v.asIdeal ∣ Ideal.span {r} := by\n  classical\n  rw [intValuationDef]\n  split_ifs with hr\n  · simp [hr]\n  · rw [← WithZero.coe_one, ← ofAdd_zero, WithZero.coe_lt_coe, ofAdd_lt, neg_lt_zero, ←\n      Int.ofNat_zero, Int.ofNat_lt, zero_lt_iff]\n    have h : (Ideal.span {r} : Ideal R) ≠ 0 := by\n      rw [Ne, Ideal.zero_eq_bot, Ideal.span_singleton_eq_bot]\n      exact hr\n    apply Associates.count_ne_zero_iff_dvd h (by apply v.irreducible)\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.intValuation_le_pow_iff_dvd","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\nr : R\nn : Nat\n⊢ Iff (LE.le (v.intValuationDef r) ↑(Multiplicative.ofAdd (Neg.neg ↑n))) (Dvd.dvd (HPow.hPow v.asIdeal n) (Ideal.span (Singleton.singleton r)))","decl":"/-- The `v`-adic valuation of `r ∈ R` is less than `Multiplicative.ofAdd (-n)` if and only if\n`vⁿ` divides the ideal `(r)`. -/\ntheorem intValuation_le_pow_iff_dvd (r : R) (n : ℕ) :\n    v.intValuationDef r ≤ Multiplicative.ofAdd (-(n : ℤ)) ↔ v.asIdeal ^ n ∣ Ideal.span {r} := by\n  classical\n  rw [intValuationDef]\n  split_ifs with hr\n  · simp_rw [hr, Ideal.dvd_span_singleton, zero_le', Submodule.zero_mem]\n  · rw [WithZero.coe_le_coe, ofAdd_le, neg_le_neg_iff, Int.ofNat_le, Ideal.dvd_span_singleton, ←\n      Associates.le_singleton_iff,\n      Associates.prime_pow_dvd_iff_le (Associates.mk_ne_zero'.mpr hr)\n        (by apply v.associates_irreducible)]\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.intValuation.map_zero'","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\n⊢ Eq (v.intValuationDef 0) 0","decl":"/-- The `v`-adic valuation of `0 : R` equals 0. -/\ntheorem intValuation.map_zero' : v.intValuationDef 0 = 0 :=\n  v.intValuationDef_if_pos (Eq.refl 0)\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.intValuation.map_one'","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\n⊢ Eq (v.intValuationDef 1) 1","decl":"/-- The `v`-adic valuation of `1 : R` equals 1. -/\ntheorem intValuation.map_one' : v.intValuationDef 1 = 1 := by\n  classical\n  rw [v.intValuationDef_if_neg (zero_ne_one.symm : (1 : R) ≠ 0), Ideal.span_singleton_one, ←\n    Ideal.one_eq_top, Associates.mk_one, Associates.factors_one,\n    Associates.count_zero (by apply v.associates_irreducible), Int.ofNat_zero, neg_zero, ofAdd_zero,\n    WithZero.coe_one]\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.intValuation.map_mul'","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\nx y : R\n⊢ Eq (v.intValuationDef (HMul.hMul x y)) (HMul.hMul (v.intValuationDef x) (v.intValuationDef y))","decl":"/-- The `v`-adic valuation of a product equals the product of the valuations. -/\ntheorem intValuation.map_mul' (x y : R) :\n    v.intValuationDef (x * y) = v.intValuationDef x * v.intValuationDef y := by\n  classical\n  simp only [intValuationDef]\n  by_cases hx : x = 0\n  · rw [hx, zero_mul, if_pos (Eq.refl _), zero_mul]\n  · by_cases hy : y = 0\n    · rw [hy, mul_zero, if_pos (Eq.refl _), mul_zero]\n    · rw [if_neg hx, if_neg hy, if_neg (mul_ne_zero hx hy), ← WithZero.coe_mul, WithZero.coe_inj, ←\n        ofAdd_add, ← Ideal.span_singleton_mul_span_singleton, ← Associates.mk_mul_mk, ← neg_add,\n        Associates.count_mul (by apply Associates.mk_ne_zero'.mpr hx)\n          (by apply Associates.mk_ne_zero'.mpr hy) (by apply v.associates_irreducible)]\n      rfl\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.intValuation.le_max_iff_min_le","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"a b c : Nat\n⊢ Iff (LE.le (Multiplicative.ofAdd (Neg.neg ↑c)) (Max.max (Multiplicative.ofAdd (Neg.neg ↑a)) (Multiplicative.ofAdd (Neg.neg ↑b)))) (LE.le (Min.min a b) c)","decl":"theorem intValuation.le_max_iff_min_le {a b c : ℕ} :\n    Multiplicative.ofAdd (-c : ℤ) ≤\n      max (Multiplicative.ofAdd (-a : ℤ)) (Multiplicative.ofAdd (-b : ℤ)) ↔\n      min a b ≤ c := by\n  rw [le_max_iff, ofAdd_le, ofAdd_le, neg_le_neg_iff, neg_le_neg_iff, Int.ofNat_le, Int.ofNat_le, ←\n    min_le_iff]\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.intValuation.map_add_le_max'","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\nx y : R\n⊢ LE.le (v.intValuationDef (HAdd.hAdd x y)) (Max.max (v.intValuationDef x) (v.intValuationDef y))","decl":"/-- The `v`-adic valuation of a sum is bounded above by the maximum of the valuations. -/\ntheorem intValuation.map_add_le_max' (x y : R) :\n    v.intValuationDef (x + y) ≤ max (v.intValuationDef x) (v.intValuationDef y) := by\n  classical\n  by_cases hx : x = 0\n  · rw [hx, zero_add]\n    conv_rhs => rw [intValuationDef, if_pos (Eq.refl _)]\n    rw [max_eq_right (WithZero.zero_le (v.intValuationDef y))]\n  · by_cases hy : y = 0\n    · rw [hy, add_zero]\n      conv_rhs => rw [max_comm, intValuationDef, if_pos (Eq.refl _)]\n      rw [max_eq_right (WithZero.zero_le (v.intValuationDef x))]\n    · by_cases hxy : x + y = 0\n      · rw [intValuationDef, if_pos hxy]; exact zero_le'\n      · rw [v.intValuationDef_if_neg hxy, v.intValuationDef_if_neg hx, v.intValuationDef_if_neg hy,\n          WithZero.le_max_iff, intValuation.le_max_iff_min_le]\n        set nmin :=\n          min ((Associates.mk v.asIdeal).count (Associates.mk (Ideal.span { x })).factors)\n            ((Associates.mk v.asIdeal).count (Associates.mk (Ideal.span { y })).factors)\n        have h_dvd_x : x ∈ v.asIdeal ^ nmin := by\n          rw [← Associates.le_singleton_iff x nmin _,\n            Associates.prime_pow_dvd_iff_le (Associates.mk_ne_zero'.mpr hx) _]\n          · exact min_le_left _ _\n          apply v.associates_irreducible\n        have h_dvd_y : y ∈ v.asIdeal ^ nmin := by\n          rw [← Associates.le_singleton_iff y nmin _,\n            Associates.prime_pow_dvd_iff_le (Associates.mk_ne_zero'.mpr hy) _]\n          · exact min_le_right _ _\n          apply v.associates_irreducible\n        have h_dvd_xy : Associates.mk v.asIdeal ^ nmin ≤ Associates.mk (Ideal.span {x + y}) := by\n          rw [Associates.le_singleton_iff]\n          exact Ideal.add_mem (v.asIdeal ^ nmin) h_dvd_x h_dvd_y\n        rw [Associates.prime_pow_dvd_iff_le (Associates.mk_ne_zero'.mpr hxy) _] at h_dvd_xy\n        · exact h_dvd_xy\n        apply v.associates_irreducible\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.intValuation_toFun","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\nr : R\n⊢ Eq (v.intValuation r) (v.intValuationDef r)","decl":"/-- The `v`-adic valuation on `R`. -/\n@[simps]\ndef intValuation : Valuation R ℤₘ₀ where\n  toFun := v.intValuationDef\n  map_zero' := intValuation.map_zero' v\n  map_one' := intValuation.map_one' v\n  map_mul' := intValuation.map_mul' v\n  map_add_le_max' := intValuation.map_add_le_max' v\n\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.intValuation_apply","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nr : R\nv : IsDedekindDomain.HeightOneSpectrum R\n⊢ Eq (v.intValuation r) (v.intValuationDef r)","decl":"theorem intValuation_apply {r : R} (v : IsDedekindDomain.HeightOneSpectrum R) :\n    intValuation v r = intValuationDef v r := rfl\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.intValuation_exists_uniformizer","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\n⊢ Exists fun π => Eq (v.intValuationDef π) ↑(Multiplicative.ofAdd (-1))","decl":"/-- There exists `π ∈ R` with `v`-adic valuation `Multiplicative.ofAdd (-1)`. -/\ntheorem intValuation_exists_uniformizer :\n    ∃ π : R, v.intValuationDef π = Multiplicative.ofAdd (-1 : ℤ) := by\n  classical\n  have hv : _root_.Irreducible (Associates.mk v.asIdeal) := v.associates_irreducible\n  have hlt : v.asIdeal ^ 2 < v.asIdeal := by\n    rw [← Ideal.dvdNotUnit_iff_lt]\n    exact\n      ⟨v.ne_bot, v.asIdeal, (not_congr Ideal.isUnit_iff).mpr (Ideal.IsPrime.ne_top v.isPrime),\n        sq v.asIdeal⟩\n  obtain ⟨π, mem, nmem⟩ := SetLike.exists_of_lt hlt\n  have hπ : Associates.mk (Ideal.span {π}) ≠ 0 := by\n    rw [Associates.mk_ne_zero']\n    intro h\n    rw [h] at nmem\n    exact nmem (Submodule.zero_mem (v.asIdeal ^ 2))\n  use π\n  rw [intValuationDef, if_neg (Associates.mk_ne_zero'.mp hπ), WithZero.coe_inj]\n  apply congr_arg\n  rw [neg_inj, ← Int.ofNat_one, Int.natCast_inj]\n  rw [← Ideal.dvd_span_singleton, ← Associates.mk_le_mk_iff_dvd] at mem nmem\n  rw [← pow_one (Associates.mk v.asIdeal), Associates.prime_pow_dvd_iff_le hπ hv] at mem\n  rw [Associates.mk_pow, Associates.prime_pow_dvd_iff_le hπ hv, not_le] at nmem\n  exact Nat.eq_of_le_of_lt_succ mem nmem\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.intValuation_singleton","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDedekindDomain R\nv : IsDedekindDomain.HeightOneSpectrum R\nr : R\nhr : Ne r 0\nhv : Eq v.asIdeal (Ideal.span (Singleton.singleton r))\n⊢ Eq (v.intValuation r) ↑(Multiplicative.ofAdd (-1))","decl":"/-- The `I`-adic valuation of a generator of `I` equals `(-1 : ℤₘ₀)` -/\ntheorem intValuation_singleton {r : R} (hr : r ≠ 0) (hv : v.asIdeal = Ideal.span {r}) :\n    v.intValuation r = Multiplicative.ofAdd (-1 : ℤ) := by\n  classical\n  rw [intValuation_apply, v.intValuationDef_if_neg hr, ← hv, Associates.count_self, Int.ofNat_one,\n    ofAdd_neg, WithZero.coe_inv]\n  apply v.associates_irreducible\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.valuation_def","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\nx : K\n⊢ Eq (v.valuation x) ((v.intValuation.extendToLocalization ⋯ K) x)","decl":"theorem valuation_def (x : K) :\n    v.valuation x =\n      v.intValuation.extendToLocalization\n        (fun r hr => Set.mem_compl (v.intValuation_ne_zero' ⟨r, hr⟩)) K x :=\n  rfl\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.valuation_of_mk'","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\nr : R\ns : Subtype fun x => Membership.mem (nonZeroDivisors R) x\n⊢ Eq (v.valuation (IsLocalization.mk' K r s)) (HDiv.hDiv (v.intValuation r) (v.intValuation ↑s))","decl":"/-- The `v`-adic valuation of `r/s ∈ K` is the valuation of `r` divided by the valuation of `s`. -/\ntheorem valuation_of_mk' {r : R} {s : nonZeroDivisors R} :\n    v.valuation (IsLocalization.mk' K r s) = v.intValuation r / v.intValuation s := by\n  erw [valuation_def, (IsLocalization.toLocalizationMap (nonZeroDivisors R) K).lift_mk',\n    div_eq_mul_inv, mul_eq_mul_left_iff]\n  left\n  rw [Units.val_inv_eq_inv_val, inv_inj]\n  rfl\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.valuation_of_algebraMap","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\nr : R\n⊢ Eq (v.valuation ((algebraMap R K) r)) (v.intValuation r)","decl":"/-- The `v`-adic valuation on `K` extends the `v`-adic valuation on `R`. -/\ntheorem valuation_of_algebraMap (r : R) : v.valuation (algebraMap R K r) = v.intValuation r := by\n  rw [valuation_def, Valuation.extendToLocalization_apply_map_apply]\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.valuation_eq_intValuationDef","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\nr : R\n⊢ Eq (v.valuation ↑r) (v.intValuationDef r)","decl":"open scoped algebraMap in\nlemma valuation_eq_intValuationDef (r : R) : v.valuation (r : K) = v.intValuationDef r :=\n  Valuation.extendToLocalization_apply_map_apply ..\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.valuation_le_one","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\nr : R\n⊢ LE.le (v.valuation ((algebraMap R K) r)) 1","decl":"/-- The `v`-adic valuation on `R` is bounded above by 1. -/\ntheorem valuation_le_one (r : R) : v.valuation (algebraMap R K r) ≤ 1 := by\n  rw [valuation_of_algebraMap]; exact v.intValuation_le_one r\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.valuation_lt_one_iff_dvd","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\nr : R\n⊢ Iff (LT.lt (v.valuation ((algebraMap R K) r)) 1) (Dvd.dvd v.asIdeal (Ideal.span (Singleton.singleton r)))","decl":"/-- The `v`-adic valuation of `r ∈ R` is less than 1 if and only if `v` divides the ideal `(r)`. -/\ntheorem valuation_lt_one_iff_dvd (r : R) :\n    v.valuation (algebraMap R K r) < 1 ↔ v.asIdeal ∣ Ideal.span {r} := by\n  rw [valuation_of_algebraMap]; exact v.intValuation_lt_one_iff_dvd r\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.valuation_exists_uniformizer","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\n⊢ Exists fun π => Eq (v.valuation π) ↑(Multiplicative.ofAdd (-1))","decl":"/-- There exists `π ∈ K` with `v`-adic valuation `Multiplicative.ofAdd (-1)`. -/\ntheorem valuation_exists_uniformizer : ∃ π : K, v.valuation π = Multiplicative.ofAdd (-1 : ℤ) := by\n  obtain ⟨r, hr⟩ := v.intValuation_exists_uniformizer\n  use algebraMap R K r\n  rw [valuation_def, Valuation.extendToLocalization_apply_map_apply]\n  exact hr\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.valuation_uniformizer_ne_zero","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\n⊢ Ne (Classical.choose ⋯) 0","decl":"/-- Uniformizers are nonzero. -/\ntheorem valuation_uniformizer_ne_zero : Classical.choose (v.valuation_exists_uniformizer K) ≠ 0 :=\n  haveI hu := Classical.choose_spec (v.valuation_exists_uniformizer K)\n  (Valuation.ne_zero_iff _).mp (ne_of_eq_of_ne hu WithZero.coe_ne_zero)\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.mem_integers_of_valuation_le_one","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nx : K\nh : ∀ (v : IsDedekindDomain.HeightOneSpectrum R), LE.le (v.valuation x) 1\n⊢ Membership.mem (algebraMap R K).range x","decl":"theorem mem_integers_of_valuation_le_one (x : K)\n    (h : ∀ v : HeightOneSpectrum R, v.valuation x ≤ 1) : x ∈ (algebraMap R K).range := by\n  obtain ⟨⟨n, d, hd⟩, hx⟩ := IsLocalization.surj (nonZeroDivisors R) x\n  obtain rfl : x = IsLocalization.mk' K n ⟨d, hd⟩ := IsLocalization.eq_mk'_iff_mul_eq.mpr hx\n  obtain rfl | hn0 := eq_or_ne n 0\n  · simp\n  have hd0 := nonZeroDivisors.ne_zero hd\n  suffices Ideal.span {d} ∣ (Ideal.span {n} : Ideal R) by\n    obtain ⟨z, rfl⟩ := Ideal.span_singleton_le_span_singleton.1 (Ideal.le_of_dvd this)\n    use z\n    rw [map_mul, mul_comm, mul_eq_mul_left_iff] at hx\n    exact (hx.resolve_right fun h => by simp [hd0] at h).symm\n  classical\n  have ine {r : R} : r ≠ 0 → Ideal.span {r} ≠ ⊥ := mt Ideal.span_singleton_eq_bot.mp\n  rw [← Associates.mk_le_mk_iff_dvd, ← Associates.factors_le, Associates.factors_mk _ (ine hn0),\n    Associates.factors_mk _ (ine hd0), WithTop.coe_le_coe, Multiset.le_iff_count]\n  rintro ⟨v, hv⟩\n  obtain ⟨v, rfl⟩ := Associates.mk_surjective v\n  have hv' := hv\n  rw [Associates.irreducible_mk, irreducible_iff_prime] at hv\n  specialize h ⟨v, Ideal.isPrime_of_prime hv, hv.ne_zero⟩\n  simp_rw [valuation_of_mk', intValuation, ← Valuation.toFun_eq_coe,\n    intValuationDef_if_neg _ hn0, intValuationDef_if_neg _ hd0, ← WithZero.coe_div,\n    ← WithZero.coe_one, WithZero.coe_le_coe, Associates.factors_mk _ (ine hn0),\n    Associates.factors_mk _ (ine hd0), Associates.count_some hv'] at h\n  simpa using h\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.adicValued_apply","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\nx : K\n⊢ Eq (Valued.v x) (v.valuation x)","decl":"theorem adicValued_apply {x : K} : v.adicValued.v x = v.valuation x :=\n  rfl\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.valuedAdicCompletion_def","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\nx : IsDedekindDomain.HeightOneSpectrum.adicCompletion K v\n⊢ Eq (Valued.v x) (Valued.extension x)","decl":"theorem valuedAdicCompletion_def {x : v.adicCompletion K} :\n    Valued.v x = @Valued.extension K _ _ _ (adicValued v) x :=\n  rfl\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.adicCompletion_completeSpace","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\n⊢ CompleteSpace (IsDedekindDomain.HeightOneSpectrum.adicCompletion K v)","decl":"instance adicCompletion_completeSpace : CompleteSpace (v.adicCompletion K) := inferInstanceAs <|\n  CompleteSpace (@UniformSpace.Completion K v.adicValued.toUniformSpace)\n\n-- Porting note: replaced by `Coe`\n-- instance AdicCompletion.hasLiftT : HasLiftT K (v.adicCompletion K) :=\n--   (inferInstance : HasLiftT K (@UniformSpace.Completion K v.adicValued.toUniformSpace))\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.mem_adicCompletionIntegers","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\nx : IsDedekindDomain.HeightOneSpectrum.adicCompletion K v\n⊢ Iff (Membership.mem (IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers K v) x) (LE.le (Valued.v x) 1)","decl":"theorem mem_adicCompletionIntegers {x : v.adicCompletion K} :\n    x ∈ v.adicCompletionIntegers K ↔ (Valued.v x : ℤₘ₀) ≤ 1 :=\n  Iff.rfl\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.not_mem_adicCompletionIntegers","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\nx : IsDedekindDomain.HeightOneSpectrum.adicCompletion K v\n⊢ Iff (Not (Membership.mem (IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers K v) x)) (LT.lt 1 (Valued.v x))","decl":"theorem not_mem_adicCompletionIntegers {x : v.adicCompletion K} :\n    x ∉ v.adicCompletionIntegers K ↔ 1 < (Valued.v x : ℤₘ₀) := by\n  rw [not_congr <| mem_adicCompletionIntegers R K v]\n  exact not_le\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.adicValued.has_uniform_continuous_const_smul'","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\n⊢ UniformContinuousConstSMul R K","decl":"instance (priority := 100) adicValued.has_uniform_continuous_const_smul' :\n    @UniformContinuousConstSMul R K v.adicValued.toUniformSpace _ :=\n  @uniformContinuousConstSMul_of_continuousConstSMul R K _ _ _ v.adicValued.toUniformSpace _ _\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.adicValued.uniformContinuousConstSMul","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\n⊢ UniformContinuousConstSMul K K","decl":"instance adicValued.uniformContinuousConstSMul :\n    @UniformContinuousConstSMul K K v.adicValued.toUniformSpace _ :=\n  @Ring.uniformContinuousConstSMul K _ v.adicValued.toUniformSpace _ _\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.coe_smul_adicCompletion","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\nr : R\nx : K\n⊢ Eq (↑(HSMul.hSMul r x)) (HSMul.hSMul r ↑x)","decl":"theorem coe_smul_adicCompletion (r : R) (x : K) :\n    (↑(r • x) : v.adicCompletion K) = r • (↑x : v.adicCompletion K) :=\n  @UniformSpace.Completion.coe_smul R K v.adicValued.toUniformSpace _ _ r x\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.algebraMap_adicCompletion'","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\n⊢ Eq (⇑(algebraMap R (IsDedekindDomain.HeightOneSpectrum.adicCompletion K v))) (Function.comp UniformSpace.Completion.coe' ⇑(algebraMap R K))","decl":"theorem algebraMap_adicCompletion' :\n    ⇑(algebraMap R <| v.adicCompletion K) = (↑) ∘ algebraMap R K :=\n  rfl\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.algebraMap_adicCompletion","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\n⊢ Eq (⇑(algebraMap K (IsDedekindDomain.HeightOneSpectrum.adicCompletion K v))) UniformSpace.Completion.coe'","decl":"theorem algebraMap_adicCompletion :\n    ⇑(algebraMap K <| v.adicCompletion K) = ((↑) : K → adicCompletion K v) :=\n  rfl\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.instIsScalarTowerAdicCompletion","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\n⊢ IsScalarTower R K (IsDedekindDomain.HeightOneSpectrum.adicCompletion K v)","decl":"instance : IsScalarTower R K (v.adicCompletion K) := inferInstanceAs <|\n  IsScalarTower R K (@UniformSpace.Completion K v.adicValued.toUniformSpace)\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.coe_algebraMap_mem","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\nr : R\n⊢ Membership.mem (IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers K v) ↑((algebraMap R K) r)","decl":"theorem coe_algebraMap_mem (r : R) : ↑((algebraMap R K) r) ∈ adicCompletionIntegers K v := by\n  rw [mem_adicCompletionIntegers]\n  letI : Valued K ℤₘ₀ := adicValued v\n  dsimp only [adicCompletion]\n  rw [Valued.valuedCompletion_apply]\n  exact v.valuation_le_one _\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.valuedAdicCompletion_eq_valuation","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\nr : R\n⊢ Eq (Valued.v ↑r) (v.valuation ↑r)","decl":"variable {R K} in\nopen scoped algebraMap in -- to make the coercions from `R` fire\n/-- The valuation on the completion agrees with the global valuation on elements of the\ninteger ring. -/\ntheorem valuedAdicCompletion_eq_valuation (r : R) :\n    Valued.v (r : v.adicCompletion K) = v.valuation (r : K) := by\n  convert Valued.valuedCompletion_apply (r : K)\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.valuedAdicCompletion_eq_valuation'","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\nk : K\n⊢ Eq (Valued.v ↑k) (v.valuation k)","decl":"variable {R K} in\n/-- The valuation on the completion agrees with the global valuation on elements of the field. -/\ntheorem valuedAdicCompletion_eq_valuation' (k : K) :\n    Valued.v (k : v.adicCompletion K) = v.valuation k := by\n  convert Valued.valuedCompletion_apply k\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.coe_mem_adicCompletionIntegers","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\nr : R\n⊢ Membership.mem (IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers K v) ↑r","decl":"variable {R K} in\nopen scoped algebraMap in -- to make the coercion from `R` fire\n/-- A global integer is in the local integers. -/\nlemma coe_mem_adicCompletionIntegers (r : R) :\n    (r : adicCompletion K v) ∈ adicCompletionIntegers K v := by\n  rw [mem_adicCompletionIntegers, valuedAdicCompletion_eq_valuation, valuation_eq_intValuationDef]\n  exact intValuation_le_one v r\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.coe_smul_adicCompletionIntegers","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\nr : R\nx : Subtype fun x => Membership.mem (IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers K v) x\n⊢ Eq (↑(HSMul.hSMul r x)) (HSMul.hSMul r ↑x)","decl":"@[simp]\ntheorem coe_smul_adicCompletionIntegers (r : R) (x : v.adicCompletionIntegers K) :\n    (↑(r • x) : v.adicCompletion K) = r • (x : v.adicCompletion K) :=\n  rfl\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.instNoZeroSMulDivisorsSubtypeAdicCompletionMemValuationSubringAdicCompletionIntegers","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\n⊢ NoZeroSMulDivisors R (Subtype fun x => Membership.mem (IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers K v) x)","decl":"instance : NoZeroSMulDivisors R (v.adicCompletionIntegers K) where\n  eq_zero_or_eq_zero_of_smul_eq_zero {c x} hcx := by\n    rw [Algebra.smul_def, mul_eq_zero] at hcx\n    refine hcx.imp_left fun hc => ?_\n    letI : UniformSpace K := v.adicValued.toUniformSpace\n    rw [← map_zero (algebraMap R (v.adicCompletionIntegers K))] at hc\n    exact\n      IsFractionRing.injective R K (UniformSpace.Completion.coe_injective K (Subtype.ext_iff.mp hc))\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.adicCompletion.instIsScalarTower'","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\n⊢ IsScalarTower R (Subtype fun x => Membership.mem (IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers K v) x) (IsDedekindDomain.HeightOneSpectrum.adicCompletion K v)","decl":"instance adicCompletion.instIsScalarTower' :\n    IsScalarTower R (v.adicCompletionIntegers K) (v.adicCompletion K) where\n  smul_assoc x y z := by simp only [Algebra.smul_def]; apply mul_assoc\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.adicCompletion.mul_nonZeroDivisor_mem_adicCompletionIntegers","module":"Mathlib.RingTheory.DedekindDomain.AdicValuation","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\na : IsDedekindDomain.HeightOneSpectrum.adicCompletion K v\n⊢ Exists fun b => And (Membership.mem (nonZeroDivisors R) b) (Membership.mem (IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers K v) (HMul.hMul a ↑b))","decl":"open nonZeroDivisors algebraMap in\nvariable {R K} in\nlemma adicCompletion.mul_nonZeroDivisor_mem_adicCompletionIntegers (v : HeightOneSpectrum R)\n    (a : v.adicCompletion K) : ∃ b ∈ R⁰, a * b ∈ v.adicCompletionIntegers K := by\n  by_cases ha : a ∈ v.adicCompletionIntegers K\n  · use 1\n    simp [ha, Submonoid.one_mem]\n  · rw [not_mem_adicCompletionIntegers] at ha\n    -- Let the additive valuation of a be -d with d>0\n    obtain ⟨d, hd⟩ : ∃ d : ℤ, Valued.v a = ofAdd d :=\n      Option.ne_none_iff_exists'.mp <| (lt_trans zero_lt_one ha).ne'\n    rw [hd, WithZero.one_lt_coe, ← ofAdd_zero, ofAdd_lt] at ha\n    -- let ϖ be a uniformiser\n    obtain ⟨ϖ, hϖ⟩ := intValuation_exists_uniformizer v\n    have hϖ0 : ϖ ≠ 0 := by rintro rfl; simp at hϖ\n    -- use ϖ^d\n    refine ⟨ϖ^d.natAbs, pow_mem (mem_nonZeroDivisors_of_ne_zero hϖ0) _, ?_⟩\n    -- now manually translate the goal (an inequality in ℤₘ₀) to an inequality in ℤ\n    rw [mem_adicCompletionIntegers, algebraMap.coe_pow, map_mul, hd, map_pow,\n      valuedAdicCompletion_eq_valuation, valuation_eq_intValuationDef, hϖ, ← WithZero.coe_pow,\n      ← WithZero.coe_mul, WithZero.coe_le_one, ← toAdd_le, toAdd_mul, toAdd_ofAdd, toAdd_pow,\n      toAdd_ofAdd, toAdd_one,\n      show d.natAbs • (-1) = (d.natAbs : ℤ) • (-1) by simp only [nsmul_eq_mul,\n        Int.natCast_natAbs, smul_eq_mul],\n      ← Int.eq_natAbs_of_zero_le ha.le, smul_eq_mul]\n    -- and now it's easy\n    omega\n\n"}
