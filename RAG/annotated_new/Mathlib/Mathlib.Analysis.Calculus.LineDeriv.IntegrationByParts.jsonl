{"name":"integral_bilinear_hasLineDerivAt_right_eq_neg_left_of_integrable_aux1","module":"Mathlib.Analysis.Calculus.LineDeriv.IntegrationByParts","initialProofState":"E : Type u_1\nF : Type u_2\nG : Type u_3\nW : Type u_4\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace Real E\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace Real F\ninstâœâµ : NormedAddCommGroup G\ninstâœâ´ : NormedSpace Real G\ninstâœÂ³ : NormedAddCommGroup W\ninstâœÂ² : NormedSpace Real W\ninstâœÂ¹ : MeasurableSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : MeasureTheory.SigmaFinite Î¼\nf f' : Prod E Real â†’ F\ng g' : Prod E Real â†’ G\nB : ContinuousLinearMap (RingHom.id Real) F (ContinuousLinearMap (RingHom.id Real) G W)\nhf'g : MeasureTheory.Integrable (fun x => (B (f' x)) (g x)) (Î¼.prod MeasureTheory.MeasureSpace.volume)\nhfg' : MeasureTheory.Integrable (fun x => (B (f x)) (g' x)) (Î¼.prod MeasureTheory.MeasureSpace.volume)\nhfg : MeasureTheory.Integrable (fun x => (B (f x)) (g x)) (Î¼.prod MeasureTheory.MeasureSpace.volume)\nhf : âˆ€ (x : Prod E Real), HasLineDerivAt Real f (f' x) x { fst := 0, snd := 1 }\nhg : âˆ€ (x : Prod E Real), HasLineDerivAt Real g (g' x) x { fst := 0, snd := 1 }\nâŠ¢ Eq (MeasureTheory.integral (Î¼.prod MeasureTheory.MeasureSpace.volume) fun x => (B (f x)) (g' x)) (Neg.neg (MeasureTheory.integral (Î¼.prod MeasureTheory.MeasureSpace.volume) fun x => (B (f' x)) (g x)))","decl":"lemma integral_bilinear_hasLineDerivAt_right_eq_neg_left_of_integrable_aux1 [SigmaFinite Î¼]\n    {f f' : E Ã— â„ â†’ F} {g g' : E Ã— â„ â†’ G} {B : F â†’L[â„] G â†’L[â„] W}\n    (hf'g : Integrable (fun x â†¦ B (f' x) (g x)) (Î¼.prod volume))\n    (hfg' : Integrable (fun x â†¦ B (f x) (g' x)) (Î¼.prod volume))\n    (hfg : Integrable (fun x â†¦ B (f x) (g x)) (Î¼.prod volume))\n    (hf : âˆ€ x, HasLineDerivAt â„ f (f' x) x (0, 1)) (hg : âˆ€ x, HasLineDerivAt â„ g (g' x) x (0, 1)) :\n    âˆ« x, B (f x) (g' x) âˆ‚(Î¼.prod volume) = - âˆ« x, B (f' x) (g x) âˆ‚(Î¼.prod volume) := calc\n  âˆ« x, B (f x) (g' x) âˆ‚(Î¼.prod volume)\n    = âˆ« x, (âˆ« t, B (f (x, t)) (g' (x, t))) âˆ‚Î¼ := integral_prod _ hfg'\n  _ = âˆ« x, (- âˆ« t, B (f' (x, t)) (g (x, t))) âˆ‚Î¼ := by\n    apply integral_congr_ae\n    filter_upwards [hf'g.prod_right_ae, hfg'.prod_right_ae, hfg.prod_right_ae]\n      with x hf'gx hfg'x hfgx\n    apply integral_bilinear_hasDerivAt_right_eq_neg_left_of_integrable ?_ ?_ hfg'x hf'gx hfgx\n    Â· intro t\n      convert (hf (x, t)).scomp_of_eq t ((hasDerivAt_id t).add (hasDerivAt_const t (-t))) (by simp)\n        <;> simp\n    Â· intro t\n      convert (hg (x, t)).scomp_of_eq t ((hasDerivAt_id t).add (hasDerivAt_const t (-t))) (by simp)\n        <;> simp\n  _ = - âˆ« x, B (f' x) (g x) âˆ‚(Î¼.prod volume) := by rw [integral_neg, integral_prod _ hf'g]\n\n"}
{"name":"integral_bilinear_hasLineDerivAt_right_eq_neg_left_of_integrable_aux2","module":"Mathlib.Analysis.Calculus.LineDeriv.IntegrationByParts","initialProofState":"E : Type u_1\nF : Type u_2\nG : Type u_3\nW : Type u_4\ninstâœÂ¹Â¹ : NormedAddCommGroup E\ninstâœÂ¹â° : NormedSpace Real E\ninstâœâ¹ : NormedAddCommGroup F\ninstâœâ¸ : NormedSpace Real F\ninstâœâ· : NormedAddCommGroup G\ninstâœâ¶ : NormedSpace Real G\ninstâœâµ : NormedAddCommGroup W\ninstâœâ´ : NormedSpace Real W\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure (Prod E Real)\ninstâœ : Î¼.IsAddHaarMeasure\nf f' : Prod E Real â†’ F\ng g' : Prod E Real â†’ G\nB : ContinuousLinearMap (RingHom.id Real) F (ContinuousLinearMap (RingHom.id Real) G W)\nhf'g : MeasureTheory.Integrable (fun x => (B (f' x)) (g x)) Î¼\nhfg' : MeasureTheory.Integrable (fun x => (B (f x)) (g' x)) Î¼\nhfg : MeasureTheory.Integrable (fun x => (B (f x)) (g x)) Î¼\nhf : âˆ€ (x : Prod E Real), HasLineDerivAt Real f (f' x) x { fst := 0, snd := 1 }\nhg : âˆ€ (x : Prod E Real), HasLineDerivAt Real g (g' x) x { fst := 0, snd := 1 }\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => (B (f x)) (g' x)) (Neg.neg (MeasureTheory.integral Î¼ fun x => (B (f' x)) (g x)))","decl":"lemma integral_bilinear_hasLineDerivAt_right_eq_neg_left_of_integrable_aux2\n    [FiniteDimensional â„ E] {Î¼ : Measure (E Ã— â„)} [IsAddHaarMeasure Î¼]\n    {f f' : E Ã— â„ â†’ F} {g g' : E Ã— â„ â†’ G} {B : F â†’L[â„] G â†’L[â„] W}\n    (hf'g : Integrable (fun x â†¦ B (f' x) (g x)) Î¼)\n    (hfg' : Integrable (fun x â†¦ B (f x) (g' x)) Î¼)\n    (hfg : Integrable (fun x â†¦ B (f x) (g x)) Î¼)\n    (hf : âˆ€ x, HasLineDerivAt â„ f (f' x) x (0, 1)) (hg : âˆ€ x, HasLineDerivAt â„ g (g' x) x (0, 1)) :\n    âˆ« x, B (f x) (g' x) âˆ‚Î¼ = - âˆ« x, B (f' x) (g x) âˆ‚Î¼ := by\n  let Î½ : Measure E := addHaar\n  have A : Î½.prod volume = (addHaarScalarFactor (Î½.prod volume) Î¼) â€¢ Î¼ :=\n    isAddLeftInvariant_eq_smul _ _\n  have Hf'g : Integrable (fun x â†¦ B (f' x) (g x)) (Î½.prod volume) := by\n    rw [A]; exact hf'g.smul_measure_nnreal\n  have Hfg' : Integrable (fun x â†¦ B (f x) (g' x)) (Î½.prod volume) := by\n    rw [A]; exact hfg'.smul_measure_nnreal\n  have Hfg : Integrable (fun x â†¦ B (f x) (g x)) (Î½.prod volume) := by\n    rw [A]; exact hfg.smul_measure_nnreal\n  rw [isAddLeftInvariant_eq_smul Î¼ (Î½.prod volume)]\n  simp [integral_bilinear_hasLineDerivAt_right_eq_neg_left_of_integrable_aux1 Hf'g Hfg' Hfg hf hg]\n\n"}
{"name":"integral_bilinear_hasLineDerivAt_right_eq_neg_left_of_integrable","module":"Mathlib.Analysis.Calculus.LineDeriv.IntegrationByParts","initialProofState":"E : Type u_1\nF : Type u_2\nG : Type u_3\nW : Type u_4\ninstâœÂ¹Â¹ : NormedAddCommGroup E\ninstâœÂ¹â° : NormedSpace Real E\ninstâœâ¹ : NormedAddCommGroup F\ninstâœâ¸ : NormedSpace Real F\ninstâœâ· : NormedAddCommGroup G\ninstâœâ¶ : NormedSpace Real G\ninstâœâµ : NormedAddCommGroup W\ninstâœâ´ : NormedSpace Real W\ninstâœÂ³ : MeasurableSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\ninstâœ : Î¼.IsAddHaarMeasure\nf f' : E â†’ F\ng g' : E â†’ G\nv : E\nB : ContinuousLinearMap (RingHom.id Real) F (ContinuousLinearMap (RingHom.id Real) G W)\nhf'g : MeasureTheory.Integrable (fun x => (B (f' x)) (g x)) Î¼\nhfg' : MeasureTheory.Integrable (fun x => (B (f x)) (g' x)) Î¼\nhfg : MeasureTheory.Integrable (fun x => (B (f x)) (g x)) Î¼\nhf : âˆ€ (x : E), HasLineDerivAt Real f (f' x) x v\nhg : âˆ€ (x : E), HasLineDerivAt Real g (g' x) x v\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => (B (f x)) (g' x)) (Neg.neg (MeasureTheory.integral Î¼ fun x => (B (f' x)) (g x)))","decl":"/-- **Integration by parts for line derivatives**\nVersion with a general bilinear form `B`.\nIf `B f g` is integrable, as well as `B f' g` and `B f g'` where `f'` and `g'` are derivatives\nof `f` and `g` in a given direction `v`, then `âˆ« B f g' = - âˆ« B f' g`. -/\ntheorem integral_bilinear_hasLineDerivAt_right_eq_neg_left_of_integrable\n    {f f' : E â†’ F} {g g' : E â†’ G} {v : E} {B : F â†’L[â„] G â†’L[â„] W}\n    (hf'g : Integrable (fun x â†¦ B (f' x) (g x)) Î¼) (hfg' : Integrable (fun x â†¦ B (f x) (g' x)) Î¼)\n    (hfg : Integrable (fun x â†¦ B (f x) (g x)) Î¼)\n    (hf : âˆ€ x, HasLineDerivAt â„ f (f' x) x v) (hg : âˆ€ x, HasLineDerivAt â„ g (g' x) x v) :\n    âˆ« x, B (f x) (g' x) âˆ‚Î¼ = - âˆ« x, B (f' x) (g x) âˆ‚Î¼ := by\n  by_cases hW : CompleteSpace W; swap\n  Â· simp [integral, hW]\n  rcases eq_or_ne v 0 with rfl|hv\n  Â· have Hf' x : f' x = 0 := by\n      simpa [(hasLineDerivAt_zero (f := f) (x := x)).lineDeriv] using (hf x).lineDeriv.symm\n    have Hg' x : g' x = 0 := by\n      simpa [(hasLineDerivAt_zero (f := g) (x := x)).lineDeriv] using (hg x).lineDeriv.symm\n    simp [Hf', Hg']\n  have : Nontrivial E := nontrivial_iff.2 âŸ¨v, 0, hvâŸ©\n  let n := finrank â„ E\n  let E' := Fin (n - 1) â†’ â„\n  obtain âŸ¨L, hLâŸ© : âˆƒ L : E â‰ƒL[â„] (E' Ã— â„), L v = (0, 1) := by\n    have : finrank â„ (E' Ã— â„) = n := by simpa [this, E'] using Nat.sub_add_cancel finrank_pos\n    have Lâ‚€ : E â‰ƒL[â„] (E' Ã— â„) := (ContinuousLinearEquiv.ofFinrankEq this).symm\n    obtain âŸ¨M, hMâŸ© : âˆƒ M : (E' Ã— â„) â‰ƒL[â„] (E' Ã— â„), M (Lâ‚€ v) = (0, 1) := by\n      apply SeparatingDual.exists_continuousLinearEquiv_apply_eq\n      Â· simpa using hv\n      Â· simp\n    exact âŸ¨Lâ‚€.trans M, by simp [hM]âŸ©\n  let Î½ := Measure.map L Î¼\n  suffices H : âˆ« (x : E' Ã— â„), (B (f (L.symm x))) (g' (L.symm x)) âˆ‚Î½ =\n      -âˆ« (x : E' Ã— â„), (B (f' (L.symm x))) (g (L.symm x)) âˆ‚Î½ by\n    have : Î¼ = Measure.map L.symm Î½ := by\n      simp [Î½, Measure.map_map L.symm.continuous.measurable L.continuous.measurable]\n    have hL : IsClosedEmbedding L.symm := L.symm.toHomeomorph.isClosedEmbedding\n    simpa [this, hL.integral_map] using H\n  have L_emb : MeasurableEmbedding L := L.toHomeomorph.measurableEmbedding\n  apply integral_bilinear_hasLineDerivAt_right_eq_neg_left_of_integrable_aux2\n  Â· simpa [Î½, L_emb.integrable_map_iff, Function.comp_def] using hf'g\n  Â· simpa [Î½, L_emb.integrable_map_iff, Function.comp_def] using hfg'\n  Â· simpa [Î½, L_emb.integrable_map_iff, Function.comp_def] using hfg\n  Â· intro x\n    have : f = (f âˆ˜ L.symm) âˆ˜ (L : E â†’â‚—[â„] (E' Ã— â„)) := by ext y; simp\n    specialize hf (L.symm x)\n    rw [this] at hf\n    convert hf.of_comp using 1\n    Â· simp\n    Â· simp [â† hL]\n  Â· intro x\n    have : g = (g âˆ˜ L.symm) âˆ˜ (L : E â†’â‚—[â„] (E' Ã— â„)) := by ext y; simp\n    specialize hg (L.symm x)\n    rw [this] at hg\n    convert hg.of_comp using 1\n    Â· simp\n    Â· simp [â† hL]\n\n"}
{"name":"integral_bilinear_hasFDerivAt_right_eq_neg_left_of_integrable","module":"Mathlib.Analysis.Calculus.LineDeriv.IntegrationByParts","initialProofState":"E : Type u_1\nF : Type u_2\nG : Type u_3\nW : Type u_4\ninstâœÂ¹Â¹ : NormedAddCommGroup E\ninstâœÂ¹â° : NormedSpace Real E\ninstâœâ¹ : NormedAddCommGroup F\ninstâœâ¸ : NormedSpace Real F\ninstâœâ· : NormedAddCommGroup G\ninstâœâ¶ : NormedSpace Real G\ninstâœâµ : NormedAddCommGroup W\ninstâœâ´ : NormedSpace Real W\ninstâœÂ³ : MeasurableSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\ninstâœ : Î¼.IsAddHaarMeasure\nf : E â†’ F\nf' : E â†’ ContinuousLinearMap (RingHom.id Real) E F\ng : E â†’ G\ng' : E â†’ ContinuousLinearMap (RingHom.id Real) E G\nv : E\nB : ContinuousLinearMap (RingHom.id Real) F (ContinuousLinearMap (RingHom.id Real) G W)\nhf'g : MeasureTheory.Integrable (fun x => (B ((f' x) v)) (g x)) Î¼\nhfg' : MeasureTheory.Integrable (fun x => (B (f x)) ((g' x) v)) Î¼\nhfg : MeasureTheory.Integrable (fun x => (B (f x)) (g x)) Î¼\nhf : âˆ€ (x : E), HasFDerivAt f (f' x) x\nhg : âˆ€ (x : E), HasFDerivAt g (g' x) x\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => (B (f x)) ((g' x) v)) (Neg.neg (MeasureTheory.integral Î¼ fun x => (B ((f' x) v)) (g x)))","decl":"/-- **Integration by parts for FrÃ©chet derivatives**\nVersion with a general bilinear form `B`.\nIf `B f g` is integrable, as well as `B f' g` and `B f g'` where `f'` and `g'` are derivatives\nof `f` and `g` in a given direction `v`, then `âˆ« B f g' = - âˆ« B f' g`. -/\ntheorem integral_bilinear_hasFDerivAt_right_eq_neg_left_of_integrable\n    {f : E â†’ F} {f' : E â†’ (E â†’L[â„] F)}\n    {g : E â†’ G} {g' : E â†’ (E â†’L[â„] G)} {v : E} {B : F â†’L[â„] G â†’L[â„] W}\n    (hf'g : Integrable (fun x â†¦ B (f' x v) (g x)) Î¼)\n    (hfg' : Integrable (fun x â†¦ B (f x) (g' x v)) Î¼)\n    (hfg : Integrable (fun x â†¦ B (f x) (g x)) Î¼)\n    (hf : âˆ€ x, HasFDerivAt f (f' x) x) (hg : âˆ€ x, HasFDerivAt g (g' x) x) :\n    âˆ« x, B (f x) (g' x v) âˆ‚Î¼ = - âˆ« x, B (f' x v) (g x) âˆ‚Î¼ :=\n  integral_bilinear_hasLineDerivAt_right_eq_neg_left_of_integrable hf'g hfg' hfg\n    (fun x â†¦ (hf x).hasLineDerivAt v) (fun x â†¦ (hg x).hasLineDerivAt v)\n\n"}
{"name":"integral_bilinear_fderiv_right_eq_neg_left_of_integrable","module":"Mathlib.Analysis.Calculus.LineDeriv.IntegrationByParts","initialProofState":"E : Type u_1\nF : Type u_2\nG : Type u_3\nW : Type u_4\ninstâœÂ¹Â¹ : NormedAddCommGroup E\ninstâœÂ¹â° : NormedSpace Real E\ninstâœâ¹ : NormedAddCommGroup F\ninstâœâ¸ : NormedSpace Real F\ninstâœâ· : NormedAddCommGroup G\ninstâœâ¶ : NormedSpace Real G\ninstâœâµ : NormedAddCommGroup W\ninstâœâ´ : NormedSpace Real W\ninstâœÂ³ : MeasurableSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\ninstâœ : Î¼.IsAddHaarMeasure\nf : E â†’ F\ng : E â†’ G\nv : E\nB : ContinuousLinearMap (RingHom.id Real) F (ContinuousLinearMap (RingHom.id Real) G W)\nhf'g : MeasureTheory.Integrable (fun x => (B ((fderiv Real f x) v)) (g x)) Î¼\nhfg' : MeasureTheory.Integrable (fun x => (B (f x)) ((fderiv Real g x) v)) Î¼\nhfg : MeasureTheory.Integrable (fun x => (B (f x)) (g x)) Î¼\nhf : Differentiable Real f\nhg : Differentiable Real g\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => (B (f x)) ((fderiv Real g x) v)) (Neg.neg (MeasureTheory.integral Î¼ fun x => (B ((fderiv Real f x) v)) (g x)))","decl":"/-- **Integration by parts for FrÃ©chet derivatives**\nVersion with a general bilinear form `B`.\nIf `B f g` is integrable, as well as `B f' g` and `B f g'` where `f'` and `g'` are the derivatives\nof `f` and `g` in a given direction `v`, then `âˆ« B f g' = - âˆ« B f' g`. -/\ntheorem integral_bilinear_fderiv_right_eq_neg_left_of_integrable\n    {f : E â†’ F} {g : E â†’ G} {v : E} {B : F â†’L[â„] G â†’L[â„] W}\n    (hf'g : Integrable (fun x â†¦ B (fderiv â„ f x v) (g x)) Î¼)\n    (hfg' : Integrable (fun x â†¦ B (f x) (fderiv â„ g x v)) Î¼)\n    (hfg : Integrable (fun x â†¦ B (f x) (g x)) Î¼)\n    (hf : Differentiable â„ f) (hg : Differentiable â„ g) :\n    âˆ« x, B (f x) (fderiv â„ g x v) âˆ‚Î¼ = - âˆ« x, B (fderiv â„ f x v) (g x) âˆ‚Î¼ :=\n  integral_bilinear_hasFDerivAt_right_eq_neg_left_of_integrable hf'g hfg' hfg\n    (fun x â†¦ (hf x).hasFDerivAt) (fun x â†¦ (hg x).hasFDerivAt)\n\n"}
{"name":"integral_smul_fderiv_eq_neg_fderiv_smul_of_integrable","module":"Mathlib.Analysis.Calculus.LineDeriv.IntegrationByParts","initialProofState":"E : Type u_1\nG : Type u_3\ninstâœÂ¹Â¹ : NormedAddCommGroup E\ninstâœÂ¹â° : NormedSpace Real E\ninstâœâ¹ : NormedAddCommGroup G\ninstâœâ¸ : NormedSpace Real G\ninstâœâ· : MeasurableSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœâ¶ : BorelSpace E\ninstâœâµ : FiniteDimensional Real E\ninstâœâ´ : Î¼.IsAddHaarMeasure\nğ•œ : Type u_5\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : NormedAlgebra Real ğ•œ\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : IsScalarTower Real ğ•œ G\nf : E â†’ ğ•œ\ng : E â†’ G\nv : E\nhf'g : MeasureTheory.Integrable (fun x => HSMul.hSMul ((fderiv Real f x) v) (g x)) Î¼\nhfg' : MeasureTheory.Integrable (fun x => HSMul.hSMul (f x) ((fderiv Real g x) v)) Î¼\nhfg : MeasureTheory.Integrable (fun x => HSMul.hSMul (f x) (g x)) Î¼\nhf : Differentiable Real f\nhg : Differentiable Real g\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => HSMul.hSMul (f x) ((fderiv Real g x) v)) (Neg.neg (MeasureTheory.integral Î¼ fun x => HSMul.hSMul ((fderiv Real f x) v) (g x)))","decl":"/-- **Integration by parts for FrÃ©chet derivatives**\nVersion with a scalar function: `âˆ« f â€¢ g' = - âˆ« f' â€¢ g` when `f â€¢ g'` and `f' â€¢ g` and `f â€¢ g`\nare integrable, where `f'` and `g'` are the derivatives of `f` and `g` in a given direction `v`. -/\ntheorem integral_smul_fderiv_eq_neg_fderiv_smul_of_integrable\n    {f : E â†’ ğ•œ} {g : E â†’ G} {v : E}\n    (hf'g : Integrable (fun x â†¦ fderiv â„ f x v â€¢ g x) Î¼)\n    (hfg' : Integrable (fun x â†¦ f x â€¢ fderiv â„ g x v) Î¼)\n    (hfg : Integrable (fun x â†¦ f x â€¢ g x) Î¼)\n    (hf : Differentiable â„ f) (hg : Differentiable â„ g) :\n    âˆ« x, f x â€¢ fderiv â„ g x v âˆ‚Î¼ = - âˆ« x, fderiv â„ f x v â€¢ g x âˆ‚Î¼ :=\n  integral_bilinear_fderiv_right_eq_neg_left_of_integrable\n    (B := ContinuousLinearMap.lsmul â„ ğ•œ) hf'g hfg' hfg hf hg\n\n"}
{"name":"integral_mul_fderiv_eq_neg_fderiv_mul_of_integrable","module":"Mathlib.Analysis.Calculus.LineDeriv.IntegrationByParts","initialProofState":"E : Type u_1\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\ninstâœâµ : MeasurableSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœâ´ : BorelSpace E\ninstâœÂ³ : FiniteDimensional Real E\ninstâœÂ² : Î¼.IsAddHaarMeasure\nğ•œ : Type u_5\ninstâœÂ¹ : NormedField ğ•œ\ninstâœ : NormedAlgebra Real ğ•œ\nf g : E â†’ ğ•œ\nv : E\nhf'g : MeasureTheory.Integrable (fun x => HMul.hMul ((fderiv Real f x) v) (g x)) Î¼\nhfg' : MeasureTheory.Integrable (fun x => HMul.hMul (f x) ((fderiv Real g x) v)) Î¼\nhfg : MeasureTheory.Integrable (fun x => HMul.hMul (f x) (g x)) Î¼\nhf : Differentiable Real f\nhg : Differentiable Real g\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => HMul.hMul (f x) ((fderiv Real g x) v)) (Neg.neg (MeasureTheory.integral Î¼ fun x => HMul.hMul ((fderiv Real f x) v) (g x)))","decl":"/-- **Integration by parts for FrÃ©chet derivatives**\nVersion with two scalar functions: `âˆ« f * g' = - âˆ« f' * g` when `f * g'` and `f' * g` and `f * g`\nare integrable, where `f'` and `g'` are the derivatives of `f` and `g` in a given direction `v`. -/\ntheorem integral_mul_fderiv_eq_neg_fderiv_mul_of_integrable\n    {f : E â†’ ğ•œ} {g : E â†’ ğ•œ} {v : E}\n    (hf'g : Integrable (fun x â†¦ fderiv â„ f x v * g x) Î¼)\n    (hfg' : Integrable (fun x â†¦ f x * fderiv â„ g x v) Î¼)\n    (hfg : Integrable (fun x â†¦ f x * g x) Î¼)\n    (hf : Differentiable â„ f) (hg : Differentiable â„ g) :\n    âˆ« x, f x * fderiv â„ g x v âˆ‚Î¼ = - âˆ« x, fderiv â„ f x v * g x âˆ‚Î¼ :=\n  integral_bilinear_fderiv_right_eq_neg_left_of_integrable\n    (B := ContinuousLinearMap.mul â„ ğ•œ) hf'g hfg' hfg hf hg\n"}
