{"name":"integral_bilinear_hasLineDerivAt_right_eq_neg_left_of_integrable_aux1","module":"Mathlib.Analysis.Calculus.LineDeriv.IntegrationByParts","initialProofState":"E : Type u_1\nF : Type u_2\nG : Type u_3\nW : Type u_4\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace Real E\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace Real F\ninst✝⁵ : NormedAddCommGroup G\ninst✝⁴ : NormedSpace Real G\ninst✝³ : NormedAddCommGroup W\ninst✝² : NormedSpace Real W\ninst✝¹ : MeasurableSpace E\nμ : MeasureTheory.Measure E\ninst✝ : MeasureTheory.SigmaFinite μ\nf f' : Prod E Real → F\ng g' : Prod E Real → G\nB : ContinuousLinearMap (RingHom.id Real) F (ContinuousLinearMap (RingHom.id Real) G W)\nhf'g : MeasureTheory.Integrable (fun x => (B (f' x)) (g x)) (μ.prod MeasureTheory.MeasureSpace.volume)\nhfg' : MeasureTheory.Integrable (fun x => (B (f x)) (g' x)) (μ.prod MeasureTheory.MeasureSpace.volume)\nhfg : MeasureTheory.Integrable (fun x => (B (f x)) (g x)) (μ.prod MeasureTheory.MeasureSpace.volume)\nhf : ∀ (x : Prod E Real), HasLineDerivAt Real f (f' x) x { fst := 0, snd := 1 }\nhg : ∀ (x : Prod E Real), HasLineDerivAt Real g (g' x) x { fst := 0, snd := 1 }\n⊢ Eq (MeasureTheory.integral (μ.prod MeasureTheory.MeasureSpace.volume) fun x => (B (f x)) (g' x)) (Neg.neg (MeasureTheory.integral (μ.prod MeasureTheory.MeasureSpace.volume) fun x => (B (f' x)) (g x)))","decl":"lemma integral_bilinear_hasLineDerivAt_right_eq_neg_left_of_integrable_aux1 [SigmaFinite μ]\n    {f f' : E × ℝ → F} {g g' : E × ℝ → G} {B : F →L[ℝ] G →L[ℝ] W}\n    (hf'g : Integrable (fun x ↦ B (f' x) (g x)) (μ.prod volume))\n    (hfg' : Integrable (fun x ↦ B (f x) (g' x)) (μ.prod volume))\n    (hfg : Integrable (fun x ↦ B (f x) (g x)) (μ.prod volume))\n    (hf : ∀ x, HasLineDerivAt ℝ f (f' x) x (0, 1)) (hg : ∀ x, HasLineDerivAt ℝ g (g' x) x (0, 1)) :\n    ∫ x, B (f x) (g' x) ∂(μ.prod volume) = - ∫ x, B (f' x) (g x) ∂(μ.prod volume) := calc\n  ∫ x, B (f x) (g' x) ∂(μ.prod volume)\n    = ∫ x, (∫ t, B (f (x, t)) (g' (x, t))) ∂μ := integral_prod _ hfg'\n  _ = ∫ x, (- ∫ t, B (f' (x, t)) (g (x, t))) ∂μ := by\n    apply integral_congr_ae\n    filter_upwards [hf'g.prod_right_ae, hfg'.prod_right_ae, hfg.prod_right_ae]\n      with x hf'gx hfg'x hfgx\n    apply integral_bilinear_hasDerivAt_right_eq_neg_left_of_integrable ?_ ?_ hfg'x hf'gx hfgx\n    · intro t\n      convert (hf (x, t)).scomp_of_eq t ((hasDerivAt_id t).add (hasDerivAt_const t (-t))) (by simp)\n        <;> simp\n    · intro t\n      convert (hg (x, t)).scomp_of_eq t ((hasDerivAt_id t).add (hasDerivAt_const t (-t))) (by simp)\n        <;> simp\n  _ = - ∫ x, B (f' x) (g x) ∂(μ.prod volume) := by rw [integral_neg, integral_prod _ hf'g]\n\n"}
{"name":"integral_bilinear_hasLineDerivAt_right_eq_neg_left_of_integrable_aux2","module":"Mathlib.Analysis.Calculus.LineDeriv.IntegrationByParts","initialProofState":"E : Type u_1\nF : Type u_2\nG : Type u_3\nW : Type u_4\ninst✝¹¹ : NormedAddCommGroup E\ninst✝¹⁰ : NormedSpace Real E\ninst✝⁹ : NormedAddCommGroup F\ninst✝⁸ : NormedSpace Real F\ninst✝⁷ : NormedAddCommGroup G\ninst✝⁶ : NormedSpace Real G\ninst✝⁵ : NormedAddCommGroup W\ninst✝⁴ : NormedSpace Real W\ninst✝³ : MeasurableSpace E\ninst✝² : BorelSpace E\ninst✝¹ : FiniteDimensional Real E\nμ : MeasureTheory.Measure (Prod E Real)\ninst✝ : μ.IsAddHaarMeasure\nf f' : Prod E Real → F\ng g' : Prod E Real → G\nB : ContinuousLinearMap (RingHom.id Real) F (ContinuousLinearMap (RingHom.id Real) G W)\nhf'g : MeasureTheory.Integrable (fun x => (B (f' x)) (g x)) μ\nhfg' : MeasureTheory.Integrable (fun x => (B (f x)) (g' x)) μ\nhfg : MeasureTheory.Integrable (fun x => (B (f x)) (g x)) μ\nhf : ∀ (x : Prod E Real), HasLineDerivAt Real f (f' x) x { fst := 0, snd := 1 }\nhg : ∀ (x : Prod E Real), HasLineDerivAt Real g (g' x) x { fst := 0, snd := 1 }\n⊢ Eq (MeasureTheory.integral μ fun x => (B (f x)) (g' x)) (Neg.neg (MeasureTheory.integral μ fun x => (B (f' x)) (g x)))","decl":"lemma integral_bilinear_hasLineDerivAt_right_eq_neg_left_of_integrable_aux2\n    [FiniteDimensional ℝ E] {μ : Measure (E × ℝ)} [IsAddHaarMeasure μ]\n    {f f' : E × ℝ → F} {g g' : E × ℝ → G} {B : F →L[ℝ] G →L[ℝ] W}\n    (hf'g : Integrable (fun x ↦ B (f' x) (g x)) μ)\n    (hfg' : Integrable (fun x ↦ B (f x) (g' x)) μ)\n    (hfg : Integrable (fun x ↦ B (f x) (g x)) μ)\n    (hf : ∀ x, HasLineDerivAt ℝ f (f' x) x (0, 1)) (hg : ∀ x, HasLineDerivAt ℝ g (g' x) x (0, 1)) :\n    ∫ x, B (f x) (g' x) ∂μ = - ∫ x, B (f' x) (g x) ∂μ := by\n  let ν : Measure E := addHaar\n  have A : ν.prod volume = (addHaarScalarFactor (ν.prod volume) μ) • μ :=\n    isAddLeftInvariant_eq_smul _ _\n  have Hf'g : Integrable (fun x ↦ B (f' x) (g x)) (ν.prod volume) := by\n    rw [A]; exact hf'g.smul_measure_nnreal\n  have Hfg' : Integrable (fun x ↦ B (f x) (g' x)) (ν.prod volume) := by\n    rw [A]; exact hfg'.smul_measure_nnreal\n  have Hfg : Integrable (fun x ↦ B (f x) (g x)) (ν.prod volume) := by\n    rw [A]; exact hfg.smul_measure_nnreal\n  rw [isAddLeftInvariant_eq_smul μ (ν.prod volume)]\n  simp [integral_bilinear_hasLineDerivAt_right_eq_neg_left_of_integrable_aux1 Hf'g Hfg' Hfg hf hg]\n\n"}
{"name":"integral_bilinear_hasLineDerivAt_right_eq_neg_left_of_integrable","module":"Mathlib.Analysis.Calculus.LineDeriv.IntegrationByParts","initialProofState":"E : Type u_1\nF : Type u_2\nG : Type u_3\nW : Type u_4\ninst✝¹¹ : NormedAddCommGroup E\ninst✝¹⁰ : NormedSpace Real E\ninst✝⁹ : NormedAddCommGroup F\ninst✝⁸ : NormedSpace Real F\ninst✝⁷ : NormedAddCommGroup G\ninst✝⁶ : NormedSpace Real G\ninst✝⁵ : NormedAddCommGroup W\ninst✝⁴ : NormedSpace Real W\ninst✝³ : MeasurableSpace E\nμ : MeasureTheory.Measure E\ninst✝² : BorelSpace E\ninst✝¹ : FiniteDimensional Real E\ninst✝ : μ.IsAddHaarMeasure\nf f' : E → F\ng g' : E → G\nv : E\nB : ContinuousLinearMap (RingHom.id Real) F (ContinuousLinearMap (RingHom.id Real) G W)\nhf'g : MeasureTheory.Integrable (fun x => (B (f' x)) (g x)) μ\nhfg' : MeasureTheory.Integrable (fun x => (B (f x)) (g' x)) μ\nhfg : MeasureTheory.Integrable (fun x => (B (f x)) (g x)) μ\nhf : ∀ (x : E), HasLineDerivAt Real f (f' x) x v\nhg : ∀ (x : E), HasLineDerivAt Real g (g' x) x v\n⊢ Eq (MeasureTheory.integral μ fun x => (B (f x)) (g' x)) (Neg.neg (MeasureTheory.integral μ fun x => (B (f' x)) (g x)))","decl":"/-- **Integration by parts for line derivatives**\nVersion with a general bilinear form `B`.\nIf `B f g` is integrable, as well as `B f' g` and `B f g'` where `f'` and `g'` are derivatives\nof `f` and `g` in a given direction `v`, then `∫ B f g' = - ∫ B f' g`. -/\ntheorem integral_bilinear_hasLineDerivAt_right_eq_neg_left_of_integrable\n    {f f' : E → F} {g g' : E → G} {v : E} {B : F →L[ℝ] G →L[ℝ] W}\n    (hf'g : Integrable (fun x ↦ B (f' x) (g x)) μ) (hfg' : Integrable (fun x ↦ B (f x) (g' x)) μ)\n    (hfg : Integrable (fun x ↦ B (f x) (g x)) μ)\n    (hf : ∀ x, HasLineDerivAt ℝ f (f' x) x v) (hg : ∀ x, HasLineDerivAt ℝ g (g' x) x v) :\n    ∫ x, B (f x) (g' x) ∂μ = - ∫ x, B (f' x) (g x) ∂μ := by\n  by_cases hW : CompleteSpace W; swap\n  · simp [integral, hW]\n  rcases eq_or_ne v 0 with rfl|hv\n  · have Hf' x : f' x = 0 := by\n      simpa [(hasLineDerivAt_zero (f := f) (x := x)).lineDeriv] using (hf x).lineDeriv.symm\n    have Hg' x : g' x = 0 := by\n      simpa [(hasLineDerivAt_zero (f := g) (x := x)).lineDeriv] using (hg x).lineDeriv.symm\n    simp [Hf', Hg']\n  have : Nontrivial E := nontrivial_iff.2 ⟨v, 0, hv⟩\n  let n := finrank ℝ E\n  let E' := Fin (n - 1) → ℝ\n  obtain ⟨L, hL⟩ : ∃ L : E ≃L[ℝ] (E' × ℝ), L v = (0, 1) := by\n    have : finrank ℝ (E' × ℝ) = n := by simpa [this, E'] using Nat.sub_add_cancel finrank_pos\n    have L₀ : E ≃L[ℝ] (E' × ℝ) := (ContinuousLinearEquiv.ofFinrankEq this).symm\n    obtain ⟨M, hM⟩ : ∃ M : (E' × ℝ) ≃L[ℝ] (E' × ℝ), M (L₀ v) = (0, 1) := by\n      apply SeparatingDual.exists_continuousLinearEquiv_apply_eq\n      · simpa using hv\n      · simp\n    exact ⟨L₀.trans M, by simp [hM]⟩\n  let ν := Measure.map L μ\n  suffices H : ∫ (x : E' × ℝ), (B (f (L.symm x))) (g' (L.symm x)) ∂ν =\n      -∫ (x : E' × ℝ), (B (f' (L.symm x))) (g (L.symm x)) ∂ν by\n    have : μ = Measure.map L.symm ν := by\n      simp [ν, Measure.map_map L.symm.continuous.measurable L.continuous.measurable]\n    have hL : IsClosedEmbedding L.symm := L.symm.toHomeomorph.isClosedEmbedding\n    simpa [this, hL.integral_map] using H\n  have L_emb : MeasurableEmbedding L := L.toHomeomorph.measurableEmbedding\n  apply integral_bilinear_hasLineDerivAt_right_eq_neg_left_of_integrable_aux2\n  · simpa [ν, L_emb.integrable_map_iff, Function.comp_def] using hf'g\n  · simpa [ν, L_emb.integrable_map_iff, Function.comp_def] using hfg'\n  · simpa [ν, L_emb.integrable_map_iff, Function.comp_def] using hfg\n  · intro x\n    have : f = (f ∘ L.symm) ∘ (L : E →ₗ[ℝ] (E' × ℝ)) := by ext y; simp\n    specialize hf (L.symm x)\n    rw [this] at hf\n    convert hf.of_comp using 1\n    · simp\n    · simp [← hL]\n  · intro x\n    have : g = (g ∘ L.symm) ∘ (L : E →ₗ[ℝ] (E' × ℝ)) := by ext y; simp\n    specialize hg (L.symm x)\n    rw [this] at hg\n    convert hg.of_comp using 1\n    · simp\n    · simp [← hL]\n\n"}
{"name":"integral_bilinear_hasFDerivAt_right_eq_neg_left_of_integrable","module":"Mathlib.Analysis.Calculus.LineDeriv.IntegrationByParts","initialProofState":"E : Type u_1\nF : Type u_2\nG : Type u_3\nW : Type u_4\ninst✝¹¹ : NormedAddCommGroup E\ninst✝¹⁰ : NormedSpace Real E\ninst✝⁹ : NormedAddCommGroup F\ninst✝⁸ : NormedSpace Real F\ninst✝⁷ : NormedAddCommGroup G\ninst✝⁶ : NormedSpace Real G\ninst✝⁵ : NormedAddCommGroup W\ninst✝⁴ : NormedSpace Real W\ninst✝³ : MeasurableSpace E\nμ : MeasureTheory.Measure E\ninst✝² : BorelSpace E\ninst✝¹ : FiniteDimensional Real E\ninst✝ : μ.IsAddHaarMeasure\nf : E → F\nf' : E → ContinuousLinearMap (RingHom.id Real) E F\ng : E → G\ng' : E → ContinuousLinearMap (RingHom.id Real) E G\nv : E\nB : ContinuousLinearMap (RingHom.id Real) F (ContinuousLinearMap (RingHom.id Real) G W)\nhf'g : MeasureTheory.Integrable (fun x => (B ((f' x) v)) (g x)) μ\nhfg' : MeasureTheory.Integrable (fun x => (B (f x)) ((g' x) v)) μ\nhfg : MeasureTheory.Integrable (fun x => (B (f x)) (g x)) μ\nhf : ∀ (x : E), HasFDerivAt f (f' x) x\nhg : ∀ (x : E), HasFDerivAt g (g' x) x\n⊢ Eq (MeasureTheory.integral μ fun x => (B (f x)) ((g' x) v)) (Neg.neg (MeasureTheory.integral μ fun x => (B ((f' x) v)) (g x)))","decl":"/-- **Integration by parts for Fréchet derivatives**\nVersion with a general bilinear form `B`.\nIf `B f g` is integrable, as well as `B f' g` and `B f g'` where `f'` and `g'` are derivatives\nof `f` and `g` in a given direction `v`, then `∫ B f g' = - ∫ B f' g`. -/\ntheorem integral_bilinear_hasFDerivAt_right_eq_neg_left_of_integrable\n    {f : E → F} {f' : E → (E →L[ℝ] F)}\n    {g : E → G} {g' : E → (E →L[ℝ] G)} {v : E} {B : F →L[ℝ] G →L[ℝ] W}\n    (hf'g : Integrable (fun x ↦ B (f' x v) (g x)) μ)\n    (hfg' : Integrable (fun x ↦ B (f x) (g' x v)) μ)\n    (hfg : Integrable (fun x ↦ B (f x) (g x)) μ)\n    (hf : ∀ x, HasFDerivAt f (f' x) x) (hg : ∀ x, HasFDerivAt g (g' x) x) :\n    ∫ x, B (f x) (g' x v) ∂μ = - ∫ x, B (f' x v) (g x) ∂μ :=\n  integral_bilinear_hasLineDerivAt_right_eq_neg_left_of_integrable hf'g hfg' hfg\n    (fun x ↦ (hf x).hasLineDerivAt v) (fun x ↦ (hg x).hasLineDerivAt v)\n\n"}
{"name":"integral_bilinear_fderiv_right_eq_neg_left_of_integrable","module":"Mathlib.Analysis.Calculus.LineDeriv.IntegrationByParts","initialProofState":"E : Type u_1\nF : Type u_2\nG : Type u_3\nW : Type u_4\ninst✝¹¹ : NormedAddCommGroup E\ninst✝¹⁰ : NormedSpace Real E\ninst✝⁹ : NormedAddCommGroup F\ninst✝⁸ : NormedSpace Real F\ninst✝⁷ : NormedAddCommGroup G\ninst✝⁶ : NormedSpace Real G\ninst✝⁵ : NormedAddCommGroup W\ninst✝⁴ : NormedSpace Real W\ninst✝³ : MeasurableSpace E\nμ : MeasureTheory.Measure E\ninst✝² : BorelSpace E\ninst✝¹ : FiniteDimensional Real E\ninst✝ : μ.IsAddHaarMeasure\nf : E → F\ng : E → G\nv : E\nB : ContinuousLinearMap (RingHom.id Real) F (ContinuousLinearMap (RingHom.id Real) G W)\nhf'g : MeasureTheory.Integrable (fun x => (B ((fderiv Real f x) v)) (g x)) μ\nhfg' : MeasureTheory.Integrable (fun x => (B (f x)) ((fderiv Real g x) v)) μ\nhfg : MeasureTheory.Integrable (fun x => (B (f x)) (g x)) μ\nhf : Differentiable Real f\nhg : Differentiable Real g\n⊢ Eq (MeasureTheory.integral μ fun x => (B (f x)) ((fderiv Real g x) v)) (Neg.neg (MeasureTheory.integral μ fun x => (B ((fderiv Real f x) v)) (g x)))","decl":"/-- **Integration by parts for Fréchet derivatives**\nVersion with a general bilinear form `B`.\nIf `B f g` is integrable, as well as `B f' g` and `B f g'` where `f'` and `g'` are the derivatives\nof `f` and `g` in a given direction `v`, then `∫ B f g' = - ∫ B f' g`. -/\ntheorem integral_bilinear_fderiv_right_eq_neg_left_of_integrable\n    {f : E → F} {g : E → G} {v : E} {B : F →L[ℝ] G →L[ℝ] W}\n    (hf'g : Integrable (fun x ↦ B (fderiv ℝ f x v) (g x)) μ)\n    (hfg' : Integrable (fun x ↦ B (f x) (fderiv ℝ g x v)) μ)\n    (hfg : Integrable (fun x ↦ B (f x) (g x)) μ)\n    (hf : Differentiable ℝ f) (hg : Differentiable ℝ g) :\n    ∫ x, B (f x) (fderiv ℝ g x v) ∂μ = - ∫ x, B (fderiv ℝ f x v) (g x) ∂μ :=\n  integral_bilinear_hasFDerivAt_right_eq_neg_left_of_integrable hf'g hfg' hfg\n    (fun x ↦ (hf x).hasFDerivAt) (fun x ↦ (hg x).hasFDerivAt)\n\n"}
{"name":"integral_smul_fderiv_eq_neg_fderiv_smul_of_integrable","module":"Mathlib.Analysis.Calculus.LineDeriv.IntegrationByParts","initialProofState":"E : Type u_1\nG : Type u_3\ninst✝¹¹ : NormedAddCommGroup E\ninst✝¹⁰ : NormedSpace Real E\ninst✝⁹ : NormedAddCommGroup G\ninst✝⁸ : NormedSpace Real G\ninst✝⁷ : MeasurableSpace E\nμ : MeasureTheory.Measure E\ninst✝⁶ : BorelSpace E\ninst✝⁵ : FiniteDimensional Real E\ninst✝⁴ : μ.IsAddHaarMeasure\n𝕜 : Type u_5\ninst✝³ : NormedField 𝕜\ninst✝² : NormedAlgebra Real 𝕜\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : IsScalarTower Real 𝕜 G\nf : E → 𝕜\ng : E → G\nv : E\nhf'g : MeasureTheory.Integrable (fun x => HSMul.hSMul ((fderiv Real f x) v) (g x)) μ\nhfg' : MeasureTheory.Integrable (fun x => HSMul.hSMul (f x) ((fderiv Real g x) v)) μ\nhfg : MeasureTheory.Integrable (fun x => HSMul.hSMul (f x) (g x)) μ\nhf : Differentiable Real f\nhg : Differentiable Real g\n⊢ Eq (MeasureTheory.integral μ fun x => HSMul.hSMul (f x) ((fderiv Real g x) v)) (Neg.neg (MeasureTheory.integral μ fun x => HSMul.hSMul ((fderiv Real f x) v) (g x)))","decl":"/-- **Integration by parts for Fréchet derivatives**\nVersion with a scalar function: `∫ f • g' = - ∫ f' • g` when `f • g'` and `f' • g` and `f • g`\nare integrable, where `f'` and `g'` are the derivatives of `f` and `g` in a given direction `v`. -/\ntheorem integral_smul_fderiv_eq_neg_fderiv_smul_of_integrable\n    {f : E → 𝕜} {g : E → G} {v : E}\n    (hf'g : Integrable (fun x ↦ fderiv ℝ f x v • g x) μ)\n    (hfg' : Integrable (fun x ↦ f x • fderiv ℝ g x v) μ)\n    (hfg : Integrable (fun x ↦ f x • g x) μ)\n    (hf : Differentiable ℝ f) (hg : Differentiable ℝ g) :\n    ∫ x, f x • fderiv ℝ g x v ∂μ = - ∫ x, fderiv ℝ f x v • g x ∂μ :=\n  integral_bilinear_fderiv_right_eq_neg_left_of_integrable\n    (B := ContinuousLinearMap.lsmul ℝ 𝕜) hf'g hfg' hfg hf hg\n\n"}
{"name":"integral_mul_fderiv_eq_neg_fderiv_mul_of_integrable","module":"Mathlib.Analysis.Calculus.LineDeriv.IntegrationByParts","initialProofState":"E : Type u_1\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace Real E\ninst✝⁵ : MeasurableSpace E\nμ : MeasureTheory.Measure E\ninst✝⁴ : BorelSpace E\ninst✝³ : FiniteDimensional Real E\ninst✝² : μ.IsAddHaarMeasure\n𝕜 : Type u_5\ninst✝¹ : NormedField 𝕜\ninst✝ : NormedAlgebra Real 𝕜\nf g : E → 𝕜\nv : E\nhf'g : MeasureTheory.Integrable (fun x => HMul.hMul ((fderiv Real f x) v) (g x)) μ\nhfg' : MeasureTheory.Integrable (fun x => HMul.hMul (f x) ((fderiv Real g x) v)) μ\nhfg : MeasureTheory.Integrable (fun x => HMul.hMul (f x) (g x)) μ\nhf : Differentiable Real f\nhg : Differentiable Real g\n⊢ Eq (MeasureTheory.integral μ fun x => HMul.hMul (f x) ((fderiv Real g x) v)) (Neg.neg (MeasureTheory.integral μ fun x => HMul.hMul ((fderiv Real f x) v) (g x)))","decl":"/-- **Integration by parts for Fréchet derivatives**\nVersion with two scalar functions: `∫ f * g' = - ∫ f' * g` when `f * g'` and `f' * g` and `f * g`\nare integrable, where `f'` and `g'` are the derivatives of `f` and `g` in a given direction `v`. -/\ntheorem integral_mul_fderiv_eq_neg_fderiv_mul_of_integrable\n    {f : E → 𝕜} {g : E → 𝕜} {v : E}\n    (hf'g : Integrable (fun x ↦ fderiv ℝ f x v * g x) μ)\n    (hfg' : Integrable (fun x ↦ f x * fderiv ℝ g x v) μ)\n    (hfg : Integrable (fun x ↦ f x * g x) μ)\n    (hf : Differentiable ℝ f) (hg : Differentiable ℝ g) :\n    ∫ x, f x * fderiv ℝ g x v ∂μ = - ∫ x, fderiv ℝ f x v * g x ∂μ :=\n  integral_bilinear_fderiv_right_eq_neg_left_of_integrable\n    (B := ContinuousLinearMap.mul ℝ 𝕜) hf'g hfg' hfg hf hg\n"}
