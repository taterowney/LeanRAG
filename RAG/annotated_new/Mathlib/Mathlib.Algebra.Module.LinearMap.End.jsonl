{"name":"LinearMap.one_eq_id","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq 1 LinearMap.id","decl":"theorem one_eq_id : (1 : Module.End R M) = id := rfl\n\n"}
{"name":"LinearMap.mul_eq_comp","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf g : Module.End R M\n⊢ Eq (HMul.hMul f g) (LinearMap.comp f g)","decl":"theorem mul_eq_comp (f g : Module.End R M) : f * g = f.comp g := rfl\n\n"}
{"name":"LinearMap.one_apply","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\n⊢ Eq (1 x) x","decl":"@[simp]\ntheorem one_apply (x : M) : (1 : Module.End R M) x = x := rfl\n\n"}
{"name":"LinearMap.mul_apply","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf g : Module.End R M\nx : M\n⊢ Eq ((HMul.hMul f g) x) (f (g x))","decl":"@[simp]\ntheorem mul_apply (f g : Module.End R M) (x : M) : (f * g) x = f (g x) := rfl\n\n"}
{"name":"LinearMap.coe_one","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (⇑1) id","decl":"theorem coe_one : ⇑(1 : Module.End R M) = _root_.id := rfl\n\n"}
{"name":"LinearMap.coe_mul","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf g : Module.End R M\n⊢ Eq (⇑(HMul.hMul f g)) (Function.comp ⇑f ⇑g)","decl":"theorem coe_mul (f g : Module.End R M) : ⇑(f * g) = f ∘ g := rfl\n\n"}
{"name":"Module.End.instNontrivial","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Nontrivial M\n⊢ Nontrivial (Module.End R M)","decl":"instance _root_.Module.End.instNontrivial [Nontrivial M] : Nontrivial (Module.End R M) := by\n  obtain ⟨m, ne⟩ := exists_ne (0 : M)\n  exact nontrivial_of_ne 1 0 fun p => ne (LinearMap.congr_fun p m)\n\n"}
{"name":"Module.End.natCast_apply","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nn : Nat\nm : M\n⊢ Eq (↑n m) (HSMul.hSMul n m)","decl":"/-- See also `Module.End.natCast_def`. -/\n@[simp]\ntheorem _root_.Module.End.natCast_apply (n : ℕ) (m : M) : (↑n : Module.End R M) m = n • m := rfl\n\n"}
{"name":"Module.End.ofNat_apply","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nn : Nat\ninst✝ : n.AtLeastTwo\nm : M\n⊢ Eq ((OfNat.ofNat n) m) (HSMul.hSMul (OfNat.ofNat n) m)","decl":"@[simp]\ntheorem _root_.Module.End.ofNat_apply (n : ℕ) [n.AtLeastTwo] (m : M) :\n    (ofNat(n) : Module.End R M) m = ofNat(n) • m := rfl\n\n"}
{"name":"Module.End.intCast_apply","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nN₁ : Type u_8\ninst✝² : Semiring R\ninst✝¹ : AddCommGroup N₁\ninst✝ : Module R N₁\nz : Int\nm : N₁\n⊢ Eq (↑z m) (HSMul.hSMul z m)","decl":"/-- See also `Module.End.intCast_def`. -/\n@[simp]\ntheorem _root_.Module.End.intCast_apply (z : ℤ) (m : N₁) : (z : Module.End R N₁) m = z • m :=\n  rfl\n\n"}
{"name":"Module.End.isScalarTower","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nS : Type u_3\nM : Type u_4\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Monoid S\ninst✝¹ : DistribMulAction S M\ninst✝ : SMulCommClass R S M\n⊢ IsScalarTower S (Module.End R M) (Module.End R M)","decl":"instance _root_.Module.End.isScalarTower :\n    IsScalarTower S (Module.End R M) (Module.End R M) :=\n  ⟨smul_comp⟩\n\n"}
{"name":"Module.End.smulCommClass","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nS : Type u_3\nM : Type u_4\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : Monoid S\ninst✝³ : DistribMulAction S M\ninst✝² : SMulCommClass R S M\ninst✝¹ : SMul S R\ninst✝ : IsScalarTower S R M\n⊢ SMulCommClass S (Module.End R M) (Module.End R M)","decl":"instance _root_.Module.End.smulCommClass [SMul S R] [IsScalarTower S R M] :\n    SMulCommClass S (Module.End R M) (Module.End R M) :=\n  ⟨fun s _ _ ↦ (comp_smul _ s _).symm⟩\n\n"}
{"name":"Module.End.smulCommClass'","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nS : Type u_3\nM : Type u_4\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : Monoid S\ninst✝³ : DistribMulAction S M\ninst✝² : SMulCommClass R S M\ninst✝¹ : SMul S R\ninst✝ : IsScalarTower S R M\n⊢ SMulCommClass (Module.End R M) S (Module.End R M)","decl":"instance _root_.Module.End.smulCommClass' [SMul S R] [IsScalarTower S R M] :\n    SMulCommClass (Module.End R M) S (Module.End R M) :=\n  SMulCommClass.symm _ _ _\n\n"}
{"name":"Module.End_isUnit_apply_inv_apply_of_isUnit","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : Module.End R M\nh : IsUnit f\nx : M\n⊢ Eq (f (h.unit.inv x)) x","decl":"theorem _root_.Module.End_isUnit_apply_inv_apply_of_isUnit\n    {f : Module.End R M} (h : IsUnit f) (x : M) :\n    f (h.unit.inv x) = x :=\n  show (f * h.unit.inv) x = x by simp\n\n"}
{"name":"Module.End_isUnit_inv_apply_apply_of_isUnit","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : Module.End R M\nh : IsUnit f\nx : M\n⊢ Eq (h.unit.inv (f x)) x","decl":"theorem _root_.Module.End_isUnit_inv_apply_apply_of_isUnit\n    {f : Module.End R M} (h : IsUnit f) (x : M) :\n    h.unit.inv (f x) = x :=\n  (by simp : (h.unit.inv * f) x = x)\n\n"}
{"name":"LinearMap.coe_pow","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : LinearMap (RingHom.id R) M M\nn : Nat\n⊢ Eq (⇑(HPow.hPow f n)) (Nat.iterate (⇑f) n)","decl":"theorem coe_pow (f : M →ₗ[R] M) (n : ℕ) : ⇑(f ^ n) = f^[n] := hom_coe_pow _ rfl (fun _ _ ↦ rfl) _ _\n\n"}
{"name":"LinearMap.pow_apply","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : LinearMap (RingHom.id R) M M\nn : Nat\nm : M\n⊢ Eq ((HPow.hPow f n) m) (Nat.iterate (⇑f) n m)","decl":"theorem pow_apply (f : M →ₗ[R] M) (n : ℕ) (m : M) : (f ^ n) m = f^[n] m := congr_fun (coe_pow f n) m\n\n"}
{"name":"LinearMap.pow_map_zero_of_le","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : Module.End R M\nm : M\nk l : Nat\nhk : LE.le k l\nhm : Eq ((HPow.hPow f k) m) 0\n⊢ Eq ((HPow.hPow f l) m) 0","decl":"theorem pow_map_zero_of_le {f : Module.End R M} {m : M} {k l : ℕ} (hk : k ≤ l)\n    (hm : (f ^ k) m = 0) : (f ^ l) m = 0 := by\n  rw [← Nat.sub_add_cancel hk, pow_add, mul_apply, hm, map_zero]\n\n"}
{"name":"LinearMap.commute_pow_left_of_commute","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_4\nM₂ : Type u_6\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Semiring R₂\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nf : LinearMap σ₁₂ M M₂\ng : Module.End R M\ng₂ : Module.End R₂ M₂\nh : Eq (LinearMap.comp g₂ f) (f.comp g)\nk : Nat\n⊢ Eq (LinearMap.comp (HPow.hPow g₂ k) f) (f.comp (HPow.hPow g k))","decl":"theorem commute_pow_left_of_commute\n    [Semiring R₂] [AddCommMonoid M₂] [Module R₂ M₂] {σ₁₂ : R →+* R₂}\n    {f : M →ₛₗ[σ₁₂] M₂} {g : Module.End R M} {g₂ : Module.End R₂ M₂}\n    (h : g₂.comp f = f.comp g) (k : ℕ) : (g₂ ^ k).comp f = f.comp (g ^ k) := by\n  induction k with\n  | zero => simp only [pow_zero, one_eq_id, id_comp, comp_id]\n  | succ k ih => rw [pow_succ', pow_succ', LinearMap.mul_eq_comp, LinearMap.comp_assoc, ih,\n    ← LinearMap.comp_assoc, h, LinearMap.comp_assoc, LinearMap.mul_eq_comp]\n\n"}
{"name":"LinearMap.id_pow","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nn : Nat\n⊢ Eq (HPow.hPow LinearMap.id n) LinearMap.id","decl":"@[simp]\ntheorem id_pow (n : ℕ) : (id : M →ₗ[R] M) ^ n = id :=\n  one_pow n\n\n"}
{"name":"LinearMap.iterate_succ","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf' : LinearMap (RingHom.id R) M M\nn : Nat\n⊢ Eq (HPow.hPow f' (HAdd.hAdd n 1)) ((HPow.hPow f' n).comp f')","decl":"theorem iterate_succ (n : ℕ) : f' ^ (n + 1) = comp (f' ^ n) f' := by rw [pow_succ, mul_eq_comp]\n\n"}
{"name":"LinearMap.iterate_surjective","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf' : LinearMap (RingHom.id R) M M\nh : Function.Surjective ⇑f'\nn : Nat\n⊢ Function.Surjective ⇑(HPow.hPow f' n)","decl":"theorem iterate_surjective (h : Surjective f') : ∀ n : ℕ, Surjective (f' ^ n)\n  | 0 => surjective_id\n  | n + 1 => by\n    rw [iterate_succ]\n    exact (iterate_surjective h n).comp h\n\n"}
{"name":"LinearMap.iterate_injective","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf' : LinearMap (RingHom.id R) M M\nh : Function.Injective ⇑f'\nn : Nat\n⊢ Function.Injective ⇑(HPow.hPow f' n)","decl":"theorem iterate_injective (h : Injective f') : ∀ n : ℕ, Injective (f' ^ n)\n  | 0 => injective_id\n  | n + 1 => by\n    rw [iterate_succ]\n    exact (iterate_injective h n).comp h\n\n"}
{"name":"LinearMap.iterate_bijective","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf' : LinearMap (RingHom.id R) M M\nh : Function.Bijective ⇑f'\nn : Nat\n⊢ Function.Bijective ⇑(HPow.hPow f' n)","decl":"theorem iterate_bijective (h : Bijective f') : ∀ n : ℕ, Bijective (f' ^ n)\n  | 0 => bijective_id\n  | n + 1 => by\n    rw [iterate_succ]\n    exact (iterate_bijective h n).comp h\n\n"}
{"name":"LinearMap.injective_of_iterate_injective","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf' : LinearMap (RingHom.id R) M M\nn : Nat\nhn : Ne n 0\nh : Function.Injective ⇑(HPow.hPow f' n)\n⊢ Function.Injective ⇑f'","decl":"theorem injective_of_iterate_injective {n : ℕ} (hn : n ≠ 0) (h : Injective (f' ^ n)) :\n    Injective f' := by\n  rw [← Nat.succ_pred_eq_of_pos (show 0 < n by omega), iterate_succ, coe_comp] at h\n  exact h.of_comp\n\n"}
{"name":"LinearMap.surjective_of_iterate_surjective","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf' : LinearMap (RingHom.id R) M M\nn : Nat\nhn : Ne n 0\nh : Function.Surjective ⇑(HPow.hPow f' n)\n⊢ Function.Surjective ⇑f'","decl":"theorem surjective_of_iterate_surjective {n : ℕ} (hn : n ≠ 0) (h : Surjective (f' ^ n)) :\n    Surjective f' := by\n  rw [← Nat.succ_pred_eq_of_pos (Nat.pos_iff_ne_zero.mpr hn), pow_succ', coe_mul] at h\n  exact Surjective.of_comp h\n\n"}
{"name":"LinearMap.smul_def","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : Module.End R M\na : M\n⊢ Eq (HSMul.hSMul f a) (f a)","decl":"@[simp]\nprotected theorem smul_def (f : Module.End R M) (a : M) : f • a = f a :=\n  rfl\n\n"}
{"name":"LinearMap.apply_faithfulSMul","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ FaithfulSMul (Module.End R M) M","decl":"/-- `LinearMap.applyModule` is faithful. -/\ninstance apply_faithfulSMul : FaithfulSMul (Module.End R M) M :=\n  ⟨LinearMap.ext⟩\n\n"}
{"name":"LinearMap.apply_smulCommClass","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nS : Type u_3\nM : Type u_4\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : SMul S R\ninst✝¹ : SMul S M\ninst✝ : IsScalarTower S R M\n⊢ SMulCommClass S (Module.End R M) M","decl":"instance apply_smulCommClass [SMul S R] [SMul S M] [IsScalarTower S R M] :\n    SMulCommClass S (Module.End R M) M where\n  smul_comm r e m := (e.map_smul_of_tower r m).symm\n\n"}
{"name":"LinearMap.apply_smulCommClass'","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nS : Type u_3\nM : Type u_4\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : SMul S R\ninst✝¹ : SMul S M\ninst✝ : IsScalarTower S R M\n⊢ SMulCommClass (Module.End R M) S M","decl":"instance apply_smulCommClass' [SMul S R] [SMul S M] [IsScalarTower S R M] :\n    SMulCommClass (Module.End R M) S M :=\n  SMulCommClass.symm _ _ _\n\n"}
{"name":"LinearMap.apply_isScalarTower","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nS : Type u_3\nM : Type u_4\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Monoid S\ninst✝¹ : DistribMulAction S M\ninst✝ : SMulCommClass R S M\n⊢ IsScalarTower S (Module.End R M) M","decl":"instance apply_isScalarTower [Monoid S] [DistribMulAction S M] [SMulCommClass R S M] :\n    IsScalarTower S (Module.End R M) M :=\n  ⟨fun _ _ _ ↦ rfl⟩\n\n"}
{"name":"DistribMulAction.toLinearMap_apply","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nS : Type u_3\nM : Type u_4\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Monoid S\ninst✝¹ : DistribMulAction S M\ninst✝ : SMulCommClass S R M\ns : S\na✝ : M\n⊢ Eq ((DistribMulAction.toLinearMap R M s) a✝) (HSMul.hSMul s a✝)","decl":"/-- Each element of the monoid defines a linear map.\n\nThis is a stronger version of `DistribMulAction.toAddMonoidHom`. -/\n@[simps]\ndef toLinearMap (s : S) : M →ₗ[R] M where\n  toFun := HSMul.hSMul s\n  map_add' := smul_add s\n  map_smul' _ _ := smul_comm _ _ _\n\n"}
{"name":"DistribMulAction.toModuleEnd_apply","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nS : Type u_3\nM : Type u_4\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Monoid S\ninst✝¹ : DistribMulAction S M\ninst✝ : SMulCommClass S R M\ns : S\n⊢ Eq ((DistribMulAction.toModuleEnd R M) s) (DistribMulAction.toLinearMap R M s)","decl":"/-- Each element of the monoid defines a module endomorphism.\n\nThis is a stronger version of `DistribMulAction.toAddMonoidEnd`. -/\n@[simps]\ndef toModuleEnd : S →* Module.End R M where\n  toFun := toLinearMap R M\n  map_one' := LinearMap.ext <| one_smul _\n  map_mul' _ _ := LinearMap.ext <| mul_smul _ _\n\n"}
{"name":"Module.toModuleEnd_apply","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nS : Type u_3\nM : Type u_4\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Semiring S\ninst✝¹ : Module S M\ninst✝ : SMulCommClass S R M\ns : S\n⊢ Eq ((Module.toModuleEnd R M) s) (DistribMulAction.toLinearMap R M s)","decl":"/-- Each element of the semiring defines a module endomorphism.\n\nThis is a stronger version of `DistribMulAction.toModuleEnd`. -/\n@[simps]\ndef toModuleEnd : S →+* Module.End R M :=\n  { DistribMulAction.toModuleEnd R M with\n    toFun := DistribMulAction.toLinearMap R M\n    map_zero' := LinearMap.ext <| zero_smul S\n    map_add' := fun _ _ ↦ LinearMap.ext <| add_smul _ _ }\n\n"}
{"name":"Module.moduleEndSelf_symm_apply","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Module.End R R\n⊢ Eq ((Module.moduleEndSelf R).symm f) (MulOpposite.op (f 1))","decl":"/-- The canonical (semi)ring isomorphism from `Rᵐᵒᵖ` to `Module.End R R` induced by the right\nmultiplication. -/\n@[simps]\ndef moduleEndSelf : Rᵐᵒᵖ ≃+* Module.End R R :=\n  { Module.toModuleEnd R R with\n    toFun := DistribMulAction.toLinearMap R R\n    invFun := fun f ↦ MulOpposite.op (f 1)\n    left_inv := mul_one\n    right_inv := fun _ ↦ LinearMap.ext_ring <| one_mul _ }\n\n"}
{"name":"Module.moduleEndSelf_apply","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\ninst✝ : Semiring R\ns : MulOpposite R\n⊢ Eq ((Module.moduleEndSelf R) s) (DistribMulAction.toLinearMap R R s)","decl":"/-- The canonical (semi)ring isomorphism from `Rᵐᵒᵖ` to `Module.End R R` induced by the right\nmultiplication. -/\n@[simps]\ndef moduleEndSelf : Rᵐᵒᵖ ≃+* Module.End R R :=\n  { Module.toModuleEnd R R with\n    toFun := DistribMulAction.toLinearMap R R\n    invFun := fun f ↦ MulOpposite.op (f 1)\n    left_inv := mul_one\n    right_inv := fun _ ↦ LinearMap.ext_ring <| one_mul _ }\n\n"}
{"name":"Module.moduleEndSelfOp_apply","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\ninst✝ : Semiring R\ns : R\n⊢ Eq ((Module.moduleEndSelfOp R) s) (DistribMulAction.toLinearMap (MulOpposite R) R s)","decl":"/-- The canonical (semi)ring isomorphism from `R` to `Module.End Rᵐᵒᵖ R` induced by the left\nmultiplication. -/\n@[simps]\ndef moduleEndSelfOp : R ≃+* Module.End Rᵐᵒᵖ R :=\n  { Module.toModuleEnd _ _ with\n    toFun := DistribMulAction.toLinearMap _ _\n    invFun := fun f ↦ f 1\n    left_inv := mul_one\n    right_inv := fun _ ↦ LinearMap.ext_ring_op <| mul_one _ }\n\n"}
{"name":"Module.moduleEndSelfOp_symm_apply","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Module.End (MulOpposite R) R\n⊢ Eq ((Module.moduleEndSelfOp R).symm f) (f 1)","decl":"/-- The canonical (semi)ring isomorphism from `R` to `Module.End Rᵐᵒᵖ R` induced by the left\nmultiplication. -/\n@[simps]\ndef moduleEndSelfOp : R ≃+* Module.End Rᵐᵒᵖ R :=\n  { Module.toModuleEnd _ _ with\n    toFun := DistribMulAction.toLinearMap _ _\n    invFun := fun f ↦ f 1\n    left_inv := mul_one\n    right_inv := fun _ ↦ LinearMap.ext_ring_op <| mul_one _ }\n\n"}
{"name":"Module.End.natCast_def","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nN₁ : Type u_8\ninst✝² : Semiring R\nn : Nat\ninst✝¹ : AddCommMonoid N₁\ninst✝ : Module R N₁\n⊢ Eq (↑n) ((Module.toModuleEnd R N₁) n)","decl":"theorem End.natCast_def (n : ℕ) [AddCommMonoid N₁] [Module R N₁] :\n    (↑n : Module.End R N₁) = Module.toModuleEnd R N₁ n :=\n  rfl\n\n"}
{"name":"Module.End.intCast_def","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nN₁ : Type u_8\ninst✝² : Semiring R\nz : Int\ninst✝¹ : AddCommGroup N₁\ninst✝ : Module R N₁\n⊢ Eq (↑z) ((Module.toModuleEnd R N₁) z)","decl":"theorem End.intCast_def (z : ℤ) [AddCommGroup N₁] [Module R N₁] :\n    (z : Module.End R N₁) = Module.toModuleEnd R N₁ z :=\n  rfl\n\n"}
{"name":"LinearMap.coe_smulRight","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nS : Type u_3\nM : Type u_4\nM₁ : Type u_5\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M₁\ninst✝⁵ : Module R M\ninst✝⁴ : Module R M₁\ninst✝³ : Semiring S\ninst✝² : Module R S\ninst✝¹ : Module S M\ninst✝ : IsScalarTower R S M\nf : LinearMap (RingHom.id R) M₁ S\nx : M\n⊢ Eq ⇑(f.smulRight x) fun c => HSMul.hSMul (f c) x","decl":"@[simp]\ntheorem coe_smulRight (f : M₁ →ₗ[R] S) (x : M) : (smulRight f x : M₁ → M) = fun c => f c • x :=\n  rfl\n\n"}
{"name":"LinearMap.smulRight_apply","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nS : Type u_3\nM : Type u_4\nM₁ : Type u_5\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M₁\ninst✝⁵ : Module R M\ninst✝⁴ : Module R M₁\ninst✝³ : Semiring S\ninst✝² : Module R S\ninst✝¹ : Module S M\ninst✝ : IsScalarTower R S M\nf : LinearMap (RingHom.id R) M₁ S\nx : M\nc : M₁\n⊢ Eq ((f.smulRight x) c) (HSMul.hSMul (f c) x)","decl":"theorem smulRight_apply (f : M₁ →ₗ[R] S) (x : M) (c : M₁) : smulRight f x c = f c • x :=\n  rfl\n\n"}
{"name":"LinearMap.smulRight_zero","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nS : Type u_3\nM : Type u_4\nM₁ : Type u_5\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M₁\ninst✝⁵ : Module R M\ninst✝⁴ : Module R M₁\ninst✝³ : Semiring S\ninst✝² : Module R S\ninst✝¹ : Module S M\ninst✝ : IsScalarTower R S M\nf : LinearMap (RingHom.id R) M₁ S\n⊢ Eq (f.smulRight 0) 0","decl":"@[simp]\nlemma smulRight_zero (f : M₁ →ₗ[R] S) : f.smulRight (0 : M) = 0 := by ext; simp\n\n"}
{"name":"LinearMap.zero_smulRight","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nS : Type u_3\nM : Type u_4\nM₁ : Type u_5\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M₁\ninst✝⁵ : Module R M\ninst✝⁴ : Module R M₁\ninst✝³ : Semiring S\ninst✝² : Module R S\ninst✝¹ : Module S M\ninst✝ : IsScalarTower R S M\nx : M\n⊢ Eq (LinearMap.smulRight 0 x) 0","decl":"@[simp]\nlemma zero_smulRight (x : M) : (0 : M₁ →ₗ[R] S).smulRight x = 0 := by ext; simp\n\n"}
{"name":"LinearMap.smulRight_apply_eq_zero_iff","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nS : Type u_3\nM : Type u_4\nM₁ : Type u_5\ninst✝⁹ : Semiring R\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : AddCommMonoid M₁\ninst✝⁶ : Module R M\ninst✝⁵ : Module R M₁\ninst✝⁴ : Semiring S\ninst✝³ : Module R S\ninst✝² : Module S M\ninst✝¹ : IsScalarTower R S M\nf : LinearMap (RingHom.id R) M₁ S\nx : M\ninst✝ : NoZeroSMulDivisors S M\n⊢ Iff (Eq (f.smulRight x) 0) (Or (Eq f 0) (Eq x 0))","decl":"@[simp]\nlemma smulRight_apply_eq_zero_iff {f : M₁ →ₗ[R] S} {x : M} [NoZeroSMulDivisors S M] :\n    f.smulRight x = 0 ↔ f = 0 ∨ x = 0 := by\n  rcases eq_or_ne x 0 with rfl | hx\n  · simp\n  refine ⟨fun h ↦ Or.inl ?_, fun h ↦ by simp [h.resolve_right hx]⟩\n  ext v\n  replace h : f v • x = 0 := by simpa only [LinearMap.zero_apply] using LinearMap.congr_fun h v\n  rw [smul_eq_zero] at h\n  tauto\n\n"}
{"name":"LinearMap.applyₗ'_apply_apply","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nS : Type u_3\nM : Type u_4\nM₂ : Type u_6\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring S\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M\ninst✝² : Module R M₂\ninst✝¹ : Module S M₂\ninst✝ : SMulCommClass R S M₂\nv : M\nf : LinearMap (RingHom.id R) M M₂\n⊢ Eq (((LinearMap.applyₗ' S) v) f) (f v)","decl":"/-- Applying a linear map at `v : M`, seen as `S`-linear map from `M →ₗ[R] M₂` to `M₂`.\n\n See `LinearMap.applyₗ` for a version where `S = R`. -/\n@[simps]\ndef applyₗ' : M →+ (M →ₗ[R] M₂) →ₗ[S] M₂ where\n  toFun v :=\n    { toFun := fun f => f v\n      map_add' := fun f g => f.add_apply g v\n      map_smul' := fun x f => f.smul_apply x v }\n  map_zero' := LinearMap.ext fun f => f.map_zero\n  map_add' _ _ := LinearMap.ext fun f => f.map_add _ _\n\n"}
{"name":"LinearMap.compRight_apply","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nM : Type u_4\nM₂ : Type u_6\nM₃ : Type u_7\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nf : LinearMap (RingHom.id R) M₂ M₃\ng : LinearMap (RingHom.id R) M M₂\n⊢ Eq (f.compRight g) (f.comp g)","decl":"@[simp]\ntheorem compRight_apply (f : M₂ →ₗ[R] M₃) (g : M →ₗ[R] M₂) : compRight f g = f.comp g :=\n  rfl\n\n"}
{"name":"LinearMap.applyₗ_apply_apply","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nM : Type u_4\nM₂ : Type u_6\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nv : M\nf : LinearMap (RingHom.id R) M M₂\n⊢ Eq ((LinearMap.applyₗ v) f) (f v)","decl":"/-- Applying a linear map at `v : M`, seen as a linear map from `M →ₗ[R] M₂` to `M₂`.\nSee also `LinearMap.applyₗ'` for a version that works with two different semirings.\n\nThis is the `LinearMap` version of `toAddMonoidHom.eval`. -/\n@[simps]\ndef applyₗ : M →ₗ[R] (M →ₗ[R] M₂) →ₗ[R] M₂ :=\n  { applyₗ' R with\n    toFun := fun v => { applyₗ' R v with toFun := fun f => f v }\n    map_smul' := fun _ _ => LinearMap.ext fun f => map_smul f _ _ }\n\n"}
{"name":"LinearMap.smulRightₗ_apply","module":"Mathlib.Algebra.Module.LinearMap.End","initialProofState":"R : Type u_1\nM : Type u_4\nM₂ : Type u_6\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nf : LinearMap (RingHom.id R) M₂ R\nx : M\nc : M₂\n⊢ Eq (((LinearMap.smulRightₗ f) x) c) (HSMul.hSMul (f c) x)","decl":"@[simp]\ntheorem smulRightₗ_apply (f : M₂ →ₗ[R] R) (x : M) (c : M₂) :\n    (smulRightₗ : (M₂ →ₗ[R] R) →ₗ[R] M →ₗ[R] M₂ →ₗ[R] M) f x c = f c • x :=\n  rfl\n\n"}
