{"name":"CategoryTheory.Functor.LeftExtension.coconeAt_Œπ_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.LeftExtension F\nY : D\ng : CategoryTheory.CostructuredArrow L Y\n‚ä¢ Eq ((E.coconeAt Y).Œπ.app g) (CategoryTheory.CategoryStruct.comp (E.hom.app g.left) (E.right.map g.hom))","decl":"/-- The cocone for `CostructuredArrow.proj L Y ‚ãô F` attached to `E : LeftExtension L F`.\nThe point of this cocone is `E.right.obj Y` -/\n@[simps]\ndef coconeAt (Y : D) : Cocone (CostructuredArrow.proj L Y ‚ãô F) where\n  pt := E.right.obj Y\n  Œπ :=\n    { app := fun g => E.hom.app g.left ‚â´ E.right.map g.hom\n      naturality := fun g‚ÇÅ g‚ÇÇ œÜ => by\n        dsimp\n        rw [‚Üê CostructuredArrow.w œÜ]\n        simp only [assoc, NatTrans.naturality_assoc, Functor.comp_map,\n          Functor.map_comp, comp_id] }\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.coconeAt_pt","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.LeftExtension F\nY : D\n‚ä¢ Eq (E.coconeAt Y).pt (E.right.obj Y)","decl":"/-- The cocone for `CostructuredArrow.proj L Y ‚ãô F` attached to `E : LeftExtension L F`.\nThe point of this cocone is `E.right.obj Y` -/\n@[simps]\ndef coconeAt (Y : D) : Cocone (CostructuredArrow.proj L Y ‚ãô F) where\n  pt := E.right.obj Y\n  Œπ :=\n    { app := fun g => E.hom.app g.left ‚â´ E.right.map g.hom\n      naturality := fun g‚ÇÅ g‚ÇÇ œÜ => by\n        dsimp\n        rw [‚Üê CostructuredArrow.w œÜ]\n        simp only [assoc, NatTrans.naturality_assoc, Functor.comp_map,\n          Functor.map_comp, comp_id] }\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.coconeAtFunctor_map_hom","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nY : D\nE E' : L.LeftExtension F\nœÜ : Quiver.Hom E E'\n‚ä¢ Eq ((CategoryTheory.Functor.LeftExtension.coconeAtFunctor L F Y).map œÜ).hom (œÜ.right.app Y)","decl":"variable (L F) in\n/-- The cocones for `CostructuredArrow.proj L Y ‚ãô F`, as a functor from `LeftExtension L F`. -/\n@[simps]\ndef coconeAtFunctor (Y : D) :\n    LeftExtension L F ‚•§ Cocone (CostructuredArrow.proj L Y ‚ãô F) where\n  obj E := E.coconeAt Y\n  map {E E'} œÜ := CoconeMorphism.mk (œÜ.right.app Y) (fun G => by\n    dsimp\n    rw [‚Üê StructuredArrow.w œÜ]\n    simp)\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.coconeAtFunctor_obj","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nY : D\nE : L.LeftExtension F\n‚ä¢ Eq ((CategoryTheory.Functor.LeftExtension.coconeAtFunctor L F Y).obj E) (E.coconeAt Y)","decl":"variable (L F) in\n/-- The cocones for `CostructuredArrow.proj L Y ‚ãô F`, as a functor from `LeftExtension L F`. -/\n@[simps]\ndef coconeAtFunctor (Y : D) :\n    LeftExtension L F ‚•§ Cocone (CostructuredArrow.proj L Y ‚ãô F) where\n  obj E := E.coconeAt Y\n  map {E E'} œÜ := CoconeMorphism.mk (œÜ.right.app Y) (fun G => by\n    dsimp\n    rw [‚Üê StructuredArrow.w œÜ]\n    simp)\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtensionAt.hasPointwiseLeftKanExtensionAt","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.LeftExtension F\nY : D\nh : E.IsPointwiseLeftKanExtensionAt Y\n‚ä¢ L.HasPointwiseLeftKanExtensionAt F Y","decl":"variable {E} in\nlemma IsPointwiseLeftKanExtensionAt.hasPointwiseLeftKanExtensionAt\n    {Y : D} (h : E.IsPointwiseLeftKanExtensionAt Y) :\n    HasPointwiseLeftKanExtensionAt L F Y := ‚ü®_, h‚ü©\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtensionAt.isIso_hom_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.LeftExtension F\nX : C\nh : E.IsPointwiseLeftKanExtensionAt (L.obj X)\ninst‚úù¬π : L.Full\ninst‚úù : L.Faithful\n‚ä¢ CategoryTheory.IsIso (E.hom.app X)","decl":"lemma IsPointwiseLeftKanExtensionAt.isIso_hom_app\n    {X : C} (h : E.IsPointwiseLeftKanExtensionAt (L.obj X)) [L.Full] [L.Faithful] :\n    IsIso (E.hom.app X) := by\n  simpa using h.isIso_Œπ_app_of_isTerminal _ CostructuredArrow.mkIdTerminal\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtensionAt.Œπ_isoColimit_inv","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.LeftExtension F\nY : D\nh : E.IsPointwiseLeftKanExtensionAt Y\ninst‚úù : CategoryTheory.Limits.HasColimit ((CategoryTheory.CostructuredArrow.proj L Y).comp F)\ng : CategoryTheory.CostructuredArrow L Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ ((CategoryTheory.CostructuredArrow.proj L Y).comp F) g) h.isoColimit.inv) (CategoryTheory.CategoryStruct.comp (E.hom.app g.left) (E.right.map g.hom))","decl":"@[reassoc (attr := simp)]\nlemma Œπ_isoColimit_inv (g : CostructuredArrow L Y) :\n    colimit.Œπ _ g ‚â´ h.isoColimit.inv = E.hom.app g.left ‚â´ E.right.map g.hom :=\n  IsColimit.comp_coconePointUniqueUpToIso_inv _ _ _\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtensionAt.Œπ_isoColimit_inv_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.LeftExtension F\nY : D\nh‚úù : E.IsPointwiseLeftKanExtensionAt Y\ninst‚úù : CategoryTheory.Limits.HasColimit ((CategoryTheory.CostructuredArrow.proj L Y).comp F)\ng : CategoryTheory.CostructuredArrow L Y\nZ : H\nh : Quiver.Hom (E.right.obj Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ ((CategoryTheory.CostructuredArrow.proj L Y).comp F) g) (CategoryTheory.CategoryStruct.comp h‚úù.isoColimit.inv h)) (CategoryTheory.CategoryStruct.comp (E.hom.app g.left) (CategoryTheory.CategoryStruct.comp (E.right.map g.hom) h))","decl":"@[reassoc (attr := simp)]\nlemma Œπ_isoColimit_inv (g : CostructuredArrow L Y) :\n    colimit.Œπ _ g ‚â´ h.isoColimit.inv = E.hom.app g.left ‚â´ E.right.map g.hom :=\n  IsColimit.comp_coconePointUniqueUpToIso_inv _ _ _\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtensionAt.Œπ_isoColimit_hom_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.LeftExtension F\nY : D\nh‚úù : E.IsPointwiseLeftKanExtensionAt Y\ninst‚úù : CategoryTheory.Limits.HasColimit ((CategoryTheory.CostructuredArrow.proj L Y).comp F)\ng : CategoryTheory.CostructuredArrow L Y\nZ : H\nh : Quiver.Hom (CategoryTheory.Limits.colimit ((CategoryTheory.CostructuredArrow.proj L Y).comp F)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (E.hom.app g.left) (CategoryTheory.CategoryStruct.comp (E.right.map g.hom) (CategoryTheory.CategoryStruct.comp h‚úù.isoColimit.hom h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ ((CategoryTheory.CostructuredArrow.proj L Y).comp F) g) h)","decl":"@[reassoc (attr := simp)]\nlemma Œπ_isoColimit_hom (g : CostructuredArrow L Y) :\n    E.hom.app g.left ‚â´ E.right.map g.hom ‚â´ h.isoColimit.hom =\n      colimit.Œπ (CostructuredArrow.proj L Y ‚ãô F) g := by\n  simpa using h.comp_coconePointUniqueUpToIso_hom (colimit.isColimit _) g\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtensionAt.Œπ_isoColimit_hom","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.LeftExtension F\nY : D\nh : E.IsPointwiseLeftKanExtensionAt Y\ninst‚úù : CategoryTheory.Limits.HasColimit ((CategoryTheory.CostructuredArrow.proj L Y).comp F)\ng : CategoryTheory.CostructuredArrow L Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (E.hom.app g.left) (CategoryTheory.CategoryStruct.comp (E.right.map g.hom) h.isoColimit.hom)) (CategoryTheory.Limits.colimit.Œπ ((CategoryTheory.CostructuredArrow.proj L Y).comp F) g)","decl":"@[reassoc (attr := simp)]\nlemma Œπ_isoColimit_hom (g : CostructuredArrow L Y) :\n    E.hom.app g.left ‚â´ E.right.map g.hom ‚â´ h.isoColimit.hom =\n      colimit.Œπ (CostructuredArrow.proj L Y ‚ãô F) g := by\n  simpa using h.comp_coconePointUniqueUpToIso_hom (colimit.isColimit _) g\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtension.hasPointwiseLeftKanExtension","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.LeftExtension F\nh : E.IsPointwiseLeftKanExtension\n‚ä¢ L.HasPointwiseLeftKanExtension F","decl":"lemma IsPointwiseLeftKanExtension.hasPointwiseLeftKanExtension :\n    HasPointwiseLeftKanExtension L F :=\n  fun Y => (h Y).hasPointwiseLeftKanExtensionAt\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtension.hom_ext","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_2} D\ninst‚úù : CategoryTheory.Category.{u_5, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.LeftExtension F\nh : E.IsPointwiseLeftKanExtension\nG : L.LeftExtension F\nf‚ÇÅ f‚ÇÇ : Quiver.Hom E G\n‚ä¢ Eq f‚ÇÅ f‚ÇÇ","decl":"lemma IsPointwiseLeftKanExtension.hom_ext\n    {G : LeftExtension L F} {f‚ÇÅ f‚ÇÇ : E ‚ü∂ G} : f‚ÇÅ = f‚ÇÇ := by\n  ext Y\n  apply (h Y).hom_ext\n  intro X\n  have eq‚ÇÅ := congr_app (StructuredArrow.w f‚ÇÅ) X.left\n  have eq‚ÇÇ := congr_app (StructuredArrow.w f‚ÇÇ) X.left\n  dsimp at eq‚ÇÅ eq‚ÇÇ ‚ä¢\n  simp only [assoc, NatTrans.naturality]\n  rw [reassoc_of% eq‚ÇÅ, reassoc_of% eq‚ÇÇ]\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtension.isLeftKanExtension","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_2} D\ninst‚úù : CategoryTheory.Category.{u_5, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.LeftExtension F\nh : E.IsPointwiseLeftKanExtension\n‚ä¢ E.right.IsLeftKanExtension E.hom","decl":"lemma IsPointwiseLeftKanExtension.isLeftKanExtension :\n    E.right.IsLeftKanExtension E.hom where\n  nonempty_isUniversal := ‚ü®h.isUniversal‚ü©\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtension.hasLeftKanExtension","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_2} D\ninst‚úù : CategoryTheory.Category.{u_5, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.LeftExtension F\nh : E.IsPointwiseLeftKanExtension\n‚ä¢ L.HasLeftKanExtension F","decl":"lemma IsPointwiseLeftKanExtension.hasLeftKanExtension :\n    HasLeftKanExtension L F :=\n  have := h.isLeftKanExtension\n  HasLeftKanExtension.mk E.right E.hom\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtension.isIso_hom","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.LeftExtension F\nh : E.IsPointwiseLeftKanExtension\ninst‚úù¬π : L.Full\ninst‚úù : L.Faithful\n‚ä¢ CategoryTheory.IsIso E.hom","decl":"lemma IsPointwiseLeftKanExtension.isIso_hom [L.Full] [L.Faithful] :\n    IsIso (E.hom) :=\n  have := fun X => (h (L.obj X)).isIso_hom_app\n  NatIso.isIso_of_isIso_app ..\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.coneAt_pt","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.RightExtension F\nY : D\n‚ä¢ Eq (E.coneAt Y).pt (E.left.obj Y)","decl":"/-- The cone for `StructuredArrow.proj Y L ‚ãô F` attached to `E : RightExtension L F`.\nThe point of this cone is `E.left.obj Y` -/\n@[simps]\ndef coneAt (Y : D) : Cone (StructuredArrow.proj Y L ‚ãô F) where\n  pt := E.left.obj Y\n  œÄ :=\n    { app := fun g ‚Ü¶ E.left.map g.hom ‚â´ E.hom.app g.right\n      naturality := fun g‚ÇÅ g‚ÇÇ œÜ ‚Ü¶ by\n        dsimp\n        rw [assoc, id_comp, ‚Üê StructuredArrow.w œÜ, Functor.map_comp, assoc]\n        congr 1\n        apply E.hom.naturality }\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.coneAt_œÄ_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.RightExtension F\nY : D\ng : CategoryTheory.StructuredArrow Y L\n‚ä¢ Eq ((E.coneAt Y).œÄ.app g) (CategoryTheory.CategoryStruct.comp (E.left.map g.hom) (E.hom.app g.right))","decl":"/-- The cone for `StructuredArrow.proj Y L ‚ãô F` attached to `E : RightExtension L F`.\nThe point of this cone is `E.left.obj Y` -/\n@[simps]\ndef coneAt (Y : D) : Cone (StructuredArrow.proj Y L ‚ãô F) where\n  pt := E.left.obj Y\n  œÄ :=\n    { app := fun g ‚Ü¶ E.left.map g.hom ‚â´ E.hom.app g.right\n      naturality := fun g‚ÇÅ g‚ÇÇ œÜ ‚Ü¶ by\n        dsimp\n        rw [assoc, id_comp, ‚Üê StructuredArrow.w œÜ, Functor.map_comp, assoc]\n        congr 1\n        apply E.hom.naturality }\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.coneAtFunctor_obj","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nY : D\nE : L.RightExtension F\n‚ä¢ Eq ((CategoryTheory.Functor.RightExtension.coneAtFunctor L F Y).obj E) (E.coneAt Y)","decl":"variable (L F) in\n/-- The cones for `StructuredArrow.proj Y L ‚ãô F`, as a functor from `RightExtension L F`. -/\n@[simps]\ndef coneAtFunctor (Y : D) :\n    RightExtension L F ‚•§ Cone (StructuredArrow.proj Y L ‚ãô F) where\n  obj E := E.coneAt Y\n  map {E E'} œÜ := ConeMorphism.mk (œÜ.left.app Y) (fun G ‚Ü¶ by\n    dsimp\n    rw [‚Üê CostructuredArrow.w œÜ]\n    simp)\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.coneAtFunctor_map_hom","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nY : D\nE E' : L.RightExtension F\nœÜ : Quiver.Hom E E'\n‚ä¢ Eq ((CategoryTheory.Functor.RightExtension.coneAtFunctor L F Y).map œÜ).hom (œÜ.left.app Y)","decl":"variable (L F) in\n/-- The cones for `StructuredArrow.proj Y L ‚ãô F`, as a functor from `RightExtension L F`. -/\n@[simps]\ndef coneAtFunctor (Y : D) :\n    RightExtension L F ‚•§ Cone (StructuredArrow.proj Y L ‚ãô F) where\n  obj E := E.coneAt Y\n  map {E E'} œÜ := ConeMorphism.mk (œÜ.left.app Y) (fun G ‚Ü¶ by\n    dsimp\n    rw [‚Üê CostructuredArrow.w œÜ]\n    simp)\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.IsPointwiseRightKanExtensionAt.hasPointwiseRightKanExtensionAt","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.RightExtension F\nY : D\nh : E.IsPointwiseRightKanExtensionAt Y\n‚ä¢ L.HasPointwiseRightKanExtensionAt F Y","decl":"variable {E} in\nlemma IsPointwiseRightKanExtensionAt.hasPointwiseRightKanExtensionAt\n    {Y : D} (h : E.IsPointwiseRightKanExtensionAt Y) :\n    HasPointwiseRightKanExtensionAt L F Y := ‚ü®_, h‚ü©\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.IsPointwiseRightKanExtensionAt.isIso_hom_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.RightExtension F\nX : C\nh : E.IsPointwiseRightKanExtensionAt (L.obj X)\ninst‚úù¬π : L.Full\ninst‚úù : L.Faithful\n‚ä¢ CategoryTheory.IsIso (E.hom.app X)","decl":"lemma IsPointwiseRightKanExtensionAt.isIso_hom_app\n    {X : C} (h : E.IsPointwiseRightKanExtensionAt (L.obj X)) [L.Full] [L.Faithful] :\n    IsIso (E.hom.app X) := by\n  simpa using h.isIso_œÄ_app_of_isInitial _ StructuredArrow.mkIdInitial\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.IsPointwiseRightKanExtensionAt.isoLimit_hom_œÄ","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.RightExtension F\nY : D\nh : E.IsPointwiseRightKanExtensionAt Y\ninst‚úù : CategoryTheory.Limits.HasLimit ((CategoryTheory.StructuredArrow.proj Y L).comp F)\ng : CategoryTheory.StructuredArrow Y L\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp h.isoLimit.hom (CategoryTheory.Limits.limit.œÄ ((CategoryTheory.StructuredArrow.proj Y L).comp F) g)) (CategoryTheory.CategoryStruct.comp (E.left.map g.hom) (E.hom.app g.right))","decl":"@[reassoc (attr := simp)]\nlemma isoLimit_hom_œÄ (g : StructuredArrow Y L) :\n    h.isoLimit.hom ‚â´ limit.œÄ _ g = E.left.map g.hom ‚â´ E.hom.app g.right :=\n  IsLimit.conePointUniqueUpToIso_hom_comp _ _ _\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.IsPointwiseRightKanExtensionAt.isoLimit_hom_œÄ_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.RightExtension F\nY : D\nh‚úù : E.IsPointwiseRightKanExtensionAt Y\ninst‚úù : CategoryTheory.Limits.HasLimit ((CategoryTheory.StructuredArrow.proj Y L).comp F)\ng : CategoryTheory.StructuredArrow Y L\nZ : H\nh : Quiver.Hom (F.obj ((CategoryTheory.StructuredArrow.proj Y L).obj g)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp h‚úù.isoLimit.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.œÄ ((CategoryTheory.StructuredArrow.proj Y L).comp F) g) h)) (CategoryTheory.CategoryStruct.comp (E.left.map g.hom) (CategoryTheory.CategoryStruct.comp (E.hom.app g.right) h))","decl":"@[reassoc (attr := simp)]\nlemma isoLimit_hom_œÄ (g : StructuredArrow Y L) :\n    h.isoLimit.hom ‚â´ limit.œÄ _ g = E.left.map g.hom ‚â´ E.hom.app g.right :=\n  IsLimit.conePointUniqueUpToIso_hom_comp _ _ _\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.IsPointwiseRightKanExtensionAt.isoLimit_inv_œÄ_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.RightExtension F\nY : D\nh‚úù : E.IsPointwiseRightKanExtensionAt Y\ninst‚úù : CategoryTheory.Limits.HasLimit ((CategoryTheory.StructuredArrow.proj Y L).comp F)\ng : CategoryTheory.StructuredArrow Y L\nZ : H\nh : Quiver.Hom (((CategoryTheory.Functor.fromPUnit F).obj E.right).obj g.right) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp h‚úù.isoLimit.inv (CategoryTheory.CategoryStruct.comp (E.left.map g.hom) (CategoryTheory.CategoryStruct.comp (E.hom.app g.right) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.œÄ ((CategoryTheory.StructuredArrow.proj Y L).comp F) g) h)","decl":"@[reassoc (attr := simp)]\nlemma isoLimit_inv_œÄ (g : StructuredArrow Y L) :\n    h.isoLimit.inv ‚â´ E.left.map g.hom ‚â´ E.hom.app g.right =\n      limit.œÄ (StructuredArrow.proj Y L ‚ãô F) g := by\n  simpa using h.conePointUniqueUpToIso_inv_comp (limit.isLimit _) g\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.IsPointwiseRightKanExtensionAt.isoLimit_inv_œÄ","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.RightExtension F\nY : D\nh : E.IsPointwiseRightKanExtensionAt Y\ninst‚úù : CategoryTheory.Limits.HasLimit ((CategoryTheory.StructuredArrow.proj Y L).comp F)\ng : CategoryTheory.StructuredArrow Y L\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp h.isoLimit.inv (CategoryTheory.CategoryStruct.comp (E.left.map g.hom) (E.hom.app g.right))) (CategoryTheory.Limits.limit.œÄ ((CategoryTheory.StructuredArrow.proj Y L).comp F) g)","decl":"@[reassoc (attr := simp)]\nlemma isoLimit_inv_œÄ (g : StructuredArrow Y L) :\n    h.isoLimit.inv ‚â´ E.left.map g.hom ‚â´ E.hom.app g.right =\n      limit.œÄ (StructuredArrow.proj Y L ‚ãô F) g := by\n  simpa using h.conePointUniqueUpToIso_inv_comp (limit.isLimit _) g\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.IsPointwiseRightKanExtension.hasPointwiseRightKanExtension","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.RightExtension F\nh : E.IsPointwiseRightKanExtension\n‚ä¢ L.HasPointwiseRightKanExtension F","decl":"lemma IsPointwiseRightKanExtension.hasPointwiseRightKanExtension :\n    HasPointwiseRightKanExtension L F :=\n  fun Y => (h Y).hasPointwiseRightKanExtensionAt\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.IsPointwiseRightKanExtension.hom_ext","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_2} D\ninst‚úù : CategoryTheory.Category.{u_5, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.RightExtension F\nh : E.IsPointwiseRightKanExtension\nG : L.RightExtension F\nf‚ÇÅ f‚ÇÇ : Quiver.Hom G E\n‚ä¢ Eq f‚ÇÅ f‚ÇÇ","decl":"lemma IsPointwiseRightKanExtension.hom_ext\n    {G : RightExtension L F} {f‚ÇÅ f‚ÇÇ : G ‚ü∂ E} : f‚ÇÅ = f‚ÇÇ := by\n  ext Y\n  apply (h Y).hom_ext\n  intro X\n  have eq‚ÇÅ := congr_app (CostructuredArrow.w f‚ÇÅ) X.right\n  have eq‚ÇÇ := congr_app (CostructuredArrow.w f‚ÇÇ) X.right\n  dsimp at eq‚ÇÅ eq‚ÇÇ ‚ä¢\n  simp only [assoc, ‚Üê NatTrans.naturality_assoc, eq‚ÇÅ, eq‚ÇÇ]\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.IsPointwiseRightKanExtension.isRightKanExtension","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_2} D\ninst‚úù : CategoryTheory.Category.{u_5, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.RightExtension F\nh : E.IsPointwiseRightKanExtension\n‚ä¢ E.left.IsRightKanExtension E.hom","decl":"lemma IsPointwiseRightKanExtension.isRightKanExtension :\n    E.left.IsRightKanExtension E.hom where\n  nonempty_isUniversal := ‚ü®h.isUniversal‚ü©\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.IsPointwiseRightKanExtension.hasRightKanExtension","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_2} D\ninst‚úù : CategoryTheory.Category.{u_5, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.RightExtension F\nh : E.IsPointwiseRightKanExtension\n‚ä¢ L.HasRightKanExtension F","decl":"lemma IsPointwiseRightKanExtension.hasRightKanExtension :\n    HasRightKanExtension L F :=\n  have := h.isRightKanExtension\n  HasRightKanExtension.mk E.left E.hom\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.IsPointwiseRightKanExtension.isIso_hom","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.RightExtension F\nh : E.IsPointwiseRightKanExtension\ninst‚úù¬π : L.Full\ninst‚úù : L.Faithful\n‚ä¢ CategoryTheory.IsIso E.hom","decl":"lemma IsPointwiseRightKanExtension.isIso_hom [L.Full] [L.Faithful] :\n    IsIso (E.hom) :=\n  have := fun X => (h (L.obj X)).isIso_hom_app\n  NatIso.isIso_of_isIso_app ..\n\n"}
{"name":"CategoryTheory.Functor.pointwiseLeftKanExtension_obj","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst‚úù : L.HasPointwiseLeftKanExtension F\nY : D\n‚ä¢ Eq ((L.pointwiseLeftKanExtension F).obj Y) (CategoryTheory.Limits.colimit ((CategoryTheory.CostructuredArrow.proj L Y).comp F))","decl":"/-- The constructed pointwise left Kan extension when `HasPointwiseLeftKanExtension L F` holds. -/\n@[simps]\nnoncomputable def pointwiseLeftKanExtension : D ‚•§ H where\n  obj Y := colimit (CostructuredArrow.proj L Y ‚ãô F)\n  map {Y‚ÇÅ Y‚ÇÇ} f :=\n    colimit.desc (CostructuredArrow.proj L Y‚ÇÅ ‚ãô F)\n      (Cocone.mk (colimit (CostructuredArrow.proj L Y‚ÇÇ ‚ãô F))\n        { app := fun g => colimit.Œπ (CostructuredArrow.proj L Y‚ÇÇ ‚ãô F)\n            ((CostructuredArrow.map f).obj g)\n          naturality := fun g‚ÇÅ g‚ÇÇ œÜ => by\n            simpa using colimit.w (CostructuredArrow.proj L Y‚ÇÇ ‚ãô F)\n              ((CostructuredArrow.map f).map œÜ) })\n  map_id Y := colimit.hom_ext (fun j => by\n    dsimp\n    simp only [colimit.Œπ_desc, comp_id]\n    congr\n    apply CostructuredArrow.map_id)\n  map_comp {Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ} f f' := colimit.hom_ext (fun j => by\n    dsimp\n    simp only [colimit.Œπ_desc, colimit.Œπ_desc_assoc, comp_obj, CostructuredArrow.proj_obj]\n    congr 1\n    apply CostructuredArrow.map_comp)\n\n"}
{"name":"CategoryTheory.Functor.pointwiseLeftKanExtension_map","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst‚úù : L.HasPointwiseLeftKanExtension F\nY‚ÇÅ Y‚ÇÇ : D\nf : Quiver.Hom Y‚ÇÅ Y‚ÇÇ\n‚ä¢ Eq ((L.pointwiseLeftKanExtension F).map f) (CategoryTheory.Limits.colimit.desc ((CategoryTheory.CostructuredArrow.proj L Y‚ÇÅ).comp F) { pt := CategoryTheory.Limits.colimit ((CategoryTheory.CostructuredArrow.proj L Y‚ÇÇ).comp F), Œπ := { app := fun g => CategoryTheory.Limits.colimit.Œπ ((CategoryTheory.CostructuredArrow.proj L Y‚ÇÇ).comp F) ((CategoryTheory.CostructuredArrow.map f).obj g), naturality := ‚ãØ } })","decl":"/-- The constructed pointwise left Kan extension when `HasPointwiseLeftKanExtension L F` holds. -/\n@[simps]\nnoncomputable def pointwiseLeftKanExtension : D ‚•§ H where\n  obj Y := colimit (CostructuredArrow.proj L Y ‚ãô F)\n  map {Y‚ÇÅ Y‚ÇÇ} f :=\n    colimit.desc (CostructuredArrow.proj L Y‚ÇÅ ‚ãô F)\n      (Cocone.mk (colimit (CostructuredArrow.proj L Y‚ÇÇ ‚ãô F))\n        { app := fun g => colimit.Œπ (CostructuredArrow.proj L Y‚ÇÇ ‚ãô F)\n            ((CostructuredArrow.map f).obj g)\n          naturality := fun g‚ÇÅ g‚ÇÇ œÜ => by\n            simpa using colimit.w (CostructuredArrow.proj L Y‚ÇÇ ‚ãô F)\n              ((CostructuredArrow.map f).map œÜ) })\n  map_id Y := colimit.hom_ext (fun j => by\n    dsimp\n    simp only [colimit.Œπ_desc, comp_id]\n    congr\n    apply CostructuredArrow.map_id)\n  map_comp {Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ} f f' := colimit.hom_ext (fun j => by\n    dsimp\n    simp only [colimit.Œπ_desc, colimit.Œπ_desc_assoc, comp_obj, CostructuredArrow.proj_obj]\n    congr 1\n    apply CostructuredArrow.map_comp)\n\n"}
{"name":"CategoryTheory.Functor.pointwiseLeftKanExtensionUnit_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst‚úù : L.HasPointwiseLeftKanExtension F\nX : C\n‚ä¢ Eq ((L.pointwiseLeftKanExtensionUnit F).app X) (CategoryTheory.Limits.colimit.Œπ ((CategoryTheory.CostructuredArrow.proj L (L.obj X)).comp F) (CategoryTheory.CostructuredArrow.mk (CategoryTheory.CategoryStruct.id (L.obj X))))","decl":"/-- The unit of the constructed pointwise left Kan extension when\n`HasPointwiseLeftKanExtension L F` holds. -/\n@[simps]\nnoncomputable def pointwiseLeftKanExtensionUnit : F ‚ü∂ L ‚ãô pointwiseLeftKanExtension L F where\n  app X := colimit.Œπ (CostructuredArrow.proj L (L.obj X) ‚ãô F)\n    (CostructuredArrow.mk (ùüô (L.obj X)))\n  naturality {X‚ÇÅ X‚ÇÇ} f := by\n    simp only [comp_obj, pointwiseLeftKanExtension_obj, comp_map,\n      pointwiseLeftKanExtension_map, colimit.Œπ_desc, CostructuredArrow.map_mk]\n    rw [id_comp]\n    let œÜ : CostructuredArrow.mk (L.map f) ‚ü∂ CostructuredArrow.mk (ùüô (L.obj X‚ÇÇ)) :=\n      CostructuredArrow.homMk f\n    exact colimit.w (CostructuredArrow.proj L (L.obj X‚ÇÇ) ‚ãô F) œÜ\n\n"}
{"name":"CategoryTheory.Functor.instIsLeftKanExtensionPointwiseLeftKanExtensionPointwiseLeftKanExtensionUnit","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_2} D\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst‚úù : L.HasPointwiseLeftKanExtension F\n‚ä¢ (L.pointwiseLeftKanExtension F).IsLeftKanExtension (L.pointwiseLeftKanExtensionUnit F)","decl":"instance : (pointwiseLeftKanExtension L F).IsLeftKanExtension\n    (pointwiseLeftKanExtensionUnit L F) where\n  nonempty_isUniversal := ‚ü®pointwiseLeftKanExtensionIsUniversal L F‚ü©\n\n"}
{"name":"CategoryTheory.Functor.instHasLeftKanExtension","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_2} D\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst‚úù : L.HasPointwiseLeftKanExtension F\n‚ä¢ L.HasLeftKanExtension F","decl":"instance : HasLeftKanExtension L F :=\n  HasLeftKanExtension.mk _ (pointwiseLeftKanExtensionUnit L F)\n\n"}
{"name":"CategoryTheory.Functor.costructuredArrowMapCocone_Œπ_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nG : CategoryTheory.Functor D H\nŒ± : Quiver.Hom F (L.comp G)\nY : D\nf : CategoryTheory.CostructuredArrow L Y\n‚ä¢ Eq ((L.costructuredArrowMapCocone F G Œ± Y).Œπ.app f) (CategoryTheory.CategoryStruct.comp (Œ±.app f.left) (G.map f.hom))","decl":"/-- An auxiliary cocone used in the lemma `pointwiseLeftKanExtension_desc_app` -/\n@[simps]\ndef costructuredArrowMapCocone (G : D ‚•§ H) (Œ± : F ‚ü∂ L ‚ãô G) (Y : D) :\n    Cocone (CostructuredArrow.proj L Y ‚ãô F) where\n  pt := G.obj Y\n  Œπ := {\n    app := fun f ‚Ü¶ Œ±.app f.left ‚â´ G.map f.hom\n    naturality := by simp [‚Üê G.map_comp] }\n\n"}
{"name":"CategoryTheory.Functor.costructuredArrowMapCocone_pt","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nG : CategoryTheory.Functor D H\nŒ± : Quiver.Hom F (L.comp G)\nY : D\n‚ä¢ Eq (L.costructuredArrowMapCocone F G Œ± Y).pt (G.obj Y)","decl":"/-- An auxiliary cocone used in the lemma `pointwiseLeftKanExtension_desc_app` -/\n@[simps]\ndef costructuredArrowMapCocone (G : D ‚•§ H) (Œ± : F ‚ü∂ L ‚ãô G) (Y : D) :\n    Cocone (CostructuredArrow.proj L Y ‚ãô F) where\n  pt := G.obj Y\n  Œπ := {\n    app := fun f ‚Ü¶ Œ±.app f.left ‚â´ G.map f.hom\n    naturality := by simp [‚Üê G.map_comp] }\n\n"}
{"name":"CategoryTheory.Functor.pointwiseLeftKanExtension_desc_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_2} D\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst‚úù : L.HasPointwiseLeftKanExtension F\nG : CategoryTheory.Functor D H\nŒ± : Quiver.Hom F (L.comp G)\nY : D\n‚ä¢ Eq (((L.pointwiseLeftKanExtension F).descOfIsLeftKanExtension (L.pointwiseLeftKanExtensionUnit F) G Œ±).app Y) (CategoryTheory.Limits.colimit.desc ((CategoryTheory.CostructuredArrow.proj L Y).comp F) (L.costructuredArrowMapCocone F G Œ± Y))","decl":"@[simp]\nlemma pointwiseLeftKanExtension_desc_app (G : D ‚•§ H) (Œ± :  F ‚ü∂ L ‚ãô G) (Y : D) :\n    ((pointwiseLeftKanExtension L F).descOfIsLeftKanExtension (pointwiseLeftKanExtensionUnit L F)\n      G Œ± |>.app Y) = colimit.desc _ (costructuredArrowMapCocone L F G Œ± Y) := by\n  let Œ≤ : L.pointwiseLeftKanExtension F ‚ü∂ G :=\n    { app := fun Y ‚Ü¶ colimit.desc _ (costructuredArrowMapCocone L F G Œ± Y) }\n  have h : (pointwiseLeftKanExtension L F).descOfIsLeftKanExtension\n      (pointwiseLeftKanExtensionUnit L F) G Œ± = Œ≤ := by\n    apply hom_ext_of_isLeftKanExtension (Œ± := pointwiseLeftKanExtensionUnit L F)\n    aesop\n  exact NatTrans.congr_app h Y\n\n"}
{"name":"CategoryTheory.Functor.pointwiseRightKanExtension_obj","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst‚úù : L.HasPointwiseRightKanExtension F\nY : D\n‚ä¢ Eq ((L.pointwiseRightKanExtension F).obj Y) (CategoryTheory.Limits.limit ((CategoryTheory.StructuredArrow.proj Y L).comp F))","decl":"/-- The constructed pointwise right Kan extension\nwhen `HasPointwiseRightKanExtension L F` holds. -/\n@[simps]\nnoncomputable def pointwiseRightKanExtension : D ‚•§ H where\n  obj Y := limit (StructuredArrow.proj Y L ‚ãô F)\n  map {Y‚ÇÅ Y‚ÇÇ} f := limit.lift (StructuredArrow.proj Y‚ÇÇ L ‚ãô F)\n      (Cone.mk (limit (StructuredArrow.proj Y‚ÇÅ L ‚ãô F))\n        { app := fun g ‚Ü¶ limit.œÄ (StructuredArrow.proj Y‚ÇÅ L ‚ãô F)\n            ((StructuredArrow.map f).obj g)\n          naturality := fun g‚ÇÅ g‚ÇÇ œÜ ‚Ü¶ by\n            simpa using (limit.w (StructuredArrow.proj Y‚ÇÅ L ‚ãô F)\n              ((StructuredArrow.map f).map œÜ)).symm })\n  map_id Y := limit.hom_ext (fun j => by\n    dsimp\n    simp only [limit.lift_œÄ, id_comp]\n    congr\n    apply StructuredArrow.map_id)\n  map_comp {Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ} f f' := limit.hom_ext (fun j => by\n    dsimp\n    simp only [limit.lift_œÄ, assoc]\n    congr 1\n    apply StructuredArrow.map_comp)\n\n"}
{"name":"CategoryTheory.Functor.pointwiseRightKanExtension_map","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst‚úù : L.HasPointwiseRightKanExtension F\nY‚ÇÅ Y‚ÇÇ : D\nf : Quiver.Hom Y‚ÇÅ Y‚ÇÇ\n‚ä¢ Eq ((L.pointwiseRightKanExtension F).map f) (CategoryTheory.Limits.limit.lift ((CategoryTheory.StructuredArrow.proj Y‚ÇÇ L).comp F) { pt := CategoryTheory.Limits.limit ((CategoryTheory.StructuredArrow.proj Y‚ÇÅ L).comp F), œÄ := { app := fun g => CategoryTheory.Limits.limit.œÄ ((CategoryTheory.StructuredArrow.proj Y‚ÇÅ L).comp F) ((CategoryTheory.StructuredArrow.map f).obj g), naturality := ‚ãØ } })","decl":"/-- The constructed pointwise right Kan extension\nwhen `HasPointwiseRightKanExtension L F` holds. -/\n@[simps]\nnoncomputable def pointwiseRightKanExtension : D ‚•§ H where\n  obj Y := limit (StructuredArrow.proj Y L ‚ãô F)\n  map {Y‚ÇÅ Y‚ÇÇ} f := limit.lift (StructuredArrow.proj Y‚ÇÇ L ‚ãô F)\n      (Cone.mk (limit (StructuredArrow.proj Y‚ÇÅ L ‚ãô F))\n        { app := fun g ‚Ü¶ limit.œÄ (StructuredArrow.proj Y‚ÇÅ L ‚ãô F)\n            ((StructuredArrow.map f).obj g)\n          naturality := fun g‚ÇÅ g‚ÇÇ œÜ ‚Ü¶ by\n            simpa using (limit.w (StructuredArrow.proj Y‚ÇÅ L ‚ãô F)\n              ((StructuredArrow.map f).map œÜ)).symm })\n  map_id Y := limit.hom_ext (fun j => by\n    dsimp\n    simp only [limit.lift_œÄ, id_comp]\n    congr\n    apply StructuredArrow.map_id)\n  map_comp {Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ} f f' := limit.hom_ext (fun j => by\n    dsimp\n    simp only [limit.lift_œÄ, assoc]\n    congr 1\n    apply StructuredArrow.map_comp)\n\n"}
{"name":"CategoryTheory.Functor.pointwiseRightKanExtensionCounit_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst‚úù : L.HasPointwiseRightKanExtension F\nX : C\n‚ä¢ Eq ((L.pointwiseRightKanExtensionCounit F).app X) (CategoryTheory.Limits.limit.œÄ ((CategoryTheory.StructuredArrow.proj (L.obj X) L).comp F) (CategoryTheory.StructuredArrow.mk (CategoryTheory.CategoryStruct.id (L.obj X))))","decl":"/-- The counit of the constructed pointwise right Kan extension when\n`HasPointwiseRightKanExtension L F` holds. -/\n@[simps]\nnoncomputable def pointwiseRightKanExtensionCounit :\n    L ‚ãô pointwiseRightKanExtension L F ‚ü∂ F where\n  app X := limit.œÄ (StructuredArrow.proj (L.obj X) L ‚ãô F)\n    (StructuredArrow.mk (ùüô (L.obj X)))\n  naturality {X‚ÇÅ X‚ÇÇ} f := by\n    simp only [comp_obj, pointwiseRightKanExtension_obj, comp_map,\n      pointwiseRightKanExtension_map, limit.lift_œÄ, StructuredArrow.map_mk]\n    rw [comp_id]\n    let œÜ : StructuredArrow.mk (ùüô (L.obj X‚ÇÅ)) ‚ü∂ StructuredArrow.mk (L.map f) :=\n      StructuredArrow.homMk f\n    exact (limit.w (StructuredArrow.proj (L.obj X‚ÇÅ) L ‚ãô F) œÜ).symm\n\n"}
{"name":"CategoryTheory.Functor.instIsRightKanExtensionPointwiseRightKanExtensionPointwiseRightKanExtensionCounit","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_2} D\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst‚úù : L.HasPointwiseRightKanExtension F\n‚ä¢ (L.pointwiseRightKanExtension F).IsRightKanExtension (L.pointwiseRightKanExtensionCounit F)","decl":"instance : (pointwiseRightKanExtension L F).IsRightKanExtension\n    (pointwiseRightKanExtensionCounit L F) where\n  nonempty_isUniversal := ‚ü®pointwiseRightKanExtensionIsUniversal L F‚ü©\n\n"}
{"name":"CategoryTheory.Functor.instHasRightKanExtension","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_2} D\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst‚úù : L.HasPointwiseRightKanExtension F\n‚ä¢ L.HasRightKanExtension F","decl":"instance : HasRightKanExtension L F :=\n  HasRightKanExtension.mk _ (pointwiseRightKanExtensionCounit L F)\n\n"}
{"name":"CategoryTheory.Functor.structuredArrowMapCone_œÄ_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nG : CategoryTheory.Functor D H\nŒ± : Quiver.Hom (L.comp G) F\nY : D\nf : CategoryTheory.StructuredArrow Y L\n‚ä¢ Eq ((L.structuredArrowMapCone F G Œ± Y).œÄ.app f) (CategoryTheory.CategoryStruct.comp (G.map f.hom) (Œ±.app f.right))","decl":"/-- An auxiliary cocone used in the lemma `pointwiseRightKanExtension_lift_app` -/\n@[simps]\ndef structuredArrowMapCone (G : D ‚•§ H) (Œ± : L ‚ãô G ‚ü∂ F) (Y : D) :\n    Cone (StructuredArrow.proj Y L ‚ãô F) where\n  pt := G.obj Y\n  œÄ := {\n    app := fun f ‚Ü¶ G.map f.hom ‚â´ Œ±.app f.right\n    naturality := by simp [‚Üê Œ±.naturality, ‚Üê G.map_comp_assoc] }\n\n"}
{"name":"CategoryTheory.Functor.structuredArrowMapCone_pt","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nG : CategoryTheory.Functor D H\nŒ± : Quiver.Hom (L.comp G) F\nY : D\n‚ä¢ Eq (L.structuredArrowMapCone F G Œ± Y).pt (G.obj Y)","decl":"/-- An auxiliary cocone used in the lemma `pointwiseRightKanExtension_lift_app` -/\n@[simps]\ndef structuredArrowMapCone (G : D ‚•§ H) (Œ± : L ‚ãô G ‚ü∂ F) (Y : D) :\n    Cone (StructuredArrow.proj Y L ‚ãô F) where\n  pt := G.obj Y\n  œÄ := {\n    app := fun f ‚Ü¶ G.map f.hom ‚â´ Œ±.app f.right\n    naturality := by simp [‚Üê Œ±.naturality, ‚Üê G.map_comp_assoc] }\n\n"}
{"name":"CategoryTheory.Functor.pointwiseRightKanExtension_lift_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_2} D\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst‚úù : L.HasPointwiseRightKanExtension F\nG : CategoryTheory.Functor D H\nŒ± : Quiver.Hom (L.comp G) F\nY : D\n‚ä¢ Eq (((L.pointwiseRightKanExtension F).liftOfIsRightKanExtension (L.pointwiseRightKanExtensionCounit F) G Œ±).app Y) (CategoryTheory.Limits.limit.lift ((CategoryTheory.StructuredArrow.proj Y L).comp F) (L.structuredArrowMapCone F G Œ± Y))","decl":"@[simp]\nlemma pointwiseRightKanExtension_lift_app (G : D ‚•§ H) (Œ± : L ‚ãô G ‚ü∂ F) (Y : D) :\n    ((pointwiseRightKanExtension L F).liftOfIsRightKanExtension\n      (pointwiseRightKanExtensionCounit L F) G Œ± |>.app Y) =\n        limit.lift _ (structuredArrowMapCone L F G Œ± Y) := by\n  let Œ≤ : G ‚ü∂ L.pointwiseRightKanExtension F :=\n    { app := fun Y ‚Ü¶ limit.lift _ (structuredArrowMapCone L F G Œ± Y) }\n  have h : (pointwiseRightKanExtension L F).liftOfIsRightKanExtension\n      (pointwiseRightKanExtensionCounit L F) G Œ± = Œ≤ := by\n    apply hom_ext_of_isRightKanExtension (Œ± := pointwiseRightKanExtensionCounit L F)\n    aesop\n  exact NatTrans.congr_app h Y\n\n"}
