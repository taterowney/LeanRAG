{"name":"CategoryTheory.Functor.LeftExtension.coconeAt_ι_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} D\ninst✝ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.LeftExtension F\nY : D\ng : CategoryTheory.CostructuredArrow L Y\n⊢ Eq ((E.coconeAt Y).ι.app g) (CategoryTheory.CategoryStruct.comp (E.hom.app g.left) (E.right.map g.hom))","decl":"/-- The cocone for `CostructuredArrow.proj L Y ⋙ F` attached to `E : LeftExtension L F`.\nThe point of this cocone is `E.right.obj Y` -/\n@[simps]\ndef coconeAt (Y : D) : Cocone (CostructuredArrow.proj L Y ⋙ F) where\n  pt := E.right.obj Y\n  ι :=\n    { app := fun g => E.hom.app g.left ≫ E.right.map g.hom\n      naturality := fun g₁ g₂ φ => by\n        dsimp\n        rw [← CostructuredArrow.w φ]\n        simp only [assoc, NatTrans.naturality_assoc, Functor.comp_map,\n          Functor.map_comp, comp_id] }\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.coconeAt_pt","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} D\ninst✝ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.LeftExtension F\nY : D\n⊢ Eq (E.coconeAt Y).pt (E.right.obj Y)","decl":"/-- The cocone for `CostructuredArrow.proj L Y ⋙ F` attached to `E : LeftExtension L F`.\nThe point of this cocone is `E.right.obj Y` -/\n@[simps]\ndef coconeAt (Y : D) : Cocone (CostructuredArrow.proj L Y ⋙ F) where\n  pt := E.right.obj Y\n  ι :=\n    { app := fun g => E.hom.app g.left ≫ E.right.map g.hom\n      naturality := fun g₁ g₂ φ => by\n        dsimp\n        rw [← CostructuredArrow.w φ]\n        simp only [assoc, NatTrans.naturality_assoc, Functor.comp_map,\n          Functor.map_comp, comp_id] }\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.coconeAtFunctor_map_hom","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} D\ninst✝ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nY : D\nE E' : L.LeftExtension F\nφ : Quiver.Hom E E'\n⊢ Eq ((CategoryTheory.Functor.LeftExtension.coconeAtFunctor L F Y).map φ).hom (φ.right.app Y)","decl":"variable (L F) in\n/-- The cocones for `CostructuredArrow.proj L Y ⋙ F`, as a functor from `LeftExtension L F`. -/\n@[simps]\ndef coconeAtFunctor (Y : D) :\n    LeftExtension L F ⥤ Cocone (CostructuredArrow.proj L Y ⋙ F) where\n  obj E := E.coconeAt Y\n  map {E E'} φ := CoconeMorphism.mk (φ.right.app Y) (fun G => by\n    dsimp\n    rw [← StructuredArrow.w φ]\n    simp)\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.coconeAtFunctor_obj","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} D\ninst✝ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nY : D\nE : L.LeftExtension F\n⊢ Eq ((CategoryTheory.Functor.LeftExtension.coconeAtFunctor L F Y).obj E) (E.coconeAt Y)","decl":"variable (L F) in\n/-- The cocones for `CostructuredArrow.proj L Y ⋙ F`, as a functor from `LeftExtension L F`. -/\n@[simps]\ndef coconeAtFunctor (Y : D) :\n    LeftExtension L F ⥤ Cocone (CostructuredArrow.proj L Y ⋙ F) where\n  obj E := E.coconeAt Y\n  map {E E'} φ := CoconeMorphism.mk (φ.right.app Y) (fun G => by\n    dsimp\n    rw [← StructuredArrow.w φ]\n    simp)\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtensionAt.hasPointwiseLeftKanExtensionAt","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} D\ninst✝ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.LeftExtension F\nY : D\nh : E.IsPointwiseLeftKanExtensionAt Y\n⊢ L.HasPointwiseLeftKanExtensionAt F Y","decl":"variable {E} in\nlemma IsPointwiseLeftKanExtensionAt.hasPointwiseLeftKanExtensionAt\n    {Y : D} (h : E.IsPointwiseLeftKanExtensionAt Y) :\n    HasPointwiseLeftKanExtensionAt L F Y := ⟨_, h⟩\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtensionAt.isIso_hom_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} D\ninst✝² : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.LeftExtension F\nX : C\nh : E.IsPointwiseLeftKanExtensionAt (L.obj X)\ninst✝¹ : L.Full\ninst✝ : L.Faithful\n⊢ CategoryTheory.IsIso (E.hom.app X)","decl":"lemma IsPointwiseLeftKanExtensionAt.isIso_hom_app\n    {X : C} (h : E.IsPointwiseLeftKanExtensionAt (L.obj X)) [L.Full] [L.Faithful] :\n    IsIso (E.hom.app X) := by\n  simpa using h.isIso_ι_app_of_isTerminal _ CostructuredArrow.mkIdTerminal\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtensionAt.ι_isoColimit_inv","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.LeftExtension F\nY : D\nh : E.IsPointwiseLeftKanExtensionAt Y\ninst✝ : CategoryTheory.Limits.HasColimit ((CategoryTheory.CostructuredArrow.proj L Y).comp F)\ng : CategoryTheory.CostructuredArrow L Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι ((CategoryTheory.CostructuredArrow.proj L Y).comp F) g) h.isoColimit.inv) (CategoryTheory.CategoryStruct.comp (E.hom.app g.left) (E.right.map g.hom))","decl":"@[reassoc (attr := simp)]\nlemma ι_isoColimit_inv (g : CostructuredArrow L Y) :\n    colimit.ι _ g ≫ h.isoColimit.inv = E.hom.app g.left ≫ E.right.map g.hom :=\n  IsColimit.comp_coconePointUniqueUpToIso_inv _ _ _\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtensionAt.ι_isoColimit_inv_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.LeftExtension F\nY : D\nh✝ : E.IsPointwiseLeftKanExtensionAt Y\ninst✝ : CategoryTheory.Limits.HasColimit ((CategoryTheory.CostructuredArrow.proj L Y).comp F)\ng : CategoryTheory.CostructuredArrow L Y\nZ : H\nh : Quiver.Hom (E.right.obj Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι ((CategoryTheory.CostructuredArrow.proj L Y).comp F) g) (CategoryTheory.CategoryStruct.comp h✝.isoColimit.inv h)) (CategoryTheory.CategoryStruct.comp (E.hom.app g.left) (CategoryTheory.CategoryStruct.comp (E.right.map g.hom) h))","decl":"@[reassoc (attr := simp)]\nlemma ι_isoColimit_inv (g : CostructuredArrow L Y) :\n    colimit.ι _ g ≫ h.isoColimit.inv = E.hom.app g.left ≫ E.right.map g.hom :=\n  IsColimit.comp_coconePointUniqueUpToIso_inv _ _ _\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtensionAt.ι_isoColimit_hom_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.LeftExtension F\nY : D\nh✝ : E.IsPointwiseLeftKanExtensionAt Y\ninst✝ : CategoryTheory.Limits.HasColimit ((CategoryTheory.CostructuredArrow.proj L Y).comp F)\ng : CategoryTheory.CostructuredArrow L Y\nZ : H\nh : Quiver.Hom (CategoryTheory.Limits.colimit ((CategoryTheory.CostructuredArrow.proj L Y).comp F)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (E.hom.app g.left) (CategoryTheory.CategoryStruct.comp (E.right.map g.hom) (CategoryTheory.CategoryStruct.comp h✝.isoColimit.hom h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι ((CategoryTheory.CostructuredArrow.proj L Y).comp F) g) h)","decl":"@[reassoc (attr := simp)]\nlemma ι_isoColimit_hom (g : CostructuredArrow L Y) :\n    E.hom.app g.left ≫ E.right.map g.hom ≫ h.isoColimit.hom =\n      colimit.ι (CostructuredArrow.proj L Y ⋙ F) g := by\n  simpa using h.comp_coconePointUniqueUpToIso_hom (colimit.isColimit _) g\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtensionAt.ι_isoColimit_hom","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.LeftExtension F\nY : D\nh : E.IsPointwiseLeftKanExtensionAt Y\ninst✝ : CategoryTheory.Limits.HasColimit ((CategoryTheory.CostructuredArrow.proj L Y).comp F)\ng : CategoryTheory.CostructuredArrow L Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (E.hom.app g.left) (CategoryTheory.CategoryStruct.comp (E.right.map g.hom) h.isoColimit.hom)) (CategoryTheory.Limits.colimit.ι ((CategoryTheory.CostructuredArrow.proj L Y).comp F) g)","decl":"@[reassoc (attr := simp)]\nlemma ι_isoColimit_hom (g : CostructuredArrow L Y) :\n    E.hom.app g.left ≫ E.right.map g.hom ≫ h.isoColimit.hom =\n      colimit.ι (CostructuredArrow.proj L Y ⋙ F) g := by\n  simpa using h.comp_coconePointUniqueUpToIso_hom (colimit.isColimit _) g\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtension.hasPointwiseLeftKanExtension","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} D\ninst✝ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.LeftExtension F\nh : E.IsPointwiseLeftKanExtension\n⊢ L.HasPointwiseLeftKanExtension F","decl":"lemma IsPointwiseLeftKanExtension.hasPointwiseLeftKanExtension :\n    HasPointwiseLeftKanExtension L F :=\n  fun Y => (h Y).hasPointwiseLeftKanExtensionAt\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtension.hom_ext","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_6, u_2} D\ninst✝ : CategoryTheory.Category.{u_5, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.LeftExtension F\nh : E.IsPointwiseLeftKanExtension\nG : L.LeftExtension F\nf₁ f₂ : Quiver.Hom E G\n⊢ Eq f₁ f₂","decl":"lemma IsPointwiseLeftKanExtension.hom_ext\n    {G : LeftExtension L F} {f₁ f₂ : E ⟶ G} : f₁ = f₂ := by\n  ext Y\n  apply (h Y).hom_ext\n  intro X\n  have eq₁ := congr_app (StructuredArrow.w f₁) X.left\n  have eq₂ := congr_app (StructuredArrow.w f₂) X.left\n  dsimp at eq₁ eq₂ ⊢\n  simp only [assoc, NatTrans.naturality]\n  rw [reassoc_of% eq₁, reassoc_of% eq₂]\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtension.isLeftKanExtension","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_6, u_2} D\ninst✝ : CategoryTheory.Category.{u_5, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.LeftExtension F\nh : E.IsPointwiseLeftKanExtension\n⊢ E.right.IsLeftKanExtension E.hom","decl":"lemma IsPointwiseLeftKanExtension.isLeftKanExtension :\n    E.right.IsLeftKanExtension E.hom where\n  nonempty_isUniversal := ⟨h.isUniversal⟩\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtension.hasLeftKanExtension","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_6, u_2} D\ninst✝ : CategoryTheory.Category.{u_5, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.LeftExtension F\nh : E.IsPointwiseLeftKanExtension\n⊢ L.HasLeftKanExtension F","decl":"lemma IsPointwiseLeftKanExtension.hasLeftKanExtension :\n    HasLeftKanExtension L F :=\n  have := h.isLeftKanExtension\n  HasLeftKanExtension.mk E.right E.hom\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtension.isIso_hom","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} D\ninst✝² : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.LeftExtension F\nh : E.IsPointwiseLeftKanExtension\ninst✝¹ : L.Full\ninst✝ : L.Faithful\n⊢ CategoryTheory.IsIso E.hom","decl":"lemma IsPointwiseLeftKanExtension.isIso_hom [L.Full] [L.Faithful] :\n    IsIso (E.hom) :=\n  have := fun X => (h (L.obj X)).isIso_hom_app\n  NatIso.isIso_of_isIso_app ..\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.coneAt_pt","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} D\ninst✝ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.RightExtension F\nY : D\n⊢ Eq (E.coneAt Y).pt (E.left.obj Y)","decl":"/-- The cone for `StructuredArrow.proj Y L ⋙ F` attached to `E : RightExtension L F`.\nThe point of this cone is `E.left.obj Y` -/\n@[simps]\ndef coneAt (Y : D) : Cone (StructuredArrow.proj Y L ⋙ F) where\n  pt := E.left.obj Y\n  π :=\n    { app := fun g ↦ E.left.map g.hom ≫ E.hom.app g.right\n      naturality := fun g₁ g₂ φ ↦ by\n        dsimp\n        rw [assoc, id_comp, ← StructuredArrow.w φ, Functor.map_comp, assoc]\n        congr 1\n        apply E.hom.naturality }\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.coneAt_π_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} D\ninst✝ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.RightExtension F\nY : D\ng : CategoryTheory.StructuredArrow Y L\n⊢ Eq ((E.coneAt Y).π.app g) (CategoryTheory.CategoryStruct.comp (E.left.map g.hom) (E.hom.app g.right))","decl":"/-- The cone for `StructuredArrow.proj Y L ⋙ F` attached to `E : RightExtension L F`.\nThe point of this cone is `E.left.obj Y` -/\n@[simps]\ndef coneAt (Y : D) : Cone (StructuredArrow.proj Y L ⋙ F) where\n  pt := E.left.obj Y\n  π :=\n    { app := fun g ↦ E.left.map g.hom ≫ E.hom.app g.right\n      naturality := fun g₁ g₂ φ ↦ by\n        dsimp\n        rw [assoc, id_comp, ← StructuredArrow.w φ, Functor.map_comp, assoc]\n        congr 1\n        apply E.hom.naturality }\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.coneAtFunctor_obj","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} D\ninst✝ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nY : D\nE : L.RightExtension F\n⊢ Eq ((CategoryTheory.Functor.RightExtension.coneAtFunctor L F Y).obj E) (E.coneAt Y)","decl":"variable (L F) in\n/-- The cones for `StructuredArrow.proj Y L ⋙ F`, as a functor from `RightExtension L F`. -/\n@[simps]\ndef coneAtFunctor (Y : D) :\n    RightExtension L F ⥤ Cone (StructuredArrow.proj Y L ⋙ F) where\n  obj E := E.coneAt Y\n  map {E E'} φ := ConeMorphism.mk (φ.left.app Y) (fun G ↦ by\n    dsimp\n    rw [← CostructuredArrow.w φ]\n    simp)\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.coneAtFunctor_map_hom","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} D\ninst✝ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nY : D\nE E' : L.RightExtension F\nφ : Quiver.Hom E E'\n⊢ Eq ((CategoryTheory.Functor.RightExtension.coneAtFunctor L F Y).map φ).hom (φ.left.app Y)","decl":"variable (L F) in\n/-- The cones for `StructuredArrow.proj Y L ⋙ F`, as a functor from `RightExtension L F`. -/\n@[simps]\ndef coneAtFunctor (Y : D) :\n    RightExtension L F ⥤ Cone (StructuredArrow.proj Y L ⋙ F) where\n  obj E := E.coneAt Y\n  map {E E'} φ := ConeMorphism.mk (φ.left.app Y) (fun G ↦ by\n    dsimp\n    rw [← CostructuredArrow.w φ]\n    simp)\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.IsPointwiseRightKanExtensionAt.hasPointwiseRightKanExtensionAt","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} D\ninst✝ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.RightExtension F\nY : D\nh : E.IsPointwiseRightKanExtensionAt Y\n⊢ L.HasPointwiseRightKanExtensionAt F Y","decl":"variable {E} in\nlemma IsPointwiseRightKanExtensionAt.hasPointwiseRightKanExtensionAt\n    {Y : D} (h : E.IsPointwiseRightKanExtensionAt Y) :\n    HasPointwiseRightKanExtensionAt L F Y := ⟨_, h⟩\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.IsPointwiseRightKanExtensionAt.isIso_hom_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} D\ninst✝² : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.RightExtension F\nX : C\nh : E.IsPointwiseRightKanExtensionAt (L.obj X)\ninst✝¹ : L.Full\ninst✝ : L.Faithful\n⊢ CategoryTheory.IsIso (E.hom.app X)","decl":"lemma IsPointwiseRightKanExtensionAt.isIso_hom_app\n    {X : C} (h : E.IsPointwiseRightKanExtensionAt (L.obj X)) [L.Full] [L.Faithful] :\n    IsIso (E.hom.app X) := by\n  simpa using h.isIso_π_app_of_isInitial _ StructuredArrow.mkIdInitial\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.IsPointwiseRightKanExtensionAt.isoLimit_hom_π","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.RightExtension F\nY : D\nh : E.IsPointwiseRightKanExtensionAt Y\ninst✝ : CategoryTheory.Limits.HasLimit ((CategoryTheory.StructuredArrow.proj Y L).comp F)\ng : CategoryTheory.StructuredArrow Y L\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.isoLimit.hom (CategoryTheory.Limits.limit.π ((CategoryTheory.StructuredArrow.proj Y L).comp F) g)) (CategoryTheory.CategoryStruct.comp (E.left.map g.hom) (E.hom.app g.right))","decl":"@[reassoc (attr := simp)]\nlemma isoLimit_hom_π (g : StructuredArrow Y L) :\n    h.isoLimit.hom ≫ limit.π _ g = E.left.map g.hom ≫ E.hom.app g.right :=\n  IsLimit.conePointUniqueUpToIso_hom_comp _ _ _\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.IsPointwiseRightKanExtensionAt.isoLimit_hom_π_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.RightExtension F\nY : D\nh✝ : E.IsPointwiseRightKanExtensionAt Y\ninst✝ : CategoryTheory.Limits.HasLimit ((CategoryTheory.StructuredArrow.proj Y L).comp F)\ng : CategoryTheory.StructuredArrow Y L\nZ : H\nh : Quiver.Hom (F.obj ((CategoryTheory.StructuredArrow.proj Y L).obj g)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h✝.isoLimit.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π ((CategoryTheory.StructuredArrow.proj Y L).comp F) g) h)) (CategoryTheory.CategoryStruct.comp (E.left.map g.hom) (CategoryTheory.CategoryStruct.comp (E.hom.app g.right) h))","decl":"@[reassoc (attr := simp)]\nlemma isoLimit_hom_π (g : StructuredArrow Y L) :\n    h.isoLimit.hom ≫ limit.π _ g = E.left.map g.hom ≫ E.hom.app g.right :=\n  IsLimit.conePointUniqueUpToIso_hom_comp _ _ _\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.IsPointwiseRightKanExtensionAt.isoLimit_inv_π_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.RightExtension F\nY : D\nh✝ : E.IsPointwiseRightKanExtensionAt Y\ninst✝ : CategoryTheory.Limits.HasLimit ((CategoryTheory.StructuredArrow.proj Y L).comp F)\ng : CategoryTheory.StructuredArrow Y L\nZ : H\nh : Quiver.Hom (((CategoryTheory.Functor.fromPUnit F).obj E.right).obj g.right) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h✝.isoLimit.inv (CategoryTheory.CategoryStruct.comp (E.left.map g.hom) (CategoryTheory.CategoryStruct.comp (E.hom.app g.right) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π ((CategoryTheory.StructuredArrow.proj Y L).comp F) g) h)","decl":"@[reassoc (attr := simp)]\nlemma isoLimit_inv_π (g : StructuredArrow Y L) :\n    h.isoLimit.inv ≫ E.left.map g.hom ≫ E.hom.app g.right =\n      limit.π (StructuredArrow.proj Y L ⋙ F) g := by\n  simpa using h.conePointUniqueUpToIso_inv_comp (limit.isLimit _) g\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.IsPointwiseRightKanExtensionAt.isoLimit_inv_π","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.RightExtension F\nY : D\nh : E.IsPointwiseRightKanExtensionAt Y\ninst✝ : CategoryTheory.Limits.HasLimit ((CategoryTheory.StructuredArrow.proj Y L).comp F)\ng : CategoryTheory.StructuredArrow Y L\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.isoLimit.inv (CategoryTheory.CategoryStruct.comp (E.left.map g.hom) (E.hom.app g.right))) (CategoryTheory.Limits.limit.π ((CategoryTheory.StructuredArrow.proj Y L).comp F) g)","decl":"@[reassoc (attr := simp)]\nlemma isoLimit_inv_π (g : StructuredArrow Y L) :\n    h.isoLimit.inv ≫ E.left.map g.hom ≫ E.hom.app g.right =\n      limit.π (StructuredArrow.proj Y L ⋙ F) g := by\n  simpa using h.conePointUniqueUpToIso_inv_comp (limit.isLimit _) g\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.IsPointwiseRightKanExtension.hasPointwiseRightKanExtension","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} D\ninst✝ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.RightExtension F\nh : E.IsPointwiseRightKanExtension\n⊢ L.HasPointwiseRightKanExtension F","decl":"lemma IsPointwiseRightKanExtension.hasPointwiseRightKanExtension :\n    HasPointwiseRightKanExtension L F :=\n  fun Y => (h Y).hasPointwiseRightKanExtensionAt\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.IsPointwiseRightKanExtension.hom_ext","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_6, u_2} D\ninst✝ : CategoryTheory.Category.{u_5, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.RightExtension F\nh : E.IsPointwiseRightKanExtension\nG : L.RightExtension F\nf₁ f₂ : Quiver.Hom G E\n⊢ Eq f₁ f₂","decl":"lemma IsPointwiseRightKanExtension.hom_ext\n    {G : RightExtension L F} {f₁ f₂ : G ⟶ E} : f₁ = f₂ := by\n  ext Y\n  apply (h Y).hom_ext\n  intro X\n  have eq₁ := congr_app (CostructuredArrow.w f₁) X.right\n  have eq₂ := congr_app (CostructuredArrow.w f₂) X.right\n  dsimp at eq₁ eq₂ ⊢\n  simp only [assoc, ← NatTrans.naturality_assoc, eq₁, eq₂]\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.IsPointwiseRightKanExtension.isRightKanExtension","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_6, u_2} D\ninst✝ : CategoryTheory.Category.{u_5, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.RightExtension F\nh : E.IsPointwiseRightKanExtension\n⊢ E.left.IsRightKanExtension E.hom","decl":"lemma IsPointwiseRightKanExtension.isRightKanExtension :\n    E.left.IsRightKanExtension E.hom where\n  nonempty_isUniversal := ⟨h.isUniversal⟩\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.IsPointwiseRightKanExtension.hasRightKanExtension","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_6, u_2} D\ninst✝ : CategoryTheory.Category.{u_5, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.RightExtension F\nh : E.IsPointwiseRightKanExtension\n⊢ L.HasRightKanExtension F","decl":"lemma IsPointwiseRightKanExtension.hasRightKanExtension :\n    HasRightKanExtension L F :=\n  have := h.isRightKanExtension\n  HasRightKanExtension.mk E.left E.hom\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.IsPointwiseRightKanExtension.isIso_hom","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} D\ninst✝² : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nE : L.RightExtension F\nh : E.IsPointwiseRightKanExtension\ninst✝¹ : L.Full\ninst✝ : L.Faithful\n⊢ CategoryTheory.IsIso E.hom","decl":"lemma IsPointwiseRightKanExtension.isIso_hom [L.Full] [L.Faithful] :\n    IsIso (E.hom) :=\n  have := fun X => (h (L.obj X)).isIso_hom_app\n  NatIso.isIso_of_isIso_app ..\n\n"}
{"name":"CategoryTheory.Functor.pointwiseLeftKanExtension_obj","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst✝ : L.HasPointwiseLeftKanExtension F\nY : D\n⊢ Eq ((L.pointwiseLeftKanExtension F).obj Y) (CategoryTheory.Limits.colimit ((CategoryTheory.CostructuredArrow.proj L Y).comp F))","decl":"/-- The constructed pointwise left Kan extension when `HasPointwiseLeftKanExtension L F` holds. -/\n@[simps]\nnoncomputable def pointwiseLeftKanExtension : D ⥤ H where\n  obj Y := colimit (CostructuredArrow.proj L Y ⋙ F)\n  map {Y₁ Y₂} f :=\n    colimit.desc (CostructuredArrow.proj L Y₁ ⋙ F)\n      (Cocone.mk (colimit (CostructuredArrow.proj L Y₂ ⋙ F))\n        { app := fun g => colimit.ι (CostructuredArrow.proj L Y₂ ⋙ F)\n            ((CostructuredArrow.map f).obj g)\n          naturality := fun g₁ g₂ φ => by\n            simpa using colimit.w (CostructuredArrow.proj L Y₂ ⋙ F)\n              ((CostructuredArrow.map f).map φ) })\n  map_id Y := colimit.hom_ext (fun j => by\n    dsimp\n    simp only [colimit.ι_desc, comp_id]\n    congr\n    apply CostructuredArrow.map_id)\n  map_comp {Y₁ Y₂ Y₃} f f' := colimit.hom_ext (fun j => by\n    dsimp\n    simp only [colimit.ι_desc, colimit.ι_desc_assoc, comp_obj, CostructuredArrow.proj_obj]\n    congr 1\n    apply CostructuredArrow.map_comp)\n\n"}
{"name":"CategoryTheory.Functor.pointwiseLeftKanExtension_map","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst✝ : L.HasPointwiseLeftKanExtension F\nY₁ Y₂ : D\nf : Quiver.Hom Y₁ Y₂\n⊢ Eq ((L.pointwiseLeftKanExtension F).map f) (CategoryTheory.Limits.colimit.desc ((CategoryTheory.CostructuredArrow.proj L Y₁).comp F) { pt := CategoryTheory.Limits.colimit ((CategoryTheory.CostructuredArrow.proj L Y₂).comp F), ι := { app := fun g => CategoryTheory.Limits.colimit.ι ((CategoryTheory.CostructuredArrow.proj L Y₂).comp F) ((CategoryTheory.CostructuredArrow.map f).obj g), naturality := ⋯ } })","decl":"/-- The constructed pointwise left Kan extension when `HasPointwiseLeftKanExtension L F` holds. -/\n@[simps]\nnoncomputable def pointwiseLeftKanExtension : D ⥤ H where\n  obj Y := colimit (CostructuredArrow.proj L Y ⋙ F)\n  map {Y₁ Y₂} f :=\n    colimit.desc (CostructuredArrow.proj L Y₁ ⋙ F)\n      (Cocone.mk (colimit (CostructuredArrow.proj L Y₂ ⋙ F))\n        { app := fun g => colimit.ι (CostructuredArrow.proj L Y₂ ⋙ F)\n            ((CostructuredArrow.map f).obj g)\n          naturality := fun g₁ g₂ φ => by\n            simpa using colimit.w (CostructuredArrow.proj L Y₂ ⋙ F)\n              ((CostructuredArrow.map f).map φ) })\n  map_id Y := colimit.hom_ext (fun j => by\n    dsimp\n    simp only [colimit.ι_desc, comp_id]\n    congr\n    apply CostructuredArrow.map_id)\n  map_comp {Y₁ Y₂ Y₃} f f' := colimit.hom_ext (fun j => by\n    dsimp\n    simp only [colimit.ι_desc, colimit.ι_desc_assoc, comp_obj, CostructuredArrow.proj_obj]\n    congr 1\n    apply CostructuredArrow.map_comp)\n\n"}
{"name":"CategoryTheory.Functor.pointwiseLeftKanExtensionUnit_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst✝ : L.HasPointwiseLeftKanExtension F\nX : C\n⊢ Eq ((L.pointwiseLeftKanExtensionUnit F).app X) (CategoryTheory.Limits.colimit.ι ((CategoryTheory.CostructuredArrow.proj L (L.obj X)).comp F) (CategoryTheory.CostructuredArrow.mk (CategoryTheory.CategoryStruct.id (L.obj X))))","decl":"/-- The unit of the constructed pointwise left Kan extension when\n`HasPointwiseLeftKanExtension L F` holds. -/\n@[simps]\nnoncomputable def pointwiseLeftKanExtensionUnit : F ⟶ L ⋙ pointwiseLeftKanExtension L F where\n  app X := colimit.ι (CostructuredArrow.proj L (L.obj X) ⋙ F)\n    (CostructuredArrow.mk (𝟙 (L.obj X)))\n  naturality {X₁ X₂} f := by\n    simp only [comp_obj, pointwiseLeftKanExtension_obj, comp_map,\n      pointwiseLeftKanExtension_map, colimit.ι_desc, CostructuredArrow.map_mk]\n    rw [id_comp]\n    let φ : CostructuredArrow.mk (L.map f) ⟶ CostructuredArrow.mk (𝟙 (L.obj X₂)) :=\n      CostructuredArrow.homMk f\n    exact colimit.w (CostructuredArrow.proj L (L.obj X₂) ⋙ F) φ\n\n"}
{"name":"CategoryTheory.Functor.instIsLeftKanExtensionPointwiseLeftKanExtensionPointwiseLeftKanExtensionUnit","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝² : CategoryTheory.Category.{u_6, u_2} D\ninst✝¹ : CategoryTheory.Category.{u_5, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst✝ : L.HasPointwiseLeftKanExtension F\n⊢ (L.pointwiseLeftKanExtension F).IsLeftKanExtension (L.pointwiseLeftKanExtensionUnit F)","decl":"instance : (pointwiseLeftKanExtension L F).IsLeftKanExtension\n    (pointwiseLeftKanExtensionUnit L F) where\n  nonempty_isUniversal := ⟨pointwiseLeftKanExtensionIsUniversal L F⟩\n\n"}
{"name":"CategoryTheory.Functor.instHasLeftKanExtension","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝² : CategoryTheory.Category.{u_6, u_2} D\ninst✝¹ : CategoryTheory.Category.{u_5, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst✝ : L.HasPointwiseLeftKanExtension F\n⊢ L.HasLeftKanExtension F","decl":"instance : HasLeftKanExtension L F :=\n  HasLeftKanExtension.mk _ (pointwiseLeftKanExtensionUnit L F)\n\n"}
{"name":"CategoryTheory.Functor.costructuredArrowMapCocone_ι_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} D\ninst✝ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nG : CategoryTheory.Functor D H\nα : Quiver.Hom F (L.comp G)\nY : D\nf : CategoryTheory.CostructuredArrow L Y\n⊢ Eq ((L.costructuredArrowMapCocone F G α Y).ι.app f) (CategoryTheory.CategoryStruct.comp (α.app f.left) (G.map f.hom))","decl":"/-- An auxiliary cocone used in the lemma `pointwiseLeftKanExtension_desc_app` -/\n@[simps]\ndef costructuredArrowMapCocone (G : D ⥤ H) (α : F ⟶ L ⋙ G) (Y : D) :\n    Cocone (CostructuredArrow.proj L Y ⋙ F) where\n  pt := G.obj Y\n  ι := {\n    app := fun f ↦ α.app f.left ≫ G.map f.hom\n    naturality := by simp [← G.map_comp] }\n\n"}
{"name":"CategoryTheory.Functor.costructuredArrowMapCocone_pt","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} D\ninst✝ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nG : CategoryTheory.Functor D H\nα : Quiver.Hom F (L.comp G)\nY : D\n⊢ Eq (L.costructuredArrowMapCocone F G α Y).pt (G.obj Y)","decl":"/-- An auxiliary cocone used in the lemma `pointwiseLeftKanExtension_desc_app` -/\n@[simps]\ndef costructuredArrowMapCocone (G : D ⥤ H) (α : F ⟶ L ⋙ G) (Y : D) :\n    Cocone (CostructuredArrow.proj L Y ⋙ F) where\n  pt := G.obj Y\n  ι := {\n    app := fun f ↦ α.app f.left ≫ G.map f.hom\n    naturality := by simp [← G.map_comp] }\n\n"}
{"name":"CategoryTheory.Functor.pointwiseLeftKanExtension_desc_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_4, u_2} D\ninst✝¹ : CategoryTheory.Category.{u_5, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst✝ : L.HasPointwiseLeftKanExtension F\nG : CategoryTheory.Functor D H\nα : Quiver.Hom F (L.comp G)\nY : D\n⊢ Eq (((L.pointwiseLeftKanExtension F).descOfIsLeftKanExtension (L.pointwiseLeftKanExtensionUnit F) G α).app Y) (CategoryTheory.Limits.colimit.desc ((CategoryTheory.CostructuredArrow.proj L Y).comp F) (L.costructuredArrowMapCocone F G α Y))","decl":"@[simp]\nlemma pointwiseLeftKanExtension_desc_app (G : D ⥤ H) (α :  F ⟶ L ⋙ G) (Y : D) :\n    ((pointwiseLeftKanExtension L F).descOfIsLeftKanExtension (pointwiseLeftKanExtensionUnit L F)\n      G α |>.app Y) = colimit.desc _ (costructuredArrowMapCocone L F G α Y) := by\n  let β : L.pointwiseLeftKanExtension F ⟶ G :=\n    { app := fun Y ↦ colimit.desc _ (costructuredArrowMapCocone L F G α Y) }\n  have h : (pointwiseLeftKanExtension L F).descOfIsLeftKanExtension\n      (pointwiseLeftKanExtensionUnit L F) G α = β := by\n    apply hom_ext_of_isLeftKanExtension (α := pointwiseLeftKanExtensionUnit L F)\n    aesop\n  exact NatTrans.congr_app h Y\n\n"}
{"name":"CategoryTheory.Functor.pointwiseRightKanExtension_obj","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst✝ : L.HasPointwiseRightKanExtension F\nY : D\n⊢ Eq ((L.pointwiseRightKanExtension F).obj Y) (CategoryTheory.Limits.limit ((CategoryTheory.StructuredArrow.proj Y L).comp F))","decl":"/-- The constructed pointwise right Kan extension\nwhen `HasPointwiseRightKanExtension L F` holds. -/\n@[simps]\nnoncomputable def pointwiseRightKanExtension : D ⥤ H where\n  obj Y := limit (StructuredArrow.proj Y L ⋙ F)\n  map {Y₁ Y₂} f := limit.lift (StructuredArrow.proj Y₂ L ⋙ F)\n      (Cone.mk (limit (StructuredArrow.proj Y₁ L ⋙ F))\n        { app := fun g ↦ limit.π (StructuredArrow.proj Y₁ L ⋙ F)\n            ((StructuredArrow.map f).obj g)\n          naturality := fun g₁ g₂ φ ↦ by\n            simpa using (limit.w (StructuredArrow.proj Y₁ L ⋙ F)\n              ((StructuredArrow.map f).map φ)).symm })\n  map_id Y := limit.hom_ext (fun j => by\n    dsimp\n    simp only [limit.lift_π, id_comp]\n    congr\n    apply StructuredArrow.map_id)\n  map_comp {Y₁ Y₂ Y₃} f f' := limit.hom_ext (fun j => by\n    dsimp\n    simp only [limit.lift_π, assoc]\n    congr 1\n    apply StructuredArrow.map_comp)\n\n"}
{"name":"CategoryTheory.Functor.pointwiseRightKanExtension_map","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst✝ : L.HasPointwiseRightKanExtension F\nY₁ Y₂ : D\nf : Quiver.Hom Y₁ Y₂\n⊢ Eq ((L.pointwiseRightKanExtension F).map f) (CategoryTheory.Limits.limit.lift ((CategoryTheory.StructuredArrow.proj Y₂ L).comp F) { pt := CategoryTheory.Limits.limit ((CategoryTheory.StructuredArrow.proj Y₁ L).comp F), π := { app := fun g => CategoryTheory.Limits.limit.π ((CategoryTheory.StructuredArrow.proj Y₁ L).comp F) ((CategoryTheory.StructuredArrow.map f).obj g), naturality := ⋯ } })","decl":"/-- The constructed pointwise right Kan extension\nwhen `HasPointwiseRightKanExtension L F` holds. -/\n@[simps]\nnoncomputable def pointwiseRightKanExtension : D ⥤ H where\n  obj Y := limit (StructuredArrow.proj Y L ⋙ F)\n  map {Y₁ Y₂} f := limit.lift (StructuredArrow.proj Y₂ L ⋙ F)\n      (Cone.mk (limit (StructuredArrow.proj Y₁ L ⋙ F))\n        { app := fun g ↦ limit.π (StructuredArrow.proj Y₁ L ⋙ F)\n            ((StructuredArrow.map f).obj g)\n          naturality := fun g₁ g₂ φ ↦ by\n            simpa using (limit.w (StructuredArrow.proj Y₁ L ⋙ F)\n              ((StructuredArrow.map f).map φ)).symm })\n  map_id Y := limit.hom_ext (fun j => by\n    dsimp\n    simp only [limit.lift_π, id_comp]\n    congr\n    apply StructuredArrow.map_id)\n  map_comp {Y₁ Y₂ Y₃} f f' := limit.hom_ext (fun j => by\n    dsimp\n    simp only [limit.lift_π, assoc]\n    congr 1\n    apply StructuredArrow.map_comp)\n\n"}
{"name":"CategoryTheory.Functor.pointwiseRightKanExtensionCounit_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst✝ : L.HasPointwiseRightKanExtension F\nX : C\n⊢ Eq ((L.pointwiseRightKanExtensionCounit F).app X) (CategoryTheory.Limits.limit.π ((CategoryTheory.StructuredArrow.proj (L.obj X) L).comp F) (CategoryTheory.StructuredArrow.mk (CategoryTheory.CategoryStruct.id (L.obj X))))","decl":"/-- The counit of the constructed pointwise right Kan extension when\n`HasPointwiseRightKanExtension L F` holds. -/\n@[simps]\nnoncomputable def pointwiseRightKanExtensionCounit :\n    L ⋙ pointwiseRightKanExtension L F ⟶ F where\n  app X := limit.π (StructuredArrow.proj (L.obj X) L ⋙ F)\n    (StructuredArrow.mk (𝟙 (L.obj X)))\n  naturality {X₁ X₂} f := by\n    simp only [comp_obj, pointwiseRightKanExtension_obj, comp_map,\n      pointwiseRightKanExtension_map, limit.lift_π, StructuredArrow.map_mk]\n    rw [comp_id]\n    let φ : StructuredArrow.mk (𝟙 (L.obj X₁)) ⟶ StructuredArrow.mk (L.map f) :=\n      StructuredArrow.homMk f\n    exact (limit.w (StructuredArrow.proj (L.obj X₁) L ⋙ F) φ).symm\n\n"}
{"name":"CategoryTheory.Functor.instIsRightKanExtensionPointwiseRightKanExtensionPointwiseRightKanExtensionCounit","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝² : CategoryTheory.Category.{u_6, u_2} D\ninst✝¹ : CategoryTheory.Category.{u_5, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst✝ : L.HasPointwiseRightKanExtension F\n⊢ (L.pointwiseRightKanExtension F).IsRightKanExtension (L.pointwiseRightKanExtensionCounit F)","decl":"instance : (pointwiseRightKanExtension L F).IsRightKanExtension\n    (pointwiseRightKanExtensionCounit L F) where\n  nonempty_isUniversal := ⟨pointwiseRightKanExtensionIsUniversal L F⟩\n\n"}
{"name":"CategoryTheory.Functor.instHasRightKanExtension","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝² : CategoryTheory.Category.{u_6, u_2} D\ninst✝¹ : CategoryTheory.Category.{u_5, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst✝ : L.HasPointwiseRightKanExtension F\n⊢ L.HasRightKanExtension F","decl":"instance : HasRightKanExtension L F :=\n  HasRightKanExtension.mk _ (pointwiseRightKanExtensionCounit L F)\n\n"}
{"name":"CategoryTheory.Functor.structuredArrowMapCone_π_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} D\ninst✝ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nG : CategoryTheory.Functor D H\nα : Quiver.Hom (L.comp G) F\nY : D\nf : CategoryTheory.StructuredArrow Y L\n⊢ Eq ((L.structuredArrowMapCone F G α Y).π.app f) (CategoryTheory.CategoryStruct.comp (G.map f.hom) (α.app f.right))","decl":"/-- An auxiliary cocone used in the lemma `pointwiseRightKanExtension_lift_app` -/\n@[simps]\ndef structuredArrowMapCone (G : D ⥤ H) (α : L ⋙ G ⟶ F) (Y : D) :\n    Cone (StructuredArrow.proj Y L ⋙ F) where\n  pt := G.obj Y\n  π := {\n    app := fun f ↦ G.map f.hom ≫ α.app f.right\n    naturality := by simp [← α.naturality, ← G.map_comp_assoc] }\n\n"}
{"name":"CategoryTheory.Functor.structuredArrowMapCone_pt","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} D\ninst✝ : CategoryTheory.Category.{u_6, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nG : CategoryTheory.Functor D H\nα : Quiver.Hom (L.comp G) F\nY : D\n⊢ Eq (L.structuredArrowMapCone F G α Y).pt (G.obj Y)","decl":"/-- An auxiliary cocone used in the lemma `pointwiseRightKanExtension_lift_app` -/\n@[simps]\ndef structuredArrowMapCone (G : D ⥤ H) (α : L ⋙ G ⟶ F) (Y : D) :\n    Cone (StructuredArrow.proj Y L ⋙ F) where\n  pt := G.obj Y\n  π := {\n    app := fun f ↦ G.map f.hom ≫ α.app f.right\n    naturality := by simp [← α.naturality, ← G.map_comp_assoc] }\n\n"}
{"name":"CategoryTheory.Functor.pointwiseRightKanExtension_lift_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Pointwise","initialProofState":"C : Type u_1\nD : Type u_2\nH : Type u_3\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_4, u_2} D\ninst✝¹ : CategoryTheory.Category.{u_5, u_3} H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst✝ : L.HasPointwiseRightKanExtension F\nG : CategoryTheory.Functor D H\nα : Quiver.Hom (L.comp G) F\nY : D\n⊢ Eq (((L.pointwiseRightKanExtension F).liftOfIsRightKanExtension (L.pointwiseRightKanExtensionCounit F) G α).app Y) (CategoryTheory.Limits.limit.lift ((CategoryTheory.StructuredArrow.proj Y L).comp F) (L.structuredArrowMapCone F G α Y))","decl":"@[simp]\nlemma pointwiseRightKanExtension_lift_app (G : D ⥤ H) (α : L ⋙ G ⟶ F) (Y : D) :\n    ((pointwiseRightKanExtension L F).liftOfIsRightKanExtension\n      (pointwiseRightKanExtensionCounit L F) G α |>.app Y) =\n        limit.lift _ (structuredArrowMapCone L F G α Y) := by\n  let β : G ⟶ L.pointwiseRightKanExtension F :=\n    { app := fun Y ↦ limit.lift _ (structuredArrowMapCone L F G α Y) }\n  have h : (pointwiseRightKanExtension L F).liftOfIsRightKanExtension\n      (pointwiseRightKanExtensionCounit L F) G α = β := by\n    apply hom_ext_of_isRightKanExtension (α := pointwiseRightKanExtensionCounit L F)\n    aesop\n  exact NatTrans.congr_app h Y\n\n"}
