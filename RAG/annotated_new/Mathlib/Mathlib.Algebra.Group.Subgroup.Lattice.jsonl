{"name":"Subgroup.coe_toAddSubgroup_apply","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nS : Subgroup G\n⊢ Eq (↑(Subgroup.toAddSubgroup S)) (Set.preimage ⇑Additive.toMul ↑S)","decl":"/-- Subgroups of a group `G` are isomorphic to additive subgroups of `Additive G`. -/\n@[simps!]\ndef Subgroup.toAddSubgroup : Subgroup G ≃o AddSubgroup (Additive G) where\n  toFun S := { Submonoid.toAddSubmonoid S.toSubmonoid with neg_mem' := S.inv_mem' }\n  invFun S := { AddSubmonoid.toSubmonoid S.toAddSubmonoid with inv_mem' := S.neg_mem' }\n  left_inv x := by cases x; rfl\n  right_inv x := by cases x; rfl\n  map_rel_iff' := Iff.rfl\n\n"}
{"name":"Subgroup.coe_toAddSubgroup_symm_apply","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nS : AddSubgroup (Additive G)\n⊢ Eq (↑((RelIso.symm Subgroup.toAddSubgroup) S)) (Set.preimage ⇑Multiplicative.toAdd ↑S)","decl":"/-- Subgroups of a group `G` are isomorphic to additive subgroups of `Additive G`. -/\n@[simps!]\ndef Subgroup.toAddSubgroup : Subgroup G ≃o AddSubgroup (Additive G) where\n  toFun S := { Submonoid.toAddSubmonoid S.toSubmonoid with neg_mem' := S.inv_mem' }\n  invFun S := { AddSubmonoid.toSubmonoid S.toAddSubmonoid with inv_mem' := S.neg_mem' }\n  left_inv x := by cases x; rfl\n  right_inv x := by cases x; rfl\n  map_rel_iff' := Iff.rfl\n\n"}
{"name":"AddSubgroup.coe_toSubgroup_symm_apply","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"A : Type u_2\ninst✝ : AddGroup A\nS : Subgroup (Multiplicative A)\n⊢ Eq (↑((RelIso.symm AddSubgroup.toSubgroup) S)) (Set.preimage ⇑Additive.toMul ↑S)","decl":"/-- Additive subgroups of an additive group `A` are isomorphic to subgroups of `Multiplicative A`.\n-/\n@[simps!]\ndef AddSubgroup.toSubgroup : AddSubgroup A ≃o Subgroup (Multiplicative A) where\n  toFun S := { AddSubmonoid.toSubmonoid S.toAddSubmonoid with inv_mem' := S.neg_mem' }\n  invFun S := { Submonoid.toAddSubmonoid S.toSubmonoid with neg_mem' := S.inv_mem' }\n  left_inv x := by cases x; rfl\n  right_inv x := by cases x; rfl\n  map_rel_iff' := Iff.rfl\n\n"}
{"name":"AddSubgroup.coe_toSubgroup_apply","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"A : Type u_2\ninst✝ : AddGroup A\nS : AddSubgroup A\n⊢ Eq (↑(AddSubgroup.toSubgroup S)) (Set.preimage ⇑Multiplicative.toAdd ↑S)","decl":"/-- Additive subgroups of an additive group `A` are isomorphic to subgroups of `Multiplicative A`.\n-/\n@[simps!]\ndef AddSubgroup.toSubgroup : AddSubgroup A ≃o Subgroup (Multiplicative A) where\n  toFun S := { AddSubmonoid.toSubmonoid S.toAddSubmonoid with inv_mem' := S.neg_mem' }\n  invFun S := { Submonoid.toAddSubmonoid S.toSubmonoid with neg_mem' := S.inv_mem' }\n  left_inv x := by cases x; rfl\n  right_inv x := by cases x; rfl\n  map_rel_iff' := Iff.rfl\n\n"}
{"name":"Subgroup.topEquiv_apply","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nx : Subtype fun x => Membership.mem Top.top x\n⊢ Eq (Subgroup.topEquiv x) ↑x","decl":"/-- The top subgroup is isomorphic to the group.\n\nThis is the group version of `Submonoid.topEquiv`. -/\n@[to_additive (attr := simps!)\n      \"The top additive subgroup is isomorphic to the additive group.\n\n      This is the additive group version of `AddSubmonoid.topEquiv`.\"]\ndef topEquiv : (⊤ : Subgroup G) ≃* G :=\n  Submonoid.topEquiv\n\n"}
{"name":"AddSubgroup.topEquiv_apply","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nx : Subtype fun x => Membership.mem Top.top x\n⊢ Eq (AddSubgroup.topEquiv x) ↑x","decl":"/-- The top subgroup is isomorphic to the group.\n\nThis is the group version of `Submonoid.topEquiv`. -/\n@[to_additive (attr := simps!)\n      \"The top additive subgroup is isomorphic to the additive group.\n\n      This is the additive group version of `AddSubmonoid.topEquiv`.\"]\ndef topEquiv : (⊤ : Subgroup G) ≃* G :=\n  Submonoid.topEquiv\n\n"}
{"name":"AddSubgroup.topEquiv_symm_apply_coe","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nx : G\n⊢ Eq (↑(AddSubgroup.topEquiv.symm x)) x","decl":"/-- The top subgroup is isomorphic to the group.\n\nThis is the group version of `Submonoid.topEquiv`. -/\n@[to_additive (attr := simps!)\n      \"The top additive subgroup is isomorphic to the additive group.\n\n      This is the additive group version of `AddSubmonoid.topEquiv`.\"]\ndef topEquiv : (⊤ : Subgroup G) ≃* G :=\n  Submonoid.topEquiv\n\n"}
{"name":"Subgroup.topEquiv_symm_apply_coe","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nx : G\n⊢ Eq (↑(Subgroup.topEquiv.symm x)) x","decl":"/-- The top subgroup is isomorphic to the group.\n\nThis is the group version of `Submonoid.topEquiv`. -/\n@[to_additive (attr := simps!)\n      \"The top additive subgroup is isomorphic to the additive group.\n\n      This is the additive group version of `AddSubmonoid.topEquiv`.\"]\ndef topEquiv : (⊤ : Subgroup G) ≃* G :=\n  Submonoid.topEquiv\n\n"}
{"name":"AddSubgroup.mem_bot","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nx : G\n⊢ Iff (Membership.mem Bot.bot x) (Eq x 0)","decl":"@[to_additive (attr := simp)]\ntheorem mem_bot {x : G} : x ∈ (⊥ : Subgroup G) ↔ x = 1 :=\n  Iff.rfl\n\n"}
{"name":"Subgroup.mem_bot","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nx : G\n⊢ Iff (Membership.mem Bot.bot x) (Eq x 1)","decl":"@[to_additive (attr := simp)]\ntheorem mem_bot {x : G} : x ∈ (⊥ : Subgroup G) ↔ x = 1 :=\n  Iff.rfl\n\n"}
{"name":"Subgroup.mem_top","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nx : G\n⊢ Membership.mem Top.top x","decl":"@[to_additive (attr := simp)]\ntheorem mem_top (x : G) : x ∈ (⊤ : Subgroup G) :=\n  Set.mem_univ x\n\n"}
{"name":"AddSubgroup.mem_top","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nx : G\n⊢ Membership.mem Top.top x","decl":"@[to_additive (attr := simp)]\ntheorem mem_top (x : G) : x ∈ (⊤ : Subgroup G) :=\n  Set.mem_univ x\n\n"}
{"name":"AddSubgroup.coe_top","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\n⊢ Eq (↑Top.top) Set.univ","decl":"@[to_additive (attr := simp)]\ntheorem coe_top : ((⊤ : Subgroup G) : Set G) = Set.univ :=\n  rfl\n\n"}
{"name":"Subgroup.coe_top","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Eq (↑Top.top) Set.univ","decl":"@[to_additive (attr := simp)]\ntheorem coe_top : ((⊤ : Subgroup G) : Set G) = Set.univ :=\n  rfl\n\n"}
{"name":"AddSubgroup.coe_bot","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\n⊢ Eq (↑Bot.bot) (Singleton.singleton 0)","decl":"@[to_additive (attr := simp)]\ntheorem coe_bot : ((⊥ : Subgroup G) : Set G) = {1} :=\n  rfl\n\n"}
{"name":"Subgroup.coe_bot","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Eq (↑Bot.bot) (Singleton.singleton 1)","decl":"@[to_additive (attr := simp)]\ntheorem coe_bot : ((⊥ : Subgroup G) : Set G) = {1} :=\n  rfl\n\n"}
{"name":"AddSubgroup.top_toAddSubmonoid","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\n⊢ Eq Top.top.toAddSubmonoid Top.top","decl":"@[to_additive (attr := simp)]\ntheorem top_toSubmonoid : (⊤ : Subgroup G).toSubmonoid = ⊤ :=\n  rfl\n\n"}
{"name":"Subgroup.top_toSubmonoid","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Eq Top.top.toSubmonoid Top.top","decl":"@[to_additive (attr := simp)]\ntheorem top_toSubmonoid : (⊤ : Subgroup G).toSubmonoid = ⊤ :=\n  rfl\n\n"}
{"name":"Subgroup.bot_toSubmonoid","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Eq Bot.bot.toSubmonoid Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem bot_toSubmonoid : (⊥ : Subgroup G).toSubmonoid = ⊥ :=\n  rfl\n\n"}
{"name":"AddSubgroup.bot_toAddSubmonoid","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\n⊢ Eq Bot.bot.toAddSubmonoid Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem bot_toSubmonoid : (⊥ : Subgroup G).toSubmonoid = ⊥ :=\n  rfl\n\n"}
{"name":"Subgroup.eq_bot_iff_forall","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Iff (Eq H Bot.bot) (∀ (x : G), Membership.mem H x → Eq x 1)","decl":"@[to_additive]\ntheorem eq_bot_iff_forall : H = ⊥ ↔ ∀ x ∈ H, x = (1 : G) :=\n  toSubmonoid_injective.eq_iff.symm.trans <| Submonoid.eq_bot_iff_forall _\n\n"}
{"name":"AddSubgroup.eq_bot_iff_forall","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Iff (Eq H Bot.bot) (∀ (x : G), Membership.mem H x → Eq x 0)","decl":"@[to_additive]\ntheorem eq_bot_iff_forall : H = ⊥ ↔ ∀ x ∈ H, x = (1 : G) :=\n  toSubmonoid_injective.eq_iff.symm.trans <| Submonoid.eq_bot_iff_forall _\n\n"}
{"name":"Subgroup.eq_bot_of_subsingleton","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : Subsingleton (Subtype fun x => Membership.mem H x)\n⊢ Eq H Bot.bot","decl":"@[to_additive]\ntheorem eq_bot_of_subsingleton [Subsingleton H] : H = ⊥ := by\n  rw [Subgroup.eq_bot_iff_forall]\n  intro y hy\n  rw [← Subgroup.coe_mk H y hy, Subsingleton.elim (⟨y, hy⟩ : H) 1, Subgroup.coe_one]\n\n"}
{"name":"AddSubgroup.eq_bot_of_subsingleton","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nH : AddSubgroup G\ninst✝ : Subsingleton (Subtype fun x => Membership.mem H x)\n⊢ Eq H Bot.bot","decl":"@[to_additive]\ntheorem eq_bot_of_subsingleton [Subsingleton H] : H = ⊥ := by\n  rw [Subgroup.eq_bot_iff_forall]\n  intro y hy\n  rw [← Subgroup.coe_mk H y hy, Subsingleton.elim (⟨y, hy⟩ : H) 1, Subgroup.coe_one]\n\n"}
{"name":"Subgroup.coe_eq_univ","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Iff (Eq (↑H) Set.univ) (Eq H Top.top)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_eq_univ {H : Subgroup G} : (H : Set G) = Set.univ ↔ H = ⊤ :=\n  (SetLike.ext'_iff.trans (by rfl)).symm\n\n"}
{"name":"AddSubgroup.coe_eq_univ","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Iff (Eq (↑H) Set.univ) (Eq H Top.top)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_eq_univ {H : Subgroup G} : (H : Set G) = Set.univ ↔ H = ⊤ :=\n  (SetLike.ext'_iff.trans (by rfl)).symm\n\n"}
{"name":"Subgroup.coe_eq_singleton","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Iff (Exists fun g => Eq (↑H) (Singleton.singleton g)) (Eq H Bot.bot)","decl":"@[to_additive]\ntheorem coe_eq_singleton {H : Subgroup G} : (∃ g : G, (H : Set G) = {g}) ↔ H = ⊥ :=\n  ⟨fun ⟨g, hg⟩ =>\n    haveI : Subsingleton (H : Set G) := by\n      rw [hg]\n      infer_instance\n    H.eq_bot_of_subsingleton,\n    fun h => ⟨1, SetLike.ext'_iff.mp h⟩⟩\n\n"}
{"name":"AddSubgroup.coe_eq_singleton","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Iff (Exists fun g => Eq (↑H) (Singleton.singleton g)) (Eq H Bot.bot)","decl":"@[to_additive]\ntheorem coe_eq_singleton {H : Subgroup G} : (∃ g : G, (H : Set G) = {g}) ↔ H = ⊥ :=\n  ⟨fun ⟨g, hg⟩ =>\n    haveI : Subsingleton (H : Set G) := by\n      rw [hg]\n      infer_instance\n    H.eq_bot_of_subsingleton,\n    fun h => ⟨1, SetLike.ext'_iff.mp h⟩⟩\n\n"}
{"name":"AddSubgroup.nontrivial_iff_exists_ne_zero","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Iff (Nontrivial (Subtype fun x => Membership.mem H x)) (Exists fun x => And (Membership.mem H x) (Ne x 0))","decl":"@[to_additive]\ntheorem nontrivial_iff_exists_ne_one (H : Subgroup G) : Nontrivial H ↔ ∃ x ∈ H, x ≠ (1 : G) := by\n  rw [Subtype.nontrivial_iff_exists_ne (fun x => x ∈ H) (1 : H)]\n  simp\n\n"}
{"name":"Subgroup.nontrivial_iff_exists_ne_one","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Iff (Nontrivial (Subtype fun x => Membership.mem H x)) (Exists fun x => And (Membership.mem H x) (Ne x 1))","decl":"@[to_additive]\ntheorem nontrivial_iff_exists_ne_one (H : Subgroup G) : Nontrivial H ↔ ∃ x ∈ H, x ≠ (1 : G) := by\n  rw [Subtype.nontrivial_iff_exists_ne (fun x => x ∈ H) (1 : H)]\n  simp\n\n"}
{"name":"AddSubgroup.exists_ne_zero_of_nontrivial","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nH : AddSubgroup G\ninst✝ : Nontrivial (Subtype fun x => Membership.mem H x)\n⊢ Exists fun x => And (Membership.mem H x) (Ne x 0)","decl":"@[to_additive]\ntheorem exists_ne_one_of_nontrivial (H : Subgroup G) [Nontrivial H] :\n    ∃ x ∈ H, x ≠ 1 := by\n  rwa [← Subgroup.nontrivial_iff_exists_ne_one]\n\n"}
{"name":"Subgroup.exists_ne_one_of_nontrivial","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : Nontrivial (Subtype fun x => Membership.mem H x)\n⊢ Exists fun x => And (Membership.mem H x) (Ne x 1)","decl":"@[to_additive]\ntheorem exists_ne_one_of_nontrivial (H : Subgroup G) [Nontrivial H] :\n    ∃ x ∈ H, x ≠ 1 := by\n  rwa [← Subgroup.nontrivial_iff_exists_ne_one]\n\n"}
{"name":"AddSubgroup.nontrivial_iff_ne_bot","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Iff (Nontrivial (Subtype fun x => Membership.mem H x)) (Ne H Bot.bot)","decl":"@[to_additive]\ntheorem nontrivial_iff_ne_bot (H : Subgroup G) : Nontrivial H ↔ H ≠ ⊥ := by\n  rw [nontrivial_iff_exists_ne_one, ne_eq, eq_bot_iff_forall]\n  simp only [ne_eq, not_forall, exists_prop]\n\n"}
{"name":"Subgroup.nontrivial_iff_ne_bot","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Iff (Nontrivial (Subtype fun x => Membership.mem H x)) (Ne H Bot.bot)","decl":"@[to_additive]\ntheorem nontrivial_iff_ne_bot (H : Subgroup G) : Nontrivial H ↔ H ≠ ⊥ := by\n  rw [nontrivial_iff_exists_ne_one, ne_eq, eq_bot_iff_forall]\n  simp only [ne_eq, not_forall, exists_prop]\n\n"}
{"name":"Subgroup.bot_or_nontrivial","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Or (Eq H Bot.bot) (Nontrivial (Subtype fun x => Membership.mem H x))","decl":"/-- A subgroup is either the trivial subgroup or nontrivial. -/\n@[to_additive \"A subgroup is either the trivial subgroup or nontrivial.\"]\ntheorem bot_or_nontrivial (H : Subgroup G) : H = ⊥ ∨ Nontrivial H := by\n  have := nontrivial_iff_ne_bot H\n  tauto\n\n"}
{"name":"AddSubgroup.bot_or_nontrivial","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Or (Eq H Bot.bot) (Nontrivial (Subtype fun x => Membership.mem H x))","decl":"/-- A subgroup is either the trivial subgroup or nontrivial. -/\n@[to_additive \"A subgroup is either the trivial subgroup or nontrivial.\"]\ntheorem bot_or_nontrivial (H : Subgroup G) : H = ⊥ ∨ Nontrivial H := by\n  have := nontrivial_iff_ne_bot H\n  tauto\n\n"}
{"name":"AddSubgroup.bot_or_exists_ne_zero","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Or (Eq H Bot.bot) (Exists fun x => And (Membership.mem H x) (Ne x 0))","decl":"/-- A subgroup is either the trivial subgroup or contains a non-identity element. -/\n@[to_additive \"A subgroup is either the trivial subgroup or contains a nonzero element.\"]\ntheorem bot_or_exists_ne_one (H : Subgroup G) : H = ⊥ ∨ ∃ x ∈ H, x ≠ (1 : G) := by\n  convert H.bot_or_nontrivial\n  rw [nontrivial_iff_exists_ne_one]\n\n"}
{"name":"Subgroup.bot_or_exists_ne_one","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Or (Eq H Bot.bot) (Exists fun x => And (Membership.mem H x) (Ne x 1))","decl":"/-- A subgroup is either the trivial subgroup or contains a non-identity element. -/\n@[to_additive \"A subgroup is either the trivial subgroup or contains a nonzero element.\"]\ntheorem bot_or_exists_ne_one (H : Subgroup G) : H = ⊥ ∨ ∃ x ∈ H, x ≠ (1 : G) := by\n  convert H.bot_or_nontrivial\n  rw [nontrivial_iff_exists_ne_one]\n\n"}
{"name":"Subgroup.ne_bot_iff_exists_ne_one","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Iff (Ne H Bot.bot) (Exists fun a => Ne a 1)","decl":"@[to_additive]\nlemma ne_bot_iff_exists_ne_one {H : Subgroup G} : H ≠ ⊥ ↔ ∃ a : ↥H, a ≠ 1 := by\n  rw [← nontrivial_iff_ne_bot, nontrivial_iff_exists_ne_one]\n  simp only [ne_eq, Subtype.exists, mk_eq_one, exists_prop]\n\n"}
{"name":"AddSubgroup.ne_bot_iff_exists_ne_zero","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Iff (Ne H Bot.bot) (Exists fun a => Ne a 0)","decl":"@[to_additive]\nlemma ne_bot_iff_exists_ne_one {H : Subgroup G} : H ≠ ⊥ ↔ ∃ a : ↥H, a ≠ 1 := by\n  rw [← nontrivial_iff_ne_bot, nontrivial_iff_exists_ne_one]\n  simp only [ne_eq, Subtype.exists, mk_eq_one, exists_prop]\n\n"}
{"name":"Subgroup.coe_inf","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\np p' : Subgroup G\n⊢ Eq (↑(Min.min p p')) (Inter.inter ↑p ↑p')","decl":"@[to_additive (attr := simp)]\ntheorem coe_inf (p p' : Subgroup G) : ((p ⊓ p' : Subgroup G) : Set G) = (p : Set G) ∩ p' :=\n  rfl\n\n"}
{"name":"AddSubgroup.coe_inf","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\np p' : AddSubgroup G\n⊢ Eq (↑(Min.min p p')) (Inter.inter ↑p ↑p')","decl":"@[to_additive (attr := simp)]\ntheorem coe_inf (p p' : Subgroup G) : ((p ⊓ p' : Subgroup G) : Set G) = (p : Set G) ∩ p' :=\n  rfl\n\n"}
{"name":"AddSubgroup.mem_inf","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\np p' : AddSubgroup G\nx : G\n⊢ Iff (Membership.mem (Min.min p p') x) (And (Membership.mem p x) (Membership.mem p' x))","decl":"@[to_additive (attr := simp)]\ntheorem mem_inf {p p' : Subgroup G} {x : G} : x ∈ p ⊓ p' ↔ x ∈ p ∧ x ∈ p' :=\n  Iff.rfl\n\n"}
{"name":"Subgroup.mem_inf","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\np p' : Subgroup G\nx : G\n⊢ Iff (Membership.mem (Min.min p p') x) (And (Membership.mem p x) (Membership.mem p' x))","decl":"@[to_additive (attr := simp)]\ntheorem mem_inf {p p' : Subgroup G} {x : G} : x ∈ p ⊓ p' ↔ x ∈ p ∧ x ∈ p' :=\n  Iff.rfl\n\n"}
{"name":"AddSubgroup.coe_sInf","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : Set (AddSubgroup G)\n⊢ Eq (↑(InfSet.sInf H)) (Set.iInter fun s => Set.iInter fun h => ↑s)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_sInf (H : Set (Subgroup G)) : ((sInf H : Subgroup G) : Set G) = ⋂ s ∈ H, ↑s :=\n  rfl\n\n"}
{"name":"Subgroup.coe_sInf","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Set (Subgroup G)\n⊢ Eq (↑(InfSet.sInf H)) (Set.iInter fun s => Set.iInter fun h => ↑s)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_sInf (H : Set (Subgroup G)) : ((sInf H : Subgroup G) : Set G) = ⋂ s ∈ H, ↑s :=\n  rfl\n\n"}
{"name":"AddSubgroup.mem_sInf","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nS : Set (AddSubgroup G)\nx : G\n⊢ Iff (Membership.mem (InfSet.sInf S) x) (∀ (p : AddSubgroup G), Membership.mem S p → Membership.mem p x)","decl":"@[to_additive (attr := simp)]\ntheorem mem_sInf {S : Set (Subgroup G)} {x : G} : x ∈ sInf S ↔ ∀ p ∈ S, x ∈ p :=\n  Set.mem_iInter₂\n\n"}
{"name":"Subgroup.mem_sInf","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nS : Set (Subgroup G)\nx : G\n⊢ Iff (Membership.mem (InfSet.sInf S) x) (∀ (p : Subgroup G), Membership.mem S p → Membership.mem p x)","decl":"@[to_additive (attr := simp)]\ntheorem mem_sInf {S : Set (Subgroup G)} {x : G} : x ∈ sInf S ↔ ∀ p ∈ S, x ∈ p :=\n  Set.mem_iInter₂\n\n"}
{"name":"Subgroup.mem_iInf","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nι : Sort u_2\nS : ι → Subgroup G\nx : G\n⊢ Iff (Membership.mem (iInf fun i => S i) x) (∀ (i : ι), Membership.mem (S i) x)","decl":"@[to_additive]\ntheorem mem_iInf {ι : Sort*} {S : ι → Subgroup G} {x : G} : (x ∈ ⨅ i, S i) ↔ ∀ i, x ∈ S i := by\n  simp only [iInf, mem_sInf, Set.forall_mem_range]\n\n"}
{"name":"AddSubgroup.mem_iInf","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nι : Sort u_2\nS : ι → AddSubgroup G\nx : G\n⊢ Iff (Membership.mem (iInf fun i => S i) x) (∀ (i : ι), Membership.mem (S i) x)","decl":"@[to_additive]\ntheorem mem_iInf {ι : Sort*} {S : ι → Subgroup G} {x : G} : (x ∈ ⨅ i, S i) ↔ ∀ i, x ∈ S i := by\n  simp only [iInf, mem_sInf, Set.forall_mem_range]\n\n"}
{"name":"Subgroup.coe_iInf","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nι : Sort u_2\nS : ι → Subgroup G\n⊢ Eq (↑(iInf fun i => S i)) (Set.iInter fun i => ↑(S i))","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_iInf {ι : Sort*} {S : ι → Subgroup G} : (↑(⨅ i, S i) : Set G) = ⋂ i, S i := by\n  simp only [iInf, coe_sInf, Set.biInter_range]\n\n"}
{"name":"AddSubgroup.coe_iInf","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nι : Sort u_2\nS : ι → AddSubgroup G\n⊢ Eq (↑(iInf fun i => S i)) (Set.iInter fun i => ↑(S i))","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_iInf {ι : Sort*} {S : ι → Subgroup G} : (↑(⨅ i, S i) : Set G) = ⋂ i, S i := by\n  simp only [iInf, coe_sInf, Set.biInter_range]\n\n"}
{"name":"AddSubgroup.mem_sup_left","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nS T : AddSubgroup G\nx : G\na✝ : Membership.mem S x\n⊢ Membership.mem (Max.max S T) x","decl":"@[to_additive]\ntheorem mem_sup_left {S T : Subgroup G} : ∀ {x : G}, x ∈ S → x ∈ S ⊔ T :=\n  have : S ≤ S ⊔ T := le_sup_left; fun h ↦ this h\n\n"}
{"name":"Subgroup.mem_sup_left","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nS T : Subgroup G\nx : G\na✝ : Membership.mem S x\n⊢ Membership.mem (Max.max S T) x","decl":"@[to_additive]\ntheorem mem_sup_left {S T : Subgroup G} : ∀ {x : G}, x ∈ S → x ∈ S ⊔ T :=\n  have : S ≤ S ⊔ T := le_sup_left; fun h ↦ this h\n\n"}
{"name":"AddSubgroup.mem_sup_right","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nS T : AddSubgroup G\nx : G\na✝ : Membership.mem T x\n⊢ Membership.mem (Max.max S T) x","decl":"@[to_additive]\ntheorem mem_sup_right {S T : Subgroup G} : ∀ {x : G}, x ∈ T → x ∈ S ⊔ T :=\n  have : T ≤ S ⊔ T := le_sup_right; fun h ↦ this h\n\n"}
{"name":"Subgroup.mem_sup_right","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nS T : Subgroup G\nx : G\na✝ : Membership.mem T x\n⊢ Membership.mem (Max.max S T) x","decl":"@[to_additive]\ntheorem mem_sup_right {S T : Subgroup G} : ∀ {x : G}, x ∈ T → x ∈ S ⊔ T :=\n  have : T ≤ S ⊔ T := le_sup_right; fun h ↦ this h\n\n"}
{"name":"Subgroup.mul_mem_sup","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nS T : Subgroup G\nx y : G\nhx : Membership.mem S x\nhy : Membership.mem T y\n⊢ Membership.mem (Max.max S T) (HMul.hMul x y)","decl":"@[to_additive]\ntheorem mul_mem_sup {S T : Subgroup G} {x y : G} (hx : x ∈ S) (hy : y ∈ T) : x * y ∈ S ⊔ T :=\n  (S ⊔ T).mul_mem (mem_sup_left hx) (mem_sup_right hy)\n\n"}
{"name":"AddSubgroup.add_mem_sup","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nS T : AddSubgroup G\nx y : G\nhx : Membership.mem S x\nhy : Membership.mem T y\n⊢ Membership.mem (Max.max S T) (HAdd.hAdd x y)","decl":"@[to_additive]\ntheorem mul_mem_sup {S T : Subgroup G} {x y : G} (hx : x ∈ S) (hy : y ∈ T) : x * y ∈ S ⊔ T :=\n  (S ⊔ T).mul_mem (mem_sup_left hx) (mem_sup_right hy)\n\n"}
{"name":"AddSubgroup.mem_iSup_of_mem","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nι : Sort u_2\nS : ι → AddSubgroup G\ni : ι\nx : G\na✝ : Membership.mem (S i) x\n⊢ Membership.mem (iSup S) x","decl":"@[to_additive]\ntheorem mem_iSup_of_mem {ι : Sort*} {S : ι → Subgroup G} (i : ι) :\n    ∀ {x : G}, x ∈ S i → x ∈ iSup S :=\n  have : S i ≤ iSup S := le_iSup _ _; fun h ↦ this h\n\n"}
{"name":"Subgroup.mem_iSup_of_mem","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nι : Sort u_2\nS : ι → Subgroup G\ni : ι\nx : G\na✝ : Membership.mem (S i) x\n⊢ Membership.mem (iSup S) x","decl":"@[to_additive]\ntheorem mem_iSup_of_mem {ι : Sort*} {S : ι → Subgroup G} (i : ι) :\n    ∀ {x : G}, x ∈ S i → x ∈ iSup S :=\n  have : S i ≤ iSup S := le_iSup _ _; fun h ↦ this h\n\n"}
{"name":"Subgroup.mem_sSup_of_mem","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nS : Set (Subgroup G)\ns : Subgroup G\nhs : Membership.mem S s\nx : G\na✝ : Membership.mem s x\n⊢ Membership.mem (SupSet.sSup S) x","decl":"@[to_additive]\ntheorem mem_sSup_of_mem {S : Set (Subgroup G)} {s : Subgroup G} (hs : s ∈ S) :\n    ∀ {x : G}, x ∈ s → x ∈ sSup S :=\n  have : s ≤ sSup S := le_sSup hs; fun h ↦ this h\n\n"}
{"name":"AddSubgroup.mem_sSup_of_mem","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nS : Set (AddSubgroup G)\ns : AddSubgroup G\nhs : Membership.mem S s\nx : G\na✝ : Membership.mem s x\n⊢ Membership.mem (SupSet.sSup S) x","decl":"@[to_additive]\ntheorem mem_sSup_of_mem {S : Set (Subgroup G)} {s : Subgroup G} (hs : s ∈ S) :\n    ∀ {x : G}, x ∈ s → x ∈ sSup S :=\n  have : s ≤ sSup S := le_sSup hs; fun h ↦ this h\n\n"}
{"name":"Subgroup.subsingleton_iff","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Iff (Subsingleton (Subgroup G)) (Subsingleton G)","decl":"@[to_additive (attr := simp)]\ntheorem subsingleton_iff : Subsingleton (Subgroup G) ↔ Subsingleton G :=\n  ⟨fun _ =>\n    ⟨fun x y =>\n      have : ∀ i : G, i = 1 := fun i =>\n        mem_bot.mp <| Subsingleton.elim (⊤ : Subgroup G) ⊥ ▸ mem_top i\n      (this x).trans (this y).symm⟩,\n    fun _ => ⟨fun x y => Subgroup.ext fun i => Subsingleton.elim 1 i ▸ by simp [Subgroup.one_mem]⟩⟩\n\n"}
{"name":"AddSubgroup.subsingleton_iff","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\n⊢ Iff (Subsingleton (AddSubgroup G)) (Subsingleton G)","decl":"@[to_additive (attr := simp)]\ntheorem subsingleton_iff : Subsingleton (Subgroup G) ↔ Subsingleton G :=\n  ⟨fun _ =>\n    ⟨fun x y =>\n      have : ∀ i : G, i = 1 := fun i =>\n        mem_bot.mp <| Subsingleton.elim (⊤ : Subgroup G) ⊥ ▸ mem_top i\n      (this x).trans (this y).symm⟩,\n    fun _ => ⟨fun x y => Subgroup.ext fun i => Subsingleton.elim 1 i ▸ by simp [Subgroup.one_mem]⟩⟩\n\n"}
{"name":"AddSubgroup.nontrivial_iff","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\n⊢ Iff (Nontrivial (AddSubgroup G)) (Nontrivial G)","decl":"@[to_additive (attr := simp)]\ntheorem nontrivial_iff : Nontrivial (Subgroup G) ↔ Nontrivial G :=\n  not_iff_not.mp\n    ((not_nontrivial_iff_subsingleton.trans subsingleton_iff).trans\n      not_nontrivial_iff_subsingleton.symm)\n\n"}
{"name":"Subgroup.nontrivial_iff","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Iff (Nontrivial (Subgroup G)) (Nontrivial G)","decl":"@[to_additive (attr := simp)]\ntheorem nontrivial_iff : Nontrivial (Subgroup G) ↔ Nontrivial G :=\n  not_iff_not.mp\n    ((not_nontrivial_iff_subsingleton.trans subsingleton_iff).trans\n      not_nontrivial_iff_subsingleton.symm)\n\n"}
{"name":"Subgroup.instNontrivial","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : Nontrivial G\n⊢ Nontrivial (Subgroup G)","decl":"@[to_additive]\ninstance [Nontrivial G] : Nontrivial (Subgroup G) :=\n  nontrivial_iff.mpr ‹_›\n\n"}
{"name":"AddSubgroup.instNontrivial","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\ninst✝ : Nontrivial G\n⊢ Nontrivial (AddSubgroup G)","decl":"@[to_additive]\ninstance [Nontrivial G] : Nontrivial (Subgroup G) :=\n  nontrivial_iff.mpr ‹_›\n\n"}
{"name":"AddSubgroup.eq_top_iff'","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Iff (Eq H Top.top) (∀ (x : G), Membership.mem H x)","decl":"@[to_additive]\ntheorem eq_top_iff' : H = ⊤ ↔ ∀ x : G, x ∈ H :=\n  eq_top_iff.trans ⟨fun h m => h <| mem_top m, fun h m _ => h m⟩\n\n"}
{"name":"Subgroup.eq_top_iff'","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Iff (Eq H Top.top) (∀ (x : G), Membership.mem H x)","decl":"@[to_additive]\ntheorem eq_top_iff' : H = ⊤ ↔ ∀ x : G, x ∈ H :=\n  eq_top_iff.trans ⟨fun h m => h <| mem_top m, fun h m _ => h m⟩\n\n"}
{"name":"AddSubgroup.mem_closure","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nk : Set G\nx : G\n⊢ Iff (Membership.mem (AddSubgroup.closure k) x) (∀ (K : AddSubgroup G), HasSubset.Subset k ↑K → Membership.mem K x)","decl":"@[to_additive]\ntheorem mem_closure {x : G} : x ∈ closure k ↔ ∀ K : Subgroup G, k ⊆ K → x ∈ K :=\n  mem_sInf\n\n"}
{"name":"Subgroup.mem_closure","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nk : Set G\nx : G\n⊢ Iff (Membership.mem (Subgroup.closure k) x) (∀ (K : Subgroup G), HasSubset.Subset k ↑K → Membership.mem K x)","decl":"@[to_additive]\ntheorem mem_closure {x : G} : x ∈ closure k ↔ ∀ K : Subgroup G, k ⊆ K → x ∈ K :=\n  mem_sInf\n\n"}
{"name":"AddSubgroup.subset_closure","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nk : Set G\n⊢ HasSubset.Subset k ↑(AddSubgroup.closure k)","decl":"/-- The subgroup generated by a set includes the set. -/\n@[to_additive (attr := simp, aesop safe 20 apply (rule_sets := [SetLike]))\n  \"The `AddSubgroup` generated by a set includes the set.\"]\ntheorem subset_closure : k ⊆ closure k := fun _ hx => mem_closure.2 fun _ hK => hK hx\n\n"}
{"name":"Subgroup.subset_closure","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nk : Set G\n⊢ HasSubset.Subset k ↑(Subgroup.closure k)","decl":"/-- The subgroup generated by a set includes the set. -/\n@[to_additive (attr := simp, aesop safe 20 apply (rule_sets := [SetLike]))\n  \"The `AddSubgroup` generated by a set includes the set.\"]\ntheorem subset_closure : k ⊆ closure k := fun _ hx => mem_closure.2 fun _ hK => hK hx\n\n"}
{"name":"AddSubgroup.not_mem_of_not_mem_closure","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nk : Set G\nP : G\nhP : Not (Membership.mem (AddSubgroup.closure k) P)\n⊢ Not (Membership.mem k P)","decl":"@[to_additive]\ntheorem not_mem_of_not_mem_closure {P : G} (hP : P ∉ closure k) : P ∉ k := fun h =>\n  hP (subset_closure h)\n\n"}
{"name":"Subgroup.not_mem_of_not_mem_closure","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nk : Set G\nP : G\nhP : Not (Membership.mem (Subgroup.closure k) P)\n⊢ Not (Membership.mem k P)","decl":"@[to_additive]\ntheorem not_mem_of_not_mem_closure {P : G} (hP : P ∉ closure k) : P ∉ k := fun h =>\n  hP (subset_closure h)\n\n"}
{"name":"AddSubgroup.closure_le","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nK : AddSubgroup G\nk : Set G\n⊢ Iff (LE.le (AddSubgroup.closure k) K) (HasSubset.Subset k ↑K)","decl":"/-- A subgroup `K` includes `closure k` if and only if it includes `k`. -/\n@[to_additive (attr := simp)\n  \"An additive subgroup `K` includes `closure k` if and only if it includes `k`\"]\ntheorem closure_le : closure k ≤ K ↔ k ⊆ K :=\n  ⟨Subset.trans subset_closure, fun h => sInf_le h⟩\n\n"}
{"name":"Subgroup.closure_le","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nK : Subgroup G\nk : Set G\n⊢ Iff (LE.le (Subgroup.closure k) K) (HasSubset.Subset k ↑K)","decl":"/-- A subgroup `K` includes `closure k` if and only if it includes `k`. -/\n@[to_additive (attr := simp)\n  \"An additive subgroup `K` includes `closure k` if and only if it includes `k`\"]\ntheorem closure_le : closure k ≤ K ↔ k ⊆ K :=\n  ⟨Subset.trans subset_closure, fun h => sInf_le h⟩\n\n"}
{"name":"Subgroup.closure_eq_of_le","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nK : Subgroup G\nk : Set G\nh₁ : HasSubset.Subset k ↑K\nh₂ : LE.le K (Subgroup.closure k)\n⊢ Eq (Subgroup.closure k) K","decl":"@[to_additive]\ntheorem closure_eq_of_le (h₁ : k ⊆ K) (h₂ : K ≤ closure k) : closure k = K :=\n  le_antisymm ((closure_le <| K).2 h₁) h₂\n\n"}
{"name":"AddSubgroup.closure_eq_of_le","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nK : AddSubgroup G\nk : Set G\nh₁ : HasSubset.Subset k ↑K\nh₂ : LE.le K (AddSubgroup.closure k)\n⊢ Eq (AddSubgroup.closure k) K","decl":"@[to_additive]\ntheorem closure_eq_of_le (h₁ : k ⊆ K) (h₂ : K ≤ closure k) : closure k = K :=\n  le_antisymm ((closure_le <| K).2 h₁) h₂\n\n"}
{"name":"Subgroup.closure_induction","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nk : Set G\np : (g : G) → Membership.mem (Subgroup.closure k) g → Prop\nmem : ∀ (x : G) (hx : Membership.mem k x), p x ⋯\none : p 1 ⋯\nmul : ∀ (x y : G) (hx : Membership.mem (Subgroup.closure k) x) (hy : Membership.mem (Subgroup.closure k) y), p x hx → p y hy → p (HMul.hMul x y) ⋯\ninv : ∀ (x : G) (hx : Membership.mem (Subgroup.closure k) x), p x hx → p (Inv.inv x) ⋯\nx : G\nhx : Membership.mem (Subgroup.closure k) x\n⊢ p x hx","decl":"/-- An induction principle for closure membership. If `p` holds for `1` and all elements of `k`, and\nis preserved under multiplication and inverse, then `p` holds for all elements of the closure\nof `k`.\n\nSee also `Subgroup.closure_induction_left` and `Subgroup.closure_induction_right` for versions that\nonly require showing `p` is preserved by multiplication by elements in `k`. -/\n@[to_additive (attr := elab_as_elim)\n      \"An induction principle for additive closure membership. If `p`\n      holds for `0` and all elements of `k`, and is preserved under addition and inverses, then `p`\n      holds for all elements of the additive closure of `k`.\n\n      See also `AddSubgroup.closure_induction_left` and `AddSubgroup.closure_induction_left` for\n      versions that only require showing `p` is preserved by addition by elements in `k`.\"]\ntheorem closure_induction {p : (g : G) → g ∈ closure k → Prop}\n    (mem : ∀ x (hx : x ∈ k), p x (subset_closure hx)) (one : p 1 (one_mem _))\n    (mul : ∀ x y hx hy, p x hx → p y hy → p (x * y) (mul_mem hx hy))\n    (inv : ∀ x hx, p x hx → p x⁻¹ (inv_mem hx)) {x} (hx : x ∈ closure k) : p x hx :=\n  let K : Subgroup G :=\n    { carrier := { x | ∃ hx, p x hx }\n      mul_mem' := fun ⟨_, ha⟩ ⟨_, hb⟩ ↦ ⟨_, mul _ _ _ _ ha hb⟩\n      one_mem' := ⟨_, one⟩\n      inv_mem' := fun ⟨_, hb⟩ ↦ ⟨_, inv _ _ hb⟩ }\n  closure_le (K := K) |>.mpr (fun y hy ↦ ⟨subset_closure hy, mem y hy⟩) hx |>.elim fun _ ↦ id\n\n"}
{"name":"AddSubgroup.closure_induction","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nk : Set G\np : (g : G) → Membership.mem (AddSubgroup.closure k) g → Prop\nmem : ∀ (x : G) (hx : Membership.mem k x), p x ⋯\none : p 0 ⋯\nmul : ∀ (x y : G) (hx : Membership.mem (AddSubgroup.closure k) x) (hy : Membership.mem (AddSubgroup.closure k) y), p x hx → p y hy → p (HAdd.hAdd x y) ⋯\ninv : ∀ (x : G) (hx : Membership.mem (AddSubgroup.closure k) x), p x hx → p (Neg.neg x) ⋯\nx : G\nhx : Membership.mem (AddSubgroup.closure k) x\n⊢ p x hx","decl":"/-- An induction principle for closure membership. If `p` holds for `1` and all elements of `k`, and\nis preserved under multiplication and inverse, then `p` holds for all elements of the closure\nof `k`.\n\nSee also `Subgroup.closure_induction_left` and `Subgroup.closure_induction_right` for versions that\nonly require showing `p` is preserved by multiplication by elements in `k`. -/\n@[to_additive (attr := elab_as_elim)\n      \"An induction principle for additive closure membership. If `p`\n      holds for `0` and all elements of `k`, and is preserved under addition and inverses, then `p`\n      holds for all elements of the additive closure of `k`.\n\n      See also `AddSubgroup.closure_induction_left` and `AddSubgroup.closure_induction_left` for\n      versions that only require showing `p` is preserved by addition by elements in `k`.\"]\ntheorem closure_induction {p : (g : G) → g ∈ closure k → Prop}\n    (mem : ∀ x (hx : x ∈ k), p x (subset_closure hx)) (one : p 1 (one_mem _))\n    (mul : ∀ x y hx hy, p x hx → p y hy → p (x * y) (mul_mem hx hy))\n    (inv : ∀ x hx, p x hx → p x⁻¹ (inv_mem hx)) {x} (hx : x ∈ closure k) : p x hx :=\n  let K : Subgroup G :=\n    { carrier := { x | ∃ hx, p x hx }\n      mul_mem' := fun ⟨_, ha⟩ ⟨_, hb⟩ ↦ ⟨_, mul _ _ _ _ ha hb⟩\n      one_mem' := ⟨_, one⟩\n      inv_mem' := fun ⟨_, hb⟩ ↦ ⟨_, inv _ _ hb⟩ }\n  closure_le (K := K) |>.mpr (fun y hy ↦ ⟨subset_closure hy, mem y hy⟩) hx |>.elim fun _ ↦ id\n\n"}
{"name":"Subgroup.closure_induction'","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nk : Set G\np : (g : G) → Membership.mem (Subgroup.closure k) g → Prop\nmem : ∀ (x : G) (hx : Membership.mem k x), p x ⋯\none : p 1 ⋯\nmul : ∀ (x y : G) (hx : Membership.mem (Subgroup.closure k) x) (hy : Membership.mem (Subgroup.closure k) y), p x hx → p y hy → p (HMul.hMul x y) ⋯\ninv : ∀ (x : G) (hx : Membership.mem (Subgroup.closure k) x), p x hx → p (Inv.inv x) ⋯\nx : G\nhx : Membership.mem (Subgroup.closure k) x\n⊢ p x hx","decl":"@[deprecated closure_induction (since := \"2024-10-10\")]\nalias closure_induction' := closure_induction\n\n"}
{"name":"Subgroup.closure_induction₂","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nk : Set G\np : (x y : G) → Membership.mem (Subgroup.closure k) x → Membership.mem (Subgroup.closure k) y → Prop\nmem : ∀ (x y : G) (hx : Membership.mem k x) (hy : Membership.mem k y), p x y ⋯ ⋯\none_left : ∀ (x : G) (hx : Membership.mem (Subgroup.closure k) x), p 1 x ⋯ hx\none_right : ∀ (x : G) (hx : Membership.mem (Subgroup.closure k) x), p x 1 hx ⋯\nmul_left : ∀ (x y z : G) (hx : Membership.mem (Subgroup.closure k) x) (hy : Membership.mem (Subgroup.closure k) y) (hz : Membership.mem (Subgroup.closure k) z), p x z hx hz → p y z hy hz → p (HMul.hMul x y) z ⋯ hz\nmul_right : ∀ (y z x : G) (hy : Membership.mem (Subgroup.closure k) y) (hz : Membership.mem (Subgroup.closure k) z) (hx : Membership.mem (Subgroup.closure k) x), p x y hx hy → p x z hx hz → p x (HMul.hMul y z) hx ⋯\ninv_left : ∀ (x y : G) (hx : Membership.mem (Subgroup.closure k) x) (hy : Membership.mem (Subgroup.closure k) y), p x y hx hy → p (Inv.inv x) y ⋯ hy\ninv_right : ∀ (x y : G) (hx : Membership.mem (Subgroup.closure k) x) (hy : Membership.mem (Subgroup.closure k) y), p x y hx hy → p x (Inv.inv y) hx ⋯\nx y : G\nhx : Membership.mem (Subgroup.closure k) x\nhy : Membership.mem (Subgroup.closure k) y\n⊢ p x y hx hy","decl":"/-- An induction principle for closure membership for predicates with two arguments. -/\n@[to_additive (attr := elab_as_elim)\n      \"An induction principle for additive closure membership, for\n      predicates with two arguments.\"]\ntheorem closure_induction₂ {p : (x y : G) → x ∈ closure k → y ∈ closure k → Prop}\n    (mem : ∀ (x) (y) (hx : x ∈ k) (hy : y ∈ k), p x y (subset_closure hx) (subset_closure hy))\n    (one_left : ∀ x hx, p 1 x (one_mem _) hx) (one_right : ∀ x hx, p x 1 hx (one_mem _))\n    (mul_left : ∀ x y z hx hy hz, p x z hx hz → p y z hy hz → p (x * y) z (mul_mem hx hy) hz)\n    (mul_right : ∀ y z x hy hz hx, p x y hx hy → p x z hx hz → p x (y * z) hx (mul_mem hy hz))\n    (inv_left : ∀ x y hx hy, p x y hx hy → p x⁻¹ y (inv_mem hx) hy)\n    (inv_right : ∀ x y hx hy, p x y hx hy → p x y⁻¹ hx (inv_mem hy))\n    {x y : G} (hx : x ∈ closure k) (hy : y ∈ closure k) : p x y hx hy := by\n  induction hy using closure_induction with\n  | mem z hz => induction hx using closure_induction with\n    | mem _ h => exact mem _ _ h hz\n    | one => exact one_left _ (subset_closure hz)\n    | mul _ _ _ _ h₁ h₂ => exact mul_left _ _ _ _ _ _ h₁ h₂\n    | inv _ _ h => exact inv_left _ _ _ _ h\n  | one => exact one_right x hx\n  | mul _ _ _ _ h₁ h₂ => exact mul_right _ _ _ _ _ hx h₁ h₂\n  | inv _ _ h => exact inv_right _ _ _ _ h\n\n"}
{"name":"AddSubgroup.closure_induction₂","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nk : Set G\np : (x y : G) → Membership.mem (AddSubgroup.closure k) x → Membership.mem (AddSubgroup.closure k) y → Prop\nmem : ∀ (x y : G) (hx : Membership.mem k x) (hy : Membership.mem k y), p x y ⋯ ⋯\none_left : ∀ (x : G) (hx : Membership.mem (AddSubgroup.closure k) x), p 0 x ⋯ hx\none_right : ∀ (x : G) (hx : Membership.mem (AddSubgroup.closure k) x), p x 0 hx ⋯\nmul_left : ∀ (x y z : G) (hx : Membership.mem (AddSubgroup.closure k) x) (hy : Membership.mem (AddSubgroup.closure k) y) (hz : Membership.mem (AddSubgroup.closure k) z), p x z hx hz → p y z hy hz → p (HAdd.hAdd x y) z ⋯ hz\nmul_right : ∀ (y z x : G) (hy : Membership.mem (AddSubgroup.closure k) y) (hz : Membership.mem (AddSubgroup.closure k) z) (hx : Membership.mem (AddSubgroup.closure k) x), p x y hx hy → p x z hx hz → p x (HAdd.hAdd y z) hx ⋯\ninv_left : ∀ (x y : G) (hx : Membership.mem (AddSubgroup.closure k) x) (hy : Membership.mem (AddSubgroup.closure k) y), p x y hx hy → p (Neg.neg x) y ⋯ hy\ninv_right : ∀ (x y : G) (hx : Membership.mem (AddSubgroup.closure k) x) (hy : Membership.mem (AddSubgroup.closure k) y), p x y hx hy → p x (Neg.neg y) hx ⋯\nx y : G\nhx : Membership.mem (AddSubgroup.closure k) x\nhy : Membership.mem (AddSubgroup.closure k) y\n⊢ p x y hx hy","decl":"/-- An induction principle for closure membership for predicates with two arguments. -/\n@[to_additive (attr := elab_as_elim)\n      \"An induction principle for additive closure membership, for\n      predicates with two arguments.\"]\ntheorem closure_induction₂ {p : (x y : G) → x ∈ closure k → y ∈ closure k → Prop}\n    (mem : ∀ (x) (y) (hx : x ∈ k) (hy : y ∈ k), p x y (subset_closure hx) (subset_closure hy))\n    (one_left : ∀ x hx, p 1 x (one_mem _) hx) (one_right : ∀ x hx, p x 1 hx (one_mem _))\n    (mul_left : ∀ x y z hx hy hz, p x z hx hz → p y z hy hz → p (x * y) z (mul_mem hx hy) hz)\n    (mul_right : ∀ y z x hy hz hx, p x y hx hy → p x z hx hz → p x (y * z) hx (mul_mem hy hz))\n    (inv_left : ∀ x y hx hy, p x y hx hy → p x⁻¹ y (inv_mem hx) hy)\n    (inv_right : ∀ x y hx hy, p x y hx hy → p x y⁻¹ hx (inv_mem hy))\n    {x y : G} (hx : x ∈ closure k) (hy : y ∈ closure k) : p x y hx hy := by\n  induction hy using closure_induction with\n  | mem z hz => induction hx using closure_induction with\n    | mem _ h => exact mem _ _ h hz\n    | one => exact one_left _ (subset_closure hz)\n    | mul _ _ _ _ h₁ h₂ => exact mul_left _ _ _ _ _ _ h₁ h₂\n    | inv _ _ h => exact inv_left _ _ _ _ h\n  | one => exact one_right x hx\n  | mul _ _ _ _ h₁ h₂ => exact mul_right _ _ _ _ _ hx h₁ h₂\n  | inv _ _ h => exact inv_right _ _ _ _ h\n\n"}
{"name":"Subgroup.closure_closure_coe_preimage","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nk : Set G\n⊢ Eq (Subgroup.closure (Set.preimage Subtype.val k)) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem closure_closure_coe_preimage {k : Set G} : closure (((↑) : closure k → G) ⁻¹' k) = ⊤ :=\n  eq_top_iff.2 fun x _ ↦ Subtype.recOn x fun _ hx' ↦\n    closure_induction (fun _ h ↦ subset_closure h) (one_mem _) (fun _ _ _ _ ↦ mul_mem)\n      (fun _ _ ↦ inv_mem) hx'\n\n"}
{"name":"AddSubgroup.closure_closure_coe_preimage","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nk : Set G\n⊢ Eq (AddSubgroup.closure (Set.preimage Subtype.val k)) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem closure_closure_coe_preimage {k : Set G} : closure (((↑) : closure k → G) ⁻¹' k) = ⊤ :=\n  eq_top_iff.2 fun x _ ↦ Subtype.recOn x fun _ hx' ↦\n    closure_induction (fun _ h ↦ subset_closure h) (one_mem _) (fun _ _ _ _ ↦ mul_mem)\n      (fun _ _ ↦ inv_mem) hx'\n\n"}
{"name":"AddSubgroup.closure_mono","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nh k : Set G\nh' : HasSubset.Subset h k\n⊢ LE.le (AddSubgroup.closure h) (AddSubgroup.closure k)","decl":"/-- Subgroup closure of a set is monotone in its argument: if `h ⊆ k`,\nthen `closure h ≤ closure k`. -/\n@[to_additive (attr := gcongr)\n      \"Additive subgroup closure of a set is monotone in its argument: if `h ⊆ k`,\n      then `closure h ≤ closure k`\"]\ntheorem closure_mono ⦃h k : Set G⦄ (h' : h ⊆ k) : closure h ≤ closure k :=\n  (Subgroup.gi G).gc.monotone_l h'\n\n"}
{"name":"Subgroup.closure_mono","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nh k : Set G\nh' : HasSubset.Subset h k\n⊢ LE.le (Subgroup.closure h) (Subgroup.closure k)","decl":"/-- Subgroup closure of a set is monotone in its argument: if `h ⊆ k`,\nthen `closure h ≤ closure k`. -/\n@[to_additive (attr := gcongr)\n      \"Additive subgroup closure of a set is monotone in its argument: if `h ⊆ k`,\n      then `closure h ≤ closure k`\"]\ntheorem closure_mono ⦃h k : Set G⦄ (h' : h ⊆ k) : closure h ≤ closure k :=\n  (Subgroup.gi G).gc.monotone_l h'\n\n"}
{"name":"AddSubgroup.closure_eq","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nK : AddSubgroup G\n⊢ Eq (AddSubgroup.closure ↑K) K","decl":"/-- Closure of a subgroup `K` equals `K`. -/\n@[to_additive (attr := simp) \"Additive closure of an additive subgroup `K` equals `K`\"]\ntheorem closure_eq : closure (K : Set G) = K :=\n  (Subgroup.gi G).l_u_eq K\n\n"}
{"name":"Subgroup.closure_eq","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nK : Subgroup G\n⊢ Eq (Subgroup.closure ↑K) K","decl":"/-- Closure of a subgroup `K` equals `K`. -/\n@[to_additive (attr := simp) \"Additive closure of an additive subgroup `K` equals `K`\"]\ntheorem closure_eq : closure (K : Set G) = K :=\n  (Subgroup.gi G).l_u_eq K\n\n"}
{"name":"Subgroup.closure_empty","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Eq (Subgroup.closure EmptyCollection.emptyCollection) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem closure_empty : closure (∅ : Set G) = ⊥ :=\n  (Subgroup.gi G).gc.l_bot\n\n"}
{"name":"AddSubgroup.closure_empty","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\n⊢ Eq (AddSubgroup.closure EmptyCollection.emptyCollection) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem closure_empty : closure (∅ : Set G) = ⊥ :=\n  (Subgroup.gi G).gc.l_bot\n\n"}
{"name":"AddSubgroup.closure_univ","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\n⊢ Eq (AddSubgroup.closure Set.univ) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem closure_univ : closure (univ : Set G) = ⊤ :=\n  @coe_top G _ ▸ closure_eq ⊤\n\n"}
{"name":"Subgroup.closure_univ","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Eq (Subgroup.closure Set.univ) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem closure_univ : closure (univ : Set G) = ⊤ :=\n  @coe_top G _ ▸ closure_eq ⊤\n\n"}
{"name":"Subgroup.closure_union","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\ns t : Set G\n⊢ Eq (Subgroup.closure (Union.union s t)) (Max.max (Subgroup.closure s) (Subgroup.closure t))","decl":"@[to_additive]\ntheorem closure_union (s t : Set G) : closure (s ∪ t) = closure s ⊔ closure t :=\n  (Subgroup.gi G).gc.l_sup\n\n"}
{"name":"AddSubgroup.closure_union","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\ns t : Set G\n⊢ Eq (AddSubgroup.closure (Union.union s t)) (Max.max (AddSubgroup.closure s) (AddSubgroup.closure t))","decl":"@[to_additive]\ntheorem closure_union (s t : Set G) : closure (s ∪ t) = closure s ⊔ closure t :=\n  (Subgroup.gi G).gc.l_sup\n\n"}
{"name":"AddSubgroup.sup_eq_closure","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH H' : AddSubgroup G\n⊢ Eq (Max.max H H') (AddSubgroup.closure (Union.union ↑H ↑H'))","decl":"@[to_additive]\ntheorem sup_eq_closure (H H' : Subgroup G) : H ⊔ H' = closure ((H : Set G) ∪ (H' : Set G)) := by\n  simp_rw [closure_union, closure_eq]\n\n"}
{"name":"Subgroup.sup_eq_closure","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nH H' : Subgroup G\n⊢ Eq (Max.max H H') (Subgroup.closure (Union.union ↑H ↑H'))","decl":"@[to_additive]\ntheorem sup_eq_closure (H H' : Subgroup G) : H ⊔ H' = closure ((H : Set G) ∪ (H' : Set G)) := by\n  simp_rw [closure_union, closure_eq]\n\n"}
{"name":"AddSubgroup.closure_iUnion","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nι : Sort u_2\ns : ι → Set G\n⊢ Eq (AddSubgroup.closure (Set.iUnion fun i => s i)) (iSup fun i => AddSubgroup.closure (s i))","decl":"@[to_additive]\ntheorem closure_iUnion {ι} (s : ι → Set G) : closure (⋃ i, s i) = ⨆ i, closure (s i) :=\n  (Subgroup.gi G).gc.l_iSup\n\n"}
{"name":"Subgroup.closure_iUnion","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nι : Sort u_2\ns : ι → Set G\n⊢ Eq (Subgroup.closure (Set.iUnion fun i => s i)) (iSup fun i => Subgroup.closure (s i))","decl":"@[to_additive]\ntheorem closure_iUnion {ι} (s : ι → Set G) : closure (⋃ i, s i) = ⨆ i, closure (s i) :=\n  (Subgroup.gi G).gc.l_iSup\n\n"}
{"name":"AddSubgroup.closure_eq_bot_iff","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nk : Set G\n⊢ Iff (Eq (AddSubgroup.closure k) Bot.bot) (HasSubset.Subset k (Singleton.singleton 0))","decl":"@[to_additive (attr := simp)]\ntheorem closure_eq_bot_iff : closure k = ⊥ ↔ k ⊆ {1} := le_bot_iff.symm.trans <| closure_le _\n\n"}
{"name":"Subgroup.closure_eq_bot_iff","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nk : Set G\n⊢ Iff (Eq (Subgroup.closure k) Bot.bot) (HasSubset.Subset k (Singleton.singleton 1))","decl":"@[to_additive (attr := simp)]\ntheorem closure_eq_bot_iff : closure k = ⊥ ↔ k ⊆ {1} := le_bot_iff.symm.trans <| closure_le _\n\n"}
{"name":"AddSubgroup.iSup_eq_closure","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nι : Sort u_2\np : ι → AddSubgroup G\n⊢ Eq (iSup fun i => p i) (AddSubgroup.closure (Set.iUnion fun i => ↑(p i)))","decl":"@[to_additive]\ntheorem iSup_eq_closure {ι : Sort*} (p : ι → Subgroup G) :\n    ⨆ i, p i = closure (⋃ i, (p i : Set G)) := by simp_rw [closure_iUnion, closure_eq]\n\n"}
{"name":"Subgroup.iSup_eq_closure","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nι : Sort u_2\np : ι → Subgroup G\n⊢ Eq (iSup fun i => p i) (Subgroup.closure (Set.iUnion fun i => ↑(p i)))","decl":"@[to_additive]\ntheorem iSup_eq_closure {ι : Sort*} (p : ι → Subgroup G) :\n    ⨆ i, p i = closure (⋃ i, (p i : Set G)) := by simp_rw [closure_iUnion, closure_eq]\n\n"}
{"name":"Subgroup.mem_closure_singleton","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nx y : G\n⊢ Iff (Membership.mem (Subgroup.closure (Singleton.singleton x)) y) (Exists fun n => Eq (HPow.hPow x n) y)","decl":"/-- The subgroup generated by an element of a group equals the set of integer number powers of\n    the element. -/\n@[to_additive\n      \"The `AddSubgroup` generated by an element of an `AddGroup` equals the set of\n      natural number multiples of the element.\"]\ntheorem mem_closure_singleton {x y : G} : y ∈ closure ({x} : Set G) ↔ ∃ n : ℤ, x ^ n = y := by\n  refine\n    ⟨fun hy => closure_induction ?_ ?_ ?_ ?_ hy, fun ⟨n, hn⟩ =>\n      hn ▸ zpow_mem (subset_closure <| mem_singleton x) n⟩\n  · intro y hy\n    rw [eq_of_mem_singleton hy]\n    exact ⟨1, zpow_one x⟩\n  · exact ⟨0, zpow_zero x⟩\n  · rintro _ _ _ _ ⟨n, rfl⟩ ⟨m, rfl⟩\n    exact ⟨n + m, zpow_add x n m⟩\n  rintro _ _ ⟨n, rfl⟩\n  exact ⟨-n, zpow_neg x n⟩\n\n"}
{"name":"AddSubgroup.mem_closure_singleton","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nx y : G\n⊢ Iff (Membership.mem (AddSubgroup.closure (Singleton.singleton x)) y) (Exists fun n => Eq (HSMul.hSMul n x) y)","decl":"/-- The subgroup generated by an element of a group equals the set of integer number powers of\n    the element. -/\n@[to_additive\n      \"The `AddSubgroup` generated by an element of an `AddGroup` equals the set of\n      natural number multiples of the element.\"]\ntheorem mem_closure_singleton {x y : G} : y ∈ closure ({x} : Set G) ↔ ∃ n : ℤ, x ^ n = y := by\n  refine\n    ⟨fun hy => closure_induction ?_ ?_ ?_ ?_ hy, fun ⟨n, hn⟩ =>\n      hn ▸ zpow_mem (subset_closure <| mem_singleton x) n⟩\n  · intro y hy\n    rw [eq_of_mem_singleton hy]\n    exact ⟨1, zpow_one x⟩\n  · exact ⟨0, zpow_zero x⟩\n  · rintro _ _ _ _ ⟨n, rfl⟩ ⟨m, rfl⟩\n    exact ⟨n + m, zpow_add x n m⟩\n  rintro _ _ ⟨n, rfl⟩\n  exact ⟨-n, zpow_neg x n⟩\n\n"}
{"name":"Subgroup.closure_singleton_one","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Eq (Subgroup.closure (Singleton.singleton 1)) Bot.bot","decl":"@[to_additive]\ntheorem closure_singleton_one : closure ({1} : Set G) = ⊥ := by\n  simp [eq_bot_iff_forall, mem_closure_singleton]\n\n"}
{"name":"AddSubgroup.closure_singleton_zero","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\n⊢ Eq (AddSubgroup.closure (Singleton.singleton 0)) Bot.bot","decl":"@[to_additive]\ntheorem closure_singleton_one : closure ({1} : Set G) = ⊥ := by\n  simp [eq_bot_iff_forall, mem_closure_singleton]\n\n"}
{"name":"AddSubgroup.mem_closure_singleton_self","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nx : G\n⊢ Membership.mem (AddSubgroup.closure (Singleton.singleton x)) x","decl":"@[to_additive (attr := simp)]\nlemma mem_closure_singleton_self (x : G) : x ∈ closure ({x} : Set G) := by\n  simpa [-subset_closure] using subset_closure (k := {x})\n\n"}
{"name":"Subgroup.mem_closure_singleton_self","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nx : G\n⊢ Membership.mem (Subgroup.closure (Singleton.singleton x)) x","decl":"@[to_additive (attr := simp)]\nlemma mem_closure_singleton_self (x : G) : x ∈ closure ({x} : Set G) := by\n  simpa [-subset_closure] using subset_closure (k := {x})\n\n"}
{"name":"Subgroup.le_closure_toSubmonoid","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nS : Set G\n⊢ LE.le (Submonoid.closure S) (Subgroup.closure S).toSubmonoid","decl":"@[to_additive]\ntheorem le_closure_toSubmonoid (S : Set G) : Submonoid.closure S ≤ (closure S).toSubmonoid :=\n  Submonoid.closure_le.2 subset_closure\n\n"}
{"name":"AddSubgroup.le_closure_toAddSubmonoid","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nS : Set G\n⊢ LE.le (AddSubmonoid.closure S) (AddSubgroup.closure S).toAddSubmonoid","decl":"@[to_additive]\ntheorem le_closure_toSubmonoid (S : Set G) : Submonoid.closure S ≤ (closure S).toSubmonoid :=\n  Submonoid.closure_le.2 subset_closure\n\n"}
{"name":"AddSubgroup.closure_eq_top_of_mclosure_eq_top","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nS : Set G\nh : Eq (AddSubmonoid.closure S) Top.top\n⊢ Eq (AddSubgroup.closure S) Top.top","decl":"@[to_additive]\ntheorem closure_eq_top_of_mclosure_eq_top {S : Set G} (h : Submonoid.closure S = ⊤) :\n    closure S = ⊤ :=\n  (eq_top_iff' _).2 fun _ => le_closure_toSubmonoid _ <| h.symm ▸ trivial\n\n"}
{"name":"Subgroup.closure_eq_top_of_mclosure_eq_top","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nS : Set G\nh : Eq (Submonoid.closure S) Top.top\n⊢ Eq (Subgroup.closure S) Top.top","decl":"@[to_additive]\ntheorem closure_eq_top_of_mclosure_eq_top {S : Set G} (h : Submonoid.closure S = ⊤) :\n    closure S = ⊤ :=\n  (eq_top_iff' _).2 fun _ => le_closure_toSubmonoid _ <| h.symm ▸ trivial\n\n"}
{"name":"AddSubgroup.mem_iSup_of_directed","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nι : Sort u_2\nhι : Nonempty ι\nK : ι → AddSubgroup G\nhK : Directed (fun x1 x2 => LE.le x1 x2) K\nx : G\n⊢ Iff (Membership.mem (iSup K) x) (Exists fun i => Membership.mem (K i) x)","decl":"@[to_additive]\ntheorem mem_iSup_of_directed {ι} [hι : Nonempty ι] {K : ι → Subgroup G} (hK : Directed (· ≤ ·) K)\n    {x : G} : x ∈ (iSup K : Subgroup G) ↔ ∃ i, x ∈ K i := by\n  refine ⟨?_, fun ⟨i, hi⟩ ↦ le_iSup K i hi⟩\n  suffices x ∈ closure (⋃ i, (K i : Set G)) → ∃ i, x ∈ K i by\n    simpa only [closure_iUnion, closure_eq (K _)] using this\n  refine fun hx ↦ closure_induction (fun _ ↦ mem_iUnion.1) ?_ ?_ ?_ hx\n  · exact hι.elim fun i ↦ ⟨i, (K i).one_mem⟩\n  · rintro x y _ _ ⟨i, hi⟩ ⟨j, hj⟩\n    rcases hK i j with ⟨k, hki, hkj⟩\n    exact ⟨k, mul_mem (hki hi) (hkj hj)⟩\n  · rintro _ _ ⟨i, hi⟩\n    exact ⟨i, inv_mem hi⟩\n\n"}
{"name":"Subgroup.mem_iSup_of_directed","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nι : Sort u_2\nhι : Nonempty ι\nK : ι → Subgroup G\nhK : Directed (fun x1 x2 => LE.le x1 x2) K\nx : G\n⊢ Iff (Membership.mem (iSup K) x) (Exists fun i => Membership.mem (K i) x)","decl":"@[to_additive]\ntheorem mem_iSup_of_directed {ι} [hι : Nonempty ι] {K : ι → Subgroup G} (hK : Directed (· ≤ ·) K)\n    {x : G} : x ∈ (iSup K : Subgroup G) ↔ ∃ i, x ∈ K i := by\n  refine ⟨?_, fun ⟨i, hi⟩ ↦ le_iSup K i hi⟩\n  suffices x ∈ closure (⋃ i, (K i : Set G)) → ∃ i, x ∈ K i by\n    simpa only [closure_iUnion, closure_eq (K _)] using this\n  refine fun hx ↦ closure_induction (fun _ ↦ mem_iUnion.1) ?_ ?_ ?_ hx\n  · exact hι.elim fun i ↦ ⟨i, (K i).one_mem⟩\n  · rintro x y _ _ ⟨i, hi⟩ ⟨j, hj⟩\n    rcases hK i j with ⟨k, hki, hkj⟩\n    exact ⟨k, mul_mem (hki hi) (hkj hj)⟩\n  · rintro _ _ ⟨i, hi⟩\n    exact ⟨i, inv_mem hi⟩\n\n"}
{"name":"AddSubgroup.coe_iSup_of_directed","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nι : Sort u_2\ninst✝ : Nonempty ι\nS : ι → AddSubgroup G\nhS : Directed (fun x1 x2 => LE.le x1 x2) S\n⊢ Eq (↑(iSup fun i => S i)) (Set.iUnion fun i => ↑(S i))","decl":"@[to_additive]\ntheorem coe_iSup_of_directed {ι} [Nonempty ι] {S : ι → Subgroup G} (hS : Directed (· ≤ ·) S) :\n    ((⨆ i, S i : Subgroup G) : Set G) = ⋃ i, S i :=\n  Set.ext fun x ↦ by simp [mem_iSup_of_directed hS]\n\n"}
{"name":"Subgroup.coe_iSup_of_directed","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nι : Sort u_2\ninst✝ : Nonempty ι\nS : ι → Subgroup G\nhS : Directed (fun x1 x2 => LE.le x1 x2) S\n⊢ Eq (↑(iSup fun i => S i)) (Set.iUnion fun i => ↑(S i))","decl":"@[to_additive]\ntheorem coe_iSup_of_directed {ι} [Nonempty ι] {S : ι → Subgroup G} (hS : Directed (· ≤ ·) S) :\n    ((⨆ i, S i : Subgroup G) : Set G) = ⋃ i, S i :=\n  Set.ext fun x ↦ by simp [mem_iSup_of_directed hS]\n\n"}
{"name":"Subgroup.mem_sSup_of_directedOn","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nK : Set (Subgroup G)\nKne : K.Nonempty\nhK : DirectedOn (fun x1 x2 => LE.le x1 x2) K\nx : G\n⊢ Iff (Membership.mem (SupSet.sSup K) x) (Exists fun s => And (Membership.mem K s) (Membership.mem s x))","decl":"@[to_additive]\ntheorem mem_sSup_of_directedOn {K : Set (Subgroup G)} (Kne : K.Nonempty) (hK : DirectedOn (· ≤ ·) K)\n    {x : G} : x ∈ sSup K ↔ ∃ s ∈ K, x ∈ s := by\n  haveI : Nonempty K := Kne.to_subtype\n  simp only [sSup_eq_iSup', mem_iSup_of_directed hK.directed_val, SetCoe.exists, Subtype.coe_mk,\n    exists_prop]\n\n"}
{"name":"AddSubgroup.mem_sSup_of_directedOn","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nK : Set (AddSubgroup G)\nKne : K.Nonempty\nhK : DirectedOn (fun x1 x2 => LE.le x1 x2) K\nx : G\n⊢ Iff (Membership.mem (SupSet.sSup K) x) (Exists fun s => And (Membership.mem K s) (Membership.mem s x))","decl":"@[to_additive]\ntheorem mem_sSup_of_directedOn {K : Set (Subgroup G)} (Kne : K.Nonempty) (hK : DirectedOn (· ≤ ·) K)\n    {x : G} : x ∈ sSup K ↔ ∃ s ∈ K, x ∈ s := by\n  haveI : Nonempty K := Kne.to_subtype\n  simp only [sSup_eq_iSup', mem_iSup_of_directed hK.directed_val, SetCoe.exists, Subtype.coe_mk,\n    exists_prop]\n\n"}
{"name":"Subgroup.mem_sup","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"C : Type u_2\ninst✝ : CommGroup C\ns t : Subgroup C\nx : C\n⊢ Iff (Membership.mem (Max.max s t) x) (Exists fun y => And (Membership.mem s y) (Exists fun z => And (Membership.mem t z) (Eq (HMul.hMul y z) x)))","decl":"@[to_additive]\ntheorem mem_sup : x ∈ s ⊔ t ↔ ∃ y ∈ s, ∃ z ∈ t, y * z = x :=\n  ⟨fun h => by\n    rw [sup_eq_closure] at h\n    refine Subgroup.closure_induction ?_ ?_ ?_ ?_ h\n    · rintro y (h | h)\n      · exact ⟨y, h, 1, t.one_mem, by simp⟩\n      · exact ⟨1, s.one_mem, y, h, by simp⟩\n    · exact ⟨1, s.one_mem, 1, ⟨t.one_mem, mul_one 1⟩⟩\n    · rintro _ _ _ _ ⟨y₁, hy₁, z₁, hz₁, rfl⟩ ⟨y₂, hy₂, z₂, hz₂, rfl⟩\n      exact ⟨_, mul_mem hy₁ hy₂, _, mul_mem hz₁ hz₂, by simp [mul_assoc, mul_left_comm]⟩\n    · rintro _ _ ⟨y, hy, z, hz, rfl⟩\n      exact ⟨_, inv_mem hy, _, inv_mem hz, mul_comm z y ▸ (mul_inv_rev z y).symm⟩, by\n    rintro ⟨y, hy, z, hz, rfl⟩; exact mul_mem_sup hy hz⟩\n\n"}
{"name":"AddSubgroup.mem_sup","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"C : Type u_2\ninst✝ : AddCommGroup C\ns t : AddSubgroup C\nx : C\n⊢ Iff (Membership.mem (Max.max s t) x) (Exists fun y => And (Membership.mem s y) (Exists fun z => And (Membership.mem t z) (Eq (HAdd.hAdd y z) x)))","decl":"@[to_additive]\ntheorem mem_sup : x ∈ s ⊔ t ↔ ∃ y ∈ s, ∃ z ∈ t, y * z = x :=\n  ⟨fun h => by\n    rw [sup_eq_closure] at h\n    refine Subgroup.closure_induction ?_ ?_ ?_ ?_ h\n    · rintro y (h | h)\n      · exact ⟨y, h, 1, t.one_mem, by simp⟩\n      · exact ⟨1, s.one_mem, y, h, by simp⟩\n    · exact ⟨1, s.one_mem, 1, ⟨t.one_mem, mul_one 1⟩⟩\n    · rintro _ _ _ _ ⟨y₁, hy₁, z₁, hz₁, rfl⟩ ⟨y₂, hy₂, z₂, hz₂, rfl⟩\n      exact ⟨_, mul_mem hy₁ hy₂, _, mul_mem hz₁ hz₂, by simp [mul_assoc, mul_left_comm]⟩\n    · rintro _ _ ⟨y, hy, z, hz, rfl⟩\n      exact ⟨_, inv_mem hy, _, inv_mem hz, mul_comm z y ▸ (mul_inv_rev z y).symm⟩, by\n    rintro ⟨y, hy, z, hz, rfl⟩; exact mul_mem_sup hy hz⟩\n\n"}
{"name":"Subgroup.mem_sup'","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"C : Type u_2\ninst✝ : CommGroup C\ns t : Subgroup C\nx : C\n⊢ Iff (Membership.mem (Max.max s t) x) (Exists fun y => Exists fun z => Eq (HMul.hMul ↑y ↑z) x)","decl":"@[to_additive]\ntheorem mem_sup' : x ∈ s ⊔ t ↔ ∃ (y : s) (z : t), (y : C) * z = x :=\n  mem_sup.trans <| by simp only [SetLike.exists, coe_mk, exists_prop]\n\n"}
{"name":"AddSubgroup.mem_sup'","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"C : Type u_2\ninst✝ : AddCommGroup C\ns t : AddSubgroup C\nx : C\n⊢ Iff (Membership.mem (Max.max s t) x) (Exists fun y => Exists fun z => Eq (HAdd.hAdd ↑y ↑z) x)","decl":"@[to_additive]\ntheorem mem_sup' : x ∈ s ⊔ t ↔ ∃ (y : s) (z : t), (y : C) * z = x :=\n  mem_sup.trans <| by simp only [SetLike.exists, coe_mk, exists_prop]\n\n"}
{"name":"AddSubgroup.mem_closure_pair","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"C : Type u_2\ninst✝ : AddCommGroup C\nx y z : C\n⊢ Iff (Membership.mem (AddSubgroup.closure (Insert.insert x (Singleton.singleton y))) z) (Exists fun m => Exists fun n => Eq (HAdd.hAdd (HSMul.hSMul m x) (HSMul.hSMul n y)) z)","decl":"@[to_additive]\ntheorem mem_closure_pair {x y z : C} :\n    z ∈ closure ({x, y} : Set C) ↔ ∃ m n : ℤ, x ^ m * y ^ n = z := by\n  rw [← Set.singleton_union, Subgroup.closure_union, mem_sup]\n  simp_rw [mem_closure_singleton, exists_exists_eq_and]\n\n"}
{"name":"Subgroup.mem_closure_pair","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"C : Type u_2\ninst✝ : CommGroup C\nx y z : C\n⊢ Iff (Membership.mem (Subgroup.closure (Insert.insert x (Singleton.singleton y))) z) (Exists fun m => Exists fun n => Eq (HMul.hMul (HPow.hPow x m) (HPow.hPow y n)) z)","decl":"@[to_additive]\ntheorem mem_closure_pair {x y z : C} :\n    z ∈ closure ({x, y} : Set C) ↔ ∃ m n : ℤ, x ^ m * y ^ n = z := by\n  rw [← Set.singleton_union, Subgroup.closure_union, mem_sup]\n  simp_rw [mem_closure_singleton, exists_exists_eq_and]\n\n"}
{"name":"AddSubgroup.disjoint_def","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH₁ H₂ : AddSubgroup G\n⊢ Iff (Disjoint H₁ H₂) (∀ {x : G}, Membership.mem H₁ x → Membership.mem H₂ x → Eq x 0)","decl":"@[to_additive]\ntheorem disjoint_def {H₁ H₂ : Subgroup G} : Disjoint H₁ H₂ ↔ ∀ {x : G}, x ∈ H₁ → x ∈ H₂ → x = 1 :=\n  disjoint_iff_inf_le.trans <| by simp only [Disjoint, SetLike.le_def, mem_inf, mem_bot, and_imp]\n\n"}
{"name":"Subgroup.disjoint_def","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nH₁ H₂ : Subgroup G\n⊢ Iff (Disjoint H₁ H₂) (∀ {x : G}, Membership.mem H₁ x → Membership.mem H₂ x → Eq x 1)","decl":"@[to_additive]\ntheorem disjoint_def {H₁ H₂ : Subgroup G} : Disjoint H₁ H₂ ↔ ∀ {x : G}, x ∈ H₁ → x ∈ H₂ → x = 1 :=\n  disjoint_iff_inf_le.trans <| by simp only [Disjoint, SetLike.le_def, mem_inf, mem_bot, and_imp]\n\n"}
{"name":"AddSubgroup.disjoint_def'","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH₁ H₂ : AddSubgroup G\n⊢ Iff (Disjoint H₁ H₂) (∀ {x y : G}, Membership.mem H₁ x → Membership.mem H₂ y → Eq x y → Eq x 0)","decl":"@[to_additive]\ntheorem disjoint_def' {H₁ H₂ : Subgroup G} :\n    Disjoint H₁ H₂ ↔ ∀ {x y : G}, x ∈ H₁ → y ∈ H₂ → x = y → x = 1 :=\n  disjoint_def.trans ⟨fun h _x _y hx hy hxy ↦ h hx <| hxy.symm ▸ hy, fun h _x hx hx' ↦ h hx hx' rfl⟩\n\n"}
{"name":"Subgroup.disjoint_def'","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nH₁ H₂ : Subgroup G\n⊢ Iff (Disjoint H₁ H₂) (∀ {x y : G}, Membership.mem H₁ x → Membership.mem H₂ y → Eq x y → Eq x 1)","decl":"@[to_additive]\ntheorem disjoint_def' {H₁ H₂ : Subgroup G} :\n    Disjoint H₁ H₂ ↔ ∀ {x y : G}, x ∈ H₁ → y ∈ H₂ → x = y → x = 1 :=\n  disjoint_def.trans ⟨fun h _x _y hx hy hxy ↦ h hx <| hxy.symm ▸ hy, fun h _x hx hx' ↦ h hx hx' rfl⟩\n\n"}
{"name":"AddSubgroup.disjoint_iff_add_eq_zero","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH₁ H₂ : AddSubgroup G\n⊢ Iff (Disjoint H₁ H₂) (∀ {x y : G}, Membership.mem H₁ x → Membership.mem H₂ y → Eq (HAdd.hAdd x y) 0 → And (Eq x 0) (Eq y 0))","decl":"@[to_additive]\ntheorem disjoint_iff_mul_eq_one {H₁ H₂ : Subgroup G} :\n    Disjoint H₁ H₂ ↔ ∀ {x y : G}, x ∈ H₁ → y ∈ H₂ → x * y = 1 → x = 1 ∧ y = 1 :=\n  disjoint_def'.trans\n    ⟨fun h x y hx hy hxy =>\n      let hx1 : x = 1 := h hx (H₂.inv_mem hy) (eq_inv_iff_mul_eq_one.mpr hxy)\n      ⟨hx1, by simpa [hx1] using hxy⟩,\n      fun h _ _ hx hy hxy => (h hx (H₂.inv_mem hy) (mul_inv_eq_one.mpr hxy)).1⟩\n\n"}
{"name":"Subgroup.disjoint_iff_mul_eq_one","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nH₁ H₂ : Subgroup G\n⊢ Iff (Disjoint H₁ H₂) (∀ {x y : G}, Membership.mem H₁ x → Membership.mem H₂ y → Eq (HMul.hMul x y) 1 → And (Eq x 1) (Eq y 1))","decl":"@[to_additive]\ntheorem disjoint_iff_mul_eq_one {H₁ H₂ : Subgroup G} :\n    Disjoint H₁ H₂ ↔ ∀ {x y : G}, x ∈ H₁ → y ∈ H₂ → x * y = 1 → x = 1 ∧ y = 1 :=\n  disjoint_def'.trans\n    ⟨fun h x y hx hy hxy =>\n      let hx1 : x = 1 := h hx (H₂.inv_mem hy) (eq_inv_iff_mul_eq_one.mpr hxy)\n      ⟨hx1, by simpa [hx1] using hxy⟩,\n      fun h _ _ hx hy hxy => (h hx (H₂.inv_mem hy) (mul_inv_eq_one.mpr hxy)).1⟩\n\n"}
{"name":"Subgroup.mul_injective_of_disjoint","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : Group G\nH₁ H₂ : Subgroup G\nh : Disjoint H₁ H₂\n⊢ Function.Injective fun g => HMul.hMul ↑g.1 ↑g.2","decl":"@[to_additive]\ntheorem mul_injective_of_disjoint {H₁ H₂ : Subgroup G} (h : Disjoint H₁ H₂) :\n    Function.Injective (fun g => g.1 * g.2 : H₁ × H₂ → G) := by\n  intro x y hxy\n  rw [← inv_mul_eq_iff_eq_mul, ← mul_assoc, ← mul_inv_eq_one, mul_assoc] at hxy\n  replace hxy := disjoint_iff_mul_eq_one.mp h (y.1⁻¹ * x.1).prop (x.2 * y.2⁻¹).prop hxy\n  rwa [coe_mul, coe_mul, coe_inv, coe_inv, inv_mul_eq_one, mul_inv_eq_one, ← Subtype.ext_iff, ←\n    Subtype.ext_iff, eq_comm, ← Prod.ext_iff] at hxy\n\n"}
{"name":"AddSubgroup.add_injective_of_disjoint","module":"Mathlib.Algebra.Group.Subgroup.Lattice","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH₁ H₂ : AddSubgroup G\nh : Disjoint H₁ H₂\n⊢ Function.Injective fun g => HAdd.hAdd ↑g.1 ↑g.2","decl":"@[to_additive]\ntheorem mul_injective_of_disjoint {H₁ H₂ : Subgroup G} (h : Disjoint H₁ H₂) :\n    Function.Injective (fun g => g.1 * g.2 : H₁ × H₂ → G) := by\n  intro x y hxy\n  rw [← inv_mul_eq_iff_eq_mul, ← mul_assoc, ← mul_inv_eq_one, mul_assoc] at hxy\n  replace hxy := disjoint_iff_mul_eq_one.mp h (y.1⁻¹ * x.1).prop (x.2 * y.2⁻¹).prop hxy\n  rwa [coe_mul, coe_mul, coe_inv, coe_inv, inv_mul_eq_one, mul_inv_eq_one, ← Subtype.ext_iff, ←\n    Subtype.ext_iff, eq_comm, ← Prod.ext_iff] at hxy\n\n"}
