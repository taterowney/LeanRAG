{"name":"NumberField.Embeddings.card","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninst✝⁴ : Field K\ninst✝³ : NumberField K\nA : Type u_2\ninst✝² : Field A\ninst✝¹ : CharZero A\ninst✝ : IsAlgClosed A\n⊢ Eq (Fintype.card (RingHom K A)) (Module.finrank Rat K)","decl":"/-- The number of embeddings of a number field is equal to its finrank. -/\ntheorem card : Fintype.card (K →+* A) = finrank ℚ K := by\n  rw [Fintype.ofEquiv_card RingHom.equivRatAlgHom.symm, AlgHom.card]\n\n"}
{"name":"NumberField.Embeddings.instNonemptyRingHom","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninst✝¹ : Field K\nA : Type u_2\ninst✝ : Field A\n⊢ Nonempty (RingHom K A)","decl":"instance : Nonempty (K →+* A) := by\n  rw [← Fintype.card_pos_iff, NumberField.Embeddings.card K A]\n  exact Module.finrank_pos\n\n"}
{"name":"NumberField.Embeddings.range_eval_eq_rootSet_minpoly","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\nA : Type u_2\ninst✝⁴ : Field K\ninst✝³ : NumberField K\ninst✝² : Field A\ninst✝¹ : Algebra Rat A\ninst✝ : IsAlgClosed A\nx : K\n⊢ Eq (Set.range fun φ => φ x) ((minpoly Rat x).rootSet A)","decl":"/-- Let `A` be an algebraically closed field and let `x ∈ K`, with `K` a number field.\nThe images of `x` by the embeddings of `K` in `A` are exactly the roots in `A` of\nthe minimal polynomial of `x` over `ℚ`. -/\ntheorem range_eval_eq_rootSet_minpoly :\n    (range fun φ : K →+* A => φ x) = (minpoly ℚ x).rootSet A := by\n  convert (NumberField.isAlgebraic K).range_eval_eq_rootSet_minpoly A x using 1\n  ext a\n  exact ⟨fun ⟨φ, hφ⟩ => ⟨φ.toRatAlgHom, hφ⟩, fun ⟨φ, hφ⟩ => ⟨φ.toRingHom, hφ⟩⟩\n\n"}
{"name":"NumberField.Embeddings.coeff_bdd_of_norm_le","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninst✝⁴ : Field K\ninst✝³ : NumberField K\nA : Type u_2\ninst✝² : NormedField A\ninst✝¹ : IsAlgClosed A\ninst✝ : NormedAlgebra Rat A\nB : Real\nx : K\nh : ∀ (φ : RingHom K A), LE.le (Norm.norm (φ x)) B\ni : Nat\n⊢ LE.le (Norm.norm ((minpoly Rat x).coeff i)) (HMul.hMul (HPow.hPow (Max.max B 1) (Module.finrank Rat K)) ↑((Module.finrank Rat K).choose (HDiv.hDiv (Module.finrank Rat K) 2)))","decl":"theorem coeff_bdd_of_norm_le {B : ℝ} {x : K} (h : ∀ φ : K →+* A, ‖φ x‖ ≤ B) (i : ℕ) :\n    ‖(minpoly ℚ x).coeff i‖ ≤ max B 1 ^ finrank ℚ K * (finrank ℚ K).choose (finrank ℚ K / 2) := by\n  have hx := Algebra.IsSeparable.isIntegral ℚ x\n  rw [← norm_algebraMap' A, ← coeff_map (algebraMap ℚ A)]\n  refine coeff_bdd_of_roots_le _ (minpoly.monic hx)\n      (IsAlgClosed.splits_codomain _) (minpoly.natDegree_le x) (fun z hz => ?_) i\n  classical\n  rw [← Multiset.mem_toFinset] at hz\n  obtain ⟨φ, rfl⟩ := (range_eval_eq_rootSet_minpoly K A x).symm.subset hz\n  exact h φ\n\n"}
{"name":"NumberField.Embeddings.finite_of_norm_le","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninst✝⁴ : Field K\ninst✝³ : NumberField K\nA : Type u_2\ninst✝² : NormedField A\ninst✝¹ : IsAlgClosed A\ninst✝ : NormedAlgebra Rat A\nB : Real\n⊢ (setOf fun x => And (IsIntegral Int x) (∀ (φ : RingHom K A), LE.le (Norm.norm (φ x)) B)).Finite","decl":"/-- Let `B` be a real number. The set of algebraic integers in `K` whose conjugates are all\nsmaller in norm than `B` is finite. -/\ntheorem finite_of_norm_le (B : ℝ) : {x : K | IsIntegral ℤ x ∧ ∀ φ : K →+* A, ‖φ x‖ ≤ B}.Finite := by\n  classical\n  let C := Nat.ceil (max B 1 ^ finrank ℚ K * (finrank ℚ K).choose (finrank ℚ K / 2))\n  have := bUnion_roots_finite (algebraMap ℤ K) (finrank ℚ K) (finite_Icc (-C : ℤ) C)\n  refine this.subset fun x hx => ?_; simp_rw [mem_iUnion]\n  have h_map_ℚ_minpoly := minpoly.isIntegrallyClosed_eq_field_fractions' ℚ hx.1\n  refine ⟨_, ⟨?_, fun i => ?_⟩, mem_rootSet.2 ⟨minpoly.ne_zero hx.1, minpoly.aeval ℤ x⟩⟩\n  · rw [← (minpoly.monic hx.1).natDegree_map (algebraMap ℤ ℚ), ← h_map_ℚ_minpoly]\n    exact minpoly.natDegree_le x\n  rw [mem_Icc, ← abs_le, ← @Int.cast_le ℝ]\n  refine (Eq.trans_le ?_ <| coeff_bdd_of_norm_le hx.2 i).trans (Nat.le_ceil _)\n  rw [h_map_ℚ_minpoly, coeff_map, eq_intCast, Int.norm_cast_rat, Int.norm_eq_abs, Int.cast_abs]\n\n"}
{"name":"NumberField.Embeddings.pow_eq_one_of_norm_eq_one","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninst✝⁴ : Field K\ninst✝³ : NumberField K\nA : Type u_2\ninst✝² : NormedField A\ninst✝¹ : IsAlgClosed A\ninst✝ : NormedAlgebra Rat A\nx : K\nhxi : IsIntegral Int x\nhx : ∀ (φ : RingHom K A), Eq (Norm.norm (φ x)) 1\n⊢ Exists fun n => Exists fun x_1 => Eq (HPow.hPow x n) 1","decl":"/-- An algebraic integer whose conjugates are all of norm one is a root of unity. -/\ntheorem pow_eq_one_of_norm_eq_one {x : K} (hxi : IsIntegral ℤ x) (hx : ∀ φ : K →+* A, ‖φ x‖ = 1) :\n    ∃ (n : ℕ) (_ : 0 < n), x ^ n = 1 := by\n  obtain ⟨a, -, b, -, habne, h⟩ :=\n    @Set.Infinite.exists_ne_map_eq_of_mapsTo _ _ _ _ (x ^ · : ℕ → K) Set.infinite_univ\n      (by exact fun a _ => ⟨hxi.pow a, fun φ => by simp [hx φ]⟩) (finite_of_norm_le K A (1 : ℝ))\n  wlog hlt : b < a\n  · exact this K A hxi hx b a habne.symm h.symm (habne.lt_or_lt.resolve_right hlt)\n  refine ⟨a - b, tsub_pos_of_lt hlt, ?_⟩\n  rw [← Nat.sub_add_cancel hlt.le, pow_add, mul_left_eq_self₀] at h\n  refine h.resolve_right fun hp => ?_\n  specialize hx (IsAlgClosed.lift (R := ℚ)).toRingHom\n  rw [pow_eq_zero hp, map_zero, norm_zero] at hx; norm_num at hx\n\n"}
{"name":"NumberField.place_apply","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninst✝² : Field K\nA : Type u_2\ninst✝¹ : NormedDivisionRing A\ninst✝ : Nontrivial A\nφ : RingHom K A\nx : K\n⊢ Eq ((NumberField.place φ) x) (Norm.norm (φ x))","decl":"@[simp]\ntheorem NumberField.place_apply (x : K) : (NumberField.place φ) x = norm (φ x) := rfl\n\n"}
{"name":"NumberField.ComplexEmbedding.conjugate_coe_eq","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninst✝ : Field K\nφ : RingHom K Complex\nx : K\n⊢ Eq ((NumberField.ComplexEmbedding.conjugate φ) x) ((starRingEnd Complex) (φ x))","decl":"@[simp]\ntheorem conjugate_coe_eq (φ : K →+* ℂ) (x : K) : (conjugate φ) x = conj (φ x) := rfl\n\n"}
{"name":"NumberField.ComplexEmbedding.place_conjugate","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninst✝ : Field K\nφ : RingHom K Complex\n⊢ Eq (NumberField.place (NumberField.ComplexEmbedding.conjugate φ)) (NumberField.place φ)","decl":"theorem place_conjugate (φ : K →+* ℂ) : place (conjugate φ) = place φ := by\n  ext; simp only [place_apply, norm_eq_abs, abs_conj, conjugate_coe_eq]\n\n"}
{"name":"NumberField.ComplexEmbedding.isReal_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninst✝ : Field K\nφ : RingHom K Complex\n⊢ Iff (NumberField.ComplexEmbedding.IsReal φ) (Eq (NumberField.ComplexEmbedding.conjugate φ) φ)","decl":"theorem isReal_iff {φ : K →+* ℂ} : IsReal φ ↔ conjugate φ = φ := isSelfAdjoint_iff\n\n"}
{"name":"NumberField.ComplexEmbedding.isReal_conjugate_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninst✝ : Field K\nφ : RingHom K Complex\n⊢ Iff (NumberField.ComplexEmbedding.IsReal (NumberField.ComplexEmbedding.conjugate φ)) (NumberField.ComplexEmbedding.IsReal φ)","decl":"theorem isReal_conjugate_iff {φ : K →+* ℂ} : IsReal (conjugate φ) ↔ IsReal φ :=\n  IsSelfAdjoint.star_iff\n\n"}
{"name":"NumberField.ComplexEmbedding.IsReal.coe_embedding_apply","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninst✝ : Field K\nφ : RingHom K Complex\nhφ : NumberField.ComplexEmbedding.IsReal φ\nx : K\n⊢ Eq (↑(hφ.embedding x)) (φ x)","decl":"@[simp]\ntheorem IsReal.coe_embedding_apply {φ : K →+* ℂ} (hφ : IsReal φ) (x : K) :\n    (hφ.embedding x : ℂ) = φ x := by\n  apply Complex.ext\n  · rfl\n  · rw [ofReal_im, eq_comm, ← Complex.conj_eq_iff_im]\n    exact RingHom.congr_fun hφ x\n\n"}
{"name":"NumberField.ComplexEmbedding.IsReal.comp","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninst✝¹ : Field K\nk : Type u_2\ninst✝ : Field k\nf : RingHom k K\nφ : RingHom K Complex\nhφ : NumberField.ComplexEmbedding.IsReal φ\n⊢ NumberField.ComplexEmbedding.IsReal (φ.comp f)","decl":"lemma IsReal.comp (f : k →+* K) {φ : K →+* ℂ} (hφ : IsReal φ) :\n    IsReal (φ.comp f) := by ext1 x; simpa using RingHom.congr_fun hφ (f x)\n\n"}
{"name":"NumberField.ComplexEmbedding.isReal_comp_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninst✝¹ : Field K\nk : Type u_2\ninst✝ : Field k\nf : RingEquiv k K\nφ : RingHom K Complex\n⊢ Iff (NumberField.ComplexEmbedding.IsReal (φ.comp ↑f)) (NumberField.ComplexEmbedding.IsReal φ)","decl":"lemma isReal_comp_iff {f : k ≃+* K} {φ : K →+* ℂ} :\n    IsReal (φ.comp (f : k →+* K)) ↔ IsReal φ :=\n  ⟨fun H ↦ by convert H.comp f.symm.toRingHom; ext1; simp, IsReal.comp _⟩\n\n"}
{"name":"NumberField.ComplexEmbedding.exists_comp_symm_eq_of_comp_eq","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninst✝³ : Field K\nk : Type u_2\ninst✝² : Field k\ninst✝¹ : Algebra k K\ninst✝ : IsGalois k K\nφ ψ : RingHom K Complex\nh : Eq (φ.comp (algebraMap k K)) (ψ.comp (algebraMap k K))\n⊢ Exists fun σ => Eq (φ.comp ↑σ.symm) ψ","decl":"lemma exists_comp_symm_eq_of_comp_eq [Algebra k K] [IsGalois k K] (φ ψ : K →+* ℂ)\n    (h : φ.comp (algebraMap k K) = ψ.comp (algebraMap k K)) :\n    ∃ σ : K ≃ₐ[k] K, φ.comp σ.symm = ψ := by\n  letI := (φ.comp (algebraMap k K)).toAlgebra\n  letI := φ.toAlgebra\n  have : IsScalarTower k K ℂ := IsScalarTower.of_algebraMap_eq' rfl\n  let ψ' : K →ₐ[k] ℂ := { ψ with commutes' := fun r ↦ (RingHom.congr_fun h r).symm }\n  use (AlgHom.restrictNormal' ψ' K).symm\n  ext1 x\n  exact AlgHom.restrictNormal_commutes ψ' K x\n\n"}
{"name":"NumberField.ComplexEmbedding.IsConj.eq","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninst✝² : Field K\nk : Type u_2\ninst✝¹ : Field k\ninst✝ : Algebra k K\nφ : RingHom K Complex\nσ : AlgEquiv k K K\nh : NumberField.ComplexEmbedding.IsConj φ σ\nx : K\n⊢ Eq (φ (σ x)) (Star.star (φ x))","decl":"lemma IsConj.eq (h : IsConj φ σ) (x) : φ (σ x) = star (φ x) := RingHom.congr_fun h.symm x\n\n"}
{"name":"NumberField.ComplexEmbedding.IsConj.ext","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninst✝² : Field K\nk : Type u_2\ninst✝¹ : Field k\ninst✝ : Algebra k K\nφ : RingHom K Complex\nσ₁ σ₂ : AlgEquiv k K K\nh₁ : NumberField.ComplexEmbedding.IsConj φ σ₁\nh₂ : NumberField.ComplexEmbedding.IsConj φ σ₂\n⊢ Eq σ₁ σ₂","decl":"lemma IsConj.ext {σ₁ σ₂ : K ≃ₐ[k] K} (h₁ : IsConj φ σ₁) (h₂ : IsConj φ σ₂) : σ₁ = σ₂ :=\n  AlgEquiv.ext fun x ↦ φ.injective ((h₁.eq x).trans (h₂.eq x).symm)\n\n"}
{"name":"NumberField.ComplexEmbedding.IsConj.ext_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninst✝² : Field K\nk : Type u_2\ninst✝¹ : Field k\ninst✝ : Algebra k K\nφ : RingHom K Complex\nσ₁ σ₂ : AlgEquiv k K K\nh₁ : NumberField.ComplexEmbedding.IsConj φ σ₁\n⊢ Iff (Eq σ₁ σ₂) (NumberField.ComplexEmbedding.IsConj φ σ₂)","decl":"lemma IsConj.ext_iff {σ₁ σ₂ : K ≃ₐ[k] K} (h₁ : IsConj φ σ₁) : σ₁ = σ₂ ↔ IsConj φ σ₂ :=\n  ⟨fun e ↦ e ▸ h₁, h₁.ext⟩\n\n"}
{"name":"NumberField.ComplexEmbedding.IsConj.isReal_comp","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninst✝² : Field K\nk : Type u_2\ninst✝¹ : Field k\ninst✝ : Algebra k K\nφ : RingHom K Complex\nσ : AlgEquiv k K K\nh : NumberField.ComplexEmbedding.IsConj φ σ\n⊢ NumberField.ComplexEmbedding.IsReal (φ.comp (algebraMap k K))","decl":"lemma IsConj.isReal_comp (h : IsConj φ σ) : IsReal (φ.comp (algebraMap k K)) := by\n  ext1 x\n  simp only [conjugate_coe_eq, RingHom.coe_comp, Function.comp_apply, ← h.eq,\n    starRingEnd_apply, AlgEquiv.commutes]\n\n"}
{"name":"NumberField.ComplexEmbedding.isConj_one_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninst✝² : Field K\nk : Type u_2\ninst✝¹ : Field k\ninst✝ : Algebra k K\nφ : RingHom K Complex\n⊢ Iff (NumberField.ComplexEmbedding.IsConj φ 1) (NumberField.ComplexEmbedding.IsReal φ)","decl":"lemma isConj_one_iff : IsConj φ (1 : K ≃ₐ[k] K) ↔ IsReal φ := Iff.rfl\n\n"}
{"name":"NumberField.ComplexEmbedding.IsReal.isConjGal_one","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninst✝² : Field K\nk : Type u_2\ninst✝¹ : Field k\ninst✝ : Algebra k K\nφ : RingHom K Complex\na✝ : NumberField.ComplexEmbedding.IsReal φ\n⊢ NumberField.ComplexEmbedding.IsConj φ 1","decl":"alias ⟨_, IsReal.isConjGal_one⟩ := ComplexEmbedding.isConj_one_iff\n\n"}
{"name":"NumberField.ComplexEmbedding.IsConj.symm","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninst✝² : Field K\nk : Type u_2\ninst✝¹ : Field k\ninst✝ : Algebra k K\nφ : RingHom K Complex\nσ : AlgEquiv k K K\nhσ : NumberField.ComplexEmbedding.IsConj φ σ\n⊢ NumberField.ComplexEmbedding.IsConj φ σ.symm","decl":"lemma IsConj.symm (hσ : IsConj φ σ) :\n    IsConj φ σ.symm := RingHom.ext fun x ↦ by simpa using congr_arg star (hσ.eq (σ.symm x))\n\n"}
{"name":"NumberField.ComplexEmbedding.isConj_symm","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninst✝² : Field K\nk : Type u_2\ninst✝¹ : Field k\ninst✝ : Algebra k K\nφ : RingHom K Complex\nσ : AlgEquiv k K K\n⊢ Iff (NumberField.ComplexEmbedding.IsConj φ σ.symm) (NumberField.ComplexEmbedding.IsConj φ σ)","decl":"lemma isConj_symm : IsConj φ σ.symm ↔ IsConj φ σ :=\n  ⟨IsConj.symm, IsConj.symm⟩\n\n"}
{"name":"instNonemptyInfinitePlaceOfNumberField","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝¹ : Field K\ninst✝ : NumberField K\n⊢ Nonempty (NumberField.InfinitePlace K)","decl":"instance [NumberField K] : Nonempty (NumberField.InfinitePlace K) := Set.instNonemptyRange _\n\n"}
{"name":"NumberField.InfinitePlace.coe_apply","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_4\ninst✝ : Field K\nv : NumberField.InfinitePlace K\nx : K\n⊢ Eq (v x) (↑v x)","decl":"lemma coe_apply {K : Type*} [Field K] (v : InfinitePlace K) (x : K) :\n  v x = v.1 x := rfl\n\n"}
{"name":"NumberField.InfinitePlace.ext","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_4\ninst✝ : Field K\nv₁ v₂ : NumberField.InfinitePlace K\nh : ∀ (k : K), Eq (v₁ k) (v₂ k)\n⊢ Eq v₁ v₂","decl":"@[ext]\nlemma ext {K : Type*} [Field K] (v₁ v₂ : InfinitePlace K) (h : ∀ k, v₁ k = v₂ k) : v₁ = v₂ :=\n  Subtype.ext <| AbsoluteValue.ext h\n\n"}
{"name":"NumberField.InfinitePlace.ext_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_4\ninst✝ : Field K\nv₁ v₂ : NumberField.InfinitePlace K\n⊢ Iff (Eq v₁ v₂) (∀ (k : K), Eq (v₁ k) (v₂ k))","decl":"@[ext]\nlemma ext {K : Type*} [Field K] (v₁ v₂ : InfinitePlace K) (h : ∀ k, v₁ k = v₂ k) : v₁ = v₂ :=\n  Subtype.ext <| AbsoluteValue.ext h\n\n"}
{"name":"NumberField.InfinitePlace.instMonoidWithZeroHomClassReal","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\n⊢ MonoidWithZeroHomClass (NumberField.InfinitePlace K) K Real","decl":"instance : MonoidWithZeroHomClass (InfinitePlace K) K ℝ where\n  map_mul w _ _ := w.1.map_mul _ _\n  map_one w := w.1.map_one\n  map_zero w := w.1.map_zero\n\n"}
{"name":"NumberField.InfinitePlace.instNonnegHomClassReal","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\n⊢ NonnegHomClass (NumberField.InfinitePlace K) K Real","decl":"instance : NonnegHomClass (InfinitePlace K) K ℝ where\n  apply_nonneg w _ := w.1.nonneg _\n\n"}
{"name":"NumberField.InfinitePlace.apply","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\nφ : RingHom K Complex\nx : K\n⊢ Eq ((NumberField.InfinitePlace.mk φ) x) (Complex.abs (φ x))","decl":"@[simp]\ntheorem apply (φ : K →+* ℂ) (x : K) : (mk φ) x = Complex.abs (φ x) := rfl\n\n"}
{"name":"NumberField.InfinitePlace.mk_embedding","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\nw : NumberField.InfinitePlace K\n⊢ Eq (NumberField.InfinitePlace.mk w.embedding) w","decl":"@[simp]\ntheorem mk_embedding (w : InfinitePlace K) : mk (embedding w) = w := Subtype.ext w.2.choose_spec\n\n"}
{"name":"NumberField.InfinitePlace.mk_conjugate_eq","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\nφ : RingHom K Complex\n⊢ Eq (NumberField.InfinitePlace.mk (NumberField.ComplexEmbedding.conjugate φ)) (NumberField.InfinitePlace.mk φ)","decl":"@[simp]\ntheorem mk_conjugate_eq (φ : K →+* ℂ) : mk (ComplexEmbedding.conjugate φ) = mk φ := by\n  refine DFunLike.ext _ _ (fun x => ?_)\n  rw [apply, apply, ComplexEmbedding.conjugate_coe_eq, Complex.abs_conj]\n\n"}
{"name":"NumberField.InfinitePlace.norm_embedding_eq","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\nw : NumberField.InfinitePlace K\nx : K\n⊢ Eq (Norm.norm (w.embedding x)) (w x)","decl":"theorem norm_embedding_eq (w : InfinitePlace K) (x : K) :\n    ‖(embedding w) x‖ = w x := by\n  nth_rewrite 2 [← mk_embedding w]\n  rfl\n\n"}
{"name":"NumberField.InfinitePlace.eq_iff_eq","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\nx : K\nr : Real\n⊢ Iff (∀ (w : NumberField.InfinitePlace K), Eq (w x) r) (∀ (φ : RingHom K Complex), Eq (Norm.norm (φ x)) r)","decl":"theorem eq_iff_eq (x : K) (r : ℝ) : (∀ w : InfinitePlace K, w x = r) ↔ ∀ φ : K →+* ℂ, ‖φ x‖ = r :=\n  ⟨fun hw φ => hw (mk φ), by rintro hφ ⟨w, ⟨φ, rfl⟩⟩; exact hφ φ⟩\n\n"}
{"name":"NumberField.InfinitePlace.le_iff_le","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\nx : K\nr : Real\n⊢ Iff (∀ (w : NumberField.InfinitePlace K), LE.le (w x) r) (∀ (φ : RingHom K Complex), LE.le (Norm.norm (φ x)) r)","decl":"theorem le_iff_le (x : K) (r : ℝ) : (∀ w : InfinitePlace K, w x ≤ r) ↔ ∀ φ : K →+* ℂ, ‖φ x‖ ≤ r :=\n  ⟨fun hw φ => hw (mk φ), by rintro hφ ⟨w, ⟨φ, rfl⟩⟩; exact hφ φ⟩\n\n"}
{"name":"NumberField.InfinitePlace.pos_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\nw : NumberField.InfinitePlace K\nx : K\n⊢ Iff (LT.lt 0 (w x)) (Ne x 0)","decl":"theorem pos_iff {w : InfinitePlace K} {x : K} : 0 < w x ↔ x ≠ 0 := AbsoluteValue.pos_iff w.1\n\n"}
{"name":"NumberField.InfinitePlace.mk_eq_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\nφ ψ : RingHom K Complex\n⊢ Iff (Eq (NumberField.InfinitePlace.mk φ) (NumberField.InfinitePlace.mk ψ)) (Or (Eq φ ψ) (Eq (NumberField.ComplexEmbedding.conjugate φ) ψ))","decl":"@[simp]\ntheorem mk_eq_iff {φ ψ : K →+* ℂ} : mk φ = mk ψ ↔ φ = ψ ∨ ComplexEmbedding.conjugate φ = ψ := by\n  constructor\n  · -- We prove that the map ψ ∘ φ⁻¹ between φ(K) and ℂ is uniform continuous, thus it is either the\n    -- inclusion or the complex conjugation using `Complex.uniformContinuous_ringHom_eq_id_or_conj`\n    intro h₀\n    obtain ⟨j, hiφ⟩ := (φ.injective).hasLeftInverse\n    let ι := RingEquiv.ofLeftInverse hiφ\n    have hlip : LipschitzWith 1 (RingHom.comp ψ ι.symm.toRingHom) := by\n      change LipschitzWith 1 (ψ ∘ ι.symm)\n      apply LipschitzWith.of_dist_le_mul\n      intro x y\n      rw [NNReal.coe_one, one_mul, NormedField.dist_eq, Function.comp_apply, Function.comp_apply,\n        ← map_sub, ← map_sub]\n      apply le_of_eq\n      suffices ‖φ (ι.symm (x - y))‖ = ‖ψ (ι.symm (x - y))‖ by\n        rw [← this, ← RingEquiv.ofLeftInverse_apply hiφ _, RingEquiv.apply_symm_apply ι _]\n        rfl\n      exact congrFun (congrArg (↑) h₀) _\n    cases\n      Complex.uniformContinuous_ringHom_eq_id_or_conj φ.fieldRange hlip.uniformContinuous with\n    | inl h =>\n        left; ext1 x\n        conv_rhs => rw [← hiφ x]\n        exact (congrFun h (ι x)).symm\n    | inr h =>\n        right; ext1 x\n        conv_rhs => rw [← hiφ x]\n        exact (congrFun h (ι x)).symm\n  · rintro (⟨h⟩ | ⟨h⟩)\n    · exact congr_arg mk h\n    · rw [← mk_conjugate_eq]\n      exact congr_arg mk h\n\n"}
{"name":"NumberField.InfinitePlace.embedding_mk_eq","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\nφ : RingHom K Complex\n⊢ Or (Eq (NumberField.InfinitePlace.mk φ).embedding φ) (Eq (NumberField.InfinitePlace.mk φ).embedding (NumberField.ComplexEmbedding.conjugate φ))","decl":"theorem embedding_mk_eq (φ : K →+* ℂ) :\n    embedding (mk φ) = φ ∨ embedding (mk φ) = ComplexEmbedding.conjugate φ := by\n  rw [@eq_comm _ _ φ, @eq_comm _ _ (ComplexEmbedding.conjugate φ), ← mk_eq_iff, mk_embedding]\n\n"}
{"name":"NumberField.InfinitePlace.embedding_mk_eq_of_isReal","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\nφ : RingHom K Complex\nh : NumberField.ComplexEmbedding.IsReal φ\n⊢ Eq (NumberField.InfinitePlace.mk φ).embedding φ","decl":"@[simp]\ntheorem embedding_mk_eq_of_isReal {φ : K →+* ℂ} (h : ComplexEmbedding.IsReal φ) :\n    embedding (mk φ) = φ := by\n  have := embedding_mk_eq φ\n  rwa [ComplexEmbedding.isReal_iff.mp h, or_self] at this\n\n"}
{"name":"NumberField.InfinitePlace.isReal_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\nw : NumberField.InfinitePlace K\n⊢ Iff w.IsReal (NumberField.ComplexEmbedding.IsReal w.embedding)","decl":"theorem isReal_iff {w : InfinitePlace K} :\n    IsReal w ↔ ComplexEmbedding.IsReal (embedding w) := by\n  refine ⟨?_, fun h => ⟨embedding w, h, mk_embedding w⟩⟩\n  rintro ⟨φ, ⟨hφ, rfl⟩⟩\n  rwa [embedding_mk_eq_of_isReal hφ]\n\n"}
{"name":"NumberField.InfinitePlace.isComplex_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\nw : NumberField.InfinitePlace K\n⊢ Iff w.IsComplex (Not (NumberField.ComplexEmbedding.IsReal w.embedding))","decl":"theorem isComplex_iff {w : InfinitePlace K} :\n    IsComplex w ↔ ¬ComplexEmbedding.IsReal (embedding w) := by\n  refine ⟨?_, fun h => ⟨embedding w, h, mk_embedding w⟩⟩\n  rintro ⟨φ, ⟨hφ, rfl⟩⟩\n  contrapose! hφ\n  cases mk_eq_iff.mp (mk_embedding (mk φ)) with\n  | inl h => rwa [h] at hφ\n  | inr h => rwa [← ComplexEmbedding.isReal_conjugate_iff, h] at hφ\n\n"}
{"name":"NumberField.InfinitePlace.conjugate_embedding_eq_of_isReal","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\nw : NumberField.InfinitePlace K\nh : w.IsReal\n⊢ Eq (NumberField.ComplexEmbedding.conjugate w.embedding) w.embedding","decl":"@[simp]\ntheorem conjugate_embedding_eq_of_isReal {w : InfinitePlace K} (h : IsReal w) :\n    ComplexEmbedding.conjugate (embedding w) = embedding w :=\n  ComplexEmbedding.isReal_iff.mpr (isReal_iff.mp h)\n\n"}
{"name":"NumberField.InfinitePlace.not_isReal_iff_isComplex","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\nw : NumberField.InfinitePlace K\n⊢ Iff (Not w.IsReal) w.IsComplex","decl":"@[simp]\ntheorem not_isReal_iff_isComplex {w : InfinitePlace K} : ¬IsReal w ↔ IsComplex w := by\n  rw [isComplex_iff, isReal_iff]\n\n"}
{"name":"NumberField.InfinitePlace.not_isComplex_iff_isReal","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\nw : NumberField.InfinitePlace K\n⊢ Iff (Not w.IsComplex) w.IsReal","decl":"@[simp]\ntheorem not_isComplex_iff_isReal {w : InfinitePlace K} : ¬IsComplex w ↔ IsReal w := by\n  rw [isComplex_iff, isReal_iff, not_not]\n\n"}
{"name":"NumberField.InfinitePlace.isReal_or_isComplex","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\nw : NumberField.InfinitePlace K\n⊢ Or w.IsReal w.IsComplex","decl":"theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by\n  rw [← not_isReal_iff_isComplex]; exact em _\n\n"}
{"name":"NumberField.InfinitePlace.ne_of_isReal_isComplex","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\nw w' : NumberField.InfinitePlace K\nh : w.IsReal\nh' : w'.IsComplex\n⊢ Ne w w'","decl":"theorem ne_of_isReal_isComplex {w w' : InfinitePlace K} (h : IsReal w) (h' : IsComplex w') :\n    w ≠ w' := fun h_eq ↦ not_isReal_iff_isComplex.mpr h' (h_eq ▸ h)\n\n"}
{"name":"NumberField.InfinitePlace.disjoint_isReal_isComplex","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\n⊢ Disjoint (setOf fun x => NumberField.InfinitePlace.disjoint_isReal_isComplex.match_1 K (fun x => Prop) x fun w => w.IsReal) (setOf fun x => NumberField.InfinitePlace.disjoint_isReal_isComplex.match_1 K (fun x => Prop) x fun w => w.IsComplex)","decl":"variable (K) in\ntheorem disjoint_isReal_isComplex :\n    Disjoint {(w : InfinitePlace K) | IsReal w} {(w : InfinitePlace K) | IsComplex w} :=\n  Set.disjoint_iff.2 <| fun _ hw ↦ not_isReal_iff_isComplex.2 hw.2 hw.1\n\n"}
{"name":"NumberField.InfinitePlace.embedding_of_isReal_apply","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\nw : NumberField.InfinitePlace K\nhw : w.IsReal\nx : K\n⊢ Eq (↑((NumberField.InfinitePlace.embedding_of_isReal hw) x)) (w.embedding x)","decl":"@[simp]\ntheorem embedding_of_isReal_apply {w : InfinitePlace K} (hw : IsReal w) (x : K) :\n    ((embedding_of_isReal hw) x : ℂ) = (embedding w) x :=\n  ComplexEmbedding.IsReal.coe_embedding_apply (isReal_iff.mp hw) x\n\n"}
{"name":"NumberField.InfinitePlace.norm_embedding_of_isReal","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\nw : NumberField.InfinitePlace K\nhw : w.IsReal\nx : K\n⊢ Eq (Norm.norm ((NumberField.InfinitePlace.embedding_of_isReal hw) x)) (w x)","decl":"theorem norm_embedding_of_isReal {w : InfinitePlace K} (hw : IsReal w) (x : K) :\n    ‖embedding_of_isReal hw x‖ = w x := by\n  rw [← norm_embedding_eq, ← embedding_of_isReal_apply hw, Complex.norm_real]\n\n"}
{"name":"NumberField.InfinitePlace.isReal_of_mk_isReal","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\nφ : RingHom K Complex\nh : (NumberField.InfinitePlace.mk φ).IsReal\n⊢ NumberField.ComplexEmbedding.IsReal φ","decl":"@[simp]\ntheorem isReal_of_mk_isReal {φ : K →+* ℂ} (h : IsReal (mk φ)) :\n    ComplexEmbedding.IsReal φ := by\n  contrapose! h\n  rw [not_isReal_iff_isComplex]\n  exact ⟨φ, h, rfl⟩\n\n"}
{"name":"NumberField.InfinitePlace.isReal_mk_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\nφ : RingHom K Complex\n⊢ Iff (NumberField.InfinitePlace.mk φ).IsReal (NumberField.ComplexEmbedding.IsReal φ)","decl":"lemma isReal_mk_iff {φ : K →+* ℂ} :\n    IsReal (mk φ) ↔ ComplexEmbedding.IsReal φ :=\n  ⟨isReal_of_mk_isReal, fun H ↦ ⟨_, H, rfl⟩⟩\n\n"}
{"name":"NumberField.InfinitePlace.isComplex_mk_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\nφ : RingHom K Complex\n⊢ Iff (NumberField.InfinitePlace.mk φ).IsComplex (Not (NumberField.ComplexEmbedding.IsReal φ))","decl":"lemma isComplex_mk_iff {φ : K →+* ℂ} :\n    IsComplex (mk φ) ↔ ¬ ComplexEmbedding.IsReal φ :=\n  not_isReal_iff_isComplex.symm.trans isReal_mk_iff.not\n\n"}
{"name":"NumberField.InfinitePlace.not_isReal_of_mk_isComplex","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\nφ : RingHom K Complex\nh : (NumberField.InfinitePlace.mk φ).IsComplex\n⊢ Not (NumberField.ComplexEmbedding.IsReal φ)","decl":"@[simp]\ntheorem not_isReal_of_mk_isComplex {φ : K →+* ℂ} (h : IsComplex (mk φ)) :\n    ¬ ComplexEmbedding.IsReal φ := by rwa [← isComplex_mk_iff]\n\n"}
{"name":"NumberField.InfinitePlace.mult_pos","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\nw : NumberField.InfinitePlace K\n⊢ LT.lt 0 w.mult","decl":"theorem mult_pos {w : InfinitePlace K} : 0 < mult w := by\n  rw [mult]\n  split_ifs <;> norm_num\n\n"}
{"name":"NumberField.InfinitePlace.mult_ne_zero","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\nw : NumberField.InfinitePlace K\n⊢ Ne w.mult 0","decl":"@[simp]\ntheorem mult_ne_zero {w : InfinitePlace K} : mult w ≠ 0 := ne_of_gt mult_pos\n\n"}
{"name":"NumberField.InfinitePlace.one_le_mult","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\nw : NumberField.InfinitePlace K\n⊢ LE.le 1 ↑w.mult","decl":"theorem one_le_mult {w : InfinitePlace K} : (1 : ℝ) ≤ mult w := by\n  rw [← Nat.cast_one, Nat.cast_le]\n  exact mult_pos\n\n"}
{"name":"NumberField.InfinitePlace.card_filter_mk_eq","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝¹ : Field K\ninst✝ : NumberField K\nw : NumberField.InfinitePlace K\n⊢ Eq (Finset.filter (fun φ => Eq (NumberField.InfinitePlace.mk φ) w) Finset.univ).card w.mult","decl":"open scoped Classical in\ntheorem card_filter_mk_eq [NumberField K] (w : InfinitePlace K) : #{φ | mk φ = w} = mult w := by\n  conv_lhs =>\n    congr; congr; ext\n    rw [← mk_embedding w, mk_eq_iff, ComplexEmbedding.conjugate, star_involutive.eq_iff]\n  simp_rw [Finset.filter_or, Finset.filter_eq' _ (embedding w),\n    Finset.filter_eq' _ (ComplexEmbedding.conjugate (embedding w)),\n    Finset.mem_univ, ite_true, mult]\n  split_ifs with hw\n  · rw [ComplexEmbedding.isReal_iff.mp (isReal_iff.mp hw), Finset.union_idempotent,\n      Finset.card_singleton]\n  · refine Finset.card_pair ?_\n    rwa [Ne, eq_comm, ← ComplexEmbedding.isReal_iff, ← isReal_iff]\n\n"}
{"name":"NumberField.InfinitePlace.sum_mult_eq","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝¹ : Field K\ninst✝ : NumberField K\n⊢ Eq (Finset.univ.sum fun w => w.mult) (Module.finrank Rat K)","decl":"theorem sum_mult_eq [NumberField K] :\n    ∑ w : InfinitePlace K, mult w = Module.finrank ℚ K := by\n  classical\n  rw [← Embeddings.card K ℂ, Fintype.card, Finset.card_eq_sum_ones, ← Finset.univ.sum_fiberwise\n    (fun φ => InfinitePlace.mk φ)]\n  exact Finset.sum_congr rfl\n    (fun _ _ => by rw [Finset.sum_const, smul_eq_mul, mul_one, card_filter_mk_eq])\n\n"}
{"name":"NumberField.InfinitePlace.mkReal_coe","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\nφ : Subtype fun φ => NumberField.ComplexEmbedding.IsReal φ\n⊢ Eq (↑(NumberField.InfinitePlace.mkReal φ)) (NumberField.InfinitePlace.mk ↑φ)","decl":"@[simp]\ntheorem mkReal_coe (φ : { φ : K →+* ℂ // ComplexEmbedding.IsReal φ }) :\n    (mkReal φ : InfinitePlace K) = mk (φ : K →+* ℂ) := rfl\n\n"}
{"name":"NumberField.InfinitePlace.mkComplex_coe","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\nφ : Subtype fun φ => Not (NumberField.ComplexEmbedding.IsReal φ)\n⊢ Eq (↑(NumberField.InfinitePlace.mkComplex φ)) (NumberField.InfinitePlace.mk ↑φ)","decl":"@[simp]\ntheorem mkComplex_coe (φ : { φ : K →+* ℂ // ¬ComplexEmbedding.IsReal φ }) :\n    (mkComplex φ : InfinitePlace K) = mk (φ : K →+* ℂ) := rfl\n\n"}
{"name":"NumberField.InfinitePlace.prod_eq_abs_norm","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝¹ : Field K\ninst✝ : NumberField K\nx : K\n⊢ Eq (Finset.univ.prod fun w => HPow.hPow (w x) w.mult) ↑(abs ((Algebra.norm Rat) x))","decl":"/-- The infinite part of the product formula : for `x ∈ K`, we have `Π_w ‖x‖_w = |norm(x)|` where\n`‖·‖_w` is the normalized absolute value for `w`. -/\ntheorem prod_eq_abs_norm (x : K) :\n    ∏ w : InfinitePlace K, w x ^ mult w = abs (Algebra.norm ℚ x) := by\n  classical\n  convert (congr_arg Complex.abs (@Algebra.norm_eq_prod_embeddings ℚ _ _ _ _ ℂ _ _ _ _ _ x)).symm\n  · rw [map_prod, ← Fintype.prod_equiv RingHom.equivRatAlgHom (fun f => Complex.abs (f x))\n      (fun φ => Complex.abs (φ x)) fun _ => by simp [RingHom.equivRatAlgHom_apply]; rfl]\n    rw [← Finset.prod_fiberwise Finset.univ mk (fun φ => Complex.abs (φ x))]\n    have (w : InfinitePlace K) (φ) (hφ : φ ∈ ({φ | mk φ = w} : Finset _)) :\n        Complex.abs (φ x) = w x := by rw [← (Finset.mem_filter.mp hφ).2, apply]\n    simp_rw [Finset.prod_congr rfl (this _), Finset.prod_const, card_filter_mk_eq]\n  · rw [eq_ratCast, Rat.cast_abs, ← Complex.abs_ofReal, Complex.ofReal_ratCast]\n\n"}
{"name":"NumberField.InfinitePlace.one_le_of_lt_one","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝¹ : Field K\ninst✝ : NumberField K\nw : NumberField.InfinitePlace K\na : NumberField.RingOfIntegers K\nha : Ne a 0\nh : ∀ ⦃z : NumberField.InfinitePlace K⦄, Ne z w → LT.lt (z ↑a) 1\n⊢ LE.le 1 (w ↑a)","decl":"theorem one_le_of_lt_one {w : InfinitePlace K} {a : (𝓞 K)} (ha : a ≠ 0)\n    (h : ∀ ⦃z⦄, z ≠ w → z a < 1) : 1 ≤ w a := by\n  suffices (1 : ℝ) ≤ |Algebra.norm ℚ (a : K)| by\n    contrapose! this\n    rw [← InfinitePlace.prod_eq_abs_norm, ← Finset.prod_const_one]\n    refine Finset.prod_lt_prod_of_nonempty (fun _ _ ↦ ?_) (fun z _ ↦ ?_) Finset.univ_nonempty\n    · exact pow_pos (pos_iff.mpr ((Subalgebra.coe_eq_zero _).not.mpr ha)) _\n    · refine pow_lt_one₀ (apply_nonneg _ _) ?_ (by rw [mult]; split_ifs <;> norm_num)\n      by_cases hz : z = w\n      · rwa [hz]\n      · exact h hz\n  rw [← Algebra.coe_norm_int, ← Int.cast_one, ← Int.cast_abs, Rat.cast_intCast, Int.cast_le]\n  exact Int.one_le_abs (Algebra.norm_ne_zero_iff.mpr ha)\n\n"}
{"name":"NumberField.is_primitive_element_of_infinitePlace_lt","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝¹ : Field K\ninst✝ : NumberField K\nx : NumberField.RingOfIntegers K\nw : NumberField.InfinitePlace K\nh₁ : Ne x 0\nh₂ : ∀ ⦃w' : NumberField.InfinitePlace K⦄, Ne w' w → LT.lt (w' ↑x) 1\nh₃ : Or w.IsReal (LT.lt (abs (w.embedding ↑x).re) 1)\n⊢ Eq (IntermediateField.adjoin Rat (Singleton.singleton ↑x)) Top.top","decl":"open scoped IntermediateField in\ntheorem _root_.NumberField.is_primitive_element_of_infinitePlace_lt {x : 𝓞 K}\n    {w : InfinitePlace K} (h₁ : x ≠ 0) (h₂ : ∀ ⦃w'⦄, w' ≠ w → w' x < 1)\n    (h₃ : IsReal w ∨ |(w.embedding x).re| < 1) : ℚ⟮(x : K)⟯ = ⊤ := by\n  rw [Field.primitive_element_iff_algHom_eq_of_eval ℚ ℂ ?_ _ w.embedding.toRatAlgHom]\n  · intro ψ hψ\n    have h : 1 ≤ w x := one_le_of_lt_one h₁ h₂\n    have main : w = InfinitePlace.mk ψ.toRingHom := by\n      erw [← norm_embedding_eq, hψ] at h\n      contrapose! h\n      exact h₂ h.symm\n    rw [(mk_embedding w).symm, mk_eq_iff] at main\n    cases h₃ with\n    | inl hw =>\n      rw [conjugate_embedding_eq_of_isReal hw, or_self] at main\n      exact congr_arg RingHom.toRatAlgHom main\n    | inr hw =>\n      refine congr_arg RingHom.toRatAlgHom (main.resolve_right fun h' ↦ hw.not_le ?_)\n      have : (embedding w x).im = 0 := by\n        erw [← Complex.conj_eq_iff_im, RingHom.congr_fun h' x]\n        exact hψ.symm\n      rwa [← norm_embedding_eq, ← Complex.re_add_im (embedding w x), this, Complex.ofReal_zero,\n        zero_mul, add_zero, Complex.norm_eq_abs, Complex.abs_ofReal] at h\n  · exact fun x ↦ IsAlgClosed.splits_codomain (minpoly ℚ x)\n\n"}
{"name":"NumberField.adjoin_eq_top_of_infinitePlace_lt","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝¹ : Field K\ninst✝ : NumberField K\nx : NumberField.RingOfIntegers K\nw : NumberField.InfinitePlace K\nh₁ : Ne x 0\nh₂ : ∀ ⦃w' : NumberField.InfinitePlace K⦄, Ne w' w → LT.lt (w' ↑x) 1\nh₃ : Or w.IsReal (LT.lt (abs (w.embedding ↑x).re) 1)\n⊢ Eq (Algebra.adjoin Rat (Singleton.singleton ↑x)) Top.top","decl":"theorem _root_.NumberField.adjoin_eq_top_of_infinitePlace_lt {x : 𝓞 K} {w : InfinitePlace K}\n    (h₁ : x ≠ 0) (h₂ : ∀ ⦃w'⦄, w' ≠ w → w' x < 1) (h₃ : IsReal w ∨ |(w.embedding x).re| < 1) :\n    Algebra.adjoin ℚ {(x : K)} = ⊤ := by\n  rw [← IntermediateField.adjoin_simple_toSubalgebra_of_integral (IsIntegral.of_finite ℚ _)]\n  exact congr_arg IntermediateField.toSubalgebra <|\n    NumberField.is_primitive_element_of_infinitePlace_lt h₁ h₂ h₃\n\n"}
{"name":"NumberField.InfinitePlace.card_real_embeddings","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝¹ : Field K\ninst✝ : NumberField K\n⊢ Eq (Fintype.card (Subtype fun φ => NumberField.ComplexEmbedding.IsReal φ)) (NumberField.InfinitePlace.nrRealPlaces K)","decl":"open scoped Classical in\ntheorem card_real_embeddings :\n    card { φ : K →+* ℂ // ComplexEmbedding.IsReal φ } = nrRealPlaces K := Fintype.card_congr mkReal\n\n"}
{"name":"NumberField.InfinitePlace.card_eq_nrRealPlaces_add_nrComplexPlaces","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝¹ : Field K\ninst✝ : NumberField K\n⊢ Eq (Fintype.card (NumberField.InfinitePlace K)) (HAdd.hAdd (NumberField.InfinitePlace.nrRealPlaces K) (NumberField.InfinitePlace.nrComplexPlaces K))","decl":"theorem card_eq_nrRealPlaces_add_nrComplexPlaces :\n    Fintype.card (InfinitePlace K) = nrRealPlaces K + nrComplexPlaces K := by\n  classical\n  convert Fintype.card_subtype_or_disjoint (IsReal (K := K)) (IsComplex (K := K))\n    (disjoint_isReal_isComplex K) using 1\n  exact (Fintype.card_of_subtype _ (fun w ↦ ⟨fun _ ↦ isReal_or_isComplex w, fun _ ↦ by simp⟩)).symm\n\n"}
{"name":"NumberField.InfinitePlace.card_complex_embeddings","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝¹ : Field K\ninst✝ : NumberField K\n⊢ Eq (Fintype.card (Subtype fun φ => Not (NumberField.ComplexEmbedding.IsReal φ))) (HMul.hMul 2 (NumberField.InfinitePlace.nrComplexPlaces K))","decl":"open scoped Classical in\ntheorem card_complex_embeddings :\n    card { φ : K →+* ℂ // ¬ComplexEmbedding.IsReal φ } = 2 * nrComplexPlaces K := by\n  suffices ∀ w : { w : InfinitePlace K // IsComplex w },\n     #{φ : {φ //¬ ComplexEmbedding.IsReal φ} | mkComplex φ = w} = 2 by\n    rw [Fintype.card, Finset.card_eq_sum_ones, ← Finset.sum_fiberwise _ (fun φ => mkComplex φ)]\n    simp_rw [Finset.sum_const, this, smul_eq_mul, mul_one, Fintype.card, Finset.card_eq_sum_ones,\n      Finset.mul_sum, Finset.sum_const, smul_eq_mul, mul_one]\n  rintro ⟨w, hw⟩\n  convert card_filter_mk_eq w\n  · rw [← Fintype.card_subtype, ← Fintype.card_subtype]\n    refine Fintype.card_congr (Equiv.ofBijective ?_ ⟨fun _ _ h => ?_, fun ⟨φ, hφ⟩ => ?_⟩)\n    · exact fun ⟨φ, hφ⟩ => ⟨φ.val, by rwa [Subtype.ext_iff] at hφ⟩\n    · rwa [Subtype.mk_eq_mk, ← Subtype.ext_iff, ← Subtype.ext_iff] at h\n    · refine ⟨⟨⟨φ, not_isReal_of_mk_isComplex (hφ.symm ▸ hw)⟩, ?_⟩, rfl⟩\n      rwa [Subtype.ext_iff, mkComplex_coe]\n  · simp_rw [mult, not_isReal_iff_isComplex.mpr hw, ite_false]\n\n"}
{"name":"NumberField.InfinitePlace.card_add_two_mul_card_eq_rank","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝¹ : Field K\ninst✝ : NumberField K\n⊢ Eq (HAdd.hAdd (NumberField.InfinitePlace.nrRealPlaces K) (HMul.hMul 2 (NumberField.InfinitePlace.nrComplexPlaces K))) (Module.finrank Rat K)","decl":"theorem card_add_two_mul_card_eq_rank :\n    nrRealPlaces K + 2 * nrComplexPlaces K = finrank ℚ K := by\n  classical\n  rw [← card_real_embeddings, ← card_complex_embeddings, Fintype.card_subtype_compl,\n    ← Embeddings.card K ℂ, Nat.add_sub_of_le]\n  exact Fintype.card_subtype_le _\n\n"}
{"name":"NumberField.InfinitePlace.nrComplexPlaces_eq_zero_of_finrank_eq_one","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝¹ : Field K\ninst✝ : NumberField K\nh : Eq (Module.finrank Rat K) 1\n⊢ Eq (NumberField.InfinitePlace.nrComplexPlaces K) 0","decl":"theorem nrComplexPlaces_eq_zero_of_finrank_eq_one (h : finrank ℚ K = 1) :\n    nrComplexPlaces K = 0 := by linarith [card_add_two_mul_card_eq_rank K]\n\n"}
{"name":"NumberField.InfinitePlace.nrRealPlaces_eq_one_of_finrank_eq_one","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝¹ : Field K\ninst✝ : NumberField K\nh : Eq (Module.finrank Rat K) 1\n⊢ Eq (NumberField.InfinitePlace.nrRealPlaces K) 1","decl":"theorem nrRealPlaces_eq_one_of_finrank_eq_one (h : finrank ℚ K = 1) :\n    nrRealPlaces K = 1 := by\n  have := card_add_two_mul_card_eq_rank K\n  rwa [nrComplexPlaces_eq_zero_of_finrank_eq_one h, h, mul_zero, add_zero] at this\n\n"}
{"name":"NumberField.InfinitePlace.comap_mk","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝¹ : Field k\nK : Type u_2\ninst✝ : Field K\nφ : RingHom K Complex\nf : RingHom k K\n⊢ Eq ((NumberField.InfinitePlace.mk φ).comap f) (NumberField.InfinitePlace.mk (φ.comp f))","decl":"@[simp]\nlemma comap_mk (φ : K →+* ℂ) (f : k →+* K) : (mk φ).comap f = mk (φ.comp f) := rfl\n\n"}
{"name":"NumberField.InfinitePlace.comap_id","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\nw : NumberField.InfinitePlace K\n⊢ Eq (w.comap (RingHom.id K)) w","decl":"lemma comap_id (w : InfinitePlace K) : w.comap (RingHom.id K) = w := rfl\n\n"}
{"name":"NumberField.InfinitePlace.comap_comp","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝² : Field k\nK : Type u_2\ninst✝¹ : Field K\nF : Type u_3\ninst✝ : Field F\nw : NumberField.InfinitePlace K\nf : RingHom F K\ng : RingHom k F\n⊢ Eq (w.comap (f.comp g)) ((w.comap f).comap g)","decl":"lemma comap_comp (w : InfinitePlace K) (f : F →+* K) (g : k →+* F) :\n    w.comap (f.comp g) = (w.comap f).comap g := rfl\n\n"}
{"name":"NumberField.InfinitePlace.IsReal.comap","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝¹ : Field k\nK : Type u_2\ninst✝ : Field K\nf : RingHom k K\nw : NumberField.InfinitePlace K\nhφ : w.IsReal\n⊢ (w.comap f).IsReal","decl":"lemma IsReal.comap (f : k →+* K) {w : InfinitePlace K} (hφ : IsReal w) :\n    IsReal (w.comap f) := by\n  rw [← mk_embedding w, comap_mk, isReal_mk_iff]\n  rw [← mk_embedding w, isReal_mk_iff] at hφ\n  exact hφ.comp f\n\n"}
{"name":"NumberField.InfinitePlace.isReal_comap_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝¹ : Field k\nK : Type u_2\ninst✝ : Field K\nf : RingEquiv k K\nw : NumberField.InfinitePlace K\n⊢ Iff (w.comap ↑f).IsReal w.IsReal","decl":"lemma isReal_comap_iff (f : k ≃+* K) {w : InfinitePlace K} :\n    IsReal (w.comap (f : k →+* K)) ↔ IsReal w := by\n  rw [← mk_embedding w, comap_mk, isReal_mk_iff, isReal_mk_iff, ComplexEmbedding.isReal_comp_iff]\n\n"}
{"name":"NumberField.InfinitePlace.comap_surjective","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝³ : Field k\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra k K\ninst✝ : Algebra.IsAlgebraic k K\n⊢ Function.Surjective fun x => x.comap (algebraMap k K)","decl":"lemma comap_surjective [Algebra k K] [Algebra.IsAlgebraic k K] :\n    Function.Surjective (comap · (algebraMap k K)) := fun w ↦\n  letI := w.embedding.toAlgebra\n  ⟨mk (IsAlgClosed.lift (M := ℂ) (R := k)).toRingHom,\n    by simp [this, comap_mk, RingHom.algebraMap_toAlgebra]⟩\n\n"}
{"name":"NumberField.InfinitePlace.mult_comap_le","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝¹ : Field k\nK : Type u_2\ninst✝ : Field K\nf : RingHom k K\nw : NumberField.InfinitePlace K\n⊢ LE.le (w.comap f).mult w.mult","decl":"lemma mult_comap_le (f : k →+* K) (w : InfinitePlace K) : mult (w.comap f) ≤ mult w := by\n  rw [mult, mult]\n  split_ifs with h₁ h₂ h₂\n  pick_goal 3\n  · exact (h₁ (h₂.comap _)).elim\n  all_goals decide\n\n"}
{"name":"NumberField.InfinitePlace.card_mono","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝⁴ : Field k\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra k K\ninst✝¹ : NumberField k\ninst✝ : NumberField K\n⊢ LE.le (Fintype.card (NumberField.InfinitePlace k)) (Fintype.card (NumberField.InfinitePlace K))","decl":"lemma card_mono [NumberField k] [NumberField K] :\n    card (InfinitePlace k) ≤ card (InfinitePlace K) :=\n  have := Module.Finite.of_restrictScalars_finite ℚ k K\n  Fintype.card_le_of_surjective _ comap_surjective\n\n"}
{"name":"NumberField.InfinitePlace.instMulActionAlgEquiv_smul_coe_apply","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝² : Field k\nK : Type u_2\ninst✝¹ : Field K\ninst✝ : Algebra k K\nσ : AlgEquiv k K K\nw : NumberField.InfinitePlace K\na✝ : K\n⊢ Eq (↑(SMul.smul σ w) a✝) (↑w (σ.symm a✝))","decl":"/-- The action of the galois group on infinite places. -/\n@[simps! smul_coe_apply]\ninstance : MulAction (K ≃ₐ[k] K) (InfinitePlace K) where\n  smul := fun σ w ↦ w.comap σ.symm\n  one_smul := fun _ ↦ rfl\n  mul_smul := fun _ _ _ ↦ rfl\n\n"}
{"name":"NumberField.InfinitePlace.smul_eq_comap","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝² : Field k\nK : Type u_2\ninst✝¹ : Field K\ninst✝ : Algebra k K\nσ : AlgEquiv k K K\nw : NumberField.InfinitePlace K\n⊢ Eq (HSMul.hSMul σ w) (w.comap ↑σ.symm)","decl":"lemma smul_eq_comap : σ • w = w.comap σ.symm := rfl\n\n"}
{"name":"NumberField.InfinitePlace.smul_apply","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝² : Field k\nK : Type u_2\ninst✝¹ : Field K\ninst✝ : Algebra k K\nσ : AlgEquiv k K K\nw : NumberField.InfinitePlace K\nx : K\n⊢ Eq ((HSMul.hSMul σ w) x) (w (σ.symm x))","decl":"@[simp] lemma smul_apply (x) : (σ • w) x = w (σ.symm x) := rfl\n\n"}
{"name":"NumberField.InfinitePlace.smul_mk","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝² : Field k\nK : Type u_2\ninst✝¹ : Field K\ninst✝ : Algebra k K\nσ : AlgEquiv k K K\nφ : RingHom K Complex\n⊢ Eq (HSMul.hSMul σ (NumberField.InfinitePlace.mk φ)) (NumberField.InfinitePlace.mk (φ.comp ↑σ.symm))","decl":"@[simp] lemma smul_mk (φ : K →+* ℂ) : σ • mk φ = mk (φ.comp σ.symm) := rfl\n\n"}
{"name":"NumberField.InfinitePlace.comap_smul","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝³ : Field k\nK : Type u_2\ninst✝² : Field K\nF : Type u_3\ninst✝¹ : Field F\ninst✝ : Algebra k K\nσ : AlgEquiv k K K\nw : NumberField.InfinitePlace K\nf : RingHom F K\n⊢ Eq ((HSMul.hSMul σ w).comap f) (w.comap ((↑σ.symm).comp f))","decl":"lemma comap_smul {f : F →+* K} : (σ • w).comap f = w.comap (RingHom.comp σ.symm f) := rfl\n\n"}
{"name":"NumberField.InfinitePlace.isReal_smul_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝² : Field k\nK : Type u_2\ninst✝¹ : Field K\ninst✝ : Algebra k K\nσ : AlgEquiv k K K\nw : NumberField.InfinitePlace K\n⊢ Iff (HSMul.hSMul σ w).IsReal w.IsReal","decl":"lemma isReal_smul_iff : IsReal (σ • w) ↔ IsReal w := isReal_comap_iff (f := σ.symm.toRingEquiv)\n\n"}
{"name":"NumberField.InfinitePlace.isComplex_smul_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝² : Field k\nK : Type u_2\ninst✝¹ : Field K\ninst✝ : Algebra k K\nσ : AlgEquiv k K K\nw : NumberField.InfinitePlace K\n⊢ Iff (HSMul.hSMul σ w).IsComplex w.IsComplex","decl":"lemma isComplex_smul_iff : IsComplex (σ • w) ↔ IsComplex w := by\n  rw [← not_isReal_iff_isComplex, ← not_isReal_iff_isComplex, isReal_smul_iff]\n\n"}
{"name":"NumberField.InfinitePlace.ComplexEmbedding.exists_comp_symm_eq_of_comp_eq","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝³ : Field k\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra k K\ninst✝ : IsGalois k K\nφ ψ : RingHom K Complex\nh : Eq (φ.comp (algebraMap k K)) (ψ.comp (algebraMap k K))\n⊢ Exists fun σ => Eq (φ.comp ↑σ.symm) ψ","decl":"lemma ComplexEmbedding.exists_comp_symm_eq_of_comp_eq [IsGalois k K] (φ ψ : K →+* ℂ)\n    (h : φ.comp (algebraMap k K) = ψ.comp (algebraMap k K)) :\n    ∃ σ : K ≃ₐ[k] K, φ.comp σ.symm = ψ := by\n  letI := (φ.comp (algebraMap k K)).toAlgebra\n  letI := φ.toAlgebra\n  have : IsScalarTower k K ℂ := IsScalarTower.of_algebraMap_eq' rfl\n  let ψ' : K →ₐ[k] ℂ := { ψ with commutes' := fun r ↦ (RingHom.congr_fun h r).symm }\n  use (AlgHom.restrictNormal' ψ' K).symm\n  ext1 x\n  exact AlgHom.restrictNormal_commutes ψ' K x\n\n"}
{"name":"NumberField.InfinitePlace.exists_smul_eq_of_comap_eq","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝³ : Field k\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra k K\ninst✝ : IsGalois k K\nw w' : NumberField.InfinitePlace K\nh : Eq (w.comap (algebraMap k K)) (w'.comap (algebraMap k K))\n⊢ Exists fun σ => Eq (HSMul.hSMul σ w) w'","decl":"lemma exists_smul_eq_of_comap_eq [IsGalois k K] {w w' : InfinitePlace K}\n    (h : w.comap (algebraMap k K) = w'.comap (algebraMap k K)) : ∃ σ : K ≃ₐ[k] K, σ • w = w' := by\n  rw [← mk_embedding w, ← mk_embedding w', comap_mk, comap_mk, mk_eq_iff] at h\n  cases h with\n  | inl h =>\n    obtain ⟨σ, hσ⟩ := ComplexEmbedding.exists_comp_symm_eq_of_comp_eq w.embedding w'.embedding h\n    use σ\n    rw [← mk_embedding w, ← mk_embedding w', smul_mk, hσ]\n  | inr h =>\n    obtain ⟨σ, hσ⟩ := ComplexEmbedding.exists_comp_symm_eq_of_comp_eq\n      ((starRingEnd ℂ).comp (embedding w)) w'.embedding h\n    use σ\n    rw [← mk_embedding w, ← mk_embedding w', smul_mk, mk_eq_iff]\n    exact Or.inr hσ\n\n"}
{"name":"NumberField.InfinitePlace.mem_orbit_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝³ : Field k\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra k K\ninst✝ : IsGalois k K\nw w' : NumberField.InfinitePlace K\n⊢ Iff (Membership.mem (MulAction.orbit (AlgEquiv k K K) w) w') (Eq (w.comap (algebraMap k K)) (w'.comap (algebraMap k K)))","decl":"lemma mem_orbit_iff [IsGalois k K] {w w' : InfinitePlace K} :\n    w' ∈ MulAction.orbit (K ≃ₐ[k] K) w ↔ w.comap (algebraMap k K) = w'.comap (algebraMap k K) := by\n  refine ⟨?_, exists_smul_eq_of_comap_eq⟩\n  rintro ⟨σ, rfl : σ • w = w'⟩\n  rw [← mk_embedding w, comap_mk, smul_mk, comap_mk]\n  congr 1; ext1; simp\n\n"}
{"name":"NumberField.InfinitePlace.orbitRelEquiv_apply_mk''","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝³ : Field k\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra k K\ninst✝ : IsGalois k K\nw : NumberField.InfinitePlace K\n⊢ Eq (NumberField.InfinitePlace.orbitRelEquiv (Quotient.mk'' w)) (w.comap (algebraMap k K))","decl":"lemma orbitRelEquiv_apply_mk'' [IsGalois k K] (w : InfinitePlace K) :\n    orbitRelEquiv (Quotient.mk'' w) = comap w (algebraMap k K) := rfl\n\n"}
{"name":"NumberField.InfinitePlace.isUnramified_self","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\nw : NumberField.InfinitePlace K\n⊢ NumberField.InfinitePlace.IsUnramified K w","decl":"lemma isUnramified_self : IsUnramified K w := rfl\n\n"}
{"name":"NumberField.InfinitePlace.IsUnramified.eq","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝² : Field k\nK : Type u_2\ninst✝¹ : Field K\ninst✝ : Algebra k K\nw : NumberField.InfinitePlace K\nh : NumberField.InfinitePlace.IsUnramified k w\n⊢ Eq (w.comap (algebraMap k K)).mult w.mult","decl":"lemma IsUnramified.eq (h : IsUnramified k w) : mult (w.comap (algebraMap k K)) = mult w := h\n\n"}
{"name":"NumberField.InfinitePlace.isUnramified_iff_mult_le","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝² : Field k\nK : Type u_2\ninst✝¹ : Field K\ninst✝ : Algebra k K\nw : NumberField.InfinitePlace K\n⊢ Iff (NumberField.InfinitePlace.IsUnramified k w) (LE.le w.mult (w.comap (algebraMap k K)).mult)","decl":"lemma isUnramified_iff_mult_le :\n    IsUnramified k w ↔ mult w ≤ mult (w.comap (algebraMap k K)) := by\n  rw [IsUnramified, le_antisymm_iff, and_iff_right]\n  exact mult_comap_le _ _\n\n"}
{"name":"NumberField.InfinitePlace.IsUnramified.comap_algHom","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝⁴ : Field k\nK : Type u_2\ninst✝³ : Field K\nF : Type u_3\ninst✝² : Field F\ninst✝¹ : Algebra k K\ninst✝ : Algebra k F\nw : NumberField.InfinitePlace F\nh : NumberField.InfinitePlace.IsUnramified k w\nf : AlgHom k K F\n⊢ NumberField.InfinitePlace.IsUnramified k (w.comap ↑f)","decl":"lemma IsUnramified.comap_algHom {w : InfinitePlace F} (h : IsUnramified k w) (f : K →ₐ[k] F) :\n    IsUnramified k (w.comap (f : K →+* F)) := by\n  rw [InfinitePlace.isUnramified_iff_mult_le, ← InfinitePlace.comap_comp, f.comp_algebraMap, h.eq]\n  exact InfinitePlace.mult_comap_le _ _\n\n"}
{"name":"NumberField.InfinitePlace.IsUnramified.of_restrictScalars","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝⁶ : Field k\nK : Type u_2\ninst✝⁵ : Field K\nF : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Algebra k K\ninst✝² : Algebra k F\ninst✝¹ : Algebra K F\ninst✝ : IsScalarTower k K F\nw : NumberField.InfinitePlace F\nh : NumberField.InfinitePlace.IsUnramified k w\n⊢ NumberField.InfinitePlace.IsUnramified K w","decl":"lemma IsUnramified.of_restrictScalars {w : InfinitePlace F} (h : IsUnramified k w) :\n    IsUnramified K w := by\n  rw [InfinitePlace.isUnramified_iff_mult_le, ← h.eq, IsScalarTower.algebraMap_eq k K F,\n    InfinitePlace.comap_comp]\n  exact InfinitePlace.mult_comap_le _ _\n\n"}
{"name":"NumberField.InfinitePlace.IsUnramified.comap","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝⁶ : Field k\nK : Type u_2\ninst✝⁵ : Field K\nF : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Algebra k K\ninst✝² : Algebra k F\ninst✝¹ : Algebra K F\ninst✝ : IsScalarTower k K F\nw : NumberField.InfinitePlace F\nh : NumberField.InfinitePlace.IsUnramified k w\n⊢ NumberField.InfinitePlace.IsUnramified k (w.comap (algebraMap K F))","decl":"lemma IsUnramified.comap {w : InfinitePlace F} (h : IsUnramified k w) :\n    IsUnramified k (w.comap (algebraMap K F)) :=\n  h.comap_algHom (IsScalarTower.toAlgHom k K F)\n\n"}
{"name":"NumberField.InfinitePlace.not_isUnramified_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝² : Field k\nK : Type u_2\ninst✝¹ : Field K\ninst✝ : Algebra k K\nw : NumberField.InfinitePlace K\n⊢ Iff (Not (NumberField.InfinitePlace.IsUnramified k w)) (And w.IsComplex (w.comap (algebraMap k K)).IsReal)","decl":"lemma not_isUnramified_iff :\n    ¬ IsUnramified k w ↔ IsComplex w ∧ IsReal (w.comap (algebraMap k K)) := by\n  rw [IsUnramified, mult, mult, ← not_isReal_iff_isComplex]\n  split_ifs with h₁ h₂ h₂ <;>\n    simp only [not_true_eq_false, false_iff, and_self, forall_true_left, IsEmpty.forall_iff,\n      not_and, OfNat.one_ne_ofNat, not_false_eq_true, true_iff, OfNat.ofNat_ne_one, h₁, h₂]\n  exact h₁ (h₂.comap _)\n\n"}
{"name":"NumberField.InfinitePlace.isUnramified_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝² : Field k\nK : Type u_2\ninst✝¹ : Field K\ninst✝ : Algebra k K\nw : NumberField.InfinitePlace K\n⊢ Iff (NumberField.InfinitePlace.IsUnramified k w) (Or w.IsReal (w.comap (algebraMap k K)).IsComplex)","decl":"lemma isUnramified_iff :\n    IsUnramified k w ↔ IsReal w ∨ IsComplex (w.comap (algebraMap k K)) := by\n  rw [← not_iff_not, not_isUnramified_iff, not_or,\n    not_isReal_iff_isComplex, not_isComplex_iff_isReal]\n\n"}
{"name":"NumberField.InfinitePlace.IsReal.isUnramified","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝² : Field k\nK : Type u_2\ninst✝¹ : Field K\ninst✝ : Algebra k K\nw : NumberField.InfinitePlace K\nh : w.IsReal\n⊢ NumberField.InfinitePlace.IsUnramified k w","decl":"lemma IsReal.isUnramified (h : IsReal w) : IsUnramified k w := isUnramified_iff.mpr (Or.inl h)\n\n"}
{"name":"NumberField.ComplexEmbedding.IsConj.isUnramified_mk_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝² : Field k\nK : Type u_2\ninst✝¹ : Field K\ninst✝ : Algebra k K\nσ : AlgEquiv k K K\nφ : RingHom K Complex\nh : NumberField.ComplexEmbedding.IsConj φ σ\n⊢ Iff (NumberField.InfinitePlace.IsUnramified k (NumberField.InfinitePlace.mk φ)) (Eq σ 1)","decl":"lemma _root_.NumberField.ComplexEmbedding.IsConj.isUnramified_mk_iff\n    {φ : K →+* ℂ} (h : ComplexEmbedding.IsConj φ σ) :\n    IsUnramified k (mk φ) ↔ σ = 1 := by\n  rw [h.ext_iff, ComplexEmbedding.isConj_one_iff, ← not_iff_not, not_isUnramified_iff,\n    ← not_isReal_iff_isComplex, comap_mk, isReal_mk_iff, isReal_mk_iff, eq_true h.isReal_comp,\n    and_true]\n\n"}
{"name":"NumberField.InfinitePlace.isUnramified_mk_iff_forall_isConj","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝³ : Field k\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra k K\ninst✝ : IsGalois k K\nφ : RingHom K Complex\n⊢ Iff (NumberField.InfinitePlace.IsUnramified k (NumberField.InfinitePlace.mk φ)) (∀ (σ : AlgEquiv k K K), NumberField.ComplexEmbedding.IsConj φ σ → Eq σ 1)","decl":"lemma isUnramified_mk_iff_forall_isConj [IsGalois k K] {φ : K →+* ℂ} :\n    IsUnramified k (mk φ) ↔ ∀ σ : K ≃ₐ[k] K, ComplexEmbedding.IsConj φ σ → σ = 1 := by\n  refine ⟨fun H σ hσ ↦ hσ.isUnramified_mk_iff.mp H,\n    fun H ↦ ?_⟩\n  by_contra hφ\n  rw [not_isUnramified_iff] at hφ\n  rw [comap_mk, isReal_mk_iff, ← not_isReal_iff_isComplex, isReal_mk_iff,\n    ← ComplexEmbedding.isConj_one_iff (k := k)] at hφ\n  letI := (φ.comp (algebraMap k K)).toAlgebra\n  letI := φ.toAlgebra\n  have : IsScalarTower k K ℂ := IsScalarTower.of_algebraMap_eq' rfl\n  let φ' : K →ₐ[k] ℂ := { star φ with commutes' := fun r ↦ by simpa using RingHom.congr_fun hφ.2 r }\n  have : ComplexEmbedding.IsConj φ (AlgHom.restrictNormal' φ' K) :=\n    (RingHom.ext <| AlgHom.restrictNormal_commutes φ' K).symm\n  exact hφ.1 (H _ this ▸ this)\n\n"}
{"name":"NumberField.InfinitePlace.mem_stabilizer_mk_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝² : Field k\nK : Type u_2\ninst✝¹ : Field K\ninst✝ : Algebra k K\nφ : RingHom K Complex\nσ : AlgEquiv k K K\n⊢ Iff (Membership.mem (MulAction.stabilizer (AlgEquiv k K K) (NumberField.InfinitePlace.mk φ)) σ) (Or (Eq σ 1) (NumberField.ComplexEmbedding.IsConj φ σ))","decl":"lemma mem_stabilizer_mk_iff (φ : K →+* ℂ) (σ : K ≃ₐ[k] K) :\n    σ ∈ Stab (mk φ) ↔ σ = 1 ∨ ComplexEmbedding.IsConj φ σ := by\n  simp only [MulAction.mem_stabilizer_iff, smul_mk, mk_eq_iff]\n  rw [← ComplexEmbedding.isConj_symm, ComplexEmbedding.conjugate, star_eq_iff_star_eq]\n  refine or_congr ⟨fun H ↦ ?_, fun H ↦ H ▸ rfl⟩ Iff.rfl\n  exact congr_arg AlgEquiv.symm\n    (AlgEquiv.ext (g := AlgEquiv.refl) fun x ↦ φ.injective (RingHom.congr_fun H x))\n\n"}
{"name":"NumberField.InfinitePlace.IsUnramified.stabilizer_eq_bot","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝² : Field k\nK : Type u_2\ninst✝¹ : Field K\ninst✝ : Algebra k K\nw : NumberField.InfinitePlace K\nh : NumberField.InfinitePlace.IsUnramified k w\n⊢ Eq (MulAction.stabilizer (AlgEquiv k K K) w) Bot.bot","decl":"lemma IsUnramified.stabilizer_eq_bot (h : IsUnramified k w) : Stab w = ⊥ := by\n  rw [eq_bot_iff, ← mk_embedding w, SetLike.le_def]\n  simp only [mem_stabilizer_mk_iff, Subgroup.mem_bot, forall_eq_or_imp, true_and]\n  exact fun σ hσ ↦ hσ.isUnramified_mk_iff.mp ((mk_embedding w).symm ▸ h)\n\n"}
{"name":"NumberField.ComplexEmbedding.IsConj.coe_stabilzer_mk","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝² : Field k\nK : Type u_2\ninst✝¹ : Field K\ninst✝ : Algebra k K\nσ : AlgEquiv k K K\nφ : RingHom K Complex\nh : NumberField.ComplexEmbedding.IsConj φ σ\n⊢ Eq (↑(MulAction.stabilizer (AlgEquiv k K K) (NumberField.InfinitePlace.mk φ))) (Insert.insert 1 (Singleton.singleton σ))","decl":"lemma _root_.NumberField.ComplexEmbedding.IsConj.coe_stabilzer_mk\n    {φ : K →+* ℂ} (h : ComplexEmbedding.IsConj φ σ) :\n    (Stab (mk φ) : Set (K ≃ₐ[k] K)) = {1, σ} := by\n  ext\n  rw [SetLike.mem_coe, mem_stabilizer_mk_iff, Set.mem_insert_iff, Set.mem_singleton_iff,\n    ← h.ext_iff, eq_comm (a := σ)]\n\n"}
{"name":"NumberField.InfinitePlace.nat_card_stabilizer_eq_one_or_two","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝² : Field k\nK : Type u_2\ninst✝¹ : Field K\ninst✝ : Algebra k K\nw : NumberField.InfinitePlace K\n⊢ Or (Eq (Nat.card (Subtype fun x => Membership.mem (MulAction.stabilizer (AlgEquiv k K K) w) x)) 1) (Eq (Nat.card (Subtype fun x => Membership.mem (MulAction.stabilizer (AlgEquiv k K K) w) x)) 2)","decl":"lemma nat_card_stabilizer_eq_one_or_two :\n    Nat.card (Stab w) = 1 ∨ Nat.card (Stab w) = 2 := by\n  classical\n  rw [← SetLike.coe_sort_coe, ← mk_embedding w]\n  by_cases h : ∃ σ, ComplexEmbedding.IsConj (k := k) (embedding w) σ\n  · obtain ⟨σ, hσ⟩ := h\n    simp only [hσ.coe_stabilzer_mk, Nat.card_eq_fintype_card, card_ofFinset, Set.toFinset_singleton]\n    by_cases 1 = σ\n    · left; simp [*]\n    · right; simp [*]\n  · push_neg at h\n    left\n    trans Nat.card ({1} : Set (K ≃ₐ[k] K))\n    · congr with x\n      simp only [SetLike.mem_coe, mem_stabilizer_mk_iff, Set.mem_singleton_iff, or_iff_left_iff_imp,\n        h x, IsEmpty.forall_iff]\n    · simp\n\n"}
{"name":"NumberField.InfinitePlace.isUnramified_iff_stabilizer_eq_bot","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝³ : Field k\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra k K\nw : NumberField.InfinitePlace K\ninst✝ : IsGalois k K\n⊢ Iff (NumberField.InfinitePlace.IsUnramified k w) (Eq (MulAction.stabilizer (AlgEquiv k K K) w) Bot.bot)","decl":"lemma isUnramified_iff_stabilizer_eq_bot [IsGalois k K] : IsUnramified k w ↔ Stab w = ⊥ := by\n  rw [← mk_embedding w, isUnramified_mk_iff_forall_isConj]\n  simp only [eq_bot_iff, SetLike.le_def, mem_stabilizer_mk_iff,\n    Subgroup.mem_bot, forall_eq_or_imp, true_and]\n\n"}
{"name":"NumberField.InfinitePlace.isUnramified_iff_card_stabilizer_eq_one","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝³ : Field k\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra k K\nw : NumberField.InfinitePlace K\ninst✝ : IsGalois k K\n⊢ Iff (NumberField.InfinitePlace.IsUnramified k w) (Eq (Nat.card (Subtype fun x => Membership.mem (MulAction.stabilizer (AlgEquiv k K K) w) x)) 1)","decl":"lemma isUnramified_iff_card_stabilizer_eq_one [IsGalois k K] :\n    IsUnramified k w ↔ Nat.card (Stab w) = 1 := by\n  rw [isUnramified_iff_stabilizer_eq_bot, Subgroup.card_eq_one]\n\n"}
{"name":"NumberField.InfinitePlace.not_isUnramified_iff_card_stabilizer_eq_two","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝³ : Field k\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra k K\nw : NumberField.InfinitePlace K\ninst✝ : IsGalois k K\n⊢ Iff (Not (NumberField.InfinitePlace.IsUnramified k w)) (Eq (Nat.card (Subtype fun x => Membership.mem (MulAction.stabilizer (AlgEquiv k K K) w) x)) 2)","decl":"lemma not_isUnramified_iff_card_stabilizer_eq_two [IsGalois k K] :\n    ¬ IsUnramified k w ↔ Nat.card (Stab w) = 2 := by\n  rw [isUnramified_iff_card_stabilizer_eq_one]\n  obtain (e|e) := nat_card_stabilizer_eq_one_or_two k w <;> rw [e] <;> decide\n\n"}
{"name":"NumberField.InfinitePlace.card_stabilizer","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝³ : Field k\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra k K\nw : NumberField.InfinitePlace K\ninst✝ : IsGalois k K\n⊢ Eq (Nat.card (Subtype fun x => Membership.mem (MulAction.stabilizer (AlgEquiv k K K) w) x)) (ite (NumberField.InfinitePlace.IsUnramified k w) 1 2)","decl":"open scoped Classical in\nlemma card_stabilizer [IsGalois k K] :\n    Nat.card (Stab w) = if IsUnramified k w then 1 else 2 := by\n  split\n  · rwa [← isUnramified_iff_card_stabilizer_eq_one]\n  · rwa [← not_isUnramified_iff_card_stabilizer_eq_two]\n\n"}
{"name":"NumberField.InfinitePlace.even_nat_card_aut_of_not_isUnramified","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝³ : Field k\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra k K\nw : NumberField.InfinitePlace K\ninst✝ : IsGalois k K\nhw : Not (NumberField.InfinitePlace.IsUnramified k w)\n⊢ Even (Nat.card (AlgEquiv k K K))","decl":"lemma even_nat_card_aut_of_not_isUnramified [IsGalois k K] (hw : ¬ IsUnramified k w) :\n    Even (Nat.card <| K ≃ₐ[k] K) := by\n  by_cases H : Finite (K ≃ₐ[k] K)\n  · cases nonempty_fintype (K ≃ₐ[k] K)\n    rw [even_iff_two_dvd, ← not_isUnramified_iff_card_stabilizer_eq_two.mp hw]\n    exact Subgroup.card_subgroup_dvd_card (Stab w)\n  · convert Even.zero\n    by_contra e\n    exact H (Nat.finite_of_card_ne_zero e)\n\n"}
{"name":"NumberField.InfinitePlace.even_card_aut_of_not_isUnramified","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝⁴ : Field k\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra k K\nw : NumberField.InfinitePlace K\ninst✝¹ : IsGalois k K\ninst✝ : FiniteDimensional k K\nhw : Not (NumberField.InfinitePlace.IsUnramified k w)\n⊢ Even (Fintype.card (AlgEquiv k K K))","decl":"lemma even_card_aut_of_not_isUnramified [IsGalois k K] [FiniteDimensional k K]\n    (hw : ¬ IsUnramified k w) :\n    Even (Fintype.card <| K ≃ₐ[k] K) :=\n  Nat.card_eq_fintype_card (α := K ≃ₐ[k] K) ▸ even_nat_card_aut_of_not_isUnramified hw\n\n"}
{"name":"NumberField.InfinitePlace.even_finrank_of_not_isUnramified","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝³ : Field k\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra k K\nw : NumberField.InfinitePlace K\ninst✝ : IsGalois k K\nhw : Not (NumberField.InfinitePlace.IsUnramified k w)\n⊢ Even (Module.finrank k K)","decl":"lemma even_finrank_of_not_isUnramified [IsGalois k K]\n    (hw : ¬ IsUnramified k w) : Even (finrank k K) := by\n  by_cases FiniteDimensional k K\n  · exact IsGalois.card_aut_eq_finrank k K ▸ even_card_aut_of_not_isUnramified hw\n  · exact finrank_of_not_finite ‹_› ▸ Even.zero\n\n"}
{"name":"NumberField.InfinitePlace.isUnramified_smul_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝² : Field k\nK : Type u_2\ninst✝¹ : Field K\ninst✝ : Algebra k K\nσ : AlgEquiv k K K\nw : NumberField.InfinitePlace K\n⊢ Iff (NumberField.InfinitePlace.IsUnramified k (HSMul.hSMul σ w)) (NumberField.InfinitePlace.IsUnramified k w)","decl":"lemma isUnramified_smul_iff :\n    IsUnramified k (σ • w) ↔ IsUnramified k w := by\n  rw [isUnramified_iff, isUnramified_iff, isReal_smul_iff, comap_smul,\n    ← AlgEquiv.toAlgHom_toRingHom, AlgHom.comp_algebraMap]\n\n"}
{"name":"NumberField.InfinitePlace.isUnramifiedIn_comap","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝³ : Field k\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra k K\ninst✝ : IsGalois k K\nw : NumberField.InfinitePlace K\n⊢ Iff (NumberField.InfinitePlace.IsUnramifiedIn K (w.comap (algebraMap k K))) (NumberField.InfinitePlace.IsUnramified k w)","decl":"lemma isUnramifiedIn_comap [IsGalois k K] {w : InfinitePlace K} :\n    (w.comap (algebraMap k K)).IsUnramifiedIn K ↔ w.IsUnramified k := by\n  refine ⟨fun H ↦ H _ rfl, fun H v hv ↦ ?_⟩\n  obtain ⟨σ, rfl⟩ := exists_smul_eq_of_comap_eq hv\n  rwa [isUnramified_smul_iff] at H\n\n"}
{"name":"NumberField.InfinitePlace.even_card_aut_of_not_isUnramifiedIn","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝⁴ : Field k\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra k K\ninst✝¹ : IsGalois k K\ninst✝ : FiniteDimensional k K\nw : NumberField.InfinitePlace k\nhw : Not (NumberField.InfinitePlace.IsUnramifiedIn K w)\n⊢ Even (Fintype.card (AlgEquiv k K K))","decl":"lemma even_card_aut_of_not_isUnramifiedIn [IsGalois k K] [FiniteDimensional k K]\n    {w : InfinitePlace k} (hw : ¬ w.IsUnramifiedIn K) :\n    Even (Fintype.card <| K ≃ₐ[k] K) := by\n  obtain ⟨v, rfl⟩ := comap_surjective (K := K) w\n  rw [isUnramifiedIn_comap] at hw\n  exact even_card_aut_of_not_isUnramified hw\n\n"}
{"name":"NumberField.InfinitePlace.even_finrank_of_not_isUnramifiedIn","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝³ : Field k\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra k K\ninst✝ : IsGalois k K\nw : NumberField.InfinitePlace k\nhw : Not (NumberField.InfinitePlace.IsUnramifiedIn K w)\n⊢ Even (Module.finrank k K)","decl":"lemma even_finrank_of_not_isUnramifiedIn\n    [IsGalois k K] {w : InfinitePlace k} (hw : ¬ w.IsUnramifiedIn K) :\n    Even (finrank k K) := by\n  obtain ⟨v, rfl⟩ := comap_surjective (K := K) w\n  rw [isUnramifiedIn_comap] at hw\n  exact even_finrank_of_not_isUnramified hw\n\n"}
{"name":"NumberField.InfinitePlace.card_isUnramified","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝⁵ : Field k\nK : Type u_2\ninst✝⁴ : Field K\ninst✝³ : Algebra k K\ninst✝² : NumberField K\ninst✝¹ : NumberField k\ninst✝ : IsGalois k K\n⊢ Eq (Finset.filter (fun w => NumberField.InfinitePlace.IsUnramified k w) Finset.univ).card (HMul.hMul (Finset.filter (fun w => NumberField.InfinitePlace.IsUnramifiedIn K w) Finset.univ).card (Module.finrank k K))","decl":"open Finset in\nopen scoped Classical in\nlemma card_isUnramified [NumberField k] [IsGalois k K] :\n    #{w : InfinitePlace K | w.IsUnramified k} =\n      #{w : InfinitePlace k | w.IsUnramifiedIn K} * finrank k K := by\n  letI := Module.Finite.of_restrictScalars_finite ℚ k K\n  rw [← IsGalois.card_aut_eq_finrank,\n    Finset.card_eq_sum_card_fiberwise (f := (comap · (algebraMap k K)))\n    (t := {w : InfinitePlace k | w.IsUnramifiedIn K}), ← smul_eq_mul, ← sum_const]\n  · refine sum_congr rfl (fun w hw ↦ ?_)\n    obtain ⟨w, rfl⟩ := comap_surjective (K := K) w\n    simp only [mem_univ, forall_true_left, mem_filter, true_and] at hw\n    trans #(MulAction.orbit (K ≃ₐ[k] K) w).toFinset\n    · congr; ext w'\n      simp only [mem_univ, forall_true_left, filter_congr_decidable, mem_filter, true_and,\n        Set.mem_toFinset, mem_orbit_iff, @eq_comm _ (comap w' _), and_iff_right_iff_imp]\n      intro e; rwa [← isUnramifiedIn_comap, ← e]\n    · rw [← MulAction.card_orbit_mul_card_stabilizer_eq_card_group _ w,\n        ← Nat.card_eq_fintype_card (α := Stab w), card_stabilizer, if_pos,\n        mul_one, Set.toFinset_card]\n      rwa [← isUnramifiedIn_comap]\n  · simp [isUnramifiedIn_comap]\n\n"}
{"name":"NumberField.InfinitePlace.card_isUnramified_compl","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝⁵ : Field k\nK : Type u_2\ninst✝⁴ : Field K\ninst✝³ : Algebra k K\ninst✝² : NumberField K\ninst✝¹ : NumberField k\ninst✝ : IsGalois k K\n⊢ Eq (HasCompl.compl (Finset.filter (fun w => NumberField.InfinitePlace.IsUnramified k w) Finset.univ)).card (HMul.hMul (HasCompl.compl (Finset.filter (fun w => NumberField.InfinitePlace.IsUnramifiedIn K w) Finset.univ)).card (HDiv.hDiv (Module.finrank k K) 2))","decl":"open Finset in\nopen scoped Classical in\nlemma card_isUnramified_compl [NumberField k] [IsGalois k K] :\n    #({w : InfinitePlace K | w.IsUnramified k} : Finset _)ᶜ =\n      #({w : InfinitePlace k | w.IsUnramifiedIn K} : Finset _)ᶜ * (finrank k K / 2) := by\n  letI := Module.Finite.of_restrictScalars_finite ℚ k K\n  rw [← IsGalois.card_aut_eq_finrank,\n    Finset.card_eq_sum_card_fiberwise (f := (comap · (algebraMap k K)))\n    (t := ({w : InfinitePlace k | w.IsUnramifiedIn K}: Finset _)ᶜ), ← smul_eq_mul, ← sum_const]\n  · refine sum_congr rfl (fun w hw ↦ ?_)\n    obtain ⟨w, rfl⟩ := comap_surjective (K := K) w\n    simp only [mem_univ, forall_true_left, compl_filter, not_not, mem_filter, true_and] at hw\n    trans Finset.card (MulAction.orbit (K ≃ₐ[k] K) w).toFinset\n    · congr; ext w'\n      simp only [compl_filter, filter_congr_decidable, mem_filter, mem_univ, true_and,\n        @eq_comm _ (comap w' _), Set.mem_toFinset, mem_orbit_iff, and_iff_right_iff_imp]\n      intro e; rwa [← isUnramifiedIn_comap, ← e]\n    · rw [← MulAction.card_orbit_mul_card_stabilizer_eq_card_group _ w,\n        ← Nat.card_eq_fintype_card (α := Stab w), InfinitePlace.card_stabilizer, if_neg,\n        Nat.mul_div_cancel _ zero_lt_two, Set.toFinset_card]\n      rwa [← isUnramifiedIn_comap]\n  · simp [isUnramifiedIn_comap]\n\n"}
{"name":"NumberField.InfinitePlace.card_eq_card_isUnramifiedIn","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝⁵ : Field k\nK : Type u_2\ninst✝⁴ : Field K\ninst✝³ : Algebra k K\ninst✝² : NumberField K\ninst✝¹ : NumberField k\ninst✝ : IsGalois k K\n⊢ Eq (Fintype.card (NumberField.InfinitePlace K)) (HAdd.hAdd (HMul.hMul (Finset.filter (fun w => NumberField.InfinitePlace.IsUnramifiedIn K w) Finset.univ).card (Module.finrank k K)) (HMul.hMul (HasCompl.compl (Finset.filter (fun w => NumberField.InfinitePlace.IsUnramifiedIn K w) Finset.univ)).card (HDiv.hDiv (Module.finrank k K) 2)))","decl":"open scoped Classical in\nlemma card_eq_card_isUnramifiedIn [NumberField k] [IsGalois k K] :\n    Fintype.card (InfinitePlace K) =\n      #{w : InfinitePlace k | w.IsUnramifiedIn K} * finrank k K +\n      #({w : InfinitePlace k | w.IsUnramifiedIn K} : Finset _)ᶜ * (finrank k K / 2) := by\n  rw [← card_isUnramified, ← card_isUnramified_compl, Finset.card_add_card_compl]\n\n"}
{"name":"IsUnramifiedAtInfinitePlaces.isUnramified","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝² : Field k\nK : Type u_2\ninst✝¹ : Field K\ninst✝ : Algebra k K\nself : IsUnramifiedAtInfinitePlaces k K\nw : NumberField.InfinitePlace K\n⊢ NumberField.InfinitePlace.IsUnramified k w","decl":"/-- A field extension is unramified at infinite places if every infinite place is unramified. -/\nclass IsUnramifiedAtInfinitePlaces : Prop where\n  isUnramified : ∀ w : InfinitePlace K, w.IsUnramified k\n\n"}
{"name":"IsUnramifiedAtInfinitePlaces.id","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninst✝ : Field K\n⊢ IsUnramifiedAtInfinitePlaces K K","decl":"instance IsUnramifiedAtInfinitePlaces.id : IsUnramifiedAtInfinitePlaces K K where\n  isUnramified w := w.isUnramified_self\n\n"}
{"name":"IsUnramifiedAtInfinitePlaces.trans","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝⁶ : Field k\nK : Type u_2\ninst✝⁵ : Field K\nF : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Algebra k K\ninst✝² : Algebra k F\ninst✝¹ : Algebra K F\ninst✝ : IsScalarTower k K F\nh₁ : IsUnramifiedAtInfinitePlaces k K\nh₂ : IsUnramifiedAtInfinitePlaces K F\n⊢ IsUnramifiedAtInfinitePlaces k F","decl":"lemma IsUnramifiedAtInfinitePlaces.trans\n    [h₁ : IsUnramifiedAtInfinitePlaces k K] [h₂ : IsUnramifiedAtInfinitePlaces K F] :\n    IsUnramifiedAtInfinitePlaces k F where\n  isUnramified w :=\n    Eq.trans (IsScalarTower.algebraMap_eq k K F ▸ h₁.1 (w.comap (algebraMap _ _))) (h₂.1 w)\n\n"}
{"name":"IsUnramifiedAtInfinitePlaces.top","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝⁶ : Field k\nK : Type u_2\ninst✝⁵ : Field K\nF : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Algebra k K\ninst✝² : Algebra k F\ninst✝¹ : Algebra K F\ninst✝ : IsScalarTower k K F\nh : IsUnramifiedAtInfinitePlaces k F\n⊢ IsUnramifiedAtInfinitePlaces K F","decl":"lemma IsUnramifiedAtInfinitePlaces.top [h : IsUnramifiedAtInfinitePlaces k F] :\n    IsUnramifiedAtInfinitePlaces K F where\n  isUnramified w := (h.1 w).of_restrictScalars K\n\n"}
{"name":"IsUnramifiedAtInfinitePlaces.bot","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝⁷ : Field k\nK : Type u_2\ninst✝⁶ : Field K\nF : Type u_3\ninst✝⁵ : Field F\ninst✝⁴ : Algebra k K\ninst✝³ : Algebra k F\ninst✝² : Algebra K F\ninst✝¹ : IsScalarTower k K F\nh₁ : IsUnramifiedAtInfinitePlaces k F\ninst✝ : Algebra.IsAlgebraic K F\n⊢ IsUnramifiedAtInfinitePlaces k K","decl":"lemma IsUnramifiedAtInfinitePlaces.bot [h₁ : IsUnramifiedAtInfinitePlaces k F]\n    [Algebra.IsAlgebraic K F] :\n    IsUnramifiedAtInfinitePlaces k K where\n  isUnramified w := by\n    obtain ⟨w, rfl⟩ := InfinitePlace.comap_surjective (K := F) w\n    exact (h₁.1 w).comap K\n\n"}
{"name":"NumberField.InfinitePlace.isUnramified","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝³ : Field k\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra k K\ninst✝ : IsUnramifiedAtInfinitePlaces k K\nw : NumberField.InfinitePlace K\n⊢ NumberField.InfinitePlace.IsUnramified k w","decl":"lemma NumberField.InfinitePlace.isUnramified [IsUnramifiedAtInfinitePlaces k K]\n    (w : InfinitePlace K) : IsUnramified k w := IsUnramifiedAtInfinitePlaces.isUnramified w\n\n"}
{"name":"NumberField.InfinitePlace.isUnramifiedIn","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝³ : Field k\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra k K\ninst✝ : IsUnramifiedAtInfinitePlaces k K\nw : NumberField.InfinitePlace k\n⊢ NumberField.InfinitePlace.IsUnramifiedIn K w","decl":"lemma NumberField.InfinitePlace.isUnramifiedIn [IsUnramifiedAtInfinitePlaces k K]\n    (w : InfinitePlace k) : IsUnramifiedIn K w := fun v _ ↦ v.isUnramified k\n\n"}
{"name":"IsUnramifiedAtInfinitePlaces_of_odd_card_aut","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝⁴ : Field k\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra k K\ninst✝¹ : IsGalois k K\ninst✝ : FiniteDimensional k K\nh : Odd (Fintype.card (AlgEquiv k K K))\n⊢ IsUnramifiedAtInfinitePlaces k K","decl":"lemma IsUnramifiedAtInfinitePlaces_of_odd_card_aut [IsGalois k K] [FiniteDimensional k K]\n    (h : Odd (Fintype.card <| K ≃ₐ[k] K)) : IsUnramifiedAtInfinitePlaces k K :=\n  ⟨fun _ ↦ not_not.mp (Nat.not_even_iff_odd.2 h ∘ InfinitePlace.even_card_aut_of_not_isUnramified)⟩\n\n"}
{"name":"IsUnramifiedAtInfinitePlaces_of_odd_finrank","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝³ : Field k\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra k K\ninst✝ : IsGalois k K\nh : Odd (Module.finrank k K)\n⊢ IsUnramifiedAtInfinitePlaces k K","decl":"lemma IsUnramifiedAtInfinitePlaces_of_odd_finrank [IsGalois k K]\n    (h : Odd (Module.finrank k K)) : IsUnramifiedAtInfinitePlaces k K :=\n  ⟨fun _ ↦ not_not.mp (Nat.not_even_iff_odd.2 h ∘ InfinitePlace.even_finrank_of_not_isUnramified)⟩\n\n"}
{"name":"IsUnramifiedAtInfinitePlaces.card_infinitePlace","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninst✝⁶ : Field k\nK : Type u_2\ninst✝⁵ : Field K\ninst✝⁴ : Algebra k K\ninst✝³ : NumberField k\ninst✝² : NumberField K\ninst✝¹ : IsGalois k K\ninst✝ : IsUnramifiedAtInfinitePlaces k K\n⊢ Eq (Fintype.card (NumberField.InfinitePlace K)) (HMul.hMul (Fintype.card (NumberField.InfinitePlace k)) (Module.finrank k K))","decl":"open Module in\nlemma IsUnramifiedAtInfinitePlaces.card_infinitePlace [NumberField k] [NumberField K]\n    [IsGalois k K] [IsUnramifiedAtInfinitePlaces k K] :\n    Fintype.card (InfinitePlace K) = Fintype.card (InfinitePlace k) * finrank k K := by\n  classical\n  rw [InfinitePlace.card_eq_card_isUnramifiedIn (k := k) (K := K), Finset.filter_true_of_mem,\n    Finset.card_univ, Finset.card_eq_zero.mpr, zero_mul, add_zero]\n  · exact Finset.compl_univ\n  simp only [Finset.mem_univ, forall_true_left, Finset.filter_eq_empty_iff]\n  exact InfinitePlace.isUnramifiedIn K\n\n"}
{"name":"IsPrimitiveRoot.nrRealPlaces_eq_zero_of_two_lt","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nζ : K\nk : Nat\nhk : LT.lt 2 k\nhζ : IsPrimitiveRoot ζ k\n⊢ Eq (NumberField.InfinitePlace.nrRealPlaces K) 0","decl":"theorem nrRealPlaces_eq_zero_of_two_lt (hk : 2 < k) (hζ : IsPrimitiveRoot ζ k) :\n    NumberField.InfinitePlace.nrRealPlaces K = 0 := by\n  refine (@Fintype.card_eq_zero_iff _ (_)).2 ⟨fun ⟨w, hwreal⟩ ↦ ?_⟩\n  rw [NumberField.InfinitePlace.isReal_iff] at hwreal\n  let f := w.embedding\n  have hζ' : IsPrimitiveRoot (f ζ) k := hζ.map_of_injective f.injective\n  have him : (f ζ).im = 0 := by\n    rw [← Complex.conj_eq_iff_im, ← NumberField.ComplexEmbedding.conjugate_coe_eq]\n    congr\n  have hre : (f ζ).re = 1 ∨ (f ζ).re = -1 := by\n    rw [← Complex.abs_re_eq_abs] at him\n    have := Complex.norm_eq_one_of_pow_eq_one hζ'.pow_eq_one (by omega)\n    rwa [Complex.norm_eq_abs, ← him, ← abs_one, abs_eq_abs] at this\n  cases hre with\n  | inl hone =>\n    exact hζ'.ne_one (by omega) <| Complex.ext (by simp [hone]) (by simp [him])\n  | inr hnegone =>\n    replace hζ' := hζ'.eq_orderOf\n    simp only [show f ζ = -1 from Complex.ext (by simp [hnegone]) (by simp [him]),\n      orderOf_neg_one, ringChar.eq_zero, OfNat.zero_ne_ofNat, ↓reduceIte] at hζ'\n    omega\n\n"}
{"name":"Rat.infinitePlace_apply","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"v : NumberField.InfinitePlace Rat\nx : Rat\n⊢ Eq (v x) ↑(abs x)","decl":"@[simp]\nlemma infinitePlace_apply (v : InfinitePlace ℚ) (x : ℚ) : v x = |x| := by\n  rw [NumberField.InfinitePlace.coe_apply]\n  obtain ⟨_, _, rfl⟩ := v\n  simp\n\n"}
{"name":"Rat.instSubsingletonInfinitePlace","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"⊢ Subsingleton (NumberField.InfinitePlace Rat)","decl":"instance : Subsingleton (InfinitePlace ℚ) where\n  allEq a b := by ext; simp\n\n"}
{"name":"Rat.isReal_infinitePlace","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"⊢ Rat.infinitePlace.IsReal","decl":"lemma isReal_infinitePlace : InfinitePlace.IsReal (infinitePlace) :=\n  ⟨Rat.castHom ℂ, by ext; simp, rfl⟩\n\n"}
{"name":"NumberField.IsTotallyReal.isReal","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nself : NumberField.IsTotallyReal K\nv : NumberField.InfinitePlace K\n⊢ v.IsReal","decl":"/-- A number field `K` is totally real if all of its infinite places\nare real. In other words, the image of every ring homomorphism `K → ℂ`\nis a subset of `ℝ`. -/\nclass IsTotallyReal (K : Type*) [Field K] [NumberField K] where\n  isReal : ∀ v : InfinitePlace K, v.IsReal\n\n"}
{"name":"NumberField.instIsTotallyRealRat","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"⊢ NumberField.IsTotallyReal Rat","decl":"instance : IsTotallyReal ℚ where\n  isReal v := by\n    rw [Subsingleton.elim v Rat.infinitePlace]\n    exact Rat.isReal_infinitePlace\n\n"}
