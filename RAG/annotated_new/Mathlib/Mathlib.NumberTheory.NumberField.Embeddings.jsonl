{"name":"NumberField.Embeddings.card","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninstâœâ´ : Field K\ninstâœÂ³ : NumberField K\nA : Type u_2\ninstâœÂ² : Field A\ninstâœÂ¹ : CharZero A\ninstâœ : IsAlgClosed A\nâŠ¢ Eq (Fintype.card (RingHom K A)) (Module.finrank Rat K)","decl":"/-- The number of embeddings of a number field is equal to its finrank. -/\ntheorem card : Fintype.card (K â†’+* A) = finrank â„š K := by\n  rw [Fintype.ofEquiv_card RingHom.equivRatAlgHom.symm, AlgHom.card]\n\n"}
{"name":"NumberField.Embeddings.instNonemptyRingHom","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\nA : Type u_2\ninstâœ : Field A\nâŠ¢ Nonempty (RingHom K A)","decl":"instance : Nonempty (K â†’+* A) := by\n  rw [â† Fintype.card_pos_iff, NumberField.Embeddings.card K A]\n  exact Module.finrank_pos\n\n"}
{"name":"NumberField.Embeddings.range_eval_eq_rootSet_minpoly","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\nA : Type u_2\ninstâœâ´ : Field K\ninstâœÂ³ : NumberField K\ninstâœÂ² : Field A\ninstâœÂ¹ : Algebra Rat A\ninstâœ : IsAlgClosed A\nx : K\nâŠ¢ Eq (Set.range fun Ï† => Ï† x) ((minpoly Rat x).rootSet A)","decl":"/-- Let `A` be an algebraically closed field and let `x âˆˆ K`, with `K` a number field.\nThe images of `x` by the embeddings of `K` in `A` are exactly the roots in `A` of\nthe minimal polynomial of `x` over `â„š`. -/\ntheorem range_eval_eq_rootSet_minpoly :\n    (range fun Ï† : K â†’+* A => Ï† x) = (minpoly â„š x).rootSet A := by\n  convert (NumberField.isAlgebraic K).range_eval_eq_rootSet_minpoly A x using 1\n  ext a\n  exact âŸ¨fun âŸ¨Ï†, hÏ†âŸ© => âŸ¨Ï†.toRatAlgHom, hÏ†âŸ©, fun âŸ¨Ï†, hÏ†âŸ© => âŸ¨Ï†.toRingHom, hÏ†âŸ©âŸ©\n\n"}
{"name":"NumberField.Embeddings.coeff_bdd_of_norm_le","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninstâœâ´ : Field K\ninstâœÂ³ : NumberField K\nA : Type u_2\ninstâœÂ² : NormedField A\ninstâœÂ¹ : IsAlgClosed A\ninstâœ : NormedAlgebra Rat A\nB : Real\nx : K\nh : âˆ€ (Ï† : RingHom K A), LE.le (Norm.norm (Ï† x)) B\ni : Nat\nâŠ¢ LE.le (Norm.norm ((minpoly Rat x).coeff i)) (HMul.hMul (HPow.hPow (Max.max B 1) (Module.finrank Rat K)) â†‘((Module.finrank Rat K).choose (HDiv.hDiv (Module.finrank Rat K) 2)))","decl":"theorem coeff_bdd_of_norm_le {B : â„} {x : K} (h : âˆ€ Ï† : K â†’+* A, â€–Ï† xâ€– â‰¤ B) (i : â„•) :\n    â€–(minpoly â„š x).coeff iâ€– â‰¤ max B 1 ^ finrank â„š K * (finrank â„š K).choose (finrank â„š K / 2) := by\n  have hx := Algebra.IsSeparable.isIntegral â„š x\n  rw [â† norm_algebraMap' A, â† coeff_map (algebraMap â„š A)]\n  refine coeff_bdd_of_roots_le _ (minpoly.monic hx)\n      (IsAlgClosed.splits_codomain _) (minpoly.natDegree_le x) (fun z hz => ?_) i\n  classical\n  rw [â† Multiset.mem_toFinset] at hz\n  obtain âŸ¨Ï†, rflâŸ© := (range_eval_eq_rootSet_minpoly K A x).symm.subset hz\n  exact h Ï†\n\n"}
{"name":"NumberField.Embeddings.finite_of_norm_le","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninstâœâ´ : Field K\ninstâœÂ³ : NumberField K\nA : Type u_2\ninstâœÂ² : NormedField A\ninstâœÂ¹ : IsAlgClosed A\ninstâœ : NormedAlgebra Rat A\nB : Real\nâŠ¢ (setOf fun x => And (IsIntegral Int x) (âˆ€ (Ï† : RingHom K A), LE.le (Norm.norm (Ï† x)) B)).Finite","decl":"/-- Let `B` be a real number. The set of algebraic integers in `K` whose conjugates are all\nsmaller in norm than `B` is finite. -/\ntheorem finite_of_norm_le (B : â„) : {x : K | IsIntegral â„¤ x âˆ§ âˆ€ Ï† : K â†’+* A, â€–Ï† xâ€– â‰¤ B}.Finite := by\n  classical\n  let C := Nat.ceil (max B 1 ^ finrank â„š K * (finrank â„š K).choose (finrank â„š K / 2))\n  have := bUnion_roots_finite (algebraMap â„¤ K) (finrank â„š K) (finite_Icc (-C : â„¤) C)\n  refine this.subset fun x hx => ?_; simp_rw [mem_iUnion]\n  have h_map_â„š_minpoly := minpoly.isIntegrallyClosed_eq_field_fractions' â„š hx.1\n  refine âŸ¨_, âŸ¨?_, fun i => ?_âŸ©, mem_rootSet.2 âŸ¨minpoly.ne_zero hx.1, minpoly.aeval â„¤ xâŸ©âŸ©\n  Â· rw [â† (minpoly.monic hx.1).natDegree_map (algebraMap â„¤ â„š), â† h_map_â„š_minpoly]\n    exact minpoly.natDegree_le x\n  rw [mem_Icc, â† abs_le, â† @Int.cast_le â„]\n  refine (Eq.trans_le ?_ <| coeff_bdd_of_norm_le hx.2 i).trans (Nat.le_ceil _)\n  rw [h_map_â„š_minpoly, coeff_map, eq_intCast, Int.norm_cast_rat, Int.norm_eq_abs, Int.cast_abs]\n\n"}
{"name":"NumberField.Embeddings.pow_eq_one_of_norm_eq_one","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninstâœâ´ : Field K\ninstâœÂ³ : NumberField K\nA : Type u_2\ninstâœÂ² : NormedField A\ninstâœÂ¹ : IsAlgClosed A\ninstâœ : NormedAlgebra Rat A\nx : K\nhxi : IsIntegral Int x\nhx : âˆ€ (Ï† : RingHom K A), Eq (Norm.norm (Ï† x)) 1\nâŠ¢ Exists fun n => Exists fun x_1 => Eq (HPow.hPow x n) 1","decl":"/-- An algebraic integer whose conjugates are all of norm one is a root of unity. -/\ntheorem pow_eq_one_of_norm_eq_one {x : K} (hxi : IsIntegral â„¤ x) (hx : âˆ€ Ï† : K â†’+* A, â€–Ï† xâ€– = 1) :\n    âˆƒ (n : â„•) (_ : 0 < n), x ^ n = 1 := by\n  obtain âŸ¨a, -, b, -, habne, hâŸ© :=\n    @Set.Infinite.exists_ne_map_eq_of_mapsTo _ _ _ _ (x ^ Â· : â„• â†’ K) Set.infinite_univ\n      (by exact fun a _ => âŸ¨hxi.pow a, fun Ï† => by simp [hx Ï†]âŸ©) (finite_of_norm_le K A (1 : â„))\n  wlog hlt : b < a\n  Â· exact this K A hxi hx b a habne.symm h.symm (habne.lt_or_lt.resolve_right hlt)\n  refine âŸ¨a - b, tsub_pos_of_lt hlt, ?_âŸ©\n  rw [â† Nat.sub_add_cancel hlt.le, pow_add, mul_left_eq_selfâ‚€] at h\n  refine h.resolve_right fun hp => ?_\n  specialize hx (IsAlgClosed.lift (R := â„š)).toRingHom\n  rw [pow_eq_zero hp, map_zero, norm_zero] at hx; norm_num at hx\n\n"}
{"name":"NumberField.place_apply","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninstâœÂ² : Field K\nA : Type u_2\ninstâœÂ¹ : NormedDivisionRing A\ninstâœ : Nontrivial A\nÏ† : RingHom K A\nx : K\nâŠ¢ Eq ((NumberField.place Ï†) x) (Norm.norm (Ï† x))","decl":"@[simp]\ntheorem NumberField.place_apply (x : K) : (NumberField.place Ï†) x = norm (Ï† x) := rfl\n\n"}
{"name":"NumberField.ComplexEmbedding.conjugate_coe_eq","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninstâœ : Field K\nÏ† : RingHom K Complex\nx : K\nâŠ¢ Eq ((NumberField.ComplexEmbedding.conjugate Ï†) x) ((starRingEnd Complex) (Ï† x))","decl":"@[simp]\ntheorem conjugate_coe_eq (Ï† : K â†’+* â„‚) (x : K) : (conjugate Ï†) x = conj (Ï† x) := rfl\n\n"}
{"name":"NumberField.ComplexEmbedding.place_conjugate","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninstâœ : Field K\nÏ† : RingHom K Complex\nâŠ¢ Eq (NumberField.place (NumberField.ComplexEmbedding.conjugate Ï†)) (NumberField.place Ï†)","decl":"theorem place_conjugate (Ï† : K â†’+* â„‚) : place (conjugate Ï†) = place Ï† := by\n  ext; simp only [place_apply, norm_eq_abs, abs_conj, conjugate_coe_eq]\n\n"}
{"name":"NumberField.ComplexEmbedding.isReal_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninstâœ : Field K\nÏ† : RingHom K Complex\nâŠ¢ Iff (NumberField.ComplexEmbedding.IsReal Ï†) (Eq (NumberField.ComplexEmbedding.conjugate Ï†) Ï†)","decl":"theorem isReal_iff {Ï† : K â†’+* â„‚} : IsReal Ï† â†” conjugate Ï† = Ï† := isSelfAdjoint_iff\n\n"}
{"name":"NumberField.ComplexEmbedding.isReal_conjugate_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninstâœ : Field K\nÏ† : RingHom K Complex\nâŠ¢ Iff (NumberField.ComplexEmbedding.IsReal (NumberField.ComplexEmbedding.conjugate Ï†)) (NumberField.ComplexEmbedding.IsReal Ï†)","decl":"theorem isReal_conjugate_iff {Ï† : K â†’+* â„‚} : IsReal (conjugate Ï†) â†” IsReal Ï† :=\n  IsSelfAdjoint.star_iff\n\n"}
{"name":"NumberField.ComplexEmbedding.IsReal.coe_embedding_apply","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninstâœ : Field K\nÏ† : RingHom K Complex\nhÏ† : NumberField.ComplexEmbedding.IsReal Ï†\nx : K\nâŠ¢ Eq (â†‘(hÏ†.embedding x)) (Ï† x)","decl":"@[simp]\ntheorem IsReal.coe_embedding_apply {Ï† : K â†’+* â„‚} (hÏ† : IsReal Ï†) (x : K) :\n    (hÏ†.embedding x : â„‚) = Ï† x := by\n  apply Complex.ext\n  Â· rfl\n  Â· rw [ofReal_im, eq_comm, â† Complex.conj_eq_iff_im]\n    exact RingHom.congr_fun hÏ† x\n\n"}
{"name":"NumberField.ComplexEmbedding.IsReal.comp","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\nk : Type u_2\ninstâœ : Field k\nf : RingHom k K\nÏ† : RingHom K Complex\nhÏ† : NumberField.ComplexEmbedding.IsReal Ï†\nâŠ¢ NumberField.ComplexEmbedding.IsReal (Ï†.comp f)","decl":"lemma IsReal.comp (f : k â†’+* K) {Ï† : K â†’+* â„‚} (hÏ† : IsReal Ï†) :\n    IsReal (Ï†.comp f) := by ext1 x; simpa using RingHom.congr_fun hÏ† (f x)\n\n"}
{"name":"NumberField.ComplexEmbedding.isReal_comp_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\nk : Type u_2\ninstâœ : Field k\nf : RingEquiv k K\nÏ† : RingHom K Complex\nâŠ¢ Iff (NumberField.ComplexEmbedding.IsReal (Ï†.comp â†‘f)) (NumberField.ComplexEmbedding.IsReal Ï†)","decl":"lemma isReal_comp_iff {f : k â‰ƒ+* K} {Ï† : K â†’+* â„‚} :\n    IsReal (Ï†.comp (f : k â†’+* K)) â†” IsReal Ï† :=\n  âŸ¨fun H â†¦ by convert H.comp f.symm.toRingHom; ext1; simp, IsReal.comp _âŸ©\n\n"}
{"name":"NumberField.ComplexEmbedding.exists_comp_symm_eq_of_comp_eq","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninstâœÂ³ : Field K\nk : Type u_2\ninstâœÂ² : Field k\ninstâœÂ¹ : Algebra k K\ninstâœ : IsGalois k K\nÏ† Ïˆ : RingHom K Complex\nh : Eq (Ï†.comp (algebraMap k K)) (Ïˆ.comp (algebraMap k K))\nâŠ¢ Exists fun Ïƒ => Eq (Ï†.comp â†‘Ïƒ.symm) Ïˆ","decl":"lemma exists_comp_symm_eq_of_comp_eq [Algebra k K] [IsGalois k K] (Ï† Ïˆ : K â†’+* â„‚)\n    (h : Ï†.comp (algebraMap k K) = Ïˆ.comp (algebraMap k K)) :\n    âˆƒ Ïƒ : K â‰ƒâ‚[k] K, Ï†.comp Ïƒ.symm = Ïˆ := by\n  letI := (Ï†.comp (algebraMap k K)).toAlgebra\n  letI := Ï†.toAlgebra\n  have : IsScalarTower k K â„‚ := IsScalarTower.of_algebraMap_eq' rfl\n  let Ïˆ' : K â†’â‚[k] â„‚ := { Ïˆ with commutes' := fun r â†¦ (RingHom.congr_fun h r).symm }\n  use (AlgHom.restrictNormal' Ïˆ' K).symm\n  ext1 x\n  exact AlgHom.restrictNormal_commutes Ïˆ' K x\n\n"}
{"name":"NumberField.ComplexEmbedding.IsConj.eq","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninstâœÂ² : Field K\nk : Type u_2\ninstâœÂ¹ : Field k\ninstâœ : Algebra k K\nÏ† : RingHom K Complex\nÏƒ : AlgEquiv k K K\nh : NumberField.ComplexEmbedding.IsConj Ï† Ïƒ\nx : K\nâŠ¢ Eq (Ï† (Ïƒ x)) (Star.star (Ï† x))","decl":"lemma IsConj.eq (h : IsConj Ï† Ïƒ) (x) : Ï† (Ïƒ x) = star (Ï† x) := RingHom.congr_fun h.symm x\n\n"}
{"name":"NumberField.ComplexEmbedding.IsConj.ext","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninstâœÂ² : Field K\nk : Type u_2\ninstâœÂ¹ : Field k\ninstâœ : Algebra k K\nÏ† : RingHom K Complex\nÏƒâ‚ Ïƒâ‚‚ : AlgEquiv k K K\nhâ‚ : NumberField.ComplexEmbedding.IsConj Ï† Ïƒâ‚\nhâ‚‚ : NumberField.ComplexEmbedding.IsConj Ï† Ïƒâ‚‚\nâŠ¢ Eq Ïƒâ‚ Ïƒâ‚‚","decl":"lemma IsConj.ext {Ïƒâ‚ Ïƒâ‚‚ : K â‰ƒâ‚[k] K} (hâ‚ : IsConj Ï† Ïƒâ‚) (hâ‚‚ : IsConj Ï† Ïƒâ‚‚) : Ïƒâ‚ = Ïƒâ‚‚ :=\n  AlgEquiv.ext fun x â†¦ Ï†.injective ((hâ‚.eq x).trans (hâ‚‚.eq x).symm)\n\n"}
{"name":"NumberField.ComplexEmbedding.IsConj.ext_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninstâœÂ² : Field K\nk : Type u_2\ninstâœÂ¹ : Field k\ninstâœ : Algebra k K\nÏ† : RingHom K Complex\nÏƒâ‚ Ïƒâ‚‚ : AlgEquiv k K K\nhâ‚ : NumberField.ComplexEmbedding.IsConj Ï† Ïƒâ‚\nâŠ¢ Iff (Eq Ïƒâ‚ Ïƒâ‚‚) (NumberField.ComplexEmbedding.IsConj Ï† Ïƒâ‚‚)","decl":"lemma IsConj.ext_iff {Ïƒâ‚ Ïƒâ‚‚ : K â‰ƒâ‚[k] K} (hâ‚ : IsConj Ï† Ïƒâ‚) : Ïƒâ‚ = Ïƒâ‚‚ â†” IsConj Ï† Ïƒâ‚‚ :=\n  âŸ¨fun e â†¦ e â–¸ hâ‚, hâ‚.extâŸ©\n\n"}
{"name":"NumberField.ComplexEmbedding.IsConj.isReal_comp","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninstâœÂ² : Field K\nk : Type u_2\ninstâœÂ¹ : Field k\ninstâœ : Algebra k K\nÏ† : RingHom K Complex\nÏƒ : AlgEquiv k K K\nh : NumberField.ComplexEmbedding.IsConj Ï† Ïƒ\nâŠ¢ NumberField.ComplexEmbedding.IsReal (Ï†.comp (algebraMap k K))","decl":"lemma IsConj.isReal_comp (h : IsConj Ï† Ïƒ) : IsReal (Ï†.comp (algebraMap k K)) := by\n  ext1 x\n  simp only [conjugate_coe_eq, RingHom.coe_comp, Function.comp_apply, â† h.eq,\n    starRingEnd_apply, AlgEquiv.commutes]\n\n"}
{"name":"NumberField.ComplexEmbedding.isConj_one_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninstâœÂ² : Field K\nk : Type u_2\ninstâœÂ¹ : Field k\ninstâœ : Algebra k K\nÏ† : RingHom K Complex\nâŠ¢ Iff (NumberField.ComplexEmbedding.IsConj Ï† 1) (NumberField.ComplexEmbedding.IsReal Ï†)","decl":"lemma isConj_one_iff : IsConj Ï† (1 : K â‰ƒâ‚[k] K) â†” IsReal Ï† := Iff.rfl\n\n"}
{"name":"NumberField.ComplexEmbedding.IsReal.isConjGal_one","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninstâœÂ² : Field K\nk : Type u_2\ninstâœÂ¹ : Field k\ninstâœ : Algebra k K\nÏ† : RingHom K Complex\naâœ : NumberField.ComplexEmbedding.IsReal Ï†\nâŠ¢ NumberField.ComplexEmbedding.IsConj Ï† 1","decl":"alias âŸ¨_, IsReal.isConjGal_oneâŸ© := ComplexEmbedding.isConj_one_iff\n\n"}
{"name":"NumberField.ComplexEmbedding.IsConj.symm","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninstâœÂ² : Field K\nk : Type u_2\ninstâœÂ¹ : Field k\ninstâœ : Algebra k K\nÏ† : RingHom K Complex\nÏƒ : AlgEquiv k K K\nhÏƒ : NumberField.ComplexEmbedding.IsConj Ï† Ïƒ\nâŠ¢ NumberField.ComplexEmbedding.IsConj Ï† Ïƒ.symm","decl":"lemma IsConj.symm (hÏƒ : IsConj Ï† Ïƒ) :\n    IsConj Ï† Ïƒ.symm := RingHom.ext fun x â†¦ by simpa using congr_arg star (hÏƒ.eq (Ïƒ.symm x))\n\n"}
{"name":"NumberField.ComplexEmbedding.isConj_symm","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninstâœÂ² : Field K\nk : Type u_2\ninstâœÂ¹ : Field k\ninstâœ : Algebra k K\nÏ† : RingHom K Complex\nÏƒ : AlgEquiv k K K\nâŠ¢ Iff (NumberField.ComplexEmbedding.IsConj Ï† Ïƒ.symm) (NumberField.ComplexEmbedding.IsConj Ï† Ïƒ)","decl":"lemma isConj_symm : IsConj Ï† Ïƒ.symm â†” IsConj Ï† Ïƒ :=\n  âŸ¨IsConj.symm, IsConj.symmâŸ©\n\n"}
{"name":"instNonemptyInfinitePlaceOfNumberField","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nâŠ¢ Nonempty (NumberField.InfinitePlace K)","decl":"instance [NumberField K] : Nonempty (NumberField.InfinitePlace K) := Set.instNonemptyRange _\n\n"}
{"name":"NumberField.InfinitePlace.coe_apply","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_4\ninstâœ : Field K\nv : NumberField.InfinitePlace K\nx : K\nâŠ¢ Eq (v x) (â†‘v x)","decl":"lemma coe_apply {K : Type*} [Field K] (v : InfinitePlace K) (x : K) :\n  v x = v.1 x := rfl\n\n"}
{"name":"NumberField.InfinitePlace.ext","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_4\ninstâœ : Field K\nvâ‚ vâ‚‚ : NumberField.InfinitePlace K\nh : âˆ€ (k : K), Eq (vâ‚ k) (vâ‚‚ k)\nâŠ¢ Eq vâ‚ vâ‚‚","decl":"@[ext]\nlemma ext {K : Type*} [Field K] (vâ‚ vâ‚‚ : InfinitePlace K) (h : âˆ€ k, vâ‚ k = vâ‚‚ k) : vâ‚ = vâ‚‚ :=\n  Subtype.ext <| AbsoluteValue.ext h\n\n"}
{"name":"NumberField.InfinitePlace.ext_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_4\ninstâœ : Field K\nvâ‚ vâ‚‚ : NumberField.InfinitePlace K\nâŠ¢ Iff (Eq vâ‚ vâ‚‚) (âˆ€ (k : K), Eq (vâ‚ k) (vâ‚‚ k))","decl":"@[ext]\nlemma ext {K : Type*} [Field K] (vâ‚ vâ‚‚ : InfinitePlace K) (h : âˆ€ k, vâ‚ k = vâ‚‚ k) : vâ‚ = vâ‚‚ :=\n  Subtype.ext <| AbsoluteValue.ext h\n\n"}
{"name":"NumberField.InfinitePlace.instMonoidWithZeroHomClassReal","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nâŠ¢ MonoidWithZeroHomClass (NumberField.InfinitePlace K) K Real","decl":"instance : MonoidWithZeroHomClass (InfinitePlace K) K â„ where\n  map_mul w _ _ := w.1.map_mul _ _\n  map_one w := w.1.map_one\n  map_zero w := w.1.map_zero\n\n"}
{"name":"NumberField.InfinitePlace.instNonnegHomClassReal","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nâŠ¢ NonnegHomClass (NumberField.InfinitePlace K) K Real","decl":"instance : NonnegHomClass (InfinitePlace K) K â„ where\n  apply_nonneg w _ := w.1.nonneg _\n\n"}
{"name":"NumberField.InfinitePlace.apply","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nÏ† : RingHom K Complex\nx : K\nâŠ¢ Eq ((NumberField.InfinitePlace.mk Ï†) x) (Complex.abs (Ï† x))","decl":"@[simp]\ntheorem apply (Ï† : K â†’+* â„‚) (x : K) : (mk Ï†) x = Complex.abs (Ï† x) := rfl\n\n"}
{"name":"NumberField.InfinitePlace.mk_embedding","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nw : NumberField.InfinitePlace K\nâŠ¢ Eq (NumberField.InfinitePlace.mk w.embedding) w","decl":"@[simp]\ntheorem mk_embedding (w : InfinitePlace K) : mk (embedding w) = w := Subtype.ext w.2.choose_spec\n\n"}
{"name":"NumberField.InfinitePlace.mk_conjugate_eq","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nÏ† : RingHom K Complex\nâŠ¢ Eq (NumberField.InfinitePlace.mk (NumberField.ComplexEmbedding.conjugate Ï†)) (NumberField.InfinitePlace.mk Ï†)","decl":"@[simp]\ntheorem mk_conjugate_eq (Ï† : K â†’+* â„‚) : mk (ComplexEmbedding.conjugate Ï†) = mk Ï† := by\n  refine DFunLike.ext _ _ (fun x => ?_)\n  rw [apply, apply, ComplexEmbedding.conjugate_coe_eq, Complex.abs_conj]\n\n"}
{"name":"NumberField.InfinitePlace.norm_embedding_eq","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nw : NumberField.InfinitePlace K\nx : K\nâŠ¢ Eq (Norm.norm (w.embedding x)) (w x)","decl":"theorem norm_embedding_eq (w : InfinitePlace K) (x : K) :\n    â€–(embedding w) xâ€– = w x := by\n  nth_rewrite 2 [â† mk_embedding w]\n  rfl\n\n"}
{"name":"NumberField.InfinitePlace.eq_iff_eq","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nx : K\nr : Real\nâŠ¢ Iff (âˆ€ (w : NumberField.InfinitePlace K), Eq (w x) r) (âˆ€ (Ï† : RingHom K Complex), Eq (Norm.norm (Ï† x)) r)","decl":"theorem eq_iff_eq (x : K) (r : â„) : (âˆ€ w : InfinitePlace K, w x = r) â†” âˆ€ Ï† : K â†’+* â„‚, â€–Ï† xâ€– = r :=\n  âŸ¨fun hw Ï† => hw (mk Ï†), by rintro hÏ† âŸ¨w, âŸ¨Ï†, rflâŸ©âŸ©; exact hÏ† Ï†âŸ©\n\n"}
{"name":"NumberField.InfinitePlace.le_iff_le","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nx : K\nr : Real\nâŠ¢ Iff (âˆ€ (w : NumberField.InfinitePlace K), LE.le (w x) r) (âˆ€ (Ï† : RingHom K Complex), LE.le (Norm.norm (Ï† x)) r)","decl":"theorem le_iff_le (x : K) (r : â„) : (âˆ€ w : InfinitePlace K, w x â‰¤ r) â†” âˆ€ Ï† : K â†’+* â„‚, â€–Ï† xâ€– â‰¤ r :=\n  âŸ¨fun hw Ï† => hw (mk Ï†), by rintro hÏ† âŸ¨w, âŸ¨Ï†, rflâŸ©âŸ©; exact hÏ† Ï†âŸ©\n\n"}
{"name":"NumberField.InfinitePlace.pos_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nw : NumberField.InfinitePlace K\nx : K\nâŠ¢ Iff (LT.lt 0 (w x)) (Ne x 0)","decl":"theorem pos_iff {w : InfinitePlace K} {x : K} : 0 < w x â†” x â‰  0 := AbsoluteValue.pos_iff w.1\n\n"}
{"name":"NumberField.InfinitePlace.mk_eq_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nÏ† Ïˆ : RingHom K Complex\nâŠ¢ Iff (Eq (NumberField.InfinitePlace.mk Ï†) (NumberField.InfinitePlace.mk Ïˆ)) (Or (Eq Ï† Ïˆ) (Eq (NumberField.ComplexEmbedding.conjugate Ï†) Ïˆ))","decl":"@[simp]\ntheorem mk_eq_iff {Ï† Ïˆ : K â†’+* â„‚} : mk Ï† = mk Ïˆ â†” Ï† = Ïˆ âˆ¨ ComplexEmbedding.conjugate Ï† = Ïˆ := by\n  constructor\n  Â· -- We prove that the map Ïˆ âˆ˜ Ï†â»Â¹ between Ï†(K) and â„‚ is uniform continuous, thus it is either the\n    -- inclusion or the complex conjugation using `Complex.uniformContinuous_ringHom_eq_id_or_conj`\n    intro hâ‚€\n    obtain âŸ¨j, hiÏ†âŸ© := (Ï†.injective).hasLeftInverse\n    let Î¹ := RingEquiv.ofLeftInverse hiÏ†\n    have hlip : LipschitzWith 1 (RingHom.comp Ïˆ Î¹.symm.toRingHom) := by\n      change LipschitzWith 1 (Ïˆ âˆ˜ Î¹.symm)\n      apply LipschitzWith.of_dist_le_mul\n      intro x y\n      rw [NNReal.coe_one, one_mul, NormedField.dist_eq, Function.comp_apply, Function.comp_apply,\n        â† map_sub, â† map_sub]\n      apply le_of_eq\n      suffices â€–Ï† (Î¹.symm (x - y))â€– = â€–Ïˆ (Î¹.symm (x - y))â€– by\n        rw [â† this, â† RingEquiv.ofLeftInverse_apply hiÏ† _, RingEquiv.apply_symm_apply Î¹ _]\n        rfl\n      exact congrFun (congrArg (â†‘) hâ‚€) _\n    cases\n      Complex.uniformContinuous_ringHom_eq_id_or_conj Ï†.fieldRange hlip.uniformContinuous with\n    | inl h =>\n        left; ext1 x\n        conv_rhs => rw [â† hiÏ† x]\n        exact (congrFun h (Î¹ x)).symm\n    | inr h =>\n        right; ext1 x\n        conv_rhs => rw [â† hiÏ† x]\n        exact (congrFun h (Î¹ x)).symm\n  Â· rintro (âŸ¨hâŸ© | âŸ¨hâŸ©)\n    Â· exact congr_arg mk h\n    Â· rw [â† mk_conjugate_eq]\n      exact congr_arg mk h\n\n"}
{"name":"NumberField.InfinitePlace.embedding_mk_eq","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nÏ† : RingHom K Complex\nâŠ¢ Or (Eq (NumberField.InfinitePlace.mk Ï†).embedding Ï†) (Eq (NumberField.InfinitePlace.mk Ï†).embedding (NumberField.ComplexEmbedding.conjugate Ï†))","decl":"theorem embedding_mk_eq (Ï† : K â†’+* â„‚) :\n    embedding (mk Ï†) = Ï† âˆ¨ embedding (mk Ï†) = ComplexEmbedding.conjugate Ï† := by\n  rw [@eq_comm _ _ Ï†, @eq_comm _ _ (ComplexEmbedding.conjugate Ï†), â† mk_eq_iff, mk_embedding]\n\n"}
{"name":"NumberField.InfinitePlace.embedding_mk_eq_of_isReal","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nÏ† : RingHom K Complex\nh : NumberField.ComplexEmbedding.IsReal Ï†\nâŠ¢ Eq (NumberField.InfinitePlace.mk Ï†).embedding Ï†","decl":"@[simp]\ntheorem embedding_mk_eq_of_isReal {Ï† : K â†’+* â„‚} (h : ComplexEmbedding.IsReal Ï†) :\n    embedding (mk Ï†) = Ï† := by\n  have := embedding_mk_eq Ï†\n  rwa [ComplexEmbedding.isReal_iff.mp h, or_self] at this\n\n"}
{"name":"NumberField.InfinitePlace.isReal_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nw : NumberField.InfinitePlace K\nâŠ¢ Iff w.IsReal (NumberField.ComplexEmbedding.IsReal w.embedding)","decl":"theorem isReal_iff {w : InfinitePlace K} :\n    IsReal w â†” ComplexEmbedding.IsReal (embedding w) := by\n  refine âŸ¨?_, fun h => âŸ¨embedding w, h, mk_embedding wâŸ©âŸ©\n  rintro âŸ¨Ï†, âŸ¨hÏ†, rflâŸ©âŸ©\n  rwa [embedding_mk_eq_of_isReal hÏ†]\n\n"}
{"name":"NumberField.InfinitePlace.isComplex_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nw : NumberField.InfinitePlace K\nâŠ¢ Iff w.IsComplex (Not (NumberField.ComplexEmbedding.IsReal w.embedding))","decl":"theorem isComplex_iff {w : InfinitePlace K} :\n    IsComplex w â†” Â¬ComplexEmbedding.IsReal (embedding w) := by\n  refine âŸ¨?_, fun h => âŸ¨embedding w, h, mk_embedding wâŸ©âŸ©\n  rintro âŸ¨Ï†, âŸ¨hÏ†, rflâŸ©âŸ©\n  contrapose! hÏ†\n  cases mk_eq_iff.mp (mk_embedding (mk Ï†)) with\n  | inl h => rwa [h] at hÏ†\n  | inr h => rwa [â† ComplexEmbedding.isReal_conjugate_iff, h] at hÏ†\n\n"}
{"name":"NumberField.InfinitePlace.conjugate_embedding_eq_of_isReal","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nw : NumberField.InfinitePlace K\nh : w.IsReal\nâŠ¢ Eq (NumberField.ComplexEmbedding.conjugate w.embedding) w.embedding","decl":"@[simp]\ntheorem conjugate_embedding_eq_of_isReal {w : InfinitePlace K} (h : IsReal w) :\n    ComplexEmbedding.conjugate (embedding w) = embedding w :=\n  ComplexEmbedding.isReal_iff.mpr (isReal_iff.mp h)\n\n"}
{"name":"NumberField.InfinitePlace.not_isReal_iff_isComplex","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nw : NumberField.InfinitePlace K\nâŠ¢ Iff (Not w.IsReal) w.IsComplex","decl":"@[simp]\ntheorem not_isReal_iff_isComplex {w : InfinitePlace K} : Â¬IsReal w â†” IsComplex w := by\n  rw [isComplex_iff, isReal_iff]\n\n"}
{"name":"NumberField.InfinitePlace.not_isComplex_iff_isReal","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nw : NumberField.InfinitePlace K\nâŠ¢ Iff (Not w.IsComplex) w.IsReal","decl":"@[simp]\ntheorem not_isComplex_iff_isReal {w : InfinitePlace K} : Â¬IsComplex w â†” IsReal w := by\n  rw [isComplex_iff, isReal_iff, not_not]\n\n"}
{"name":"NumberField.InfinitePlace.isReal_or_isComplex","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nw : NumberField.InfinitePlace K\nâŠ¢ Or w.IsReal w.IsComplex","decl":"theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w âˆ¨ IsComplex w := by\n  rw [â† not_isReal_iff_isComplex]; exact em _\n\n"}
{"name":"NumberField.InfinitePlace.ne_of_isReal_isComplex","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nw w' : NumberField.InfinitePlace K\nh : w.IsReal\nh' : w'.IsComplex\nâŠ¢ Ne w w'","decl":"theorem ne_of_isReal_isComplex {w w' : InfinitePlace K} (h : IsReal w) (h' : IsComplex w') :\n    w â‰  w' := fun h_eq â†¦ not_isReal_iff_isComplex.mpr h' (h_eq â–¸ h)\n\n"}
{"name":"NumberField.InfinitePlace.disjoint_isReal_isComplex","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nâŠ¢ Disjoint (setOf fun x => NumberField.InfinitePlace.disjoint_isReal_isComplex.match_1 K (fun x => Prop) x fun w => w.IsReal) (setOf fun x => NumberField.InfinitePlace.disjoint_isReal_isComplex.match_1 K (fun x => Prop) x fun w => w.IsComplex)","decl":"variable (K) in\ntheorem disjoint_isReal_isComplex :\n    Disjoint {(w : InfinitePlace K) | IsReal w} {(w : InfinitePlace K) | IsComplex w} :=\n  Set.disjoint_iff.2 <| fun _ hw â†¦ not_isReal_iff_isComplex.2 hw.2 hw.1\n\n"}
{"name":"NumberField.InfinitePlace.embedding_of_isReal_apply","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nw : NumberField.InfinitePlace K\nhw : w.IsReal\nx : K\nâŠ¢ Eq (â†‘((NumberField.InfinitePlace.embedding_of_isReal hw) x)) (w.embedding x)","decl":"@[simp]\ntheorem embedding_of_isReal_apply {w : InfinitePlace K} (hw : IsReal w) (x : K) :\n    ((embedding_of_isReal hw) x : â„‚) = (embedding w) x :=\n  ComplexEmbedding.IsReal.coe_embedding_apply (isReal_iff.mp hw) x\n\n"}
{"name":"NumberField.InfinitePlace.norm_embedding_of_isReal","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nw : NumberField.InfinitePlace K\nhw : w.IsReal\nx : K\nâŠ¢ Eq (Norm.norm ((NumberField.InfinitePlace.embedding_of_isReal hw) x)) (w x)","decl":"theorem norm_embedding_of_isReal {w : InfinitePlace K} (hw : IsReal w) (x : K) :\n    â€–embedding_of_isReal hw xâ€– = w x := by\n  rw [â† norm_embedding_eq, â† embedding_of_isReal_apply hw, Complex.norm_real]\n\n"}
{"name":"NumberField.InfinitePlace.isReal_of_mk_isReal","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nÏ† : RingHom K Complex\nh : (NumberField.InfinitePlace.mk Ï†).IsReal\nâŠ¢ NumberField.ComplexEmbedding.IsReal Ï†","decl":"@[simp]\ntheorem isReal_of_mk_isReal {Ï† : K â†’+* â„‚} (h : IsReal (mk Ï†)) :\n    ComplexEmbedding.IsReal Ï† := by\n  contrapose! h\n  rw [not_isReal_iff_isComplex]\n  exact âŸ¨Ï†, h, rflâŸ©\n\n"}
{"name":"NumberField.InfinitePlace.isReal_mk_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nÏ† : RingHom K Complex\nâŠ¢ Iff (NumberField.InfinitePlace.mk Ï†).IsReal (NumberField.ComplexEmbedding.IsReal Ï†)","decl":"lemma isReal_mk_iff {Ï† : K â†’+* â„‚} :\n    IsReal (mk Ï†) â†” ComplexEmbedding.IsReal Ï† :=\n  âŸ¨isReal_of_mk_isReal, fun H â†¦ âŸ¨_, H, rflâŸ©âŸ©\n\n"}
{"name":"NumberField.InfinitePlace.isComplex_mk_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nÏ† : RingHom K Complex\nâŠ¢ Iff (NumberField.InfinitePlace.mk Ï†).IsComplex (Not (NumberField.ComplexEmbedding.IsReal Ï†))","decl":"lemma isComplex_mk_iff {Ï† : K â†’+* â„‚} :\n    IsComplex (mk Ï†) â†” Â¬ ComplexEmbedding.IsReal Ï† :=\n  not_isReal_iff_isComplex.symm.trans isReal_mk_iff.not\n\n"}
{"name":"NumberField.InfinitePlace.not_isReal_of_mk_isComplex","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nÏ† : RingHom K Complex\nh : (NumberField.InfinitePlace.mk Ï†).IsComplex\nâŠ¢ Not (NumberField.ComplexEmbedding.IsReal Ï†)","decl":"@[simp]\ntheorem not_isReal_of_mk_isComplex {Ï† : K â†’+* â„‚} (h : IsComplex (mk Ï†)) :\n    Â¬ ComplexEmbedding.IsReal Ï† := by rwa [â† isComplex_mk_iff]\n\n"}
{"name":"NumberField.InfinitePlace.mult_pos","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nw : NumberField.InfinitePlace K\nâŠ¢ LT.lt 0 w.mult","decl":"theorem mult_pos {w : InfinitePlace K} : 0 < mult w := by\n  rw [mult]\n  split_ifs <;> norm_num\n\n"}
{"name":"NumberField.InfinitePlace.mult_ne_zero","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nw : NumberField.InfinitePlace K\nâŠ¢ Ne w.mult 0","decl":"@[simp]\ntheorem mult_ne_zero {w : InfinitePlace K} : mult w â‰  0 := ne_of_gt mult_pos\n\n"}
{"name":"NumberField.InfinitePlace.one_le_mult","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nw : NumberField.InfinitePlace K\nâŠ¢ LE.le 1 â†‘w.mult","decl":"theorem one_le_mult {w : InfinitePlace K} : (1 : â„) â‰¤ mult w := by\n  rw [â† Nat.cast_one, Nat.cast_le]\n  exact mult_pos\n\n"}
{"name":"NumberField.InfinitePlace.card_filter_mk_eq","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nw : NumberField.InfinitePlace K\nâŠ¢ Eq (Finset.filter (fun Ï† => Eq (NumberField.InfinitePlace.mk Ï†) w) Finset.univ).card w.mult","decl":"open scoped Classical in\ntheorem card_filter_mk_eq [NumberField K] (w : InfinitePlace K) : #{Ï† | mk Ï† = w} = mult w := by\n  conv_lhs =>\n    congr; congr; ext\n    rw [â† mk_embedding w, mk_eq_iff, ComplexEmbedding.conjugate, star_involutive.eq_iff]\n  simp_rw [Finset.filter_or, Finset.filter_eq' _ (embedding w),\n    Finset.filter_eq' _ (ComplexEmbedding.conjugate (embedding w)),\n    Finset.mem_univ, ite_true, mult]\n  split_ifs with hw\n  Â· rw [ComplexEmbedding.isReal_iff.mp (isReal_iff.mp hw), Finset.union_idempotent,\n      Finset.card_singleton]\n  Â· refine Finset.card_pair ?_\n    rwa [Ne, eq_comm, â† ComplexEmbedding.isReal_iff, â† isReal_iff]\n\n"}
{"name":"NumberField.InfinitePlace.sum_mult_eq","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nâŠ¢ Eq (Finset.univ.sum fun w => w.mult) (Module.finrank Rat K)","decl":"theorem sum_mult_eq [NumberField K] :\n    âˆ‘ w : InfinitePlace K, mult w = Module.finrank â„š K := by\n  classical\n  rw [â† Embeddings.card K â„‚, Fintype.card, Finset.card_eq_sum_ones, â† Finset.univ.sum_fiberwise\n    (fun Ï† => InfinitePlace.mk Ï†)]\n  exact Finset.sum_congr rfl\n    (fun _ _ => by rw [Finset.sum_const, smul_eq_mul, mul_one, card_filter_mk_eq])\n\n"}
{"name":"NumberField.InfinitePlace.mkReal_coe","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nÏ† : Subtype fun Ï† => NumberField.ComplexEmbedding.IsReal Ï†\nâŠ¢ Eq (â†‘(NumberField.InfinitePlace.mkReal Ï†)) (NumberField.InfinitePlace.mk â†‘Ï†)","decl":"@[simp]\ntheorem mkReal_coe (Ï† : { Ï† : K â†’+* â„‚ // ComplexEmbedding.IsReal Ï† }) :\n    (mkReal Ï† : InfinitePlace K) = mk (Ï† : K â†’+* â„‚) := rfl\n\n"}
{"name":"NumberField.InfinitePlace.mkComplex_coe","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nÏ† : Subtype fun Ï† => Not (NumberField.ComplexEmbedding.IsReal Ï†)\nâŠ¢ Eq (â†‘(NumberField.InfinitePlace.mkComplex Ï†)) (NumberField.InfinitePlace.mk â†‘Ï†)","decl":"@[simp]\ntheorem mkComplex_coe (Ï† : { Ï† : K â†’+* â„‚ // Â¬ComplexEmbedding.IsReal Ï† }) :\n    (mkComplex Ï† : InfinitePlace K) = mk (Ï† : K â†’+* â„‚) := rfl\n\n"}
{"name":"NumberField.InfinitePlace.prod_eq_abs_norm","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : K\nâŠ¢ Eq (Finset.univ.prod fun w => HPow.hPow (w x) w.mult) â†‘(abs ((Algebra.norm Rat) x))","decl":"/-- The infinite part of the product formula : for `x âˆˆ K`, we have `Î _w â€–xâ€–_w = |norm(x)|` where\n`â€–Â·â€–_w` is the normalized absolute value for `w`. -/\ntheorem prod_eq_abs_norm (x : K) :\n    âˆ w : InfinitePlace K, w x ^ mult w = abs (Algebra.norm â„š x) := by\n  classical\n  convert (congr_arg Complex.abs (@Algebra.norm_eq_prod_embeddings â„š _ _ _ _ â„‚ _ _ _ _ _ x)).symm\n  Â· rw [map_prod, â† Fintype.prod_equiv RingHom.equivRatAlgHom (fun f => Complex.abs (f x))\n      (fun Ï† => Complex.abs (Ï† x)) fun _ => by simp [RingHom.equivRatAlgHom_apply]; rfl]\n    rw [â† Finset.prod_fiberwise Finset.univ mk (fun Ï† => Complex.abs (Ï† x))]\n    have (w : InfinitePlace K) (Ï†) (hÏ† : Ï† âˆˆ ({Ï† | mk Ï† = w} : Finset _)) :\n        Complex.abs (Ï† x) = w x := by rw [â† (Finset.mem_filter.mp hÏ†).2, apply]\n    simp_rw [Finset.prod_congr rfl (this _), Finset.prod_const, card_filter_mk_eq]\n  Â· rw [eq_ratCast, Rat.cast_abs, â† Complex.abs_ofReal, Complex.ofReal_ratCast]\n\n"}
{"name":"NumberField.InfinitePlace.one_le_of_lt_one","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nw : NumberField.InfinitePlace K\na : NumberField.RingOfIntegers K\nha : Ne a 0\nh : âˆ€ â¦ƒz : NumberField.InfinitePlace Kâ¦„, Ne z w â†’ LT.lt (z â†‘a) 1\nâŠ¢ LE.le 1 (w â†‘a)","decl":"theorem one_le_of_lt_one {w : InfinitePlace K} {a : (ğ“ K)} (ha : a â‰  0)\n    (h : âˆ€ â¦ƒzâ¦„, z â‰  w â†’ z a < 1) : 1 â‰¤ w a := by\n  suffices (1 : â„) â‰¤ |Algebra.norm â„š (a : K)| by\n    contrapose! this\n    rw [â† InfinitePlace.prod_eq_abs_norm, â† Finset.prod_const_one]\n    refine Finset.prod_lt_prod_of_nonempty (fun _ _ â†¦ ?_) (fun z _ â†¦ ?_) Finset.univ_nonempty\n    Â· exact pow_pos (pos_iff.mpr ((Subalgebra.coe_eq_zero _).not.mpr ha)) _\n    Â· refine pow_lt_oneâ‚€ (apply_nonneg _ _) ?_ (by rw [mult]; split_ifs <;> norm_num)\n      by_cases hz : z = w\n      Â· rwa [hz]\n      Â· exact h hz\n  rw [â† Algebra.coe_norm_int, â† Int.cast_one, â† Int.cast_abs, Rat.cast_intCast, Int.cast_le]\n  exact Int.one_le_abs (Algebra.norm_ne_zero_iff.mpr ha)\n\n"}
{"name":"NumberField.is_primitive_element_of_infinitePlace_lt","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : NumberField.RingOfIntegers K\nw : NumberField.InfinitePlace K\nhâ‚ : Ne x 0\nhâ‚‚ : âˆ€ â¦ƒw' : NumberField.InfinitePlace Kâ¦„, Ne w' w â†’ LT.lt (w' â†‘x) 1\nhâ‚ƒ : Or w.IsReal (LT.lt (abs (w.embedding â†‘x).re) 1)\nâŠ¢ Eq (IntermediateField.adjoin Rat (Singleton.singleton â†‘x)) Top.top","decl":"open scoped IntermediateField in\ntheorem _root_.NumberField.is_primitive_element_of_infinitePlace_lt {x : ğ“ K}\n    {w : InfinitePlace K} (hâ‚ : x â‰  0) (hâ‚‚ : âˆ€ â¦ƒw'â¦„, w' â‰  w â†’ w' x < 1)\n    (hâ‚ƒ : IsReal w âˆ¨ |(w.embedding x).re| < 1) : â„šâŸ®(x : K)âŸ¯ = âŠ¤ := by\n  rw [Field.primitive_element_iff_algHom_eq_of_eval â„š â„‚ ?_ _ w.embedding.toRatAlgHom]\n  Â· intro Ïˆ hÏˆ\n    have h : 1 â‰¤ w x := one_le_of_lt_one hâ‚ hâ‚‚\n    have main : w = InfinitePlace.mk Ïˆ.toRingHom := by\n      erw [â† norm_embedding_eq, hÏˆ] at h\n      contrapose! h\n      exact hâ‚‚ h.symm\n    rw [(mk_embedding w).symm, mk_eq_iff] at main\n    cases hâ‚ƒ with\n    | inl hw =>\n      rw [conjugate_embedding_eq_of_isReal hw, or_self] at main\n      exact congr_arg RingHom.toRatAlgHom main\n    | inr hw =>\n      refine congr_arg RingHom.toRatAlgHom (main.resolve_right fun h' â†¦ hw.not_le ?_)\n      have : (embedding w x).im = 0 := by\n        erw [â† Complex.conj_eq_iff_im, RingHom.congr_fun h' x]\n        exact hÏˆ.symm\n      rwa [â† norm_embedding_eq, â† Complex.re_add_im (embedding w x), this, Complex.ofReal_zero,\n        zero_mul, add_zero, Complex.norm_eq_abs, Complex.abs_ofReal] at h\n  Â· exact fun x â†¦ IsAlgClosed.splits_codomain (minpoly â„š x)\n\n"}
{"name":"NumberField.adjoin_eq_top_of_infinitePlace_lt","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : NumberField.RingOfIntegers K\nw : NumberField.InfinitePlace K\nhâ‚ : Ne x 0\nhâ‚‚ : âˆ€ â¦ƒw' : NumberField.InfinitePlace Kâ¦„, Ne w' w â†’ LT.lt (w' â†‘x) 1\nhâ‚ƒ : Or w.IsReal (LT.lt (abs (w.embedding â†‘x).re) 1)\nâŠ¢ Eq (Algebra.adjoin Rat (Singleton.singleton â†‘x)) Top.top","decl":"theorem _root_.NumberField.adjoin_eq_top_of_infinitePlace_lt {x : ğ“ K} {w : InfinitePlace K}\n    (hâ‚ : x â‰  0) (hâ‚‚ : âˆ€ â¦ƒw'â¦„, w' â‰  w â†’ w' x < 1) (hâ‚ƒ : IsReal w âˆ¨ |(w.embedding x).re| < 1) :\n    Algebra.adjoin â„š {(x : K)} = âŠ¤ := by\n  rw [â† IntermediateField.adjoin_simple_toSubalgebra_of_integral (IsIntegral.of_finite â„š _)]\n  exact congr_arg IntermediateField.toSubalgebra <|\n    NumberField.is_primitive_element_of_infinitePlace_lt hâ‚ hâ‚‚ hâ‚ƒ\n\n"}
{"name":"NumberField.InfinitePlace.card_real_embeddings","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nâŠ¢ Eq (Fintype.card (Subtype fun Ï† => NumberField.ComplexEmbedding.IsReal Ï†)) (NumberField.InfinitePlace.nrRealPlaces K)","decl":"open scoped Classical in\ntheorem card_real_embeddings :\n    card { Ï† : K â†’+* â„‚ // ComplexEmbedding.IsReal Ï† } = nrRealPlaces K := Fintype.card_congr mkReal\n\n"}
{"name":"NumberField.InfinitePlace.card_eq_nrRealPlaces_add_nrComplexPlaces","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nâŠ¢ Eq (Fintype.card (NumberField.InfinitePlace K)) (HAdd.hAdd (NumberField.InfinitePlace.nrRealPlaces K) (NumberField.InfinitePlace.nrComplexPlaces K))","decl":"theorem card_eq_nrRealPlaces_add_nrComplexPlaces :\n    Fintype.card (InfinitePlace K) = nrRealPlaces K + nrComplexPlaces K := by\n  classical\n  convert Fintype.card_subtype_or_disjoint (IsReal (K := K)) (IsComplex (K := K))\n    (disjoint_isReal_isComplex K) using 1\n  exact (Fintype.card_of_subtype _ (fun w â†¦ âŸ¨fun _ â†¦ isReal_or_isComplex w, fun _ â†¦ by simpâŸ©)).symm\n\n"}
{"name":"NumberField.InfinitePlace.card_complex_embeddings","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nâŠ¢ Eq (Fintype.card (Subtype fun Ï† => Not (NumberField.ComplexEmbedding.IsReal Ï†))) (HMul.hMul 2 (NumberField.InfinitePlace.nrComplexPlaces K))","decl":"open scoped Classical in\ntheorem card_complex_embeddings :\n    card { Ï† : K â†’+* â„‚ // Â¬ComplexEmbedding.IsReal Ï† } = 2 * nrComplexPlaces K := by\n  suffices âˆ€ w : { w : InfinitePlace K // IsComplex w },\n     #{Ï† : {Ï† //Â¬ ComplexEmbedding.IsReal Ï†} | mkComplex Ï† = w} = 2 by\n    rw [Fintype.card, Finset.card_eq_sum_ones, â† Finset.sum_fiberwise _ (fun Ï† => mkComplex Ï†)]\n    simp_rw [Finset.sum_const, this, smul_eq_mul, mul_one, Fintype.card, Finset.card_eq_sum_ones,\n      Finset.mul_sum, Finset.sum_const, smul_eq_mul, mul_one]\n  rintro âŸ¨w, hwâŸ©\n  convert card_filter_mk_eq w\n  Â· rw [â† Fintype.card_subtype, â† Fintype.card_subtype]\n    refine Fintype.card_congr (Equiv.ofBijective ?_ âŸ¨fun _ _ h => ?_, fun âŸ¨Ï†, hÏ†âŸ© => ?_âŸ©)\n    Â· exact fun âŸ¨Ï†, hÏ†âŸ© => âŸ¨Ï†.val, by rwa [Subtype.ext_iff] at hÏ†âŸ©\n    Â· rwa [Subtype.mk_eq_mk, â† Subtype.ext_iff, â† Subtype.ext_iff] at h\n    Â· refine âŸ¨âŸ¨âŸ¨Ï†, not_isReal_of_mk_isComplex (hÏ†.symm â–¸ hw)âŸ©, ?_âŸ©, rflâŸ©\n      rwa [Subtype.ext_iff, mkComplex_coe]\n  Â· simp_rw [mult, not_isReal_iff_isComplex.mpr hw, ite_false]\n\n"}
{"name":"NumberField.InfinitePlace.card_add_two_mul_card_eq_rank","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nâŠ¢ Eq (HAdd.hAdd (NumberField.InfinitePlace.nrRealPlaces K) (HMul.hMul 2 (NumberField.InfinitePlace.nrComplexPlaces K))) (Module.finrank Rat K)","decl":"theorem card_add_two_mul_card_eq_rank :\n    nrRealPlaces K + 2 * nrComplexPlaces K = finrank â„š K := by\n  classical\n  rw [â† card_real_embeddings, â† card_complex_embeddings, Fintype.card_subtype_compl,\n    â† Embeddings.card K â„‚, Nat.add_sub_of_le]\n  exact Fintype.card_subtype_le _\n\n"}
{"name":"NumberField.InfinitePlace.nrComplexPlaces_eq_zero_of_finrank_eq_one","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nh : Eq (Module.finrank Rat K) 1\nâŠ¢ Eq (NumberField.InfinitePlace.nrComplexPlaces K) 0","decl":"theorem nrComplexPlaces_eq_zero_of_finrank_eq_one (h : finrank â„š K = 1) :\n    nrComplexPlaces K = 0 := by linarith [card_add_two_mul_card_eq_rank K]\n\n"}
{"name":"NumberField.InfinitePlace.nrRealPlaces_eq_one_of_finrank_eq_one","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nh : Eq (Module.finrank Rat K) 1\nâŠ¢ Eq (NumberField.InfinitePlace.nrRealPlaces K) 1","decl":"theorem nrRealPlaces_eq_one_of_finrank_eq_one (h : finrank â„š K = 1) :\n    nrRealPlaces K = 1 := by\n  have := card_add_two_mul_card_eq_rank K\n  rwa [nrComplexPlaces_eq_zero_of_finrank_eq_one h, h, mul_zero, add_zero] at this\n\n"}
{"name":"NumberField.InfinitePlace.comap_mk","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ¹ : Field k\nK : Type u_2\ninstâœ : Field K\nÏ† : RingHom K Complex\nf : RingHom k K\nâŠ¢ Eq ((NumberField.InfinitePlace.mk Ï†).comap f) (NumberField.InfinitePlace.mk (Ï†.comp f))","decl":"@[simp]\nlemma comap_mk (Ï† : K â†’+* â„‚) (f : k â†’+* K) : (mk Ï†).comap f = mk (Ï†.comp f) := rfl\n\n"}
{"name":"NumberField.InfinitePlace.comap_id","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nw : NumberField.InfinitePlace K\nâŠ¢ Eq (w.comap (RingHom.id K)) w","decl":"lemma comap_id (w : InfinitePlace K) : w.comap (RingHom.id K) = w := rfl\n\n"}
{"name":"NumberField.InfinitePlace.comap_comp","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ² : Field k\nK : Type u_2\ninstâœÂ¹ : Field K\nF : Type u_3\ninstâœ : Field F\nw : NumberField.InfinitePlace K\nf : RingHom F K\ng : RingHom k F\nâŠ¢ Eq (w.comap (f.comp g)) ((w.comap f).comap g)","decl":"lemma comap_comp (w : InfinitePlace K) (f : F â†’+* K) (g : k â†’+* F) :\n    w.comap (f.comp g) = (w.comap f).comap g := rfl\n\n"}
{"name":"NumberField.InfinitePlace.IsReal.comap","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ¹ : Field k\nK : Type u_2\ninstâœ : Field K\nf : RingHom k K\nw : NumberField.InfinitePlace K\nhÏ† : w.IsReal\nâŠ¢ (w.comap f).IsReal","decl":"lemma IsReal.comap (f : k â†’+* K) {w : InfinitePlace K} (hÏ† : IsReal w) :\n    IsReal (w.comap f) := by\n  rw [â† mk_embedding w, comap_mk, isReal_mk_iff]\n  rw [â† mk_embedding w, isReal_mk_iff] at hÏ†\n  exact hÏ†.comp f\n\n"}
{"name":"NumberField.InfinitePlace.isReal_comap_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ¹ : Field k\nK : Type u_2\ninstâœ : Field K\nf : RingEquiv k K\nw : NumberField.InfinitePlace K\nâŠ¢ Iff (w.comap â†‘f).IsReal w.IsReal","decl":"lemma isReal_comap_iff (f : k â‰ƒ+* K) {w : InfinitePlace K} :\n    IsReal (w.comap (f : k â†’+* K)) â†” IsReal w := by\n  rw [â† mk_embedding w, comap_mk, isReal_mk_iff, isReal_mk_iff, ComplexEmbedding.isReal_comp_iff]\n\n"}
{"name":"NumberField.InfinitePlace.comap_surjective","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ³ : Field k\nK : Type u_2\ninstâœÂ² : Field K\ninstâœÂ¹ : Algebra k K\ninstâœ : Algebra.IsAlgebraic k K\nâŠ¢ Function.Surjective fun x => x.comap (algebraMap k K)","decl":"lemma comap_surjective [Algebra k K] [Algebra.IsAlgebraic k K] :\n    Function.Surjective (comap Â· (algebraMap k K)) := fun w â†¦\n  letI := w.embedding.toAlgebra\n  âŸ¨mk (IsAlgClosed.lift (M := â„‚) (R := k)).toRingHom,\n    by simp [this, comap_mk, RingHom.algebraMap_toAlgebra]âŸ©\n\n"}
{"name":"NumberField.InfinitePlace.mult_comap_le","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ¹ : Field k\nK : Type u_2\ninstâœ : Field K\nf : RingHom k K\nw : NumberField.InfinitePlace K\nâŠ¢ LE.le (w.comap f).mult w.mult","decl":"lemma mult_comap_le (f : k â†’+* K) (w : InfinitePlace K) : mult (w.comap f) â‰¤ mult w := by\n  rw [mult, mult]\n  split_ifs with hâ‚ hâ‚‚ hâ‚‚\n  pick_goal 3\n  Â· exact (hâ‚ (hâ‚‚.comap _)).elim\n  all_goals decide\n\n"}
{"name":"NumberField.InfinitePlace.card_mono","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœâ´ : Field k\nK : Type u_2\ninstâœÂ³ : Field K\ninstâœÂ² : Algebra k K\ninstâœÂ¹ : NumberField k\ninstâœ : NumberField K\nâŠ¢ LE.le (Fintype.card (NumberField.InfinitePlace k)) (Fintype.card (NumberField.InfinitePlace K))","decl":"lemma card_mono [NumberField k] [NumberField K] :\n    card (InfinitePlace k) â‰¤ card (InfinitePlace K) :=\n  have := Module.Finite.of_restrictScalars_finite â„š k K\n  Fintype.card_le_of_surjective _ comap_surjective\n\n"}
{"name":"NumberField.InfinitePlace.instMulActionAlgEquiv_smul_coe_apply","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ² : Field k\nK : Type u_2\ninstâœÂ¹ : Field K\ninstâœ : Algebra k K\nÏƒ : AlgEquiv k K K\nw : NumberField.InfinitePlace K\naâœ : K\nâŠ¢ Eq (â†‘(SMul.smul Ïƒ w) aâœ) (â†‘w (Ïƒ.symm aâœ))","decl":"/-- The action of the galois group on infinite places. -/\n@[simps! smul_coe_apply]\ninstance : MulAction (K â‰ƒâ‚[k] K) (InfinitePlace K) where\n  smul := fun Ïƒ w â†¦ w.comap Ïƒ.symm\n  one_smul := fun _ â†¦ rfl\n  mul_smul := fun _ _ _ â†¦ rfl\n\n"}
{"name":"NumberField.InfinitePlace.smul_eq_comap","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ² : Field k\nK : Type u_2\ninstâœÂ¹ : Field K\ninstâœ : Algebra k K\nÏƒ : AlgEquiv k K K\nw : NumberField.InfinitePlace K\nâŠ¢ Eq (HSMul.hSMul Ïƒ w) (w.comap â†‘Ïƒ.symm)","decl":"lemma smul_eq_comap : Ïƒ â€¢ w = w.comap Ïƒ.symm := rfl\n\n"}
{"name":"NumberField.InfinitePlace.smul_apply","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ² : Field k\nK : Type u_2\ninstâœÂ¹ : Field K\ninstâœ : Algebra k K\nÏƒ : AlgEquiv k K K\nw : NumberField.InfinitePlace K\nx : K\nâŠ¢ Eq ((HSMul.hSMul Ïƒ w) x) (w (Ïƒ.symm x))","decl":"@[simp] lemma smul_apply (x) : (Ïƒ â€¢ w) x = w (Ïƒ.symm x) := rfl\n\n"}
{"name":"NumberField.InfinitePlace.smul_mk","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ² : Field k\nK : Type u_2\ninstâœÂ¹ : Field K\ninstâœ : Algebra k K\nÏƒ : AlgEquiv k K K\nÏ† : RingHom K Complex\nâŠ¢ Eq (HSMul.hSMul Ïƒ (NumberField.InfinitePlace.mk Ï†)) (NumberField.InfinitePlace.mk (Ï†.comp â†‘Ïƒ.symm))","decl":"@[simp] lemma smul_mk (Ï† : K â†’+* â„‚) : Ïƒ â€¢ mk Ï† = mk (Ï†.comp Ïƒ.symm) := rfl\n\n"}
{"name":"NumberField.InfinitePlace.comap_smul","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ³ : Field k\nK : Type u_2\ninstâœÂ² : Field K\nF : Type u_3\ninstâœÂ¹ : Field F\ninstâœ : Algebra k K\nÏƒ : AlgEquiv k K K\nw : NumberField.InfinitePlace K\nf : RingHom F K\nâŠ¢ Eq ((HSMul.hSMul Ïƒ w).comap f) (w.comap ((â†‘Ïƒ.symm).comp f))","decl":"lemma comap_smul {f : F â†’+* K} : (Ïƒ â€¢ w).comap f = w.comap (RingHom.comp Ïƒ.symm f) := rfl\n\n"}
{"name":"NumberField.InfinitePlace.isReal_smul_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ² : Field k\nK : Type u_2\ninstâœÂ¹ : Field K\ninstâœ : Algebra k K\nÏƒ : AlgEquiv k K K\nw : NumberField.InfinitePlace K\nâŠ¢ Iff (HSMul.hSMul Ïƒ w).IsReal w.IsReal","decl":"lemma isReal_smul_iff : IsReal (Ïƒ â€¢ w) â†” IsReal w := isReal_comap_iff (f := Ïƒ.symm.toRingEquiv)\n\n"}
{"name":"NumberField.InfinitePlace.isComplex_smul_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ² : Field k\nK : Type u_2\ninstâœÂ¹ : Field K\ninstâœ : Algebra k K\nÏƒ : AlgEquiv k K K\nw : NumberField.InfinitePlace K\nâŠ¢ Iff (HSMul.hSMul Ïƒ w).IsComplex w.IsComplex","decl":"lemma isComplex_smul_iff : IsComplex (Ïƒ â€¢ w) â†” IsComplex w := by\n  rw [â† not_isReal_iff_isComplex, â† not_isReal_iff_isComplex, isReal_smul_iff]\n\n"}
{"name":"NumberField.InfinitePlace.ComplexEmbedding.exists_comp_symm_eq_of_comp_eq","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ³ : Field k\nK : Type u_2\ninstâœÂ² : Field K\ninstâœÂ¹ : Algebra k K\ninstâœ : IsGalois k K\nÏ† Ïˆ : RingHom K Complex\nh : Eq (Ï†.comp (algebraMap k K)) (Ïˆ.comp (algebraMap k K))\nâŠ¢ Exists fun Ïƒ => Eq (Ï†.comp â†‘Ïƒ.symm) Ïˆ","decl":"lemma ComplexEmbedding.exists_comp_symm_eq_of_comp_eq [IsGalois k K] (Ï† Ïˆ : K â†’+* â„‚)\n    (h : Ï†.comp (algebraMap k K) = Ïˆ.comp (algebraMap k K)) :\n    âˆƒ Ïƒ : K â‰ƒâ‚[k] K, Ï†.comp Ïƒ.symm = Ïˆ := by\n  letI := (Ï†.comp (algebraMap k K)).toAlgebra\n  letI := Ï†.toAlgebra\n  have : IsScalarTower k K â„‚ := IsScalarTower.of_algebraMap_eq' rfl\n  let Ïˆ' : K â†’â‚[k] â„‚ := { Ïˆ with commutes' := fun r â†¦ (RingHom.congr_fun h r).symm }\n  use (AlgHom.restrictNormal' Ïˆ' K).symm\n  ext1 x\n  exact AlgHom.restrictNormal_commutes Ïˆ' K x\n\n"}
{"name":"NumberField.InfinitePlace.exists_smul_eq_of_comap_eq","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ³ : Field k\nK : Type u_2\ninstâœÂ² : Field K\ninstâœÂ¹ : Algebra k K\ninstâœ : IsGalois k K\nw w' : NumberField.InfinitePlace K\nh : Eq (w.comap (algebraMap k K)) (w'.comap (algebraMap k K))\nâŠ¢ Exists fun Ïƒ => Eq (HSMul.hSMul Ïƒ w) w'","decl":"lemma exists_smul_eq_of_comap_eq [IsGalois k K] {w w' : InfinitePlace K}\n    (h : w.comap (algebraMap k K) = w'.comap (algebraMap k K)) : âˆƒ Ïƒ : K â‰ƒâ‚[k] K, Ïƒ â€¢ w = w' := by\n  rw [â† mk_embedding w, â† mk_embedding w', comap_mk, comap_mk, mk_eq_iff] at h\n  cases h with\n  | inl h =>\n    obtain âŸ¨Ïƒ, hÏƒâŸ© := ComplexEmbedding.exists_comp_symm_eq_of_comp_eq w.embedding w'.embedding h\n    use Ïƒ\n    rw [â† mk_embedding w, â† mk_embedding w', smul_mk, hÏƒ]\n  | inr h =>\n    obtain âŸ¨Ïƒ, hÏƒâŸ© := ComplexEmbedding.exists_comp_symm_eq_of_comp_eq\n      ((starRingEnd â„‚).comp (embedding w)) w'.embedding h\n    use Ïƒ\n    rw [â† mk_embedding w, â† mk_embedding w', smul_mk, mk_eq_iff]\n    exact Or.inr hÏƒ\n\n"}
{"name":"NumberField.InfinitePlace.mem_orbit_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ³ : Field k\nK : Type u_2\ninstâœÂ² : Field K\ninstâœÂ¹ : Algebra k K\ninstâœ : IsGalois k K\nw w' : NumberField.InfinitePlace K\nâŠ¢ Iff (Membership.mem (MulAction.orbit (AlgEquiv k K K) w) w') (Eq (w.comap (algebraMap k K)) (w'.comap (algebraMap k K)))","decl":"lemma mem_orbit_iff [IsGalois k K] {w w' : InfinitePlace K} :\n    w' âˆˆ MulAction.orbit (K â‰ƒâ‚[k] K) w â†” w.comap (algebraMap k K) = w'.comap (algebraMap k K) := by\n  refine âŸ¨?_, exists_smul_eq_of_comap_eqâŸ©\n  rintro âŸ¨Ïƒ, rfl : Ïƒ â€¢ w = w'âŸ©\n  rw [â† mk_embedding w, comap_mk, smul_mk, comap_mk]\n  congr 1; ext1; simp\n\n"}
{"name":"NumberField.InfinitePlace.orbitRelEquiv_apply_mk''","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ³ : Field k\nK : Type u_2\ninstâœÂ² : Field K\ninstâœÂ¹ : Algebra k K\ninstâœ : IsGalois k K\nw : NumberField.InfinitePlace K\nâŠ¢ Eq (NumberField.InfinitePlace.orbitRelEquiv (Quotient.mk'' w)) (w.comap (algebraMap k K))","decl":"lemma orbitRelEquiv_apply_mk'' [IsGalois k K] (w : InfinitePlace K) :\n    orbitRelEquiv (Quotient.mk'' w) = comap w (algebraMap k K) := rfl\n\n"}
{"name":"NumberField.InfinitePlace.isUnramified_self","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nw : NumberField.InfinitePlace K\nâŠ¢ NumberField.InfinitePlace.IsUnramified K w","decl":"lemma isUnramified_self : IsUnramified K w := rfl\n\n"}
{"name":"NumberField.InfinitePlace.IsUnramified.eq","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ² : Field k\nK : Type u_2\ninstâœÂ¹ : Field K\ninstâœ : Algebra k K\nw : NumberField.InfinitePlace K\nh : NumberField.InfinitePlace.IsUnramified k w\nâŠ¢ Eq (w.comap (algebraMap k K)).mult w.mult","decl":"lemma IsUnramified.eq (h : IsUnramified k w) : mult (w.comap (algebraMap k K)) = mult w := h\n\n"}
{"name":"NumberField.InfinitePlace.isUnramified_iff_mult_le","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ² : Field k\nK : Type u_2\ninstâœÂ¹ : Field K\ninstâœ : Algebra k K\nw : NumberField.InfinitePlace K\nâŠ¢ Iff (NumberField.InfinitePlace.IsUnramified k w) (LE.le w.mult (w.comap (algebraMap k K)).mult)","decl":"lemma isUnramified_iff_mult_le :\n    IsUnramified k w â†” mult w â‰¤ mult (w.comap (algebraMap k K)) := by\n  rw [IsUnramified, le_antisymm_iff, and_iff_right]\n  exact mult_comap_le _ _\n\n"}
{"name":"NumberField.InfinitePlace.IsUnramified.comap_algHom","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœâ´ : Field k\nK : Type u_2\ninstâœÂ³ : Field K\nF : Type u_3\ninstâœÂ² : Field F\ninstâœÂ¹ : Algebra k K\ninstâœ : Algebra k F\nw : NumberField.InfinitePlace F\nh : NumberField.InfinitePlace.IsUnramified k w\nf : AlgHom k K F\nâŠ¢ NumberField.InfinitePlace.IsUnramified k (w.comap â†‘f)","decl":"lemma IsUnramified.comap_algHom {w : InfinitePlace F} (h : IsUnramified k w) (f : K â†’â‚[k] F) :\n    IsUnramified k (w.comap (f : K â†’+* F)) := by\n  rw [InfinitePlace.isUnramified_iff_mult_le, â† InfinitePlace.comap_comp, f.comp_algebraMap, h.eq]\n  exact InfinitePlace.mult_comap_le _ _\n\n"}
{"name":"NumberField.InfinitePlace.IsUnramified.of_restrictScalars","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœâ¶ : Field k\nK : Type u_2\ninstâœâµ : Field K\nF : Type u_3\ninstâœâ´ : Field F\ninstâœÂ³ : Algebra k K\ninstâœÂ² : Algebra k F\ninstâœÂ¹ : Algebra K F\ninstâœ : IsScalarTower k K F\nw : NumberField.InfinitePlace F\nh : NumberField.InfinitePlace.IsUnramified k w\nâŠ¢ NumberField.InfinitePlace.IsUnramified K w","decl":"lemma IsUnramified.of_restrictScalars {w : InfinitePlace F} (h : IsUnramified k w) :\n    IsUnramified K w := by\n  rw [InfinitePlace.isUnramified_iff_mult_le, â† h.eq, IsScalarTower.algebraMap_eq k K F,\n    InfinitePlace.comap_comp]\n  exact InfinitePlace.mult_comap_le _ _\n\n"}
{"name":"NumberField.InfinitePlace.IsUnramified.comap","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœâ¶ : Field k\nK : Type u_2\ninstâœâµ : Field K\nF : Type u_3\ninstâœâ´ : Field F\ninstâœÂ³ : Algebra k K\ninstâœÂ² : Algebra k F\ninstâœÂ¹ : Algebra K F\ninstâœ : IsScalarTower k K F\nw : NumberField.InfinitePlace F\nh : NumberField.InfinitePlace.IsUnramified k w\nâŠ¢ NumberField.InfinitePlace.IsUnramified k (w.comap (algebraMap K F))","decl":"lemma IsUnramified.comap {w : InfinitePlace F} (h : IsUnramified k w) :\n    IsUnramified k (w.comap (algebraMap K F)) :=\n  h.comap_algHom (IsScalarTower.toAlgHom k K F)\n\n"}
{"name":"NumberField.InfinitePlace.not_isUnramified_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ² : Field k\nK : Type u_2\ninstâœÂ¹ : Field K\ninstâœ : Algebra k K\nw : NumberField.InfinitePlace K\nâŠ¢ Iff (Not (NumberField.InfinitePlace.IsUnramified k w)) (And w.IsComplex (w.comap (algebraMap k K)).IsReal)","decl":"lemma not_isUnramified_iff :\n    Â¬ IsUnramified k w â†” IsComplex w âˆ§ IsReal (w.comap (algebraMap k K)) := by\n  rw [IsUnramified, mult, mult, â† not_isReal_iff_isComplex]\n  split_ifs with hâ‚ hâ‚‚ hâ‚‚ <;>\n    simp only [not_true_eq_false, false_iff, and_self, forall_true_left, IsEmpty.forall_iff,\n      not_and, OfNat.one_ne_ofNat, not_false_eq_true, true_iff, OfNat.ofNat_ne_one, hâ‚, hâ‚‚]\n  exact hâ‚ (hâ‚‚.comap _)\n\n"}
{"name":"NumberField.InfinitePlace.isUnramified_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ² : Field k\nK : Type u_2\ninstâœÂ¹ : Field K\ninstâœ : Algebra k K\nw : NumberField.InfinitePlace K\nâŠ¢ Iff (NumberField.InfinitePlace.IsUnramified k w) (Or w.IsReal (w.comap (algebraMap k K)).IsComplex)","decl":"lemma isUnramified_iff :\n    IsUnramified k w â†” IsReal w âˆ¨ IsComplex (w.comap (algebraMap k K)) := by\n  rw [â† not_iff_not, not_isUnramified_iff, not_or,\n    not_isReal_iff_isComplex, not_isComplex_iff_isReal]\n\n"}
{"name":"NumberField.InfinitePlace.IsReal.isUnramified","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ² : Field k\nK : Type u_2\ninstâœÂ¹ : Field K\ninstâœ : Algebra k K\nw : NumberField.InfinitePlace K\nh : w.IsReal\nâŠ¢ NumberField.InfinitePlace.IsUnramified k w","decl":"lemma IsReal.isUnramified (h : IsReal w) : IsUnramified k w := isUnramified_iff.mpr (Or.inl h)\n\n"}
{"name":"NumberField.ComplexEmbedding.IsConj.isUnramified_mk_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ² : Field k\nK : Type u_2\ninstâœÂ¹ : Field K\ninstâœ : Algebra k K\nÏƒ : AlgEquiv k K K\nÏ† : RingHom K Complex\nh : NumberField.ComplexEmbedding.IsConj Ï† Ïƒ\nâŠ¢ Iff (NumberField.InfinitePlace.IsUnramified k (NumberField.InfinitePlace.mk Ï†)) (Eq Ïƒ 1)","decl":"lemma _root_.NumberField.ComplexEmbedding.IsConj.isUnramified_mk_iff\n    {Ï† : K â†’+* â„‚} (h : ComplexEmbedding.IsConj Ï† Ïƒ) :\n    IsUnramified k (mk Ï†) â†” Ïƒ = 1 := by\n  rw [h.ext_iff, ComplexEmbedding.isConj_one_iff, â† not_iff_not, not_isUnramified_iff,\n    â† not_isReal_iff_isComplex, comap_mk, isReal_mk_iff, isReal_mk_iff, eq_true h.isReal_comp,\n    and_true]\n\n"}
{"name":"NumberField.InfinitePlace.isUnramified_mk_iff_forall_isConj","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ³ : Field k\nK : Type u_2\ninstâœÂ² : Field K\ninstâœÂ¹ : Algebra k K\ninstâœ : IsGalois k K\nÏ† : RingHom K Complex\nâŠ¢ Iff (NumberField.InfinitePlace.IsUnramified k (NumberField.InfinitePlace.mk Ï†)) (âˆ€ (Ïƒ : AlgEquiv k K K), NumberField.ComplexEmbedding.IsConj Ï† Ïƒ â†’ Eq Ïƒ 1)","decl":"lemma isUnramified_mk_iff_forall_isConj [IsGalois k K] {Ï† : K â†’+* â„‚} :\n    IsUnramified k (mk Ï†) â†” âˆ€ Ïƒ : K â‰ƒâ‚[k] K, ComplexEmbedding.IsConj Ï† Ïƒ â†’ Ïƒ = 1 := by\n  refine âŸ¨fun H Ïƒ hÏƒ â†¦ hÏƒ.isUnramified_mk_iff.mp H,\n    fun H â†¦ ?_âŸ©\n  by_contra hÏ†\n  rw [not_isUnramified_iff] at hÏ†\n  rw [comap_mk, isReal_mk_iff, â† not_isReal_iff_isComplex, isReal_mk_iff,\n    â† ComplexEmbedding.isConj_one_iff (k := k)] at hÏ†\n  letI := (Ï†.comp (algebraMap k K)).toAlgebra\n  letI := Ï†.toAlgebra\n  have : IsScalarTower k K â„‚ := IsScalarTower.of_algebraMap_eq' rfl\n  let Ï†' : K â†’â‚[k] â„‚ := { star Ï† with commutes' := fun r â†¦ by simpa using RingHom.congr_fun hÏ†.2 r }\n  have : ComplexEmbedding.IsConj Ï† (AlgHom.restrictNormal' Ï†' K) :=\n    (RingHom.ext <| AlgHom.restrictNormal_commutes Ï†' K).symm\n  exact hÏ†.1 (H _ this â–¸ this)\n\n"}
{"name":"NumberField.InfinitePlace.mem_stabilizer_mk_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ² : Field k\nK : Type u_2\ninstâœÂ¹ : Field K\ninstâœ : Algebra k K\nÏ† : RingHom K Complex\nÏƒ : AlgEquiv k K K\nâŠ¢ Iff (Membership.mem (MulAction.stabilizer (AlgEquiv k K K) (NumberField.InfinitePlace.mk Ï†)) Ïƒ) (Or (Eq Ïƒ 1) (NumberField.ComplexEmbedding.IsConj Ï† Ïƒ))","decl":"lemma mem_stabilizer_mk_iff (Ï† : K â†’+* â„‚) (Ïƒ : K â‰ƒâ‚[k] K) :\n    Ïƒ âˆˆ Stab (mk Ï†) â†” Ïƒ = 1 âˆ¨ ComplexEmbedding.IsConj Ï† Ïƒ := by\n  simp only [MulAction.mem_stabilizer_iff, smul_mk, mk_eq_iff]\n  rw [â† ComplexEmbedding.isConj_symm, ComplexEmbedding.conjugate, star_eq_iff_star_eq]\n  refine or_congr âŸ¨fun H â†¦ ?_, fun H â†¦ H â–¸ rflâŸ© Iff.rfl\n  exact congr_arg AlgEquiv.symm\n    (AlgEquiv.ext (g := AlgEquiv.refl) fun x â†¦ Ï†.injective (RingHom.congr_fun H x))\n\n"}
{"name":"NumberField.InfinitePlace.IsUnramified.stabilizer_eq_bot","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ² : Field k\nK : Type u_2\ninstâœÂ¹ : Field K\ninstâœ : Algebra k K\nw : NumberField.InfinitePlace K\nh : NumberField.InfinitePlace.IsUnramified k w\nâŠ¢ Eq (MulAction.stabilizer (AlgEquiv k K K) w) Bot.bot","decl":"lemma IsUnramified.stabilizer_eq_bot (h : IsUnramified k w) : Stab w = âŠ¥ := by\n  rw [eq_bot_iff, â† mk_embedding w, SetLike.le_def]\n  simp only [mem_stabilizer_mk_iff, Subgroup.mem_bot, forall_eq_or_imp, true_and]\n  exact fun Ïƒ hÏƒ â†¦ hÏƒ.isUnramified_mk_iff.mp ((mk_embedding w).symm â–¸ h)\n\n"}
{"name":"NumberField.ComplexEmbedding.IsConj.coe_stabilzer_mk","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ² : Field k\nK : Type u_2\ninstâœÂ¹ : Field K\ninstâœ : Algebra k K\nÏƒ : AlgEquiv k K K\nÏ† : RingHom K Complex\nh : NumberField.ComplexEmbedding.IsConj Ï† Ïƒ\nâŠ¢ Eq (â†‘(MulAction.stabilizer (AlgEquiv k K K) (NumberField.InfinitePlace.mk Ï†))) (Insert.insert 1 (Singleton.singleton Ïƒ))","decl":"lemma _root_.NumberField.ComplexEmbedding.IsConj.coe_stabilzer_mk\n    {Ï† : K â†’+* â„‚} (h : ComplexEmbedding.IsConj Ï† Ïƒ) :\n    (Stab (mk Ï†) : Set (K â‰ƒâ‚[k] K)) = {1, Ïƒ} := by\n  ext\n  rw [SetLike.mem_coe, mem_stabilizer_mk_iff, Set.mem_insert_iff, Set.mem_singleton_iff,\n    â† h.ext_iff, eq_comm (a := Ïƒ)]\n\n"}
{"name":"NumberField.InfinitePlace.nat_card_stabilizer_eq_one_or_two","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ² : Field k\nK : Type u_2\ninstâœÂ¹ : Field K\ninstâœ : Algebra k K\nw : NumberField.InfinitePlace K\nâŠ¢ Or (Eq (Nat.card (Subtype fun x => Membership.mem (MulAction.stabilizer (AlgEquiv k K K) w) x)) 1) (Eq (Nat.card (Subtype fun x => Membership.mem (MulAction.stabilizer (AlgEquiv k K K) w) x)) 2)","decl":"lemma nat_card_stabilizer_eq_one_or_two :\n    Nat.card (Stab w) = 1 âˆ¨ Nat.card (Stab w) = 2 := by\n  classical\n  rw [â† SetLike.coe_sort_coe, â† mk_embedding w]\n  by_cases h : âˆƒ Ïƒ, ComplexEmbedding.IsConj (k := k) (embedding w) Ïƒ\n  Â· obtain âŸ¨Ïƒ, hÏƒâŸ© := h\n    simp only [hÏƒ.coe_stabilzer_mk, Nat.card_eq_fintype_card, card_ofFinset, Set.toFinset_singleton]\n    by_cases 1 = Ïƒ\n    Â· left; simp [*]\n    Â· right; simp [*]\n  Â· push_neg at h\n    left\n    trans Nat.card ({1} : Set (K â‰ƒâ‚[k] K))\n    Â· congr with x\n      simp only [SetLike.mem_coe, mem_stabilizer_mk_iff, Set.mem_singleton_iff, or_iff_left_iff_imp,\n        h x, IsEmpty.forall_iff]\n    Â· simp\n\n"}
{"name":"NumberField.InfinitePlace.isUnramified_iff_stabilizer_eq_bot","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ³ : Field k\nK : Type u_2\ninstâœÂ² : Field K\ninstâœÂ¹ : Algebra k K\nw : NumberField.InfinitePlace K\ninstâœ : IsGalois k K\nâŠ¢ Iff (NumberField.InfinitePlace.IsUnramified k w) (Eq (MulAction.stabilizer (AlgEquiv k K K) w) Bot.bot)","decl":"lemma isUnramified_iff_stabilizer_eq_bot [IsGalois k K] : IsUnramified k w â†” Stab w = âŠ¥ := by\n  rw [â† mk_embedding w, isUnramified_mk_iff_forall_isConj]\n  simp only [eq_bot_iff, SetLike.le_def, mem_stabilizer_mk_iff,\n    Subgroup.mem_bot, forall_eq_or_imp, true_and]\n\n"}
{"name":"NumberField.InfinitePlace.isUnramified_iff_card_stabilizer_eq_one","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ³ : Field k\nK : Type u_2\ninstâœÂ² : Field K\ninstâœÂ¹ : Algebra k K\nw : NumberField.InfinitePlace K\ninstâœ : IsGalois k K\nâŠ¢ Iff (NumberField.InfinitePlace.IsUnramified k w) (Eq (Nat.card (Subtype fun x => Membership.mem (MulAction.stabilizer (AlgEquiv k K K) w) x)) 1)","decl":"lemma isUnramified_iff_card_stabilizer_eq_one [IsGalois k K] :\n    IsUnramified k w â†” Nat.card (Stab w) = 1 := by\n  rw [isUnramified_iff_stabilizer_eq_bot, Subgroup.card_eq_one]\n\n"}
{"name":"NumberField.InfinitePlace.not_isUnramified_iff_card_stabilizer_eq_two","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ³ : Field k\nK : Type u_2\ninstâœÂ² : Field K\ninstâœÂ¹ : Algebra k K\nw : NumberField.InfinitePlace K\ninstâœ : IsGalois k K\nâŠ¢ Iff (Not (NumberField.InfinitePlace.IsUnramified k w)) (Eq (Nat.card (Subtype fun x => Membership.mem (MulAction.stabilizer (AlgEquiv k K K) w) x)) 2)","decl":"lemma not_isUnramified_iff_card_stabilizer_eq_two [IsGalois k K] :\n    Â¬ IsUnramified k w â†” Nat.card (Stab w) = 2 := by\n  rw [isUnramified_iff_card_stabilizer_eq_one]\n  obtain (e|e) := nat_card_stabilizer_eq_one_or_two k w <;> rw [e] <;> decide\n\n"}
{"name":"NumberField.InfinitePlace.card_stabilizer","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ³ : Field k\nK : Type u_2\ninstâœÂ² : Field K\ninstâœÂ¹ : Algebra k K\nw : NumberField.InfinitePlace K\ninstâœ : IsGalois k K\nâŠ¢ Eq (Nat.card (Subtype fun x => Membership.mem (MulAction.stabilizer (AlgEquiv k K K) w) x)) (ite (NumberField.InfinitePlace.IsUnramified k w) 1 2)","decl":"open scoped Classical in\nlemma card_stabilizer [IsGalois k K] :\n    Nat.card (Stab w) = if IsUnramified k w then 1 else 2 := by\n  split\n  Â· rwa [â† isUnramified_iff_card_stabilizer_eq_one]\n  Â· rwa [â† not_isUnramified_iff_card_stabilizer_eq_two]\n\n"}
{"name":"NumberField.InfinitePlace.even_nat_card_aut_of_not_isUnramified","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ³ : Field k\nK : Type u_2\ninstâœÂ² : Field K\ninstâœÂ¹ : Algebra k K\nw : NumberField.InfinitePlace K\ninstâœ : IsGalois k K\nhw : Not (NumberField.InfinitePlace.IsUnramified k w)\nâŠ¢ Even (Nat.card (AlgEquiv k K K))","decl":"lemma even_nat_card_aut_of_not_isUnramified [IsGalois k K] (hw : Â¬ IsUnramified k w) :\n    Even (Nat.card <| K â‰ƒâ‚[k] K) := by\n  by_cases H : Finite (K â‰ƒâ‚[k] K)\n  Â· cases nonempty_fintype (K â‰ƒâ‚[k] K)\n    rw [even_iff_two_dvd, â† not_isUnramified_iff_card_stabilizer_eq_two.mp hw]\n    exact Subgroup.card_subgroup_dvd_card (Stab w)\n  Â· convert Even.zero\n    by_contra e\n    exact H (Nat.finite_of_card_ne_zero e)\n\n"}
{"name":"NumberField.InfinitePlace.even_card_aut_of_not_isUnramified","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœâ´ : Field k\nK : Type u_2\ninstâœÂ³ : Field K\ninstâœÂ² : Algebra k K\nw : NumberField.InfinitePlace K\ninstâœÂ¹ : IsGalois k K\ninstâœ : FiniteDimensional k K\nhw : Not (NumberField.InfinitePlace.IsUnramified k w)\nâŠ¢ Even (Fintype.card (AlgEquiv k K K))","decl":"lemma even_card_aut_of_not_isUnramified [IsGalois k K] [FiniteDimensional k K]\n    (hw : Â¬ IsUnramified k w) :\n    Even (Fintype.card <| K â‰ƒâ‚[k] K) :=\n  Nat.card_eq_fintype_card (Î± := K â‰ƒâ‚[k] K) â–¸ even_nat_card_aut_of_not_isUnramified hw\n\n"}
{"name":"NumberField.InfinitePlace.even_finrank_of_not_isUnramified","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ³ : Field k\nK : Type u_2\ninstâœÂ² : Field K\ninstâœÂ¹ : Algebra k K\nw : NumberField.InfinitePlace K\ninstâœ : IsGalois k K\nhw : Not (NumberField.InfinitePlace.IsUnramified k w)\nâŠ¢ Even (Module.finrank k K)","decl":"lemma even_finrank_of_not_isUnramified [IsGalois k K]\n    (hw : Â¬ IsUnramified k w) : Even (finrank k K) := by\n  by_cases FiniteDimensional k K\n  Â· exact IsGalois.card_aut_eq_finrank k K â–¸ even_card_aut_of_not_isUnramified hw\n  Â· exact finrank_of_not_finite â€¹_â€º â–¸ Even.zero\n\n"}
{"name":"NumberField.InfinitePlace.isUnramified_smul_iff","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ² : Field k\nK : Type u_2\ninstâœÂ¹ : Field K\ninstâœ : Algebra k K\nÏƒ : AlgEquiv k K K\nw : NumberField.InfinitePlace K\nâŠ¢ Iff (NumberField.InfinitePlace.IsUnramified k (HSMul.hSMul Ïƒ w)) (NumberField.InfinitePlace.IsUnramified k w)","decl":"lemma isUnramified_smul_iff :\n    IsUnramified k (Ïƒ â€¢ w) â†” IsUnramified k w := by\n  rw [isUnramified_iff, isUnramified_iff, isReal_smul_iff, comap_smul,\n    â† AlgEquiv.toAlgHom_toRingHom, AlgHom.comp_algebraMap]\n\n"}
{"name":"NumberField.InfinitePlace.isUnramifiedIn_comap","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ³ : Field k\nK : Type u_2\ninstâœÂ² : Field K\ninstâœÂ¹ : Algebra k K\ninstâœ : IsGalois k K\nw : NumberField.InfinitePlace K\nâŠ¢ Iff (NumberField.InfinitePlace.IsUnramifiedIn K (w.comap (algebraMap k K))) (NumberField.InfinitePlace.IsUnramified k w)","decl":"lemma isUnramifiedIn_comap [IsGalois k K] {w : InfinitePlace K} :\n    (w.comap (algebraMap k K)).IsUnramifiedIn K â†” w.IsUnramified k := by\n  refine âŸ¨fun H â†¦ H _ rfl, fun H v hv â†¦ ?_âŸ©\n  obtain âŸ¨Ïƒ, rflâŸ© := exists_smul_eq_of_comap_eq hv\n  rwa [isUnramified_smul_iff] at H\n\n"}
{"name":"NumberField.InfinitePlace.even_card_aut_of_not_isUnramifiedIn","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœâ´ : Field k\nK : Type u_2\ninstâœÂ³ : Field K\ninstâœÂ² : Algebra k K\ninstâœÂ¹ : IsGalois k K\ninstâœ : FiniteDimensional k K\nw : NumberField.InfinitePlace k\nhw : Not (NumberField.InfinitePlace.IsUnramifiedIn K w)\nâŠ¢ Even (Fintype.card (AlgEquiv k K K))","decl":"lemma even_card_aut_of_not_isUnramifiedIn [IsGalois k K] [FiniteDimensional k K]\n    {w : InfinitePlace k} (hw : Â¬ w.IsUnramifiedIn K) :\n    Even (Fintype.card <| K â‰ƒâ‚[k] K) := by\n  obtain âŸ¨v, rflâŸ© := comap_surjective (K := K) w\n  rw [isUnramifiedIn_comap] at hw\n  exact even_card_aut_of_not_isUnramified hw\n\n"}
{"name":"NumberField.InfinitePlace.even_finrank_of_not_isUnramifiedIn","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ³ : Field k\nK : Type u_2\ninstâœÂ² : Field K\ninstâœÂ¹ : Algebra k K\ninstâœ : IsGalois k K\nw : NumberField.InfinitePlace k\nhw : Not (NumberField.InfinitePlace.IsUnramifiedIn K w)\nâŠ¢ Even (Module.finrank k K)","decl":"lemma even_finrank_of_not_isUnramifiedIn\n    [IsGalois k K] {w : InfinitePlace k} (hw : Â¬ w.IsUnramifiedIn K) :\n    Even (finrank k K) := by\n  obtain âŸ¨v, rflâŸ© := comap_surjective (K := K) w\n  rw [isUnramifiedIn_comap] at hw\n  exact even_finrank_of_not_isUnramified hw\n\n"}
{"name":"NumberField.InfinitePlace.card_isUnramified","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœâµ : Field k\nK : Type u_2\ninstâœâ´ : Field K\ninstâœÂ³ : Algebra k K\ninstâœÂ² : NumberField K\ninstâœÂ¹ : NumberField k\ninstâœ : IsGalois k K\nâŠ¢ Eq (Finset.filter (fun w => NumberField.InfinitePlace.IsUnramified k w) Finset.univ).card (HMul.hMul (Finset.filter (fun w => NumberField.InfinitePlace.IsUnramifiedIn K w) Finset.univ).card (Module.finrank k K))","decl":"open Finset in\nopen scoped Classical in\nlemma card_isUnramified [NumberField k] [IsGalois k K] :\n    #{w : InfinitePlace K | w.IsUnramified k} =\n      #{w : InfinitePlace k | w.IsUnramifiedIn K} * finrank k K := by\n  letI := Module.Finite.of_restrictScalars_finite â„š k K\n  rw [â† IsGalois.card_aut_eq_finrank,\n    Finset.card_eq_sum_card_fiberwise (f := (comap Â· (algebraMap k K)))\n    (t := {w : InfinitePlace k | w.IsUnramifiedIn K}), â† smul_eq_mul, â† sum_const]\n  Â· refine sum_congr rfl (fun w hw â†¦ ?_)\n    obtain âŸ¨w, rflâŸ© := comap_surjective (K := K) w\n    simp only [mem_univ, forall_true_left, mem_filter, true_and] at hw\n    trans #(MulAction.orbit (K â‰ƒâ‚[k] K) w).toFinset\n    Â· congr; ext w'\n      simp only [mem_univ, forall_true_left, filter_congr_decidable, mem_filter, true_and,\n        Set.mem_toFinset, mem_orbit_iff, @eq_comm _ (comap w' _), and_iff_right_iff_imp]\n      intro e; rwa [â† isUnramifiedIn_comap, â† e]\n    Â· rw [â† MulAction.card_orbit_mul_card_stabilizer_eq_card_group _ w,\n        â† Nat.card_eq_fintype_card (Î± := Stab w), card_stabilizer, if_pos,\n        mul_one, Set.toFinset_card]\n      rwa [â† isUnramifiedIn_comap]\n  Â· simp [isUnramifiedIn_comap]\n\n"}
{"name":"NumberField.InfinitePlace.card_isUnramified_compl","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœâµ : Field k\nK : Type u_2\ninstâœâ´ : Field K\ninstâœÂ³ : Algebra k K\ninstâœÂ² : NumberField K\ninstâœÂ¹ : NumberField k\ninstâœ : IsGalois k K\nâŠ¢ Eq (HasCompl.compl (Finset.filter (fun w => NumberField.InfinitePlace.IsUnramified k w) Finset.univ)).card (HMul.hMul (HasCompl.compl (Finset.filter (fun w => NumberField.InfinitePlace.IsUnramifiedIn K w) Finset.univ)).card (HDiv.hDiv (Module.finrank k K) 2))","decl":"open Finset in\nopen scoped Classical in\nlemma card_isUnramified_compl [NumberField k] [IsGalois k K] :\n    #({w : InfinitePlace K | w.IsUnramified k} : Finset _)á¶œ =\n      #({w : InfinitePlace k | w.IsUnramifiedIn K} : Finset _)á¶œ * (finrank k K / 2) := by\n  letI := Module.Finite.of_restrictScalars_finite â„š k K\n  rw [â† IsGalois.card_aut_eq_finrank,\n    Finset.card_eq_sum_card_fiberwise (f := (comap Â· (algebraMap k K)))\n    (t := ({w : InfinitePlace k | w.IsUnramifiedIn K}: Finset _)á¶œ), â† smul_eq_mul, â† sum_const]\n  Â· refine sum_congr rfl (fun w hw â†¦ ?_)\n    obtain âŸ¨w, rflâŸ© := comap_surjective (K := K) w\n    simp only [mem_univ, forall_true_left, compl_filter, not_not, mem_filter, true_and] at hw\n    trans Finset.card (MulAction.orbit (K â‰ƒâ‚[k] K) w).toFinset\n    Â· congr; ext w'\n      simp only [compl_filter, filter_congr_decidable, mem_filter, mem_univ, true_and,\n        @eq_comm _ (comap w' _), Set.mem_toFinset, mem_orbit_iff, and_iff_right_iff_imp]\n      intro e; rwa [â† isUnramifiedIn_comap, â† e]\n    Â· rw [â† MulAction.card_orbit_mul_card_stabilizer_eq_card_group _ w,\n        â† Nat.card_eq_fintype_card (Î± := Stab w), InfinitePlace.card_stabilizer, if_neg,\n        Nat.mul_div_cancel _ zero_lt_two, Set.toFinset_card]\n      rwa [â† isUnramifiedIn_comap]\n  Â· simp [isUnramifiedIn_comap]\n\n"}
{"name":"NumberField.InfinitePlace.card_eq_card_isUnramifiedIn","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœâµ : Field k\nK : Type u_2\ninstâœâ´ : Field K\ninstâœÂ³ : Algebra k K\ninstâœÂ² : NumberField K\ninstâœÂ¹ : NumberField k\ninstâœ : IsGalois k K\nâŠ¢ Eq (Fintype.card (NumberField.InfinitePlace K)) (HAdd.hAdd (HMul.hMul (Finset.filter (fun w => NumberField.InfinitePlace.IsUnramifiedIn K w) Finset.univ).card (Module.finrank k K)) (HMul.hMul (HasCompl.compl (Finset.filter (fun w => NumberField.InfinitePlace.IsUnramifiedIn K w) Finset.univ)).card (HDiv.hDiv (Module.finrank k K) 2)))","decl":"open scoped Classical in\nlemma card_eq_card_isUnramifiedIn [NumberField k] [IsGalois k K] :\n    Fintype.card (InfinitePlace K) =\n      #{w : InfinitePlace k | w.IsUnramifiedIn K} * finrank k K +\n      #({w : InfinitePlace k | w.IsUnramifiedIn K} : Finset _)á¶œ * (finrank k K / 2) := by\n  rw [â† card_isUnramified, â† card_isUnramified_compl, Finset.card_add_card_compl]\n\n"}
{"name":"IsUnramifiedAtInfinitePlaces.isUnramified","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ² : Field k\nK : Type u_2\ninstâœÂ¹ : Field K\ninstâœ : Algebra k K\nself : IsUnramifiedAtInfinitePlaces k K\nw : NumberField.InfinitePlace K\nâŠ¢ NumberField.InfinitePlace.IsUnramified k w","decl":"/-- A field extension is unramified at infinite places if every infinite place is unramified. -/\nclass IsUnramifiedAtInfinitePlaces : Prop where\n  isUnramified : âˆ€ w : InfinitePlace K, w.IsUnramified k\n\n"}
{"name":"IsUnramifiedAtInfinitePlaces.id","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_2\ninstâœ : Field K\nâŠ¢ IsUnramifiedAtInfinitePlaces K K","decl":"instance IsUnramifiedAtInfinitePlaces.id : IsUnramifiedAtInfinitePlaces K K where\n  isUnramified w := w.isUnramified_self\n\n"}
{"name":"IsUnramifiedAtInfinitePlaces.trans","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœâ¶ : Field k\nK : Type u_2\ninstâœâµ : Field K\nF : Type u_3\ninstâœâ´ : Field F\ninstâœÂ³ : Algebra k K\ninstâœÂ² : Algebra k F\ninstâœÂ¹ : Algebra K F\ninstâœ : IsScalarTower k K F\nhâ‚ : IsUnramifiedAtInfinitePlaces k K\nhâ‚‚ : IsUnramifiedAtInfinitePlaces K F\nâŠ¢ IsUnramifiedAtInfinitePlaces k F","decl":"lemma IsUnramifiedAtInfinitePlaces.trans\n    [hâ‚ : IsUnramifiedAtInfinitePlaces k K] [hâ‚‚ : IsUnramifiedAtInfinitePlaces K F] :\n    IsUnramifiedAtInfinitePlaces k F where\n  isUnramified w :=\n    Eq.trans (IsScalarTower.algebraMap_eq k K F â–¸ hâ‚.1 (w.comap (algebraMap _ _))) (hâ‚‚.1 w)\n\n"}
{"name":"IsUnramifiedAtInfinitePlaces.top","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœâ¶ : Field k\nK : Type u_2\ninstâœâµ : Field K\nF : Type u_3\ninstâœâ´ : Field F\ninstâœÂ³ : Algebra k K\ninstâœÂ² : Algebra k F\ninstâœÂ¹ : Algebra K F\ninstâœ : IsScalarTower k K F\nh : IsUnramifiedAtInfinitePlaces k F\nâŠ¢ IsUnramifiedAtInfinitePlaces K F","decl":"lemma IsUnramifiedAtInfinitePlaces.top [h : IsUnramifiedAtInfinitePlaces k F] :\n    IsUnramifiedAtInfinitePlaces K F where\n  isUnramified w := (h.1 w).of_restrictScalars K\n\n"}
{"name":"IsUnramifiedAtInfinitePlaces.bot","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœâ· : Field k\nK : Type u_2\ninstâœâ¶ : Field K\nF : Type u_3\ninstâœâµ : Field F\ninstâœâ´ : Algebra k K\ninstâœÂ³ : Algebra k F\ninstâœÂ² : Algebra K F\ninstâœÂ¹ : IsScalarTower k K F\nhâ‚ : IsUnramifiedAtInfinitePlaces k F\ninstâœ : Algebra.IsAlgebraic K F\nâŠ¢ IsUnramifiedAtInfinitePlaces k K","decl":"lemma IsUnramifiedAtInfinitePlaces.bot [hâ‚ : IsUnramifiedAtInfinitePlaces k F]\n    [Algebra.IsAlgebraic K F] :\n    IsUnramifiedAtInfinitePlaces k K where\n  isUnramified w := by\n    obtain âŸ¨w, rflâŸ© := InfinitePlace.comap_surjective (K := F) w\n    exact (hâ‚.1 w).comap K\n\n"}
{"name":"NumberField.InfinitePlace.isUnramified","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ³ : Field k\nK : Type u_2\ninstâœÂ² : Field K\ninstâœÂ¹ : Algebra k K\ninstâœ : IsUnramifiedAtInfinitePlaces k K\nw : NumberField.InfinitePlace K\nâŠ¢ NumberField.InfinitePlace.IsUnramified k w","decl":"lemma NumberField.InfinitePlace.isUnramified [IsUnramifiedAtInfinitePlaces k K]\n    (w : InfinitePlace K) : IsUnramified k w := IsUnramifiedAtInfinitePlaces.isUnramified w\n\n"}
{"name":"NumberField.InfinitePlace.isUnramifiedIn","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ³ : Field k\nK : Type u_2\ninstâœÂ² : Field K\ninstâœÂ¹ : Algebra k K\ninstâœ : IsUnramifiedAtInfinitePlaces k K\nw : NumberField.InfinitePlace k\nâŠ¢ NumberField.InfinitePlace.IsUnramifiedIn K w","decl":"lemma NumberField.InfinitePlace.isUnramifiedIn [IsUnramifiedAtInfinitePlaces k K]\n    (w : InfinitePlace k) : IsUnramifiedIn K w := fun v _ â†¦ v.isUnramified k\n\n"}
{"name":"IsUnramifiedAtInfinitePlaces_of_odd_card_aut","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœâ´ : Field k\nK : Type u_2\ninstâœÂ³ : Field K\ninstâœÂ² : Algebra k K\ninstâœÂ¹ : IsGalois k K\ninstâœ : FiniteDimensional k K\nh : Odd (Fintype.card (AlgEquiv k K K))\nâŠ¢ IsUnramifiedAtInfinitePlaces k K","decl":"lemma IsUnramifiedAtInfinitePlaces_of_odd_card_aut [IsGalois k K] [FiniteDimensional k K]\n    (h : Odd (Fintype.card <| K â‰ƒâ‚[k] K)) : IsUnramifiedAtInfinitePlaces k K :=\n  âŸ¨fun _ â†¦ not_not.mp (Nat.not_even_iff_odd.2 h âˆ˜ InfinitePlace.even_card_aut_of_not_isUnramified)âŸ©\n\n"}
{"name":"IsUnramifiedAtInfinitePlaces_of_odd_finrank","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœÂ³ : Field k\nK : Type u_2\ninstâœÂ² : Field K\ninstâœÂ¹ : Algebra k K\ninstâœ : IsGalois k K\nh : Odd (Module.finrank k K)\nâŠ¢ IsUnramifiedAtInfinitePlaces k K","decl":"lemma IsUnramifiedAtInfinitePlaces_of_odd_finrank [IsGalois k K]\n    (h : Odd (Module.finrank k K)) : IsUnramifiedAtInfinitePlaces k K :=\n  âŸ¨fun _ â†¦ not_not.mp (Nat.not_even_iff_odd.2 h âˆ˜ InfinitePlace.even_finrank_of_not_isUnramified)âŸ©\n\n"}
{"name":"IsUnramifiedAtInfinitePlaces.card_infinitePlace","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"k : Type u_1\ninstâœâ¶ : Field k\nK : Type u_2\ninstâœâµ : Field K\ninstâœâ´ : Algebra k K\ninstâœÂ³ : NumberField k\ninstâœÂ² : NumberField K\ninstâœÂ¹ : IsGalois k K\ninstâœ : IsUnramifiedAtInfinitePlaces k K\nâŠ¢ Eq (Fintype.card (NumberField.InfinitePlace K)) (HMul.hMul (Fintype.card (NumberField.InfinitePlace k)) (Module.finrank k K))","decl":"open Module in\nlemma IsUnramifiedAtInfinitePlaces.card_infinitePlace [NumberField k] [NumberField K]\n    [IsGalois k K] [IsUnramifiedAtInfinitePlaces k K] :\n    Fintype.card (InfinitePlace K) = Fintype.card (InfinitePlace k) * finrank k K := by\n  classical\n  rw [InfinitePlace.card_eq_card_isUnramifiedIn (k := k) (K := K), Finset.filter_true_of_mem,\n    Finset.card_univ, Finset.card_eq_zero.mpr, zero_mul, add_zero]\n  Â· exact Finset.compl_univ\n  simp only [Finset.mem_univ, forall_true_left, Finset.filter_eq_empty_iff]\n  exact InfinitePlace.isUnramifiedIn K\n\n"}
{"name":"IsPrimitiveRoot.nrRealPlaces_eq_zero_of_two_lt","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nÎ¶ : K\nk : Nat\nhk : LT.lt 2 k\nhÎ¶ : IsPrimitiveRoot Î¶ k\nâŠ¢ Eq (NumberField.InfinitePlace.nrRealPlaces K) 0","decl":"theorem nrRealPlaces_eq_zero_of_two_lt (hk : 2 < k) (hÎ¶ : IsPrimitiveRoot Î¶ k) :\n    NumberField.InfinitePlace.nrRealPlaces K = 0 := by\n  refine (@Fintype.card_eq_zero_iff _ (_)).2 âŸ¨fun âŸ¨w, hwrealâŸ© â†¦ ?_âŸ©\n  rw [NumberField.InfinitePlace.isReal_iff] at hwreal\n  let f := w.embedding\n  have hÎ¶' : IsPrimitiveRoot (f Î¶) k := hÎ¶.map_of_injective f.injective\n  have him : (f Î¶).im = 0 := by\n    rw [â† Complex.conj_eq_iff_im, â† NumberField.ComplexEmbedding.conjugate_coe_eq]\n    congr\n  have hre : (f Î¶).re = 1 âˆ¨ (f Î¶).re = -1 := by\n    rw [â† Complex.abs_re_eq_abs] at him\n    have := Complex.norm_eq_one_of_pow_eq_one hÎ¶'.pow_eq_one (by omega)\n    rwa [Complex.norm_eq_abs, â† him, â† abs_one, abs_eq_abs] at this\n  cases hre with\n  | inl hone =>\n    exact hÎ¶'.ne_one (by omega) <| Complex.ext (by simp [hone]) (by simp [him])\n  | inr hnegone =>\n    replace hÎ¶' := hÎ¶'.eq_orderOf\n    simp only [show f Î¶ = -1 from Complex.ext (by simp [hnegone]) (by simp [him]),\n      orderOf_neg_one, ringChar.eq_zero, OfNat.zero_ne_ofNat, â†“reduceIte] at hÎ¶'\n    omega\n\n"}
{"name":"Rat.infinitePlace_apply","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"v : NumberField.InfinitePlace Rat\nx : Rat\nâŠ¢ Eq (v x) â†‘(abs x)","decl":"@[simp]\nlemma infinitePlace_apply (v : InfinitePlace â„š) (x : â„š) : v x = |x| := by\n  rw [NumberField.InfinitePlace.coe_apply]\n  obtain âŸ¨_, _, rflâŸ© := v\n  simp\n\n"}
{"name":"Rat.instSubsingletonInfinitePlace","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"âŠ¢ Subsingleton (NumberField.InfinitePlace Rat)","decl":"instance : Subsingleton (InfinitePlace â„š) where\n  allEq a b := by ext; simp\n\n"}
{"name":"Rat.isReal_infinitePlace","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"âŠ¢ Rat.infinitePlace.IsReal","decl":"lemma isReal_infinitePlace : InfinitePlace.IsReal (infinitePlace) :=\n  âŸ¨Rat.castHom â„‚, by ext; simp, rflâŸ©\n\n"}
{"name":"NumberField.IsTotallyReal.isReal","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nself : NumberField.IsTotallyReal K\nv : NumberField.InfinitePlace K\nâŠ¢ v.IsReal","decl":"/-- A number field `K` is totally real if all of its infinite places\nare real. In other words, the image of every ring homomorphism `K â†’ â„‚`\nis a subset of `â„`. -/\nclass IsTotallyReal (K : Type*) [Field K] [NumberField K] where\n  isReal : âˆ€ v : InfinitePlace K, v.IsReal\n\n"}
{"name":"NumberField.instIsTotallyRealRat","module":"Mathlib.NumberTheory.NumberField.Embeddings","initialProofState":"âŠ¢ NumberField.IsTotallyReal Rat","decl":"instance : IsTotallyReal â„š where\n  isReal v := by\n    rw [Subsingleton.elim v Rat.infinitePlace]\n    exact Rat.isReal_infinitePlace\n\n"}
