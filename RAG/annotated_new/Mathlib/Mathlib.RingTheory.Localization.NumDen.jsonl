{"name":"IsFractionRing.exists_reduced_fraction","module":"Mathlib.RingTheory.Localization.NumDen","initialProofState":"A : Type u_1\ninst✝⁵ : CommRing A\ninst✝⁴ : IsDomain A\ninst✝³ : UniqueFactorizationMonoid A\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\nx : K\n⊢ Exists fun a => Exists fun b => And (IsRelPrime a ↑b) (Eq (IsLocalization.mk' K a b) x)","decl":"theorem exists_reduced_fraction (x : K) :\n    ∃ (a : A) (b : nonZeroDivisors A), IsRelPrime a b ∧ mk' K a b = x := by\n  obtain ⟨⟨b, b_nonzero⟩, a, hab⟩ := exists_integer_multiple (nonZeroDivisors A) x\n  obtain ⟨a', b', c', no_factor, rfl, rfl⟩ :=\n    UniqueFactorizationMonoid.exists_reduced_factors' a b\n      (mem_nonZeroDivisors_iff_ne_zero.mp b_nonzero)\n  obtain ⟨_, b'_nonzero⟩ := mul_mem_nonZeroDivisors.mp b_nonzero\n  refine ⟨a', ⟨b', b'_nonzero⟩, no_factor, ?_⟩\n  refine mul_left_cancel₀ (IsFractionRing.to_map_ne_zero_of_mem_nonZeroDivisors b_nonzero) ?_\n  simp only [Subtype.coe_mk, RingHom.map_mul, Algebra.smul_def] at *\n  rw [← hab, mul_assoc, mk'_spec' _ a' ⟨b', b'_nonzero⟩]\n\n"}
{"name":"IsFractionRing.num_den_reduced","module":"Mathlib.RingTheory.Localization.NumDen","initialProofState":"A : Type u_1\ninst✝⁵ : CommRing A\ninst✝⁴ : IsDomain A\ninst✝³ : UniqueFactorizationMonoid A\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\nx : K\n⊢ IsRelPrime (IsFractionRing.num A x) ↑(IsFractionRing.den A x)","decl":"theorem num_den_reduced (x : K) : IsRelPrime (num A x) (den A x) :=\n  (Classical.choose_spec (Classical.choose_spec (exists_reduced_fraction A x))).1\n\n-- @[simp] -- Porting note: LHS reduces to give the simp lemma below\n"}
{"name":"IsFractionRing.mk'_num_den","module":"Mathlib.RingTheory.Localization.NumDen","initialProofState":"A : Type u_1\ninst✝⁵ : CommRing A\ninst✝⁴ : IsDomain A\ninst✝³ : UniqueFactorizationMonoid A\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\nx : K\n⊢ Eq (IsLocalization.mk' K (IsFractionRing.num A x) (IsFractionRing.den A x)) x","decl":"theorem mk'_num_den (x : K) : mk' K (num A x) (den A x) = x :=\n  (Classical.choose_spec (Classical.choose_spec (exists_reduced_fraction A x))).2\n\n"}
{"name":"IsFractionRing.mk'_num_den'","module":"Mathlib.RingTheory.Localization.NumDen","initialProofState":"A : Type u_1\ninst✝⁵ : CommRing A\ninst✝⁴ : IsDomain A\ninst✝³ : UniqueFactorizationMonoid A\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\nx : K\n⊢ Eq (HDiv.hDiv ((algebraMap A K) (IsFractionRing.num A x)) ((algebraMap A K) ↑(IsFractionRing.den A x))) x","decl":"@[simp]\ntheorem mk'_num_den' (x : K) : algebraMap A K (num A x) / algebraMap A K (den A x) = x := by\n  rw [← mk'_eq_div]\n  apply mk'_num_den\n\n"}
{"name":"IsFractionRing.num_mul_den_eq_num_iff_eq","module":"Mathlib.RingTheory.Localization.NumDen","initialProofState":"A : Type u_1\ninst✝⁵ : CommRing A\ninst✝⁴ : IsDomain A\ninst✝³ : UniqueFactorizationMonoid A\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\nx y : K\n⊢ Iff (Eq (HMul.hMul x ((algebraMap A K) ↑(IsFractionRing.den A y))) ((algebraMap A K) (IsFractionRing.num A y))) (Eq x y)","decl":"theorem num_mul_den_eq_num_iff_eq {x y : K} :\n    x * algebraMap A K (den A y) = algebraMap A K (num A y) ↔ x = y :=\n  ⟨fun h => by simpa only [mk'_num_den] using eq_mk'_iff_mul_eq.mpr h, fun h ↦\n    eq_mk'_iff_mul_eq.mp (by rw [h, mk'_num_den])⟩\n\n"}
{"name":"IsFractionRing.num_mul_den_eq_num_iff_eq'","module":"Mathlib.RingTheory.Localization.NumDen","initialProofState":"A : Type u_1\ninst✝⁵ : CommRing A\ninst✝⁴ : IsDomain A\ninst✝³ : UniqueFactorizationMonoid A\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\nx y : K\n⊢ Iff (Eq (HMul.hMul y ((algebraMap A K) ↑(IsFractionRing.den A x))) ((algebraMap A K) (IsFractionRing.num A x))) (Eq x y)","decl":"theorem num_mul_den_eq_num_iff_eq' {x y : K} :\n    y * algebraMap A K (den A x) = algebraMap A K (num A x) ↔ x = y :=\n  ⟨fun h ↦ by simpa only [eq_comm, mk'_num_den] using eq_mk'_iff_mul_eq.mpr h, fun h ↦\n    eq_mk'_iff_mul_eq.mp (by rw [h, mk'_num_den])⟩\n\n"}
{"name":"IsFractionRing.num_mul_den_eq_num_mul_den_iff_eq","module":"Mathlib.RingTheory.Localization.NumDen","initialProofState":"A : Type u_1\ninst✝⁵ : CommRing A\ninst✝⁴ : IsDomain A\ninst✝³ : UniqueFactorizationMonoid A\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\nx y : K\n⊢ Iff (Eq (HMul.hMul (IsFractionRing.num A y) ↑(IsFractionRing.den A x)) (HMul.hMul (IsFractionRing.num A x) ↑(IsFractionRing.den A y))) (Eq x y)","decl":"theorem num_mul_den_eq_num_mul_den_iff_eq {x y : K} :\n    num A y * den A x = num A x * den A y ↔ x = y :=\n  ⟨fun h ↦ by simpa only [mk'_num_den] using mk'_eq_of_eq' (S := K) h, fun h ↦ by rw [h]⟩\n\n"}
{"name":"IsFractionRing.eq_zero_of_num_eq_zero","module":"Mathlib.RingTheory.Localization.NumDen","initialProofState":"A : Type u_1\ninst✝⁵ : CommRing A\ninst✝⁴ : IsDomain A\ninst✝³ : UniqueFactorizationMonoid A\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\nx : K\nh : Eq (IsFractionRing.num A x) 0\n⊢ Eq x 0","decl":"theorem eq_zero_of_num_eq_zero {x : K} (h : num A x = 0) : x = 0 :=\n  (num_mul_den_eq_num_iff_eq' (A := A)).mp (by rw [zero_mul, h, RingHom.map_zero])\n\n"}
{"name":"IsFractionRing.num_zero","module":"Mathlib.RingTheory.Localization.NumDen","initialProofState":"A : Type u_1\ninst✝⁵ : CommRing A\ninst✝⁴ : IsDomain A\ninst✝³ : UniqueFactorizationMonoid A\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\n⊢ Eq (IsFractionRing.num A 0) 0","decl":"@[simp]\nlemma num_zero : IsFractionRing.num A (0 : K) = 0 := by\n  have := mk'_num_den' A (0 : K)\n  simp only [div_eq_zero_iff] at this\n  rcases this with h | h\n  · exact NoZeroSMulDivisors.algebraMap_injective A K (by convert h; simp)\n  · replace h : algebraMap A K (den A (0 : K)) = algebraMap A K 0 := by convert h; simp\n    absurd NoZeroSMulDivisors.algebraMap_injective A K h\n    apply nonZeroDivisors.coe_ne_zero\n\n"}
{"name":"IsFractionRing.num_eq_zero","module":"Mathlib.RingTheory.Localization.NumDen","initialProofState":"A : Type u_1\ninst✝⁵ : CommRing A\ninst✝⁴ : IsDomain A\ninst✝³ : UniqueFactorizationMonoid A\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\nx : K\n⊢ Iff (Eq (IsFractionRing.num A x) 0) (Eq x 0)","decl":"@[simp]\nlemma num_eq_zero (x : K) : IsFractionRing.num A x = 0 ↔ x = 0 :=\n  ⟨eq_zero_of_num_eq_zero, fun h ↦ h ▸ num_zero⟩\n\n"}
{"name":"IsFractionRing.isInteger_of_isUnit_den","module":"Mathlib.RingTheory.Localization.NumDen","initialProofState":"A : Type u_1\ninst✝⁵ : CommRing A\ninst✝⁴ : IsDomain A\ninst✝³ : UniqueFactorizationMonoid A\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\nx : K\nh : IsUnit ↑(IsFractionRing.den A x)\n⊢ IsLocalization.IsInteger A x","decl":"theorem isInteger_of_isUnit_den {x : K} (h : IsUnit (den A x : A)) : IsInteger A x := by\n  cases' h with d hd\n  have d_ne_zero : algebraMap A K (den A x) ≠ 0 :=\n    IsFractionRing.to_map_ne_zero_of_mem_nonZeroDivisors (den A x).2\n  use ↑d⁻¹ * num A x\n  refine _root_.trans ?_ (mk'_num_den A x)\n  rw [map_mul, map_units_inv, hd]\n  apply mul_left_cancel₀ d_ne_zero\n  rw [← mul_assoc, mul_inv_cancel₀ d_ne_zero, one_mul, mk'_spec']\n\n"}
{"name":"IsFractionRing.isUnit_den_iff","module":"Mathlib.RingTheory.Localization.NumDen","initialProofState":"A : Type u_1\ninst✝⁵ : CommRing A\ninst✝⁴ : IsDomain A\ninst✝³ : UniqueFactorizationMonoid A\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\nx : K\n⊢ Iff (IsUnit ↑(IsFractionRing.den A x)) (IsLocalization.IsInteger A x)","decl":"theorem isUnit_den_iff (x : K) : IsUnit (den A x : A) ↔ IsLocalization.IsInteger A x where\n  mp := isInteger_of_isUnit_den\n  mpr h := by\n    have ⟨v, h⟩ := h\n    apply IsRelPrime.isUnit_of_dvd (num_den_reduced A x).symm\n    use v\n    apply_fun algebraMap A K\n    · simp only [map_mul, h]\n      rw [mul_comm, ← div_eq_iff]\n      · simp only [mk'_num_den']\n      intro h\n      replace h : algebraMap A K (den A x : A) = algebraMap A K 0 := by convert h; simp\n      exact nonZeroDivisors.coe_ne_zero _ <| NoZeroSMulDivisors.algebraMap_injective A K h\n    exact NoZeroSMulDivisors.algebraMap_injective A K\n\n"}
{"name":"IsFractionRing.isUnit_den_zero","module":"Mathlib.RingTheory.Localization.NumDen","initialProofState":"A : Type u_1\ninst✝⁵ : CommRing A\ninst✝⁴ : IsDomain A\ninst✝³ : UniqueFactorizationMonoid A\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\n⊢ IsUnit ↑(IsFractionRing.den A 0)","decl":"theorem isUnit_den_zero : IsUnit (den A (0 : K) : A) := by\n  simp [isUnit_den_iff, IsLocalization.isInteger_zero]\n\n"}
{"name":"IsFractionRing.associated_den_num_inv","module":"Mathlib.RingTheory.Localization.NumDen","initialProofState":"A : Type u_1\ninst✝⁵ : CommRing A\ninst✝⁴ : IsDomain A\ninst✝³ : UniqueFactorizationMonoid A\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\nx : K\nhx : Ne x 0\n⊢ Associated (↑(IsFractionRing.den A x)) (IsFractionRing.num A (Inv.inv x))","decl":"lemma associated_den_num_inv (x : K) (hx : x ≠ 0) : Associated (den A x : A) (num A x⁻¹) :=\n  associated_of_dvd_dvd\n    (IsRelPrime.dvd_of_dvd_mul_right (IsFractionRing.num_den_reduced A x).symm <|\n      dvd_of_mul_left_dvd (a := (den A x⁻¹ : A)) <| dvd_of_eq <|\n      NoZeroSMulDivisors.algebraMap_injective A K <| Eq.symm <| eq_of_div_eq_one\n      (by simp [mul_div_mul_comm, hx]))\n    (IsRelPrime.dvd_of_dvd_mul_right (IsFractionRing.num_den_reduced A x⁻¹) <|\n      dvd_of_mul_left_dvd (a := (num A x : A)) <| dvd_of_eq <|\n      NoZeroSMulDivisors.algebraMap_injective A K <| eq_of_div_eq_one\n      (by simp [mul_div_mul_comm, hx]))\n\n"}
{"name":"IsFractionRing.associated_num_den_inv","module":"Mathlib.RingTheory.Localization.NumDen","initialProofState":"A : Type u_1\ninst✝⁵ : CommRing A\ninst✝⁴ : IsDomain A\ninst✝³ : UniqueFactorizationMonoid A\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\nx : K\nhx : Ne x 0\n⊢ Associated (IsFractionRing.num A x) ↑(IsFractionRing.den A (Inv.inv x))","decl":"lemma associated_num_den_inv (x : K) (hx : x ≠ 0) : Associated (num A x : A) (den A x⁻¹) := by\n  have : Associated (num A x⁻¹⁻¹ : A) (den A x⁻¹) :=\n    (associated_den_num_inv x⁻¹ (inv_ne_zero hx)).symm\n  rw [inv_inv] at this\n  exact this\n\n"}
