{"name":"QuadraticMap.map_add","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddCommGroup M\ninst✝ : AddCommGroup N\nf : M → N\nx y : M\n⊢ Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (HAdd.hAdd (f x) (f y)) (QuadraticMap.polar f x y))","decl":"protected theorem map_add (f : M → N) (x y : M) :\n    f (x + y) = f x + f y + polar f x y := by\n  rw [polar]\n  abel\n\n"}
{"name":"QuadraticMap.polar_add","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddCommGroup M\ninst✝ : AddCommGroup N\nf g : M → N\nx y : M\n⊢ Eq (QuadraticMap.polar (HAdd.hAdd f g) x y) (HAdd.hAdd (QuadraticMap.polar f x y) (QuadraticMap.polar g x y))","decl":"theorem polar_add (f g : M → N) (x y : M) : polar (f + g) x y = polar f x y + polar g x y := by\n  simp only [polar, Pi.add_apply]\n  abel\n\n"}
{"name":"QuadraticMap.polar_neg","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddCommGroup M\ninst✝ : AddCommGroup N\nf : M → N\nx y : M\n⊢ Eq (QuadraticMap.polar (Neg.neg f) x y) (Neg.neg (QuadraticMap.polar f x y))","decl":"theorem polar_neg (f : M → N) (x y : M) : polar (-f) x y = -polar f x y := by\n  simp only [polar, Pi.neg_apply, sub_eq_add_neg, neg_add]\n\n"}
{"name":"QuadraticMap.polar_smul","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"S : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Monoid S\ninst✝ : DistribMulAction S N\nf : M → N\ns : S\nx y : M\n⊢ Eq (QuadraticMap.polar (HSMul.hSMul s f) x y) (HSMul.hSMul s (QuadraticMap.polar f x y))","decl":"theorem polar_smul [Monoid S] [DistribMulAction S N] (f : M → N) (s : S) (x y : M) :\n    polar (s • f) x y = s • polar f x y := by simp only [polar, Pi.smul_apply, smul_sub]\n\n"}
{"name":"QuadraticMap.polar_comm","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddCommGroup M\ninst✝ : AddCommGroup N\nf : M → N\nx y : M\n⊢ Eq (QuadraticMap.polar f x y) (QuadraticMap.polar f y x)","decl":"theorem polar_comm (f : M → N) (x y : M) : polar f x y = polar f y x := by\n  rw [polar, polar, add_comm, sub_sub, sub_sub, add_comm (f x) (f y)]\n\n"}
{"name":"QuadraticMap.polar_add_left_iff","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddCommGroup M\ninst✝ : AddCommGroup N\nf : M → N\nx x' y : M\n⊢ Iff (Eq (QuadraticMap.polar f (HAdd.hAdd x x') y) (HAdd.hAdd (QuadraticMap.polar f x y) (QuadraticMap.polar f x' y))) (Eq (HAdd.hAdd (f (HAdd.hAdd (HAdd.hAdd x x') y)) (HAdd.hAdd (HAdd.hAdd (f x) (f x')) (f y))) (HAdd.hAdd (HAdd.hAdd (f (HAdd.hAdd x x')) (f (HAdd.hAdd x' y))) (f (HAdd.hAdd y x))))","decl":"/-- Auxiliary lemma to express bilinearity of `QuadraticMap.polar` without subtraction. -/\ntheorem polar_add_left_iff {f : M → N} {x x' y : M} :\n    polar f (x + x') y = polar f x y + polar f x' y ↔\n      f (x + x' + y) + (f x + f x' + f y) = f (x + x') + f (x' + y) + f (y + x) := by\n  simp only [← add_assoc]\n  simp only [polar, sub_eq_iff_eq_add, eq_sub_iff_add_eq, sub_add_eq_add_sub, add_sub]\n  simp only [add_right_comm _ (f y) _, add_right_comm _ (f x') (f x)]\n  rw [add_comm y x, add_right_comm _ _ (f (x + y)), add_comm _ (f (x + y)),\n    add_right_comm (f (x + y)), add_left_inj]\n\n"}
{"name":"QuadraticMap.polar_comp","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"S : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup N\nF : Type u_8\ninst✝² : CommRing S\ninst✝¹ : FunLike F N S\ninst✝ : AddMonoidHomClass F N S\nf : M → N\ng : F\nx y : M\n⊢ Eq (QuadraticMap.polar (Function.comp (⇑g) f) x y) (g (QuadraticMap.polar f x y))","decl":"theorem polar_comp {F : Type*} [CommRing S] [FunLike F N S] [AddMonoidHomClass F N S]\n    (f : M → N) (g : F) (x y : M) :\n    polar (g ∘ f) x y = g (polar f x y) := by\n  simp only [polar, Pi.smul_apply, Function.comp_apply, map_sub]\n\n"}
{"name":"QuadraticMap.mk.injEq","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u\nM : Type v\nN : Type w\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\ntoFun✝ : M → N\ntoFun_smul✝ : ∀ (a : R) (x : M), Eq (toFun✝ (HSMul.hSMul a x)) (HSMul.hSMul (HMul.hMul a a) (toFun✝ x))\nexists_companion'✝ : Exists fun B => ∀ (x y : M), Eq (toFun✝ (HAdd.hAdd x y)) (HAdd.hAdd (HAdd.hAdd (toFun✝ x) (toFun✝ y)) ((B x) y))\ntoFun : M → N\ntoFun_smul : ∀ (a : R) (x : M), Eq (toFun (HSMul.hSMul a x)) (HSMul.hSMul (HMul.hMul a a) (toFun x))\nexists_companion' : Exists fun B => ∀ (x y : M), Eq (toFun (HAdd.hAdd x y)) (HAdd.hAdd (HAdd.hAdd (toFun x) (toFun y)) ((B x) y))\n⊢ Eq (Eq { toFun := toFun✝, toFun_smul := toFun_smul✝, exists_companion' := exists_companion'✝ } { toFun := toFun, toFun_smul := toFun_smul, exists_companion' := exists_companion' }) (Eq toFun✝ toFun)","decl":"/-- A quadratic map on a module.\n\nFor a more familiar constructor when `R` is a ring, see `QuadraticMap.ofPolar`. -/\nstructure QuadraticMap (R : Type u) (M : Type v) (N : Type w) [CommSemiring R] [AddCommMonoid M]\n    [Module R M] [AddCommMonoid N] [Module R N] where\n  toFun : M → N\n  toFun_smul : ∀ (a : R) (x : M), toFun (a • x) = (a * a) • toFun x\n  exists_companion' : ∃ B : BilinMap R M N, ∀ x y, toFun (x + y) = toFun x + toFun y + B x y\n\n"}
{"name":"QuadraticMap.mk.inj","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u\nM : Type v\nN : Type w\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\ntoFun✝ : M → N\ntoFun_smul✝ : ∀ (a : R) (x : M), Eq (toFun✝ (HSMul.hSMul a x)) (HSMul.hSMul (HMul.hMul a a) (toFun✝ x))\nexists_companion'✝ : Exists fun B => ∀ (x y : M), Eq (toFun✝ (HAdd.hAdd x y)) (HAdd.hAdd (HAdd.hAdd (toFun✝ x) (toFun✝ y)) ((B x) y))\ntoFun : M → N\ntoFun_smul : ∀ (a : R) (x : M), Eq (toFun (HSMul.hSMul a x)) (HSMul.hSMul (HMul.hMul a a) (toFun x))\nexists_companion' : Exists fun B => ∀ (x y : M), Eq (toFun (HAdd.hAdd x y)) (HAdd.hAdd (HAdd.hAdd (toFun x) (toFun y)) ((B x) y))\nx✝ : Eq { toFun := toFun✝, toFun_smul := toFun_smul✝, exists_companion' := exists_companion'✝ } { toFun := toFun, toFun_smul := toFun_smul, exists_companion' := exists_companion' }\n⊢ Eq toFun✝ toFun","decl":"/-- A quadratic map on a module.\n\nFor a more familiar constructor when `R` is a ring, see `QuadraticMap.ofPolar`. -/\nstructure QuadraticMap (R : Type u) (M : Type v) (N : Type w) [CommSemiring R] [AddCommMonoid M]\n    [Module R M] [AddCommMonoid N] [Module R N] where\n  toFun : M → N\n  toFun_smul : ∀ (a : R) (x : M), toFun (a • x) = (a * a) • toFun x\n  exists_companion' : ∃ B : BilinMap R M N, ∀ x y, toFun (x + y) = toFun x + toFun y + B x y\n\n"}
{"name":"QuadraticMap.mk.sizeOf_spec","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u\nM : Type v\nN : Type w\ninst✝⁷ : CommSemiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R N\ninst✝² : SizeOf R\ninst✝¹ : SizeOf M\ninst✝ : SizeOf N\ntoFun : M → N\ntoFun_smul : ∀ (a : R) (x : M), Eq (toFun (HSMul.hSMul a x)) (HSMul.hSMul (HMul.hMul a a) (toFun x))\nexists_companion' : Exists fun B => ∀ (x y : M), Eq (toFun (HAdd.hAdd x y)) (HAdd.hAdd (HAdd.hAdd (toFun x) (toFun y)) ((B x) y))\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, toFun_smul := toFun_smul, exists_companion' := exists_companion' }) (HAdd.hAdd 1 (SizeOf.sizeOf exists_companion'))","decl":"/-- A quadratic map on a module.\n\nFor a more familiar constructor when `R` is a ring, see `QuadraticMap.ofPolar`. -/\nstructure QuadraticMap (R : Type u) (M : Type v) (N : Type w) [CommSemiring R] [AddCommMonoid M]\n    [Module R M] [AddCommMonoid N] [Module R N] where\n  toFun : M → N\n  toFun_smul : ∀ (a : R) (x : M), toFun (a • x) = (a * a) • toFun x\n  exists_companion' : ∃ B : BilinMap R M N, ∀ x y, toFun (x + y) = toFun x + toFun y + B x y\n\n"}
{"name":"QuadraticMap.exists_companion'","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u\nM : Type v\nN : Type w\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nself : QuadraticMap R M N\n⊢ Exists fun B => ∀ (x y : M), Eq (self.toFun (HAdd.hAdd x y)) (HAdd.hAdd (HAdd.hAdd (self.toFun x) (self.toFun y)) ((B x) y))","decl":"/-- A quadratic map on a module.\n\nFor a more familiar constructor when `R` is a ring, see `QuadraticMap.ofPolar`. -/\nstructure QuadraticMap (R : Type u) (M : Type v) (N : Type w) [CommSemiring R] [AddCommMonoid M]\n    [Module R M] [AddCommMonoid N] [Module R N] where\n  toFun : M → N\n  toFun_smul : ∀ (a : R) (x : M), toFun (a • x) = (a * a) • toFun x\n  exists_companion' : ∃ B : BilinMap R M N, ∀ x y, toFun (x + y) = toFun x + toFun y + B x y\n\n"}
{"name":"QuadraticMap.toFun_smul","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u\nM : Type v\nN : Type w\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nself : QuadraticMap R M N\na : R\nx : M\n⊢ Eq (self.toFun (HSMul.hSMul a x)) (HSMul.hSMul (HMul.hMul a a) (self.toFun x))","decl":"/-- A quadratic map on a module.\n\nFor a more familiar constructor when `R` is a ring, see `QuadraticMap.ofPolar`. -/\nstructure QuadraticMap (R : Type u) (M : Type v) (N : Type w) [CommSemiring R] [AddCommMonoid M]\n    [Module R M] [AddCommMonoid N] [Module R N] where\n  toFun : M → N\n  toFun_smul : ∀ (a : R) (x : M), toFun (a • x) = (a * a) • toFun x\n  exists_companion' : ∃ B : BilinMap R M N, ∀ x y, toFun (x + y) = toFun x + toFun y + B x y\n\n"}
{"name":"QuadraticMap.toFun_eq_coe","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nQ : QuadraticMap R M N\n⊢ Eq Q.toFun ⇑Q","decl":"/-- The `simp` normal form for a quadratic map is `DFunLike.coe`, not `toFun`. -/\n@[simp]\ntheorem toFun_eq_coe : Q.toFun = ⇑Q :=\n  rfl\n\n-- this must come after the coe_to_fun definition\n"}
{"name":"QuadraticMap.ext_iff","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nQ Q' : QuadraticMap R M N\n⊢ Iff (Eq Q Q') (∀ (x : M), Eq (Q x) (Q' x))","decl":"@[ext]\ntheorem ext (H : ∀ x : M, Q x = Q' x) : Q = Q' :=\n  DFunLike.ext _ _ H\n\n"}
{"name":"QuadraticMap.ext","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nQ Q' : QuadraticMap R M N\nH : ∀ (x : M), Eq (Q x) (Q' x)\n⊢ Eq Q Q'","decl":"@[ext]\ntheorem ext (H : ∀ x : M, Q x = Q' x) : Q = Q' :=\n  DFunLike.ext _ _ H\n\n"}
{"name":"QuadraticMap.congr_fun","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nQ Q' : QuadraticMap R M N\nh : Eq Q Q'\nx : M\n⊢ Eq (Q x) (Q' x)","decl":"theorem congr_fun (h : Q = Q') (x : M) : Q x = Q' x :=\n  DFunLike.congr_fun h _\n\n"}
{"name":"QuadraticMap.coe_copy","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nQ : QuadraticMap R M N\nQ' : M → N\nh : Eq Q' ⇑Q\n⊢ Eq (⇑(Q.copy Q' h)) Q'","decl":"@[simp]\ntheorem coe_copy (Q : QuadraticMap R M N) (Q' : M → N) (h : Q' = ⇑Q) : ⇑(Q.copy Q' h) = Q' :=\n  rfl\n\n"}
{"name":"QuadraticMap.copy_eq","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nQ : QuadraticMap R M N\nQ' : M → N\nh : Eq Q' ⇑Q\n⊢ Eq (Q.copy Q' h) Q","decl":"theorem copy_eq (Q : QuadraticMap R M N) (Q' : M → N) (h : Q' = ⇑Q) : Q.copy Q' h = Q :=\n  DFunLike.ext' h\n\n"}
{"name":"QuadraticMap.map_smul","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nQ : QuadraticMap R M N\na : R\nx : M\n⊢ Eq (Q (HSMul.hSMul a x)) (HSMul.hSMul (HMul.hMul a a) (Q x))","decl":"theorem map_smul (a : R) (x : M) : Q (a • x) = (a * a) • Q x :=\n  Q.toFun_smul a x\n\n"}
{"name":"QuadraticMap.exists_companion","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nQ : QuadraticMap R M N\n⊢ Exists fun B => ∀ (x y : M), Eq (Q (HAdd.hAdd x y)) (HAdd.hAdd (HAdd.hAdd (Q x) (Q y)) ((B x) y))","decl":"theorem exists_companion : ∃ B : BilinMap R M N, ∀ x y, Q (x + y) = Q x + Q y + B x y :=\n  Q.exists_companion'\n\n"}
{"name":"QuadraticMap.map_add_add_add_map","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nQ : QuadraticMap R M N\nx y z : M\n⊢ Eq (HAdd.hAdd (Q (HAdd.hAdd (HAdd.hAdd x y) z)) (HAdd.hAdd (HAdd.hAdd (Q x) (Q y)) (Q z))) (HAdd.hAdd (HAdd.hAdd (Q (HAdd.hAdd x y)) (Q (HAdd.hAdd y z))) (Q (HAdd.hAdd z x)))","decl":"theorem map_add_add_add_map (x y z : M) :\n    Q (x + y + z) + (Q x + Q y + Q z) = Q (x + y) + Q (y + z) + Q (z + x) := by\n  obtain ⟨B, h⟩ := Q.exists_companion\n  rw [add_comm z x]\n  simp only [h, LinearMap.map_add₂]\n  abel\n\n"}
{"name":"QuadraticMap.map_add_self","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nQ : QuadraticMap R M N\nx : M\n⊢ Eq (Q (HAdd.hAdd x x)) (HSMul.hSMul 4 (Q x))","decl":"theorem map_add_self (x : M) : Q (x + x) = 4 • Q x := by\n  rw [← two_smul R x, map_smul, ← Nat.cast_smul_eq_nsmul R]\n  norm_num\n\n-- not @[simp] because it is superseded by `ZeroHomClass.map_zero`\n"}
{"name":"QuadraticMap.map_zero","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nQ : QuadraticMap R M N\n⊢ Eq (Q 0) 0","decl":"protected theorem map_zero : Q 0 = 0 := by\n  rw [← @zero_smul R _ _ _ _ (0 : M), map_smul, zero_mul, zero_smul]\n\n"}
{"name":"QuadraticMap.zeroHomClass","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\n⊢ ZeroHomClass (QuadraticMap R M N) M N","decl":"instance zeroHomClass : ZeroHomClass (QuadraticMap R M N) M N :=\n  { QuadraticMap.instFunLike (R := R) (M := M) (N := N) with map_zero := QuadraticMap.map_zero }\n\n"}
{"name":"QuadraticMap.map_smul_of_tower","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"S : Type u_1\nR : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\ninst✝⁷ : AddCommMonoid N\ninst✝⁶ : Module R N\nQ : QuadraticMap R M N\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra S R\ninst✝³ : Module S M\ninst✝² : IsScalarTower S R M\ninst✝¹ : Module S N\ninst✝ : IsScalarTower S R N\na : S\nx : M\n⊢ Eq (Q (HSMul.hSMul a x)) (HSMul.hSMul (HMul.hMul a a) (Q x))","decl":"theorem map_smul_of_tower [CommSemiring S] [Algebra S R] [Module S M] [IsScalarTower S R M]\n    [Module S N] [IsScalarTower S R N] (a : S)\n    (x : M) : Q (a • x) = (a * a) • Q x := by\n  rw [← IsScalarTower.algebraMap_smul R a x, map_smul, ← RingHom.map_mul, algebraMap_smul]\n\n"}
{"name":"QuadraticMap.map_neg","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticMap R M N\nx : M\n⊢ Eq (Q (Neg.neg x)) (Q x)","decl":"@[simp]\ntheorem map_neg (x : M) : Q (-x) = Q x := by\n  rw [← @neg_one_smul R _ _ _ _ x, map_smul, neg_one_mul, neg_neg, one_smul]\n\n"}
{"name":"QuadraticMap.map_sub","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticMap R M N\nx y : M\n⊢ Eq (Q (HSub.hSub x y)) (Q (HSub.hSub y x))","decl":"theorem map_sub (x y : M) : Q (x - y) = Q (y - x) := by rw [← neg_sub, map_neg]\n\n"}
{"name":"QuadraticMap.polar_zero_left","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticMap R M N\ny : M\n⊢ Eq (QuadraticMap.polar (⇑Q) 0 y) 0","decl":"@[simp]\ntheorem polar_zero_left (y : M) : polar Q 0 y = 0 := by\n  simp only [polar, zero_add, QuadraticMap.map_zero, sub_zero, sub_self]\n\n"}
{"name":"QuadraticMap.polar_add_left","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticMap R M N\nx x' y : M\n⊢ Eq (QuadraticMap.polar (⇑Q) (HAdd.hAdd x x') y) (HAdd.hAdd (QuadraticMap.polar (⇑Q) x y) (QuadraticMap.polar (⇑Q) x' y))","decl":"@[simp]\ntheorem polar_add_left (x x' y : M) : polar Q (x + x') y = polar Q x y + polar Q x' y :=\n  polar_add_left_iff.mpr <| Q.map_add_add_add_map x x' y\n\n"}
{"name":"QuadraticMap.polar_smul_left","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticMap R M N\na : R\nx y : M\n⊢ Eq (QuadraticMap.polar (⇑Q) (HSMul.hSMul a x) y) (HSMul.hSMul a (QuadraticMap.polar (⇑Q) x y))","decl":"@[simp]\ntheorem polar_smul_left (a : R) (x y : M) : polar Q (a • x) y = a • polar Q x y := by\n  obtain ⟨B, h⟩ := Q.exists_companion\n  simp_rw [polar, h, Q.map_smul, LinearMap.map_smul₂, sub_sub, add_sub_cancel_left]\n\n"}
{"name":"QuadraticMap.polar_neg_left","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticMap R M N\nx y : M\n⊢ Eq (QuadraticMap.polar (⇑Q) (Neg.neg x) y) (Neg.neg (QuadraticMap.polar (⇑Q) x y))","decl":"@[simp]\ntheorem polar_neg_left (x y : M) : polar Q (-x) y = -polar Q x y := by\n  rw [← neg_one_smul R x, polar_smul_left, neg_one_smul]\n\n"}
{"name":"QuadraticMap.polar_sub_left","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticMap R M N\nx x' y : M\n⊢ Eq (QuadraticMap.polar (⇑Q) (HSub.hSub x x') y) (HSub.hSub (QuadraticMap.polar (⇑Q) x y) (QuadraticMap.polar (⇑Q) x' y))","decl":"@[simp]\ntheorem polar_sub_left (x x' y : M) : polar Q (x - x') y = polar Q x y - polar Q x' y := by\n  rw [sub_eq_add_neg, sub_eq_add_neg, polar_add_left, polar_neg_left]\n\n"}
{"name":"QuadraticMap.polar_zero_right","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticMap R M N\ny : M\n⊢ Eq (QuadraticMap.polar (⇑Q) y 0) 0","decl":"@[simp]\ntheorem polar_zero_right (y : M) : polar Q y 0 = 0 := by\n  simp only [add_zero, polar, QuadraticMap.map_zero, sub_self]\n\n"}
{"name":"QuadraticMap.polar_add_right","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticMap R M N\nx y y' : M\n⊢ Eq (QuadraticMap.polar (⇑Q) x (HAdd.hAdd y y')) (HAdd.hAdd (QuadraticMap.polar (⇑Q) x y) (QuadraticMap.polar (⇑Q) x y'))","decl":"@[simp]\ntheorem polar_add_right (x y y' : M) : polar Q x (y + y') = polar Q x y + polar Q x y' := by\n  rw [polar_comm Q x, polar_comm Q x, polar_comm Q x, polar_add_left]\n\n"}
{"name":"QuadraticMap.polar_smul_right","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticMap R M N\na : R\nx y : M\n⊢ Eq (QuadraticMap.polar (⇑Q) x (HSMul.hSMul a y)) (HSMul.hSMul a (QuadraticMap.polar (⇑Q) x y))","decl":"@[simp]\ntheorem polar_smul_right (a : R) (x y : M) : polar Q x (a • y) = a • polar Q x y := by\n  rw [polar_comm Q x, polar_comm Q x, polar_smul_left]\n\n"}
{"name":"QuadraticMap.polar_neg_right","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticMap R M N\nx y : M\n⊢ Eq (QuadraticMap.polar (⇑Q) x (Neg.neg y)) (Neg.neg (QuadraticMap.polar (⇑Q) x y))","decl":"@[simp]\ntheorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by\n  rw [← neg_one_smul R y, polar_smul_right, neg_one_smul]\n\n"}
{"name":"QuadraticMap.polar_sub_right","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticMap R M N\nx y y' : M\n⊢ Eq (QuadraticMap.polar (⇑Q) x (HSub.hSub y y')) (HSub.hSub (QuadraticMap.polar (⇑Q) x y) (QuadraticMap.polar (⇑Q) x y'))","decl":"@[simp]\ntheorem polar_sub_right (x y y' : M) : polar Q x (y - y') = polar Q x y - polar Q x y' := by\n  rw [sub_eq_add_neg, sub_eq_add_neg, polar_add_right, polar_neg_right]\n\n"}
{"name":"QuadraticMap.polar_self","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticMap R M N\nx : M\n⊢ Eq (QuadraticMap.polar (⇑Q) x x) (HSMul.hSMul 2 (Q x))","decl":"@[simp]\ntheorem polar_self (x : M) : polar Q x x = 2 • Q x := by\n  rw [polar, map_add_self, sub_sub, sub_eq_iff_eq_add, ← two_smul ℕ, ← two_smul ℕ, ← mul_smul]\n  norm_num\n\n"}
{"name":"QuadraticMap.polarBilin_apply_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticMap R M N\nm y : M\n⊢ Eq ((Q.polarBilin m) y) (QuadraticMap.polar (⇑Q) m y)","decl":"/-- `QuadraticMap.polar` as a bilinear map -/\n@[simps!]\ndef polarBilin : BilinMap R M N :=\n  LinearMap.mk₂ R (polar Q) (polar_add_left Q) (polar_smul_left Q) (polar_add_right Q)\n  (polar_smul_right Q)\n\n"}
{"name":"QuadraticMap.polar_smul_left_of_tower","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"S : Type u_1\nR : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝¹⁰ : CommRing R\ninst✝⁹ : AddCommGroup M\ninst✝⁸ : AddCommGroup N\ninst✝⁷ : Module R M\ninst✝⁶ : Module R N\nQ : QuadraticMap R M N\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra S R\ninst✝³ : Module S M\ninst✝² : IsScalarTower S R M\ninst✝¹ : Module S N\ninst✝ : IsScalarTower S R N\na : S\nx y : M\n⊢ Eq (QuadraticMap.polar (⇑Q) (HSMul.hSMul a x) y) (HSMul.hSMul a (QuadraticMap.polar (⇑Q) x y))","decl":"@[simp]\ntheorem polar_smul_left_of_tower (a : S) (x y : M) : polar Q (a • x) y = a • polar Q x y := by\n  rw [← IsScalarTower.algebraMap_smul R a x, polar_smul_left, algebraMap_smul]\n\n"}
{"name":"QuadraticMap.polar_smul_right_of_tower","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"S : Type u_1\nR : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝¹⁰ : CommRing R\ninst✝⁹ : AddCommGroup M\ninst✝⁸ : AddCommGroup N\ninst✝⁷ : Module R M\ninst✝⁶ : Module R N\nQ : QuadraticMap R M N\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra S R\ninst✝³ : Module S M\ninst✝² : IsScalarTower S R M\ninst✝¹ : Module S N\ninst✝ : IsScalarTower S R N\na : S\nx y : M\n⊢ Eq (QuadraticMap.polar (⇑Q) x (HSMul.hSMul a y)) (HSMul.hSMul a (QuadraticMap.polar (⇑Q) x y))","decl":"@[simp]\ntheorem polar_smul_right_of_tower (a : S) (x y : M) : polar Q x (a • y) = a • polar Q x y := by\n  rw [← IsScalarTower.algebraMap_smul R a y, polar_smul_right, algebraMap_smul]\n\n"}
{"name":"QuadraticMap.ofPolar_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\ntoFun : M → N\ntoFun_smul : ∀ (a : R) (x : M), Eq (toFun (HSMul.hSMul a x)) (HSMul.hSMul (HMul.hMul a a) (toFun x))\npolar_add_left : ∀ (x x' y : M), Eq (QuadraticMap.polar toFun (HAdd.hAdd x x') y) (HAdd.hAdd (QuadraticMap.polar toFun x y) (QuadraticMap.polar toFun x' y))\npolar_smul_left : ∀ (a : R) (x y : M), Eq (QuadraticMap.polar toFun (HSMul.hSMul a x) y) (HSMul.hSMul a (QuadraticMap.polar toFun x y))\na✝ : M\n⊢ Eq ((QuadraticMap.ofPolar toFun toFun_smul polar_add_left polar_smul_left) a✝) (toFun a✝)","decl":"/-- An alternative constructor to `QuadraticMap.mk`, for rings where `polar` can be used. -/\n@[simps]\ndef ofPolar (toFun : M → N) (toFun_smul : ∀ (a : R) (x : M), toFun (a • x) = (a * a) • toFun x)\n    (polar_add_left : ∀ x x' y : M, polar toFun (x + x') y = polar toFun x y + polar toFun x' y)\n    (polar_smul_left : ∀ (a : R) (x y : M), polar toFun (a • x) y = a • polar toFun x y) :\n    QuadraticMap R M N :=\n  { toFun\n    toFun_smul\n    exists_companion' := ⟨LinearMap.mk₂ R (polar toFun) (polar_add_left) (polar_smul_left)\n      (fun x _ _ ↦ by simp_rw [polar_comm _ x, polar_add_left])\n      (fun _ _ _ ↦ by rw [polar_comm, polar_smul_left, polar_comm]),\n      fun _ _ ↦ by\n        simp only [LinearMap.mk₂_apply]\n        rw [polar, sub_sub, add_sub_cancel]⟩ }\n\n"}
{"name":"QuadraticMap.choose_exists_companion","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticMap R M N\n⊢ Eq ⋯.choose Q.polarBilin","decl":"/-- In a ring the companion bilinear form is unique and equal to `QuadraticMap.polar`. -/\ntheorem choose_exists_companion : Q.exists_companion.choose = polarBilin Q :=\n  LinearMap.ext₂ fun x y => by\n    rw [polarBilin_apply_apply, polar, Q.exists_companion.choose_spec, sub_sub,\n      add_sub_cancel_left]\n\n"}
{"name":"QuadraticMap.map_sum","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup N\ninst✝² : Module R M\ninst✝¹ : Module R N\nι : Type u_8\ninst✝ : DecidableEq ι\nQ : QuadraticMap R M N\ns : Finset ι\nf : ι → M\n⊢ Eq (Q (s.sum fun i => f i)) (HAdd.hAdd (s.sum fun i => Q (f i)) ((Finset.filter (fun ij => Not ij.IsDiag) s.sym2).sum fun ij => Sym2.lift ⟨fun i j => QuadraticMap.polar (⇑Q) (f i) (f j), ⋯⟩ ij))","decl":"protected theorem map_sum {ι} [DecidableEq ι] (Q : QuadraticMap R M N) (s : Finset ι) (f : ι → M) :\n    Q (∑ i ∈ s, f i) = ∑ i ∈ s, Q (f i) +\n      ∑ ij ∈ s.sym2 with ¬ ij.IsDiag,\n        Sym2.lift ⟨fun i j => polar Q (f i) (f j), fun _ _ => polar_comm _ _ _⟩ ij := by\n  induction s using Finset.cons_induction with\n  | empty => simp\n  | cons a s ha ih =>\n    simp_rw [Finset.sum_cons, QuadraticMap.map_add, ih, add_assoc, Finset.sym2_cons,\n      Finset.sum_filter, Finset.sum_disjUnion, Finset.sum_map, Finset.sum_cons,\n      Sym2.mkEmbedding_apply, Sym2.isDiag_iff_proj_eq, not_true, if_false, zero_add, Sym2.lift_mk,\n      ← polarBilin_apply_apply, _root_.map_sum, polarBilin_apply_apply]\n    congr 2\n    rw [add_comm]\n    congr! with i hi\n    rw [if_pos (ne_of_mem_of_not_mem hi ha).symm]\n\n"}
{"name":"QuadraticMap.map_sum'","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nι : Type u_8\nQ : QuadraticMap R M N\ns : Finset ι\nf : ι → M\n⊢ Eq (Q (s.sum fun i => f i)) (HSub.hSub (s.sym2.sum fun ij => Sym2.lift ⟨fun i j => QuadraticMap.polar (⇑Q) (f i) (f j), ⋯⟩ ij) (s.sum fun i => Q (f i)))","decl":"protected theorem map_sum' {ι} (Q : QuadraticMap R M N) (s : Finset ι) (f : ι → M) :\n    Q (∑ i ∈ s, f i) =\n      ∑ ij ∈ s.sym2,\n        Sym2.lift ⟨fun i j => polar Q (f i) (f j), fun _ _ => polar_comm _ _ _⟩ ij\n      - ∑ i ∈ s, Q (f i) := by\n  induction s using Finset.cons_induction with\n  | empty => simp\n  | cons a s ha ih =>\n    simp_rw [Finset.sum_cons, QuadraticMap.map_add Q, ih, add_assoc, Finset.sym2_cons,\n      Finset.sum_disjUnion, Finset.sum_map, Finset.sum_cons, Sym2.mkEmbedding_apply, Sym2.lift_mk,\n      ← polarBilin_apply_apply, _root_.map_sum, polarBilin_apply_apply, polar_self]\n    abel_nf\n\n"}
{"name":"QuadraticMap.coeFn_smul","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"S : Type u_1\nR : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁷ : CommSemiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R N\ninst✝² : Monoid S\ninst✝¹ : DistribMulAction S N\ninst✝ : SMulCommClass S R N\na : S\nQ : QuadraticMap R M N\n⊢ Eq (⇑(HSMul.hSMul a Q)) (HSMul.hSMul a ⇑Q)","decl":"@[simp]\ntheorem coeFn_smul (a : S) (Q : QuadraticMap R M N) : ⇑(a • Q) = a • ⇑Q :=\n  rfl\n\n"}
{"name":"QuadraticMap.smul_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"S : Type u_1\nR : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁷ : CommSemiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R N\ninst✝² : Monoid S\ninst✝¹ : DistribMulAction S N\ninst✝ : SMulCommClass S R N\na : S\nQ : QuadraticMap R M N\nx : M\n⊢ Eq ((HSMul.hSMul a Q) x) (HSMul.hSMul a (Q x))","decl":"@[simp]\ntheorem smul_apply (a : S) (Q : QuadraticMap R M N) (x : M) : (a • Q) x = a • Q x :=\n  rfl\n\n"}
{"name":"QuadraticMap.instSMulCommClass","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"S : Type u_1\nT : Type u_2\nR : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝¹¹ : CommSemiring R\ninst✝¹⁰ : AddCommMonoid M\ninst✝⁹ : Module R M\ninst✝⁸ : AddCommMonoid N\ninst✝⁷ : Module R N\ninst✝⁶ : Monoid S\ninst✝⁵ : Monoid T\ninst✝⁴ : DistribMulAction S N\ninst✝³ : DistribMulAction T N\ninst✝² : SMulCommClass S R N\ninst✝¹ : SMulCommClass T R N\ninst✝ : SMulCommClass S T N\n⊢ SMulCommClass S T (QuadraticMap R M N)","decl":"instance [SMulCommClass S T N] : SMulCommClass S T (QuadraticMap R M N) where\n  smul_comm _s _t _q := ext fun _ => smul_comm _ _ _\n\n"}
{"name":"QuadraticMap.instIsScalarTower","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"S : Type u_1\nT : Type u_2\nR : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝¹² : CommSemiring R\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : Module R M\ninst✝⁹ : AddCommMonoid N\ninst✝⁸ : Module R N\ninst✝⁷ : Monoid S\ninst✝⁶ : Monoid T\ninst✝⁵ : DistribMulAction S N\ninst✝⁴ : DistribMulAction T N\ninst✝³ : SMulCommClass S R N\ninst✝² : SMulCommClass T R N\ninst✝¹ : SMul S T\ninst✝ : IsScalarTower S T N\n⊢ IsScalarTower S T (QuadraticMap R M N)","decl":"instance [SMul S T] [IsScalarTower S T N] : IsScalarTower S T (QuadraticMap R M N) where\n  smul_assoc _s _t _q := ext fun _ => smul_assoc _ _ _\n\n"}
{"name":"QuadraticMap.coeFn_zero","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\n⊢ Eq (⇑0) 0","decl":"@[simp]\ntheorem coeFn_zero : ⇑(0 : QuadraticMap R M N) = 0 :=\n  rfl\n\n"}
{"name":"QuadraticMap.zero_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nx : M\n⊢ Eq (0 x) 0","decl":"@[simp]\ntheorem zero_apply (x : M) : (0 : QuadraticMap R M N) x = 0 :=\n  rfl\n\n"}
{"name":"QuadraticMap.coeFn_add","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nQ Q' : QuadraticMap R M N\n⊢ Eq (⇑(HAdd.hAdd Q Q')) (HAdd.hAdd ⇑Q ⇑Q')","decl":"@[simp]\ntheorem coeFn_add (Q Q' : QuadraticMap R M N) : ⇑(Q + Q') = Q + Q' :=\n  rfl\n\n"}
{"name":"QuadraticMap.add_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nQ Q' : QuadraticMap R M N\nx : M\n⊢ Eq ((HAdd.hAdd Q Q') x) (HAdd.hAdd (Q x) (Q' x))","decl":"@[simp]\ntheorem add_apply (Q Q' : QuadraticMap R M N) (x : M) : (Q + Q') x = Q x + Q' x :=\n  rfl\n\n"}
{"name":"QuadraticMap.coeFnAddMonoidHom_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\na✝ : QuadraticMap R M N\na : M\n⊢ Eq (QuadraticMap.coeFnAddMonoidHom a✝ a) (a✝ a)","decl":"/-- `@CoeFn (QuadraticMap R M)` as an `AddMonoidHom`.\n\nThis API mirrors `AddMonoidHom.coeFn`. -/\n@[simps apply]\ndef coeFnAddMonoidHom : QuadraticMap R M N →+ M → N where\n  toFun := DFunLike.coe\n  map_zero' := coeFn_zero\n  map_add' := coeFn_add\n\n"}
{"name":"QuadraticMap.evalAddMonoidHom_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nm : M\na✝ : QuadraticMap R M N\n⊢ Eq ((QuadraticMap.evalAddMonoidHom m) a✝) (a✝ m)","decl":"/-- Evaluation on a particular element of the module `M` is an additive map on quadratic maps. -/\n@[simps! apply]\ndef evalAddMonoidHom (m : M) : QuadraticMap R M N →+ N :=\n  (Pi.evalAddMonoidHom _ m).comp coeFnAddMonoidHom\n\n"}
{"name":"QuadraticMap.coeFn_sum","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_8\nQ : ι → QuadraticMap R M N\ns : Finset ι\n⊢ Eq (⇑(s.sum fun i => Q i)) (s.sum fun i => ⇑(Q i))","decl":"@[simp]\ntheorem coeFn_sum {ι : Type*} (Q : ι → QuadraticMap R M N) (s : Finset ι) :\n    ⇑(∑ i ∈ s, Q i) = ∑ i ∈ s, ⇑(Q i) :=\n  map_sum coeFnAddMonoidHom Q s\n\n"}
{"name":"QuadraticMap.sum_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_8\nQ : ι → QuadraticMap R M N\ns : Finset ι\nx : M\n⊢ Eq ((s.sum fun i => Q i) x) (s.sum fun i => (Q i) x)","decl":"@[simp]\ntheorem sum_apply {ι : Type*} (Q : ι → QuadraticMap R M N) (s : Finset ι) (x : M) :\n    (∑ i ∈ s, Q i) x = ∑ i ∈ s, Q i x :=\n  map_sum (evalAddMonoidHom x : _ →+ N) Q s\n\n"}
{"name":"QuadraticMap.coeFn_neg","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nQ : QuadraticMap R M N\n⊢ Eq (⇑(Neg.neg Q)) (Neg.neg ⇑Q)","decl":"@[simp]\ntheorem coeFn_neg (Q : QuadraticMap R M N) : ⇑(-Q) = -Q :=\n  rfl\n\n"}
{"name":"QuadraticMap.neg_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nQ : QuadraticMap R M N\nx : M\n⊢ Eq ((Neg.neg Q) x) (Neg.neg (Q x))","decl":"@[simp]\ntheorem neg_apply (Q : QuadraticMap R M N) (x : M) : (-Q) x = -Q x :=\n  rfl\n\n"}
{"name":"QuadraticMap.coeFn_sub","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nQ Q' : QuadraticMap R M N\n⊢ Eq (⇑(HSub.hSub Q Q')) (HSub.hSub ⇑Q ⇑Q')","decl":"@[simp]\ntheorem coeFn_sub (Q Q' : QuadraticMap R M N) : ⇑(Q - Q') = Q - Q' :=\n  rfl\n\n"}
{"name":"QuadraticMap.sub_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nQ Q' : QuadraticMap R M N\nx : M\n⊢ Eq ((HSub.hSub Q Q') x) (HSub.hSub (Q x) (Q' x))","decl":"@[simp]\ntheorem sub_apply (Q Q' : QuadraticMap R M N) (x : M) : (Q - Q') x = Q x - Q' x :=\n  rfl\n\n"}
{"name":"QuadraticMap.restrictScalars_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"S : Type u_1\nR : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring S\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : Module R M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : Module R N\ninst✝⁴ : Module S M\ninst✝³ : Module S N\ninst✝² : Algebra S R\ninst✝¹ : IsScalarTower S R M\ninst✝ : IsScalarTower S R N\nQ : QuadraticMap R M N\nx : M\n⊢ Eq (Q.restrictScalars x) (Q x)","decl":"/-- If `Q : M → N` is a quadratic map of `R`-modules and `R` is an `S`-algebra,\nthen the restriction of scalars is a quadratic map of `S`-modules. -/\n@[simps!]\ndef restrictScalars (Q : QuadraticMap R M N) : QuadraticMap S M N where\n  toFun x := Q x\n  toFun_smul a x := by\n    simp [map_smul_of_tower]\n  exists_companion' :=\n    let ⟨B, h⟩ := Q.exists_companion\n    ⟨B.restrictScalars₁₂ (S := R) (R' := S) (S' := S), fun x y => by\n      simp only [LinearMap.restrictScalars₁₂_apply_apply, h]⟩\n\n"}
{"name":"QuadraticMap.comp_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : AddCommMonoid P\ninst✝ : Module R P\nQ : QuadraticMap R N P\nf : LinearMap (RingHom.id R) M N\nx : M\n⊢ Eq ((Q.comp f) x) (Q (f x))","decl":"@[simp]\ntheorem comp_apply (Q : QuadraticMap R N P) (f : M →ₗ[R] N) (x : M) : (Q.comp f) x = Q (f x) :=\n  rfl\n\n"}
{"name":"LinearMap.compQuadraticMap_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : AddCommMonoid P\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) N P\nQ : QuadraticMap R M N\nx : M\n⊢ Eq ((f.compQuadraticMap Q) x) (f (Q x))","decl":"/-- Compose a quadratic map with a linear function on the left. -/\n@[simps (config := { simpRhs := true })]\ndef _root_.LinearMap.compQuadraticMap (f : N →ₗ[R] P) (Q : QuadraticMap R M N) :\n    QuadraticMap R M P where\n  toFun x := f (Q x)\n  toFun_smul b x := by simp only [map_smul, f.map_smul]\n  exists_companion' :=\n    let ⟨B, h⟩ := Q.exists_companion\n    ⟨B.compr₂ f, fun x y => by simp only [h, map_add, LinearMap.compr₂_apply]⟩\n\n"}
{"name":"LinearMap.compQuadraticMap'_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"S : Type u_1\nR : Type u_3\nM : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝¹² : CommSemiring R\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : Module R M\ninst✝⁹ : AddCommMonoid N\ninst✝⁸ : Module R N\ninst✝⁷ : AddCommMonoid P\ninst✝⁶ : CommSemiring S\ninst✝⁵ : Algebra S R\ninst✝⁴ : Module S N\ninst✝³ : Module S M\ninst✝² : IsScalarTower S R N\ninst✝¹ : IsScalarTower S R M\ninst✝ : Module S P\nf : LinearMap (RingHom.id S) N P\nQ : QuadraticMap R M N\nx : M\n⊢ Eq ((f.compQuadraticMap' Q) x) (f (Q x))","decl":"/-- Compose a quadratic map with a linear function on the left. -/\n@[simps! (config := { simpRhs := true })]\ndef _root_.LinearMap.compQuadraticMap' [CommSemiring S] [Algebra S R] [Module S N] [Module S M]\n    [IsScalarTower S R N] [IsScalarTower S R M] [Module S P]\n    (f : N →ₗ[S] P) (Q : QuadraticMap R M N) : QuadraticMap S M P :=\n  _root_.LinearMap.compQuadraticMap f Q.restrictScalars\n\n"}
{"name":"LinearEquiv.congrQuadraticMap_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : AddCommMonoid P\ninst✝ : Module R P\ne : LinearEquiv (RingHom.id R) N P\nQ : QuadraticMap R M N\n⊢ Eq (e.congrQuadraticMap Q) ((↑e).compQuadraticMap Q)","decl":"/-- When `N` and `P` are equivalent, quadratic maps on `M` into `N` are equivalent to quadratic\nmaps on `M` into `P`.\n\nSee `LinearMap.BilinMap.congr₂` for the bilinear map version. -/\n@[simps]\ndef _root_.LinearEquiv.congrQuadraticMap (e : N ≃ₗ[R] P) :\n    QuadraticMap R M N ≃ₗ[R] QuadraticMap R M P where\n  toFun Q := e.compQuadraticMap Q\n  invFun Q := e.symm.compQuadraticMap Q\n  left_inv _ := ext fun _ => e.symm_apply_apply _\n  right_inv _ := ext fun _ => e.apply_symm_apply _\n  map_add' _ _ := ext fun _ => map_add e _ _\n  map_smul' _ _ := ext fun _ => _root_.map_smul e _ _\n\n"}
{"name":"LinearEquiv.congrQuadraticMap_symm_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : AddCommMonoid P\ninst✝ : Module R P\ne : LinearEquiv (RingHom.id R) N P\nQ : QuadraticMap R M P\n⊢ Eq (e.congrQuadraticMap.symm Q) ((↑e.symm).compQuadraticMap Q)","decl":"/-- When `N` and `P` are equivalent, quadratic maps on `M` into `N` are equivalent to quadratic\nmaps on `M` into `P`.\n\nSee `LinearMap.BilinMap.congr₂` for the bilinear map version. -/\n@[simps]\ndef _root_.LinearEquiv.congrQuadraticMap (e : N ≃ₗ[R] P) :\n    QuadraticMap R M N ≃ₗ[R] QuadraticMap R M P where\n  toFun Q := e.compQuadraticMap Q\n  invFun Q := e.symm.compQuadraticMap Q\n  left_inv _ := ext fun _ => e.symm_apply_apply _\n  right_inv _ := ext fun _ => e.apply_symm_apply _\n  map_add' _ _ := ext fun _ => map_add e _ _\n  map_smul' _ _ := ext fun _ => _root_.map_smul e _ _\n\n"}
{"name":"LinearEquiv.congrQuadraticMap_refl","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\n⊢ Eq (LinearEquiv.refl R N).congrQuadraticMap (LinearEquiv.refl R (QuadraticMap R M N))","decl":"@[simp]\ntheorem _root_.LinearEquiv.congrQuadraticMap_refl :\n    LinearEquiv.congrQuadraticMap (.refl R N) = .refl R (QuadraticMap R M N) := rfl\n\n"}
{"name":"LinearEquiv.congrQuadraticMap_symm","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : AddCommMonoid P\ninst✝ : Module R P\ne : LinearEquiv (RingHom.id R) N P\n⊢ Eq e.congrQuadraticMap.symm e.symm.congrQuadraticMap","decl":"@[simp]\ntheorem _root_.LinearEquiv.congrQuadraticMap_symm (e : N ≃ₗ[R] P) :\n    (LinearEquiv.congrQuadraticMap e (M := M)).symm = e.symm.congrQuadraticMap := rfl\n\n"}
{"name":"QuadraticMap.linMulLin_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nA : Type u_7\ninst✝⁶ : CommSemiring R\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Module R A\ninst✝¹ : SMulCommClass R A A\ninst✝ : IsScalarTower R A A\nf g : LinearMap (RingHom.id R) M A\nx : M\n⊢ Eq ((QuadraticMap.linMulLin f g) x) (HMul.hMul (f x) (g x))","decl":"@[simp]\ntheorem linMulLin_apply (f g : M →ₗ[R] A) (x) : linMulLin f g x = f x * g x :=\n  rfl\n\n"}
{"name":"QuadraticMap.add_linMulLin","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nA : Type u_7\ninst✝⁶ : CommSemiring R\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Module R A\ninst✝¹ : SMulCommClass R A A\ninst✝ : IsScalarTower R A A\nf g h : LinearMap (RingHom.id R) M A\n⊢ Eq (QuadraticMap.linMulLin (HAdd.hAdd f g) h) (HAdd.hAdd (QuadraticMap.linMulLin f h) (QuadraticMap.linMulLin g h))","decl":"@[simp]\ntheorem add_linMulLin (f g h : M →ₗ[R] A) : linMulLin (f + g) h = linMulLin f h + linMulLin g h :=\n  ext fun _ => add_mul _ _ _\n\n"}
{"name":"QuadraticMap.linMulLin_add","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nA : Type u_7\ninst✝⁶ : CommSemiring R\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Module R A\ninst✝¹ : SMulCommClass R A A\ninst✝ : IsScalarTower R A A\nf g h : LinearMap (RingHom.id R) M A\n⊢ Eq (QuadraticMap.linMulLin f (HAdd.hAdd g h)) (HAdd.hAdd (QuadraticMap.linMulLin f g) (QuadraticMap.linMulLin f h))","decl":"@[simp]\ntheorem linMulLin_add (f g h : M →ₗ[R] A) : linMulLin f (g + h) = linMulLin f g + linMulLin f h :=\n  ext fun _ => mul_add _ _ _\n\n"}
{"name":"QuadraticMap.linMulLin_comp","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nA : Type u_7\ninst✝⁸ : CommSemiring R\ninst✝⁷ : NonUnitalNonAssocSemiring A\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : Module R A\ninst✝³ : SMulCommClass R A A\ninst✝² : IsScalarTower R A A\nN' : Type u_8\ninst✝¹ : AddCommMonoid N'\ninst✝ : Module R N'\nf g : LinearMap (RingHom.id R) M A\nh : LinearMap (RingHom.id R) N' M\n⊢ Eq ((QuadraticMap.linMulLin f g).comp h) (QuadraticMap.linMulLin (f.comp h) (g.comp h))","decl":"@[simp]\ntheorem linMulLin_comp (f g : M →ₗ[R] A) (h : N' →ₗ[R] M) :\n    (linMulLin f g).comp h = linMulLin (f.comp h) (g.comp h) :=\n  rfl\n\n"}
{"name":"QuadraticMap.sq_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nA : Type u_7\ninst✝⁴ : CommSemiring R\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : Module R A\ninst✝¹ : SMulCommClass R A A\ninst✝ : IsScalarTower R A A\na : A\n⊢ Eq (QuadraticMap.sq a) (HMul.hMul a a)","decl":"/-- `sq` is the quadratic map sending the vector `x : A` to `x * x` -/\n@[simps!]\ndef sq : QuadraticMap R A A :=\n  linMulLin LinearMap.id LinearMap.id\n\n"}
{"name":"QuadraticMap.proj_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nA : Type u_7\ninst✝⁴ : CommSemiring R\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : Module R A\ninst✝¹ : SMulCommClass R A A\ninst✝ : IsScalarTower R A A\nn : Type u_9\ni j : n\nx : n → A\n⊢ Eq ((QuadraticMap.proj i j) x) (HMul.hMul (x i) (x j))","decl":"@[simp]\ntheorem proj_apply (i j : n) (x : n → A) : proj (R := R) i j x = x i * x j :=\n  rfl\n\n"}
{"name":"LinearMap.BilinMap.toQuadraticMap_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nB : LinearMap.BilinMap R M N\nx : M\n⊢ Eq (B.toQuadraticMap x) ((B x) x)","decl":"@[simp]\ntheorem toQuadraticMap_apply (B : BilinMap R M N) (x : M) : B.toQuadraticMap x = B x x :=\n  rfl\n\n"}
{"name":"LinearMap.BilinMap.toQuadraticMap_comp_same","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\nN' : Type u_8\ninst✝¹ : AddCommMonoid N'\ninst✝ : Module R N'\nB : LinearMap.BilinMap R M N\nf : LinearMap (RingHom.id R) N' M\n⊢ Eq (LinearMap.BilinMap.toQuadraticMap (LinearMap.compl₁₂ B f f)) (B.toQuadraticMap.comp f)","decl":"theorem toQuadraticMap_comp_same (B : BilinMap R M N) (f : N' →ₗ[R] M) :\n    BilinMap.toQuadraticMap (B.compl₁₂ f f) = B.toQuadraticMap.comp f := rfl\n\n"}
{"name":"LinearMap.BilinMap.toQuadraticMap_zero","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\n⊢ Eq (LinearMap.BilinMap.toQuadraticMap 0) 0","decl":"@[simp]\ntheorem toQuadraticMap_zero : (0 : BilinMap R M N).toQuadraticMap = 0 :=\n  rfl\n\n"}
{"name":"LinearMap.BilinMap.toQuadraticMap_add","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nB₁ B₂ : LinearMap.BilinMap R M N\n⊢ Eq (HAdd.hAdd B₁ B₂).toQuadraticMap (HAdd.hAdd B₁.toQuadraticMap B₂.toQuadraticMap)","decl":"@[simp]\ntheorem toQuadraticMap_add (B₁ B₂ : BilinMap R M N) :\n    (B₁ + B₂).toQuadraticMap = B₁.toQuadraticMap + B₂.toQuadraticMap :=\n  rfl\n\n"}
{"name":"LinearMap.BilinMap.toQuadraticMap_smul","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"S : Type u_1\nR : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁸ : CommSemiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R N\ninst✝³ : Monoid S\ninst✝² : DistribMulAction S N\ninst✝¹ : SMulCommClass S R N\ninst✝ : SMulCommClass R S N\na : S\nB : LinearMap.BilinMap R M N\n⊢ Eq (HSMul.hSMul a B).toQuadraticMap (HSMul.hSMul a B.toQuadraticMap)","decl":"@[simp]\ntheorem toQuadraticMap_smul [Monoid S] [DistribMulAction S N] [SMulCommClass S R N]\n    [SMulCommClass R S N] (a : S)\n    (B : BilinMap R M N) : (a • B).toQuadraticMap = a • B.toQuadraticMap :=\n  rfl\n\n"}
{"name":"LinearMap.BilinMap.toQuadraticMapAddMonoidHom_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nB : LinearMap.BilinMap R M N\n⊢ Eq ((LinearMap.BilinMap.toQuadraticMapAddMonoidHom R M) B) B.toQuadraticMap","decl":"/-- `LinearMap.BilinMap.toQuadraticMap` as an additive homomorphism -/\n@[simps]\ndef toQuadraticMapAddMonoidHom : (BilinMap R M N) →+ QuadraticMap R M N where\n  toFun := toQuadraticMap\n  map_zero' := toQuadraticMap_zero _ _\n  map_add' := toQuadraticMap_add\n\n"}
{"name":"LinearMap.BilinMap.toQuadraticMapLinearMap_apply_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"S : Type u_1\nR : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁸ : CommSemiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R N\ninst✝³ : Semiring S\ninst✝² : Module S N\ninst✝¹ : SMulCommClass S R N\ninst✝ : SMulCommClass R S N\nB : LinearMap.BilinMap R M N\nx : M\n⊢ Eq (((LinearMap.BilinMap.toQuadraticMapLinearMap S R M) B) x) ((B x) x)","decl":"/-- `LinearMap.BilinMap.toQuadraticMap` as a linear map -/\n@[simps!]\ndef toQuadraticMapLinearMap [Semiring S] [Module S N] [SMulCommClass S R N] [SMulCommClass R S N] :\n    (BilinMap R M N) →ₗ[S] QuadraticMap R M N where\n  toFun := toQuadraticMap\n  map_smul' := toQuadraticMap_smul\n  map_add' := toQuadraticMap_add\n\n"}
{"name":"LinearMap.BilinMap.toQuadraticMap_list_sum","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nB : List (LinearMap.BilinMap R M N)\n⊢ Eq B.sum.toQuadraticMap (List.map LinearMap.BilinMap.toQuadraticMap B).sum","decl":"@[simp]\ntheorem toQuadraticMap_list_sum (B : List (BilinMap R M N)) :\n    B.sum.toQuadraticMap = (B.map toQuadraticMap).sum :=\n  map_list_sum (toQuadraticMapAddMonoidHom R M) B\n\n"}
{"name":"LinearMap.BilinMap.toQuadraticMap_multiset_sum","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nB : Multiset (LinearMap.BilinMap R M N)\n⊢ Eq B.sum.toQuadraticMap (Multiset.map LinearMap.BilinMap.toQuadraticMap B).sum","decl":"@[simp]\ntheorem toQuadraticMap_multiset_sum (B : Multiset (BilinMap R M N)) :\n    B.sum.toQuadraticMap = (B.map toQuadraticMap).sum :=\n  map_multiset_sum (toQuadraticMapAddMonoidHom R M) B\n\n"}
{"name":"LinearMap.BilinMap.toQuadraticMap_sum","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_9\ns : Finset ι\nB : ι → LinearMap.BilinMap R M N\n⊢ Eq (s.sum fun i => B i).toQuadraticMap (s.sum fun i => (B i).toQuadraticMap)","decl":"@[simp]\ntheorem toQuadraticMap_sum {ι : Type*} (s : Finset ι) (B : ι → (BilinMap R M N)) :\n    (∑ i ∈ s, B i).toQuadraticMap = ∑ i ∈ s, (B i).toQuadraticMap :=\n  map_sum (toQuadraticMapAddMonoidHom R M) B s\n\n"}
{"name":"LinearMap.BilinMap.toQuadraticMap_eq_zero","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nB : LinearMap.BilinMap R M N\n⊢ Iff (Eq B.toQuadraticMap 0) (LinearMap.IsAlt B)","decl":"@[simp]\ntheorem toQuadraticMap_eq_zero {B : BilinMap R M N} :\n    B.toQuadraticMap = 0 ↔ B.IsAlt :=\n  QuadraticMap.ext_iff\n\n"}
{"name":"LinearMap.BilinMap.toQuadraticMap_neg","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nB : LinearMap.BilinMap R M N\n⊢ Eq (Neg.neg B).toQuadraticMap (Neg.neg B.toQuadraticMap)","decl":"@[simp]\ntheorem toQuadraticMap_neg (B : BilinMap R M N) : (-B).toQuadraticMap = -B.toQuadraticMap :=\n  rfl\n\n"}
{"name":"LinearMap.BilinMap.toQuadraticMap_sub","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nB₁ B₂ : LinearMap.BilinMap R M N\n⊢ Eq (HSub.hSub B₁ B₂).toQuadraticMap (HSub.hSub B₁.toQuadraticMap B₂.toQuadraticMap)","decl":"@[simp]\ntheorem toQuadraticMap_sub (B₁ B₂ : BilinMap R M N) :\n    (B₁ - B₂).toQuadraticMap = B₁.toQuadraticMap - B₂.toQuadraticMap :=\n  rfl\n\n"}
{"name":"LinearMap.BilinMap.polar_toQuadraticMap","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nB : LinearMap.BilinMap R M N\nx y : M\n⊢ Eq (QuadraticMap.polar (⇑B.toQuadraticMap) x y) (HAdd.hAdd ((B x) y) ((B y) x))","decl":"theorem polar_toQuadraticMap (x y : M) : polar (toQuadraticMap B) x y = B x y + B y x := by\n  simp only [polar, toQuadraticMap_apply, map_add, add_apply, add_assoc, add_comm (B y x) _,\n    add_sub_cancel_left, sub_eq_add_neg _ (B y y), add_neg_cancel_left]\n\n"}
{"name":"LinearMap.BilinMap.polarBilin_toQuadraticMap","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nB : LinearMap.BilinMap R M N\n⊢ Eq B.toQuadraticMap.polarBilin (HAdd.hAdd B (LinearMap.flip B))","decl":"theorem polarBilin_toQuadraticMap : polarBilin (toQuadraticMap B) = B + flip B :=\n  LinearMap.ext₂ polar_toQuadraticMap\n\n"}
{"name":"QuadraticMap.toQuadraticMap_polarBilin","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticMap R M N\n⊢ Eq Q.polarBilin.toQuadraticMap (HSMul.hSMul 2 Q)","decl":"@[simp] theorem _root_.QuadraticMap.toQuadraticMap_polarBilin (Q : QuadraticMap R M N) :\n    toQuadraticMap (polarBilin Q) = 2 • Q :=\n  QuadraticMap.ext fun x => (polar_self _ x).trans <| by simp\n\n"}
{"name":"QuadraticMap.polarBilin_injective","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nh : IsUnit 2\n⊢ Function.Injective QuadraticMap.polarBilin","decl":"theorem _root_.QuadraticMap.polarBilin_injective (h : IsUnit (2 : R)) :\n    Function.Injective (polarBilin : QuadraticMap R M N → _) := by\n  intro Q₁ Q₂ h₁₂\n  apply h.smul_left_cancel.mp\n  rw [show (2 : R) = (2 : ℕ) by rfl]\n  simp_rw [Nat.cast_smul_eq_nsmul R, ← QuadraticMap.toQuadraticMap_polarBilin]\n  exact congrArg toQuadraticMap h₁₂\n\n"}
{"name":"QuadraticMap.polarBilin_comp","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\nN' : Type u_8\ninst✝¹ : AddCommGroup N'\ninst✝ : Module R N'\nQ : QuadraticMap R N' N\nf : LinearMap (RingHom.id R) M N'\n⊢ Eq (Q.comp f).polarBilin (LinearMap.compl₁₂ Q.polarBilin f f)","decl":"theorem _root_.QuadraticMap.polarBilin_comp (Q : QuadraticMap R N' N) (f : M →ₗ[R] N') :\n    polarBilin (Q.comp f) = LinearMap.compl₁₂ (polarBilin Q) f f :=\n  LinearMap.ext₂ <| fun x y => by simp [polar]\n\n"}
{"name":"LinearMap.compQuadraticMap_polar","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"S : Type u_1\nR : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝¹² : CommRing R\ninst✝¹¹ : AddCommGroup M\ninst✝¹⁰ : AddCommGroup N\ninst✝⁹ : Module R M\ninst✝⁸ : Module R N\nN' : Type u_8\ninst✝⁷ : AddCommGroup N'\ninst✝⁶ : CommSemiring S\ninst✝⁵ : Algebra S R\ninst✝⁴ : Module S N\ninst✝³ : Module S N'\ninst✝² : IsScalarTower S R N\ninst✝¹ : Module S M\ninst✝ : IsScalarTower S R M\nf : LinearMap (RingHom.id S) N N'\nQ : QuadraticMap R M N\nx y : M\n⊢ Eq (QuadraticMap.polar (⇑(f.compQuadraticMap' Q)) x y) (f (QuadraticMap.polar (⇑Q) x y))","decl":"theorem _root_.LinearMap.compQuadraticMap_polar [CommSemiring S] [Algebra S R] [Module S N]\n    [Module S N'] [IsScalarTower S R N] [Module S M] [IsScalarTower S R M] (f : N →ₗ[S] N')\n    (Q : QuadraticMap R M N) (x y : M) : polar (f.compQuadraticMap' Q) x y = f (polar Q x y) := by\n  simp [polar]\n\n"}
{"name":"LinearMap.compQuadraticMap_polarBilin","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\nN' : Type u_8\ninst✝¹ : AddCommGroup N'\ninst✝ : Module R N'\nf : LinearMap (RingHom.id R) N N'\nQ : QuadraticMap R M N\n⊢ Eq (f.compQuadraticMap' Q).polarBilin (LinearMap.compr₂ Q.polarBilin f)","decl":"theorem _root_.LinearMap.compQuadraticMap_polarBilin (f : N →ₗ[R] N') (Q : QuadraticMap R M N) :\n    (f.compQuadraticMap' Q).polarBilin = Q.polarBilin.compr₂ f := by\n  ext\n  rw [polarBilin_apply_apply, compr₂_apply, polarBilin_apply_apply,\n    LinearMap.compQuadraticMap_polar]\n\n"}
{"name":"QuadraticMap.instSMulCommClassSubtypeMemSubmonoidCenter","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ SMulCommClass R (Subtype fun x => Membership.mem (Submonoid.center R) x) M","decl":"instance : SMulCommClass R (Submonoid.center R) M where\n  smul_comm r r' m := by\n    simp_rw [Submonoid.smul_def, smul_smul, (Set.mem_center_iff.1 r'.prop).1]\n\n"}
{"name":"QuadraticMap.half_moduleEnd_apply_eq_half_smul","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Invertible 2\nx : M\n⊢ Eq ((Invertible.invOf 2) x) (HSMul.hSMul (Invertible.invOf 2) x)","decl":"/-- If `2` is invertible in `R`, then applying the inverse of `2` in `End R M` to an element\nof `M` is the same as multiplying by the inverse of `2` in `R`. -/\n@[simp]\nlemma half_moduleEnd_apply_eq_half_smul [Invertible (2 : R)] (x : M) :\n    ⅟ (2 : Module.End R M) x = ⅟ (2 : R) • x :=\n  rfl\n\n"}
{"name":"QuadraticMap.associated_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"S : Type u_1\nR : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁹ : CommRing R\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : AddCommGroup N\ninst✝⁵ : Module R N\ninst✝⁴ : CommSemiring S\ninst✝³ : Algebra S R\ninst✝² : Module S N\ninst✝¹ : IsScalarTower S R N\ninst✝ : Invertible 2\nQ : QuadraticMap R M N\nx y : M\n⊢ Eq ((((QuadraticMap.associatedHom S) Q) x) y) (HSMul.hSMul (Invertible.invOf 2) (HSub.hSub (HSub.hSub (Q (HAdd.hAdd x y)) (Q x)) (Q y)))","decl":"@[simp]\ntheorem associated_apply (x y : M) :\n    associatedHom S Q x y = ⅟ (2 : Module.End R N) • (Q (x + y) - Q x - Q y) :=\n  rfl\n\n"}
{"name":"QuadraticMap.two_nsmul_associated","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"S : Type u_1\nR : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁹ : CommRing R\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : AddCommGroup N\ninst✝⁵ : Module R N\ninst✝⁴ : CommSemiring S\ninst✝³ : Algebra S R\ninst✝² : Module S N\ninst✝¹ : IsScalarTower S R N\ninst✝ : Invertible 2\nQ : QuadraticMap R M N\n⊢ Eq (HSMul.hSMul 2 ((QuadraticMap.associatedHom S) Q)) Q.polarBilin","decl":"/-- Twice the associated bilinear map of `Q` is the same as the polar of `Q`. -/\n@[simp] theorem two_nsmul_associated : 2 • associatedHom S Q = Q.polarBilin := by\n  ext\n  dsimp\n  rw [← LinearMap.smul_apply, nsmul_eq_mul, Nat.cast_ofNat, mul_invOf_self', LinearMap.one_apply,\n    polar]\n\n"}
{"name":"QuadraticMap.associated_isSymm","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"S : Type u_1\nR : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁹ : CommRing R\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : AddCommGroup N\ninst✝⁵ : Module R N\ninst✝⁴ : CommSemiring S\ninst✝³ : Algebra S R\ninst✝² : Module S N\ninst✝¹ : IsScalarTower S R N\ninst✝ : Invertible 2\nQ : QuadraticMap R M N\nx y : M\n⊢ Eq ((((QuadraticMap.associatedHom S) Q) x) y) ((((QuadraticMap.associatedHom S) Q) y) x)","decl":"theorem associated_isSymm (Q : QuadraticMap R M N) (x y : M) :\n    associatedHom S Q x y = associatedHom S Q y x := by\n  simp only [associated_apply, sub_eq_add_neg, add_assoc, add_comm, add_left_comm]\n\n"}
{"name":"QuadraticForm.associated_isSymm","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"S : Type u_1\nR : Type u_3\nM : Type u_4\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : CommSemiring S\ninst✝¹ : Algebra S R\nQ : QuadraticForm R M\ninst✝ : Invertible 2\n⊢ LinearMap.IsSymm ((QuadraticMap.associatedHom S) Q)","decl":"theorem _root_.QuadraticForm.associated_isSymm (Q : QuadraticForm R M) [Invertible (2 : R)] :\n    (associatedHom S Q).IsSymm :=\n  QuadraticMap.associated_isSymm S Q\n\n"}
{"name":"QuadraticMap.associated_flip","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"S : Type u_1\nR : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁹ : CommRing R\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : AddCommGroup N\ninst✝⁵ : Module R N\ninst✝⁴ : CommSemiring S\ninst✝³ : Algebra S R\ninst✝² : Module S N\ninst✝¹ : IsScalarTower S R N\ninst✝ : Invertible 2\nQ : QuadraticMap R M N\n⊢ Eq (LinearMap.flip ((QuadraticMap.associatedHom S) Q)) ((QuadraticMap.associatedHom S) Q)","decl":"/-- A version of `QuadraticMap.associated_isSymm` for general targets\n(using `flip` because `IsSymm` does not apply here). -/\nlemma associated_flip : (associatedHom S Q).flip = associatedHom S Q := by\n  ext\n  simp only [LinearMap.flip_apply, associated_apply, add_comm, sub_eq_add_neg, add_left_comm,\n    add_assoc]\n\n"}
{"name":"QuadraticMap.associated_comp","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"S : Type u_1\nR : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : AddCommGroup M\ninst✝⁹ : Module R M\ninst✝⁸ : AddCommGroup N\ninst✝⁷ : Module R N\ninst✝⁶ : CommSemiring S\ninst✝⁵ : Algebra S R\ninst✝⁴ : Module S N\ninst✝³ : IsScalarTower S R N\ninst✝² : Invertible 2\nQ : QuadraticMap R M N\nN' : Type u_8\ninst✝¹ : AddCommGroup N'\ninst✝ : Module R N'\nf : LinearMap (RingHom.id R) N' M\n⊢ Eq ((QuadraticMap.associatedHom S) (Q.comp f)) (LinearMap.compl₁₂ ((QuadraticMap.associatedHom S) Q) f f)","decl":"@[simp]\ntheorem associated_comp {N' : Type*} [AddCommGroup N'] [Module R N'] (f : N' →ₗ[R] M) :\n    associatedHom S (Q.comp f) = (associatedHom S Q).compl₁₂ f f := by\n  ext\n  simp only [associated_apply, comp_apply, map_add, LinearMap.compl₁₂_apply]\n\n"}
{"name":"QuadraticMap.associated_toQuadraticMap","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"S : Type u_1\nR : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁹ : CommRing R\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : AddCommGroup N\ninst✝⁵ : Module R N\ninst✝⁴ : CommSemiring S\ninst✝³ : Algebra S R\ninst✝² : Module S N\ninst✝¹ : IsScalarTower S R N\ninst✝ : Invertible 2\nB : LinearMap.BilinMap R M N\nx y : M\n⊢ Eq ((((QuadraticMap.associatedHom S) B.toQuadraticMap) x) y) (HSMul.hSMul (Invertible.invOf 2) (HAdd.hAdd ((B x) y) ((B y) x)))","decl":"theorem associated_toQuadraticMap (B : BilinMap R M N) (x y : M) :\n    associatedHom S B.toQuadraticMap x y = ⅟ (2 : Module.End R N) • (B x y + B y x) := by\n  simp only [associated_apply, BilinMap.toQuadraticMap_apply, map_add, LinearMap.add_apply,\n    LinearMap.smul_def, _root_.map_sub]\n  abel_nf\n\n"}
{"name":"QuadraticMap.associated_left_inverse","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"S : Type u_1\nR : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁹ : CommRing R\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : AddCommGroup N\ninst✝⁵ : Module R N\ninst✝⁴ : CommSemiring S\ninst✝³ : Algebra S R\ninst✝² : Module S N\ninst✝¹ : IsScalarTower S R N\ninst✝ : Invertible 2\nB₁ : LinearMap.BilinMap R M N\nh : ∀ (x y : M), Eq ((B₁ x) y) ((B₁ y) x)\n⊢ Eq ((QuadraticMap.associatedHom S) B₁.toQuadraticMap) B₁","decl":"theorem associated_left_inverse {B₁ : BilinMap R M N} (h : ∀ x y, B₁ x y = B₁ y x) :\n    associatedHom S B₁.toQuadraticMap = B₁ :=\n  LinearMap.ext₂ fun x y ↦ by\n    rw [associated_toQuadraticMap, ← h x y, ← two_smul R, invOf_smul_eq_iff, two_smul, two_smul]\n\n"}
{"name":"QuadraticMap.associated_left_inverse'","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"S : Type u_1\nR : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁹ : CommRing R\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : AddCommGroup N\ninst✝⁵ : Module R N\ninst✝⁴ : CommSemiring S\ninst✝³ : Algebra S R\ninst✝² : Module S N\ninst✝¹ : IsScalarTower S R N\ninst✝ : Invertible 2\nB₁ : LinearMap.BilinMap R M N\nhB₁ : Eq (LinearMap.flip B₁) B₁\n⊢ Eq ((QuadraticMap.associatedHom S) B₁.toQuadraticMap) B₁","decl":"/-- A version of `QuadraticMap.associated_left_inverse` for general targets. -/\nlemma associated_left_inverse' {B₁ : BilinMap R M N} (hB₁ : B₁.flip = B₁) :\n    associatedHom S B₁.toQuadraticMap = B₁ := by\n  ext _ y\n  rw [associated_toQuadraticMap, ← LinearMap.flip_apply _ y, hB₁, invOf_smul_eq_iff, two_smul]\n\n-- Porting note: moved from below to golf the next theorem\n"}
{"name":"QuadraticMap.associated_eq_self_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"S : Type u_1\nR : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁹ : CommRing R\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : AddCommGroup N\ninst✝⁵ : Module R N\ninst✝⁴ : CommSemiring S\ninst✝³ : Algebra S R\ninst✝² : Module S N\ninst✝¹ : IsScalarTower S R N\ninst✝ : Invertible 2\nQ : QuadraticMap R M N\nx : M\n⊢ Eq ((((QuadraticMap.associatedHom S) Q) x) x) (Q x)","decl":"theorem associated_eq_self_apply (x : M) : associatedHom S Q x x = Q x := by\n  rw [associated_apply, map_add_self, ← three_add_one_eq_four, ← two_add_one_eq_three, add_smul,\n    add_smul, one_smul, add_sub_cancel_right, add_sub_cancel_right, two_smul, ← two_smul R,\n    invOf_smul_eq_iff, two_smul, two_smul]\n\n"}
{"name":"QuadraticMap.toQuadraticMap_associated","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"S : Type u_1\nR : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁹ : CommRing R\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : AddCommGroup N\ninst✝⁵ : Module R N\ninst✝⁴ : CommSemiring S\ninst✝³ : Algebra S R\ninst✝² : Module S N\ninst✝¹ : IsScalarTower S R N\ninst✝ : Invertible 2\nQ : QuadraticMap R M N\n⊢ Eq ((QuadraticMap.associatedHom S) Q).toQuadraticMap Q","decl":"theorem toQuadraticMap_associated : (associatedHom S Q).toQuadraticMap = Q :=\n  QuadraticMap.ext <| associated_eq_self_apply S Q\n\n-- note: usually `rightInverse` lemmas are named the other way around, but this is consistent\n-- with historical naming in this file.\n"}
{"name":"QuadraticMap.associated_rightInverse","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"S : Type u_1\nR : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁹ : CommRing R\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : AddCommGroup N\ninst✝⁵ : Module R N\ninst✝⁴ : CommSemiring S\ninst✝³ : Algebra S R\ninst✝² : Module S N\ninst✝¹ : IsScalarTower S R N\ninst✝ : Invertible 2\n⊢ Function.RightInverse (⇑(QuadraticMap.associatedHom S)) LinearMap.BilinMap.toQuadraticMap","decl":"theorem associated_rightInverse :\n    Function.RightInverse (associatedHom S) (BilinMap.toQuadraticMap : _ → QuadraticMap R M N) :=\n  toQuadraticMap_associated S\n\n"}
{"name":"QuadraticMap.canLift","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Invertible 2\n⊢ CanLift (LinearMap.BilinMap R M R) (QuadraticForm R M) (⇑(QuadraticMap.associatedHom Nat)) LinearMap.IsSymm","decl":"/-- Symmetric bilinear forms can be lifted to quadratic forms -/\ninstance canLift [Invertible (2 : R)] :\n    CanLift (BilinMap R M R) (QuadraticForm R M) (associatedHom ℕ) LinearMap.IsSymm where\n  prf B hB := ⟨B.toQuadraticMap, associated_left_inverse _ hB⟩\n\n"}
{"name":"QuadraticMap.canLift'","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : Invertible 2\n⊢ CanLift (LinearMap.BilinMap R M N) (QuadraticMap R M N) ⇑(QuadraticMap.associatedHom Nat) fun B => Eq (LinearMap.flip B) B","decl":"/-- Symmetric bilinear maps can be lifted to quadratic maps -/\ninstance canLift' :\n    CanLift (BilinMap R M N) (QuadraticMap R M N) (associatedHom ℕ) fun B ↦ B.flip = B where\n  prf B hB := ⟨B.toQuadraticMap, associated_left_inverse' _ hB⟩\n\n"}
{"name":"QuadraticMap.exists_quadraticMap_ne_zero","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : Invertible 2\nQ : QuadraticMap R M N\nhB₁ : Ne (QuadraticMap.associated' Q) 0\n⊢ Exists fun x => Ne (Q x) 0","decl":"/-- There exists a non-null vector with respect to any quadratic form `Q` whose associated\nbilinear form is non-zero, i.e. there exists `x` such that `Q x ≠ 0`. -/\ntheorem exists_quadraticMap_ne_zero {Q : QuadraticMap R M N}\n    -- Porting note: added implicit argument\n    (hB₁ : associated' (R := R) (N := N) Q ≠ 0) :\n    ∃ x, Q x ≠ 0 := by\n  rw [← not_forall]\n  intro h\n  apply hB₁\n  rw [(QuadraticMap.ext h : Q = 0), LinearMap.map_zero]\n\n"}
{"name":"QuadraticMap.exists_quadraticForm_ne_zero","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : Invertible 2\nQ : QuadraticMap R M N\nhB₁ : Ne (QuadraticMap.associated' Q) 0\n⊢ Exists fun x => Ne (Q x) 0","decl":"@[deprecated (since := \"2024-10-05\")] alias exists_quadraticForm_ne_zero :=\n  exists_quadraticMap_ne_zero\n\n"}
{"name":"QuadraticMap.coe_associatedHom","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"S : Type u_1\nR : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁹ : CommSemiring S\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Algebra S R\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R N\ninst✝² : Module S N\ninst✝¹ : IsScalarTower S R N\ninst✝ : Invertible 2\n⊢ Eq ⇑(QuadraticMap.associatedHom S) ⇑QuadraticMap.associated","decl":"variable (S) in\ntheorem coe_associatedHom :\n    ⇑(associatedHom S : QuadraticMap R M N →ₗ[S] BilinMap R M N) = associated :=\n  rfl\n\n"}
{"name":"QuadraticMap.associated_linMulLin","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Invertible 2\nf g : LinearMap (RingHom.id R) M R\n⊢ Eq (QuadraticMap.associated (QuadraticMap.linMulLin f g)) (HSMul.hSMul (Invertible.invOf 2) (HAdd.hAdd ((LinearMap.mul R R).compl₁₂ f g) ((LinearMap.mul R R).compl₁₂ g f)))","decl":"open LinearMap in\n@[simp]\ntheorem associated_linMulLin [Invertible (2 : R)] (f g : M →ₗ[R] R) :\n    associated (R := R) (N := R) (linMulLin f g) =\n      ⅟ (2 : R) • ((mul R R).compl₁₂ f g + (mul R R).compl₁₂ g f) := by\n  ext\n  simp only [associated_apply, linMulLin_apply, map_add, smul_add, LinearMap.add_apply,\n    LinearMap.smul_apply, compl₁₂_apply, mul_apply', smul_eq_mul, invOf_smul_eq_iff]\n  simp only [smul_add, LinearMap.smul_def, Module.End.ofNat_apply, nsmul_eq_mul, Nat.cast_ofNat,\n    mul_invOf_cancel_left']\n  ring_nf\n\n"}
{"name":"QuadraticMap.associated_sq","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\ninst✝¹ : CommRing R\ninst✝ : Invertible 2\n⊢ Eq (QuadraticMap.associated QuadraticMap.sq) (LinearMap.mul R R)","decl":"open LinearMap in\n@[simp]\nlemma associated_sq [Invertible (2 : R)] : associated (R := R) sq = mul R R :=\n  (associated_linMulLin (id) (id)).trans <|\n    by simp only [smul_add, invOf_two_smul_add_invOf_two_smul]; rfl\n\n"}
{"name":"QuadraticMap.isOrtho_def","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nQ : QuadraticMap R M N\nx y : M\n⊢ Iff (Q.IsOrtho x y) (Eq (Q (HAdd.hAdd x y)) (HAdd.hAdd (Q x) (Q y)))","decl":"theorem isOrtho_def {Q : QuadraticMap R M N} {x y : M} : Q.IsOrtho x y ↔ Q (x + y) = Q x + Q y :=\n  Iff.rfl\n\n"}
{"name":"QuadraticMap.IsOrtho.all","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nx y : M\n⊢ QuadraticMap.IsOrtho 0 x y","decl":"theorem IsOrtho.all (x y : M) : IsOrtho (0 : QuadraticMap R M N) x y := (zero_add _).symm\n\n"}
{"name":"QuadraticMap.IsOrtho.zero_left","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nQ : QuadraticMap R M N\nx : M\n⊢ Q.IsOrtho 0 x","decl":"theorem IsOrtho.zero_left (x : M) : IsOrtho Q (0 : M) x := by simp [isOrtho_def]\n\n"}
{"name":"QuadraticMap.IsOrtho.zero_right","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nQ : QuadraticMap R M N\nx : M\n⊢ Q.IsOrtho x 0","decl":"theorem IsOrtho.zero_right (x : M) : IsOrtho Q x (0 : M) := by simp [isOrtho_def]\n\n"}
{"name":"QuadraticMap.ne_zero_of_not_isOrtho_self","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nQ : QuadraticMap R M N\nx : M\nhx₁ : Not (Q.IsOrtho x x)\n⊢ Ne x 0","decl":"theorem ne_zero_of_not_isOrtho_self {Q : QuadraticMap R M N} (x : M) (hx₁ : ¬Q.IsOrtho x x) :\n    x ≠ 0 :=\n  fun hx₂ => hx₁ (hx₂.symm ▸ .zero_left _)\n\n"}
{"name":"QuadraticMap.isOrtho_comm","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nQ : QuadraticMap R M N\nx y : M\n⊢ Iff (Q.IsOrtho x y) (Q.IsOrtho y x)","decl":"theorem isOrtho_comm {x y : M} : IsOrtho Q x y ↔ IsOrtho Q y x := by simp_rw [isOrtho_def, add_comm]\n\n"}
{"name":"QuadraticMap.IsOrtho.symm","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nQ : QuadraticMap R M N\nx y : M\na✝ : Q.IsOrtho x y\n⊢ Q.IsOrtho y x","decl":"alias ⟨IsOrtho.symm, _⟩ := isOrtho_comm\n\n"}
{"name":"LinearMap.BilinForm.toQuadraticMap_isOrtho","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : IsCancelAdd R\ninst✝¹ : NoZeroDivisors R\ninst✝ : CharZero R\nB : LinearMap.BilinMap R M R\nx y : M\nh : LinearMap.IsSymm B\n⊢ Iff (B.toQuadraticMap.IsOrtho x y) (LinearMap.IsOrtho B x y)","decl":"theorem _root_.LinearMap.BilinForm.toQuadraticMap_isOrtho [IsCancelAdd R]\n    [NoZeroDivisors R] [CharZero R] {B : BilinMap R M R} {x y : M} (h : B.IsSymm) :\n    B.toQuadraticMap.IsOrtho x y ↔ B.IsOrtho x y := by\n  letI : AddCancelMonoid R := { ‹IsCancelAdd R›, (inferInstanceAs <| AddCommMonoid R) with }\n  simp_rw [isOrtho_def, LinearMap.isOrtho_def, B.toQuadraticMap_apply, map_add,\n    LinearMap.add_apply, add_comm _ (B y y), add_add_add_comm _ _ (B y y), add_comm (B y y)]\n  rw [add_right_eq_self (a := B x x + B y y), ← h, RingHom.id_apply, add_self_eq_zero]\n\n"}
{"name":"QuadraticMap.isOrtho_polarBilin","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nQ : QuadraticMap R M N\nx y : M\n⊢ Iff (LinearMap.IsOrtho Q.polarBilin x y) (Q.IsOrtho x y)","decl":"@[simp]\ntheorem isOrtho_polarBilin {x y : M} : Q.polarBilin.IsOrtho x y ↔ IsOrtho Q x y := by\n  simp_rw [isOrtho_def, LinearMap.isOrtho_def, polarBilin_apply_apply, polar, sub_sub, sub_eq_zero]\n\n"}
{"name":"QuadraticMap.IsOrtho.polar_eq_zero","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nQ : QuadraticMap R M N\nx y : M\nh : Q.IsOrtho x y\n⊢ Eq (QuadraticMap.polar (⇑Q) x y) 0","decl":"theorem IsOrtho.polar_eq_zero {x y : M} (h : IsOrtho Q x y) : polar Q x y = 0 :=\n  isOrtho_polarBilin.mpr h\n\n"}
{"name":"QuadraticMap.associated_isOrtho","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\nQ : QuadraticMap R M N\ninst✝ : Invertible 2\nx y : M\n⊢ Iff (LinearMap.IsOrtho (QuadraticMap.associated Q) x y) (Q.IsOrtho x y)","decl":"@[simp]\ntheorem associated_isOrtho [Invertible (2 : R)] {x y : M} :\n    Q.associated.IsOrtho x y ↔ Q.IsOrtho x y := by\n  simp_rw [isOrtho_def, LinearMap.isOrtho_def, associated_apply, invOf_smul_eq_iff,\n    smul_zero, sub_sub, sub_eq_zero]\n\n"}
{"name":"QuadraticMap.not_anisotropic_iff_exists","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticMap R M N\n⊢ Iff (Not Q.Anisotropic) (Exists fun x => And (Ne x 0) (Eq (Q x) 0))","decl":"theorem not_anisotropic_iff_exists (Q : QuadraticMap R M N) :\n    ¬Anisotropic Q ↔ ∃ x, x ≠ 0 ∧ Q x = 0 := by\n  simp only [Anisotropic, not_forall, exists_prop, and_comm]\n\n"}
{"name":"QuadraticMap.Anisotropic.eq_zero_iff","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticMap R M N\nh : Q.Anisotropic\nx : M\n⊢ Iff (Eq (Q x) 0) (Eq x 0)","decl":"theorem Anisotropic.eq_zero_iff {Q : QuadraticMap R M N} (h : Anisotropic Q) {x : M} :\n    Q x = 0 ↔ x = 0 :=\n  ⟨h x, fun h => h.symm ▸ map_zero Q⟩\n\n"}
{"name":"QuadraticMap.separatingLeft_of_anisotropic","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Invertible 2\nQ : QuadraticMap R M R\nhB : Q.Anisotropic\n⊢ LinearMap.SeparatingLeft (QuadraticMap.associated' Q)","decl":"/-- The associated bilinear form of an anisotropic quadratic form is nondegenerate. -/\ntheorem separatingLeft_of_anisotropic [Invertible (2 : R)] (Q : QuadraticMap R M R)\n    (hB : Q.Anisotropic) :\n    -- Porting note: added implicit argument\n    (QuadraticMap.associated' (R := R) (N := R) Q).SeparatingLeft := fun x hx ↦ hB _ <| by\n  rw [← hx x]\n  exact (associated_eq_self_apply _ _ x).symm\n\n"}
{"name":"QuadraticMap.PosDef.smul","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : PartialOrder N\ninst✝⁴ : AddCommMonoid N\nR : Type u_8\ninst✝³ : LinearOrderedCommRing R\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : PosSMulStrictMono R N\nQ : QuadraticMap R M N\nh : Q.PosDef\na : R\na_pos : LT.lt 0 a\n⊢ (HSMul.hSMul a Q).PosDef","decl":"theorem PosDef.smul {R} [LinearOrderedCommRing R] [Module R M] [Module R N] [PosSMulStrictMono R N]\n    {Q : QuadraticMap R M N} (h : PosDef Q) {a : R} (a_pos : 0 < a) : PosDef (a • Q) :=\n  fun x hx => smul_pos a_pos (h x hx)\n\n"}
{"name":"QuadraticMap.PosDef.nonneg","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"M : Type u_4\nN : Type u_5\nR₂ : Type u\ninst✝⁵ : CommSemiring R₂\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R₂ M\ninst✝² : PartialOrder N\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R₂ N\nQ : QuadraticMap R₂ M N\nhQ : Q.PosDef\nx : M\n⊢ LE.le 0 (Q x)","decl":"theorem PosDef.nonneg {Q : QuadraticMap R₂ M N} (hQ : PosDef Q) (x : M) : 0 ≤ Q x :=\n  (eq_or_ne x 0).elim (fun h => h.symm ▸ (map_zero Q).symm.le) fun h => (hQ _ h).le\n\n"}
{"name":"QuadraticMap.PosDef.anisotropic","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"M : Type u_4\nN : Type u_5\nR₂ : Type u\ninst✝⁵ : CommSemiring R₂\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R₂ M\ninst✝² : PartialOrder N\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R₂ N\nQ : QuadraticMap R₂ M N\nhQ : Q.PosDef\n⊢ Q.Anisotropic","decl":"theorem PosDef.anisotropic {Q : QuadraticMap R₂ M N} (hQ : Q.PosDef) : Q.Anisotropic :=\n  fun x hQx => by_contradiction fun hx =>\n    lt_irrefl (0 : N) <| by\n      have := hQ _ hx\n      rw [hQx] at this\n      exact this\n\n"}
{"name":"QuadraticMap.posDef_of_nonneg","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"M : Type u_4\nN : Type u_5\nR₂ : Type u\ninst✝⁵ : CommSemiring R₂\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R₂ M\ninst✝² : PartialOrder N\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R₂ N\nQ : QuadraticMap R₂ M N\nh : ∀ (x : M), LE.le 0 (Q x)\nh0 : Q.Anisotropic\n⊢ Q.PosDef","decl":"theorem posDef_of_nonneg {Q : QuadraticMap R₂ M N} (h : ∀ x, 0 ≤ Q x) (h0 : Q.Anisotropic) :\n    PosDef Q :=\n  fun x hx => lt_of_le_of_ne (h x) (Ne.symm fun hQx => hx <| h0 _ hQx)\n\n"}
{"name":"QuadraticMap.posDef_iff_nonneg","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"M : Type u_4\nN : Type u_5\nR₂ : Type u\ninst✝⁵ : CommSemiring R₂\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R₂ M\ninst✝² : PartialOrder N\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R₂ N\nQ : QuadraticMap R₂ M N\n⊢ Iff Q.PosDef (And (∀ (x : M), LE.le 0 (Q x)) Q.Anisotropic)","decl":"theorem posDef_iff_nonneg {Q : QuadraticMap R₂ M N} : PosDef Q ↔ (∀ x, 0 ≤ Q x) ∧ Q.Anisotropic :=\n  ⟨fun h => ⟨h.nonneg, h.anisotropic⟩, fun ⟨n, a⟩ => posDef_of_nonneg n a⟩\n\n"}
{"name":"QuadraticMap.PosDef.add","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"M : Type u_4\nN : Type u_5\nR₂ : Type u\ninst✝⁶ : CommSemiring R₂\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R₂ M\ninst✝³ : PartialOrder N\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R₂ N\ninst✝ : AddLeftStrictMono N\nQ Q' : QuadraticMap R₂ M N\nhQ : Q.PosDef\nhQ' : Q'.PosDef\n⊢ (HAdd.hAdd Q Q').PosDef","decl":"theorem PosDef.add [AddLeftStrictMono N]\n    (Q Q' : QuadraticMap R₂ M N) (hQ : PosDef Q) (hQ' : PosDef Q') :\n    PosDef (Q + Q') :=\n  fun x hx => add_pos (hQ x hx) (hQ' x hx)\n\n"}
{"name":"QuadraticMap.linMulLinSelfPosDef","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"M : Type u_4\nA : Type u_7\ninst✝⁷ : AddCommMonoid M\nR : Type u_9\ninst✝⁶ : LinearOrderedCommRing R\ninst✝⁵ : Module R M\ninst✝⁴ : LinearOrderedSemiring A\ninst✝³ : ExistsAddOfLE A\ninst✝² : Module R A\ninst✝¹ : SMulCommClass R A A\ninst✝ : IsScalarTower R A A\nf : LinearMap (RingHom.id R) M A\nhf : Eq (LinearMap.ker f) Bot.bot\n⊢ (QuadraticMap.linMulLin f f).PosDef","decl":"theorem linMulLinSelfPosDef {R} [LinearOrderedCommRing R] [Module R M] [LinearOrderedSemiring A]\n    [ExistsAddOfLE A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A] (f : M →ₗ[R] A)\n    (hf : LinearMap.ker f = ⊥) : PosDef (linMulLin (A := A) f f) :=\n  fun _x hx => mul_self_pos.2 fun h => hx <| LinearMap.ker_eq_bot'.mp hf _ h\n\n"}
{"name":"QuadraticMap.toMatrix'_smul","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nn : Type w\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommRing R\ninst✝ : Invertible 2\na : R\nQ : QuadraticMap R (n → R) R\n⊢ Eq (HSMul.hSMul a Q).toMatrix' (HSMul.hSMul a Q.toMatrix')","decl":"theorem QuadraticMap.toMatrix'_smul (a : R) (Q : QuadraticMap R (n → R) R) :\n    (a • Q).toMatrix' = a • Q.toMatrix' := by\n  simp only [toMatrix', LinearEquiv.map_smul, LinearMap.map_smul]\n\n"}
{"name":"QuadraticMap.isSymm_toMatrix'","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nn : Type w\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommRing R\ninst✝ : Invertible 2\nQ : QuadraticForm R (n → R)\n⊢ (QuadraticMap.toMatrix' Q).IsSymm","decl":"theorem QuadraticMap.isSymm_toMatrix' (Q : QuadraticForm R (n → R)) : Q.toMatrix'.IsSymm := by\n  ext i j\n  rw [toMatrix', Matrix.transpose_apply, LinearMap.toMatrix₂'_apply, LinearMap.toMatrix₂'_apply,\n    ← associated_isSymm]\n\n"}
{"name":"QuadraticMap.toMatrix'_comp","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nn : Type w\ninst✝⁵ : Fintype n\ninst✝⁴ : CommRing R\ninst✝³ : DecidableEq n\ninst✝² : Invertible 2\nm : Type w\ninst✝¹ : DecidableEq m\ninst✝ : Fintype m\nQ : QuadraticMap R (m → R) R\nf : LinearMap (RingHom.id R) (n → R) (m → R)\n⊢ Eq (Q.comp f).toMatrix' (HMul.hMul (HMul.hMul (LinearMap.toMatrix' f).transpose Q.toMatrix') (LinearMap.toMatrix' f))","decl":"@[simp]\ntheorem toMatrix'_comp (Q : QuadraticMap R (m → R) R) (f : (n → R) →ₗ[R] m → R) :\n    (Q.comp f).toMatrix' = (LinearMap.toMatrix' f)ᵀ * Q.toMatrix' * (LinearMap.toMatrix' f) := by\n  ext\n  simp only [QuadraticMap.associated_comp, LinearMap.toMatrix₂'_compl₁₂, toMatrix']\n\n"}
{"name":"QuadraticMap.discr_smul","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nn : Type w\ninst✝³ : Fintype n\ninst✝² : CommRing R\ninst✝¹ : DecidableEq n\ninst✝ : Invertible 2\nQ : QuadraticMap R (n → R) R\na : R\n⊢ Eq (HSMul.hSMul a Q).discr (HMul.hMul (HPow.hPow a (Fintype.card n)) Q.discr)","decl":"theorem discr_smul (a : R) : (a • Q).discr = a ^ Fintype.card n * Q.discr := by\n  simp only [discr, toMatrix'_smul, Matrix.det_smul]\n\n"}
{"name":"QuadraticMap.discr_comp","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nn : Type w\ninst✝³ : Fintype n\ninst✝² : CommRing R\ninst✝¹ : DecidableEq n\ninst✝ : Invertible 2\nQ : QuadraticMap R (n → R) R\nf : LinearMap (RingHom.id R) (n → R) (n → R)\n⊢ Eq (Q.comp f).discr (HMul.hMul (HMul.hMul (LinearMap.toMatrix' f).det (LinearMap.toMatrix' f).det) Q.discr)","decl":"theorem discr_comp (f : (n → R) →ₗ[R] n → R) :\n    (Q.comp f).discr = f.toMatrix'.det * f.toMatrix'.det * Q.discr := by\n  simp only [Matrix.det_transpose, mul_left_comm, QuadraticMap.toMatrix'_comp, mul_comm,\n    Matrix.det_mul, discr]\n\n"}
{"name":"LinearMap.BilinForm.separatingLeft_of_anisotropic","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nB : LinearMap.BilinForm R M\nhB : (LinearMap.BilinMap.toQuadraticMap B).Anisotropic\n⊢ LinearMap.SeparatingLeft B","decl":"/--\nA bilinear form is separating left if the quadratic form it is associated with is anisotropic.\n-/\ntheorem separatingLeft_of_anisotropic {B : BilinForm R M} (hB : B.toQuadraticMap.Anisotropic) :\n    B.SeparatingLeft := fun x hx => hB _ (hx x)\n\n"}
{"name":"LinearMap.BilinForm.exists_bilinForm_self_ne_zero","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nhtwo : Invertible 2\nB : LinearMap.BilinForm R M\nhB₁ : Ne B 0\nhB₂ : LinearMap.IsSymm B\n⊢ Exists fun x => Not (LinearMap.IsOrtho B x x)","decl":"/-- There exists a non-null vector with respect to any symmetric, nonzero bilinear form `B`\non a module `M` over a ring `R` with invertible `2`, i.e. there exists some\n`x : M` such that `B x x ≠ 0`. -/\ntheorem exists_bilinForm_self_ne_zero [htwo : Invertible (2 : R)] {B : BilinForm R M}\n    (hB₁ : B ≠ 0) (hB₂ : B.IsSymm) : ∃ x, ¬B.IsOrtho x x := by\n  lift B to QuadraticForm R M using hB₂ with Q\n  obtain ⟨x, hx⟩ := QuadraticMap.exists_quadraticMap_ne_zero hB₁\n  exact ⟨x, fun h => hx (Q.associated_eq_self_apply ℕ x ▸ h)⟩\n\n"}
{"name":"LinearMap.BilinForm.exists_orthogonal_basis","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"V : Type u\nK : Type v\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nhK : Invertible 2\nB : LinearMap.BilinForm K V\nhB₂ : LinearMap.IsSymm B\n⊢ Exists fun v => LinearMap.IsOrthoᵢ B ⇑v","decl":"/-- Given a symmetric bilinear form `B` on some vector space `V` over a field `K`\nin which `2` is invertible, there exists an orthogonal basis with respect to `B`. -/\ntheorem exists_orthogonal_basis [hK : Invertible (2 : K)] {B : LinearMap.BilinForm K V}\n    (hB₂ : B.IsSymm) : ∃ v : Basis (Fin (finrank K V)) K V, B.IsOrthoᵢ v := by\n  induction' hd : finrank K V with d ih generalizing V\n  · exact ⟨basisOfFinrankZero hd, fun _ _ _ => map_zero _⟩\n  haveI := finrank_pos_iff.1 (hd.symm ▸ Nat.succ_pos d : 0 < finrank K V)\n  -- either the bilinear form is trivial or we can pick a non-null `x`\n  obtain rfl | hB₁ := eq_or_ne B 0\n  · let b := Module.finBasis K V\n    rw [hd] at b\n    exact ⟨b, fun i j _ => rfl⟩\n  obtain ⟨x, hx⟩ := exists_bilinForm_self_ne_zero hB₁ hB₂\n  rw [← Submodule.finrank_add_eq_of_isCompl (isCompl_span_singleton_orthogonal hx).symm,\n    finrank_span_singleton (ne_zero_of_map hx)] at hd\n  let B' :=  B.domRestrict₁₂ (Submodule.orthogonalBilin (K ∙ x) B )\n    (Submodule.orthogonalBilin (K ∙ x) B )\n  obtain ⟨v', hv₁⟩ := ih (hB₂.domRestrict _ : B'.IsSymm) (Nat.succ.inj hd)\n  -- concatenate `x` with the basis obtained by induction\n  let b :=\n    Basis.mkFinCons x v'\n      (by\n        rintro c y hy hc\n        rw [add_eq_zero_iff_neg_eq] at hc\n        rw [← hc, Submodule.neg_mem_iff] at hy\n        have := (isCompl_span_singleton_orthogonal hx).disjoint\n        rw [Submodule.disjoint_def] at this\n        have := this (c • x) (Submodule.smul_mem _ _ <| Submodule.mem_span_singleton_self _) hy\n        exact (smul_eq_zero.1 this).resolve_right fun h => hx <| h.symm ▸ map_zero _)\n      (by\n        intro y\n        refine ⟨-B x y / B x x, fun z hz => ?_⟩\n        obtain ⟨c, rfl⟩ := Submodule.mem_span_singleton.1 hz\n        rw [IsOrtho, map_smul, smul_apply, map_add, map_smul, smul_eq_mul, smul_eq_mul,\n          div_mul_cancel₀ _ hx, add_neg_cancel, mul_zero])\n  refine ⟨b, ?_⟩\n  rw [Basis.coe_mkFinCons]\n  intro j i\n  refine Fin.cases ?_ (fun i => ?_) i <;> refine Fin.cases ?_ (fun j => ?_) j <;> intro hij <;>\n    simp only [Function.onFun, Fin.cons_zero, Fin.cons_succ, Function.comp_apply]\n  · exact (hij rfl).elim\n  · rw [IsOrtho, ← hB₂]\n    exact (v' j).prop _ (Submodule.mem_span_singleton_self x)\n  · exact (v' i).prop _ (Submodule.mem_span_singleton_self x)\n  · exact hv₁ (ne_of_apply_ne _ hij)\n\n"}
{"name":"QuadraticMap.basisRepr_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\nι : Type u_8\ninst✝ : Fintype ι\nv : Basis ι R M\nQ : QuadraticMap R M N\nw : ι → R\n⊢ Eq ((Q.basisRepr v) w) (Q (Finset.univ.sum fun i => HSMul.hSMul (w i) (v i)))","decl":"@[simp]\ntheorem basisRepr_apply [Fintype ι] {v : Basis ι R M} (Q : QuadraticMap R M N) (w : ι → R) :\n    Q.basisRepr v w = Q (∑ i : ι, w i • v i) := by\n  rw [← v.equivFun_symm_apply]\n  rfl\n\n"}
{"name":"QuadraticMap.weightedSumSquares_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"S : Type u_1\nR : Type u_3\ninst✝⁴ : CommSemiring R\nι : Type u_8\ninst✝³ : Fintype ι\ninst✝² : Monoid S\ninst✝¹ : DistribMulAction S R\ninst✝ : SMulCommClass S R R\nw : ι → S\nv : ι → R\n⊢ Eq ((QuadraticMap.weightedSumSquares R w) v) (Finset.univ.sum fun i => HSMul.hSMul (w i) (HMul.hMul (v i) (v i)))","decl":"@[simp]\ntheorem weightedSumSquares_apply [Monoid S] [DistribMulAction S R] [SMulCommClass S R R]\n    (w : ι → S) (v : ι → R) :\n    weightedSumSquares R w v = ∑ i : ι, w i • (v i * v i) :=\n  QuadraticMap.sum_apply _ _ _\n\n"}
{"name":"QuadraticMap.basisRepr_eq_of_iIsOrtho","module":"Mathlib.LinearAlgebra.QuadraticForm.Basic","initialProofState":"ι : Type u_8\ninst✝⁴ : Fintype ι\nR : Type u_9\nM : Type u_10\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Invertible 2\nQ : QuadraticForm R M\nv : Basis ι R M\nhv₂ : LinearMap.IsOrthoᵢ (QuadraticMap.associated Q) ⇑v\n⊢ Eq (QuadraticMap.basisRepr Q v) (QuadraticMap.weightedSumSquares R fun i => Q (v i))","decl":"/-- On an orthogonal basis, the basis representation of `Q` is just a sum of squares. -/\ntheorem basisRepr_eq_of_iIsOrtho {R M} [CommRing R] [AddCommGroup M] [Module R M]\n    [Invertible (2 : R)] (Q : QuadraticForm R M) (v : Basis ι R M)\n    (hv₂ : (associated (R := R) Q).IsOrthoᵢ v) :\n    Q.basisRepr v = weightedSumSquares _ fun i => Q (v i) := by\n  ext w\n  rw [basisRepr_apply, ← @associated_eq_self_apply R, map_sum, weightedSumSquares_apply]\n  refine sum_congr rfl fun j hj => ?_\n  rw [← @associated_eq_self_apply R, LinearMap.map_sum₂, sum_eq_single_of_mem j hj]\n  · rw [LinearMap.map_smul, LinearMap.map_smul₂, smul_eq_mul, associated_apply, smul_eq_mul,\n      smul_eq_mul, LinearMap.smul_def, half_moduleEnd_apply_eq_half_smul]\n    ring_nf\n  · intro i _ hij\n    rw [LinearMap.map_smul, LinearMap.map_smul₂, hv₂ hij]\n    module\n\n"}
