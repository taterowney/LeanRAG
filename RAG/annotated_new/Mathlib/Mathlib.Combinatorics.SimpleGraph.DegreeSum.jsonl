{"name":"SimpleGraph.dart_fst_fiber","module":"Mathlib.Combinatorics.SimpleGraph.DegreeSum","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝² : Fintype V\ninst✝¹ : DecidableRel G.Adj\ninst✝ : DecidableEq V\nv : V\n⊢ Eq (Finset.filter (fun d => Eq d.toProd.1 v) Finset.univ) (Finset.image (G.dartOfNeighborSet v) Finset.univ)","decl":"theorem dart_fst_fiber [DecidableEq V] (v : V) :\n    ({d : G.Dart | d.fst = v} : Finset _) = univ.image (G.dartOfNeighborSet v) := by\n  ext d\n  simp only [mem_image, true_and, mem_filter, SetCoe.exists, mem_univ, exists_prop_of_true]\n  constructor\n  · rintro rfl\n    exact ⟨_, d.adj, by ext <;> rfl⟩\n  · rintro ⟨e, he, rfl⟩\n    rfl\n\n"}
{"name":"SimpleGraph.dart_fst_fiber_card_eq_degree","module":"Mathlib.Combinatorics.SimpleGraph.DegreeSum","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝² : Fintype V\ninst✝¹ : DecidableRel G.Adj\ninst✝ : DecidableEq V\nv : V\n⊢ Eq (Finset.filter (fun d => Eq d.toProd.1 v) Finset.univ).card (G.degree v)","decl":"theorem dart_fst_fiber_card_eq_degree [DecidableEq V] (v : V) :\n    #{d : G.Dart | d.fst = v} = G.degree v := by\n  simpa only [dart_fst_fiber, Finset.card_univ, card_neighborSet_eq_degree] using\n    card_image_of_injective univ (G.dartOfNeighborSet_injective v)\n\n"}
{"name":"SimpleGraph.dart_card_eq_sum_degrees","module":"Mathlib.Combinatorics.SimpleGraph.DegreeSum","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝¹ : Fintype V\ninst✝ : DecidableRel G.Adj\n⊢ Eq (Fintype.card G.Dart) (Finset.univ.sum fun v => G.degree v)","decl":"theorem dart_card_eq_sum_degrees : Fintype.card G.Dart = ∑ v, G.degree v := by\n  haveI := Classical.decEq V\n  simp only [← card_univ, ← dart_fst_fiber_card_eq_degree]\n  exact card_eq_sum_card_fiberwise (by simp)\n\n"}
{"name":"SimpleGraph.Dart.edge_fiber","module":"Mathlib.Combinatorics.SimpleGraph.DegreeSum","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝² : Fintype V\ninst✝¹ : DecidableRel G.Adj\ninst✝ : DecidableEq V\nd : G.Dart\n⊢ Eq (Finset.filter (fun d' => Eq d'.edge d.edge) Finset.univ) (Insert.insert d (Singleton.singleton d.symm))","decl":"theorem Dart.edge_fiber [DecidableEq V] (d : G.Dart) :\n    ({d' : G.Dart | d'.edge = d.edge} : Finset _) = {d, d.symm} :=\n  Finset.ext fun d' => by simpa using dart_edge_eq_iff d' d\n\n"}
{"name":"SimpleGraph.dart_edge_fiber_card","module":"Mathlib.Combinatorics.SimpleGraph.DegreeSum","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝² : Fintype V\ninst✝¹ : DecidableRel G.Adj\ninst✝ : DecidableEq V\ne : Sym2 V\nh : Membership.mem G.edgeSet e\n⊢ Eq (Finset.filter (fun d => Eq d.edge e) Finset.univ).card 2","decl":"theorem dart_edge_fiber_card [DecidableEq V] (e : Sym2 V) (h : e ∈ G.edgeSet) :\n    #{d : G.Dart | d.edge = e} = 2 := by\n  induction' e with v w\n  let d : G.Dart := ⟨(v, w), h⟩\n  convert congr_arg card d.edge_fiber\n  rw [card_insert_of_not_mem, card_singleton]\n  rw [mem_singleton]\n  exact d.symm_ne.symm\n\n"}
{"name":"SimpleGraph.dart_card_eq_twice_card_edges","module":"Mathlib.Combinatorics.SimpleGraph.DegreeSum","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝¹ : Fintype V\ninst✝ : DecidableRel G.Adj\n⊢ Eq (Fintype.card G.Dart) (HMul.hMul 2 G.edgeFinset.card)","decl":"theorem dart_card_eq_twice_card_edges : Fintype.card G.Dart = 2 * #G.edgeFinset := by\n  classical\n  rw [← card_univ]\n  rw [@card_eq_sum_card_fiberwise _ _ _ Dart.edge _ G.edgeFinset fun d _h =>\n      by rw [mem_edgeFinset]; apply Dart.edge_mem]\n  rw [← mul_comm, sum_const_nat]\n  intro e h\n  apply G.dart_edge_fiber_card e\n  rwa [← mem_edgeFinset]\n\n"}
{"name":"SimpleGraph.sum_degrees_eq_twice_card_edges","module":"Mathlib.Combinatorics.SimpleGraph.DegreeSum","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝¹ : Fintype V\ninst✝ : DecidableRel G.Adj\n⊢ Eq (Finset.univ.sum fun v => G.degree v) (HMul.hMul 2 G.edgeFinset.card)","decl":"/-- The degree-sum formula.  This is also known as the handshaking lemma, which might\nmore specifically refer to `SimpleGraph.even_card_odd_degree_vertices`. -/\ntheorem sum_degrees_eq_twice_card_edges : ∑ v, G.degree v = 2 * #G.edgeFinset :=\n  G.dart_card_eq_sum_degrees.symm.trans G.dart_card_eq_twice_card_edges\n\n"}
{"name":"SimpleGraph.two_mul_card_edgeFinset","module":"Mathlib.Combinatorics.SimpleGraph.DegreeSum","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝¹ : Fintype V\ninst✝ : DecidableRel G.Adj\n⊢ Eq (HMul.hMul 2 G.edgeFinset.card) (Finset.filter (fun x => SimpleGraph.two_mul_card_edgeFinset.match_1 (fun x => Prop) x fun x y => G.Adj x y) Finset.univ).card","decl":"lemma two_mul_card_edgeFinset : 2 * #G.edgeFinset = #(univ.filter fun (x, y) ↦ G.Adj x y) := by\n  rw [← dart_card_eq_twice_card_edges, ← card_univ]\n  refine card_bij' (fun d _ ↦ (d.fst, d.snd)) (fun xy h ↦ ⟨xy, (mem_filter.1 h).2⟩) ?_ ?_ ?_ ?_\n    <;> simp\n\n"}
{"name":"SimpleGraph.even_card_odd_degree_vertices","module":"Mathlib.Combinatorics.SimpleGraph.DegreeSum","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝¹ : Fintype V\ninst✝ : DecidableRel G.Adj\n⊢ Even (Finset.filter (fun v => Odd (G.degree v)) Finset.univ).card","decl":"/-- The handshaking lemma.  See also `SimpleGraph.sum_degrees_eq_twice_card_edges`. -/\ntheorem even_card_odd_degree_vertices [Fintype V] [DecidableRel G.Adj] :\n    Even #{v | Odd (G.degree v)} := by\n  classical\n    have h := congr_arg (fun n => ↑n : ℕ → ZMod 2) G.sum_degrees_eq_twice_card_edges\n    simp only [ZMod.natCast_self, zero_mul, Nat.cast_mul] at h\n    rw [Nat.cast_sum, ← sum_filter_ne_zero] at h\n    rw [@sum_congr _ _ _ _ (fun v => (G.degree v : ZMod 2)) (fun _v => (1 : ZMod 2)) _ rfl] at h\n    · simp only [filter_congr, mul_one, nsmul_eq_mul, sum_const, Ne] at h\n      rw [← ZMod.eq_zero_iff_even]\n      convert h\n      exact ZMod.ne_zero_iff_odd.symm\n    · intro v\n      simp only [true_and, mem_filter, mem_univ, Ne]\n      rw [ZMod.eq_zero_iff_even, ZMod.eq_one_iff_odd, ← Nat.not_even_iff_odd, imp_self]\n      trivial\n\n"}
{"name":"SimpleGraph.odd_card_odd_degree_vertices_ne","module":"Mathlib.Combinatorics.SimpleGraph.DegreeSum","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝² : Fintype V\ninst✝¹ : DecidableEq V\ninst✝ : DecidableRel G.Adj\nv : V\nh : Odd (G.degree v)\n⊢ Odd (Finset.filter (fun w => And (Ne w v) (Odd (G.degree w))) Finset.univ).card","decl":"theorem odd_card_odd_degree_vertices_ne [Fintype V] [DecidableEq V] [DecidableRel G.Adj] (v : V)\n    (h : Odd (G.degree v)) : Odd #{w | w ≠ v ∧ Odd (G.degree w)} := by\n  rcases G.even_card_odd_degree_vertices with ⟨k, hg⟩\n  have hk : 0 < k := by\n    have hh : Finset.Nonempty {v : V | Odd (G.degree v)} := by\n      use v\n      simp only [true_and, mem_filter, mem_univ]\n      exact h\n    rwa [← card_pos, hg, ← two_mul, mul_pos_iff_of_pos_left] at hh\n    exact zero_lt_two\n  have hc : (fun w : V => w ≠ v ∧ Odd (G.degree w)) = fun w : V => Odd (G.degree w) ∧ w ≠ v := by\n    ext w\n    rw [and_comm]\n  simp only [hc, filter_congr]\n  rw [← filter_filter, filter_ne', card_erase_of_mem]\n  · refine ⟨k - 1, tsub_eq_of_eq_add <| hg.trans ?_⟩\n    rw [add_assoc, one_add_one_eq_two, ← Nat.mul_succ, ← two_mul]\n    congr\n    omega\n  · simpa only [true_and, mem_filter, mem_univ]\n\n"}
{"name":"SimpleGraph.exists_ne_odd_degree_of_exists_odd_degree","module":"Mathlib.Combinatorics.SimpleGraph.DegreeSum","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝¹ : Fintype V\ninst✝ : DecidableRel G.Adj\nv : V\nh : Odd (G.degree v)\n⊢ Exists fun w => And (Ne w v) (Odd (G.degree w))","decl":"theorem exists_ne_odd_degree_of_exists_odd_degree [Fintype V] [DecidableRel G.Adj] (v : V)\n    (h : Odd (G.degree v)) : ∃ w : V, w ≠ v ∧ Odd (G.degree w) := by\n  haveI := Classical.decEq V\n  rcases G.odd_card_odd_degree_vertices_ne v h with ⟨k, hg⟩\n  have hg' : 0 < #{w | w ≠ v ∧ Odd (G.degree w)} := by\n    rw [hg]\n    apply Nat.succ_pos\n  rcases card_pos.mp hg' with ⟨w, hw⟩\n  simp only [true_and, mem_filter, mem_univ, Ne] at hw\n  exact ⟨w, hw⟩\n\n"}
