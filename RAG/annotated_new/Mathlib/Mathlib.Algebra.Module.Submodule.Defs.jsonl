{"name":"Submodule.smul_mem'","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nself : Submodule R M\nc : R\nx : M\na✝ : Membership.mem self.carrier x\n⊢ Membership.mem self.carrier (HSMul.hSMul c x)","decl":"/-- A submodule of a module is one which is closed under vector operations.\n  This is a sufficient condition for the subset of vectors in the submodule\n  to themselves form a module. -/\nstructure Submodule (R : Type u) (M : Type v) [Semiring R] [AddCommMonoid M] [Module R M] extends\n  AddSubmonoid M, SubMulAction R M : Type v\n\n"}
{"name":"Submodule.mk.sizeOf_spec","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : SizeOf R\ninst✝ : SizeOf M\ntoAddSubmonoid : AddSubmonoid M\nsmul_mem' : ∀ (c : R) {x : M}, Membership.mem toAddSubmonoid.carrier x → Membership.mem toAddSubmonoid.carrier (HSMul.hSMul c x)\n⊢ Eq (SizeOf.sizeOf { toAddSubmonoid := toAddSubmonoid, smul_mem' := smul_mem' }) (HAdd.hAdd 1 (SizeOf.sizeOf toAddSubmonoid))","decl":"/-- A submodule of a module is one which is closed under vector operations.\n  This is a sufficient condition for the subset of vectors in the submodule\n  to themselves form a module. -/\nstructure Submodule (R : Type u) (M : Type v) [Semiring R] [AddCommMonoid M] [Module R M] extends\n  AddSubmonoid M, SubMulAction R M : Type v\n\n"}
{"name":"Submodule.mk.injEq","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ntoAddSubmonoid✝ : AddSubmonoid M\nsmul_mem'✝ : ∀ (c : R) {x : M}, Membership.mem toAddSubmonoid✝.carrier x → Membership.mem toAddSubmonoid✝.carrier (HSMul.hSMul c x)\ntoAddSubmonoid : AddSubmonoid M\nsmul_mem' : ∀ (c : R) {x : M}, Membership.mem toAddSubmonoid.carrier x → Membership.mem toAddSubmonoid.carrier (HSMul.hSMul c x)\n⊢ Eq (Eq { toAddSubmonoid := toAddSubmonoid✝, smul_mem' := smul_mem'✝ } { toAddSubmonoid := toAddSubmonoid, smul_mem' := smul_mem' }) (Eq toAddSubmonoid✝ toAddSubmonoid)","decl":"/-- A submodule of a module is one which is closed under vector operations.\n  This is a sufficient condition for the subset of vectors in the submodule\n  to themselves form a module. -/\nstructure Submodule (R : Type u) (M : Type v) [Semiring R] [AddCommMonoid M] [Module R M] extends\n  AddSubmonoid M, SubMulAction R M : Type v\n\n"}
{"name":"Submodule.mk.inj","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ntoAddSubmonoid✝ : AddSubmonoid M\nsmul_mem'✝ : ∀ (c : R) {x : M}, Membership.mem toAddSubmonoid✝.carrier x → Membership.mem toAddSubmonoid✝.carrier (HSMul.hSMul c x)\ntoAddSubmonoid : AddSubmonoid M\nsmul_mem' : ∀ (c : R) {x : M}, Membership.mem toAddSubmonoid.carrier x → Membership.mem toAddSubmonoid.carrier (HSMul.hSMul c x)\nx✝ : Eq { toAddSubmonoid := toAddSubmonoid✝, smul_mem' := smul_mem'✝ } { toAddSubmonoid := toAddSubmonoid, smul_mem' := smul_mem' }\n⊢ Eq toAddSubmonoid✝ toAddSubmonoid","decl":"/-- A submodule of a module is one which is closed under vector operations.\n  This is a sufficient condition for the subset of vectors in the submodule\n  to themselves form a module. -/\nstructure Submodule (R : Type u) (M : Type v) [Semiring R] [AddCommMonoid M] [Module R M] extends\n  AddSubmonoid M, SubMulAction R M : Type v\n\n"}
{"name":"Submodule.addSubmonoidClass","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ AddSubmonoidClass (Submodule R M) M","decl":"instance addSubmonoidClass : AddSubmonoidClass (Submodule R M) M where\n  zero_mem _ := AddSubmonoid.zero_mem' _\n  add_mem := AddSubsemigroup.add_mem' _\n\n"}
{"name":"Submodule.smulMemClass","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ SMulMemClass (Submodule R M) R M","decl":"instance smulMemClass : SMulMemClass (Submodule R M) R M where\n  smul_mem {s} c _ h := SubMulAction.smul_mem' s.toSubMulAction c h\n\n"}
{"name":"Submodule.mem_toAddSubmonoid","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Submodule R M\nx : M\n⊢ Iff (Membership.mem p.toAddSubmonoid x) (Membership.mem p x)","decl":"@[simp]\ntheorem mem_toAddSubmonoid (p : Submodule R M) (x : M) : x ∈ p.toAddSubmonoid ↔ x ∈ p :=\n  Iff.rfl\n\n"}
{"name":"Submodule.mem_mk","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nS : AddSubmonoid M\nx : M\nh : ∀ (c : R) {x : M}, Membership.mem S.carrier x → Membership.mem S.carrier (HSMul.hSMul c x)\n⊢ Iff (Membership.mem { toAddSubmonoid := S, smul_mem' := h } x) (Membership.mem S x)","decl":"@[simp]\ntheorem mem_mk {S : AddSubmonoid M} {x : M} (h) : x ∈ (⟨S, h⟩ : Submodule R M) ↔ x ∈ S :=\n  Iff.rfl\n\n"}
{"name":"Submodule.coe_set_mk","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nS : AddSubmonoid M\nh : ∀ (c : R) {x : M}, Membership.mem S.carrier x → Membership.mem S.carrier (HSMul.hSMul c x)\n⊢ Eq ↑{ toAddSubmonoid := S, smul_mem' := h } ↑S","decl":"@[simp]\ntheorem coe_set_mk (S : AddSubmonoid M) (h) : ((⟨S, h⟩ : Submodule R M) : Set M) = S :=\n  rfl\n\n"}
{"name":"Submodule.eta","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Submodule R M\nh : ∀ (c : R) {x : M}, Membership.mem p.carrier x → Membership.mem p.carrier (HSMul.hSMul c x)\n⊢ Eq { toAddSubmonoid := p.toAddSubmonoid, smul_mem' := h } p","decl":"@[simp] theorem eta (h) : ({p with smul_mem' := h} : Submodule R M) = p :=\n  rfl\n\n-- Porting note: replaced `S ⊆ S' : Set` with `S ≤ S'`\n"}
{"name":"Submodule.mk_le_mk","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nS S' : AddSubmonoid M\nh : ∀ (c : R) {x : M}, Membership.mem S.carrier x → Membership.mem S.carrier (HSMul.hSMul c x)\nh' : ∀ (c : R) {x : M}, Membership.mem S'.carrier x → Membership.mem S'.carrier (HSMul.hSMul c x)\n⊢ Iff (LE.le { toAddSubmonoid := S, smul_mem' := h } { toAddSubmonoid := S', smul_mem' := h' }) (LE.le S S')","decl":"@[simp]\ntheorem mk_le_mk {S S' : AddSubmonoid M} (h h') :\n    (⟨S, h⟩ : Submodule R M) ≤ (⟨S', h'⟩ : Submodule R M) ↔ S ≤ S' :=\n  Iff.rfl\n\n"}
{"name":"Submodule.ext_iff","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np q : Submodule R M\n⊢ Iff (Eq p q) (∀ (x : M), Iff (Membership.mem p x) (Membership.mem q x))","decl":"@[ext]\ntheorem ext (h : ∀ x, x ∈ p ↔ x ∈ q) : p = q :=\n  SetLike.ext h\n\n-- Porting note: adding this as the `simp`-normal form of `toSubMulAction_inj`\n"}
{"name":"Submodule.ext","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np q : Submodule R M\nh : ∀ (x : M), Iff (Membership.mem p x) (Membership.mem q x)\n⊢ Eq p q","decl":"@[ext]\ntheorem ext (h : ∀ x, x ∈ p ↔ x ∈ q) : p = q :=\n  SetLike.ext h\n\n-- Porting note: adding this as the `simp`-normal form of `toSubMulAction_inj`\n"}
{"name":"Submodule.carrier_inj","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np q : Submodule R M\n⊢ Iff (Eq p.carrier q.carrier) (Eq p q)","decl":"@[simp]\ntheorem carrier_inj : p.carrier = q.carrier ↔ p = q :=\n  (SetLike.coe_injective (A := Submodule R M)).eq_iff\n\n"}
{"name":"Submodule.coe_copy","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Submodule R M\ns : Set M\nhs : Eq s ↑p\n⊢ Eq (↑(p.copy s hs)) s","decl":"/-- Copy of a submodule with a new `carrier` equal to the old one. Useful to fix definitional\nequalities. -/\n@[simps]\nprotected def copy (p : Submodule R M) (s : Set M) (hs : s = ↑p) : Submodule R M where\n  carrier := s\n  zero_mem' := by simpa [hs] using p.zero_mem'\n  add_mem' := hs.symm ▸ p.add_mem'\n  smul_mem' := by simpa [hs] using p.smul_mem'\n\n"}
{"name":"Submodule.copy_eq","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nS : Submodule R M\ns : Set M\nhs : Eq s ↑S\n⊢ Eq (S.copy s hs) S","decl":"theorem copy_eq (S : Submodule R M) (s : Set M) (hs : s = ↑S) : S.copy s hs = S :=\n  SetLike.coe_injective hs\n\n"}
{"name":"Submodule.toAddSubmonoid_injective","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Function.Injective Submodule.toAddSubmonoid","decl":"theorem toAddSubmonoid_injective : Injective (toAddSubmonoid : Submodule R M → AddSubmonoid M) :=\n  fun p q h => SetLike.ext'_iff.2 (show (p.toAddSubmonoid : Set M) = q from SetLike.ext'_iff.1 h)\n\n"}
{"name":"Submodule.toAddSubmonoid_inj","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np q : Submodule R M\n⊢ Iff (Eq p.toAddSubmonoid q.toAddSubmonoid) (Eq p q)","decl":"@[simp]\ntheorem toAddSubmonoid_inj : p.toAddSubmonoid = q.toAddSubmonoid ↔ p = q :=\n  toAddSubmonoid_injective.eq_iff\n\n"}
{"name":"Submodule.toAddSubmonoid_eq","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np q : Submodule R M\n⊢ Iff (Eq p.toAddSubmonoid q.toAddSubmonoid) (Eq p q)","decl":"@[deprecated (since := \"2024-12-29\")] alias toAddSubmonoid_eq := toAddSubmonoid_inj\n\n"}
{"name":"Submodule.coe_toAddSubmonoid","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Submodule R M\n⊢ Eq ↑p.toAddSubmonoid ↑p","decl":"@[simp]\ntheorem coe_toAddSubmonoid (p : Submodule R M) : (p.toAddSubmonoid : Set M) = p :=\n  rfl\n\n"}
{"name":"Submodule.toSubMulAction_injective","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Function.Injective Submodule.toSubMulAction","decl":"theorem toSubMulAction_injective : Injective (toSubMulAction : Submodule R M → SubMulAction R M) :=\n  fun p q h => SetLike.ext'_iff.2 (show (p.toSubMulAction : Set M) = q from SetLike.ext'_iff.1 h)\n\n"}
{"name":"Submodule.toSubMulAction_inj","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np q : Submodule R M\n⊢ Iff (Eq p.toSubMulAction q.toSubMulAction) (Eq p q)","decl":"theorem toSubMulAction_inj : p.toSubMulAction = q.toSubMulAction ↔ p = q :=\n  toSubMulAction_injective.eq_iff\n\n"}
{"name":"Submodule.toSubMulAction_eq","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np q : Submodule R M\n⊢ Iff (Eq p.toSubMulAction q.toSubMulAction) (Eq p q)","decl":"@[deprecated (since := \"2024-12-29\")] alias toSubMulAction_eq := toSubMulAction_inj\n\n"}
{"name":"Submodule.coe_toSubMulAction","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Submodule R M\n⊢ Eq ↑p.toSubMulAction ↑p","decl":"@[simp]\ntheorem coe_toSubMulAction (p : Submodule R M) : (p.toSubMulAction : Set M) = p :=\n  rfl\n\n"}
{"name":"Submodule.mem_carrier","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Semiring R\ninst✝ : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\nx : M\n⊢ Iff (Membership.mem p.carrier x) (Membership.mem (↑p) x)","decl":"theorem mem_carrier : x ∈ p.carrier ↔ x ∈ (p : Set M) :=\n  Iff.rfl\n\n"}
{"name":"Submodule.zero_mem","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Semiring R\ninst✝ : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\n⊢ Membership.mem p 0","decl":"@[simp]\nprotected theorem zero_mem : (0 : M) ∈ p :=\n  zero_mem _\n\n"}
{"name":"Submodule.add_mem","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Semiring R\ninst✝ : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\nx y : M\nh₁ : Membership.mem p x\nh₂ : Membership.mem p y\n⊢ Membership.mem p (HAdd.hAdd x y)","decl":"protected theorem add_mem (h₁ : x ∈ p) (h₂ : y ∈ p) : x + y ∈ p :=\n  add_mem h₁ h₂\n\n"}
{"name":"Submodule.smul_mem","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Semiring R\ninst✝ : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\nx : M\nr : R\nh : Membership.mem p x\n⊢ Membership.mem p (HSMul.hSMul r x)","decl":"theorem smul_mem (r : R) (h : x ∈ p) : r • x ∈ p :=\n  p.smul_mem' r h\n\n"}
{"name":"Submodule.smul_of_tower_mem","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"S : Type u'\nR : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\nx : M\ninst✝² : SMul S R\ninst✝¹ : SMul S M\ninst✝ : IsScalarTower S R M\nr : S\nh : Membership.mem p x\n⊢ Membership.mem p (HSMul.hSMul r x)","decl":"theorem smul_of_tower_mem [SMul S R] [SMul S M] [IsScalarTower S R M] (r : S) (h : x ∈ p) :\n    r • x ∈ p :=\n  p.toSubMulAction.smul_of_tower_mem r h\n\n"}
{"name":"Submodule.smul_mem_iff'","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"G : Type u''\nR : Type u\nM : Type v\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\nx : M\ninst✝³ : Group G\ninst✝² : MulAction G M\ninst✝¹ : SMul G R\ninst✝ : IsScalarTower G R M\ng : G\n⊢ Iff (Membership.mem p (HSMul.hSMul g x)) (Membership.mem p x)","decl":"@[simp]\ntheorem smul_mem_iff' [Group G] [MulAction G M] [SMul G R] [IsScalarTower G R M] (g : G) :\n    g • x ∈ p ↔ x ∈ p :=\n  p.toSubMulAction.smul_mem_iff' g\n\n"}
{"name":"Submodule.isScalarTower","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"S : Type u'\nR : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\ninst✝² : SMul S R\ninst✝¹ : SMul S M\ninst✝ : IsScalarTower S R M\n⊢ IsScalarTower S R (Subtype fun x => Membership.mem p x)","decl":"instance isScalarTower [SMul S R] [SMul S M] [IsScalarTower S R M] : IsScalarTower S R p :=\n  p.toSubMulAction.isScalarTower\n\n"}
{"name":"Submodule.isScalarTower'","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"S : Type u'\nR : Type u\nM : Type v\ninst✝⁹ : Semiring R\ninst✝⁸ : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\nS' : Type u_1\ninst✝⁷ : SMul S R\ninst✝⁶ : SMul S M\ninst✝⁵ : SMul S' R\ninst✝⁴ : SMul S' M\ninst✝³ : SMul S S'\ninst✝² : IsScalarTower S' R M\ninst✝¹ : IsScalarTower S S' M\ninst✝ : IsScalarTower S R M\n⊢ IsScalarTower S S' (Subtype fun x => Membership.mem p x)","decl":"instance isScalarTower' {S' : Type*} [SMul S R] [SMul S M] [SMul S' R] [SMul S' M] [SMul S S']\n    [IsScalarTower S' R M] [IsScalarTower S S' M] [IsScalarTower S R M] : IsScalarTower S S' p :=\n  p.toSubMulAction.isScalarTower'\n\n"}
{"name":"Submodule.nonempty","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Semiring R\ninst✝ : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\n⊢ (↑p).Nonempty","decl":"protected theorem nonempty : (p : Set M).Nonempty :=\n  ⟨0, p.zero_mem⟩\n\n"}
{"name":"Submodule.mk_eq_zero","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Semiring R\ninst✝ : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\nx : M\nh : Membership.mem p x\n⊢ Iff (Eq ⟨x, h⟩ 0) (Eq x 0)","decl":"@[simp]\ntheorem mk_eq_zero {x} (h : x ∈ p) : (⟨x, h⟩ : p) = 0 ↔ x = 0 :=\n  Subtype.ext_iff_val\n\n"}
{"name":"Submodule.coe_eq_zero","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Semiring R\ninst✝ : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\nx : Subtype fun x => Membership.mem p x\n⊢ Iff (Eq (↑x) 0) (Eq x 0)","decl":"@[norm_cast] -- Porting note: removed `@[simp]` because this follows from `ZeroMemClass.coe_zero`\ntheorem coe_eq_zero {x : p} : (x : M) = 0 ↔ x = 0 :=\n  (SetLike.coe_eq_coe : (x : M) = (0 : p) ↔ x = 0)\n\n"}
{"name":"Submodule.coe_add","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Semiring R\ninst✝ : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\nx y : Subtype fun x => Membership.mem p x\n⊢ Eq (↑(HAdd.hAdd x y)) (HAdd.hAdd ↑x ↑y)","decl":"@[simp, norm_cast]\ntheorem coe_add (x y : p) : (↑(x + y) : M) = ↑x + ↑y :=\n  rfl\n\n"}
{"name":"Submodule.coe_zero","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Semiring R\ninst✝ : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\n⊢ Eq (↑0) 0","decl":"@[simp, norm_cast]\ntheorem coe_zero : ((0 : p) : M) = 0 :=\n  rfl\n\n"}
{"name":"Submodule.coe_smul","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Semiring R\ninst✝ : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\nr : R\nx : Subtype fun x => Membership.mem p x\n⊢ Eq (↑(HSMul.hSMul r x)) (HSMul.hSMul r ↑x)","decl":"@[norm_cast]\ntheorem coe_smul (r : R) (x : p) : ((r • x : p) : M) = r • (x : M) :=\n  rfl\n\n"}
{"name":"Submodule.coe_smul_of_tower","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"S : Type u'\nR : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\ninst✝² : SMul S R\ninst✝¹ : SMul S M\ninst✝ : IsScalarTower S R M\nr : S\nx : Subtype fun x => Membership.mem p x\n⊢ Eq (↑(HSMul.hSMul r x)) (HSMul.hSMul r ↑x)","decl":"@[simp, norm_cast]\ntheorem coe_smul_of_tower [SMul S R] [SMul S M] [IsScalarTower S R M] (r : S) (x : p) :\n    ((r • x : p) : M) = r • (x : M) :=\n  rfl\n\n"}
{"name":"Submodule.coe_mk","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Semiring R\ninst✝ : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\nx : M\nhx : Membership.mem p x\n⊢ Eq (↑⟨x, hx⟩) x","decl":"@[norm_cast] -- Porting note: removed `@[simp]` because this is now structure eta\ntheorem coe_mk (x : M) (hx : x ∈ p) : ((⟨x, hx⟩ : p) : M) = x :=\n  rfl\n\n-- Porting note: removed `@[simp]` because this is exactly `SetLike.coe_mem`\n"}
{"name":"Submodule.coe_mem","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Semiring R\ninst✝ : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\nx : Subtype fun x => Membership.mem p x\n⊢ Membership.mem p ↑x","decl":"theorem coe_mem (x : p) : (x : M) ∈ p :=\n  x.2\n\n"}
{"name":"Submodule.addSubgroupClass","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ AddSubgroupClass (Submodule R M) M","decl":"instance addSubgroupClass [Module R M] : AddSubgroupClass (Submodule R M) M :=\n  { Submodule.addSubmonoidClass with neg_mem := fun p {_} => p.toSubMulAction.neg_mem }\n\n"}
{"name":"Submodule.neg_mem","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Ring R\ninst✝ : AddCommGroup M\nmodule_M : Module R M\np : Submodule R M\nx : M\nhx : Membership.mem p x\n⊢ Membership.mem p (Neg.neg x)","decl":"protected theorem neg_mem (hx : x ∈ p) : -x ∈ p :=\n  neg_mem hx\n\n"}
{"name":"Submodule.coe_toAddSubgroup","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Ring R\ninst✝ : AddCommGroup M\nmodule_M : Module R M\np : Submodule R M\n⊢ Eq ↑p.toAddSubgroup ↑p","decl":"@[simp]\ntheorem coe_toAddSubgroup : (p.toAddSubgroup : Set M) = p :=\n  rfl\n\n"}
{"name":"Submodule.mem_toAddSubgroup","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Ring R\ninst✝ : AddCommGroup M\nmodule_M : Module R M\np : Submodule R M\nx : M\n⊢ Iff (Membership.mem p.toAddSubgroup x) (Membership.mem p x)","decl":"@[simp]\ntheorem mem_toAddSubgroup : x ∈ p.toAddSubgroup ↔ x ∈ p :=\n  Iff.rfl\n\n"}
{"name":"Submodule.toAddSubgroup_injective","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Ring R\ninst✝ : AddCommGroup M\nmodule_M : Module R M\n⊢ Function.Injective Submodule.toAddSubgroup","decl":"theorem toAddSubgroup_injective : Injective (toAddSubgroup : Submodule R M → AddSubgroup M)\n  | _, _, h => SetLike.ext (SetLike.ext_iff.1 h :)\n\n"}
{"name":"Submodule.toAddSubgroup_inj","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Ring R\ninst✝ : AddCommGroup M\nmodule_M : Module R M\np p' : Submodule R M\n⊢ Iff (Eq p.toAddSubgroup p'.toAddSubgroup) (Eq p p')","decl":"@[simp]\ntheorem toAddSubgroup_inj : p.toAddSubgroup = p'.toAddSubgroup ↔ p = p' :=\n  toAddSubgroup_injective.eq_iff\n\n"}
{"name":"Submodule.toAddSubgroup_eq","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Ring R\ninst✝ : AddCommGroup M\nmodule_M : Module R M\np p' : Submodule R M\n⊢ Iff (Eq p.toAddSubgroup p'.toAddSubgroup) (Eq p p')","decl":"@[deprecated (since := \"2024-12-29\")] alias toAddSubgroup_eq := toAddSubgroup_inj\n\n"}
{"name":"Submodule.sub_mem","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Ring R\ninst✝ : AddCommGroup M\nmodule_M : Module R M\np : Submodule R M\nx y : M\na✝¹ : Membership.mem p x\na✝ : Membership.mem p y\n⊢ Membership.mem p (HSub.hSub x y)","decl":"protected theorem sub_mem : x ∈ p → y ∈ p → x - y ∈ p :=\n  sub_mem\n\n"}
{"name":"Submodule.neg_mem_iff","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Ring R\ninst✝ : AddCommGroup M\nmodule_M : Module R M\np : Submodule R M\nx : M\n⊢ Iff (Membership.mem p (Neg.neg x)) (Membership.mem p x)","decl":"protected theorem neg_mem_iff : -x ∈ p ↔ x ∈ p :=\n  neg_mem_iff\n\n"}
{"name":"Submodule.add_mem_iff_left","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Ring R\ninst✝ : AddCommGroup M\nmodule_M : Module R M\np : Submodule R M\nx y : M\na✝ : Membership.mem p y\n⊢ Iff (Membership.mem p (HAdd.hAdd x y)) (Membership.mem p x)","decl":"protected theorem add_mem_iff_left : y ∈ p → (x + y ∈ p ↔ x ∈ p) :=\n  add_mem_cancel_right\n\n"}
{"name":"Submodule.add_mem_iff_right","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Ring R\ninst✝ : AddCommGroup M\nmodule_M : Module R M\np : Submodule R M\nx y : M\na✝ : Membership.mem p x\n⊢ Iff (Membership.mem p (HAdd.hAdd x y)) (Membership.mem p y)","decl":"protected theorem add_mem_iff_right : x ∈ p → (x + y ∈ p ↔ y ∈ p) :=\n  add_mem_cancel_left\n\n"}
{"name":"Submodule.coe_neg","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Ring R\ninst✝ : AddCommGroup M\nmodule_M : Module R M\np : Submodule R M\nx : Subtype fun x => Membership.mem p x\n⊢ Eq (↑(Neg.neg x)) (Neg.neg ↑x)","decl":"protected theorem coe_neg (x : p) : ((-x : p) : M) = -x :=\n  NegMemClass.coe_neg _\n\n"}
{"name":"Submodule.coe_sub","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Ring R\ninst✝ : AddCommGroup M\nmodule_M : Module R M\np : Submodule R M\nx y : Subtype fun x => Membership.mem p x\n⊢ Eq (↑(HSub.hSub x y)) (HSub.hSub ↑x ↑y)","decl":"protected theorem coe_sub (x y : p) : (↑(x - y) : M) = ↑x - ↑y :=\n  AddSubgroupClass.coe_sub _ _\n\n"}
{"name":"Submodule.sub_mem_iff_left","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Ring R\ninst✝ : AddCommGroup M\nmodule_M : Module R M\np : Submodule R M\nx y : M\nhy : Membership.mem p y\n⊢ Iff (Membership.mem p (HSub.hSub x y)) (Membership.mem p x)","decl":"theorem sub_mem_iff_left (hy : y ∈ p) : x - y ∈ p ↔ x ∈ p := by\n  rw [sub_eq_add_neg, p.add_mem_iff_left (p.neg_mem hy)]\n\n"}
{"name":"Submodule.sub_mem_iff_right","module":"Mathlib.Algebra.Module.Submodule.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Ring R\ninst✝ : AddCommGroup M\nmodule_M : Module R M\np : Submodule R M\nx y : M\nhx : Membership.mem p x\n⊢ Iff (Membership.mem p (HSub.hSub x y)) (Membership.mem p y)","decl":"theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by\n  rw [sub_eq_add_neg, p.add_mem_iff_right hx, p.neg_mem_iff]\n\n"}
