{"name":"FreeMagma.mul_eq","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nx y : FreeMagma α\n⊢ Eq (x.mul y) (HMul.hMul x y)","decl":"@[to_additive (attr := simp)]\ntheorem mul_eq (x y : FreeMagma α) : mul x y = x * y := rfl\n\n"}
{"name":"FreeAddMagma.add_eq","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nx y : FreeAddMagma α\n⊢ Eq (x.add y) (HAdd.hAdd x y)","decl":"@[to_additive (attr := simp)]\ntheorem mul_eq (x y : FreeMagma α) : mul x y = x * y := rfl\n\n"}
{"name":"FreeAddMagma.hom_ext_iff","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Add β\nf g : AddHom (FreeAddMagma α) β\n⊢ Iff (Eq f g) (Eq (Function.comp (⇑f) FreeAddMagma.of) (Function.comp (⇑g) FreeAddMagma.of))","decl":"@[to_additive (attr := ext 1100)]\ntheorem hom_ext {β : Type v} [Mul β] {f g : FreeMagma α →ₙ* β} (h : f ∘ of = g ∘ of) : f = g :=\n  (DFunLike.ext _ _) fun x ↦ recOnMul x (congr_fun h) <| by intros; simp only [map_mul, *]\n\n"}
{"name":"FreeMagma.hom_ext","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Mul β\nf g : MulHom (FreeMagma α) β\nh : Eq (Function.comp (⇑f) FreeMagma.of) (Function.comp (⇑g) FreeMagma.of)\n⊢ Eq f g","decl":"@[to_additive (attr := ext 1100)]\ntheorem hom_ext {β : Type v} [Mul β] {f g : FreeMagma α →ₙ* β} (h : f ∘ of = g ∘ of) : f = g :=\n  (DFunLike.ext _ _) fun x ↦ recOnMul x (congr_fun h) <| by intros; simp only [map_mul, *]\n\n"}
{"name":"FreeAddMagma.hom_ext","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Add β\nf g : AddHom (FreeAddMagma α) β\nh : Eq (Function.comp (⇑f) FreeAddMagma.of) (Function.comp (⇑g) FreeAddMagma.of)\n⊢ Eq f g","decl":"@[to_additive (attr := ext 1100)]\ntheorem hom_ext {β : Type v} [Mul β] {f g : FreeMagma α →ₙ* β} (h : f ∘ of = g ∘ of) : f = g :=\n  (DFunLike.ext _ _) fun x ↦ recOnMul x (congr_fun h) <| by intros; simp only [map_mul, *]\n\n"}
{"name":"FreeMagma.hom_ext_iff","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Mul β\nf g : MulHom (FreeMagma α) β\n⊢ Iff (Eq f g) (Eq (Function.comp (⇑f) FreeMagma.of) (Function.comp (⇑g) FreeMagma.of))","decl":"@[to_additive (attr := ext 1100)]\ntheorem hom_ext {β : Type v} [Mul β] {f g : FreeMagma α →ₙ* β} (h : f ∘ of = g ∘ of) : f = g :=\n  (DFunLike.ext _ _) fun x ↦ recOnMul x (congr_fun h) <| by intros; simp only [map_mul, *]\n\n"}
{"name":"FreeMagma.lift_symm_apply","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Mul β\nF : MulHom (FreeMagma α) β\na✝ : α\n⊢ Eq (FreeMagma.lift.symm F a✝) (Function.comp (⇑F) FreeMagma.of a✝)","decl":"/-- The universal property of the free magma expressing its adjointness. -/\n@[to_additive (attr := simps symm_apply)\n\"The universal property of the free additive magma expressing its adjointness.\"]\ndef lift : (α → β) ≃ (FreeMagma α →ₙ* β) where\n  toFun f :=\n  { toFun := liftAux f\n    map_mul' := fun _ _ ↦ rfl }\n  invFun F := F ∘ of\n  left_inv _ := rfl\n  right_inv F := by ext; rfl\n\n"}
{"name":"FreeAddMagma.lift_symm_apply","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Add β\nF : AddHom (FreeAddMagma α) β\na✝ : α\n⊢ Eq (FreeAddMagma.lift.symm F a✝) (Function.comp (⇑F) FreeAddMagma.of a✝)","decl":"/-- The universal property of the free magma expressing its adjointness. -/\n@[to_additive (attr := simps symm_apply)\n\"The universal property of the free additive magma expressing its adjointness.\"]\ndef lift : (α → β) ≃ (FreeMagma α →ₙ* β) where\n  toFun f :=\n  { toFun := liftAux f\n    map_mul' := fun _ _ ↦ rfl }\n  invFun F := F ∘ of\n  left_inv _ := rfl\n  right_inv F := by ext; rfl\n\n"}
{"name":"FreeAddMagma.lift_of","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Add β\nf : α → β\nx : α\n⊢ Eq ((FreeAddMagma.lift f) (FreeAddMagma.of x)) (f x)","decl":"@[to_additive (attr := simp)]\ntheorem lift_of (x) : lift f (of x) = f x := rfl\n\n"}
{"name":"FreeMagma.lift_of","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Mul β\nf : α → β\nx : α\n⊢ Eq ((FreeMagma.lift f) (FreeMagma.of x)) (f x)","decl":"@[to_additive (attr := simp)]\ntheorem lift_of (x) : lift f (of x) = f x := rfl\n\n"}
{"name":"FreeAddMagma.lift_comp_of","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Add β\nf : α → β\n⊢ Eq (Function.comp (⇑(FreeAddMagma.lift f)) FreeAddMagma.of) f","decl":"@[to_additive (attr := simp)]\ntheorem lift_comp_of : lift f ∘ of = f := rfl\n\n"}
{"name":"FreeMagma.lift_comp_of","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Mul β\nf : α → β\n⊢ Eq (Function.comp (⇑(FreeMagma.lift f)) FreeMagma.of) f","decl":"@[to_additive (attr := simp)]\ntheorem lift_comp_of : lift f ∘ of = f := rfl\n\n"}
{"name":"FreeAddMagma.lift_comp_of'","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Add β\nf : AddHom (FreeAddMagma α) β\n⊢ Eq (FreeAddMagma.lift (Function.comp (⇑f) FreeAddMagma.of)) f","decl":"@[to_additive (attr := simp)]\ntheorem lift_comp_of' (f : FreeMagma α →ₙ* β) : lift (f ∘ of) = f := lift.apply_symm_apply f\n\n"}
{"name":"FreeMagma.lift_comp_of'","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Mul β\nf : MulHom (FreeMagma α) β\n⊢ Eq (FreeMagma.lift (Function.comp (⇑f) FreeMagma.of)) f","decl":"@[to_additive (attr := simp)]\ntheorem lift_comp_of' (f : FreeMagma α →ₙ* β) : lift (f ∘ of) = f := lift.apply_symm_apply f\n\n"}
{"name":"FreeMagma.map_of","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nx : α\n⊢ Eq ((FreeMagma.map f) (FreeMagma.of x)) (FreeMagma.of (f x))","decl":"@[to_additive (attr := simp)]\ntheorem map_of (x) : map f (of x) = of (f x) := rfl\n\n"}
{"name":"FreeAddMagma.map_of","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nx : α\n⊢ Eq ((FreeAddMagma.map f) (FreeAddMagma.of x)) (FreeAddMagma.of (f x))","decl":"@[to_additive (attr := simp)]\ntheorem map_of (x) : map f (of x) = of (f x) := rfl\n\n"}
{"name":"FreeAddMagma.map_pure","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nf : α → β\nx : α\n⊢ Eq (Functor.map f (Pure.pure x)) (Pure.pure (f x))","decl":"@[to_additive (attr := simp)]\ntheorem map_pure (f : α → β) (x) : (f <$> pure x : FreeMagma β) = pure (f x) := rfl\n\n"}
{"name":"FreeMagma.map_pure","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nf : α → β\nx : α\n⊢ Eq (Functor.map f (Pure.pure x)) (Pure.pure (f x))","decl":"@[to_additive (attr := simp)]\ntheorem map_pure (f : α → β) (x) : (f <$> pure x : FreeMagma β) = pure (f x) := rfl\n\n"}
{"name":"FreeAddMagma.map_add'","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nf : α → β\nx y : FreeAddMagma α\n⊢ Eq (Functor.map f (HAdd.hAdd x y)) (HAdd.hAdd (Functor.map f x) (Functor.map f y))","decl":"@[to_additive (attr := simp)]\ntheorem map_mul' (f : α → β) (x y : FreeMagma α) : f <$> (x * y) = f <$> x * f <$> y := rfl\n\n"}
{"name":"FreeMagma.map_mul'","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nf : α → β\nx y : FreeMagma α\n⊢ Eq (Functor.map f (HMul.hMul x y)) (HMul.hMul (Functor.map f x) (Functor.map f y))","decl":"@[to_additive (attr := simp)]\ntheorem map_mul' (f : α → β) (x y : FreeMagma α) : f <$> (x * y) = f <$> x * f <$> y := rfl\n\n"}
{"name":"FreeMagma.pure_bind","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nf : α → FreeMagma β\nx : α\n⊢ Eq (Bind.bind (Pure.pure x) f) (f x)","decl":"@[to_additive (attr := simp)]\ntheorem pure_bind (f : α → FreeMagma β) (x) : pure x >>= f = f x := rfl\n\n"}
{"name":"FreeAddMagma.pure_bind","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nf : α → FreeAddMagma β\nx : α\n⊢ Eq (Bind.bind (Pure.pure x) f) (f x)","decl":"@[to_additive (attr := simp)]\ntheorem pure_bind (f : α → FreeMagma β) (x) : pure x >>= f = f x := rfl\n\n"}
{"name":"FreeAddMagma.add_bind","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nf : α → FreeAddMagma β\nx y : FreeAddMagma α\n⊢ Eq (Bind.bind (HAdd.hAdd x y) f) (HAdd.hAdd (Bind.bind x f) (Bind.bind y f))","decl":"@[to_additive (attr := simp)]\ntheorem mul_bind (f : α → FreeMagma β) (x y : FreeMagma α) : x * y >>= f = (x >>= f) * (y >>= f) :=\n  rfl\n\n"}
{"name":"FreeMagma.mul_bind","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nf : α → FreeMagma β\nx y : FreeMagma α\n⊢ Eq (Bind.bind (HMul.hMul x y) f) (HMul.hMul (Bind.bind x f) (Bind.bind y f))","decl":"@[to_additive (attr := simp)]\ntheorem mul_bind (f : α → FreeMagma β) (x y : FreeMagma α) : x * y >>= f = (x >>= f) * (y >>= f) :=\n  rfl\n\n"}
{"name":"FreeAddMagma.pure_seq","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nf : α → β\nx : FreeAddMagma α\n⊢ Eq (Seq.seq (Pure.pure f) fun x_1 => x) (Functor.map f x)","decl":"@[to_additive (attr := simp)]\ntheorem pure_seq {α β : Type u} {f : α → β} {x : FreeMagma α} : pure f <*> x = f <$> x := rfl\n\n"}
{"name":"FreeMagma.pure_seq","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nf : α → β\nx : FreeMagma α\n⊢ Eq (Seq.seq (Pure.pure f) fun x_1 => x) (Functor.map f x)","decl":"@[to_additive (attr := simp)]\ntheorem pure_seq {α β : Type u} {f : α → β} {x : FreeMagma α} : pure f <*> x = f <$> x := rfl\n\n"}
{"name":"FreeAddMagma.add_seq","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nf g : FreeAddMagma (α → β)\nx : FreeAddMagma α\n⊢ Eq (Seq.seq (HAdd.hAdd f g) fun x_1 => x) (HAdd.hAdd (Seq.seq f fun x_1 => x) (Seq.seq g fun x_1 => x))","decl":"@[to_additive (attr := simp)]\ntheorem mul_seq {α β : Type u} {f g : FreeMagma (α → β)} {x : FreeMagma α} :\n    f * g <*> x = (f <*> x) * (g <*> x) := rfl\n\n"}
{"name":"FreeMagma.mul_seq","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nf g : FreeMagma (α → β)\nx : FreeMagma α\n⊢ Eq (Seq.seq (HMul.hMul f g) fun x_1 => x) (HMul.hMul (Seq.seq f fun x_1 => x) (Seq.seq g fun x_1 => x))","decl":"@[to_additive (attr := simp)]\ntheorem mul_seq {α β : Type u} {f g : FreeMagma (α → β)} {x : FreeMagma α} :\n    f * g <*> x = (f <*> x) * (g <*> x) := rfl\n\n"}
{"name":"FreeAddMagma.instLawfulMonad","module":"Mathlib.Algebra.Free","initialProofState":"⊢ LawfulMonad FreeAddMagma","decl":"@[to_additive]\ninstance instLawfulMonad : LawfulMonad FreeMagma.{u} := LawfulMonad.mk'\n  (pure_bind := fun _ _ ↦ rfl)\n  (bind_assoc := fun x f g ↦ FreeMagma.recOnPure x (fun _ ↦ rfl) fun x y ih1 ih2 ↦ by\n    rw [mul_bind, mul_bind, mul_bind, ih1, ih2])\n  (id_map := fun x ↦ FreeMagma.recOnPure x (fun _ ↦ rfl) fun x y ih1 ih2 ↦ by\n    rw [map_mul', ih1, ih2])\n\n"}
{"name":"FreeMagma.instLawfulMonad","module":"Mathlib.Algebra.Free","initialProofState":"⊢ LawfulMonad FreeMagma","decl":"@[to_additive]\ninstance instLawfulMonad : LawfulMonad FreeMagma.{u} := LawfulMonad.mk'\n  (pure_bind := fun _ _ ↦ rfl)\n  (bind_assoc := fun x f g ↦ FreeMagma.recOnPure x (fun _ ↦ rfl) fun x y ih1 ih2 ↦ by\n    rw [mul_bind, mul_bind, mul_bind, ih1, ih2])\n  (id_map := fun x ↦ FreeMagma.recOnPure x (fun _ ↦ rfl) fun x y ih1 ih2 ↦ by\n    rw [map_mul', ih1, ih2])\n\n"}
{"name":"FreeAddMagma.traverse_pure","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nm : Type u → Type u\ninst✝ : Applicative m\nF : α → m β\nx : α\n⊢ Eq (Traversable.traverse F (Pure.pure x)) (Functor.map Pure.pure (F x))","decl":"@[to_additive (attr := simp)]\ntheorem traverse_pure (x) : traverse F (pure x : FreeMagma α) = pure <$> F x := rfl\n\n"}
{"name":"FreeMagma.traverse_pure","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nm : Type u → Type u\ninst✝ : Applicative m\nF : α → m β\nx : α\n⊢ Eq (Traversable.traverse F (Pure.pure x)) (Functor.map Pure.pure (F x))","decl":"@[to_additive (attr := simp)]\ntheorem traverse_pure (x) : traverse F (pure x : FreeMagma α) = pure <$> F x := rfl\n\n"}
{"name":"FreeAddMagma.traverse_pure'","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nm : Type u → Type u\ninst✝ : Applicative m\nF : α → m β\n⊢ Eq (Function.comp (Traversable.traverse F) Pure.pure) fun x => Functor.map Pure.pure (F x)","decl":"@[to_additive (attr := simp)]\ntheorem traverse_pure' : traverse F ∘ pure = fun x ↦ (pure <$> F x : m (FreeMagma β)) := rfl\n\n"}
{"name":"FreeMagma.traverse_pure'","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nm : Type u → Type u\ninst✝ : Applicative m\nF : α → m β\n⊢ Eq (Function.comp (Traversable.traverse F) Pure.pure) fun x => Functor.map Pure.pure (F x)","decl":"@[to_additive (attr := simp)]\ntheorem traverse_pure' : traverse F ∘ pure = fun x ↦ (pure <$> F x : m (FreeMagma β)) := rfl\n\n"}
{"name":"FreeAddMagma.traverse_add","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nm : Type u → Type u\ninst✝ : Applicative m\nF : α → m β\nx y : FreeAddMagma α\n⊢ Eq (Traversable.traverse F (HAdd.hAdd x y)) (Seq.seq (Functor.map (fun x1 x2 => HAdd.hAdd x1 x2) (Traversable.traverse F x)) fun x => Traversable.traverse F y)","decl":"@[to_additive (attr := simp)]\ntheorem traverse_mul (x y : FreeMagma α) :\n    traverse F (x * y) = (· * ·) <$> traverse F x <*> traverse F y := rfl\n\n"}
{"name":"FreeMagma.traverse_mul","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nm : Type u → Type u\ninst✝ : Applicative m\nF : α → m β\nx y : FreeMagma α\n⊢ Eq (Traversable.traverse F (HMul.hMul x y)) (Seq.seq (Functor.map (fun x1 x2 => HMul.hMul x1 x2) (Traversable.traverse F x)) fun x => Traversable.traverse F y)","decl":"@[to_additive (attr := simp)]\ntheorem traverse_mul (x y : FreeMagma α) :\n    traverse F (x * y) = (· * ·) <$> traverse F x <*> traverse F y := rfl\n\n"}
{"name":"FreeMagma.traverse_mul'","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nm : Type u → Type u\ninst✝ : Applicative m\nF : α → m β\n⊢ Eq (Function.comp (Function.comp (Traversable.traverse F)) HMul.hMul) fun x y => Seq.seq (Functor.map (fun x1 x2 => HMul.hMul x1 x2) (Traversable.traverse F x)) fun x => Traversable.traverse F y","decl":"@[to_additive (attr := simp)]\ntheorem traverse_mul' :\n    Function.comp (traverse F) ∘ (HMul.hMul : FreeMagma α → FreeMagma α → FreeMagma α) = fun x y ↦\n      (· * ·) <$> traverse F x <*> traverse F y := rfl\n\n"}
{"name":"FreeAddMagma.traverse_add'","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nm : Type u → Type u\ninst✝ : Applicative m\nF : α → m β\n⊢ Eq (Function.comp (Function.comp (Traversable.traverse F)) HAdd.hAdd) fun x y => Seq.seq (Functor.map (fun x1 x2 => HAdd.hAdd x1 x2) (Traversable.traverse F x)) fun x => Traversable.traverse F y","decl":"@[to_additive (attr := simp)]\ntheorem traverse_mul' :\n    Function.comp (traverse F) ∘ (HMul.hMul : FreeMagma α → FreeMagma α → FreeMagma α) = fun x y ↦\n      (· * ·) <$> traverse F x <*> traverse F y := rfl\n\n"}
{"name":"FreeAddMagma.traverse_eq","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nm : Type u → Type u\ninst✝ : Applicative m\nF : α → m β\nx : FreeAddMagma α\n⊢ Eq (FreeAddMagma.traverse F x) (Traversable.traverse F x)","decl":"@[to_additive (attr := simp)]\ntheorem traverse_eq (x) : FreeMagma.traverse F x = traverse F x := rfl\n\n-- This is not a simp lemma because the left-hand side is not in simp normal form.\n"}
{"name":"FreeMagma.traverse_eq","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nm : Type u → Type u\ninst✝ : Applicative m\nF : α → m β\nx : FreeMagma α\n⊢ Eq (FreeMagma.traverse F x) (Traversable.traverse F x)","decl":"@[to_additive (attr := simp)]\ntheorem traverse_eq (x) : FreeMagma.traverse F x = traverse F x := rfl\n\n-- This is not a simp lemma because the left-hand side is not in simp normal form.\n"}
{"name":"FreeMagma.mul_map_seq","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nx y : FreeMagma α\n⊢ Eq (Seq.seq (Functor.map (fun x1 x2 => HMul.hMul x1 x2) x) fun x => y) (HMul.hMul x y)","decl":"@[to_additive]\ntheorem mul_map_seq (x y : FreeMagma α) :\n    ((· * ·) <$> x <*> y : Id (FreeMagma α)) = (x * y : FreeMagma α) := rfl\n\n"}
{"name":"FreeAddMagma.add_map_seq","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nx y : FreeAddMagma α\n⊢ Eq (Seq.seq (Functor.map (fun x1 x2 => HAdd.hAdd x1 x2) x) fun x => y) (HAdd.hAdd x y)","decl":"@[to_additive]\ntheorem mul_map_seq (x y : FreeMagma α) :\n    ((· * ·) <$> x <*> y : Id (FreeMagma α)) = (x * y : FreeMagma α) := rfl\n\n"}
{"name":"FreeMagma.instLawfulTraversable","module":"Mathlib.Algebra.Free","initialProofState":"⊢ LawfulTraversable FreeMagma","decl":"@[to_additive]\ninstance : LawfulTraversable FreeMagma.{u} :=\n  { instLawfulMonad with\n    id_traverse := fun x ↦\n      FreeMagma.recOnPure x (fun _ ↦ rfl) fun x y ih1 ih2 ↦ by\n        rw [traverse_mul, ih1, ih2, mul_map_seq]\n    comp_traverse := fun f g x ↦\n      FreeMagma.recOnPure x\n        (fun x ↦ by simp only [Function.comp_def, traverse_pure, traverse_pure', functor_norm])\n        (fun x y ih1 ih2 ↦ by\n          rw [traverse_mul, ih1, ih2, traverse_mul]\n          simp [Functor.Comp.map_mk, Functor.map_map, Function.comp_def, Comp.seq_mk, seq_map_assoc,\n            map_seq, traverse_mul])\n    naturality := fun η α β f x ↦\n      FreeMagma.recOnPure x\n        (fun x ↦ by simp only [traverse_pure, functor_norm, Function.comp_apply])\n        (fun x y ih1 ih2 ↦ by simp only [traverse_mul, functor_norm, ih1, ih2])\n    traverse_eq_map_id := fun f x ↦\n      FreeMagma.recOnPure x (fun _ ↦ rfl) fun x y ih1 ih2 ↦ by\n        rw [traverse_mul, ih1, ih2, map_mul', mul_map_seq]; rfl }\n\n"}
{"name":"FreeAddMagma.instLawfulTraversable","module":"Mathlib.Algebra.Free","initialProofState":"⊢ LawfulTraversable FreeAddMagma","decl":"@[to_additive]\ninstance : LawfulTraversable FreeMagma.{u} :=\n  { instLawfulMonad with\n    id_traverse := fun x ↦\n      FreeMagma.recOnPure x (fun _ ↦ rfl) fun x y ih1 ih2 ↦ by\n        rw [traverse_mul, ih1, ih2, mul_map_seq]\n    comp_traverse := fun f g x ↦\n      FreeMagma.recOnPure x\n        (fun x ↦ by simp only [Function.comp_def, traverse_pure, traverse_pure', functor_norm])\n        (fun x y ih1 ih2 ↦ by\n          rw [traverse_mul, ih1, ih2, traverse_mul]\n          simp [Functor.Comp.map_mk, Functor.map_map, Function.comp_def, Comp.seq_mk, seq_map_assoc,\n            map_seq, traverse_mul])\n    naturality := fun η α β f x ↦\n      FreeMagma.recOnPure x\n        (fun x ↦ by simp only [traverse_pure, functor_norm, Function.comp_apply])\n        (fun x y ih1 ih2 ↦ by simp only [traverse_mul, functor_norm, ih1, ih2])\n    traverse_eq_map_id := fun f x ↦\n      FreeMagma.recOnPure x (fun _ ↦ rfl) fun x y ih1 ih2 ↦ by\n        rw [traverse_mul, ih1, ih2, map_mul', mul_map_seq]; rfl }\n\n"}
{"name":"FreeAddMagma.length_pos","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nx : FreeAddMagma α\n⊢ LT.lt 0 x.length","decl":"/-- The length of an element of a free magma is positive. -/\n@[to_additive \"The length of an element of a free additive magma is positive.\"]\nlemma FreeMagma.length_pos {α : Type u} (x : FreeMagma α) : 0 < x.length :=\n  match x with\n  | FreeMagma.of _ => Nat.succ_pos 0\n  | mul y z => Nat.add_pos_left (length_pos y) z.length\n\n"}
{"name":"FreeMagma.length_pos","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nx : FreeMagma α\n⊢ LT.lt 0 x.length","decl":"/-- The length of an element of a free magma is positive. -/\n@[to_additive \"The length of an element of a free additive magma is positive.\"]\nlemma FreeMagma.length_pos {α : Type u} (x : FreeMagma α) : 0 < x.length :=\n  match x with\n  | FreeMagma.of _ => Nat.succ_pos 0\n  | mul y z => Nat.add_pos_left (length_pos y) z.length\n\n"}
{"name":"Magma.AssocQuotient.quot_mk_assoc","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\ninst✝ : Mul α\nx y z : α\n⊢ Eq (Quot.mk (Magma.AssocRel α) (HMul.hMul (HMul.hMul x y) z)) (Quot.mk (Magma.AssocRel α) (HMul.hMul x (HMul.hMul y z)))","decl":"@[to_additive]\ntheorem quot_mk_assoc (x y z : α) : Quot.mk (AssocRel α) (x * y * z) = Quot.mk _ (x * (y * z)) :=\n  Quot.sound (AssocRel.intro _ _ _)\n\n"}
{"name":"AddMagma.FreeAddSemigroup.quot_mk_assoc","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\ninst✝ : Add α\nx y z : α\n⊢ Eq (Quot.mk (AddMagma.AssocRel α) (HAdd.hAdd (HAdd.hAdd x y) z)) (Quot.mk (AddMagma.AssocRel α) (HAdd.hAdd x (HAdd.hAdd y z)))","decl":"@[to_additive]\ntheorem quot_mk_assoc (x y z : α) : Quot.mk (AssocRel α) (x * y * z) = Quot.mk _ (x * (y * z)) :=\n  Quot.sound (AssocRel.intro _ _ _)\n\n"}
{"name":"AddMagma.FreeAddSemigroup.quot_mk_assoc_left","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\ninst✝ : Add α\nx y z w : α\n⊢ Eq (Quot.mk (AddMagma.AssocRel α) (HAdd.hAdd x (HAdd.hAdd (HAdd.hAdd y z) w))) (Quot.mk (AddMagma.AssocRel α) (HAdd.hAdd x (HAdd.hAdd y (HAdd.hAdd z w))))","decl":"@[to_additive]\ntheorem quot_mk_assoc_left (x y z w : α) :\n    Quot.mk (AssocRel α) (x * (y * z * w)) = Quot.mk _ (x * (y * (z * w))) :=\n  Quot.sound (AssocRel.left _ _ _ _)\n\n"}
{"name":"Magma.AssocQuotient.quot_mk_assoc_left","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\ninst✝ : Mul α\nx y z w : α\n⊢ Eq (Quot.mk (Magma.AssocRel α) (HMul.hMul x (HMul.hMul (HMul.hMul y z) w))) (Quot.mk (Magma.AssocRel α) (HMul.hMul x (HMul.hMul y (HMul.hMul z w))))","decl":"@[to_additive]\ntheorem quot_mk_assoc_left (x y z w : α) :\n    Quot.mk (AssocRel α) (x * (y * z * w)) = Quot.mk _ (x * (y * (z * w))) :=\n  Quot.sound (AssocRel.left _ _ _ _)\n\n"}
{"name":"AddMagma.FreeAddSemigroup.induction_on","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\ninst✝ : Add α\nC : AddMagma.FreeAddSemigroup α → Prop\nx : AddMagma.FreeAddSemigroup α\nih : ∀ (x : α), C (AddMagma.FreeAddSemigroup.of x)\n⊢ C x","decl":"@[to_additive (attr := elab_as_elim, induction_eliminator)]\nprotected theorem induction_on {C : AssocQuotient α → Prop} (x : AssocQuotient α)\n    (ih : ∀ x, C (of x)) : C x := Quot.induction_on x ih\n\n"}
{"name":"Magma.AssocQuotient.induction_on","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\ninst✝ : Mul α\nC : Magma.AssocQuotient α → Prop\nx : Magma.AssocQuotient α\nih : ∀ (x : α), C (Magma.AssocQuotient.of x)\n⊢ C x","decl":"@[to_additive (attr := elab_as_elim, induction_eliminator)]\nprotected theorem induction_on {C : AssocQuotient α → Prop} (x : AssocQuotient α)\n    (ih : ∀ x, C (of x)) : C x := Quot.induction_on x ih\n\n"}
{"name":"Magma.AssocQuotient.hom_ext_iff","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\ninst✝¹ : Mul α\nβ : Type v\ninst✝ : Semigroup β\nf g : MulHom (Magma.AssocQuotient α) β\n⊢ Iff (Eq f g) (Eq (f.comp Magma.AssocQuotient.of) (g.comp Magma.AssocQuotient.of))","decl":"@[to_additive (attr := ext 1100)]\ntheorem hom_ext {f g : AssocQuotient α →ₙ* β} (h : f.comp of = g.comp of) : f = g :=\n  (DFunLike.ext _ _) fun x => AssocQuotient.induction_on x <| DFunLike.congr_fun h\n\n"}
{"name":"AddMagma.FreeAddSemigroup.hom_ext_iff","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\ninst✝¹ : Add α\nβ : Type v\ninst✝ : AddSemigroup β\nf g : AddHom (AddMagma.FreeAddSemigroup α) β\n⊢ Iff (Eq f g) (Eq (f.comp AddMagma.FreeAddSemigroup.of) (g.comp AddMagma.FreeAddSemigroup.of))","decl":"@[to_additive (attr := ext 1100)]\ntheorem hom_ext {f g : AssocQuotient α →ₙ* β} (h : f.comp of = g.comp of) : f = g :=\n  (DFunLike.ext _ _) fun x => AssocQuotient.induction_on x <| DFunLike.congr_fun h\n\n"}
{"name":"Magma.AssocQuotient.hom_ext","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\ninst✝¹ : Mul α\nβ : Type v\ninst✝ : Semigroup β\nf g : MulHom (Magma.AssocQuotient α) β\nh : Eq (f.comp Magma.AssocQuotient.of) (g.comp Magma.AssocQuotient.of)\n⊢ Eq f g","decl":"@[to_additive (attr := ext 1100)]\ntheorem hom_ext {f g : AssocQuotient α →ₙ* β} (h : f.comp of = g.comp of) : f = g :=\n  (DFunLike.ext _ _) fun x => AssocQuotient.induction_on x <| DFunLike.congr_fun h\n\n"}
{"name":"AddMagma.FreeAddSemigroup.hom_ext","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\ninst✝¹ : Add α\nβ : Type v\ninst✝ : AddSemigroup β\nf g : AddHom (AddMagma.FreeAddSemigroup α) β\nh : Eq (f.comp AddMagma.FreeAddSemigroup.of) (g.comp AddMagma.FreeAddSemigroup.of)\n⊢ Eq f g","decl":"@[to_additive (attr := ext 1100)]\ntheorem hom_ext {f g : AssocQuotient α →ₙ* β} (h : f.comp of = g.comp of) : f = g :=\n  (DFunLike.ext _ _) fun x => AssocQuotient.induction_on x <| DFunLike.congr_fun h\n\n"}
{"name":"Magma.AssocQuotient.lift_symm_apply","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\ninst✝¹ : Mul α\nβ : Type v\ninst✝ : Semigroup β\nf : MulHom (Magma.AssocQuotient α) β\n⊢ Eq (Magma.AssocQuotient.lift.symm f) (f.comp Magma.AssocQuotient.of)","decl":"/-- Lifts a magma homomorphism `α → β` to a semigroup homomorphism `Magma.AssocQuotient α → β`\ngiven a semigroup `β`. -/\n@[to_additive (attr := simps symm_apply) \"Lifts an additive magma homomorphism `α → β` to an\nadditive semigroup homomorphism `AddMagma.AssocQuotient α → β` given an additive semigroup `β`.\"]\ndef lift : (α →ₙ* β) ≃ (AssocQuotient α →ₙ* β) where\n  toFun f :=\n  { toFun := fun x ↦\n      Quot.liftOn x f <| by rintro a b (⟨c, d, e⟩ | ⟨c, d, e, f⟩) <;> simp only [map_mul, mul_assoc]\n    map_mul' := fun x y ↦ Quot.induction_on₂ x y (map_mul f) }\n  invFun f := f.comp of\n  left_inv _ := (DFunLike.ext _ _) fun _ ↦ rfl\n  right_inv _ := hom_ext <| (DFunLike.ext _ _) fun _ ↦ rfl\n\n"}
{"name":"AddMagma.FreeAddSemigroup.lift_symm_apply","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\ninst✝¹ : Add α\nβ : Type v\ninst✝ : AddSemigroup β\nf : AddHom (AddMagma.FreeAddSemigroup α) β\n⊢ Eq (AddMagma.FreeAddSemigroup.lift.symm f) (f.comp AddMagma.FreeAddSemigroup.of)","decl":"/-- Lifts a magma homomorphism `α → β` to a semigroup homomorphism `Magma.AssocQuotient α → β`\ngiven a semigroup `β`. -/\n@[to_additive (attr := simps symm_apply) \"Lifts an additive magma homomorphism `α → β` to an\nadditive semigroup homomorphism `AddMagma.AssocQuotient α → β` given an additive semigroup `β`.\"]\ndef lift : (α →ₙ* β) ≃ (AssocQuotient α →ₙ* β) where\n  toFun f :=\n  { toFun := fun x ↦\n      Quot.liftOn x f <| by rintro a b (⟨c, d, e⟩ | ⟨c, d, e, f⟩) <;> simp only [map_mul, mul_assoc]\n    map_mul' := fun x y ↦ Quot.induction_on₂ x y (map_mul f) }\n  invFun f := f.comp of\n  left_inv _ := (DFunLike.ext _ _) fun _ ↦ rfl\n  right_inv _ := hom_ext <| (DFunLike.ext _ _) fun _ ↦ rfl\n\n"}
{"name":"Magma.AssocQuotient.lift_of","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\ninst✝¹ : Mul α\nβ : Type v\ninst✝ : Semigroup β\nf : MulHom α β\nx : α\n⊢ Eq ((Magma.AssocQuotient.lift f) (Magma.AssocQuotient.of x)) (f x)","decl":"@[to_additive (attr := simp)]\ntheorem lift_of (x : α) : lift f (of x) = f x := rfl\n\n"}
{"name":"AddMagma.FreeAddSemigroup.lift_of","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\ninst✝¹ : Add α\nβ : Type v\ninst✝ : AddSemigroup β\nf : AddHom α β\nx : α\n⊢ Eq ((AddMagma.FreeAddSemigroup.lift f) (AddMagma.FreeAddSemigroup.of x)) (f x)","decl":"@[to_additive (attr := simp)]\ntheorem lift_of (x : α) : lift f (of x) = f x := rfl\n\n"}
{"name":"Magma.AssocQuotient.lift_comp_of","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\ninst✝¹ : Mul α\nβ : Type v\ninst✝ : Semigroup β\nf : MulHom α β\n⊢ Eq ((Magma.AssocQuotient.lift f).comp Magma.AssocQuotient.of) f","decl":"@[to_additive (attr := simp)]\ntheorem lift_comp_of : (lift f).comp of = f := lift.symm_apply_apply f\n\n"}
{"name":"AddMagma.FreeAddSemigroup.lift_comp_of","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\ninst✝¹ : Add α\nβ : Type v\ninst✝ : AddSemigroup β\nf : AddHom α β\n⊢ Eq ((AddMagma.FreeAddSemigroup.lift f).comp AddMagma.FreeAddSemigroup.of) f","decl":"@[to_additive (attr := simp)]\ntheorem lift_comp_of : (lift f).comp of = f := lift.symm_apply_apply f\n\n"}
{"name":"Magma.AssocQuotient.lift_comp_of'","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\ninst✝¹ : Mul α\nβ : Type v\ninst✝ : Semigroup β\nf : MulHom (Magma.AssocQuotient α) β\n⊢ Eq (Magma.AssocQuotient.lift (f.comp Magma.AssocQuotient.of)) f","decl":"@[to_additive (attr := simp)]\ntheorem lift_comp_of' (f : AssocQuotient α →ₙ* β) : lift (f.comp of) = f := lift.apply_symm_apply f\n\n"}
{"name":"AddMagma.FreeAddSemigroup.lift_comp_of'","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\ninst✝¹ : Add α\nβ : Type v\ninst✝ : AddSemigroup β\nf : AddHom (AddMagma.FreeAddSemigroup α) β\n⊢ Eq (AddMagma.FreeAddSemigroup.lift (f.comp AddMagma.FreeAddSemigroup.of)) f","decl":"@[to_additive (attr := simp)]\ntheorem lift_comp_of' (f : AssocQuotient α →ₙ* β) : lift (f.comp of) = f := lift.apply_symm_apply f\n\n"}
{"name":"Magma.AssocQuotient.map_of","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\ninst✝¹ : Mul α\nβ : Type v\ninst✝ : Mul β\nf : MulHom α β\nx : α\n⊢ Eq ((Magma.AssocQuotient.map f) (Magma.AssocQuotient.of x)) (Magma.AssocQuotient.of (f x))","decl":"@[to_additive (attr := simp)]\ntheorem map_of (x) : map f (of x) = of (f x) := rfl\n\n"}
{"name":"AddMagma.FreeAddSemigroup.map_of","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\ninst✝¹ : Add α\nβ : Type v\ninst✝ : Add β\nf : AddHom α β\nx : α\n⊢ Eq ((AddMagma.FreeAddSemigroup.map f) (AddMagma.FreeAddSemigroup.of x)) (AddMagma.FreeAddSemigroup.of (f x))","decl":"@[to_additive (attr := simp)]\ntheorem map_of (x) : map f (of x) = of (f x) := rfl\n\n"}
{"name":"FreeAddSemigroup.mk.injEq","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nhead✝ : α\ntail✝ : List α\nhead : α\ntail : List α\n⊢ Eq (Eq { head := head✝, tail := tail✝ } { head := head, tail := tail }) (And (Eq head✝ head) (Eq tail✝ tail))","decl":"/-- Free additive semigroup over a given alphabet. -/\nstructure FreeAddSemigroup (α : Type u) where\n  /-- The head of the element -/\n  head : α\n  /-- The tail of the element -/\n  tail : List α\n"}
{"name":"FreeAddSemigroup.mk.sizeOf_spec","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\ninst✝ : SizeOf α\nhead : α\ntail : List α\n⊢ Eq (SizeOf.sizeOf { head := head, tail := tail }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf head)) (SizeOf.sizeOf tail))","decl":"/-- Free additive semigroup over a given alphabet. -/\nstructure FreeAddSemigroup (α : Type u) where\n  /-- The head of the element -/\n  head : α\n  /-- The tail of the element -/\n  tail : List α\n"}
{"name":"FreeAddSemigroup.mk.inj","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nhead✝ : α\ntail✝ : List α\nhead : α\ntail : List α\nx✝ : Eq { head := head✝, tail := tail✝ } { head := head, tail := tail }\n⊢ And (Eq head✝ head) (Eq tail✝ tail)","decl":"/-- Free additive semigroup over a given alphabet. -/\nstructure FreeAddSemigroup (α : Type u) where\n  /-- The head of the element -/\n  head : α\n  /-- The tail of the element -/\n  tail : List α\n"}
{"name":"FreeAddSemigroup.ext","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nx y : FreeAddSemigroup α\nhead : Eq x.head y.head\ntail : Eq x.tail y.tail\n⊢ Eq x y","decl":"/-- Free semigroup over a given alphabet. -/\n@[to_additive (attr := ext)]\nstructure FreeSemigroup (α : Type u) where\n  /-- The head of the element -/\n  head : α\n  /-- The tail of the element -/\n  tail : List α\n"}
{"name":"FreeSemigroup.ext_iff","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nx y : FreeSemigroup α\n⊢ Iff (Eq x y) (And (Eq x.head y.head) (Eq x.tail y.tail))","decl":"/-- Free semigroup over a given alphabet. -/\n@[to_additive (attr := ext)]\nstructure FreeSemigroup (α : Type u) where\n  /-- The head of the element -/\n  head : α\n  /-- The tail of the element -/\n  tail : List α\n"}
{"name":"FreeSemigroup.ext","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nx y : FreeSemigroup α\nhead : Eq x.head y.head\ntail : Eq x.tail y.tail\n⊢ Eq x y","decl":"/-- Free semigroup over a given alphabet. -/\n@[to_additive (attr := ext)]\nstructure FreeSemigroup (α : Type u) where\n  /-- The head of the element -/\n  head : α\n  /-- The tail of the element -/\n  tail : List α\n"}
{"name":"FreeSemigroup.mk.injEq","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nhead✝ : α\ntail✝ : List α\nhead : α\ntail : List α\n⊢ Eq (Eq { head := head✝, tail := tail✝ } { head := head, tail := tail }) (And (Eq head✝ head) (Eq tail✝ tail))","decl":"/-- Free semigroup over a given alphabet. -/\n@[to_additive (attr := ext)]\nstructure FreeSemigroup (α : Type u) where\n  /-- The head of the element -/\n  head : α\n  /-- The tail of the element -/\n  tail : List α\n"}
{"name":"FreeSemigroup.mk.sizeOf_spec","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\ninst✝ : SizeOf α\nhead : α\ntail : List α\n⊢ Eq (SizeOf.sizeOf { head := head, tail := tail }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf head)) (SizeOf.sizeOf tail))","decl":"/-- Free semigroup over a given alphabet. -/\n@[to_additive (attr := ext)]\nstructure FreeSemigroup (α : Type u) where\n  /-- The head of the element -/\n  head : α\n  /-- The tail of the element -/\n  tail : List α\n"}
{"name":"FreeSemigroup.mk.inj","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nhead✝ : α\ntail✝ : List α\nhead : α\ntail : List α\nx✝ : Eq { head := head✝, tail := tail✝ } { head := head, tail := tail }\n⊢ And (Eq head✝ head) (Eq tail✝ tail)","decl":"/-- Free semigroup over a given alphabet. -/\n@[to_additive (attr := ext)]\nstructure FreeSemigroup (α : Type u) where\n  /-- The head of the element -/\n  head : α\n  /-- The tail of the element -/\n  tail : List α\n"}
{"name":"FreeAddSemigroup.ext_iff","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nx y : FreeAddSemigroup α\n⊢ Iff (Eq x y) (And (Eq x.head y.head) (Eq x.tail y.tail))","decl":"/-- Free semigroup over a given alphabet. -/\n@[to_additive (attr := ext)]\nstructure FreeSemigroup (α : Type u) where\n  /-- The head of the element -/\n  head : α\n  /-- The tail of the element -/\n  tail : List α\n"}
{"name":"FreeAddSemigroup.head_add","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nx y : FreeAddSemigroup α\n⊢ Eq (HAdd.hAdd x y).head x.head","decl":"@[to_additive (attr := simp)]\ntheorem head_mul (x y : FreeSemigroup α) : (x * y).1 = x.1 := rfl\n\n"}
{"name":"FreeSemigroup.head_mul","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nx y : FreeSemigroup α\n⊢ Eq (HMul.hMul x y).head x.head","decl":"@[to_additive (attr := simp)]\ntheorem head_mul (x y : FreeSemigroup α) : (x * y).1 = x.1 := rfl\n\n"}
{"name":"FreeSemigroup.tail_mul","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nx y : FreeSemigroup α\n⊢ Eq (HMul.hMul x y).tail (HAppend.hAppend x.tail (List.cons y.head y.tail))","decl":"@[to_additive (attr := simp)]\ntheorem tail_mul (x y : FreeSemigroup α) : (x * y).2 = x.2 ++ y.1 :: y.2 := rfl\n\n"}
{"name":"FreeAddSemigroup.tail_add","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nx y : FreeAddSemigroup α\n⊢ Eq (HAdd.hAdd x y).tail (HAppend.hAppend x.tail (List.cons y.head y.tail))","decl":"@[to_additive (attr := simp)]\ntheorem tail_mul (x y : FreeSemigroup α) : (x * y).2 = x.2 ++ y.1 :: y.2 := rfl\n\n"}
{"name":"FreeSemigroup.mk_mul_mk","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nx y : α\nL1 L2 : List α\n⊢ Eq (HMul.hMul { head := x, tail := L1 } { head := y, tail := L2 }) { head := x, tail := HAppend.hAppend L1 (List.cons y L2) }","decl":"@[to_additive (attr := simp)]\ntheorem mk_mul_mk (x y : α) (L1 L2 : List α) : mk x L1 * mk y L2 = mk x (L1 ++ y :: L2) := rfl\n\n"}
{"name":"FreeAddSemigroup.mk_add_mk","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nx y : α\nL1 L2 : List α\n⊢ Eq (HAdd.hAdd { head := x, tail := L1 } { head := y, tail := L2 }) { head := x, tail := HAppend.hAppend L1 (List.cons y L2) }","decl":"@[to_additive (attr := simp)]\ntheorem mk_mul_mk (x y : α) (L1 L2 : List α) : mk x L1 * mk y L2 = mk x (L1 ++ y :: L2) := rfl\n\n"}
{"name":"FreeSemigroup.of_head","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nx : α\n⊢ Eq (FreeSemigroup.of x).head x","decl":"/-- The embedding `α → FreeSemigroup α`. -/\n@[to_additive (attr := simps) \"The embedding `α → FreeAddSemigroup α`.\"]\ndef of (x : α) : FreeSemigroup α := ⟨x, []⟩\n\n"}
{"name":"FreeAddSemigroup.of_tail","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nx : α\n⊢ Eq (FreeAddSemigroup.of x).tail List.nil","decl":"/-- The embedding `α → FreeSemigroup α`. -/\n@[to_additive (attr := simps) \"The embedding `α → FreeAddSemigroup α`.\"]\ndef of (x : α) : FreeSemigroup α := ⟨x, []⟩\n\n"}
{"name":"FreeAddSemigroup.of_head","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nx : α\n⊢ Eq (FreeAddSemigroup.of x).head x","decl":"/-- The embedding `α → FreeSemigroup α`. -/\n@[to_additive (attr := simps) \"The embedding `α → FreeAddSemigroup α`.\"]\ndef of (x : α) : FreeSemigroup α := ⟨x, []⟩\n\n"}
{"name":"FreeSemigroup.of_tail","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nx : α\n⊢ Eq (FreeSemigroup.of x).tail List.nil","decl":"/-- The embedding `α → FreeSemigroup α`. -/\n@[to_additive (attr := simps) \"The embedding `α → FreeAddSemigroup α`.\"]\ndef of (x : α) : FreeSemigroup α := ⟨x, []⟩\n\n"}
{"name":"FreeSemigroup.length_mul","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nx y : FreeSemigroup α\n⊢ Eq (HMul.hMul x y).length (HAdd.hAdd x.length y.length)","decl":"@[to_additive (attr := simp)]\ntheorem length_mul (x y : FreeSemigroup α) : (x * y).length = x.length + y.length := by\n  simp [length, Nat.add_right_comm, List.length, List.length_append]\n\n"}
{"name":"FreeAddSemigroup.length_add","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nx y : FreeAddSemigroup α\n⊢ Eq (HAdd.hAdd x y).length (HAdd.hAdd x.length y.length)","decl":"@[to_additive (attr := simp)]\ntheorem length_mul (x y : FreeSemigroup α) : (x * y).length = x.length + y.length := by\n  simp [length, Nat.add_right_comm, List.length, List.length_append]\n\n"}
{"name":"FreeAddSemigroup.length_of","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nx : α\n⊢ Eq (FreeAddSemigroup.of x).length 1","decl":"@[to_additive (attr := simp)]\ntheorem length_of (x : α) : (of x).length = 1 := rfl\n\n"}
{"name":"FreeSemigroup.length_of","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nx : α\n⊢ Eq (FreeSemigroup.of x).length 1","decl":"@[to_additive (attr := simp)]\ntheorem length_of (x : α) : (of x).length = 1 := rfl\n\n"}
{"name":"FreeAddSemigroup.hom_ext_iff","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Add β\nf g : AddHom (FreeAddSemigroup α) β\n⊢ Iff (Eq f g) (Eq (Function.comp (⇑f) FreeAddSemigroup.of) (Function.comp (⇑g) FreeAddSemigroup.of))","decl":"@[to_additive (attr := ext 1100)]\ntheorem hom_ext {β : Type v} [Mul β] {f g : FreeSemigroup α →ₙ* β} (h : f ∘ of = g ∘ of) : f = g :=\n  (DFunLike.ext _ _) fun x ↦\n    FreeSemigroup.recOnMul x (congr_fun h) fun x y hx hy ↦ by simp only [map_mul, *]\n\n"}
{"name":"FreeSemigroup.hom_ext","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Mul β\nf g : MulHom (FreeSemigroup α) β\nh : Eq (Function.comp (⇑f) FreeSemigroup.of) (Function.comp (⇑g) FreeSemigroup.of)\n⊢ Eq f g","decl":"@[to_additive (attr := ext 1100)]\ntheorem hom_ext {β : Type v} [Mul β] {f g : FreeSemigroup α →ₙ* β} (h : f ∘ of = g ∘ of) : f = g :=\n  (DFunLike.ext _ _) fun x ↦\n    FreeSemigroup.recOnMul x (congr_fun h) fun x y hx hy ↦ by simp only [map_mul, *]\n\n"}
{"name":"FreeSemigroup.hom_ext_iff","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Mul β\nf g : MulHom (FreeSemigroup α) β\n⊢ Iff (Eq f g) (Eq (Function.comp (⇑f) FreeSemigroup.of) (Function.comp (⇑g) FreeSemigroup.of))","decl":"@[to_additive (attr := ext 1100)]\ntheorem hom_ext {β : Type v} [Mul β] {f g : FreeSemigroup α →ₙ* β} (h : f ∘ of = g ∘ of) : f = g :=\n  (DFunLike.ext _ _) fun x ↦\n    FreeSemigroup.recOnMul x (congr_fun h) fun x y hx hy ↦ by simp only [map_mul, *]\n\n"}
{"name":"FreeAddSemigroup.hom_ext","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Add β\nf g : AddHom (FreeAddSemigroup α) β\nh : Eq (Function.comp (⇑f) FreeAddSemigroup.of) (Function.comp (⇑g) FreeAddSemigroup.of)\n⊢ Eq f g","decl":"@[to_additive (attr := ext 1100)]\ntheorem hom_ext {β : Type v} [Mul β] {f g : FreeSemigroup α →ₙ* β} (h : f ∘ of = g ∘ of) : f = g :=\n  (DFunLike.ext _ _) fun x ↦\n    FreeSemigroup.recOnMul x (congr_fun h) fun x y hx hy ↦ by simp only [map_mul, *]\n\n"}
{"name":"FreeAddSemigroup.lift_symm_apply","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\ninst✝ : AddSemigroup β\nf : AddHom (FreeAddSemigroup α) β\na✝ : α\n⊢ Eq (FreeAddSemigroup.lift.symm f a✝) (Function.comp (⇑f) FreeAddSemigroup.of a✝)","decl":"/-- Lifts a function `α → β` to a semigroup homomorphism `FreeSemigroup α → β` given\na semigroup `β`. -/\n@[to_additive (attr := simps symm_apply) \"Lifts a function `α → β` to an additive semigroup\nhomomorphism `FreeAddSemigroup α → β` given an additive semigroup `β`.\"]\ndef lift : (α → β) ≃ (FreeSemigroup α →ₙ* β) where\n  toFun f :=\n    { toFun := fun x ↦ x.2.foldl (fun a b ↦ a * f b) (f x.1)\n      map_mul' := fun x y ↦ by\n        simp [head_mul, tail_mul, ← List.foldl_map, List.foldl_append, List.foldl_cons,\n          List.foldl_assoc] }\n  invFun f := f ∘ of\n  left_inv _ := rfl\n  right_inv _ := hom_ext rfl\n\n"}
{"name":"FreeSemigroup.lift_symm_apply","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Semigroup β\nf : MulHom (FreeSemigroup α) β\na✝ : α\n⊢ Eq (FreeSemigroup.lift.symm f a✝) (Function.comp (⇑f) FreeSemigroup.of a✝)","decl":"/-- Lifts a function `α → β` to a semigroup homomorphism `FreeSemigroup α → β` given\na semigroup `β`. -/\n@[to_additive (attr := simps symm_apply) \"Lifts a function `α → β` to an additive semigroup\nhomomorphism `FreeAddSemigroup α → β` given an additive semigroup `β`.\"]\ndef lift : (α → β) ≃ (FreeSemigroup α →ₙ* β) where\n  toFun f :=\n    { toFun := fun x ↦ x.2.foldl (fun a b ↦ a * f b) (f x.1)\n      map_mul' := fun x y ↦ by\n        simp [head_mul, tail_mul, ← List.foldl_map, List.foldl_append, List.foldl_cons,\n          List.foldl_assoc] }\n  invFun f := f ∘ of\n  left_inv _ := rfl\n  right_inv _ := hom_ext rfl\n\n"}
{"name":"FreeSemigroup.lift_of","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Semigroup β\nf : α → β\nx : α\n⊢ Eq ((FreeSemigroup.lift f) (FreeSemigroup.of x)) (f x)","decl":"@[to_additive (attr := simp)]\ntheorem lift_of (x : α) : lift f (of x) = f x := rfl\n\n"}
{"name":"FreeAddSemigroup.lift_of","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\ninst✝ : AddSemigroup β\nf : α → β\nx : α\n⊢ Eq ((FreeAddSemigroup.lift f) (FreeAddSemigroup.of x)) (f x)","decl":"@[to_additive (attr := simp)]\ntheorem lift_of (x : α) : lift f (of x) = f x := rfl\n\n"}
{"name":"FreeAddSemigroup.lift_comp_of","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\ninst✝ : AddSemigroup β\nf : α → β\n⊢ Eq (Function.comp (⇑(FreeAddSemigroup.lift f)) FreeAddSemigroup.of) f","decl":"@[to_additive (attr := simp)]\ntheorem lift_comp_of : lift f ∘ of = f := rfl\n\n"}
{"name":"FreeSemigroup.lift_comp_of","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Semigroup β\nf : α → β\n⊢ Eq (Function.comp (⇑(FreeSemigroup.lift f)) FreeSemigroup.of) f","decl":"@[to_additive (attr := simp)]\ntheorem lift_comp_of : lift f ∘ of = f := rfl\n\n"}
{"name":"FreeSemigroup.lift_comp_of'","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Semigroup β\nf : MulHom (FreeSemigroup α) β\n⊢ Eq (FreeSemigroup.lift (Function.comp (⇑f) FreeSemigroup.of)) f","decl":"@[to_additive (attr := simp)]\ntheorem lift_comp_of' (f : FreeSemigroup α →ₙ* β) : lift (f ∘ of) = f := hom_ext rfl\n\n"}
{"name":"FreeAddSemigroup.lift_comp_of'","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\ninst✝ : AddSemigroup β\nf : AddHom (FreeAddSemigroup α) β\n⊢ Eq (FreeAddSemigroup.lift (Function.comp (⇑f) FreeAddSemigroup.of)) f","decl":"@[to_additive (attr := simp)]\ntheorem lift_comp_of' (f : FreeSemigroup α →ₙ* β) : lift (f ∘ of) = f := hom_ext rfl\n\n"}
{"name":"FreeAddSemigroup.lift_of_add","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\ninst✝ : AddSemigroup β\nf : α → β\nx : α\ny : FreeAddSemigroup α\n⊢ Eq ((FreeAddSemigroup.lift f) (HAdd.hAdd (FreeAddSemigroup.of x) y)) (HAdd.hAdd (f x) ((FreeAddSemigroup.lift f) y))","decl":"@[to_additive]\ntheorem lift_of_mul (x y) : lift f (of x * y) = f x * lift f y := by rw [map_mul, lift_of]\n\n"}
{"name":"FreeSemigroup.lift_of_mul","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Semigroup β\nf : α → β\nx : α\ny : FreeSemigroup α\n⊢ Eq ((FreeSemigroup.lift f) (HMul.hMul (FreeSemigroup.of x) y)) (HMul.hMul (f x) ((FreeSemigroup.lift f) y))","decl":"@[to_additive]\ntheorem lift_of_mul (x y) : lift f (of x * y) = f x * lift f y := by rw [map_mul, lift_of]\n\n"}
{"name":"FreeSemigroup.map_of","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nx : α\n⊢ Eq ((FreeSemigroup.map f) (FreeSemigroup.of x)) (FreeSemigroup.of (f x))","decl":"@[to_additive (attr := simp)]\ntheorem map_of (x) : map f (of x) = of (f x) := rfl\n\n"}
{"name":"FreeAddSemigroup.map_of","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nx : α\n⊢ Eq ((FreeAddSemigroup.map f) (FreeAddSemigroup.of x)) (FreeAddSemigroup.of (f x))","decl":"@[to_additive (attr := simp)]\ntheorem map_of (x) : map f (of x) = of (f x) := rfl\n\n"}
{"name":"FreeSemigroup.length_map","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nx : FreeSemigroup α\n⊢ Eq ((FreeSemigroup.map f) x).length x.length","decl":"@[to_additive (attr := simp)]\ntheorem length_map (x) : (map f x).length = x.length :=\n  FreeSemigroup.recOnMul x (fun _ ↦ rfl) (fun x y hx hy ↦ by simp only [map_mul, length_mul, *])\n\n"}
{"name":"FreeAddSemigroup.length_map","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nx : FreeAddSemigroup α\n⊢ Eq ((FreeAddSemigroup.map f) x).length x.length","decl":"@[to_additive (attr := simp)]\ntheorem length_map (x) : (map f x).length = x.length :=\n  FreeSemigroup.recOnMul x (fun _ ↦ rfl) (fun x y hx hy ↦ by simp only [map_mul, length_mul, *])\n\n"}
{"name":"FreeSemigroup.map_pure","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nf : α → β\nx : α\n⊢ Eq (Functor.map f (Pure.pure x)) (Pure.pure (f x))","decl":"@[to_additive (attr := simp)]\ntheorem map_pure (f : α → β) (x) : (f <$> pure x : FreeSemigroup β) = pure (f x) := rfl\n\n"}
{"name":"FreeAddSemigroup.map_pure","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nf : α → β\nx : α\n⊢ Eq (Functor.map f (Pure.pure x)) (Pure.pure (f x))","decl":"@[to_additive (attr := simp)]\ntheorem map_pure (f : α → β) (x) : (f <$> pure x : FreeSemigroup β) = pure (f x) := rfl\n\n"}
{"name":"FreeAddSemigroup.map_add'","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nf : α → β\nx y : FreeAddSemigroup α\n⊢ Eq (Functor.map f (HAdd.hAdd x y)) (HAdd.hAdd (Functor.map f x) (Functor.map f y))","decl":"@[to_additive (attr := simp)]\ntheorem map_mul' (f : α → β) (x y : FreeSemigroup α) : f <$> (x * y) = f <$> x * f <$> y :=\n  map_mul (map f) _ _\n\n"}
{"name":"FreeSemigroup.map_mul'","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nf : α → β\nx y : FreeSemigroup α\n⊢ Eq (Functor.map f (HMul.hMul x y)) (HMul.hMul (Functor.map f x) (Functor.map f y))","decl":"@[to_additive (attr := simp)]\ntheorem map_mul' (f : α → β) (x y : FreeSemigroup α) : f <$> (x * y) = f <$> x * f <$> y :=\n  map_mul (map f) _ _\n\n"}
{"name":"FreeAddSemigroup.pure_bind","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nf : α → FreeAddSemigroup β\nx : α\n⊢ Eq (Bind.bind (Pure.pure x) f) (f x)","decl":"@[to_additive (attr := simp)]\ntheorem pure_bind (f : α → FreeSemigroup β) (x) : pure x >>= f = f x := rfl\n\n"}
{"name":"FreeSemigroup.pure_bind","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nf : α → FreeSemigroup β\nx : α\n⊢ Eq (Bind.bind (Pure.pure x) f) (f x)","decl":"@[to_additive (attr := simp)]\ntheorem pure_bind (f : α → FreeSemigroup β) (x) : pure x >>= f = f x := rfl\n\n"}
{"name":"FreeAddSemigroup.add_bind","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nf : α → FreeAddSemigroup β\nx y : FreeAddSemigroup α\n⊢ Eq (Bind.bind (HAdd.hAdd x y) f) (HAdd.hAdd (Bind.bind x f) (Bind.bind y f))","decl":"@[to_additive (attr := simp)]\ntheorem mul_bind (f : α → FreeSemigroup β) (x y : FreeSemigroup α) :\n    x * y >>= f = (x >>= f) * (y >>= f) := map_mul (lift f) _ _\n\n"}
{"name":"FreeSemigroup.mul_bind","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nf : α → FreeSemigroup β\nx y : FreeSemigroup α\n⊢ Eq (Bind.bind (HMul.hMul x y) f) (HMul.hMul (Bind.bind x f) (Bind.bind y f))","decl":"@[to_additive (attr := simp)]\ntheorem mul_bind (f : α → FreeSemigroup β) (x y : FreeSemigroup α) :\n    x * y >>= f = (x >>= f) * (y >>= f) := map_mul (lift f) _ _\n\n"}
{"name":"FreeAddSemigroup.pure_seq","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nf : α → β\nx : FreeAddSemigroup α\n⊢ Eq (Seq.seq (Pure.pure f) fun x_1 => x) (Functor.map f x)","decl":"@[to_additive (attr := simp)]\ntheorem pure_seq {f : α → β} {x : FreeSemigroup α} : pure f <*> x = f <$> x := rfl\n\n"}
{"name":"FreeSemigroup.pure_seq","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nf : α → β\nx : FreeSemigroup α\n⊢ Eq (Seq.seq (Pure.pure f) fun x_1 => x) (Functor.map f x)","decl":"@[to_additive (attr := simp)]\ntheorem pure_seq {f : α → β} {x : FreeSemigroup α} : pure f <*> x = f <$> x := rfl\n\n"}
{"name":"FreeAddSemigroup.add_seq","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nf g : FreeAddSemigroup (α → β)\nx : FreeAddSemigroup α\n⊢ Eq (Seq.seq (HAdd.hAdd f g) fun x_1 => x) (HAdd.hAdd (Seq.seq f fun x_1 => x) (Seq.seq g fun x_1 => x))","decl":"@[to_additive (attr := simp)]\ntheorem mul_seq {f g : FreeSemigroup (α → β)} {x : FreeSemigroup α} :\n    f * g <*> x = (f <*> x) * (g <*> x) := mul_bind _ _ _\n\n"}
{"name":"FreeSemigroup.mul_seq","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nf g : FreeSemigroup (α → β)\nx : FreeSemigroup α\n⊢ Eq (Seq.seq (HMul.hMul f g) fun x_1 => x) (HMul.hMul (Seq.seq f fun x_1 => x) (Seq.seq g fun x_1 => x))","decl":"@[to_additive (attr := simp)]\ntheorem mul_seq {f g : FreeSemigroup (α → β)} {x : FreeSemigroup α} :\n    f * g <*> x = (f <*> x) * (g <*> x) := mul_bind _ _ _\n\n"}
{"name":"FreeAddSemigroup.instLawfulMonad","module":"Mathlib.Algebra.Free","initialProofState":"⊢ LawfulMonad FreeAddSemigroup","decl":"@[to_additive]\ninstance instLawfulMonad : LawfulMonad FreeSemigroup.{u} := LawfulMonad.mk'\n  (pure_bind := fun _ _ ↦ rfl)\n  (bind_assoc := fun x g f ↦\n    recOnPure x (fun _ ↦ rfl) fun x y ih1 ih2 ↦ by rw [mul_bind, mul_bind, mul_bind, ih1, ih2])\n  (id_map := fun x ↦ recOnPure x (fun _ ↦ rfl) fun x y ih1 ih2 ↦ by rw [map_mul', ih1, ih2])\n\n"}
{"name":"FreeSemigroup.instLawfulMonad","module":"Mathlib.Algebra.Free","initialProofState":"⊢ LawfulMonad FreeSemigroup","decl":"@[to_additive]\ninstance instLawfulMonad : LawfulMonad FreeSemigroup.{u} := LawfulMonad.mk'\n  (pure_bind := fun _ _ ↦ rfl)\n  (bind_assoc := fun x g f ↦\n    recOnPure x (fun _ ↦ rfl) fun x y ih1 ih2 ↦ by rw [mul_bind, mul_bind, mul_bind, ih1, ih2])\n  (id_map := fun x ↦ recOnPure x (fun _ ↦ rfl) fun x y ih1 ih2 ↦ by rw [map_mul', ih1, ih2])\n\n"}
{"name":"FreeSemigroup.traverse_pure","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nm : Type u → Type u\ninst✝ : Applicative m\nF : α → m β\nx : α\n⊢ Eq (Traversable.traverse F (Pure.pure x)) (Functor.map Pure.pure (F x))","decl":"@[to_additive (attr := simp)]\ntheorem traverse_pure (x) : traverse F (pure x : FreeSemigroup α) = pure <$> F x := rfl\n\n"}
{"name":"FreeAddSemigroup.traverse_pure","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nm : Type u → Type u\ninst✝ : Applicative m\nF : α → m β\nx : α\n⊢ Eq (Traversable.traverse F (Pure.pure x)) (Functor.map Pure.pure (F x))","decl":"@[to_additive (attr := simp)]\ntheorem traverse_pure (x) : traverse F (pure x : FreeSemigroup α) = pure <$> F x := rfl\n\n"}
{"name":"FreeAddSemigroup.traverse_pure'","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nm : Type u → Type u\ninst✝ : Applicative m\nF : α → m β\n⊢ Eq (Function.comp (Traversable.traverse F) Pure.pure) fun x => Functor.map Pure.pure (F x)","decl":"@[to_additive (attr := simp)]\ntheorem traverse_pure' : traverse F ∘ pure = fun x ↦ (pure <$> F x : m (FreeSemigroup β)) := rfl\n\n"}
{"name":"FreeSemigroup.traverse_pure'","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nm : Type u → Type u\ninst✝ : Applicative m\nF : α → m β\n⊢ Eq (Function.comp (Traversable.traverse F) Pure.pure) fun x => Functor.map Pure.pure (F x)","decl":"@[to_additive (attr := simp)]\ntheorem traverse_pure' : traverse F ∘ pure = fun x ↦ (pure <$> F x : m (FreeSemigroup β)) := rfl\n\n"}
{"name":"FreeSemigroup.traverse_mul","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nm : Type u → Type u\ninst✝¹ : Applicative m\nF : α → m β\ninst✝ : LawfulApplicative m\nx y : FreeSemigroup α\n⊢ Eq (Traversable.traverse F (HMul.hMul x y)) (Seq.seq (Functor.map (fun x1 x2 => HMul.hMul x1 x2) (Traversable.traverse F x)) fun x => Traversable.traverse F y)","decl":"@[to_additive (attr := simp)]\ntheorem traverse_mul (x y : FreeSemigroup α) :\n    traverse F (x * y) = (· * ·) <$> traverse F x <*> traverse F y :=\n  let ⟨x, L1⟩ := x\n  let ⟨y, L2⟩ := y\n  List.recOn L1 (fun _ ↦ rfl)\n    (fun hd tl ih x ↦ show\n        (· * ·) <$> pure <$> F x <*> traverse F (mk hd tl * mk y L2) =\n          (· * ·) <$> ((· * ·) <$> pure <$> F x <*> traverse F (mk hd tl)) <*> traverse F (mk y L2)\n        by rw [ih]; simp only [Function.comp_def, (mul_assoc _ _ _).symm, functor_norm])\n    x\n\n"}
{"name":"FreeAddSemigroup.traverse_add","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nm : Type u → Type u\ninst✝¹ : Applicative m\nF : α → m β\ninst✝ : LawfulApplicative m\nx y : FreeAddSemigroup α\n⊢ Eq (Traversable.traverse F (HAdd.hAdd x y)) (Seq.seq (Functor.map (fun x1 x2 => HAdd.hAdd x1 x2) (Traversable.traverse F x)) fun x => Traversable.traverse F y)","decl":"@[to_additive (attr := simp)]\ntheorem traverse_mul (x y : FreeSemigroup α) :\n    traverse F (x * y) = (· * ·) <$> traverse F x <*> traverse F y :=\n  let ⟨x, L1⟩ := x\n  let ⟨y, L2⟩ := y\n  List.recOn L1 (fun _ ↦ rfl)\n    (fun hd tl ih x ↦ show\n        (· * ·) <$> pure <$> F x <*> traverse F (mk hd tl * mk y L2) =\n          (· * ·) <$> ((· * ·) <$> pure <$> F x <*> traverse F (mk hd tl)) <*> traverse F (mk y L2)\n        by rw [ih]; simp only [Function.comp_def, (mul_assoc _ _ _).symm, functor_norm])\n    x\n\n"}
{"name":"FreeSemigroup.traverse_mul'","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nm : Type u → Type u\ninst✝¹ : Applicative m\nF : α → m β\ninst✝ : LawfulApplicative m\n⊢ Eq (Function.comp (Function.comp (Traversable.traverse F)) HMul.hMul) fun x y => Seq.seq (Functor.map (fun x1 x2 => HMul.hMul x1 x2) (Traversable.traverse F x)) fun x => Traversable.traverse F y","decl":"@[to_additive (attr := simp)]\ntheorem traverse_mul' :\n    Function.comp (traverse F) ∘ (HMul.hMul : FreeSemigroup α → FreeSemigroup α → FreeSemigroup α) =\n      fun x y ↦ (· * ·) <$> traverse F x <*> traverse F y :=\n  funext fun x ↦ funext fun y ↦ traverse_mul F x y\n\n"}
{"name":"FreeAddSemigroup.traverse_add'","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nm : Type u → Type u\ninst✝¹ : Applicative m\nF : α → m β\ninst✝ : LawfulApplicative m\n⊢ Eq (Function.comp (Function.comp (Traversable.traverse F)) HAdd.hAdd) fun x y => Seq.seq (Functor.map (fun x1 x2 => HAdd.hAdd x1 x2) (Traversable.traverse F x)) fun x => Traversable.traverse F y","decl":"@[to_additive (attr := simp)]\ntheorem traverse_mul' :\n    Function.comp (traverse F) ∘ (HMul.hMul : FreeSemigroup α → FreeSemigroup α → FreeSemigroup α) =\n      fun x y ↦ (· * ·) <$> traverse F x <*> traverse F y :=\n  funext fun x ↦ funext fun y ↦ traverse_mul F x y\n\n"}
{"name":"FreeAddSemigroup.traverse_eq","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nm : Type u → Type u\ninst✝ : Applicative m\nF : α → m β\nx : FreeAddSemigroup α\n⊢ Eq (FreeAddSemigroup.traverse F x) (Traversable.traverse F x)","decl":"@[to_additive (attr := simp)]\ntheorem traverse_eq (x) : FreeSemigroup.traverse F x = traverse F x := rfl\n\n-- This is not a simp lemma because the left-hand side is not in simp normal form.\n"}
{"name":"FreeSemigroup.traverse_eq","module":"Mathlib.Algebra.Free","initialProofState":"α β : Type u\nm : Type u → Type u\ninst✝ : Applicative m\nF : α → m β\nx : FreeSemigroup α\n⊢ Eq (FreeSemigroup.traverse F x) (Traversable.traverse F x)","decl":"@[to_additive (attr := simp)]\ntheorem traverse_eq (x) : FreeSemigroup.traverse F x = traverse F x := rfl\n\n-- This is not a simp lemma because the left-hand side is not in simp normal form.\n"}
{"name":"FreeSemigroup.mul_map_seq","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nx y : FreeSemigroup α\n⊢ Eq (Seq.seq (Functor.map (fun x1 x2 => HMul.hMul x1 x2) x) fun x => y) (HMul.hMul x y)","decl":"@[to_additive]\ntheorem mul_map_seq (x y : FreeSemigroup α) :\n    ((· * ·) <$> x <*> y : Id (FreeSemigroup α)) = (x * y : FreeSemigroup α) := rfl\n\n"}
{"name":"FreeAddSemigroup.add_map_seq","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nx y : FreeAddSemigroup α\n⊢ Eq (Seq.seq (Functor.map (fun x1 x2 => HAdd.hAdd x1 x2) x) fun x => y) (HAdd.hAdd x y)","decl":"@[to_additive]\ntheorem mul_map_seq (x y : FreeSemigroup α) :\n    ((· * ·) <$> x <*> y : Id (FreeSemigroup α)) = (x * y : FreeSemigroup α) := rfl\n\n"}
{"name":"FreeAddSemigroup.instLawfulTraversable","module":"Mathlib.Algebra.Free","initialProofState":"⊢ LawfulTraversable FreeAddSemigroup","decl":"@[to_additive]\ninstance : LawfulTraversable FreeSemigroup.{u} :=\n  { instLawfulMonad with\n    id_traverse := fun x ↦\n      FreeSemigroup.recOnMul x (fun _ ↦ rfl) fun x y ih1 ih2 ↦ by\n        rw [traverse_mul, ih1, ih2, mul_map_seq]\n    comp_traverse := fun f g x ↦\n      recOnPure x (fun x ↦ by simp only [traverse_pure, functor_norm, Function.comp_def])\n        fun x y ih1 ih2 ↦ by\n          rw [traverse_mul, ih1, ih2, traverse_mul, Functor.Comp.map_mk]\n          simp only [Function.comp_def, functor_norm, traverse_mul]\n    naturality := fun η α β f x ↦\n      recOnPure x (fun x ↦ by simp only [traverse_pure, functor_norm, Function.comp])\n          (fun x y ih1 ih2 ↦ by simp only [traverse_mul, functor_norm, ih1, ih2])\n    traverse_eq_map_id := fun f x ↦\n      FreeSemigroup.recOnMul x (fun _ ↦ rfl) fun x y ih1 ih2 ↦ by\n        rw [traverse_mul, ih1, ih2, map_mul', mul_map_seq]; rfl }\n\n"}
{"name":"FreeSemigroup.instLawfulTraversable","module":"Mathlib.Algebra.Free","initialProofState":"⊢ LawfulTraversable FreeSemigroup","decl":"@[to_additive]\ninstance : LawfulTraversable FreeSemigroup.{u} :=\n  { instLawfulMonad with\n    id_traverse := fun x ↦\n      FreeSemigroup.recOnMul x (fun _ ↦ rfl) fun x y ih1 ih2 ↦ by\n        rw [traverse_mul, ih1, ih2, mul_map_seq]\n    comp_traverse := fun f g x ↦\n      recOnPure x (fun x ↦ by simp only [traverse_pure, functor_norm, Function.comp_def])\n        fun x y ih1 ih2 ↦ by\n          rw [traverse_mul, ih1, ih2, traverse_mul, Functor.Comp.map_mk]\n          simp only [Function.comp_def, functor_norm, traverse_mul]\n    naturality := fun η α β f x ↦\n      recOnPure x (fun x ↦ by simp only [traverse_pure, functor_norm, Function.comp])\n          (fun x y ih1 ih2 ↦ by simp only [traverse_mul, functor_norm, ih1, ih2])\n    traverse_eq_map_id := fun f x ↦\n      FreeSemigroup.recOnMul x (fun _ ↦ rfl) fun x y ih1 ih2 ↦ by\n        rw [traverse_mul, ih1, ih2, map_mul', mul_map_seq]; rfl }\n\n"}
{"name":"FreeAddMagma.toFreeAddSemigroup_of","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nx : α\n⊢ Eq (FreeAddMagma.toFreeAddSemigroup (FreeAddMagma.of x)) (FreeAddSemigroup.of x)","decl":"@[to_additive (attr := simp)]\ntheorem toFreeSemigroup_of (x : α) : toFreeSemigroup (of x) = FreeSemigroup.of x := rfl\n\n"}
{"name":"FreeMagma.toFreeSemigroup_of","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nx : α\n⊢ Eq (FreeMagma.toFreeSemigroup (FreeMagma.of x)) (FreeSemigroup.of x)","decl":"@[to_additive (attr := simp)]\ntheorem toFreeSemigroup_of (x : α) : toFreeSemigroup (of x) = FreeSemigroup.of x := rfl\n\n"}
{"name":"FreeMagma.toFreeSemigroup_comp_of","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\n⊢ Eq (Function.comp (⇑FreeMagma.toFreeSemigroup) FreeMagma.of) FreeSemigroup.of","decl":"@[to_additive (attr := simp)]\ntheorem toFreeSemigroup_comp_of : @toFreeSemigroup α ∘ of = FreeSemigroup.of := rfl\n\n"}
{"name":"FreeAddMagma.toFreeAddSemigroup_comp_of","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\n⊢ Eq (Function.comp (⇑FreeAddMagma.toFreeAddSemigroup) FreeAddMagma.of) FreeAddSemigroup.of","decl":"@[to_additive (attr := simp)]\ntheorem toFreeSemigroup_comp_of : @toFreeSemigroup α ∘ of = FreeSemigroup.of := rfl\n\n"}
{"name":"FreeAddMagma.toFreeAddSemigroup_comp_map","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\nf : α → β\n⊢ Eq (FreeAddMagma.toFreeAddSemigroup.comp (FreeAddMagma.map f)) ((FreeAddSemigroup.map f).comp FreeAddMagma.toFreeAddSemigroup)","decl":"@[to_additive]\ntheorem toFreeSemigroup_comp_map (f : α → β) :\n    toFreeSemigroup.comp (map f) = (FreeSemigroup.map f).comp toFreeSemigroup := by ext1; rfl\n\n"}
{"name":"FreeMagma.toFreeSemigroup_comp_map","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\nf : α → β\n⊢ Eq (FreeMagma.toFreeSemigroup.comp (FreeMagma.map f)) ((FreeSemigroup.map f).comp FreeMagma.toFreeSemigroup)","decl":"@[to_additive]\ntheorem toFreeSemigroup_comp_map (f : α → β) :\n    toFreeSemigroup.comp (map f) = (FreeSemigroup.map f).comp toFreeSemigroup := by ext1; rfl\n\n"}
{"name":"FreeAddMagma.toFreeAddSemigroup_map","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nx : FreeAddMagma α\n⊢ Eq (FreeAddMagma.toFreeAddSemigroup ((FreeAddMagma.map f) x)) ((FreeAddSemigroup.map f) (FreeAddMagma.toFreeAddSemigroup x))","decl":"@[to_additive]\ntheorem toFreeSemigroup_map (f : α → β) (x : FreeMagma α) :\n    toFreeSemigroup (map f x) = FreeSemigroup.map f (toFreeSemigroup x) :=\n  DFunLike.congr_fun (toFreeSemigroup_comp_map f) x\n\n"}
{"name":"FreeMagma.toFreeSemigroup_map","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nx : FreeMagma α\n⊢ Eq (FreeMagma.toFreeSemigroup ((FreeMagma.map f) x)) ((FreeSemigroup.map f) (FreeMagma.toFreeSemigroup x))","decl":"@[to_additive]\ntheorem toFreeSemigroup_map (f : α → β) (x : FreeMagma α) :\n    toFreeSemigroup (map f x) = FreeSemigroup.map f (toFreeSemigroup x) :=\n  DFunLike.congr_fun (toFreeSemigroup_comp_map f) x\n\n"}
{"name":"FreeMagma.length_toFreeSemigroup","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nx : FreeMagma α\n⊢ Eq (FreeMagma.toFreeSemigroup x).length x.length","decl":"@[to_additive (attr := simp)]\ntheorem length_toFreeSemigroup (x : FreeMagma α) : (toFreeSemigroup x).length = x.length :=\n  FreeMagma.recOnMul x (fun _ ↦ rfl) fun x y hx hy ↦ by\n    rw [map_mul, FreeSemigroup.length_mul, hx, hy]; rfl\n\n"}
{"name":"FreeAddMagma.length_toFreeAddSemigroup","module":"Mathlib.Algebra.Free","initialProofState":"α : Type u\nx : FreeAddMagma α\n⊢ Eq (FreeAddMagma.toFreeAddSemigroup x).length x.length","decl":"@[to_additive (attr := simp)]\ntheorem length_toFreeSemigroup (x : FreeMagma α) : (toFreeSemigroup x).length = x.length :=\n  FreeMagma.recOnMul x (fun _ ↦ rfl) fun x y hx hy ↦ by\n    rw [map_mul, FreeSemigroup.length_mul, hx, hy]; rfl\n\n"}
