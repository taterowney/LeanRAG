{"name":"TrivSqZeroExt.isNilpotent_iff_isNilpotent_fst","module":"Mathlib.RingTheory.DualNumber","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module (MulOpposite R) M\ninst✝ : SMulCommClass R (MulOpposite R) M\nx : TrivSqZeroExt R M\n⊢ Iff (IsNilpotent x) (IsNilpotent x.fst)","decl":"lemma isNilpotent_iff_isNilpotent_fst {x : TrivSqZeroExt R M} :\n    IsNilpotent x ↔ IsNilpotent x.fst := by\n  constructor <;> rintro ⟨n, hn⟩\n  · refine ⟨n, ?_⟩\n    rw [← fst_pow, hn, fst_zero]\n  · refine ⟨n * 2, ?_⟩\n    rw [pow_mul]\n    ext\n    · rw [fst_pow, fst_pow, hn, zero_pow two_ne_zero, fst_zero]\n    · rw [pow_two, snd_mul, fst_pow, hn, MulOpposite.op_zero, zero_smul, zero_smul, zero_add,\n        snd_zero]\n\n"}
{"name":"TrivSqZeroExt.isNilpotent_inl_iff","module":"Mathlib.RingTheory.DualNumber","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module (MulOpposite R) M\ninst✝ : SMulCommClass R (MulOpposite R) M\nr : R\n⊢ Iff (IsNilpotent (TrivSqZeroExt.inl r)) (IsNilpotent r)","decl":"@[simp]\nlemma isNilpotent_inl_iff (r : R) : IsNilpotent (.inl r : TrivSqZeroExt R M) ↔ IsNilpotent r := by\n  rw [isNilpotent_iff_isNilpotent_fst, fst_inl]\n\n"}
{"name":"TrivSqZeroExt.isNilpotent_inr","module":"Mathlib.RingTheory.DualNumber","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module (MulOpposite R) M\ninst✝ : SMulCommClass R (MulOpposite R) M\nx : M\n⊢ IsNilpotent (TrivSqZeroExt.inr x)","decl":"@[simp]\nlemma isNilpotent_inr (x : M) : IsNilpotent (.inr x : TrivSqZeroExt R M) := by\n  refine ⟨2, by simp [pow_two]⟩\n\n"}
{"name":"TrivSqZeroExt.isUnit_or_isNilpotent_of_isMaximal_isNilpotent","module":"Mathlib.RingTheory.DualNumber","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module (MulOpposite R) M\ninst✝ : IsCentralScalar R M\nh : ∀ (I : Ideal R), I.IsMaximal → IsNilpotent I\na : TrivSqZeroExt R M\n⊢ Or (IsUnit a) (IsNilpotent a)","decl":"lemma isUnit_or_isNilpotent_of_isMaximal_isNilpotent [CommSemiring R] [AddCommGroup M]\n    [Module R M] [Module Rᵐᵒᵖ M] [IsCentralScalar R M]\n    (h : ∀ I : Ideal R, I.IsMaximal → IsNilpotent I)\n    (a : TrivSqZeroExt R M) :\n    IsUnit a ∨ IsNilpotent a := by\n  rw [isUnit_iff_isUnit_fst, isNilpotent_iff_isNilpotent_fst]\n  refine (em _).imp_right fun ha ↦ ?_\n  obtain ⟨I, hI, haI⟩ := exists_max_ideal_of_mem_nonunits (mem_nonunits_iff.mpr ha)\n  refine (h _ hI).imp fun n hn ↦ ?_\n  exact hn.le (Ideal.pow_mem_pow haI _)\n\n"}
{"name":"TrivSqZeroExt.isUnit_or_isNilpotent","module":"Mathlib.RingTheory.DualNumber","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : DivisionSemiring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module (MulOpposite R) M\ninst✝ : SMulCommClass R (MulOpposite R) M\na : TrivSqZeroExt R M\n⊢ Or (IsUnit a) (IsNilpotent a)","decl":"lemma isUnit_or_isNilpotent [DivisionSemiring R] [AddCommGroup M]\n    [Module R M] [Module Rᵐᵒᵖ M] [SMulCommClass R Rᵐᵒᵖ M]\n    (a : TrivSqZeroExt R M) :\n    IsUnit a ∨ IsNilpotent a := by\n  simp [isUnit_iff_isUnit_fst, isNilpotent_iff_isNilpotent_fst, em']\n\n"}
{"name":"DualNumber.fst_eq_zero_iff_eps_dvd","module":"Mathlib.RingTheory.DualNumber","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nx : DualNumber R\n⊢ Iff (Eq (TrivSqZeroExt.fst x) 0) (Dvd.dvd DualNumber.eps x)","decl":"lemma fst_eq_zero_iff_eps_dvd [Semiring R] {x : R[ε]} :\n    x.fst = 0 ↔ ε ∣ x := by\n  simp_rw [dvd_def, TrivSqZeroExt.ext_iff, TrivSqZeroExt.fst_mul, TrivSqZeroExt.snd_mul,\n    fst_eps, snd_eps, zero_mul, zero_smul, zero_add, MulOpposite.smul_eq_mul_unop,\n    MulOpposite.unop_op, one_mul, exists_and_left, iff_self_and]\n  intro\n  exact ⟨.inl x.snd, rfl⟩\n\n"}
{"name":"DualNumber.isNilpotent_eps","module":"Mathlib.RingTheory.DualNumber","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ IsNilpotent DualNumber.eps","decl":"lemma isNilpotent_eps [Semiring R] :\n    IsNilpotent (ε : R[ε]) :=\n  TrivSqZeroExt.isNilpotent_inr 1\n\n"}
{"name":"DualNumber.isNilpotent_iff_eps_dvd","module":"Mathlib.RingTheory.DualNumber","initialProofState":"R : Type u_1\ninst✝ : DivisionSemiring R\nx : DualNumber R\n⊢ Iff (IsNilpotent x) (Dvd.dvd DualNumber.eps x)","decl":"lemma isNilpotent_iff_eps_dvd [DivisionSemiring R] {x : R[ε]} :\n    IsNilpotent x ↔ ε ∣ x := by\n  simp only [isNilpotent_iff_isNilpotent_fst, isNilpotent_iff_eq_zero, fst_eq_zero_iff_eps_dvd]\n\n"}
{"name":"DualNumber.instIsLocalRing","module":"Mathlib.RingTheory.DualNumber","initialProofState":"K : Type u_2\ninst✝ : DivisionRing K\n⊢ IsLocalRing (DualNumber K)","decl":"instance [DivisionRing K] : IsLocalRing K[ε] where\n  isUnit_or_isUnit_of_add_one {a b} h := by\n    rw [add_comm, ← eq_sub_iff_add_eq] at h\n    rcases eq_or_ne (fst a) 0 with ha|ha <;>\n    simp [isUnit_iff_isUnit_fst, h, ha]\n\n"}
{"name":"DualNumber.ideal_trichotomy","module":"Mathlib.RingTheory.DualNumber","initialProofState":"K : Type u_2\ninst✝ : DivisionRing K\nI : Ideal (DualNumber K)\n⊢ Or (Eq I Bot.bot) (Or (Eq I (Ideal.span (Singleton.singleton DualNumber.eps))) (Eq I Top.top))","decl":"lemma ideal_trichotomy [DivisionRing K] (I : Ideal K[ε]) :\n    I = ⊥ ∨ I = .span {ε} ∨ I = ⊤ := by\n  refine (eq_or_ne I ⊥).imp_right fun hb ↦ ?_\n  refine (eq_or_ne I ⊤).symm.imp_left fun ht ↦ ?_\n  have hd : ∀ x ∈ I, ε ∣ x := by\n    intro x hxI\n    rcases isUnit_or_isNilpotent x with hx|hx\n    · exact absurd (Ideal.eq_top_of_isUnit_mem _ hxI hx) ht\n    · rwa [← isNilpotent_iff_eps_dvd]\n  have hd' : ∀ x ∈ I, x ≠ 0 → ∃ r, ε = r * x := by\n    intro x hxI hx0\n    obtain ⟨r, rfl⟩ := hd _ hxI\n    have : ε * r = (fst r) • ε := by ext <;> simp\n    rw [this] at hxI hx0 ⊢\n    have hr : fst r ≠ 0 := by\n      contrapose! hx0\n      simp [hx0]\n    refine ⟨r⁻¹, ?_⟩\n    simp [TrivSqZeroExt.ext_iff, inv_mul_cancel₀ hr]\n  refine le_antisymm ?_ ?_ <;> intro x <;>\n    simp_rw [Ideal.mem_span_singleton', (commute_eps_right _).eq, eq_comm, ← dvd_def]\n  · intro hx\n    simp_rw [hd _ hx]\n  · intro hx\n    obtain ⟨p, rfl⟩ := hx\n    obtain ⟨y, hyI, hy0⟩ := Submodule.exists_mem_ne_zero_of_ne_bot hb\n    obtain ⟨r, hr⟩ := hd' _ hyI hy0\n    rw [(commute_eps_left _).eq, hr, ← mul_assoc]\n    exact Ideal.mul_mem_left _ _ hyI\n\n"}
{"name":"DualNumber.isMaximal_span_singleton_eps","module":"Mathlib.RingTheory.DualNumber","initialProofState":"K : Type u_2\ninst✝ : DivisionRing K\n⊢ (Ideal.span (Singleton.singleton DualNumber.eps)).IsMaximal","decl":"lemma isMaximal_span_singleton_eps [DivisionRing K] :\n    (Ideal.span {ε} : Ideal K[ε]).IsMaximal := by\n  refine ⟨?_, fun I hI ↦ ?_⟩\n  · simp [ne_eq, Ideal.eq_top_iff_one, Ideal.mem_span_singleton', TrivSqZeroExt.ext_iff]\n  · rcases ideal_trichotomy I with rfl|rfl|rfl <;>\n    first | simp at hI | simp\n\n"}
{"name":"DualNumber.maximalIdeal_eq_span_singleton_eps","module":"Mathlib.RingTheory.DualNumber","initialProofState":"K : Type u_2\ninst✝ : Field K\n⊢ Eq (IsLocalRing.maximalIdeal (DualNumber K)) (Ideal.span (Singleton.singleton DualNumber.eps))","decl":"lemma maximalIdeal_eq_span_singleton_eps [Field K] :\n    IsLocalRing.maximalIdeal K[ε] = Ideal.span {ε} :=\n  (IsLocalRing.eq_maximalIdeal isMaximal_span_singleton_eps).symm\n\n"}
{"name":"DualNumber.instIsPrincipalIdealRing","module":"Mathlib.RingTheory.DualNumber","initialProofState":"K : Type u_2\ninst✝ : DivisionRing K\n⊢ IsPrincipalIdealRing (DualNumber K)","decl":"instance [DivisionRing K] : IsPrincipalIdealRing K[ε] where\n  principal I := by\n    rcases ideal_trichotomy I with rfl|rfl|rfl\n    · exact bot_isPrincipal\n    · exact ⟨_, rfl⟩\n    · exact top_isPrincipal\n\n"}
{"name":"DualNumber.exists_mul_left_or_mul_right","module":"Mathlib.RingTheory.DualNumber","initialProofState":"K : Type u_2\ninst✝ : DivisionRing K\na b : DualNumber K\n⊢ Exists fun c => Or (Eq (HMul.hMul a c) b) (Eq (HMul.hMul b c) a)","decl":"lemma exists_mul_left_or_mul_right [DivisionRing K] (a b : K[ε]) :\n    ∃ c, a * c = b ∨ b * c = a := by\n  rcases isUnit_or_isNilpotent a with ha|ha\n  · lift a to K[ε]ˣ using ha\n    exact ⟨a⁻¹ * b, by simp⟩\n  rcases isUnit_or_isNilpotent b with hb|hb\n  · lift b to K[ε]ˣ using hb\n    exact ⟨b⁻¹ * a, by simp⟩\n  rw [isNilpotent_iff_eps_dvd] at ha hb\n  obtain ⟨x, rfl⟩ := ha\n  obtain ⟨y, rfl⟩ := hb\n  suffices ∃ c, fst x * fst c = fst y ∨ fst y * fst c = fst x by\n    simpa [TrivSqZeroExt.ext_iff] using this\n  rcases eq_or_ne (fst x) 0 with hx|hx\n  · refine ⟨ε, Or.inr ?_⟩\n    simp [hx]\n  refine ⟨inl ((fst x)⁻¹ * fst y), ?_⟩\n  simp [← inl_mul, ← mul_assoc, mul_inv_cancel₀ hx]\n\n"}
