{"name":"Matrix.invOf_eq","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝⁴ : Fintype n\ninst✝³ : DecidableEq n\ninst✝² : CommRing α\nA : Matrix n n α\ninst✝¹ : Invertible A.det\ninst✝ : Invertible A\n⊢ Eq (Invertible.invOf A) (HSMul.hSMul (Invertible.invOf A.det) A.adjugate)","decl":"theorem invOf_eq [Invertible A.det] [Invertible A] : ⅟ A = ⅟ A.det • A.adjugate := by\n  letI := invertibleOfDetInvertible A\n  convert (rfl : ⅟ A = _)\n\n"}
{"name":"Matrix.det_invOf","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝⁴ : Fintype n\ninst✝³ : DecidableEq n\ninst✝² : CommRing α\nA : Matrix n n α\ninst✝¹ : Invertible A\ninst✝ : Invertible A.det\n⊢ Eq (Invertible.invOf A).det (Invertible.invOf A.det)","decl":"theorem det_invOf [Invertible A] [Invertible A.det] : (⅟ A).det = ⅟ A.det := by\n  letI := detInvertibleOfInvertible A\n  convert (rfl : _ = ⅟ A.det)\n\n"}
{"name":"Matrix.invertibleEquivDetInvertible_apply","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommRing α\nA : Matrix n n α\ninst✝ : Invertible A\n⊢ Eq (A.invertibleEquivDetInvertible inst✝) A.detInvertibleOfInvertible","decl":"/-- Together `Matrix.detInvertibleOfInvertible` and `Matrix.invertibleOfDetInvertible` form an\nequivalence, although both sides of the equiv are subsingleton anyway. -/\n@[simps]\ndef invertibleEquivDetInvertible : Invertible A ≃ Invertible A.det where\n  toFun := @detInvertibleOfInvertible _ _ _ _ _ A\n  invFun := @invertibleOfDetInvertible _ _ _ _ _ A\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := Subsingleton.elim _ _\n\n"}
{"name":"Matrix.invertibleEquivDetInvertible_symm_apply","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommRing α\nA : Matrix n n α\ninst✝ : Invertible A.det\n⊢ Eq (A.invertibleEquivDetInvertible.symm inst✝) A.invertibleOfDetInvertible","decl":"/-- Together `Matrix.detInvertibleOfInvertible` and `Matrix.invertibleOfDetInvertible` form an\nequivalence, although both sides of the equiv are subsingleton anyway. -/\n@[simps]\ndef invertibleEquivDetInvertible : Invertible A ≃ Invertible A.det where\n  toFun := @detInvertibleOfInvertible _ _ _ _ _ A\n  invFun := @invertibleOfDetInvertible _ _ _ _ _ A\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := Subsingleton.elim _ _\n\n"}
{"name":"Matrix.isUnit_iff_isUnit_det","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix n n α\n⊢ Iff (IsUnit A) (IsUnit A.det)","decl":"/-- When lowered to a prop, `Matrix.invertibleEquivDetInvertible` forms an `iff`. -/\ntheorem isUnit_iff_isUnit_det : IsUnit A ↔ IsUnit A.det := by\n  simp only [← nonempty_invertible_iff_isUnit, (invertibleEquivDetInvertible A).nonempty_congr]\n\n"}
{"name":"Matrix.isUnits_det_units","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Units (Matrix n n α)\n⊢ IsUnit (↑A).det","decl":"@[simp]\ntheorem isUnits_det_units (A : (Matrix n n α)ˣ) : IsUnit (A : Matrix n n α).det :=\n  isUnit_iff_isUnit_det _ |>.mp A.isUnit\n\n"}
{"name":"Matrix.isUnit_det_of_invertible","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommRing α\nA : Matrix n n α\ninst✝ : Invertible A\n⊢ IsUnit A.det","decl":"theorem isUnit_det_of_invertible [Invertible A] : IsUnit A.det :=\n  @isUnit_of_invertible _ _ _ (detInvertibleOfInvertible A)\n\n"}
{"name":"Matrix.isUnit_det_of_left_inverse","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA B : Matrix n n α\nh : Eq (HMul.hMul B A) 1\n⊢ IsUnit A.det","decl":"theorem isUnit_det_of_left_inverse (h : B * A = 1) : IsUnit A.det :=\n  @isUnit_of_invertible _ _ _ (detInvertibleOfLeftInverse _ _ h)\n\n"}
{"name":"Matrix.isUnit_det_of_right_inverse","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA B : Matrix n n α\nh : Eq (HMul.hMul A B) 1\n⊢ IsUnit A.det","decl":"theorem isUnit_det_of_right_inverse (h : A * B = 1) : IsUnit A.det :=\n  @isUnit_of_invertible _ _ _ (detInvertibleOfRightInverse _ _ h)\n\n"}
{"name":"Matrix.det_ne_zero_of_left_inverse","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommRing α\nA B : Matrix n n α\ninst✝ : Nontrivial α\nh : Eq (HMul.hMul B A) 1\n⊢ Ne A.det 0","decl":"theorem det_ne_zero_of_left_inverse [Nontrivial α] (h : B * A = 1) : A.det ≠ 0 :=\n  (isUnit_det_of_left_inverse h).ne_zero\n\n"}
{"name":"Matrix.det_ne_zero_of_right_inverse","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommRing α\nA B : Matrix n n α\ninst✝ : Nontrivial α\nh : Eq (HMul.hMul A B) 1\n⊢ Ne A.det 0","decl":"theorem det_ne_zero_of_right_inverse [Nontrivial α] (h : A * B = 1) : A.det ≠ 0 :=\n  (isUnit_det_of_right_inverse h).ne_zero\n\n"}
{"name":"Matrix.isUnit_det_transpose","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix n n α\nh : IsUnit A.det\n⊢ IsUnit A.transpose.det","decl":"theorem isUnit_det_transpose (h : IsUnit A.det) : IsUnit Aᵀ.det := by\n  rw [det_transpose]\n  exact h\n\n"}
{"name":"Matrix.inv_def","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix n n α\n⊢ Eq (Inv.inv A) (HSMul.hSMul (Ring.inverse A.det) A.adjugate)","decl":"theorem inv_def (A : Matrix n n α) : A⁻¹ = Ring.inverse A.det • A.adjugate :=\n  rfl\n\n"}
{"name":"Matrix.nonsing_inv_apply_not_isUnit","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix n n α\nh : Not (IsUnit A.det)\n⊢ Eq (Inv.inv A) 0","decl":"theorem nonsing_inv_apply_not_isUnit (h : ¬IsUnit A.det) : A⁻¹ = 0 := by\n  rw [inv_def, Ring.inverse_non_unit _ h, zero_smul]\n\n"}
{"name":"Matrix.nonsing_inv_apply","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix n n α\nh : IsUnit A.det\n⊢ Eq (Inv.inv A) (HSMul.hSMul (↑(Inv.inv h.unit)) A.adjugate)","decl":"theorem nonsing_inv_apply (h : IsUnit A.det) : A⁻¹ = (↑h.unit⁻¹ : α) • A.adjugate := by\n  rw [inv_def, ← Ring.inverse_unit h.unit, IsUnit.unit_spec]\n\n"}
{"name":"Matrix.invOf_eq_nonsing_inv","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommRing α\nA : Matrix n n α\ninst✝ : Invertible A\n⊢ Eq (Invertible.invOf A) (Inv.inv A)","decl":"/-- The nonsingular inverse is the same as `invOf` when `A` is invertible. -/\n@[simp]\ntheorem invOf_eq_nonsing_inv [Invertible A] : ⅟ A = A⁻¹ := by\n  letI := detInvertibleOfInvertible A\n  rw [inv_def, Ring.inverse_invertible, invOf_eq]\n\n"}
{"name":"Matrix.coe_units_inv","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Units (Matrix n n α)\n⊢ Eq (↑(Inv.inv A)) (Inv.inv ↑A)","decl":"/-- Coercing the result of `Units.instInv` is the same as coercing first and applying the\nnonsingular inverse. -/\n@[simp, norm_cast]\ntheorem coe_units_inv (A : (Matrix n n α)ˣ) : ↑A⁻¹ = (A⁻¹ : Matrix n n α) := by\n  letI := A.invertible\n  rw [← invOf_eq_nonsing_inv, invOf_units]\n\n"}
{"name":"Matrix.nonsing_inv_eq_ring_inverse","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix n n α\n⊢ Eq (Inv.inv A) (Ring.inverse A)","decl":"/-- The nonsingular inverse is the same as the general `Ring.inverse`. -/\ntheorem nonsing_inv_eq_ring_inverse : A⁻¹ = Ring.inverse A := by\n  by_cases h_det : IsUnit A.det\n  · cases (A.isUnit_iff_isUnit_det.mpr h_det).nonempty_invertible\n    rw [← invOf_eq_nonsing_inv, Ring.inverse_invertible]\n  · have h := mt A.isUnit_iff_isUnit_det.mp h_det\n    rw [Ring.inverse_non_unit _ h, nonsing_inv_apply_not_isUnit A h_det]\n\n"}
{"name":"Matrix.transpose_nonsing_inv","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix n n α\n⊢ Eq (Inv.inv A).transpose (Inv.inv A.transpose)","decl":"theorem transpose_nonsing_inv : A⁻¹ᵀ = Aᵀ⁻¹ := by\n  rw [inv_def, inv_def, transpose_smul, det_transpose, adjugate_transpose]\n\n"}
{"name":"Matrix.conjTranspose_nonsing_inv","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommRing α\nA : Matrix n n α\ninst✝ : StarRing α\n⊢ Eq (Inv.inv A).conjTranspose (Inv.inv A.conjTranspose)","decl":"theorem conjTranspose_nonsing_inv [StarRing α] : A⁻¹ᴴ = Aᴴ⁻¹ := by\n  rw [inv_def, inv_def, conjTranspose_smul, det_conjTranspose, adjugate_conjTranspose,\n    Ring.inverse_star]\n\n"}
{"name":"Matrix.mul_nonsing_inv","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix n n α\nh : IsUnit A.det\n⊢ Eq (HMul.hMul A (Inv.inv A)) 1","decl":"/-- The `nonsing_inv` of `A` is a right inverse. -/\n@[simp]\ntheorem mul_nonsing_inv (h : IsUnit A.det) : A * A⁻¹ = 1 := by\n  cases (A.isUnit_iff_isUnit_det.mpr h).nonempty_invertible\n  rw [← invOf_eq_nonsing_inv, mul_invOf_self]\n\n"}
{"name":"Matrix.nonsing_inv_mul","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix n n α\nh : IsUnit A.det\n⊢ Eq (HMul.hMul (Inv.inv A) A) 1","decl":"/-- The `nonsing_inv` of `A` is a left inverse. -/\n@[simp]\ntheorem nonsing_inv_mul (h : IsUnit A.det) : A⁻¹ * A = 1 := by\n  cases (A.isUnit_iff_isUnit_det.mpr h).nonempty_invertible\n  rw [← invOf_eq_nonsing_inv, invOf_mul_self]\n\n"}
{"name":"Matrix.inv_inv_of_invertible","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommRing α\nA : Matrix n n α\ninst✝ : Invertible A\n⊢ Eq (Inv.inv (Inv.inv A)) A","decl":"@[simp]\ntheorem inv_inv_of_invertible [Invertible A] : A⁻¹⁻¹ = A := by\n  simp only [← invOf_eq_nonsing_inv, invOf_invOf]\n\n"}
{"name":"Matrix.mul_nonsing_inv_cancel_right","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\nn : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix n n α\nB : Matrix m n α\nh : IsUnit A.det\n⊢ Eq (HMul.hMul (HMul.hMul B A) (Inv.inv A)) B","decl":"@[simp]\ntheorem mul_nonsing_inv_cancel_right (B : Matrix m n α) (h : IsUnit A.det) : B * A * A⁻¹ = B := by\n  simp [Matrix.mul_assoc, mul_nonsing_inv A h]\n\n"}
{"name":"Matrix.mul_nonsing_inv_cancel_left","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\nn : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix n n α\nB : Matrix n m α\nh : IsUnit A.det\n⊢ Eq (HMul.hMul A (HMul.hMul (Inv.inv A) B)) B","decl":"@[simp]\ntheorem mul_nonsing_inv_cancel_left (B : Matrix n m α) (h : IsUnit A.det) : A * (A⁻¹ * B) = B := by\n  simp [← Matrix.mul_assoc, mul_nonsing_inv A h]\n\n"}
{"name":"Matrix.nonsing_inv_mul_cancel_right","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\nn : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix n n α\nB : Matrix m n α\nh : IsUnit A.det\n⊢ Eq (HMul.hMul (HMul.hMul B (Inv.inv A)) A) B","decl":"@[simp]\ntheorem nonsing_inv_mul_cancel_right (B : Matrix m n α) (h : IsUnit A.det) : B * A⁻¹ * A = B := by\n  simp [Matrix.mul_assoc, nonsing_inv_mul A h]\n\n"}
{"name":"Matrix.nonsing_inv_mul_cancel_left","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\nn : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix n n α\nB : Matrix n m α\nh : IsUnit A.det\n⊢ Eq (HMul.hMul (Inv.inv A) (HMul.hMul A B)) B","decl":"@[simp]\ntheorem nonsing_inv_mul_cancel_left (B : Matrix n m α) (h : IsUnit A.det) : A⁻¹ * (A * B) = B := by\n  simp [← Matrix.mul_assoc, nonsing_inv_mul A h]\n\n"}
{"name":"Matrix.mul_inv_of_invertible","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommRing α\nA : Matrix n n α\ninst✝ : Invertible A\n⊢ Eq (HMul.hMul A (Inv.inv A)) 1","decl":"@[simp]\ntheorem mul_inv_of_invertible [Invertible A] : A * A⁻¹ = 1 :=\n  mul_nonsing_inv A (isUnit_det_of_invertible A)\n\n"}
{"name":"Matrix.inv_mul_of_invertible","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommRing α\nA : Matrix n n α\ninst✝ : Invertible A\n⊢ Eq (HMul.hMul (Inv.inv A) A) 1","decl":"@[simp]\ntheorem inv_mul_of_invertible [Invertible A] : A⁻¹ * A = 1 :=\n  nonsing_inv_mul A (isUnit_det_of_invertible A)\n\n"}
{"name":"Matrix.mul_inv_cancel_right_of_invertible","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\nn : Type u'\nα : Type v\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommRing α\nA : Matrix n n α\nB : Matrix m n α\ninst✝ : Invertible A\n⊢ Eq (HMul.hMul (HMul.hMul B A) (Inv.inv A)) B","decl":"@[simp]\ntheorem mul_inv_cancel_right_of_invertible (B : Matrix m n α) [Invertible A] : B * A * A⁻¹ = B :=\n  mul_nonsing_inv_cancel_right A B (isUnit_det_of_invertible A)\n\n"}
{"name":"Matrix.mul_inv_cancel_left_of_invertible","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\nn : Type u'\nα : Type v\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommRing α\nA : Matrix n n α\nB : Matrix n m α\ninst✝ : Invertible A\n⊢ Eq (HMul.hMul A (HMul.hMul (Inv.inv A) B)) B","decl":"@[simp]\ntheorem mul_inv_cancel_left_of_invertible (B : Matrix n m α) [Invertible A] : A * (A⁻¹ * B) = B :=\n  mul_nonsing_inv_cancel_left A B (isUnit_det_of_invertible A)\n\n"}
{"name":"Matrix.inv_mul_cancel_right_of_invertible","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\nn : Type u'\nα : Type v\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommRing α\nA : Matrix n n α\nB : Matrix m n α\ninst✝ : Invertible A\n⊢ Eq (HMul.hMul (HMul.hMul B (Inv.inv A)) A) B","decl":"@[simp]\ntheorem inv_mul_cancel_right_of_invertible (B : Matrix m n α) [Invertible A] : B * A⁻¹ * A = B :=\n  nonsing_inv_mul_cancel_right A B (isUnit_det_of_invertible A)\n\n"}
{"name":"Matrix.inv_mul_cancel_left_of_invertible","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\nn : Type u'\nα : Type v\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommRing α\nA : Matrix n n α\nB : Matrix n m α\ninst✝ : Invertible A\n⊢ Eq (HMul.hMul (Inv.inv A) (HMul.hMul A B)) B","decl":"@[simp]\ntheorem inv_mul_cancel_left_of_invertible (B : Matrix n m α) [Invertible A] : A⁻¹ * (A * B) = B :=\n  nonsing_inv_mul_cancel_left A B (isUnit_det_of_invertible A)\n\n"}
{"name":"Matrix.inv_mul_eq_iff_eq_mul_of_invertible","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommRing α\nA B C : Matrix n n α\ninst✝ : Invertible A\n⊢ Iff (Eq (HMul.hMul (Inv.inv A) B) C) (Eq B (HMul.hMul A C))","decl":"theorem inv_mul_eq_iff_eq_mul_of_invertible (A B C : Matrix n n α) [Invertible A] :\n    A⁻¹ * B = C ↔ B = A * C :=\n  ⟨fun h => by rw [← h, mul_inv_cancel_left_of_invertible],\n   fun h => by rw [h, inv_mul_cancel_left_of_invertible]⟩\n\n"}
{"name":"Matrix.mul_inv_eq_iff_eq_mul_of_invertible","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommRing α\nA B C : Matrix n n α\ninst✝ : Invertible A\n⊢ Iff (Eq (HMul.hMul B (Inv.inv A)) C) (Eq B (HMul.hMul C A))","decl":"theorem mul_inv_eq_iff_eq_mul_of_invertible (A B C : Matrix n n α) [Invertible A] :\n    B * A⁻¹ = C ↔ B = C * A :=\n  ⟨fun h => by rw [← h, inv_mul_cancel_right_of_invertible],\n   fun h => by rw [h, mul_inv_cancel_right_of_invertible]⟩\n\n"}
{"name":"Matrix.inv_mulVec_eq_vec","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommRing α\nA : Matrix n n α\ninst✝ : Invertible A\nu v : n → α\nhM : Eq u (A.mulVec v)\n⊢ Eq ((Inv.inv A).mulVec u) v","decl":"lemma inv_mulVec_eq_vec {A : Matrix n n α} [Invertible A]\n    {u v : n → α} (hM : u = A.mulVec v) : A⁻¹.mulVec u = v := by\n  rw [hM, Matrix.mulVec_mulVec, Matrix.inv_mul_of_invertible, Matrix.one_mulVec]\n\n"}
{"name":"Matrix.mul_right_injective_of_invertible","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\nn : Type u'\nα : Type v\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommRing α\nA : Matrix n n α\ninst✝ : Invertible A\n⊢ Function.Injective fun x => HMul.hMul A x","decl":"lemma mul_right_injective_of_invertible [Invertible A] :\n    Function.Injective (fun (x : Matrix n m α) => A * x) :=\n  fun _ _ h => by simpa only [inv_mul_cancel_left_of_invertible] using congr_arg (A⁻¹ * ·) h\n\n"}
{"name":"Matrix.mul_left_injective_of_invertible","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\nn : Type u'\nα : Type v\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommRing α\nA : Matrix n n α\ninst✝ : Invertible A\n⊢ Function.Injective fun x => HMul.hMul x A","decl":"lemma mul_left_injective_of_invertible [Invertible A] :\n    Function.Injective (fun (x : Matrix m n α) => x * A) :=\n  fun a x hax => by simpa only [mul_inv_cancel_right_of_invertible] using congr_arg (· * A⁻¹) hax\n\n"}
{"name":"Matrix.mul_right_inj_of_invertible","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\nn : Type u'\nα : Type v\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommRing α\nA : Matrix n n α\ninst✝ : Invertible A\nx y : Matrix n m α\n⊢ Iff (Eq (HMul.hMul A x) (HMul.hMul A y)) (Eq x y)","decl":"lemma mul_right_inj_of_invertible [Invertible A] {x y : Matrix n m α} : A * x = A * y ↔ x = y :=\n  (mul_right_injective_of_invertible A).eq_iff\n\n"}
{"name":"Matrix.mul_left_inj_of_invertible","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\nn : Type u'\nα : Type v\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommRing α\nA : Matrix n n α\ninst✝ : Invertible A\nx y : Matrix m n α\n⊢ Iff (Eq (HMul.hMul x A) (HMul.hMul y A)) (Eq x y)","decl":"lemma mul_left_inj_of_invertible [Invertible A] {x y : Matrix m n α} : x * A = y * A ↔ x = y :=\n  (mul_left_injective_of_invertible A).eq_iff\n\n"}
{"name":"Matrix.mul_left_injective_of_inv","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"l : Type u_1\nm : Type u\nn : Type u'\nα : Type v\ninst✝³ : Fintype n\ninst✝² : Fintype m\ninst✝¹ : DecidableEq m\ninst✝ : CommRing α\nA : Matrix m n α\nB : Matrix n m α\nh : Eq (HMul.hMul A B) 1\n⊢ Function.Injective fun x => HMul.hMul x A","decl":"lemma mul_left_injective_of_inv (A : Matrix m n α) (B : Matrix n m α) (h : A * B = 1) :\n    Function.Injective (fun x : Matrix l m α => x * A) := fun _ _ g => by\n  simpa only [Matrix.mul_assoc, Matrix.mul_one, h] using congr_arg (· * B) g\n\n"}
{"name":"Matrix.mul_right_injective_of_inv","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"l : Type u_1\nm : Type u\nn : Type u'\nα : Type v\ninst✝³ : Fintype n\ninst✝² : Fintype m\ninst✝¹ : DecidableEq m\ninst✝ : CommRing α\nA : Matrix m n α\nB : Matrix n m α\nh : Eq (HMul.hMul A B) 1\n⊢ Function.Injective fun x => HMul.hMul B x","decl":"lemma mul_right_injective_of_inv (A : Matrix m n α) (B : Matrix n m α) (h : A * B = 1) :\n    Function.Injective (fun x : Matrix m l α => B * x) :=\n  fun _ _ g => by simpa only [← Matrix.mul_assoc, Matrix.one_mul, h] using congr_arg (A * ·) g\n\n"}
{"name":"Matrix.vecMul_surjective_iff_exists_left_inverse","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\nn : Type u'\nR : Type u_2\ninst✝³ : Semiring R\ninst✝² : DecidableEq n\ninst✝¹ : Fintype m\ninst✝ : Finite n\nA : Matrix m n R\n⊢ Iff (Function.Surjective fun v => Matrix.vecMul v A) (Exists fun B => Eq (HMul.hMul B A) 1)","decl":"theorem vecMul_surjective_iff_exists_left_inverse\n    [DecidableEq n] [Fintype m] [Finite n] {A : Matrix m n R} :\n    Function.Surjective A.vecMul ↔ ∃ B : Matrix n m R, B * A = 1 := by\n  cases nonempty_fintype n\n  refine ⟨fun h ↦ ?_, fun ⟨B, hBA⟩ y ↦ ⟨y ᵥ* B, by simp [hBA]⟩⟩\n  choose rows hrows using (h <| Pi.single · 1)\n  refine ⟨Matrix.of rows, Matrix.ext fun i j => ?_⟩\n  rw [mul_apply_eq_vecMul, one_eq_pi_single, ← hrows]\n  rfl\n\n"}
{"name":"Matrix.mulVec_surjective_iff_exists_right_inverse","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\nn : Type u'\nR : Type u_2\ninst✝³ : Semiring R\ninst✝² : DecidableEq m\ninst✝¹ : Finite m\ninst✝ : Fintype n\nA : Matrix m n R\n⊢ Iff (Function.Surjective A.mulVec) (Exists fun B => Eq (HMul.hMul A B) 1)","decl":"theorem mulVec_surjective_iff_exists_right_inverse\n    [DecidableEq m] [Finite m] [Fintype n] {A : Matrix m n R} :\n    Function.Surjective A.mulVec ↔ ∃ B : Matrix n m R, A * B = 1 := by\n  cases nonempty_fintype m\n  refine ⟨fun h ↦ ?_, fun ⟨B, hBA⟩ y ↦ ⟨B *ᵥ y, by simp [hBA]⟩⟩\n  choose cols hcols using (h <| Pi.single · 1)\n  refine ⟨(Matrix.of cols)ᵀ, Matrix.ext fun i j ↦ ?_⟩\n  rw [one_eq_pi_single, Pi.single_comm, ← hcols j]\n  rfl\n\n"}
{"name":"Matrix.vecMul_surjective_iff_isUnit","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\ninst✝² : DecidableEq m\nR : Type u_2\ninst✝¹ : CommRing R\ninst✝ : Fintype m\nA : Matrix m m R\n⊢ Iff (Function.Surjective fun v => Matrix.vecMul v A) (IsUnit A)","decl":"theorem vecMul_surjective_iff_isUnit {A : Matrix m m R} :\n    Function.Surjective A.vecMul ↔ IsUnit A := by\n  rw [vecMul_surjective_iff_exists_left_inverse, exists_left_inverse_iff_isUnit]\n\n"}
{"name":"Matrix.mulVec_surjective_iff_isUnit","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\ninst✝² : DecidableEq m\nR : Type u_2\ninst✝¹ : CommRing R\ninst✝ : Fintype m\nA : Matrix m m R\n⊢ Iff (Function.Surjective A.mulVec) (IsUnit A)","decl":"theorem mulVec_surjective_iff_isUnit {A : Matrix m m R} :\n    Function.Surjective A.mulVec ↔ IsUnit A := by\n  rw [mulVec_surjective_iff_exists_right_inverse, exists_right_inverse_iff_isUnit]\n\n"}
{"name":"Matrix.vecMul_injective_iff_isUnit","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\ninst✝² : DecidableEq m\nK : Type u_3\ninst✝¹ : Field K\ninst✝ : Fintype m\nA : Matrix m m K\n⊢ Iff (Function.Injective fun v => Matrix.vecMul v A) (IsUnit A)","decl":"theorem vecMul_injective_iff_isUnit {A : Matrix m m K} :\n    Function.Injective A.vecMul ↔ IsUnit A := by\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · rw [← vecMul_surjective_iff_isUnit]\n    exact LinearMap.surjective_of_injective (f := A.vecMulLinear) h\n  change Function.Injective A.vecMulLinear\n  rw [← LinearMap.ker_eq_bot, LinearMap.ker_eq_bot']\n  intro c hc\n  replace h := h.invertible\n  simpa using congr_arg A⁻¹.vecMulLinear hc\n\n"}
{"name":"Matrix.mulVec_injective_iff_isUnit","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\ninst✝² : DecidableEq m\nK : Type u_3\ninst✝¹ : Field K\ninst✝ : Fintype m\nA : Matrix m m K\n⊢ Iff (Function.Injective A.mulVec) (IsUnit A)","decl":"theorem mulVec_injective_iff_isUnit {A : Matrix m m K} :\n    Function.Injective A.mulVec ↔ IsUnit A := by\n  rw [← isUnit_transpose, ← vecMul_injective_iff_isUnit]\n  simp_rw [vecMul_transpose]\n\n"}
{"name":"Matrix.linearIndependent_rows_iff_isUnit","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\ninst✝² : DecidableEq m\nK : Type u_3\ninst✝¹ : Field K\ninst✝ : Fintype m\nA : Matrix m m K\n⊢ Iff (LinearIndependent K fun i => A i) (IsUnit A)","decl":"theorem linearIndependent_rows_iff_isUnit {A : Matrix m m K} :\n    LinearIndependent K (fun i ↦ A i) ↔ IsUnit A := by\n  rw [← transpose_transpose A, ← mulVec_injective_iff, ← coe_mulVecLin, mulVecLin_transpose,\n    transpose_transpose, ← vecMul_injective_iff_isUnit, coe_vecMulLinear]\n\n"}
{"name":"Matrix.linearIndependent_cols_iff_isUnit","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\ninst✝² : DecidableEq m\nK : Type u_3\ninst✝¹ : Field K\ninst✝ : Fintype m\nA : Matrix m m K\n⊢ Iff (LinearIndependent K fun i => A.transpose i) (IsUnit A)","decl":"theorem linearIndependent_cols_iff_isUnit {A : Matrix m m K} :\n    LinearIndependent K (fun i ↦ Aᵀ i) ↔ IsUnit A := by\n  rw [← transpose_transpose A, isUnit_transpose, linearIndependent_rows_iff_isUnit,\n    transpose_transpose]\n\n"}
{"name":"Matrix.vecMul_surjective_of_invertible","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\ninst✝³ : DecidableEq m\nR : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Fintype m\nA : Matrix m m R\ninst✝ : Invertible A\n⊢ Function.Surjective fun v => Matrix.vecMul v A","decl":"theorem vecMul_surjective_of_invertible (A : Matrix m m R) [Invertible A] :\n    Function.Surjective A.vecMul :=\n  vecMul_surjective_iff_isUnit.2 <| isUnit_of_invertible A\n\n"}
{"name":"Matrix.mulVec_surjective_of_invertible","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\ninst✝³ : DecidableEq m\nR : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Fintype m\nA : Matrix m m R\ninst✝ : Invertible A\n⊢ Function.Surjective A.mulVec","decl":"theorem mulVec_surjective_of_invertible (A : Matrix m m R) [Invertible A] :\n    Function.Surjective A.mulVec :=\n  mulVec_surjective_iff_isUnit.2 <| isUnit_of_invertible A\n\n"}
{"name":"Matrix.vecMul_injective_of_invertible","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\ninst✝³ : DecidableEq m\nK : Type u_3\ninst✝² : Field K\ninst✝¹ : Fintype m\nA : Matrix m m K\ninst✝ : Invertible A\n⊢ Function.Injective fun v => Matrix.vecMul v A","decl":"theorem vecMul_injective_of_invertible (A : Matrix m m K) [Invertible A] :\n    Function.Injective A.vecMul :=\n  vecMul_injective_iff_isUnit.2 <| isUnit_of_invertible A\n\n"}
{"name":"Matrix.mulVec_injective_of_invertible","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\ninst✝³ : DecidableEq m\nK : Type u_3\ninst✝² : Field K\ninst✝¹ : Fintype m\nA : Matrix m m K\ninst✝ : Invertible A\n⊢ Function.Injective A.mulVec","decl":"theorem mulVec_injective_of_invertible (A : Matrix m m K) [Invertible A] :\n    Function.Injective A.mulVec :=\n  mulVec_injective_iff_isUnit.2 <| isUnit_of_invertible A\n\n"}
{"name":"Matrix.linearIndependent_rows_of_invertible","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\ninst✝³ : DecidableEq m\nK : Type u_3\ninst✝² : Field K\ninst✝¹ : Fintype m\nA : Matrix m m K\ninst✝ : Invertible A\n⊢ LinearIndependent K fun i => A i","decl":"theorem linearIndependent_rows_of_invertible (A : Matrix m m K) [Invertible A] :\n    LinearIndependent K (fun i ↦ A i) :=\n  linearIndependent_rows_iff_isUnit.2 <| isUnit_of_invertible A\n\n"}
{"name":"Matrix.linearIndependent_cols_of_invertible","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\ninst✝³ : DecidableEq m\nK : Type u_3\ninst✝² : Field K\ninst✝¹ : Fintype m\nA : Matrix m m K\ninst✝ : Invertible A\n⊢ LinearIndependent K fun i => A.transpose i","decl":"theorem linearIndependent_cols_of_invertible (A : Matrix m m K) [Invertible A] :\n    LinearIndependent K (fun i ↦ Aᵀ i) :=\n  linearIndependent_cols_iff_isUnit.2 <| isUnit_of_invertible A\n\n"}
{"name":"Matrix.nonsing_inv_cancel_or_zero","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix n n α\n⊢ Or (And (Eq (HMul.hMul (Inv.inv A) A) 1) (Eq (HMul.hMul A (Inv.inv A)) 1)) (Eq (Inv.inv A) 0)","decl":"theorem nonsing_inv_cancel_or_zero : A⁻¹ * A = 1 ∧ A * A⁻¹ = 1 ∨ A⁻¹ = 0 := by\n  by_cases h : IsUnit A.det\n  · exact Or.inl ⟨nonsing_inv_mul _ h, mul_nonsing_inv _ h⟩\n  · exact Or.inr (nonsing_inv_apply_not_isUnit _ h)\n\n"}
{"name":"Matrix.det_nonsing_inv_mul_det","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix n n α\nh : IsUnit A.det\n⊢ Eq (HMul.hMul (Inv.inv A).det A.det) 1","decl":"theorem det_nonsing_inv_mul_det (h : IsUnit A.det) : A⁻¹.det * A.det = 1 := by\n  rw [← det_mul, A.nonsing_inv_mul h, det_one]\n\n"}
{"name":"Matrix.det_nonsing_inv","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix n n α\n⊢ Eq (Inv.inv A).det (Ring.inverse A.det)","decl":"@[simp]\ntheorem det_nonsing_inv : A⁻¹.det = Ring.inverse A.det := by\n  by_cases h : IsUnit A.det\n  · cases h.nonempty_invertible\n    letI := invertibleOfDetInvertible A\n    rw [Ring.inverse_invertible, ← invOf_eq_nonsing_inv, det_invOf]\n  cases isEmpty_or_nonempty n\n  · rw [det_isEmpty, det_isEmpty, Ring.inverse_one]\n  · rw [Ring.inverse_non_unit _ h, nonsing_inv_apply_not_isUnit _ h, det_zero ‹_›]\n\n"}
{"name":"Matrix.isUnit_nonsing_inv_det","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix n n α\nh : IsUnit A.det\n⊢ IsUnit (Inv.inv A).det","decl":"theorem isUnit_nonsing_inv_det (h : IsUnit A.det) : IsUnit A⁻¹.det :=\n  isUnit_of_mul_eq_one _ _ (A.det_nonsing_inv_mul_det h)\n\n"}
{"name":"Matrix.nonsing_inv_nonsing_inv","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix n n α\nh : IsUnit A.det\n⊢ Eq (Inv.inv (Inv.inv A)) A","decl":"@[simp]\ntheorem nonsing_inv_nonsing_inv (h : IsUnit A.det) : A⁻¹⁻¹ = A :=\n  calc\n    A⁻¹⁻¹ = 1 * A⁻¹⁻¹ := by rw [Matrix.one_mul]\n    _ = A * A⁻¹ * A⁻¹⁻¹ := by rw [A.mul_nonsing_inv h]\n    _ = A := by\n      rw [Matrix.mul_assoc, A⁻¹.mul_nonsing_inv (A.isUnit_nonsing_inv_det h), Matrix.mul_one]\n\n"}
{"name":"Matrix.isUnit_nonsing_inv_det_iff","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix n n α\n⊢ Iff (IsUnit (Inv.inv A).det) (IsUnit A.det)","decl":"theorem isUnit_nonsing_inv_det_iff {A : Matrix n n α} : IsUnit A⁻¹.det ↔ IsUnit A.det := by\n  rw [Matrix.det_nonsing_inv, isUnit_ring_inverse]\n\n"}
{"name":"Matrix.isUnit_nonsing_inv_iff","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix n n α\n⊢ Iff (IsUnit (Inv.inv A)) (IsUnit A)","decl":"@[simp]\ntheorem isUnit_nonsing_inv_iff {A : Matrix n n α} : IsUnit A⁻¹ ↔ IsUnit A := by\n  simp_rw [isUnit_iff_isUnit_det, isUnit_nonsing_inv_det_iff]\n\n-- `IsUnit.invertible` lifts the proposition `IsUnit A` to a constructive inverse of `A`.\n"}
{"name":"Matrix.unitOfDetInvertible_eq_nonsingInvUnit","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommRing α\nA : Matrix n n α\ninst✝ : Invertible A.det\n⊢ Eq A.unitOfDetInvertible (A.nonsingInvUnit ⋯)","decl":"theorem unitOfDetInvertible_eq_nonsingInvUnit [Invertible A.det] :\n    unitOfDetInvertible A = nonsingInvUnit A (isUnit_of_invertible _) := by\n  ext\n  rfl\n\n"}
{"name":"Matrix.inv_eq_left_inv","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA B : Matrix n n α\nh : Eq (HMul.hMul B A) 1\n⊢ Eq (Inv.inv A) B","decl":"/-- If matrix A is left invertible, then its inverse equals its left inverse. -/\ntheorem inv_eq_left_inv (h : B * A = 1) : A⁻¹ = B :=\n  letI := invertibleOfLeftInverse _ _ h\n  invOf_eq_nonsing_inv A ▸ invOf_eq_left_inv h\n\n"}
{"name":"Matrix.inv_eq_right_inv","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA B : Matrix n n α\nh : Eq (HMul.hMul A B) 1\n⊢ Eq (Inv.inv A) B","decl":"/-- If matrix A is right invertible, then its inverse equals its right inverse. -/\ntheorem inv_eq_right_inv (h : A * B = 1) : A⁻¹ = B :=\n  inv_eq_left_inv (mul_eq_one_comm.2 h)\n\n"}
{"name":"Matrix.left_inv_eq_left_inv","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA B C : Matrix n n α\nh : Eq (HMul.hMul B A) 1\ng : Eq (HMul.hMul C A) 1\n⊢ Eq B C","decl":"/-- The left inverse of matrix A is unique when existing. -/\ntheorem left_inv_eq_left_inv (h : B * A = 1) (g : C * A = 1) : B = C := by\n  rw [← inv_eq_left_inv h, ← inv_eq_left_inv g]\n\n"}
{"name":"Matrix.right_inv_eq_right_inv","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA B C : Matrix n n α\nh : Eq (HMul.hMul A B) 1\ng : Eq (HMul.hMul A C) 1\n⊢ Eq B C","decl":"/-- The right inverse of matrix A is unique when existing. -/\ntheorem right_inv_eq_right_inv (h : A * B = 1) (g : A * C = 1) : B = C := by\n  rw [← inv_eq_right_inv h, ← inv_eq_right_inv g]\n\n"}
{"name":"Matrix.right_inv_eq_left_inv","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA B C : Matrix n n α\nh : Eq (HMul.hMul A B) 1\ng : Eq (HMul.hMul C A) 1\n⊢ Eq B C","decl":"/-- The right inverse of matrix A equals the left inverse of A when they exist. -/\ntheorem right_inv_eq_left_inv (h : A * B = 1) (g : C * A = 1) : B = C := by\n  rw [← inv_eq_right_inv h, ← inv_eq_left_inv g]\n\n"}
{"name":"Matrix.inv_inj","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA B : Matrix n n α\nh : Eq (Inv.inv A) (Inv.inv B)\nh' : IsUnit A.det\n⊢ Eq A B","decl":"theorem inv_inj (h : A⁻¹ = B⁻¹) (h' : IsUnit A.det) : A = B := by\n  refine left_inv_eq_left_inv (mul_nonsing_inv _ h') ?_\n  rw [h]\n  refine mul_nonsing_inv _ ?_\n  rwa [← isUnit_nonsing_inv_det_iff, ← h, isUnit_nonsing_inv_det_iff]\n\n"}
{"name":"Matrix.inv_zero","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\n⊢ Eq (Inv.inv 0) 0","decl":"@[simp]\ntheorem inv_zero : (0 : Matrix n n α)⁻¹ = 0 := by\n  cases' subsingleton_or_nontrivial α with ht ht\n  · simp [eq_iff_true_of_subsingleton]\n  rcases (Fintype.card n).zero_le.eq_or_lt with hc | hc\n  · rw [eq_comm, Fintype.card_eq_zero_iff] at hc\n    haveI := hc\n    ext i\n    exact (IsEmpty.false i).elim\n  · have hn : Nonempty n := Fintype.card_pos_iff.mp hc\n    refine nonsing_inv_apply_not_isUnit _ ?_\n    simp [hn]\n\n"}
{"name":"Matrix.inv_smul","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommRing α\nA : Matrix n n α\nk : α\ninst✝ : Invertible k\nh : IsUnit A.det\n⊢ Eq (Inv.inv (HSMul.hSMul k A)) (HSMul.hSMul (Invertible.invOf k) (Inv.inv A))","decl":"theorem inv_smul (k : α) [Invertible k] (h : IsUnit A.det) : (k • A)⁻¹ = ⅟ k • A⁻¹ :=\n  inv_eq_left_inv (by simp [h, smul_smul])\n\n"}
{"name":"Matrix.inv_smul'","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix n n α\nk : Units α\nh : IsUnit A.det\n⊢ Eq (Inv.inv (HSMul.hSMul k A)) (HSMul.hSMul (Inv.inv k) (Inv.inv A))","decl":"theorem inv_smul' (k : αˣ) (h : IsUnit A.det) : (k • A)⁻¹ = k⁻¹ • A⁻¹ :=\n  inv_eq_left_inv (by simp [h, smul_smul])\n\n"}
{"name":"Matrix.inv_adjugate","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix n n α\nh : IsUnit A.det\n⊢ Eq (Inv.inv A.adjugate) (HSMul.hSMul (Inv.inv h.unit) A)","decl":"theorem inv_adjugate (A : Matrix n n α) (h : IsUnit A.det) : (adjugate A)⁻¹ = h.unit⁻¹ • A := by\n  refine inv_eq_left_inv ?_\n  rw [smul_mul, mul_adjugate, Units.smul_def, smul_smul, h.val_inv_mul, one_smul]\n\n"}
{"name":"Matrix.invOf_diagonal_eq","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\ninst✝⁴ : Fintype n\ninst✝³ : DecidableEq n\nα : Type u_2\ninst✝² : Semiring α\nv : n → α\ninst✝¹ : Invertible v\ninst✝ : Invertible (Matrix.diagonal v)\n⊢ Eq (Invertible.invOf (Matrix.diagonal v)) (Matrix.diagonal (Invertible.invOf v))","decl":"theorem invOf_diagonal_eq {α} [Semiring α] (v : n → α) [Invertible v] [Invertible (diagonal v)] :\n    ⅟ (diagonal v) = diagonal (⅟ v) := by\n  letI := diagonalInvertible v\n  -- Porting note: no longer need `haveI := Invertible.subsingleton (diagonal v)`\n  convert (rfl : ⅟ (diagonal v) = _)\n\n"}
{"name":"Matrix.diagonalInvertibleEquivInvertible_apply","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommRing α\nv : n → α\ninst✝ : Invertible (Matrix.diagonal v)\n⊢ Eq ((Matrix.diagonalInvertibleEquivInvertible v) inst✝) (Matrix.invertibleOfDiagonalInvertible v)","decl":"/-- Together `Matrix.diagonalInvertible` and `Matrix.invertibleOfDiagonalInvertible` form an\nequivalence, although both sides of the equiv are subsingleton anyway. -/\n@[simps]\ndef diagonalInvertibleEquivInvertible (v : n → α) : Invertible (diagonal v) ≃ Invertible v where\n  toFun := @invertibleOfDiagonalInvertible _ _ _ _ _ _\n  invFun := @diagonalInvertible _ _ _ _ _ _\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := Subsingleton.elim _ _\n\n"}
{"name":"Matrix.diagonalInvertibleEquivInvertible_symm_apply","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommRing α\nv : n → α\ninst✝ : Invertible v\n⊢ Eq ((Matrix.diagonalInvertibleEquivInvertible v).symm inst✝) (Matrix.diagonalInvertible v)","decl":"/-- Together `Matrix.diagonalInvertible` and `Matrix.invertibleOfDiagonalInvertible` form an\nequivalence, although both sides of the equiv are subsingleton anyway. -/\n@[simps]\ndef diagonalInvertibleEquivInvertible (v : n → α) : Invertible (diagonal v) ≃ Invertible v where\n  toFun := @invertibleOfDiagonalInvertible _ _ _ _ _ _\n  invFun := @diagonalInvertible _ _ _ _ _ _\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := Subsingleton.elim _ _\n\n"}
{"name":"Matrix.isUnit_diagonal","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nv : n → α\n⊢ Iff (IsUnit (Matrix.diagonal v)) (IsUnit v)","decl":"/-- When lowered to a prop, `Matrix.diagonalInvertibleEquivInvertible` forms an `iff`. -/\n@[simp]\ntheorem isUnit_diagonal {v : n → α} : IsUnit (diagonal v) ↔ IsUnit v := by\n  simp only [← nonempty_invertible_iff_isUnit,\n    (diagonalInvertibleEquivInvertible v).nonempty_congr]\n\n"}
{"name":"Matrix.inv_diagonal","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nv : n → α\n⊢ Eq (Inv.inv (Matrix.diagonal v)) (Matrix.diagonal (Ring.inverse v))","decl":"theorem inv_diagonal (v : n → α) : (diagonal v)⁻¹ = diagonal (Ring.inverse v) := by\n  rw [nonsing_inv_eq_ring_inverse]\n  by_cases h : IsUnit v\n  · have := isUnit_diagonal.mpr h\n    cases this.nonempty_invertible\n    cases h.nonempty_invertible\n    rw [Ring.inverse_invertible, Ring.inverse_invertible, invOf_diagonal_eq]\n  · have := isUnit_diagonal.not.mpr h\n    rw [Ring.inverse_non_unit _ h, Pi.zero_def, diagonal_zero, Ring.inverse_non_unit _ this]\n\n"}
{"name":"Matrix.inv_subsingleton","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\nα : Type v\ninst✝³ : CommRing α\ninst✝² : Subsingleton m\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nA : Matrix m m α\n⊢ Eq (Inv.inv A) (Matrix.diagonal fun i => Ring.inverse (A i i))","decl":"/-- The inverse of a 1×1 or 0×0 matrix is always diagonal.\n\nWhile we could write this as `of fun _ _ => Ring.inverse (A default default)` on the RHS, this is\nless useful because:\n\n* It wouldn't work for 0×0 matrices.\n* More things are true about diagonal matrices than constant matrices, and so more lemmas exist.\n\n`Matrix.diagonal_unique` can be used to reach this form, while `Ring.inverse_eq_inv` can be used\nto replace `Ring.inverse` with `⁻¹`.\n-/\n@[simp]\ntheorem inv_subsingleton [Subsingleton m] [Fintype m] [DecidableEq m] (A : Matrix m m α) :\n    A⁻¹ = diagonal fun i => Ring.inverse (A i i) := by\n  rw [inv_def, adjugate_subsingleton, smul_one_eq_diagonal]\n  congr! with i\n  exact det_eq_elem_of_subsingleton _ _\n\n"}
{"name":"Matrix.add_mul_mul_inv_eq_sub","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\nn : Type u'\nα : Type v\ninst✝⁴ : Fintype n\ninst✝³ : DecidableEq n\ninst✝² : CommRing α\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nA : Matrix n n α\nU : Matrix n m α\nC : Matrix m m α\nV : Matrix m n α\nhA : IsUnit A\nhC : IsUnit C\nhAC : IsUnit (HAdd.hAdd (Inv.inv C) (HMul.hMul (HMul.hMul V (Inv.inv A)) U))\n⊢ Eq (Inv.inv (HAdd.hAdd A (HMul.hMul (HMul.hMul U C) V))) (HSub.hSub (Inv.inv A) (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul (Inv.inv A) U) (Inv.inv (HAdd.hAdd (Inv.inv C) (HMul.hMul (HMul.hMul V (Inv.inv A)) U)))) V) (Inv.inv A)))","decl":"/-- The **Woodbury Identity** (`⁻¹` version). -/\ntheorem add_mul_mul_inv_eq_sub (hA : IsUnit A) (hC : IsUnit C) (hAC : IsUnit (C⁻¹ + V * A⁻¹ * U)) :\n    (A + U * C * V)⁻¹ = A⁻¹ - A⁻¹ * U * (C⁻¹ + V * A⁻¹ * U)⁻¹ * V * A⁻¹ := by\n  obtain ⟨_⟩ := hA.nonempty_invertible\n  obtain ⟨_⟩ := hC.nonempty_invertible\n  obtain ⟨iAC⟩ := hAC.nonempty_invertible\n  simp only [← invOf_eq_nonsing_inv] at iAC\n  letI := invertibleAddMulMul A U C V\n  simp only [← invOf_eq_nonsing_inv]\n  apply invOf_add_mul_mul\n\n"}
{"name":"Matrix.inv_inv_inv","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix n n α\n⊢ Eq (Inv.inv (Inv.inv (Inv.inv A))) (Inv.inv A)","decl":"@[simp]\ntheorem inv_inv_inv (A : Matrix n n α) : A⁻¹⁻¹⁻¹ = A⁻¹ := by\n  by_cases h : IsUnit A.det\n  · rw [nonsing_inv_nonsing_inv _ h]\n  · simp [nonsing_inv_apply_not_isUnit _ h]\n\n"}
{"name":"Matrix.inv_add_inv","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA B : Matrix n n α\nh : Iff (IsUnit A) (IsUnit B)\n⊢ Eq (HAdd.hAdd (Inv.inv A) (Inv.inv B)) (HMul.hMul (HMul.hMul (Inv.inv A) (HAdd.hAdd A B)) (Inv.inv B))","decl":"/-- The `Matrix` version of `inv_add_inv'` -/\ntheorem inv_add_inv {A B : Matrix n n α} (h : IsUnit A ↔ IsUnit B) :\n    A⁻¹ + B⁻¹ = A⁻¹ * (A + B) * B⁻¹ := by\n  simpa only [nonsing_inv_eq_ring_inverse] using Ring.inverse_add_inverse h\n\n"}
{"name":"Matrix.inv_sub_inv","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA B : Matrix n n α\nh : Iff (IsUnit A) (IsUnit B)\n⊢ Eq (HSub.hSub (Inv.inv A) (Inv.inv B)) (HMul.hMul (HMul.hMul (Inv.inv A) (HSub.hSub B A)) (Inv.inv B))","decl":"/-- The `Matrix` version of `inv_sub_inv'` -/\ntheorem inv_sub_inv {A B : Matrix n n α} (h : IsUnit A ↔ IsUnit B) :\n    A⁻¹ - B⁻¹ = A⁻¹ * (B - A) * B⁻¹ := by\n  simpa only [nonsing_inv_eq_ring_inverse] using Ring.inverse_sub_inverse h\n\n"}
{"name":"Matrix.mul_inv_rev","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA B : Matrix n n α\n⊢ Eq (Inv.inv (HMul.hMul A B)) (HMul.hMul (Inv.inv B) (Inv.inv A))","decl":"theorem mul_inv_rev (A B : Matrix n n α) : (A * B)⁻¹ = B⁻¹ * A⁻¹ := by\n  simp only [inv_def]\n  rw [Matrix.smul_mul, Matrix.mul_smul, smul_smul, det_mul, adjugate_mul_distrib,\n    Ring.mul_inverse_rev]\n\n"}
{"name":"Matrix.list_prod_inv_reverse","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nl : List (Matrix n n α)\n⊢ Eq (Inv.inv l.prod) (List.map Inv.inv l.reverse).prod","decl":"/-- A version of `List.prod_inv_reverse` for `Matrix.inv`. -/\ntheorem list_prod_inv_reverse : ∀ l : List (Matrix n n α), l.prod⁻¹ = (l.reverse.map Inv.inv).prod\n  | [] => by rw [List.reverse_nil, List.map_nil, List.prod_nil, inv_one]\n  | A::Xs => by\n    rw [List.reverse_cons', List.map_concat, List.prod_concat, List.prod_cons,\n      mul_inv_rev, list_prod_inv_reverse Xs]\n\n"}
{"name":"Matrix.det_smul_inv_mulVec_eq_cramer","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix n n α\nb : n → α\nh : IsUnit A.det\n⊢ Eq (HSMul.hSMul A.det ((Inv.inv A).mulVec b)) (A.cramer b)","decl":"/-- One form of **Cramer's rule**. See `Matrix.mulVec_cramer` for a stronger form. -/\n@[simp]\ntheorem det_smul_inv_mulVec_eq_cramer (A : Matrix n n α) (b : n → α) (h : IsUnit A.det) :\n    A.det • A⁻¹ *ᵥ b = cramer A b := by\n  rw [cramer_eq_adjugate_mulVec, A.nonsing_inv_apply h, ← smul_mulVec_assoc, smul_smul,\n    h.mul_val_inv, one_smul]\n\n"}
{"name":"Matrix.det_smul_inv_vecMul_eq_cramer_transpose","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"n : Type u'\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommRing α\nA : Matrix n n α\nb : n → α\nh : IsUnit A.det\n⊢ Eq (HSMul.hSMul A.det (Matrix.vecMul b (Inv.inv A))) (A.transpose.cramer b)","decl":"/-- One form of **Cramer's rule**. See `Matrix.mulVec_cramer` for a stronger form. -/\n@[simp]\ntheorem det_smul_inv_vecMul_eq_cramer_transpose (A : Matrix n n α) (b : n → α) (h : IsUnit A.det) :\n    A.det • b ᵥ* A⁻¹ = cramer Aᵀ b := by\n  rw [← A⁻¹.transpose_transpose, vecMul_transpose, transpose_nonsing_inv, ← det_transpose,\n    Aᵀ.det_smul_inv_mulVec_eq_cramer _ (isUnit_det_transpose A h)]\n\n"}
{"name":"Matrix.invOf_submatrix_equiv_eq","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\nn : Type u'\nα : Type v\ninst✝⁶ : Fintype n\ninst✝⁵ : DecidableEq n\ninst✝⁴ : CommRing α\ninst✝³ : Fintype m\ninst✝² : DecidableEq m\nA : Matrix m m α\ne₁ e₂ : Equiv n m\ninst✝¹ : Invertible A\ninst✝ : Invertible (A.submatrix ⇑e₁ ⇑e₂)\n⊢ Eq (Invertible.invOf (A.submatrix ⇑e₁ ⇑e₂)) ((Invertible.invOf A).submatrix ⇑e₂ ⇑e₁)","decl":"theorem invOf_submatrix_equiv_eq (A : Matrix m m α) (e₁ e₂ : n ≃ m) [Invertible A]\n    [Invertible (A.submatrix e₁ e₂)] : ⅟ (A.submatrix e₁ e₂) = (⅟ A).submatrix e₂ e₁ := by\n  letI := submatrixEquivInvertible A e₁ e₂\n  -- Porting note: no longer need `haveI := Invertible.subsingleton (A.submatrix e₁ e₂)`\n  convert (rfl : ⅟ (A.submatrix e₁ e₂) = _)\n\n"}
{"name":"Matrix.submatrixEquivInvertibleEquivInvertible_symm_apply","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\nn : Type u'\nα : Type v\ninst✝⁴ : Fintype n\ninst✝³ : DecidableEq n\ninst✝² : CommRing α\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nA : Matrix m m α\ne₁ e₂ : Equiv n m\nx✝ : Invertible A\n⊢ Eq ((A.submatrixEquivInvertibleEquivInvertible e₁ e₂).symm x✝) (A.submatrixEquivInvertible e₁ e₂)","decl":"/-- Together `Matrix.submatrixEquivInvertible` and\n`Matrix.invertibleOfSubmatrixEquivInvertible` form an equivalence, although both sides of the\nequiv are subsingleton anyway. -/\n@[simps]\ndef submatrixEquivInvertibleEquivInvertible (A : Matrix m m α) (e₁ e₂ : n ≃ m) :\n    Invertible (A.submatrix e₁ e₂) ≃ Invertible A where\n  toFun _ := invertibleOfSubmatrixEquivInvertible A e₁ e₂\n  invFun _ := submatrixEquivInvertible A e₁ e₂\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := Subsingleton.elim _ _\n\n"}
{"name":"Matrix.submatrixEquivInvertibleEquivInvertible_apply","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\nn : Type u'\nα : Type v\ninst✝⁴ : Fintype n\ninst✝³ : DecidableEq n\ninst✝² : CommRing α\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nA : Matrix m m α\ne₁ e₂ : Equiv n m\nx✝ : Invertible (A.submatrix ⇑e₁ ⇑e₂)\n⊢ Eq ((A.submatrixEquivInvertibleEquivInvertible e₁ e₂) x✝) (A.invertibleOfSubmatrixEquivInvertible e₁ e₂)","decl":"/-- Together `Matrix.submatrixEquivInvertible` and\n`Matrix.invertibleOfSubmatrixEquivInvertible` form an equivalence, although both sides of the\nequiv are subsingleton anyway. -/\n@[simps]\ndef submatrixEquivInvertibleEquivInvertible (A : Matrix m m α) (e₁ e₂ : n ≃ m) :\n    Invertible (A.submatrix e₁ e₂) ≃ Invertible A where\n  toFun _ := invertibleOfSubmatrixEquivInvertible A e₁ e₂\n  invFun _ := submatrixEquivInvertible A e₁ e₂\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := Subsingleton.elim _ _\n\n"}
{"name":"Matrix.isUnit_submatrix_equiv","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\nn : Type u'\nα : Type v\ninst✝⁴ : Fintype n\ninst✝³ : DecidableEq n\ninst✝² : CommRing α\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nA : Matrix m m α\ne₁ e₂ : Equiv n m\n⊢ Iff (IsUnit (A.submatrix ⇑e₁ ⇑e₂)) (IsUnit A)","decl":"/-- When lowered to a prop, `Matrix.invertibleOfSubmatrixEquivInvertible` forms an `iff`. -/\n@[simp]\ntheorem isUnit_submatrix_equiv {A : Matrix m m α} (e₁ e₂ : n ≃ m) :\n    IsUnit (A.submatrix e₁ e₂) ↔ IsUnit A := by\n  simp only [← nonempty_invertible_iff_isUnit,\n    (submatrixEquivInvertibleEquivInvertible A _ _).nonempty_congr]\n\n"}
{"name":"Matrix.inv_submatrix_equiv","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\nn : Type u'\nα : Type v\ninst✝⁴ : Fintype n\ninst✝³ : DecidableEq n\ninst✝² : CommRing α\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nA : Matrix m m α\ne₁ e₂ : Equiv n m\n⊢ Eq (Inv.inv (A.submatrix ⇑e₁ ⇑e₂)) ((Inv.inv A).submatrix ⇑e₂ ⇑e₁)","decl":"@[simp]\ntheorem inv_submatrix_equiv (A : Matrix m m α) (e₁ e₂ : n ≃ m) :\n    (A.submatrix e₁ e₂)⁻¹ = A⁻¹.submatrix e₂ e₁ := by\n  by_cases h : IsUnit A\n  · cases h.nonempty_invertible\n    letI := submatrixEquivInvertible A e₁ e₂\n    rw [← invOf_eq_nonsing_inv, ← invOf_eq_nonsing_inv, invOf_submatrix_equiv_eq A]\n  · have := (isUnit_submatrix_equiv e₁ e₂).not.mpr h\n    simp_rw [nonsing_inv_eq_ring_inverse, Ring.inverse_non_unit _ h, Ring.inverse_non_unit _ this,\n      submatrix_zero, Pi.zero_apply]\n\n"}
{"name":"Matrix.inv_reindex","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\nn : Type u'\nα : Type v\ninst✝⁴ : Fintype n\ninst✝³ : DecidableEq n\ninst✝² : CommRing α\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\ne₁ e₂ : Equiv n m\nA : Matrix n n α\n⊢ Eq (Inv.inv ((Matrix.reindex e₁ e₂) A)) ((Matrix.reindex e₂ e₁) (Inv.inv A))","decl":"theorem inv_reindex (e₁ e₂ : n ≃ m) (A : Matrix n n α) : (reindex e₁ e₂ A)⁻¹ = reindex e₂ e₁ A⁻¹ :=\n  inv_submatrix_equiv A e₁.symm e₂.symm\n\n"}
{"name":"Matrix.det_conj","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\nα : Type v\ninst✝² : CommRing α\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nM : Matrix m m α\nh : IsUnit M\nN : Matrix m m α\n⊢ Eq (HMul.hMul (HMul.hMul M N) (Inv.inv M)).det N.det","decl":"/-- A variant of `Matrix.det_units_conj`. -/\ntheorem det_conj {M : Matrix m m α} (h : IsUnit M) (N : Matrix m m α) :\n    det (M * N * M⁻¹) = det N := by rw [← h.unit_spec, ← coe_units_inv, det_units_conj]\n\n"}
{"name":"Matrix.det_conj'","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\nα : Type v\ninst✝² : CommRing α\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nM : Matrix m m α\nh : IsUnit M\nN : Matrix m m α\n⊢ Eq (HMul.hMul (HMul.hMul (Inv.inv M) N) M).det N.det","decl":"/-- A variant of `Matrix.det_units_conj'`. -/\ntheorem det_conj' {M : Matrix m m α} (h : IsUnit M) (N : Matrix m m α) :\n    det (M⁻¹ * N * M) = det N := by rw [← h.unit_spec, ← coe_units_inv, det_units_conj']\n\n"}
{"name":"Matrix.trace_conj","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\nα : Type v\ninst✝² : CommRing α\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nM : Matrix m m α\nh : IsUnit M\nN : Matrix m m α\n⊢ Eq (HMul.hMul (HMul.hMul M N) (Inv.inv M)).trace N.trace","decl":"/-- A variant of `Matrix.trace_units_conj`. -/\ntheorem trace_conj {M : Matrix m m α} (h : IsUnit M) (N : Matrix m m α) :\n    trace (M * N * M⁻¹) = trace N := by rw [← h.unit_spec, ← coe_units_inv, trace_units_conj]\n\n"}
{"name":"Matrix.trace_conj'","module":"Mathlib.LinearAlgebra.Matrix.NonsingularInverse","initialProofState":"m : Type u\nα : Type v\ninst✝² : CommRing α\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nM : Matrix m m α\nh : IsUnit M\nN : Matrix m m α\n⊢ Eq (HMul.hMul (HMul.hMul (Inv.inv M) N) M).trace N.trace","decl":"/-- A variant of `Matrix.trace_units_conj'`. -/\ntheorem trace_conj' {M : Matrix m m α} (h : IsUnit M) (N : Matrix m m α) :\n    trace (M⁻¹ * N * M) = trace N := by rw [← h.unit_spec, ← coe_units_inv, trace_units_conj']\n\n"}
