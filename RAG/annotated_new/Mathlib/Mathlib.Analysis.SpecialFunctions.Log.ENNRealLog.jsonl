{"name":"ENNReal.log_zero","module":"Mathlib.Analysis.SpecialFunctions.Log.ENNRealLog","initialProofState":"⊢ Eq (ENNReal.log 0) Bot.bot","decl":"@[simp] lemma log_zero : log 0 = ⊥ := if_pos rfl\n"}
{"name":"ENNReal.log_one","module":"Mathlib.Analysis.SpecialFunctions.Log.ENNRealLog","initialProofState":"⊢ Eq (ENNReal.log 1) 0","decl":"@[simp] lemma log_one : log 1 = 0 := by simp [log]\n"}
{"name":"ENNReal.log_top","module":"Mathlib.Analysis.SpecialFunctions.Log.ENNRealLog","initialProofState":"⊢ Eq Top.top.log Top.top","decl":"@[simp] lemma log_top : log ⊤ = ⊤ := rfl\n\n"}
{"name":"ENNReal.log_ofReal","module":"Mathlib.Analysis.SpecialFunctions.Log.ENNRealLog","initialProofState":"x : Real\n⊢ Eq (ENNReal.ofReal x).log (ite (LE.le x 0) Bot.bot ↑(Real.log x))","decl":"@[simp]\nlemma log_ofReal (x : ℝ) : log (ENNReal.ofReal x) = if x ≤ 0 then ⊥ else ↑(Real.log x) := by\n  simp only [log, ENNReal.none_eq_top, ENNReal.ofReal_ne_top, IsEmpty.forall_iff,\n    ENNReal.ofReal_eq_zero, EReal.coe_ennreal_ofReal, if_false]\n  split_ifs with h_nonpos\n  · rfl\n  · rw [ENNReal.toReal_ofReal (not_le.mp h_nonpos).le]\n\n"}
{"name":"ENNReal.log_ofReal_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Log.ENNRealLog","initialProofState":"x : Real\nhx : LT.lt 0 x\n⊢ Eq (ENNReal.ofReal x).log ↑(Real.log x)","decl":"lemma log_ofReal_of_pos {x : ℝ} (hx : 0 < x) : log (ENNReal.ofReal x) = Real.log x := by\n  rw [log_ofReal, if_neg hx.not_le]\n\n"}
{"name":"ENNReal.log_pos_real","module":"Mathlib.Analysis.SpecialFunctions.Log.ENNRealLog","initialProofState":"x : ENNReal\nh : Ne x 0\nh' : Ne x Top.top\n⊢ Eq x.log ↑(Real.log x.toReal)","decl":"theorem log_pos_real {x : ℝ≥0∞} (h : x ≠ 0) (h' : x ≠ ⊤) :\n    log x = Real.log (ENNReal.toReal x) := by simp [log, h, h']\n\n"}
{"name":"ENNReal.log_pos_real'","module":"Mathlib.Analysis.SpecialFunctions.Log.ENNRealLog","initialProofState":"x : ENNReal\nh : LT.lt 0 x.toReal\n⊢ Eq x.log ↑(Real.log x.toReal)","decl":"theorem log_pos_real' {x : ℝ≥0∞} (h : 0 < x.toReal) :\n    log x = Real.log (ENNReal.toReal x) := by\n  simp [log, (ENNReal.toReal_pos_iff.1 h).1.ne', (ENNReal.toReal_pos_iff.1 h).2.ne]\n\n"}
{"name":"ENNReal.log_of_nnreal","module":"Mathlib.Analysis.SpecialFunctions.Log.ENNRealLog","initialProofState":"x : NNReal\nh : Ne x 0\n⊢ Eq (↑x).log ↑(Real.log ↑x)","decl":"theorem log_of_nnreal {x : ℝ≥0} (h : x ≠ 0) :\n    log (x : ℝ≥0∞) = Real.log x := by simp [log, h]\n\n"}
{"name":"ENNReal.log_strictMono","module":"Mathlib.Analysis.SpecialFunctions.Log.ENNRealLog","initialProofState":"⊢ StrictMono ENNReal.log","decl":"theorem log_strictMono : StrictMono log := by\n  intro x y h\n  unfold log\n  rcases ENNReal.trichotomy x with (rfl | rfl | x_real)\n  · rcases ENNReal.trichotomy y with (rfl | rfl | y_real)\n    · exfalso; exact lt_irrefl 0 h\n    · simp\n    · simp [(ENNReal.toReal_pos_iff.1 y_real).1.ne',\n        (ENNReal.toReal_pos_iff.1 y_real).2.ne, EReal.bot_lt_coe]\n  · exfalso; exact not_top_lt h\n  · simp only [(ENNReal.toReal_pos_iff.1 x_real).1.ne',\n      (ENNReal.toReal_pos_iff.1 x_real).2.ne, if_false]\n    rcases ENNReal.trichotomy y with (rfl | rfl | y_real)\n    · exfalso; rw [← ENNReal.bot_eq_zero] at h; exact not_lt_bot h\n    · simp\n    · simp only [(ENNReal.toReal_pos_iff.1 y_real).1.ne', ↓reduceIte,\n        (ENNReal.toReal_pos_iff.1 y_real).2.ne, EReal.coe_lt_coe_iff]\n      apply Real.log_lt_log x_real\n      exact (ENNReal.toReal_lt_toReal (ENNReal.toReal_pos_iff.1 x_real).2.ne\n        (ENNReal.toReal_pos_iff.1 y_real).2.ne).2 h\n\n"}
{"name":"ENNReal.log_monotone","module":"Mathlib.Analysis.SpecialFunctions.Log.ENNRealLog","initialProofState":"⊢ Monotone ENNReal.log","decl":"theorem log_monotone : Monotone log := log_strictMono.monotone\n\n"}
{"name":"ENNReal.log_injective","module":"Mathlib.Analysis.SpecialFunctions.Log.ENNRealLog","initialProofState":"⊢ Function.Injective ENNReal.log","decl":"theorem log_injective : Function.Injective log := log_strictMono.injective\n\n"}
{"name":"ENNReal.log_surjective","module":"Mathlib.Analysis.SpecialFunctions.Log.ENNRealLog","initialProofState":"⊢ Function.Surjective ENNReal.log","decl":"theorem log_surjective : Function.Surjective log := by\n  intro y\n  cases' eq_bot_or_bot_lt y with y_bot y_nbot\n  · exact y_bot ▸ ⟨⊥, log_zero⟩\n  cases' eq_top_or_lt_top y with y_top y_ntop\n  · exact y_top ▸ ⟨⊤, log_top⟩\n  use ENNReal.ofReal (Real.exp y.toReal)\n  have exp_y_pos := not_le_of_lt (Real.exp_pos y.toReal)\n  simp only [log, ofReal_eq_zero, exp_y_pos, ↓reduceIte, ofReal_ne_top,\n    ENNReal.toReal_ofReal (Real.exp_pos y.toReal).le, Real.log_exp y.toReal]\n  exact EReal.coe_toReal y_ntop.ne y_nbot.ne'\n\n"}
{"name":"ENNReal.log_bijective","module":"Mathlib.Analysis.SpecialFunctions.Log.ENNRealLog","initialProofState":"⊢ Function.Bijective ENNReal.log","decl":"theorem log_bijective : Function.Bijective log := ⟨log_injective, log_surjective⟩\n\n"}
{"name":"ENNReal.log_eq_iff","module":"Mathlib.Analysis.SpecialFunctions.Log.ENNRealLog","initialProofState":"x y : ENNReal\n⊢ Iff (Eq x.log y.log) (Eq x y)","decl":"@[simp]\ntheorem log_eq_iff {x y : ℝ≥0∞} : log x = log y ↔ x = y :=\n  log_injective.eq_iff\n\n"}
{"name":"ENNReal.log_eq_bot_iff","module":"Mathlib.Analysis.SpecialFunctions.Log.ENNRealLog","initialProofState":"x : ENNReal\n⊢ Iff (Eq x.log Bot.bot) (Eq x 0)","decl":"@[simp] theorem log_eq_bot_iff {x : ℝ≥0∞} : log x = ⊥ ↔ x = 0 := log_zero ▸ @log_eq_iff x 0\n\n"}
{"name":"ENNReal.log_eq_one_iff","module":"Mathlib.Analysis.SpecialFunctions.Log.ENNRealLog","initialProofState":"x : ENNReal\n⊢ Iff (Eq x.log 0) (Eq x 1)","decl":"@[simp] theorem log_eq_one_iff {x : ℝ≥0∞} : log x = 0 ↔ x = 1 := log_one ▸ @log_eq_iff x 1\n\n"}
{"name":"ENNReal.log_eq_top_iff","module":"Mathlib.Analysis.SpecialFunctions.Log.ENNRealLog","initialProofState":"x : ENNReal\n⊢ Iff (Eq x.log Top.top) (Eq x Top.top)","decl":"@[simp] theorem log_eq_top_iff {x : ℝ≥0∞} : log x = ⊤ ↔ x = ⊤ := log_top ▸ @log_eq_iff x ⊤\n\n"}
{"name":"ENNReal.log_lt_log_iff","module":"Mathlib.Analysis.SpecialFunctions.Log.ENNRealLog","initialProofState":"x y : ENNReal\n⊢ Iff (LT.lt x.log y.log) (LT.lt x y)","decl":"@[simp] lemma log_lt_log_iff {x y : ℝ≥0∞} : log x < log y ↔ x < y := log_strictMono.lt_iff_lt\n\n"}
{"name":"ENNReal.bot_lt_log_iff","module":"Mathlib.Analysis.SpecialFunctions.Log.ENNRealLog","initialProofState":"x : ENNReal\n⊢ Iff (LT.lt Bot.bot x.log) (LT.lt 0 x)","decl":"@[simp] lemma bot_lt_log_iff {x : ℝ≥0∞} : ⊥ < log x ↔ 0 < x := log_zero ▸ @log_lt_log_iff 0 x\n\n"}
{"name":"ENNReal.log_lt_top_iff","module":"Mathlib.Analysis.SpecialFunctions.Log.ENNRealLog","initialProofState":"x : ENNReal\n⊢ Iff (LT.lt x.log Top.top) (LT.lt x Top.top)","decl":"@[simp] lemma log_lt_top_iff {x : ℝ≥0∞} : log x < ⊤ ↔ x < ⊤ := log_top ▸ @log_lt_log_iff x ⊤\n\n"}
{"name":"ENNReal.log_lt_zero_iff","module":"Mathlib.Analysis.SpecialFunctions.Log.ENNRealLog","initialProofState":"x : ENNReal\n⊢ Iff (LT.lt x.log 0) (LT.lt x 1)","decl":"@[simp] lemma log_lt_zero_iff {x : ℝ≥0∞} : log x < 0 ↔ x < 1 := log_one ▸ @log_lt_log_iff x 1\n\n"}
{"name":"ENNReal.zero_lt_log_iff","module":"Mathlib.Analysis.SpecialFunctions.Log.ENNRealLog","initialProofState":"x : ENNReal\n⊢ Iff (LT.lt 0 x.log) (LT.lt 1 x)","decl":"@[simp] lemma zero_lt_log_iff {x : ℝ≥0∞} : 0 < log x ↔ 1 < x := log_one ▸ @log_lt_log_iff 1 x\n\n"}
{"name":"ENNReal.log_le_log_iff","module":"Mathlib.Analysis.SpecialFunctions.Log.ENNRealLog","initialProofState":"x y : ENNReal\n⊢ Iff (LE.le x.log y.log) (LE.le x y)","decl":"@[simp] lemma log_le_log_iff {x y : ℝ≥0∞} : log x ≤ log y ↔ x ≤ y := log_strictMono.le_iff_le\n\n"}
{"name":"ENNReal.log_le_zero_iff","module":"Mathlib.Analysis.SpecialFunctions.Log.ENNRealLog","initialProofState":"x : ENNReal\n⊢ Iff (LE.le x.log 0) (LE.le x 1)","decl":"@[simp] lemma log_le_zero_iff {x : ℝ≥0∞} : log x ≤ 0 ↔ x ≤ 1 := log_one ▸ @log_le_log_iff x 1\n\n"}
{"name":"ENNReal.zero_le_log_iff","module":"Mathlib.Analysis.SpecialFunctions.Log.ENNRealLog","initialProofState":"x : ENNReal\n⊢ Iff (LE.le 0 x.log) (LE.le 1 x)","decl":"@[simp] lemma zero_le_log_iff {x : ℝ≥0∞} : 0 ≤ log x ↔ 1 ≤ x := log_one ▸ @log_le_log_iff 1 x\n\n"}
{"name":"ENNReal.log_mul_add","module":"Mathlib.Analysis.SpecialFunctions.Log.ENNRealLog","initialProofState":"x y : ENNReal\n⊢ Eq (HMul.hMul x y).log (HAdd.hAdd x.log y.log)","decl":"theorem log_mul_add {x y : ℝ≥0∞} : log (x * y) = log x + log y := by\n  rcases ENNReal.trichotomy x with (rfl | rfl | x_real)\n  · simp\n  · rw [log_top]\n    rcases ENNReal.trichotomy y with (rfl | rfl | y_real)\n    · rw [mul_zero, log_zero, EReal.add_bot]\n    · simp\n    · rw [log_pos_real' y_real, ENNReal.top_mul', EReal.top_add_coe, log_eq_top_iff]\n      simp only [ite_eq_right_iff, zero_ne_top, imp_false]\n      exact (ENNReal.toReal_pos_iff.1 y_real).1.ne'\n  · rw [log_pos_real' x_real]\n    rcases ENNReal.trichotomy y with (rfl | rfl | y_real)\n    · simp\n    · simp [(ENNReal.toReal_pos_iff.1 x_real).1.ne']\n    · rw_mod_cast [log_pos_real', log_pos_real' y_real, ENNReal.toReal_mul]\n      · exact Real.log_mul x_real.ne' y_real.ne'\n      rw [toReal_mul]\n      positivity\n\n"}
{"name":"ENNReal.log_pow","module":"Mathlib.Analysis.SpecialFunctions.Log.ENNRealLog","initialProofState":"x : ENNReal\nn : Nat\n⊢ Eq (HPow.hPow x n).log (HMul.hMul (↑n) x.log)","decl":"theorem log_pow {x : ℝ≥0∞} {n : ℕ} : log (x ^ n) = n * log x := by\n  cases' Nat.eq_zero_or_pos n with n_zero n_pos\n  · simp [n_zero, pow_zero x]\n  rcases ENNReal.trichotomy x with (rfl | rfl | x_real)\n  · rw [zero_pow n_pos.ne', log_zero, EReal.mul_bot_of_pos (Nat.cast_pos'.2 n_pos)]\n  · rw [ENNReal.top_pow n_pos, log_top, EReal.mul_top_of_pos (Nat.cast_pos'.2 n_pos)]\n  · replace x_real := ENNReal.toReal_pos_iff.1 x_real\n    simp only [log, pow_eq_zero_iff', x_real.1.ne', false_and, ↓reduceIte, pow_eq_top_iff,\n      x_real.2.ne, toReal_pow, Real.log_pow, EReal.coe_mul, EReal.coe_coe_eq_natCast]\n\n"}
{"name":"ENNReal.log_rpow","module":"Mathlib.Analysis.SpecialFunctions.Log.ENNRealLog","initialProofState":"x : ENNReal\ny : Real\n⊢ Eq (HPow.hPow x y).log (HMul.hMul (↑y) x.log)","decl":"theorem log_rpow {x : ℝ≥0∞} {y : ℝ} : log (x ^ y) = y * log x := by\n  rcases lt_trichotomy y 0 with (y_neg | rfl | y_pos)\n  · rcases ENNReal.trichotomy x with (rfl | rfl | x_real)\n    · simp only [ENNReal.zero_rpow_def y, not_lt_of_lt y_neg, y_neg.ne, if_false, log_top,\n        log_zero, EReal.coe_mul_bot_of_neg y_neg]\n    · rw [ENNReal.top_rpow_of_neg y_neg, log_zero, log_top, EReal.coe_mul_top_of_neg y_neg]\n    · have x_ne_zero := (ENNReal.toReal_pos_iff.1 x_real).1.ne'\n      have x_ne_top := (ENNReal.toReal_pos_iff.1 x_real).2.ne\n      simp only [log, rpow_eq_zero_iff, x_ne_zero, false_and, x_ne_top, or_self, ↓reduceIte,\n        rpow_eq_top_iff]\n      norm_cast\n      exact ENNReal.toReal_rpow x y ▸ Real.log_rpow x_real y\n  · simp\n  · rcases ENNReal.trichotomy x with (rfl | rfl | x_real)\n    · rw [ENNReal.zero_rpow_of_pos y_pos, log_zero, EReal.mul_bot_of_pos]; norm_cast\n    · rw [ENNReal.top_rpow_of_pos y_pos, log_top, EReal.mul_top_of_pos]; norm_cast\n    · have x_ne_zero := (ENNReal.toReal_pos_iff.1 x_real).1.ne'\n      have x_ne_top := (ENNReal.toReal_pos_iff.1 x_real).2.ne\n      simp only [log, rpow_eq_zero_iff, x_ne_zero, false_and, x_ne_top, or_self, ↓reduceIte,\n        rpow_eq_top_iff]\n      norm_cast\n      exact ENNReal.toReal_rpow x y ▸ Real.log_rpow x_real y\n\n"}
{"name":"ENNReal.log_inv","module":"Mathlib.Analysis.SpecialFunctions.Log.ENNRealLog","initialProofState":"x : ENNReal\n⊢ Eq (Inv.inv x).log (Neg.neg x.log)","decl":"lemma log_inv {x : ℝ≥0∞} : log x⁻¹ = - log x := by\n  simp [← rpow_neg_one, log_rpow]\n\n"}
