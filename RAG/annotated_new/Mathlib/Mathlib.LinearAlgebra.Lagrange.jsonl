{"name":"Polynomial.eq_zero_of_degree_lt_of_eval_finset_eq_zero","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nf : Polynomial R\ns : Finset R\ndegree_f_lt : LT.lt f.degree ↑s.card\neval_f : ∀ (x : R), Membership.mem s x → Eq (Polynomial.eval x f) 0\n⊢ Eq f 0","decl":"theorem eq_zero_of_degree_lt_of_eval_finset_eq_zero (degree_f_lt : f.degree < #s)\n    (eval_f : ∀ x ∈ s, f.eval x = 0) : f = 0 := by\n  rw [← mem_degreeLT] at degree_f_lt\n  simp_rw [eval_eq_sum_degreeLTEquiv degree_f_lt] at eval_f\n  rw [← degreeLTEquiv_eq_zero_iff_eq_zero degree_f_lt]\n  exact\n    Matrix.eq_zero_of_forall_index_sum_mul_pow_eq_zero\n      (Injective.comp (Embedding.subtype _).inj' (equivFinOfCardEq (card_coe _)).symm.injective)\n      fun _ => eval_f _ (Finset.coe_mem _)\n\n"}
{"name":"Polynomial.eq_of_degree_sub_lt_of_eval_finset_eq","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nf g : Polynomial R\ns : Finset R\ndegree_fg_lt : LT.lt (HSub.hSub f g).degree ↑s.card\neval_fg : ∀ (x : R), Membership.mem s x → Eq (Polynomial.eval x f) (Polynomial.eval x g)\n⊢ Eq f g","decl":"theorem eq_of_degree_sub_lt_of_eval_finset_eq (degree_fg_lt : (f - g).degree < #s)\n    (eval_fg : ∀ x ∈ s, f.eval x = g.eval x) : f = g := by\n  rw [← sub_eq_zero]\n  refine eq_zero_of_degree_lt_of_eval_finset_eq_zero _ degree_fg_lt ?_\n  simp_rw [eval_sub, sub_eq_zero]\n  exact eval_fg\n\n"}
{"name":"Polynomial.eq_of_degrees_lt_of_eval_finset_eq","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nf g : Polynomial R\ns : Finset R\ndegree_f_lt : LT.lt f.degree ↑s.card\ndegree_g_lt : LT.lt g.degree ↑s.card\neval_fg : ∀ (x : R), Membership.mem s x → Eq (Polynomial.eval x f) (Polynomial.eval x g)\n⊢ Eq f g","decl":"theorem eq_of_degrees_lt_of_eval_finset_eq (degree_f_lt : f.degree < #s)\n    (degree_g_lt : g.degree < #s) (eval_fg : ∀ x ∈ s, f.eval x = g.eval x) : f = g := by\n  rw [← mem_degreeLT] at degree_f_lt degree_g_lt\n  refine eq_of_degree_sub_lt_of_eval_finset_eq _ ?_ eval_fg\n  rw [← mem_degreeLT]; exact Submodule.sub_mem _ degree_f_lt degree_g_lt\n\n"}
{"name":"Polynomial.eq_of_degree_le_of_eval_finset_eq","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nf g : Polynomial R\ns : Finset R\nh_deg_le : LE.le f.degree ↑s.card\nh_deg_eq : Eq f.degree g.degree\nhlc : Eq f.leadingCoeff g.leadingCoeff\nh_eval : ∀ (x : R), Membership.mem s x → Eq (Polynomial.eval x f) (Polynomial.eval x g)\n⊢ Eq f g","decl":"/--\nTwo polynomials, with the same degree and leading coefficient, which have the same evaluation\non a set of distinct values with cardinality equal to the degree, are equal.\n-/\ntheorem eq_of_degree_le_of_eval_finset_eq\n    (h_deg_le : f.degree ≤ #s)\n    (h_deg_eq : f.degree = g.degree)\n    (hlc : f.leadingCoeff = g.leadingCoeff)\n    (h_eval : ∀ x ∈ s, f.eval x = g.eval x) :\n    f = g := by\n  rcases eq_or_ne f 0 with rfl | hf\n  · rwa [degree_zero, eq_comm, degree_eq_bot, eq_comm] at h_deg_eq\n  · exact eq_of_degree_sub_lt_of_eval_finset_eq s\n      (lt_of_lt_of_le (degree_sub_lt h_deg_eq hf hlc) h_deg_le) h_eval\n\n"}
{"name":"Polynomial.eq_zero_of_degree_lt_of_eval_index_eq_zero","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nf : Polynomial R\nι : Type u_2\nv : ι → R\ns : Finset ι\nhvs : Set.InjOn v ↑s\ndegree_f_lt : LT.lt f.degree ↑s.card\neval_f : ∀ (i : ι), Membership.mem s i → Eq (Polynomial.eval (v i) f) 0\n⊢ Eq f 0","decl":"theorem eq_zero_of_degree_lt_of_eval_index_eq_zero (hvs : Set.InjOn v s)\n    (degree_f_lt : f.degree < #s) (eval_f : ∀ i ∈ s, f.eval (v i) = 0) : f = 0 := by\n  classical\n    rw [← card_image_of_injOn hvs] at degree_f_lt\n    refine eq_zero_of_degree_lt_of_eval_finset_eq_zero _ degree_f_lt ?_\n    intro x hx\n    rcases mem_image.mp hx with ⟨_, hj, rfl⟩\n    exact eval_f _ hj\n\n"}
{"name":"Polynomial.eq_of_degree_sub_lt_of_eval_index_eq","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nf g : Polynomial R\nι : Type u_2\nv : ι → R\ns : Finset ι\nhvs : Set.InjOn v ↑s\ndegree_fg_lt : LT.lt (HSub.hSub f g).degree ↑s.card\neval_fg : ∀ (i : ι), Membership.mem s i → Eq (Polynomial.eval (v i) f) (Polynomial.eval (v i) g)\n⊢ Eq f g","decl":"theorem eq_of_degree_sub_lt_of_eval_index_eq (hvs : Set.InjOn v s)\n    (degree_fg_lt : (f - g).degree < #s) (eval_fg : ∀ i ∈ s, f.eval (v i) = g.eval (v i)) :\n    f = g := by\n  rw [← sub_eq_zero]\n  refine eq_zero_of_degree_lt_of_eval_index_eq_zero _ hvs degree_fg_lt ?_\n  simp_rw [eval_sub, sub_eq_zero]\n  exact eval_fg\n\n"}
{"name":"Polynomial.eq_of_degrees_lt_of_eval_index_eq","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nf g : Polynomial R\nι : Type u_2\nv : ι → R\ns : Finset ι\nhvs : Set.InjOn v ↑s\ndegree_f_lt : LT.lt f.degree ↑s.card\ndegree_g_lt : LT.lt g.degree ↑s.card\neval_fg : ∀ (i : ι), Membership.mem s i → Eq (Polynomial.eval (v i) f) (Polynomial.eval (v i) g)\n⊢ Eq f g","decl":"theorem eq_of_degrees_lt_of_eval_index_eq (hvs : Set.InjOn v s) (degree_f_lt : f.degree < #s)\n    (degree_g_lt : g.degree < #s) (eval_fg : ∀ i ∈ s, f.eval (v i) = g.eval (v i)) : f = g := by\n  refine eq_of_degree_sub_lt_of_eval_index_eq _ hvs ?_ eval_fg\n  rw [← mem_degreeLT] at degree_f_lt degree_g_lt ⊢\n  exact Submodule.sub_mem _ degree_f_lt degree_g_lt\n\n"}
{"name":"Polynomial.eq_of_degree_le_of_eval_index_eq","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nf g : Polynomial R\nι : Type u_2\nv : ι → R\ns : Finset ι\nhvs : Set.InjOn v ↑s\nh_deg_le : LE.le f.degree ↑s.card\nh_deg_eq : Eq f.degree g.degree\nhlc : Eq f.leadingCoeff g.leadingCoeff\nh_eval : ∀ (i : ι), Membership.mem s i → Eq (Polynomial.eval (v i) f) (Polynomial.eval (v i) g)\n⊢ Eq f g","decl":"theorem eq_of_degree_le_of_eval_index_eq (hvs : Set.InjOn v s)\n    (h_deg_le : f.degree ≤ #s)\n    (h_deg_eq : f.degree = g.degree)\n    (hlc : f.leadingCoeff = g.leadingCoeff)\n    (h_eval : ∀ i ∈ s, f.eval (v i) = g.eval (v i)) : f = g := by\n  rcases eq_or_ne f 0 with rfl | hf\n  · rwa [degree_zero, eq_comm, degree_eq_bot, eq_comm] at h_deg_eq\n  · exact eq_of_degree_sub_lt_of_eval_index_eq s hvs\n      (lt_of_lt_of_le (degree_sub_lt h_deg_eq hf hlc) h_deg_le)\n      h_eval\n\n"}
{"name":"Lagrange.basisDivisor_self","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝ : Field F\nx : F\n⊢ Eq (Lagrange.basisDivisor x x) 0","decl":"theorem basisDivisor_self : basisDivisor x x = 0 := by\n  simp only [basisDivisor, sub_self, inv_zero, map_zero, zero_mul]\n\n"}
{"name":"Lagrange.basisDivisor_inj","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝ : Field F\nx y : F\nhxy : Eq (Lagrange.basisDivisor x y) 0\n⊢ Eq x y","decl":"theorem basisDivisor_inj (hxy : basisDivisor x y = 0) : x = y := by\n  simp_rw [basisDivisor, mul_eq_zero, X_sub_C_ne_zero, or_false, C_eq_zero, inv_eq_zero,\n    sub_eq_zero] at hxy\n  exact hxy\n\n"}
{"name":"Lagrange.basisDivisor_eq_zero_iff","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝ : Field F\nx y : F\n⊢ Iff (Eq (Lagrange.basisDivisor x y) 0) (Eq x y)","decl":"@[simp]\ntheorem basisDivisor_eq_zero_iff : basisDivisor x y = 0 ↔ x = y :=\n  ⟨basisDivisor_inj, fun H => H ▸ basisDivisor_self⟩\n\n"}
{"name":"Lagrange.basisDivisor_ne_zero_iff","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝ : Field F\nx y : F\n⊢ Iff (Ne (Lagrange.basisDivisor x y) 0) (Ne x y)","decl":"theorem basisDivisor_ne_zero_iff : basisDivisor x y ≠ 0 ↔ x ≠ y := by\n  rw [Ne, basisDivisor_eq_zero_iff]\n\n"}
{"name":"Lagrange.degree_basisDivisor_of_ne","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝ : Field F\nx y : F\nhxy : Ne x y\n⊢ Eq (Lagrange.basisDivisor x y).degree 1","decl":"theorem degree_basisDivisor_of_ne (hxy : x ≠ y) : (basisDivisor x y).degree = 1 := by\n  rw [basisDivisor, degree_mul, degree_X_sub_C, degree_C, zero_add]\n  exact inv_ne_zero (sub_ne_zero_of_ne hxy)\n\n"}
{"name":"Lagrange.degree_basisDivisor_self","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝ : Field F\nx : F\n⊢ Eq (Lagrange.basisDivisor x x).degree Bot.bot","decl":"@[simp]\ntheorem degree_basisDivisor_self : (basisDivisor x x).degree = ⊥ := by\n  rw [basisDivisor_self, degree_zero]\n\n"}
{"name":"Lagrange.natDegree_basisDivisor_self","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝ : Field F\nx : F\n⊢ Eq (Lagrange.basisDivisor x x).natDegree 0","decl":"theorem natDegree_basisDivisor_self : (basisDivisor x x).natDegree = 0 := by\n  rw [basisDivisor_self, natDegree_zero]\n\n"}
{"name":"Lagrange.natDegree_basisDivisor_of_ne","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝ : Field F\nx y : F\nhxy : Ne x y\n⊢ Eq (Lagrange.basisDivisor x y).natDegree 1","decl":"theorem natDegree_basisDivisor_of_ne (hxy : x ≠ y) : (basisDivisor x y).natDegree = 1 :=\n  natDegree_eq_of_degree_eq_some (degree_basisDivisor_of_ne hxy)\n\n"}
{"name":"Lagrange.eval_basisDivisor_right","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝ : Field F\nx y : F\n⊢ Eq (Polynomial.eval y (Lagrange.basisDivisor x y)) 0","decl":"@[simp]\ntheorem eval_basisDivisor_right : eval y (basisDivisor x y) = 0 := by\n  simp only [basisDivisor, eval_mul, eval_C, eval_sub, eval_X, sub_self, mul_zero]\n\n"}
{"name":"Lagrange.eval_basisDivisor_left_of_ne","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝ : Field F\nx y : F\nhxy : Ne x y\n⊢ Eq (Polynomial.eval x (Lagrange.basisDivisor x y)) 1","decl":"theorem eval_basisDivisor_left_of_ne (hxy : x ≠ y) : eval x (basisDivisor x y) = 1 := by\n  simp only [basisDivisor, eval_mul, eval_C, eval_sub, eval_X]\n  exact inv_mul_cancel₀ (sub_ne_zero_of_ne hxy)\n\n"}
{"name":"Lagrange.basis_empty","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\nv : ι → F\ni : ι\n⊢ Eq (Lagrange.basis EmptyCollection.emptyCollection v i) 1","decl":"@[simp]\ntheorem basis_empty : Lagrange.basis ∅ v i = 1 :=\n  rfl\n\n"}
{"name":"Lagrange.basis_singleton","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\nv : ι → F\ni : ι\n⊢ Eq (Lagrange.basis (Singleton.singleton i) v i) 1","decl":"@[simp]\ntheorem basis_singleton (i : ι) : Lagrange.basis {i} v i = 1 := by\n  rw [Lagrange.basis, erase_singleton, prod_empty]\n\n"}
{"name":"Lagrange.basis_pair_left","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\nv : ι → F\ni j : ι\nhij : Ne i j\n⊢ Eq (Lagrange.basis (Insert.insert i (Singleton.singleton j)) v i) (Lagrange.basisDivisor (v i) (v j))","decl":"@[simp]\ntheorem basis_pair_left (hij : i ≠ j) : Lagrange.basis {i, j} v i = basisDivisor (v i) (v j) := by\n  simp only [Lagrange.basis, hij, erase_insert_eq_erase, erase_eq_of_not_mem, mem_singleton,\n    not_false_iff, prod_singleton]\n\n"}
{"name":"Lagrange.basis_pair_right","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\nv : ι → F\ni j : ι\nhij : Ne i j\n⊢ Eq (Lagrange.basis (Insert.insert i (Singleton.singleton j)) v j) (Lagrange.basisDivisor (v j) (v i))","decl":"@[simp]\ntheorem basis_pair_right (hij : i ≠ j) : Lagrange.basis {i, j} v j = basisDivisor (v j) (v i) := by\n  rw [pair_comm]\n  exact basis_pair_left hij.symm\n\n"}
{"name":"Lagrange.basis_ne_zero","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\ns : Finset ι\nv : ι → F\ni : ι\nhvs : Set.InjOn v ↑s\nhi : Membership.mem s i\n⊢ Ne (Lagrange.basis s v i) 0","decl":"theorem basis_ne_zero (hvs : Set.InjOn v s) (hi : i ∈ s) : Lagrange.basis s v i ≠ 0 := by\n  simp_rw [Lagrange.basis, prod_ne_zero_iff, Ne, mem_erase]\n  rintro j ⟨hij, hj⟩\n  rw [basisDivisor_eq_zero_iff, hvs.eq_iff hi hj]\n  exact hij.symm\n\n"}
{"name":"Lagrange.eval_basis_self","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\ns : Finset ι\nv : ι → F\ni : ι\nhvs : Set.InjOn v ↑s\nhi : Membership.mem s i\n⊢ Eq (Polynomial.eval (v i) (Lagrange.basis s v i)) 1","decl":"@[simp]\ntheorem eval_basis_self (hvs : Set.InjOn v s) (hi : i ∈ s) :\n    (Lagrange.basis s v i).eval (v i) = 1 := by\n  rw [Lagrange.basis, eval_prod]\n  refine prod_eq_one fun j H => ?_\n  rw [eval_basisDivisor_left_of_ne]\n  rcases mem_erase.mp H with ⟨hij, hj⟩\n  exact mt (hvs hi hj) hij.symm\n\n"}
{"name":"Lagrange.eval_basis_of_ne","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\ns : Finset ι\nv : ι → F\ni j : ι\nhij : Ne i j\nhj : Membership.mem s j\n⊢ Eq (Polynomial.eval (v j) (Lagrange.basis s v i)) 0","decl":"@[simp]\ntheorem eval_basis_of_ne (hij : i ≠ j) (hj : j ∈ s) : (Lagrange.basis s v i).eval (v j) = 0 := by\n  simp_rw [Lagrange.basis, eval_prod, prod_eq_zero_iff]\n  exact ⟨j, ⟨mem_erase.mpr ⟨hij.symm, hj⟩, eval_basisDivisor_right⟩⟩\n\n"}
{"name":"Lagrange.natDegree_basis","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\ns : Finset ι\nv : ι → F\ni : ι\nhvs : Set.InjOn v ↑s\nhi : Membership.mem s i\n⊢ Eq (Lagrange.basis s v i).natDegree (HSub.hSub s.card 1)","decl":"@[simp]\ntheorem natDegree_basis (hvs : Set.InjOn v s) (hi : i ∈ s) :\n    (Lagrange.basis s v i).natDegree = #s - 1 := by\n  have H : ∀ j, j ∈ s.erase i → basisDivisor (v i) (v j) ≠ 0 := by\n    simp_rw [Ne, mem_erase, basisDivisor_eq_zero_iff]\n    exact fun j ⟨hij₁, hj⟩ hij₂ => hij₁ (hvs hj hi hij₂.symm)\n  rw [← card_erase_of_mem hi, card_eq_sum_ones]\n  convert natDegree_prod _ _ H using 1\n  refine sum_congr rfl fun j hj => (natDegree_basisDivisor_of_ne ?_).symm\n  rw [Ne, ← basisDivisor_eq_zero_iff]\n  exact H _ hj\n\n"}
{"name":"Lagrange.degree_basis","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\ns : Finset ι\nv : ι → F\ni : ι\nhvs : Set.InjOn v ↑s\nhi : Membership.mem s i\n⊢ Eq (Lagrange.basis s v i).degree ↑(HSub.hSub s.card 1)","decl":"theorem degree_basis (hvs : Set.InjOn v s) (hi : i ∈ s) :\n    (Lagrange.basis s v i).degree = ↑(#s - 1) := by\n  rw [degree_eq_natDegree (basis_ne_zero hvs hi), natDegree_basis hvs hi]\n\n-- Porting note: Added `Nat.cast_withBot` rewrites\n"}
{"name":"Lagrange.sum_basis","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\ns : Finset ι\nv : ι → F\nhvs : Set.InjOn v ↑s\nhs : s.Nonempty\n⊢ Eq (s.sum fun j => Lagrange.basis s v j) 1","decl":"theorem sum_basis (hvs : Set.InjOn v s) (hs : s.Nonempty) :\n    ∑ j ∈ s, Lagrange.basis s v j = 1 := by\n  refine eq_of_degrees_lt_of_eval_index_eq s hvs (lt_of_le_of_lt (degree_sum_le _ _) ?_) ?_ ?_\n  · rw [Nat.cast_withBot, Finset.sup_lt_iff (WithBot.bot_lt_coe #s)]\n    intro i hi\n    rw [degree_basis hvs hi, Nat.cast_withBot, WithBot.coe_lt_coe]\n    exact Nat.pred_lt (card_ne_zero_of_mem hi)\n  · rw [degree_one, ← WithBot.coe_zero, Nat.cast_withBot, WithBot.coe_lt_coe]\n    exact Nonempty.card_pos hs\n  · intro i hi\n    rw [eval_finset_sum, eval_one, ← add_sum_erase _ _ hi, eval_basis_self hvs hi,\n      add_right_eq_self]\n    refine sum_eq_zero fun j hj => ?_\n    rcases mem_erase.mp hj with ⟨hij, _⟩\n    rw [eval_basis_of_ne hij hi]\n\n"}
{"name":"Lagrange.basisDivisor_add_symm","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝ : Field F\nx y : F\nhxy : Ne x y\n⊢ Eq (HAdd.hAdd (Lagrange.basisDivisor x y) (Lagrange.basisDivisor y x)) 1","decl":"theorem basisDivisor_add_symm {x y : F} (hxy : x ≠ y) :\n    basisDivisor x y + basisDivisor y x = 1 := by\n  classical\n  rw [← sum_basis Function.injective_id.injOn ⟨x, mem_insert_self _ {y}⟩,\n    sum_insert (not_mem_singleton.mpr hxy), sum_singleton, basis_pair_left hxy,\n    basis_pair_right hxy, id, id]\n\n"}
{"name":"Lagrange.interpolate_apply","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\ns : Finset ι\nv r : ι → F\n⊢ Eq ((Lagrange.interpolate s v) r) (s.sum fun i => HMul.hMul (Polynomial.C (r i)) (Lagrange.basis s v i))","decl":"/-- Lagrange interpolation: given a finset `s : Finset ι`, a nodal map `v : ι → F` injective on\n`s` and a value function `r : ι → F`, `interpolate s v r` is the unique\npolynomial of degree `< #s` that takes value `r i` on `v i` for all `i` in `s`. -/\n@[simps]\ndef interpolate (s : Finset ι) (v : ι → F) : (ι → F) →ₗ[F] F[X] where\n  toFun r := ∑ i ∈ s, C (r i) * Lagrange.basis s v i\n  map_add' f g := by\n    simp_rw [← Finset.sum_add_distrib]\n    have h : (fun x => C (f x) * Lagrange.basis s v x + C (g x) * Lagrange.basis s v x) =\n    (fun x => C ((f + g) x) * Lagrange.basis s v x) := by\n      simp_rw [← add_mul, ← C_add, Pi.add_apply]\n    rw [h]\n  map_smul' c f := by\n    simp_rw [Finset.smul_sum, C_mul', smul_smul, Pi.smul_apply, RingHom.id_apply, smul_eq_mul]\n\n"}
{"name":"Lagrange.interpolate_empty","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\nv r : ι → F\n⊢ Eq ((Lagrange.interpolate EmptyCollection.emptyCollection v) r) 0","decl":"theorem interpolate_empty : interpolate ∅ v r = 0 := by rw [interpolate_apply, sum_empty]\n\n"}
{"name":"Lagrange.interpolate_singleton","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\ni : ι\nv r : ι → F\n⊢ Eq ((Lagrange.interpolate (Singleton.singleton i) v) r) (Polynomial.C (r i))","decl":"theorem interpolate_singleton : interpolate {i} v r = C (r i) := by\n  rw [interpolate_apply, sum_singleton, basis_singleton, mul_one]\n\n"}
{"name":"Lagrange.interpolate_one","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\ns : Finset ι\nv : ι → F\nhvs : Set.InjOn v ↑s\nhs : s.Nonempty\n⊢ Eq ((Lagrange.interpolate s v) 1) 1","decl":"theorem interpolate_one (hvs : Set.InjOn v s) (hs : s.Nonempty) : interpolate s v 1 = 1 := by\n  simp_rw [interpolate_apply, Pi.one_apply, map_one, one_mul]\n  exact sum_basis hvs hs\n\n"}
{"name":"Lagrange.eval_interpolate_at_node","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\ns : Finset ι\ni : ι\nv r : ι → F\nhvs : Set.InjOn v ↑s\nhi : Membership.mem s i\n⊢ Eq (Polynomial.eval (v i) ((Lagrange.interpolate s v) r)) (r i)","decl":"theorem eval_interpolate_at_node (hvs : Set.InjOn v s) (hi : i ∈ s) :\n    eval (v i) (interpolate s v r) = r i := by\n  rw [interpolate_apply, eval_finset_sum, ← add_sum_erase _ _ hi]\n  simp_rw [eval_mul, eval_C, eval_basis_self hvs hi, mul_one, add_right_eq_self]\n  refine sum_eq_zero fun j H => ?_\n  rw [eval_basis_of_ne (mem_erase.mp H).1 hi, mul_zero]\n\n"}
{"name":"Lagrange.degree_interpolate_le","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\ns : Finset ι\nv r : ι → F\nhvs : Set.InjOn v ↑s\n⊢ LE.le ((Lagrange.interpolate s v) r).degree ↑(HSub.hSub s.card 1)","decl":"theorem degree_interpolate_le (hvs : Set.InjOn v s) :\n    (interpolate s v r).degree ≤ ↑(#s - 1) := by\n  refine (degree_sum_le _ _).trans ?_\n  rw [Finset.sup_le_iff]\n  intro i hi\n  rw [degree_mul, degree_basis hvs hi]\n  by_cases hr : r i = 0\n  · simpa only [hr, map_zero, degree_zero, WithBot.bot_add] using bot_le\n  · rw [degree_C hr, zero_add]\n\n-- Porting note: Added `Nat.cast_withBot` rewrites\n"}
{"name":"Lagrange.degree_interpolate_lt","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\ns : Finset ι\nv r : ι → F\nhvs : Set.InjOn v ↑s\n⊢ LT.lt ((Lagrange.interpolate s v) r).degree ↑s.card","decl":"theorem degree_interpolate_lt (hvs : Set.InjOn v s) : (interpolate s v r).degree < #s := by\n  rw [Nat.cast_withBot]\n  rcases eq_empty_or_nonempty s with (rfl | h)\n  · rw [interpolate_empty, degree_zero, card_empty]\n    exact WithBot.bot_lt_coe _\n  · refine lt_of_le_of_lt (degree_interpolate_le _ hvs) ?_\n    rw [Nat.cast_withBot, WithBot.coe_lt_coe]\n    exact Nat.sub_lt (Nonempty.card_pos h) zero_lt_one\n\n"}
{"name":"Lagrange.degree_interpolate_erase_lt","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\ns : Finset ι\ni : ι\nv r : ι → F\nhvs : Set.InjOn v ↑s\nhi : Membership.mem s i\n⊢ LT.lt ((Lagrange.interpolate (s.erase i) v) r).degree ↑(HSub.hSub s.card 1)","decl":"theorem degree_interpolate_erase_lt (hvs : Set.InjOn v s) (hi : i ∈ s) :\n    (interpolate (s.erase i) v r).degree < ↑(#s - 1) := by\n  rw [← Finset.card_erase_of_mem hi]\n  exact degree_interpolate_lt _ (Set.InjOn.mono (coe_subset.mpr (erase_subset _ _)) hvs)\n\n"}
{"name":"Lagrange.values_eq_on_of_interpolate_eq","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\ns : Finset ι\nv r r' : ι → F\nhvs : Set.InjOn v ↑s\nhrr' : Eq ((Lagrange.interpolate s v) r) ((Lagrange.interpolate s v) r')\ni : ι\na✝ : Membership.mem s i\n⊢ Eq (r i) (r' i)","decl":"theorem values_eq_on_of_interpolate_eq (hvs : Set.InjOn v s)\n    (hrr' : interpolate s v r = interpolate s v r') : ∀ i ∈ s, r i = r' i := fun _ hi => by\n  rw [← eval_interpolate_at_node r hvs hi, hrr', eval_interpolate_at_node r' hvs hi]\n\n"}
{"name":"Lagrange.interpolate_eq_of_values_eq_on","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\ns : Finset ι\nv r r' : ι → F\nhrr' : ∀ (i : ι), Membership.mem s i → Eq (r i) (r' i)\n⊢ Eq ((Lagrange.interpolate s v) r) ((Lagrange.interpolate s v) r')","decl":"theorem interpolate_eq_of_values_eq_on (hrr' : ∀ i ∈ s, r i = r' i) :\n    interpolate s v r = interpolate s v r' :=\n  sum_congr rfl fun i hi => by rw [hrr' _ hi]\n\n"}
{"name":"Lagrange.interpolate_eq_iff_values_eq_on","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\ns : Finset ι\nv r r' : ι → F\nhvs : Set.InjOn v ↑s\n⊢ Iff (Eq ((Lagrange.interpolate s v) r) ((Lagrange.interpolate s v) r')) (∀ (i : ι), Membership.mem s i → Eq (r i) (r' i))","decl":"theorem interpolate_eq_iff_values_eq_on (hvs : Set.InjOn v s) :\n    interpolate s v r = interpolate s v r' ↔ ∀ i ∈ s, r i = r' i :=\n  ⟨values_eq_on_of_interpolate_eq _ _ hvs, interpolate_eq_of_values_eq_on _ _⟩\n\n"}
{"name":"Lagrange.eq_interpolate","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\ns : Finset ι\nv : ι → F\nf : Polynomial F\nhvs : Set.InjOn v ↑s\ndegree_f_lt : LT.lt f.degree ↑s.card\n⊢ Eq f ((Lagrange.interpolate s v) fun i => Polynomial.eval (v i) f)","decl":"theorem eq_interpolate {f : F[X]} (hvs : Set.InjOn v s) (degree_f_lt : f.degree < #s) :\n    f = interpolate s v fun i => f.eval (v i) :=\n  eq_of_degrees_lt_of_eval_index_eq _ hvs degree_f_lt (degree_interpolate_lt _ hvs) fun _ hi =>\n    (eval_interpolate_at_node (fun x ↦ eval (v x) f) hvs hi).symm\n\n"}
{"name":"Lagrange.eq_interpolate_of_eval_eq","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\ns : Finset ι\nv r : ι → F\nf : Polynomial F\nhvs : Set.InjOn v ↑s\ndegree_f_lt : LT.lt f.degree ↑s.card\neval_f : ∀ (i : ι), Membership.mem s i → Eq (Polynomial.eval (v i) f) (r i)\n⊢ Eq f ((Lagrange.interpolate s v) r)","decl":"theorem eq_interpolate_of_eval_eq {f : F[X]} (hvs : Set.InjOn v s) (degree_f_lt : f.degree < #s)\n    (eval_f : ∀ i ∈ s, f.eval (v i) = r i) : f = interpolate s v r := by\n  rw [eq_interpolate hvs degree_f_lt]\n  exact interpolate_eq_of_values_eq_on _ _ eval_f\n\n"}
{"name":"Lagrange.eq_interpolate_iff","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\ns : Finset ι\nv r : ι → F\nf : Polynomial F\nhvs : Set.InjOn v ↑s\n⊢ Iff (And (LT.lt f.degree ↑s.card) (∀ (i : ι), Membership.mem s i → Eq (Polynomial.eval (v i) f) (r i))) (Eq f ((Lagrange.interpolate s v) r))","decl":"/-- This is the characteristic property of the interpolation: the interpolation is the\nunique polynomial of `degree < Fintype.card ι` which takes the value of the `r i` on the `v i`.\n-/\ntheorem eq_interpolate_iff {f : F[X]} (hvs : Set.InjOn v s) :\n    (f.degree < #s ∧ ∀ i ∈ s, eval (v i) f = r i) ↔ f = interpolate s v r := by\n  constructor <;> intro h\n  · exact eq_interpolate_of_eval_eq _ hvs h.1 h.2\n  · rw [h]\n    exact ⟨degree_interpolate_lt _ hvs, fun _ hi => eval_interpolate_at_node _ hvs hi⟩\n\n"}
{"name":"Lagrange.interpolate_eq_sum_interpolate_insert_sdiff","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\ns t : Finset ι\nv r : ι → F\nhvt : Set.InjOn v ↑t\nhs : s.Nonempty\nhst : HasSubset.Subset s t\n⊢ Eq ((Lagrange.interpolate t v) r) (s.sum fun i => HMul.hMul ((Lagrange.interpolate (Insert.insert i (SDiff.sdiff t s)) v) r) (Lagrange.basis s v i))","decl":"theorem interpolate_eq_sum_interpolate_insert_sdiff (hvt : Set.InjOn v t) (hs : s.Nonempty)\n    (hst : s ⊆ t) :\n    interpolate t v r = ∑ i ∈ s, interpolate (insert i (t \\ s)) v r * Lagrange.basis s v i := by\n  symm\n  refine eq_interpolate_of_eval_eq _ hvt (lt_of_le_of_lt (degree_sum_le _ _) ?_) fun i hi => ?_\n  · simp_rw [Nat.cast_withBot, Finset.sup_lt_iff (WithBot.bot_lt_coe #t), degree_mul]\n    intro i hi\n    have hs : 1 ≤ #s := Nonempty.card_pos ⟨_, hi⟩\n    have hst' : #s ≤ #t := card_le_card hst\n    have H : #t = 1 + (#t - #s) + (#s - 1) := by\n      rw [add_assoc, tsub_add_tsub_cancel hst' hs, ← add_tsub_assoc_of_le (hs.trans hst'),\n        Nat.succ_add_sub_one, zero_add]\n    rw [degree_basis (Set.InjOn.mono hst hvt) hi, H, WithBot.coe_add, Nat.cast_withBot,\n      WithBot.add_lt_add_iff_right (@WithBot.coe_ne_bot _ (#s - 1))]\n    convert degree_interpolate_lt _\n        (hvt.mono (coe_subset.mpr (insert_subset_iff.mpr ⟨hst hi, sdiff_subset⟩)))\n    rw [card_insert_of_not_mem (not_mem_sdiff_of_mem_right hi), card_sdiff hst, add_comm]\n  · simp_rw [eval_finset_sum, eval_mul]\n    by_cases hi' : i ∈ s\n    · rw [← add_sum_erase _ _ hi', eval_basis_self (hvt.mono hst) hi',\n        eval_interpolate_at_node _\n          (hvt.mono (coe_subset.mpr (insert_subset_iff.mpr ⟨hi, sdiff_subset⟩)))\n          (mem_insert_self _ _),\n        mul_one, add_right_eq_self]\n      refine sum_eq_zero fun j hj => ?_\n      rcases mem_erase.mp hj with ⟨hij, _⟩\n      rw [eval_basis_of_ne hij hi', mul_zero]\n    · have H : (∑ j ∈ s, eval (v i) (Lagrange.basis s v j)) = 1 := by\n        rw [← eval_finset_sum, sum_basis (hvt.mono hst) hs, eval_one]\n      rw [← mul_one (r i), ← H, mul_sum]\n      refine sum_congr rfl fun j hj => ?_\n      congr\n      exact\n        eval_interpolate_at_node _ (hvt.mono (insert_subset_iff.mpr ⟨hst hj, sdiff_subset⟩))\n          (mem_insert.mpr (Or.inr (mem_sdiff.mpr ⟨hi, hi'⟩)))\n\n"}
{"name":"Lagrange.interpolate_eq_add_interpolate_erase","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\ns : Finset ι\ni j : ι\nv r : ι → F\nhvs : Set.InjOn v ↑s\nhi : Membership.mem s i\nhj : Membership.mem s j\nhij : Ne i j\n⊢ Eq ((Lagrange.interpolate s v) r) (HAdd.hAdd (HMul.hMul ((Lagrange.interpolate (s.erase j) v) r) (Lagrange.basisDivisor (v i) (v j))) (HMul.hMul ((Lagrange.interpolate (s.erase i) v) r) (Lagrange.basisDivisor (v j) (v i))))","decl":"theorem interpolate_eq_add_interpolate_erase (hvs : Set.InjOn v s) (hi : i ∈ s) (hj : j ∈ s)\n    (hij : i ≠ j) :\n    interpolate s v r =\n      interpolate (s.erase j) v r * basisDivisor (v i) (v j) +\n        interpolate (s.erase i) v r * basisDivisor (v j) (v i) := by\n  rw [interpolate_eq_sum_interpolate_insert_sdiff _ hvs ⟨i, mem_insert_self i {j}⟩ _,\n    sum_insert (not_mem_singleton.mpr hij), sum_singleton, basis_pair_left hij,\n    basis_pair_right hij, sdiff_insert_insert_of_mem_of_not_mem hi (not_mem_singleton.mpr hij),\n    sdiff_singleton_eq_erase, pair_comm,\n    sdiff_insert_insert_of_mem_of_not_mem hj (not_mem_singleton.mpr hij.symm),\n    sdiff_singleton_eq_erase]\n  exact insert_subset_iff.mpr ⟨hi, singleton_subset_iff.mpr hj⟩\n\n"}
{"name":"Lagrange.nodal_eq","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nι : Type u_2\ns : Finset ι\nv : ι → R\n⊢ Eq (Lagrange.nodal s v) (s.prod fun i => HSub.hSub Polynomial.X (Polynomial.C (v i)))","decl":"theorem nodal_eq (s : Finset ι) (v : ι → R) : nodal s v = ∏ i ∈ s, (X - C (v i)) :=\n  rfl\n\n"}
{"name":"Lagrange.nodal_empty","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nι : Type u_2\nv : ι → R\n⊢ Eq (Lagrange.nodal EmptyCollection.emptyCollection v) 1","decl":"@[simp]\ntheorem nodal_empty : nodal ∅ v = 1 := by\n  rfl\n\n"}
{"name":"Lagrange.natDegree_nodal","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nι : Type u_2\ns : Finset ι\nv : ι → R\ninst✝ : Nontrivial R\n⊢ Eq (Lagrange.nodal s v).natDegree s.card","decl":"@[simp]\ntheorem natDegree_nodal [Nontrivial R] : (nodal s v).natDegree = #s := by\n  simp_rw [nodal, natDegree_prod_of_monic (h := fun i _ => monic_X_sub_C (v i)),\n    natDegree_X_sub_C, sum_const, smul_eq_mul, mul_one]\n\n"}
{"name":"Lagrange.nodal_ne_zero","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nι : Type u_2\ns : Finset ι\nv : ι → R\ninst✝ : Nontrivial R\n⊢ Ne (Lagrange.nodal s v) 0","decl":"theorem nodal_ne_zero [Nontrivial R] : nodal s v ≠ 0 := by\nrcases s.eq_empty_or_nonempty with (rfl | h)\n· exact one_ne_zero\n· apply ne_zero_of_natDegree_gt (n := 0)\n  simp only [natDegree_nodal, h.card_pos]\n\n"}
{"name":"Lagrange.degree_nodal","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nι : Type u_2\ns : Finset ι\nv : ι → R\ninst✝ : Nontrivial R\n⊢ Eq (Lagrange.nodal s v).degree ↑s.card","decl":"@[simp]\ntheorem degree_nodal [Nontrivial R] : (nodal s v).degree = #s := by\n  simp_rw [degree_eq_natDegree nodal_ne_zero, natDegree_nodal]\n\n"}
{"name":"Lagrange.nodal_monic","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nι : Type u_2\ns : Finset ι\nv : ι → R\n⊢ (Lagrange.nodal s v).Monic","decl":"theorem nodal_monic : (nodal s v).Monic :=\n  monic_prod_of_monic s (fun i ↦ X - C (v i)) fun i _ ↦ monic_X_sub_C (v i)\n\n"}
{"name":"Lagrange.eval_nodal","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nι : Type u_2\ns : Finset ι\nv : ι → R\nx : R\n⊢ Eq (Polynomial.eval x (Lagrange.nodal s v)) (s.prod fun i => HSub.hSub x (v i))","decl":"theorem eval_nodal {x : R} : (nodal s v).eval x = ∏ i ∈ s, (x - v i) := by\n  simp_rw [nodal, eval_prod, eval_sub, eval_X, eval_C]\n\n"}
{"name":"Lagrange.eval_nodal_at_node","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nι : Type u_2\ns : Finset ι\nv : ι → R\ni : ι\nhi : Membership.mem s i\n⊢ Eq (Polynomial.eval (v i) (Lagrange.nodal s v)) 0","decl":"theorem eval_nodal_at_node {i : ι} (hi : i ∈ s) : eval (v i) (nodal s v) = 0 := by\n  rw [eval_nodal]\n  exact s.prod_eq_zero hi (sub_self (v i))\n\n"}
{"name":"Lagrange.eval_nodal_not_at_node","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nι : Type u_2\ns : Finset ι\nv : ι → R\ninst✝¹ : Nontrivial R\ninst✝ : NoZeroDivisors R\nx : R\nhx : ∀ (i : ι), Membership.mem s i → Ne x (v i)\n⊢ Ne (Polynomial.eval x (Lagrange.nodal s v)) 0","decl":"theorem eval_nodal_not_at_node [Nontrivial R] [NoZeroDivisors R] {x : R}\n    (hx : ∀ i ∈ s, x ≠ v i) : eval x (nodal s v) ≠ 0 := by\n  simp_rw [nodal, eval_prod, prod_ne_zero_iff, eval_sub, eval_X, eval_C, sub_ne_zero]\n  exact hx\n\n"}
{"name":"Lagrange.nodal_eq_mul_nodal_erase","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nι : Type u_2\ns : Finset ι\nv : ι → R\ninst✝ : DecidableEq ι\ni : ι\nhi : Membership.mem s i\n⊢ Eq (Lagrange.nodal s v) (HMul.hMul (HSub.hSub Polynomial.X (Polynomial.C (v i))) (Lagrange.nodal (s.erase i) v))","decl":"theorem nodal_eq_mul_nodal_erase [DecidableEq ι] {i : ι} (hi : i ∈ s) :\n    nodal s v = (X - C (v i)) * nodal (s.erase i) v := by\n    simp_rw [nodal, Finset.mul_prod_erase _ (fun x => X - C (v x)) hi]\n\n"}
{"name":"Lagrange.X_sub_C_dvd_nodal","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nι : Type u_2\ns : Finset ι\nv : ι → R\ni : ι\nhi : Membership.mem s i\n⊢ Dvd.dvd (HSub.hSub Polynomial.X (Polynomial.C (v i))) (Lagrange.nodal s v)","decl":"theorem X_sub_C_dvd_nodal (v : ι → R) {i : ι} (hi : i ∈ s) : X - C (v i) ∣ nodal s v := by\n  classical\n  exact ⟨nodal (s.erase i) v, nodal_eq_mul_nodal_erase hi⟩\n\n"}
{"name":"Lagrange.nodal_insert_eq_nodal","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nι : Type u_2\ns : Finset ι\nv : ι → R\ninst✝ : DecidableEq ι\ni : ι\nhi : Not (Membership.mem s i)\n⊢ Eq (Lagrange.nodal (Insert.insert i s) v) (HMul.hMul (HSub.hSub Polynomial.X (Polynomial.C (v i))) (Lagrange.nodal s v))","decl":"theorem nodal_insert_eq_nodal [DecidableEq ι] {i : ι} (hi : i ∉ s) :\n    nodal (insert i s) v = (X - C (v i)) * nodal s v := by\n  simp_rw [nodal, prod_insert hi]\n\n"}
{"name":"Lagrange.derivative_nodal","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nι : Type u_2\ns : Finset ι\nv : ι → R\ninst✝ : DecidableEq ι\n⊢ Eq (Polynomial.derivative (Lagrange.nodal s v)) (s.sum fun i => Lagrange.nodal (s.erase i) v)","decl":"theorem derivative_nodal [DecidableEq ι] :\n    derivative (nodal s v) = ∑ i ∈ s, nodal (s.erase i) v := by\n  refine s.induction_on ?_ fun i t hit IH => ?_\n  · rw [nodal_empty, derivative_one, sum_empty]\n  · rw [nodal_insert_eq_nodal hit, derivative_mul, IH, derivative_sub, derivative_X, derivative_C,\n      sub_zero, one_mul, sum_insert hit, mul_sum, erase_insert hit, add_right_inj]\n    refine sum_congr rfl fun j hjt => ?_\n    rw [t.erase_insert_of_ne (ne_of_mem_of_not_mem hjt hit).symm,\n      nodal_insert_eq_nodal (mem_of_mem_erase.mt hit)]\n\n"}
{"name":"Lagrange.eval_nodal_derivative_eval_node_eq","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nι : Type u_2\ns : Finset ι\nv : ι → R\ninst✝ : DecidableEq ι\ni : ι\nhi : Membership.mem s i\n⊢ Eq (Polynomial.eval (v i) (Polynomial.derivative (Lagrange.nodal s v))) (Polynomial.eval (v i) (Lagrange.nodal (s.erase i) v))","decl":"theorem eval_nodal_derivative_eval_node_eq [DecidableEq ι] {i : ι} (hi : i ∈ s) :\n    eval (v i) (derivative (nodal s v)) = eval (v i) (nodal (s.erase i) v) := by\n  rw [derivative_nodal, eval_finset_sum, ← add_sum_erase _ _ hi, add_right_eq_self]\n  exact sum_eq_zero fun j hj => (eval_nodal_at_node (mem_erase.mpr ⟨(mem_erase.mp hj).1.symm, hi⟩))\n\n"}
{"name":"Lagrange.nodal_subgroup_eq_X_pow_card_sub_one","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\nG : Subgroup (Units R)\ninst✝ : Fintype (Subtype fun x => Membership.mem G x)\n⊢ Eq (Lagrange.nodal (↑G).toFinset Units.val) (HSub.hSub (HPow.hPow Polynomial.X (Fintype.card (Subtype fun x => Membership.mem G x))) 1)","decl":"/-- The vanishing polynomial on a multiplicative subgroup is of the form X ^ n - 1. -/\n@[simp] theorem nodal_subgroup_eq_X_pow_card_sub_one [IsDomain R]\n  (G : Subgroup Rˣ) [Fintype G] :\n  nodal (G : Set Rˣ).toFinset ((↑) : Rˣ → R) = X ^ (Fintype.card G) - 1 := by\n  have h : degree (1 : R[X]) < degree ((X : R[X]) ^ Fintype.card G) := by simp [Fintype.card_pos]\n  apply eq_of_degree_le_of_eval_index_eq (v := ((↑) : Rˣ → R)) (G : Set Rˣ).toFinset\n  · exact Set.injOn_of_injective Units.ext\n  · simp\n  · rw [degree_sub_eq_left_of_degree_lt h, degree_nodal, Set.toFinset_card, degree_pow, degree_X,\n      nsmul_eq_mul, mul_one, Nat.cast_inj]\n    exact rfl\n  · rw [nodal_monic, leadingCoeff_sub_of_degree_lt h, monic_X_pow]\n  · intros i hi\n    rw [eval_nodal_at_node hi]\n    replace hi : i ∈ G := by simpa using hi\n    obtain ⟨g, rfl⟩ : ∃ g : G, g.val = i := ⟨⟨i, hi⟩, rfl⟩\n    simp [← Units.val_pow_eq_pow_val, ← Subgroup.coe_pow G]\n\n"}
{"name":"Lagrange.nodalWeight_eq_eval_nodal_erase_inv","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\ns : Finset ι\nv : ι → F\ni : ι\n⊢ Eq (Lagrange.nodalWeight s v i) (Inv.inv (Polynomial.eval (v i) (Lagrange.nodal (s.erase i) v)))","decl":"theorem nodalWeight_eq_eval_nodal_erase_inv :\n    nodalWeight s v i = (eval (v i) (nodal (s.erase i) v))⁻¹ := by\n  rw [eval_nodal, nodalWeight, prod_inv_distrib]\n\n"}
{"name":"Lagrange.nodal_erase_eq_nodal_div","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\ns : Finset ι\nv : ι → F\ni : ι\nhi : Membership.mem s i\n⊢ Eq (Lagrange.nodal (s.erase i) v) (HDiv.hDiv (Lagrange.nodal s v) (HSub.hSub Polynomial.X (Polynomial.C (v i))))","decl":"theorem nodal_erase_eq_nodal_div (hi : i ∈ s) :\n    nodal (s.erase i) v = nodal s v / (X - C (v i)) := by\n  rw [nodal_eq_mul_nodal_erase hi, mul_div_cancel_left₀]\n  exact X_sub_C_ne_zero _\n\n"}
{"name":"Lagrange.nodalWeight_eq_eval_nodal_derative","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\ns : Finset ι\nv : ι → F\ni : ι\nhi : Membership.mem s i\n⊢ Eq (Lagrange.nodalWeight s v i) (Inv.inv (Polynomial.eval (v i) (Polynomial.derivative (Lagrange.nodal s v))))","decl":"theorem nodalWeight_eq_eval_nodal_derative (hi : i ∈ s) :\n    nodalWeight s v i = (eval (v i) (Polynomial.derivative (nodal s v)))⁻¹ := by\n  rw [eval_nodal_derivative_eval_node_eq hi, nodalWeight_eq_eval_nodal_erase_inv]\n\n"}
{"name":"Lagrange.nodalWeight_ne_zero","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\ns : Finset ι\nv : ι → F\ni : ι\nhvs : Set.InjOn v ↑s\nhi : Membership.mem s i\n⊢ Ne (Lagrange.nodalWeight s v i) 0","decl":"theorem nodalWeight_ne_zero (hvs : Set.InjOn v s) (hi : i ∈ s) : nodalWeight s v i ≠ 0 := by\n  rw [nodalWeight, prod_ne_zero_iff]\n  intro j hj\n  rcases mem_erase.mp hj with ⟨hij, hj⟩\n  exact inv_ne_zero (sub_ne_zero_of_ne (mt (hvs.eq_iff hi hj).mp hij.symm))\n\n"}
{"name":"Lagrange.basis_eq_prod_sub_inv_mul_nodal_div","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\ns : Finset ι\nv : ι → F\ni : ι\nhi : Membership.mem s i\n⊢ Eq (Lagrange.basis s v i) (HMul.hMul (Polynomial.C (Lagrange.nodalWeight s v i)) (HDiv.hDiv (Lagrange.nodal s v) (HSub.hSub Polynomial.X (Polynomial.C (v i)))))","decl":"theorem basis_eq_prod_sub_inv_mul_nodal_div (hi : i ∈ s) :\n    Lagrange.basis s v i = C (nodalWeight s v i) * (nodal s v / (X - C (v i))) := by\n  simp_rw [Lagrange.basis, basisDivisor, nodalWeight, prod_mul_distrib, map_prod, ←\n    nodal_erase_eq_nodal_div hi, nodal]\n\n"}
{"name":"Lagrange.eval_basis_not_at_node","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\ns : Finset ι\nv : ι → F\ni : ι\nx : F\nhi : Membership.mem s i\nhxi : Ne x (v i)\n⊢ Eq (Polynomial.eval x (Lagrange.basis s v i)) (HMul.hMul (Polynomial.eval x (Lagrange.nodal s v)) (HMul.hMul (Lagrange.nodalWeight s v i) (Inv.inv (HSub.hSub x (v i)))))","decl":"theorem eval_basis_not_at_node (hi : i ∈ s) (hxi : x ≠ v i) :\n    eval x (Lagrange.basis s v i) = eval x (nodal s v) * (nodalWeight s v i * (x - v i)⁻¹) := by\n  rw [mul_comm, basis_eq_prod_sub_inv_mul_nodal_div hi, eval_mul, eval_C, ←\n    nodal_erase_eq_nodal_div hi, eval_nodal, eval_nodal, mul_assoc, ← mul_prod_erase _ _ hi, ←\n    mul_assoc (x - v i)⁻¹, inv_mul_cancel₀ (sub_ne_zero_of_ne hxi), one_mul]\n\n"}
{"name":"Lagrange.interpolate_eq_nodalWeight_mul_nodal_div_X_sub_C","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\ns : Finset ι\nv r : ι → F\n⊢ Eq ((Lagrange.interpolate s v) r) (s.sum fun i => HMul.hMul (HMul.hMul (Polynomial.C (Lagrange.nodalWeight s v i)) (HDiv.hDiv (Lagrange.nodal s v) (HSub.hSub Polynomial.X (Polynomial.C (v i))))) (Polynomial.C (r i)))","decl":"theorem interpolate_eq_nodalWeight_mul_nodal_div_X_sub_C :\n    interpolate s v r = ∑ i ∈ s, C (nodalWeight s v i) * (nodal s v / (X - C (v i))) * C (r i) :=\n  sum_congr rfl fun j hj => by rw [mul_comm, basis_eq_prod_sub_inv_mul_nodal_div hj]\n\n"}
{"name":"Lagrange.eval_interpolate_not_at_node","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\ns : Finset ι\nv r : ι → F\nx : F\nhx : ∀ (i : ι), Membership.mem s i → Ne x (v i)\n⊢ Eq (Polynomial.eval x ((Lagrange.interpolate s v) r)) (HMul.hMul (Polynomial.eval x (Lagrange.nodal s v)) (s.sum fun i => HMul.hMul (HMul.hMul (Lagrange.nodalWeight s v i) (Inv.inv (HSub.hSub x (v i)))) (r i)))","decl":"/-- This is the first barycentric form of the Lagrange interpolant. -/\ntheorem eval_interpolate_not_at_node (hx : ∀ i ∈ s, x ≠ v i) :\n    eval x (interpolate s v r) =\n      eval x (nodal s v) * ∑ i ∈ s, nodalWeight s v i * (x - v i)⁻¹ * r i := by\n  simp_rw [interpolate_apply, mul_sum, eval_finset_sum, eval_mul, eval_C]\n  refine sum_congr rfl fun i hi => ?_\n  rw [← mul_assoc, mul_comm, eval_basis_not_at_node hi (hx _ hi)]\n\n"}
{"name":"Lagrange.sum_nodalWeight_mul_inv_sub_ne_zero","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\ns : Finset ι\nv : ι → F\nx : F\nhvs : Set.InjOn v ↑s\nhx : ∀ (i : ι), Membership.mem s i → Ne x (v i)\nhs : s.Nonempty\n⊢ Ne (s.sum fun i => HMul.hMul (Lagrange.nodalWeight s v i) (Inv.inv (HSub.hSub x (v i)))) 0","decl":"theorem sum_nodalWeight_mul_inv_sub_ne_zero (hvs : Set.InjOn v s) (hx : ∀ i ∈ s, x ≠ v i)\n    (hs : s.Nonempty) : (∑ i ∈ s, nodalWeight s v i * (x - v i)⁻¹) ≠ 0 :=\n  @right_ne_zero_of_mul_eq_one _ _ _ (eval x (nodal s v)) _ <| by\n    simpa only [Pi.one_apply, interpolate_one hvs hs, eval_one, mul_one] using\n      (eval_interpolate_not_at_node 1 hx).symm\n\n"}
{"name":"Lagrange.eval_interpolate_not_at_node'","module":"Mathlib.LinearAlgebra.Lagrange","initialProofState":"F : Type u_1\ninst✝¹ : Field F\nι : Type u_2\ninst✝ : DecidableEq ι\ns : Finset ι\nv r : ι → F\nx : F\nhvs : Set.InjOn v ↑s\nhs : s.Nonempty\nhx : ∀ (i : ι), Membership.mem s i → Ne x (v i)\n⊢ Eq (Polynomial.eval x ((Lagrange.interpolate s v) r)) (HDiv.hDiv (s.sum fun i => HMul.hMul (HMul.hMul (Lagrange.nodalWeight s v i) (Inv.inv (HSub.hSub x (v i)))) (r i)) (s.sum fun i => HMul.hMul (Lagrange.nodalWeight s v i) (Inv.inv (HSub.hSub x (v i)))))","decl":"/-- This is the second barycentric form of the Lagrange interpolant. -/\ntheorem eval_interpolate_not_at_node' (hvs : Set.InjOn v s) (hs : s.Nonempty)\n    (hx : ∀ i ∈ s, x ≠ v i) :\n    eval x (interpolate s v r) =\n      (∑ i ∈ s, nodalWeight s v i * (x - v i)⁻¹ * r i) /\n        ∑ i ∈ s, nodalWeight s v i * (x - v i)⁻¹ := by\n  rw [← div_one (eval x (interpolate s v r)), ← @eval_one _ _ x, ← interpolate_one hvs hs,\n    eval_interpolate_not_at_node r hx, eval_interpolate_not_at_node 1 hx]\n  simp only [mul_div_mul_left _ _ (eval_nodal_not_at_node hx), Pi.one_apply, mul_one]\n\n"}
