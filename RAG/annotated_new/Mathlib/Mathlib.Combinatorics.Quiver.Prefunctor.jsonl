{"name":"Prefunctor.mk.inj","module":"Mathlib.Combinatorics.Quiver.Prefunctor","initialProofState":"V : Type u₁\ninst✝¹ : Quiver V\nW : Type u₂\ninst✝ : Quiver W\nobj✝ : V → W\nmap✝ : {X Y : V} → Quiver.Hom X Y → Quiver.Hom (obj✝ X) (obj✝ Y)\nobj : V → W\nmap : {X Y : V} → Quiver.Hom X Y → Quiver.Hom (obj X) (obj Y)\nx✝ : Eq { obj := obj✝, map := map✝ } { obj := obj, map := map }\n⊢ And (Eq obj✝ obj) (HEq map✝ map)","decl":"/-- A morphism of quivers. As we will later have categorical functors extend this structure,\nwe call it a `Prefunctor`. -/\nstructure Prefunctor (V : Type u₁) [Quiver.{v₁} V] (W : Type u₂) [Quiver.{v₂} W] where\n  /-- The action of a (pre)functor on vertices/objects. -/\n  obj : V → W\n  /-- The action of a (pre)functor on edges/arrows/morphisms. -/\n  map : ∀ {X Y : V}, (X ⟶ Y) → (obj X ⟶ obj Y)\n\n\n"}
{"name":"Prefunctor.mk.sizeOf_spec","module":"Mathlib.Combinatorics.Quiver.Prefunctor","initialProofState":"V : Type u₁\ninst✝³ : Quiver V\nW : Type u₂\ninst✝² : Quiver W\ninst✝¹ : SizeOf V\ninst✝ : SizeOf W\nobj : V → W\nmap : {X Y : V} → Quiver.Hom X Y → Quiver.Hom (obj X) (obj Y)\n⊢ Eq (SizeOf.sizeOf { obj := obj, map := map }) 1","decl":"/-- A morphism of quivers. As we will later have categorical functors extend this structure,\nwe call it a `Prefunctor`. -/\nstructure Prefunctor (V : Type u₁) [Quiver.{v₁} V] (W : Type u₂) [Quiver.{v₂} W] where\n  /-- The action of a (pre)functor on vertices/objects. -/\n  obj : V → W\n  /-- The action of a (pre)functor on edges/arrows/morphisms. -/\n  map : ∀ {X Y : V}, (X ⟶ Y) → (obj X ⟶ obj Y)\n\n\n"}
{"name":"Prefunctor.mk.injEq","module":"Mathlib.Combinatorics.Quiver.Prefunctor","initialProofState":"V : Type u₁\ninst✝¹ : Quiver V\nW : Type u₂\ninst✝ : Quiver W\nobj✝ : V → W\nmap✝ : {X Y : V} → Quiver.Hom X Y → Quiver.Hom (obj✝ X) (obj✝ Y)\nobj : V → W\nmap : {X Y : V} → Quiver.Hom X Y → Quiver.Hom (obj X) (obj Y)\n⊢ Eq (Eq { obj := obj✝, map := map✝ } { obj := obj, map := map }) (And (Eq obj✝ obj) (HEq map✝ map))","decl":"/-- A morphism of quivers. As we will later have categorical functors extend this structure,\nwe call it a `Prefunctor`. -/\nstructure Prefunctor (V : Type u₁) [Quiver.{v₁} V] (W : Type u₂) [Quiver.{v₂} W] where\n  /-- The action of a (pre)functor on vertices/objects. -/\n  obj : V → W\n  /-- The action of a (pre)functor on edges/arrows/morphisms. -/\n  map : ∀ {X Y : V}, (X ⟶ Y) → (obj X ⟶ obj Y)\n\n\n"}
{"name":"Prefunctor.mk_obj","module":"Mathlib.Combinatorics.Quiver.Prefunctor","initialProofState":"V : Type u_1\nW : Type u_2\ninst✝¹ : Quiver V\ninst✝ : Quiver W\nobj : V → W\nmap : {X Y : V} → Quiver.Hom X Y → Quiver.Hom (obj X) (obj Y)\nX : V\n⊢ Eq ({ obj := obj, map := map }.obj X) (obj X)","decl":"lemma mk_obj {V W : Type*} [Quiver V] [Quiver W] {obj : V → W} {map} {X : V} :\n    (Prefunctor.mk obj map).obj X = obj X := rfl\n\n"}
{"name":"Prefunctor.mk_map","module":"Mathlib.Combinatorics.Quiver.Prefunctor","initialProofState":"V : Type u_1\nW : Type u_2\ninst✝¹ : Quiver V\ninst✝ : Quiver W\nobj : V → W\nmap : {X Y : V} → Quiver.Hom X Y → Quiver.Hom (obj X) (obj Y)\nX Y : V\nf : Quiver.Hom X Y\n⊢ Eq ({ obj := obj, map := map }.map f) (map f)","decl":"lemma mk_map {V W : Type*} [Quiver V] [Quiver W] {obj : V → W} {map} {X Y : V} {f : X ⟶ Y} :\n    (Prefunctor.mk obj map).map f = map f := rfl\n\n"}
{"name":"Prefunctor.ext","module":"Mathlib.Combinatorics.Quiver.Prefunctor","initialProofState":"V : Type u\ninst✝¹ : Quiver V\nW : Type u₂\ninst✝ : Quiver W\nF G : Prefunctor V W\nh_obj : ∀ (X : V), Eq (F.obj X) (G.obj X)\nh_map : ∀ (X Y : V) (f : Quiver.Hom X Y), Eq (F.map f) (Eq.recOn ⋯ (Eq.recOn ⋯ (G.map f)))\n⊢ Eq F G","decl":"@[ext (iff := false)]\ntheorem ext {V : Type u} [Quiver.{v₁} V] {W : Type u₂} [Quiver.{v₂} W] {F G : Prefunctor V W}\n    (h_obj : ∀ X, F.obj X = G.obj X)\n    (h_map : ∀ (X Y : V) (f : X ⟶ Y),\n      F.map f = Eq.recOn (h_obj Y).symm (Eq.recOn (h_obj X).symm (G.map f))) : F = G := by\n  obtain ⟨F_obj, _⟩ := F\n  obtain ⟨G_obj, _⟩ := G\n  obtain rfl : F_obj = G_obj := by\n    ext X\n    apply h_obj\n  congr\n  funext X Y f\n  simpa using h_map X Y f\n\n"}
{"name":"Prefunctor.ext'","module":"Mathlib.Combinatorics.Quiver.Prefunctor","initialProofState":"V W : Type u\ninst✝¹ : Quiver V\ninst✝ : Quiver W\nF G : Prefunctor V W\nh_obj : ∀ (X : V), Eq (F.obj X) (G.obj X)\nh_map : ∀ (X Y : V) (f : Quiver.Hom X Y), Eq (F.map f) (Quiver.homOfEq (G.map f) ⋯ ⋯)\n⊢ Eq F G","decl":"/-- This may be a more useful form of `Prefunctor.ext`. -/\ntheorem ext' {V W : Type u} [Quiver V] [Quiver W] {F G : Prefunctor V W}\n    (h_obj : ∀ X, F.obj X = G.obj X)\n    (h_map : ∀ (X Y : V) (f : X ⟶ Y),\n      F.map f = Quiver.homOfEq (G.map f) (h_obj _).symm (h_obj _).symm) : F = G := by\n  obtain ⟨Fobj, Fmap⟩ := F\n  obtain ⟨Gobj, Gmap⟩ := G\n  obtain rfl : Fobj = Gobj := funext h_obj\n  simp only [mk.injEq, heq_eq_eq, true_and]\n  ext X Y f\n  simpa only [Quiver.homOfEq_rfl] using h_map X Y f\n\n"}
{"name":"Prefunctor.id_map","module":"Mathlib.Combinatorics.Quiver.Prefunctor","initialProofState":"V : Type u_1\ninst✝ : Quiver V\nX✝ Y✝ : V\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((Prefunctor.id V).map f) f","decl":"/-- The identity morphism between quivers. -/\n@[simps]\ndef id (V : Type*) [Quiver V] : Prefunctor V V where\n  obj := fun X => X\n  map f := f\n\n"}
{"name":"Prefunctor.id_obj","module":"Mathlib.Combinatorics.Quiver.Prefunctor","initialProofState":"V : Type u_1\ninst✝ : Quiver V\nX : V\n⊢ Eq ((Prefunctor.id V).obj X) X","decl":"/-- The identity morphism between quivers. -/\n@[simps]\ndef id (V : Type*) [Quiver V] : Prefunctor V V where\n  obj := fun X => X\n  map f := f\n\n"}
{"name":"Prefunctor.comp_obj","module":"Mathlib.Combinatorics.Quiver.Prefunctor","initialProofState":"U : Type u_1\ninst✝² : Quiver U\nV : Type u_2\ninst✝¹ : Quiver V\nW : Type u_3\ninst✝ : Quiver W\nF : Prefunctor U V\nG : Prefunctor V W\nX : U\n⊢ Eq ((F.comp G).obj X) (G.obj (F.obj X))","decl":"/-- Composition of morphisms between quivers. -/\n@[simps]\ndef comp {U : Type*} [Quiver U] {V : Type*} [Quiver V] {W : Type*} [Quiver W]\n    (F : Prefunctor U V) (G : Prefunctor V W) : Prefunctor U W where\n  obj X := G.obj (F.obj X)\n  map f := G.map (F.map f)\n\n"}
{"name":"Prefunctor.comp_map","module":"Mathlib.Combinatorics.Quiver.Prefunctor","initialProofState":"U : Type u_1\ninst✝² : Quiver U\nV : Type u_2\ninst✝¹ : Quiver V\nW : Type u_3\ninst✝ : Quiver W\nF : Prefunctor U V\nG : Prefunctor V W\nX✝ Y✝ : U\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((F.comp G).map f) (G.map (F.map f))","decl":"/-- Composition of morphisms between quivers. -/\n@[simps]\ndef comp {U : Type*} [Quiver U] {V : Type*} [Quiver V] {W : Type*} [Quiver W]\n    (F : Prefunctor U V) (G : Prefunctor V W) : Prefunctor U W where\n  obj X := G.obj (F.obj X)\n  map f := G.map (F.map f)\n\n"}
{"name":"Prefunctor.comp_id","module":"Mathlib.Combinatorics.Quiver.Prefunctor","initialProofState":"U : Type u_1\nV : Type u_2\ninst✝¹ : Quiver U\ninst✝ : Quiver V\nF : Prefunctor U V\n⊢ Eq (F.comp (Prefunctor.id V)) F","decl":"@[simp]\ntheorem comp_id {U V : Type*} [Quiver U] [Quiver V] (F : Prefunctor U V) :\n    F.comp (id _) = F := rfl\n\n"}
{"name":"Prefunctor.id_comp","module":"Mathlib.Combinatorics.Quiver.Prefunctor","initialProofState":"U : Type u_1\nV : Type u_2\ninst✝¹ : Quiver U\ninst✝ : Quiver V\nF : Prefunctor U V\n⊢ Eq ((Prefunctor.id U).comp F) F","decl":"@[simp]\ntheorem id_comp {U V : Type*} [Quiver U] [Quiver V] (F : Prefunctor U V) :\n    (id _).comp F = F := rfl\n\n"}
{"name":"Prefunctor.comp_assoc","module":"Mathlib.Combinatorics.Quiver.Prefunctor","initialProofState":"U : Type u_1\nV : Type u_2\nW : Type u_3\nZ : Type u_4\ninst✝³ : Quiver U\ninst✝² : Quiver V\ninst✝¹ : Quiver W\ninst✝ : Quiver Z\nF : Prefunctor U V\nG : Prefunctor V W\nH : Prefunctor W Z\n⊢ Eq ((F.comp G).comp H) (F.comp (G.comp H))","decl":"@[simp]\ntheorem comp_assoc {U V W Z : Type*} [Quiver U] [Quiver V] [Quiver W] [Quiver Z]\n    (F : Prefunctor U V) (G : Prefunctor V W) (H : Prefunctor W Z) :\n    (F.comp G).comp H = F.comp (G.comp H) :=\n  rfl\n\n"}
{"name":"Prefunctor.congr_map","module":"Mathlib.Combinatorics.Quiver.Prefunctor","initialProofState":"U : Type u_1\nV : Type u_2\ninst✝¹ : Quiver U\ninst✝ : Quiver V\nF : Prefunctor U V\nX Y : U\nf g : Quiver.Hom X Y\nh : Eq f g\n⊢ Eq (F.map f) (F.map g)","decl":"theorem congr_map {U V : Type*} [Quiver U] [Quiver V] (F : U ⥤q V) {X Y : U} {f g : X ⟶ Y}\n    (h : f = g) : F.map f = F.map g := by\n  rw [h]\n\n"}
{"name":"Prefunctor.congr_obj","module":"Mathlib.Combinatorics.Quiver.Prefunctor","initialProofState":"U : Type u_1\nV : Type u_2\ninst✝¹ : Quiver U\ninst✝ : Quiver V\nF G : Prefunctor U V\ne : Eq F G\nX : U\n⊢ Eq (F.obj X) (G.obj X)","decl":"/-- An equality of prefunctors gives an equality on objects. -/\ntheorem congr_obj {U V : Type*} [Quiver U] [Quiver V] {F G : U ⥤q V} (e : F = G) (X : U) :\n    F.obj X = G.obj X := by cases e; rfl\n\n"}
{"name":"Prefunctor.congr_hom","module":"Mathlib.Combinatorics.Quiver.Prefunctor","initialProofState":"U : Type u_1\nV : Type u_2\ninst✝¹ : Quiver U\ninst✝ : Quiver V\nF G : Prefunctor U V\ne : Eq F G\nX Y : U\nf : Quiver.Hom X Y\n⊢ Eq (Quiver.homOfEq (F.map f) ⋯ ⋯) (G.map f)","decl":"/-- An equality of prefunctors gives an equality on homs. -/\ntheorem congr_hom {U V : Type*} [Quiver U] [Quiver V] {F G : U ⥤q V} (e : F = G) {X Y : U}\n    (f : X ⟶ Y) : Quiver.homOfEq (F.map f) (congr_obj e X) (congr_obj e Y) = G.map f := by\n  subst e\n  simp\n\n"}
{"name":"Prefunctor.homOfEq_map","module":"Mathlib.Combinatorics.Quiver.Prefunctor","initialProofState":"U : Type u_1\nV : Type u_2\ninst✝¹ : Quiver U\ninst✝ : Quiver V\nF : Prefunctor U V\nX Y : U\nf : Quiver.Hom X Y\nX' Y' : U\nhX : Eq X X'\nhY : Eq Y Y'\n⊢ Eq (F.map (Quiver.homOfEq f hX hY)) (Quiver.homOfEq (F.map f) ⋯ ⋯)","decl":"/-- Prefunctors commute with `homOfEq`. -/\n@[simp]\ntheorem homOfEq_map {U V : Type*} [Quiver U] [Quiver V] (F : U ⥤q V) {X Y : U} (f : X ⟶ Y)\n    {X' Y' : U} (hX : X = X') (hY : Y = Y') :\n    F.map (Quiver.homOfEq f hX hY) =\n      Quiver.homOfEq (F.map f) (congr_arg F.obj hX) (congr_arg F.obj hY) := by subst hX hY; simp\n\n"}
