{"name":"Orientation.continuousAt_oangle","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx : Prod V V\nhx1 : Ne x.1 0\nhx2 : Ne x.2 0\n⊢ ContinuousAt (fun y => o.oangle y.1 y.2) x","decl":"/-- Oriented angles are continuous when the vectors involved are nonzero. -/\ntheorem continuousAt_oangle {x : V × V} (hx1 : x.1 ≠ 0) (hx2 : x.2 ≠ 0) :\n    ContinuousAt (fun y : V × V => o.oangle y.1 y.2) x := by\n  refine (Complex.continuousAt_arg_coe_angle ?_).comp ?_\n  · exact o.kahler_ne_zero hx1 hx2\n  exact ((continuous_ofReal.comp continuous_inner).add\n    ((continuous_ofReal.comp o.areaForm'.continuous₂).mul continuous_const)).continuousAt\n\n"}
{"name":"Orientation.oangle_zero_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx : V\n⊢ Eq (o.oangle 0 x) 0","decl":"/-- If the first vector passed to `oangle` is 0, the result is 0. -/\n@[simp]\ntheorem oangle_zero_left (x : V) : o.oangle 0 x = 0 := by simp [oangle]\n\n"}
{"name":"Orientation.oangle_zero_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx : V\n⊢ Eq (o.oangle x 0) 0","decl":"/-- If the second vector passed to `oangle` is 0, the result is 0. -/\n@[simp]\ntheorem oangle_zero_right (x : V) : o.oangle x 0 = 0 := by simp [oangle]\n\n"}
{"name":"Orientation.oangle_self","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx : V\n⊢ Eq (o.oangle x x) 0","decl":"/-- If the two vectors passed to `oangle` are the same, the result is 0. -/\n@[simp]\ntheorem oangle_self (x : V) : o.oangle x x = 0 := by\n  rw [oangle, kahler_apply_self, ← ofReal_pow]\n  convert QuotientAddGroup.mk_zero (AddSubgroup.zmultiples (2 * π))\n  apply arg_ofReal_of_nonneg\n  positivity\n\n"}
{"name":"Orientation.left_ne_zero_of_oangle_ne_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Ne (o.oangle x y) 0\n⊢ Ne x 0","decl":"/-- If the angle between two vectors is nonzero, the first vector is nonzero. -/\ntheorem left_ne_zero_of_oangle_ne_zero {x y : V} (h : o.oangle x y ≠ 0) : x ≠ 0 := by\n  rintro rfl; simp at h\n\n"}
{"name":"Orientation.right_ne_zero_of_oangle_ne_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Ne (o.oangle x y) 0\n⊢ Ne y 0","decl":"/-- If the angle between two vectors is nonzero, the second vector is nonzero. -/\ntheorem right_ne_zero_of_oangle_ne_zero {x y : V} (h : o.oangle x y ≠ 0) : y ≠ 0 := by\n  rintro rfl; simp at h\n\n"}
{"name":"Orientation.ne_of_oangle_ne_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Ne (o.oangle x y) 0\n⊢ Ne x y","decl":"/-- If the angle between two vectors is nonzero, the vectors are not equal. -/\ntheorem ne_of_oangle_ne_zero {x y : V} (h : o.oangle x y ≠ 0) : x ≠ y := by\n  rintro rfl; simp at h\n\n"}
{"name":"Orientation.left_ne_zero_of_oangle_eq_pi","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Eq (o.oangle x y) ↑Real.pi\n⊢ Ne x 0","decl":"/-- If the angle between two vectors is `π`, the first vector is nonzero. -/\ntheorem left_ne_zero_of_oangle_eq_pi {x y : V} (h : o.oangle x y = π) : x ≠ 0 :=\n  o.left_ne_zero_of_oangle_ne_zero (h.symm ▸ Real.Angle.pi_ne_zero : o.oangle x y ≠ 0)\n\n"}
{"name":"Orientation.right_ne_zero_of_oangle_eq_pi","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Eq (o.oangle x y) ↑Real.pi\n⊢ Ne y 0","decl":"/-- If the angle between two vectors is `π`, the second vector is nonzero. -/\ntheorem right_ne_zero_of_oangle_eq_pi {x y : V} (h : o.oangle x y = π) : y ≠ 0 :=\n  o.right_ne_zero_of_oangle_ne_zero (h.symm ▸ Real.Angle.pi_ne_zero : o.oangle x y ≠ 0)\n\n"}
{"name":"Orientation.ne_of_oangle_eq_pi","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Eq (o.oangle x y) ↑Real.pi\n⊢ Ne x y","decl":"/-- If the angle between two vectors is `π`, the vectors are not equal. -/\ntheorem ne_of_oangle_eq_pi {x y : V} (h : o.oangle x y = π) : x ≠ y :=\n  o.ne_of_oangle_ne_zero (h.symm ▸ Real.Angle.pi_ne_zero : o.oangle x y ≠ 0)\n\n"}
{"name":"Orientation.left_ne_zero_of_oangle_eq_pi_div_two","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Eq (o.oangle x y) ↑(HDiv.hDiv Real.pi 2)\n⊢ Ne x 0","decl":"/-- If the angle between two vectors is `π / 2`, the first vector is nonzero. -/\ntheorem left_ne_zero_of_oangle_eq_pi_div_two {x y : V} (h : o.oangle x y = (π / 2 : ℝ)) : x ≠ 0 :=\n  o.left_ne_zero_of_oangle_ne_zero (h.symm ▸ Real.Angle.pi_div_two_ne_zero : o.oangle x y ≠ 0)\n\n"}
{"name":"Orientation.right_ne_zero_of_oangle_eq_pi_div_two","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Eq (o.oangle x y) ↑(HDiv.hDiv Real.pi 2)\n⊢ Ne y 0","decl":"/-- If the angle between two vectors is `π / 2`, the second vector is nonzero. -/\ntheorem right_ne_zero_of_oangle_eq_pi_div_two {x y : V} (h : o.oangle x y = (π / 2 : ℝ)) : y ≠ 0 :=\n  o.right_ne_zero_of_oangle_ne_zero (h.symm ▸ Real.Angle.pi_div_two_ne_zero : o.oangle x y ≠ 0)\n\n"}
{"name":"Orientation.ne_of_oangle_eq_pi_div_two","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Eq (o.oangle x y) ↑(HDiv.hDiv Real.pi 2)\n⊢ Ne x y","decl":"/-- If the angle between two vectors is `π / 2`, the vectors are not equal. -/\ntheorem ne_of_oangle_eq_pi_div_two {x y : V} (h : o.oangle x y = (π / 2 : ℝ)) : x ≠ y :=\n  o.ne_of_oangle_ne_zero (h.symm ▸ Real.Angle.pi_div_two_ne_zero : o.oangle x y ≠ 0)\n\n"}
{"name":"Orientation.left_ne_zero_of_oangle_eq_neg_pi_div_two","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Eq (o.oangle x y) ↑(HDiv.hDiv (Neg.neg Real.pi) 2)\n⊢ Ne x 0","decl":"/-- If the angle between two vectors is `-π / 2`, the first vector is nonzero. -/\ntheorem left_ne_zero_of_oangle_eq_neg_pi_div_two {x y : V} (h : o.oangle x y = (-π / 2 : ℝ)) :\n    x ≠ 0 :=\n  o.left_ne_zero_of_oangle_ne_zero (h.symm ▸ Real.Angle.neg_pi_div_two_ne_zero : o.oangle x y ≠ 0)\n\n"}
{"name":"Orientation.right_ne_zero_of_oangle_eq_neg_pi_div_two","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Eq (o.oangle x y) ↑(HDiv.hDiv (Neg.neg Real.pi) 2)\n⊢ Ne y 0","decl":"/-- If the angle between two vectors is `-π / 2`, the second vector is nonzero. -/\ntheorem right_ne_zero_of_oangle_eq_neg_pi_div_two {x y : V} (h : o.oangle x y = (-π / 2 : ℝ)) :\n    y ≠ 0 :=\n  o.right_ne_zero_of_oangle_ne_zero (h.symm ▸ Real.Angle.neg_pi_div_two_ne_zero : o.oangle x y ≠ 0)\n\n"}
{"name":"Orientation.ne_of_oangle_eq_neg_pi_div_two","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Eq (o.oangle x y) ↑(HDiv.hDiv (Neg.neg Real.pi) 2)\n⊢ Ne x y","decl":"/-- If the angle between two vectors is `-π / 2`, the vectors are not equal. -/\ntheorem ne_of_oangle_eq_neg_pi_div_two {x y : V} (h : o.oangle x y = (-π / 2 : ℝ)) : x ≠ y :=\n  o.ne_of_oangle_ne_zero (h.symm ▸ Real.Angle.neg_pi_div_two_ne_zero : o.oangle x y ≠ 0)\n\n"}
{"name":"Orientation.left_ne_zero_of_oangle_sign_ne_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Ne (o.oangle x y).sign 0\n⊢ Ne x 0","decl":"/-- If the sign of the angle between two vectors is nonzero, the first vector is nonzero. -/\ntheorem left_ne_zero_of_oangle_sign_ne_zero {x y : V} (h : (o.oangle x y).sign ≠ 0) : x ≠ 0 :=\n  o.left_ne_zero_of_oangle_ne_zero (Real.Angle.sign_ne_zero_iff.1 h).1\n\n"}
{"name":"Orientation.right_ne_zero_of_oangle_sign_ne_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Ne (o.oangle x y).sign 0\n⊢ Ne y 0","decl":"/-- If the sign of the angle between two vectors is nonzero, the second vector is nonzero. -/\ntheorem right_ne_zero_of_oangle_sign_ne_zero {x y : V} (h : (o.oangle x y).sign ≠ 0) : y ≠ 0 :=\n  o.right_ne_zero_of_oangle_ne_zero (Real.Angle.sign_ne_zero_iff.1 h).1\n\n"}
{"name":"Orientation.ne_of_oangle_sign_ne_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Ne (o.oangle x y).sign 0\n⊢ Ne x y","decl":"/-- If the sign of the angle between two vectors is nonzero, the vectors are not equal. -/\ntheorem ne_of_oangle_sign_ne_zero {x y : V} (h : (o.oangle x y).sign ≠ 0) : x ≠ y :=\n  o.ne_of_oangle_ne_zero (Real.Angle.sign_ne_zero_iff.1 h).1\n\n"}
{"name":"Orientation.left_ne_zero_of_oangle_sign_eq_one","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Eq (o.oangle x y).sign 1\n⊢ Ne x 0","decl":"/-- If the sign of the angle between two vectors is positive, the first vector is nonzero. -/\ntheorem left_ne_zero_of_oangle_sign_eq_one {x y : V} (h : (o.oangle x y).sign = 1) : x ≠ 0 :=\n  o.left_ne_zero_of_oangle_sign_ne_zero (h.symm ▸ by decide : (o.oangle x y).sign ≠ 0)\n\n"}
{"name":"Orientation.right_ne_zero_of_oangle_sign_eq_one","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Eq (o.oangle x y).sign 1\n⊢ Ne y 0","decl":"/-- If the sign of the angle between two vectors is positive, the second vector is nonzero. -/\ntheorem right_ne_zero_of_oangle_sign_eq_one {x y : V} (h : (o.oangle x y).sign = 1) : y ≠ 0 :=\n  o.right_ne_zero_of_oangle_sign_ne_zero (h.symm ▸ by decide : (o.oangle x y).sign ≠ 0)\n\n"}
{"name":"Orientation.ne_of_oangle_sign_eq_one","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Eq (o.oangle x y).sign 1\n⊢ Ne x y","decl":"/-- If the sign of the angle between two vectors is positive, the vectors are not equal. -/\ntheorem ne_of_oangle_sign_eq_one {x y : V} (h : (o.oangle x y).sign = 1) : x ≠ y :=\n  o.ne_of_oangle_sign_ne_zero (h.symm ▸ by decide : (o.oangle x y).sign ≠ 0)\n\n"}
{"name":"Orientation.left_ne_zero_of_oangle_sign_eq_neg_one","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Eq (o.oangle x y).sign (-1)\n⊢ Ne x 0","decl":"/-- If the sign of the angle between two vectors is negative, the first vector is nonzero. -/\ntheorem left_ne_zero_of_oangle_sign_eq_neg_one {x y : V} (h : (o.oangle x y).sign = -1) : x ≠ 0 :=\n  o.left_ne_zero_of_oangle_sign_ne_zero (h.symm ▸ by decide : (o.oangle x y).sign ≠ 0)\n\n"}
{"name":"Orientation.right_ne_zero_of_oangle_sign_eq_neg_one","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Eq (o.oangle x y).sign (-1)\n⊢ Ne y 0","decl":"/-- If the sign of the angle between two vectors is negative, the second vector is nonzero. -/\ntheorem right_ne_zero_of_oangle_sign_eq_neg_one {x y : V} (h : (o.oangle x y).sign = -1) : y ≠ 0 :=\n  o.right_ne_zero_of_oangle_sign_ne_zero (h.symm ▸ by decide : (o.oangle x y).sign ≠ 0)\n\n"}
{"name":"Orientation.ne_of_oangle_sign_eq_neg_one","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Eq (o.oangle x y).sign (-1)\n⊢ Ne x y","decl":"/-- If the sign of the angle between two vectors is negative, the vectors are not equal. -/\ntheorem ne_of_oangle_sign_eq_neg_one {x y : V} (h : (o.oangle x y).sign = -1) : x ≠ y :=\n  o.ne_of_oangle_sign_ne_zero (h.symm ▸ by decide : (o.oangle x y).sign ≠ 0)\n\n"}
{"name":"Orientation.oangle_rev","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Eq (o.oangle y x) (Neg.neg (o.oangle x y))","decl":"/-- Swapping the two vectors passed to `oangle` negates the angle. -/\ntheorem oangle_rev (x y : V) : o.oangle y x = -o.oangle x y := by\n  simp only [oangle, o.kahler_swap y x, Complex.arg_conj_coe_angle]\n\n"}
{"name":"Orientation.oangle_add_oangle_rev","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Eq (HAdd.hAdd (o.oangle x y) (o.oangle y x)) 0","decl":"/-- Adding the angles between two vectors in each order results in 0. -/\n@[simp]\ntheorem oangle_add_oangle_rev (x y : V) : o.oangle x y + o.oangle y x = 0 := by\n  simp [o.oangle_rev y x]\n\n"}
{"name":"Orientation.oangle_neg_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nhx : Ne x 0\nhy : Ne y 0\n⊢ Eq (o.oangle (Neg.neg x) y) (HAdd.hAdd (o.oangle x y) ↑Real.pi)","decl":"/-- Negating the first vector passed to `oangle` adds `π` to the angle. -/\ntheorem oangle_neg_left {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) :\n    o.oangle (-x) y = o.oangle x y + π := by\n  simp only [oangle, map_neg]\n  convert Complex.arg_neg_coe_angle _\n  exact o.kahler_ne_zero hx hy\n\n"}
{"name":"Orientation.oangle_neg_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nhx : Ne x 0\nhy : Ne y 0\n⊢ Eq (o.oangle x (Neg.neg y)) (HAdd.hAdd (o.oangle x y) ↑Real.pi)","decl":"/-- Negating the second vector passed to `oangle` adds `π` to the angle. -/\ntheorem oangle_neg_right {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) :\n    o.oangle x (-y) = o.oangle x y + π := by\n  simp only [oangle, map_neg]\n  convert Complex.arg_neg_coe_angle _\n  exact o.kahler_ne_zero hx hy\n\n"}
{"name":"Orientation.two_zsmul_oangle_neg_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Eq (HSMul.hSMul 2 (o.oangle (Neg.neg x) y)) (HSMul.hSMul 2 (o.oangle x y))","decl":"/-- Negating the first vector passed to `oangle` does not change twice the angle. -/\n@[simp]\ntheorem two_zsmul_oangle_neg_left (x y : V) :\n    (2 : ℤ) • o.oangle (-x) y = (2 : ℤ) • o.oangle x y := by\n  by_cases hx : x = 0\n  · simp [hx]\n  · by_cases hy : y = 0\n    · simp [hy]\n    · simp [o.oangle_neg_left hx hy]\n\n"}
{"name":"Orientation.two_zsmul_oangle_neg_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Eq (HSMul.hSMul 2 (o.oangle x (Neg.neg y))) (HSMul.hSMul 2 (o.oangle x y))","decl":"/-- Negating the second vector passed to `oangle` does not change twice the angle. -/\n@[simp]\ntheorem two_zsmul_oangle_neg_right (x y : V) :\n    (2 : ℤ) • o.oangle x (-y) = (2 : ℤ) • o.oangle x y := by\n  by_cases hx : x = 0\n  · simp [hx]\n  · by_cases hy : y = 0\n    · simp [hy]\n    · simp [o.oangle_neg_right hx hy]\n\n"}
{"name":"Orientation.oangle_neg_neg","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Eq (o.oangle (Neg.neg x) (Neg.neg y)) (o.oangle x y)","decl":"/-- Negating both vectors passed to `oangle` does not change the angle. -/\n@[simp]\ntheorem oangle_neg_neg (x y : V) : o.oangle (-x) (-y) = o.oangle x y := by simp [oangle]\n\n"}
{"name":"Orientation.oangle_neg_left_eq_neg_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Eq (o.oangle (Neg.neg x) y) (o.oangle x (Neg.neg y))","decl":"/-- Negating the first vector produces the same angle as negating the second vector. -/\ntheorem oangle_neg_left_eq_neg_right (x y : V) : o.oangle (-x) y = o.oangle x (-y) := by\n  rw [← neg_neg y, oangle_neg_neg, neg_neg]\n\n"}
{"name":"Orientation.oangle_neg_self_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx : V\nhx : Ne x 0\n⊢ Eq (o.oangle (Neg.neg x) x) ↑Real.pi","decl":"/-- The angle between the negation of a nonzero vector and that vector is `π`. -/\n@[simp]\ntheorem oangle_neg_self_left {x : V} (hx : x ≠ 0) : o.oangle (-x) x = π := by\n  simp [oangle_neg_left, hx]\n\n"}
{"name":"Orientation.oangle_neg_self_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx : V\nhx : Ne x 0\n⊢ Eq (o.oangle x (Neg.neg x)) ↑Real.pi","decl":"/-- The angle between a nonzero vector and its negation is `π`. -/\n@[simp]\ntheorem oangle_neg_self_right {x : V} (hx : x ≠ 0) : o.oangle x (-x) = π := by\n  simp [oangle_neg_right, hx]\n\n"}
{"name":"Orientation.two_zsmul_oangle_neg_self_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx : V\n⊢ Eq (HSMul.hSMul 2 (o.oangle (Neg.neg x) x)) 0","decl":"/-- Twice the angle between the negation of a vector and that vector is 0. -/\ntheorem two_zsmul_oangle_neg_self_left (x : V) : (2 : ℤ) • o.oangle (-x) x = 0 := by\n  by_cases hx : x = 0 <;> simp [hx]\n\n"}
{"name":"Orientation.two_zsmul_oangle_neg_self_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx : V\n⊢ Eq (HSMul.hSMul 2 (o.oangle x (Neg.neg x))) 0","decl":"/-- Twice the angle between a vector and its negation is 0. -/\ntheorem two_zsmul_oangle_neg_self_right (x : V) : (2 : ℤ) • o.oangle x (-x) = 0 := by\n  by_cases hx : x = 0 <;> simp [hx]\n\n"}
{"name":"Orientation.oangle_add_oangle_rev_neg_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Eq (HAdd.hAdd (o.oangle (Neg.neg x) y) (o.oangle (Neg.neg y) x)) 0","decl":"/-- Adding the angles between two vectors in each order, with the first vector in each angle\nnegated, results in 0. -/\n@[simp]\ntheorem oangle_add_oangle_rev_neg_left (x y : V) : o.oangle (-x) y + o.oangle (-y) x = 0 := by\n  rw [oangle_neg_left_eq_neg_right, oangle_rev, neg_add_cancel]\n\n"}
{"name":"Orientation.oangle_add_oangle_rev_neg_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Eq (HAdd.hAdd (o.oangle x (Neg.neg y)) (o.oangle y (Neg.neg x))) 0","decl":"/-- Adding the angles between two vectors in each order, with the second vector in each angle\nnegated, results in 0. -/\n@[simp]\ntheorem oangle_add_oangle_rev_neg_right (x y : V) : o.oangle x (-y) + o.oangle y (-x) = 0 := by\n  rw [o.oangle_rev (-x), oangle_neg_left_eq_neg_right, add_neg_cancel]\n\n"}
{"name":"Orientation.oangle_smul_left_of_pos","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nr : Real\nhr : LT.lt 0 r\n⊢ Eq (o.oangle (HSMul.hSMul r x) y) (o.oangle x y)","decl":"/-- Multiplying the first vector passed to `oangle` by a positive real does not change the\nangle. -/\n@[simp]\ntheorem oangle_smul_left_of_pos (x y : V) {r : ℝ} (hr : 0 < r) :\n    o.oangle (r • x) y = o.oangle x y := by simp [oangle, Complex.arg_real_mul _ hr]\n\n"}
{"name":"Orientation.oangle_smul_right_of_pos","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nr : Real\nhr : LT.lt 0 r\n⊢ Eq (o.oangle x (HSMul.hSMul r y)) (o.oangle x y)","decl":"/-- Multiplying the second vector passed to `oangle` by a positive real does not change the\nangle. -/\n@[simp]\ntheorem oangle_smul_right_of_pos (x y : V) {r : ℝ} (hr : 0 < r) :\n    o.oangle x (r • y) = o.oangle x y := by simp [oangle, Complex.arg_real_mul _ hr]\n\n"}
{"name":"Orientation.oangle_smul_left_of_neg","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nr : Real\nhr : LT.lt r 0\n⊢ Eq (o.oangle (HSMul.hSMul r x) y) (o.oangle (Neg.neg x) y)","decl":"/-- Multiplying the first vector passed to `oangle` by a negative real produces the same angle\nas negating that vector. -/\n@[simp]\ntheorem oangle_smul_left_of_neg (x y : V) {r : ℝ} (hr : r < 0) :\n    o.oangle (r • x) y = o.oangle (-x) y := by\n  rw [← neg_neg r, neg_smul, ← smul_neg, o.oangle_smul_left_of_pos _ _ (neg_pos_of_neg hr)]\n\n"}
{"name":"Orientation.oangle_smul_right_of_neg","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nr : Real\nhr : LT.lt r 0\n⊢ Eq (o.oangle x (HSMul.hSMul r y)) (o.oangle x (Neg.neg y))","decl":"/-- Multiplying the second vector passed to `oangle` by a negative real produces the same angle\nas negating that vector. -/\n@[simp]\ntheorem oangle_smul_right_of_neg (x y : V) {r : ℝ} (hr : r < 0) :\n    o.oangle x (r • y) = o.oangle x (-y) := by\n  rw [← neg_neg r, neg_smul, ← smul_neg, o.oangle_smul_right_of_pos _ _ (neg_pos_of_neg hr)]\n\n"}
{"name":"Orientation.oangle_smul_left_self_of_nonneg","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx : V\nr : Real\nhr : LE.le 0 r\n⊢ Eq (o.oangle (HSMul.hSMul r x) x) 0","decl":"/-- The angle between a nonnegative multiple of a vector and that vector is 0. -/\n@[simp]\ntheorem oangle_smul_left_self_of_nonneg (x : V) {r : ℝ} (hr : 0 ≤ r) : o.oangle (r • x) x = 0 := by\n  rcases hr.lt_or_eq with (h | h)\n  · simp [h]\n  · simp [h.symm]\n\n"}
{"name":"Orientation.oangle_smul_right_self_of_nonneg","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx : V\nr : Real\nhr : LE.le 0 r\n⊢ Eq (o.oangle x (HSMul.hSMul r x)) 0","decl":"/-- The angle between a vector and a nonnegative multiple of that vector is 0. -/\n@[simp]\ntheorem oangle_smul_right_self_of_nonneg (x : V) {r : ℝ} (hr : 0 ≤ r) : o.oangle x (r • x) = 0 := by\n  rcases hr.lt_or_eq with (h | h)\n  · simp [h]\n  · simp [h.symm]\n\n"}
{"name":"Orientation.oangle_smul_smul_self_of_nonneg","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx : V\nr₁ r₂ : Real\nhr₁ : LE.le 0 r₁\nhr₂ : LE.le 0 r₂\n⊢ Eq (o.oangle (HSMul.hSMul r₁ x) (HSMul.hSMul r₂ x)) 0","decl":"/-- The angle between two nonnegative multiples of the same vector is 0. -/\n@[simp]\ntheorem oangle_smul_smul_self_of_nonneg (x : V) {r₁ r₂ : ℝ} (hr₁ : 0 ≤ r₁) (hr₂ : 0 ≤ r₂) :\n    o.oangle (r₁ • x) (r₂ • x) = 0 := by\n  rcases hr₁.lt_or_eq with (h | h)\n  · simp [h, hr₂]\n  · simp [h.symm]\n\n"}
{"name":"Orientation.two_zsmul_oangle_smul_left_of_ne_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nr : Real\nhr : Ne r 0\n⊢ Eq (HSMul.hSMul 2 (o.oangle (HSMul.hSMul r x) y)) (HSMul.hSMul 2 (o.oangle x y))","decl":"/-- Multiplying the first vector passed to `oangle` by a nonzero real does not change twice the\nangle. -/\n@[simp]\ntheorem two_zsmul_oangle_smul_left_of_ne_zero (x y : V) {r : ℝ} (hr : r ≠ 0) :\n    (2 : ℤ) • o.oangle (r • x) y = (2 : ℤ) • o.oangle x y := by\n  rcases hr.lt_or_lt with (h | h) <;> simp [h]\n\n"}
{"name":"Orientation.two_zsmul_oangle_smul_right_of_ne_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nr : Real\nhr : Ne r 0\n⊢ Eq (HSMul.hSMul 2 (o.oangle x (HSMul.hSMul r y))) (HSMul.hSMul 2 (o.oangle x y))","decl":"/-- Multiplying the second vector passed to `oangle` by a nonzero real does not change twice the\nangle. -/\n@[simp]\ntheorem two_zsmul_oangle_smul_right_of_ne_zero (x y : V) {r : ℝ} (hr : r ≠ 0) :\n    (2 : ℤ) • o.oangle x (r • y) = (2 : ℤ) • o.oangle x y := by\n  rcases hr.lt_or_lt with (h | h) <;> simp [h]\n\n"}
{"name":"Orientation.two_zsmul_oangle_smul_left_self","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx : V\nr : Real\n⊢ Eq (HSMul.hSMul 2 (o.oangle (HSMul.hSMul r x) x)) 0","decl":"/-- Twice the angle between a multiple of a vector and that vector is 0. -/\n@[simp]\ntheorem two_zsmul_oangle_smul_left_self (x : V) {r : ℝ} : (2 : ℤ) • o.oangle (r • x) x = 0 := by\n  rcases lt_or_le r 0 with (h | h) <;> simp [h]\n\n"}
{"name":"Orientation.two_zsmul_oangle_smul_right_self","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx : V\nr : Real\n⊢ Eq (HSMul.hSMul 2 (o.oangle x (HSMul.hSMul r x))) 0","decl":"/-- Twice the angle between a vector and a multiple of that vector is 0. -/\n@[simp]\ntheorem two_zsmul_oangle_smul_right_self (x : V) {r : ℝ} : (2 : ℤ) • o.oangle x (r • x) = 0 := by\n  rcases lt_or_le r 0 with (h | h) <;> simp [h]\n\n"}
{"name":"Orientation.two_zsmul_oangle_smul_smul_self","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx : V\nr₁ r₂ : Real\n⊢ Eq (HSMul.hSMul 2 (o.oangle (HSMul.hSMul r₁ x) (HSMul.hSMul r₂ x))) 0","decl":"/-- Twice the angle between two multiples of a vector is 0. -/\n@[simp]\ntheorem two_zsmul_oangle_smul_smul_self (x : V) {r₁ r₂ : ℝ} :\n    (2 : ℤ) • o.oangle (r₁ • x) (r₂ • x) = 0 := by by_cases h : r₁ = 0 <;> simp [h]\n\n"}
{"name":"Orientation.two_zsmul_oangle_left_of_span_eq","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y z : V\nh : Eq (Submodule.span Real (Singleton.singleton x)) (Submodule.span Real (Singleton.singleton y))\n⊢ Eq (HSMul.hSMul 2 (o.oangle x z)) (HSMul.hSMul 2 (o.oangle y z))","decl":"/-- If the spans of two vectors are equal, twice angles with those vectors on the left are\nequal. -/\ntheorem two_zsmul_oangle_left_of_span_eq {x y : V} (z : V) (h : (ℝ ∙ x) = ℝ ∙ y) :\n    (2 : ℤ) • o.oangle x z = (2 : ℤ) • o.oangle y z := by\n  rw [Submodule.span_singleton_eq_span_singleton] at h\n  rcases h with ⟨r, rfl⟩\n  exact (o.two_zsmul_oangle_smul_left_of_ne_zero _ _ (Units.ne_zero _)).symm\n\n"}
{"name":"Orientation.two_zsmul_oangle_right_of_span_eq","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y z : V\nh : Eq (Submodule.span Real (Singleton.singleton y)) (Submodule.span Real (Singleton.singleton z))\n⊢ Eq (HSMul.hSMul 2 (o.oangle x y)) (HSMul.hSMul 2 (o.oangle x z))","decl":"/-- If the spans of two vectors are equal, twice angles with those vectors on the right are\nequal. -/\ntheorem two_zsmul_oangle_right_of_span_eq (x : V) {y z : V} (h : (ℝ ∙ y) = ℝ ∙ z) :\n    (2 : ℤ) • o.oangle x y = (2 : ℤ) • o.oangle x z := by\n  rw [Submodule.span_singleton_eq_span_singleton] at h\n  rcases h with ⟨r, rfl⟩\n  exact (o.two_zsmul_oangle_smul_right_of_ne_zero _ _ (Units.ne_zero _)).symm\n\n"}
{"name":"Orientation.two_zsmul_oangle_of_span_eq_of_span_eq","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nw x y z : V\nhwx : Eq (Submodule.span Real (Singleton.singleton w)) (Submodule.span Real (Singleton.singleton x))\nhyz : Eq (Submodule.span Real (Singleton.singleton y)) (Submodule.span Real (Singleton.singleton z))\n⊢ Eq (HSMul.hSMul 2 (o.oangle w y)) (HSMul.hSMul 2 (o.oangle x z))","decl":"/-- If the spans of two pairs of vectors are equal, twice angles between those vectors are\nequal. -/\ntheorem two_zsmul_oangle_of_span_eq_of_span_eq {w x y z : V} (hwx : (ℝ ∙ w) = ℝ ∙ x)\n    (hyz : (ℝ ∙ y) = ℝ ∙ z) : (2 : ℤ) • o.oangle w y = (2 : ℤ) • o.oangle x z := by\n  rw [o.two_zsmul_oangle_left_of_span_eq y hwx, o.two_zsmul_oangle_right_of_span_eq x hyz]\n\n"}
{"name":"Orientation.oangle_eq_zero_iff_oangle_rev_eq_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Iff (Eq (o.oangle x y) 0) (Eq (o.oangle y x) 0)","decl":"/-- The oriented angle between two vectors is zero if and only if the angle with the vectors\nswapped is zero. -/\ntheorem oangle_eq_zero_iff_oangle_rev_eq_zero {x y : V} : o.oangle x y = 0 ↔ o.oangle y x = 0 := by\n  rw [oangle_rev, neg_eq_zero]\n\n"}
{"name":"Orientation.oangle_eq_zero_iff_sameRay","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Iff (Eq (o.oangle x y) 0) (SameRay Real x y)","decl":"/-- The oriented angle between two vectors is zero if and only if they are on the same ray. -/\ntheorem oangle_eq_zero_iff_sameRay {x y : V} : o.oangle x y = 0 ↔ SameRay ℝ x y := by\n  rw [oangle, kahler_apply_apply, Complex.arg_coe_angle_eq_iff_eq_toReal, Real.Angle.toReal_zero,\n    Complex.arg_eq_zero_iff]\n  simpa using o.nonneg_inner_and_areaForm_eq_zero_iff_sameRay x y\n\n"}
{"name":"Orientation.oangle_eq_pi_iff_oangle_rev_eq_pi","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Iff (Eq (o.oangle x y) ↑Real.pi) (Eq (o.oangle y x) ↑Real.pi)","decl":"/-- The oriented angle between two vectors is `π` if and only if the angle with the vectors\nswapped is `π`. -/\ntheorem oangle_eq_pi_iff_oangle_rev_eq_pi {x y : V} : o.oangle x y = π ↔ o.oangle y x = π := by\n  rw [oangle_rev, neg_eq_iff_eq_neg, Real.Angle.neg_coe_pi]\n\n"}
{"name":"Orientation.oangle_eq_pi_iff_sameRay_neg","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Iff (Eq (o.oangle x y) ↑Real.pi) (And (Ne x 0) (And (Ne y 0) (SameRay Real x (Neg.neg y))))","decl":"/-- The oriented angle between two vectors is `π` if and only they are nonzero and the first is\non the same ray as the negation of the second. -/\ntheorem oangle_eq_pi_iff_sameRay_neg {x y : V} :\n    o.oangle x y = π ↔ x ≠ 0 ∧ y ≠ 0 ∧ SameRay ℝ x (-y) := by\n  rw [← o.oangle_eq_zero_iff_sameRay]\n  constructor\n  · intro h\n    by_cases hx : x = 0; · simp [hx, Real.Angle.pi_ne_zero.symm] at h\n    by_cases hy : y = 0; · simp [hy, Real.Angle.pi_ne_zero.symm] at h\n    refine ⟨hx, hy, ?_⟩\n    rw [o.oangle_neg_right hx hy, h, Real.Angle.coe_pi_add_coe_pi]\n  · rintro ⟨hx, hy, h⟩\n    rwa [o.oangle_neg_right hx hy, ← Real.Angle.sub_coe_pi_eq_add_coe_pi, sub_eq_zero] at h\n\n"}
{"name":"Orientation.oangle_eq_zero_or_eq_pi_iff_not_linearIndependent","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Iff (Or (Eq (o.oangle x y) 0) (Eq (o.oangle x y) ↑Real.pi)) (Not (LinearIndependent Real (Matrix.vecCons x (Matrix.vecCons y Matrix.vecEmpty))))","decl":"/-- The oriented angle between two vectors is zero or `π` if and only if those two vectors are\nnot linearly independent. -/\ntheorem oangle_eq_zero_or_eq_pi_iff_not_linearIndependent {x y : V} :\n    o.oangle x y = 0 ∨ o.oangle x y = π ↔ ¬LinearIndependent ℝ ![x, y] := by\n  rw [oangle_eq_zero_iff_sameRay, oangle_eq_pi_iff_sameRay_neg,\n    sameRay_or_ne_zero_and_sameRay_neg_iff_not_linearIndependent]\n\n"}
{"name":"Orientation.oangle_eq_zero_or_eq_pi_iff_right_eq_smul","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Iff (Or (Eq (o.oangle x y) 0) (Eq (o.oangle x y) ↑Real.pi)) (Or (Eq x 0) (Exists fun r => Eq y (HSMul.hSMul r x)))","decl":"/-- The oriented angle between two vectors is zero or `π` if and only if the first vector is zero\nor the second is a multiple of the first. -/\ntheorem oangle_eq_zero_or_eq_pi_iff_right_eq_smul {x y : V} :\n    o.oangle x y = 0 ∨ o.oangle x y = π ↔ x = 0 ∨ ∃ r : ℝ, y = r • x := by\n  rw [oangle_eq_zero_iff_sameRay, oangle_eq_pi_iff_sameRay_neg]\n  refine ⟨fun h => ?_, fun h => ?_⟩\n  · rcases h with (h | ⟨-, -, h⟩)\n    · by_cases hx : x = 0; · simp [hx]\n      obtain ⟨r, -, rfl⟩ := h.exists_nonneg_left hx\n      exact Or.inr ⟨r, rfl⟩\n    · by_cases hx : x = 0; · simp [hx]\n      obtain ⟨r, -, hy⟩ := h.exists_nonneg_left hx\n      refine Or.inr ⟨-r, ?_⟩\n      simp [hy]\n  · rcases h with (rfl | ⟨r, rfl⟩); · simp\n    by_cases hx : x = 0; · simp [hx]\n    rcases lt_trichotomy r 0 with (hr | hr | hr)\n    · rw [← neg_smul]\n      exact Or.inr ⟨hx, smul_ne_zero hr.ne hx,\n        SameRay.sameRay_pos_smul_right x (Left.neg_pos_iff.2 hr)⟩\n    · simp [hr]\n    · exact Or.inl (SameRay.sameRay_pos_smul_right x hr)\n\n"}
{"name":"Orientation.oangle_ne_zero_and_ne_pi_iff_linearIndependent","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Iff (And (Ne (o.oangle x y) 0) (Ne (o.oangle x y) ↑Real.pi)) (LinearIndependent Real (Matrix.vecCons x (Matrix.vecCons y Matrix.vecEmpty)))","decl":"/-- The oriented angle between two vectors is not zero or `π` if and only if those two vectors\nare linearly independent. -/\ntheorem oangle_ne_zero_and_ne_pi_iff_linearIndependent {x y : V} :\n    o.oangle x y ≠ 0 ∧ o.oangle x y ≠ π ↔ LinearIndependent ℝ ![x, y] := by\n  rw [← not_or, ← not_iff_not, Classical.not_not,\n    oangle_eq_zero_or_eq_pi_iff_not_linearIndependent]\n\n"}
{"name":"Orientation.eq_iff_norm_eq_and_oangle_eq_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Iff (Eq x y) (And (Eq (Norm.norm x) (Norm.norm y)) (Eq (o.oangle x y) 0))","decl":"/-- Two vectors are equal if and only if they have equal norms and zero angle between them. -/\ntheorem eq_iff_norm_eq_and_oangle_eq_zero (x y : V) : x = y ↔ ‖x‖ = ‖y‖ ∧ o.oangle x y = 0 := by\n  rw [oangle_eq_zero_iff_sameRay]\n  constructor\n  · rintro rfl\n    simp; rfl\n  · rcases eq_or_ne y 0 with (rfl | hy)\n    · simp\n    rintro ⟨h₁, h₂⟩\n    obtain ⟨r, hr, rfl⟩ := h₂.exists_nonneg_right hy\n    have : ‖y‖ ≠ 0 := by simpa using hy\n    obtain rfl : r = 1 := by\n      apply mul_right_cancel₀ this\n      simpa [norm_smul, _root_.abs_of_nonneg hr] using h₁\n    simp\n\n"}
{"name":"Orientation.eq_iff_oangle_eq_zero_of_norm_eq","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Eq (Norm.norm x) (Norm.norm y)\n⊢ Iff (Eq x y) (Eq (o.oangle x y) 0)","decl":"/-- Two vectors with equal norms are equal if and only if they have zero angle between them. -/\ntheorem eq_iff_oangle_eq_zero_of_norm_eq {x y : V} (h : ‖x‖ = ‖y‖) : x = y ↔ o.oangle x y = 0 :=\n  ⟨fun he => ((o.eq_iff_norm_eq_and_oangle_eq_zero x y).1 he).2, fun ha =>\n    (o.eq_iff_norm_eq_and_oangle_eq_zero x y).2 ⟨h, ha⟩⟩\n\n"}
{"name":"Orientation.eq_iff_norm_eq_of_oangle_eq_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Eq (o.oangle x y) 0\n⊢ Iff (Eq x y) (Eq (Norm.norm x) (Norm.norm y))","decl":"/-- Two vectors with zero angle between them are equal if and only if they have equal norms. -/\ntheorem eq_iff_norm_eq_of_oangle_eq_zero {x y : V} (h : o.oangle x y = 0) : x = y ↔ ‖x‖ = ‖y‖ :=\n  ⟨fun he => ((o.eq_iff_norm_eq_and_oangle_eq_zero x y).1 he).1, fun hn =>\n    (o.eq_iff_norm_eq_and_oangle_eq_zero x y).2 ⟨hn, h⟩⟩\n\n"}
{"name":"Orientation.oangle_add","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y z : V\nhx : Ne x 0\nhy : Ne y 0\nhz : Ne z 0\n⊢ Eq (HAdd.hAdd (o.oangle x y) (o.oangle y z)) (o.oangle x z)","decl":"/-- Given three nonzero vectors, the angle between the first and the second plus the angle\nbetween the second and the third equals the angle between the first and the third. -/\n@[simp]\ntheorem oangle_add {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) :\n    o.oangle x y + o.oangle y z = o.oangle x z := by\n  simp_rw [oangle]\n  rw [← Complex.arg_mul_coe_angle, o.kahler_mul y x z]\n  · congr 1\n    exact mod_cast Complex.arg_real_mul _ (by positivity : 0 < ‖y‖ ^ 2)\n  · exact o.kahler_ne_zero hx hy\n  · exact o.kahler_ne_zero hy hz\n\n"}
{"name":"Orientation.oangle_add_swap","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y z : V\nhx : Ne x 0\nhy : Ne y 0\nhz : Ne z 0\n⊢ Eq (HAdd.hAdd (o.oangle y z) (o.oangle x y)) (o.oangle x z)","decl":"/-- Given three nonzero vectors, the angle between the second and the third plus the angle\nbetween the first and the second equals the angle between the first and the third. -/\n@[simp]\ntheorem oangle_add_swap {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) :\n    o.oangle y z + o.oangle x y = o.oangle x z := by rw [add_comm, o.oangle_add hx hy hz]\n\n"}
{"name":"Orientation.oangle_sub_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y z : V\nhx : Ne x 0\nhy : Ne y 0\nhz : Ne z 0\n⊢ Eq (HSub.hSub (o.oangle x z) (o.oangle x y)) (o.oangle y z)","decl":"/-- Given three nonzero vectors, the angle between the first and the third minus the angle\nbetween the first and the second equals the angle between the second and the third. -/\n@[simp]\ntheorem oangle_sub_left {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) :\n    o.oangle x z - o.oangle x y = o.oangle y z := by\n  rw [sub_eq_iff_eq_add, o.oangle_add_swap hx hy hz]\n\n"}
{"name":"Orientation.oangle_sub_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y z : V\nhx : Ne x 0\nhy : Ne y 0\nhz : Ne z 0\n⊢ Eq (HSub.hSub (o.oangle x z) (o.oangle y z)) (o.oangle x y)","decl":"/-- Given three nonzero vectors, the angle between the first and the third minus the angle\nbetween the second and the third equals the angle between the first and the second. -/\n@[simp]\ntheorem oangle_sub_right {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) :\n    o.oangle x z - o.oangle y z = o.oangle x y := by rw [sub_eq_iff_eq_add, o.oangle_add hx hy hz]\n\n"}
{"name":"Orientation.oangle_add_cyc3","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y z : V\nhx : Ne x 0\nhy : Ne y 0\nhz : Ne z 0\n⊢ Eq (HAdd.hAdd (HAdd.hAdd (o.oangle x y) (o.oangle y z)) (o.oangle z x)) 0","decl":"/-- Given three nonzero vectors, adding the angles between them in cyclic order results in 0. -/\n@[simp]\ntheorem oangle_add_cyc3 {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) :\n    o.oangle x y + o.oangle y z + o.oangle z x = 0 := by simp [hx, hy, hz]\n\n"}
{"name":"Orientation.oangle_add_cyc3_neg_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y z : V\nhx : Ne x 0\nhy : Ne y 0\nhz : Ne z 0\n⊢ Eq (HAdd.hAdd (HAdd.hAdd (o.oangle (Neg.neg x) y) (o.oangle (Neg.neg y) z)) (o.oangle (Neg.neg z) x)) ↑Real.pi","decl":"/-- Given three nonzero vectors, adding the angles between them in cyclic order, with the first\nvector in each angle negated, results in π. If the vectors add to 0, this is a version of the\nsum of the angles of a triangle. -/\n@[simp]\ntheorem oangle_add_cyc3_neg_left {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) :\n    o.oangle (-x) y + o.oangle (-y) z + o.oangle (-z) x = π := by\n  rw [o.oangle_neg_left hx hy, o.oangle_neg_left hy hz, o.oangle_neg_left hz hx,\n    show o.oangle x y + π + (o.oangle y z + π) + (o.oangle z x + π) =\n      o.oangle x y + o.oangle y z + o.oangle z x + (π + π + π : Real.Angle) by abel,\n    o.oangle_add_cyc3 hx hy hz, Real.Angle.coe_pi_add_coe_pi, zero_add, zero_add]\n\n"}
{"name":"Orientation.oangle_add_cyc3_neg_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y z : V\nhx : Ne x 0\nhy : Ne y 0\nhz : Ne z 0\n⊢ Eq (HAdd.hAdd (HAdd.hAdd (o.oangle x (Neg.neg y)) (o.oangle y (Neg.neg z))) (o.oangle z (Neg.neg x))) ↑Real.pi","decl":"/-- Given three nonzero vectors, adding the angles between them in cyclic order, with the second\nvector in each angle negated, results in π. If the vectors add to 0, this is a version of the\nsum of the angles of a triangle. -/\n@[simp]\ntheorem oangle_add_cyc3_neg_right {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) :\n    o.oangle x (-y) + o.oangle y (-z) + o.oangle z (-x) = π := by\n  simp_rw [← oangle_neg_left_eq_neg_right, o.oangle_add_cyc3_neg_left hx hy hz]\n\n"}
{"name":"Orientation.oangle_sub_eq_oangle_sub_rev_of_norm_eq","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Eq (Norm.norm x) (Norm.norm y)\n⊢ Eq (o.oangle x (HSub.hSub x y)) (o.oangle (HSub.hSub y x) y)","decl":"/-- Pons asinorum, oriented vector angle form. -/\ntheorem oangle_sub_eq_oangle_sub_rev_of_norm_eq {x y : V} (h : ‖x‖ = ‖y‖) :\n    o.oangle x (x - y) = o.oangle (y - x) y := by simp [oangle, h]\n\n"}
{"name":"Orientation.oangle_eq_pi_sub_two_zsmul_oangle_sub_of_norm_eq","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nhn : Ne x y\nh : Eq (Norm.norm x) (Norm.norm y)\n⊢ Eq (o.oangle y x) (HSub.hSub (↑Real.pi) (HSMul.hSMul 2 (o.oangle (HSub.hSub y x) y)))","decl":"/-- The angle at the apex of an isosceles triangle is `π` minus twice a base angle, oriented\nvector angle form. -/\ntheorem oangle_eq_pi_sub_two_zsmul_oangle_sub_of_norm_eq {x y : V} (hn : x ≠ y) (h : ‖x‖ = ‖y‖) :\n    o.oangle y x = π - (2 : ℤ) • o.oangle (y - x) y := by\n  rw [two_zsmul]\n  nth_rw 1 [← o.oangle_sub_eq_oangle_sub_rev_of_norm_eq h]\n  rw [eq_sub_iff_add_eq, ← oangle_neg_neg, ← add_assoc]\n  have hy : y ≠ 0 := by\n    rintro rfl\n    rw [norm_zero, norm_eq_zero] at h\n    exact hn h\n  have hx : x ≠ 0 := norm_ne_zero_iff.1 (h.symm ▸ norm_ne_zero_iff.2 hy)\n  convert o.oangle_add_cyc3_neg_right (neg_ne_zero.2 hy) hx (sub_ne_zero_of_ne hn.symm) using 1\n  simp\n\n"}
{"name":"Orientation.oangle_map","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\nV' : Type u_2\ninst✝⁵ : NormedAddCommGroup V\ninst✝⁴ : NormedAddCommGroup V'\ninst✝³ : InnerProductSpace Real V\ninst✝² : InnerProductSpace Real V'\ninst✝¹ : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Fact (Eq (Module.finrank Real V') 2)\no : Orientation Real V (Fin 2)\nx y : V'\nf : LinearIsometryEquiv (RingHom.id Real) V V'\n⊢ Eq (((Orientation.map (Fin 2) f.toLinearEquiv) o).oangle x y) (o.oangle (f.symm x) (f.symm y))","decl":"/-- The angle between two vectors, with respect to an orientation given by `Orientation.map`\nwith a linear isometric equivalence, equals the angle between those two vectors, transformed by\nthe inverse of that equivalence, with respect to the original orientation. -/\n@[simp]\ntheorem oangle_map (x y : V') (f : V ≃ₗᵢ[ℝ] V') :\n    (Orientation.map (Fin 2) f.toLinearEquiv o).oangle x y = o.oangle (f.symm x) (f.symm y) := by\n  simp [oangle, o.kahler_map]\n\n"}
{"name":"Complex.oangle","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"w z : Complex\n⊢ Eq (Complex.orientation.oangle w z) ↑(HMul.hMul ((starRingEnd Complex) w) z).arg","decl":"@[simp]\nprotected theorem _root_.Complex.oangle (w z : ℂ) :\n    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by simp [oangle]\n\n"}
{"name":"Orientation.oangle_map_complex","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nf : LinearIsometryEquiv (RingHom.id Real) V Complex\nhf : Eq ((Orientation.map (Fin 2) f.toLinearEquiv) o) Complex.orientation\nx y : V\n⊢ Eq (o.oangle x y) ↑(HMul.hMul ((starRingEnd Complex) (f x)) (f y)).arg","decl":"/-- The oriented angle on an oriented real inner product space of dimension 2 can be evaluated in\nterms of a complex-number representation of the space. -/\ntheorem oangle_map_complex (f : V ≃ₗᵢ[ℝ] ℂ)\n    (hf : Orientation.map (Fin 2) f.toLinearEquiv o = Complex.orientation) (x y : V) :\n    o.oangle x y = Complex.arg (conj (f x) * f y) := by\n  rw [← Complex.oangle, ← hf, o.oangle_map]\n  iterate 2 rw [LinearIsometryEquiv.symm_apply_apply]\n\n"}
{"name":"Orientation.oangle_neg_orientation_eq_neg","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Eq ((Neg.neg o).oangle x y) (Neg.neg (o.oangle x y))","decl":"/-- Negating the orientation negates the value of `oangle`. -/\ntheorem oangle_neg_orientation_eq_neg (x y : V) : (-o).oangle x y = -o.oangle x y := by\n  simp [oangle]\n\n"}
{"name":"Orientation.inner_eq_norm_mul_norm_mul_cos_oangle","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Eq (Inner.inner x y) (HMul.hMul (HMul.hMul (Norm.norm x) (Norm.norm y)) (o.oangle x y).cos)","decl":"/-- The inner product of two vectors is the product of the norms and the cosine of the oriented\nangle between the vectors. -/\ntheorem inner_eq_norm_mul_norm_mul_cos_oangle (x y : V) :\n    ⟪x, y⟫ = ‖x‖ * ‖y‖ * Real.Angle.cos (o.oangle x y) := by\n  by_cases hx : x = 0; · simp [hx]\n  by_cases hy : y = 0; · simp [hy]\n  rw [oangle, Real.Angle.cos_coe, Complex.cos_arg, o.abs_kahler]\n  · simp only [kahler_apply_apply, real_smul, add_re, ofReal_re, mul_re, I_re, ofReal_im]\n    -- TODO(https://github.com/leanprover-community/mathlib4/issues/15486): used to be `field_simp`; replaced by `simp only ...` to speed up\n    -- Reinstate `field_simp` once it is faster.\n    simp (disch := field_simp_discharge) only [mul_zero, I_im, mul_one, sub_self, add_zero,\n      mul_div_assoc', mul_div_cancel_left₀]\n  · exact o.kahler_ne_zero hx hy\n\n"}
{"name":"Orientation.cos_oangle_eq_inner_div_norm_mul_norm","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nhx : Ne x 0\nhy : Ne y 0\n⊢ Eq (o.oangle x y).cos (HDiv.hDiv (Inner.inner x y) (HMul.hMul (Norm.norm x) (Norm.norm y)))","decl":"/-- The cosine of the oriented angle between two nonzero vectors is the inner product divided by\nthe product of the norms. -/\ntheorem cos_oangle_eq_inner_div_norm_mul_norm {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) :\n    Real.Angle.cos (o.oangle x y) = ⟪x, y⟫ / (‖x‖ * ‖y‖) := by\n  rw [o.inner_eq_norm_mul_norm_mul_cos_oangle]\n  field_simp [norm_ne_zero_iff.2 hx, norm_ne_zero_iff.2 hy]\n\n"}
{"name":"Orientation.cos_oangle_eq_cos_angle","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nhx : Ne x 0\nhy : Ne y 0\n⊢ Eq (o.oangle x y).cos (Real.cos (InnerProductGeometry.angle x y))","decl":"/-- The cosine of the oriented angle between two nonzero vectors equals that of the unoriented\nangle. -/\ntheorem cos_oangle_eq_cos_angle {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) :\n    Real.Angle.cos (o.oangle x y) = Real.cos (InnerProductGeometry.angle x y) := by\n  rw [o.cos_oangle_eq_inner_div_norm_mul_norm hx hy, InnerProductGeometry.cos_angle]\n\n"}
{"name":"Orientation.oangle_eq_angle_or_eq_neg_angle","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nhx : Ne x 0\nhy : Ne y 0\n⊢ Or (Eq (o.oangle x y) ↑(InnerProductGeometry.angle x y)) (Eq (o.oangle x y) (Neg.neg ↑(InnerProductGeometry.angle x y)))","decl":"/-- The oriented angle between two nonzero vectors is plus or minus the unoriented angle. -/\ntheorem oangle_eq_angle_or_eq_neg_angle {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) :\n    o.oangle x y = InnerProductGeometry.angle x y ∨\n      o.oangle x y = -InnerProductGeometry.angle x y :=\n  Real.Angle.cos_eq_real_cos_iff_eq_or_eq_neg.1 <| o.cos_oangle_eq_cos_angle hx hy\n\n"}
{"name":"Orientation.angle_eq_abs_oangle_toReal","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nhx : Ne x 0\nhy : Ne y 0\n⊢ Eq (InnerProductGeometry.angle x y) (abs (o.oangle x y).toReal)","decl":"/-- The unoriented angle between two nonzero vectors is the absolute value of the oriented angle,\nconverted to a real. -/\ntheorem angle_eq_abs_oangle_toReal {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) :\n    InnerProductGeometry.angle x y = |(o.oangle x y).toReal| := by\n  have h0 := InnerProductGeometry.angle_nonneg x y\n  have hpi := InnerProductGeometry.angle_le_pi x y\n  rcases o.oangle_eq_angle_or_eq_neg_angle hx hy with (h | h)\n  · rw [h, eq_comm, Real.Angle.abs_toReal_coe_eq_self_iff]\n    exact ⟨h0, hpi⟩\n  · rw [h, eq_comm, Real.Angle.abs_toReal_neg_coe_eq_self_iff]\n    exact ⟨h0, hpi⟩\n\n"}
{"name":"Orientation.eq_zero_or_angle_eq_zero_or_pi_of_sign_oangle_eq_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Eq (o.oangle x y).sign 0\n⊢ Or (Eq x 0) (Or (Eq y 0) (Or (Eq (InnerProductGeometry.angle x y) 0) (Eq (InnerProductGeometry.angle x y) Real.pi)))","decl":"/-- If the sign of the oriented angle between two vectors is zero, either one of the vectors is\nzero or the unoriented angle is 0 or π. -/\ntheorem eq_zero_or_angle_eq_zero_or_pi_of_sign_oangle_eq_zero {x y : V}\n    (h : (o.oangle x y).sign = 0) :\n    x = 0 ∨ y = 0 ∨ InnerProductGeometry.angle x y = 0 ∨ InnerProductGeometry.angle x y = π := by\n  by_cases hx : x = 0; · simp [hx]\n  by_cases hy : y = 0; · simp [hy]\n  rw [o.angle_eq_abs_oangle_toReal hx hy]\n  rw [Real.Angle.sign_eq_zero_iff] at h\n  rcases h with (h | h) <;> simp [h, Real.pi_pos.le]\n\n"}
{"name":"Orientation.oangle_eq_of_angle_eq_of_sign_eq","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nw x y z : V\nh : Eq (InnerProductGeometry.angle w x) (InnerProductGeometry.angle y z)\nhs : Eq (o.oangle w x).sign (o.oangle y z).sign\n⊢ Eq (o.oangle w x) (o.oangle y z)","decl":"/-- If two unoriented angles are equal, and the signs of the corresponding oriented angles are\nequal, then the oriented angles are equal (even in degenerate cases). -/\ntheorem oangle_eq_of_angle_eq_of_sign_eq {w x y z : V}\n    (h : InnerProductGeometry.angle w x = InnerProductGeometry.angle y z)\n    (hs : (o.oangle w x).sign = (o.oangle y z).sign) : o.oangle w x = o.oangle y z := by\n  by_cases h0 : (w = 0 ∨ x = 0) ∨ y = 0 ∨ z = 0\n  · have hs' : (o.oangle w x).sign = 0 ∧ (o.oangle y z).sign = 0 := by\n      rcases h0 with ((rfl | rfl) | rfl | rfl)\n      · simpa using hs.symm\n      · simpa using hs.symm\n      · simpa using hs\n      · simpa using hs\n    rcases hs' with ⟨hswx, hsyz⟩\n    have h' : InnerProductGeometry.angle w x = π / 2 ∧ InnerProductGeometry.angle y z = π / 2 := by\n      rcases h0 with ((rfl | rfl) | rfl | rfl)\n      · simpa using h.symm\n      · simpa using h.symm\n      · simpa using h\n      · simpa using h\n    rcases h' with ⟨hwx, hyz⟩\n    have hpi : π / 2 ≠ π := by\n      intro hpi\n      rw [div_eq_iff, eq_comm, ← sub_eq_zero, mul_two, add_sub_cancel_right] at hpi\n      · exact Real.pi_pos.ne.symm hpi\n      · exact two_ne_zero\n    have h0wx : w = 0 ∨ x = 0 := by\n      have h0' := o.eq_zero_or_angle_eq_zero_or_pi_of_sign_oangle_eq_zero hswx\n      simpa [hwx, Real.pi_pos.ne.symm, hpi] using h0'\n    have h0yz : y = 0 ∨ z = 0 := by\n      have h0' := o.eq_zero_or_angle_eq_zero_or_pi_of_sign_oangle_eq_zero hsyz\n      simpa [hyz, Real.pi_pos.ne.symm, hpi] using h0'\n    rcases h0wx with (h0wx | h0wx) <;> rcases h0yz with (h0yz | h0yz) <;> simp [h0wx, h0yz]\n  · push_neg at h0\n    rw [Real.Angle.eq_iff_abs_toReal_eq_of_sign_eq hs]\n    rwa [o.angle_eq_abs_oangle_toReal h0.1.1 h0.1.2,\n      o.angle_eq_abs_oangle_toReal h0.2.1 h0.2.2] at h\n\n"}
{"name":"Orientation.angle_eq_iff_oangle_eq_of_sign_eq","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nw x y z : V\nhw : Ne w 0\nhx : Ne x 0\nhy : Ne y 0\nhz : Ne z 0\nhs : Eq (o.oangle w x).sign (o.oangle y z).sign\n⊢ Iff (Eq (InnerProductGeometry.angle w x) (InnerProductGeometry.angle y z)) (Eq (o.oangle w x) (o.oangle y z))","decl":"/-- If the signs of two oriented angles between nonzero vectors are equal, the oriented angles are\nequal if and only if the unoriented angles are equal. -/\ntheorem angle_eq_iff_oangle_eq_of_sign_eq {w x y z : V} (hw : w ≠ 0) (hx : x ≠ 0) (hy : y ≠ 0)\n    (hz : z ≠ 0) (hs : (o.oangle w x).sign = (o.oangle y z).sign) :\n    InnerProductGeometry.angle w x = InnerProductGeometry.angle y z ↔\n    o.oangle w x = o.oangle y z := by\n  refine ⟨fun h => o.oangle_eq_of_angle_eq_of_sign_eq h hs, fun h => ?_⟩\n  rw [o.angle_eq_abs_oangle_toReal hw hx, o.angle_eq_abs_oangle_toReal hy hz, h]\n\n"}
{"name":"Orientation.oangle_eq_angle_of_sign_eq_one","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Eq (o.oangle x y).sign 1\n⊢ Eq (o.oangle x y) ↑(InnerProductGeometry.angle x y)","decl":"/-- The oriented angle between two vectors equals the unoriented angle if the sign is positive. -/\ntheorem oangle_eq_angle_of_sign_eq_one {x y : V} (h : (o.oangle x y).sign = 1) :\n    o.oangle x y = InnerProductGeometry.angle x y := by\n  by_cases hx : x = 0; · exfalso; simp [hx] at h\n  by_cases hy : y = 0; · exfalso; simp [hy] at h\n  refine (o.oangle_eq_angle_or_eq_neg_angle hx hy).resolve_right ?_\n  intro hxy\n  rw [hxy, Real.Angle.sign_neg, neg_eq_iff_eq_neg, ← SignType.neg_iff, ← not_le] at h\n  exact h (Real.Angle.sign_coe_nonneg_of_nonneg_of_le_pi (InnerProductGeometry.angle_nonneg _ _)\n    (InnerProductGeometry.angle_le_pi _ _))\n\n"}
{"name":"Orientation.oangle_eq_neg_angle_of_sign_eq_neg_one","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Eq (o.oangle x y).sign (-1)\n⊢ Eq (o.oangle x y) (Neg.neg ↑(InnerProductGeometry.angle x y))","decl":"/-- The oriented angle between two vectors equals minus the unoriented angle if the sign is\nnegative. -/\ntheorem oangle_eq_neg_angle_of_sign_eq_neg_one {x y : V} (h : (o.oangle x y).sign = -1) :\n    o.oangle x y = -InnerProductGeometry.angle x y := by\n  by_cases hx : x = 0; · exfalso; simp [hx] at h\n  by_cases hy : y = 0; · exfalso; simp [hy] at h\n  refine (o.oangle_eq_angle_or_eq_neg_angle hx hy).resolve_left ?_\n  intro hxy\n  rw [hxy, ← SignType.neg_iff, ← not_le] at h\n  exact h (Real.Angle.sign_coe_nonneg_of_nonneg_of_le_pi (InnerProductGeometry.angle_nonneg _ _)\n    (InnerProductGeometry.angle_le_pi _ _))\n\n"}
{"name":"Orientation.oangle_eq_zero_iff_angle_eq_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nhx : Ne x 0\nhy : Ne y 0\n⊢ Iff (Eq (o.oangle x y) 0) (Eq (InnerProductGeometry.angle x y) 0)","decl":"/-- The oriented angle between two nonzero vectors is zero if and only if the unoriented angle\nis zero. -/\ntheorem oangle_eq_zero_iff_angle_eq_zero {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) :\n    o.oangle x y = 0 ↔ InnerProductGeometry.angle x y = 0 := by\n  refine ⟨fun h => ?_, fun h => ?_⟩\n  · simpa [o.angle_eq_abs_oangle_toReal hx hy]\n  · have ha := o.oangle_eq_angle_or_eq_neg_angle hx hy\n    rw [h] at ha\n    simpa using ha\n\n"}
{"name":"Orientation.oangle_eq_pi_iff_angle_eq_pi","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Iff (Eq (o.oangle x y) ↑Real.pi) (Eq (InnerProductGeometry.angle x y) Real.pi)","decl":"/-- The oriented angle between two vectors is `π` if and only if the unoriented angle is `π`. -/\ntheorem oangle_eq_pi_iff_angle_eq_pi {x y : V} :\n    o.oangle x y = π ↔ InnerProductGeometry.angle x y = π := by\n  by_cases hx : x = 0\n  · simp [hx, Real.Angle.pi_ne_zero.symm, div_eq_mul_inv, mul_right_eq_self₀, not_or,\n      Real.pi_ne_zero]\n  by_cases hy : y = 0\n  · simp [hy, Real.Angle.pi_ne_zero.symm, div_eq_mul_inv, mul_right_eq_self₀, not_or,\n      Real.pi_ne_zero]\n  refine ⟨fun h => ?_, fun h => ?_⟩\n  · rw [o.angle_eq_abs_oangle_toReal hx hy, h]\n    simp [Real.pi_pos.le]\n  · have ha := o.oangle_eq_angle_or_eq_neg_angle hx hy\n    rw [h] at ha\n    simpa using ha\n\n"}
{"name":"Orientation.eq_zero_or_oangle_eq_iff_inner_eq_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Iff (Or (Eq x 0) (Or (Eq y 0) (Or (Eq (o.oangle x y) ↑(HDiv.hDiv Real.pi 2)) (Eq (o.oangle x y) ↑(HDiv.hDiv (Neg.neg Real.pi) 2))))) (Eq (Inner.inner x y) 0)","decl":"/-- One of two vectors is zero or the oriented angle between them is plus or minus `π / 2` if\nand only if the inner product of those vectors is zero. -/\ntheorem eq_zero_or_oangle_eq_iff_inner_eq_zero {x y : V} :\n    x = 0 ∨ y = 0 ∨ o.oangle x y = (π / 2 : ℝ) ∨ o.oangle x y = (-π / 2 : ℝ) ↔ ⟪x, y⟫ = 0 := by\n  by_cases hx : x = 0; · simp [hx]\n  by_cases hy : y = 0; · simp [hy]\n  rw [InnerProductGeometry.inner_eq_zero_iff_angle_eq_pi_div_two, or_iff_right hx, or_iff_right hy]\n  refine ⟨fun h => ?_, fun h => ?_⟩\n  · rwa [o.angle_eq_abs_oangle_toReal hx hy, Real.Angle.abs_toReal_eq_pi_div_two_iff]\n  · convert o.oangle_eq_angle_or_eq_neg_angle hx hy using 2 <;> rw [h]\n    simp only [neg_div, Real.Angle.coe_neg]\n\n"}
{"name":"Orientation.inner_eq_zero_of_oangle_eq_pi_div_two","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Eq (o.oangle x y) ↑(HDiv.hDiv Real.pi 2)\n⊢ Eq (Inner.inner x y) 0","decl":"/-- If the oriented angle between two vectors is `π / 2`, the inner product of those vectors\nis zero. -/\ntheorem inner_eq_zero_of_oangle_eq_pi_div_two {x y : V} (h : o.oangle x y = (π / 2 : ℝ)) :\n    ⟪x, y⟫ = 0 :=\n  o.eq_zero_or_oangle_eq_iff_inner_eq_zero.1 <| Or.inr <| Or.inr <| Or.inl h\n\n"}
{"name":"Orientation.inner_rev_eq_zero_of_oangle_eq_pi_div_two","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Eq (o.oangle x y) ↑(HDiv.hDiv Real.pi 2)\n⊢ Eq (Inner.inner y x) 0","decl":"/-- If the oriented angle between two vectors is `π / 2`, the inner product of those vectors\n(reversed) is zero. -/\ntheorem inner_rev_eq_zero_of_oangle_eq_pi_div_two {x y : V} (h : o.oangle x y = (π / 2 : ℝ)) :\n    ⟪y, x⟫ = 0 := by rw [real_inner_comm, o.inner_eq_zero_of_oangle_eq_pi_div_two h]\n\n"}
{"name":"Orientation.inner_eq_zero_of_oangle_eq_neg_pi_div_two","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Eq (o.oangle x y) ↑(HDiv.hDiv (Neg.neg Real.pi) 2)\n⊢ Eq (Inner.inner x y) 0","decl":"/-- If the oriented angle between two vectors is `-π / 2`, the inner product of those vectors\nis zero. -/\ntheorem inner_eq_zero_of_oangle_eq_neg_pi_div_two {x y : V} (h : o.oangle x y = (-π / 2 : ℝ)) :\n    ⟪x, y⟫ = 0 :=\n  o.eq_zero_or_oangle_eq_iff_inner_eq_zero.1 <| Or.inr <| Or.inr <| Or.inr h\n\n"}
{"name":"Orientation.inner_rev_eq_zero_of_oangle_eq_neg_pi_div_two","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Eq (o.oangle x y) ↑(HDiv.hDiv (Neg.neg Real.pi) 2)\n⊢ Eq (Inner.inner y x) 0","decl":"/-- If the oriented angle between two vectors is `-π / 2`, the inner product of those vectors\n(reversed) is zero. -/\ntheorem inner_rev_eq_zero_of_oangle_eq_neg_pi_div_two {x y : V} (h : o.oangle x y = (-π / 2 : ℝ)) :\n    ⟪y, x⟫ = 0 := by rw [real_inner_comm, o.inner_eq_zero_of_oangle_eq_neg_pi_div_two h]\n\n"}
{"name":"Orientation.oangle_sign_neg_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Eq (o.oangle (Neg.neg x) y).sign (Neg.neg (o.oangle x y).sign)","decl":"/-- Negating the first vector passed to `oangle` negates the sign of the angle. -/\n@[simp]\ntheorem oangle_sign_neg_left (x y : V) : (o.oangle (-x) y).sign = -(o.oangle x y).sign := by\n  by_cases hx : x = 0; · simp [hx]\n  by_cases hy : y = 0; · simp [hy]\n  rw [o.oangle_neg_left hx hy, Real.Angle.sign_add_pi]\n\n"}
{"name":"Orientation.oangle_sign_neg_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Eq (o.oangle x (Neg.neg y)).sign (Neg.neg (o.oangle x y).sign)","decl":"/-- Negating the second vector passed to `oangle` negates the sign of the angle. -/\n@[simp]\ntheorem oangle_sign_neg_right (x y : V) : (o.oangle x (-y)).sign = -(o.oangle x y).sign := by\n  by_cases hx : x = 0; · simp [hx]\n  by_cases hy : y = 0; · simp [hy]\n  rw [o.oangle_neg_right hx hy, Real.Angle.sign_add_pi]\n\n"}
{"name":"Orientation.oangle_sign_smul_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nr : Real\n⊢ Eq (o.oangle (HSMul.hSMul r x) y).sign (HMul.hMul (SignType.sign r) (o.oangle x y).sign)","decl":"/-- Multiplying the first vector passed to `oangle` by a real multiplies the sign of the angle by\nthe sign of the real. -/\n@[simp]\ntheorem oangle_sign_smul_left (x y : V) (r : ℝ) :\n    (o.oangle (r • x) y).sign = SignType.sign r * (o.oangle x y).sign := by\n  rcases lt_trichotomy r 0 with (h | h | h) <;> simp [h]\n\n"}
{"name":"Orientation.oangle_sign_smul_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nr : Real\n⊢ Eq (o.oangle x (HSMul.hSMul r y)).sign (HMul.hMul (SignType.sign r) (o.oangle x y).sign)","decl":"/-- Multiplying the second vector passed to `oangle` by a real multiplies the sign of the angle by\nthe sign of the real. -/\n@[simp]\ntheorem oangle_sign_smul_right (x y : V) (r : ℝ) :\n    (o.oangle x (r • y)).sign = SignType.sign r * (o.oangle x y).sign := by\n  rcases lt_trichotomy r 0 with (h | h | h) <;> simp [h]\n\n"}
{"name":"Orientation.oangle_smul_add_right_eq_zero_or_eq_pi_iff","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nr : Real\n⊢ Iff (Or (Eq (o.oangle x (HAdd.hAdd (HSMul.hSMul r x) y)) 0) (Eq (o.oangle x (HAdd.hAdd (HSMul.hSMul r x) y)) ↑Real.pi)) (Or (Eq (o.oangle x y) 0) (Eq (o.oangle x y) ↑Real.pi))","decl":"/-- Auxiliary lemma for the proof of `oangle_sign_smul_add_right`; not intended to be used\noutside of that proof. -/\ntheorem oangle_smul_add_right_eq_zero_or_eq_pi_iff {x y : V} (r : ℝ) :\n    o.oangle x (r • x + y) = 0 ∨ o.oangle x (r • x + y) = π ↔\n    o.oangle x y = 0 ∨ o.oangle x y = π := by\n  simp_rw [oangle_eq_zero_or_eq_pi_iff_not_linearIndependent, Fintype.not_linearIndependent_iff,\n      Fin.sum_univ_two, Fin.exists_fin_two]\n  refine ⟨fun h => ?_, fun h => ?_⟩\n  · rcases h with ⟨m, h, hm⟩\n    change m 0 • x + m 1 • (r • x + y) = 0 at h\n    refine ⟨![m 0 + m 1 * r, m 1], ?_⟩\n    change (m 0 + m 1 * r) • x + m 1 • y = 0 ∧ (m 0 + m 1 * r ≠ 0 ∨ m 1 ≠ 0)\n    rw [smul_add, smul_smul, ← add_assoc, ← add_smul] at h\n    refine ⟨h, not_and_or.1 fun h0 => ?_⟩\n    obtain ⟨h0, h1⟩ := h0\n    rw [h1] at h0 hm\n    rw [zero_mul, add_zero] at h0\n    simp [h0] at hm\n  · rcases h with ⟨m, h, hm⟩\n    change m 0 • x + m 1 • y = 0 at h\n    refine ⟨![m 0 - m 1 * r, m 1], ?_⟩\n    change (m 0 - m 1 * r) • x + m 1 • (r • x + y) = 0 ∧ (m 0 - m 1 * r ≠ 0 ∨ m 1 ≠ 0)\n    rw [sub_smul, smul_add, smul_smul, ← add_assoc, sub_add_cancel]\n    refine ⟨h, not_and_or.1 fun h0 => ?_⟩\n    obtain ⟨h0, h1⟩ := h0\n    rw [h1] at h0 hm\n    rw [zero_mul, sub_zero] at h0\n    simp [h0] at hm\n\n"}
{"name":"Orientation.oangle_sign_smul_add_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nr : Real\n⊢ Eq (o.oangle x (HAdd.hAdd (HSMul.hSMul r x) y)).sign (o.oangle x y).sign","decl":"/-- Adding a multiple of the first vector passed to `oangle` to the second vector does not change\nthe sign of the angle. -/\n@[simp]\ntheorem oangle_sign_smul_add_right (x y : V) (r : ℝ) :\n    (o.oangle x (r • x + y)).sign = (o.oangle x y).sign := by\n  by_cases h : o.oangle x y = 0 ∨ o.oangle x y = π\n  · rwa [Real.Angle.sign_eq_zero_iff.2 h, Real.Angle.sign_eq_zero_iff,\n      oangle_smul_add_right_eq_zero_or_eq_pi_iff]\n  have h' : ∀ r' : ℝ, o.oangle x (r' • x + y) ≠ 0 ∧ o.oangle x (r' • x + y) ≠ π := by\n    intro r'\n    rwa [← o.oangle_smul_add_right_eq_zero_or_eq_pi_iff r', not_or] at h\n  let s : Set (V × V) := (fun r' : ℝ => (x, r' • x + y)) '' Set.univ\n  have hc : IsConnected s := isConnected_univ.image _ (continuous_const.prod_mk\n    ((continuous_id.smul continuous_const).add continuous_const)).continuousOn\n  have hf : ContinuousOn (fun z : V × V => o.oangle z.1 z.2) s := by\n    refine continuousOn_of_forall_continuousAt fun z hz => o.continuousAt_oangle ?_ ?_\n    all_goals\n      simp_rw [s, Set.mem_image] at hz\n      obtain ⟨r', -, rfl⟩ := hz\n      simp only [Prod.fst, Prod.snd]\n      intro hz\n    · simpa [hz] using (h' 0).1\n    · simpa [hz] using (h' r').1\n  have hs : ∀ z : V × V, z ∈ s → o.oangle z.1 z.2 ≠ 0 ∧ o.oangle z.1 z.2 ≠ π := by\n    intro z hz\n    simp_rw [s, Set.mem_image] at hz\n    obtain ⟨r', -, rfl⟩ := hz\n    exact h' r'\n  have hx : (x, y) ∈ s := by\n    convert Set.mem_image_of_mem (fun r' : ℝ => (x, r' • x + y)) (Set.mem_univ 0)\n    simp\n  have hy : (x, r • x + y) ∈ s := Set.mem_image_of_mem _ (Set.mem_univ _)\n  convert Real.Angle.sign_eq_of_continuousOn hc hf hs hx hy\n\n"}
{"name":"Orientation.oangle_sign_add_smul_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nr : Real\n⊢ Eq (o.oangle (HAdd.hAdd x (HSMul.hSMul r y)) y).sign (o.oangle x y).sign","decl":"/-- Adding a multiple of the second vector passed to `oangle` to the first vector does not change\nthe sign of the angle. -/\n@[simp]\ntheorem oangle_sign_add_smul_left (x y : V) (r : ℝ) :\n    (o.oangle (x + r • y) y).sign = (o.oangle x y).sign := by\n  simp_rw [o.oangle_rev y, Real.Angle.sign_neg, add_comm x, oangle_sign_smul_add_right]\n\n"}
{"name":"Orientation.oangle_sign_sub_smul_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nr : Real\n⊢ Eq (o.oangle x (HSub.hSub y (HSMul.hSMul r x))).sign (o.oangle x y).sign","decl":"/-- Subtracting a multiple of the first vector passed to `oangle` from the second vector does\nnot change the sign of the angle. -/\n@[simp]\ntheorem oangle_sign_sub_smul_right (x y : V) (r : ℝ) :\n    (o.oangle x (y - r • x)).sign = (o.oangle x y).sign := by\n  rw [sub_eq_add_neg, ← neg_smul, add_comm, oangle_sign_smul_add_right]\n\n"}
{"name":"Orientation.oangle_sign_sub_smul_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nr : Real\n⊢ Eq (o.oangle (HSub.hSub x (HSMul.hSMul r y)) y).sign (o.oangle x y).sign","decl":"/-- Subtracting a multiple of the second vector passed to `oangle` from the first vector does\nnot change the sign of the angle. -/\n@[simp]\ntheorem oangle_sign_sub_smul_left (x y : V) (r : ℝ) :\n    (o.oangle (x - r • y) y).sign = (o.oangle x y).sign := by\n  rw [sub_eq_add_neg, ← neg_smul, oangle_sign_add_smul_left]\n\n"}
{"name":"Orientation.oangle_sign_add_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Eq (o.oangle x (HAdd.hAdd x y)).sign (o.oangle x y).sign","decl":"/-- Adding the first vector passed to `oangle` to the second vector does not change the sign of\nthe angle. -/\n@[simp]\ntheorem oangle_sign_add_right (x y : V) : (o.oangle x (x + y)).sign = (o.oangle x y).sign := by\n  rw [← o.oangle_sign_smul_add_right x y 1, one_smul]\n\n"}
{"name":"Orientation.oangle_sign_add_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Eq (o.oangle (HAdd.hAdd x y) y).sign (o.oangle x y).sign","decl":"/-- Adding the second vector passed to `oangle` to the first vector does not change the sign of\nthe angle. -/\n@[simp]\ntheorem oangle_sign_add_left (x y : V) : (o.oangle (x + y) y).sign = (o.oangle x y).sign := by\n  rw [← o.oangle_sign_add_smul_left x y 1, one_smul]\n\n"}
{"name":"Orientation.oangle_sign_sub_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Eq (o.oangle x (HSub.hSub y x)).sign (o.oangle x y).sign","decl":"/-- Subtracting the first vector passed to `oangle` from the second vector does not change the\nsign of the angle. -/\n@[simp]\ntheorem oangle_sign_sub_right (x y : V) : (o.oangle x (y - x)).sign = (o.oangle x y).sign := by\n  rw [← o.oangle_sign_sub_smul_right x y 1, one_smul]\n\n"}
{"name":"Orientation.oangle_sign_sub_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Eq (o.oangle (HSub.hSub x y) y).sign (o.oangle x y).sign","decl":"/-- Subtracting the second vector passed to `oangle` from the first vector does not change the\nsign of the angle. -/\n@[simp]\ntheorem oangle_sign_sub_left (x y : V) : (o.oangle (x - y) y).sign = (o.oangle x y).sign := by\n  rw [← o.oangle_sign_sub_smul_left x y 1, one_smul]\n\n"}
{"name":"Orientation.oangle_sign_smul_sub_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nr : Real\n⊢ Eq (o.oangle x (HSub.hSub (HSMul.hSMul r x) y)).sign (Neg.neg (o.oangle x y).sign)","decl":"/-- Subtracting the second vector passed to `oangle` from a multiple of the first vector negates\nthe sign of the angle. -/\n@[simp]\ntheorem oangle_sign_smul_sub_right (x y : V) (r : ℝ) :\n    (o.oangle x (r • x - y)).sign = -(o.oangle x y).sign := by\n  rw [← oangle_sign_neg_right, sub_eq_add_neg, oangle_sign_smul_add_right]\n\n"}
{"name":"Orientation.oangle_sign_smul_sub_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nr : Real\n⊢ Eq (o.oangle (HSub.hSub (HSMul.hSMul r y) x) y).sign (Neg.neg (o.oangle x y).sign)","decl":"/-- Subtracting the first vector passed to `oangle` from a multiple of the second vector negates\nthe sign of the angle. -/\n@[simp]\ntheorem oangle_sign_smul_sub_left (x y : V) (r : ℝ) :\n    (o.oangle (r • y - x) y).sign = -(o.oangle x y).sign := by\n  rw [← oangle_sign_neg_left, sub_eq_neg_add, oangle_sign_add_smul_left]\n\n"}
{"name":"Orientation.oangle_sign_sub_right_eq_neg","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Eq (o.oangle x (HSub.hSub x y)).sign (Neg.neg (o.oangle x y).sign)","decl":"/-- Subtracting the second vector passed to `oangle` from the first vector negates the sign of\nthe angle. -/\ntheorem oangle_sign_sub_right_eq_neg (x y : V) :\n    (o.oangle x (x - y)).sign = -(o.oangle x y).sign := by\n  rw [← o.oangle_sign_smul_sub_right x y 1, one_smul]\n\n"}
{"name":"Orientation.oangle_sign_sub_left_eq_neg","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Eq (o.oangle (HSub.hSub y x) y).sign (Neg.neg (o.oangle x y).sign)","decl":"/-- Subtracting the first vector passed to `oangle` from the second vector negates the sign of\nthe angle. -/\ntheorem oangle_sign_sub_left_eq_neg (x y : V) :\n    (o.oangle (y - x) y).sign = -(o.oangle x y).sign := by\n  rw [← o.oangle_sign_smul_sub_left x y 1, one_smul]\n\n"}
{"name":"Orientation.oangle_sign_sub_right_swap","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Eq (o.oangle y (HSub.hSub y x)).sign (o.oangle x y).sign","decl":"/-- Subtracting the first vector passed to `oangle` from the second vector then swapping the\nvectors does not change the sign of the angle. -/\n@[simp]\ntheorem oangle_sign_sub_right_swap (x y : V) : (o.oangle y (y - x)).sign = (o.oangle x y).sign := by\n  rw [oangle_sign_sub_right_eq_neg, o.oangle_rev y x, Real.Angle.sign_neg]\n\n"}
{"name":"Orientation.oangle_sign_sub_left_swap","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Eq (o.oangle (HSub.hSub x y) x).sign (o.oangle x y).sign","decl":"/-- Subtracting the second vector passed to `oangle` from the first vector then swapping the\nvectors does not change the sign of the angle. -/\n@[simp]\ntheorem oangle_sign_sub_left_swap (x y : V) : (o.oangle (x - y) x).sign = (o.oangle x y).sign := by\n  rw [oangle_sign_sub_left_eq_neg, o.oangle_rev y x, Real.Angle.sign_neg]\n\n"}
{"name":"Orientation.oangle_sign_smul_add_smul_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nr₁ r₂ : Real\n⊢ Eq (o.oangle x (HAdd.hAdd (HSMul.hSMul r₁ x) (HSMul.hSMul r₂ y))).sign (HMul.hMul (SignType.sign r₂) (o.oangle x y).sign)","decl":"/-- The sign of the angle between a vector, and a linear combination of that vector with a second\nvector, is the sign of the factor by which the second vector is multiplied in that combination\nmultiplied by the sign of the angle between the two vectors. -/\ntheorem oangle_sign_smul_add_smul_right (x y : V) (r₁ r₂ : ℝ) :\n    (o.oangle x (r₁ • x + r₂ • y)).sign = SignType.sign r₂ * (o.oangle x y).sign := by\n  rw [← o.oangle_sign_smul_add_right x (r₁ • x + r₂ • y) (-r₁)]\n  simp\n\n"}
{"name":"Orientation.oangle_sign_smul_add_smul_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nr₁ r₂ : Real\n⊢ Eq (o.oangle (HAdd.hAdd (HSMul.hSMul r₁ x) (HSMul.hSMul r₂ y)) y).sign (HMul.hMul (SignType.sign r₁) (o.oangle x y).sign)","decl":"/-- The sign of the angle between a linear combination of two vectors and the second vector is\nthe sign of the factor by which the first vector is multiplied in that combination multiplied by\nthe sign of the angle between the two vectors. -/\ntheorem oangle_sign_smul_add_smul_left (x y : V) (r₁ r₂ : ℝ) :\n    (o.oangle (r₁ • x + r₂ • y) y).sign = SignType.sign r₁ * (o.oangle x y).sign := by\n  simp_rw [o.oangle_rev y, Real.Angle.sign_neg, add_comm (r₁ • x), oangle_sign_smul_add_smul_right,\n    mul_neg]\n\n"}
{"name":"Orientation.oangle_sign_smul_add_smul_smul_add_smul","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nr₁ r₂ r₃ r₄ : Real\n⊢ Eq (o.oangle (HAdd.hAdd (HSMul.hSMul r₁ x) (HSMul.hSMul r₂ y)) (HAdd.hAdd (HSMul.hSMul r₃ x) (HSMul.hSMul r₄ y))).sign (HMul.hMul (SignType.sign (HSub.hSub (HMul.hMul r₁ r₄) (HMul.hMul r₂ r₃))) (o.oangle x y).sign)","decl":"/-- The sign of the angle between two linear combinations of two vectors is the sign of the\ndeterminant of the factors in those combinations multiplied by the sign of the angle between the\ntwo vectors. -/\ntheorem oangle_sign_smul_add_smul_smul_add_smul (x y : V) (r₁ r₂ r₃ r₄ : ℝ) :\n    (o.oangle (r₁ • x + r₂ • y) (r₃ • x + r₄ • y)).sign =\n      SignType.sign (r₁ * r₄ - r₂ * r₃) * (o.oangle x y).sign := by\n  by_cases hr₁ : r₁ = 0\n  · rw [hr₁, zero_smul, zero_mul, zero_add, zero_sub, Left.sign_neg,\n      oangle_sign_smul_left, add_comm, oangle_sign_smul_add_smul_right, oangle_rev,\n      Real.Angle.sign_neg, sign_mul, mul_neg, mul_neg, neg_mul, mul_assoc]\n  · rw [← o.oangle_sign_smul_add_right (r₁ • x + r₂ • y) (r₃ • x + r₄ • y) (-r₃ / r₁), smul_add,\n      smul_smul, smul_smul, div_mul_cancel₀ _ hr₁, neg_smul, ← add_assoc, add_comm (-(r₃ • x)), ←\n      sub_eq_add_neg, sub_add_cancel, ← add_smul, oangle_sign_smul_right,\n      oangle_sign_smul_add_smul_left, ← mul_assoc, ← sign_mul, add_mul, mul_assoc, mul_comm r₂ r₁, ←\n      mul_assoc, div_mul_cancel₀ _ hr₁, add_comm, neg_mul, ← sub_eq_add_neg, mul_comm r₄,\n      mul_comm r₃]\n\n"}
{"name":"Orientation.abs_oangle_sub_left_toReal_lt_pi_div_two","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Eq (Norm.norm x) (Norm.norm y)\n⊢ LT.lt (abs (o.oangle (HSub.hSub y x) y).toReal) (HDiv.hDiv Real.pi 2)","decl":"/-- A base angle of an isosceles triangle is acute, oriented vector angle form. -/\ntheorem abs_oangle_sub_left_toReal_lt_pi_div_two {x y : V} (h : ‖x‖ = ‖y‖) :\n    |(o.oangle (y - x) y).toReal| < π / 2 := by\n  by_cases hn : x = y; · simp [hn, div_pos, Real.pi_pos]\n  have hs : ((2 : ℤ) • o.oangle (y - x) y).sign = (o.oangle (y - x) y).sign := by\n    conv_rhs => rw [oangle_sign_sub_left_swap]\n    rw [o.oangle_eq_pi_sub_two_zsmul_oangle_sub_of_norm_eq hn h, Real.Angle.sign_pi_sub]\n  rw [Real.Angle.sign_two_zsmul_eq_sign_iff] at hs\n  rcases hs with (hs | hs)\n  · rw [oangle_eq_pi_iff_oangle_rev_eq_pi, oangle_eq_pi_iff_sameRay_neg, neg_sub] at hs\n    rcases hs with ⟨hy, -, hr⟩\n    rw [← exists_nonneg_left_iff_sameRay hy] at hr\n    rcases hr with ⟨r, hr0, hr⟩\n    rw [eq_sub_iff_add_eq] at hr\n    nth_rw 2 [← one_smul ℝ y] at hr\n    rw [← add_smul] at hr\n    rw [← hr, norm_smul, Real.norm_eq_abs, abs_of_pos (Left.add_pos_of_nonneg_of_pos hr0 one_pos),\n      mul_left_eq_self₀, or_iff_left (norm_ne_zero_iff.2 hy), add_left_eq_self] at h\n    rw [h, zero_add, one_smul] at hr\n    exact False.elim (hn hr.symm)\n  · exact hs\n\n"}
{"name":"Orientation.abs_oangle_sub_right_toReal_lt_pi_div_two","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Basic","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nh : Eq (Norm.norm x) (Norm.norm y)\n⊢ LT.lt (abs (o.oangle x (HSub.hSub x y)).toReal) (HDiv.hDiv Real.pi 2)","decl":"/-- A base angle of an isosceles triangle is acute, oriented vector angle form. -/\ntheorem abs_oangle_sub_right_toReal_lt_pi_div_two {x y : V} (h : ‖x‖ = ‖y‖) :\n    |(o.oangle x (x - y)).toReal| < π / 2 :=\n  (o.oangle_sub_eq_oangle_sub_rev_of_norm_eq h).symm ▸ o.abs_oangle_sub_left_toReal_lt_pi_div_two h\n\n"}
