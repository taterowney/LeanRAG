{"name":"LieAlgebra.derivedSeriesOfIdeal_zero","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\n⊢ Eq (LieAlgebra.derivedSeriesOfIdeal R L 0 I) I","decl":"@[simp]\ntheorem derivedSeriesOfIdeal_zero : derivedSeriesOfIdeal R L 0 I = I :=\n  rfl\n\n"}
{"name":"LieAlgebra.derivedSeriesOfIdeal_succ","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\nk : Nat\n⊢ Eq (LieAlgebra.derivedSeriesOfIdeal R L (HAdd.hAdd k 1) I) (Bracket.bracket (LieAlgebra.derivedSeriesOfIdeal R L k I) (LieAlgebra.derivedSeriesOfIdeal R L k I))","decl":"@[simp]\ntheorem derivedSeriesOfIdeal_succ (k : ℕ) :\n    derivedSeriesOfIdeal R L (k + 1) I =\n      ⁅derivedSeriesOfIdeal R L k I, derivedSeriesOfIdeal R L k I⁆ :=\n  Function.iterate_succ_apply' (fun I => ⁅I, I⁆) k I\n\n"}
{"name":"LieAlgebra.derivedSeries_def","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nk : Nat\n⊢ Eq (LieAlgebra.derivedSeries R L k) (LieAlgebra.derivedSeriesOfIdeal R L k Top.top)","decl":"theorem derivedSeries_def (k : ℕ) : derivedSeries R L k = derivedSeriesOfIdeal R L k ⊤ :=\n  rfl\n\n"}
{"name":"LieAlgebra.derivedSeriesOfIdeal_add","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\nk l : Nat\n⊢ Eq (LieAlgebra.derivedSeriesOfIdeal R L (HAdd.hAdd k l) I) (LieAlgebra.derivedSeriesOfIdeal R L k (LieAlgebra.derivedSeriesOfIdeal R L l I))","decl":"theorem derivedSeriesOfIdeal_add (k l : ℕ) : D (k + l) I = D k (D l I) := by\n  induction k with\n  | zero => rw [Nat.zero_add, derivedSeriesOfIdeal_zero]\n  | succ k ih => rw [Nat.succ_add k l, derivedSeriesOfIdeal_succ, derivedSeriesOfIdeal_succ, ih]\n\n"}
{"name":"LieAlgebra.derivedSeriesOfIdeal_le","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI J : LieIdeal R L\nk l : Nat\nh₁ : LE.le I J\nh₂ : LE.le l k\n⊢ LE.le (LieAlgebra.derivedSeriesOfIdeal R L k I) (LieAlgebra.derivedSeriesOfIdeal R L l J)","decl":"@[gcongr, mono]\ntheorem derivedSeriesOfIdeal_le {I J : LieIdeal R L} {k l : ℕ} (h₁ : I ≤ J) (h₂ : l ≤ k) :\n    D k I ≤ D l J := by\n  revert l; induction' k with k ih <;> intro l h₂\n  · rw [le_zero_iff] at h₂; rw [h₂, derivedSeriesOfIdeal_zero]; exact h₁\n  · have h : l = k.succ ∨ l ≤ k := by rwa [le_iff_eq_or_lt, Nat.lt_succ_iff] at h₂\n    cases' h with h h\n    · rw [h, derivedSeriesOfIdeal_succ, derivedSeriesOfIdeal_succ]\n      exact LieSubmodule.mono_lie (ih (le_refl k)) (ih (le_refl k))\n    · rw [derivedSeriesOfIdeal_succ]; exact le_trans (LieSubmodule.lie_le_left _ _) (ih h)\n\n"}
{"name":"LieAlgebra.derivedSeriesOfIdeal_succ_le","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\nk : Nat\n⊢ LE.le (LieAlgebra.derivedSeriesOfIdeal R L (HAdd.hAdd k 1) I) (LieAlgebra.derivedSeriesOfIdeal R L k I)","decl":"theorem derivedSeriesOfIdeal_succ_le (k : ℕ) : D (k + 1) I ≤ D k I :=\n  derivedSeriesOfIdeal_le (le_refl I) k.le_succ\n\n"}
{"name":"LieAlgebra.derivedSeriesOfIdeal_le_self","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\nk : Nat\n⊢ LE.le (LieAlgebra.derivedSeriesOfIdeal R L k I) I","decl":"theorem derivedSeriesOfIdeal_le_self (k : ℕ) : D k I ≤ I :=\n  derivedSeriesOfIdeal_le (le_refl I) (zero_le k)\n\n"}
{"name":"LieAlgebra.derivedSeriesOfIdeal_mono","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI J : LieIdeal R L\nh : LE.le I J\nk : Nat\n⊢ LE.le (LieAlgebra.derivedSeriesOfIdeal R L k I) (LieAlgebra.derivedSeriesOfIdeal R L k J)","decl":"theorem derivedSeriesOfIdeal_mono {I J : LieIdeal R L} (h : I ≤ J) (k : ℕ) : D k I ≤ D k J :=\n  derivedSeriesOfIdeal_le h (le_refl k)\n\n"}
{"name":"LieAlgebra.derivedSeriesOfIdeal_antitone","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\nk l : Nat\nh : LE.le l k\n⊢ LE.le (LieAlgebra.derivedSeriesOfIdeal R L k I) (LieAlgebra.derivedSeriesOfIdeal R L l I)","decl":"theorem derivedSeriesOfIdeal_antitone {k l : ℕ} (h : l ≤ k) : D k I ≤ D l I :=\n  derivedSeriesOfIdeal_le (le_refl I) h\n\n"}
{"name":"LieAlgebra.derivedSeriesOfIdeal_add_le_add","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI J : LieIdeal R L\nk l : Nat\n⊢ LE.le (LieAlgebra.derivedSeriesOfIdeal R L (HAdd.hAdd k l) (HAdd.hAdd I J)) (HAdd.hAdd (LieAlgebra.derivedSeriesOfIdeal R L k I) (LieAlgebra.derivedSeriesOfIdeal R L l J))","decl":"theorem derivedSeriesOfIdeal_add_le_add (J : LieIdeal R L) (k l : ℕ) :\n    D (k + l) (I + J) ≤ D k I + D l J := by\n  let D₁ : LieIdeal R L →o LieIdeal R L :=\n    { toFun := fun I => ⁅I, I⁆\n      monotone' := fun I J h => LieSubmodule.mono_lie h h }\n  have h₁ : ∀ I J : LieIdeal R L, D₁ (I ⊔ J) ≤ D₁ I ⊔ J := by\n    simp [D₁, LieSubmodule.lie_le_right, LieSubmodule.lie_le_left, le_sup_of_le_right]\n  rw [← D₁.iterate_sup_le_sup_iff] at h₁\n  exact h₁ k l I J\n\n"}
{"name":"LieAlgebra.derivedSeries_of_bot_eq_bot","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nk : Nat\n⊢ Eq (LieAlgebra.derivedSeriesOfIdeal R L k Bot.bot) Bot.bot","decl":"theorem derivedSeries_of_bot_eq_bot (k : ℕ) : derivedSeriesOfIdeal R L k ⊥ = ⊥ := by\n  rw [eq_bot_iff]; exact derivedSeriesOfIdeal_le_self ⊥ k\n\n"}
{"name":"LieAlgebra.abelian_iff_derived_one_eq_bot","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\n⊢ Iff (IsLieAbelian (Subtype fun x => Membership.mem I x)) (Eq (LieAlgebra.derivedSeriesOfIdeal R L 1 I) Bot.bot)","decl":"theorem abelian_iff_derived_one_eq_bot : IsLieAbelian I ↔ derivedSeriesOfIdeal R L 1 I = ⊥ := by\n  rw [derivedSeriesOfIdeal_succ, derivedSeriesOfIdeal_zero,\n    LieSubmodule.lie_abelian_iff_lie_self_eq_bot]\n\n"}
{"name":"LieAlgebra.abelian_iff_derived_succ_eq_bot","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\nk : Nat\n⊢ Iff (IsLieAbelian (Subtype fun x => Membership.mem (LieAlgebra.derivedSeriesOfIdeal R L k I) x)) (Eq (LieAlgebra.derivedSeriesOfIdeal R L (HAdd.hAdd k 1) I) Bot.bot)","decl":"theorem abelian_iff_derived_succ_eq_bot (I : LieIdeal R L) (k : ℕ) :\n    IsLieAbelian (derivedSeriesOfIdeal R L k I) ↔ derivedSeriesOfIdeal R L (k + 1) I = ⊥ := by\n  rw [add_comm, derivedSeriesOfIdeal_add I 1 k, abelian_iff_derived_one_eq_bot]\n\n"}
{"name":"LieAlgebra.derivedSeriesOfIdeal_baseChange","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\nI : LieIdeal R L\nA : Type u_1\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nk : Nat\n⊢ Eq (LieAlgebra.derivedSeriesOfIdeal A (TensorProduct R A L) k (LieSubmodule.baseChange A I)) (LieSubmodule.baseChange A (LieAlgebra.derivedSeriesOfIdeal R L k I))","decl":"open TensorProduct in\n@[simp] theorem derivedSeriesOfIdeal_baseChange {A : Type*} [CommRing A] [Algebra R A] (k : ℕ) :\n    derivedSeriesOfIdeal A (A ⊗[R] L) k (I.baseChange A) =\n      (derivedSeriesOfIdeal R L k I).baseChange A := by\n  induction k with\n  | zero => simp\n  | succ k ih => simp only [derivedSeriesOfIdeal_succ, ih, ← LieSubmodule.baseChange_top,\n    LieSubmodule.lie_baseChange]\n\n"}
{"name":"LieAlgebra.derivedSeries_baseChange","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\nA : Type u_1\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nk : Nat\n⊢ Eq (LieAlgebra.derivedSeries A (TensorProduct R A L) k) (LieSubmodule.baseChange A (LieAlgebra.derivedSeries R L k))","decl":"open TensorProduct in\n@[simp] theorem derivedSeries_baseChange {A : Type*} [CommRing A] [Algebra R A] (k : ℕ) :\n    derivedSeries A (A ⊗[R] L) k = (derivedSeries R L k).baseChange A := by\n  rw [derivedSeries_def, derivedSeries_def, ← derivedSeriesOfIdeal_baseChange,\n    LieSubmodule.baseChange_top]\n\n"}
{"name":"LieIdeal.derivedSeries_eq_derivedSeriesOfIdeal_comap","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\nk : Nat\n⊢ Eq (LieAlgebra.derivedSeries R (Subtype fun x => Membership.mem I x) k) (LieIdeal.comap I.incl (LieAlgebra.derivedSeriesOfIdeal R L k I))","decl":"theorem derivedSeries_eq_derivedSeriesOfIdeal_comap (k : ℕ) :\n    derivedSeries R I k = (derivedSeriesOfIdeal R L k I).comap I.incl := by\n  induction k with\n  | zero => simp only [derivedSeries_def, comap_incl_self, derivedSeriesOfIdeal_zero]\n  | succ k ih =>\n    simp only [derivedSeries_def, derivedSeriesOfIdeal_succ] at ih ⊢; rw [ih]\n    exact comap_bracket_incl_of_le I (derivedSeriesOfIdeal_le_self I k)\n      (derivedSeriesOfIdeal_le_self I k)\n\n"}
{"name":"LieIdeal.derivedSeries_eq_derivedSeriesOfIdeal_map","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\nk : Nat\n⊢ Eq (LieIdeal.map I.incl (LieAlgebra.derivedSeries R (Subtype fun x => Membership.mem I x) k)) (LieAlgebra.derivedSeriesOfIdeal R L k I)","decl":"theorem derivedSeries_eq_derivedSeriesOfIdeal_map (k : ℕ) :\n    (derivedSeries R I k).map I.incl = derivedSeriesOfIdeal R L k I := by\n  rw [derivedSeries_eq_derivedSeriesOfIdeal_comap, map_comap_incl, inf_eq_right]\n  apply derivedSeriesOfIdeal_le_self\n\n"}
{"name":"LieIdeal.derivedSeries_eq_bot_iff","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\nk : Nat\n⊢ Iff (Eq (LieAlgebra.derivedSeries R (Subtype fun x => Membership.mem I x) k) Bot.bot) (Eq (LieAlgebra.derivedSeriesOfIdeal R L k I) Bot.bot)","decl":"theorem derivedSeries_eq_bot_iff (k : ℕ) :\n    derivedSeries R I k = ⊥ ↔ derivedSeriesOfIdeal R L k I = ⊥ := by\n  rw [← derivedSeries_eq_derivedSeriesOfIdeal_map, map_eq_bot_iff, ker_incl, eq_bot_iff]\n\n"}
{"name":"LieIdeal.derivedSeries_add_eq_bot","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nk l : Nat\nI J : LieIdeal R L\nhI : Eq (LieAlgebra.derivedSeries R (Subtype fun x => Membership.mem I x) k) Bot.bot\nhJ : Eq (LieAlgebra.derivedSeries R (Subtype fun x => Membership.mem J x) l) Bot.bot\n⊢ Eq (LieAlgebra.derivedSeries R (Subtype fun x => Membership.mem (HAdd.hAdd I J) x) (HAdd.hAdd k l)) Bot.bot","decl":"theorem derivedSeries_add_eq_bot {k l : ℕ} {I J : LieIdeal R L} (hI : derivedSeries R I k = ⊥)\n    (hJ : derivedSeries R J l = ⊥) : derivedSeries R (I + J) (k + l) = ⊥ := by\n  rw [LieIdeal.derivedSeries_eq_bot_iff] at hI hJ ⊢\n  rw [← le_bot_iff]\n  let D := derivedSeriesOfIdeal R L; change D k I = ⊥ at hI; change D l J = ⊥ at hJ\n  calc\n    D (k + l) (I + J) ≤ D k I + D l J := derivedSeriesOfIdeal_add_le_add I J k l\n    _ ≤ ⊥ := by rw [hI, hJ]; simp\n\n"}
{"name":"LieIdeal.derivedSeries_map_le","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\nL' : Type w₁\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : LieRing L'\ninst✝ : LieAlgebra R L'\nf : LieHom R L' L\nk : Nat\n⊢ LE.le (LieIdeal.map f (LieAlgebra.derivedSeries R L' k)) (LieAlgebra.derivedSeries R L k)","decl":"theorem derivedSeries_map_le (k : ℕ) : (derivedSeries R L' k).map f ≤ derivedSeries R L k := by\n  induction k with\n  | zero => simp only [derivedSeries_def, derivedSeriesOfIdeal_zero, le_top]\n  | succ k ih =>\n    simp only [derivedSeries_def, derivedSeriesOfIdeal_succ] at ih ⊢\n    exact le_trans (map_bracket_le f) (LieSubmodule.mono_lie ih ih)\n\n"}
{"name":"LieIdeal.derivedSeries_map_eq","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\nL' : Type w₁\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : LieRing L'\ninst✝ : LieAlgebra R L'\nf : LieHom R L' L\nk : Nat\nh : Function.Surjective ⇑f\n⊢ Eq (LieIdeal.map f (LieAlgebra.derivedSeries R L' k)) (LieAlgebra.derivedSeries R L k)","decl":"theorem derivedSeries_map_eq (k : ℕ) (h : Function.Surjective f) :\n    (derivedSeries R L' k).map f = derivedSeries R L k := by\n  induction k with\n  | zero =>\n    change (⊤ : LieIdeal R L').map f = ⊤\n    rw [← f.idealRange_eq_map]\n    exact f.idealRange_eq_top_of_surjective h\n  | succ k ih => simp only [derivedSeries_def, map_bracket_eq f h, ih, derivedSeriesOfIdeal_succ]\n\n"}
{"name":"LieIdeal.derivedSeries_succ_eq_top_iff","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nn : Nat\n⊢ Iff (Eq (LieAlgebra.derivedSeries R L (HAdd.hAdd n 1)) Top.top) (Eq (LieAlgebra.derivedSeries R L 1) Top.top)","decl":"theorem derivedSeries_succ_eq_top_iff (n : ℕ) :\n    derivedSeries R L (n + 1) = ⊤ ↔ derivedSeries R L 1 = ⊤ := by\n  simp only [derivedSeries_def]\n  induction n with\n  | zero => simp\n  | succ n ih =>\n    rw [derivedSeriesOfIdeal_succ]\n    refine ⟨fun h ↦ ?_, fun h ↦ by rwa [ih.mpr h]⟩\n    rw [← ih, eq_top_iff]\n    conv_lhs => rw [← h]\n    exact LieSubmodule.lie_le_right _ _\n\n"}
{"name":"LieIdeal.derivedSeries_eq_top","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nn : Nat\nh : Eq (LieAlgebra.derivedSeries R L 1) Top.top\n⊢ Eq (LieAlgebra.derivedSeries R L n) Top.top","decl":"theorem derivedSeries_eq_top (n : ℕ) (h : derivedSeries R L 1 = ⊤) :\n    derivedSeries R L n = ⊤ := by\n  cases n\n  · rfl\n  · rwa [derivedSeries_succ_eq_top_iff]\n\n"}
{"name":"LieIdeal.coe_derivedSeries_eq_int","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nk : Nat\n⊢ Eq ↑(LieAlgebra.derivedSeries R L k) ↑(LieAlgebra.derivedSeries Int L k)","decl":"theorem coe_derivedSeries_eq_int (k : ℕ) :\n    (derivedSeries R L k : Set L) = (derivedSeries ℤ L k : Set L) := by\n  show ((derivedSeries R L k).toSubmodule : Set L) = ((derivedSeries ℤ L k).toSubmodule : Set L)\n  rw [derivedSeries_def, derivedSeries_def]\n  induction k with\n  | zero => rfl\n  | succ k ih =>\n    rw [derivedSeriesOfIdeal_succ, derivedSeriesOfIdeal_succ]\n    rw [LieSubmodule.lieIdeal_oper_eq_linear_span', LieSubmodule.lieIdeal_oper_eq_linear_span']\n    rw [Set.ext_iff] at ih\n    simp only [SetLike.mem_coe, LieSubmodule.mem_toSubmodule] at ih\n    simp only [Subtype.exists, exists_prop, ih]\n    apply le_antisymm\n    · exact coe_derivedSeries_eq_int_aux _ _ L k ih\n    · simp only [← ih]\n      apply coe_derivedSeries_eq_int_aux _ _ L k\n      simp [ih]\n\n"}
{"name":"LieAlgebra.IsSolvable.solvable_int","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"L : Type v\ninst✝ : LieRing L\nself : LieAlgebra.IsSolvable L\n⊢ Exists fun k => Eq (LieAlgebra.derivedSeries Int L k) Bot.bot","decl":"/-- A Lie algebra is solvable if its derived series reaches 0 (in a finite number of steps). -/\n@[mk_iff isSolvable_iff_int]\nclass IsSolvable : Prop where\n  mk_int ::\n  solvable_int : ∃ k, derivedSeries ℤ L k = ⊥\n\n"}
{"name":"LieAlgebra.isSolvable_iff_int","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"L : Type v\ninst✝ : LieRing L\n⊢ Iff (LieAlgebra.IsSolvable L) (Exists fun k => Eq (LieAlgebra.derivedSeries Int L k) Bot.bot)","decl":"/-- A Lie algebra is solvable if its derived series reaches 0 (in a finite number of steps). -/\n@[mk_iff isSolvable_iff_int]\nclass IsSolvable : Prop where\n  mk_int ::\n  solvable_int : ∃ k, derivedSeries ℤ L k = ⊥\n\n"}
{"name":"LieAlgebra.isSolvableBot","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ LieAlgebra.IsSolvable (Subtype fun x => Membership.mem Bot.bot x)","decl":"instance isSolvableBot : IsSolvable (⊥ : LieIdeal R L) :=\n  ⟨⟨0, Subsingleton.elim _ ⊥⟩⟩\n\n"}
{"name":"LieAlgebra.isSolvable_iff","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ Iff (LieAlgebra.IsSolvable L) (Exists fun k => Eq (LieAlgebra.derivedSeries R L k) Bot.bot)","decl":"lemma isSolvable_iff : IsSolvable L ↔ ∃ k, derivedSeries R L k = ⊥ := by\n  simp [isSolvable_iff_int, SetLike.ext'_iff, LieIdeal.coe_derivedSeries_eq_int]\n\n"}
{"name":"LieAlgebra.IsSolvable.solvable","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\ninst✝ : LieAlgebra.IsSolvable L\n⊢ Exists fun k => Eq (LieAlgebra.derivedSeries R L k) Bot.bot","decl":"lemma IsSolvable.solvable [IsSolvable L] : ∃ k, derivedSeries R L k = ⊥ :=\n  (isSolvable_iff R L).mp ‹_›\n\n"}
{"name":"LieAlgebra.IsSolvable.mk","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nk : Nat\nh : Eq (LieAlgebra.derivedSeries R L k) Bot.bot\n⊢ LieAlgebra.IsSolvable L","decl":"variable {R L} in\nlemma IsSolvable.mk {k : ℕ} (h : derivedSeries R L k = ⊥) : IsSolvable L :=\n  (isSolvable_iff R L).mpr ⟨k, h⟩\n\n"}
{"name":"LieAlgebra.isSolvableAdd","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\nI J : LieIdeal R L\ninst✝¹ : LieAlgebra.IsSolvable (Subtype fun x => Membership.mem I x)\ninst✝ : LieAlgebra.IsSolvable (Subtype fun x => Membership.mem J x)\n⊢ LieAlgebra.IsSolvable (Subtype fun x => Membership.mem (HAdd.hAdd I J) x)","decl":"instance isSolvableAdd {I J : LieIdeal R L} [IsSolvable I] [IsSolvable J] :\n    IsSolvable (I + J) := by\n  obtain ⟨k, hk⟩ := IsSolvable.solvable R I\n  obtain ⟨l, hl⟩ := IsSolvable.solvable R J\n  exact IsSolvable.mk (LieIdeal.derivedSeries_add_eq_bot hk hl)\n\n"}
{"name":"LieAlgebra.derivedSeries_lt_top_of_solvable","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : LieAlgebra.IsSolvable L\ninst✝ : Nontrivial L\n⊢ LT.lt (LieAlgebra.derivedSeries R L 1) Top.top","decl":"theorem derivedSeries_lt_top_of_solvable [IsSolvable L] [Nontrivial L] :\n    derivedSeries R L 1 < ⊤ := by\n  obtain ⟨n, hn⟩ := IsSolvable.solvable (R := R) (L := L)\n  rw [lt_top_iff_ne_top]\n  intro contra\n  rw [LieIdeal.derivedSeries_eq_top n contra] at hn\n  exact top_ne_bot hn\n\n"}
{"name":"LieAlgebra.instIsSolvableTensorProduct","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : LieAlgebra R L\nA : Type u_1\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\ninst✝ : LieAlgebra.IsSolvable L\n⊢ LieAlgebra.IsSolvable (TensorProduct R A L)","decl":"open TensorProduct in\ninstance {A : Type*} [CommRing A] [Algebra R A] [IsSolvable L] : IsSolvable (A ⊗[R] L) := by\n  obtain ⟨k, hk⟩ := IsSolvable.solvable R L\n  rw [isSolvable_iff A]\n  use k\n  rw [derivedSeries_baseChange, hk, LieSubmodule.baseChange_bot]\n\n"}
{"name":"LieAlgebra.isSolvable_tensorProduct_iff","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : LieAlgebra R L\nA : Type u_1\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\ninst✝ : Module.FaithfullyFlat R A\n⊢ Iff (LieAlgebra.IsSolvable (TensorProduct R A L)) (LieAlgebra.IsSolvable L)","decl":"open TensorProduct in\nvariable {A : Type*} [CommRing A] [Algebra R A] [Module.FaithfullyFlat R A] in\ntheorem isSolvable_tensorProduct_iff : IsSolvable (A ⊗[R] L) ↔ IsSolvable L := by\n  refine ⟨?_, fun _ ↦ inferInstance⟩\n  rw [isSolvable_iff A, isSolvable_iff R]\n  rintro ⟨k, h⟩\n  use k\n  rw [eq_bot_iff] at h ⊢\n  intro x hx\n  rw [derivedSeries_baseChange] at h\n  specialize h <| Submodule.tmul_mem_baseChange_of_mem 1 hx\n  rw [LieSubmodule.mem_bot] at h ⊢\n  rwa [Module.FaithfullyFlat.one_tmul_eq_zero_iff] at h\n\n"}
{"name":"Function.Injective.lieAlgebra_isSolvable","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\nL' : Type w₁\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : LieRing L'\ninst✝ : LieAlgebra R L'\nf : LieHom R L' L\nhL : LieAlgebra.IsSolvable L\nh : Function.Injective ⇑f\n⊢ LieAlgebra.IsSolvable L'","decl":"theorem Injective.lieAlgebra_isSolvable [hL : IsSolvable L] (h : Injective f) :\n    IsSolvable L' := by\n  rw [isSolvable_iff R] at hL ⊢\n  apply hL.imp\n  intro k hk\n  apply LieIdeal.bot_of_map_eq_bot h; rw [eq_bot_iff, ← hk]\n  apply LieIdeal.derivedSeries_map_le\n\n"}
{"name":"Function.instIsSolvableSubtypeMemLieSubmodule","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\nA : LieIdeal R L\ninst✝ : LieAlgebra.IsSolvable L\n⊢ LieAlgebra.IsSolvable (Subtype fun x => Membership.mem A x)","decl":"instance (A : LieIdeal R L) [IsSolvable L] : IsSolvable A :=\n  A.incl_injective.lieAlgebra_isSolvable\n\n"}
{"name":"Function.Surjective.lieAlgebra_isSolvable","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\nL' : Type w₁\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : LieRing L'\ninst✝ : LieAlgebra R L'\nf : LieHom R L' L\nhL' : LieAlgebra.IsSolvable L'\nh : Function.Surjective ⇑f\n⊢ LieAlgebra.IsSolvable L","decl":"theorem Surjective.lieAlgebra_isSolvable [hL' : IsSolvable L'] (h : Surjective f) :\n    IsSolvable L := by\n  rw [isSolvable_iff R] at hL' ⊢\n  apply hL'.imp\n  intro k hk\n  rw [← LieIdeal.derivedSeries_map_eq k h, hk]\n  simp only [LieIdeal.map_eq_bot_iff, bot_le]\n\n"}
{"name":"LieHom.isSolvable_range","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\nL' : Type w₁\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : LieAlgebra R L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\nf : LieHom R L' L\ninst✝ : LieAlgebra.IsSolvable L'\n⊢ LieAlgebra.IsSolvable (Subtype fun x => Membership.mem f.range x)","decl":"instance LieHom.isSolvable_range (f : L' →ₗ⁅R⁆ L) [LieAlgebra.IsSolvable L'] :\n    LieAlgebra.IsSolvable f.range :=\n  f.surjective_rangeRestrict.lieAlgebra_isSolvable\n\n"}
{"name":"LieAlgebra.solvable_iff_equiv_solvable","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\nL' : Type w₁\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : LieRing L'\ninst✝ : LieAlgebra R L'\ne : LieEquiv R L' L\n⊢ Iff (LieAlgebra.IsSolvable L') (LieAlgebra.IsSolvable L)","decl":"theorem solvable_iff_equiv_solvable (e : L' ≃ₗ⁅R⁆ L) : IsSolvable L' ↔ IsSolvable L := by\n  constructor <;> intro h\n  · exact e.symm.injective.lieAlgebra_isSolvable\n  · exact e.injective.lieAlgebra_isSolvable\n\n"}
{"name":"LieAlgebra.le_solvable_ideal_solvable","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI J : LieIdeal R L\nh₁ : LE.le I J\nx✝ : LieAlgebra.IsSolvable (Subtype fun x => Membership.mem J x)\n⊢ LieAlgebra.IsSolvable (Subtype fun x => Membership.mem I x)","decl":"theorem le_solvable_ideal_solvable {I J : LieIdeal R L} (h₁ : I ≤ J) (_ : IsSolvable J) :\n    IsSolvable I :=\n  (LieIdeal.inclusion_injective h₁).lieAlgebra_isSolvable\n\n"}
{"name":"LieAlgebra.ofAbelianIsSolvable","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"L : Type v\ninst✝¹ : LieRing L\ninst✝ : IsLieAbelian L\n⊢ LieAlgebra.IsSolvable L","decl":"instance (priority := 100) ofAbelianIsSolvable [IsLieAbelian L] : IsSolvable L := by\n  use 1\n  rw [← abelian_iff_derived_one_eq_bot, lie_abelian_iff_equiv_lie_abelian LieIdeal.topEquiv]\n  infer_instance\n\n"}
{"name":"LieAlgebra.radicalIsSolvable","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\ninst✝ : IsNoetherian R L\n⊢ LieAlgebra.IsSolvable (Subtype fun x => Membership.mem (LieAlgebra.radical R L) x)","decl":"/-- The radical of a Noetherian Lie algebra is solvable. -/\ninstance radicalIsSolvable [IsNoetherian R L] : IsSolvable (radical R L) := by\n  have hwf := LieSubmodule.wellFoundedGT_of_noetherian R L L\n  rw [← CompleteLattice.isSupClosedCompact_iff_wellFoundedGT] at hwf\n  refine hwf { I : LieIdeal R L | IsSolvable I } ⟨⊥, ?_⟩ fun I hI J hJ => ?_\n  · exact LieAlgebra.isSolvableBot R L\n  · rw [Set.mem_setOf_eq] at hI hJ ⊢\n    apply LieAlgebra.isSolvableAdd R L\n\n"}
{"name":"LieAlgebra.LieIdeal.solvable_iff_le_radical","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\ninst✝ : IsNoetherian R L\nI : LieIdeal R L\n⊢ Iff (LieAlgebra.IsSolvable (Subtype fun x => Membership.mem I x)) (LE.le I (LieAlgebra.radical R L))","decl":"/-- The `→` direction of this lemma is actually true without the `IsNoetherian` assumption. -/\ntheorem LieIdeal.solvable_iff_le_radical [IsNoetherian R L] (I : LieIdeal R L) :\n    IsSolvable I ↔ I ≤ radical R L :=\n  ⟨fun h => le_sSup h, fun h => le_solvable_ideal_solvable h inferInstance⟩\n\n"}
{"name":"LieAlgebra.center_le_radical","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ LE.le (LieAlgebra.center R L) (LieAlgebra.radical R L)","decl":"theorem center_le_radical : center R L ≤ radical R L :=\n  have h : IsSolvable (center R L) := inferInstance\n  le_sSup h\n\n"}
{"name":"LieAlgebra.instIsSolvableSubtypeMemLieSubalgebraTop","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\ninst✝ : LieAlgebra.IsSolvable L\n⊢ LieAlgebra.IsSolvable (Subtype fun x => Membership.mem Top.top x)","decl":"instance [IsSolvable L] : IsSolvable (⊤ : LieSubalgebra R L) := by\n  rwa [solvable_iff_equiv_solvable LieSubalgebra.topEquiv]\n\n"}
{"name":"LieAlgebra.radical_eq_top_of_isSolvable","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\ninst✝ : LieAlgebra.IsSolvable L\n⊢ Eq (LieAlgebra.radical R L) Top.top","decl":"@[simp] lemma radical_eq_top_of_isSolvable [IsSolvable L] :\n    radical R L = ⊤ := by\n  rw [eq_top_iff]\n  have h : IsSolvable (⊤ : LieSubalgebra R L) := inferInstance\n  exact le_sSup h\n\n"}
{"name":"LieAlgebra.derivedSeries_of_derivedLength_succ","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\nk : Nat\n⊢ Iff (Eq (LieAlgebra.derivedLengthOfIdeal R L I) (HAdd.hAdd k 1)) (And (IsLieAbelian (Subtype fun x => Membership.mem (LieAlgebra.derivedSeriesOfIdeal R L k I) x)) (Ne (LieAlgebra.derivedSeriesOfIdeal R L k I) Bot.bot))","decl":"theorem derivedSeries_of_derivedLength_succ (I : LieIdeal R L) (k : ℕ) :\n    derivedLengthOfIdeal R L I = k + 1 ↔\n      IsLieAbelian (derivedSeriesOfIdeal R L k I) ∧ derivedSeriesOfIdeal R L k I ≠ ⊥ := by\n  rw [abelian_iff_derived_succ_eq_bot]\n  let s := { k | derivedSeriesOfIdeal R L k I = ⊥ }\n  change sInf s = k + 1 ↔ k + 1 ∈ s ∧ k ∉ s\n  have hs : ∀ k₁ k₂ : ℕ, k₁ ≤ k₂ → k₁ ∈ s → k₂ ∈ s := by\n    intro k₁ k₂ h₁₂ h₁\n    suffices derivedSeriesOfIdeal R L k₂ I ≤ ⊥ by exact eq_bot_iff.mpr this\n    change derivedSeriesOfIdeal R L k₁ I = ⊥ at h₁; rw [← h₁]\n    exact derivedSeriesOfIdeal_antitone I h₁₂\n  exact Nat.sInf_upward_closed_eq_succ_iff hs k\n\n"}
{"name":"LieAlgebra.derivedLength_eq_derivedLengthOfIdeal","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\n⊢ Eq (LieAlgebra.derivedLength R (Subtype fun x => Membership.mem I x)) (LieAlgebra.derivedLengthOfIdeal R L I)","decl":"theorem derivedLength_eq_derivedLengthOfIdeal (I : LieIdeal R L) :\n    derivedLength R I = derivedLengthOfIdeal R L I := by\n  let s₁ := { k | derivedSeries R I k = ⊥ }\n  let s₂ := { k | derivedSeriesOfIdeal R L k I = ⊥ }\n  change sInf s₁ = sInf s₂\n  congr; ext k; exact I.derivedSeries_eq_bot_iff k\n\n"}
{"name":"LieAlgebra.abelian_derivedAbelianOfIdeal","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\n⊢ IsLieAbelian (Subtype fun x => Membership.mem (LieAlgebra.derivedAbelianOfIdeal I) x)","decl":"theorem abelian_derivedAbelianOfIdeal (I : LieIdeal R L) :\n    IsLieAbelian (derivedAbelianOfIdeal I) := by\n  dsimp only [derivedAbelianOfIdeal]\n  cases' h : derivedLengthOfIdeal R L I with k\n  · dsimp; infer_instance\n  · rw [derivedSeries_of_derivedLength_succ] at h; exact h.1\n\n"}
{"name":"LieAlgebra.derivedLength_zero","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\nI : LieIdeal R L\ninst✝ : LieAlgebra.IsSolvable (Subtype fun x => Membership.mem I x)\n⊢ Iff (Eq (LieAlgebra.derivedLengthOfIdeal R L I) 0) (Eq I Bot.bot)","decl":"theorem derivedLength_zero (I : LieIdeal R L) [IsSolvable I] :\n    derivedLengthOfIdeal R L I = 0 ↔ I = ⊥ := by\n  let s := { k | derivedSeriesOfIdeal R L k I = ⊥ }\n  change sInf s = 0 ↔ _\n  have hne : s ≠ ∅ := by\n    obtain ⟨k, hk⟩ := IsSolvable.solvable R I\n    refine Set.Nonempty.ne_empty ⟨k, ?_⟩\n    rw [derivedSeries_def, LieIdeal.derivedSeries_eq_bot_iff] at hk; exact hk\n  simp [s, hne]\n\n"}
{"name":"LieAlgebra.abelian_of_solvable_ideal_eq_bot_iff","module":"Mathlib.Algebra.Lie.Solvable","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\nh : LieAlgebra.IsSolvable (Subtype fun x => Membership.mem I x)\n⊢ Iff (Eq (LieAlgebra.derivedAbelianOfIdeal I) Bot.bot) (Eq I Bot.bot)","decl":"theorem abelian_of_solvable_ideal_eq_bot_iff (I : LieIdeal R L) [h : IsSolvable I] :\n    derivedAbelianOfIdeal I = ⊥ ↔ I = ⊥ := by\n  dsimp only [derivedAbelianOfIdeal]\n  split -- Porting note: Original tactic was `cases' h : derivedAbelianOfIdeal R L I with k`\n  · rename_i h\n    rw [derivedLength_zero] at h\n    rw [h]\n  · rename_i k h\n    obtain ⟨_, h₂⟩ := (derivedSeries_of_derivedLength_succ R L I k).mp h\n    have h₃ : I ≠ ⊥ := by intro contra; apply h₂; rw [contra]; apply derivedSeries_of_bot_eq_bot\n    simp only [h₂, h₃]\n\n"}
