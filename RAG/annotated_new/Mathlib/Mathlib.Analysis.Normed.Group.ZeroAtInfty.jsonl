{"name":"ZeroAtInftyContinuousMapClass.norm_le","module":"Mathlib.Analysis.Normed.Group.ZeroAtInfty","initialProofState":"E : Type u_1\nF : Type u_2\nğ“• : Type u_3\ninstâœÂ³ : SeminormedAddGroup E\ninstâœÂ² : SeminormedAddCommGroup F\ninstâœÂ¹ : FunLike ğ“• E F\ninstâœ : ZeroAtInftyContinuousMapClass ğ“• E F\nf : ğ“•\nÎµ : Real\nhÎµ : LT.lt 0 Îµ\nâŠ¢ Exists fun r => âˆ€ (x : E), LT.lt r (Norm.norm x) â†’ LT.lt (Norm.norm (f x)) Îµ","decl":"theorem ZeroAtInftyContinuousMapClass.norm_le (f : ğ“•) (Îµ : â„) (hÎµ : 0 < Îµ) :\n    âˆƒ (r : â„), âˆ€ (x : E) (_hx : r < â€–xâ€–), â€–f xâ€– < Îµ := by\n  have h := zero_at_infty f\n  rw [tendsto_zero_iff_norm_tendsto_zero, tendsto_def] at h\n  specialize h (Metric.ball 0 Îµ) (Metric.ball_mem_nhds 0 hÎµ)\n  rcases Metric.closedBall_compl_subset_of_mem_cocompact h 0 with âŸ¨r, hrâŸ©\n  use r\n  intro x hr'\n  suffices x âˆˆ (fun x â†¦ â€–f xâ€–) â»Â¹' Metric.ball 0 Îµ by aesop\n  apply hr\n  aesop\n\n"}
{"name":"zero_at_infty_of_norm_le","module":"Mathlib.Analysis.Normed.Group.ZeroAtInfty","initialProofState":"E : Type u_1\nF : Type u_2\ninstâœÂ² : SeminormedAddGroup E\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : ProperSpace E\nf : E â†’ F\nh : âˆ€ (Îµ : Real), LT.lt 0 Îµ â†’ Exists fun r => âˆ€ (x : E), LT.lt r (Norm.norm x) â†’ LT.lt (Norm.norm (f x)) Îµ\nâŠ¢ Filter.Tendsto f (Filter.cocompact E) (nhds 0)","decl":"theorem zero_at_infty_of_norm_le (f : E â†’ F)\n    (h : âˆ€ (Îµ : â„) (_hÎµ : 0 < Îµ), âˆƒ (r : â„), âˆ€ (x : E) (_hx : r < â€–xâ€–), â€–f xâ€– < Îµ) :\n    Tendsto f (cocompact E) (ğ“ 0) := by\n  rw [tendsto_zero_iff_norm_tendsto_zero]\n  intro s hs\n  rw [mem_map, Metric.mem_cocompact_iff_closedBall_compl_subset 0]\n  rw [Metric.mem_nhds_iff] at hs\n  rcases hs with âŸ¨Îµ, hÎµ, hsâŸ©\n  rcases h Îµ hÎµ with âŸ¨r, hrâŸ©\n  use r\n  intro\n  aesop\n"}
