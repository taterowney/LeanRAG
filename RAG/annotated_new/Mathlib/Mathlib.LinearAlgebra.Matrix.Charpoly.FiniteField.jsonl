{"name":"FiniteField.Matrix.charpoly_pow_card","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.FiniteField","initialProofState":"n : Type u_1\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\nK : Type u_2\ninst✝¹ : Field K\ninst✝ : Fintype K\nM : Matrix n n K\n⊢ Eq (HPow.hPow M (Fintype.card K)).charpoly M.charpoly","decl":"@[simp]\ntheorem FiniteField.Matrix.charpoly_pow_card {K : Type*} [Field K] [Fintype K] (M : Matrix n n K) :\n    (M ^ Fintype.card K).charpoly = M.charpoly := by\n  cases (isEmpty_or_nonempty n).symm\n  · cases' CharP.exists K with p hp; letI := hp\n    rcases FiniteField.card K p with ⟨⟨k, kpos⟩, ⟨hp, hk⟩⟩\n    haveI : Fact p.Prime := ⟨hp⟩\n    dsimp at hk; rw [hk]\n    apply (frobenius_inj K[X] p).iterate k\n    repeat' rw [iterate_frobenius (R := K[X])]; rw [← hk]\n    rw [← FiniteField.expand_card]\n    unfold charpoly\n    rw [AlgHom.map_det, ← coe_detMonoidHom, ← (detMonoidHom : Matrix n n K[X] →* K[X]).map_pow]\n    apply congr_arg det\n    refine matPolyEquiv.injective ?_\n    rw [map_pow, matPolyEquiv_charmatrix, hk, sub_pow_char_pow_of_commute, ← C_pow]\n    · exact (id (matPolyEquiv_eq_X_pow_sub_C (p ^ k) M) :)\n    · exact (C M).commute_X\n  · exact congr_arg _ (Subsingleton.elim _ _)\n\n"}
{"name":"ZMod.charpoly_pow_card","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.FiniteField","initialProofState":"n : Type u_1\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\np : Nat\ninst✝ : Fact (Nat.Prime p)\nM : Matrix n n (ZMod p)\n⊢ Eq (HPow.hPow M p).charpoly M.charpoly","decl":"@[simp]\ntheorem ZMod.charpoly_pow_card {p : ℕ} [Fact p.Prime] (M : Matrix n n (ZMod p)) :\n    (M ^ p).charpoly = M.charpoly := by\n  have h := FiniteField.Matrix.charpoly_pow_card M\n  rwa [ZMod.card] at h\n\n"}
{"name":"FiniteField.trace_pow_card","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.FiniteField","initialProofState":"n : Type u_1\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\nK : Type u_2\ninst✝¹ : Field K\ninst✝ : Fintype K\nM : Matrix n n K\n⊢ Eq (HPow.hPow M (Fintype.card K)).trace (HPow.hPow M.trace (Fintype.card K))","decl":"theorem FiniteField.trace_pow_card {K : Type*} [Field K] [Fintype K] (M : Matrix n n K) :\n    trace (M ^ Fintype.card K) = trace M ^ Fintype.card K := by\n  cases isEmpty_or_nonempty n\n  · simp [Matrix.trace]\n  rw [Matrix.trace_eq_neg_charpoly_coeff, Matrix.trace_eq_neg_charpoly_coeff,\n    FiniteField.Matrix.charpoly_pow_card, FiniteField.pow_card]\n\n"}
{"name":"ZMod.trace_pow_card","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.FiniteField","initialProofState":"n : Type u_1\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\np : Nat\ninst✝ : Fact (Nat.Prime p)\nM : Matrix n n (ZMod p)\n⊢ Eq (HPow.hPow M p).trace (HPow.hPow M.trace p)","decl":"theorem ZMod.trace_pow_card {p : ℕ} [Fact p.Prime] (M : Matrix n n (ZMod p)) :\n    trace (M ^ p) = trace M ^ p := by have h := FiniteField.trace_pow_card M; rwa [ZMod.card] at h\n"}
