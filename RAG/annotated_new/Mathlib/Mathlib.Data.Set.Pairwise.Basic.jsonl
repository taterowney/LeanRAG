{"name":"pairwise_on_bool","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\nhr : Symmetric r\na b : α\n⊢ Iff (Pairwise (Function.onFun r fun c => cond c a b)) (r a b)","decl":"theorem pairwise_on_bool (hr : Symmetric r) {a b : α} :\n    Pairwise (r on fun c => cond c a b) ↔ r a b := by simpa [Pairwise, Function.onFun] using @hr a b\n\n"}
{"name":"pairwise_disjoint_on_bool","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\na b : α\n⊢ Iff (Pairwise (Function.onFun Disjoint fun c => cond c a b)) (Disjoint a b)","decl":"theorem pairwise_disjoint_on_bool [PartialOrder α] [OrderBot α] {a b : α} :\n    Pairwise (Disjoint on fun c => cond c a b) ↔ Disjoint a b :=\n  pairwise_on_bool Disjoint.symm\n\n"}
{"name":"Symmetric.pairwise_on","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\nr : α → α → Prop\ninst✝ : LinearOrder ι\nhr : Symmetric r\nf : ι → α\n⊢ Iff (Pairwise (Function.onFun r f)) (∀ ⦃m n : ι⦄, LT.lt m n → r (f m) (f n))","decl":"theorem Symmetric.pairwise_on [LinearOrder ι] (hr : Symmetric r) (f : ι → α) :\n    Pairwise (r on f) ↔ ∀ ⦃m n⦄, m < n → r (f m) (f n) :=\n  ⟨fun h _m _n hmn => h hmn.ne, fun h _m _n hmn => hmn.lt_or_lt.elim (@h _ _) fun h' => hr (h h')⟩\n\n"}
{"name":"pairwise_disjoint_on","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝² : PartialOrder α\ninst✝¹ : OrderBot α\ninst✝ : LinearOrder ι\nf : ι → α\n⊢ Iff (Pairwise (Function.onFun Disjoint f)) (∀ ⦃m n : ι⦄, LT.lt m n → Disjoint (f m) (f n))","decl":"theorem pairwise_disjoint_on [PartialOrder α] [OrderBot α] [LinearOrder ι] (f : ι → α) :\n    Pairwise (Disjoint on f) ↔ ∀ ⦃m n⦄, m < n → Disjoint (f m) (f n) :=\n  Symmetric.pairwise_on Disjoint.symm f\n\n"}
{"name":"pairwise_disjoint_mono","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\nf g : ι → α\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\nhs : Pairwise (Function.onFun Disjoint f)\nh : LE.le g f\n⊢ Pairwise (Function.onFun Disjoint g)","decl":"theorem pairwise_disjoint_mono [PartialOrder α] [OrderBot α] (hs : Pairwise (Disjoint on f))\n    (h : g ≤ f) : Pairwise (Disjoint on g) :=\n  hs.mono fun i j hij => Disjoint.mono (h i) (h j) hij\n\n"}
{"name":"Pairwise.disjoint_extend_bot","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : PartialOrder γ\ninst✝ : OrderBot γ\ne : α → β\nf : α → γ\nhf : Pairwise (Function.onFun Disjoint f)\nhe : Function.FactorsThrough f e\n⊢ Pairwise (Function.onFun Disjoint (Function.extend e f Bot.bot))","decl":"theorem Pairwise.disjoint_extend_bot [PartialOrder γ] [OrderBot γ]\n    {e : α → β} {f : α → γ} (hf : Pairwise (Disjoint on f)) (he : FactorsThrough f e) :\n    Pairwise (Disjoint on extend e f ⊥) := by\n  intro b₁ b₂ hne\n  rcases em (∃ a₁, e a₁ = b₁) with ⟨a₁, rfl⟩ | hb₁\n  · rcases em (∃ a₂, e a₂ = b₂) with ⟨a₂, rfl⟩ | hb₂\n    · simpa only [onFun, he.extend_apply] using hf (ne_of_apply_ne e hne)\n    · simpa only [onFun, extend_apply' _ _ _ hb₂] using disjoint_bot_right\n  · simpa only [onFun, extend_apply' _ _ _ hb₁] using disjoint_bot_left\n\n"}
{"name":"Set.Pairwise.mono","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\ns t : Set α\nh : HasSubset.Subset t s\nhs : s.Pairwise r\n⊢ t.Pairwise r","decl":"theorem Pairwise.mono (h : t ⊆ s) (hs : s.Pairwise r) : t.Pairwise r :=\n  fun _x xt _y yt => hs (h xt) (h yt)\n\n"}
{"name":"Set.Pairwise.mono'","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nr p : α → α → Prop\ns : Set α\nH : LE.le r p\nhr : s.Pairwise r\n⊢ s.Pairwise p","decl":"theorem Pairwise.mono' (H : r ≤ p) (hr : s.Pairwise r) : s.Pairwise p :=\n  hr.imp H\n\n"}
{"name":"Set.pairwise_top","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\ns : Set α\n⊢ s.Pairwise Top.top","decl":"theorem pairwise_top (s : Set α) : s.Pairwise ⊤ :=\n  pairwise_of_forall s _ fun _ _ => trivial\n\n"}
{"name":"Set.Subsingleton.pairwise","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\ns : Set α\nh : s.Subsingleton\nr : α → α → Prop\n⊢ s.Pairwise r","decl":"protected theorem Subsingleton.pairwise (h : s.Subsingleton) (r : α → α → Prop) : s.Pairwise r :=\n  fun _x hx _y hy hne => (hne (h hx hy)).elim\n\n"}
{"name":"Set.pairwise_empty","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ EmptyCollection.emptyCollection.Pairwise r","decl":"@[simp]\ntheorem pairwise_empty (r : α → α → Prop) : (∅ : Set α).Pairwise r :=\n  subsingleton_empty.pairwise r\n\n"}
{"name":"Set.pairwise_singleton","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\na : α\nr : α → α → Prop\n⊢ (Singleton.singleton a).Pairwise r","decl":"@[simp]\ntheorem pairwise_singleton (a : α) (r : α → α → Prop) : Set.Pairwise {a} r :=\n  subsingleton_singleton.pairwise r\n\n"}
{"name":"Set.pairwise_iff_of_refl","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\ninst✝ : IsRefl α r\n⊢ Iff (s.Pairwise r) (∀ ⦃a : α⦄, Membership.mem s a → ∀ ⦃b : α⦄, Membership.mem s b → r a b)","decl":"theorem pairwise_iff_of_refl [IsRefl α r] : s.Pairwise r ↔ ∀ ⦃a⦄, a ∈ s → ∀ ⦃b⦄, b ∈ s → r a b :=\n  forall₄_congr fun _ _ _ _ => or_iff_not_imp_left.symm.trans <| or_iff_right_of_imp of_eq\n\n"}
{"name":"Set.Pairwise.of_refl","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\ninst✝ : IsRefl α r\na✝² : s.Pairwise r\na : α\na✝¹ : Membership.mem s a\nb : α\na✝ : Membership.mem s b\n⊢ r a b","decl":"alias ⟨Pairwise.of_refl, _⟩ := pairwise_iff_of_refl\n\n"}
{"name":"Set.Nonempty.pairwise_iff_exists_forall","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\nr : α → α → Prop\nf : ι → α\ninst✝ : IsEquiv α r\ns : Set ι\nhs : s.Nonempty\n⊢ Iff (s.Pairwise (Function.onFun r f)) (Exists fun z => ∀ (x : ι), Membership.mem s x → r (f x) z)","decl":"theorem Nonempty.pairwise_iff_exists_forall [IsEquiv α r] {s : Set ι} (hs : s.Nonempty) :\n    s.Pairwise (r on f) ↔ ∃ z, ∀ x ∈ s, r (f x) z := by\n  constructor\n  · rcases hs with ⟨y, hy⟩\n    refine fun H => ⟨f y, fun x hx => ?_⟩\n    rcases eq_or_ne x y with (rfl | hne)\n    · apply IsRefl.refl\n    · exact H hx hy hne\n  · rintro ⟨z, hz⟩ x hx y hy _\n    exact @IsTrans.trans α r _ (f x) z (f y) (hz _ hx) (IsSymm.symm _ _ <| hz _ hy)\n\n"}
{"name":"Set.Nonempty.pairwise_eq_iff_exists_eq","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\ns : Set α\nhs : s.Nonempty\nf : α → ι\n⊢ Iff (s.Pairwise fun x y => Eq (f x) (f y)) (Exists fun z => ∀ (x : α), Membership.mem s x → Eq (f x) z)","decl":"/-- For a nonempty set `s`, a function `f` takes pairwise equal values on `s` if and only if\nfor some `z` in the codomain, `f` takes value `z` on all `x ∈ s`. See also\n`Set.pairwise_eq_iff_exists_eq` for a version that assumes `[Nonempty ι]` instead of\n`Set.Nonempty s`. -/\ntheorem Nonempty.pairwise_eq_iff_exists_eq {s : Set α} (hs : s.Nonempty) {f : α → ι} :\n    (s.Pairwise fun x y => f x = f y) ↔ ∃ z, ∀ x ∈ s, f x = z :=\n  hs.pairwise_iff_exists_forall\n\n"}
{"name":"Set.pairwise_iff_exists_forall","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝¹ : Nonempty ι\ns : Set α\nf : α → ι\nr : ι → ι → Prop\ninst✝ : IsEquiv ι r\n⊢ Iff (s.Pairwise (Function.onFun r f)) (Exists fun z => ∀ (x : α), Membership.mem s x → r (f x) z)","decl":"theorem pairwise_iff_exists_forall [Nonempty ι] (s : Set α) (f : α → ι) {r : ι → ι → Prop}\n    [IsEquiv ι r] : s.Pairwise (r on f) ↔ ∃ z, ∀ x ∈ s, r (f x) z := by\n  rcases s.eq_empty_or_nonempty with (rfl | hne)\n  · simp\n  · exact hne.pairwise_iff_exists_forall\n\n"}
{"name":"Set.pairwise_eq_iff_exists_eq","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝ : Nonempty ι\ns : Set α\nf : α → ι\n⊢ Iff (s.Pairwise fun x y => Eq (f x) (f y)) (Exists fun z => ∀ (x : α), Membership.mem s x → Eq (f x) z)","decl":"/-- A function `f : α → ι` with nonempty codomain takes pairwise equal values on a set `s` if and\nonly if for some `z` in the codomain, `f` takes value `z` on all `x ∈ s`. See also\n`Set.Nonempty.pairwise_eq_iff_exists_eq` for a version that assumes `Set.Nonempty s` instead of\n`[Nonempty ι]`. -/\ntheorem pairwise_eq_iff_exists_eq [Nonempty ι] (s : Set α) (f : α → ι) :\n    (s.Pairwise fun x y => f x = f y) ↔ ∃ z, ∀ x ∈ s, f x = z :=\n  pairwise_iff_exists_forall s f\n\n"}
{"name":"Set.pairwise_union","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\ns t : Set α\n⊢ Iff ((Union.union s t).Pairwise r) (And (s.Pairwise r) (And (t.Pairwise r) (∀ (a : α), Membership.mem s a → ∀ (b : α), Membership.mem t b → Ne a b → And (r a b) (r b a))))","decl":"theorem pairwise_union :\n    (s ∪ t).Pairwise r ↔\n    s.Pairwise r ∧ t.Pairwise r ∧ ∀ a ∈ s, ∀ b ∈ t, a ≠ b → r a b ∧ r b a := by\n  simp only [Set.Pairwise, mem_union, or_imp, forall_and]\n  aesop\n\n"}
{"name":"Set.pairwise_union_of_symmetric","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\ns t : Set α\nhr : Symmetric r\n⊢ Iff ((Union.union s t).Pairwise r) (And (s.Pairwise r) (And (t.Pairwise r) (∀ (a : α), Membership.mem s a → ∀ (b : α), Membership.mem t b → Ne a b → r a b)))","decl":"theorem pairwise_union_of_symmetric (hr : Symmetric r) :\n    (s ∪ t).Pairwise r ↔ s.Pairwise r ∧ t.Pairwise r ∧ ∀ a ∈ s, ∀ b ∈ t, a ≠ b → r a b :=\n  pairwise_union.trans <| by simp only [hr.iff, and_self_iff]\n\n"}
{"name":"Set.pairwise_insert","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\na : α\n⊢ Iff ((Insert.insert a s).Pairwise r) (And (s.Pairwise r) (∀ (b : α), Membership.mem s b → Ne a b → And (r a b) (r b a)))","decl":"theorem pairwise_insert :\n    (insert a s).Pairwise r ↔ s.Pairwise r ∧ ∀ b ∈ s, a ≠ b → r a b ∧ r b a := by\n  simp only [insert_eq, pairwise_union, pairwise_singleton, true_and, mem_singleton_iff, forall_eq]\n\n"}
{"name":"Set.pairwise_insert_of_not_mem","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\na : α\nha : Not (Membership.mem s a)\n⊢ Iff ((Insert.insert a s).Pairwise r) (And (s.Pairwise r) (∀ (b : α), Membership.mem s b → And (r a b) (r b a)))","decl":"theorem pairwise_insert_of_not_mem (ha : a ∉ s) :\n    (insert a s).Pairwise r ↔ s.Pairwise r ∧ ∀ b ∈ s, r a b ∧ r b a :=\n  pairwise_insert.trans <|\n    and_congr_right' <| forall₂_congr fun b hb => by simp [(ne_of_mem_of_not_mem hb ha).symm]\n\n"}
{"name":"Set.Pairwise.insert","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\na : α\nhs : s.Pairwise r\nh : ∀ (b : α), Membership.mem s b → Ne a b → And (r a b) (r b a)\n⊢ (Insert.insert a s).Pairwise r","decl":"protected theorem Pairwise.insert (hs : s.Pairwise r) (h : ∀ b ∈ s, a ≠ b → r a b ∧ r b a) :\n    (insert a s).Pairwise r :=\n  pairwise_insert.2 ⟨hs, h⟩\n\n"}
{"name":"Set.Pairwise.insert_of_not_mem","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\na : α\nha : Not (Membership.mem s a)\nhs : s.Pairwise r\nh : ∀ (b : α), Membership.mem s b → And (r a b) (r b a)\n⊢ (Insert.insert a s).Pairwise r","decl":"theorem Pairwise.insert_of_not_mem (ha : a ∉ s) (hs : s.Pairwise r) (h : ∀ b ∈ s, r a b ∧ r b a) :\n    (insert a s).Pairwise r :=\n  (pairwise_insert_of_not_mem ha).2 ⟨hs, h⟩\n\n"}
{"name":"Set.pairwise_insert_of_symmetric","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\na : α\nhr : Symmetric r\n⊢ Iff ((Insert.insert a s).Pairwise r) (And (s.Pairwise r) (∀ (b : α), Membership.mem s b → Ne a b → r a b))","decl":"theorem pairwise_insert_of_symmetric (hr : Symmetric r) :\n    (insert a s).Pairwise r ↔ s.Pairwise r ∧ ∀ b ∈ s, a ≠ b → r a b := by\n  simp only [pairwise_insert, hr.iff a, and_self_iff]\n\n"}
{"name":"Set.pairwise_insert_of_symmetric_of_not_mem","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\na : α\nhr : Symmetric r\nha : Not (Membership.mem s a)\n⊢ Iff ((Insert.insert a s).Pairwise r) (And (s.Pairwise r) (∀ (b : α), Membership.mem s b → r a b))","decl":"theorem pairwise_insert_of_symmetric_of_not_mem (hr : Symmetric r) (ha : a ∉ s) :\n    (insert a s).Pairwise r ↔ s.Pairwise r ∧ ∀ b ∈ s, r a b := by\n  simp only [pairwise_insert_of_not_mem ha, hr.iff a, and_self_iff]\n\n"}
{"name":"Set.Pairwise.insert_of_symmetric","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\na : α\nhs : s.Pairwise r\nhr : Symmetric r\nh : ∀ (b : α), Membership.mem s b → Ne a b → r a b\n⊢ (Insert.insert a s).Pairwise r","decl":"theorem Pairwise.insert_of_symmetric (hs : s.Pairwise r) (hr : Symmetric r)\n    (h : ∀ b ∈ s, a ≠ b → r a b) : (insert a s).Pairwise r :=\n  (pairwise_insert_of_symmetric hr).2 ⟨hs, h⟩\n\n"}
{"name":"Set.Pairwise.insert_of_symmetric_of_not_mem","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\na : α\nhs : s.Pairwise r\nhr : Symmetric r\nha : Not (Membership.mem s a)\nh : ∀ (b : α), Membership.mem s b → r a b\n⊢ (Insert.insert a s).Pairwise r","decl":"theorem Pairwise.insert_of_symmetric_of_not_mem (hs : s.Pairwise r) (hr : Symmetric r) (ha : a ∉ s)\n    (h : ∀ b ∈ s, r a b) : (insert a s).Pairwise r :=\n  (pairwise_insert_of_symmetric_of_not_mem hr ha).2 ⟨hs, h⟩\n\n"}
{"name":"Set.pairwise_pair","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\na b : α\n⊢ Iff ((Insert.insert a (Singleton.singleton b)).Pairwise r) (Ne a b → And (r a b) (r b a))","decl":"theorem pairwise_pair : Set.Pairwise {a, b} r ↔ a ≠ b → r a b ∧ r b a := by simp [pairwise_insert]\n\n"}
{"name":"Set.pairwise_pair_of_symmetric","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\na b : α\nhr : Symmetric r\n⊢ Iff ((Insert.insert a (Singleton.singleton b)).Pairwise r) (Ne a b → r a b)","decl":"theorem pairwise_pair_of_symmetric (hr : Symmetric r) : Set.Pairwise {a, b} r ↔ a ≠ b → r a b := by\n  simp [pairwise_insert_of_symmetric hr]\n\n"}
{"name":"Set.pairwise_univ","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ Iff (Set.univ.Pairwise r) (Pairwise r)","decl":"theorem pairwise_univ : (univ : Set α).Pairwise r ↔ Pairwise r := by\n  simp only [Set.Pairwise, Pairwise, mem_univ, forall_const]\n\n"}
{"name":"Set.pairwise_bot_iff","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\ns : Set α\n⊢ Iff (s.Pairwise Bot.bot) s.Subsingleton","decl":"@[simp]\ntheorem pairwise_bot_iff : s.Pairwise (⊥ : α → α → Prop) ↔ (s : Set α).Subsingleton :=\n  ⟨fun h _a ha _b hb => h.eq ha hb id, fun h => h.pairwise _⟩\n\n"}
{"name":"Set.Pairwise.subsingleton","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\ns : Set α\na✝ : s.Pairwise Bot.bot\n⊢ s.Subsingleton","decl":"alias ⟨Pairwise.subsingleton, _⟩ := pairwise_bot_iff\n\n"}
{"name":"Set.injOn_iff_pairwise_ne","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\nf : ι → α\ns : Set ι\n⊢ Iff (Set.InjOn f s) (s.Pairwise fun x1 x2 => Ne (f x1) (f x2))","decl":"/-- See also `Function.injective_iff_pairwise_ne` -/\nlemma injOn_iff_pairwise_ne {s : Set ι} : InjOn f s ↔ s.Pairwise (f · ≠ f ·) := by\n  simp only [InjOn, Set.Pairwise, not_imp_not]\n\n"}
{"name":"Set.InjOn.pairwise_ne","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\nf : ι → α\ns : Set ι\na✝ : Set.InjOn f s\n⊢ s.Pairwise fun x1 x2 => Ne (f x1) (f x2)","decl":"alias ⟨InjOn.pairwise_ne, _⟩ := injOn_iff_pairwise_ne\n\n"}
{"name":"Set.Pairwise.image","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\nr : α → α → Prop\nf : ι → α\ns : Set ι\nh : s.Pairwise (Function.onFun r f)\n⊢ (Set.image f s).Pairwise r","decl":"protected theorem Pairwise.image {s : Set ι} (h : s.Pairwise (r on f)) : (f '' s).Pairwise r :=\n  forall_mem_image.2 fun _x hx ↦ forall_mem_image.2 fun _y hy hne ↦ h hx hy <| ne_of_apply_ne _ hne\n\n"}
{"name":"Set.InjOn.pairwise_image","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\nr : α → α → Prop\nf : ι → α\ns : Set ι\nh : Set.InjOn f s\n⊢ Iff ((Set.image f s).Pairwise r) (s.Pairwise (Function.onFun r f))","decl":"/-- See also `Set.Pairwise.image`. -/\ntheorem InjOn.pairwise_image {s : Set ι} (h : s.InjOn f) :\n    (f '' s).Pairwise r ↔ s.Pairwise (r on f) := by\n  simp +contextual [h.eq_iff, Set.Pairwise]\n\n"}
{"name":"Pairwise.range_pairwise","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\nr : α → α → Prop\nf : ι → α\nhr : Pairwise (Function.onFun r f)\n⊢ (Set.range f).Pairwise r","decl":"lemma _root_.Pairwise.range_pairwise (hr : Pairwise (r on f)) : (Set.range f).Pairwise r :=\n  image_univ ▸ (pairwise_univ.mpr hr).image\n\n"}
{"name":"pairwise_subtype_iff_pairwise_set","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\ns : Set α\nr : α → α → Prop\n⊢ Iff (Pairwise fun x y => r ↑x ↑y) (s.Pairwise r)","decl":"theorem pairwise_subtype_iff_pairwise_set (s : Set α) (r : α → α → Prop) :\n    (Pairwise fun (x : s) (y : s) => r x y) ↔ s.Pairwise r := by\n  simp only [Pairwise, Set.Pairwise, SetCoe.forall, Ne, Subtype.ext_iff, Subtype.coe_mk]\n\n"}
{"name":"Set.Pairwise.subtype","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\ns : Set α\nr : α → α → Prop\na✝ : s.Pairwise r\n⊢ Pairwise fun x y => r ↑x ↑y","decl":"alias ⟨Pairwise.set_of_subtype, Set.Pairwise.subtype⟩ := pairwise_subtype_iff_pairwise_set\n\n"}
{"name":"Pairwise.set_of_subtype","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\ns : Set α\nr : α → α → Prop\na✝ : Pairwise fun x y => r ↑x ↑y\n⊢ s.Pairwise r","decl":"alias ⟨Pairwise.set_of_subtype, Set.Pairwise.subtype⟩ := pairwise_subtype_iff_pairwise_set\n\n"}
{"name":"Set.PairwiseDisjoint.subset","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\ns t : Set ι\nf : ι → α\nht : t.PairwiseDisjoint f\nh : HasSubset.Subset s t\n⊢ s.PairwiseDisjoint f","decl":"theorem PairwiseDisjoint.subset (ht : t.PairwiseDisjoint f) (h : s ⊆ t) : s.PairwiseDisjoint f :=\n  Pairwise.mono h ht\n\n"}
{"name":"Set.PairwiseDisjoint.mono_on","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\ns : Set ι\nf g : ι → α\nhs : s.PairwiseDisjoint f\nh : ∀ ⦃i : ι⦄, Membership.mem s i → LE.le (g i) (f i)\n⊢ s.PairwiseDisjoint g","decl":"theorem PairwiseDisjoint.mono_on (hs : s.PairwiseDisjoint f) (h : ∀ ⦃i⦄, i ∈ s → g i ≤ f i) :\n    s.PairwiseDisjoint g := fun _a ha _b hb hab => (hs ha hb hab).mono (h ha) (h hb)\n\n"}
{"name":"Set.PairwiseDisjoint.mono","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\ns : Set ι\nf g : ι → α\nhs : s.PairwiseDisjoint f\nh : LE.le g f\n⊢ s.PairwiseDisjoint g","decl":"theorem PairwiseDisjoint.mono (hs : s.PairwiseDisjoint f) (h : g ≤ f) : s.PairwiseDisjoint g :=\n  hs.mono_on fun i _ => h i\n\n"}
{"name":"Set.pairwiseDisjoint_empty","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\nf : ι → α\n⊢ EmptyCollection.emptyCollection.PairwiseDisjoint f","decl":"@[simp]\ntheorem pairwiseDisjoint_empty : (∅ : Set ι).PairwiseDisjoint f :=\n  pairwise_empty _\n\n"}
{"name":"Set.pairwiseDisjoint_singleton","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\ni : ι\nf : ι → α\n⊢ (Singleton.singleton i).PairwiseDisjoint f","decl":"@[simp]\ntheorem pairwiseDisjoint_singleton (i : ι) (f : ι → α) : PairwiseDisjoint {i} f :=\n  pairwise_singleton i _\n\n"}
{"name":"Set.pairwiseDisjoint_insert","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\ns : Set ι\nf : ι → α\ni : ι\n⊢ Iff ((Insert.insert i s).PairwiseDisjoint f) (And (s.PairwiseDisjoint f) (∀ (j : ι), Membership.mem s j → Ne i j → Disjoint (f i) (f j)))","decl":"theorem pairwiseDisjoint_insert {i : ι} :\n    (insert i s).PairwiseDisjoint f ↔\n      s.PairwiseDisjoint f ∧ ∀ j ∈ s, i ≠ j → Disjoint (f i) (f j) :=\n  pairwise_insert_of_symmetric <| symmetric_disjoint.comap f\n\n"}
{"name":"Set.pairwiseDisjoint_insert_of_not_mem","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\ns : Set ι\nf : ι → α\ni : ι\nhi : Not (Membership.mem s i)\n⊢ Iff ((Insert.insert i s).PairwiseDisjoint f) (And (s.PairwiseDisjoint f) (∀ (j : ι), Membership.mem s j → Disjoint (f i) (f j)))","decl":"theorem pairwiseDisjoint_insert_of_not_mem {i : ι} (hi : i ∉ s) :\n    (insert i s).PairwiseDisjoint f ↔ s.PairwiseDisjoint f ∧ ∀ j ∈ s, Disjoint (f i) (f j) :=\n  pairwise_insert_of_symmetric_of_not_mem (symmetric_disjoint.comap f) hi\n\n"}
{"name":"Set.PairwiseDisjoint.insert","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\ns : Set ι\nf : ι → α\nhs : s.PairwiseDisjoint f\ni : ι\nh : ∀ (j : ι), Membership.mem s j → Ne i j → Disjoint (f i) (f j)\n⊢ (Insert.insert i s).PairwiseDisjoint f","decl":"protected theorem PairwiseDisjoint.insert (hs : s.PairwiseDisjoint f) {i : ι}\n    (h : ∀ j ∈ s, i ≠ j → Disjoint (f i) (f j)) : (insert i s).PairwiseDisjoint f :=\n  pairwiseDisjoint_insert.2 ⟨hs, h⟩\n\n"}
{"name":"Set.PairwiseDisjoint.insert_of_not_mem","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\ns : Set ι\nf : ι → α\nhs : s.PairwiseDisjoint f\ni : ι\nhi : Not (Membership.mem s i)\nh : ∀ (j : ι), Membership.mem s j → Disjoint (f i) (f j)\n⊢ (Insert.insert i s).PairwiseDisjoint f","decl":"theorem PairwiseDisjoint.insert_of_not_mem (hs : s.PairwiseDisjoint f) {i : ι} (hi : i ∉ s)\n    (h : ∀ j ∈ s, Disjoint (f i) (f j)) : (insert i s).PairwiseDisjoint f :=\n  (pairwiseDisjoint_insert_of_not_mem hi).2 ⟨hs, h⟩\n\n"}
{"name":"Set.PairwiseDisjoint.image_of_le","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\ns : Set ι\nf : ι → α\nhs : s.PairwiseDisjoint f\ng : ι → ι\nhg : LE.le (Function.comp f g) f\n⊢ (Set.image g s).PairwiseDisjoint f","decl":"theorem PairwiseDisjoint.image_of_le (hs : s.PairwiseDisjoint f) {g : ι → ι} (hg : f ∘ g ≤ f) :\n    (g '' s).PairwiseDisjoint f := by\n  rintro _ ⟨a, ha, rfl⟩ _ ⟨b, hb, rfl⟩ h\n  exact (hs ha hb <| ne_of_apply_ne _ h).mono (hg a) (hg b)\n\n"}
{"name":"Set.InjOn.pairwiseDisjoint_image","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\nι' : Type u_5\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\nf : ι → α\ng : ι' → ι\ns : Set ι'\nh : Set.InjOn g s\n⊢ Iff ((Set.image g s).PairwiseDisjoint f) (s.PairwiseDisjoint (Function.comp f g))","decl":"theorem InjOn.pairwiseDisjoint_image {g : ι' → ι} {s : Set ι'} (h : s.InjOn g) :\n    (g '' s).PairwiseDisjoint f ↔ s.PairwiseDisjoint (f ∘ g) :=\n  h.pairwise_image\n\n"}
{"name":"Set.PairwiseDisjoint.range","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\ns : Set ι\nf : ι → α\ng : ↑s → ι\nhg : ∀ (i : ↑s), LE.le (f (g i)) (f ↑i)\nht : s.PairwiseDisjoint f\n⊢ (Set.range g).PairwiseDisjoint f","decl":"theorem PairwiseDisjoint.range (g : s → ι) (hg : ∀ i : s, f (g i) ≤ f i)\n    (ht : s.PairwiseDisjoint f) : (range g).PairwiseDisjoint f := by\n  rintro _ ⟨x, rfl⟩ _ ⟨y, rfl⟩ hxy\n  exact ((ht x.2 y.2) fun h => hxy <| congr_arg g <| Subtype.ext h).mono (hg x) (hg y)\n\n"}
{"name":"Set.pairwiseDisjoint_union","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\ns t : Set ι\nf : ι → α\n⊢ Iff ((Union.union s t).PairwiseDisjoint f) (And (s.PairwiseDisjoint f) (And (t.PairwiseDisjoint f) (∀ ⦃i : ι⦄, Membership.mem s i → ∀ ⦃j : ι⦄, Membership.mem t j → Ne i j → Disjoint (f i) (f j))))","decl":"theorem pairwiseDisjoint_union :\n    (s ∪ t).PairwiseDisjoint f ↔\n      s.PairwiseDisjoint f ∧\n        t.PairwiseDisjoint f ∧ ∀ ⦃i⦄, i ∈ s → ∀ ⦃j⦄, j ∈ t → i ≠ j → Disjoint (f i) (f j) :=\n  pairwise_union_of_symmetric <| symmetric_disjoint.comap f\n\n"}
{"name":"Set.PairwiseDisjoint.union","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\ns t : Set ι\nf : ι → α\nhs : s.PairwiseDisjoint f\nht : t.PairwiseDisjoint f\nh : ∀ ⦃i : ι⦄, Membership.mem s i → ∀ ⦃j : ι⦄, Membership.mem t j → Ne i j → Disjoint (f i) (f j)\n⊢ (Union.union s t).PairwiseDisjoint f","decl":"theorem PairwiseDisjoint.union (hs : s.PairwiseDisjoint f) (ht : t.PairwiseDisjoint f)\n    (h : ∀ ⦃i⦄, i ∈ s → ∀ ⦃j⦄, j ∈ t → i ≠ j → Disjoint (f i) (f j)) : (s ∪ t).PairwiseDisjoint f :=\n  pairwiseDisjoint_union.2 ⟨hs, ht, h⟩\n\n-- classical\n"}
{"name":"Set.PairwiseDisjoint.elim","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\ns : Set ι\nf : ι → α\nhs : s.PairwiseDisjoint f\ni j : ι\nhi : Membership.mem s i\nhj : Membership.mem s j\nh : Not (Disjoint (f i) (f j))\n⊢ Eq i j","decl":"theorem PairwiseDisjoint.elim (hs : s.PairwiseDisjoint f) {i j : ι} (hi : i ∈ s) (hj : j ∈ s)\n    (h : ¬Disjoint (f i) (f j)) : i = j :=\n  hs.eq hi hj h\n\n"}
{"name":"Set.PairwiseDisjoint.eq_or_disjoint","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\ns : Set ι\nf : ι → α\nh : s.PairwiseDisjoint f\ni j : ι\nhi : Membership.mem s i\nhj : Membership.mem s j\n⊢ Or (Eq i j) (Disjoint (f i) (f j))","decl":"lemma PairwiseDisjoint.eq_or_disjoint\n    (h : s.PairwiseDisjoint f) {i j : ι} (hi : i ∈ s) (hj : j ∈ s) :\n    i = j ∨ Disjoint (f i) (f j) := by\n  rw [or_iff_not_imp_right]\n  exact h.elim hi hj\n\n"}
{"name":"Set.pairwiseDisjoint_range_iff","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\nf : α → Set β\n⊢ Iff ((Set.range f).PairwiseDisjoint id) (∀ (x y : α), Ne (f x) (f y) → Disjoint (f x) (f y))","decl":"lemma pairwiseDisjoint_range_iff {α β : Type*} {f : α → (Set β)} :\n    (range f).PairwiseDisjoint id ↔ ∀ x y, f x ≠ f y → Disjoint (f x) (f y) := by\n  aesop (add simp [PairwiseDisjoint, Set.Pairwise])\n\n"}
{"name":"Pairwise.pairwiseDisjoint","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\nf : ι → α\nh : Pairwise (Function.onFun Disjoint f)\ns : Set ι\n⊢ s.PairwiseDisjoint f","decl":"/-- If the range of `f` is pairwise disjoint, then the image of any set `s` under `f` is as well. -/\nlemma _root_.Pairwise.pairwiseDisjoint (h : Pairwise (Disjoint on f)) (s : Set ι) :\n    s.PairwiseDisjoint f := h.set_pairwise s\n\n"}
{"name":"Set.PairwiseDisjoint.elim'","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderBot α\ns : Set ι\nf : ι → α\nhs : s.PairwiseDisjoint f\ni j : ι\nhi : Membership.mem s i\nhj : Membership.mem s j\nh : Ne (Min.min (f i) (f j)) Bot.bot\n⊢ Eq i j","decl":"theorem PairwiseDisjoint.elim' (hs : s.PairwiseDisjoint f) {i j : ι} (hi : i ∈ s) (hj : j ∈ s)\n    (h : f i ⊓ f j ≠ ⊥) : i = j :=\n  (hs.elim hi hj) fun hij => h hij.eq_bot\n\n"}
{"name":"Set.PairwiseDisjoint.eq_of_le","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderBot α\ns : Set ι\nf : ι → α\nhs : s.PairwiseDisjoint f\ni j : ι\nhi : Membership.mem s i\nhj : Membership.mem s j\nhf : Ne (f i) Bot.bot\nhij : LE.le (f i) (f j)\n⊢ Eq i j","decl":"theorem PairwiseDisjoint.eq_of_le (hs : s.PairwiseDisjoint f) {i j : ι} (hi : i ∈ s) (hj : j ∈ s)\n    (hf : f i ≠ ⊥) (hij : f i ≤ f j) : i = j :=\n  (hs.elim' hi hj) fun h => hf <| (inf_of_le_left hij).symm.trans h\n\n"}
{"name":"Set.pairwiseDisjoint_range_singleton","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"ι : Type u_4\n⊢ (Set.range Singleton.singleton).PairwiseDisjoint id","decl":"theorem pairwiseDisjoint_range_singleton :\n    (range (singleton : ι → Set ι)).PairwiseDisjoint id :=\n  Pairwise.range_pairwise fun _ _ => disjoint_singleton.2\n\n"}
{"name":"Set.pairwiseDisjoint_fiber","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\nf : ι → α\ns : Set α\n⊢ s.PairwiseDisjoint fun a => Set.preimage f (Singleton.singleton a)","decl":"theorem pairwiseDisjoint_fiber (f : ι → α) (s : Set α) : s.PairwiseDisjoint fun a => f ⁻¹' {a} :=\n  fun _a _ _b _ h => disjoint_iff_inf_le.mpr fun _i ⟨hia, hib⟩ => h <| (Eq.symm hia).trans hib\n\n-- classical\n"}
{"name":"Set.PairwiseDisjoint.elim_set","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\ns : Set ι\nf : ι → Set α\nhs : s.PairwiseDisjoint f\ni j : ι\nhi : Membership.mem s i\nhj : Membership.mem s j\na : α\nhai : Membership.mem (f i) a\nhaj : Membership.mem (f j) a\n⊢ Eq i j","decl":"theorem PairwiseDisjoint.elim_set {s : Set ι} {f : ι → Set α} (hs : s.PairwiseDisjoint f) {i j : ι}\n    (hi : i ∈ s) (hj : j ∈ s) (a : α) (hai : a ∈ f i) (haj : a ∈ f j) : i = j :=\n  hs.elim hi hj <| not_disjoint_iff.2 ⟨a, hai, haj⟩\n\n"}
{"name":"Set.PairwiseDisjoint.prod","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_4\nι' : Type u_5\ns : Set ι\nt : Set ι'\nf : ι → Set α\ng : ι' → Set β\nhs : s.PairwiseDisjoint f\nht : t.PairwiseDisjoint g\n⊢ (SProd.sprod s t).PairwiseDisjoint fun i => SProd.sprod (f i.1) (g i.2)","decl":"theorem PairwiseDisjoint.prod {f : ι → Set α} {g : ι' → Set β} (hs : s.PairwiseDisjoint f)\n    (ht : t.PairwiseDisjoint g) :\n    (s ×ˢ t : Set (ι × ι')).PairwiseDisjoint fun i => f i.1 ×ˢ g i.2 :=\n  fun ⟨_, _⟩ ⟨hi, hi'⟩ ⟨_, _⟩ ⟨hj, hj'⟩ hij =>\n  disjoint_left.2 fun ⟨_, _⟩ ⟨hai, hbi⟩ ⟨haj, hbj⟩ =>\n    hij <| Prod.ext (hs.elim_set hi hj _ hai haj) <| ht.elim_set hi' hj' _ hbi hbj\n\n"}
{"name":"Set.pairwiseDisjoint_pi","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"ι : Type u_4\nι' : ι → Type u_6\nα : ι → Type u_7\ns : (i : ι) → Set (ι' i)\nf : (i : ι) → ι' i → Set (α i)\nhs : ∀ (i : ι), (s i).PairwiseDisjoint (f i)\n⊢ (Set.univ.pi s).PairwiseDisjoint fun I => Set.univ.pi fun i => f i (I i)","decl":"theorem pairwiseDisjoint_pi {ι' α : ι → Type*} {s : ∀ i, Set (ι' i)} {f : ∀ i, ι' i → Set (α i)}\n    (hs : ∀ i, (s i).PairwiseDisjoint (f i)) :\n    ((univ : Set ι).pi s).PairwiseDisjoint fun I => (univ : Set ι).pi fun i => f _ (I i) :=\n  fun _ hI _ hJ hIJ =>\n  disjoint_left.2 fun a haI haJ =>\n    hIJ <|\n      funext fun i =>\n        (hs i).elim_set (hI i trivial) (hJ i trivial) (a i) (haI i trivial) (haJ i trivial)\n\n"}
{"name":"Set.pairwiseDisjoint_image_right_iff","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\ns : Set α\nt : Set β\nhf : ∀ (a : α), Membership.mem s a → Function.Injective (f a)\n⊢ Iff (s.PairwiseDisjoint fun a => Set.image (f a) t) (Set.InjOn (fun p => f p.1 p.2) (SProd.sprod s t))","decl":"/-- The partial images of a binary function `f` whose partial evaluations are injective are pairwise\ndisjoint iff `f` is injective . -/\ntheorem pairwiseDisjoint_image_right_iff {f : α → β → γ} {s : Set α} {t : Set β}\n    (hf : ∀ a ∈ s, Injective (f a)) :\n    (s.PairwiseDisjoint fun a => f a '' t) ↔ (s ×ˢ t).InjOn fun p => f p.1 p.2 := by\n  refine ⟨fun hs x hx y hy (h : f _ _ = _) => ?_, fun hs x hx y hy h => ?_⟩\n  · suffices x.1 = y.1 by exact Prod.ext this (hf _ hx.1 <| h.trans <| by rw [this])\n    refine hs.elim hx.1 hy.1 (not_disjoint_iff.2 ⟨_, mem_image_of_mem _ hx.2, ?_⟩)\n    rw [h]\n    exact mem_image_of_mem _ hy.2\n  · refine disjoint_iff_inf_le.mpr ?_\n    rintro _ ⟨⟨a, ha, hab⟩, b, hb, rfl⟩\n    exact h (congr_arg Prod.fst <| hs (mk_mem_prod hx ha) (mk_mem_prod hy hb) hab)\n\n"}
{"name":"Set.pairwiseDisjoint_image_left_iff","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\ns : Set α\nt : Set β\nhf : ∀ (b : β), Membership.mem t b → Function.Injective fun a => f a b\n⊢ Iff (t.PairwiseDisjoint fun b => Set.image (fun a => f a b) s) (Set.InjOn (fun p => f p.1 p.2) (SProd.sprod s t))","decl":"/-- The partial images of a binary function `f` whose partial evaluations are injective are pairwise\ndisjoint iff `f` is injective . -/\ntheorem pairwiseDisjoint_image_left_iff {f : α → β → γ} {s : Set α} {t : Set β}\n    (hf : ∀ b ∈ t, Injective fun a => f a b) :\n    (t.PairwiseDisjoint fun b => (fun a => f a b) '' s) ↔ (s ×ˢ t).InjOn fun p => f p.1 p.2 := by\n  refine ⟨fun ht x hx y hy (h : f _ _ = _) => ?_, fun ht x hx y hy h => ?_⟩\n  · suffices x.2 = y.2 by exact Prod.ext (hf _ hx.2 <| h.trans <| by rw [this]) this\n    refine ht.elim hx.2 hy.2 (not_disjoint_iff.2 ⟨_, mem_image_of_mem _ hx.1, ?_⟩)\n    rw [h]\n    exact mem_image_of_mem _ hy.1\n  · refine disjoint_iff_inf_le.mpr ?_\n    rintro _ ⟨⟨a, ha, hab⟩, b, hb, rfl⟩\n    exact h (congr_arg Prod.snd <| ht (mk_mem_prod ha hx) (mk_mem_prod hb hy) hab)\n\n"}
{"name":"Set.exists_ne_mem_inter_of_not_pairwiseDisjoint","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\ns : Set ι\nf : ι → Set α\nh : Not (s.PairwiseDisjoint f)\n⊢ Exists fun i => And (Membership.mem s i) (Exists fun j => And (Membership.mem s j) (And (Ne i j) (Exists fun x => Membership.mem (Inter.inter (f i) (f j)) x)))","decl":"lemma exists_ne_mem_inter_of_not_pairwiseDisjoint\n    {f : ι → Set α} (h : ¬ s.PairwiseDisjoint f) :\n    ∃ i ∈ s, ∃ j ∈ s, i ≠ j ∧ ∃ x : α, x ∈ f i ∩ f j := by\n  change ¬ ∀ i, i ∈ s → ∀ j, j ∈ s → i ≠ j → ∀ t, t ≤ f i → t ≤ f j → t ≤ ⊥ at h\n  simp only [not_forall] at h\n  obtain ⟨i, hi, j, hj, h_ne, t, hfi, hfj, ht⟩ := h\n  replace ht : t.Nonempty := by\n    rwa [le_bot_iff, bot_eq_empty, ← Ne, ← nonempty_iff_ne_empty] at ht\n  obtain ⟨x, hx⟩ := ht\n  exact ⟨i, hi, j, hj, h_ne, x, hfi hx, hfj hx⟩\n\n"}
{"name":"Set.exists_lt_mem_inter_of_not_pairwiseDisjoint","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\ns : Set ι\ninst✝ : LinearOrder ι\nf : ι → Set α\nh : Not (s.PairwiseDisjoint f)\n⊢ Exists fun i => And (Membership.mem s i) (Exists fun j => And (Membership.mem s j) (And (LT.lt i j) (Exists fun x => Membership.mem (Inter.inter (f i) (f j)) x)))","decl":"lemma exists_lt_mem_inter_of_not_pairwiseDisjoint [LinearOrder ι]\n    {f : ι → Set α} (h : ¬ s.PairwiseDisjoint f) :\n    ∃ i ∈ s, ∃ j ∈ s, i < j ∧ ∃ x, x ∈ f i ∩ f j := by\n  obtain ⟨i, hi, j, hj, hne, x, hx₁, hx₂⟩ := exists_ne_mem_inter_of_not_pairwiseDisjoint h\n  cases' lt_or_lt_iff_ne.mpr hne with h_lt h_lt\n  · exact ⟨i, hi, j, hj, h_lt, x, hx₁, hx₂⟩\n  · exact ⟨j, hj, i, hi, h_lt, x, hx₂, hx₁⟩\n\n"}
{"name":"exists_ne_mem_inter_of_not_pairwise_disjoint","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\nf : ι → Set α\nh : Not (Pairwise (Function.onFun Disjoint f))\n⊢ Exists fun i => Exists fun j => And (Ne i j) (Exists fun x => Membership.mem (Inter.inter (f i) (f j)) x)","decl":"lemma exists_ne_mem_inter_of_not_pairwise_disjoint\n    {f : ι → Set α} (h : ¬ Pairwise (Disjoint on f)) :\n    ∃ i j : ι, i ≠ j ∧ ∃ x, x ∈ f i ∩ f j := by\n  rw [← pairwise_univ] at h\n  obtain ⟨i, _hi, j, _hj, h⟩ := exists_ne_mem_inter_of_not_pairwiseDisjoint h\n  exact ⟨i, j, h⟩\n\n"}
{"name":"exists_lt_mem_inter_of_not_pairwise_disjoint","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝ : LinearOrder ι\nf : ι → Set α\nh : Not (Pairwise (Function.onFun Disjoint f))\n⊢ Exists fun i => Exists fun j => And (LT.lt i j) (Exists fun x => Membership.mem (Inter.inter (f i) (f j)) x)","decl":"lemma exists_lt_mem_inter_of_not_pairwise_disjoint [LinearOrder ι]\n    {f : ι → Set α} (h : ¬ Pairwise (Disjoint on f)) :\n    ∃ i j : ι, i < j ∧ ∃ x, x ∈ f i ∩ f j := by\n  rw [← pairwise_univ] at h\n  obtain ⟨i, _hi, j, _hj, h⟩ := exists_lt_mem_inter_of_not_pairwiseDisjoint h\n  exact ⟨i, j, h⟩\n\n"}
{"name":"pairwise_disjoint_fiber","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\nf : ι → α\n⊢ Pairwise (Function.onFun Disjoint fun a => Set.preimage f (Singleton.singleton a))","decl":"theorem pairwise_disjoint_fiber (f : ι → α) : Pairwise (Disjoint on fun a : α => f ⁻¹' {a}) :=\n  pairwise_univ.1 <| Set.pairwiseDisjoint_fiber f univ\n\n"}
{"name":"subsingleton_setOf_mem_iff_pairwise_disjoint","module":"Mathlib.Data.Set.Pairwise.Basic","initialProofState":"α : Type u_1\nι : Type u_4\nf : ι → Set α\n⊢ Iff (∀ (a : α), (setOf fun i => Membership.mem (f i) a).Subsingleton) (Pairwise (Function.onFun Disjoint f))","decl":"lemma subsingleton_setOf_mem_iff_pairwise_disjoint {f : ι → Set α} :\n    (∀ a, {i | a ∈ f i}.Subsingleton) ↔ Pairwise (Disjoint on f) :=\n  ⟨fun h _ _ hij ↦ disjoint_left.2 fun a hi hj ↦ hij (h a hi hj),\n   fun h _ _ hx _ hy ↦ by_contra fun hne ↦ disjoint_left.1 (h hne) hx hy⟩\n"}
