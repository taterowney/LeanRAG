{"name":"orthonormal_iff_ite","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : SeminormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\nι : Type u_4\ninst✝ : DecidableEq ι\nv : ι → E\n⊢ Iff (Orthonormal 𝕜 v) (∀ (i j : ι), Eq (Inner.inner (v i) (v j)) (ite (Eq i j) 1 0))","decl":"/-- `if ... then ... else` characterization of an indexed set of vectors being orthonormal.  (Inner\nproduct equals Kronecker delta.) -/\ntheorem orthonormal_iff_ite [DecidableEq ι] {v : ι → E} :\n    Orthonormal 𝕜 v ↔ ∀ i j, ⟪v i, v j⟫ = if i = j then (1 : 𝕜) else (0 : 𝕜) := by\n  constructor\n  · intro hv i j\n    split_ifs with h\n    · simp [h, inner_self_eq_norm_sq_to_K, hv.1]\n    · exact hv.2 h\n  · intro h\n    constructor\n    · intro i\n      have h' : ‖v i‖ ^ 2 = 1 ^ 2 := by simp [@norm_sq_eq_inner 𝕜, h i i]\n      have h₁ : 0 ≤ ‖v i‖ := norm_nonneg _\n      have h₂ : (0 : ℝ) ≤ 1 := zero_le_one\n      rwa [sq_eq_sq₀ h₁ h₂] at h'\n    · intro i j hij\n      simpa [hij] using h i j\n\n"}
{"name":"orthonormal_subtype_iff_ite","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : SeminormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : DecidableEq E\ns : Set E\n⊢ Iff (Orthonormal 𝕜 Subtype.val) (∀ (v : E), Membership.mem s v → ∀ (w : E), Membership.mem s w → Eq (Inner.inner v w) (ite (Eq v w) 1 0))","decl":"/-- `if ... then ... else` characterization of a set of vectors being orthonormal.  (Inner product\nequals Kronecker delta.) -/\ntheorem orthonormal_subtype_iff_ite [DecidableEq E] {s : Set E} :\n    Orthonormal 𝕜 (Subtype.val : s → E) ↔ ∀ v ∈ s, ∀ w ∈ s, ⟪v, w⟫ = if v = w then 1 else 0 := by\n  rw [orthonormal_iff_ite]\n  constructor\n  · intro h v hv w hw\n    convert h ⟨v, hv⟩ ⟨w, hw⟩ using 1\n    simp\n  · rintro h ⟨v, hv⟩ ⟨w, hw⟩\n    convert h v hv w hw using 1\n    simp\n\n"}
{"name":"Orthonormal.inner_right_finsupp","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nι : Type u_4\nv : ι → E\nhv : Orthonormal 𝕜 v\nl : Finsupp ι 𝕜\ni : ι\n⊢ Eq (Inner.inner (v i) ((Finsupp.linearCombination 𝕜 v) l)) (l i)","decl":"/-- The inner product of a linear combination of a set of orthonormal vectors with one of those\nvectors picks out the coefficient of that vector. -/\ntheorem Orthonormal.inner_right_finsupp {v : ι → E} (hv : Orthonormal 𝕜 v) (l : ι →₀ 𝕜) (i : ι) :\n    ⟪v i, linearCombination 𝕜 v l⟫ = l i := by\n  classical\n  simpa [linearCombination_apply, Finsupp.inner_sum, orthonormal_iff_ite.mp hv] using Eq.symm\n\n"}
{"name":"Orthonormal.inner_right_sum","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nι : Type u_4\nv : ι → E\nhv : Orthonormal 𝕜 v\nl : ι → 𝕜\ns : Finset ι\ni : ι\nhi : Membership.mem s i\n⊢ Eq (Inner.inner (v i) (s.sum fun i => HSMul.hSMul (l i) (v i))) (l i)","decl":"/-- The inner product of a linear combination of a set of orthonormal vectors with one of those\nvectors picks out the coefficient of that vector. -/\ntheorem Orthonormal.inner_right_sum {v : ι → E} (hv : Orthonormal 𝕜 v) (l : ι → 𝕜) {s : Finset ι}\n    {i : ι} (hi : i ∈ s) : ⟪v i, ∑ i ∈ s, l i • v i⟫ = l i := by\n  classical\n  simp [inner_sum, inner_smul_right, orthonormal_iff_ite.mp hv, hi]\n\n"}
{"name":"Orthonormal.inner_right_fintype","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : SeminormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\nι : Type u_4\ninst✝ : Fintype ι\nv : ι → E\nhv : Orthonormal 𝕜 v\nl : ι → 𝕜\ni : ι\n⊢ Eq (Inner.inner (v i) (Finset.univ.sum fun i => HSMul.hSMul (l i) (v i))) (l i)","decl":"/-- The inner product of a linear combination of a set of orthonormal vectors with one of those\nvectors picks out the coefficient of that vector. -/\ntheorem Orthonormal.inner_right_fintype [Fintype ι] {v : ι → E} (hv : Orthonormal 𝕜 v) (l : ι → 𝕜)\n    (i : ι) : ⟪v i, ∑ i : ι, l i • v i⟫ = l i :=\n  hv.inner_right_sum l (Finset.mem_univ _)\n\n"}
{"name":"Orthonormal.inner_left_finsupp","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nι : Type u_4\nv : ι → E\nhv : Orthonormal 𝕜 v\nl : Finsupp ι 𝕜\ni : ι\n⊢ Eq (Inner.inner ((Finsupp.linearCombination 𝕜 v) l) (v i)) ((starRingEnd 𝕜) (l i))","decl":"/-- The inner product of a linear combination of a set of orthonormal vectors with one of those\nvectors picks out the coefficient of that vector. -/\ntheorem Orthonormal.inner_left_finsupp {v : ι → E} (hv : Orthonormal 𝕜 v) (l : ι →₀ 𝕜) (i : ι) :\n    ⟪linearCombination 𝕜 v l, v i⟫ = conj (l i) := by rw [← inner_conj_symm, hv.inner_right_finsupp]\n\n"}
{"name":"Orthonormal.inner_left_sum","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nι : Type u_4\nv : ι → E\nhv : Orthonormal 𝕜 v\nl : ι → 𝕜\ns : Finset ι\ni : ι\nhi : Membership.mem s i\n⊢ Eq (Inner.inner (s.sum fun i => HSMul.hSMul (l i) (v i)) (v i)) ((starRingEnd 𝕜) (l i))","decl":"/-- The inner product of a linear combination of a set of orthonormal vectors with one of those\nvectors picks out the coefficient of that vector. -/\ntheorem Orthonormal.inner_left_sum {v : ι → E} (hv : Orthonormal 𝕜 v) (l : ι → 𝕜) {s : Finset ι}\n    {i : ι} (hi : i ∈ s) : ⟪∑ i ∈ s, l i • v i, v i⟫ = conj (l i) := by\n  classical\n  simp only [sum_inner, inner_smul_left, orthonormal_iff_ite.mp hv, hi, mul_boole,\n    Finset.sum_ite_eq', if_true]\n\n"}
{"name":"Orthonormal.inner_left_fintype","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : SeminormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\nι : Type u_4\ninst✝ : Fintype ι\nv : ι → E\nhv : Orthonormal 𝕜 v\nl : ι → 𝕜\ni : ι\n⊢ Eq (Inner.inner (Finset.univ.sum fun i => HSMul.hSMul (l i) (v i)) (v i)) ((starRingEnd 𝕜) (l i))","decl":"/-- The inner product of a linear combination of a set of orthonormal vectors with one of those\nvectors picks out the coefficient of that vector. -/\ntheorem Orthonormal.inner_left_fintype [Fintype ι] {v : ι → E} (hv : Orthonormal 𝕜 v) (l : ι → 𝕜)\n    (i : ι) : ⟪∑ i : ι, l i • v i, v i⟫ = conj (l i) :=\n  hv.inner_left_sum l (Finset.mem_univ _)\n\n"}
{"name":"Orthonormal.inner_finsupp_eq_sum_left","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nι : Type u_4\nv : ι → E\nhv : Orthonormal 𝕜 v\nl₁ l₂ : Finsupp ι 𝕜\n⊢ Eq (Inner.inner ((Finsupp.linearCombination 𝕜 v) l₁) ((Finsupp.linearCombination 𝕜 v) l₂)) (l₁.sum fun i y => HMul.hMul ((starRingEnd 𝕜) y) (l₂ i))","decl":"/-- The inner product of two linear combinations of a set of orthonormal vectors, expressed as\na sum over the first `Finsupp`. -/\ntheorem Orthonormal.inner_finsupp_eq_sum_left {v : ι → E} (hv : Orthonormal 𝕜 v) (l₁ l₂ : ι →₀ 𝕜) :\n    ⟪linearCombination 𝕜 v l₁, linearCombination 𝕜 v l₂⟫ = l₁.sum fun i y => conj y * l₂ i := by\n  simp only [l₁.linearCombination_apply _, Finsupp.sum_inner, hv.inner_right_finsupp, smul_eq_mul]\n\n"}
{"name":"Orthonormal.inner_finsupp_eq_sum_right","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nι : Type u_4\nv : ι → E\nhv : Orthonormal 𝕜 v\nl₁ l₂ : Finsupp ι 𝕜\n⊢ Eq (Inner.inner ((Finsupp.linearCombination 𝕜 v) l₁) ((Finsupp.linearCombination 𝕜 v) l₂)) (l₂.sum fun i y => HMul.hMul ((starRingEnd 𝕜) (l₁ i)) y)","decl":"/-- The inner product of two linear combinations of a set of orthonormal vectors, expressed as\na sum over the second `Finsupp`. -/\ntheorem Orthonormal.inner_finsupp_eq_sum_right {v : ι → E} (hv : Orthonormal 𝕜 v) (l₁ l₂ : ι →₀ 𝕜) :\n    ⟪linearCombination 𝕜 v l₁, linearCombination 𝕜 v l₂⟫ = l₂.sum fun i y => conj (l₁ i) * y := by\n  simp only [l₂.linearCombination_apply _, Finsupp.inner_sum, hv.inner_left_finsupp, mul_comm,\n             smul_eq_mul]\n\n"}
{"name":"Orthonormal.inner_sum","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nι : Type u_4\nv : ι → E\nhv : Orthonormal 𝕜 v\nl₁ l₂ : ι → 𝕜\ns : Finset ι\n⊢ Eq (Inner.inner (s.sum fun i => HSMul.hSMul (l₁ i) (v i)) (s.sum fun i => HSMul.hSMul (l₂ i) (v i))) (s.sum fun i => HMul.hMul ((starRingEnd 𝕜) (l₁ i)) (l₂ i))","decl":"/-- The inner product of two linear combinations of a set of orthonormal vectors, expressed as\na sum. -/\nprotected theorem Orthonormal.inner_sum {v : ι → E} (hv : Orthonormal 𝕜 v) (l₁ l₂ : ι → 𝕜)\n    (s : Finset ι) : ⟪∑ i ∈ s, l₁ i • v i, ∑ i ∈ s, l₂ i • v i⟫ = ∑ i ∈ s, conj (l₁ i) * l₂ i := by\n  simp_rw [sum_inner, inner_smul_left]\n  refine Finset.sum_congr rfl fun i hi => ?_\n  rw [hv.inner_right_sum l₂ hi]\n\n"}
{"name":"Orthonormal.inner_left_right_finset","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nι : Type u_4\ns : Finset ι\nv : ι → E\nhv : Orthonormal 𝕜 v\na : ι → ι → 𝕜\n⊢ Eq (s.sum fun i => s.sum fun j => HSMul.hSMul (a i j) (Inner.inner (v j) (v i))) (s.sum fun k => a k k)","decl":"/--\nThe double sum of weighted inner products of pairs of vectors from an orthonormal sequence is the\nsum of the weights.\n-/\ntheorem Orthonormal.inner_left_right_finset {s : Finset ι} {v : ι → E} (hv : Orthonormal 𝕜 v)\n    {a : ι → ι → 𝕜} : (∑ i ∈ s, ∑ j ∈ s, a i j • ⟪v j, v i⟫) = ∑ k ∈ s, a k k := by\n  classical\n  simp [orthonormal_iff_ite.mp hv, Finset.sum_ite_of_true]\n\n"}
{"name":"Orthonormal.linearIndependent","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nι : Type u_4\nv : ι → E\nhv : Orthonormal 𝕜 v\n⊢ LinearIndependent 𝕜 v","decl":"/-- An orthonormal set is linearly independent. -/\ntheorem Orthonormal.linearIndependent {v : ι → E} (hv : Orthonormal 𝕜 v) :\n    LinearIndependent 𝕜 v := by\n  rw [linearIndependent_iff]\n  intro l hl\n  ext i\n  have key : ⟪v i, Finsupp.linearCombination 𝕜 v l⟫ = ⟪v i, 0⟫ := by rw [hl]\n  simpa only [hv.inner_right_finsupp, inner_zero_right] using key\n\n"}
{"name":"Orthonormal.comp","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nι : Type u_4\nι' : Type u_5\nv : ι → E\nhv : Orthonormal 𝕜 v\nf : ι' → ι\nhf : Function.Injective f\n⊢ Orthonormal 𝕜 (Function.comp v f)","decl":"/-- A subfamily of an orthonormal family (i.e., a composition with an injective map) is an\northonormal family. -/\ntheorem Orthonormal.comp {ι' : Type*} {v : ι → E} (hv : Orthonormal 𝕜 v) (f : ι' → ι)\n    (hf : Function.Injective f) : Orthonormal 𝕜 (v ∘ f) := by\n  classical\n  rw [orthonormal_iff_ite] at hv ⊢\n  intro i j\n  convert hv (f i) (f j) using 1\n  simp [hf.eq_iff]\n\n"}
{"name":"orthonormal_subtype_range","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nι : Type u_4\nv : ι → E\nhv : Function.Injective v\n⊢ Iff (Orthonormal 𝕜 Subtype.val) (Orthonormal 𝕜 v)","decl":"/-- An injective family `v : ι → E` is orthonormal if and only if `Subtype.val : (range v) → E` is\northonormal. -/\ntheorem orthonormal_subtype_range {v : ι → E} (hv : Function.Injective v) :\n    Orthonormal 𝕜 (Subtype.val : Set.range v → E) ↔ Orthonormal 𝕜 v := by\n  let f : ι ≃ Set.range v := Equiv.ofInjective v hv\n  refine ⟨fun h => h.comp f f.injective, fun h => ?_⟩\n  rw [← Equiv.self_comp_ofInjective_symm hv]\n  exact h.comp f.symm f.symm.injective\n\n"}
{"name":"Orthonormal.toSubtypeRange","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nι : Type u_4\nv : ι → E\nhv : Orthonormal 𝕜 v\n⊢ Orthonormal 𝕜 Subtype.val","decl":"/-- If `v : ι → E` is an orthonormal family, then `Subtype.val : (range v) → E` is an orthonormal\nfamily. -/\ntheorem Orthonormal.toSubtypeRange {v : ι → E} (hv : Orthonormal 𝕜 v) :\n    Orthonormal 𝕜 (Subtype.val : Set.range v → E) :=\n  (orthonormal_subtype_range hv.linearIndependent.injective).2 hv\n\n"}
{"name":"Orthonormal.inner_finsupp_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nι : Type u_4\nv : ι → E\nhv : Orthonormal 𝕜 v\ns : Set ι\ni : ι\nhi : Not (Membership.mem s i)\nl : Finsupp ι 𝕜\nhl : Membership.mem (Finsupp.supported 𝕜 𝕜 s) l\n⊢ Eq (Inner.inner ((Finsupp.linearCombination 𝕜 v) l) (v i)) 0","decl":"/-- A linear combination of some subset of an orthonormal set is orthogonal to other members of the\nset. -/\ntheorem Orthonormal.inner_finsupp_eq_zero {v : ι → E} (hv : Orthonormal 𝕜 v) {s : Set ι} {i : ι}\n    (hi : i ∉ s) {l : ι →₀ 𝕜} (hl : l ∈ Finsupp.supported 𝕜 𝕜 s) :\n    ⟪Finsupp.linearCombination 𝕜 v l, v i⟫ = 0 := by\n  rw [Finsupp.mem_supported'] at hl\n  simp only [hv.inner_left_finsupp, hl i hi, map_zero]\n\n"}
{"name":"Orthonormal.orthonormal_of_forall_eq_or_eq_neg","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nι : Type u_4\nv w : ι → E\nhv : Orthonormal 𝕜 v\nhw : ∀ (i : ι), Or (Eq (w i) (v i)) (Eq (w i) (Neg.neg (v i)))\n⊢ Orthonormal 𝕜 w","decl":"/-- Given an orthonormal family, a second family of vectors is orthonormal if every vector equals\nthe corresponding vector in the original family or its negation. -/\ntheorem Orthonormal.orthonormal_of_forall_eq_or_eq_neg {v w : ι → E} (hv : Orthonormal 𝕜 v)\n    (hw : ∀ i, w i = v i ∨ w i = -v i) : Orthonormal 𝕜 w := by\n  classical\n  rw [orthonormal_iff_ite] at *\n  intro i j\n  cases' hw i with hi hi <;> cases' hw j with hj hj <;>\n    replace hv := hv i j <;> split_ifs at hv ⊢ with h <;>\n    simpa only [hi, hj, h, inner_neg_right, inner_neg_left, neg_neg, eq_self_iff_true,\n      neg_eq_zero] using hv\n\n/- The material that follows, culminating in the existence of a maximal orthonormal subset, is\nadapted from the corresponding development of the theory of linearly independents sets.  See\n`exists_linearIndependent` in particular. -/\n"}
{"name":"orthonormal_empty","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\n⊢ Orthonormal 𝕜 fun x => ↑x","decl":"theorem orthonormal_empty : Orthonormal 𝕜 (fun x => x : (∅ : Set E) → E) := by\n  classical\n  simp [orthonormal_subtype_iff_ite]\n\n"}
{"name":"orthonormal_iUnion_of_directed","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nη : Type u_5\ns : η → Set E\nhs : Directed (fun x1 x2 => HasSubset.Subset x1 x2) s\nh : ∀ (i : η), Orthonormal 𝕜 fun x => ↑x\n⊢ Orthonormal 𝕜 fun x => ↑x","decl":"theorem orthonormal_iUnion_of_directed {η : Type*} {s : η → Set E} (hs : Directed (· ⊆ ·) s)\n    (h : ∀ i, Orthonormal 𝕜 (fun x => x : s i → E)) :\n    Orthonormal 𝕜 (fun x => x : (⋃ i, s i) → E) := by\n  classical\n  rw [orthonormal_subtype_iff_ite]\n  rintro x ⟨_, ⟨i, rfl⟩, hxi⟩ y ⟨_, ⟨j, rfl⟩, hyj⟩\n  obtain ⟨k, hik, hjk⟩ := hs i j\n  have h_orth : Orthonormal 𝕜 (fun x => x : s k → E) := h k\n  rw [orthonormal_subtype_iff_ite] at h_orth\n  exact h_orth x (hik hxi) y (hjk hyj)\n\n"}
{"name":"orthonormal_sUnion_of_directed","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\ns : Set (Set E)\nhs : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) s\nh : ∀ (a : Set E), Membership.mem s a → Orthonormal 𝕜 fun x => ↑x\n⊢ Orthonormal 𝕜 fun x => ↑x","decl":"theorem orthonormal_sUnion_of_directed {s : Set (Set E)} (hs : DirectedOn (· ⊆ ·) s)\n    (h : ∀ a ∈ s, Orthonormal 𝕜 (fun x => ((x : a) : E))) :\n    Orthonormal 𝕜 (fun x => x : ⋃₀ s → E) := by\n  rw [Set.sUnion_eq_iUnion]; exact orthonormal_iUnion_of_directed hs.directed_val (by simpa using h)\n\n"}
{"name":"exists_maximal_orthonormal","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\ns : Set E\nhs : Orthonormal 𝕜 Subtype.val\n⊢ Exists fun w => And (Superset w s) (And (Orthonormal 𝕜 Subtype.val) (∀ (u : Set E), Superset u w → Orthonormal 𝕜 Subtype.val → Eq u w))","decl":"/-- Given an orthonormal set `v` of vectors in `E`, there exists a maximal orthonormal set\ncontaining it. -/\ntheorem exists_maximal_orthonormal {s : Set E} (hs : Orthonormal 𝕜 (Subtype.val : s → E)) :\n    ∃ w ⊇ s, Orthonormal 𝕜 (Subtype.val : w → E) ∧\n      ∀ u ⊇ w, Orthonormal 𝕜 (Subtype.val : u → E) → u = w := by\n  have := zorn_subset_nonempty { b | Orthonormal 𝕜 (Subtype.val : b → E) } ?_ _ hs\n  · obtain ⟨b, hb⟩ := this\n    exact ⟨b, hb.1, hb.2.1, fun u hus hu => hb.2.eq_of_ge hu hus⟩\n  · refine fun c hc cc _c0 => ⟨⋃₀ c, ?_, ?_⟩\n    · exact orthonormal_sUnion_of_directed cc.directedOn fun x xc => hc xc\n    · exact fun _ => Set.subset_sUnion_of_mem\n\n"}
{"name":"coe_basisOfOrthonormalOfCardEqFinrank","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : RCLike 𝕜\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\nι : Type u_4\ninst✝¹ : Fintype ι\ninst✝ : Nonempty ι\nv : ι → E\nhv : Orthonormal 𝕜 v\ncard_eq : Eq (Fintype.card ι) (Module.finrank 𝕜 E)\n⊢ Eq (⇑(basisOfOrthonormalOfCardEqFinrank hv card_eq)) v","decl":"@[simp]\ntheorem coe_basisOfOrthonormalOfCardEqFinrank [Fintype ι] [Nonempty ι] {v : ι → E}\n    (hv : Orthonormal 𝕜 v) (card_eq : Fintype.card ι = finrank 𝕜 E) :\n    (basisOfOrthonormalOfCardEqFinrank hv card_eq : ι → E) = v :=\n  coe_basisOfLinearIndependentOfCardEqFinrank _ _\n\n"}
{"name":"Orthonormal.ne_zero","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nι : Type u_4\nv : ι → E\nhv : Orthonormal 𝕜 v\ni : ι\n⊢ Ne (v i) 0","decl":"theorem Orthonormal.ne_zero {v : ι → E} (hv : Orthonormal 𝕜 v) (i : ι) : v i ≠ 0 := by\n  refine ne_of_apply_ne norm ?_\n  rw [hv.1 i, norm_zero]\n  norm_num\n\n"}
{"name":"LinearIsometry.orthonormal_comp_iff","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : RCLike 𝕜\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\nι : Type u_4\nE' : Type u_7\ninst✝¹ : SeminormedAddCommGroup E'\ninst✝ : InnerProductSpace 𝕜 E'\nv : ι → E\nf : LinearIsometry (RingHom.id 𝕜) E E'\n⊢ Iff (Orthonormal 𝕜 (Function.comp (⇑f) v)) (Orthonormal 𝕜 v)","decl":"/-- A linear isometry preserves the property of being orthonormal. -/\ntheorem LinearIsometry.orthonormal_comp_iff {v : ι → E} (f : E →ₗᵢ[𝕜] E') :\n    Orthonormal 𝕜 (f ∘ v) ↔ Orthonormal 𝕜 v := by\n  classical simp_rw [orthonormal_iff_ite, Function.comp_apply, LinearIsometry.inner_map_map]\n\n"}
{"name":"Orthonormal.comp_linearIsometry","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : RCLike 𝕜\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\nι : Type u_4\nE' : Type u_7\ninst✝¹ : SeminormedAddCommGroup E'\ninst✝ : InnerProductSpace 𝕜 E'\nv : ι → E\nhv : Orthonormal 𝕜 v\nf : LinearIsometry (RingHom.id 𝕜) E E'\n⊢ Orthonormal 𝕜 (Function.comp (⇑f) v)","decl":"/-- A linear isometry preserves the property of being orthonormal. -/\ntheorem Orthonormal.comp_linearIsometry {v : ι → E} (hv : Orthonormal 𝕜 v) (f : E →ₗᵢ[𝕜] E') :\n    Orthonormal 𝕜 (f ∘ v) := by rwa [f.orthonormal_comp_iff]\n\n"}
{"name":"Orthonormal.comp_linearIsometryEquiv","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : RCLike 𝕜\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\nι : Type u_4\nE' : Type u_7\ninst✝¹ : SeminormedAddCommGroup E'\ninst✝ : InnerProductSpace 𝕜 E'\nv : ι → E\nhv : Orthonormal 𝕜 v\nf : LinearIsometryEquiv (RingHom.id 𝕜) E E'\n⊢ Orthonormal 𝕜 (Function.comp (⇑f) v)","decl":"/-- A linear isometric equivalence preserves the property of being orthonormal. -/\ntheorem Orthonormal.comp_linearIsometryEquiv {v : ι → E} (hv : Orthonormal 𝕜 v) (f : E ≃ₗᵢ[𝕜] E') :\n    Orthonormal 𝕜 (f ∘ v) :=\n  hv.comp_linearIsometry f.toLinearIsometry\n\n"}
{"name":"Orthonormal.mapLinearIsometryEquiv","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : RCLike 𝕜\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\nι : Type u_4\nE' : Type u_7\ninst✝¹ : SeminormedAddCommGroup E'\ninst✝ : InnerProductSpace 𝕜 E'\nv : Basis ι 𝕜 E\nhv : Orthonormal 𝕜 ⇑v\nf : LinearIsometryEquiv (RingHom.id 𝕜) E E'\n⊢ Orthonormal 𝕜 ⇑(v.map f.toLinearEquiv)","decl":"/-- A linear isometric equivalence, applied with `Basis.map`, preserves the property of being\northonormal. -/\ntheorem Orthonormal.mapLinearIsometryEquiv {v : Basis ι 𝕜 E} (hv : Orthonormal 𝕜 v)\n    (f : E ≃ₗᵢ[𝕜] E') : Orthonormal 𝕜 (v.map f.toLinearEquiv) :=\n  hv.comp_linearIsometryEquiv f\n\n"}
{"name":"LinearMap.coe_isometryOfOrthonormal","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : RCLike 𝕜\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\nι : Type u_4\nE' : Type u_7\ninst✝¹ : SeminormedAddCommGroup E'\ninst✝ : InnerProductSpace 𝕜 E'\nf : LinearMap (RingHom.id 𝕜) E E'\nv : Basis ι 𝕜 E\nhv : Orthonormal 𝕜 ⇑v\nhf : Orthonormal 𝕜 (Function.comp ⇑f ⇑v)\n⊢ Eq ⇑(f.isometryOfOrthonormal hv hf) ⇑f","decl":"@[simp]\ntheorem LinearMap.coe_isometryOfOrthonormal (f : E →ₗ[𝕜] E') {v : Basis ι 𝕜 E}\n    (hv : Orthonormal 𝕜 v) (hf : Orthonormal 𝕜 (f ∘ v)) : ⇑(f.isometryOfOrthonormal hv hf) = f :=\n  rfl\n\n"}
{"name":"LinearMap.isometryOfOrthonormal_toLinearMap","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : RCLike 𝕜\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\nι : Type u_4\nE' : Type u_7\ninst✝¹ : SeminormedAddCommGroup E'\ninst✝ : InnerProductSpace 𝕜 E'\nf : LinearMap (RingHom.id 𝕜) E E'\nv : Basis ι 𝕜 E\nhv : Orthonormal 𝕜 ⇑v\nhf : Orthonormal 𝕜 (Function.comp ⇑f ⇑v)\n⊢ Eq (f.isometryOfOrthonormal hv hf).toLinearMap f","decl":"@[simp]\ntheorem LinearMap.isometryOfOrthonormal_toLinearMap (f : E →ₗ[𝕜] E') {v : Basis ι 𝕜 E}\n    (hv : Orthonormal 𝕜 v) (hf : Orthonormal 𝕜 (f ∘ v)) :\n    (f.isometryOfOrthonormal hv hf).toLinearMap = f :=\n  rfl\n\n"}
{"name":"LinearEquiv.coe_isometryOfOrthonormal","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : RCLike 𝕜\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\nι : Type u_4\nE' : Type u_7\ninst✝¹ : SeminormedAddCommGroup E'\ninst✝ : InnerProductSpace 𝕜 E'\nf : LinearEquiv (RingHom.id 𝕜) E E'\nv : Basis ι 𝕜 E\nhv : Orthonormal 𝕜 ⇑v\nhf : Orthonormal 𝕜 (Function.comp ⇑f ⇑v)\n⊢ Eq ⇑(f.isometryOfOrthonormal hv hf) ⇑f","decl":"@[simp]\ntheorem LinearEquiv.coe_isometryOfOrthonormal (f : E ≃ₗ[𝕜] E') {v : Basis ι 𝕜 E}\n    (hv : Orthonormal 𝕜 v) (hf : Orthonormal 𝕜 (f ∘ v)) : ⇑(f.isometryOfOrthonormal hv hf) = f :=\n  rfl\n\n"}
{"name":"LinearEquiv.isometryOfOrthonormal_toLinearEquiv","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : RCLike 𝕜\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\nι : Type u_4\nE' : Type u_7\ninst✝¹ : SeminormedAddCommGroup E'\ninst✝ : InnerProductSpace 𝕜 E'\nf : LinearEquiv (RingHom.id 𝕜) E E'\nv : Basis ι 𝕜 E\nhv : Orthonormal 𝕜 ⇑v\nhf : Orthonormal 𝕜 (Function.comp ⇑f ⇑v)\n⊢ Eq (f.isometryOfOrthonormal hv hf).toLinearEquiv f","decl":"@[simp]\ntheorem LinearEquiv.isometryOfOrthonormal_toLinearEquiv (f : E ≃ₗ[𝕜] E') {v : Basis ι 𝕜 E}\n    (hv : Orthonormal 𝕜 v) (hf : Orthonormal 𝕜 (f ∘ v)) :\n    (f.isometryOfOrthonormal hv hf).toLinearEquiv = f :=\n  rfl\n\n"}
{"name":"Orthonormal.equiv_toLinearEquiv","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : RCLike 𝕜\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\nι : Type u_4\nι' : Type u_5\nE' : Type u_7\ninst✝¹ : SeminormedAddCommGroup E'\ninst✝ : InnerProductSpace 𝕜 E'\nv : Basis ι 𝕜 E\nhv : Orthonormal 𝕜 ⇑v\nv' : Basis ι' 𝕜 E'\nhv' : Orthonormal 𝕜 ⇑v'\ne : Equiv ι ι'\n⊢ Eq (hv.equiv hv' e).toLinearEquiv (v.equiv v' e)","decl":"@[simp]\ntheorem Orthonormal.equiv_toLinearEquiv {v : Basis ι 𝕜 E} (hv : Orthonormal 𝕜 v)\n    {v' : Basis ι' 𝕜 E'} (hv' : Orthonormal 𝕜 v') (e : ι ≃ ι') :\n    (hv.equiv hv' e).toLinearEquiv = v.equiv v' e :=\n  rfl\n\n"}
{"name":"Orthonormal.equiv_apply","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : RCLike 𝕜\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\nι : Type u_4\nE' : Type u_7\ninst✝¹ : SeminormedAddCommGroup E'\ninst✝ : InnerProductSpace 𝕜 E'\nι' : Type u_9\nv : Basis ι 𝕜 E\nhv : Orthonormal 𝕜 ⇑v\nv' : Basis ι' 𝕜 E'\nhv' : Orthonormal 𝕜 ⇑v'\ne : Equiv ι ι'\ni : ι\n⊢ Eq ((hv.equiv hv' e) (v i)) (v' (e i))","decl":"@[simp]\ntheorem Orthonormal.equiv_apply {ι' : Type*} {v : Basis ι 𝕜 E} (hv : Orthonormal 𝕜 v)\n    {v' : Basis ι' 𝕜 E'} (hv' : Orthonormal 𝕜 v') (e : ι ≃ ι') (i : ι) :\n    hv.equiv hv' e (v i) = v' (e i) :=\n  Basis.equiv_apply _ _ _ _\n\n"}
{"name":"Orthonormal.equiv_trans","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : InnerProductSpace 𝕜 E\nι : Type u_4\nι' : Type u_5\nι'' : Type u_6\nE' : Type u_7\ninst✝³ : SeminormedAddCommGroup E'\ninst✝² : InnerProductSpace 𝕜 E'\nE'' : Type u_8\ninst✝¹ : SeminormedAddCommGroup E''\ninst✝ : InnerProductSpace 𝕜 E''\nv : Basis ι 𝕜 E\nhv : Orthonormal 𝕜 ⇑v\nv' : Basis ι' 𝕜 E'\nhv' : Orthonormal 𝕜 ⇑v'\ne : Equiv ι ι'\nv'' : Basis ι'' 𝕜 E''\nhv'' : Orthonormal 𝕜 ⇑v''\ne' : Equiv ι' ι''\n⊢ Eq ((hv.equiv hv' e).trans (hv'.equiv hv'' e')) (hv.equiv hv'' (e.trans e'))","decl":"@[simp]\ntheorem Orthonormal.equiv_trans {v : Basis ι 𝕜 E} (hv : Orthonormal 𝕜 v) {v' : Basis ι' 𝕜 E'}\n    (hv' : Orthonormal 𝕜 v') (e : ι ≃ ι') {v'' : Basis ι'' 𝕜 E''} (hv'' : Orthonormal 𝕜 v'')\n    (e' : ι' ≃ ι'') : (hv.equiv hv' e).trans (hv'.equiv hv'' e') = hv.equiv hv'' (e.trans e') :=\n  v.ext_linearIsometryEquiv fun i => by\n    simp only [LinearIsometryEquiv.trans_apply, Orthonormal.equiv_apply, e.coe_trans,\n      Function.comp_apply]\n\n"}
{"name":"Orthonormal.map_equiv","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : RCLike 𝕜\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\nι : Type u_4\nι' : Type u_5\nE' : Type u_7\ninst✝¹ : SeminormedAddCommGroup E'\ninst✝ : InnerProductSpace 𝕜 E'\nv : Basis ι 𝕜 E\nhv : Orthonormal 𝕜 ⇑v\nv' : Basis ι' 𝕜 E'\nhv' : Orthonormal 𝕜 ⇑v'\ne : Equiv ι ι'\n⊢ Eq (v.map (hv.equiv hv' e).toLinearEquiv) (v'.reindex e.symm)","decl":"theorem Orthonormal.map_equiv {v : Basis ι 𝕜 E} (hv : Orthonormal 𝕜 v) {v' : Basis ι' 𝕜 E'}\n    (hv' : Orthonormal 𝕜 v') (e : ι ≃ ι') :\n    v.map (hv.equiv hv' e).toLinearEquiv = v'.reindex e.symm :=\n  v.map_equiv _ _\n\n"}
{"name":"Orthonormal.equiv_refl","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nι : Type u_4\nv : Basis ι 𝕜 E\nhv : Orthonormal 𝕜 ⇑v\n⊢ Eq (hv.equiv hv (Equiv.refl ι)) (LinearIsometryEquiv.refl 𝕜 E)","decl":"@[simp]\ntheorem Orthonormal.equiv_refl {v : Basis ι 𝕜 E} (hv : Orthonormal 𝕜 v) :\n    hv.equiv hv (Equiv.refl ι) = LinearIsometryEquiv.refl 𝕜 E :=\n  v.ext_linearIsometryEquiv fun i => by\n    simp only [Orthonormal.equiv_apply, Equiv.coe_refl, id, LinearIsometryEquiv.coe_refl]\n\n"}
{"name":"Orthonormal.equiv_symm","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : RCLike 𝕜\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\nι : Type u_4\nι' : Type u_5\nE' : Type u_6\ninst✝¹ : SeminormedAddCommGroup E'\ninst✝ : InnerProductSpace 𝕜 E'\nv : Basis ι 𝕜 E\nhv : Orthonormal 𝕜 ⇑v\nv' : Basis ι' 𝕜 E'\nhv' : Orthonormal 𝕜 ⇑v'\ne : Equiv ι ι'\n⊢ Eq (hv.equiv hv' e).symm (hv'.equiv hv e.symm)","decl":"@[simp]\ntheorem Orthonormal.equiv_symm {v : Basis ι 𝕜 E} (hv : Orthonormal 𝕜 v) {v' : Basis ι' 𝕜 E'}\n    (hv' : Orthonormal 𝕜 v') (e : ι ≃ ι') : (hv.equiv hv' e).symm = hv'.equiv hv e.symm :=\n  v'.ext_linearIsometryEquiv fun i =>\n    (hv.equiv hv' e).injective <| by\n      simp only [LinearIsometryEquiv.apply_symm_apply, Orthonormal.equiv_apply, e.apply_symm_apply]\n\n"}
{"name":"Orthonormal.sum_inner_products_le","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nι : Type u_4\nx : E\nv : ι → E\ns : Finset ι\nhv : Orthonormal 𝕜 v\n⊢ LE.le (s.sum fun i => HPow.hPow (Norm.norm (Inner.inner (v i) x)) 2) (HPow.hPow (Norm.norm x) 2)","decl":"/-- Bessel's inequality for finite sums. -/\ntheorem Orthonormal.sum_inner_products_le {s : Finset ι} (hv : Orthonormal 𝕜 v) :\n    ∑ i ∈ s, ‖⟪v i, x⟫‖ ^ 2 ≤ ‖x‖ ^ 2 := by\n  have h₂ :\n    (∑ i ∈ s, ∑ j ∈ s, ⟪v i, x⟫ * ⟪x, v j⟫ * ⟪v j, v i⟫) = (∑ k ∈ s, ⟪v k, x⟫ * ⟪x, v k⟫ : 𝕜) := by\n    classical exact hv.inner_left_right_finset\n  have h₃ : ∀ z : 𝕜, re (z * conj z) = ‖z‖ ^ 2 := by\n    intro z\n    simp only [mul_conj, normSq_eq_def']\n    norm_cast\n  suffices hbf : ‖x - ∑ i ∈ s, ⟪v i, x⟫ • v i‖ ^ 2 = ‖x‖ ^ 2 - ∑ i ∈ s, ‖⟪v i, x⟫‖ ^ 2 by\n    rw [← sub_nonneg, ← hbf]\n    simp only [norm_nonneg, pow_nonneg]\n  rw [@norm_sub_sq 𝕜, sub_add]\n  simp only [@InnerProductSpace.norm_sq_eq_inner 𝕜 E, inner_sum, sum_inner]\n  simp only [inner_smul_right, two_mul, inner_smul_left, inner_conj_symm, ← mul_assoc, h₂,\n    add_sub_cancel_right, sub_right_inj]\n  simp only [map_sum, ← inner_conj_symm x, ← h₃]\n\n"}
{"name":"Orthonormal.tsum_inner_products_le","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nι : Type u_4\nx : E\nv : ι → E\nhv : Orthonormal 𝕜 v\n⊢ LE.le (tsum fun i => HPow.hPow (Norm.norm (Inner.inner (v i) x)) 2) (HPow.hPow (Norm.norm x) 2)","decl":"/-- Bessel's inequality. -/\ntheorem Orthonormal.tsum_inner_products_le (hv : Orthonormal 𝕜 v) :\n    ∑' i, ‖⟪v i, x⟫‖ ^ 2 ≤ ‖x‖ ^ 2 := by\n  refine tsum_le_of_sum_le' ?_ fun s => hv.sum_inner_products_le x\n  simp only [norm_nonneg, pow_nonneg]\n\n"}
{"name":"Orthonormal.inner_products_summable","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nι : Type u_4\nx : E\nv : ι → E\nhv : Orthonormal 𝕜 v\n⊢ Summable fun i => HPow.hPow (Norm.norm (Inner.inner (v i) x)) 2","decl":"/-- The sum defined in Bessel's inequality is summable. -/\ntheorem Orthonormal.inner_products_summable (hv : Orthonormal 𝕜 v) :\n    Summable fun i => ‖⟪v i, x⟫‖ ^ 2 := by\n  use ⨆ s : Finset ι, ∑ i ∈ s, ‖⟪v i, x⟫‖ ^ 2\n  apply hasSum_of_isLUB_of_nonneg\n  · intro b\n    simp only [norm_nonneg, pow_nonneg]\n  · refine isLUB_ciSup ?_\n    use ‖x‖ ^ 2\n    rintro y ⟨s, rfl⟩\n    exact hv.sum_inner_products_le x\n\n"}
