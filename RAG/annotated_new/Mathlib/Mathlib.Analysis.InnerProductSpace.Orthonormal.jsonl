{"name":"orthonormal_iff_ite","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : SeminormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\ninstâœ : DecidableEq Î¹\nv : Î¹ â†’ E\nâŠ¢ Iff (Orthonormal ğ•œ v) (âˆ€ (i j : Î¹), Eq (Inner.inner (v i) (v j)) (ite (Eq i j) 1 0))","decl":"/-- `if ... then ... else` characterization of an indexed set of vectors being orthonormal.  (Inner\nproduct equals Kronecker delta.) -/\ntheorem orthonormal_iff_ite [DecidableEq Î¹] {v : Î¹ â†’ E} :\n    Orthonormal ğ•œ v â†” âˆ€ i j, âŸªv i, v jâŸ« = if i = j then (1 : ğ•œ) else (0 : ğ•œ) := by\n  constructor\n  Â· intro hv i j\n    split_ifs with h\n    Â· simp [h, inner_self_eq_norm_sq_to_K, hv.1]\n    Â· exact hv.2 h\n  Â· intro h\n    constructor\n    Â· intro i\n      have h' : â€–v iâ€– ^ 2 = 1 ^ 2 := by simp [@norm_sq_eq_inner ğ•œ, h i i]\n      have hâ‚ : 0 â‰¤ â€–v iâ€– := norm_nonneg _\n      have hâ‚‚ : (0 : â„) â‰¤ 1 := zero_le_one\n      rwa [sq_eq_sqâ‚€ hâ‚ hâ‚‚] at h'\n    Â· intro i j hij\n      simpa [hij] using h i j\n\n"}
{"name":"orthonormal_subtype_iff_ite","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : SeminormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : DecidableEq E\ns : Set E\nâŠ¢ Iff (Orthonormal ğ•œ Subtype.val) (âˆ€ (v : E), Membership.mem s v â†’ âˆ€ (w : E), Membership.mem s w â†’ Eq (Inner.inner v w) (ite (Eq v w) 1 0))","decl":"/-- `if ... then ... else` characterization of a set of vectors being orthonormal.  (Inner product\nequals Kronecker delta.) -/\ntheorem orthonormal_subtype_iff_ite [DecidableEq E] {s : Set E} :\n    Orthonormal ğ•œ (Subtype.val : s â†’ E) â†” âˆ€ v âˆˆ s, âˆ€ w âˆˆ s, âŸªv, wâŸ« = if v = w then 1 else 0 := by\n  rw [orthonormal_iff_ite]\n  constructor\n  Â· intro h v hv w hw\n    convert h âŸ¨v, hvâŸ© âŸ¨w, hwâŸ© using 1\n    simp\n  Â· rintro h âŸ¨v, hvâŸ© âŸ¨w, hwâŸ©\n    convert h v hv w hw using 1\n    simp\n\n"}
{"name":"Orthonormal.inner_right_finsupp","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nv : Î¹ â†’ E\nhv : Orthonormal ğ•œ v\nl : Finsupp Î¹ ğ•œ\ni : Î¹\nâŠ¢ Eq (Inner.inner (v i) ((Finsupp.linearCombination ğ•œ v) l)) (l i)","decl":"/-- The inner product of a linear combination of a set of orthonormal vectors with one of those\nvectors picks out the coefficient of that vector. -/\ntheorem Orthonormal.inner_right_finsupp {v : Î¹ â†’ E} (hv : Orthonormal ğ•œ v) (l : Î¹ â†’â‚€ ğ•œ) (i : Î¹) :\n    âŸªv i, linearCombination ğ•œ v lâŸ« = l i := by\n  classical\n  simpa [linearCombination_apply, Finsupp.inner_sum, orthonormal_iff_ite.mp hv] using Eq.symm\n\n"}
{"name":"Orthonormal.inner_right_sum","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nv : Î¹ â†’ E\nhv : Orthonormal ğ•œ v\nl : Î¹ â†’ ğ•œ\ns : Finset Î¹\ni : Î¹\nhi : Membership.mem s i\nâŠ¢ Eq (Inner.inner (v i) (s.sum fun i => HSMul.hSMul (l i) (v i))) (l i)","decl":"/-- The inner product of a linear combination of a set of orthonormal vectors with one of those\nvectors picks out the coefficient of that vector. -/\ntheorem Orthonormal.inner_right_sum {v : Î¹ â†’ E} (hv : Orthonormal ğ•œ v) (l : Î¹ â†’ ğ•œ) {s : Finset Î¹}\n    {i : Î¹} (hi : i âˆˆ s) : âŸªv i, âˆ‘ i âˆˆ s, l i â€¢ v iâŸ« = l i := by\n  classical\n  simp [inner_sum, inner_smul_right, orthonormal_iff_ite.mp hv, hi]\n\n"}
{"name":"Orthonormal.inner_right_fintype","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : SeminormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\ninstâœ : Fintype Î¹\nv : Î¹ â†’ E\nhv : Orthonormal ğ•œ v\nl : Î¹ â†’ ğ•œ\ni : Î¹\nâŠ¢ Eq (Inner.inner (v i) (Finset.univ.sum fun i => HSMul.hSMul (l i) (v i))) (l i)","decl":"/-- The inner product of a linear combination of a set of orthonormal vectors with one of those\nvectors picks out the coefficient of that vector. -/\ntheorem Orthonormal.inner_right_fintype [Fintype Î¹] {v : Î¹ â†’ E} (hv : Orthonormal ğ•œ v) (l : Î¹ â†’ ğ•œ)\n    (i : Î¹) : âŸªv i, âˆ‘ i : Î¹, l i â€¢ v iâŸ« = l i :=\n  hv.inner_right_sum l (Finset.mem_univ _)\n\n"}
{"name":"Orthonormal.inner_left_finsupp","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nv : Î¹ â†’ E\nhv : Orthonormal ğ•œ v\nl : Finsupp Î¹ ğ•œ\ni : Î¹\nâŠ¢ Eq (Inner.inner ((Finsupp.linearCombination ğ•œ v) l) (v i)) ((starRingEnd ğ•œ) (l i))","decl":"/-- The inner product of a linear combination of a set of orthonormal vectors with one of those\nvectors picks out the coefficient of that vector. -/\ntheorem Orthonormal.inner_left_finsupp {v : Î¹ â†’ E} (hv : Orthonormal ğ•œ v) (l : Î¹ â†’â‚€ ğ•œ) (i : Î¹) :\n    âŸªlinearCombination ğ•œ v l, v iâŸ« = conj (l i) := by rw [â† inner_conj_symm, hv.inner_right_finsupp]\n\n"}
{"name":"Orthonormal.inner_left_sum","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nv : Î¹ â†’ E\nhv : Orthonormal ğ•œ v\nl : Î¹ â†’ ğ•œ\ns : Finset Î¹\ni : Î¹\nhi : Membership.mem s i\nâŠ¢ Eq (Inner.inner (s.sum fun i => HSMul.hSMul (l i) (v i)) (v i)) ((starRingEnd ğ•œ) (l i))","decl":"/-- The inner product of a linear combination of a set of orthonormal vectors with one of those\nvectors picks out the coefficient of that vector. -/\ntheorem Orthonormal.inner_left_sum {v : Î¹ â†’ E} (hv : Orthonormal ğ•œ v) (l : Î¹ â†’ ğ•œ) {s : Finset Î¹}\n    {i : Î¹} (hi : i âˆˆ s) : âŸªâˆ‘ i âˆˆ s, l i â€¢ v i, v iâŸ« = conj (l i) := by\n  classical\n  simp only [sum_inner, inner_smul_left, orthonormal_iff_ite.mp hv, hi, mul_boole,\n    Finset.sum_ite_eq', if_true]\n\n"}
{"name":"Orthonormal.inner_left_fintype","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : SeminormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\ninstâœ : Fintype Î¹\nv : Î¹ â†’ E\nhv : Orthonormal ğ•œ v\nl : Î¹ â†’ ğ•œ\ni : Î¹\nâŠ¢ Eq (Inner.inner (Finset.univ.sum fun i => HSMul.hSMul (l i) (v i)) (v i)) ((starRingEnd ğ•œ) (l i))","decl":"/-- The inner product of a linear combination of a set of orthonormal vectors with one of those\nvectors picks out the coefficient of that vector. -/\ntheorem Orthonormal.inner_left_fintype [Fintype Î¹] {v : Î¹ â†’ E} (hv : Orthonormal ğ•œ v) (l : Î¹ â†’ ğ•œ)\n    (i : Î¹) : âŸªâˆ‘ i : Î¹, l i â€¢ v i, v iâŸ« = conj (l i) :=\n  hv.inner_left_sum l (Finset.mem_univ _)\n\n"}
{"name":"Orthonormal.inner_finsupp_eq_sum_left","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nv : Î¹ â†’ E\nhv : Orthonormal ğ•œ v\nlâ‚ lâ‚‚ : Finsupp Î¹ ğ•œ\nâŠ¢ Eq (Inner.inner ((Finsupp.linearCombination ğ•œ v) lâ‚) ((Finsupp.linearCombination ğ•œ v) lâ‚‚)) (lâ‚.sum fun i y => HMul.hMul ((starRingEnd ğ•œ) y) (lâ‚‚ i))","decl":"/-- The inner product of two linear combinations of a set of orthonormal vectors, expressed as\na sum over the first `Finsupp`. -/\ntheorem Orthonormal.inner_finsupp_eq_sum_left {v : Î¹ â†’ E} (hv : Orthonormal ğ•œ v) (lâ‚ lâ‚‚ : Î¹ â†’â‚€ ğ•œ) :\n    âŸªlinearCombination ğ•œ v lâ‚, linearCombination ğ•œ v lâ‚‚âŸ« = lâ‚.sum fun i y => conj y * lâ‚‚ i := by\n  simp only [lâ‚.linearCombination_apply _, Finsupp.sum_inner, hv.inner_right_finsupp, smul_eq_mul]\n\n"}
{"name":"Orthonormal.inner_finsupp_eq_sum_right","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nv : Î¹ â†’ E\nhv : Orthonormal ğ•œ v\nlâ‚ lâ‚‚ : Finsupp Î¹ ğ•œ\nâŠ¢ Eq (Inner.inner ((Finsupp.linearCombination ğ•œ v) lâ‚) ((Finsupp.linearCombination ğ•œ v) lâ‚‚)) (lâ‚‚.sum fun i y => HMul.hMul ((starRingEnd ğ•œ) (lâ‚ i)) y)","decl":"/-- The inner product of two linear combinations of a set of orthonormal vectors, expressed as\na sum over the second `Finsupp`. -/\ntheorem Orthonormal.inner_finsupp_eq_sum_right {v : Î¹ â†’ E} (hv : Orthonormal ğ•œ v) (lâ‚ lâ‚‚ : Î¹ â†’â‚€ ğ•œ) :\n    âŸªlinearCombination ğ•œ v lâ‚, linearCombination ğ•œ v lâ‚‚âŸ« = lâ‚‚.sum fun i y => conj (lâ‚ i) * y := by\n  simp only [lâ‚‚.linearCombination_apply _, Finsupp.inner_sum, hv.inner_left_finsupp, mul_comm,\n             smul_eq_mul]\n\n"}
{"name":"Orthonormal.inner_sum","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nv : Î¹ â†’ E\nhv : Orthonormal ğ•œ v\nlâ‚ lâ‚‚ : Î¹ â†’ ğ•œ\ns : Finset Î¹\nâŠ¢ Eq (Inner.inner (s.sum fun i => HSMul.hSMul (lâ‚ i) (v i)) (s.sum fun i => HSMul.hSMul (lâ‚‚ i) (v i))) (s.sum fun i => HMul.hMul ((starRingEnd ğ•œ) (lâ‚ i)) (lâ‚‚ i))","decl":"/-- The inner product of two linear combinations of a set of orthonormal vectors, expressed as\na sum. -/\nprotected theorem Orthonormal.inner_sum {v : Î¹ â†’ E} (hv : Orthonormal ğ•œ v) (lâ‚ lâ‚‚ : Î¹ â†’ ğ•œ)\n    (s : Finset Î¹) : âŸªâˆ‘ i âˆˆ s, lâ‚ i â€¢ v i, âˆ‘ i âˆˆ s, lâ‚‚ i â€¢ v iâŸ« = âˆ‘ i âˆˆ s, conj (lâ‚ i) * lâ‚‚ i := by\n  simp_rw [sum_inner, inner_smul_left]\n  refine Finset.sum_congr rfl fun i hi => ?_\n  rw [hv.inner_right_sum lâ‚‚ hi]\n\n"}
{"name":"Orthonormal.inner_left_right_finset","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\ns : Finset Î¹\nv : Î¹ â†’ E\nhv : Orthonormal ğ•œ v\na : Î¹ â†’ Î¹ â†’ ğ•œ\nâŠ¢ Eq (s.sum fun i => s.sum fun j => HSMul.hSMul (a i j) (Inner.inner (v j) (v i))) (s.sum fun k => a k k)","decl":"/--\nThe double sum of weighted inner products of pairs of vectors from an orthonormal sequence is the\nsum of the weights.\n-/\ntheorem Orthonormal.inner_left_right_finset {s : Finset Î¹} {v : Î¹ â†’ E} (hv : Orthonormal ğ•œ v)\n    {a : Î¹ â†’ Î¹ â†’ ğ•œ} : (âˆ‘ i âˆˆ s, âˆ‘ j âˆˆ s, a i j â€¢ âŸªv j, v iâŸ«) = âˆ‘ k âˆˆ s, a k k := by\n  classical\n  simp [orthonormal_iff_ite.mp hv, Finset.sum_ite_of_true]\n\n"}
{"name":"Orthonormal.linearIndependent","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nv : Î¹ â†’ E\nhv : Orthonormal ğ•œ v\nâŠ¢ LinearIndependent ğ•œ v","decl":"/-- An orthonormal set is linearly independent. -/\ntheorem Orthonormal.linearIndependent {v : Î¹ â†’ E} (hv : Orthonormal ğ•œ v) :\n    LinearIndependent ğ•œ v := by\n  rw [linearIndependent_iff]\n  intro l hl\n  ext i\n  have key : âŸªv i, Finsupp.linearCombination ğ•œ v lâŸ« = âŸªv i, 0âŸ« := by rw [hl]\n  simpa only [hv.inner_right_finsupp, inner_zero_right] using key\n\n"}
{"name":"Orthonormal.comp","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nÎ¹' : Type u_5\nv : Î¹ â†’ E\nhv : Orthonormal ğ•œ v\nf : Î¹' â†’ Î¹\nhf : Function.Injective f\nâŠ¢ Orthonormal ğ•œ (Function.comp v f)","decl":"/-- A subfamily of an orthonormal family (i.e., a composition with an injective map) is an\northonormal family. -/\ntheorem Orthonormal.comp {Î¹' : Type*} {v : Î¹ â†’ E} (hv : Orthonormal ğ•œ v) (f : Î¹' â†’ Î¹)\n    (hf : Function.Injective f) : Orthonormal ğ•œ (v âˆ˜ f) := by\n  classical\n  rw [orthonormal_iff_ite] at hv âŠ¢\n  intro i j\n  convert hv (f i) (f j) using 1\n  simp [hf.eq_iff]\n\n"}
{"name":"orthonormal_subtype_range","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nv : Î¹ â†’ E\nhv : Function.Injective v\nâŠ¢ Iff (Orthonormal ğ•œ Subtype.val) (Orthonormal ğ•œ v)","decl":"/-- An injective family `v : Î¹ â†’ E` is orthonormal if and only if `Subtype.val : (range v) â†’ E` is\northonormal. -/\ntheorem orthonormal_subtype_range {v : Î¹ â†’ E} (hv : Function.Injective v) :\n    Orthonormal ğ•œ (Subtype.val : Set.range v â†’ E) â†” Orthonormal ğ•œ v := by\n  let f : Î¹ â‰ƒ Set.range v := Equiv.ofInjective v hv\n  refine âŸ¨fun h => h.comp f f.injective, fun h => ?_âŸ©\n  rw [â† Equiv.self_comp_ofInjective_symm hv]\n  exact h.comp f.symm f.symm.injective\n\n"}
{"name":"Orthonormal.toSubtypeRange","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nv : Î¹ â†’ E\nhv : Orthonormal ğ•œ v\nâŠ¢ Orthonormal ğ•œ Subtype.val","decl":"/-- If `v : Î¹ â†’ E` is an orthonormal family, then `Subtype.val : (range v) â†’ E` is an orthonormal\nfamily. -/\ntheorem Orthonormal.toSubtypeRange {v : Î¹ â†’ E} (hv : Orthonormal ğ•œ v) :\n    Orthonormal ğ•œ (Subtype.val : Set.range v â†’ E) :=\n  (orthonormal_subtype_range hv.linearIndependent.injective).2 hv\n\n"}
{"name":"Orthonormal.inner_finsupp_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nv : Î¹ â†’ E\nhv : Orthonormal ğ•œ v\ns : Set Î¹\ni : Î¹\nhi : Not (Membership.mem s i)\nl : Finsupp Î¹ ğ•œ\nhl : Membership.mem (Finsupp.supported ğ•œ ğ•œ s) l\nâŠ¢ Eq (Inner.inner ((Finsupp.linearCombination ğ•œ v) l) (v i)) 0","decl":"/-- A linear combination of some subset of an orthonormal set is orthogonal to other members of the\nset. -/\ntheorem Orthonormal.inner_finsupp_eq_zero {v : Î¹ â†’ E} (hv : Orthonormal ğ•œ v) {s : Set Î¹} {i : Î¹}\n    (hi : i âˆ‰ s) {l : Î¹ â†’â‚€ ğ•œ} (hl : l âˆˆ Finsupp.supported ğ•œ ğ•œ s) :\n    âŸªFinsupp.linearCombination ğ•œ v l, v iâŸ« = 0 := by\n  rw [Finsupp.mem_supported'] at hl\n  simp only [hv.inner_left_finsupp, hl i hi, map_zero]\n\n"}
{"name":"Orthonormal.orthonormal_of_forall_eq_or_eq_neg","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nv w : Î¹ â†’ E\nhv : Orthonormal ğ•œ v\nhw : âˆ€ (i : Î¹), Or (Eq (w i) (v i)) (Eq (w i) (Neg.neg (v i)))\nâŠ¢ Orthonormal ğ•œ w","decl":"/-- Given an orthonormal family, a second family of vectors is orthonormal if every vector equals\nthe corresponding vector in the original family or its negation. -/\ntheorem Orthonormal.orthonormal_of_forall_eq_or_eq_neg {v w : Î¹ â†’ E} (hv : Orthonormal ğ•œ v)\n    (hw : âˆ€ i, w i = v i âˆ¨ w i = -v i) : Orthonormal ğ•œ w := by\n  classical\n  rw [orthonormal_iff_ite] at *\n  intro i j\n  cases' hw i with hi hi <;> cases' hw j with hj hj <;>\n    replace hv := hv i j <;> split_ifs at hv âŠ¢ with h <;>\n    simpa only [hi, hj, h, inner_neg_right, inner_neg_left, neg_neg, eq_self_iff_true,\n      neg_eq_zero] using hv\n\n/- The material that follows, culminating in the existence of a maximal orthonormal subset, is\nadapted from the corresponding development of the theory of linearly independents sets.  See\n`exists_linearIndependent` in particular. -/\n"}
{"name":"orthonormal_empty","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nâŠ¢ Orthonormal ğ•œ fun x => â†‘x","decl":"theorem orthonormal_empty : Orthonormal ğ•œ (fun x => x : (âˆ… : Set E) â†’ E) := by\n  classical\n  simp [orthonormal_subtype_iff_ite]\n\n"}
{"name":"orthonormal_iUnion_of_directed","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ· : Type u_5\ns : Î· â†’ Set E\nhs : Directed (fun x1 x2 => HasSubset.Subset x1 x2) s\nh : âˆ€ (i : Î·), Orthonormal ğ•œ fun x => â†‘x\nâŠ¢ Orthonormal ğ•œ fun x => â†‘x","decl":"theorem orthonormal_iUnion_of_directed {Î· : Type*} {s : Î· â†’ Set E} (hs : Directed (Â· âŠ† Â·) s)\n    (h : âˆ€ i, Orthonormal ğ•œ (fun x => x : s i â†’ E)) :\n    Orthonormal ğ•œ (fun x => x : (â‹ƒ i, s i) â†’ E) := by\n  classical\n  rw [orthonormal_subtype_iff_ite]\n  rintro x âŸ¨_, âŸ¨i, rflâŸ©, hxiâŸ© y âŸ¨_, âŸ¨j, rflâŸ©, hyjâŸ©\n  obtain âŸ¨k, hik, hjkâŸ© := hs i j\n  have h_orth : Orthonormal ğ•œ (fun x => x : s k â†’ E) := h k\n  rw [orthonormal_subtype_iff_ite] at h_orth\n  exact h_orth x (hik hxi) y (hjk hyj)\n\n"}
{"name":"orthonormal_sUnion_of_directed","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\ns : Set (Set E)\nhs : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) s\nh : âˆ€ (a : Set E), Membership.mem s a â†’ Orthonormal ğ•œ fun x => â†‘x\nâŠ¢ Orthonormal ğ•œ fun x => â†‘x","decl":"theorem orthonormal_sUnion_of_directed {s : Set (Set E)} (hs : DirectedOn (Â· âŠ† Â·) s)\n    (h : âˆ€ a âˆˆ s, Orthonormal ğ•œ (fun x => ((x : a) : E))) :\n    Orthonormal ğ•œ (fun x => x : â‹ƒâ‚€ s â†’ E) := by\n  rw [Set.sUnion_eq_iUnion]; exact orthonormal_iUnion_of_directed hs.directed_val (by simpa using h)\n\n"}
{"name":"exists_maximal_orthonormal","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\ns : Set E\nhs : Orthonormal ğ•œ Subtype.val\nâŠ¢ Exists fun w => And (Superset w s) (And (Orthonormal ğ•œ Subtype.val) (âˆ€ (u : Set E), Superset u w â†’ Orthonormal ğ•œ Subtype.val â†’ Eq u w))","decl":"/-- Given an orthonormal set `v` of vectors in `E`, there exists a maximal orthonormal set\ncontaining it. -/\ntheorem exists_maximal_orthonormal {s : Set E} (hs : Orthonormal ğ•œ (Subtype.val : s â†’ E)) :\n    âˆƒ w âŠ‡ s, Orthonormal ğ•œ (Subtype.val : w â†’ E) âˆ§\n      âˆ€ u âŠ‡ w, Orthonormal ğ•œ (Subtype.val : u â†’ E) â†’ u = w := by\n  have := zorn_subset_nonempty { b | Orthonormal ğ•œ (Subtype.val : b â†’ E) } ?_ _ hs\n  Â· obtain âŸ¨b, hbâŸ© := this\n    exact âŸ¨b, hb.1, hb.2.1, fun u hus hu => hb.2.eq_of_ge hu husâŸ©\n  Â· refine fun c hc cc _c0 => âŸ¨â‹ƒâ‚€ c, ?_, ?_âŸ©\n    Â· exact orthonormal_sUnion_of_directed cc.directedOn fun x xc => hc xc\n    Â· exact fun _ => Set.subset_sUnion_of_mem\n\n"}
{"name":"coe_basisOfOrthonormalOfCardEqFinrank","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\ninstâœÂ¹ : Fintype Î¹\ninstâœ : Nonempty Î¹\nv : Î¹ â†’ E\nhv : Orthonormal ğ•œ v\ncard_eq : Eq (Fintype.card Î¹) (Module.finrank ğ•œ E)\nâŠ¢ Eq (â‡‘(basisOfOrthonormalOfCardEqFinrank hv card_eq)) v","decl":"@[simp]\ntheorem coe_basisOfOrthonormalOfCardEqFinrank [Fintype Î¹] [Nonempty Î¹] {v : Î¹ â†’ E}\n    (hv : Orthonormal ğ•œ v) (card_eq : Fintype.card Î¹ = finrank ğ•œ E) :\n    (basisOfOrthonormalOfCardEqFinrank hv card_eq : Î¹ â†’ E) = v :=\n  coe_basisOfLinearIndependentOfCardEqFinrank _ _\n\n"}
{"name":"Orthonormal.ne_zero","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nv : Î¹ â†’ E\nhv : Orthonormal ğ•œ v\ni : Î¹\nâŠ¢ Ne (v i) 0","decl":"theorem Orthonormal.ne_zero {v : Î¹ â†’ E} (hv : Orthonormal ğ•œ v) (i : Î¹) : v i â‰  0 := by\n  refine ne_of_apply_ne norm ?_\n  rw [hv.1 i, norm_zero]\n  norm_num\n\n"}
{"name":"LinearIsometry.orthonormal_comp_iff","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nE' : Type u_7\ninstâœÂ¹ : SeminormedAddCommGroup E'\ninstâœ : InnerProductSpace ğ•œ E'\nv : Î¹ â†’ E\nf : LinearIsometry (RingHom.id ğ•œ) E E'\nâŠ¢ Iff (Orthonormal ğ•œ (Function.comp (â‡‘f) v)) (Orthonormal ğ•œ v)","decl":"/-- A linear isometry preserves the property of being orthonormal. -/\ntheorem LinearIsometry.orthonormal_comp_iff {v : Î¹ â†’ E} (f : E â†’â‚—áµ¢[ğ•œ] E') :\n    Orthonormal ğ•œ (f âˆ˜ v) â†” Orthonormal ğ•œ v := by\n  classical simp_rw [orthonormal_iff_ite, Function.comp_apply, LinearIsometry.inner_map_map]\n\n"}
{"name":"Orthonormal.comp_linearIsometry","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nE' : Type u_7\ninstâœÂ¹ : SeminormedAddCommGroup E'\ninstâœ : InnerProductSpace ğ•œ E'\nv : Î¹ â†’ E\nhv : Orthonormal ğ•œ v\nf : LinearIsometry (RingHom.id ğ•œ) E E'\nâŠ¢ Orthonormal ğ•œ (Function.comp (â‡‘f) v)","decl":"/-- A linear isometry preserves the property of being orthonormal. -/\ntheorem Orthonormal.comp_linearIsometry {v : Î¹ â†’ E} (hv : Orthonormal ğ•œ v) (f : E â†’â‚—áµ¢[ğ•œ] E') :\n    Orthonormal ğ•œ (f âˆ˜ v) := by rwa [f.orthonormal_comp_iff]\n\n"}
{"name":"Orthonormal.comp_linearIsometryEquiv","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nE' : Type u_7\ninstâœÂ¹ : SeminormedAddCommGroup E'\ninstâœ : InnerProductSpace ğ•œ E'\nv : Î¹ â†’ E\nhv : Orthonormal ğ•œ v\nf : LinearIsometryEquiv (RingHom.id ğ•œ) E E'\nâŠ¢ Orthonormal ğ•œ (Function.comp (â‡‘f) v)","decl":"/-- A linear isometric equivalence preserves the property of being orthonormal. -/\ntheorem Orthonormal.comp_linearIsometryEquiv {v : Î¹ â†’ E} (hv : Orthonormal ğ•œ v) (f : E â‰ƒâ‚—áµ¢[ğ•œ] E') :\n    Orthonormal ğ•œ (f âˆ˜ v) :=\n  hv.comp_linearIsometry f.toLinearIsometry\n\n"}
{"name":"Orthonormal.mapLinearIsometryEquiv","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nE' : Type u_7\ninstâœÂ¹ : SeminormedAddCommGroup E'\ninstâœ : InnerProductSpace ğ•œ E'\nv : Basis Î¹ ğ•œ E\nhv : Orthonormal ğ•œ â‡‘v\nf : LinearIsometryEquiv (RingHom.id ğ•œ) E E'\nâŠ¢ Orthonormal ğ•œ â‡‘(v.map f.toLinearEquiv)","decl":"/-- A linear isometric equivalence, applied with `Basis.map`, preserves the property of being\northonormal. -/\ntheorem Orthonormal.mapLinearIsometryEquiv {v : Basis Î¹ ğ•œ E} (hv : Orthonormal ğ•œ v)\n    (f : E â‰ƒâ‚—áµ¢[ğ•œ] E') : Orthonormal ğ•œ (v.map f.toLinearEquiv) :=\n  hv.comp_linearIsometryEquiv f\n\n"}
{"name":"LinearMap.coe_isometryOfOrthonormal","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nE' : Type u_7\ninstâœÂ¹ : SeminormedAddCommGroup E'\ninstâœ : InnerProductSpace ğ•œ E'\nf : LinearMap (RingHom.id ğ•œ) E E'\nv : Basis Î¹ ğ•œ E\nhv : Orthonormal ğ•œ â‡‘v\nhf : Orthonormal ğ•œ (Function.comp â‡‘f â‡‘v)\nâŠ¢ Eq â‡‘(f.isometryOfOrthonormal hv hf) â‡‘f","decl":"@[simp]\ntheorem LinearMap.coe_isometryOfOrthonormal (f : E â†’â‚—[ğ•œ] E') {v : Basis Î¹ ğ•œ E}\n    (hv : Orthonormal ğ•œ v) (hf : Orthonormal ğ•œ (f âˆ˜ v)) : â‡‘(f.isometryOfOrthonormal hv hf) = f :=\n  rfl\n\n"}
{"name":"LinearMap.isometryOfOrthonormal_toLinearMap","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nE' : Type u_7\ninstâœÂ¹ : SeminormedAddCommGroup E'\ninstâœ : InnerProductSpace ğ•œ E'\nf : LinearMap (RingHom.id ğ•œ) E E'\nv : Basis Î¹ ğ•œ E\nhv : Orthonormal ğ•œ â‡‘v\nhf : Orthonormal ğ•œ (Function.comp â‡‘f â‡‘v)\nâŠ¢ Eq (f.isometryOfOrthonormal hv hf).toLinearMap f","decl":"@[simp]\ntheorem LinearMap.isometryOfOrthonormal_toLinearMap (f : E â†’â‚—[ğ•œ] E') {v : Basis Î¹ ğ•œ E}\n    (hv : Orthonormal ğ•œ v) (hf : Orthonormal ğ•œ (f âˆ˜ v)) :\n    (f.isometryOfOrthonormal hv hf).toLinearMap = f :=\n  rfl\n\n"}
{"name":"LinearEquiv.coe_isometryOfOrthonormal","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nE' : Type u_7\ninstâœÂ¹ : SeminormedAddCommGroup E'\ninstâœ : InnerProductSpace ğ•œ E'\nf : LinearEquiv (RingHom.id ğ•œ) E E'\nv : Basis Î¹ ğ•œ E\nhv : Orthonormal ğ•œ â‡‘v\nhf : Orthonormal ğ•œ (Function.comp â‡‘f â‡‘v)\nâŠ¢ Eq â‡‘(f.isometryOfOrthonormal hv hf) â‡‘f","decl":"@[simp]\ntheorem LinearEquiv.coe_isometryOfOrthonormal (f : E â‰ƒâ‚—[ğ•œ] E') {v : Basis Î¹ ğ•œ E}\n    (hv : Orthonormal ğ•œ v) (hf : Orthonormal ğ•œ (f âˆ˜ v)) : â‡‘(f.isometryOfOrthonormal hv hf) = f :=\n  rfl\n\n"}
{"name":"LinearEquiv.isometryOfOrthonormal_toLinearEquiv","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nE' : Type u_7\ninstâœÂ¹ : SeminormedAddCommGroup E'\ninstâœ : InnerProductSpace ğ•œ E'\nf : LinearEquiv (RingHom.id ğ•œ) E E'\nv : Basis Î¹ ğ•œ E\nhv : Orthonormal ğ•œ â‡‘v\nhf : Orthonormal ğ•œ (Function.comp â‡‘f â‡‘v)\nâŠ¢ Eq (f.isometryOfOrthonormal hv hf).toLinearEquiv f","decl":"@[simp]\ntheorem LinearEquiv.isometryOfOrthonormal_toLinearEquiv (f : E â‰ƒâ‚—[ğ•œ] E') {v : Basis Î¹ ğ•œ E}\n    (hv : Orthonormal ğ•œ v) (hf : Orthonormal ğ•œ (f âˆ˜ v)) :\n    (f.isometryOfOrthonormal hv hf).toLinearEquiv = f :=\n  rfl\n\n"}
{"name":"Orthonormal.equiv_toLinearEquiv","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nÎ¹' : Type u_5\nE' : Type u_7\ninstâœÂ¹ : SeminormedAddCommGroup E'\ninstâœ : InnerProductSpace ğ•œ E'\nv : Basis Î¹ ğ•œ E\nhv : Orthonormal ğ•œ â‡‘v\nv' : Basis Î¹' ğ•œ E'\nhv' : Orthonormal ğ•œ â‡‘v'\ne : Equiv Î¹ Î¹'\nâŠ¢ Eq (hv.equiv hv' e).toLinearEquiv (v.equiv v' e)","decl":"@[simp]\ntheorem Orthonormal.equiv_toLinearEquiv {v : Basis Î¹ ğ•œ E} (hv : Orthonormal ğ•œ v)\n    {v' : Basis Î¹' ğ•œ E'} (hv' : Orthonormal ğ•œ v') (e : Î¹ â‰ƒ Î¹') :\n    (hv.equiv hv' e).toLinearEquiv = v.equiv v' e :=\n  rfl\n\n"}
{"name":"Orthonormal.equiv_apply","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nE' : Type u_7\ninstâœÂ¹ : SeminormedAddCommGroup E'\ninstâœ : InnerProductSpace ğ•œ E'\nÎ¹' : Type u_9\nv : Basis Î¹ ğ•œ E\nhv : Orthonormal ğ•œ â‡‘v\nv' : Basis Î¹' ğ•œ E'\nhv' : Orthonormal ğ•œ â‡‘v'\ne : Equiv Î¹ Î¹'\ni : Î¹\nâŠ¢ Eq ((hv.equiv hv' e) (v i)) (v' (e i))","decl":"@[simp]\ntheorem Orthonormal.equiv_apply {Î¹' : Type*} {v : Basis Î¹ ğ•œ E} (hv : Orthonormal ğ•œ v)\n    {v' : Basis Î¹' ğ•œ E'} (hv' : Orthonormal ğ•œ v') (e : Î¹ â‰ƒ Î¹') (i : Î¹) :\n    hv.equiv hv' e (v i) = v' (e i) :=\n  Basis.equiv_apply _ _ _ _\n\n"}
{"name":"Orthonormal.equiv_trans","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nÎ¹' : Type u_5\nÎ¹'' : Type u_6\nE' : Type u_7\ninstâœÂ³ : SeminormedAddCommGroup E'\ninstâœÂ² : InnerProductSpace ğ•œ E'\nE'' : Type u_8\ninstâœÂ¹ : SeminormedAddCommGroup E''\ninstâœ : InnerProductSpace ğ•œ E''\nv : Basis Î¹ ğ•œ E\nhv : Orthonormal ğ•œ â‡‘v\nv' : Basis Î¹' ğ•œ E'\nhv' : Orthonormal ğ•œ â‡‘v'\ne : Equiv Î¹ Î¹'\nv'' : Basis Î¹'' ğ•œ E''\nhv'' : Orthonormal ğ•œ â‡‘v''\ne' : Equiv Î¹' Î¹''\nâŠ¢ Eq ((hv.equiv hv' e).trans (hv'.equiv hv'' e')) (hv.equiv hv'' (e.trans e'))","decl":"@[simp]\ntheorem Orthonormal.equiv_trans {v : Basis Î¹ ğ•œ E} (hv : Orthonormal ğ•œ v) {v' : Basis Î¹' ğ•œ E'}\n    (hv' : Orthonormal ğ•œ v') (e : Î¹ â‰ƒ Î¹') {v'' : Basis Î¹'' ğ•œ E''} (hv'' : Orthonormal ğ•œ v'')\n    (e' : Î¹' â‰ƒ Î¹'') : (hv.equiv hv' e).trans (hv'.equiv hv'' e') = hv.equiv hv'' (e.trans e') :=\n  v.ext_linearIsometryEquiv fun i => by\n    simp only [LinearIsometryEquiv.trans_apply, Orthonormal.equiv_apply, e.coe_trans,\n      Function.comp_apply]\n\n"}
{"name":"Orthonormal.map_equiv","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nÎ¹' : Type u_5\nE' : Type u_7\ninstâœÂ¹ : SeminormedAddCommGroup E'\ninstâœ : InnerProductSpace ğ•œ E'\nv : Basis Î¹ ğ•œ E\nhv : Orthonormal ğ•œ â‡‘v\nv' : Basis Î¹' ğ•œ E'\nhv' : Orthonormal ğ•œ â‡‘v'\ne : Equiv Î¹ Î¹'\nâŠ¢ Eq (v.map (hv.equiv hv' e).toLinearEquiv) (v'.reindex e.symm)","decl":"theorem Orthonormal.map_equiv {v : Basis Î¹ ğ•œ E} (hv : Orthonormal ğ•œ v) {v' : Basis Î¹' ğ•œ E'}\n    (hv' : Orthonormal ğ•œ v') (e : Î¹ â‰ƒ Î¹') :\n    v.map (hv.equiv hv' e).toLinearEquiv = v'.reindex e.symm :=\n  v.map_equiv _ _\n\n"}
{"name":"Orthonormal.equiv_refl","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nv : Basis Î¹ ğ•œ E\nhv : Orthonormal ğ•œ â‡‘v\nâŠ¢ Eq (hv.equiv hv (Equiv.refl Î¹)) (LinearIsometryEquiv.refl ğ•œ E)","decl":"@[simp]\ntheorem Orthonormal.equiv_refl {v : Basis Î¹ ğ•œ E} (hv : Orthonormal ğ•œ v) :\n    hv.equiv hv (Equiv.refl Î¹) = LinearIsometryEquiv.refl ğ•œ E :=\n  v.ext_linearIsometryEquiv fun i => by\n    simp only [Orthonormal.equiv_apply, Equiv.coe_refl, id, LinearIsometryEquiv.coe_refl]\n\n"}
{"name":"Orthonormal.equiv_symm","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nÎ¹' : Type u_5\nE' : Type u_6\ninstâœÂ¹ : SeminormedAddCommGroup E'\ninstâœ : InnerProductSpace ğ•œ E'\nv : Basis Î¹ ğ•œ E\nhv : Orthonormal ğ•œ â‡‘v\nv' : Basis Î¹' ğ•œ E'\nhv' : Orthonormal ğ•œ â‡‘v'\ne : Equiv Î¹ Î¹'\nâŠ¢ Eq (hv.equiv hv' e).symm (hv'.equiv hv e.symm)","decl":"@[simp]\ntheorem Orthonormal.equiv_symm {v : Basis Î¹ ğ•œ E} (hv : Orthonormal ğ•œ v) {v' : Basis Î¹' ğ•œ E'}\n    (hv' : Orthonormal ğ•œ v') (e : Î¹ â‰ƒ Î¹') : (hv.equiv hv' e).symm = hv'.equiv hv e.symm :=\n  v'.ext_linearIsometryEquiv fun i =>\n    (hv.equiv hv' e).injective <| by\n      simp only [LinearIsometryEquiv.apply_symm_apply, Orthonormal.equiv_apply, e.apply_symm_apply]\n\n"}
{"name":"Orthonormal.sum_inner_products_le","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nx : E\nv : Î¹ â†’ E\ns : Finset Î¹\nhv : Orthonormal ğ•œ v\nâŠ¢ LE.le (s.sum fun i => HPow.hPow (Norm.norm (Inner.inner (v i) x)) 2) (HPow.hPow (Norm.norm x) 2)","decl":"/-- Bessel's inequality for finite sums. -/\ntheorem Orthonormal.sum_inner_products_le {s : Finset Î¹} (hv : Orthonormal ğ•œ v) :\n    âˆ‘ i âˆˆ s, â€–âŸªv i, xâŸ«â€– ^ 2 â‰¤ â€–xâ€– ^ 2 := by\n  have hâ‚‚ :\n    (âˆ‘ i âˆˆ s, âˆ‘ j âˆˆ s, âŸªv i, xâŸ« * âŸªx, v jâŸ« * âŸªv j, v iâŸ«) = (âˆ‘ k âˆˆ s, âŸªv k, xâŸ« * âŸªx, v kâŸ« : ğ•œ) := by\n    classical exact hv.inner_left_right_finset\n  have hâ‚ƒ : âˆ€ z : ğ•œ, re (z * conj z) = â€–zâ€– ^ 2 := by\n    intro z\n    simp only [mul_conj, normSq_eq_def']\n    norm_cast\n  suffices hbf : â€–x - âˆ‘ i âˆˆ s, âŸªv i, xâŸ« â€¢ v iâ€– ^ 2 = â€–xâ€– ^ 2 - âˆ‘ i âˆˆ s, â€–âŸªv i, xâŸ«â€– ^ 2 by\n    rw [â† sub_nonneg, â† hbf]\n    simp only [norm_nonneg, pow_nonneg]\n  rw [@norm_sub_sq ğ•œ, sub_add]\n  simp only [@InnerProductSpace.norm_sq_eq_inner ğ•œ E, inner_sum, sum_inner]\n  simp only [inner_smul_right, two_mul, inner_smul_left, inner_conj_symm, â† mul_assoc, hâ‚‚,\n    add_sub_cancel_right, sub_right_inj]\n  simp only [map_sum, â† inner_conj_symm x, â† hâ‚ƒ]\n\n"}
{"name":"Orthonormal.tsum_inner_products_le","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nx : E\nv : Î¹ â†’ E\nhv : Orthonormal ğ•œ v\nâŠ¢ LE.le (tsum fun i => HPow.hPow (Norm.norm (Inner.inner (v i) x)) 2) (HPow.hPow (Norm.norm x) 2)","decl":"/-- Bessel's inequality. -/\ntheorem Orthonormal.tsum_inner_products_le (hv : Orthonormal ğ•œ v) :\n    âˆ‘' i, â€–âŸªv i, xâŸ«â€– ^ 2 â‰¤ â€–xâ€– ^ 2 := by\n  refine tsum_le_of_sum_le' ?_ fun s => hv.sum_inner_products_le x\n  simp only [norm_nonneg, pow_nonneg]\n\n"}
{"name":"Orthonormal.inner_products_summable","module":"Mathlib.Analysis.InnerProductSpace.Orthonormal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nx : E\nv : Î¹ â†’ E\nhv : Orthonormal ğ•œ v\nâŠ¢ Summable fun i => HPow.hPow (Norm.norm (Inner.inner (v i) x)) 2","decl":"/-- The sum defined in Bessel's inequality is summable. -/\ntheorem Orthonormal.inner_products_summable (hv : Orthonormal ğ•œ v) :\n    Summable fun i => â€–âŸªv i, xâŸ«â€– ^ 2 := by\n  use â¨† s : Finset Î¹, âˆ‘ i âˆˆ s, â€–âŸªv i, xâŸ«â€– ^ 2\n  apply hasSum_of_isLUB_of_nonneg\n  Â· intro b\n    simp only [norm_nonneg, pow_nonneg]\n  Â· refine isLUB_ciSup ?_\n    use â€–xâ€– ^ 2\n    rintro y âŸ¨s, rflâŸ©\n    exact hv.sum_inner_products_le x\n\n"}
