{"name":"List.smul_sum","module":"Mathlib.Algebra.BigOperators.GroupWithZero.Action","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddMonoid β\ninst✝ : DistribSMul α β\nr : α\nl : List β\n⊢ Eq (HSMul.hSMul r l.sum) (List.map (fun x => HSMul.hSMul r x) l).sum","decl":"theorem List.smul_sum {r : α} {l : List β} : r • l.sum = (l.map (r • ·)).sum :=\n  map_list_sum (DistribSMul.toAddMonoidHom β r) l\n\n"}
{"name":"List.smul_prod'","module":"Mathlib.Algebra.BigOperators.GroupWithZero.Action","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Monoid α\ninst✝¹ : Monoid β\ninst✝ : MulDistribMulAction α β\nr : α\nl : List β\n⊢ Eq (HSMul.hSMul r l.prod) (List.map (fun x => HSMul.hSMul r x) l).prod","decl":"theorem List.smul_prod' {r : α} {l : List β} : r • l.prod = (l.map (r • ·)).prod :=\n  map_list_prod (MulDistribMulAction.toMonoidHom β r) l\n\n"}
{"name":"Multiset.smul_sum","module":"Mathlib.Algebra.BigOperators.GroupWithZero.Action","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid β\ninst✝ : DistribSMul α β\nr : α\ns : Multiset β\n⊢ Eq (HSMul.hSMul r s.sum) (Multiset.map (fun x => HSMul.hSMul r x) s).sum","decl":"theorem Multiset.smul_sum {r : α} {s : Multiset β} : r • s.sum = (s.map (r • ·)).sum :=\n  (DistribSMul.toAddMonoidHom β r).map_multiset_sum s\n\n"}
{"name":"Finset.smul_sum","module":"Mathlib.Algebra.BigOperators.GroupWithZero.Action","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : AddCommMonoid β\ninst✝ : DistribSMul α β\nr : α\nf : γ → β\ns : Finset γ\n⊢ Eq (HSMul.hSMul r (s.sum fun x => f x)) (s.sum fun x => HSMul.hSMul r (f x))","decl":"theorem Finset.smul_sum {r : α} {f : γ → β} {s : Finset γ} :\n    (r • ∑ x ∈ s, f x) = ∑ x ∈ s, r • f x :=\n  map_sum (DistribSMul.toAddMonoidHom β r) f s\n\n"}
{"name":"Multiset.smul_prod'","module":"Mathlib.Algebra.BigOperators.GroupWithZero.Action","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Monoid α\ninst✝¹ : CommMonoid β\ninst✝ : MulDistribMulAction α β\nr : α\ns : Multiset β\n⊢ Eq (HSMul.hSMul r s.prod) (Multiset.map (fun x => HSMul.hSMul r x) s).prod","decl":"theorem Multiset.smul_prod' {r : α} {s : Multiset β} : r • s.prod = (s.map (r • ·)).prod :=\n  (MulDistribMulAction.toMonoidHom β r).map_multiset_prod s\n\n"}
{"name":"Finset.smul_prod'","module":"Mathlib.Algebra.BigOperators.GroupWithZero.Action","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : Monoid α\ninst✝¹ : CommMonoid β\ninst✝ : MulDistribMulAction α β\nr : α\nf : γ → β\ns : Finset γ\n⊢ Eq (HSMul.hSMul r (s.prod fun x => f x)) (s.prod fun x => HSMul.hSMul r (f x))","decl":"theorem Finset.smul_prod' {r : α} {f : γ → β} {s : Finset γ} :\n    (r • ∏ x ∈ s, f x) = ∏ x ∈ s, r • f x :=\n  map_prod (MulDistribMulAction.toMonoidHom β r) f s\n\n"}
{"name":"smul_finprod'","module":"Mathlib.Algebra.BigOperators.GroupWithZero.Action","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Monoid α\ninst✝² : CommMonoid β\ninst✝¹ : MulDistribMulAction α β\nι : Sort u_4\ninst✝ : Finite ι\nf : ι → β\nr : α\n⊢ Eq (HSMul.hSMul r (finprod fun x => f x)) (finprod fun x => HSMul.hSMul r (f x))","decl":"theorem smul_finprod' {ι : Sort*} [Finite ι] {f : ι → β} (r : α) :\n    r • ∏ᶠ x : ι, f x = ∏ᶠ x : ι, r • (f x) := by\n  cases nonempty_fintype (PLift ι)\n  simp only [finprod_eq_prod_plift_of_mulSupport_subset (s := Finset.univ) (by simp),\n    finprod_eq_prod_of_fintype, Finset.smul_prod']\n\n"}
{"name":"Finset.smul_prod_perm","module":"Mathlib.Algebra.BigOperators.GroupWithZero.Action","initialProofState":"β : Type u_2\ninst✝³ : CommMonoid β\nG : Type u_4\ninst✝² : Group G\ninst✝¹ : MulDistribMulAction G β\ninst✝ : Fintype G\nb : β\ng : G\n⊢ Eq (HSMul.hSMul g (Finset.univ.prod fun h => HSMul.hSMul h b)) (Finset.univ.prod fun h => HSMul.hSMul h b)","decl":"theorem Finset.smul_prod_perm [Fintype G] (b : β) (g : G) :\n    (g • ∏ h : G, h • b) = ∏ h : G, h • b := by\n  simp only [smul_prod', smul_smul]\n  exact Finset.prod_bijective (g * ·) (Group.mulLeft_bijective g) (by simp) (fun _ _ ↦ rfl)\n\n"}
{"name":"smul_finprod_perm","module":"Mathlib.Algebra.BigOperators.GroupWithZero.Action","initialProofState":"β : Type u_2\ninst✝³ : CommMonoid β\nG : Type u_4\ninst✝² : Group G\ninst✝¹ : MulDistribMulAction G β\ninst✝ : Finite G\nb : β\ng : G\n⊢ Eq (HSMul.hSMul g (finprod fun h => HSMul.hSMul h b)) (finprod fun h => HSMul.hSMul h b)","decl":"theorem smul_finprod_perm [Finite G] (b : β) (g : G) :\n    (g • ∏ᶠ h : G, h • b) = ∏ᶠ h : G, h • b := by\n  cases nonempty_fintype G\n  simp only [finprod_eq_prod_of_fintype, Finset.smul_prod_perm]\n\n"}
{"name":"List.vadd_sum","module":"Mathlib.Algebra.BigOperators.GroupWithZero.Action","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : AddMonoid α\ninst✝³ : AddMonoid β\ninst✝² : AddAction α β\ninst✝¹ : VAddAssocClass α β β\ninst✝ : VAddCommClass α β β\nl : List β\nm : α\n⊢ Eq (HVAdd.hVAdd (HSMul.hSMul l.length m) l.sum) (List.map (fun x => HVAdd.hVAdd m x) l).sum","decl":"@[to_additive]\ntheorem smul_prod [Monoid α] [Monoid β] [MulAction α β] [IsScalarTower α β β] [SMulCommClass α β β]\n    (l : List β) (m : α) :\n    m ^ l.length • l.prod = (l.map (m • ·)).prod := by\n  induction l with\n  | nil => simp\n  | cons head tail ih => simp [← ih, smul_mul_smul_comm, pow_succ']\n\n"}
{"name":"List.smul_prod","module":"Mathlib.Algebra.BigOperators.GroupWithZero.Action","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Monoid α\ninst✝³ : Monoid β\ninst✝² : MulAction α β\ninst✝¹ : IsScalarTower α β β\ninst✝ : SMulCommClass α β β\nl : List β\nm : α\n⊢ Eq (HSMul.hSMul (HPow.hPow m l.length) l.prod) (List.map (fun x => HSMul.hSMul m x) l).prod","decl":"@[to_additive]\ntheorem smul_prod [Monoid α] [Monoid β] [MulAction α β] [IsScalarTower α β β] [SMulCommClass α β β]\n    (l : List β) (m : α) :\n    m ^ l.length • l.prod = (l.map (m • ·)).prod := by\n  induction l with\n  | nil => simp\n  | cons head tail ih => simp [← ih, smul_mul_smul_comm, pow_succ']\n\n"}
{"name":"Multiset.smul_prod","module":"Mathlib.Algebra.BigOperators.GroupWithZero.Action","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Monoid α\ninst✝³ : CommMonoid β\ninst✝² : MulAction α β\ninst✝¹ : IsScalarTower α β β\ninst✝ : SMulCommClass α β β\ns : Multiset β\nb : α\n⊢ Eq (HSMul.hSMul (HPow.hPow b s.card) s.prod) (Multiset.map (fun x => HSMul.hSMul b x) s).prod","decl":"@[to_additive]\ntheorem smul_prod [Monoid α] [CommMonoid β] [MulAction α β] [IsScalarTower α β β]\n    [SMulCommClass α β β] (s : Multiset β) (b : α) :\n    b ^ card s • s.prod = (s.map (b • ·)).prod :=\n  Quot.induction_on s <| by simp [List.smul_prod]\n\n"}
{"name":"Multiset.vadd_sum","module":"Mathlib.Algebra.BigOperators.GroupWithZero.Action","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : AddMonoid α\ninst✝³ : AddCommMonoid β\ninst✝² : AddAction α β\ninst✝¹ : VAddAssocClass α β β\ninst✝ : VAddCommClass α β β\ns : Multiset β\nb : α\n⊢ Eq (HVAdd.hVAdd (HSMul.hSMul s.card b) s.sum) (Multiset.map (fun x => HVAdd.hVAdd b x) s).sum","decl":"@[to_additive]\ntheorem smul_prod [Monoid α] [CommMonoid β] [MulAction α β] [IsScalarTower α β β]\n    [SMulCommClass α β β] (s : Multiset β) (b : α) :\n    b ^ card s • s.prod = (s.map (b • ·)).prod :=\n  Quot.induction_on s <| by simp [List.smul_prod]\n\n"}
{"name":"Finset.smul_prod","module":"Mathlib.Algebra.BigOperators.GroupWithZero.Action","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : CommMonoid β\ninst✝³ : Monoid α\ninst✝² : MulAction α β\ninst✝¹ : IsScalarTower α β β\ninst✝ : SMulCommClass α β β\ns : Finset β\nb : α\nf : β → β\n⊢ Eq (HSMul.hSMul (HPow.hPow b s.card) (s.prod fun x => f x)) (s.prod fun x => HSMul.hSMul b (f x))","decl":"theorem smul_prod\n    [CommMonoid β] [Monoid α] [MulAction α β] [IsScalarTower α β β] [SMulCommClass α β β]\n    (s : Finset β) (b : α) (f : β → β) :\n    b ^ s.card • ∏ x ∈ s, f x = ∏ x ∈ s, b • f x := by\n  have : Multiset.map (fun (x : β) ↦ b • f x) s.val =\n      Multiset.map (fun x ↦ b • x) (Multiset.map f s.val) := by\n    simp only [Multiset.map_map, Function.comp_apply]\n  simp_rw [prod_eq_multiset_prod, card_def, this, ← Multiset.smul_prod _ b, Multiset.card_map]\n\n"}
{"name":"Finset.prod_smul","module":"Mathlib.Algebra.BigOperators.GroupWithZero.Action","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : CommMonoid β\ninst✝³ : CommMonoid α\ninst✝² : MulAction α β\ninst✝¹ : IsScalarTower α β β\ninst✝ : SMulCommClass α β β\ns : Finset β\nb : β → α\nf : β → β\n⊢ Eq (s.prod fun i => HSMul.hSMul (b i) (f i)) (HSMul.hSMul (s.prod fun i => b i) (s.prod fun i => f i))","decl":"theorem prod_smul\n    [CommMonoid β] [CommMonoid α] [MulAction α β] [IsScalarTower α β β] [SMulCommClass α β β]\n    (s : Finset β) (b : β → α) (f : β → β) :\n    ∏ i ∈ s, b i • f i = (∏ i ∈ s, b i) • ∏ i ∈ s, f i := by\n  induction s using Finset.cons_induction_on with\n  | h₁ =>  simp\n  | h₂ hj ih => rw [prod_cons, ih, smul_mul_smul_comm, ← prod_cons hj, ← prod_cons hj]\n\n"}
