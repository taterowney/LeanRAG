{"name":"QuaternionGroup.a.injEq","module":"Mathlib.GroupTheory.SpecificGroups.Quaternion","initialProofState":"n : Nat\na✝¹ a✝ : ZMod (HMul.hMul 2 n)\n⊢ Eq (Eq (QuaternionGroup.a a✝¹) (QuaternionGroup.a a✝)) (Eq a✝¹ a✝)","decl":"/-- The (generalised) quaternion group `QuaternionGroup n` of order `4n`. It can be defined by the\npresentation $\\langle a, x | a^{2n} = 1, x^2 = a^n, x^{-1}ax=a^{-1}\\rangle$. We write `a i` for\n$a^i$ and `xa i` for $x * a^i$.\n-/\ninductive QuaternionGroup (n : ℕ) : Type\n  | a : ZMod (2 * n) → QuaternionGroup n\n  | xa : ZMod (2 * n) → QuaternionGroup n\n  deriving DecidableEq\n\n"}
{"name":"QuaternionGroup.a.inj","module":"Mathlib.GroupTheory.SpecificGroups.Quaternion","initialProofState":"n : Nat\na✝¹ a✝ : ZMod (HMul.hMul 2 n)\nx✝ : Eq (QuaternionGroup.a a✝¹) (QuaternionGroup.a a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- The (generalised) quaternion group `QuaternionGroup n` of order `4n`. It can be defined by the\npresentation $\\langle a, x | a^{2n} = 1, x^2 = a^n, x^{-1}ax=a^{-1}\\rangle$. We write `a i` for\n$a^i$ and `xa i` for $x * a^i$.\n-/\ninductive QuaternionGroup (n : ℕ) : Type\n  | a : ZMod (2 * n) → QuaternionGroup n\n  | xa : ZMod (2 * n) → QuaternionGroup n\n  deriving DecidableEq\n\n"}
{"name":"QuaternionGroup.xa.injEq","module":"Mathlib.GroupTheory.SpecificGroups.Quaternion","initialProofState":"n : Nat\na✝¹ a✝ : ZMod (HMul.hMul 2 n)\n⊢ Eq (Eq (QuaternionGroup.xa a✝¹) (QuaternionGroup.xa a✝)) (Eq a✝¹ a✝)","decl":"/-- The (generalised) quaternion group `QuaternionGroup n` of order `4n`. It can be defined by the\npresentation $\\langle a, x | a^{2n} = 1, x^2 = a^n, x^{-1}ax=a^{-1}\\rangle$. We write `a i` for\n$a^i$ and `xa i` for $x * a^i$.\n-/\ninductive QuaternionGroup (n : ℕ) : Type\n  | a : ZMod (2 * n) → QuaternionGroup n\n  | xa : ZMod (2 * n) → QuaternionGroup n\n  deriving DecidableEq\n\n"}
{"name":"QuaternionGroup.xa.inj","module":"Mathlib.GroupTheory.SpecificGroups.Quaternion","initialProofState":"n : Nat\na✝¹ a✝ : ZMod (HMul.hMul 2 n)\nx✝ : Eq (QuaternionGroup.xa a✝¹) (QuaternionGroup.xa a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- The (generalised) quaternion group `QuaternionGroup n` of order `4n`. It can be defined by the\npresentation $\\langle a, x | a^{2n} = 1, x^2 = a^n, x^{-1}ax=a^{-1}\\rangle$. We write `a i` for\n$a^i$ and `xa i` for $x * a^i$.\n-/\ninductive QuaternionGroup (n : ℕ) : Type\n  | a : ZMod (2 * n) → QuaternionGroup n\n  | xa : ZMod (2 * n) → QuaternionGroup n\n  deriving DecidableEq\n\n"}
{"name":"QuaternionGroup.xa.sizeOf_spec","module":"Mathlib.GroupTheory.SpecificGroups.Quaternion","initialProofState":"n : Nat\na✝ : ZMod (HMul.hMul 2 n)\n⊢ Eq (SizeOf.sizeOf (QuaternionGroup.xa a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- The (generalised) quaternion group `QuaternionGroup n` of order `4n`. It can be defined by the\npresentation $\\langle a, x | a^{2n} = 1, x^2 = a^n, x^{-1}ax=a^{-1}\\rangle$. We write `a i` for\n$a^i$ and `xa i` for $x * a^i$.\n-/\ninductive QuaternionGroup (n : ℕ) : Type\n  | a : ZMod (2 * n) → QuaternionGroup n\n  | xa : ZMod (2 * n) → QuaternionGroup n\n  deriving DecidableEq\n\n"}
{"name":"QuaternionGroup.a.sizeOf_spec","module":"Mathlib.GroupTheory.SpecificGroups.Quaternion","initialProofState":"n : Nat\na✝ : ZMod (HMul.hMul 2 n)\n⊢ Eq (SizeOf.sizeOf (QuaternionGroup.a a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- The (generalised) quaternion group `QuaternionGroup n` of order `4n`. It can be defined by the\npresentation $\\langle a, x | a^{2n} = 1, x^2 = a^n, x^{-1}ax=a^{-1}\\rangle$. We write `a i` for\n$a^i$ and `xa i` for $x * a^i$.\n-/\ninductive QuaternionGroup (n : ℕ) : Type\n  | a : ZMod (2 * n) → QuaternionGroup n\n  | xa : ZMod (2 * n) → QuaternionGroup n\n  deriving DecidableEq\n\n"}
{"name":"QuaternionGroup.a_mul_a","module":"Mathlib.GroupTheory.SpecificGroups.Quaternion","initialProofState":"n : Nat\ni j : ZMod (HMul.hMul 2 n)\n⊢ Eq (HMul.hMul (QuaternionGroup.a i) (QuaternionGroup.a j)) (QuaternionGroup.a (HAdd.hAdd i j))","decl":"@[simp]\ntheorem a_mul_a (i j : ZMod (2 * n)) : a i * a j = a (i + j) :=\n  rfl\n\n"}
{"name":"QuaternionGroup.a_mul_xa","module":"Mathlib.GroupTheory.SpecificGroups.Quaternion","initialProofState":"n : Nat\ni j : ZMod (HMul.hMul 2 n)\n⊢ Eq (HMul.hMul (QuaternionGroup.a i) (QuaternionGroup.xa j)) (QuaternionGroup.xa (HSub.hSub j i))","decl":"@[simp]\ntheorem a_mul_xa (i j : ZMod (2 * n)) : a i * xa j = xa (j - i) :=\n  rfl\n\n"}
{"name":"QuaternionGroup.xa_mul_a","module":"Mathlib.GroupTheory.SpecificGroups.Quaternion","initialProofState":"n : Nat\ni j : ZMod (HMul.hMul 2 n)\n⊢ Eq (HMul.hMul (QuaternionGroup.xa i) (QuaternionGroup.a j)) (QuaternionGroup.xa (HAdd.hAdd i j))","decl":"@[simp]\ntheorem xa_mul_a (i j : ZMod (2 * n)) : xa i * a j = xa (i + j) :=\n  rfl\n\n"}
{"name":"QuaternionGroup.xa_mul_xa","module":"Mathlib.GroupTheory.SpecificGroups.Quaternion","initialProofState":"n : Nat\ni j : ZMod (HMul.hMul 2 n)\n⊢ Eq (HMul.hMul (QuaternionGroup.xa i) (QuaternionGroup.xa j)) (QuaternionGroup.a (HSub.hSub (HAdd.hAdd (↑n) j) i))","decl":"@[simp]\ntheorem xa_mul_xa (i j : ZMod (2 * n)) : xa i * xa j = a ((n : ZMod (2 * n)) + j - i) :=\n  rfl\n\n"}
{"name":"QuaternionGroup.one_def","module":"Mathlib.GroupTheory.SpecificGroups.Quaternion","initialProofState":"n : Nat\n⊢ Eq 1 (QuaternionGroup.a 0)","decl":"theorem one_def : (1 : QuaternionGroup n) = a 0 :=\n  rfl\n\n"}
{"name":"QuaternionGroup.instNontrivial","module":"Mathlib.GroupTheory.SpecificGroups.Quaternion","initialProofState":"n : Nat\n⊢ Nontrivial (QuaternionGroup n)","decl":"instance : Nontrivial (QuaternionGroup n) :=\n  ⟨⟨a 0, xa 0, by revert n; simp⟩⟩ -- Porting note: `revert n; simp` was `decide`\n\n"}
{"name":"QuaternionGroup.card","module":"Mathlib.GroupTheory.SpecificGroups.Quaternion","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ Eq (Fintype.card (QuaternionGroup n)) (HMul.hMul 4 n)","decl":"/-- If `0 < n`, then `QuaternionGroup n` has `4n` elements.\n-/\ntheorem card [NeZero n] : Fintype.card (QuaternionGroup n) = 4 * n := by\n  rw [← Fintype.card_eq.mpr ⟨fintypeHelper⟩, Fintype.card_sum, ZMod.card, two_mul]\n  ring\n\n"}
{"name":"QuaternionGroup.a_one_pow","module":"Mathlib.GroupTheory.SpecificGroups.Quaternion","initialProofState":"n k : Nat\n⊢ Eq (HPow.hPow (QuaternionGroup.a 1) k) (QuaternionGroup.a ↑k)","decl":"@[simp]\ntheorem a_one_pow (k : ℕ) : (a 1 : QuaternionGroup n) ^ k = a k := by\n  induction' k with k IH\n  · rw [Nat.cast_zero]; rfl\n  · rw [pow_succ, IH, a_mul_a]\n    congr 1\n    norm_cast\n\n-- @[simp] -- Porting note: simp changes this to `a 0 = 1`, so this is no longer a good simp lemma.\n"}
{"name":"QuaternionGroup.a_one_pow_n","module":"Mathlib.GroupTheory.SpecificGroups.Quaternion","initialProofState":"n : Nat\n⊢ Eq (HPow.hPow (QuaternionGroup.a 1) (HMul.hMul 2 n)) 1","decl":"theorem a_one_pow_n : (a 1 : QuaternionGroup n) ^ (2 * n) = 1 := by\n  rw [a_one_pow, one_def]\n  congr 1\n  exact ZMod.natCast_self _\n\n"}
{"name":"QuaternionGroup.xa_sq","module":"Mathlib.GroupTheory.SpecificGroups.Quaternion","initialProofState":"n : Nat\ni : ZMod (HMul.hMul 2 n)\n⊢ Eq (HPow.hPow (QuaternionGroup.xa i) 2) (QuaternionGroup.a ↑n)","decl":"@[simp]\ntheorem xa_sq (i : ZMod (2 * n)) : xa i ^ 2 = a n := by simp [sq]\n\n"}
{"name":"QuaternionGroup.xa_pow_four","module":"Mathlib.GroupTheory.SpecificGroups.Quaternion","initialProofState":"n : Nat\ni : ZMod (HMul.hMul 2 n)\n⊢ Eq (HPow.hPow (QuaternionGroup.xa i) 4) 1","decl":"@[simp]\ntheorem xa_pow_four (i : ZMod (2 * n)) : xa i ^ 4 = 1 := by\n  rw [pow_succ, pow_succ, sq, xa_mul_xa, a_mul_xa, xa_mul_xa,\n    add_sub_cancel_right, add_sub_assoc, sub_sub_cancel]\n  norm_cast\n  rw [← two_mul]\n  simp [one_def]\n\n"}
{"name":"QuaternionGroup.orderOf_xa","module":"Mathlib.GroupTheory.SpecificGroups.Quaternion","initialProofState":"n : Nat\ninst✝ : NeZero n\ni : ZMod (HMul.hMul 2 n)\n⊢ Eq (orderOf (QuaternionGroup.xa i)) 4","decl":"/-- If `0 < n`, then `xa i` has order 4.\n-/\n@[simp]\ntheorem orderOf_xa [NeZero n] (i : ZMod (2 * n)) : orderOf (xa i) = 4 := by\n  change _ = 2 ^ 2\n  haveI : Fact (Nat.Prime 2) := Fact.mk Nat.prime_two\n  apply orderOf_eq_prime_pow\n  · intro h\n    simp only [pow_one, xa_sq] at h\n    injection h with h'\n    apply_fun ZMod.val at h'\n    apply_fun (· / n) at h'\n    simp only [ZMod.val_natCast, ZMod.val_zero, Nat.zero_div, Nat.mod_mul_left_div_self,\n      Nat.div_self (NeZero.pos n), reduceCtorEq] at h'\n  · norm_num\n\n"}
{"name":"QuaternionGroup.quaternionGroup_one_isCyclic","module":"Mathlib.GroupTheory.SpecificGroups.Quaternion","initialProofState":"⊢ IsCyclic (QuaternionGroup 1)","decl":"/-- In the special case `n = 1`, `Quaternion 1` is a cyclic group (of order `4`). -/\ntheorem quaternionGroup_one_isCyclic : IsCyclic (QuaternionGroup 1) := by\n  apply isCyclic_of_orderOf_eq_card\n  · rw [Nat.card_eq_fintype_card, card, mul_one]\n    exact orderOf_xa 0\n\n"}
{"name":"QuaternionGroup.orderOf_a_one","module":"Mathlib.GroupTheory.SpecificGroups.Quaternion","initialProofState":"n : Nat\n⊢ Eq (orderOf (QuaternionGroup.a 1)) (HMul.hMul 2 n)","decl":"/-- If `0 < n`, then `a 1` has order `2 * n`.\n-/\n@[simp]\ntheorem orderOf_a_one : orderOf (a 1 : QuaternionGroup n) = 2 * n := by\n  cases' eq_zero_or_neZero n with hn hn\n  · subst hn\n    simp_rw [mul_zero, orderOf_eq_zero_iff']\n    intro n h\n    rw [one_def, a_one_pow]\n    apply mt a.inj\n    haveI : CharZero (ZMod (2 * 0)) := ZMod.charZero\n    simpa using h.ne'\n  apply (Nat.le_of_dvd\n    (NeZero.pos _) (orderOf_dvd_of_pow_eq_one (@a_one_pow_n n))).lt_or_eq.resolve_left\n  intro h\n  have h1 : (a 1 : QuaternionGroup n) ^ orderOf (a 1) = 1 := pow_orderOf_eq_one _\n  rw [a_one_pow] at h1\n  injection h1 with h2\n  rw [← ZMod.val_eq_zero, ZMod.val_natCast, Nat.mod_eq_of_lt h] at h2\n  exact absurd h2.symm (orderOf_pos _).ne\n\n"}
{"name":"QuaternionGroup.orderOf_a","module":"Mathlib.GroupTheory.SpecificGroups.Quaternion","initialProofState":"n : Nat\ninst✝ : NeZero n\ni : ZMod (HMul.hMul 2 n)\n⊢ Eq (orderOf (QuaternionGroup.a i)) (HDiv.hDiv (HMul.hMul 2 n) ((HMul.hMul 2 n).gcd i.val))","decl":"/-- If `0 < n`, then `a i` has order `(2 * n) / gcd (2 * n) i`.\n-/\ntheorem orderOf_a [NeZero n] (i : ZMod (2 * n)) :\n    orderOf (a i) = 2 * n / Nat.gcd (2 * n) i.val := by\n  conv_lhs => rw [← ZMod.natCast_zmod_val i]\n  rw [← a_one_pow, orderOf_pow, orderOf_a_one]\n\n"}
{"name":"QuaternionGroup.exponent","module":"Mathlib.GroupTheory.SpecificGroups.Quaternion","initialProofState":"n : Nat\n⊢ Eq (Monoid.exponent (QuaternionGroup n)) (HMul.hMul 2 (GCDMonoid.lcm n 2))","decl":"theorem exponent : Monoid.exponent (QuaternionGroup n) = 2 * lcm n 2 := by\n  rw [← normalize_eq 2, ← lcm_mul_left, normalize_eq]\n  norm_num\n  cases' eq_zero_or_neZero n with hn hn\n  · subst hn\n    simp only [lcm_zero_left, mul_zero]\n    exact Monoid.exponent_eq_zero_of_order_zero orderOf_a_one\n  apply Nat.dvd_antisymm\n  · apply Monoid.exponent_dvd_of_forall_pow_eq_one\n    rintro (m | m)\n    · rw [← orderOf_dvd_iff_pow_eq_one, orderOf_a]\n      refine Nat.dvd_trans ⟨gcd (2 * n) m.val, ?_⟩ (dvd_lcm_left (2 * n) 4)\n      exact (Nat.div_mul_cancel (Nat.gcd_dvd_left (2 * n) m.val)).symm\n    · rw [← orderOf_dvd_iff_pow_eq_one, orderOf_xa]\n      exact dvd_lcm_right (2 * n) 4\n  · apply lcm_dvd\n    · convert Monoid.order_dvd_exponent (a 1)\n      exact orderOf_a_one.symm\n    · convert Monoid.order_dvd_exponent (xa (0 : ZMod (2 * n)))\n      exact (orderOf_xa 0).symm\n\n"}
