{"name":"MeasurableAdd.measurable_const_add","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\ninst✝¹ : MeasurableSpace M\ninst✝ : Add M\nself : MeasurableAdd M\nc : M\n⊢ Measurable fun x => HAdd.hAdd c x","decl":"/-- We say that a type has `MeasurableAdd` if `(· + c)` and `(· + c)` are measurable functions.\nFor a typeclass assuming measurability of `uncurry (· + ·)` see `MeasurableAdd₂`. -/\nclass MeasurableAdd (M : Type*) [MeasurableSpace M] [Add M] : Prop where\n  measurable_const_add : ∀ c : M, Measurable (c + ·)\n  measurable_add_const : ∀ c : M, Measurable (· + c)\n\n"}
{"name":"MeasurableAdd.measurable_add_const","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\ninst✝¹ : MeasurableSpace M\ninst✝ : Add M\nself : MeasurableAdd M\nc : M\n⊢ Measurable fun x => HAdd.hAdd x c","decl":"/-- We say that a type has `MeasurableAdd` if `(· + c)` and `(· + c)` are measurable functions.\nFor a typeclass assuming measurability of `uncurry (· + ·)` see `MeasurableAdd₂`. -/\nclass MeasurableAdd (M : Type*) [MeasurableSpace M] [Add M] : Prop where\n  measurable_const_add : ∀ c : M, Measurable (c + ·)\n  measurable_add_const : ∀ c : M, Measurable (· + c)\n\n"}
{"name":"MeasurableAdd₂.measurable_add","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\ninst✝¹ : MeasurableSpace M\ninst✝ : Add M\nself : MeasurableAdd₂ M\n⊢ Measurable fun p => HAdd.hAdd p.1 p.2","decl":"/-- We say that a type has `MeasurableAdd₂` if `uncurry (· + ·)` is a measurable functions.\nFor a typeclass assuming measurability of `(c + ·)` and `(· + c)` see `MeasurableAdd`. -/\nclass MeasurableAdd₂ (M : Type*) [MeasurableSpace M] [Add M] : Prop where\n  measurable_add : Measurable fun p : M × M => p.1 + p.2\n\n"}
{"name":"MeasurableMul.measurable_mul_const","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\ninst✝¹ : MeasurableSpace M\ninst✝ : Mul M\nself : MeasurableMul M\nc : M\n⊢ Measurable fun x => HMul.hMul x c","decl":"/-- We say that a type has `MeasurableMul` if `(c * ·)` and `(· * c)` are measurable functions.\nFor a typeclass assuming measurability of `uncurry (*)` see `MeasurableMul₂`. -/\n@[to_additive]\nclass MeasurableMul (M : Type*) [MeasurableSpace M] [Mul M] : Prop where\n  measurable_const_mul : ∀ c : M, Measurable (c * ·)\n  measurable_mul_const : ∀ c : M, Measurable (· * c)\n\n"}
{"name":"MeasurableMul.measurable_const_mul","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\ninst✝¹ : MeasurableSpace M\ninst✝ : Mul M\nself : MeasurableMul M\nc : M\n⊢ Measurable fun x => HMul.hMul c x","decl":"/-- We say that a type has `MeasurableMul` if `(c * ·)` and `(· * c)` are measurable functions.\nFor a typeclass assuming measurability of `uncurry (*)` see `MeasurableMul₂`. -/\n@[to_additive]\nclass MeasurableMul (M : Type*) [MeasurableSpace M] [Mul M] : Prop where\n  measurable_const_mul : ∀ c : M, Measurable (c * ·)\n  measurable_mul_const : ∀ c : M, Measurable (· * c)\n\n"}
{"name":"MeasurableMul₂.measurable_mul","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\ninst✝¹ : MeasurableSpace M\ninst✝ : Mul M\nself : MeasurableMul₂ M\n⊢ Measurable fun p => HMul.hMul p.1 p.2","decl":"/-- We say that a type has `MeasurableMul₂` if `uncurry (· * ·)` is a measurable functions.\nFor a typeclass assuming measurability of `(c * ·)` and `(· * c)` see `MeasurableMul`. -/\n@[to_additive MeasurableAdd₂]\nclass MeasurableMul₂ (M : Type*) [MeasurableSpace M] [Mul M] : Prop where\n  measurable_mul : Measurable fun p : M × M => p.1 * p.2\n\n"}
{"name":"Measurable.const_mul","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\ninst✝² : MeasurableSpace M\ninst✝¹ : Mul M\nm : MeasurableSpace α\nf : α → M\ninst✝ : MeasurableMul M\nhf : Measurable f\nc : M\n⊢ Measurable fun x => HMul.hMul c (f x)","decl":"@[to_additive (attr := fun_prop, measurability)]\ntheorem Measurable.const_mul [MeasurableMul M] (hf : Measurable f) (c : M) :\n    Measurable fun x => c * f x :=\n  (measurable_const_mul c).comp hf\n\n"}
{"name":"Measurable.const_add","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\ninst✝² : MeasurableSpace M\ninst✝¹ : Add M\nm : MeasurableSpace α\nf : α → M\ninst✝ : MeasurableAdd M\nhf : Measurable f\nc : M\n⊢ Measurable fun x => HAdd.hAdd c (f x)","decl":"@[to_additive (attr := fun_prop, measurability)]\ntheorem Measurable.const_mul [MeasurableMul M] (hf : Measurable f) (c : M) :\n    Measurable fun x => c * f x :=\n  (measurable_const_mul c).comp hf\n\n"}
{"name":"AEMeasurable.const_add","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\ninst✝² : MeasurableSpace M\ninst✝¹ : Add M\nm : MeasurableSpace α\nf : α → M\nμ : MeasureTheory.Measure α\ninst✝ : MeasurableAdd M\nhf : AEMeasurable f μ\nc : M\n⊢ AEMeasurable (fun x => HAdd.hAdd c (f x)) μ","decl":"@[to_additive (attr := measurability)]\ntheorem AEMeasurable.const_mul [MeasurableMul M] (hf : AEMeasurable f μ) (c : M) :\n    AEMeasurable (fun x => c * f x) μ :=\n  (MeasurableMul.measurable_const_mul c).comp_aemeasurable hf\n\n"}
{"name":"AEMeasurable.const_mul","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\ninst✝² : MeasurableSpace M\ninst✝¹ : Mul M\nm : MeasurableSpace α\nf : α → M\nμ : MeasureTheory.Measure α\ninst✝ : MeasurableMul M\nhf : AEMeasurable f μ\nc : M\n⊢ AEMeasurable (fun x => HMul.hMul c (f x)) μ","decl":"@[to_additive (attr := measurability)]\ntheorem AEMeasurable.const_mul [MeasurableMul M] (hf : AEMeasurable f μ) (c : M) :\n    AEMeasurable (fun x => c * f x) μ :=\n  (MeasurableMul.measurable_const_mul c).comp_aemeasurable hf\n\n"}
{"name":"Measurable.mul_const","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\ninst✝² : MeasurableSpace M\ninst✝¹ : Mul M\nm : MeasurableSpace α\nf : α → M\ninst✝ : MeasurableMul M\nhf : Measurable f\nc : M\n⊢ Measurable fun x => HMul.hMul (f x) c","decl":"@[to_additive (attr := measurability)]\ntheorem Measurable.mul_const [MeasurableMul M] (hf : Measurable f) (c : M) :\n    Measurable fun x => f x * c :=\n  (measurable_mul_const c).comp hf\n\n"}
{"name":"Measurable.add_const","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\ninst✝² : MeasurableSpace M\ninst✝¹ : Add M\nm : MeasurableSpace α\nf : α → M\ninst✝ : MeasurableAdd M\nhf : Measurable f\nc : M\n⊢ Measurable fun x => HAdd.hAdd (f x) c","decl":"@[to_additive (attr := measurability)]\ntheorem Measurable.mul_const [MeasurableMul M] (hf : Measurable f) (c : M) :\n    Measurable fun x => f x * c :=\n  (measurable_mul_const c).comp hf\n\n"}
{"name":"AEMeasurable.add_const","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\ninst✝² : MeasurableSpace M\ninst✝¹ : Add M\nm : MeasurableSpace α\nf : α → M\nμ : MeasureTheory.Measure α\ninst✝ : MeasurableAdd M\nhf : AEMeasurable f μ\nc : M\n⊢ AEMeasurable (fun x => HAdd.hAdd (f x) c) μ","decl":"@[to_additive (attr := measurability)]\ntheorem AEMeasurable.mul_const [MeasurableMul M] (hf : AEMeasurable f μ) (c : M) :\n    AEMeasurable (fun x => f x * c) μ :=\n  (measurable_mul_const c).comp_aemeasurable hf\n\n"}
{"name":"AEMeasurable.mul_const","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\ninst✝² : MeasurableSpace M\ninst✝¹ : Mul M\nm : MeasurableSpace α\nf : α → M\nμ : MeasureTheory.Measure α\ninst✝ : MeasurableMul M\nhf : AEMeasurable f μ\nc : M\n⊢ AEMeasurable (fun x => HMul.hMul (f x) c) μ","decl":"@[to_additive (attr := measurability)]\ntheorem AEMeasurable.mul_const [MeasurableMul M] (hf : AEMeasurable f μ) (c : M) :\n    AEMeasurable (fun x => f x * c) μ :=\n  (measurable_mul_const c).comp_aemeasurable hf\n\n"}
{"name":"Measurable.add","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\ninst✝² : MeasurableSpace M\ninst✝¹ : Add M\nm : MeasurableSpace α\nf g : α → M\ninst✝ : MeasurableAdd₂ M\nhf : Measurable f\nhg : Measurable g\n⊢ Measurable fun a => HAdd.hAdd (f a) (g a)","decl":"@[to_additive (attr := fun_prop, aesop safe 20 apply (rule_sets := [Measurable]))]\ntheorem Measurable.mul [MeasurableMul₂ M] (hf : Measurable f) (hg : Measurable g) :\n    Measurable fun a => f a * g a :=\n  measurable_mul.comp (hf.prod_mk hg)\n\n"}
{"name":"Measurable.mul","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\ninst✝² : MeasurableSpace M\ninst✝¹ : Mul M\nm : MeasurableSpace α\nf g : α → M\ninst✝ : MeasurableMul₂ M\nhf : Measurable f\nhg : Measurable g\n⊢ Measurable fun a => HMul.hMul (f a) (g a)","decl":"@[to_additive (attr := fun_prop, aesop safe 20 apply (rule_sets := [Measurable]))]\ntheorem Measurable.mul [MeasurableMul₂ M] (hf : Measurable f) (hg : Measurable g) :\n    Measurable fun a => f a * g a :=\n  measurable_mul.comp (hf.prod_mk hg)\n\n"}
{"name":"Measurable.mul'","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝² : MeasurableSpace M\ninst✝¹ : Mul M\nm : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝ : MeasurableMul₂ M\nf g : α → β → M\nh : α → β\nhf : Measurable (Function.HasUncurry.uncurry f)\nhg : Measurable (Function.HasUncurry.uncurry g)\nhh : Measurable h\n⊢ Measurable fun a => HMul.hMul (f a) (g a) (h a)","decl":"/-- Compositional version of `Measurable.mul` for use by `fun_prop`. -/\n@[to_additive (attr := fun_prop, aesop safe 20 apply (rule_sets := [Measurable]))\n\"Compositional version of `Measurable.add` for use by `fun_prop`.\"]\nlemma Measurable.mul' [MeasurableMul₂ M] {f g : α → β → M} {h : α → β} (hf : Measurable ↿f)\n    (hg : Measurable ↿g) (hh : Measurable h) : Measurable fun a ↦ (f a * g a) (h a) := by\n  simp; fun_prop\n\n"}
{"name":"Measurable.add'","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝² : MeasurableSpace M\ninst✝¹ : Add M\nm : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝ : MeasurableAdd₂ M\nf g : α → β → M\nh : α → β\nhf : Measurable (Function.HasUncurry.uncurry f)\nhg : Measurable (Function.HasUncurry.uncurry g)\nhh : Measurable h\n⊢ Measurable fun a => HAdd.hAdd (f a) (g a) (h a)","decl":"/-- Compositional version of `Measurable.mul` for use by `fun_prop`. -/\n@[to_additive (attr := fun_prop, aesop safe 20 apply (rule_sets := [Measurable]))\n\"Compositional version of `Measurable.add` for use by `fun_prop`.\"]\nlemma Measurable.mul' [MeasurableMul₂ M] {f g : α → β → M} {h : α → β} (hf : Measurable ↿f)\n    (hg : Measurable ↿g) (hh : Measurable h) : Measurable fun a ↦ (f a * g a) (h a) := by\n  simp; fun_prop\n\n"}
{"name":"AEMeasurable.mul'","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\ninst✝² : MeasurableSpace M\ninst✝¹ : Mul M\nm : MeasurableSpace α\nf g : α → M\nμ : MeasureTheory.Measure α\ninst✝ : MeasurableMul₂ M\nhf : AEMeasurable f μ\nhg : AEMeasurable g μ\n⊢ AEMeasurable (HMul.hMul f g) μ","decl":"@[to_additive (attr := fun_prop, aesop safe 20 apply (rule_sets := [Measurable]))]\ntheorem AEMeasurable.mul' [MeasurableMul₂ M] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    AEMeasurable (f * g) μ :=\n  measurable_mul.comp_aemeasurable (hf.prod_mk hg)\n\n"}
{"name":"AEMeasurable.add'","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\ninst✝² : MeasurableSpace M\ninst✝¹ : Add M\nm : MeasurableSpace α\nf g : α → M\nμ : MeasureTheory.Measure α\ninst✝ : MeasurableAdd₂ M\nhf : AEMeasurable f μ\nhg : AEMeasurable g μ\n⊢ AEMeasurable (HAdd.hAdd f g) μ","decl":"@[to_additive (attr := fun_prop, aesop safe 20 apply (rule_sets := [Measurable]))]\ntheorem AEMeasurable.mul' [MeasurableMul₂ M] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    AEMeasurable (f * g) μ :=\n  measurable_mul.comp_aemeasurable (hf.prod_mk hg)\n\n"}
{"name":"AEMeasurable.mul","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\ninst✝² : MeasurableSpace M\ninst✝¹ : Mul M\nm : MeasurableSpace α\nf g : α → M\nμ : MeasureTheory.Measure α\ninst✝ : MeasurableMul₂ M\nhf : AEMeasurable f μ\nhg : AEMeasurable g μ\n⊢ AEMeasurable (fun a => HMul.hMul (f a) (g a)) μ","decl":"@[to_additive (attr := fun_prop, aesop safe 20 apply (rule_sets := [Measurable]))]\ntheorem AEMeasurable.mul [MeasurableMul₂ M] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    AEMeasurable (fun a => f a * g a) μ :=\n  measurable_mul.comp_aemeasurable (hf.prod_mk hg)\n\n"}
{"name":"AEMeasurable.add","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\ninst✝² : MeasurableSpace M\ninst✝¹ : Add M\nm : MeasurableSpace α\nf g : α → M\nμ : MeasureTheory.Measure α\ninst✝ : MeasurableAdd₂ M\nhf : AEMeasurable f μ\nhg : AEMeasurable g μ\n⊢ AEMeasurable (fun a => HAdd.hAdd (f a) (g a)) μ","decl":"@[to_additive (attr := fun_prop, aesop safe 20 apply (rule_sets := [Measurable]))]\ntheorem AEMeasurable.mul [MeasurableMul₂ M] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    AEMeasurable (fun a => f a * g a) μ :=\n  measurable_mul.comp_aemeasurable (hf.prod_mk hg)\n\n"}
{"name":"MeasurableMul₂.toMeasurableMul","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\ninst✝² : MeasurableSpace M\ninst✝¹ : Mul M\ninst✝ : MeasurableMul₂ M\n⊢ MeasurableMul M","decl":"@[to_additive]\ninstance (priority := 100) MeasurableMul₂.toMeasurableMul [MeasurableMul₂ M] :\n    MeasurableMul M :=\n  ⟨fun _ => measurable_const.mul measurable_id, fun _ => measurable_id.mul measurable_const⟩\n\n"}
{"name":"MeasurableAdd₂.toMeasurableAdd","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\ninst✝² : MeasurableSpace M\ninst✝¹ : Add M\ninst✝ : MeasurableAdd₂ M\n⊢ MeasurableAdd M","decl":"@[to_additive]\ninstance (priority := 100) MeasurableMul₂.toMeasurableMul [MeasurableMul₂ M] :\n    MeasurableMul M :=\n  ⟨fun _ => measurable_const.mul measurable_id, fun _ => measurable_id.mul measurable_const⟩\n\n"}
{"name":"Pi.measurableAdd","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"ι : Type u_5\nα : ι → Type u_6\ninst✝² : (i : ι) → Add (α i)\ninst✝¹ : (i : ι) → MeasurableSpace (α i)\ninst✝ : ∀ (i : ι), MeasurableAdd (α i)\n⊢ MeasurableAdd ((i : ι) → α i)","decl":"@[to_additive]\ninstance Pi.measurableMul {ι : Type*} {α : ι → Type*} [∀ i, Mul (α i)]\n    [∀ i, MeasurableSpace (α i)] [∀ i, MeasurableMul (α i)] : MeasurableMul (∀ i, α i) :=\n  ⟨fun _ => measurable_pi_iff.mpr fun i => (measurable_pi_apply i).const_mul _, fun _ =>\n    measurable_pi_iff.mpr fun i => (measurable_pi_apply i).mul_const _⟩\n\n"}
{"name":"Pi.measurableMul","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"ι : Type u_5\nα : ι → Type u_6\ninst✝² : (i : ι) → Mul (α i)\ninst✝¹ : (i : ι) → MeasurableSpace (α i)\ninst✝ : ∀ (i : ι), MeasurableMul (α i)\n⊢ MeasurableMul ((i : ι) → α i)","decl":"@[to_additive]\ninstance Pi.measurableMul {ι : Type*} {α : ι → Type*} [∀ i, Mul (α i)]\n    [∀ i, MeasurableSpace (α i)] [∀ i, MeasurableMul (α i)] : MeasurableMul (∀ i, α i) :=\n  ⟨fun _ => measurable_pi_iff.mpr fun i => (measurable_pi_apply i).const_mul _, fun _ =>\n    measurable_pi_iff.mpr fun i => (measurable_pi_apply i).mul_const _⟩\n\n"}
{"name":"Pi.measurableMul₂","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"ι : Type u_5\nα : ι → Type u_6\ninst✝² : (i : ι) → Mul (α i)\ninst✝¹ : (i : ι) → MeasurableSpace (α i)\ninst✝ : ∀ (i : ι), MeasurableMul₂ (α i)\n⊢ MeasurableMul₂ ((i : ι) → α i)","decl":"@[to_additive Pi.measurableAdd₂]\ninstance Pi.measurableMul₂ {ι : Type*} {α : ι → Type*} [∀ i, Mul (α i)]\n    [∀ i, MeasurableSpace (α i)] [∀ i, MeasurableMul₂ (α i)] : MeasurableMul₂ (∀ i, α i) :=\n  ⟨measurable_pi_iff.mpr fun _ => measurable_fst.eval.mul measurable_snd.eval⟩\n\n"}
{"name":"Pi.measurableAdd₂","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"ι : Type u_5\nα : ι → Type u_6\ninst✝² : (i : ι) → Add (α i)\ninst✝¹ : (i : ι) → MeasurableSpace (α i)\ninst✝ : ∀ (i : ι), MeasurableAdd₂ (α i)\n⊢ MeasurableAdd₂ ((i : ι) → α i)","decl":"@[to_additive Pi.measurableAdd₂]\ninstance Pi.measurableMul₂ {ι : Type*} {α : ι → Type*} [∀ i, Mul (α i)]\n    [∀ i, MeasurableSpace (α i)] [∀ i, MeasurableMul₂ (α i)] : MeasurableMul₂ (∀ i, α i) :=\n  ⟨measurable_pi_iff.mpr fun _ => measurable_fst.eval.mul measurable_snd.eval⟩\n\n"}
{"name":"measurable_sub_const'","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\ninst✝² : SubNegMonoid G\ninst✝¹ : MeasurableSpace G\ninst✝ : MeasurableAdd G\ng : G\n⊢ Measurable fun h => HSub.hSub h g","decl":"/-- A version of `measurable_div_const` that assumes `MeasurableMul` instead of\n  `MeasurableDiv`. This can be nice to avoid unnecessary type-class assumptions. -/\n@[to_additive \" A version of `measurable_sub_const` that assumes `MeasurableAdd` instead of\n  `MeasurableSub`. This can be nice to avoid unnecessary type-class assumptions. \"]\ntheorem measurable_div_const' {G : Type*} [DivInvMonoid G] [MeasurableSpace G] [MeasurableMul G]\n    (g : G) : Measurable fun h => h / g := by simp_rw [div_eq_mul_inv, measurable_mul_const]\n\n"}
{"name":"measurable_div_const'","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\ninst✝² : DivInvMonoid G\ninst✝¹ : MeasurableSpace G\ninst✝ : MeasurableMul G\ng : G\n⊢ Measurable fun h => HDiv.hDiv h g","decl":"/-- A version of `measurable_div_const` that assumes `MeasurableMul` instead of\n  `MeasurableDiv`. This can be nice to avoid unnecessary type-class assumptions. -/\n@[to_additive \" A version of `measurable_sub_const` that assumes `MeasurableAdd` instead of\n  `MeasurableSub`. This can be nice to avoid unnecessary type-class assumptions. \"]\ntheorem measurable_div_const' {G : Type*} [DivInvMonoid G] [MeasurableSpace G] [MeasurableMul G]\n    (g : G) : Measurable fun h => h / g := by simp_rw [div_eq_mul_inv, measurable_mul_const]\n\n"}
{"name":"MeasurablePow.measurable_pow","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"β : Type u_2\nγ : Type u_3\ninst✝² : MeasurableSpace β\ninst✝¹ : MeasurableSpace γ\ninst✝ : Pow β γ\nself : MeasurablePow β γ\n⊢ Measurable fun p => HPow.hPow p.1 p.2","decl":"/-- This class assumes that the map `β × γ → β` given by `(x, y) ↦ x ^ y` is measurable. -/\nclass MeasurablePow (β γ : Type*) [MeasurableSpace β] [MeasurableSpace γ] [Pow β γ] : Prop where\n  measurable_pow : Measurable fun p : β × γ => p.1 ^ p.2\n\n"}
{"name":"Monoid.measurablePow","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\ninst✝² : Monoid M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableMul₂ M\n⊢ MeasurablePow M Nat","decl":"/-- `Monoid.Pow` is measurable. -/\ninstance Monoid.measurablePow (M : Type*) [Monoid M] [MeasurableSpace M] [MeasurableMul₂ M] :\n    MeasurablePow M ℕ :=\n  ⟨measurable_from_prod_countable fun n => by\n      induction' n with n ih\n      · simp only [pow_zero, ← Pi.one_def, measurable_one]\n      · simp only [pow_succ]\n        exact ih.mul measurable_id⟩\n\n"}
{"name":"Measurable.pow","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"β : Type u_2\nγ : Type u_3\nα : Type u_4\ninst✝³ : MeasurableSpace β\ninst✝² : MeasurableSpace γ\ninst✝¹ : Pow β γ\ninst✝ : MeasurablePow β γ\nm : MeasurableSpace α\nf : α → β\ng : α → γ\nhf : Measurable f\nhg : Measurable g\n⊢ Measurable fun x => HPow.hPow (f x) (g x)","decl":"@[aesop safe 20 apply (rule_sets := [Measurable])]\ntheorem Measurable.pow (hf : Measurable f) (hg : Measurable g) : Measurable fun x => f x ^ g x :=\n  measurable_pow.comp (hf.prod_mk hg)\n\n"}
{"name":"AEMeasurable.pow","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"β : Type u_2\nγ : Type u_3\nα : Type u_4\ninst✝³ : MeasurableSpace β\ninst✝² : MeasurableSpace γ\ninst✝¹ : Pow β γ\ninst✝ : MeasurablePow β γ\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → β\ng : α → γ\nhf : AEMeasurable f μ\nhg : AEMeasurable g μ\n⊢ AEMeasurable (fun x => HPow.hPow (f x) (g x)) μ","decl":"@[aesop safe 20 apply (rule_sets := [Measurable])]\ntheorem AEMeasurable.pow (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    AEMeasurable (fun x => f x ^ g x) μ :=\n  measurable_pow.comp_aemeasurable (hf.prod_mk hg)\n\n"}
{"name":"Measurable.pow_const","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"β : Type u_2\nγ : Type u_3\nα : Type u_4\ninst✝³ : MeasurableSpace β\ninst✝² : MeasurableSpace γ\ninst✝¹ : Pow β γ\ninst✝ : MeasurablePow β γ\nm : MeasurableSpace α\nf : α → β\nhf : Measurable f\nc : γ\n⊢ Measurable fun x => HPow.hPow (f x) c","decl":"@[fun_prop, measurability]\ntheorem Measurable.pow_const (hf : Measurable f) (c : γ) : Measurable fun x => f x ^ c :=\n  hf.pow measurable_const\n\n"}
{"name":"AEMeasurable.pow_const","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"β : Type u_2\nγ : Type u_3\nα : Type u_4\ninst✝³ : MeasurableSpace β\ninst✝² : MeasurableSpace γ\ninst✝¹ : Pow β γ\ninst✝ : MeasurablePow β γ\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → β\nhf : AEMeasurable f μ\nc : γ\n⊢ AEMeasurable (fun x => HPow.hPow (f x) c) μ","decl":"@[fun_prop, measurability]\ntheorem AEMeasurable.pow_const (hf : AEMeasurable f μ) (c : γ) :\n    AEMeasurable (fun x => f x ^ c) μ :=\n  hf.pow aemeasurable_const\n\n"}
{"name":"Measurable.const_pow","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"β : Type u_2\nγ : Type u_3\nα : Type u_4\ninst✝³ : MeasurableSpace β\ninst✝² : MeasurableSpace γ\ninst✝¹ : Pow β γ\ninst✝ : MeasurablePow β γ\nm : MeasurableSpace α\ng : α → γ\nhg : Measurable g\nc : β\n⊢ Measurable fun x => HPow.hPow c (g x)","decl":"@[measurability]\ntheorem Measurable.const_pow (hg : Measurable g) (c : β) : Measurable fun x => c ^ g x :=\n  measurable_const.pow hg\n\n"}
{"name":"AEMeasurable.const_pow","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"β : Type u_2\nγ : Type u_3\nα : Type u_4\ninst✝³ : MeasurableSpace β\ninst✝² : MeasurableSpace γ\ninst✝¹ : Pow β γ\ninst✝ : MeasurablePow β γ\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ng : α → γ\nhg : AEMeasurable g μ\nc : β\n⊢ AEMeasurable (fun x => HPow.hPow c (g x)) μ","decl":"@[measurability]\ntheorem AEMeasurable.const_pow (hg : AEMeasurable g μ) (c : β) :\n    AEMeasurable (fun x => c ^ g x) μ :=\n  aemeasurable_const.pow hg\n\n"}
{"name":"MeasurableSub.measurable_const_sub","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\ninst✝¹ : MeasurableSpace G\ninst✝ : Sub G\nself : MeasurableSub G\nc : G\n⊢ Measurable fun x => HSub.hSub c x","decl":"/-- We say that a type has `MeasurableSub` if `(c - ·)` and `(· - c)` are measurable\nfunctions. For a typeclass assuming measurability of `uncurry (-)` see `MeasurableSub₂`. -/\nclass MeasurableSub (G : Type*) [MeasurableSpace G] [Sub G] : Prop where\n  measurable_const_sub : ∀ c : G, Measurable (c - ·)\n  measurable_sub_const : ∀ c : G, Measurable (· - c)\n\n"}
{"name":"MeasurableSub.measurable_sub_const","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\ninst✝¹ : MeasurableSpace G\ninst✝ : Sub G\nself : MeasurableSub G\nc : G\n⊢ Measurable fun x => HSub.hSub x c","decl":"/-- We say that a type has `MeasurableSub` if `(c - ·)` and `(· - c)` are measurable\nfunctions. For a typeclass assuming measurability of `uncurry (-)` see `MeasurableSub₂`. -/\nclass MeasurableSub (G : Type*) [MeasurableSpace G] [Sub G] : Prop where\n  measurable_const_sub : ∀ c : G, Measurable (c - ·)\n  measurable_sub_const : ∀ c : G, Measurable (· - c)\n\n"}
{"name":"MeasurableSub₂.measurable_sub","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\ninst✝¹ : MeasurableSpace G\ninst✝ : Sub G\nself : MeasurableSub₂ G\n⊢ Measurable fun p => HSub.hSub p.1 p.2","decl":"/-- We say that a type has `MeasurableSub₂` if `uncurry (· - ·)` is a measurable functions.\nFor a typeclass assuming measurability of `(c - ·)` and `(· - c)` see `MeasurableSub`. -/\nclass MeasurableSub₂ (G : Type*) [MeasurableSpace G] [Sub G] : Prop where\n  measurable_sub : Measurable fun p : G × G => p.1 - p.2\n\n"}
{"name":"MeasurableDiv.measurable_div_const","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G₀ : Type u_2\ninst✝¹ : MeasurableSpace G₀\ninst✝ : Div G₀\nself : MeasurableDiv G₀\nc : G₀\n⊢ Measurable fun x => HDiv.hDiv x c","decl":"/-- We say that a type has `MeasurableDiv` if `(c / ·)` and `(· / c)` are measurable functions.\nFor a typeclass assuming measurability of `uncurry (· / ·)` see `MeasurableDiv₂`. -/\n@[to_additive]\nclass MeasurableDiv (G₀ : Type*) [MeasurableSpace G₀] [Div G₀] : Prop where\n  measurable_const_div : ∀ c : G₀, Measurable (c / ·)\n  measurable_div_const : ∀ c : G₀, Measurable (· / c)\n\n"}
{"name":"MeasurableDiv.measurable_const_div","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G₀ : Type u_2\ninst✝¹ : MeasurableSpace G₀\ninst✝ : Div G₀\nself : MeasurableDiv G₀\nc : G₀\n⊢ Measurable fun x => HDiv.hDiv c x","decl":"/-- We say that a type has `MeasurableDiv` if `(c / ·)` and `(· / c)` are measurable functions.\nFor a typeclass assuming measurability of `uncurry (· / ·)` see `MeasurableDiv₂`. -/\n@[to_additive]\nclass MeasurableDiv (G₀ : Type*) [MeasurableSpace G₀] [Div G₀] : Prop where\n  measurable_const_div : ∀ c : G₀, Measurable (c / ·)\n  measurable_div_const : ∀ c : G₀, Measurable (· / c)\n\n"}
{"name":"MeasurableDiv₂.measurable_div","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G₀ : Type u_2\ninst✝¹ : MeasurableSpace G₀\ninst✝ : Div G₀\nself : MeasurableDiv₂ G₀\n⊢ Measurable fun p => HDiv.hDiv p.1 p.2","decl":"/-- We say that a type has `MeasurableDiv₂` if `uncurry (· / ·)` is a measurable functions.\nFor a typeclass assuming measurability of `(c / ·)` and `(· / c)` see `MeasurableDiv`. -/\n@[to_additive MeasurableSub₂]\nclass MeasurableDiv₂ (G₀ : Type*) [MeasurableSpace G₀] [Div G₀] : Prop where\n  measurable_div : Measurable fun p : G₀ × G₀ => p.1 / p.2\n\n"}
{"name":"Measurable.const_sub","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\nα : Type u_3\ninst✝² : MeasurableSpace G\ninst✝¹ : Sub G\nm : MeasurableSpace α\nf : α → G\ninst✝ : MeasurableSub G\nhf : Measurable f\nc : G\n⊢ Measurable fun x => HSub.hSub c (f x)","decl":"@[to_additive (attr := measurability)]\ntheorem Measurable.const_div [MeasurableDiv G] (hf : Measurable f) (c : G) :\n    Measurable fun x => c / f x :=\n  (MeasurableDiv.measurable_const_div c).comp hf\n\n"}
{"name":"Measurable.const_div","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\nα : Type u_3\ninst✝² : MeasurableSpace G\ninst✝¹ : Div G\nm : MeasurableSpace α\nf : α → G\ninst✝ : MeasurableDiv G\nhf : Measurable f\nc : G\n⊢ Measurable fun x => HDiv.hDiv c (f x)","decl":"@[to_additive (attr := measurability)]\ntheorem Measurable.const_div [MeasurableDiv G] (hf : Measurable f) (c : G) :\n    Measurable fun x => c / f x :=\n  (MeasurableDiv.measurable_const_div c).comp hf\n\n"}
{"name":"AEMeasurable.const_sub","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\nα : Type u_3\ninst✝² : MeasurableSpace G\ninst✝¹ : Sub G\nm : MeasurableSpace α\nf : α → G\nμ : MeasureTheory.Measure α\ninst✝ : MeasurableSub G\nhf : AEMeasurable f μ\nc : G\n⊢ AEMeasurable (fun x => HSub.hSub c (f x)) μ","decl":"@[to_additive (attr := measurability)]\ntheorem AEMeasurable.const_div [MeasurableDiv G] (hf : AEMeasurable f μ) (c : G) :\n    AEMeasurable (fun x => c / f x) μ :=\n  (MeasurableDiv.measurable_const_div c).comp_aemeasurable hf\n\n"}
{"name":"AEMeasurable.const_div","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\nα : Type u_3\ninst✝² : MeasurableSpace G\ninst✝¹ : Div G\nm : MeasurableSpace α\nf : α → G\nμ : MeasureTheory.Measure α\ninst✝ : MeasurableDiv G\nhf : AEMeasurable f μ\nc : G\n⊢ AEMeasurable (fun x => HDiv.hDiv c (f x)) μ","decl":"@[to_additive (attr := measurability)]\ntheorem AEMeasurable.const_div [MeasurableDiv G] (hf : AEMeasurable f μ) (c : G) :\n    AEMeasurable (fun x => c / f x) μ :=\n  (MeasurableDiv.measurable_const_div c).comp_aemeasurable hf\n\n"}
{"name":"Measurable.sub_const","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\nα : Type u_3\ninst✝² : MeasurableSpace G\ninst✝¹ : Sub G\nm : MeasurableSpace α\nf : α → G\ninst✝ : MeasurableSub G\nhf : Measurable f\nc : G\n⊢ Measurable fun x => HSub.hSub (f x) c","decl":"@[to_additive (attr := measurability)]\ntheorem Measurable.div_const [MeasurableDiv G] (hf : Measurable f) (c : G) :\n    Measurable fun x => f x / c :=\n  (MeasurableDiv.measurable_div_const c).comp hf\n\n"}
{"name":"Measurable.div_const","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\nα : Type u_3\ninst✝² : MeasurableSpace G\ninst✝¹ : Div G\nm : MeasurableSpace α\nf : α → G\ninst✝ : MeasurableDiv G\nhf : Measurable f\nc : G\n⊢ Measurable fun x => HDiv.hDiv (f x) c","decl":"@[to_additive (attr := measurability)]\ntheorem Measurable.div_const [MeasurableDiv G] (hf : Measurable f) (c : G) :\n    Measurable fun x => f x / c :=\n  (MeasurableDiv.measurable_div_const c).comp hf\n\n"}
{"name":"AEMeasurable.sub_const","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\nα : Type u_3\ninst✝² : MeasurableSpace G\ninst✝¹ : Sub G\nm : MeasurableSpace α\nf : α → G\nμ : MeasureTheory.Measure α\ninst✝ : MeasurableSub G\nhf : AEMeasurable f μ\nc : G\n⊢ AEMeasurable (fun x => HSub.hSub (f x) c) μ","decl":"@[to_additive (attr := measurability)]\ntheorem AEMeasurable.div_const [MeasurableDiv G] (hf : AEMeasurable f μ) (c : G) :\n    AEMeasurable (fun x => f x / c) μ :=\n  (MeasurableDiv.measurable_div_const c).comp_aemeasurable hf\n\n"}
{"name":"AEMeasurable.div_const","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\nα : Type u_3\ninst✝² : MeasurableSpace G\ninst✝¹ : Div G\nm : MeasurableSpace α\nf : α → G\nμ : MeasureTheory.Measure α\ninst✝ : MeasurableDiv G\nhf : AEMeasurable f μ\nc : G\n⊢ AEMeasurable (fun x => HDiv.hDiv (f x) c) μ","decl":"@[to_additive (attr := measurability)]\ntheorem AEMeasurable.div_const [MeasurableDiv G] (hf : AEMeasurable f μ) (c : G) :\n    AEMeasurable (fun x => f x / c) μ :=\n  (MeasurableDiv.measurable_div_const c).comp_aemeasurable hf\n\n"}
{"name":"Measurable.div","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\nα : Type u_3\ninst✝² : MeasurableSpace G\ninst✝¹ : Div G\nm : MeasurableSpace α\nf g : α → G\ninst✝ : MeasurableDiv₂ G\nhf : Measurable f\nhg : Measurable g\n⊢ Measurable fun a => HDiv.hDiv (f a) (g a)","decl":"@[to_additive (attr := fun_prop, aesop safe 20 apply (rule_sets := [Measurable]))]\ntheorem Measurable.div [MeasurableDiv₂ G] (hf : Measurable f) (hg : Measurable g) :\n    Measurable fun a => f a / g a :=\n  measurable_div.comp (hf.prod_mk hg)\n\n"}
{"name":"Measurable.sub","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\nα : Type u_3\ninst✝² : MeasurableSpace G\ninst✝¹ : Sub G\nm : MeasurableSpace α\nf g : α → G\ninst✝ : MeasurableSub₂ G\nhf : Measurable f\nhg : Measurable g\n⊢ Measurable fun a => HSub.hSub (f a) (g a)","decl":"@[to_additive (attr := fun_prop, aesop safe 20 apply (rule_sets := [Measurable]))]\ntheorem Measurable.div [MeasurableDiv₂ G] (hf : Measurable f) (hg : Measurable g) :\n    Measurable fun a => f a / g a :=\n  measurable_div.comp (hf.prod_mk hg)\n\n"}
{"name":"Measurable.sub'","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝² : MeasurableSpace G\ninst✝¹ : Sub G\nm : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝ : MeasurableSub₂ G\nf g : α → β → G\nh : α → β\nhf : Measurable (Function.HasUncurry.uncurry f)\nhg : Measurable (Function.HasUncurry.uncurry g)\nhh : Measurable h\n⊢ Measurable fun a => HSub.hSub (f a) (g a) (h a)","decl":"@[to_additive (attr := fun_prop, aesop safe 20 apply (rule_sets := [Measurable]))]\nlemma Measurable.div' [MeasurableDiv₂ G] {f g : α → β → G} {h : α → β} (hf : Measurable ↿f)\n    (hg : Measurable ↿g) (hh : Measurable h) : Measurable fun a ↦ (f a / g a) (h a) := by\n  simp; fun_prop\n\n"}
{"name":"Measurable.div'","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝² : MeasurableSpace G\ninst✝¹ : Div G\nm : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝ : MeasurableDiv₂ G\nf g : α → β → G\nh : α → β\nhf : Measurable (Function.HasUncurry.uncurry f)\nhg : Measurable (Function.HasUncurry.uncurry g)\nhh : Measurable h\n⊢ Measurable fun a => HDiv.hDiv (f a) (g a) (h a)","decl":"@[to_additive (attr := fun_prop, aesop safe 20 apply (rule_sets := [Measurable]))]\nlemma Measurable.div' [MeasurableDiv₂ G] {f g : α → β → G} {h : α → β} (hf : Measurable ↿f)\n    (hg : Measurable ↿g) (hh : Measurable h) : Measurable fun a ↦ (f a / g a) (h a) := by\n  simp; fun_prop\n\n"}
{"name":"AEMeasurable.sub'","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\nα : Type u_3\ninst✝² : MeasurableSpace G\ninst✝¹ : Sub G\nm : MeasurableSpace α\nf g : α → G\nμ : MeasureTheory.Measure α\ninst✝ : MeasurableSub₂ G\nhf : AEMeasurable f μ\nhg : AEMeasurable g μ\n⊢ AEMeasurable (HSub.hSub f g) μ","decl":"@[to_additive (attr := fun_prop, aesop safe 20 apply (rule_sets := [Measurable]))]\ntheorem AEMeasurable.div' [MeasurableDiv₂ G] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    AEMeasurable (f / g) μ :=\n  measurable_div.comp_aemeasurable (hf.prod_mk hg)\n\n"}
{"name":"AEMeasurable.div'","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\nα : Type u_3\ninst✝² : MeasurableSpace G\ninst✝¹ : Div G\nm : MeasurableSpace α\nf g : α → G\nμ : MeasureTheory.Measure α\ninst✝ : MeasurableDiv₂ G\nhf : AEMeasurable f μ\nhg : AEMeasurable g μ\n⊢ AEMeasurable (HDiv.hDiv f g) μ","decl":"@[to_additive (attr := fun_prop, aesop safe 20 apply (rule_sets := [Measurable]))]\ntheorem AEMeasurable.div' [MeasurableDiv₂ G] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    AEMeasurable (f / g) μ :=\n  measurable_div.comp_aemeasurable (hf.prod_mk hg)\n\n"}
{"name":"AEMeasurable.div","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\nα : Type u_3\ninst✝² : MeasurableSpace G\ninst✝¹ : Div G\nm : MeasurableSpace α\nf g : α → G\nμ : MeasureTheory.Measure α\ninst✝ : MeasurableDiv₂ G\nhf : AEMeasurable f μ\nhg : AEMeasurable g μ\n⊢ AEMeasurable (fun a => HDiv.hDiv (f a) (g a)) μ","decl":"@[to_additive (attr := fun_prop, aesop safe 20 apply (rule_sets := [Measurable]))]\ntheorem AEMeasurable.div [MeasurableDiv₂ G] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    AEMeasurable (fun a => f a / g a) μ :=\n  measurable_div.comp_aemeasurable (hf.prod_mk hg)\n\n"}
{"name":"AEMeasurable.sub","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\nα : Type u_3\ninst✝² : MeasurableSpace G\ninst✝¹ : Sub G\nm : MeasurableSpace α\nf g : α → G\nμ : MeasureTheory.Measure α\ninst✝ : MeasurableSub₂ G\nhf : AEMeasurable f μ\nhg : AEMeasurable g μ\n⊢ AEMeasurable (fun a => HSub.hSub (f a) (g a)) μ","decl":"@[to_additive (attr := fun_prop, aesop safe 20 apply (rule_sets := [Measurable]))]\ntheorem AEMeasurable.div [MeasurableDiv₂ G] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    AEMeasurable (fun a => f a / g a) μ :=\n  measurable_div.comp_aemeasurable (hf.prod_mk hg)\n\n"}
{"name":"MeasurableDiv₂.toMeasurableDiv","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\ninst✝² : MeasurableSpace G\ninst✝¹ : Div G\ninst✝ : MeasurableDiv₂ G\n⊢ MeasurableDiv G","decl":"@[to_additive]\ninstance (priority := 100) MeasurableDiv₂.toMeasurableDiv [MeasurableDiv₂ G] :\n    MeasurableDiv G :=\n  ⟨fun _ => measurable_const.div measurable_id, fun _ => measurable_id.div measurable_const⟩\n\n"}
{"name":"MeasurableSub₂.toMeasurableSub","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\ninst✝² : MeasurableSpace G\ninst✝¹ : Sub G\ninst✝ : MeasurableSub₂ G\n⊢ MeasurableSub G","decl":"@[to_additive]\ninstance (priority := 100) MeasurableDiv₂.toMeasurableDiv [MeasurableDiv₂ G] :\n    MeasurableDiv G :=\n  ⟨fun _ => measurable_const.div measurable_id, fun _ => measurable_id.div measurable_const⟩\n\n"}
{"name":"Pi.measurableSub","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"ι : Type u_5\nα : ι → Type u_6\ninst✝² : (i : ι) → Sub (α i)\ninst✝¹ : (i : ι) → MeasurableSpace (α i)\ninst✝ : ∀ (i : ι), MeasurableSub (α i)\n⊢ MeasurableSub ((i : ι) → α i)","decl":"@[to_additive]\ninstance Pi.measurableDiv {ι : Type*} {α : ι → Type*} [∀ i, Div (α i)]\n    [∀ i, MeasurableSpace (α i)] [∀ i, MeasurableDiv (α i)] : MeasurableDiv (∀ i, α i) :=\n  ⟨fun _ => measurable_pi_iff.mpr fun i => (measurable_pi_apply i).const_div _, fun _ =>\n    measurable_pi_iff.mpr fun i => (measurable_pi_apply i).div_const _⟩\n\n"}
{"name":"Pi.measurableDiv","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"ι : Type u_5\nα : ι → Type u_6\ninst✝² : (i : ι) → Div (α i)\ninst✝¹ : (i : ι) → MeasurableSpace (α i)\ninst✝ : ∀ (i : ι), MeasurableDiv (α i)\n⊢ MeasurableDiv ((i : ι) → α i)","decl":"@[to_additive]\ninstance Pi.measurableDiv {ι : Type*} {α : ι → Type*} [∀ i, Div (α i)]\n    [∀ i, MeasurableSpace (α i)] [∀ i, MeasurableDiv (α i)] : MeasurableDiv (∀ i, α i) :=\n  ⟨fun _ => measurable_pi_iff.mpr fun i => (measurable_pi_apply i).const_div _, fun _ =>\n    measurable_pi_iff.mpr fun i => (measurable_pi_apply i).div_const _⟩\n\n"}
{"name":"Pi.measurableSub₂","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"ι : Type u_5\nα : ι → Type u_6\ninst✝² : (i : ι) → Sub (α i)\ninst✝¹ : (i : ι) → MeasurableSpace (α i)\ninst✝ : ∀ (i : ι), MeasurableSub₂ (α i)\n⊢ MeasurableSub₂ ((i : ι) → α i)","decl":"@[to_additive Pi.measurableSub₂]\ninstance Pi.measurableDiv₂ {ι : Type*} {α : ι → Type*} [∀ i, Div (α i)]\n    [∀ i, MeasurableSpace (α i)] [∀ i, MeasurableDiv₂ (α i)] : MeasurableDiv₂ (∀ i, α i) :=\n  ⟨measurable_pi_iff.mpr fun _ => measurable_fst.eval.div measurable_snd.eval⟩\n\n"}
{"name":"Pi.measurableDiv₂","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"ι : Type u_5\nα : ι → Type u_6\ninst✝² : (i : ι) → Div (α i)\ninst✝¹ : (i : ι) → MeasurableSpace (α i)\ninst✝ : ∀ (i : ι), MeasurableDiv₂ (α i)\n⊢ MeasurableDiv₂ ((i : ι) → α i)","decl":"@[to_additive Pi.measurableSub₂]\ninstance Pi.measurableDiv₂ {ι : Type*} {α : ι → Type*} [∀ i, Div (α i)]\n    [∀ i, MeasurableSpace (α i)] [∀ i, MeasurableDiv₂ (α i)] : MeasurableDiv₂ (∀ i, α i) :=\n  ⟨measurable_pi_iff.mpr fun _ => measurable_fst.eval.div measurable_snd.eval⟩\n\n"}
{"name":"measurableSet_eq_fun","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_3\nm : MeasurableSpace α\nE : Type u_5\ninst✝³ : MeasurableSpace E\ninst✝² : AddGroup E\ninst✝¹ : MeasurableSingletonClass E\ninst✝ : MeasurableSub₂ E\nf g : α → E\nhf : Measurable f\nhg : Measurable g\n⊢ MeasurableSet (setOf fun x => Eq (f x) (g x))","decl":"@[measurability]\ntheorem measurableSet_eq_fun {m : MeasurableSpace α} {E} [MeasurableSpace E] [AddGroup E]\n    [MeasurableSingletonClass E] [MeasurableSub₂ E] {f g : α → E} (hf : Measurable f)\n    (hg : Measurable g) : MeasurableSet { x | f x = g x } := by\n  suffices h_set_eq : { x : α | f x = g x } = { x | (f - g) x = (0 : E) } by\n    rw [h_set_eq]\n    exact (hf.sub hg) measurableSet_eq\n  ext\n  simp_rw [Set.mem_setOf_eq, Pi.sub_apply, sub_eq_zero]\n\n"}
{"name":"measurableSet_eq_fun'","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_3\nm : MeasurableSpace α\nβ : Type u_5\ninst✝⁶ : AddCommMonoid β\ninst✝⁵ : PartialOrder β\ninst✝⁴ : CanonicallyOrderedAdd β\ninst✝³ : Sub β\ninst✝² : OrderedSub β\nx✝ : MeasurableSpace β\ninst✝¹ : MeasurableSub₂ β\ninst✝ : MeasurableSingletonClass β\nf g : α → β\nhf : Measurable f\nhg : Measurable g\n⊢ MeasurableSet (setOf fun x => Eq (f x) (g x))","decl":"@[measurability]\nlemma measurableSet_eq_fun' {β : Type*} [AddCommMonoid β] [PartialOrder β]\n    [CanonicallyOrderedAdd β] [Sub β] [OrderedSub β]\n    {_ : MeasurableSpace β} [MeasurableSub₂ β] [MeasurableSingletonClass β]\n    {f g : α → β} (hf : Measurable f) (hg : Measurable g) :\n    MeasurableSet {x | f x = g x} := by\n  have : {a | f a = g a} = {a | (f - g) a = 0} ∩ {a | (g - f) a = 0} := by\n    ext\n    simp only [Set.mem_setOf_eq, Pi.sub_apply, tsub_eq_zero_iff_le, Set.mem_inter_iff]\n    exact ⟨fun h ↦ ⟨h.le, h.symm.le⟩, fun h ↦ le_antisymm h.1 h.2⟩\n  rw [this]\n  exact ((hf.sub hg) (measurableSet_singleton 0)).inter ((hg.sub hf) (measurableSet_singleton 0))\n\n"}
{"name":"nullMeasurableSet_eq_fun","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_3\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nE : Type u_5\ninst✝³ : MeasurableSpace E\ninst✝² : AddGroup E\ninst✝¹ : MeasurableSingletonClass E\ninst✝ : MeasurableSub₂ E\nf g : α → E\nhf : AEMeasurable f μ\nhg : AEMeasurable g μ\n⊢ MeasureTheory.NullMeasurableSet (setOf fun x => Eq (f x) (g x)) μ","decl":"theorem nullMeasurableSet_eq_fun {E} [MeasurableSpace E] [AddGroup E] [MeasurableSingletonClass E]\n    [MeasurableSub₂ E] {f g : α → E} (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    NullMeasurableSet { x | f x = g x } μ := by\n  apply (measurableSet_eq_fun hf.measurable_mk hg.measurable_mk).nullMeasurableSet.congr\n  filter_upwards [hf.ae_eq_mk, hg.ae_eq_mk] with x hfx hgx\n  change (hf.mk f x = hg.mk g x) = (f x = g x)\n  simp only [hfx, hgx]\n\n"}
{"name":"measurableSet_eq_fun_of_countable","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_3\nm : MeasurableSpace α\nE : Type u_5\ninst✝² : MeasurableSpace E\ninst✝¹ : MeasurableSingletonClass E\ninst✝ : Countable E\nf g : α → E\nhf : Measurable f\nhg : Measurable g\n⊢ MeasurableSet (setOf fun x => Eq (f x) (g x))","decl":"theorem measurableSet_eq_fun_of_countable {m : MeasurableSpace α} {E} [MeasurableSpace E]\n    [MeasurableSingletonClass E] [Countable E] {f g : α → E} (hf : Measurable f)\n    (hg : Measurable g) : MeasurableSet { x | f x = g x } := by\n  have : { x | f x = g x } = ⋃ j, { x | f x = j } ∩ { x | g x = j } := by\n    ext1 x\n    simp only [Set.mem_setOf_eq, Set.mem_iUnion, Set.mem_inter_iff, exists_eq_right']\n  rw [this]\n  refine MeasurableSet.iUnion fun j => MeasurableSet.inter ?_ ?_\n  · exact hf (measurableSet_singleton j)\n  · exact hg (measurableSet_singleton j)\n\n"}
{"name":"ae_eq_trim_of_measurable","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_5\nE : Type u_6\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace E\ninst✝² : AddGroup E\ninst✝¹ : MeasurableSingletonClass E\ninst✝ : MeasurableSub₂ E\nhm : LE.le m m0\nf g : α → E\nhf : Measurable f\nhg : Measurable g\nhfg : (MeasureTheory.ae μ).EventuallyEq f g\n⊢ (MeasureTheory.ae (μ.trim hm)).EventuallyEq f g","decl":"theorem ae_eq_trim_of_measurable {α E} {m m0 : MeasurableSpace α} {μ : Measure α}\n    [MeasurableSpace E] [AddGroup E] [MeasurableSingletonClass E] [MeasurableSub₂ E]\n    (hm : m ≤ m0) {f g : α → E} (hf : Measurable[m] f) (hg : Measurable[m] g) (hfg : f =ᵐ[μ] g) :\n    f =ᵐ[μ.trim hm] g := by\n  rwa [Filter.EventuallyEq, ae_iff, trim_measurableSet_eq hm _]\n  exact @MeasurableSet.compl α _ m (@measurableSet_eq_fun α m E _ _ _ _ _ _ hf hg)\n\n"}
{"name":"MeasurableNeg.measurable_neg","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\ninst✝¹ : Neg G\ninst✝ : MeasurableSpace G\nself : MeasurableNeg G\n⊢ Measurable Neg.neg","decl":"/-- We say that a type has `MeasurableNeg` if `x ↦ -x` is a measurable function. -/\nclass MeasurableNeg (G : Type*) [Neg G] [MeasurableSpace G] : Prop where\n  measurable_neg : Measurable (Neg.neg : G → G)\n\n"}
{"name":"MeasurableInv.measurable_inv","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\ninst✝¹ : Inv G\ninst✝ : MeasurableSpace G\nself : MeasurableInv G\n⊢ Measurable Inv.inv","decl":"/-- We say that a type has `MeasurableInv` if `x ↦ x⁻¹` is a measurable function. -/\n@[to_additive]\nclass MeasurableInv (G : Type*) [Inv G] [MeasurableSpace G] : Prop where\n  measurable_inv : Measurable (Inv.inv : G → G)\n\n"}
{"name":"measurableDiv_of_mul_inv","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\ninst✝³ : MeasurableSpace G\ninst✝² : DivInvMonoid G\ninst✝¹ : MeasurableMul G\ninst✝ : MeasurableInv G\n⊢ MeasurableDiv G","decl":"@[to_additive]\ninstance (priority := 100) measurableDiv_of_mul_inv (G : Type*) [MeasurableSpace G]\n    [DivInvMonoid G] [MeasurableMul G] [MeasurableInv G] : MeasurableDiv G where\n  measurable_const_div c := by\n    convert measurable_inv.const_mul c using 1\n    ext1\n    apply div_eq_mul_inv\n  measurable_div_const c := by\n    convert measurable_id.mul_const c⁻¹ using 1\n    ext1\n    apply div_eq_mul_inv\n\n"}
{"name":"measurableSub_of_add_neg","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\ninst✝³ : MeasurableSpace G\ninst✝² : SubNegMonoid G\ninst✝¹ : MeasurableAdd G\ninst✝ : MeasurableNeg G\n⊢ MeasurableSub G","decl":"@[to_additive]\ninstance (priority := 100) measurableDiv_of_mul_inv (G : Type*) [MeasurableSpace G]\n    [DivInvMonoid G] [MeasurableMul G] [MeasurableInv G] : MeasurableDiv G where\n  measurable_const_div c := by\n    convert measurable_inv.const_mul c using 1\n    ext1\n    apply div_eq_mul_inv\n  measurable_div_const c := by\n    convert measurable_id.mul_const c⁻¹ using 1\n    ext1\n    apply div_eq_mul_inv\n\n"}
{"name":"Measurable.neg","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\nα : Type u_3\ninst✝² : Neg G\ninst✝¹ : MeasurableSpace G\ninst✝ : MeasurableNeg G\nm : MeasurableSpace α\nf : α → G\nhf : Measurable f\n⊢ Measurable fun x => Neg.neg (f x)","decl":"@[to_additive (attr := fun_prop, measurability)]\ntheorem Measurable.inv (hf : Measurable f) : Measurable fun x => (f x)⁻¹ :=\n  measurable_inv.comp hf\n\n"}
{"name":"Measurable.inv","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\nα : Type u_3\ninst✝² : Inv G\ninst✝¹ : MeasurableSpace G\ninst✝ : MeasurableInv G\nm : MeasurableSpace α\nf : α → G\nhf : Measurable f\n⊢ Measurable fun x => Inv.inv (f x)","decl":"@[to_additive (attr := fun_prop, measurability)]\ntheorem Measurable.inv (hf : Measurable f) : Measurable fun x => (f x)⁻¹ :=\n  measurable_inv.comp hf\n\n"}
{"name":"AEMeasurable.inv","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\nα : Type u_3\ninst✝² : Inv G\ninst✝¹ : MeasurableSpace G\ninst✝ : MeasurableInv G\nm : MeasurableSpace α\nf : α → G\nμ : MeasureTheory.Measure α\nhf : AEMeasurable f μ\n⊢ AEMeasurable (fun x => Inv.inv (f x)) μ","decl":"@[to_additive (attr := fun_prop, measurability)]\ntheorem AEMeasurable.inv (hf : AEMeasurable f μ) : AEMeasurable (fun x => (f x)⁻¹) μ :=\n  measurable_inv.comp_aemeasurable hf\n\n"}
{"name":"AEMeasurable.neg","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\nα : Type u_3\ninst✝² : Neg G\ninst✝¹ : MeasurableSpace G\ninst✝ : MeasurableNeg G\nm : MeasurableSpace α\nf : α → G\nμ : MeasureTheory.Measure α\nhf : AEMeasurable f μ\n⊢ AEMeasurable (fun x => Neg.neg (f x)) μ","decl":"@[to_additive (attr := fun_prop, measurability)]\ntheorem AEMeasurable.inv (hf : AEMeasurable f μ) : AEMeasurable (fun x => (f x)⁻¹) μ :=\n  measurable_inv.comp_aemeasurable hf\n\n"}
{"name":"measurable_neg_iff","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_3\nm : MeasurableSpace α\nG : Type u_4\ninst✝² : AddGroup G\ninst✝¹ : MeasurableSpace G\ninst✝ : MeasurableNeg G\nf : α → G\n⊢ Iff (Measurable fun x => Neg.neg (f x)) (Measurable f)","decl":"@[to_additive (attr := simp)]\ntheorem measurable_inv_iff {G : Type*} [Group G] [MeasurableSpace G] [MeasurableInv G]\n    {f : α → G} : (Measurable fun x => (f x)⁻¹) ↔ Measurable f :=\n  ⟨fun h => by simpa only [inv_inv] using h.inv, fun h => h.inv⟩\n\n"}
{"name":"measurable_inv_iff","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_3\nm : MeasurableSpace α\nG : Type u_4\ninst✝² : Group G\ninst✝¹ : MeasurableSpace G\ninst✝ : MeasurableInv G\nf : α → G\n⊢ Iff (Measurable fun x => Inv.inv (f x)) (Measurable f)","decl":"@[to_additive (attr := simp)]\ntheorem measurable_inv_iff {G : Type*} [Group G] [MeasurableSpace G] [MeasurableInv G]\n    {f : α → G} : (Measurable fun x => (f x)⁻¹) ↔ Measurable f :=\n  ⟨fun h => by simpa only [inv_inv] using h.inv, fun h => h.inv⟩\n\n"}
{"name":"aemeasurable_neg_iff","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_3\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nG : Type u_4\ninst✝² : AddGroup G\ninst✝¹ : MeasurableSpace G\ninst✝ : MeasurableNeg G\nf : α → G\n⊢ Iff (AEMeasurable (fun x => Neg.neg (f x)) μ) (AEMeasurable f μ)","decl":"@[to_additive (attr := simp)]\ntheorem aemeasurable_inv_iff {G : Type*} [Group G] [MeasurableSpace G] [MeasurableInv G]\n    {f : α → G} : AEMeasurable (fun x => (f x)⁻¹) μ ↔ AEMeasurable f μ :=\n  ⟨fun h => by simpa only [inv_inv] using h.inv, fun h => h.inv⟩\n\n"}
{"name":"aemeasurable_inv_iff","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_3\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nG : Type u_4\ninst✝² : Group G\ninst✝¹ : MeasurableSpace G\ninst✝ : MeasurableInv G\nf : α → G\n⊢ Iff (AEMeasurable (fun x => Inv.inv (f x)) μ) (AEMeasurable f μ)","decl":"@[to_additive (attr := simp)]\ntheorem aemeasurable_inv_iff {G : Type*} [Group G] [MeasurableSpace G] [MeasurableInv G]\n    {f : α → G} : AEMeasurable (fun x => (f x)⁻¹) μ ↔ AEMeasurable f μ :=\n  ⟨fun h => by simpa only [inv_inv] using h.inv, fun h => h.inv⟩\n\n"}
{"name":"measurable_inv_iff₀","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_3\nm : MeasurableSpace α\nG₀ : Type u_4\ninst✝² : GroupWithZero G₀\ninst✝¹ : MeasurableSpace G₀\ninst✝ : MeasurableInv G₀\nf : α → G₀\n⊢ Iff (Measurable fun x => Inv.inv (f x)) (Measurable f)","decl":"@[simp]\ntheorem measurable_inv_iff₀ {G₀ : Type*} [GroupWithZero G₀] [MeasurableSpace G₀]\n    [MeasurableInv G₀] {f : α → G₀} : (Measurable fun x => (f x)⁻¹) ↔ Measurable f :=\n  ⟨fun h => by simpa only [inv_inv] using h.inv, fun h => h.inv⟩\n\n"}
{"name":"aemeasurable_inv_iff₀","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_3\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nG₀ : Type u_4\ninst✝² : GroupWithZero G₀\ninst✝¹ : MeasurableSpace G₀\ninst✝ : MeasurableInv G₀\nf : α → G₀\n⊢ Iff (AEMeasurable (fun x => Inv.inv (f x)) μ) (AEMeasurable f μ)","decl":"@[simp]\ntheorem aemeasurable_inv_iff₀ {G₀ : Type*} [GroupWithZero G₀] [MeasurableSpace G₀]\n    [MeasurableInv G₀] {f : α → G₀} : AEMeasurable (fun x => (f x)⁻¹) μ ↔ AEMeasurable f μ :=\n  ⟨fun h => by simpa only [inv_inv] using h.inv, fun h => h.inv⟩\n\n"}
{"name":"Pi.measurableNeg","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"ι : Type u_4\nα : ι → Type u_5\ninst✝² : (i : ι) → Neg (α i)\ninst✝¹ : (i : ι) → MeasurableSpace (α i)\ninst✝ : ∀ (i : ι), MeasurableNeg (α i)\n⊢ MeasurableNeg ((i : ι) → α i)","decl":"@[to_additive]\ninstance Pi.measurableInv {ι : Type*} {α : ι → Type*} [∀ i, Inv (α i)]\n    [∀ i, MeasurableSpace (α i)] [∀ i, MeasurableInv (α i)] : MeasurableInv (∀ i, α i) :=\n  ⟨measurable_pi_iff.mpr fun i => (measurable_pi_apply i).inv⟩\n\n"}
{"name":"Pi.measurableInv","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"ι : Type u_4\nα : ι → Type u_5\ninst✝² : (i : ι) → Inv (α i)\ninst✝¹ : (i : ι) → MeasurableSpace (α i)\ninst✝ : ∀ (i : ι), MeasurableInv (α i)\n⊢ MeasurableInv ((i : ι) → α i)","decl":"@[to_additive]\ninstance Pi.measurableInv {ι : Type*} {α : ι → Type*} [∀ i, Inv (α i)]\n    [∀ i, MeasurableSpace (α i)] [∀ i, MeasurableInv (α i)] : MeasurableInv (∀ i, α i) :=\n  ⟨measurable_pi_iff.mpr fun i => (measurable_pi_apply i).inv⟩\n\n"}
{"name":"MeasurableSet.neg","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\ninst✝² : Neg G\ninst✝¹ : MeasurableSpace G\ninst✝ : MeasurableNeg G\ns : Set G\nhs : MeasurableSet s\n⊢ MeasurableSet (Neg.neg s)","decl":"@[to_additive]\ntheorem MeasurableSet.inv {s : Set G} (hs : MeasurableSet s) : MeasurableSet s⁻¹ :=\n  measurable_inv hs\n\n"}
{"name":"MeasurableSet.inv","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\ninst✝² : Inv G\ninst✝¹ : MeasurableSpace G\ninst✝ : MeasurableInv G\ns : Set G\nhs : MeasurableSet s\n⊢ MeasurableSet (Inv.inv s)","decl":"@[to_additive]\ntheorem MeasurableSet.inv {s : Set G} (hs : MeasurableSet s) : MeasurableSet s⁻¹ :=\n  measurable_inv hs\n\n"}
{"name":"measurableEmbedding_neg","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_3\nm : MeasurableSpace α\ninst✝¹ : InvolutiveNeg α\ninst✝ : MeasurableNeg α\n⊢ MeasurableEmbedding Neg.neg","decl":"@[to_additive]\ntheorem measurableEmbedding_inv [InvolutiveInv α] [MeasurableInv α] :\n    MeasurableEmbedding (Inv.inv (α := α)) :=\n  ⟨inv_injective, measurable_inv, fun s hs ↦ s.image_inv_eq_inv ▸ hs.inv⟩\n\n"}
{"name":"measurableEmbedding_inv","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_3\nm : MeasurableSpace α\ninst✝¹ : InvolutiveInv α\ninst✝ : MeasurableInv α\n⊢ MeasurableEmbedding Inv.inv","decl":"@[to_additive]\ntheorem measurableEmbedding_inv [InvolutiveInv α] [MeasurableInv α] :\n    MeasurableEmbedding (Inv.inv (α := α)) :=\n  ⟨inv_injective, measurable_inv, fun s hs ↦ s.image_inv_eq_inv ▸ hs.inv⟩\n\n"}
{"name":"Measurable.add_iff_right","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableSpace α\ninst✝² : AddCommGroup G\ninst✝¹ : MeasurableAdd₂ G\ninst✝ : MeasurableNeg G\nf g : α → G\nhf : Measurable f\n⊢ Iff (Measurable (HAdd.hAdd f g)) (Measurable g)","decl":"@[to_additive]\ntheorem Measurable.mul_iff_right {G : Type*} [MeasurableSpace G] [MeasurableSpace α] [CommGroup G]\n    [MeasurableMul₂ G] [MeasurableInv G] {f g : α → G} (hf : Measurable f) :\n    Measurable (f * g) ↔ Measurable g :=\n  ⟨fun h ↦ show g = f * g * f⁻¹ by simp only [mul_inv_cancel_comm] ▸ h.mul hf.inv,\n    fun h ↦ hf.mul h⟩\n\n"}
{"name":"Measurable.mul_iff_right","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableSpace α\ninst✝² : CommGroup G\ninst✝¹ : MeasurableMul₂ G\ninst✝ : MeasurableInv G\nf g : α → G\nhf : Measurable f\n⊢ Iff (Measurable (HMul.hMul f g)) (Measurable g)","decl":"@[to_additive]\ntheorem Measurable.mul_iff_right {G : Type*} [MeasurableSpace G] [MeasurableSpace α] [CommGroup G]\n    [MeasurableMul₂ G] [MeasurableInv G] {f g : α → G} (hf : Measurable f) :\n    Measurable (f * g) ↔ Measurable g :=\n  ⟨fun h ↦ show g = f * g * f⁻¹ by simp only [mul_inv_cancel_comm] ▸ h.mul hf.inv,\n    fun h ↦ hf.mul h⟩\n\n"}
{"name":"AEMeasurable.add_iff_right","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableSpace α\ninst✝² : AddCommGroup G\ninst✝¹ : MeasurableAdd₂ G\ninst✝ : MeasurableNeg G\nμ : MeasureTheory.Measure α\nf g : α → G\nhf : AEMeasurable f μ\n⊢ Iff (AEMeasurable (HAdd.hAdd f g) μ) (AEMeasurable g μ)","decl":"@[to_additive]\ntheorem AEMeasurable.mul_iff_right {G : Type*} [MeasurableSpace G] [MeasurableSpace α] [CommGroup G]\n    [MeasurableMul₂ G] [MeasurableInv G] {μ : Measure α} {f g : α → G} (hf : AEMeasurable f μ) :\n    AEMeasurable (f * g) μ ↔ AEMeasurable g μ :=\n  ⟨fun h ↦ show g = f * g * f⁻¹ by simp only [mul_inv_cancel_comm] ▸ h.mul hf.inv,\n    fun h ↦ hf.mul h⟩\n\n"}
{"name":"AEMeasurable.mul_iff_right","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableSpace α\ninst✝² : CommGroup G\ninst✝¹ : MeasurableMul₂ G\ninst✝ : MeasurableInv G\nμ : MeasureTheory.Measure α\nf g : α → G\nhf : AEMeasurable f μ\n⊢ Iff (AEMeasurable (HMul.hMul f g) μ) (AEMeasurable g μ)","decl":"@[to_additive]\ntheorem AEMeasurable.mul_iff_right {G : Type*} [MeasurableSpace G] [MeasurableSpace α] [CommGroup G]\n    [MeasurableMul₂ G] [MeasurableInv G] {μ : Measure α} {f g : α → G} (hf : AEMeasurable f μ) :\n    AEMeasurable (f * g) μ ↔ AEMeasurable g μ :=\n  ⟨fun h ↦ show g = f * g * f⁻¹ by simp only [mul_inv_cancel_comm] ▸ h.mul hf.inv,\n    fun h ↦ hf.mul h⟩\n\n"}
{"name":"Measurable.add_iff_left","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableSpace α\ninst✝² : AddCommGroup G\ninst✝¹ : MeasurableAdd₂ G\ninst✝ : MeasurableNeg G\nf g : α → G\nhf : Measurable f\n⊢ Iff (Measurable (HAdd.hAdd g f)) (Measurable g)","decl":"@[to_additive]\ntheorem Measurable.mul_iff_left {G : Type*} [MeasurableSpace G] [MeasurableSpace α] [CommGroup G]\n    [MeasurableMul₂ G] [MeasurableInv G] {f g : α → G} (hf : Measurable f) :\n    Measurable (g * f) ↔ Measurable g :=\n  mul_comm g f ▸ Measurable.mul_iff_right hf\n\n"}
{"name":"Measurable.mul_iff_left","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableSpace α\ninst✝² : CommGroup G\ninst✝¹ : MeasurableMul₂ G\ninst✝ : MeasurableInv G\nf g : α → G\nhf : Measurable f\n⊢ Iff (Measurable (HMul.hMul g f)) (Measurable g)","decl":"@[to_additive]\ntheorem Measurable.mul_iff_left {G : Type*} [MeasurableSpace G] [MeasurableSpace α] [CommGroup G]\n    [MeasurableMul₂ G] [MeasurableInv G] {f g : α → G} (hf : Measurable f) :\n    Measurable (g * f) ↔ Measurable g :=\n  mul_comm g f ▸ Measurable.mul_iff_right hf\n\n"}
{"name":"AEMeasurable.add_iff_left","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableSpace α\ninst✝² : AddCommGroup G\ninst✝¹ : MeasurableAdd₂ G\ninst✝ : MeasurableNeg G\nμ : MeasureTheory.Measure α\nf g : α → G\nhf : AEMeasurable f μ\n⊢ Iff (AEMeasurable (HAdd.hAdd g f) μ) (AEMeasurable g μ)","decl":"@[to_additive]\ntheorem AEMeasurable.mul_iff_left {G : Type*} [MeasurableSpace G] [MeasurableSpace α] [CommGroup G]\n    [MeasurableMul₂ G] [MeasurableInv G] {μ : Measure α} {f g : α → G} (hf : AEMeasurable f μ) :\n    AEMeasurable (g * f) μ ↔ AEMeasurable g μ :=\n  mul_comm g f ▸ AEMeasurable.mul_iff_right hf\n\n"}
{"name":"AEMeasurable.mul_iff_left","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableSpace α\ninst✝² : CommGroup G\ninst✝¹ : MeasurableMul₂ G\ninst✝ : MeasurableInv G\nμ : MeasureTheory.Measure α\nf g : α → G\nhf : AEMeasurable f μ\n⊢ Iff (AEMeasurable (HMul.hMul g f) μ) (AEMeasurable g μ)","decl":"@[to_additive]\ntheorem AEMeasurable.mul_iff_left {G : Type*} [MeasurableSpace G] [MeasurableSpace α] [CommGroup G]\n    [MeasurableMul₂ G] [MeasurableInv G] {μ : Measure α} {f g : α → G} (hf : AEMeasurable f μ) :\n    AEMeasurable (g * f) μ ↔ AEMeasurable g μ :=\n  mul_comm g f ▸ AEMeasurable.mul_iff_right hf\n\n"}
{"name":"DivInvMonoid.measurableZPow","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u\ninst✝³ : DivInvMonoid G\ninst✝² : MeasurableSpace G\ninst✝¹ : MeasurableMul₂ G\ninst✝ : MeasurableInv G\n⊢ MeasurablePow G Int","decl":"/-- `DivInvMonoid.Pow` is measurable. -/\ninstance DivInvMonoid.measurableZPow (G : Type u) [DivInvMonoid G] [MeasurableSpace G]\n    [MeasurableMul₂ G] [MeasurableInv G] : MeasurablePow G ℤ :=\n  ⟨measurable_from_prod_countable fun n => by\n      cases' n with n n\n      · simp_rw [Int.ofNat_eq_coe, zpow_natCast]\n        exact measurable_id.pow_const _\n      · simp_rw [zpow_negSucc]\n        exact (measurable_id.pow_const (n + 1)).inv⟩\n\n"}
{"name":"measurableDiv₂_of_add_neg","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\ninst✝³ : MeasurableSpace G\ninst✝² : SubNegMonoid G\ninst✝¹ : MeasurableAdd₂ G\ninst✝ : MeasurableNeg G\n⊢ MeasurableSub₂ G","decl":"@[to_additive]\ninstance (priority := 100) measurableDiv₂_of_mul_inv (G : Type*) [MeasurableSpace G]\n    [DivInvMonoid G] [MeasurableMul₂ G] [MeasurableInv G] : MeasurableDiv₂ G :=\n  ⟨by\n    simp only [div_eq_mul_inv]\n    exact measurable_fst.mul measurable_snd.inv⟩\n\n-- See note [lower instance priority]\n"}
{"name":"measurableDiv₂_of_mul_inv","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\ninst✝³ : MeasurableSpace G\ninst✝² : DivInvMonoid G\ninst✝¹ : MeasurableMul₂ G\ninst✝ : MeasurableInv G\n⊢ MeasurableDiv₂ G","decl":"@[to_additive]\ninstance (priority := 100) measurableDiv₂_of_mul_inv (G : Type*) [MeasurableSpace G]\n    [DivInvMonoid G] [MeasurableMul₂ G] [MeasurableInv G] : MeasurableDiv₂ G :=\n  ⟨by\n    simp only [div_eq_mul_inv]\n    exact measurable_fst.mul measurable_snd.inv⟩\n\n-- See note [lower instance priority]\n"}
{"name":"MeasurableDiv.toMeasurableInv","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\ninst✝¹ : Group α\ninst✝ : MeasurableDiv α\n⊢ MeasurableInv α","decl":"instance (priority := 100) MeasurableDiv.toMeasurableInv [MeasurableSpace α] [Group α]\n    [MeasurableDiv α] : MeasurableInv α where\n  measurable_inv := by simpa using measurable_const_div (1 : α)\n\n"}
{"name":"MeasurableVAdd.measurable_vadd_const","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\ninst✝² : VAdd M α\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableSpace α\nself : MeasurableVAdd M α\nx : α\n⊢ Measurable fun x_1 => HVAdd.hVAdd x_1 x","decl":"/-- We say that the action of `M` on `α` has `MeasurableVAdd` if for each `c` the map `x ↦ c +ᵥ x`\nis a measurable function and for each `x` the map `c ↦ c +ᵥ x` is a measurable function. -/\nclass MeasurableVAdd (M α : Type*) [VAdd M α] [MeasurableSpace M] [MeasurableSpace α] :\n    Prop where\n  measurable_const_vadd : ∀ c : M, Measurable (c +ᵥ · : α → α)\n  measurable_vadd_const : ∀ x : α, Measurable (· +ᵥ x : M → α)\n\n"}
{"name":"MeasurableVAdd.measurable_const_vadd","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\ninst✝² : VAdd M α\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableSpace α\nself : MeasurableVAdd M α\nc : M\n⊢ Measurable fun x => HVAdd.hVAdd c x","decl":"/-- We say that the action of `M` on `α` has `MeasurableVAdd` if for each `c` the map `x ↦ c +ᵥ x`\nis a measurable function and for each `x` the map `c ↦ c +ᵥ x` is a measurable function. -/\nclass MeasurableVAdd (M α : Type*) [VAdd M α] [MeasurableSpace M] [MeasurableSpace α] :\n    Prop where\n  measurable_const_vadd : ∀ c : M, Measurable (c +ᵥ · : α → α)\n  measurable_vadd_const : ∀ x : α, Measurable (· +ᵥ x : M → α)\n\n"}
{"name":"MeasurableSMul.measurable_const_smul","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\ninst✝² : SMul M α\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableSpace α\nself : MeasurableSMul M α\nc : M\n⊢ Measurable fun x => HSMul.hSMul c x","decl":"/-- We say that the action of `M` on `α` has `MeasurableSMul` if for each `c` the map `x ↦ c • x`\nis a measurable function and for each `x` the map `c ↦ c • x` is a measurable function. -/\n@[to_additive]\nclass MeasurableSMul (M α : Type*) [SMul M α] [MeasurableSpace M] [MeasurableSpace α] :\n    Prop where\n  measurable_const_smul : ∀ c : M, Measurable (c • · : α → α)\n  measurable_smul_const : ∀ x : α, Measurable (· • x : M → α)\n\n"}
{"name":"MeasurableSMul.measurable_smul_const","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\ninst✝² : SMul M α\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableSpace α\nself : MeasurableSMul M α\nx : α\n⊢ Measurable fun x_1 => HSMul.hSMul x_1 x","decl":"/-- We say that the action of `M` on `α` has `MeasurableSMul` if for each `c` the map `x ↦ c • x`\nis a measurable function and for each `x` the map `c ↦ c • x` is a measurable function. -/\n@[to_additive]\nclass MeasurableSMul (M α : Type*) [SMul M α] [MeasurableSpace M] [MeasurableSpace α] :\n    Prop where\n  measurable_const_smul : ∀ c : M, Measurable (c • · : α → α)\n  measurable_smul_const : ∀ x : α, Measurable (· • x : M → α)\n\n"}
{"name":"MeasurableVAdd₂.measurable_vadd","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\ninst✝² : VAdd M α\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableSpace α\nself : MeasurableVAdd₂ M α\n⊢ Measurable (Function.uncurry fun x1 x2 => HVAdd.hVAdd x1 x2)","decl":"/-- We say that the action of `M` on `α` has `MeasurableVAdd₂` if the map\n`(c, x) ↦ c +ᵥ x` is a measurable function. -/\nclass MeasurableVAdd₂ (M α : Type*) [VAdd M α] [MeasurableSpace M] [MeasurableSpace α] :\n    Prop where\n  measurable_vadd : Measurable (Function.uncurry (· +ᵥ ·) : M × α → α)\n\n"}
{"name":"MeasurableSMul₂.measurable_smul","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\ninst✝² : SMul M α\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableSpace α\nself : MeasurableSMul₂ M α\n⊢ Measurable (Function.uncurry fun x1 x2 => HSMul.hSMul x1 x2)","decl":"/-- We say that the action of `M` on `α` has `Measurable_SMul₂` if the map\n`(c, x) ↦ c • x` is a measurable function. -/\n@[to_additive MeasurableVAdd₂]\nclass MeasurableSMul₂ (M α : Type*) [SMul M α] [MeasurableSpace M] [MeasurableSpace α] :\n    Prop where\n  measurable_smul : Measurable (Function.uncurry (· • ·) : M × α → α)\n\n"}
{"name":"measurableSMul_of_mul","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\ninst✝² : Mul M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableMul M\n⊢ MeasurableSMul M M","decl":"@[to_additive]\ninstance measurableSMul_of_mul (M : Type*) [Mul M] [MeasurableSpace M] [MeasurableMul M] :\n    MeasurableSMul M M :=\n  ⟨measurable_id.const_mul, measurable_id.mul_const⟩\n\n"}
{"name":"measurableVAdd_of_add","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\ninst✝² : Add M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableAdd M\n⊢ MeasurableVAdd M M","decl":"@[to_additive]\ninstance measurableSMul_of_mul (M : Type*) [Mul M] [MeasurableSpace M] [MeasurableMul M] :\n    MeasurableSMul M M :=\n  ⟨measurable_id.const_mul, measurable_id.mul_const⟩\n\n"}
{"name":"measurableSMul₂_of_mul","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\ninst✝² : Mul M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableMul₂ M\n⊢ MeasurableSMul₂ M M","decl":"@[to_additive]\ninstance measurableSMul₂_of_mul (M : Type*) [Mul M] [MeasurableSpace M] [MeasurableMul₂ M] :\n    MeasurableSMul₂ M M :=\n  ⟨measurable_mul⟩\n\n"}
{"name":"measurableSMul₂_of_add","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\ninst✝² : Add M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableAdd₂ M\n⊢ MeasurableVAdd₂ M M","decl":"@[to_additive]\ninstance measurableSMul₂_of_mul (M : Type*) [Mul M] [MeasurableSpace M] [MeasurableMul₂ M] :\n    MeasurableSMul₂ M M :=\n  ⟨measurable_mul⟩\n\n"}
{"name":"Submonoid.measurableSMul","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\ninst✝⁴ : MeasurableSpace M\ninst✝³ : MeasurableSpace α\ninst✝² : Monoid M\ninst✝¹ : MulAction M α\ninst✝ : MeasurableSMul M α\ns : Submonoid M\n⊢ MeasurableSMul (Subtype fun x => Membership.mem s x) α","decl":"@[to_additive]\ninstance Submonoid.measurableSMul {M α} [MeasurableSpace M] [MeasurableSpace α] [Monoid M]\n    [MulAction M α] [MeasurableSMul M α] (s : Submonoid M) : MeasurableSMul s α :=\n  ⟨fun c => by simpa only using measurable_const_smul (c : M), fun x =>\n    (measurable_smul_const x : Measurable fun c : M => c • x).comp measurable_subtype_coe⟩\n\n"}
{"name":"AddSubmonoid.measurableVAdd","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\ninst✝⁴ : MeasurableSpace M\ninst✝³ : MeasurableSpace α\ninst✝² : AddMonoid M\ninst✝¹ : AddAction M α\ninst✝ : MeasurableVAdd M α\ns : AddSubmonoid M\n⊢ MeasurableVAdd (Subtype fun x => Membership.mem s x) α","decl":"@[to_additive]\ninstance Submonoid.measurableSMul {M α} [MeasurableSpace M] [MeasurableSpace α] [Monoid M]\n    [MulAction M α] [MeasurableSMul M α] (s : Submonoid M) : MeasurableSMul s α :=\n  ⟨fun c => by simpa only using measurable_const_smul (c : M), fun x =>\n    (measurable_smul_const x : Measurable fun c : M => c • x).comp measurable_subtype_coe⟩\n\n"}
{"name":"AddSubgroup.measurableVAdd","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\nα : Type u_3\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableSpace α\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : MeasurableVAdd G α\ns : AddSubgroup G\n⊢ MeasurableVAdd (Subtype fun x => Membership.mem s x) α","decl":"@[to_additive]\ninstance Subgroup.measurableSMul {G α} [MeasurableSpace G] [MeasurableSpace α] [Group G]\n    [MulAction G α] [MeasurableSMul G α] (s : Subgroup G) : MeasurableSMul s α :=\n  s.toSubmonoid.measurableSMul\n\n"}
{"name":"Subgroup.measurableSMul","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"G : Type u_2\nα : Type u_3\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableSpace α\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : MeasurableSMul G α\ns : Subgroup G\n⊢ MeasurableSMul (Subtype fun x => Membership.mem s x) α","decl":"@[to_additive]\ninstance Subgroup.measurableSMul {G α} [MeasurableSpace G] [MeasurableSpace α] [Group G]\n    [MulAction G α] [MeasurableSMul G α] (s : Subgroup G) : MeasurableSMul s α :=\n  s.toSubmonoid.measurableSMul\n\n"}
{"name":"Measurable.vadd","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nX : Type u_3\nα : Type u_4\ninst✝³ : MeasurableSpace M\ninst✝² : MeasurableSpace X\ninst✝¹ : VAdd M X\nm : MeasurableSpace α\nf : α → M\ng : α → X\ninst✝ : MeasurableVAdd₂ M X\nhf : Measurable f\nhg : Measurable g\n⊢ Measurable fun x => HVAdd.hVAdd (f x) (g x)","decl":"@[to_additive (attr := fun_prop, aesop safe 20 apply (rule_sets := [Measurable]))]\ntheorem Measurable.smul [MeasurableSMul₂ M X] (hf : Measurable f) (hg : Measurable g) :\n    Measurable fun x => f x • g x :=\n  measurable_smul.comp (hf.prod_mk hg)\n\n"}
{"name":"Measurable.smul","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nX : Type u_3\nα : Type u_4\ninst✝³ : MeasurableSpace M\ninst✝² : MeasurableSpace X\ninst✝¹ : SMul M X\nm : MeasurableSpace α\nf : α → M\ng : α → X\ninst✝ : MeasurableSMul₂ M X\nhf : Measurable f\nhg : Measurable g\n⊢ Measurable fun x => HSMul.hSMul (f x) (g x)","decl":"@[to_additive (attr := fun_prop, aesop safe 20 apply (rule_sets := [Measurable]))]\ntheorem Measurable.smul [MeasurableSMul₂ M X] (hf : Measurable f) (hg : Measurable g) :\n    Measurable fun x => f x • g x :=\n  measurable_smul.comp (hf.prod_mk hg)\n\n"}
{"name":"Measurable.smul'","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nX : Type u_3\nα : Type u_4\nβ : Type u_5\ninst✝³ : MeasurableSpace M\ninst✝² : MeasurableSpace X\ninst✝¹ : SMul M X\nm : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝ : MeasurableSMul₂ M X\nf : α → β → M\ng : α → β → X\nh : α → β\nhf : Measurable (Function.HasUncurry.uncurry f)\nhg : Measurable (Function.HasUncurry.uncurry g)\nhh : Measurable h\n⊢ Measurable fun a => HSMul.hSMul (f a) (g a) (h a)","decl":"/-- Compositional version of `Measurable.smul` for use by `fun_prop`. -/\n@[to_additive (attr := fun_prop)\n\"Compositional version of `Measurable.vadd` for use by `fun_prop`.\"]\nlemma Measurable.smul' [MeasurableSMul₂ M X] {f : α → β → M} {g : α → β → X} {h : α → β}\n    (hf : Measurable ↿f) (hg : Measurable ↿g) (hh : Measurable h) :\n    Measurable fun a ↦ (f a • g a) (h a) := by simp; fun_prop\n\n"}
{"name":"Measurable.vadd'","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nX : Type u_3\nα : Type u_4\nβ : Type u_5\ninst✝³ : MeasurableSpace M\ninst✝² : MeasurableSpace X\ninst✝¹ : VAdd M X\nm : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝ : MeasurableVAdd₂ M X\nf : α → β → M\ng : α → β → X\nh : α → β\nhf : Measurable (Function.HasUncurry.uncurry f)\nhg : Measurable (Function.HasUncurry.uncurry g)\nhh : Measurable h\n⊢ Measurable fun a => HVAdd.hVAdd (f a) (g a) (h a)","decl":"/-- Compositional version of `Measurable.smul` for use by `fun_prop`. -/\n@[to_additive (attr := fun_prop)\n\"Compositional version of `Measurable.vadd` for use by `fun_prop`.\"]\nlemma Measurable.smul' [MeasurableSMul₂ M X] {f : α → β → M} {g : α → β → X} {h : α → β}\n    (hf : Measurable ↿f) (hg : Measurable ↿g) (hh : Measurable h) :\n    Measurable fun a ↦ (f a • g a) (h a) := by simp; fun_prop\n\n"}
{"name":"AEMeasurable.smul","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nX : Type u_3\nα : Type u_4\ninst✝³ : MeasurableSpace M\ninst✝² : MeasurableSpace X\ninst✝¹ : SMul M X\nm : MeasurableSpace α\nf : α → M\ng : α → X\ninst✝ : MeasurableSMul₂ M X\nμ : MeasureTheory.Measure α\nhf : AEMeasurable f μ\nhg : AEMeasurable g μ\n⊢ AEMeasurable (fun x => HSMul.hSMul (f x) (g x)) μ","decl":"@[to_additive (attr := fun_prop, aesop safe 20 apply (rule_sets := [Measurable]))]\ntheorem AEMeasurable.smul [MeasurableSMul₂ M X] {μ : Measure α} (hf : AEMeasurable f μ)\n    (hg : AEMeasurable g μ) : AEMeasurable (fun x => f x • g x) μ :=\n  MeasurableSMul₂.measurable_smul.comp_aemeasurable (hf.prod_mk hg)\n\n"}
{"name":"AEMeasurable.vadd","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nX : Type u_3\nα : Type u_4\ninst✝³ : MeasurableSpace M\ninst✝² : MeasurableSpace X\ninst✝¹ : VAdd M X\nm : MeasurableSpace α\nf : α → M\ng : α → X\ninst✝ : MeasurableVAdd₂ M X\nμ : MeasureTheory.Measure α\nhf : AEMeasurable f μ\nhg : AEMeasurable g μ\n⊢ AEMeasurable (fun x => HVAdd.hVAdd (f x) (g x)) μ","decl":"@[to_additive (attr := fun_prop, aesop safe 20 apply (rule_sets := [Measurable]))]\ntheorem AEMeasurable.smul [MeasurableSMul₂ M X] {μ : Measure α} (hf : AEMeasurable f μ)\n    (hg : AEMeasurable g μ) : AEMeasurable (fun x => f x • g x) μ :=\n  MeasurableSMul₂.measurable_smul.comp_aemeasurable (hf.prod_mk hg)\n\n"}
{"name":"MeasurableSMul₂.toMeasurableSMul","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nX : Type u_3\ninst✝³ : MeasurableSpace M\ninst✝² : MeasurableSpace X\ninst✝¹ : SMul M X\ninst✝ : MeasurableSMul₂ M X\n⊢ MeasurableSMul M X","decl":"@[to_additive]\ninstance (priority := 100) MeasurableSMul₂.toMeasurableSMul [MeasurableSMul₂ M X] :\n    MeasurableSMul M X :=\n  ⟨fun _ => measurable_const.smul measurable_id, fun _ => measurable_id.smul measurable_const⟩\n\n"}
{"name":"MeasurableVAdd₂.toMeasurableVAdd","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nX : Type u_3\ninst✝³ : MeasurableSpace M\ninst✝² : MeasurableSpace X\ninst✝¹ : VAdd M X\ninst✝ : MeasurableVAdd₂ M X\n⊢ MeasurableVAdd M X","decl":"@[to_additive]\ninstance (priority := 100) MeasurableSMul₂.toMeasurableSMul [MeasurableSMul₂ M X] :\n    MeasurableSMul M X :=\n  ⟨fun _ => measurable_const.smul measurable_id, fun _ => measurable_id.smul measurable_const⟩\n\n"}
{"name":"Measurable.smul_const","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nX : Type u_3\nα : Type u_4\ninst✝³ : MeasurableSpace M\ninst✝² : MeasurableSpace X\ninst✝¹ : SMul M X\nm : MeasurableSpace α\nf : α → M\ninst✝ : MeasurableSMul M X\nhf : Measurable f\ny : X\n⊢ Measurable fun x => HSMul.hSMul (f x) y","decl":"@[to_additive (attr := measurability)]\ntheorem Measurable.smul_const (hf : Measurable f) (y : X) : Measurable fun x => f x • y :=\n  (MeasurableSMul.measurable_smul_const y).comp hf\n\n"}
{"name":"Measurable.vadd_const","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nX : Type u_3\nα : Type u_4\ninst✝³ : MeasurableSpace M\ninst✝² : MeasurableSpace X\ninst✝¹ : VAdd M X\nm : MeasurableSpace α\nf : α → M\ninst✝ : MeasurableVAdd M X\nhf : Measurable f\ny : X\n⊢ Measurable fun x => HVAdd.hVAdd (f x) y","decl":"@[to_additive (attr := measurability)]\ntheorem Measurable.smul_const (hf : Measurable f) (y : X) : Measurable fun x => f x • y :=\n  (MeasurableSMul.measurable_smul_const y).comp hf\n\n"}
{"name":"AEMeasurable.vadd_const","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nX : Type u_3\nα : Type u_4\ninst✝³ : MeasurableSpace M\ninst✝² : MeasurableSpace X\ninst✝¹ : VAdd M X\nm : MeasurableSpace α\nf : α → M\ninst✝ : MeasurableVAdd M X\nμ : MeasureTheory.Measure α\nhf : AEMeasurable f μ\ny : X\n⊢ AEMeasurable (fun x => HVAdd.hVAdd (f x) y) μ","decl":"@[to_additive (attr := measurability)]\ntheorem AEMeasurable.smul_const (hf : AEMeasurable f μ) (y : X) :\n    AEMeasurable (fun x => f x • y) μ :=\n  (MeasurableSMul.measurable_smul_const y).comp_aemeasurable hf\n\n"}
{"name":"AEMeasurable.smul_const","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nX : Type u_3\nα : Type u_4\ninst✝³ : MeasurableSpace M\ninst✝² : MeasurableSpace X\ninst✝¹ : SMul M X\nm : MeasurableSpace α\nf : α → M\ninst✝ : MeasurableSMul M X\nμ : MeasureTheory.Measure α\nhf : AEMeasurable f μ\ny : X\n⊢ AEMeasurable (fun x => HSMul.hSMul (f x) y) μ","decl":"@[to_additive (attr := measurability)]\ntheorem AEMeasurable.smul_const (hf : AEMeasurable f μ) (y : X) :\n    AEMeasurable (fun x => f x • y) μ :=\n  (MeasurableSMul.measurable_smul_const y).comp_aemeasurable hf\n\n"}
{"name":"Measurable.const_vadd","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nX : Type u_3\nα : Type u_4\ninst✝³ : MeasurableSpace M\ninst✝² : MeasurableSpace X\ninst✝¹ : VAdd M X\nm : MeasurableSpace α\ng : α → X\ninst✝ : MeasurableVAdd M X\nhg : Measurable g\nc : M\n⊢ Measurable (HVAdd.hVAdd c g)","decl":"@[to_additive (attr := fun_prop, measurability)]\ntheorem Measurable.const_smul (hg : Measurable g) (c : M) : Measurable (c • g) :=\n  (MeasurableSMul.measurable_const_smul c).comp hg\n\n"}
{"name":"Measurable.const_smul","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nX : Type u_3\nα : Type u_4\ninst✝³ : MeasurableSpace M\ninst✝² : MeasurableSpace X\ninst✝¹ : SMul M X\nm : MeasurableSpace α\ng : α → X\ninst✝ : MeasurableSMul M X\nhg : Measurable g\nc : M\n⊢ Measurable (HSMul.hSMul c g)","decl":"@[to_additive (attr := fun_prop, measurability)]\ntheorem Measurable.const_smul (hg : Measurable g) (c : M) : Measurable (c • g) :=\n  (MeasurableSMul.measurable_const_smul c).comp hg\n\n"}
{"name":"Measurable.const_vadd'","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nX : Type u_3\nα : Type u_4\nβ : Type u_5\ninst✝³ : MeasurableSpace M\ninst✝² : MeasurableSpace X\ninst✝¹ : VAdd M X\nm : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝ : MeasurableVAdd M X\ng : α → β → X\nh : α → β\nhg : Measurable (Function.HasUncurry.uncurry g)\nhh : Measurable h\nc : M\n⊢ Measurable fun a => HVAdd.hVAdd c (g a) (h a)","decl":"/-- Compositional version of `Measurable.const_smul` for use by `fun_prop`. -/\n@[to_additive (attr := fun_prop)\n\"Compositional version of `Measurable.const_vadd` for use by `fun_prop`.\"]\nlemma Measurable.const_smul' {g : α → β → X} {h : α → β} (hg : Measurable ↿g) (hh : Measurable h)\n    (c : M) : Measurable fun a ↦ (c • g a) (h a) :=\n  (hg.comp <| measurable_id.prod_mk hh).const_smul _\n\n"}
{"name":"Measurable.const_smul'","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nX : Type u_3\nα : Type u_4\nβ : Type u_5\ninst✝³ : MeasurableSpace M\ninst✝² : MeasurableSpace X\ninst✝¹ : SMul M X\nm : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝ : MeasurableSMul M X\ng : α → β → X\nh : α → β\nhg : Measurable (Function.HasUncurry.uncurry g)\nhh : Measurable h\nc : M\n⊢ Measurable fun a => HSMul.hSMul c (g a) (h a)","decl":"/-- Compositional version of `Measurable.const_smul` for use by `fun_prop`. -/\n@[to_additive (attr := fun_prop)\n\"Compositional version of `Measurable.const_vadd` for use by `fun_prop`.\"]\nlemma Measurable.const_smul' {g : α → β → X} {h : α → β} (hg : Measurable ↿g) (hh : Measurable h)\n    (c : M) : Measurable fun a ↦ (c • g a) (h a) :=\n  (hg.comp <| measurable_id.prod_mk hh).const_smul _\n\n"}
{"name":"AEMeasurable.const_smul'","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nX : Type u_3\nα : Type u_4\ninst✝³ : MeasurableSpace M\ninst✝² : MeasurableSpace X\ninst✝¹ : SMul M X\nm : MeasurableSpace α\ng : α → X\ninst✝ : MeasurableSMul M X\nμ : MeasureTheory.Measure α\nhg : AEMeasurable g μ\nc : M\n⊢ AEMeasurable (fun x => HSMul.hSMul c (g x)) μ","decl":"@[to_additive (attr := measurability)]\ntheorem AEMeasurable.const_smul' (hg : AEMeasurable g μ) (c : M) :\n    AEMeasurable (fun x => c • g x) μ :=\n  (MeasurableSMul.measurable_const_smul c).comp_aemeasurable hg\n\n"}
{"name":"AEMeasurable.const_vadd'","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nX : Type u_3\nα : Type u_4\ninst✝³ : MeasurableSpace M\ninst✝² : MeasurableSpace X\ninst✝¹ : VAdd M X\nm : MeasurableSpace α\ng : α → X\ninst✝ : MeasurableVAdd M X\nμ : MeasureTheory.Measure α\nhg : AEMeasurable g μ\nc : M\n⊢ AEMeasurable (fun x => HVAdd.hVAdd c (g x)) μ","decl":"@[to_additive (attr := measurability)]\ntheorem AEMeasurable.const_smul' (hg : AEMeasurable g μ) (c : M) :\n    AEMeasurable (fun x => c • g x) μ :=\n  (MeasurableSMul.measurable_const_smul c).comp_aemeasurable hg\n\n"}
{"name":"AEMeasurable.const_smul","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nX : Type u_3\nα : Type u_4\ninst✝³ : MeasurableSpace M\ninst✝² : MeasurableSpace X\ninst✝¹ : SMul M X\nm : MeasurableSpace α\ng : α → X\ninst✝ : MeasurableSMul M X\nμ : MeasureTheory.Measure α\nhf : AEMeasurable g μ\nc : M\n⊢ AEMeasurable (HSMul.hSMul c g) μ","decl":"@[to_additive (attr := measurability)]\ntheorem AEMeasurable.const_smul (hf : AEMeasurable g μ) (c : M) : AEMeasurable (c • g) μ :=\n  hf.const_smul' c\n\n"}
{"name":"AEMeasurable.const_vadd","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nX : Type u_3\nα : Type u_4\ninst✝³ : MeasurableSpace M\ninst✝² : MeasurableSpace X\ninst✝¹ : VAdd M X\nm : MeasurableSpace α\ng : α → X\ninst✝ : MeasurableVAdd M X\nμ : MeasureTheory.Measure α\nhf : AEMeasurable g μ\nc : M\n⊢ AEMeasurable (HVAdd.hVAdd c g) μ","decl":"@[to_additive (attr := measurability)]\ntheorem AEMeasurable.const_smul (hf : AEMeasurable g μ) (c : M) : AEMeasurable (c • g) μ :=\n  hf.const_smul' c\n\n"}
{"name":"Pi.measurableVAdd","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\ninst✝³ : MeasurableSpace M\nι : Type u_6\nα : ι → Type u_7\ninst✝² : (i : ι) → VAdd M (α i)\ninst✝¹ : (i : ι) → MeasurableSpace (α i)\ninst✝ : ∀ (i : ι), MeasurableVAdd M (α i)\n⊢ MeasurableVAdd M ((i : ι) → α i)","decl":"@[to_additive]\ninstance Pi.measurableSMul {ι : Type*} {α : ι → Type*} [∀ i, SMul M (α i)]\n    [∀ i, MeasurableSpace (α i)] [∀ i, MeasurableSMul M (α i)] :\n    MeasurableSMul M (∀ i, α i) :=\n  ⟨fun _ => measurable_pi_iff.mpr fun i => (measurable_pi_apply i).const_smul _, fun _ =>\n    measurable_pi_iff.mpr fun _ => measurable_smul_const _⟩\n\n"}
{"name":"Pi.measurableSMul","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\ninst✝³ : MeasurableSpace M\nι : Type u_6\nα : ι → Type u_7\ninst✝² : (i : ι) → SMul M (α i)\ninst✝¹ : (i : ι) → MeasurableSpace (α i)\ninst✝ : ∀ (i : ι), MeasurableSMul M (α i)\n⊢ MeasurableSMul M ((i : ι) → α i)","decl":"@[to_additive]\ninstance Pi.measurableSMul {ι : Type*} {α : ι → Type*} [∀ i, SMul M (α i)]\n    [∀ i, MeasurableSpace (α i)] [∀ i, MeasurableSMul M (α i)] :\n    MeasurableSMul M (∀ i, α i) :=\n  ⟨fun _ => measurable_pi_iff.mpr fun i => (measurable_pi_apply i).const_smul _, fun _ =>\n    measurable_pi_iff.mpr fun _ => measurable_smul_const _⟩\n\n"}
{"name":"AddMonoid.measurableSMul_nat₂","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_6\ninst✝² : AddMonoid M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableAdd₂ M\n⊢ MeasurableSMul₂ Nat M","decl":"/-- `AddMonoid.SMul` is measurable. -/\ninstance AddMonoid.measurableSMul_nat₂ (M : Type*) [AddMonoid M] [MeasurableSpace M]\n    [MeasurableAdd₂ M] : MeasurableSMul₂ ℕ M :=\n  ⟨by\n    suffices Measurable fun p : M × ℕ => p.2 • p.1 by apply this.comp measurable_swap\n    refine measurable_from_prod_countable fun n => ?_\n    induction' n with n ih\n    · simp only [zero_smul, ← Pi.zero_def, measurable_zero]\n    · simp only [succ_nsmul]\n      exact ih.add measurable_id⟩\n\n"}
{"name":"SubNegMonoid.measurableSMul_int₂","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_6\ninst✝³ : SubNegMonoid M\ninst✝² : MeasurableSpace M\ninst✝¹ : MeasurableAdd₂ M\ninst✝ : MeasurableNeg M\n⊢ MeasurableSMul₂ Int M","decl":"/-- `SubNegMonoid.SMulInt` is measurable. -/\ninstance SubNegMonoid.measurableSMul_int₂ (M : Type*) [SubNegMonoid M] [MeasurableSpace M]\n    [MeasurableAdd₂ M] [MeasurableNeg M] : MeasurableSMul₂ ℤ M :=\n  ⟨by\n    suffices Measurable fun p : M × ℤ => p.2 • p.1 by apply this.comp measurable_swap\n    refine measurable_from_prod_countable fun n => ?_\n    induction' n with n n ih\n    · simp only [Int.ofNat_eq_coe, natCast_zsmul]\n      exact measurable_const_smul _\n    · simp only [negSucc_zsmul]\n      exact (measurable_const_smul _).neg⟩\n\n"}
{"name":"Measurable.measurableSMul₂_iterateAddAct","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_2\nx✝ : MeasurableSpace α\nf : α → α\nh : Measurable f\n⊢ MeasurableVAdd₂ (IterateAddAct f) α","decl":"@[to_additive]\ntheorem Measurable.measurableSMul₂_iterateMulAct (h : Measurable f) :\n    MeasurableSMul₂ (IterateMulAct f) α where\n  measurable_smul :=\n    suffices Measurable fun p : α × IterateMulAct f ↦ f^[p.2.val] p.1 from this.comp measurable_swap\n    measurable_from_prod_countable fun n ↦ h.iterate n.val\n\n"}
{"name":"Measurable.measurableSMul₂_iterateMulAct","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_2\nx✝ : MeasurableSpace α\nf : α → α\nh : Measurable f\n⊢ MeasurableSMul₂ (IterateMulAct f) α","decl":"@[to_additive]\ntheorem Measurable.measurableSMul₂_iterateMulAct (h : Measurable f) :\n    MeasurableSMul₂ (IterateMulAct f) α where\n  measurable_smul :=\n    suffices Measurable fun p : α × IterateMulAct f ↦ f^[p.2.val] p.1 from this.comp measurable_swap\n    measurable_from_prod_countable fun n ↦ h.iterate n.val\n\n"}
{"name":"measurableVAdd_iterateAddAct","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_2\nx✝ : MeasurableSpace α\nf : α → α\n⊢ Iff (MeasurableVAdd (IterateAddAct f) α) (Measurable f)","decl":"@[to_additive (attr := simp)]\ntheorem measurableSMul_iterateMulAct : MeasurableSMul (IterateMulAct f) α ↔ Measurable f :=\n  ⟨fun _ ↦ measurable_const_smul (IterateMulAct.mk (f := f) 1), fun h ↦\n    have := h.measurableSMul₂_iterateMulAct; inferInstance⟩\n\n"}
{"name":"measurableSMul_iterateMulAct","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_2\nx✝ : MeasurableSpace α\nf : α → α\n⊢ Iff (MeasurableSMul (IterateMulAct f) α) (Measurable f)","decl":"@[to_additive (attr := simp)]\ntheorem measurableSMul_iterateMulAct : MeasurableSMul (IterateMulAct f) α ↔ Measurable f :=\n  ⟨fun _ ↦ measurable_const_smul (IterateMulAct.mk (f := f) 1), fun h ↦\n    have := h.measurableSMul₂_iterateMulAct; inferInstance⟩\n\n"}
{"name":"measurableSMul₂_iterateMulAct","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_2\nx✝ : MeasurableSpace α\nf : α → α\n⊢ Iff (MeasurableSMul₂ (IterateMulAct f) α) (Measurable f)","decl":"@[to_additive (attr := simp)]\ntheorem measurableSMul₂_iterateMulAct : MeasurableSMul₂ (IterateMulAct f) α ↔ Measurable f :=\n  ⟨fun _ ↦ measurableSMul_iterateMulAct.mp inferInstance,\n    Measurable.measurableSMul₂_iterateMulAct⟩\n\n"}
{"name":"measurableSMul₂_iterateAddAct","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_2\nx✝ : MeasurableSpace α\nf : α → α\n⊢ Iff (MeasurableVAdd₂ (IterateAddAct f) α) (Measurable f)","decl":"@[to_additive (attr := simp)]\ntheorem measurableSMul₂_iterateMulAct : MeasurableSMul₂ (IterateMulAct f) α ↔ Measurable f :=\n  ⟨fun _ ↦ measurableSMul_iterateMulAct.mp inferInstance,\n    Measurable.measurableSMul₂_iterateMulAct⟩\n\n"}
{"name":"measurable_const_vadd_iff","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"β : Type u_3\nα : Type u_4\ninst✝⁵ : MeasurableSpace β\ninst✝⁴ : MeasurableSpace α\nf : α → β\nG : Type u_5\ninst✝³ : AddGroup G\ninst✝² : MeasurableSpace G\ninst✝¹ : AddAction G β\ninst✝ : MeasurableVAdd G β\nc : G\n⊢ Iff (Measurable fun x => HVAdd.hVAdd c (f x)) (Measurable f)","decl":"@[to_additive]\ntheorem measurable_const_smul_iff (c : G) : (Measurable fun x => c • f x) ↔ Measurable f :=\n  ⟨fun h => by simpa [inv_smul_smul, Pi.smul_def] using h.const_smul c⁻¹, fun h => h.const_smul c⟩\n\n"}
{"name":"measurable_const_smul_iff","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"β : Type u_3\nα : Type u_4\ninst✝⁵ : MeasurableSpace β\ninst✝⁴ : MeasurableSpace α\nf : α → β\nG : Type u_5\ninst✝³ : Group G\ninst✝² : MeasurableSpace G\ninst✝¹ : MulAction G β\ninst✝ : MeasurableSMul G β\nc : G\n⊢ Iff (Measurable fun x => HSMul.hSMul c (f x)) (Measurable f)","decl":"@[to_additive]\ntheorem measurable_const_smul_iff (c : G) : (Measurable fun x => c • f x) ↔ Measurable f :=\n  ⟨fun h => by simpa [inv_smul_smul, Pi.smul_def] using h.const_smul c⁻¹, fun h => h.const_smul c⟩\n\n"}
{"name":"aemeasurable_const_smul_iff","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"β : Type u_3\nα : Type u_4\ninst✝⁵ : MeasurableSpace β\ninst✝⁴ : MeasurableSpace α\nf : α → β\nμ : MeasureTheory.Measure α\nG : Type u_5\ninst✝³ : Group G\ninst✝² : MeasurableSpace G\ninst✝¹ : MulAction G β\ninst✝ : MeasurableSMul G β\nc : G\n⊢ Iff (AEMeasurable (fun x => HSMul.hSMul c (f x)) μ) (AEMeasurable f μ)","decl":"@[to_additive]\ntheorem aemeasurable_const_smul_iff (c : G) :\n    AEMeasurable (fun x => c • f x) μ ↔ AEMeasurable f μ :=\n  ⟨fun h => by simpa [inv_smul_smul, Pi.smul_def] using h.const_smul c⁻¹, fun h => h.const_smul c⟩\n\n"}
{"name":"aemeasurable_const_vadd_iff","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"β : Type u_3\nα : Type u_4\ninst✝⁵ : MeasurableSpace β\ninst✝⁴ : MeasurableSpace α\nf : α → β\nμ : MeasureTheory.Measure α\nG : Type u_5\ninst✝³ : AddGroup G\ninst✝² : MeasurableSpace G\ninst✝¹ : AddAction G β\ninst✝ : MeasurableVAdd G β\nc : G\n⊢ Iff (AEMeasurable (fun x => HVAdd.hVAdd c (f x)) μ) (AEMeasurable f μ)","decl":"@[to_additive]\ntheorem aemeasurable_const_smul_iff (c : G) :\n    AEMeasurable (fun x => c • f x) μ ↔ AEMeasurable f μ :=\n  ⟨fun h => by simpa [inv_smul_smul, Pi.smul_def] using h.const_smul c⁻¹, fun h => h.const_smul c⟩\n\n"}
{"name":"Units.measurableSMul","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nβ : Type u_3\ninst✝⁴ : MeasurableSpace M\ninst✝³ : MeasurableSpace β\ninst✝² : Monoid M\ninst✝¹ : MulAction M β\ninst✝ : MeasurableSMul M β\n⊢ MeasurableSMul (Units M) β","decl":"@[to_additive]\ninstance Units.measurableSMul : MeasurableSMul Mˣ β where\n  measurable_const_smul c := measurable_const_smul (c : M)\n  measurable_smul_const x :=\n    (measurable_smul_const x : Measurable fun c : M => c • x).comp MeasurableSpace.le_map_comap\n\n"}
{"name":"AddUnits.measurableVAdd","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nβ : Type u_3\ninst✝⁴ : MeasurableSpace M\ninst✝³ : MeasurableSpace β\ninst✝² : AddMonoid M\ninst✝¹ : AddAction M β\ninst✝ : MeasurableVAdd M β\n⊢ MeasurableVAdd (AddUnits M) β","decl":"@[to_additive]\ninstance Units.measurableSMul : MeasurableSMul Mˣ β where\n  measurable_const_smul c := measurable_const_smul (c : M)\n  measurable_smul_const x :=\n    (measurable_smul_const x : Measurable fun c : M => c • x).comp MeasurableSpace.le_map_comap\n\n"}
{"name":"IsUnit.measurable_const_smul_iff","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nβ : Type u_3\nα : Type u_4\ninst✝⁵ : MeasurableSpace M\ninst✝⁴ : MeasurableSpace β\ninst✝³ : Monoid M\ninst✝² : MulAction M β\ninst✝¹ : MeasurableSMul M β\ninst✝ : MeasurableSpace α\nf : α → β\nc : M\nhc : IsUnit c\n⊢ Iff (Measurable fun x => HSMul.hSMul c (f x)) (Measurable f)","decl":"@[to_additive]\nnonrec theorem IsUnit.measurable_const_smul_iff {c : M} (hc : IsUnit c) :\n    (Measurable fun x => c • f x) ↔ Measurable f :=\n  let ⟨u, hu⟩ := hc\n  hu ▸ measurable_const_smul_iff u\n\n"}
{"name":"IsAddUnit.measurable_const_vadd_iff","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nβ : Type u_3\nα : Type u_4\ninst✝⁵ : MeasurableSpace M\ninst✝⁴ : MeasurableSpace β\ninst✝³ : AddMonoid M\ninst✝² : AddAction M β\ninst✝¹ : MeasurableVAdd M β\ninst✝ : MeasurableSpace α\nf : α → β\nc : M\nhc : IsAddUnit c\n⊢ Iff (Measurable fun x => HVAdd.hVAdd c (f x)) (Measurable f)","decl":"@[to_additive]\nnonrec theorem IsUnit.measurable_const_smul_iff {c : M} (hc : IsUnit c) :\n    (Measurable fun x => c • f x) ↔ Measurable f :=\n  let ⟨u, hu⟩ := hc\n  hu ▸ measurable_const_smul_iff u\n\n"}
{"name":"IsAddUnit.aemeasurable_const_vadd_iff","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nβ : Type u_3\nα : Type u_4\ninst✝⁵ : MeasurableSpace M\ninst✝⁴ : MeasurableSpace β\ninst✝³ : AddMonoid M\ninst✝² : AddAction M β\ninst✝¹ : MeasurableVAdd M β\ninst✝ : MeasurableSpace α\nf : α → β\nμ : MeasureTheory.Measure α\nc : M\nhc : IsAddUnit c\n⊢ Iff (AEMeasurable (fun x => HVAdd.hVAdd c (f x)) μ) (AEMeasurable f μ)","decl":"@[to_additive]\nnonrec theorem IsUnit.aemeasurable_const_smul_iff {c : M} (hc : IsUnit c) :\n    AEMeasurable (fun x => c • f x) μ ↔ AEMeasurable f μ :=\n  let ⟨u, hu⟩ := hc\n  hu ▸ aemeasurable_const_smul_iff u\n\n"}
{"name":"IsUnit.aemeasurable_const_smul_iff","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nβ : Type u_3\nα : Type u_4\ninst✝⁵ : MeasurableSpace M\ninst✝⁴ : MeasurableSpace β\ninst✝³ : Monoid M\ninst✝² : MulAction M β\ninst✝¹ : MeasurableSMul M β\ninst✝ : MeasurableSpace α\nf : α → β\nμ : MeasureTheory.Measure α\nc : M\nhc : IsUnit c\n⊢ Iff (AEMeasurable (fun x => HSMul.hSMul c (f x)) μ) (AEMeasurable f μ)","decl":"@[to_additive]\nnonrec theorem IsUnit.aemeasurable_const_smul_iff {c : M} (hc : IsUnit c) :\n    AEMeasurable (fun x => c • f x) μ ↔ AEMeasurable f μ :=\n  let ⟨u, hu⟩ := hc\n  hu ▸ aemeasurable_const_smul_iff u\n\n"}
{"name":"measurable_const_smul_iff₀","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"β : Type u_3\nα : Type u_4\ninst✝⁵ : MeasurableSpace β\ninst✝⁴ : MeasurableSpace α\nf : α → β\nG₀ : Type u_6\ninst✝³ : GroupWithZero G₀\ninst✝² : MeasurableSpace G₀\ninst✝¹ : MulAction G₀ β\ninst✝ : MeasurableSMul G₀ β\nc : G₀\nhc : Ne c 0\n⊢ Iff (Measurable fun x => HSMul.hSMul c (f x)) (Measurable f)","decl":"theorem measurable_const_smul_iff₀ {c : G₀} (hc : c ≠ 0) :\n    (Measurable fun x => c • f x) ↔ Measurable f :=\n  (IsUnit.mk0 c hc).measurable_const_smul_iff\n\n"}
{"name":"aemeasurable_const_smul_iff₀","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"β : Type u_3\nα : Type u_4\ninst✝⁵ : MeasurableSpace β\ninst✝⁴ : MeasurableSpace α\nf : α → β\nμ : MeasureTheory.Measure α\nG₀ : Type u_6\ninst✝³ : GroupWithZero G₀\ninst✝² : MeasurableSpace G₀\ninst✝¹ : MulAction G₀ β\ninst✝ : MeasurableSMul G₀ β\nc : G₀\nhc : Ne c 0\n⊢ Iff (AEMeasurable (fun x => HSMul.hSMul c (f x)) μ) (AEMeasurable f μ)","decl":"theorem aemeasurable_const_smul_iff₀ {c : G₀} (hc : c ≠ 0) :\n    AEMeasurable (fun x => c • f x) μ ↔ AEMeasurable f μ :=\n  (IsUnit.mk0 c hc).aemeasurable_const_smul_iff\n\n"}
{"name":"measurable_add_op","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_2\ninst✝ : MeasurableSpace α\n⊢ Measurable AddOpposite.op","decl":"@[to_additive]\ntheorem measurable_mul_op {α : Type*} [MeasurableSpace α] : Measurable (op : α → αᵐᵒᵖ) := fun _ =>\n  id\n\n"}
{"name":"measurable_mul_op","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_2\ninst✝ : MeasurableSpace α\n⊢ Measurable MulOpposite.op","decl":"@[to_additive]\ntheorem measurable_mul_op {α : Type*} [MeasurableSpace α] : Measurable (op : α → αᵐᵒᵖ) := fun _ =>\n  id\n\n"}
{"name":"measurable_add_unop","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_2\ninst✝ : MeasurableSpace α\n⊢ Measurable AddOpposite.unop","decl":"@[to_additive]\ntheorem measurable_mul_unop {α : Type*} [MeasurableSpace α] : Measurable (unop : αᵐᵒᵖ → α) :=\n  fun _ => id\n\n"}
{"name":"measurable_mul_unop","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_2\ninst✝ : MeasurableSpace α\n⊢ Measurable MulOpposite.unop","decl":"@[to_additive]\ntheorem measurable_mul_unop {α : Type*} [MeasurableSpace α] : Measurable (unop : αᵐᵒᵖ → α) :=\n  fun _ => id\n\n"}
{"name":"MulOpposite.instMeasurableMul","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\ninst✝² : Mul M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableMul M\n⊢ MeasurableMul (MulOpposite M)","decl":"@[to_additive]\ninstance MulOpposite.instMeasurableMul {M : Type*} [Mul M] [MeasurableSpace M]\n    [MeasurableMul M] : MeasurableMul Mᵐᵒᵖ :=\n  ⟨fun _ => measurable_mul_op.comp (measurable_mul_unop.mul_const _), fun _ =>\n    measurable_mul_op.comp (measurable_mul_unop.const_mul _)⟩\n\n"}
{"name":"AddOpposite.instMeasurableAdd","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\ninst✝² : Add M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableAdd M\n⊢ MeasurableAdd (AddOpposite M)","decl":"@[to_additive]\ninstance MulOpposite.instMeasurableMul {M : Type*} [Mul M] [MeasurableSpace M]\n    [MeasurableMul M] : MeasurableMul Mᵐᵒᵖ :=\n  ⟨fun _ => measurable_mul_op.comp (measurable_mul_unop.mul_const _), fun _ =>\n    measurable_mul_op.comp (measurable_mul_unop.const_mul _)⟩\n\n"}
{"name":"MulOpposite.instMeasurableMul₂","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\ninst✝² : Mul M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableMul₂ M\n⊢ MeasurableMul₂ (MulOpposite M)","decl":"@[to_additive]\ninstance MulOpposite.instMeasurableMul₂ {M : Type*} [Mul M] [MeasurableSpace M]\n    [MeasurableMul₂ M] : MeasurableMul₂ Mᵐᵒᵖ :=\n  ⟨measurable_mul_op.comp\n      ((measurable_mul_unop.comp measurable_snd).mul (measurable_mul_unop.comp measurable_fst))⟩\n\n"}
{"name":"AddOpposite.instMeasurableMul₂","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\ninst✝² : Add M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableAdd₂ M\n⊢ MeasurableAdd₂ (AddOpposite M)","decl":"@[to_additive]\ninstance MulOpposite.instMeasurableMul₂ {M : Type*} [Mul M] [MeasurableSpace M]\n    [MeasurableMul₂ M] : MeasurableMul₂ Mᵐᵒᵖ :=\n  ⟨measurable_mul_op.comp\n      ((measurable_mul_unop.comp measurable_snd).mul (measurable_mul_unop.comp measurable_fst))⟩\n\n"}
{"name":"MeasurableSMul.op","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\ninst✝⁵ : MeasurableSpace M\ninst✝⁴ : MeasurableSpace α\ninst✝³ : SMul M α\ninst✝² : SMul (MulOpposite M) α\ninst✝¹ : IsCentralScalar M α\ninst✝ : MeasurableSMul M α\n⊢ MeasurableSMul (MulOpposite M) α","decl":"/-- If a scalar is central, then its right action is measurable when its left action is. -/\nnonrec instance MeasurableSMul.op {M α} [MeasurableSpace M] [MeasurableSpace α] [SMul M α]\n    [SMul Mᵐᵒᵖ α] [IsCentralScalar M α] [MeasurableSMul M α] : MeasurableSMul Mᵐᵒᵖ α :=\n  ⟨MulOpposite.rec' fun c =>\n      show Measurable fun x => op c • x by\n        simpa only [op_smul_eq_smul] using measurable_const_smul c,\n    fun x =>\n    show Measurable fun c => op (unop c) • x by\n      simpa only [op_smul_eq_smul] using (measurable_smul_const x).comp measurable_mul_unop⟩\n\n"}
{"name":"MeasurableSMul₂.op","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\ninst✝⁵ : MeasurableSpace M\ninst✝⁴ : MeasurableSpace α\ninst✝³ : SMul M α\ninst✝² : SMul (MulOpposite M) α\ninst✝¹ : IsCentralScalar M α\ninst✝ : MeasurableSMul₂ M α\n⊢ MeasurableSMul₂ (MulOpposite M) α","decl":"/-- If a scalar is central, then its right action is measurable when its left action is. -/\nnonrec instance MeasurableSMul₂.op {M α} [MeasurableSpace M] [MeasurableSpace α] [SMul M α]\n    [SMul Mᵐᵒᵖ α] [IsCentralScalar M α] [MeasurableSMul₂ M α] : MeasurableSMul₂ Mᵐᵒᵖ α :=\n  ⟨show Measurable fun x : Mᵐᵒᵖ × α => op (unop x.1) • x.2 by\n      simp_rw [op_smul_eq_smul]\n      exact (measurable_mul_unop.comp measurable_fst).smul measurable_snd⟩\n\n"}
{"name":"measurableSMul_opposite_of_mul","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\ninst✝² : Mul M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableMul M\n⊢ MeasurableSMul (MulOpposite M) M","decl":"@[to_additive]\ninstance measurableSMul_opposite_of_mul {M : Type*} [Mul M] [MeasurableSpace M]\n    [MeasurableMul M] : MeasurableSMul Mᵐᵒᵖ M :=\n  ⟨fun c => measurable_mul_const (unop c), fun x => measurable_mul_unop.const_mul x⟩\n\n"}
{"name":"measurableVAdd_opposite_of_add","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\ninst✝² : Add M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableAdd M\n⊢ MeasurableVAdd (AddOpposite M) M","decl":"@[to_additive]\ninstance measurableSMul_opposite_of_mul {M : Type*} [Mul M] [MeasurableSpace M]\n    [MeasurableMul M] : MeasurableSMul Mᵐᵒᵖ M :=\n  ⟨fun c => measurable_mul_const (unop c), fun x => measurable_mul_unop.const_mul x⟩\n\n"}
{"name":"measurableSMul₂_opposite_of_mul","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\ninst✝² : Mul M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableMul₂ M\n⊢ MeasurableSMul₂ (MulOpposite M) M","decl":"@[to_additive]\ninstance measurableSMul₂_opposite_of_mul {M : Type*} [Mul M] [MeasurableSpace M]\n    [MeasurableMul₂ M] : MeasurableSMul₂ Mᵐᵒᵖ M :=\n  ⟨measurable_snd.mul (measurable_mul_unop.comp measurable_fst)⟩\n\n"}
{"name":"measurableSMul₂_opposite_of_add","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\ninst✝² : Add M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableAdd₂ M\n⊢ MeasurableVAdd₂ (AddOpposite M) M","decl":"@[to_additive]\ninstance measurableSMul₂_opposite_of_mul {M : Type*} [Mul M] [MeasurableSpace M]\n    [MeasurableMul₂ M] : MeasurableSMul₂ Mᵐᵒᵖ M :=\n  ⟨measurable_snd.mul (measurable_mul_unop.comp measurable_fst)⟩\n\n"}
{"name":"List.measurable_sum'","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableAdd₂ M\nm : MeasurableSpace α\nl : List (α → M)\nhl : ∀ (f : α → M), Membership.mem l f → Measurable f\n⊢ Measurable l.sum","decl":"@[to_additive (attr := measurability)]\ntheorem List.measurable_prod' (l : List (α → M)) (hl : ∀ f ∈ l, Measurable f) :\n    Measurable l.prod := by\n  induction' l with f l ihl; · exact measurable_one\n  rw [List.forall_mem_cons] at hl\n  rw [List.prod_cons]\n  exact hl.1.mul (ihl hl.2)\n\n"}
{"name":"List.measurable_prod'","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\ninst✝² : Monoid M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableMul₂ M\nm : MeasurableSpace α\nl : List (α → M)\nhl : ∀ (f : α → M), Membership.mem l f → Measurable f\n⊢ Measurable l.prod","decl":"@[to_additive (attr := measurability)]\ntheorem List.measurable_prod' (l : List (α → M)) (hl : ∀ f ∈ l, Measurable f) :\n    Measurable l.prod := by\n  induction' l with f l ihl; · exact measurable_one\n  rw [List.forall_mem_cons] at hl\n  rw [List.prod_cons]\n  exact hl.1.mul (ihl hl.2)\n\n"}
{"name":"List.aemeasurable_prod'","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\ninst✝² : Monoid M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableMul₂ M\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : List (α → M)\nhl : ∀ (f : α → M), Membership.mem l f → AEMeasurable f μ\n⊢ AEMeasurable l.prod μ","decl":"@[to_additive (attr := measurability)]\ntheorem List.aemeasurable_prod' (l : List (α → M)) (hl : ∀ f ∈ l, AEMeasurable f μ) :\n    AEMeasurable l.prod μ := by\n  induction' l with f l ihl; · exact aemeasurable_one\n  rw [List.forall_mem_cons] at hl\n  rw [List.prod_cons]\n  exact hl.1.mul (ihl hl.2)\n\n"}
{"name":"List.aemeasurable_sum'","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableAdd₂ M\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : List (α → M)\nhl : ∀ (f : α → M), Membership.mem l f → AEMeasurable f μ\n⊢ AEMeasurable l.sum μ","decl":"@[to_additive (attr := measurability)]\ntheorem List.aemeasurable_prod' (l : List (α → M)) (hl : ∀ f ∈ l, AEMeasurable f μ) :\n    AEMeasurable l.prod μ := by\n  induction' l with f l ihl; · exact aemeasurable_one\n  rw [List.forall_mem_cons] at hl\n  rw [List.prod_cons]\n  exact hl.1.mul (ihl hl.2)\n\n"}
{"name":"List.measurable_sum","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableAdd₂ M\nm : MeasurableSpace α\nl : List (α → M)\nhl : ∀ (f : α → M), Membership.mem l f → Measurable f\n⊢ Measurable fun x => (List.map (fun f => f x) l).sum","decl":"@[to_additive (attr := measurability)]\ntheorem List.measurable_prod (l : List (α → M)) (hl : ∀ f ∈ l, Measurable f) :\n    Measurable fun x => (l.map fun f : α → M => f x).prod := by\n  simpa only [← Pi.list_prod_apply] using l.measurable_prod' hl\n\n"}
{"name":"List.measurable_prod","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\ninst✝² : Monoid M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableMul₂ M\nm : MeasurableSpace α\nl : List (α → M)\nhl : ∀ (f : α → M), Membership.mem l f → Measurable f\n⊢ Measurable fun x => (List.map (fun f => f x) l).prod","decl":"@[to_additive (attr := measurability)]\ntheorem List.measurable_prod (l : List (α → M)) (hl : ∀ f ∈ l, Measurable f) :\n    Measurable fun x => (l.map fun f : α → M => f x).prod := by\n  simpa only [← Pi.list_prod_apply] using l.measurable_prod' hl\n\n"}
{"name":"List.aemeasurable_prod","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\ninst✝² : Monoid M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableMul₂ M\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : List (α → M)\nhl : ∀ (f : α → M), Membership.mem l f → AEMeasurable f μ\n⊢ AEMeasurable (fun x => (List.map (fun f => f x) l).prod) μ","decl":"@[to_additive (attr := measurability)]\ntheorem List.aemeasurable_prod (l : List (α → M)) (hl : ∀ f ∈ l, AEMeasurable f μ) :\n    AEMeasurable (fun x => (l.map fun f : α → M => f x).prod) μ := by\n  simpa only [← Pi.list_prod_apply] using l.aemeasurable_prod' hl\n\n"}
{"name":"List.aemeasurable_sum","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableAdd₂ M\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : List (α → M)\nhl : ∀ (f : α → M), Membership.mem l f → AEMeasurable f μ\n⊢ AEMeasurable (fun x => (List.map (fun f => f x) l).sum) μ","decl":"@[to_additive (attr := measurability)]\ntheorem List.aemeasurable_prod (l : List (α → M)) (hl : ∀ f ∈ l, AEMeasurable f μ) :\n    AEMeasurable (fun x => (l.map fun f : α → M => f x).prod) μ := by\n  simpa only [← Pi.list_prod_apply] using l.aemeasurable_prod' hl\n\n"}
{"name":"Multiset.measurable_sum'","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_4\ninst✝² : AddCommMonoid M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableAdd₂ M\nm : MeasurableSpace α\nl : Multiset (α → M)\nhl : ∀ (f : α → M), Membership.mem l f → Measurable f\n⊢ Measurable l.sum","decl":"@[to_additive (attr := measurability)]\ntheorem Multiset.measurable_prod' (l : Multiset (α → M)) (hl : ∀ f ∈ l, Measurable f) :\n    Measurable l.prod := by\n  rcases l with ⟨l⟩\n  simpa using l.measurable_prod' (by simpa using hl)\n\n"}
{"name":"Multiset.measurable_prod'","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_4\ninst✝² : CommMonoid M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableMul₂ M\nm : MeasurableSpace α\nl : Multiset (α → M)\nhl : ∀ (f : α → M), Membership.mem l f → Measurable f\n⊢ Measurable l.prod","decl":"@[to_additive (attr := measurability)]\ntheorem Multiset.measurable_prod' (l : Multiset (α → M)) (hl : ∀ f ∈ l, Measurable f) :\n    Measurable l.prod := by\n  rcases l with ⟨l⟩\n  simpa using l.measurable_prod' (by simpa using hl)\n\n"}
{"name":"Multiset.aemeasurable_sum'","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_4\ninst✝² : AddCommMonoid M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableAdd₂ M\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Multiset (α → M)\nhl : ∀ (f : α → M), Membership.mem l f → AEMeasurable f μ\n⊢ AEMeasurable l.sum μ","decl":"@[to_additive (attr := measurability)]\ntheorem Multiset.aemeasurable_prod' (l : Multiset (α → M)) (hl : ∀ f ∈ l, AEMeasurable f μ) :\n    AEMeasurable l.prod μ := by\n  rcases l with ⟨l⟩\n  simpa using l.aemeasurable_prod' (by simpa using hl)\n\n"}
{"name":"Multiset.aemeasurable_prod'","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_4\ninst✝² : CommMonoid M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableMul₂ M\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Multiset (α → M)\nhl : ∀ (f : α → M), Membership.mem l f → AEMeasurable f μ\n⊢ AEMeasurable l.prod μ","decl":"@[to_additive (attr := measurability)]\ntheorem Multiset.aemeasurable_prod' (l : Multiset (α → M)) (hl : ∀ f ∈ l, AEMeasurable f μ) :\n    AEMeasurable l.prod μ := by\n  rcases l with ⟨l⟩\n  simpa using l.aemeasurable_prod' (by simpa using hl)\n\n"}
{"name":"Multiset.measurable_prod","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_4\ninst✝² : CommMonoid M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableMul₂ M\nm : MeasurableSpace α\ns : Multiset (α → M)\nhs : ∀ (f : α → M), Membership.mem s f → Measurable f\n⊢ Measurable fun x => (Multiset.map (fun f => f x) s).prod","decl":"@[to_additive (attr := measurability)]\ntheorem Multiset.measurable_prod (s : Multiset (α → M)) (hs : ∀ f ∈ s, Measurable f) :\n    Measurable fun x => (s.map fun f : α → M => f x).prod := by\n  simpa only [← Pi.multiset_prod_apply] using s.measurable_prod' hs\n\n"}
{"name":"Multiset.measurable_sum","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_4\ninst✝² : AddCommMonoid M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableAdd₂ M\nm : MeasurableSpace α\ns : Multiset (α → M)\nhs : ∀ (f : α → M), Membership.mem s f → Measurable f\n⊢ Measurable fun x => (Multiset.map (fun f => f x) s).sum","decl":"@[to_additive (attr := measurability)]\ntheorem Multiset.measurable_prod (s : Multiset (α → M)) (hs : ∀ f ∈ s, Measurable f) :\n    Measurable fun x => (s.map fun f : α → M => f x).prod := by\n  simpa only [← Pi.multiset_prod_apply] using s.measurable_prod' hs\n\n"}
{"name":"Multiset.aemeasurable_prod","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_4\ninst✝² : CommMonoid M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableMul₂ M\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Multiset (α → M)\nhs : ∀ (f : α → M), Membership.mem s f → AEMeasurable f μ\n⊢ AEMeasurable (fun x => (Multiset.map (fun f => f x) s).prod) μ","decl":"@[to_additive (attr := measurability)]\ntheorem Multiset.aemeasurable_prod (s : Multiset (α → M)) (hs : ∀ f ∈ s, AEMeasurable f μ) :\n    AEMeasurable (fun x => (s.map fun f : α → M => f x).prod) μ := by\n  simpa only [← Pi.multiset_prod_apply] using s.aemeasurable_prod' hs\n\n"}
{"name":"Multiset.aemeasurable_sum","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nα : Type u_4\ninst✝² : AddCommMonoid M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableAdd₂ M\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Multiset (α → M)\nhs : ∀ (f : α → M), Membership.mem s f → AEMeasurable f μ\n⊢ AEMeasurable (fun x => (Multiset.map (fun f => f x) s).sum) μ","decl":"@[to_additive (attr := measurability)]\ntheorem Multiset.aemeasurable_prod (s : Multiset (α → M)) (hs : ∀ f ∈ s, AEMeasurable f μ) :\n    AEMeasurable (fun x => (s.map fun f : α → M => f x).prod) μ := by\n  simpa only [← Pi.multiset_prod_apply] using s.aemeasurable_prod' hs\n\n"}
{"name":"Finset.measurable_prod","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nι : Type u_3\nα : Type u_4\ninst✝² : CommMonoid M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableMul₂ M\nm : MeasurableSpace α\nf : ι → α → M\ns : Finset ι\nhf : ∀ (i : ι), Membership.mem s i → Measurable (f i)\n⊢ Measurable fun a => s.prod fun i => f i a","decl":"@[to_additive (attr := fun_prop, measurability)]\ntheorem Finset.measurable_prod (s : Finset ι) (hf : ∀ i ∈ s, Measurable (f i)) :\n    Measurable fun a ↦ ∏ i ∈ s, f i a := by\n  simp_rw [← Finset.prod_apply]\n  exact Finset.prod_induction _ _ (fun _ _ => Measurable.mul) (@measurable_one M _ _ _ _) hf\n\n"}
{"name":"Finset.measurable_sum","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nι : Type u_3\nα : Type u_4\ninst✝² : AddCommMonoid M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableAdd₂ M\nm : MeasurableSpace α\nf : ι → α → M\ns : Finset ι\nhf : ∀ (i : ι), Membership.mem s i → Measurable (f i)\n⊢ Measurable fun a => s.sum fun i => f i a","decl":"@[to_additive (attr := fun_prop, measurability)]\ntheorem Finset.measurable_prod (s : Finset ι) (hf : ∀ i ∈ s, Measurable (f i)) :\n    Measurable fun a ↦ ∏ i ∈ s, f i a := by\n  simp_rw [← Finset.prod_apply]\n  exact Finset.prod_induction _ _ (fun _ _ => Measurable.mul) (@measurable_one M _ _ _ _) hf\n\n"}
{"name":"Finset.measurable_sum'","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nι : Type u_3\nα : Type u_4\nβ : Type u_5\ninst✝² : AddCommMonoid M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableAdd₂ M\nm : MeasurableSpace α\nmβ : MeasurableSpace β\nf : ι → α → β → M\ng : α → β\ns : Finset ι\nhf : ∀ (i : ι), Measurable (Function.HasUncurry.uncurry (f i))\nhg : Measurable g\n⊢ Measurable fun a => s.sum (fun i => f i a) (g a)","decl":"/-- Compositional version of `Finset.measurable_prod` for use by `fun_prop`. -/\n@[to_additive (attr := measurability, fun_prop)\n\"Compositional version of `Finset.measurable_sum` for use by `fun_prop`.\"]\nlemma Finset.measurable_prod' {f : ι → α → β → M} {g : α → β} {s : Finset ι}\n    (hf : ∀ i, Measurable ↿(f i)) (hg : Measurable g) :\n    Measurable fun a ↦ (∏ i ∈ s, f i a) (g a) := by simp; fun_prop\n\n"}
{"name":"Finset.measurable_prod'","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nι : Type u_3\nα : Type u_4\nβ : Type u_5\ninst✝² : CommMonoid M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableMul₂ M\nm : MeasurableSpace α\nmβ : MeasurableSpace β\nf : ι → α → β → M\ng : α → β\ns : Finset ι\nhf : ∀ (i : ι), Measurable (Function.HasUncurry.uncurry (f i))\nhg : Measurable g\n⊢ Measurable fun a => s.prod (fun i => f i a) (g a)","decl":"/-- Compositional version of `Finset.measurable_prod` for use by `fun_prop`. -/\n@[to_additive (attr := measurability, fun_prop)\n\"Compositional version of `Finset.measurable_sum` for use by `fun_prop`.\"]\nlemma Finset.measurable_prod' {f : ι → α → β → M} {g : α → β} {s : Finset ι}\n    (hf : ∀ i, Measurable ↿(f i)) (hg : Measurable g) :\n    Measurable fun a ↦ (∏ i ∈ s, f i a) (g a) := by simp; fun_prop\n\n"}
{"name":"Finset.aemeasurable_prod'","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nι : Type u_3\nα : Type u_4\ninst✝² : CommMonoid M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableMul₂ M\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : ι → α → M\ns : Finset ι\nhf : ∀ (i : ι), Membership.mem s i → AEMeasurable (f i) μ\n⊢ AEMeasurable (s.prod fun i => f i) μ","decl":"@[to_additive (attr := measurability)]\ntheorem Finset.aemeasurable_prod' (s : Finset ι) (hf : ∀ i ∈ s, AEMeasurable (f i) μ) :\n    AEMeasurable (∏ i ∈ s, f i) μ :=\n  Multiset.aemeasurable_prod' _ fun _g hg =>\n    let ⟨_i, hi, hg⟩ := Multiset.mem_map.1 hg\n    hg ▸ hf _ hi\n\n"}
{"name":"Finset.aemeasurable_sum'","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nι : Type u_3\nα : Type u_4\ninst✝² : AddCommMonoid M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableAdd₂ M\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : ι → α → M\ns : Finset ι\nhf : ∀ (i : ι), Membership.mem s i → AEMeasurable (f i) μ\n⊢ AEMeasurable (s.sum fun i => f i) μ","decl":"@[to_additive (attr := measurability)]\ntheorem Finset.aemeasurable_prod' (s : Finset ι) (hf : ∀ i ∈ s, AEMeasurable (f i) μ) :\n    AEMeasurable (∏ i ∈ s, f i) μ :=\n  Multiset.aemeasurable_prod' _ fun _g hg =>\n    let ⟨_i, hi, hg⟩ := Multiset.mem_map.1 hg\n    hg ▸ hf _ hi\n\n"}
{"name":"Finset.aemeasurable_prod","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nι : Type u_3\nα : Type u_4\ninst✝² : CommMonoid M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableMul₂ M\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : ι → α → M\ns : Finset ι\nhf : ∀ (i : ι), Membership.mem s i → AEMeasurable (f i) μ\n⊢ AEMeasurable (fun a => s.prod fun i => f i a) μ","decl":"@[to_additive (attr := measurability)]\ntheorem Finset.aemeasurable_prod (s : Finset ι) (hf : ∀ i ∈ s, AEMeasurable (f i) μ) :\n    AEMeasurable (fun a => ∏ i ∈ s, f i a) μ := by\n  simpa only [← Finset.prod_apply] using s.aemeasurable_prod' hf\n\n"}
{"name":"Finset.aemeasurable_sum","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"M : Type u_2\nι : Type u_3\nα : Type u_4\ninst✝² : AddCommMonoid M\ninst✝¹ : MeasurableSpace M\ninst✝ : MeasurableAdd₂ M\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : ι → α → M\ns : Finset ι\nhf : ∀ (i : ι), Membership.mem s i → AEMeasurable (f i) μ\n⊢ AEMeasurable (fun a => s.sum fun i => f i a) μ","decl":"@[to_additive (attr := measurability)]\ntheorem Finset.aemeasurable_prod (s : Finset ι) (hf : ∀ i ∈ s, AEMeasurable (f i) μ) :\n    AEMeasurable (fun a => ∏ i ∈ s, f i a) μ := by\n  simpa only [← Finset.prod_apply] using s.aemeasurable_prod' hf\n\n"}
{"name":"DiscreteMeasurableSpace.toMeasurableAdd","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\ninst✝¹ : Add α\ninst✝ : DiscreteMeasurableSpace α\n⊢ MeasurableAdd α","decl":"@[to_additive] -- See note [lower instance priority]\ninstance (priority := 100) DiscreteMeasurableSpace.toMeasurableMul [DiscreteMeasurableSpace α] :\n    MeasurableMul α where\n  measurable_const_mul _ := .of_discrete\n  measurable_mul_const _ := .of_discrete\n\n"}
{"name":"DiscreteMeasurableSpace.toMeasurableMul","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\ninst✝¹ : Mul α\ninst✝ : DiscreteMeasurableSpace α\n⊢ MeasurableMul α","decl":"@[to_additive] -- See note [lower instance priority]\ninstance (priority := 100) DiscreteMeasurableSpace.toMeasurableMul [DiscreteMeasurableSpace α] :\n    MeasurableMul α where\n  measurable_const_mul _ := .of_discrete\n  measurable_mul_const _ := .of_discrete\n\n"}
{"name":"DiscreteMeasurableSpace.toMeasurableMul₂","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\ninst✝¹ : Mul α\ninst✝ : DiscreteMeasurableSpace (Prod α α)\n⊢ MeasurableMul₂ α","decl":"@[to_additive DiscreteMeasurableSpace.toMeasurableAdd₂] -- See note [lower instance priority]\ninstance (priority := 100) DiscreteMeasurableSpace.toMeasurableMul₂\n    [DiscreteMeasurableSpace (α × α)] : MeasurableMul₂ α := ⟨.of_discrete⟩\n\n"}
{"name":"DiscreteMeasurableSpace.toMeasurableAdd₂","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\ninst✝¹ : Add α\ninst✝ : DiscreteMeasurableSpace (Prod α α)\n⊢ MeasurableAdd₂ α","decl":"@[to_additive DiscreteMeasurableSpace.toMeasurableAdd₂] -- See note [lower instance priority]\ninstance (priority := 100) DiscreteMeasurableSpace.toMeasurableMul₂\n    [DiscreteMeasurableSpace (α × α)] : MeasurableMul₂ α := ⟨.of_discrete⟩\n\n"}
{"name":"DiscreteMeasurableSpace.toMeasurableInv","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\ninst✝¹ : Inv α\ninst✝ : DiscreteMeasurableSpace α\n⊢ MeasurableInv α","decl":"@[to_additive] -- See note [lower instance priority]\ninstance (priority := 100) DiscreteMeasurableSpace.toMeasurableInv [DiscreteMeasurableSpace α] :\n    MeasurableInv α := ⟨.of_discrete⟩\n\n"}
{"name":"DiscreteMeasurableSpace.toMeasurableNeg","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\ninst✝¹ : Neg α\ninst✝ : DiscreteMeasurableSpace α\n⊢ MeasurableNeg α","decl":"@[to_additive] -- See note [lower instance priority]\ninstance (priority := 100) DiscreteMeasurableSpace.toMeasurableInv [DiscreteMeasurableSpace α] :\n    MeasurableInv α := ⟨.of_discrete⟩\n\n"}
{"name":"DiscreteMeasurableSpace.toMeasurableDiv","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\ninst✝¹ : Div α\ninst✝ : DiscreteMeasurableSpace α\n⊢ MeasurableDiv α","decl":"@[to_additive] -- See note [lower instance priority]\ninstance (priority := 100) DiscreteMeasurableSpace.toMeasurableDiv [DiscreteMeasurableSpace α] :\n    MeasurableDiv α where\n  measurable_const_div _ := .of_discrete\n  measurable_div_const _ := .of_discrete\n\n"}
{"name":"DiscreteMeasurableSpace.toMeasurableSub","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\ninst✝¹ : Sub α\ninst✝ : DiscreteMeasurableSpace α\n⊢ MeasurableSub α","decl":"@[to_additive] -- See note [lower instance priority]\ninstance (priority := 100) DiscreteMeasurableSpace.toMeasurableDiv [DiscreteMeasurableSpace α] :\n    MeasurableDiv α where\n  measurable_const_div _ := .of_discrete\n  measurable_div_const _ := .of_discrete\n\n"}
{"name":"DiscreteMeasurableSpace.toMeasurableDiv₂","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\ninst✝¹ : Div α\ninst✝ : DiscreteMeasurableSpace (Prod α α)\n⊢ MeasurableDiv₂ α","decl":"@[to_additive DiscreteMeasurableSpace.toMeasurableSub₂] -- See note [lower instance priority]\ninstance (priority := 100) DiscreteMeasurableSpace.toMeasurableDiv₂\n    [DiscreteMeasurableSpace (α × α)] : MeasurableDiv₂ α := ⟨.of_discrete⟩\n"}
{"name":"DiscreteMeasurableSpace.toMeasurableSub₂","module":"Mathlib.MeasureTheory.Group.Arithmetic","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\ninst✝¹ : Sub α\ninst✝ : DiscreteMeasurableSpace (Prod α α)\n⊢ MeasurableSub₂ α","decl":"@[to_additive DiscreteMeasurableSpace.toMeasurableSub₂] -- See note [lower instance priority]\ninstance (priority := 100) DiscreteMeasurableSpace.toMeasurableDiv₂\n    [DiscreteMeasurableSpace (α × α)] : MeasurableDiv₂ α := ⟨.of_discrete⟩\n"}
