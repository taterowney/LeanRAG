{"name":"Ideal.Filtration.mk.injEq","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nN✝ : Nat → Submodule R M\nmono✝ : ∀ (i : Nat), LE.le (N✝ (HAdd.hAdd i 1)) (N✝ i)\nsmul_le✝ : ∀ (i : Nat), LE.le (HSMul.hSMul I (N✝ i)) (N✝ (HAdd.hAdd i 1))\nN : Nat → Submodule R M\nmono : ∀ (i : Nat), LE.le (N (HAdd.hAdd i 1)) (N i)\nsmul_le : ∀ (i : Nat), LE.le (HSMul.hSMul I (N i)) (N (HAdd.hAdd i 1))\n⊢ Eq (Eq { N := N✝, mono := mono✝, smul_le := smul_le✝ } { N := N, mono := mono, smul_le := smul_le }) (Eq N✝ N)","decl":"/-- An `I`-filtration on the module `M` is a sequence of decreasing submodules `N i` such that\n`I • (N i) ≤ N (i + 1)`. Note that we do not require the filtration to start from `⊤`. -/\n@[ext]\nstructure Ideal.Filtration (M : Type*) [AddCommGroup M] [Module R M] where\n  N : ℕ → Submodule R M\n  mono : ∀ i, N (i + 1) ≤ N i\n  smul_le : ∀ i, I • N i ≤ N (i + 1)\n\n"}
{"name":"Ideal.Filtration.mk.inj","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nN✝ : Nat → Submodule R M\nmono✝ : ∀ (i : Nat), LE.le (N✝ (HAdd.hAdd i 1)) (N✝ i)\nsmul_le✝ : ∀ (i : Nat), LE.le (HSMul.hSMul I (N✝ i)) (N✝ (HAdd.hAdd i 1))\nN : Nat → Submodule R M\nmono : ∀ (i : Nat), LE.le (N (HAdd.hAdd i 1)) (N i)\nsmul_le : ∀ (i : Nat), LE.le (HSMul.hSMul I (N i)) (N (HAdd.hAdd i 1))\nx✝ : Eq { N := N✝, mono := mono✝, smul_le := smul_le✝ } { N := N, mono := mono, smul_le := smul_le }\n⊢ Eq N✝ N","decl":"/-- An `I`-filtration on the module `M` is a sequence of decreasing submodules `N i` such that\n`I • (N i) ≤ N (i + 1)`. Note that we do not require the filtration to start from `⊤`. -/\n@[ext]\nstructure Ideal.Filtration (M : Type*) [AddCommGroup M] [Module R M] where\n  N : ℕ → Submodule R M\n  mono : ∀ i, N (i + 1) ≤ N i\n  smul_le : ∀ i, I • N i ≤ N (i + 1)\n\n"}
{"name":"Ideal.Filtration.ext","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : I.Filtration M\nN : Eq x.N y.N\n⊢ Eq x y","decl":"/-- An `I`-filtration on the module `M` is a sequence of decreasing submodules `N i` such that\n`I • (N i) ≤ N (i + 1)`. Note that we do not require the filtration to start from `⊤`. -/\n@[ext]\nstructure Ideal.Filtration (M : Type*) [AddCommGroup M] [Module R M] where\n  N : ℕ → Submodule R M\n  mono : ∀ i, N (i + 1) ≤ N i\n  smul_le : ∀ i, I • N i ≤ N (i + 1)\n\n"}
{"name":"Ideal.Filtration.mk.sizeOf_spec","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nI : Ideal R\nM : Type u_3\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : SizeOf R\ninst✝ : SizeOf M\nN : Nat → Submodule R M\nmono : ∀ (i : Nat), LE.le (N (HAdd.hAdd i 1)) (N i)\nsmul_le : ∀ (i : Nat), LE.le (HSMul.hSMul I (N i)) (N (HAdd.hAdd i 1))\n⊢ Eq (SizeOf.sizeOf { N := N, mono := mono, smul_le := smul_le }) 1","decl":"/-- An `I`-filtration on the module `M` is a sequence of decreasing submodules `N i` such that\n`I • (N i) ≤ N (i + 1)`. Note that we do not require the filtration to start from `⊤`. -/\n@[ext]\nstructure Ideal.Filtration (M : Type*) [AddCommGroup M] [Module R M] where\n  N : ℕ → Submodule R M\n  mono : ∀ i, N (i + 1) ≤ N i\n  smul_le : ∀ i, I • N i ≤ N (i + 1)\n\n"}
{"name":"Ideal.Filtration.smul_le","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nself : I.Filtration M\ni : Nat\n⊢ LE.le (HSMul.hSMul I (self.N i)) (self.N (HAdd.hAdd i 1))","decl":"/-- An `I`-filtration on the module `M` is a sequence of decreasing submodules `N i` such that\n`I • (N i) ≤ N (i + 1)`. Note that we do not require the filtration to start from `⊤`. -/\n@[ext]\nstructure Ideal.Filtration (M : Type*) [AddCommGroup M] [Module R M] where\n  N : ℕ → Submodule R M\n  mono : ∀ i, N (i + 1) ≤ N i\n  smul_le : ∀ i, I • N i ≤ N (i + 1)\n\n"}
{"name":"Ideal.Filtration.mono","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nself : I.Filtration M\ni : Nat\n⊢ LE.le (self.N (HAdd.hAdd i 1)) (self.N i)","decl":"/-- An `I`-filtration on the module `M` is a sequence of decreasing submodules `N i` such that\n`I • (N i) ≤ N (i + 1)`. Note that we do not require the filtration to start from `⊤`. -/\n@[ext]\nstructure Ideal.Filtration (M : Type*) [AddCommGroup M] [Module R M] where\n  N : ℕ → Submodule R M\n  mono : ∀ i, N (i + 1) ≤ N i\n  smul_le : ∀ i, I • N i ≤ N (i + 1)\n\n"}
{"name":"Ideal.Filtration.ext_iff","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : I.Filtration M\n⊢ Iff (Eq x y) (Eq x.N y.N)","decl":"/-- An `I`-filtration on the module `M` is a sequence of decreasing submodules `N i` such that\n`I • (N i) ≤ N (i + 1)`. Note that we do not require the filtration to start from `⊤`. -/\n@[ext]\nstructure Ideal.Filtration (M : Type*) [AddCommGroup M] [Module R M] where\n  N : ℕ → Submodule R M\n  mono : ∀ i, N (i + 1) ≤ N i\n  smul_le : ∀ i, I • N i ≤ N (i + 1)\n\n"}
{"name":"Ideal.Filtration.pow_smul_le","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nF : I.Filtration M\ni j : Nat\n⊢ LE.le (HSMul.hSMul (HPow.hPow I i) (F.N j)) (F.N (HAdd.hAdd i j))","decl":"theorem pow_smul_le (i j : ℕ) : I ^ i • F.N j ≤ F.N (i + j) := by\n  induction' i with _ ih\n  · simp\n  · rw [pow_succ', mul_smul, add_assoc, add_comm 1, ← add_assoc]\n    exact (smul_mono_right _ ih).trans (F.smul_le _)\n\n"}
{"name":"Ideal.Filtration.pow_smul_le_pow_smul","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nF : I.Filtration M\ni j k : Nat\n⊢ LE.le (HSMul.hSMul (HPow.hPow I (HAdd.hAdd i k)) (F.N j)) (HSMul.hSMul (HPow.hPow I k) (F.N (HAdd.hAdd i j)))","decl":"theorem pow_smul_le_pow_smul (i j k : ℕ) : I ^ (i + k) • F.N j ≤ I ^ k • F.N (i + j) := by\n  rw [add_comm, pow_add, mul_smul]\n  exact smul_mono_right _ (F.pow_smul_le i j)\n\n"}
{"name":"Ideal.Filtration.antitone","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nF : I.Filtration M\n⊢ Antitone F.N","decl":"protected theorem antitone : Antitone F.N :=\n  antitone_nat_of_succ_le F.mono\n\n"}
{"name":"Ideal.trivialFiltration_N","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nN : Submodule R M\nx✝ : Nat\n⊢ Eq ((I.trivialFiltration N).N x✝) N","decl":"/-- The trivial `I`-filtration of `N`. -/\n@[simps]\ndef _root_.Ideal.trivialFiltration (I : Ideal R) (N : Submodule R M) : I.Filtration M where\n  N _ := N\n  mono _ := le_rfl\n  smul_le _ := Submodule.smul_le_right\n\n"}
{"name":"Ideal.Filtration.sup_N","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nF F' : I.Filtration M\n⊢ Eq (Max.max F F').N (Max.max F.N F'.N)","decl":"@[simp]\ntheorem sup_N : (F ⊔ F').N = F.N ⊔ F'.N :=\n  rfl\n\n"}
{"name":"Ideal.Filtration.sSup_N","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nS : Set (I.Filtration M)\n⊢ Eq (SupSet.sSup S).N (SupSet.sSup (Set.image Ideal.Filtration.N S))","decl":"@[simp]\ntheorem sSup_N (S : Set (I.Filtration M)) : (sSup S).N = sSup (Ideal.Filtration.N '' S) :=\n  rfl\n\n"}
{"name":"Ideal.Filtration.inf_N","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nF F' : I.Filtration M\n⊢ Eq (Min.min F F').N (Min.min F.N F'.N)","decl":"@[simp]\ntheorem inf_N : (F ⊓ F').N = F.N ⊓ F'.N :=\n  rfl\n\n"}
{"name":"Ideal.Filtration.sInf_N","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nS : Set (I.Filtration M)\n⊢ Eq (InfSet.sInf S).N (InfSet.sInf (Set.image Ideal.Filtration.N S))","decl":"@[simp]\ntheorem sInf_N (S : Set (I.Filtration M)) : (sInf S).N = sInf (Ideal.Filtration.N '' S) :=\n  rfl\n\n"}
{"name":"Ideal.Filtration.top_N","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\n⊢ Eq Top.top.N Top.top","decl":"@[simp]\ntheorem top_N : (⊤ : I.Filtration M).N = ⊤ :=\n  rfl\n\n"}
{"name":"Ideal.Filtration.bot_N","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\n⊢ Eq Bot.bot.N Bot.bot","decl":"@[simp]\ntheorem bot_N : (⊥ : I.Filtration M).N = ⊥ :=\n  rfl\n\n"}
{"name":"Ideal.Filtration.iSup_N","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nι : Sort u_3\nf : ι → I.Filtration M\n⊢ Eq (iSup f).N (iSup fun i => (f i).N)","decl":"@[simp]\ntheorem iSup_N {ι : Sort*} (f : ι → I.Filtration M) : (iSup f).N = ⨆ i, (f i).N :=\n  congr_arg sSup (Set.range_comp _ _).symm\n\n"}
{"name":"Ideal.Filtration.iInf_N","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nι : Sort u_3\nf : ι → I.Filtration M\n⊢ Eq (iInf f).N (iInf fun i => (f i).N)","decl":"@[simp]\ntheorem iInf_N {ι : Sort*} (f : ι → I.Filtration M) : (iInf f).N = ⨅ i, (f i).N :=\n  congr_arg sInf (Set.range_comp _ _).symm\n\n"}
{"name":"Ideal.stableFiltration_N","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nN : Submodule R M\ni : Nat\n⊢ Eq ((I.stableFiltration N).N i) (HSMul.hSMul (HPow.hPow I i) N)","decl":"/-- The trivial stable `I`-filtration of `N`. -/\n@[simps]\ndef _root_.Ideal.stableFiltration (I : Ideal R) (N : Submodule R M) : I.Filtration M where\n  N i := I ^ i • N\n  mono i := by dsimp only; rw [add_comm, pow_add, mul_smul]; exact Submodule.smul_le_right\n  smul_le i := by dsimp only; rw [add_comm, pow_add, mul_smul, pow_one]\n\n"}
{"name":"Ideal.stableFiltration_stable","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nN : Submodule R M\n⊢ (I.stableFiltration N).Stable","decl":"theorem _root_.Ideal.stableFiltration_stable (I : Ideal R) (N : Submodule R M) :\n    (I.stableFiltration N).Stable := by\n  use 0\n  intro n _\n  dsimp\n  rw [add_comm, pow_add, mul_smul, pow_one]\n\n"}
{"name":"Ideal.Filtration.Stable.exists_pow_smul_eq","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nF : I.Filtration M\nh : F.Stable\n⊢ Exists fun n₀ => ∀ (k : Nat), Eq (F.N (HAdd.hAdd n₀ k)) (HSMul.hSMul (HPow.hPow I k) (F.N n₀))","decl":"theorem Stable.exists_pow_smul_eq (h : F.Stable) : ∃ n₀, ∀ k, F.N (n₀ + k) = I ^ k • F.N n₀ := by\n  obtain ⟨n₀, hn⟩ := h\n  use n₀\n  intro k\n  induction' k with _ ih\n  · simp\n  · rw [← add_assoc, ← hn, ih, add_comm, pow_add, mul_smul, pow_one]\n    omega\n\n"}
{"name":"Ideal.Filtration.Stable.exists_pow_smul_eq_of_ge","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nF : I.Filtration M\nh : F.Stable\n⊢ Exists fun n₀ => ∀ (n : Nat), GE.ge n n₀ → Eq (F.N n) (HSMul.hSMul (HPow.hPow I (HSub.hSub n n₀)) (F.N n₀))","decl":"theorem Stable.exists_pow_smul_eq_of_ge (h : F.Stable) :\n    ∃ n₀, ∀ n ≥ n₀, F.N n = I ^ (n - n₀) • F.N n₀ := by\n  obtain ⟨n₀, hn₀⟩ := h.exists_pow_smul_eq\n  use n₀\n  intro n hn\n  convert hn₀ (n - n₀)\n  rw [add_comm, tsub_add_cancel_of_le hn]\n\n"}
{"name":"Ideal.Filtration.stable_iff_exists_pow_smul_eq_of_ge","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nF : I.Filtration M\n⊢ Iff F.Stable (Exists fun n₀ => ∀ (n : Nat), GE.ge n n₀ → Eq (F.N n) (HSMul.hSMul (HPow.hPow I (HSub.hSub n n₀)) (F.N n₀)))","decl":"theorem stable_iff_exists_pow_smul_eq_of_ge :\n    F.Stable ↔ ∃ n₀, ∀ n ≥ n₀, F.N n = I ^ (n - n₀) • F.N n₀ := by\n  refine ⟨Stable.exists_pow_smul_eq_of_ge, fun h => ⟨h.choose, fun n hn => ?_⟩⟩\n  rw [h.choose_spec n hn, h.choose_spec (n + 1) (by omega), smul_smul, ← pow_succ',\n    tsub_add_eq_add_tsub hn]\n\n"}
{"name":"Ideal.Filtration.Stable.exists_forall_le","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nF F' : I.Filtration M\nh : F.Stable\ne : LE.le (F.N 0) (F'.N 0)\n⊢ Exists fun n₀ => ∀ (n : Nat), LE.le (F.N (HAdd.hAdd n n₀)) (F'.N n)","decl":"theorem Stable.exists_forall_le (h : F.Stable) (e : F.N 0 ≤ F'.N 0) :\n    ∃ n₀, ∀ n, F.N (n + n₀) ≤ F'.N n := by\n  obtain ⟨n₀, hF⟩ := h\n  use n₀\n  intro n\n  induction' n with n hn\n  · refine (F.antitone ?_).trans e; simp\n  · rw [add_right_comm, ← hF]\n    · exact (smul_mono_right _ hn).trans (F'.smul_le _)\n    simp\n\n"}
{"name":"Ideal.Filtration.Stable.bounded_difference","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nF F' : I.Filtration M\nh : F.Stable\nh' : F'.Stable\ne : Eq (F.N 0) (F'.N 0)\n⊢ Exists fun n₀ => ∀ (n : Nat), And (LE.le (F.N (HAdd.hAdd n n₀)) (F'.N n)) (LE.le (F'.N (HAdd.hAdd n n₀)) (F.N n))","decl":"theorem Stable.bounded_difference (h : F.Stable) (h' : F'.Stable) (e : F.N 0 = F'.N 0) :\n    ∃ n₀, ∀ n, F.N (n + n₀) ≤ F'.N n ∧ F'.N (n + n₀) ≤ F.N n := by\n  obtain ⟨n₁, h₁⟩ := h.exists_forall_le (le_of_eq e)\n  obtain ⟨n₂, h₂⟩ := h'.exists_forall_le (le_of_eq e.symm)\n  use max n₁ n₂\n  intro n\n  refine ⟨(F.antitone ?_).trans (h₁ n), (F'.antitone ?_).trans (h₂ n)⟩ <;> simp\n\n"}
{"name":"Ideal.Filtration.mem_submodule","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nF : I.Filtration M\nf : PolynomialModule R M\n⊢ Iff (Membership.mem F.submodule f) (∀ (i : Nat), Membership.mem (F.N i) (f i))","decl":"@[simp]\ntheorem mem_submodule (f : PolynomialModule R M) : f ∈ F.submodule ↔ ∀ i, f i ∈ F.N i :=\n  Iff.rfl\n\n"}
{"name":"Ideal.Filtration.inf_submodule","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nF F' : I.Filtration M\n⊢ Eq (Min.min F F').submodule (Min.min F.submodule F'.submodule)","decl":"theorem inf_submodule : (F ⊓ F').submodule = F.submodule ⊓ F'.submodule := by\n  ext\n  exact forall_and\n\n"}
{"name":"Ideal.Filtration.submodule_closure_single","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nF : I.Filtration M\n⊢ Eq (AddSubmonoid.closure (Set.iUnion fun i => Set.image ⇑(PolynomialModule.single R i) ↑(F.N i))) F.submodule.toAddSubmonoid","decl":"theorem submodule_closure_single :\n    AddSubmonoid.closure (⋃ i, single R i '' (F.N i : Set M)) = F.submodule.toAddSubmonoid := by\n  apply le_antisymm\n  · rw [AddSubmonoid.closure_le, Set.iUnion_subset_iff]\n    rintro i _ ⟨m, hm, rfl⟩ j\n    rw [single_apply]\n    split_ifs with h\n    · rwa [← h]\n    · exact (F.N j).zero_mem\n  · intro f hf\n    rw [← f.sum_single]\n    apply AddSubmonoid.sum_mem _ _\n    rintro c -\n    exact AddSubmonoid.subset_closure (Set.subset_iUnion _ c <| Set.mem_image_of_mem _ (hf c))\n\n"}
{"name":"Ideal.Filtration.submodule_span_single","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nF : I.Filtration M\n⊢ Eq (Submodule.span (Subtype fun x => Membership.mem (reesAlgebra I) x) (Set.iUnion fun i => Set.image ⇑(PolynomialModule.single R i) ↑(F.N i))) F.submodule","decl":"theorem submodule_span_single :\n    Submodule.span (reesAlgebra I) (⋃ i, single R i '' (F.N i : Set M)) = F.submodule := by\n  rw [← Submodule.span_closure, submodule_closure_single, Submodule.coe_toAddSubmonoid]\n  exact Submodule.span_eq (Filtration.submodule F)\n\n"}
{"name":"Ideal.Filtration.submodule_eq_span_le_iff_stable_ge","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nF : I.Filtration M\nn₀ : Nat\n⊢ Iff (Eq F.submodule (Submodule.span (Subtype fun x => Membership.mem (reesAlgebra I) x) (Set.iUnion fun i => Set.iUnion fun h => Set.image ⇑(PolynomialModule.single R i) ↑(F.N i)))) (∀ (n : Nat), GE.ge n n₀ → Eq (HSMul.hSMul I (F.N n)) (F.N (HAdd.hAdd n 1)))","decl":"theorem submodule_eq_span_le_iff_stable_ge (n₀ : ℕ) :\n    F.submodule = Submodule.span _ (⋃ i ≤ n₀, single R i '' (F.N i : Set M)) ↔\n      ∀ n ≥ n₀, I • F.N n = F.N (n + 1) := by\n  rw [← submodule_span_single, ← LE.le.le_iff_eq, Submodule.span_le, Set.iUnion_subset_iff]\n  swap; · exact Submodule.span_mono (Set.iUnion₂_subset_iUnion _ _)\n  constructor\n  · intro H n hn\n    refine (F.smul_le n).antisymm ?_\n    intro x hx\n    obtain ⟨l, hl⟩ := (Finsupp.mem_span_iff_linearCombination _ _ _).mp (H _ ⟨x, hx, rfl⟩)\n    replace hl := congr_arg (fun f : ℕ →₀ M => f (n + 1)) hl\n    dsimp only at hl\n    erw [Finsupp.single_eq_same] at hl\n    rw [← hl, Finsupp.linearCombination_apply, Finsupp.sum_apply]\n    apply Submodule.sum_mem _ _\n    rintro ⟨_, _, ⟨n', rfl⟩, _, ⟨hn', rfl⟩, m, hm, rfl⟩ -\n    dsimp only [Subtype.coe_mk]\n    rw [Subalgebra.smul_def, smul_single_apply, if_pos (show n' ≤ n + 1 by omega)]\n    have e : n' ≤ n := by omega\n    have := F.pow_smul_le_pow_smul (n - n') n' 1\n    rw [tsub_add_cancel_of_le e, pow_one, add_comm _ 1, ← add_tsub_assoc_of_le e, add_comm] at this\n    exact this (Submodule.smul_mem_smul ((l _).2 <| n + 1 - n') hm)\n  · let F' := Submodule.span (reesAlgebra I) (⋃ i ≤ n₀, single R i '' (F.N i : Set M))\n    intro hF i\n    have : ∀ i ≤ n₀, single R i '' (F.N i : Set M) ⊆ F' := by\n      -- Porting note: Original proof was\n      -- `fun i hi => Set.Subset.trans (Set.subset_iUnion₂ i hi) Submodule.subset_span`\n      intro i hi\n      refine Set.Subset.trans ?_ Submodule.subset_span\n      refine @Set.subset_iUnion₂ _ _ _ (fun i => fun _ => ↑((single R i) '' ((N F i) : Set M))) i ?_\n      exact hi\n    induction' i with j hj\n    · exact this _ (zero_le _)\n    by_cases hj' : j.succ ≤ n₀\n    · exact this _ hj'\n    simp only [not_le, Nat.lt_succ_iff] at hj'\n    rw [← hF _ hj']\n    rintro _ ⟨m, hm, rfl⟩\n    refine Submodule.smul_induction_on hm (fun r hr m' hm' => ?_) (fun x y hx hy => ?_)\n    · rw [add_comm, ← monomial_smul_single]\n      exact F'.smul_mem\n        ⟨_, reesAlgebra.monomial_mem.mpr (by rwa [pow_one])⟩ (hj <| Set.mem_image_of_mem _ hm')\n    · rw [map_add]\n      exact F'.add_mem hx hy\n\n"}
{"name":"Ideal.Filtration.submodule_fg_iff_stable","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nF : I.Filtration M\nhF' : ∀ (i : Nat), (F.N i).FG\n⊢ Iff F.submodule.FG F.Stable","decl":"/-- If the components of a filtration are finitely generated, then the filtration is stable iff\nits associated submodule of is finitely generated. -/\ntheorem submodule_fg_iff_stable (hF' : ∀ i, (F.N i).FG) : F.submodule.FG ↔ F.Stable := by\n  classical\n  delta Ideal.Filtration.Stable\n  simp_rw [← F.submodule_eq_span_le_iff_stable_ge]\n  constructor\n  · rintro H\n    refine H.stabilizes_of_iSup_eq\n        ⟨fun n₀ => Submodule.span _ (⋃ (i : ℕ) (_ : i ≤ n₀), single R i '' ↑(F.N i)), ?_⟩ ?_\n    · intro n m e\n      rw [Submodule.span_le, Set.iUnion₂_subset_iff]\n      intro i hi\n      refine Set.Subset.trans ?_ Submodule.subset_span\n      refine @Set.subset_iUnion₂ _ _ _ (fun i => fun _ => ↑((single R i) '' ((N F i) : Set M))) i ?_\n      exact hi.trans e\n    · dsimp\n      rw [← Submodule.span_iUnion, ← submodule_span_single]\n      congr 1\n      ext\n      simp only [Set.mem_iUnion, Set.mem_image, SetLike.mem_coe, exists_prop]\n      constructor\n      · rintro ⟨-, i, -, e⟩; exact ⟨i, e⟩\n      · rintro ⟨i, e⟩; exact ⟨i, i, le_refl i, e⟩\n  · rintro ⟨n, hn⟩\n    rw [hn]\n    simp_rw [Submodule.span_iUnion₂, ← Finset.mem_range_succ_iff, iSup_subtype']\n    apply Submodule.fg_iSup\n    rintro ⟨i, hi⟩\n    obtain ⟨s, hs⟩ := hF' i\n    have : Submodule.span (reesAlgebra I) (s.image (lsingle R i) : Set (PolynomialModule R M)) =\n        Submodule.span _ (single R i '' (F.N i : Set M)) := by\n      rw [Finset.coe_image, ← Submodule.span_span_of_tower R, ← Submodule.map_span, hs]; rfl\n    rw [Subtype.coe_mk, ← this]\n    exact ⟨_, rfl⟩\n\n"}
{"name":"Ideal.Filtration.Stable.of_le","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nI : Ideal R\nF : I.Filtration M\ninst✝¹ : IsNoetherianRing R\ninst✝ : Module.Finite R M\nhF : F.Stable\nF' : I.Filtration M\nhf : LE.le F' F\n⊢ F'.Stable","decl":"theorem Stable.of_le [IsNoetherianRing R] [Module.Finite R M] (hF : F.Stable)\n    {F' : I.Filtration M} (hf : F' ≤ F) : F'.Stable := by\n  rw [← submodule_fg_iff_stable] at hF ⊢\n  any_goals intro i; exact IsNoetherian.noetherian _\n  have := isNoetherian_of_fg_of_noetherian _ hF\n  rw [isNoetherian_submodule] at this\n  exact this _ (OrderHomClass.mono (submoduleInfHom M I) hf)\n\n"}
{"name":"Ideal.Filtration.Stable.inter_right","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nI : Ideal R\nF F' : I.Filtration M\ninst✝¹ : IsNoetherianRing R\ninst✝ : Module.Finite R M\nhF : F.Stable\n⊢ (Min.min F F').Stable","decl":"theorem Stable.inter_right [IsNoetherianRing R] [Module.Finite R M] (hF : F.Stable) :\n    (F ⊓ F').Stable :=\n  hF.of_le inf_le_left\n\n"}
{"name":"Ideal.Filtration.Stable.inter_left","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nI : Ideal R\nF F' : I.Filtration M\ninst✝¹ : IsNoetherianRing R\ninst✝ : Module.Finite R M\nhF : F.Stable\n⊢ (Min.min F' F).Stable","decl":"theorem Stable.inter_left [IsNoetherianRing R] [Module.Finite R M] (hF : F.Stable) :\n    (F' ⊓ F).Stable :=\n  hF.of_le inf_le_right\n\n"}
{"name":"Ideal.exists_pow_inf_eq_pow_smul","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nI : Ideal R\ninst✝¹ : IsNoetherianRing R\ninst✝ : Module.Finite R M\nN : Submodule R M\n⊢ Exists fun k => ∀ (n : Nat), GE.ge n k → Eq (Min.min (HSMul.hSMul (HPow.hPow I n) Top.top) N) (HSMul.hSMul (HPow.hPow I (HSub.hSub n k)) (Min.min (HSMul.hSMul (HPow.hPow I k) Top.top) N))","decl":"/-- **Artin-Rees lemma** -/\ntheorem Ideal.exists_pow_inf_eq_pow_smul [IsNoetherianRing R] [Module.Finite R M]\n    (N : Submodule R M) : ∃ k : ℕ, ∀ n ≥ k, I ^ n • ⊤ ⊓ N = I ^ (n - k) • (I ^ k • ⊤ ⊓ N) :=\n  ((I.stableFiltration_stable ⊤).inter_right (I.trivialFiltration N)).exists_pow_smul_eq_of_ge\n\n"}
{"name":"Ideal.mem_iInf_smul_pow_eq_bot_iff","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nI : Ideal R\ninst✝¹ : IsNoetherianRing R\ninst✝ : Module.Finite R M\nx : M\n⊢ Iff (Membership.mem (iInf fun i => HSMul.hSMul (HPow.hPow I i) Top.top) x) (Exists fun r => Eq (HSMul.hSMul (↑r) x) x)","decl":"theorem Ideal.mem_iInf_smul_pow_eq_bot_iff [IsNoetherianRing R] [Module.Finite R M] (x : M) :\n    x ∈ (⨅ i : ℕ, I ^ i • ⊤ : Submodule R M) ↔ ∃ r : I, (r : R) • x = x := by\n  let N := (⨅ i : ℕ, I ^ i • ⊤ : Submodule R M)\n  have hN : ∀ k, (I.stableFiltration ⊤ ⊓ I.trivialFiltration N).N k = N :=\n    fun k => inf_eq_right.mpr ((iInf_le _ k).trans <| le_of_eq <| by simp)\n  constructor\n  · obtain ⟨r, hr₁, hr₂⟩ :=\n      Submodule.exists_mem_and_smul_eq_self_of_fg_of_le_smul I N (IsNoetherian.noetherian N) (by\n        obtain ⟨k, hk⟩ := (I.stableFiltration_stable ⊤).inter_right (I.trivialFiltration N)\n        have := hk k (le_refl _)\n        rw [hN, hN] at this\n        exact le_of_eq this.symm)\n    intro H\n    exact ⟨⟨r, hr₁⟩, hr₂ _ H⟩\n  · rintro ⟨r, eq⟩\n    rw [Submodule.mem_iInf]\n    intro i\n    induction' i with i hi\n    · simp\n    · rw [add_comm, pow_add, ← smul_smul, pow_one, ← eq]\n      exact Submodule.smul_mem_smul r.prop hi\n\n"}
{"name":"Ideal.iInf_pow_smul_eq_bot_of_isLocalRing","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nI : Ideal R\ninst✝² : IsNoetherianRing R\ninst✝¹ : IsLocalRing R\ninst✝ : Module.Finite R M\nh : Ne I Top.top\n⊢ Eq (iInf fun i => HSMul.hSMul (HPow.hPow I i) Top.top) Bot.bot","decl":"theorem Ideal.iInf_pow_smul_eq_bot_of_isLocalRing [IsNoetherianRing R] [IsLocalRing R]\n    [Module.Finite R M] (h : I ≠ ⊤) : (⨅ i : ℕ, I ^ i • ⊤ : Submodule R M) = ⊥ := by\n  rw [eq_bot_iff]\n  intro x hx\n  obtain ⟨r, hr⟩ := (I.mem_iInf_smul_pow_eq_bot_iff x).mp hx\n  have := IsLocalRing.isUnit_one_sub_self_of_mem_nonunits _ (IsLocalRing.le_maximalIdeal h r.prop)\n  apply this.smul_left_cancel.mp\n  simp [sub_smul, hr]\n\n"}
{"name":"Ideal.iInf_pow_smul_eq_bot_of_localRing","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nI : Ideal R\ninst✝² : IsNoetherianRing R\ninst✝¹ : IsLocalRing R\ninst✝ : Module.Finite R M\nh : Ne I Top.top\n⊢ Eq (iInf fun i => HSMul.hSMul (HPow.hPow I i) Top.top) Bot.bot","decl":"@[deprecated (since := \"2024-11-12\")]\nalias Ideal.iInf_pow_smul_eq_bot_of_localRing := Ideal.iInf_pow_smul_eq_bot_of_isLocalRing\n\n"}
{"name":"Ideal.iInf_pow_eq_bot_of_isLocalRing","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\ninst✝¹ : IsNoetherianRing R\ninst✝ : IsLocalRing R\nh : Ne I Top.top\n⊢ Eq (iInf fun i => HPow.hPow I i) Bot.bot","decl":"/-- **Krull's intersection theorem** for noetherian local rings. -/\ntheorem Ideal.iInf_pow_eq_bot_of_isLocalRing [IsNoetherianRing R] [IsLocalRing R] (h : I ≠ ⊤) :\n    ⨅ i : ℕ, I ^ i = ⊥ := by\n  convert I.iInf_pow_smul_eq_bot_of_isLocalRing (M := R) h\n  ext i\n  rw [smul_eq_mul, ← Ideal.one_eq_top, mul_one]\n\n"}
{"name":"Ideal.iInf_pow_eq_bot_of_localRing","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\ninst✝¹ : IsNoetherianRing R\ninst✝ : IsLocalRing R\nh : Ne I Top.top\n⊢ Eq (iInf fun i => HPow.hPow I i) Bot.bot","decl":"@[deprecated (since := \"2024-11-12\")]\nalias Ideal.iInf_pow_eq_bot_of_localRing := Ideal.iInf_pow_eq_bot_of_isLocalRing\n\n"}
{"name":"Ideal.isIdempotentElem_iff_eq_bot_or_top_of_isLocalRing","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_3\ninst✝² : CommRing R\ninst✝¹ : IsNoetherianRing R\ninst✝ : IsLocalRing R\nI : Ideal R\n⊢ Iff (IsIdempotentElem I) (Or (Eq I Bot.bot) (Eq I Top.top))","decl":"/-- Also see `Ideal.isIdempotentElem_iff_eq_bot_or_top` for integral domains. -/\ntheorem Ideal.isIdempotentElem_iff_eq_bot_or_top_of_isLocalRing {R} [CommRing R]\n    [IsNoetherianRing R] [IsLocalRing R] (I : Ideal R) :\n    IsIdempotentElem I ↔ I = ⊥ ∨ I = ⊤ := by\n  constructor\n  · intro H\n    by_cases I = ⊤; · exact Or.inr ‹_›\n    refine Or.inl (eq_bot_iff.mpr ?_)\n    rw [← Ideal.iInf_pow_eq_bot_of_isLocalRing I ‹_›]\n    apply le_iInf\n    rintro (_|n) <;> simp [H.pow_succ_eq]\n  · rintro (rfl | rfl) <;> simp [IsIdempotentElem]\n\n"}
{"name":"Ideal.isIdempotentElem_iff_eq_bot_or_top_of_localRing","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_3\ninst✝² : CommRing R\ninst✝¹ : IsNoetherianRing R\ninst✝ : IsLocalRing R\nI : Ideal R\n⊢ Iff (IsIdempotentElem I) (Or (Eq I Bot.bot) (Eq I Top.top))","decl":"@[deprecated (since := \"2024-11-12\")]\nalias Ideal.isIdempotentElem_iff_eq_bot_or_top_of_localRing :=\n  Ideal.isIdempotentElem_iff_eq_bot_or_top_of_isLocalRing\n\n"}
{"name":"Ideal.iInf_pow_eq_bot_of_isDomain","module":"Mathlib.RingTheory.Filtration","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\ninst✝¹ : IsNoetherianRing R\ninst✝ : IsDomain R\nh : Ne I Top.top\n⊢ Eq (iInf fun i => HPow.hPow I i) Bot.bot","decl":"/-- **Krull's intersection theorem** for noetherian domains. -/\ntheorem Ideal.iInf_pow_eq_bot_of_isDomain [IsNoetherianRing R] [IsDomain R] (h : I ≠ ⊤) :\n    ⨅ i : ℕ, I ^ i = ⊥ := by\n  rw [eq_bot_iff]\n  intro x hx\n  by_contra hx'\n  have := Ideal.mem_iInf_smul_pow_eq_bot_iff I x\n  simp_rw [smul_eq_mul, ← Ideal.one_eq_top, mul_one] at this\n  obtain ⟨r, hr⟩ := this.mp hx\n  have := mul_right_cancel₀ hx' (hr.trans (one_mul x).symm)\n  exact I.eq_top_iff_one.not.mp h (this ▸ r.prop)\n"}
