{"name":"IsIrrefl.irrefl","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\nself : IsIrrefl α r\na : α\n⊢ Not (r a a)","decl":"/-- `IsIrrefl X r` means the binary relation `r` on `X` is irreflexive (that is, `r x x` never\nholds). -/\nclass IsIrrefl (α : Sort*) (r : α → α → Prop) : Prop where\n  irrefl : ∀ a, ¬r a a\n\n"}
{"name":"IsRefl.refl","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\nself : IsRefl α r\na : α\n⊢ r a a","decl":"/-- `IsRefl X r` means the binary relation `r` on `X` is reflexive. -/\nclass IsRefl (α : Sort*) (r : α → α → Prop) : Prop where\n  refl : ∀ a, r a a\n\n"}
{"name":"IsSymm.symm","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\nself : IsSymm α r\na b : α\na✝ : r a b\n⊢ r b a","decl":"/-- `IsSymm X r` means the binary relation `r` on `X` is symmetric. -/\nclass IsSymm (α : Sort*) (r : α → α → Prop) : Prop where\n  symm : ∀ a b, r a b → r b a\n\n"}
{"name":"IsAsymm.asymm","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\nself : IsAsymm α r\na b : α\na✝ : r a b\n⊢ Not (r b a)","decl":"/-- `IsAsymm X r` means that the binary relation `r` on `X` is asymmetric, that is,\n`r a b → ¬ r b a`. -/\nclass IsAsymm (α : Sort*) (r : α → α → Prop) : Prop where\n  asymm : ∀ a b, r a b → ¬r b a\n\n"}
{"name":"IsAntisymm.antisymm","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\nself : IsAntisymm α r\na b : α\na✝¹ : r a b\na✝ : r b a\n⊢ Eq a b","decl":"/-- `IsAntisymm X r` means the binary relation `r` on `X` is antisymmetric. -/\nclass IsAntisymm (α : Sort*) (r : α → α → Prop) : Prop where\n  antisymm : ∀ a b, r a b → r b a → a = b\n\n"}
{"name":"IsAsymm.toIsAntisymm","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\ninst✝ : IsAsymm α r\n⊢ IsAntisymm α r","decl":"instance (priority := 100) IsAsymm.toIsAntisymm {α : Sort*} (r : α → α → Prop) [IsAsymm α r] :\n    IsAntisymm α r where\n  antisymm _ _ hx hy := (IsAsymm.asymm _ _ hx hy).elim\n\n"}
{"name":"IsTrans.trans","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\nself : IsTrans α r\na b c : α\na✝¹ : r a b\na✝ : r b c\n⊢ r a c","decl":"/-- `IsTrans X r` means the binary relation `r` on `X` is transitive. -/\nclass IsTrans (α : Sort*) (r : α → α → Prop) : Prop where\n  trans : ∀ a b c, r a b → r b c → r a c\n\n"}
{"name":"instIsTransOfTrans","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\ninst✝ : Trans r r r\n⊢ IsTrans α r","decl":"instance (priority := 100) {α : Sort*} {r : α → α → Prop} [Trans r r r] : IsTrans α r :=\n  ⟨fun _ _ _ => Trans.trans⟩\n\n"}
{"name":"IsTotal.total","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\nself : IsTotal α r\na b : α\n⊢ Or (r a b) (r b a)","decl":"/-- `IsTotal X r` means that the binary relation `r` on `X` is total, that is, that for any\n`x y : X` we have `r x y` or `r y x`. -/\nclass IsTotal (α : Sort*) (r : α → α → Prop) : Prop where\n  total : ∀ a b, r a b ∨ r b a\n\n"}
{"name":"IsPreorder.toIsTrans","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\nself : IsPreorder α r\n⊢ IsTrans α r","decl":"/-- `IsPreorder X r` means that the binary relation `r` on `X` is a pre-order, that is, reflexive\nand transitive. -/\nclass IsPreorder (α : Sort*) (r : α → α → Prop) extends IsRefl α r, IsTrans α r : Prop\n\n"}
{"name":"IsPreorder.toIsRefl","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\nself : IsPreorder α r\n⊢ IsRefl α r","decl":"/-- `IsPreorder X r` means that the binary relation `r` on `X` is a pre-order, that is, reflexive\nand transitive. -/\nclass IsPreorder (α : Sort*) (r : α → α → Prop) extends IsRefl α r, IsTrans α r : Prop\n\n"}
{"name":"IsPartialOrder.toIsPreorder","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\nself : IsPartialOrder α r\n⊢ IsPreorder α r","decl":"/-- `IsPartialOrder X r` means that the binary relation `r` on `X` is a partial order, that is,\n`IsPreorder X r` and `IsAntisymm X r`. -/\nclass IsPartialOrder (α : Sort*) (r : α → α → Prop) extends IsPreorder α r, IsAntisymm α r : Prop\n\n"}
{"name":"IsPartialOrder.toIsAntisymm","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\nself : IsPartialOrder α r\n⊢ IsAntisymm α r","decl":"/-- `IsPartialOrder X r` means that the binary relation `r` on `X` is a partial order, that is,\n`IsPreorder X r` and `IsAntisymm X r`. -/\nclass IsPartialOrder (α : Sort*) (r : α → α → Prop) extends IsPreorder α r, IsAntisymm α r : Prop\n\n"}
{"name":"IsLinearOrder.toIsTotal","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\nself : IsLinearOrder α r\n⊢ IsTotal α r","decl":"/-- `IsLinearOrder X r` means that the binary relation `r` on `X` is a linear order, that is,\n`IsPartialOrder X r` and `IsTotal X r`. -/\nclass IsLinearOrder (α : Sort*) (r : α → α → Prop) extends IsPartialOrder α r, IsTotal α r : Prop\n\n"}
{"name":"IsLinearOrder.toIsPartialOrder","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\nself : IsLinearOrder α r\n⊢ IsPartialOrder α r","decl":"/-- `IsLinearOrder X r` means that the binary relation `r` on `X` is a linear order, that is,\n`IsPartialOrder X r` and `IsTotal X r`. -/\nclass IsLinearOrder (α : Sort*) (r : α → α → Prop) extends IsPartialOrder α r, IsTotal α r : Prop\n\n"}
{"name":"IsEquiv.toIsSymm","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\nself : IsEquiv α r\n⊢ IsSymm α r","decl":"/-- `IsEquiv X r` means that the binary relation `r` on `X` is an equivalence relation, that\nis, `IsPreorder X r` and `IsSymm X r`. -/\nclass IsEquiv (α : Sort*) (r : α → α → Prop) extends IsPreorder α r, IsSymm α r : Prop\n\n"}
{"name":"IsEquiv.toIsPreorder","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\nself : IsEquiv α r\n⊢ IsPreorder α r","decl":"/-- `IsEquiv X r` means that the binary relation `r` on `X` is an equivalence relation, that\nis, `IsPreorder X r` and `IsSymm X r`. -/\nclass IsEquiv (α : Sort*) (r : α → α → Prop) extends IsPreorder α r, IsSymm α r : Prop\n\n"}
{"name":"IsStrictOrder.toIsIrrefl","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\nself : IsStrictOrder α r\n⊢ IsIrrefl α r","decl":"/-- `IsStrictOrder X r` means that the binary relation `r` on `X` is a strict order, that is,\n`IsIrrefl X r` and `IsTrans X r`. -/\nclass IsStrictOrder (α : Sort*) (r : α → α → Prop) extends IsIrrefl α r, IsTrans α r : Prop\n\n"}
{"name":"IsStrictOrder.toIsTrans","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\nself : IsStrictOrder α r\n⊢ IsTrans α r","decl":"/-- `IsStrictOrder X r` means that the binary relation `r` on `X` is a strict order, that is,\n`IsIrrefl X r` and `IsTrans X r`. -/\nclass IsStrictOrder (α : Sort*) (r : α → α → Prop) extends IsIrrefl α r, IsTrans α r : Prop\n\n"}
{"name":"IsStrictWeakOrder.incomp_trans","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nlt : α → α → Prop\nself : IsStrictWeakOrder α lt\na b c : α\na✝¹ : And (Not (lt a b)) (Not (lt b a))\na✝ : And (Not (lt b c)) (Not (lt c b))\n⊢ And (Not (lt a c)) (Not (lt c a))","decl":"/-- `IsStrictWeakOrder X lt` means that the binary relation `lt` on `X` is a strict weak order,\nthat is, `IsStrictOrder X lt` and `¬lt a b ∧ ¬lt b a → ¬lt b c ∧ ¬lt c b → ¬lt a c ∧ ¬lt c a`. -/\nclass IsStrictWeakOrder (α : Sort*) (lt : α → α → Prop) extends IsStrictOrder α lt : Prop where\n  incomp_trans : ∀ a b c, ¬lt a b ∧ ¬lt b a → ¬lt b c ∧ ¬lt c b → ¬lt a c ∧ ¬lt c a\n\n"}
{"name":"IsStrictWeakOrder.toIsStrictOrder","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nlt : α → α → Prop\nself : IsStrictWeakOrder α lt\n⊢ IsStrictOrder α lt","decl":"/-- `IsStrictWeakOrder X lt` means that the binary relation `lt` on `X` is a strict weak order,\nthat is, `IsStrictOrder X lt` and `¬lt a b ∧ ¬lt b a → ¬lt b c ∧ ¬lt c b → ¬lt a c ∧ ¬lt c a`. -/\nclass IsStrictWeakOrder (α : Sort*) (lt : α → α → Prop) extends IsStrictOrder α lt : Prop where\n  incomp_trans : ∀ a b c, ¬lt a b ∧ ¬lt b a → ¬lt b c ∧ ¬lt c b → ¬lt a c ∧ ¬lt c a\n\n"}
{"name":"IsTrichotomous.trichotomous","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nlt : α → α → Prop\nself : IsTrichotomous α lt\na b : α\n⊢ Or (lt a b) (Or (Eq a b) (lt b a))","decl":"/-- `IsTrichotomous X lt` means that the binary relation `lt` on `X` is trichotomous, that is,\neither `lt a b` or `a = b` or `lt b a` for any `a` and `b`. -/\nclass IsTrichotomous (α : Sort*) (lt : α → α → Prop) : Prop where\n  trichotomous : ∀ a b, lt a b ∨ a = b ∨ lt b a\n\n"}
{"name":"IsStrictTotalOrder.toIsTrichotomous","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nlt : α → α → Prop\nself : IsStrictTotalOrder α lt\n⊢ IsTrichotomous α lt","decl":"/-- `IsStrictTotalOrder X lt` means that the binary relation `lt` on `X` is a strict total order,\nthat is, `IsTrichotomous X lt` and `IsStrictOrder X lt`. -/\nclass IsStrictTotalOrder (α : Sort*) (lt : α → α → Prop) extends IsTrichotomous α lt,\n    IsStrictOrder α lt : Prop\n\n"}
{"name":"IsStrictTotalOrder.toIsStrictOrder","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nlt : α → α → Prop\nself : IsStrictTotalOrder α lt\n⊢ IsStrictOrder α lt","decl":"/-- `IsStrictTotalOrder X lt` means that the binary relation `lt` on `X` is a strict total order,\nthat is, `IsTrichotomous X lt` and `IsStrictOrder X lt`. -/\nclass IsStrictTotalOrder (α : Sort*) (lt : α → α → Prop) extends IsTrichotomous α lt,\n    IsStrictOrder α lt : Prop\n\n"}
{"name":"eq_isEquiv","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\n⊢ IsEquiv α fun x1 x2 => Eq x1 x2","decl":"/-- Equality is an equivalence relation. -/\ninstance eq_isEquiv (α : Sort*) : IsEquiv α (· = ·) where\n  symm := @Eq.symm _\n  trans := @Eq.trans _\n  refl := Eq.refl\n\n"}
{"name":"iff_isEquiv","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"⊢ IsEquiv Prop Iff","decl":"/-- `Iff` is an equivalence relation. -/\ninstance iff_isEquiv : IsEquiv Prop Iff where\n  symm := @Iff.symm\n  trans := @Iff.trans\n  refl := @Iff.refl\n\n"}
{"name":"irrefl","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\ninst✝ : IsIrrefl α r\na : α\n⊢ Not (r a a)","decl":"lemma irrefl [IsIrrefl α r] (a : α) : ¬a ≺ a := IsIrrefl.irrefl a\n"}
{"name":"refl","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\ninst✝ : IsRefl α r\na : α\n⊢ r a a","decl":"lemma refl [IsRefl α r] (a : α) : a ≺ a := IsRefl.refl a\n"}
{"name":"trans","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\na b c : α\ninst✝ : IsTrans α r\na✝¹ : r a b\na✝ : r b c\n⊢ r a c","decl":"lemma trans [IsTrans α r] : a ≺ b → b ≺ c → a ≺ c := IsTrans.trans _ _ _\n"}
{"name":"symm","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\na b : α\ninst✝ : IsSymm α r\na✝ : r a b\n⊢ r b a","decl":"lemma symm [IsSymm α r] : a ≺ b → b ≺ a := IsSymm.symm _ _\n"}
{"name":"antisymm","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\na b : α\ninst✝ : IsAntisymm α r\na✝¹ : r a b\na✝ : r b a\n⊢ Eq a b","decl":"lemma antisymm [IsAntisymm α r] : a ≺ b → b ≺ a → a = b := IsAntisymm.antisymm _ _\n"}
{"name":"asymm","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\na b : α\ninst✝ : IsAsymm α r\na✝ : r a b\n⊢ Not (r b a)","decl":"lemma asymm [IsAsymm α r] : a ≺ b → ¬b ≺ a := IsAsymm.asymm _ _\n\n"}
{"name":"trichotomous","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\ninst✝ : IsTrichotomous α r\na b : α\n⊢ Or (r a b) (Or (Eq a b) (r b a))","decl":"lemma trichotomous [IsTrichotomous α r] : ∀ a b : α, a ≺ b ∨ a = b ∨ b ≺ a :=\n  IsTrichotomous.trichotomous\n\n"}
{"name":"isAsymm_of_isTrans_of_isIrrefl","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\ninst✝¹ : IsTrans α r\ninst✝ : IsIrrefl α r\n⊢ IsAsymm α r","decl":"instance (priority := 90) isAsymm_of_isTrans_of_isIrrefl [IsTrans α r] [IsIrrefl α r] :\n    IsAsymm α r :=\n  ⟨fun a _b h₁ h₂ => absurd (_root_.trans h₁ h₂) (irrefl a)⟩\n\n"}
{"name":"IsIrrefl.decide","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\ninst✝¹ : DecidableRel r\ninst✝ : IsIrrefl α r\n⊢ IsIrrefl α fun a b => Eq (Decidable.decide (r a b)) Bool.true","decl":"instance IsIrrefl.decide [DecidableRel r] [IsIrrefl α r] :\n    IsIrrefl α (fun a b => decide (r a b) = true) where\n  irrefl := fun a => by simpa using irrefl a\n\n"}
{"name":"IsRefl.decide","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\ninst✝¹ : DecidableRel r\ninst✝ : IsRefl α r\n⊢ IsRefl α fun a b => Eq (Decidable.decide (r a b)) Bool.true","decl":"instance IsRefl.decide [DecidableRel r] [IsRefl α r] :\n    IsRefl α (fun a b => decide (r a b) = true) where\n  refl := fun a => by simpa using refl a\n\n"}
{"name":"IsTrans.decide","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\ninst✝¹ : DecidableRel r\ninst✝ : IsTrans α r\n⊢ IsTrans α fun a b => Eq (Decidable.decide (r a b)) Bool.true","decl":"instance IsTrans.decide [DecidableRel r] [IsTrans α r] :\n    IsTrans α (fun a b => decide (r a b) = true) where\n  trans := fun a b c => by simpa using trans a b c\n\n"}
{"name":"IsSymm.decide","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\ninst✝¹ : DecidableRel r\ninst✝ : IsSymm α r\n⊢ IsSymm α fun a b => Eq (Decidable.decide (r a b)) Bool.true","decl":"instance IsSymm.decide [DecidableRel r] [IsSymm α r] :\n    IsSymm α (fun a b => decide (r a b) = true) where\n  symm := fun a b => by simpa using symm a b\n\n"}
{"name":"IsAntisymm.decide","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\ninst✝¹ : DecidableRel r\ninst✝ : IsAntisymm α r\n⊢ IsAntisymm α fun a b => Eq (Decidable.decide (r a b)) Bool.true","decl":"instance IsAntisymm.decide [DecidableRel r] [IsAntisymm α r] :\n    IsAntisymm α (fun a b => decide (r a b) = true) where\n  antisymm a b h₁ h₂ := antisymm (r := r) _ _ (by simpa using h₁) (by simpa using h₂)\n\n"}
{"name":"IsAsymm.decide","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\ninst✝¹ : DecidableRel r\ninst✝ : IsAsymm α r\n⊢ IsAsymm α fun a b => Eq (Decidable.decide (r a b)) Bool.true","decl":"instance IsAsymm.decide [DecidableRel r] [IsAsymm α r] :\n    IsAsymm α (fun a b => decide (r a b) = true) where\n  asymm := fun a b => by simpa using asymm a b\n\n"}
{"name":"IsTotal.decide","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\ninst✝¹ : DecidableRel r\ninst✝ : IsTotal α r\n⊢ IsTotal α fun a b => Eq (Decidable.decide (r a b)) Bool.true","decl":"instance IsTotal.decide [DecidableRel r] [IsTotal α r] :\n    IsTotal α (fun a b => decide (r a b) = true) where\n  total := fun a b => by simpa using total a b\n\n"}
{"name":"IsTrichotomous.decide","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\ninst✝¹ : DecidableRel r\ninst✝ : IsTrichotomous α r\n⊢ IsTrichotomous α fun a b => Eq (Decidable.decide (r a b)) Bool.true","decl":"instance IsTrichotomous.decide [DecidableRel r] [IsTrichotomous α r] :\n    IsTrichotomous α (fun a b => decide (r a b) = true) where\n  trichotomous := fun a b => by simpa using trichotomous a b\n\n"}
{"name":"irrefl_of","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\ninst✝ : IsIrrefl α r\na : α\n⊢ Not (r a a)","decl":"@[elab_without_expected_type] lemma irrefl_of [IsIrrefl α r] (a : α) : ¬a ≺ a := irrefl a\n"}
{"name":"refl_of","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\ninst✝ : IsRefl α r\na : α\n⊢ r a a","decl":"@[elab_without_expected_type] lemma refl_of [IsRefl α r] (a : α) : a ≺ a := refl a\n"}
{"name":"trans_of","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\na b c : α\ninst✝ : IsTrans α r\na✝¹ : r a b\na✝ : r b c\n⊢ r a c","decl":"@[elab_without_expected_type] lemma trans_of [IsTrans α r] : a ≺ b → b ≺ c → a ≺ c := _root_.trans\n"}
{"name":"symm_of","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\na b : α\ninst✝ : IsSymm α r\na✝ : r a b\n⊢ r b a","decl":"@[elab_without_expected_type] lemma symm_of [IsSymm α r] : a ≺ b → b ≺ a := symm\n"}
{"name":"asymm_of","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\na b : α\ninst✝ : IsAsymm α r\na✝ : r a b\n⊢ Not (r b a)","decl":"@[elab_without_expected_type] lemma asymm_of [IsAsymm α r] : a ≺ b → ¬b ≺ a := asymm\n\n"}
{"name":"total_of","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\ninst✝ : IsTotal α r\na b : α\n⊢ Or (r a b) (r b a)","decl":"@[elab_without_expected_type]\nlemma total_of [IsTotal α r] (a b : α) : a ≺ b ∨ b ≺ a := IsTotal.total _ _\n\n"}
{"name":"trichotomous_of","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\ninst✝ : IsTrichotomous α r\na b : α\n⊢ Or (r a b) (Or (Eq a b) (r b a))","decl":"@[elab_without_expected_type]\nlemma trichotomous_of [IsTrichotomous α r] : ∀ a b : α, a ≺ b ∨ a = b ∨ b ≺ a := trichotomous\n\n"}
{"name":"Equivalence.reflexive","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\nh : Equivalence r\n⊢ Reflexive r","decl":"@[deprecated Equivalence.refl (since := \"2024-09-13\")]\ntheorem Equivalence.reflexive (h : Equivalence r) : Reflexive r := h.refl\n\n"}
{"name":"Equivalence.symmetric","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\nh : Equivalence r\n⊢ Symmetric r","decl":"@[deprecated Equivalence.symm (since := \"2024-09-13\")]\ntheorem Equivalence.symmetric (h : Equivalence r) : Symmetric r :=\n  fun _ _ ↦ h.symm\n\n"}
{"name":"Equivalence.transitive","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nr : α → α → Prop\nh : Equivalence r\n⊢ Transitive r","decl":"@[deprecated Equivalence.trans (since := \"2024-09-13\")]\ntheorem Equivalence.transitive (h : Equivalence r) : Transitive r :=\n  fun _ _ _ ↦ h.trans\n\n"}
{"name":"InvImage.trans","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nβ : Sort u_2\nr : β → β → Prop\nf : α → β\nh : Transitive r\n⊢ Transitive (InvImage r f)","decl":"@[deprecated \"No deprecation message was provided.\" (since := \"2024-09-13\")]\ntheorem InvImage.trans (h : Transitive r) : Transitive (InvImage r f) :=\n  fun (a₁ a₂ a₃ : α) (h₁ : InvImage r f a₁ a₂) (h₂ : InvImage r f a₂ a₃) ↦ h h₁ h₂\n\n"}
{"name":"InvImage.irreflexive","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Sort u_1\nβ : Sort u_2\nr : β → β → Prop\nf : α → β\nh : Irreflexive r\n⊢ Irreflexive (InvImage r f)","decl":"@[deprecated \"No deprecation message was provided.\" (since := \"2024-09-13\")]\ntheorem InvImage.irreflexive (h : Irreflexive r) : Irreflexive (InvImage r f) :=\n  fun (a : α) (h₁ : InvImage r f a a) ↦ h (f a) h₁\n\n"}
{"name":"Minimal.prop","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Type u_1\ninst✝ : LE α\nP : α → Prop\nx : α\nh : Minimal P x\n⊢ P x","decl":"lemma Minimal.prop (h : Minimal P x) : P x :=\n  h.1\n\n"}
{"name":"Maximal.prop","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Type u_1\ninst✝ : LE α\nP : α → Prop\nx : α\nh : Maximal P x\n⊢ P x","decl":"lemma Maximal.prop (h : Maximal P x) : P x :=\n  h.1\n\n"}
{"name":"Minimal.le_of_le","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Type u_1\ninst✝ : LE α\nP : α → Prop\nx y : α\nh : Minimal P x\nhy : P y\nhle : LE.le y x\n⊢ LE.le x y","decl":"lemma Minimal.le_of_le (h : Minimal P x) (hy : P y) (hle : y ≤ x) : x ≤ y :=\n  h.2 hy hle\n\n"}
{"name":"Maximal.le_of_ge","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Type u_1\ninst✝ : LE α\nP : α → Prop\nx y : α\nh : Maximal P x\nhy : P y\nhge : LE.le x y\n⊢ LE.le y x","decl":"lemma Maximal.le_of_ge (h : Maximal P x) (hy : P y) (hge : x ≤ y) : y ≤ x :=\n  h.2 hy hge\n\n"}
{"name":"UpperSet.mk.inj","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Type u_1\ninst✝ : LE α\ncarrier✝ : Set α\nupper'✝ : IsUpperSet carrier✝\ncarrier : Set α\nupper' : IsUpperSet carrier\nx✝ : Eq { carrier := carrier✝, upper' := upper'✝ } { carrier := carrier, upper' := upper' }\n⊢ Eq carrier✝ carrier","decl":"@[inherit_doc IsUpperSet]\nstructure UpperSet (α : Type*) [LE α] where\n  /-- The carrier of an `UpperSet`. -/\n  carrier : Set α\n  /-- The carrier of an `UpperSet` is an upper set. -/\n  upper' : IsUpperSet carrier\n\n"}
{"name":"UpperSet.mk.sizeOf_spec","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Type u_1\ninst✝¹ : LE α\ninst✝ : SizeOf α\ncarrier : Set α\nupper' : IsUpperSet carrier\n⊢ Eq (SizeOf.sizeOf { carrier := carrier, upper' := upper' }) 1","decl":"@[inherit_doc IsUpperSet]\nstructure UpperSet (α : Type*) [LE α] where\n  /-- The carrier of an `UpperSet`. -/\n  carrier : Set α\n  /-- The carrier of an `UpperSet` is an upper set. -/\n  upper' : IsUpperSet carrier\n\n"}
{"name":"UpperSet.upper'","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Type u_1\ninst✝ : LE α\nself : UpperSet α\n⊢ IsUpperSet self.carrier","decl":"@[inherit_doc IsUpperSet]\nstructure UpperSet (α : Type*) [LE α] where\n  /-- The carrier of an `UpperSet`. -/\n  carrier : Set α\n  /-- The carrier of an `UpperSet` is an upper set. -/\n  upper' : IsUpperSet carrier\n\n"}
{"name":"UpperSet.mk.injEq","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Type u_1\ninst✝ : LE α\ncarrier✝ : Set α\nupper'✝ : IsUpperSet carrier✝\ncarrier : Set α\nupper' : IsUpperSet carrier\n⊢ Eq (Eq { carrier := carrier✝, upper' := upper'✝ } { carrier := carrier, upper' := upper' }) (Eq carrier✝ carrier)","decl":"@[inherit_doc IsUpperSet]\nstructure UpperSet (α : Type*) [LE α] where\n  /-- The carrier of an `UpperSet`. -/\n  carrier : Set α\n  /-- The carrier of an `UpperSet` is an upper set. -/\n  upper' : IsUpperSet carrier\n\n"}
{"name":"LowerSet.mk.injEq","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Type u_1\ninst✝ : LE α\ncarrier✝ : Set α\nlower'✝ : IsLowerSet carrier✝\ncarrier : Set α\nlower' : IsLowerSet carrier\n⊢ Eq (Eq { carrier := carrier✝, lower' := lower'✝ } { carrier := carrier, lower' := lower' }) (Eq carrier✝ carrier)","decl":"@[inherit_doc IsLowerSet]\nstructure LowerSet (α : Type*) [LE α] where\n  /-- The carrier of a `LowerSet`. -/\n  carrier : Set α\n  /-- The carrier of a `LowerSet` is a lower set. -/\n  lower' : IsLowerSet carrier\n\n"}
{"name":"LowerSet.mk.sizeOf_spec","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Type u_1\ninst✝¹ : LE α\ninst✝ : SizeOf α\ncarrier : Set α\nlower' : IsLowerSet carrier\n⊢ Eq (SizeOf.sizeOf { carrier := carrier, lower' := lower' }) 1","decl":"@[inherit_doc IsLowerSet]\nstructure LowerSet (α : Type*) [LE α] where\n  /-- The carrier of a `LowerSet`. -/\n  carrier : Set α\n  /-- The carrier of a `LowerSet` is a lower set. -/\n  lower' : IsLowerSet carrier\n\n"}
{"name":"LowerSet.lower'","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Type u_1\ninst✝ : LE α\nself : LowerSet α\n⊢ IsLowerSet self.carrier","decl":"@[inherit_doc IsLowerSet]\nstructure LowerSet (α : Type*) [LE α] where\n  /-- The carrier of a `LowerSet`. -/\n  carrier : Set α\n  /-- The carrier of a `LowerSet` is a lower set. -/\n  lower' : IsLowerSet carrier\n\n"}
{"name":"LowerSet.mk.inj","module":"Mathlib.Order.Defs.Unbundled","initialProofState":"α : Type u_1\ninst✝ : LE α\ncarrier✝ : Set α\nlower'✝ : IsLowerSet carrier✝\ncarrier : Set α\nlower' : IsLowerSet carrier\nx✝ : Eq { carrier := carrier✝, lower' := lower'✝ } { carrier := carrier, lower' := lower' }\n⊢ Eq carrier✝ carrier","decl":"@[inherit_doc IsLowerSet]\nstructure LowerSet (α : Type*) [LE α] where\n  /-- The carrier of a `LowerSet`. -/\n  carrier : Set α\n  /-- The carrier of a `LowerSet` is a lower set. -/\n  lower' : IsLowerSet carrier\n\n"}
