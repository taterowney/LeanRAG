{"name":"CategoryTheory.Sheaf.adjunction_unit_app_val","module":"Mathlib.CategoryTheory.Sites.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} E\nF : CategoryTheory.Functor D E\nG : CategoryTheory.Functor E D\ninst‚úù¬π : CategoryTheory.HasWeakSheafify J D\ninst‚úù : J.HasSheafCompose F\nadj : CategoryTheory.Adjunction G F\nX : CategoryTheory.Sheaf J E\n‚ä¢ Eq ((CategoryTheory.Sheaf.adjunction J adj).unit.app X).val (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Adjunction.whiskerRight (Opposite C) adj).unit.app X.val) (CategoryTheory.whiskerRight (CategoryTheory.toSheafify J (X.val.comp G)) F))","decl":"@[simp]\nlemma adjunction_unit_app_val [HasWeakSheafify J D] [HasSheafCompose J F] (adj : G ‚ä£ F)\n    (X : Sheaf J E) : ((adjunction J adj).unit.app X).val =\n      (adj.whiskerRight C·µí·µñ).unit.app _ ‚â´ whiskerRight (toSheafify J (X.val ‚ãô G)) F  := by\n  change (sheafToPresheaf _ _).map ((adjunction J adj).unit.app X) = _\n  simp only [Functor.id_obj, Functor.comp_obj, whiskeringRight_obj_obj, adjunction,\n    Adjunction.map_restrictFullyFaithful_unit_app, Adjunction.comp_unit_app,\n    sheafificationAdjunction_unit_app, whiskeringRight_obj_map, Iso.refl_hom, NatTrans.id_app,\n    Functor.comp_map, Functor.map_id, whiskerRight_id', Category.comp_id]\n  rfl\n\n"}
{"name":"CategoryTheory.Sheaf.adjunction_counit_app_val","module":"Mathlib.CategoryTheory.Sites.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} E\nF : CategoryTheory.Functor D E\nG : CategoryTheory.Functor E D\ninst‚úù¬π : CategoryTheory.HasWeakSheafify J D\ninst‚úù : J.HasSheafCompose F\nadj : CategoryTheory.Adjunction G F\nY : CategoryTheory.Sheaf J D\n‚ä¢ Eq ((CategoryTheory.Sheaf.adjunction J adj).counit.app Y).val (CategoryTheory.sheafifyLift J ((CategoryTheory.Adjunction.whiskerRight (Opposite C) adj).counit.app Y.val) ‚ãØ)","decl":"@[simp]\nlemma adjunction_counit_app_val [HasWeakSheafify J D] [HasSheafCompose J F] (adj : G ‚ä£ F)\n    (Y : Sheaf J D) : ((adjunction J adj).counit.app Y).val =\n      sheafifyLift J (((adj.whiskerRight C·µí·µñ).counit.app Y.val)) Y.cond := by\n  change ((ùü≠ (Sheaf _ _)).map ((adjunction J adj).counit.app Y)).val = _\n  simp only [Functor.comp_obj, sheafToPresheaf_obj, sheafCompose_obj_val, whiskeringRight_obj_obj,\n    adjunction, Adjunction.map_restrictFullyFaithful_counit_app, Iso.refl_inv, NatTrans.id_app,\n    Functor.comp_map, whiskeringRight_obj_map, Adjunction.comp_counit_app,\n    instCategorySheaf_comp_val, instCategorySheaf_id_val, sheafificationAdjunction_counit_app_val,\n    sheafifyMap_sheafifyLift, Functor.id_obj, whiskerRight_id', Category.comp_id, Category.id_comp]\n\n\n"}
{"name":"CategoryTheory.Sheaf.instIsRightAdjointSheafComposeOfHasWeakSheafify","module":"Mathlib.CategoryTheory.Sites.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} E\nF : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.HasWeakSheafify J D\ninst‚úù : F.IsRightAdjoint\n‚ä¢ (CategoryTheory.sheafCompose J F).IsRightAdjoint","decl":"instance [HasWeakSheafify J D] [F.IsRightAdjoint] : (sheafCompose J F).IsRightAdjoint :=\n  (adjunction J (Adjunction.ofIsRightAdjoint F)).isRightAdjoint\n\n"}
{"name":"CategoryTheory.Sheaf.instIsLeftAdjointComposeAndSheafify","module":"Mathlib.CategoryTheory.Sites.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} E\nG : CategoryTheory.Functor E D\ninst‚úù¬π : CategoryTheory.HasWeakSheafify J D\ninst‚úù : G.IsLeftAdjoint\n‚ä¢ (CategoryTheory.Sheaf.composeAndSheafify J G).IsLeftAdjoint","decl":"instance [HasWeakSheafify J D] [G.IsLeftAdjoint] : (composeAndSheafify J G).IsLeftAdjoint :=\n  (adjunction J (Adjunction.ofIsLeftAdjoint G)).isLeftAdjoint\n\n"}
{"name":"CategoryTheory.Sheaf.preservesSheafification_of_adjunction","module":"Mathlib.CategoryTheory.Sites.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} E\nF : CategoryTheory.Functor D E\nG : CategoryTheory.Functor E D\nadj : CategoryTheory.Adjunction G F\n‚ä¢ J.PreservesSheafification G","decl":"lemma preservesSheafification_of_adjunction (adj : G ‚ä£ F) :\n    J.PreservesSheafification G where\n  le P Q f hf := by\n    have := adj.isRightAdjoint\n    rw [MorphismProperty.inverseImage_iff]\n    dsimp\n    intro R hR\n    rw [‚Üê ((adj.whiskerRight C·µí·µñ).homEquiv P R).comp_bijective]\n    convert (((adj.whiskerRight C·µí·µñ).homEquiv Q R).trans\n      (hf.homEquiv (R ‚ãô F) ((sheafCompose J F).obj ‚ü®R, hR‚ü©).cond)).bijective\n    ext g X\n    -- The rest of this proof was\n    -- `dsimp [Adjunction.whiskerRight, Adjunction.mkOfUnitCounit]; simp` before https://github.com/leanprover-community/mathlib4/pull/16317.\n    dsimp\n    rw [‚Üê NatTrans.comp_app]\n    congr\n    exact Adjunction.homEquiv_naturality_left _ _ _\n\n"}
{"name":"CategoryTheory.Sheaf.instPreservesSheafificationOfIsLeftAdjoint","module":"Mathlib.CategoryTheory.Sites.Adjunction","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} E\nG : CategoryTheory.Functor E D\ninst‚úù : G.IsLeftAdjoint\n‚ä¢ J.PreservesSheafification G","decl":"instance [G.IsLeftAdjoint] : J.PreservesSheafification G :=\n  preservesSheafification_of_adjunction J (Adjunction.ofIsLeftAdjoint G)\n\n"}
