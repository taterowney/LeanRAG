{"name":"iSup_eq_iSup_finset","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝ : CompleteLattice α\ns : ι → α\n⊢ Eq (iSup fun i => s i) (iSup fun t => iSup fun i => iSup fun h => s i)","decl":"/-- Supremum of `s i`, `i : ι`, is equal to the supremum over `t : Finset ι` of suprema\n`⨆ i ∈ t, s i`. This version assumes `ι` is a `Type*`. See `iSup_eq_iSup_finset'` for a version\nthat works for `ι : Sort*`. -/\ntheorem iSup_eq_iSup_finset (s : ι → α) : ⨆ i, s i = ⨆ t : Finset ι, ⨆ i ∈ t, s i := by\n  classical\n  refine le_antisymm ?_ ?_\n  · exact iSup_le fun b => le_iSup_of_le {b} <| le_iSup_of_le b <| le_iSup_of_le (by simp) <| le_rfl\n  · exact iSup_le fun t => iSup_le fun b => iSup_le fun _ => le_iSup _ _\n\n"}
{"name":"iSup_eq_iSup_finset'","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nι' : Sort u_7\ninst✝ : CompleteLattice α\ns : ι' → α\n⊢ Eq (iSup fun i => s i) (iSup fun t => iSup fun i => iSup fun h => s i.down)","decl":"/-- Supremum of `s i`, `i : ι`, is equal to the supremum over `t : Finset ι` of suprema\n`⨆ i ∈ t, s i`. This version works for `ι : Sort*`. See `iSup_eq_iSup_finset` for a version\nthat assumes `ι : Type*` but has no `PLift`s. -/\ntheorem iSup_eq_iSup_finset' (s : ι' → α) :\n    ⨆ i, s i = ⨆ t : Finset (PLift ι'), ⨆ i ∈ t, s (PLift.down i) := by\n  rw [← iSup_eq_iSup_finset, ← Equiv.plift.surjective.iSup_comp]; rfl\n\n"}
{"name":"iInf_eq_iInf_finset","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nι : Type u_5\ninst✝ : CompleteLattice α\ns : ι → α\n⊢ Eq (iInf fun i => s i) (iInf fun t => iInf fun i => iInf fun h => s i)","decl":"/-- Infimum of `s i`, `i : ι`, is equal to the infimum over `t : Finset ι` of infima\n`⨅ i ∈ t, s i`. This version assumes `ι` is a `Type*`. See `iInf_eq_iInf_finset'` for a version\nthat works for `ι : Sort*`. -/\ntheorem iInf_eq_iInf_finset (s : ι → α) : ⨅ i, s i = ⨅ (t : Finset ι) (i ∈ t), s i :=\n  @iSup_eq_iSup_finset αᵒᵈ _ _ _\n\n"}
{"name":"iInf_eq_iInf_finset'","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nι' : Sort u_7\ninst✝ : CompleteLattice α\ns : ι' → α\n⊢ Eq (iInf fun i => s i) (iInf fun t => iInf fun i => iInf fun h => s i.down)","decl":"/-- Infimum of `s i`, `i : ι`, is equal to the infimum over `t : Finset ι` of infima\n`⨅ i ∈ t, s i`. This version works for `ι : Sort*`. See `iInf_eq_iInf_finset` for a version\nthat assumes `ι : Type*` but has no `PLift`s. -/\ntheorem iInf_eq_iInf_finset' (s : ι' → α) :\n    ⨅ i, s i = ⨅ t : Finset (PLift ι'), ⨅ i ∈ t, s (PLift.down i) :=\n  @iSup_eq_iSup_finset' αᵒᵈ _ _ _\n\n"}
{"name":"Set.iUnion_eq_iUnion_finset","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nι : Type u_5\ns : ι → Set α\n⊢ Eq (Set.iUnion fun i => s i) (Set.iUnion fun t => Set.iUnion fun i => Set.iUnion fun h => s i)","decl":"/-- Union of an indexed family of sets `s : ι → Set α` is equal to the union of the unions\nof finite subfamilies. This version assumes `ι : Type*`. See also `iUnion_eq_iUnion_finset'` for\na version that works for `ι : Sort*`. -/\ntheorem iUnion_eq_iUnion_finset (s : ι → Set α) : ⋃ i, s i = ⋃ t : Finset ι, ⋃ i ∈ t, s i :=\n  iSup_eq_iSup_finset s\n\n"}
{"name":"Set.iUnion_eq_iUnion_finset'","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nι' : Sort u_7\ns : ι' → Set α\n⊢ Eq (Set.iUnion fun i => s i) (Set.iUnion fun t => Set.iUnion fun i => Set.iUnion fun h => s i.down)","decl":"/-- Union of an indexed family of sets `s : ι → Set α` is equal to the union of the unions\nof finite subfamilies. This version works for `ι : Sort*`. See also `iUnion_eq_iUnion_finset` for\na version that assumes `ι : Type*` but avoids `PLift`s in the right hand side. -/\ntheorem iUnion_eq_iUnion_finset' (s : ι' → Set α) :\n    ⋃ i, s i = ⋃ t : Finset (PLift ι'), ⋃ i ∈ t, s (PLift.down i) :=\n  iSup_eq_iSup_finset' s\n\n"}
{"name":"Set.iInter_eq_iInter_finset","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nι : Type u_5\ns : ι → Set α\n⊢ Eq (Set.iInter fun i => s i) (Set.iInter fun t => Set.iInter fun i => Set.iInter fun h => s i)","decl":"/-- Intersection of an indexed family of sets `s : ι → Set α` is equal to the intersection of the\nintersections of finite subfamilies. This version assumes `ι : Type*`. See also\n`iInter_eq_iInter_finset'` for a version that works for `ι : Sort*`. -/\ntheorem iInter_eq_iInter_finset (s : ι → Set α) : ⋂ i, s i = ⋂ t : Finset ι, ⋂ i ∈ t, s i :=\n  iInf_eq_iInf_finset s\n\n"}
{"name":"Set.iInter_eq_iInter_finset'","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nι' : Sort u_7\ns : ι' → Set α\n⊢ Eq (Set.iInter fun i => s i) (Set.iInter fun t => Set.iInter fun i => Set.iInter fun h => s i.down)","decl":"/-- Intersection of an indexed family of sets `s : ι → Set α` is equal to the intersection of the\nintersections of finite subfamilies. This version works for `ι : Sort*`. See also\n`iInter_eq_iInter_finset` for a version that assumes `ι : Type*` but avoids `PLift`s in the right\nhand side. -/\ntheorem iInter_eq_iInter_finset' (s : ι' → Set α) :\n    ⋂ i, s i = ⋂ t : Finset (PLift ι'), ⋂ i ∈ t, s (PLift.down i) :=\n  iInf_eq_iInf_finset' s\n\n"}
{"name":"Finset.maximal_iff_forall_insert","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\ninst✝ : DecidableEq α\nP : Finset α → Prop\ns : Finset α\nhP : ∀ ⦃s t : Finset α⦄, P t → HasSubset.Subset s t → P s\n⊢ Iff (Maximal P s) (And (P s) (∀ (x : α), Not (Membership.mem s x) → Not (P (Insert.insert x s))))","decl":"theorem maximal_iff_forall_insert (hP : ∀ ⦃s t⦄, P t → s ⊆ t → P s) :\n    Maximal P s ↔ P s ∧ ∀ x ∉ s, ¬ P (insert x s) := by\n  simp only [Maximal, and_congr_right_iff]\n  exact fun _ ↦ ⟨fun h x hxs hx ↦ hxs <| h hx (subset_insert _ _) (mem_insert_self x s),\n    fun h t ht hst x hxt ↦ by_contra fun hxs ↦ h x hxs (hP ht (insert_subset hxt hst))⟩\n\n"}
{"name":"Finset.minimal_iff_forall_diff_singleton","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\ninst✝ : DecidableEq α\nP : Finset α → Prop\ns : Finset α\nhP : ∀ ⦃s t : Finset α⦄, P t → HasSubset.Subset t s → P s\n⊢ Iff (Minimal P s) (And (P s) (∀ (x : α), Membership.mem s x → Not (P (s.erase x))))","decl":"theorem minimal_iff_forall_diff_singleton (hP : ∀ ⦃s t⦄, P t → t ⊆ s → P s) :\n    Minimal P s ↔ P s ∧ ∀ x ∈ s, ¬ P (s.erase x) where\n  mp h := ⟨h.prop, fun x hxs hx ↦ by simpa using h.le_of_le hx (erase_subset _ _) hxs⟩\n  mpr h := ⟨h.1, fun t ht hts x hxs ↦ by_contra fun hxt ↦\n    h.2 x hxs <| hP ht (subset_erase.2 ⟨hts, hxt⟩)⟩\n\n"}
{"name":"Finset.iSup_coe","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SupSet β\nf : α → β\ns : Finset α\n⊢ Eq (iSup fun x => iSup fun h => f x) (iSup fun x => iSup fun h => f x)","decl":"theorem iSup_coe [SupSet β] (f : α → β) (s : Finset α) : ⨆ x ∈ (↑s : Set α), f x = ⨆ x ∈ s, f x :=\n  rfl\n\n"}
{"name":"Finset.iInf_coe","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : InfSet β\nf : α → β\ns : Finset α\n⊢ Eq (iInf fun x => iInf fun h => f x) (iInf fun x => iInf fun h => f x)","decl":"theorem iInf_coe [InfSet β] (f : α → β) (s : Finset α) : ⨅ x ∈ (↑s : Set α), f x = ⨅ x ∈ s, f x :=\n  rfl\n\n"}
{"name":"Finset.iSup_singleton","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : CompleteLattice β\na : α\ns : α → β\n⊢ Eq (iSup fun x => iSup fun h => s x) (s a)","decl":"theorem iSup_singleton (a : α) (s : α → β) : ⨆ x ∈ ({a} : Finset α), s x = s a := by simp\n\n"}
{"name":"Finset.iInf_singleton","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : CompleteLattice β\na : α\ns : α → β\n⊢ Eq (iInf fun x => iInf fun h => s x) (s a)","decl":"theorem iInf_singleton (a : α) (s : α → β) : ⨅ x ∈ ({a} : Finset α), s x = s a := by simp\n\n"}
{"name":"Finset.iSup_option_toFinset","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : CompleteLattice β\no : Option α\nf : α → β\n⊢ Eq (iSup fun x => iSup fun h => f x) (iSup fun x => iSup fun h => f x)","decl":"theorem iSup_option_toFinset (o : Option α) (f : α → β) : ⨆ x ∈ o.toFinset, f x = ⨆ x ∈ o, f x := by\n  simp\n\n"}
{"name":"Finset.iInf_option_toFinset","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : CompleteLattice β\no : Option α\nf : α → β\n⊢ Eq (iInf fun x => iInf fun h => f x) (iInf fun x => iInf fun h => f x)","decl":"theorem iInf_option_toFinset (o : Option α) (f : α → β) : ⨅ x ∈ o.toFinset, f x = ⨅ x ∈ o, f x :=\n  @iSup_option_toFinset _ βᵒᵈ _ _ _\n\n"}
{"name":"Finset.iSup_union","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CompleteLattice β\ninst✝ : DecidableEq α\nf : α → β\ns t : Finset α\n⊢ Eq (iSup fun x => iSup fun h => f x) (Max.max (iSup fun x => iSup fun h => f x) (iSup fun x => iSup fun h => f x))","decl":"theorem iSup_union {f : α → β} {s t : Finset α} :\n    ⨆ x ∈ s ∪ t, f x = (⨆ x ∈ s, f x) ⊔ ⨆ x ∈ t, f x := by simp [iSup_or, iSup_sup_eq]\n\n"}
{"name":"Finset.iInf_union","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CompleteLattice β\ninst✝ : DecidableEq α\nf : α → β\ns t : Finset α\n⊢ Eq (iInf fun x => iInf fun h => f x) (Min.min (iInf fun x => iInf fun h => f x) (iInf fun x => iInf fun h => f x))","decl":"theorem iInf_union {f : α → β} {s t : Finset α} :\n    ⨅ x ∈ s ∪ t, f x = (⨅ x ∈ s, f x) ⊓ ⨅ x ∈ t, f x :=\n  @iSup_union α βᵒᵈ _ _ _ _ _\n\n"}
{"name":"Finset.iSup_insert","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CompleteLattice β\ninst✝ : DecidableEq α\na : α\ns : Finset α\nt : α → β\n⊢ Eq (iSup fun x => iSup fun h => t x) (Max.max (t a) (iSup fun x => iSup fun h => t x))","decl":"theorem iSup_insert (a : α) (s : Finset α) (t : α → β) :\n    ⨆ x ∈ insert a s, t x = t a ⊔ ⨆ x ∈ s, t x := by\n  rw [insert_eq]\n  simp only [iSup_union, Finset.iSup_singleton]\n\n"}
{"name":"Finset.iInf_insert","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CompleteLattice β\ninst✝ : DecidableEq α\na : α\ns : Finset α\nt : α → β\n⊢ Eq (iInf fun x => iInf fun h => t x) (Min.min (t a) (iInf fun x => iInf fun h => t x))","decl":"theorem iInf_insert (a : α) (s : Finset α) (t : α → β) :\n    ⨅ x ∈ insert a s, t x = t a ⊓ ⨅ x ∈ s, t x :=\n  @iSup_insert α βᵒᵈ _ _ _ _ _\n\n"}
{"name":"Finset.iSup_finset_image","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝¹ : CompleteLattice β\ninst✝ : DecidableEq α\nf : γ → α\ng : α → β\ns : Finset γ\n⊢ Eq (iSup fun x => iSup fun h => g x) (iSup fun y => iSup fun h => g (f y))","decl":"theorem iSup_finset_image {f : γ → α} {g : α → β} {s : Finset γ} :\n    ⨆ x ∈ s.image f, g x = ⨆ y ∈ s, g (f y) := by rw [← iSup_coe, coe_image, iSup_image, iSup_coe]\n\n"}
{"name":"Finset.iInf_finset_image","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝¹ : CompleteLattice β\ninst✝ : DecidableEq α\nf : γ → α\ng : α → β\ns : Finset γ\n⊢ Eq (iInf fun x => iInf fun h => g x) (iInf fun y => iInf fun h => g (f y))","decl":"theorem iInf_finset_image {f : γ → α} {g : α → β} {s : Finset γ} :\n    ⨅ x ∈ s.image f, g x = ⨅ y ∈ s, g (f y) := by rw [← iInf_coe, coe_image, iInf_image, iInf_coe]\n\n"}
{"name":"Finset.iSup_insert_update","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CompleteLattice β\ninst✝ : DecidableEq α\nx : α\nt : Finset α\nf : α → β\ns : β\nhx : Not (Membership.mem t x)\n⊢ Eq (iSup fun i => iSup fun h => Function.update f x s i) (Max.max s (iSup fun i => iSup fun h => f i))","decl":"theorem iSup_insert_update {x : α} {t : Finset α} (f : α → β) {s : β} (hx : x ∉ t) :\n    ⨆ i ∈ insert x t, Function.update f x s i = s ⊔ ⨆ i ∈ t, f i := by\n  simp only [Finset.iSup_insert, update_self]\n  rcongr (i hi); apply update_of_ne; rintro rfl; exact hx hi\n\n"}
{"name":"Finset.iInf_insert_update","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CompleteLattice β\ninst✝ : DecidableEq α\nx : α\nt : Finset α\nf : α → β\ns : β\nhx : Not (Membership.mem t x)\n⊢ Eq (iInf fun i => iInf fun h => Function.update f x s i) (Min.min s (iInf fun i => iInf fun h => f i))","decl":"theorem iInf_insert_update {x : α} {t : Finset α} (f : α → β) {s : β} (hx : x ∉ t) :\n    ⨅ i ∈ insert x t, update f x s i = s ⊓ ⨅ i ∈ t, f i :=\n  @iSup_insert_update α βᵒᵈ _ _ _ _ f _ hx\n\n"}
{"name":"Finset.iSup_biUnion","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝¹ : CompleteLattice β\ninst✝ : DecidableEq α\ns : Finset γ\nt : γ → Finset α\nf : α → β\n⊢ Eq (iSup fun y => iSup fun h => f y) (iSup fun x => iSup fun h => iSup fun y => iSup fun h => f y)","decl":"theorem iSup_biUnion (s : Finset γ) (t : γ → Finset α) (f : α → β) :\n    ⨆ y ∈ s.biUnion t, f y = ⨆ (x ∈ s) (y ∈ t x), f y := by simp [@iSup_comm _ α, iSup_and]\n\n"}
{"name":"Finset.iInf_biUnion","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝¹ : CompleteLattice β\ninst✝ : DecidableEq α\ns : Finset γ\nt : γ → Finset α\nf : α → β\n⊢ Eq (iInf fun y => iInf fun h => f y) (iInf fun x => iInf fun h => iInf fun y => iInf fun h => f y)","decl":"theorem iInf_biUnion (s : Finset γ) (t : γ → Finset α) (f : α → β) :\n    ⨅ y ∈ s.biUnion t, f y = ⨅ (x ∈ s) (y ∈ t x), f y :=\n  @iSup_biUnion _ βᵒᵈ _ _ _ _ _ _\n\n"}
{"name":"Finset.set_biUnion_coe","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ns : Finset α\nt : α → Set β\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun h => t x) (Set.iUnion fun x => Set.iUnion fun h => t x)","decl":"theorem set_biUnion_coe (s : Finset α) (t : α → Set β) : ⋃ x ∈ (↑s : Set α), t x = ⋃ x ∈ s, t x :=\n  rfl\n\n"}
{"name":"Finset.set_biInter_coe","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ns : Finset α\nt : α → Set β\n⊢ Eq (Set.iInter fun x => Set.iInter fun h => t x) (Set.iInter fun x => Set.iInter fun h => t x)","decl":"theorem set_biInter_coe (s : Finset α) (t : α → Set β) : ⋂ x ∈ (↑s : Set α), t x = ⋂ x ∈ s, t x :=\n  rfl\n\n"}
{"name":"Finset.set_biUnion_singleton","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\na : α\ns : α → Set β\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun h => s x) (s a)","decl":"theorem set_biUnion_singleton (a : α) (s : α → Set β) : ⋃ x ∈ ({a} : Finset α), s x = s a :=\n  iSup_singleton a s\n\n"}
{"name":"Finset.set_biInter_singleton","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\na : α\ns : α → Set β\n⊢ Eq (Set.iInter fun x => Set.iInter fun h => s x) (s a)","decl":"theorem set_biInter_singleton (a : α) (s : α → Set β) : ⋂ x ∈ ({a} : Finset α), s x = s a :=\n  iInf_singleton a s\n\n"}
{"name":"Finset.set_biUnion_preimage_singleton","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\nf : α → β\ns : Finset β\n⊢ Eq (Set.iUnion fun y => Set.iUnion fun h => Set.preimage f (Singleton.singleton y)) (Set.preimage f ↑s)","decl":"@[simp]\ntheorem set_biUnion_preimage_singleton (f : α → β) (s : Finset β) :\n    ⋃ y ∈ s, f ⁻¹' {y} = f ⁻¹' s :=\n  Set.biUnion_preimage_singleton f s\n\n"}
{"name":"Finset.set_biUnion_option_toFinset","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\no : Option α\nf : α → Set β\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun h => f x) (Set.iUnion fun x => Set.iUnion fun h => f x)","decl":"theorem set_biUnion_option_toFinset (o : Option α) (f : α → Set β) :\n    ⋃ x ∈ o.toFinset, f x = ⋃ x ∈ o, f x :=\n  iSup_option_toFinset o f\n\n"}
{"name":"Finset.set_biInter_option_toFinset","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\no : Option α\nf : α → Set β\n⊢ Eq (Set.iInter fun x => Set.iInter fun h => f x) (Set.iInter fun x => Set.iInter fun h => f x)","decl":"theorem set_biInter_option_toFinset (o : Option α) (f : α → Set β) :\n    ⋂ x ∈ o.toFinset, f x = ⋂ x ∈ o, f x :=\n  iInf_option_toFinset o f\n\n"}
{"name":"Finset.subset_set_biUnion_of_mem","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ns : Finset α\nf : α → Set β\nx : α\nh : Membership.mem s x\n⊢ HasSubset.Subset (f x) (Set.iUnion fun y => Set.iUnion fun h => f y)","decl":"theorem subset_set_biUnion_of_mem {s : Finset α} {f : α → Set β} {x : α} (h : x ∈ s) :\n    f x ⊆ ⋃ y ∈ s, f y :=\n  show f x ≤ ⨆ y ∈ s, f y from le_iSup_of_le x <| by simp only [h, iSup_pos, le_refl]\n\n"}
{"name":"Finset.set_biUnion_union","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : DecidableEq α\ns t : Finset α\nu : α → Set β\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun h => u x) (Union.union (Set.iUnion fun x => Set.iUnion fun h => u x) (Set.iUnion fun x => Set.iUnion fun h => u x))","decl":"theorem set_biUnion_union (s t : Finset α) (u : α → Set β) :\n    ⋃ x ∈ s ∪ t, u x = (⋃ x ∈ s, u x) ∪ ⋃ x ∈ t, u x :=\n  iSup_union\n\n"}
{"name":"Finset.set_biInter_inter","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : DecidableEq α\ns t : Finset α\nu : α → Set β\n⊢ Eq (Set.iInter fun x => Set.iInter fun h => u x) (Inter.inter (Set.iInter fun x => Set.iInter fun h => u x) (Set.iInter fun x => Set.iInter fun h => u x))","decl":"theorem set_biInter_inter (s t : Finset α) (u : α → Set β) :\n    ⋂ x ∈ s ∪ t, u x = (⋂ x ∈ s, u x) ∩ ⋂ x ∈ t, u x :=\n  iInf_union\n\n"}
{"name":"Finset.set_biUnion_insert","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : DecidableEq α\na : α\ns : Finset α\nt : α → Set β\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun h => t x) (Union.union (t a) (Set.iUnion fun x => Set.iUnion fun h => t x))","decl":"theorem set_biUnion_insert (a : α) (s : Finset α) (t : α → Set β) :\n    ⋃ x ∈ insert a s, t x = t a ∪ ⋃ x ∈ s, t x :=\n  iSup_insert a s t\n\n"}
{"name":"Finset.set_biInter_insert","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : DecidableEq α\na : α\ns : Finset α\nt : α → Set β\n⊢ Eq (Set.iInter fun x => Set.iInter fun h => t x) (Inter.inter (t a) (Set.iInter fun x => Set.iInter fun h => t x))","decl":"theorem set_biInter_insert (a : α) (s : Finset α) (t : α → Set β) :\n    ⋂ x ∈ insert a s, t x = t a ∩ ⋂ x ∈ s, t x :=\n  iInf_insert a s t\n\n"}
{"name":"Finset.set_biUnion_finset_image","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝ : DecidableEq α\nf : γ → α\ng : α → Set β\ns : Finset γ\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun h => g x) (Set.iUnion fun y => Set.iUnion fun h => g (f y))","decl":"theorem set_biUnion_finset_image {f : γ → α} {g : α → Set β} {s : Finset γ} :\n    ⋃ x ∈ s.image f, g x = ⋃ y ∈ s, g (f y) :=\n  iSup_finset_image\n\n"}
{"name":"Finset.set_biInter_finset_image","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝ : DecidableEq α\nf : γ → α\ng : α → Set β\ns : Finset γ\n⊢ Eq (Set.iInter fun x => Set.iInter fun h => g x) (Set.iInter fun y => Set.iInter fun h => g (f y))","decl":"theorem set_biInter_finset_image {f : γ → α} {g : α → Set β} {s : Finset γ} :\n    ⋂ x ∈ s.image f, g x = ⋂ y ∈ s, g (f y) :=\n  iInf_finset_image\n\n"}
{"name":"Finset.set_biUnion_insert_update","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : DecidableEq α\nx : α\nt : Finset α\nf : α → Set β\ns : Set β\nhx : Not (Membership.mem t x)\n⊢ Eq (Set.iUnion fun i => Set.iUnion fun h => Function.update f x s i) (Union.union s (Set.iUnion fun i => Set.iUnion fun h => f i))","decl":"theorem set_biUnion_insert_update {x : α} {t : Finset α} (f : α → Set β) {s : Set β} (hx : x ∉ t) :\n    ⋃ i ∈ insert x t, @update _ _ _ f x s i = s ∪ ⋃ i ∈ t, f i :=\n  iSup_insert_update f hx\n\n"}
{"name":"Finset.set_biInter_insert_update","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : DecidableEq α\nx : α\nt : Finset α\nf : α → Set β\ns : Set β\nhx : Not (Membership.mem t x)\n⊢ Eq (Set.iInter fun i => Set.iInter fun h => Function.update f x s i) (Inter.inter s (Set.iInter fun i => Set.iInter fun h => f i))","decl":"theorem set_biInter_insert_update {x : α} {t : Finset α} (f : α → Set β) {s : Set β} (hx : x ∉ t) :\n    ⋂ i ∈ insert x t, @update _ _ _ f x s i = s ∩ ⋂ i ∈ t, f i :=\n  iInf_insert_update f hx\n\n"}
{"name":"Finset.set_biUnion_biUnion","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝ : DecidableEq α\ns : Finset γ\nt : γ → Finset α\nf : α → Set β\n⊢ Eq (Set.iUnion fun y => Set.iUnion fun h => f y) (Set.iUnion fun x => Set.iUnion fun h => Set.iUnion fun y => Set.iUnion fun h => f y)","decl":"theorem set_biUnion_biUnion (s : Finset γ) (t : γ → Finset α) (f : α → Set β) :\n    ⋃ y ∈ s.biUnion t, f y = ⋃ (x ∈ s) (y ∈ t x), f y :=\n  iSup_biUnion s t f\n\n"}
{"name":"Finset.set_biInter_biUnion","module":"Mathlib.Order.CompleteLattice.Finset","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝ : DecidableEq α\ns : Finset γ\nt : γ → Finset α\nf : α → Set β\n⊢ Eq (Set.iInter fun y => Set.iInter fun h => f y) (Set.iInter fun x => Set.iInter fun h => Set.iInter fun y => Set.iInter fun h => f y)","decl":"theorem set_biInter_biUnion (s : Finset γ) (t : γ → Finset α) (f : α → Set β) :\n    ⋂ y ∈ s.biUnion t, f y = ⋂ (x ∈ s) (y ∈ t x), f y :=\n  iInf_biUnion s t f\n\n"}
