{"name":"Basis.flag_zero","module":"Mathlib.LinearAlgebra.Basis.Flag","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nn : Nat\nb : Basis (Fin n) R M\n⊢ Eq (b.flag 0) Bot.bot","decl":"@[simp]\ntheorem flag_zero (b : Basis (Fin n) R M) : b.flag 0 = ⊥ := by simp [flag]\n\n"}
{"name":"Basis.flag_last","module":"Mathlib.LinearAlgebra.Basis.Flag","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nn : Nat\nb : Basis (Fin n) R M\n⊢ Eq (b.flag (Fin.last n)) Top.top","decl":"@[simp]\ntheorem flag_last (b : Basis (Fin n) R M) : b.flag (.last n) = ⊤ := by\n  simp [flag, Fin.castSucc_lt_last]\n\n"}
{"name":"Basis.flag_le_iff","module":"Mathlib.LinearAlgebra.Basis.Flag","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nn : Nat\nb : Basis (Fin n) R M\nk : Fin (HAdd.hAdd n 1)\np : Submodule R M\n⊢ Iff (LE.le (b.flag k) p) (∀ (i : Fin n), LT.lt i.castSucc k → Membership.mem p (b i))","decl":"theorem flag_le_iff (b : Basis (Fin n) R M) {k p} :\n    b.flag k ≤ p ↔ ∀ i : Fin n, i.castSucc < k → b i ∈ p :=\n  span_le.trans forall_mem_image\n\n"}
{"name":"Basis.flag_succ","module":"Mathlib.LinearAlgebra.Basis.Flag","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nn : Nat\nb : Basis (Fin n) R M\nk : Fin n\n⊢ Eq (b.flag k.succ) (Max.max (Submodule.span R (Singleton.singleton (b k))) (b.flag k.castSucc))","decl":"theorem flag_succ (b : Basis (Fin n) R M) (k : Fin n) :\n    b.flag k.succ = (R ∙ b k) ⊔ b.flag k.castSucc := by\n  simp only [flag, Fin.castSucc_lt_castSucc_iff]\n  simp [Fin.castSucc_lt_iff_succ_le, le_iff_eq_or_lt, setOf_or, image_insert_eq, span_insert]\n\n"}
{"name":"Basis.self_mem_flag","module":"Mathlib.LinearAlgebra.Basis.Flag","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nn : Nat\nb : Basis (Fin n) R M\ni : Fin n\nk : Fin (HAdd.hAdd n 1)\nh : LT.lt i.castSucc k\n⊢ Membership.mem (b.flag k) (b i)","decl":"theorem self_mem_flag (b : Basis (Fin n) R M) {i : Fin n} {k : Fin (n + 1)} (h : i.castSucc < k) :\n    b i ∈ b.flag k :=\n  subset_span <| mem_image_of_mem _ h\n\n"}
{"name":"Basis.self_mem_flag_iff","module":"Mathlib.LinearAlgebra.Basis.Flag","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nn : Nat\ninst✝ : Nontrivial R\nb : Basis (Fin n) R M\ni : Fin n\nk : Fin (HAdd.hAdd n 1)\n⊢ Iff (Membership.mem (b.flag k) (b i)) (LT.lt i.castSucc k)","decl":"@[simp]\ntheorem self_mem_flag_iff [Nontrivial R] (b : Basis (Fin n) R M) {i : Fin n} {k : Fin (n + 1)} :\n    b i ∈ b.flag k ↔ i.castSucc < k :=\n  b.self_mem_span_image\n\n"}
{"name":"Basis.flag_mono","module":"Mathlib.LinearAlgebra.Basis.Flag","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nn : Nat\nb : Basis (Fin n) R M\n⊢ Monotone b.flag","decl":"@[mono]\ntheorem flag_mono (b : Basis (Fin n) R M) : Monotone b.flag :=\n  Fin.monotone_iff_le_succ.2 fun k ↦ by rw [flag_succ]; exact le_sup_right\n\n"}
{"name":"Basis.isChain_range_flag","module":"Mathlib.LinearAlgebra.Basis.Flag","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nn : Nat\nb : Basis (Fin n) R M\n⊢ IsChain (fun x1 x2 => LE.le x1 x2) (Set.range b.flag)","decl":"theorem isChain_range_flag (b : Basis (Fin n) R M) : IsChain (· ≤ ·) (range b.flag) :=\n  b.flag_mono.isChain_range\n\n"}
{"name":"Basis.flag_strictMono","module":"Mathlib.LinearAlgebra.Basis.Flag","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nn : Nat\ninst✝ : Nontrivial R\nb : Basis (Fin n) R M\n⊢ StrictMono b.flag","decl":"@[mono]\ntheorem flag_strictMono [Nontrivial R] (b : Basis (Fin n) R M) : StrictMono b.flag :=\n  Fin.strictMono_iff_lt_succ.2 fun _ ↦ by simp [flag_succ]\n\n"}
{"name":"Basis.flag_le_flag","module":"Mathlib.LinearAlgebra.Basis.Flag","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nn : Nat\nb : Basis (Fin n) R M\ni j : Fin (HAdd.hAdd n 1)\nhij : LE.le i j\n⊢ LE.le (b.flag i) (b.flag j)","decl":"@[gcongr] lemma flag_le_flag (hij : i ≤ j) : b.flag i ≤ b.flag j := flag_mono _ hij\n\n"}
{"name":"Basis.flag_lt_flag","module":"Mathlib.LinearAlgebra.Basis.Flag","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nn : Nat\nb : Basis (Fin n) R M\ni j : Fin (HAdd.hAdd n 1)\ninst✝ : Nontrivial R\nhij : LT.lt i j\n⊢ LT.lt (b.flag i) (b.flag j)","decl":"@[gcongr]\nlemma flag_lt_flag [Nontrivial R] (hij : i < j) : b.flag i < b.flag j := flag_strictMono _ hij\n\n"}
{"name":"Basis.flag_le_ker_coord_iff","module":"Mathlib.LinearAlgebra.Basis.Flag","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nn : Nat\ninst✝ : Nontrivial R\nb : Basis (Fin n) R M\nk : Fin (HAdd.hAdd n 1)\nl : Fin n\n⊢ Iff (LE.le (b.flag k) (LinearMap.ker (b.coord l))) (LE.le k l.castSucc)","decl":"@[simp]\ntheorem flag_le_ker_coord_iff [Nontrivial R] (b : Basis (Fin n) R M) {k : Fin (n + 1)} {l : Fin n} :\n    b.flag k ≤ LinearMap.ker (b.coord l) ↔ k ≤ l.castSucc := by\n  simp [flag_le_iff, Finsupp.single_apply_eq_zero, imp_false, imp_not_comm]\n\n"}
{"name":"Basis.flag_le_ker_coord","module":"Mathlib.LinearAlgebra.Basis.Flag","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\nb : Basis (Fin n) R M\nk : Fin (HAdd.hAdd n 1)\nl : Fin n\nh : LE.le k l.castSucc\n⊢ LE.le (b.flag k) (LinearMap.ker (b.coord l))","decl":"theorem flag_le_ker_coord (b : Basis (Fin n) R M) {k : Fin (n + 1)} {l : Fin n}\n    (h : k ≤ l.castSucc) : b.flag k ≤ LinearMap.ker (b.coord l) := by\n  nontriviality R\n  exact b.flag_le_ker_coord_iff.2 h\n\n"}
{"name":"Basis.flag_le_ker_dual","module":"Mathlib.LinearAlgebra.Basis.Flag","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\nb : Basis (Fin n) R M\nk : Fin n\n⊢ LE.le (b.flag k.castSucc) (LinearMap.ker (b.dualBasis k))","decl":"theorem flag_le_ker_dual (b : Basis (Fin n) R M) (k : Fin n) :\n    b.flag k.castSucc ≤ LinearMap.ker (b.dualBasis k) := by\n  nontriviality R\n  rw [coe_dualBasis, b.flag_le_ker_coord_iff]\n\n"}
{"name":"Basis.flag_covBy","module":"Mathlib.LinearAlgebra.Basis.Flag","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nn : Nat\nb : Basis (Fin n) K V\ni : Fin n\n⊢ CovBy (b.flag i.castSucc) (b.flag i.succ)","decl":"theorem flag_covBy (b : Basis (Fin n) K V) (i : Fin n) :\n    b.flag i.castSucc ⋖ b.flag i.succ := by\n  rw [flag_succ]\n  apply covBy_span_singleton_sup\n  simp\n\n"}
{"name":"Basis.flag_wcovBy","module":"Mathlib.LinearAlgebra.Basis.Flag","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nn : Nat\nb : Basis (Fin n) K V\ni : Fin n\n⊢ WCovBy (b.flag i.castSucc) (b.flag i.succ)","decl":"theorem flag_wcovBy (b : Basis (Fin n) K V) (i : Fin n) :\n    b.flag i.castSucc ⩿ b.flag i.succ :=\n  (b.flag_covBy i).wcovBy\n\n"}
{"name":"Basis.toFlag_carrier","module":"Mathlib.LinearAlgebra.Basis.Flag","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nn : Nat\nb : Basis (Fin n) K V\n⊢ Eq (↑b.toFlag) (Set.range b.flag)","decl":"/-- Range of `Basis.flag` as a `Flag`. -/\n@[simps!]\ndef toFlag (b : Basis (Fin n) K V) : Flag (Submodule K V) :=\n  .rangeFin b.flag b.flag_zero b.flag_last b.flag_wcovBy\n\n"}
{"name":"Basis.mem_toFlag","module":"Mathlib.LinearAlgebra.Basis.Flag","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nn : Nat\nb : Basis (Fin n) K V\np : Submodule K V\n⊢ Iff (Membership.mem b.toFlag p) (Exists fun k => Eq (b.flag k) p)","decl":"@[simp]\ntheorem mem_toFlag (b : Basis (Fin n) K V) {p : Submodule K V} : p ∈ b.toFlag ↔ ∃ k, b.flag k = p :=\n  Iff.rfl\n\n"}
{"name":"Basis.isMaxChain_range_flag","module":"Mathlib.LinearAlgebra.Basis.Flag","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nn : Nat\nb : Basis (Fin n) K V\n⊢ IsMaxChain (fun x1 x2 => LE.le x1 x2) (Set.range b.flag)","decl":"theorem isMaxChain_range_flag (b : Basis (Fin n) K V) : IsMaxChain (· ≤ ·) (range b.flag) :=\n  b.toFlag.maxChain\n\n"}
