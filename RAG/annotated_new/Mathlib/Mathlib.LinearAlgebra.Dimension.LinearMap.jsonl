{"name":"LinearMap.rank_le_range","module":"Mathlib.LinearAlgebra.Dimension.LinearMap","initialProofState":"K : Type u\nV : Type v\nV' : Type v'\ninst✝⁴ : Ring K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\ninst✝¹ : AddCommGroup V'\ninst✝ : Module K V'\nf : LinearMap (RingHom.id K) V V'\n⊢ LE.le f.rank (Module.rank K V')","decl":"theorem rank_le_range (f : V →ₗ[K] V') : rank f ≤ Module.rank K V' :=\n  Submodule.rank_le _\n\n"}
{"name":"LinearMap.rank_le_domain","module":"Mathlib.LinearAlgebra.Dimension.LinearMap","initialProofState":"K : Type u\nV V₁ : Type v\ninst✝⁴ : Ring K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\ninst✝¹ : AddCommGroup V₁\ninst✝ : Module K V₁\nf : LinearMap (RingHom.id K) V V₁\n⊢ LE.le f.rank (Module.rank K V)","decl":"theorem rank_le_domain (f : V →ₗ[K] V₁) : rank f ≤ Module.rank K V :=\n  rank_range_le _\n\n"}
{"name":"LinearMap.rank_zero","module":"Mathlib.LinearAlgebra.Dimension.LinearMap","initialProofState":"K : Type u\nV : Type v\nV' : Type v'\ninst✝⁵ : Ring K\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module K V\ninst✝² : AddCommGroup V'\ninst✝¹ : Module K V'\ninst✝ : Nontrivial K\n⊢ Eq (LinearMap.rank 0) 0","decl":"@[simp]\ntheorem rank_zero [Nontrivial K] : rank (0 : V →ₗ[K] V') = 0 := by\n  rw [rank, LinearMap.range_zero, rank_bot]\n\n"}
{"name":"LinearMap.rank_comp_le_left","module":"Mathlib.LinearAlgebra.Dimension.LinearMap","initialProofState":"K : Type u\nV : Type v\nV' : Type v'\nV'' : Type v''\ninst✝⁶ : Ring K\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : Module K V\ninst✝³ : AddCommGroup V'\ninst✝² : Module K V'\ninst✝¹ : AddCommGroup V''\ninst✝ : Module K V''\ng : LinearMap (RingHom.id K) V V'\nf : LinearMap (RingHom.id K) V' V''\n⊢ LE.le (f.comp g).rank f.rank","decl":"theorem rank_comp_le_left (g : V →ₗ[K] V') (f : V' →ₗ[K] V'') : rank (f.comp g) ≤ rank f := by\n  refine Submodule.rank_mono ?_\n  rw [LinearMap.range_comp]\n  exact LinearMap.map_le_range\n\n"}
{"name":"LinearMap.lift_rank_comp_le_right","module":"Mathlib.LinearAlgebra.Dimension.LinearMap","initialProofState":"K : Type u\nV : Type v\nV' : Type v'\nV'' : Type v''\ninst✝⁶ : Ring K\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : Module K V\ninst✝³ : AddCommGroup V'\ninst✝² : Module K V'\ninst✝¹ : AddCommGroup V''\ninst✝ : Module K V''\ng : LinearMap (RingHom.id K) V V'\nf : LinearMap (RingHom.id K) V' V''\n⊢ LE.le (Cardinal.lift.{v', v''} (f.comp g).rank) (Cardinal.lift.{v'', v'} g.rank)","decl":"theorem lift_rank_comp_le_right (g : V →ₗ[K] V') (f : V' →ₗ[K] V'') :\n    Cardinal.lift.{v'} (rank (f.comp g)) ≤ Cardinal.lift.{v''} (rank g) := by\n  rw [rank, rank, LinearMap.range_comp]; exact lift_rank_map_le _ _\n\n"}
{"name":"LinearMap.lift_rank_comp_le","module":"Mathlib.LinearAlgebra.Dimension.LinearMap","initialProofState":"K : Type u\nV : Type v\nV' : Type v'\nV'' : Type v''\ninst✝⁶ : Ring K\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : Module K V\ninst✝³ : AddCommGroup V'\ninst✝² : Module K V'\ninst✝¹ : AddCommGroup V''\ninst✝ : Module K V''\ng : LinearMap (RingHom.id K) V V'\nf : LinearMap (RingHom.id K) V' V''\n⊢ LE.le (Cardinal.lift.{v', v''} (f.comp g).rank) (Min.min (Cardinal.lift.{v', v''} f.rank) (Cardinal.lift.{v'', v'} g.rank))","decl":"/-- The rank of the composition of two maps is less than the minimum of their ranks. -/\ntheorem lift_rank_comp_le (g : V →ₗ[K] V') (f : V' →ₗ[K] V'') :\n    Cardinal.lift.{v'} (rank (f.comp g)) ≤\n      min (Cardinal.lift.{v'} (rank f)) (Cardinal.lift.{v''} (rank g)) :=\n  le_min (Cardinal.lift_le.mpr <| rank_comp_le_left _ _) (lift_rank_comp_le_right _ _)\n\n"}
{"name":"LinearMap.rank_comp_le_right","module":"Mathlib.LinearAlgebra.Dimension.LinearMap","initialProofState":"K : Type u\nV : Type v\nV' V'₁ : Type v'\ninst✝⁶ : Ring K\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : Module K V\ninst✝³ : AddCommGroup V'\ninst✝² : Module K V'\ninst✝¹ : AddCommGroup V'₁\ninst✝ : Module K V'₁\ng : LinearMap (RingHom.id K) V V'\nf : LinearMap (RingHom.id K) V' V'₁\n⊢ LE.le (f.comp g).rank g.rank","decl":"theorem rank_comp_le_right (g : V →ₗ[K] V') (f : V' →ₗ[K] V'₁) : rank (f.comp g) ≤ rank g := by\n  simpa only [Cardinal.lift_id] using lift_rank_comp_le_right g f\n\n"}
{"name":"LinearMap.rank_comp_le","module":"Mathlib.LinearAlgebra.Dimension.LinearMap","initialProofState":"K : Type u\nV : Type v\nV' V'₁ : Type v'\ninst✝⁶ : Ring K\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : Module K V\ninst✝³ : AddCommGroup V'\ninst✝² : Module K V'\ninst✝¹ : AddCommGroup V'₁\ninst✝ : Module K V'₁\ng : LinearMap (RingHom.id K) V V'\nf : LinearMap (RingHom.id K) V' V'₁\n⊢ LE.le (f.comp g).rank (Min.min f.rank g.rank)","decl":"/-- The rank of the composition of two maps is less than the minimum of their ranks.\n\nSee `lift_rank_comp_le` for the universe-polymorphic version. -/\ntheorem rank_comp_le (g : V →ₗ[K] V') (f : V' →ₗ[K] V'₁) :\n    rank (f.comp g) ≤ min (rank f) (rank g) := by\n  simpa only [Cardinal.lift_id] using lift_rank_comp_le g f\n\n"}
{"name":"LinearMap.rank_add_le","module":"Mathlib.LinearAlgebra.Dimension.LinearMap","initialProofState":"K : Type u\nV : Type v\nV' : Type v'\ninst✝⁴ : DivisionRing K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\ninst✝¹ : AddCommGroup V'\ninst✝ : Module K V'\nf g : LinearMap (RingHom.id K) V V'\n⊢ LE.le (HAdd.hAdd f g).rank (HAdd.hAdd f.rank g.rank)","decl":"theorem rank_add_le (f g : V →ₗ[K] V') : rank (f + g) ≤ rank f + rank g :=\n  calc\n    rank (f + g) ≤ Module.rank K (LinearMap.range f ⊔ LinearMap.range g : Submodule K V') := by\n      refine Submodule.rank_mono ?_\n      exact LinearMap.range_le_iff_comap.2 <| eq_top_iff'.2 fun x =>\n        show f x + g x ∈ (LinearMap.range f ⊔ LinearMap.range g : Submodule K V') from\n        mem_sup.2 ⟨_, ⟨x, rfl⟩, _, ⟨x, rfl⟩, rfl⟩\n    _ ≤ rank f + rank g := Submodule.rank_add_le_rank_add_rank _ _\n\n"}
{"name":"LinearMap.rank_finset_sum_le","module":"Mathlib.LinearAlgebra.Dimension.LinearMap","initialProofState":"K : Type u\nV : Type v\nV' : Type v'\ninst✝⁴ : DivisionRing K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\ninst✝¹ : AddCommGroup V'\ninst✝ : Module K V'\nη : Type u_1\ns : Finset η\nf : η → LinearMap (RingHom.id K) V V'\n⊢ LE.le (s.sum fun d => f d).rank (s.sum fun d => (f d).rank)","decl":"theorem rank_finset_sum_le {η} (s : Finset η) (f : η → V →ₗ[K] V') :\n    rank (∑ d ∈ s, f d) ≤ ∑ d ∈ s, rank (f d) :=\n  @Finset.sum_hom_rel _ _ _ _ _ (fun a b => rank a ≤ b) f (fun d => rank (f d)) s\n    (le_of_eq rank_zero) fun _ _ _ h => le_trans (rank_add_le _ _) (add_le_add_left h _)\n\n"}
{"name":"LinearMap.le_rank_iff_exists_linearIndependent","module":"Mathlib.LinearAlgebra.Dimension.LinearMap","initialProofState":"K : Type u\nV : Type v\nV' : Type v'\ninst✝⁴ : DivisionRing K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\ninst✝¹ : AddCommGroup V'\ninst✝ : Module K V'\nc : Cardinal.{v'}\nf : LinearMap (RingHom.id K) V V'\n⊢ Iff (LE.le c f.rank) (Exists fun s => And (Eq (Cardinal.lift.{v', v} (Cardinal.mk ↑s)) (Cardinal.lift.{v, v'} c)) (LinearIndependent K fun x => f ↑x))","decl":"theorem le_rank_iff_exists_linearIndependent {c : Cardinal} {f : V →ₗ[K] V'} :\n    c ≤ rank f ↔ ∃ s : Set V,\n    Cardinal.lift.{v'} #s = Cardinal.lift.{v} c ∧ LinearIndependent K (fun x : s => f x) := by\n  rcases f.rangeRestrict.exists_rightInverse_of_surjective f.range_rangeRestrict with ⟨g, hg⟩\n  have fg : LeftInverse f.rangeRestrict g := LinearMap.congr_fun hg\n  refine ⟨fun h => ?_, ?_⟩\n  · rcases _root_.le_rank_iff_exists_linearIndependent.1 h with ⟨s, rfl, si⟩\n    refine ⟨g '' s, Cardinal.mk_image_eq_lift _ _ fg.injective, ?_⟩\n    replace fg : ∀ x, f (g x) = x := by\n      intro x\n      convert congr_arg Subtype.val (fg x)\n    replace si : LinearIndependent K fun x : s => f (g x) := by\n      simpa only [fg] using si.map' _ (ker_subtype _)\n    exact si.image_of_comp s g f\n  · rintro ⟨s, hsc, si⟩\n    have : LinearIndependent K fun x : s => f.rangeRestrict x :=\n      LinearIndependent.of_comp f.range.subtype (by convert si)\n    convert this.image.cardinal_le_rank\n    rw [← Cardinal.lift_inj, ← hsc, Cardinal.mk_image_eq_of_injOn_lift]\n    exact injOn_iff_injective.2 this.injective\n\n"}
{"name":"LinearMap.le_rank_iff_exists_linearIndependent_finset","module":"Mathlib.LinearAlgebra.Dimension.LinearMap","initialProofState":"K : Type u\nV : Type v\nV' : Type v'\ninst✝⁴ : DivisionRing K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\ninst✝¹ : AddCommGroup V'\ninst✝ : Module K V'\nn : Nat\nf : LinearMap (RingHom.id K) V V'\n⊢ Iff (LE.le (↑n) f.rank) (Exists fun s => And (Eq s.card n) (LinearIndependent K fun x => f ↑x))","decl":"theorem le_rank_iff_exists_linearIndependent_finset {n : ℕ} {f : V →ₗ[K] V'} :\n    ↑n ≤ rank f ↔ ∃ s : Finset V, s.card = n ∧ LinearIndependent K fun x : (s : Set V) => f x := by\n  simp only [le_rank_iff_exists_linearIndependent, Cardinal.lift_natCast, Cardinal.lift_eq_nat_iff,\n    Cardinal.mk_set_eq_nat_iff_finset]\n  constructor\n  · rintro ⟨s, ⟨t, rfl, rfl⟩, si⟩\n    exact ⟨t, rfl, si⟩\n  · rintro ⟨s, rfl, si⟩\n    exact ⟨s, ⟨s, rfl, rfl⟩, si⟩\n\n"}
