{"name":"hasSum_pi_single","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommMonoid α\ninst✝¹ : TopologicalSpace α\ninst✝ : DecidableEq β\nb : β\na : α\n⊢ HasSum (Pi.single b a) a","decl":"@[to_additive]\ntheorem hasProd_pi_single [DecidableEq β] (b : β) (a : α) : HasProd (Pi.mulSingle b a) a := by\n  convert hasProd_ite_eq b a\n  simp [Pi.mulSingle_apply]\n\n"}
{"name":"hasProd_pi_single","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommMonoid α\ninst✝¹ : TopologicalSpace α\ninst✝ : DecidableEq β\nb : β\na : α\n⊢ HasProd (Pi.mulSingle b a) a","decl":"@[to_additive]\ntheorem hasProd_pi_single [DecidableEq β] (b : β) (a : α) : HasProd (Pi.mulSingle b a) a := by\n  convert hasProd_ite_eq b a\n  simp [Pi.mulSingle_apply]\n\n"}
{"name":"tsum_pi_single","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommMonoid α\ninst✝¹ : TopologicalSpace α\ninst✝ : DecidableEq β\nb : β\na : α\n⊢ Eq (tsum fun b' => Pi.single b a b') a","decl":"@[to_additive (attr := simp)]\ntheorem tprod_pi_single [DecidableEq β] (b : β) (a : α) : ∏' b', Pi.mulSingle b a b' = a := by\n  rw [tprod_eq_mulSingle b]\n  · simp\n  · intro b' hb'; simp [hb']\n\n"}
{"name":"tprod_pi_single","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommMonoid α\ninst✝¹ : TopologicalSpace α\ninst✝ : DecidableEq β\nb : β\na : α\n⊢ Eq (tprod fun b' => Pi.mulSingle b a b') a","decl":"@[to_additive (attr := simp)]\ntheorem tprod_pi_single [DecidableEq β] (b : β) (a : α) : ∏' b', Pi.mulSingle b a b' = a := by\n  rw [tprod_eq_mulSingle b]\n  · simp\n  · intro b' hb'; simp [hb']\n\n"}
{"name":"tsum_setProd_singleton_left","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nb : β\nt : Set γ\nf : Prod β γ → α\n⊢ Eq (tsum fun x => f ↑x) (tsum fun c => f { fst := b, snd := ↑c })","decl":"@[to_additive tsum_setProd_singleton_left]\nlemma tprod_setProd_singleton_left (b : β) (t : Set γ) (f : β × γ → α) :\n    (∏' x : {b} ×ˢ t, f x) = ∏' c : t, f (b, c) := by\n  rw [tprod_congr_set_coe _ Set.singleton_prod, tprod_image _ (Prod.mk.inj_left b).injOn]\n\n"}
{"name":"tprod_setProd_singleton_left","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nb : β\nt : Set γ\nf : Prod β γ → α\n⊢ Eq (tprod fun x => f ↑x) (tprod fun c => f { fst := b, snd := ↑c })","decl":"@[to_additive tsum_setProd_singleton_left]\nlemma tprod_setProd_singleton_left (b : β) (t : Set γ) (f : β × γ → α) :\n    (∏' x : {b} ×ˢ t, f x) = ∏' c : t, f (b, c) := by\n  rw [tprod_congr_set_coe _ Set.singleton_prod, tprod_image _ (Prod.mk.inj_left b).injOn]\n\n"}
{"name":"tsum_setProd_singleton_right","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\ns : Set β\nc : γ\nf : Prod β γ → α\n⊢ Eq (tsum fun x => f ↑x) (tsum fun b => f { fst := ↑b, snd := c })","decl":"@[to_additive tsum_setProd_singleton_right]\nlemma tprod_setProd_singleton_right (s : Set β) (c : γ) (f : β × γ → α) :\n    (∏' x : s ×ˢ {c}, f x) = ∏' b : s, f (b, c) := by\n  rw [tprod_congr_set_coe _ Set.prod_singleton, tprod_image _ (Prod.mk.inj_right c).injOn]\n\n"}
{"name":"tprod_setProd_singleton_right","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\ns : Set β\nc : γ\nf : Prod β γ → α\n⊢ Eq (tprod fun x => f ↑x) (tprod fun b => f { fst := ↑b, snd := c })","decl":"@[to_additive tsum_setProd_singleton_right]\nlemma tprod_setProd_singleton_right (s : Set β) (c : γ) (f : β × γ → α) :\n    (∏' x : s ×ˢ {c}, f x) = ∏' b : s, f (b, c) := by\n  rw [tprod_congr_set_coe _ Set.prod_singleton, tprod_image _ (Prod.mk.inj_right c).injOn]\n\n"}
{"name":"Multipliable.prod_symm","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : Prod β γ → α\nhf : Multipliable f\n⊢ Multipliable fun p => f p.swap","decl":"@[to_additive Summable.prod_symm]\ntheorem Multipliable.prod_symm {f : β × γ → α} (hf : Multipliable f) :\n    Multipliable fun p : γ × β ↦ f p.swap :=\n  (Equiv.prodComm γ β).multipliable_iff.2 hf\n\n"}
{"name":"Summable.prod_symm","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : Prod β γ → α\nhf : Summable f\n⊢ Summable fun p => f p.swap","decl":"@[to_additive Summable.prod_symm]\ntheorem Multipliable.prod_symm {f : β × γ → α} (hf : Multipliable f) :\n    Multipliable fun p : γ × β ↦ f p.swap :=\n  (Equiv.prodComm γ β).multipliable_iff.2 hf\n\n"}
{"name":"HasProd.prod_mk","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : CommMonoid α\ninst✝² : TopologicalSpace α\ninst✝¹ : CommMonoid γ\ninst✝ : TopologicalSpace γ\nf : β → α\ng : β → γ\na : α\nb : γ\nhf : HasProd f a\nhg : HasProd g b\n⊢ HasProd (fun x => { fst := f x, snd := g x }) { fst := a, snd := b }","decl":"@[to_additive HasSum.prod_mk]\ntheorem HasProd.prod_mk {f : β → α} {g : β → γ} {a : α} {b : γ}\n    (hf : HasProd f a) (hg : HasProd g b) : HasProd (fun x ↦ (⟨f x, g x⟩ : α × γ)) ⟨a, b⟩ := by\n  simp [HasProd, ← prod_mk_prod, Filter.Tendsto.prod_mk_nhds hf hg]\n\n"}
{"name":"HasSum.prod_mk","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : AddCommMonoid α\ninst✝² : TopologicalSpace α\ninst✝¹ : AddCommMonoid γ\ninst✝ : TopologicalSpace γ\nf : β → α\ng : β → γ\na : α\nb : γ\nhf : HasSum f a\nhg : HasSum g b\n⊢ HasSum (fun x => { fst := f x, snd := g x }) { fst := a, snd := b }","decl":"@[to_additive HasSum.prod_mk]\ntheorem HasProd.prod_mk {f : β → α} {g : β → γ} {a : α} {b : γ}\n    (hf : HasProd f a) (hg : HasProd g b) : HasProd (fun x ↦ (⟨f x, g x⟩ : α × γ)) ⟨a, b⟩ := by\n  simp [HasProd, ← prod_mk_prod, Filter.Tendsto.prod_mk_nhds hf hg]\n\n"}
{"name":"HasSum.sigma","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : AddCommMonoid α\ninst✝² : TopologicalSpace α\ninst✝¹ : ContinuousAdd α\ninst✝ : RegularSpace α\nγ : β → Type u_4\nf : (Sigma fun b => γ b) → α\ng : β → α\na : α\nha : HasSum f a\nhf : ∀ (b : β), HasSum (fun c => f ⟨b, c⟩) (g b)\n⊢ HasSum g a","decl":"@[to_additive]\ntheorem HasProd.sigma {γ : β → Type*} {f : (Σ b : β, γ b) → α} {g : β → α} {a : α}\n    (ha : HasProd f a) (hf : ∀ b, HasProd (fun c ↦ f ⟨b, c⟩) (g b)) : HasProd g a := by\n  classical\n  refine (atTop_basis.tendsto_iff (closed_nhds_basis a)).mpr ?_\n  rintro s ⟨hs, hsc⟩\n  rcases mem_atTop_sets.mp (ha hs) with ⟨u, hu⟩\n  use u.image Sigma.fst, trivial\n  intro bs hbs\n  simp only [Set.mem_preimage, Finset.le_iff_subset] at hu\n  have : Tendsto (fun t : Finset (Σb, γ b) ↦ ∏ p ∈ t with p.1 ∈ bs, f p) atTop\n      (𝓝 <| ∏ b ∈ bs, g b) := by\n    simp only [← sigma_preimage_mk, prod_sigma]\n    refine tendsto_finset_prod _ fun b _ ↦ ?_\n    change\n      Tendsto (fun t ↦ (fun t ↦ ∏ s ∈ t, f ⟨b, s⟩) (preimage t (Sigma.mk b) _)) atTop (𝓝 (g b))\n    exact (hf b).comp (tendsto_finset_preimage_atTop_atTop (sigma_mk_injective))\n  refine hsc.mem_of_tendsto this (eventually_atTop.2 ⟨u, fun t ht ↦ hu _ fun x hx ↦ ?_⟩)\n  exact mem_filter.2 ⟨ht hx, hbs <| mem_image_of_mem _ hx⟩\n\n"}
{"name":"HasProd.sigma","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : CommMonoid α\ninst✝² : TopologicalSpace α\ninst✝¹ : ContinuousMul α\ninst✝ : RegularSpace α\nγ : β → Type u_4\nf : (Sigma fun b => γ b) → α\ng : β → α\na : α\nha : HasProd f a\nhf : ∀ (b : β), HasProd (fun c => f ⟨b, c⟩) (g b)\n⊢ HasProd g a","decl":"@[to_additive]\ntheorem HasProd.sigma {γ : β → Type*} {f : (Σ b : β, γ b) → α} {g : β → α} {a : α}\n    (ha : HasProd f a) (hf : ∀ b, HasProd (fun c ↦ f ⟨b, c⟩) (g b)) : HasProd g a := by\n  classical\n  refine (atTop_basis.tendsto_iff (closed_nhds_basis a)).mpr ?_\n  rintro s ⟨hs, hsc⟩\n  rcases mem_atTop_sets.mp (ha hs) with ⟨u, hu⟩\n  use u.image Sigma.fst, trivial\n  intro bs hbs\n  simp only [Set.mem_preimage, Finset.le_iff_subset] at hu\n  have : Tendsto (fun t : Finset (Σb, γ b) ↦ ∏ p ∈ t with p.1 ∈ bs, f p) atTop\n      (𝓝 <| ∏ b ∈ bs, g b) := by\n    simp only [← sigma_preimage_mk, prod_sigma]\n    refine tendsto_finset_prod _ fun b _ ↦ ?_\n    change\n      Tendsto (fun t ↦ (fun t ↦ ∏ s ∈ t, f ⟨b, s⟩) (preimage t (Sigma.mk b) _)) atTop (𝓝 (g b))\n    exact (hf b).comp (tendsto_finset_preimage_atTop_atTop (sigma_mk_injective))\n  refine hsc.mem_of_tendsto this (eventually_atTop.2 ⟨u, fun t ht ↦ hu _ fun x hx ↦ ?_⟩)\n  exact mem_filter.2 ⟨ht hx, hbs <| mem_image_of_mem _ hx⟩\n\n"}
{"name":"HasProd.prod_fiberwise","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : CommMonoid α\ninst✝² : TopologicalSpace α\ninst✝¹ : ContinuousMul α\ninst✝ : RegularSpace α\nf : Prod β γ → α\ng : β → α\na : α\nha : HasProd f a\nhf : ∀ (b : β), HasProd (fun c => f { fst := b, snd := c }) (g b)\n⊢ HasProd g a","decl":"/-- If a function `f` on `β × γ` has product `a` and for each `b` the restriction of `f` to\n`{b} × γ` has product `g b`, then the function `g` has product `a`. -/\n@[to_additive HasSum.prod_fiberwise \"If a series `f` on `β × γ` has sum `a` and for each `b` the\nrestriction of `f` to `{b} × γ` has sum `g b`, then the series `g` has sum `a`.\"]\ntheorem HasProd.prod_fiberwise {f : β × γ → α} {g : β → α} {a : α} (ha : HasProd f a)\n    (hf : ∀ b, HasProd (fun c ↦ f (b, c)) (g b)) : HasProd g a :=\n  HasProd.sigma ((Equiv.sigmaEquivProd β γ).hasProd_iff.2 ha) hf\n\n"}
{"name":"HasSum.prod_fiberwise","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : AddCommMonoid α\ninst✝² : TopologicalSpace α\ninst✝¹ : ContinuousAdd α\ninst✝ : RegularSpace α\nf : Prod β γ → α\ng : β → α\na : α\nha : HasSum f a\nhf : ∀ (b : β), HasSum (fun c => f { fst := b, snd := c }) (g b)\n⊢ HasSum g a","decl":"/-- If a function `f` on `β × γ` has product `a` and for each `b` the restriction of `f` to\n`{b} × γ` has product `g b`, then the function `g` has product `a`. -/\n@[to_additive HasSum.prod_fiberwise \"If a series `f` on `β × γ` has sum `a` and for each `b` the\nrestriction of `f` to `{b} × γ` has sum `g b`, then the series `g` has sum `a`.\"]\ntheorem HasProd.prod_fiberwise {f : β × γ → α} {g : β → α} {a : α} (ha : HasProd f a)\n    (hf : ∀ b, HasProd (fun c ↦ f (b, c)) (g b)) : HasProd g a :=\n  HasProd.sigma ((Equiv.sigmaEquivProd β γ).hasProd_iff.2 ha) hf\n\n"}
{"name":"Multipliable.sigma'","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : CommMonoid α\ninst✝² : TopologicalSpace α\ninst✝¹ : ContinuousMul α\ninst✝ : RegularSpace α\nγ : β → Type u_4\nf : (Sigma fun b => γ b) → α\nha : Multipliable f\nhf : ∀ (b : β), Multipliable fun c => f ⟨b, c⟩\n⊢ Multipliable fun b => tprod fun c => f ⟨b, c⟩","decl":"@[to_additive]\ntheorem Multipliable.sigma' {γ : β → Type*} {f : (Σb : β, γ b) → α} (ha : Multipliable f)\n    (hf : ∀ b, Multipliable fun c ↦ f ⟨b, c⟩) : Multipliable fun b ↦ ∏' c, f ⟨b, c⟩ :=\n  (ha.hasProd.sigma fun b ↦ (hf b).hasProd).multipliable\n\n"}
{"name":"Summable.sigma'","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : AddCommMonoid α\ninst✝² : TopologicalSpace α\ninst✝¹ : ContinuousAdd α\ninst✝ : RegularSpace α\nγ : β → Type u_4\nf : (Sigma fun b => γ b) → α\nha : Summable f\nhf : ∀ (b : β), Summable fun c => f ⟨b, c⟩\n⊢ Summable fun b => tsum fun c => f ⟨b, c⟩","decl":"@[to_additive]\ntheorem Multipliable.sigma' {γ : β → Type*} {f : (Σb : β, γ b) → α} (ha : Multipliable f)\n    (hf : ∀ b, Multipliable fun c ↦ f ⟨b, c⟩) : Multipliable fun b ↦ ∏' c, f ⟨b, c⟩ :=\n  (ha.hasProd.sigma fun b ↦ (hf b).hasProd).multipliable\n\n"}
{"name":"HasProd.sigma_of_hasProd","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : CommMonoid α\ninst✝² : TopologicalSpace α\ninst✝¹ : ContinuousMul α\ninst✝ : T3Space α\nγ : β → Type u_4\nf : (Sigma fun b => γ b) → α\ng : β → α\na : α\nha : HasProd g a\nhf : ∀ (b : β), HasProd (fun c => f ⟨b, c⟩) (g b)\nhf' : Multipliable f\n⊢ HasProd f a","decl":"@[to_additive]\ntheorem HasProd.sigma_of_hasProd {γ : β → Type*} {f : (Σb : β, γ b) → α} {g : β → α}\n    {a : α} (ha : HasProd g a) (hf : ∀ b, HasProd (fun c ↦ f ⟨b, c⟩) (g b)) (hf' : Multipliable f) :\n    HasProd f a := by simpa [(hf'.hasProd.sigma hf).unique ha] using hf'.hasProd\n\n"}
{"name":"HasSum.sigma_of_hasSum","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : AddCommMonoid α\ninst✝² : TopologicalSpace α\ninst✝¹ : ContinuousAdd α\ninst✝ : T3Space α\nγ : β → Type u_4\nf : (Sigma fun b => γ b) → α\ng : β → α\na : α\nha : HasSum g a\nhf : ∀ (b : β), HasSum (fun c => f ⟨b, c⟩) (g b)\nhf' : Summable f\n⊢ HasSum f a","decl":"@[to_additive]\ntheorem HasProd.sigma_of_hasProd {γ : β → Type*} {f : (Σb : β, γ b) → α} {g : β → α}\n    {a : α} (ha : HasProd g a) (hf : ∀ b, HasProd (fun c ↦ f ⟨b, c⟩) (g b)) (hf' : Multipliable f) :\n    HasProd f a := by simpa [(hf'.hasProd.sigma hf).unique ha] using hf'.hasProd\n\n"}
{"name":"tprod_sigma'","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : CommMonoid α\ninst✝² : TopologicalSpace α\ninst✝¹ : ContinuousMul α\ninst✝ : T3Space α\nγ : β → Type u_4\nf : (Sigma fun b => γ b) → α\nh₁ : ∀ (b : β), Multipliable fun c => f ⟨b, c⟩\nh₂ : Multipliable f\n⊢ Eq (tprod fun p => f p) (tprod fun b => tprod fun c => f ⟨b, c⟩)","decl":"@[to_additive]\ntheorem tprod_sigma' {γ : β → Type*} {f : (Σb : β, γ b) → α}\n    (h₁ : ∀ b, Multipliable fun c ↦ f ⟨b, c⟩) (h₂ : Multipliable f) :\n    ∏' p, f p = ∏' (b) (c), f ⟨b, c⟩ :=\n  (h₂.hasProd.sigma fun b ↦ (h₁ b).hasProd).tprod_eq.symm\n\n"}
{"name":"tsum_sigma'","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : AddCommMonoid α\ninst✝² : TopologicalSpace α\ninst✝¹ : ContinuousAdd α\ninst✝ : T3Space α\nγ : β → Type u_4\nf : (Sigma fun b => γ b) → α\nh₁ : ∀ (b : β), Summable fun c => f ⟨b, c⟩\nh₂ : Summable f\n⊢ Eq (tsum fun p => f p) (tsum fun b => tsum fun c => f ⟨b, c⟩)","decl":"@[to_additive]\ntheorem tprod_sigma' {γ : β → Type*} {f : (Σb : β, γ b) → α}\n    (h₁ : ∀ b, Multipliable fun c ↦ f ⟨b, c⟩) (h₂ : Multipliable f) :\n    ∏' p, f p = ∏' (b) (c), f ⟨b, c⟩ :=\n  (h₂.hasProd.sigma fun b ↦ (h₁ b).hasProd).tprod_eq.symm\n\n"}
{"name":"tprod_prod'","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : CommMonoid α\ninst✝² : TopologicalSpace α\ninst✝¹ : ContinuousMul α\ninst✝ : T3Space α\nf : Prod β γ → α\nh : Multipliable f\nh₁ : ∀ (b : β), Multipliable fun c => f { fst := b, snd := c }\n⊢ Eq (tprod fun p => f p) (tprod fun b => tprod fun c => f { fst := b, snd := c })","decl":"@[to_additive tsum_prod']\ntheorem tprod_prod' {f : β × γ → α} (h : Multipliable f)\n    (h₁ : ∀ b, Multipliable fun c ↦ f (b, c)) :\n    ∏' p, f p = ∏' (b) (c), f (b, c) :=\n  (h.hasProd.prod_fiberwise fun b ↦ (h₁ b).hasProd).tprod_eq.symm\n\n"}
{"name":"tsum_prod'","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : AddCommMonoid α\ninst✝² : TopologicalSpace α\ninst✝¹ : ContinuousAdd α\ninst✝ : T3Space α\nf : Prod β γ → α\nh : Summable f\nh₁ : ∀ (b : β), Summable fun c => f { fst := b, snd := c }\n⊢ Eq (tsum fun p => f p) (tsum fun b => tsum fun c => f { fst := b, snd := c })","decl":"@[to_additive tsum_prod']\ntheorem tprod_prod' {f : β × γ → α} (h : Multipliable f)\n    (h₁ : ∀ b, Multipliable fun c ↦ f (b, c)) :\n    ∏' p, f p = ∏' (b) (c), f (b, c) :=\n  (h.hasProd.prod_fiberwise fun b ↦ (h₁ b).hasProd).tprod_eq.symm\n\n"}
{"name":"tprod_comm'","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : CommMonoid α\ninst✝² : TopologicalSpace α\ninst✝¹ : ContinuousMul α\ninst✝ : T3Space α\nf : β → γ → α\nh : Multipliable (Function.uncurry f)\nh₁ : ∀ (b : β), Multipliable (f b)\nh₂ : ∀ (c : γ), Multipliable fun b => f b c\n⊢ Eq (tprod fun c => tprod fun b => f b c) (tprod fun b => tprod fun c => f b c)","decl":"@[to_additive]\ntheorem tprod_comm' {f : β → γ → α} (h : Multipliable (Function.uncurry f))\n    (h₁ : ∀ b, Multipliable (f b)) (h₂ : ∀ c, Multipliable fun b ↦ f b c) :\n    ∏' (c) (b), f b c = ∏' (b) (c), f b c := by\n  erw [← tprod_prod' h h₁, ← tprod_prod' h.prod_symm h₂,\n      ← (Equiv.prodComm γ β).tprod_eq (uncurry f)]\n  rfl\n\n"}
{"name":"tsum_comm'","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : AddCommMonoid α\ninst✝² : TopologicalSpace α\ninst✝¹ : ContinuousAdd α\ninst✝ : T3Space α\nf : β → γ → α\nh : Summable (Function.uncurry f)\nh₁ : ∀ (b : β), Summable (f b)\nh₂ : ∀ (c : γ), Summable fun b => f b c\n⊢ Eq (tsum fun c => tsum fun b => f b c) (tsum fun b => tsum fun c => f b c)","decl":"@[to_additive]\ntheorem tprod_comm' {f : β → γ → α} (h : Multipliable (Function.uncurry f))\n    (h₁ : ∀ b, Multipliable (f b)) (h₂ : ∀ c, Multipliable fun b ↦ f b c) :\n    ∏' (c) (b), f b c = ∏' (b) (c), f b c := by\n  erw [← tprod_prod' h h₁, ← tprod_prod' h.prod_symm h₂,\n      ← (Equiv.prodComm γ β).tprod_eq (uncurry f)]\n  rfl\n\n"}
{"name":"HasProd.of_sigma","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommGroup α\ninst✝¹ : UniformSpace α\ninst✝ : UniformGroup α\nγ : β → Type u_4\nf : (Sigma fun b => γ b) → α\ng : β → α\na : α\nhf : ∀ (b : β), HasProd (fun c => f ⟨b, c⟩) (g b)\nhg : HasProd g a\nh : CauchySeq fun s => s.prod fun i => f i\n⊢ HasProd f a","decl":"@[to_additive]\ntheorem HasProd.of_sigma {γ : β → Type*} {f : (Σ b : β, γ b) → α} {g : β → α} {a : α}\n    (hf : ∀ b, HasProd (fun c ↦ f ⟨b, c⟩) (g b)) (hg : HasProd g a)\n    (h : CauchySeq (fun (s : Finset (Σ b : β, γ b)) ↦ ∏ i ∈ s, f i)) :\n    HasProd f a := by\n  classical\n  apply le_nhds_of_cauchy_adhp h\n  simp only [← mapClusterPt_def, mapClusterPt_iff, frequently_atTop, ge_iff_le, le_eq_subset]\n  intro u hu s\n  rcases mem_nhds_iff.1 hu with ⟨v, vu, v_open, hv⟩\n  obtain ⟨t0, st0, ht0⟩ : ∃ t0, ∏ i ∈ t0, g i ∈ v ∧ s.image Sigma.fst ⊆ t0 := by\n    have A : ∀ᶠ t0 in (atTop : Filter (Finset β)), ∏ i ∈ t0, g i ∈ v := hg (v_open.mem_nhds hv)\n    exact (A.and (Ici_mem_atTop _)).exists\n  have L : Tendsto (fun t : Finset (Σb, γ b) ↦ ∏ p ∈ t with p.1 ∈ t0, f p) atTop\n      (𝓝 <| ∏ b ∈ t0, g b) := by\n    simp only [← sigma_preimage_mk, prod_sigma]\n    refine tendsto_finset_prod _ fun b _ ↦ ?_\n    change\n      Tendsto (fun t ↦ (fun t ↦ ∏ s ∈ t, f ⟨b, s⟩) (preimage t (Sigma.mk b) _)) atTop (𝓝 (g b))\n    exact (hf b).comp (tendsto_finset_preimage_atTop_atTop (sigma_mk_injective))\n  have : ∃ t, ∏ p ∈ t with p.1 ∈ t0, f p ∈ v ∧ s ⊆ t :=\n    ((Tendsto.eventually_mem L (v_open.mem_nhds st0)).and (Ici_mem_atTop _)).exists\n  obtain ⟨t, tv, st⟩ := this\n  refine ⟨{p ∈ t | p.1 ∈ t0}, fun x hx ↦ ?_, vu tv⟩\n  simpa only [mem_filter, st hx, true_and] using ht0 (mem_image_of_mem Sigma.fst hx)\n\n"}
{"name":"HasSum.of_sigma","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommGroup α\ninst✝¹ : UniformSpace α\ninst✝ : UniformAddGroup α\nγ : β → Type u_4\nf : (Sigma fun b => γ b) → α\ng : β → α\na : α\nhf : ∀ (b : β), HasSum (fun c => f ⟨b, c⟩) (g b)\nhg : HasSum g a\nh : CauchySeq fun s => s.sum fun i => f i\n⊢ HasSum f a","decl":"@[to_additive]\ntheorem HasProd.of_sigma {γ : β → Type*} {f : (Σ b : β, γ b) → α} {g : β → α} {a : α}\n    (hf : ∀ b, HasProd (fun c ↦ f ⟨b, c⟩) (g b)) (hg : HasProd g a)\n    (h : CauchySeq (fun (s : Finset (Σ b : β, γ b)) ↦ ∏ i ∈ s, f i)) :\n    HasProd f a := by\n  classical\n  apply le_nhds_of_cauchy_adhp h\n  simp only [← mapClusterPt_def, mapClusterPt_iff, frequently_atTop, ge_iff_le, le_eq_subset]\n  intro u hu s\n  rcases mem_nhds_iff.1 hu with ⟨v, vu, v_open, hv⟩\n  obtain ⟨t0, st0, ht0⟩ : ∃ t0, ∏ i ∈ t0, g i ∈ v ∧ s.image Sigma.fst ⊆ t0 := by\n    have A : ∀ᶠ t0 in (atTop : Filter (Finset β)), ∏ i ∈ t0, g i ∈ v := hg (v_open.mem_nhds hv)\n    exact (A.and (Ici_mem_atTop _)).exists\n  have L : Tendsto (fun t : Finset (Σb, γ b) ↦ ∏ p ∈ t with p.1 ∈ t0, f p) atTop\n      (𝓝 <| ∏ b ∈ t0, g b) := by\n    simp only [← sigma_preimage_mk, prod_sigma]\n    refine tendsto_finset_prod _ fun b _ ↦ ?_\n    change\n      Tendsto (fun t ↦ (fun t ↦ ∏ s ∈ t, f ⟨b, s⟩) (preimage t (Sigma.mk b) _)) atTop (𝓝 (g b))\n    exact (hf b).comp (tendsto_finset_preimage_atTop_atTop (sigma_mk_injective))\n  have : ∃ t, ∏ p ∈ t with p.1 ∈ t0, f p ∈ v ∧ s ⊆ t :=\n    ((Tendsto.eventually_mem L (v_open.mem_nhds st0)).and (Ici_mem_atTop _)).exists\n  obtain ⟨t, tv, st⟩ := this\n  refine ⟨{p ∈ t | p.1 ∈ t0}, fun x hx ↦ ?_, vu tv⟩\n  simpa only [mem_filter, st hx, true_and] using ht0 (mem_image_of_mem Sigma.fst hx)\n\n"}
{"name":"Summable.sigma_factor","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : AddCommGroup α\ninst✝² : UniformSpace α\ninst✝¹ : UniformAddGroup α\ninst✝ : CompleteSpace α\nγ : β → Type u_4\nf : (Sigma fun b => γ b) → α\nha : Summable f\nb : β\n⊢ Summable fun c => f ⟨b, c⟩","decl":"@[to_additive]\ntheorem Multipliable.sigma_factor {γ : β → Type*} {f : (Σb : β, γ b) → α}\n    (ha : Multipliable f) (b : β) :\n    Multipliable fun c ↦ f ⟨b, c⟩ :=\n  ha.comp_injective sigma_mk_injective\n\n"}
{"name":"Multipliable.sigma_factor","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : CommGroup α\ninst✝² : UniformSpace α\ninst✝¹ : UniformGroup α\ninst✝ : CompleteSpace α\nγ : β → Type u_4\nf : (Sigma fun b => γ b) → α\nha : Multipliable f\nb : β\n⊢ Multipliable fun c => f ⟨b, c⟩","decl":"@[to_additive]\ntheorem Multipliable.sigma_factor {γ : β → Type*} {f : (Σb : β, γ b) → α}\n    (ha : Multipliable f) (b : β) :\n    Multipliable fun c ↦ f ⟨b, c⟩ :=\n  ha.comp_injective sigma_mk_injective\n\n"}
{"name":"Multipliable.sigma","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : CommGroup α\ninst✝² : UniformSpace α\ninst✝¹ : UniformGroup α\ninst✝ : CompleteSpace α\nγ : β → Type u_4\nf : (Sigma fun b => γ b) → α\nha : Multipliable f\n⊢ Multipliable fun b => tprod fun c => f ⟨b, c⟩","decl":"@[to_additive]\ntheorem Multipliable.sigma {γ : β → Type*} {f : (Σb : β, γ b) → α} (ha : Multipliable f) :\n    Multipliable fun b ↦ ∏' c, f ⟨b, c⟩ :=\n  ha.sigma' fun b ↦ ha.sigma_factor b\n\n"}
{"name":"Summable.sigma","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : AddCommGroup α\ninst✝² : UniformSpace α\ninst✝¹ : UniformAddGroup α\ninst✝ : CompleteSpace α\nγ : β → Type u_4\nf : (Sigma fun b => γ b) → α\nha : Summable f\n⊢ Summable fun b => tsum fun c => f ⟨b, c⟩","decl":"@[to_additive]\ntheorem Multipliable.sigma {γ : β → Type*} {f : (Σb : β, γ b) → α} (ha : Multipliable f) :\n    Multipliable fun b ↦ ∏' c, f ⟨b, c⟩ :=\n  ha.sigma' fun b ↦ ha.sigma_factor b\n\n"}
{"name":"Summable.prod_factor","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : AddCommGroup α\ninst✝² : UniformSpace α\ninst✝¹ : UniformAddGroup α\ninst✝ : CompleteSpace α\nf : Prod β γ → α\nh : Summable f\nb : β\n⊢ Summable fun c => f { fst := b, snd := c }","decl":"@[to_additive Summable.prod_factor]\ntheorem Multipliable.prod_factor {f : β × γ → α} (h : Multipliable f) (b : β) :\n    Multipliable fun c ↦ f (b, c) :=\n  h.comp_injective fun _ _ h ↦ (Prod.ext_iff.1 h).2\n\n"}
{"name":"Multipliable.prod_factor","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : CommGroup α\ninst✝² : UniformSpace α\ninst✝¹ : UniformGroup α\ninst✝ : CompleteSpace α\nf : Prod β γ → α\nh : Multipliable f\nb : β\n⊢ Multipliable fun c => f { fst := b, snd := c }","decl":"@[to_additive Summable.prod_factor]\ntheorem Multipliable.prod_factor {f : β × γ → α} (h : Multipliable f) (b : β) :\n    Multipliable fun c ↦ f (b, c) :=\n  h.comp_injective fun _ _ h ↦ (Prod.ext_iff.1 h).2\n\n"}
{"name":"Summable.prod","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : AddCommGroup α\ninst✝² : UniformSpace α\ninst✝¹ : UniformAddGroup α\ninst✝ : CompleteSpace α\nf : Prod β γ → α\nh : Summable f\n⊢ Summable fun b => tsum fun c => f { fst := b, snd := c }","decl":"@[to_additive Summable.prod]\nlemma Multipliable.prod {f : β × γ → α} (h : Multipliable f) :\n    Multipliable fun b ↦ ∏' c, f (b, c) :=\n  ((Equiv.sigmaEquivProd β γ).multipliable_iff.mpr h).sigma\n\n"}
{"name":"Multipliable.prod","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : CommGroup α\ninst✝² : UniformSpace α\ninst✝¹ : UniformGroup α\ninst✝ : CompleteSpace α\nf : Prod β γ → α\nh : Multipliable f\n⊢ Multipliable fun b => tprod fun c => f { fst := b, snd := c }","decl":"@[to_additive Summable.prod]\nlemma Multipliable.prod {f : β × γ → α} (h : Multipliable f) :\n    Multipliable fun b ↦ ∏' c, f (b, c) :=\n  ((Equiv.sigmaEquivProd β γ).multipliable_iff.mpr h).sigma\n\n"}
{"name":"HasProd.tprod_fiberwise","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁴ : CommGroup α\ninst✝³ : UniformSpace α\ninst✝² : UniformGroup α\ninst✝¹ : CompleteSpace α\ninst✝ : T2Space α\nf : β → α\na : α\nhf : HasProd f a\ng : β → γ\n⊢ HasProd (fun c => tprod fun b => f ↑b) a","decl":"@[to_additive]\nlemma HasProd.tprod_fiberwise [T2Space α] {f : β → α} {a : α} (hf : HasProd f a) (g : β → γ) :\n    HasProd (fun c : γ ↦ ∏' b : g ⁻¹' {c}, f b) a :=\n  (((Equiv.sigmaFiberEquiv g).hasProd_iff).mpr hf).sigma <|\n    fun _ ↦ ((hf.multipliable.subtype _).hasProd_iff).mpr rfl\n\n"}
{"name":"HasSum.tsum_fiberwise","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁴ : AddCommGroup α\ninst✝³ : UniformSpace α\ninst✝² : UniformAddGroup α\ninst✝¹ : CompleteSpace α\ninst✝ : T2Space α\nf : β → α\na : α\nhf : HasSum f a\ng : β → γ\n⊢ HasSum (fun c => tsum fun b => f ↑b) a","decl":"@[to_additive]\nlemma HasProd.tprod_fiberwise [T2Space α] {f : β → α} {a : α} (hf : HasProd f a) (g : β → γ) :\n    HasProd (fun c : γ ↦ ∏' b : g ⁻¹' {c}, f b) a :=\n  (((Equiv.sigmaFiberEquiv g).hasProd_iff).mpr hf).sigma <|\n    fun _ ↦ ((hf.multipliable.subtype _).hasProd_iff).mpr rfl\n\n"}
{"name":"tprod_sigma","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : CommGroup α\ninst✝³ : UniformSpace α\ninst✝² : UniformGroup α\ninst✝¹ : CompleteSpace α\ninst✝ : T0Space α\nγ : β → Type u_4\nf : (Sigma fun b => γ b) → α\nha : Multipliable f\n⊢ Eq (tprod fun p => f p) (tprod fun b => tprod fun c => f ⟨b, c⟩)","decl":"@[to_additive]\ntheorem tprod_sigma {γ : β → Type*} {f : (Σb : β, γ b) → α} (ha : Multipliable f) :\n    ∏' p, f p = ∏' (b) (c), f ⟨b, c⟩ :=\n  tprod_sigma' (fun b ↦ ha.sigma_factor b) ha\n\n"}
{"name":"tsum_sigma","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : AddCommGroup α\ninst✝³ : UniformSpace α\ninst✝² : UniformAddGroup α\ninst✝¹ : CompleteSpace α\ninst✝ : T0Space α\nγ : β → Type u_4\nf : (Sigma fun b => γ b) → α\nha : Summable f\n⊢ Eq (tsum fun p => f p) (tsum fun b => tsum fun c => f ⟨b, c⟩)","decl":"@[to_additive]\ntheorem tprod_sigma {γ : β → Type*} {f : (Σb : β, γ b) → α} (ha : Multipliable f) :\n    ∏' p, f p = ∏' (b) (c), f ⟨b, c⟩ :=\n  tprod_sigma' (fun b ↦ ha.sigma_factor b) ha\n\n"}
{"name":"tsum_prod","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁴ : AddCommGroup α\ninst✝³ : UniformSpace α\ninst✝² : UniformAddGroup α\ninst✝¹ : CompleteSpace α\ninst✝ : T0Space α\nf : Prod β γ → α\nh : Summable f\n⊢ Eq (tsum fun p => f p) (tsum fun b => tsum fun c => f { fst := b, snd := c })","decl":"@[to_additive tsum_prod]\ntheorem tprod_prod {f : β × γ → α} (h : Multipliable f) :\n    ∏' p, f p = ∏' (b) (c), f ⟨b, c⟩ :=\n  tprod_prod' h h.prod_factor\n\n"}
{"name":"tprod_prod","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁴ : CommGroup α\ninst✝³ : UniformSpace α\ninst✝² : UniformGroup α\ninst✝¹ : CompleteSpace α\ninst✝ : T0Space α\nf : Prod β γ → α\nh : Multipliable f\n⊢ Eq (tprod fun p => f p) (tprod fun b => tprod fun c => f { fst := b, snd := c })","decl":"@[to_additive tsum_prod]\ntheorem tprod_prod {f : β × γ → α} (h : Multipliable f) :\n    ∏' p, f p = ∏' (b) (c), f ⟨b, c⟩ :=\n  tprod_prod' h h.prod_factor\n\n"}
{"name":"tsum_comm","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁴ : AddCommGroup α\ninst✝³ : UniformSpace α\ninst✝² : UniformAddGroup α\ninst✝¹ : CompleteSpace α\ninst✝ : T0Space α\nf : β → γ → α\nh : Summable (Function.uncurry f)\n⊢ Eq (tsum fun c => tsum fun b => f b c) (tsum fun b => tsum fun c => f b c)","decl":"@[to_additive]\ntheorem tprod_comm {f : β → γ → α} (h : Multipliable (Function.uncurry f)) :\n    ∏' (c) (b), f b c = ∏' (b) (c), f b c :=\n  tprod_comm' h h.prod_factor h.prod_symm.prod_factor\n\n"}
{"name":"tprod_comm","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁴ : CommGroup α\ninst✝³ : UniformSpace α\ninst✝² : UniformGroup α\ninst✝¹ : CompleteSpace α\ninst✝ : T0Space α\nf : β → γ → α\nh : Multipliable (Function.uncurry f)\n⊢ Eq (tprod fun c => tprod fun b => f b c) (tprod fun b => tprod fun c => f b c)","decl":"@[to_additive]\ntheorem tprod_comm {f : β → γ → α} (h : Multipliable (Function.uncurry f)) :\n    ∏' (c) (b), f b c = ∏' (b) (c), f b c :=\n  tprod_comm' h h.prod_factor h.prod_symm.prod_factor\n\n"}
{"name":"Pi.hasProd","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nι : Type u_4\nπ : α → Type u_5\ninst✝¹ : (x : α) → CommMonoid (π x)\ninst✝ : (x : α) → TopologicalSpace (π x)\nf : ι → (x : α) → π x\ng : (x : α) → π x\n⊢ Iff (HasProd f g) (∀ (x : α), HasProd (fun i => f i x) (g x))","decl":"@[to_additive]\ntheorem Pi.hasProd {f : ι → ∀ x, π x} {g : ∀ x, π x} :\n    HasProd f g ↔ ∀ x, HasProd (fun i ↦ f i x) (g x) := by\n  simp only [HasProd, tendsto_pi_nhds, prod_apply]\n\n"}
{"name":"Pi.hasSum","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nι : Type u_4\nπ : α → Type u_5\ninst✝¹ : (x : α) → AddCommMonoid (π x)\ninst✝ : (x : α) → TopologicalSpace (π x)\nf : ι → (x : α) → π x\ng : (x : α) → π x\n⊢ Iff (HasSum f g) (∀ (x : α), HasSum (fun i => f i x) (g x))","decl":"@[to_additive]\ntheorem Pi.hasProd {f : ι → ∀ x, π x} {g : ∀ x, π x} :\n    HasProd f g ↔ ∀ x, HasProd (fun i ↦ f i x) (g x) := by\n  simp only [HasProd, tendsto_pi_nhds, prod_apply]\n\n"}
{"name":"Pi.summable","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nι : Type u_4\nπ : α → Type u_5\ninst✝¹ : (x : α) → AddCommMonoid (π x)\ninst✝ : (x : α) → TopologicalSpace (π x)\nf : ι → (x : α) → π x\n⊢ Iff (Summable f) (∀ (x : α), Summable fun i => f i x)","decl":"@[to_additive]\ntheorem Pi.multipliable {f : ι → ∀ x, π x} : Multipliable f ↔ ∀ x, Multipliable fun i ↦ f i x := by\n  simp only [Multipliable, Pi.hasProd, Classical.skolem]\n\n"}
{"name":"Pi.multipliable","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nι : Type u_4\nπ : α → Type u_5\ninst✝¹ : (x : α) → CommMonoid (π x)\ninst✝ : (x : α) → TopologicalSpace (π x)\nf : ι → (x : α) → π x\n⊢ Iff (Multipliable f) (∀ (x : α), Multipliable fun i => f i x)","decl":"@[to_additive]\ntheorem Pi.multipliable {f : ι → ∀ x, π x} : Multipliable f ↔ ∀ x, Multipliable fun i ↦ f i x := by\n  simp only [Multipliable, Pi.hasProd, Classical.skolem]\n\n"}
{"name":"tprod_apply","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nι : Type u_4\nπ : α → Type u_5\ninst✝² : (x : α) → CommMonoid (π x)\ninst✝¹ : (x : α) → TopologicalSpace (π x)\ninst✝ : ∀ (x : α), T2Space (π x)\nf : ι → (x : α) → π x\nx : α\nhf : Multipliable f\n⊢ Eq (tprod (fun i => f i) x) (tprod fun i => f i x)","decl":"@[to_additive]\ntheorem tprod_apply [∀ x, T2Space (π x)] {f : ι → ∀ x, π x} {x : α} (hf : Multipliable f) :\n    (∏' i, f i) x = ∏' i, f i x :=\n  (Pi.hasProd.mp hf.hasProd x).tprod_eq.symm\n\n"}
{"name":"tsum_apply","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nι : Type u_4\nπ : α → Type u_5\ninst✝² : (x : α) → AddCommMonoid (π x)\ninst✝¹ : (x : α) → TopologicalSpace (π x)\ninst✝ : ∀ (x : α), T2Space (π x)\nf : ι → (x : α) → π x\nx : α\nhf : Summable f\n⊢ Eq (tsum (fun i => f i) x) (tsum fun i => f i x)","decl":"@[to_additive]\ntheorem tprod_apply [∀ x, T2Space (π x)] {f : ι → ∀ x, π x} {x : α} (hf : Multipliable f) :\n    (∏' i, f i) x = ∏' i, f i x :=\n  (Pi.hasProd.mp hf.hasProd x).tprod_eq.symm\n\n"}
{"name":"HasSum.op","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\na : α\nhf : HasSum f a\n⊢ HasSum (fun a => MulOpposite.op (f a)) (MulOpposite.op a)","decl":"theorem HasSum.op (hf : HasSum f a) : HasSum (fun a ↦ op (f a)) (op a) :=\n  (hf.map (@opAddEquiv α _) continuous_op :)\n\n"}
{"name":"Summable.op","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\nhf : Summable f\n⊢ Summable (Function.comp MulOpposite.op f)","decl":"theorem Summable.op (hf : Summable f) : Summable (op ∘ f) :=\n  hf.hasSum.op.summable\n\n"}
{"name":"HasSum.unop","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → MulOpposite α\na : MulOpposite α\nhf : HasSum f a\n⊢ HasSum (fun a => MulOpposite.unop (f a)) (MulOpposite.unop a)","decl":"theorem HasSum.unop {f : β → αᵐᵒᵖ} {a : αᵐᵒᵖ} (hf : HasSum f a) :\n    HasSum (fun a ↦ unop (f a)) (unop a) :=\n  (hf.map (@opAddEquiv α _).symm continuous_unop :)\n\n"}
{"name":"Summable.unop","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → MulOpposite α\nhf : Summable f\n⊢ Summable (Function.comp MulOpposite.unop f)","decl":"theorem Summable.unop {f : β → αᵐᵒᵖ} (hf : Summable f) : Summable (unop ∘ f) :=\n  hf.hasSum.unop.summable\n\n"}
{"name":"hasSum_op","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\na : α\n⊢ Iff (HasSum (fun a => MulOpposite.op (f a)) (MulOpposite.op a)) (HasSum f a)","decl":"@[simp]\ntheorem hasSum_op : HasSum (fun a ↦ op (f a)) (op a) ↔ HasSum f a :=\n  ⟨HasSum.unop, HasSum.op⟩\n\n"}
{"name":"hasSum_unop","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → MulOpposite α\na : MulOpposite α\n⊢ Iff (HasSum (fun a => MulOpposite.unop (f a)) (MulOpposite.unop a)) (HasSum f a)","decl":"@[simp]\ntheorem hasSum_unop {f : β → αᵐᵒᵖ} {a : αᵐᵒᵖ} :\n    HasSum (fun a ↦ unop (f a)) (unop a) ↔ HasSum f a :=\n  ⟨HasSum.op, HasSum.unop⟩\n\n"}
{"name":"summable_op","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\n⊢ Iff (Summable fun a => MulOpposite.op (f a)) (Summable f)","decl":"@[simp]\ntheorem summable_op : (Summable fun a ↦ op (f a)) ↔ Summable f :=\n  ⟨Summable.unop, Summable.op⟩\n\n-- Porting note: This theorem causes a loop easily in Lean 4, so the priority should be `low`.\n"}
{"name":"summable_unop","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → MulOpposite α\n⊢ Iff (Summable fun a => MulOpposite.unop (f a)) (Summable f)","decl":"@[simp low]\ntheorem summable_unop {f : β → αᵐᵒᵖ} : (Summable fun a ↦ unop (f a)) ↔ Summable f :=\n  ⟨Summable.op, Summable.unop⟩\n\n"}
{"name":"tsum_op","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommMonoid α\ninst✝¹ : TopologicalSpace α\nf : β → α\ninst✝ : T2Space α\n⊢ Eq (tsum fun x => MulOpposite.op (f x)) (MulOpposite.op (tsum fun x => f x))","decl":"theorem tsum_op [T2Space α] :\n    ∑' x, op (f x) = op (∑' x, f x) := by\n  by_cases h : Summable f\n  · exact h.hasSum.op.tsum_eq\n  · have ho := summable_op.not.mpr h\n    rw [tsum_eq_zero_of_not_summable h, tsum_eq_zero_of_not_summable ho, op_zero]\n\n"}
{"name":"tsum_unop","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommMonoid α\ninst✝¹ : TopologicalSpace α\ninst✝ : T2Space α\nf : β → MulOpposite α\n⊢ Eq (tsum fun x => MulOpposite.unop (f x)) (MulOpposite.unop (tsum fun x => f x))","decl":"theorem tsum_unop [T2Space α] {f : β → αᵐᵒᵖ} :\n    ∑' x, unop (f x) = unop (∑' x, f x) :=\n  op_injective tsum_op.symm\n\n"}
{"name":"HasSum.star","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : AddCommMonoid α\ninst✝² : TopologicalSpace α\ninst✝¹ : StarAddMonoid α\ninst✝ : ContinuousStar α\nf : β → α\na : α\nh : HasSum f a\n⊢ HasSum (fun b => Star.star (f b)) (Star.star a)","decl":"theorem HasSum.star (h : HasSum f a) : HasSum (fun b ↦ star (f b)) (star a) := by\n  simpa only using h.map (starAddEquiv : α ≃+ α) continuous_star\n\n"}
{"name":"Summable.star","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : AddCommMonoid α\ninst✝² : TopologicalSpace α\ninst✝¹ : StarAddMonoid α\ninst✝ : ContinuousStar α\nf : β → α\nhf : Summable f\n⊢ Summable fun b => Star.star (f b)","decl":"theorem Summable.star (hf : Summable f) : Summable fun b ↦ star (f b) :=\n  hf.hasSum.star.summable\n\n"}
{"name":"Summable.ofStar","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : AddCommMonoid α\ninst✝² : TopologicalSpace α\ninst✝¹ : StarAddMonoid α\ninst✝ : ContinuousStar α\nf : β → α\nhf : Summable fun b => Star.star (f b)\n⊢ Summable f","decl":"theorem Summable.ofStar (hf : Summable fun b ↦ Star.star (f b)) : Summable f := by\n  simpa only [star_star] using hf.star\n\n"}
{"name":"summable_star_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : AddCommMonoid α\ninst✝² : TopologicalSpace α\ninst✝¹ : StarAddMonoid α\ninst✝ : ContinuousStar α\nf : β → α\n⊢ Iff (Summable fun b => Star.star (f b)) (Summable f)","decl":"@[simp]\ntheorem summable_star_iff : (Summable fun b ↦ star (f b)) ↔ Summable f :=\n  ⟨Summable.ofStar, Summable.star⟩\n\n"}
{"name":"summable_star_iff'","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : AddCommMonoid α\ninst✝² : TopologicalSpace α\ninst✝¹ : StarAddMonoid α\ninst✝ : ContinuousStar α\nf : β → α\n⊢ Iff (Summable (Star.star f)) (Summable f)","decl":"@[simp]\ntheorem summable_star_iff' : Summable (star f) ↔ Summable f :=\n  summable_star_iff\n\n"}
{"name":"tsum_star","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : AddCommMonoid α\ninst✝³ : TopologicalSpace α\ninst✝² : StarAddMonoid α\ninst✝¹ : ContinuousStar α\nf : β → α\ninst✝ : T2Space α\n⊢ Eq (Star.star (tsum fun b => f b)) (tsum fun b => Star.star (f b))","decl":"theorem tsum_star [T2Space α] : star (∑' b, f b) = ∑' b, star (f b) := by\n  by_cases hf : Summable f\n  · exact hf.hasSum.star.tsum_eq.symm\n  · rw [tsum_eq_zero_of_not_summable hf, tsum_eq_zero_of_not_summable (mt Summable.ofStar hf),\n      star_zero]\n\n"}
