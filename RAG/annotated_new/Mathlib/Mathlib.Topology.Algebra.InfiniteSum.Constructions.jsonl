{"name":"hasSum_pi_single","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : AddCommMonoid Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : DecidableEq Î²\nb : Î²\na : Î±\nâŠ¢ HasSum (Pi.single b a) a","decl":"@[to_additive]\ntheorem hasProd_pi_single [DecidableEq Î²] (b : Î²) (a : Î±) : HasProd (Pi.mulSingle b a) a := by\n  convert hasProd_ite_eq b a\n  simp [Pi.mulSingle_apply]\n\n"}
{"name":"hasProd_pi_single","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : CommMonoid Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : DecidableEq Î²\nb : Î²\na : Î±\nâŠ¢ HasProd (Pi.mulSingle b a) a","decl":"@[to_additive]\ntheorem hasProd_pi_single [DecidableEq Î²] (b : Î²) (a : Î±) : HasProd (Pi.mulSingle b a) a := by\n  convert hasProd_ite_eq b a\n  simp [Pi.mulSingle_apply]\n\n"}
{"name":"tsum_pi_single","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : AddCommMonoid Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : DecidableEq Î²\nb : Î²\na : Î±\nâŠ¢ Eq (tsum fun b' => Pi.single b a b') a","decl":"@[to_additive (attr := simp)]\ntheorem tprod_pi_single [DecidableEq Î²] (b : Î²) (a : Î±) : âˆ' b', Pi.mulSingle b a b' = a := by\n  rw [tprod_eq_mulSingle b]\n  Â· simp\n  Â· intro b' hb'; simp [hb']\n\n"}
{"name":"tprod_pi_single","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : CommMonoid Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : DecidableEq Î²\nb : Î²\na : Î±\nâŠ¢ Eq (tprod fun b' => Pi.mulSingle b a b') a","decl":"@[to_additive (attr := simp)]\ntheorem tprod_pi_single [DecidableEq Î²] (b : Î²) (a : Î±) : âˆ' b', Pi.mulSingle b a b' = a := by\n  rw [tprod_eq_mulSingle b]\n  Â· simp\n  Â· intro b' hb'; simp [hb']\n\n"}
{"name":"tsum_setProd_singleton_left","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ¹ : AddCommMonoid Î±\ninstâœ : TopologicalSpace Î±\nb : Î²\nt : Set Î³\nf : Prod Î² Î³ â†’ Î±\nâŠ¢ Eq (tsum fun x => f â†‘x) (tsum fun c => f { fst := b, snd := â†‘c })","decl":"@[to_additive tsum_setProd_singleton_left]\nlemma tprod_setProd_singleton_left (b : Î²) (t : Set Î³) (f : Î² Ã— Î³ â†’ Î±) :\n    (âˆ' x : {b} Ã—Ë¢ t, f x) = âˆ' c : t, f (b, c) := by\n  rw [tprod_congr_set_coe _ Set.singleton_prod, tprod_image _ (Prod.mk.inj_left b).injOn]\n\n"}
{"name":"tprod_setProd_singleton_left","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ¹ : CommMonoid Î±\ninstâœ : TopologicalSpace Î±\nb : Î²\nt : Set Î³\nf : Prod Î² Î³ â†’ Î±\nâŠ¢ Eq (tprod fun x => f â†‘x) (tprod fun c => f { fst := b, snd := â†‘c })","decl":"@[to_additive tsum_setProd_singleton_left]\nlemma tprod_setProd_singleton_left (b : Î²) (t : Set Î³) (f : Î² Ã— Î³ â†’ Î±) :\n    (âˆ' x : {b} Ã—Ë¢ t, f x) = âˆ' c : t, f (b, c) := by\n  rw [tprod_congr_set_coe _ Set.singleton_prod, tprod_image _ (Prod.mk.inj_left b).injOn]\n\n"}
{"name":"tsum_setProd_singleton_right","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ¹ : AddCommMonoid Î±\ninstâœ : TopologicalSpace Î±\ns : Set Î²\nc : Î³\nf : Prod Î² Î³ â†’ Î±\nâŠ¢ Eq (tsum fun x => f â†‘x) (tsum fun b => f { fst := â†‘b, snd := c })","decl":"@[to_additive tsum_setProd_singleton_right]\nlemma tprod_setProd_singleton_right (s : Set Î²) (c : Î³) (f : Î² Ã— Î³ â†’ Î±) :\n    (âˆ' x : s Ã—Ë¢ {c}, f x) = âˆ' b : s, f (b, c) := by\n  rw [tprod_congr_set_coe _ Set.prod_singleton, tprod_image _ (Prod.mk.inj_right c).injOn]\n\n"}
{"name":"tprod_setProd_singleton_right","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ¹ : CommMonoid Î±\ninstâœ : TopologicalSpace Î±\ns : Set Î²\nc : Î³\nf : Prod Î² Î³ â†’ Î±\nâŠ¢ Eq (tprod fun x => f â†‘x) (tprod fun b => f { fst := â†‘b, snd := c })","decl":"@[to_additive tsum_setProd_singleton_right]\nlemma tprod_setProd_singleton_right (s : Set Î²) (c : Î³) (f : Î² Ã— Î³ â†’ Î±) :\n    (âˆ' x : s Ã—Ë¢ {c}, f x) = âˆ' b : s, f (b, c) := by\n  rw [tprod_congr_set_coe _ Set.prod_singleton, tprod_image _ (Prod.mk.inj_right c).injOn]\n\n"}
{"name":"Multipliable.prod_symm","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ¹ : CommMonoid Î±\ninstâœ : TopologicalSpace Î±\nf : Prod Î² Î³ â†’ Î±\nhf : Multipliable f\nâŠ¢ Multipliable fun p => f p.swap","decl":"@[to_additive Summable.prod_symm]\ntheorem Multipliable.prod_symm {f : Î² Ã— Î³ â†’ Î±} (hf : Multipliable f) :\n    Multipliable fun p : Î³ Ã— Î² â†¦ f p.swap :=\n  (Equiv.prodComm Î³ Î²).multipliable_iff.2 hf\n\n"}
{"name":"Summable.prod_symm","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ¹ : AddCommMonoid Î±\ninstâœ : TopologicalSpace Î±\nf : Prod Î² Î³ â†’ Î±\nhf : Summable f\nâŠ¢ Summable fun p => f p.swap","decl":"@[to_additive Summable.prod_symm]\ntheorem Multipliable.prod_symm {f : Î² Ã— Î³ â†’ Î±} (hf : Multipliable f) :\n    Multipliable fun p : Î³ Ã— Î² â†¦ f p.swap :=\n  (Equiv.prodComm Î³ Î²).multipliable_iff.2 hf\n\n"}
{"name":"HasProd.prod_mk","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : CommMonoid Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : CommMonoid Î³\ninstâœ : TopologicalSpace Î³\nf : Î² â†’ Î±\ng : Î² â†’ Î³\na : Î±\nb : Î³\nhf : HasProd f a\nhg : HasProd g b\nâŠ¢ HasProd (fun x => { fst := f x, snd := g x }) { fst := a, snd := b }","decl":"@[to_additive HasSum.prod_mk]\ntheorem HasProd.prod_mk {f : Î² â†’ Î±} {g : Î² â†’ Î³} {a : Î±} {b : Î³}\n    (hf : HasProd f a) (hg : HasProd g b) : HasProd (fun x â†¦ (âŸ¨f x, g xâŸ© : Î± Ã— Î³)) âŸ¨a, bâŸ© := by\n  simp [HasProd, â† prod_mk_prod, Filter.Tendsto.prod_mk_nhds hf hg]\n\n"}
{"name":"HasSum.prod_mk","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : AddCommMonoid Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : AddCommMonoid Î³\ninstâœ : TopologicalSpace Î³\nf : Î² â†’ Î±\ng : Î² â†’ Î³\na : Î±\nb : Î³\nhf : HasSum f a\nhg : HasSum g b\nâŠ¢ HasSum (fun x => { fst := f x, snd := g x }) { fst := a, snd := b }","decl":"@[to_additive HasSum.prod_mk]\ntheorem HasProd.prod_mk {f : Î² â†’ Î±} {g : Î² â†’ Î³} {a : Î±} {b : Î³}\n    (hf : HasProd f a) (hg : HasProd g b) : HasProd (fun x â†¦ (âŸ¨f x, g xâŸ© : Î± Ã— Î³)) âŸ¨a, bâŸ© := by\n  simp [HasProd, â† prod_mk_prod, Filter.Tendsto.prod_mk_nhds hf hg]\n\n"}
{"name":"HasSum.sigma","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : AddCommMonoid Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : ContinuousAdd Î±\ninstâœ : RegularSpace Î±\nÎ³ : Î² â†’ Type u_4\nf : (Sigma fun b => Î³ b) â†’ Î±\ng : Î² â†’ Î±\na : Î±\nha : HasSum f a\nhf : âˆ€ (b : Î²), HasSum (fun c => f âŸ¨b, câŸ©) (g b)\nâŠ¢ HasSum g a","decl":"@[to_additive]\ntheorem HasProd.sigma {Î³ : Î² â†’ Type*} {f : (Î£ b : Î², Î³ b) â†’ Î±} {g : Î² â†’ Î±} {a : Î±}\n    (ha : HasProd f a) (hf : âˆ€ b, HasProd (fun c â†¦ f âŸ¨b, câŸ©) (g b)) : HasProd g a := by\n  classical\n  refine (atTop_basis.tendsto_iff (closed_nhds_basis a)).mpr ?_\n  rintro s âŸ¨hs, hscâŸ©\n  rcases mem_atTop_sets.mp (ha hs) with âŸ¨u, huâŸ©\n  use u.image Sigma.fst, trivial\n  intro bs hbs\n  simp only [Set.mem_preimage, Finset.le_iff_subset] at hu\n  have : Tendsto (fun t : Finset (Î£b, Î³ b) â†¦ âˆ p âˆˆ t with p.1 âˆˆ bs, f p) atTop\n      (ğ“ <| âˆ b âˆˆ bs, g b) := by\n    simp only [â† sigma_preimage_mk, prod_sigma]\n    refine tendsto_finset_prod _ fun b _ â†¦ ?_\n    change\n      Tendsto (fun t â†¦ (fun t â†¦ âˆ s âˆˆ t, f âŸ¨b, sâŸ©) (preimage t (Sigma.mk b) _)) atTop (ğ“ (g b))\n    exact (hf b).comp (tendsto_finset_preimage_atTop_atTop (sigma_mk_injective))\n  refine hsc.mem_of_tendsto this (eventually_atTop.2 âŸ¨u, fun t ht â†¦ hu _ fun x hx â†¦ ?_âŸ©)\n  exact mem_filter.2 âŸ¨ht hx, hbs <| mem_image_of_mem _ hxâŸ©\n\n"}
{"name":"HasProd.sigma","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : CommMonoid Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : ContinuousMul Î±\ninstâœ : RegularSpace Î±\nÎ³ : Î² â†’ Type u_4\nf : (Sigma fun b => Î³ b) â†’ Î±\ng : Î² â†’ Î±\na : Î±\nha : HasProd f a\nhf : âˆ€ (b : Î²), HasProd (fun c => f âŸ¨b, câŸ©) (g b)\nâŠ¢ HasProd g a","decl":"@[to_additive]\ntheorem HasProd.sigma {Î³ : Î² â†’ Type*} {f : (Î£ b : Î², Î³ b) â†’ Î±} {g : Î² â†’ Î±} {a : Î±}\n    (ha : HasProd f a) (hf : âˆ€ b, HasProd (fun c â†¦ f âŸ¨b, câŸ©) (g b)) : HasProd g a := by\n  classical\n  refine (atTop_basis.tendsto_iff (closed_nhds_basis a)).mpr ?_\n  rintro s âŸ¨hs, hscâŸ©\n  rcases mem_atTop_sets.mp (ha hs) with âŸ¨u, huâŸ©\n  use u.image Sigma.fst, trivial\n  intro bs hbs\n  simp only [Set.mem_preimage, Finset.le_iff_subset] at hu\n  have : Tendsto (fun t : Finset (Î£b, Î³ b) â†¦ âˆ p âˆˆ t with p.1 âˆˆ bs, f p) atTop\n      (ğ“ <| âˆ b âˆˆ bs, g b) := by\n    simp only [â† sigma_preimage_mk, prod_sigma]\n    refine tendsto_finset_prod _ fun b _ â†¦ ?_\n    change\n      Tendsto (fun t â†¦ (fun t â†¦ âˆ s âˆˆ t, f âŸ¨b, sâŸ©) (preimage t (Sigma.mk b) _)) atTop (ğ“ (g b))\n    exact (hf b).comp (tendsto_finset_preimage_atTop_atTop (sigma_mk_injective))\n  refine hsc.mem_of_tendsto this (eventually_atTop.2 âŸ¨u, fun t ht â†¦ hu _ fun x hx â†¦ ?_âŸ©)\n  exact mem_filter.2 âŸ¨ht hx, hbs <| mem_image_of_mem _ hxâŸ©\n\n"}
{"name":"HasProd.prod_fiberwise","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : CommMonoid Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : ContinuousMul Î±\ninstâœ : RegularSpace Î±\nf : Prod Î² Î³ â†’ Î±\ng : Î² â†’ Î±\na : Î±\nha : HasProd f a\nhf : âˆ€ (b : Î²), HasProd (fun c => f { fst := b, snd := c }) (g b)\nâŠ¢ HasProd g a","decl":"/-- If a function `f` on `Î² Ã— Î³` has product `a` and for each `b` the restriction of `f` to\n`{b} Ã— Î³` has product `g b`, then the function `g` has product `a`. -/\n@[to_additive HasSum.prod_fiberwise \"If a series `f` on `Î² Ã— Î³` has sum `a` and for each `b` the\nrestriction of `f` to `{b} Ã— Î³` has sum `g b`, then the series `g` has sum `a`.\"]\ntheorem HasProd.prod_fiberwise {f : Î² Ã— Î³ â†’ Î±} {g : Î² â†’ Î±} {a : Î±} (ha : HasProd f a)\n    (hf : âˆ€ b, HasProd (fun c â†¦ f (b, c)) (g b)) : HasProd g a :=\n  HasProd.sigma ((Equiv.sigmaEquivProd Î² Î³).hasProd_iff.2 ha) hf\n\n"}
{"name":"HasSum.prod_fiberwise","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : AddCommMonoid Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : ContinuousAdd Î±\ninstâœ : RegularSpace Î±\nf : Prod Î² Î³ â†’ Î±\ng : Î² â†’ Î±\na : Î±\nha : HasSum f a\nhf : âˆ€ (b : Î²), HasSum (fun c => f { fst := b, snd := c }) (g b)\nâŠ¢ HasSum g a","decl":"/-- If a function `f` on `Î² Ã— Î³` has product `a` and for each `b` the restriction of `f` to\n`{b} Ã— Î³` has product `g b`, then the function `g` has product `a`. -/\n@[to_additive HasSum.prod_fiberwise \"If a series `f` on `Î² Ã— Î³` has sum `a` and for each `b` the\nrestriction of `f` to `{b} Ã— Î³` has sum `g b`, then the series `g` has sum `a`.\"]\ntheorem HasProd.prod_fiberwise {f : Î² Ã— Î³ â†’ Î±} {g : Î² â†’ Î±} {a : Î±} (ha : HasProd f a)\n    (hf : âˆ€ b, HasProd (fun c â†¦ f (b, c)) (g b)) : HasProd g a :=\n  HasProd.sigma ((Equiv.sigmaEquivProd Î² Î³).hasProd_iff.2 ha) hf\n\n"}
{"name":"Multipliable.sigma'","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : CommMonoid Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : ContinuousMul Î±\ninstâœ : RegularSpace Î±\nÎ³ : Î² â†’ Type u_4\nf : (Sigma fun b => Î³ b) â†’ Î±\nha : Multipliable f\nhf : âˆ€ (b : Î²), Multipliable fun c => f âŸ¨b, câŸ©\nâŠ¢ Multipliable fun b => tprod fun c => f âŸ¨b, câŸ©","decl":"@[to_additive]\ntheorem Multipliable.sigma' {Î³ : Î² â†’ Type*} {f : (Î£b : Î², Î³ b) â†’ Î±} (ha : Multipliable f)\n    (hf : âˆ€ b, Multipliable fun c â†¦ f âŸ¨b, câŸ©) : Multipliable fun b â†¦ âˆ' c, f âŸ¨b, câŸ© :=\n  (ha.hasProd.sigma fun b â†¦ (hf b).hasProd).multipliable\n\n"}
{"name":"Summable.sigma'","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : AddCommMonoid Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : ContinuousAdd Î±\ninstâœ : RegularSpace Î±\nÎ³ : Î² â†’ Type u_4\nf : (Sigma fun b => Î³ b) â†’ Î±\nha : Summable f\nhf : âˆ€ (b : Î²), Summable fun c => f âŸ¨b, câŸ©\nâŠ¢ Summable fun b => tsum fun c => f âŸ¨b, câŸ©","decl":"@[to_additive]\ntheorem Multipliable.sigma' {Î³ : Î² â†’ Type*} {f : (Î£b : Î², Î³ b) â†’ Î±} (ha : Multipliable f)\n    (hf : âˆ€ b, Multipliable fun c â†¦ f âŸ¨b, câŸ©) : Multipliable fun b â†¦ âˆ' c, f âŸ¨b, câŸ© :=\n  (ha.hasProd.sigma fun b â†¦ (hf b).hasProd).multipliable\n\n"}
{"name":"HasProd.sigma_of_hasProd","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : CommMonoid Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : ContinuousMul Î±\ninstâœ : T3Space Î±\nÎ³ : Î² â†’ Type u_4\nf : (Sigma fun b => Î³ b) â†’ Î±\ng : Î² â†’ Î±\na : Î±\nha : HasProd g a\nhf : âˆ€ (b : Î²), HasProd (fun c => f âŸ¨b, câŸ©) (g b)\nhf' : Multipliable f\nâŠ¢ HasProd f a","decl":"@[to_additive]\ntheorem HasProd.sigma_of_hasProd {Î³ : Î² â†’ Type*} {f : (Î£b : Î², Î³ b) â†’ Î±} {g : Î² â†’ Î±}\n    {a : Î±} (ha : HasProd g a) (hf : âˆ€ b, HasProd (fun c â†¦ f âŸ¨b, câŸ©) (g b)) (hf' : Multipliable f) :\n    HasProd f a := by simpa [(hf'.hasProd.sigma hf).unique ha] using hf'.hasProd\n\n"}
{"name":"HasSum.sigma_of_hasSum","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : AddCommMonoid Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : ContinuousAdd Î±\ninstâœ : T3Space Î±\nÎ³ : Î² â†’ Type u_4\nf : (Sigma fun b => Î³ b) â†’ Î±\ng : Î² â†’ Î±\na : Î±\nha : HasSum g a\nhf : âˆ€ (b : Î²), HasSum (fun c => f âŸ¨b, câŸ©) (g b)\nhf' : Summable f\nâŠ¢ HasSum f a","decl":"@[to_additive]\ntheorem HasProd.sigma_of_hasProd {Î³ : Î² â†’ Type*} {f : (Î£b : Î², Î³ b) â†’ Î±} {g : Î² â†’ Î±}\n    {a : Î±} (ha : HasProd g a) (hf : âˆ€ b, HasProd (fun c â†¦ f âŸ¨b, câŸ©) (g b)) (hf' : Multipliable f) :\n    HasProd f a := by simpa [(hf'.hasProd.sigma hf).unique ha] using hf'.hasProd\n\n"}
{"name":"tprod_sigma'","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : CommMonoid Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : ContinuousMul Î±\ninstâœ : T3Space Î±\nÎ³ : Î² â†’ Type u_4\nf : (Sigma fun b => Î³ b) â†’ Î±\nhâ‚ : âˆ€ (b : Î²), Multipliable fun c => f âŸ¨b, câŸ©\nhâ‚‚ : Multipliable f\nâŠ¢ Eq (tprod fun p => f p) (tprod fun b => tprod fun c => f âŸ¨b, câŸ©)","decl":"@[to_additive]\ntheorem tprod_sigma' {Î³ : Î² â†’ Type*} {f : (Î£b : Î², Î³ b) â†’ Î±}\n    (hâ‚ : âˆ€ b, Multipliable fun c â†¦ f âŸ¨b, câŸ©) (hâ‚‚ : Multipliable f) :\n    âˆ' p, f p = âˆ' (b) (c), f âŸ¨b, câŸ© :=\n  (hâ‚‚.hasProd.sigma fun b â†¦ (hâ‚ b).hasProd).tprod_eq.symm\n\n"}
{"name":"tsum_sigma'","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : AddCommMonoid Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : ContinuousAdd Î±\ninstâœ : T3Space Î±\nÎ³ : Î² â†’ Type u_4\nf : (Sigma fun b => Î³ b) â†’ Î±\nhâ‚ : âˆ€ (b : Î²), Summable fun c => f âŸ¨b, câŸ©\nhâ‚‚ : Summable f\nâŠ¢ Eq (tsum fun p => f p) (tsum fun b => tsum fun c => f âŸ¨b, câŸ©)","decl":"@[to_additive]\ntheorem tprod_sigma' {Î³ : Î² â†’ Type*} {f : (Î£b : Î², Î³ b) â†’ Î±}\n    (hâ‚ : âˆ€ b, Multipliable fun c â†¦ f âŸ¨b, câŸ©) (hâ‚‚ : Multipliable f) :\n    âˆ' p, f p = âˆ' (b) (c), f âŸ¨b, câŸ© :=\n  (hâ‚‚.hasProd.sigma fun b â†¦ (hâ‚ b).hasProd).tprod_eq.symm\n\n"}
{"name":"tprod_prod'","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : CommMonoid Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : ContinuousMul Î±\ninstâœ : T3Space Î±\nf : Prod Î² Î³ â†’ Î±\nh : Multipliable f\nhâ‚ : âˆ€ (b : Î²), Multipliable fun c => f { fst := b, snd := c }\nâŠ¢ Eq (tprod fun p => f p) (tprod fun b => tprod fun c => f { fst := b, snd := c })","decl":"@[to_additive tsum_prod']\ntheorem tprod_prod' {f : Î² Ã— Î³ â†’ Î±} (h : Multipliable f)\n    (hâ‚ : âˆ€ b, Multipliable fun c â†¦ f (b, c)) :\n    âˆ' p, f p = âˆ' (b) (c), f (b, c) :=\n  (h.hasProd.prod_fiberwise fun b â†¦ (hâ‚ b).hasProd).tprod_eq.symm\n\n"}
{"name":"tsum_prod'","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : AddCommMonoid Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : ContinuousAdd Î±\ninstâœ : T3Space Î±\nf : Prod Î² Î³ â†’ Î±\nh : Summable f\nhâ‚ : âˆ€ (b : Î²), Summable fun c => f { fst := b, snd := c }\nâŠ¢ Eq (tsum fun p => f p) (tsum fun b => tsum fun c => f { fst := b, snd := c })","decl":"@[to_additive tsum_prod']\ntheorem tprod_prod' {f : Î² Ã— Î³ â†’ Î±} (h : Multipliable f)\n    (hâ‚ : âˆ€ b, Multipliable fun c â†¦ f (b, c)) :\n    âˆ' p, f p = âˆ' (b) (c), f (b, c) :=\n  (h.hasProd.prod_fiberwise fun b â†¦ (hâ‚ b).hasProd).tprod_eq.symm\n\n"}
{"name":"tprod_comm'","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : CommMonoid Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : ContinuousMul Î±\ninstâœ : T3Space Î±\nf : Î² â†’ Î³ â†’ Î±\nh : Multipliable (Function.uncurry f)\nhâ‚ : âˆ€ (b : Î²), Multipliable (f b)\nhâ‚‚ : âˆ€ (c : Î³), Multipliable fun b => f b c\nâŠ¢ Eq (tprod fun c => tprod fun b => f b c) (tprod fun b => tprod fun c => f b c)","decl":"@[to_additive]\ntheorem tprod_comm' {f : Î² â†’ Î³ â†’ Î±} (h : Multipliable (Function.uncurry f))\n    (hâ‚ : âˆ€ b, Multipliable (f b)) (hâ‚‚ : âˆ€ c, Multipliable fun b â†¦ f b c) :\n    âˆ' (c) (b), f b c = âˆ' (b) (c), f b c := by\n  erw [â† tprod_prod' h hâ‚, â† tprod_prod' h.prod_symm hâ‚‚,\n      â† (Equiv.prodComm Î³ Î²).tprod_eq (uncurry f)]\n  rfl\n\n"}
{"name":"tsum_comm'","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : AddCommMonoid Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : ContinuousAdd Î±\ninstâœ : T3Space Î±\nf : Î² â†’ Î³ â†’ Î±\nh : Summable (Function.uncurry f)\nhâ‚ : âˆ€ (b : Î²), Summable (f b)\nhâ‚‚ : âˆ€ (c : Î³), Summable fun b => f b c\nâŠ¢ Eq (tsum fun c => tsum fun b => f b c) (tsum fun b => tsum fun c => f b c)","decl":"@[to_additive]\ntheorem tprod_comm' {f : Î² â†’ Î³ â†’ Î±} (h : Multipliable (Function.uncurry f))\n    (hâ‚ : âˆ€ b, Multipliable (f b)) (hâ‚‚ : âˆ€ c, Multipliable fun b â†¦ f b c) :\n    âˆ' (c) (b), f b c = âˆ' (b) (c), f b c := by\n  erw [â† tprod_prod' h hâ‚, â† tprod_prod' h.prod_symm hâ‚‚,\n      â† (Equiv.prodComm Î³ Î²).tprod_eq (uncurry f)]\n  rfl\n\n"}
{"name":"HasProd.of_sigma","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : CommGroup Î±\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformGroup Î±\nÎ³ : Î² â†’ Type u_4\nf : (Sigma fun b => Î³ b) â†’ Î±\ng : Î² â†’ Î±\na : Î±\nhf : âˆ€ (b : Î²), HasProd (fun c => f âŸ¨b, câŸ©) (g b)\nhg : HasProd g a\nh : CauchySeq fun s => s.prod fun i => f i\nâŠ¢ HasProd f a","decl":"@[to_additive]\ntheorem HasProd.of_sigma {Î³ : Î² â†’ Type*} {f : (Î£ b : Î², Î³ b) â†’ Î±} {g : Î² â†’ Î±} {a : Î±}\n    (hf : âˆ€ b, HasProd (fun c â†¦ f âŸ¨b, câŸ©) (g b)) (hg : HasProd g a)\n    (h : CauchySeq (fun (s : Finset (Î£ b : Î², Î³ b)) â†¦ âˆ i âˆˆ s, f i)) :\n    HasProd f a := by\n  classical\n  apply le_nhds_of_cauchy_adhp h\n  simp only [â† mapClusterPt_def, mapClusterPt_iff, frequently_atTop, ge_iff_le, le_eq_subset]\n  intro u hu s\n  rcases mem_nhds_iff.1 hu with âŸ¨v, vu, v_open, hvâŸ©\n  obtain âŸ¨t0, st0, ht0âŸ© : âˆƒ t0, âˆ i âˆˆ t0, g i âˆˆ v âˆ§ s.image Sigma.fst âŠ† t0 := by\n    have A : âˆ€á¶  t0 in (atTop : Filter (Finset Î²)), âˆ i âˆˆ t0, g i âˆˆ v := hg (v_open.mem_nhds hv)\n    exact (A.and (Ici_mem_atTop _)).exists\n  have L : Tendsto (fun t : Finset (Î£b, Î³ b) â†¦ âˆ p âˆˆ t with p.1 âˆˆ t0, f p) atTop\n      (ğ“ <| âˆ b âˆˆ t0, g b) := by\n    simp only [â† sigma_preimage_mk, prod_sigma]\n    refine tendsto_finset_prod _ fun b _ â†¦ ?_\n    change\n      Tendsto (fun t â†¦ (fun t â†¦ âˆ s âˆˆ t, f âŸ¨b, sâŸ©) (preimage t (Sigma.mk b) _)) atTop (ğ“ (g b))\n    exact (hf b).comp (tendsto_finset_preimage_atTop_atTop (sigma_mk_injective))\n  have : âˆƒ t, âˆ p âˆˆ t with p.1 âˆˆ t0, f p âˆˆ v âˆ§ s âŠ† t :=\n    ((Tendsto.eventually_mem L (v_open.mem_nhds st0)).and (Ici_mem_atTop _)).exists\n  obtain âŸ¨t, tv, stâŸ© := this\n  refine âŸ¨{p âˆˆ t | p.1 âˆˆ t0}, fun x hx â†¦ ?_, vu tvâŸ©\n  simpa only [mem_filter, st hx, true_and] using ht0 (mem_image_of_mem Sigma.fst hx)\n\n"}
{"name":"HasSum.of_sigma","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : AddCommGroup Î±\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformAddGroup Î±\nÎ³ : Î² â†’ Type u_4\nf : (Sigma fun b => Î³ b) â†’ Î±\ng : Î² â†’ Î±\na : Î±\nhf : âˆ€ (b : Î²), HasSum (fun c => f âŸ¨b, câŸ©) (g b)\nhg : HasSum g a\nh : CauchySeq fun s => s.sum fun i => f i\nâŠ¢ HasSum f a","decl":"@[to_additive]\ntheorem HasProd.of_sigma {Î³ : Î² â†’ Type*} {f : (Î£ b : Î², Î³ b) â†’ Î±} {g : Î² â†’ Î±} {a : Î±}\n    (hf : âˆ€ b, HasProd (fun c â†¦ f âŸ¨b, câŸ©) (g b)) (hg : HasProd g a)\n    (h : CauchySeq (fun (s : Finset (Î£ b : Î², Î³ b)) â†¦ âˆ i âˆˆ s, f i)) :\n    HasProd f a := by\n  classical\n  apply le_nhds_of_cauchy_adhp h\n  simp only [â† mapClusterPt_def, mapClusterPt_iff, frequently_atTop, ge_iff_le, le_eq_subset]\n  intro u hu s\n  rcases mem_nhds_iff.1 hu with âŸ¨v, vu, v_open, hvâŸ©\n  obtain âŸ¨t0, st0, ht0âŸ© : âˆƒ t0, âˆ i âˆˆ t0, g i âˆˆ v âˆ§ s.image Sigma.fst âŠ† t0 := by\n    have A : âˆ€á¶  t0 in (atTop : Filter (Finset Î²)), âˆ i âˆˆ t0, g i âˆˆ v := hg (v_open.mem_nhds hv)\n    exact (A.and (Ici_mem_atTop _)).exists\n  have L : Tendsto (fun t : Finset (Î£b, Î³ b) â†¦ âˆ p âˆˆ t with p.1 âˆˆ t0, f p) atTop\n      (ğ“ <| âˆ b âˆˆ t0, g b) := by\n    simp only [â† sigma_preimage_mk, prod_sigma]\n    refine tendsto_finset_prod _ fun b _ â†¦ ?_\n    change\n      Tendsto (fun t â†¦ (fun t â†¦ âˆ s âˆˆ t, f âŸ¨b, sâŸ©) (preimage t (Sigma.mk b) _)) atTop (ğ“ (g b))\n    exact (hf b).comp (tendsto_finset_preimage_atTop_atTop (sigma_mk_injective))\n  have : âˆƒ t, âˆ p âˆˆ t with p.1 âˆˆ t0, f p âˆˆ v âˆ§ s âŠ† t :=\n    ((Tendsto.eventually_mem L (v_open.mem_nhds st0)).and (Ici_mem_atTop _)).exists\n  obtain âŸ¨t, tv, stâŸ© := this\n  refine âŸ¨{p âˆˆ t | p.1 âˆˆ t0}, fun x hx â†¦ ?_, vu tvâŸ©\n  simpa only [mem_filter, st hx, true_and] using ht0 (mem_image_of_mem Sigma.fst hx)\n\n"}
{"name":"Summable.sigma_factor","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : AddCommGroup Î±\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformAddGroup Î±\ninstâœ : CompleteSpace Î±\nÎ³ : Î² â†’ Type u_4\nf : (Sigma fun b => Î³ b) â†’ Î±\nha : Summable f\nb : Î²\nâŠ¢ Summable fun c => f âŸ¨b, câŸ©","decl":"@[to_additive]\ntheorem Multipliable.sigma_factor {Î³ : Î² â†’ Type*} {f : (Î£b : Î², Î³ b) â†’ Î±}\n    (ha : Multipliable f) (b : Î²) :\n    Multipliable fun c â†¦ f âŸ¨b, câŸ© :=\n  ha.comp_injective sigma_mk_injective\n\n"}
{"name":"Multipliable.sigma_factor","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : CommGroup Î±\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformGroup Î±\ninstâœ : CompleteSpace Î±\nÎ³ : Î² â†’ Type u_4\nf : (Sigma fun b => Î³ b) â†’ Î±\nha : Multipliable f\nb : Î²\nâŠ¢ Multipliable fun c => f âŸ¨b, câŸ©","decl":"@[to_additive]\ntheorem Multipliable.sigma_factor {Î³ : Î² â†’ Type*} {f : (Î£b : Î², Î³ b) â†’ Î±}\n    (ha : Multipliable f) (b : Î²) :\n    Multipliable fun c â†¦ f âŸ¨b, câŸ© :=\n  ha.comp_injective sigma_mk_injective\n\n"}
{"name":"Multipliable.sigma","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : CommGroup Î±\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformGroup Î±\ninstâœ : CompleteSpace Î±\nÎ³ : Î² â†’ Type u_4\nf : (Sigma fun b => Î³ b) â†’ Î±\nha : Multipliable f\nâŠ¢ Multipliable fun b => tprod fun c => f âŸ¨b, câŸ©","decl":"@[to_additive]\ntheorem Multipliable.sigma {Î³ : Î² â†’ Type*} {f : (Î£b : Î², Î³ b) â†’ Î±} (ha : Multipliable f) :\n    Multipliable fun b â†¦ âˆ' c, f âŸ¨b, câŸ© :=\n  ha.sigma' fun b â†¦ ha.sigma_factor b\n\n"}
{"name":"Summable.sigma","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : AddCommGroup Î±\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformAddGroup Î±\ninstâœ : CompleteSpace Î±\nÎ³ : Î² â†’ Type u_4\nf : (Sigma fun b => Î³ b) â†’ Î±\nha : Summable f\nâŠ¢ Summable fun b => tsum fun c => f âŸ¨b, câŸ©","decl":"@[to_additive]\ntheorem Multipliable.sigma {Î³ : Î² â†’ Type*} {f : (Î£b : Î², Î³ b) â†’ Î±} (ha : Multipliable f) :\n    Multipliable fun b â†¦ âˆ' c, f âŸ¨b, câŸ© :=\n  ha.sigma' fun b â†¦ ha.sigma_factor b\n\n"}
{"name":"Summable.prod_factor","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : AddCommGroup Î±\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformAddGroup Î±\ninstâœ : CompleteSpace Î±\nf : Prod Î² Î³ â†’ Î±\nh : Summable f\nb : Î²\nâŠ¢ Summable fun c => f { fst := b, snd := c }","decl":"@[to_additive Summable.prod_factor]\ntheorem Multipliable.prod_factor {f : Î² Ã— Î³ â†’ Î±} (h : Multipliable f) (b : Î²) :\n    Multipliable fun c â†¦ f (b, c) :=\n  h.comp_injective fun _ _ h â†¦ (Prod.ext_iff.1 h).2\n\n"}
{"name":"Multipliable.prod_factor","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : CommGroup Î±\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformGroup Î±\ninstâœ : CompleteSpace Î±\nf : Prod Î² Î³ â†’ Î±\nh : Multipliable f\nb : Î²\nâŠ¢ Multipliable fun c => f { fst := b, snd := c }","decl":"@[to_additive Summable.prod_factor]\ntheorem Multipliable.prod_factor {f : Î² Ã— Î³ â†’ Î±} (h : Multipliable f) (b : Î²) :\n    Multipliable fun c â†¦ f (b, c) :=\n  h.comp_injective fun _ _ h â†¦ (Prod.ext_iff.1 h).2\n\n"}
{"name":"Summable.prod","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : AddCommGroup Î±\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformAddGroup Î±\ninstâœ : CompleteSpace Î±\nf : Prod Î² Î³ â†’ Î±\nh : Summable f\nâŠ¢ Summable fun b => tsum fun c => f { fst := b, snd := c }","decl":"@[to_additive Summable.prod]\nlemma Multipliable.prod {f : Î² Ã— Î³ â†’ Î±} (h : Multipliable f) :\n    Multipliable fun b â†¦ âˆ' c, f (b, c) :=\n  ((Equiv.sigmaEquivProd Î² Î³).multipliable_iff.mpr h).sigma\n\n"}
{"name":"Multipliable.prod","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : CommGroup Î±\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformGroup Î±\ninstâœ : CompleteSpace Î±\nf : Prod Î² Î³ â†’ Î±\nh : Multipliable f\nâŠ¢ Multipliable fun b => tprod fun c => f { fst := b, snd := c }","decl":"@[to_additive Summable.prod]\nlemma Multipliable.prod {f : Î² Ã— Î³ â†’ Î±} (h : Multipliable f) :\n    Multipliable fun b â†¦ âˆ' c, f (b, c) :=\n  ((Equiv.sigmaEquivProd Î² Î³).multipliable_iff.mpr h).sigma\n\n"}
{"name":"HasProd.tprod_fiberwise","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœâ´ : CommGroup Î±\ninstâœÂ³ : UniformSpace Î±\ninstâœÂ² : UniformGroup Î±\ninstâœÂ¹ : CompleteSpace Î±\ninstâœ : T2Space Î±\nf : Î² â†’ Î±\na : Î±\nhf : HasProd f a\ng : Î² â†’ Î³\nâŠ¢ HasProd (fun c => tprod fun b => f â†‘b) a","decl":"@[to_additive]\nlemma HasProd.tprod_fiberwise [T2Space Î±] {f : Î² â†’ Î±} {a : Î±} (hf : HasProd f a) (g : Î² â†’ Î³) :\n    HasProd (fun c : Î³ â†¦ âˆ' b : g â»Â¹' {c}, f b) a :=\n  (((Equiv.sigmaFiberEquiv g).hasProd_iff).mpr hf).sigma <|\n    fun _ â†¦ ((hf.multipliable.subtype _).hasProd_iff).mpr rfl\n\n"}
{"name":"HasSum.tsum_fiberwise","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœâ´ : AddCommGroup Î±\ninstâœÂ³ : UniformSpace Î±\ninstâœÂ² : UniformAddGroup Î±\ninstâœÂ¹ : CompleteSpace Î±\ninstâœ : T2Space Î±\nf : Î² â†’ Î±\na : Î±\nhf : HasSum f a\ng : Î² â†’ Î³\nâŠ¢ HasSum (fun c => tsum fun b => f â†‘b) a","decl":"@[to_additive]\nlemma HasProd.tprod_fiberwise [T2Space Î±] {f : Î² â†’ Î±} {a : Î±} (hf : HasProd f a) (g : Î² â†’ Î³) :\n    HasProd (fun c : Î³ â†¦ âˆ' b : g â»Â¹' {c}, f b) a :=\n  (((Equiv.sigmaFiberEquiv g).hasProd_iff).mpr hf).sigma <|\n    fun _ â†¦ ((hf.multipliable.subtype _).hasProd_iff).mpr rfl\n\n"}
{"name":"tprod_sigma","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ´ : CommGroup Î±\ninstâœÂ³ : UniformSpace Î±\ninstâœÂ² : UniformGroup Î±\ninstâœÂ¹ : CompleteSpace Î±\ninstâœ : T0Space Î±\nÎ³ : Î² â†’ Type u_4\nf : (Sigma fun b => Î³ b) â†’ Î±\nha : Multipliable f\nâŠ¢ Eq (tprod fun p => f p) (tprod fun b => tprod fun c => f âŸ¨b, câŸ©)","decl":"@[to_additive]\ntheorem tprod_sigma {Î³ : Î² â†’ Type*} {f : (Î£b : Î², Î³ b) â†’ Î±} (ha : Multipliable f) :\n    âˆ' p, f p = âˆ' (b) (c), f âŸ¨b, câŸ© :=\n  tprod_sigma' (fun b â†¦ ha.sigma_factor b) ha\n\n"}
{"name":"tsum_sigma","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ´ : AddCommGroup Î±\ninstâœÂ³ : UniformSpace Î±\ninstâœÂ² : UniformAddGroup Î±\ninstâœÂ¹ : CompleteSpace Î±\ninstâœ : T0Space Î±\nÎ³ : Î² â†’ Type u_4\nf : (Sigma fun b => Î³ b) â†’ Î±\nha : Summable f\nâŠ¢ Eq (tsum fun p => f p) (tsum fun b => tsum fun c => f âŸ¨b, câŸ©)","decl":"@[to_additive]\ntheorem tprod_sigma {Î³ : Î² â†’ Type*} {f : (Î£b : Î², Î³ b) â†’ Î±} (ha : Multipliable f) :\n    âˆ' p, f p = âˆ' (b) (c), f âŸ¨b, câŸ© :=\n  tprod_sigma' (fun b â†¦ ha.sigma_factor b) ha\n\n"}
{"name":"tsum_prod","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœâ´ : AddCommGroup Î±\ninstâœÂ³ : UniformSpace Î±\ninstâœÂ² : UniformAddGroup Î±\ninstâœÂ¹ : CompleteSpace Î±\ninstâœ : T0Space Î±\nf : Prod Î² Î³ â†’ Î±\nh : Summable f\nâŠ¢ Eq (tsum fun p => f p) (tsum fun b => tsum fun c => f { fst := b, snd := c })","decl":"@[to_additive tsum_prod]\ntheorem tprod_prod {f : Î² Ã— Î³ â†’ Î±} (h : Multipliable f) :\n    âˆ' p, f p = âˆ' (b) (c), f âŸ¨b, câŸ© :=\n  tprod_prod' h h.prod_factor\n\n"}
{"name":"tprod_prod","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœâ´ : CommGroup Î±\ninstâœÂ³ : UniformSpace Î±\ninstâœÂ² : UniformGroup Î±\ninstâœÂ¹ : CompleteSpace Î±\ninstâœ : T0Space Î±\nf : Prod Î² Î³ â†’ Î±\nh : Multipliable f\nâŠ¢ Eq (tprod fun p => f p) (tprod fun b => tprod fun c => f { fst := b, snd := c })","decl":"@[to_additive tsum_prod]\ntheorem tprod_prod {f : Î² Ã— Î³ â†’ Î±} (h : Multipliable f) :\n    âˆ' p, f p = âˆ' (b) (c), f âŸ¨b, câŸ© :=\n  tprod_prod' h h.prod_factor\n\n"}
{"name":"tsum_comm","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœâ´ : AddCommGroup Î±\ninstâœÂ³ : UniformSpace Î±\ninstâœÂ² : UniformAddGroup Î±\ninstâœÂ¹ : CompleteSpace Î±\ninstâœ : T0Space Î±\nf : Î² â†’ Î³ â†’ Î±\nh : Summable (Function.uncurry f)\nâŠ¢ Eq (tsum fun c => tsum fun b => f b c) (tsum fun b => tsum fun c => f b c)","decl":"@[to_additive]\ntheorem tprod_comm {f : Î² â†’ Î³ â†’ Î±} (h : Multipliable (Function.uncurry f)) :\n    âˆ' (c) (b), f b c = âˆ' (b) (c), f b c :=\n  tprod_comm' h h.prod_factor h.prod_symm.prod_factor\n\n"}
{"name":"tprod_comm","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœâ´ : CommGroup Î±\ninstâœÂ³ : UniformSpace Î±\ninstâœÂ² : UniformGroup Î±\ninstâœÂ¹ : CompleteSpace Î±\ninstâœ : T0Space Î±\nf : Î² â†’ Î³ â†’ Î±\nh : Multipliable (Function.uncurry f)\nâŠ¢ Eq (tprod fun c => tprod fun b => f b c) (tprod fun b => tprod fun c => f b c)","decl":"@[to_additive]\ntheorem tprod_comm {f : Î² â†’ Î³ â†’ Î±} (h : Multipliable (Function.uncurry f)) :\n    âˆ' (c) (b), f b c = âˆ' (b) (c), f b c :=\n  tprod_comm' h h.prod_factor h.prod_symm.prod_factor\n\n"}
{"name":"Pi.hasProd","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_4\nÏ€ : Î± â†’ Type u_5\ninstâœÂ¹ : (x : Î±) â†’ CommMonoid (Ï€ x)\ninstâœ : (x : Î±) â†’ TopologicalSpace (Ï€ x)\nf : Î¹ â†’ (x : Î±) â†’ Ï€ x\ng : (x : Î±) â†’ Ï€ x\nâŠ¢ Iff (HasProd f g) (âˆ€ (x : Î±), HasProd (fun i => f i x) (g x))","decl":"@[to_additive]\ntheorem Pi.hasProd {f : Î¹ â†’ âˆ€ x, Ï€ x} {g : âˆ€ x, Ï€ x} :\n    HasProd f g â†” âˆ€ x, HasProd (fun i â†¦ f i x) (g x) := by\n  simp only [HasProd, tendsto_pi_nhds, prod_apply]\n\n"}
{"name":"Pi.hasSum","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_4\nÏ€ : Î± â†’ Type u_5\ninstâœÂ¹ : (x : Î±) â†’ AddCommMonoid (Ï€ x)\ninstâœ : (x : Î±) â†’ TopologicalSpace (Ï€ x)\nf : Î¹ â†’ (x : Î±) â†’ Ï€ x\ng : (x : Î±) â†’ Ï€ x\nâŠ¢ Iff (HasSum f g) (âˆ€ (x : Î±), HasSum (fun i => f i x) (g x))","decl":"@[to_additive]\ntheorem Pi.hasProd {f : Î¹ â†’ âˆ€ x, Ï€ x} {g : âˆ€ x, Ï€ x} :\n    HasProd f g â†” âˆ€ x, HasProd (fun i â†¦ f i x) (g x) := by\n  simp only [HasProd, tendsto_pi_nhds, prod_apply]\n\n"}
{"name":"Pi.summable","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_4\nÏ€ : Î± â†’ Type u_5\ninstâœÂ¹ : (x : Î±) â†’ AddCommMonoid (Ï€ x)\ninstâœ : (x : Î±) â†’ TopologicalSpace (Ï€ x)\nf : Î¹ â†’ (x : Î±) â†’ Ï€ x\nâŠ¢ Iff (Summable f) (âˆ€ (x : Î±), Summable fun i => f i x)","decl":"@[to_additive]\ntheorem Pi.multipliable {f : Î¹ â†’ âˆ€ x, Ï€ x} : Multipliable f â†” âˆ€ x, Multipliable fun i â†¦ f i x := by\n  simp only [Multipliable, Pi.hasProd, Classical.skolem]\n\n"}
{"name":"Pi.multipliable","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_4\nÏ€ : Î± â†’ Type u_5\ninstâœÂ¹ : (x : Î±) â†’ CommMonoid (Ï€ x)\ninstâœ : (x : Î±) â†’ TopologicalSpace (Ï€ x)\nf : Î¹ â†’ (x : Î±) â†’ Ï€ x\nâŠ¢ Iff (Multipliable f) (âˆ€ (x : Î±), Multipliable fun i => f i x)","decl":"@[to_additive]\ntheorem Pi.multipliable {f : Î¹ â†’ âˆ€ x, Ï€ x} : Multipliable f â†” âˆ€ x, Multipliable fun i â†¦ f i x := by\n  simp only [Multipliable, Pi.hasProd, Classical.skolem]\n\n"}
{"name":"tprod_apply","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_4\nÏ€ : Î± â†’ Type u_5\ninstâœÂ² : (x : Î±) â†’ CommMonoid (Ï€ x)\ninstâœÂ¹ : (x : Î±) â†’ TopologicalSpace (Ï€ x)\ninstâœ : âˆ€ (x : Î±), T2Space (Ï€ x)\nf : Î¹ â†’ (x : Î±) â†’ Ï€ x\nx : Î±\nhf : Multipliable f\nâŠ¢ Eq (tprod (fun i => f i) x) (tprod fun i => f i x)","decl":"@[to_additive]\ntheorem tprod_apply [âˆ€ x, T2Space (Ï€ x)] {f : Î¹ â†’ âˆ€ x, Ï€ x} {x : Î±} (hf : Multipliable f) :\n    (âˆ' i, f i) x = âˆ' i, f i x :=\n  (Pi.hasProd.mp hf.hasProd x).tprod_eq.symm\n\n"}
{"name":"tsum_apply","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_4\nÏ€ : Î± â†’ Type u_5\ninstâœÂ² : (x : Î±) â†’ AddCommMonoid (Ï€ x)\ninstâœÂ¹ : (x : Î±) â†’ TopologicalSpace (Ï€ x)\ninstâœ : âˆ€ (x : Î±), T2Space (Ï€ x)\nf : Î¹ â†’ (x : Î±) â†’ Ï€ x\nx : Î±\nhf : Summable f\nâŠ¢ Eq (tsum (fun i => f i) x) (tsum fun i => f i x)","decl":"@[to_additive]\ntheorem tprod_apply [âˆ€ x, T2Space (Ï€ x)] {f : Î¹ â†’ âˆ€ x, Ï€ x} {x : Î±} (hf : Multipliable f) :\n    (âˆ' i, f i) x = âˆ' i, f i x :=\n  (Pi.hasProd.mp hf.hasProd x).tprod_eq.symm\n\n"}
{"name":"HasSum.op","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : AddCommMonoid Î±\ninstâœ : TopologicalSpace Î±\nf : Î² â†’ Î±\na : Î±\nhf : HasSum f a\nâŠ¢ HasSum (fun a => MulOpposite.op (f a)) (MulOpposite.op a)","decl":"theorem HasSum.op (hf : HasSum f a) : HasSum (fun a â†¦ op (f a)) (op a) :=\n  (hf.map (@opAddEquiv Î± _) continuous_op :)\n\n"}
{"name":"Summable.op","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : AddCommMonoid Î±\ninstâœ : TopologicalSpace Î±\nf : Î² â†’ Î±\nhf : Summable f\nâŠ¢ Summable (Function.comp MulOpposite.op f)","decl":"theorem Summable.op (hf : Summable f) : Summable (op âˆ˜ f) :=\n  hf.hasSum.op.summable\n\n"}
{"name":"HasSum.unop","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : AddCommMonoid Î±\ninstâœ : TopologicalSpace Î±\nf : Î² â†’ MulOpposite Î±\na : MulOpposite Î±\nhf : HasSum f a\nâŠ¢ HasSum (fun a => MulOpposite.unop (f a)) (MulOpposite.unop a)","decl":"theorem HasSum.unop {f : Î² â†’ Î±áµáµ’áµ–} {a : Î±áµáµ’áµ–} (hf : HasSum f a) :\n    HasSum (fun a â†¦ unop (f a)) (unop a) :=\n  (hf.map (@opAddEquiv Î± _).symm continuous_unop :)\n\n"}
{"name":"Summable.unop","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : AddCommMonoid Î±\ninstâœ : TopologicalSpace Î±\nf : Î² â†’ MulOpposite Î±\nhf : Summable f\nâŠ¢ Summable (Function.comp MulOpposite.unop f)","decl":"theorem Summable.unop {f : Î² â†’ Î±áµáµ’áµ–} (hf : Summable f) : Summable (unop âˆ˜ f) :=\n  hf.hasSum.unop.summable\n\n"}
{"name":"hasSum_op","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : AddCommMonoid Î±\ninstâœ : TopologicalSpace Î±\nf : Î² â†’ Î±\na : Î±\nâŠ¢ Iff (HasSum (fun a => MulOpposite.op (f a)) (MulOpposite.op a)) (HasSum f a)","decl":"@[simp]\ntheorem hasSum_op : HasSum (fun a â†¦ op (f a)) (op a) â†” HasSum f a :=\n  âŸ¨HasSum.unop, HasSum.opâŸ©\n\n"}
{"name":"hasSum_unop","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : AddCommMonoid Î±\ninstâœ : TopologicalSpace Î±\nf : Î² â†’ MulOpposite Î±\na : MulOpposite Î±\nâŠ¢ Iff (HasSum (fun a => MulOpposite.unop (f a)) (MulOpposite.unop a)) (HasSum f a)","decl":"@[simp]\ntheorem hasSum_unop {f : Î² â†’ Î±áµáµ’áµ–} {a : Î±áµáµ’áµ–} :\n    HasSum (fun a â†¦ unop (f a)) (unop a) â†” HasSum f a :=\n  âŸ¨HasSum.op, HasSum.unopâŸ©\n\n"}
{"name":"summable_op","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : AddCommMonoid Î±\ninstâœ : TopologicalSpace Î±\nf : Î² â†’ Î±\nâŠ¢ Iff (Summable fun a => MulOpposite.op (f a)) (Summable f)","decl":"@[simp]\ntheorem summable_op : (Summable fun a â†¦ op (f a)) â†” Summable f :=\n  âŸ¨Summable.unop, Summable.opâŸ©\n\n-- Porting note: This theorem causes a loop easily in Lean 4, so the priority should be `low`.\n"}
{"name":"summable_unop","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : AddCommMonoid Î±\ninstâœ : TopologicalSpace Î±\nf : Î² â†’ MulOpposite Î±\nâŠ¢ Iff (Summable fun a => MulOpposite.unop (f a)) (Summable f)","decl":"@[simp low]\ntheorem summable_unop {f : Î² â†’ Î±áµáµ’áµ–} : (Summable fun a â†¦ unop (f a)) â†” Summable f :=\n  âŸ¨Summable.op, Summable.unopâŸ©\n\n"}
{"name":"tsum_op","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : AddCommMonoid Î±\ninstâœÂ¹ : TopologicalSpace Î±\nf : Î² â†’ Î±\ninstâœ : T2Space Î±\nâŠ¢ Eq (tsum fun x => MulOpposite.op (f x)) (MulOpposite.op (tsum fun x => f x))","decl":"theorem tsum_op [T2Space Î±] :\n    âˆ‘' x, op (f x) = op (âˆ‘' x, f x) := by\n  by_cases h : Summable f\n  Â· exact h.hasSum.op.tsum_eq\n  Â· have ho := summable_op.not.mpr h\n    rw [tsum_eq_zero_of_not_summable h, tsum_eq_zero_of_not_summable ho, op_zero]\n\n"}
{"name":"tsum_unop","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : AddCommMonoid Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : T2Space Î±\nf : Î² â†’ MulOpposite Î±\nâŠ¢ Eq (tsum fun x => MulOpposite.unop (f x)) (MulOpposite.unop (tsum fun x => f x))","decl":"theorem tsum_unop [T2Space Î±] {f : Î² â†’ Î±áµáµ’áµ–} :\n    âˆ‘' x, unop (f x) = unop (âˆ‘' x, f x) :=\n  op_injective tsum_op.symm\n\n"}
{"name":"HasSum.star","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : AddCommMonoid Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : StarAddMonoid Î±\ninstâœ : ContinuousStar Î±\nf : Î² â†’ Î±\na : Î±\nh : HasSum f a\nâŠ¢ HasSum (fun b => Star.star (f b)) (Star.star a)","decl":"theorem HasSum.star (h : HasSum f a) : HasSum (fun b â†¦ star (f b)) (star a) := by\n  simpa only using h.map (starAddEquiv : Î± â‰ƒ+ Î±) continuous_star\n\n"}
{"name":"Summable.star","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : AddCommMonoid Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : StarAddMonoid Î±\ninstâœ : ContinuousStar Î±\nf : Î² â†’ Î±\nhf : Summable f\nâŠ¢ Summable fun b => Star.star (f b)","decl":"theorem Summable.star (hf : Summable f) : Summable fun b â†¦ star (f b) :=\n  hf.hasSum.star.summable\n\n"}
{"name":"Summable.ofStar","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : AddCommMonoid Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : StarAddMonoid Î±\ninstâœ : ContinuousStar Î±\nf : Î² â†’ Î±\nhf : Summable fun b => Star.star (f b)\nâŠ¢ Summable f","decl":"theorem Summable.ofStar (hf : Summable fun b â†¦ Star.star (f b)) : Summable f := by\n  simpa only [star_star] using hf.star\n\n"}
{"name":"summable_star_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : AddCommMonoid Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : StarAddMonoid Î±\ninstâœ : ContinuousStar Î±\nf : Î² â†’ Î±\nâŠ¢ Iff (Summable fun b => Star.star (f b)) (Summable f)","decl":"@[simp]\ntheorem summable_star_iff : (Summable fun b â†¦ star (f b)) â†” Summable f :=\n  âŸ¨Summable.ofStar, Summable.starâŸ©\n\n"}
{"name":"summable_star_iff'","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : AddCommMonoid Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : StarAddMonoid Î±\ninstâœ : ContinuousStar Î±\nf : Î² â†’ Î±\nâŠ¢ Iff (Summable (Star.star f)) (Summable f)","decl":"@[simp]\ntheorem summable_star_iff' : Summable (star f) â†” Summable f :=\n  summable_star_iff\n\n"}
{"name":"tsum_star","module":"Mathlib.Topology.Algebra.InfiniteSum.Constructions","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ´ : AddCommMonoid Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : StarAddMonoid Î±\ninstâœÂ¹ : ContinuousStar Î±\nf : Î² â†’ Î±\ninstâœ : T2Space Î±\nâŠ¢ Eq (Star.star (tsum fun b => f b)) (tsum fun b => Star.star (f b))","decl":"theorem tsum_star [T2Space Î±] : star (âˆ‘' b, f b) = âˆ‘' b, star (f b) := by\n  by_cases hf : Summable f\n  Â· exact hf.hasSum.star.tsum_eq.symm\n  Â· rw [tsum_eq_zero_of_not_summable hf, tsum_eq_zero_of_not_summable (mt Summable.ofStar hf),\n      star_zero]\n\n"}
