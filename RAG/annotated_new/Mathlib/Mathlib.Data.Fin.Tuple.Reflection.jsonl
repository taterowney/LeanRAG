{"name":"FinVec.seq_eq","module":"Mathlib.Data.Fin.Tuple.Reflection","initialProofState":"α : Type u_1\nβ : Type u_2\nm : Nat\nf : Fin m → α → β\nv : Fin m → α\n⊢ Eq (FinVec.seq f v) fun i => f i (v i)","decl":"@[simp]\ntheorem seq_eq : ∀ {m} (f : Fin m → α → β) (v : Fin m → α), seq f v = fun i => f i (v i)\n  | 0, _, _ => Subsingleton.elim _ _\n  | n + 1, f, v =>\n    funext fun i => by\n      simp_rw [seq, seq_eq]\n      refine i.cases ?_ fun i => ?_\n      · rfl\n      · rw [Matrix.cons_val_succ]\n        rfl\n\n"}
{"name":"FinVec.map_eq","module":"Mathlib.Data.Fin.Tuple.Reflection","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nm : Nat\nv : Fin m → α\n⊢ Eq (FinVec.map f v) (Function.comp f v)","decl":"/-- This can be used to prove\n```lean\nexample {f : α → β} (a₁ a₂ : α) : f ∘ ![a₁, a₂] = ![f a₁, f a₂] :=\n  (map_eq _ _).symm\n```\n-/\n@[simp]\ntheorem map_eq (f : α → β) {m} (v : Fin m → α) : map f v = f ∘ v :=\n  seq_eq _ _\n\n"}
{"name":"FinVec.etaExpand_eq","module":"Mathlib.Data.Fin.Tuple.Reflection","initialProofState":"α : Type u_1\nm : Nat\nv : Fin m → α\n⊢ Eq (FinVec.etaExpand v) v","decl":"/-- This can be used to prove\n```lean\nexample (a : Fin 2 → α) : a = ![a 0, a 1] :=\n  (etaExpand_eq _).symm\n```\n-/\n@[simp]\ntheorem etaExpand_eq {m} (v : Fin m → α) : etaExpand v = v :=\n  map_eq id v\n\n"}
{"name":"FinVec.forall_iff","module":"Mathlib.Data.Fin.Tuple.Reflection","initialProofState":"α : Type u_1\nm : Nat\nP : (Fin m → α) → Prop\n⊢ Iff (FinVec.Forall P) (∀ (x : Fin m → α), P x)","decl":"/-- This can be used to prove\n```lean\nexample (P : (Fin 2 → α) → Prop) : (∀ f, P f) ↔ ∀ a₀ a₁, P ![a₀, a₁] :=\n  (forall_iff _).symm\n```\n-/\n@[simp]\ntheorem forall_iff : ∀ {m} (P : (Fin m → α) → Prop), Forall P ↔ ∀ x, P x\n  | 0, P => by\n    simp only [Forall, Fin.forall_fin_zero_pi]\n    rfl\n  | .succ n, P => by simp only [Forall, forall_iff, Fin.forall_fin_succ_pi, Matrix.vecCons]\n\n"}
{"name":"FinVec.exists_iff","module":"Mathlib.Data.Fin.Tuple.Reflection","initialProofState":"α : Type u_1\nm : Nat\nP : (Fin m → α) → Prop\n⊢ Iff (FinVec.Exists P) (Exists fun x => P x)","decl":"/-- This can be used to prove\n```lean\nexample (P : (Fin 2 → α) → Prop) : (∃ f, P f) ↔ ∃ a₀ a₁, P ![a₀, a₁] :=\n  (exists_iff _).symm\n```\n-/\ntheorem exists_iff : ∀ {m} (P : (Fin m → α) → Prop), Exists P ↔ ∃ x, P x\n  | 0, P => by\n    simp only [Exists, Fin.exists_fin_zero_pi, Matrix.vecEmpty]\n    rfl\n  | .succ n, P => by simp only [Exists, exists_iff, Fin.exists_fin_succ_pi, Matrix.vecCons]\n\n"}
{"name":"FinVec.sum_eq","module":"Mathlib.Data.Fin.Tuple.Reflection","initialProofState":"α : Type u_1\ninst✝ : AddCommMonoid α\nm : Nat\na : Fin m → α\n⊢ Eq (FinVec.sum a) (Finset.univ.sum fun i => a i)","decl":"/-- This can be used to prove\n```lean\nexample [AddCommMonoid α] (a : Fin 3 → α) : ∑ i, a i = a 0 + a 1 + a 2 :=\n  (sum_eq _).symm\n```\n-/\n@[simp]\ntheorem sum_eq [AddCommMonoid α] : ∀ {m} (a : Fin m → α), sum a = ∑ i, a i\n  | 0, _ => rfl\n  | 1, a => (Fintype.sum_unique a).symm\n  | n + 2, a => by rw [Fin.sum_univ_castSucc, sum, sum_eq]\n\n"}
