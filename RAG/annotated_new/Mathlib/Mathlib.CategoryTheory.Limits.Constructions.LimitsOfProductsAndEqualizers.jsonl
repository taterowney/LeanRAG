{"name":"CategoryTheory.Limits.HasLimitOfHasProductsOfHasEqualizers.buildLimit_π_app","module":"Mathlib.CategoryTheory.Limits.Constructions.LimitsOfProductsAndEqualizers","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J C\nc₁ : CategoryTheory.Limits.Fan F.obj\nc₂ : CategoryTheory.Limits.Fan fun f => F.obj f.fst.2\ns t : Quiver.Hom c₁.pt c₂.pt\nhs : ∀ (f : Sigma fun p => Quiver.Hom p.1 p.2), Eq (CategoryTheory.CategoryStruct.comp s (c₂.π.app { as := f })) (CategoryTheory.CategoryStruct.comp (c₁.π.app { as := f.fst.1 }) (F.map f.snd))\nht : ∀ (f : Sigma fun p => Quiver.Hom p.1 p.2), Eq (CategoryTheory.CategoryStruct.comp t (c₂.π.app { as := f })) (c₁.π.app { as := f.fst.2 })\ni : CategoryTheory.Limits.Fork s t\nx✝ : J\n⊢ Eq ((CategoryTheory.Limits.HasLimitOfHasProductsOfHasEqualizers.buildLimit s t hs ht i).π.app x✝) (CategoryTheory.CategoryStruct.comp i.ι (c₁.π.app { as := x✝ }))","decl":"/--\n(Implementation) Given the appropriate product and equalizer cones, build the cone for `F` which is\nlimiting if the given cones are also.\n-/\n@[simps]\ndef buildLimit\n    (hs : ∀ f : Σp : J × J, p.1 ⟶ p.2, s ≫ c₂.π.app ⟨f⟩ = c₁.π.app ⟨f.1.1⟩ ≫ F.map f.2)\n    (ht : ∀ f : Σp : J × J, p.1 ⟶ p.2, t ≫ c₂.π.app ⟨f⟩ = c₁.π.app ⟨f.1.2⟩)\n    (i : Fork s t) : Cone F where\n  pt := i.pt\n  π :=\n    { app := fun _ => i.ι ≫ c₁.π.app ⟨_⟩\n      naturality := fun j₁ j₂ f => by\n        dsimp\n        rw [Category.id_comp, Category.assoc, ← hs ⟨⟨_, _⟩, f⟩, i.condition_assoc, ht] }\n\n"}
{"name":"CategoryTheory.Limits.HasLimitOfHasProductsOfHasEqualizers.buildLimit_pt","module":"Mathlib.CategoryTheory.Limits.Constructions.LimitsOfProductsAndEqualizers","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J C\nc₁ : CategoryTheory.Limits.Fan F.obj\nc₂ : CategoryTheory.Limits.Fan fun f => F.obj f.fst.2\ns t : Quiver.Hom c₁.pt c₂.pt\nhs : ∀ (f : Sigma fun p => Quiver.Hom p.1 p.2), Eq (CategoryTheory.CategoryStruct.comp s (c₂.π.app { as := f })) (CategoryTheory.CategoryStruct.comp (c₁.π.app { as := f.fst.1 }) (F.map f.snd))\nht : ∀ (f : Sigma fun p => Quiver.Hom p.1 p.2), Eq (CategoryTheory.CategoryStruct.comp t (c₂.π.app { as := f })) (c₁.π.app { as := f.fst.2 })\ni : CategoryTheory.Limits.Fork s t\n⊢ Eq (CategoryTheory.Limits.HasLimitOfHasProductsOfHasEqualizers.buildLimit s t hs ht i).pt i.pt","decl":"/--\n(Implementation) Given the appropriate product and equalizer cones, build the cone for `F` which is\nlimiting if the given cones are also.\n-/\n@[simps]\ndef buildLimit\n    (hs : ∀ f : Σp : J × J, p.1 ⟶ p.2, s ≫ c₂.π.app ⟨f⟩ = c₁.π.app ⟨f.1.1⟩ ≫ F.map f.2)\n    (ht : ∀ f : Σp : J × J, p.1 ⟶ p.2, t ≫ c₂.π.app ⟨f⟩ = c₁.π.app ⟨f.1.2⟩)\n    (i : Fork s t) : Cone F where\n  pt := i.pt\n  π :=\n    { app := fun _ => i.ι ≫ c₁.π.app ⟨_⟩\n      naturality := fun j₁ j₂ f => by\n        dsimp\n        rw [Category.id_comp, Category.assoc, ← hs ⟨⟨_, _⟩, f⟩, i.condition_assoc, ht] }\n\n"}
{"name":"CategoryTheory.Limits.hasLimit_of_equalizer_and_product","module":"Mathlib.CategoryTheory.Limits.Constructions.LimitsOfProductsAndEqualizers","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝³ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J C\ninst✝² : CategoryTheory.Limits.HasLimit (CategoryTheory.Discrete.functor F.obj)\ninst✝¹ : CategoryTheory.Limits.HasLimit (CategoryTheory.Discrete.functor fun f => F.obj f.fst.2)\ninst✝ : CategoryTheory.Limits.HasEqualizers C\n⊢ CategoryTheory.Limits.HasLimit F","decl":"/--\nGiven the existence of the appropriate (possibly finite) products and equalizers, we know a limit of\n`F` exists.\n(This assumes the existence of all equalizers, which is technically stronger than needed.)\n-/\ntheorem hasLimit_of_equalizer_and_product (F : J ⥤ C) [HasLimit (Discrete.functor F.obj)]\n    [HasLimit (Discrete.functor fun f : Σp : J × J, p.1 ⟶ p.2 => F.obj f.1.2)] [HasEqualizers C] :\n    HasLimit F :=\n  HasLimit.mk (limitConeOfEqualizerAndProduct F)\n\n"}
{"name":"CategoryTheory.Limits.limitSubobjectProduct_mono","module":"Mathlib.CategoryTheory.Limits.Constructions.LimitsOfProductsAndEqualizers","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.Limits.HasLimitsOfSize.{w, w, v, u} C\nF : CategoryTheory.Functor J C\n⊢ CategoryTheory.Mono (CategoryTheory.Limits.limitSubobjectProduct F)","decl":"instance limitSubobjectProduct_mono [HasLimitsOfSize.{w, w} C] (F : J ⥤ C) :\n    Mono (limitSubobjectProduct F) :=\n  mono_comp _ _\n\n"}
{"name":"CategoryTheory.Limits.has_limits_of_hasEqualizers_and_products","module":"Mathlib.CategoryTheory.Limits.Constructions.LimitsOfProductsAndEqualizers","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasProducts C\ninst✝ : CategoryTheory.Limits.HasEqualizers C\n⊢ CategoryTheory.Limits.HasLimitsOfSize.{w, w, v, u} C","decl":"/-- Any category with products and equalizers has all limits. -/\n@[stacks 002N]\ntheorem has_limits_of_hasEqualizers_and_products [HasProducts.{w} C] [HasEqualizers C] :\n    HasLimitsOfSize.{w, w} C :=\n  { has_limits_of_shape :=\n    fun _ _ => { has_limit := fun F => hasLimit_of_equalizer_and_product F } }\n\n"}
{"name":"CategoryTheory.Limits.hasFiniteLimits_of_hasEqualizers_and_finite_products","module":"Mathlib.CategoryTheory.Limits.Constructions.LimitsOfProductsAndEqualizers","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasEqualizers C\n⊢ CategoryTheory.Limits.HasFiniteLimits C","decl":"/-- Any category with finite products and equalizers has all finite limits. -/\n@[stacks 002O]\ntheorem hasFiniteLimits_of_hasEqualizers_and_finite_products [HasFiniteProducts C]\n    [HasEqualizers C] : HasFiniteLimits C where\n  out _ := { has_limit := fun F => hasLimit_of_equalizer_and_product F }\n\n"}
{"name":"CategoryTheory.Limits.preservesLimit_of_preservesEqualizers_and_product","module":"Mathlib.CategoryTheory.Limits.Constructions.LimitsOfProductsAndEqualizers","initialProofState":"C : Type u\ninst✝⁸ : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝⁷ : CategoryTheory.SmallCategory J\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁵ : CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete J) C\ninst✝⁴ : CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete (Sigma fun p => Quiver.Hom p.1 p.2)) C\ninst✝³ : CategoryTheory.Limits.HasEqualizers C\nG : CategoryTheory.Functor C D\ninst✝² : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingParallelPair G\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete J) G\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete (Sigma fun p => Quiver.Hom p.1 p.2)) G\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J G","decl":"/-- If a functor preserves equalizers and the appropriate products, it preserves limits. -/\nlemma preservesLimit_of_preservesEqualizers_and_product :\n    PreservesLimitsOfShape J G where\n  preservesLimit {K} := by\n    let P := ∏ᶜ K.obj\n    let Q := ∏ᶜ fun f : Σp : J × J, p.fst ⟶ p.snd => K.obj f.1.2\n    let s : P ⟶ Q := Pi.lift fun f => limit.π (Discrete.functor K.obj) ⟨_⟩ ≫ K.map f.2\n    let t : P ⟶ Q := Pi.lift fun f => limit.π (Discrete.functor K.obj) ⟨f.1.2⟩\n    let I := equalizer s t\n    let i : I ⟶ P := equalizer.ι s t\n    apply preservesLimit_of_preserves_limit_cone\n        (buildIsLimit s t (by simp [P, s]) (by simp [P, t]) (limit.isLimit _)\n          (limit.isLimit _) (limit.isLimit _))\n    apply IsLimit.ofIsoLimit (buildIsLimit _ _ _ _ _ _ _) _\n    · exact Fan.mk _ fun j => G.map (Pi.π _ j)\n    · exact Fan.mk (G.obj Q) fun f => G.map (Pi.π _ f)\n    · apply G.map s\n    · apply G.map t\n    · intro f\n      dsimp [P, Q, s, Fan.mk]\n      simp only [← G.map_comp, limit.lift_π]\n      congr\n    · intro f\n      dsimp [P, Q, t, Fan.mk]\n      simp only [← G.map_comp, limit.lift_π]\n      apply congrArg G.map\n      dsimp\n    · apply Fork.ofι (G.map i)\n      rw [← G.map_comp, ← G.map_comp]\n      apply congrArg G.map\n      exact equalizer.condition s t\n    · apply isLimitOfHasProductOfPreservesLimit\n    · apply isLimitOfHasProductOfPreservesLimit\n    · apply isLimitForkMapOfIsLimit\n      apply equalizerIsEqualizer\n    · refine Cones.ext (Iso.refl _) ?_\n      intro j; dsimp [P, Q, I, i]; simp\n-- See note [dsimp, simp].\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteLimits_of_preservesEqualizers_and_finiteProducts","module":"Mathlib.CategoryTheory.Limits.Constructions.LimitsOfProductsAndEqualizers","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasEqualizers C\ninst✝² : CategoryTheory.Limits.HasFiniteProducts C\nG : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingParallelPair G\ninst✝ : CategoryTheory.Limits.PreservesFiniteProducts G\n⊢ CategoryTheory.Limits.PreservesFiniteLimits G","decl":"/-- If G preserves equalizers and finite products, it preserves finite limits. -/\nlemma preservesFiniteLimits_of_preservesEqualizers_and_finiteProducts [HasEqualizers C]\n    [HasFiniteProducts C] (G : C ⥤ D) [PreservesLimitsOfShape WalkingParallelPair G]\n    [PreservesFiniteProducts G] : PreservesFiniteLimits G where\n  preservesFiniteLimits := by\n    intro J sJ fJ\n    haveI : Fintype J := inferInstance\n    haveI : Fintype ((p : J × J) × (p.fst ⟶ p.snd)) := inferInstance\n    apply @preservesLimit_of_preservesEqualizers_and_product _ _ _ sJ _ _ ?_ ?_ _ G _ ?_ ?_\n    · apply hasLimitsOfShape_discrete _ _\n    · apply hasLimitsOfShape_discrete _\n    · apply PreservesFiniteProducts.preserves _\n    · apply PreservesFiniteProducts.preserves _\n\n"}
{"name":"CategoryTheory.Limits.preservesLimits_of_preservesEqualizers_and_products","module":"Mathlib.CategoryTheory.Limits.Constructions.LimitsOfProductsAndEqualizers","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasEqualizers C\ninst✝² : CategoryTheory.Limits.HasProducts C\nG : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingParallelPair G\ninst✝ : ∀ (J : Type w), CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete J) G\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, w, v, v₂, u, u₂} G","decl":"/-- If G preserves equalizers and products, it preserves all limits. -/\nlemma preservesLimits_of_preservesEqualizers_and_products [HasEqualizers C]\n    [HasProducts.{w} C] (G : C ⥤ D) [PreservesLimitsOfShape WalkingParallelPair G]\n    [∀ J, PreservesLimitsOfShape (Discrete.{w} J) G] : PreservesLimitsOfSize.{w, w} G where\n  preservesLimitsOfShape := preservesLimit_of_preservesEqualizers_and_product G\n\n"}
{"name":"CategoryTheory.Limits.hasFiniteLimits_of_hasTerminal_and_pullbacks","module":"Mathlib.CategoryTheory.Limits.Constructions.LimitsOfProductsAndEqualizers","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\n⊢ CategoryTheory.Limits.HasFiniteLimits C","decl":"theorem hasFiniteLimits_of_hasTerminal_and_pullbacks [HasTerminal C] [HasPullbacks C] :\n    HasFiniteLimits C :=\n  @hasFiniteLimits_of_hasEqualizers_and_finite_products C _\n    (@hasFiniteProducts_of_has_binary_and_terminal C _\n      (hasBinaryProducts_of_hasTerminal_and_pullbacks C) inferInstance)\n    (@hasEqualizers_of_hasPullbacks_and_binary_products C _\n      (hasBinaryProducts_of_hasTerminal_and_pullbacks C) inferInstance)\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteLimits_of_preservesTerminal_and_pullbacks","module":"Mathlib.CategoryTheory.Limits.Constructions.LimitsOfProductsAndEqualizers","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasTerminal C\ninst✝² : CategoryTheory.Limits.HasPullbacks C\nG : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) G\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingCospan G\n⊢ CategoryTheory.Limits.PreservesFiniteLimits G","decl":"/-- If G preserves terminal objects and pullbacks, it preserves all finite limits. -/\nlemma preservesFiniteLimits_of_preservesTerminal_and_pullbacks [HasTerminal C]\n    [HasPullbacks C] (G : C ⥤ D) [PreservesLimitsOfShape (Discrete.{0} PEmpty) G]\n    [PreservesLimitsOfShape WalkingCospan G] : PreservesFiniteLimits G := by\n  haveI : HasFiniteLimits C := hasFiniteLimits_of_hasTerminal_and_pullbacks\n  haveI : PreservesLimitsOfShape (Discrete WalkingPair) G :=\n    preservesBinaryProducts_of_preservesTerminal_and_pullbacks G\n  haveI : PreservesLimitsOfShape WalkingParallelPair G :=\n      preservesEqualizers_of_preservesPullbacks_and_binaryProducts G\n  apply\n    @preservesFiniteLimits_of_preservesEqualizers_and_finiteProducts _ _ _ _ _ _ G _ ?_\n  apply PreservesFiniteProducts.mk\n  apply preservesFiniteProducts_of_preserves_binary_and_terminal G\n\n"}
{"name":"CategoryTheory.Limits.HasColimitOfHasCoproductsOfHasCoequalizers.buildColimit_pt","module":"Mathlib.CategoryTheory.Limits.Constructions.LimitsOfProductsAndEqualizers","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J C\nc₁ : CategoryTheory.Limits.Cofan fun f => F.obj f.fst.1\nc₂ : CategoryTheory.Limits.Cofan F.obj\ns t : Quiver.Hom c₁.pt c₂.pt\nhs : ∀ (f : Sigma fun p => Quiver.Hom p.1 p.2), Eq (CategoryTheory.CategoryStruct.comp (c₁.ι.app { as := f }) s) (CategoryTheory.CategoryStruct.comp (F.map f.snd) (c₂.ι.app { as := f.fst.2 }))\nht : ∀ (f : Sigma fun p => Quiver.Hom p.1 p.2), Eq (CategoryTheory.CategoryStruct.comp (c₁.ι.app { as := f }) t) (c₂.ι.app { as := f.fst.1 })\ni : CategoryTheory.Limits.Cofork s t\n⊢ Eq (CategoryTheory.Limits.HasColimitOfHasCoproductsOfHasCoequalizers.buildColimit s t hs ht i).pt i.pt","decl":"/-- (Implementation) Given the appropriate coproduct and coequalizer cocones,\nbuild the cocone for `F` which is colimiting if the given cocones are also.\n-/\n@[simps]\ndef buildColimit\n    (hs : ∀ f : Σp : J × J, p.1 ⟶ p.2, c₁.ι.app ⟨f⟩ ≫ s = F.map f.2 ≫ c₂.ι.app ⟨f.1.2⟩)\n    (ht : ∀ f : Σp : J × J, p.1 ⟶ p.2, c₁.ι.app ⟨f⟩ ≫ t = c₂.ι.app ⟨f.1.1⟩)\n    (i : Cofork s t) : Cocone F where\n  pt := i.pt\n  ι :=\n    { app := fun _ => c₂.ι.app ⟨_⟩ ≫ i.π\n      naturality := fun j₁ j₂ f => by\n        dsimp\n        have reassoced (f : (p : J × J) × (p.fst ⟶ p.snd)) {W : C} {h : _ ⟶ W} :\n          c₁.ι.app ⟨f⟩ ≫ s ≫ h = F.map f.snd ≫ c₂.ι.app ⟨f.fst.snd⟩ ≫ h := by\n            simp only [← Category.assoc, eq_whisker (hs f)]\n        rw [Category.comp_id, ← reassoced ⟨⟨_, _⟩, f⟩, i.condition, ← Category.assoc, ht] }\n\n"}
{"name":"CategoryTheory.Limits.HasColimitOfHasCoproductsOfHasCoequalizers.buildColimit_ι_app","module":"Mathlib.CategoryTheory.Limits.Constructions.LimitsOfProductsAndEqualizers","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J C\nc₁ : CategoryTheory.Limits.Cofan fun f => F.obj f.fst.1\nc₂ : CategoryTheory.Limits.Cofan F.obj\ns t : Quiver.Hom c₁.pt c₂.pt\nhs : ∀ (f : Sigma fun p => Quiver.Hom p.1 p.2), Eq (CategoryTheory.CategoryStruct.comp (c₁.ι.app { as := f }) s) (CategoryTheory.CategoryStruct.comp (F.map f.snd) (c₂.ι.app { as := f.fst.2 }))\nht : ∀ (f : Sigma fun p => Quiver.Hom p.1 p.2), Eq (CategoryTheory.CategoryStruct.comp (c₁.ι.app { as := f }) t) (c₂.ι.app { as := f.fst.1 })\ni : CategoryTheory.Limits.Cofork s t\nx✝ : J\n⊢ Eq ((CategoryTheory.Limits.HasColimitOfHasCoproductsOfHasCoequalizers.buildColimit s t hs ht i).ι.app x✝) (CategoryTheory.CategoryStruct.comp (c₂.ι.app { as := x✝ }) i.π)","decl":"/-- (Implementation) Given the appropriate coproduct and coequalizer cocones,\nbuild the cocone for `F` which is colimiting if the given cocones are also.\n-/\n@[simps]\ndef buildColimit\n    (hs : ∀ f : Σp : J × J, p.1 ⟶ p.2, c₁.ι.app ⟨f⟩ ≫ s = F.map f.2 ≫ c₂.ι.app ⟨f.1.2⟩)\n    (ht : ∀ f : Σp : J × J, p.1 ⟶ p.2, c₁.ι.app ⟨f⟩ ≫ t = c₂.ι.app ⟨f.1.1⟩)\n    (i : Cofork s t) : Cocone F where\n  pt := i.pt\n  ι :=\n    { app := fun _ => c₂.ι.app ⟨_⟩ ≫ i.π\n      naturality := fun j₁ j₂ f => by\n        dsimp\n        have reassoced (f : (p : J × J) × (p.fst ⟶ p.snd)) {W : C} {h : _ ⟶ W} :\n          c₁.ι.app ⟨f⟩ ≫ s ≫ h = F.map f.snd ≫ c₂.ι.app ⟨f.fst.snd⟩ ≫ h := by\n            simp only [← Category.assoc, eq_whisker (hs f)]\n        rw [Category.comp_id, ← reassoced ⟨⟨_, _⟩, f⟩, i.condition, ← Category.assoc, ht] }\n\n"}
{"name":"CategoryTheory.Limits.hasColimit_of_coequalizer_and_coproduct","module":"Mathlib.CategoryTheory.Limits.Constructions.LimitsOfProductsAndEqualizers","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝³ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J C\ninst✝² : CategoryTheory.Limits.HasColimit (CategoryTheory.Discrete.functor F.obj)\ninst✝¹ : CategoryTheory.Limits.HasColimit (CategoryTheory.Discrete.functor fun f => F.obj f.fst.1)\ninst✝ : CategoryTheory.Limits.HasCoequalizers C\n⊢ CategoryTheory.Limits.HasColimit F","decl":"/-- Given the existence of the appropriate (possibly finite) coproducts and coequalizers,\nwe know a colimit of `F` exists.\n(This assumes the existence of all coequalizers, which is technically stronger than needed.)\n-/\ntheorem hasColimit_of_coequalizer_and_coproduct (F : J ⥤ C) [HasColimit (Discrete.functor F.obj)]\n    [HasColimit (Discrete.functor fun f : Σp : J × J, p.1 ⟶ p.2 => F.obj f.1.1)]\n    [HasCoequalizers C] : HasColimit F :=\n  HasColimit.mk (colimitCoconeOfCoequalizerAndCoproduct F)\n\n"}
{"name":"CategoryTheory.Limits.colimitQuotientCoproduct_epi","module":"Mathlib.CategoryTheory.Limits.Constructions.LimitsOfProductsAndEqualizers","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.Limits.HasColimitsOfSize.{w, w, v, u} C\nF : CategoryTheory.Functor J C\n⊢ CategoryTheory.Epi (CategoryTheory.Limits.colimitQuotientCoproduct F)","decl":"instance colimitQuotientCoproduct_epi [HasColimitsOfSize.{w, w} C] (F : J ⥤ C) :\n    Epi (colimitQuotientCoproduct F) :=\n  epi_comp _ _\n\n"}
{"name":"CategoryTheory.Limits.has_colimits_of_hasCoequalizers_and_coproducts","module":"Mathlib.CategoryTheory.Limits.Constructions.LimitsOfProductsAndEqualizers","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasCoproducts C\ninst✝ : CategoryTheory.Limits.HasCoequalizers C\n⊢ CategoryTheory.Limits.HasColimitsOfSize.{w, w, v, u} C","decl":"/-- Any category with coproducts and coequalizers has all colimits. -/\n@[stacks 002P]\ntheorem has_colimits_of_hasCoequalizers_and_coproducts [HasCoproducts.{w} C] [HasCoequalizers C] :\n    HasColimitsOfSize.{w, w} C where\n  has_colimits_of_shape := fun _ _ =>\n      { has_colimit := fun F => hasColimit_of_coequalizer_and_coproduct F }\n\n"}
{"name":"CategoryTheory.Limits.hasFiniteColimits_of_hasCoequalizers_and_finite_coproducts","module":"Mathlib.CategoryTheory.Limits.Constructions.LimitsOfProductsAndEqualizers","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteCoproducts C\ninst✝ : CategoryTheory.Limits.HasCoequalizers C\n⊢ CategoryTheory.Limits.HasFiniteColimits C","decl":"/-- Any category with finite coproducts and coequalizers has all finite colimits. -/\n@[stacks 002Q]\ntheorem hasFiniteColimits_of_hasCoequalizers_and_finite_coproducts [HasFiniteCoproducts C]\n    [HasCoequalizers C] : HasFiniteColimits C where\n  out _ := { has_colimit := fun F => hasColimit_of_coequalizer_and_coproduct F }\n\n-- Porting note: removed and added individually\n-- noncomputable section\n"}
{"name":"CategoryTheory.Limits.preservesColimit_of_preservesCoequalizers_and_coproduct","module":"Mathlib.CategoryTheory.Limits.Constructions.LimitsOfProductsAndEqualizers","initialProofState":"C : Type u\ninst✝⁸ : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝⁷ : CategoryTheory.SmallCategory J\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁵ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete J) C\ninst✝⁴ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (Sigma fun p => Quiver.Hom p.1 p.2)) C\ninst✝³ : CategoryTheory.Limits.HasCoequalizers C\nG : CategoryTheory.Functor C D\ninst✝² : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingParallelPair G\ninst✝¹ : CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete J) G\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete (Sigma fun p => Quiver.Hom p.1 p.2)) G\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape J G","decl":"/-- If a functor preserves coequalizers and the appropriate coproducts, it preserves colimits. -/\nlemma preservesColimit_of_preservesCoequalizers_and_coproduct :\n    PreservesColimitsOfShape J G where\n  preservesColimit {K} := by\n    let P := ∐ K.obj\n    let Q := ∐ fun f : Σp : J × J, p.fst ⟶ p.snd => K.obj f.1.1\n    let s : Q ⟶ P := Sigma.desc fun f => K.map f.2 ≫ colimit.ι (Discrete.functor K.obj) ⟨_⟩\n    let t : Q ⟶ P := Sigma.desc fun f => colimit.ι (Discrete.functor K.obj) ⟨f.1.1⟩\n    let I := coequalizer s t\n    let i : P ⟶ I := coequalizer.π s t\n    apply preservesColimit_of_preserves_colimit_cocone\n        (buildIsColimit s t (by simp [P, s]) (by simp [P, t]) (colimit.isColimit _)\n          (colimit.isColimit _) (colimit.isColimit _))\n    apply IsColimit.ofIsoColimit (buildIsColimit _ _ _ _ _ _ _) _\n    · refine Cofan.mk (G.obj Q) fun j => G.map ?_\n      apply Sigma.ι _ j\n    -- fun j => G.map (Sigma.ι _ j)\n    · exact Cofan.mk _ fun f => G.map (Sigma.ι _ f)\n    · apply G.map s\n    · apply G.map t\n    · intro f\n      dsimp [P, Q, s, Cofan.mk]\n      simp only [← G.map_comp, colimit.ι_desc]\n      congr\n    · intro f\n      dsimp [P, Q, t, Cofan.mk]\n      simp only [← G.map_comp, colimit.ι_desc]\n      dsimp\n    · refine Cofork.ofπ (G.map i) ?_\n      rw [← G.map_comp, ← G.map_comp]\n      apply congrArg G.map\n      apply coequalizer.condition\n    · apply isColimitOfHasCoproductOfPreservesColimit\n    · apply isColimitOfHasCoproductOfPreservesColimit\n    · apply isColimitCoforkMapOfIsColimit\n      apply coequalizerIsCoequalizer\n    refine Cocones.ext (Iso.refl _) ?_\n    intro j\n    dsimp [P, Q, I, i]\n    simp\n-- See note [dsimp, simp].\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteColimits_of_preservesCoequalizers_and_finiteCoproducts","module":"Mathlib.CategoryTheory.Limits.Constructions.LimitsOfProductsAndEqualizers","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasCoequalizers C\ninst✝² : CategoryTheory.Limits.HasFiniteCoproducts C\nG : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingParallelPair G\ninst✝ : CategoryTheory.Limits.PreservesFiniteCoproducts G\n⊢ CategoryTheory.Limits.PreservesFiniteColimits G","decl":"/-- If G preserves coequalizers and finite coproducts, it preserves finite colimits. -/\nlemma preservesFiniteColimits_of_preservesCoequalizers_and_finiteCoproducts\n    [HasCoequalizers C] [HasFiniteCoproducts C] (G : C ⥤ D)\n    [PreservesColimitsOfShape WalkingParallelPair G]\n    [PreservesFiniteCoproducts G] : PreservesFiniteColimits G where\n  preservesFiniteColimits := by\n    intro J sJ fJ\n    haveI : Fintype J := inferInstance\n    haveI : Fintype ((p : J × J) × (p.fst ⟶ p.snd)) := inferInstance\n    apply @preservesColimit_of_preservesCoequalizers_and_coproduct _ _ _ sJ _ _ ?_ ?_ _ G _ ?_ ?_\n    · apply hasColimitsOfShape_discrete _ _\n    · apply hasColimitsOfShape_discrete _\n    · apply PreservesFiniteCoproducts.preserves _\n    · apply PreservesFiniteCoproducts.preserves _\n\n"}
{"name":"CategoryTheory.Limits.preservesColimits_of_preservesCoequalizers_and_coproducts","module":"Mathlib.CategoryTheory.Limits.Constructions.LimitsOfProductsAndEqualizers","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasCoequalizers C\ninst✝² : CategoryTheory.Limits.HasCoproducts C\nG : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingParallelPair G\ninst✝ : ∀ (J : Type w), CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete J) G\n⊢ CategoryTheory.Limits.PreservesColimitsOfSize.{w, w, v, v₂, u, u₂} G","decl":"/-- If G preserves coequalizers and coproducts, it preserves all colimits. -/\nlemma preservesColimits_of_preservesCoequalizers_and_coproducts [HasCoequalizers C]\n    [HasCoproducts.{w} C] (G : C ⥤ D) [PreservesColimitsOfShape WalkingParallelPair G]\n    [∀ J, PreservesColimitsOfShape (Discrete.{w} J) G] : PreservesColimitsOfSize.{w, w} G where\n  preservesColimitsOfShape := preservesColimit_of_preservesCoequalizers_and_coproduct G\n\n"}
{"name":"CategoryTheory.Limits.hasFiniteColimits_of_hasInitial_and_pushouts","module":"Mathlib.CategoryTheory.Limits.Constructions.LimitsOfProductsAndEqualizers","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasInitial C\ninst✝ : CategoryTheory.Limits.HasPushouts C\n⊢ CategoryTheory.Limits.HasFiniteColimits C","decl":"theorem hasFiniteColimits_of_hasInitial_and_pushouts [HasInitial C] [HasPushouts C] :\n    HasFiniteColimits C :=\n  @hasFiniteColimits_of_hasCoequalizers_and_finite_coproducts C _\n    (@hasFiniteCoproducts_of_has_binary_and_initial C _\n      (hasBinaryCoproducts_of_hasInitial_and_pushouts C) inferInstance)\n    (@hasCoequalizers_of_hasPushouts_and_binary_coproducts C _\n      (hasBinaryCoproducts_of_hasInitial_and_pushouts C) inferInstance)\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteColimits_of_preservesInitial_and_pushouts","module":"Mathlib.CategoryTheory.Limits.Constructions.LimitsOfProductsAndEqualizers","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasInitial C\ninst✝² : CategoryTheory.Limits.HasPushouts C\nG : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) G\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingSpan G\n⊢ CategoryTheory.Limits.PreservesFiniteColimits G","decl":"/-- If G preserves initial objects and pushouts, it preserves all finite colimits. -/\nlemma preservesFiniteColimits_of_preservesInitial_and_pushouts [HasInitial C]\n    [HasPushouts C] (G : C ⥤ D) [PreservesColimitsOfShape (Discrete.{0} PEmpty) G]\n    [PreservesColimitsOfShape WalkingSpan G] : PreservesFiniteColimits G := by\n  haveI : HasFiniteColimits C := hasFiniteColimits_of_hasInitial_and_pushouts\n  haveI : PreservesColimitsOfShape (Discrete WalkingPair) G :=\n    preservesBinaryCoproducts_of_preservesInitial_and_pushouts G\n  haveI : PreservesColimitsOfShape (WalkingParallelPair) G :=\n      (preservesCoequalizers_of_preservesPushouts_and_binaryCoproducts G)\n  refine\n    @preservesFiniteColimits_of_preservesCoequalizers_and_finiteCoproducts _ _ _ _ _ _ G _ ?_\n  apply PreservesFiniteCoproducts.mk\n  apply preservesFiniteCoproductsOfPreservesBinaryAndInitial G\n\n"}
