{"name":"Set.initialSegIic_toFun","module":"Mathlib.Order.Interval.Set.InitialSeg","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nj : α\nx✝ : ↑(Set.Iic j)\n⊢ Eq ((Set.initialSegIic j) x✝) (Set.initialSegIic.match_1 j (fun x => α) x✝ fun j_1 hj => j_1)","decl":"/-- `Set.Iic j` is an initial segment. -/\n@[simps]\ndef initialSegIic (j : α) :\n    Set.Iic j ≤i α where\n  toFun := fun ⟨j, hj⟩ ↦ j\n  inj' _ _ _ := by aesop\n  map_rel_iff' := by aesop\n  mem_range_of_rel' x k h := by simpa using h.le.trans x.2\n\n"}
{"name":"Set.principalSegIio_top","module":"Mathlib.Order.Interval.Set.InitialSeg","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nj : α\n⊢ Eq (Set.principalSegIio j).top j","decl":"/-- `Set.Iio j` is a principal segment. -/\n@[simps]\ndef principalSegIio (j : α) :\n    Set.Iio j <i α where\n  top := j\n  toFun := fun ⟨j, hj⟩ ↦ j\n  inj' _ _ _ := by aesop\n  map_rel_iff' := by aesop\n  mem_range_iff_rel' := by aesop\n\n"}
{"name":"Set.principalSegIio_toFun","module":"Mathlib.Order.Interval.Set.InitialSeg","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nj : α\nx✝ : ↑(Set.Iio j)\n⊢ Eq ((Set.principalSegIio j).toFun x✝) (Set.principalSegIio.match_1 j (fun x => α) x✝ fun j_1 hj => j_1)","decl":"/-- `Set.Iio j` is a principal segment. -/\n@[simps]\ndef principalSegIio (j : α) :\n    Set.Iio j <i α where\n  top := j\n  toFun := fun ⟨j, hj⟩ ↦ j\n  inj' _ _ _ := by aesop\n  map_rel_iff' := by aesop\n  mem_range_iff_rel' := by aesop\n\n"}
{"name":"Set.principalSegIio_toRelEmbedding","module":"Mathlib.Order.Interval.Set.InitialSeg","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nj : α\nk : ↑(Set.Iio j)\n⊢ Eq ((Set.principalSegIio j).toRelEmbedding k) ↑k","decl":"@[simp]\nlemma principalSegIio_toRelEmbedding {j : α} (k : Iio j) :\n    (Set.principalSegIio j).toRelEmbedding k = k.1 := rfl\n\n"}
{"name":"Set.initialSegIicIicOfLE_toFun_coe","module":"Mathlib.Order.Interval.Set.InitialSeg","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ni j : α\nh : LE.le i j\nx✝ : ↑(Set.Iic i)\n⊢ Eq ↑((Set.initialSegIicIicOfLE h) x✝) ↑x✝","decl":"/-- If `i ≤ j`, then `Set.Iic i` is an initial segment of `Set.Iic j`. -/\n@[simps]\ndef initialSegIicIicOfLE {i j : α} (h : i ≤ j) :\n    Set.Iic i ≤i Set.Iic j where\n  toFun := fun ⟨k, hk⟩ ↦ ⟨k, hk.trans h⟩\n  inj' _ _ _ := by aesop\n  map_rel_iff' := by aesop\n  mem_range_of_rel' x k h := ⟨⟨k.1, (Subtype.coe_le_coe.2 h.le).trans x.2⟩, rfl⟩\n\n"}
{"name":"Set.principalSegIioIicOfLE_top","module":"Mathlib.Order.Interval.Set.InitialSeg","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ni j : α\nh : LE.le i j\n⊢ Eq (Set.principalSegIioIicOfLE h).top ⟨i, h⟩","decl":"/-- If `i ≤ j`, then `Set.Iio i` is a principal segment of `Set.Iic j`. -/\n@[simps top]\ndef principalSegIioIicOfLE {i j : α} (h : i ≤ j) :\n    Set.Iio i <i Set.Iic j where\n  top := ⟨i, h⟩\n  toFun := fun ⟨k, hk⟩ ↦ ⟨k, hk.le.trans h⟩\n  inj' _ _ _ := by aesop\n  map_rel_iff' := by aesop\n  mem_range_iff_rel' := by aesop\n\n"}
{"name":"Set.principalSegIioIicOfLE_toRelEmbedding","module":"Mathlib.Order.Interval.Set.InitialSeg","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ni j : α\nh : LE.le i j\nk : ↑(Set.Iio i)\n⊢ Eq ((Set.principalSegIioIicOfLE h).toRelEmbedding k) ⟨↑k, ⋯⟩","decl":"@[simp]\nlemma principalSegIioIicOfLE_toRelEmbedding {i j : α} (h : i ≤ j)\n    (k : Iio i) :\n    (Set.principalSegIioIicOfLE h).toRelEmbedding k = ⟨k, k.2.le.trans h⟩ := rfl\n\n"}
{"name":"PrincipalSeg.orderIsoIio_apply_coe","module":"Mathlib.Order.Interval.Set.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\nf : PrincipalSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\na : α\n⊢ Eq (↑(f.orderIsoIio a)) (f.toRelEmbedding a)","decl":"/-- If `f : α <i β` is a principal segment, this is the induced order\nisomorphism `α ≃o Set.Iio f.top`. -/\n@[simps! apply_coe]\nnoncomputable def PrincipalSeg.orderIsoIio {α β : Type*} [PartialOrder α] [PartialOrder β]\n    (f : α <i β) :\n    α ≃o Set.Iio f.top where\n  toEquiv := Equiv.ofBijective (f := fun a ↦ ⟨f a, f.lt_top a⟩) (by\n    constructor\n    · intro x y hxy\n      exact f.injective (by simpa using hxy)\n    · rintro ⟨z, hz⟩\n      obtain ⟨x, hx⟩ := f.mem_range_of_rel_top hz\n      exact ⟨x, by simpa using hx⟩)\n  map_rel_iff' := by simp\n"}
