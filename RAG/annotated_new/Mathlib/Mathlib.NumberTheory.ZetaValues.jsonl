{"name":"bernoulliFun_eval_zero","module":"Mathlib.NumberTheory.ZetaValues","initialProofState":"k : Nat\n‚ä¢ Eq (bernoulliFun k 0) ‚Üë(bernoulli k)","decl":"theorem bernoulliFun_eval_zero (k : ‚Ñï) : bernoulliFun k 0 = bernoulli k := by\n  rw [bernoulliFun, Polynomial.eval_zero_map, Polynomial.bernoulli_eval_zero, eq_ratCast]\n\n"}
{"name":"bernoulliFun_endpoints_eq_of_ne_one","module":"Mathlib.NumberTheory.ZetaValues","initialProofState":"k : Nat\nhk : Ne k 1\n‚ä¢ Eq (bernoulliFun k 1) (bernoulliFun k 0)","decl":"theorem bernoulliFun_endpoints_eq_of_ne_one {k : ‚Ñï} (hk : k ‚â† 1) :\n    bernoulliFun k 1 = bernoulliFun k 0 := by\n  rw [bernoulliFun_eval_zero, bernoulliFun, Polynomial.eval_one_map, Polynomial.bernoulli_eval_one,\n    bernoulli_eq_bernoulli'_of_ne_one hk, eq_ratCast]\n\n"}
{"name":"bernoulliFun_eval_one","module":"Mathlib.NumberTheory.ZetaValues","initialProofState":"k : Nat\n‚ä¢ Eq (bernoulliFun k 1) (HAdd.hAdd (bernoulliFun k 0) (ite (Eq k 1) 1 0))","decl":"theorem bernoulliFun_eval_one (k : ‚Ñï) : bernoulliFun k 1 = bernoulliFun k 0 + ite (k = 1) 1 0 := by\n  rw [bernoulliFun, bernoulliFun_eval_zero, Polynomial.eval_one_map, Polynomial.bernoulli_eval_one]\n  split_ifs with h\n  ¬∑ rw [h, bernoulli_one, bernoulli'_one, eq_ratCast]\n    push_cast; ring\n  ¬∑ rw [bernoulli_eq_bernoulli'_of_ne_one h, add_zero, eq_ratCast]\n\n"}
{"name":"hasDerivAt_bernoulliFun","module":"Mathlib.NumberTheory.ZetaValues","initialProofState":"k : Nat\nx : Real\n‚ä¢ HasDerivAt (bernoulliFun k) (HMul.hMul (‚Üëk) (bernoulliFun (HSub.hSub k 1) x)) x","decl":"theorem hasDerivAt_bernoulliFun (k : ‚Ñï) (x : ‚Ñù) :\n    HasDerivAt (bernoulliFun k) (k * bernoulliFun (k - 1) x) x := by\n  convert ((Polynomial.bernoulli k).map <| algebraMap ‚Ñö ‚Ñù).hasDerivAt x using 1\n  simp only [bernoulliFun, Polynomial.derivative_map, Polynomial.derivative_bernoulli k,\n    Polynomial.map_mul, Polynomial.map_natCast, Polynomial.eval_mul, Polynomial.eval_natCast]\n\n"}
{"name":"antideriv_bernoulliFun","module":"Mathlib.NumberTheory.ZetaValues","initialProofState":"k : Nat\nx : Real\n‚ä¢ HasDerivAt (fun x => HDiv.hDiv (bernoulliFun (HAdd.hAdd k 1) x) (HAdd.hAdd (‚Üëk) 1)) (bernoulliFun k x) x","decl":"theorem antideriv_bernoulliFun (k : ‚Ñï) (x : ‚Ñù) :\n    HasDerivAt (fun x => bernoulliFun (k + 1) x / (k + 1)) (bernoulliFun k x) x := by\n  convert (hasDerivAt_bernoulliFun (k + 1) x).div_const _ using 1\n  field_simp [Nat.cast_add_one_ne_zero k]\n\n"}
{"name":"integral_bernoulliFun_eq_zero","module":"Mathlib.NumberTheory.ZetaValues","initialProofState":"k : Nat\nhk : Ne k 0\n‚ä¢ Eq (intervalIntegral (fun x => bernoulliFun k x) 0 1 MeasureTheory.MeasureSpace.volume) 0","decl":"theorem integral_bernoulliFun_eq_zero {k : ‚Ñï} (hk : k ‚â† 0) :\n    ‚à´ x : ‚Ñù in (0)..1, bernoulliFun k x = 0 := by\n  rw [integral_eq_sub_of_hasDerivAt (fun x _ => antideriv_bernoulliFun k x)\n      ((Polynomial.continuous _).intervalIntegrable _ _)]\n  rw [bernoulliFun_eval_one]\n  split_ifs with h\n  ¬∑ exfalso; exact hk (Nat.succ_inj'.mp h)\n  ¬∑ simp\n\n"}
{"name":"bernoulliFourierCoeff_recurrence","module":"Mathlib.NumberTheory.ZetaValues","initialProofState":"k : Nat\nn : Int\nhn : Ne n 0\n‚ä¢ Eq (bernoulliFourierCoeff k n) (HMul.hMul (HDiv.hDiv 1 (HMul.hMul (HMul.hMul (HMul.hMul (-2) ‚ÜëReal.pi) Complex.I) ‚Üën)) (HSub.hSub (ite (Eq k 1) 1 0) (HMul.hMul (‚Üëk) (bernoulliFourierCoeff (HSub.hSub k 1) n))))","decl":"/-- Recurrence relation (in `k`) for the `n`-th Fourier coefficient of `B‚Çñ`. -/\ntheorem bernoulliFourierCoeff_recurrence (k : ‚Ñï) {n : ‚Ñ§} (hn : n ‚â† 0) :\n    bernoulliFourierCoeff k n =\n      1 / (-2 * œÄ * I * n) * (ite (k = 1) 1 0 - k * bernoulliFourierCoeff (k - 1) n) := by\n  unfold bernoulliFourierCoeff\n  rw [fourierCoeffOn_of_hasDerivAt zero_lt_one hn\n      (fun x _ => (hasDerivAt_bernoulliFun k x).ofReal_comp)\n      ((continuous_ofReal.comp <|\n            continuous_const.mul <| Polynomial.continuous _).intervalIntegrable\n        _ _)]\n  simp_rw [ofReal_one, ofReal_zero, sub_zero, one_mul]\n  rw [QuotientAddGroup.mk_zero, fourier_eval_zero, one_mul, ‚Üê ofReal_sub, bernoulliFun_eval_one,\n    add_sub_cancel_left]\n  congr 2\n  ¬∑ split_ifs <;> simp only [ofReal_one, ofReal_zero, one_mul]\n  ¬∑ simp_rw [ofReal_mul, ofReal_natCast, fourierCoeffOn.const_mul]\n\n"}
{"name":"bernoulli_zero_fourier_coeff","module":"Mathlib.NumberTheory.ZetaValues","initialProofState":"n : Int\nhn : Ne n 0\n‚ä¢ Eq (bernoulliFourierCoeff 0 n) 0","decl":"/-- The Fourier coefficients of `B‚ÇÄ(x) = 1`. -/\ntheorem bernoulli_zero_fourier_coeff {n : ‚Ñ§} (hn : n ‚â† 0) : bernoulliFourierCoeff 0 n = 0 := by\n  simpa using bernoulliFourierCoeff_recurrence 0 hn\n\n"}
{"name":"bernoulliFourierCoeff_zero","module":"Mathlib.NumberTheory.ZetaValues","initialProofState":"k : Nat\nhk : Ne k 0\n‚ä¢ Eq (bernoulliFourierCoeff k 0) 0","decl":"/-- The `0`-th Fourier coefficient of `B‚Çñ(x)`. -/\ntheorem bernoulliFourierCoeff_zero {k : ‚Ñï} (hk : k ‚â† 0) : bernoulliFourierCoeff k 0 = 0 := by\n  simp_rw [bernoulliFourierCoeff, fourierCoeffOn_eq_integral, neg_zero, fourier_zero, sub_zero,\n    div_one, one_smul, intervalIntegral.integral_ofReal, integral_bernoulliFun_eq_zero hk,\n    ofReal_zero]\n\n"}
{"name":"bernoulliFourierCoeff_eq","module":"Mathlib.NumberTheory.ZetaValues","initialProofState":"k : Nat\nhk : Ne k 0\nn : Int\n‚ä¢ Eq (bernoulliFourierCoeff k n) (HDiv.hDiv (Neg.neg ‚Üëk.factorial) (HPow.hPow (HMul.hMul (HMul.hMul (HMul.hMul 2 ‚ÜëReal.pi) Complex.I) ‚Üën) k))","decl":"theorem bernoulliFourierCoeff_eq {k : ‚Ñï} (hk : k ‚â† 0) (n : ‚Ñ§) :\n    bernoulliFourierCoeff k n = -k ! / (2 * œÄ * I * n) ^ k := by\n  rcases eq_or_ne n 0 with (rfl | hn)\n  ¬∑ rw [bernoulliFourierCoeff_zero hk, Int.cast_zero, mul_zero, zero_pow hk,\n      div_zero]\n  refine Nat.le_induction ?_ (fun k hk h'k => ?_) k (Nat.one_le_iff_ne_zero.mpr hk)\n  ¬∑ rw [bernoulliFourierCoeff_recurrence 1 hn]\n    simp only [Nat.cast_one, tsub_self, neg_mul, one_mul, eq_self_iff_true, if_true,\n      Nat.factorial_one, pow_one, inv_I, mul_neg]\n    rw [bernoulli_zero_fourier_coeff hn, sub_zero, mul_one, div_neg, neg_div]\n  ¬∑ rw [bernoulliFourierCoeff_recurrence (k + 1) hn, Nat.add_sub_cancel k 1]\n    split_ifs with h\n    ¬∑ exfalso; exact (ne_of_gt (Nat.lt_succ_iff.mpr hk)) h\n    ¬∑ rw [h'k, Nat.factorial_succ, zero_sub, Nat.cast_mul, pow_add, pow_one, neg_div, mul_neg,\n        mul_neg, mul_neg, neg_neg, neg_mul, neg_mul, neg_mul, div_neg]\n      field_simp [Int.cast_ne_zero.mpr hn, I_ne_zero]\n      ring_nf\n\n"}
{"name":"periodizedBernoulli.continuous","module":"Mathlib.NumberTheory.ZetaValues","initialProofState":"k : Nat\nhk : Ne k 1\n‚ä¢ Continuous (periodizedBernoulli k)","decl":"theorem periodizedBernoulli.continuous {k : ‚Ñï} (hk : k ‚â† 1) : Continuous (periodizedBernoulli k) :=\n  AddCircle.liftIco_zero_continuous\n    (mod_cast (bernoulliFun_endpoints_eq_of_ne_one hk).symm)\n    (Polynomial.continuous _).continuousOn\n\n"}
{"name":"fourierCoeff_bernoulli_eq","module":"Mathlib.NumberTheory.ZetaValues","initialProofState":"k : Nat\nhk : Ne k 0\nn : Int\n‚ä¢ Eq (fourierCoeff (Function.comp Complex.ofReal (periodizedBernoulli k)) n) (HDiv.hDiv (Neg.neg ‚Üëk.factorial) (HPow.hPow (HMul.hMul (HMul.hMul (HMul.hMul 2 ‚ÜëReal.pi) Complex.I) ‚Üën) k))","decl":"theorem fourierCoeff_bernoulli_eq {k : ‚Ñï} (hk : k ‚â† 0) (n : ‚Ñ§) :\n    fourierCoeff ((‚Üë) ‚àò periodizedBernoulli k : ùïå ‚Üí ‚ÑÇ) n = -k ! / (2 * œÄ * I * n) ^ k := by\n  have : ((‚Üë) ‚àò periodizedBernoulli k : ùïå ‚Üí ‚ÑÇ) = AddCircle.liftIco 1 0 ((‚Üë) ‚àò bernoulliFun k) := by\n    ext1 x; rfl\n  rw [this, fourierCoeff_liftIco_eq]\n  simpa only [zero_add] using bernoulliFourierCoeff_eq hk n\n\n"}
{"name":"summable_bernoulli_fourier","module":"Mathlib.NumberTheory.ZetaValues","initialProofState":"k : Nat\nhk : LE.le 2 k\n‚ä¢ Summable fun n => HDiv.hDiv (Neg.neg ‚Üëk.factorial) (HPow.hPow (HMul.hMul (HMul.hMul (HMul.hMul 2 ‚ÜëReal.pi) Complex.I) ‚Üën) k)","decl":"theorem summable_bernoulli_fourier {k : ‚Ñï} (hk : 2 ‚â§ k) :\n    Summable (fun n => -k ! / (2 * œÄ * I * n) ^ k : ‚Ñ§ ‚Üí ‚ÑÇ) := by\n  have :\n      ‚àÄ n : ‚Ñ§, -(k ! : ‚ÑÇ) / (2 * œÄ * I * n) ^ k = -k ! / (2 * œÄ * I) ^ k * (1 / (n : ‚ÑÇ) ^ k) := by\n    intro n; rw [mul_one_div, div_div, ‚Üê mul_pow]\n  simp_rw [this]\n  refine Summable.mul_left _ <| .of_norm ?_\n  have : (fun x : ‚Ñ§ => ‚Äñ1 / (x : ‚ÑÇ) ^ k‚Äñ) = fun x : ‚Ñ§ => |1 / (x : ‚Ñù) ^ k| := by\n    ext1 x\n    rw [norm_eq_abs, ‚Üê Complex.abs_ofReal]\n    congr 1\n    norm_cast\n  simp_rw [this]\n  rwa [summable_abs_iff, Real.summable_one_div_int_pow]\n\n"}
{"name":"hasSum_one_div_pow_mul_fourier_mul_bernoulliFun","module":"Mathlib.NumberTheory.ZetaValues","initialProofState":"k : Nat\nhk : LE.le 2 k\nx : Real\nhx : Membership.mem (Set.Icc 0 1) x\n‚ä¢ HasSum (fun n => HMul.hMul (HDiv.hDiv 1 (HPow.hPow (‚Üën) k)) ((fourier n) ‚Üëx)) (HMul.hMul (HDiv.hDiv (Neg.neg (HPow.hPow (HMul.hMul (HMul.hMul 2 ‚ÜëReal.pi) Complex.I) k)) ‚Üëk.factorial) ‚Üë(bernoulliFun k x))","decl":"theorem hasSum_one_div_pow_mul_fourier_mul_bernoulliFun {k : ‚Ñï} (hk : 2 ‚â§ k) {x : ‚Ñù}\n    (hx : x ‚àà Icc (0 : ‚Ñù) 1) :\n    HasSum (fun n : ‚Ñ§ => 1 / (n : ‚ÑÇ) ^ k * fourier n (x : ùïå))\n      (-(2 * œÄ * I) ^ k / k ! * bernoulliFun k x) := by\n  -- first show it suffices to prove result for `Ico 0 1`\n  suffices ‚àÄ {y : ‚Ñù}, y ‚àà Ico (0 : ‚Ñù) 1 ‚Üí\n      HasSum (fun (n : ‚Ñ§) ‚Ü¶ 1 / (n : ‚ÑÇ) ^ k * fourier n y)\n        (-(2 * (œÄ : ‚ÑÇ) * I) ^ k / k ! * bernoulliFun k y) by\n    rw [‚Üê Ico_insert_right (zero_le_one' ‚Ñù), mem_insert_iff, or_comm] at hx\n    rcases hx with (hx | rfl)\n    ¬∑ exact this hx\n    ¬∑ convert this (left_mem_Ico.mpr zero_lt_one) using 1\n      ¬∑ rw [AddCircle.coe_period, QuotientAddGroup.mk_zero]\n      ¬∑ rw [bernoulliFun_endpoints_eq_of_ne_one (by omega : k ‚â† 1)]\n  intro y hy\n  let B : C(ùïå, ‚ÑÇ) :=\n    ContinuousMap.mk ((‚Üë) ‚àò periodizedBernoulli k)\n      (continuous_ofReal.comp (periodizedBernoulli.continuous (by omega)))\n  have step1 : ‚àÄ n : ‚Ñ§, fourierCoeff B n = -k ! / (2 * œÄ * I * n) ^ k := by\n    rw [ContinuousMap.coe_mk]; exact fourierCoeff_bernoulli_eq (by omega : k ‚â† 0)\n  have step2 :=\n    has_pointwise_sum_fourier_series_of_summable\n      ((summable_bernoulli_fourier hk).congr fun n => (step1 n).symm) y\n  simp_rw [step1] at step2\n  convert step2.mul_left (-(2 * ‚ÜëœÄ * I) ^ k / (k ! : ‚ÑÇ)) using 2 with n\n  ¬∑ rw [smul_eq_mul, ‚Üê mul_assoc, mul_div, mul_neg, div_mul_cancel‚ÇÄ, neg_neg, mul_pow _ (n : ‚ÑÇ),\n      ‚Üê div_div, div_self]\n    ¬∑ rw [Ne, pow_eq_zero_iff', not_and_or]\n      exact Or.inl two_pi_I_ne_zero\n    ¬∑ exact Nat.cast_ne_zero.mpr (Nat.factorial_ne_zero _)\n  ¬∑ rw [ContinuousMap.coe_mk, Function.comp_apply, ofReal_inj, periodizedBernoulli,\n      AddCircle.liftIco_coe_apply (show y ‚àà Ico 0 (0 + 1) by rwa [zero_add])]\n\n"}
{"name":"hasSum_one_div_nat_pow_mul_fourier","module":"Mathlib.NumberTheory.ZetaValues","initialProofState":"k : Nat\nhk : LE.le 2 k\nx : Real\nhx : Membership.mem (Set.Icc 0 1) x\n‚ä¢ HasSum (fun n => HMul.hMul (HDiv.hDiv 1 (HPow.hPow (‚Üën) k)) (HAdd.hAdd ((fourier ‚Üën) ‚Üëx) (HMul.hMul (HPow.hPow (-1) k) ((fourier (Neg.neg ‚Üën)) ‚Üëx)))) (HMul.hMul (HDiv.hDiv (Neg.neg (HPow.hPow (HMul.hMul (HMul.hMul 2 ‚ÜëReal.pi) Complex.I) k)) ‚Üëk.factorial) ‚Üë(bernoulliFun k x))","decl":"theorem hasSum_one_div_nat_pow_mul_fourier {k : ‚Ñï} (hk : 2 ‚â§ k) {x : ‚Ñù} (hx : x ‚àà Icc (0 : ‚Ñù) 1) :\n    HasSum\n      (fun n : ‚Ñï =>\n        (1 : ‚ÑÇ) / (n : ‚ÑÇ) ^ k * (fourier n (x : ùïå) + (-1 : ‚ÑÇ) ^ k * fourier (-n) (x : ùïå)))\n      (-(2 * œÄ * I) ^ k / k ! * bernoulliFun k x) := by\n  convert (hasSum_one_div_pow_mul_fourier_mul_bernoulliFun hk hx).nat_add_neg using 1\n  ¬∑ ext1 n\n    rw [Int.cast_neg, mul_add, ‚Üê mul_assoc]\n    conv_rhs => rw [neg_eq_neg_one_mul, mul_pow, ‚Üê div_div]\n    congr 2\n    rw [div_mul_eq_mul_div‚ÇÄ, one_mul]\n    congr 1\n    rw [eq_div_iff, ‚Üê mul_pow, ‚Üê neg_eq_neg_one_mul, neg_neg, one_pow]\n    apply pow_ne_zero; rw [neg_ne_zero]; exact one_ne_zero\n  ¬∑ rw [Int.cast_zero, zero_pow (by positivity : k ‚â† 0), div_zero, zero_mul, add_zero]\n\n"}
{"name":"hasSum_one_div_nat_pow_mul_cos","module":"Mathlib.NumberTheory.ZetaValues","initialProofState":"k : Nat\nhk : Ne k 0\nx : Real\nhx : Membership.mem (Set.Icc 0 1) x\n‚ä¢ HasSum (fun n => HMul.hMul (HDiv.hDiv 1 (HPow.hPow (‚Üën) (HMul.hMul 2 k))) (Real.cos (HMul.hMul (HMul.hMul (HMul.hMul 2 Real.pi) ‚Üën) x))) (HMul.hMul (HDiv.hDiv (HDiv.hDiv (HMul.hMul (HPow.hPow (-1) (HAdd.hAdd k 1)) (HPow.hPow (HMul.hMul 2 Real.pi) (HMul.hMul 2 k))) 2) ‚Üë(HMul.hMul 2 k).factorial) (Polynomial.eval x (Polynomial.map (algebraMap Rat Real) (Polynomial.bernoulli (HMul.hMul 2 k)))))","decl":"theorem hasSum_one_div_nat_pow_mul_cos {k : ‚Ñï} (hk : k ‚â† 0) {x : ‚Ñù} (hx : x ‚àà Icc (0 : ‚Ñù) 1) :\n    HasSum (fun n : ‚Ñï => 1 / (n : ‚Ñù) ^ (2 * k) * Real.cos (2 * œÄ * n * x))\n      ((-1 : ‚Ñù) ^ (k + 1) * (2 * œÄ) ^ (2 * k) / 2 / (2 * k)! *\n        (Polynomial.map (algebraMap ‚Ñö ‚Ñù) (Polynomial.bernoulli (2 * k))).eval x) := by\n  have :\n    HasSum (fun n : ‚Ñï => 1 / (n : ‚ÑÇ) ^ (2 * k) * (fourier n (x : ùïå) + fourier (-n) (x : ùïå)))\n      ((-1 : ‚ÑÇ) ^ (k + 1) * (2 * (œÄ : ‚ÑÇ)) ^ (2 * k) / (2 * k)! * bernoulliFun (2 * k) x) := by\n    convert\n      hasSum_one_div_nat_pow_mul_fourier (by omega : 2 ‚â§ 2 * k)\n        hx using 3\n    ¬∑ rw [pow_mul (-1 : ‚ÑÇ), neg_one_sq, one_pow, one_mul]\n    ¬∑ rw [pow_add, pow_one]\n      conv_rhs =>\n        rw [mul_pow]\n        congr\n        congr\n        ¬∑ skip\n        ¬∑ rw [pow_mul, I_sq]\n      ring\n  have ofReal_two : ((2 : ‚Ñù) : ‚ÑÇ) = 2 := by norm_cast\n  convert ((hasSum_iff _ _).mp (this.div_const 2)).1 with n\n  ¬∑ convert (ofReal_re _).symm\n    rw [ofReal_mul]; rw [‚Üê mul_div]; congr\n    ¬∑ rw [ofReal_div, ofReal_one, ofReal_pow]; rfl\n    ¬∑ rw [ofReal_cos, ofReal_mul, fourier_coe_apply, fourier_coe_apply, cos, ofReal_one, div_one,\n        div_one, ofReal_mul, ofReal_mul, ofReal_two, Int.cast_neg, Int.cast_natCast,\n        ofReal_natCast]\n      congr 3\n      ¬∑ ring\n      ¬∑ ring\n  ¬∑ convert (ofReal_re _).symm\n    rw [ofReal_mul, ofReal_div, ofReal_div, ofReal_mul, ofReal_pow, ofReal_pow, ofReal_neg,\n      ofReal_natCast, ofReal_mul, ofReal_two, ofReal_one]\n    rw [bernoulliFun]\n    ring\n\n"}
{"name":"hasSum_one_div_nat_pow_mul_sin","module":"Mathlib.NumberTheory.ZetaValues","initialProofState":"k : Nat\nhk : Ne k 0\nx : Real\nhx : Membership.mem (Set.Icc 0 1) x\n‚ä¢ HasSum (fun n => HMul.hMul (HDiv.hDiv 1 (HPow.hPow (‚Üën) (HAdd.hAdd (HMul.hMul 2 k) 1))) (Real.sin (HMul.hMul (HMul.hMul (HMul.hMul 2 Real.pi) ‚Üën) x))) (HMul.hMul (HDiv.hDiv (HDiv.hDiv (HMul.hMul (HPow.hPow (-1) (HAdd.hAdd k 1)) (HPow.hPow (HMul.hMul 2 Real.pi) (HAdd.hAdd (HMul.hMul 2 k) 1))) 2) ‚Üë(HAdd.hAdd (HMul.hMul 2 k) 1).factorial) (Polynomial.eval x (Polynomial.map (algebraMap Rat Real) (Polynomial.bernoulli (HAdd.hAdd (HMul.hMul 2 k) 1)))))","decl":"theorem hasSum_one_div_nat_pow_mul_sin {k : ‚Ñï} (hk : k ‚â† 0) {x : ‚Ñù} (hx : x ‚àà Icc (0 : ‚Ñù) 1) :\n    HasSum (fun n : ‚Ñï => 1 / (n : ‚Ñù) ^ (2 * k + 1) * Real.sin (2 * œÄ * n * x))\n      ((-1 : ‚Ñù) ^ (k + 1) * (2 * œÄ) ^ (2 * k + 1) / 2 / (2 * k + 1)! *\n        (Polynomial.map (algebraMap ‚Ñö ‚Ñù) (Polynomial.bernoulli (2 * k + 1))).eval x) := by\n  have :\n    HasSum (fun n : ‚Ñï => 1 / (n : ‚ÑÇ) ^ (2 * k + 1) * (fourier n (x : ùïå) - fourier (-n) (x : ùïå)))\n      ((-1 : ‚ÑÇ) ^ (k + 1) * I * (2 * œÄ : ‚ÑÇ) ^ (2 * k + 1) / (2 * k + 1)! *\n        bernoulliFun (2 * k + 1) x) := by\n    convert\n      hasSum_one_div_nat_pow_mul_fourier\n        (by omega : 2 ‚â§ 2 * k + 1) hx using 1\n    ¬∑ ext1 n\n      rw [pow_add (-1 : ‚ÑÇ), pow_mul (-1 : ‚ÑÇ), neg_one_sq, one_pow, one_mul, pow_one, ‚Üê\n        neg_eq_neg_one_mul, ‚Üê sub_eq_add_neg]\n    ¬∑ congr\n      rw [pow_add, pow_one]\n      conv_rhs =>\n        rw [mul_pow]\n        congr\n        congr\n        ¬∑ skip\n        ¬∑ rw [pow_add, pow_one, pow_mul, I_sq]\n      ring\n  have ofReal_two : ((2 : ‚Ñù) : ‚ÑÇ) = 2 := by norm_cast\n  convert ((hasSum_iff _ _).mp (this.div_const (2 * I))).1\n  ¬∑ convert (ofReal_re _).symm\n    rw [ofReal_mul]; rw [‚Üê mul_div]; congr\n    ¬∑ rw [ofReal_div, ofReal_one, ofReal_pow]; rfl\n    ¬∑ rw [ofReal_sin, ofReal_mul, fourier_coe_apply, fourier_coe_apply, sin, ofReal_one, div_one,\n        div_one, ofReal_mul, ofReal_mul, ofReal_two, Int.cast_neg, Int.cast_natCast,\n        ofReal_natCast, ‚Üê div_div, div_I, div_mul_eq_mul_div‚ÇÄ, ‚Üê neg_div, ‚Üê neg_mul, neg_sub]\n      congr 4\n      ¬∑ ring\n      ¬∑ ring\n  ¬∑ convert (ofReal_re _).symm\n    rw [ofReal_mul, ofReal_div, ofReal_div, ofReal_mul, ofReal_pow, ofReal_pow, ofReal_neg,\n      ofReal_natCast, ofReal_mul, ofReal_two, ofReal_one, ‚Üê div_div, div_I,\n      div_mul_eq_mul_div‚ÇÄ]\n    have : ‚àÄ Œ± Œ≤ Œ≥ Œ¥ : ‚ÑÇ, Œ± * I * Œ≤ / Œ≥ * Œ¥ * I = I ^ 2 * Œ± * Œ≤ / Œ≥ * Œ¥ := by intros; ring\n    rw [this, I_sq]\n    rw [bernoulliFun]\n    ring\n\n"}
{"name":"hasSum_zeta_nat","module":"Mathlib.NumberTheory.ZetaValues","initialProofState":"k : Nat\nhk : Ne k 0\n‚ä¢ HasSum (fun n => HDiv.hDiv 1 (HPow.hPow (‚Üën) (HMul.hMul 2 k))) (HDiv.hDiv (HMul.hMul (HMul.hMul (HMul.hMul (HPow.hPow (-1) (HAdd.hAdd k 1)) (HPow.hPow 2 (HSub.hSub (HMul.hMul 2 k) 1))) (HPow.hPow Real.pi (HMul.hMul 2 k))) ‚Üë(bernoulli (HMul.hMul 2 k))) ‚Üë(HMul.hMul 2 k).factorial)","decl":"theorem hasSum_zeta_nat {k : ‚Ñï} (hk : k ‚â† 0) :\n    HasSum (fun n : ‚Ñï => 1 / (n : ‚Ñù) ^ (2 * k))\n      ((-1 : ‚Ñù) ^ (k + 1) * (2 : ‚Ñù) ^ (2 * k - 1) * œÄ ^ (2 * k) *\n        bernoulli (2 * k) / (2 * k)!) := by\n  convert hasSum_one_div_nat_pow_mul_cos hk (left_mem_Icc.mpr zero_le_one) using 1\n  ¬∑ ext1 n; rw [mul_zero, Real.cos_zero, mul_one]\n  rw [Polynomial.eval_zero_map, Polynomial.bernoulli_eval_zero, eq_ratCast]\n  have : (2 : ‚Ñù) ^ (2 * k - 1) = (2 : ‚Ñù) ^ (2 * k) / 2 := by\n    rw [eq_div_iff (two_ne_zero' ‚Ñù)]\n    conv_lhs =>\n      congr\n      ¬∑ skip\n      ¬∑ rw [‚Üê pow_one (2 : ‚Ñù)]\n    rw [‚Üê pow_add, Nat.sub_add_cancel]\n    omega\n  rw [this, mul_pow]\n  ring\n\n"}
{"name":"hasSum_zeta_two","module":"Mathlib.NumberTheory.ZetaValues","initialProofState":"‚ä¢ HasSum (fun n => HDiv.hDiv 1 (HPow.hPow (‚Üën) 2)) (HDiv.hDiv (HPow.hPow Real.pi 2) 6)","decl":"theorem hasSum_zeta_two : HasSum (fun n : ‚Ñï => (1 : ‚Ñù) / (n : ‚Ñù) ^ 2) (œÄ ^ 2 / 6) := by\n  convert hasSum_zeta_nat one_ne_zero using 1; rw [mul_one]\n  rw [bernoulli_eq_bernoulli'_of_ne_one (by decide : 2 ‚â† 1), bernoulli'_two]\n  norm_num [Nat.factorial]; field_simp; ring\n\n"}
{"name":"hasSum_zeta_four","module":"Mathlib.NumberTheory.ZetaValues","initialProofState":"‚ä¢ HasSum (fun n => HDiv.hDiv 1 (HPow.hPow (‚Üën) 4)) (HDiv.hDiv (HPow.hPow Real.pi 4) 90)","decl":"theorem hasSum_zeta_four : HasSum (fun n : ‚Ñï => (1 : ‚Ñù) / (n : ‚Ñù) ^ 4) (œÄ ^ 4 / 90) := by\n  convert hasSum_zeta_nat two_ne_zero using 1; norm_num\n  rw [bernoulli_eq_bernoulli'_of_ne_one, bernoulli'_four]\n  ¬∑ norm_num [Nat.factorial]; field_simp; ring\n  ¬∑ decide\n\n"}
{"name":"Polynomial.bernoulli_three_eval_one_quarter","module":"Mathlib.NumberTheory.ZetaValues","initialProofState":"‚ä¢ Eq (Polynomial.eval (1 / 4) (Polynomial.bernoulli 3)) (3 / 64)","decl":"theorem Polynomial.bernoulli_three_eval_one_quarter :\n    (Polynomial.bernoulli 3).eval (1 / 4) = 3 / 64 := by\n  simp_rw [Polynomial.bernoulli, Finset.sum_range_succ, Polynomial.eval_add,\n    Polynomial.eval_monomial]\n  rw [Finset.sum_range_zero, Polynomial.eval_zero, zero_add, bernoulli_one]\n  rw [bernoulli_eq_bernoulli'_of_ne_one zero_ne_one, bernoulli'_zero,\n    bernoulli_eq_bernoulli'_of_ne_one (by decide : 2 ‚â† 1), bernoulli'_two,\n    bernoulli_eq_bernoulli'_of_ne_one (by decide : 3 ‚â† 1), bernoulli'_three]\n  norm_num\n\n"}
{"name":"hasSum_L_function_mod_four_eval_three","module":"Mathlib.NumberTheory.ZetaValues","initialProofState":"‚ä¢ HasSum (fun n => HMul.hMul (HDiv.hDiv 1 (HPow.hPow (‚Üën) 3)) (Real.sin (HDiv.hDiv (HMul.hMul Real.pi ‚Üën) 2))) (HDiv.hDiv (HPow.hPow Real.pi 3) 32)","decl":"/-- Explicit formula for `L(œá, 3)`, where `œá` is the unique nontrivial Dirichlet character modulo 4.\n-/\ntheorem hasSum_L_function_mod_four_eval_three :\n    HasSum (fun n : ‚Ñï => (1 : ‚Ñù) / (n : ‚Ñù) ^ 3 * Real.sin (œÄ * n / 2)) (œÄ ^ 3 / 32) := by\n  -- Porting note: times out with\n  -- convert hasSum_one_div_nat_pow_mul_sin one_ne_zero (_ : 1 / 4 ‚àà Icc (0 : ‚Ñù) 1)\n  apply (congr_arg‚ÇÇ HasSum ?_ ?_).to_iff.mp <|\n    hasSum_one_div_nat_pow_mul_sin one_ne_zero (?_ : 1 / 4 ‚àà Icc (0 : ‚Ñù) 1)\n  ¬∑ ext1 n\n    norm_num\n    left\n    congr 1\n    ring\n  ¬∑ have : (1 / 4 : ‚Ñù) = (algebraMap ‚Ñö ‚Ñù) (1 / 4 : ‚Ñö) := by norm_num\n    rw [this, mul_pow, Polynomial.eval_map, Polynomial.eval‚ÇÇ_at_apply, (by decide : 2 * 1 + 1 = 3),\n      Polynomial.bernoulli_three_eval_one_quarter]\n    norm_num [Nat.factorial]; field_simp; ring\n  ¬∑ rw [mem_Icc]; constructor\n    ¬∑ linarith\n    ¬∑ linarith\n\n"}
