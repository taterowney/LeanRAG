{"name":"hasDerivAtFilter_iff_tendsto_slope","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\nL : Filter 𝕜\n⊢ Iff (HasDerivAtFilter f f' x L) (Filter.Tendsto (slope f x) (Min.min L (Filter.principal (HasCompl.compl (Singleton.singleton x)))) (nhds f'))","decl":"/-- If the domain has dimension one, then Fréchet derivative is equivalent to the classical\ndefinition with a limit. In this version we have to take the limit along the subset `-{x}`,\nbecause for `y=x` the slope equals zero due to the convention `0⁻¹=0`. -/\ntheorem hasDerivAtFilter_iff_tendsto_slope {x : 𝕜} {L : Filter 𝕜} :\n    HasDerivAtFilter f f' x L ↔ Tendsto (slope f x) (L ⊓ 𝓟 {x}ᶜ) (𝓝 f') :=\n  calc HasDerivAtFilter f f' x L\n    ↔ Tendsto (fun y ↦ slope f x y - (y - x)⁻¹ • (y - x) • f') L (𝓝 0) := by\n        simp only [hasDerivAtFilter_iff_tendsto, ← norm_inv, ← norm_smul,\n          ← tendsto_zero_iff_norm_tendsto_zero, slope_def_module, smul_sub]\n  _ ↔ Tendsto (fun y ↦ slope f x y - (y - x)⁻¹ • (y - x) • f') (L ⊓ 𝓟 {x}ᶜ) (𝓝 0) :=\n        .symm <| tendsto_inf_principal_nhds_iff_of_forall_eq <| by simp\n  _ ↔ Tendsto (fun y ↦ slope f x y - f') (L ⊓ 𝓟 {x}ᶜ) (𝓝 0) := tendsto_congr' <| by\n        refine (EqOn.eventuallyEq fun y hy ↦ ?_).filter_mono inf_le_right\n        rw [inv_smul_smul₀ (sub_ne_zero.2 hy) f']\n  _ ↔ Tendsto (slope f x) (L ⊓ 𝓟 {x}ᶜ) (𝓝 f') := by\n        rw [← nhds_translation_sub f', tendsto_comap_iff]; rfl\n\n"}
{"name":"hasDerivWithinAt_iff_tendsto_slope","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\ns : Set 𝕜\n⊢ Iff (HasDerivWithinAt f f' s x) (Filter.Tendsto (slope f x) (nhdsWithin x (SDiff.sdiff s (Singleton.singleton x))) (nhds f'))","decl":"theorem hasDerivWithinAt_iff_tendsto_slope :\n    HasDerivWithinAt f f' s x ↔ Tendsto (slope f x) (𝓝[s \\ {x}] x) (𝓝 f') := by\n  simp only [HasDerivWithinAt, nhdsWithin, diff_eq, ← inf_assoc, inf_principal.symm]\n  exact hasDerivAtFilter_iff_tendsto_slope\n\n"}
{"name":"hasDerivWithinAt_iff_tendsto_slope'","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\ns : Set 𝕜\nhs : Not (Membership.mem s x)\n⊢ Iff (HasDerivWithinAt f f' s x) (Filter.Tendsto (slope f x) (nhdsWithin x s) (nhds f'))","decl":"theorem hasDerivWithinAt_iff_tendsto_slope' (hs : x ∉ s) :\n    HasDerivWithinAt f f' s x ↔ Tendsto (slope f x) (𝓝[s] x) (𝓝 f') := by\n  rw [hasDerivWithinAt_iff_tendsto_slope, diff_singleton_eq_self hs]\n\n"}
{"name":"hasDerivAt_iff_tendsto_slope","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\n⊢ Iff (HasDerivAt f f' x) (Filter.Tendsto (slope f x) (nhdsWithin x (HasCompl.compl (Singleton.singleton x))) (nhds f'))","decl":"theorem hasDerivAt_iff_tendsto_slope : HasDerivAt f f' x ↔ Tendsto (slope f x) (𝓝[≠] x) (𝓝 f') :=\n  hasDerivAtFilter_iff_tendsto_slope\n\n"}
{"name":"hasDerivAt_iff_tendsto_slope_zero","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\n⊢ Iff (HasDerivAt f f' x) (Filter.Tendsto (fun t => HSMul.hSMul (Inv.inv t) (HSub.hSub (f (HAdd.hAdd x t)) (f x))) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))) (nhds f'))","decl":"theorem hasDerivAt_iff_tendsto_slope_zero :\n    HasDerivAt f f' x ↔ Tendsto (fun t ↦ t⁻¹ • (f (x + t) - f x)) (𝓝[≠] 0) (𝓝 f') := by\n  have : 𝓝[≠] x = Filter.map (fun t ↦ x + t) (𝓝[≠] 0) := by\n    simp [nhdsWithin, map_add_left_nhds_zero x, Filter.map_inf, add_right_injective x]\n  simp [hasDerivAt_iff_tendsto_slope, this, slope, Function.comp_def]\n\n"}
{"name":"HasDerivAt.tendsto_slope_zero","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\na✝ : HasDerivAt f f' x\n⊢ Filter.Tendsto (fun t => HSMul.hSMul (Inv.inv t) (HSub.hSub (f (HAdd.hAdd x t)) (f x))) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))) (nhds f')","decl":"alias ⟨HasDerivAt.tendsto_slope_zero, _⟩ := hasDerivAt_iff_tendsto_slope_zero\n\n"}
{"name":"HasDerivAt.tendsto_slope_zero_right","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"𝕜 : Type u\ninst✝³ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\ninst✝ : PartialOrder 𝕜\nh : HasDerivAt f f' x\n⊢ Filter.Tendsto (fun t => HSMul.hSMul (Inv.inv t) (HSub.hSub (f (HAdd.hAdd x t)) (f x))) (nhdsWithin 0 (Set.Ioi 0)) (nhds f')","decl":"theorem HasDerivAt.tendsto_slope_zero_right [PartialOrder 𝕜] (h : HasDerivAt f f' x) :\n    Tendsto (fun t ↦ t⁻¹ • (f (x + t) - f x)) (𝓝[>] 0) (𝓝 f') :=\n  h.tendsto_slope_zero.mono_left (nhdsGT_le_nhdsNE 0)\n\n"}
{"name":"HasDerivAt.tendsto_slope_zero_left","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"𝕜 : Type u\ninst✝³ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\ninst✝ : PartialOrder 𝕜\nh : HasDerivAt f f' x\n⊢ Filter.Tendsto (fun t => HSMul.hSMul (Inv.inv t) (HSub.hSub (f (HAdd.hAdd x t)) (f x))) (nhdsWithin 0 (Set.Iio 0)) (nhds f')","decl":"theorem HasDerivAt.tendsto_slope_zero_left [PartialOrder 𝕜] (h : HasDerivAt f f' x) :\n    Tendsto (fun t ↦ t⁻¹ • (f (x + t) - f x)) (𝓝[<] 0) (𝓝 f') :=\n  h.tendsto_slope_zero.mono_left (nhdsLT_le_nhdsNE 0)\n\n"}
{"name":"range_derivWithin_subset_closure_span_image","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\ns t : Set 𝕜\nh : HasSubset.Subset s (closure (Inter.inter s t))\n⊢ HasSubset.Subset (Set.range (derivWithin f s)) (closure ↑(Submodule.span 𝕜 (Set.image f t)))","decl":"/-- Given a set `t` such that `s ∩ t` is dense in `s`, then the range of `derivWithin f s` is\ncontained in the closure of the submodule spanned by the image of `t`. -/\ntheorem range_derivWithin_subset_closure_span_image\n    (f : 𝕜 → F) {s t : Set 𝕜} (h : s ⊆ closure (s ∩ t)) :\n    range (derivWithin f s) ⊆ closure (Submodule.span 𝕜 (f '' t)) := by\n  rintro - ⟨x, rfl⟩\n  rcases eq_or_neBot (𝓝[s \\ {x}] x) with H|H\n  · simpa [derivWithin_zero_of_isolated H] using subset_closure (zero_mem _)\n  by_cases H' : DifferentiableWithinAt 𝕜 f s x; swap\n  · rw [derivWithin_zero_of_not_differentiableWithinAt H']\n    exact subset_closure (zero_mem _)\n  have I : (𝓝[(s ∩ t) \\ {x}] x).NeBot := by\n    rw [← mem_closure_iff_nhdsWithin_neBot] at H ⊢\n    have A : closure (s \\ {x}) ⊆ closure (closure (s ∩ t) \\ {x}) :=\n      closure_mono (diff_subset_diff_left h)\n    have B : closure (s ∩ t) \\ {x} ⊆ closure ((s ∩ t) \\ {x}) := by\n      convert closure_diff; exact closure_singleton.symm\n    simpa using A.trans (closure_mono B) H\n  have : Tendsto (slope f x) (𝓝[(s ∩ t) \\ {x}] x) (𝓝 (derivWithin f s x)) := by\n    apply Tendsto.mono_left (hasDerivWithinAt_iff_tendsto_slope.1 H'.hasDerivWithinAt)\n    rw [inter_comm, inter_diff_assoc]\n    exact nhdsWithin_mono _ inter_subset_right\n  rw [← closure_closure, ← Submodule.topologicalClosure_coe]\n  apply mem_closure_of_tendsto this\n  filter_upwards [self_mem_nhdsWithin] with y hy\n  simp only [slope, vsub_eq_sub, SetLike.mem_coe]\n  refine Submodule.smul_mem _ _ (Submodule.sub_mem _ ?_ ?_)\n  · apply Submodule.le_topologicalClosure\n    apply Submodule.subset_span\n    exact mem_image_of_mem _ hy.1.2\n  · apply Submodule.closure_subset_topologicalClosure_span\n    suffices A : f x ∈ closure (f '' (s ∩ t)) from\n      closure_mono (image_subset _ inter_subset_right) A\n    apply ContinuousWithinAt.mem_closure_image\n    · apply H'.continuousWithinAt.mono inter_subset_left\n    rw [mem_closure_iff_nhdsWithin_neBot]\n    exact I.mono (nhdsWithin_mono _ diff_subset)\n\n"}
{"name":"range_deriv_subset_closure_span_image","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nt : Set 𝕜\nh : Dense t\n⊢ HasSubset.Subset (Set.range (deriv f)) (closure ↑(Submodule.span 𝕜 (Set.image f t)))","decl":"/-- Given a dense set `t`, then the range of `deriv f` is contained in the closure of the submodule\nspanned by the image of `t`. -/\ntheorem range_deriv_subset_closure_span_image\n    (f : 𝕜 → F) {t : Set 𝕜} (h : Dense t) :\n    range (deriv f) ⊆ closure (Submodule.span 𝕜 (f '' t)) := by\n  rw [← derivWithin_univ]\n  apply range_derivWithin_subset_closure_span_image\n  simp [dense_iff_closure_eq.1 h]\n\n"}
{"name":"isSeparable_range_derivWithin","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"𝕜 : Type u\ninst✝³ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : TopologicalSpace.SeparableSpace 𝕜\nf : 𝕜 → F\ns : Set 𝕜\n⊢ TopologicalSpace.IsSeparable (Set.range (derivWithin f s))","decl":"theorem isSeparable_range_derivWithin [SeparableSpace 𝕜] (f : 𝕜 → F) (s : Set 𝕜) :\n    IsSeparable (range (derivWithin f s)) := by\n  obtain ⟨t, ts, t_count, ht⟩ : ∃ t, t ⊆ s ∧ Set.Countable t ∧ s ⊆ closure t :=\n    (IsSeparable.of_separableSpace s).exists_countable_dense_subset\n  have : s ⊆ closure (s ∩ t) := by rwa [inter_eq_self_of_subset_right ts]\n  apply IsSeparable.mono _ (range_derivWithin_subset_closure_span_image f this)\n  exact (Countable.image t_count f).isSeparable.span.closure\n\n"}
{"name":"isSeparable_range_deriv","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"𝕜 : Type u\ninst✝³ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : TopologicalSpace.SeparableSpace 𝕜\nf : 𝕜 → F\n⊢ TopologicalSpace.IsSeparable (Set.range (deriv f))","decl":"theorem isSeparable_range_deriv [SeparableSpace 𝕜] (f : 𝕜 → F) :\n    IsSeparable (range (deriv f)) := by\n  rw [← derivWithin_univ]\n  exact isSeparable_range_derivWithin _ _\n\n"}
{"name":"HasDerivAt.continuousAt_div","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"𝕜 : Type u\ninst✝¹ : NontriviallyNormedField 𝕜\ninst✝ : DecidableEq 𝕜\nf : 𝕜 → 𝕜\nc a : 𝕜\nhf : HasDerivAt f a c\n⊢ ContinuousAt (Function.update (fun x => HDiv.hDiv (HSub.hSub (f x) (f c)) (HSub.hSub x c)) c a) c","decl":"lemma HasDerivAt.continuousAt_div [DecidableEq 𝕜] {f : 𝕜 → 𝕜} {c a : 𝕜} (hf : HasDerivAt f a c) :\n    ContinuousAt (Function.update (fun x ↦ (f x - f c) / (x - c)) c a) c := by\n  rw [← slope_fun_def_field]\n  exact continuousAt_update_same.mpr <| hasDerivAt_iff_tendsto_slope.mp hf\n\n"}
{"name":"HasDerivWithinAt.limsup_slope_le","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"f : Real → Real\nf' : Real\ns : Set Real\nx r : Real\nhf : HasDerivWithinAt f f' s x\nhr : LT.lt f' r\n⊢ Filter.Eventually (fun z => LT.lt (slope f x z) r) (nhdsWithin x (SDiff.sdiff s (Singleton.singleton x)))","decl":"theorem HasDerivWithinAt.limsup_slope_le (hf : HasDerivWithinAt f f' s x) (hr : f' < r) :\n    ∀ᶠ z in 𝓝[s \\ {x}] x, slope f x z < r :=\n  hasDerivWithinAt_iff_tendsto_slope.1 hf (IsOpen.mem_nhds isOpen_Iio hr)\n\n"}
{"name":"HasDerivWithinAt.limsup_slope_le'","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"f : Real → Real\nf' : Real\ns : Set Real\nx r : Real\nhf : HasDerivWithinAt f f' s x\nhs : Not (Membership.mem s x)\nhr : LT.lt f' r\n⊢ Filter.Eventually (fun z => LT.lt (slope f x z) r) (nhdsWithin x s)","decl":"theorem HasDerivWithinAt.limsup_slope_le' (hf : HasDerivWithinAt f f' s x) (hs : x ∉ s)\n    (hr : f' < r) : ∀ᶠ z in 𝓝[s] x, slope f x z < r :=\n  (hasDerivWithinAt_iff_tendsto_slope' hs).1 hf (IsOpen.mem_nhds isOpen_Iio hr)\n\n"}
{"name":"HasDerivWithinAt.liminf_right_slope_le","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"f : Real → Real\nf' x r : Real\nhf : HasDerivWithinAt f f' (Set.Ici x) x\nhr : LT.lt f' r\n⊢ Filter.Frequently (fun z => LT.lt (slope f x z) r) (nhdsWithin x (Set.Ioi x))","decl":"theorem HasDerivWithinAt.liminf_right_slope_le (hf : HasDerivWithinAt f f' (Ici x) x)\n    (hr : f' < r) : ∃ᶠ z in 𝓝[>] x, slope f x z < r :=\n  (hf.Ioi_of_Ici.limsup_slope_le' (lt_irrefl x) hr).frequently\n\n"}
{"name":"HasDerivWithinAt.limsup_norm_slope_le","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"E : Type u\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : Real → E\nf' : E\ns : Set Real\nx r : Real\nhf : HasDerivWithinAt f f' s x\nhr : LT.lt (Norm.norm f') r\n⊢ Filter.Eventually (fun z => LT.lt (HMul.hMul (Inv.inv (Norm.norm (HSub.hSub z x))) (Norm.norm (HSub.hSub (f z) (f x)))) r) (nhdsWithin x s)","decl":"/-- If `f` has derivative `f'` within `s` at `x`, then for any `r > ‖f'‖` the ratio\n`‖f z - f x‖ / ‖z - x‖` is less than `r` in some neighborhood of `x` within `s`.\nIn other words, the limit superior of this ratio as `z` tends to `x` along `s`\nis less than or equal to `‖f'‖`. -/\ntheorem HasDerivWithinAt.limsup_norm_slope_le (hf : HasDerivWithinAt f f' s x) (hr : ‖f'‖ < r) :\n    ∀ᶠ z in 𝓝[s] x, ‖z - x‖⁻¹ * ‖f z - f x‖ < r := by\n  have hr₀ : 0 < r := lt_of_le_of_lt (norm_nonneg f') hr\n  have A : ∀ᶠ z in 𝓝[s \\ {x}] x, ‖(z - x)⁻¹ • (f z - f x)‖ ∈ Iio r :=\n    (hasDerivWithinAt_iff_tendsto_slope.1 hf).norm (IsOpen.mem_nhds isOpen_Iio hr)\n  have B : ∀ᶠ z in 𝓝[{x}] x, ‖(z - x)⁻¹ • (f z - f x)‖ ∈ Iio r :=\n    mem_of_superset self_mem_nhdsWithin (singleton_subset_iff.2 <| by simp [hr₀])\n  have C := mem_sup.2 ⟨A, B⟩\n  rw [← nhdsWithin_union, diff_union_self, nhdsWithin_union, mem_sup] at C\n  filter_upwards [C.1]\n  simp only [norm_smul, mem_Iio, norm_inv]\n  exact fun _ => id\n\n"}
{"name":"HasDerivWithinAt.limsup_slope_norm_le","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"E : Type u\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : Real → E\nf' : E\ns : Set Real\nx r : Real\nhf : HasDerivWithinAt f f' s x\nhr : LT.lt (Norm.norm f') r\n⊢ Filter.Eventually (fun z => LT.lt (HMul.hMul (Inv.inv (Norm.norm (HSub.hSub z x))) (HSub.hSub (Norm.norm (f z)) (Norm.norm (f x)))) r) (nhdsWithin x s)","decl":"/-- If `f` has derivative `f'` within `s` at `x`, then for any `r > ‖f'‖` the ratio\n`(‖f z‖ - ‖f x‖) / ‖z - x‖` is less than `r` in some neighborhood of `x` within `s`.\nIn other words, the limit superior of this ratio as `z` tends to `x` along `s`\nis less than or equal to `‖f'‖`.\n\nThis lemma is a weaker version of `HasDerivWithinAt.limsup_norm_slope_le`\nwhere `‖f z‖ - ‖f x‖` is replaced by `‖f z - f x‖`. -/\ntheorem HasDerivWithinAt.limsup_slope_norm_le (hf : HasDerivWithinAt f f' s x) (hr : ‖f'‖ < r) :\n    ∀ᶠ z in 𝓝[s] x, ‖z - x‖⁻¹ * (‖f z‖ - ‖f x‖) < r := by\n  apply (hf.limsup_norm_slope_le hr).mono\n  intro z hz\n  refine lt_of_le_of_lt (mul_le_mul_of_nonneg_left (norm_sub_norm_le _ _) ?_) hz\n  exact inv_nonneg.2 (norm_nonneg _)\n\n"}
{"name":"HasDerivWithinAt.liminf_right_norm_slope_le","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"E : Type u\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : Real → E\nf' : E\nx r : Real\nhf : HasDerivWithinAt f f' (Set.Ici x) x\nhr : LT.lt (Norm.norm f') r\n⊢ Filter.Frequently (fun z => LT.lt (HMul.hMul (Inv.inv (Norm.norm (HSub.hSub z x))) (Norm.norm (HSub.hSub (f z) (f x)))) r) (nhdsWithin x (Set.Ioi x))","decl":"/-- If `f` has derivative `f'` within `(x, +∞)` at `x`, then for any `r > ‖f'‖` the ratio\n`‖f z - f x‖ / ‖z - x‖` is frequently less than `r` as `z → x+0`.\nIn other words, the limit inferior of this ratio as `z` tends to `x+0`\nis less than or equal to `‖f'‖`. See also `HasDerivWithinAt.limsup_norm_slope_le`\nfor a stronger version using limit superior and any set `s`. -/\ntheorem HasDerivWithinAt.liminf_right_norm_slope_le (hf : HasDerivWithinAt f f' (Ici x) x)\n    (hr : ‖f'‖ < r) : ∃ᶠ z in 𝓝[>] x, ‖z - x‖⁻¹ * ‖f z - f x‖ < r :=\n  (hf.Ioi_of_Ici.limsup_norm_slope_le hr).frequently\n\n"}
{"name":"HasDerivWithinAt.liminf_right_slope_norm_le","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"E : Type u\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : Real → E\nf' : E\nx r : Real\nhf : HasDerivWithinAt f f' (Set.Ici x) x\nhr : LT.lt (Norm.norm f') r\n⊢ Filter.Frequently (fun z => LT.lt (HMul.hMul (Inv.inv (HSub.hSub z x)) (HSub.hSub (Norm.norm (f z)) (Norm.norm (f x)))) r) (nhdsWithin x (Set.Ioi x))","decl":"/-- If `f` has derivative `f'` within `(x, +∞)` at `x`, then for any `r > ‖f'‖` the ratio\n`(‖f z‖ - ‖f x‖) / (z - x)` is frequently less than `r` as `z → x+0`.\nIn other words, the limit inferior of this ratio as `z` tends to `x+0`\nis less than or equal to `‖f'‖`.\n\nSee also\n\n* `HasDerivWithinAt.limsup_norm_slope_le` for a stronger version using\n  limit superior and any set `s`;\n* `HasDerivWithinAt.liminf_right_norm_slope_le` for a stronger version using\n  `‖f z - f xp‖` instead of `‖f z‖ - ‖f x‖`. -/\ntheorem HasDerivWithinAt.liminf_right_slope_norm_le (hf : HasDerivWithinAt f f' (Ici x) x)\n    (hr : ‖f'‖ < r) : ∃ᶠ z in 𝓝[>] x, (z - x)⁻¹ * (‖f z‖ - ‖f x‖) < r := by\n  have := (hf.Ioi_of_Ici.limsup_slope_norm_le hr).frequently\n  refine this.mp (Eventually.mono self_mem_nhdsWithin fun z hxz hz ↦ ?_)\n  rwa [Real.norm_eq_abs, abs_of_pos (sub_pos_of_lt hxz)] at hz\n\n"}
