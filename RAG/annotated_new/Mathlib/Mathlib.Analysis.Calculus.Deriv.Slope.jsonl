{"name":"hasDerivAtFilter_iff_tendsto_slope","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\nf' : F\nx : ğ•œ\nL : Filter ğ•œ\nâŠ¢ Iff (HasDerivAtFilter f f' x L) (Filter.Tendsto (slope f x) (Min.min L (Filter.principal (HasCompl.compl (Singleton.singleton x)))) (nhds f'))","decl":"/-- If the domain has dimension one, then FrÃ©chet derivative is equivalent to the classical\ndefinition with a limit. In this version we have to take the limit along the subset `-{x}`,\nbecause for `y=x` the slope equals zero due to the convention `0â»Â¹=0`. -/\ntheorem hasDerivAtFilter_iff_tendsto_slope {x : ğ•œ} {L : Filter ğ•œ} :\n    HasDerivAtFilter f f' x L â†” Tendsto (slope f x) (L âŠ“ ğ“Ÿ {x}á¶œ) (ğ“ f') :=\n  calc HasDerivAtFilter f f' x L\n    â†” Tendsto (fun y â†¦ slope f x y - (y - x)â»Â¹ â€¢ (y - x) â€¢ f') L (ğ“ 0) := by\n        simp only [hasDerivAtFilter_iff_tendsto, â† norm_inv, â† norm_smul,\n          â† tendsto_zero_iff_norm_tendsto_zero, slope_def_module, smul_sub]\n  _ â†” Tendsto (fun y â†¦ slope f x y - (y - x)â»Â¹ â€¢ (y - x) â€¢ f') (L âŠ“ ğ“Ÿ {x}á¶œ) (ğ“ 0) :=\n        .symm <| tendsto_inf_principal_nhds_iff_of_forall_eq <| by simp\n  _ â†” Tendsto (fun y â†¦ slope f x y - f') (L âŠ“ ğ“Ÿ {x}á¶œ) (ğ“ 0) := tendsto_congr' <| by\n        refine (EqOn.eventuallyEq fun y hy â†¦ ?_).filter_mono inf_le_right\n        rw [inv_smul_smulâ‚€ (sub_ne_zero.2 hy) f']\n  _ â†” Tendsto (slope f x) (L âŠ“ ğ“Ÿ {x}á¶œ) (ğ“ f') := by\n        rw [â† nhds_translation_sub f', tendsto_comap_iff]; rfl\n\n"}
{"name":"hasDerivWithinAt_iff_tendsto_slope","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\nf' : F\nx : ğ•œ\ns : Set ğ•œ\nâŠ¢ Iff (HasDerivWithinAt f f' s x) (Filter.Tendsto (slope f x) (nhdsWithin x (SDiff.sdiff s (Singleton.singleton x))) (nhds f'))","decl":"theorem hasDerivWithinAt_iff_tendsto_slope :\n    HasDerivWithinAt f f' s x â†” Tendsto (slope f x) (ğ“[s \\ {x}] x) (ğ“ f') := by\n  simp only [HasDerivWithinAt, nhdsWithin, diff_eq, â† inf_assoc, inf_principal.symm]\n  exact hasDerivAtFilter_iff_tendsto_slope\n\n"}
{"name":"hasDerivWithinAt_iff_tendsto_slope'","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\nf' : F\nx : ğ•œ\ns : Set ğ•œ\nhs : Not (Membership.mem s x)\nâŠ¢ Iff (HasDerivWithinAt f f' s x) (Filter.Tendsto (slope f x) (nhdsWithin x s) (nhds f'))","decl":"theorem hasDerivWithinAt_iff_tendsto_slope' (hs : x âˆ‰ s) :\n    HasDerivWithinAt f f' s x â†” Tendsto (slope f x) (ğ“[s] x) (ğ“ f') := by\n  rw [hasDerivWithinAt_iff_tendsto_slope, diff_singleton_eq_self hs]\n\n"}
{"name":"hasDerivAt_iff_tendsto_slope","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\nf' : F\nx : ğ•œ\nâŠ¢ Iff (HasDerivAt f f' x) (Filter.Tendsto (slope f x) (nhdsWithin x (HasCompl.compl (Singleton.singleton x))) (nhds f'))","decl":"theorem hasDerivAt_iff_tendsto_slope : HasDerivAt f f' x â†” Tendsto (slope f x) (ğ“[â‰ ] x) (ğ“ f') :=\n  hasDerivAtFilter_iff_tendsto_slope\n\n"}
{"name":"hasDerivAt_iff_tendsto_slope_zero","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\nf' : F\nx : ğ•œ\nâŠ¢ Iff (HasDerivAt f f' x) (Filter.Tendsto (fun t => HSMul.hSMul (Inv.inv t) (HSub.hSub (f (HAdd.hAdd x t)) (f x))) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))) (nhds f'))","decl":"theorem hasDerivAt_iff_tendsto_slope_zero :\n    HasDerivAt f f' x â†” Tendsto (fun t â†¦ tâ»Â¹ â€¢ (f (x + t) - f x)) (ğ“[â‰ ] 0) (ğ“ f') := by\n  have : ğ“[â‰ ] x = Filter.map (fun t â†¦ x + t) (ğ“[â‰ ] 0) := by\n    simp [nhdsWithin, map_add_left_nhds_zero x, Filter.map_inf, add_right_injective x]\n  simp [hasDerivAt_iff_tendsto_slope, this, slope, Function.comp_def]\n\n"}
{"name":"HasDerivAt.tendsto_slope_zero","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\nf' : F\nx : ğ•œ\naâœ : HasDerivAt f f' x\nâŠ¢ Filter.Tendsto (fun t => HSMul.hSMul (Inv.inv t) (HSub.hSub (f (HAdd.hAdd x t)) (f x))) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))) (nhds f')","decl":"alias âŸ¨HasDerivAt.tendsto_slope_zero, _âŸ© := hasDerivAt_iff_tendsto_slope_zero\n\n"}
{"name":"HasDerivAt.tendsto_slope_zero_right","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"ğ•œ : Type u\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\nf' : F\nx : ğ•œ\ninstâœ : PartialOrder ğ•œ\nh : HasDerivAt f f' x\nâŠ¢ Filter.Tendsto (fun t => HSMul.hSMul (Inv.inv t) (HSub.hSub (f (HAdd.hAdd x t)) (f x))) (nhdsWithin 0 (Set.Ioi 0)) (nhds f')","decl":"theorem HasDerivAt.tendsto_slope_zero_right [PartialOrder ğ•œ] (h : HasDerivAt f f' x) :\n    Tendsto (fun t â†¦ tâ»Â¹ â€¢ (f (x + t) - f x)) (ğ“[>] 0) (ğ“ f') :=\n  h.tendsto_slope_zero.mono_left (nhdsGT_le_nhdsNE 0)\n\n"}
{"name":"HasDerivAt.tendsto_slope_zero_left","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"ğ•œ : Type u\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\nf' : F\nx : ğ•œ\ninstâœ : PartialOrder ğ•œ\nh : HasDerivAt f f' x\nâŠ¢ Filter.Tendsto (fun t => HSMul.hSMul (Inv.inv t) (HSub.hSub (f (HAdd.hAdd x t)) (f x))) (nhdsWithin 0 (Set.Iio 0)) (nhds f')","decl":"theorem HasDerivAt.tendsto_slope_zero_left [PartialOrder ğ•œ] (h : HasDerivAt f f' x) :\n    Tendsto (fun t â†¦ tâ»Â¹ â€¢ (f (x + t) - f x)) (ğ“[<] 0) (ğ“ f') :=\n  h.tendsto_slope_zero.mono_left (nhdsLT_le_nhdsNE 0)\n\n"}
{"name":"range_derivWithin_subset_closure_span_image","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\ns t : Set ğ•œ\nh : HasSubset.Subset s (closure (Inter.inter s t))\nâŠ¢ HasSubset.Subset (Set.range (derivWithin f s)) (closure â†‘(Submodule.span ğ•œ (Set.image f t)))","decl":"/-- Given a set `t` such that `s âˆ© t` is dense in `s`, then the range of `derivWithin f s` is\ncontained in the closure of the submodule spanned by the image of `t`. -/\ntheorem range_derivWithin_subset_closure_span_image\n    (f : ğ•œ â†’ F) {s t : Set ğ•œ} (h : s âŠ† closure (s âˆ© t)) :\n    range (derivWithin f s) âŠ† closure (Submodule.span ğ•œ (f '' t)) := by\n  rintro - âŸ¨x, rflâŸ©\n  rcases eq_or_neBot (ğ“[s \\ {x}] x) with H|H\n  Â· simpa [derivWithin_zero_of_isolated H] using subset_closure (zero_mem _)\n  by_cases H' : DifferentiableWithinAt ğ•œ f s x; swap\n  Â· rw [derivWithin_zero_of_not_differentiableWithinAt H']\n    exact subset_closure (zero_mem _)\n  have I : (ğ“[(s âˆ© t) \\ {x}] x).NeBot := by\n    rw [â† mem_closure_iff_nhdsWithin_neBot] at H âŠ¢\n    have A : closure (s \\ {x}) âŠ† closure (closure (s âˆ© t) \\ {x}) :=\n      closure_mono (diff_subset_diff_left h)\n    have B : closure (s âˆ© t) \\ {x} âŠ† closure ((s âˆ© t) \\ {x}) := by\n      convert closure_diff; exact closure_singleton.symm\n    simpa using A.trans (closure_mono B) H\n  have : Tendsto (slope f x) (ğ“[(s âˆ© t) \\ {x}] x) (ğ“ (derivWithin f s x)) := by\n    apply Tendsto.mono_left (hasDerivWithinAt_iff_tendsto_slope.1 H'.hasDerivWithinAt)\n    rw [inter_comm, inter_diff_assoc]\n    exact nhdsWithin_mono _ inter_subset_right\n  rw [â† closure_closure, â† Submodule.topologicalClosure_coe]\n  apply mem_closure_of_tendsto this\n  filter_upwards [self_mem_nhdsWithin] with y hy\n  simp only [slope, vsub_eq_sub, SetLike.mem_coe]\n  refine Submodule.smul_mem _ _ (Submodule.sub_mem _ ?_ ?_)\n  Â· apply Submodule.le_topologicalClosure\n    apply Submodule.subset_span\n    exact mem_image_of_mem _ hy.1.2\n  Â· apply Submodule.closure_subset_topologicalClosure_span\n    suffices A : f x âˆˆ closure (f '' (s âˆ© t)) from\n      closure_mono (image_subset _ inter_subset_right) A\n    apply ContinuousWithinAt.mem_closure_image\n    Â· apply H'.continuousWithinAt.mono inter_subset_left\n    rw [mem_closure_iff_nhdsWithin_neBot]\n    exact I.mono (nhdsWithin_mono _ diff_subset)\n\n"}
{"name":"range_deriv_subset_closure_span_image","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\nt : Set ğ•œ\nh : Dense t\nâŠ¢ HasSubset.Subset (Set.range (deriv f)) (closure â†‘(Submodule.span ğ•œ (Set.image f t)))","decl":"/-- Given a dense set `t`, then the range of `deriv f` is contained in the closure of the submodule\nspanned by the image of `t`. -/\ntheorem range_deriv_subset_closure_span_image\n    (f : ğ•œ â†’ F) {t : Set ğ•œ} (h : Dense t) :\n    range (deriv f) âŠ† closure (Submodule.span ğ•œ (f '' t)) := by\n  rw [â† derivWithin_univ]\n  apply range_derivWithin_subset_closure_span_image\n  simp [dense_iff_closure_eq.1 h]\n\n"}
{"name":"isSeparable_range_derivWithin","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"ğ•œ : Type u\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : TopologicalSpace.SeparableSpace ğ•œ\nf : ğ•œ â†’ F\ns : Set ğ•œ\nâŠ¢ TopologicalSpace.IsSeparable (Set.range (derivWithin f s))","decl":"theorem isSeparable_range_derivWithin [SeparableSpace ğ•œ] (f : ğ•œ â†’ F) (s : Set ğ•œ) :\n    IsSeparable (range (derivWithin f s)) := by\n  obtain âŸ¨t, ts, t_count, htâŸ© : âˆƒ t, t âŠ† s âˆ§ Set.Countable t âˆ§ s âŠ† closure t :=\n    (IsSeparable.of_separableSpace s).exists_countable_dense_subset\n  have : s âŠ† closure (s âˆ© t) := by rwa [inter_eq_self_of_subset_right ts]\n  apply IsSeparable.mono _ (range_derivWithin_subset_closure_span_image f this)\n  exact (Countable.image t_count f).isSeparable.span.closure\n\n"}
{"name":"isSeparable_range_deriv","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"ğ•œ : Type u\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nF : Type v\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : TopologicalSpace.SeparableSpace ğ•œ\nf : ğ•œ â†’ F\nâŠ¢ TopologicalSpace.IsSeparable (Set.range (deriv f))","decl":"theorem isSeparable_range_deriv [SeparableSpace ğ•œ] (f : ğ•œ â†’ F) :\n    IsSeparable (range (deriv f)) := by\n  rw [â† derivWithin_univ]\n  exact isSeparable_range_derivWithin _ _\n\n"}
{"name":"HasDerivAt.continuousAt_div","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"ğ•œ : Type u\ninstâœÂ¹ : NontriviallyNormedField ğ•œ\ninstâœ : DecidableEq ğ•œ\nf : ğ•œ â†’ ğ•œ\nc a : ğ•œ\nhf : HasDerivAt f a c\nâŠ¢ ContinuousAt (Function.update (fun x => HDiv.hDiv (HSub.hSub (f x) (f c)) (HSub.hSub x c)) c a) c","decl":"lemma HasDerivAt.continuousAt_div [DecidableEq ğ•œ] {f : ğ•œ â†’ ğ•œ} {c a : ğ•œ} (hf : HasDerivAt f a c) :\n    ContinuousAt (Function.update (fun x â†¦ (f x - f c) / (x - c)) c a) c := by\n  rw [â† slope_fun_def_field]\n  exact continuousAt_update_same.mpr <| hasDerivAt_iff_tendsto_slope.mp hf\n\n"}
{"name":"HasDerivWithinAt.limsup_slope_le","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"f : Real â†’ Real\nf' : Real\ns : Set Real\nx r : Real\nhf : HasDerivWithinAt f f' s x\nhr : LT.lt f' r\nâŠ¢ Filter.Eventually (fun z => LT.lt (slope f x z) r) (nhdsWithin x (SDiff.sdiff s (Singleton.singleton x)))","decl":"theorem HasDerivWithinAt.limsup_slope_le (hf : HasDerivWithinAt f f' s x) (hr : f' < r) :\n    âˆ€á¶  z in ğ“[s \\ {x}] x, slope f x z < r :=\n  hasDerivWithinAt_iff_tendsto_slope.1 hf (IsOpen.mem_nhds isOpen_Iio hr)\n\n"}
{"name":"HasDerivWithinAt.limsup_slope_le'","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"f : Real â†’ Real\nf' : Real\ns : Set Real\nx r : Real\nhf : HasDerivWithinAt f f' s x\nhs : Not (Membership.mem s x)\nhr : LT.lt f' r\nâŠ¢ Filter.Eventually (fun z => LT.lt (slope f x z) r) (nhdsWithin x s)","decl":"theorem HasDerivWithinAt.limsup_slope_le' (hf : HasDerivWithinAt f f' s x) (hs : x âˆ‰ s)\n    (hr : f' < r) : âˆ€á¶  z in ğ“[s] x, slope f x z < r :=\n  (hasDerivWithinAt_iff_tendsto_slope' hs).1 hf (IsOpen.mem_nhds isOpen_Iio hr)\n\n"}
{"name":"HasDerivWithinAt.liminf_right_slope_le","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"f : Real â†’ Real\nf' x r : Real\nhf : HasDerivWithinAt f f' (Set.Ici x) x\nhr : LT.lt f' r\nâŠ¢ Filter.Frequently (fun z => LT.lt (slope f x z) r) (nhdsWithin x (Set.Ioi x))","decl":"theorem HasDerivWithinAt.liminf_right_slope_le (hf : HasDerivWithinAt f f' (Ici x) x)\n    (hr : f' < r) : âˆƒá¶  z in ğ“[>] x, slope f x z < r :=\n  (hf.Ioi_of_Ici.limsup_slope_le' (lt_irrefl x) hr).frequently\n\n"}
{"name":"HasDerivWithinAt.limsup_norm_slope_le","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"E : Type u\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : Real â†’ E\nf' : E\ns : Set Real\nx r : Real\nhf : HasDerivWithinAt f f' s x\nhr : LT.lt (Norm.norm f') r\nâŠ¢ Filter.Eventually (fun z => LT.lt (HMul.hMul (Inv.inv (Norm.norm (HSub.hSub z x))) (Norm.norm (HSub.hSub (f z) (f x)))) r) (nhdsWithin x s)","decl":"/-- If `f` has derivative `f'` within `s` at `x`, then for any `r > â€–f'â€–` the ratio\n`â€–f z - f xâ€– / â€–z - xâ€–` is less than `r` in some neighborhood of `x` within `s`.\nIn other words, the limit superior of this ratio as `z` tends to `x` along `s`\nis less than or equal to `â€–f'â€–`. -/\ntheorem HasDerivWithinAt.limsup_norm_slope_le (hf : HasDerivWithinAt f f' s x) (hr : â€–f'â€– < r) :\n    âˆ€á¶  z in ğ“[s] x, â€–z - xâ€–â»Â¹ * â€–f z - f xâ€– < r := by\n  have hrâ‚€ : 0 < r := lt_of_le_of_lt (norm_nonneg f') hr\n  have A : âˆ€á¶  z in ğ“[s \\ {x}] x, â€–(z - x)â»Â¹ â€¢ (f z - f x)â€– âˆˆ Iio r :=\n    (hasDerivWithinAt_iff_tendsto_slope.1 hf).norm (IsOpen.mem_nhds isOpen_Iio hr)\n  have B : âˆ€á¶  z in ğ“[{x}] x, â€–(z - x)â»Â¹ â€¢ (f z - f x)â€– âˆˆ Iio r :=\n    mem_of_superset self_mem_nhdsWithin (singleton_subset_iff.2 <| by simp [hrâ‚€])\n  have C := mem_sup.2 âŸ¨A, BâŸ©\n  rw [â† nhdsWithin_union, diff_union_self, nhdsWithin_union, mem_sup] at C\n  filter_upwards [C.1]\n  simp only [norm_smul, mem_Iio, norm_inv]\n  exact fun _ => id\n\n"}
{"name":"HasDerivWithinAt.limsup_slope_norm_le","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"E : Type u\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : Real â†’ E\nf' : E\ns : Set Real\nx r : Real\nhf : HasDerivWithinAt f f' s x\nhr : LT.lt (Norm.norm f') r\nâŠ¢ Filter.Eventually (fun z => LT.lt (HMul.hMul (Inv.inv (Norm.norm (HSub.hSub z x))) (HSub.hSub (Norm.norm (f z)) (Norm.norm (f x)))) r) (nhdsWithin x s)","decl":"/-- If `f` has derivative `f'` within `s` at `x`, then for any `r > â€–f'â€–` the ratio\n`(â€–f zâ€– - â€–f xâ€–) / â€–z - xâ€–` is less than `r` in some neighborhood of `x` within `s`.\nIn other words, the limit superior of this ratio as `z` tends to `x` along `s`\nis less than or equal to `â€–f'â€–`.\n\nThis lemma is a weaker version of `HasDerivWithinAt.limsup_norm_slope_le`\nwhere `â€–f zâ€– - â€–f xâ€–` is replaced by `â€–f z - f xâ€–`. -/\ntheorem HasDerivWithinAt.limsup_slope_norm_le (hf : HasDerivWithinAt f f' s x) (hr : â€–f'â€– < r) :\n    âˆ€á¶  z in ğ“[s] x, â€–z - xâ€–â»Â¹ * (â€–f zâ€– - â€–f xâ€–) < r := by\n  apply (hf.limsup_norm_slope_le hr).mono\n  intro z hz\n  refine lt_of_le_of_lt (mul_le_mul_of_nonneg_left (norm_sub_norm_le _ _) ?_) hz\n  exact inv_nonneg.2 (norm_nonneg _)\n\n"}
{"name":"HasDerivWithinAt.liminf_right_norm_slope_le","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"E : Type u\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : Real â†’ E\nf' : E\nx r : Real\nhf : HasDerivWithinAt f f' (Set.Ici x) x\nhr : LT.lt (Norm.norm f') r\nâŠ¢ Filter.Frequently (fun z => LT.lt (HMul.hMul (Inv.inv (Norm.norm (HSub.hSub z x))) (Norm.norm (HSub.hSub (f z) (f x)))) r) (nhdsWithin x (Set.Ioi x))","decl":"/-- If `f` has derivative `f'` within `(x, +âˆ)` at `x`, then for any `r > â€–f'â€–` the ratio\n`â€–f z - f xâ€– / â€–z - xâ€–` is frequently less than `r` as `z â†’ x+0`.\nIn other words, the limit inferior of this ratio as `z` tends to `x+0`\nis less than or equal to `â€–f'â€–`. See also `HasDerivWithinAt.limsup_norm_slope_le`\nfor a stronger version using limit superior and any set `s`. -/\ntheorem HasDerivWithinAt.liminf_right_norm_slope_le (hf : HasDerivWithinAt f f' (Ici x) x)\n    (hr : â€–f'â€– < r) : âˆƒá¶  z in ğ“[>] x, â€–z - xâ€–â»Â¹ * â€–f z - f xâ€– < r :=\n  (hf.Ioi_of_Ici.limsup_norm_slope_le hr).frequently\n\n"}
{"name":"HasDerivWithinAt.liminf_right_slope_norm_le","module":"Mathlib.Analysis.Calculus.Deriv.Slope","initialProofState":"E : Type u\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : Real â†’ E\nf' : E\nx r : Real\nhf : HasDerivWithinAt f f' (Set.Ici x) x\nhr : LT.lt (Norm.norm f') r\nâŠ¢ Filter.Frequently (fun z => LT.lt (HMul.hMul (Inv.inv (HSub.hSub z x)) (HSub.hSub (Norm.norm (f z)) (Norm.norm (f x)))) r) (nhdsWithin x (Set.Ioi x))","decl":"/-- If `f` has derivative `f'` within `(x, +âˆ)` at `x`, then for any `r > â€–f'â€–` the ratio\n`(â€–f zâ€– - â€–f xâ€–) / (z - x)` is frequently less than `r` as `z â†’ x+0`.\nIn other words, the limit inferior of this ratio as `z` tends to `x+0`\nis less than or equal to `â€–f'â€–`.\n\nSee also\n\n* `HasDerivWithinAt.limsup_norm_slope_le` for a stronger version using\n  limit superior and any set `s`;\n* `HasDerivWithinAt.liminf_right_norm_slope_le` for a stronger version using\n  `â€–f z - f xpâ€–` instead of `â€–f zâ€– - â€–f xâ€–`. -/\ntheorem HasDerivWithinAt.liminf_right_slope_norm_le (hf : HasDerivWithinAt f f' (Ici x) x)\n    (hr : â€–f'â€– < r) : âˆƒá¶  z in ğ“[>] x, (z - x)â»Â¹ * (â€–f zâ€– - â€–f xâ€–) < r := by\n  have := (hf.Ioi_of_Ici.limsup_slope_norm_le hr).frequently\n  refine this.mp (Eventually.mono self_mem_nhdsWithin fun z hxz hz â†¦ ?_)\n  rwa [Real.norm_eq_abs, abs_of_pos (sub_pos_of_lt hxz)] at hz\n\n"}
