{"name":"Summable.norm_lt_one","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"F : Type u_1\ninst✝¹ : NormedField F\ninst✝ : CompleteSpace F\nf : MonoidHom Nat F\nhsum : Summable ⇑f\np : Nat\nhp : LT.lt 1 p\n⊢ LT.lt (Norm.norm (f p)) 1","decl":"/-- If `f` is multiplicative and summable, then its values at natural numbers `> 1`\nhave norm strictly less than `1`. -/\nlemma Summable.norm_lt_one {F : Type*} [NormedField F] [CompleteSpace F] {f : ℕ →* F}\n    (hsum : Summable f) {p : ℕ} (hp : 1 < p) :\n    ‖f p‖ < 1 := by\n  refine summable_geometric_iff_norm_lt_one.mp ?_\n  simp_rw [← map_pow]\n  exact hsum.comp_injective <| Nat.pow_right_injective hp\n\n"}
{"name":"EulerProduct.summable_and_hasSum_factoredNumbers_prod_filter_prime_tsum","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹ : NormedCommRing R\nf : Nat → R\ninst✝ : CompleteSpace R\nhf₁ : Eq (f 1) 1\nhmul : ∀ {m n : Nat}, m.Coprime n → Eq (f (HMul.hMul m n)) (HMul.hMul (f m) (f n))\nhsum : ∀ {p : Nat}, Nat.Prime p → Summable fun n => Norm.norm (f (HPow.hPow p n))\ns : Finset Nat\n⊢ And (Summable fun m => Norm.norm (f ↑m)) (HasSum (fun m => f ↑m) ((Finset.filter (fun p => Nat.Prime p) s).prod fun p => tsum fun n => f (HPow.hPow p n)))","decl":"include hf₁ hmul in\n/-- We relate a finite product over primes in `s` to an infinite sum over `s`-factored numbers. -/\nlemma summable_and_hasSum_factoredNumbers_prod_filter_prime_tsum\n    (hsum : ∀ {p : ℕ}, p.Prime → Summable (fun n : ℕ ↦ ‖f (p ^ n)‖)) (s : Finset ℕ) :\n    Summable (fun m : factoredNumbers s ↦ ‖f m‖) ∧\n      HasSum (fun m : factoredNumbers s ↦ f m)\n        (∏ p ∈ s with p.Prime, ∑' n : ℕ, f (p ^ n)) := by\n  induction' s using Finset.induction with p s hp ih\n  · rw [factoredNumbers_empty]\n    simp only [not_mem_empty, IsEmpty.forall_iff, forall_const, filter_true_of_mem, prod_empty]\n    exact ⟨(Set.finite_singleton 1).summable (‖f ·‖), hf₁ ▸ hasSum_singleton 1 f⟩\n  · rw [filter_insert]\n    split_ifs with hpp\n    · constructor\n      · simp only [← (equivProdNatFactoredNumbers hpp hp).summable_iff, Function.comp_def,\n          equivProdNatFactoredNumbers_apply', factoredNumbers.map_prime_pow_mul hmul hpp hp]\n        refine Summable.of_nonneg_of_le (fun _ ↦ norm_nonneg _) (fun _ ↦ norm_mul_le ..) ?_\n        apply Summable.mul_of_nonneg (hsum hpp) ih.1 <;> exact fun n ↦ norm_nonneg _\n      · have hp' : p ∉ {p ∈ s | p.Prime} := mt (mem_of_mem_filter p) hp\n        rw [prod_insert hp', ← (equivProdNatFactoredNumbers hpp hp).hasSum_iff, Function.comp_def]\n        conv =>\n          enter [1, x]\n          rw [equivProdNatFactoredNumbers_apply', factoredNumbers.map_prime_pow_mul hmul hpp hp]\n        have : T3Space R := instT3Space -- speeds up the following\n        apply (hsum hpp).of_norm.hasSum.mul ih.2\n        -- `exact summable_mul_of_summable_norm (hsum hpp) ih.1` gives a time-out\n        apply summable_mul_of_summable_norm (hsum hpp) ih.1\n    · rwa [factoredNumbers_insert s hpp]\n\n"}
{"name":"EulerProduct.prod_filter_prime_tsum_eq_tsum_factoredNumbers","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹ : NormedCommRing R\nf : Nat → R\ninst✝ : CompleteSpace R\nhf₁ : Eq (f 1) 1\nhmul : ∀ {m n : Nat}, m.Coprime n → Eq (f (HMul.hMul m n)) (HMul.hMul (f m) (f n))\nhsum : Summable fun x => Norm.norm (f x)\ns : Finset Nat\n⊢ Eq ((Finset.filter (fun p => Nat.Prime p) s).prod fun p => tsum fun n => f (HPow.hPow p n)) (tsum fun m => f ↑m)","decl":"include hf₁ hmul in\n/-- A version of `EulerProduct.summable_and_hasSum_factoredNumbers_prod_filter_prime_tsum`\nin terms of the value of the series. -/\nlemma prod_filter_prime_tsum_eq_tsum_factoredNumbers (hsum : Summable (‖f ·‖)) (s : Finset ℕ) :\n    ∏ p ∈ s with p.Prime, ∑' n : ℕ, f (p ^ n) = ∑' m : factoredNumbers s, f m :=\n  (summable_and_hasSum_factoredNumbers_prod_filter_prime_tsum hf₁ hmul\n    (fun hp ↦ hsum.comp_injective <| Nat.pow_right_injective hp.one_lt) _).2.tsum_eq.symm\n\n"}
{"name":"EulerProduct.norm_tsum_factoredNumbers_sub_tsum_lt","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹ : NormedCommRing R\nf : Nat → R\ninst✝ : CompleteSpace R\nhsum : Summable f\nhf₀ : Eq (f 0) 0\nε : Real\nεpos : LT.lt 0 ε\n⊢ Exists fun N => ∀ (s : Finset Nat), LE.le N.primesBelow s → LT.lt (Norm.norm (HSub.hSub (tsum fun m => f m) (tsum fun m => f ↑m))) ε","decl":"/-- The following statement says that summing over `s`-factored numbers such that\n`s` contains `primesBelow N` for large enough `N` gets us arbitrarily close to the sum\nover all natural numbers (assuming `f` is summable and `f 0 = 0`; the latter since\n`0` is not `s`-factored). -/\nlemma norm_tsum_factoredNumbers_sub_tsum_lt (hsum : Summable f) (hf₀ : f 0 = 0) {ε : ℝ}\n    (εpos : 0 < ε) :\n    ∃ N : ℕ, ∀ s : Finset ℕ, primesBelow N ≤ s →\n      ‖(∑' m : ℕ, f m) - ∑' m : factoredNumbers s, f m‖ < ε := by\n  obtain ⟨N, hN⟩ :=\n    summable_iff_nat_tsum_vanishing.mp hsum (Metric.ball 0 ε) <| Metric.ball_mem_nhds 0 εpos\n  simp_rw [mem_ball_zero_iff] at hN\n  refine ⟨N, fun s hs ↦ ?_⟩\n  have := hN _ <| factoredNumbers_compl hs\n  rwa [← tsum_subtype_add_tsum_subtype_compl hsum (factoredNumbers s),\n    add_sub_cancel_left, tsum_eq_tsum_diff_singleton (factoredNumbers s)ᶜ hf₀]\n\n-- Versions of the three lemmas above for `smoothNumbers N`\n\n"}
{"name":"EulerProduct.summable_and_hasSum_smoothNumbers_prod_primesBelow_tsum","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹ : NormedCommRing R\nf : Nat → R\ninst✝ : CompleteSpace R\nhf₁ : Eq (f 1) 1\nhmul : ∀ {m n : Nat}, m.Coprime n → Eq (f (HMul.hMul m n)) (HMul.hMul (f m) (f n))\nhsum : ∀ {p : Nat}, Nat.Prime p → Summable fun n => Norm.norm (f (HPow.hPow p n))\nN : Nat\n⊢ And (Summable fun m => Norm.norm (f ↑m)) (HasSum (fun m => f ↑m) (N.primesBelow.prod fun p => tsum fun n => f (HPow.hPow p n)))","decl":"include hf₁ hmul in\n/-- We relate a finite product over primes to an infinite sum over smooth numbers. -/\nlemma summable_and_hasSum_smoothNumbers_prod_primesBelow_tsum\n    (hsum : ∀ {p : ℕ}, p.Prime → Summable (fun n : ℕ ↦ ‖f (p ^ n)‖)) (N : ℕ) :\n    Summable (fun m : N.smoothNumbers ↦ ‖f m‖) ∧\n      HasSum (fun m : N.smoothNumbers ↦ f m) (∏ p ∈ N.primesBelow, ∑' n : ℕ, f (p ^ n)) := by\n  rw [smoothNumbers_eq_factoredNumbers, primesBelow]\n  exact summable_and_hasSum_factoredNumbers_prod_filter_prime_tsum hf₁ hmul hsum _\n\n"}
{"name":"EulerProduct.prod_primesBelow_tsum_eq_tsum_smoothNumbers","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹ : NormedCommRing R\nf : Nat → R\ninst✝ : CompleteSpace R\nhf₁ : Eq (f 1) 1\nhmul : ∀ {m n : Nat}, m.Coprime n → Eq (f (HMul.hMul m n)) (HMul.hMul (f m) (f n))\nhsum : Summable fun x => Norm.norm (f x)\nN : Nat\n⊢ Eq (N.primesBelow.prod fun p => tsum fun n => f (HPow.hPow p n)) (tsum fun m => f ↑m)","decl":"include hf₁ hmul in\n/-- A version of `EulerProduct.summable_and_hasSum_smoothNumbers_prod_primesBelow_tsum`\nin terms of the value of the series. -/\nlemma prod_primesBelow_tsum_eq_tsum_smoothNumbers (hsum : Summable (‖f ·‖)) (N : ℕ) :\n    ∏ p ∈ N.primesBelow, ∑' n : ℕ, f (p ^ n) = ∑' m : N.smoothNumbers, f m :=\n  (summable_and_hasSum_smoothNumbers_prod_primesBelow_tsum hf₁ hmul\n    (fun hp ↦ hsum.comp_injective <| Nat.pow_right_injective hp.one_lt) _).2.tsum_eq.symm\n\n"}
{"name":"EulerProduct.norm_tsum_smoothNumbers_sub_tsum_lt","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹ : NormedCommRing R\nf : Nat → R\ninst✝ : CompleteSpace R\nhsum : Summable f\nhf₀ : Eq (f 0) 0\nε : Real\nεpos : LT.lt 0 ε\n⊢ Exists fun N₀ => ∀ (N : Nat), GE.ge N N₀ → LT.lt (Norm.norm (HSub.hSub (tsum fun m => f m) (tsum fun m => f ↑m))) ε","decl":"/-- The following statement says that summing over `N`-smooth numbers\nfor large enough `N` gets us arbitrarily close to the sum over all natural numbers\n(assuming `f` is norm-summable and `f 0 = 0`; the latter since `0` is not smooth). -/\nlemma norm_tsum_smoothNumbers_sub_tsum_lt (hsum : Summable f) (hf₀ : f 0 = 0)\n    {ε : ℝ} (εpos : 0 < ε) :\n    ∃ N₀ : ℕ, ∀ N ≥ N₀, ‖(∑' m : ℕ, f m) - ∑' m : N.smoothNumbers, f m‖ < ε := by\n  conv => enter [1, N₀, N]; rw [smoothNumbers_eq_factoredNumbers]\n  obtain ⟨N₀, hN₀⟩ := norm_tsum_factoredNumbers_sub_tsum_lt hsum hf₀ εpos\n  refine ⟨N₀, fun N hN ↦ hN₀ (range N) fun p hp ↦ ?_⟩\n  exact mem_range.mpr <| (lt_of_mem_primesBelow hp).trans_le hN\n\n\n"}
{"name":"EulerProduct.eulerProduct_hasProd","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹ : NormedCommRing R\nf : Nat → R\ninst✝ : CompleteSpace R\nhf₁ : Eq (f 1) 1\nhmul : ∀ {m n : Nat}, m.Coprime n → Eq (f (HMul.hMul m n)) (HMul.hMul (f m) (f n))\nhsum : Summable fun x => Norm.norm (f x)\nhf₀ : Eq (f 0) 0\n⊢ HasProd (fun p => tsum fun e => f (HPow.hPow (↑p) e)) (tsum fun n => f n)","decl":"include hf₁ hmul in\n/-- The *Euler Product* for multiplicative (on coprime arguments) functions.\n\nIf `f : ℕ → R`, where `R` is a complete normed commutative ring, `f 0 = 0`, `f 1 = 1`, `f` is\nmultiplicative on coprime arguments, and `‖f ·‖` is summable, then\n`∏' p : Nat.Primes, ∑' e, f (p ^ e) = ∑' n, f n`. This version is stated using `HasProd`. -/\ntheorem eulerProduct_hasProd (hsum : Summable (‖f ·‖)) (hf₀ : f 0 = 0) :\n    HasProd (fun p : Primes ↦ ∑' e, f (p ^ e)) (∑' n, f n) := by\n  let F : ℕ → R := fun n ↦ ∑' e, f (n ^ e)\n  change HasProd (F ∘ Subtype.val) _\n  rw [hasProd_subtype_iff_mulIndicator,\n    show Set.mulIndicator (fun p : ℕ ↦ Irreducible p) =  {p | Nat.Prime p}.mulIndicator from rfl,\n    HasProd, Metric.tendsto_atTop]\n  intro ε hε\n  obtain ⟨N₀, hN₀⟩ := norm_tsum_factoredNumbers_sub_tsum_lt hsum.of_norm hf₀ hε\n  refine ⟨range N₀, fun s hs ↦ ?_⟩\n  have : ∏ p ∈ s, {p | Nat.Prime p}.mulIndicator F p = ∏ p ∈ s with p.Prime, F p :=\n    prod_mulIndicator_eq_prod_filter s (fun _ ↦ F) _ id\n  rw [this, dist_eq_norm, prod_filter_prime_tsum_eq_tsum_factoredNumbers hf₁ hmul hsum,\n    norm_sub_rev]\n  exact hN₀ s fun p hp ↦ hs <| mem_range.mpr <| lt_of_mem_primesBelow hp\n\n"}
{"name":"EulerProduct.eulerProduct_hasProd_mulIndicator","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹ : NormedCommRing R\nf : Nat → R\ninst✝ : CompleteSpace R\nhf₁ : Eq (f 1) 1\nhmul : ∀ {m n : Nat}, m.Coprime n → Eq (f (HMul.hMul m n)) (HMul.hMul (f m) (f n))\nhsum : Summable fun x => Norm.norm (f x)\nhf₀ : Eq (f 0) 0\n⊢ HasProd ((setOf fun p => Nat.Prime p).mulIndicator fun p => tsum fun e => f (HPow.hPow p e)) (tsum fun n => f n)","decl":"include hf₁ hmul in\n/-- The *Euler Product* for multiplicative (on coprime arguments) functions.\n\nIf `f : ℕ → R`, where `R` is a complete normed commutative ring, `f 0 = 0`, `f 1 = 1`, `f` i\nmultiplicative on coprime arguments, and `‖f ·‖` is summable, then\n`∏' p : ℕ, if p.Prime then ∑' e, f (p ^ e) else 1 = ∑' n, f n`.\nThis version is stated using `HasProd` and `Set.mulIndicator`. -/\ntheorem eulerProduct_hasProd_mulIndicator (hsum : Summable (‖f ·‖)) (hf₀ : f 0 = 0) :\n    HasProd (Set.mulIndicator {p | Nat.Prime p} fun p ↦  ∑' e, f (p ^ e)) (∑' n, f n) := by\n  rw [← hasProd_subtype_iff_mulIndicator]\n  exact eulerProduct_hasProd hf₁ hmul hsum hf₀\n\n"}
{"name":"EulerProduct.eulerProduct","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹ : NormedCommRing R\nf : Nat → R\ninst✝ : CompleteSpace R\nhf₁ : Eq (f 1) 1\nhmul : ∀ {m n : Nat}, m.Coprime n → Eq (f (HMul.hMul m n)) (HMul.hMul (f m) (f n))\nhsum : Summable fun x => Norm.norm (f x)\nhf₀ : Eq (f 0) 0\n⊢ Filter.Tendsto (fun n => n.primesBelow.prod fun p => tsum fun e => f (HPow.hPow p e)) Filter.atTop (nhds (tsum fun n => f n))","decl":"open Filter in\ninclude hf₁ hmul in\n/-- The *Euler Product* for multiplicative (on coprime arguments) functions.\n\nIf `f : ℕ → R`, where `R` is a complete normed commutative ring, `f 0 = 0`, `f 1 = 1`, `f` is\nmultiplicative on coprime arguments, and `‖f ·‖` is summable, then\n`∏' p : {p : ℕ | p.Prime}, ∑' e, f (p ^ e) = ∑' n, f n`.\nThis is a version using convergence of finite partial products. -/\ntheorem eulerProduct (hsum : Summable (‖f ·‖)) (hf₀ : f 0 = 0) :\n    Tendsto (fun n : ℕ ↦ ∏ p ∈ primesBelow n, ∑' e, f (p ^ e)) atTop (𝓝 (∑' n, f n)) := by\n  have := (eulerProduct_hasProd_mulIndicator hf₁ hmul hsum hf₀).tendsto_prod_nat\n  let F : ℕ → R := fun p ↦ ∑' (e : ℕ), f (p ^ e)\n  have H (n : ℕ) : ∏ i ∈ range n, Set.mulIndicator {p | Nat.Prime p} F i =\n                     ∏ p ∈ primesBelow n, ∑' (e : ℕ), f (p ^ e) :=\n    prod_mulIndicator_eq_prod_filter (range n) (fun _ ↦ F) (fun _ ↦ {p | Nat.Prime p}) id\n  simpa only [F, H]\n\n"}
{"name":"EulerProduct.eulerProduct_tprod","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹ : NormedCommRing R\nf : Nat → R\ninst✝ : CompleteSpace R\nhf₁ : Eq (f 1) 1\nhmul : ∀ {m n : Nat}, m.Coprime n → Eq (f (HMul.hMul m n)) (HMul.hMul (f m) (f n))\nhsum : Summable fun x => Norm.norm (f x)\nhf₀ : Eq (f 0) 0\n⊢ Eq (tprod fun p => tsum fun e => f (HPow.hPow (↑p) e)) (tsum fun n => f n)","decl":"include hf₁ hmul in\n/-- The *Euler Product* for multiplicative (on coprime arguments) functions.\n\nIf `f : ℕ → R`, where `R` is a complete normed commutative ring, `f 0 = 0`, `f 1 = 1`, `f` is\nmultiplicative on coprime arguments, and `‖f ·‖` is summable, then\n`∏' p : {p : ℕ | p.Prime}, ∑' e, f (p ^ e) = ∑' n, f n`. -/\ntheorem eulerProduct_tprod (hsum : Summable (‖f ·‖)) (hf₀ : f 0 = 0) :\n    ∏' p : Primes, ∑' e, f (p ^ e) = ∑' n, f n :=\n  (eulerProduct_hasProd hf₁ hmul hsum hf₀).tprod_eq\n\n"}
{"name":"ArithmeticFunction.IsMultiplicative.eulerProduct_hasProd","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹ : NormedCommRing R\ninst✝ : CompleteSpace R\nf : ArithmeticFunction R\nhf : f.IsMultiplicative\nhsum : Summable fun x => Norm.norm (f x)\n⊢ HasProd (fun p => tsum fun e => f (HPow.hPow (↑p) e)) (tsum fun n => f n)","decl":"/-- The *Euler Product* for a multiplicative arithmetic function `f` with values in a\ncomplete normed commutative ring `R`: if `‖f ·‖` is summable, then\n`∏' p : Nat.Primes, ∑' e, f (p ^ e) = ∑' n, f n`.\nThis version is stated in terms of `HasProd`. -/\nnonrec theorem IsMultiplicative.eulerProduct_hasProd {f : ArithmeticFunction R}\n    (hf : f.IsMultiplicative) (hsum : Summable (‖f ·‖)) :\n    HasProd (fun p : Primes ↦ ∑' e, f (p ^ e)) (∑' n, f n) :=\n  eulerProduct_hasProd hf.1 hf.2 hsum f.map_zero\n\n"}
{"name":"ArithmeticFunction.IsMultiplicative.eulerProduct","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹ : NormedCommRing R\ninst✝ : CompleteSpace R\nf : ArithmeticFunction R\nhf : f.IsMultiplicative\nhsum : Summable fun x => Norm.norm (f x)\n⊢ Filter.Tendsto (fun n => n.primesBelow.prod fun p => tsum fun e => f (HPow.hPow p e)) Filter.atTop (nhds (tsum fun n => f n))","decl":"open Filter in\n/-- The *Euler Product* for a multiplicative arithmetic function `f` with values in a\ncomplete normed commutative ring `R`: if `‖f ·‖` is summable, then\n`∏' p : Nat.Primes, ∑' e, f (p ^ e) = ∑' n, f n`.\nThis version is stated in the form of convergence of finite partial products. -/\nnonrec theorem IsMultiplicative.eulerProduct {f : ArithmeticFunction R} (hf : f.IsMultiplicative)\n    (hsum : Summable (‖f ·‖)) :\n    Tendsto (fun n : ℕ ↦ ∏ p ∈ primesBelow n, ∑' e, f (p ^ e)) atTop (𝓝 (∑' n, f n)) :=\n  eulerProduct hf.1 hf.2 hsum f.map_zero\n\n"}
{"name":"ArithmeticFunction.IsMultiplicative.eulerProduct_tprod","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹ : NormedCommRing R\ninst✝ : CompleteSpace R\nf : ArithmeticFunction R\nhf : f.IsMultiplicative\nhsum : Summable fun x => Norm.norm (f x)\n⊢ Eq (tprod fun p => tsum fun e => f (HPow.hPow (↑p) e)) (tsum fun n => f n)","decl":"/-- The *Euler Product* for a multiplicative arithmetic function `f` with values in a\ncomplete normed commutative ring `R`: if `‖f ·‖` is summable, then\n`∏' p : Nat.Primes, ∑' e, f (p ^ e) = ∑' n, f n`. -/\nnonrec theorem IsMultiplicative.eulerProduct_tprod {f : ArithmeticFunction R}\n    (hf : f.IsMultiplicative) (hsum : Summable (‖f ·‖)) :\n    ∏' p : Primes, ∑' e, f (p ^ e) = ∑' n, f n :=\n  eulerProduct_tprod hf.1 hf.2 hsum f.map_zero\n\n"}
{"name":"EulerProduct.one_sub_inv_eq_geometric_of_summable_norm","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"F : Type u_1\ninst✝¹ : NormedField F\ninst✝ : CompleteSpace F\nf : MonoidWithZeroHom Nat F\np : Nat\nhp : Nat.Prime p\nhsum : Summable fun x => Norm.norm (f x)\n⊢ Eq (Inv.inv (HSub.hSub 1 (f p))) (tsum fun e => f (HPow.hPow p e))","decl":"lemma one_sub_inv_eq_geometric_of_summable_norm {f : ℕ →*₀ F} {p : ℕ} (hp : p.Prime)\n    (hsum : Summable fun x ↦ ‖f x‖) :\n    (1 - f p)⁻¹ = ∑' (e : ℕ), f (p ^ e) := by\n  simp only [map_pow]\n  refine (tsum_geometric_of_norm_lt_one <| summable_geometric_iff_norm_lt_one.mp ?_).symm\n  refine Summable.of_norm ?_\n  simpa only [Function.comp_def, map_pow]\n    using hsum.comp_injective <| Nat.pow_right_injective hp.one_lt\n\n"}
{"name":"EulerProduct.summable_and_hasSum_factoredNumbers_prod_filter_prime_geometric","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"F : Type u_1\ninst✝¹ : NormedField F\ninst✝ : CompleteSpace F\nf : MonoidHom Nat F\nh : ∀ {p : Nat}, Nat.Prime p → LT.lt (Norm.norm (f p)) 1\ns : Finset Nat\n⊢ And (Summable fun m => Norm.norm (f ↑m)) (HasSum (fun m => f ↑m) ((Finset.filter (fun p => Nat.Prime p) s).prod fun p => Inv.inv (HSub.hSub 1 (f p))))","decl":"/-- Given a (completely) multiplicative function `f : ℕ → F`, where `F` is a normed field,\nsuch that `‖f p‖ < 1` for all primes `p`, we can express the sum of `f n` over all `s`-factored\npositive integers `n` as a product of `(1 - f p)⁻¹` over the primes `p ∈ s`. At the same time,\nwe show that the sum involved converges absolutely. -/\nlemma summable_and_hasSum_factoredNumbers_prod_filter_prime_geometric {f : ℕ →* F}\n    (h : ∀ {p : ℕ}, p.Prime → ‖f p‖ < 1) (s : Finset ℕ) :\n    Summable (fun m : factoredNumbers s ↦ ‖f m‖) ∧\n      HasSum (fun m : factoredNumbers s ↦ f m) (∏ p ∈ s with p.Prime, (1 - f p)⁻¹) := by\n  have hmul {m n} (_ : Nat.Coprime m n) := f.map_mul m n\n  have H₁ :\n      ∏ p ∈ s with p.Prime, ∑' n : ℕ, f (p ^ n) = ∏ p ∈ s with p.Prime, (1 - f p)⁻¹ := by\n    refine prod_congr rfl fun p hp ↦ ?_\n    simp only [map_pow]\n    exact tsum_geometric_of_norm_lt_one <| h (mem_filter.mp hp).2\n  have H₂ : ∀ {p : ℕ}, p.Prime → Summable fun n ↦ ‖f (p ^ n)‖ := by\n    intro p hp\n    simp only [map_pow]\n    refine Summable.of_nonneg_of_le (fun _ ↦ norm_nonneg _) (fun _ ↦ norm_pow_le ..) ?_\n    exact summable_geometric_iff_norm_lt_one.mpr <| (norm_norm (f p)).symm ▸ h hp\n  exact H₁ ▸ summable_and_hasSum_factoredNumbers_prod_filter_prime_tsum f.map_one hmul H₂ s\n\n"}
{"name":"EulerProduct.prod_filter_prime_geometric_eq_tsum_factoredNumbers","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"F : Type u_1\ninst✝¹ : NormedField F\ninst✝ : CompleteSpace F\nf : MonoidHom Nat F\nhsum : Summable ⇑f\ns : Finset Nat\n⊢ Eq ((Finset.filter (fun p => Nat.Prime p) s).prod fun p => Inv.inv (HSub.hSub 1 (f p))) (tsum fun m => f ↑m)","decl":"/-- A version of `EulerProduct.summable_and_hasSum_factoredNumbers_prod_filter_prime_geometric`\nin terms of the value of the series. -/\nlemma prod_filter_prime_geometric_eq_tsum_factoredNumbers {f : ℕ →* F} (hsum : Summable f)\n    (s : Finset ℕ) :\n    ∏ p ∈ s with p.Prime, (1 - f p)⁻¹ = ∑' m : factoredNumbers s, f m := by\n  refine (summable_and_hasSum_factoredNumbers_prod_filter_prime_geometric ?_ s).2.tsum_eq.symm\n  exact fun {_} hp ↦ hsum.norm_lt_one hp.one_lt\n\n"}
{"name":"EulerProduct.summable_and_hasSum_smoothNumbers_prod_primesBelow_geometric","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"F : Type u_1\ninst✝¹ : NormedField F\ninst✝ : CompleteSpace F\nf : MonoidHom Nat F\nh : ∀ {p : Nat}, Nat.Prime p → LT.lt (Norm.norm (f p)) 1\nN : Nat\n⊢ And (Summable fun m => Norm.norm (f ↑m)) (HasSum (fun m => f ↑m) (N.primesBelow.prod fun p => Inv.inv (HSub.hSub 1 (f p))))","decl":"/-- Given a (completely) multiplicative function `f : ℕ → F`, where `F` is a normed field,\nsuch that `‖f p‖ < 1` for all primes `p`, we can express the sum of `f n` over all `N`-smooth\npositive integers `n` as a product of `(1 - f p)⁻¹` over the primes `p < N`. At the same time,\nwe show that the sum involved converges absolutely. -/\nlemma summable_and_hasSum_smoothNumbers_prod_primesBelow_geometric {f : ℕ →* F}\n    (h : ∀ {p : ℕ}, p.Prime → ‖f p‖ < 1) (N : ℕ) :\n    Summable (fun m : N.smoothNumbers ↦ ‖f m‖) ∧\n      HasSum (fun m : N.smoothNumbers ↦ f m) (∏ p ∈ N.primesBelow, (1 - f p)⁻¹) := by\n  rw [smoothNumbers_eq_factoredNumbers, primesBelow]\n  exact summable_and_hasSum_factoredNumbers_prod_filter_prime_geometric h _\n\n"}
{"name":"EulerProduct.prod_primesBelow_geometric_eq_tsum_smoothNumbers","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"F : Type u_1\ninst✝¹ : NormedField F\ninst✝ : CompleteSpace F\nf : MonoidHom Nat F\nhsum : Summable ⇑f\nN : Nat\n⊢ Eq (N.primesBelow.prod fun p => Inv.inv (HSub.hSub 1 (f p))) (tsum fun m => f ↑m)","decl":"/-- A version of `EulerProduct.summable_and_hasSum_smoothNumbers_prod_primesBelow_geometric`\nin terms of the value of the series. -/\nlemma prod_primesBelow_geometric_eq_tsum_smoothNumbers {f : ℕ →* F} (hsum : Summable f) (N : ℕ) :\n    ∏ p ∈ N.primesBelow, (1 - f p)⁻¹ = ∑' m : N.smoothNumbers, f m := by\n  rw [smoothNumbers_eq_factoredNumbers, primesBelow]\n  exact prod_filter_prime_geometric_eq_tsum_factoredNumbers hsum _\n\n"}
{"name":"EulerProduct.eulerProduct_completely_multiplicative_hasProd","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"F : Type u_1\ninst✝¹ : NormedField F\ninst✝ : CompleteSpace F\nf : MonoidWithZeroHom Nat F\nhsum : Summable fun x => Norm.norm (f x)\n⊢ HasProd (fun p => Inv.inv (HSub.hSub 1 (f ↑p))) (tsum fun n => f n)","decl":"/-- The *Euler Product* for completely multiplicative functions.\n\nIf `f : ℕ →*₀ F`, where `F` is a complete normed field and `‖f ·‖` is summable, then\n`∏' p : Nat.Primes, (1 - f p)⁻¹ = ∑' n, f n`.\nThis version is stated in terms of `HasProd`. -/\ntheorem eulerProduct_completely_multiplicative_hasProd {f : ℕ →*₀ F} (hsum : Summable (‖f ·‖)) :\n    HasProd (fun p : Primes ↦ (1 - f p)⁻¹) (∑' n, f n) := by\n  have H : (fun p : Primes ↦ (1 - f p)⁻¹) = fun p : Primes ↦ ∑' (e : ℕ), f (p ^ e) :=\n    funext <| fun p ↦ one_sub_inv_eq_geometric_of_summable_norm p.prop hsum\n  simpa only [map_pow, H]\n    using eulerProduct_hasProd f.map_one (fun {m n} _ ↦ f.map_mul m n) hsum f.map_zero\n\n"}
{"name":"EulerProduct.eulerProduct_completely_multiplicative_tprod","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"F : Type u_1\ninst✝¹ : NormedField F\ninst✝ : CompleteSpace F\nf : MonoidWithZeroHom Nat F\nhsum : Summable fun x => Norm.norm (f x)\n⊢ Eq (tprod fun p => Inv.inv (HSub.hSub 1 (f ↑p))) (tsum fun n => f n)","decl":"/-- The *Euler Product* for completely multiplicative functions.\n\nIf `f : ℕ →*₀ F`, where `F` is a complete normed field and `‖f ·‖` is summable, then\n`∏' p : Nat.Primes, (1 - f p)⁻¹ = ∑' n, f n`. -/\ntheorem eulerProduct_completely_multiplicative_tprod {f : ℕ →*₀ F} (hsum : Summable (‖f ·‖)) :\n    ∏' p : Primes, (1 - f p)⁻¹ = ∑' n, f n :=\n  (eulerProduct_completely_multiplicative_hasProd hsum).tprod_eq\n\n"}
{"name":"EulerProduct.eulerProduct_completely_multiplicative","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"F : Type u_1\ninst✝¹ : NormedField F\ninst✝ : CompleteSpace F\nf : MonoidWithZeroHom Nat F\nhsum : Summable fun x => Norm.norm (f x)\n⊢ Filter.Tendsto (fun n => n.primesBelow.prod fun p => Inv.inv (HSub.hSub 1 (f p))) Filter.atTop (nhds (tsum fun n => f n))","decl":"open Filter in\n/-- The *Euler Product* for completely multiplicative functions.\n\nIf `f : ℕ →*₀ F`, where `F` is a complete normed field and `‖f ·‖` is summable, then\n`∏' p : Nat.Primes, (1 - f p)⁻¹ = ∑' n, f n`.\nThis version is stated in the form of convergence of finite partial products. -/\ntheorem eulerProduct_completely_multiplicative {f : ℕ →*₀ F} (hsum : Summable (‖f ·‖)) :\n    Tendsto (fun n : ℕ ↦ ∏ p ∈ primesBelow n, (1 - f p)⁻¹) atTop (𝓝 (∑' n, f n)) := by\n  have hmul {m n} (_ : Nat.Coprime m n) := f.map_mul m n\n  have := (eulerProduct_hasProd_mulIndicator f.map_one hmul hsum f.map_zero).tendsto_prod_nat\n  have H (n : ℕ) : ∏ p ∈ range n, {p | Nat.Prime p}.mulIndicator (fun p ↦ (1 - f p)⁻¹) p =\n                     ∏ p ∈ primesBelow n, (1 - f p)⁻¹ :=\n    prod_mulIndicator_eq_prod_filter\n      (range n) (fun _ ↦ fun p ↦ (1 - f p)⁻¹) (fun _ ↦ {p | Nat.Prime p}) id\n  have H' : {p | Nat.Prime p}.mulIndicator (fun p ↦ (1 - f p)⁻¹) =\n              {p | Nat.Prime p}.mulIndicator (fun p ↦ ∑' e : ℕ, f (p ^ e)) :=\n    Set.mulIndicator_congr fun p hp ↦ one_sub_inv_eq_geometric_of_summable_norm hp hsum\n  simpa only [← H, H'] using this\n\n"}
