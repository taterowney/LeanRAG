{"name":"Summable.norm_lt_one","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"F : Type u_1\ninstâœÂ¹ : NormedField F\ninstâœ : CompleteSpace F\nf : MonoidHom Nat F\nhsum : Summable â‡‘f\np : Nat\nhp : LT.lt 1 p\nâŠ¢ LT.lt (Norm.norm (f p)) 1","decl":"/-- If `f` is multiplicative and summable, then its values at natural numbers `> 1`\nhave norm strictly less than `1`. -/\nlemma Summable.norm_lt_one {F : Type*} [NormedField F] [CompleteSpace F] {f : â„• â†’* F}\n    (hsum : Summable f) {p : â„•} (hp : 1 < p) :\n    â€–f pâ€– < 1 := by\n  refine summable_geometric_iff_norm_lt_one.mp ?_\n  simp_rw [â† map_pow]\n  exact hsum.comp_injective <| Nat.pow_right_injective hp\n\n"}
{"name":"EulerProduct.summable_and_hasSum_factoredNumbers_prod_filter_prime_tsum","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"R : Type u_1\ninstâœÂ¹ : NormedCommRing R\nf : Nat â†’ R\ninstâœ : CompleteSpace R\nhfâ‚ : Eq (f 1) 1\nhmul : âˆ€ {m n : Nat}, m.Coprime n â†’ Eq (f (HMul.hMul m n)) (HMul.hMul (f m) (f n))\nhsum : âˆ€ {p : Nat}, Nat.Prime p â†’ Summable fun n => Norm.norm (f (HPow.hPow p n))\ns : Finset Nat\nâŠ¢ And (Summable fun m => Norm.norm (f â†‘m)) (HasSum (fun m => f â†‘m) ((Finset.filter (fun p => Nat.Prime p) s).prod fun p => tsum fun n => f (HPow.hPow p n)))","decl":"include hfâ‚ hmul in\n/-- We relate a finite product over primes in `s` to an infinite sum over `s`-factored numbers. -/\nlemma summable_and_hasSum_factoredNumbers_prod_filter_prime_tsum\n    (hsum : âˆ€ {p : â„•}, p.Prime â†’ Summable (fun n : â„• â†¦ â€–f (p ^ n)â€–)) (s : Finset â„•) :\n    Summable (fun m : factoredNumbers s â†¦ â€–f mâ€–) âˆ§\n      HasSum (fun m : factoredNumbers s â†¦ f m)\n        (âˆ p âˆˆ s with p.Prime, âˆ‘' n : â„•, f (p ^ n)) := by\n  induction' s using Finset.induction with p s hp ih\n  Â· rw [factoredNumbers_empty]\n    simp only [not_mem_empty, IsEmpty.forall_iff, forall_const, filter_true_of_mem, prod_empty]\n    exact âŸ¨(Set.finite_singleton 1).summable (â€–f Â·â€–), hfâ‚ â–¸ hasSum_singleton 1 fâŸ©\n  Â· rw [filter_insert]\n    split_ifs with hpp\n    Â· constructor\n      Â· simp only [â† (equivProdNatFactoredNumbers hpp hp).summable_iff, Function.comp_def,\n          equivProdNatFactoredNumbers_apply', factoredNumbers.map_prime_pow_mul hmul hpp hp]\n        refine Summable.of_nonneg_of_le (fun _ â†¦ norm_nonneg _) (fun _ â†¦ norm_mul_le ..) ?_\n        apply Summable.mul_of_nonneg (hsum hpp) ih.1 <;> exact fun n â†¦ norm_nonneg _\n      Â· have hp' : p âˆ‰ {p âˆˆ s | p.Prime} := mt (mem_of_mem_filter p) hp\n        rw [prod_insert hp', â† (equivProdNatFactoredNumbers hpp hp).hasSum_iff, Function.comp_def]\n        conv =>\n          enter [1, x]\n          rw [equivProdNatFactoredNumbers_apply', factoredNumbers.map_prime_pow_mul hmul hpp hp]\n        have : T3Space R := instT3Space -- speeds up the following\n        apply (hsum hpp).of_norm.hasSum.mul ih.2\n        -- `exact summable_mul_of_summable_norm (hsum hpp) ih.1` gives a time-out\n        apply summable_mul_of_summable_norm (hsum hpp) ih.1\n    Â· rwa [factoredNumbers_insert s hpp]\n\n"}
{"name":"EulerProduct.prod_filter_prime_tsum_eq_tsum_factoredNumbers","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"R : Type u_1\ninstâœÂ¹ : NormedCommRing R\nf : Nat â†’ R\ninstâœ : CompleteSpace R\nhfâ‚ : Eq (f 1) 1\nhmul : âˆ€ {m n : Nat}, m.Coprime n â†’ Eq (f (HMul.hMul m n)) (HMul.hMul (f m) (f n))\nhsum : Summable fun x => Norm.norm (f x)\ns : Finset Nat\nâŠ¢ Eq ((Finset.filter (fun p => Nat.Prime p) s).prod fun p => tsum fun n => f (HPow.hPow p n)) (tsum fun m => f â†‘m)","decl":"include hfâ‚ hmul in\n/-- A version of `EulerProduct.summable_and_hasSum_factoredNumbers_prod_filter_prime_tsum`\nin terms of the value of the series. -/\nlemma prod_filter_prime_tsum_eq_tsum_factoredNumbers (hsum : Summable (â€–f Â·â€–)) (s : Finset â„•) :\n    âˆ p âˆˆ s with p.Prime, âˆ‘' n : â„•, f (p ^ n) = âˆ‘' m : factoredNumbers s, f m :=\n  (summable_and_hasSum_factoredNumbers_prod_filter_prime_tsum hfâ‚ hmul\n    (fun hp â†¦ hsum.comp_injective <| Nat.pow_right_injective hp.one_lt) _).2.tsum_eq.symm\n\n"}
{"name":"EulerProduct.norm_tsum_factoredNumbers_sub_tsum_lt","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"R : Type u_1\ninstâœÂ¹ : NormedCommRing R\nf : Nat â†’ R\ninstâœ : CompleteSpace R\nhsum : Summable f\nhfâ‚€ : Eq (f 0) 0\nÎµ : Real\nÎµpos : LT.lt 0 Îµ\nâŠ¢ Exists fun N => âˆ€ (s : Finset Nat), LE.le N.primesBelow s â†’ LT.lt (Norm.norm (HSub.hSub (tsum fun m => f m) (tsum fun m => f â†‘m))) Îµ","decl":"/-- The following statement says that summing over `s`-factored numbers such that\n`s` contains `primesBelow N` for large enough `N` gets us arbitrarily close to the sum\nover all natural numbers (assuming `f` is summable and `f 0 = 0`; the latter since\n`0` is not `s`-factored). -/\nlemma norm_tsum_factoredNumbers_sub_tsum_lt (hsum : Summable f) (hfâ‚€ : f 0 = 0) {Îµ : â„}\n    (Îµpos : 0 < Îµ) :\n    âˆƒ N : â„•, âˆ€ s : Finset â„•, primesBelow N â‰¤ s â†’\n      â€–(âˆ‘' m : â„•, f m) - âˆ‘' m : factoredNumbers s, f mâ€– < Îµ := by\n  obtain âŸ¨N, hNâŸ© :=\n    summable_iff_nat_tsum_vanishing.mp hsum (Metric.ball 0 Îµ) <| Metric.ball_mem_nhds 0 Îµpos\n  simp_rw [mem_ball_zero_iff] at hN\n  refine âŸ¨N, fun s hs â†¦ ?_âŸ©\n  have := hN _ <| factoredNumbers_compl hs\n  rwa [â† tsum_subtype_add_tsum_subtype_compl hsum (factoredNumbers s),\n    add_sub_cancel_left, tsum_eq_tsum_diff_singleton (factoredNumbers s)á¶œ hfâ‚€]\n\n-- Versions of the three lemmas above for `smoothNumbers N`\n\n"}
{"name":"EulerProduct.summable_and_hasSum_smoothNumbers_prod_primesBelow_tsum","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"R : Type u_1\ninstâœÂ¹ : NormedCommRing R\nf : Nat â†’ R\ninstâœ : CompleteSpace R\nhfâ‚ : Eq (f 1) 1\nhmul : âˆ€ {m n : Nat}, m.Coprime n â†’ Eq (f (HMul.hMul m n)) (HMul.hMul (f m) (f n))\nhsum : âˆ€ {p : Nat}, Nat.Prime p â†’ Summable fun n => Norm.norm (f (HPow.hPow p n))\nN : Nat\nâŠ¢ And (Summable fun m => Norm.norm (f â†‘m)) (HasSum (fun m => f â†‘m) (N.primesBelow.prod fun p => tsum fun n => f (HPow.hPow p n)))","decl":"include hfâ‚ hmul in\n/-- We relate a finite product over primes to an infinite sum over smooth numbers. -/\nlemma summable_and_hasSum_smoothNumbers_prod_primesBelow_tsum\n    (hsum : âˆ€ {p : â„•}, p.Prime â†’ Summable (fun n : â„• â†¦ â€–f (p ^ n)â€–)) (N : â„•) :\n    Summable (fun m : N.smoothNumbers â†¦ â€–f mâ€–) âˆ§\n      HasSum (fun m : N.smoothNumbers â†¦ f m) (âˆ p âˆˆ N.primesBelow, âˆ‘' n : â„•, f (p ^ n)) := by\n  rw [smoothNumbers_eq_factoredNumbers, primesBelow]\n  exact summable_and_hasSum_factoredNumbers_prod_filter_prime_tsum hfâ‚ hmul hsum _\n\n"}
{"name":"EulerProduct.prod_primesBelow_tsum_eq_tsum_smoothNumbers","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"R : Type u_1\ninstâœÂ¹ : NormedCommRing R\nf : Nat â†’ R\ninstâœ : CompleteSpace R\nhfâ‚ : Eq (f 1) 1\nhmul : âˆ€ {m n : Nat}, m.Coprime n â†’ Eq (f (HMul.hMul m n)) (HMul.hMul (f m) (f n))\nhsum : Summable fun x => Norm.norm (f x)\nN : Nat\nâŠ¢ Eq (N.primesBelow.prod fun p => tsum fun n => f (HPow.hPow p n)) (tsum fun m => f â†‘m)","decl":"include hfâ‚ hmul in\n/-- A version of `EulerProduct.summable_and_hasSum_smoothNumbers_prod_primesBelow_tsum`\nin terms of the value of the series. -/\nlemma prod_primesBelow_tsum_eq_tsum_smoothNumbers (hsum : Summable (â€–f Â·â€–)) (N : â„•) :\n    âˆ p âˆˆ N.primesBelow, âˆ‘' n : â„•, f (p ^ n) = âˆ‘' m : N.smoothNumbers, f m :=\n  (summable_and_hasSum_smoothNumbers_prod_primesBelow_tsum hfâ‚ hmul\n    (fun hp â†¦ hsum.comp_injective <| Nat.pow_right_injective hp.one_lt) _).2.tsum_eq.symm\n\n"}
{"name":"EulerProduct.norm_tsum_smoothNumbers_sub_tsum_lt","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"R : Type u_1\ninstâœÂ¹ : NormedCommRing R\nf : Nat â†’ R\ninstâœ : CompleteSpace R\nhsum : Summable f\nhfâ‚€ : Eq (f 0) 0\nÎµ : Real\nÎµpos : LT.lt 0 Îµ\nâŠ¢ Exists fun Nâ‚€ => âˆ€ (N : Nat), GE.ge N Nâ‚€ â†’ LT.lt (Norm.norm (HSub.hSub (tsum fun m => f m) (tsum fun m => f â†‘m))) Îµ","decl":"/-- The following statement says that summing over `N`-smooth numbers\nfor large enough `N` gets us arbitrarily close to the sum over all natural numbers\n(assuming `f` is norm-summable and `f 0 = 0`; the latter since `0` is not smooth). -/\nlemma norm_tsum_smoothNumbers_sub_tsum_lt (hsum : Summable f) (hfâ‚€ : f 0 = 0)\n    {Îµ : â„} (Îµpos : 0 < Îµ) :\n    âˆƒ Nâ‚€ : â„•, âˆ€ N â‰¥ Nâ‚€, â€–(âˆ‘' m : â„•, f m) - âˆ‘' m : N.smoothNumbers, f mâ€– < Îµ := by\n  conv => enter [1, Nâ‚€, N]; rw [smoothNumbers_eq_factoredNumbers]\n  obtain âŸ¨Nâ‚€, hNâ‚€âŸ© := norm_tsum_factoredNumbers_sub_tsum_lt hsum hfâ‚€ Îµpos\n  refine âŸ¨Nâ‚€, fun N hN â†¦ hNâ‚€ (range N) fun p hp â†¦ ?_âŸ©\n  exact mem_range.mpr <| (lt_of_mem_primesBelow hp).trans_le hN\n\n\n"}
{"name":"EulerProduct.eulerProduct_hasProd","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"R : Type u_1\ninstâœÂ¹ : NormedCommRing R\nf : Nat â†’ R\ninstâœ : CompleteSpace R\nhfâ‚ : Eq (f 1) 1\nhmul : âˆ€ {m n : Nat}, m.Coprime n â†’ Eq (f (HMul.hMul m n)) (HMul.hMul (f m) (f n))\nhsum : Summable fun x => Norm.norm (f x)\nhfâ‚€ : Eq (f 0) 0\nâŠ¢ HasProd (fun p => tsum fun e => f (HPow.hPow (â†‘p) e)) (tsum fun n => f n)","decl":"include hfâ‚ hmul in\n/-- The *Euler Product* for multiplicative (on coprime arguments) functions.\n\nIf `f : â„• â†’ R`, where `R` is a complete normed commutative ring, `f 0 = 0`, `f 1 = 1`, `f` is\nmultiplicative on coprime arguments, and `â€–f Â·â€–` is summable, then\n`âˆ' p : Nat.Primes, âˆ‘' e, f (p ^ e) = âˆ‘' n, f n`. This version is stated using `HasProd`. -/\ntheorem eulerProduct_hasProd (hsum : Summable (â€–f Â·â€–)) (hfâ‚€ : f 0 = 0) :\n    HasProd (fun p : Primes â†¦ âˆ‘' e, f (p ^ e)) (âˆ‘' n, f n) := by\n  let F : â„• â†’ R := fun n â†¦ âˆ‘' e, f (n ^ e)\n  change HasProd (F âˆ˜ Subtype.val) _\n  rw [hasProd_subtype_iff_mulIndicator,\n    show Set.mulIndicator (fun p : â„• â†¦ Irreducible p) =  {p | Nat.Prime p}.mulIndicator from rfl,\n    HasProd, Metric.tendsto_atTop]\n  intro Îµ hÎµ\n  obtain âŸ¨Nâ‚€, hNâ‚€âŸ© := norm_tsum_factoredNumbers_sub_tsum_lt hsum.of_norm hfâ‚€ hÎµ\n  refine âŸ¨range Nâ‚€, fun s hs â†¦ ?_âŸ©\n  have : âˆ p âˆˆ s, {p | Nat.Prime p}.mulIndicator F p = âˆ p âˆˆ s with p.Prime, F p :=\n    prod_mulIndicator_eq_prod_filter s (fun _ â†¦ F) _ id\n  rw [this, dist_eq_norm, prod_filter_prime_tsum_eq_tsum_factoredNumbers hfâ‚ hmul hsum,\n    norm_sub_rev]\n  exact hNâ‚€ s fun p hp â†¦ hs <| mem_range.mpr <| lt_of_mem_primesBelow hp\n\n"}
{"name":"EulerProduct.eulerProduct_hasProd_mulIndicator","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"R : Type u_1\ninstâœÂ¹ : NormedCommRing R\nf : Nat â†’ R\ninstâœ : CompleteSpace R\nhfâ‚ : Eq (f 1) 1\nhmul : âˆ€ {m n : Nat}, m.Coprime n â†’ Eq (f (HMul.hMul m n)) (HMul.hMul (f m) (f n))\nhsum : Summable fun x => Norm.norm (f x)\nhfâ‚€ : Eq (f 0) 0\nâŠ¢ HasProd ((setOf fun p => Nat.Prime p).mulIndicator fun p => tsum fun e => f (HPow.hPow p e)) (tsum fun n => f n)","decl":"include hfâ‚ hmul in\n/-- The *Euler Product* for multiplicative (on coprime arguments) functions.\n\nIf `f : â„• â†’ R`, where `R` is a complete normed commutative ring, `f 0 = 0`, `f 1 = 1`, `f` i\nmultiplicative on coprime arguments, and `â€–f Â·â€–` is summable, then\n`âˆ' p : â„•, if p.Prime then âˆ‘' e, f (p ^ e) else 1 = âˆ‘' n, f n`.\nThis version is stated using `HasProd` and `Set.mulIndicator`. -/\ntheorem eulerProduct_hasProd_mulIndicator (hsum : Summable (â€–f Â·â€–)) (hfâ‚€ : f 0 = 0) :\n    HasProd (Set.mulIndicator {p | Nat.Prime p} fun p â†¦  âˆ‘' e, f (p ^ e)) (âˆ‘' n, f n) := by\n  rw [â† hasProd_subtype_iff_mulIndicator]\n  exact eulerProduct_hasProd hfâ‚ hmul hsum hfâ‚€\n\n"}
{"name":"EulerProduct.eulerProduct","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"R : Type u_1\ninstâœÂ¹ : NormedCommRing R\nf : Nat â†’ R\ninstâœ : CompleteSpace R\nhfâ‚ : Eq (f 1) 1\nhmul : âˆ€ {m n : Nat}, m.Coprime n â†’ Eq (f (HMul.hMul m n)) (HMul.hMul (f m) (f n))\nhsum : Summable fun x => Norm.norm (f x)\nhfâ‚€ : Eq (f 0) 0\nâŠ¢ Filter.Tendsto (fun n => n.primesBelow.prod fun p => tsum fun e => f (HPow.hPow p e)) Filter.atTop (nhds (tsum fun n => f n))","decl":"open Filter in\ninclude hfâ‚ hmul in\n/-- The *Euler Product* for multiplicative (on coprime arguments) functions.\n\nIf `f : â„• â†’ R`, where `R` is a complete normed commutative ring, `f 0 = 0`, `f 1 = 1`, `f` is\nmultiplicative on coprime arguments, and `â€–f Â·â€–` is summable, then\n`âˆ' p : {p : â„• | p.Prime}, âˆ‘' e, f (p ^ e) = âˆ‘' n, f n`.\nThis is a version using convergence of finite partial products. -/\ntheorem eulerProduct (hsum : Summable (â€–f Â·â€–)) (hfâ‚€ : f 0 = 0) :\n    Tendsto (fun n : â„• â†¦ âˆ p âˆˆ primesBelow n, âˆ‘' e, f (p ^ e)) atTop (ğ“ (âˆ‘' n, f n)) := by\n  have := (eulerProduct_hasProd_mulIndicator hfâ‚ hmul hsum hfâ‚€).tendsto_prod_nat\n  let F : â„• â†’ R := fun p â†¦ âˆ‘' (e : â„•), f (p ^ e)\n  have H (n : â„•) : âˆ i âˆˆ range n, Set.mulIndicator {p | Nat.Prime p} F i =\n                     âˆ p âˆˆ primesBelow n, âˆ‘' (e : â„•), f (p ^ e) :=\n    prod_mulIndicator_eq_prod_filter (range n) (fun _ â†¦ F) (fun _ â†¦ {p | Nat.Prime p}) id\n  simpa only [F, H]\n\n"}
{"name":"EulerProduct.eulerProduct_tprod","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"R : Type u_1\ninstâœÂ¹ : NormedCommRing R\nf : Nat â†’ R\ninstâœ : CompleteSpace R\nhfâ‚ : Eq (f 1) 1\nhmul : âˆ€ {m n : Nat}, m.Coprime n â†’ Eq (f (HMul.hMul m n)) (HMul.hMul (f m) (f n))\nhsum : Summable fun x => Norm.norm (f x)\nhfâ‚€ : Eq (f 0) 0\nâŠ¢ Eq (tprod fun p => tsum fun e => f (HPow.hPow (â†‘p) e)) (tsum fun n => f n)","decl":"include hfâ‚ hmul in\n/-- The *Euler Product* for multiplicative (on coprime arguments) functions.\n\nIf `f : â„• â†’ R`, where `R` is a complete normed commutative ring, `f 0 = 0`, `f 1 = 1`, `f` is\nmultiplicative on coprime arguments, and `â€–f Â·â€–` is summable, then\n`âˆ' p : {p : â„• | p.Prime}, âˆ‘' e, f (p ^ e) = âˆ‘' n, f n`. -/\ntheorem eulerProduct_tprod (hsum : Summable (â€–f Â·â€–)) (hfâ‚€ : f 0 = 0) :\n    âˆ' p : Primes, âˆ‘' e, f (p ^ e) = âˆ‘' n, f n :=\n  (eulerProduct_hasProd hfâ‚ hmul hsum hfâ‚€).tprod_eq\n\n"}
{"name":"ArithmeticFunction.IsMultiplicative.eulerProduct_hasProd","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"R : Type u_1\ninstâœÂ¹ : NormedCommRing R\ninstâœ : CompleteSpace R\nf : ArithmeticFunction R\nhf : f.IsMultiplicative\nhsum : Summable fun x => Norm.norm (f x)\nâŠ¢ HasProd (fun p => tsum fun e => f (HPow.hPow (â†‘p) e)) (tsum fun n => f n)","decl":"/-- The *Euler Product* for a multiplicative arithmetic function `f` with values in a\ncomplete normed commutative ring `R`: if `â€–f Â·â€–` is summable, then\n`âˆ' p : Nat.Primes, âˆ‘' e, f (p ^ e) = âˆ‘' n, f n`.\nThis version is stated in terms of `HasProd`. -/\nnonrec theorem IsMultiplicative.eulerProduct_hasProd {f : ArithmeticFunction R}\n    (hf : f.IsMultiplicative) (hsum : Summable (â€–f Â·â€–)) :\n    HasProd (fun p : Primes â†¦ âˆ‘' e, f (p ^ e)) (âˆ‘' n, f n) :=\n  eulerProduct_hasProd hf.1 hf.2 hsum f.map_zero\n\n"}
{"name":"ArithmeticFunction.IsMultiplicative.eulerProduct","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"R : Type u_1\ninstâœÂ¹ : NormedCommRing R\ninstâœ : CompleteSpace R\nf : ArithmeticFunction R\nhf : f.IsMultiplicative\nhsum : Summable fun x => Norm.norm (f x)\nâŠ¢ Filter.Tendsto (fun n => n.primesBelow.prod fun p => tsum fun e => f (HPow.hPow p e)) Filter.atTop (nhds (tsum fun n => f n))","decl":"open Filter in\n/-- The *Euler Product* for a multiplicative arithmetic function `f` with values in a\ncomplete normed commutative ring `R`: if `â€–f Â·â€–` is summable, then\n`âˆ' p : Nat.Primes, âˆ‘' e, f (p ^ e) = âˆ‘' n, f n`.\nThis version is stated in the form of convergence of finite partial products. -/\nnonrec theorem IsMultiplicative.eulerProduct {f : ArithmeticFunction R} (hf : f.IsMultiplicative)\n    (hsum : Summable (â€–f Â·â€–)) :\n    Tendsto (fun n : â„• â†¦ âˆ p âˆˆ primesBelow n, âˆ‘' e, f (p ^ e)) atTop (ğ“ (âˆ‘' n, f n)) :=\n  eulerProduct hf.1 hf.2 hsum f.map_zero\n\n"}
{"name":"ArithmeticFunction.IsMultiplicative.eulerProduct_tprod","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"R : Type u_1\ninstâœÂ¹ : NormedCommRing R\ninstâœ : CompleteSpace R\nf : ArithmeticFunction R\nhf : f.IsMultiplicative\nhsum : Summable fun x => Norm.norm (f x)\nâŠ¢ Eq (tprod fun p => tsum fun e => f (HPow.hPow (â†‘p) e)) (tsum fun n => f n)","decl":"/-- The *Euler Product* for a multiplicative arithmetic function `f` with values in a\ncomplete normed commutative ring `R`: if `â€–f Â·â€–` is summable, then\n`âˆ' p : Nat.Primes, âˆ‘' e, f (p ^ e) = âˆ‘' n, f n`. -/\nnonrec theorem IsMultiplicative.eulerProduct_tprod {f : ArithmeticFunction R}\n    (hf : f.IsMultiplicative) (hsum : Summable (â€–f Â·â€–)) :\n    âˆ' p : Primes, âˆ‘' e, f (p ^ e) = âˆ‘' n, f n :=\n  eulerProduct_tprod hf.1 hf.2 hsum f.map_zero\n\n"}
{"name":"EulerProduct.one_sub_inv_eq_geometric_of_summable_norm","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"F : Type u_1\ninstâœÂ¹ : NormedField F\ninstâœ : CompleteSpace F\nf : MonoidWithZeroHom Nat F\np : Nat\nhp : Nat.Prime p\nhsum : Summable fun x => Norm.norm (f x)\nâŠ¢ Eq (Inv.inv (HSub.hSub 1 (f p))) (tsum fun e => f (HPow.hPow p e))","decl":"lemma one_sub_inv_eq_geometric_of_summable_norm {f : â„• â†’*â‚€ F} {p : â„•} (hp : p.Prime)\n    (hsum : Summable fun x â†¦ â€–f xâ€–) :\n    (1 - f p)â»Â¹ = âˆ‘' (e : â„•), f (p ^ e) := by\n  simp only [map_pow]\n  refine (tsum_geometric_of_norm_lt_one <| summable_geometric_iff_norm_lt_one.mp ?_).symm\n  refine Summable.of_norm ?_\n  simpa only [Function.comp_def, map_pow]\n    using hsum.comp_injective <| Nat.pow_right_injective hp.one_lt\n\n"}
{"name":"EulerProduct.summable_and_hasSum_factoredNumbers_prod_filter_prime_geometric","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"F : Type u_1\ninstâœÂ¹ : NormedField F\ninstâœ : CompleteSpace F\nf : MonoidHom Nat F\nh : âˆ€ {p : Nat}, Nat.Prime p â†’ LT.lt (Norm.norm (f p)) 1\ns : Finset Nat\nâŠ¢ And (Summable fun m => Norm.norm (f â†‘m)) (HasSum (fun m => f â†‘m) ((Finset.filter (fun p => Nat.Prime p) s).prod fun p => Inv.inv (HSub.hSub 1 (f p))))","decl":"/-- Given a (completely) multiplicative function `f : â„• â†’ F`, where `F` is a normed field,\nsuch that `â€–f pâ€– < 1` for all primes `p`, we can express the sum of `f n` over all `s`-factored\npositive integers `n` as a product of `(1 - f p)â»Â¹` over the primes `p âˆˆ s`. At the same time,\nwe show that the sum involved converges absolutely. -/\nlemma summable_and_hasSum_factoredNumbers_prod_filter_prime_geometric {f : â„• â†’* F}\n    (h : âˆ€ {p : â„•}, p.Prime â†’ â€–f pâ€– < 1) (s : Finset â„•) :\n    Summable (fun m : factoredNumbers s â†¦ â€–f mâ€–) âˆ§\n      HasSum (fun m : factoredNumbers s â†¦ f m) (âˆ p âˆˆ s with p.Prime, (1 - f p)â»Â¹) := by\n  have hmul {m n} (_ : Nat.Coprime m n) := f.map_mul m n\n  have Hâ‚ :\n      âˆ p âˆˆ s with p.Prime, âˆ‘' n : â„•, f (p ^ n) = âˆ p âˆˆ s with p.Prime, (1 - f p)â»Â¹ := by\n    refine prod_congr rfl fun p hp â†¦ ?_\n    simp only [map_pow]\n    exact tsum_geometric_of_norm_lt_one <| h (mem_filter.mp hp).2\n  have Hâ‚‚ : âˆ€ {p : â„•}, p.Prime â†’ Summable fun n â†¦ â€–f (p ^ n)â€– := by\n    intro p hp\n    simp only [map_pow]\n    refine Summable.of_nonneg_of_le (fun _ â†¦ norm_nonneg _) (fun _ â†¦ norm_pow_le ..) ?_\n    exact summable_geometric_iff_norm_lt_one.mpr <| (norm_norm (f p)).symm â–¸ h hp\n  exact Hâ‚ â–¸ summable_and_hasSum_factoredNumbers_prod_filter_prime_tsum f.map_one hmul Hâ‚‚ s\n\n"}
{"name":"EulerProduct.prod_filter_prime_geometric_eq_tsum_factoredNumbers","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"F : Type u_1\ninstâœÂ¹ : NormedField F\ninstâœ : CompleteSpace F\nf : MonoidHom Nat F\nhsum : Summable â‡‘f\ns : Finset Nat\nâŠ¢ Eq ((Finset.filter (fun p => Nat.Prime p) s).prod fun p => Inv.inv (HSub.hSub 1 (f p))) (tsum fun m => f â†‘m)","decl":"/-- A version of `EulerProduct.summable_and_hasSum_factoredNumbers_prod_filter_prime_geometric`\nin terms of the value of the series. -/\nlemma prod_filter_prime_geometric_eq_tsum_factoredNumbers {f : â„• â†’* F} (hsum : Summable f)\n    (s : Finset â„•) :\n    âˆ p âˆˆ s with p.Prime, (1 - f p)â»Â¹ = âˆ‘' m : factoredNumbers s, f m := by\n  refine (summable_and_hasSum_factoredNumbers_prod_filter_prime_geometric ?_ s).2.tsum_eq.symm\n  exact fun {_} hp â†¦ hsum.norm_lt_one hp.one_lt\n\n"}
{"name":"EulerProduct.summable_and_hasSum_smoothNumbers_prod_primesBelow_geometric","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"F : Type u_1\ninstâœÂ¹ : NormedField F\ninstâœ : CompleteSpace F\nf : MonoidHom Nat F\nh : âˆ€ {p : Nat}, Nat.Prime p â†’ LT.lt (Norm.norm (f p)) 1\nN : Nat\nâŠ¢ And (Summable fun m => Norm.norm (f â†‘m)) (HasSum (fun m => f â†‘m) (N.primesBelow.prod fun p => Inv.inv (HSub.hSub 1 (f p))))","decl":"/-- Given a (completely) multiplicative function `f : â„• â†’ F`, where `F` is a normed field,\nsuch that `â€–f pâ€– < 1` for all primes `p`, we can express the sum of `f n` over all `N`-smooth\npositive integers `n` as a product of `(1 - f p)â»Â¹` over the primes `p < N`. At the same time,\nwe show that the sum involved converges absolutely. -/\nlemma summable_and_hasSum_smoothNumbers_prod_primesBelow_geometric {f : â„• â†’* F}\n    (h : âˆ€ {p : â„•}, p.Prime â†’ â€–f pâ€– < 1) (N : â„•) :\n    Summable (fun m : N.smoothNumbers â†¦ â€–f mâ€–) âˆ§\n      HasSum (fun m : N.smoothNumbers â†¦ f m) (âˆ p âˆˆ N.primesBelow, (1 - f p)â»Â¹) := by\n  rw [smoothNumbers_eq_factoredNumbers, primesBelow]\n  exact summable_and_hasSum_factoredNumbers_prod_filter_prime_geometric h _\n\n"}
{"name":"EulerProduct.prod_primesBelow_geometric_eq_tsum_smoothNumbers","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"F : Type u_1\ninstâœÂ¹ : NormedField F\ninstâœ : CompleteSpace F\nf : MonoidHom Nat F\nhsum : Summable â‡‘f\nN : Nat\nâŠ¢ Eq (N.primesBelow.prod fun p => Inv.inv (HSub.hSub 1 (f p))) (tsum fun m => f â†‘m)","decl":"/-- A version of `EulerProduct.summable_and_hasSum_smoothNumbers_prod_primesBelow_geometric`\nin terms of the value of the series. -/\nlemma prod_primesBelow_geometric_eq_tsum_smoothNumbers {f : â„• â†’* F} (hsum : Summable f) (N : â„•) :\n    âˆ p âˆˆ N.primesBelow, (1 - f p)â»Â¹ = âˆ‘' m : N.smoothNumbers, f m := by\n  rw [smoothNumbers_eq_factoredNumbers, primesBelow]\n  exact prod_filter_prime_geometric_eq_tsum_factoredNumbers hsum _\n\n"}
{"name":"EulerProduct.eulerProduct_completely_multiplicative_hasProd","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"F : Type u_1\ninstâœÂ¹ : NormedField F\ninstâœ : CompleteSpace F\nf : MonoidWithZeroHom Nat F\nhsum : Summable fun x => Norm.norm (f x)\nâŠ¢ HasProd (fun p => Inv.inv (HSub.hSub 1 (f â†‘p))) (tsum fun n => f n)","decl":"/-- The *Euler Product* for completely multiplicative functions.\n\nIf `f : â„• â†’*â‚€ F`, where `F` is a complete normed field and `â€–f Â·â€–` is summable, then\n`âˆ' p : Nat.Primes, (1 - f p)â»Â¹ = âˆ‘' n, f n`.\nThis version is stated in terms of `HasProd`. -/\ntheorem eulerProduct_completely_multiplicative_hasProd {f : â„• â†’*â‚€ F} (hsum : Summable (â€–f Â·â€–)) :\n    HasProd (fun p : Primes â†¦ (1 - f p)â»Â¹) (âˆ‘' n, f n) := by\n  have H : (fun p : Primes â†¦ (1 - f p)â»Â¹) = fun p : Primes â†¦ âˆ‘' (e : â„•), f (p ^ e) :=\n    funext <| fun p â†¦ one_sub_inv_eq_geometric_of_summable_norm p.prop hsum\n  simpa only [map_pow, H]\n    using eulerProduct_hasProd f.map_one (fun {m n} _ â†¦ f.map_mul m n) hsum f.map_zero\n\n"}
{"name":"EulerProduct.eulerProduct_completely_multiplicative_tprod","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"F : Type u_1\ninstâœÂ¹ : NormedField F\ninstâœ : CompleteSpace F\nf : MonoidWithZeroHom Nat F\nhsum : Summable fun x => Norm.norm (f x)\nâŠ¢ Eq (tprod fun p => Inv.inv (HSub.hSub 1 (f â†‘p))) (tsum fun n => f n)","decl":"/-- The *Euler Product* for completely multiplicative functions.\n\nIf `f : â„• â†’*â‚€ F`, where `F` is a complete normed field and `â€–f Â·â€–` is summable, then\n`âˆ' p : Nat.Primes, (1 - f p)â»Â¹ = âˆ‘' n, f n`. -/\ntheorem eulerProduct_completely_multiplicative_tprod {f : â„• â†’*â‚€ F} (hsum : Summable (â€–f Â·â€–)) :\n    âˆ' p : Primes, (1 - f p)â»Â¹ = âˆ‘' n, f n :=\n  (eulerProduct_completely_multiplicative_hasProd hsum).tprod_eq\n\n"}
{"name":"EulerProduct.eulerProduct_completely_multiplicative","module":"Mathlib.NumberTheory.EulerProduct.Basic","initialProofState":"F : Type u_1\ninstâœÂ¹ : NormedField F\ninstâœ : CompleteSpace F\nf : MonoidWithZeroHom Nat F\nhsum : Summable fun x => Norm.norm (f x)\nâŠ¢ Filter.Tendsto (fun n => n.primesBelow.prod fun p => Inv.inv (HSub.hSub 1 (f p))) Filter.atTop (nhds (tsum fun n => f n))","decl":"open Filter in\n/-- The *Euler Product* for completely multiplicative functions.\n\nIf `f : â„• â†’*â‚€ F`, where `F` is a complete normed field and `â€–f Â·â€–` is summable, then\n`âˆ' p : Nat.Primes, (1 - f p)â»Â¹ = âˆ‘' n, f n`.\nThis version is stated in the form of convergence of finite partial products. -/\ntheorem eulerProduct_completely_multiplicative {f : â„• â†’*â‚€ F} (hsum : Summable (â€–f Â·â€–)) :\n    Tendsto (fun n : â„• â†¦ âˆ p âˆˆ primesBelow n, (1 - f p)â»Â¹) atTop (ğ“ (âˆ‘' n, f n)) := by\n  have hmul {m n} (_ : Nat.Coprime m n) := f.map_mul m n\n  have := (eulerProduct_hasProd_mulIndicator f.map_one hmul hsum f.map_zero).tendsto_prod_nat\n  have H (n : â„•) : âˆ p âˆˆ range n, {p | Nat.Prime p}.mulIndicator (fun p â†¦ (1 - f p)â»Â¹) p =\n                     âˆ p âˆˆ primesBelow n, (1 - f p)â»Â¹ :=\n    prod_mulIndicator_eq_prod_filter\n      (range n) (fun _ â†¦ fun p â†¦ (1 - f p)â»Â¹) (fun _ â†¦ {p | Nat.Prime p}) id\n  have H' : {p | Nat.Prime p}.mulIndicator (fun p â†¦ (1 - f p)â»Â¹) =\n              {p | Nat.Prime p}.mulIndicator (fun p â†¦ âˆ‘' e : â„•, f (p ^ e)) :=\n    Set.mulIndicator_congr fun p hp â†¦ one_sub_inv_eq_geometric_of_summable_norm hp hsum\n  simpa only [â† H, H'] using this\n\n"}
