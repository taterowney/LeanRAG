{"name":"IsTranscendenceBasis.lift_cardinalMk_eq_max_lift","module":"Mathlib.RingTheory.AlgebraicIndependent.RankAndCardinality","initialProofState":"F : Type u\nE : Type v\ninst✝⁵ : CommRing F\ninst✝⁴ : Nontrivial F\ninst✝³ : CommRing E\ninst✝² : IsDomain E\ninst✝¹ : Algebra F E\nι : Type w\nx : ι → E\ninst✝ : Nonempty ι\nhx : IsTranscendenceBasis F x\n⊢ Eq (Cardinal.lift.{max u w, v} (Cardinal.mk E)) (Max.max (Max.max (Cardinal.lift.{max v w, u} (Cardinal.mk F)) (Cardinal.lift.{max u v, w} (Cardinal.mk ι))) Cardinal.aleph0)","decl":"theorem IsTranscendenceBasis.lift_cardinalMk_eq_max_lift\n    {F : Type u} {E : Type v} [CommRing F] [Nontrivial F] [CommRing E] [IsDomain E] [Algebra F E]\n    {ι : Type w} {x : ι → E} [Nonempty ι] (hx : IsTranscendenceBasis F x) :\n    lift.{max u w} #E = lift.{max v w} #F ⊔ lift.{max u v} #ι ⊔ ℵ₀ := by\n  let K := Algebra.adjoin F (Set.range x)\n  suffices #E = #K by simp [K, this, ← lift_mk_eq'.2 ⟨hx.1.aevalEquiv.toEquiv⟩]\n  haveI : Algebra.IsAlgebraic K E := hx.isAlgebraic\n  refine le_antisymm ?_ (mk_le_of_injective Subtype.val_injective)\n  haveI : Infinite K := hx.1.aevalEquiv.infinite_iff.1 inferInstance\n  simpa only [sup_eq_left.2 (aleph0_le_mk K)] using Algebra.IsAlgebraic.cardinalMk_le_max K E\n\n"}
{"name":"IsTranscendenceBasis.lift_rank_eq_max_lift","module":"Mathlib.RingTheory.AlgebraicIndependent.RankAndCardinality","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\nι : Type w\nx : ι → E\ninst✝ : Nonempty ι\nhx : IsTranscendenceBasis F x\n⊢ Eq (Cardinal.lift.{max u w, v} (Module.rank F E)) (Max.max (Max.max (Cardinal.lift.{max v w, u} (Cardinal.mk F)) (Cardinal.lift.{max u v, w} (Cardinal.mk ι))) Cardinal.aleph0)","decl":"theorem IsTranscendenceBasis.lift_rank_eq_max_lift\n    {F : Type u} {E : Type v} [Field F] [Field E] [Algebra F E]\n    {ι : Type w} {x : ι → E} [Nonempty ι] (hx : IsTranscendenceBasis F x) :\n    lift.{max u w} (Module.rank F E) = lift.{max v w} #F ⊔ lift.{max u v} #ι ⊔ ℵ₀ := by\n  let K := IntermediateField.adjoin F (Set.range x)\n  haveI : Algebra.IsAlgebraic K E := hx.isAlgebraic_field\n  rw [← rank_mul_rank F K E, lift_mul, ← hx.1.aevalEquivField.toLinearEquiv.lift_rank_eq,\n    MvRatFunc.rank_eq_max_lift, lift_max, lift_max, lift_lift, lift_lift, lift_aleph0]\n  refine mul_eq_left le_sup_right ((lift_le.2 ((rank_le_card K E).trans\n    (Algebra.IsAlgebraic.cardinalMk_le_max K E))).trans_eq ?_) (by simp [rank_pos.ne'])\n  simp [K, ← lift_mk_eq'.2 ⟨hx.1.aevalEquivField.toEquiv⟩]\n\n"}
{"name":"Algebra.Transcendental.rank_eq_cardinalMk","module":"Mathlib.RingTheory.AlgebraicIndependent.RankAndCardinality","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Algebra.Transcendental F E\n⊢ Eq (Module.rank F E) (Cardinal.mk E)","decl":"theorem Algebra.Transcendental.rank_eq_cardinalMk\n    (F : Type u) (E : Type v) [Field F] [Field E] [Algebra F E] [Algebra.Transcendental F E] :\n    Module.rank F E = #E := by\n  obtain ⟨ι, x, hx⟩ := exists_isTranscendenceBasis' _ (algebraMap F E).injective\n  haveI := hx.nonempty_iff_transcendental.2 ‹_›\n  simpa [← hx.lift_cardinalMk_eq_max_lift] using hx.lift_rank_eq_max_lift\n\n"}
{"name":"IntermediateField.rank_sup_le","module":"Mathlib.RingTheory.AlgebraicIndependent.RankAndCardinality","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nA B : IntermediateField F E\n⊢ LE.le (Module.rank F (Subtype fun x => Membership.mem (Max.max A B) x)) (HMul.hMul (Module.rank F (Subtype fun x => Membership.mem A x)) (Module.rank F (Subtype fun x => Membership.mem B x)))","decl":"theorem IntermediateField.rank_sup_le\n    {F : Type u} {E : Type v} [Field F] [Field E] [Algebra F E] (A B : IntermediateField F E) :\n    Module.rank F ↥(A ⊔ B) ≤ Module.rank F A * Module.rank F B := by\n  by_cases hA : Algebra.IsAlgebraic F A\n  · exact rank_sup_le_of_isAlgebraic A B (Or.inl hA)\n  by_cases hB : Algebra.IsAlgebraic F B\n  · exact rank_sup_le_of_isAlgebraic A B (Or.inr hB)\n  rw [← Algebra.transcendental_iff_not_isAlgebraic] at hA hB\n  haveI : Algebra.Transcendental F ↥(A ⊔ B) := .ringHom_of_comp_eq (RingHom.id F)\n    (inclusion le_sup_left) Function.surjective_id (inclusion_injective _) rfl\n  haveI := Algebra.Transcendental.infinite F A\n  haveI := Algebra.Transcendental.infinite F B\n  simp_rw [Algebra.Transcendental.rank_eq_cardinalMk]\n  rw [sup_def, mul_mk_eq_max, ← Cardinal.lift_le.{u}]\n  refine (lift_cardinalMk_adjoin_le _ _).trans ?_\n  calc\n    _ ≤ Cardinal.lift.{v} #F ⊔ Cardinal.lift.{u} (#A ⊔ #B) ⊔ ℵ₀ := by\n      gcongr\n      rw [Cardinal.lift_le]\n      exact (mk_union_le _ _).trans_eq (by simp)\n    _ = _ := by\n      simp [lift_mk_le_lift_mk_of_injective (algebraMap F A).injective]\n"}
