{"name":"Module.Flat.trans","module":"Mathlib.RingTheory.Flat.Stability","initialProofState":"R : Type u\nS : Type v\nM : Type w\ninst✝⁸ : CommSemiring R\ninst✝⁷ : CommSemiring S\ninst✝⁶ : Algebra R S\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Module S M\ninst✝² : IsScalarTower R S M\ninst✝¹ : Module.Flat R S\ninst✝ : Module.Flat S M\n⊢ Module.Flat R M","decl":"open AlgebraTensorModule in\n/-- If `S` is a flat `R`-algebra, then any flat `S`-Module is also `R`-flat. -/\ntheorem trans [Flat R S] [Flat S M] : Flat R M := by\n  rw [Flat.iff_lTensor_injectiveₛ]\n  introv\n  rw [← coe_lTensor (A := S), ← EquivLike.injective_comp (cancelBaseChange R S S _ _),\n    ← LinearEquiv.coe_coe, ← LinearMap.coe_comp, lTensor_comp_cancelBaseChange,\n    LinearMap.coe_comp, LinearEquiv.coe_coe, EquivLike.comp_injective]\n  iterate 2 apply Flat.lTensor_preserves_injective_linearMap\n  exact Subtype.val_injective\n\n"}
{"name":"Module.Flat.comp","module":"Mathlib.RingTheory.Flat.Stability","initialProofState":"R : Type u\nS : Type v\nM : Type w\ninst✝⁸ : CommSemiring R\ninst✝⁷ : CommSemiring S\ninst✝⁶ : Algebra R S\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Module S M\ninst✝² : IsScalarTower R S M\ninst✝¹ : Module.Flat R S\ninst✝ : Module.Flat S M\n⊢ Module.Flat R M","decl":"@[deprecated (since := \"2024-11-03\")] alias comp := trans\n\n"}
{"name":"Module.Flat.baseChange","module":"Mathlib.RingTheory.Flat.Stability","initialProofState":"R : Type u\nS : Type v\nM : Type w\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring S\ninst✝³ : Algebra R S\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Module.Flat R M\n⊢ Module.Flat S (TensorProduct R S M)","decl":"/-- If `M` is a flat `R`-module and `S` is any `R`-algebra, `S ⊗[R] M` is `S`-flat. -/\ninstance baseChange [Flat R M] : Flat S (S ⊗[R] M) := inferInstance\n\n"}
{"name":"Module.Flat.isBaseChange","module":"Mathlib.RingTheory.Flat.Stability","initialProofState":"R : Type u\nS : Type v\nM : Type w\ninst✝⁹ : CommSemiring R\ninst✝⁸ : CommSemiring S\ninst✝⁷ : Algebra R S\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : Module.Flat R M\nN : Type t\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : Module S N\ninst✝ : IsScalarTower R S N\nf : LinearMap (RingHom.id R) M N\nh : IsBaseChange S f\n⊢ Module.Flat S N","decl":"/-- A base change of a flat module is flat. -/\ntheorem isBaseChange [Flat R M] (N : Type t) [AddCommMonoid N] [Module R N] [Module S N]\n    [IsScalarTower R S N] {f : M →ₗ[R] N} (h : IsBaseChange S f) :\n    Flat S N :=\n  of_linearEquiv (IsBaseChange.equiv h).symm\n\n"}
{"name":"Module.Flat.localizedModule","module":"Mathlib.RingTheory.Flat.Stability","initialProofState":"R : Type u\nM : Type u_1\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Module.Flat R M\nS : Submonoid R\n⊢ Module.Flat (Localization S) (LocalizedModule S M)","decl":"instance localizedModule [Flat R M] (S : Submonoid R) :\n    Flat (Localization S) (LocalizedModule S M) := by\n  apply Flat.isBaseChange (R := R) (S := Localization S)\n    (f := LocalizedModule.mkLinearMap S M)\n  rw [← isLocalizedModule_iff_isBaseChange S]\n  exact localizedModuleIsLocalizedModule S\n\n"}
{"name":"Module.Flat.of_isLocalizedModule","module":"Mathlib.RingTheory.Flat.Stability","initialProofState":"R : Type u\nM : Type u_1\nMp : Type u_2\nRp : Type v\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\ninst✝⁷ : CommSemiring Rp\ninst✝⁶ : Algebra R Rp\ninst✝⁵ : AddCommMonoid Mp\ninst✝⁴ : Module R Mp\ninst✝³ : Module Rp Mp\ninst✝² : IsScalarTower R Rp Mp\ninst✝¹ : Module.Flat R M\nS : Submonoid R\ninst✝ : IsLocalization S Rp\nf : LinearMap (RingHom.id R) M Mp\nh : IsLocalizedModule S f\n⊢ Module.Flat Rp Mp","decl":"theorem of_isLocalizedModule [Flat R M] (S : Submonoid R) [IsLocalization S Rp]\n    (f : M →ₗ[R] Mp) [h : IsLocalizedModule S f] : Flat Rp Mp := by\n  fapply Flat.isBaseChange (R := R) (M := M) (S := Rp) (N := Mp)\n  exact (isLocalizedModule_iff_isBaseChange S Rp f).mp h\n\n"}
