{"name":"Finset.card_dfinsupp","module":"Mathlib.Data.DFinsupp.Interval","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → Zero (α i)\ns : Finset ι\nt : (i : ι) → Finset (α i)\n⊢ Eq (s.dfinsupp t).card (s.prod fun i => (t i).card)","decl":"@[simp]\ntheorem card_dfinsupp (s : Finset ι) (t : ∀ i, Finset (α i)) : #(s.dfinsupp t) = ∏ i ∈ s, #(t i) :=\n  (card_map _).trans <| card_pi _ _\n\n"}
{"name":"Finset.mem_dfinsupp_iff","module":"Mathlib.Data.DFinsupp.Interval","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → Zero (α i)\ns : Finset ι\nf : DFinsupp fun i => α i\nt : (i : ι) → Finset (α i)\ninst✝ : (i : ι) → DecidableEq (α i)\n⊢ Iff (Membership.mem (s.dfinsupp t) f) (And (HasSubset.Subset f.support s) (∀ (i : ι), Membership.mem s i → Membership.mem (t i) (f i)))","decl":"theorem mem_dfinsupp_iff : f ∈ s.dfinsupp t ↔ f.support ⊆ s ∧ ∀ i ∈ s, f i ∈ t i := by\n  refine mem_map.trans ⟨?_, ?_⟩\n  · rintro ⟨f, hf, rfl⟩\n    rw [Function.Embedding.coeFn_mk] -- Porting note: added to avoid heartbeat timeout\n    refine ⟨support_mk_subset, fun i hi => ?_⟩\n    convert mem_pi.1 hf i hi\n    exact mk_of_mem hi\n  · refine fun h => ⟨fun i _ => f i, mem_pi.2 h.2, ?_⟩\n    ext i\n    dsimp\n    exact ite_eq_left_iff.2 fun hi => (not_mem_support_iff.1 fun H => hi <| h.1 H).symm\n\n"}
{"name":"Finset.mem_dfinsupp_iff_of_support_subset","module":"Mathlib.Data.DFinsupp.Interval","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → Zero (α i)\ns : Finset ι\nf : DFinsupp fun i => α i\ninst✝ : (i : ι) → DecidableEq (α i)\nt : DFinsupp fun i => Finset (α i)\nht : HasSubset.Subset t.support s\n⊢ Iff (Membership.mem (s.dfinsupp ⇑t) f) (∀ (i : ι), Membership.mem (t i) (f i))","decl":"/-- When `t` is supported on `s`, `f ∈ s.dfinsupp t` precisely means that `f` is pointwise in `t`.\n-/\n@[simp]\ntheorem mem_dfinsupp_iff_of_support_subset {t : Π₀ i, Finset (α i)} (ht : t.support ⊆ s) :\n    f ∈ s.dfinsupp t ↔ ∀ i, f i ∈ t i := by\n  refine mem_dfinsupp_iff.trans (forall_and.symm.trans <| forall_congr' fun i =>\n      ⟨ fun h => ?_,\n        fun h => ⟨fun hi => ht <| mem_support_iff.2 fun H => mem_support_iff.1 hi ?_, fun _ => h⟩⟩)\n  · by_cases hi : i ∈ s\n    · exact h.2 hi\n    · rw [not_mem_support_iff.1 (mt h.1 hi), not_mem_support_iff.1 (not_mem_mono ht hi)]\n      exact zero_mem_zero\n  · rwa [H, mem_zero] at h\n\n"}
{"name":"DFinsupp.mem_singleton_apply_iff","module":"Mathlib.Data.DFinsupp.Interval","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → Zero (α i)\nf : DFinsupp fun i => α i\ni : ι\na : α i\n⊢ Iff (Membership.mem (f.singleton i) a) (Eq a (f i))","decl":"theorem mem_singleton_apply_iff : a ∈ f.singleton i ↔ a = f i :=\n  mem_singleton\n\n"}
{"name":"DFinsupp.rangeIcc_apply","module":"Mathlib.Data.DFinsupp.Interval","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝² : (i : ι) → Zero (α i)\ninst✝¹ : (i : ι) → PartialOrder (α i)\ninst✝ : (i : ι) → LocallyFiniteOrder (α i)\nf g : DFinsupp fun i => α i\ni : ι\n⊢ Eq ((f.rangeIcc g) i) (Finset.Icc (f i) (g i))","decl":"@[simp]\ntheorem rangeIcc_apply (f g : Π₀ i, α i) (i : ι) : f.rangeIcc g i = Icc (f i) (g i) := rfl\n\n"}
{"name":"DFinsupp.mem_rangeIcc_apply_iff","module":"Mathlib.Data.DFinsupp.Interval","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝² : (i : ι) → Zero (α i)\ninst✝¹ : (i : ι) → PartialOrder (α i)\ninst✝ : (i : ι) → LocallyFiniteOrder (α i)\nf g : DFinsupp fun i => α i\ni : ι\na : α i\n⊢ Iff (Membership.mem ((f.rangeIcc g) i) a) (And (LE.le (f i) a) (LE.le a (g i)))","decl":"theorem mem_rangeIcc_apply_iff : a ∈ f.rangeIcc g i ↔ f i ≤ a ∧ a ≤ g i := mem_Icc\n\n"}
{"name":"DFinsupp.support_rangeIcc_subset","module":"Mathlib.Data.DFinsupp.Interval","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝⁴ : (i : ι) → Zero (α i)\ninst✝³ : (i : ι) → PartialOrder (α i)\ninst✝² : (i : ι) → LocallyFiniteOrder (α i)\nf g : DFinsupp fun i => α i\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (α i)\n⊢ HasSubset.Subset (f.rangeIcc g).support (Union.union f.support g.support)","decl":"theorem support_rangeIcc_subset [DecidableEq ι] [∀ i, DecidableEq (α i)] :\n    (f.rangeIcc g).support ⊆ f.support ∪ g.support := by\n  refine fun x hx => ?_\n  by_contra h\n  refine not_mem_support_iff.2 ?_ hx\n  rw [rangeIcc_apply, not_mem_support_iff.1 (not_mem_mono subset_union_left h),\n    not_mem_support_iff.1 (not_mem_mono subset_union_right h)]\n  exact Icc_self _\n\n"}
{"name":"DFinsupp.mem_pi","module":"Mathlib.Data.DFinsupp.Interval","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝² : (i : ι) → Zero (α i)\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (α i)\nf : DFinsupp fun i => Finset (α i)\ng : DFinsupp fun i => α i\n⊢ Iff (Membership.mem f.pi g) (∀ (i : ι), Membership.mem (f i) (g i))","decl":"@[simp]\ntheorem mem_pi {f : Π₀ i, Finset (α i)} {g : Π₀ i, α i} : g ∈ f.pi ↔ ∀ i, g i ∈ f i :=\n  mem_dfinsupp_iff_of_support_subset <| Subset.refl _\n\n"}
{"name":"DFinsupp.card_pi","module":"Mathlib.Data.DFinsupp.Interval","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝² : (i : ι) → Zero (α i)\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (α i)\nf : DFinsupp fun i => Finset (α i)\n⊢ Eq f.pi.card (f.prod fun i => ↑(f i).card)","decl":"@[simp]\ntheorem card_pi (f : Π₀ i, Finset (α i)) : #f.pi = f.prod fun i ↦ #(f i) := by\n  rw [pi, card_dfinsupp]\n  exact Finset.prod_congr rfl fun i _ => by simp only [Pi.natCast_apply, Nat.cast_id]\n\n"}
{"name":"DFinsupp.Icc_eq","module":"Mathlib.Data.DFinsupp.Interval","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝⁴ : DecidableEq ι\ninst✝³ : (i : ι) → DecidableEq (α i)\ninst✝² : (i : ι) → PartialOrder (α i)\ninst✝¹ : (i : ι) → Zero (α i)\ninst✝ : (i : ι) → LocallyFiniteOrder (α i)\nf g : DFinsupp fun i => α i\n⊢ Eq (Finset.Icc f g) ((Union.union f.support g.support).dfinsupp ⇑(f.rangeIcc g))","decl":"theorem Icc_eq : Icc f g = (f.support ∪ g.support).dfinsupp (f.rangeIcc g) := rfl\n\n"}
{"name":"DFinsupp.card_Icc","module":"Mathlib.Data.DFinsupp.Interval","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝⁴ : DecidableEq ι\ninst✝³ : (i : ι) → DecidableEq (α i)\ninst✝² : (i : ι) → PartialOrder (α i)\ninst✝¹ : (i : ι) → Zero (α i)\ninst✝ : (i : ι) → LocallyFiniteOrder (α i)\nf g : DFinsupp fun i => α i\n⊢ Eq (Finset.Icc f g).card ((Union.union f.support g.support).prod fun i => (Finset.Icc (f i) (g i)).card)","decl":"lemma card_Icc : #(Icc f g) = ∏ i ∈ f.support ∪ g.support, #(Icc (f i) (g i)) :=\n  card_dfinsupp _ _\n\n"}
{"name":"DFinsupp.card_Ico","module":"Mathlib.Data.DFinsupp.Interval","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝⁴ : DecidableEq ι\ninst✝³ : (i : ι) → DecidableEq (α i)\ninst✝² : (i : ι) → PartialOrder (α i)\ninst✝¹ : (i : ι) → Zero (α i)\ninst✝ : (i : ι) → LocallyFiniteOrder (α i)\nf g : DFinsupp fun i => α i\n⊢ Eq (Finset.Ico f g).card (HSub.hSub ((Union.union f.support g.support).prod fun i => (Finset.Icc (f i) (g i)).card) 1)","decl":"lemma card_Ico : #(Ico f g) = (∏ i ∈ f.support ∪ g.support, #(Icc (f i) (g i))) - 1 := by\n  rw [card_Ico_eq_card_Icc_sub_one, card_Icc]\n\n"}
{"name":"DFinsupp.card_Ioc","module":"Mathlib.Data.DFinsupp.Interval","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝⁴ : DecidableEq ι\ninst✝³ : (i : ι) → DecidableEq (α i)\ninst✝² : (i : ι) → PartialOrder (α i)\ninst✝¹ : (i : ι) → Zero (α i)\ninst✝ : (i : ι) → LocallyFiniteOrder (α i)\nf g : DFinsupp fun i => α i\n⊢ Eq (Finset.Ioc f g).card (HSub.hSub ((Union.union f.support g.support).prod fun i => (Finset.Icc (f i) (g i)).card) 1)","decl":"lemma card_Ioc : #(Ioc f g) = (∏ i ∈ f.support ∪ g.support, #(Icc (f i) (g i))) - 1 := by\n  rw [card_Ioc_eq_card_Icc_sub_one, card_Icc]\n\n"}
{"name":"DFinsupp.card_Ioo","module":"Mathlib.Data.DFinsupp.Interval","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝⁴ : DecidableEq ι\ninst✝³ : (i : ι) → DecidableEq (α i)\ninst✝² : (i : ι) → PartialOrder (α i)\ninst✝¹ : (i : ι) → Zero (α i)\ninst✝ : (i : ι) → LocallyFiniteOrder (α i)\nf g : DFinsupp fun i => α i\n⊢ Eq (Finset.Ioo f g).card (HSub.hSub ((Union.union f.support g.support).prod fun i => (Finset.Icc (f i) (g i)).card) 2)","decl":"lemma card_Ioo : #(Ioo f g) = (∏ i ∈ f.support ∪ g.support, #(Icc (f i) (g i))) - 2 := by\n  rw [card_Ioo_eq_card_Icc_sub_two, card_Icc]\n\n"}
{"name":"DFinsupp.card_uIcc","module":"Mathlib.Data.DFinsupp.Interval","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝⁴ : DecidableEq ι\ninst✝³ : (i : ι) → DecidableEq (α i)\ninst✝² : (i : ι) → Lattice (α i)\ninst✝¹ : (i : ι) → Zero (α i)\ninst✝ : (i : ι) → LocallyFiniteOrder (α i)\nf g : DFinsupp fun i => α i\n⊢ Eq (Finset.uIcc f g).card ((Union.union f.support g.support).prod fun i => (Finset.uIcc (f i) (g i)).card)","decl":"lemma card_uIcc : #(uIcc f g) = ∏ i ∈ f.support ∪ g.support, #(uIcc (f i) (g i)) := by\n  rw [← support_inf_union_support_sup]; exact card_Icc _ _\n\n"}
{"name":"DFinsupp.card_Iic","module":"Mathlib.Data.DFinsupp.Interval","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : (i : ι) → DecidableEq (α i)\ninst✝³ : (i : ι) → AddCommMonoid (α i)\ninst✝² : (i : ι) → PartialOrder (α i)\ninst✝¹ : ∀ (i : ι), CanonicallyOrderedAdd (α i)\ninst✝ : (i : ι) → LocallyFiniteOrder (α i)\nf : DFinsupp fun i => α i\n⊢ Eq (Finset.Iic f).card (f.support.prod fun i => (Finset.Iic (f i)).card)","decl":"lemma card_Iic : #(Iic f) = ∏ i ∈ f.support, #(Iic (f i)) := by\n  simp_rw [Iic_eq_Icc, card_Icc, DFinsupp.bot_eq_zero, support_zero, empty_union, zero_apply,\n    bot_eq_zero]\n\n"}
{"name":"DFinsupp.card_Iio","module":"Mathlib.Data.DFinsupp.Interval","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : (i : ι) → DecidableEq (α i)\ninst✝³ : (i : ι) → AddCommMonoid (α i)\ninst✝² : (i : ι) → PartialOrder (α i)\ninst✝¹ : ∀ (i : ι), CanonicallyOrderedAdd (α i)\ninst✝ : (i : ι) → LocallyFiniteOrder (α i)\nf : DFinsupp fun i => α i\n⊢ Eq (Finset.Iio f).card (HSub.hSub (f.support.prod fun i => (Finset.Iic (f i)).card) 1)","decl":"lemma card_Iio : #(Iio f) = (∏ i ∈ f.support, #(Iic (f i))) - 1 := by\n  rw [card_Iio_eq_card_Iic_sub_one, card_Iic]\n\n"}
