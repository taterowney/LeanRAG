{"name":"MeasureTheory.MeasurePreserving.measurable","module":"Mathlib.Dynamics.Ergodic.MeasurePreserving","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\nμa : autoParam (MeasureTheory.Measure α) _auto✝\nμb : autoParam (MeasureTheory.Measure β) _auto✝\nself : MeasureTheory.MeasurePreserving f μa μb\n⊢ Measurable f","decl":"/-- `f` is a measure preserving map w.r.t. measures `μa` and `μb` if `f` is measurable\nand `map f μa = μb`. -/\nstructure MeasurePreserving (f : α → β)\n  (μa : Measure α := by volume_tac) (μb : Measure β := by volume_tac) : Prop where\n  protected measurable : Measurable f\n  protected map_eq : map f μa = μb\n\n"}
{"name":"MeasureTheory.MeasurePreserving.map_eq","module":"Mathlib.Dynamics.Ergodic.MeasurePreserving","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\nμa : autoParam (MeasureTheory.Measure α) _auto✝\nμb : autoParam (MeasureTheory.Measure β) _auto✝\nself : MeasureTheory.MeasurePreserving f μa μb\n⊢ Eq (MeasureTheory.Measure.map f μa) μb","decl":"/-- `f` is a measure preserving map w.r.t. measures `μa` and `μb` if `f` is measurable\nand `map f μa = μb`. -/\nstructure MeasurePreserving (f : α → β)\n  (μa : Measure α := by volume_tac) (μb : Measure β := by volume_tac) : Prop where\n  protected measurable : Measurable f\n  protected map_eq : map f μa = μb\n\n"}
{"name":"Measurable.measurePreserving","module":"Mathlib.Dynamics.Ergodic.MeasurePreserving","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\nh : Measurable f\nμa : MeasureTheory.Measure α\n⊢ MeasureTheory.MeasurePreserving f μa (MeasureTheory.Measure.map f μa)","decl":"protected theorem _root_.Measurable.measurePreserving\n    {f : α → β} (h : Measurable f) (μa : Measure α) : MeasurePreserving f μa (map f μa) :=\n  ⟨h, rfl⟩\n\n"}
{"name":"MeasureTheory.MeasurePreserving.id","module":"Mathlib.Dynamics.Ergodic.MeasurePreserving","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ MeasureTheory.MeasurePreserving id μ μ","decl":"protected theorem id (μ : Measure α) : MeasurePreserving id μ μ :=\n  ⟨measurable_id, map_id⟩\n\n"}
{"name":"MeasureTheory.MeasurePreserving.aemeasurable","module":"Mathlib.Dynamics.Ergodic.MeasurePreserving","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμa : MeasureTheory.Measure α\nμb : MeasureTheory.Measure β\nf : α → β\nhf : MeasureTheory.MeasurePreserving f μa μb\n⊢ AEMeasurable f μa","decl":"protected theorem aemeasurable {f : α → β} (hf : MeasurePreserving f μa μb) : AEMeasurable f μa :=\n  hf.1.aemeasurable\n\n"}
{"name":"MeasureTheory.MeasurePreserving.of_isEmpty","module":"Mathlib.Dynamics.Ergodic.MeasurePreserving","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : IsEmpty β\nf : α → β\nμa : MeasureTheory.Measure α\nμb : MeasureTheory.Measure β\n⊢ MeasureTheory.MeasurePreserving f μa μb","decl":"@[nontriviality]\ntheorem of_isEmpty [IsEmpty β] (f : α → β) (μa : Measure α) (μb : Measure β) :\n    MeasurePreserving f μa μb :=\n  ⟨measurable_of_subsingleton_codomain _, Subsingleton.elim _ _⟩\n\n"}
{"name":"MeasureTheory.MeasurePreserving.symm","module":"Mathlib.Dynamics.Ergodic.MeasurePreserving","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ne : MeasurableEquiv α β\nμa : MeasureTheory.Measure α\nμb : MeasureTheory.Measure β\nh : MeasureTheory.MeasurePreserving (⇑e) μa μb\n⊢ MeasureTheory.MeasurePreserving (⇑e.symm) μb μa","decl":"theorem symm (e : α ≃ᵐ β) {μa : Measure α} {μb : Measure β} (h : MeasurePreserving e μa μb) :\n    MeasurePreserving e.symm μb μa :=\n  ⟨e.symm.measurable, by\n    rw [← h.map_eq, map_map e.symm.measurable e.measurable, e.symm_comp_self, map_id]⟩\n\n"}
{"name":"MeasureTheory.MeasurePreserving.restrict_preimage","module":"Mathlib.Dynamics.Ergodic.MeasurePreserving","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμa : MeasureTheory.Measure α\nμb : MeasureTheory.Measure β\nf : α → β\nhf : MeasureTheory.MeasurePreserving f μa μb\ns : Set β\nhs : MeasurableSet s\n⊢ MeasureTheory.MeasurePreserving f (μa.restrict (Set.preimage f s)) (μb.restrict s)","decl":"theorem restrict_preimage {f : α → β} (hf : MeasurePreserving f μa μb) {s : Set β}\n    (hs : MeasurableSet s) : MeasurePreserving f (μa.restrict (f ⁻¹' s)) (μb.restrict s) :=\n  ⟨hf.measurable, by rw [← hf.map_eq, restrict_map hf.measurable hs]⟩\n\n"}
{"name":"MeasureTheory.MeasurePreserving.restrict_preimage_emb","module":"Mathlib.Dynamics.Ergodic.MeasurePreserving","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμa : MeasureTheory.Measure α\nμb : MeasureTheory.Measure β\nf : α → β\nhf : MeasureTheory.MeasurePreserving f μa μb\nh₂ : MeasurableEmbedding f\ns : Set β\n⊢ MeasureTheory.MeasurePreserving f (μa.restrict (Set.preimage f s)) (μb.restrict s)","decl":"theorem restrict_preimage_emb {f : α → β} (hf : MeasurePreserving f μa μb)\n    (h₂ : MeasurableEmbedding f) (s : Set β) :\n    MeasurePreserving f (μa.restrict (f ⁻¹' s)) (μb.restrict s) :=\n  ⟨hf.measurable, by rw [← hf.map_eq, h₂.restrict_map]⟩\n\n"}
{"name":"MeasureTheory.MeasurePreserving.restrict_image_emb","module":"Mathlib.Dynamics.Ergodic.MeasurePreserving","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμa : MeasureTheory.Measure α\nμb : MeasureTheory.Measure β\nf : α → β\nhf : MeasureTheory.MeasurePreserving f μa μb\nh₂ : MeasurableEmbedding f\ns : Set α\n⊢ MeasureTheory.MeasurePreserving f (μa.restrict s) (μb.restrict (Set.image f s))","decl":"theorem restrict_image_emb {f : α → β} (hf : MeasurePreserving f μa μb) (h₂ : MeasurableEmbedding f)\n    (s : Set α) : MeasurePreserving f (μa.restrict s) (μb.restrict (f '' s)) := by\n  simpa only [Set.preimage_image_eq _ h₂.injective] using hf.restrict_preimage_emb h₂ (f '' s)\n\n"}
{"name":"MeasureTheory.MeasurePreserving.aemeasurable_comp_iff","module":"Mathlib.Dynamics.Ergodic.MeasurePreserving","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace γ\nμa : MeasureTheory.Measure α\nμb : MeasureTheory.Measure β\nf : α → β\nhf : MeasureTheory.MeasurePreserving f μa μb\nh₂ : MeasurableEmbedding f\ng : β → γ\n⊢ Iff (AEMeasurable (Function.comp g f) μa) (AEMeasurable g μb)","decl":"theorem aemeasurable_comp_iff {f : α → β} (hf : MeasurePreserving f μa μb)\n    (h₂ : MeasurableEmbedding f) {g : β → γ} : AEMeasurable (g ∘ f) μa ↔ AEMeasurable g μb := by\n  rw [← hf.map_eq, h₂.aemeasurable_map_iff]\n\n"}
{"name":"MeasureTheory.MeasurePreserving.quasiMeasurePreserving","module":"Mathlib.Dynamics.Ergodic.MeasurePreserving","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμa : MeasureTheory.Measure α\nμb : MeasureTheory.Measure β\nf : α → β\nhf : MeasureTheory.MeasurePreserving f μa μb\n⊢ MeasureTheory.Measure.QuasiMeasurePreserving f μa μb","decl":"protected theorem quasiMeasurePreserving {f : α → β} (hf : MeasurePreserving f μa μb) :\n    QuasiMeasurePreserving f μa μb :=\n  ⟨hf.1, hf.2.absolutelyContinuous⟩\n\n"}
{"name":"MeasureTheory.MeasurePreserving.comp","module":"Mathlib.Dynamics.Ergodic.MeasurePreserving","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace γ\nμa : MeasureTheory.Measure α\nμb : MeasureTheory.Measure β\nμc : MeasureTheory.Measure γ\ng : β → γ\nf : α → β\nhg : MeasureTheory.MeasurePreserving g μb μc\nhf : MeasureTheory.MeasurePreserving f μa μb\n⊢ MeasureTheory.MeasurePreserving (Function.comp g f) μa μc","decl":"protected theorem comp {g : β → γ} {f : α → β} (hg : MeasurePreserving g μb μc)\n    (hf : MeasurePreserving f μa μb) : MeasurePreserving (g ∘ f) μa μc :=\n  ⟨hg.1.comp hf.1, by rw [← map_map hg.1 hf.1, hf.2, hg.2]⟩\n\n"}
{"name":"MeasureTheory.MeasurePreserving.trans","module":"Mathlib.Dynamics.Ergodic.MeasurePreserving","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace γ\ne : MeasurableEquiv α β\ne' : MeasurableEquiv β γ\nμa : MeasureTheory.Measure α\nμb : MeasureTheory.Measure β\nμc : MeasureTheory.Measure γ\nh : MeasureTheory.MeasurePreserving (⇑e) μa μb\nh' : MeasureTheory.MeasurePreserving (⇑e') μb μc\n⊢ MeasureTheory.MeasurePreserving (⇑(e.trans e')) μa μc","decl":"/-- An alias of `MeasureTheory.MeasurePreserving.comp` with a convenient defeq and argument order\nfor `MeasurableEquiv` -/\nprotected theorem trans {e : α ≃ᵐ β} {e' : β ≃ᵐ γ}\n    {μa : Measure α} {μb : Measure β} {μc : Measure γ}\n    (h : MeasurePreserving e μa μb) (h' : MeasurePreserving e' μb μc) :\n    MeasurePreserving (e.trans e') μa μc :=\n  h'.comp h\n\n"}
{"name":"MeasureTheory.MeasurePreserving.comp_left_iff","module":"Mathlib.Dynamics.Ergodic.MeasurePreserving","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace γ\nμa : MeasureTheory.Measure α\nμb : MeasureTheory.Measure β\nμc : MeasureTheory.Measure γ\ng : α → β\ne : MeasurableEquiv β γ\nh : MeasureTheory.MeasurePreserving (⇑e) μb μc\n⊢ Iff (MeasureTheory.MeasurePreserving (Function.comp (⇑e) g) μa μc) (MeasureTheory.MeasurePreserving g μa μb)","decl":"protected theorem comp_left_iff {g : α → β} {e : β ≃ᵐ γ} (h : MeasurePreserving e μb μc) :\n    MeasurePreserving (e ∘ g) μa μc ↔ MeasurePreserving g μa μb := by\n  refine ⟨fun hg => ?_, fun hg => h.comp hg⟩\n  convert (MeasurePreserving.symm e h).comp hg\n  simp [← Function.comp_assoc e.symm e g]\n\n"}
{"name":"MeasureTheory.MeasurePreserving.comp_right_iff","module":"Mathlib.Dynamics.Ergodic.MeasurePreserving","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace γ\nμa : MeasureTheory.Measure α\nμb : MeasureTheory.Measure β\nμc : MeasureTheory.Measure γ\ng : α → β\ne : MeasurableEquiv γ α\nh : MeasureTheory.MeasurePreserving (⇑e) μc μa\n⊢ Iff (MeasureTheory.MeasurePreserving (Function.comp g ⇑e) μc μb) (MeasureTheory.MeasurePreserving g μa μb)","decl":"protected theorem comp_right_iff {g : α → β} {e : γ ≃ᵐ α} (h : MeasurePreserving e μc μa) :\n    MeasurePreserving (g ∘ e) μc μb ↔ MeasurePreserving g μa μb := by\n  refine ⟨fun hg => ?_, fun hg => hg.comp h⟩\n  convert hg.comp (MeasurePreserving.symm e h)\n  simp [Function.comp_assoc g e e.symm]\n\n"}
{"name":"MeasureTheory.MeasurePreserving.sigmaFinite","module":"Mathlib.Dynamics.Ergodic.MeasurePreserving","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμa : MeasureTheory.Measure α\nμb : MeasureTheory.Measure β\nf : α → β\nhf : MeasureTheory.MeasurePreserving f μa μb\ninst✝ : MeasureTheory.SigmaFinite μb\n⊢ MeasureTheory.SigmaFinite μa","decl":"protected theorem sigmaFinite {f : α → β} (hf : MeasurePreserving f μa μb) [SigmaFinite μb] :\n    SigmaFinite μa :=\n  SigmaFinite.of_map μa hf.aemeasurable (by rwa [hf.map_eq])\n\n"}
{"name":"MeasureTheory.MeasurePreserving.measure_preimage","module":"Mathlib.Dynamics.Ergodic.MeasurePreserving","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμa : MeasureTheory.Measure α\nμb : MeasureTheory.Measure β\nf : α → β\nhf : MeasureTheory.MeasurePreserving f μa μb\ns : Set β\nhs : MeasureTheory.NullMeasurableSet s μb\n⊢ Eq (μa (Set.preimage f s)) (μb s)","decl":"theorem measure_preimage {f : α → β} (hf : MeasurePreserving f μa μb) {s : Set β}\n    (hs : NullMeasurableSet s μb) : μa (f ⁻¹' s) = μb s := by\n  rw [← hf.map_eq] at hs ⊢\n  rw [map_apply₀ hf.1.aemeasurable hs]\n\n"}
{"name":"MeasureTheory.MeasurePreserving.measure_preimage_emb","module":"Mathlib.Dynamics.Ergodic.MeasurePreserving","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμa : MeasureTheory.Measure α\nμb : MeasureTheory.Measure β\nf : α → β\nhf : MeasureTheory.MeasurePreserving f μa μb\nhfe : MeasurableEmbedding f\ns : Set β\n⊢ Eq (μa (Set.preimage f s)) (μb s)","decl":"theorem measure_preimage_emb {f : α → β} (hf : MeasurePreserving f μa μb)\n    (hfe : MeasurableEmbedding f) (s : Set β) : μa (f ⁻¹' s) = μb s := by\n  rw [← hf.map_eq, hfe.map_apply]\n\n"}
{"name":"MeasureTheory.MeasurePreserving.measure_preimage_equiv","module":"Mathlib.Dynamics.Ergodic.MeasurePreserving","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμa : MeasureTheory.Measure α\nμb : MeasureTheory.Measure β\nf : MeasurableEquiv α β\nhf : MeasureTheory.MeasurePreserving (⇑f) μa μb\ns : Set β\n⊢ Eq (μa (Set.preimage (⇑f) s)) (μb s)","decl":"theorem measure_preimage_equiv {f : α ≃ᵐ β} (hf : MeasurePreserving f μa μb) (s : Set β) :\n    μa (f ⁻¹' s) = μb s :=\n  measure_preimage_emb hf f.measurableEmbedding s\n\n"}
{"name":"MeasureTheory.MeasurePreserving.aeconst_comp","module":"Mathlib.Dynamics.Ergodic.MeasurePreserving","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\ninst✝¹ : MeasurableSpace γ\nμa : MeasureTheory.Measure α\nμb : MeasureTheory.Measure β\ninst✝ : MeasurableSingletonClass γ\nf : α → β\nhf : MeasureTheory.MeasurePreserving f μa μb\ng : β → γ\nhg : MeasureTheory.NullMeasurable g μb\n⊢ Iff (Filter.EventuallyConst (Function.comp g f) (MeasureTheory.ae μa)) (Filter.EventuallyConst g (MeasureTheory.ae μb))","decl":"theorem aeconst_comp [MeasurableSingletonClass γ] {f : α → β} (hf : MeasurePreserving f μa μb)\n    {g : β → γ} (hg : NullMeasurable g μb) :\n    Filter.EventuallyConst (g ∘ f) (ae μa) ↔ Filter.EventuallyConst g (ae μb) :=\n  exists_congr fun s ↦ and_congr_left fun hs ↦ by\n    simp only [Filter.mem_map, mem_ae_iff, ← hf.measure_preimage (hg hs.measurableSet).compl,\n      preimage_comp, preimage_compl]\n\n"}
{"name":"MeasureTheory.MeasurePreserving.aeconst_preimage","module":"Mathlib.Dynamics.Ergodic.MeasurePreserving","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμa : MeasureTheory.Measure α\nμb : MeasureTheory.Measure β\nf : α → β\nhf : MeasureTheory.MeasurePreserving f μa μb\ns : Set β\nhs : MeasureTheory.NullMeasurableSet s μb\n⊢ Iff (Filter.EventuallyConst (Set.preimage f s) (MeasureTheory.ae μa)) (Filter.EventuallyConst s (MeasureTheory.ae μb))","decl":"theorem aeconst_preimage {f : α → β} (hf : MeasurePreserving f μa μb) {s : Set β}\n    (hs : NullMeasurableSet s μb) :\n    Filter.EventuallyConst (f ⁻¹' s) (ae μa) ↔ Filter.EventuallyConst s (ae μb) :=\n  aeconst_comp hf hs.mem\n\n"}
{"name":"MeasureTheory.MeasurePreserving.add_measure","module":"Mathlib.Dynamics.Ergodic.MeasurePreserving","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμa : MeasureTheory.Measure α\nμb : MeasureTheory.Measure β\nf : α → β\nμa' : MeasureTheory.Measure α\nμb' : MeasureTheory.Measure β\nhf : MeasureTheory.MeasurePreserving f μa μb\nhf' : MeasureTheory.MeasurePreserving f μa' μb'\n⊢ MeasureTheory.MeasurePreserving f (HAdd.hAdd μa μa') (HAdd.hAdd μb μb')","decl":"theorem add_measure {f μa' μb'} (hf : MeasurePreserving f μa μb)\n    (hf' : MeasurePreserving f μa' μb') : MeasurePreserving f (μa + μa') (μb + μb') where\n  measurable := hf.measurable\n  map_eq := by rw [Measure.map_add _ _ hf.measurable, hf.map_eq, hf'.map_eq]\n\n"}
{"name":"MeasureTheory.MeasurePreserving.smul_measure","module":"Mathlib.Dynamics.Ergodic.MeasurePreserving","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\nμa : MeasureTheory.Measure α\nμb : MeasureTheory.Measure β\nR : Type u_5\ninst✝¹ : SMul R ENNReal\ninst✝ : IsScalarTower R ENNReal ENNReal\nf : α → β\nhf : MeasureTheory.MeasurePreserving f μa μb\nc : R\n⊢ MeasureTheory.MeasurePreserving f (HSMul.hSMul c μa) (HSMul.hSMul c μb)","decl":"theorem smul_measure {R : Type*} [SMul R ℝ≥0∞] [IsScalarTower R ℝ≥0∞ ℝ≥0∞] {f : α → β}\n    (hf : MeasurePreserving f μa μb) (c : R) : MeasurePreserving f (c • μa) (c • μb) where\n  measurable := hf.measurable\n  map_eq := by rw [Measure.map_smul, hf.map_eq]\n\n"}
{"name":"MeasureTheory.MeasurePreserving.iterate","module":"Mathlib.Dynamics.Ergodic.MeasurePreserving","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → α\nhf : MeasureTheory.MeasurePreserving f μ μ\nn : Nat\n⊢ MeasureTheory.MeasurePreserving (Nat.iterate f n) μ μ","decl":"protected theorem iterate (hf : MeasurePreserving f μ μ) :\n    ∀ n, MeasurePreserving f^[n] μ μ\n  | 0 => .id μ\n  | n + 1 => (MeasurePreserving.iterate hf n).comp hf\n\n"}
{"name":"MeasureTheory.MeasurePreserving.measure_symmDiff_preimage_iterate_le","module":"Mathlib.Dynamics.Ergodic.MeasurePreserving","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → α\ns : Set α\nhf : MeasureTheory.MeasurePreserving f μ μ\nhs : MeasureTheory.NullMeasurableSet s μ\nn : Nat\n⊢ LE.le (μ (symmDiff s (Set.preimage (Nat.iterate f n) s))) (HSMul.hSMul n (μ (symmDiff s (Set.preimage f s))))","decl":"open scoped symmDiff in\nlemma measure_symmDiff_preimage_iterate_le\n    (hf : MeasurePreserving f μ μ) (hs : NullMeasurableSet s μ) (n : ℕ) :\n    μ (s ∆ (f^[n] ⁻¹' s)) ≤ n • μ (s ∆ (f ⁻¹' s)) := by\n  induction' n with n ih; · simp\n  simp only [add_smul, one_smul, ← n.add_one]\n  refine le_trans (measure_symmDiff_le s (f^[n] ⁻¹' s) (f^[n+1] ⁻¹' s)) (add_le_add ih ?_)\n  replace hs : NullMeasurableSet (s ∆ (f ⁻¹' s)) μ :=\n    hs.symmDiff <| hs.preimage hf.quasiMeasurePreserving\n  rw [iterate_succ', preimage_comp, ← preimage_symmDiff, (hf.iterate n).measure_preimage hs]\n\n"}
{"name":"MeasureTheory.MeasurePreserving.exists_mem_iterate_mem_of_measure_univ_lt_mul_measure","module":"Mathlib.Dynamics.Ergodic.MeasurePreserving","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → α\ns : Set α\nhf : MeasureTheory.MeasurePreserving f μ μ\nhs : MeasureTheory.NullMeasurableSet s μ\nn : Nat\nhvol : LT.lt (μ Set.univ) (HMul.hMul (↑n) (μ s))\n⊢ Exists fun x => And (Membership.mem s x) (Exists fun m => And (Membership.mem (Set.Ioo 0 n) m) (Membership.mem s (Nat.iterate f m x)))","decl":"/-- If `μ univ < n * μ s` and `f` is a map preserving measure `μ`,\nthen for some `x ∈ s` and `0 < m < n`, `f^[m] x ∈ s`. -/\ntheorem exists_mem_iterate_mem_of_measure_univ_lt_mul_measure (hf : MeasurePreserving f μ μ)\n    (hs : NullMeasurableSet s μ) {n : ℕ} (hvol : μ (Set.univ : Set α) < n * μ s) :\n    ∃ x ∈ s, ∃ m ∈ Set.Ioo 0 n, f^[m] x ∈ s := by\n  have A : ∀ m, NullMeasurableSet (f^[m] ⁻¹' s) μ := fun m ↦\n    hs.preimage (hf.iterate m).quasiMeasurePreserving\n  have B : ∀ m, μ (f^[m] ⁻¹' s) = μ s := fun m ↦ (hf.iterate m).measure_preimage hs\n  have : μ (univ : Set α) < ∑ m ∈ Finset.range n, μ (f^[m] ⁻¹' s) := by simpa [B]\n  obtain ⟨i, hi, j, hj, hij, x, hxi : f^[i] x ∈ s, hxj : f^[j] x ∈ s⟩ :\n      ∃ i < n, ∃ j < n, i ≠ j ∧ (f^[i] ⁻¹' s ∩ f^[j] ⁻¹' s).Nonempty := by\n    simpa using exists_nonempty_inter_of_measure_univ_lt_sum_measure μ (fun m _ ↦ A m) this\n  wlog hlt : i < j generalizing i j\n  · exact this j hj i hi hij.symm hxj hxi (hij.lt_or_lt.resolve_left hlt)\n  refine ⟨f^[i] x, hxi, j - i, ⟨tsub_pos_of_lt hlt, lt_of_le_of_lt (j.sub_le i) hj⟩, ?_⟩\n  rwa [← iterate_add_apply, tsub_add_cancel_of_le hlt.le]\n\n"}
{"name":"MeasureTheory.MeasurePreserving.exists_mem_iterate_mem_of_volume_lt_mul_volume","module":"Mathlib.Dynamics.Ergodic.MeasurePreserving","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → α\ns : Set α\nhf : MeasureTheory.MeasurePreserving f μ μ\nhs : MeasureTheory.NullMeasurableSet s μ\nn : Nat\nhvol : LT.lt (μ Set.univ) (HMul.hMul (↑n) (μ s))\n⊢ Exists fun x => And (Membership.mem s x) (Exists fun m => And (Membership.mem (Set.Ioo 0 n) m) (Membership.mem s (Nat.iterate f m x)))","decl":"@[deprecated (since := \"2024-08-12\")]\nalias exists_mem_iterate_mem_of_volume_lt_mul_volume :=\n  exists_mem_iterate_mem_of_measure_univ_lt_mul_measure\n\n"}
{"name":"MeasureTheory.MeasurePreserving.exists_mem_iterate_mem","module":"Mathlib.Dynamics.Ergodic.MeasurePreserving","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → α\ns : Set α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhf : MeasureTheory.MeasurePreserving f μ μ\nhs : MeasureTheory.NullMeasurableSet s μ\nhs' : Ne (μ s) 0\n⊢ Exists fun x => And (Membership.mem s x) (Exists fun m => And (Ne m 0) (Membership.mem s (Nat.iterate f m x)))","decl":"/-- A self-map preserving a finite measure is conservative: if `μ s ≠ 0`, then at least one point\n`x ∈ s` comes back to `s` under iterations of `f`. Actually, a.e. point of `s` comes back to `s`\ninfinitely many times, see `MeasureTheory.MeasurePreserving.conservative` and theorems about\n`MeasureTheory.Conservative`. -/\ntheorem exists_mem_iterate_mem [IsFiniteMeasure μ] (hf : MeasurePreserving f μ μ)\n    (hs : NullMeasurableSet s μ) (hs' : μ s ≠ 0) : ∃ x ∈ s, ∃ m ≠ 0, f^[m] x ∈ s := by\n  rcases ENNReal.exists_nat_mul_gt hs' (measure_ne_top μ (Set.univ : Set α)) with ⟨N, hN⟩\n  rcases hf.exists_mem_iterate_mem_of_measure_univ_lt_mul_measure hs hN with ⟨x, hx, m, hm, hmx⟩\n  exact ⟨x, hx, m, hm.1.ne', hmx⟩\n\n"}
{"name":"MeasureTheory.MeasurableEquiv.measurePreserving_symm","module":"Mathlib.Dynamics.Ergodic.MeasurePreserving","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμ : MeasureTheory.Measure α\ne : MeasurableEquiv α β\n⊢ MeasureTheory.MeasurePreserving (⇑e.symm) (MeasureTheory.Measure.map (⇑e) μ) μ","decl":"theorem measurePreserving_symm (μ : Measure α) (e : α ≃ᵐ β) :\n    MeasurePreserving e.symm (map e μ) μ :=\n  (e.measurable.measurePreserving μ).symm _\n\n"}
