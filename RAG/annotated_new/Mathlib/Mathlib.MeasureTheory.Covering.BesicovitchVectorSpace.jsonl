{"name":"Besicovitch.SatelliteConfig.centerAndRescale_center","module":"Mathlib.MeasureTheory.Covering.BesicovitchVectorSpace","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nN : Nat\nτ : Real\na : Besicovitch.SatelliteConfig E N τ\n⊢ Eq (a.centerAndRescale.c (Fin.last N)) 0","decl":"theorem centerAndRescale_center : a.centerAndRescale.c (last N) = 0 := by\n  simp [SatelliteConfig.centerAndRescale]\n\n"}
{"name":"Besicovitch.SatelliteConfig.centerAndRescale_radius","module":"Mathlib.MeasureTheory.Covering.BesicovitchVectorSpace","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nN : Nat\nτ : Real\na : Besicovitch.SatelliteConfig E N τ\n⊢ Eq (a.centerAndRescale.r (Fin.last N)) 1","decl":"theorem centerAndRescale_radius {N : ℕ} {τ : ℝ} (a : SatelliteConfig E N τ) :\n    a.centerAndRescale.r (last N) = 1 := by\n  simp [SatelliteConfig.centerAndRescale, inv_mul_cancel₀ (a.rpos _).ne']\n\n"}
{"name":"Besicovitch.card_le_of_separated","module":"Mathlib.MeasureTheory.Covering.BesicovitchVectorSpace","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : FiniteDimensional Real E\ns : Finset E\nhs : ∀ (c : E), Membership.mem s c → LE.le (Norm.norm c) 2\nh : ∀ (c : E), Membership.mem s c → ∀ (d : E), Membership.mem s d → Ne c d → LE.le 1 (Norm.norm (HSub.hSub c d))\n⊢ LE.le s.card (HPow.hPow 5 (Module.finrank Real E))","decl":"open scoped Function in -- required for scoped `on` notation\n/-- Any `1`-separated set in the ball of radius `2` has cardinality at most `5 ^ dim`. This is\nuseful to show that the supremum in the definition of `Besicovitch.multiplicity E` is\nwell behaved. -/\ntheorem card_le_of_separated (s : Finset E) (hs : ∀ c ∈ s, ‖c‖ ≤ 2)\n    (h : ∀ c ∈ s, ∀ d ∈ s, c ≠ d → 1 ≤ ‖c - d‖) : s.card ≤ 5 ^ finrank ℝ E := by\n  /- We consider balls of radius `1/2` around the points in `s`. They are disjoint, and all\n    contained in the ball of radius `5/2`. A volume argument gives `s.card * (1/2)^dim ≤ (5/2)^dim`,\n    i.e., `s.card ≤ 5^dim`. -/\n  borelize E\n  let μ : Measure E := Measure.addHaar\n  let δ : ℝ := (1 : ℝ) / 2\n  let ρ : ℝ := (5 : ℝ) / 2\n  have ρpos : 0 < ρ := by norm_num\n  set A := ⋃ c ∈ s, ball (c : E) δ with hA\n  have D : Set.Pairwise (s : Set E) (Disjoint on fun c => ball (c : E) δ) := by\n    rintro c hc d hd hcd\n    apply ball_disjoint_ball\n    rw [dist_eq_norm]\n    convert h c hc d hd hcd\n    norm_num\n  have A_subset : A ⊆ ball (0 : E) ρ := by\n    refine iUnion₂_subset fun x hx => ?_\n    apply ball_subset_ball'\n    calc\n      δ + dist x 0 ≤ δ + 2 := by rw [dist_zero_right]; exact add_le_add le_rfl (hs x hx)\n      _ = 5 / 2 := by norm_num\n  have I :\n    (s.card : ℝ≥0∞) * ENNReal.ofReal (δ ^ finrank ℝ E) * μ (ball 0 1) ≤\n      ENNReal.ofReal (ρ ^ finrank ℝ E) * μ (ball 0 1) :=\n    calc\n      (s.card : ℝ≥0∞) * ENNReal.ofReal (δ ^ finrank ℝ E) * μ (ball 0 1) = μ A := by\n        rw [hA, measure_biUnion_finset D fun c _ => measurableSet_ball]\n        have I : 0 < δ := by norm_num\n        simp only [div_pow, μ.addHaar_ball_of_pos _ I]\n        simp only [one_div, one_pow, Finset.sum_const, nsmul_eq_mul, mul_assoc]\n      _ ≤ μ (ball (0 : E) ρ) := measure_mono A_subset\n      _ = ENNReal.ofReal (ρ ^ finrank ℝ E) * μ (ball 0 1) := by\n        simp only [μ.addHaar_ball_of_pos _ ρpos]\n  have J : (s.card : ℝ≥0∞) * ENNReal.ofReal (δ ^ finrank ℝ E) ≤ ENNReal.ofReal (ρ ^ finrank ℝ E) :=\n    (ENNReal.mul_le_mul_right (measure_ball_pos _ _ zero_lt_one).ne' measure_ball_lt_top.ne).1 I\n  have K : (s.card : ℝ) ≤ (5 : ℝ) ^ finrank ℝ E := by\n    have := ENNReal.toReal_le_of_le_ofReal (pow_nonneg ρpos.le _) J\n    simpa [ρ, δ, div_eq_mul_inv, mul_pow] using this\n  exact mod_cast K\n\n"}
{"name":"Besicovitch.multiplicity_le","module":"Mathlib.MeasureTheory.Covering.BesicovitchVectorSpace","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : FiniteDimensional Real E\n⊢ LE.le (Besicovitch.multiplicity E) (HPow.hPow 5 (Module.finrank Real E))","decl":"theorem multiplicity_le : multiplicity E ≤ 5 ^ finrank ℝ E := by\n  apply csSup_le\n  · refine ⟨0, ⟨∅, by simp⟩⟩\n  · rintro _ ⟨s, ⟨rfl, h⟩⟩\n    exact Besicovitch.card_le_of_separated s h.1 h.2\n\n"}
{"name":"Besicovitch.card_le_multiplicity","module":"Mathlib.MeasureTheory.Covering.BesicovitchVectorSpace","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : FiniteDimensional Real E\ns : Finset E\nhs : ∀ (c : E), Membership.mem s c → LE.le (Norm.norm c) 2\nh's : ∀ (c : E), Membership.mem s c → ∀ (d : E), Membership.mem s d → Ne c d → LE.le 1 (Norm.norm (HSub.hSub c d))\n⊢ LE.le s.card (Besicovitch.multiplicity E)","decl":"theorem card_le_multiplicity {s : Finset E} (hs : ∀ c ∈ s, ‖c‖ ≤ 2)\n    (h's : ∀ c ∈ s, ∀ d ∈ s, c ≠ d → 1 ≤ ‖c - d‖) : s.card ≤ multiplicity E := by\n  apply le_csSup\n  · refine ⟨5 ^ finrank ℝ E, ?_⟩\n    rintro _ ⟨s, ⟨rfl, h⟩⟩\n    exact Besicovitch.card_le_of_separated s h.1 h.2\n  · simp only [mem_setOf_eq, Ne]\n    exact ⟨s, rfl, hs, h's⟩\n\n"}
{"name":"Besicovitch.exists_goodδ","module":"Mathlib.MeasureTheory.Covering.BesicovitchVectorSpace","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : FiniteDimensional Real E\n⊢ Exists fun δ => And (LT.lt 0 δ) (And (LT.lt δ 1) (∀ (s : Finset E), (∀ (c : E), Membership.mem s c → LE.le (Norm.norm c) 2) → (∀ (c : E), Membership.mem s c → ∀ (d : E), Membership.mem s d → Ne c d → LE.le (HSub.hSub 1 δ) (Norm.norm (HSub.hSub c d))) → LE.le s.card (Besicovitch.multiplicity E)))","decl":"/-- If `δ` is small enough, a `(1-δ)`-separated set in the ball of radius `2` also has cardinality\nat most `multiplicity E`. -/\ntheorem exists_goodδ :\n    ∃ δ : ℝ, 0 < δ ∧ δ < 1 ∧ ∀ s : Finset E, (∀ c ∈ s, ‖c‖ ≤ 2) →\n      (∀ c ∈ s, ∀ d ∈ s, c ≠ d → 1 - δ ≤ ‖c - d‖) → s.card ≤ multiplicity E := by\n  classical\n  /- This follows from a compactness argument: otherwise, one could extract a converging\n    subsequence, to obtain a `1`-separated set in the ball of radius `2` with cardinality\n    `N = multiplicity E + 1`. To formalize this, we work with functions `Fin N → E`.\n     -/\n  by_contra! h\n  set N := multiplicity E + 1 with hN\n  have :\n    ∀ δ : ℝ, 0 < δ → ∃ f : Fin N → E, (∀ i : Fin N, ‖f i‖ ≤ 2) ∧\n      Pairwise fun i j => 1 - δ ≤ ‖f i - f j‖ := by\n    intro δ hδ\n    rcases lt_or_le δ 1 with (hδ' | hδ')\n    · rcases h δ hδ hδ' with ⟨s, hs, h's, s_card⟩\n      obtain ⟨f, f_inj, hfs⟩ : ∃ f : Fin N → E, Function.Injective f ∧ range f ⊆ ↑s := by\n        have : Fintype.card (Fin N) ≤ s.card := by simp only [Fintype.card_fin]; exact s_card\n        rcases Function.Embedding.exists_of_card_le_finset this with ⟨f, hf⟩\n        exact ⟨f, f.injective, hf⟩\n      simp only [range_subset_iff, Finset.mem_coe] at hfs\n      exact ⟨f, fun i => hs _ (hfs i), fun i j hij => h's _ (hfs i) _ (hfs j) (f_inj.ne hij)⟩\n    · exact\n        ⟨fun _ => 0, by simp, fun i j _ => by\n          simpa only [norm_zero, sub_nonpos, sub_self]⟩\n  -- For `δ > 0`, `F δ` is a function from `Fin N` to the ball of radius `2` for which two points\n  -- in the image are separated by `1 - δ`.\n  choose! F hF using this\n  -- Choose a converging subsequence when `δ → 0`.\n  have : ∃ f : Fin N → E, (∀ i : Fin N, ‖f i‖ ≤ 2) ∧ Pairwise fun i j => 1 ≤ ‖f i - f j‖ := by\n    obtain ⟨u, _, zero_lt_u, hu⟩ :\n      ∃ u : ℕ → ℝ,\n        (∀ m n : ℕ, m < n → u n < u m) ∧ (∀ n : ℕ, 0 < u n) ∧ Filter.Tendsto u Filter.atTop (𝓝 0) :=\n      exists_seq_strictAnti_tendsto (0 : ℝ)\n    have A : ∀ n, F (u n) ∈ closedBall (0 : Fin N → E) 2 := by\n      intro n\n      simp only [pi_norm_le_iff_of_nonneg zero_le_two, mem_closedBall, dist_zero_right,\n        (hF (u n) (zero_lt_u n)).left, forall_const]\n    obtain ⟨f, fmem, φ, φ_mono, hf⟩ :\n      ∃ f ∈ closedBall (0 : Fin N → E) 2,\n        ∃ φ : ℕ → ℕ, StrictMono φ ∧ Tendsto ((F ∘ u) ∘ φ) atTop (𝓝 f) :=\n      IsCompact.tendsto_subseq (isCompact_closedBall _ _) A\n    refine ⟨f, fun i => ?_, fun i j hij => ?_⟩\n    · simp only [pi_norm_le_iff_of_nonneg zero_le_two, mem_closedBall, dist_zero_right] at fmem\n      exact fmem i\n    · have A : Tendsto (fun n => ‖F (u (φ n)) i - F (u (φ n)) j‖) atTop (𝓝 ‖f i - f j‖) :=\n        ((hf.apply_nhds i).sub (hf.apply_nhds j)).norm\n      have B : Tendsto (fun n => 1 - u (φ n)) atTop (𝓝 (1 - 0)) :=\n        tendsto_const_nhds.sub (hu.comp φ_mono.tendsto_atTop)\n      rw [sub_zero] at B\n      exact le_of_tendsto_of_tendsto' B A fun n => (hF (u (φ n)) (zero_lt_u _)).2 hij\n  rcases this with ⟨f, hf, h'f⟩\n  -- the range of `f` contradicts the definition of `multiplicity E`.\n  have finj : Function.Injective f := by\n    intro i j hij\n    by_contra h\n    have : 1 ≤ ‖f i - f j‖ := h'f h\n    simp only [hij, norm_zero, sub_self] at this\n    exact lt_irrefl _ (this.trans_lt zero_lt_one)\n  let s := Finset.image f Finset.univ\n  have s_card : s.card = N := by rw [Finset.card_image_of_injective _ finj]; exact Finset.card_fin N\n  have hs : ∀ c ∈ s, ‖c‖ ≤ 2 := by\n    simp only [s, hf, forall_apply_eq_imp_iff, forall_const, forall_exists_index, Finset.mem_univ,\n      Finset.mem_image, true_and]\n  have h's : ∀ c ∈ s, ∀ d ∈ s, c ≠ d → 1 ≤ ‖c - d‖ := by\n    simp only [s, forall_apply_eq_imp_iff, forall_exists_index, Finset.mem_univ, Finset.mem_image,\n      Ne, exists_true_left, forall_apply_eq_imp_iff, forall_true_left, true_and]\n    intro i j hij\n    have : i ≠ j := fun h => by rw [h] at hij; exact hij rfl\n    exact h'f this\n  have : s.card ≤ multiplicity E := card_le_multiplicity hs h's\n  rw [s_card, hN] at this\n  exact lt_irrefl _ ((Nat.lt_succ_self (multiplicity E)).trans_le this)\n\n"}
{"name":"Besicovitch.goodδ_lt_one","module":"Mathlib.MeasureTheory.Covering.BesicovitchVectorSpace","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : FiniteDimensional Real E\n⊢ LT.lt (Besicovitch.goodδ E) 1","decl":"theorem goodδ_lt_one : goodδ E < 1 :=\n  (exists_goodδ E).choose_spec.2.1\n\n"}
{"name":"Besicovitch.one_lt_goodτ","module":"Mathlib.MeasureTheory.Covering.BesicovitchVectorSpace","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : FiniteDimensional Real E\n⊢ LT.lt 1 (Besicovitch.goodτ E)","decl":"theorem one_lt_goodτ : 1 < goodτ E := by\n  dsimp [goodτ, goodδ]; linarith [(exists_goodδ E).choose_spec.1]\n\n"}
{"name":"Besicovitch.card_le_multiplicity_of_δ","module":"Mathlib.MeasureTheory.Covering.BesicovitchVectorSpace","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : FiniteDimensional Real E\ns : Finset E\nhs : ∀ (c : E), Membership.mem s c → LE.le (Norm.norm c) 2\nh's : ∀ (c : E), Membership.mem s c → ∀ (d : E), Membership.mem s d → Ne c d → LE.le (HSub.hSub 1 (Besicovitch.goodδ E)) (Norm.norm (HSub.hSub c d))\n⊢ LE.le s.card (Besicovitch.multiplicity E)","decl":"theorem card_le_multiplicity_of_δ {s : Finset E} (hs : ∀ c ∈ s, ‖c‖ ≤ 2)\n    (h's : ∀ c ∈ s, ∀ d ∈ s, c ≠ d → 1 - goodδ E ≤ ‖c - d‖) : s.card ≤ multiplicity E :=\n  (Classical.choose_spec (exists_goodδ E)).2.2 s hs h's\n\n"}
{"name":"Besicovitch.le_multiplicity_of_δ_of_fin","module":"Mathlib.MeasureTheory.Covering.BesicovitchVectorSpace","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : FiniteDimensional Real E\nn : Nat\nf : Fin n → E\nh : ∀ (i : Fin n), LE.le (Norm.norm (f i)) 2\nh' : Pairwise fun i j => LE.le (HSub.hSub 1 (Besicovitch.goodδ E)) (Norm.norm (HSub.hSub (f i) (f j)))\n⊢ LE.le n (Besicovitch.multiplicity E)","decl":"theorem le_multiplicity_of_δ_of_fin {n : ℕ} (f : Fin n → E) (h : ∀ i, ‖f i‖ ≤ 2)\n    (h' : Pairwise fun i j => 1 - goodδ E ≤ ‖f i - f j‖) : n ≤ multiplicity E := by\n  classical\n  have finj : Function.Injective f := by\n    intro i j hij\n    by_contra h\n    have : 1 - goodδ E ≤ ‖f i - f j‖ := h' h\n    simp only [hij, norm_zero, sub_self] at this\n    linarith [goodδ_lt_one E]\n  let s := Finset.image f Finset.univ\n  have s_card : s.card = n := by rw [Finset.card_image_of_injective _ finj]; exact Finset.card_fin n\n  have hs : ∀ c ∈ s, ‖c‖ ≤ 2 := by\n    simp only [s, h, forall_apply_eq_imp_iff, forall_const, forall_exists_index, Finset.mem_univ,\n      Finset.mem_image, imp_true_iff, true_and]\n  have h's : ∀ c ∈ s, ∀ d ∈ s, c ≠ d → 1 - goodδ E ≤ ‖c - d‖ := by\n    simp only [s, forall_apply_eq_imp_iff, forall_exists_index, Finset.mem_univ, Finset.mem_image,\n      Ne, exists_true_left, forall_apply_eq_imp_iff, forall_true_left, true_and]\n    intro i j hij\n    have : i ≠ j := fun h => by rw [h] at hij; exact hij rfl\n    exact h' this\n  have : s.card ≤ multiplicity E := card_le_multiplicity_of_δ hs h's\n  rwa [s_card] at this\n\n"}
{"name":"Besicovitch.SatelliteConfig.exists_normalized_aux1","module":"Mathlib.MeasureTheory.Covering.BesicovitchVectorSpace","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\nN : Nat\nτ : Real\na : Besicovitch.SatelliteConfig E N τ\nlastr : Eq (a.r (Fin.last N)) 1\nhτ : LE.le 1 τ\nδ : Real\nhδ1 : LE.le τ (HAdd.hAdd 1 (HDiv.hDiv δ 4))\nhδ2 : LE.le δ 1\ni j : Fin N.succ\ninej : Ne i j\n⊢ LE.le (HSub.hSub 1 δ) (Norm.norm (HSub.hSub (a.c i) (a.c j)))","decl":"theorem exists_normalized_aux1 {N : ℕ} {τ : ℝ} (a : SatelliteConfig E N τ)\n    (lastr : a.r (last N) = 1) (hτ : 1 ≤ τ) (δ : ℝ) (hδ1 : τ ≤ 1 + δ / 4) (hδ2 : δ ≤ 1)\n    (i j : Fin N.succ) (inej : i ≠ j) : 1 - δ ≤ ‖a.c i - a.c j‖ := by\n  have ah :\n      Pairwise fun i j => a.r i ≤ ‖a.c i - a.c j‖ ∧ a.r j ≤ τ * a.r i ∨\n        a.r j ≤ ‖a.c j - a.c i‖ ∧ a.r i ≤ τ * a.r j := by\n    simpa only [dist_eq_norm] using a.h\n  have δnonneg : 0 ≤ δ := by linarith only [hτ, hδ1]\n  have D : 0 ≤ 1 - δ / 4 := by linarith only [hδ2]\n  have τpos : 0 < τ := _root_.zero_lt_one.trans_le hτ\n  have I : (1 - δ / 4) * τ ≤ 1 :=\n    calc\n      (1 - δ / 4) * τ ≤ (1 - δ / 4) * (1 + δ / 4) := by gcongr\n      _ = (1 : ℝ) - δ ^ 2 / 16 := by ring\n      _ ≤ 1 := by linarith only [sq_nonneg δ]\n  have J : 1 - δ ≤ 1 - δ / 4 := by linarith only [δnonneg]\n  have K : 1 - δ / 4 ≤ τ⁻¹ := by rw [inv_eq_one_div, le_div_iff₀ τpos]; exact I\n  suffices L : τ⁻¹ ≤ ‖a.c i - a.c j‖ by linarith only [J, K, L]\n  have hτ' : ∀ k, τ⁻¹ ≤ a.r k := by\n    intro k\n    rw [inv_eq_one_div, div_le_iff₀ τpos, ← lastr, mul_comm]\n    exact a.hlast' k hτ\n  rcases ah inej with (H | H)\n  · apply le_trans _ H.1\n    exact hτ' i\n  · rw [norm_sub_rev]\n    apply le_trans _ H.1\n    exact hτ' j\n\n"}
{"name":"Besicovitch.SatelliteConfig.exists_normalized_aux2","module":"Mathlib.MeasureTheory.Covering.BesicovitchVectorSpace","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nN : Nat\nτ : Real\na : Besicovitch.SatelliteConfig E N τ\nlastc : Eq (a.c (Fin.last N)) 0\nlastr : Eq (a.r (Fin.last N)) 1\nhτ : LE.le 1 τ\nδ : Real\nhδ1 : LE.le τ (HAdd.hAdd 1 (HDiv.hDiv δ 4))\nhδ2 : LE.le δ 1\ni j : Fin N.succ\ninej : Ne i j\nhi : LE.le (Norm.norm (a.c i)) 2\nhj : LT.lt 2 (Norm.norm (a.c j))\n⊢ LE.le (HSub.hSub 1 δ) (Norm.norm (HSub.hSub (a.c i) (HSMul.hSMul (HDiv.hDiv 2 (Norm.norm (a.c j))) (a.c j))))","decl":"theorem exists_normalized_aux2 {N : ℕ} {τ : ℝ} (a : SatelliteConfig E N τ)\n    (lastc : a.c (last N) = 0) (lastr : a.r (last N) = 1) (hτ : 1 ≤ τ) (δ : ℝ) (hδ1 : τ ≤ 1 + δ / 4)\n    (hδ2 : δ ≤ 1) (i j : Fin N.succ) (inej : i ≠ j) (hi : ‖a.c i‖ ≤ 2) (hj : 2 < ‖a.c j‖) :\n    1 - δ ≤ ‖a.c i - (2 / ‖a.c j‖) • a.c j‖ := by\n  have ah :\n      Pairwise fun i j => a.r i ≤ ‖a.c i - a.c j‖ ∧ a.r j ≤ τ * a.r i ∨\n        a.r j ≤ ‖a.c j - a.c i‖ ∧ a.r i ≤ τ * a.r j := by\n    simpa only [dist_eq_norm] using a.h\n  have δnonneg : 0 ≤ δ := by linarith only [hτ, hδ1]\n  have D : 0 ≤ 1 - δ / 4 := by linarith only [hδ2]\n  have hcrj : ‖a.c j‖ ≤ a.r j + 1 := by simpa only [lastc, lastr, dist_zero_right] using a.inter' j\n  have I : a.r i ≤ 2 := by\n    rcases lt_or_le i (last N) with (H | H)\n    · apply (a.hlast i H).1.trans\n      simpa only [dist_eq_norm, lastc, sub_zero] using hi\n    · have : i = last N := top_le_iff.1 H\n      rw [this, lastr]\n      exact one_le_two\n  have J : (1 - δ / 4) * τ ≤ 1 :=\n    calc\n      (1 - δ / 4) * τ ≤ (1 - δ / 4) * (1 + δ / 4) := by gcongr\n      _ = (1 : ℝ) - δ ^ 2 / 16 := by ring\n      _ ≤ 1 := by linarith only [sq_nonneg δ]\n  have A : a.r j - δ ≤ ‖a.c i - a.c j‖ := by\n    rcases ah inej.symm with (H | H); · rw [norm_sub_rev]; linarith [H.1]\n    have C : a.r j ≤ 4 :=\n      calc\n        a.r j ≤ τ * a.r i := H.2\n        _ ≤ τ * 2 := by gcongr\n        _ ≤ 5 / 4 * 2 := by gcongr; linarith only [hδ1, hδ2]\n        _ ≤ 4 := by norm_num\n    calc\n      a.r j - δ ≤ a.r j - a.r j / 4 * δ := by\n        gcongr _ - ?_\n        exact mul_le_of_le_one_left δnonneg (by linarith only [C])\n      _ = (1 - δ / 4) * a.r j := by ring\n      _ ≤ (1 - δ / 4) * (τ * a.r i) := mul_le_mul_of_nonneg_left H.2 D\n      _ ≤ 1 * a.r i := by rw [← mul_assoc]; gcongr\n      _ ≤ ‖a.c i - a.c j‖ := by rw [one_mul]; exact H.1\n  set d := (2 / ‖a.c j‖) • a.c j with hd\n  have : a.r j - δ ≤ ‖a.c i - d‖ + (a.r j - 1) :=\n    calc\n      a.r j - δ ≤ ‖a.c i - a.c j‖ := A\n      _ ≤ ‖a.c i - d‖ + ‖d - a.c j‖ := by simp only [← dist_eq_norm, dist_triangle]\n      _ ≤ ‖a.c i - d‖ + (a.r j - 1) := by\n        apply add_le_add_left\n        have A : 0 ≤ 1 - 2 / ‖a.c j‖ := by simpa [div_le_iff₀ (zero_le_two.trans_lt hj)] using hj.le\n        rw [← one_smul ℝ (a.c j), hd, ← sub_smul, norm_smul, norm_sub_rev, Real.norm_eq_abs,\n          abs_of_nonneg A, sub_mul]\n        field_simp [(zero_le_two.trans_lt hj).ne']\n        linarith only [hcrj]\n  linarith only [this]\n\n"}
{"name":"Besicovitch.SatelliteConfig.exists_normalized_aux3","module":"Mathlib.MeasureTheory.Covering.BesicovitchVectorSpace","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nN : Nat\nτ : Real\na : Besicovitch.SatelliteConfig E N τ\nlastc : Eq (a.c (Fin.last N)) 0\nlastr : Eq (a.r (Fin.last N)) 1\nhτ : LE.le 1 τ\nδ : Real\nhδ1 : LE.le τ (HAdd.hAdd 1 (HDiv.hDiv δ 4))\ni j : Fin N.succ\ninej : Ne i j\nhi : LT.lt 2 (Norm.norm (a.c i))\nhij : LE.le (Norm.norm (a.c i)) (Norm.norm (a.c j))\n⊢ LE.le (HSub.hSub 1 δ) (Norm.norm (HSub.hSub (HSMul.hSMul (HDiv.hDiv 2 (Norm.norm (a.c i))) (a.c i)) (HSMul.hSMul (HDiv.hDiv 2 (Norm.norm (a.c j))) (a.c j))))","decl":"theorem exists_normalized_aux3 {N : ℕ} {τ : ℝ} (a : SatelliteConfig E N τ)\n    (lastc : a.c (last N) = 0) (lastr : a.r (last N) = 1) (hτ : 1 ≤ τ) (δ : ℝ) (hδ1 : τ ≤ 1 + δ / 4)\n    (i j : Fin N.succ) (inej : i ≠ j) (hi : 2 < ‖a.c i‖) (hij : ‖a.c i‖ ≤ ‖a.c j‖) :\n    1 - δ ≤ ‖(2 / ‖a.c i‖) • a.c i - (2 / ‖a.c j‖) • a.c j‖ := by\n  have ah :\n      Pairwise fun i j => a.r i ≤ ‖a.c i - a.c j‖ ∧ a.r j ≤ τ * a.r i ∨\n        a.r j ≤ ‖a.c j - a.c i‖ ∧ a.r i ≤ τ * a.r j := by\n    simpa only [dist_eq_norm] using a.h\n  have δnonneg : 0 ≤ δ := by linarith only [hτ, hδ1]\n  have hcrj : ‖a.c j‖ ≤ a.r j + 1 := by simpa only [lastc, lastr, dist_zero_right] using a.inter' j\n  have A : a.r i ≤ ‖a.c i‖ := by\n    have : i < last N := by\n      apply lt_top_iff_ne_top.2\n      intro iN\n      change i = last N at iN\n      rw [iN, lastc, norm_zero] at hi\n      exact lt_irrefl _ (zero_le_two.trans_lt hi)\n    convert (a.hlast i this).1 using 1\n    rw [dist_eq_norm, lastc, sub_zero]\n  have hj : 2 < ‖a.c j‖ := hi.trans_le hij\n  set s := ‖a.c i‖\n  have spos : 0 < s := zero_lt_two.trans hi\n  set d := (s / ‖a.c j‖) • a.c j with hd\n  have I : ‖a.c j - a.c i‖ ≤ ‖a.c j‖ - s + ‖d - a.c i‖ :=\n    calc\n      ‖a.c j - a.c i‖ ≤ ‖a.c j - d‖ + ‖d - a.c i‖ := by simp [← dist_eq_norm, dist_triangle]\n      _ = ‖a.c j‖ - ‖a.c i‖ + ‖d - a.c i‖ := by\n        nth_rw 1 [← one_smul ℝ (a.c j)]\n        rw [add_left_inj, hd, ← sub_smul, norm_smul, Real.norm_eq_abs, abs_of_nonneg, sub_mul,\n          one_mul, div_mul_cancel₀ _ (zero_le_two.trans_lt hj).ne']\n        rwa [sub_nonneg, div_le_iff₀ (zero_lt_two.trans hj), one_mul]\n  have J : a.r j - ‖a.c j - a.c i‖ ≤ s / 2 * δ :=\n    calc\n      a.r j - ‖a.c j - a.c i‖ ≤ s * (τ - 1) := by\n        rcases ah inej.symm with (H | H)\n        · calc\n            a.r j - ‖a.c j - a.c i‖ ≤ 0 := sub_nonpos.2 H.1\n            _ ≤ s * (τ - 1) := mul_nonneg spos.le (sub_nonneg.2 hτ)\n        · rw [norm_sub_rev] at H\n          calc\n            a.r j - ‖a.c j - a.c i‖ ≤ τ * a.r i - a.r i := sub_le_sub H.2 H.1\n            _ = a.r i * (τ - 1) := by ring\n            _ ≤ s * (τ - 1) := mul_le_mul_of_nonneg_right A (sub_nonneg.2 hτ)\n      _ ≤ s * (δ / 2) := (mul_le_mul_of_nonneg_left (by linarith only [δnonneg, hδ1]) spos.le)\n      _ = s / 2 * δ := by ring\n  have invs_nonneg : 0 ≤ 2 / s := div_nonneg zero_le_two (zero_le_two.trans hi.le)\n  calc\n    1 - δ = 2 / s * (s / 2 - s / 2 * δ) := by field_simp [spos.ne']; ring\n    _ ≤ 2 / s * ‖d - a.c i‖ :=\n      (mul_le_mul_of_nonneg_left (by linarith only [hcrj, I, J, hi]) invs_nonneg)\n    _ = ‖(2 / s) • a.c i - (2 / ‖a.c j‖) • a.c j‖ := by\n      conv_lhs => rw [norm_sub_rev, ← abs_of_nonneg invs_nonneg]\n      rw [← Real.norm_eq_abs, ← norm_smul, smul_sub, hd, smul_smul]\n      congr 3\n      field_simp [spos.ne']\n\n"}
{"name":"Besicovitch.SatelliteConfig.exists_normalized","module":"Mathlib.MeasureTheory.Covering.BesicovitchVectorSpace","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nN : Nat\nτ : Real\na : Besicovitch.SatelliteConfig E N τ\nlastc : Eq (a.c (Fin.last N)) 0\nlastr : Eq (a.r (Fin.last N)) 1\nhτ : LE.le 1 τ\nδ : Real\nhδ1 : LE.le τ (HAdd.hAdd 1 (HDiv.hDiv δ 4))\nhδ2 : LE.le δ 1\n⊢ Exists fun c' => And (∀ (n : Fin N.succ), LE.le (Norm.norm (c' n)) 2) (Pairwise fun i j => LE.le (HSub.hSub 1 δ) (Norm.norm (HSub.hSub (c' i) (c' j))))","decl":"theorem exists_normalized {N : ℕ} {τ : ℝ} (a : SatelliteConfig E N τ) (lastc : a.c (last N) = 0)\n    (lastr : a.r (last N) = 1) (hτ : 1 ≤ τ) (δ : ℝ) (hδ1 : τ ≤ 1 + δ / 4) (hδ2 : δ ≤ 1) :\n    ∃ c' : Fin N.succ → E, (∀ n, ‖c' n‖ ≤ 2) ∧ Pairwise fun i j => 1 - δ ≤ ‖c' i - c' j‖ := by\n  let c' : Fin N.succ → E := fun i => if ‖a.c i‖ ≤ 2 then a.c i else (2 / ‖a.c i‖) • a.c i\n  have norm_c'_le : ∀ i, ‖c' i‖ ≤ 2 := by\n    intro i\n    simp only [c']\n    split_ifs with h; · exact h\n    by_cases hi : ‖a.c i‖ = 0 <;> field_simp [norm_smul, hi]\n  refine ⟨c', fun n => norm_c'_le n, fun i j inej => ?_⟩\n  -- up to exchanging `i` and `j`, one can assume `‖c i‖ ≤ ‖c j‖`.\n  wlog hij : ‖a.c i‖ ≤ ‖a.c j‖ generalizing i j\n  · rw [norm_sub_rev]; exact this j i inej.symm (le_of_not_le hij)\n  rcases le_or_lt ‖a.c j‖ 2 with (Hj | Hj)\n  -- case `‖c j‖ ≤ 2` (and therefore also `‖c i‖ ≤ 2`)\n  · simp_rw [c', Hj, hij.trans Hj, if_true]\n    exact exists_normalized_aux1 a lastr hτ δ hδ1 hδ2 i j inej\n  -- case `2 < ‖c j‖`\n  · have H'j : ‖a.c j‖ ≤ 2 ↔ False := by simpa only [not_le, iff_false] using Hj\n    rcases le_or_lt ‖a.c i‖ 2 with (Hi | Hi)\n    · -- case `‖c i‖ ≤ 2`\n      simp_rw [c', Hi, if_true, H'j, if_false]\n      exact exists_normalized_aux2 a lastc lastr hτ δ hδ1 hδ2 i j inej Hi Hj\n    · -- case `2 < ‖c i‖`\n      have H'i : ‖a.c i‖ ≤ 2 ↔ False := by simpa only [not_le, iff_false] using Hi\n      simp_rw [c', H'i, if_false, H'j, if_false]\n      exact exists_normalized_aux3 a lastc lastr hτ δ hδ1 i j inej Hi hij\n\n"}
{"name":"Besicovitch.isEmpty_satelliteConfig_multiplicity","module":"Mathlib.MeasureTheory.Covering.BesicovitchVectorSpace","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : FiniteDimensional Real E\n⊢ IsEmpty (Besicovitch.SatelliteConfig E (Besicovitch.multiplicity E) (Besicovitch.goodτ E))","decl":"/-- In a normed vector space `E`, there can be no satellite configuration with `multiplicity E + 1`\npoints and the parameter `goodτ E`. This will ensure that in the inductive construction to get\nthe Besicovitch covering families, there will never be more than `multiplicity E` nonempty\nfamilies. -/\ntheorem isEmpty_satelliteConfig_multiplicity :\n    IsEmpty (SatelliteConfig E (multiplicity E) (goodτ E)) :=\n  ⟨by\n    intro a\n    let b := a.centerAndRescale\n    rcases b.exists_normalized a.centerAndRescale_center a.centerAndRescale_radius\n        (one_lt_goodτ E).le (goodδ E) le_rfl (goodδ_lt_one E).le with\n      ⟨c', c'_le_two, hc'⟩\n    exact\n      lt_irrefl _ ((Nat.lt_succ_self _).trans_le (le_multiplicity_of_δ_of_fin c' c'_le_two hc'))⟩\n\n"}
{"name":"Besicovitch.instHasBesicovitchCovering","module":"Mathlib.MeasureTheory.Covering.BesicovitchVectorSpace","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : FiniteDimensional Real E\n⊢ HasBesicovitchCovering E","decl":"instance (priority := 100) instHasBesicovitchCovering : HasBesicovitchCovering E :=\n  ⟨⟨multiplicity E, goodτ E, one_lt_goodτ E, isEmpty_satelliteConfig_multiplicity E⟩⟩\n\n"}
