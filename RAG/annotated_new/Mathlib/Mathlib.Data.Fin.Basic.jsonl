{"name":"Fin.ne_of_vne","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ni j : Fin n\nh : Ne ↑i ↑j\n⊢ Ne i j","decl":"@[deprecated (since := \"2024-08-13\")] alias ne_of_vne := ne_of_val_ne\n"}
{"name":"Fin.vne_of_ne","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ni j : Fin n\nh : Ne i j\n⊢ Ne ↑i ↑j","decl":"@[deprecated (since := \"2024-08-13\")] alias vne_of_ne := val_ne_of_ne\n\n"}
{"name":"Fin.instCanLiftNatValLt","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\n⊢ CanLift Nat (Fin n) Fin.val fun x => LT.lt x n","decl":"instance {n : ℕ} : CanLift ℕ (Fin n) Fin.val (· < n) where\n  prf k hk := ⟨⟨k, hk⟩, rfl⟩\n\n"}
{"name":"Fin.val_injective","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\n⊢ Function.Injective Fin.val","decl":"theorem val_injective : Function.Injective (@Fin.val n) :=\n  @Fin.eq_of_val_eq n\n\n"}
{"name":"Fin.size_positive","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na✝ : Fin n\n⊢ LT.lt 0 n","decl":"/-- If you actually have an element of `Fin n`, then the `n` is always positive -/\nlemma size_positive : Fin n → 0 < n := Fin.pos\n\n"}
{"name":"Fin.size_positive'","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : Nonempty (Fin n)\n⊢ LT.lt 0 n","decl":"lemma size_positive' [Nonempty (Fin n)] : 0 < n :=\n  ‹Nonempty (Fin n)›.elim Fin.pos\n\n"}
{"name":"Fin.prop","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na : Fin n\n⊢ LT.lt (↑a) n","decl":"protected theorem prop (a : Fin n) : a.val < n :=\n  a.2\n\n"}
{"name":"Fin.lt_of_le_of_lt","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b c : Fin n\na✝¹ : LE.le a b\na✝ : LT.lt b c\n⊢ LT.lt a c","decl":"protected lemma lt_of_le_of_lt : a ≤ b → b < c → a < c := Nat.lt_of_le_of_lt\n"}
{"name":"Fin.lt_of_lt_of_le","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b c : Fin n\na✝¹ : LT.lt a b\na✝ : LE.le b c\n⊢ LT.lt a c","decl":"protected lemma lt_of_lt_of_le : a < b → b ≤ c → a < c := Nat.lt_of_lt_of_le\n"}
{"name":"Fin.le_rfl","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na : Fin n\n⊢ LE.le a a","decl":"protected lemma le_rfl : a ≤ a := Nat.le_refl _\n"}
{"name":"Fin.lt_iff_le_and_ne","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin n\n⊢ Iff (LT.lt a b) (And (LE.le a b) (Ne a b))","decl":"protected lemma lt_iff_le_and_ne : a < b ↔ a ≤ b ∧ a ≠ b := by\n  rw [← val_ne_iff]; exact Nat.lt_iff_le_and_ne\n"}
{"name":"Fin.lt_or_lt_of_ne","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin n\nh : Ne a b\n⊢ Or (LT.lt a b) (LT.lt b a)","decl":"protected lemma lt_or_lt_of_ne (h : a ≠ b) : a < b ∨ b < a := Nat.lt_or_lt_of_ne <| val_ne_iff.2 h\n"}
{"name":"Fin.lt_or_le","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin n\n⊢ Or (LT.lt a b) (LE.le b a)","decl":"protected lemma lt_or_le (a b : Fin n) : a < b ∨ b ≤ a := Nat.lt_or_ge _ _\n"}
{"name":"Fin.le_or_lt","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin n\n⊢ Or (LE.le a b) (LT.lt b a)","decl":"protected lemma le_or_lt (a b : Fin n) : a ≤ b ∨ b < a := (b.lt_or_le a).symm\n"}
{"name":"Fin.le_of_eq","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin n\nhab : Eq a b\n⊢ LE.le a b","decl":"protected lemma le_of_eq (hab : a = b) : a ≤ b := Nat.le_of_eq <| congr_arg val hab\n"}
{"name":"Fin.ge_of_eq","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin n\nhab : Eq a b\n⊢ LE.le b a","decl":"protected lemma ge_of_eq (hab : a = b) : b ≤ a := Fin.le_of_eq hab.symm\n"}
{"name":"Fin.eq_or_lt_of_le","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin n\na✝ : LE.le a b\n⊢ Or (Eq a b) (LT.lt a b)","decl":"protected lemma eq_or_lt_of_le : a ≤ b → a = b ∨ a < b := by\n  rw [Fin.ext_iff]; exact Nat.eq_or_lt_of_le\n"}
{"name":"Fin.lt_or_eq_of_le","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin n\na✝ : LE.le a b\n⊢ Or (LT.lt a b) (Eq a b)","decl":"protected lemma lt_or_eq_of_le : a ≤ b → a < b ∨ a = b := by\n  rw [Fin.ext_iff]; exact Nat.lt_or_eq_of_le\n\n"}
{"name":"Fin.lt_last_iff_ne_last","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na : Fin (HAdd.hAdd n 1)\n⊢ Iff (LT.lt a (Fin.last n)) (Ne a (Fin.last n))","decl":"lemma lt_last_iff_ne_last {a : Fin (n + 1)} : a < last n ↔ a ≠ last n := by\n  simp [Fin.lt_iff_le_and_ne, le_last]\n\n"}
{"name":"Fin.ne_zero_of_lt","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin (HAdd.hAdd n 1)\nhab : LT.lt a b\n⊢ Ne b 0","decl":"lemma ne_zero_of_lt {a b : Fin (n + 1)} (hab : a < b) : b ≠ 0 :=\n  Fin.ne_of_gt <| Fin.lt_of_le_of_lt a.zero_le hab\n\n"}
{"name":"Fin.ne_last_of_lt","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin (HAdd.hAdd n 1)\nhab : LT.lt a b\n⊢ Ne a (Fin.last n)","decl":"lemma ne_last_of_lt {a b : Fin (n + 1)} (hab : a < b) : a ≠ last n :=\n  Fin.ne_of_lt <| Fin.lt_of_lt_of_le hab b.le_last\n\n"}
{"name":"Fin.equivSubtype_symm_apply","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na : Subtype fun i => LT.lt i n\n⊢ Eq (Fin.equivSubtype.symm a) ⟨↑a, ⋯⟩","decl":"/-- Equivalence between `Fin n` and `{ i // i < n }`. -/\n@[simps apply symm_apply]\ndef equivSubtype : Fin n ≃ { i // i < n } where\n  toFun a := ⟨a.1, a.2⟩\n  invFun a := ⟨a.1, a.2⟩\n  left_inv := fun ⟨_, _⟩ => rfl\n  right_inv := fun ⟨_, _⟩ => rfl\n\n"}
{"name":"Fin.equivSubtype_apply","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na : Fin n\n⊢ Eq (Fin.equivSubtype a) ⟨↑a, ⋯⟩","decl":"/-- Equivalence between `Fin n` and `{ i // i < n }`. -/\n@[simps apply symm_apply]\ndef equivSubtype : Fin n ≃ { i // i < n } where\n  toFun a := ⟨a.1, a.2⟩\n  invFun a := ⟨a.1, a.2⟩\n  left_inv := fun ⟨_, _⟩ => rfl\n  right_inv := fun ⟨_, _⟩ => rfl\n\n"}
{"name":"Fin.val_eq_val","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin n\n⊢ Iff (Eq ↑a ↑b) (Eq a b)","decl":"theorem val_eq_val (a b : Fin n) : (a : ℕ) = b ↔ a = b :=\n  Fin.ext_iff.symm\n\n"}
{"name":"Fin.ne_iff_vne","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin n\n⊢ Iff (Ne a b) (Ne ↑a ↑b)","decl":"theorem ne_iff_vne (a b : Fin n) : a ≠ b ↔ a.1 ≠ b.1 :=\n  Fin.ext_iff.not\n\n-- Porting note: I'm not sure if this comment still applies.\n-- built-in reduction doesn't always work\n"}
{"name":"Fin.mk_eq_mk","module":"Mathlib.Data.Fin.Basic","initialProofState":"n a : Nat\nh : LT.lt a n\na' : Nat\nh' : LT.lt a' n\n⊢ Iff (Eq ⟨a, h⟩ ⟨a', h'⟩) (Eq a a')","decl":"@[simp, nolint simpNF]\ntheorem mk_eq_mk {a h a' h'} : @mk n a h = @mk n a' h' ↔ a = a' :=\n  Fin.ext_iff\n\n-- syntactic tautologies now\n\n"}
{"name":"Fin.heq_fun_iff","module":"Mathlib.Data.Fin.Basic","initialProofState":"α : Sort u_1\nk l : Nat\nh : Eq k l\nf : Fin k → α\ng : Fin l → α\n⊢ Iff (HEq f g) (∀ (i : Fin k), Eq (f i) (g ⟨↑i, ⋯⟩))","decl":"/-- Assume `k = l`. If two functions defined on `Fin k` and `Fin l` are equal on each element,\nthen they coincide (in the heq sense). -/\nprotected theorem heq_fun_iff {α : Sort*} {k l : ℕ} (h : k = l) {f : Fin k → α} {g : Fin l → α} :\n    HEq f g ↔ ∀ i : Fin k, f i = g ⟨(i : ℕ), h ▸ i.2⟩ := by\n  subst h\n  simp [funext_iff]\n\n"}
{"name":"Fin.heq_fun₂_iff","module":"Mathlib.Data.Fin.Basic","initialProofState":"α : Sort u_1\nk l k' l' : Nat\nh : Eq k l\nh' : Eq k' l'\nf : Fin k → Fin k' → α\ng : Fin l → Fin l' → α\n⊢ Iff (HEq f g) (∀ (i : Fin k) (j : Fin k'), Eq (f i j) (g ⟨↑i, ⋯⟩ ⟨↑j, ⋯⟩))","decl":"/-- Assume `k = l` and `k' = l'`.\nIf two functions `Fin k → Fin k' → α` and `Fin l → Fin l' → α` are equal on each pair,\nthen they coincide (in the heq sense). -/\nprotected theorem heq_fun₂_iff {α : Sort*} {k l k' l' : ℕ} (h : k = l) (h' : k' = l')\n    {f : Fin k → Fin k' → α} {g : Fin l → Fin l' → α} :\n    HEq f g ↔ ∀ (i : Fin k) (j : Fin k'), f i j = g ⟨(i : ℕ), h ▸ i.2⟩ ⟨(j : ℕ), h' ▸ j.2⟩ := by\n  subst h\n  subst h'\n  simp [funext_iff]\n\n"}
{"name":"Fin.heq_ext_iff","module":"Mathlib.Data.Fin.Basic","initialProofState":"k l : Nat\nh : Eq k l\ni : Fin k\nj : Fin l\n⊢ Iff (HEq i j) (Eq ↑i ↑j)","decl":"/-- Two elements of `Fin k` and `Fin l` are heq iff their values in `ℕ` coincide. This requires\n`k = l`. For the left implication without this assumption, see `val_eq_val_of_heq`. -/\nprotected theorem heq_ext_iff {k l : ℕ} (h : k = l) {i : Fin k} {j : Fin l} :\n    HEq i j ↔ (i : ℕ) = (j : ℕ) := by\n  subst h\n  simp [val_eq_val]\n\n"}
{"name":"Fin.le_iff_val_le_val","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin n\n⊢ Iff (LE.le a b) (LE.le ↑a ↑b)","decl":"theorem le_iff_val_le_val {a b : Fin n} : a ≤ b ↔ (a : ℕ) ≤ b :=\n  Iff.rfl\n\n"}
{"name":"Fin.val_fin_lt","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin n\n⊢ Iff (LT.lt ↑a ↑b) (LT.lt a b)","decl":"/-- `a < b` as natural numbers if and only if `a < b` in `Fin n`. -/\n@[norm_cast, simp]\ntheorem val_fin_lt {n : ℕ} {a b : Fin n} : (a : ℕ) < (b : ℕ) ↔ a < b :=\n  Iff.rfl\n\n"}
{"name":"Fin.val_fin_le","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin n\n⊢ Iff (LE.le ↑a ↑b) (LE.le a b)","decl":"/-- `a ≤ b` as natural numbers if and only if `a ≤ b` in `Fin n`. -/\n@[norm_cast, simp]\ntheorem val_fin_le {n : ℕ} {a b : Fin n} : (a : ℕ) ≤ (b : ℕ) ↔ a ≤ b :=\n  Iff.rfl\n\n"}
{"name":"Fin.min_val","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na : Fin n\n⊢ Eq (Min.min (↑a) n) ↑a","decl":"theorem min_val {a : Fin n} : min (a : ℕ) n = a := by simp\n\n"}
{"name":"Fin.max_val","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na : Fin n\n⊢ Eq (Max.max (↑a) n) n","decl":"theorem max_val {a : Fin n} : max (a : ℕ) n = n := by simp\n\n"}
{"name":"Fin.valEmbedding_apply","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\nself : Fin n\n⊢ Eq (Fin.valEmbedding self) ↑self","decl":"/-- The inclusion map `Fin n → ℕ` is an embedding. -/\n@[simps apply]\ndef valEmbedding : Fin n ↪ ℕ :=\n  ⟨val, val_injective⟩\n\n"}
{"name":"Fin.equivSubtype_symm_trans_valEmbedding","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\n⊢ Eq (Fin.equivSubtype.symm.toEmbedding.trans Fin.valEmbedding) (Function.Embedding.subtype fun x => LT.lt x n)","decl":"@[simp]\ntheorem equivSubtype_symm_trans_valEmbedding :\n    equivSubtype.symm.toEmbedding.trans valEmbedding = Embedding.subtype (· < n) :=\n  rfl\n\n"}
{"name":"Fin.val_zero'","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ Eq (↑0) 0","decl":"/--\nThe `Fin.val_zero` in `Lean` only applies in `Fin (n+1)`.\nThis one instead uses a `NeZero n` typeclass hypothesis.\n-/\n@[simp]\ntheorem val_zero' (n : ℕ) [NeZero n] : ((0 : Fin n) : ℕ) = 0 :=\n  rfl\n\n"}
{"name":"Fin.mk_zero'","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ Eq ⟨0, ⋯⟩ 0","decl":"/-- Fin.mk_zero` in `Lean` only applies in `Fin (n + 1)`.\nThis one instead uses a `NeZero n` typeclass hypothesis.\n-/\n@[simp]\ntheorem mk_zero' (n : ℕ) [NeZero n] : (⟨0, pos_of_neZero n⟩ : Fin n) = 0 := rfl\n\n"}
{"name":"Fin.zero_le'","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\na : Fin n\n⊢ LE.le 0 a","decl":"/--\nThe `Fin.zero_le` in `Lean` only applies in `Fin (n+1)`.\nThis one instead uses a `NeZero n` typeclass hypothesis.\n-/\n@[simp]\nprotected theorem zero_le' [NeZero n] (a : Fin n) : 0 ≤ a :=\n  Nat.zero_le a.val\n\n"}
{"name":"Fin.pos_iff_ne_zero'","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\na : Fin n\n⊢ Iff (LT.lt 0 a) (Ne a 0)","decl":"/--\nThe `Fin.pos_iff_ne_zero` in `Lean` only applies in `Fin (n+1)`.\nThis one instead uses a `NeZero n` typeclass hypothesis.\n-/\ntheorem pos_iff_ne_zero' [NeZero n] (a : Fin n) : 0 < a ↔ a ≠ 0 := by\n  rw [← val_fin_lt, val_zero', Nat.pos_iff_ne_zero, Ne, Ne, Fin.ext_iff, val_zero']\n\n"}
{"name":"Fin.cast_eq_self","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na : Fin n\n⊢ Eq (Fin.cast ⋯ a) a","decl":"@[simp] lemma cast_eq_self (a : Fin n) : a.cast rfl = a := rfl\n\n"}
{"name":"Fin.cast_eq_zero","module":"Mathlib.Data.Fin.Basic","initialProofState":"k l : Nat\ninst✝¹ : NeZero k\ninst✝ : NeZero l\nh : Eq k l\nx : Fin k\n⊢ Iff (Eq (Fin.cast h x) 0) (Eq x 0)","decl":"@[simp] theorem cast_eq_zero {k l : ℕ} [NeZero k] [NeZero l]\n    (h : k = l) (x : Fin k) : Fin.cast h x = 0 ↔ x = 0 := by simp [← val_eq_val]\n\n"}
{"name":"Fin.cast_injective","module":"Mathlib.Data.Fin.Basic","initialProofState":"k l : Nat\nh : Eq k l\n⊢ Function.Injective (Fin.cast h)","decl":"lemma cast_injective {k l : ℕ} (h : k = l) : Injective (Fin.cast h) :=\n  fun a b hab ↦ by simpa [← val_eq_val] using hab\n\n"}
{"name":"Fin.last_pos'","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ LT.lt 0 (Fin.last n)","decl":"theorem last_pos' [NeZero n] : 0 < last n := n.pos_of_neZero\n\n"}
{"name":"Fin.one_lt_last","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ LT.lt 1 (Fin.last (HAdd.hAdd n 1))","decl":"theorem one_lt_last [NeZero n] : 1 < last (n + 1) := by\n  rw [lt_iff_val_lt_val, val_one, val_last, Nat.lt_add_left_iff_pos, Nat.pos_iff_ne_zero]\n  exact NeZero.ne n\n\n"}
{"name":"Fin.coe_int_sub_eq_ite","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\nu v : Fin n\n⊢ Eq (↑↑(HSub.hSub u v)) (ite (LE.le v u) (HSub.hSub ↑↑u ↑↑v) (HAdd.hAdd (HSub.hSub ↑↑u ↑↑v) ↑n))","decl":"theorem coe_int_sub_eq_ite {n : Nat} (u v : Fin n) :\n    ((u - v : Fin n) : Int) = if v ≤ u then (u - v : Int) else (u - v : Int) + n := by\n  rw [Fin.sub_def]\n  split\n  · rw [ofNat_emod, Int.emod_eq_sub_self_emod, Int.emod_eq_of_lt] <;> omega\n  · rw [ofNat_emod, Int.emod_eq_of_lt] <;> omega\n\n"}
{"name":"Fin.coe_int_sub_eq_mod","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\nu v : Fin n\n⊢ Eq (↑↑(HSub.hSub u v)) (HMod.hMod (HSub.hSub ↑↑u ↑↑v) ↑n)","decl":"theorem coe_int_sub_eq_mod {n : Nat} (u v : Fin n) :\n    ((u - v : Fin n) : Int) = ((u : Int) - (v : Int)) % n := by\n  rw [coe_int_sub_eq_ite]\n  split\n  · rw [Int.emod_eq_of_lt] <;> omega\n  · rw [Int.emod_eq_add_self_emod, Int.emod_eq_of_lt] <;> omega\n\n"}
{"name":"Fin.coe_int_add_eq_ite","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\nu v : Fin n\n⊢ Eq (↑↑(HAdd.hAdd u v)) (ite (LT.lt (HAdd.hAdd ↑u ↑v) n) (HAdd.hAdd ↑↑u ↑↑v) (HSub.hSub (HAdd.hAdd ↑↑u ↑↑v) ↑n))","decl":"theorem coe_int_add_eq_ite {n : Nat} (u v : Fin n) :\n    ((u + v : Fin n) : Int) = if (u + v : ℕ) < n then (u + v : Int) else (u + v : Int) - n := by\n  rw [Fin.add_def]\n  split\n  · rw [ofNat_emod, Int.emod_eq_of_lt] <;> omega\n  · rw [ofNat_emod, Int.emod_eq_sub_self_emod, Int.emod_eq_of_lt] <;> omega\n\n"}
{"name":"Fin.coe_int_add_eq_mod","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\nu v : Fin n\n⊢ Eq (↑↑(HAdd.hAdd u v)) (HMod.hMod (HAdd.hAdd ↑↑u ↑↑v) ↑n)","decl":"theorem coe_int_add_eq_mod {n : Nat} (u v : Fin n) :\n    ((u + v : Fin n) : Int) = ((u : Int) + (v : Int)) % n := by\n  rw [coe_int_add_eq_ite]\n  split\n  · rw [Int.emod_eq_of_lt] <;> omega\n  · rw [Int.emod_eq_sub_self_emod, Int.emod_eq_of_lt] <;> omega\n\n-- Write `a + b` as `if (a + b : ℕ) < n then (a + b : ℤ) else (a + b : ℤ) - n` and\n-- similarly `a - b` as `if (b : ℕ) ≤ a then (a - b : ℤ) else (a - b : ℤ) + n`.\n"}
{"name":"Fin.val_one'","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ Eq (↑1) (HMod.hMod 1 n)","decl":"@[simp]\ntheorem val_one' (n : ℕ) [NeZero n] : ((1 : Fin n) : ℕ) = 1 % n :=\n  rfl\n\n-- Porting note: Delete this lemma after porting\n"}
{"name":"Fin.val_one''","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\n⊢ Eq (↑1) (HMod.hMod 1 (HAdd.hAdd n 1))","decl":"theorem val_one'' {n : ℕ} : ((1 : Fin (n + 1)) : ℕ) = 1 % (n + 1) :=\n  rfl\n\n"}
{"name":"Fin.nontrivial","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\n⊢ Nontrivial (Fin (HAdd.hAdd n 2))","decl":"instance nontrivial {n : ℕ} : Nontrivial (Fin (n + 2)) where\n  exists_pair_ne := ⟨0, 1, (ne_iff_vne 0 1).mpr (by simp [val_one, val_zero])⟩\n\n"}
{"name":"Fin.nontrivial_iff_two_le","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\n⊢ Iff (Nontrivial (Fin n)) (LE.le 2 n)","decl":"theorem nontrivial_iff_two_le : Nontrivial (Fin n) ↔ 2 ≤ n := by\n  rcases n with (_ | _ | n) <;>\n  simp [Fin.nontrivial, not_nontrivial, Nat.succ_le_iff]\n\n"}
{"name":"Fin.default_eq_zero","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ Eq Inhabited.default 0","decl":"@[simp]\ntheorem default_eq_zero (n : ℕ) [NeZero n] : (default : Fin n) = 0 :=\n  rfl\n\n"}
{"name":"Fin.natCast_def","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\na : Nat\n⊢ Eq ↑a ⟨HMod.hMod a n, ⋯⟩","decl":"lemma natCast_def [NeZero n] (a : ℕ) : (a : Fin n) = ⟨a % n, mod_lt _ n.pos_of_neZero⟩ := rfl\n\n"}
{"name":"Fin.val_add_eq_ite","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin n\n⊢ Eq (↑(HAdd.hAdd a b)) (ite (LE.le n (HAdd.hAdd ↑a ↑b)) (HSub.hSub (HAdd.hAdd ↑a ↑b) n) (HAdd.hAdd ↑a ↑b))","decl":"theorem val_add_eq_ite {n : ℕ} (a b : Fin n) :\n    (↑(a + b) : ℕ) = if n ≤ a + b then a + b - n else a + b := by\n  rw [Fin.val_add, Nat.add_mod_eq_ite, Nat.mod_eq_of_lt (show ↑a < n from a.2),\n    Nat.mod_eq_of_lt (show ↑b < n from b.2)]\n--- Porting note: syntactically the same as the above\n\n"}
{"name":"Fin.val_add_eq_of_add_lt","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin n\nhuv : LT.lt (HAdd.hAdd ↑a ↑b) n\n⊢ Eq (↑(HAdd.hAdd a b)) (HAdd.hAdd ↑a ↑b)","decl":"theorem val_add_eq_of_add_lt {n : ℕ} {a b : Fin n} (huv : a.val + b.val < n) :\n    (a + b).val = a.val + b.val := by\n  rw [val_add]\n  simp [Nat.mod_eq_of_lt huv]\n\n"}
{"name":"Fin.intCast_val_sub_eq_sub_add_ite","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin n\n⊢ Eq (↑↑(HSub.hSub a b)) (HAdd.hAdd (HSub.hSub ↑↑a ↑↑b) ↑(ite (LE.le b a) 0 n))","decl":"lemma intCast_val_sub_eq_sub_add_ite {n : ℕ} (a b : Fin n) :\n    ((a - b).val : ℤ) = a.val - b.val + if b ≤ a then 0 else n := by\n  split <;> fin_omega\n\n"}
{"name":"Fin.ofNat'_eq_cast","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\na : Nat\n⊢ Eq (Fin.ofNat' n a) ↑a","decl":"@[simp]\ntheorem ofNat'_eq_cast (n : ℕ) [NeZero n] (a : ℕ) : Fin.ofNat' n a = a :=\n  rfl\n\n"}
{"name":"Fin.val_natCast","module":"Mathlib.Data.Fin.Basic","initialProofState":"a n : Nat\ninst✝ : NeZero n\n⊢ Eq (↑↑a) (HMod.hMod a n)","decl":"@[simp] lemma val_natCast (a n : ℕ) [NeZero n] : (a : Fin n).val = a % n := rfl\n\n-- Porting note: is this the right name for things involving `Nat.cast`?\n"}
{"name":"Fin.val_cast_of_lt","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\na : Nat\nh : LT.lt a n\n⊢ Eq (↑↑a) a","decl":"/-- Converting an in-range number to `Fin (n + 1)` produces a result\nwhose value is the original number. -/\ntheorem val_cast_of_lt {n : ℕ} [NeZero n] {a : ℕ} (h : a < n) : (a : Fin n).val = a :=\n  Nat.mod_eq_of_lt h\n\n"}
{"name":"Fin.cast_val_eq_self","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\na : Fin n\n⊢ Eq (↑↑a) a","decl":"/-- If `n` is non-zero, converting the value of a `Fin n` to `Fin n` results\nin the same value. -/\n@[simp] theorem cast_val_eq_self {n : ℕ} [NeZero n] (a : Fin n) : (a.val : Fin n) = a :=\n  Fin.ext <| val_cast_of_lt a.isLt\n\n-- Porting note: this is syntactically the same as `val_cast_of_lt`\n\n-- Porting note: this is syntactically the same as `cast_val_of_lt`\n\n-- This is a special case of `CharP.cast_eq_zero` that doesn't require typeclass search\n"}
{"name":"Fin.natCast_self","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ Eq (↑n) 0","decl":"@[simp high] lemma natCast_self (n : ℕ) [NeZero n] : (n : Fin n) = 0 := by ext; simp\n\n"}
{"name":"Fin.natCast_eq_zero","module":"Mathlib.Data.Fin.Basic","initialProofState":"a n : Nat\ninst✝ : NeZero n\n⊢ Iff (Eq (↑a) 0) (Dvd.dvd n a)","decl":"@[simp] lemma natCast_eq_zero {a n : ℕ} [NeZero n] : (a : Fin n) = 0 ↔ n ∣ a := by\n  simp [Fin.ext_iff, Nat.dvd_iff_mod_eq_zero]\n\n"}
{"name":"Fin.natCast_eq_last","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\n⊢ Eq (↑n) (Fin.last n)","decl":"@[simp]\ntheorem natCast_eq_last (n) : (n : Fin (n + 1)) = Fin.last n := by ext; simp\n\n"}
{"name":"Fin.le_val_last","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\n⊢ LE.le i ↑n","decl":"theorem le_val_last (i : Fin (n + 1)) : i ≤ n := by\n  rw [Fin.natCast_eq_last]\n  exact Fin.le_last i\n\n"}
{"name":"Fin.natCast_le_natCast","module":"Mathlib.Data.Fin.Basic","initialProofState":"n a b : Nat\nhan : LE.le a n\nhbn : LE.le b n\n⊢ Iff (LE.le ↑a ↑b) (LE.le a b)","decl":"lemma natCast_le_natCast (han : a ≤ n) (hbn : b ≤ n) : (a : Fin (n + 1)) ≤ b ↔ a ≤ b := by\n  rw [← Nat.lt_succ_iff] at han hbn\n  simp [le_iff_val_le_val, -val_fin_le, Nat.mod_eq_of_lt, han, hbn]\n\n"}
{"name":"Fin.natCast_lt_natCast","module":"Mathlib.Data.Fin.Basic","initialProofState":"n a b : Nat\nhan : LE.le a n\nhbn : LE.le b n\n⊢ Iff (LT.lt ↑a ↑b) (LT.lt a b)","decl":"lemma natCast_lt_natCast (han : a ≤ n) (hbn : b ≤ n) : (a : Fin (n + 1)) < b ↔ a < b := by\n  rw [← Nat.lt_succ_iff] at han hbn; simp [lt_iff_val_lt_val, Nat.mod_eq_of_lt, han, hbn]\n\n"}
{"name":"Fin.natCast_mono","module":"Mathlib.Data.Fin.Basic","initialProofState":"n a b : Nat\nhbn : LE.le b n\nhab : LE.le a b\n⊢ LE.le ↑a ↑b","decl":"lemma natCast_mono (hbn : b ≤ n) (hab : a ≤ b) : (a : Fin (n + 1)) ≤ b :=\n  (natCast_le_natCast (hab.trans hbn) hbn).2 hab\n\n"}
{"name":"Fin.natCast_strictMono","module":"Mathlib.Data.Fin.Basic","initialProofState":"n a b : Nat\nhbn : LE.le b n\nhab : LT.lt a b\n⊢ LT.lt ↑a ↑b","decl":"lemma natCast_strictMono (hbn : b ≤ n) (hab : a < b) : (a : Fin (n + 1)) < b :=\n  (natCast_lt_natCast (hab.le.trans hbn) hbn).2 hab\n\n"}
{"name":"Fin.succ_injective","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\n⊢ Function.Injective Fin.succ","decl":"lemma succ_injective (n : ℕ) : Injective (@Fin.succ n) := fun a b ↦ by simp [Fin.ext_iff]\n\n"}
{"name":"Fin.val_succEmb","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\n⊢ Eq (⇑(Fin.succEmb n)) Fin.succ","decl":"@[simp]\ntheorem val_succEmb : ⇑(succEmb n) = Fin.succ := rfl\n\n"}
{"name":"Fin.exists_succ_eq","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\nx : Fin (HAdd.hAdd n 1)\n⊢ Iff (Exists fun y => Eq y.succ x) (Ne x 0)","decl":"@[simp]\ntheorem exists_succ_eq {x : Fin (n + 1)} : (∃ y, Fin.succ y = x) ↔ x ≠ 0 :=\n  ⟨fun ⟨_, hy⟩ => hy ▸ succ_ne_zero _, x.cases (fun h => h.irrefl.elim) (fun _ _ => ⟨_, rfl⟩)⟩\n\n"}
{"name":"Fin.exists_succ_eq_of_ne_zero","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\nx : Fin (HAdd.hAdd n 1)\nh : Ne x 0\n⊢ Exists fun y => Eq y.succ x","decl":"theorem exists_succ_eq_of_ne_zero {x : Fin (n + 1)} (h : x ≠ 0) :\n    ∃ y, Fin.succ y = x := exists_succ_eq.mpr h\n\n"}
{"name":"Fin.succ_zero_eq_one'","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ Eq (Fin.succ 0) 1","decl":"@[simp]\ntheorem succ_zero_eq_one' [NeZero n] : Fin.succ (0 : Fin n) = 1 := by\n  cases n\n  · exact (NeZero.ne 0 rfl).elim\n  · rfl\n\n"}
{"name":"Fin.one_pos'","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ LT.lt 0 1","decl":"theorem one_pos' [NeZero n] : (0 : Fin (n + 1)) < 1 := succ_zero_eq_one' (n := n) ▸ succ_pos _\n"}
{"name":"Fin.zero_ne_one'","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ Ne 0 1","decl":"theorem zero_ne_one' [NeZero n] : (0 : Fin (n + 1)) ≠ 1 := Fin.ne_of_lt one_pos'\n\n"}
{"name":"Fin.succ_one_eq_two'","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ Eq (Fin.succ 1) 2","decl":"/--\nThe `Fin.succ_one_eq_two` in `Lean` only applies in `Fin (n+2)`.\nThis one instead uses a `NeZero n` typeclass hypothesis.\n-/\n@[simp]\ntheorem succ_one_eq_two' [NeZero n] : Fin.succ (1 : Fin (n + 1)) = 2 := by\n  cases n\n  · exact (NeZero.ne 0 rfl).elim\n  · rfl\n\n-- Version of `succ_one_eq_two` to be used by `dsimp`.\n-- Note the `'` swapped around due to a move to std4.\n\n"}
{"name":"Fin.le_zero_iff'","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\nk : Fin n\n⊢ Iff (LE.le k 0) (Eq k 0)","decl":"/--\nThe `Fin.le_zero_iff` in `Lean` only applies in `Fin (n+1)`.\nThis one instead uses a `NeZero n` typeclass hypothesis.\n-/\n@[simp]\ntheorem le_zero_iff' {n : ℕ} [NeZero n] {k : Fin n} : k ≤ 0 ↔ k = 0 :=\n  ⟨fun h => Fin.ext <| by rw [Nat.eq_zero_of_le_zero h]; rfl, by rintro rfl; exact Nat.le_refl _⟩\n\n-- TODO: Move to Batteries\n"}
{"name":"Fin.castLE_inj","module":"Mathlib.Data.Fin.Basic","initialProofState":"n m : Nat\nhmn : LE.le m n\na b : Fin m\n⊢ Iff (Eq (Fin.castLE hmn a) (Fin.castLE hmn b)) (Eq a b)","decl":"@[simp] lemma castLE_inj {hmn : m ≤ n} {a b : Fin m} : castLE hmn a = castLE hmn b ↔ a = b := by\n  simp [Fin.ext_iff]\n\n"}
{"name":"Fin.castAdd_inj","module":"Mathlib.Data.Fin.Basic","initialProofState":"n m : Nat\na b : Fin m\n⊢ Iff (Eq (Fin.castAdd n a) (Fin.castAdd n b)) (Eq a b)","decl":"@[simp] lemma castAdd_inj {a b : Fin m} : castAdd n a = castAdd n b ↔ a = b := by simp [Fin.ext_iff]\n\n"}
{"name":"Fin.castLE_injective","module":"Mathlib.Data.Fin.Basic","initialProofState":"n m : Nat\nhmn : LE.le m n\n⊢ Function.Injective (Fin.castLE hmn)","decl":"lemma castLE_injective (hmn : m ≤ n) : Injective (castLE hmn) :=\n  fun _ _ hab ↦ Fin.ext (congr_arg val hab :)\n\n"}
{"name":"Fin.castAdd_injective","module":"Mathlib.Data.Fin.Basic","initialProofState":"m n : Nat\n⊢ Function.Injective (Fin.castAdd n)","decl":"lemma castAdd_injective (m n : ℕ) : Injective (@Fin.castAdd m n) := castLE_injective _\n\n"}
{"name":"Fin.castSucc_injective","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\n⊢ Function.Injective Fin.castSucc","decl":"lemma castSucc_injective (n : ℕ) : Injective (@Fin.castSucc n) := castAdd_injective _ _\n\n"}
{"name":"Fin.castLEEmb_apply","module":"Mathlib.Data.Fin.Basic","initialProofState":"n m : Nat\nh : LE.le n m\ni : Fin n\n⊢ Eq ((Fin.castLEEmb h) i) (Fin.castLE h i)","decl":"/-- `Fin.castLE` as an `Embedding`, `castLEEmb h i` embeds `i` into a larger `Fin` type. -/\n@[simps! apply]\ndef castLEEmb (h : n ≤ m) : Fin n ↪ Fin m where\n  toFun := castLE h\n  inj' := castLE_injective _\n\n"}
{"name":"Fin.coe_castLEEmb","module":"Mathlib.Data.Fin.Basic","initialProofState":"m n : Nat\nhmn : LE.le m n\n⊢ Eq (⇑(Fin.castLEEmb hmn)) (Fin.castLE hmn)","decl":"@[simp, norm_cast] lemma coe_castLEEmb {m n} (hmn : m ≤ n) : castLEEmb hmn = castLE hmn := rfl\n\n/- The next proof can be golfed a lot using `Fintype.card`.\nIt is written this way to define `ENat.card` and `Nat.card` without a `Fintype` dependency\n(not done yet). -/\n"}
{"name":"Fin.nonempty_embedding_iff","module":"Mathlib.Data.Fin.Basic","initialProofState":"n m : Nat\n⊢ Iff (Nonempty (Function.Embedding (Fin n) (Fin m))) (LE.le n m)","decl":"lemma nonempty_embedding_iff : Nonempty (Fin n ↪ Fin m) ↔ n ≤ m := by\n  refine ⟨fun h ↦ ?_, fun h ↦ ⟨castLEEmb h⟩⟩\n  induction n generalizing m with\n  | zero => exact m.zero_le\n  | succ n ihn =>\n    cases' h with e\n    rcases exists_eq_succ_of_ne_zero (pos_iff_nonempty.2 (Nonempty.map e inferInstance)).ne'\n      with ⟨m, rfl⟩\n    refine Nat.succ_le_succ <| ihn ⟨?_⟩\n    refine ⟨fun i ↦ (e.setValue 0 0 i.succ).pred (mt e.setValue_eq_iff.1 i.succ_ne_zero),\n      fun i j h ↦ ?_⟩\n    simpa only [pred_inj, EmbeddingLike.apply_eq_iff_eq, succ_inj] using h\n\n"}
{"name":"Fin.equiv_iff_eq","module":"Mathlib.Data.Fin.Basic","initialProofState":"n m : Nat\n⊢ Iff (Nonempty (Equiv (Fin m) (Fin n))) (Eq m n)","decl":"lemma equiv_iff_eq : Nonempty (Fin m ≃ Fin n) ↔ m = n :=\n  ⟨fun ⟨e⟩ ↦ le_antisymm (nonempty_embedding_iff.1 ⟨e⟩) (nonempty_embedding_iff.1 ⟨e.symm⟩),\n    fun h ↦ h ▸ ⟨.refl _⟩⟩\n\n"}
{"name":"Fin.castLE_castSucc","module":"Mathlib.Data.Fin.Basic","initialProofState":"n m : Nat\ni : Fin n\nh : LE.le (HAdd.hAdd n 1) m\n⊢ Eq (Fin.castLE h i.castSucc) (Fin.castLE ⋯ i)","decl":"@[simp] lemma castLE_castSucc {n m} (i : Fin n) (h : n + 1 ≤ m) :\n    i.castSucc.castLE h = i.castLE (Nat.le_of_succ_le h) :=\n  rfl\n\n"}
{"name":"Fin.castLE_comp_castSucc","module":"Mathlib.Data.Fin.Basic","initialProofState":"n m : Nat\nh : LE.le (HAdd.hAdd n 1) m\n⊢ Eq (Function.comp (Fin.castLE h) Fin.castSucc) (Fin.castLE ⋯)","decl":"@[simp] lemma castLE_comp_castSucc {n m} (h : n + 1 ≤ m) :\n    Fin.castLE h ∘ Fin.castSucc = Fin.castLE (Nat.le_of_succ_le h) :=\n  rfl\n\n"}
{"name":"Fin.castLE_rfl","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\n⊢ Eq (Fin.castLE ⋯) id","decl":"@[simp] lemma castLE_rfl (n : ℕ) : Fin.castLE (le_refl n) = id :=\n  rfl\n\n"}
{"name":"Fin.range_castLE","module":"Mathlib.Data.Fin.Basic","initialProofState":"n k : Nat\nh : LE.le n k\n⊢ Eq (Set.range (Fin.castLE h)) (setOf fun i => LT.lt (↑i) n)","decl":"@[simp]\ntheorem range_castLE {n k : ℕ} (h : n ≤ k) : Set.range (castLE h) = { i : Fin k | (i : ℕ) < n } :=\n  Set.ext fun x => ⟨fun ⟨y, hy⟩ => hy ▸ y.2, fun hx => ⟨⟨x, hx⟩, rfl⟩⟩\n\n"}
{"name":"Fin.coe_of_injective_castLE_symm","module":"Mathlib.Data.Fin.Basic","initialProofState":"n k : Nat\nh : LE.le n k\ni : Fin k\nhi : Membership.mem (Set.range (Fin.castLE h)) i\n⊢ Eq ↑((Equiv.ofInjective (Fin.castLE h) ⋯).symm ⟨i, hi⟩) ↑i","decl":"@[simp]\ntheorem coe_of_injective_castLE_symm {n k : ℕ} (h : n ≤ k) (i : Fin k) (hi) :\n    ((Equiv.ofInjective _ (castLE_injective h)).symm ⟨i, hi⟩ : ℕ) = i := by\n  rw [← coe_castLE h]\n  exact congr_arg Fin.val (Equiv.apply_ofInjective_symm _ _)\n\n"}
{"name":"Fin.leftInverse_cast","module":"Mathlib.Data.Fin.Basic","initialProofState":"n m : Nat\neq : Eq n m\n⊢ Function.LeftInverse (Fin.cast ⋯) (Fin.cast eq)","decl":"theorem leftInverse_cast (eq : n = m) : LeftInverse (Fin.cast eq.symm) (Fin.cast eq) :=\n  fun _ => rfl\n\n"}
{"name":"Fin.rightInverse_cast","module":"Mathlib.Data.Fin.Basic","initialProofState":"n m : Nat\neq : Eq n m\n⊢ Function.RightInverse (Fin.cast ⋯) (Fin.cast eq)","decl":"theorem rightInverse_cast (eq : n = m) : RightInverse (Fin.cast eq.symm) (Fin.cast eq) :=\n  fun _ => rfl\n\n"}
{"name":"Fin.cast_inj","module":"Mathlib.Data.Fin.Basic","initialProofState":"n m : Nat\neq : Eq n m\na b : Fin n\n⊢ Iff (Eq (Fin.cast eq a) (Fin.cast eq b)) (Eq a b)","decl":"@[simp]\ntheorem cast_inj (eq : n = m) {a b : Fin n} : a.cast eq = b.cast eq ↔ a = b := by\n  simp [← val_inj]\n\n"}
{"name":"Fin.cast_lt_cast","module":"Mathlib.Data.Fin.Basic","initialProofState":"n m : Nat\neq : Eq n m\na b : Fin n\n⊢ Iff (LT.lt (Fin.cast eq a) (Fin.cast eq b)) (LT.lt a b)","decl":"@[simp]\ntheorem cast_lt_cast (eq : n = m) {a b : Fin n} : a.cast eq < b.cast eq ↔ a < b :=\n  Iff.rfl\n\n"}
{"name":"Fin.cast_le_cast","module":"Mathlib.Data.Fin.Basic","initialProofState":"n m : Nat\neq : Eq n m\na b : Fin n\n⊢ Iff (LE.le (Fin.cast eq a) (Fin.cast eq b)) (LE.le a b)","decl":"@[simp]\ntheorem cast_le_cast (eq : n = m) {a b : Fin n} : a.cast eq ≤ b.cast eq ↔ a ≤ b :=\n  Iff.rfl\n\n"}
{"name":"finCongr_apply","module":"Mathlib.Data.Fin.Basic","initialProofState":"n m : Nat\neq : Eq n m\ni : Fin n\n⊢ Eq ((finCongr eq) i) (Fin.cast eq i)","decl":"/-- The 'identity' equivalence between `Fin m` and `Fin n` when `m = n`. -/\n@[simps]\ndef _root_.finCongr (eq : n = m) : Fin n ≃ Fin m where\n  toFun := Fin.cast eq\n  invFun := Fin.cast eq.symm\n  left_inv := leftInverse_cast eq\n  right_inv := rightInverse_cast eq\n\n"}
{"name":"finCongr_symm_apply","module":"Mathlib.Data.Fin.Basic","initialProofState":"n m : Nat\neq : Eq n m\ni : Fin m\n⊢ Eq ((finCongr eq).symm i) (Fin.cast ⋯ i)","decl":"/-- The 'identity' equivalence between `Fin m` and `Fin n` when `m = n`. -/\n@[simps]\ndef _root_.finCongr (eq : n = m) : Fin n ≃ Fin m where\n  toFun := Fin.cast eq\n  invFun := Fin.cast eq.symm\n  left_inv := leftInverse_cast eq\n  right_inv := rightInverse_cast eq\n\n"}
{"name":"finCongr_apply_mk","module":"Mathlib.Data.Fin.Basic","initialProofState":"n m : Nat\nh : Eq m n\nk : Nat\nhk : LT.lt k m\n⊢ Eq ((finCongr h) ⟨k, hk⟩) ⟨k, ⋯⟩","decl":"@[simp] lemma _root_.finCongr_apply_mk (h : m = n) (k : ℕ) (hk : k < m) :\n    finCongr h ⟨k, hk⟩ = ⟨k, h ▸ hk⟩ := rfl\n\n"}
{"name":"finCongr_refl","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\nh : optParam (Eq n n) ⋯\n⊢ Eq (finCongr h) (Equiv.refl (Fin n))","decl":"@[simp]\nlemma _root_.finCongr_refl (h : n = n := rfl) : finCongr h = Equiv.refl (Fin n) := by ext; simp\n\n"}
{"name":"finCongr_symm","module":"Mathlib.Data.Fin.Basic","initialProofState":"n m : Nat\nh : Eq m n\n⊢ Eq (finCongr h).symm (finCongr ⋯)","decl":"@[simp] lemma _root_.finCongr_symm (h : m = n) : (finCongr h).symm = finCongr h.symm := rfl\n\n"}
{"name":"finCongr_apply_coe","module":"Mathlib.Data.Fin.Basic","initialProofState":"n m : Nat\nh : Eq m n\nk : Fin m\n⊢ Eq ↑((finCongr h) k) ↑k","decl":"@[simp] lemma _root_.finCongr_apply_coe (h : m = n) (k : Fin m) : (finCongr h k : ℕ) = k := rfl\n\n"}
{"name":"finCongr_symm_apply_coe","module":"Mathlib.Data.Fin.Basic","initialProofState":"n m : Nat\nh : Eq m n\nk : Fin n\n⊢ Eq ↑((finCongr h).symm k) ↑k","decl":"lemma _root_.finCongr_symm_apply_coe (h : m = n) (k : Fin n) : ((finCongr h).symm k : ℕ) = k := rfl\n\n"}
{"name":"finCongr_eq_equivCast","module":"Mathlib.Data.Fin.Basic","initialProofState":"n m : Nat\nh : Eq n m\n⊢ Eq (finCongr h) (Equiv.cast ⋯)","decl":"/-- While in many cases `finCongr` is better than `Equiv.cast`/`cast`, sometimes we want to apply\na generic theorem about `cast`. -/\nlemma _root_.finCongr_eq_equivCast (h : n = m) : finCongr h = .cast (h ▸ rfl) := by subst h; simp\n\n"}
{"name":"Fin.cast_zero","module":"Mathlib.Data.Fin.Basic","initialProofState":"n n' : Nat\ninst✝ : NeZero n\nh : Eq n n'\n⊢ Eq (Fin.cast h 0) 0","decl":"@[simp]\ntheorem cast_zero {n' : ℕ} [NeZero n] {h : n = n'} : (0 : Fin n).cast h =\n    by { haveI : NeZero n' := by {rw [← h]; infer_instance}; exact 0} := rfl\n\n"}
{"name":"Fin.cast_eq_cast","module":"Mathlib.Data.Fin.Basic","initialProofState":"n m : Nat\nh : Eq n m\n⊢ Eq (Fin.cast h) (cast ⋯)","decl":"/-- While in many cases `Fin.cast` is better than `Equiv.cast`/`cast`, sometimes we want to apply\na generic theorem about `cast`. -/\ntheorem cast_eq_cast (h : n = m) : (Fin.cast h : Fin n → Fin m) = _root_.cast (h ▸ rfl) := by\n  subst h\n  ext\n  rfl\n\n"}
{"name":"Fin.castAddEmb_apply","module":"Mathlib.Data.Fin.Basic","initialProofState":"n m : Nat\ni : Fin n\n⊢ Eq ((Fin.castAddEmb m) i) (Fin.castLE ⋯ i)","decl":"/-- `Fin.castAdd` as an `Embedding`, `castAddEmb m i` embeds `i : Fin n` in `Fin (n+m)`.\nSee also `Fin.natAddEmb` and `Fin.addNatEmb`. -/\n@[simps! apply]\ndef castAddEmb (m) : Fin n ↪ Fin (n + m) := castLEEmb (le_add_right n m)\n\n"}
{"name":"Fin.castSuccEmb_apply","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ni : Fin n\n⊢ Eq (Fin.castSuccEmb i) (Fin.castLE ⋯ i)","decl":"/-- `Fin.castSucc` as an `Embedding`, `castSuccEmb i` embeds `i : Fin n` in `Fin (n+1)`. -/\n@[simps! apply]\ndef castSuccEmb : Fin n ↪ Fin (n + 1) := castAddEmb _\n\n"}
{"name":"Fin.coe_castSuccEmb","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\n⊢ Eq (⇑Fin.castSuccEmb) Fin.castSucc","decl":"@[simp, norm_cast] lemma coe_castSuccEmb : (castSuccEmb : Fin n → Fin (n + 1)) = Fin.castSucc := rfl\n\n"}
{"name":"Fin.castSucc_le_succ","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ni : Fin n\n⊢ LE.le i.castSucc i.succ","decl":"theorem castSucc_le_succ {n} (i : Fin n) : i.castSucc ≤ i.succ := Nat.le_succ i\n\n"}
{"name":"Fin.castSucc_le_castSucc_iff","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin n\n⊢ Iff (LE.le a.castSucc b.castSucc) (LE.le a b)","decl":"@[simp] theorem castSucc_le_castSucc_iff {a b : Fin n} : castSucc a ≤ castSucc b ↔ a ≤ b := .rfl\n\n"}
{"name":"Fin.succ_le_castSucc_iff","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin n\n⊢ Iff (LE.le a.succ b.castSucc) (LT.lt a b)","decl":"@[simp] theorem succ_le_castSucc_iff {a b : Fin n} : succ a ≤ castSucc b ↔ a < b := by\n  rw [le_castSucc_iff, succ_lt_succ_iff]\n\n"}
{"name":"Fin.castSucc_lt_succ_iff","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin n\n⊢ Iff (LT.lt a.castSucc b.succ) (LE.le a b)","decl":"@[simp] theorem castSucc_lt_succ_iff {a b : Fin n} : castSucc a < succ b ↔ a ≤ b := by\n  rw [castSucc_lt_iff_succ_le, succ_le_succ_iff]\n\n"}
{"name":"Fin.le_of_castSucc_lt_of_succ_lt","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin (HAdd.hAdd n 1)\ni : Fin n\nhl : LT.lt i.castSucc a\nhu : LT.lt b i.succ\n⊢ LT.lt b a","decl":"theorem le_of_castSucc_lt_of_succ_lt {a b : Fin (n + 1)} {i : Fin n}\n    (hl : castSucc i < a) (hu : b < succ i) : b < a := by\n  simp [Fin.lt_def, -val_fin_lt] at *; omega\n\n"}
{"name":"Fin.castSucc_lt_or_lt_succ","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\ni : Fin n\n⊢ Or (LT.lt i.castSucc p) (LT.lt p i.succ)","decl":"theorem castSucc_lt_or_lt_succ (p : Fin (n + 1)) (i : Fin n) : castSucc i < p ∨ p < i.succ := by\n  simp [Fin.lt_def, -val_fin_lt]; omega\n\n"}
{"name":"Fin.succ_le_or_le_castSucc","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\ni : Fin n\n⊢ Or (LE.le i.succ p) (LE.le p i.castSucc)","decl":"theorem succ_le_or_le_castSucc (p : Fin (n + 1)) (i : Fin n) : succ i ≤ p ∨ p ≤ i.castSucc := by\n  rw [le_castSucc_iff, ← castSucc_lt_iff_succ_le]\n  exact p.castSucc_lt_or_lt_succ i\n\n"}
{"name":"Fin.exists_castSucc_eq_of_ne_last","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\nx : Fin (HAdd.hAdd n 1)\nh : Ne x (Fin.last n)\n⊢ Exists fun y => Eq y.castSucc x","decl":"theorem exists_castSucc_eq_of_ne_last {x : Fin (n + 1)} (h : x ≠ (last _)) :\n    ∃ y, Fin.castSucc y = x := exists_castSucc_eq.mpr h\n\n"}
{"name":"Fin.forall_fin_succ'","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\nP : Fin (HAdd.hAdd n 1) → Prop\n⊢ Iff (∀ (i : Fin (HAdd.hAdd n 1)), P i) (And (∀ (i : Fin n), P i.castSucc) (P (Fin.last n)))","decl":"theorem forall_fin_succ' {P : Fin (n + 1) → Prop} :\n    (∀ i, P i) ↔ (∀ i : Fin n, P i.castSucc) ∧ P (.last _) :=\n  ⟨fun H => ⟨fun _ => H _, H _⟩, fun ⟨H0, H1⟩ i => Fin.lastCases H1 H0 i⟩\n\n-- to match `Fin.eq_zero_or_eq_succ`\n"}
{"name":"Fin.eq_castSucc_or_eq_last","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\n⊢ Or (Exists fun j => Eq i j.castSucc) (Eq i (Fin.last n))","decl":"theorem eq_castSucc_or_eq_last {n : Nat} (i : Fin (n + 1)) :\n    (∃ j : Fin n, i = j.castSucc) ∨ i = last n := i.lastCases (Or.inr rfl) (Or.inl ⟨·, rfl⟩)\n\n"}
{"name":"Fin.exists_fin_succ'","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\nP : Fin (HAdd.hAdd n 1) → Prop\n⊢ Iff (Exists fun i => P i) (Or (Exists fun i => P i.castSucc) (P (Fin.last n)))","decl":"theorem exists_fin_succ' {P : Fin (n + 1) → Prop} :\n    (∃ i, P i) ↔ (∃ i : Fin n, P i.castSucc) ∨ P (.last _) :=\n  ⟨fun ⟨i, h⟩ => Fin.lastCases Or.inr (fun i hi => Or.inl ⟨i, hi⟩) i h,\n   fun h => h.elim (fun ⟨i, hi⟩ => ⟨i.castSucc, hi⟩) (fun h => ⟨.last _, h⟩)⟩\n\n"}
{"name":"Fin.castSucc_zero'","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ Eq (Fin.castSucc 0) 0","decl":"/--\nThe `Fin.castSucc_zero` in `Lean` only applies in `Fin (n+1)`.\nThis one instead uses a `NeZero n` typeclass hypothesis.\n-/\n@[simp]\ntheorem castSucc_zero' [NeZero n] : castSucc (0 : Fin n) = 0 := rfl\n\n"}
{"name":"Fin.castSucc_pos'","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\ni : Fin n\nh : LT.lt 0 i\n⊢ LT.lt 0 i.castSucc","decl":"/-- `castSucc i` is positive when `i` is positive.\n\nThe `Fin.castSucc_pos` in `Lean` only applies in `Fin (n+1)`.\nThis one instead uses a `NeZero n` typeclass hypothesis. -/\ntheorem castSucc_pos' [NeZero n] {i : Fin n} (h : 0 < i) : 0 < castSucc i := by\n  simpa [lt_iff_val_lt_val] using h\n\n"}
{"name":"Fin.castSucc_eq_zero_iff'","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\na : Fin n\n⊢ Iff (Eq a.castSucc 0) (Eq a 0)","decl":"/--\nThe `Fin.castSucc_eq_zero_iff` in `Lean` only applies in `Fin (n+1)`.\nThis one instead uses a `NeZero n` typeclass hypothesis.\n-/\n@[simp]\ntheorem castSucc_eq_zero_iff' [NeZero n] (a : Fin n) : castSucc a = 0 ↔ a = 0 :=\n  Fin.ext_iff.trans <| (Fin.ext_iff.trans <| by simp).symm\n\n"}
{"name":"Fin.castSucc_ne_zero_iff'","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\na : Fin n\n⊢ Iff (Ne a.castSucc 0) (Ne a 0)","decl":"/--\nThe `Fin.castSucc_ne_zero_iff` in `Lean` only applies in `Fin (n+1)`.\nThis one instead uses a `NeZero n` typeclass hypothesis.\n-/\ntheorem castSucc_ne_zero_iff' [NeZero n] (a : Fin n) : castSucc a ≠ 0 ↔ a ≠ 0 :=\n  not_iff_not.mpr <| castSucc_eq_zero_iff' a\n\n"}
{"name":"Fin.castSucc_ne_zero_of_lt","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np i : Fin n\nh : LT.lt p i\n⊢ Ne i.castSucc 0","decl":"theorem castSucc_ne_zero_of_lt {p i : Fin n} (h : p < i) : castSucc i ≠ 0 := by\n  cases n\n  · exact i.elim0\n  · rw [castSucc_ne_zero_iff', Ne, Fin.ext_iff]\n    exact ((zero_le _).trans_lt h).ne'\n\n"}
{"name":"Fin.succ_ne_last_iff","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na : Fin (HAdd.hAdd n 1)\n⊢ Iff (Ne a.succ (Fin.last (HAdd.hAdd n 1))) (Ne a (Fin.last n))","decl":"theorem succ_ne_last_iff (a : Fin (n + 1)) : succ a ≠ last (n + 1) ↔ a ≠ last n :=\n  not_iff_not.mpr <| succ_eq_last_succ\n\n"}
{"name":"Fin.succ_ne_last_of_lt","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np i : Fin n\nh : LT.lt i p\n⊢ Ne i.succ (Fin.last n)","decl":"theorem succ_ne_last_of_lt {p i : Fin n} (h : i < p) : succ i ≠ last n := by\n  cases n\n  · exact i.elim0\n  · rw [succ_ne_last_iff, Ne, Fin.ext_iff]\n    exact ((le_last _).trans_lt' h).ne\n\n"}
{"name":"Fin.coe_eq_castSucc","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na : Fin n\n⊢ Eq (↑↑a) a.castSucc","decl":"@[norm_cast, simp]\ntheorem coe_eq_castSucc {a : Fin n} : (a : Fin (n + 1)) = castSucc a := by\n  ext\n  exact val_cast_of_lt (Nat.lt.step a.is_lt)\n\n"}
{"name":"Fin.coe_succ_lt_iff_lt","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\nj k : Fin n\n⊢ Iff (LT.lt ↑↑j ↑↑k) (LT.lt j k)","decl":"theorem coe_succ_lt_iff_lt {n : ℕ} {j k : Fin n} : (j : Fin <| n + 1) < k ↔ j < k := by\n  simp only [coe_eq_castSucc, castSucc_lt_castSucc_iff]\n\n"}
{"name":"Fin.range_castSucc","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\n⊢ Eq (Set.range Fin.castSucc) (setOf fun i => LT.lt (↑i) n)","decl":"@[simp]\ntheorem range_castSucc {n : ℕ} : Set.range (castSucc : Fin n → Fin n.succ) =\n    ({ i | (i : ℕ) < n } : Set (Fin n.succ)) := range_castLE (by omega)\n\n"}
{"name":"Fin.coe_of_injective_castSucc_symm","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ni : Fin n.succ\nhi : Membership.mem (Set.range Fin.castSucc) i\n⊢ Eq ↑((Equiv.ofInjective Fin.castSucc ⋯).symm ⟨i, hi⟩) ↑i","decl":"@[simp]\ntheorem coe_of_injective_castSucc_symm {n : ℕ} (i : Fin n.succ) (hi) :\n    ((Equiv.ofInjective castSucc (castSucc_injective _)).symm ⟨i, hi⟩ : ℕ) = i := by\n  rw [← coe_castSucc]\n  exact congr_arg val (Equiv.apply_ofInjective_symm _ _)\n\n"}
{"name":"Fin.addNatEmb_apply","module":"Mathlib.Data.Fin.Basic","initialProofState":"n m : Nat\nx✝ : Fin n\n⊢ Eq ((Fin.addNatEmb m) x✝) (x✝.addNat m)","decl":"/-- `Fin.addNat` as an `Embedding`, `addNatEmb m i` adds `m` to `i`, generalizes `Fin.succ`. -/\n@[simps! apply]\ndef addNatEmb (m) : Fin n ↪ Fin (n + m) where\n  toFun := (addNat · m)\n  inj' a b := by simp [Fin.ext_iff]\n\n"}
{"name":"Fin.natAddEmb_apply","module":"Mathlib.Data.Fin.Basic","initialProofState":"n m : Nat\ni : Fin m\n⊢ Eq ((Fin.natAddEmb n) i) (Fin.natAdd n i)","decl":"/-- `Fin.natAdd` as an `Embedding`, `natAddEmb n i` adds `n` to `i` \"on the left\". -/\n@[simps! apply]\ndef natAddEmb (n) {m} : Fin m ↪ Fin (n + m) where\n  toFun := natAdd n\n  inj' a b := by simp [Fin.ext_iff]\n\n"}
{"name":"Fin.pred_one'","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\nh : optParam (Ne 1 0) ⋯\n⊢ Eq (Fin.pred 1 h) 0","decl":"theorem pred_one' [NeZero n] (h := (zero_ne_one' (n := n)).symm) :\n    Fin.pred (1 : Fin (n + 1)) h = 0 := by\n  simp_rw [Fin.ext_iff, coe_pred, val_one', val_zero', Nat.sub_eq_zero_iff_le, Nat.mod_le]\n\n"}
{"name":"Fin.pred_last","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\nh : optParam (Not (Eq (Fin.last (HAdd.hAdd n 1)) 0)) ⋯\n⊢ Eq ((Fin.last (HAdd.hAdd n 1)).pred h) (Fin.last n)","decl":"theorem pred_last (h := Fin.ext_iff.not.2 last_pos'.ne') :\n    pred (last (n + 1)) h = last n := by simp_rw [← succ_last, pred_succ]\n\n"}
{"name":"Fin.pred_lt_iff","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\nj : Fin n\ni : Fin (HAdd.hAdd n 1)\nhi : Ne i 0\n⊢ Iff (LT.lt (i.pred hi) j) (LT.lt i j.succ)","decl":"theorem pred_lt_iff {j : Fin n} {i : Fin (n + 1)} (hi : i ≠ 0) : pred i hi < j ↔ i < succ j := by\n  rw [← succ_lt_succ_iff, succ_pred]\n"}
{"name":"Fin.lt_pred_iff","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\nj : Fin n\ni : Fin (HAdd.hAdd n 1)\nhi : Ne i 0\n⊢ Iff (LT.lt j (i.pred hi)) (LT.lt j.succ i)","decl":"theorem lt_pred_iff {j : Fin n} {i : Fin (n + 1)} (hi : i ≠ 0) : j < pred i hi ↔ succ j < i := by\n  rw [← succ_lt_succ_iff, succ_pred]\n"}
{"name":"Fin.pred_le_iff","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\nj : Fin n\ni : Fin (HAdd.hAdd n 1)\nhi : Ne i 0\n⊢ Iff (LE.le (i.pred hi) j) (LE.le i j.succ)","decl":"theorem pred_le_iff {j : Fin n} {i : Fin (n + 1)} (hi : i ≠ 0) : pred i hi ≤ j ↔ i ≤ succ j := by\n  rw [← succ_le_succ_iff, succ_pred]\n"}
{"name":"Fin.le_pred_iff","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\nj : Fin n\ni : Fin (HAdd.hAdd n 1)\nhi : Ne i 0\n⊢ Iff (LE.le j (i.pred hi)) (LE.le j.succ i)","decl":"theorem le_pred_iff {j : Fin n} {i : Fin (n + 1)} (hi : i ≠ 0) : j ≤ pred i hi ↔ succ j ≤ i := by\n  rw [← succ_le_succ_iff, succ_pred]\n\n"}
{"name":"Fin.castSucc_pred_eq_pred_castSucc","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na : Fin (HAdd.hAdd n 1)\nha : Ne a 0\nha' : optParam (Ne a.castSucc 0) ⋯\n⊢ Eq (a.pred ha).castSucc (a.castSucc.pred ha')","decl":"theorem castSucc_pred_eq_pred_castSucc {a : Fin (n + 1)} (ha : a ≠ 0)\n    (ha' := castSucc_ne_zero_iff.mpr ha) :\n    (a.pred ha).castSucc = (castSucc a).pred ha' := rfl\n\n"}
{"name":"Fin.castSucc_pred_add_one_eq","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na : Fin (HAdd.hAdd n 1)\nha : Ne a 0\n⊢ Eq (HAdd.hAdd (a.pred ha).castSucc 1) a","decl":"theorem castSucc_pred_add_one_eq {a : Fin (n + 1)} (ha : a ≠ 0) :\n    (a.pred ha).castSucc + 1 = a := by\n  cases' a using cases with a\n  · exact (ha rfl).elim\n  · rw [pred_succ, coeSucc_eq_succ]\n\n"}
{"name":"Fin.le_pred_castSucc_iff","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin (HAdd.hAdd n 1)\nha : Ne a.castSucc 0\n⊢ Iff (LE.le b (a.castSucc.pred ha)) (LT.lt b a)","decl":"theorem le_pred_castSucc_iff {a b : Fin (n + 1)} (ha : castSucc a ≠ 0) :\n    b ≤ (castSucc a).pred ha ↔ b < a := by\n  rw [le_pred_iff, succ_le_castSucc_iff]\n\n"}
{"name":"Fin.pred_castSucc_lt_iff","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin (HAdd.hAdd n 1)\nha : Ne a.castSucc 0\n⊢ Iff (LT.lt (a.castSucc.pred ha) b) (LE.le a b)","decl":"theorem pred_castSucc_lt_iff {a b : Fin (n + 1)} (ha : castSucc a ≠ 0) :\n    (castSucc a).pred ha < b ↔ a ≤ b := by\n  rw [pred_lt_iff, castSucc_lt_succ_iff]\n\n"}
{"name":"Fin.pred_castSucc_lt","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na : Fin (HAdd.hAdd n 1)\nha : Ne a.castSucc 0\n⊢ LT.lt (a.castSucc.pred ha) a","decl":"theorem pred_castSucc_lt {a : Fin (n + 1)} (ha : castSucc a ≠ 0) :\n    (castSucc a).pred ha < a := by rw [pred_castSucc_lt_iff, le_def]\n\n"}
{"name":"Fin.le_castSucc_pred_iff","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin (HAdd.hAdd n 1)\nha : Ne a 0\n⊢ Iff (LE.le b (a.pred ha).castSucc) (LT.lt b a)","decl":"theorem le_castSucc_pred_iff {a b : Fin (n + 1)} (ha : a ≠ 0) :\n    b ≤ castSucc (a.pred ha) ↔ b < a := by\n  rw [castSucc_pred_eq_pred_castSucc, le_pred_castSucc_iff]\n\n"}
{"name":"Fin.castSucc_pred_lt_iff","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin (HAdd.hAdd n 1)\nha : Ne a 0\n⊢ Iff (LT.lt (a.pred ha).castSucc b) (LE.le a b)","decl":"theorem castSucc_pred_lt_iff {a b : Fin (n + 1)} (ha : a ≠ 0) :\n    castSucc (a.pred ha) < b ↔ a ≤ b := by\n  rw [castSucc_pred_eq_pred_castSucc, pred_castSucc_lt_iff]\n\n"}
{"name":"Fin.castSucc_pred_lt","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na : Fin (HAdd.hAdd n 1)\nha : Ne a 0\n⊢ LT.lt (a.pred ha).castSucc a","decl":"theorem castSucc_pred_lt {a : Fin (n + 1)} (ha : a ≠ 0) :\n    castSucc (a.pred ha) < a := by rw [castSucc_pred_lt_iff, le_def]\n\n"}
{"name":"Fin.castLT_eq_castPred","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\nh : LT.lt i (Fin.last n)\nh' : optParam (Not (Eq i (Fin.last n))) ⋯\n⊢ Eq (i.castLT h) (i.castPred h')","decl":"@[simp]\nlemma castLT_eq_castPred (i : Fin (n + 1)) (h : i < last _) (h' := Fin.ext_iff.not.2 h.ne) :\n    castLT i h = castPred i h' := rfl\n\n"}
{"name":"Fin.coe_castPred","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\nh : Ne i (Fin.last n)\n⊢ Eq ↑(i.castPred h) ↑i","decl":"@[simp]\nlemma coe_castPred (i : Fin (n + 1)) (h : i ≠ last _) : (castPred i h : ℕ) = i := rfl\n\n"}
{"name":"Fin.castPred_castSucc","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ni : Fin n\nh' : optParam (Not (Eq i.castSucc (Fin.last n))) ⋯\n⊢ Eq (i.castSucc.castPred h') i","decl":"@[simp]\ntheorem castPred_castSucc {i : Fin n} (h' := Fin.ext_iff.not.2 (castSucc_lt_last i).ne) :\n    castPred (castSucc i) h' = i := rfl\n\n"}
{"name":"Fin.castSucc_castPred","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\nh : Ne i (Fin.last n)\n⊢ Eq (i.castPred h).castSucc i","decl":"@[simp]\ntheorem castSucc_castPred (i : Fin (n + 1)) (h : i ≠ last n) :\n    castSucc (i.castPred h) = i := by\n  rcases exists_castSucc_eq.mpr h with ⟨y, rfl⟩\n  rw [castPred_castSucc]\n\n"}
{"name":"Fin.castPred_eq_iff_eq_castSucc","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\nhi : Ne i (Fin.last n)\nj : Fin n\n⊢ Iff (Eq (i.castPred hi) j) (Eq i j.castSucc)","decl":"theorem castPred_eq_iff_eq_castSucc (i : Fin (n + 1)) (hi : i ≠ last _) (j : Fin n) :\n    castPred i hi = j ↔ i = castSucc j :=\n  ⟨fun h => by rw [← h, castSucc_castPred], fun h => by simp_rw [h, castPred_castSucc]⟩\n\n"}
{"name":"Fin.castPred_mk","module":"Mathlib.Data.Fin.Basic","initialProofState":"n i : Nat\nh₁ : LT.lt i n\nh₂ : optParam (LT.lt i n.succ) ⋯\nh₃ : optParam (Ne ⟨i, h₂⟩ (Fin.last n)) ⋯\n⊢ Eq (⟨i, h₂⟩.castPred h₃) ⟨i, h₁⟩","decl":"@[simp]\ntheorem castPred_mk (i : ℕ) (h₁ : i < n) (h₂ := h₁.trans (Nat.lt_succ_self _))\n    (h₃ : ⟨i, h₂⟩ ≠ last _ := (ne_iff_vne _ _).mpr (val_last _ ▸ h₁.ne)) :\n  castPred ⟨i, h₂⟩ h₃ = ⟨i, h₁⟩ := rfl\n\n"}
{"name":"Fin.castPred_le_castPred_iff","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ni j : Fin (HAdd.hAdd n 1)\nhi : Ne i (Fin.last n)\nhj : Ne j (Fin.last n)\n⊢ Iff (LE.le (i.castPred hi) (j.castPred hj)) (LE.le i j)","decl":"theorem castPred_le_castPred_iff {i j : Fin (n + 1)} {hi : i ≠ last n} {hj : j ≠ last n} :\n    castPred i hi ≤ castPred j hj ↔ i ≤ j := Iff.rfl\n\n"}
{"name":"Fin.castPred_lt_castPred_iff","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ni j : Fin (HAdd.hAdd n 1)\nhi : Ne i (Fin.last n)\nhj : Ne j (Fin.last n)\n⊢ Iff (LT.lt (i.castPred hi) (j.castPred hj)) (LT.lt i j)","decl":"theorem castPred_lt_castPred_iff {i j : Fin (n + 1)} {hi : i ≠ last n} {hj : j ≠ last n} :\n    castPred i hi < castPred j hj ↔ i < j := Iff.rfl\n\n"}
{"name":"Fin.castPred_lt_iff","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\nj : Fin n\ni : Fin (HAdd.hAdd n 1)\nhi : Ne i (Fin.last n)\n⊢ Iff (LT.lt (i.castPred hi) j) (LT.lt i j.castSucc)","decl":"theorem castPred_lt_iff {j : Fin n} {i : Fin (n + 1)} (hi : i ≠ last n) :\n    castPred i hi < j ↔ i < castSucc j := by\n  rw [← castSucc_lt_castSucc_iff, castSucc_castPred]\n\n"}
{"name":"Fin.lt_castPred_iff","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\nj : Fin n\ni : Fin (HAdd.hAdd n 1)\nhi : Ne i (Fin.last n)\n⊢ Iff (LT.lt j (i.castPred hi)) (LT.lt j.castSucc i)","decl":"theorem lt_castPred_iff {j : Fin n} {i : Fin (n + 1)} (hi : i ≠ last n) :\n    j < castPred i hi ↔ castSucc j < i := by\n  rw [← castSucc_lt_castSucc_iff, castSucc_castPred]\n\n"}
{"name":"Fin.castPred_le_iff","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\nj : Fin n\ni : Fin (HAdd.hAdd n 1)\nhi : Ne i (Fin.last n)\n⊢ Iff (LE.le (i.castPred hi) j) (LE.le i j.castSucc)","decl":"theorem castPred_le_iff {j : Fin n} {i : Fin (n + 1)} (hi : i ≠ last n) :\n    castPred i hi ≤ j ↔ i ≤ castSucc j := by\n  rw [← castSucc_le_castSucc_iff, castSucc_castPred]\n\n"}
{"name":"Fin.le_castPred_iff","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\nj : Fin n\ni : Fin (HAdd.hAdd n 1)\nhi : Ne i (Fin.last n)\n⊢ Iff (LE.le j (i.castPred hi)) (LE.le j.castSucc i)","decl":"theorem le_castPred_iff {j : Fin n} {i : Fin (n + 1)} (hi : i ≠ last n) :\n    j ≤ castPred i hi ↔ castSucc j ≤ i := by\n  rw [← castSucc_le_castSucc_iff, castSucc_castPred]\n\n"}
{"name":"Fin.castPred_inj","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ni j : Fin (HAdd.hAdd n 1)\nhi : Ne i (Fin.last n)\nhj : Ne j (Fin.last n)\n⊢ Iff (Eq (i.castPred hi) (j.castPred hj)) (Eq i j)","decl":"theorem castPred_inj {i j : Fin (n + 1)} {hi : i ≠ last n} {hj : j ≠ last n} :\n    castPred i hi = castPred j hj ↔ i = j := by\n  simp_rw [Fin.ext_iff, le_antisymm_iff, ← le_def, castPred_le_castPred_iff]\n\n"}
{"name":"Fin.castPred_zero'","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\nh : optParam (Not (Eq 0 (Fin.last n))) ⋯\n⊢ Eq (Fin.castPred 0 h) 0","decl":"theorem castPred_zero' [NeZero n] (h := Fin.ext_iff.not.2 last_pos'.ne) :\n    castPred (0 : Fin (n + 1)) h = 0 := rfl\n\n"}
{"name":"Fin.castPred_zero","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\nh : optParam (Not (Eq 0 (Fin.last (HAdd.hAdd n 1)))) ⋯\n⊢ Eq (Fin.castPred 0 h) 0","decl":"theorem castPred_zero (h := Fin.ext_iff.not.2 last_pos.ne)  :\n    castPred (0 : Fin (n + 2)) h = 0 := rfl\n\n"}
{"name":"Fin.castPred_one","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\nh : optParam (Not (Eq 1 (Fin.last (HAdd.hAdd n 1)))) ⋯\n⊢ Eq (Fin.castPred 1 h) 1","decl":"@[simp]\ntheorem castPred_one [NeZero n] (h := Fin.ext_iff.not.2 one_lt_last.ne) :\n    castPred (1 : Fin (n + 2)) h = 1 := by\n  cases n\n  · exact subsingleton_one.elim _ 1\n  · rfl\n\n"}
{"name":"Fin.succ_castPred_eq_castPred_succ","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na : Fin (HAdd.hAdd n 1)\nha : Ne a (Fin.last n)\nha' : optParam (Ne a.succ (Fin.last (HAdd.hAdd n 1))) ⋯\n⊢ Eq (a.castPred ha).succ (a.succ.castPred ha')","decl":"theorem succ_castPred_eq_castPred_succ {a : Fin (n + 1)} (ha : a ≠ last n)\n    (ha' := a.succ_ne_last_iff.mpr ha) :\n    (a.castPred ha).succ = (succ a).castPred ha' := rfl\n\n"}
{"name":"Fin.succ_castPred_eq_add_one","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na : Fin (HAdd.hAdd n 1)\nha : Ne a (Fin.last n)\n⊢ Eq (a.castPred ha).succ (HAdd.hAdd a 1)","decl":"theorem succ_castPred_eq_add_one {a : Fin (n + 1)} (ha : a ≠ last n) :\n    (a.castPred ha).succ = a + 1 := by\n  cases' a using lastCases with a\n  · exact (ha rfl).elim\n  · rw [castPred_castSucc, coeSucc_eq_succ]\n\n"}
{"name":"Fin.castpred_succ_le_iff","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin (HAdd.hAdd n 1)\nha : Ne a.succ (Fin.last (HAdd.hAdd n 1))\n⊢ Iff (LE.le (a.succ.castPred ha) b) (LT.lt a b)","decl":"theorem castpred_succ_le_iff {a b : Fin (n + 1)} (ha : succ a ≠ last (n + 1)) :\n    (succ a).castPred ha ≤ b ↔ a < b := by\n  rw [castPred_le_iff, succ_le_castSucc_iff]\n\n"}
{"name":"Fin.lt_castPred_succ_iff","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin (HAdd.hAdd n 1)\nha : Ne a.succ (Fin.last (HAdd.hAdd n 1))\n⊢ Iff (LT.lt b (a.succ.castPred ha)) (LE.le b a)","decl":"theorem lt_castPred_succ_iff {a b : Fin (n + 1)} (ha : succ a ≠ last (n + 1)) :\n    b < (succ a).castPred ha ↔ b ≤ a := by\n  rw [lt_castPred_iff, castSucc_lt_succ_iff]\n\n"}
{"name":"Fin.lt_castPred_succ","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na : Fin (HAdd.hAdd n 1)\nha : Ne a.succ (Fin.last (HAdd.hAdd n 1))\n⊢ LT.lt a (a.succ.castPred ha)","decl":"theorem lt_castPred_succ {a : Fin (n + 1)} (ha : succ a ≠ last (n + 1)) :\n    a < (succ a).castPred ha := by rw [lt_castPred_succ_iff, le_def]\n\n"}
{"name":"Fin.succ_castPred_le_iff","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin (HAdd.hAdd n 1)\nha : Ne a (Fin.last n)\n⊢ Iff (LE.le (a.castPred ha).succ b) (LT.lt a b)","decl":"theorem succ_castPred_le_iff {a b : Fin (n + 1)} (ha : a ≠ last n) :\n    succ (a.castPred ha) ≤ b ↔ a < b := by\n  rw [succ_castPred_eq_castPred_succ ha, castpred_succ_le_iff]\n\n"}
{"name":"Fin.lt_succ_castPred_iff","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin (HAdd.hAdd n 1)\nha : Ne a (Fin.last n)\n⊢ Iff (LT.lt b (a.castPred ha).succ) (LE.le b a)","decl":"theorem lt_succ_castPred_iff {a b : Fin (n + 1)} (ha : a ≠ last n) :\n    b < succ (a.castPred ha) ↔ b ≤ a := by\n  rw [succ_castPred_eq_castPred_succ ha, lt_castPred_succ_iff]\n\n"}
{"name":"Fin.lt_succ_castPred","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na : Fin (HAdd.hAdd n 1)\nha : Ne a (Fin.last n)\n⊢ LT.lt a (a.castPred ha).succ","decl":"theorem lt_succ_castPred {a : Fin (n + 1)} (ha : a ≠ last n) :\n    a < succ (a.castPred ha) := by rw [lt_succ_castPred_iff, le_def]\n\n"}
{"name":"Fin.castPred_le_pred_iff","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin (HAdd.hAdd n 1)\nha : Ne a (Fin.last n)\nhb : Ne b 0\n⊢ Iff (LE.le (a.castPred ha) (b.pred hb)) (LT.lt a b)","decl":"theorem castPred_le_pred_iff {a b : Fin (n + 1)} (ha : a ≠ last n) (hb : b ≠ 0) :\n    castPred a ha ≤ pred b hb ↔ a < b := by\n  rw [le_pred_iff, succ_castPred_le_iff]\n\n"}
{"name":"Fin.pred_lt_castPred_iff","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin (HAdd.hAdd n 1)\nha : Ne a 0\nhb : Ne b (Fin.last n)\n⊢ Iff (LT.lt (a.pred ha) (b.castPred hb)) (LE.le a b)","decl":"theorem pred_lt_castPred_iff {a b : Fin (n + 1)} (ha : a ≠ 0) (hb : b ≠ last n) :\n    pred a ha < castPred b hb ↔ a ≤ b := by\n  rw [lt_castPred_iff, castSucc_pred_lt_iff ha]\n\n"}
{"name":"Fin.pred_lt_castPred","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na : Fin (HAdd.hAdd n 1)\nh₁ : Ne a 0\nh₂ : Ne a (Fin.last n)\n⊢ LT.lt (a.pred h₁) (a.castPred h₂)","decl":"theorem pred_lt_castPred {a : Fin (n + 1)} (h₁ : a ≠ 0) (h₂ : a ≠ last n) :\n    pred a h₁ < castPred a h₂ := by\n  rw [pred_lt_castPred_iff, le_def]\n\n"}
{"name":"Fin.succAbove_of_castSucc_lt","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\ni : Fin n\nh : LT.lt i.castSucc p\n⊢ Eq (p.succAbove i) i.castSucc","decl":"/-- Embedding `i : Fin n` into `Fin (n + 1)` with a hole around `p : Fin (n + 1)`\nembeds `i` by `castSucc` when the resulting `i.castSucc < p`. -/\nlemma succAbove_of_castSucc_lt (p : Fin (n + 1)) (i : Fin n) (h : castSucc i < p) :\n    p.succAbove i = castSucc i := if_pos h\n\n"}
{"name":"Fin.succAbove_of_succ_le","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\ni : Fin n\nh : LE.le i.succ p\n⊢ Eq (p.succAbove i) i.castSucc","decl":"lemma succAbove_of_succ_le (p : Fin (n + 1)) (i : Fin n) (h : succ i ≤ p) :\n    p.succAbove i = castSucc i :=\n  succAbove_of_castSucc_lt _ _ (castSucc_lt_iff_succ_le.mpr h)\n\n"}
{"name":"Fin.succAbove_of_le_castSucc","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\ni : Fin n\nh : LE.le p i.castSucc\n⊢ Eq (p.succAbove i) i.succ","decl":"/-- Embedding `i : Fin n` into `Fin (n + 1)` with a hole around `p : Fin (n + 1)`\nembeds `i` by `succ` when the resulting `p < i.succ`. -/\nlemma succAbove_of_le_castSucc (p : Fin (n + 1)) (i : Fin n) (h : p ≤ castSucc i) :\n    p.succAbove i = i.succ := if_neg (Fin.not_lt.2 h)\n\n"}
{"name":"Fin.succAbove_of_lt_succ","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\ni : Fin n\nh : LT.lt p i.succ\n⊢ Eq (p.succAbove i) i.succ","decl":"lemma succAbove_of_lt_succ (p : Fin (n + 1)) (i : Fin n) (h : p < succ i) :\n    p.succAbove i = succ i := succAbove_of_le_castSucc _ _ (le_castSucc_iff.mpr h)\n\n"}
{"name":"Fin.succAbove_succ_of_lt","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np i : Fin n\nh : LT.lt p i\n⊢ Eq (p.succ.succAbove i) i.succ","decl":"lemma succAbove_succ_of_lt (p i : Fin n) (h : p < i) : succAbove p.succ i = i.succ :=\n  succAbove_of_lt_succ _ _ (succ_lt_succ_iff.mpr h)\n\n"}
{"name":"Fin.succAbove_succ_of_le","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np i : Fin n\nh : LE.le i p\n⊢ Eq (p.succ.succAbove i) i.castSucc","decl":"lemma succAbove_succ_of_le (p i : Fin n) (h : i ≤ p) : succAbove p.succ i = i.castSucc :=\n  succAbove_of_succ_le _ _ (succ_le_succ_iff.mpr h)\n\n"}
{"name":"Fin.succAbove_succ_self","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\nj : Fin n\n⊢ Eq (j.succ.succAbove j) j.castSucc","decl":"@[simp] lemma succAbove_succ_self (j : Fin n) : j.succ.succAbove j = j.castSucc :=\n  succAbove_succ_of_le _ _ Fin.le_rfl\n\n"}
{"name":"Fin.succAbove_castSucc_of_lt","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np i : Fin n\nh : LT.lt i p\n⊢ Eq (p.castSucc.succAbove i) i.castSucc","decl":"lemma succAbove_castSucc_of_lt (p i : Fin n) (h : i < p) : succAbove p.castSucc i = i.castSucc :=\n  succAbove_of_castSucc_lt _ _ (castSucc_lt_castSucc_iff.2 h)\n\n"}
{"name":"Fin.succAbove_castSucc_of_le","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np i : Fin n\nh : LE.le p i\n⊢ Eq (p.castSucc.succAbove i) i.succ","decl":"lemma succAbove_castSucc_of_le (p i : Fin n) (h : p ≤ i) : succAbove p.castSucc i = i.succ :=\n  succAbove_of_le_castSucc _ _ (castSucc_le_castSucc_iff.2 h)\n\n"}
{"name":"Fin.succAbove_castSucc_self","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\nj : Fin n\n⊢ Eq (j.castSucc.succAbove j) j.succ","decl":"@[simp] lemma succAbove_castSucc_self (j : Fin n) : succAbove j.castSucc j = j.succ :=\n  succAbove_castSucc_of_le _ _ Fin.le_rfl\n\n"}
{"name":"Fin.succAbove_pred_of_lt","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np i : Fin (HAdd.hAdd n 1)\nh : LT.lt p i\nhi : optParam (Ne i 0) ⋯\n⊢ Eq (p.succAbove (i.pred hi)) i","decl":"lemma succAbove_pred_of_lt (p i : Fin (n + 1)) (h : p < i)\n    (hi := Fin.ne_of_gt <| Fin.lt_of_le_of_lt p.zero_le h) : succAbove p (i.pred hi) = i := by\n  rw [succAbove_of_lt_succ _ _ (succ_pred _ _ ▸ h), succ_pred]\n\n"}
{"name":"Fin.succAbove_pred_of_le","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np i : Fin (HAdd.hAdd n 1)\nh : LE.le i p\nhi : Ne i 0\n⊢ Eq (p.succAbove (i.pred hi)) (i.pred hi).castSucc","decl":"lemma succAbove_pred_of_le (p i : Fin (n + 1)) (h : i ≤ p) (hi : i ≠ 0) :\n    succAbove p (i.pred hi) = (i.pred hi).castSucc := succAbove_of_succ_le _ _ (succ_pred _ _ ▸ h)\n\n"}
{"name":"Fin.succAbove_pred_self","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\nh : Ne p 0\n⊢ Eq (p.succAbove (p.pred h)) (p.pred h).castSucc","decl":"@[simp] lemma succAbove_pred_self (p : Fin (n + 1)) (h : p ≠ 0) :\n    succAbove p (p.pred h) = (p.pred h).castSucc := succAbove_pred_of_le _ _ Fin.le_rfl h\n\n"}
{"name":"Fin.succAbove_castPred_of_lt","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np i : Fin (HAdd.hAdd n 1)\nh : LT.lt i p\nhi : optParam (Ne i (Fin.last n)) ⋯\n⊢ Eq (p.succAbove (i.castPred hi)) i","decl":"lemma succAbove_castPred_of_lt (p i : Fin (n + 1)) (h : i < p)\n    (hi := Fin.ne_of_lt <| Nat.lt_of_lt_of_le h p.le_last) : succAbove p (i.castPred hi) = i := by\n  rw [succAbove_of_castSucc_lt _ _ (castSucc_castPred _ _ ▸ h), castSucc_castPred]\n\n"}
{"name":"Fin.succAbove_castPred_of_le","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np i : Fin (HAdd.hAdd n 1)\nh : LE.le p i\nhi : Ne i (Fin.last n)\n⊢ Eq (p.succAbove (i.castPred hi)) (i.castPred hi).succ","decl":"lemma succAbove_castPred_of_le (p i : Fin (n + 1)) (h : p ≤ i) (hi : i ≠ last n) :\n    succAbove p (i.castPred hi) = (i.castPred hi).succ :=\n  succAbove_of_le_castSucc _ _ (castSucc_castPred _ _ ▸ h)\n\n"}
{"name":"Fin.succAbove_castPred_self","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\nh : Ne p (Fin.last n)\n⊢ Eq (p.succAbove (p.castPred h)) (p.castPred h).succ","decl":"lemma succAbove_castPred_self (p : Fin (n + 1)) (h : p ≠ last n) :\n    succAbove p (p.castPred h) = (p.castPred h).succ := succAbove_castPred_of_le _ _ Fin.le_rfl h\n\n"}
{"name":"Fin.succAbove_ne","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\ni : Fin n\n⊢ Ne (p.succAbove i) p","decl":"/-- Embedding `i : Fin n` into `Fin (n + 1)` with a hole around `p : Fin (n + 1)`\nnever results in `p` itself -/\nlemma succAbove_ne (p : Fin (n + 1)) (i : Fin n) : p.succAbove i ≠ p := by\n  rcases p.castSucc_lt_or_lt_succ i with (h | h)\n  · rw [succAbove_of_castSucc_lt _ _ h]\n    exact Fin.ne_of_lt h\n  · rw [succAbove_of_lt_succ _ _ h]\n    exact Fin.ne_of_gt h\n\n"}
{"name":"Fin.ne_succAbove","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\ni : Fin n\n⊢ Ne p (p.succAbove i)","decl":"lemma ne_succAbove (p : Fin (n + 1)) (i : Fin n) : p ≠ p.succAbove i := (succAbove_ne _ _).symm\n\n"}
{"name":"Fin.succAbove_right_injective","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\n⊢ Function.Injective p.succAbove","decl":"/-- Given a fixed pivot `p : Fin (n + 1)`, `p.succAbove` is injective. -/\nlemma succAbove_right_injective : Injective p.succAbove := by\n  rintro i j hij\n  unfold succAbove at hij\n  split_ifs at hij with hi hj hj\n  · exact castSucc_injective _ hij\n  · rw [hij] at hi\n    cases hj <| Nat.lt_trans j.castSucc_lt_succ hi\n  · rw [← hij] at hj\n    cases hi <| Nat.lt_trans i.castSucc_lt_succ hj\n  · exact succ_injective _ hij\n\n"}
{"name":"Fin.succAbove_right_inj","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\ni j : Fin n\n⊢ Iff (Eq (p.succAbove i) (p.succAbove j)) (Eq i j)","decl":"/-- Given a fixed pivot `p : Fin (n + 1)`, `p.succAbove` is injective. -/\nlemma succAbove_right_inj : p.succAbove i = p.succAbove j ↔ i = j :=\n  succAbove_right_injective.eq_iff\n\n"}
{"name":"Fin.succAboveEmb_apply","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\ni : Fin n\n⊢ Eq (p.succAboveEmb i) (p.succAbove i)","decl":"/--  `Fin.succAbove p` as an `Embedding`. -/\n@[simps!]\ndef succAboveEmb (p : Fin (n + 1)) : Fin n ↪ Fin (n + 1) := ⟨p.succAbove, succAbove_right_injective⟩\n\n"}
{"name":"Fin.coe_succAboveEmb","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\n⊢ Eq (⇑p.succAboveEmb) p.succAbove","decl":"@[simp, norm_cast] lemma coe_succAboveEmb (p : Fin (n + 1)) : p.succAboveEmb = p.succAbove := rfl\n\n"}
{"name":"Fin.succAbove_ne_zero_zero","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\na : Fin (HAdd.hAdd n 1)\nha : Ne a 0\n⊢ Eq (a.succAbove 0) 0","decl":"@[simp]\nlemma succAbove_ne_zero_zero [NeZero n] {a : Fin (n + 1)} (ha : a ≠ 0) : a.succAbove 0 = 0 := by\n  rw [Fin.succAbove_of_castSucc_lt]\n  · exact castSucc_zero'\n  · exact Fin.pos_iff_ne_zero.2 ha\n\n"}
{"name":"Fin.succAbove_eq_zero_iff","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\na : Fin (HAdd.hAdd n 1)\nb : Fin n\nha : Ne a 0\n⊢ Iff (Eq (a.succAbove b) 0) (Eq b 0)","decl":"lemma succAbove_eq_zero_iff [NeZero n] {a : Fin (n + 1)} {b : Fin n} (ha : a ≠ 0) :\n    a.succAbove b = 0 ↔ b = 0 := by\n  rw [← succAbove_ne_zero_zero ha, succAbove_right_inj]\n\n"}
{"name":"Fin.succAbove_ne_zero","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\na : Fin (HAdd.hAdd n 1)\nb : Fin n\nha : Ne a 0\nhb : Ne b 0\n⊢ Ne (a.succAbove b) 0","decl":"lemma succAbove_ne_zero [NeZero n] {a : Fin (n + 1)} {b : Fin n} (ha : a ≠ 0) (hb : b ≠ 0) :\n    a.succAbove b ≠ 0 := mt (succAbove_eq_zero_iff ha).mp hb\n\n"}
{"name":"Fin.succAbove_zero","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\n⊢ Eq (Fin.succAbove 0) Fin.succ","decl":"/-- Embedding `Fin n` into `Fin (n + 1)` with a hole around zero embeds by `succ`. -/\n@[simp] lemma succAbove_zero : succAbove (0 : Fin (n + 1)) = Fin.succ := rfl\n\n"}
{"name":"Fin.succAbove_zero_apply","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ni : Fin n\n⊢ Eq (Fin.succAbove 0 i) i.succ","decl":"lemma succAbove_zero_apply (i : Fin n) : succAbove 0 i = succ i := by rw [succAbove_zero]\n\n"}
{"name":"Fin.succAbove_ne_last_last","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na : Fin (HAdd.hAdd n 2)\nh : Ne a (Fin.last (HAdd.hAdd n 1))\n⊢ Eq (a.succAbove (Fin.last n)) (Fin.last (HAdd.hAdd n 1))","decl":"@[simp] lemma succAbove_ne_last_last {a : Fin (n + 2)} (h : a ≠ last (n + 1)) :\n    a.succAbove (last n) = last (n + 1) := by\n  rw [succAbove_of_lt_succ _ _ (succ_last _ ▸ lt_last_iff_ne_last.2 h), succ_last]\n\n"}
{"name":"Fin.succAbove_eq_last_iff","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na : Fin (HAdd.hAdd n 2)\nb : Fin (HAdd.hAdd n 1)\nha : Ne a (Fin.last (HAdd.hAdd n 1))\n⊢ Iff (Eq (a.succAbove b) (Fin.last (HAdd.hAdd n 1))) (Eq b (Fin.last n))","decl":"lemma succAbove_eq_last_iff {a : Fin (n + 2)} {b : Fin (n + 1)} (ha : a ≠ last _) :\n    a.succAbove b = last _ ↔ b = last _ := by\n  simp [← succAbove_ne_last_last ha, succAbove_right_inj]\n\n"}
{"name":"Fin.succAbove_ne_last","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na : Fin (HAdd.hAdd n 2)\nb : Fin (HAdd.hAdd n 1)\nha : Ne a (Fin.last (HAdd.hAdd n 1))\nhb : Ne b (Fin.last n)\n⊢ Ne (a.succAbove b) (Fin.last (HAdd.hAdd n 1))","decl":"lemma succAbove_ne_last {a : Fin (n + 2)} {b : Fin (n + 1)} (ha : a ≠ last _) (hb : b ≠ last _) :\n    a.succAbove b ≠ last _ := mt (succAbove_eq_last_iff ha).mp hb\n\n"}
{"name":"Fin.succAbove_last","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\n⊢ Eq (Fin.last n).succAbove Fin.castSucc","decl":"/-- Embedding `Fin n` into `Fin (n + 1)` with a hole around `last n` embeds by `castSucc`. -/\n@[simp] lemma succAbove_last : succAbove (last n) = castSucc := by\n  ext; simp only [succAbove_of_castSucc_lt, castSucc_lt_last]\n\n"}
{"name":"Fin.succAbove_last_apply","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ni : Fin n\n⊢ Eq ((Fin.last n).succAbove i) i.castSucc","decl":"lemma succAbove_last_apply (i : Fin n) : succAbove (last n) i = castSucc i := by rw [succAbove_last]\n\n"}
{"name":"Fin.succAbove_lt_iff_castSucc_lt","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\ni : Fin n\n⊢ Iff (LT.lt (p.succAbove i) p) (LT.lt i.castSucc p)","decl":"/-- Embedding `i : Fin n` into `Fin (n + 1)` using a pivot `p` that is greater\nresults in a value that is less than `p`. -/\nlemma succAbove_lt_iff_castSucc_lt (p : Fin (n + 1)) (i : Fin n) :\n    p.succAbove i < p ↔ castSucc i < p := by\n  cases' castSucc_lt_or_lt_succ p i with H H\n  · rwa [iff_true_right H, succAbove_of_castSucc_lt _ _ H]\n  · rw [castSucc_lt_iff_succ_le, iff_false_right (Fin.not_le.2 H), succAbove_of_lt_succ _ _ H]\n    exact Fin.not_lt.2 <| Fin.le_of_lt H\n\n"}
{"name":"Fin.succAbove_lt_iff_succ_le","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\ni : Fin n\n⊢ Iff (LT.lt (p.succAbove i) p) (LE.le i.succ p)","decl":"lemma succAbove_lt_iff_succ_le (p : Fin (n + 1)) (i : Fin n) :\n    p.succAbove i < p ↔ succ i ≤ p := by\n  rw [succAbove_lt_iff_castSucc_lt, castSucc_lt_iff_succ_le]\n\n"}
{"name":"Fin.lt_succAbove_iff_le_castSucc","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\ni : Fin n\n⊢ Iff (LT.lt p (p.succAbove i)) (LE.le p i.castSucc)","decl":"/-- Embedding `i : Fin n` into `Fin (n + 1)` using a pivot `p` that is lesser\nresults in a value that is greater than `p`. -/\nlemma lt_succAbove_iff_le_castSucc (p : Fin (n + 1)) (i : Fin n) :\n    p < p.succAbove i ↔ p ≤ castSucc i := by\n  cases' castSucc_lt_or_lt_succ p i with H H\n  · rw [iff_false_right (Fin.not_le.2 H), succAbove_of_castSucc_lt _ _ H]\n    exact Fin.not_lt.2 <| Fin.le_of_lt H\n  · rwa [succAbove_of_lt_succ _ _ H, iff_true_left H, le_castSucc_iff]\n\n"}
{"name":"Fin.lt_succAbove_iff_lt_castSucc","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\ni : Fin n\n⊢ Iff (LT.lt p (p.succAbove i)) (LT.lt p i.succ)","decl":"lemma lt_succAbove_iff_lt_castSucc (p : Fin (n + 1)) (i : Fin n) :\n    p < p.succAbove i ↔ p < succ i := by rw [lt_succAbove_iff_le_castSucc, le_castSucc_iff]\n\n"}
{"name":"Fin.succAbove_pos","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\np : Fin (HAdd.hAdd n 1)\ni : Fin n\nh : LT.lt 0 i\n⊢ LT.lt 0 (p.succAbove i)","decl":"/-- Embedding a positive `Fin n` results in a positive `Fin (n + 1)` -/\nlemma succAbove_pos [NeZero n] (p : Fin (n + 1)) (i : Fin n) (h : 0 < i) : 0 < p.succAbove i := by\n  by_cases H : castSucc i < p\n  · simpa [succAbove_of_castSucc_lt _ _ H] using castSucc_pos' h\n  · simp [succAbove_of_le_castSucc _ _ (Fin.not_lt.1 H)]\n\n"}
{"name":"Fin.castPred_succAbove","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\nx : Fin n\ny : Fin (HAdd.hAdd n 1)\nh : LT.lt x.castSucc y\nh' : optParam (Ne (y.succAbove x) (Fin.last n)) ⋯\n⊢ Eq ((y.succAbove x).castPred h') x","decl":"lemma castPred_succAbove (x : Fin n) (y : Fin (n + 1)) (h : castSucc x < y)\n    (h' := Fin.ne_last_of_lt <| (succAbove_lt_iff_castSucc_lt ..).2 h) :\n    (y.succAbove x).castPred h' = x := by\n  rw [castPred_eq_iff_eq_castSucc, succAbove_of_castSucc_lt _ _ h]\n\n"}
{"name":"Fin.pred_succAbove","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\nx : Fin n\ny : Fin (HAdd.hAdd n 1)\nh : LE.le y x.castSucc\nh' : optParam (Ne (y.succAbove x) 0) ⋯\n⊢ Eq ((y.succAbove x).pred h') x","decl":"lemma pred_succAbove (x : Fin n) (y : Fin (n + 1)) (h : y ≤ castSucc x)\n    (h' := Fin.ne_zero_of_lt <| (lt_succAbove_iff_le_castSucc ..).2 h) :\n    (y.succAbove x).pred h' = x := by simp only [succAbove_of_le_castSucc _ _ h, pred_succ]\n\n"}
{"name":"Fin.exists_succAbove_eq","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\nx y : Fin (HAdd.hAdd n 1)\nh : Ne x y\n⊢ Exists fun z => Eq (y.succAbove z) x","decl":"lemma exists_succAbove_eq {x y : Fin (n + 1)} (h : x ≠ y) : ∃ z, y.succAbove z = x := by\n  obtain hxy | hyx := Fin.lt_or_lt_of_ne h\n  exacts [⟨_, succAbove_castPred_of_lt _ _ hxy⟩, ⟨_, succAbove_pred_of_lt _ _ hyx⟩]\n\n"}
{"name":"Fin.exists_succAbove_eq_iff","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\nx y : Fin (HAdd.hAdd n 1)\n⊢ Iff (Exists fun z => Eq (x.succAbove z) y) (Ne y x)","decl":"@[simp] lemma exists_succAbove_eq_iff {x y : Fin (n + 1)} : (∃ z, x.succAbove z = y) ↔ y ≠ x :=\n  ⟨by rintro ⟨y, rfl⟩; exact succAbove_ne _ _, exists_succAbove_eq⟩\n\n"}
{"name":"Fin.range_succAbove","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\n⊢ Eq (Set.range p.succAbove) (HasCompl.compl (Singleton.singleton p))","decl":"/-- The range of `p.succAbove` is everything except `p`. -/\n@[simp] lemma range_succAbove (p : Fin (n + 1)) : Set.range p.succAbove = {p}ᶜ :=\n  Set.ext fun _ => exists_succAbove_eq_iff\n\n"}
{"name":"Fin.range_succ","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\n⊢ Eq (Set.range Fin.succ) (HasCompl.compl (Singleton.singleton 0))","decl":"@[simp] lemma range_succ (n : ℕ) : Set.range (Fin.succ : Fin n → Fin (n + 1)) = {0}ᶜ := by\n  rw [← succAbove_zero]; exact range_succAbove (0 : Fin (n + 1))\n\n"}
{"name":"Fin.succAbove_left_injective","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\n⊢ Function.Injective Fin.succAbove","decl":"/-- `succAbove` is injective at the pivot -/\nlemma succAbove_left_injective : Injective (@succAbove n) := fun _ _ h => by\n  simpa [range_succAbove] using congr_arg (fun f : Fin n → Fin (n + 1) => (Set.range f)ᶜ) h\n\n"}
{"name":"Fin.succAbove_left_inj","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\nx y : Fin (HAdd.hAdd n 1)\n⊢ Iff (Eq x.succAbove y.succAbove) (Eq x y)","decl":"/-- `succAbove` is injective at the pivot -/\n@[simp] lemma succAbove_left_inj {x y : Fin (n + 1)} : x.succAbove = y.succAbove ↔ x = y :=\n  succAbove_left_injective.eq_iff\n\n"}
{"name":"Fin.zero_succAbove","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ni : Fin n\n⊢ Eq (Fin.succAbove 0 i) i.succ","decl":"@[simp] lemma zero_succAbove {n : ℕ} (i : Fin n) : (0 : Fin (n + 1)).succAbove i = i.succ := rfl\n\n"}
{"name":"Fin.succ_succAbove_zero","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\ni : Fin n\n⊢ Eq (i.succ.succAbove 0) 0","decl":"@[simp] lemma succ_succAbove_zero {n : ℕ} [NeZero n] (i : Fin n) : succAbove i.succ 0 = 0 :=\n  succAbove_of_castSucc_lt i.succ 0 (by simp only [castSucc_zero', succ_pos])\n\n"}
{"name":"Fin.succ_succAbove_succ","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\nj : Fin n\n⊢ Eq (i.succ.succAbove j.succ) (i.succAbove j).succ","decl":"/-- `succ` commutes with `succAbove`. -/\n@[simp] lemma succ_succAbove_succ {n : ℕ} (i : Fin (n + 1)) (j : Fin n) :\n    i.succ.succAbove j.succ = (i.succAbove j).succ := by\n  obtain h | h := i.lt_or_le (succ j)\n  · rw [succAbove_of_lt_succ _ _ h, succAbove_succ_of_lt _ _ h]\n  · rwa [succAbove_of_castSucc_lt _ _ h, succAbove_succ_of_le, succ_castSucc]\n\n"}
{"name":"Fin.castSucc_succAbove_castSucc","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\nj : Fin n\n⊢ Eq (i.castSucc.succAbove j.castSucc) (i.succAbove j).castSucc","decl":"/-- `castSucc` commutes with `succAbove`. -/\n@[simp]\nlemma castSucc_succAbove_castSucc {n : ℕ} {i : Fin (n + 1)} {j : Fin n} :\n    i.castSucc.succAbove j.castSucc = (i.succAbove j).castSucc := by\n  rcases i.le_or_lt (castSucc j) with (h | h)\n  · rw [succAbove_of_le_castSucc _ _ h, succAbove_castSucc_of_le _ _ h, succ_castSucc]\n  · rw [succAbove_of_castSucc_lt _ _ h, succAbove_castSucc_of_lt _ _ h]\n\n"}
{"name":"Fin.pred_succAbove_pred","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na : Fin (HAdd.hAdd n 2)\nb : Fin (HAdd.hAdd n 1)\nha : Ne a 0\nhb : Ne b 0\nhk : optParam (Ne (a.succAbove b) 0) ⋯\n⊢ Eq ((a.pred ha).succAbove (b.pred hb)) ((a.succAbove b).pred hk)","decl":"/-- `pred` commutes with `succAbove`. -/\nlemma pred_succAbove_pred {a : Fin (n + 2)} {b : Fin (n + 1)} (ha : a ≠ 0) (hb : b ≠ 0)\n    (hk := succAbove_ne_zero ha hb) :\n    (a.pred ha).succAbove (b.pred hb) = (a.succAbove b).pred hk := by\n  simp_rw [← succ_inj (b := pred (succAbove a b) hk), ← succ_succAbove_succ, succ_pred]\n\n"}
{"name":"Fin.castPred_succAbove_castPred","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na : Fin (HAdd.hAdd n 2)\nb : Fin (HAdd.hAdd n 1)\nha : Ne a (Fin.last (HAdd.hAdd n 1))\nhb : Ne b (Fin.last n)\nhk : optParam (Ne (a.succAbove b) (Fin.last (HAdd.hAdd n 1))) ⋯\n⊢ Eq ((a.castPred ha).succAbove (b.castPred hb)) ((a.succAbove b).castPred hk)","decl":"/-- `castPred` commutes with `succAbove`. -/\nlemma castPred_succAbove_castPred {a : Fin (n + 2)} {b : Fin (n + 1)} (ha : a ≠ last (n + 1))\n    (hb : b ≠ last n) (hk := succAbove_ne_last ha hb) :\n    (a.castPred ha).succAbove (b.castPred hb) = (a.succAbove b).castPred hk := by\n  simp_rw [← castSucc_inj (b := (a.succAbove b).castPred hk), ← castSucc_succAbove_castSucc,\n    castSucc_castPred]\n\n--@[simp] -- Porting note: can be proved by `simp`\n"}
{"name":"Fin.one_succAbove_zero","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\n⊢ Eq (Fin.succAbove 1 0) 0","decl":"lemma one_succAbove_zero {n : ℕ} : (1 : Fin (n + 2)).succAbove 0 = 0 := by\n  rfl\n\n"}
{"name":"Fin.succ_succAbove_one","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq (i.succ.succAbove 1) (i.succAbove 0).succ","decl":"/-- By moving `succ` to the outside of this expression, we create opportunities for further\nsimplification using `succAbove_zero` or `succ_succAbove_zero`. -/\n@[simp] lemma succ_succAbove_one {n : ℕ} [NeZero n] (i : Fin (n + 1)) :\n    i.succ.succAbove 1 = (i.succAbove 0).succ := by\n  rw [← succ_zero_eq_one']; convert succ_succAbove_succ i 0\n\n"}
{"name":"Fin.one_succAbove_succ","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\nj : Fin n\n⊢ Eq (Fin.succAbove 1 j.succ) j.succ.succ","decl":"@[simp] lemma one_succAbove_succ {n : ℕ} (j : Fin n) :\n    (1 : Fin (n + 2)).succAbove j.succ = j.succ.succ := by\n  have := succ_succAbove_succ 0 j; rwa [succ_zero_eq_one, zero_succAbove] at this\n\n"}
{"name":"Fin.one_succAbove_one","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\n⊢ Eq (Fin.succAbove 1 1) 2","decl":"@[simp] lemma one_succAbove_one {n : ℕ} : (1 : Fin (n + 3)).succAbove 1 = 2 := by\n  simpa only [succ_zero_eq_one, val_zero, zero_succAbove, succ_one_eq_two]\n    using succ_succAbove_succ (0 : Fin (n + 2)) (0 : Fin (n + 2))\n\n"}
{"name":"Fin.predAbove_of_le_castSucc","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np : Fin n\ni : Fin (HAdd.hAdd n 1)\nh : LE.le i p.castSucc\nhi : optParam (Ne i (Fin.last n)) ⋯\n⊢ Eq (p.predAbove i) (i.castPred hi)","decl":"lemma predAbove_of_le_castSucc (p : Fin n) (i : Fin (n + 1)) (h : i ≤ castSucc p)\n    (hi := Fin.ne_of_lt <| Fin.lt_of_le_of_lt h <| castSucc_lt_last _) :\n    p.predAbove i = i.castPred hi := dif_neg <| Fin.not_lt.2 h\n\n"}
{"name":"Fin.predAbove_of_lt_succ","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np : Fin n\ni : Fin (HAdd.hAdd n 1)\nh : LT.lt i p.succ\nhi : optParam (Ne i (Fin.last n)) ⋯\n⊢ Eq (p.predAbove i) (i.castPred hi)","decl":"lemma predAbove_of_lt_succ (p : Fin n) (i : Fin (n + 1)) (h : i < succ p)\n    (hi := Fin.ne_last_of_lt h) : p.predAbove i = i.castPred hi :=\n  predAbove_of_le_castSucc _ _ (le_castSucc_iff.mpr h)\n\n"}
{"name":"Fin.predAbove_of_castSucc_lt","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np : Fin n\ni : Fin (HAdd.hAdd n 1)\nh : LT.lt p.castSucc i\nhi : optParam (Ne i 0) ⋯\n⊢ Eq (p.predAbove i) (i.pred hi)","decl":"lemma predAbove_of_castSucc_lt (p : Fin n) (i : Fin (n + 1)) (h : castSucc p < i)\n    (hi := Fin.ne_zero_of_lt h) : p.predAbove i = i.pred hi := dif_pos h\n\n"}
{"name":"Fin.predAbove_of_succ_le","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np : Fin n\ni : Fin (HAdd.hAdd n 1)\nh : LE.le p.succ i\nhi : optParam (Ne i 0) ⋯\n⊢ Eq (p.predAbove i) (i.pred hi)","decl":"lemma predAbove_of_succ_le (p : Fin n) (i : Fin (n + 1)) (h : succ p ≤ i)\n    (hi := Fin.ne_of_gt <| Fin.lt_of_lt_of_le (succ_pos _) h) :\n    p.predAbove i = i.pred hi := predAbove_of_castSucc_lt _ _ (castSucc_lt_iff_succ_le.mpr h)\n\n"}
{"name":"Fin.predAbove_succ_of_lt","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np i : Fin n\nh : LT.lt i p\nhi : optParam (Ne i.succ (Fin.last n)) ⋯\n⊢ Eq (p.predAbove i.succ) (i.succ.castPred hi)","decl":"lemma predAbove_succ_of_lt (p i : Fin n) (h : i < p) (hi := succ_ne_last_of_lt h) :\n    p.predAbove (succ i) = (i.succ).castPred hi := by\n  rw [predAbove_of_lt_succ _ _ (succ_lt_succ_iff.mpr h)]\n\n"}
{"name":"Fin.predAbove_succ_of_le","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np i : Fin n\nh : LE.le p i\n⊢ Eq (p.predAbove i.succ) i","decl":"lemma predAbove_succ_of_le (p i : Fin n) (h : p ≤ i) : p.predAbove (succ i) = i := by\n  rw [predAbove_of_succ_le _ _ (succ_le_succ_iff.mpr h), pred_succ]\n\n"}
{"name":"Fin.predAbove_succ_self","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np : Fin n\n⊢ Eq (p.predAbove p.succ) p","decl":"@[simp] lemma predAbove_succ_self (p : Fin n) : p.predAbove (succ p) = p :=\n  predAbove_succ_of_le _ _ Fin.le_rfl\n\n"}
{"name":"Fin.predAbove_castSucc_of_lt","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np i : Fin n\nh : LT.lt p i\nhi : optParam (Ne i.castSucc 0) ⋯\n⊢ Eq (p.predAbove i.castSucc) (i.castSucc.pred hi)","decl":"lemma predAbove_castSucc_of_lt (p i : Fin n) (h : p < i) (hi := castSucc_ne_zero_of_lt h) :\n    p.predAbove (castSucc i) = i.castSucc.pred hi := by\n  rw [predAbove_of_castSucc_lt _ _ (castSucc_lt_castSucc_iff.2 h)]\n\n"}
{"name":"Fin.predAbove_castSucc_of_le","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np i : Fin n\nh : LE.le i p\n⊢ Eq (p.predAbove i.castSucc) i","decl":"lemma predAbove_castSucc_of_le (p i : Fin n) (h : i ≤ p) : p.predAbove (castSucc i) = i := by\n  rw [predAbove_of_le_castSucc _ _ (castSucc_le_castSucc_iff.mpr h), castPred_castSucc]\n\n"}
{"name":"Fin.predAbove_castSucc_self","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np : Fin n\n⊢ Eq (p.predAbove p.castSucc) p","decl":"@[simp] lemma predAbove_castSucc_self (p : Fin n) : p.predAbove (castSucc p) = p :=\n  predAbove_castSucc_of_le _ _ Fin.le_rfl\n\n"}
{"name":"Fin.predAbove_pred_of_lt","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np i : Fin (HAdd.hAdd n 1)\nh : LT.lt i p\nhp : optParam (Ne p 0) ⋯\nhi : optParam (Ne i (Fin.last n)) ⋯\n⊢ Eq ((p.pred hp).predAbove i) (i.castPred hi)","decl":"lemma predAbove_pred_of_lt (p i : Fin (n + 1)) (h : i < p) (hp := Fin.ne_zero_of_lt h)\n    (hi := Fin.ne_last_of_lt h) : (pred p hp).predAbove i = castPred i hi := by\n  rw [predAbove_of_lt_succ _ _ (succ_pred _ _ ▸ h)]\n\n"}
{"name":"Fin.predAbove_pred_of_le","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np i : Fin (HAdd.hAdd n 1)\nh : LE.le p i\nhp : Ne p 0\nhi : optParam (Ne i 0) ⋯\n⊢ Eq ((p.pred hp).predAbove i) (i.pred hi)","decl":"lemma predAbove_pred_of_le (p i : Fin (n + 1)) (h : p ≤ i) (hp : p ≠ 0)\n    (hi := Fin.ne_of_gt <| Fin.lt_of_lt_of_le (Fin.pos_iff_ne_zero.2 hp) h) :\n  (pred p hp).predAbove i = pred i hi := by rw [predAbove_of_succ_le _ _ (succ_pred _ _ ▸ h)]\n\n"}
{"name":"Fin.predAbove_pred_self","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\nhp : Ne p 0\n⊢ Eq ((p.pred hp).predAbove p) (p.pred hp)","decl":"lemma predAbove_pred_self (p : Fin (n + 1)) (hp : p ≠ 0) : (pred p hp).predAbove p = pred p hp :=\n  predAbove_pred_of_le _ _ Fin.le_rfl hp\n\n"}
{"name":"Fin.predAbove_castPred_of_lt","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np i : Fin (HAdd.hAdd n 1)\nh : LT.lt p i\nhp : optParam (Ne p (Fin.last n)) ⋯\nhi : optParam (Ne i 0) ⋯\n⊢ Eq ((p.castPred hp).predAbove i) (i.pred hi)","decl":"lemma predAbove_castPred_of_lt (p i : Fin (n + 1)) (h : p < i) (hp := Fin.ne_last_of_lt h)\n  (hi := Fin.ne_zero_of_lt h) : (castPred p hp).predAbove i = pred i hi := by\n  rw [predAbove_of_castSucc_lt _ _ (castSucc_castPred _ _ ▸ h)]\n\n"}
{"name":"Fin.predAbove_castPred_of_le","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np i : Fin (HAdd.hAdd n 1)\nh : LE.le i p\nhp : Ne p (Fin.last n)\nhi : optParam (Ne i (Fin.last n)) ⋯\n⊢ Eq ((p.castPred hp).predAbove i) (i.castPred hi)","decl":"lemma predAbove_castPred_of_le (p i : Fin (n + 1)) (h : i ≤ p) (hp : p ≠ last n)\n    (hi := Fin.ne_of_lt <| Fin.lt_of_le_of_lt h <| Fin.lt_last_iff_ne_last.2 hp) :\n    (castPred p hp).predAbove i = castPred i hi := by\n  rw [predAbove_of_le_castSucc _ _ (castSucc_castPred _ _ ▸ h)]\n\n"}
{"name":"Fin.predAbove_castPred_self","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\nhp : Ne p (Fin.last n)\n⊢ Eq ((p.castPred hp).predAbove p) (p.castPred hp)","decl":"lemma predAbove_castPred_self (p : Fin (n + 1)) (hp : p ≠ last n) :\n    (castPred p hp).predAbove p = castPred p hp := predAbove_castPred_of_le _ _ Fin.le_rfl hp\n\n"}
{"name":"Fin.predAbove_right_zero","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\ni : Fin n\n⊢ Eq (i.predAbove 0) 0","decl":"@[simp] lemma predAbove_right_zero [NeZero n] {i : Fin n} : predAbove (i : Fin n) 0 = 0 := by\n  cases n\n  · exact i.elim0\n  · rw [predAbove_of_le_castSucc _ _ (zero_le _), castPred_zero]\n\n"}
{"name":"Fin.predAbove_zero_succ","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\ni : Fin n\n⊢ Eq (Fin.predAbove 0 i.succ) i","decl":"@[simp] lemma predAbove_zero_succ [NeZero n] {i : Fin n} : predAbove 0 i.succ = i := by\n  rw [predAbove_succ_of_le _ _ (Fin.zero_le' _)]\n\n"}
{"name":"Fin.succ_predAbove_zero","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\nj : Fin (HAdd.hAdd n 1)\nh : Ne j 0\n⊢ Eq (Fin.predAbove 0 j).succ j","decl":"@[simp]\nlemma succ_predAbove_zero [NeZero n] {j : Fin (n + 1)} (h : j ≠ 0) : succ (predAbove 0 j) = j := by\n  rcases exists_succ_eq_of_ne_zero h with ⟨k, rfl⟩\n  rw [predAbove_zero_succ]\n\n"}
{"name":"Fin.predAbove_zero_of_ne_zero","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\ni : Fin (HAdd.hAdd n 1)\nhi : Ne i 0\n⊢ Eq (Fin.predAbove 0 i) (i.pred hi)","decl":"@[simp] lemma predAbove_zero_of_ne_zero [NeZero n] {i : Fin (n + 1)} (hi : i ≠ 0) :\n    predAbove 0 i = i.pred hi := by\n  obtain ⟨y, rfl⟩ := exists_succ_eq.2 hi; exact predAbove_zero_succ\n\n"}
{"name":"Fin.predAbove_zero","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq (Fin.predAbove 0 i) (dite (Eq i 0) (fun hi => 0) fun hi => i.pred hi)","decl":"lemma predAbove_zero [NeZero n] {i : Fin (n + 1)} :\n    predAbove (0 : Fin n) i = if hi : i = 0 then 0 else i.pred hi := by\n  split_ifs with hi\n  · rw [hi, predAbove_right_zero]\n  · rw [predAbove_zero_of_ne_zero hi]\n\n"}
{"name":"Fin.predAbove_right_last","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq (i.predAbove (Fin.last (HAdd.hAdd n 1))) (Fin.last n)","decl":"@[simp] lemma predAbove_right_last {i : Fin (n + 1)} : predAbove i (last (n + 1)) = last n := by\n  rw [predAbove_of_castSucc_lt _ _ (castSucc_lt_last _), pred_last]\n\n"}
{"name":"Fin.predAbove_last_castSucc","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq ((Fin.last n).predAbove i.castSucc) i","decl":"@[simp] lemma predAbove_last_castSucc {i : Fin (n + 1)} : predAbove (last n) (i.castSucc) = i := by\n  rw [predAbove_of_le_castSucc _ _ (castSucc_le_castSucc_iff.mpr (le_last _)), castPred_castSucc]\n\n"}
{"name":"Fin.predAbove_last_of_ne_last","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 2)\nhi : Ne i (Fin.last (HAdd.hAdd n 1))\n⊢ Eq ((Fin.last n).predAbove i) (i.castPred hi)","decl":"@[simp] lemma predAbove_last_of_ne_last {i : Fin (n + 2)} (hi : i ≠ last (n + 1)) :\n    predAbove (last n) i = castPred i hi := by\n  rw [← exists_castSucc_eq] at hi\n  rcases hi with ⟨y, rfl⟩\n  exact predAbove_last_castSucc\n\n"}
{"name":"Fin.predAbove_last_apply","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 2)\n⊢ Eq ((Fin.last n).predAbove i) (dite (Eq i (Fin.last (HAdd.hAdd n 1))) (fun hi => Fin.last n) fun hi => i.castPred hi)","decl":"lemma predAbove_last_apply {i : Fin (n + 2)} :\n    predAbove (last n) i = if hi : i = last _ then last _ else i.castPred hi := by\n  split_ifs with hi\n  · rw [hi, predAbove_right_last]\n  · rw [predAbove_last_of_ne_last hi]\n\n"}
{"name":"Fin.succAbove_predAbove","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np : Fin n\ni : Fin (HAdd.hAdd n 1)\nh : Ne i p.castSucc\n⊢ Eq (p.castSucc.succAbove (p.predAbove i)) i","decl":"/-- Sending `Fin (n+1)` to `Fin n` by subtracting one from anything above `p`\nthen back to `Fin (n+1)` with a gap around `p` is the identity away from `p`. -/\n@[simp]\nlemma succAbove_predAbove {p : Fin n} {i : Fin (n + 1)} (h : i ≠ castSucc p) :\n    p.castSucc.succAbove (p.predAbove i) = i := by\n  obtain h | h := Fin.lt_or_lt_of_ne h\n  · rw [predAbove_of_le_castSucc _ _ (Fin.le_of_lt h), succAbove_castPred_of_lt _ _ h]\n  · rw [predAbove_of_castSucc_lt _ _ h, succAbove_pred_of_lt _ _ h]\n\n"}
{"name":"Fin.succ_succAbove_predAbove","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np : Fin n\ni : Fin (HAdd.hAdd n 1)\nh : Ne i p.succ\n⊢ Eq (p.succ.succAbove (p.predAbove i)) i","decl":"/-- Sending `Fin (n+1)` to `Fin n` by subtracting one from anything above `p`\nthen back to `Fin (n+1)` with a gap around `p.succ` is the identity away from `p.succ`. -/\n@[simp]\nlemma succ_succAbove_predAbove {n : ℕ} {p : Fin n} {i : Fin (n + 1)} (h : i ≠ p.succ) :\n    p.succ.succAbove (p.predAbove i) = i := by\n  obtain h | h := Fin.lt_or_lt_of_ne h\n  · rw [predAbove_of_le_castSucc _ _ (le_castSucc_iff.2 h),\n      succAbove_castPred_of_lt _ _ h]\n  · rw [predAbove_of_castSucc_lt _ _ (Fin.lt_of_le_of_lt (p.castSucc_le_succ) h),\n      succAbove_pred_of_lt _ _ h]\n\n"}
{"name":"Fin.predAbove_succAbove","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\np i : Fin n\n⊢ Eq (p.predAbove (p.castSucc.succAbove i)) i","decl":"/-- Sending `Fin n` into `Fin (n + 1)` with a gap at `p`\nthen back to `Fin n` by subtracting one from anything above `p` is the identity. -/\n@[simp]\nlemma predAbove_succAbove (p : Fin n) (i : Fin n) : p.predAbove ((castSucc p).succAbove i) = i := by\n  obtain h | h := p.le_or_lt i\n  · rw [succAbove_castSucc_of_le _ _ h, predAbove_succ_of_le _ _ h]\n  · rw [succAbove_castSucc_of_lt _ _ h, predAbove_castSucc_of_le _ _ <| Fin.le_of_lt h]\n\n"}
{"name":"Fin.succ_predAbove_succ","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na : Fin n\nb : Fin (HAdd.hAdd n 1)\n⊢ Eq (a.succ.predAbove b.succ) (a.predAbove b).succ","decl":"/-- `succ` commutes with `predAbove`. -/\n@[simp] lemma succ_predAbove_succ (a : Fin n) (b : Fin (n + 1)) :\n    a.succ.predAbove b.succ = (a.predAbove b).succ := by\n  obtain h | h := Fin.le_or_lt (succ a) b\n  · rw [predAbove_of_castSucc_lt _ _ h, predAbove_succ_of_le _ _ h, succ_pred]\n  · rw [predAbove_of_lt_succ _ _ h, predAbove_succ_of_lt _ _ h, succ_castPred_eq_castPred_succ]\n\n"}
{"name":"Fin.castSucc_predAbove_castSucc","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na : Fin n\nb : Fin (HAdd.hAdd n 1)\n⊢ Eq (a.castSucc.predAbove b.castSucc) (a.predAbove b).castSucc","decl":"/-- `castSucc` commutes with `predAbove`. -/\n@[simp] lemma castSucc_predAbove_castSucc {n : ℕ} (a : Fin n) (b : Fin (n + 1)) :\n    a.castSucc.predAbove b.castSucc = (a.predAbove b).castSucc := by\n  obtain h | h := a.castSucc.lt_or_le b\n  · rw [predAbove_of_castSucc_lt _ _ h, predAbove_castSucc_of_lt _ _ h,\n      castSucc_pred_eq_pred_castSucc]\n  · rw [predAbove_of_le_castSucc _ _ h, predAbove_castSucc_of_le _ _ h, castSucc_castPred]\n\n"}
{"name":"Fin.coe_divNat","module":"Mathlib.Data.Fin.Basic","initialProofState":"n m : Nat\ni : Fin (HMul.hMul m n)\n⊢ Eq (↑i.divNat) (HDiv.hDiv (↑i) n)","decl":"@[simp]\ntheorem coe_divNat (i : Fin (m * n)) : (i.divNat : ℕ) = i / n :=\n  rfl\n\n"}
{"name":"Fin.coe_modNat","module":"Mathlib.Data.Fin.Basic","initialProofState":"n m : Nat\ni : Fin (HMul.hMul m n)\n⊢ Eq (↑i.modNat) (HMod.hMod (↑i) n)","decl":"@[simp]\ntheorem coe_modNat (i : Fin (m * n)) : (i.modNat : ℕ) = i % n :=\n  rfl\n\n"}
{"name":"Fin.modNat_rev","module":"Mathlib.Data.Fin.Basic","initialProofState":"n m : Nat\ni : Fin (HMul.hMul m n)\n⊢ Eq i.rev.modNat i.modNat.rev","decl":"theorem modNat_rev (i : Fin (m * n)) : i.rev.modNat = i.modNat.rev := by\n  ext\n  have H₁ : i % n + 1 ≤ n := i.modNat.is_lt\n  have H₂ : i / n < m := i.divNat.is_lt\n  simp only [coe_modNat, val_rev]\n  calc\n    (m * n - (i + 1)) % n = (m * n - ((i / n) * n + i % n + 1)) % n := by rw [Nat.div_add_mod']\n    _ = ((m - i / n - 1) * n + (n - (i % n + 1))) % n := by\n      rw [Nat.mul_sub_right_distrib, Nat.one_mul, Nat.sub_add_sub_cancel _ H₁,\n        Nat.mul_sub_right_distrib, Nat.sub_sub, Nat.add_assoc]\n      exact Nat.le_mul_of_pos_left _ <| Nat.le_sub_of_add_le' H₂\n    _ = n - (i % n + 1) := by\n      rw [Nat.mul_comm, Nat.mul_add_mod, Nat.mod_eq_of_lt]; exact i.modNat.rev.is_lt\n\n"}
{"name":"Fin.liftFun_iff_succ","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\nα : Type u_1\nr : α → α → Prop\ninst✝ : IsTrans α r\nf : Fin (HAdd.hAdd n 1) → α\n⊢ Iff (Relator.LiftFun (fun x1 x2 => LT.lt x1 x2) r f f) (∀ (i : Fin n), r (f i.castSucc) (f i.succ))","decl":"theorem liftFun_iff_succ {α : Type*} (r : α → α → Prop) [IsTrans α r] {f : Fin (n + 1) → α} :\n    ((· < ·) ⇒ r) f f ↔ ∀ i : Fin n, r (f (castSucc i)) (f i.succ) := by\n  constructor\n  · intro H i\n    exact H i.castSucc_lt_succ\n  · refine fun H i => Fin.induction (fun h ↦ ?_) ?_\n    · simp [le_def] at h\n    · intro j ihj hij\n      rw [← le_castSucc_iff] at hij\n      obtain hij | hij := (le_def.1 hij).eq_or_lt\n      · obtain rfl := Fin.ext hij\n        exact H _\n      · exact _root_.trans (ihj hij) (H j)\n\n"}
{"name":"Fin.neg_def","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na : Fin n\n⊢ Eq (Neg.neg a) ⟨HMod.hMod (HSub.hSub n ↑a) n, ⋯⟩","decl":"theorem neg_def (a : Fin n) : -a = ⟨(n - a) % n, Nat.mod_lt _ a.pos⟩ := rfl\n\n"}
{"name":"Fin.coe_neg","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na : Fin n\n⊢ Eq (↑(Neg.neg a)) (HMod.hMod (HSub.hSub n ↑a) n)","decl":"protected theorem coe_neg (a : Fin n) : ((-a : Fin n) : ℕ) = (n - a) % n :=\n  rfl\n\n"}
{"name":"Fin.eq_zero","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Fin 1\n⊢ Eq n 0","decl":"theorem eq_zero (n : Fin 1) : n = 0 := Subsingleton.elim _ _\n\n"}
{"name":"Fin.coe_fin_one","module":"Mathlib.Data.Fin.Basic","initialProofState":"a : Fin 1\n⊢ Eq (↑a) 0","decl":"@[deprecated val_eq_zero (since := \"2024-09-18\")]\ntheorem coe_fin_one (a : Fin 1) : (a : ℕ) = 0 := by simp [Subsingleton.elim a 0]\n\n"}
{"name":"Fin.eq_one_of_neq_zero","module":"Mathlib.Data.Fin.Basic","initialProofState":"i : Fin 2\nhi : Ne i 0\n⊢ Eq i 1","decl":"lemma eq_one_of_neq_zero (i : Fin 2) (hi : i ≠ 0) : i = 1 := by\n  fin_omega\n\n"}
{"name":"Fin.coe_neg_one","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\n⊢ Eq (↑(-1)) n","decl":"@[simp]\ntheorem coe_neg_one : ↑(-1 : Fin (n + 1)) = n := by\n  cases n\n  · simp\n  rw [Fin.coe_neg, Fin.val_one, Nat.add_one_sub_one, Nat.mod_eq_of_lt]\n  constructor\n\n"}
{"name":"Fin.last_sub","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq (HSub.hSub (Fin.last n) i) i.rev","decl":"theorem last_sub (i : Fin (n + 1)) : last n - i = Fin.rev i :=\n  Fin.ext <| by rw [coe_sub_iff_le.2 i.le_last, val_last, val_rev, Nat.succ_sub_succ_eq_sub]\n\n"}
{"name":"Fin.add_one_le_of_lt","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin (HAdd.hAdd n 1)\nh : LT.lt a b\n⊢ LE.le (HAdd.hAdd a 1) b","decl":"theorem add_one_le_of_lt {n : ℕ} {a b : Fin (n + 1)} (h : a < b) : a + 1 ≤ b := by\n  cases n <;> fin_omega\n\n"}
{"name":"Fin.exists_eq_add_of_le","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin n\nh : LE.le a b\n⊢ Exists fun k => And (LE.le k b) (Eq b (HAdd.hAdd a k))","decl":"theorem exists_eq_add_of_le {n : ℕ} {a b : Fin n} (h : a ≤ b) : ∃ k ≤ b, b = a + k := by\n  obtain ⟨k, hk⟩ : ∃ k : ℕ, (b : ℕ) = a + k := Nat.exists_eq_add_of_le h\n  have hkb : k ≤ b := by omega\n  refine ⟨⟨k, hkb.trans_lt b.is_lt⟩, hkb, ?_⟩\n  simp [Fin.ext_iff, Fin.val_add, ← hk, Nat.mod_eq_of_lt b.is_lt]\n\n"}
{"name":"Fin.exists_eq_add_of_lt","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na b : Fin (HAdd.hAdd n 1)\nh : LT.lt a b\n⊢ Exists fun k => And (LT.lt k b) (And (LE.le (HAdd.hAdd k 1) b) (Eq b (HAdd.hAdd (HAdd.hAdd a k) 1)))","decl":"theorem exists_eq_add_of_lt {n : ℕ} {a b : Fin (n + 1)} (h : a < b) :\n    ∃ k < b, k + 1 ≤ b ∧ b = a + k + 1 := by\n  cases n\n  · omega\n  obtain ⟨k, hk⟩ : ∃ k : ℕ, (b : ℕ) = a + k + 1 := Nat.exists_eq_add_of_lt h\n  have hkb : k < b := by omega\n  refine ⟨⟨k, hkb.trans b.is_lt⟩, hkb, by fin_omega, ?_⟩\n  simp [Fin.ext_iff, Fin.val_add, ← hk, Nat.mod_eq_of_lt b.is_lt]\n\n"}
{"name":"Fin.pos_of_ne_zero","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\na : Fin (HAdd.hAdd n 1)\nh : Ne a 0\n⊢ LT.lt 0 a","decl":"lemma pos_of_ne_zero {n : ℕ} {a : Fin (n + 1)} (h : a ≠ 0) :\n    0 < a :=\n  Nat.pos_of_ne_zero (val_ne_of_ne h)\n\n"}
{"name":"Fin.sub_succ_le_sub_of_le","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\nu v : Fin (HAdd.hAdd n 2)\nh : LT.lt u v\n⊢ LT.lt (HSub.hSub v (HAdd.hAdd u 1)) (HSub.hSub v u)","decl":"lemma sub_succ_le_sub_of_le {n : ℕ} {u v : Fin (n + 2)} (h : u < v) : v - (u + 1) < v - u := by\n  fin_omega\n\n"}
{"name":"Fin.coe_natCast_eq_mod","module":"Mathlib.Data.Fin.Basic","initialProofState":"m n : Nat\ninst✝ : NeZero m\n⊢ Eq (↑↑n) (HMod.hMod n m)","decl":"@[simp]\ntheorem coe_natCast_eq_mod (m n : ℕ) [NeZero m] :\n    ((n : Fin m) : ℕ) = n % m :=\n  rfl\n\n"}
{"name":"Fin.coe_ofNat_eq_mod","module":"Mathlib.Data.Fin.Basic","initialProofState":"m n : Nat\ninst✝ : NeZero m\n⊢ Eq (↑(OfNat.ofNat n)) (HMod.hMod (OfNat.ofNat n) m)","decl":"theorem coe_ofNat_eq_mod (m n : ℕ) [NeZero m] :\n    ((ofNat(n) : Fin m) : ℕ) = ofNat(n) % m :=\n  rfl\n\n"}
{"name":"Fin.mul_one'","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\nk : Fin n\n⊢ Eq (HMul.hMul k 1) k","decl":"protected theorem mul_one' [NeZero n] (k : Fin n) : k * 1 = k := by\n  cases' n with n\n  · simp [eq_iff_true_of_subsingleton]\n  cases n\n  · simp [fin_one_eq_zero]\n  simp [Fin.ext_iff, mul_def, mod_eq_of_lt (is_lt k)]\n\n"}
{"name":"Fin.one_mul'","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\nk : Fin n\n⊢ Eq (HMul.hMul 1 k) k","decl":"protected theorem one_mul' [NeZero n] (k : Fin n) : (1 : Fin n) * k = k := by\n  rw [Fin.mul_comm, Fin.mul_one']\n\n"}
{"name":"Fin.mul_zero'","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\nk : Fin n\n⊢ Eq (HMul.hMul k 0) 0","decl":"protected theorem mul_zero' [NeZero n] (k : Fin n) : k * 0 = 0 := by simp [Fin.ext_iff, mul_def]\n\n"}
{"name":"Fin.zero_mul'","module":"Mathlib.Data.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\nk : Fin n\n⊢ Eq (HMul.hMul 0 k) 0","decl":"protected theorem zero_mul' [NeZero n] (k : Fin n) : (0 : Fin n) * k = 0 := by\n  simp [Fin.ext_iff, mul_def]\n\n"}
