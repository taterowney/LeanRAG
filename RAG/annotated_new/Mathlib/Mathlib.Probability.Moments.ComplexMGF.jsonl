{"name":"ProbabilityTheory.complexMGF_undef","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Œ© : Type u_1\nm : MeasurableSpace Œ©\nX : Œ© ‚Üí Real\nŒº : MeasureTheory.Measure Œ©\nz : Complex\nhX : AEMeasurable X Œº\nh : Not (MeasureTheory.Integrable (fun œâ => Real.exp (HMul.hMul z.re (X œâ))) Œº)\n‚ä¢ Eq (ProbabilityTheory.complexMGF X Œº z) 0","decl":"lemma complexMGF_undef (hX : AEMeasurable X Œº) (h : ¬¨ Integrable (fun œâ ‚Ü¶ rexp (z.re * X œâ)) Œº) :\n    complexMGF X Œº z = 0 := by\n  rw [complexMGF, integral_undef]\n  rw [‚Üê integrable_norm_iff (AEMeasurable.aestronglyMeasurable <| by fun_prop)]\n  simpa [Complex.norm_eq_abs, Complex.abs_exp] using h\n\n"}
{"name":"ProbabilityTheory.complexMGF_id_map","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Œ© : Type u_1\nm : MeasurableSpace Œ©\nX : Œ© ‚Üí Real\nŒº : MeasureTheory.Measure Œ©\nhX : AEMeasurable X Œº\n‚ä¢ Eq (ProbabilityTheory.complexMGF id (MeasureTheory.Measure.map X Œº)) (ProbabilityTheory.complexMGF X Œº)","decl":"lemma complexMGF_id_map (hX : AEMeasurable X Œº) : complexMGF id (Œº.map X) = complexMGF X Œº := by\n  ext t\n  rw [complexMGF, integral_map hX]\n  ¬∑ rfl\n  ¬∑ exact AEMeasurable.aestronglyMeasurable <| by fun_prop\n\n"}
{"name":"ProbabilityTheory.complexMGF_congr_identDistrib","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Œ© : Type u_1\nm : MeasurableSpace Œ©\nX : Œ© ‚Üí Real\nŒº : MeasureTheory.Measure Œ©\nŒ©' : Type u_3\nmŒ©' : MeasurableSpace Œ©'\nŒº' : MeasureTheory.Measure Œ©'\nY : Œ©' ‚Üí Real\nh : ProbabilityTheory.IdentDistrib X Y Œº Œº'\n‚ä¢ Eq (ProbabilityTheory.complexMGF X Œº) (ProbabilityTheory.complexMGF Y Œº')","decl":"lemma complexMGF_congr_identDistrib {Œ©' : Type*} {mŒ©' : MeasurableSpace Œ©'} {Œº' : Measure Œ©'}\n    {Y : Œ©' ‚Üí ‚Ñù}  (h : IdentDistrib X Y Œº Œº') :\n    complexMGF X Œº = complexMGF Y Œº' := by\n  rw [‚Üê complexMGF_id_map h.aemeasurable_fst, ‚Üê complexMGF_id_map h.aemeasurable_snd, h.map_eq]\n\n"}
{"name":"ProbabilityTheory.abs_complexMGF_le_mgf","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Œ© : Type u_1\nm : MeasurableSpace Œ©\nX : Œ© ‚Üí Real\nŒº : MeasureTheory.Measure Œ©\nz : Complex\n‚ä¢ LE.le (Complex.abs (ProbabilityTheory.complexMGF X Œº z)) (ProbabilityTheory.mgf X Œº z.re)","decl":"lemma abs_complexMGF_le_mgf : abs (complexMGF X Œº z) ‚â§ mgf X Œº z.re := by\n  rw [complexMGF, ‚Üê re_add_im z]\n  simp_rw [add_mul, Complex.exp_add, re_add_im, ‚Üê Complex.norm_eq_abs]\n  calc ‚Äñ‚à´ œâ, cexp (z.re * X œâ) * cexp (z.im * I * X œâ) ‚àÇŒº‚Äñ\n  _ ‚â§ ‚à´ œâ, ‚Äñcexp (z.re * X œâ) * cexp (z.im * I * X œâ)‚Äñ ‚àÇŒº := norm_integral_le_integral_norm _\n  _ = ‚à´ œâ, rexp (z.re * X œâ) ‚àÇŒº := by simp [Complex.abs_exp]\n\n"}
{"name":"ProbabilityTheory.complexMGF_ofReal","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Œ© : Type u_1\nm : MeasurableSpace Œ©\nX : Œ© ‚Üí Real\nŒº : MeasureTheory.Measure Œ©\nx : Real\n‚ä¢ Eq (ProbabilityTheory.complexMGF X Œº ‚Üëx) ‚Üë(ProbabilityTheory.mgf X Œº x)","decl":"lemma complexMGF_ofReal (x : ‚Ñù) : complexMGF X Œº x = mgf X Œº x := by\n  rw [complexMGF, mgf, ‚Üê integral_complex_ofReal]\n  norm_cast\n\n"}
{"name":"ProbabilityTheory.re_complexMGF_ofReal","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Œ© : Type u_1\nm : MeasurableSpace Œ©\nX : Œ© ‚Üí Real\nŒº : MeasureTheory.Measure Œ©\nx : Real\n‚ä¢ Eq (ProbabilityTheory.complexMGF X Œº ‚Üëx).re (ProbabilityTheory.mgf X Œº x)","decl":"lemma re_complexMGF_ofReal (x : ‚Ñù) : (complexMGF X Œº x).re = mgf X Œº x := by\n  simp [complexMGF_ofReal]\n\n"}
{"name":"ProbabilityTheory.re_complexMGF_ofReal'","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Œ© : Type u_1\nm : MeasurableSpace Œ©\nX : Œ© ‚Üí Real\nŒº : MeasureTheory.Measure Œ©\n‚ä¢ Eq (fun x => (ProbabilityTheory.complexMGF X Œº ‚Üëx).re) (ProbabilityTheory.mgf X Œº)","decl":"lemma re_complexMGF_ofReal' : (fun x : ‚Ñù ‚Ü¶ (complexMGF X Œº x).re) = mgf X Œº := by\n  ext x\n  exact re_complexMGF_ofReal x\n\n"}
{"name":"ProbabilityTheory.hasDerivAt_integral_pow_mul_exp","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Œ© : Type u_1\nm : MeasurableSpace Œ©\nX : Œ© ‚Üí Real\nŒº : MeasureTheory.Measure Œ©\nz : Complex\nhz : Membership.mem (interior (ProbabilityTheory.integrableExpSet X Œº)) z.re\nn : Nat\n‚ä¢ HasDerivAt (fun z => MeasureTheory.integral Œº fun x => (fun œâ => HMul.hMul (HPow.hPow (‚Üë(X œâ)) n) (Complex.exp (HMul.hMul z ‚Üë(X œâ)))) x) (MeasureTheory.integral Œº fun x => (fun œâ => HMul.hMul (HPow.hPow (‚Üë(X œâ)) (HAdd.hAdd n 1)) (Complex.exp (HMul.hMul z ‚Üë(X œâ)))) x) z","decl":"/-- For `z : ‚ÑÇ` with `z.re ‚àà interior (integrableExpSet X Œº)`, the derivative of the function\n`z' ‚Ü¶ Œº[X ^ n * cexp (z' * X)]` at `z` is `Œº[X ^ (n + 1) * cexp (z * X)]`. -/\nlemma hasDerivAt_integral_pow_mul_exp (hz : z.re ‚àà interior (integrableExpSet X Œº)) (n : ‚Ñï) :\n    HasDerivAt (fun z ‚Ü¶ Œº[fun œâ ‚Ü¶ X œâ ^ n * cexp (z * X œâ)])\n        Œº[fun œâ ‚Ü¶ X œâ ^ (n + 1) * cexp (z * X œâ)] z := by\n  have hX : AEMeasurable X Œº := aemeasurable_of_mem_interior_integrableExpSet hz\n  have hz' := hz\n  rw [mem_interior_iff_mem_nhds, mem_nhds_iff_exists_Ioo_subset] at hz'\n  obtain ‚ü®l, u, hlu, h_subset‚ü© := hz'\n  let t := ((z.re - l) ‚äì (u - z.re)) / 2\n  have h_pos : 0 < (z.re - l) ‚äì (u - z.re) := by simp [hlu.1, hlu.2]\n  have ht : 0 < t := half_pos h_pos\n  refine (hasDerivAt_integral_of_dominated_loc_of_deriv_le\n    (bound := fun œâ ‚Ü¶ |X œâ| ^ (n + 1) * rexp (z.re * X œâ + t/2 * |X œâ|))\n    (F := fun z œâ ‚Ü¶ X œâ ^ n * cexp (z * X œâ))\n    (F' := fun z œâ ‚Ü¶ X œâ ^ (n + 1) * cexp (z * X œâ)) (half_pos ht) ?_ ?_ ?_ ?_ ?_ ?_).2\n  ¬∑ exact .of_forall fun z ‚Ü¶ AEMeasurable.aestronglyMeasurable (by fun_prop)\n  ¬∑ exact integrable_pow_mul_cexp_of_re_mem_interior_integrableExpSet hz n\n  ¬∑ exact AEMeasurable.aestronglyMeasurable (by fun_prop)\n  ¬∑ refine ae_of_all _ fun œâ Œµ hŒµ ‚Ü¶ ?_\n    simp only [norm_mul, norm_pow, norm_real, Real.norm_eq_abs, Complex.norm_eq_abs]\n    rw [Complex.abs_ofReal, Complex.abs_exp]\n    simp only [mul_re, ofReal_re, ofReal_im, mul_zero, sub_zero]\n    gcongr\n    have : Œµ = z + (Œµ - z) := by simp\n    rw [this, add_re, add_mul]\n    gcongr _ + ?_\n    refine (le_abs_self _).trans ?_\n    rw [abs_mul]\n    gcongr\n    refine (abs_re_le_abs _).trans ?_\n    simp only [Metric.mem_ball, dist_eq_norm, Complex.norm_eq_abs] at hŒµ\n    exact hŒµ.le\n  ¬∑ refine integrable_pow_abs_mul_exp_add_of_integrable_exp_mul ?_ ?_ ?_ ?_ (t := t) (n + 1)\n    ¬∑ exact h_subset (add_half_inf_sub_mem_Ioo hlu)\n    ¬∑ exact h_subset (sub_half_inf_sub_mem_Ioo hlu)\n    ¬∑ positivity\n    ¬∑ exact lt_of_lt_of_le (by simp [ht]) (le_abs_self _)\n  ¬∑ refine ae_of_all _ fun œâ Œµ hŒµ ‚Ü¶ ?_\n    simp only\n    simp_rw [pow_succ, mul_assoc]\n    refine HasDerivAt.const_mul _ ?_\n    simp_rw [‚Üê smul_eq_mul, Complex.exp_eq_exp_‚ÑÇ]\n    convert hasDerivAt_exp_smul_const (X œâ : ‚ÑÇ) Œµ using 1\n    rw [smul_eq_mul, mul_comm]\n\n"}
{"name":"ProbabilityTheory.hasDerivAt_complexMGF","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Œ© : Type u_1\nm : MeasurableSpace Œ©\nX : Œ© ‚Üí Real\nŒº : MeasureTheory.Measure Œ©\nz : Complex\nhz : Membership.mem (interior (ProbabilityTheory.integrableExpSet X Œº)) z.re\n‚ä¢ HasDerivAt (ProbabilityTheory.complexMGF X Œº) (MeasureTheory.integral Œº fun x => (fun œâ => HMul.hMul (‚Üë(X œâ)) (Complex.exp (HMul.hMul z ‚Üë(X œâ)))) x) z","decl":"/-- For all `z : ‚ÑÇ` with `z.re ‚àà interior (integrableExpSet X Œº)`,\n`complexMGF X Œº` is differentiable at `z` with derivative `Œº[X * exp (z * X)]`. -/\ntheorem hasDerivAt_complexMGF (hz : z.re ‚àà interior (integrableExpSet X Œº)) :\n    HasDerivAt (complexMGF X Œº) Œº[fun œâ ‚Ü¶ X œâ * cexp (z * X œâ)] z := by\n  convert hasDerivAt_integral_pow_mul_exp hz 0\n  ¬∑ simp [complexMGF]\n  ¬∑ simp\n\n"}
{"name":"ProbabilityTheory.differentiableOn_complexMGF","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Œ© : Type u_1\nm : MeasurableSpace Œ©\nX : Œ© ‚Üí Real\nŒº : MeasureTheory.Measure Œ©\n‚ä¢ DifferentiableOn Complex (ProbabilityTheory.complexMGF X Œº) (setOf fun z => Membership.mem (interior (ProbabilityTheory.integrableExpSet X Œº)) z.re)","decl":"/-- `complexMGF X Œº` is holomorphic on the vertical strip\n`{z | z.re ‚àà interior (integrableExpSet X Œº)}`. -/\ntheorem differentiableOn_complexMGF :\n    DifferentiableOn ‚ÑÇ (complexMGF X Œº) {z | z.re ‚àà interior (integrableExpSet X Œº)} := by\n  intro z hz\n  have h := hasDerivAt_complexMGF hz\n  rw [hasDerivAt_iff_hasFDerivAt] at h\n  exact h.hasFDerivWithinAt.differentiableWithinAt\n\n"}
{"name":"ProbabilityTheory.analyticOnNhd_complexMGF","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Œ© : Type u_1\nm : MeasurableSpace Œ©\nX : Œ© ‚Üí Real\nŒº : MeasureTheory.Measure Œ©\n‚ä¢ AnalyticOnNhd Complex (ProbabilityTheory.complexMGF X Œº) (setOf fun z => Membership.mem (interior (ProbabilityTheory.integrableExpSet X Œº)) z.re)","decl":"theorem analyticOnNhd_complexMGF :\n    AnalyticOnNhd ‚ÑÇ (complexMGF X Œº) {z | z.re ‚àà interior (integrableExpSet X Œº)} :=\n  differentiableOn_complexMGF.analyticOnNhd (isOpen_interior.preimage Complex.continuous_re)\n\n"}
{"name":"ProbabilityTheory.analyticOn_complexMGF","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Œ© : Type u_1\nm : MeasurableSpace Œ©\nX : Œ© ‚Üí Real\nŒº : MeasureTheory.Measure Œ©\n‚ä¢ AnalyticOn Complex (ProbabilityTheory.complexMGF X Œº) (setOf fun z => Membership.mem (interior (ProbabilityTheory.integrableExpSet X Œº)) z.re)","decl":"/-- `complexMGF X Œº` is analytic on the vertical strip\n  `{z | z.re ‚àà interior (integrableExpSet X Œº)}`. -/\ntheorem analyticOn_complexMGF :\n    AnalyticOn ‚ÑÇ (complexMGF X Œº) {z | z.re ‚àà interior (integrableExpSet X Œº)} :=\n  analyticOnNhd_complexMGF.analyticOn\n\n"}
{"name":"ProbabilityTheory.analyticAt_complexMGF","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Œ© : Type u_1\nm : MeasurableSpace Œ©\nX : Œ© ‚Üí Real\nŒº : MeasureTheory.Measure Œ©\nz : Complex\nhz : Membership.mem (interior (ProbabilityTheory.integrableExpSet X Œº)) z.re\n‚ä¢ AnalyticAt Complex (ProbabilityTheory.complexMGF X Œº) z","decl":"/-- `complexMGF X Œº` is analytic at any point `z` with `z.re ‚àà interior (integrableExpSet X Œº)`. -/\nlemma analyticAt_complexMGF (hz : z.re ‚àà interior (integrableExpSet X Œº)) :\n    AnalyticAt ‚ÑÇ (complexMGF X Œº) z :=\n  analyticOnNhd_complexMGF z hz\n\n"}
{"name":"ProbabilityTheory.hasDerivAt_iteratedDeriv_complexMGF","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Œ© : Type u_1\nm : MeasurableSpace Œ©\nX : Œ© ‚Üí Real\nŒº : MeasureTheory.Measure Œ©\nz : Complex\nhz : Membership.mem (interior (ProbabilityTheory.integrableExpSet X Œº)) z.re\nn : Nat\n‚ä¢ HasDerivAt (iteratedDeriv n (ProbabilityTheory.complexMGF X Œº)) (MeasureTheory.integral Œº fun x => (fun œâ => HMul.hMul (HPow.hPow (‚Üë(X œâ)) (HAdd.hAdd n 1)) (Complex.exp (HMul.hMul z ‚Üë(X œâ)))) x) z","decl":"lemma hasDerivAt_iteratedDeriv_complexMGF (hz : z.re ‚àà interior (integrableExpSet X Œº)) (n : ‚Ñï) :\n    HasDerivAt (iteratedDeriv n (complexMGF X Œº)) Œº[fun œâ ‚Ü¶ X œâ ^ (n + 1) * cexp (z * X œâ)] z := by\n  induction n generalizing z with\n  | zero => simp [hasDerivAt_complexMGF hz]\n  | succ n hn =>\n    rw [iteratedDeriv_succ]\n    have : deriv (iteratedDeriv n (complexMGF X Œº))\n        =·∂†[ùìù z] fun z ‚Ü¶ Œº[fun œâ ‚Ü¶ X œâ ^ (n + 1) * cexp (z * X œâ)] := by\n      have h_mem : ‚àÄ·∂† y in ùìù z, y.re ‚àà interior (integrableExpSet X Œº) := by\n        refine IsOpen.eventually_mem ?_ hz\n        exact isOpen_interior.preimage Complex.continuous_re\n      filter_upwards [h_mem] with y hy using HasDerivAt.deriv (hn hy)\n    rw [EventuallyEq.hasDerivAt_iff this]\n    exact hasDerivAt_integral_pow_mul_exp hz (n + 1)\n\n"}
{"name":"ProbabilityTheory.iteratedDeriv_complexMGF","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Œ© : Type u_1\nm : MeasurableSpace Œ©\nX : Œ© ‚Üí Real\nŒº : MeasureTheory.Measure Œ©\nz : Complex\nhz : Membership.mem (interior (ProbabilityTheory.integrableExpSet X Œº)) z.re\nn : Nat\n‚ä¢ Eq (iteratedDeriv n (ProbabilityTheory.complexMGF X Œº) z) (MeasureTheory.integral Œº fun x => (fun œâ => HMul.hMul (HPow.hPow (‚Üë(X œâ)) n) (Complex.exp (HMul.hMul z ‚Üë(X œâ)))) x)","decl":"/-- For `z : ‚ÑÇ` with `z.re ‚àà interior (integrableExpSet X Œº)`, the n-th derivative of the function\n`complexMGF X Œº` at `z` is `Œº[X ^ n * cexp (z * X)]`. -/\nlemma iteratedDeriv_complexMGF (hz : z.re ‚àà interior (integrableExpSet X Œº)) (n : ‚Ñï) :\n    iteratedDeriv n (complexMGF X Œº) z = Œº[fun œâ ‚Ü¶ X œâ ^ n * cexp (z * X œâ)] := by\n  induction n generalizing z with\n  | zero => simp [complexMGF]\n  | succ n hn =>\n    rw [iteratedDeriv_succ]\n    exact (hasDerivAt_iteratedDeriv_complexMGF hz n).deriv\n\n"}
{"name":"ProbabilityTheory.integrableExpSet_eq_of_mgf'","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Œ© : Type u_1\nm : MeasurableSpace Œ©\nX : Œ© ‚Üí Real\nŒº : MeasureTheory.Measure Œ©\nŒ©' : Type u_3\nmŒ©' : MeasurableSpace Œ©'\nY : Œ©' ‚Üí Real\nŒº' : MeasureTheory.Measure Œ©'\nhXY : Eq (ProbabilityTheory.mgf X Œº) (ProbabilityTheory.mgf Y Œº')\nhŒºŒº' : Iff (Eq Œº 0) (Eq Œº' 0)\n‚ä¢ Eq (ProbabilityTheory.integrableExpSet X Œº) (ProbabilityTheory.integrableExpSet Y Œº')","decl":"/-- If two random variables have the same moment generating function then they have\nthe same `integrableExpSet`. -/\nlemma integrableExpSet_eq_of_mgf' (hXY : mgf X Œº = mgf Y Œº') (hŒºŒº' : Œº = 0 ‚Üî Œº' = 0) :\n    integrableExpSet X Œº = integrableExpSet Y Œº' := by\n  ext t\n  simp only [integrableExpSet, Set.mem_setOf_eq]\n  by_cases hŒº : Œº = 0\n  ¬∑ simp [hŒº, hŒºŒº'.mp hŒº]\n  have : NeZero Œº := ‚ü®hŒº‚ü©\n  have : NeZero Œº' := ‚ü®(not_iff_not.mpr hŒºŒº').mp hŒº‚ü©\n  rw [‚Üê mgf_pos_iff, ‚Üê mgf_pos_iff, hXY]\n\n"}
{"name":"ProbabilityTheory.integrableExpSet_eq_of_mgf","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Œ© : Type u_1\nm : MeasurableSpace Œ©\nX : Œ© ‚Üí Real\nŒº : MeasureTheory.Measure Œ©\nŒ©' : Type u_3\nmŒ©' : MeasurableSpace Œ©'\nY : Œ©' ‚Üí Real\nŒº' : MeasureTheory.Measure Œ©'\ninst‚úù : MeasureTheory.IsProbabilityMeasure Œº\nhXY : Eq (ProbabilityTheory.mgf X Œº) (ProbabilityTheory.mgf Y Œº')\n‚ä¢ Eq (ProbabilityTheory.integrableExpSet X Œº) (ProbabilityTheory.integrableExpSet Y Œº')","decl":"/-- If two random variables have the same moment generating function then they have\nthe same `integrableExpSet`. -/\nlemma integrableExpSet_eq_of_mgf [IsProbabilityMeasure Œº]\n    (hXY : mgf X Œº = mgf Y Œº') :\n    integrableExpSet X Œº = integrableExpSet Y Œº' := by\n  refine integrableExpSet_eq_of_mgf' hXY ?_\n  simp only [IsProbabilityMeasure.ne_zero, false_iff]\n  suffices mgf Y Œº' 0 ‚â† 0 by\n    intro h_contra\n    simp [h_contra] at this\n  rw [‚Üê hXY]\n  exact (mgf_pos (by simp)).ne'\n\n"}
{"name":"ProbabilityTheory.eqOn_complexMGF_of_mgf'","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Œ© : Type u_1\nm : MeasurableSpace Œ©\nX : Œ© ‚Üí Real\nŒº : MeasureTheory.Measure Œ©\nŒ©' : Type u_3\nmŒ©' : MeasurableSpace Œ©'\nY : Œ©' ‚Üí Real\nŒº' : MeasureTheory.Measure Œ©'\nhXY : Eq (ProbabilityTheory.mgf X Œº) (ProbabilityTheory.mgf Y Œº')\nhŒºŒº' : Iff (Eq Œº 0) (Eq Œº' 0)\n‚ä¢ Set.EqOn (ProbabilityTheory.complexMGF X Œº) (ProbabilityTheory.complexMGF Y Œº') (setOf fun z => Membership.mem (interior (ProbabilityTheory.integrableExpSet X Œº)) z.re)","decl":"/-- If two random variables have the same moment generating function then they have\nthe same `complexMGF` on the vertical strip `{z | z.re ‚àà interior (integrableExpSet X Œº)}`.\n\nTODO: once we know that equal `mgf` implies equal distributions, we will be able to show that\nthe `complexMGF` are equal everywhere, not only on the strip.\nThis lemma will be used in the proof of the equality of distributions. -/\nlemma eqOn_complexMGF_of_mgf' (hXY : mgf X Œº = mgf Y Œº') (hŒºŒº' : Œº = 0 ‚Üî Œº' = 0) :\n    Set.EqOn (complexMGF X Œº) (complexMGF Y Œº') {z | z.re ‚àà interior (integrableExpSet X Œº)} := by\n  by_cases h_empty : interior (integrableExpSet X Œº) = ‚àÖ\n  ¬∑ simp [h_empty]\n  rw [‚Üê ne_eq, ‚Üê Set.nonempty_iff_ne_empty] at h_empty\n  obtain ‚ü®t, ht‚ü© := h_empty\n  have hX : AnalyticOnNhd ‚ÑÇ (complexMGF X Œº) {z | z.re ‚àà interior (integrableExpSet X Œº)} :=\n    analyticOnNhd_complexMGF\n  have hY : AnalyticOnNhd ‚ÑÇ (complexMGF Y Œº') {z | z.re ‚àà interior (integrableExpSet Y Œº')} :=\n    analyticOnNhd_complexMGF\n  rw [integrableExpSet_eq_of_mgf' hXY hŒºŒº'] at hX ht ‚ä¢\n  refine AnalyticOnNhd.eqOn_of_preconnected_of_frequently_eq hX hY\n    (convex_integrableExpSet.interior.linear_preimage reLm).isPreconnected\n    (z‚ÇÄ := (t : ‚ÑÇ)) (by simp [ht]) ?_\n  have h_real : ‚àÉ·∂† (x : ‚Ñù) in ùìù[‚â†] t, complexMGF X Œº x = complexMGF Y Œº' x := by\n    refine .of_forall fun y ‚Ü¶ ?_\n    rw [complexMGF_ofReal, complexMGF_ofReal, hXY]\n  rw [frequently_iff_seq_forall] at h_real ‚ä¢\n  obtain ‚ü®xs, hx_tendsto, hx_eq‚ü© := h_real\n  refine ‚ü®fun n ‚Ü¶ xs n, ?_, fun n ‚Ü¶ ?_‚ü©\n  ¬∑ rw [tendsto_nhdsWithin_iff] at hx_tendsto ‚ä¢\n    constructor\n    ¬∑ rw [tendsto_ofReal_iff]\n      exact hx_tendsto.1\n    ¬∑ simpa using hx_tendsto.2\n  ¬∑ simp [hx_eq]\n\n"}
{"name":"ProbabilityTheory.eqOn_complexMGF_of_mgf","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Œ© : Type u_1\nm : MeasurableSpace Œ©\nX : Œ© ‚Üí Real\nŒº : MeasureTheory.Measure Œ©\nŒ©' : Type u_3\nmŒ©' : MeasurableSpace Œ©'\nY : Œ©' ‚Üí Real\nŒº' : MeasureTheory.Measure Œ©'\ninst‚úù : MeasureTheory.IsProbabilityMeasure Œº\nhXY : Eq (ProbabilityTheory.mgf X Œº) (ProbabilityTheory.mgf Y Œº')\n‚ä¢ Set.EqOn (ProbabilityTheory.complexMGF X Œº) (ProbabilityTheory.complexMGF Y Œº') (setOf fun z => Membership.mem (interior (ProbabilityTheory.integrableExpSet X Œº)) z.re)","decl":"/-- If two random variables have the same moment generating function then they have\nthe same `complexMGF` on the vertical strip `{z | z.re ‚àà interior (integrableExpSet X Œº)}`. -/\nlemma eqOn_complexMGF_of_mgf [IsProbabilityMeasure Œº]\n    (hXY : mgf X Œº = mgf Y Œº') :\n    Set.EqOn (complexMGF X Œº) (complexMGF Y Œº') {z | z.re ‚àà interior (integrableExpSet X Œº)} := by\n  refine eqOn_complexMGF_of_mgf' hXY ?_\n  simp only [IsProbabilityMeasure.ne_zero, false_iff]\n  suffices mgf Y Œº' 0 ‚â† 0 by\n    intro h_contra\n    simp [h_contra] at this\n  rw [‚Üê hXY]\n  exact (mgf_pos (by simp)).ne'\n\n"}
