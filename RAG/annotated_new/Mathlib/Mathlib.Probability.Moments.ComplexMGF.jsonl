{"name":"ProbabilityTheory.complexMGF_undef","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nz : Complex\nhX : AEMeasurable X μ\nh : Not (MeasureTheory.Integrable (fun ω => Real.exp (HMul.hMul z.re (X ω))) μ)\n⊢ Eq (ProbabilityTheory.complexMGF X μ z) 0","decl":"lemma complexMGF_undef (hX : AEMeasurable X μ) (h : ¬ Integrable (fun ω ↦ rexp (z.re * X ω)) μ) :\n    complexMGF X μ z = 0 := by\n  rw [complexMGF, integral_undef]\n  rw [← integrable_norm_iff (AEMeasurable.aestronglyMeasurable <| by fun_prop)]\n  simpa [Complex.norm_eq_abs, Complex.abs_exp] using h\n\n"}
{"name":"ProbabilityTheory.complexMGF_id_map","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nhX : AEMeasurable X μ\n⊢ Eq (ProbabilityTheory.complexMGF id (MeasureTheory.Measure.map X μ)) (ProbabilityTheory.complexMGF X μ)","decl":"lemma complexMGF_id_map (hX : AEMeasurable X μ) : complexMGF id (μ.map X) = complexMGF X μ := by\n  ext t\n  rw [complexMGF, integral_map hX]\n  · rfl\n  · exact AEMeasurable.aestronglyMeasurable <| by fun_prop\n\n"}
{"name":"ProbabilityTheory.complexMGF_congr_identDistrib","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nΩ' : Type u_3\nmΩ' : MeasurableSpace Ω'\nμ' : MeasureTheory.Measure Ω'\nY : Ω' → Real\nh : ProbabilityTheory.IdentDistrib X Y μ μ'\n⊢ Eq (ProbabilityTheory.complexMGF X μ) (ProbabilityTheory.complexMGF Y μ')","decl":"lemma complexMGF_congr_identDistrib {Ω' : Type*} {mΩ' : MeasurableSpace Ω'} {μ' : Measure Ω'}\n    {Y : Ω' → ℝ}  (h : IdentDistrib X Y μ μ') :\n    complexMGF X μ = complexMGF Y μ' := by\n  rw [← complexMGF_id_map h.aemeasurable_fst, ← complexMGF_id_map h.aemeasurable_snd, h.map_eq]\n\n"}
{"name":"ProbabilityTheory.abs_complexMGF_le_mgf","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nz : Complex\n⊢ LE.le (Complex.abs (ProbabilityTheory.complexMGF X μ z)) (ProbabilityTheory.mgf X μ z.re)","decl":"lemma abs_complexMGF_le_mgf : abs (complexMGF X μ z) ≤ mgf X μ z.re := by\n  rw [complexMGF, ← re_add_im z]\n  simp_rw [add_mul, Complex.exp_add, re_add_im, ← Complex.norm_eq_abs]\n  calc ‖∫ ω, cexp (z.re * X ω) * cexp (z.im * I * X ω) ∂μ‖\n  _ ≤ ∫ ω, ‖cexp (z.re * X ω) * cexp (z.im * I * X ω)‖ ∂μ := norm_integral_le_integral_norm _\n  _ = ∫ ω, rexp (z.re * X ω) ∂μ := by simp [Complex.abs_exp]\n\n"}
{"name":"ProbabilityTheory.complexMGF_ofReal","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nx : Real\n⊢ Eq (ProbabilityTheory.complexMGF X μ ↑x) ↑(ProbabilityTheory.mgf X μ x)","decl":"lemma complexMGF_ofReal (x : ℝ) : complexMGF X μ x = mgf X μ x := by\n  rw [complexMGF, mgf, ← integral_complex_ofReal]\n  norm_cast\n\n"}
{"name":"ProbabilityTheory.re_complexMGF_ofReal","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nx : Real\n⊢ Eq (ProbabilityTheory.complexMGF X μ ↑x).re (ProbabilityTheory.mgf X μ x)","decl":"lemma re_complexMGF_ofReal (x : ℝ) : (complexMGF X μ x).re = mgf X μ x := by\n  simp [complexMGF_ofReal]\n\n"}
{"name":"ProbabilityTheory.re_complexMGF_ofReal'","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\n⊢ Eq (fun x => (ProbabilityTheory.complexMGF X μ ↑x).re) (ProbabilityTheory.mgf X μ)","decl":"lemma re_complexMGF_ofReal' : (fun x : ℝ ↦ (complexMGF X μ x).re) = mgf X μ := by\n  ext x\n  exact re_complexMGF_ofReal x\n\n"}
{"name":"ProbabilityTheory.hasDerivAt_integral_pow_mul_exp","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nz : Complex\nhz : Membership.mem (interior (ProbabilityTheory.integrableExpSet X μ)) z.re\nn : Nat\n⊢ HasDerivAt (fun z => MeasureTheory.integral μ fun x => (fun ω => HMul.hMul (HPow.hPow (↑(X ω)) n) (Complex.exp (HMul.hMul z ↑(X ω)))) x) (MeasureTheory.integral μ fun x => (fun ω => HMul.hMul (HPow.hPow (↑(X ω)) (HAdd.hAdd n 1)) (Complex.exp (HMul.hMul z ↑(X ω)))) x) z","decl":"/-- For `z : ℂ` with `z.re ∈ interior (integrableExpSet X μ)`, the derivative of the function\n`z' ↦ μ[X ^ n * cexp (z' * X)]` at `z` is `μ[X ^ (n + 1) * cexp (z * X)]`. -/\nlemma hasDerivAt_integral_pow_mul_exp (hz : z.re ∈ interior (integrableExpSet X μ)) (n : ℕ) :\n    HasDerivAt (fun z ↦ μ[fun ω ↦ X ω ^ n * cexp (z * X ω)])\n        μ[fun ω ↦ X ω ^ (n + 1) * cexp (z * X ω)] z := by\n  have hX : AEMeasurable X μ := aemeasurable_of_mem_interior_integrableExpSet hz\n  have hz' := hz\n  rw [mem_interior_iff_mem_nhds, mem_nhds_iff_exists_Ioo_subset] at hz'\n  obtain ⟨l, u, hlu, h_subset⟩ := hz'\n  let t := ((z.re - l) ⊓ (u - z.re)) / 2\n  have h_pos : 0 < (z.re - l) ⊓ (u - z.re) := by simp [hlu.1, hlu.2]\n  have ht : 0 < t := half_pos h_pos\n  refine (hasDerivAt_integral_of_dominated_loc_of_deriv_le\n    (bound := fun ω ↦ |X ω| ^ (n + 1) * rexp (z.re * X ω + t/2 * |X ω|))\n    (F := fun z ω ↦ X ω ^ n * cexp (z * X ω))\n    (F' := fun z ω ↦ X ω ^ (n + 1) * cexp (z * X ω)) (half_pos ht) ?_ ?_ ?_ ?_ ?_ ?_).2\n  · exact .of_forall fun z ↦ AEMeasurable.aestronglyMeasurable (by fun_prop)\n  · exact integrable_pow_mul_cexp_of_re_mem_interior_integrableExpSet hz n\n  · exact AEMeasurable.aestronglyMeasurable (by fun_prop)\n  · refine ae_of_all _ fun ω ε hε ↦ ?_\n    simp only [norm_mul, norm_pow, norm_real, Real.norm_eq_abs, Complex.norm_eq_abs]\n    rw [Complex.abs_ofReal, Complex.abs_exp]\n    simp only [mul_re, ofReal_re, ofReal_im, mul_zero, sub_zero]\n    gcongr\n    have : ε = z + (ε - z) := by simp\n    rw [this, add_re, add_mul]\n    gcongr _ + ?_\n    refine (le_abs_self _).trans ?_\n    rw [abs_mul]\n    gcongr\n    refine (abs_re_le_abs _).trans ?_\n    simp only [Metric.mem_ball, dist_eq_norm, Complex.norm_eq_abs] at hε\n    exact hε.le\n  · refine integrable_pow_abs_mul_exp_add_of_integrable_exp_mul ?_ ?_ ?_ ?_ (t := t) (n + 1)\n    · exact h_subset (add_half_inf_sub_mem_Ioo hlu)\n    · exact h_subset (sub_half_inf_sub_mem_Ioo hlu)\n    · positivity\n    · exact lt_of_lt_of_le (by simp [ht]) (le_abs_self _)\n  · refine ae_of_all _ fun ω ε hε ↦ ?_\n    simp only\n    simp_rw [pow_succ, mul_assoc]\n    refine HasDerivAt.const_mul _ ?_\n    simp_rw [← smul_eq_mul, Complex.exp_eq_exp_ℂ]\n    convert hasDerivAt_exp_smul_const (X ω : ℂ) ε using 1\n    rw [smul_eq_mul, mul_comm]\n\n"}
{"name":"ProbabilityTheory.hasDerivAt_complexMGF","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nz : Complex\nhz : Membership.mem (interior (ProbabilityTheory.integrableExpSet X μ)) z.re\n⊢ HasDerivAt (ProbabilityTheory.complexMGF X μ) (MeasureTheory.integral μ fun x => (fun ω => HMul.hMul (↑(X ω)) (Complex.exp (HMul.hMul z ↑(X ω)))) x) z","decl":"/-- For all `z : ℂ` with `z.re ∈ interior (integrableExpSet X μ)`,\n`complexMGF X μ` is differentiable at `z` with derivative `μ[X * exp (z * X)]`. -/\ntheorem hasDerivAt_complexMGF (hz : z.re ∈ interior (integrableExpSet X μ)) :\n    HasDerivAt (complexMGF X μ) μ[fun ω ↦ X ω * cexp (z * X ω)] z := by\n  convert hasDerivAt_integral_pow_mul_exp hz 0\n  · simp [complexMGF]\n  · simp\n\n"}
{"name":"ProbabilityTheory.differentiableOn_complexMGF","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\n⊢ DifferentiableOn Complex (ProbabilityTheory.complexMGF X μ) (setOf fun z => Membership.mem (interior (ProbabilityTheory.integrableExpSet X μ)) z.re)","decl":"/-- `complexMGF X μ` is holomorphic on the vertical strip\n`{z | z.re ∈ interior (integrableExpSet X μ)}`. -/\ntheorem differentiableOn_complexMGF :\n    DifferentiableOn ℂ (complexMGF X μ) {z | z.re ∈ interior (integrableExpSet X μ)} := by\n  intro z hz\n  have h := hasDerivAt_complexMGF hz\n  rw [hasDerivAt_iff_hasFDerivAt] at h\n  exact h.hasFDerivWithinAt.differentiableWithinAt\n\n"}
{"name":"ProbabilityTheory.analyticOnNhd_complexMGF","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\n⊢ AnalyticOnNhd Complex (ProbabilityTheory.complexMGF X μ) (setOf fun z => Membership.mem (interior (ProbabilityTheory.integrableExpSet X μ)) z.re)","decl":"theorem analyticOnNhd_complexMGF :\n    AnalyticOnNhd ℂ (complexMGF X μ) {z | z.re ∈ interior (integrableExpSet X μ)} :=\n  differentiableOn_complexMGF.analyticOnNhd (isOpen_interior.preimage Complex.continuous_re)\n\n"}
{"name":"ProbabilityTheory.analyticOn_complexMGF","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\n⊢ AnalyticOn Complex (ProbabilityTheory.complexMGF X μ) (setOf fun z => Membership.mem (interior (ProbabilityTheory.integrableExpSet X μ)) z.re)","decl":"/-- `complexMGF X μ` is analytic on the vertical strip\n  `{z | z.re ∈ interior (integrableExpSet X μ)}`. -/\ntheorem analyticOn_complexMGF :\n    AnalyticOn ℂ (complexMGF X μ) {z | z.re ∈ interior (integrableExpSet X μ)} :=\n  analyticOnNhd_complexMGF.analyticOn\n\n"}
{"name":"ProbabilityTheory.analyticAt_complexMGF","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nz : Complex\nhz : Membership.mem (interior (ProbabilityTheory.integrableExpSet X μ)) z.re\n⊢ AnalyticAt Complex (ProbabilityTheory.complexMGF X μ) z","decl":"/-- `complexMGF X μ` is analytic at any point `z` with `z.re ∈ interior (integrableExpSet X μ)`. -/\nlemma analyticAt_complexMGF (hz : z.re ∈ interior (integrableExpSet X μ)) :\n    AnalyticAt ℂ (complexMGF X μ) z :=\n  analyticOnNhd_complexMGF z hz\n\n"}
{"name":"ProbabilityTheory.hasDerivAt_iteratedDeriv_complexMGF","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nz : Complex\nhz : Membership.mem (interior (ProbabilityTheory.integrableExpSet X μ)) z.re\nn : Nat\n⊢ HasDerivAt (iteratedDeriv n (ProbabilityTheory.complexMGF X μ)) (MeasureTheory.integral μ fun x => (fun ω => HMul.hMul (HPow.hPow (↑(X ω)) (HAdd.hAdd n 1)) (Complex.exp (HMul.hMul z ↑(X ω)))) x) z","decl":"lemma hasDerivAt_iteratedDeriv_complexMGF (hz : z.re ∈ interior (integrableExpSet X μ)) (n : ℕ) :\n    HasDerivAt (iteratedDeriv n (complexMGF X μ)) μ[fun ω ↦ X ω ^ (n + 1) * cexp (z * X ω)] z := by\n  induction n generalizing z with\n  | zero => simp [hasDerivAt_complexMGF hz]\n  | succ n hn =>\n    rw [iteratedDeriv_succ]\n    have : deriv (iteratedDeriv n (complexMGF X μ))\n        =ᶠ[𝓝 z] fun z ↦ μ[fun ω ↦ X ω ^ (n + 1) * cexp (z * X ω)] := by\n      have h_mem : ∀ᶠ y in 𝓝 z, y.re ∈ interior (integrableExpSet X μ) := by\n        refine IsOpen.eventually_mem ?_ hz\n        exact isOpen_interior.preimage Complex.continuous_re\n      filter_upwards [h_mem] with y hy using HasDerivAt.deriv (hn hy)\n    rw [EventuallyEq.hasDerivAt_iff this]\n    exact hasDerivAt_integral_pow_mul_exp hz (n + 1)\n\n"}
{"name":"ProbabilityTheory.iteratedDeriv_complexMGF","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nz : Complex\nhz : Membership.mem (interior (ProbabilityTheory.integrableExpSet X μ)) z.re\nn : Nat\n⊢ Eq (iteratedDeriv n (ProbabilityTheory.complexMGF X μ) z) (MeasureTheory.integral μ fun x => (fun ω => HMul.hMul (HPow.hPow (↑(X ω)) n) (Complex.exp (HMul.hMul z ↑(X ω)))) x)","decl":"/-- For `z : ℂ` with `z.re ∈ interior (integrableExpSet X μ)`, the n-th derivative of the function\n`complexMGF X μ` at `z` is `μ[X ^ n * cexp (z * X)]`. -/\nlemma iteratedDeriv_complexMGF (hz : z.re ∈ interior (integrableExpSet X μ)) (n : ℕ) :\n    iteratedDeriv n (complexMGF X μ) z = μ[fun ω ↦ X ω ^ n * cexp (z * X ω)] := by\n  induction n generalizing z with\n  | zero => simp [complexMGF]\n  | succ n hn =>\n    rw [iteratedDeriv_succ]\n    exact (hasDerivAt_iteratedDeriv_complexMGF hz n).deriv\n\n"}
{"name":"ProbabilityTheory.integrableExpSet_eq_of_mgf'","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nΩ' : Type u_3\nmΩ' : MeasurableSpace Ω'\nY : Ω' → Real\nμ' : MeasureTheory.Measure Ω'\nhXY : Eq (ProbabilityTheory.mgf X μ) (ProbabilityTheory.mgf Y μ')\nhμμ' : Iff (Eq μ 0) (Eq μ' 0)\n⊢ Eq (ProbabilityTheory.integrableExpSet X μ) (ProbabilityTheory.integrableExpSet Y μ')","decl":"/-- If two random variables have the same moment generating function then they have\nthe same `integrableExpSet`. -/\nlemma integrableExpSet_eq_of_mgf' (hXY : mgf X μ = mgf Y μ') (hμμ' : μ = 0 ↔ μ' = 0) :\n    integrableExpSet X μ = integrableExpSet Y μ' := by\n  ext t\n  simp only [integrableExpSet, Set.mem_setOf_eq]\n  by_cases hμ : μ = 0\n  · simp [hμ, hμμ'.mp hμ]\n  have : NeZero μ := ⟨hμ⟩\n  have : NeZero μ' := ⟨(not_iff_not.mpr hμμ').mp hμ⟩\n  rw [← mgf_pos_iff, ← mgf_pos_iff, hXY]\n\n"}
{"name":"ProbabilityTheory.integrableExpSet_eq_of_mgf","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nΩ' : Type u_3\nmΩ' : MeasurableSpace Ω'\nY : Ω' → Real\nμ' : MeasureTheory.Measure Ω'\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nhXY : Eq (ProbabilityTheory.mgf X μ) (ProbabilityTheory.mgf Y μ')\n⊢ Eq (ProbabilityTheory.integrableExpSet X μ) (ProbabilityTheory.integrableExpSet Y μ')","decl":"/-- If two random variables have the same moment generating function then they have\nthe same `integrableExpSet`. -/\nlemma integrableExpSet_eq_of_mgf [IsProbabilityMeasure μ]\n    (hXY : mgf X μ = mgf Y μ') :\n    integrableExpSet X μ = integrableExpSet Y μ' := by\n  refine integrableExpSet_eq_of_mgf' hXY ?_\n  simp only [IsProbabilityMeasure.ne_zero, false_iff]\n  suffices mgf Y μ' 0 ≠ 0 by\n    intro h_contra\n    simp [h_contra] at this\n  rw [← hXY]\n  exact (mgf_pos (by simp)).ne'\n\n"}
{"name":"ProbabilityTheory.eqOn_complexMGF_of_mgf'","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nΩ' : Type u_3\nmΩ' : MeasurableSpace Ω'\nY : Ω' → Real\nμ' : MeasureTheory.Measure Ω'\nhXY : Eq (ProbabilityTheory.mgf X μ) (ProbabilityTheory.mgf Y μ')\nhμμ' : Iff (Eq μ 0) (Eq μ' 0)\n⊢ Set.EqOn (ProbabilityTheory.complexMGF X μ) (ProbabilityTheory.complexMGF Y μ') (setOf fun z => Membership.mem (interior (ProbabilityTheory.integrableExpSet X μ)) z.re)","decl":"/-- If two random variables have the same moment generating function then they have\nthe same `complexMGF` on the vertical strip `{z | z.re ∈ interior (integrableExpSet X μ)}`.\n\nTODO: once we know that equal `mgf` implies equal distributions, we will be able to show that\nthe `complexMGF` are equal everywhere, not only on the strip.\nThis lemma will be used in the proof of the equality of distributions. -/\nlemma eqOn_complexMGF_of_mgf' (hXY : mgf X μ = mgf Y μ') (hμμ' : μ = 0 ↔ μ' = 0) :\n    Set.EqOn (complexMGF X μ) (complexMGF Y μ') {z | z.re ∈ interior (integrableExpSet X μ)} := by\n  by_cases h_empty : interior (integrableExpSet X μ) = ∅\n  · simp [h_empty]\n  rw [← ne_eq, ← Set.nonempty_iff_ne_empty] at h_empty\n  obtain ⟨t, ht⟩ := h_empty\n  have hX : AnalyticOnNhd ℂ (complexMGF X μ) {z | z.re ∈ interior (integrableExpSet X μ)} :=\n    analyticOnNhd_complexMGF\n  have hY : AnalyticOnNhd ℂ (complexMGF Y μ') {z | z.re ∈ interior (integrableExpSet Y μ')} :=\n    analyticOnNhd_complexMGF\n  rw [integrableExpSet_eq_of_mgf' hXY hμμ'] at hX ht ⊢\n  refine AnalyticOnNhd.eqOn_of_preconnected_of_frequently_eq hX hY\n    (convex_integrableExpSet.interior.linear_preimage reLm).isPreconnected\n    (z₀ := (t : ℂ)) (by simp [ht]) ?_\n  have h_real : ∃ᶠ (x : ℝ) in 𝓝[≠] t, complexMGF X μ x = complexMGF Y μ' x := by\n    refine .of_forall fun y ↦ ?_\n    rw [complexMGF_ofReal, complexMGF_ofReal, hXY]\n  rw [frequently_iff_seq_forall] at h_real ⊢\n  obtain ⟨xs, hx_tendsto, hx_eq⟩ := h_real\n  refine ⟨fun n ↦ xs n, ?_, fun n ↦ ?_⟩\n  · rw [tendsto_nhdsWithin_iff] at hx_tendsto ⊢\n    constructor\n    · rw [tendsto_ofReal_iff]\n      exact hx_tendsto.1\n    · simpa using hx_tendsto.2\n  · simp [hx_eq]\n\n"}
{"name":"ProbabilityTheory.eqOn_complexMGF_of_mgf","module":"Mathlib.Probability.Moments.ComplexMGF","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nΩ' : Type u_3\nmΩ' : MeasurableSpace Ω'\nY : Ω' → Real\nμ' : MeasureTheory.Measure Ω'\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nhXY : Eq (ProbabilityTheory.mgf X μ) (ProbabilityTheory.mgf Y μ')\n⊢ Set.EqOn (ProbabilityTheory.complexMGF X μ) (ProbabilityTheory.complexMGF Y μ') (setOf fun z => Membership.mem (interior (ProbabilityTheory.integrableExpSet X μ)) z.re)","decl":"/-- If two random variables have the same moment generating function then they have\nthe same `complexMGF` on the vertical strip `{z | z.re ∈ interior (integrableExpSet X μ)}`. -/\nlemma eqOn_complexMGF_of_mgf [IsProbabilityMeasure μ]\n    (hXY : mgf X μ = mgf Y μ') :\n    Set.EqOn (complexMGF X μ) (complexMGF Y μ') {z | z.re ∈ interior (integrableExpSet X μ)} := by\n  refine eqOn_complexMGF_of_mgf' hXY ?_\n  simp only [IsProbabilityMeasure.ne_zero, false_iff]\n  suffices mgf Y μ' 0 ≠ 0 by\n    intro h_contra\n    simp [h_contra] at this\n  rw [← hXY]\n  exact (mgf_pos (by simp)).ne'\n\n"}
