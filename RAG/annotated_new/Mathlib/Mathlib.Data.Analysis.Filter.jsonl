{"name":"CFilter.mk.sizeOf_spec","module":"Mathlib.Data.Analysis.Filter","initialProofState":"α : Type u_1\nσ : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : SizeOf α\ninst✝ : SizeOf σ\nf : σ → α\npt : σ\ninf : σ → σ → σ\ninf_le_left : ∀ (a b : σ), LE.le (f (inf a b)) (f a)\ninf_le_right : ∀ (a b : σ), LE.le (f (inf a b)) (f b)\n⊢ Eq (SizeOf.sizeOf { f := f, pt := pt, inf := inf, inf_le_left := inf_le_left, inf_le_right := inf_le_right }) (HAdd.hAdd 1 (SizeOf.sizeOf pt))","decl":"/-- A `CFilter α σ` is a realization of a filter (base) on `α`,\n  represented by a type `σ` together with operations for the top element and\n  the binary `inf` operation. -/\nstructure CFilter (α σ : Type*) [PartialOrder α] where\n  f : σ → α\n  pt : σ\n  inf : σ → σ → σ\n  inf_le_left : ∀ a b : σ, f (inf a b) ≤ f a\n  inf_le_right : ∀ a b : σ, f (inf a b) ≤ f b\n\n"}
{"name":"CFilter.mk.inj","module":"Mathlib.Data.Analysis.Filter","initialProofState":"α : Type u_1\nσ : Type u_2\ninst✝ : PartialOrder α\nf✝ : σ → α\npt✝ : σ\ninf✝ : σ → σ → σ\ninf_le_left✝ : ∀ (a b : σ), LE.le (f✝ (inf✝ a b)) (f✝ a)\ninf_le_right✝ : ∀ (a b : σ), LE.le (f✝ (inf✝ a b)) (f✝ b)\nf : σ → α\npt : σ\ninf : σ → σ → σ\ninf_le_left : ∀ (a b : σ), LE.le (f (inf a b)) (f a)\ninf_le_right : ∀ (a b : σ), LE.le (f (inf a b)) (f b)\nx✝ : Eq { f := f✝, pt := pt✝, inf := inf✝, inf_le_left := inf_le_left✝, inf_le_right := inf_le_right✝ } { f := f, pt := pt, inf := inf, inf_le_left := inf_le_left, inf_le_right := inf_le_right }\n⊢ And (Eq f✝ f) (And (Eq pt✝ pt) (Eq inf✝ inf))","decl":"/-- A `CFilter α σ` is a realization of a filter (base) on `α`,\n  represented by a type `σ` together with operations for the top element and\n  the binary `inf` operation. -/\nstructure CFilter (α σ : Type*) [PartialOrder α] where\n  f : σ → α\n  pt : σ\n  inf : σ → σ → σ\n  inf_le_left : ∀ a b : σ, f (inf a b) ≤ f a\n  inf_le_right : ∀ a b : σ, f (inf a b) ≤ f b\n\n"}
{"name":"CFilter.mk.injEq","module":"Mathlib.Data.Analysis.Filter","initialProofState":"α : Type u_1\nσ : Type u_2\ninst✝ : PartialOrder α\nf✝ : σ → α\npt✝ : σ\ninf✝ : σ → σ → σ\ninf_le_left✝ : ∀ (a b : σ), LE.le (f✝ (inf✝ a b)) (f✝ a)\ninf_le_right✝ : ∀ (a b : σ), LE.le (f✝ (inf✝ a b)) (f✝ b)\nf : σ → α\npt : σ\ninf : σ → σ → σ\ninf_le_left : ∀ (a b : σ), LE.le (f (inf a b)) (f a)\ninf_le_right : ∀ (a b : σ), LE.le (f (inf a b)) (f b)\n⊢ Eq (Eq { f := f✝, pt := pt✝, inf := inf✝, inf_le_left := inf_le_left✝, inf_le_right := inf_le_right✝ } { f := f, pt := pt, inf := inf, inf_le_left := inf_le_left, inf_le_right := inf_le_right }) (And (Eq f✝ f) (And (Eq pt✝ pt) (Eq inf✝ inf)))","decl":"/-- A `CFilter α σ` is a realization of a filter (base) on `α`,\n  represented by a type `σ` together with operations for the top element and\n  the binary `inf` operation. -/\nstructure CFilter (α σ : Type*) [PartialOrder α] where\n  f : σ → α\n  pt : σ\n  inf : σ → σ → σ\n  inf_le_left : ∀ a b : σ, f (inf a b) ≤ f a\n  inf_le_right : ∀ a b : σ, f (inf a b) ≤ f b\n\n"}
{"name":"CFilter.inf_le_right","module":"Mathlib.Data.Analysis.Filter","initialProofState":"α : Type u_1\nσ : Type u_2\ninst✝ : PartialOrder α\nself : CFilter α σ\na b : σ\n⊢ LE.le (self.f (self.inf a b)) (self.f b)","decl":"/-- A `CFilter α σ` is a realization of a filter (base) on `α`,\n  represented by a type `σ` together with operations for the top element and\n  the binary `inf` operation. -/\nstructure CFilter (α σ : Type*) [PartialOrder α] where\n  f : σ → α\n  pt : σ\n  inf : σ → σ → σ\n  inf_le_left : ∀ a b : σ, f (inf a b) ≤ f a\n  inf_le_right : ∀ a b : σ, f (inf a b) ≤ f b\n\n"}
{"name":"CFilter.inf_le_left","module":"Mathlib.Data.Analysis.Filter","initialProofState":"α : Type u_1\nσ : Type u_2\ninst✝ : PartialOrder α\nself : CFilter α σ\na b : σ\n⊢ LE.le (self.f (self.inf a b)) (self.f a)","decl":"/-- A `CFilter α σ` is a realization of a filter (base) on `α`,\n  represented by a type `σ` together with operations for the top element and\n  the binary `inf` operation. -/\nstructure CFilter (α σ : Type*) [PartialOrder α] where\n  f : σ → α\n  pt : σ\n  inf : σ → σ → σ\n  inf_le_left : ∀ a b : σ, f (inf a b) ≤ f a\n  inf_le_right : ∀ a b : σ, f (inf a b) ≤ f b\n\n"}
{"name":"CFilter.coe_mk","module":"Mathlib.Data.Analysis.Filter","initialProofState":"α : Type u_1\nσ : Type u_3\ninst✝ : PartialOrder α\nf : σ → α\npt : σ\ninf : σ → σ → σ\nh₁ : ∀ (a b : σ), LE.le (f (inf a b)) (f a)\nh₂ : ∀ (a b : σ), LE.le (f (inf a b)) (f b)\na : σ\n⊢ Eq ({ f := f, pt := pt, inf := inf, inf_le_left := h₁, inf_le_right := h₂ }.f a) (f a)","decl":"theorem coe_mk (f pt inf h₁ h₂ a) : (@CFilter.mk α σ _ f pt inf h₁ h₂) a = f a :=\n  rfl\n\n"}
{"name":"CFilter.ofEquiv_val","module":"Mathlib.Data.Analysis.Filter","initialProofState":"α : Type u_1\nσ : Type u_3\nτ : Type u_4\ninst✝ : PartialOrder α\nE : Equiv σ τ\nF : CFilter α σ\na : τ\n⊢ Eq ((CFilter.ofEquiv E F).f a) (F.f (E.symm a))","decl":"@[simp]\ntheorem ofEquiv_val (E : σ ≃ τ) (F : CFilter α σ) (a : τ) : F.ofEquiv E a = F (E.symm a) := by\n  cases F; rfl\n\n"}
{"name":"CFilter.mem_toFilter_sets","module":"Mathlib.Data.Analysis.Filter","initialProofState":"α : Type u_1\nσ : Type u_3\nF : CFilter (Set α) σ\na : Set α\n⊢ Iff (Membership.mem F.toFilter a) (Exists fun b => HasSubset.Subset (F.f b) a)","decl":"@[simp]\ntheorem mem_toFilter_sets (F : CFilter (Set α) σ) {a : Set α} : a ∈ F.toFilter ↔ ∃ b, F b ⊆ a :=\n  Iff.rfl\n\n"}
{"name":"Filter.Realizer.mk.inj","module":"Mathlib.Data.Analysis.Filter","initialProofState":"α : Type u_1\nf : Filter α\nσ✝ : Type u_5\nF✝ : CFilter (Set α) σ✝\neq✝ : Eq F✝.toFilter f\nσ : Type u_5\nF : CFilter (Set α) σ\neq : Eq F.toFilter f\nx✝ : Eq { σ := σ✝, F := F✝, eq := eq✝ } { σ := σ, F := F, eq := eq }\n⊢ And (Eq σ✝ σ) (HEq F✝ F)","decl":"/-- A realizer for filter `f` is a cfilter which generates `f`. -/\nstructure Filter.Realizer (f : Filter α) where\n  σ : Type*\n  F : CFilter (Set α) σ\n  eq : F.toFilter = f\n\n"}
{"name":"Filter.Realizer.mk.sizeOf_spec","module":"Mathlib.Data.Analysis.Filter","initialProofState":"α : Type u_1\nf : Filter α\ninst✝ : SizeOf α\nσ : Type u_5\nF : CFilter (Set α) σ\neq : Eq F.toFilter f\n⊢ Eq (SizeOf.sizeOf { σ := σ, F := F, eq := eq }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf σ)) (SizeOf.sizeOf F)) (SizeOf.sizeOf eq))","decl":"/-- A realizer for filter `f` is a cfilter which generates `f`. -/\nstructure Filter.Realizer (f : Filter α) where\n  σ : Type*\n  F : CFilter (Set α) σ\n  eq : F.toFilter = f\n\n"}
{"name":"Filter.Realizer.eq","module":"Mathlib.Data.Analysis.Filter","initialProofState":"α : Type u_1\nf : Filter α\nself : f.Realizer\n⊢ Eq self.F.toFilter f","decl":"/-- A realizer for filter `f` is a cfilter which generates `f`. -/\nstructure Filter.Realizer (f : Filter α) where\n  σ : Type*\n  F : CFilter (Set α) σ\n  eq : F.toFilter = f\n\n"}
{"name":"Filter.Realizer.mk.injEq","module":"Mathlib.Data.Analysis.Filter","initialProofState":"α : Type u_1\nf : Filter α\nσ✝ : Type u_5\nF✝ : CFilter (Set α) σ✝\neq✝ : Eq F✝.toFilter f\nσ : Type u_5\nF : CFilter (Set α) σ\neq : Eq F.toFilter f\n⊢ Eq (Eq { σ := σ✝, F := F✝, eq := eq✝ } { σ := σ, F := F, eq := eq }) (And (Eq σ✝ σ) (HEq F✝ F))","decl":"/-- A realizer for filter `f` is a cfilter which generates `f`. -/\nstructure Filter.Realizer (f : Filter α) where\n  σ : Type*\n  F : CFilter (Set α) σ\n  eq : F.toFilter = f\n\n"}
{"name":"Filter.Realizer.mem_sets","module":"Mathlib.Data.Analysis.Filter","initialProofState":"α : Type u_1\nf : Filter α\nF : f.Realizer\na : Set α\n⊢ Iff (Membership.mem f a) (Exists fun b => HasSubset.Subset (F.F.f b) a)","decl":"theorem mem_sets {f : Filter α} (F : f.Realizer) {a : Set α} : a ∈ f ↔ ∃ b, F.F b ⊆ a := by\n  cases F; subst f; rfl\n\n"}
{"name":"Filter.Realizer.ofEquiv_σ","module":"Mathlib.Data.Analysis.Filter","initialProofState":"α : Type u_1\nτ : Type u_4\nf : Filter α\nF : f.Realizer\nE : Equiv F.σ τ\n⊢ Eq (F.ofEquiv E).σ τ","decl":"@[simp]\ntheorem ofEquiv_σ {f : Filter α} (F : f.Realizer) (E : F.σ ≃ τ) : (F.ofEquiv E).σ = τ :=\n  rfl\n\n"}
{"name":"Filter.Realizer.ofEquiv_F","module":"Mathlib.Data.Analysis.Filter","initialProofState":"α : Type u_1\nτ : Type u_4\nf : Filter α\nF : f.Realizer\nE : Equiv F.σ τ\ns : τ\n⊢ Eq ((F.ofEquiv E).F.f s) (F.F.f (E.symm s))","decl":"@[simp]\ntheorem ofEquiv_F {f : Filter α} (F : f.Realizer) (E : F.σ ≃ τ) (s : τ) :\n    (F.ofEquiv E).F s = F.F (E.symm s) := rfl\n\n"}
{"name":"Filter.Realizer.principal_σ","module":"Mathlib.Data.Analysis.Filter","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (Filter.Realizer.principal s).σ Unit","decl":"@[simp]\ntheorem principal_σ (s : Set α) : (Realizer.principal s).σ = Unit :=\n  rfl\n\n"}
{"name":"Filter.Realizer.principal_F","module":"Mathlib.Data.Analysis.Filter","initialProofState":"α : Type u_1\ns : Set α\nu : Unit\n⊢ Eq ((Filter.Realizer.principal s).F.f u) s","decl":"@[simp]\ntheorem principal_F (s : Set α) (u : Unit) : (Realizer.principal s).F u = s :=\n  rfl\n\n"}
{"name":"Filter.Realizer.top_σ","module":"Mathlib.Data.Analysis.Filter","initialProofState":"α : Type u_1\n⊢ Eq Filter.Realizer.top.σ Unit","decl":"@[simp]\ntheorem top_σ : (@Realizer.top α).σ = Unit :=\n  rfl\n\n"}
{"name":"Filter.Realizer.top_F","module":"Mathlib.Data.Analysis.Filter","initialProofState":"α : Type u_1\nu : Unit\n⊢ Eq (Filter.Realizer.top.F.f u) Set.univ","decl":"@[simp]\ntheorem top_F (u : Unit) : (@Realizer.top α).F u = univ :=\n  rfl\n\n"}
{"name":"Filter.Realizer.bot_σ","module":"Mathlib.Data.Analysis.Filter","initialProofState":"α : Type u_1\n⊢ Eq Filter.Realizer.bot.σ Unit","decl":"@[simp]\ntheorem bot_σ : (@Realizer.bot α).σ = Unit :=\n  rfl\n\n"}
{"name":"Filter.Realizer.bot_F","module":"Mathlib.Data.Analysis.Filter","initialProofState":"α : Type u_1\nu : Unit\n⊢ Eq (Filter.Realizer.bot.F.f u) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem bot_F (u : Unit) : (@Realizer.bot α).F u = ∅ :=\n  rfl\n\n"}
{"name":"Filter.Realizer.map_σ","module":"Mathlib.Data.Analysis.Filter","initialProofState":"α : Type u_1\nβ : Type u_2\nm : α → β\nf : Filter α\nF : f.Realizer\n⊢ Eq (Filter.Realizer.map m F).σ F.σ","decl":"@[simp]\ntheorem map_σ (m : α → β) {f : Filter α} (F : f.Realizer) : (F.map m).σ = F.σ :=\n  rfl\n\n"}
{"name":"Filter.Realizer.map_F","module":"Mathlib.Data.Analysis.Filter","initialProofState":"α : Type u_1\nβ : Type u_2\nm : α → β\nf : Filter α\nF : f.Realizer\ns : (Filter.Realizer.map m F).σ\n⊢ Eq ((Filter.Realizer.map m F).F.f s) (Set.image m (F.F.f s))","decl":"@[simp]\ntheorem map_F (m : α → β) {f : Filter α} (F : f.Realizer) (s) : (F.map m).F s = image m (F.F s) :=\n  rfl\n\n"}
{"name":"Filter.Realizer.le_iff","module":"Mathlib.Data.Analysis.Filter","initialProofState":"α : Type u_1\nf g : Filter α\nF : f.Realizer\nG : g.Realizer\n⊢ Iff (LE.le f g) (∀ (b : G.σ), Exists fun a => LE.le (F.F.f a) (G.F.f b))","decl":"theorem le_iff {f g : Filter α} (F : f.Realizer) (G : g.Realizer) :\n    f ≤ g ↔ ∀ b : G.σ, ∃ a : F.σ, F.F a ≤ G.F b :=\n  ⟨fun H t ↦ F.mem_sets.1 (H (G.mem_sets.2 ⟨t, Subset.refl _⟩)), fun H _ h ↦\n    F.mem_sets.2 <|\n      let ⟨s, h₁⟩ := G.mem_sets.1 h\n      let ⟨t, h₂⟩ := H s\n      ⟨t, Subset.trans h₂ h₁⟩⟩\n\n"}
{"name":"Filter.Realizer.tendsto_iff","module":"Mathlib.Data.Analysis.Filter","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nl₁ : Filter α\nl₂ : Filter β\nL₁ : l₁.Realizer\nL₂ : l₂.Realizer\n⊢ Iff (Filter.Tendsto f l₁ l₂) (∀ (b : L₂.σ), Exists fun a => ∀ (x : α), Membership.mem (L₁.F.f a) x → Membership.mem (L₂.F.f b) (f x))","decl":"theorem tendsto_iff (f : α → β) {l₁ : Filter α} {l₂ : Filter β} (L₁ : l₁.Realizer)\n    (L₂ : l₂.Realizer) : Tendsto f l₁ l₂ ↔ ∀ b, ∃ a, ∀ x ∈ L₁.F a, f x ∈ L₂.F b :=\n  (le_iff (L₁.map f) L₂).trans <| forall_congr' fun _ ↦ exists_congr fun _ ↦ image_subset_iff\n\n"}
{"name":"Filter.Realizer.ne_bot_iff","module":"Mathlib.Data.Analysis.Filter","initialProofState":"α : Type u_1\nf : Filter α\nF : f.Realizer\n⊢ Iff (Ne f Bot.bot) (∀ (a : F.σ), (F.F.f a).Nonempty)","decl":"theorem ne_bot_iff {f : Filter α} (F : f.Realizer) : f ≠ ⊥ ↔ ∀ a : F.σ, (F.F a).Nonempty := by\n  rw [not_iff_comm, ← le_bot_iff, F.le_iff Realizer.bot, not_forall]\n  simp only [Set.not_nonempty_iff_eq_empty]\n  exact ⟨fun ⟨x, e⟩ _ ↦ ⟨x, le_of_eq e⟩, fun h ↦\n    let ⟨x, h⟩ := h ()\n    ⟨x, le_bot_iff.1 h⟩⟩\n\n"}
