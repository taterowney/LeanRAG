{"name":"HasStrictDerivAt.real_of_complex","module":"Mathlib.Analysis.Complex.RealDeriv","initialProofState":"e : Complex → Complex\ne' : Complex\nz : Real\nh : HasStrictDerivAt e e' ↑z\n⊢ HasStrictDerivAt (fun x => (e ↑x).re) e'.re z","decl":"/-- If a complex function is differentiable at a real point, then the induced real function is also\ndifferentiable at this point, with a derivative equal to the real part of the complex derivative. -/\ntheorem HasStrictDerivAt.real_of_complex (h : HasStrictDerivAt e e' z) :\n    HasStrictDerivAt (fun x : ℝ => (e x).re) e'.re z := by\n  have A : HasStrictFDerivAt ((↑) : ℝ → ℂ) ofRealCLM z := ofRealCLM.hasStrictFDerivAt\n  have B :\n    HasStrictFDerivAt e ((ContinuousLinearMap.smulRight 1 e' : ℂ →L[ℂ] ℂ).restrictScalars ℝ)\n      (ofRealCLM z) :=\n    h.hasStrictFDerivAt.restrictScalars ℝ\n  have C : HasStrictFDerivAt re reCLM (e (ofRealCLM z)) := reCLM.hasStrictFDerivAt\n  -- Porting note: this should be by:\n  -- simpa using (C.comp z (B.comp z A)).hasStrictDerivAt\n  -- but for some reason simp can not use `ContinuousLinearMap.comp_apply`\n  convert (C.comp z (B.comp z A)).hasStrictDerivAt\n  rw [ContinuousLinearMap.comp_apply, ContinuousLinearMap.comp_apply]\n  simp\n\n"}
{"name":"HasDerivAt.real_of_complex","module":"Mathlib.Analysis.Complex.RealDeriv","initialProofState":"e : Complex → Complex\ne' : Complex\nz : Real\nh : HasDerivAt e e' ↑z\n⊢ HasDerivAt (fun x => (e ↑x).re) e'.re z","decl":"/-- If a complex function `e` is differentiable at a real point, then the function `ℝ → ℝ` given by\nthe real part of `e` is also differentiable at this point, with a derivative equal to the real part\nof the complex derivative. -/\ntheorem HasDerivAt.real_of_complex (h : HasDerivAt e e' z) :\n    HasDerivAt (fun x : ℝ => (e x).re) e'.re z := by\n  have A : HasFDerivAt ((↑) : ℝ → ℂ) ofRealCLM z := ofRealCLM.hasFDerivAt\n  have B :\n    HasFDerivAt e ((ContinuousLinearMap.smulRight 1 e' : ℂ →L[ℂ] ℂ).restrictScalars ℝ)\n      (ofRealCLM z) :=\n    h.hasFDerivAt.restrictScalars ℝ\n  have C : HasFDerivAt re reCLM (e (ofRealCLM z)) := reCLM.hasFDerivAt\n  -- Porting note: this should be by:\n  -- simpa using (C.comp z (B.comp z A)).hasStrictDerivAt\n  -- but for some reason simp can not use `ContinuousLinearMap.comp_apply`\n  convert (C.comp z (B.comp z A)).hasDerivAt\n  rw [ContinuousLinearMap.comp_apply, ContinuousLinearMap.comp_apply]\n  simp\n\n"}
{"name":"ContDiffAt.real_of_complex","module":"Mathlib.Analysis.Complex.RealDeriv","initialProofState":"e : Complex → Complex\nz : Real\nn : WithTop ENat\nh : ContDiffAt Complex n e ↑z\n⊢ ContDiffAt Real n (fun x => (e ↑x).re) z","decl":"theorem ContDiffAt.real_of_complex {n : WithTop ℕ∞} (h : ContDiffAt ℂ n e z) :\n    ContDiffAt ℝ n (fun x : ℝ => (e x).re) z := by\n  have A : ContDiffAt ℝ n ((↑) : ℝ → ℂ) z := ofRealCLM.contDiff.contDiffAt\n  have B : ContDiffAt ℝ n e z := h.restrict_scalars ℝ\n  have C : ContDiffAt ℝ n re (e z) := reCLM.contDiff.contDiffAt\n  exact C.comp z (B.comp z A)\n\n"}
{"name":"ContDiff.real_of_complex","module":"Mathlib.Analysis.Complex.RealDeriv","initialProofState":"e : Complex → Complex\nn : WithTop ENat\nh : ContDiff Complex n e\n⊢ ContDiff Real n fun x => (e ↑x).re","decl":"theorem ContDiff.real_of_complex {n : WithTop ℕ∞} (h : ContDiff ℂ n e) :\n    ContDiff ℝ n fun x : ℝ => (e x).re :=\n  contDiff_iff_contDiffAt.2 fun _ => h.contDiffAt.real_of_complex\n\n"}
{"name":"HasStrictDerivAt.complexToReal_fderiv'","module":"Mathlib.Analysis.Complex.RealDeriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Complex → E\nx : Complex\nf' : E\nh : HasStrictDerivAt f f' x\n⊢ HasStrictFDerivAt f (HAdd.hAdd (Complex.reCLM.smulRight f') (HSMul.hSMul Complex.I (Complex.imCLM.smulRight f'))) x","decl":"theorem HasStrictDerivAt.complexToReal_fderiv' {f : ℂ → E} {x : ℂ} {f' : E}\n    (h : HasStrictDerivAt f f' x) :\n    HasStrictFDerivAt f (reCLM.smulRight f' + I • imCLM.smulRight f') x := by\n  simpa only [Complex.restrictScalars_one_smulRight'] using\n    h.hasStrictFDerivAt.restrictScalars ℝ\n\n"}
{"name":"HasDerivAt.complexToReal_fderiv'","module":"Mathlib.Analysis.Complex.RealDeriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Complex → E\nx : Complex\nf' : E\nh : HasDerivAt f f' x\n⊢ HasFDerivAt f (HAdd.hAdd (Complex.reCLM.smulRight f') (HSMul.hSMul Complex.I (Complex.imCLM.smulRight f'))) x","decl":"theorem HasDerivAt.complexToReal_fderiv' {f : ℂ → E} {x : ℂ} {f' : E} (h : HasDerivAt f f' x) :\n    HasFDerivAt f (reCLM.smulRight f' + I • imCLM.smulRight f') x := by\n  simpa only [Complex.restrictScalars_one_smulRight'] using h.hasFDerivAt.restrictScalars ℝ\n\n"}
{"name":"HasDerivWithinAt.complexToReal_fderiv'","module":"Mathlib.Analysis.Complex.RealDeriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Complex → E\ns : Set Complex\nx : Complex\nf' : E\nh : HasDerivWithinAt f f' s x\n⊢ HasFDerivWithinAt f (HAdd.hAdd (Complex.reCLM.smulRight f') (HSMul.hSMul Complex.I (Complex.imCLM.smulRight f'))) s x","decl":"theorem HasDerivWithinAt.complexToReal_fderiv' {f : ℂ → E} {s : Set ℂ} {x : ℂ} {f' : E}\n    (h : HasDerivWithinAt f f' s x) :\n    HasFDerivWithinAt f (reCLM.smulRight f' + I • imCLM.smulRight f') s x := by\n  simpa only [Complex.restrictScalars_one_smulRight'] using\n    h.hasFDerivWithinAt.restrictScalars ℝ\n\n"}
{"name":"HasStrictDerivAt.complexToReal_fderiv","module":"Mathlib.Analysis.Complex.RealDeriv","initialProofState":"f : Complex → Complex\nf' x : Complex\nh : HasStrictDerivAt f f' x\n⊢ HasStrictFDerivAt f (HSMul.hSMul f' 1) x","decl":"theorem HasStrictDerivAt.complexToReal_fderiv {f : ℂ → ℂ} {f' x : ℂ} (h : HasStrictDerivAt f f' x) :\n    HasStrictFDerivAt f (f' • (1 : ℂ →L[ℝ] ℂ)) x := by\n  simpa only [Complex.restrictScalars_one_smulRight] using h.hasStrictFDerivAt.restrictScalars ℝ\n\n"}
{"name":"HasDerivAt.complexToReal_fderiv","module":"Mathlib.Analysis.Complex.RealDeriv","initialProofState":"f : Complex → Complex\nf' x : Complex\nh : HasDerivAt f f' x\n⊢ HasFDerivAt f (HSMul.hSMul f' 1) x","decl":"theorem HasDerivAt.complexToReal_fderiv {f : ℂ → ℂ} {f' x : ℂ} (h : HasDerivAt f f' x) :\n    HasFDerivAt f (f' • (1 : ℂ →L[ℝ] ℂ)) x := by\n  simpa only [Complex.restrictScalars_one_smulRight] using h.hasFDerivAt.restrictScalars ℝ\n\n"}
{"name":"HasDerivWithinAt.complexToReal_fderiv","module":"Mathlib.Analysis.Complex.RealDeriv","initialProofState":"f : Complex → Complex\ns : Set Complex\nf' x : Complex\nh : HasDerivWithinAt f f' s x\n⊢ HasFDerivWithinAt f (HSMul.hSMul f' 1) s x","decl":"theorem HasDerivWithinAt.complexToReal_fderiv {f : ℂ → ℂ} {s : Set ℂ} {f' x : ℂ}\n    (h : HasDerivWithinAt f f' s x) : HasFDerivWithinAt f (f' • (1 : ℂ →L[ℝ] ℂ)) s x := by\n  simpa only [Complex.restrictScalars_one_smulRight] using h.hasFDerivWithinAt.restrictScalars ℝ\n\n"}
{"name":"HasDerivAt.comp_ofReal","module":"Mathlib.Analysis.Complex.RealDeriv","initialProofState":"e : Complex → Complex\ne' : Complex\nz : Real\nhf : HasDerivAt e e' ↑z\n⊢ HasDerivAt (fun y => e ↑y) e' z","decl":"/-- If a complex function `e` is differentiable at a real point, then its restriction to `ℝ` is\ndifferentiable there as a function `ℝ → ℂ`, with the same derivative. -/\ntheorem HasDerivAt.comp_ofReal (hf : HasDerivAt e e' ↑z) : HasDerivAt (fun y : ℝ => e ↑y) e' z := by\n  simpa only [ofRealCLM_apply, ofReal_one, mul_one] using hf.comp z ofRealCLM.hasDerivAt\n\n"}
{"name":"HasDerivAt.ofReal_comp","module":"Mathlib.Analysis.Complex.RealDeriv","initialProofState":"z : Real\nf : Real → Real\nu : Real\nhf : HasDerivAt f u z\n⊢ HasDerivAt (fun y => ↑(f y)) (↑u) z","decl":"/-- If a function `f : ℝ → ℝ` is differentiable at a (real) point `x`, then it is also\ndifferentiable as a function `ℝ → ℂ`. -/\ntheorem HasDerivAt.ofReal_comp {f : ℝ → ℝ} {u : ℝ} (hf : HasDerivAt f u z) :\n    HasDerivAt (fun y : ℝ => ↑(f y) : ℝ → ℂ) u z := by\n  simpa only [ofRealCLM_apply, ofReal_one, real_smul, mul_one] using\n    ofRealCLM.hasDerivAt.scomp z hf\n\n"}
