{"name":"Int.log_of_one_le_right","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nb : Nat\nr : R\nhr : LE.le 1 r\n⊢ Eq (Int.log b r) ↑(Nat.log b (Nat.floor r))","decl":"theorem log_of_one_le_right (b : ℕ) {r : R} (hr : 1 ≤ r) : log b r = Nat.log b ⌊r⌋₊ :=\n  if_pos hr\n\n"}
{"name":"Int.log_of_right_le_one","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nb : Nat\nr : R\nhr : LE.le r 1\n⊢ Eq (Int.log b r) (Neg.neg ↑(Nat.clog b (Nat.ceil (Inv.inv r))))","decl":"theorem log_of_right_le_one (b : ℕ) {r : R} (hr : r ≤ 1) : log b r = -Nat.clog b ⌈r⁻¹⌉₊ := by\n  obtain rfl | hr := hr.eq_or_lt\n  · rw [log, if_pos hr, inv_one, Nat.ceil_one, Nat.floor_one, Nat.log_one_right, Nat.clog_one_right,\n      Int.ofNat_zero, neg_zero]\n  · exact if_neg hr.not_le\n\n"}
{"name":"Int.log_natCast","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nb n : Nat\n⊢ Eq (Int.log b ↑n) ↑(Nat.log b n)","decl":"@[simp, norm_cast]\ntheorem log_natCast (b : ℕ) (n : ℕ) : log b (n : R) = Nat.log b n := by\n  cases n\n  · simp [log_of_right_le_one]\n  · rw [log_of_one_le_right, Nat.floor_natCast]\n    simp\n\n"}
{"name":"Int.log_ofNat","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝² : LinearOrderedSemifield R\ninst✝¹ : FloorSemiring R\nb n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (Int.log b (OfNat.ofNat n)) ↑(Nat.log b (OfNat.ofNat n))","decl":"@[simp]\ntheorem log_ofNat (b : ℕ) (n : ℕ) [n.AtLeastTwo] :\n    log b (ofNat(n) : R) = Nat.log b ofNat(n) :=\n  log_natCast b n\n\n"}
{"name":"Int.log_of_left_le_one","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nb : Nat\nhb : LE.le b 1\nr : R\n⊢ Eq (Int.log b r) 0","decl":"theorem log_of_left_le_one {b : ℕ} (hb : b ≤ 1) (r : R) : log b r = 0 := by\n  rcases le_total 1 r with h | h\n  · rw [log_of_one_le_right _ h, Nat.log_of_left_le_one hb, Int.ofNat_zero]\n  · rw [log_of_right_le_one _ h, Nat.clog_of_left_le_one hb, Int.ofNat_zero, neg_zero]\n\n"}
{"name":"Int.log_of_right_le_zero","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nb : Nat\nr : R\nhr : LE.le r 0\n⊢ Eq (Int.log b r) 0","decl":"theorem log_of_right_le_zero (b : ℕ) {r : R} (hr : r ≤ 0) : log b r = 0 := by\n  rw [log_of_right_le_one _ (hr.trans zero_le_one),\n    Nat.clog_of_right_le_one ((Nat.ceil_eq_zero.mpr <| inv_nonpos.2 hr).trans_le zero_le_one),\n    Int.ofNat_zero, neg_zero]\n\n"}
{"name":"Int.zpow_log_le_self","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nb : Nat\nr : R\nhb : LT.lt 1 b\nhr : LT.lt 0 r\n⊢ LE.le (HPow.hPow (↑b) (Int.log b r)) r","decl":"theorem zpow_log_le_self {b : ℕ} {r : R} (hb : 1 < b) (hr : 0 < r) : (b : R) ^ log b r ≤ r := by\n  rcases le_total 1 r with hr1 | hr1\n  · rw [log_of_one_le_right _ hr1]\n    rw [zpow_natCast, ← Nat.cast_pow, ← Nat.le_floor_iff hr.le]\n    exact Nat.pow_log_le_self b (Nat.floor_pos.mpr hr1).ne'\n  · rw [log_of_right_le_one _ hr1, zpow_neg, zpow_natCast, ← Nat.cast_pow]\n    exact inv_le_of_inv_le₀ hr (Nat.ceil_le.1 <| Nat.le_pow_clog hb _)\n\n"}
{"name":"Int.lt_zpow_succ_log_self","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nb : Nat\nhb : LT.lt 1 b\nr : R\n⊢ LT.lt r (HPow.hPow (↑b) (HAdd.hAdd (Int.log b r) 1))","decl":"theorem lt_zpow_succ_log_self {b : ℕ} (hb : 1 < b) (r : R) : r < (b : R) ^ (log b r + 1) := by\n  rcases le_or_lt r 0 with hr | hr\n  · rw [log_of_right_le_zero _ hr, zero_add, zpow_one]\n    exact hr.trans_lt (zero_lt_one.trans_le <| mod_cast hb.le)\n  rcases le_or_lt 1 r with hr1 | hr1\n  · rw [log_of_one_le_right _ hr1]\n    rw [Int.ofNat_add_one_out, zpow_natCast, ← Nat.cast_pow]\n    apply Nat.lt_of_floor_lt\n    exact Nat.lt_pow_succ_log_self hb _\n  · rw [log_of_right_le_one _ hr1.le]\n    have hcri : 1 < r⁻¹ := (one_lt_inv₀ hr).2 hr1\n    have : 1 ≤ Nat.clog b ⌈r⁻¹⌉₊ :=\n      Nat.succ_le_of_lt (Nat.clog_pos hb <| Nat.one_lt_cast.1 <| hcri.trans_le (Nat.le_ceil _))\n    rw [neg_add_eq_sub, ← neg_sub, ← Int.ofNat_one, ← Int.ofNat_sub this, zpow_neg, zpow_natCast,\n      lt_inv_comm₀ hr (pow_pos (Nat.cast_pos.mpr <| zero_lt_one.trans hb) _), ← Nat.cast_pow]\n    refine Nat.lt_ceil.1 ?_\n    exact Nat.pow_pred_clog_lt_self hb <| Nat.one_lt_cast.1 <| hcri.trans_le <| Nat.le_ceil _\n\n"}
{"name":"Int.log_zero_right","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nb : Nat\n⊢ Eq (Int.log b 0) 0","decl":"@[simp]\ntheorem log_zero_right (b : ℕ) : log b (0 : R) = 0 :=\n  log_of_right_le_zero b le_rfl\n\n"}
{"name":"Int.log_one_right","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nb : Nat\n⊢ Eq (Int.log b 1) 0","decl":"@[simp]\ntheorem log_one_right (b : ℕ) : log b (1 : R) = 0 := by\n  rw [log_of_one_le_right _ le_rfl, Nat.floor_one, Nat.log_one_right, Int.ofNat_zero]\n\n"}
{"name":"Int.log_zero_left","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nr : R\n⊢ Eq (Int.log 0 r) 0","decl":"@[simp]\ntheorem log_zero_left (r : R) : log 0 r = 0 := by\n  simp only [log, Nat.log_zero_left, Nat.cast_zero, Nat.clog_zero_left, neg_zero, ite_self]\n\n"}
{"name":"Int.log_one_left","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nr : R\n⊢ Eq (Int.log 1 r) 0","decl":"@[simp]\ntheorem log_one_left (r : R) : log 1 r = 0 := by\n  by_cases hr : 1 ≤ r\n  · simp_all only [log, ↓reduceIte, Nat.log_one_left, Nat.cast_zero]\n  · simp only [log, Nat.log_one_left, Nat.cast_zero, Nat.clog_one_left, neg_zero, ite_self]\n\n-- Porting note: needed to replace b ^ z with (b : R) ^ z in the below\n"}
{"name":"Int.log_zpow","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nb : Nat\nhb : LT.lt 1 b\nz : Int\n⊢ Eq (Int.log b (HPow.hPow (↑b) z)) z","decl":"theorem log_zpow {b : ℕ} (hb : 1 < b) (z : ℤ) : log b ((b : R) ^ z : R) = z := by\n  obtain ⟨n, rfl | rfl⟩ := Int.eq_nat_or_neg z\n  · rw [log_of_one_le_right _ (one_le_zpow₀ (mod_cast hb.le) <| Int.natCast_nonneg _), zpow_natCast,\n      ← Nat.cast_pow, Nat.floor_natCast, Nat.log_pow hb]\n  · rw [log_of_right_le_one _ (zpow_le_one_of_nonpos₀ (mod_cast hb.le) <|\n      neg_nonpos.2 (Int.natCast_nonneg _)),\n      zpow_neg, inv_inv, zpow_natCast, ← Nat.cast_pow, Nat.ceil_natCast, Nat.clog_pow _ _ hb]\n\n"}
{"name":"Int.log_mono_right","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nb : Nat\nr₁ r₂ : R\nh₀ : LT.lt 0 r₁\nh : LE.le r₁ r₂\n⊢ LE.le (Int.log b r₁) (Int.log b r₂)","decl":"@[mono]\ntheorem log_mono_right {b : ℕ} {r₁ r₂ : R} (h₀ : 0 < r₁) (h : r₁ ≤ r₂) : log b r₁ ≤ log b r₂ := by\n  rcases le_total r₁ 1 with h₁ | h₁ <;> rcases le_total r₂ 1 with h₂ | h₂\n  · rw [log_of_right_le_one _ h₁, log_of_right_le_one _ h₂, neg_le_neg_iff, Int.ofNat_le]\n    exact Nat.clog_mono_right _ (Nat.ceil_mono <| inv_anti₀ h₀ h)\n  · rw [log_of_right_le_one _ h₁, log_of_one_le_right _ h₂]\n    exact (neg_nonpos.mpr (Int.natCast_nonneg _)).trans (Int.natCast_nonneg _)\n  · obtain rfl := le_antisymm h (h₂.trans h₁)\n    rfl\n  · rw [log_of_one_le_right _ h₁, log_of_one_le_right _ h₂, Int.ofNat_le]\n    exact Nat.log_mono_right (Nat.floor_mono h)\n\n"}
{"name":"Int.lt_zpow_iff_log_lt","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nb : Nat\nhb : LT.lt 1 b\nx : Int\nr : R\nhr : LT.lt 0 r\n⊢ Iff (LT.lt r (HPow.hPow (↑b) x)) (LT.lt (Int.log b r) x)","decl":"/-- `zpow b` and `Int.log b` (almost) form a Galois connection. -/\ntheorem lt_zpow_iff_log_lt {b : ℕ} (hb : 1 < b) {x : ℤ} {r : R} (hr : 0 < r) :\n    r < (b : R) ^ x ↔ log b r < x :=\n  @GaloisConnection.lt_iff_lt _ _ _ _ _ _ (zpowLogGi R hb).gc x ⟨r, hr⟩\n\n"}
{"name":"Int.zpow_le_iff_le_log","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nb : Nat\nhb : LT.lt 1 b\nx : Int\nr : R\nhr : LT.lt 0 r\n⊢ Iff (LE.le (HPow.hPow (↑b) x) r) (LE.le x (Int.log b r))","decl":"/-- `zpow b` and `Int.log b` (almost) form a Galois connection. -/\ntheorem zpow_le_iff_le_log {b : ℕ} (hb : 1 < b) {x : ℤ} {r : R} (hr : 0 < r) :\n    (b : R) ^ x ≤ r ↔ x ≤ log b r :=\n  @GaloisConnection.le_iff_le _ _ _ _ _ _ (zpowLogGi R hb).gc x ⟨r, hr⟩\n\n"}
{"name":"Int.clog_of_one_le_right","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nb : Nat\nr : R\nhr : LE.le 1 r\n⊢ Eq (Int.clog b r) ↑(Nat.clog b (Nat.ceil r))","decl":"theorem clog_of_one_le_right (b : ℕ) {r : R} (hr : 1 ≤ r) : clog b r = Nat.clog b ⌈r⌉₊ :=\n  if_pos hr\n\n"}
{"name":"Int.clog_of_right_le_one","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nb : Nat\nr : R\nhr : LE.le r 1\n⊢ Eq (Int.clog b r) (Neg.neg ↑(Nat.log b (Nat.floor (Inv.inv r))))","decl":"theorem clog_of_right_le_one (b : ℕ) {r : R} (hr : r ≤ 1) : clog b r = -Nat.log b ⌊r⁻¹⌋₊ := by\n  obtain rfl | hr := hr.eq_or_lt\n  · rw [clog, if_pos hr, inv_one, Nat.ceil_one, Nat.floor_one, Nat.log_one_right,\n      Nat.clog_one_right, Int.ofNat_zero, neg_zero]\n  · exact if_neg hr.not_le\n\n"}
{"name":"Int.clog_of_right_le_zero","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nb : Nat\nr : R\nhr : LE.le r 0\n⊢ Eq (Int.clog b r) 0","decl":"theorem clog_of_right_le_zero (b : ℕ) {r : R} (hr : r ≤ 0) : clog b r = 0 := by\n  rw [clog, if_neg (hr.trans_lt zero_lt_one).not_le, neg_eq_zero, Int.natCast_eq_zero,\n    Nat.log_eq_zero_iff]\n  rcases le_or_lt b 1 with hb | hb\n  · exact Or.inr hb\n  · refine Or.inl (lt_of_le_of_lt ?_ hb)\n    exact Nat.floor_le_one_of_le_one ((inv_nonpos.2 hr).trans zero_le_one)\n\n"}
{"name":"Int.clog_inv","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nb : Nat\nr : R\n⊢ Eq (Int.clog b (Inv.inv r)) (Neg.neg (Int.log b r))","decl":"@[simp]\ntheorem clog_inv (b : ℕ) (r : R) : clog b r⁻¹ = -log b r := by\n  cases' lt_or_le 0 r with hrp hrp\n  · obtain hr | hr := le_total 1 r\n    · rw [clog_of_right_le_one _ (inv_le_one_of_one_le₀ hr), log_of_one_le_right _ hr, inv_inv]\n    · rw [clog_of_one_le_right _ ((one_le_inv₀ hrp).2 hr), log_of_right_le_one _ hr, neg_neg]\n  · rw [clog_of_right_le_zero _ (inv_nonpos.mpr hrp), log_of_right_le_zero _ hrp, neg_zero]\n\n"}
{"name":"Int.log_inv","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nb : Nat\nr : R\n⊢ Eq (Int.log b (Inv.inv r)) (Neg.neg (Int.clog b r))","decl":"@[simp]\ntheorem log_inv (b : ℕ) (r : R) : log b r⁻¹ = -clog b r := by\n  rw [← inv_inv r, clog_inv, neg_neg, inv_inv]\n\n-- note this is useful for writing in reverse\n"}
{"name":"Int.neg_log_inv_eq_clog","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nb : Nat\nr : R\n⊢ Eq (Neg.neg (Int.log b (Inv.inv r))) (Int.clog b r)","decl":"theorem neg_log_inv_eq_clog (b : ℕ) (r : R) : -log b r⁻¹ = clog b r := by rw [log_inv, neg_neg]\n\n"}
{"name":"Int.neg_clog_inv_eq_log","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nb : Nat\nr : R\n⊢ Eq (Neg.neg (Int.clog b (Inv.inv r))) (Int.log b r)","decl":"theorem neg_clog_inv_eq_log (b : ℕ) (r : R) : -clog b r⁻¹ = log b r := by rw [clog_inv, neg_neg]\n\n"}
{"name":"Int.clog_natCast","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nb n : Nat\n⊢ Eq (Int.clog b ↑n) ↑(Nat.clog b n)","decl":"@[simp, norm_cast]\ntheorem clog_natCast (b : ℕ) (n : ℕ) : clog b (n : R) = Nat.clog b n := by\n  cases' n with n\n  · simp [clog_of_right_le_one]\n  · rw [clog_of_one_le_right, (Nat.ceil_eq_iff (Nat.succ_ne_zero n)).mpr] <;> simp\n\n"}
{"name":"Int.clog_ofNat","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝² : LinearOrderedSemifield R\ninst✝¹ : FloorSemiring R\nb n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (Int.clog b (OfNat.ofNat n)) ↑(Nat.clog b (OfNat.ofNat n))","decl":"@[simp]\ntheorem clog_ofNat (b : ℕ) (n : ℕ) [n.AtLeastTwo] :\n    clog b (ofNat(n) : R) = Nat.clog b ofNat(n) :=\n  clog_natCast b n\n\n"}
{"name":"Int.clog_of_left_le_one","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nb : Nat\nhb : LE.le b 1\nr : R\n⊢ Eq (Int.clog b r) 0","decl":"theorem clog_of_left_le_one {b : ℕ} (hb : b ≤ 1) (r : R) : clog b r = 0 := by\n  rw [← neg_log_inv_eq_clog, log_of_left_le_one hb, neg_zero]\n\n"}
{"name":"Int.self_le_zpow_clog","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nb : Nat\nhb : LT.lt 1 b\nr : R\n⊢ LE.le r (HPow.hPow (↑b) (Int.clog b r))","decl":"theorem self_le_zpow_clog {b : ℕ} (hb : 1 < b) (r : R) : r ≤ (b : R) ^ clog b r := by\n  rcases le_or_lt r 0 with hr | hr\n  · rw [clog_of_right_le_zero _ hr, zpow_zero]\n    exact hr.trans zero_le_one\n  rw [← neg_log_inv_eq_clog, zpow_neg, le_inv_comm₀ hr (zpow_pos ..)]\n  · exact zpow_log_le_self hb (inv_pos.mpr hr)\n  · exact Nat.cast_pos.mpr (zero_le_one.trans_lt hb)\n\n"}
{"name":"Int.zpow_pred_clog_lt_self","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nb : Nat\nr : R\nhb : LT.lt 1 b\nhr : LT.lt 0 r\n⊢ LT.lt (HPow.hPow (↑b) (HSub.hSub (Int.clog b r) 1)) r","decl":"theorem zpow_pred_clog_lt_self {b : ℕ} {r : R} (hb : 1 < b) (hr : 0 < r) :\n    (b : R) ^ (clog b r - 1) < r := by\n  rw [← neg_log_inv_eq_clog, ← neg_add', zpow_neg, inv_lt_comm₀ _ hr]\n  · exact lt_zpow_succ_log_self hb _\n  · exact zpow_pos (Nat.cast_pos.mpr <| zero_le_one.trans_lt hb) _\n\n"}
{"name":"Int.clog_zero_right","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nb : Nat\n⊢ Eq (Int.clog b 0) 0","decl":"@[simp]\ntheorem clog_zero_right (b : ℕ) : clog b (0 : R) = 0 :=\n  clog_of_right_le_zero _ le_rfl\n\n"}
{"name":"Int.clog_one_right","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nb : Nat\n⊢ Eq (Int.clog b 1) 0","decl":"@[simp]\ntheorem clog_one_right (b : ℕ) : clog b (1 : R) = 0 := by\n  rw [clog_of_one_le_right _ le_rfl, Nat.ceil_one, Nat.clog_one_right, Int.ofNat_zero]\n\n"}
{"name":"Int.clog_zero_left","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nr : R\n⊢ Eq (Int.clog 0 r) 0","decl":"@[simp]\ntheorem clog_zero_left (r : R) : clog 0 r = 0 := by\n  by_cases hr : 1 ≤ r\n  · simp only [clog, Nat.clog_zero_left, Nat.cast_zero, Nat.log_zero_left, neg_zero, ite_self]\n  · simp only [clog, hr, ite_cond_eq_false, Nat.log_zero_left, Nat.cast_zero, neg_zero]\n\n"}
{"name":"Int.clog_one_left","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nr : R\n⊢ Eq (Int.clog 1 r) 0","decl":"@[simp]\ntheorem clog_one_left (r : R) : clog 1 r = 0 := by\n  simp only [clog, Nat.log_one_left, Nat.cast_zero, Nat.clog_one_left, neg_zero, ite_self]\n\n-- Porting note: needed to replace b ^ z with (b : R) ^ z in the below\n"}
{"name":"Int.clog_zpow","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nb : Nat\nhb : LT.lt 1 b\nz : Int\n⊢ Eq (Int.clog b (HPow.hPow (↑b) z)) z","decl":"theorem clog_zpow {b : ℕ} (hb : 1 < b) (z : ℤ) : clog b ((b : R) ^ z : R) = z := by\n  rw [← neg_log_inv_eq_clog, ← zpow_neg, log_zpow hb, neg_neg]\n\n"}
{"name":"Int.clog_mono_right","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nb : Nat\nr₁ r₂ : R\nh₀ : LT.lt 0 r₁\nh : LE.le r₁ r₂\n⊢ LE.le (Int.clog b r₁) (Int.clog b r₂)","decl":"@[mono]\ntheorem clog_mono_right {b : ℕ} {r₁ r₂ : R} (h₀ : 0 < r₁) (h : r₁ ≤ r₂) :\n    clog b r₁ ≤ clog b r₂ := by\n  rw [← neg_log_inv_eq_clog, ← neg_log_inv_eq_clog, neg_le_neg_iff]\n  exact log_mono_right (inv_pos.mpr <| h₀.trans_le h) (inv_anti₀ h₀ h)\n\n"}
{"name":"Int.zpow_lt_iff_lt_clog","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nb : Nat\nhb : LT.lt 1 b\nx : Int\nr : R\nhr : LT.lt 0 r\n⊢ Iff (LT.lt (HPow.hPow (↑b) x) r) (LT.lt x (Int.clog b r))","decl":"/-- `Int.clog b` and `zpow b` (almost) form a Galois connection. -/\ntheorem zpow_lt_iff_lt_clog {b : ℕ} (hb : 1 < b) {x : ℤ} {r : R} (hr : 0 < r) :\n    (b : R) ^ x < r ↔ x < clog b r :=\n  (@GaloisConnection.lt_iff_lt _ _ _ _ _ _ (clogZPowGi R hb).gc ⟨r, hr⟩ x).symm\n\n"}
{"name":"Int.le_zpow_iff_clog_le","module":"Mathlib.Data.Int.Log","initialProofState":"R : Type u_1\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : FloorSemiring R\nb : Nat\nhb : LT.lt 1 b\nx : Int\nr : R\nhr : LT.lt 0 r\n⊢ Iff (LE.le r (HPow.hPow (↑b) x)) (LE.le (Int.clog b r) x)","decl":"/-- `Int.clog b` and `zpow b` (almost) form a Galois connection. -/\ntheorem le_zpow_iff_clog_le {b : ℕ} (hb : 1 < b) {x : ℤ} {r : R} (hr : 0 < r) :\n    r ≤ (b : R) ^ x ↔ clog b r ≤ x :=\n  (@GaloisConnection.le_iff_le _ _ _ _ _ _ (clogZPowGi R hb).gc ⟨r, hr⟩ x).symm\n\n"}
