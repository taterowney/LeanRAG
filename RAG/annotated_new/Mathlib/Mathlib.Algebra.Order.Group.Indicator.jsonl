{"name":"Function.mulSupport_sup","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : One M\ninst✝ : SemilatticeSup M\nf g : α → M\n⊢ HasSubset.Subset (Function.mulSupport fun x => Max.max (f x) (g x)) (Union.union (Function.mulSupport f) (Function.mulSupport g))","decl":"@[to_additive]\nlemma mulSupport_sup [SemilatticeSup M] (f g : α → M) :\n    mulSupport (fun x ↦ f x ⊔ g x) ⊆ mulSupport f ∪ mulSupport g :=\n  mulSupport_binop_subset (· ⊔ ·) (sup_idem _) f g\n\n"}
{"name":"Function.support_sup","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : Zero M\ninst✝ : SemilatticeSup M\nf g : α → M\n⊢ HasSubset.Subset (Function.support fun x => Max.max (f x) (g x)) (Union.union (Function.support f) (Function.support g))","decl":"@[to_additive]\nlemma mulSupport_sup [SemilatticeSup M] (f g : α → M) :\n    mulSupport (fun x ↦ f x ⊔ g x) ⊆ mulSupport f ∪ mulSupport g :=\n  mulSupport_binop_subset (· ⊔ ·) (sup_idem _) f g\n\n"}
{"name":"Function.mulSupport_inf","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : One M\ninst✝ : SemilatticeInf M\nf g : α → M\n⊢ HasSubset.Subset (Function.mulSupport fun x => Min.min (f x) (g x)) (Union.union (Function.mulSupport f) (Function.mulSupport g))","decl":"@[to_additive]\nlemma mulSupport_inf [SemilatticeInf M] (f g : α → M) :\n    mulSupport (fun x ↦ f x ⊓ g x) ⊆ mulSupport f ∪ mulSupport g :=\n  mulSupport_binop_subset (· ⊓ ·) (inf_idem _) f g\n\n"}
{"name":"Function.support_inf","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : Zero M\ninst✝ : SemilatticeInf M\nf g : α → M\n⊢ HasSubset.Subset (Function.support fun x => Min.min (f x) (g x)) (Union.union (Function.support f) (Function.support g))","decl":"@[to_additive]\nlemma mulSupport_inf [SemilatticeInf M] (f g : α → M) :\n    mulSupport (fun x ↦ f x ⊓ g x) ⊆ mulSupport f ∪ mulSupport g :=\n  mulSupport_binop_subset (· ⊓ ·) (inf_idem _) f g\n\n"}
{"name":"Function.support_max","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : Zero M\ninst✝ : LinearOrder M\nf g : α → M\n⊢ HasSubset.Subset (Function.support fun x => Max.max (f x) (g x)) (Union.union (Function.support f) (Function.support g))","decl":"@[to_additive]\nlemma mulSupport_max [LinearOrder M] (f g : α → M) :\n    mulSupport (fun x ↦ max (f x) (g x)) ⊆ mulSupport f ∪ mulSupport g := mulSupport_sup f g\n\n"}
{"name":"Function.mulSupport_max","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : One M\ninst✝ : LinearOrder M\nf g : α → M\n⊢ HasSubset.Subset (Function.mulSupport fun x => Max.max (f x) (g x)) (Union.union (Function.mulSupport f) (Function.mulSupport g))","decl":"@[to_additive]\nlemma mulSupport_max [LinearOrder M] (f g : α → M) :\n    mulSupport (fun x ↦ max (f x) (g x)) ⊆ mulSupport f ∪ mulSupport g := mulSupport_sup f g\n\n"}
{"name":"Function.mulSupport_min","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : One M\ninst✝ : LinearOrder M\nf g : α → M\n⊢ HasSubset.Subset (Function.mulSupport fun x => Min.min (f x) (g x)) (Union.union (Function.mulSupport f) (Function.mulSupport g))","decl":"@[to_additive]\nlemma mulSupport_min [LinearOrder M] (f g : α → M) :\n    mulSupport (fun x ↦ min (f x) (g x)) ⊆ mulSupport f ∪ mulSupport g := mulSupport_inf f g\n\n"}
{"name":"Function.support_min","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : Zero M\ninst✝ : LinearOrder M\nf g : α → M\n⊢ HasSubset.Subset (Function.support fun x => Min.min (f x) (g x)) (Union.union (Function.support f) (Function.support g))","decl":"@[to_additive]\nlemma mulSupport_min [LinearOrder M] (f g : α → M) :\n    mulSupport (fun x ↦ min (f x) (g x)) ⊆ mulSupport f ∪ mulSupport g := mulSupport_inf f g\n\n"}
{"name":"Function.support_iSup","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"ι : Sort u_1\nα : Type u_2\nM : Type u_3\ninst✝² : Zero M\ninst✝¹ : ConditionallyCompleteLattice M\ninst✝ : Nonempty ι\nf : ι → α → M\n⊢ HasSubset.Subset (Function.support fun x => iSup fun i => f i x) (Set.iUnion fun i => Function.support (f i))","decl":"@[to_additive]\nlemma mulSupport_iSup [ConditionallyCompleteLattice M] [Nonempty ι] (f : ι → α → M) :\n    mulSupport (fun x ↦ ⨆ i, f i x) ⊆ ⋃ i, mulSupport (f i) := by\n  simp only [mulSupport_subset_iff', mem_iUnion, not_exists, nmem_mulSupport]\n  intro x hx\n  simp only [hx, ciSup_const]\n\n"}
{"name":"Function.mulSupport_iSup","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"ι : Sort u_1\nα : Type u_2\nM : Type u_3\ninst✝² : One M\ninst✝¹ : ConditionallyCompleteLattice M\ninst✝ : Nonempty ι\nf : ι → α → M\n⊢ HasSubset.Subset (Function.mulSupport fun x => iSup fun i => f i x) (Set.iUnion fun i => Function.mulSupport (f i))","decl":"@[to_additive]\nlemma mulSupport_iSup [ConditionallyCompleteLattice M] [Nonempty ι] (f : ι → α → M) :\n    mulSupport (fun x ↦ ⨆ i, f i x) ⊆ ⋃ i, mulSupport (f i) := by\n  simp only [mulSupport_subset_iff', mem_iUnion, not_exists, nmem_mulSupport]\n  intro x hx\n  simp only [hx, ciSup_const]\n\n"}
{"name":"Function.support_iInf","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"ι : Sort u_1\nα : Type u_2\nM : Type u_3\ninst✝² : Zero M\ninst✝¹ : ConditionallyCompleteLattice M\ninst✝ : Nonempty ι\nf : ι → α → M\n⊢ HasSubset.Subset (Function.support fun x => iInf fun i => f i x) (Set.iUnion fun i => Function.support (f i))","decl":"@[to_additive]\nlemma mulSupport_iInf [ConditionallyCompleteLattice M] [Nonempty ι] (f : ι → α → M) :\n    mulSupport (fun x ↦ ⨅ i, f i x) ⊆ ⋃ i, mulSupport (f i) := mulSupport_iSup (M := Mᵒᵈ) f\n\n"}
{"name":"Function.mulSupport_iInf","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"ι : Sort u_1\nα : Type u_2\nM : Type u_3\ninst✝² : One M\ninst✝¹ : ConditionallyCompleteLattice M\ninst✝ : Nonempty ι\nf : ι → α → M\n⊢ HasSubset.Subset (Function.mulSupport fun x => iInf fun i => f i x) (Set.iUnion fun i => Function.mulSupport (f i))","decl":"@[to_additive]\nlemma mulSupport_iInf [ConditionallyCompleteLattice M] [Nonempty ι] (f : ι → α → M) :\n    mulSupport (fun x ↦ ⨅ i, f i x) ⊆ ⋃ i, mulSupport (f i) := mulSupport_iSup (M := Mᵒᵈ) f\n\n"}
{"name":"Set.indicator_apply_le'","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : LE M\ninst✝ : Zero M\ns : Set α\nf : α → M\na : α\ny : M\nhfg : Membership.mem s a → LE.le (f a) y\nhg : Not (Membership.mem s a) → LE.le 0 y\n⊢ LE.le (s.indicator f a) y","decl":"@[to_additive]\nlemma mulIndicator_apply_le' (hfg : a ∈ s → f a ≤ y) (hg : a ∉ s → 1 ≤ y) :\n    mulIndicator s f a ≤ y := by\n  by_cases ha : a ∈ s\n  · simpa [ha] using hfg ha\n  · simpa [ha] using hg ha\n\n"}
{"name":"Set.mulIndicator_apply_le'","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : LE M\ninst✝ : One M\ns : Set α\nf : α → M\na : α\ny : M\nhfg : Membership.mem s a → LE.le (f a) y\nhg : Not (Membership.mem s a) → LE.le 1 y\n⊢ LE.le (s.mulIndicator f a) y","decl":"@[to_additive]\nlemma mulIndicator_apply_le' (hfg : a ∈ s → f a ≤ y) (hg : a ∉ s → 1 ≤ y) :\n    mulIndicator s f a ≤ y := by\n  by_cases ha : a ∈ s\n  · simpa [ha] using hfg ha\n  · simpa [ha] using hg ha\n\n"}
{"name":"Set.mulIndicator_le'","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : LE M\ninst✝ : One M\ns : Set α\nf g : α → M\nhfg : ∀ (a : α), Membership.mem s a → LE.le (f a) (g a)\nhg : ∀ (a : α), Not (Membership.mem s a) → LE.le 1 (g a)\n⊢ LE.le (s.mulIndicator f) g","decl":"@[to_additive]\nlemma mulIndicator_le' (hfg : ∀ a ∈ s, f a ≤ g a) (hg : ∀ a, a ∉ s → 1 ≤ g a) :\n    mulIndicator s f ≤ g := fun _ ↦ mulIndicator_apply_le' (hfg _) (hg _)\n\n"}
{"name":"Set.indicator_le'","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : LE M\ninst✝ : Zero M\ns : Set α\nf g : α → M\nhfg : ∀ (a : α), Membership.mem s a → LE.le (f a) (g a)\nhg : ∀ (a : α), Not (Membership.mem s a) → LE.le 0 (g a)\n⊢ LE.le (s.indicator f) g","decl":"@[to_additive]\nlemma mulIndicator_le' (hfg : ∀ a ∈ s, f a ≤ g a) (hg : ∀ a, a ∉ s → 1 ≤ g a) :\n    mulIndicator s f ≤ g := fun _ ↦ mulIndicator_apply_le' (hfg _) (hg _)\n\n"}
{"name":"Set.le_mulIndicator_apply","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : LE M\ninst✝ : One M\ns : Set α\ng : α → M\na : α\ny : M\nhfg : Membership.mem s a → LE.le y (g a)\nhf : Not (Membership.mem s a) → LE.le y 1\n⊢ LE.le y (s.mulIndicator g a)","decl":"@[to_additive]\nlemma le_mulIndicator_apply (hfg : a ∈ s → y ≤ g a) (hf : a ∉ s → y ≤ 1) :\n    y ≤ mulIndicator s g a := mulIndicator_apply_le' (M := Mᵒᵈ) hfg hf\n\n"}
{"name":"Set.le_indicator_apply","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : LE M\ninst✝ : Zero M\ns : Set α\ng : α → M\na : α\ny : M\nhfg : Membership.mem s a → LE.le y (g a)\nhf : Not (Membership.mem s a) → LE.le y 0\n⊢ LE.le y (s.indicator g a)","decl":"@[to_additive]\nlemma le_mulIndicator_apply (hfg : a ∈ s → y ≤ g a) (hf : a ∉ s → y ≤ 1) :\n    y ≤ mulIndicator s g a := mulIndicator_apply_le' (M := Mᵒᵈ) hfg hf\n\n"}
{"name":"Set.le_mulIndicator","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : LE M\ninst✝ : One M\ns : Set α\nf g : α → M\nhfg : ∀ (a : α), Membership.mem s a → LE.le (f a) (g a)\nhf : ∀ (a : α), Not (Membership.mem s a) → LE.le (f a) 1\n⊢ LE.le f (s.mulIndicator g)","decl":"@[to_additive]\nlemma le_mulIndicator (hfg : ∀ a ∈ s, f a ≤ g a) (hf : ∀ a ∉ s, f a ≤ 1) :\n    f ≤ mulIndicator s g := fun _ ↦ le_mulIndicator_apply (hfg _) (hf _)\n\n"}
{"name":"Set.le_indicator","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : LE M\ninst✝ : Zero M\ns : Set α\nf g : α → M\nhfg : ∀ (a : α), Membership.mem s a → LE.le (f a) (g a)\nhf : ∀ (a : α), Not (Membership.mem s a) → LE.le (f a) 0\n⊢ LE.le f (s.indicator g)","decl":"@[to_additive]\nlemma le_mulIndicator (hfg : ∀ a ∈ s, f a ≤ g a) (hf : ∀ a ∉ s, f a ≤ 1) :\n    f ≤ mulIndicator s g := fun _ ↦ le_mulIndicator_apply (hfg _) (hf _)\n\n"}
{"name":"Set.indicator_apply_nonneg","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : Preorder M\ninst✝ : Zero M\ns : Set α\nf : α → M\na : α\nh : Membership.mem s a → LE.le 0 (f a)\n⊢ LE.le 0 (s.indicator f a)","decl":"@[to_additive indicator_apply_nonneg]\nlemma one_le_mulIndicator_apply (h : a ∈ s → 1 ≤ f a) : 1 ≤ mulIndicator s f a :=\n  le_mulIndicator_apply h fun _ ↦ le_rfl\n\n"}
{"name":"Set.one_le_mulIndicator_apply","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : Preorder M\ninst✝ : One M\ns : Set α\nf : α → M\na : α\nh : Membership.mem s a → LE.le 1 (f a)\n⊢ LE.le 1 (s.mulIndicator f a)","decl":"@[to_additive indicator_apply_nonneg]\nlemma one_le_mulIndicator_apply (h : a ∈ s → 1 ≤ f a) : 1 ≤ mulIndicator s f a :=\n  le_mulIndicator_apply h fun _ ↦ le_rfl\n\n"}
{"name":"Set.one_le_mulIndicator","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : Preorder M\ninst✝ : One M\ns : Set α\nf : α → M\nh : ∀ (a : α), Membership.mem s a → LE.le 1 (f a)\na : α\n⊢ LE.le 1 (s.mulIndicator f a)","decl":"@[to_additive indicator_nonneg]\nlemma one_le_mulIndicator (h : ∀ a ∈ s, 1 ≤ f a) (a : α) : 1 ≤ mulIndicator s f a :=\n  one_le_mulIndicator_apply (h a)\n\n"}
{"name":"Set.indicator_nonneg","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : Preorder M\ninst✝ : Zero M\ns : Set α\nf : α → M\nh : ∀ (a : α), Membership.mem s a → LE.le 0 (f a)\na : α\n⊢ LE.le 0 (s.indicator f a)","decl":"@[to_additive indicator_nonneg]\nlemma one_le_mulIndicator (h : ∀ a ∈ s, 1 ≤ f a) (a : α) : 1 ≤ mulIndicator s f a :=\n  one_le_mulIndicator_apply (h a)\n\n"}
{"name":"Set.indicator_apply_nonpos","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : Preorder M\ninst✝ : Zero M\ns : Set α\nf : α → M\na : α\nh : Membership.mem s a → LE.le (f a) 0\n⊢ LE.le (s.indicator f a) 0","decl":"@[to_additive]\nlemma mulIndicator_apply_le_one (h : a ∈ s → f a ≤ 1) : mulIndicator s f a ≤ 1 :=\n  mulIndicator_apply_le' h fun _ ↦ le_rfl\n\n"}
{"name":"Set.mulIndicator_apply_le_one","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : Preorder M\ninst✝ : One M\ns : Set α\nf : α → M\na : α\nh : Membership.mem s a → LE.le (f a) 1\n⊢ LE.le (s.mulIndicator f a) 1","decl":"@[to_additive]\nlemma mulIndicator_apply_le_one (h : a ∈ s → f a ≤ 1) : mulIndicator s f a ≤ 1 :=\n  mulIndicator_apply_le' h fun _ ↦ le_rfl\n\n"}
{"name":"Set.mulIndicator_le_one","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : Preorder M\ninst✝ : One M\ns : Set α\nf : α → M\nh : ∀ (a : α), Membership.mem s a → LE.le (f a) 1\na : α\n⊢ LE.le (s.mulIndicator f a) 1","decl":"@[to_additive]\nlemma mulIndicator_le_one (h : ∀ a ∈ s, f a ≤ 1) (a : α) : mulIndicator s f a ≤ 1 :=\n  mulIndicator_apply_le_one (h a)\n\n"}
{"name":"Set.indicator_nonpos","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : Preorder M\ninst✝ : Zero M\ns : Set α\nf : α → M\nh : ∀ (a : α), Membership.mem s a → LE.le (f a) 0\na : α\n⊢ LE.le (s.indicator f a) 0","decl":"@[to_additive]\nlemma mulIndicator_le_one (h : ∀ a ∈ s, f a ≤ 1) (a : α) : mulIndicator s f a ≤ 1 :=\n  mulIndicator_apply_le_one (h a)\n\n"}
{"name":"Set.mulIndicator_le_mulIndicator'","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : Preorder M\ninst✝ : One M\ns : Set α\nf g : α → M\na : α\nh : Membership.mem s a → LE.le (f a) (g a)\n⊢ LE.le (s.mulIndicator f a) (s.mulIndicator g a)","decl":"@[to_additive]\nlemma mulIndicator_le_mulIndicator' (h : a ∈ s → f a ≤ g a) :\n    mulIndicator s f a ≤ mulIndicator s g a :=\n  mulIndicator_rel_mulIndicator le_rfl h\n\n"}
{"name":"Set.indicator_le_indicator'","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : Preorder M\ninst✝ : Zero M\ns : Set α\nf g : α → M\na : α\nh : Membership.mem s a → LE.le (f a) (g a)\n⊢ LE.le (s.indicator f a) (s.indicator g a)","decl":"@[to_additive]\nlemma mulIndicator_le_mulIndicator' (h : a ∈ s → f a ≤ g a) :\n    mulIndicator s f a ≤ mulIndicator s g a :=\n  mulIndicator_rel_mulIndicator le_rfl h\n\n"}
{"name":"Set.indicator_le_indicator","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : Preorder M\ninst✝ : Zero M\ns : Set α\nf g : α → M\na : α\nh : LE.le (f a) (g a)\n⊢ LE.le (s.indicator f a) (s.indicator g a)","decl":"@[to_additive (attr := mono, gcongr)]\nlemma mulIndicator_le_mulIndicator (h : f a ≤ g a) : mulIndicator s f a ≤ mulIndicator s g a :=\n  mulIndicator_rel_mulIndicator le_rfl fun _ ↦ h\n\n"}
{"name":"Set.mulIndicator_le_mulIndicator","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : Preorder M\ninst✝ : One M\ns : Set α\nf g : α → M\na : α\nh : LE.le (f a) (g a)\n⊢ LE.le (s.mulIndicator f a) (s.mulIndicator g a)","decl":"@[to_additive (attr := mono, gcongr)]\nlemma mulIndicator_le_mulIndicator (h : f a ≤ g a) : mulIndicator s f a ≤ mulIndicator s g a :=\n  mulIndicator_rel_mulIndicator le_rfl fun _ ↦ h\n\n"}
{"name":"Set.indicator_mono","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : Preorder M\ninst✝ : Zero M\ns : Set α\nf g : α → M\nh : LE.le f g\n⊢ LE.le (s.indicator f) (s.indicator g)","decl":"@[to_additive (attr := gcongr)]\nlemma mulIndicator_mono (h : f ≤ g) : s.mulIndicator f ≤ s.mulIndicator g :=\n  fun _ ↦ mulIndicator_le_mulIndicator (h _)\n\n"}
{"name":"Set.mulIndicator_mono","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : Preorder M\ninst✝ : One M\ns : Set α\nf g : α → M\nh : LE.le f g\n⊢ LE.le (s.mulIndicator f) (s.mulIndicator g)","decl":"@[to_additive (attr := gcongr)]\nlemma mulIndicator_mono (h : f ≤ g) : s.mulIndicator f ≤ s.mulIndicator g :=\n  fun _ ↦ mulIndicator_le_mulIndicator (h _)\n\n"}
{"name":"Set.mulIndicator_le_mulIndicator_apply_of_subset","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : Preorder M\ninst✝ : One M\ns t : Set α\nf : α → M\na : α\nh : HasSubset.Subset s t\nhf : LE.le 1 (f a)\n⊢ LE.le (s.mulIndicator f a) (t.mulIndicator f a)","decl":"@[to_additive]\nlemma mulIndicator_le_mulIndicator_apply_of_subset (h : s ⊆ t) (hf : 1 ≤ f a) :\n    mulIndicator s f a ≤ mulIndicator t f a :=\n  mulIndicator_apply_le'\n    (fun ha ↦ le_mulIndicator_apply (fun _ ↦ le_rfl) fun hat ↦ (hat <| h ha).elim) fun _ ↦\n    one_le_mulIndicator_apply fun _ ↦ hf\n\n"}
{"name":"Set.indicator_le_indicator_apply_of_subset","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : Preorder M\ninst✝ : Zero M\ns t : Set α\nf : α → M\na : α\nh : HasSubset.Subset s t\nhf : LE.le 0 (f a)\n⊢ LE.le (s.indicator f a) (t.indicator f a)","decl":"@[to_additive]\nlemma mulIndicator_le_mulIndicator_apply_of_subset (h : s ⊆ t) (hf : 1 ≤ f a) :\n    mulIndicator s f a ≤ mulIndicator t f a :=\n  mulIndicator_apply_le'\n    (fun ha ↦ le_mulIndicator_apply (fun _ ↦ le_rfl) fun hat ↦ (hat <| h ha).elim) fun _ ↦\n    one_le_mulIndicator_apply fun _ ↦ hf\n\n"}
{"name":"Set.mulIndicator_le_mulIndicator_of_subset","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : Preorder M\ninst✝ : One M\ns t : Set α\nf : α → M\nh : HasSubset.Subset s t\nhf : LE.le 1 f\n⊢ LE.le (s.mulIndicator f) (t.mulIndicator f)","decl":"@[to_additive]\nlemma mulIndicator_le_mulIndicator_of_subset (h : s ⊆ t) (hf : 1 ≤ f) :\n    mulIndicator s f ≤ mulIndicator t f :=\n  fun _ ↦ mulIndicator_le_mulIndicator_apply_of_subset h (hf _)\n\n"}
{"name":"Set.indicator_le_indicator_of_subset","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : Preorder M\ninst✝ : Zero M\ns t : Set α\nf : α → M\nh : HasSubset.Subset s t\nhf : LE.le 0 f\n⊢ LE.le (s.indicator f) (t.indicator f)","decl":"@[to_additive]\nlemma mulIndicator_le_mulIndicator_of_subset (h : s ⊆ t) (hf : 1 ≤ f) :\n    mulIndicator s f ≤ mulIndicator t f :=\n  fun _ ↦ mulIndicator_le_mulIndicator_apply_of_subset h (hf _)\n\n"}
{"name":"Set.indicator_le_self'","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : Preorder M\ninst✝ : Zero M\ns : Set α\nf : α → M\nhf : ∀ (x : α), Not (Membership.mem s x) → LE.le 0 (f x)\n⊢ LE.le (s.indicator f) f","decl":"@[to_additive]\nlemma mulIndicator_le_self' (hf : ∀ x ∉ s, 1 ≤ f x) : mulIndicator s f ≤ f :=\n  mulIndicator_le' (fun _ _ ↦ le_rfl) hf\n\n"}
{"name":"Set.mulIndicator_le_self'","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : Preorder M\ninst✝ : One M\ns : Set α\nf : α → M\nhf : ∀ (x : α), Not (Membership.mem s x) → LE.le 1 (f x)\n⊢ LE.le (s.mulIndicator f) f","decl":"@[to_additive]\nlemma mulIndicator_le_self' (hf : ∀ x ∉ s, 1 ≤ f x) : mulIndicator s f ≤ f :=\n  mulIndicator_le' (fun _ _ ↦ le_rfl) hf\n\n"}
{"name":"Set.indicator_le_indicator_nonneg","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : Zero M\ninst✝ : LinearOrder M\ns : Set α\nf : α → M\n⊢ LE.le (s.indicator f) ((setOf fun a => LE.le 0 (f a)).indicator f)","decl":"lemma indicator_le_indicator_nonneg (s : Set α) (f : α → M) :\n    s.indicator f ≤ {a | 0 ≤ f a}.indicator f := by\n  intro a\n  classical\n  simp_rw [indicator_apply]\n  split_ifs\n  exacts [le_rfl, (not_le.1 ‹_›).le, ‹_›, le_rfl]\n\n"}
{"name":"Set.indicator_nonpos_le_indicator","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝¹ : Zero M\ninst✝ : LinearOrder M\ns : Set α\nf : α → M\n⊢ LE.le ((setOf fun a => LE.le (f a) 0).indicator f) (s.indicator f)","decl":"lemma indicator_nonpos_le_indicator (s : Set α) (f : α → M) :\n    {a | f a ≤ 0}.indicator f ≤ s.indicator f :=\n  indicator_le_indicator_nonneg (M := Mᵒᵈ) _ _\n\n"}
{"name":"Set.indicator_iUnion_apply","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"ι : Sort u_1\nα : Type u_2\nM : Type u_3\ninst✝¹ : CompleteLattice M\ninst✝ : Zero M\nh1 : Eq Bot.bot 0\ns : ι → Set α\nf : α → M\nx : α\n⊢ Eq ((Set.iUnion fun i => s i).indicator f x) (iSup fun i => (s i).indicator f x)","decl":"@[to_additive]\nlemma mulIndicator_iUnion_apply (h1 : (⊥ : M) = 1) (s : ι → Set α) (f : α → M) (x : α) :\n    mulIndicator (⋃ i, s i) f x = ⨆ i, mulIndicator (s i) f x := by\n  by_cases hx : x ∈ ⋃ i, s i\n  · rw [mulIndicator_of_mem hx]\n    rw [mem_iUnion] at hx\n    refine le_antisymm ?_ (iSup_le fun i ↦ mulIndicator_le_self' (fun x _ ↦ h1 ▸ bot_le) x)\n    rcases hx with ⟨i, hi⟩\n    exact le_iSup_of_le i (ge_of_eq <| mulIndicator_of_mem hi _)\n  · rw [mulIndicator_of_not_mem hx]\n    simp only [mem_iUnion, not_exists] at hx\n    simp [hx, ← h1]\n\n"}
{"name":"Set.mulIndicator_iUnion_apply","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"ι : Sort u_1\nα : Type u_2\nM : Type u_3\ninst✝¹ : CompleteLattice M\ninst✝ : One M\nh1 : Eq Bot.bot 1\ns : ι → Set α\nf : α → M\nx : α\n⊢ Eq ((Set.iUnion fun i => s i).mulIndicator f x) (iSup fun i => (s i).mulIndicator f x)","decl":"@[to_additive]\nlemma mulIndicator_iUnion_apply (h1 : (⊥ : M) = 1) (s : ι → Set α) (f : α → M) (x : α) :\n    mulIndicator (⋃ i, s i) f x = ⨆ i, mulIndicator (s i) f x := by\n  by_cases hx : x ∈ ⋃ i, s i\n  · rw [mulIndicator_of_mem hx]\n    rw [mem_iUnion] at hx\n    refine le_antisymm ?_ (iSup_le fun i ↦ mulIndicator_le_self' (fun x _ ↦ h1 ▸ bot_le) x)\n    rcases hx with ⟨i, hi⟩\n    exact le_iSup_of_le i (ge_of_eq <| mulIndicator_of_mem hi _)\n  · rw [mulIndicator_of_not_mem hx]\n    simp only [mem_iUnion, not_exists] at hx\n    simp [hx, ← h1]\n\n"}
{"name":"Set.indicator_iInter_apply","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"ι : Sort u_1\nα : Type u_2\nM : Type u_3\ninst✝² : CompleteLattice M\ninst✝¹ : Zero M\ninst✝ : Nonempty ι\nh1 : Eq Bot.bot 0\ns : ι → Set α\nf : α → M\nx : α\n⊢ Eq ((Set.iInter fun i => s i).indicator f x) (iInf fun i => (s i).indicator f x)","decl":"@[to_additive]\nlemma mulIndicator_iInter_apply (h1 : (⊥ : M) = 1) (s : ι → Set α) (f : α → M) (x : α) :\n    mulIndicator (⋂ i, s i) f x = ⨅ i, mulIndicator (s i) f x := by\n  by_cases hx : x ∈ ⋂ i, s i\n  · rw [mulIndicator_of_mem hx]\n    rw [mem_iInter] at hx\n    refine le_antisymm ?_ (by simp only [mulIndicator_of_mem (hx _), ciInf_const, le_refl])\n    exact le_iInf (fun j ↦ by simp only [mulIndicator_of_mem (hx j), le_refl])\n  · rw [mulIndicator_of_not_mem hx]\n    simp only [mem_iInter, not_exists, not_forall] at hx\n    rcases hx with ⟨j, hj⟩\n    refine le_antisymm (by simp only [← h1, le_iInf_iff, bot_le, forall_const]) ?_\n    simpa [mulIndicator_of_not_mem hj] using (iInf_le (fun i ↦ (s i).mulIndicator f) j) x\n\n"}
{"name":"Set.mulIndicator_iInter_apply","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"ι : Sort u_1\nα : Type u_2\nM : Type u_3\ninst✝² : CompleteLattice M\ninst✝¹ : One M\ninst✝ : Nonempty ι\nh1 : Eq Bot.bot 1\ns : ι → Set α\nf : α → M\nx : α\n⊢ Eq ((Set.iInter fun i => s i).mulIndicator f x) (iInf fun i => (s i).mulIndicator f x)","decl":"@[to_additive]\nlemma mulIndicator_iInter_apply (h1 : (⊥ : M) = 1) (s : ι → Set α) (f : α → M) (x : α) :\n    mulIndicator (⋂ i, s i) f x = ⨅ i, mulIndicator (s i) f x := by\n  by_cases hx : x ∈ ⋂ i, s i\n  · rw [mulIndicator_of_mem hx]\n    rw [mem_iInter] at hx\n    refine le_antisymm ?_ (by simp only [mulIndicator_of_mem (hx _), ciInf_const, le_refl])\n    exact le_iInf (fun j ↦ by simp only [mulIndicator_of_mem (hx j), le_refl])\n  · rw [mulIndicator_of_not_mem hx]\n    simp only [mem_iInter, not_exists, not_forall] at hx\n    rcases hx with ⟨j, hj⟩\n    refine le_antisymm (by simp only [← h1, le_iInf_iff, bot_le, forall_const]) ?_\n    simpa [mulIndicator_of_not_mem hj] using (iInf_le (fun i ↦ (s i).mulIndicator f) j) x\n\n"}
{"name":"Set.iSup_mulIndicator","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝³ : CompleteLattice M\ninst✝² : One M\nι : Type u_4\ninst✝¹ : Preorder ι\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nf : ι → α → M\ns : ι → Set α\nh1 : Eq Bot.bot 1\nhf : Monotone f\nhs : Monotone s\n⊢ Eq (iSup fun i => (s i).mulIndicator (f i)) ((Set.iUnion fun i => s i).mulIndicator (iSup fun i => f i))","decl":"@[to_additive]\nlemma iSup_mulIndicator {ι : Type*} [Preorder ι] [IsDirected ι (· ≤ ·)] {f : ι → α → M}\n    {s : ι → Set α} (h1 : (⊥ : M) = 1) (hf : Monotone f) (hs : Monotone s) :\n    ⨆ i, (s i).mulIndicator (f i) = (⋃ i, s i).mulIndicator (⨆ i, f i) := by\n  simp only [le_antisymm_iff, iSup_le_iff]\n  refine ⟨fun i ↦ (mulIndicator_mono (le_iSup _ _)).trans (mulIndicator_le_mulIndicator_of_subset\n    (subset_iUnion _ _) (fun _ ↦ by simp [← h1])), fun a ↦ ?_⟩\n  by_cases ha : a ∈ ⋃ i, s i\n  · obtain ⟨i, hi⟩ : ∃ i, a ∈ s i := by simpa using ha\n    rw [mulIndicator_of_mem ha, iSup_apply, iSup_apply]\n    refine iSup_le fun j ↦ ?_\n    obtain ⟨k, hik, hjk⟩ := exists_ge_ge i j\n    refine le_iSup_of_le k <| (hf hjk _).trans_eq ?_\n    rw [mulIndicator_of_mem (hs hik hi)]\n  · rw [mulIndicator_of_not_mem ha, ← h1]\n    exact bot_le\n\n"}
{"name":"Set.iSup_indicator","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝³ : CompleteLattice M\ninst✝² : Zero M\nι : Type u_4\ninst✝¹ : Preorder ι\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nf : ι → α → M\ns : ι → Set α\nh1 : Eq Bot.bot 0\nhf : Monotone f\nhs : Monotone s\n⊢ Eq (iSup fun i => (s i).indicator (f i)) ((Set.iUnion fun i => s i).indicator (iSup fun i => f i))","decl":"@[to_additive]\nlemma iSup_mulIndicator {ι : Type*} [Preorder ι] [IsDirected ι (· ≤ ·)] {f : ι → α → M}\n    {s : ι → Set α} (h1 : (⊥ : M) = 1) (hf : Monotone f) (hs : Monotone s) :\n    ⨆ i, (s i).mulIndicator (f i) = (⋃ i, s i).mulIndicator (⨆ i, f i) := by\n  simp only [le_antisymm_iff, iSup_le_iff]\n  refine ⟨fun i ↦ (mulIndicator_mono (le_iSup _ _)).trans (mulIndicator_le_mulIndicator_of_subset\n    (subset_iUnion _ _) (fun _ ↦ by simp [← h1])), fun a ↦ ?_⟩\n  by_cases ha : a ∈ ⋃ i, s i\n  · obtain ⟨i, hi⟩ : ∃ i, a ∈ s i := by simpa using ha\n    rw [mulIndicator_of_mem ha, iSup_apply, iSup_apply]\n    refine iSup_le fun j ↦ ?_\n    obtain ⟨k, hik, hjk⟩ := exists_ge_ge i j\n    refine le_iSup_of_le k <| (hf hjk _).trans_eq ?_\n    rw [mulIndicator_of_mem (hs hik hi)]\n  · rw [mulIndicator_of_not_mem ha, ← h1]\n    exact bot_le\n\n"}
{"name":"Set.indicator_le_self","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : PartialOrder M\ninst✝ : CanonicallyOrderedAdd M\ns : Set α\nf : α → M\n⊢ LE.le (s.indicator f) f","decl":"@[to_additive]\nlemma mulIndicator_le_self (s : Set α) (f : α → M) : mulIndicator s f ≤ f :=\n  mulIndicator_le_self' fun _ _ ↦ one_le _\n\n"}
{"name":"Set.mulIndicator_le_self","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝² : Monoid M\ninst✝¹ : PartialOrder M\ninst✝ : CanonicallyOrderedMul M\ns : Set α\nf : α → M\n⊢ LE.le (s.mulIndicator f) f","decl":"@[to_additive]\nlemma mulIndicator_le_self (s : Set α) (f : α → M) : mulIndicator s f ≤ f :=\n  mulIndicator_le_self' fun _ _ ↦ one_le _\n\n"}
{"name":"Set.indicator_apply_le","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : PartialOrder M\ninst✝ : CanonicallyOrderedAdd M\na : α\ns : Set α\nf g : α → M\nhfg : Membership.mem s a → LE.le (f a) (g a)\n⊢ LE.le (s.indicator f a) (g a)","decl":"@[to_additive]\nlemma mulIndicator_apply_le {a : α} {s : Set α} {f g : α → M} (hfg : a ∈ s → f a ≤ g a) :\n    mulIndicator s f a ≤ g a :=\n  mulIndicator_apply_le' hfg fun _ ↦ one_le _\n\n"}
{"name":"Set.mulIndicator_apply_le","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝² : Monoid M\ninst✝¹ : PartialOrder M\ninst✝ : CanonicallyOrderedMul M\na : α\ns : Set α\nf g : α → M\nhfg : Membership.mem s a → LE.le (f a) (g a)\n⊢ LE.le (s.mulIndicator f a) (g a)","decl":"@[to_additive]\nlemma mulIndicator_apply_le {a : α} {s : Set α} {f g : α → M} (hfg : a ∈ s → f a ≤ g a) :\n    mulIndicator s f a ≤ g a :=\n  mulIndicator_apply_le' hfg fun _ ↦ one_le _\n\n"}
{"name":"Set.indicator_le","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : PartialOrder M\ninst✝ : CanonicallyOrderedAdd M\ns : Set α\nf g : α → M\nhfg : ∀ (a : α), Membership.mem s a → LE.le (f a) (g a)\n⊢ LE.le (s.indicator f) g","decl":"@[to_additive]\nlemma mulIndicator_le {s : Set α} {f g : α → M} (hfg : ∀ a ∈ s, f a ≤ g a) :\n    mulIndicator s f ≤ g :=\n  mulIndicator_le' hfg fun _ _ ↦ one_le _\n\n"}
{"name":"Set.mulIndicator_le","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝² : Monoid M\ninst✝¹ : PartialOrder M\ninst✝ : CanonicallyOrderedMul M\ns : Set α\nf g : α → M\nhfg : ∀ (a : α), Membership.mem s a → LE.le (f a) (g a)\n⊢ LE.le (s.mulIndicator f) g","decl":"@[to_additive]\nlemma mulIndicator_le {s : Set α} {f g : α → M} (hfg : ∀ a ∈ s, f a ≤ g a) :\n    mulIndicator s f ≤ g :=\n  mulIndicator_le' hfg fun _ _ ↦ one_le _\n\n"}
{"name":"Set.abs_indicator_symmDiff","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝ : LinearOrderedAddCommGroup M\ns t : Set α\nf : α → M\nx : α\n⊢ Eq (abs ((symmDiff s t).indicator f x)) (abs (HSub.hSub (s.indicator f x) (t.indicator f x)))","decl":"@[to_additive]\nlemma mabs_mulIndicator_symmDiff (s t : Set α) (f : α → M) (x : α) :\n    |mulIndicator (s ∆ t) f x|ₘ = |mulIndicator s f x / mulIndicator t f x|ₘ :=\n  apply_mulIndicator_symmDiff mabs_inv s t f x\n\n"}
{"name":"Set.mabs_mulIndicator_symmDiff","module":"Mathlib.Algebra.Order.Group.Indicator","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝ : LinearOrderedCommGroup M\ns t : Set α\nf : α → M\nx : α\n⊢ Eq (mabs ((symmDiff s t).mulIndicator f x)) (mabs (HDiv.hDiv (s.mulIndicator f x) (t.mulIndicator f x)))","decl":"@[to_additive]\nlemma mabs_mulIndicator_symmDiff (s t : Set α) (f : α → M) (x : α) :\n    |mulIndicator (s ∆ t) f x|ₘ = |mulIndicator s f x / mulIndicator t f x|ₘ :=\n  apply_mulIndicator_symmDiff mabs_inv s t f x\n\n"}
