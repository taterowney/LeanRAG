{"name":"supClosed_empty","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeSup α\n⊢ SupClosed EmptyCollection.emptyCollection","decl":"@[simp] lemma supClosed_empty : SupClosed (∅ : Set α) := by simp [SupClosed]\n"}
{"name":"supClosed_singleton","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeSup α\na : α\n⊢ SupClosed (Singleton.singleton a)","decl":"@[simp] lemma supClosed_singleton : SupClosed ({a} : Set α) := by simp [SupClosed]\n\n"}
{"name":"supClosed_univ","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeSup α\n⊢ SupClosed Set.univ","decl":"@[simp] lemma supClosed_univ : SupClosed (univ : Set α) := by simp [SupClosed]\n"}
{"name":"SupClosed.inter","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeSup α\ns t : Set α\nhs : SupClosed s\nht : SupClosed t\n⊢ SupClosed (Inter.inter s t)","decl":"lemma SupClosed.inter (hs : SupClosed s) (ht : SupClosed t) : SupClosed (s ∩ t) :=\n  fun _a ha _b hb ↦ ⟨hs ha.1 hb.1, ht ha.2 hb.2⟩\n\n"}
{"name":"supClosed_sInter","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeSup α\nS : Set (Set α)\nhS : ∀ (s : Set α), Membership.mem S s → SupClosed s\n⊢ SupClosed S.sInter","decl":"lemma supClosed_sInter (hS : ∀ s ∈ S, SupClosed s) : SupClosed (⋂₀ S) :=\n  fun _a ha _b hb _s hs ↦ hS _ hs (ha _ hs) (hb _ hs)\n\n"}
{"name":"supClosed_iInter","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeSup α\nι : Sort u_5\nf : ι → Set α\nhf : ∀ (i : ι), SupClosed (f i)\n⊢ SupClosed (Set.iInter fun i => f i)","decl":"lemma supClosed_iInter (hf : ∀ i, SupClosed (f i)) : SupClosed (⋂ i, f i) :=\n  supClosed_sInter <| forall_mem_range.2 hf\n\n"}
{"name":"SupClosed.directedOn","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeSup α\ns : Set α\nhs : SupClosed s\n⊢ DirectedOn (fun x1 x2 => LE.le x1 x2) s","decl":"lemma SupClosed.directedOn (hs : SupClosed s) : DirectedOn (· ≤ ·) s :=\n  fun _a ha _b hb ↦ ⟨_, hs ha hb, le_sup_left, le_sup_right⟩\n\n"}
{"name":"IsUpperSet.supClosed","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeSup α\ns : Set α\nhs : IsUpperSet s\n⊢ SupClosed s","decl":"lemma IsUpperSet.supClosed (hs : IsUpperSet s) : SupClosed s := fun _a _ _b ↦ hs le_sup_right\n\n"}
{"name":"SupClosed.preimage","module":"Mathlib.Order.SupClosed","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝³ : SemilatticeSup α\ninst✝² : SemilatticeSup β\ns : Set α\ninst✝¹ : FunLike F β α\ninst✝ : SupHomClass F β α\nhs : SupClosed s\nf : F\n⊢ SupClosed (Set.preimage (⇑f) s)","decl":"lemma SupClosed.preimage [FunLike F β α] [SupHomClass F β α] (hs : SupClosed s) (f : F) :\n    SupClosed (f ⁻¹' s) :=\n  fun a ha b hb ↦ by simpa [map_sup] using hs ha hb\n\n"}
{"name":"SupClosed.image","module":"Mathlib.Order.SupClosed","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝³ : SemilatticeSup α\ninst✝² : SemilatticeSup β\ns : Set α\ninst✝¹ : FunLike F α β\ninst✝ : SupHomClass F α β\nhs : SupClosed s\nf : F\n⊢ SupClosed (Set.image (⇑f) s)","decl":"lemma SupClosed.image [FunLike F α β] [SupHomClass F α β] (hs : SupClosed s) (f : F) :\n    SupClosed (f '' s) := by\n  rintro _ ⟨a, ha, rfl⟩ _ ⟨b, hb, rfl⟩\n  rw [← map_sup]\n  exact Set.mem_image_of_mem _ <| hs ha hb\n\n"}
{"name":"supClosed_range","module":"Mathlib.Order.SupClosed","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝³ : SemilatticeSup α\ninst✝² : SemilatticeSup β\ninst✝¹ : FunLike F α β\ninst✝ : SupHomClass F α β\nf : F\n⊢ SupClosed (Set.range ⇑f)","decl":"lemma supClosed_range [FunLike F α β] [SupHomClass F α β] (f : F) : SupClosed (Set.range f) := by\n  simpa using supClosed_univ.image f\n\n"}
{"name":"SupClosed.prod","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : SemilatticeSup α\ninst✝ : SemilatticeSup β\ns : Set α\nt : Set β\nhs : SupClosed s\nht : SupClosed t\n⊢ SupClosed (SProd.sprod s t)","decl":"lemma SupClosed.prod {t : Set β} (hs : SupClosed s) (ht : SupClosed t) : SupClosed (s ×ˢ t) :=\n  fun _a ha _b hb ↦ ⟨hs ha.1 hb.1, ht ha.2 hb.2⟩\n\n"}
{"name":"supClosed_pi","module":"Mathlib.Order.SupClosed","initialProofState":"ι : Type u_6\nα : ι → Type u_7\ninst✝ : (i : ι) → SemilatticeSup (α i)\ns : Set ι\nt : (i : ι) → Set (α i)\nht : ∀ (i : ι), Membership.mem s i → SupClosed (t i)\n⊢ SupClosed (s.pi t)","decl":"lemma supClosed_pi {ι : Type*} {α : ι → Type*} [∀ i, SemilatticeSup (α i)] {s : Set ι}\n    {t : ∀ i, Set (α i)} (ht : ∀ i ∈ s, SupClosed (t i)) : SupClosed (s.pi t) :=\n  fun _a ha _b hb _i hi ↦ ht _ hi (ha _ hi) (hb _ hi)\n\n"}
{"name":"SupClosed.insert_upperBounds","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeSup α\ns : Set α\na : α\nhs : SupClosed s\nha : Membership.mem (upperBounds s) a\n⊢ SupClosed (Insert.insert a s)","decl":"lemma SupClosed.insert_upperBounds {s : Set α} {a : α} (hs : SupClosed s) (ha : a ∈ upperBounds s) :\n    SupClosed (insert a s) := by\n  rw [SupClosed]\n  aesop\n\n"}
{"name":"SupClosed.insert_lowerBounds","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeSup α\ns : Set α\na : α\nh : SupClosed s\nha : Membership.mem (lowerBounds s) a\n⊢ SupClosed (Insert.insert a s)","decl":"lemma SupClosed.insert_lowerBounds {s : Set α} {a : α} (h : SupClosed s) (ha : a ∈ lowerBounds s) :\n    SupClosed (insert a s) := by\n  rw [SupClosed]\n  have ha' : ∀ b ∈ s, a ≤ b := fun _ a ↦ ha a\n  aesop\n\n"}
{"name":"SupClosed.finsetSup'_mem","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeSup α\nι : Type u_5\nf : ι → α\ns : Set α\nt : Finset ι\nhs : SupClosed s\nht : t.Nonempty\na✝ : ∀ (i : ι), Membership.mem t i → Membership.mem s (f i)\n⊢ Membership.mem s (t.sup' ht f)","decl":"lemma SupClosed.finsetSup'_mem (hs : SupClosed s) (ht : t.Nonempty) :\n    (∀ i ∈ t, f i ∈ s) → t.sup' ht f ∈ s :=\n  sup'_induction _ _ hs\n\n"}
{"name":"SupClosed.finsetSup_mem","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝¹ : SemilatticeSup α\nι : Type u_5\nf : ι → α\ns : Set α\nt : Finset ι\ninst✝ : OrderBot α\nhs : SupClosed s\nht : t.Nonempty\na✝ : ∀ (i : ι), Membership.mem t i → Membership.mem s (f i)\n⊢ Membership.mem s (t.sup f)","decl":"lemma SupClosed.finsetSup_mem [OrderBot α] (hs : SupClosed s) (ht : t.Nonempty) :\n    (∀ i ∈ t, f i ∈ s) → t.sup f ∈ s :=\n  sup'_eq_sup ht f ▸ hs.finsetSup'_mem ht\n\n"}
{"name":"infClosed_empty","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeInf α\n⊢ InfClosed EmptyCollection.emptyCollection","decl":"@[simp] lemma infClosed_empty : InfClosed (∅ : Set α) := by simp [InfClosed]\n"}
{"name":"infClosed_singleton","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeInf α\na : α\n⊢ InfClosed (Singleton.singleton a)","decl":"@[simp] lemma infClosed_singleton : InfClosed ({a} : Set α) := by simp [InfClosed]\n\n"}
{"name":"infClosed_univ","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeInf α\n⊢ InfClosed Set.univ","decl":"@[simp] lemma infClosed_univ : InfClosed (univ : Set α) := by simp [InfClosed]\n"}
{"name":"InfClosed.inter","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeInf α\ns t : Set α\nhs : InfClosed s\nht : InfClosed t\n⊢ InfClosed (Inter.inter s t)","decl":"lemma InfClosed.inter (hs : InfClosed s) (ht : InfClosed t) : InfClosed (s ∩ t) :=\n  fun _a ha _b hb ↦ ⟨hs ha.1 hb.1, ht ha.2 hb.2⟩\n\n"}
{"name":"infClosed_sInter","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeInf α\nS : Set (Set α)\nhS : ∀ (s : Set α), Membership.mem S s → InfClosed s\n⊢ InfClosed S.sInter","decl":"lemma infClosed_sInter (hS : ∀ s ∈ S, InfClosed s) : InfClosed (⋂₀ S) :=\n  fun _a ha _b hb _s hs ↦ hS _ hs (ha _ hs) (hb _ hs)\n\n"}
{"name":"infClosed_iInter","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeInf α\nι : Sort u_5\nf : ι → Set α\nhf : ∀ (i : ι), InfClosed (f i)\n⊢ InfClosed (Set.iInter fun i => f i)","decl":"lemma infClosed_iInter (hf : ∀ i, InfClosed (f i)) : InfClosed (⋂ i, f i) :=\n  infClosed_sInter <| forall_mem_range.2 hf\n\n"}
{"name":"InfClosed.codirectedOn","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeInf α\ns : Set α\nhs : InfClosed s\n⊢ DirectedOn (fun x1 x2 => GE.ge x1 x2) s","decl":"lemma InfClosed.codirectedOn (hs : InfClosed s) : DirectedOn (· ≥ ·) s :=\n  fun _a ha _b hb ↦ ⟨_, hs ha hb, inf_le_left, inf_le_right⟩\n\n"}
{"name":"IsLowerSet.infClosed","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeInf α\ns : Set α\nhs : IsLowerSet s\n⊢ InfClosed s","decl":"lemma IsLowerSet.infClosed (hs : IsLowerSet s) : InfClosed s := fun _a _ _b ↦ hs inf_le_right\n\n"}
{"name":"InfClosed.preimage","module":"Mathlib.Order.SupClosed","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝³ : SemilatticeInf α\ninst✝² : SemilatticeInf β\ns : Set α\ninst✝¹ : FunLike F β α\ninst✝ : InfHomClass F β α\nhs : InfClosed s\nf : F\n⊢ InfClosed (Set.preimage (⇑f) s)","decl":"lemma InfClosed.preimage [FunLike F β α] [InfHomClass F β α] (hs : InfClosed s) (f : F) :\n    InfClosed (f ⁻¹' s) :=\n  fun a ha b hb ↦ by simpa [map_inf] using hs ha hb\n\n"}
{"name":"InfClosed.image","module":"Mathlib.Order.SupClosed","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝³ : SemilatticeInf α\ninst✝² : SemilatticeInf β\ns : Set α\ninst✝¹ : FunLike F α β\ninst✝ : InfHomClass F α β\nhs : InfClosed s\nf : F\n⊢ InfClosed (Set.image (⇑f) s)","decl":"lemma InfClosed.image [FunLike F α β] [InfHomClass F α β] (hs : InfClosed s) (f : F) :\n    InfClosed (f '' s) := by\n  rintro _ ⟨a, ha, rfl⟩ _ ⟨b, hb, rfl⟩\n  rw [← map_inf]\n  exact Set.mem_image_of_mem _ <| hs ha hb\n\n"}
{"name":"infClosed_range","module":"Mathlib.Order.SupClosed","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝³ : SemilatticeInf α\ninst✝² : SemilatticeInf β\ninst✝¹ : FunLike F α β\ninst✝ : InfHomClass F α β\nf : F\n⊢ InfClosed (Set.range ⇑f)","decl":"lemma infClosed_range [FunLike F α β] [InfHomClass F α β] (f : F) : InfClosed (Set.range f) := by\n  simpa using infClosed_univ.image f\n\n"}
{"name":"InfClosed.prod","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : SemilatticeInf α\ninst✝ : SemilatticeInf β\ns : Set α\nt : Set β\nhs : InfClosed s\nht : InfClosed t\n⊢ InfClosed (SProd.sprod s t)","decl":"lemma InfClosed.prod {t : Set β} (hs : InfClosed s) (ht : InfClosed t) : InfClosed (s ×ˢ t) :=\n  fun _a ha _b hb ↦ ⟨hs ha.1 hb.1, ht ha.2 hb.2⟩\n\n"}
{"name":"infClosed_pi","module":"Mathlib.Order.SupClosed","initialProofState":"ι : Type u_6\nα : ι → Type u_7\ninst✝ : (i : ι) → SemilatticeInf (α i)\ns : Set ι\nt : (i : ι) → Set (α i)\nht : ∀ (i : ι), Membership.mem s i → InfClosed (t i)\n⊢ InfClosed (s.pi t)","decl":"lemma infClosed_pi {ι : Type*} {α : ι → Type*} [∀ i, SemilatticeInf (α i)] {s : Set ι}\n    {t : ∀ i, Set (α i)} (ht : ∀ i ∈ s, InfClosed (t i)) : InfClosed (s.pi t) :=\n  fun _a ha _b hb _i hi ↦ ht _ hi (ha _ hi) (hb _ hi)\n\n"}
{"name":"InfClosed.insert_upperBounds","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeInf α\ns : Set α\na : α\nhs : InfClosed s\nha : Membership.mem (upperBounds s) a\n⊢ InfClosed (Insert.insert a s)","decl":"lemma InfClosed.insert_upperBounds {s : Set α} {a : α} (hs : InfClosed s) (ha : a ∈ upperBounds s) :\n    InfClosed (insert a s) := by\n  rw [InfClosed]\n  have ha' : ∀ b ∈ s, b ≤ a := fun _ a ↦ ha a\n  aesop\n\n"}
{"name":"InfClosed.insert_lowerBounds","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeInf α\ns : Set α\na : α\nh : InfClosed s\nha : Membership.mem (lowerBounds s) a\n⊢ InfClosed (Insert.insert a s)","decl":"lemma InfClosed.insert_lowerBounds {s : Set α} {a : α} (h : InfClosed s) (ha : a ∈ lowerBounds s) :\n    InfClosed (insert a s) := by\n  rw [InfClosed]\n  aesop\n\n"}
{"name":"InfClosed.finsetInf'_mem","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeInf α\nι : Type u_5\nf : ι → α\ns : Set α\nt : Finset ι\nhs : InfClosed s\nht : t.Nonempty\na✝ : ∀ (i : ι), Membership.mem t i → Membership.mem s (f i)\n⊢ Membership.mem s (t.inf' ht f)","decl":"lemma InfClosed.finsetInf'_mem (hs : InfClosed s) (ht : t.Nonempty) :\n    (∀ i ∈ t, f i ∈ s) → t.inf' ht f ∈ s :=\n  inf'_induction _ _ hs\n\n"}
{"name":"InfClosed.finsetInf_mem","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝¹ : SemilatticeInf α\nι : Type u_5\nf : ι → α\ns : Set α\nt : Finset ι\ninst✝ : OrderTop α\nhs : InfClosed s\nht : t.Nonempty\na✝ : ∀ (i : ι), Membership.mem t i → Membership.mem s (f i)\n⊢ Membership.mem s (t.inf f)","decl":"lemma InfClosed.finsetInf_mem [OrderTop α] (hs : InfClosed s) (ht : t.Nonempty) :\n    (∀ i ∈ t, f i ∈ s) → t.inf f ∈ s :=\n  inf'_eq_inf ht f ▸ hs.finsetInf'_mem ht\n\n"}
{"name":"IsSublattice.infClosed","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : Lattice α\ns : Set α\nself : IsSublattice s\n⊢ InfClosed s","decl":"/-- A set `s` is a *sublattice* if `a ⊔ b ∈ s` and `a ⊓ b ∈ s` for all `a ∈ s`, `b ∈ s`.\nNote: This is not the preferred way to declare a sublattice. One should instead use `Sublattice`.\nTODO: Define `Sublattice`. -/\nstructure IsSublattice (s : Set α) : Prop where\n  supClosed : SupClosed s\n  infClosed : InfClosed s\n\n"}
{"name":"IsSublattice.supClosed","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : Lattice α\ns : Set α\nself : IsSublattice s\n⊢ SupClosed s","decl":"/-- A set `s` is a *sublattice* if `a ⊔ b ∈ s` and `a ⊓ b ∈ s` for all `a ∈ s`, `b ∈ s`.\nNote: This is not the preferred way to declare a sublattice. One should instead use `Sublattice`.\nTODO: Define `Sublattice`. -/\nstructure IsSublattice (s : Set α) : Prop where\n  supClosed : SupClosed s\n  infClosed : InfClosed s\n\n"}
{"name":"isSublattice_empty","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : Lattice α\n⊢ IsSublattice EmptyCollection.emptyCollection","decl":"@[simp] lemma isSublattice_empty : IsSublattice (∅ : Set α) := ⟨supClosed_empty, infClosed_empty⟩\n"}
{"name":"isSublattice_singleton","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : Lattice α\na : α\n⊢ IsSublattice (Singleton.singleton a)","decl":"@[simp] lemma isSublattice_singleton : IsSublattice ({a} : Set α) :=\n  ⟨supClosed_singleton, infClosed_singleton⟩\n\n"}
{"name":"isSublattice_univ","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : Lattice α\n⊢ IsSublattice Set.univ","decl":"@[simp] lemma isSublattice_univ : IsSublattice (Set.univ : Set α) :=\n  ⟨supClosed_univ, infClosed_univ⟩\n\n"}
{"name":"IsSublattice.inter","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : Lattice α\ns t : Set α\nhs : IsSublattice s\nht : IsSublattice t\n⊢ IsSublattice (Inter.inter s t)","decl":"lemma IsSublattice.inter (hs : IsSublattice s) (ht : IsSublattice t) : IsSublattice (s ∩ t) :=\n  ⟨hs.1.inter ht.1, hs.2.inter ht.2⟩\n\n"}
{"name":"isSublattice_sInter","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : Lattice α\nS : Set (Set α)\nhS : ∀ (s : Set α), Membership.mem S s → IsSublattice s\n⊢ IsSublattice S.sInter","decl":"lemma isSublattice_sInter (hS : ∀ s ∈ S, IsSublattice s) : IsSublattice (⋂₀ S) :=\n  ⟨supClosed_sInter fun _s hs ↦ (hS _ hs).1, infClosed_sInter fun _s hs ↦ (hS _ hs).2⟩\n\n"}
{"name":"isSublattice_iInter","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\nι : Sort u_5\ninst✝ : Lattice α\nf : ι → Set α\nhf : ∀ (i : ι), IsSublattice (f i)\n⊢ IsSublattice (Set.iInter fun i => f i)","decl":"lemma isSublattice_iInter (hf : ∀ i, IsSublattice (f i)) : IsSublattice (⋂ i, f i) :=\n  ⟨supClosed_iInter fun _i ↦ (hf _).1, infClosed_iInter fun _i ↦ (hf _).2⟩\n\n"}
{"name":"IsSublattice.preimage","module":"Mathlib.Order.SupClosed","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝³ : Lattice α\ninst✝² : Lattice β\ns : Set α\ninst✝¹ : FunLike F β α\ninst✝ : LatticeHomClass F β α\nhs : IsSublattice s\nf : F\n⊢ IsSublattice (Set.preimage (⇑f) s)","decl":"lemma IsSublattice.preimage [FunLike F β α] [LatticeHomClass F β α]\n    (hs : IsSublattice s) (f : F) :\n    IsSublattice (f ⁻¹' s) := ⟨hs.1.preimage _, hs.2.preimage _⟩\n\n"}
{"name":"IsSublattice.image","module":"Mathlib.Order.SupClosed","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝³ : Lattice α\ninst✝² : Lattice β\ns : Set α\ninst✝¹ : FunLike F α β\ninst✝ : LatticeHomClass F α β\nhs : IsSublattice s\nf : F\n⊢ IsSublattice (Set.image (⇑f) s)","decl":"lemma IsSublattice.image [FunLike F α β] [LatticeHomClass F α β] (hs : IsSublattice s) (f : F) :\n    IsSublattice (f '' s) := ⟨hs.1.image _, hs.2.image _⟩\n\n"}
{"name":"IsSublattice_range","module":"Mathlib.Order.SupClosed","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝³ : Lattice α\ninst✝² : Lattice β\ninst✝¹ : FunLike F α β\ninst✝ : LatticeHomClass F α β\nf : F\n⊢ IsSublattice (Set.range ⇑f)","decl":"lemma IsSublattice_range [FunLike F α β] [LatticeHomClass F α β] (f : F) :\n    IsSublattice (Set.range f) :=\n  ⟨supClosed_range _, infClosed_range _⟩\n\n"}
{"name":"IsSublattice.prod","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : Lattice α\ninst✝ : Lattice β\ns : Set α\nt : Set β\nhs : IsSublattice s\nht : IsSublattice t\n⊢ IsSublattice (SProd.sprod s t)","decl":"lemma IsSublattice.prod {t : Set β} (hs : IsSublattice s) (ht : IsSublattice t) :\n    IsSublattice (s ×ˢ t) := ⟨hs.1.prod ht.1, hs.2.prod ht.2⟩\n\n"}
{"name":"isSublattice_pi","module":"Mathlib.Order.SupClosed","initialProofState":"ι : Type u_6\nα : ι → Type u_7\ninst✝ : (i : ι) → Lattice (α i)\ns : Set ι\nt : (i : ι) → Set (α i)\nht : ∀ (i : ι), Membership.mem s i → IsSublattice (t i)\n⊢ IsSublattice (s.pi t)","decl":"lemma isSublattice_pi {ι : Type*} {α : ι → Type*} [∀ i, Lattice (α i)] {s : Set ι}\n    {t : ∀ i, Set (α i)} (ht : ∀ i ∈ s, IsSublattice (t i)) : IsSublattice (s.pi t) :=\n  ⟨supClosed_pi fun _i hi ↦ (ht _ hi).1, infClosed_pi fun _i hi ↦ (ht _ hi).2⟩\n\n"}
{"name":"supClosed_preimage_toDual","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : Lattice α\ns : Set (OrderDual α)\n⊢ Iff (SupClosed (Set.preimage (⇑OrderDual.toDual) s)) (InfClosed s)","decl":"@[simp] lemma supClosed_preimage_toDual {s : Set αᵒᵈ} :\n    SupClosed (toDual ⁻¹' s) ↔ InfClosed s := Iff.rfl\n\n"}
{"name":"infClosed_preimage_toDual","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : Lattice α\ns : Set (OrderDual α)\n⊢ Iff (InfClosed (Set.preimage (⇑OrderDual.toDual) s)) (SupClosed s)","decl":"@[simp] lemma infClosed_preimage_toDual {s : Set αᵒᵈ} :\n    InfClosed (toDual ⁻¹' s) ↔ SupClosed s := Iff.rfl\n\n"}
{"name":"supClosed_preimage_ofDual","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : Lattice α\ns : Set α\n⊢ Iff (SupClosed (Set.preimage (⇑OrderDual.ofDual) s)) (InfClosed s)","decl":"@[simp] lemma supClosed_preimage_ofDual {s : Set α} :\n    SupClosed (ofDual ⁻¹' s) ↔ InfClosed s := Iff.rfl\n\n"}
{"name":"infClosed_preimage_ofDual","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : Lattice α\ns : Set α\n⊢ Iff (InfClosed (Set.preimage (⇑OrderDual.ofDual) s)) (SupClosed s)","decl":"@[simp] lemma infClosed_preimage_ofDual {s : Set α} :\n    InfClosed (ofDual ⁻¹' s) ↔ SupClosed s := Iff.rfl\n\n"}
{"name":"isSublattice_preimage_toDual","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : Lattice α\ns : Set (OrderDual α)\n⊢ Iff (IsSublattice (Set.preimage (⇑OrderDual.toDual) s)) (IsSublattice s)","decl":"@[simp] lemma isSublattice_preimage_toDual {s : Set αᵒᵈ} :\n    IsSublattice (toDual ⁻¹' s) ↔ IsSublattice s := ⟨fun h ↦ ⟨h.2, h.1⟩, fun h ↦ ⟨h.2, h.1⟩⟩\n\n"}
{"name":"isSublattice_preimage_ofDual","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : Lattice α\ns : Set α\n⊢ Iff (IsSublattice (Set.preimage (⇑OrderDual.ofDual) s)) (IsSublattice s)","decl":"@[simp] lemma isSublattice_preimage_ofDual :\n    IsSublattice (ofDual ⁻¹' s) ↔ IsSublattice s := ⟨fun h ↦ ⟨h.2, h.1⟩, fun h ↦ ⟨h.2, h.1⟩⟩\n\n"}
{"name":"InfClosed.dual","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : Lattice α\ns : Set α\na✝ : InfClosed s\n⊢ SupClosed (Set.preimage (⇑OrderDual.ofDual) s)","decl":"alias ⟨_, InfClosed.dual⟩ := supClosed_preimage_ofDual\n"}
{"name":"SupClosed.dual","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : Lattice α\ns : Set α\na✝ : SupClosed s\n⊢ InfClosed (Set.preimage (⇑OrderDual.ofDual) s)","decl":"alias ⟨_, SupClosed.dual⟩ := infClosed_preimage_ofDual\n"}
{"name":"IsSublattice.dual","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : Lattice α\ns : Set α\na✝ : IsSublattice s\n⊢ IsSublattice (Set.preimage (⇑OrderDual.ofDual) s)","decl":"alias ⟨_, IsSublattice.dual⟩ := isSublattice_preimage_ofDual\n"}
{"name":"IsSublattice.of_dual","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : Lattice α\ns : Set (OrderDual α)\na✝ : IsSublattice s\n⊢ IsSublattice (Set.preimage (⇑OrderDual.toDual) s)","decl":"alias ⟨_, IsSublattice.of_dual⟩ := isSublattice_preimage_toDual\n\n"}
{"name":"LinearOrder.supClosed","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : LinearOrder α\ns : Set α\n⊢ SupClosed s","decl":"@[simp] protected lemma LinearOrder.supClosed (s : Set α) : SupClosed s :=\n  fun a ha b hb ↦ by cases le_total a b <;> simp [*]\n\n"}
{"name":"LinearOrder.infClosed","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : LinearOrder α\ns : Set α\n⊢ InfClosed s","decl":"@[simp] protected lemma LinearOrder.infClosed (s : Set α) : InfClosed s :=\n  fun a ha b hb ↦ by cases le_total a b <;> simp [*]\n\n"}
{"name":"LinearOrder.isSublattice","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : LinearOrder α\ns : Set α\n⊢ IsSublattice s","decl":"@[simp] protected lemma LinearOrder.isSublattice (s : Set α) : IsSublattice s :=\n  ⟨LinearOrder.supClosed _, LinearOrder.infClosed _⟩\n\n"}
{"name":"supClosure_isClosed","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeSup α\ns : Set α\n⊢ Eq (supClosure.IsClosed s) (SupClosed s)","decl":"/-- Every set in a join-semilattice generates a set closed under join. -/\n@[simps! isClosed]\ndef supClosure : ClosureOperator (Set α) := .ofPred\n  (fun s ↦ {a | ∃ (t : Finset α) (ht : t.Nonempty), ↑t ⊆ s ∧ t.sup' ht id = a})\n  SupClosed\n  (fun s a ha ↦ ⟨{a}, singleton_nonempty _, by simpa⟩)\n  (by\n    classical\n    rintro s _ ⟨t, ht, hts, rfl⟩ _ ⟨u, hu, hus, rfl⟩\n    refine ⟨_, ht.mono subset_union_left, ?_, sup'_union ht hu _⟩\n    rw [coe_union]\n    exact Set.union_subset hts hus)\n  (by rintro s₁ s₂ hs h₂ _ ⟨t, ht, hts, rfl⟩; exact h₂.finsetSup'_mem ht fun i hi ↦ hs <| hts hi)\n\n"}
{"name":"subset_supClosure","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeSup α\ns : Set α\n⊢ HasSubset.Subset s (supClosure s)","decl":"@[simp] lemma subset_supClosure {s : Set α} : s ⊆ supClosure s := supClosure.le_closure _\n\n"}
{"name":"supClosed_supClosure","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeSup α\ns : Set α\n⊢ SupClosed (supClosure s)","decl":"@[simp] lemma supClosed_supClosure : SupClosed (supClosure s) := supClosure.isClosed_closure _\n\n"}
{"name":"supClosure_mono","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeSup α\n⊢ Monotone ⇑supClosure","decl":"lemma supClosure_mono : Monotone (supClosure : Set α → Set α) := supClosure.monotone\n\n"}
{"name":"supClosure_eq_self","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeSup α\ns : Set α\n⊢ Iff (Eq (supClosure s) s) (SupClosed s)","decl":"@[simp] lemma supClosure_eq_self : supClosure s = s ↔ SupClosed s := supClosure.isClosed_iff.symm\n\n"}
{"name":"SupClosed.supClosure_eq","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeSup α\ns : Set α\na✝ : SupClosed s\n⊢ Eq (supClosure s) s","decl":"alias ⟨_, SupClosed.supClosure_eq⟩ := supClosure_eq_self\n\n"}
{"name":"supClosure_idem","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeSup α\ns : Set α\n⊢ Eq (supClosure (supClosure s)) (supClosure s)","decl":"lemma supClosure_idem (s : Set α) : supClosure (supClosure s) = supClosure s :=\n  supClosure.idempotent _\n\n"}
{"name":"supClosure_empty","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeSup α\n⊢ Eq (supClosure EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp] lemma supClosure_empty : supClosure (∅ : Set α) = ∅ := by simp\n"}
{"name":"supClosure_singleton","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeSup α\na : α\n⊢ Eq (supClosure (Singleton.singleton a)) (Singleton.singleton a)","decl":"@[simp] lemma supClosure_singleton : supClosure {a} = {a} := by simp\n"}
{"name":"supClosure_univ","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeSup α\n⊢ Eq (supClosure Set.univ) Set.univ","decl":"@[simp] lemma supClosure_univ : supClosure (Set.univ : Set α) = Set.univ := by simp\n\n"}
{"name":"upperBounds_supClosure","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeSup α\ns : Set α\n⊢ Eq (upperBounds (supClosure s)) (upperBounds s)","decl":"@[simp] lemma upperBounds_supClosure (s : Set α) : upperBounds (supClosure s) = upperBounds s :=\n  (upperBounds_mono_set subset_supClosure).antisymm <| by\n    rintro a ha _ ⟨t, ht, hts, rfl⟩\n    exact sup'_le _ _ fun b hb ↦ ha <| hts hb\n\n"}
{"name":"isLUB_supClosure","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeSup α\ns : Set α\na : α\n⊢ Iff (IsLUB (supClosure s) a) (IsLUB s a)","decl":"@[simp] lemma isLUB_supClosure : IsLUB (supClosure s) a ↔ IsLUB s a := by simp [IsLUB]\n\n"}
{"name":"sup_mem_supClosure","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeSup α\ns : Set α\na b : α\nha : Membership.mem s a\nhb : Membership.mem s b\n⊢ Membership.mem (supClosure s) (Max.max a b)","decl":"lemma sup_mem_supClosure (ha : a ∈ s) (hb : b ∈ s) : a ⊔ b ∈ supClosure s :=\n  supClosed_supClosure (subset_supClosure ha) (subset_supClosure hb)\n\n"}
{"name":"finsetSup'_mem_supClosure","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeSup α\ns : Set α\nι : Type u_5\nt : Finset ι\nht : t.Nonempty\nf : ι → α\nhf : ∀ (i : ι), Membership.mem t i → Membership.mem s (f i)\n⊢ Membership.mem (supClosure s) (t.sup' ht f)","decl":"lemma finsetSup'_mem_supClosure {ι : Type*} {t : Finset ι} (ht : t.Nonempty) {f : ι → α}\n    (hf : ∀ i ∈ t, f i ∈ s) : t.sup' ht f ∈ supClosure s :=\n  supClosed_supClosure.finsetSup'_mem _ fun _i hi ↦ subset_supClosure <| hf _ hi\n\n"}
{"name":"supClosure_min","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeSup α\ns t : Set α\na✝¹ : HasSubset.Subset s t\na✝ : SupClosed t\n⊢ HasSubset.Subset (supClosure s) t","decl":"lemma supClosure_min : s ⊆ t → SupClosed t → supClosure s ⊆ t := supClosure.closure_min\n\n"}
{"name":"Set.Finite.supClosure","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeSup α\ns : Set α\nhs : s.Finite\n⊢ (supClosure s).Finite","decl":"/-- The semilatice generated by a finite set is finite. -/\nprotected lemma Set.Finite.supClosure (hs : s.Finite) : (supClosure s).Finite := by\n  lift s to Finset α using hs\n  classical\n  refine ({t ∈ s.powerset | t.Nonempty}.attach.image\n    fun t ↦ t.1.sup' (mem_filter.1 t.2).2 id).finite_toSet.subset ?_\n  rintro _ ⟨t, ht, hts, rfl⟩\n  simp only [id_eq, coe_image, mem_image, mem_coe, mem_attach, true_and, Subtype.exists,\n    Finset.mem_powerset, Finset.not_nonempty_iff_eq_empty, mem_filter]\n  exact ⟨t, ⟨hts, ht⟩, rfl⟩\n\n"}
{"name":"supClosure_prod","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : SemilatticeSup α\ninst✝ : SemilatticeSup β\ns : Set α\nt : Set β\n⊢ Eq (supClosure (SProd.sprod s t)) (SProd.sprod (supClosure s) (supClosure t))","decl":"@[simp] lemma supClosure_prod (s : Set α) (t : Set β) :\n    supClosure (s ×ˢ t) = supClosure s ×ˢ supClosure t :=\n  le_antisymm (supClosure_min (Set.prod_mono subset_supClosure subset_supClosure) <|\n    supClosed_supClosure.prod supClosed_supClosure) <| by\n      rintro ⟨_, _⟩ ⟨⟨u, hu, hus, rfl⟩, v, hv, hvt, rfl⟩\n      refine ⟨u ×ˢ v, hu.product hv, ?_, ?_⟩\n      · simpa only [coe_product] using Set.prod_mono hus hvt\n      · simp [prodMk_sup'_sup']\n\n"}
{"name":"infClosure_isClosed","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeInf α\ns : Set α\n⊢ Eq (infClosure.IsClosed s) (InfClosed s)","decl":"/-- Every set in a join-semilattice generates a set closed under join. -/\n@[simps! isClosed]\ndef infClosure : ClosureOperator (Set α) := ClosureOperator.ofPred\n  (fun s ↦ {a | ∃ (t : Finset α) (ht : t.Nonempty), ↑t ⊆ s ∧ t.inf' ht id = a})\n  InfClosed\n  (fun s a ha ↦ ⟨{a}, singleton_nonempty _, by simpa⟩)\n  (by\n    classical\n    rintro s _ ⟨t, ht, hts, rfl⟩ _ ⟨u, hu, hus, rfl⟩\n    refine ⟨_, ht.mono subset_union_left, ?_, inf'_union ht hu _⟩\n    rw [coe_union]\n    exact Set.union_subset hts hus)\n  (by rintro s₁ s₂ hs h₂ _ ⟨t, ht, hts, rfl⟩; exact h₂.finsetInf'_mem ht fun i hi ↦ hs <| hts hi)\n\n"}
{"name":"subset_infClosure","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeInf α\ns : Set α\n⊢ HasSubset.Subset s (infClosure s)","decl":"@[simp] lemma subset_infClosure {s : Set α} : s ⊆ infClosure s := infClosure.le_closure _\n\n"}
{"name":"infClosed_infClosure","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeInf α\ns : Set α\n⊢ InfClosed (infClosure s)","decl":"@[simp] lemma infClosed_infClosure : InfClosed (infClosure s) := infClosure.isClosed_closure _\n\n"}
{"name":"infClosure_mono","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeInf α\n⊢ Monotone ⇑infClosure","decl":"lemma infClosure_mono : Monotone (infClosure : Set α → Set α) := infClosure.monotone\n\n"}
{"name":"infClosure_eq_self","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeInf α\ns : Set α\n⊢ Iff (Eq (infClosure s) s) (InfClosed s)","decl":"@[simp] lemma infClosure_eq_self : infClosure s = s ↔ InfClosed s := infClosure.isClosed_iff.symm\n\n"}
{"name":"InfClosed.infClosure_eq","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeInf α\ns : Set α\na✝ : InfClosed s\n⊢ Eq (infClosure s) s","decl":"alias ⟨_, InfClosed.infClosure_eq⟩ := infClosure_eq_self\n\n"}
{"name":"infClosure_idem","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeInf α\ns : Set α\n⊢ Eq (infClosure (infClosure s)) (infClosure s)","decl":"lemma infClosure_idem (s : Set α) : infClosure (infClosure s) = infClosure s :=\n  infClosure.idempotent _\n\n"}
{"name":"infClosure_empty","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeInf α\n⊢ Eq (infClosure EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp] lemma infClosure_empty : infClosure (∅ : Set α) = ∅ := by simp\n"}
{"name":"infClosure_singleton","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeInf α\na : α\n⊢ Eq (infClosure (Singleton.singleton a)) (Singleton.singleton a)","decl":"@[simp] lemma infClosure_singleton : infClosure {a} = {a} := by simp\n"}
{"name":"infClosure_univ","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeInf α\n⊢ Eq (infClosure Set.univ) Set.univ","decl":"@[simp] lemma infClosure_univ : infClosure (Set.univ : Set α) = Set.univ := by simp\n\n"}
{"name":"lowerBounds_infClosure","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeInf α\ns : Set α\n⊢ Eq (lowerBounds (infClosure s)) (lowerBounds s)","decl":"@[simp] lemma lowerBounds_infClosure (s : Set α) : lowerBounds (infClosure s) = lowerBounds s :=\n  (lowerBounds_mono_set subset_infClosure).antisymm <| by\n    rintro a ha _ ⟨t, ht, hts, rfl⟩\n    exact le_inf' _ _ fun b hb ↦ ha <| hts hb\n\n"}
{"name":"isGLB_infClosure","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeInf α\ns : Set α\na : α\n⊢ Iff (IsGLB (infClosure s) a) (IsGLB s a)","decl":"@[simp] lemma isGLB_infClosure : IsGLB (infClosure s) a ↔ IsGLB s a := by simp [IsGLB]\n\n"}
{"name":"inf_mem_infClosure","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeInf α\ns : Set α\na b : α\nha : Membership.mem s a\nhb : Membership.mem s b\n⊢ Membership.mem (infClosure s) (Min.min a b)","decl":"lemma inf_mem_infClosure (ha : a ∈ s) (hb : b ∈ s) : a ⊓ b ∈ infClosure s :=\n  infClosed_infClosure (subset_infClosure ha) (subset_infClosure hb)\n\n"}
{"name":"finsetInf'_mem_infClosure","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeInf α\ns : Set α\nι : Type u_5\nt : Finset ι\nht : t.Nonempty\nf : ι → α\nhf : ∀ (i : ι), Membership.mem t i → Membership.mem s (f i)\n⊢ Membership.mem (infClosure s) (t.inf' ht f)","decl":"lemma finsetInf'_mem_infClosure {ι : Type*} {t : Finset ι} (ht : t.Nonempty) {f : ι → α}\n    (hf : ∀ i ∈ t, f i ∈ s) : t.inf' ht f ∈ infClosure s :=\n  infClosed_infClosure.finsetInf'_mem _ fun _i hi ↦ subset_infClosure <| hf _ hi\n\n"}
{"name":"infClosure_min","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeInf α\ns t : Set α\na✝¹ : HasSubset.Subset s t\na✝ : InfClosed t\n⊢ HasSubset.Subset (infClosure s) t","decl":"lemma infClosure_min : s ⊆ t → InfClosed t → infClosure s ⊆ t := infClosure.closure_min\n\n"}
{"name":"Set.Finite.infClosure","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : SemilatticeInf α\ns : Set α\nhs : s.Finite\n⊢ (infClosure s).Finite","decl":"/-- The semilatice generated by a finite set is finite. -/\nprotected lemma Set.Finite.infClosure (hs : s.Finite) : (infClosure s).Finite := by\n  lift s to Finset α using hs\n  classical\n  refine ({t ∈ s.powerset | t.Nonempty}.attach.image\n    fun t ↦ t.1.inf' (mem_filter.1 t.2).2 id).finite_toSet.subset ?_\n  rintro _ ⟨t, ht, hts, rfl⟩\n  simp only [id_eq, coe_image, mem_image, mem_coe, mem_attach, true_and, Subtype.exists,\n    Finset.mem_powerset, Finset.not_nonempty_iff_eq_empty, mem_filter]\n  exact ⟨t, ⟨hts, ht⟩, rfl⟩\n\n"}
{"name":"infClosure_prod","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : SemilatticeInf α\ninst✝ : SemilatticeInf β\ns : Set α\nt : Set β\n⊢ Eq (infClosure (SProd.sprod s t)) (SProd.sprod (infClosure s) (infClosure t))","decl":"@[simp] lemma infClosure_prod (s : Set α) (t : Set β) :\n    infClosure (s ×ˢ t) = infClosure s ×ˢ infClosure t :=\n  le_antisymm (infClosure_min (Set.prod_mono subset_infClosure subset_infClosure) <|\n    infClosed_infClosure.prod infClosed_infClosure) <| by\n      rintro ⟨_, _⟩ ⟨⟨u, hu, hus, rfl⟩, v, hv, hvt, rfl⟩\n      refine ⟨u ×ˢ v, hu.product hv, ?_, ?_⟩\n      · simpa only [coe_product] using Set.prod_mono hus hvt\n      · simp [prodMk_inf'_inf']\n\n"}
{"name":"latticeClosure_isClosed","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : Lattice α\ns : Set α\n⊢ Eq (latticeClosure.IsClosed s) (IsSublattice s)","decl":"/-- Every set in a join-semilattice generates a set closed under join. -/\n@[simps! isClosed]\ndef latticeClosure : ClosureOperator (Set α) :=\n  .ofCompletePred IsSublattice fun _ ↦ isSublattice_sInter\n\n"}
{"name":"subset_latticeClosure","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : Lattice α\ns : Set α\n⊢ HasSubset.Subset s (latticeClosure s)","decl":"@[simp] lemma subset_latticeClosure : s ⊆ latticeClosure s := latticeClosure.le_closure _\n\n"}
{"name":"isSublattice_latticeClosure","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : Lattice α\ns : Set α\n⊢ IsSublattice (latticeClosure s)","decl":"@[simp] lemma isSublattice_latticeClosure : IsSublattice (latticeClosure s) :=\n  latticeClosure.isClosed_closure _\n\n"}
{"name":"latticeClosure_min","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : Lattice α\ns t : Set α\na✝¹ : HasSubset.Subset s t\na✝ : IsSublattice t\n⊢ HasSubset.Subset (latticeClosure s) t","decl":"lemma latticeClosure_min : s ⊆ t → IsSublattice t → latticeClosure s ⊆ t :=\n  latticeClosure.closure_min\n\n"}
{"name":"latticeClosure_mono","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : Lattice α\n⊢ Monotone ⇑latticeClosure","decl":"lemma latticeClosure_mono : Monotone (latticeClosure : Set α → Set α) := latticeClosure.monotone\n\n"}
{"name":"latticeClosure_eq_self","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : Lattice α\ns : Set α\n⊢ Iff (Eq (latticeClosure s) s) (IsSublattice s)","decl":"@[simp] lemma latticeClosure_eq_self : latticeClosure s = s ↔ IsSublattice s :=\n  latticeClosure.isClosed_iff.symm\n\n"}
{"name":"IsSublattice.latticeClosure_eq","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : Lattice α\ns : Set α\na✝ : IsSublattice s\n⊢ Eq (latticeClosure s) s","decl":"alias ⟨_, IsSublattice.latticeClosure_eq⟩ := latticeClosure_eq_self\n\n"}
{"name":"latticeClosure_idem","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : Lattice α\ns : Set α\n⊢ Eq (latticeClosure (latticeClosure s)) (latticeClosure s)","decl":"lemma latticeClosure_idem (s : Set α) : latticeClosure (latticeClosure s) = latticeClosure s :=\n  latticeClosure.idempotent _\n\n"}
{"name":"latticeClosure_empty","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : Lattice α\n⊢ Eq (latticeClosure EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp] lemma latticeClosure_empty : latticeClosure (∅ : Set α) = ∅ := by simp\n"}
{"name":"latticeClosure_singleton","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : Lattice α\na : α\n⊢ Eq (latticeClosure (Singleton.singleton a)) (Singleton.singleton a)","decl":"@[simp] lemma latticeClosure_singleton (a : α) : latticeClosure {a} = {a} := by simp\n"}
{"name":"latticeClosure_univ","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : Lattice α\n⊢ Eq (latticeClosure Set.univ) Set.univ","decl":"@[simp] lemma latticeClosure_univ : latticeClosure (Set.univ : Set α) = Set.univ := by simp\n\n"}
{"name":"SupClosed.infClosure","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : DistribLattice α\ns : Set α\nhs : SupClosed s\n⊢ SupClosed (infClosure s)","decl":"protected lemma SupClosed.infClosure (hs : SupClosed s) : SupClosed (infClosure s) := by\n  rintro _ ⟨t, ht, hts, rfl⟩ _ ⟨u, hu, hus, rfl⟩\n  rw [inf'_sup_inf']\n  exact finsetInf'_mem_infClosure _\n    fun i hi ↦ hs (hts (mem_product.1 hi).1) (hus (mem_product.1 hi).2)\n\n"}
{"name":"InfClosed.supClosure","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : DistribLattice α\ns : Set α\nhs : InfClosed s\n⊢ InfClosed (supClosure s)","decl":"protected lemma InfClosed.supClosure (hs : InfClosed s) : InfClosed (supClosure s) := by\n  rintro _ ⟨t, ht, hts, rfl⟩ _ ⟨u, hu, hus, rfl⟩\n  rw [sup'_inf_sup']\n  exact finsetSup'_mem_supClosure _\n    fun i hi ↦ hs (hts (mem_product.1 hi).1) (hus (mem_product.1 hi).2)\n\n"}
{"name":"supClosure_infClosure","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : DistribLattice α\ns : Set α\n⊢ Eq (supClosure (infClosure s)) (latticeClosure s)","decl":"@[simp] lemma supClosure_infClosure (s : Set α) : supClosure (infClosure s) = latticeClosure s :=\n  le_antisymm (supClosure_min (infClosure_min subset_latticeClosure isSublattice_latticeClosure.2)\n    isSublattice_latticeClosure.1) <| latticeClosure_min (subset_infClosure.trans subset_supClosure)\n      ⟨supClosed_supClosure, infClosed_infClosure.supClosure⟩\n\n"}
{"name":"infClosure_supClosure","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : DistribLattice α\ns : Set α\n⊢ Eq (infClosure (supClosure s)) (latticeClosure s)","decl":"@[simp] lemma infClosure_supClosure (s : Set α) : infClosure (supClosure s) = latticeClosure s :=\n  le_antisymm (infClosure_min (supClosure_min subset_latticeClosure isSublattice_latticeClosure.1)\n    isSublattice_latticeClosure.2) <| latticeClosure_min (subset_supClosure.trans subset_infClosure)\n      ⟨supClosed_supClosure.infClosure, infClosed_infClosure⟩\n\n"}
{"name":"Set.Finite.latticeClosure","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : DistribLattice α\ns : Set α\nhs : s.Finite\n⊢ (latticeClosure s).Finite","decl":"lemma Set.Finite.latticeClosure (hs : s.Finite) : (latticeClosure s).Finite := by\n  rw [← supClosure_infClosure]; exact hs.infClosure.supClosure\n\n"}
{"name":"latticeClosure_prod","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : DistribLattice α\ninst✝ : DistribLattice β\ns : Set α\nt : Set β\n⊢ Eq (latticeClosure (SProd.sprod s t)) (SProd.sprod (latticeClosure s) (latticeClosure t))","decl":"@[simp] lemma latticeClosure_prod (s : Set α) (t : Set β) :\n    latticeClosure (s ×ˢ t) = latticeClosure s ×ˢ latticeClosure t := by\n  simp_rw [← supClosure_infClosure]; simp\n\n"}
{"name":"SupClosed.iSup_mem_of_nonempty","module":"Mathlib.Order.SupClosed","initialProofState":"ι : Sort u_1\nα : Type u_3\ninst✝² : ConditionallyCompleteLattice α\nf : ι → α\ns : Set α\ninst✝¹ : Finite ι\ninst✝ : Nonempty ι\nhs : SupClosed s\nhf : ∀ (i : ι), Membership.mem s (f i)\n⊢ Membership.mem s (iSup fun i => f i)","decl":"lemma SupClosed.iSup_mem_of_nonempty [Finite ι] [Nonempty ι] (hs : SupClosed s)\n    (hf : ∀ i, f i ∈ s) : ⨆ i, f i ∈ s := by\n  cases nonempty_fintype (PLift ι)\n  rw [← iSup_plift_down, ← Finset.sup'_univ_eq_ciSup]\n  exact hs.finsetSup'_mem Finset.univ_nonempty fun _ _ ↦ hf _\n\n"}
{"name":"InfClosed.iInf_mem_of_nonempty","module":"Mathlib.Order.SupClosed","initialProofState":"ι : Sort u_1\nα : Type u_3\ninst✝² : ConditionallyCompleteLattice α\nf : ι → α\ns : Set α\ninst✝¹ : Finite ι\ninst✝ : Nonempty ι\nhs : InfClosed s\nhf : ∀ (i : ι), Membership.mem s (f i)\n⊢ Membership.mem s (iInf fun i => f i)","decl":"lemma InfClosed.iInf_mem_of_nonempty [Finite ι] [Nonempty ι] (hs : InfClosed s)\n    (hf : ∀ i, f i ∈ s) : ⨅ i, f i ∈ s := hs.dual.iSup_mem_of_nonempty hf\n\n"}
{"name":"SupClosed.sSup_mem_of_nonempty","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : ConditionallyCompleteLattice α\ns t : Set α\nhs : SupClosed s\nht : t.Finite\nht' : t.Nonempty\nhts : HasSubset.Subset t s\n⊢ Membership.mem s (SupSet.sSup t)","decl":"lemma SupClosed.sSup_mem_of_nonempty (hs : SupClosed s) (ht : t.Finite) (ht' : t.Nonempty)\n    (hts : t ⊆ s) : sSup t ∈ s := by\n  have := ht.to_subtype\n  have := ht'.to_subtype\n  rw [sSup_eq_iSup']\n  exact hs.iSup_mem_of_nonempty (by simpa)\n\n"}
{"name":"InfClosed.sInf_mem_of_nonempty","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : ConditionallyCompleteLattice α\ns t : Set α\nhs : InfClosed s\nht : t.Finite\nht' : t.Nonempty\nhts : HasSubset.Subset t s\n⊢ Membership.mem s (InfSet.sInf t)","decl":"lemma InfClosed.sInf_mem_of_nonempty (hs : InfClosed s) (ht : t.Finite) (ht' : t.Nonempty)\n    (hts : t ⊆ s) : sInf t ∈ s := hs.dual.sSup_mem_of_nonempty ht ht' hts\n\n"}
{"name":"SupClosed.biSup_mem_of_nonempty","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : CompleteLattice α\ns : Set α\nι : Type u_5\nt : Set ι\nf : ι → α\nhs : SupClosed s\nht : t.Finite\nht' : t.Nonempty\nhf : ∀ (i : ι), Membership.mem t i → Membership.mem s (f i)\n⊢ Membership.mem s (iSup fun i => iSup fun h => f i)","decl":"lemma SupClosed.biSup_mem_of_nonempty {ι : Type*} {t : Set ι} {f : ι → α} (hs : SupClosed s)\n    (ht : t.Finite) (ht' : t.Nonempty) (hf : ∀ i ∈ t, f i ∈ s) : ⨆ i ∈ t, f i ∈ s := by\n  rw [← sSup_image]\n  exact hs.sSup_mem_of_nonempty (ht.image _) (by simpa) (by simpa)\n\n"}
{"name":"InfClosed.biInf_mem_of_nonempty","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : CompleteLattice α\ns : Set α\nι : Type u_5\nt : Set ι\nf : ι → α\nhs : InfClosed s\nht : t.Finite\nht' : t.Nonempty\nhf : ∀ (i : ι), Membership.mem t i → Membership.mem s (f i)\n⊢ Membership.mem s (iInf fun i => iInf fun h => f i)","decl":"lemma InfClosed.biInf_mem_of_nonempty {ι : Type*} {t : Set ι} {f : ι → α} (hs : InfClosed s)\n    (ht : t.Finite) (ht' : t.Nonempty) (hf : ∀ i ∈ t, f i ∈ s) : ⨅ i ∈ t, f i ∈ s :=\n  hs.dual.biSup_mem_of_nonempty ht ht' hf\n\n"}
{"name":"SupClosed.iSup_mem","module":"Mathlib.Order.SupClosed","initialProofState":"ι : Sort u_1\nα : Type u_3\ninst✝¹ : CompleteLattice α\nf : ι → α\ns : Set α\ninst✝ : Finite ι\nhs : SupClosed s\nhbot : Membership.mem s Bot.bot\nhf : ∀ (i : ι), Membership.mem s (f i)\n⊢ Membership.mem s (iSup fun i => f i)","decl":"lemma SupClosed.iSup_mem [Finite ι] (hs : SupClosed s) (hbot : ⊥ ∈ s) (hf : ∀ i, f i ∈ s) :\n    ⨆ i, f i ∈ s := by\n  cases isEmpty_or_nonempty ι\n  · simpa [iSup_of_empty]\n  · exact hs.iSup_mem_of_nonempty hf\n\n"}
{"name":"InfClosed.iInf_mem","module":"Mathlib.Order.SupClosed","initialProofState":"ι : Sort u_1\nα : Type u_3\ninst✝¹ : CompleteLattice α\nf : ι → α\ns : Set α\ninst✝ : Finite ι\nhs : InfClosed s\nhtop : Membership.mem s Top.top\nhf : ∀ (i : ι), Membership.mem s (f i)\n⊢ Membership.mem s (iInf fun i => f i)","decl":"lemma InfClosed.iInf_mem [Finite ι] (hs : InfClosed s) (htop : ⊤ ∈ s) (hf : ∀ i, f i ∈ s) :\n    ⨅ i, f i ∈ s := hs.dual.iSup_mem htop hf\n\n"}
{"name":"SupClosed.sSup_mem","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : CompleteLattice α\ns t : Set α\nhs : SupClosed s\nht : t.Finite\nhbot : Membership.mem s Bot.bot\nhts : HasSubset.Subset t s\n⊢ Membership.mem s (SupSet.sSup t)","decl":"lemma SupClosed.sSup_mem (hs : SupClosed s) (ht : t.Finite) (hbot : ⊥ ∈ s) (hts : t ⊆ s) :\n    sSup t ∈ s := by\n  have := ht.to_subtype\n  rw [sSup_eq_iSup']\n  exact hs.iSup_mem hbot (by simpa)\n\n"}
{"name":"InfClosed.sInf_mem","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : CompleteLattice α\ns t : Set α\nhs : InfClosed s\nht : t.Finite\nhtop : Membership.mem s Top.top\nhts : HasSubset.Subset t s\n⊢ Membership.mem s (InfSet.sInf t)","decl":"lemma InfClosed.sInf_mem (hs : InfClosed s) (ht : t.Finite) (htop : ⊤ ∈ s) (hts : t ⊆ s) :\n    sInf t ∈ s := hs.dual.sSup_mem ht htop hts\n\n"}
{"name":"SupClosed.biSup_mem","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : CompleteLattice α\ns : Set α\nι : Type u_5\nt : Set ι\nf : ι → α\nhs : SupClosed s\nht : t.Finite\nhbot : Membership.mem s Bot.bot\nhf : ∀ (i : ι), Membership.mem t i → Membership.mem s (f i)\n⊢ Membership.mem s (iSup fun i => iSup fun h => f i)","decl":"lemma SupClosed.biSup_mem {ι : Type*} {t : Set ι} {f : ι → α} (hs : SupClosed s)\n    (ht : t.Finite) (hbot : ⊥ ∈ s) (hf : ∀ i ∈ t, f i ∈ s) : ⨆ i ∈ t, f i ∈ s := by\n  rw [← sSup_image]\n  exact hs.sSup_mem (ht.image _) hbot (by simpa)\n\n"}
{"name":"InfClosed.biInf_mem","module":"Mathlib.Order.SupClosed","initialProofState":"α : Type u_3\ninst✝ : CompleteLattice α\ns : Set α\nι : Type u_5\nt : Set ι\nf : ι → α\nhs : InfClosed s\nht : t.Finite\nhtop : Membership.mem s Top.top\nhf : ∀ (i : ι), Membership.mem t i → Membership.mem s (f i)\n⊢ Membership.mem s (iInf fun i => iInf fun h => f i)","decl":"lemma InfClosed.biInf_mem {ι : Type*} {t : Set ι} {f : ι → α} (hs : InfClosed s)\n    (ht : t.Finite) (htop : ⊤ ∈ s) (hf : ∀ i ∈ t, f i ∈ s) : ⨅ i ∈ t, f i ∈ s :=\n  hs.dual.biSup_mem ht htop hf\n"}
