{"name":"RootPairing.Hom.ext_iff","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nι₂ : Type u_5\nM₂ : Type u_6\nN₂ : Type u_7\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nQ : RootPairing ι₂ R M₂ N₂\nx y : P.Hom Q\n⊢ Iff (Eq x y) (And (Eq x.weightMap y.weightMap) (And (Eq x.coweightMap y.coweightMap) (Eq x.indexEquiv y.indexEquiv)))","decl":"/-- A morphism of root pairings is a pair of mutually transposed maps of weight and coweight spaces\nthat preserves roots and coroots.  We make the map of indexing sets explicit. -/\n@[ext]\nstructure Hom {ι₂ M₂ N₂ : Type*}\n    [AddCommGroup M₂] [Module R M₂] [AddCommGroup N₂] [Module R N₂]\n    (P : RootPairing ι R M N) (Q : RootPairing ι₂ R M₂ N₂) where\n  /-- A linear map on weight space. -/\n  weightMap : M →ₗ[R] M₂\n  /-- A contravariant linear map on coweight space. -/\n  coweightMap : N₂ →ₗ[R] N\n  /-- A bijection on index sets. -/\n  indexEquiv : ι ≃ ι₂\n  weight_coweight_transpose : weightMap.dualMap ∘ₗ Q.toDualRight = P.toDualRight ∘ₗ coweightMap\n  root_weightMap : weightMap ∘ P.root = Q.root ∘ indexEquiv\n  coroot_coweightMap : coweightMap ∘ Q.coroot = P.coroot ∘ indexEquiv.symm\n\n"}
{"name":"RootPairing.Hom.mk.sizeOf_spec","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹⁵ : CommRing R\ninst✝¹⁴ : AddCommGroup M\ninst✝¹³ : Module R M\ninst✝¹² : AddCommGroup N\ninst✝¹¹ : Module R N\nι₂ : Type u_5\nM₂ : Type u_6\nN₂ : Type u_7\ninst✝¹⁰ : AddCommGroup M₂\ninst✝⁹ : Module R M₂\ninst✝⁸ : AddCommGroup N₂\ninst✝⁷ : Module R N₂\nP : RootPairing ι R M N\nQ : RootPairing ι₂ R M₂ N₂\ninst✝⁶ : SizeOf ι\ninst✝⁵ : SizeOf R\ninst✝⁴ : SizeOf M\ninst✝³ : SizeOf N\ninst✝² : SizeOf ι₂\ninst✝¹ : SizeOf M₂\ninst✝ : SizeOf N₂\nweightMap : LinearMap (RingHom.id R) M M₂\ncoweightMap : LinearMap (RingHom.id R) N₂ N\nindexEquiv : Equiv ι ι₂\nweight_coweight_transpose : Eq (weightMap.dualMap.comp ↑Q.toDualRight) ((↑P.toDualRight).comp coweightMap)\nroot_weightMap : Eq (Function.comp ⇑weightMap ⇑P.root) (Function.comp ⇑Q.root ⇑indexEquiv)\ncoroot_coweightMap : Eq (Function.comp ⇑coweightMap ⇑Q.coroot) (Function.comp ⇑P.coroot ⇑indexEquiv.symm)\n⊢ Eq (SizeOf.sizeOf { weightMap := weightMap, coweightMap := coweightMap, indexEquiv := indexEquiv, weight_coweight_transpose := weight_coweight_transpose, root_weightMap := root_weightMap, coroot_coweightMap := coroot_coweightMap }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf weightMap)) (SizeOf.sizeOf coweightMap)) (SizeOf.sizeOf indexEquiv)) (SizeOf.sizeOf weight_coweight_transpose)) (SizeOf.sizeOf root_weightMap)) (SizeOf.sizeOf coroot_coweightMap))","decl":"/-- A morphism of root pairings is a pair of mutually transposed maps of weight and coweight spaces\nthat preserves roots and coroots.  We make the map of indexing sets explicit. -/\n@[ext]\nstructure Hom {ι₂ M₂ N₂ : Type*}\n    [AddCommGroup M₂] [Module R M₂] [AddCommGroup N₂] [Module R N₂]\n    (P : RootPairing ι R M N) (Q : RootPairing ι₂ R M₂ N₂) where\n  /-- A linear map on weight space. -/\n  weightMap : M →ₗ[R] M₂\n  /-- A contravariant linear map on coweight space. -/\n  coweightMap : N₂ →ₗ[R] N\n  /-- A bijection on index sets. -/\n  indexEquiv : ι ≃ ι₂\n  weight_coweight_transpose : weightMap.dualMap ∘ₗ Q.toDualRight = P.toDualRight ∘ₗ coweightMap\n  root_weightMap : weightMap ∘ P.root = Q.root ∘ indexEquiv\n  coroot_coweightMap : coweightMap ∘ Q.coroot = P.coroot ∘ indexEquiv.symm\n\n"}
{"name":"RootPairing.Hom.root_weightMap","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nι₂ : Type u_5\nM₂ : Type u_6\nN₂ : Type u_7\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nQ : RootPairing ι₂ R M₂ N₂\nself : P.Hom Q\n⊢ Eq (Function.comp ⇑self.weightMap ⇑P.root) (Function.comp ⇑Q.root ⇑self.indexEquiv)","decl":"/-- A morphism of root pairings is a pair of mutually transposed maps of weight and coweight spaces\nthat preserves roots and coroots.  We make the map of indexing sets explicit. -/\n@[ext]\nstructure Hom {ι₂ M₂ N₂ : Type*}\n    [AddCommGroup M₂] [Module R M₂] [AddCommGroup N₂] [Module R N₂]\n    (P : RootPairing ι R M N) (Q : RootPairing ι₂ R M₂ N₂) where\n  /-- A linear map on weight space. -/\n  weightMap : M →ₗ[R] M₂\n  /-- A contravariant linear map on coweight space. -/\n  coweightMap : N₂ →ₗ[R] N\n  /-- A bijection on index sets. -/\n  indexEquiv : ι ≃ ι₂\n  weight_coweight_transpose : weightMap.dualMap ∘ₗ Q.toDualRight = P.toDualRight ∘ₗ coweightMap\n  root_weightMap : weightMap ∘ P.root = Q.root ∘ indexEquiv\n  coroot_coweightMap : coweightMap ∘ Q.coroot = P.coroot ∘ indexEquiv.symm\n\n"}
{"name":"RootPairing.Hom.mk.injEq","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nι₂ : Type u_5\nM₂ : Type u_6\nN₂ : Type u_7\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nQ : RootPairing ι₂ R M₂ N₂\nweightMap✝ : LinearMap (RingHom.id R) M M₂\ncoweightMap✝ : LinearMap (RingHom.id R) N₂ N\nindexEquiv✝ : Equiv ι ι₂\nweight_coweight_transpose✝ : Eq (weightMap✝.dualMap.comp ↑Q.toDualRight) ((↑P.toDualRight).comp coweightMap✝)\nroot_weightMap✝ : Eq (Function.comp ⇑weightMap✝ ⇑P.root) (Function.comp ⇑Q.root ⇑indexEquiv✝)\ncoroot_coweightMap✝ : Eq (Function.comp ⇑coweightMap✝ ⇑Q.coroot) (Function.comp ⇑P.coroot ⇑indexEquiv✝.symm)\nweightMap : LinearMap (RingHom.id R) M M₂\ncoweightMap : LinearMap (RingHom.id R) N₂ N\nindexEquiv : Equiv ι ι₂\nweight_coweight_transpose : Eq (weightMap.dualMap.comp ↑Q.toDualRight) ((↑P.toDualRight).comp coweightMap)\nroot_weightMap : Eq (Function.comp ⇑weightMap ⇑P.root) (Function.comp ⇑Q.root ⇑indexEquiv)\ncoroot_coweightMap : Eq (Function.comp ⇑coweightMap ⇑Q.coroot) (Function.comp ⇑P.coroot ⇑indexEquiv.symm)\n⊢ Eq (Eq { weightMap := weightMap✝, coweightMap := coweightMap✝, indexEquiv := indexEquiv✝, weight_coweight_transpose := weight_coweight_transpose✝, root_weightMap := root_weightMap✝, coroot_coweightMap := coroot_coweightMap✝ } { weightMap := weightMap, coweightMap := coweightMap, indexEquiv := indexEquiv, weight_coweight_transpose := weight_coweight_transpose, root_weightMap := root_weightMap, coroot_coweightMap := coroot_coweightMap }) (And (Eq weightMap✝ weightMap) (And (Eq coweightMap✝ coweightMap) (Eq indexEquiv✝ indexEquiv)))","decl":"/-- A morphism of root pairings is a pair of mutually transposed maps of weight and coweight spaces\nthat preserves roots and coroots.  We make the map of indexing sets explicit. -/\n@[ext]\nstructure Hom {ι₂ M₂ N₂ : Type*}\n    [AddCommGroup M₂] [Module R M₂] [AddCommGroup N₂] [Module R N₂]\n    (P : RootPairing ι R M N) (Q : RootPairing ι₂ R M₂ N₂) where\n  /-- A linear map on weight space. -/\n  weightMap : M →ₗ[R] M₂\n  /-- A contravariant linear map on coweight space. -/\n  coweightMap : N₂ →ₗ[R] N\n  /-- A bijection on index sets. -/\n  indexEquiv : ι ≃ ι₂\n  weight_coweight_transpose : weightMap.dualMap ∘ₗ Q.toDualRight = P.toDualRight ∘ₗ coweightMap\n  root_weightMap : weightMap ∘ P.root = Q.root ∘ indexEquiv\n  coroot_coweightMap : coweightMap ∘ Q.coroot = P.coroot ∘ indexEquiv.symm\n\n"}
{"name":"RootPairing.Hom.mk.inj","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nι₂ : Type u_5\nM₂ : Type u_6\nN₂ : Type u_7\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nQ : RootPairing ι₂ R M₂ N₂\nweightMap✝ : LinearMap (RingHom.id R) M M₂\ncoweightMap✝ : LinearMap (RingHom.id R) N₂ N\nindexEquiv✝ : Equiv ι ι₂\nweight_coweight_transpose✝ : Eq (weightMap✝.dualMap.comp ↑Q.toDualRight) ((↑P.toDualRight).comp coweightMap✝)\nroot_weightMap✝ : Eq (Function.comp ⇑weightMap✝ ⇑P.root) (Function.comp ⇑Q.root ⇑indexEquiv✝)\ncoroot_coweightMap✝ : Eq (Function.comp ⇑coweightMap✝ ⇑Q.coroot) (Function.comp ⇑P.coroot ⇑indexEquiv✝.symm)\nweightMap : LinearMap (RingHom.id R) M M₂\ncoweightMap : LinearMap (RingHom.id R) N₂ N\nindexEquiv : Equiv ι ι₂\nweight_coweight_transpose : Eq (weightMap.dualMap.comp ↑Q.toDualRight) ((↑P.toDualRight).comp coweightMap)\nroot_weightMap : Eq (Function.comp ⇑weightMap ⇑P.root) (Function.comp ⇑Q.root ⇑indexEquiv)\ncoroot_coweightMap : Eq (Function.comp ⇑coweightMap ⇑Q.coroot) (Function.comp ⇑P.coroot ⇑indexEquiv.symm)\nx✝ : Eq { weightMap := weightMap✝, coweightMap := coweightMap✝, indexEquiv := indexEquiv✝, weight_coweight_transpose := weight_coweight_transpose✝, root_weightMap := root_weightMap✝, coroot_coweightMap := coroot_coweightMap✝ } { weightMap := weightMap, coweightMap := coweightMap, indexEquiv := indexEquiv, weight_coweight_transpose := weight_coweight_transpose, root_weightMap := root_weightMap, coroot_coweightMap := coroot_coweightMap }\n⊢ And (Eq weightMap✝ weightMap) (And (Eq coweightMap✝ coweightMap) (Eq indexEquiv✝ indexEquiv))","decl":"/-- A morphism of root pairings is a pair of mutually transposed maps of weight and coweight spaces\nthat preserves roots and coroots.  We make the map of indexing sets explicit. -/\n@[ext]\nstructure Hom {ι₂ M₂ N₂ : Type*}\n    [AddCommGroup M₂] [Module R M₂] [AddCommGroup N₂] [Module R N₂]\n    (P : RootPairing ι R M N) (Q : RootPairing ι₂ R M₂ N₂) where\n  /-- A linear map on weight space. -/\n  weightMap : M →ₗ[R] M₂\n  /-- A contravariant linear map on coweight space. -/\n  coweightMap : N₂ →ₗ[R] N\n  /-- A bijection on index sets. -/\n  indexEquiv : ι ≃ ι₂\n  weight_coweight_transpose : weightMap.dualMap ∘ₗ Q.toDualRight = P.toDualRight ∘ₗ coweightMap\n  root_weightMap : weightMap ∘ P.root = Q.root ∘ indexEquiv\n  coroot_coweightMap : coweightMap ∘ Q.coroot = P.coroot ∘ indexEquiv.symm\n\n"}
{"name":"RootPairing.Hom.ext","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nι₂ : Type u_5\nM₂ : Type u_6\nN₂ : Type u_7\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nQ : RootPairing ι₂ R M₂ N₂\nx y : P.Hom Q\nweightMap : Eq x.weightMap y.weightMap\ncoweightMap : Eq x.coweightMap y.coweightMap\nindexEquiv : Eq x.indexEquiv y.indexEquiv\n⊢ Eq x y","decl":"/-- A morphism of root pairings is a pair of mutually transposed maps of weight and coweight spaces\nthat preserves roots and coroots.  We make the map of indexing sets explicit. -/\n@[ext]\nstructure Hom {ι₂ M₂ N₂ : Type*}\n    [AddCommGroup M₂] [Module R M₂] [AddCommGroup N₂] [Module R N₂]\n    (P : RootPairing ι R M N) (Q : RootPairing ι₂ R M₂ N₂) where\n  /-- A linear map on weight space. -/\n  weightMap : M →ₗ[R] M₂\n  /-- A contravariant linear map on coweight space. -/\n  coweightMap : N₂ →ₗ[R] N\n  /-- A bijection on index sets. -/\n  indexEquiv : ι ≃ ι₂\n  weight_coweight_transpose : weightMap.dualMap ∘ₗ Q.toDualRight = P.toDualRight ∘ₗ coweightMap\n  root_weightMap : weightMap ∘ P.root = Q.root ∘ indexEquiv\n  coroot_coweightMap : coweightMap ∘ Q.coroot = P.coroot ∘ indexEquiv.symm\n\n"}
{"name":"RootPairing.Hom.weight_coweight_transpose","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nι₂ : Type u_5\nM₂ : Type u_6\nN₂ : Type u_7\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nQ : RootPairing ι₂ R M₂ N₂\nself : P.Hom Q\n⊢ Eq (self.weightMap.dualMap.comp ↑Q.toDualRight) ((↑P.toDualRight).comp self.coweightMap)","decl":"/-- A morphism of root pairings is a pair of mutually transposed maps of weight and coweight spaces\nthat preserves roots and coroots.  We make the map of indexing sets explicit. -/\n@[ext]\nstructure Hom {ι₂ M₂ N₂ : Type*}\n    [AddCommGroup M₂] [Module R M₂] [AddCommGroup N₂] [Module R N₂]\n    (P : RootPairing ι R M N) (Q : RootPairing ι₂ R M₂ N₂) where\n  /-- A linear map on weight space. -/\n  weightMap : M →ₗ[R] M₂\n  /-- A contravariant linear map on coweight space. -/\n  coweightMap : N₂ →ₗ[R] N\n  /-- A bijection on index sets. -/\n  indexEquiv : ι ≃ ι₂\n  weight_coweight_transpose : weightMap.dualMap ∘ₗ Q.toDualRight = P.toDualRight ∘ₗ coweightMap\n  root_weightMap : weightMap ∘ P.root = Q.root ∘ indexEquiv\n  coroot_coweightMap : coweightMap ∘ Q.coroot = P.coroot ∘ indexEquiv.symm\n\n"}
{"name":"RootPairing.Hom.coroot_coweightMap","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nι₂ : Type u_5\nM₂ : Type u_6\nN₂ : Type u_7\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nQ : RootPairing ι₂ R M₂ N₂\nself : P.Hom Q\n⊢ Eq (Function.comp ⇑self.coweightMap ⇑Q.coroot) (Function.comp ⇑P.coroot ⇑self.indexEquiv.symm)","decl":"/-- A morphism of root pairings is a pair of mutually transposed maps of weight and coweight spaces\nthat preserves roots and coroots.  We make the map of indexing sets explicit. -/\n@[ext]\nstructure Hom {ι₂ M₂ N₂ : Type*}\n    [AddCommGroup M₂] [Module R M₂] [AddCommGroup N₂] [Module R N₂]\n    (P : RootPairing ι R M N) (Q : RootPairing ι₂ R M₂ N₂) where\n  /-- A linear map on weight space. -/\n  weightMap : M →ₗ[R] M₂\n  /-- A contravariant linear map on coweight space. -/\n  coweightMap : N₂ →ₗ[R] N\n  /-- A bijection on index sets. -/\n  indexEquiv : ι ≃ ι₂\n  weight_coweight_transpose : weightMap.dualMap ∘ₗ Q.toDualRight = P.toDualRight ∘ₗ coweightMap\n  root_weightMap : weightMap ∘ P.root = Q.root ∘ indexEquiv\n  coroot_coweightMap : coweightMap ∘ Q.coroot = P.coroot ∘ indexEquiv.symm\n\n"}
{"name":"RootPairing.Hom.weight_coweight_transpose_apply","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nι₂ : Type u_5\nM₂ : Type u_6\nN₂ : Type u_7\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nQ : RootPairing ι₂ R M₂ N₂\nx : N₂\nf : P.Hom Q\n⊢ Eq (f.weightMap.dualMap (Q.toDualRight x)) (P.toDualRight (f.coweightMap x))","decl":"lemma weight_coweight_transpose_apply {ι₂ M₂ N₂ : Type*}\n    [AddCommGroup M₂] [Module R M₂] [AddCommGroup N₂] [Module R N₂]\n    (P : RootPairing ι R M N) (Q : RootPairing ι₂ R M₂ N₂) (x : N₂) (f : Hom P Q) :\n    f.weightMap.dualMap (Q.toDualRight x) = P.toDualRight (f.coweightMap x) :=\n  Eq.mp (propext LinearMap.ext_iff) f.weight_coweight_transpose x\n\n"}
{"name":"RootPairing.Hom.root_weightMap_apply","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nι₂ : Type u_5\nM₂ : Type u_6\nN₂ : Type u_7\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nQ : RootPairing ι₂ R M₂ N₂\ni : ι\nf : P.Hom Q\n⊢ Eq (f.weightMap (P.root i)) (Q.root (f.indexEquiv i))","decl":"lemma root_weightMap_apply {ι₂ M₂ N₂ : Type*}\n    [AddCommGroup M₂] [Module R M₂] [AddCommGroup N₂] [Module R N₂]\n    (P : RootPairing ι R M N) (Q : RootPairing ι₂ R M₂ N₂) (i : ι) (f : Hom P Q) :\n    f.weightMap (P.root i) = Q.root (f.indexEquiv i) :=\n  Eq.mp (propext funext_iff) f.root_weightMap i\n\n"}
{"name":"RootPairing.Hom.coroot_coweightMap_apply","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nι₂ : Type u_5\nM₂ : Type u_6\nN₂ : Type u_7\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nQ : RootPairing ι₂ R M₂ N₂\ni : ι₂\nf : P.Hom Q\n⊢ Eq (f.coweightMap (Q.coroot i)) (P.coroot (f.indexEquiv.symm i))","decl":"lemma coroot_coweightMap_apply {ι₂ M₂ N₂ : Type*}\n    [AddCommGroup M₂] [Module R M₂] [AddCommGroup N₂] [Module R N₂]\n    (P : RootPairing ι R M N) (Q : RootPairing ι₂ R M₂ N₂) (i : ι₂) (f : Hom P Q) :\n    f.coweightMap (Q.coroot i) = P.coroot (f.indexEquiv.symm i) :=\n  Eq.mp (propext funext_iff) f.coroot_coweightMap i\n\n"}
{"name":"RootPairing.Hom.id_indexEquiv_apply","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\na : ι\n⊢ Eq ((RootPairing.Hom.id P).indexEquiv a) a","decl":"/-- The identity morphism of a root pairing. -/\n@[simps!]\ndef id (P : RootPairing ι R M N) : Hom P P where\n  weightMap := LinearMap.id\n  coweightMap := LinearMap.id\n  indexEquiv := Equiv.refl ι\n  weight_coweight_transpose := by simp\n  root_weightMap := by simp\n  coroot_coweightMap := by simp\n\n"}
{"name":"RootPairing.Hom.id_indexEquiv_symm_apply","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\na : ι\n⊢ Eq ((RootPairing.Hom.id P).indexEquiv.symm a) a","decl":"/-- The identity morphism of a root pairing. -/\n@[simps!]\ndef id (P : RootPairing ι R M N) : Hom P P where\n  weightMap := LinearMap.id\n  coweightMap := LinearMap.id\n  indexEquiv := Equiv.refl ι\n  weight_coweight_transpose := by simp\n  root_weightMap := by simp\n  coroot_coweightMap := by simp\n\n"}
{"name":"RootPairing.Hom.id_coweightMap_apply","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\na : N\n⊢ Eq ((RootPairing.Hom.id P).coweightMap a) a","decl":"/-- The identity morphism of a root pairing. -/\n@[simps!]\ndef id (P : RootPairing ι R M N) : Hom P P where\n  weightMap := LinearMap.id\n  coweightMap := LinearMap.id\n  indexEquiv := Equiv.refl ι\n  weight_coweight_transpose := by simp\n  root_weightMap := by simp\n  coroot_coweightMap := by simp\n\n"}
{"name":"RootPairing.Hom.id_weightMap_apply","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\na : M\n⊢ Eq ((RootPairing.Hom.id P).weightMap a) a","decl":"/-- The identity morphism of a root pairing. -/\n@[simps!]\ndef id (P : RootPairing ι R M N) : Hom P P where\n  weightMap := LinearMap.id\n  coweightMap := LinearMap.id\n  indexEquiv := Equiv.refl ι\n  weight_coweight_transpose := by simp\n  root_weightMap := by simp\n  coroot_coweightMap := by simp\n\n"}
{"name":"RootPairing.Hom.comp_indexEquiv_symm_apply","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹² : CommRing R\ninst✝¹¹ : AddCommGroup M\ninst✝¹⁰ : Module R M\ninst✝⁹ : AddCommGroup N\ninst✝⁸ : Module R N\nι₁ : Type u_5\nM₁ : Type u_6\nN₁ : Type u_7\nι₂ : Type u_8\nM₂ : Type u_9\nN₂ : Type u_10\ninst✝⁷ : AddCommGroup M₁\ninst✝⁶ : Module R M₁\ninst✝⁵ : AddCommGroup N₁\ninst✝⁴ : Module R N₁\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nP₁ : RootPairing ι₁ R M₁ N₁\nP₂ : RootPairing ι₂ R M₂ N₂\ng : P₁.Hom P₂\nf : P.Hom P₁\na✝ : ι₂\n⊢ Eq ((g.comp f).indexEquiv.symm a✝) (f.indexEquiv.symm (g.indexEquiv.symm a✝))","decl":"/-- Composition of morphisms -/\n@[simps!]\ndef comp {ι₁ M₁ N₁ ι₂ M₂ N₂ : Type*} [AddCommGroup M₁] [Module R M₁] [AddCommGroup N₁]\n    [Module R N₁] [AddCommGroup M₂] [Module R M₂] [AddCommGroup N₂] [Module R N₂]\n    {P : RootPairing ι R M N} {P₁ : RootPairing ι₁ R M₁ N₁} {P₂ : RootPairing ι₂ R M₂ N₂}\n    (g : Hom P₁ P₂) (f : Hom P P₁) : Hom P P₂ where\n  weightMap := g.weightMap ∘ₗ f.weightMap\n  coweightMap := f.coweightMap ∘ₗ g.coweightMap\n  indexEquiv := f.indexEquiv.trans g.indexEquiv\n  weight_coweight_transpose := by\n    ext φ x\n    rw [← LinearMap.dualMap_comp_dualMap, ← LinearMap.comp_assoc _ f.coweightMap,\n      ← f.weight_coweight_transpose, LinearMap.comp_assoc g.coweightMap,\n      ← g.weight_coweight_transpose, ← LinearMap.comp_assoc]\n  root_weightMap := by\n    ext i\n    simp only [LinearMap.coe_comp, Equiv.coe_trans]\n    rw [comp_assoc, f.root_weightMap, ← comp_assoc, g.root_weightMap, comp_assoc]\n  coroot_coweightMap := by\n    ext i\n    simp only [LinearMap.coe_comp, Equiv.symm_trans_apply]\n    rw [comp_assoc, g.coroot_coweightMap, ← comp_assoc, f.coroot_coweightMap, comp_assoc]\n    simp\n\n"}
{"name":"RootPairing.Hom.comp_coweightMap_apply","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹² : CommRing R\ninst✝¹¹ : AddCommGroup M\ninst✝¹⁰ : Module R M\ninst✝⁹ : AddCommGroup N\ninst✝⁸ : Module R N\nι₁ : Type u_5\nM₁ : Type u_6\nN₁ : Type u_7\nι₂ : Type u_8\nM₂ : Type u_9\nN₂ : Type u_10\ninst✝⁷ : AddCommGroup M₁\ninst✝⁶ : Module R M₁\ninst✝⁵ : AddCommGroup N₁\ninst✝⁴ : Module R N₁\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nP₁ : RootPairing ι₁ R M₁ N₁\nP₂ : RootPairing ι₂ R M₂ N₂\ng : P₁.Hom P₂\nf : P.Hom P₁\na✝ : N₂\n⊢ Eq ((g.comp f).coweightMap a✝) (f.coweightMap (g.coweightMap a✝))","decl":"/-- Composition of morphisms -/\n@[simps!]\ndef comp {ι₁ M₁ N₁ ι₂ M₂ N₂ : Type*} [AddCommGroup M₁] [Module R M₁] [AddCommGroup N₁]\n    [Module R N₁] [AddCommGroup M₂] [Module R M₂] [AddCommGroup N₂] [Module R N₂]\n    {P : RootPairing ι R M N} {P₁ : RootPairing ι₁ R M₁ N₁} {P₂ : RootPairing ι₂ R M₂ N₂}\n    (g : Hom P₁ P₂) (f : Hom P P₁) : Hom P P₂ where\n  weightMap := g.weightMap ∘ₗ f.weightMap\n  coweightMap := f.coweightMap ∘ₗ g.coweightMap\n  indexEquiv := f.indexEquiv.trans g.indexEquiv\n  weight_coweight_transpose := by\n    ext φ x\n    rw [← LinearMap.dualMap_comp_dualMap, ← LinearMap.comp_assoc _ f.coweightMap,\n      ← f.weight_coweight_transpose, LinearMap.comp_assoc g.coweightMap,\n      ← g.weight_coweight_transpose, ← LinearMap.comp_assoc]\n  root_weightMap := by\n    ext i\n    simp only [LinearMap.coe_comp, Equiv.coe_trans]\n    rw [comp_assoc, f.root_weightMap, ← comp_assoc, g.root_weightMap, comp_assoc]\n  coroot_coweightMap := by\n    ext i\n    simp only [LinearMap.coe_comp, Equiv.symm_trans_apply]\n    rw [comp_assoc, g.coroot_coweightMap, ← comp_assoc, f.coroot_coweightMap, comp_assoc]\n    simp\n\n"}
{"name":"RootPairing.Hom.comp_weightMap_apply","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹² : CommRing R\ninst✝¹¹ : AddCommGroup M\ninst✝¹⁰ : Module R M\ninst✝⁹ : AddCommGroup N\ninst✝⁸ : Module R N\nι₁ : Type u_5\nM₁ : Type u_6\nN₁ : Type u_7\nι₂ : Type u_8\nM₂ : Type u_9\nN₂ : Type u_10\ninst✝⁷ : AddCommGroup M₁\ninst✝⁶ : Module R M₁\ninst✝⁵ : AddCommGroup N₁\ninst✝⁴ : Module R N₁\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nP₁ : RootPairing ι₁ R M₁ N₁\nP₂ : RootPairing ι₂ R M₂ N₂\ng : P₁.Hom P₂\nf : P.Hom P₁\na✝ : M\n⊢ Eq ((g.comp f).weightMap a✝) (g.weightMap (f.weightMap a✝))","decl":"/-- Composition of morphisms -/\n@[simps!]\ndef comp {ι₁ M₁ N₁ ι₂ M₂ N₂ : Type*} [AddCommGroup M₁] [Module R M₁] [AddCommGroup N₁]\n    [Module R N₁] [AddCommGroup M₂] [Module R M₂] [AddCommGroup N₂] [Module R N₂]\n    {P : RootPairing ι R M N} {P₁ : RootPairing ι₁ R M₁ N₁} {P₂ : RootPairing ι₂ R M₂ N₂}\n    (g : Hom P₁ P₂) (f : Hom P P₁) : Hom P P₂ where\n  weightMap := g.weightMap ∘ₗ f.weightMap\n  coweightMap := f.coweightMap ∘ₗ g.coweightMap\n  indexEquiv := f.indexEquiv.trans g.indexEquiv\n  weight_coweight_transpose := by\n    ext φ x\n    rw [← LinearMap.dualMap_comp_dualMap, ← LinearMap.comp_assoc _ f.coweightMap,\n      ← f.weight_coweight_transpose, LinearMap.comp_assoc g.coweightMap,\n      ← g.weight_coweight_transpose, ← LinearMap.comp_assoc]\n  root_weightMap := by\n    ext i\n    simp only [LinearMap.coe_comp, Equiv.coe_trans]\n    rw [comp_assoc, f.root_weightMap, ← comp_assoc, g.root_weightMap, comp_assoc]\n  coroot_coweightMap := by\n    ext i\n    simp only [LinearMap.coe_comp, Equiv.symm_trans_apply]\n    rw [comp_assoc, g.coroot_coweightMap, ← comp_assoc, f.coroot_coweightMap, comp_assoc]\n    simp\n\n"}
{"name":"RootPairing.Hom.comp_indexEquiv_apply","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹² : CommRing R\ninst✝¹¹ : AddCommGroup M\ninst✝¹⁰ : Module R M\ninst✝⁹ : AddCommGroup N\ninst✝⁸ : Module R N\nι₁ : Type u_5\nM₁ : Type u_6\nN₁ : Type u_7\nι₂ : Type u_8\nM₂ : Type u_9\nN₂ : Type u_10\ninst✝⁷ : AddCommGroup M₁\ninst✝⁶ : Module R M₁\ninst✝⁵ : AddCommGroup N₁\ninst✝⁴ : Module R N₁\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nP₁ : RootPairing ι₁ R M₁ N₁\nP₂ : RootPairing ι₂ R M₂ N₂\ng : P₁.Hom P₂\nf : P.Hom P₁\na✝ : ι\n⊢ Eq ((g.comp f).indexEquiv a✝) (g.indexEquiv (f.indexEquiv a✝))","decl":"/-- Composition of morphisms -/\n@[simps!]\ndef comp {ι₁ M₁ N₁ ι₂ M₂ N₂ : Type*} [AddCommGroup M₁] [Module R M₁] [AddCommGroup N₁]\n    [Module R N₁] [AddCommGroup M₂] [Module R M₂] [AddCommGroup N₂] [Module R N₂]\n    {P : RootPairing ι R M N} {P₁ : RootPairing ι₁ R M₁ N₁} {P₂ : RootPairing ι₂ R M₂ N₂}\n    (g : Hom P₁ P₂) (f : Hom P P₁) : Hom P P₂ where\n  weightMap := g.weightMap ∘ₗ f.weightMap\n  coweightMap := f.coweightMap ∘ₗ g.coweightMap\n  indexEquiv := f.indexEquiv.trans g.indexEquiv\n  weight_coweight_transpose := by\n    ext φ x\n    rw [← LinearMap.dualMap_comp_dualMap, ← LinearMap.comp_assoc _ f.coweightMap,\n      ← f.weight_coweight_transpose, LinearMap.comp_assoc g.coweightMap,\n      ← g.weight_coweight_transpose, ← LinearMap.comp_assoc]\n  root_weightMap := by\n    ext i\n    simp only [LinearMap.coe_comp, Equiv.coe_trans]\n    rw [comp_assoc, f.root_weightMap, ← comp_assoc, g.root_weightMap, comp_assoc]\n  coroot_coweightMap := by\n    ext i\n    simp only [LinearMap.coe_comp, Equiv.symm_trans_apply]\n    rw [comp_assoc, g.coroot_coweightMap, ← comp_assoc, f.coroot_coweightMap, comp_assoc]\n    simp\n\n"}
{"name":"RootPairing.Hom.id_comp","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nι₂ : Type u_5\nM₂ : Type u_6\nN₂ : Type u_7\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nQ : RootPairing ι₂ R M₂ N₂\nf : P.Hom Q\n⊢ Eq (f.comp (RootPairing.Hom.id P)) f","decl":"@[simp]\nlemma id_comp {ι₂ M₂ N₂ : Type*}\n    [AddCommGroup M₂] [Module R M₂] [AddCommGroup N₂] [Module R N₂]\n    (P : RootPairing ι R M N) (Q : RootPairing ι₂ R M₂ N₂) (f : Hom P Q) :\n    comp f (id P) = f := by\n  ext x <;> simp\n\n"}
{"name":"RootPairing.Hom.comp_id","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nι₂ : Type u_5\nM₂ : Type u_6\nN₂ : Type u_7\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nQ : RootPairing ι₂ R M₂ N₂\nf : P.Hom Q\n⊢ Eq ((RootPairing.Hom.id Q).comp f) f","decl":"@[simp]\nlemma comp_id {ι₂ M₂ N₂ : Type*}\n    [AddCommGroup M₂] [Module R M₂] [AddCommGroup N₂] [Module R N₂]\n    (P : RootPairing ι R M N) (Q : RootPairing ι₂ R M₂ N₂) (f : Hom P Q) :\n    comp (id Q) f = f := by\n  ext x <;> simp\n\n"}
{"name":"RootPairing.Hom.comp_assoc","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹⁶ : CommRing R\ninst✝¹⁵ : AddCommGroup M\ninst✝¹⁴ : Module R M\ninst✝¹³ : AddCommGroup N\ninst✝¹² : Module R N\nι₁ : Type u_5\nM₁ : Type u_6\nN₁ : Type u_7\nι₂ : Type u_8\nM₂ : Type u_9\nN₂ : Type u_10\nι₃ : Type u_11\nM₃ : Type u_12\nN₃ : Type u_13\ninst✝¹¹ : AddCommGroup M₁\ninst✝¹⁰ : Module R M₁\ninst✝⁹ : AddCommGroup N₁\ninst✝⁸ : Module R N₁\ninst✝⁷ : AddCommGroup M₂\ninst✝⁶ : Module R M₂\ninst✝⁵ : AddCommGroup N₂\ninst✝⁴ : Module R N₂\ninst✝³ : AddCommGroup M₃\ninst✝² : Module R M₃\ninst✝¹ : AddCommGroup N₃\ninst✝ : Module R N₃\nP : RootPairing ι R M N\nP₁ : RootPairing ι₁ R M₁ N₁\nP₂ : RootPairing ι₂ R M₂ N₂\nP₃ : RootPairing ι₃ R M₃ N₃\nh : P₂.Hom P₃\ng : P₁.Hom P₂\nf : P.Hom P₁\n⊢ Eq ((h.comp g).comp f) (h.comp (g.comp f))","decl":"@[simp]\nlemma comp_assoc {ι₁ M₁ N₁ ι₂ M₂ N₂ ι₃ M₃ N₃ : Type*} [AddCommGroup M₁] [Module R M₁]\n    [AddCommGroup N₁] [Module R N₁] [AddCommGroup M₂] [Module R M₂] [AddCommGroup N₂] [Module R N₂]\n    [AddCommGroup M₃] [Module R M₃] [AddCommGroup N₃] [Module R N₃] {P : RootPairing ι R M N}\n    {P₁ : RootPairing ι₁ R M₁ N₁} {P₂ : RootPairing ι₂ R M₂ N₂} {P₃ : RootPairing ι₃ R M₃ N₃}\n    (h : Hom P₂ P₃) (g : Hom P₁ P₂) (f : Hom P P₁) :\n    comp (comp h g) f = comp h (comp g f) := by\n  ext <;> simp\n\n"}
{"name":"RootPairing.Hom.weightMap_one","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ Eq (RootPairing.Hom.weightMap 1) LinearMap.id","decl":"@[simp]\nlemma weightMap_one (P : RootPairing ι R M N) :\n    weightMap (P := P) (Q := P) 1 = LinearMap.id (R := R) (M := M) :=\n  rfl\n\n"}
{"name":"RootPairing.Hom.coweightMap_one","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ Eq (RootPairing.Hom.coweightMap 1) LinearMap.id","decl":"@[simp]\nlemma coweightMap_one (P : RootPairing ι R M N) :\n    coweightMap (P := P) (Q := P) 1 = LinearMap.id (R := R) (M := N) :=\n  rfl\n\n"}
{"name":"RootPairing.Hom.indexEquiv_one","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ Eq (RootPairing.Hom.indexEquiv 1) (Equiv.refl ι)","decl":"@[simp]\nlemma indexEquiv_one (P : RootPairing ι R M N) :\n    indexEquiv (P := P) (Q := P) 1 = Equiv.refl ι :=\n  rfl\n\n"}
{"name":"RootPairing.Hom.weightMap_mul","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nx y : P.Hom P\n⊢ Eq (HMul.hMul x y).weightMap (x.weightMap.comp y.weightMap)","decl":"@[simp]\nlemma weightMap_mul (P : RootPairing ι R M N) (x y : Hom P P) :\n    weightMap (x * y) = weightMap x ∘ₗ weightMap y :=\n  rfl\n\n"}
{"name":"RootPairing.Hom.coweightMap_mul","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nx y : P.Hom P\n⊢ Eq (HMul.hMul x y).coweightMap (y.coweightMap.comp x.coweightMap)","decl":"@[simp]\nlemma coweightMap_mul (P : RootPairing ι R M N) (x y : Hom P P) :\n    coweightMap (x * y) = coweightMap y ∘ₗ coweightMap x :=\n  rfl\n\n"}
{"name":"RootPairing.Hom.indexEquiv_mul","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nx y : P.Hom P\n⊢ Eq (⇑(HMul.hMul x y).indexEquiv) (Function.comp ⇑x.indexEquiv ⇑y.indexEquiv)","decl":"@[simp]\nlemma indexEquiv_mul (P : RootPairing ι R M N) (x y : Hom P P) :\n    indexEquiv (x * y) = indexEquiv x ∘ indexEquiv y :=\n  rfl\n\n"}
{"name":"RootPairing.Hom.weightHom_injective","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ Function.Injective ⇑(RootPairing.Hom.weightHom P)","decl":"lemma weightHom_injective (P : RootPairing ι R M N) : Injective (weightHom P) := by\n  intro f g hfg\n  ext x\n  · exact LinearMap.congr_fun hfg x\n  · refine LinearEquiv.injective P.toDualRight ?_\n    simp_rw [← weight_coweight_transpose_apply]\n    exact congrFun (congrArg DFunLike.coe (congrArg LinearMap.dualMap hfg)) (P.toDualRight x)\n  · refine Embedding.injective P.root ?_\n    simp_rw [← root_weightMap_apply]\n    exact congrFun (congrArg DFunLike.coe hfg) (P.root x)\n\n"}
{"name":"RootPairing.Hom.coweightHom_injective","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ Function.Injective ⇑(RootPairing.Hom.coweightHom P)","decl":"lemma coweightHom_injective (P : RootPairing ι R M N) : Injective (coweightHom P) := by\n  intro f g hfg\n  ext x\n  · dsimp [coweightHom] at hfg\n    rw [MulOpposite.op_inj] at hfg\n    have h := congrArg (LinearMap.comp (M₃ := Module.Dual R M)\n        (σ₂₃ := RingHom.id R) (P.toDualRight)) hfg\n    rw [← f.weight_coweight_transpose, ← g.weight_coweight_transpose] at h\n    have : f.weightMap = g.weightMap := by\n      haveI : Module.IsReflexive R M := PerfectPairing.reflexive_left P.toPerfectPairing\n      refine (Module.dualMap_dualMap_eq_iff R M).mp (congrArg LinearMap.dualMap\n        ((LinearEquiv.eq_comp_toLinearMap_iff f.weightMap.dualMap g.weightMap.dualMap).mp h))\n    exact congrFun (congrArg DFunLike.coe this) x\n  · dsimp [coweightHom] at hfg\n    simp_all only [MulOpposite.op_inj]\n  · dsimp [coweightHom] at hfg\n    rw [MulOpposite.op_inj] at hfg\n    set y := f.indexEquiv x with hy\n    have : f.coweightMap (P.coroot y) = g.coweightMap (P.coroot y) := by\n      exact congrFun (congrArg DFunLike.coe hfg) (P.coroot y)\n    rw [coroot_coweightMap_apply, coroot_coweightMap_apply, Embedding.apply_eq_iff_eq, hy] at this\n    rw [Equiv.symm_apply_apply] at this\n    rw [this, Equiv.apply_symm_apply]\n\n"}
{"name":"RootPairing.Equiv.mk.sizeOf_spec","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹⁵ : CommRing R\ninst✝¹⁴ : AddCommGroup M\ninst✝¹³ : Module R M\ninst✝¹² : AddCommGroup N\ninst✝¹¹ : Module R N\nι₂ : Type u_5\nM₂ : Type u_6\nN₂ : Type u_7\ninst✝¹⁰ : AddCommGroup M₂\ninst✝⁹ : Module R M₂\ninst✝⁸ : AddCommGroup N₂\ninst✝⁷ : Module R N₂\nP : RootPairing ι R M N\nQ : RootPairing ι₂ R M₂ N₂\ninst✝⁶ : SizeOf ι\ninst✝⁵ : SizeOf R\ninst✝⁴ : SizeOf M\ninst✝³ : SizeOf N\ninst✝² : SizeOf ι₂\ninst✝¹ : SizeOf M₂\ninst✝ : SizeOf N₂\ntoHom : P.Hom Q\nbijective_weightMap : Function.Bijective ⇑toHom.weightMap\nbijective_coweightMap : Function.Bijective ⇑toHom.coweightMap\n⊢ Eq (SizeOf.sizeOf { toHom := toHom, bijective_weightMap := bijective_weightMap, bijective_coweightMap := bijective_coweightMap }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toHom)) (SizeOf.sizeOf bijective_weightMap)) (SizeOf.sizeOf bijective_coweightMap))","decl":"/-- An equivalence of root pairings is a morphism where the maps of weight and coweight spaces are\nbijective.\n\nSee also `RootPairing.Equiv.toEndUnit`. -/\n@[ext]\nprotected structure Equiv extends Hom P Q where\n  bijective_weightMap : Bijective weightMap\n  bijective_coweightMap : Bijective coweightMap\n\n"}
{"name":"RootPairing.Equiv.bijective_weightMap","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nι₂ : Type u_5\nM₂ : Type u_6\nN₂ : Type u_7\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nQ : RootPairing ι₂ R M₂ N₂\nself : P.Equiv Q\n⊢ Function.Bijective ⇑self.weightMap","decl":"/-- An equivalence of root pairings is a morphism where the maps of weight and coweight spaces are\nbijective.\n\nSee also `RootPairing.Equiv.toEndUnit`. -/\n@[ext]\nprotected structure Equiv extends Hom P Q where\n  bijective_weightMap : Bijective weightMap\n  bijective_coweightMap : Bijective coweightMap\n\n"}
{"name":"RootPairing.Equiv.mk.inj","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nι₂ : Type u_5\nM₂ : Type u_6\nN₂ : Type u_7\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nQ : RootPairing ι₂ R M₂ N₂\ntoHom✝ : P.Hom Q\nbijective_weightMap✝ : Function.Bijective ⇑toHom✝.weightMap\nbijective_coweightMap✝ : Function.Bijective ⇑toHom✝.coweightMap\ntoHom : P.Hom Q\nbijective_weightMap : Function.Bijective ⇑toHom.weightMap\nbijective_coweightMap : Function.Bijective ⇑toHom.coweightMap\nx✝ : Eq { toHom := toHom✝, bijective_weightMap := bijective_weightMap✝, bijective_coweightMap := bijective_coweightMap✝ } { toHom := toHom, bijective_weightMap := bijective_weightMap, bijective_coweightMap := bijective_coweightMap }\n⊢ Eq toHom✝ toHom","decl":"/-- An equivalence of root pairings is a morphism where the maps of weight and coweight spaces are\nbijective.\n\nSee also `RootPairing.Equiv.toEndUnit`. -/\n@[ext]\nprotected structure Equiv extends Hom P Q where\n  bijective_weightMap : Bijective weightMap\n  bijective_coweightMap : Bijective coweightMap\n\n"}
{"name":"RootPairing.Equiv.ext_iff","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nι₂ : Type u_5\nM₂ : Type u_6\nN₂ : Type u_7\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nQ : RootPairing ι₂ R M₂ N₂\nx y : P.Equiv Q\n⊢ Iff (Eq x y) (And (Eq x.weightMap y.weightMap) (And (Eq x.coweightMap y.coweightMap) (Eq x.indexEquiv y.indexEquiv)))","decl":"/-- An equivalence of root pairings is a morphism where the maps of weight and coweight spaces are\nbijective.\n\nSee also `RootPairing.Equiv.toEndUnit`. -/\n@[ext]\nprotected structure Equiv extends Hom P Q where\n  bijective_weightMap : Bijective weightMap\n  bijective_coweightMap : Bijective coweightMap\n\n"}
{"name":"RootPairing.Equiv.mk.injEq","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nι₂ : Type u_5\nM₂ : Type u_6\nN₂ : Type u_7\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nQ : RootPairing ι₂ R M₂ N₂\ntoHom✝ : P.Hom Q\nbijective_weightMap✝ : Function.Bijective ⇑toHom✝.weightMap\nbijective_coweightMap✝ : Function.Bijective ⇑toHom✝.coweightMap\ntoHom : P.Hom Q\nbijective_weightMap : Function.Bijective ⇑toHom.weightMap\nbijective_coweightMap : Function.Bijective ⇑toHom.coweightMap\n⊢ Eq (Eq { toHom := toHom✝, bijective_weightMap := bijective_weightMap✝, bijective_coweightMap := bijective_coweightMap✝ } { toHom := toHom, bijective_weightMap := bijective_weightMap, bijective_coweightMap := bijective_coweightMap }) (Eq toHom✝ toHom)","decl":"/-- An equivalence of root pairings is a morphism where the maps of weight and coweight spaces are\nbijective.\n\nSee also `RootPairing.Equiv.toEndUnit`. -/\n@[ext]\nprotected structure Equiv extends Hom P Q where\n  bijective_weightMap : Bijective weightMap\n  bijective_coweightMap : Bijective coweightMap\n\n"}
{"name":"RootPairing.Equiv.bijective_coweightMap","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nι₂ : Type u_5\nM₂ : Type u_6\nN₂ : Type u_7\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nQ : RootPairing ι₂ R M₂ N₂\nself : P.Equiv Q\n⊢ Function.Bijective ⇑self.coweightMap","decl":"/-- An equivalence of root pairings is a morphism where the maps of weight and coweight spaces are\nbijective.\n\nSee also `RootPairing.Equiv.toEndUnit`. -/\n@[ext]\nprotected structure Equiv extends Hom P Q where\n  bijective_weightMap : Bijective weightMap\n  bijective_coweightMap : Bijective coweightMap\n\n"}
{"name":"RootPairing.Equiv.ext","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nι₂ : Type u_5\nM₂ : Type u_6\nN₂ : Type u_7\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nQ : RootPairing ι₂ R M₂ N₂\nx y : P.Equiv Q\nweightMap : Eq x.weightMap y.weightMap\ncoweightMap : Eq x.coweightMap y.coweightMap\nindexEquiv : Eq x.indexEquiv y.indexEquiv\n⊢ Eq x y","decl":"/-- An equivalence of root pairings is a morphism where the maps of weight and coweight spaces are\nbijective.\n\nSee also `RootPairing.Equiv.toEndUnit`. -/\n@[ext]\nprotected structure Equiv extends Hom P Q where\n  bijective_weightMap : Bijective weightMap\n  bijective_coweightMap : Bijective coweightMap\n\n"}
{"name":"RootPairing.Equiv.weightEquiv_apply","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nι₂ : Type u_5\nM₂ : Type u_6\nN₂ : Type u_7\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nQ : RootPairing ι₂ R M₂ N₂\ne : P.Equiv Q\nm : M\n⊢ Eq ((RootPairing.Equiv.weightEquiv P Q e) m) ((↑e).weightMap m)","decl":"@[simp]\nlemma weightEquiv_apply (e : RootPairing.Equiv P Q) (m : M) :\n    weightEquiv P Q e m = e.toHom.weightMap m :=\n  rfl\n\n"}
{"name":"RootPairing.Equiv.weightEquiv_symm_weightMap","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nι₂ : Type u_5\nM₂ : Type u_6\nN₂ : Type u_7\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nQ : RootPairing ι₂ R M₂ N₂\ne : P.Equiv Q\nm : M\n⊢ Eq ((RootPairing.Equiv.weightEquiv P Q e).symm ((↑e).weightMap m)) m","decl":"@[simp]\nlemma weightEquiv_symm_weightMap (e : RootPairing.Equiv P Q) (m : M) :\n    (weightEquiv P Q e).symm (e.toHom.weightMap m) = m :=\n  (LinearEquiv.symm_apply_eq (weightEquiv P Q e)).mpr rfl\n\n"}
{"name":"RootPairing.Equiv.weightMap_weightEquiv_symm","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nι₂ : Type u_5\nM₂ : Type u_6\nN₂ : Type u_7\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nQ : RootPairing ι₂ R M₂ N₂\ne : P.Equiv Q\nm : M₂\n⊢ Eq ((↑e).weightMap ((RootPairing.Equiv.weightEquiv P Q e).symm m)) m","decl":"@[simp]\nlemma weightMap_weightEquiv_symm (e : RootPairing.Equiv P Q) (m : M₂) :\n    e.toHom.weightMap ((weightEquiv P Q e).symm m) = m := by\n  rw [← weightEquiv_apply]\n  exact LinearEquiv.apply_symm_apply (weightEquiv P Q e) m\n\n"}
{"name":"RootPairing.Equiv.coweightEquiv_apply","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nι₂ : Type u_5\nM₂ : Type u_6\nN₂ : Type u_7\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nQ : RootPairing ι₂ R M₂ N₂\ne : P.Equiv Q\nn : N₂\n⊢ Eq ((RootPairing.Equiv.coweightEquiv P Q e) n) ((↑e).coweightMap n)","decl":"@[simp]\nlemma coweightEquiv_apply (e : RootPairing.Equiv P Q) (n : N₂) :\n    coweightEquiv P Q e n = e.toHom.coweightMap n :=\n  rfl\n\n"}
{"name":"RootPairing.Equiv.coweightEquiv_symm_coweightMap","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nι₂ : Type u_5\nM₂ : Type u_6\nN₂ : Type u_7\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nQ : RootPairing ι₂ R M₂ N₂\ne : P.Equiv Q\nn : N₂\n⊢ Eq ((RootPairing.Equiv.coweightEquiv P Q e).symm ((↑e).coweightMap n)) n","decl":"@[simp]\nlemma coweightEquiv_symm_coweightMap (e : RootPairing.Equiv P Q) (n : N₂) :\n    (coweightEquiv P Q e).symm (e.toHom.coweightMap n) = n :=\n  (LinearEquiv.symm_apply_eq (coweightEquiv P Q e)).mpr rfl\n\n"}
{"name":"RootPairing.Equiv.coweightMap_coweightEquiv_symm","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nι₂ : Type u_5\nM₂ : Type u_6\nN₂ : Type u_7\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nQ : RootPairing ι₂ R M₂ N₂\ne : P.Equiv Q\nn : N\n⊢ Eq ((↑e).coweightMap ((RootPairing.Equiv.coweightEquiv P Q e).symm n)) n","decl":"@[simp]\nlemma coweightMap_coweightEquiv_symm (e : RootPairing.Equiv P Q) (n : N) :\n    e.toHom.coweightMap ((coweightEquiv P Q e).symm n) = n := by\n  rw [← coweightEquiv_apply]\n  exact LinearEquiv.apply_symm_apply (coweightEquiv P Q e) n\n\n"}
{"name":"RootPairing.Equiv.id_indexEquiv_symm_apply","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\na : ι\n⊢ Eq ((↑(RootPairing.Equiv.id P)).indexEquiv.symm a) a","decl":"/-- The identity equivalence of a root pairing. -/\n@[simps!]\ndef id (P : RootPairing ι R M N) : RootPairing.Equiv P P :=\n  { Hom.id P with\n    bijective_weightMap := _root_.id bijective_id\n    bijective_coweightMap := _root_.id bijective_id }\n\n"}
{"name":"RootPairing.Equiv.id_coweightMap_apply","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\na : N\n⊢ Eq ((↑(RootPairing.Equiv.id P)).coweightMap a) a","decl":"/-- The identity equivalence of a root pairing. -/\n@[simps!]\ndef id (P : RootPairing ι R M N) : RootPairing.Equiv P P :=\n  { Hom.id P with\n    bijective_weightMap := _root_.id bijective_id\n    bijective_coweightMap := _root_.id bijective_id }\n\n"}
{"name":"RootPairing.Equiv.id_indexEquiv_apply","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\na : ι\n⊢ Eq ((↑(RootPairing.Equiv.id P)).indexEquiv a) a","decl":"/-- The identity equivalence of a root pairing. -/\n@[simps!]\ndef id (P : RootPairing ι R M N) : RootPairing.Equiv P P :=\n  { Hom.id P with\n    bijective_weightMap := _root_.id bijective_id\n    bijective_coweightMap := _root_.id bijective_id }\n\n"}
{"name":"RootPairing.Equiv.id_weightMap_apply","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\na : M\n⊢ Eq ((↑(RootPairing.Equiv.id P)).weightMap a) a","decl":"/-- The identity equivalence of a root pairing. -/\n@[simps!]\ndef id (P : RootPairing ι R M N) : RootPairing.Equiv P P :=\n  { Hom.id P with\n    bijective_weightMap := _root_.id bijective_id\n    bijective_coweightMap := _root_.id bijective_id }\n\n"}
{"name":"RootPairing.Equiv.comp_coweightMap_apply","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹² : CommRing R\ninst✝¹¹ : AddCommGroup M\ninst✝¹⁰ : Module R M\ninst✝⁹ : AddCommGroup N\ninst✝⁸ : Module R N\nι₁ : Type u_8\nM₁ : Type u_9\nN₁ : Type u_10\nι₂ : Type u_11\nM₂ : Type u_12\nN₂ : Type u_13\ninst✝⁷ : AddCommGroup M₁\ninst✝⁶ : Module R M₁\ninst✝⁵ : AddCommGroup N₁\ninst✝⁴ : Module R N₁\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nP₁ : RootPairing ι₁ R M₁ N₁\nP₂ : RootPairing ι₂ R M₂ N₂\ng : P₁.Equiv P₂\nf : P.Equiv P₁\na✝ : N₂\n⊢ Eq ((↑(g.comp f)).coweightMap a✝) ((↑f).coweightMap ((↑g).coweightMap a✝))","decl":"/-- Composition of equivalences -/\n@[simps!]\ndef comp {ι₁ M₁ N₁ ι₂ M₂ N₂ : Type*} [AddCommGroup M₁] [Module R M₁] [AddCommGroup N₁]\n    [Module R N₁] [AddCommGroup M₂] [Module R M₂] [AddCommGroup N₂] [Module R N₂]\n    {P : RootPairing ι R M N} {P₁ : RootPairing ι₁ R M₁ N₁} {P₂ : RootPairing ι₂ R M₂ N₂}\n    (g : RootPairing.Equiv P₁ P₂) (f : RootPairing.Equiv P P₁) : RootPairing.Equiv P P₂ :=\n  { Hom.comp g.toHom f.toHom with\n    bijective_weightMap := by\n      simp only [Hom.comp, LinearMap.coe_comp]\n      exact Bijective.comp g.bijective_weightMap f.bijective_weightMap\n    bijective_coweightMap := by\n      simp only [Hom.comp, LinearMap.coe_comp]\n      exact Bijective.comp f.bijective_coweightMap g.bijective_coweightMap }\n\n"}
{"name":"RootPairing.Equiv.comp_indexEquiv_symm_apply","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹² : CommRing R\ninst✝¹¹ : AddCommGroup M\ninst✝¹⁰ : Module R M\ninst✝⁹ : AddCommGroup N\ninst✝⁸ : Module R N\nι₁ : Type u_8\nM₁ : Type u_9\nN₁ : Type u_10\nι₂ : Type u_11\nM₂ : Type u_12\nN₂ : Type u_13\ninst✝⁷ : AddCommGroup M₁\ninst✝⁶ : Module R M₁\ninst✝⁵ : AddCommGroup N₁\ninst✝⁴ : Module R N₁\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nP₁ : RootPairing ι₁ R M₁ N₁\nP₂ : RootPairing ι₂ R M₂ N₂\ng : P₁.Equiv P₂\nf : P.Equiv P₁\na✝ : ι₂\n⊢ Eq ((↑(g.comp f)).indexEquiv.symm a✝) ((↑f).indexEquiv.symm ((↑g).indexEquiv.symm a✝))","decl":"/-- Composition of equivalences -/\n@[simps!]\ndef comp {ι₁ M₁ N₁ ι₂ M₂ N₂ : Type*} [AddCommGroup M₁] [Module R M₁] [AddCommGroup N₁]\n    [Module R N₁] [AddCommGroup M₂] [Module R M₂] [AddCommGroup N₂] [Module R N₂]\n    {P : RootPairing ι R M N} {P₁ : RootPairing ι₁ R M₁ N₁} {P₂ : RootPairing ι₂ R M₂ N₂}\n    (g : RootPairing.Equiv P₁ P₂) (f : RootPairing.Equiv P P₁) : RootPairing.Equiv P P₂ :=\n  { Hom.comp g.toHom f.toHom with\n    bijective_weightMap := by\n      simp only [Hom.comp, LinearMap.coe_comp]\n      exact Bijective.comp g.bijective_weightMap f.bijective_weightMap\n    bijective_coweightMap := by\n      simp only [Hom.comp, LinearMap.coe_comp]\n      exact Bijective.comp f.bijective_coweightMap g.bijective_coweightMap }\n\n"}
{"name":"RootPairing.Equiv.comp_indexEquiv_apply","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹² : CommRing R\ninst✝¹¹ : AddCommGroup M\ninst✝¹⁰ : Module R M\ninst✝⁹ : AddCommGroup N\ninst✝⁸ : Module R N\nι₁ : Type u_8\nM₁ : Type u_9\nN₁ : Type u_10\nι₂ : Type u_11\nM₂ : Type u_12\nN₂ : Type u_13\ninst✝⁷ : AddCommGroup M₁\ninst✝⁶ : Module R M₁\ninst✝⁵ : AddCommGroup N₁\ninst✝⁴ : Module R N₁\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nP₁ : RootPairing ι₁ R M₁ N₁\nP₂ : RootPairing ι₂ R M₂ N₂\ng : P₁.Equiv P₂\nf : P.Equiv P₁\na✝ : ι\n⊢ Eq ((↑(g.comp f)).indexEquiv a✝) ((↑g).indexEquiv ((↑f).indexEquiv a✝))","decl":"/-- Composition of equivalences -/\n@[simps!]\ndef comp {ι₁ M₁ N₁ ι₂ M₂ N₂ : Type*} [AddCommGroup M₁] [Module R M₁] [AddCommGroup N₁]\n    [Module R N₁] [AddCommGroup M₂] [Module R M₂] [AddCommGroup N₂] [Module R N₂]\n    {P : RootPairing ι R M N} {P₁ : RootPairing ι₁ R M₁ N₁} {P₂ : RootPairing ι₂ R M₂ N₂}\n    (g : RootPairing.Equiv P₁ P₂) (f : RootPairing.Equiv P P₁) : RootPairing.Equiv P P₂ :=\n  { Hom.comp g.toHom f.toHom with\n    bijective_weightMap := by\n      simp only [Hom.comp, LinearMap.coe_comp]\n      exact Bijective.comp g.bijective_weightMap f.bijective_weightMap\n    bijective_coweightMap := by\n      simp only [Hom.comp, LinearMap.coe_comp]\n      exact Bijective.comp f.bijective_coweightMap g.bijective_coweightMap }\n\n"}
{"name":"RootPairing.Equiv.comp_weightMap_apply","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹² : CommRing R\ninst✝¹¹ : AddCommGroup M\ninst✝¹⁰ : Module R M\ninst✝⁹ : AddCommGroup N\ninst✝⁸ : Module R N\nι₁ : Type u_8\nM₁ : Type u_9\nN₁ : Type u_10\nι₂ : Type u_11\nM₂ : Type u_12\nN₂ : Type u_13\ninst✝⁷ : AddCommGroup M₁\ninst✝⁶ : Module R M₁\ninst✝⁵ : AddCommGroup N₁\ninst✝⁴ : Module R N₁\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nP₁ : RootPairing ι₁ R M₁ N₁\nP₂ : RootPairing ι₂ R M₂ N₂\ng : P₁.Equiv P₂\nf : P.Equiv P₁\na✝ : M\n⊢ Eq ((↑(g.comp f)).weightMap a✝) ((↑g).weightMap ((↑f).weightMap a✝))","decl":"/-- Composition of equivalences -/\n@[simps!]\ndef comp {ι₁ M₁ N₁ ι₂ M₂ N₂ : Type*} [AddCommGroup M₁] [Module R M₁] [AddCommGroup N₁]\n    [Module R N₁] [AddCommGroup M₂] [Module R M₂] [AddCommGroup N₂] [Module R N₂]\n    {P : RootPairing ι R M N} {P₁ : RootPairing ι₁ R M₁ N₁} {P₂ : RootPairing ι₂ R M₂ N₂}\n    (g : RootPairing.Equiv P₁ P₂) (f : RootPairing.Equiv P P₁) : RootPairing.Equiv P P₂ :=\n  { Hom.comp g.toHom f.toHom with\n    bijective_weightMap := by\n      simp only [Hom.comp, LinearMap.coe_comp]\n      exact Bijective.comp g.bijective_weightMap f.bijective_weightMap\n    bijective_coweightMap := by\n      simp only [Hom.comp, LinearMap.coe_comp]\n      exact Bijective.comp f.bijective_coweightMap g.bijective_coweightMap }\n\n"}
{"name":"RootPairing.Equiv.toHom_comp","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹² : CommRing R\ninst✝¹¹ : AddCommGroup M\ninst✝¹⁰ : Module R M\ninst✝⁹ : AddCommGroup N\ninst✝⁸ : Module R N\nι₁ : Type u_8\nM₁ : Type u_9\nN₁ : Type u_10\nι₂ : Type u_11\nM₂ : Type u_12\nN₂ : Type u_13\ninst✝⁷ : AddCommGroup M₁\ninst✝⁶ : Module R M₁\ninst✝⁵ : AddCommGroup N₁\ninst✝⁴ : Module R N₁\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nP₁ : RootPairing ι₁ R M₁ N₁\nP₂ : RootPairing ι₂ R M₂ N₂\ng : P₁.Equiv P₂\nf : P.Equiv P₁\n⊢ Eq (↑(g.comp f)) ((↑g).comp ↑f)","decl":"@[simp]\nlemma toHom_comp {ι₁ M₁ N₁ ι₂ M₂ N₂ : Type*} [AddCommGroup M₁] [Module R M₁] [AddCommGroup N₁]\n    [Module R N₁] [AddCommGroup M₂] [Module R M₂] [AddCommGroup N₂] [Module R N₂]\n    {P : RootPairing ι R M N} {P₁ : RootPairing ι₁ R M₁ N₁} {P₂ : RootPairing ι₂ R M₂ N₂}\n    (g : RootPairing.Equiv P₁ P₂) (f : RootPairing.Equiv P P₁) :\n    (Equiv.comp g f).toHom = Hom.comp g.toHom f.toHom := by\n  rfl\n\n"}
{"name":"RootPairing.Equiv.id_comp","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nι₂ : Type u_8\nM₂ : Type u_9\nN₂ : Type u_10\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nQ : RootPairing ι₂ R M₂ N₂\nf : P.Equiv Q\n⊢ Eq (f.comp (RootPairing.Equiv.id P)) f","decl":"@[simp]\nlemma id_comp {ι₂ M₂ N₂ : Type*}\n    [AddCommGroup M₂] [Module R M₂] [AddCommGroup N₂] [Module R N₂]\n    (P : RootPairing ι R M N) (Q : RootPairing ι₂ R M₂ N₂) (f : RootPairing.Equiv P Q) :\n    comp f (id P) = f := by\n  ext x <;> simp\n\n"}
{"name":"RootPairing.Equiv.comp_id","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nι₂ : Type u_8\nM₂ : Type u_9\nN₂ : Type u_10\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nQ : RootPairing ι₂ R M₂ N₂\nf : P.Equiv Q\n⊢ Eq ((RootPairing.Equiv.id Q).comp f) f","decl":"@[simp]\nlemma comp_id {ι₂ M₂ N₂ : Type*}\n    [AddCommGroup M₂] [Module R M₂] [AddCommGroup N₂] [Module R N₂]\n    (P : RootPairing ι R M N) (Q : RootPairing ι₂ R M₂ N₂) (f : RootPairing.Equiv P Q) :\n    comp (id Q) f = f := by\n  ext x <;> simp\n\n"}
{"name":"RootPairing.Equiv.comp_assoc","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹⁶ : CommRing R\ninst✝¹⁵ : AddCommGroup M\ninst✝¹⁴ : Module R M\ninst✝¹³ : AddCommGroup N\ninst✝¹² : Module R N\nι₁ : Type u_8\nM₁ : Type u_9\nN₁ : Type u_10\nι₂ : Type u_11\nM₂ : Type u_12\nN₂ : Type u_13\nι₃ : Type u_14\nM₃ : Type u_15\nN₃ : Type u_16\ninst✝¹¹ : AddCommGroup M₁\ninst✝¹⁰ : Module R M₁\ninst✝⁹ : AddCommGroup N₁\ninst✝⁸ : Module R N₁\ninst✝⁷ : AddCommGroup M₂\ninst✝⁶ : Module R M₂\ninst✝⁵ : AddCommGroup N₂\ninst✝⁴ : Module R N₂\ninst✝³ : AddCommGroup M₃\ninst✝² : Module R M₃\ninst✝¹ : AddCommGroup N₃\ninst✝ : Module R N₃\nP : RootPairing ι R M N\nP₁ : RootPairing ι₁ R M₁ N₁\nP₂ : RootPairing ι₂ R M₂ N₂\nP₃ : RootPairing ι₃ R M₃ N₃\nh : P₂.Equiv P₃\ng : P₁.Equiv P₂\nf : P.Equiv P₁\n⊢ Eq ((h.comp g).comp f) (h.comp (g.comp f))","decl":"@[simp]\nlemma comp_assoc {ι₁ M₁ N₁ ι₂ M₂ N₂ ι₃ M₃ N₃ : Type*} [AddCommGroup M₁] [Module R M₁]\n    [AddCommGroup N₁] [Module R N₁] [AddCommGroup M₂] [Module R M₂] [AddCommGroup N₂] [Module R N₂]\n    [AddCommGroup M₃] [Module R M₃] [AddCommGroup N₃] [Module R N₃] {P : RootPairing ι R M N}\n    {P₁ : RootPairing ι₁ R M₁ N₁} {P₂ : RootPairing ι₂ R M₂ N₂} {P₃ : RootPairing ι₃ R M₃ N₃}\n    (h : RootPairing.Equiv P₂ P₃) (g : RootPairing.Equiv P₁ P₂) (f : RootPairing.Equiv P P₁) :\n    comp (comp h g) f = comp h (comp g f) := by\n  ext <;> simp\n\n"}
{"name":"RootPairing.Equiv.weightEquiv_one","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ Eq (↑(RootPairing.Equiv.weightEquiv P P 1)) LinearMap.id","decl":"@[simp]\nlemma weightEquiv_one (P : RootPairing ι R M N) :\n    weightEquiv (P := P) (Q := P) 1 = LinearMap.id (R := R) (M := M) :=\n  rfl\n\n"}
{"name":"RootPairing.Equiv.coweightEquiv_one","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ Eq (↑(RootPairing.Equiv.coweightEquiv P P 1)) LinearMap.id","decl":"@[simp]\nlemma coweightEquiv_one (P : RootPairing ι R M N) :\n    coweightEquiv (P := P) (Q := P) 1 = LinearMap.id (R := R) (M := N) :=\n  rfl\n\n"}
{"name":"RootPairing.Equiv.toHom_one","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ Eq (↑1) 1","decl":"@[simp]\nlemma toHom_one (P : RootPairing ι R M N) :\n    (1 : RootPairing.Equiv P P).toHom = (1 : RootPairing.Hom P P) :=\n  rfl\n\n"}
{"name":"RootPairing.Equiv.mul_eq_comp","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nx y : P.Equiv P\n⊢ Eq (HMul.hMul x y) (x.comp y)","decl":"@[simp]\nlemma mul_eq_comp {P : RootPairing ι R M N} (x y : RootPairing.Equiv P P) :\n    x * y = Equiv.comp x y :=\n  rfl\n\n"}
{"name":"RootPairing.Equiv.weightEquiv_comp_toLin","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nx y : P.Equiv P\n⊢ Eq (RootPairing.Equiv.weightEquiv P P (x.comp y)) ((RootPairing.Equiv.weightEquiv P P y).trans (RootPairing.Equiv.weightEquiv P P x))","decl":"@[simp]\nlemma weightEquiv_comp_toLin {P : RootPairing ι R M N} (x y : RootPairing.Equiv P P) :\n    weightEquiv P P (Equiv.comp x y) = weightEquiv P P y ≪≫ₗ weightEquiv P P x := by\n  ext; simp\n\n"}
{"name":"RootPairing.Equiv.weightEquiv_mul","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nx y : P.Equiv P\n⊢ Eq (HMul.hMul (RootPairing.Equiv.weightEquiv P P x) (RootPairing.Equiv.weightEquiv P P y)) ((RootPairing.Equiv.weightEquiv P P y).trans (RootPairing.Equiv.weightEquiv P P x))","decl":"@[simp]\nlemma weightEquiv_mul {P : RootPairing ι R M N} (x y : RootPairing.Equiv P P) :\n    weightEquiv P P x * weightEquiv P P y = weightEquiv P P y ≪≫ₗ weightEquiv P P x := by\n  rfl\n\n"}
{"name":"RootPairing.Equiv.coweightEquiv_comp_toLin","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nx y : P.Equiv P\n⊢ Eq (RootPairing.Equiv.coweightEquiv P P (x.comp y)) ((RootPairing.Equiv.coweightEquiv P P x).trans (RootPairing.Equiv.coweightEquiv P P y))","decl":"@[simp]\nlemma coweightEquiv_comp_toLin {P : RootPairing ι R M N} (x y : RootPairing.Equiv P P) :\n    coweightEquiv P P (Equiv.comp x y) = coweightEquiv P P x ≪≫ₗ coweightEquiv P P y := by\n  ext; simp\n\n"}
{"name":"RootPairing.Equiv.coweightEquiv_mul","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nx y : P.Equiv P\n⊢ Eq (HMul.hMul (RootPairing.Equiv.coweightEquiv P P x) (RootPairing.Equiv.coweightEquiv P P y)) ((RootPairing.Equiv.coweightEquiv P P y).trans (RootPairing.Equiv.coweightEquiv P P x))","decl":"@[simp]\nlemma coweightEquiv_mul {P : RootPairing ι R M N} (x y : RootPairing.Equiv P P) :\n    coweightEquiv P P x * coweightEquiv P P y = coweightEquiv P P y ≪≫ₗ coweightEquiv P P x := by\n  rfl\n\n"}
{"name":"RootPairing.Equiv.inv_weightMap","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nι₂ : Type u_8\nM₂ : Type u_9\nN₂ : Type u_10\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nQ : RootPairing ι₂ R M₂ N₂\nf : P.Equiv Q\n⊢ Eq (↑(RootPairing.Equiv.symm P Q f)).weightMap ↑(RootPairing.Equiv.weightEquiv P Q f).symm","decl":"@[simp]\nlemma inv_weightMap {ι₂ M₂ N₂ : Type*} [AddCommGroup M₂] [Module R M₂] [AddCommGroup N₂]\n    [Module R N₂] (P : RootPairing ι R M N) (Q : RootPairing ι₂ R M₂ N₂)\n    (f : RootPairing.Equiv P Q) : (symm P Q f).weightMap = (weightEquiv P Q f).symm :=\n  rfl\n\n"}
{"name":"RootPairing.Equiv.inv_coweightMap","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nι₂ : Type u_8\nM₂ : Type u_9\nN₂ : Type u_10\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nQ : RootPairing ι₂ R M₂ N₂\nf : P.Equiv Q\n⊢ Eq (↑(RootPairing.Equiv.symm P Q f)).coweightMap ↑(RootPairing.Equiv.coweightEquiv P Q f).symm","decl":"@[simp]\nlemma inv_coweightMap {ι₂ M₂ N₂ : Type*} [AddCommGroup M₂] [Module R M₂] [AddCommGroup N₂]\n    [Module R N₂] (P : RootPairing ι R M N) (Q : RootPairing ι₂ R M₂ N₂)\n    (f : RootPairing.Equiv P Q) : (symm P Q f).coweightMap = (coweightEquiv P Q f).symm :=\n  rfl\n\n"}
{"name":"RootPairing.Equiv.inv_indexEquiv","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nι₂ : Type u_8\nM₂ : Type u_9\nN₂ : Type u_10\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommGroup N₂\ninst✝ : Module R N₂\nP : RootPairing ι R M N\nQ : RootPairing ι₂ R M₂ N₂\nf : P.Equiv Q\n⊢ Eq (↑(RootPairing.Equiv.symm P Q f)).indexEquiv (↑f).indexEquiv.symm","decl":"@[simp]\nlemma inv_indexEquiv {ι₂ M₂ N₂ : Type*} [AddCommGroup M₂] [Module R M₂] [AddCommGroup N₂]\n    [Module R N₂] (P : RootPairing ι R M N) (Q : RootPairing ι₂ R M₂ N₂)\n    (f : RootPairing.Equiv P Q) : (symm P Q f).indexEquiv = (Hom.indexEquiv f.toHom).symm :=\n  rfl\n\n"}
{"name":"RootPairing.Equiv.toEndUnit_val","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ng : P.Aut\n⊢ Eq ↑((RootPairing.Equiv.toEndUnit P) g) ↑g","decl":"lemma toEndUnit_val (P : RootPairing ι R M N) (g : Aut P) : (toEndUnit P g).val = g.toHom :=\n  rfl\n\n"}
{"name":"RootPairing.Equiv.toEndUnit_inv","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ng : P.Aut\n⊢ Eq ((RootPairing.Equiv.toEndUnit P) g).inv ↑(RootPairing.Equiv.symm P P g)","decl":"lemma toEndUnit_inv (P : RootPairing ι R M N) (g : Aut P) :\n    (toEndUnit P g).inv = (symm P P g).toHom :=\n  rfl\n\n"}
{"name":"RootPairing.Equiv.weightHom_apply","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ne : P.Equiv P\n⊢ Eq ((RootPairing.Equiv.weightHom P) e) (RootPairing.Equiv.weightEquiv P P e)","decl":"/-- The weight space representation of automorphisms -/\n@[simps]\ndef weightHom (P : RootPairing ι R M N) : Aut P →* (M ≃ₗ[R] M) where\n  toFun := weightEquiv P P\n  map_one' := by ext; simp\n  map_mul' x y := by ext; simp\n\n"}
{"name":"RootPairing.Equiv.weightHom_toLinearMap","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ng : P.Aut\n⊢ Eq (↑((RootPairing.Equiv.weightHom P) g)) ((RootPairing.Hom.weightHom P) ↑g)","decl":"lemma weightHom_toLinearMap {P : RootPairing ι R M N} (g : Aut P) :\n    (weightHom P g).toLinearMap = Hom.weightHom P g.toHom :=\n  rfl\n\n"}
{"name":"RootPairing.Equiv.weightHom_injective","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ Function.Injective ⇑(RootPairing.Equiv.weightHom P)","decl":"lemma weightHom_injective (P : RootPairing ι R M N) : Injective (Equiv.weightHom P) := by\n  refine Injective.of_comp (f := LinearEquiv.toLinearMap) fun g g' hgg' => ?_\n  let h : (weightHom P g).toLinearMap = (weightHom P g').toLinearMap := hgg' --`have` gets lint\n  rw [weightHom_toLinearMap, weightHom_toLinearMap] at h\n  suffices h' : g.toHom = g'.toHom by\n    exact Equiv.ext hgg' (congrArg Hom.coweightMap h') (congrArg Hom.indexEquiv h')\n  exact Hom.weightHom_injective P hgg'\n\n"}
{"name":"RootPairing.Equiv.weightEquiv_inv","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ng : P.Aut\n⊢ Eq (RootPairing.Equiv.weightEquiv P P (Inv.inv g)) (Inv.inv (RootPairing.Equiv.weightEquiv P P g))","decl":"@[simp]\nlemma weightEquiv_inv {P : RootPairing ι R M N} (g : Aut P) :\n    weightEquiv P P g⁻¹ = (weightEquiv P P g)⁻¹ :=\n  LinearEquiv.toLinearMap_inj.mp rfl\n\n"}
{"name":"RootPairing.Equiv.coweightHom_apply","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ng : P.Aut\n⊢ Eq ((RootPairing.Equiv.coweightHom P) g) (MulOpposite.op (RootPairing.Equiv.coweightEquiv P P g))","decl":"/-- The coweight space representation of automorphisms -/\n@[simps]\ndef coweightHom (P : RootPairing ι R M N) : Aut P →* (N ≃ₗ[R] N)ᵐᵒᵖ where\n  toFun g := MulOpposite.op (coweightEquiv P P g)\n  map_one' := by\n    simp only [MulOpposite.op_eq_one_iff]\n    exact LinearEquiv.toLinearMap_inj.mp rfl\n  map_mul' := by\n    simp only [mul_eq_comp, coweightEquiv_comp_toLin]\n    exact fun x y ↦ rfl\n\n"}
{"name":"RootPairing.Equiv.coweightHom_toLinearMap","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ng : P.Aut\n⊢ Eq (↑(MulOpposite.unop ((RootPairing.Equiv.coweightHom P) g))) (MulOpposite.unop ((RootPairing.Hom.coweightHom P) ↑g))","decl":"lemma coweightHom_toLinearMap {P : RootPairing ι R M N} (g : Aut P) :\n    (MulOpposite.unop (coweightHom P g)).toLinearMap =\n      MulOpposite.unop (Hom.coweightHom P g.toHom) :=\n  rfl\n\n"}
{"name":"RootPairing.Equiv.coweightHom_injective","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\n⊢ Function.Injective ⇑(RootPairing.Equiv.coweightHom P)","decl":"lemma coweightHom_injective (P : RootPairing ι R M N) : Injective (Equiv.coweightHom P) := by\n  refine Injective.of_comp (f := fun a => MulOpposite.op a) fun g g' hgg' => ?_\n  have h : (MulOpposite.unop (coweightHom P g)).toLinearMap =\n      (MulOpposite.unop (coweightHom P g')).toLinearMap := by\n    simp_all\n  rw [coweightHom_toLinearMap, coweightHom_toLinearMap] at h\n  suffices h' : g.toHom = g'.toHom by\n    exact Equiv.ext (congrArg Hom.weightMap h') h (congrArg Hom.indexEquiv h')\n  apply Hom.coweightHom_injective P\n  exact MulOpposite.unop_inj.mp h\n\n"}
{"name":"RootPairing.Equiv.coweightHom_op","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ng : P.Aut\n⊢ Eq (MulOpposite.unop ((RootPairing.Equiv.coweightHom P) g)) (RootPairing.Equiv.coweightEquiv P P g)","decl":"lemma coweightHom_op {P : RootPairing ι R M N} (g : Aut P) :\n    MulOpposite.unop (coweightHom P g) = coweightEquiv P P g :=\n  rfl\n\n"}
{"name":"RootPairing.Equiv.coweightEquiv_inv","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ng : P.Aut\n⊢ Eq (RootPairing.Equiv.coweightEquiv P P (Inv.inv g)) (Inv.inv (RootPairing.Equiv.coweightEquiv P P g))","decl":"@[simp]\nlemma coweightEquiv_inv {P : RootPairing ι R M N} (g : Aut P) :\n    coweightEquiv P P g⁻¹ = (coweightEquiv P P g)⁻¹ :=\n  LinearEquiv.toLinearMap_inj.mp rfl\n\n"}
{"name":"RootPairing.Equiv.indexHom_apply","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ng : P.Aut\n⊢ Eq ((RootPairing.Equiv.indexHom P) g) (↑g).indexEquiv","decl":"/-- The permutation representation of the automorphism group on the root index set -/\n@[simps]\ndef indexHom (P : RootPairing ι R M N) : Aut P →* (ι ≃ ι) where\n  toFun g := g.toHom.indexEquiv\n  map_one' := by ext; simp\n  map_mul' x y := by ext; simp\n\n"}
{"name":"RootPairing.Equiv.indexEquiv_inv","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ng : P.Aut\n⊢ Eq (↑(Inv.inv g)).indexEquiv (Inv.inv ((RootPairing.Equiv.indexHom P) g))","decl":"@[simp]\nlemma indexEquiv_inv {P : RootPairing ι R M N} (g : Aut P) :\n    (g⁻¹).toHom.indexEquiv = (indexHom P g)⁻¹ :=\n  rfl\n\n"}
{"name":"RootPairing.Equiv.reflection_weightEquiv","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\n⊢ Eq (RootPairing.Equiv.weightEquiv P P (RootPairing.Equiv.reflection P i)) (P.reflection i)","decl":"@[simp]\nlemma reflection_weightEquiv (P : RootPairing ι R M N) (i : ι) :\n    (reflection P i).weightEquiv = P.reflection i :=\n  LinearEquiv.toLinearMap_inj.mp rfl\n\n"}
{"name":"RootPairing.Equiv.reflection_coweightEquiv","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\n⊢ Eq (RootPairing.Equiv.coweightEquiv P P (RootPairing.Equiv.reflection P i)) (P.coreflection i)","decl":"@[simp]\nlemma reflection_coweightEquiv (P : RootPairing ι R M N) (i : ι) :\n    (reflection P i).coweightEquiv = P.coreflection i :=\n  LinearEquiv.toLinearMap_inj.mp rfl\n\n"}
{"name":"RootPairing.Equiv.reflection_indexEquiv","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\n⊢ Eq (↑(RootPairing.Equiv.reflection P i)).indexEquiv (P.reflection_perm i)","decl":"@[simp]\nlemma reflection_indexEquiv (P : RootPairing ι R M N) (i : ι) :\n    (reflection P i).indexEquiv = P.reflection_perm i :=\n  rfl\n\n"}
{"name":"RootPairing.Equiv.reflection_inv","module":"Mathlib.LinearAlgebra.RootSystem.Hom","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\ni : ι\n⊢ Eq (Inv.inv (RootPairing.Equiv.reflection P i)) (RootPairing.Equiv.reflection P i)","decl":"@[simp]\nlemma reflection_inv (P : RootPairing ι R M N) (i : ι) :\n    (reflection P i)⁻¹ = (reflection P i) := by\n  refine Equiv.ext ?_ ?_ ?_\n  · exact LinearMap.ext_iff.mpr (fun x => by simp [← weightEquiv_apply])\n  · exact LinearMap.ext_iff.mpr (fun x => by simp [← coweightEquiv_apply])\n  · exact _root_.Equiv.ext (fun j => by simp only [← indexHom_apply, map_inv]; simp)\n\n"}
