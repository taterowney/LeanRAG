{"name":"MeasureTheory.lintegral_def","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_5\nxâœ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ f) (iSup fun g => iSup fun x => g.lintegral Î¼)","decl":"/-- The **lower Lebesgue integral** of a function `f` with respect to a measure `Î¼`. -/\nirreducible_def lintegral {_ : MeasurableSpace Î±} (Î¼ : Measure Î±) (f : Î± â†’ â„â‰¥0âˆ) : â„â‰¥0âˆ :=\n  â¨† (g : Î± â†’â‚› â„â‰¥0âˆ) (_ : â‡‘g â‰¤ f), g.lintegral Î¼\n\n"}
{"name":"MeasureTheory.SimpleFunc.lintegral_eq_lintegral","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nf : MeasureTheory.SimpleFunc Î± ENNReal\nÎ¼ : MeasureTheory.Measure Î±\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => f a) (f.lintegral Î¼)","decl":"theorem SimpleFunc.lintegral_eq_lintegral {m : MeasurableSpace Î±} (f : Î± â†’â‚› â„â‰¥0âˆ) (Î¼ : Measure Î±) :\n    âˆ«â» a, f a âˆ‚Î¼ = f.lintegral Î¼ := by\n  rw [MeasureTheory.lintegral]\n  exact le_antisymm (iSupâ‚‚_le fun g hg => lintegral_mono hg <| le_rfl)\n    (le_iSupâ‚‚_of_le f le_rfl le_rfl)\n\n"}
{"name":"MeasureTheory.lintegral_mono'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ Î½ : MeasureTheory.Measure Î±\nhÎ¼Î½ : LE.le Î¼ Î½\nf g : Î± â†’ ENNReal\nhfg : LE.le f g\nâŠ¢ LE.le (MeasureTheory.lintegral Î¼ fun a => f a) (MeasureTheory.lintegral Î½ fun a => g a)","decl":"@[gcongr, mono]\ntheorem lintegral_mono' {m : MeasurableSpace Î±} â¦ƒÎ¼ Î½ : Measure Î±â¦„ (hÎ¼Î½ : Î¼ â‰¤ Î½) â¦ƒf g : Î± â†’ â„â‰¥0âˆâ¦„\n    (hfg : f â‰¤ g) : âˆ«â» a, f a âˆ‚Î¼ â‰¤ âˆ«â» a, g a âˆ‚Î½ := by\n  rw [lintegral, lintegral]\n  exact iSup_mono fun Ï† => iSup_mono' fun hÏ† => âŸ¨le_trans hÏ† hfg, lintegral_mono (le_refl Ï†) hÎ¼Î½âŸ©\n\n-- version where `hfg` is an explicit forall, so that `@[gcongr]` can recognize it\n"}
{"name":"MeasureTheory.lintegral_mono_fn'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ Î½ : MeasureTheory.Measure Î±\nf g : Î± â†’ ENNReal\nhfg : âˆ€ (x : Î±), LE.le (f x) (g x)\nh2 : LE.le Î¼ Î½\nâŠ¢ LE.le (MeasureTheory.lintegral Î¼ fun a => f a) (MeasureTheory.lintegral Î½ fun a => g a)","decl":"@[gcongr] theorem lintegral_mono_fn' â¦ƒf g : Î± â†’ â„â‰¥0âˆâ¦„ (hfg : âˆ€ x, f x â‰¤ g x) (h2 : Î¼ â‰¤ Î½) :\n    âˆ«â» a, f a âˆ‚Î¼ â‰¤ âˆ«â» a, g a âˆ‚Î½ :=\n  lintegral_mono' h2 hfg\n\n"}
{"name":"MeasureTheory.lintegral_mono","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ ENNReal\nhfg : LE.le f g\nâŠ¢ LE.le (MeasureTheory.lintegral Î¼ fun a => f a) (MeasureTheory.lintegral Î¼ fun a => g a)","decl":"theorem lintegral_mono â¦ƒf g : Î± â†’ â„â‰¥0âˆâ¦„ (hfg : f â‰¤ g) : âˆ«â» a, f a âˆ‚Î¼ â‰¤ âˆ«â» a, g a âˆ‚Î¼ :=\n  lintegral_mono' (le_refl Î¼) hfg\n\n-- version where `hfg` is an explicit forall, so that `@[gcongr]` can recognize it\n"}
{"name":"MeasureTheory.lintegral_mono_fn","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ ENNReal\nhfg : âˆ€ (x : Î±), LE.le (f x) (g x)\nâŠ¢ LE.le (MeasureTheory.lintegral Î¼ fun a => f a) (MeasureTheory.lintegral Î¼ fun a => g a)","decl":"@[gcongr] theorem lintegral_mono_fn â¦ƒf g : Î± â†’ â„â‰¥0âˆâ¦„ (hfg : âˆ€ x, f x â‰¤ g x) :\n    âˆ«â» a, f a âˆ‚Î¼ â‰¤ âˆ«â» a, g a âˆ‚Î¼ :=\n  lintegral_mono hfg\n\n"}
{"name":"MeasureTheory.lintegral_mono_nnreal","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ NNReal\nh : LE.le f g\nâŠ¢ LE.le (MeasureTheory.lintegral Î¼ fun a => â†‘(f a)) (MeasureTheory.lintegral Î¼ fun a => â†‘(g a))","decl":"theorem lintegral_mono_nnreal {f g : Î± â†’ â„â‰¥0} (h : f â‰¤ g) : âˆ«â» a, f a âˆ‚Î¼ â‰¤ âˆ«â» a, g a âˆ‚Î¼ :=\n  lintegral_mono fun a => ENNReal.coe_le_coe.2 (h a)\n\n"}
{"name":"MeasureTheory.iSup_lintegral_measurable_le_eq_lintegral","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nâŠ¢ Eq (iSup fun g => iSup fun x => iSup fun x => MeasureTheory.lintegral Î¼ fun a => g a) (MeasureTheory.lintegral Î¼ fun a => f a)","decl":"theorem iSup_lintegral_measurable_le_eq_lintegral (f : Î± â†’ â„â‰¥0âˆ) :\n    â¨† (g : Î± â†’ â„â‰¥0âˆ) (_ : Measurable g) (_ : g â‰¤ f), âˆ«â» a, g a âˆ‚Î¼ = âˆ«â» a, f a âˆ‚Î¼ := by\n  apply le_antisymm\n  Â· exact iSup_le fun i => iSup_le fun _ => iSup_le fun h'i => lintegral_mono h'i\n  Â· rw [lintegral]\n    refine iSupâ‚‚_le fun i hi => le_iSupâ‚‚_of_le i i.measurable <| le_iSup_of_le hi ?_\n    exact le_of_eq (i.lintegral_eq_lintegral _).symm\n\n"}
{"name":"MeasureTheory.lintegral_mono_set","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nxâœ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns t : Set Î±\nf : Î± â†’ ENNReal\nhst : HasSubset.Subset s t\nâŠ¢ LE.le (MeasureTheory.lintegral (Î¼.restrict s) fun x => f x) (MeasureTheory.lintegral (Î¼.restrict t) fun x => f x)","decl":"theorem lintegral_mono_set {_ : MeasurableSpace Î±} â¦ƒÎ¼ : Measure Î±â¦„ {s t : Set Î±} {f : Î± â†’ â„â‰¥0âˆ}\n    (hst : s âŠ† t) : âˆ«â» x in s, f x âˆ‚Î¼ â‰¤ âˆ«â» x in t, f x âˆ‚Î¼ :=\n  lintegral_mono' (Measure.restrict_mono hst (le_refl Î¼)) (le_refl f)\n\n"}
{"name":"MeasureTheory.lintegral_mono_set'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nxâœ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns t : Set Î±\nf : Î± â†’ ENNReal\nhst : (MeasureTheory.ae Î¼).EventuallyLE s t\nâŠ¢ LE.le (MeasureTheory.lintegral (Î¼.restrict s) fun x => f x) (MeasureTheory.lintegral (Î¼.restrict t) fun x => f x)","decl":"theorem lintegral_mono_set' {_ : MeasurableSpace Î±} â¦ƒÎ¼ : Measure Î±â¦„ {s t : Set Î±} {f : Î± â†’ â„â‰¥0âˆ}\n    (hst : s â‰¤áµ[Î¼] t) : âˆ«â» x in s, f x âˆ‚Î¼ â‰¤ âˆ«â» x in t, f x âˆ‚Î¼ :=\n  lintegral_mono' (Measure.restrict_mono' hst (le_refl Î¼)) (le_refl f)\n\n"}
{"name":"MeasureTheory.monotone_lintegral","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nxâœ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nâŠ¢ Monotone (MeasureTheory.lintegral Î¼)","decl":"theorem monotone_lintegral {_ : MeasurableSpace Î±} (Î¼ : Measure Î±) : Monotone (lintegral Î¼) :=\n  lintegral_mono\n\n"}
{"name":"MeasureTheory.lintegral_const","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nc : ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun x => c) (HMul.hMul c (Î¼ Set.univ))","decl":"@[simp]\ntheorem lintegral_const (c : â„â‰¥0âˆ) : âˆ«â» _, c âˆ‚Î¼ = c * Î¼ univ := by\n  rw [â† SimpleFunc.const_lintegral, â† SimpleFunc.lintegral_eq_lintegral, SimpleFunc.coe_const]\n  rfl\n\n"}
{"name":"MeasureTheory.lintegral_zero","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun x => 0) 0","decl":"theorem lintegral_zero : âˆ«â» _ : Î±, 0 âˆ‚Î¼ = 0 := by simp\n\n"}
{"name":"MeasureTheory.lintegral_zero_fun","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ 0) 0","decl":"theorem lintegral_zero_fun : lintegral Î¼ (0 : Î± â†’ â„â‰¥0âˆ) = 0 :=\n  lintegral_zero\n\n"}
{"name":"MeasureTheory.lintegral_one","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun x => 1) (Î¼ Set.univ)","decl":"theorem lintegral_one : âˆ«â» _, (1 : â„â‰¥0âˆ) âˆ‚Î¼ = Î¼ univ := by rw [lintegral_const, one_mul]\n\n"}
{"name":"MeasureTheory.setLIntegral_const","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nc : ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict s) fun x => c) (HMul.hMul c (Î¼ s))","decl":"theorem setLIntegral_const (s : Set Î±) (c : â„â‰¥0âˆ) : âˆ«â» _ in s, c âˆ‚Î¼ = c * Î¼ s := by\n  rw [lintegral_const, Measure.restrict_apply_univ]\n\n"}
{"name":"MeasureTheory.setLIntegral_one","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict s) fun x => 1) (Î¼ s)","decl":"theorem setLIntegral_one (s) : âˆ«â» _ in s, 1 âˆ‚Î¼ = Î¼ s := by rw [setLIntegral_const, one_mul]\n\n"}
{"name":"MeasureTheory.setLIntegral_const_lt_top","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\ns : Set Î±\nc : ENNReal\nhc : Ne c Top.top\nâŠ¢ LT.lt (MeasureTheory.lintegral (Î¼.restrict s) fun x => c) Top.top","decl":"theorem setLIntegral_const_lt_top [IsFiniteMeasure Î¼] (s : Set Î±) {c : â„â‰¥0âˆ} (hc : c â‰  âˆ) :\n    âˆ«â» _ in s, c âˆ‚Î¼ < âˆ := by\n  rw [lintegral_const]\n  exact ENNReal.mul_lt_top hc.lt_top (measure_lt_top (Î¼.restrict s) univ)\n\n"}
{"name":"MeasureTheory.lintegral_const_lt_top","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nc : ENNReal\nhc : Ne c Top.top\nâŠ¢ LT.lt (MeasureTheory.lintegral Î¼ fun x => c) Top.top","decl":"theorem lintegral_const_lt_top [IsFiniteMeasure Î¼] {c : â„â‰¥0âˆ} (hc : c â‰  âˆ) : âˆ«â» _, c âˆ‚Î¼ < âˆ := by\n  simpa only [Measure.restrict_univ] using setLIntegral_const_lt_top (univ : Set Î±) hc\n\n"}
{"name":"MeasureTheory.exists_measurable_le_lintegral_eq","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nâŠ¢ Exists fun g => And (Measurable g) (And (LE.le g f) (Eq (MeasureTheory.lintegral Î¼ fun a => f a) (MeasureTheory.lintegral Î¼ fun a => g a)))","decl":"/-- For any function `f : Î± â†’ â„â‰¥0âˆ`, there exists a measurable function `g â‰¤ f` with the same\nintegral. -/\ntheorem exists_measurable_le_lintegral_eq (f : Î± â†’ â„â‰¥0âˆ) :\n    âˆƒ g : Î± â†’ â„â‰¥0âˆ, Measurable g âˆ§ g â‰¤ f âˆ§ âˆ«â» a, f a âˆ‚Î¼ = âˆ«â» a, g a âˆ‚Î¼ := by\n  rcases eq_or_ne (âˆ«â» a, f a âˆ‚Î¼) 0 with hâ‚€ | hâ‚€\n  Â· exact âŸ¨0, measurable_zero, zero_le f, hâ‚€.trans lintegral_zero.symmâŸ©\n  rcases exists_seq_strictMono_tendsto' hâ‚€.bot_lt with âŸ¨L, _, hLf, hL_tendstoâŸ©\n  have : âˆ€ n, âˆƒ g : Î± â†’ â„â‰¥0âˆ, Measurable g âˆ§ g â‰¤ f âˆ§ L n < âˆ«â» a, g a âˆ‚Î¼ := by\n    intro n\n    simpa only [â† iSup_lintegral_measurable_le_eq_lintegral f, lt_iSup_iff, exists_prop] using\n      (hLf n).2\n  choose g hgm hgf hLg using this\n  refine\n    âŸ¨fun x => â¨† n, g n x, .iSup hgm, fun x => iSup_le fun n => hgf n x, le_antisymm ?_ ?_âŸ©\n  Â· refine le_of_tendsto' hL_tendsto fun n => (hLg n).le.trans <| lintegral_mono fun x => ?_\n    exact le_iSup (fun n => g n x) n\n  Â· exact lintegral_mono fun x => iSup_le fun n => hgf n x\n\n"}
{"name":"MeasureTheory.lintegral_eq_nnreal","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nf : Î± â†’ ENNReal\nÎ¼ : MeasureTheory.Measure Î±\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => f a) (iSup fun Ï† => iSup fun x => (MeasureTheory.SimpleFunc.map ENNReal.ofNNReal Ï†).lintegral Î¼)","decl":"/-- `âˆ«â» a in s, f a âˆ‚Î¼` is defined as the supremum of integrals of simple functions\n`Ï† : Î± â†’â‚› â„â‰¥0âˆ` such that `Ï† â‰¤ f`. This lemma says that it suffices to take\nfunctions `Ï† : Î± â†’â‚› â„â‰¥0`. -/\ntheorem lintegral_eq_nnreal {m : MeasurableSpace Î±} (f : Î± â†’ â„â‰¥0âˆ) (Î¼ : Measure Î±) :\n    âˆ«â» a, f a âˆ‚Î¼ =\n      â¨† (Ï† : Î± â†’â‚› â„â‰¥0) (_ : âˆ€ x, â†‘(Ï† x) â‰¤ f x), (Ï†.map ((â†‘) : â„â‰¥0 â†’ â„â‰¥0âˆ)).lintegral Î¼ := by\n  rw [lintegral]\n  refine\n    le_antisymm (iSupâ‚‚_le fun Ï† hÏ† â†¦ ?_) (iSup_mono' fun Ï† â†¦ âŸ¨Ï†.map ((â†‘) : â„â‰¥0 â†’ â„â‰¥0âˆ), le_rflâŸ©)\n  by_cases h : âˆ€áµ a âˆ‚Î¼, Ï† a â‰  âˆ\n  Â· let Ïˆ := Ï†.map ENNReal.toNNReal\n    replace h : Ïˆ.map ((â†‘) : â„â‰¥0 â†’ â„â‰¥0âˆ) =áµ[Î¼] Ï† := h.mono fun a => ENNReal.coe_toNNReal\n    have : âˆ€ x, â†‘(Ïˆ x) â‰¤ f x := fun x => le_trans ENNReal.coe_toNNReal_le_self (hÏ† x)\n    exact le_iSupâ‚‚_of_le (Ï†.map ENNReal.toNNReal) this (ge_of_eq <| lintegral_congr h)\n  Â· have h_meas : Î¼ (Ï† â»Â¹' {âˆ}) â‰  0 := mt measure_zero_iff_ae_nmem.1 h\n    refine le_trans le_top (ge_of_eq <| (iSup_eq_top _).2 fun b hb => ?_)\n    obtain âŸ¨n, hnâŸ© : âˆƒ n : â„•, b < n * Î¼ (Ï† â»Â¹' {âˆ}) := exists_nat_mul_gt h_meas (ne_of_lt hb)\n    use (const Î± (n : â„â‰¥0)).restrict (Ï† â»Â¹' {âˆ})\n    simp only [lt_iSup_iff, exists_prop, coe_restrict, Ï†.measurableSet_preimage, coe_const,\n      ENNReal.coe_indicator, map_coe_ennreal_restrict, SimpleFunc.map_const, ENNReal.coe_natCast,\n      restrict_const_lintegral]\n    refine âŸ¨indicator_le fun x hx => le_trans ?_ (hÏ† _), hnâŸ©\n    simp only [mem_preimage, mem_singleton_iff] at hx\n    simp only [hx, le_top]\n\n"}
{"name":"MeasureTheory.exists_simpleFunc_forall_lintegral_sub_lt_of_pos","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nh : Ne (MeasureTheory.lintegral Î¼ fun x => f x) Top.top\nÎµ : ENNReal\nhÎµ : Ne Îµ 0\nâŠ¢ Exists fun Ï† => And (âˆ€ (x : Î±), LE.le (â†‘(Ï† x)) (f x)) (âˆ€ (Ïˆ : MeasureTheory.SimpleFunc Î± NNReal), (âˆ€ (x : Î±), LE.le (â†‘(Ïˆ x)) (f x)) â†’ LT.lt ((MeasureTheory.SimpleFunc.map ENNReal.ofNNReal (HSub.hSub Ïˆ Ï†)).lintegral Î¼) Îµ)","decl":"theorem exists_simpleFunc_forall_lintegral_sub_lt_of_pos {f : Î± â†’ â„â‰¥0âˆ} (h : âˆ«â» x, f x âˆ‚Î¼ â‰  âˆ)\n    {Îµ : â„â‰¥0âˆ} (hÎµ : Îµ â‰  0) :\n    âˆƒ Ï† : Î± â†’â‚› â„â‰¥0,\n      (âˆ€ x, â†‘(Ï† x) â‰¤ f x) âˆ§\n        âˆ€ Ïˆ : Î± â†’â‚› â„â‰¥0, (âˆ€ x, â†‘(Ïˆ x) â‰¤ f x) â†’ (map (â†‘) (Ïˆ - Ï†)).lintegral Î¼ < Îµ := by\n  rw [lintegral_eq_nnreal] at h\n  have := ENNReal.lt_add_right h hÎµ\n  erw [ENNReal.biSup_add] at this <;> [skip; exact âŸ¨0, fun x => zero_le _âŸ©]\n  simp_rw [lt_iSup_iff, iSup_lt_iff, iSup_le_iff] at this\n  rcases this with âŸ¨Ï†, hle : âˆ€ x, â†‘(Ï† x) â‰¤ f x, b, hbÏ†, hbâŸ©\n  refine âŸ¨Ï†, hle, fun Ïˆ hÏˆ => ?_âŸ©\n  have : (map (â†‘) Ï†).lintegral Î¼ â‰  âˆ := ne_top_of_le_ne_top h (by exact le_iSupâ‚‚ (Î± := â„â‰¥0âˆ) Ï† hle)\n  rw [â† ENNReal.add_lt_add_iff_left this, â† add_lintegral, â† SimpleFunc.map_add @ENNReal.coe_add]\n  refine (hb _ fun x => le_trans ?_ (max_le (hle x) (hÏˆ x))).trans_lt hbÏ†\n  norm_cast\n  simp only [add_apply, sub_apply, add_tsub_eq_max]\n  rfl\n\n"}
{"name":"MeasureTheory.iSup_lintegral_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ¹ : Sort u_5\nf : Î¹ â†’ Î± â†’ ENNReal\nâŠ¢ LE.le (iSup fun i => MeasureTheory.lintegral Î¼ fun a => f i a) (MeasureTheory.lintegral Î¼ fun a => iSup fun i => f i a)","decl":"theorem iSup_lintegral_le {Î¹ : Sort*} (f : Î¹ â†’ Î± â†’ â„â‰¥0âˆ) :\n    â¨† i, âˆ«â» a, f i a âˆ‚Î¼ â‰¤ âˆ«â» a, â¨† i, f i a âˆ‚Î¼ := by\n  simp only [â† iSup_apply]\n  exact (monotone_lintegral Î¼).le_map_iSup\n\n"}
{"name":"MeasureTheory.iSupâ‚‚_lintegral_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ¹ : Sort u_5\nÎ¹' : Î¹ â†’ Sort u_6\nf : (i : Î¹) â†’ Î¹' i â†’ Î± â†’ ENNReal\nâŠ¢ LE.le (iSup fun i => iSup fun j => MeasureTheory.lintegral Î¼ fun a => f i j a) (MeasureTheory.lintegral Î¼ fun a => iSup fun i => iSup fun j => f i j a)","decl":"theorem iSupâ‚‚_lintegral_le {Î¹ : Sort*} {Î¹' : Î¹ â†’ Sort*} (f : âˆ€ i, Î¹' i â†’ Î± â†’ â„â‰¥0âˆ) :\n    â¨† (i) (j), âˆ«â» a, f i j a âˆ‚Î¼ â‰¤ âˆ«â» a, â¨† (i) (j), f i j a âˆ‚Î¼ := by\n  convert (monotone_lintegral Î¼).le_map_iSupâ‚‚ f with a\n  simp only [iSup_apply]\n\n"}
{"name":"MeasureTheory.le_iInf_lintegral","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ¹ : Sort u_5\nf : Î¹ â†’ Î± â†’ ENNReal\nâŠ¢ LE.le (MeasureTheory.lintegral Î¼ fun a => iInf fun i => f i a) (iInf fun i => MeasureTheory.lintegral Î¼ fun a => f i a)","decl":"theorem le_iInf_lintegral {Î¹ : Sort*} (f : Î¹ â†’ Î± â†’ â„â‰¥0âˆ) :\n    âˆ«â» a, â¨… i, f i a âˆ‚Î¼ â‰¤ â¨… i, âˆ«â» a, f i a âˆ‚Î¼ := by\n  simp only [â† iInf_apply]\n  exact (monotone_lintegral Î¼).map_iInf_le\n\n"}
{"name":"MeasureTheory.le_iInfâ‚‚_lintegral","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ¹ : Sort u_5\nÎ¹' : Î¹ â†’ Sort u_6\nf : (i : Î¹) â†’ Î¹' i â†’ Î± â†’ ENNReal\nâŠ¢ LE.le (MeasureTheory.lintegral Î¼ fun a => iInf fun i => iInf fun h => f i h a) (iInf fun i => iInf fun h => MeasureTheory.lintegral Î¼ fun a => f i h a)","decl":"theorem le_iInfâ‚‚_lintegral {Î¹ : Sort*} {Î¹' : Î¹ â†’ Sort*} (f : âˆ€ i, Î¹' i â†’ Î± â†’ â„â‰¥0âˆ) :\n    âˆ«â» a, â¨… (i) (h : Î¹' i), f i h a âˆ‚Î¼ â‰¤ â¨… (i) (h : Î¹' i), âˆ«â» a, f i h a âˆ‚Î¼ := by\n  convert (monotone_lintegral Î¼).map_iInfâ‚‚_le f with a\n  simp only [iInf_apply]\n\n"}
{"name":"MeasureTheory.lintegral_mono_ae","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ ENNReal\nh : Filter.Eventually (fun a => LE.le (f a) (g a)) (MeasureTheory.ae Î¼)\nâŠ¢ LE.le (MeasureTheory.lintegral Î¼ fun a => f a) (MeasureTheory.lintegral Î¼ fun a => g a)","decl":"theorem lintegral_mono_ae {f g : Î± â†’ â„â‰¥0âˆ} (h : âˆ€áµ a âˆ‚Î¼, f a â‰¤ g a) :\n    âˆ«â» a, f a âˆ‚Î¼ â‰¤ âˆ«â» a, g a âˆ‚Î¼ := by\n  rcases exists_measurable_superset_of_null h with âŸ¨t, hts, ht, ht0âŸ©\n  have : âˆ€áµ x âˆ‚Î¼, x âˆ‰ t := measure_zero_iff_ae_nmem.1 ht0\n  rw [lintegral, lintegral]\n  refine iSupâ‚‚_le fun s hfs â†¦ le_iSupâ‚‚_of_le (s.restrict tá¶œ) ?_ ?_\n  Â· intro a\n    by_cases h : a âˆˆ t <;>\n      simp only [restrict_apply s ht.compl, mem_compl_iff, h, not_true, not_false_eq_true,\n        indicator_of_not_mem, zero_le, not_false_eq_true, indicator_of_mem]\n    exact le_trans (hfs a) (by_contradiction fun hnfg => h (hts hnfg))\n  Â· refine le_of_eq (SimpleFunc.lintegral_congr <| this.mono fun a hnt => ?_)\n    by_cases hat : a âˆˆ t <;> simp only [restrict_apply s ht.compl, mem_compl_iff, hat, not_true,\n      not_false_eq_true, indicator_of_not_mem, not_false_eq_true, indicator_of_mem]\n    exact (hnt hat).elim\n\n"}
{"name":"MeasureTheory.setLIntegral_mono_ae","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nf g : Î± â†’ ENNReal\nhg : AEMeasurable g (Î¼.restrict s)\nhfg : Filter.Eventually (fun x => Membership.mem s x â†’ LE.le (f x) (g x)) (MeasureTheory.ae Î¼)\nâŠ¢ LE.le (MeasureTheory.lintegral (Î¼.restrict s) fun x => f x) (MeasureTheory.lintegral (Î¼.restrict s) fun x => g x)","decl":"/-- Lebesgue integral over a set is monotone in function.\n\nThis version assumes that the upper estimate is an a.e. measurable function\nand the estimate holds a.e. on the set.\nSee also `setLIntegral_mono_ae'` for a version that assumes measurability of the set\nbut assumes no regularity of either function. -/\ntheorem setLIntegral_mono_ae {s : Set Î±} {f g : Î± â†’ â„â‰¥0âˆ} (hg : AEMeasurable g (Î¼.restrict s))\n    (hfg : âˆ€áµ x âˆ‚Î¼, x âˆˆ s â†’ f x â‰¤ g x) : âˆ«â» x in s, f x âˆ‚Î¼ â‰¤ âˆ«â» x in s, g x âˆ‚Î¼ := by\n  rcases exists_measurable_le_lintegral_eq (Î¼.restrict s) f with âŸ¨f', hf'm, hle, hf'âŸ©\n  rw [hf']\n  apply lintegral_mono_ae\n  rw [ae_restrict_iffâ‚€]\n  Â· exact hfg.mono fun x hx hxs â†¦ (hle x).trans (hx hxs)\n  Â· exact nullMeasurableSet_le hf'm.aemeasurable hg\n\n"}
{"name":"MeasureTheory.setLIntegral_mono","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nf g : Î± â†’ ENNReal\nhg : Measurable g\nhfg : âˆ€ (x : Î±), Membership.mem s x â†’ LE.le (f x) (g x)\nâŠ¢ LE.le (MeasureTheory.lintegral (Î¼.restrict s) fun x => f x) (MeasureTheory.lintegral (Î¼.restrict s) fun x => g x)","decl":"theorem setLIntegral_mono {s : Set Î±} {f g : Î± â†’ â„â‰¥0âˆ} (hg : Measurable g)\n    (hfg : âˆ€ x âˆˆ s, f x â‰¤ g x) : âˆ«â» x in s, f x âˆ‚Î¼ â‰¤ âˆ«â» x in s, g x âˆ‚Î¼ :=\n  setLIntegral_mono_ae hg.aemeasurable (ae_of_all _ hfg)\n\n"}
{"name":"MeasureTheory.setLIntegral_mono_ae'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nf g : Î± â†’ ENNReal\nhs : MeasurableSet s\nhfg : Filter.Eventually (fun x => Membership.mem s x â†’ LE.le (f x) (g x)) (MeasureTheory.ae Î¼)\nâŠ¢ LE.le (MeasureTheory.lintegral (Î¼.restrict s) fun x => f x) (MeasureTheory.lintegral (Î¼.restrict s) fun x => g x)","decl":"theorem setLIntegral_mono_ae' {s : Set Î±} {f g : Î± â†’ â„â‰¥0âˆ} (hs : MeasurableSet s)\n    (hfg : âˆ€áµ x âˆ‚Î¼, x âˆˆ s â†’ f x â‰¤ g x) : âˆ«â» x in s, f x âˆ‚Î¼ â‰¤ âˆ«â» x in s, g x âˆ‚Î¼ :=\n  lintegral_mono_ae <| (ae_restrict_iff' hs).2 hfg\n\n"}
{"name":"MeasureTheory.setLIntegral_mono'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nf g : Î± â†’ ENNReal\nhs : MeasurableSet s\nhfg : âˆ€ (x : Î±), Membership.mem s x â†’ LE.le (f x) (g x)\nâŠ¢ LE.le (MeasureTheory.lintegral (Î¼.restrict s) fun x => f x) (MeasureTheory.lintegral (Î¼.restrict s) fun x => g x)","decl":"theorem setLIntegral_mono' {s : Set Î±} {f g : Î± â†’ â„â‰¥0âˆ} (hs : MeasurableSet s)\n    (hfg : âˆ€ x âˆˆ s, f x â‰¤ g x) : âˆ«â» x in s, f x âˆ‚Î¼ â‰¤ âˆ«â» x in s, g x âˆ‚Î¼ :=\n  setLIntegral_mono_ae' hs (ae_of_all _ hfg)\n\n"}
{"name":"MeasureTheory.setLIntegral_le_lintegral","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nf : Î± â†’ ENNReal\nâŠ¢ LE.le (MeasureTheory.lintegral (Î¼.restrict s) fun x => f x) (MeasureTheory.lintegral Î¼ fun x => f x)","decl":"theorem setLIntegral_le_lintegral (s : Set Î±) (f : Î± â†’ â„â‰¥0âˆ) :\n    âˆ«â» x in s, f x âˆ‚Î¼ â‰¤ âˆ«â» x, f x âˆ‚Î¼ :=\n  lintegral_mono' Measure.restrict_le_self le_rfl\n\n"}
{"name":"MeasureTheory.lintegral_congr_ae","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ ENNReal\nh : (MeasureTheory.ae Î¼).EventuallyEq f g\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => f a) (MeasureTheory.lintegral Î¼ fun a => g a)","decl":"theorem lintegral_congr_ae {f g : Î± â†’ â„â‰¥0âˆ} (h : f =áµ[Î¼] g) : âˆ«â» a, f a âˆ‚Î¼ = âˆ«â» a, g a âˆ‚Î¼ :=\n  le_antisymm (lintegral_mono_ae <| h.le) (lintegral_mono_ae <| h.symm.le)\n\n"}
{"name":"MeasureTheory.lintegral_congr","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ ENNReal\nh : âˆ€ (a : Î±), Eq (f a) (g a)\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => f a) (MeasureTheory.lintegral Î¼ fun a => g a)","decl":"theorem lintegral_congr {f g : Î± â†’ â„â‰¥0âˆ} (h : âˆ€ a, f a = g a) : âˆ«â» a, f a âˆ‚Î¼ = âˆ«â» a, g a âˆ‚Î¼ := by\n  simp only [h]\n\n"}
{"name":"MeasureTheory.setLIntegral_congr","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\ns t : Set Î±\nh : (MeasureTheory.ae Î¼).EventuallyEq s t\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict s) fun x => f x) (MeasureTheory.lintegral (Î¼.restrict t) fun x => f x)","decl":"theorem setLIntegral_congr {f : Î± â†’ â„â‰¥0âˆ} {s t : Set Î±} (h : s =áµ[Î¼] t) :\n    âˆ«â» x in s, f x âˆ‚Î¼ = âˆ«â» x in t, f x âˆ‚Î¼ := by rw [Measure.restrict_congr_set h]\n\n"}
{"name":"MeasureTheory.setLIntegral_congr_fun","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ ENNReal\ns : Set Î±\nhs : MeasurableSet s\nhfg : Filter.Eventually (fun x => Membership.mem s x â†’ Eq (f x) (g x)) (MeasureTheory.ae Î¼)\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict s) fun x => f x) (MeasureTheory.lintegral (Î¼.restrict s) fun x => g x)","decl":"theorem setLIntegral_congr_fun {f g : Î± â†’ â„â‰¥0âˆ} {s : Set Î±} (hs : MeasurableSet s)\n    (hfg : âˆ€áµ x âˆ‚Î¼, x âˆˆ s â†’ f x = g x) : âˆ«â» x in s, f x âˆ‚Î¼ = âˆ«â» x in s, g x âˆ‚Î¼ := by\n  rw [lintegral_congr_ae]\n  rw [EventuallyEq]\n  rwa [ae_restrict_iff' hs]\n\n"}
{"name":"MeasureTheory.lintegral_ofReal_le_lintegral_enorm","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nâŠ¢ LE.le (MeasureTheory.lintegral Î¼ fun x => ENNReal.ofReal (f x)) (MeasureTheory.lintegral Î¼ fun x => ENorm.enorm (f x))","decl":"theorem lintegral_ofReal_le_lintegral_enorm (f : Î± â†’ â„) :\n    âˆ«â» x, ENNReal.ofReal (f x) âˆ‚Î¼ â‰¤ âˆ«â» x, â€–f xâ€–â‚‘ âˆ‚Î¼ := by\n  simp_rw [â† ofReal_norm_eq_enorm]\n  refine lintegral_mono fun x => ENNReal.ofReal_le_ofReal ?_\n  rw [Real.norm_eq_abs]\n  exact le_abs_self (f x)\n\n"}
{"name":"MeasureTheory.lintegral_ofReal_le_lintegral_nnnorm","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nâŠ¢ LE.le (MeasureTheory.lintegral Î¼ fun x => ENNReal.ofReal (f x)) (MeasureTheory.lintegral Î¼ fun x => ENorm.enorm (f x))","decl":"@[deprecated (since := \"2025-01-17\")]\nalias lintegral_ofReal_le_lintegral_nnnorm := lintegral_ofReal_le_lintegral_enorm\n\n"}
{"name":"MeasureTheory.lintegral_enorm_of_ae_nonneg","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nh_nonneg : (MeasureTheory.ae Î¼).EventuallyLE 0 f\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun x => ENorm.enorm (f x)) (MeasureTheory.lintegral Î¼ fun x => ENNReal.ofReal (f x))","decl":"theorem lintegral_enorm_of_ae_nonneg {f : Î± â†’ â„} (h_nonneg : 0 â‰¤áµ[Î¼] f) :\n    âˆ«â» x, â€–f xâ€–â‚‘ âˆ‚Î¼ = âˆ«â» x, .ofReal (f x) âˆ‚Î¼ := by\n  apply lintegral_congr_ae\n  filter_upwards [h_nonneg] with x hx\n  rw [Real.enorm_eq_ofReal hx]\n\n"}
{"name":"MeasureTheory.lintegral_nnnorm_eq_of_ae_nonneg","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nh_nonneg : (MeasureTheory.ae Î¼).EventuallyLE 0 f\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun x => ENorm.enorm (f x)) (MeasureTheory.lintegral Î¼ fun x => ENNReal.ofReal (f x))","decl":"@[deprecated (since := \"2025-01-17\")]\nalias lintegral_nnnorm_eq_of_ae_nonneg := lintegral_enorm_of_ae_nonneg\n\n"}
{"name":"MeasureTheory.lintegral_enorm_of_nonneg","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nh_nonneg : LE.le 0 f\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun x => ENorm.enorm (f x)) (MeasureTheory.lintegral Î¼ fun x => ENNReal.ofReal (f x))","decl":"theorem lintegral_enorm_of_nonneg {f : Î± â†’ â„} (h_nonneg : 0 â‰¤ f) :\n    âˆ«â» x, â€–f xâ€–â‚‘ âˆ‚Î¼ = âˆ«â» x, .ofReal (f x) âˆ‚Î¼ :=\n  lintegral_enorm_of_ae_nonneg <| .of_forall h_nonneg\n\n"}
{"name":"MeasureTheory.lintegral_nnnorm_eq_of_nonneg","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nh_nonneg : LE.le 0 f\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun x => ENorm.enorm (f x)) (MeasureTheory.lintegral Î¼ fun x => ENNReal.ofReal (f x))","decl":"@[deprecated (since := \"2025-01-17\")]\nalias lintegral_nnnorm_eq_of_nonneg := lintegral_enorm_of_nonneg\n\n"}
{"name":"MeasureTheory.lintegral_iSup","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Nat â†’ Î± â†’ ENNReal\nhf : âˆ€ (n : Nat), Measurable (f n)\nh_mono : Monotone f\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => iSup fun n => f n a) (iSup fun n => MeasureTheory.lintegral Î¼ fun a => f n a)","decl":"/-- **Monotone convergence theorem** -- sometimes called **Beppo-Levi convergence**.\nSee `lintegral_iSup_directed` for a more general form. -/\ntheorem lintegral_iSup {f : â„• â†’ Î± â†’ â„â‰¥0âˆ} (hf : âˆ€ n, Measurable (f n)) (h_mono : Monotone f) :\n    âˆ«â» a, â¨† n, f n a âˆ‚Î¼ = â¨† n, âˆ«â» a, f n a âˆ‚Î¼ := by\n  set c : â„â‰¥0 â†’ â„â‰¥0âˆ := (â†‘)\n  set F := fun a : Î± => â¨† n, f n a\n  refine le_antisymm ?_ (iSup_lintegral_le _)\n  rw [lintegral_eq_nnreal]\n  refine iSup_le fun s => iSup_le fun hsf => ?_\n  refine ENNReal.le_of_forall_lt_one_mul_le fun a ha => ?_\n  rcases ENNReal.lt_iff_exists_coe.1 ha with âŸ¨r, rfl, _âŸ©\n  have ha : r < 1 := ENNReal.coe_lt_coe.1 ha\n  let rs := s.map fun a => r * a\n  have eq_rs : rs.map c = (const Î± r : Î± â†’â‚› â„â‰¥0âˆ) * map c s := rfl\n  have eq : âˆ€ p, rs.map c â»Â¹' {p} = â‹ƒ n, rs.map c â»Â¹' {p} âˆ© { a | p â‰¤ f n a } := by\n    intro p\n    rw [â† inter_iUnion]; nth_rw 1 [â† inter_univ (map c rs â»Â¹' {p})]\n    refine Set.ext fun x => and_congr_right fun hx => (iff_of_eq (true_iff _)).2 ?_\n    by_cases p_eq : p = 0\n    Â· simp [p_eq]\n    simp only [coe_map, mem_preimage, Function.comp_apply, mem_singleton_iff] at hx\n    subst hx\n    have : r * s x â‰  0 := by rwa [Ne, â† ENNReal.coe_eq_zero]\n    have : s x â‰  0 := right_ne_zero_of_mul this\n    have : (rs.map c) x < â¨† n : â„•, f n x := by\n      refine lt_of_lt_of_le (ENNReal.coe_lt_coe.2 ?_) (hsf x)\n      suffices r * s x < 1 * s x by simpa\n      exact mul_lt_mul_of_pos_right ha (pos_iff_ne_zero.2 this)\n    rcases lt_iSup_iff.1 this with âŸ¨i, hiâŸ©\n    exact mem_iUnion.2 âŸ¨i, le_of_lt hiâŸ©\n  have mono : âˆ€ r : â„â‰¥0âˆ, Monotone fun n => rs.map c â»Â¹' {r} âˆ© { a | r â‰¤ f n a } := by\n    intro r i j h\n    refine inter_subset_inter_right _ ?_\n    simp_rw [subset_def, mem_setOf]\n    intro x hx\n    exact le_trans hx (h_mono h x)\n  have h_meas : âˆ€ n, MeasurableSet {a : Î± | map c rs a â‰¤ f n a} := fun n =>\n    measurableSet_le (SimpleFunc.measurable _) (hf n)\n  calc\n    (r : â„â‰¥0âˆ) * (s.map c).lintegral Î¼ = âˆ‘ r âˆˆ (rs.map c).range, r * Î¼ (rs.map c â»Â¹' {r}) := by\n      rw [â† const_mul_lintegral, eq_rs, SimpleFunc.lintegral]\n    _ = âˆ‘ r âˆˆ (rs.map c).range, r * Î¼ (â‹ƒ n, rs.map c â»Â¹' {r} âˆ© { a | r â‰¤ f n a }) := by\n      simp only [(eq _).symm]\n    _ = âˆ‘ r âˆˆ (rs.map c).range, â¨† n, r * Î¼ (rs.map c â»Â¹' {r} âˆ© { a | r â‰¤ f n a }) :=\n      Finset.sum_congr rfl fun x _ => by rw [(mono x).measure_iUnion, ENNReal.mul_iSup]\n    _ = â¨† n, âˆ‘ r âˆˆ (rs.map c).range, r * Î¼ (rs.map c â»Â¹' {r} âˆ© { a | r â‰¤ f n a }) := by\n      refine ENNReal.finsetSum_iSup_of_monotone fun p i j h â†¦ ?_\n      gcongr _ * Î¼ ?_\n      exact mono p h\n    _ â‰¤ â¨† n : â„•, ((rs.map c).restrict { a | (rs.map c) a â‰¤ f n a }).lintegral Î¼ := by\n      gcongr with n\n      rw [restrict_lintegral _ (h_meas n)]\n      refine le_of_eq (Finset.sum_congr rfl fun r _ => ?_)\n      congr 2 with a\n      refine and_congr_right ?_\n      simp +contextual\n    _ â‰¤ â¨† n, âˆ«â» a, f n a âˆ‚Î¼ := by\n      simp only [â† SimpleFunc.lintegral_eq_lintegral]\n      gcongr with n a\n      simp only [map_apply] at h_meas\n      simp only [coe_map, restrict_apply _ (h_meas _), (Â· âˆ˜ Â·)]\n      exact indicator_apply_le id\n\n"}
{"name":"MeasureTheory.lintegral_iSup'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Nat â†’ Î± â†’ ENNReal\nhf : âˆ€ (n : Nat), AEMeasurable (f n) Î¼\nh_mono : Filter.Eventually (fun x => Monotone fun n => f n x) (MeasureTheory.ae Î¼)\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => iSup fun n => f n a) (iSup fun n => MeasureTheory.lintegral Î¼ fun a => f n a)","decl":"/-- Monotone convergence theorem -- sometimes called Beppo-Levi convergence. Version with\nae_measurable functions. -/\ntheorem lintegral_iSup' {f : â„• â†’ Î± â†’ â„â‰¥0âˆ} (hf : âˆ€ n, AEMeasurable (f n) Î¼)\n    (h_mono : âˆ€áµ x âˆ‚Î¼, Monotone fun n => f n x) : âˆ«â» a, â¨† n, f n a âˆ‚Î¼ = â¨† n, âˆ«â» a, f n a âˆ‚Î¼ := by\n  simp_rw [â† iSup_apply]\n  let p : Î± â†’ (â„• â†’ â„â‰¥0âˆ) â†’ Prop := fun _ f' => Monotone f'\n  have hp : âˆ€áµ x âˆ‚Î¼, p x fun i => f i x := h_mono\n  have h_ae_seq_mono : Monotone (aeSeq hf p) := by\n    intro n m hnm x\n    by_cases hx : x âˆˆ aeSeqSet hf p\n    Â· exact aeSeq.prop_of_mem_aeSeqSet hf hx hnm\n    Â· simp only [aeSeq, hx, if_false, le_rfl]\n  rw [lintegral_congr_ae (aeSeq.iSup hf hp).symm]\n  simp_rw [iSup_apply]\n  rw [lintegral_iSup (aeSeq.measurable hf p) h_ae_seq_mono]\n  congr with n\n  exact lintegral_congr_ae (aeSeq.aeSeq_n_eq_fun_n_ae hf hp n)\n\n"}
{"name":"MeasureTheory.lintegral_tendsto_of_tendsto_of_monotone","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Nat â†’ Î± â†’ ENNReal\nF : Î± â†’ ENNReal\nhf : âˆ€ (n : Nat), AEMeasurable (f n) Î¼\nh_mono : Filter.Eventually (fun x => Monotone fun n => f n x) (MeasureTheory.ae Î¼)\nh_tendsto : Filter.Eventually (fun x => Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Tendsto (fun n => MeasureTheory.lintegral Î¼ fun x => f n x) Filter.atTop (nhds (MeasureTheory.lintegral Î¼ fun x => F x))","decl":"/-- Monotone convergence theorem expressed with limits -/\ntheorem lintegral_tendsto_of_tendsto_of_monotone {f : â„• â†’ Î± â†’ â„â‰¥0âˆ} {F : Î± â†’ â„â‰¥0âˆ}\n    (hf : âˆ€ n, AEMeasurable (f n) Î¼) (h_mono : âˆ€áµ x âˆ‚Î¼, Monotone fun n => f n x)\n    (h_tendsto : âˆ€áµ x âˆ‚Î¼, Tendsto (fun n => f n x) atTop (ğ“ <| F x)) :\n    Tendsto (fun n => âˆ«â» x, f n x âˆ‚Î¼) atTop (ğ“ <| âˆ«â» x, F x âˆ‚Î¼) := by\n  have : Monotone fun n => âˆ«â» x, f n x âˆ‚Î¼ := fun i j hij =>\n    lintegral_mono_ae (h_mono.mono fun x hx => hx hij)\n  suffices key : âˆ«â» x, F x âˆ‚Î¼ = â¨† n, âˆ«â» x, f n x âˆ‚Î¼ by\n    rw [key]\n    exact tendsto_atTop_iSup this\n  rw [â† lintegral_iSup' hf h_mono]\n  refine lintegral_congr_ae ?_\n  filter_upwards [h_mono, h_tendsto] with _ hx_mono hx_tendsto using\n    tendsto_nhds_unique hx_tendsto (tendsto_atTop_iSup hx_mono)\n\n"}
{"name":"MeasureTheory.lintegral_eq_iSup_eapprox_lintegral","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nhf : Measurable f\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => f a) (iSup fun n => (MeasureTheory.SimpleFunc.eapprox f n).lintegral Î¼)","decl":"theorem lintegral_eq_iSup_eapprox_lintegral {f : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) :\n    âˆ«â» a, f a âˆ‚Î¼ = â¨† n, (eapprox f n).lintegral Î¼ :=\n  calc\n    âˆ«â» a, f a âˆ‚Î¼ = âˆ«â» a, â¨† n, (eapprox f n : Î± â†’ â„â‰¥0âˆ) a âˆ‚Î¼ := by\n      congr; ext a; rw [iSup_eapprox_apply hf]\n    _ = â¨† n, âˆ«â» a, (eapprox f n : Î± â†’ â„â‰¥0âˆ) a âˆ‚Î¼ := by\n      apply lintegral_iSup\n      Â· measurability\n      Â· intro i j h\n        exact monotone_eapprox f h\n    _ = â¨† n, (eapprox f n).lintegral Î¼ := by\n      congr; ext n; rw [(eapprox f n).lintegral_eq_lintegral]\n\n"}
{"name":"MeasureTheory.lintegral_eapprox_le_lintegral","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nhf : Measurable f\nn : Nat\nâŠ¢ LE.le ((MeasureTheory.SimpleFunc.eapprox f n).lintegral Î¼) (MeasureTheory.lintegral Î¼ fun x => f x)","decl":"lemma lintegral_eapprox_le_lintegral {f : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) (n : â„•) :\n    (eapprox f n).lintegral Î¼ â‰¤ âˆ«â» x, f x âˆ‚Î¼ := by\n  rw [lintegral_eq_iSup_eapprox_lintegral hf]\n  exact le_iSup (fun n â†¦ (eapprox f n).lintegral Î¼) n\n\n"}
{"name":"MeasureTheory.measure_support_eapprox_lt_top","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nhf_meas : Measurable f\nhf : Ne (MeasureTheory.lintegral Î¼ fun x => f x) Top.top\nn : Nat\nâŠ¢ LT.lt (Î¼ (Function.support â‡‘(MeasureTheory.SimpleFunc.eapprox f n))) Top.top","decl":"lemma measure_support_eapprox_lt_top {f : Î± â†’ â„â‰¥0âˆ} (hf_meas : Measurable f)\n    (hf : âˆ«â» x, f x âˆ‚Î¼ â‰  âˆ) (n : â„•) :\n    Î¼ (support (eapprox f n)) < âˆ :=\n  measure_support_lt_top_of_lintegral_ne_top <|\n    ((lintegral_eapprox_le_lintegral hf_meas n).trans_lt hf.lt_top).ne\n\n"}
{"name":"MeasureTheory.exists_pos_setLIntegral_lt_of_measure_lt","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nh : Ne (MeasureTheory.lintegral Î¼ fun x => f x) Top.top\nÎµ : ENNReal\nhÎµ : Ne Îµ 0\nâŠ¢ Exists fun Î´ => And (GT.gt Î´ 0) (âˆ€ (s : Set Î±), LT.lt (Î¼ s) Î´ â†’ LT.lt (MeasureTheory.lintegral (Î¼.restrict s) fun x => f x) Îµ)","decl":"/-- If `f` has finite integral, then `âˆ«â» x in s, f x âˆ‚Î¼` is absolutely continuous in `s`: it tends\nto zero as `Î¼ s` tends to zero. This lemma states this fact in terms of `Îµ` and `Î´`. -/\ntheorem exists_pos_setLIntegral_lt_of_measure_lt {f : Î± â†’ â„â‰¥0âˆ} (h : âˆ«â» x, f x âˆ‚Î¼ â‰  âˆ) {Îµ : â„â‰¥0âˆ}\n    (hÎµ : Îµ â‰  0) : âˆƒ Î´ > 0, âˆ€ s, Î¼ s < Î´ â†’ âˆ«â» x in s, f x âˆ‚Î¼ < Îµ := by\n  rcases exists_between (pos_iff_ne_zero.mpr hÎµ) with âŸ¨Îµâ‚‚, hÎµâ‚‚0, hÎµâ‚‚ÎµâŸ©\n  rcases exists_between hÎµâ‚‚0 with âŸ¨Îµâ‚, hÎµâ‚0, hÎµâ‚â‚‚âŸ©\n  rcases exists_simpleFunc_forall_lintegral_sub_lt_of_pos h hÎµâ‚0.ne' with âŸ¨Ï†, _, hÏ†âŸ©\n  rcases Ï†.exists_forall_le with âŸ¨C, hCâŸ©\n  use (Îµâ‚‚ - Îµâ‚) / C, ENNReal.div_pos_iff.2 âŸ¨(tsub_pos_iff_lt.2 hÎµâ‚â‚‚).ne', ENNReal.coe_ne_topâŸ©\n  refine fun s hs => lt_of_le_of_lt ?_ hÎµâ‚‚Îµ\n  simp only [lintegral_eq_nnreal, iSup_le_iff]\n  intro Ïˆ hÏˆ\n  calc\n    (map (â†‘) Ïˆ).lintegral (Î¼.restrict s) â‰¤\n        (map (â†‘) Ï†).lintegral (Î¼.restrict s) + (map (â†‘) (Ïˆ - Ï†)).lintegral (Î¼.restrict s) := by\n      rw [â† SimpleFunc.add_lintegral, â† SimpleFunc.map_add @ENNReal.coe_add]\n      refine SimpleFunc.lintegral_mono (fun x => ?_) le_rfl\n      simp only [add_tsub_eq_max, le_max_right, coe_map, Function.comp_apply, SimpleFunc.coe_add,\n        SimpleFunc.coe_sub, Pi.add_apply, Pi.sub_apply, ENNReal.coe_max (Ï† x) (Ïˆ x)]\n    _ â‰¤ (map (â†‘) Ï†).lintegral (Î¼.restrict s) + Îµâ‚ := by\n      gcongr\n      refine le_trans ?_ (hÏ† _ hÏˆ).le\n      exact SimpleFunc.lintegral_mono le_rfl Measure.restrict_le_self\n    _ â‰¤ (SimpleFunc.const Î± (C : â„â‰¥0âˆ)).lintegral (Î¼.restrict s) + Îµâ‚ := by\n      gcongr\n      exact fun x â†¦ ENNReal.coe_le_coe.2 (hC x)\n    _ = C * Î¼ s + Îµâ‚ := by\n      simp only [â† SimpleFunc.lintegral_eq_lintegral, coe_const, lintegral_const,\n        Measure.restrict_apply, MeasurableSet.univ, univ_inter, Function.const]\n    _ â‰¤ C * ((Îµâ‚‚ - Îµâ‚) / C) + Îµâ‚ := by gcongr\n    _ â‰¤ Îµâ‚‚ - Îµâ‚ + Îµâ‚ := by gcongr; apply mul_div_le\n    _ = Îµâ‚‚ := tsub_add_cancel_of_le hÎµâ‚â‚‚.le\n\n"}
{"name":"MeasureTheory.tendsto_setLIntegral_zero","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ¹ : Type u_5\nf : Î± â†’ ENNReal\nh : Ne (MeasureTheory.lintegral Î¼ fun x => f x) Top.top\nl : Filter Î¹\ns : Î¹ â†’ Set Î±\nhl : Filter.Tendsto (Function.comp (â‡‘Î¼) s) l (nhds 0)\nâŠ¢ Filter.Tendsto (fun i => MeasureTheory.lintegral (Î¼.restrict (s i)) fun x => f x) l (nhds 0)","decl":"/-- If `f` has finite integral, then `âˆ«â» x in s, f x âˆ‚Î¼` is absolutely continuous in `s`: it tends\nto zero as `Î¼ s` tends to zero. -/\ntheorem tendsto_setLIntegral_zero {Î¹} {f : Î± â†’ â„â‰¥0âˆ} (h : âˆ«â» x, f x âˆ‚Î¼ â‰  âˆ) {l : Filter Î¹}\n    {s : Î¹ â†’ Set Î±} (hl : Tendsto (Î¼ âˆ˜ s) l (ğ“ 0)) :\n    Tendsto (fun i => âˆ«â» x in s i, f x âˆ‚Î¼) l (ğ“ 0) := by\n  simp only [ENNReal.nhds_zero, tendsto_iInf, tendsto_principal, mem_Iio,\n    â† pos_iff_ne_zero] at hl âŠ¢\n  intro Îµ Îµ0\n  rcases exists_pos_setLIntegral_lt_of_measure_lt h Îµ0.ne' with âŸ¨Î´, Î´0, hÎ´âŸ©\n  exact (hl Î´ Î´0).mono fun i => hÎ´ _\n\n"}
{"name":"MeasureTheory.le_lintegral_add","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ ENNReal\nâŠ¢ LE.le (HAdd.hAdd (MeasureTheory.lintegral Î¼ fun a => f a) (MeasureTheory.lintegral Î¼ fun a => g a)) (MeasureTheory.lintegral Î¼ fun a => HAdd.hAdd (f a) (g a))","decl":"/-- The sum of the lower Lebesgue integrals of two functions is less than or equal to the integral\nof their sum. The other inequality needs one of these functions to be (a.e.-)measurable. -/\ntheorem le_lintegral_add (f g : Î± â†’ â„â‰¥0âˆ) :\n    âˆ«â» a, f a âˆ‚Î¼ + âˆ«â» a, g a âˆ‚Î¼ â‰¤ âˆ«â» a, f a + g a âˆ‚Î¼ := by\n  simp only [lintegral]\n  refine ENNReal.biSup_add_biSup_le' (p := fun h : Î± â†’â‚› â„â‰¥0âˆ => h â‰¤ f)\n    (q := fun h : Î± â†’â‚› â„â‰¥0âˆ => h â‰¤ g) âŸ¨0, zero_le fâŸ© âŸ¨0, zero_le gâŸ© fun f' hf' g' hg' => ?_\n  exact le_iSupâ‚‚_of_le (f' + g') (add_le_add hf' hg') (add_lintegral _ _).ge\n\n-- Use stronger lemmas `lintegral_add_left`/`lintegral_add_right` instead\n"}
{"name":"MeasureTheory.lintegral_add_aux","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ ENNReal\nhf : Measurable f\nhg : Measurable g\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => HAdd.hAdd (f a) (g a)) (HAdd.hAdd (MeasureTheory.lintegral Î¼ fun a => f a) (MeasureTheory.lintegral Î¼ fun a => g a))","decl":"theorem lintegral_add_aux {f g : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) (hg : Measurable g) :\n    âˆ«â» a, f a + g a âˆ‚Î¼ = âˆ«â» a, f a âˆ‚Î¼ + âˆ«â» a, g a âˆ‚Î¼ :=\n  calc\n    âˆ«â» a, f a + g a âˆ‚Î¼ =\n        âˆ«â» a, (â¨† n, (eapprox f n : Î± â†’ â„â‰¥0âˆ) a) + â¨† n, (eapprox g n : Î± â†’ â„â‰¥0âˆ) a âˆ‚Î¼ := by\n      simp only [iSup_eapprox_apply, hf, hg]\n    _ = âˆ«â» a, â¨† n, (eapprox f n + eapprox g n : Î± â†’ â„â‰¥0âˆ) a âˆ‚Î¼ := by\n      congr; funext a\n      rw [ENNReal.iSup_add_iSup_of_monotone]\n      Â· simp only [Pi.add_apply]\n      Â· intro i j h\n        exact monotone_eapprox _ h a\n      Â· intro i j h\n        exact monotone_eapprox _ h a\n    _ = â¨† n, (eapprox f n).lintegral Î¼ + (eapprox g n).lintegral Î¼ := by\n      rw [lintegral_iSup]\n      Â· congr\n        funext n\n        rw [â† SimpleFunc.add_lintegral, â† SimpleFunc.lintegral_eq_lintegral]\n        simp only [Pi.add_apply, SimpleFunc.coe_add]\n      Â· fun_prop\n      Â· intro i j h a\n        dsimp\n        gcongr <;> exact monotone_eapprox _ h _\n    _ = (â¨† n, (eapprox f n).lintegral Î¼) + â¨† n, (eapprox g n).lintegral Î¼ := by\n      refine (ENNReal.iSup_add_iSup_of_monotone ?_ ?_).symm <;>\n        Â· intro i j h\n          exact SimpleFunc.lintegral_mono (monotone_eapprox _ h) le_rfl\n    _ = âˆ«â» a, f a âˆ‚Î¼ + âˆ«â» a, g a âˆ‚Î¼ := by\n      rw [lintegral_eq_iSup_eapprox_lintegral hf, lintegral_eq_iSup_eapprox_lintegral hg]\n\n"}
{"name":"MeasureTheory.lintegral_add_left","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nhf : Measurable f\ng : Î± â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => HAdd.hAdd (f a) (g a)) (HAdd.hAdd (MeasureTheory.lintegral Î¼ fun a => f a) (MeasureTheory.lintegral Î¼ fun a => g a))","decl":"/-- If `f g : Î± â†’ â„â‰¥0âˆ` are two functions and one of them is (a.e.) measurable, then the Lebesgue\nintegral of `f + g` equals the sum of integrals. This lemma assumes that `f` is integrable, see also\n`MeasureTheory.lintegral_add_right` and primed versions of these lemmas. -/\n@[simp]\ntheorem lintegral_add_left {f : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) (g : Î± â†’ â„â‰¥0âˆ) :\n    âˆ«â» a, f a + g a âˆ‚Î¼ = âˆ«â» a, f a âˆ‚Î¼ + âˆ«â» a, g a âˆ‚Î¼ := by\n  refine le_antisymm ?_ (le_lintegral_add _ _)\n  rcases exists_measurable_le_lintegral_eq Î¼ fun a => f a + g a with âŸ¨Ï†, hÏ†m, hÏ†_le, hÏ†_eqâŸ©\n  calc\n    âˆ«â» a, f a + g a âˆ‚Î¼ = âˆ«â» a, Ï† a âˆ‚Î¼ := hÏ†_eq\n    _ â‰¤ âˆ«â» a, f a + (Ï† a - f a) âˆ‚Î¼ := lintegral_mono fun a => le_add_tsub\n    _ = âˆ«â» a, f a âˆ‚Î¼ + âˆ«â» a, Ï† a - f a âˆ‚Î¼ := lintegral_add_aux hf (hÏ†m.sub hf)\n    _ â‰¤ âˆ«â» a, f a âˆ‚Î¼ + âˆ«â» a, g a âˆ‚Î¼ :=\n      add_le_add_left (lintegral_mono fun a => tsub_le_iff_left.2 <| hÏ†_le a) _\n\n"}
{"name":"MeasureTheory.lintegral_add_left'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nhf : AEMeasurable f Î¼\ng : Î± â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => HAdd.hAdd (f a) (g a)) (HAdd.hAdd (MeasureTheory.lintegral Î¼ fun a => f a) (MeasureTheory.lintegral Î¼ fun a => g a))","decl":"theorem lintegral_add_left' {f : Î± â†’ â„â‰¥0âˆ} (hf : AEMeasurable f Î¼) (g : Î± â†’ â„â‰¥0âˆ) :\n    âˆ«â» a, f a + g a âˆ‚Î¼ = âˆ«â» a, f a âˆ‚Î¼ + âˆ«â» a, g a âˆ‚Î¼ := by\n  rw [lintegral_congr_ae hf.ae_eq_mk, â† lintegral_add_left hf.measurable_mk,\n    lintegral_congr_ae (hf.ae_eq_mk.add (ae_eq_refl g))]\n\n"}
{"name":"MeasureTheory.lintegral_add_right'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ ENNReal\nhg : AEMeasurable g Î¼\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => HAdd.hAdd (f a) (g a)) (HAdd.hAdd (MeasureTheory.lintegral Î¼ fun a => f a) (MeasureTheory.lintegral Î¼ fun a => g a))","decl":"theorem lintegral_add_right' (f : Î± â†’ â„â‰¥0âˆ) {g : Î± â†’ â„â‰¥0âˆ} (hg : AEMeasurable g Î¼) :\n    âˆ«â» a, f a + g a âˆ‚Î¼ = âˆ«â» a, f a âˆ‚Î¼ + âˆ«â» a, g a âˆ‚Î¼ := by\n  simpa only [add_comm] using lintegral_add_left' hg f\n\n"}
{"name":"MeasureTheory.lintegral_add_right","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ ENNReal\nhg : Measurable g\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => HAdd.hAdd (f a) (g a)) (HAdd.hAdd (MeasureTheory.lintegral Î¼ fun a => f a) (MeasureTheory.lintegral Î¼ fun a => g a))","decl":"/-- If `f g : Î± â†’ â„â‰¥0âˆ` are two functions and one of them is (a.e.) measurable, then the Lebesgue\nintegral of `f + g` equals the sum of integrals. This lemma assumes that `g` is integrable, see also\n`MeasureTheory.lintegral_add_left` and primed versions of these lemmas. -/\n@[simp]\ntheorem lintegral_add_right (f : Î± â†’ â„â‰¥0âˆ) {g : Î± â†’ â„â‰¥0âˆ} (hg : Measurable g) :\n    âˆ«â» a, f a + g a âˆ‚Î¼ = âˆ«â» a, f a âˆ‚Î¼ + âˆ«â» a, g a âˆ‚Î¼ :=\n  lintegral_add_right' f hg.aemeasurable\n\n"}
{"name":"MeasureTheory.lintegral_smul_measure","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nc : ENNReal\nf : Î± â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral (HSMul.hSMul c Î¼) fun a => f a) (HMul.hMul c (MeasureTheory.lintegral Î¼ fun a => f a))","decl":"@[simp]\ntheorem lintegral_smul_measure (c : â„â‰¥0âˆ) (f : Î± â†’ â„â‰¥0âˆ) : âˆ«â» a, f a âˆ‚c â€¢ Î¼ = c * âˆ«â» a, f a âˆ‚Î¼ := by\n  simp only [lintegral, iSup_subtype', SimpleFunc.lintegral_smul, ENNReal.mul_iSup, smul_eq_mul]\n\n"}
{"name":"MeasureTheory.setLIntegral_smul_measure","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nc : ENNReal\nf : Î± â†’ ENNReal\ns : Set Î±\nâŠ¢ Eq (MeasureTheory.lintegral ((HSMul.hSMul c Î¼).restrict s) fun a => f a) (HMul.hMul c (MeasureTheory.lintegral (Î¼.restrict s) fun a => f a))","decl":"lemma setLIntegral_smul_measure (c : â„â‰¥0âˆ) (f : Î± â†’ â„â‰¥0âˆ) (s : Set Î±) :\n    âˆ«â» a in s, f a âˆ‚(c â€¢ Î¼) = c * âˆ«â» a in s, f a âˆ‚Î¼ := by\n  rw [Measure.restrict_smul, lintegral_smul_measure]\n\n"}
{"name":"MeasureTheory.lintegral_zero_measure","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nf : Î± â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral 0 fun a => f a) 0","decl":"@[simp]\ntheorem lintegral_zero_measure {m : MeasurableSpace Î±} (f : Î± â†’ â„â‰¥0âˆ) :\n    âˆ«â» a, f a âˆ‚(0 : Measure Î±) = 0 := by\n  simp [lintegral]\n\n"}
{"name":"MeasureTheory.lintegral_add_measure","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nf : Î± â†’ ENNReal\nÎ¼ Î½ : MeasureTheory.Measure Î±\nâŠ¢ Eq (MeasureTheory.lintegral (HAdd.hAdd Î¼ Î½) fun a => f a) (HAdd.hAdd (MeasureTheory.lintegral Î¼ fun a => f a) (MeasureTheory.lintegral Î½ fun a => f a))","decl":"@[simp]\ntheorem lintegral_add_measure (f : Î± â†’ â„â‰¥0âˆ) (Î¼ Î½ : Measure Î±) :\n    âˆ«â» a, f a âˆ‚(Î¼ + Î½) = âˆ«â» a, f a âˆ‚Î¼ + âˆ«â» a, f a âˆ‚Î½ := by\n  simp only [lintegral, SimpleFunc.lintegral_add, iSup_subtype']\n  refine (ENNReal.iSup_add_iSup ?_).symm\n  rintro âŸ¨Ï†, hÏ†âŸ© âŸ¨Ïˆ, hÏˆâŸ©\n  refine âŸ¨âŸ¨Ï† âŠ” Ïˆ, sup_le hÏ† hÏˆâŸ©, ?_âŸ©\n  apply_rules [add_le_add, SimpleFunc.lintegral_mono, le_rfl] -- TODO: use `gcongr`\n  exacts [le_sup_left, le_sup_right]\n\n"}
{"name":"MeasureTheory.lintegral_finset_sum_measure","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¹ : Type u_5\ns : Finset Î¹\nf : Î± â†’ ENNReal\nÎ¼ : Î¹ â†’ MeasureTheory.Measure Î±\nâŠ¢ Eq (MeasureTheory.lintegral (s.sum fun i => Î¼ i) fun a => f a) (s.sum fun i => MeasureTheory.lintegral (Î¼ i) fun a => f a)","decl":"@[simp]\ntheorem lintegral_finset_sum_measure {Î¹} (s : Finset Î¹) (f : Î± â†’ â„â‰¥0âˆ) (Î¼ : Î¹ â†’ Measure Î±) :\n    âˆ«â» a, f a âˆ‚(âˆ‘ i âˆˆ s, Î¼ i) = âˆ‘ i âˆˆ s, âˆ«â» a, f a âˆ‚Î¼ i :=\n  let F : Measure Î± â†’+ â„â‰¥0âˆ :=\n    { toFun := (lintegral Â· f),\n      map_zero' := lintegral_zero_measure f,\n      map_add' := lintegral_add_measure f }\n  map_sum F Î¼ s\n\n"}
{"name":"MeasureTheory.lintegral_sum_measure","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¹ : Type u_5\nf : Î± â†’ ENNReal\nÎ¼ : Î¹ â†’ MeasureTheory.Measure Î±\nâŠ¢ Eq (MeasureTheory.lintegral (MeasureTheory.Measure.sum Î¼) fun a => f a) (tsum fun i => MeasureTheory.lintegral (Î¼ i) fun a => f a)","decl":"@[simp]\ntheorem lintegral_sum_measure {m : MeasurableSpace Î±} {Î¹} (f : Î± â†’ â„â‰¥0âˆ) (Î¼ : Î¹ â†’ Measure Î±) :\n    âˆ«â» a, f a âˆ‚Measure.sum Î¼ = âˆ‘' i, âˆ«â» a, f a âˆ‚Î¼ i := by\n  simp_rw [ENNReal.tsum_eq_iSup_sum, â† lintegral_finset_sum_measure,\n    lintegral, SimpleFunc.lintegral_sum, ENNReal.tsum_eq_iSup_sum,\n    SimpleFunc.lintegral_finset_sum, iSup_comm (Î¹ := Finset Î¹)]\n\n"}
{"name":"MeasureTheory.hasSum_lintegral_measure","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_5\nxâœ : MeasurableSpace Î±\nf : Î± â†’ ENNReal\nÎ¼ : Î¹ â†’ MeasureTheory.Measure Î±\nâŠ¢ HasSum (fun i => MeasureTheory.lintegral (Î¼ i) fun a => f a) (MeasureTheory.lintegral (MeasureTheory.Measure.sum Î¼) fun a => f a)","decl":"theorem hasSum_lintegral_measure {Î¹} {_ : MeasurableSpace Î±} (f : Î± â†’ â„â‰¥0âˆ) (Î¼ : Î¹ â†’ Measure Î±) :\n    HasSum (fun i => âˆ«â» a, f a âˆ‚Î¼ i) (âˆ«â» a, f a âˆ‚Measure.sum Î¼) :=\n  (lintegral_sum_measure f Î¼).symm â–¸ ENNReal.summable.hasSum\n\n"}
{"name":"MeasureTheory.lintegral_of_isEmpty","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_5\ninstâœÂ¹ : MeasurableSpace Î±\ninstâœ : IsEmpty Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun x => f x) 0","decl":"@[simp]\ntheorem lintegral_of_isEmpty {Î±} [MeasurableSpace Î±] [IsEmpty Î±] (Î¼ : Measure Î±) (f : Î± â†’ â„â‰¥0âˆ) :\n    âˆ«â» x, f x âˆ‚Î¼ = 0 := by\n  have : Subsingleton (Measure Î±) := inferInstance\n  convert lintegral_zero_measure f\n\n"}
{"name":"MeasureTheory.setLIntegral_empty","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict EmptyCollection.emptyCollection) fun x => f x) 0","decl":"theorem setLIntegral_empty (f : Î± â†’ â„â‰¥0âˆ) : âˆ«â» x in âˆ…, f x âˆ‚Î¼ = 0 := by\n  rw [Measure.restrict_empty, lintegral_zero_measure]\n\n"}
{"name":"MeasureTheory.setLIntegral_univ","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict Set.univ) fun x => f x) (MeasureTheory.lintegral Î¼ fun x => f x)","decl":"theorem setLIntegral_univ (f : Î± â†’ â„â‰¥0âˆ) : âˆ«â» x in univ, f x âˆ‚Î¼ = âˆ«â» x, f x âˆ‚Î¼ := by\n  rw [Measure.restrict_univ]\n\n"}
{"name":"MeasureTheory.setLIntegral_measure_zero","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nf : Î± â†’ ENNReal\nhs' : Eq (Î¼ s) 0\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict s) fun x => f x) 0","decl":"theorem setLIntegral_measure_zero (s : Set Î±) (f : Î± â†’ â„â‰¥0âˆ) (hs' : Î¼ s = 0) :\n    âˆ«â» x in s, f x âˆ‚Î¼ = 0 := by\n  convert lintegral_zero_measure _\n  exact Measure.restrict_eq_zero.2 hs'\n\n"}
{"name":"MeasureTheory.lintegral_finset_sum'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Finset Î²\nf : Î² â†’ Î± â†’ ENNReal\nhf : âˆ€ (b : Î²), Membership.mem s b â†’ AEMeasurable (f b) Î¼\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => s.sum fun b => f b a) (s.sum fun b => MeasureTheory.lintegral Î¼ fun a => f b a)","decl":"theorem lintegral_finset_sum' (s : Finset Î²) {f : Î² â†’ Î± â†’ â„â‰¥0âˆ}\n    (hf : âˆ€ b âˆˆ s, AEMeasurable (f b) Î¼) :\n    âˆ«â» a, âˆ‘ b âˆˆ s, f b a âˆ‚Î¼ = âˆ‘ b âˆˆ s, âˆ«â» a, f b a âˆ‚Î¼ := by\n  classical\n  induction' s using Finset.induction_on with a s has ih\n  Â· simp\n  Â· simp only [Finset.sum_insert has]\n    rw [Finset.forall_mem_insert] at hf\n    rw [lintegral_add_left' hf.1, ih hf.2]\n\n"}
{"name":"MeasureTheory.lintegral_finset_sum","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Finset Î²\nf : Î² â†’ Î± â†’ ENNReal\nhf : âˆ€ (b : Î²), Membership.mem s b â†’ Measurable (f b)\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => s.sum fun b => f b a) (s.sum fun b => MeasureTheory.lintegral Î¼ fun a => f b a)","decl":"theorem lintegral_finset_sum (s : Finset Î²) {f : Î² â†’ Î± â†’ â„â‰¥0âˆ} (hf : âˆ€ b âˆˆ s, Measurable (f b)) :\n    âˆ«â» a, âˆ‘ b âˆˆ s, f b a âˆ‚Î¼ = âˆ‘ b âˆˆ s, âˆ«â» a, f b a âˆ‚Î¼ :=\n  lintegral_finset_sum' s fun b hb => (hf b hb).aemeasurable\n\n"}
{"name":"MeasureTheory.lintegral_const_mul","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nr : ENNReal\nf : Î± â†’ ENNReal\nhf : Measurable f\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => HMul.hMul r (f a)) (HMul.hMul r (MeasureTheory.lintegral Î¼ fun a => f a))","decl":"@[simp]\ntheorem lintegral_const_mul (r : â„â‰¥0âˆ) {f : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) :\n    âˆ«â» a, r * f a âˆ‚Î¼ = r * âˆ«â» a, f a âˆ‚Î¼ :=\n  calc\n    âˆ«â» a, r * f a âˆ‚Î¼ = âˆ«â» a, â¨† n, (const Î± r * eapprox f n) a âˆ‚Î¼ := by\n      congr\n      funext a\n      rw [â† iSup_eapprox_apply hf, ENNReal.mul_iSup]\n      simp\n    _ = â¨† n, r * (eapprox f n).lintegral Î¼ := by\n      rw [lintegral_iSup]\n      Â· congr\n        funext n\n        rw [â† SimpleFunc.const_mul_lintegral, â† SimpleFunc.lintegral_eq_lintegral]\n      Â· intro n\n        exact SimpleFunc.measurable _\n      Â· intro i j h a\n        exact mul_le_mul_left' (monotone_eapprox _ h _) _\n    _ = r * âˆ«â» a, f a âˆ‚Î¼ := by rw [â† ENNReal.mul_iSup, lintegral_eq_iSup_eapprox_lintegral hf]\n\n"}
{"name":"MeasureTheory.lintegral_const_mul''","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nr : ENNReal\nf : Î± â†’ ENNReal\nhf : AEMeasurable f Î¼\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => HMul.hMul r (f a)) (HMul.hMul r (MeasureTheory.lintegral Î¼ fun a => f a))","decl":"theorem lintegral_const_mul'' (r : â„â‰¥0âˆ) {f : Î± â†’ â„â‰¥0âˆ} (hf : AEMeasurable f Î¼) :\n    âˆ«â» a, r * f a âˆ‚Î¼ = r * âˆ«â» a, f a âˆ‚Î¼ := by\n  have A : âˆ«â» a, f a âˆ‚Î¼ = âˆ«â» a, hf.mk f a âˆ‚Î¼ := lintegral_congr_ae hf.ae_eq_mk\n  have B : âˆ«â» a, r * f a âˆ‚Î¼ = âˆ«â» a, r * hf.mk f a âˆ‚Î¼ :=\n    lintegral_congr_ae (EventuallyEq.fun_comp hf.ae_eq_mk _)\n  rw [A, B, lintegral_const_mul _ hf.measurable_mk]\n\n"}
{"name":"MeasureTheory.lintegral_const_mul_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nr : ENNReal\nf : Î± â†’ ENNReal\nâŠ¢ LE.le (HMul.hMul r (MeasureTheory.lintegral Î¼ fun a => f a)) (MeasureTheory.lintegral Î¼ fun a => HMul.hMul r (f a))","decl":"theorem lintegral_const_mul_le (r : â„â‰¥0âˆ) (f : Î± â†’ â„â‰¥0âˆ) :\n    r * âˆ«â» a, f a âˆ‚Î¼ â‰¤ âˆ«â» a, r * f a âˆ‚Î¼ := by\n  rw [lintegral, ENNReal.mul_iSup]\n  refine iSup_le fun s => ?_\n  rw [ENNReal.mul_iSup, iSup_le_iff]\n  intro hs\n  rw [â† SimpleFunc.const_mul_lintegral, lintegral]\n  refine le_iSup_of_le (const Î± r * s) (le_iSup_of_le (fun x => ?_) le_rfl)\n  exact mul_le_mul_left' (hs x) _\n\n"}
{"name":"MeasureTheory.lintegral_const_mul'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nr : ENNReal\nf : Î± â†’ ENNReal\nhr : Ne r Top.top\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => HMul.hMul r (f a)) (HMul.hMul r (MeasureTheory.lintegral Î¼ fun a => f a))","decl":"theorem lintegral_const_mul' (r : â„â‰¥0âˆ) (f : Î± â†’ â„â‰¥0âˆ) (hr : r â‰  âˆ) :\n    âˆ«â» a, r * f a âˆ‚Î¼ = r * âˆ«â» a, f a âˆ‚Î¼ := by\n  by_cases h : r = 0\n  Â· simp [h]\n  apply le_antisymm _ (lintegral_const_mul_le r f)\n  have rinv : r * râ»Â¹ = 1 := ENNReal.mul_inv_cancel h hr\n  have rinv' : râ»Â¹ * r = 1 := by\n    rw [mul_comm]\n    exact rinv\n  have := lintegral_const_mul_le (Î¼ := Î¼) râ»Â¹ fun x => r * f x\n  simp? [(mul_assoc _ _ _).symm, rinv'] at this says\n    simp only [(mul_assoc _ _ _).symm, rinv', one_mul] at this\n  simpa [(mul_assoc _ _ _).symm, rinv] using mul_le_mul_left' this r\n\n"}
{"name":"MeasureTheory.lintegral_mul_const","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nr : ENNReal\nf : Î± â†’ ENNReal\nhf : Measurable f\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => HMul.hMul (f a) r) (HMul.hMul (MeasureTheory.lintegral Î¼ fun a => f a) r)","decl":"theorem lintegral_mul_const (r : â„â‰¥0âˆ) {f : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) :\n    âˆ«â» a, f a * r âˆ‚Î¼ = (âˆ«â» a, f a âˆ‚Î¼) * r := by simp_rw [mul_comm, lintegral_const_mul r hf]\n\n"}
{"name":"MeasureTheory.lintegral_mul_const''","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nr : ENNReal\nf : Î± â†’ ENNReal\nhf : AEMeasurable f Î¼\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => HMul.hMul (f a) r) (HMul.hMul (MeasureTheory.lintegral Î¼ fun a => f a) r)","decl":"theorem lintegral_mul_const'' (r : â„â‰¥0âˆ) {f : Î± â†’ â„â‰¥0âˆ} (hf : AEMeasurable f Î¼) :\n    âˆ«â» a, f a * r âˆ‚Î¼ = (âˆ«â» a, f a âˆ‚Î¼) * r := by simp_rw [mul_comm, lintegral_const_mul'' r hf]\n\n"}
{"name":"MeasureTheory.lintegral_mul_const_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nr : ENNReal\nf : Î± â†’ ENNReal\nâŠ¢ LE.le (HMul.hMul (MeasureTheory.lintegral Î¼ fun a => f a) r) (MeasureTheory.lintegral Î¼ fun a => HMul.hMul (f a) r)","decl":"theorem lintegral_mul_const_le (r : â„â‰¥0âˆ) (f : Î± â†’ â„â‰¥0âˆ) :\n    (âˆ«â» a, f a âˆ‚Î¼) * r â‰¤ âˆ«â» a, f a * r âˆ‚Î¼ := by\n  simp_rw [mul_comm, lintegral_const_mul_le r f]\n\n"}
{"name":"MeasureTheory.lintegral_mul_const'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nr : ENNReal\nf : Î± â†’ ENNReal\nhr : Ne r Top.top\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => HMul.hMul (f a) r) (HMul.hMul (MeasureTheory.lintegral Î¼ fun a => f a) r)","decl":"theorem lintegral_mul_const' (r : â„â‰¥0âˆ) (f : Î± â†’ â„â‰¥0âˆ) (hr : r â‰  âˆ) :\n    âˆ«â» a, f a * r âˆ‚Î¼ = (âˆ«â» a, f a âˆ‚Î¼) * r := by simp_rw [mul_comm, lintegral_const_mul' r f hr]\n\n/- A double integral of a product where each factor contains only one variable\n  is a product of integrals -/\n"}
{"name":"MeasureTheory.lintegral_lintegral_mul","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ² : Type u_5\ninstâœ : MeasurableSpace Î²\nÎ½ : MeasureTheory.Measure Î²\nf : Î± â†’ ENNReal\ng : Î² â†’ ENNReal\nhf : AEMeasurable f Î¼\nhg : AEMeasurable g Î½\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun x => MeasureTheory.lintegral Î½ fun y => HMul.hMul (f x) (g y)) (HMul.hMul (MeasureTheory.lintegral Î¼ fun x => f x) (MeasureTheory.lintegral Î½ fun y => g y))","decl":"theorem lintegral_lintegral_mul {Î²} [MeasurableSpace Î²] {Î½ : Measure Î²} {f : Î± â†’ â„â‰¥0âˆ}\n    {g : Î² â†’ â„â‰¥0âˆ} (hf : AEMeasurable f Î¼) (hg : AEMeasurable g Î½) :\n    âˆ«â» x, âˆ«â» y, f x * g y âˆ‚Î½ âˆ‚Î¼ = (âˆ«â» x, f x âˆ‚Î¼) * âˆ«â» y, g y âˆ‚Î½ := by\n  simp [lintegral_const_mul'' _ hg, lintegral_mul_const'' _ hf]\n\n-- TODO: Need a better way of rewriting inside of an integral\n"}
{"name":"MeasureTheory.lintegral_rwâ‚","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf f' : Î± â†’ Î²\nh : (MeasureTheory.ae Î¼).EventuallyEq f f'\ng : Î² â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => g (f a)) (MeasureTheory.lintegral Î¼ fun a => g (f' a))","decl":"theorem lintegral_rwâ‚ {f f' : Î± â†’ Î²} (h : f =áµ[Î¼] f') (g : Î² â†’ â„â‰¥0âˆ) :\n    âˆ«â» a, g (f a) âˆ‚Î¼ = âˆ«â» a, g (f' a) âˆ‚Î¼ :=\n  lintegral_congr_ae <| h.mono fun a h => by dsimp only; rw [h]\n\n-- TODO: Need a better way of rewriting inside of an integral\n"}
{"name":"MeasureTheory.lintegral_rwâ‚‚","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nfâ‚ fâ‚' : Î± â†’ Î²\nfâ‚‚ fâ‚‚' : Î± â†’ Î³\nhâ‚ : (MeasureTheory.ae Î¼).EventuallyEq fâ‚ fâ‚'\nhâ‚‚ : (MeasureTheory.ae Î¼).EventuallyEq fâ‚‚ fâ‚‚'\ng : Î² â†’ Î³ â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => g (fâ‚ a) (fâ‚‚ a)) (MeasureTheory.lintegral Î¼ fun a => g (fâ‚' a) (fâ‚‚' a))","decl":"theorem lintegral_rwâ‚‚ {fâ‚ fâ‚' : Î± â†’ Î²} {fâ‚‚ fâ‚‚' : Î± â†’ Î³} (hâ‚ : fâ‚ =áµ[Î¼] fâ‚') (hâ‚‚ : fâ‚‚ =áµ[Î¼] fâ‚‚')\n    (g : Î² â†’ Î³ â†’ â„â‰¥0âˆ) : âˆ«â» a, g (fâ‚ a) (fâ‚‚ a) âˆ‚Î¼ = âˆ«â» a, g (fâ‚' a) (fâ‚‚' a) âˆ‚Î¼ :=\n  lintegral_congr_ae <| hâ‚.mp <| hâ‚‚.mono fun _ hâ‚‚ hâ‚ => by dsimp only; rw [hâ‚, hâ‚‚]\n\n"}
{"name":"MeasureTheory.lintegral_indicator_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\ns : Set Î±\nâŠ¢ LE.le (MeasureTheory.lintegral Î¼ fun a => s.indicator f a) (MeasureTheory.lintegral (Î¼.restrict s) fun a => f a)","decl":"theorem lintegral_indicator_le (f : Î± â†’ â„â‰¥0âˆ) (s : Set Î±) :\n    âˆ«â» a, s.indicator f a âˆ‚Î¼ â‰¤ âˆ«â» a in s, f a âˆ‚Î¼ := by\n  simp only [lintegral]\n  apply iSup_le (fun g â†¦ (iSup_le (fun hg â†¦ ?_)))\n  have : g â‰¤ f := hg.trans (indicator_le_self s f)\n  refine le_iSup_of_le g (le_iSup_of_le this (le_of_eq ?_))\n  rw [lintegral_restrict, SimpleFunc.lintegral]\n  congr with t\n  by_cases H : t = 0\n  Â· simp [H]\n  congr with x\n  simp only [mem_preimage, mem_singleton_iff, mem_inter_iff, iff_self_and]\n  rintro rfl\n  contrapose! H\n  simpa [H] using hg x\n\n"}
{"name":"MeasureTheory.lintegral_indicator","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nhs : MeasurableSet s\nf : Î± â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => s.indicator f a) (MeasureTheory.lintegral (Î¼.restrict s) fun a => f a)","decl":"@[simp]\ntheorem lintegral_indicator {s : Set Î±} (hs : MeasurableSet s) (f : Î± â†’ â„â‰¥0âˆ) :\n    âˆ«â» a, s.indicator f a âˆ‚Î¼ = âˆ«â» a in s, f a âˆ‚Î¼ := by\n  apply le_antisymm (lintegral_indicator_le f s)\n  simp only [lintegral, â† restrict_lintegral_eq_lintegral_restrict _ hs, iSup_subtype']\n  refine iSup_mono' (Subtype.forall.2 fun Ï† hÏ† => ?_)\n  refine âŸ¨âŸ¨Ï†.restrict s, fun x => ?_âŸ©, le_rflâŸ©\n  simp [hÏ† x, hs, indicator_le_indicator]\n\n"}
{"name":"MeasureTheory.setLIntegral_indicator","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns t : Set Î±\nhs : MeasurableSet s\nf : Î± â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict t) fun a => s.indicator f a) (MeasureTheory.lintegral (Î¼.restrict (Inter.inter s t)) fun a => f a)","decl":"lemma setLIntegral_indicator {s t : Set Î±} (hs : MeasurableSet s) (f : Î± â†’ â„â‰¥0âˆ) :\n    âˆ«â» a in t, s.indicator f a âˆ‚Î¼ = âˆ«â» a in s âˆ© t, f a âˆ‚Î¼ := by\n  rw [lintegral_indicator hs, Measure.restrict_restrict hs]\n\n"}
{"name":"MeasureTheory.lintegral_indicatorâ‚€","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nhs : MeasureTheory.NullMeasurableSet s Î¼\nf : Î± â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => s.indicator f a) (MeasureTheory.lintegral (Î¼.restrict s) fun a => f a)","decl":"theorem lintegral_indicatorâ‚€ {s : Set Î±} (hs : NullMeasurableSet s Î¼) (f : Î± â†’ â„â‰¥0âˆ) :\n    âˆ«â» a, s.indicator f a âˆ‚Î¼ = âˆ«â» a in s, f a âˆ‚Î¼ := by\n  rw [â† lintegral_congr_ae (indicator_ae_eq_of_ae_eq_set hs.toMeasurable_ae_eq),\n    lintegral_indicator (measurableSet_toMeasurable _ _),\n    Measure.restrict_congr_set hs.toMeasurable_ae_eq]\n\n"}
{"name":"MeasureTheory.setLIntegral_indicatorâ‚€","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\ns t : Set Î±\nhs : MeasureTheory.NullMeasurableSet s (Î¼.restrict t)\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict t) fun a => s.indicator f a) (MeasureTheory.lintegral (Î¼.restrict (Inter.inter s t)) fun a => f a)","decl":"lemma setLIntegral_indicatorâ‚€ (f : Î± â†’ â„â‰¥0âˆ) {s t : Set Î±}\n    (hs : NullMeasurableSet s (Î¼.restrict t)) :\n    âˆ«â» a in t, s.indicator f a âˆ‚Î¼ = âˆ«â» a in s âˆ© t, f a âˆ‚Î¼ := by\n  rw [lintegral_indicatorâ‚€ hs, Measure.restrict_restrictâ‚€ hs]\n\n"}
{"name":"MeasureTheory.lintegral_indicator_const_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nc : ENNReal\nâŠ¢ LE.le (MeasureTheory.lintegral Î¼ fun a => s.indicator (fun x => c) a) (HMul.hMul c (Î¼ s))","decl":"theorem lintegral_indicator_const_le (s : Set Î±) (c : â„â‰¥0âˆ) :\n    âˆ«â» a, s.indicator (fun _ => c) a âˆ‚Î¼ â‰¤ c * Î¼ s :=\n  (lintegral_indicator_le _ _).trans (setLIntegral_const s c).le\n\n"}
{"name":"MeasureTheory.lintegral_indicator_constâ‚€","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nhs : MeasureTheory.NullMeasurableSet s Î¼\nc : ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => s.indicator (fun x => c) a) (HMul.hMul c (Î¼ s))","decl":"theorem lintegral_indicator_constâ‚€ {s : Set Î±} (hs : NullMeasurableSet s Î¼) (c : â„â‰¥0âˆ) :\n    âˆ«â» a, s.indicator (fun _ => c) a âˆ‚Î¼ = c * Î¼ s := by\n  rw [lintegral_indicatorâ‚€ hs, setLIntegral_const]\n\n"}
{"name":"MeasureTheory.lintegral_indicator_const","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nhs : MeasurableSet s\nc : ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => s.indicator (fun x => c) a) (HMul.hMul c (Î¼ s))","decl":"theorem lintegral_indicator_const {s : Set Î±} (hs : MeasurableSet s) (c : â„â‰¥0âˆ) :\n    âˆ«â» a, s.indicator (fun _ => c) a âˆ‚Î¼ = c * Î¼ s :=\n  lintegral_indicator_constâ‚€ hs.nullMeasurableSet c\n\n"}
{"name":"MeasureTheory.setLIntegral_eq_of_support_subset","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nf : Î± â†’ ENNReal\nhsf : HasSubset.Subset (Function.support f) s\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict s) fun x => f x) (MeasureTheory.lintegral Î¼ fun x => f x)","decl":"lemma setLIntegral_eq_of_support_subset {s : Set Î±} {f : Î± â†’ â„â‰¥0âˆ} (hsf : f.support âŠ† s) :\n    âˆ«â» x in s, f x âˆ‚Î¼ = âˆ«â» x, f x âˆ‚Î¼ := by\n  apply le_antisymm (setLIntegral_le_lintegral s fun x â†¦ f x)\n  apply le_trans (le_of_eq _) (lintegral_indicator_le _ _)\n  congr with x\n  simp only [indicator]\n  split_ifs with h\n  Â· rfl\n  Â· exact Function.support_subset_iff'.1 hsf x h\n\n"}
{"name":"MeasureTheory.setLIntegral_eq_const","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nhf : Measurable f\nr : ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict (setOf fun x => Eq (f x) r)) fun x => f x) (HMul.hMul r (Î¼ (setOf fun x => Eq (f x) r)))","decl":"theorem setLIntegral_eq_const {f : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) (r : â„â‰¥0âˆ) :\n    âˆ«â» x in { x | f x = r }, f x âˆ‚Î¼ = r * Î¼ { x | f x = r } := by\n  have : âˆ€áµ x âˆ‚Î¼, x âˆˆ { x | f x = r } â†’ f x = r := ae_of_all Î¼ fun _ hx => hx\n  rw [setLIntegral_congr_fun _ this]\n  Â· rw [lintegral_const, Measure.restrict_apply MeasurableSet.univ, Set.univ_inter]\n  Â· exact hf (measurableSet_singleton r)\n\n"}
{"name":"MeasureTheory.lintegral_indicator_one_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nâŠ¢ LE.le (MeasureTheory.lintegral Î¼ fun a => s.indicator 1 a) (Î¼ s)","decl":"theorem lintegral_indicator_one_le (s : Set Î±) : âˆ«â» a, s.indicator 1 a âˆ‚Î¼ â‰¤ Î¼ s :=\n  (lintegral_indicator_const_le _ _).trans <| (one_mul _).le\n\n"}
{"name":"MeasureTheory.lintegral_indicator_oneâ‚€","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nhs : MeasureTheory.NullMeasurableSet s Î¼\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => s.indicator 1 a) (Î¼ s)","decl":"@[simp]\ntheorem lintegral_indicator_oneâ‚€ {s : Set Î±} (hs : NullMeasurableSet s Î¼) :\n    âˆ«â» a, s.indicator 1 a âˆ‚Î¼ = Î¼ s :=\n  (lintegral_indicator_constâ‚€ hs _).trans <| one_mul _\n\n"}
{"name":"MeasureTheory.lintegral_indicator_one","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nhs : MeasurableSet s\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => s.indicator 1 a) (Î¼ s)","decl":"@[simp]\ntheorem lintegral_indicator_one {s : Set Î±} (hs : MeasurableSet s) :\n    âˆ«â» a, s.indicator 1 a âˆ‚Î¼ = Î¼ s :=\n  (lintegral_indicator_const hs _).trans <| one_mul _\n\n"}
{"name":"MeasureTheory.lintegral_add_mul_meas_add_le_le_lintegral","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ ENNReal\nhle : (MeasureTheory.ae Î¼).EventuallyLE f g\nhg : AEMeasurable g Î¼\nÎµ : ENNReal\nâŠ¢ LE.le (HAdd.hAdd (MeasureTheory.lintegral Î¼ fun a => f a) (HMul.hMul Îµ (Î¼ (setOf fun x => LE.le (HAdd.hAdd (f x) Îµ) (g x))))) (MeasureTheory.lintegral Î¼ fun a => g a)","decl":"/-- A version of **Markov's inequality** for two functions. It doesn't follow from the standard\nMarkov's inequality because we only assume measurability of `g`, not `f`. -/\ntheorem lintegral_add_mul_meas_add_le_le_lintegral {f g : Î± â†’ â„â‰¥0âˆ} (hle : f â‰¤áµ[Î¼] g)\n    (hg : AEMeasurable g Î¼) (Îµ : â„â‰¥0âˆ) :\n    âˆ«â» a, f a âˆ‚Î¼ + Îµ * Î¼ { x | f x + Îµ â‰¤ g x } â‰¤ âˆ«â» a, g a âˆ‚Î¼ := by\n  rcases exists_measurable_le_lintegral_eq Î¼ f with âŸ¨Ï†, hÏ†m, hÏ†_le, hÏ†_eqâŸ©\n  calc\n    âˆ«â» x, f x âˆ‚Î¼ + Îµ * Î¼ { x | f x + Îµ â‰¤ g x } = âˆ«â» x, Ï† x âˆ‚Î¼ + Îµ * Î¼ { x | f x + Îµ â‰¤ g x } := by\n      rw [hÏ†_eq]\n    _ â‰¤ âˆ«â» x, Ï† x âˆ‚Î¼ + Îµ * Î¼ { x | Ï† x + Îµ â‰¤ g x } := by\n      gcongr\n      exact fun x => (add_le_add_right (hÏ†_le _) _).trans\n    _ = âˆ«â» x, Ï† x + indicator { x | Ï† x + Îµ â‰¤ g x } (fun _ => Îµ) x âˆ‚Î¼ := by\n      rw [lintegral_add_left hÏ†m, lintegral_indicatorâ‚€, setLIntegral_const]\n      exact measurableSet_le (hÏ†m.nullMeasurable.measurable'.add_const _) hg.nullMeasurable\n    _ â‰¤ âˆ«â» x, g x âˆ‚Î¼ := lintegral_mono_ae (hle.mono fun x hxâ‚ => ?_)\n  simp only [indicator_apply]; split_ifs with hxâ‚‚\n  exacts [hxâ‚‚, (add_zero _).trans_le <| (hÏ†_le x).trans hxâ‚]\n\n"}
{"name":"MeasureTheory.mul_meas_ge_le_lintegralâ‚€","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nhf : AEMeasurable f Î¼\nÎµ : ENNReal\nâŠ¢ LE.le (HMul.hMul Îµ (Î¼ (setOf fun x => LE.le Îµ (f x)))) (MeasureTheory.lintegral Î¼ fun a => f a)","decl":"/-- **Markov's inequality** also known as **Chebyshev's first inequality**. -/\ntheorem mul_meas_ge_le_lintegralâ‚€ {f : Î± â†’ â„â‰¥0âˆ} (hf : AEMeasurable f Î¼) (Îµ : â„â‰¥0âˆ) :\n    Îµ * Î¼ { x | Îµ â‰¤ f x } â‰¤ âˆ«â» a, f a âˆ‚Î¼ := by\n  simpa only [lintegral_zero, zero_add] using\n    lintegral_add_mul_meas_add_le_le_lintegral (ae_of_all _ fun x => zero_le (f x)) hf Îµ\n\n"}
{"name":"MeasureTheory.mul_meas_ge_le_lintegral","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nhf : Measurable f\nÎµ : ENNReal\nâŠ¢ LE.le (HMul.hMul Îµ (Î¼ (setOf fun x => LE.le Îµ (f x)))) (MeasureTheory.lintegral Î¼ fun a => f a)","decl":"/-- **Markov's inequality** also known as **Chebyshev's first inequality**. For a version assuming\n`AEMeasurable`, see `mul_meas_ge_le_lintegralâ‚€`. -/\ntheorem mul_meas_ge_le_lintegral {f : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) (Îµ : â„â‰¥0âˆ) :\n    Îµ * Î¼ { x | Îµ â‰¤ f x } â‰¤ âˆ«â» a, f a âˆ‚Î¼ :=\n  mul_meas_ge_le_lintegralâ‚€ hf.aemeasurable Îµ\n\n"}
{"name":"MeasureTheory.meas_le_lintegralâ‚€","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nhf : AEMeasurable f Î¼\ns : Set Î±\nhs : âˆ€ (x : Î±), Membership.mem s x â†’ LE.le 1 (f x)\nâŠ¢ LE.le (Î¼ s) (MeasureTheory.lintegral Î¼ fun a => f a)","decl":"lemma meas_le_lintegralâ‚€ {f : Î± â†’ â„â‰¥0âˆ} (hf : AEMeasurable f Î¼)\n    {s : Set Î±} (hs : âˆ€ x âˆˆ s, 1 â‰¤ f x) : Î¼ s â‰¤ âˆ«â» a, f a âˆ‚Î¼ := by\n  apply le_trans _ (mul_meas_ge_le_lintegralâ‚€ hf 1)\n  rw [one_mul]\n  exact measure_mono hs\n\n"}
{"name":"MeasureTheory.lintegral_le_meas","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nf : Î± â†’ ENNReal\nhf : âˆ€ (a : Î±), LE.le (f a) 1\nh'f : âˆ€ (a : Î±), Membership.mem (HasCompl.compl s) a â†’ Eq (f a) 0\nâŠ¢ LE.le (MeasureTheory.lintegral Î¼ fun a => f a) (Î¼ s)","decl":"lemma lintegral_le_meas {s : Set Î±} {f : Î± â†’ â„â‰¥0âˆ} (hf : âˆ€ a, f a â‰¤ 1) (h'f : âˆ€ a âˆˆ sá¶œ, f a = 0) :\n    âˆ«â» a, f a âˆ‚Î¼ â‰¤ Î¼ s := by\n  apply (lintegral_mono (fun x â†¦ ?_)).trans (lintegral_indicator_one_le s)\n  by_cases hx : x âˆˆ s\n  Â· simpa [hx] using hf x\n  Â· simpa [hx] using h'f x hx\n\n"}
{"name":"MeasureTheory.setLIntegral_le_meas","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns t : Set Î±\nhs : MeasurableSet s\nf : Î± â†’ ENNReal\nhf : âˆ€ (a : Î±), Membership.mem s a â†’ Membership.mem t a â†’ LE.le (f a) 1\nhf' : âˆ€ (a : Î±), Membership.mem s a â†’ Not (Membership.mem t a) â†’ Eq (f a) 0\nâŠ¢ LE.le (MeasureTheory.lintegral (Î¼.restrict s) fun a => f a) (Î¼ t)","decl":"lemma setLIntegral_le_meas {s t : Set Î±} (hs : MeasurableSet s)\n    {f : Î± â†’ â„â‰¥0âˆ} (hf : âˆ€ a âˆˆ s, a âˆˆ t â†’ f a â‰¤ 1)\n    (hf' : âˆ€ a âˆˆ s, a âˆ‰ t â†’ f a = 0) : âˆ«â» a in s, f a âˆ‚Î¼ â‰¤ Î¼ t := by\n  rw [â† lintegral_indicator hs]\n  refine lintegral_le_meas (fun a â†¦ ?_) (by aesop)\n  by_cases has : a âˆˆ s <;> [by_cases hat : a âˆˆ t; skip] <;> simp [*]\n\n"}
{"name":"MeasureTheory.lintegral_eq_top_of_measure_eq_top_ne_zero","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nhf : AEMeasurable f Î¼\nhÎ¼f : Ne (Î¼ (setOf fun x => Eq (f x) Top.top)) 0\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun x => f x) Top.top","decl":"theorem lintegral_eq_top_of_measure_eq_top_ne_zero {f : Î± â†’ â„â‰¥0âˆ} (hf : AEMeasurable f Î¼)\n    (hÎ¼f : Î¼ {x | f x = âˆ} â‰  0) : âˆ«â» x, f x âˆ‚Î¼ = âˆ :=\n  eq_top_iff.mpr <|\n    calc\n      âˆ = âˆ * Î¼ { x | âˆ â‰¤ f x } := by simp [mul_eq_top, hÎ¼f]\n      _ â‰¤ âˆ«â» x, f x âˆ‚Î¼ := mul_meas_ge_le_lintegralâ‚€ hf âˆ\n\n"}
{"name":"MeasureTheory.setLintegral_eq_top_of_measure_eq_top_ne_zero","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\ns : Set Î±\nhf : AEMeasurable f (Î¼.restrict s)\nhÎ¼f : Ne (Î¼ (setOf fun x => And (Membership.mem s x) (Eq (f x) Top.top))) 0\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict s) fun x => f x) Top.top","decl":"theorem setLintegral_eq_top_of_measure_eq_top_ne_zero {f : Î± â†’ â„â‰¥0âˆ} {s : Set Î±}\n    (hf : AEMeasurable f (Î¼.restrict s)) (hÎ¼f : Î¼ ({x âˆˆ s | f x = âˆ}) â‰  0) :\n    âˆ«â» x in s, f x âˆ‚Î¼ = âˆ :=\n  lintegral_eq_top_of_measure_eq_top_ne_zero hf <|\n    mt (eq_bot_mono <| by rw [â† setOf_inter_eq_sep]; exact Measure.le_restrict_apply _ _) hÎ¼f\n\n"}
{"name":"MeasureTheory.measure_eq_top_of_lintegral_ne_top","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nhf : AEMeasurable f Î¼\nhÎ¼f : Ne (MeasureTheory.lintegral Î¼ fun x => f x) Top.top\nâŠ¢ Eq (Î¼ (setOf fun x => Eq (f x) Top.top)) 0","decl":"theorem measure_eq_top_of_lintegral_ne_top {f : Î± â†’ â„â‰¥0âˆ}\n    (hf : AEMeasurable f Î¼) (hÎ¼f : âˆ«â» x, f x âˆ‚Î¼ â‰  âˆ) : Î¼ {x | f x = âˆ} = 0 :=\n  of_not_not fun h => hÎ¼f <| lintegral_eq_top_of_measure_eq_top_ne_zero hf h\n\n"}
{"name":"MeasureTheory.measure_eq_top_of_setLintegral_ne_top","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\ns : Set Î±\nhf : AEMeasurable f (Î¼.restrict s)\nhÎ¼f : Ne (MeasureTheory.lintegral (Î¼.restrict s) fun x => f x) Top.top\nâŠ¢ Eq (Î¼ (setOf fun x => And (Membership.mem s x) (Eq (f x) Top.top))) 0","decl":"theorem measure_eq_top_of_setLintegral_ne_top {f : Î± â†’ â„â‰¥0âˆ} {s : Set Î±}\n    (hf : AEMeasurable f (Î¼.restrict s)) (hÎ¼f : âˆ«â» x in s, f x âˆ‚Î¼ â‰  âˆ) :\n    Î¼ ({x âˆˆ s | f x = âˆ}) = 0 :=\n  of_not_not fun h => hÎ¼f <| setLintegral_eq_top_of_measure_eq_top_ne_zero hf h\n\n"}
{"name":"MeasureTheory.meas_ge_le_lintegral_div","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nhf : AEMeasurable f Î¼\nÎµ : ENNReal\nhÎµ : Ne Îµ 0\nhÎµ' : Ne Îµ Top.top\nâŠ¢ LE.le (Î¼ (setOf fun x => LE.le Îµ (f x))) (HDiv.hDiv (MeasureTheory.lintegral Î¼ fun a => f a) Îµ)","decl":"/-- **Markov's inequality**, also known as **Chebyshev's first inequality**. -/\ntheorem meas_ge_le_lintegral_div {f : Î± â†’ â„â‰¥0âˆ} (hf : AEMeasurable f Î¼) {Îµ : â„â‰¥0âˆ} (hÎµ : Îµ â‰  0)\n    (hÎµ' : Îµ â‰  âˆ) : Î¼ { x | Îµ â‰¤ f x } â‰¤ (âˆ«â» a, f a âˆ‚Î¼) / Îµ :=\n  (ENNReal.le_div_iff_mul_le (Or.inl hÎµ) (Or.inl hÎµ')).2 <| by\n    rw [mul_comm]\n    exact mul_meas_ge_le_lintegralâ‚€ hf Îµ\n\n"}
{"name":"MeasureTheory.ae_eq_of_ae_le_of_lintegral_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ ENNReal\nhfg : (MeasureTheory.ae Î¼).EventuallyLE f g\nhf : Ne (MeasureTheory.lintegral Î¼ fun x => f x) Top.top\nhg : AEMeasurable g Î¼\nhgf : LE.le (MeasureTheory.lintegral Î¼ fun x => g x) (MeasureTheory.lintegral Î¼ fun x => f x)\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq f g","decl":"theorem ae_eq_of_ae_le_of_lintegral_le {f g : Î± â†’ â„â‰¥0âˆ} (hfg : f â‰¤áµ[Î¼] g) (hf : âˆ«â» x, f x âˆ‚Î¼ â‰  âˆ)\n    (hg : AEMeasurable g Î¼) (hgf : âˆ«â» x, g x âˆ‚Î¼ â‰¤ âˆ«â» x, f x âˆ‚Î¼) : f =áµ[Î¼] g := by\n  have : âˆ€ n : â„•, âˆ€áµ x âˆ‚Î¼, g x < f x + (n : â„â‰¥0âˆ)â»Â¹ := by\n    intro n\n    simp only [ae_iff, not_lt]\n    have : âˆ«â» x, f x âˆ‚Î¼ + (â†‘n)â»Â¹ * Î¼ { x : Î± | f x + (n : â„â‰¥0âˆ)â»Â¹ â‰¤ g x } â‰¤ âˆ«â» x, f x âˆ‚Î¼ :=\n      (lintegral_add_mul_meas_add_le_le_lintegral hfg hg nâ»Â¹).trans hgf\n    rw [(ENNReal.cancel_of_ne hf).add_le_iff_nonpos_right, nonpos_iff_eq_zero, mul_eq_zero] at this\n    exact this.resolve_left (ENNReal.inv_ne_zero.2 (ENNReal.natCast_ne_top _))\n  refine hfg.mp ((ae_all_iff.2 this).mono fun x hlt hle => hle.antisymm ?_)\n  suffices Tendsto (fun n : â„• => f x + (n : â„â‰¥0âˆ)â»Â¹) atTop (ğ“ (f x)) from\n    ge_of_tendsto' this fun i => (hlt i).le\n  simpa only [inv_top, add_zero] using\n    tendsto_const_nhds.add (ENNReal.tendsto_inv_iff.2 ENNReal.tendsto_nat_nhds_top)\n\n"}
{"name":"MeasureTheory.lintegral_eq_zero_iff'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nhf : AEMeasurable f Î¼\nâŠ¢ Iff (Eq (MeasureTheory.lintegral Î¼ fun a => f a) 0) ((MeasureTheory.ae Î¼).EventuallyEq f 0)","decl":"@[simp]\ntheorem lintegral_eq_zero_iff' {f : Î± â†’ â„â‰¥0âˆ} (hf : AEMeasurable f Î¼) :\n    âˆ«â» a, f a âˆ‚Î¼ = 0 â†” f =áµ[Î¼] 0 :=\n  have : âˆ«â» _ : Î±, 0 âˆ‚Î¼ â‰  âˆ := by simp [lintegral_zero, zero_ne_top]\n  âŸ¨fun h =>\n    (ae_eq_of_ae_le_of_lintegral_le (ae_of_all _ <| zero_le f) this hf\n        (h.trans lintegral_zero.symm).le).symm,\n    fun h => (lintegral_congr_ae h).trans lintegral_zeroâŸ©\n\n"}
{"name":"MeasureTheory.lintegral_eq_zero_iff","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nhf : Measurable f\nâŠ¢ Iff (Eq (MeasureTheory.lintegral Î¼ fun a => f a) 0) ((MeasureTheory.ae Î¼).EventuallyEq f 0)","decl":"@[simp]\ntheorem lintegral_eq_zero_iff {f : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) : âˆ«â» a, f a âˆ‚Î¼ = 0 â†” f =áµ[Î¼] 0 :=\n  lintegral_eq_zero_iff' hf.aemeasurable\n\n"}
{"name":"MeasureTheory.setLIntegral_eq_zero_iff'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nhs : MeasurableSet s\nf : Î± â†’ ENNReal\nhf : AEMeasurable f (Î¼.restrict s)\nâŠ¢ Iff (Eq (MeasureTheory.lintegral (Î¼.restrict s) fun a => f a) 0) (Filter.Eventually (fun x => Membership.mem s x â†’ Eq (f x) 0) (MeasureTheory.ae Î¼))","decl":"theorem setLIntegral_eq_zero_iff' {s : Set Î±} (hs : MeasurableSet s)\n    {f : Î± â†’ â„â‰¥0âˆ} (hf : AEMeasurable f (Î¼.restrict s)) :\n    âˆ«â» a in s, f a âˆ‚Î¼ = 0 â†” âˆ€áµ x âˆ‚Î¼, x âˆˆ s â†’ f x = 0 :=\n  (lintegral_eq_zero_iff' hf).trans (ae_restrict_iff' hs)\n\n"}
{"name":"MeasureTheory.setLIntegral_eq_zero_iff","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nhs : MeasurableSet s\nf : Î± â†’ ENNReal\nhf : Measurable f\nâŠ¢ Iff (Eq (MeasureTheory.lintegral (Î¼.restrict s) fun a => f a) 0) (Filter.Eventually (fun x => Membership.mem s x â†’ Eq (f x) 0) (MeasureTheory.ae Î¼))","decl":"theorem setLIntegral_eq_zero_iff {s : Set Î±} (hs : MeasurableSet s) {f : Î± â†’ â„â‰¥0âˆ}\n    (hf : Measurable f) : âˆ«â» a in s, f a âˆ‚Î¼ = 0 â†” âˆ€áµ x âˆ‚Î¼, x âˆˆ s â†’ f x = 0 :=\n  setLIntegral_eq_zero_iff' hs hf.aemeasurable\n\n"}
{"name":"MeasureTheory.lintegral_pos_iff_support","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nhf : Measurable f\nâŠ¢ Iff (LT.lt 0 (MeasureTheory.lintegral Î¼ fun a => f a)) (LT.lt 0 (Î¼ (Function.support f)))","decl":"theorem lintegral_pos_iff_support {f : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) :\n    (0 < âˆ«â» a, f a âˆ‚Î¼) â†” 0 < Î¼ (Function.support f) := by\n  simp [pos_iff_ne_zero, hf, Filter.EventuallyEq, ae_iff, Function.support]\n\n"}
{"name":"MeasureTheory.setLintegral_pos_iff","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nhf : Measurable f\ns : Set Î±\nâŠ¢ Iff (LT.lt 0 (MeasureTheory.lintegral (Î¼.restrict s) fun a => f a)) (LT.lt 0 (Î¼ (Inter.inter (Function.support f) s)))","decl":"theorem setLintegral_pos_iff {f : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) {s : Set Î±} :\n    0 < âˆ«â» a in s, f a âˆ‚Î¼ â†” 0 < Î¼ (Function.support f âˆ© s) := by\n  rw [lintegral_pos_iff_support hf, Measure.restrict_apply (measurableSet_support hf)]\n\n"}
{"name":"MeasureTheory.lintegral_iSup_ae","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Nat â†’ Î± â†’ ENNReal\nhf : âˆ€ (n : Nat), Measurable (f n)\nh_mono : âˆ€ (n : Nat), Filter.Eventually (fun a => LE.le (f n a) (f n.succ a)) (MeasureTheory.ae Î¼)\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => iSup fun n => f n a) (iSup fun n => MeasureTheory.lintegral Î¼ fun a => f n a)","decl":"/-- Weaker version of the monotone convergence theorem -/\ntheorem lintegral_iSup_ae {f : â„• â†’ Î± â†’ â„â‰¥0âˆ} (hf : âˆ€ n, Measurable (f n))\n    (h_mono : âˆ€ n, âˆ€áµ a âˆ‚Î¼, f n a â‰¤ f n.succ a) : âˆ«â» a, â¨† n, f n a âˆ‚Î¼ = â¨† n, âˆ«â» a, f n a âˆ‚Î¼ := by\n  classical\n  let âŸ¨s, hsâŸ© := exists_measurable_superset_of_null (ae_iff.1 (ae_all_iff.2 h_mono))\n  let g n a := if a âˆˆ s then 0 else f n a\n  have g_eq_f : âˆ€áµ a âˆ‚Î¼, âˆ€ n, g n a = f n a :=\n    (measure_zero_iff_ae_nmem.1 hs.2.2).mono fun a ha n => if_neg ha\n  calc\n    âˆ«â» a, â¨† n, f n a âˆ‚Î¼ = âˆ«â» a, â¨† n, g n a âˆ‚Î¼ :=\n      lintegral_congr_ae <| g_eq_f.mono fun a ha => by simp only [ha]\n    _ = â¨† n, âˆ«â» a, g n a âˆ‚Î¼ :=\n      (lintegral_iSup (fun n => measurable_const.piecewise hs.2.1 (hf n))\n        (monotone_nat_of_le_succ fun n a => ?_))\n    _ = â¨† n, âˆ«â» a, f n a âˆ‚Î¼ := by simp only [lintegral_congr_ae (g_eq_f.mono fun _a ha => ha _)]\n  simp only [g]\n  split_ifs with h\n  Â· rfl\n  Â· have := Set.not_mem_subset hs.1 h\n    simp only [not_forall, not_le, mem_setOf_eq, not_exists, not_lt] at this\n    exact this n\n\n"}
{"name":"MeasureTheory.lintegral_sub'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ ENNReal\nhg : AEMeasurable g Î¼\nhg_fin : Ne (MeasureTheory.lintegral Î¼ fun a => g a) Top.top\nh_le : (MeasureTheory.ae Î¼).EventuallyLE g f\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => HSub.hSub (f a) (g a)) (HSub.hSub (MeasureTheory.lintegral Î¼ fun a => f a) (MeasureTheory.lintegral Î¼ fun a => g a))","decl":"theorem lintegral_sub' {f g : Î± â†’ â„â‰¥0âˆ} (hg : AEMeasurable g Î¼) (hg_fin : âˆ«â» a, g a âˆ‚Î¼ â‰  âˆ)\n    (h_le : g â‰¤áµ[Î¼] f) : âˆ«â» a, f a - g a âˆ‚Î¼ = âˆ«â» a, f a âˆ‚Î¼ - âˆ«â» a, g a âˆ‚Î¼ := by\n  refine ENNReal.eq_sub_of_add_eq hg_fin ?_\n  rw [â† lintegral_add_right' _ hg]\n  exact lintegral_congr_ae (h_le.mono fun x hx => tsub_add_cancel_of_le hx)\n\n"}
{"name":"MeasureTheory.lintegral_sub","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ ENNReal\nhg : Measurable g\nhg_fin : Ne (MeasureTheory.lintegral Î¼ fun a => g a) Top.top\nh_le : (MeasureTheory.ae Î¼).EventuallyLE g f\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => HSub.hSub (f a) (g a)) (HSub.hSub (MeasureTheory.lintegral Î¼ fun a => f a) (MeasureTheory.lintegral Î¼ fun a => g a))","decl":"theorem lintegral_sub {f g : Î± â†’ â„â‰¥0âˆ} (hg : Measurable g) (hg_fin : âˆ«â» a, g a âˆ‚Î¼ â‰  âˆ)\n    (h_le : g â‰¤áµ[Î¼] f) : âˆ«â» a, f a - g a âˆ‚Î¼ = âˆ«â» a, f a âˆ‚Î¼ - âˆ«â» a, g a âˆ‚Î¼ :=\n  lintegral_sub' hg.aemeasurable hg_fin h_le\n\n"}
{"name":"MeasureTheory.lintegral_sub_le'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ ENNReal\nhf : AEMeasurable f Î¼\nâŠ¢ LE.le (HSub.hSub (MeasureTheory.lintegral Î¼ fun x => g x) (MeasureTheory.lintegral Î¼ fun x => f x)) (MeasureTheory.lintegral Î¼ fun x => HSub.hSub (g x) (f x))","decl":"theorem lintegral_sub_le' (f g : Î± â†’ â„â‰¥0âˆ) (hf : AEMeasurable f Î¼) :\n    âˆ«â» x, g x âˆ‚Î¼ - âˆ«â» x, f x âˆ‚Î¼ â‰¤ âˆ«â» x, g x - f x âˆ‚Î¼ := by\n  rw [tsub_le_iff_right]\n  by_cases hfi : âˆ«â» x, f x âˆ‚Î¼ = âˆ\n  Â· rw [hfi, add_top]\n    exact le_top\n  Â· rw [â† lintegral_add_right' _ hf]\n    gcongr\n    exact le_tsub_add\n\n"}
{"name":"MeasureTheory.lintegral_sub_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ ENNReal\nhf : Measurable f\nâŠ¢ LE.le (HSub.hSub (MeasureTheory.lintegral Î¼ fun x => g x) (MeasureTheory.lintegral Î¼ fun x => f x)) (MeasureTheory.lintegral Î¼ fun x => HSub.hSub (g x) (f x))","decl":"theorem lintegral_sub_le (f g : Î± â†’ â„â‰¥0âˆ) (hf : Measurable f) :\n    âˆ«â» x, g x âˆ‚Î¼ - âˆ«â» x, f x âˆ‚Î¼ â‰¤ âˆ«â» x, g x - f x âˆ‚Î¼ :=\n  lintegral_sub_le' f g hf.aemeasurable\n\n"}
{"name":"MeasureTheory.lintegral_strict_mono_of_ae_le_of_frequently_ae_lt","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ ENNReal\nhg : AEMeasurable g Î¼\nhfi : Ne (MeasureTheory.lintegral Î¼ fun x => f x) Top.top\nh_le : (MeasureTheory.ae Î¼).EventuallyLE f g\nh : Filter.Frequently (fun x => Ne (f x) (g x)) (MeasureTheory.ae Î¼)\nâŠ¢ LT.lt (MeasureTheory.lintegral Î¼ fun x => f x) (MeasureTheory.lintegral Î¼ fun x => g x)","decl":"theorem lintegral_strict_mono_of_ae_le_of_frequently_ae_lt {f g : Î± â†’ â„â‰¥0âˆ} (hg : AEMeasurable g Î¼)\n    (hfi : âˆ«â» x, f x âˆ‚Î¼ â‰  âˆ) (h_le : f â‰¤áµ[Î¼] g) (h : âˆƒáµ x âˆ‚Î¼, f x â‰  g x) :\n    âˆ«â» x, f x âˆ‚Î¼ < âˆ«â» x, g x âˆ‚Î¼ := by\n  contrapose! h\n  simp only [not_frequently, Ne, Classical.not_not]\n  exact ae_eq_of_ae_le_of_lintegral_le h_le hfi hg h\n\n"}
{"name":"MeasureTheory.lintegral_strict_mono_of_ae_le_of_ae_lt_on","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ ENNReal\nhg : AEMeasurable g Î¼\nhfi : Ne (MeasureTheory.lintegral Î¼ fun x => f x) Top.top\nh_le : (MeasureTheory.ae Î¼).EventuallyLE f g\ns : Set Î±\nhÎ¼s : Ne (Î¼ s) 0\nh : Filter.Eventually (fun x => Membership.mem s x â†’ LT.lt (f x) (g x)) (MeasureTheory.ae Î¼)\nâŠ¢ LT.lt (MeasureTheory.lintegral Î¼ fun x => f x) (MeasureTheory.lintegral Î¼ fun x => g x)","decl":"theorem lintegral_strict_mono_of_ae_le_of_ae_lt_on {f g : Î± â†’ â„â‰¥0âˆ} (hg : AEMeasurable g Î¼)\n    (hfi : âˆ«â» x, f x âˆ‚Î¼ â‰  âˆ) (h_le : f â‰¤áµ[Î¼] g) {s : Set Î±} (hÎ¼s : Î¼ s â‰  0)\n    (h : âˆ€áµ x âˆ‚Î¼, x âˆˆ s â†’ f x < g x) : âˆ«â» x, f x âˆ‚Î¼ < âˆ«â» x, g x âˆ‚Î¼ :=\n  lintegral_strict_mono_of_ae_le_of_frequently_ae_lt hg hfi h_le <|\n    ((frequently_ae_mem_iff.2 hÎ¼s).and_eventually h).mono fun _x hx => (hx.2 hx.1).ne\n\n"}
{"name":"MeasureTheory.lintegral_strict_mono","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ ENNReal\nhÎ¼ : Ne Î¼ 0\nhg : AEMeasurable g Î¼\nhfi : Ne (MeasureTheory.lintegral Î¼ fun x => f x) Top.top\nh : Filter.Eventually (fun x => LT.lt (f x) (g x)) (MeasureTheory.ae Î¼)\nâŠ¢ LT.lt (MeasureTheory.lintegral Î¼ fun x => f x) (MeasureTheory.lintegral Î¼ fun x => g x)","decl":"theorem lintegral_strict_mono {f g : Î± â†’ â„â‰¥0âˆ} (hÎ¼ : Î¼ â‰  0) (hg : AEMeasurable g Î¼)\n    (hfi : âˆ«â» x, f x âˆ‚Î¼ â‰  âˆ) (h : âˆ€áµ x âˆ‚Î¼, f x < g x) : âˆ«â» x, f x âˆ‚Î¼ < âˆ«â» x, g x âˆ‚Î¼ := by\n  rw [Ne, â† Measure.measure_univ_eq_zero] at hÎ¼\n  refine lintegral_strict_mono_of_ae_le_of_ae_lt_on hg hfi (ae_le_of_ae_lt h) hÎ¼ ?_\n  simpa using h\n\n"}
{"name":"MeasureTheory.setLIntegral_strict_mono","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ ENNReal\ns : Set Î±\nhsm : MeasurableSet s\nhs : Ne (Î¼ s) 0\nhg : Measurable g\nhfi : Ne (MeasureTheory.lintegral (Î¼.restrict s) fun x => f x) Top.top\nh : Filter.Eventually (fun x => Membership.mem s x â†’ LT.lt (f x) (g x)) (MeasureTheory.ae Î¼)\nâŠ¢ LT.lt (MeasureTheory.lintegral (Î¼.restrict s) fun x => f x) (MeasureTheory.lintegral (Î¼.restrict s) fun x => g x)","decl":"theorem setLIntegral_strict_mono {f g : Î± â†’ â„â‰¥0âˆ} {s : Set Î±} (hsm : MeasurableSet s)\n    (hs : Î¼ s â‰  0) (hg : Measurable g) (hfi : âˆ«â» x in s, f x âˆ‚Î¼ â‰  âˆ)\n    (h : âˆ€áµ x âˆ‚Î¼, x âˆˆ s â†’ f x < g x) : âˆ«â» x in s, f x âˆ‚Î¼ < âˆ«â» x in s, g x âˆ‚Î¼ :=\n  lintegral_strict_mono (by simp [hs]) hg.aemeasurable hfi ((ae_restrict_iff' hsm).mpr h)\n\n"}
{"name":"MeasureTheory.lintegral_iInf_ae","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Nat â†’ Î± â†’ ENNReal\nh_meas : âˆ€ (n : Nat), Measurable (f n)\nh_mono : âˆ€ (n : Nat), (MeasureTheory.ae Î¼).EventuallyLE (f n.succ) (f n)\nh_fin : Ne (MeasureTheory.lintegral Î¼ fun a => f 0 a) Top.top\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => iInf fun n => f n a) (iInf fun n => MeasureTheory.lintegral Î¼ fun a => f n a)","decl":"/-- Monotone convergence theorem for nonincreasing sequences of functions -/\ntheorem lintegral_iInf_ae {f : â„• â†’ Î± â†’ â„â‰¥0âˆ} (h_meas : âˆ€ n, Measurable (f n))\n    (h_mono : âˆ€ n : â„•, f n.succ â‰¤áµ[Î¼] f n) (h_fin : âˆ«â» a, f 0 a âˆ‚Î¼ â‰  âˆ) :\n    âˆ«â» a, â¨… n, f n a âˆ‚Î¼ = â¨… n, âˆ«â» a, f n a âˆ‚Î¼ :=\n  have fn_le_f0 : âˆ«â» a, â¨… n, f n a âˆ‚Î¼ â‰¤ âˆ«â» a, f 0 a âˆ‚Î¼ :=\n    lintegral_mono fun _ => iInf_le_of_le 0 le_rfl\n  have fn_le_f0' : â¨… n, âˆ«â» a, f n a âˆ‚Î¼ â‰¤ âˆ«â» a, f 0 a âˆ‚Î¼ := iInf_le_of_le 0 le_rfl\n  (ENNReal.sub_right_inj h_fin fn_le_f0 fn_le_f0').1 <|\n    show âˆ«â» a, f 0 a âˆ‚Î¼ - âˆ«â» a, â¨… n, f n a âˆ‚Î¼ = âˆ«â» a, f 0 a âˆ‚Î¼ - â¨… n, âˆ«â» a, f n a âˆ‚Î¼ from\n      calc\n        âˆ«â» a, f 0 a âˆ‚Î¼ - âˆ«â» a, â¨… n, f n a âˆ‚Î¼ = âˆ«â» a, f 0 a - â¨… n, f n a âˆ‚Î¼ :=\n          (lintegral_sub (.iInf h_meas)\n              (ne_top_of_le_ne_top h_fin <| lintegral_mono fun _ => iInf_le _ _)\n              (ae_of_all _ fun _ => iInf_le _ _)).symm\n        _ = âˆ«â» a, â¨† n, f 0 a - f n a âˆ‚Î¼ := congr rfl (funext fun _ => ENNReal.sub_iInf)\n        _ = â¨† n, âˆ«â» a, f 0 a - f n a âˆ‚Î¼ :=\n          (lintegral_iSup_ae (fun n => (h_meas 0).sub (h_meas n)) fun n =>\n            (h_mono n).mono fun _ ha => tsub_le_tsub le_rfl ha)\n        _ = â¨† n, âˆ«â» a, f 0 a âˆ‚Î¼ - âˆ«â» a, f n a âˆ‚Î¼ :=\n          (have h_mono : âˆ€áµ a âˆ‚Î¼, âˆ€ n : â„•, f n.succ a â‰¤ f n a := ae_all_iff.2 h_mono\n          have h_mono : âˆ€ n, âˆ€áµ a âˆ‚Î¼, f n a â‰¤ f 0 a := fun n =>\n            h_mono.mono fun a h => by\n              induction' n with n ih\n              Â· exact le_rfl\n              Â· exact le_trans (h n) ih\n          congr_arg iSup <|\n            funext fun n =>\n              lintegral_sub (h_meas _) (ne_top_of_le_ne_top h_fin <| lintegral_mono_ae <| h_mono n)\n                (h_mono n))\n        _ = âˆ«â» a, f 0 a âˆ‚Î¼ - â¨… n, âˆ«â» a, f n a âˆ‚Î¼ := ENNReal.sub_iInf.symm\n\n"}
{"name":"MeasureTheory.lintegral_iInf","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Nat â†’ Î± â†’ ENNReal\nh_meas : âˆ€ (n : Nat), Measurable (f n)\nh_anti : Antitone f\nh_fin : Ne (MeasureTheory.lintegral Î¼ fun a => f 0 a) Top.top\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => iInf fun n => f n a) (iInf fun n => MeasureTheory.lintegral Î¼ fun a => f n a)","decl":"/-- Monotone convergence theorem for nonincreasing sequences of functions -/\ntheorem lintegral_iInf {f : â„• â†’ Î± â†’ â„â‰¥0âˆ} (h_meas : âˆ€ n, Measurable (f n)) (h_anti : Antitone f)\n    (h_fin : âˆ«â» a, f 0 a âˆ‚Î¼ â‰  âˆ) : âˆ«â» a, â¨… n, f n a âˆ‚Î¼ = â¨… n, âˆ«â» a, f n a âˆ‚Î¼ :=\n  lintegral_iInf_ae h_meas (fun n => ae_of_all _ <| h_anti n.le_succ) h_fin\n\n"}
{"name":"MeasureTheory.lintegral_iInf'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Nat â†’ Î± â†’ ENNReal\nh_meas : âˆ€ (n : Nat), AEMeasurable (f n) Î¼\nh_anti : Filter.Eventually (fun a => Antitone fun i => f i a) (MeasureTheory.ae Î¼)\nh_fin : Ne (MeasureTheory.lintegral Î¼ fun a => f 0 a) Top.top\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => iInf fun n => f n a) (iInf fun n => MeasureTheory.lintegral Î¼ fun a => f n a)","decl":"theorem lintegral_iInf' {f : â„• â†’ Î± â†’ â„â‰¥0âˆ} (h_meas : âˆ€ n, AEMeasurable (f n) Î¼)\n    (h_anti : âˆ€áµ a âˆ‚Î¼, Antitone (fun i â†¦ f i a)) (h_fin : âˆ«â» a, f 0 a âˆ‚Î¼ â‰  âˆ) :\n    âˆ«â» a, â¨… n, f n a âˆ‚Î¼ = â¨… n, âˆ«â» a, f n a âˆ‚Î¼ := by\n  simp_rw [â† iInf_apply]\n  let p : Î± â†’ (â„• â†’ â„â‰¥0âˆ) â†’ Prop := fun _ f' => Antitone f'\n  have hp : âˆ€áµ x âˆ‚Î¼, p x fun i => f i x := h_anti\n  have h_ae_seq_mono : Antitone (aeSeq h_meas p) := by\n    intro n m hnm x\n    by_cases hx : x âˆˆ aeSeqSet h_meas p\n    Â· exact aeSeq.prop_of_mem_aeSeqSet h_meas hx hnm\n    Â· simp only [aeSeq, hx, if_false]\n      exact le_rfl\n  rw [lintegral_congr_ae (aeSeq.iInf h_meas hp).symm]\n  simp_rw [iInf_apply]\n  rw [lintegral_iInf (aeSeq.measurable h_meas p) h_ae_seq_mono]\n  Â· congr\n    exact funext fun n â†¦ lintegral_congr_ae (aeSeq.aeSeq_n_eq_fun_n_ae h_meas hp n)\n  Â· rwa [lintegral_congr_ae (aeSeq.aeSeq_n_eq_fun_n_ae h_meas hp 0)]\n\n"}
{"name":"MeasureTheory.lintegral_iInf_directed_of_measurable","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nmÎ± : MeasurableSpace Î±\ninstâœ : Countable Î²\nf : Î² â†’ Î± â†’ ENNReal\nÎ¼ : MeasureTheory.Measure Î±\nhÎ¼ : Ne Î¼ 0\nhf : âˆ€ (b : Î²), Measurable (f b)\nhf_int : âˆ€ (b : Î²), Ne (MeasureTheory.lintegral Î¼ fun a => f b a) Top.top\nh_directed : Directed (fun x1 x2 => GE.ge x1 x2) f\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => iInf fun b => f b a) (iInf fun b => MeasureTheory.lintegral Î¼ fun a => f b a)","decl":"/-- Monotone convergence for an infimum over a directed family and indexed by a countable type -/\ntheorem lintegral_iInf_directed_of_measurable {mÎ± : MeasurableSpace Î±} [Countable Î²]\n    {f : Î² â†’ Î± â†’ â„â‰¥0âˆ} {Î¼ : Measure Î±} (hÎ¼ : Î¼ â‰  0) (hf : âˆ€ b, Measurable (f b))\n    (hf_int : âˆ€ b, âˆ«â» a, f b a âˆ‚Î¼ â‰  âˆ) (h_directed : Directed (Â· â‰¥ Â·) f) :\n    âˆ«â» a, â¨… b, f b a âˆ‚Î¼ = â¨… b, âˆ«â» a, f b a âˆ‚Î¼ := by\n  cases nonempty_encodable Î²\n  cases isEmpty_or_nonempty Î²\n  Â· simp only [iInf_of_empty, lintegral_const,\n      ENNReal.top_mul (Measure.measure_univ_ne_zero.mpr hÎ¼)]\n  inhabit Î²\n  have : âˆ€ a, â¨… b, f b a = â¨… n, f (h_directed.sequence f n) a := by\n    refine fun a =>\n      le_antisymm (le_iInf fun n => iInf_le _ _)\n        (le_iInf fun b => iInf_le_of_le (Encodable.encode b + 1) ?_)\n    exact h_directed.sequence_le b a\n  -- Porting note: used `âˆ˜` below to deal with its reduced reducibility\n  calc\n    âˆ«â» a, â¨… b, f b a âˆ‚Î¼\n    _ = âˆ«â» a, â¨… n, (f âˆ˜ h_directed.sequence f) n a âˆ‚Î¼ := by simp only [this, Function.comp_apply]\n    _ = â¨… n, âˆ«â» a, (f âˆ˜ h_directed.sequence f) n a âˆ‚Î¼ := by\n      rw [lintegral_iInf ?_ h_directed.sequence_anti]\n      Â· exact hf_int _\n      Â· exact fun n => hf _\n    _ = â¨… b, âˆ«â» a, f b a âˆ‚Î¼ := by\n      refine le_antisymm (le_iInf fun b => ?_) (le_iInf fun n => ?_)\n      Â· exact iInf_le_of_le (Encodable.encode b + 1) (lintegral_mono <| h_directed.sequence_le b)\n      Â· exact iInf_le (fun b => âˆ«â» a, f b a âˆ‚Î¼) _\n\n"}
{"name":"MeasureTheory.lintegral_liminf_le'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Nat â†’ Î± â†’ ENNReal\nh_meas : âˆ€ (n : Nat), AEMeasurable (f n) Î¼\nâŠ¢ LE.le (MeasureTheory.lintegral Î¼ fun a => Filter.liminf (fun n => f n a) Filter.atTop) (Filter.liminf (fun n => MeasureTheory.lintegral Î¼ fun a => f n a) Filter.atTop)","decl":"/-- Known as Fatou's lemma, version with `AEMeasurable` functions -/\ntheorem lintegral_liminf_le' {f : â„• â†’ Î± â†’ â„â‰¥0âˆ} (h_meas : âˆ€ n, AEMeasurable (f n) Î¼) :\n    âˆ«â» a, liminf (fun n => f n a) atTop âˆ‚Î¼ â‰¤ liminf (fun n => âˆ«â» a, f n a âˆ‚Î¼) atTop :=\n  calc\n    âˆ«â» a, liminf (fun n => f n a) atTop âˆ‚Î¼ = âˆ«â» a, â¨† n : â„•, â¨… i â‰¥ n, f i a âˆ‚Î¼ := by\n      simp only [liminf_eq_iSup_iInf_of_nat]\n    _ = â¨† n : â„•, âˆ«â» a, â¨… i â‰¥ n, f i a âˆ‚Î¼ :=\n      (lintegral_iSup' (fun _ => .biInf _ (to_countable _) (fun i _ â†¦ h_meas i))\n        (ae_of_all Î¼ fun _ _ _ hnm => iInf_le_iInf_of_subset fun _ hi => le_trans hnm hi))\n    _ â‰¤ â¨† n : â„•, â¨… i â‰¥ n, âˆ«â» a, f i a âˆ‚Î¼ := iSup_mono fun _ => le_iInfâ‚‚_lintegral _\n    _ = atTop.liminf fun n => âˆ«â» a, f n a âˆ‚Î¼ := Filter.liminf_eq_iSup_iInf_of_nat.symm\n\n"}
{"name":"MeasureTheory.lintegral_liminf_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Nat â†’ Î± â†’ ENNReal\nh_meas : âˆ€ (n : Nat), Measurable (f n)\nâŠ¢ LE.le (MeasureTheory.lintegral Î¼ fun a => Filter.liminf (fun n => f n a) Filter.atTop) (Filter.liminf (fun n => MeasureTheory.lintegral Î¼ fun a => f n a) Filter.atTop)","decl":"/-- Known as Fatou's lemma -/\ntheorem lintegral_liminf_le {f : â„• â†’ Î± â†’ â„â‰¥0âˆ} (h_meas : âˆ€ n, Measurable (f n)) :\n    âˆ«â» a, liminf (fun n => f n a) atTop âˆ‚Î¼ â‰¤ liminf (fun n => âˆ«â» a, f n a âˆ‚Î¼) atTop :=\n  lintegral_liminf_le' fun n => (h_meas n).aemeasurable\n\n"}
{"name":"MeasureTheory.limsup_lintegral_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Nat â†’ Î± â†’ ENNReal\ng : Î± â†’ ENNReal\nhf_meas : âˆ€ (n : Nat), Measurable (f n)\nh_bound : âˆ€ (n : Nat), (MeasureTheory.ae Î¼).EventuallyLE (f n) g\nh_fin : Ne (MeasureTheory.lintegral Î¼ fun a => g a) Top.top\nâŠ¢ LE.le (Filter.limsup (fun n => MeasureTheory.lintegral Î¼ fun a => f n a) Filter.atTop) (MeasureTheory.lintegral Î¼ fun a => Filter.limsup (fun n => f n a) Filter.atTop)","decl":"theorem limsup_lintegral_le {f : â„• â†’ Î± â†’ â„â‰¥0âˆ} (g : Î± â†’ â„â‰¥0âˆ) (hf_meas : âˆ€ n, Measurable (f n))\n    (h_bound : âˆ€ n, f n â‰¤áµ[Î¼] g) (h_fin : âˆ«â» a, g a âˆ‚Î¼ â‰  âˆ) :\n    limsup (fun n => âˆ«â» a, f n a âˆ‚Î¼) atTop â‰¤ âˆ«â» a, limsup (fun n => f n a) atTop âˆ‚Î¼ :=\n  calc\n    limsup (fun n => âˆ«â» a, f n a âˆ‚Î¼) atTop = â¨… n : â„•, â¨† i â‰¥ n, âˆ«â» a, f i a âˆ‚Î¼ :=\n      limsup_eq_iInf_iSup_of_nat\n    _ â‰¤ â¨… n : â„•, âˆ«â» a, â¨† i â‰¥ n, f i a âˆ‚Î¼ := iInf_mono fun _ => iSupâ‚‚_lintegral_le _\n    _ = âˆ«â» a, â¨… n : â„•, â¨† i â‰¥ n, f i a âˆ‚Î¼ := by\n      refine (lintegral_iInf ?_ ?_ ?_).symm\n      Â· intro n\n        exact .biSup _ (to_countable _) (fun i _ â†¦ hf_meas i)\n      Â· intro n m hnm a\n        exact iSup_le_iSup_of_subset fun i hi => le_trans hnm hi\n      Â· refine ne_top_of_le_ne_top h_fin (lintegral_mono_ae ?_)\n        refine (ae_all_iff.2 h_bound).mono fun n hn => ?_\n        exact iSup_le fun i => iSup_le fun _ => hn i\n    _ = âˆ«â» a, limsup (fun n => f n a) atTop âˆ‚Î¼ := by simp only [limsup_eq_iInf_iSup_of_nat]\n\n"}
{"name":"MeasureTheory.tendsto_lintegral_of_dominated_convergence","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nF : Nat â†’ Î± â†’ ENNReal\nf bound : Î± â†’ ENNReal\nhF_meas : âˆ€ (n : Nat), Measurable (F n)\nh_bound : âˆ€ (n : Nat), (MeasureTheory.ae Î¼).EventuallyLE (F n) bound\nh_fin : Ne (MeasureTheory.lintegral Î¼ fun a => bound a) Top.top\nh_lim : Filter.Eventually (fun a => Filter.Tendsto (fun n => F n a) Filter.atTop (nhds (f a))) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Tendsto (fun n => MeasureTheory.lintegral Î¼ fun a => F n a) Filter.atTop (nhds (MeasureTheory.lintegral Î¼ fun a => f a))","decl":"/-- Dominated convergence theorem for nonnegative functions -/\ntheorem tendsto_lintegral_of_dominated_convergence {F : â„• â†’ Î± â†’ â„â‰¥0âˆ} {f : Î± â†’ â„â‰¥0âˆ}\n    (bound : Î± â†’ â„â‰¥0âˆ) (hF_meas : âˆ€ n, Measurable (F n)) (h_bound : âˆ€ n, F n â‰¤áµ[Î¼] bound)\n    (h_fin : âˆ«â» a, bound a âˆ‚Î¼ â‰  âˆ) (h_lim : âˆ€áµ a âˆ‚Î¼, Tendsto (fun n => F n a) atTop (ğ“ (f a))) :\n    Tendsto (fun n => âˆ«â» a, F n a âˆ‚Î¼) atTop (ğ“ (âˆ«â» a, f a âˆ‚Î¼)) :=\n  tendsto_of_le_liminf_of_limsup_le\n    (calc\n      âˆ«â» a, f a âˆ‚Î¼ = âˆ«â» a, liminf (fun n : â„• => F n a) atTop âˆ‚Î¼ :=\n        lintegral_congr_ae <| h_lim.mono fun _ h => h.liminf_eq.symm\n      _ â‰¤ liminf (fun n => âˆ«â» a, F n a âˆ‚Î¼) atTop := lintegral_liminf_le hF_meas\n      )\n    (calc\n      limsup (fun n : â„• => âˆ«â» a, F n a âˆ‚Î¼) atTop â‰¤ âˆ«â» a, limsup (fun n => F n a) atTop âˆ‚Î¼ :=\n        limsup_lintegral_le _ hF_meas h_bound h_fin\n      _ = âˆ«â» a, f a âˆ‚Î¼ := lintegral_congr_ae <| h_lim.mono fun _ h => h.limsup_eq\n      )\n\n"}
{"name":"MeasureTheory.tendsto_lintegral_of_dominated_convergence'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nF : Nat â†’ Î± â†’ ENNReal\nf bound : Î± â†’ ENNReal\nhF_meas : âˆ€ (n : Nat), AEMeasurable (F n) Î¼\nh_bound : âˆ€ (n : Nat), (MeasureTheory.ae Î¼).EventuallyLE (F n) bound\nh_fin : Ne (MeasureTheory.lintegral Î¼ fun a => bound a) Top.top\nh_lim : Filter.Eventually (fun a => Filter.Tendsto (fun n => F n a) Filter.atTop (nhds (f a))) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Tendsto (fun n => MeasureTheory.lintegral Î¼ fun a => F n a) Filter.atTop (nhds (MeasureTheory.lintegral Î¼ fun a => f a))","decl":"/-- Dominated convergence theorem for nonnegative functions which are just almost everywhere\nmeasurable. -/\ntheorem tendsto_lintegral_of_dominated_convergence' {F : â„• â†’ Î± â†’ â„â‰¥0âˆ} {f : Î± â†’ â„â‰¥0âˆ}\n    (bound : Î± â†’ â„â‰¥0âˆ) (hF_meas : âˆ€ n, AEMeasurable (F n) Î¼) (h_bound : âˆ€ n, F n â‰¤áµ[Î¼] bound)\n    (h_fin : âˆ«â» a, bound a âˆ‚Î¼ â‰  âˆ) (h_lim : âˆ€áµ a âˆ‚Î¼, Tendsto (fun n => F n a) atTop (ğ“ (f a))) :\n    Tendsto (fun n => âˆ«â» a, F n a âˆ‚Î¼) atTop (ğ“ (âˆ«â» a, f a âˆ‚Î¼)) := by\n  have : âˆ€ n, âˆ«â» a, F n a âˆ‚Î¼ = âˆ«â» a, (hF_meas n).mk (F n) a âˆ‚Î¼ := fun n =>\n    lintegral_congr_ae (hF_meas n).ae_eq_mk\n  simp_rw [this]\n  apply\n    tendsto_lintegral_of_dominated_convergence bound (fun n => (hF_meas n).measurable_mk) _ h_fin\n  Â· have : âˆ€ n, âˆ€áµ a âˆ‚Î¼, (hF_meas n).mk (F n) a = F n a := fun n => (hF_meas n).ae_eq_mk.symm\n    have : âˆ€áµ a âˆ‚Î¼, âˆ€ n, (hF_meas n).mk (F n) a = F n a := ae_all_iff.mpr this\n    filter_upwards [this, h_lim] with a H H'\n    simp_rw [H]\n    exact H'\n  Â· intro n\n    filter_upwards [h_bound n, (hF_meas n).ae_eq_mk] with a H H'\n    rwa [H'] at H\n\n"}
{"name":"MeasureTheory.tendsto_lintegral_filter_of_dominated_convergence","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ¹ : Type u_5\nl : Filter Î¹\ninstâœ : l.IsCountablyGenerated\nF : Î¹ â†’ Î± â†’ ENNReal\nf bound : Î± â†’ ENNReal\nhF_meas : Filter.Eventually (fun n => Measurable (F n)) l\nh_bound : Filter.Eventually (fun n => Filter.Eventually (fun a => LE.le (F n a) (bound a)) (MeasureTheory.ae Î¼)) l\nh_fin : Ne (MeasureTheory.lintegral Î¼ fun a => bound a) Top.top\nh_lim : Filter.Eventually (fun a => Filter.Tendsto (fun n => F n a) l (nhds (f a))) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Tendsto (fun n => MeasureTheory.lintegral Î¼ fun a => F n a) l (nhds (MeasureTheory.lintegral Î¼ fun a => f a))","decl":"/-- Dominated convergence theorem for filters with a countable basis -/\ntheorem tendsto_lintegral_filter_of_dominated_convergence {Î¹} {l : Filter Î¹}\n    [l.IsCountablyGenerated] {F : Î¹ â†’ Î± â†’ â„â‰¥0âˆ} {f : Î± â†’ â„â‰¥0âˆ} (bound : Î± â†’ â„â‰¥0âˆ)\n    (hF_meas : âˆ€á¶  n in l, Measurable (F n)) (h_bound : âˆ€á¶  n in l, âˆ€áµ a âˆ‚Î¼, F n a â‰¤ bound a)\n    (h_fin : âˆ«â» a, bound a âˆ‚Î¼ â‰  âˆ) (h_lim : âˆ€áµ a âˆ‚Î¼, Tendsto (fun n => F n a) l (ğ“ (f a))) :\n    Tendsto (fun n => âˆ«â» a, F n a âˆ‚Î¼) l (ğ“ <| âˆ«â» a, f a âˆ‚Î¼) := by\n  rw [tendsto_iff_seq_tendsto]\n  intro x xl\n  have hxl := by\n    rw [tendsto_atTop'] at xl\n    exact xl\n  have h := inter_mem hF_meas h_bound\n  replace h := hxl _ h\n  rcases h with âŸ¨k, hâŸ©\n  rw [â† tendsto_add_atTop_iff_nat k]\n  refine tendsto_lintegral_of_dominated_convergence ?_ ?_ ?_ ?_ ?_\n  Â· exact bound\n  Â· intro\n    refine (h _ ?_).1\n    exact Nat.le_add_left _ _\n  Â· intro\n    refine (h _ ?_).2\n    exact Nat.le_add_left _ _\n  Â· assumption\n  Â· refine h_lim.mono fun a h_lim => ?_\n    apply @Tendsto.comp _ _ _ (fun n => x (n + k)) fun n => F n a\n    Â· assumption\n    rw [tendsto_add_atTop_iff_nat]\n    assumption\n\n"}
{"name":"MeasureTheory.lintegral_tendsto_of_tendsto_of_antitone","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Nat â†’ Î± â†’ ENNReal\nF : Î± â†’ ENNReal\nhf : âˆ€ (n : Nat), AEMeasurable (f n) Î¼\nh_anti : Filter.Eventually (fun x => Antitone fun n => f n x) (MeasureTheory.ae Î¼)\nh0 : Ne (MeasureTheory.lintegral Î¼ fun a => f 0 a) Top.top\nh_tendsto : Filter.Eventually (fun x => Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Tendsto (fun n => MeasureTheory.lintegral Î¼ fun x => f n x) Filter.atTop (nhds (MeasureTheory.lintegral Î¼ fun x => F x))","decl":"theorem lintegral_tendsto_of_tendsto_of_antitone {f : â„• â†’ Î± â†’ â„â‰¥0âˆ} {F : Î± â†’ â„â‰¥0âˆ}\n    (hf : âˆ€ n, AEMeasurable (f n) Î¼) (h_anti : âˆ€áµ x âˆ‚Î¼, Antitone fun n â†¦ f n x)\n    (h0 : âˆ«â» a, f 0 a âˆ‚Î¼ â‰  âˆ)\n    (h_tendsto : âˆ€áµ x âˆ‚Î¼, Tendsto (fun n â†¦ f n x) atTop (ğ“ (F x))) :\n    Tendsto (fun n â†¦ âˆ«â» x, f n x âˆ‚Î¼) atTop (ğ“ (âˆ«â» x, F x âˆ‚Î¼)) := by\n  have : Antitone fun n â†¦ âˆ«â» x, f n x âˆ‚Î¼ := fun i j hij â†¦\n    lintegral_mono_ae (h_anti.mono fun x hx â†¦ hx hij)\n  suffices key : âˆ«â» x, F x âˆ‚Î¼ = â¨… n, âˆ«â» x, f n x âˆ‚Î¼ by\n    rw [key]\n    exact tendsto_atTop_iInf this\n  rw [â† lintegral_iInf' hf h_anti h0]\n  refine lintegral_congr_ae ?_\n  filter_upwards [h_anti, h_tendsto] with _ hx_anti hx_tendsto\n    using tendsto_nhds_unique hx_tendsto (tendsto_atTop_iInf hx_anti)\n\n"}
{"name":"MeasureTheory.lintegral_iSup_directed_of_measurable","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : Countable Î²\nf : Î² â†’ Î± â†’ ENNReal\nhf : âˆ€ (b : Î²), Measurable (f b)\nh_directed : Directed (fun x1 x2 => LE.le x1 x2) f\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => iSup fun b => f b a) (iSup fun b => MeasureTheory.lintegral Î¼ fun a => f b a)","decl":"/-- Monotone convergence for a supremum over a directed family and indexed by a countable type -/\ntheorem lintegral_iSup_directed_of_measurable [Countable Î²] {f : Î² â†’ Î± â†’ â„â‰¥0âˆ}\n    (hf : âˆ€ b, Measurable (f b)) (h_directed : Directed (Â· â‰¤ Â·) f) :\n    âˆ«â» a, â¨† b, f b a âˆ‚Î¼ = â¨† b, âˆ«â» a, f b a âˆ‚Î¼ := by\n  cases nonempty_encodable Î²\n  cases isEmpty_or_nonempty Î²\n  Â· simp [iSup_of_empty]\n  inhabit Î²\n  have : âˆ€ a, â¨† b, f b a = â¨† n, f (h_directed.sequence f n) a := by\n    intro a\n    refine le_antisymm (iSup_le fun b => ?_) (iSup_le fun n => le_iSup (fun n => f n a) _)\n    exact le_iSup_of_le (encode b + 1) (h_directed.le_sequence b a)\n  calc\n    âˆ«â» a, â¨† b, f b a âˆ‚Î¼ = âˆ«â» a, â¨† n, f (h_directed.sequence f n) a âˆ‚Î¼ := by simp only [this]\n    _ = â¨† n, âˆ«â» a, f (h_directed.sequence f n) a âˆ‚Î¼ :=\n      (lintegral_iSup (fun n => hf _) h_directed.sequence_mono)\n    _ = â¨† b, âˆ«â» a, f b a âˆ‚Î¼ := by\n      refine le_antisymm (iSup_le fun n => ?_) (iSup_le fun b => ?_)\n      Â· exact le_iSup (fun b => âˆ«â» a, f b a âˆ‚Î¼) _\n      Â· exact le_iSup_of_le (encode b + 1) (lintegral_mono <| h_directed.le_sequence b)\n\n"}
{"name":"MeasureTheory.lintegral_iSup_directed","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : Countable Î²\nf : Î² â†’ Î± â†’ ENNReal\nhf : âˆ€ (b : Î²), AEMeasurable (f b) Î¼\nh_directed : Directed (fun x1 x2 => LE.le x1 x2) f\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => iSup fun b => f b a) (iSup fun b => MeasureTheory.lintegral Î¼ fun a => f b a)","decl":"/-- Monotone convergence for a supremum over a directed family and indexed by a countable type. -/\ntheorem lintegral_iSup_directed [Countable Î²] {f : Î² â†’ Î± â†’ â„â‰¥0âˆ} (hf : âˆ€ b, AEMeasurable (f b) Î¼)\n    (h_directed : Directed (Â· â‰¤ Â·) f) : âˆ«â» a, â¨† b, f b a âˆ‚Î¼ = â¨† b, âˆ«â» a, f b a âˆ‚Î¼ := by\n  simp_rw [â† iSup_apply]\n  let p : Î± â†’ (Î² â†’ ENNReal) â†’ Prop := fun x f' => Directed LE.le f'\n  have hp : âˆ€áµ x âˆ‚Î¼, p x fun i => f i x := by\n    filter_upwards [] with x i j\n    obtain âŸ¨z, hzâ‚, hzâ‚‚âŸ© := h_directed i j\n    exact âŸ¨z, hzâ‚ x, hzâ‚‚ xâŸ©\n  have h_ae_seq_directed : Directed LE.le (aeSeq hf p) := by\n    intro bâ‚ bâ‚‚\n    obtain âŸ¨z, hzâ‚, hzâ‚‚âŸ© := h_directed bâ‚ bâ‚‚\n    refine âŸ¨z, ?_, ?_âŸ© <;>\n      Â· intro x\n        by_cases hx : x âˆˆ aeSeqSet hf p\n        Â· repeat rw [aeSeq.aeSeq_eq_fun_of_mem_aeSeqSet hf hx]\n          apply_rules [hzâ‚, hzâ‚‚]\n        Â· simp only [aeSeq, hx, if_false]\n          exact le_rfl\n  convert lintegral_iSup_directed_of_measurable (aeSeq.measurable hf p) h_ae_seq_directed using 1\n  Â· simp_rw [â† iSup_apply]\n    rw [lintegral_congr_ae (aeSeq.iSup hf hp).symm]\n  Â· congr 1\n    ext1 b\n    rw [lintegral_congr_ae]\n    apply EventuallyEq.symm\n    exact aeSeq.aeSeq_n_eq_fun_n_ae hf hp _\n\n"}
{"name":"MeasureTheory.lintegral_tsum","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : Countable Î²\nf : Î² â†’ Î± â†’ ENNReal\nhf : âˆ€ (i : Î²), AEMeasurable (f i) Î¼\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => tsum fun i => f i a) (tsum fun i => MeasureTheory.lintegral Î¼ fun a => f i a)","decl":"theorem lintegral_tsum [Countable Î²] {f : Î² â†’ Î± â†’ â„â‰¥0âˆ} (hf : âˆ€ i, AEMeasurable (f i) Î¼) :\n    âˆ«â» a, âˆ‘' i, f i a âˆ‚Î¼ = âˆ‘' i, âˆ«â» a, f i a âˆ‚Î¼ := by\n  classical\n  simp only [ENNReal.tsum_eq_iSup_sum]\n  rw [lintegral_iSup_directed]\n  Â· simp [lintegral_finset_sum' _ fun i _ => hf i]\n  Â· intro b\n    exact Finset.aemeasurable_sum _ fun i _ => hf i\n  Â· intro s t\n    use s âˆª t\n    constructor\n    Â· exact fun a => Finset.sum_le_sum_of_subset Finset.subset_union_left\n    Â· exact fun a => Finset.sum_le_sum_of_subset Finset.subset_union_right\n\n"}
{"name":"MeasureTheory.lintegral_iUnionâ‚€","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : Countable Î²\ns : Î² â†’ Set Î±\nhm : âˆ€ (i : Î²), MeasureTheory.NullMeasurableSet (s i) Î¼\nhd : Pairwise (Function.onFun (MeasureTheory.AEDisjoint Î¼) s)\nf : Î± â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict (Set.iUnion fun i => s i)) fun a => f a) (tsum fun i => MeasureTheory.lintegral (Î¼.restrict (s i)) fun a => f a)","decl":"theorem lintegral_iUnionâ‚€ [Countable Î²] {s : Î² â†’ Set Î±} (hm : âˆ€ i, NullMeasurableSet (s i) Î¼)\n    (hd : Pairwise (AEDisjoint Î¼ on s)) (f : Î± â†’ â„â‰¥0âˆ) :\n    âˆ«â» a in â‹ƒ i, s i, f a âˆ‚Î¼ = âˆ‘' i, âˆ«â» a in s i, f a âˆ‚Î¼ := by\n  simp only [Measure.restrict_iUnion_ae hd hm, lintegral_sum_measure]\n\n"}
{"name":"MeasureTheory.lintegral_iUnion","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : Countable Î²\ns : Î² â†’ Set Î±\nhm : âˆ€ (i : Î²), MeasurableSet (s i)\nhd : Pairwise (Function.onFun Disjoint s)\nf : Î± â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict (Set.iUnion fun i => s i)) fun a => f a) (tsum fun i => MeasureTheory.lintegral (Î¼.restrict (s i)) fun a => f a)","decl":"theorem lintegral_iUnion [Countable Î²] {s : Î² â†’ Set Î±} (hm : âˆ€ i, MeasurableSet (s i))\n    (hd : Pairwise (Disjoint on s)) (f : Î± â†’ â„â‰¥0âˆ) :\n    âˆ«â» a in â‹ƒ i, s i, f a âˆ‚Î¼ = âˆ‘' i, âˆ«â» a in s i, f a âˆ‚Î¼ :=\n  lintegral_iUnionâ‚€ (fun i => (hm i).nullMeasurableSet) hd.aedisjoint f\n\n"}
{"name":"MeasureTheory.lintegral_biUnionâ‚€","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nt : Set Î²\ns : Î² â†’ Set Î±\nht : t.Countable\nhm : âˆ€ (i : Î²), Membership.mem t i â†’ MeasureTheory.NullMeasurableSet (s i) Î¼\nhd : t.Pairwise (Function.onFun (MeasureTheory.AEDisjoint Î¼) s)\nf : Î± â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict (Set.iUnion fun i => Set.iUnion fun h => s i)) fun a => f a) (tsum fun i => MeasureTheory.lintegral (Î¼.restrict (s â†‘i)) fun a => f a)","decl":"theorem lintegral_biUnionâ‚€ {t : Set Î²} {s : Î² â†’ Set Î±} (ht : t.Countable)\n    (hm : âˆ€ i âˆˆ t, NullMeasurableSet (s i) Î¼) (hd : t.Pairwise (AEDisjoint Î¼ on s)) (f : Î± â†’ â„â‰¥0âˆ) :\n    âˆ«â» a in â‹ƒ i âˆˆ t, s i, f a âˆ‚Î¼ = âˆ‘' i : t, âˆ«â» a in s i, f a âˆ‚Î¼ := by\n  haveI := ht.toEncodable\n  rw [biUnion_eq_iUnion, lintegral_iUnionâ‚€ (SetCoe.forall'.1 hm) (hd.subtype _ _)]\n\n"}
{"name":"MeasureTheory.lintegral_biUnion","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nt : Set Î²\ns : Î² â†’ Set Î±\nht : t.Countable\nhm : âˆ€ (i : Î²), Membership.mem t i â†’ MeasurableSet (s i)\nhd : t.PairwiseDisjoint s\nf : Î± â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict (Set.iUnion fun i => Set.iUnion fun h => s i)) fun a => f a) (tsum fun i => MeasureTheory.lintegral (Î¼.restrict (s â†‘i)) fun a => f a)","decl":"theorem lintegral_biUnion {t : Set Î²} {s : Î² â†’ Set Î±} (ht : t.Countable)\n    (hm : âˆ€ i âˆˆ t, MeasurableSet (s i)) (hd : t.PairwiseDisjoint s) (f : Î± â†’ â„â‰¥0âˆ) :\n    âˆ«â» a in â‹ƒ i âˆˆ t, s i, f a âˆ‚Î¼ = âˆ‘' i : t, âˆ«â» a in s i, f a âˆ‚Î¼ :=\n  lintegral_biUnionâ‚€ ht (fun i hi => (hm i hi).nullMeasurableSet) hd.aedisjoint f\n\n"}
{"name":"MeasureTheory.lintegral_biUnion_finsetâ‚€","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Finset Î²\nt : Î² â†’ Set Î±\nhd : (â†‘s).Pairwise (Function.onFun (MeasureTheory.AEDisjoint Î¼) t)\nhm : âˆ€ (b : Î²), Membership.mem s b â†’ MeasureTheory.NullMeasurableSet (t b) Î¼\nf : Î± â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict (Set.iUnion fun b => Set.iUnion fun h => t b)) fun a => f a) (s.sum fun b => MeasureTheory.lintegral (Î¼.restrict (t b)) fun a => f a)","decl":"theorem lintegral_biUnion_finsetâ‚€ {s : Finset Î²} {t : Î² â†’ Set Î±}\n    (hd : Set.Pairwise (â†‘s) (AEDisjoint Î¼ on t)) (hm : âˆ€ b âˆˆ s, NullMeasurableSet (t b) Î¼)\n    (f : Î± â†’ â„â‰¥0âˆ) : âˆ«â» a in â‹ƒ b âˆˆ s, t b, f a âˆ‚Î¼ = âˆ‘ b âˆˆ s, âˆ«â» a in t b, f a âˆ‚Î¼ := by\n  simp only [â† Finset.mem_coe, lintegral_biUnionâ‚€ s.countable_toSet hm hd, â† Finset.tsum_subtype']\n\n"}
{"name":"MeasureTheory.lintegral_biUnion_finset","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Finset Î²\nt : Î² â†’ Set Î±\nhd : (â†‘s).PairwiseDisjoint t\nhm : âˆ€ (b : Î²), Membership.mem s b â†’ MeasurableSet (t b)\nf : Î± â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict (Set.iUnion fun b => Set.iUnion fun h => t b)) fun a => f a) (s.sum fun b => MeasureTheory.lintegral (Î¼.restrict (t b)) fun a => f a)","decl":"theorem lintegral_biUnion_finset {s : Finset Î²} {t : Î² â†’ Set Î±} (hd : Set.PairwiseDisjoint (â†‘s) t)\n    (hm : âˆ€ b âˆˆ s, MeasurableSet (t b)) (f : Î± â†’ â„â‰¥0âˆ) :\n    âˆ«â» a in â‹ƒ b âˆˆ s, t b, f a âˆ‚Î¼ = âˆ‘ b âˆˆ s, âˆ«â» a in t b, f a âˆ‚Î¼ :=\n  lintegral_biUnion_finsetâ‚€ hd.aedisjoint (fun b hb => (hm b hb).nullMeasurableSet) f\n\n"}
{"name":"MeasureTheory.lintegral_iUnion_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : Countable Î²\ns : Î² â†’ Set Î±\nf : Î± â†’ ENNReal\nâŠ¢ LE.le (MeasureTheory.lintegral (Î¼.restrict (Set.iUnion fun i => s i)) fun a => f a) (tsum fun i => MeasureTheory.lintegral (Î¼.restrict (s i)) fun a => f a)","decl":"theorem lintegral_iUnion_le [Countable Î²] (s : Î² â†’ Set Î±) (f : Î± â†’ â„â‰¥0âˆ) :\n    âˆ«â» a in â‹ƒ i, s i, f a âˆ‚Î¼ â‰¤ âˆ‘' i, âˆ«â» a in s i, f a âˆ‚Î¼ := by\n  rw [â† lintegral_sum_measure]\n  exact lintegral_mono' restrict_iUnion_le le_rfl\n\n"}
{"name":"MeasureTheory.lintegral_union","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nA B : Set Î±\nhB : MeasurableSet B\nhAB : Disjoint A B\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict (Union.union A B)) fun a => f a) (HAdd.hAdd (MeasureTheory.lintegral (Î¼.restrict A) fun a => f a) (MeasureTheory.lintegral (Î¼.restrict B) fun a => f a))","decl":"theorem lintegral_union {f : Î± â†’ â„â‰¥0âˆ} {A B : Set Î±} (hB : MeasurableSet B) (hAB : Disjoint A B) :\n    âˆ«â» a in A âˆª B, f a âˆ‚Î¼ = âˆ«â» a in A, f a âˆ‚Î¼ + âˆ«â» a in B, f a âˆ‚Î¼ := by\n  rw [restrict_union hAB hB, lintegral_add_measure]\n\n"}
{"name":"MeasureTheory.lintegral_union_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\ns t : Set Î±\nâŠ¢ LE.le (MeasureTheory.lintegral (Î¼.restrict (Union.union s t)) fun a => f a) (HAdd.hAdd (MeasureTheory.lintegral (Î¼.restrict s) fun a => f a) (MeasureTheory.lintegral (Î¼.restrict t) fun a => f a))","decl":"theorem lintegral_union_le (f : Î± â†’ â„â‰¥0âˆ) (s t : Set Î±) :\n    âˆ«â» a in s âˆª t, f a âˆ‚Î¼ â‰¤ âˆ«â» a in s, f a âˆ‚Î¼ + âˆ«â» a in t, f a âˆ‚Î¼ := by\n  rw [â† lintegral_add_measure]\n  exact lintegral_mono' (restrict_union_le _ _) le_rfl\n\n"}
{"name":"MeasureTheory.lintegral_inter_add_diff","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nB : Set Î±\nf : Î± â†’ ENNReal\nA : Set Î±\nhB : MeasurableSet B\nâŠ¢ Eq (HAdd.hAdd (MeasureTheory.lintegral (Î¼.restrict (Inter.inter A B)) fun x => f x) (MeasureTheory.lintegral (Î¼.restrict (SDiff.sdiff A B)) fun x => f x)) (MeasureTheory.lintegral (Î¼.restrict A) fun x => f x)","decl":"theorem lintegral_inter_add_diff {B : Set Î±} (f : Î± â†’ â„â‰¥0âˆ) (A : Set Î±) (hB : MeasurableSet B) :\n    âˆ«â» x in A âˆ© B, f x âˆ‚Î¼ + âˆ«â» x in A \\ B, f x âˆ‚Î¼ = âˆ«â» x in A, f x âˆ‚Î¼ := by\n  rw [â† lintegral_add_measure, restrict_inter_add_diff _ hB]\n\n"}
{"name":"MeasureTheory.lintegral_add_compl","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nA : Set Î±\nhA : MeasurableSet A\nâŠ¢ Eq (HAdd.hAdd (MeasureTheory.lintegral (Î¼.restrict A) fun x => f x) (MeasureTheory.lintegral (Î¼.restrict (HasCompl.compl A)) fun x => f x)) (MeasureTheory.lintegral Î¼ fun x => f x)","decl":"theorem lintegral_add_compl (f : Î± â†’ â„â‰¥0âˆ) {A : Set Î±} (hA : MeasurableSet A) :\n    âˆ«â» x in A, f x âˆ‚Î¼ + âˆ«â» x in Aá¶œ, f x âˆ‚Î¼ = âˆ«â» x, f x âˆ‚Î¼ := by\n  rw [â† lintegral_add_measure, Measure.restrict_add_restrict_compl hA]\n\n"}
{"name":"MeasureTheory.setLintegral_compl","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\ns : Set Î±\nhsm : MeasurableSet s\nhfs : Ne (MeasureTheory.lintegral (Î¼.restrict s) fun x => f x) Top.top\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict (HasCompl.compl s)) fun x => f x) (HSub.hSub (MeasureTheory.lintegral Î¼ fun x => f x) (MeasureTheory.lintegral (Î¼.restrict s) fun x => f x))","decl":"theorem setLintegral_compl {f : Î± â†’ â„â‰¥0âˆ} {s : Set Î±} (hsm : MeasurableSet s)\n    (hfs : âˆ«â» x in s, f x âˆ‚Î¼ â‰  âˆ) :\n    âˆ«â» x in sá¶œ, f x âˆ‚Î¼ = âˆ«â» x, f x âˆ‚Î¼ - âˆ«â» x in s, f x âˆ‚Î¼ := by\n  rw [â† lintegral_add_compl (Î¼ := Î¼) f hsm, ENNReal.add_sub_cancel_left hfs]\n\n"}
{"name":"MeasureTheory.setLIntegral_iUnion_of_directed","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ¹ : Type u_5\ninstâœ : Countable Î¹\nf : Î± â†’ ENNReal\ns : Î¹ â†’ Set Î±\nhd : Directed (fun x1 x2 => HasSubset.Subset x1 x2) s\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict (Set.iUnion fun i => s i)) fun x => f x) (iSup fun i => MeasureTheory.lintegral (Î¼.restrict (s i)) fun x => f x)","decl":"theorem setLIntegral_iUnion_of_directed {Î¹ : Type*} [Countable Î¹]\n    (f : Î± â†’ â„â‰¥0âˆ) {s : Î¹ â†’ Set Î±} (hd : Directed (Â· âŠ† Â·) s) :\n    âˆ«â» x in â‹ƒ i, s i, f x âˆ‚Î¼ = â¨† i, âˆ«â» x in s i, f x âˆ‚Î¼ := by\n  simp only [lintegral_def, iSup_comm (Î¹ := Î¹),\n    SimpleFunc.lintegral_restrict_iUnion_of_directed _ hd]\n\n"}
{"name":"MeasureTheory.lintegral_max","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ ENNReal\nhf : Measurable f\nhg : Measurable g\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun x => Max.max (f x) (g x)) (HAdd.hAdd (MeasureTheory.lintegral (Î¼.restrict (setOf fun x => LE.le (f x) (g x))) fun x => g x) (MeasureTheory.lintegral (Î¼.restrict (setOf fun x => LT.lt (g x) (f x))) fun x => f x))","decl":"theorem lintegral_max {f g : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) (hg : Measurable g) :\n    âˆ«â» x, max (f x) (g x) âˆ‚Î¼ =\n      âˆ«â» x in { x | f x â‰¤ g x }, g x âˆ‚Î¼ + âˆ«â» x in { x | g x < f x }, f x âˆ‚Î¼ := by\n  have hm : MeasurableSet { x | f x â‰¤ g x } := measurableSet_le hf hg\n  rw [â† lintegral_add_compl (fun x => max (f x) (g x)) hm]\n  simp only [â† compl_setOf, â† not_le]\n  refine congr_argâ‚‚ (Â· + Â·) (setLIntegral_congr_fun hm ?_) (setLIntegral_congr_fun hm.compl ?_)\n  exacts [ae_of_all _ fun x => max_eq_right (a := f x) (b := g x),\n    ae_of_all _ fun x (hx : Â¬ f x â‰¤ g x) => max_eq_left (not_le.1 hx).le]\n\n"}
{"name":"MeasureTheory.setLIntegral_max","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ ENNReal\nhf : Measurable f\nhg : Measurable g\ns : Set Î±\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict s) fun x => Max.max (f x) (g x)) (HAdd.hAdd (MeasureTheory.lintegral (Î¼.restrict (Inter.inter s (setOf fun x => LE.le (f x) (g x)))) fun x => g x) (MeasureTheory.lintegral (Î¼.restrict (Inter.inter s (setOf fun x => LT.lt (g x) (f x)))) fun x => f x))","decl":"theorem setLIntegral_max {f g : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) (hg : Measurable g) (s : Set Î±) :\n    âˆ«â» x in s, max (f x) (g x) âˆ‚Î¼ =\n      âˆ«â» x in s âˆ© { x | f x â‰¤ g x }, g x âˆ‚Î¼ + âˆ«â» x in s âˆ© { x | g x < f x }, f x âˆ‚Î¼ := by\n  rw [lintegral_max hf hg, restrict_restrict, restrict_restrict, inter_comm s, inter_comm s]\n  exacts [measurableSet_lt hg hf, measurableSet_le hf hg]\n\n"}
{"name":"MeasureTheory.lintegral_map","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nmÎ² : MeasurableSpace Î²\nf : Î² â†’ ENNReal\ng : Î± â†’ Î²\nhf : Measurable f\nhg : Measurable g\nâŠ¢ Eq (MeasureTheory.lintegral (MeasureTheory.Measure.map g Î¼) fun a => f a) (MeasureTheory.lintegral Î¼ fun a => f (g a))","decl":"theorem lintegral_map {mÎ² : MeasurableSpace Î²} {f : Î² â†’ â„â‰¥0âˆ} {g : Î± â†’ Î²} (hf : Measurable f)\n    (hg : Measurable g) : âˆ«â» a, f a âˆ‚map g Î¼ = âˆ«â» a, f (g a) âˆ‚Î¼ := by\n  erw [lintegral_eq_iSup_eapprox_lintegral hf, lintegral_eq_iSup_eapprox_lintegral (hf.comp hg)]\n  congr with n : 1\n  convert SimpleFunc.lintegral_map _ hg\n  ext1 x; simp only [eapprox_comp hf hg, coe_comp]\n\n"}
{"name":"MeasureTheory.lintegral_map'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nmÎ² : MeasurableSpace Î²\nf : Î² â†’ ENNReal\ng : Î± â†’ Î²\nhf : AEMeasurable f (MeasureTheory.Measure.map g Î¼)\nhg : AEMeasurable g Î¼\nâŠ¢ Eq (MeasureTheory.lintegral (MeasureTheory.Measure.map g Î¼) fun a => f a) (MeasureTheory.lintegral Î¼ fun a => f (g a))","decl":"theorem lintegral_map' {mÎ² : MeasurableSpace Î²} {f : Î² â†’ â„â‰¥0âˆ} {g : Î± â†’ Î²}\n    (hf : AEMeasurable f (Measure.map g Î¼)) (hg : AEMeasurable g Î¼) :\n    âˆ«â» a, f a âˆ‚Measure.map g Î¼ = âˆ«â» a, f (g a) âˆ‚Î¼ :=\n  calc\n    âˆ«â» a, f a âˆ‚Measure.map g Î¼ = âˆ«â» a, hf.mk f a âˆ‚Measure.map g Î¼ :=\n      lintegral_congr_ae hf.ae_eq_mk\n    _ = âˆ«â» a, hf.mk f a âˆ‚Measure.map (hg.mk g) Î¼ := by\n      congr 1\n      exact Measure.map_congr hg.ae_eq_mk\n    _ = âˆ«â» a, hf.mk f (hg.mk g a) âˆ‚Î¼ := lintegral_map hf.measurable_mk hg.measurable_mk\n    _ = âˆ«â» a, hf.mk f (g a) âˆ‚Î¼ := lintegral_congr_ae <| hg.ae_eq_mk.symm.fun_comp _\n    _ = âˆ«â» a, f (g a) âˆ‚Î¼ := lintegral_congr_ae (ae_eq_comp hg hf.ae_eq_mk.symm)\n\n"}
{"name":"MeasureTheory.lintegral_map_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nmÎ² : MeasurableSpace Î²\nf : Î² â†’ ENNReal\ng : Î± â†’ Î²\nhg : Measurable g\nâŠ¢ LE.le (MeasureTheory.lintegral (MeasureTheory.Measure.map g Î¼) fun a => f a) (MeasureTheory.lintegral Î¼ fun a => f (g a))","decl":"theorem lintegral_map_le {mÎ² : MeasurableSpace Î²} (f : Î² â†’ â„â‰¥0âˆ) {g : Î± â†’ Î²} (hg : Measurable g) :\n    âˆ«â» a, f a âˆ‚Measure.map g Î¼ â‰¤ âˆ«â» a, f (g a) âˆ‚Î¼ := by\n  rw [â† iSup_lintegral_measurable_le_eq_lintegral, â† iSup_lintegral_measurable_le_eq_lintegral]\n  refine iSupâ‚‚_le fun i hi => iSup_le fun h'i => ?_\n  refine le_iSupâ‚‚_of_le (i âˆ˜ g) (hi.comp hg) ?_\n  exact le_iSup_of_le (fun x => h'i (g x)) (le_of_eq (lintegral_map hi hg))\n\n"}
{"name":"MeasureTheory.lintegral_comp","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasurableSpace Î²\nf : Î² â†’ ENNReal\ng : Î± â†’ Î²\nhf : Measurable f\nhg : Measurable g\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ (Function.comp f g)) (MeasureTheory.lintegral (MeasureTheory.Measure.map g Î¼) fun a => f a)","decl":"theorem lintegral_comp [MeasurableSpace Î²] {f : Î² â†’ â„â‰¥0âˆ} {g : Î± â†’ Î²} (hf : Measurable f)\n    (hg : Measurable g) : lintegral Î¼ (f âˆ˜ g) = âˆ«â» a, f a âˆ‚map g Î¼ :=\n  (lintegral_map hf hg).symm\n\n"}
{"name":"MeasureTheory.setLIntegral_map","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasurableSpace Î²\nf : Î² â†’ ENNReal\ng : Î± â†’ Î²\ns : Set Î²\nhs : MeasurableSet s\nhf : Measurable f\nhg : Measurable g\nâŠ¢ Eq (MeasureTheory.lintegral ((MeasureTheory.Measure.map g Î¼).restrict s) fun y => f y) (MeasureTheory.lintegral (Î¼.restrict (Set.preimage g s)) fun x => f (g x))","decl":"theorem setLIntegral_map [MeasurableSpace Î²] {f : Î² â†’ â„â‰¥0âˆ} {g : Î± â†’ Î²} {s : Set Î²}\n    (hs : MeasurableSet s) (hf : Measurable f) (hg : Measurable g) :\n    âˆ«â» y in s, f y âˆ‚map g Î¼ = âˆ«â» x in g â»Â¹' s, f (g x) âˆ‚Î¼ := by\n  rw [restrict_map hg hs, lintegral_map hf hg]\n\n"}
{"name":"MeasureTheory.lintegral_indicator_const_comp","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nmÎ² : MeasurableSpace Î²\nf : Î± â†’ Î²\ns : Set Î²\nhf : Measurable f\nhs : MeasurableSet s\nc : ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => s.indicator (fun x => c) (f a)) (HMul.hMul c (Î¼ (Set.preimage f s)))","decl":"theorem lintegral_indicator_const_comp {mÎ² : MeasurableSpace Î²} {f : Î± â†’ Î²} {s : Set Î²}\n    (hf : Measurable f) (hs : MeasurableSet s) (c : â„â‰¥0âˆ) :\n    âˆ«â» a, s.indicator (fun _ => c) (f a) âˆ‚Î¼ = c * Î¼ (f â»Â¹' s) := by\n  erw [lintegral_comp (measurable_const.indicator hs) hf, lintegral_indicator_const hs,\n    Measure.map_apply hf hs]\n\n"}
{"name":"MeasurableEmbedding.lintegral_map","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasurableSpace Î²\ng : Î± â†’ Î²\nhg : MeasurableEmbedding g\nf : Î² â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral (MeasureTheory.Measure.map g Î¼) fun a => f a) (MeasureTheory.lintegral Î¼ fun a => f (g a))","decl":"/-- If `g : Î± â†’ Î²` is a measurable embedding and `f : Î² â†’ â„â‰¥0âˆ` is any function (not necessarily\nmeasurable), then `âˆ«â» a, f a âˆ‚(map g Î¼) = âˆ«â» a, f (g a) âˆ‚Î¼`. Compare with `lintegral_map` which\napplies to any measurable `g : Î± â†’ Î²` but requires that `f` is measurable as well. -/\ntheorem _root_.MeasurableEmbedding.lintegral_map [MeasurableSpace Î²] {g : Î± â†’ Î²}\n    (hg : MeasurableEmbedding g) (f : Î² â†’ â„â‰¥0âˆ) : âˆ«â» a, f a âˆ‚map g Î¼ = âˆ«â» a, f (g a) âˆ‚Î¼ := by\n  rw [lintegral, lintegral]\n  refine le_antisymm (iSupâ‚‚_le fun fâ‚€ hfâ‚€ => ?_) (iSupâ‚‚_le fun fâ‚€ hfâ‚€ => ?_)\n  Â· rw [SimpleFunc.lintegral_map _ hg.measurable]\n    have : (fâ‚€.comp g hg.measurable : Î± â†’ â„â‰¥0âˆ) â‰¤ f âˆ˜ g := fun x => hfâ‚€ (g x)\n    exact le_iSup_of_le (comp fâ‚€ g hg.measurable) (by exact le_iSup (Î± := â„â‰¥0âˆ) _ this)\n  Â· rw [â† fâ‚€.extend_comp_eq hg (const _ 0), â† SimpleFunc.lintegral_map, â†\n      SimpleFunc.lintegral_eq_lintegral, â† lintegral]\n    refine lintegral_mono_ae (hg.ae_map_iff.2 <| Eventually.of_forall fun x => ?_)\n    exact (extend_apply _ _ _ _).trans_le (hfâ‚€ _)\n\n"}
{"name":"MeasureTheory.lintegral_map_equiv","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasurableSpace Î²\nf : Î² â†’ ENNReal\ng : MeasurableEquiv Î± Î²\nâŠ¢ Eq (MeasureTheory.lintegral (MeasureTheory.Measure.map (â‡‘g) Î¼) fun a => f a) (MeasureTheory.lintegral Î¼ fun a => f (g a))","decl":"/-- The `lintegral` transforms appropriately under a measurable equivalence `g : Î± â‰ƒáµ Î²`.\n(Compare `lintegral_map`, which applies to a wider class of functions `g : Î± â†’ Î²`, but requires\nmeasurability of the function being integrated.) -/\ntheorem lintegral_map_equiv [MeasurableSpace Î²] (f : Î² â†’ â„â‰¥0âˆ) (g : Î± â‰ƒáµ Î²) :\n    âˆ«â» a, f a âˆ‚map g Î¼ = âˆ«â» a, f (g a) âˆ‚Î¼ :=\n  g.measurableEmbedding.lintegral_map f\n\n"}
{"name":"MeasureTheory.MeasurePreserving.lintegral_map_equiv","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasurableSpace Î²\nÎ½ : MeasureTheory.Measure Î²\nf : Î² â†’ ENNReal\ng : MeasurableEquiv Î± Î²\nhg : MeasureTheory.MeasurePreserving (â‡‘g) Î¼ Î½\nâŠ¢ Eq (MeasureTheory.lintegral Î½ fun a => f a) (MeasureTheory.lintegral Î¼ fun a => f (g a))","decl":"protected theorem MeasurePreserving.lintegral_map_equiv [MeasurableSpace Î²] {Î½ : Measure Î²}\n    (f : Î² â†’ â„â‰¥0âˆ) (g : Î± â‰ƒáµ Î²) (hg : MeasurePreserving g Î¼ Î½) :\n    âˆ«â» a, f a âˆ‚Î½ = âˆ«â» a, f (g a) âˆ‚Î¼ := by\n  rw [â† MeasureTheory.lintegral_map_equiv f g, hg.map_eq]\n\n"}
{"name":"MeasureTheory.MeasurePreserving.lintegral_comp","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nmb : MeasurableSpace Î²\nÎ½ : MeasureTheory.Measure Î²\ng : Î± â†’ Î²\nhg : MeasureTheory.MeasurePreserving g Î¼ Î½\nf : Î² â†’ ENNReal\nhf : Measurable f\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => f (g a)) (MeasureTheory.lintegral Î½ fun b => f b)","decl":"theorem MeasurePreserving.lintegral_comp {mb : MeasurableSpace Î²} {Î½ : Measure Î²} {g : Î± â†’ Î²}\n    (hg : MeasurePreserving g Î¼ Î½) {f : Î² â†’ â„â‰¥0âˆ} (hf : Measurable f) :\n    âˆ«â» a, f (g a) âˆ‚Î¼ = âˆ«â» b, f b âˆ‚Î½ := by rw [â† hg.map_eq, lintegral_map hf hg.measurable]\n\n"}
{"name":"MeasureTheory.MeasurePreserving.lintegral_comp_emb","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nmb : MeasurableSpace Î²\nÎ½ : MeasureTheory.Measure Î²\ng : Î± â†’ Î²\nhg : MeasureTheory.MeasurePreserving g Î¼ Î½\nhge : MeasurableEmbedding g\nf : Î² â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => f (g a)) (MeasureTheory.lintegral Î½ fun b => f b)","decl":"theorem MeasurePreserving.lintegral_comp_emb {mb : MeasurableSpace Î²} {Î½ : Measure Î²} {g : Î± â†’ Î²}\n    (hg : MeasurePreserving g Î¼ Î½) (hge : MeasurableEmbedding g) (f : Î² â†’ â„â‰¥0âˆ) :\n    âˆ«â» a, f (g a) âˆ‚Î¼ = âˆ«â» b, f b âˆ‚Î½ := by rw [â† hg.map_eq, hge.lintegral_map]\n\n"}
{"name":"MeasureTheory.MeasurePreserving.setLIntegral_comp_preimage","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nmb : MeasurableSpace Î²\nÎ½ : MeasureTheory.Measure Î²\ng : Î± â†’ Î²\nhg : MeasureTheory.MeasurePreserving g Î¼ Î½\ns : Set Î²\nhs : MeasurableSet s\nf : Î² â†’ ENNReal\nhf : Measurable f\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict (Set.preimage g s)) fun a => f (g a)) (MeasureTheory.lintegral (Î½.restrict s) fun b => f b)","decl":"theorem MeasurePreserving.setLIntegral_comp_preimage {mb : MeasurableSpace Î²} {Î½ : Measure Î²}\n    {g : Î± â†’ Î²} (hg : MeasurePreserving g Î¼ Î½) {s : Set Î²} (hs : MeasurableSet s) {f : Î² â†’ â„â‰¥0âˆ}\n    (hf : Measurable f) : âˆ«â» a in g â»Â¹' s, f (g a) âˆ‚Î¼ = âˆ«â» b in s, f b âˆ‚Î½ := by\n  rw [â† hg.map_eq, setLIntegral_map hs hf hg.measurable]\n\n"}
{"name":"MeasureTheory.MeasurePreserving.setLIntegral_comp_preimage_emb","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nmb : MeasurableSpace Î²\nÎ½ : MeasureTheory.Measure Î²\ng : Î± â†’ Î²\nhg : MeasureTheory.MeasurePreserving g Î¼ Î½\nhge : MeasurableEmbedding g\nf : Î² â†’ ENNReal\ns : Set Î²\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict (Set.preimage g s)) fun a => f (g a)) (MeasureTheory.lintegral (Î½.restrict s) fun b => f b)","decl":"theorem MeasurePreserving.setLIntegral_comp_preimage_emb {mb : MeasurableSpace Î²} {Î½ : Measure Î²}\n    {g : Î± â†’ Î²} (hg : MeasurePreserving g Î¼ Î½) (hge : MeasurableEmbedding g) (f : Î² â†’ â„â‰¥0âˆ)\n    (s : Set Î²) : âˆ«â» a in g â»Â¹' s, f (g a) âˆ‚Î¼ = âˆ«â» b in s, f b âˆ‚Î½ := by\n  rw [â† hg.map_eq, hge.restrict_map, hge.lintegral_map]\n\n"}
{"name":"MeasureTheory.MeasurePreserving.setLIntegral_comp_emb","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nmb : MeasurableSpace Î²\nÎ½ : MeasureTheory.Measure Î²\ng : Î± â†’ Î²\nhg : MeasureTheory.MeasurePreserving g Î¼ Î½\nhge : MeasurableEmbedding g\nf : Î² â†’ ENNReal\ns : Set Î±\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict s) fun a => f (g a)) (MeasureTheory.lintegral (Î½.restrict (Set.image g s)) fun b => f b)","decl":"theorem MeasurePreserving.setLIntegral_comp_emb {mb : MeasurableSpace Î²} {Î½ : Measure Î²}\n    {g : Î± â†’ Î²} (hg : MeasurePreserving g Î¼ Î½) (hge : MeasurableEmbedding g) (f : Î² â†’ â„â‰¥0âˆ)\n    (s : Set Î±) : âˆ«â» a in s, f (g a) âˆ‚Î¼ = âˆ«â» b in g '' s, f b âˆ‚Î½ := by\n  rw [â† hg.setLIntegral_comp_preimage_emb hge, preimage_image_eq _ hge.injective]\n\n"}
{"name":"MeasureTheory.lintegral_subtype_comap","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nhs : MeasurableSet s\nf : Î± â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral (MeasureTheory.Measure.comap Subtype.val Î¼) fun x => f â†‘x) (MeasureTheory.lintegral (Î¼.restrict s) fun x => f x)","decl":"theorem lintegral_subtype_comap {s : Set Î±} (hs : MeasurableSet s) (f : Î± â†’ â„â‰¥0âˆ) :\n    âˆ«â» x : s, f x âˆ‚(Î¼.comap (â†‘)) = âˆ«â» x in s, f x âˆ‚Î¼ := by\n  rw [â† (MeasurableEmbedding.subtype_coe hs).lintegral_map, map_comap_subtype_coe hs]\n\n"}
{"name":"MeasureTheory.setLIntegral_subtype","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nhs : MeasurableSet s\nt : Set â†‘s\nf : Î± â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral ((MeasureTheory.Measure.comap Subtype.val Î¼).restrict t) fun x => f â†‘x) (MeasureTheory.lintegral (Î¼.restrict (Set.image Subtype.val t)) fun x => f x)","decl":"theorem setLIntegral_subtype {s : Set Î±} (hs : MeasurableSet s) (t : Set s) (f : Î± â†’ â„â‰¥0âˆ) :\n    âˆ«â» x in t, f x âˆ‚(Î¼.comap (â†‘)) = âˆ«â» x in (â†‘) '' t, f x âˆ‚Î¼ := by\n  rw [(MeasurableEmbedding.subtype_coe hs).restrict_comap, lintegral_subtype_comap hs,\n    restrict_restrict hs, inter_eq_right.2 (Subtype.coe_image_subset _ _)]\n\n"}
{"name":"MeasureTheory.exists_setLintegral_compl_lt","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nhf : Ne (MeasureTheory.lintegral Î¼ fun a => f a) Top.top\nÎµ : ENNReal\nhÎµ : Ne Îµ 0\nâŠ¢ Exists fun s => And (MeasurableSet s) (And (LT.lt (Î¼ s) Top.top) (LT.lt (MeasureTheory.lintegral (Î¼.restrict (HasCompl.compl s)) fun a => f a) Îµ))","decl":"/-- If `f : Î± â†’ â„â‰¥0âˆ` has finite integral, then there exists a measurable set `s` of finite measure\nsuch that the integral of `f` over `sá¶œ` is less than a given positive number.\n\nAlso used to prove an `Láµ–`-norm version in\n`MeasureTheory.Memâ„’p.exists_eLpNorm_indicator_compl_le`. -/\ntheorem exists_setLintegral_compl_lt {f : Î± â†’ â„â‰¥0âˆ} (hf : âˆ«â» a, f a âˆ‚Î¼ â‰  âˆ)\n    {Îµ : â„â‰¥0âˆ} (hÎµ : Îµ â‰  0) :\n    âˆƒ s : Set Î±, MeasurableSet s âˆ§ Î¼ s < âˆ âˆ§ âˆ«â» a in sá¶œ, f a âˆ‚Î¼ < Îµ := by\n  by_cases hfâ‚€ : âˆ«â» a, f a âˆ‚Î¼ = 0\n  Â· exact âŸ¨âˆ…, .empty, by simp, by simpa [hfâ‚€, pos_iff_ne_zero]âŸ©\n  obtain âŸ¨g, hgf, hg_meas, hgsupp, hgÎµâŸ© :\n      âˆƒ g â‰¤ f, Measurable g âˆ§ Î¼ (support g) < âˆ âˆ§ âˆ«â» a, f a âˆ‚Î¼ - Îµ < âˆ«â» a, g a âˆ‚Î¼ := by\n    obtain âŸ¨g, hgf, hgÎµâŸ© : âˆƒ (g : Î± â†’â‚› â„â‰¥0âˆ) (_ : g â‰¤ f), âˆ«â» a, f a âˆ‚Î¼ - Îµ < g.lintegral Î¼ := by\n      simpa only [â† lt_iSup_iff, â† lintegral_def] using ENNReal.sub_lt_self hf hfâ‚€ hÎµ\n    refine âŸ¨g, hgf, g.measurable, ?_, by rwa [g.lintegral_eq_lintegral]âŸ©\n    exact SimpleFunc.FinMeasSupp.of_lintegral_ne_top <| ne_top_of_le_ne_top hf <|\n      g.lintegral_eq_lintegral Î¼ â–¸ lintegral_mono hgf\n  refine âŸ¨_, measurableSet_support hg_meas, hgsupp, ?_âŸ©\n  calc\n    âˆ«â» a in (support g)á¶œ, f a âˆ‚Î¼\n      = âˆ«â» a in (support g)á¶œ, f a - g a âˆ‚Î¼ := setLIntegral_congr_fun\n      (measurableSet_support hg_meas).compl <| ae_of_all _ <| by intro; simp_all\n    _ â‰¤ âˆ«â» a, f a - g a âˆ‚Î¼ := setLIntegral_le_lintegral _ _\n    _ = âˆ«â» a, f a âˆ‚Î¼ - âˆ«â» a, g a âˆ‚Î¼ :=\n      lintegral_sub hg_meas (ne_top_of_le_ne_top hf <| lintegral_mono hgf) (ae_of_all _ hgf)\n    _ < Îµ := ENNReal.sub_lt_of_lt_add (lintegral_mono hgf) <|\n      ENNReal.lt_add_of_sub_lt_left (.inl hf) hgÎµ\n\n"}
{"name":"MeasureTheory.exists_measurable_le_setLintegral_eq_of_integrable","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nhf : Ne (MeasureTheory.lintegral Î¼ fun a => f a) Top.top\nâŠ¢ Exists fun g => And (Measurable g) (And (LE.le g f) (âˆ€ (s : Set Î±), MeasurableSet s â†’ Eq (MeasureTheory.lintegral (Î¼.restrict s) fun a => f a) (MeasureTheory.lintegral (Î¼.restrict s) fun a => g a)))","decl":"/-- For any function `f : Î± â†’ â„â‰¥0âˆ`, there exists a measurable function `g â‰¤ f` with the same\nintegral over any measurable set. -/\ntheorem exists_measurable_le_setLintegral_eq_of_integrable {f : Î± â†’ â„â‰¥0âˆ} (hf : âˆ«â» a, f a âˆ‚Î¼ â‰  âˆ) :\n    âˆƒ (g : Î± â†’ â„â‰¥0âˆ), Measurable g âˆ§ g â‰¤ f âˆ§ âˆ€ s : Set Î±, MeasurableSet s â†’\n      âˆ«â» a in s, f a âˆ‚Î¼ = âˆ«â» a in s, g a âˆ‚Î¼ := by\n  obtain âŸ¨g, hmg, hgf, hifgâŸ© := exists_measurable_le_lintegral_eq (Î¼ := Î¼) f\n  use g, hmg, hgf\n  refine fun s hms â†¦ le_antisymm ?_ (lintegral_mono hgf)\n  rw [â† compl_compl s, setLintegral_compl hms.compl, setLintegral_compl hms.compl, hifg]\n  Â· gcongr; apply hgf\n  Â· rw [hifg] at hf\n    exact ne_top_of_le_ne_top hf (setLIntegral_le_lintegral _ _)\n  Â· exact ne_top_of_le_ne_top hf (setLIntegral_le_lintegral _ _)\n\n"}
{"name":"MeasureTheory.lintegral_dirac'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\ninstâœ : MeasurableSpace Î±\na : Î±\nf : Î± â†’ ENNReal\nhf : Measurable f\nâŠ¢ Eq (MeasureTheory.lintegral (MeasureTheory.Measure.dirac a) fun a => f a) (f a)","decl":"theorem lintegral_dirac' (a : Î±) {f : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) : âˆ«â» a, f a âˆ‚dirac a = f a := by\n  simp [lintegral_congr_ae (ae_eq_dirac' hf)]\n\n"}
{"name":"MeasureTheory.lintegral_dirac","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : MeasurableSpace Î±\ninstâœ : MeasurableSingletonClass Î±\na : Î±\nf : Î± â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral (MeasureTheory.Measure.dirac a) fun a => f a) (f a)","decl":"theorem lintegral_dirac [MeasurableSingletonClass Î±] (a : Î±) (f : Î± â†’ â„â‰¥0âˆ) :\n    âˆ«â» a, f a âˆ‚dirac a = f a := by simp [lintegral_congr_ae (ae_eq_dirac f)]\n\n"}
{"name":"MeasureTheory.setLIntegral_dirac'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : MeasurableSpace Î±\na : Î±\nf : Î± â†’ ENNReal\nhf : Measurable f\ns : Set Î±\nhs : MeasurableSet s\ninstâœ : Decidable (Membership.mem s a)\nâŠ¢ Eq (MeasureTheory.lintegral ((MeasureTheory.Measure.dirac a).restrict s) fun x => f x) (ite (Membership.mem s a) (f a) 0)","decl":"theorem setLIntegral_dirac' {a : Î±} {f : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) {s : Set Î±}\n    (hs : MeasurableSet s) [Decidable (a âˆˆ s)] :\n    âˆ«â» x in s, f x âˆ‚Measure.dirac a = if a âˆˆ s then f a else 0 := by\n  rw [restrict_dirac' hs]\n  split_ifs\n  Â· exact lintegral_dirac' _ hf\n  Â· exact lintegral_zero_measure _\n\n"}
{"name":"MeasureTheory.setLIntegral_dirac","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\ninstâœÂ² : MeasurableSpace Î±\na : Î±\nf : Î± â†’ ENNReal\ns : Set Î±\ninstâœÂ¹ : MeasurableSingletonClass Î±\ninstâœ : Decidable (Membership.mem s a)\nâŠ¢ Eq (MeasureTheory.lintegral ((MeasureTheory.Measure.dirac a).restrict s) fun x => f x) (ite (Membership.mem s a) (f a) 0)","decl":"theorem setLIntegral_dirac {a : Î±} (f : Î± â†’ â„â‰¥0âˆ) (s : Set Î±) [MeasurableSingletonClass Î±]\n    [Decidable (a âˆˆ s)] : âˆ«â» x in s, f x âˆ‚Measure.dirac a = if a âˆˆ s then f a else 0 := by\n  rw [restrict_dirac]\n  split_ifs\n  Â· exact lintegral_dirac _ _\n  Â· exact lintegral_zero_measure _\n\n"}
{"name":"MeasureTheory.lintegral_count'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\ninstâœ : MeasurableSpace Î±\nf : Î± â†’ ENNReal\nhf : Measurable f\nâŠ¢ Eq (MeasureTheory.lintegral MeasureTheory.Measure.count fun a => f a) (tsum fun a => f a)","decl":"theorem lintegral_count' {f : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) : âˆ«â» a, f a âˆ‚count = âˆ‘' a, f a := by\n  rw [count, lintegral_sum_measure]\n  congr\n  exact funext fun a => lintegral_dirac' a hf\n\n"}
{"name":"MeasureTheory.lintegral_count","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : MeasurableSpace Î±\ninstâœ : MeasurableSingletonClass Î±\nf : Î± â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral MeasureTheory.Measure.count fun a => f a) (tsum fun a => f a)","decl":"theorem lintegral_count [MeasurableSingletonClass Î±] (f : Î± â†’ â„â‰¥0âˆ) :\n    âˆ«â» a, f a âˆ‚count = âˆ‘' a, f a := by\n  rw [count, lintegral_sum_measure]\n  congr\n  exact funext fun a => lintegral_dirac a f\n\n"}
{"name":"ENNReal.tsum_const_eq","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : MeasurableSpace Î±\ninstâœ : MeasurableSingletonClass Î±\nc : ENNReal\nâŠ¢ Eq (tsum fun x => c) (HMul.hMul c (MeasureTheory.Measure.count Set.univ))","decl":"theorem _root_.ENNReal.tsum_const_eq [MeasurableSingletonClass Î±] (c : â„â‰¥0âˆ) :\n    âˆ‘' _ : Î±, c = c * Measure.count (univ : Set Î±) := by rw [â† lintegral_count, lintegral_const]\n\n"}
{"name":"ENNReal.count_const_le_le_of_tsum_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : MeasurableSpace Î±\ninstâœ : MeasurableSingletonClass Î±\na : Î± â†’ ENNReal\na_mble : Measurable a\nc : ENNReal\ntsum_le_c : LE.le (tsum fun i => a i) c\nÎµ : ENNReal\nÎµ_ne_zero : Ne Îµ 0\nÎµ_ne_top : Ne Îµ Top.top\nâŠ¢ LE.le (MeasureTheory.Measure.count (setOf fun i => LE.le Îµ (a i))) (HDiv.hDiv c Îµ)","decl":"/-- Markov's inequality for the counting measure with hypothesis using `tsum` in `â„â‰¥0âˆ`. -/\ntheorem _root_.ENNReal.count_const_le_le_of_tsum_le [MeasurableSingletonClass Î±] {a : Î± â†’ â„â‰¥0âˆ}\n    (a_mble : Measurable a) {c : â„â‰¥0âˆ} (tsum_le_c : âˆ‘' i, a i â‰¤ c) {Îµ : â„â‰¥0âˆ} (Îµ_ne_zero : Îµ â‰  0)\n    (Îµ_ne_top : Îµ â‰  âˆ) : Measure.count { i : Î± | Îµ â‰¤ a i } â‰¤ c / Îµ := by\n  rw [â† lintegral_count] at tsum_le_c\n  apply (MeasureTheory.meas_ge_le_lintegral_div a_mble.aemeasurable Îµ_ne_zero Îµ_ne_top).trans\n  exact ENNReal.div_le_div tsum_le_c rfl.le\n\n"}
{"name":"NNReal.count_const_le_le_of_tsum_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : MeasurableSpace Î±\ninstâœ : MeasurableSingletonClass Î±\na : Î± â†’ NNReal\na_mble : Measurable a\na_summable : Summable a\nc : NNReal\ntsum_le_c : LE.le (tsum fun i => a i) c\nÎµ : NNReal\nÎµ_ne_zero : Ne Îµ 0\nâŠ¢ LE.le (MeasureTheory.Measure.count (setOf fun i => LE.le Îµ (a i))) (HDiv.hDiv â†‘c â†‘Îµ)","decl":"/-- Markov's inequality for counting measure with hypothesis using `tsum` in `â„â‰¥0`. -/\ntheorem _root_.NNReal.count_const_le_le_of_tsum_le [MeasurableSingletonClass Î±] {a : Î± â†’ â„â‰¥0}\n    (a_mble : Measurable a) (a_summable : Summable a) {c : â„â‰¥0} (tsum_le_c : âˆ‘' i, a i â‰¤ c)\n    {Îµ : â„â‰¥0} (Îµ_ne_zero : Îµ â‰  0) : Measure.count { i : Î± | Îµ â‰¤ a i } â‰¤ c / Îµ := by\n  rw [show (fun i => Îµ â‰¤ a i) = fun i => (Îµ : â„â‰¥0âˆ) â‰¤ ((â†‘) âˆ˜ a) i by\n      funext i\n      simp only [ENNReal.coe_le_coe, Function.comp]]\n  apply\n    ENNReal.count_const_le_le_of_tsum_le (measurable_coe_nnreal_ennreal.comp a_mble) _\n      (mod_cast Îµ_ne_zero) (@ENNReal.coe_ne_top Îµ)\n  convert ENNReal.coe_le_coe.mpr tsum_le_c\n  simp_rw [Function.comp_apply]\n  rw [ENNReal.tsum_coe_eq a_summable.hasSum]\n\n"}
{"name":"MeasureTheory.lintegral_countable'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : Countable Î±\ninstâœ : MeasurableSingletonClass Î±\nf : Î± â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => f a) (tsum fun a => HMul.hMul (f a) (Î¼ (Singleton.singleton a)))","decl":"theorem lintegral_countable' [Countable Î±] [MeasurableSingletonClass Î±] (f : Î± â†’ â„â‰¥0âˆ) :\n    âˆ«â» a, f a âˆ‚Î¼ = âˆ‘' a, f a * Î¼ {a} := by\n  conv_lhs => rw [â† sum_smul_dirac Î¼, lintegral_sum_measure]\n  congr 1 with a : 1\n  rw [lintegral_smul_measure, lintegral_dirac, mul_comm]\n\n"}
{"name":"MeasureTheory.lintegral_singleton'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nhf : Measurable f\na : Î±\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict (Singleton.singleton a)) fun x => f x) (HMul.hMul (f a) (Î¼ (Singleton.singleton a)))","decl":"theorem lintegral_singleton' {f : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) (a : Î±) :\n    âˆ«â» x in {a}, f x âˆ‚Î¼ = f a * Î¼ {a} := by\n  simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac' _ hf, mul_comm]\n\n"}
{"name":"MeasureTheory.lintegral_singleton","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasurableSingletonClass Î±\nf : Î± â†’ ENNReal\na : Î±\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict (Singleton.singleton a)) fun x => f x) (HMul.hMul (f a) (Î¼ (Singleton.singleton a)))","decl":"theorem lintegral_singleton [MeasurableSingletonClass Î±] (f : Î± â†’ â„â‰¥0âˆ) (a : Î±) :\n    âˆ«â» x in {a}, f x âˆ‚Î¼ = f a * Î¼ {a} := by\n  simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac, mul_comm]\n\n"}
{"name":"MeasureTheory.lintegral_countable","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasurableSingletonClass Î±\nf : Î± â†’ ENNReal\ns : Set Î±\nhs : s.Countable\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict s) fun a => f a) (tsum fun a => HMul.hMul (f â†‘a) (Î¼ (Singleton.singleton â†‘a)))","decl":"theorem lintegral_countable [MeasurableSingletonClass Î±] (f : Î± â†’ â„â‰¥0âˆ) {s : Set Î±}\n    (hs : s.Countable) : âˆ«â» a in s, f a âˆ‚Î¼ = âˆ‘' a : s, f a * Î¼ {(a : Î±)} :=\n  calc\n    âˆ«â» a in s, f a âˆ‚Î¼ = âˆ«â» a in â‹ƒ x âˆˆ s, {x}, f a âˆ‚Î¼ := by rw [biUnion_of_singleton]\n    _ = âˆ‘' a : s, âˆ«â» x in {(a : Î±)}, f x âˆ‚Î¼ :=\n      (lintegral_biUnion hs (fun _ _ => measurableSet_singleton _) (pairwiseDisjoint_fiber id s) _)\n    _ = âˆ‘' a : s, f a * Î¼ {(a : Î±)} := by simp only [lintegral_singleton]\n\n"}
{"name":"MeasureTheory.lintegral_insert","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasurableSingletonClass Î±\na : Î±\ns : Set Î±\nh : Not (Membership.mem s a)\nf : Î± â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict (Insert.insert a s)) fun x => f x) (HAdd.hAdd (HMul.hMul (f a) (Î¼ (Singleton.singleton a))) (MeasureTheory.lintegral (Î¼.restrict s) fun x => f x))","decl":"theorem lintegral_insert [MeasurableSingletonClass Î±] {a : Î±} {s : Set Î±} (h : a âˆ‰ s)\n    (f : Î± â†’ â„â‰¥0âˆ) : âˆ«â» x in insert a s, f x âˆ‚Î¼ = f a * Î¼ {a} + âˆ«â» x in s, f x âˆ‚Î¼ := by\n  rw [â† union_singleton, lintegral_union (measurableSet_singleton a), lintegral_singleton,\n    add_comm]\n  rwa [disjoint_singleton_right]\n\n"}
{"name":"MeasureTheory.lintegral_finset","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasurableSingletonClass Î±\ns : Finset Î±\nf : Î± â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict â†‘s) fun x => f x) (s.sum fun x => HMul.hMul (f x) (Î¼ (Singleton.singleton x)))","decl":"theorem lintegral_finset [MeasurableSingletonClass Î±] (s : Finset Î±) (f : Î± â†’ â„â‰¥0âˆ) :\n    âˆ«â» x in s, f x âˆ‚Î¼ = âˆ‘ x âˆˆ s, f x * Î¼ {x} := by\n  simp only [lintegral_countable _ s.countable_toSet, â† Finset.tsum_subtype']\n\n"}
{"name":"MeasureTheory.lintegral_fintype","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : MeasurableSingletonClass Î±\ninstâœ : Fintype Î±\nf : Î± â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun x => f x) (Finset.univ.sum fun x => HMul.hMul (f x) (Î¼ (Singleton.singleton x)))","decl":"theorem lintegral_fintype [MeasurableSingletonClass Î±] [Fintype Î±] (f : Î± â†’ â„â‰¥0âˆ) :\n    âˆ«â» x, f x âˆ‚Î¼ = âˆ‘ x, f x * Î¼ {x} := by\n  rw [â† lintegral_finset, Finset.coe_univ, Measure.restrict_univ]\n\n"}
{"name":"MeasureTheory.lintegral_unique","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : Unique Î±\nf : Î± â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun x => f x) (HMul.hMul (f Inhabited.default) (Î¼ Set.univ))","decl":"theorem lintegral_unique [Unique Î±] (f : Î± â†’ â„â‰¥0âˆ) : âˆ«â» x, f x âˆ‚Î¼ = f default * Î¼ univ :=\n  calc\n    âˆ«â» x, f x âˆ‚Î¼ = âˆ«â» _, f default âˆ‚Î¼ := lintegral_congr <| Unique.forall_iff.2 rfl\n    _ = f default * Î¼ univ := lintegral_const _\n\n"}
{"name":"MeasureTheory.ae_lt_top'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nhf : AEMeasurable f Î¼\nh2f : Ne (MeasureTheory.lintegral Î¼ fun x => f x) Top.top\nâŠ¢ Filter.Eventually (fun x => LT.lt (f x) Top.top) (MeasureTheory.ae Î¼)","decl":"theorem ae_lt_top' {f : Î± â†’ â„â‰¥0âˆ} (hf : AEMeasurable f Î¼) (h2f : âˆ«â» x, f x âˆ‚Î¼ â‰  âˆ) :\n    âˆ€áµ x âˆ‚Î¼, f x < âˆ := by\n  simp_rw [ae_iff, ENNReal.not_lt_top]\n  exact measure_eq_top_of_lintegral_ne_top hf h2f\n\n"}
{"name":"MeasureTheory.ae_lt_top","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nhf : Measurable f\nh2f : Ne (MeasureTheory.lintegral Î¼ fun x => f x) Top.top\nâŠ¢ Filter.Eventually (fun x => LT.lt (f x) Top.top) (MeasureTheory.ae Î¼)","decl":"theorem ae_lt_top {f : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) (h2f : âˆ«â» x, f x âˆ‚Î¼ â‰  âˆ) :\n    âˆ€áµ x âˆ‚Î¼, f x < âˆ :=\n  ae_lt_top' hf.aemeasurable h2f\n\n"}
{"name":"MeasureTheory.setLIntegral_lt_top_of_le_nnreal","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nhs : Ne (Î¼ s) Top.top\nf : Î± â†’ ENNReal\nhbdd : Exists fun y => âˆ€ (x : Î±), Membership.mem s x â†’ LE.le (f x) â†‘y\nâŠ¢ LT.lt (MeasureTheory.lintegral (Î¼.restrict s) fun x => f x) Top.top","decl":"/-- Lebesgue integral of a bounded function over a set of finite measure is finite.\nNote that this lemma assumes no regularity of either `f` or `s`. -/\ntheorem setLIntegral_lt_top_of_le_nnreal {s : Set Î±} (hs : Î¼ s â‰  âˆ) {f : Î± â†’ â„â‰¥0âˆ}\n    (hbdd : âˆƒ y : â„â‰¥0, âˆ€ x âˆˆ s, f x â‰¤ y) : âˆ«â» x in s, f x âˆ‚Î¼ < âˆ := by\n  obtain âŸ¨M, hMâŸ© := hbdd\n  refine lt_of_le_of_lt (setLIntegral_mono measurable_const hM) ?_\n  simp [ENNReal.mul_lt_top, hs.lt_top]\n\n"}
{"name":"MeasureTheory.setLIntegral_lt_top_of_bddAbove","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nhs : Ne (Î¼ s) Top.top\nf : Î± â†’ NNReal\nhbdd : BddAbove (Set.image f s)\nâŠ¢ LT.lt (MeasureTheory.lintegral (Î¼.restrict s) fun x => â†‘(f x)) Top.top","decl":"/-- Lebesgue integral of a bounded function over a set of finite measure is finite.\nNote that this lemma assumes no regularity of either `f` or `s`. -/\ntheorem setLIntegral_lt_top_of_bddAbove {s : Set Î±} (hs : Î¼ s â‰  âˆ) {f : Î± â†’ â„â‰¥0}\n    (hbdd : BddAbove (f '' s)) : âˆ«â» x in s, f x âˆ‚Î¼ < âˆ :=\n  setLIntegral_lt_top_of_le_nnreal hs <| hbdd.imp fun _M hM _x hx â†¦\n    ENNReal.coe_le_coe.2 <| hM (mem_image_of_mem f hx)\n\n"}
{"name":"MeasureTheory.setLIntegral_lt_top_of_isCompact","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : TopologicalSpace Î±\ns : Set Î±\nhs : Ne (Î¼ s) Top.top\nhsc : IsCompact s\nf : Î± â†’ NNReal\nhf : Continuous f\nâŠ¢ LT.lt (MeasureTheory.lintegral (Î¼.restrict s) fun x => â†‘(f x)) Top.top","decl":"theorem setLIntegral_lt_top_of_isCompact [TopologicalSpace Î±] {s : Set Î±}\n    (hs : Î¼ s â‰  âˆ) (hsc : IsCompact s) {f : Î± â†’ â„â‰¥0} (hf : Continuous f) :\n    âˆ«â» x in s, f x âˆ‚Î¼ < âˆ :=\n  setLIntegral_lt_top_of_bddAbove hs (hsc.image hf).bddAbove\n\n"}
{"name":"IsFiniteMeasure.lintegral_lt_top_of_bounded_to_ennreal","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_5\ninstâœ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ¼_fin : MeasureTheory.IsFiniteMeasure Î¼\nf : Î± â†’ ENNReal\nf_bdd : Exists fun c => âˆ€ (x : Î±), LE.le (f x) â†‘c\nâŠ¢ LT.lt (MeasureTheory.lintegral Î¼ fun x => f x) Top.top","decl":"theorem _root_.IsFiniteMeasure.lintegral_lt_top_of_bounded_to_ennreal {Î± : Type*}\n    [MeasurableSpace Î±] (Î¼ : Measure Î±) [Î¼_fin : IsFiniteMeasure Î¼] {f : Î± â†’ â„â‰¥0âˆ}\n    (f_bdd : âˆƒ c : â„â‰¥0, âˆ€ x, f x â‰¤ c) : âˆ«â» x, f x âˆ‚Î¼ < âˆ := by\n  rw [â† Î¼.restrict_univ]\n  refine setLIntegral_lt_top_of_le_nnreal (measure_ne_top _ _) ?_\n  simpa using f_bdd\n\n"}
{"name":"MeasureTheory.tendsto_of_lintegral_tendsto_of_monotone_aux","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_5\nmÎ± : MeasurableSpace Î±\nf : Nat â†’ Î± â†’ ENNReal\nF : Î± â†’ ENNReal\nÎ¼ : MeasureTheory.Measure Î±\nhf_meas : âˆ€ (n : Nat), AEMeasurable (f n) Î¼\nhF_meas : AEMeasurable F Î¼\nhf_tendsto : Filter.Tendsto (fun i => MeasureTheory.lintegral Î¼ fun a => f i a) Filter.atTop (nhds (MeasureTheory.lintegral Î¼ fun a => F a))\nhf_mono : Filter.Eventually (fun a => Monotone fun i => f i a) (MeasureTheory.ae Î¼)\nh_bound : Filter.Eventually (fun a => âˆ€ (i : Nat), LE.le (f i a) (F a)) (MeasureTheory.ae Î¼)\nh_int_finite : Ne (MeasureTheory.lintegral Î¼ fun a => F a) Top.top\nâŠ¢ Filter.Eventually (fun a => Filter.Tendsto (fun i => f i a) Filter.atTop (nhds (F a))) (MeasureTheory.ae Î¼)","decl":"/-- If a monotone sequence of functions has an upper bound and the sequence of integrals of these\nfunctions tends to the integral of the upper bound, then the sequence of functions converges\nalmost everywhere to the upper bound. Auxiliary version assuming moreover that the\nfunctions in the sequence are ae measurable. -/\nlemma tendsto_of_lintegral_tendsto_of_monotone_aux {Î± : Type*} {mÎ± : MeasurableSpace Î±}\n    {f : â„• â†’ Î± â†’ â„â‰¥0âˆ} {F : Î± â†’ â„â‰¥0âˆ} {Î¼ : Measure Î±}\n    (hf_meas : âˆ€ n, AEMeasurable (f n) Î¼) (hF_meas : AEMeasurable F Î¼)\n    (hf_tendsto : Tendsto (fun i â†¦ âˆ«â» a, f i a âˆ‚Î¼) atTop (ğ“ (âˆ«â» a, F a âˆ‚Î¼)))\n    (hf_mono : âˆ€áµ a âˆ‚Î¼, Monotone (fun i â†¦ f i a))\n    (h_bound : âˆ€áµ a âˆ‚Î¼, âˆ€ i, f i a â‰¤ F a) (h_int_finite : âˆ«â» a, F a âˆ‚Î¼ â‰  âˆ) :\n    âˆ€áµ a âˆ‚Î¼, Tendsto (fun i â†¦ f i a) atTop (ğ“ (F a)) := by\n  have h_bound_finite : âˆ€áµ a âˆ‚Î¼, F a â‰  âˆ := by\n    filter_upwards [ae_lt_top' hF_meas h_int_finite] with a ha using ha.ne\n  have h_exists : âˆ€áµ a âˆ‚Î¼, âˆƒ l, Tendsto (fun i â†¦ f i a) atTop (ğ“ l) := by\n    filter_upwards [h_bound, h_bound_finite, hf_mono] with a h_le h_fin h_mono\n    have h_tendsto : Tendsto (fun i â†¦ f i a) atTop atTop âˆ¨\n        âˆƒ l, Tendsto (fun i â†¦ f i a) atTop (ğ“ l) := tendsto_of_monotone h_mono\n    cases' h_tendsto with h_absurd h_tendsto\n    Â· rw [tendsto_atTop_atTop_iff_of_monotone h_mono] at h_absurd\n      obtain âŸ¨i, hiâŸ© := h_absurd (F a + 1)\n      refine absurd (hi.trans (h_le _)) (not_le.mpr ?_)\n      exact ENNReal.lt_add_right h_fin one_ne_zero\n    Â· exact h_tendsto\n  classical\n  let F' : Î± â†’ â„â‰¥0âˆ := fun a â†¦ if h : âˆƒ l, Tendsto (fun i â†¦ f i a) atTop (ğ“ l)\n    then h.choose else âˆ\n  have hF'_tendsto : âˆ€áµ a âˆ‚Î¼, Tendsto (fun i â†¦ f i a) atTop (ğ“ (F' a)) := by\n    filter_upwards [h_exists] with a ha\n    simp_rw [F', dif_pos ha]\n    exact ha.choose_spec\n  suffices F' =áµ[Î¼] F by\n    filter_upwards [this, hF'_tendsto] with a h_eq h_tendsto using h_eq â–¸ h_tendsto\n  have hF'_le : F' â‰¤áµ[Î¼] F := by\n    filter_upwards [h_bound, hF'_tendsto] with a h_le h_tendsto\n    exact le_of_tendsto' h_tendsto (fun m â†¦ h_le _)\n  suffices âˆ«â» a, F' a âˆ‚Î¼ = âˆ«â» a, F a âˆ‚Î¼ from\n    ae_eq_of_ae_le_of_lintegral_le hF'_le (this â–¸ h_int_finite) hF_meas this.symm.le\n  refine tendsto_nhds_unique ?_ hf_tendsto\n  exact lintegral_tendsto_of_tendsto_of_monotone hf_meas hf_mono hF'_tendsto\n\n"}
{"name":"MeasureTheory.tendsto_of_lintegral_tendsto_of_monotone","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_5\nmÎ± : MeasurableSpace Î±\nf : Nat â†’ Î± â†’ ENNReal\nF : Î± â†’ ENNReal\nÎ¼ : MeasureTheory.Measure Î±\nhF_meas : AEMeasurable F Î¼\nhf_tendsto : Filter.Tendsto (fun i => MeasureTheory.lintegral Î¼ fun a => f i a) Filter.atTop (nhds (MeasureTheory.lintegral Î¼ fun a => F a))\nhf_mono : Filter.Eventually (fun a => Monotone fun i => f i a) (MeasureTheory.ae Î¼)\nh_bound : Filter.Eventually (fun a => âˆ€ (i : Nat), LE.le (f i a) (F a)) (MeasureTheory.ae Î¼)\nh_int_finite : Ne (MeasureTheory.lintegral Î¼ fun a => F a) Top.top\nâŠ¢ Filter.Eventually (fun a => Filter.Tendsto (fun i => f i a) Filter.atTop (nhds (F a))) (MeasureTheory.ae Î¼)","decl":"/-- If a monotone sequence of functions has an upper bound and the sequence of integrals of these\nfunctions tends to the integral of the upper bound, then the sequence of functions converges\nalmost everywhere to the upper bound. -/\nlemma tendsto_of_lintegral_tendsto_of_monotone {Î± : Type*} {mÎ± : MeasurableSpace Î±}\n    {f : â„• â†’ Î± â†’ â„â‰¥0âˆ} {F : Î± â†’ â„â‰¥0âˆ} {Î¼ : Measure Î±}\n    (hF_meas : AEMeasurable F Î¼)\n    (hf_tendsto : Tendsto (fun i â†¦ âˆ«â» a, f i a âˆ‚Î¼) atTop (ğ“ (âˆ«â» a, F a âˆ‚Î¼)))\n    (hf_mono : âˆ€áµ a âˆ‚Î¼, Monotone (fun i â†¦ f i a))\n    (h_bound : âˆ€áµ a âˆ‚Î¼, âˆ€ i, f i a â‰¤ F a) (h_int_finite : âˆ«â» a, F a âˆ‚Î¼ â‰  âˆ) :\n    âˆ€áµ a âˆ‚Î¼, Tendsto (fun i â†¦ f i a) atTop (ğ“ (F a)) := by\n  have : âˆ€ n, âˆƒ g : Î± â†’ â„â‰¥0âˆ, Measurable g âˆ§ g â‰¤ f n âˆ§ âˆ«â» a, f n a âˆ‚Î¼ = âˆ«â» a, g a âˆ‚Î¼ :=\n    fun n â†¦ exists_measurable_le_lintegral_eq _ _\n  choose g gmeas gf hg using this\n  let g' : â„• â†’ Î± â†’ â„â‰¥0âˆ := Nat.rec (g 0) (fun n I x â†¦ max (g (n+1) x) (I x))\n  have M n : Measurable (g' n) := by\n    induction n with\n    | zero => simp [g', gmeas 0]\n    | succ n ih => exact Measurable.max (gmeas (n+1)) ih\n  have I : âˆ€ n x, g n x â‰¤ g' n x := by\n    intro n x\n    cases n with | zero | succ => simp [g']\n  have I' : âˆ€áµ x âˆ‚Î¼, âˆ€ n, g' n x â‰¤ f n x := by\n    filter_upwards [hf_mono] with x hx n\n    induction n with\n    | zero => simpa [g'] using gf 0 x\n    | succ n ih => exact max_le (gf (n+1) x) (ih.trans (hx (Nat.le_succ n)))\n  have Int_eq n : âˆ«â» x, g' n x âˆ‚Î¼ = âˆ«â» x, f n x âˆ‚Î¼ := by\n    apply le_antisymm\n    Â· apply lintegral_mono_ae\n      filter_upwards [I'] with x hx using hx n\n    Â· rw [hg n]\n      exact lintegral_mono (I n)\n  have : âˆ€áµ a âˆ‚Î¼, Tendsto (fun i â†¦ g' i a) atTop (ğ“ (F a)) := by\n    apply tendsto_of_lintegral_tendsto_of_monotone_aux _ hF_meas _ _ _ h_int_finite\n    Â· exact fun n â†¦ (M n).aemeasurable\n    Â· simp_rw [Int_eq]\n      exact hf_tendsto\n    Â· exact Eventually.of_forall (fun x â†¦ monotone_nat_of_le_succ (fun n â†¦ le_max_right _ _))\n    Â· filter_upwards [h_bound, I'] with x h'x hx n using (hx n).trans (h'x n)\n  filter_upwards [this, I', h_bound] with x hx h'x h''x\n  exact tendsto_of_tendsto_of_tendsto_of_le_of_le hx tendsto_const_nhds h'x h''x\n\n"}
{"name":"MeasureTheory.tendsto_of_lintegral_tendsto_of_antitone","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_5\nmÎ± : MeasurableSpace Î±\nf : Nat â†’ Î± â†’ ENNReal\nF : Î± â†’ ENNReal\nÎ¼ : MeasureTheory.Measure Î±\nhf_meas : âˆ€ (n : Nat), AEMeasurable (f n) Î¼\nhf_tendsto : Filter.Tendsto (fun i => MeasureTheory.lintegral Î¼ fun a => f i a) Filter.atTop (nhds (MeasureTheory.lintegral Î¼ fun a => F a))\nhf_mono : Filter.Eventually (fun a => Antitone fun i => f i a) (MeasureTheory.ae Î¼)\nh_bound : Filter.Eventually (fun a => âˆ€ (i : Nat), LE.le (F a) (f i a)) (MeasureTheory.ae Î¼)\nh0 : Ne (MeasureTheory.lintegral Î¼ fun a => f 0 a) Top.top\nâŠ¢ Filter.Eventually (fun a => Filter.Tendsto (fun i => f i a) Filter.atTop (nhds (F a))) (MeasureTheory.ae Î¼)","decl":"/-- If an antitone sequence of functions has a lower bound and the sequence of integrals of these\nfunctions tends to the integral of the lower bound, then the sequence of functions converges\nalmost everywhere to the lower bound. -/\nlemma tendsto_of_lintegral_tendsto_of_antitone {Î± : Type*} {mÎ± : MeasurableSpace Î±}\n    {f : â„• â†’ Î± â†’ â„â‰¥0âˆ} {F : Î± â†’ â„â‰¥0âˆ} {Î¼ : Measure Î±}\n    (hf_meas : âˆ€ n, AEMeasurable (f n) Î¼)\n    (hf_tendsto : Tendsto (fun i â†¦ âˆ«â» a, f i a âˆ‚Î¼) atTop (ğ“ (âˆ«â» a, F a âˆ‚Î¼)))\n    (hf_mono : âˆ€áµ a âˆ‚Î¼, Antitone (fun i â†¦ f i a))\n    (h_bound : âˆ€áµ a âˆ‚Î¼, âˆ€ i, F a â‰¤ f i a) (h0 : âˆ«â» a, f 0 a âˆ‚Î¼ â‰  âˆ) :\n    âˆ€áµ a âˆ‚Î¼, Tendsto (fun i â†¦ f i a) atTop (ğ“ (F a)) := by\n  have h_int_finite : âˆ«â» a, F a âˆ‚Î¼ â‰  âˆ := by\n    refine ((lintegral_mono_ae ?_).trans_lt h0.lt_top).ne\n    filter_upwards [h_bound] with a ha using ha 0\n  have h_exists : âˆ€áµ a âˆ‚Î¼, âˆƒ l, Tendsto (fun i â†¦ f i a) atTop (ğ“ l) := by\n    filter_upwards [hf_mono] with a h_mono\n    rcases _root_.tendsto_of_antitone h_mono with h | h\n    Â· refine âŸ¨0, h.mono_right ?_âŸ©\n      rw [OrderBot.atBot_eq]\n      exact pure_le_nhds _\n    Â· exact h\n  classical\n  let F' : Î± â†’ â„â‰¥0âˆ := fun a â†¦ if h : âˆƒ l, Tendsto (fun i â†¦ f i a) atTop (ğ“ l)\n    then h.choose else âˆ\n  have hF'_tendsto : âˆ€áµ a âˆ‚Î¼, Tendsto (fun i â†¦ f i a) atTop (ğ“ (F' a)) := by\n    filter_upwards [h_exists] with a ha\n    simp_rw [F', dif_pos ha]\n    exact ha.choose_spec\n  suffices F' =áµ[Î¼] F by\n    filter_upwards [this, hF'_tendsto] with a h_eq h_tendsto using h_eq â–¸ h_tendsto\n  have hF'_le : F â‰¤áµ[Î¼] F' := by\n    filter_upwards [h_bound, hF'_tendsto] with a h_le h_tendsto\n    exact ge_of_tendsto' h_tendsto (fun m â†¦ h_le _)\n  suffices âˆ«â» a, F' a âˆ‚Î¼ = âˆ«â» a, F a âˆ‚Î¼ by\n    refine (ae_eq_of_ae_le_of_lintegral_le hF'_le h_int_finite ?_ this.le).symm\n    exact ENNReal.aemeasurable_of_tendsto hf_meas hF'_tendsto\n  refine tendsto_nhds_unique ?_ hf_tendsto\n  exact lintegral_tendsto_of_tendsto_of_antitone hf_meas hf_mono h0 hF'_tendsto\n\n"}
{"name":"MeasureTheory.exists_measurable_le_forall_setLIntegral_eq","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.SFinite Î¼\nf : Î± â†’ ENNReal\nâŠ¢ Exists fun g => And (Measurable g) (And (LE.le g f) (âˆ€ (s : Set Î±), Eq (MeasureTheory.lintegral (Î¼.restrict s) fun a => f a) (MeasureTheory.lintegral (Î¼.restrict s) fun a => g a)))","decl":"variable (Î¼) in\n/-- If `Î¼` is an s-finite measure, then for any function `f`\nthere exists a measurable function `g â‰¤ f`\nthat has the same Lebesgue integral over every set.\n\nFor the integral over the whole space, the statement is true without extra assumptions,\nsee `exists_measurable_le_lintegral_eq`.\nSee also `MeasureTheory.Measure.restrict_toMeasurable_of_sFinite` for a similar result. -/\ntheorem exists_measurable_le_forall_setLIntegral_eq [SFinite Î¼] (f : Î± â†’ â„â‰¥0âˆ) :\n    âˆƒ g : Î± â†’ â„â‰¥0âˆ, Measurable g âˆ§ g â‰¤ f âˆ§ âˆ€ s, âˆ«â» a in s, f a âˆ‚Î¼ = âˆ«â» a in s, g a âˆ‚Î¼ := by\n  -- We only need to prove the `â‰¤` inequality for the integrals, the other one follows from `g â‰¤ f`.\n  rsuffices âŸ¨g, hgm, hgle, hlegâŸ© :\n      âˆƒ g : Î± â†’ â„â‰¥0âˆ, Measurable g âˆ§ g â‰¤ f âˆ§ âˆ€ s, âˆ«â» a in s, f a âˆ‚Î¼ â‰¤ âˆ«â» a in s, g a âˆ‚Î¼\n  Â· exact âŸ¨g, hgm, hgle, fun s â†¦ (hleg s).antisymm (lintegral_mono hgle)âŸ©\n  -- Without loss of generality, `Î¼` is a finite measure.\n  wlog h : IsFiniteMeasure Î¼ generalizing Î¼\n  Â· choose g hgm hgle hgint using fun n â†¦ @this (sfiniteSeq Î¼ n) _ inferInstance\n    refine âŸ¨fun x â†¦ â¨† n, g n x, .iSup hgm, fun x â†¦ iSup_le (hgle Â· x), fun s â†¦ ?_âŸ©\n    rw [â† sum_sfiniteSeq Î¼, Measure.restrict_sum_of_countable,\n      lintegral_sum_measure, lintegral_sum_measure]\n    exact ENNReal.tsum_le_tsum fun n â†¦ (hgint n s).trans (lintegral_mono fun x â†¦ le_iSup (g Â· x) _)\n  -- According to `exists_measurable_le_lintegral_eq`, for any natural `n`\n  -- we can choose a measurable function $g_{n}$\n  -- such that $g_{n}(x) â‰¤ \\min (f(x), n)$ for all $x$\n  -- and both sides have the same integral over the whole space w.r.t. $Î¼$.\n  have (n : â„•): âˆƒ g : Î± â†’ â„â‰¥0âˆ, Measurable g âˆ§ g â‰¤ f âˆ§ g â‰¤ n âˆ§\n      âˆ«â» a, min (f a) n âˆ‚Î¼ = âˆ«â» a, g a âˆ‚Î¼ := by\n    simpa [and_assoc] using exists_measurable_le_lintegral_eq Î¼ (f âŠ“ n)\n  choose g hgm hgf hgle hgint using this\n  -- Let `Ï†` be the pointwise supremum of the functions $g_{n}$.\n  -- Clearly, `Ï†` is a measurable function and `Ï† â‰¤ f`.\n  set Ï† : Î± â†’ â„â‰¥0âˆ := fun x â†¦ â¨† n, g n x\n  have hÏ†m : Measurable Ï† := by measurability\n  have hÏ†le : Ï† â‰¤ f := fun x â†¦ iSup_le (hgf Â· x)\n  refine âŸ¨Ï†, hÏ†m, hÏ†le, fun s â†¦ ?_âŸ©\n  -- Now we show the inequality between set integrals.\n  -- Choose a simple function `Ïˆ â‰¤ f` with values in `â„â‰¥0` and prove for `Ïˆ`.\n  rw [lintegral_eq_nnreal]\n  refine iSupâ‚‚_le fun Ïˆ hÏˆ â†¦ ?_\n  -- Choose `n` such that `Ïˆ x â‰¤ n` for all `x`.\n  obtain âŸ¨n, hnâŸ© : âˆƒ n : â„•, âˆ€ x, Ïˆ x â‰¤ n := by\n    rcases Ïˆ.range.bddAbove with âŸ¨C, hCâŸ©\n    exact âŸ¨âŒˆCâŒ‰â‚Š, fun x â†¦ (hC <| Ïˆ.mem_range_self x).trans (Nat.le_ceil _)âŸ©\n  calc\n    (Ïˆ.map (â†‘)).lintegral (Î¼.restrict s) = âˆ«â» a in s, Ïˆ a âˆ‚Î¼ :=\n      SimpleFunc.lintegral_eq_lintegral .. |>.symm\n    _ â‰¤ âˆ«â» a in s, min (f a) n âˆ‚Î¼ :=\n      lintegral_mono fun a â†¦ le_min (hÏˆ _) (ENNReal.coe_le_coe.2 (hn a))\n    _ â‰¤ âˆ«â» a in s, g n a âˆ‚Î¼ := by\n      have : âˆ«â» a in (toMeasurable Î¼ s)á¶œ, min (f a) n âˆ‚Î¼ â‰  âˆ :=\n        IsFiniteMeasure.lintegral_lt_top_of_bounded_to_ennreal _ âŸ¨n, fun _ â†¦ min_le_right ..âŸ© |>.ne\n      have hsm : MeasurableSet (toMeasurable Î¼ s) := measurableSet_toMeasurable ..\n      apply ENNReal.le_of_add_le_add_right this\n      rw [â† Î¼.restrict_toMeasurable_of_sFinite, lintegral_add_compl _ hsm, hgint,\n        â† lintegral_add_compl _ hsm]\n      gcongr with x\n      exact le_min (hgf n x) (hgle n x)\n    _ â‰¤ _ := lintegral_mono fun x â†¦ le_iSup (g Â· x) n\n\n"}
{"name":"MeasureTheory.exists_pos_lintegral_lt_of_sigmaFinite","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.SigmaFinite Î¼\nÎµ : ENNReal\nÎµ0 : Ne Îµ 0\nâŠ¢ Exists fun g => And (âˆ€ (x : Î±), LT.lt 0 (g x)) (And (Measurable g) (LT.lt (MeasureTheory.lintegral Î¼ fun x => â†‘(g x)) Îµ))","decl":"/-- In a sigma-finite measure space, there exists an integrable function which is\npositive everywhere (and with an arbitrarily small integral). -/\ntheorem exists_pos_lintegral_lt_of_sigmaFinite (Î¼ : Measure Î±) [SigmaFinite Î¼] {Îµ : â„â‰¥0âˆ}\n    (Îµ0 : Îµ â‰  0) : âˆƒ g : Î± â†’ â„â‰¥0, (âˆ€ x, 0 < g x) âˆ§ Measurable g âˆ§ âˆ«â» x, g x âˆ‚Î¼ < Îµ := by\n  /- Let `s` be a covering of `Î±` by pairwise disjoint measurable sets of finite measure. Let\n    `Î´ : â„• â†’ â„â‰¥0` be a positive function such that `âˆ‘' i, Î¼ (s i) * Î´ i < Îµ`. Then the function that\n     is equal to `Î´ n` on `s n` is a positive function with integral less than `Îµ`. -/\n  set s : â„• â†’ Set Î± := disjointed (spanningSets Î¼)\n  have : âˆ€ n, Î¼ (s n) < âˆ := fun n =>\n    (measure_mono <| disjointed_subset _ _).trans_lt (measure_spanningSets_lt_top Î¼ n)\n  obtain âŸ¨Î´, Î´pos, Î´sumâŸ© : âˆƒ Î´ : â„• â†’ â„â‰¥0, (âˆ€ i, 0 < Î´ i) âˆ§ (âˆ‘' i, Î¼ (s i) * Î´ i) < Îµ :=\n    ENNReal.exists_pos_tsum_mul_lt_of_countable Îµ0 _ fun n => (this n).ne\n  set N : Î± â†’ â„• := spanningSetsIndex Î¼\n  have hN_meas : Measurable N := measurableSet_spanningSetsIndex Î¼\n  have hNs : âˆ€ n, N â»Â¹' {n} = s n := preimage_spanningSetsIndex_singleton Î¼\n  refine âŸ¨Î´ âˆ˜ N, fun x => Î´pos _, measurable_from_nat.comp hN_meas, ?_âŸ©\n  erw [lintegral_comp measurable_from_nat.coe_nnreal_ennreal hN_meas]\n  simpa [N, hNs, lintegral_countable', measurableSet_spanningSetsIndex, mul_comm] using Î´sum\n\n"}
{"name":"MeasureTheory.lintegral_trim","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nhm : LE.le m m0\nf : Î± â†’ ENNReal\nhf : Measurable f\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.trim hm) fun a => f a) (MeasureTheory.lintegral Î¼ fun a => f a)","decl":"theorem lintegral_trim {Î¼ : Measure Î±} (hm : m â‰¤ m0) {f : Î± â†’ â„â‰¥0âˆ} (hf : Measurable[m] f) :\n    âˆ«â» a, f a âˆ‚Î¼.trim hm = âˆ«â» a, f a âˆ‚Î¼ := by\n  refine\n    @Measurable.ennreal_induction Î± m (fun f => âˆ«â» a, f a âˆ‚Î¼.trim hm = âˆ«â» a, f a âˆ‚Î¼) ?_ ?_ ?_ f hf\n  Â· intro c s hs\n    rw [lintegral_indicator hs, lintegral_indicator (hm s hs), setLIntegral_const,\n      setLIntegral_const]\n    suffices h_trim_s : Î¼.trim hm s = Î¼ s by rw [h_trim_s]\n    exact trim_measurableSet_eq hm hs\n  Â· intro f g _ hf _ hf_prop hg_prop\n    have h_m := lintegral_add_left (Î¼ := Measure.trim Î¼ hm) hf g\n    have h_m0 := lintegral_add_left (Î¼ := Î¼) (Measurable.mono hf hm le_rfl) g\n    rwa [hf_prop, hg_prop, â† h_m0] at h_m\n  Â· intro f hf hf_mono hf_prop\n    rw [lintegral_iSup hf hf_mono]\n    rw [lintegral_iSup (fun n => Measurable.mono (hf n) hm le_rfl) hf_mono]\n    congr with n\n    exact hf_prop n\n\n"}
{"name":"MeasureTheory.lintegral_trim_ae","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nhm : LE.le m m0\nf : Î± â†’ ENNReal\nhf : AEMeasurable f (Î¼.trim hm)\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.trim hm) fun a => f a) (MeasureTheory.lintegral Î¼ fun a => f a)","decl":"theorem lintegral_trim_ae {Î¼ : Measure Î±} (hm : m â‰¤ m0) {f : Î± â†’ â„â‰¥0âˆ}\n    (hf : AEMeasurable f (Î¼.trim hm)) : âˆ«â» a, f a âˆ‚Î¼.trim hm = âˆ«â» a, f a âˆ‚Î¼ := by\n  rw [lintegral_congr_ae (ae_eq_of_ae_eq_trim hf.ae_eq_mk), lintegral_congr_ae hf.ae_eq_mk,\n    lintegral_trim hm hf.measurable_mk]\n\n"}
{"name":"MeasureTheory.univ_le_of_forall_fin_meas_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nhm : LE.le m m0\ninstâœ : MeasureTheory.SigmaFinite (Î¼.trim hm)\nC : ENNReal\nf : Set Î± â†’ ENNReal\nhf : âˆ€ (s : Set Î±), MeasurableSet s â†’ Ne (Î¼ s) Top.top â†’ LE.le (f s) C\nh_F_lim : âˆ€ (S : Nat â†’ Set Î±), (âˆ€ (n : Nat), MeasurableSet (S n)) â†’ Monotone S â†’ LE.le (f (Set.iUnion fun n => S n)) (iSup fun n => f (S n))\nâŠ¢ LE.le (f Set.univ) C","decl":"theorem univ_le_of_forall_fin_meas_le {Î¼ : Measure Î±} (hm : m â‰¤ m0) [SigmaFinite (Î¼.trim hm)]\n    (C : â„â‰¥0âˆ) {f : Set Î± â†’ â„â‰¥0âˆ} (hf : âˆ€ s, MeasurableSet[m] s â†’ Î¼ s â‰  âˆ â†’ f s â‰¤ C)\n    (h_F_lim :\n      âˆ€ S : â„• â†’ Set Î±, (âˆ€ n, MeasurableSet[m] (S n)) â†’ Monotone S â†’ f (â‹ƒ n, S n) â‰¤ â¨† n, f (S n)) :\n    f univ â‰¤ C := by\n  let S := @spanningSets _ m (Î¼.trim hm) _\n  have hS_mono : Monotone S := @monotone_spanningSets _ m (Î¼.trim hm) _\n  have hS_meas : âˆ€ n, MeasurableSet[m] (S n) := @measurableSet_spanningSets _ m (Î¼.trim hm) _\n  rw [â† @iUnion_spanningSets _ m (Î¼.trim hm)]\n  refine (h_F_lim S hS_meas hS_mono).trans ?_\n  refine iSup_le fun n => hf (S n) (hS_meas n) ?_\n  exact ((le_trim hm).trans_lt (@measure_spanningSets_lt_top _ m (Î¼.trim hm) _ n)).ne\n\n"}
{"name":"MeasureTheory.lintegral_le_of_forall_fin_meas_trim_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nhm : LE.le m m0\ninstâœ : MeasureTheory.SigmaFinite (Î¼.trim hm)\nC : ENNReal\nf : Î± â†’ ENNReal\nhf : âˆ€ (s : Set Î±), MeasurableSet s â†’ Ne (Î¼ s) Top.top â†’ LE.le (MeasureTheory.lintegral (Î¼.restrict s) fun x => f x) C\nâŠ¢ LE.le (MeasureTheory.lintegral Î¼ fun x => f x) C","decl":"/-- If the Lebesgue integral of a function is bounded by some constant on all sets with finite\nmeasure in a sub-Ïƒ-algebra and the measure is Ïƒ-finite on that sub-Ïƒ-algebra, then the integral\nover the whole space is bounded by that same constant. -/\ntheorem lintegral_le_of_forall_fin_meas_trim_le {Î¼ : Measure Î±} (hm : m â‰¤ m0)\n    [SigmaFinite (Î¼.trim hm)] (C : â„â‰¥0âˆ) {f : Î± â†’ â„â‰¥0âˆ}\n    (hf : âˆ€ s, MeasurableSet[m] s â†’ Î¼ s â‰  âˆ â†’ âˆ«â» x in s, f x âˆ‚Î¼ â‰¤ C) : âˆ«â» x, f x âˆ‚Î¼ â‰¤ C := by\n  have : âˆ«â» x in univ, f x âˆ‚Î¼ = âˆ«â» x, f x âˆ‚Î¼ := by simp only [Measure.restrict_univ]\n  rw [â† this]\n  refine univ_le_of_forall_fin_meas_le hm C hf fun S _ hS_mono => ?_\n  rw [setLIntegral_iUnion_of_directed]\n  exact directed_of_isDirected_le hS_mono\n\n"}
{"name":"MeasureTheory.lintegral_le_of_forall_fin_meas_le_of_measurable","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nhm : LE.le m m0\ninstâœ : MeasureTheory.SigmaFinite (Î¼.trim hm)\nC : ENNReal\nf : Î± â†’ ENNReal\nhf : âˆ€ (s : Set Î±), MeasurableSet s â†’ Ne (Î¼ s) Top.top â†’ LE.le (MeasureTheory.lintegral (Î¼.restrict s) fun x => f x) C\nâŠ¢ LE.le (MeasureTheory.lintegral Î¼ fun x => f x) C","decl":"alias lintegral_le_of_forall_fin_meas_le_of_measurable := lintegral_le_of_forall_fin_meas_trim_le\n\n"}
{"name":"MeasureTheory.lintegral_le_of_forall_fin_meas_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.SigmaFinite Î¼\nC : ENNReal\nf : Î± â†’ ENNReal\nhf : âˆ€ (s : Set Î±), MeasurableSet s â†’ Ne (Î¼ s) Top.top â†’ LE.le (MeasureTheory.lintegral (Î¼.restrict s) fun x => f x) C\nâŠ¢ LE.le (MeasureTheory.lintegral Î¼ fun x => f x) C","decl":"/-- If the Lebesgue integral of a function is bounded by some constant on all sets with finite\nmeasure and the measure is Ïƒ-finite, then the integral over the whole space is bounded by that same\nconstant. -/\ntheorem lintegral_le_of_forall_fin_meas_le [MeasurableSpace Î±] {Î¼ : Measure Î±} [SigmaFinite Î¼]\n    (C : â„â‰¥0âˆ) {f : Î± â†’ â„â‰¥0âˆ}\n    (hf : âˆ€ s, MeasurableSet s â†’ Î¼ s â‰  âˆ â†’ âˆ«â» x in s, f x âˆ‚Î¼ â‰¤ C) : âˆ«â» x, f x âˆ‚Î¼ â‰¤ C :=\n  have : SigmaFinite (Î¼.trim le_rfl) := by rwa [trim_eq_self]\n  lintegral_le_of_forall_fin_meas_trim_le _ C hf\n\n"}
{"name":"MeasureTheory.SimpleFunc.exists_lt_lintegral_simpleFunc_of_lt_lintegral","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.SigmaFinite Î¼\nf : MeasureTheory.SimpleFunc Î± NNReal\nL : ENNReal\nhL : LT.lt L (MeasureTheory.lintegral Î¼ fun x => â†‘(f x))\nâŠ¢ Exists fun g => And (âˆ€ (x : Î±), LE.le (g x) (f x)) (And (LT.lt (MeasureTheory.lintegral Î¼ fun x => â†‘(g x)) Top.top) (LT.lt L (MeasureTheory.lintegral Î¼ fun x => â†‘(g x))))","decl":"theorem SimpleFunc.exists_lt_lintegral_simpleFunc_of_lt_lintegral {m : MeasurableSpace Î±}\n    {Î¼ : Measure Î±} [SigmaFinite Î¼] {f : Î± â†’â‚› â„â‰¥0} {L : â„â‰¥0âˆ} (hL : L < âˆ«â» x, f x âˆ‚Î¼) :\n    âˆƒ g : Î± â†’â‚› â„â‰¥0, (âˆ€ x, g x â‰¤ f x) âˆ§ âˆ«â» x, g x âˆ‚Î¼ < âˆ âˆ§ L < âˆ«â» x, g x âˆ‚Î¼ := by\n  induction' f using MeasureTheory.SimpleFunc.induction with c s hs fâ‚ fâ‚‚ _ hâ‚ hâ‚‚ generalizing L\n  Â· simp only [hs, const_zero, coe_piecewise, coe_const, SimpleFunc.coe_zero, univ_inter,\n      piecewise_eq_indicator, lintegral_indicator, lintegral_const, Measure.restrict_apply',\n      ENNReal.coe_indicator, Function.const_apply] at hL\n    have c_ne_zero : c â‰  0 := by\n      intro hc\n      simp only [hc, ENNReal.coe_zero, zero_mul, not_lt_zero] at hL\n    have : L / c < Î¼ s := by\n      rwa [ENNReal.div_lt_iff, mul_comm]\n      Â· simp only [c_ne_zero, Ne, ENNReal.coe_eq_zero, not_false_iff, true_or]\n      Â· simp only [Ne, coe_ne_top, not_false_iff, true_or]\n    obtain âŸ¨t, ht, ts, mlt, t_topâŸ© :\n      âˆƒ t : Set Î±, MeasurableSet t âˆ§ t âŠ† s âˆ§ L / â†‘c < Î¼ t âˆ§ Î¼ t < âˆ :=\n      Measure.exists_subset_measure_lt_top hs this\n    refine âŸ¨piecewise t ht (const Î± c) (const Î± 0), fun x => ?_, ?_, ?_âŸ©\n    Â· refine indicator_le_indicator_of_subset ts (fun x => ?_) x\n      exact zero_le _\n    Â· simp only [ht, const_zero, coe_piecewise, coe_const, SimpleFunc.coe_zero, univ_inter,\n        piecewise_eq_indicator, ENNReal.coe_indicator, Function.const_apply, lintegral_indicator,\n        lintegral_const, Measure.restrict_apply', ENNReal.mul_lt_top ENNReal.coe_lt_top t_top]\n    Â· simp only [ht, const_zero, coe_piecewise, coe_const, SimpleFunc.coe_zero,\n        piecewise_eq_indicator, ENNReal.coe_indicator, Function.const_apply, lintegral_indicator,\n        lintegral_const, Measure.restrict_apply', univ_inter]\n      rwa [mul_comm, â† ENNReal.div_lt_iff]\n      Â· simp only [c_ne_zero, Ne, ENNReal.coe_eq_zero, not_false_iff, true_or]\n      Â· simp only [Ne, coe_ne_top, not_false_iff, true_or]\n  Â· replace hL : L < âˆ«â» x, fâ‚ x âˆ‚Î¼ + âˆ«â» x, fâ‚‚ x âˆ‚Î¼ := by\n      rwa [â† lintegral_add_left fâ‚.measurable.coe_nnreal_ennreal]\n    by_cases hfâ‚ : âˆ«â» x, fâ‚ x âˆ‚Î¼ = 0\n    Â· simp only [hfâ‚, zero_add] at hL\n      rcases hâ‚‚ hL with âŸ¨g, g_le, g_top, gLâŸ©\n      refine âŸ¨g, fun x => (g_le x).trans ?_, g_top, gLâŸ©\n      simp only [SimpleFunc.coe_add, Pi.add_apply, le_add_iff_nonneg_left, zero_le']\n    by_cases hfâ‚‚ : âˆ«â» x, fâ‚‚ x âˆ‚Î¼ = 0\n    Â· simp only [hfâ‚‚, add_zero] at hL\n      rcases hâ‚ hL with âŸ¨g, g_le, g_top, gLâŸ©\n      refine âŸ¨g, fun x => (g_le x).trans ?_, g_top, gLâŸ©\n      simp only [SimpleFunc.coe_add, Pi.add_apply, le_add_iff_nonneg_right, zero_le']\n    obtain âŸ¨Lâ‚, hLâ‚, Lâ‚‚, hLâ‚‚, hLâŸ© : âˆƒ Lâ‚ < âˆ«â» x, fâ‚ x âˆ‚Î¼, âˆƒ Lâ‚‚ < âˆ«â» x, fâ‚‚ x âˆ‚Î¼, L < Lâ‚ + Lâ‚‚ :=\n      ENNReal.exists_lt_add_of_lt_add hL hfâ‚ hfâ‚‚\n    rcases hâ‚ hLâ‚ with âŸ¨gâ‚, gâ‚_le, gâ‚_top, hgâ‚âŸ©\n    rcases hâ‚‚ hLâ‚‚ with âŸ¨gâ‚‚, gâ‚‚_le, gâ‚‚_top, hgâ‚‚âŸ©\n    refine âŸ¨gâ‚ + gâ‚‚, fun x => add_le_add (gâ‚_le x) (gâ‚‚_le x), ?_, ?_âŸ©\n    Â· apply lt_of_le_of_lt _ (add_lt_top.2 âŸ¨gâ‚_top, gâ‚‚_topâŸ©)\n      rw [â† lintegral_add_left gâ‚.measurable.coe_nnreal_ennreal]\n      exact le_rfl\n    Â· apply hL.trans ((ENNReal.add_lt_add hgâ‚ hgâ‚‚).trans_le _)\n      rw [â† lintegral_add_left gâ‚.measurable.coe_nnreal_ennreal]\n      simp only [coe_add, Pi.add_apply, ENNReal.coe_add, le_rfl]\n\n"}
{"name":"MeasureTheory.exists_lt_lintegral_simpleFunc_of_lt_lintegral","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.SigmaFinite Î¼\nf : Î± â†’ NNReal\nL : ENNReal\nhL : LT.lt L (MeasureTheory.lintegral Î¼ fun x => â†‘(f x))\nâŠ¢ Exists fun g => And (âˆ€ (x : Î±), LE.le (g x) (f x)) (And (LT.lt (MeasureTheory.lintegral Î¼ fun x => â†‘(g x)) Top.top) (LT.lt L (MeasureTheory.lintegral Î¼ fun x => â†‘(g x))))","decl":"theorem exists_lt_lintegral_simpleFunc_of_lt_lintegral {m : MeasurableSpace Î±} {Î¼ : Measure Î±}\n    [SigmaFinite Î¼] {f : Î± â†’ â„â‰¥0} {L : â„â‰¥0âˆ} (hL : L < âˆ«â» x, f x âˆ‚Î¼) :\n    âˆƒ g : Î± â†’â‚› â„â‰¥0, (âˆ€ x, g x â‰¤ f x) âˆ§ âˆ«â» x, g x âˆ‚Î¼ < âˆ âˆ§ L < âˆ«â» x, g x âˆ‚Î¼ := by\n  simp_rw [lintegral_eq_nnreal, lt_iSup_iff] at hL\n  rcases hL with âŸ¨gâ‚€, hgâ‚€, gâ‚€LâŸ©\n  have h'L : L < âˆ«â» x, gâ‚€ x âˆ‚Î¼ := by\n    convert gâ‚€L\n    rw [â† SimpleFunc.lintegral_eq_lintegral, coe_map]\n    simp only [Function.comp_apply]\n  rcases SimpleFunc.exists_lt_lintegral_simpleFunc_of_lt_lintegral h'L with âŸ¨g, hg, gL, gtopâŸ©\n  exact âŸ¨g, fun x => (hg x).trans (coe_le_coe.1 (hgâ‚€ x)), gL, gtopâŸ©\n\n"}
{"name":"MeasureTheory.tendsto_measure_of_ae_tendsto_indicator","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_5\ninstâœÂ¹ : MeasurableSpace Î±\nA : Set Î±\nÎ¹ : Type u_6\nL : Filter Î¹\ninstâœ : L.IsCountablyGenerated\nAs : Î¹ â†’ Set Î±\nÎ¼ : MeasureTheory.Measure Î±\nA_mble : MeasurableSet A\nAs_mble : âˆ€ (i : Î¹), MeasurableSet (As i)\nB : Set Î±\nB_mble : MeasurableSet B\nB_finmeas : Ne (Î¼ B) Top.top\nAs_le_B : Filter.Eventually (fun i => HasSubset.Subset (As i) B) L\nh_lim : Filter.Eventually (fun x => Filter.Eventually (fun i => Iff (Membership.mem (As i) x) (Membership.mem A x)) L) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Tendsto (fun i => Î¼ (As i)) L (nhds (Î¼ A))","decl":"/-- If the indicators of measurable sets `Aáµ¢` tend pointwise almost everywhere to the indicator\nof a measurable set `A` and we eventually have `Aáµ¢ âŠ† B` for some set `B` of finite measure, then\nthe measures of `Aáµ¢` tend to the measure of `A`. -/\nlemma tendsto_measure_of_ae_tendsto_indicator {Î¼ : Measure Î±} (A_mble : MeasurableSet A)\n    (As_mble : âˆ€ i, MeasurableSet (As i)) {B : Set Î±} (B_mble : MeasurableSet B)\n    (B_finmeas : Î¼ B â‰  âˆ) (As_le_B : âˆ€á¶  i in L, As i âŠ† B)\n    (h_lim : âˆ€áµ x âˆ‚Î¼, âˆ€á¶  i in L, x âˆˆ As i â†” x âˆˆ A) :\n    Tendsto (fun i â†¦ Î¼ (As i)) L (ğ“ (Î¼ A)) := by\n  simp_rw [â† MeasureTheory.lintegral_indicator_one A_mble,\n           â† MeasureTheory.lintegral_indicator_one (As_mble _)]\n  refine tendsto_lintegral_filter_of_dominated_convergence (B.indicator (1 : Î± â†’ â„â‰¥0âˆ))\n          (Eventually.of_forall ?_) ?_ ?_ ?_\n  Â· exact fun i â†¦ Measurable.indicator measurable_const (As_mble i)\n  Â· filter_upwards [As_le_B] with i hi\n    exact Eventually.of_forall (fun x â†¦ indicator_le_indicator_of_subset hi (by simp) x)\n  Â· rwa [â† lintegral_indicator_one B_mble] at B_finmeas\n  Â· simpa only [Pi.one_def, tendsto_indicator_const_apply_iff_eventually] using h_lim\n\n"}
{"name":"MeasureTheory.tendsto_measure_of_ae_tendsto_indicator_of_isFiniteMeasure","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"Î± : Type u_5\ninstâœÂ² : MeasurableSpace Î±\nA : Set Î±\nÎ¹ : Type u_6\nL : Filter Î¹\ninstâœÂ¹ : L.IsCountablyGenerated\nAs : Î¹ â†’ Set Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nA_mble : MeasurableSet A\nAs_mble : âˆ€ (i : Î¹), MeasurableSet (As i)\nh_lim : Filter.Eventually (fun x => Filter.Eventually (fun i => Iff (Membership.mem (As i) x) (Membership.mem A x)) L) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Tendsto (fun i => Î¼ (As i)) L (nhds (Î¼ A))","decl":"/-- If `Î¼` is a finite measure and the indicators of measurable sets `Aáµ¢` tend pointwise\nalmost everywhere to the indicator of a measurable set `A`, then the measures `Î¼ Aáµ¢` tend to\nthe measure `Î¼ A`. -/\nlemma tendsto_measure_of_ae_tendsto_indicator_of_isFiniteMeasure\n    {Î¼ : Measure Î±} [IsFiniteMeasure Î¼] (A_mble : MeasurableSet A)\n    (As_mble : âˆ€ i, MeasurableSet (As i)) (h_lim : âˆ€áµ x âˆ‚Î¼, âˆ€á¶  i in L, x âˆˆ As i â†” x âˆˆ A) :\n    Tendsto (fun i â†¦ Î¼ (As i)) L (ğ“ (Î¼ A)) :=\n  tendsto_measure_of_ae_tendsto_indicator L A_mble As_mble MeasurableSet.univ\n    (measure_ne_top Î¼ univ) (Eventually.of_forall (fun i â†¦ subset_univ (As i))) h_lim\n\n"}
