{"name":"MeasureTheory.lintegral_def","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_5\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral μ f) (iSup fun g => iSup fun x => g.lintegral μ)","decl":"/-- The **lower Lebesgue integral** of a function `f` with respect to a measure `μ`. -/\nirreducible_def lintegral {_ : MeasurableSpace α} (μ : Measure α) (f : α → ℝ≥0∞) : ℝ≥0∞ :=\n  ⨆ (g : α →ₛ ℝ≥0∞) (_ : ⇑g ≤ f), g.lintegral μ\n\n"}
{"name":"MeasureTheory.SimpleFunc.lintegral_eq_lintegral","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nf : MeasureTheory.SimpleFunc α ENNReal\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.lintegral μ fun a => f a) (f.lintegral μ)","decl":"theorem SimpleFunc.lintegral_eq_lintegral {m : MeasurableSpace α} (f : α →ₛ ℝ≥0∞) (μ : Measure α) :\n    ∫⁻ a, f a ∂μ = f.lintegral μ := by\n  rw [MeasureTheory.lintegral]\n  exact le_antisymm (iSup₂_le fun g hg => lintegral_mono hg <| le_rfl)\n    (le_iSup₂_of_le f le_rfl le_rfl)\n\n"}
{"name":"MeasureTheory.lintegral_mono'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nhμν : LE.le μ ν\nf g : α → ENNReal\nhfg : LE.le f g\n⊢ LE.le (MeasureTheory.lintegral μ fun a => f a) (MeasureTheory.lintegral ν fun a => g a)","decl":"@[gcongr, mono]\ntheorem lintegral_mono' {m : MeasurableSpace α} ⦃μ ν : Measure α⦄ (hμν : μ ≤ ν) ⦃f g : α → ℝ≥0∞⦄\n    (hfg : f ≤ g) : ∫⁻ a, f a ∂μ ≤ ∫⁻ a, g a ∂ν := by\n  rw [lintegral, lintegral]\n  exact iSup_mono fun φ => iSup_mono' fun hφ => ⟨le_trans hφ hfg, lintegral_mono (le_refl φ) hμν⟩\n\n-- version where `hfg` is an explicit forall, so that `@[gcongr]` can recognize it\n"}
{"name":"MeasureTheory.lintegral_mono_fn'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nf g : α → ENNReal\nhfg : ∀ (x : α), LE.le (f x) (g x)\nh2 : LE.le μ ν\n⊢ LE.le (MeasureTheory.lintegral μ fun a => f a) (MeasureTheory.lintegral ν fun a => g a)","decl":"@[gcongr] theorem lintegral_mono_fn' ⦃f g : α → ℝ≥0∞⦄ (hfg : ∀ x, f x ≤ g x) (h2 : μ ≤ ν) :\n    ∫⁻ a, f a ∂μ ≤ ∫⁻ a, g a ∂ν :=\n  lintegral_mono' h2 hfg\n\n"}
{"name":"MeasureTheory.lintegral_mono","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\nhfg : LE.le f g\n⊢ LE.le (MeasureTheory.lintegral μ fun a => f a) (MeasureTheory.lintegral μ fun a => g a)","decl":"theorem lintegral_mono ⦃f g : α → ℝ≥0∞⦄ (hfg : f ≤ g) : ∫⁻ a, f a ∂μ ≤ ∫⁻ a, g a ∂μ :=\n  lintegral_mono' (le_refl μ) hfg\n\n-- version where `hfg` is an explicit forall, so that `@[gcongr]` can recognize it\n"}
{"name":"MeasureTheory.lintegral_mono_fn","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\nhfg : ∀ (x : α), LE.le (f x) (g x)\n⊢ LE.le (MeasureTheory.lintegral μ fun a => f a) (MeasureTheory.lintegral μ fun a => g a)","decl":"@[gcongr] theorem lintegral_mono_fn ⦃f g : α → ℝ≥0∞⦄ (hfg : ∀ x, f x ≤ g x) :\n    ∫⁻ a, f a ∂μ ≤ ∫⁻ a, g a ∂μ :=\n  lintegral_mono hfg\n\n"}
{"name":"MeasureTheory.lintegral_mono_nnreal","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → NNReal\nh : LE.le f g\n⊢ LE.le (MeasureTheory.lintegral μ fun a => ↑(f a)) (MeasureTheory.lintegral μ fun a => ↑(g a))","decl":"theorem lintegral_mono_nnreal {f g : α → ℝ≥0} (h : f ≤ g) : ∫⁻ a, f a ∂μ ≤ ∫⁻ a, g a ∂μ :=\n  lintegral_mono fun a => ENNReal.coe_le_coe.2 (h a)\n\n"}
{"name":"MeasureTheory.iSup_lintegral_measurable_le_eq_lintegral","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\n⊢ Eq (iSup fun g => iSup fun x => iSup fun x => MeasureTheory.lintegral μ fun a => g a) (MeasureTheory.lintegral μ fun a => f a)","decl":"theorem iSup_lintegral_measurable_le_eq_lintegral (f : α → ℝ≥0∞) :\n    ⨆ (g : α → ℝ≥0∞) (_ : Measurable g) (_ : g ≤ f), ∫⁻ a, g a ∂μ = ∫⁻ a, f a ∂μ := by\n  apply le_antisymm\n  · exact iSup_le fun i => iSup_le fun _ => iSup_le fun h'i => lintegral_mono h'i\n  · rw [lintegral]\n    refine iSup₂_le fun i hi => le_iSup₂_of_le i i.measurable <| le_iSup_of_le hi ?_\n    exact le_of_eq (i.lintegral_eq_lintegral _).symm\n\n"}
{"name":"MeasureTheory.lintegral_mono_set","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nf : α → ENNReal\nhst : HasSubset.Subset s t\n⊢ LE.le (MeasureTheory.lintegral (μ.restrict s) fun x => f x) (MeasureTheory.lintegral (μ.restrict t) fun x => f x)","decl":"theorem lintegral_mono_set {_ : MeasurableSpace α} ⦃μ : Measure α⦄ {s t : Set α} {f : α → ℝ≥0∞}\n    (hst : s ⊆ t) : ∫⁻ x in s, f x ∂μ ≤ ∫⁻ x in t, f x ∂μ :=\n  lintegral_mono' (Measure.restrict_mono hst (le_refl μ)) (le_refl f)\n\n"}
{"name":"MeasureTheory.lintegral_mono_set'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nf : α → ENNReal\nhst : (MeasureTheory.ae μ).EventuallyLE s t\n⊢ LE.le (MeasureTheory.lintegral (μ.restrict s) fun x => f x) (MeasureTheory.lintegral (μ.restrict t) fun x => f x)","decl":"theorem lintegral_mono_set' {_ : MeasurableSpace α} ⦃μ : Measure α⦄ {s t : Set α} {f : α → ℝ≥0∞}\n    (hst : s ≤ᵐ[μ] t) : ∫⁻ x in s, f x ∂μ ≤ ∫⁻ x in t, f x ∂μ :=\n  lintegral_mono' (Measure.restrict_mono' hst (le_refl μ)) (le_refl f)\n\n"}
{"name":"MeasureTheory.monotone_lintegral","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Monotone (MeasureTheory.lintegral μ)","decl":"theorem monotone_lintegral {_ : MeasurableSpace α} (μ : Measure α) : Monotone (lintegral μ) :=\n  lintegral_mono\n\n"}
{"name":"MeasureTheory.lintegral_const","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nc : ENNReal\n⊢ Eq (MeasureTheory.lintegral μ fun x => c) (HMul.hMul c (μ Set.univ))","decl":"@[simp]\ntheorem lintegral_const (c : ℝ≥0∞) : ∫⁻ _, c ∂μ = c * μ univ := by\n  rw [← SimpleFunc.const_lintegral, ← SimpleFunc.lintegral_eq_lintegral, SimpleFunc.coe_const]\n  rfl\n\n"}
{"name":"MeasureTheory.lintegral_zero","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.lintegral μ fun x => 0) 0","decl":"theorem lintegral_zero : ∫⁻ _ : α, 0 ∂μ = 0 := by simp\n\n"}
{"name":"MeasureTheory.lintegral_zero_fun","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.lintegral μ 0) 0","decl":"theorem lintegral_zero_fun : lintegral μ (0 : α → ℝ≥0∞) = 0 :=\n  lintegral_zero\n\n"}
{"name":"MeasureTheory.lintegral_one","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.lintegral μ fun x => 1) (μ Set.univ)","decl":"theorem lintegral_one : ∫⁻ _, (1 : ℝ≥0∞) ∂μ = μ univ := by rw [lintegral_const, one_mul]\n\n"}
{"name":"MeasureTheory.setLIntegral_const","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nc : ENNReal\n⊢ Eq (MeasureTheory.lintegral (μ.restrict s) fun x => c) (HMul.hMul c (μ s))","decl":"theorem setLIntegral_const (s : Set α) (c : ℝ≥0∞) : ∫⁻ _ in s, c ∂μ = c * μ s := by\n  rw [lintegral_const, Measure.restrict_apply_univ]\n\n"}
{"name":"MeasureTheory.setLIntegral_one","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ Eq (MeasureTheory.lintegral (μ.restrict s) fun x => 1) (μ s)","decl":"theorem setLIntegral_one (s) : ∫⁻ _ in s, 1 ∂μ = μ s := by rw [setLIntegral_const, one_mul]\n\n"}
{"name":"MeasureTheory.setLIntegral_const_lt_top","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns : Set α\nc : ENNReal\nhc : Ne c Top.top\n⊢ LT.lt (MeasureTheory.lintegral (μ.restrict s) fun x => c) Top.top","decl":"theorem setLIntegral_const_lt_top [IsFiniteMeasure μ] (s : Set α) {c : ℝ≥0∞} (hc : c ≠ ∞) :\n    ∫⁻ _ in s, c ∂μ < ∞ := by\n  rw [lintegral_const]\n  exact ENNReal.mul_lt_top hc.lt_top (measure_lt_top (μ.restrict s) univ)\n\n"}
{"name":"MeasureTheory.lintegral_const_lt_top","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nc : ENNReal\nhc : Ne c Top.top\n⊢ LT.lt (MeasureTheory.lintegral μ fun x => c) Top.top","decl":"theorem lintegral_const_lt_top [IsFiniteMeasure μ] {c : ℝ≥0∞} (hc : c ≠ ∞) : ∫⁻ _, c ∂μ < ∞ := by\n  simpa only [Measure.restrict_univ] using setLIntegral_const_lt_top (univ : Set α) hc\n\n"}
{"name":"MeasureTheory.exists_measurable_le_lintegral_eq","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\n⊢ Exists fun g => And (Measurable g) (And (LE.le g f) (Eq (MeasureTheory.lintegral μ fun a => f a) (MeasureTheory.lintegral μ fun a => g a)))","decl":"/-- For any function `f : α → ℝ≥0∞`, there exists a measurable function `g ≤ f` with the same\nintegral. -/\ntheorem exists_measurable_le_lintegral_eq (f : α → ℝ≥0∞) :\n    ∃ g : α → ℝ≥0∞, Measurable g ∧ g ≤ f ∧ ∫⁻ a, f a ∂μ = ∫⁻ a, g a ∂μ := by\n  rcases eq_or_ne (∫⁻ a, f a ∂μ) 0 with h₀ | h₀\n  · exact ⟨0, measurable_zero, zero_le f, h₀.trans lintegral_zero.symm⟩\n  rcases exists_seq_strictMono_tendsto' h₀.bot_lt with ⟨L, _, hLf, hL_tendsto⟩\n  have : ∀ n, ∃ g : α → ℝ≥0∞, Measurable g ∧ g ≤ f ∧ L n < ∫⁻ a, g a ∂μ := by\n    intro n\n    simpa only [← iSup_lintegral_measurable_le_eq_lintegral f, lt_iSup_iff, exists_prop] using\n      (hLf n).2\n  choose g hgm hgf hLg using this\n  refine\n    ⟨fun x => ⨆ n, g n x, .iSup hgm, fun x => iSup_le fun n => hgf n x, le_antisymm ?_ ?_⟩\n  · refine le_of_tendsto' hL_tendsto fun n => (hLg n).le.trans <| lintegral_mono fun x => ?_\n    exact le_iSup (fun n => g n x) n\n  · exact lintegral_mono fun x => iSup_le fun n => hgf n x\n\n"}
{"name":"MeasureTheory.lintegral_eq_nnreal","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nf : α → ENNReal\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.lintegral μ fun a => f a) (iSup fun φ => iSup fun x => (MeasureTheory.SimpleFunc.map ENNReal.ofNNReal φ).lintegral μ)","decl":"/-- `∫⁻ a in s, f a ∂μ` is defined as the supremum of integrals of simple functions\n`φ : α →ₛ ℝ≥0∞` such that `φ ≤ f`. This lemma says that it suffices to take\nfunctions `φ : α →ₛ ℝ≥0`. -/\ntheorem lintegral_eq_nnreal {m : MeasurableSpace α} (f : α → ℝ≥0∞) (μ : Measure α) :\n    ∫⁻ a, f a ∂μ =\n      ⨆ (φ : α →ₛ ℝ≥0) (_ : ∀ x, ↑(φ x) ≤ f x), (φ.map ((↑) : ℝ≥0 → ℝ≥0∞)).lintegral μ := by\n  rw [lintegral]\n  refine\n    le_antisymm (iSup₂_le fun φ hφ ↦ ?_) (iSup_mono' fun φ ↦ ⟨φ.map ((↑) : ℝ≥0 → ℝ≥0∞), le_rfl⟩)\n  by_cases h : ∀ᵐ a ∂μ, φ a ≠ ∞\n  · let ψ := φ.map ENNReal.toNNReal\n    replace h : ψ.map ((↑) : ℝ≥0 → ℝ≥0∞) =ᵐ[μ] φ := h.mono fun a => ENNReal.coe_toNNReal\n    have : ∀ x, ↑(ψ x) ≤ f x := fun x => le_trans ENNReal.coe_toNNReal_le_self (hφ x)\n    exact le_iSup₂_of_le (φ.map ENNReal.toNNReal) this (ge_of_eq <| lintegral_congr h)\n  · have h_meas : μ (φ ⁻¹' {∞}) ≠ 0 := mt measure_zero_iff_ae_nmem.1 h\n    refine le_trans le_top (ge_of_eq <| (iSup_eq_top _).2 fun b hb => ?_)\n    obtain ⟨n, hn⟩ : ∃ n : ℕ, b < n * μ (φ ⁻¹' {∞}) := exists_nat_mul_gt h_meas (ne_of_lt hb)\n    use (const α (n : ℝ≥0)).restrict (φ ⁻¹' {∞})\n    simp only [lt_iSup_iff, exists_prop, coe_restrict, φ.measurableSet_preimage, coe_const,\n      ENNReal.coe_indicator, map_coe_ennreal_restrict, SimpleFunc.map_const, ENNReal.coe_natCast,\n      restrict_const_lintegral]\n    refine ⟨indicator_le fun x hx => le_trans ?_ (hφ _), hn⟩\n    simp only [mem_preimage, mem_singleton_iff] at hx\n    simp only [hx, le_top]\n\n"}
{"name":"MeasureTheory.exists_simpleFunc_forall_lintegral_sub_lt_of_pos","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nh : Ne (MeasureTheory.lintegral μ fun x => f x) Top.top\nε : ENNReal\nhε : Ne ε 0\n⊢ Exists fun φ => And (∀ (x : α), LE.le (↑(φ x)) (f x)) (∀ (ψ : MeasureTheory.SimpleFunc α NNReal), (∀ (x : α), LE.le (↑(ψ x)) (f x)) → LT.lt ((MeasureTheory.SimpleFunc.map ENNReal.ofNNReal (HSub.hSub ψ φ)).lintegral μ) ε)","decl":"theorem exists_simpleFunc_forall_lintegral_sub_lt_of_pos {f : α → ℝ≥0∞} (h : ∫⁻ x, f x ∂μ ≠ ∞)\n    {ε : ℝ≥0∞} (hε : ε ≠ 0) :\n    ∃ φ : α →ₛ ℝ≥0,\n      (∀ x, ↑(φ x) ≤ f x) ∧\n        ∀ ψ : α →ₛ ℝ≥0, (∀ x, ↑(ψ x) ≤ f x) → (map (↑) (ψ - φ)).lintegral μ < ε := by\n  rw [lintegral_eq_nnreal] at h\n  have := ENNReal.lt_add_right h hε\n  erw [ENNReal.biSup_add] at this <;> [skip; exact ⟨0, fun x => zero_le _⟩]\n  simp_rw [lt_iSup_iff, iSup_lt_iff, iSup_le_iff] at this\n  rcases this with ⟨φ, hle : ∀ x, ↑(φ x) ≤ f x, b, hbφ, hb⟩\n  refine ⟨φ, hle, fun ψ hψ => ?_⟩\n  have : (map (↑) φ).lintegral μ ≠ ∞ := ne_top_of_le_ne_top h (by exact le_iSup₂ (α := ℝ≥0∞) φ hle)\n  rw [← ENNReal.add_lt_add_iff_left this, ← add_lintegral, ← SimpleFunc.map_add @ENNReal.coe_add]\n  refine (hb _ fun x => le_trans ?_ (max_le (hle x) (hψ x))).trans_lt hbφ\n  norm_cast\n  simp only [add_apply, sub_apply, add_tsub_eq_max]\n  rfl\n\n"}
{"name":"MeasureTheory.iSup_lintegral_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nι : Sort u_5\nf : ι → α → ENNReal\n⊢ LE.le (iSup fun i => MeasureTheory.lintegral μ fun a => f i a) (MeasureTheory.lintegral μ fun a => iSup fun i => f i a)","decl":"theorem iSup_lintegral_le {ι : Sort*} (f : ι → α → ℝ≥0∞) :\n    ⨆ i, ∫⁻ a, f i a ∂μ ≤ ∫⁻ a, ⨆ i, f i a ∂μ := by\n  simp only [← iSup_apply]\n  exact (monotone_lintegral μ).le_map_iSup\n\n"}
{"name":"MeasureTheory.iSup₂_lintegral_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nι : Sort u_5\nι' : ι → Sort u_6\nf : (i : ι) → ι' i → α → ENNReal\n⊢ LE.le (iSup fun i => iSup fun j => MeasureTheory.lintegral μ fun a => f i j a) (MeasureTheory.lintegral μ fun a => iSup fun i => iSup fun j => f i j a)","decl":"theorem iSup₂_lintegral_le {ι : Sort*} {ι' : ι → Sort*} (f : ∀ i, ι' i → α → ℝ≥0∞) :\n    ⨆ (i) (j), ∫⁻ a, f i j a ∂μ ≤ ∫⁻ a, ⨆ (i) (j), f i j a ∂μ := by\n  convert (monotone_lintegral μ).le_map_iSup₂ f with a\n  simp only [iSup_apply]\n\n"}
{"name":"MeasureTheory.le_iInf_lintegral","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nι : Sort u_5\nf : ι → α → ENNReal\n⊢ LE.le (MeasureTheory.lintegral μ fun a => iInf fun i => f i a) (iInf fun i => MeasureTheory.lintegral μ fun a => f i a)","decl":"theorem le_iInf_lintegral {ι : Sort*} (f : ι → α → ℝ≥0∞) :\n    ∫⁻ a, ⨅ i, f i a ∂μ ≤ ⨅ i, ∫⁻ a, f i a ∂μ := by\n  simp only [← iInf_apply]\n  exact (monotone_lintegral μ).map_iInf_le\n\n"}
{"name":"MeasureTheory.le_iInf₂_lintegral","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nι : Sort u_5\nι' : ι → Sort u_6\nf : (i : ι) → ι' i → α → ENNReal\n⊢ LE.le (MeasureTheory.lintegral μ fun a => iInf fun i => iInf fun h => f i h a) (iInf fun i => iInf fun h => MeasureTheory.lintegral μ fun a => f i h a)","decl":"theorem le_iInf₂_lintegral {ι : Sort*} {ι' : ι → Sort*} (f : ∀ i, ι' i → α → ℝ≥0∞) :\n    ∫⁻ a, ⨅ (i) (h : ι' i), f i h a ∂μ ≤ ⨅ (i) (h : ι' i), ∫⁻ a, f i h a ∂μ := by\n  convert (monotone_lintegral μ).map_iInf₂_le f with a\n  simp only [iInf_apply]\n\n"}
{"name":"MeasureTheory.lintegral_mono_ae","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\nh : Filter.Eventually (fun a => LE.le (f a) (g a)) (MeasureTheory.ae μ)\n⊢ LE.le (MeasureTheory.lintegral μ fun a => f a) (MeasureTheory.lintegral μ fun a => g a)","decl":"theorem lintegral_mono_ae {f g : α → ℝ≥0∞} (h : ∀ᵐ a ∂μ, f a ≤ g a) :\n    ∫⁻ a, f a ∂μ ≤ ∫⁻ a, g a ∂μ := by\n  rcases exists_measurable_superset_of_null h with ⟨t, hts, ht, ht0⟩\n  have : ∀ᵐ x ∂μ, x ∉ t := measure_zero_iff_ae_nmem.1 ht0\n  rw [lintegral, lintegral]\n  refine iSup₂_le fun s hfs ↦ le_iSup₂_of_le (s.restrict tᶜ) ?_ ?_\n  · intro a\n    by_cases h : a ∈ t <;>\n      simp only [restrict_apply s ht.compl, mem_compl_iff, h, not_true, not_false_eq_true,\n        indicator_of_not_mem, zero_le, not_false_eq_true, indicator_of_mem]\n    exact le_trans (hfs a) (by_contradiction fun hnfg => h (hts hnfg))\n  · refine le_of_eq (SimpleFunc.lintegral_congr <| this.mono fun a hnt => ?_)\n    by_cases hat : a ∈ t <;> simp only [restrict_apply s ht.compl, mem_compl_iff, hat, not_true,\n      not_false_eq_true, indicator_of_not_mem, not_false_eq_true, indicator_of_mem]\n    exact (hnt hat).elim\n\n"}
{"name":"MeasureTheory.setLIntegral_mono_ae","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf g : α → ENNReal\nhg : AEMeasurable g (μ.restrict s)\nhfg : Filter.Eventually (fun x => Membership.mem s x → LE.le (f x) (g x)) (MeasureTheory.ae μ)\n⊢ LE.le (MeasureTheory.lintegral (μ.restrict s) fun x => f x) (MeasureTheory.lintegral (μ.restrict s) fun x => g x)","decl":"/-- Lebesgue integral over a set is monotone in function.\n\nThis version assumes that the upper estimate is an a.e. measurable function\nand the estimate holds a.e. on the set.\nSee also `setLIntegral_mono_ae'` for a version that assumes measurability of the set\nbut assumes no regularity of either function. -/\ntheorem setLIntegral_mono_ae {s : Set α} {f g : α → ℝ≥0∞} (hg : AEMeasurable g (μ.restrict s))\n    (hfg : ∀ᵐ x ∂μ, x ∈ s → f x ≤ g x) : ∫⁻ x in s, f x ∂μ ≤ ∫⁻ x in s, g x ∂μ := by\n  rcases exists_measurable_le_lintegral_eq (μ.restrict s) f with ⟨f', hf'm, hle, hf'⟩\n  rw [hf']\n  apply lintegral_mono_ae\n  rw [ae_restrict_iff₀]\n  · exact hfg.mono fun x hx hxs ↦ (hle x).trans (hx hxs)\n  · exact nullMeasurableSet_le hf'm.aemeasurable hg\n\n"}
{"name":"MeasureTheory.setLIntegral_mono","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf g : α → ENNReal\nhg : Measurable g\nhfg : ∀ (x : α), Membership.mem s x → LE.le (f x) (g x)\n⊢ LE.le (MeasureTheory.lintegral (μ.restrict s) fun x => f x) (MeasureTheory.lintegral (μ.restrict s) fun x => g x)","decl":"theorem setLIntegral_mono {s : Set α} {f g : α → ℝ≥0∞} (hg : Measurable g)\n    (hfg : ∀ x ∈ s, f x ≤ g x) : ∫⁻ x in s, f x ∂μ ≤ ∫⁻ x in s, g x ∂μ :=\n  setLIntegral_mono_ae hg.aemeasurable (ae_of_all _ hfg)\n\n"}
{"name":"MeasureTheory.setLIntegral_mono_ae'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf g : α → ENNReal\nhs : MeasurableSet s\nhfg : Filter.Eventually (fun x => Membership.mem s x → LE.le (f x) (g x)) (MeasureTheory.ae μ)\n⊢ LE.le (MeasureTheory.lintegral (μ.restrict s) fun x => f x) (MeasureTheory.lintegral (μ.restrict s) fun x => g x)","decl":"theorem setLIntegral_mono_ae' {s : Set α} {f g : α → ℝ≥0∞} (hs : MeasurableSet s)\n    (hfg : ∀ᵐ x ∂μ, x ∈ s → f x ≤ g x) : ∫⁻ x in s, f x ∂μ ≤ ∫⁻ x in s, g x ∂μ :=\n  lintegral_mono_ae <| (ae_restrict_iff' hs).2 hfg\n\n"}
{"name":"MeasureTheory.setLIntegral_mono'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf g : α → ENNReal\nhs : MeasurableSet s\nhfg : ∀ (x : α), Membership.mem s x → LE.le (f x) (g x)\n⊢ LE.le (MeasureTheory.lintegral (μ.restrict s) fun x => f x) (MeasureTheory.lintegral (μ.restrict s) fun x => g x)","decl":"theorem setLIntegral_mono' {s : Set α} {f g : α → ℝ≥0∞} (hs : MeasurableSet s)\n    (hfg : ∀ x ∈ s, f x ≤ g x) : ∫⁻ x in s, f x ∂μ ≤ ∫⁻ x in s, g x ∂μ :=\n  setLIntegral_mono_ae' hs (ae_of_all _ hfg)\n\n"}
{"name":"MeasureTheory.setLIntegral_le_lintegral","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf : α → ENNReal\n⊢ LE.le (MeasureTheory.lintegral (μ.restrict s) fun x => f x) (MeasureTheory.lintegral μ fun x => f x)","decl":"theorem setLIntegral_le_lintegral (s : Set α) (f : α → ℝ≥0∞) :\n    ∫⁻ x in s, f x ∂μ ≤ ∫⁻ x, f x ∂μ :=\n  lintegral_mono' Measure.restrict_le_self le_rfl\n\n"}
{"name":"MeasureTheory.lintegral_congr_ae","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\nh : (MeasureTheory.ae μ).EventuallyEq f g\n⊢ Eq (MeasureTheory.lintegral μ fun a => f a) (MeasureTheory.lintegral μ fun a => g a)","decl":"theorem lintegral_congr_ae {f g : α → ℝ≥0∞} (h : f =ᵐ[μ] g) : ∫⁻ a, f a ∂μ = ∫⁻ a, g a ∂μ :=\n  le_antisymm (lintegral_mono_ae <| h.le) (lintegral_mono_ae <| h.symm.le)\n\n"}
{"name":"MeasureTheory.lintegral_congr","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\nh : ∀ (a : α), Eq (f a) (g a)\n⊢ Eq (MeasureTheory.lintegral μ fun a => f a) (MeasureTheory.lintegral μ fun a => g a)","decl":"theorem lintegral_congr {f g : α → ℝ≥0∞} (h : ∀ a, f a = g a) : ∫⁻ a, f a ∂μ = ∫⁻ a, g a ∂μ := by\n  simp only [h]\n\n"}
{"name":"MeasureTheory.setLIntegral_congr","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\ns t : Set α\nh : (MeasureTheory.ae μ).EventuallyEq s t\n⊢ Eq (MeasureTheory.lintegral (μ.restrict s) fun x => f x) (MeasureTheory.lintegral (μ.restrict t) fun x => f x)","decl":"theorem setLIntegral_congr {f : α → ℝ≥0∞} {s t : Set α} (h : s =ᵐ[μ] t) :\n    ∫⁻ x in s, f x ∂μ = ∫⁻ x in t, f x ∂μ := by rw [Measure.restrict_congr_set h]\n\n"}
{"name":"MeasureTheory.setLIntegral_congr_fun","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\ns : Set α\nhs : MeasurableSet s\nhfg : Filter.Eventually (fun x => Membership.mem s x → Eq (f x) (g x)) (MeasureTheory.ae μ)\n⊢ Eq (MeasureTheory.lintegral (μ.restrict s) fun x => f x) (MeasureTheory.lintegral (μ.restrict s) fun x => g x)","decl":"theorem setLIntegral_congr_fun {f g : α → ℝ≥0∞} {s : Set α} (hs : MeasurableSet s)\n    (hfg : ∀ᵐ x ∂μ, x ∈ s → f x = g x) : ∫⁻ x in s, f x ∂μ = ∫⁻ x in s, g x ∂μ := by\n  rw [lintegral_congr_ae]\n  rw [EventuallyEq]\n  rwa [ae_restrict_iff' hs]\n\n"}
{"name":"MeasureTheory.lintegral_ofReal_le_lintegral_enorm","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\n⊢ LE.le (MeasureTheory.lintegral μ fun x => ENNReal.ofReal (f x)) (MeasureTheory.lintegral μ fun x => ENorm.enorm (f x))","decl":"theorem lintegral_ofReal_le_lintegral_enorm (f : α → ℝ) :\n    ∫⁻ x, ENNReal.ofReal (f x) ∂μ ≤ ∫⁻ x, ‖f x‖ₑ ∂μ := by\n  simp_rw [← ofReal_norm_eq_enorm]\n  refine lintegral_mono fun x => ENNReal.ofReal_le_ofReal ?_\n  rw [Real.norm_eq_abs]\n  exact le_abs_self (f x)\n\n"}
{"name":"MeasureTheory.lintegral_ofReal_le_lintegral_nnnorm","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\n⊢ LE.le (MeasureTheory.lintegral μ fun x => ENNReal.ofReal (f x)) (MeasureTheory.lintegral μ fun x => ENorm.enorm (f x))","decl":"@[deprecated (since := \"2025-01-17\")]\nalias lintegral_ofReal_le_lintegral_nnnorm := lintegral_ofReal_le_lintegral_enorm\n\n"}
{"name":"MeasureTheory.lintegral_enorm_of_ae_nonneg","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nh_nonneg : (MeasureTheory.ae μ).EventuallyLE 0 f\n⊢ Eq (MeasureTheory.lintegral μ fun x => ENorm.enorm (f x)) (MeasureTheory.lintegral μ fun x => ENNReal.ofReal (f x))","decl":"theorem lintegral_enorm_of_ae_nonneg {f : α → ℝ} (h_nonneg : 0 ≤ᵐ[μ] f) :\n    ∫⁻ x, ‖f x‖ₑ ∂μ = ∫⁻ x, .ofReal (f x) ∂μ := by\n  apply lintegral_congr_ae\n  filter_upwards [h_nonneg] with x hx\n  rw [Real.enorm_eq_ofReal hx]\n\n"}
{"name":"MeasureTheory.lintegral_nnnorm_eq_of_ae_nonneg","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nh_nonneg : (MeasureTheory.ae μ).EventuallyLE 0 f\n⊢ Eq (MeasureTheory.lintegral μ fun x => ENorm.enorm (f x)) (MeasureTheory.lintegral μ fun x => ENNReal.ofReal (f x))","decl":"@[deprecated (since := \"2025-01-17\")]\nalias lintegral_nnnorm_eq_of_ae_nonneg := lintegral_enorm_of_ae_nonneg\n\n"}
{"name":"MeasureTheory.lintegral_enorm_of_nonneg","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nh_nonneg : LE.le 0 f\n⊢ Eq (MeasureTheory.lintegral μ fun x => ENorm.enorm (f x)) (MeasureTheory.lintegral μ fun x => ENNReal.ofReal (f x))","decl":"theorem lintegral_enorm_of_nonneg {f : α → ℝ} (h_nonneg : 0 ≤ f) :\n    ∫⁻ x, ‖f x‖ₑ ∂μ = ∫⁻ x, .ofReal (f x) ∂μ :=\n  lintegral_enorm_of_ae_nonneg <| .of_forall h_nonneg\n\n"}
{"name":"MeasureTheory.lintegral_nnnorm_eq_of_nonneg","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nh_nonneg : LE.le 0 f\n⊢ Eq (MeasureTheory.lintegral μ fun x => ENorm.enorm (f x)) (MeasureTheory.lintegral μ fun x => ENNReal.ofReal (f x))","decl":"@[deprecated (since := \"2025-01-17\")]\nalias lintegral_nnnorm_eq_of_nonneg := lintegral_enorm_of_nonneg\n\n"}
{"name":"MeasureTheory.lintegral_iSup","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : Nat → α → ENNReal\nhf : ∀ (n : Nat), Measurable (f n)\nh_mono : Monotone f\n⊢ Eq (MeasureTheory.lintegral μ fun a => iSup fun n => f n a) (iSup fun n => MeasureTheory.lintegral μ fun a => f n a)","decl":"/-- **Monotone convergence theorem** -- sometimes called **Beppo-Levi convergence**.\nSee `lintegral_iSup_directed` for a more general form. -/\ntheorem lintegral_iSup {f : ℕ → α → ℝ≥0∞} (hf : ∀ n, Measurable (f n)) (h_mono : Monotone f) :\n    ∫⁻ a, ⨆ n, f n a ∂μ = ⨆ n, ∫⁻ a, f n a ∂μ := by\n  set c : ℝ≥0 → ℝ≥0∞ := (↑)\n  set F := fun a : α => ⨆ n, f n a\n  refine le_antisymm ?_ (iSup_lintegral_le _)\n  rw [lintegral_eq_nnreal]\n  refine iSup_le fun s => iSup_le fun hsf => ?_\n  refine ENNReal.le_of_forall_lt_one_mul_le fun a ha => ?_\n  rcases ENNReal.lt_iff_exists_coe.1 ha with ⟨r, rfl, _⟩\n  have ha : r < 1 := ENNReal.coe_lt_coe.1 ha\n  let rs := s.map fun a => r * a\n  have eq_rs : rs.map c = (const α r : α →ₛ ℝ≥0∞) * map c s := rfl\n  have eq : ∀ p, rs.map c ⁻¹' {p} = ⋃ n, rs.map c ⁻¹' {p} ∩ { a | p ≤ f n a } := by\n    intro p\n    rw [← inter_iUnion]; nth_rw 1 [← inter_univ (map c rs ⁻¹' {p})]\n    refine Set.ext fun x => and_congr_right fun hx => (iff_of_eq (true_iff _)).2 ?_\n    by_cases p_eq : p = 0\n    · simp [p_eq]\n    simp only [coe_map, mem_preimage, Function.comp_apply, mem_singleton_iff] at hx\n    subst hx\n    have : r * s x ≠ 0 := by rwa [Ne, ← ENNReal.coe_eq_zero]\n    have : s x ≠ 0 := right_ne_zero_of_mul this\n    have : (rs.map c) x < ⨆ n : ℕ, f n x := by\n      refine lt_of_lt_of_le (ENNReal.coe_lt_coe.2 ?_) (hsf x)\n      suffices r * s x < 1 * s x by simpa\n      exact mul_lt_mul_of_pos_right ha (pos_iff_ne_zero.2 this)\n    rcases lt_iSup_iff.1 this with ⟨i, hi⟩\n    exact mem_iUnion.2 ⟨i, le_of_lt hi⟩\n  have mono : ∀ r : ℝ≥0∞, Monotone fun n => rs.map c ⁻¹' {r} ∩ { a | r ≤ f n a } := by\n    intro r i j h\n    refine inter_subset_inter_right _ ?_\n    simp_rw [subset_def, mem_setOf]\n    intro x hx\n    exact le_trans hx (h_mono h x)\n  have h_meas : ∀ n, MeasurableSet {a : α | map c rs a ≤ f n a} := fun n =>\n    measurableSet_le (SimpleFunc.measurable _) (hf n)\n  calc\n    (r : ℝ≥0∞) * (s.map c).lintegral μ = ∑ r ∈ (rs.map c).range, r * μ (rs.map c ⁻¹' {r}) := by\n      rw [← const_mul_lintegral, eq_rs, SimpleFunc.lintegral]\n    _ = ∑ r ∈ (rs.map c).range, r * μ (⋃ n, rs.map c ⁻¹' {r} ∩ { a | r ≤ f n a }) := by\n      simp only [(eq _).symm]\n    _ = ∑ r ∈ (rs.map c).range, ⨆ n, r * μ (rs.map c ⁻¹' {r} ∩ { a | r ≤ f n a }) :=\n      Finset.sum_congr rfl fun x _ => by rw [(mono x).measure_iUnion, ENNReal.mul_iSup]\n    _ = ⨆ n, ∑ r ∈ (rs.map c).range, r * μ (rs.map c ⁻¹' {r} ∩ { a | r ≤ f n a }) := by\n      refine ENNReal.finsetSum_iSup_of_monotone fun p i j h ↦ ?_\n      gcongr _ * μ ?_\n      exact mono p h\n    _ ≤ ⨆ n : ℕ, ((rs.map c).restrict { a | (rs.map c) a ≤ f n a }).lintegral μ := by\n      gcongr with n\n      rw [restrict_lintegral _ (h_meas n)]\n      refine le_of_eq (Finset.sum_congr rfl fun r _ => ?_)\n      congr 2 with a\n      refine and_congr_right ?_\n      simp +contextual\n    _ ≤ ⨆ n, ∫⁻ a, f n a ∂μ := by\n      simp only [← SimpleFunc.lintegral_eq_lintegral]\n      gcongr with n a\n      simp only [map_apply] at h_meas\n      simp only [coe_map, restrict_apply _ (h_meas _), (· ∘ ·)]\n      exact indicator_apply_le id\n\n"}
{"name":"MeasureTheory.lintegral_iSup'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : Nat → α → ENNReal\nhf : ∀ (n : Nat), AEMeasurable (f n) μ\nh_mono : Filter.Eventually (fun x => Monotone fun n => f n x) (MeasureTheory.ae μ)\n⊢ Eq (MeasureTheory.lintegral μ fun a => iSup fun n => f n a) (iSup fun n => MeasureTheory.lintegral μ fun a => f n a)","decl":"/-- Monotone convergence theorem -- sometimes called Beppo-Levi convergence. Version with\nae_measurable functions. -/\ntheorem lintegral_iSup' {f : ℕ → α → ℝ≥0∞} (hf : ∀ n, AEMeasurable (f n) μ)\n    (h_mono : ∀ᵐ x ∂μ, Monotone fun n => f n x) : ∫⁻ a, ⨆ n, f n a ∂μ = ⨆ n, ∫⁻ a, f n a ∂μ := by\n  simp_rw [← iSup_apply]\n  let p : α → (ℕ → ℝ≥0∞) → Prop := fun _ f' => Monotone f'\n  have hp : ∀ᵐ x ∂μ, p x fun i => f i x := h_mono\n  have h_ae_seq_mono : Monotone (aeSeq hf p) := by\n    intro n m hnm x\n    by_cases hx : x ∈ aeSeqSet hf p\n    · exact aeSeq.prop_of_mem_aeSeqSet hf hx hnm\n    · simp only [aeSeq, hx, if_false, le_rfl]\n  rw [lintegral_congr_ae (aeSeq.iSup hf hp).symm]\n  simp_rw [iSup_apply]\n  rw [lintegral_iSup (aeSeq.measurable hf p) h_ae_seq_mono]\n  congr with n\n  exact lintegral_congr_ae (aeSeq.aeSeq_n_eq_fun_n_ae hf hp n)\n\n"}
{"name":"MeasureTheory.lintegral_tendsto_of_tendsto_of_monotone","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : Nat → α → ENNReal\nF : α → ENNReal\nhf : ∀ (n : Nat), AEMeasurable (f n) μ\nh_mono : Filter.Eventually (fun x => Monotone fun n => f n x) (MeasureTheory.ae μ)\nh_tendsto : Filter.Eventually (fun x => Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) (MeasureTheory.ae μ)\n⊢ Filter.Tendsto (fun n => MeasureTheory.lintegral μ fun x => f n x) Filter.atTop (nhds (MeasureTheory.lintegral μ fun x => F x))","decl":"/-- Monotone convergence theorem expressed with limits -/\ntheorem lintegral_tendsto_of_tendsto_of_monotone {f : ℕ → α → ℝ≥0∞} {F : α → ℝ≥0∞}\n    (hf : ∀ n, AEMeasurable (f n) μ) (h_mono : ∀ᵐ x ∂μ, Monotone fun n => f n x)\n    (h_tendsto : ∀ᵐ x ∂μ, Tendsto (fun n => f n x) atTop (𝓝 <| F x)) :\n    Tendsto (fun n => ∫⁻ x, f n x ∂μ) atTop (𝓝 <| ∫⁻ x, F x ∂μ) := by\n  have : Monotone fun n => ∫⁻ x, f n x ∂μ := fun i j hij =>\n    lintegral_mono_ae (h_mono.mono fun x hx => hx hij)\n  suffices key : ∫⁻ x, F x ∂μ = ⨆ n, ∫⁻ x, f n x ∂μ by\n    rw [key]\n    exact tendsto_atTop_iSup this\n  rw [← lintegral_iSup' hf h_mono]\n  refine lintegral_congr_ae ?_\n  filter_upwards [h_mono, h_tendsto] with _ hx_mono hx_tendsto using\n    tendsto_nhds_unique hx_tendsto (tendsto_atTop_iSup hx_mono)\n\n"}
{"name":"MeasureTheory.lintegral_eq_iSup_eapprox_lintegral","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : Measurable f\n⊢ Eq (MeasureTheory.lintegral μ fun a => f a) (iSup fun n => (MeasureTheory.SimpleFunc.eapprox f n).lintegral μ)","decl":"theorem lintegral_eq_iSup_eapprox_lintegral {f : α → ℝ≥0∞} (hf : Measurable f) :\n    ∫⁻ a, f a ∂μ = ⨆ n, (eapprox f n).lintegral μ :=\n  calc\n    ∫⁻ a, f a ∂μ = ∫⁻ a, ⨆ n, (eapprox f n : α → ℝ≥0∞) a ∂μ := by\n      congr; ext a; rw [iSup_eapprox_apply hf]\n    _ = ⨆ n, ∫⁻ a, (eapprox f n : α → ℝ≥0∞) a ∂μ := by\n      apply lintegral_iSup\n      · measurability\n      · intro i j h\n        exact monotone_eapprox f h\n    _ = ⨆ n, (eapprox f n).lintegral μ := by\n      congr; ext n; rw [(eapprox f n).lintegral_eq_lintegral]\n\n"}
{"name":"MeasureTheory.lintegral_eapprox_le_lintegral","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : Measurable f\nn : Nat\n⊢ LE.le ((MeasureTheory.SimpleFunc.eapprox f n).lintegral μ) (MeasureTheory.lintegral μ fun x => f x)","decl":"lemma lintegral_eapprox_le_lintegral {f : α → ℝ≥0∞} (hf : Measurable f) (n : ℕ) :\n    (eapprox f n).lintegral μ ≤ ∫⁻ x, f x ∂μ := by\n  rw [lintegral_eq_iSup_eapprox_lintegral hf]\n  exact le_iSup (fun n ↦ (eapprox f n).lintegral μ) n\n\n"}
{"name":"MeasureTheory.measure_support_eapprox_lt_top","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf_meas : Measurable f\nhf : Ne (MeasureTheory.lintegral μ fun x => f x) Top.top\nn : Nat\n⊢ LT.lt (μ (Function.support ⇑(MeasureTheory.SimpleFunc.eapprox f n))) Top.top","decl":"lemma measure_support_eapprox_lt_top {f : α → ℝ≥0∞} (hf_meas : Measurable f)\n    (hf : ∫⁻ x, f x ∂μ ≠ ∞) (n : ℕ) :\n    μ (support (eapprox f n)) < ∞ :=\n  measure_support_lt_top_of_lintegral_ne_top <|\n    ((lintegral_eapprox_le_lintegral hf_meas n).trans_lt hf.lt_top).ne\n\n"}
{"name":"MeasureTheory.exists_pos_setLIntegral_lt_of_measure_lt","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nh : Ne (MeasureTheory.lintegral μ fun x => f x) Top.top\nε : ENNReal\nhε : Ne ε 0\n⊢ Exists fun δ => And (GT.gt δ 0) (∀ (s : Set α), LT.lt (μ s) δ → LT.lt (MeasureTheory.lintegral (μ.restrict s) fun x => f x) ε)","decl":"/-- If `f` has finite integral, then `∫⁻ x in s, f x ∂μ` is absolutely continuous in `s`: it tends\nto zero as `μ s` tends to zero. This lemma states this fact in terms of `ε` and `δ`. -/\ntheorem exists_pos_setLIntegral_lt_of_measure_lt {f : α → ℝ≥0∞} (h : ∫⁻ x, f x ∂μ ≠ ∞) {ε : ℝ≥0∞}\n    (hε : ε ≠ 0) : ∃ δ > 0, ∀ s, μ s < δ → ∫⁻ x in s, f x ∂μ < ε := by\n  rcases exists_between (pos_iff_ne_zero.mpr hε) with ⟨ε₂, hε₂0, hε₂ε⟩\n  rcases exists_between hε₂0 with ⟨ε₁, hε₁0, hε₁₂⟩\n  rcases exists_simpleFunc_forall_lintegral_sub_lt_of_pos h hε₁0.ne' with ⟨φ, _, hφ⟩\n  rcases φ.exists_forall_le with ⟨C, hC⟩\n  use (ε₂ - ε₁) / C, ENNReal.div_pos_iff.2 ⟨(tsub_pos_iff_lt.2 hε₁₂).ne', ENNReal.coe_ne_top⟩\n  refine fun s hs => lt_of_le_of_lt ?_ hε₂ε\n  simp only [lintegral_eq_nnreal, iSup_le_iff]\n  intro ψ hψ\n  calc\n    (map (↑) ψ).lintegral (μ.restrict s) ≤\n        (map (↑) φ).lintegral (μ.restrict s) + (map (↑) (ψ - φ)).lintegral (μ.restrict s) := by\n      rw [← SimpleFunc.add_lintegral, ← SimpleFunc.map_add @ENNReal.coe_add]\n      refine SimpleFunc.lintegral_mono (fun x => ?_) le_rfl\n      simp only [add_tsub_eq_max, le_max_right, coe_map, Function.comp_apply, SimpleFunc.coe_add,\n        SimpleFunc.coe_sub, Pi.add_apply, Pi.sub_apply, ENNReal.coe_max (φ x) (ψ x)]\n    _ ≤ (map (↑) φ).lintegral (μ.restrict s) + ε₁ := by\n      gcongr\n      refine le_trans ?_ (hφ _ hψ).le\n      exact SimpleFunc.lintegral_mono le_rfl Measure.restrict_le_self\n    _ ≤ (SimpleFunc.const α (C : ℝ≥0∞)).lintegral (μ.restrict s) + ε₁ := by\n      gcongr\n      exact fun x ↦ ENNReal.coe_le_coe.2 (hC x)\n    _ = C * μ s + ε₁ := by\n      simp only [← SimpleFunc.lintegral_eq_lintegral, coe_const, lintegral_const,\n        Measure.restrict_apply, MeasurableSet.univ, univ_inter, Function.const]\n    _ ≤ C * ((ε₂ - ε₁) / C) + ε₁ := by gcongr\n    _ ≤ ε₂ - ε₁ + ε₁ := by gcongr; apply mul_div_le\n    _ = ε₂ := tsub_add_cancel_of_le hε₁₂.le\n\n"}
{"name":"MeasureTheory.tendsto_setLIntegral_zero","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nι : Type u_5\nf : α → ENNReal\nh : Ne (MeasureTheory.lintegral μ fun x => f x) Top.top\nl : Filter ι\ns : ι → Set α\nhl : Filter.Tendsto (Function.comp (⇑μ) s) l (nhds 0)\n⊢ Filter.Tendsto (fun i => MeasureTheory.lintegral (μ.restrict (s i)) fun x => f x) l (nhds 0)","decl":"/-- If `f` has finite integral, then `∫⁻ x in s, f x ∂μ` is absolutely continuous in `s`: it tends\nto zero as `μ s` tends to zero. -/\ntheorem tendsto_setLIntegral_zero {ι} {f : α → ℝ≥0∞} (h : ∫⁻ x, f x ∂μ ≠ ∞) {l : Filter ι}\n    {s : ι → Set α} (hl : Tendsto (μ ∘ s) l (𝓝 0)) :\n    Tendsto (fun i => ∫⁻ x in s i, f x ∂μ) l (𝓝 0) := by\n  simp only [ENNReal.nhds_zero, tendsto_iInf, tendsto_principal, mem_Iio,\n    ← pos_iff_ne_zero] at hl ⊢\n  intro ε ε0\n  rcases exists_pos_setLIntegral_lt_of_measure_lt h ε0.ne' with ⟨δ, δ0, hδ⟩\n  exact (hl δ δ0).mono fun i => hδ _\n\n"}
{"name":"MeasureTheory.le_lintegral_add","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\n⊢ LE.le (HAdd.hAdd (MeasureTheory.lintegral μ fun a => f a) (MeasureTheory.lintegral μ fun a => g a)) (MeasureTheory.lintegral μ fun a => HAdd.hAdd (f a) (g a))","decl":"/-- The sum of the lower Lebesgue integrals of two functions is less than or equal to the integral\nof their sum. The other inequality needs one of these functions to be (a.e.-)measurable. -/\ntheorem le_lintegral_add (f g : α → ℝ≥0∞) :\n    ∫⁻ a, f a ∂μ + ∫⁻ a, g a ∂μ ≤ ∫⁻ a, f a + g a ∂μ := by\n  simp only [lintegral]\n  refine ENNReal.biSup_add_biSup_le' (p := fun h : α →ₛ ℝ≥0∞ => h ≤ f)\n    (q := fun h : α →ₛ ℝ≥0∞ => h ≤ g) ⟨0, zero_le f⟩ ⟨0, zero_le g⟩ fun f' hf' g' hg' => ?_\n  exact le_iSup₂_of_le (f' + g') (add_le_add hf' hg') (add_lintegral _ _).ge\n\n-- Use stronger lemmas `lintegral_add_left`/`lintegral_add_right` instead\n"}
{"name":"MeasureTheory.lintegral_add_aux","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\nhf : Measurable f\nhg : Measurable g\n⊢ Eq (MeasureTheory.lintegral μ fun a => HAdd.hAdd (f a) (g a)) (HAdd.hAdd (MeasureTheory.lintegral μ fun a => f a) (MeasureTheory.lintegral μ fun a => g a))","decl":"theorem lintegral_add_aux {f g : α → ℝ≥0∞} (hf : Measurable f) (hg : Measurable g) :\n    ∫⁻ a, f a + g a ∂μ = ∫⁻ a, f a ∂μ + ∫⁻ a, g a ∂μ :=\n  calc\n    ∫⁻ a, f a + g a ∂μ =\n        ∫⁻ a, (⨆ n, (eapprox f n : α → ℝ≥0∞) a) + ⨆ n, (eapprox g n : α → ℝ≥0∞) a ∂μ := by\n      simp only [iSup_eapprox_apply, hf, hg]\n    _ = ∫⁻ a, ⨆ n, (eapprox f n + eapprox g n : α → ℝ≥0∞) a ∂μ := by\n      congr; funext a\n      rw [ENNReal.iSup_add_iSup_of_monotone]\n      · simp only [Pi.add_apply]\n      · intro i j h\n        exact monotone_eapprox _ h a\n      · intro i j h\n        exact monotone_eapprox _ h a\n    _ = ⨆ n, (eapprox f n).lintegral μ + (eapprox g n).lintegral μ := by\n      rw [lintegral_iSup]\n      · congr\n        funext n\n        rw [← SimpleFunc.add_lintegral, ← SimpleFunc.lintegral_eq_lintegral]\n        simp only [Pi.add_apply, SimpleFunc.coe_add]\n      · fun_prop\n      · intro i j h a\n        dsimp\n        gcongr <;> exact monotone_eapprox _ h _\n    _ = (⨆ n, (eapprox f n).lintegral μ) + ⨆ n, (eapprox g n).lintegral μ := by\n      refine (ENNReal.iSup_add_iSup_of_monotone ?_ ?_).symm <;>\n        · intro i j h\n          exact SimpleFunc.lintegral_mono (monotone_eapprox _ h) le_rfl\n    _ = ∫⁻ a, f a ∂μ + ∫⁻ a, g a ∂μ := by\n      rw [lintegral_eq_iSup_eapprox_lintegral hf, lintegral_eq_iSup_eapprox_lintegral hg]\n\n"}
{"name":"MeasureTheory.lintegral_add_left","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : Measurable f\ng : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral μ fun a => HAdd.hAdd (f a) (g a)) (HAdd.hAdd (MeasureTheory.lintegral μ fun a => f a) (MeasureTheory.lintegral μ fun a => g a))","decl":"/-- If `f g : α → ℝ≥0∞` are two functions and one of them is (a.e.) measurable, then the Lebesgue\nintegral of `f + g` equals the sum of integrals. This lemma assumes that `f` is integrable, see also\n`MeasureTheory.lintegral_add_right` and primed versions of these lemmas. -/\n@[simp]\ntheorem lintegral_add_left {f : α → ℝ≥0∞} (hf : Measurable f) (g : α → ℝ≥0∞) :\n    ∫⁻ a, f a + g a ∂μ = ∫⁻ a, f a ∂μ + ∫⁻ a, g a ∂μ := by\n  refine le_antisymm ?_ (le_lintegral_add _ _)\n  rcases exists_measurable_le_lintegral_eq μ fun a => f a + g a with ⟨φ, hφm, hφ_le, hφ_eq⟩\n  calc\n    ∫⁻ a, f a + g a ∂μ = ∫⁻ a, φ a ∂μ := hφ_eq\n    _ ≤ ∫⁻ a, f a + (φ a - f a) ∂μ := lintegral_mono fun a => le_add_tsub\n    _ = ∫⁻ a, f a ∂μ + ∫⁻ a, φ a - f a ∂μ := lintegral_add_aux hf (hφm.sub hf)\n    _ ≤ ∫⁻ a, f a ∂μ + ∫⁻ a, g a ∂μ :=\n      add_le_add_left (lintegral_mono fun a => tsub_le_iff_left.2 <| hφ_le a) _\n\n"}
{"name":"MeasureTheory.lintegral_add_left'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : AEMeasurable f μ\ng : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral μ fun a => HAdd.hAdd (f a) (g a)) (HAdd.hAdd (MeasureTheory.lintegral μ fun a => f a) (MeasureTheory.lintegral μ fun a => g a))","decl":"theorem lintegral_add_left' {f : α → ℝ≥0∞} (hf : AEMeasurable f μ) (g : α → ℝ≥0∞) :\n    ∫⁻ a, f a + g a ∂μ = ∫⁻ a, f a ∂μ + ∫⁻ a, g a ∂μ := by\n  rw [lintegral_congr_ae hf.ae_eq_mk, ← lintegral_add_left hf.measurable_mk,\n    lintegral_congr_ae (hf.ae_eq_mk.add (ae_eq_refl g))]\n\n"}
{"name":"MeasureTheory.lintegral_add_right'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\nhg : AEMeasurable g μ\n⊢ Eq (MeasureTheory.lintegral μ fun a => HAdd.hAdd (f a) (g a)) (HAdd.hAdd (MeasureTheory.lintegral μ fun a => f a) (MeasureTheory.lintegral μ fun a => g a))","decl":"theorem lintegral_add_right' (f : α → ℝ≥0∞) {g : α → ℝ≥0∞} (hg : AEMeasurable g μ) :\n    ∫⁻ a, f a + g a ∂μ = ∫⁻ a, f a ∂μ + ∫⁻ a, g a ∂μ := by\n  simpa only [add_comm] using lintegral_add_left' hg f\n\n"}
{"name":"MeasureTheory.lintegral_add_right","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\nhg : Measurable g\n⊢ Eq (MeasureTheory.lintegral μ fun a => HAdd.hAdd (f a) (g a)) (HAdd.hAdd (MeasureTheory.lintegral μ fun a => f a) (MeasureTheory.lintegral μ fun a => g a))","decl":"/-- If `f g : α → ℝ≥0∞` are two functions and one of them is (a.e.) measurable, then the Lebesgue\nintegral of `f + g` equals the sum of integrals. This lemma assumes that `g` is integrable, see also\n`MeasureTheory.lintegral_add_left` and primed versions of these lemmas. -/\n@[simp]\ntheorem lintegral_add_right (f : α → ℝ≥0∞) {g : α → ℝ≥0∞} (hg : Measurable g) :\n    ∫⁻ a, f a + g a ∂μ = ∫⁻ a, f a ∂μ + ∫⁻ a, g a ∂μ :=\n  lintegral_add_right' f hg.aemeasurable\n\n"}
{"name":"MeasureTheory.lintegral_smul_measure","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nc : ENNReal\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral (HSMul.hSMul c μ) fun a => f a) (HMul.hMul c (MeasureTheory.lintegral μ fun a => f a))","decl":"@[simp]\ntheorem lintegral_smul_measure (c : ℝ≥0∞) (f : α → ℝ≥0∞) : ∫⁻ a, f a ∂c • μ = c * ∫⁻ a, f a ∂μ := by\n  simp only [lintegral, iSup_subtype', SimpleFunc.lintegral_smul, ENNReal.mul_iSup, smul_eq_mul]\n\n"}
{"name":"MeasureTheory.setLIntegral_smul_measure","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nc : ENNReal\nf : α → ENNReal\ns : Set α\n⊢ Eq (MeasureTheory.lintegral ((HSMul.hSMul c μ).restrict s) fun a => f a) (HMul.hMul c (MeasureTheory.lintegral (μ.restrict s) fun a => f a))","decl":"lemma setLIntegral_smul_measure (c : ℝ≥0∞) (f : α → ℝ≥0∞) (s : Set α) :\n    ∫⁻ a in s, f a ∂(c • μ) = c * ∫⁻ a in s, f a ∂μ := by\n  rw [Measure.restrict_smul, lintegral_smul_measure]\n\n"}
{"name":"MeasureTheory.lintegral_zero_measure","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral 0 fun a => f a) 0","decl":"@[simp]\ntheorem lintegral_zero_measure {m : MeasurableSpace α} (f : α → ℝ≥0∞) :\n    ∫⁻ a, f a ∂(0 : Measure α) = 0 := by\n  simp [lintegral]\n\n"}
{"name":"MeasureTheory.lintegral_add_measure","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nf : α → ENNReal\nμ ν : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.lintegral (HAdd.hAdd μ ν) fun a => f a) (HAdd.hAdd (MeasureTheory.lintegral μ fun a => f a) (MeasureTheory.lintegral ν fun a => f a))","decl":"@[simp]\ntheorem lintegral_add_measure (f : α → ℝ≥0∞) (μ ν : Measure α) :\n    ∫⁻ a, f a ∂(μ + ν) = ∫⁻ a, f a ∂μ + ∫⁻ a, f a ∂ν := by\n  simp only [lintegral, SimpleFunc.lintegral_add, iSup_subtype']\n  refine (ENNReal.iSup_add_iSup ?_).symm\n  rintro ⟨φ, hφ⟩ ⟨ψ, hψ⟩\n  refine ⟨⟨φ ⊔ ψ, sup_le hφ hψ⟩, ?_⟩\n  apply_rules [add_le_add, SimpleFunc.lintegral_mono, le_rfl] -- TODO: use `gcongr`\n  exacts [le_sup_left, le_sup_right]\n\n"}
{"name":"MeasureTheory.lintegral_finset_sum_measure","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nι : Type u_5\ns : Finset ι\nf : α → ENNReal\nμ : ι → MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.lintegral (s.sum fun i => μ i) fun a => f a) (s.sum fun i => MeasureTheory.lintegral (μ i) fun a => f a)","decl":"@[simp]\ntheorem lintegral_finset_sum_measure {ι} (s : Finset ι) (f : α → ℝ≥0∞) (μ : ι → Measure α) :\n    ∫⁻ a, f a ∂(∑ i ∈ s, μ i) = ∑ i ∈ s, ∫⁻ a, f a ∂μ i :=\n  let F : Measure α →+ ℝ≥0∞ :=\n    { toFun := (lintegral · f),\n      map_zero' := lintegral_zero_measure f,\n      map_add' := lintegral_add_measure f }\n  map_sum F μ s\n\n"}
{"name":"MeasureTheory.lintegral_sum_measure","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nι : Type u_5\nf : α → ENNReal\nμ : ι → MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.lintegral (MeasureTheory.Measure.sum μ) fun a => f a) (tsum fun i => MeasureTheory.lintegral (μ i) fun a => f a)","decl":"@[simp]\ntheorem lintegral_sum_measure {m : MeasurableSpace α} {ι} (f : α → ℝ≥0∞) (μ : ι → Measure α) :\n    ∫⁻ a, f a ∂Measure.sum μ = ∑' i, ∫⁻ a, f a ∂μ i := by\n  simp_rw [ENNReal.tsum_eq_iSup_sum, ← lintegral_finset_sum_measure,\n    lintegral, SimpleFunc.lintegral_sum, ENNReal.tsum_eq_iSup_sum,\n    SimpleFunc.lintegral_finset_sum, iSup_comm (ι := Finset ι)]\n\n"}
{"name":"MeasureTheory.hasSum_lintegral_measure","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nι : Type u_5\nx✝ : MeasurableSpace α\nf : α → ENNReal\nμ : ι → MeasureTheory.Measure α\n⊢ HasSum (fun i => MeasureTheory.lintegral (μ i) fun a => f a) (MeasureTheory.lintegral (MeasureTheory.Measure.sum μ) fun a => f a)","decl":"theorem hasSum_lintegral_measure {ι} {_ : MeasurableSpace α} (f : α → ℝ≥0∞) (μ : ι → Measure α) :\n    HasSum (fun i => ∫⁻ a, f a ∂μ i) (∫⁻ a, f a ∂Measure.sum μ) :=\n  (lintegral_sum_measure f μ).symm ▸ ENNReal.summable.hasSum\n\n"}
{"name":"MeasureTheory.lintegral_of_isEmpty","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_5\ninst✝¹ : MeasurableSpace α\ninst✝ : IsEmpty α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral μ fun x => f x) 0","decl":"@[simp]\ntheorem lintegral_of_isEmpty {α} [MeasurableSpace α] [IsEmpty α] (μ : Measure α) (f : α → ℝ≥0∞) :\n    ∫⁻ x, f x ∂μ = 0 := by\n  have : Subsingleton (Measure α) := inferInstance\n  convert lintegral_zero_measure f\n\n"}
{"name":"MeasureTheory.setLIntegral_empty","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral (μ.restrict EmptyCollection.emptyCollection) fun x => f x) 0","decl":"theorem setLIntegral_empty (f : α → ℝ≥0∞) : ∫⁻ x in ∅, f x ∂μ = 0 := by\n  rw [Measure.restrict_empty, lintegral_zero_measure]\n\n"}
{"name":"MeasureTheory.setLIntegral_univ","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral (μ.restrict Set.univ) fun x => f x) (MeasureTheory.lintegral μ fun x => f x)","decl":"theorem setLIntegral_univ (f : α → ℝ≥0∞) : ∫⁻ x in univ, f x ∂μ = ∫⁻ x, f x ∂μ := by\n  rw [Measure.restrict_univ]\n\n"}
{"name":"MeasureTheory.setLIntegral_measure_zero","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf : α → ENNReal\nhs' : Eq (μ s) 0\n⊢ Eq (MeasureTheory.lintegral (μ.restrict s) fun x => f x) 0","decl":"theorem setLIntegral_measure_zero (s : Set α) (f : α → ℝ≥0∞) (hs' : μ s = 0) :\n    ∫⁻ x in s, f x ∂μ = 0 := by\n  convert lintegral_zero_measure _\n  exact Measure.restrict_eq_zero.2 hs'\n\n"}
{"name":"MeasureTheory.lintegral_finset_sum'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Finset β\nf : β → α → ENNReal\nhf : ∀ (b : β), Membership.mem s b → AEMeasurable (f b) μ\n⊢ Eq (MeasureTheory.lintegral μ fun a => s.sum fun b => f b a) (s.sum fun b => MeasureTheory.lintegral μ fun a => f b a)","decl":"theorem lintegral_finset_sum' (s : Finset β) {f : β → α → ℝ≥0∞}\n    (hf : ∀ b ∈ s, AEMeasurable (f b) μ) :\n    ∫⁻ a, ∑ b ∈ s, f b a ∂μ = ∑ b ∈ s, ∫⁻ a, f b a ∂μ := by\n  classical\n  induction' s using Finset.induction_on with a s has ih\n  · simp\n  · simp only [Finset.sum_insert has]\n    rw [Finset.forall_mem_insert] at hf\n    rw [lintegral_add_left' hf.1, ih hf.2]\n\n"}
{"name":"MeasureTheory.lintegral_finset_sum","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Finset β\nf : β → α → ENNReal\nhf : ∀ (b : β), Membership.mem s b → Measurable (f b)\n⊢ Eq (MeasureTheory.lintegral μ fun a => s.sum fun b => f b a) (s.sum fun b => MeasureTheory.lintegral μ fun a => f b a)","decl":"theorem lintegral_finset_sum (s : Finset β) {f : β → α → ℝ≥0∞} (hf : ∀ b ∈ s, Measurable (f b)) :\n    ∫⁻ a, ∑ b ∈ s, f b a ∂μ = ∑ b ∈ s, ∫⁻ a, f b a ∂μ :=\n  lintegral_finset_sum' s fun b hb => (hf b hb).aemeasurable\n\n"}
{"name":"MeasureTheory.lintegral_const_mul","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nr : ENNReal\nf : α → ENNReal\nhf : Measurable f\n⊢ Eq (MeasureTheory.lintegral μ fun a => HMul.hMul r (f a)) (HMul.hMul r (MeasureTheory.lintegral μ fun a => f a))","decl":"@[simp]\ntheorem lintegral_const_mul (r : ℝ≥0∞) {f : α → ℝ≥0∞} (hf : Measurable f) :\n    ∫⁻ a, r * f a ∂μ = r * ∫⁻ a, f a ∂μ :=\n  calc\n    ∫⁻ a, r * f a ∂μ = ∫⁻ a, ⨆ n, (const α r * eapprox f n) a ∂μ := by\n      congr\n      funext a\n      rw [← iSup_eapprox_apply hf, ENNReal.mul_iSup]\n      simp\n    _ = ⨆ n, r * (eapprox f n).lintegral μ := by\n      rw [lintegral_iSup]\n      · congr\n        funext n\n        rw [← SimpleFunc.const_mul_lintegral, ← SimpleFunc.lintegral_eq_lintegral]\n      · intro n\n        exact SimpleFunc.measurable _\n      · intro i j h a\n        exact mul_le_mul_left' (monotone_eapprox _ h _) _\n    _ = r * ∫⁻ a, f a ∂μ := by rw [← ENNReal.mul_iSup, lintegral_eq_iSup_eapprox_lintegral hf]\n\n"}
{"name":"MeasureTheory.lintegral_const_mul''","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nr : ENNReal\nf : α → ENNReal\nhf : AEMeasurable f μ\n⊢ Eq (MeasureTheory.lintegral μ fun a => HMul.hMul r (f a)) (HMul.hMul r (MeasureTheory.lintegral μ fun a => f a))","decl":"theorem lintegral_const_mul'' (r : ℝ≥0∞) {f : α → ℝ≥0∞} (hf : AEMeasurable f μ) :\n    ∫⁻ a, r * f a ∂μ = r * ∫⁻ a, f a ∂μ := by\n  have A : ∫⁻ a, f a ∂μ = ∫⁻ a, hf.mk f a ∂μ := lintegral_congr_ae hf.ae_eq_mk\n  have B : ∫⁻ a, r * f a ∂μ = ∫⁻ a, r * hf.mk f a ∂μ :=\n    lintegral_congr_ae (EventuallyEq.fun_comp hf.ae_eq_mk _)\n  rw [A, B, lintegral_const_mul _ hf.measurable_mk]\n\n"}
{"name":"MeasureTheory.lintegral_const_mul_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nr : ENNReal\nf : α → ENNReal\n⊢ LE.le (HMul.hMul r (MeasureTheory.lintegral μ fun a => f a)) (MeasureTheory.lintegral μ fun a => HMul.hMul r (f a))","decl":"theorem lintegral_const_mul_le (r : ℝ≥0∞) (f : α → ℝ≥0∞) :\n    r * ∫⁻ a, f a ∂μ ≤ ∫⁻ a, r * f a ∂μ := by\n  rw [lintegral, ENNReal.mul_iSup]\n  refine iSup_le fun s => ?_\n  rw [ENNReal.mul_iSup, iSup_le_iff]\n  intro hs\n  rw [← SimpleFunc.const_mul_lintegral, lintegral]\n  refine le_iSup_of_le (const α r * s) (le_iSup_of_le (fun x => ?_) le_rfl)\n  exact mul_le_mul_left' (hs x) _\n\n"}
{"name":"MeasureTheory.lintegral_const_mul'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nr : ENNReal\nf : α → ENNReal\nhr : Ne r Top.top\n⊢ Eq (MeasureTheory.lintegral μ fun a => HMul.hMul r (f a)) (HMul.hMul r (MeasureTheory.lintegral μ fun a => f a))","decl":"theorem lintegral_const_mul' (r : ℝ≥0∞) (f : α → ℝ≥0∞) (hr : r ≠ ∞) :\n    ∫⁻ a, r * f a ∂μ = r * ∫⁻ a, f a ∂μ := by\n  by_cases h : r = 0\n  · simp [h]\n  apply le_antisymm _ (lintegral_const_mul_le r f)\n  have rinv : r * r⁻¹ = 1 := ENNReal.mul_inv_cancel h hr\n  have rinv' : r⁻¹ * r = 1 := by\n    rw [mul_comm]\n    exact rinv\n  have := lintegral_const_mul_le (μ := μ) r⁻¹ fun x => r * f x\n  simp? [(mul_assoc _ _ _).symm, rinv'] at this says\n    simp only [(mul_assoc _ _ _).symm, rinv', one_mul] at this\n  simpa [(mul_assoc _ _ _).symm, rinv] using mul_le_mul_left' this r\n\n"}
{"name":"MeasureTheory.lintegral_mul_const","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nr : ENNReal\nf : α → ENNReal\nhf : Measurable f\n⊢ Eq (MeasureTheory.lintegral μ fun a => HMul.hMul (f a) r) (HMul.hMul (MeasureTheory.lintegral μ fun a => f a) r)","decl":"theorem lintegral_mul_const (r : ℝ≥0∞) {f : α → ℝ≥0∞} (hf : Measurable f) :\n    ∫⁻ a, f a * r ∂μ = (∫⁻ a, f a ∂μ) * r := by simp_rw [mul_comm, lintegral_const_mul r hf]\n\n"}
{"name":"MeasureTheory.lintegral_mul_const''","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nr : ENNReal\nf : α → ENNReal\nhf : AEMeasurable f μ\n⊢ Eq (MeasureTheory.lintegral μ fun a => HMul.hMul (f a) r) (HMul.hMul (MeasureTheory.lintegral μ fun a => f a) r)","decl":"theorem lintegral_mul_const'' (r : ℝ≥0∞) {f : α → ℝ≥0∞} (hf : AEMeasurable f μ) :\n    ∫⁻ a, f a * r ∂μ = (∫⁻ a, f a ∂μ) * r := by simp_rw [mul_comm, lintegral_const_mul'' r hf]\n\n"}
{"name":"MeasureTheory.lintegral_mul_const_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nr : ENNReal\nf : α → ENNReal\n⊢ LE.le (HMul.hMul (MeasureTheory.lintegral μ fun a => f a) r) (MeasureTheory.lintegral μ fun a => HMul.hMul (f a) r)","decl":"theorem lintegral_mul_const_le (r : ℝ≥0∞) (f : α → ℝ≥0∞) :\n    (∫⁻ a, f a ∂μ) * r ≤ ∫⁻ a, f a * r ∂μ := by\n  simp_rw [mul_comm, lintegral_const_mul_le r f]\n\n"}
{"name":"MeasureTheory.lintegral_mul_const'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nr : ENNReal\nf : α → ENNReal\nhr : Ne r Top.top\n⊢ Eq (MeasureTheory.lintegral μ fun a => HMul.hMul (f a) r) (HMul.hMul (MeasureTheory.lintegral μ fun a => f a) r)","decl":"theorem lintegral_mul_const' (r : ℝ≥0∞) (f : α → ℝ≥0∞) (hr : r ≠ ∞) :\n    ∫⁻ a, f a * r ∂μ = (∫⁻ a, f a ∂μ) * r := by simp_rw [mul_comm, lintegral_const_mul' r f hr]\n\n/- A double integral of a product where each factor contains only one variable\n  is a product of integrals -/\n"}
{"name":"MeasureTheory.lintegral_lintegral_mul","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nβ : Type u_5\ninst✝ : MeasurableSpace β\nν : MeasureTheory.Measure β\nf : α → ENNReal\ng : β → ENNReal\nhf : AEMeasurable f μ\nhg : AEMeasurable g ν\n⊢ Eq (MeasureTheory.lintegral μ fun x => MeasureTheory.lintegral ν fun y => HMul.hMul (f x) (g y)) (HMul.hMul (MeasureTheory.lintegral μ fun x => f x) (MeasureTheory.lintegral ν fun y => g y))","decl":"theorem lintegral_lintegral_mul {β} [MeasurableSpace β] {ν : Measure β} {f : α → ℝ≥0∞}\n    {g : β → ℝ≥0∞} (hf : AEMeasurable f μ) (hg : AEMeasurable g ν) :\n    ∫⁻ x, ∫⁻ y, f x * g y ∂ν ∂μ = (∫⁻ x, f x ∂μ) * ∫⁻ y, g y ∂ν := by\n  simp [lintegral_const_mul'' _ hg, lintegral_mul_const'' _ hf]\n\n-- TODO: Need a better way of rewriting inside of an integral\n"}
{"name":"MeasureTheory.lintegral_rw₁","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf f' : α → β\nh : (MeasureTheory.ae μ).EventuallyEq f f'\ng : β → ENNReal\n⊢ Eq (MeasureTheory.lintegral μ fun a => g (f a)) (MeasureTheory.lintegral μ fun a => g (f' a))","decl":"theorem lintegral_rw₁ {f f' : α → β} (h : f =ᵐ[μ] f') (g : β → ℝ≥0∞) :\n    ∫⁻ a, g (f a) ∂μ = ∫⁻ a, g (f' a) ∂μ :=\n  lintegral_congr_ae <| h.mono fun a h => by dsimp only; rw [h]\n\n-- TODO: Need a better way of rewriting inside of an integral\n"}
{"name":"MeasureTheory.lintegral_rw₂","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf₁ f₁' : α → β\nf₂ f₂' : α → γ\nh₁ : (MeasureTheory.ae μ).EventuallyEq f₁ f₁'\nh₂ : (MeasureTheory.ae μ).EventuallyEq f₂ f₂'\ng : β → γ → ENNReal\n⊢ Eq (MeasureTheory.lintegral μ fun a => g (f₁ a) (f₂ a)) (MeasureTheory.lintegral μ fun a => g (f₁' a) (f₂' a))","decl":"theorem lintegral_rw₂ {f₁ f₁' : α → β} {f₂ f₂' : α → γ} (h₁ : f₁ =ᵐ[μ] f₁') (h₂ : f₂ =ᵐ[μ] f₂')\n    (g : β → γ → ℝ≥0∞) : ∫⁻ a, g (f₁ a) (f₂ a) ∂μ = ∫⁻ a, g (f₁' a) (f₂' a) ∂μ :=\n  lintegral_congr_ae <| h₁.mp <| h₂.mono fun _ h₂ h₁ => by dsimp only; rw [h₁, h₂]\n\n"}
{"name":"MeasureTheory.lintegral_indicator_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\ns : Set α\n⊢ LE.le (MeasureTheory.lintegral μ fun a => s.indicator f a) (MeasureTheory.lintegral (μ.restrict s) fun a => f a)","decl":"theorem lintegral_indicator_le (f : α → ℝ≥0∞) (s : Set α) :\n    ∫⁻ a, s.indicator f a ∂μ ≤ ∫⁻ a in s, f a ∂μ := by\n  simp only [lintegral]\n  apply iSup_le (fun g ↦ (iSup_le (fun hg ↦ ?_)))\n  have : g ≤ f := hg.trans (indicator_le_self s f)\n  refine le_iSup_of_le g (le_iSup_of_le this (le_of_eq ?_))\n  rw [lintegral_restrict, SimpleFunc.lintegral]\n  congr with t\n  by_cases H : t = 0\n  · simp [H]\n  congr with x\n  simp only [mem_preimage, mem_singleton_iff, mem_inter_iff, iff_self_and]\n  rintro rfl\n  contrapose! H\n  simpa [H] using hg x\n\n"}
{"name":"MeasureTheory.lintegral_indicator","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral μ fun a => s.indicator f a) (MeasureTheory.lintegral (μ.restrict s) fun a => f a)","decl":"@[simp]\ntheorem lintegral_indicator {s : Set α} (hs : MeasurableSet s) (f : α → ℝ≥0∞) :\n    ∫⁻ a, s.indicator f a ∂μ = ∫⁻ a in s, f a ∂μ := by\n  apply le_antisymm (lintegral_indicator_le f s)\n  simp only [lintegral, ← restrict_lintegral_eq_lintegral_restrict _ hs, iSup_subtype']\n  refine iSup_mono' (Subtype.forall.2 fun φ hφ => ?_)\n  refine ⟨⟨φ.restrict s, fun x => ?_⟩, le_rfl⟩\n  simp [hφ x, hs, indicator_le_indicator]\n\n"}
{"name":"MeasureTheory.setLIntegral_indicator","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nhs : MeasurableSet s\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral (μ.restrict t) fun a => s.indicator f a) (MeasureTheory.lintegral (μ.restrict (Inter.inter s t)) fun a => f a)","decl":"lemma setLIntegral_indicator {s t : Set α} (hs : MeasurableSet s) (f : α → ℝ≥0∞) :\n    ∫⁻ a in t, s.indicator f a ∂μ = ∫⁻ a in s ∩ t, f a ∂μ := by\n  rw [lintegral_indicator hs, Measure.restrict_restrict hs]\n\n"}
{"name":"MeasureTheory.lintegral_indicator₀","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasureTheory.NullMeasurableSet s μ\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral μ fun a => s.indicator f a) (MeasureTheory.lintegral (μ.restrict s) fun a => f a)","decl":"theorem lintegral_indicator₀ {s : Set α} (hs : NullMeasurableSet s μ) (f : α → ℝ≥0∞) :\n    ∫⁻ a, s.indicator f a ∂μ = ∫⁻ a in s, f a ∂μ := by\n  rw [← lintegral_congr_ae (indicator_ae_eq_of_ae_eq_set hs.toMeasurable_ae_eq),\n    lintegral_indicator (measurableSet_toMeasurable _ _),\n    Measure.restrict_congr_set hs.toMeasurable_ae_eq]\n\n"}
{"name":"MeasureTheory.setLIntegral_indicator₀","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\ns t : Set α\nhs : MeasureTheory.NullMeasurableSet s (μ.restrict t)\n⊢ Eq (MeasureTheory.lintegral (μ.restrict t) fun a => s.indicator f a) (MeasureTheory.lintegral (μ.restrict (Inter.inter s t)) fun a => f a)","decl":"lemma setLIntegral_indicator₀ (f : α → ℝ≥0∞) {s t : Set α}\n    (hs : NullMeasurableSet s (μ.restrict t)) :\n    ∫⁻ a in t, s.indicator f a ∂μ = ∫⁻ a in s ∩ t, f a ∂μ := by\n  rw [lintegral_indicator₀ hs, Measure.restrict_restrict₀ hs]\n\n"}
{"name":"MeasureTheory.lintegral_indicator_const_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nc : ENNReal\n⊢ LE.le (MeasureTheory.lintegral μ fun a => s.indicator (fun x => c) a) (HMul.hMul c (μ s))","decl":"theorem lintegral_indicator_const_le (s : Set α) (c : ℝ≥0∞) :\n    ∫⁻ a, s.indicator (fun _ => c) a ∂μ ≤ c * μ s :=\n  (lintegral_indicator_le _ _).trans (setLIntegral_const s c).le\n\n"}
{"name":"MeasureTheory.lintegral_indicator_const₀","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasureTheory.NullMeasurableSet s μ\nc : ENNReal\n⊢ Eq (MeasureTheory.lintegral μ fun a => s.indicator (fun x => c) a) (HMul.hMul c (μ s))","decl":"theorem lintegral_indicator_const₀ {s : Set α} (hs : NullMeasurableSet s μ) (c : ℝ≥0∞) :\n    ∫⁻ a, s.indicator (fun _ => c) a ∂μ = c * μ s := by\n  rw [lintegral_indicator₀ hs, setLIntegral_const]\n\n"}
{"name":"MeasureTheory.lintegral_indicator_const","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\nc : ENNReal\n⊢ Eq (MeasureTheory.lintegral μ fun a => s.indicator (fun x => c) a) (HMul.hMul c (μ s))","decl":"theorem lintegral_indicator_const {s : Set α} (hs : MeasurableSet s) (c : ℝ≥0∞) :\n    ∫⁻ a, s.indicator (fun _ => c) a ∂μ = c * μ s :=\n  lintegral_indicator_const₀ hs.nullMeasurableSet c\n\n"}
{"name":"MeasureTheory.setLIntegral_eq_of_support_subset","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf : α → ENNReal\nhsf : HasSubset.Subset (Function.support f) s\n⊢ Eq (MeasureTheory.lintegral (μ.restrict s) fun x => f x) (MeasureTheory.lintegral μ fun x => f x)","decl":"lemma setLIntegral_eq_of_support_subset {s : Set α} {f : α → ℝ≥0∞} (hsf : f.support ⊆ s) :\n    ∫⁻ x in s, f x ∂μ = ∫⁻ x, f x ∂μ := by\n  apply le_antisymm (setLIntegral_le_lintegral s fun x ↦ f x)\n  apply le_trans (le_of_eq _) (lintegral_indicator_le _ _)\n  congr with x\n  simp only [indicator]\n  split_ifs with h\n  · rfl\n  · exact Function.support_subset_iff'.1 hsf x h\n\n"}
{"name":"MeasureTheory.setLIntegral_eq_const","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : Measurable f\nr : ENNReal\n⊢ Eq (MeasureTheory.lintegral (μ.restrict (setOf fun x => Eq (f x) r)) fun x => f x) (HMul.hMul r (μ (setOf fun x => Eq (f x) r)))","decl":"theorem setLIntegral_eq_const {f : α → ℝ≥0∞} (hf : Measurable f) (r : ℝ≥0∞) :\n    ∫⁻ x in { x | f x = r }, f x ∂μ = r * μ { x | f x = r } := by\n  have : ∀ᵐ x ∂μ, x ∈ { x | f x = r } → f x = r := ae_of_all μ fun _ hx => hx\n  rw [setLIntegral_congr_fun _ this]\n  · rw [lintegral_const, Measure.restrict_apply MeasurableSet.univ, Set.univ_inter]\n  · exact hf (measurableSet_singleton r)\n\n"}
{"name":"MeasureTheory.lintegral_indicator_one_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ LE.le (MeasureTheory.lintegral μ fun a => s.indicator 1 a) (μ s)","decl":"theorem lintegral_indicator_one_le (s : Set α) : ∫⁻ a, s.indicator 1 a ∂μ ≤ μ s :=\n  (lintegral_indicator_const_le _ _).trans <| (one_mul _).le\n\n"}
{"name":"MeasureTheory.lintegral_indicator_one₀","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasureTheory.NullMeasurableSet s μ\n⊢ Eq (MeasureTheory.lintegral μ fun a => s.indicator 1 a) (μ s)","decl":"@[simp]\ntheorem lintegral_indicator_one₀ {s : Set α} (hs : NullMeasurableSet s μ) :\n    ∫⁻ a, s.indicator 1 a ∂μ = μ s :=\n  (lintegral_indicator_const₀ hs _).trans <| one_mul _\n\n"}
{"name":"MeasureTheory.lintegral_indicator_one","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\n⊢ Eq (MeasureTheory.lintegral μ fun a => s.indicator 1 a) (μ s)","decl":"@[simp]\ntheorem lintegral_indicator_one {s : Set α} (hs : MeasurableSet s) :\n    ∫⁻ a, s.indicator 1 a ∂μ = μ s :=\n  (lintegral_indicator_const hs _).trans <| one_mul _\n\n"}
{"name":"MeasureTheory.lintegral_add_mul_meas_add_le_le_lintegral","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\nhle : (MeasureTheory.ae μ).EventuallyLE f g\nhg : AEMeasurable g μ\nε : ENNReal\n⊢ LE.le (HAdd.hAdd (MeasureTheory.lintegral μ fun a => f a) (HMul.hMul ε (μ (setOf fun x => LE.le (HAdd.hAdd (f x) ε) (g x))))) (MeasureTheory.lintegral μ fun a => g a)","decl":"/-- A version of **Markov's inequality** for two functions. It doesn't follow from the standard\nMarkov's inequality because we only assume measurability of `g`, not `f`. -/\ntheorem lintegral_add_mul_meas_add_le_le_lintegral {f g : α → ℝ≥0∞} (hle : f ≤ᵐ[μ] g)\n    (hg : AEMeasurable g μ) (ε : ℝ≥0∞) :\n    ∫⁻ a, f a ∂μ + ε * μ { x | f x + ε ≤ g x } ≤ ∫⁻ a, g a ∂μ := by\n  rcases exists_measurable_le_lintegral_eq μ f with ⟨φ, hφm, hφ_le, hφ_eq⟩\n  calc\n    ∫⁻ x, f x ∂μ + ε * μ { x | f x + ε ≤ g x } = ∫⁻ x, φ x ∂μ + ε * μ { x | f x + ε ≤ g x } := by\n      rw [hφ_eq]\n    _ ≤ ∫⁻ x, φ x ∂μ + ε * μ { x | φ x + ε ≤ g x } := by\n      gcongr\n      exact fun x => (add_le_add_right (hφ_le _) _).trans\n    _ = ∫⁻ x, φ x + indicator { x | φ x + ε ≤ g x } (fun _ => ε) x ∂μ := by\n      rw [lintegral_add_left hφm, lintegral_indicator₀, setLIntegral_const]\n      exact measurableSet_le (hφm.nullMeasurable.measurable'.add_const _) hg.nullMeasurable\n    _ ≤ ∫⁻ x, g x ∂μ := lintegral_mono_ae (hle.mono fun x hx₁ => ?_)\n  simp only [indicator_apply]; split_ifs with hx₂\n  exacts [hx₂, (add_zero _).trans_le <| (hφ_le x).trans hx₁]\n\n"}
{"name":"MeasureTheory.mul_meas_ge_le_lintegral₀","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : AEMeasurable f μ\nε : ENNReal\n⊢ LE.le (HMul.hMul ε (μ (setOf fun x => LE.le ε (f x)))) (MeasureTheory.lintegral μ fun a => f a)","decl":"/-- **Markov's inequality** also known as **Chebyshev's first inequality**. -/\ntheorem mul_meas_ge_le_lintegral₀ {f : α → ℝ≥0∞} (hf : AEMeasurable f μ) (ε : ℝ≥0∞) :\n    ε * μ { x | ε ≤ f x } ≤ ∫⁻ a, f a ∂μ := by\n  simpa only [lintegral_zero, zero_add] using\n    lintegral_add_mul_meas_add_le_le_lintegral (ae_of_all _ fun x => zero_le (f x)) hf ε\n\n"}
{"name":"MeasureTheory.mul_meas_ge_le_lintegral","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : Measurable f\nε : ENNReal\n⊢ LE.le (HMul.hMul ε (μ (setOf fun x => LE.le ε (f x)))) (MeasureTheory.lintegral μ fun a => f a)","decl":"/-- **Markov's inequality** also known as **Chebyshev's first inequality**. For a version assuming\n`AEMeasurable`, see `mul_meas_ge_le_lintegral₀`. -/\ntheorem mul_meas_ge_le_lintegral {f : α → ℝ≥0∞} (hf : Measurable f) (ε : ℝ≥0∞) :\n    ε * μ { x | ε ≤ f x } ≤ ∫⁻ a, f a ∂μ :=\n  mul_meas_ge_le_lintegral₀ hf.aemeasurable ε\n\n"}
{"name":"MeasureTheory.meas_le_lintegral₀","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : AEMeasurable f μ\ns : Set α\nhs : ∀ (x : α), Membership.mem s x → LE.le 1 (f x)\n⊢ LE.le (μ s) (MeasureTheory.lintegral μ fun a => f a)","decl":"lemma meas_le_lintegral₀ {f : α → ℝ≥0∞} (hf : AEMeasurable f μ)\n    {s : Set α} (hs : ∀ x ∈ s, 1 ≤ f x) : μ s ≤ ∫⁻ a, f a ∂μ := by\n  apply le_trans _ (mul_meas_ge_le_lintegral₀ hf 1)\n  rw [one_mul]\n  exact measure_mono hs\n\n"}
{"name":"MeasureTheory.lintegral_le_meas","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf : α → ENNReal\nhf : ∀ (a : α), LE.le (f a) 1\nh'f : ∀ (a : α), Membership.mem (HasCompl.compl s) a → Eq (f a) 0\n⊢ LE.le (MeasureTheory.lintegral μ fun a => f a) (μ s)","decl":"lemma lintegral_le_meas {s : Set α} {f : α → ℝ≥0∞} (hf : ∀ a, f a ≤ 1) (h'f : ∀ a ∈ sᶜ, f a = 0) :\n    ∫⁻ a, f a ∂μ ≤ μ s := by\n  apply (lintegral_mono (fun x ↦ ?_)).trans (lintegral_indicator_one_le s)\n  by_cases hx : x ∈ s\n  · simpa [hx] using hf x\n  · simpa [hx] using h'f x hx\n\n"}
{"name":"MeasureTheory.setLIntegral_le_meas","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nhs : MeasurableSet s\nf : α → ENNReal\nhf : ∀ (a : α), Membership.mem s a → Membership.mem t a → LE.le (f a) 1\nhf' : ∀ (a : α), Membership.mem s a → Not (Membership.mem t a) → Eq (f a) 0\n⊢ LE.le (MeasureTheory.lintegral (μ.restrict s) fun a => f a) (μ t)","decl":"lemma setLIntegral_le_meas {s t : Set α} (hs : MeasurableSet s)\n    {f : α → ℝ≥0∞} (hf : ∀ a ∈ s, a ∈ t → f a ≤ 1)\n    (hf' : ∀ a ∈ s, a ∉ t → f a = 0) : ∫⁻ a in s, f a ∂μ ≤ μ t := by\n  rw [← lintegral_indicator hs]\n  refine lintegral_le_meas (fun a ↦ ?_) (by aesop)\n  by_cases has : a ∈ s <;> [by_cases hat : a ∈ t; skip] <;> simp [*]\n\n"}
{"name":"MeasureTheory.lintegral_eq_top_of_measure_eq_top_ne_zero","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : AEMeasurable f μ\nhμf : Ne (μ (setOf fun x => Eq (f x) Top.top)) 0\n⊢ Eq (MeasureTheory.lintegral μ fun x => f x) Top.top","decl":"theorem lintegral_eq_top_of_measure_eq_top_ne_zero {f : α → ℝ≥0∞} (hf : AEMeasurable f μ)\n    (hμf : μ {x | f x = ∞} ≠ 0) : ∫⁻ x, f x ∂μ = ∞ :=\n  eq_top_iff.mpr <|\n    calc\n      ∞ = ∞ * μ { x | ∞ ≤ f x } := by simp [mul_eq_top, hμf]\n      _ ≤ ∫⁻ x, f x ∂μ := mul_meas_ge_le_lintegral₀ hf ∞\n\n"}
{"name":"MeasureTheory.setLintegral_eq_top_of_measure_eq_top_ne_zero","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\ns : Set α\nhf : AEMeasurable f (μ.restrict s)\nhμf : Ne (μ (setOf fun x => And (Membership.mem s x) (Eq (f x) Top.top))) 0\n⊢ Eq (MeasureTheory.lintegral (μ.restrict s) fun x => f x) Top.top","decl":"theorem setLintegral_eq_top_of_measure_eq_top_ne_zero {f : α → ℝ≥0∞} {s : Set α}\n    (hf : AEMeasurable f (μ.restrict s)) (hμf : μ ({x ∈ s | f x = ∞}) ≠ 0) :\n    ∫⁻ x in s, f x ∂μ = ∞ :=\n  lintegral_eq_top_of_measure_eq_top_ne_zero hf <|\n    mt (eq_bot_mono <| by rw [← setOf_inter_eq_sep]; exact Measure.le_restrict_apply _ _) hμf\n\n"}
{"name":"MeasureTheory.measure_eq_top_of_lintegral_ne_top","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : AEMeasurable f μ\nhμf : Ne (MeasureTheory.lintegral μ fun x => f x) Top.top\n⊢ Eq (μ (setOf fun x => Eq (f x) Top.top)) 0","decl":"theorem measure_eq_top_of_lintegral_ne_top {f : α → ℝ≥0∞}\n    (hf : AEMeasurable f μ) (hμf : ∫⁻ x, f x ∂μ ≠ ∞) : μ {x | f x = ∞} = 0 :=\n  of_not_not fun h => hμf <| lintegral_eq_top_of_measure_eq_top_ne_zero hf h\n\n"}
{"name":"MeasureTheory.measure_eq_top_of_setLintegral_ne_top","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\ns : Set α\nhf : AEMeasurable f (μ.restrict s)\nhμf : Ne (MeasureTheory.lintegral (μ.restrict s) fun x => f x) Top.top\n⊢ Eq (μ (setOf fun x => And (Membership.mem s x) (Eq (f x) Top.top))) 0","decl":"theorem measure_eq_top_of_setLintegral_ne_top {f : α → ℝ≥0∞} {s : Set α}\n    (hf : AEMeasurable f (μ.restrict s)) (hμf : ∫⁻ x in s, f x ∂μ ≠ ∞) :\n    μ ({x ∈ s | f x = ∞}) = 0 :=\n  of_not_not fun h => hμf <| setLintegral_eq_top_of_measure_eq_top_ne_zero hf h\n\n"}
{"name":"MeasureTheory.meas_ge_le_lintegral_div","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : AEMeasurable f μ\nε : ENNReal\nhε : Ne ε 0\nhε' : Ne ε Top.top\n⊢ LE.le (μ (setOf fun x => LE.le ε (f x))) (HDiv.hDiv (MeasureTheory.lintegral μ fun a => f a) ε)","decl":"/-- **Markov's inequality**, also known as **Chebyshev's first inequality**. -/\ntheorem meas_ge_le_lintegral_div {f : α → ℝ≥0∞} (hf : AEMeasurable f μ) {ε : ℝ≥0∞} (hε : ε ≠ 0)\n    (hε' : ε ≠ ∞) : μ { x | ε ≤ f x } ≤ (∫⁻ a, f a ∂μ) / ε :=\n  (ENNReal.le_div_iff_mul_le (Or.inl hε) (Or.inl hε')).2 <| by\n    rw [mul_comm]\n    exact mul_meas_ge_le_lintegral₀ hf ε\n\n"}
{"name":"MeasureTheory.ae_eq_of_ae_le_of_lintegral_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\nhfg : (MeasureTheory.ae μ).EventuallyLE f g\nhf : Ne (MeasureTheory.lintegral μ fun x => f x) Top.top\nhg : AEMeasurable g μ\nhgf : LE.le (MeasureTheory.lintegral μ fun x => g x) (MeasureTheory.lintegral μ fun x => f x)\n⊢ (MeasureTheory.ae μ).EventuallyEq f g","decl":"theorem ae_eq_of_ae_le_of_lintegral_le {f g : α → ℝ≥0∞} (hfg : f ≤ᵐ[μ] g) (hf : ∫⁻ x, f x ∂μ ≠ ∞)\n    (hg : AEMeasurable g μ) (hgf : ∫⁻ x, g x ∂μ ≤ ∫⁻ x, f x ∂μ) : f =ᵐ[μ] g := by\n  have : ∀ n : ℕ, ∀ᵐ x ∂μ, g x < f x + (n : ℝ≥0∞)⁻¹ := by\n    intro n\n    simp only [ae_iff, not_lt]\n    have : ∫⁻ x, f x ∂μ + (↑n)⁻¹ * μ { x : α | f x + (n : ℝ≥0∞)⁻¹ ≤ g x } ≤ ∫⁻ x, f x ∂μ :=\n      (lintegral_add_mul_meas_add_le_le_lintegral hfg hg n⁻¹).trans hgf\n    rw [(ENNReal.cancel_of_ne hf).add_le_iff_nonpos_right, nonpos_iff_eq_zero, mul_eq_zero] at this\n    exact this.resolve_left (ENNReal.inv_ne_zero.2 (ENNReal.natCast_ne_top _))\n  refine hfg.mp ((ae_all_iff.2 this).mono fun x hlt hle => hle.antisymm ?_)\n  suffices Tendsto (fun n : ℕ => f x + (n : ℝ≥0∞)⁻¹) atTop (𝓝 (f x)) from\n    ge_of_tendsto' this fun i => (hlt i).le\n  simpa only [inv_top, add_zero] using\n    tendsto_const_nhds.add (ENNReal.tendsto_inv_iff.2 ENNReal.tendsto_nat_nhds_top)\n\n"}
{"name":"MeasureTheory.lintegral_eq_zero_iff'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : AEMeasurable f μ\n⊢ Iff (Eq (MeasureTheory.lintegral μ fun a => f a) 0) ((MeasureTheory.ae μ).EventuallyEq f 0)","decl":"@[simp]\ntheorem lintegral_eq_zero_iff' {f : α → ℝ≥0∞} (hf : AEMeasurable f μ) :\n    ∫⁻ a, f a ∂μ = 0 ↔ f =ᵐ[μ] 0 :=\n  have : ∫⁻ _ : α, 0 ∂μ ≠ ∞ := by simp [lintegral_zero, zero_ne_top]\n  ⟨fun h =>\n    (ae_eq_of_ae_le_of_lintegral_le (ae_of_all _ <| zero_le f) this hf\n        (h.trans lintegral_zero.symm).le).symm,\n    fun h => (lintegral_congr_ae h).trans lintegral_zero⟩\n\n"}
{"name":"MeasureTheory.lintegral_eq_zero_iff","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : Measurable f\n⊢ Iff (Eq (MeasureTheory.lintegral μ fun a => f a) 0) ((MeasureTheory.ae μ).EventuallyEq f 0)","decl":"@[simp]\ntheorem lintegral_eq_zero_iff {f : α → ℝ≥0∞} (hf : Measurable f) : ∫⁻ a, f a ∂μ = 0 ↔ f =ᵐ[μ] 0 :=\n  lintegral_eq_zero_iff' hf.aemeasurable\n\n"}
{"name":"MeasureTheory.setLIntegral_eq_zero_iff'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\nf : α → ENNReal\nhf : AEMeasurable f (μ.restrict s)\n⊢ Iff (Eq (MeasureTheory.lintegral (μ.restrict s) fun a => f a) 0) (Filter.Eventually (fun x => Membership.mem s x → Eq (f x) 0) (MeasureTheory.ae μ))","decl":"theorem setLIntegral_eq_zero_iff' {s : Set α} (hs : MeasurableSet s)\n    {f : α → ℝ≥0∞} (hf : AEMeasurable f (μ.restrict s)) :\n    ∫⁻ a in s, f a ∂μ = 0 ↔ ∀ᵐ x ∂μ, x ∈ s → f x = 0 :=\n  (lintegral_eq_zero_iff' hf).trans (ae_restrict_iff' hs)\n\n"}
{"name":"MeasureTheory.setLIntegral_eq_zero_iff","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\nf : α → ENNReal\nhf : Measurable f\n⊢ Iff (Eq (MeasureTheory.lintegral (μ.restrict s) fun a => f a) 0) (Filter.Eventually (fun x => Membership.mem s x → Eq (f x) 0) (MeasureTheory.ae μ))","decl":"theorem setLIntegral_eq_zero_iff {s : Set α} (hs : MeasurableSet s) {f : α → ℝ≥0∞}\n    (hf : Measurable f) : ∫⁻ a in s, f a ∂μ = 0 ↔ ∀ᵐ x ∂μ, x ∈ s → f x = 0 :=\n  setLIntegral_eq_zero_iff' hs hf.aemeasurable\n\n"}
{"name":"MeasureTheory.lintegral_pos_iff_support","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : Measurable f\n⊢ Iff (LT.lt 0 (MeasureTheory.lintegral μ fun a => f a)) (LT.lt 0 (μ (Function.support f)))","decl":"theorem lintegral_pos_iff_support {f : α → ℝ≥0∞} (hf : Measurable f) :\n    (0 < ∫⁻ a, f a ∂μ) ↔ 0 < μ (Function.support f) := by\n  simp [pos_iff_ne_zero, hf, Filter.EventuallyEq, ae_iff, Function.support]\n\n"}
{"name":"MeasureTheory.setLintegral_pos_iff","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : Measurable f\ns : Set α\n⊢ Iff (LT.lt 0 (MeasureTheory.lintegral (μ.restrict s) fun a => f a)) (LT.lt 0 (μ (Inter.inter (Function.support f) s)))","decl":"theorem setLintegral_pos_iff {f : α → ℝ≥0∞} (hf : Measurable f) {s : Set α} :\n    0 < ∫⁻ a in s, f a ∂μ ↔ 0 < μ (Function.support f ∩ s) := by\n  rw [lintegral_pos_iff_support hf, Measure.restrict_apply (measurableSet_support hf)]\n\n"}
{"name":"MeasureTheory.lintegral_iSup_ae","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : Nat → α → ENNReal\nhf : ∀ (n : Nat), Measurable (f n)\nh_mono : ∀ (n : Nat), Filter.Eventually (fun a => LE.le (f n a) (f n.succ a)) (MeasureTheory.ae μ)\n⊢ Eq (MeasureTheory.lintegral μ fun a => iSup fun n => f n a) (iSup fun n => MeasureTheory.lintegral μ fun a => f n a)","decl":"/-- Weaker version of the monotone convergence theorem -/\ntheorem lintegral_iSup_ae {f : ℕ → α → ℝ≥0∞} (hf : ∀ n, Measurable (f n))\n    (h_mono : ∀ n, ∀ᵐ a ∂μ, f n a ≤ f n.succ a) : ∫⁻ a, ⨆ n, f n a ∂μ = ⨆ n, ∫⁻ a, f n a ∂μ := by\n  classical\n  let ⟨s, hs⟩ := exists_measurable_superset_of_null (ae_iff.1 (ae_all_iff.2 h_mono))\n  let g n a := if a ∈ s then 0 else f n a\n  have g_eq_f : ∀ᵐ a ∂μ, ∀ n, g n a = f n a :=\n    (measure_zero_iff_ae_nmem.1 hs.2.2).mono fun a ha n => if_neg ha\n  calc\n    ∫⁻ a, ⨆ n, f n a ∂μ = ∫⁻ a, ⨆ n, g n a ∂μ :=\n      lintegral_congr_ae <| g_eq_f.mono fun a ha => by simp only [ha]\n    _ = ⨆ n, ∫⁻ a, g n a ∂μ :=\n      (lintegral_iSup (fun n => measurable_const.piecewise hs.2.1 (hf n))\n        (monotone_nat_of_le_succ fun n a => ?_))\n    _ = ⨆ n, ∫⁻ a, f n a ∂μ := by simp only [lintegral_congr_ae (g_eq_f.mono fun _a ha => ha _)]\n  simp only [g]\n  split_ifs with h\n  · rfl\n  · have := Set.not_mem_subset hs.1 h\n    simp only [not_forall, not_le, mem_setOf_eq, not_exists, not_lt] at this\n    exact this n\n\n"}
{"name":"MeasureTheory.lintegral_sub'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\nhg : AEMeasurable g μ\nhg_fin : Ne (MeasureTheory.lintegral μ fun a => g a) Top.top\nh_le : (MeasureTheory.ae μ).EventuallyLE g f\n⊢ Eq (MeasureTheory.lintegral μ fun a => HSub.hSub (f a) (g a)) (HSub.hSub (MeasureTheory.lintegral μ fun a => f a) (MeasureTheory.lintegral μ fun a => g a))","decl":"theorem lintegral_sub' {f g : α → ℝ≥0∞} (hg : AEMeasurable g μ) (hg_fin : ∫⁻ a, g a ∂μ ≠ ∞)\n    (h_le : g ≤ᵐ[μ] f) : ∫⁻ a, f a - g a ∂μ = ∫⁻ a, f a ∂μ - ∫⁻ a, g a ∂μ := by\n  refine ENNReal.eq_sub_of_add_eq hg_fin ?_\n  rw [← lintegral_add_right' _ hg]\n  exact lintegral_congr_ae (h_le.mono fun x hx => tsub_add_cancel_of_le hx)\n\n"}
{"name":"MeasureTheory.lintegral_sub","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\nhg : Measurable g\nhg_fin : Ne (MeasureTheory.lintegral μ fun a => g a) Top.top\nh_le : (MeasureTheory.ae μ).EventuallyLE g f\n⊢ Eq (MeasureTheory.lintegral μ fun a => HSub.hSub (f a) (g a)) (HSub.hSub (MeasureTheory.lintegral μ fun a => f a) (MeasureTheory.lintegral μ fun a => g a))","decl":"theorem lintegral_sub {f g : α → ℝ≥0∞} (hg : Measurable g) (hg_fin : ∫⁻ a, g a ∂μ ≠ ∞)\n    (h_le : g ≤ᵐ[μ] f) : ∫⁻ a, f a - g a ∂μ = ∫⁻ a, f a ∂μ - ∫⁻ a, g a ∂μ :=\n  lintegral_sub' hg.aemeasurable hg_fin h_le\n\n"}
{"name":"MeasureTheory.lintegral_sub_le'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\nhf : AEMeasurable f μ\n⊢ LE.le (HSub.hSub (MeasureTheory.lintegral μ fun x => g x) (MeasureTheory.lintegral μ fun x => f x)) (MeasureTheory.lintegral μ fun x => HSub.hSub (g x) (f x))","decl":"theorem lintegral_sub_le' (f g : α → ℝ≥0∞) (hf : AEMeasurable f μ) :\n    ∫⁻ x, g x ∂μ - ∫⁻ x, f x ∂μ ≤ ∫⁻ x, g x - f x ∂μ := by\n  rw [tsub_le_iff_right]\n  by_cases hfi : ∫⁻ x, f x ∂μ = ∞\n  · rw [hfi, add_top]\n    exact le_top\n  · rw [← lintegral_add_right' _ hf]\n    gcongr\n    exact le_tsub_add\n\n"}
{"name":"MeasureTheory.lintegral_sub_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\nhf : Measurable f\n⊢ LE.le (HSub.hSub (MeasureTheory.lintegral μ fun x => g x) (MeasureTheory.lintegral μ fun x => f x)) (MeasureTheory.lintegral μ fun x => HSub.hSub (g x) (f x))","decl":"theorem lintegral_sub_le (f g : α → ℝ≥0∞) (hf : Measurable f) :\n    ∫⁻ x, g x ∂μ - ∫⁻ x, f x ∂μ ≤ ∫⁻ x, g x - f x ∂μ :=\n  lintegral_sub_le' f g hf.aemeasurable\n\n"}
{"name":"MeasureTheory.lintegral_strict_mono_of_ae_le_of_frequently_ae_lt","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\nhg : AEMeasurable g μ\nhfi : Ne (MeasureTheory.lintegral μ fun x => f x) Top.top\nh_le : (MeasureTheory.ae μ).EventuallyLE f g\nh : Filter.Frequently (fun x => Ne (f x) (g x)) (MeasureTheory.ae μ)\n⊢ LT.lt (MeasureTheory.lintegral μ fun x => f x) (MeasureTheory.lintegral μ fun x => g x)","decl":"theorem lintegral_strict_mono_of_ae_le_of_frequently_ae_lt {f g : α → ℝ≥0∞} (hg : AEMeasurable g μ)\n    (hfi : ∫⁻ x, f x ∂μ ≠ ∞) (h_le : f ≤ᵐ[μ] g) (h : ∃ᵐ x ∂μ, f x ≠ g x) :\n    ∫⁻ x, f x ∂μ < ∫⁻ x, g x ∂μ := by\n  contrapose! h\n  simp only [not_frequently, Ne, Classical.not_not]\n  exact ae_eq_of_ae_le_of_lintegral_le h_le hfi hg h\n\n"}
{"name":"MeasureTheory.lintegral_strict_mono_of_ae_le_of_ae_lt_on","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\nhg : AEMeasurable g μ\nhfi : Ne (MeasureTheory.lintegral μ fun x => f x) Top.top\nh_le : (MeasureTheory.ae μ).EventuallyLE f g\ns : Set α\nhμs : Ne (μ s) 0\nh : Filter.Eventually (fun x => Membership.mem s x → LT.lt (f x) (g x)) (MeasureTheory.ae μ)\n⊢ LT.lt (MeasureTheory.lintegral μ fun x => f x) (MeasureTheory.lintegral μ fun x => g x)","decl":"theorem lintegral_strict_mono_of_ae_le_of_ae_lt_on {f g : α → ℝ≥0∞} (hg : AEMeasurable g μ)\n    (hfi : ∫⁻ x, f x ∂μ ≠ ∞) (h_le : f ≤ᵐ[μ] g) {s : Set α} (hμs : μ s ≠ 0)\n    (h : ∀ᵐ x ∂μ, x ∈ s → f x < g x) : ∫⁻ x, f x ∂μ < ∫⁻ x, g x ∂μ :=\n  lintegral_strict_mono_of_ae_le_of_frequently_ae_lt hg hfi h_le <|\n    ((frequently_ae_mem_iff.2 hμs).and_eventually h).mono fun _x hx => (hx.2 hx.1).ne\n\n"}
{"name":"MeasureTheory.lintegral_strict_mono","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\nhμ : Ne μ 0\nhg : AEMeasurable g μ\nhfi : Ne (MeasureTheory.lintegral μ fun x => f x) Top.top\nh : Filter.Eventually (fun x => LT.lt (f x) (g x)) (MeasureTheory.ae μ)\n⊢ LT.lt (MeasureTheory.lintegral μ fun x => f x) (MeasureTheory.lintegral μ fun x => g x)","decl":"theorem lintegral_strict_mono {f g : α → ℝ≥0∞} (hμ : μ ≠ 0) (hg : AEMeasurable g μ)\n    (hfi : ∫⁻ x, f x ∂μ ≠ ∞) (h : ∀ᵐ x ∂μ, f x < g x) : ∫⁻ x, f x ∂μ < ∫⁻ x, g x ∂μ := by\n  rw [Ne, ← Measure.measure_univ_eq_zero] at hμ\n  refine lintegral_strict_mono_of_ae_le_of_ae_lt_on hg hfi (ae_le_of_ae_lt h) hμ ?_\n  simpa using h\n\n"}
{"name":"MeasureTheory.setLIntegral_strict_mono","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\ns : Set α\nhsm : MeasurableSet s\nhs : Ne (μ s) 0\nhg : Measurable g\nhfi : Ne (MeasureTheory.lintegral (μ.restrict s) fun x => f x) Top.top\nh : Filter.Eventually (fun x => Membership.mem s x → LT.lt (f x) (g x)) (MeasureTheory.ae μ)\n⊢ LT.lt (MeasureTheory.lintegral (μ.restrict s) fun x => f x) (MeasureTheory.lintegral (μ.restrict s) fun x => g x)","decl":"theorem setLIntegral_strict_mono {f g : α → ℝ≥0∞} {s : Set α} (hsm : MeasurableSet s)\n    (hs : μ s ≠ 0) (hg : Measurable g) (hfi : ∫⁻ x in s, f x ∂μ ≠ ∞)\n    (h : ∀ᵐ x ∂μ, x ∈ s → f x < g x) : ∫⁻ x in s, f x ∂μ < ∫⁻ x in s, g x ∂μ :=\n  lintegral_strict_mono (by simp [hs]) hg.aemeasurable hfi ((ae_restrict_iff' hsm).mpr h)\n\n"}
{"name":"MeasureTheory.lintegral_iInf_ae","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : Nat → α → ENNReal\nh_meas : ∀ (n : Nat), Measurable (f n)\nh_mono : ∀ (n : Nat), (MeasureTheory.ae μ).EventuallyLE (f n.succ) (f n)\nh_fin : Ne (MeasureTheory.lintegral μ fun a => f 0 a) Top.top\n⊢ Eq (MeasureTheory.lintegral μ fun a => iInf fun n => f n a) (iInf fun n => MeasureTheory.lintegral μ fun a => f n a)","decl":"/-- Monotone convergence theorem for nonincreasing sequences of functions -/\ntheorem lintegral_iInf_ae {f : ℕ → α → ℝ≥0∞} (h_meas : ∀ n, Measurable (f n))\n    (h_mono : ∀ n : ℕ, f n.succ ≤ᵐ[μ] f n) (h_fin : ∫⁻ a, f 0 a ∂μ ≠ ∞) :\n    ∫⁻ a, ⨅ n, f n a ∂μ = ⨅ n, ∫⁻ a, f n a ∂μ :=\n  have fn_le_f0 : ∫⁻ a, ⨅ n, f n a ∂μ ≤ ∫⁻ a, f 0 a ∂μ :=\n    lintegral_mono fun _ => iInf_le_of_le 0 le_rfl\n  have fn_le_f0' : ⨅ n, ∫⁻ a, f n a ∂μ ≤ ∫⁻ a, f 0 a ∂μ := iInf_le_of_le 0 le_rfl\n  (ENNReal.sub_right_inj h_fin fn_le_f0 fn_le_f0').1 <|\n    show ∫⁻ a, f 0 a ∂μ - ∫⁻ a, ⨅ n, f n a ∂μ = ∫⁻ a, f 0 a ∂μ - ⨅ n, ∫⁻ a, f n a ∂μ from\n      calc\n        ∫⁻ a, f 0 a ∂μ - ∫⁻ a, ⨅ n, f n a ∂μ = ∫⁻ a, f 0 a - ⨅ n, f n a ∂μ :=\n          (lintegral_sub (.iInf h_meas)\n              (ne_top_of_le_ne_top h_fin <| lintegral_mono fun _ => iInf_le _ _)\n              (ae_of_all _ fun _ => iInf_le _ _)).symm\n        _ = ∫⁻ a, ⨆ n, f 0 a - f n a ∂μ := congr rfl (funext fun _ => ENNReal.sub_iInf)\n        _ = ⨆ n, ∫⁻ a, f 0 a - f n a ∂μ :=\n          (lintegral_iSup_ae (fun n => (h_meas 0).sub (h_meas n)) fun n =>\n            (h_mono n).mono fun _ ha => tsub_le_tsub le_rfl ha)\n        _ = ⨆ n, ∫⁻ a, f 0 a ∂μ - ∫⁻ a, f n a ∂μ :=\n          (have h_mono : ∀ᵐ a ∂μ, ∀ n : ℕ, f n.succ a ≤ f n a := ae_all_iff.2 h_mono\n          have h_mono : ∀ n, ∀ᵐ a ∂μ, f n a ≤ f 0 a := fun n =>\n            h_mono.mono fun a h => by\n              induction' n with n ih\n              · exact le_rfl\n              · exact le_trans (h n) ih\n          congr_arg iSup <|\n            funext fun n =>\n              lintegral_sub (h_meas _) (ne_top_of_le_ne_top h_fin <| lintegral_mono_ae <| h_mono n)\n                (h_mono n))\n        _ = ∫⁻ a, f 0 a ∂μ - ⨅ n, ∫⁻ a, f n a ∂μ := ENNReal.sub_iInf.symm\n\n"}
{"name":"MeasureTheory.lintegral_iInf","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : Nat → α → ENNReal\nh_meas : ∀ (n : Nat), Measurable (f n)\nh_anti : Antitone f\nh_fin : Ne (MeasureTheory.lintegral μ fun a => f 0 a) Top.top\n⊢ Eq (MeasureTheory.lintegral μ fun a => iInf fun n => f n a) (iInf fun n => MeasureTheory.lintegral μ fun a => f n a)","decl":"/-- Monotone convergence theorem for nonincreasing sequences of functions -/\ntheorem lintegral_iInf {f : ℕ → α → ℝ≥0∞} (h_meas : ∀ n, Measurable (f n)) (h_anti : Antitone f)\n    (h_fin : ∫⁻ a, f 0 a ∂μ ≠ ∞) : ∫⁻ a, ⨅ n, f n a ∂μ = ⨅ n, ∫⁻ a, f n a ∂μ :=\n  lintegral_iInf_ae h_meas (fun n => ae_of_all _ <| h_anti n.le_succ) h_fin\n\n"}
{"name":"MeasureTheory.lintegral_iInf'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : Nat → α → ENNReal\nh_meas : ∀ (n : Nat), AEMeasurable (f n) μ\nh_anti : Filter.Eventually (fun a => Antitone fun i => f i a) (MeasureTheory.ae μ)\nh_fin : Ne (MeasureTheory.lintegral μ fun a => f 0 a) Top.top\n⊢ Eq (MeasureTheory.lintegral μ fun a => iInf fun n => f n a) (iInf fun n => MeasureTheory.lintegral μ fun a => f n a)","decl":"theorem lintegral_iInf' {f : ℕ → α → ℝ≥0∞} (h_meas : ∀ n, AEMeasurable (f n) μ)\n    (h_anti : ∀ᵐ a ∂μ, Antitone (fun i ↦ f i a)) (h_fin : ∫⁻ a, f 0 a ∂μ ≠ ∞) :\n    ∫⁻ a, ⨅ n, f n a ∂μ = ⨅ n, ∫⁻ a, f n a ∂μ := by\n  simp_rw [← iInf_apply]\n  let p : α → (ℕ → ℝ≥0∞) → Prop := fun _ f' => Antitone f'\n  have hp : ∀ᵐ x ∂μ, p x fun i => f i x := h_anti\n  have h_ae_seq_mono : Antitone (aeSeq h_meas p) := by\n    intro n m hnm x\n    by_cases hx : x ∈ aeSeqSet h_meas p\n    · exact aeSeq.prop_of_mem_aeSeqSet h_meas hx hnm\n    · simp only [aeSeq, hx, if_false]\n      exact le_rfl\n  rw [lintegral_congr_ae (aeSeq.iInf h_meas hp).symm]\n  simp_rw [iInf_apply]\n  rw [lintegral_iInf (aeSeq.measurable h_meas p) h_ae_seq_mono]\n  · congr\n    exact funext fun n ↦ lintegral_congr_ae (aeSeq.aeSeq_n_eq_fun_n_ae h_meas hp n)\n  · rwa [lintegral_congr_ae (aeSeq.aeSeq_n_eq_fun_n_ae h_meas hp 0)]\n\n"}
{"name":"MeasureTheory.lintegral_iInf_directed_of_measurable","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\ninst✝ : Countable β\nf : β → α → ENNReal\nμ : MeasureTheory.Measure α\nhμ : Ne μ 0\nhf : ∀ (b : β), Measurable (f b)\nhf_int : ∀ (b : β), Ne (MeasureTheory.lintegral μ fun a => f b a) Top.top\nh_directed : Directed (fun x1 x2 => GE.ge x1 x2) f\n⊢ Eq (MeasureTheory.lintegral μ fun a => iInf fun b => f b a) (iInf fun b => MeasureTheory.lintegral μ fun a => f b a)","decl":"/-- Monotone convergence for an infimum over a directed family and indexed by a countable type -/\ntheorem lintegral_iInf_directed_of_measurable {mα : MeasurableSpace α} [Countable β]\n    {f : β → α → ℝ≥0∞} {μ : Measure α} (hμ : μ ≠ 0) (hf : ∀ b, Measurable (f b))\n    (hf_int : ∀ b, ∫⁻ a, f b a ∂μ ≠ ∞) (h_directed : Directed (· ≥ ·) f) :\n    ∫⁻ a, ⨅ b, f b a ∂μ = ⨅ b, ∫⁻ a, f b a ∂μ := by\n  cases nonempty_encodable β\n  cases isEmpty_or_nonempty β\n  · simp only [iInf_of_empty, lintegral_const,\n      ENNReal.top_mul (Measure.measure_univ_ne_zero.mpr hμ)]\n  inhabit β\n  have : ∀ a, ⨅ b, f b a = ⨅ n, f (h_directed.sequence f n) a := by\n    refine fun a =>\n      le_antisymm (le_iInf fun n => iInf_le _ _)\n        (le_iInf fun b => iInf_le_of_le (Encodable.encode b + 1) ?_)\n    exact h_directed.sequence_le b a\n  -- Porting note: used `∘` below to deal with its reduced reducibility\n  calc\n    ∫⁻ a, ⨅ b, f b a ∂μ\n    _ = ∫⁻ a, ⨅ n, (f ∘ h_directed.sequence f) n a ∂μ := by simp only [this, Function.comp_apply]\n    _ = ⨅ n, ∫⁻ a, (f ∘ h_directed.sequence f) n a ∂μ := by\n      rw [lintegral_iInf ?_ h_directed.sequence_anti]\n      · exact hf_int _\n      · exact fun n => hf _\n    _ = ⨅ b, ∫⁻ a, f b a ∂μ := by\n      refine le_antisymm (le_iInf fun b => ?_) (le_iInf fun n => ?_)\n      · exact iInf_le_of_le (Encodable.encode b + 1) (lintegral_mono <| h_directed.sequence_le b)\n      · exact iInf_le (fun b => ∫⁻ a, f b a ∂μ) _\n\n"}
{"name":"MeasureTheory.lintegral_liminf_le'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : Nat → α → ENNReal\nh_meas : ∀ (n : Nat), AEMeasurable (f n) μ\n⊢ LE.le (MeasureTheory.lintegral μ fun a => Filter.liminf (fun n => f n a) Filter.atTop) (Filter.liminf (fun n => MeasureTheory.lintegral μ fun a => f n a) Filter.atTop)","decl":"/-- Known as Fatou's lemma, version with `AEMeasurable` functions -/\ntheorem lintegral_liminf_le' {f : ℕ → α → ℝ≥0∞} (h_meas : ∀ n, AEMeasurable (f n) μ) :\n    ∫⁻ a, liminf (fun n => f n a) atTop ∂μ ≤ liminf (fun n => ∫⁻ a, f n a ∂μ) atTop :=\n  calc\n    ∫⁻ a, liminf (fun n => f n a) atTop ∂μ = ∫⁻ a, ⨆ n : ℕ, ⨅ i ≥ n, f i a ∂μ := by\n      simp only [liminf_eq_iSup_iInf_of_nat]\n    _ = ⨆ n : ℕ, ∫⁻ a, ⨅ i ≥ n, f i a ∂μ :=\n      (lintegral_iSup' (fun _ => .biInf _ (to_countable _) (fun i _ ↦ h_meas i))\n        (ae_of_all μ fun _ _ _ hnm => iInf_le_iInf_of_subset fun _ hi => le_trans hnm hi))\n    _ ≤ ⨆ n : ℕ, ⨅ i ≥ n, ∫⁻ a, f i a ∂μ := iSup_mono fun _ => le_iInf₂_lintegral _\n    _ = atTop.liminf fun n => ∫⁻ a, f n a ∂μ := Filter.liminf_eq_iSup_iInf_of_nat.symm\n\n"}
{"name":"MeasureTheory.lintegral_liminf_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : Nat → α → ENNReal\nh_meas : ∀ (n : Nat), Measurable (f n)\n⊢ LE.le (MeasureTheory.lintegral μ fun a => Filter.liminf (fun n => f n a) Filter.atTop) (Filter.liminf (fun n => MeasureTheory.lintegral μ fun a => f n a) Filter.atTop)","decl":"/-- Known as Fatou's lemma -/\ntheorem lintegral_liminf_le {f : ℕ → α → ℝ≥0∞} (h_meas : ∀ n, Measurable (f n)) :\n    ∫⁻ a, liminf (fun n => f n a) atTop ∂μ ≤ liminf (fun n => ∫⁻ a, f n a ∂μ) atTop :=\n  lintegral_liminf_le' fun n => (h_meas n).aemeasurable\n\n"}
{"name":"MeasureTheory.limsup_lintegral_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : Nat → α → ENNReal\ng : α → ENNReal\nhf_meas : ∀ (n : Nat), Measurable (f n)\nh_bound : ∀ (n : Nat), (MeasureTheory.ae μ).EventuallyLE (f n) g\nh_fin : Ne (MeasureTheory.lintegral μ fun a => g a) Top.top\n⊢ LE.le (Filter.limsup (fun n => MeasureTheory.lintegral μ fun a => f n a) Filter.atTop) (MeasureTheory.lintegral μ fun a => Filter.limsup (fun n => f n a) Filter.atTop)","decl":"theorem limsup_lintegral_le {f : ℕ → α → ℝ≥0∞} (g : α → ℝ≥0∞) (hf_meas : ∀ n, Measurable (f n))\n    (h_bound : ∀ n, f n ≤ᵐ[μ] g) (h_fin : ∫⁻ a, g a ∂μ ≠ ∞) :\n    limsup (fun n => ∫⁻ a, f n a ∂μ) atTop ≤ ∫⁻ a, limsup (fun n => f n a) atTop ∂μ :=\n  calc\n    limsup (fun n => ∫⁻ a, f n a ∂μ) atTop = ⨅ n : ℕ, ⨆ i ≥ n, ∫⁻ a, f i a ∂μ :=\n      limsup_eq_iInf_iSup_of_nat\n    _ ≤ ⨅ n : ℕ, ∫⁻ a, ⨆ i ≥ n, f i a ∂μ := iInf_mono fun _ => iSup₂_lintegral_le _\n    _ = ∫⁻ a, ⨅ n : ℕ, ⨆ i ≥ n, f i a ∂μ := by\n      refine (lintegral_iInf ?_ ?_ ?_).symm\n      · intro n\n        exact .biSup _ (to_countable _) (fun i _ ↦ hf_meas i)\n      · intro n m hnm a\n        exact iSup_le_iSup_of_subset fun i hi => le_trans hnm hi\n      · refine ne_top_of_le_ne_top h_fin (lintegral_mono_ae ?_)\n        refine (ae_all_iff.2 h_bound).mono fun n hn => ?_\n        exact iSup_le fun i => iSup_le fun _ => hn i\n    _ = ∫⁻ a, limsup (fun n => f n a) atTop ∂μ := by simp only [limsup_eq_iInf_iSup_of_nat]\n\n"}
{"name":"MeasureTheory.tendsto_lintegral_of_dominated_convergence","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nF : Nat → α → ENNReal\nf bound : α → ENNReal\nhF_meas : ∀ (n : Nat), Measurable (F n)\nh_bound : ∀ (n : Nat), (MeasureTheory.ae μ).EventuallyLE (F n) bound\nh_fin : Ne (MeasureTheory.lintegral μ fun a => bound a) Top.top\nh_lim : Filter.Eventually (fun a => Filter.Tendsto (fun n => F n a) Filter.atTop (nhds (f a))) (MeasureTheory.ae μ)\n⊢ Filter.Tendsto (fun n => MeasureTheory.lintegral μ fun a => F n a) Filter.atTop (nhds (MeasureTheory.lintegral μ fun a => f a))","decl":"/-- Dominated convergence theorem for nonnegative functions -/\ntheorem tendsto_lintegral_of_dominated_convergence {F : ℕ → α → ℝ≥0∞} {f : α → ℝ≥0∞}\n    (bound : α → ℝ≥0∞) (hF_meas : ∀ n, Measurable (F n)) (h_bound : ∀ n, F n ≤ᵐ[μ] bound)\n    (h_fin : ∫⁻ a, bound a ∂μ ≠ ∞) (h_lim : ∀ᵐ a ∂μ, Tendsto (fun n => F n a) atTop (𝓝 (f a))) :\n    Tendsto (fun n => ∫⁻ a, F n a ∂μ) atTop (𝓝 (∫⁻ a, f a ∂μ)) :=\n  tendsto_of_le_liminf_of_limsup_le\n    (calc\n      ∫⁻ a, f a ∂μ = ∫⁻ a, liminf (fun n : ℕ => F n a) atTop ∂μ :=\n        lintegral_congr_ae <| h_lim.mono fun _ h => h.liminf_eq.symm\n      _ ≤ liminf (fun n => ∫⁻ a, F n a ∂μ) atTop := lintegral_liminf_le hF_meas\n      )\n    (calc\n      limsup (fun n : ℕ => ∫⁻ a, F n a ∂μ) atTop ≤ ∫⁻ a, limsup (fun n => F n a) atTop ∂μ :=\n        limsup_lintegral_le _ hF_meas h_bound h_fin\n      _ = ∫⁻ a, f a ∂μ := lintegral_congr_ae <| h_lim.mono fun _ h => h.limsup_eq\n      )\n\n"}
{"name":"MeasureTheory.tendsto_lintegral_of_dominated_convergence'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nF : Nat → α → ENNReal\nf bound : α → ENNReal\nhF_meas : ∀ (n : Nat), AEMeasurable (F n) μ\nh_bound : ∀ (n : Nat), (MeasureTheory.ae μ).EventuallyLE (F n) bound\nh_fin : Ne (MeasureTheory.lintegral μ fun a => bound a) Top.top\nh_lim : Filter.Eventually (fun a => Filter.Tendsto (fun n => F n a) Filter.atTop (nhds (f a))) (MeasureTheory.ae μ)\n⊢ Filter.Tendsto (fun n => MeasureTheory.lintegral μ fun a => F n a) Filter.atTop (nhds (MeasureTheory.lintegral μ fun a => f a))","decl":"/-- Dominated convergence theorem for nonnegative functions which are just almost everywhere\nmeasurable. -/\ntheorem tendsto_lintegral_of_dominated_convergence' {F : ℕ → α → ℝ≥0∞} {f : α → ℝ≥0∞}\n    (bound : α → ℝ≥0∞) (hF_meas : ∀ n, AEMeasurable (F n) μ) (h_bound : ∀ n, F n ≤ᵐ[μ] bound)\n    (h_fin : ∫⁻ a, bound a ∂μ ≠ ∞) (h_lim : ∀ᵐ a ∂μ, Tendsto (fun n => F n a) atTop (𝓝 (f a))) :\n    Tendsto (fun n => ∫⁻ a, F n a ∂μ) atTop (𝓝 (∫⁻ a, f a ∂μ)) := by\n  have : ∀ n, ∫⁻ a, F n a ∂μ = ∫⁻ a, (hF_meas n).mk (F n) a ∂μ := fun n =>\n    lintegral_congr_ae (hF_meas n).ae_eq_mk\n  simp_rw [this]\n  apply\n    tendsto_lintegral_of_dominated_convergence bound (fun n => (hF_meas n).measurable_mk) _ h_fin\n  · have : ∀ n, ∀ᵐ a ∂μ, (hF_meas n).mk (F n) a = F n a := fun n => (hF_meas n).ae_eq_mk.symm\n    have : ∀ᵐ a ∂μ, ∀ n, (hF_meas n).mk (F n) a = F n a := ae_all_iff.mpr this\n    filter_upwards [this, h_lim] with a H H'\n    simp_rw [H]\n    exact H'\n  · intro n\n    filter_upwards [h_bound n, (hF_meas n).ae_eq_mk] with a H H'\n    rwa [H'] at H\n\n"}
{"name":"MeasureTheory.tendsto_lintegral_filter_of_dominated_convergence","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nι : Type u_5\nl : Filter ι\ninst✝ : l.IsCountablyGenerated\nF : ι → α → ENNReal\nf bound : α → ENNReal\nhF_meas : Filter.Eventually (fun n => Measurable (F n)) l\nh_bound : Filter.Eventually (fun n => Filter.Eventually (fun a => LE.le (F n a) (bound a)) (MeasureTheory.ae μ)) l\nh_fin : Ne (MeasureTheory.lintegral μ fun a => bound a) Top.top\nh_lim : Filter.Eventually (fun a => Filter.Tendsto (fun n => F n a) l (nhds (f a))) (MeasureTheory.ae μ)\n⊢ Filter.Tendsto (fun n => MeasureTheory.lintegral μ fun a => F n a) l (nhds (MeasureTheory.lintegral μ fun a => f a))","decl":"/-- Dominated convergence theorem for filters with a countable basis -/\ntheorem tendsto_lintegral_filter_of_dominated_convergence {ι} {l : Filter ι}\n    [l.IsCountablyGenerated] {F : ι → α → ℝ≥0∞} {f : α → ℝ≥0∞} (bound : α → ℝ≥0∞)\n    (hF_meas : ∀ᶠ n in l, Measurable (F n)) (h_bound : ∀ᶠ n in l, ∀ᵐ a ∂μ, F n a ≤ bound a)\n    (h_fin : ∫⁻ a, bound a ∂μ ≠ ∞) (h_lim : ∀ᵐ a ∂μ, Tendsto (fun n => F n a) l (𝓝 (f a))) :\n    Tendsto (fun n => ∫⁻ a, F n a ∂μ) l (𝓝 <| ∫⁻ a, f a ∂μ) := by\n  rw [tendsto_iff_seq_tendsto]\n  intro x xl\n  have hxl := by\n    rw [tendsto_atTop'] at xl\n    exact xl\n  have h := inter_mem hF_meas h_bound\n  replace h := hxl _ h\n  rcases h with ⟨k, h⟩\n  rw [← tendsto_add_atTop_iff_nat k]\n  refine tendsto_lintegral_of_dominated_convergence ?_ ?_ ?_ ?_ ?_\n  · exact bound\n  · intro\n    refine (h _ ?_).1\n    exact Nat.le_add_left _ _\n  · intro\n    refine (h _ ?_).2\n    exact Nat.le_add_left _ _\n  · assumption\n  · refine h_lim.mono fun a h_lim => ?_\n    apply @Tendsto.comp _ _ _ (fun n => x (n + k)) fun n => F n a\n    · assumption\n    rw [tendsto_add_atTop_iff_nat]\n    assumption\n\n"}
{"name":"MeasureTheory.lintegral_tendsto_of_tendsto_of_antitone","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : Nat → α → ENNReal\nF : α → ENNReal\nhf : ∀ (n : Nat), AEMeasurable (f n) μ\nh_anti : Filter.Eventually (fun x => Antitone fun n => f n x) (MeasureTheory.ae μ)\nh0 : Ne (MeasureTheory.lintegral μ fun a => f 0 a) Top.top\nh_tendsto : Filter.Eventually (fun x => Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) (MeasureTheory.ae μ)\n⊢ Filter.Tendsto (fun n => MeasureTheory.lintegral μ fun x => f n x) Filter.atTop (nhds (MeasureTheory.lintegral μ fun x => F x))","decl":"theorem lintegral_tendsto_of_tendsto_of_antitone {f : ℕ → α → ℝ≥0∞} {F : α → ℝ≥0∞}\n    (hf : ∀ n, AEMeasurable (f n) μ) (h_anti : ∀ᵐ x ∂μ, Antitone fun n ↦ f n x)\n    (h0 : ∫⁻ a, f 0 a ∂μ ≠ ∞)\n    (h_tendsto : ∀ᵐ x ∂μ, Tendsto (fun n ↦ f n x) atTop (𝓝 (F x))) :\n    Tendsto (fun n ↦ ∫⁻ x, f n x ∂μ) atTop (𝓝 (∫⁻ x, F x ∂μ)) := by\n  have : Antitone fun n ↦ ∫⁻ x, f n x ∂μ := fun i j hij ↦\n    lintegral_mono_ae (h_anti.mono fun x hx ↦ hx hij)\n  suffices key : ∫⁻ x, F x ∂μ = ⨅ n, ∫⁻ x, f n x ∂μ by\n    rw [key]\n    exact tendsto_atTop_iInf this\n  rw [← lintegral_iInf' hf h_anti h0]\n  refine lintegral_congr_ae ?_\n  filter_upwards [h_anti, h_tendsto] with _ hx_anti hx_tendsto\n    using tendsto_nhds_unique hx_tendsto (tendsto_atTop_iInf hx_anti)\n\n"}
{"name":"MeasureTheory.lintegral_iSup_directed_of_measurable","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : Countable β\nf : β → α → ENNReal\nhf : ∀ (b : β), Measurable (f b)\nh_directed : Directed (fun x1 x2 => LE.le x1 x2) f\n⊢ Eq (MeasureTheory.lintegral μ fun a => iSup fun b => f b a) (iSup fun b => MeasureTheory.lintegral μ fun a => f b a)","decl":"/-- Monotone convergence for a supremum over a directed family and indexed by a countable type -/\ntheorem lintegral_iSup_directed_of_measurable [Countable β] {f : β → α → ℝ≥0∞}\n    (hf : ∀ b, Measurable (f b)) (h_directed : Directed (· ≤ ·) f) :\n    ∫⁻ a, ⨆ b, f b a ∂μ = ⨆ b, ∫⁻ a, f b a ∂μ := by\n  cases nonempty_encodable β\n  cases isEmpty_or_nonempty β\n  · simp [iSup_of_empty]\n  inhabit β\n  have : ∀ a, ⨆ b, f b a = ⨆ n, f (h_directed.sequence f n) a := by\n    intro a\n    refine le_antisymm (iSup_le fun b => ?_) (iSup_le fun n => le_iSup (fun n => f n a) _)\n    exact le_iSup_of_le (encode b + 1) (h_directed.le_sequence b a)\n  calc\n    ∫⁻ a, ⨆ b, f b a ∂μ = ∫⁻ a, ⨆ n, f (h_directed.sequence f n) a ∂μ := by simp only [this]\n    _ = ⨆ n, ∫⁻ a, f (h_directed.sequence f n) a ∂μ :=\n      (lintegral_iSup (fun n => hf _) h_directed.sequence_mono)\n    _ = ⨆ b, ∫⁻ a, f b a ∂μ := by\n      refine le_antisymm (iSup_le fun n => ?_) (iSup_le fun b => ?_)\n      · exact le_iSup (fun b => ∫⁻ a, f b a ∂μ) _\n      · exact le_iSup_of_le (encode b + 1) (lintegral_mono <| h_directed.le_sequence b)\n\n"}
{"name":"MeasureTheory.lintegral_iSup_directed","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : Countable β\nf : β → α → ENNReal\nhf : ∀ (b : β), AEMeasurable (f b) μ\nh_directed : Directed (fun x1 x2 => LE.le x1 x2) f\n⊢ Eq (MeasureTheory.lintegral μ fun a => iSup fun b => f b a) (iSup fun b => MeasureTheory.lintegral μ fun a => f b a)","decl":"/-- Monotone convergence for a supremum over a directed family and indexed by a countable type. -/\ntheorem lintegral_iSup_directed [Countable β] {f : β → α → ℝ≥0∞} (hf : ∀ b, AEMeasurable (f b) μ)\n    (h_directed : Directed (· ≤ ·) f) : ∫⁻ a, ⨆ b, f b a ∂μ = ⨆ b, ∫⁻ a, f b a ∂μ := by\n  simp_rw [← iSup_apply]\n  let p : α → (β → ENNReal) → Prop := fun x f' => Directed LE.le f'\n  have hp : ∀ᵐ x ∂μ, p x fun i => f i x := by\n    filter_upwards [] with x i j\n    obtain ⟨z, hz₁, hz₂⟩ := h_directed i j\n    exact ⟨z, hz₁ x, hz₂ x⟩\n  have h_ae_seq_directed : Directed LE.le (aeSeq hf p) := by\n    intro b₁ b₂\n    obtain ⟨z, hz₁, hz₂⟩ := h_directed b₁ b₂\n    refine ⟨z, ?_, ?_⟩ <;>\n      · intro x\n        by_cases hx : x ∈ aeSeqSet hf p\n        · repeat rw [aeSeq.aeSeq_eq_fun_of_mem_aeSeqSet hf hx]\n          apply_rules [hz₁, hz₂]\n        · simp only [aeSeq, hx, if_false]\n          exact le_rfl\n  convert lintegral_iSup_directed_of_measurable (aeSeq.measurable hf p) h_ae_seq_directed using 1\n  · simp_rw [← iSup_apply]\n    rw [lintegral_congr_ae (aeSeq.iSup hf hp).symm]\n  · congr 1\n    ext1 b\n    rw [lintegral_congr_ae]\n    apply EventuallyEq.symm\n    exact aeSeq.aeSeq_n_eq_fun_n_ae hf hp _\n\n"}
{"name":"MeasureTheory.lintegral_tsum","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : Countable β\nf : β → α → ENNReal\nhf : ∀ (i : β), AEMeasurable (f i) μ\n⊢ Eq (MeasureTheory.lintegral μ fun a => tsum fun i => f i a) (tsum fun i => MeasureTheory.lintegral μ fun a => f i a)","decl":"theorem lintegral_tsum [Countable β] {f : β → α → ℝ≥0∞} (hf : ∀ i, AEMeasurable (f i) μ) :\n    ∫⁻ a, ∑' i, f i a ∂μ = ∑' i, ∫⁻ a, f i a ∂μ := by\n  classical\n  simp only [ENNReal.tsum_eq_iSup_sum]\n  rw [lintegral_iSup_directed]\n  · simp [lintegral_finset_sum' _ fun i _ => hf i]\n  · intro b\n    exact Finset.aemeasurable_sum _ fun i _ => hf i\n  · intro s t\n    use s ∪ t\n    constructor\n    · exact fun a => Finset.sum_le_sum_of_subset Finset.subset_union_left\n    · exact fun a => Finset.sum_le_sum_of_subset Finset.subset_union_right\n\n"}
{"name":"MeasureTheory.lintegral_iUnion₀","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : Countable β\ns : β → Set α\nhm : ∀ (i : β), MeasureTheory.NullMeasurableSet (s i) μ\nhd : Pairwise (Function.onFun (MeasureTheory.AEDisjoint μ) s)\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral (μ.restrict (Set.iUnion fun i => s i)) fun a => f a) (tsum fun i => MeasureTheory.lintegral (μ.restrict (s i)) fun a => f a)","decl":"theorem lintegral_iUnion₀ [Countable β] {s : β → Set α} (hm : ∀ i, NullMeasurableSet (s i) μ)\n    (hd : Pairwise (AEDisjoint μ on s)) (f : α → ℝ≥0∞) :\n    ∫⁻ a in ⋃ i, s i, f a ∂μ = ∑' i, ∫⁻ a in s i, f a ∂μ := by\n  simp only [Measure.restrict_iUnion_ae hd hm, lintegral_sum_measure]\n\n"}
{"name":"MeasureTheory.lintegral_iUnion","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : Countable β\ns : β → Set α\nhm : ∀ (i : β), MeasurableSet (s i)\nhd : Pairwise (Function.onFun Disjoint s)\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral (μ.restrict (Set.iUnion fun i => s i)) fun a => f a) (tsum fun i => MeasureTheory.lintegral (μ.restrict (s i)) fun a => f a)","decl":"theorem lintegral_iUnion [Countable β] {s : β → Set α} (hm : ∀ i, MeasurableSet (s i))\n    (hd : Pairwise (Disjoint on s)) (f : α → ℝ≥0∞) :\n    ∫⁻ a in ⋃ i, s i, f a ∂μ = ∑' i, ∫⁻ a in s i, f a ∂μ :=\n  lintegral_iUnion₀ (fun i => (hm i).nullMeasurableSet) hd.aedisjoint f\n\n"}
{"name":"MeasureTheory.lintegral_biUnion₀","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nt : Set β\ns : β → Set α\nht : t.Countable\nhm : ∀ (i : β), Membership.mem t i → MeasureTheory.NullMeasurableSet (s i) μ\nhd : t.Pairwise (Function.onFun (MeasureTheory.AEDisjoint μ) s)\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral (μ.restrict (Set.iUnion fun i => Set.iUnion fun h => s i)) fun a => f a) (tsum fun i => MeasureTheory.lintegral (μ.restrict (s ↑i)) fun a => f a)","decl":"theorem lintegral_biUnion₀ {t : Set β} {s : β → Set α} (ht : t.Countable)\n    (hm : ∀ i ∈ t, NullMeasurableSet (s i) μ) (hd : t.Pairwise (AEDisjoint μ on s)) (f : α → ℝ≥0∞) :\n    ∫⁻ a in ⋃ i ∈ t, s i, f a ∂μ = ∑' i : t, ∫⁻ a in s i, f a ∂μ := by\n  haveI := ht.toEncodable\n  rw [biUnion_eq_iUnion, lintegral_iUnion₀ (SetCoe.forall'.1 hm) (hd.subtype _ _)]\n\n"}
{"name":"MeasureTheory.lintegral_biUnion","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nt : Set β\ns : β → Set α\nht : t.Countable\nhm : ∀ (i : β), Membership.mem t i → MeasurableSet (s i)\nhd : t.PairwiseDisjoint s\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral (μ.restrict (Set.iUnion fun i => Set.iUnion fun h => s i)) fun a => f a) (tsum fun i => MeasureTheory.lintegral (μ.restrict (s ↑i)) fun a => f a)","decl":"theorem lintegral_biUnion {t : Set β} {s : β → Set α} (ht : t.Countable)\n    (hm : ∀ i ∈ t, MeasurableSet (s i)) (hd : t.PairwiseDisjoint s) (f : α → ℝ≥0∞) :\n    ∫⁻ a in ⋃ i ∈ t, s i, f a ∂μ = ∑' i : t, ∫⁻ a in s i, f a ∂μ :=\n  lintegral_biUnion₀ ht (fun i hi => (hm i hi).nullMeasurableSet) hd.aedisjoint f\n\n"}
{"name":"MeasureTheory.lintegral_biUnion_finset₀","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Finset β\nt : β → Set α\nhd : (↑s).Pairwise (Function.onFun (MeasureTheory.AEDisjoint μ) t)\nhm : ∀ (b : β), Membership.mem s b → MeasureTheory.NullMeasurableSet (t b) μ\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral (μ.restrict (Set.iUnion fun b => Set.iUnion fun h => t b)) fun a => f a) (s.sum fun b => MeasureTheory.lintegral (μ.restrict (t b)) fun a => f a)","decl":"theorem lintegral_biUnion_finset₀ {s : Finset β} {t : β → Set α}\n    (hd : Set.Pairwise (↑s) (AEDisjoint μ on t)) (hm : ∀ b ∈ s, NullMeasurableSet (t b) μ)\n    (f : α → ℝ≥0∞) : ∫⁻ a in ⋃ b ∈ s, t b, f a ∂μ = ∑ b ∈ s, ∫⁻ a in t b, f a ∂μ := by\n  simp only [← Finset.mem_coe, lintegral_biUnion₀ s.countable_toSet hm hd, ← Finset.tsum_subtype']\n\n"}
{"name":"MeasureTheory.lintegral_biUnion_finset","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Finset β\nt : β → Set α\nhd : (↑s).PairwiseDisjoint t\nhm : ∀ (b : β), Membership.mem s b → MeasurableSet (t b)\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral (μ.restrict (Set.iUnion fun b => Set.iUnion fun h => t b)) fun a => f a) (s.sum fun b => MeasureTheory.lintegral (μ.restrict (t b)) fun a => f a)","decl":"theorem lintegral_biUnion_finset {s : Finset β} {t : β → Set α} (hd : Set.PairwiseDisjoint (↑s) t)\n    (hm : ∀ b ∈ s, MeasurableSet (t b)) (f : α → ℝ≥0∞) :\n    ∫⁻ a in ⋃ b ∈ s, t b, f a ∂μ = ∑ b ∈ s, ∫⁻ a in t b, f a ∂μ :=\n  lintegral_biUnion_finset₀ hd.aedisjoint (fun b hb => (hm b hb).nullMeasurableSet) f\n\n"}
{"name":"MeasureTheory.lintegral_iUnion_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : Countable β\ns : β → Set α\nf : α → ENNReal\n⊢ LE.le (MeasureTheory.lintegral (μ.restrict (Set.iUnion fun i => s i)) fun a => f a) (tsum fun i => MeasureTheory.lintegral (μ.restrict (s i)) fun a => f a)","decl":"theorem lintegral_iUnion_le [Countable β] (s : β → Set α) (f : α → ℝ≥0∞) :\n    ∫⁻ a in ⋃ i, s i, f a ∂μ ≤ ∑' i, ∫⁻ a in s i, f a ∂μ := by\n  rw [← lintegral_sum_measure]\n  exact lintegral_mono' restrict_iUnion_le le_rfl\n\n"}
{"name":"MeasureTheory.lintegral_union","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nA B : Set α\nhB : MeasurableSet B\nhAB : Disjoint A B\n⊢ Eq (MeasureTheory.lintegral (μ.restrict (Union.union A B)) fun a => f a) (HAdd.hAdd (MeasureTheory.lintegral (μ.restrict A) fun a => f a) (MeasureTheory.lintegral (μ.restrict B) fun a => f a))","decl":"theorem lintegral_union {f : α → ℝ≥0∞} {A B : Set α} (hB : MeasurableSet B) (hAB : Disjoint A B) :\n    ∫⁻ a in A ∪ B, f a ∂μ = ∫⁻ a in A, f a ∂μ + ∫⁻ a in B, f a ∂μ := by\n  rw [restrict_union hAB hB, lintegral_add_measure]\n\n"}
{"name":"MeasureTheory.lintegral_union_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\ns t : Set α\n⊢ LE.le (MeasureTheory.lintegral (μ.restrict (Union.union s t)) fun a => f a) (HAdd.hAdd (MeasureTheory.lintegral (μ.restrict s) fun a => f a) (MeasureTheory.lintegral (μ.restrict t) fun a => f a))","decl":"theorem lintegral_union_le (f : α → ℝ≥0∞) (s t : Set α) :\n    ∫⁻ a in s ∪ t, f a ∂μ ≤ ∫⁻ a in s, f a ∂μ + ∫⁻ a in t, f a ∂μ := by\n  rw [← lintegral_add_measure]\n  exact lintegral_mono' (restrict_union_le _ _) le_rfl\n\n"}
{"name":"MeasureTheory.lintegral_inter_add_diff","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nB : Set α\nf : α → ENNReal\nA : Set α\nhB : MeasurableSet B\n⊢ Eq (HAdd.hAdd (MeasureTheory.lintegral (μ.restrict (Inter.inter A B)) fun x => f x) (MeasureTheory.lintegral (μ.restrict (SDiff.sdiff A B)) fun x => f x)) (MeasureTheory.lintegral (μ.restrict A) fun x => f x)","decl":"theorem lintegral_inter_add_diff {B : Set α} (f : α → ℝ≥0∞) (A : Set α) (hB : MeasurableSet B) :\n    ∫⁻ x in A ∩ B, f x ∂μ + ∫⁻ x in A \\ B, f x ∂μ = ∫⁻ x in A, f x ∂μ := by\n  rw [← lintegral_add_measure, restrict_inter_add_diff _ hB]\n\n"}
{"name":"MeasureTheory.lintegral_add_compl","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nA : Set α\nhA : MeasurableSet A\n⊢ Eq (HAdd.hAdd (MeasureTheory.lintegral (μ.restrict A) fun x => f x) (MeasureTheory.lintegral (μ.restrict (HasCompl.compl A)) fun x => f x)) (MeasureTheory.lintegral μ fun x => f x)","decl":"theorem lintegral_add_compl (f : α → ℝ≥0∞) {A : Set α} (hA : MeasurableSet A) :\n    ∫⁻ x in A, f x ∂μ + ∫⁻ x in Aᶜ, f x ∂μ = ∫⁻ x, f x ∂μ := by\n  rw [← lintegral_add_measure, Measure.restrict_add_restrict_compl hA]\n\n"}
{"name":"MeasureTheory.setLintegral_compl","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\ns : Set α\nhsm : MeasurableSet s\nhfs : Ne (MeasureTheory.lintegral (μ.restrict s) fun x => f x) Top.top\n⊢ Eq (MeasureTheory.lintegral (μ.restrict (HasCompl.compl s)) fun x => f x) (HSub.hSub (MeasureTheory.lintegral μ fun x => f x) (MeasureTheory.lintegral (μ.restrict s) fun x => f x))","decl":"theorem setLintegral_compl {f : α → ℝ≥0∞} {s : Set α} (hsm : MeasurableSet s)\n    (hfs : ∫⁻ x in s, f x ∂μ ≠ ∞) :\n    ∫⁻ x in sᶜ, f x ∂μ = ∫⁻ x, f x ∂μ - ∫⁻ x in s, f x ∂μ := by\n  rw [← lintegral_add_compl (μ := μ) f hsm, ENNReal.add_sub_cancel_left hfs]\n\n"}
{"name":"MeasureTheory.setLIntegral_iUnion_of_directed","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nι : Type u_5\ninst✝ : Countable ι\nf : α → ENNReal\ns : ι → Set α\nhd : Directed (fun x1 x2 => HasSubset.Subset x1 x2) s\n⊢ Eq (MeasureTheory.lintegral (μ.restrict (Set.iUnion fun i => s i)) fun x => f x) (iSup fun i => MeasureTheory.lintegral (μ.restrict (s i)) fun x => f x)","decl":"theorem setLIntegral_iUnion_of_directed {ι : Type*} [Countable ι]\n    (f : α → ℝ≥0∞) {s : ι → Set α} (hd : Directed (· ⊆ ·) s) :\n    ∫⁻ x in ⋃ i, s i, f x ∂μ = ⨆ i, ∫⁻ x in s i, f x ∂μ := by\n  simp only [lintegral_def, iSup_comm (ι := ι),\n    SimpleFunc.lintegral_restrict_iUnion_of_directed _ hd]\n\n"}
{"name":"MeasureTheory.lintegral_max","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\nhf : Measurable f\nhg : Measurable g\n⊢ Eq (MeasureTheory.lintegral μ fun x => Max.max (f x) (g x)) (HAdd.hAdd (MeasureTheory.lintegral (μ.restrict (setOf fun x => LE.le (f x) (g x))) fun x => g x) (MeasureTheory.lintegral (μ.restrict (setOf fun x => LT.lt (g x) (f x))) fun x => f x))","decl":"theorem lintegral_max {f g : α → ℝ≥0∞} (hf : Measurable f) (hg : Measurable g) :\n    ∫⁻ x, max (f x) (g x) ∂μ =\n      ∫⁻ x in { x | f x ≤ g x }, g x ∂μ + ∫⁻ x in { x | g x < f x }, f x ∂μ := by\n  have hm : MeasurableSet { x | f x ≤ g x } := measurableSet_le hf hg\n  rw [← lintegral_add_compl (fun x => max (f x) (g x)) hm]\n  simp only [← compl_setOf, ← not_le]\n  refine congr_arg₂ (· + ·) (setLIntegral_congr_fun hm ?_) (setLIntegral_congr_fun hm.compl ?_)\n  exacts [ae_of_all _ fun x => max_eq_right (a := f x) (b := g x),\n    ae_of_all _ fun x (hx : ¬ f x ≤ g x) => max_eq_left (not_le.1 hx).le]\n\n"}
{"name":"MeasureTheory.setLIntegral_max","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\nhf : Measurable f\nhg : Measurable g\ns : Set α\n⊢ Eq (MeasureTheory.lintegral (μ.restrict s) fun x => Max.max (f x) (g x)) (HAdd.hAdd (MeasureTheory.lintegral (μ.restrict (Inter.inter s (setOf fun x => LE.le (f x) (g x)))) fun x => g x) (MeasureTheory.lintegral (μ.restrict (Inter.inter s (setOf fun x => LT.lt (g x) (f x)))) fun x => f x))","decl":"theorem setLIntegral_max {f g : α → ℝ≥0∞} (hf : Measurable f) (hg : Measurable g) (s : Set α) :\n    ∫⁻ x in s, max (f x) (g x) ∂μ =\n      ∫⁻ x in s ∩ { x | f x ≤ g x }, g x ∂μ + ∫⁻ x in s ∩ { x | g x < f x }, f x ∂μ := by\n  rw [lintegral_max hf hg, restrict_restrict, restrict_restrict, inter_comm s, inter_comm s]\n  exacts [measurableSet_lt hg hf, measurableSet_le hf hg]\n\n"}
{"name":"MeasureTheory.lintegral_map","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nmβ : MeasurableSpace β\nf : β → ENNReal\ng : α → β\nhf : Measurable f\nhg : Measurable g\n⊢ Eq (MeasureTheory.lintegral (MeasureTheory.Measure.map g μ) fun a => f a) (MeasureTheory.lintegral μ fun a => f (g a))","decl":"theorem lintegral_map {mβ : MeasurableSpace β} {f : β → ℝ≥0∞} {g : α → β} (hf : Measurable f)\n    (hg : Measurable g) : ∫⁻ a, f a ∂map g μ = ∫⁻ a, f (g a) ∂μ := by\n  erw [lintegral_eq_iSup_eapprox_lintegral hf, lintegral_eq_iSup_eapprox_lintegral (hf.comp hg)]\n  congr with n : 1\n  convert SimpleFunc.lintegral_map _ hg\n  ext1 x; simp only [eapprox_comp hf hg, coe_comp]\n\n"}
{"name":"MeasureTheory.lintegral_map'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nmβ : MeasurableSpace β\nf : β → ENNReal\ng : α → β\nhf : AEMeasurable f (MeasureTheory.Measure.map g μ)\nhg : AEMeasurable g μ\n⊢ Eq (MeasureTheory.lintegral (MeasureTheory.Measure.map g μ) fun a => f a) (MeasureTheory.lintegral μ fun a => f (g a))","decl":"theorem lintegral_map' {mβ : MeasurableSpace β} {f : β → ℝ≥0∞} {g : α → β}\n    (hf : AEMeasurable f (Measure.map g μ)) (hg : AEMeasurable g μ) :\n    ∫⁻ a, f a ∂Measure.map g μ = ∫⁻ a, f (g a) ∂μ :=\n  calc\n    ∫⁻ a, f a ∂Measure.map g μ = ∫⁻ a, hf.mk f a ∂Measure.map g μ :=\n      lintegral_congr_ae hf.ae_eq_mk\n    _ = ∫⁻ a, hf.mk f a ∂Measure.map (hg.mk g) μ := by\n      congr 1\n      exact Measure.map_congr hg.ae_eq_mk\n    _ = ∫⁻ a, hf.mk f (hg.mk g a) ∂μ := lintegral_map hf.measurable_mk hg.measurable_mk\n    _ = ∫⁻ a, hf.mk f (g a) ∂μ := lintegral_congr_ae <| hg.ae_eq_mk.symm.fun_comp _\n    _ = ∫⁻ a, f (g a) ∂μ := lintegral_congr_ae (ae_eq_comp hg hf.ae_eq_mk.symm)\n\n"}
{"name":"MeasureTheory.lintegral_map_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nmβ : MeasurableSpace β\nf : β → ENNReal\ng : α → β\nhg : Measurable g\n⊢ LE.le (MeasureTheory.lintegral (MeasureTheory.Measure.map g μ) fun a => f a) (MeasureTheory.lintegral μ fun a => f (g a))","decl":"theorem lintegral_map_le {mβ : MeasurableSpace β} (f : β → ℝ≥0∞) {g : α → β} (hg : Measurable g) :\n    ∫⁻ a, f a ∂Measure.map g μ ≤ ∫⁻ a, f (g a) ∂μ := by\n  rw [← iSup_lintegral_measurable_le_eq_lintegral, ← iSup_lintegral_measurable_le_eq_lintegral]\n  refine iSup₂_le fun i hi => iSup_le fun h'i => ?_\n  refine le_iSup₂_of_le (i ∘ g) (hi.comp hg) ?_\n  exact le_iSup_of_le (fun x => h'i (g x)) (le_of_eq (lintegral_map hi hg))\n\n"}
{"name":"MeasureTheory.lintegral_comp","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasurableSpace β\nf : β → ENNReal\ng : α → β\nhf : Measurable f\nhg : Measurable g\n⊢ Eq (MeasureTheory.lintegral μ (Function.comp f g)) (MeasureTheory.lintegral (MeasureTheory.Measure.map g μ) fun a => f a)","decl":"theorem lintegral_comp [MeasurableSpace β] {f : β → ℝ≥0∞} {g : α → β} (hf : Measurable f)\n    (hg : Measurable g) : lintegral μ (f ∘ g) = ∫⁻ a, f a ∂map g μ :=\n  (lintegral_map hf hg).symm\n\n"}
{"name":"MeasureTheory.setLIntegral_map","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasurableSpace β\nf : β → ENNReal\ng : α → β\ns : Set β\nhs : MeasurableSet s\nhf : Measurable f\nhg : Measurable g\n⊢ Eq (MeasureTheory.lintegral ((MeasureTheory.Measure.map g μ).restrict s) fun y => f y) (MeasureTheory.lintegral (μ.restrict (Set.preimage g s)) fun x => f (g x))","decl":"theorem setLIntegral_map [MeasurableSpace β] {f : β → ℝ≥0∞} {g : α → β} {s : Set β}\n    (hs : MeasurableSet s) (hf : Measurable f) (hg : Measurable g) :\n    ∫⁻ y in s, f y ∂map g μ = ∫⁻ x in g ⁻¹' s, f (g x) ∂μ := by\n  rw [restrict_map hg hs, lintegral_map hf hg]\n\n"}
{"name":"MeasureTheory.lintegral_indicator_const_comp","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nmβ : MeasurableSpace β\nf : α → β\ns : Set β\nhf : Measurable f\nhs : MeasurableSet s\nc : ENNReal\n⊢ Eq (MeasureTheory.lintegral μ fun a => s.indicator (fun x => c) (f a)) (HMul.hMul c (μ (Set.preimage f s)))","decl":"theorem lintegral_indicator_const_comp {mβ : MeasurableSpace β} {f : α → β} {s : Set β}\n    (hf : Measurable f) (hs : MeasurableSet s) (c : ℝ≥0∞) :\n    ∫⁻ a, s.indicator (fun _ => c) (f a) ∂μ = c * μ (f ⁻¹' s) := by\n  erw [lintegral_comp (measurable_const.indicator hs) hf, lintegral_indicator_const hs,\n    Measure.map_apply hf hs]\n\n"}
{"name":"MeasurableEmbedding.lintegral_map","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasurableSpace β\ng : α → β\nhg : MeasurableEmbedding g\nf : β → ENNReal\n⊢ Eq (MeasureTheory.lintegral (MeasureTheory.Measure.map g μ) fun a => f a) (MeasureTheory.lintegral μ fun a => f (g a))","decl":"/-- If `g : α → β` is a measurable embedding and `f : β → ℝ≥0∞` is any function (not necessarily\nmeasurable), then `∫⁻ a, f a ∂(map g μ) = ∫⁻ a, f (g a) ∂μ`. Compare with `lintegral_map` which\napplies to any measurable `g : α → β` but requires that `f` is measurable as well. -/\ntheorem _root_.MeasurableEmbedding.lintegral_map [MeasurableSpace β] {g : α → β}\n    (hg : MeasurableEmbedding g) (f : β → ℝ≥0∞) : ∫⁻ a, f a ∂map g μ = ∫⁻ a, f (g a) ∂μ := by\n  rw [lintegral, lintegral]\n  refine le_antisymm (iSup₂_le fun f₀ hf₀ => ?_) (iSup₂_le fun f₀ hf₀ => ?_)\n  · rw [SimpleFunc.lintegral_map _ hg.measurable]\n    have : (f₀.comp g hg.measurable : α → ℝ≥0∞) ≤ f ∘ g := fun x => hf₀ (g x)\n    exact le_iSup_of_le (comp f₀ g hg.measurable) (by exact le_iSup (α := ℝ≥0∞) _ this)\n  · rw [← f₀.extend_comp_eq hg (const _ 0), ← SimpleFunc.lintegral_map, ←\n      SimpleFunc.lintegral_eq_lintegral, ← lintegral]\n    refine lintegral_mono_ae (hg.ae_map_iff.2 <| Eventually.of_forall fun x => ?_)\n    exact (extend_apply _ _ _ _).trans_le (hf₀ _)\n\n"}
{"name":"MeasureTheory.lintegral_map_equiv","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasurableSpace β\nf : β → ENNReal\ng : MeasurableEquiv α β\n⊢ Eq (MeasureTheory.lintegral (MeasureTheory.Measure.map (⇑g) μ) fun a => f a) (MeasureTheory.lintegral μ fun a => f (g a))","decl":"/-- The `lintegral` transforms appropriately under a measurable equivalence `g : α ≃ᵐ β`.\n(Compare `lintegral_map`, which applies to a wider class of functions `g : α → β`, but requires\nmeasurability of the function being integrated.) -/\ntheorem lintegral_map_equiv [MeasurableSpace β] (f : β → ℝ≥0∞) (g : α ≃ᵐ β) :\n    ∫⁻ a, f a ∂map g μ = ∫⁻ a, f (g a) ∂μ :=\n  g.measurableEmbedding.lintegral_map f\n\n"}
{"name":"MeasureTheory.MeasurePreserving.lintegral_map_equiv","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasurableSpace β\nν : MeasureTheory.Measure β\nf : β → ENNReal\ng : MeasurableEquiv α β\nhg : MeasureTheory.MeasurePreserving (⇑g) μ ν\n⊢ Eq (MeasureTheory.lintegral ν fun a => f a) (MeasureTheory.lintegral μ fun a => f (g a))","decl":"protected theorem MeasurePreserving.lintegral_map_equiv [MeasurableSpace β] {ν : Measure β}\n    (f : β → ℝ≥0∞) (g : α ≃ᵐ β) (hg : MeasurePreserving g μ ν) :\n    ∫⁻ a, f a ∂ν = ∫⁻ a, f (g a) ∂μ := by\n  rw [← MeasureTheory.lintegral_map_equiv f g, hg.map_eq]\n\n"}
{"name":"MeasureTheory.MeasurePreserving.lintegral_comp","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nmb : MeasurableSpace β\nν : MeasureTheory.Measure β\ng : α → β\nhg : MeasureTheory.MeasurePreserving g μ ν\nf : β → ENNReal\nhf : Measurable f\n⊢ Eq (MeasureTheory.lintegral μ fun a => f (g a)) (MeasureTheory.lintegral ν fun b => f b)","decl":"theorem MeasurePreserving.lintegral_comp {mb : MeasurableSpace β} {ν : Measure β} {g : α → β}\n    (hg : MeasurePreserving g μ ν) {f : β → ℝ≥0∞} (hf : Measurable f) :\n    ∫⁻ a, f (g a) ∂μ = ∫⁻ b, f b ∂ν := by rw [← hg.map_eq, lintegral_map hf hg.measurable]\n\n"}
{"name":"MeasureTheory.MeasurePreserving.lintegral_comp_emb","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nmb : MeasurableSpace β\nν : MeasureTheory.Measure β\ng : α → β\nhg : MeasureTheory.MeasurePreserving g μ ν\nhge : MeasurableEmbedding g\nf : β → ENNReal\n⊢ Eq (MeasureTheory.lintegral μ fun a => f (g a)) (MeasureTheory.lintegral ν fun b => f b)","decl":"theorem MeasurePreserving.lintegral_comp_emb {mb : MeasurableSpace β} {ν : Measure β} {g : α → β}\n    (hg : MeasurePreserving g μ ν) (hge : MeasurableEmbedding g) (f : β → ℝ≥0∞) :\n    ∫⁻ a, f (g a) ∂μ = ∫⁻ b, f b ∂ν := by rw [← hg.map_eq, hge.lintegral_map]\n\n"}
{"name":"MeasureTheory.MeasurePreserving.setLIntegral_comp_preimage","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nmb : MeasurableSpace β\nν : MeasureTheory.Measure β\ng : α → β\nhg : MeasureTheory.MeasurePreserving g μ ν\ns : Set β\nhs : MeasurableSet s\nf : β → ENNReal\nhf : Measurable f\n⊢ Eq (MeasureTheory.lintegral (μ.restrict (Set.preimage g s)) fun a => f (g a)) (MeasureTheory.lintegral (ν.restrict s) fun b => f b)","decl":"theorem MeasurePreserving.setLIntegral_comp_preimage {mb : MeasurableSpace β} {ν : Measure β}\n    {g : α → β} (hg : MeasurePreserving g μ ν) {s : Set β} (hs : MeasurableSet s) {f : β → ℝ≥0∞}\n    (hf : Measurable f) : ∫⁻ a in g ⁻¹' s, f (g a) ∂μ = ∫⁻ b in s, f b ∂ν := by\n  rw [← hg.map_eq, setLIntegral_map hs hf hg.measurable]\n\n"}
{"name":"MeasureTheory.MeasurePreserving.setLIntegral_comp_preimage_emb","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nmb : MeasurableSpace β\nν : MeasureTheory.Measure β\ng : α → β\nhg : MeasureTheory.MeasurePreserving g μ ν\nhge : MeasurableEmbedding g\nf : β → ENNReal\ns : Set β\n⊢ Eq (MeasureTheory.lintegral (μ.restrict (Set.preimage g s)) fun a => f (g a)) (MeasureTheory.lintegral (ν.restrict s) fun b => f b)","decl":"theorem MeasurePreserving.setLIntegral_comp_preimage_emb {mb : MeasurableSpace β} {ν : Measure β}\n    {g : α → β} (hg : MeasurePreserving g μ ν) (hge : MeasurableEmbedding g) (f : β → ℝ≥0∞)\n    (s : Set β) : ∫⁻ a in g ⁻¹' s, f (g a) ∂μ = ∫⁻ b in s, f b ∂ν := by\n  rw [← hg.map_eq, hge.restrict_map, hge.lintegral_map]\n\n"}
{"name":"MeasureTheory.MeasurePreserving.setLIntegral_comp_emb","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nmb : MeasurableSpace β\nν : MeasureTheory.Measure β\ng : α → β\nhg : MeasureTheory.MeasurePreserving g μ ν\nhge : MeasurableEmbedding g\nf : β → ENNReal\ns : Set α\n⊢ Eq (MeasureTheory.lintegral (μ.restrict s) fun a => f (g a)) (MeasureTheory.lintegral (ν.restrict (Set.image g s)) fun b => f b)","decl":"theorem MeasurePreserving.setLIntegral_comp_emb {mb : MeasurableSpace β} {ν : Measure β}\n    {g : α → β} (hg : MeasurePreserving g μ ν) (hge : MeasurableEmbedding g) (f : β → ℝ≥0∞)\n    (s : Set α) : ∫⁻ a in s, f (g a) ∂μ = ∫⁻ b in g '' s, f b ∂ν := by\n  rw [← hg.setLIntegral_comp_preimage_emb hge, preimage_image_eq _ hge.injective]\n\n"}
{"name":"MeasureTheory.lintegral_subtype_comap","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral (MeasureTheory.Measure.comap Subtype.val μ) fun x => f ↑x) (MeasureTheory.lintegral (μ.restrict s) fun x => f x)","decl":"theorem lintegral_subtype_comap {s : Set α} (hs : MeasurableSet s) (f : α → ℝ≥0∞) :\n    ∫⁻ x : s, f x ∂(μ.comap (↑)) = ∫⁻ x in s, f x ∂μ := by\n  rw [← (MeasurableEmbedding.subtype_coe hs).lintegral_map, map_comap_subtype_coe hs]\n\n"}
{"name":"MeasureTheory.setLIntegral_subtype","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\nt : Set ↑s\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral ((MeasureTheory.Measure.comap Subtype.val μ).restrict t) fun x => f ↑x) (MeasureTheory.lintegral (μ.restrict (Set.image Subtype.val t)) fun x => f x)","decl":"theorem setLIntegral_subtype {s : Set α} (hs : MeasurableSet s) (t : Set s) (f : α → ℝ≥0∞) :\n    ∫⁻ x in t, f x ∂(μ.comap (↑)) = ∫⁻ x in (↑) '' t, f x ∂μ := by\n  rw [(MeasurableEmbedding.subtype_coe hs).restrict_comap, lintegral_subtype_comap hs,\n    restrict_restrict hs, inter_eq_right.2 (Subtype.coe_image_subset _ _)]\n\n"}
{"name":"MeasureTheory.exists_setLintegral_compl_lt","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : Ne (MeasureTheory.lintegral μ fun a => f a) Top.top\nε : ENNReal\nhε : Ne ε 0\n⊢ Exists fun s => And (MeasurableSet s) (And (LT.lt (μ s) Top.top) (LT.lt (MeasureTheory.lintegral (μ.restrict (HasCompl.compl s)) fun a => f a) ε))","decl":"/-- If `f : α → ℝ≥0∞` has finite integral, then there exists a measurable set `s` of finite measure\nsuch that the integral of `f` over `sᶜ` is less than a given positive number.\n\nAlso used to prove an `Lᵖ`-norm version in\n`MeasureTheory.Memℒp.exists_eLpNorm_indicator_compl_le`. -/\ntheorem exists_setLintegral_compl_lt {f : α → ℝ≥0∞} (hf : ∫⁻ a, f a ∂μ ≠ ∞)\n    {ε : ℝ≥0∞} (hε : ε ≠ 0) :\n    ∃ s : Set α, MeasurableSet s ∧ μ s < ∞ ∧ ∫⁻ a in sᶜ, f a ∂μ < ε := by\n  by_cases hf₀ : ∫⁻ a, f a ∂μ = 0\n  · exact ⟨∅, .empty, by simp, by simpa [hf₀, pos_iff_ne_zero]⟩\n  obtain ⟨g, hgf, hg_meas, hgsupp, hgε⟩ :\n      ∃ g ≤ f, Measurable g ∧ μ (support g) < ∞ ∧ ∫⁻ a, f a ∂μ - ε < ∫⁻ a, g a ∂μ := by\n    obtain ⟨g, hgf, hgε⟩ : ∃ (g : α →ₛ ℝ≥0∞) (_ : g ≤ f), ∫⁻ a, f a ∂μ - ε < g.lintegral μ := by\n      simpa only [← lt_iSup_iff, ← lintegral_def] using ENNReal.sub_lt_self hf hf₀ hε\n    refine ⟨g, hgf, g.measurable, ?_, by rwa [g.lintegral_eq_lintegral]⟩\n    exact SimpleFunc.FinMeasSupp.of_lintegral_ne_top <| ne_top_of_le_ne_top hf <|\n      g.lintegral_eq_lintegral μ ▸ lintegral_mono hgf\n  refine ⟨_, measurableSet_support hg_meas, hgsupp, ?_⟩\n  calc\n    ∫⁻ a in (support g)ᶜ, f a ∂μ\n      = ∫⁻ a in (support g)ᶜ, f a - g a ∂μ := setLIntegral_congr_fun\n      (measurableSet_support hg_meas).compl <| ae_of_all _ <| by intro; simp_all\n    _ ≤ ∫⁻ a, f a - g a ∂μ := setLIntegral_le_lintegral _ _\n    _ = ∫⁻ a, f a ∂μ - ∫⁻ a, g a ∂μ :=\n      lintegral_sub hg_meas (ne_top_of_le_ne_top hf <| lintegral_mono hgf) (ae_of_all _ hgf)\n    _ < ε := ENNReal.sub_lt_of_lt_add (lintegral_mono hgf) <|\n      ENNReal.lt_add_of_sub_lt_left (.inl hf) hgε\n\n"}
{"name":"MeasureTheory.exists_measurable_le_setLintegral_eq_of_integrable","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : Ne (MeasureTheory.lintegral μ fun a => f a) Top.top\n⊢ Exists fun g => And (Measurable g) (And (LE.le g f) (∀ (s : Set α), MeasurableSet s → Eq (MeasureTheory.lintegral (μ.restrict s) fun a => f a) (MeasureTheory.lintegral (μ.restrict s) fun a => g a)))","decl":"/-- For any function `f : α → ℝ≥0∞`, there exists a measurable function `g ≤ f` with the same\nintegral over any measurable set. -/\ntheorem exists_measurable_le_setLintegral_eq_of_integrable {f : α → ℝ≥0∞} (hf : ∫⁻ a, f a ∂μ ≠ ∞) :\n    ∃ (g : α → ℝ≥0∞), Measurable g ∧ g ≤ f ∧ ∀ s : Set α, MeasurableSet s →\n      ∫⁻ a in s, f a ∂μ = ∫⁻ a in s, g a ∂μ := by\n  obtain ⟨g, hmg, hgf, hifg⟩ := exists_measurable_le_lintegral_eq (μ := μ) f\n  use g, hmg, hgf\n  refine fun s hms ↦ le_antisymm ?_ (lintegral_mono hgf)\n  rw [← compl_compl s, setLintegral_compl hms.compl, setLintegral_compl hms.compl, hifg]\n  · gcongr; apply hgf\n  · rw [hifg] at hf\n    exact ne_top_of_le_ne_top hf (setLIntegral_le_lintegral _ _)\n  · exact ne_top_of_le_ne_top hf (setLIntegral_le_lintegral _ _)\n\n"}
{"name":"MeasureTheory.lintegral_dirac'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\na : α\nf : α → ENNReal\nhf : Measurable f\n⊢ Eq (MeasureTheory.lintegral (MeasureTheory.Measure.dirac a) fun a => f a) (f a)","decl":"theorem lintegral_dirac' (a : α) {f : α → ℝ≥0∞} (hf : Measurable f) : ∫⁻ a, f a ∂dirac a = f a := by\n  simp [lintegral_congr_ae (ae_eq_dirac' hf)]\n\n"}
{"name":"MeasureTheory.lintegral_dirac","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSingletonClass α\na : α\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral (MeasureTheory.Measure.dirac a) fun a => f a) (f a)","decl":"theorem lintegral_dirac [MeasurableSingletonClass α] (a : α) (f : α → ℝ≥0∞) :\n    ∫⁻ a, f a ∂dirac a = f a := by simp [lintegral_congr_ae (ae_eq_dirac f)]\n\n"}
{"name":"MeasureTheory.setLIntegral_dirac'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\na : α\nf : α → ENNReal\nhf : Measurable f\ns : Set α\nhs : MeasurableSet s\ninst✝ : Decidable (Membership.mem s a)\n⊢ Eq (MeasureTheory.lintegral ((MeasureTheory.Measure.dirac a).restrict s) fun x => f x) (ite (Membership.mem s a) (f a) 0)","decl":"theorem setLIntegral_dirac' {a : α} {f : α → ℝ≥0∞} (hf : Measurable f) {s : Set α}\n    (hs : MeasurableSet s) [Decidable (a ∈ s)] :\n    ∫⁻ x in s, f x ∂Measure.dirac a = if a ∈ s then f a else 0 := by\n  rw [restrict_dirac' hs]\n  split_ifs\n  · exact lintegral_dirac' _ hf\n  · exact lintegral_zero_measure _\n\n"}
{"name":"MeasureTheory.setLIntegral_dirac","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\na : α\nf : α → ENNReal\ns : Set α\ninst✝¹ : MeasurableSingletonClass α\ninst✝ : Decidable (Membership.mem s a)\n⊢ Eq (MeasureTheory.lintegral ((MeasureTheory.Measure.dirac a).restrict s) fun x => f x) (ite (Membership.mem s a) (f a) 0)","decl":"theorem setLIntegral_dirac {a : α} (f : α → ℝ≥0∞) (s : Set α) [MeasurableSingletonClass α]\n    [Decidable (a ∈ s)] : ∫⁻ x in s, f x ∂Measure.dirac a = if a ∈ s then f a else 0 := by\n  rw [restrict_dirac]\n  split_ifs\n  · exact lintegral_dirac _ _\n  · exact lintegral_zero_measure _\n\n"}
{"name":"MeasureTheory.lintegral_count'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → ENNReal\nhf : Measurable f\n⊢ Eq (MeasureTheory.lintegral MeasureTheory.Measure.count fun a => f a) (tsum fun a => f a)","decl":"theorem lintegral_count' {f : α → ℝ≥0∞} (hf : Measurable f) : ∫⁻ a, f a ∂count = ∑' a, f a := by\n  rw [count, lintegral_sum_measure]\n  congr\n  exact funext fun a => lintegral_dirac' a hf\n\n"}
{"name":"MeasureTheory.lintegral_count","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSingletonClass α\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral MeasureTheory.Measure.count fun a => f a) (tsum fun a => f a)","decl":"theorem lintegral_count [MeasurableSingletonClass α] (f : α → ℝ≥0∞) :\n    ∫⁻ a, f a ∂count = ∑' a, f a := by\n  rw [count, lintegral_sum_measure]\n  congr\n  exact funext fun a => lintegral_dirac a f\n\n"}
{"name":"ENNReal.tsum_const_eq","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSingletonClass α\nc : ENNReal\n⊢ Eq (tsum fun x => c) (HMul.hMul c (MeasureTheory.Measure.count Set.univ))","decl":"theorem _root_.ENNReal.tsum_const_eq [MeasurableSingletonClass α] (c : ℝ≥0∞) :\n    ∑' _ : α, c = c * Measure.count (univ : Set α) := by rw [← lintegral_count, lintegral_const]\n\n"}
{"name":"ENNReal.count_const_le_le_of_tsum_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSingletonClass α\na : α → ENNReal\na_mble : Measurable a\nc : ENNReal\ntsum_le_c : LE.le (tsum fun i => a i) c\nε : ENNReal\nε_ne_zero : Ne ε 0\nε_ne_top : Ne ε Top.top\n⊢ LE.le (MeasureTheory.Measure.count (setOf fun i => LE.le ε (a i))) (HDiv.hDiv c ε)","decl":"/-- Markov's inequality for the counting measure with hypothesis using `tsum` in `ℝ≥0∞`. -/\ntheorem _root_.ENNReal.count_const_le_le_of_tsum_le [MeasurableSingletonClass α] {a : α → ℝ≥0∞}\n    (a_mble : Measurable a) {c : ℝ≥0∞} (tsum_le_c : ∑' i, a i ≤ c) {ε : ℝ≥0∞} (ε_ne_zero : ε ≠ 0)\n    (ε_ne_top : ε ≠ ∞) : Measure.count { i : α | ε ≤ a i } ≤ c / ε := by\n  rw [← lintegral_count] at tsum_le_c\n  apply (MeasureTheory.meas_ge_le_lintegral_div a_mble.aemeasurable ε_ne_zero ε_ne_top).trans\n  exact ENNReal.div_le_div tsum_le_c rfl.le\n\n"}
{"name":"NNReal.count_const_le_le_of_tsum_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSingletonClass α\na : α → NNReal\na_mble : Measurable a\na_summable : Summable a\nc : NNReal\ntsum_le_c : LE.le (tsum fun i => a i) c\nε : NNReal\nε_ne_zero : Ne ε 0\n⊢ LE.le (MeasureTheory.Measure.count (setOf fun i => LE.le ε (a i))) (HDiv.hDiv ↑c ↑ε)","decl":"/-- Markov's inequality for counting measure with hypothesis using `tsum` in `ℝ≥0`. -/\ntheorem _root_.NNReal.count_const_le_le_of_tsum_le [MeasurableSingletonClass α] {a : α → ℝ≥0}\n    (a_mble : Measurable a) (a_summable : Summable a) {c : ℝ≥0} (tsum_le_c : ∑' i, a i ≤ c)\n    {ε : ℝ≥0} (ε_ne_zero : ε ≠ 0) : Measure.count { i : α | ε ≤ a i } ≤ c / ε := by\n  rw [show (fun i => ε ≤ a i) = fun i => (ε : ℝ≥0∞) ≤ ((↑) ∘ a) i by\n      funext i\n      simp only [ENNReal.coe_le_coe, Function.comp]]\n  apply\n    ENNReal.count_const_le_le_of_tsum_le (measurable_coe_nnreal_ennreal.comp a_mble) _\n      (mod_cast ε_ne_zero) (@ENNReal.coe_ne_top ε)\n  convert ENNReal.coe_le_coe.mpr tsum_le_c\n  simp_rw [Function.comp_apply]\n  rw [ENNReal.tsum_coe_eq a_summable.hasSum]\n\n"}
{"name":"MeasureTheory.lintegral_countable'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : Countable α\ninst✝ : MeasurableSingletonClass α\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral μ fun a => f a) (tsum fun a => HMul.hMul (f a) (μ (Singleton.singleton a)))","decl":"theorem lintegral_countable' [Countable α] [MeasurableSingletonClass α] (f : α → ℝ≥0∞) :\n    ∫⁻ a, f a ∂μ = ∑' a, f a * μ {a} := by\n  conv_lhs => rw [← sum_smul_dirac μ, lintegral_sum_measure]\n  congr 1 with a : 1\n  rw [lintegral_smul_measure, lintegral_dirac, mul_comm]\n\n"}
{"name":"MeasureTheory.lintegral_singleton'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : Measurable f\na : α\n⊢ Eq (MeasureTheory.lintegral (μ.restrict (Singleton.singleton a)) fun x => f x) (HMul.hMul (f a) (μ (Singleton.singleton a)))","decl":"theorem lintegral_singleton' {f : α → ℝ≥0∞} (hf : Measurable f) (a : α) :\n    ∫⁻ x in {a}, f x ∂μ = f a * μ {a} := by\n  simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac' _ hf, mul_comm]\n\n"}
{"name":"MeasureTheory.lintegral_singleton","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasurableSingletonClass α\nf : α → ENNReal\na : α\n⊢ Eq (MeasureTheory.lintegral (μ.restrict (Singleton.singleton a)) fun x => f x) (HMul.hMul (f a) (μ (Singleton.singleton a)))","decl":"theorem lintegral_singleton [MeasurableSingletonClass α] (f : α → ℝ≥0∞) (a : α) :\n    ∫⁻ x in {a}, f x ∂μ = f a * μ {a} := by\n  simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac, mul_comm]\n\n"}
{"name":"MeasureTheory.lintegral_countable","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasurableSingletonClass α\nf : α → ENNReal\ns : Set α\nhs : s.Countable\n⊢ Eq (MeasureTheory.lintegral (μ.restrict s) fun a => f a) (tsum fun a => HMul.hMul (f ↑a) (μ (Singleton.singleton ↑a)))","decl":"theorem lintegral_countable [MeasurableSingletonClass α] (f : α → ℝ≥0∞) {s : Set α}\n    (hs : s.Countable) : ∫⁻ a in s, f a ∂μ = ∑' a : s, f a * μ {(a : α)} :=\n  calc\n    ∫⁻ a in s, f a ∂μ = ∫⁻ a in ⋃ x ∈ s, {x}, f a ∂μ := by rw [biUnion_of_singleton]\n    _ = ∑' a : s, ∫⁻ x in {(a : α)}, f x ∂μ :=\n      (lintegral_biUnion hs (fun _ _ => measurableSet_singleton _) (pairwiseDisjoint_fiber id s) _)\n    _ = ∑' a : s, f a * μ {(a : α)} := by simp only [lintegral_singleton]\n\n"}
{"name":"MeasureTheory.lintegral_insert","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasurableSingletonClass α\na : α\ns : Set α\nh : Not (Membership.mem s a)\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral (μ.restrict (Insert.insert a s)) fun x => f x) (HAdd.hAdd (HMul.hMul (f a) (μ (Singleton.singleton a))) (MeasureTheory.lintegral (μ.restrict s) fun x => f x))","decl":"theorem lintegral_insert [MeasurableSingletonClass α] {a : α} {s : Set α} (h : a ∉ s)\n    (f : α → ℝ≥0∞) : ∫⁻ x in insert a s, f x ∂μ = f a * μ {a} + ∫⁻ x in s, f x ∂μ := by\n  rw [← union_singleton, lintegral_union (measurableSet_singleton a), lintegral_singleton,\n    add_comm]\n  rwa [disjoint_singleton_right]\n\n"}
{"name":"MeasureTheory.lintegral_finset","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasurableSingletonClass α\ns : Finset α\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral (μ.restrict ↑s) fun x => f x) (s.sum fun x => HMul.hMul (f x) (μ (Singleton.singleton x)))","decl":"theorem lintegral_finset [MeasurableSingletonClass α] (s : Finset α) (f : α → ℝ≥0∞) :\n    ∫⁻ x in s, f x ∂μ = ∑ x ∈ s, f x * μ {x} := by\n  simp only [lintegral_countable _ s.countable_toSet, ← Finset.tsum_subtype']\n\n"}
{"name":"MeasureTheory.lintegral_fintype","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasurableSingletonClass α\ninst✝ : Fintype α\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral μ fun x => f x) (Finset.univ.sum fun x => HMul.hMul (f x) (μ (Singleton.singleton x)))","decl":"theorem lintegral_fintype [MeasurableSingletonClass α] [Fintype α] (f : α → ℝ≥0∞) :\n    ∫⁻ x, f x ∂μ = ∑ x, f x * μ {x} := by\n  rw [← lintegral_finset, Finset.coe_univ, Measure.restrict_univ]\n\n"}
{"name":"MeasureTheory.lintegral_unique","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : Unique α\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral μ fun x => f x) (HMul.hMul (f Inhabited.default) (μ Set.univ))","decl":"theorem lintegral_unique [Unique α] (f : α → ℝ≥0∞) : ∫⁻ x, f x ∂μ = f default * μ univ :=\n  calc\n    ∫⁻ x, f x ∂μ = ∫⁻ _, f default ∂μ := lintegral_congr <| Unique.forall_iff.2 rfl\n    _ = f default * μ univ := lintegral_const _\n\n"}
{"name":"MeasureTheory.ae_lt_top'","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : AEMeasurable f μ\nh2f : Ne (MeasureTheory.lintegral μ fun x => f x) Top.top\n⊢ Filter.Eventually (fun x => LT.lt (f x) Top.top) (MeasureTheory.ae μ)","decl":"theorem ae_lt_top' {f : α → ℝ≥0∞} (hf : AEMeasurable f μ) (h2f : ∫⁻ x, f x ∂μ ≠ ∞) :\n    ∀ᵐ x ∂μ, f x < ∞ := by\n  simp_rw [ae_iff, ENNReal.not_lt_top]\n  exact measure_eq_top_of_lintegral_ne_top hf h2f\n\n"}
{"name":"MeasureTheory.ae_lt_top","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : Measurable f\nh2f : Ne (MeasureTheory.lintegral μ fun x => f x) Top.top\n⊢ Filter.Eventually (fun x => LT.lt (f x) Top.top) (MeasureTheory.ae μ)","decl":"theorem ae_lt_top {f : α → ℝ≥0∞} (hf : Measurable f) (h2f : ∫⁻ x, f x ∂μ ≠ ∞) :\n    ∀ᵐ x ∂μ, f x < ∞ :=\n  ae_lt_top' hf.aemeasurable h2f\n\n"}
{"name":"MeasureTheory.setLIntegral_lt_top_of_le_nnreal","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : Ne (μ s) Top.top\nf : α → ENNReal\nhbdd : Exists fun y => ∀ (x : α), Membership.mem s x → LE.le (f x) ↑y\n⊢ LT.lt (MeasureTheory.lintegral (μ.restrict s) fun x => f x) Top.top","decl":"/-- Lebesgue integral of a bounded function over a set of finite measure is finite.\nNote that this lemma assumes no regularity of either `f` or `s`. -/\ntheorem setLIntegral_lt_top_of_le_nnreal {s : Set α} (hs : μ s ≠ ∞) {f : α → ℝ≥0∞}\n    (hbdd : ∃ y : ℝ≥0, ∀ x ∈ s, f x ≤ y) : ∫⁻ x in s, f x ∂μ < ∞ := by\n  obtain ⟨M, hM⟩ := hbdd\n  refine lt_of_le_of_lt (setLIntegral_mono measurable_const hM) ?_\n  simp [ENNReal.mul_lt_top, hs.lt_top]\n\n"}
{"name":"MeasureTheory.setLIntegral_lt_top_of_bddAbove","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : Ne (μ s) Top.top\nf : α → NNReal\nhbdd : BddAbove (Set.image f s)\n⊢ LT.lt (MeasureTheory.lintegral (μ.restrict s) fun x => ↑(f x)) Top.top","decl":"/-- Lebesgue integral of a bounded function over a set of finite measure is finite.\nNote that this lemma assumes no regularity of either `f` or `s`. -/\ntheorem setLIntegral_lt_top_of_bddAbove {s : Set α} (hs : μ s ≠ ∞) {f : α → ℝ≥0}\n    (hbdd : BddAbove (f '' s)) : ∫⁻ x in s, f x ∂μ < ∞ :=\n  setLIntegral_lt_top_of_le_nnreal hs <| hbdd.imp fun _M hM _x hx ↦\n    ENNReal.coe_le_coe.2 <| hM (mem_image_of_mem f hx)\n\n"}
{"name":"MeasureTheory.setLIntegral_lt_top_of_isCompact","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : TopologicalSpace α\ns : Set α\nhs : Ne (μ s) Top.top\nhsc : IsCompact s\nf : α → NNReal\nhf : Continuous f\n⊢ LT.lt (MeasureTheory.lintegral (μ.restrict s) fun x => ↑(f x)) Top.top","decl":"theorem setLIntegral_lt_top_of_isCompact [TopologicalSpace α] {s : Set α}\n    (hs : μ s ≠ ∞) (hsc : IsCompact s) {f : α → ℝ≥0} (hf : Continuous f) :\n    ∫⁻ x in s, f x ∂μ < ∞ :=\n  setLIntegral_lt_top_of_bddAbove hs (hsc.image hf).bddAbove\n\n"}
{"name":"IsFiniteMeasure.lintegral_lt_top_of_bounded_to_ennreal","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_5\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nμ_fin : MeasureTheory.IsFiniteMeasure μ\nf : α → ENNReal\nf_bdd : Exists fun c => ∀ (x : α), LE.le (f x) ↑c\n⊢ LT.lt (MeasureTheory.lintegral μ fun x => f x) Top.top","decl":"theorem _root_.IsFiniteMeasure.lintegral_lt_top_of_bounded_to_ennreal {α : Type*}\n    [MeasurableSpace α] (μ : Measure α) [μ_fin : IsFiniteMeasure μ] {f : α → ℝ≥0∞}\n    (f_bdd : ∃ c : ℝ≥0, ∀ x, f x ≤ c) : ∫⁻ x, f x ∂μ < ∞ := by\n  rw [← μ.restrict_univ]\n  refine setLIntegral_lt_top_of_le_nnreal (measure_ne_top _ _) ?_\n  simpa using f_bdd\n\n"}
{"name":"MeasureTheory.tendsto_of_lintegral_tendsto_of_monotone_aux","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_5\nmα : MeasurableSpace α\nf : Nat → α → ENNReal\nF : α → ENNReal\nμ : MeasureTheory.Measure α\nhf_meas : ∀ (n : Nat), AEMeasurable (f n) μ\nhF_meas : AEMeasurable F μ\nhf_tendsto : Filter.Tendsto (fun i => MeasureTheory.lintegral μ fun a => f i a) Filter.atTop (nhds (MeasureTheory.lintegral μ fun a => F a))\nhf_mono : Filter.Eventually (fun a => Monotone fun i => f i a) (MeasureTheory.ae μ)\nh_bound : Filter.Eventually (fun a => ∀ (i : Nat), LE.le (f i a) (F a)) (MeasureTheory.ae μ)\nh_int_finite : Ne (MeasureTheory.lintegral μ fun a => F a) Top.top\n⊢ Filter.Eventually (fun a => Filter.Tendsto (fun i => f i a) Filter.atTop (nhds (F a))) (MeasureTheory.ae μ)","decl":"/-- If a monotone sequence of functions has an upper bound and the sequence of integrals of these\nfunctions tends to the integral of the upper bound, then the sequence of functions converges\nalmost everywhere to the upper bound. Auxiliary version assuming moreover that the\nfunctions in the sequence are ae measurable. -/\nlemma tendsto_of_lintegral_tendsto_of_monotone_aux {α : Type*} {mα : MeasurableSpace α}\n    {f : ℕ → α → ℝ≥0∞} {F : α → ℝ≥0∞} {μ : Measure α}\n    (hf_meas : ∀ n, AEMeasurable (f n) μ) (hF_meas : AEMeasurable F μ)\n    (hf_tendsto : Tendsto (fun i ↦ ∫⁻ a, f i a ∂μ) atTop (𝓝 (∫⁻ a, F a ∂μ)))\n    (hf_mono : ∀ᵐ a ∂μ, Monotone (fun i ↦ f i a))\n    (h_bound : ∀ᵐ a ∂μ, ∀ i, f i a ≤ F a) (h_int_finite : ∫⁻ a, F a ∂μ ≠ ∞) :\n    ∀ᵐ a ∂μ, Tendsto (fun i ↦ f i a) atTop (𝓝 (F a)) := by\n  have h_bound_finite : ∀ᵐ a ∂μ, F a ≠ ∞ := by\n    filter_upwards [ae_lt_top' hF_meas h_int_finite] with a ha using ha.ne\n  have h_exists : ∀ᵐ a ∂μ, ∃ l, Tendsto (fun i ↦ f i a) atTop (𝓝 l) := by\n    filter_upwards [h_bound, h_bound_finite, hf_mono] with a h_le h_fin h_mono\n    have h_tendsto : Tendsto (fun i ↦ f i a) atTop atTop ∨\n        ∃ l, Tendsto (fun i ↦ f i a) atTop (𝓝 l) := tendsto_of_monotone h_mono\n    cases' h_tendsto with h_absurd h_tendsto\n    · rw [tendsto_atTop_atTop_iff_of_monotone h_mono] at h_absurd\n      obtain ⟨i, hi⟩ := h_absurd (F a + 1)\n      refine absurd (hi.trans (h_le _)) (not_le.mpr ?_)\n      exact ENNReal.lt_add_right h_fin one_ne_zero\n    · exact h_tendsto\n  classical\n  let F' : α → ℝ≥0∞ := fun a ↦ if h : ∃ l, Tendsto (fun i ↦ f i a) atTop (𝓝 l)\n    then h.choose else ∞\n  have hF'_tendsto : ∀ᵐ a ∂μ, Tendsto (fun i ↦ f i a) atTop (𝓝 (F' a)) := by\n    filter_upwards [h_exists] with a ha\n    simp_rw [F', dif_pos ha]\n    exact ha.choose_spec\n  suffices F' =ᵐ[μ] F by\n    filter_upwards [this, hF'_tendsto] with a h_eq h_tendsto using h_eq ▸ h_tendsto\n  have hF'_le : F' ≤ᵐ[μ] F := by\n    filter_upwards [h_bound, hF'_tendsto] with a h_le h_tendsto\n    exact le_of_tendsto' h_tendsto (fun m ↦ h_le _)\n  suffices ∫⁻ a, F' a ∂μ = ∫⁻ a, F a ∂μ from\n    ae_eq_of_ae_le_of_lintegral_le hF'_le (this ▸ h_int_finite) hF_meas this.symm.le\n  refine tendsto_nhds_unique ?_ hf_tendsto\n  exact lintegral_tendsto_of_tendsto_of_monotone hf_meas hf_mono hF'_tendsto\n\n"}
{"name":"MeasureTheory.tendsto_of_lintegral_tendsto_of_monotone","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_5\nmα : MeasurableSpace α\nf : Nat → α → ENNReal\nF : α → ENNReal\nμ : MeasureTheory.Measure α\nhF_meas : AEMeasurable F μ\nhf_tendsto : Filter.Tendsto (fun i => MeasureTheory.lintegral μ fun a => f i a) Filter.atTop (nhds (MeasureTheory.lintegral μ fun a => F a))\nhf_mono : Filter.Eventually (fun a => Monotone fun i => f i a) (MeasureTheory.ae μ)\nh_bound : Filter.Eventually (fun a => ∀ (i : Nat), LE.le (f i a) (F a)) (MeasureTheory.ae μ)\nh_int_finite : Ne (MeasureTheory.lintegral μ fun a => F a) Top.top\n⊢ Filter.Eventually (fun a => Filter.Tendsto (fun i => f i a) Filter.atTop (nhds (F a))) (MeasureTheory.ae μ)","decl":"/-- If a monotone sequence of functions has an upper bound and the sequence of integrals of these\nfunctions tends to the integral of the upper bound, then the sequence of functions converges\nalmost everywhere to the upper bound. -/\nlemma tendsto_of_lintegral_tendsto_of_monotone {α : Type*} {mα : MeasurableSpace α}\n    {f : ℕ → α → ℝ≥0∞} {F : α → ℝ≥0∞} {μ : Measure α}\n    (hF_meas : AEMeasurable F μ)\n    (hf_tendsto : Tendsto (fun i ↦ ∫⁻ a, f i a ∂μ) atTop (𝓝 (∫⁻ a, F a ∂μ)))\n    (hf_mono : ∀ᵐ a ∂μ, Monotone (fun i ↦ f i a))\n    (h_bound : ∀ᵐ a ∂μ, ∀ i, f i a ≤ F a) (h_int_finite : ∫⁻ a, F a ∂μ ≠ ∞) :\n    ∀ᵐ a ∂μ, Tendsto (fun i ↦ f i a) atTop (𝓝 (F a)) := by\n  have : ∀ n, ∃ g : α → ℝ≥0∞, Measurable g ∧ g ≤ f n ∧ ∫⁻ a, f n a ∂μ = ∫⁻ a, g a ∂μ :=\n    fun n ↦ exists_measurable_le_lintegral_eq _ _\n  choose g gmeas gf hg using this\n  let g' : ℕ → α → ℝ≥0∞ := Nat.rec (g 0) (fun n I x ↦ max (g (n+1) x) (I x))\n  have M n : Measurable (g' n) := by\n    induction n with\n    | zero => simp [g', gmeas 0]\n    | succ n ih => exact Measurable.max (gmeas (n+1)) ih\n  have I : ∀ n x, g n x ≤ g' n x := by\n    intro n x\n    cases n with | zero | succ => simp [g']\n  have I' : ∀ᵐ x ∂μ, ∀ n, g' n x ≤ f n x := by\n    filter_upwards [hf_mono] with x hx n\n    induction n with\n    | zero => simpa [g'] using gf 0 x\n    | succ n ih => exact max_le (gf (n+1) x) (ih.trans (hx (Nat.le_succ n)))\n  have Int_eq n : ∫⁻ x, g' n x ∂μ = ∫⁻ x, f n x ∂μ := by\n    apply le_antisymm\n    · apply lintegral_mono_ae\n      filter_upwards [I'] with x hx using hx n\n    · rw [hg n]\n      exact lintegral_mono (I n)\n  have : ∀ᵐ a ∂μ, Tendsto (fun i ↦ g' i a) atTop (𝓝 (F a)) := by\n    apply tendsto_of_lintegral_tendsto_of_monotone_aux _ hF_meas _ _ _ h_int_finite\n    · exact fun n ↦ (M n).aemeasurable\n    · simp_rw [Int_eq]\n      exact hf_tendsto\n    · exact Eventually.of_forall (fun x ↦ monotone_nat_of_le_succ (fun n ↦ le_max_right _ _))\n    · filter_upwards [h_bound, I'] with x h'x hx n using (hx n).trans (h'x n)\n  filter_upwards [this, I', h_bound] with x hx h'x h''x\n  exact tendsto_of_tendsto_of_tendsto_of_le_of_le hx tendsto_const_nhds h'x h''x\n\n"}
{"name":"MeasureTheory.tendsto_of_lintegral_tendsto_of_antitone","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_5\nmα : MeasurableSpace α\nf : Nat → α → ENNReal\nF : α → ENNReal\nμ : MeasureTheory.Measure α\nhf_meas : ∀ (n : Nat), AEMeasurable (f n) μ\nhf_tendsto : Filter.Tendsto (fun i => MeasureTheory.lintegral μ fun a => f i a) Filter.atTop (nhds (MeasureTheory.lintegral μ fun a => F a))\nhf_mono : Filter.Eventually (fun a => Antitone fun i => f i a) (MeasureTheory.ae μ)\nh_bound : Filter.Eventually (fun a => ∀ (i : Nat), LE.le (F a) (f i a)) (MeasureTheory.ae μ)\nh0 : Ne (MeasureTheory.lintegral μ fun a => f 0 a) Top.top\n⊢ Filter.Eventually (fun a => Filter.Tendsto (fun i => f i a) Filter.atTop (nhds (F a))) (MeasureTheory.ae μ)","decl":"/-- If an antitone sequence of functions has a lower bound and the sequence of integrals of these\nfunctions tends to the integral of the lower bound, then the sequence of functions converges\nalmost everywhere to the lower bound. -/\nlemma tendsto_of_lintegral_tendsto_of_antitone {α : Type*} {mα : MeasurableSpace α}\n    {f : ℕ → α → ℝ≥0∞} {F : α → ℝ≥0∞} {μ : Measure α}\n    (hf_meas : ∀ n, AEMeasurable (f n) μ)\n    (hf_tendsto : Tendsto (fun i ↦ ∫⁻ a, f i a ∂μ) atTop (𝓝 (∫⁻ a, F a ∂μ)))\n    (hf_mono : ∀ᵐ a ∂μ, Antitone (fun i ↦ f i a))\n    (h_bound : ∀ᵐ a ∂μ, ∀ i, F a ≤ f i a) (h0 : ∫⁻ a, f 0 a ∂μ ≠ ∞) :\n    ∀ᵐ a ∂μ, Tendsto (fun i ↦ f i a) atTop (𝓝 (F a)) := by\n  have h_int_finite : ∫⁻ a, F a ∂μ ≠ ∞ := by\n    refine ((lintegral_mono_ae ?_).trans_lt h0.lt_top).ne\n    filter_upwards [h_bound] with a ha using ha 0\n  have h_exists : ∀ᵐ a ∂μ, ∃ l, Tendsto (fun i ↦ f i a) atTop (𝓝 l) := by\n    filter_upwards [hf_mono] with a h_mono\n    rcases _root_.tendsto_of_antitone h_mono with h | h\n    · refine ⟨0, h.mono_right ?_⟩\n      rw [OrderBot.atBot_eq]\n      exact pure_le_nhds _\n    · exact h\n  classical\n  let F' : α → ℝ≥0∞ := fun a ↦ if h : ∃ l, Tendsto (fun i ↦ f i a) atTop (𝓝 l)\n    then h.choose else ∞\n  have hF'_tendsto : ∀ᵐ a ∂μ, Tendsto (fun i ↦ f i a) atTop (𝓝 (F' a)) := by\n    filter_upwards [h_exists] with a ha\n    simp_rw [F', dif_pos ha]\n    exact ha.choose_spec\n  suffices F' =ᵐ[μ] F by\n    filter_upwards [this, hF'_tendsto] with a h_eq h_tendsto using h_eq ▸ h_tendsto\n  have hF'_le : F ≤ᵐ[μ] F' := by\n    filter_upwards [h_bound, hF'_tendsto] with a h_le h_tendsto\n    exact ge_of_tendsto' h_tendsto (fun m ↦ h_le _)\n  suffices ∫⁻ a, F' a ∂μ = ∫⁻ a, F a ∂μ by\n    refine (ae_eq_of_ae_le_of_lintegral_le hF'_le h_int_finite ?_ this.le).symm\n    exact ENNReal.aemeasurable_of_tendsto hf_meas hF'_tendsto\n  refine tendsto_nhds_unique ?_ hf_tendsto\n  exact lintegral_tendsto_of_tendsto_of_antitone hf_meas hf_mono h0 hF'_tendsto\n\n"}
{"name":"MeasureTheory.exists_measurable_le_forall_setLIntegral_eq","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite μ\nf : α → ENNReal\n⊢ Exists fun g => And (Measurable g) (And (LE.le g f) (∀ (s : Set α), Eq (MeasureTheory.lintegral (μ.restrict s) fun a => f a) (MeasureTheory.lintegral (μ.restrict s) fun a => g a)))","decl":"variable (μ) in\n/-- If `μ` is an s-finite measure, then for any function `f`\nthere exists a measurable function `g ≤ f`\nthat has the same Lebesgue integral over every set.\n\nFor the integral over the whole space, the statement is true without extra assumptions,\nsee `exists_measurable_le_lintegral_eq`.\nSee also `MeasureTheory.Measure.restrict_toMeasurable_of_sFinite` for a similar result. -/\ntheorem exists_measurable_le_forall_setLIntegral_eq [SFinite μ] (f : α → ℝ≥0∞) :\n    ∃ g : α → ℝ≥0∞, Measurable g ∧ g ≤ f ∧ ∀ s, ∫⁻ a in s, f a ∂μ = ∫⁻ a in s, g a ∂μ := by\n  -- We only need to prove the `≤` inequality for the integrals, the other one follows from `g ≤ f`.\n  rsuffices ⟨g, hgm, hgle, hleg⟩ :\n      ∃ g : α → ℝ≥0∞, Measurable g ∧ g ≤ f ∧ ∀ s, ∫⁻ a in s, f a ∂μ ≤ ∫⁻ a in s, g a ∂μ\n  · exact ⟨g, hgm, hgle, fun s ↦ (hleg s).antisymm (lintegral_mono hgle)⟩\n  -- Without loss of generality, `μ` is a finite measure.\n  wlog h : IsFiniteMeasure μ generalizing μ\n  · choose g hgm hgle hgint using fun n ↦ @this (sfiniteSeq μ n) _ inferInstance\n    refine ⟨fun x ↦ ⨆ n, g n x, .iSup hgm, fun x ↦ iSup_le (hgle · x), fun s ↦ ?_⟩\n    rw [← sum_sfiniteSeq μ, Measure.restrict_sum_of_countable,\n      lintegral_sum_measure, lintegral_sum_measure]\n    exact ENNReal.tsum_le_tsum fun n ↦ (hgint n s).trans (lintegral_mono fun x ↦ le_iSup (g · x) _)\n  -- According to `exists_measurable_le_lintegral_eq`, for any natural `n`\n  -- we can choose a measurable function $g_{n}$\n  -- such that $g_{n}(x) ≤ \\min (f(x), n)$ for all $x$\n  -- and both sides have the same integral over the whole space w.r.t. $μ$.\n  have (n : ℕ): ∃ g : α → ℝ≥0∞, Measurable g ∧ g ≤ f ∧ g ≤ n ∧\n      ∫⁻ a, min (f a) n ∂μ = ∫⁻ a, g a ∂μ := by\n    simpa [and_assoc] using exists_measurable_le_lintegral_eq μ (f ⊓ n)\n  choose g hgm hgf hgle hgint using this\n  -- Let `φ` be the pointwise supremum of the functions $g_{n}$.\n  -- Clearly, `φ` is a measurable function and `φ ≤ f`.\n  set φ : α → ℝ≥0∞ := fun x ↦ ⨆ n, g n x\n  have hφm : Measurable φ := by measurability\n  have hφle : φ ≤ f := fun x ↦ iSup_le (hgf · x)\n  refine ⟨φ, hφm, hφle, fun s ↦ ?_⟩\n  -- Now we show the inequality between set integrals.\n  -- Choose a simple function `ψ ≤ f` with values in `ℝ≥0` and prove for `ψ`.\n  rw [lintegral_eq_nnreal]\n  refine iSup₂_le fun ψ hψ ↦ ?_\n  -- Choose `n` such that `ψ x ≤ n` for all `x`.\n  obtain ⟨n, hn⟩ : ∃ n : ℕ, ∀ x, ψ x ≤ n := by\n    rcases ψ.range.bddAbove with ⟨C, hC⟩\n    exact ⟨⌈C⌉₊, fun x ↦ (hC <| ψ.mem_range_self x).trans (Nat.le_ceil _)⟩\n  calc\n    (ψ.map (↑)).lintegral (μ.restrict s) = ∫⁻ a in s, ψ a ∂μ :=\n      SimpleFunc.lintegral_eq_lintegral .. |>.symm\n    _ ≤ ∫⁻ a in s, min (f a) n ∂μ :=\n      lintegral_mono fun a ↦ le_min (hψ _) (ENNReal.coe_le_coe.2 (hn a))\n    _ ≤ ∫⁻ a in s, g n a ∂μ := by\n      have : ∫⁻ a in (toMeasurable μ s)ᶜ, min (f a) n ∂μ ≠ ∞ :=\n        IsFiniteMeasure.lintegral_lt_top_of_bounded_to_ennreal _ ⟨n, fun _ ↦ min_le_right ..⟩ |>.ne\n      have hsm : MeasurableSet (toMeasurable μ s) := measurableSet_toMeasurable ..\n      apply ENNReal.le_of_add_le_add_right this\n      rw [← μ.restrict_toMeasurable_of_sFinite, lintegral_add_compl _ hsm, hgint,\n        ← lintegral_add_compl _ hsm]\n      gcongr with x\n      exact le_min (hgf n x) (hgle n x)\n    _ ≤ _ := lintegral_mono fun x ↦ le_iSup (g · x) n\n\n"}
{"name":"MeasureTheory.exists_pos_lintegral_lt_of_sigmaFinite","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\nε : ENNReal\nε0 : Ne ε 0\n⊢ Exists fun g => And (∀ (x : α), LT.lt 0 (g x)) (And (Measurable g) (LT.lt (MeasureTheory.lintegral μ fun x => ↑(g x)) ε))","decl":"/-- In a sigma-finite measure space, there exists an integrable function which is\npositive everywhere (and with an arbitrarily small integral). -/\ntheorem exists_pos_lintegral_lt_of_sigmaFinite (μ : Measure α) [SigmaFinite μ] {ε : ℝ≥0∞}\n    (ε0 : ε ≠ 0) : ∃ g : α → ℝ≥0, (∀ x, 0 < g x) ∧ Measurable g ∧ ∫⁻ x, g x ∂μ < ε := by\n  /- Let `s` be a covering of `α` by pairwise disjoint measurable sets of finite measure. Let\n    `δ : ℕ → ℝ≥0` be a positive function such that `∑' i, μ (s i) * δ i < ε`. Then the function that\n     is equal to `δ n` on `s n` is a positive function with integral less than `ε`. -/\n  set s : ℕ → Set α := disjointed (spanningSets μ)\n  have : ∀ n, μ (s n) < ∞ := fun n =>\n    (measure_mono <| disjointed_subset _ _).trans_lt (measure_spanningSets_lt_top μ n)\n  obtain ⟨δ, δpos, δsum⟩ : ∃ δ : ℕ → ℝ≥0, (∀ i, 0 < δ i) ∧ (∑' i, μ (s i) * δ i) < ε :=\n    ENNReal.exists_pos_tsum_mul_lt_of_countable ε0 _ fun n => (this n).ne\n  set N : α → ℕ := spanningSetsIndex μ\n  have hN_meas : Measurable N := measurableSet_spanningSetsIndex μ\n  have hNs : ∀ n, N ⁻¹' {n} = s n := preimage_spanningSetsIndex_singleton μ\n  refine ⟨δ ∘ N, fun x => δpos _, measurable_from_nat.comp hN_meas, ?_⟩\n  erw [lintegral_comp measurable_from_nat.coe_nnreal_ennreal hN_meas]\n  simpa [N, hNs, lintegral_countable', measurableSet_spanningSetsIndex, mul_comm] using δsum\n\n"}
{"name":"MeasureTheory.lintegral_trim","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nhm : LE.le m m0\nf : α → ENNReal\nhf : Measurable f\n⊢ Eq (MeasureTheory.lintegral (μ.trim hm) fun a => f a) (MeasureTheory.lintegral μ fun a => f a)","decl":"theorem lintegral_trim {μ : Measure α} (hm : m ≤ m0) {f : α → ℝ≥0∞} (hf : Measurable[m] f) :\n    ∫⁻ a, f a ∂μ.trim hm = ∫⁻ a, f a ∂μ := by\n  refine\n    @Measurable.ennreal_induction α m (fun f => ∫⁻ a, f a ∂μ.trim hm = ∫⁻ a, f a ∂μ) ?_ ?_ ?_ f hf\n  · intro c s hs\n    rw [lintegral_indicator hs, lintegral_indicator (hm s hs), setLIntegral_const,\n      setLIntegral_const]\n    suffices h_trim_s : μ.trim hm s = μ s by rw [h_trim_s]\n    exact trim_measurableSet_eq hm hs\n  · intro f g _ hf _ hf_prop hg_prop\n    have h_m := lintegral_add_left (μ := Measure.trim μ hm) hf g\n    have h_m0 := lintegral_add_left (μ := μ) (Measurable.mono hf hm le_rfl) g\n    rwa [hf_prop, hg_prop, ← h_m0] at h_m\n  · intro f hf hf_mono hf_prop\n    rw [lintegral_iSup hf hf_mono]\n    rw [lintegral_iSup (fun n => Measurable.mono (hf n) hm le_rfl) hf_mono]\n    congr with n\n    exact hf_prop n\n\n"}
{"name":"MeasureTheory.lintegral_trim_ae","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nhm : LE.le m m0\nf : α → ENNReal\nhf : AEMeasurable f (μ.trim hm)\n⊢ Eq (MeasureTheory.lintegral (μ.trim hm) fun a => f a) (MeasureTheory.lintegral μ fun a => f a)","decl":"theorem lintegral_trim_ae {μ : Measure α} (hm : m ≤ m0) {f : α → ℝ≥0∞}\n    (hf : AEMeasurable f (μ.trim hm)) : ∫⁻ a, f a ∂μ.trim hm = ∫⁻ a, f a ∂μ := by\n  rw [lintegral_congr_ae (ae_eq_of_ae_eq_trim hf.ae_eq_mk), lintegral_congr_ae hf.ae_eq_mk,\n    lintegral_trim hm hf.measurable_mk]\n\n"}
{"name":"MeasureTheory.univ_le_of_forall_fin_meas_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nhm : LE.le m m0\ninst✝ : MeasureTheory.SigmaFinite (μ.trim hm)\nC : ENNReal\nf : Set α → ENNReal\nhf : ∀ (s : Set α), MeasurableSet s → Ne (μ s) Top.top → LE.le (f s) C\nh_F_lim : ∀ (S : Nat → Set α), (∀ (n : Nat), MeasurableSet (S n)) → Monotone S → LE.le (f (Set.iUnion fun n => S n)) (iSup fun n => f (S n))\n⊢ LE.le (f Set.univ) C","decl":"theorem univ_le_of_forall_fin_meas_le {μ : Measure α} (hm : m ≤ m0) [SigmaFinite (μ.trim hm)]\n    (C : ℝ≥0∞) {f : Set α → ℝ≥0∞} (hf : ∀ s, MeasurableSet[m] s → μ s ≠ ∞ → f s ≤ C)\n    (h_F_lim :\n      ∀ S : ℕ → Set α, (∀ n, MeasurableSet[m] (S n)) → Monotone S → f (⋃ n, S n) ≤ ⨆ n, f (S n)) :\n    f univ ≤ C := by\n  let S := @spanningSets _ m (μ.trim hm) _\n  have hS_mono : Monotone S := @monotone_spanningSets _ m (μ.trim hm) _\n  have hS_meas : ∀ n, MeasurableSet[m] (S n) := @measurableSet_spanningSets _ m (μ.trim hm) _\n  rw [← @iUnion_spanningSets _ m (μ.trim hm)]\n  refine (h_F_lim S hS_meas hS_mono).trans ?_\n  refine iSup_le fun n => hf (S n) (hS_meas n) ?_\n  exact ((le_trim hm).trans_lt (@measure_spanningSets_lt_top _ m (μ.trim hm) _ n)).ne\n\n"}
{"name":"MeasureTheory.lintegral_le_of_forall_fin_meas_trim_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nhm : LE.le m m0\ninst✝ : MeasureTheory.SigmaFinite (μ.trim hm)\nC : ENNReal\nf : α → ENNReal\nhf : ∀ (s : Set α), MeasurableSet s → Ne (μ s) Top.top → LE.le (MeasureTheory.lintegral (μ.restrict s) fun x => f x) C\n⊢ LE.le (MeasureTheory.lintegral μ fun x => f x) C","decl":"/-- If the Lebesgue integral of a function is bounded by some constant on all sets with finite\nmeasure in a sub-σ-algebra and the measure is σ-finite on that sub-σ-algebra, then the integral\nover the whole space is bounded by that same constant. -/\ntheorem lintegral_le_of_forall_fin_meas_trim_le {μ : Measure α} (hm : m ≤ m0)\n    [SigmaFinite (μ.trim hm)] (C : ℝ≥0∞) {f : α → ℝ≥0∞}\n    (hf : ∀ s, MeasurableSet[m] s → μ s ≠ ∞ → ∫⁻ x in s, f x ∂μ ≤ C) : ∫⁻ x, f x ∂μ ≤ C := by\n  have : ∫⁻ x in univ, f x ∂μ = ∫⁻ x, f x ∂μ := by simp only [Measure.restrict_univ]\n  rw [← this]\n  refine univ_le_of_forall_fin_meas_le hm C hf fun S _ hS_mono => ?_\n  rw [setLIntegral_iUnion_of_directed]\n  exact directed_of_isDirected_le hS_mono\n\n"}
{"name":"MeasureTheory.lintegral_le_of_forall_fin_meas_le_of_measurable","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nhm : LE.le m m0\ninst✝ : MeasureTheory.SigmaFinite (μ.trim hm)\nC : ENNReal\nf : α → ENNReal\nhf : ∀ (s : Set α), MeasurableSet s → Ne (μ s) Top.top → LE.le (MeasureTheory.lintegral (μ.restrict s) fun x => f x) C\n⊢ LE.le (MeasureTheory.lintegral μ fun x => f x) C","decl":"alias lintegral_le_of_forall_fin_meas_le_of_measurable := lintegral_le_of_forall_fin_meas_trim_le\n\n"}
{"name":"MeasureTheory.lintegral_le_of_forall_fin_meas_le","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\nC : ENNReal\nf : α → ENNReal\nhf : ∀ (s : Set α), MeasurableSet s → Ne (μ s) Top.top → LE.le (MeasureTheory.lintegral (μ.restrict s) fun x => f x) C\n⊢ LE.le (MeasureTheory.lintegral μ fun x => f x) C","decl":"/-- If the Lebesgue integral of a function is bounded by some constant on all sets with finite\nmeasure and the measure is σ-finite, then the integral over the whole space is bounded by that same\nconstant. -/\ntheorem lintegral_le_of_forall_fin_meas_le [MeasurableSpace α] {μ : Measure α} [SigmaFinite μ]\n    (C : ℝ≥0∞) {f : α → ℝ≥0∞}\n    (hf : ∀ s, MeasurableSet s → μ s ≠ ∞ → ∫⁻ x in s, f x ∂μ ≤ C) : ∫⁻ x, f x ∂μ ≤ C :=\n  have : SigmaFinite (μ.trim le_rfl) := by rwa [trim_eq_self]\n  lintegral_le_of_forall_fin_meas_trim_le _ C hf\n\n"}
{"name":"MeasureTheory.SimpleFunc.exists_lt_lintegral_simpleFunc_of_lt_lintegral","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\nf : MeasureTheory.SimpleFunc α NNReal\nL : ENNReal\nhL : LT.lt L (MeasureTheory.lintegral μ fun x => ↑(f x))\n⊢ Exists fun g => And (∀ (x : α), LE.le (g x) (f x)) (And (LT.lt (MeasureTheory.lintegral μ fun x => ↑(g x)) Top.top) (LT.lt L (MeasureTheory.lintegral μ fun x => ↑(g x))))","decl":"theorem SimpleFunc.exists_lt_lintegral_simpleFunc_of_lt_lintegral {m : MeasurableSpace α}\n    {μ : Measure α} [SigmaFinite μ] {f : α →ₛ ℝ≥0} {L : ℝ≥0∞} (hL : L < ∫⁻ x, f x ∂μ) :\n    ∃ g : α →ₛ ℝ≥0, (∀ x, g x ≤ f x) ∧ ∫⁻ x, g x ∂μ < ∞ ∧ L < ∫⁻ x, g x ∂μ := by\n  induction' f using MeasureTheory.SimpleFunc.induction with c s hs f₁ f₂ _ h₁ h₂ generalizing L\n  · simp only [hs, const_zero, coe_piecewise, coe_const, SimpleFunc.coe_zero, univ_inter,\n      piecewise_eq_indicator, lintegral_indicator, lintegral_const, Measure.restrict_apply',\n      ENNReal.coe_indicator, Function.const_apply] at hL\n    have c_ne_zero : c ≠ 0 := by\n      intro hc\n      simp only [hc, ENNReal.coe_zero, zero_mul, not_lt_zero] at hL\n    have : L / c < μ s := by\n      rwa [ENNReal.div_lt_iff, mul_comm]\n      · simp only [c_ne_zero, Ne, ENNReal.coe_eq_zero, not_false_iff, true_or]\n      · simp only [Ne, coe_ne_top, not_false_iff, true_or]\n    obtain ⟨t, ht, ts, mlt, t_top⟩ :\n      ∃ t : Set α, MeasurableSet t ∧ t ⊆ s ∧ L / ↑c < μ t ∧ μ t < ∞ :=\n      Measure.exists_subset_measure_lt_top hs this\n    refine ⟨piecewise t ht (const α c) (const α 0), fun x => ?_, ?_, ?_⟩\n    · refine indicator_le_indicator_of_subset ts (fun x => ?_) x\n      exact zero_le _\n    · simp only [ht, const_zero, coe_piecewise, coe_const, SimpleFunc.coe_zero, univ_inter,\n        piecewise_eq_indicator, ENNReal.coe_indicator, Function.const_apply, lintegral_indicator,\n        lintegral_const, Measure.restrict_apply', ENNReal.mul_lt_top ENNReal.coe_lt_top t_top]\n    · simp only [ht, const_zero, coe_piecewise, coe_const, SimpleFunc.coe_zero,\n        piecewise_eq_indicator, ENNReal.coe_indicator, Function.const_apply, lintegral_indicator,\n        lintegral_const, Measure.restrict_apply', univ_inter]\n      rwa [mul_comm, ← ENNReal.div_lt_iff]\n      · simp only [c_ne_zero, Ne, ENNReal.coe_eq_zero, not_false_iff, true_or]\n      · simp only [Ne, coe_ne_top, not_false_iff, true_or]\n  · replace hL : L < ∫⁻ x, f₁ x ∂μ + ∫⁻ x, f₂ x ∂μ := by\n      rwa [← lintegral_add_left f₁.measurable.coe_nnreal_ennreal]\n    by_cases hf₁ : ∫⁻ x, f₁ x ∂μ = 0\n    · simp only [hf₁, zero_add] at hL\n      rcases h₂ hL with ⟨g, g_le, g_top, gL⟩\n      refine ⟨g, fun x => (g_le x).trans ?_, g_top, gL⟩\n      simp only [SimpleFunc.coe_add, Pi.add_apply, le_add_iff_nonneg_left, zero_le']\n    by_cases hf₂ : ∫⁻ x, f₂ x ∂μ = 0\n    · simp only [hf₂, add_zero] at hL\n      rcases h₁ hL with ⟨g, g_le, g_top, gL⟩\n      refine ⟨g, fun x => (g_le x).trans ?_, g_top, gL⟩\n      simp only [SimpleFunc.coe_add, Pi.add_apply, le_add_iff_nonneg_right, zero_le']\n    obtain ⟨L₁, hL₁, L₂, hL₂, hL⟩ : ∃ L₁ < ∫⁻ x, f₁ x ∂μ, ∃ L₂ < ∫⁻ x, f₂ x ∂μ, L < L₁ + L₂ :=\n      ENNReal.exists_lt_add_of_lt_add hL hf₁ hf₂\n    rcases h₁ hL₁ with ⟨g₁, g₁_le, g₁_top, hg₁⟩\n    rcases h₂ hL₂ with ⟨g₂, g₂_le, g₂_top, hg₂⟩\n    refine ⟨g₁ + g₂, fun x => add_le_add (g₁_le x) (g₂_le x), ?_, ?_⟩\n    · apply lt_of_le_of_lt _ (add_lt_top.2 ⟨g₁_top, g₂_top⟩)\n      rw [← lintegral_add_left g₁.measurable.coe_nnreal_ennreal]\n      exact le_rfl\n    · apply hL.trans ((ENNReal.add_lt_add hg₁ hg₂).trans_le _)\n      rw [← lintegral_add_left g₁.measurable.coe_nnreal_ennreal]\n      simp only [coe_add, Pi.add_apply, ENNReal.coe_add, le_rfl]\n\n"}
{"name":"MeasureTheory.exists_lt_lintegral_simpleFunc_of_lt_lintegral","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\nf : α → NNReal\nL : ENNReal\nhL : LT.lt L (MeasureTheory.lintegral μ fun x => ↑(f x))\n⊢ Exists fun g => And (∀ (x : α), LE.le (g x) (f x)) (And (LT.lt (MeasureTheory.lintegral μ fun x => ↑(g x)) Top.top) (LT.lt L (MeasureTheory.lintegral μ fun x => ↑(g x))))","decl":"theorem exists_lt_lintegral_simpleFunc_of_lt_lintegral {m : MeasurableSpace α} {μ : Measure α}\n    [SigmaFinite μ] {f : α → ℝ≥0} {L : ℝ≥0∞} (hL : L < ∫⁻ x, f x ∂μ) :\n    ∃ g : α →ₛ ℝ≥0, (∀ x, g x ≤ f x) ∧ ∫⁻ x, g x ∂μ < ∞ ∧ L < ∫⁻ x, g x ∂μ := by\n  simp_rw [lintegral_eq_nnreal, lt_iSup_iff] at hL\n  rcases hL with ⟨g₀, hg₀, g₀L⟩\n  have h'L : L < ∫⁻ x, g₀ x ∂μ := by\n    convert g₀L\n    rw [← SimpleFunc.lintegral_eq_lintegral, coe_map]\n    simp only [Function.comp_apply]\n  rcases SimpleFunc.exists_lt_lintegral_simpleFunc_of_lt_lintegral h'L with ⟨g, hg, gL, gtop⟩\n  exact ⟨g, fun x => (hg x).trans (coe_le_coe.1 (hg₀ x)), gL, gtop⟩\n\n"}
{"name":"MeasureTheory.tendsto_measure_of_ae_tendsto_indicator","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_5\ninst✝¹ : MeasurableSpace α\nA : Set α\nι : Type u_6\nL : Filter ι\ninst✝ : L.IsCountablyGenerated\nAs : ι → Set α\nμ : MeasureTheory.Measure α\nA_mble : MeasurableSet A\nAs_mble : ∀ (i : ι), MeasurableSet (As i)\nB : Set α\nB_mble : MeasurableSet B\nB_finmeas : Ne (μ B) Top.top\nAs_le_B : Filter.Eventually (fun i => HasSubset.Subset (As i) B) L\nh_lim : Filter.Eventually (fun x => Filter.Eventually (fun i => Iff (Membership.mem (As i) x) (Membership.mem A x)) L) (MeasureTheory.ae μ)\n⊢ Filter.Tendsto (fun i => μ (As i)) L (nhds (μ A))","decl":"/-- If the indicators of measurable sets `Aᵢ` tend pointwise almost everywhere to the indicator\nof a measurable set `A` and we eventually have `Aᵢ ⊆ B` for some set `B` of finite measure, then\nthe measures of `Aᵢ` tend to the measure of `A`. -/\nlemma tendsto_measure_of_ae_tendsto_indicator {μ : Measure α} (A_mble : MeasurableSet A)\n    (As_mble : ∀ i, MeasurableSet (As i)) {B : Set α} (B_mble : MeasurableSet B)\n    (B_finmeas : μ B ≠ ∞) (As_le_B : ∀ᶠ i in L, As i ⊆ B)\n    (h_lim : ∀ᵐ x ∂μ, ∀ᶠ i in L, x ∈ As i ↔ x ∈ A) :\n    Tendsto (fun i ↦ μ (As i)) L (𝓝 (μ A)) := by\n  simp_rw [← MeasureTheory.lintegral_indicator_one A_mble,\n           ← MeasureTheory.lintegral_indicator_one (As_mble _)]\n  refine tendsto_lintegral_filter_of_dominated_convergence (B.indicator (1 : α → ℝ≥0∞))\n          (Eventually.of_forall ?_) ?_ ?_ ?_\n  · exact fun i ↦ Measurable.indicator measurable_const (As_mble i)\n  · filter_upwards [As_le_B] with i hi\n    exact Eventually.of_forall (fun x ↦ indicator_le_indicator_of_subset hi (by simp) x)\n  · rwa [← lintegral_indicator_one B_mble] at B_finmeas\n  · simpa only [Pi.one_def, tendsto_indicator_const_apply_iff_eventually] using h_lim\n\n"}
{"name":"MeasureTheory.tendsto_measure_of_ae_tendsto_indicator_of_isFiniteMeasure","module":"Mathlib.MeasureTheory.Integral.Lebesgue","initialProofState":"α : Type u_5\ninst✝² : MeasurableSpace α\nA : Set α\nι : Type u_6\nL : Filter ι\ninst✝¹ : L.IsCountablyGenerated\nAs : ι → Set α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nA_mble : MeasurableSet A\nAs_mble : ∀ (i : ι), MeasurableSet (As i)\nh_lim : Filter.Eventually (fun x => Filter.Eventually (fun i => Iff (Membership.mem (As i) x) (Membership.mem A x)) L) (MeasureTheory.ae μ)\n⊢ Filter.Tendsto (fun i => μ (As i)) L (nhds (μ A))","decl":"/-- If `μ` is a finite measure and the indicators of measurable sets `Aᵢ` tend pointwise\nalmost everywhere to the indicator of a measurable set `A`, then the measures `μ Aᵢ` tend to\nthe measure `μ A`. -/\nlemma tendsto_measure_of_ae_tendsto_indicator_of_isFiniteMeasure\n    {μ : Measure α} [IsFiniteMeasure μ] (A_mble : MeasurableSet A)\n    (As_mble : ∀ i, MeasurableSet (As i)) (h_lim : ∀ᵐ x ∂μ, ∀ᶠ i in L, x ∈ As i ↔ x ∈ A) :\n    Tendsto (fun i ↦ μ (As i)) L (𝓝 (μ A)) :=\n  tendsto_measure_of_ae_tendsto_indicator L A_mble As_mble MeasurableSet.univ\n    (measure_ne_top μ univ) (Eventually.of_forall (fun i ↦ subset_univ (As i))) h_lim\n\n"}
