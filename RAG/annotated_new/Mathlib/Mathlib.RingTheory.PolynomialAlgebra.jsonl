{"name":"PolyEquivTensor.toFunBilinear_apply_apply","module":"Mathlib.RingTheory.PolynomialAlgebra","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nb : A\na : Polynomial R\n⊢ Eq (((PolyEquivTensor.toFunBilinear R A) b) a) (HSMul.hSMul b ((Polynomial.aeval Polynomial.X) a))","decl":"/-- (Implementation detail).\nThe function underlying `A ⊗[R] R[X] →ₐ[R] A[X]`,\nas a bilinear function of two arguments.\n-/\n@[simps! apply_apply]\ndef toFunBilinear : A →ₗ[A] R[X] →ₗ[R] A[X] :=\n  LinearMap.toSpanSingleton A _ (aeval (Polynomial.X : A[X])).toLinearMap\n\n"}
{"name":"PolyEquivTensor.toFunBilinear_apply_eq_sum","module":"Mathlib.RingTheory.PolynomialAlgebra","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\na : A\np : Polynomial R\n⊢ Eq (((PolyEquivTensor.toFunBilinear R A) a) p) (p.sum fun n r => (Polynomial.monomial n) (HMul.hMul a ((algebraMap R A) r)))","decl":"theorem toFunBilinear_apply_eq_sum (a : A) (p : R[X]) :\n    toFunBilinear R A a p = p.sum fun n r => monomial n (a * algebraMap R A r) := by\n  simp only [toFunBilinear_apply_apply, aeval_def, eval₂_eq_sum, Polynomial.sum, Finset.smul_sum]\n  congr with i : 1\n  rw [← Algebra.smul_def, ← C_mul', mul_smul_comm, C_mul_X_pow_eq_monomial, ← Algebra.commutes,\n    ← Algebra.smul_def, smul_monomial]\n\n"}
{"name":"PolyEquivTensor.toFunLinear_tmul_apply","module":"Mathlib.RingTheory.PolynomialAlgebra","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\na : A\np : Polynomial R\n⊢ Eq ((PolyEquivTensor.toFunLinear R A) (TensorProduct.tmul R a p)) (((PolyEquivTensor.toFunBilinear R A) a) p)","decl":"@[simp]\ntheorem toFunLinear_tmul_apply (a : A) (p : R[X]) :\n    toFunLinear R A (a ⊗ₜ[R] p) = toFunBilinear R A a p :=\n  rfl\n\n-- We apparently need to provide the decidable instance here\n-- in order to successfully rewrite by this lemma.\n"}
{"name":"PolyEquivTensor.toFunLinear_mul_tmul_mul_aux_1","module":"Mathlib.RingTheory.PolynomialAlgebra","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\np : Polynomial R\nk : Nat\nh : Decidable (Not (Eq (p.coeff k) 0))\na : A\n⊢ Eq (ite (Not (Eq (p.coeff k) 0)) (HMul.hMul a ((algebraMap R A) (p.coeff k))) 0) (HMul.hMul a ((algebraMap R A) (p.coeff k)))","decl":"theorem toFunLinear_mul_tmul_mul_aux_1 (p : R[X]) (k : ℕ) (h : Decidable ¬p.coeff k = 0) (a : A) :\n    ite (¬coeff p k = 0) (a * (algebraMap R A) (coeff p k)) 0 =\n    a * (algebraMap R A) (coeff p k) := by classical split_ifs <;> simp [*]\n\n"}
{"name":"PolyEquivTensor.toFunLinear_mul_tmul_mul_aux_2","module":"Mathlib.RingTheory.PolynomialAlgebra","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nk : Nat\na₁ a₂ : A\np₁ p₂ : Polynomial R\n⊢ Eq (HMul.hMul (HMul.hMul a₁ a₂) ((algebraMap R A) ((HMul.hMul p₁ p₂).coeff k))) ((Finset.HasAntidiagonal.antidiagonal k).sum fun x => HMul.hMul (HMul.hMul a₁ ((algebraMap R A) (p₁.coeff x.1))) (HMul.hMul a₂ ((algebraMap R A) (p₂.coeff x.2))))","decl":"theorem toFunLinear_mul_tmul_mul_aux_2 (k : ℕ) (a₁ a₂ : A) (p₁ p₂ : R[X]) :\n    a₁ * a₂ * (algebraMap R A) ((p₁ * p₂).coeff k) =\n      (Finset.antidiagonal k).sum fun x =>\n        a₁ * (algebraMap R A) (coeff p₁ x.1) * (a₂ * (algebraMap R A) (coeff p₂ x.2)) := by\n  simp_rw [mul_assoc, Algebra.commutes, ← Finset.mul_sum, mul_assoc, ← Finset.mul_sum]\n  congr\n  simp_rw [Algebra.commutes (coeff p₂ _), coeff_mul, map_sum, RingHom.map_mul]\n\n"}
{"name":"PolyEquivTensor.toFunLinear_mul_tmul_mul","module":"Mathlib.RingTheory.PolynomialAlgebra","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\na₁ a₂ : A\np₁ p₂ : Polynomial R\n⊢ Eq ((PolyEquivTensor.toFunLinear R A) (TensorProduct.tmul R (HMul.hMul a₁ a₂) (HMul.hMul p₁ p₂))) (HMul.hMul ((PolyEquivTensor.toFunLinear R A) (TensorProduct.tmul R a₁ p₁)) ((PolyEquivTensor.toFunLinear R A) (TensorProduct.tmul R a₂ p₂)))","decl":"theorem toFunLinear_mul_tmul_mul (a₁ a₂ : A) (p₁ p₂ : R[X]) :\n    (toFunLinear R A) ((a₁ * a₂) ⊗ₜ[R] (p₁ * p₂)) =\n      (toFunLinear R A) (a₁ ⊗ₜ[R] p₁) * (toFunLinear R A) (a₂ ⊗ₜ[R] p₂) := by\n  classical\n    simp only [toFunLinear_tmul_apply, toFunBilinear_apply_eq_sum]\n    ext k\n    simp_rw [coeff_sum, coeff_monomial, sum_def, Finset.sum_ite_eq', mem_support_iff, Ne]\n    conv_rhs => rw [coeff_mul]\n    simp_rw [finset_sum_coeff, coeff_monomial, Finset.sum_ite_eq', mem_support_iff, Ne, mul_ite,\n      mul_zero, ite_mul, zero_mul]\n    simp_rw [← ite_zero_mul (¬coeff p₁ _ = 0) (a₁ * (algebraMap R A) (coeff p₁ _))]\n    simp_rw [← mul_ite_zero (¬coeff p₂ _ = 0) _ (_ * _)]\n    simp_rw [toFunLinear_mul_tmul_mul_aux_1, toFunLinear_mul_tmul_mul_aux_2]\n\n"}
{"name":"PolyEquivTensor.toFunLinear_one_tmul_one","module":"Mathlib.RingTheory.PolynomialAlgebra","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\n⊢ Eq ((PolyEquivTensor.toFunLinear R A) (TensorProduct.tmul R 1 1)) 1","decl":"theorem toFunLinear_one_tmul_one :\n    toFunLinear R A (1 ⊗ₜ[R] 1) = 1 := by\n  rw [toFunLinear_tmul_apply, toFunBilinear_apply_apply, Polynomial.aeval_one, one_smul]\n\n"}
{"name":"PolyEquivTensor.toFunAlgHom_apply_tmul","module":"Mathlib.RingTheory.PolynomialAlgebra","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\na : A\np : Polynomial R\n⊢ Eq ((PolyEquivTensor.toFunAlgHom R A) (TensorProduct.tmul R a p)) (p.sum fun n r => (Polynomial.monomial n) (HMul.hMul a ((algebraMap R A) r)))","decl":"@[simp]\ntheorem toFunAlgHom_apply_tmul (a : A) (p : R[X]) :\n    toFunAlgHom R A (a ⊗ₜ[R] p) = p.sum fun n r => monomial n (a * (algebraMap R A) r) :=\n  toFunBilinear_apply_eq_sum R A _ _\n\n"}
{"name":"PolyEquivTensor.invFun_add","module":"Mathlib.RingTheory.PolynomialAlgebra","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\np q : Polynomial A\n⊢ Eq (PolyEquivTensor.invFun R A (HAdd.hAdd p q)) (HAdd.hAdd (PolyEquivTensor.invFun R A p) (PolyEquivTensor.invFun R A q))","decl":"@[simp]\ntheorem invFun_add {p q} : invFun R A (p + q) = invFun R A p + invFun R A q := by\n  simp only [invFun, eval₂_add]\n\n"}
{"name":"PolyEquivTensor.invFun_monomial","module":"Mathlib.RingTheory.PolynomialAlgebra","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nn : Nat\na : A\n⊢ Eq (PolyEquivTensor.invFun R A ((Polynomial.monomial n) a)) (HMul.hMul (TensorProduct.tmul R a 1) (HPow.hPow (TensorProduct.tmul R 1 Polynomial.X) n))","decl":"theorem invFun_monomial (n : ℕ) (a : A) :\n    invFun R A (monomial n a) = (a ⊗ₜ[R] 1) * 1 ⊗ₜ[R] X ^ n :=\n  eval₂_monomial _ _\n\n"}
{"name":"PolyEquivTensor.left_inv","module":"Mathlib.RingTheory.PolynomialAlgebra","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nx : TensorProduct R A (Polynomial R)\n⊢ Eq (PolyEquivTensor.invFun R A ((PolyEquivTensor.toFunAlgHom R A) x)) x","decl":"theorem left_inv (x : A ⊗ R[X]) : invFun R A ((toFunAlgHom R A) x) = x := by\n  refine TensorProduct.induction_on x ?_ ?_ ?_\n  · simp [invFun]\n  · intro a p\n    dsimp only [invFun]\n    rw [toFunAlgHom_apply_tmul, eval₂_sum]\n    simp_rw [eval₂_monomial, AlgHom.coe_toRingHom, Algebra.TensorProduct.tmul_pow, one_pow,\n      Algebra.TensorProduct.includeLeft_apply, Algebra.TensorProduct.tmul_mul_tmul, mul_one,\n      one_mul, ← Algebra.commutes, ← Algebra.smul_def, smul_tmul, sum_def, ← tmul_sum]\n    conv_rhs => rw [← sum_C_mul_X_pow_eq p]\n    simp only [Algebra.smul_def]\n    rfl\n  · intro p q hp hq\n    simp only [map_add, invFun_add, hp, hq]\n\n"}
{"name":"PolyEquivTensor.right_inv","module":"Mathlib.RingTheory.PolynomialAlgebra","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nx : Polynomial A\n⊢ Eq ((PolyEquivTensor.toFunAlgHom R A) (PolyEquivTensor.invFun R A x)) x","decl":"theorem right_inv (x : A[X]) : (toFunAlgHom R A) (invFun R A x) = x := by\n  refine Polynomial.induction_on' x ?_ ?_\n  · intro p q hp hq\n    simp only [invFun_add, map_add, hp, hq]\n  · intro n a\n    rw [invFun_monomial, Algebra.TensorProduct.tmul_pow,\n        one_pow, Algebra.TensorProduct.tmul_mul_tmul, mul_one, one_mul, toFunAlgHom_apply_tmul,\n        X_pow_eq_monomial, sum_monomial_index] <;>\n      simp\n\n"}
{"name":"polyEquivTensor_apply","module":"Mathlib.RingTheory.PolynomialAlgebra","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\np : Polynomial A\n⊢ Eq ((polyEquivTensor R A) p) (Polynomial.eval₂ (↑Algebra.TensorProduct.includeLeft) (TensorProduct.tmul R 1 Polynomial.X) p)","decl":"@[simp]\ntheorem polyEquivTensor_apply (p : A[X]) :\n    polyEquivTensor R A p =\n      p.eval₂ (includeLeft : A →ₐ[R] A ⊗[R] R[X]) ((1 : A) ⊗ₜ[R] (X : R[X])) :=\n  rfl\n\n"}
{"name":"polyEquivTensor_symm_apply_tmul","module":"Mathlib.RingTheory.PolynomialAlgebra","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\na : A\np : Polynomial R\n⊢ Eq ((polyEquivTensor R A).symm (TensorProduct.tmul R a p)) (p.sum fun n r => (Polynomial.monomial n) (HMul.hMul a ((algebraMap R A) r)))","decl":"@[simp]\ntheorem polyEquivTensor_symm_apply_tmul (a : A) (p : R[X]) :\n    (polyEquivTensor R A).symm (a ⊗ₜ p) = p.sum fun n r => monomial n (a * algebraMap R A r) :=\n  toFunAlgHom_apply_tmul _ _ _ _\n\n"}
{"name":"coe_polyEquivTensor'","module":"Mathlib.RingTheory.PolynomialAlgebra","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nA : Type u_3\ninst✝¹ : CommSemiring A\ninst✝ : Algebra R A\n⊢ Eq ⇑(polyEquivTensor' R A) ⇑(polyEquivTensor R A)","decl":"/-- `polyEquivTensor' R A` is the same as `polyEquivTensor R A` as a function. -/\n@[simp] theorem coe_polyEquivTensor' : ⇑(polyEquivTensor' R A) = polyEquivTensor R A := rfl\n\n"}
{"name":"coe_polyEquivTensor'_symm","module":"Mathlib.RingTheory.PolynomialAlgebra","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nA : Type u_3\ninst✝¹ : CommSemiring A\ninst✝ : Algebra R A\n⊢ Eq ⇑(polyEquivTensor' R A).symm ⇑(polyEquivTensor R A).symm","decl":"@[simp] theorem coe_polyEquivTensor'_symm :\n    ⇑(polyEquivTensor' R A).symm = (polyEquivTensor R A).symm := rfl\n\n"}
{"name":"matPolyEquiv_symm_C","module":"Mathlib.RingTheory.PolynomialAlgebra","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nn : Type w\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n R\n⊢ Eq (matPolyEquiv.symm (Polynomial.C M)) (M.map ⇑Polynomial.C)","decl":"@[simp] theorem matPolyEquiv_symm_C (M : Matrix n n R) : matPolyEquiv.symm (C M) = M.map C := by\n  simp [matPolyEquiv, ← C_eq_algebraMap]\n\n"}
{"name":"matPolyEquiv_map_C","module":"Mathlib.RingTheory.PolynomialAlgebra","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nn : Type w\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n R\n⊢ Eq (matPolyEquiv (M.map ⇑Polynomial.C)) (Polynomial.C M)","decl":"@[simp] theorem matPolyEquiv_map_C (M : Matrix n n R) : matPolyEquiv (M.map C) = C M := by\n  rw [← matPolyEquiv_symm_C, AlgEquiv.apply_symm_apply]\n\n"}
{"name":"matPolyEquiv_symm_X","module":"Mathlib.RingTheory.PolynomialAlgebra","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nn : Type w\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\n⊢ Eq (matPolyEquiv.symm Polynomial.X) (Matrix.diagonal fun x => Polynomial.X)","decl":"@[simp] theorem matPolyEquiv_symm_X :\n    matPolyEquiv.symm X = diagonal fun _ : n => (X : R[X]) := by\n  suffices (Matrix.map 1 fun x ↦ X * algebraMap R R[X] x) = diagonal fun _ : n => (X : R[X]) by\n    simpa [matPolyEquiv]\n  rw [← Matrix.diagonal_one]\n  simp [-Matrix.diagonal_one]\n\n"}
{"name":"matPolyEquiv_diagonal_X","module":"Mathlib.RingTheory.PolynomialAlgebra","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nn : Type w\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\n⊢ Eq (matPolyEquiv (Matrix.diagonal fun x => Polynomial.X)) Polynomial.X","decl":"@[simp] theorem matPolyEquiv_diagonal_X :\n    matPolyEquiv (diagonal fun _ : n => (X : R[X])) = X := by\n  rw [← matPolyEquiv_symm_X, AlgEquiv.apply_symm_apply]\n\n"}
{"name":"matPolyEquiv_coeff_apply_aux_1","module":"Mathlib.RingTheory.PolynomialAlgebra","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nn : Type w\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\ni j : n\nk : Nat\nx : R\n⊢ Eq (matPolyEquiv (Matrix.stdBasisMatrix i j ((Polynomial.monomial k) x))) ((Polynomial.monomial k) (Matrix.stdBasisMatrix i j x))","decl":"unseal Algebra.TensorProduct.mul in\ntheorem matPolyEquiv_coeff_apply_aux_1 (i j : n) (k : ℕ) (x : R) :\n    matPolyEquiv (stdBasisMatrix i j <| monomial k x) = monomial k (stdBasisMatrix i j x) := by\n  simp only [matPolyEquiv, AlgEquiv.trans_apply, matrixEquivTensor_apply_stdBasisMatrix]\n  apply (polyEquivTensor R (Matrix n n R)).injective\n  simp only [AlgEquiv.apply_symm_apply,Algebra.TensorProduct.comm_tmul,\n    polyEquivTensor_apply, eval₂_monomial]\n  simp only [Algebra.TensorProduct.tmul_mul_tmul, one_pow, one_mul, Matrix.mul_one,\n    Algebra.TensorProduct.tmul_pow, Algebra.TensorProduct.includeLeft_apply]\n  rw [← smul_X_eq_monomial, ← TensorProduct.smul_tmul]\n  congr with i' <;> simp [stdBasisMatrix]\n\n"}
{"name":"matPolyEquiv_coeff_apply_aux_2","module":"Mathlib.RingTheory.PolynomialAlgebra","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nn : Type w\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\ni j : n\np : Polynomial R\nk : Nat\n⊢ Eq ((matPolyEquiv (Matrix.stdBasisMatrix i j p)).coeff k) (Matrix.stdBasisMatrix i j (p.coeff k))","decl":"theorem matPolyEquiv_coeff_apply_aux_2 (i j : n) (p : R[X]) (k : ℕ) :\n    coeff (matPolyEquiv (stdBasisMatrix i j p)) k = stdBasisMatrix i j (coeff p k) := by\n  refine Polynomial.induction_on' p ?_ ?_\n  · intro p q hp hq\n    ext\n    simp [hp, hq, coeff_add, DMatrix.add_apply, stdBasisMatrix_add]\n  · intro k x\n    simp only [matPolyEquiv_coeff_apply_aux_1, coeff_monomial]\n    split_ifs <;>\n      · funext\n        simp\n\n"}
{"name":"matPolyEquiv_coeff_apply","module":"Mathlib.RingTheory.PolynomialAlgebra","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nn : Type w\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nm : Matrix n n (Polynomial R)\nk : Nat\ni j : n\n⊢ Eq ((matPolyEquiv m).coeff k i j) ((m i j).coeff k)","decl":"@[simp]\ntheorem matPolyEquiv_coeff_apply (m : Matrix n n R[X]) (k : ℕ) (i j : n) :\n    coeff (matPolyEquiv m) k i j = coeff (m i j) k := by\n  refine Matrix.induction_on' m ?_ ?_ ?_\n  · simp\n  · intro p q hp hq\n    simp [hp, hq]\n  · intro i' j' x\n    rw [matPolyEquiv_coeff_apply_aux_2]\n    dsimp [stdBasisMatrix]\n    split_ifs <;> rename_i h\n    · rcases h with ⟨rfl, rfl⟩\n      simp [stdBasisMatrix]\n    · simp [stdBasisMatrix, h]\n\n"}
{"name":"matPolyEquiv_symm_apply_coeff","module":"Mathlib.RingTheory.PolynomialAlgebra","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nn : Type w\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\np : Polynomial (Matrix n n R)\ni j : n\nk : Nat\n⊢ Eq ((matPolyEquiv.symm p i j).coeff k) (p.coeff k i j)","decl":"@[simp]\ntheorem matPolyEquiv_symm_apply_coeff (p : (Matrix n n R)[X]) (i j : n) (k : ℕ) :\n    coeff (matPolyEquiv.symm p i j) k = coeff p k i j := by\n  have t : p = matPolyEquiv (matPolyEquiv.symm p) := by simp\n  conv_rhs => rw [t]\n  simp only [matPolyEquiv_coeff_apply]\n\n"}
{"name":"matPolyEquiv_smul_one","module":"Mathlib.RingTheory.PolynomialAlgebra","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nn : Type w\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\np : Polynomial R\n⊢ Eq (matPolyEquiv (HSMul.hSMul p 1)) (Polynomial.map (algebraMap R (Matrix n n R)) p)","decl":"theorem matPolyEquiv_smul_one (p : R[X]) :\n    matPolyEquiv (p • (1 : Matrix n n R[X])) = p.map (algebraMap R (Matrix n n R)) := by\n  ext m i j\n  simp only [matPolyEquiv_coeff_apply, smul_apply, one_apply, smul_eq_mul, mul_ite, mul_one,\n    mul_zero, coeff_map, algebraMap_matrix_apply, Algebra.id.map_eq_id, RingHom.id_apply]\n  split_ifs <;> simp\n\n"}
{"name":"matPolyEquiv_map_smul","module":"Mathlib.RingTheory.PolynomialAlgebra","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nn : Type w\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\np : Polynomial R\nM : Matrix n n (Polynomial R)\n⊢ Eq (matPolyEquiv (HSMul.hSMul p M)) (HMul.hMul (Polynomial.map (algebraMap R (Matrix n n R)) p) (matPolyEquiv M))","decl":"@[simp]\nlemma matPolyEquiv_map_smul (p : R[X]) (M : Matrix n n R[X]) :\n    matPolyEquiv (p • M) = p.map (algebraMap _ _) * matPolyEquiv M := by\n  rw [← one_mul M, ← smul_mul_assoc, _root_.map_mul, matPolyEquiv_smul_one, one_mul]\n\n"}
{"name":"support_subset_support_matPolyEquiv","module":"Mathlib.RingTheory.PolynomialAlgebra","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nn : Type w\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nm : Matrix n n (Polynomial R)\ni j : n\n⊢ HasSubset.Subset (m i j).support (matPolyEquiv m).support","decl":"theorem support_subset_support_matPolyEquiv (m : Matrix n n R[X]) (i j : n) :\n    support (m i j) ⊆ support (matPolyEquiv m) := by\n  intro k\n  contrapose\n  simp only [not_mem_support_iff]\n  intro hk\n  rw [← matPolyEquiv_coeff_apply, hk]\n  rfl\n\n"}
{"name":"evalRingHom_mapMatrix_comp_polyToMatrix","module":"Mathlib.RingTheory.PolynomialAlgebra","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nn : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nS : Type u_3\ninst✝ : CommSemiring S\nf : RingHom S (Matrix n n R)\n⊢ Eq ((Polynomial.evalRingHom 0).mapMatrix.comp f.polyToMatrix) (f.comp (Polynomial.evalRingHom 0))","decl":"lemma evalRingHom_mapMatrix_comp_polyToMatrix :\n    (evalRingHom 0).mapMatrix.comp f.polyToMatrix = f.comp (evalRingHom 0) := by\n  ext <;> simp [RingHom.polyToMatrix, ← AlgEquiv.symm_toRingEquiv, diagonal, apply_ite]\n\n"}
{"name":"evalRingHom_mapMatrix_comp_compRingEquiv","module":"Mathlib.RingTheory.PolynomialAlgebra","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nn : Type w\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\nm : Type u_4\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\n⊢ Eq ((Polynomial.evalRingHom 0).mapMatrix.comp ↑(Matrix.compRingEquiv m n (Polynomial R))) ((Matrix.compRingEquiv m n R).toRingHom.comp (Polynomial.evalRingHom 0).mapMatrix.mapMatrix)","decl":"lemma evalRingHom_mapMatrix_comp_compRingEquiv {m} [Fintype m] [DecidableEq m] :\n    (evalRingHom 0).mapMatrix.comp (compRingEquiv m n R[X]) =\n      (compRingEquiv m n R).toRingHom.comp (evalRingHom 0).mapMatrix.mapMatrix := by\n  ext; simp\n"}
