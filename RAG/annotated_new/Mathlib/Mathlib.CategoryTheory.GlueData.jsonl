{"name":"CategoryTheory.GlueData.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v, u₁} C\ninst✝ : SizeOf C\nJ : Type v\nU : J → C\nV : Prod J J → C\nf : (i j : J) → Quiver.Hom (V { fst := i, snd := j }) (U i)\nf_mono : autoParam (∀ (i j : J), CategoryTheory.Mono (f i j)) _auto✝\nf_hasPullback : autoParam (∀ (i j k : J), CategoryTheory.Limits.HasPullback (f i j) (f i k)) _auto✝\nf_id : autoParam (∀ (i : J), CategoryTheory.IsIso (f i i)) _auto✝\nt : (i j : J) → Quiver.Hom (V { fst := i, snd := j }) (V { fst := j, snd := i })\nt_id : ∀ (i : J), Eq (t i i) (CategoryTheory.CategoryStruct.id (V { fst := i, snd := i }))\nt' : (i j k : J) → Quiver.Hom (CategoryTheory.Limits.pullback (f i j) (f i k)) (CategoryTheory.Limits.pullback (f j k) (f j i))\nt_fac : ∀ (i j k : J), Eq (CategoryTheory.CategoryStruct.comp (t' i j k) (CategoryTheory.Limits.pullback.snd (f j k) (f j i))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (f i j) (f i k)) (t i j))\ncocycle : ∀ (i j k : J), Eq (CategoryTheory.CategoryStruct.comp (t' i j k) (CategoryTheory.CategoryStruct.comp (t' j k i) (t' k i j))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback (f i j) (f i k)))\n⊢ Eq (SizeOf.sizeOf { J := J, U := U, V := V, f := f, f_mono := f_mono, f_hasPullback := f_hasPullback, f_id := f_id, t := t, t_id := t_id, t' := t', t_fac := t_fac, cocycle := cocycle }) (HAdd.hAdd 1 (SizeOf.sizeOf J))","decl":"/-- A gluing datum consists of\n1. An index type `J`\n2. An object `U i` for each `i : J`.\n3. An object `V i j` for each `i j : J`.\n4. A monomorphism `f i j : V i j ⟶ U i` for each `i j : J`.\n5. A transition map `t i j : V i j ⟶ V j i` for each `i j : J`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. The pullback for `f i j` and `f i k` exists.\n9. `V i j ×[U i] V i k ⟶ V i j ⟶ V j i` factors through `V j k ×[U j] V j i ⟶ V j i` via some\n    `t' : V i j ×[U i] V i k ⟶ V j k ×[U j] V j i`.\n10. `t' i j k ≫ t' j k i ≫ t' k i j = 𝟙 _`.\n-/\nstructure GlueData where\n  J : Type v\n  U : J → C\n  V : J × J → C\n  f : ∀ i j, V (i, j) ⟶ U i\n  f_mono : ∀ i j, Mono (f i j) := by infer_instance\n  f_hasPullback : ∀ i j k, HasPullback (f i j) (f i k) := by infer_instance\n  f_id : ∀ i, IsIso (f i i) := by infer_instance\n  t : ∀ i j, V (i, j) ⟶ V (j, i)\n  t_id : ∀ i, t i i = 𝟙 _\n  t' : ∀ i j k, pullback (f i j) (f i k) ⟶ pullback (f j k) (f j i)\n  t_fac : ∀ i j k, t' i j k ≫ pullback.snd _ _ = pullback.fst _ _ ≫ t i j\n  cocycle : ∀ i j k, t' i j k ≫ t' j k i ≫ t' k i j = 𝟙 _\n\n"}
{"name":"CategoryTheory.GlueData.f_mono","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nself : CategoryTheory.GlueData C\ni j : self.J\n⊢ CategoryTheory.Mono (self.f i j)","decl":"/-- A gluing datum consists of\n1. An index type `J`\n2. An object `U i` for each `i : J`.\n3. An object `V i j` for each `i j : J`.\n4. A monomorphism `f i j : V i j ⟶ U i` for each `i j : J`.\n5. A transition map `t i j : V i j ⟶ V j i` for each `i j : J`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. The pullback for `f i j` and `f i k` exists.\n9. `V i j ×[U i] V i k ⟶ V i j ⟶ V j i` factors through `V j k ×[U j] V j i ⟶ V j i` via some\n    `t' : V i j ×[U i] V i k ⟶ V j k ×[U j] V j i`.\n10. `t' i j k ≫ t' j k i ≫ t' k i j = 𝟙 _`.\n-/\nstructure GlueData where\n  J : Type v\n  U : J → C\n  V : J × J → C\n  f : ∀ i j, V (i, j) ⟶ U i\n  f_mono : ∀ i j, Mono (f i j) := by infer_instance\n  f_hasPullback : ∀ i j k, HasPullback (f i j) (f i k) := by infer_instance\n  f_id : ∀ i, IsIso (f i i) := by infer_instance\n  t : ∀ i j, V (i, j) ⟶ V (j, i)\n  t_id : ∀ i, t i i = 𝟙 _\n  t' : ∀ i j k, pullback (f i j) (f i k) ⟶ pullback (f j k) (f j i)\n  t_fac : ∀ i j k, t' i j k ≫ pullback.snd _ _ = pullback.fst _ _ ≫ t i j\n  cocycle : ∀ i j k, t' i j k ≫ t' j k i ≫ t' k i j = 𝟙 _\n\n"}
{"name":"CategoryTheory.GlueData.f_hasPullback","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nself : CategoryTheory.GlueData C\ni j k : self.J\n⊢ CategoryTheory.Limits.HasPullback (self.f i j) (self.f i k)","decl":"/-- A gluing datum consists of\n1. An index type `J`\n2. An object `U i` for each `i : J`.\n3. An object `V i j` for each `i j : J`.\n4. A monomorphism `f i j : V i j ⟶ U i` for each `i j : J`.\n5. A transition map `t i j : V i j ⟶ V j i` for each `i j : J`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. The pullback for `f i j` and `f i k` exists.\n9. `V i j ×[U i] V i k ⟶ V i j ⟶ V j i` factors through `V j k ×[U j] V j i ⟶ V j i` via some\n    `t' : V i j ×[U i] V i k ⟶ V j k ×[U j] V j i`.\n10. `t' i j k ≫ t' j k i ≫ t' k i j = 𝟙 _`.\n-/\nstructure GlueData where\n  J : Type v\n  U : J → C\n  V : J × J → C\n  f : ∀ i j, V (i, j) ⟶ U i\n  f_mono : ∀ i j, Mono (f i j) := by infer_instance\n  f_hasPullback : ∀ i j k, HasPullback (f i j) (f i k) := by infer_instance\n  f_id : ∀ i, IsIso (f i i) := by infer_instance\n  t : ∀ i j, V (i, j) ⟶ V (j, i)\n  t_id : ∀ i, t i i = 𝟙 _\n  t' : ∀ i j k, pullback (f i j) (f i k) ⟶ pullback (f j k) (f j i)\n  t_fac : ∀ i j k, t' i j k ≫ pullback.snd _ _ = pullback.fst _ _ ≫ t i j\n  cocycle : ∀ i j k, t' i j k ≫ t' j k i ≫ t' k i j = 𝟙 _\n\n"}
{"name":"CategoryTheory.GlueData.f_id","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nself : CategoryTheory.GlueData C\ni : self.J\n⊢ CategoryTheory.IsIso (self.f i i)","decl":"/-- A gluing datum consists of\n1. An index type `J`\n2. An object `U i` for each `i : J`.\n3. An object `V i j` for each `i j : J`.\n4. A monomorphism `f i j : V i j ⟶ U i` for each `i j : J`.\n5. A transition map `t i j : V i j ⟶ V j i` for each `i j : J`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. The pullback for `f i j` and `f i k` exists.\n9. `V i j ×[U i] V i k ⟶ V i j ⟶ V j i` factors through `V j k ×[U j] V j i ⟶ V j i` via some\n    `t' : V i j ×[U i] V i k ⟶ V j k ×[U j] V j i`.\n10. `t' i j k ≫ t' j k i ≫ t' k i j = 𝟙 _`.\n-/\nstructure GlueData where\n  J : Type v\n  U : J → C\n  V : J × J → C\n  f : ∀ i j, V (i, j) ⟶ U i\n  f_mono : ∀ i j, Mono (f i j) := by infer_instance\n  f_hasPullback : ∀ i j k, HasPullback (f i j) (f i k) := by infer_instance\n  f_id : ∀ i, IsIso (f i i) := by infer_instance\n  t : ∀ i j, V (i, j) ⟶ V (j, i)\n  t_id : ∀ i, t i i = 𝟙 _\n  t' : ∀ i j k, pullback (f i j) (f i k) ⟶ pullback (f j k) (f j i)\n  t_fac : ∀ i j k, t' i j k ≫ pullback.snd _ _ = pullback.fst _ _ ≫ t i j\n  cocycle : ∀ i j k, t' i j k ≫ t' j k i ≫ t' k i j = 𝟙 _\n\n"}
{"name":"CategoryTheory.GlueData.cocycle","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nself : CategoryTheory.GlueData C\ni j k : self.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.t' i j k) (CategoryTheory.CategoryStruct.comp (self.t' j k i) (self.t' k i j))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback (self.f i j) (self.f i k)))","decl":"/-- A gluing datum consists of\n1. An index type `J`\n2. An object `U i` for each `i : J`.\n3. An object `V i j` for each `i j : J`.\n4. A monomorphism `f i j : V i j ⟶ U i` for each `i j : J`.\n5. A transition map `t i j : V i j ⟶ V j i` for each `i j : J`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. The pullback for `f i j` and `f i k` exists.\n9. `V i j ×[U i] V i k ⟶ V i j ⟶ V j i` factors through `V j k ×[U j] V j i ⟶ V j i` via some\n    `t' : V i j ×[U i] V i k ⟶ V j k ×[U j] V j i`.\n10. `t' i j k ≫ t' j k i ≫ t' k i j = 𝟙 _`.\n-/\nstructure GlueData where\n  J : Type v\n  U : J → C\n  V : J × J → C\n  f : ∀ i j, V (i, j) ⟶ U i\n  f_mono : ∀ i j, Mono (f i j) := by infer_instance\n  f_hasPullback : ∀ i j k, HasPullback (f i j) (f i k) := by infer_instance\n  f_id : ∀ i, IsIso (f i i) := by infer_instance\n  t : ∀ i j, V (i, j) ⟶ V (j, i)\n  t_id : ∀ i, t i i = 𝟙 _\n  t' : ∀ i j k, pullback (f i j) (f i k) ⟶ pullback (f j k) (f j i)\n  t_fac : ∀ i j k, t' i j k ≫ pullback.snd _ _ = pullback.fst _ _ ≫ t i j\n  cocycle : ∀ i j k, t' i j k ≫ t' j k i ≫ t' k i j = 𝟙 _\n\n"}
{"name":"CategoryTheory.GlueData.t_fac","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nself : CategoryTheory.GlueData C\ni j k : self.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.t' i j k) (CategoryTheory.Limits.pullback.snd (self.f j k) (self.f j i))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (self.f i j) (self.f i k)) (self.t i j))","decl":"/-- A gluing datum consists of\n1. An index type `J`\n2. An object `U i` for each `i : J`.\n3. An object `V i j` for each `i j : J`.\n4. A monomorphism `f i j : V i j ⟶ U i` for each `i j : J`.\n5. A transition map `t i j : V i j ⟶ V j i` for each `i j : J`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. The pullback for `f i j` and `f i k` exists.\n9. `V i j ×[U i] V i k ⟶ V i j ⟶ V j i` factors through `V j k ×[U j] V j i ⟶ V j i` via some\n    `t' : V i j ×[U i] V i k ⟶ V j k ×[U j] V j i`.\n10. `t' i j k ≫ t' j k i ≫ t' k i j = 𝟙 _`.\n-/\nstructure GlueData where\n  J : Type v\n  U : J → C\n  V : J × J → C\n  f : ∀ i j, V (i, j) ⟶ U i\n  f_mono : ∀ i j, Mono (f i j) := by infer_instance\n  f_hasPullback : ∀ i j k, HasPullback (f i j) (f i k) := by infer_instance\n  f_id : ∀ i, IsIso (f i i) := by infer_instance\n  t : ∀ i j, V (i, j) ⟶ V (j, i)\n  t_id : ∀ i, t i i = 𝟙 _\n  t' : ∀ i j k, pullback (f i j) (f i k) ⟶ pullback (f j k) (f j i)\n  t_fac : ∀ i j k, t' i j k ≫ pullback.snd _ _ = pullback.fst _ _ ≫ t i j\n  cocycle : ∀ i j k, t' i j k ≫ t' j k i ≫ t' k i j = 𝟙 _\n\n"}
{"name":"CategoryTheory.GlueData.t_id","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nself : CategoryTheory.GlueData C\ni : self.J\n⊢ Eq (self.t i i) (CategoryTheory.CategoryStruct.id (self.V { fst := i, snd := i }))","decl":"/-- A gluing datum consists of\n1. An index type `J`\n2. An object `U i` for each `i : J`.\n3. An object `V i j` for each `i j : J`.\n4. A monomorphism `f i j : V i j ⟶ U i` for each `i j : J`.\n5. A transition map `t i j : V i j ⟶ V j i` for each `i j : J`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. The pullback for `f i j` and `f i k` exists.\n9. `V i j ×[U i] V i k ⟶ V i j ⟶ V j i` factors through `V j k ×[U j] V j i ⟶ V j i` via some\n    `t' : V i j ×[U i] V i k ⟶ V j k ×[U j] V j i`.\n10. `t' i j k ≫ t' j k i ≫ t' k i j = 𝟙 _`.\n-/\nstructure GlueData where\n  J : Type v\n  U : J → C\n  V : J × J → C\n  f : ∀ i j, V (i, j) ⟶ U i\n  f_mono : ∀ i j, Mono (f i j) := by infer_instance\n  f_hasPullback : ∀ i j k, HasPullback (f i j) (f i k) := by infer_instance\n  f_id : ∀ i, IsIso (f i i) := by infer_instance\n  t : ∀ i j, V (i, j) ⟶ V (j, i)\n  t_id : ∀ i, t i i = 𝟙 _\n  t' : ∀ i j k, pullback (f i j) (f i k) ⟶ pullback (f j k) (f j i)\n  t_fac : ∀ i j k, t' i j k ≫ pullback.snd _ _ = pullback.fst _ _ ≫ t i j\n  cocycle : ∀ i j k, t' i j k ≫ t' j k i ≫ t' k i j = 𝟙 _\n\n"}
{"name":"CategoryTheory.GlueData.mk.inj","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nJ✝ : Type v\nU✝ : J✝ → C\nV✝ : Prod J✝ J✝ → C\nf✝ : (i j : J✝) → Quiver.Hom (V✝ { fst := i, snd := j }) (U✝ i)\nf_mono✝ : autoParam (∀ (i j : J✝), CategoryTheory.Mono (f✝ i j)) _auto✝\nf_hasPullback✝ : autoParam (∀ (i j k : J✝), CategoryTheory.Limits.HasPullback (f✝ i j) (f✝ i k)) _auto✝\nf_id✝ : autoParam (∀ (i : J✝), CategoryTheory.IsIso (f✝ i i)) _auto✝\nt✝ : (i j : J✝) → Quiver.Hom (V✝ { fst := i, snd := j }) (V✝ { fst := j, snd := i })\nt_id✝ : ∀ (i : J✝), Eq (t✝ i i) (CategoryTheory.CategoryStruct.id (V✝ { fst := i, snd := i }))\nt'✝ : (i j k : J✝) → Quiver.Hom (CategoryTheory.Limits.pullback (f✝ i j) (f✝ i k)) (CategoryTheory.Limits.pullback (f✝ j k) (f✝ j i))\nt_fac✝ : ∀ (i j k : J✝), Eq (CategoryTheory.CategoryStruct.comp (t'✝ i j k) (CategoryTheory.Limits.pullback.snd (f✝ j k) (f✝ j i))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (f✝ i j) (f✝ i k)) (t✝ i j))\ncocycle✝ : ∀ (i j k : J✝), Eq (CategoryTheory.CategoryStruct.comp (t'✝ i j k) (CategoryTheory.CategoryStruct.comp (t'✝ j k i) (t'✝ k i j))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback (f✝ i j) (f✝ i k)))\nJ : Type v\nU : J → C\nV : Prod J J → C\nf : (i j : J) → Quiver.Hom (V { fst := i, snd := j }) (U i)\nf_mono : autoParam (∀ (i j : J), CategoryTheory.Mono (f i j)) _auto✝\nf_hasPullback : autoParam (∀ (i j k : J), CategoryTheory.Limits.HasPullback (f i j) (f i k)) _auto✝\nf_id : autoParam (∀ (i : J), CategoryTheory.IsIso (f i i)) _auto✝\nt : (i j : J) → Quiver.Hom (V { fst := i, snd := j }) (V { fst := j, snd := i })\nt_id : ∀ (i : J), Eq (t i i) (CategoryTheory.CategoryStruct.id (V { fst := i, snd := i }))\nt' : (i j k : J) → Quiver.Hom (CategoryTheory.Limits.pullback (f i j) (f i k)) (CategoryTheory.Limits.pullback (f j k) (f j i))\nt_fac : ∀ (i j k : J), Eq (CategoryTheory.CategoryStruct.comp (t' i j k) (CategoryTheory.Limits.pullback.snd (f j k) (f j i))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (f i j) (f i k)) (t i j))\ncocycle : ∀ (i j k : J), Eq (CategoryTheory.CategoryStruct.comp (t' i j k) (CategoryTheory.CategoryStruct.comp (t' j k i) (t' k i j))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback (f i j) (f i k)))\nx✝ : Eq { J := J✝, U := U✝, V := V✝, f := f✝, f_mono := f_mono✝, f_hasPullback := f_hasPullback✝, f_id := f_id✝, t := t✝, t_id := t_id✝, t' := t'✝, t_fac := t_fac✝, cocycle := cocycle✝ } { J := J, U := U, V := V, f := f, f_mono := f_mono, f_hasPullback := f_hasPullback, f_id := f_id, t := t, t_id := t_id, t' := t', t_fac := t_fac, cocycle := cocycle }\n⊢ And (Eq J✝ J) (And (HEq U✝ U) (And (HEq V✝ V) (And (HEq f✝ f) (And (HEq t✝ t) (HEq t'✝ t')))))","decl":"/-- A gluing datum consists of\n1. An index type `J`\n2. An object `U i` for each `i : J`.\n3. An object `V i j` for each `i j : J`.\n4. A monomorphism `f i j : V i j ⟶ U i` for each `i j : J`.\n5. A transition map `t i j : V i j ⟶ V j i` for each `i j : J`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. The pullback for `f i j` and `f i k` exists.\n9. `V i j ×[U i] V i k ⟶ V i j ⟶ V j i` factors through `V j k ×[U j] V j i ⟶ V j i` via some\n    `t' : V i j ×[U i] V i k ⟶ V j k ×[U j] V j i`.\n10. `t' i j k ≫ t' j k i ≫ t' k i j = 𝟙 _`.\n-/\nstructure GlueData where\n  J : Type v\n  U : J → C\n  V : J × J → C\n  f : ∀ i j, V (i, j) ⟶ U i\n  f_mono : ∀ i j, Mono (f i j) := by infer_instance\n  f_hasPullback : ∀ i j k, HasPullback (f i j) (f i k) := by infer_instance\n  f_id : ∀ i, IsIso (f i i) := by infer_instance\n  t : ∀ i j, V (i, j) ⟶ V (j, i)\n  t_id : ∀ i, t i i = 𝟙 _\n  t' : ∀ i j k, pullback (f i j) (f i k) ⟶ pullback (f j k) (f j i)\n  t_fac : ∀ i j k, t' i j k ≫ pullback.snd _ _ = pullback.fst _ _ ≫ t i j\n  cocycle : ∀ i j k, t' i j k ≫ t' j k i ≫ t' k i j = 𝟙 _\n\n"}
{"name":"CategoryTheory.GlueData.mk.injEq","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nJ✝ : Type v\nU✝ : J✝ → C\nV✝ : Prod J✝ J✝ → C\nf✝ : (i j : J✝) → Quiver.Hom (V✝ { fst := i, snd := j }) (U✝ i)\nf_mono✝ : autoParam (∀ (i j : J✝), CategoryTheory.Mono (f✝ i j)) _auto✝\nf_hasPullback✝ : autoParam (∀ (i j k : J✝), CategoryTheory.Limits.HasPullback (f✝ i j) (f✝ i k)) _auto✝\nf_id✝ : autoParam (∀ (i : J✝), CategoryTheory.IsIso (f✝ i i)) _auto✝\nt✝ : (i j : J✝) → Quiver.Hom (V✝ { fst := i, snd := j }) (V✝ { fst := j, snd := i })\nt_id✝ : ∀ (i : J✝), Eq (t✝ i i) (CategoryTheory.CategoryStruct.id (V✝ { fst := i, snd := i }))\nt'✝ : (i j k : J✝) → Quiver.Hom (CategoryTheory.Limits.pullback (f✝ i j) (f✝ i k)) (CategoryTheory.Limits.pullback (f✝ j k) (f✝ j i))\nt_fac✝ : ∀ (i j k : J✝), Eq (CategoryTheory.CategoryStruct.comp (t'✝ i j k) (CategoryTheory.Limits.pullback.snd (f✝ j k) (f✝ j i))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (f✝ i j) (f✝ i k)) (t✝ i j))\ncocycle✝ : ∀ (i j k : J✝), Eq (CategoryTheory.CategoryStruct.comp (t'✝ i j k) (CategoryTheory.CategoryStruct.comp (t'✝ j k i) (t'✝ k i j))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback (f✝ i j) (f✝ i k)))\nJ : Type v\nU : J → C\nV : Prod J J → C\nf : (i j : J) → Quiver.Hom (V { fst := i, snd := j }) (U i)\nf_mono : autoParam (∀ (i j : J), CategoryTheory.Mono (f i j)) _auto✝\nf_hasPullback : autoParam (∀ (i j k : J), CategoryTheory.Limits.HasPullback (f i j) (f i k)) _auto✝\nf_id : autoParam (∀ (i : J), CategoryTheory.IsIso (f i i)) _auto✝\nt : (i j : J) → Quiver.Hom (V { fst := i, snd := j }) (V { fst := j, snd := i })\nt_id : ∀ (i : J), Eq (t i i) (CategoryTheory.CategoryStruct.id (V { fst := i, snd := i }))\nt' : (i j k : J) → Quiver.Hom (CategoryTheory.Limits.pullback (f i j) (f i k)) (CategoryTheory.Limits.pullback (f j k) (f j i))\nt_fac : ∀ (i j k : J), Eq (CategoryTheory.CategoryStruct.comp (t' i j k) (CategoryTheory.Limits.pullback.snd (f j k) (f j i))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (f i j) (f i k)) (t i j))\ncocycle : ∀ (i j k : J), Eq (CategoryTheory.CategoryStruct.comp (t' i j k) (CategoryTheory.CategoryStruct.comp (t' j k i) (t' k i j))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback (f i j) (f i k)))\n⊢ Eq (Eq { J := J✝, U := U✝, V := V✝, f := f✝, f_mono := f_mono✝, f_hasPullback := f_hasPullback✝, f_id := f_id✝, t := t✝, t_id := t_id✝, t' := t'✝, t_fac := t_fac✝, cocycle := cocycle✝ } { J := J, U := U, V := V, f := f, f_mono := f_mono, f_hasPullback := f_hasPullback, f_id := f_id, t := t, t_id := t_id, t' := t', t_fac := t_fac, cocycle := cocycle }) (And (Eq J✝ J) (And (HEq U✝ U) (And (HEq V✝ V) (And (HEq f✝ f) (And (HEq t✝ t) (HEq t'✝ t'))))))","decl":"/-- A gluing datum consists of\n1. An index type `J`\n2. An object `U i` for each `i : J`.\n3. An object `V i j` for each `i j : J`.\n4. A monomorphism `f i j : V i j ⟶ U i` for each `i j : J`.\n5. A transition map `t i j : V i j ⟶ V j i` for each `i j : J`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. The pullback for `f i j` and `f i k` exists.\n9. `V i j ×[U i] V i k ⟶ V i j ⟶ V j i` factors through `V j k ×[U j] V j i ⟶ V j i` via some\n    `t' : V i j ×[U i] V i k ⟶ V j k ×[U j] V j i`.\n10. `t' i j k ≫ t' j k i ≫ t' k i j = 𝟙 _`.\n-/\nstructure GlueData where\n  J : Type v\n  U : J → C\n  V : J × J → C\n  f : ∀ i j, V (i, j) ⟶ U i\n  f_mono : ∀ i j, Mono (f i j) := by infer_instance\n  f_hasPullback : ∀ i j k, HasPullback (f i j) (f i k) := by infer_instance\n  f_id : ∀ i, IsIso (f i i) := by infer_instance\n  t : ∀ i j, V (i, j) ⟶ V (j, i)\n  t_id : ∀ i, t i i = 𝟙 _\n  t' : ∀ i j k, pullback (f i j) (f i k) ⟶ pullback (f j k) (f j i)\n  t_fac : ∀ i j k, t' i j k ≫ pullback.snd _ _ = pullback.fst _ _ ≫ t i j\n  cocycle : ∀ i j k, t' i j k ≫ t' j k i ≫ t' k i j = 𝟙 _\n\n"}
{"name":"CategoryTheory.GlueData.t_fac_assoc","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nself : CategoryTheory.GlueData C\ni j k : self.J\nZ : C\nh : Quiver.Hom (self.V { fst := j, snd := i }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.t' i j k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (self.f j k) (self.f j i)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (self.f i j) (self.f i k)) (CategoryTheory.CategoryStruct.comp (self.t i j) h))","decl":"attribute [reassoc] GlueData.t_fac GlueData.cocycle\n\n"}
{"name":"CategoryTheory.GlueData.cocycle_assoc","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nself : CategoryTheory.GlueData C\ni j k : self.J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pullback (self.f i j) (self.f i k)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.t' i j k) (CategoryTheory.CategoryStruct.comp (self.t' j k i) (CategoryTheory.CategoryStruct.comp (self.t' k i j) h))) h","decl":"attribute [reassoc] GlueData.t_fac GlueData.cocycle\n\n"}
{"name":"CategoryTheory.GlueData.t'_iij","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nD : CategoryTheory.GlueData C\ni j : D.J\n⊢ Eq (D.t' i i j) (CategoryTheory.Limits.pullbackSymmetry (D.f i i) (D.f i j)).hom","decl":"@[simp]\ntheorem t'_iij (i j : D.J) : D.t' i i j = (pullbackSymmetry _ _).hom := by\n  have eq₁ := D.t_fac i i j\n  have eq₂ := (IsIso.eq_comp_inv (D.f i i)).mpr (@pullback.condition _ _ _ _ _ _ (D.f i j) _)\n  rw [D.t_id, Category.comp_id, eq₂] at eq₁\n  have eq₃ := (IsIso.eq_comp_inv (D.f i i)).mp eq₁\n  rw [Category.assoc, ← pullback.condition, ← Category.assoc] at eq₃\n  exact\n    Mono.right_cancellation _ _\n      ((Mono.right_cancellation _ _ eq₃).trans (pullbackSymmetry_hom_comp_fst _ _).symm)\n\n"}
{"name":"CategoryTheory.GlueData.t'_jii","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nD : CategoryTheory.GlueData C\ni j : D.J\n⊢ Eq (D.t' j i i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (D.f j i) (D.f j i)) (CategoryTheory.CategoryStruct.comp (D.t j i) (CategoryTheory.inv (CategoryTheory.Limits.pullback.snd (D.f i i) (D.f i j)))))","decl":"theorem t'_jii (i j : D.J) : D.t' j i i = pullback.fst _ _ ≫ D.t j i ≫ inv (pullback.snd _ _) := by\n  rw [← Category.assoc, ← D.t_fac]\n  simp\n\n"}
{"name":"CategoryTheory.GlueData.t'_iji","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nD : CategoryTheory.GlueData C\ni j : D.J\n⊢ Eq (D.t' i j i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (D.f i j) (D.f i i)) (CategoryTheory.CategoryStruct.comp (D.t i j) (CategoryTheory.inv (CategoryTheory.Limits.pullback.snd (D.f j i) (D.f j i)))))","decl":"theorem t'_iji (i j : D.J) : D.t' i j i = pullback.fst _ _ ≫ D.t i j ≫ inv (pullback.snd _ _) := by\n  rw [← Category.assoc, ← D.t_fac]\n  simp\n\n"}
{"name":"CategoryTheory.GlueData.t_inv","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nD : CategoryTheory.GlueData C\ni j : D.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (D.t i j) (D.t j i)) (CategoryTheory.CategoryStruct.id (D.V { fst := i, snd := j }))","decl":"@[reassoc, elementwise (attr := simp)]\ntheorem t_inv (i j : D.J) : D.t i j ≫ D.t j i = 𝟙 _ := by\n  have eq : (pullbackSymmetry (D.f i i) (D.f i j)).hom =\n      pullback.snd _ _ ≫ inv (pullback.fst _ _) := by simp\n  have := D.cocycle i j i\n  rw [D.t'_iij, D.t'_jii, D.t'_iji, fst_eq_snd_of_mono_eq, eq] at this\n  simp only [Category.assoc, IsIso.inv_hom_id_assoc] at this\n  rw [← IsIso.eq_inv_comp, ← Category.assoc, IsIso.comp_inv_eq] at this\n  simpa using this\n\n"}
{"name":"CategoryTheory.GlueData.t_inv_assoc","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nD : CategoryTheory.GlueData C\ni j : D.J\nZ : C\nh : Quiver.Hom (D.V { fst := i, snd := j }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (D.t i j) (CategoryTheory.CategoryStruct.comp (D.t j i) h)) h","decl":"@[reassoc, elementwise (attr := simp)]\ntheorem t_inv (i j : D.J) : D.t i j ≫ D.t j i = 𝟙 _ := by\n  have eq : (pullbackSymmetry (D.f i i) (D.f i j)).hom =\n      pullback.snd _ _ ≫ inv (pullback.fst _ _) := by simp\n  have := D.cocycle i j i\n  rw [D.t'_iij, D.t'_jii, D.t'_iji, fst_eq_snd_of_mono_eq, eq] at this\n  simp only [Category.assoc, IsIso.inv_hom_id_assoc] at this\n  rw [← IsIso.eq_inv_comp, ← Category.assoc, IsIso.comp_inv_eq] at this\n  simpa using this\n\n"}
{"name":"CategoryTheory.GlueData.t_inv_apply","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nD : CategoryTheory.GlueData C\ni j : D.J\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (D.V { fst := i, snd := j })\n⊢ Eq ((D.t j i) ((D.t i j) x)) x","decl":"@[reassoc, elementwise (attr := simp)]\ntheorem t_inv (i j : D.J) : D.t i j ≫ D.t j i = 𝟙 _ := by\n  have eq : (pullbackSymmetry (D.f i i) (D.f i j)).hom =\n      pullback.snd _ _ ≫ inv (pullback.fst _ _) := by simp\n  have := D.cocycle i j i\n  rw [D.t'_iij, D.t'_jii, D.t'_iji, fst_eq_snd_of_mono_eq, eq] at this\n  simp only [Category.assoc, IsIso.inv_hom_id_assoc] at this\n  rw [← IsIso.eq_inv_comp, ← Category.assoc, IsIso.comp_inv_eq] at this\n  simpa using this\n\n"}
{"name":"CategoryTheory.GlueData.t'_inv","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nD : CategoryTheory.GlueData C\ni j k : D.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (D.t' i j k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry (D.f j k) (D.f j i)).hom (CategoryTheory.CategoryStruct.comp (D.t' j i k) (CategoryTheory.Limits.pullbackSymmetry (D.f i k) (D.f i j)).hom))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback (D.f i j) (D.f i k)))","decl":"theorem t'_inv (i j k : D.J) :\n    D.t' i j k ≫ (pullbackSymmetry _ _).hom ≫ D.t' j i k ≫ (pullbackSymmetry _ _).hom = 𝟙 _ := by\n  rw [← cancel_mono (pullback.fst (D.f i j) (D.f i k))]\n  simp [t_fac, t_fac_assoc]\n\n"}
{"name":"CategoryTheory.GlueData.t_isIso","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nD : CategoryTheory.GlueData C\ni j : D.J\n⊢ CategoryTheory.IsIso (D.t i j)","decl":"instance t_isIso (i j : D.J) : IsIso (D.t i j) :=\n  ⟨⟨D.t j i, D.t_inv _ _, D.t_inv _ _⟩⟩\n\n"}
{"name":"CategoryTheory.GlueData.t'_isIso","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nD : CategoryTheory.GlueData C\ni j k : D.J\n⊢ CategoryTheory.IsIso (D.t' i j k)","decl":"instance t'_isIso (i j k : D.J) : IsIso (D.t' i j k) :=\n  ⟨⟨D.t' j k i ≫ D.t' k i j, D.cocycle _ _ _, by simpa using D.cocycle _ _ _⟩⟩\n\n"}
{"name":"CategoryTheory.GlueData.t'_comp_eq_pullbackSymmetry_assoc","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nD : CategoryTheory.GlueData C\ni j k : D.J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pullback (D.f i j) (D.f i k)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (D.t' j k i) (CategoryTheory.CategoryStruct.comp (D.t' k i j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry (D.f j k) (D.f j i)).hom (CategoryTheory.CategoryStruct.comp (D.t' j i k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry (D.f i k) (D.f i j)).hom h)))","decl":"@[reassoc]\ntheorem t'_comp_eq_pullbackSymmetry (i j k : D.J) :\n    D.t' j k i ≫ D.t' k i j =\n      (pullbackSymmetry _ _).hom ≫ D.t' j i k ≫ (pullbackSymmetry _ _).hom := by\n  trans inv (D.t' i j k)\n  · exact IsIso.eq_inv_of_hom_inv_id (D.cocycle _ _ _)\n  · rw [← cancel_mono (pullback.fst (D.f i j) (D.f i k))]\n    simp [t_fac, t_fac_assoc]\n\n"}
{"name":"CategoryTheory.GlueData.t'_comp_eq_pullbackSymmetry","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nD : CategoryTheory.GlueData C\ni j k : D.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (D.t' j k i) (D.t' k i j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry (D.f j k) (D.f j i)).hom (CategoryTheory.CategoryStruct.comp (D.t' j i k) (CategoryTheory.Limits.pullbackSymmetry (D.f i k) (D.f i j)).hom))","decl":"@[reassoc]\ntheorem t'_comp_eq_pullbackSymmetry (i j k : D.J) :\n    D.t' j k i ≫ D.t' k i j =\n      (pullbackSymmetry _ _).hom ≫ D.t' j i k ≫ (pullbackSymmetry _ _).hom := by\n  trans inv (D.t' i j k)\n  · exact IsIso.eq_inv_of_hom_inv_id (D.cocycle _ _ _)\n  · rw [← cancel_mono (pullback.fst (D.f i j) (D.f i k))]\n    simp [t_fac, t_fac_assoc]\n\n"}
{"name":"CategoryTheory.GlueData.diagram_l","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nD : CategoryTheory.GlueData C\n⊢ Eq D.diagram.L (Prod D.J D.J)","decl":"@[simp]\ntheorem diagram_l : D.diagram.L = (D.J × D.J) :=\n  rfl\n\n"}
{"name":"CategoryTheory.GlueData.diagram_r","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nD : CategoryTheory.GlueData C\n⊢ Eq D.diagram.R D.J","decl":"@[simp]\ntheorem diagram_r : D.diagram.R = D.J :=\n  rfl\n\n"}
{"name":"CategoryTheory.GlueData.diagram_fstFrom","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nD : CategoryTheory.GlueData C\ni j : D.J\n⊢ Eq (D.diagram.fstFrom { fst := i, snd := j }) i","decl":"@[simp]\ntheorem diagram_fstFrom (i j : D.J) : D.diagram.fstFrom ⟨i, j⟩ = i :=\n  rfl\n\n"}
{"name":"CategoryTheory.GlueData.diagram_sndFrom","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nD : CategoryTheory.GlueData C\ni j : D.J\n⊢ Eq (D.diagram.sndFrom { fst := i, snd := j }) j","decl":"@[simp]\ntheorem diagram_sndFrom (i j : D.J) : D.diagram.sndFrom ⟨i, j⟩ = j :=\n  rfl\n\n"}
{"name":"CategoryTheory.GlueData.diagram_fst","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nD : CategoryTheory.GlueData C\ni j : D.J\n⊢ Eq (D.diagram.fst { fst := i, snd := j }) (D.f i j)","decl":"@[simp]\ntheorem diagram_fst (i j : D.J) : D.diagram.fst ⟨i, j⟩ = D.f i j :=\n  rfl\n\n"}
{"name":"CategoryTheory.GlueData.diagram_snd","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nD : CategoryTheory.GlueData C\ni j : D.J\n⊢ Eq (D.diagram.snd { fst := i, snd := j }) (CategoryTheory.CategoryStruct.comp (D.t i j) (D.f j i))","decl":"@[simp]\ntheorem diagram_snd (i j : D.J) : D.diagram.snd ⟨i, j⟩ = D.t i j ≫ D.f j i :=\n  rfl\n\n"}
{"name":"CategoryTheory.GlueData.diagram_left","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nD : CategoryTheory.GlueData C\n⊢ Eq D.diagram.left D.V","decl":"@[simp]\ntheorem diagram_left : D.diagram.left = D.V :=\n  rfl\n\n"}
{"name":"CategoryTheory.GlueData.diagram_right","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nD : CategoryTheory.GlueData C\n⊢ Eq D.diagram.right D.U","decl":"@[simp]\ntheorem diagram_right : D.diagram.right = D.U :=\n  rfl\n\n"}
{"name":"CategoryTheory.GlueData.glue_condition","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v, u₁} C\nD : CategoryTheory.GlueData C\ninst✝ : CategoryTheory.Limits.HasMulticoequalizer D.diagram\ni j : D.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (D.t i j) (CategoryTheory.CategoryStruct.comp (D.f j i) (D.ι j))) (CategoryTheory.CategoryStruct.comp (D.f i j) (D.ι i))","decl":"@[elementwise (attr := simp)]\ntheorem glue_condition (i j : D.J) : D.t i j ≫ D.f j i ≫ D.ι j = D.f i j ≫ D.ι i :=\n  (Category.assoc _ _ _).symm.trans (Multicoequalizer.condition D.diagram ⟨i, j⟩).symm\n\n"}
{"name":"CategoryTheory.GlueData.glue_condition_apply","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v, u₁} C\nD : CategoryTheory.GlueData C\ninst✝ : CategoryTheory.Limits.HasMulticoequalizer D.diagram\ni j : D.J\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (D.V { fst := i, snd := j })\n⊢ Eq ((D.ι j) ((D.f j i) ((D.t i j) x))) ((D.ι i) ((D.f i j) x))","decl":"@[elementwise (attr := simp)]\ntheorem glue_condition (i j : D.J) : D.t i j ≫ D.f j i ≫ D.ι j = D.f i j ≫ D.ι i :=\n  (Category.assoc _ _ _).symm.trans (Multicoequalizer.condition D.diagram ⟨i, j⟩).symm\n\n"}
{"name":"CategoryTheory.GlueData.π_epi","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v, u₁} C\nD : CategoryTheory.GlueData C\ninst✝¹ : CategoryTheory.Limits.HasMulticoequalizer D.diagram\ninst✝ : CategoryTheory.Limits.HasColimits C\n⊢ CategoryTheory.Epi D.π","decl":"instance π_epi : Epi D.π := by\n  unfold π\n  infer_instance\n\n"}
{"name":"CategoryTheory.GlueData.types_π_surjective","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"D : CategoryTheory.GlueData (Type u_1)\n⊢ Function.Surjective D.π","decl":"theorem types_π_surjective (D : GlueData Type*) : Function.Surjective D.π :=\n  (epi_iff_surjective _).mp inferInstance\n\n"}
{"name":"CategoryTheory.GlueData.types_ι_jointly_surjective","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"D : CategoryTheory.GlueData (Type v)\nx : D.glued\n⊢ Exists fun i => Exists fun y => Eq (D.ι i y) x","decl":"theorem types_ι_jointly_surjective (D : GlueData (Type v)) (x : D.glued) :\n    ∃ (i : _) (y : D.U i), D.ι i y = x := by\n  delta CategoryTheory.GlueData.ι\n  simp_rw [← Multicoequalizer.ι_sigmaπ D.diagram]\n  rcases D.types_π_surjective x with ⟨x', rfl⟩\n  --have := colimit.isoColimitCocone (Types.coproductColimitCocone _)\n  rw [← show (colimit.isoColimitCocone (Types.coproductColimitCocone.{v, v} _)).inv _ = x' from\n      ConcreteCategory.congr_hom\n        (colimit.isoColimitCocone (Types.coproductColimitCocone _)).hom_inv_id x']\n  rcases (colimit.isoColimitCocone (Types.coproductColimitCocone _)).hom x' with ⟨i, y⟩\n  exact ⟨i, y, by\n    simp [← Multicoequalizer.ι_sigmaπ]\n    rfl ⟩\n\n"}
{"name":"CategoryTheory.GlueData.instHasPullbackMapF","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v, u₁} C\nC' : Type u₂\ninst✝¹ : CategoryTheory.Category.{v, u₂} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst✝ : ∀ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\ni j k : D.J\n⊢ CategoryTheory.Limits.HasPullback (F.map (D.f i j)) (F.map (D.f i k))","decl":"instance (i j k : D.J) : HasPullback (F.map (D.f i j)) (F.map (D.f i k)) :=\n  ⟨⟨⟨_, isLimitOfHasPullbackOfPreservesLimit F (D.f i j) (D.f i k)⟩⟩⟩\n\n"}
{"name":"CategoryTheory.GlueData.mapGlueData_t'","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v, u₁} C\nC' : Type u₂\ninst✝¹ : CategoryTheory.Category.{v, u₂} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst✝ : ∀ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\ni j k : D.J\n⊢ Eq ((D.mapGlueData F).t' i j k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesPullback.iso F (D.f i j) (D.f i k)).inv (CategoryTheory.CategoryStruct.comp (F.map (D.t' i j k)) (CategoryTheory.Limits.PreservesPullback.iso F (D.f j k) (D.f j i)).hom))","decl":"/-- A functor that preserves the pullbacks of `f i j` and `f i k` can map a family of glue data. -/\n@[simps]\ndef mapGlueData : GlueData C' where\n  J := D.J\n  U i := F.obj (D.U i)\n  V i := F.obj (D.V i)\n  f i j := F.map (D.f i j)\n  f_mono _ _ := preserves_mono_of_preservesLimit _ _\n  f_id _ := inferInstance\n  t i j := F.map (D.t i j)\n  t_id i := by\n    simp [D.t_id i]\n  t' i j k :=\n    (PreservesPullback.iso F (D.f i j) (D.f i k)).inv ≫\n      F.map (D.t' i j k) ≫ (PreservesPullback.iso F (D.f j k) (D.f j i)).hom\n  t_fac i j k := by simpa [Iso.inv_comp_eq] using congr_arg (fun f => F.map f) (D.t_fac i j k)\n  cocycle i j k := by\n    simp only [Category.assoc, Iso.hom_inv_id_assoc, ← Functor.map_comp_assoc, D.cocycle,\n      Iso.inv_hom_id, CategoryTheory.Functor.map_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.GlueData.mapGlueData_V","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v, u₁} C\nC' : Type u₂\ninst✝¹ : CategoryTheory.Category.{v, u₂} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst✝ : ∀ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\ni : Prod D.J D.J\n⊢ Eq ((D.mapGlueData F).V i) (F.obj (D.V i))","decl":"/-- A functor that preserves the pullbacks of `f i j` and `f i k` can map a family of glue data. -/\n@[simps]\ndef mapGlueData : GlueData C' where\n  J := D.J\n  U i := F.obj (D.U i)\n  V i := F.obj (D.V i)\n  f i j := F.map (D.f i j)\n  f_mono _ _ := preserves_mono_of_preservesLimit _ _\n  f_id _ := inferInstance\n  t i j := F.map (D.t i j)\n  t_id i := by\n    simp [D.t_id i]\n  t' i j k :=\n    (PreservesPullback.iso F (D.f i j) (D.f i k)).inv ≫\n      F.map (D.t' i j k) ≫ (PreservesPullback.iso F (D.f j k) (D.f j i)).hom\n  t_fac i j k := by simpa [Iso.inv_comp_eq] using congr_arg (fun f => F.map f) (D.t_fac i j k)\n  cocycle i j k := by\n    simp only [Category.assoc, Iso.hom_inv_id_assoc, ← Functor.map_comp_assoc, D.cocycle,\n      Iso.inv_hom_id, CategoryTheory.Functor.map_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.GlueData.mapGlueData_f","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v, u₁} C\nC' : Type u₂\ninst✝¹ : CategoryTheory.Category.{v, u₂} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst✝ : ∀ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\ni j : D.J\n⊢ Eq ((D.mapGlueData F).f i j) (F.map (D.f i j))","decl":"/-- A functor that preserves the pullbacks of `f i j` and `f i k` can map a family of glue data. -/\n@[simps]\ndef mapGlueData : GlueData C' where\n  J := D.J\n  U i := F.obj (D.U i)\n  V i := F.obj (D.V i)\n  f i j := F.map (D.f i j)\n  f_mono _ _ := preserves_mono_of_preservesLimit _ _\n  f_id _ := inferInstance\n  t i j := F.map (D.t i j)\n  t_id i := by\n    simp [D.t_id i]\n  t' i j k :=\n    (PreservesPullback.iso F (D.f i j) (D.f i k)).inv ≫\n      F.map (D.t' i j k) ≫ (PreservesPullback.iso F (D.f j k) (D.f j i)).hom\n  t_fac i j k := by simpa [Iso.inv_comp_eq] using congr_arg (fun f => F.map f) (D.t_fac i j k)\n  cocycle i j k := by\n    simp only [Category.assoc, Iso.hom_inv_id_assoc, ← Functor.map_comp_assoc, D.cocycle,\n      Iso.inv_hom_id, CategoryTheory.Functor.map_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.GlueData.mapGlueData_t","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v, u₁} C\nC' : Type u₂\ninst✝¹ : CategoryTheory.Category.{v, u₂} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst✝ : ∀ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\ni j : D.J\n⊢ Eq ((D.mapGlueData F).t i j) (F.map (D.t i j))","decl":"/-- A functor that preserves the pullbacks of `f i j` and `f i k` can map a family of glue data. -/\n@[simps]\ndef mapGlueData : GlueData C' where\n  J := D.J\n  U i := F.obj (D.U i)\n  V i := F.obj (D.V i)\n  f i j := F.map (D.f i j)\n  f_mono _ _ := preserves_mono_of_preservesLimit _ _\n  f_id _ := inferInstance\n  t i j := F.map (D.t i j)\n  t_id i := by\n    simp [D.t_id i]\n  t' i j k :=\n    (PreservesPullback.iso F (D.f i j) (D.f i k)).inv ≫\n      F.map (D.t' i j k) ≫ (PreservesPullback.iso F (D.f j k) (D.f j i)).hom\n  t_fac i j k := by simpa [Iso.inv_comp_eq] using congr_arg (fun f => F.map f) (D.t_fac i j k)\n  cocycle i j k := by\n    simp only [Category.assoc, Iso.hom_inv_id_assoc, ← Functor.map_comp_assoc, D.cocycle,\n      Iso.inv_hom_id, CategoryTheory.Functor.map_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.GlueData.mapGlueData_J","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v, u₁} C\nC' : Type u₂\ninst✝¹ : CategoryTheory.Category.{v, u₂} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst✝ : ∀ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\n⊢ Eq (D.mapGlueData F).J D.J","decl":"/-- A functor that preserves the pullbacks of `f i j` and `f i k` can map a family of glue data. -/\n@[simps]\ndef mapGlueData : GlueData C' where\n  J := D.J\n  U i := F.obj (D.U i)\n  V i := F.obj (D.V i)\n  f i j := F.map (D.f i j)\n  f_mono _ _ := preserves_mono_of_preservesLimit _ _\n  f_id _ := inferInstance\n  t i j := F.map (D.t i j)\n  t_id i := by\n    simp [D.t_id i]\n  t' i j k :=\n    (PreservesPullback.iso F (D.f i j) (D.f i k)).inv ≫\n      F.map (D.t' i j k) ≫ (PreservesPullback.iso F (D.f j k) (D.f j i)).hom\n  t_fac i j k := by simpa [Iso.inv_comp_eq] using congr_arg (fun f => F.map f) (D.t_fac i j k)\n  cocycle i j k := by\n    simp only [Category.assoc, Iso.hom_inv_id_assoc, ← Functor.map_comp_assoc, D.cocycle,\n      Iso.inv_hom_id, CategoryTheory.Functor.map_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.GlueData.mapGlueData_U","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v, u₁} C\nC' : Type u₂\ninst✝¹ : CategoryTheory.Category.{v, u₂} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst✝ : ∀ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\ni : D.J\n⊢ Eq ((D.mapGlueData F).U i) (F.obj (D.U i))","decl":"/-- A functor that preserves the pullbacks of `f i j` and `f i k` can map a family of glue data. -/\n@[simps]\ndef mapGlueData : GlueData C' where\n  J := D.J\n  U i := F.obj (D.U i)\n  V i := F.obj (D.V i)\n  f i j := F.map (D.f i j)\n  f_mono _ _ := preserves_mono_of_preservesLimit _ _\n  f_id _ := inferInstance\n  t i j := F.map (D.t i j)\n  t_id i := by\n    simp [D.t_id i]\n  t' i j k :=\n    (PreservesPullback.iso F (D.f i j) (D.f i k)).inv ≫\n      F.map (D.t' i j k) ≫ (PreservesPullback.iso F (D.f j k) (D.f j i)).hom\n  t_fac i j k := by simpa [Iso.inv_comp_eq] using congr_arg (fun f => F.map f) (D.t_fac i j k)\n  cocycle i j k := by\n    simp only [Category.assoc, Iso.hom_inv_id_assoc, ← Functor.map_comp_assoc, D.cocycle,\n      Iso.inv_hom_id, CategoryTheory.Functor.map_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.GlueData.diagramIso_app_left","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v, u₁} C\nC' : Type u₂\ninst✝¹ : CategoryTheory.Category.{v, u₂} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst✝ : ∀ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\ni : Prod D.J D.J\n⊢ Eq ((D.diagramIso F).app (CategoryTheory.Limits.WalkingMultispan.left i)) (CategoryTheory.Iso.refl ((D.diagram.multispan.comp F).obj (CategoryTheory.Limits.WalkingMultispan.left i)))","decl":"@[simp]\ntheorem diagramIso_app_left (i : D.J × D.J) :\n    (D.diagramIso F).app (WalkingMultispan.left i) = Iso.refl _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.GlueData.diagramIso_app_right","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v, u₁} C\nC' : Type u₂\ninst✝¹ : CategoryTheory.Category.{v, u₂} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst✝ : ∀ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\ni : D.J\n⊢ Eq ((D.diagramIso F).app (CategoryTheory.Limits.WalkingMultispan.right i)) (CategoryTheory.Iso.refl ((D.diagram.multispan.comp F).obj (CategoryTheory.Limits.WalkingMultispan.right i)))","decl":"@[simp]\ntheorem diagramIso_app_right (i : D.J) :\n    (D.diagramIso F).app (WalkingMultispan.right i) = Iso.refl _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.GlueData.diagramIso_hom_app_left","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v, u₁} C\nC' : Type u₂\ninst✝¹ : CategoryTheory.Category.{v, u₂} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst✝ : ∀ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\ni : Prod D.J D.J\n⊢ Eq ((D.diagramIso F).hom.app (CategoryTheory.Limits.WalkingMultispan.left i)) (CategoryTheory.CategoryStruct.id ((D.diagram.multispan.comp F).obj (CategoryTheory.Limits.WalkingMultispan.left i)))","decl":"@[simp]\ntheorem diagramIso_hom_app_left (i : D.J × D.J) :\n    (D.diagramIso F).hom.app (WalkingMultispan.left i) = 𝟙 _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.GlueData.diagramIso_hom_app_right","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v, u₁} C\nC' : Type u₂\ninst✝¹ : CategoryTheory.Category.{v, u₂} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst✝ : ∀ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\ni : D.J\n⊢ Eq ((D.diagramIso F).hom.app (CategoryTheory.Limits.WalkingMultispan.right i)) (CategoryTheory.CategoryStruct.id ((D.diagram.multispan.comp F).obj (CategoryTheory.Limits.WalkingMultispan.right i)))","decl":"@[simp]\ntheorem diagramIso_hom_app_right (i : D.J) :\n    (D.diagramIso F).hom.app (WalkingMultispan.right i) = 𝟙 _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.GlueData.diagramIso_inv_app_left","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v, u₁} C\nC' : Type u₂\ninst✝¹ : CategoryTheory.Category.{v, u₂} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst✝ : ∀ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\ni : Prod D.J D.J\n⊢ Eq ((D.diagramIso F).inv.app (CategoryTheory.Limits.WalkingMultispan.left i)) (CategoryTheory.CategoryStruct.id ((D.mapGlueData F).diagram.multispan.obj (CategoryTheory.Limits.WalkingMultispan.left i)))","decl":"@[simp]\ntheorem diagramIso_inv_app_left (i : D.J × D.J) :\n    (D.diagramIso F).inv.app (WalkingMultispan.left i) = 𝟙 _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.GlueData.diagramIso_inv_app_right","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v, u₁} C\nC' : Type u₂\ninst✝¹ : CategoryTheory.Category.{v, u₂} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst✝ : ∀ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\ni : D.J\n⊢ Eq ((D.diagramIso F).inv.app (CategoryTheory.Limits.WalkingMultispan.right i)) (CategoryTheory.CategoryStruct.id ((D.mapGlueData F).diagram.multispan.obj (CategoryTheory.Limits.WalkingMultispan.right i)))","decl":"@[simp]\ntheorem diagramIso_inv_app_right (i : D.J) :\n    (D.diagramIso F).inv.app (WalkingMultispan.right i) = 𝟙 _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.GlueData.hasColimit_multispan_comp","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v, u₁} C\nC' : Type u₂\ninst✝² : CategoryTheory.Category.{v, u₂} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst✝¹ : CategoryTheory.Limits.HasMulticoequalizer D.diagram\ninst✝ : CategoryTheory.Limits.PreservesColimit D.diagram.multispan F\n⊢ CategoryTheory.Limits.HasColimit (D.diagram.multispan.comp F)","decl":"theorem hasColimit_multispan_comp : HasColimit (D.diagram.multispan ⋙ F) :=\n  ⟨⟨⟨_, isColimitOfPreserves _ (colimit.isColimit _)⟩⟩⟩\n\n"}
{"name":"CategoryTheory.GlueData.hasColimit_mapGlueData_diagram","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v, u₁} C\nC' : Type u₂\ninst✝³ : CategoryTheory.Category.{v, u₂} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst✝² : CategoryTheory.Limits.HasMulticoequalizer D.diagram\ninst✝¹ : CategoryTheory.Limits.PreservesColimit D.diagram.multispan F\ninst✝ : ∀ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\n⊢ CategoryTheory.Limits.HasMulticoequalizer (D.mapGlueData F).diagram","decl":"theorem hasColimit_mapGlueData_diagram : HasMulticoequalizer (D.mapGlueData F).diagram :=\n  hasColimitOfIso (D.diagramIso F).symm\n\n"}
{"name":"CategoryTheory.GlueData.ι_gluedIso_hom","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v, u₁} C\nC' : Type u₂\ninst✝³ : CategoryTheory.Category.{v, u₂} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst✝² : CategoryTheory.Limits.HasMulticoequalizer D.diagram\ninst✝¹ : CategoryTheory.Limits.PreservesColimit D.diagram.multispan F\ninst✝ : ∀ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\ni : D.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (D.ι i)) (D.gluedIso F).hom) ((D.mapGlueData F).ι i)","decl":"@[reassoc (attr := simp)]\ntheorem ι_gluedIso_hom (i : D.J) : F.map (D.ι i) ≫ (D.gluedIso F).hom = (D.mapGlueData F).ι i := by\n  haveI : HasColimit (MultispanIndex.multispan (diagram (mapGlueData D F))) := inferInstance\n  erw [ι_preservesColimitIso_hom_assoc]\n  rw [HasColimit.isoOfNatIso_ι_hom]\n  erw [Category.id_comp]\n  rfl\n\n"}
{"name":"CategoryTheory.GlueData.ι_gluedIso_hom_assoc","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v, u₁} C\nC' : Type u₂\ninst✝³ : CategoryTheory.Category.{v, u₂} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst✝² : CategoryTheory.Limits.HasMulticoequalizer D.diagram\ninst✝¹ : CategoryTheory.Limits.PreservesColimit D.diagram.multispan F\ninst✝ : ∀ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\ni : D.J\nZ : C'\nh : Quiver.Hom (D.mapGlueData F).glued Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (D.ι i)) (CategoryTheory.CategoryStruct.comp (D.gluedIso F).hom h)) (CategoryTheory.CategoryStruct.comp ((D.mapGlueData F).ι i) h)","decl":"@[reassoc (attr := simp)]\ntheorem ι_gluedIso_hom (i : D.J) : F.map (D.ι i) ≫ (D.gluedIso F).hom = (D.mapGlueData F).ι i := by\n  haveI : HasColimit (MultispanIndex.multispan (diagram (mapGlueData D F))) := inferInstance\n  erw [ι_preservesColimitIso_hom_assoc]\n  rw [HasColimit.isoOfNatIso_ι_hom]\n  erw [Category.id_comp]\n  rfl\n\n"}
{"name":"CategoryTheory.GlueData.ι_gluedIso_inv_assoc","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v, u₁} C\nC' : Type u₂\ninst✝³ : CategoryTheory.Category.{v, u₂} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst✝² : CategoryTheory.Limits.HasMulticoequalizer D.diagram\ninst✝¹ : CategoryTheory.Limits.PreservesColimit D.diagram.multispan F\ninst✝ : ∀ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\ni : D.J\nZ : C'\nh : Quiver.Hom (F.obj D.glued) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((D.mapGlueData F).ι i) (CategoryTheory.CategoryStruct.comp (D.gluedIso F).inv h)) (CategoryTheory.CategoryStruct.comp (F.map (D.ι i)) h)","decl":"@[reassoc (attr := simp)]\ntheorem ι_gluedIso_inv (i : D.J) : (D.mapGlueData F).ι i ≫ (D.gluedIso F).inv = F.map (D.ι i) := by\n  rw [Iso.comp_inv_eq, ι_gluedIso_hom]\n\n"}
{"name":"CategoryTheory.GlueData.ι_gluedIso_inv","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v, u₁} C\nC' : Type u₂\ninst✝³ : CategoryTheory.Category.{v, u₂} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst✝² : CategoryTheory.Limits.HasMulticoequalizer D.diagram\ninst✝¹ : CategoryTheory.Limits.PreservesColimit D.diagram.multispan F\ninst✝ : ∀ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\ni : D.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((D.mapGlueData F).ι i) (D.gluedIso F).inv) (F.map (D.ι i))","decl":"@[reassoc (attr := simp)]\ntheorem ι_gluedIso_inv (i : D.J) : (D.mapGlueData F).ι i ≫ (D.gluedIso F).inv = F.map (D.ι i) := by\n  rw [Iso.comp_inv_eq, ι_gluedIso_hom]\n\n"}
{"name":"CategoryTheory.GlueData.ι_jointly_surjective","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v, u₁} C\nD : CategoryTheory.GlueData C\ninst✝² : CategoryTheory.Limits.HasMulticoequalizer D.diagram\nF : CategoryTheory.Functor C (Type v)\ninst✝¹ : CategoryTheory.Limits.PreservesColimit D.diagram.multispan F\ninst✝ : ∀ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\nx : F.obj D.glued\n⊢ Exists fun i => Exists fun y => Eq (F.map (D.ι i) y) x","decl":"/-- If there is a forgetful functor into `Type` that preserves enough (co)limits, then `D.ι` will\nbe jointly surjective. -/\ntheorem ι_jointly_surjective (F : C ⥤ Type v) [PreservesColimit D.diagram.multispan F]\n    [∀ i j k : D.J, PreservesLimit (cospan (D.f i j) (D.f i k)) F] (x : F.obj D.glued) :\n    ∃ (i : _) (y : F.obj (D.U i)), F.map (D.ι i) y = x := by\n  let e := D.gluedIso F\n  obtain ⟨i, y, eq⟩ := (D.mapGlueData F).types_ι_jointly_surjective (e.hom x)\n  replace eq := congr_arg e.inv eq\n  change ((D.mapGlueData F).ι i ≫ e.inv) y = (e.hom ≫ e.inv) x at eq\n  rw [e.hom_inv_id, D.ι_gluedIso_inv] at eq\n  exact ⟨i, y, eq⟩\n\n"}
{"name":"CategoryTheory.GlueData'.mk.inj","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nJ✝ : Type v\nU✝ : J✝ → C\nV✝ : (i j : J✝) → Ne i j → C\nf✝ : (i j : J✝) → (h : Ne i j) → Quiver.Hom (V✝ i j h) (U✝ i)\nf_mono✝ : autoParam (∀ (i j : J✝) (h : Ne i j), CategoryTheory.Mono (f✝ i j h)) _auto✝\nf_hasPullback✝ : autoParam (∀ (i j k : J✝) (hij : Ne i j) (hik : Ne i k), CategoryTheory.Limits.HasPullback (f✝ i j hij) (f✝ i k hik)) _auto✝\nt✝ : (i j : J✝) → (h : Ne i j) → Quiver.Hom (V✝ i j h) (V✝ j i ⋯)\nt'✝ : (i j k : J✝) → (hij : Ne i j) → (hik : Ne i k) → (hjk : Ne j k) → Quiver.Hom (CategoryTheory.Limits.pullback (f✝ i j hij) (f✝ i k hik)) (CategoryTheory.Limits.pullback (f✝ j k hjk) (f✝ j i ⋯))\nt_fac✝ : ∀ (i j k : J✝) (hij : Ne i j) (hik : Ne i k) (hjk : Ne j k), Eq (CategoryTheory.CategoryStruct.comp (t'✝ i j k hij hik hjk) (CategoryTheory.Limits.pullback.snd (f✝ j k hjk) (f✝ j i ⋯))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (f✝ i j hij) (f✝ i k hik)) (t✝ i j hij))\nt_inv✝ : ∀ (i j : J✝) (hij : Ne i j), Eq (CategoryTheory.CategoryStruct.comp (t✝ i j hij) (t✝ j i ⋯)) (CategoryTheory.CategoryStruct.id (V✝ i j hij))\ncocycle✝ : ∀ (i j k : J✝) (hij : Ne i j) (hik : Ne i k) (hjk : Ne j k), Eq (CategoryTheory.CategoryStruct.comp (t'✝ i j k hij hik hjk) (CategoryTheory.CategoryStruct.comp (t'✝ j k i hjk ⋯ ⋯) (t'✝ k i j ⋯ ⋯ hij))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback (f✝ i j hij) (f✝ i k hik)))\nJ : Type v\nU : J → C\nV : (i j : J) → Ne i j → C\nf : (i j : J) → (h : Ne i j) → Quiver.Hom (V i j h) (U i)\nf_mono : autoParam (∀ (i j : J) (h : Ne i j), CategoryTheory.Mono (f i j h)) _auto✝\nf_hasPullback : autoParam (∀ (i j k : J) (hij : Ne i j) (hik : Ne i k), CategoryTheory.Limits.HasPullback (f i j hij) (f i k hik)) _auto✝\nt : (i j : J) → (h : Ne i j) → Quiver.Hom (V i j h) (V j i ⋯)\nt' : (i j k : J) → (hij : Ne i j) → (hik : Ne i k) → (hjk : Ne j k) → Quiver.Hom (CategoryTheory.Limits.pullback (f i j hij) (f i k hik)) (CategoryTheory.Limits.pullback (f j k hjk) (f j i ⋯))\nt_fac : ∀ (i j k : J) (hij : Ne i j) (hik : Ne i k) (hjk : Ne j k), Eq (CategoryTheory.CategoryStruct.comp (t' i j k hij hik hjk) (CategoryTheory.Limits.pullback.snd (f j k hjk) (f j i ⋯))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (f i j hij) (f i k hik)) (t i j hij))\nt_inv : ∀ (i j : J) (hij : Ne i j), Eq (CategoryTheory.CategoryStruct.comp (t i j hij) (t j i ⋯)) (CategoryTheory.CategoryStruct.id (V i j hij))\ncocycle : ∀ (i j k : J) (hij : Ne i j) (hik : Ne i k) (hjk : Ne j k), Eq (CategoryTheory.CategoryStruct.comp (t' i j k hij hik hjk) (CategoryTheory.CategoryStruct.comp (t' j k i hjk ⋯ ⋯) (t' k i j ⋯ ⋯ hij))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback (f i j hij) (f i k hik)))\nx✝ : Eq { J := J✝, U := U✝, V := V✝, f := f✝, f_mono := f_mono✝, f_hasPullback := f_hasPullback✝, t := t✝, t' := t'✝, t_fac := t_fac✝, t_inv := t_inv✝, cocycle := cocycle✝ } { J := J, U := U, V := V, f := f, f_mono := f_mono, f_hasPullback := f_hasPullback, t := t, t' := t', t_fac := t_fac, t_inv := t_inv, cocycle := cocycle }\n⊢ And (Eq J✝ J) (And (HEq U✝ U) (And (HEq V✝ V) (And (HEq f✝ f) (And (HEq t✝ t) (HEq t'✝ t')))))","decl":"/--\nThis is a variant of `GlueData` that only requires conditions on `V (i, j)` when `i ≠ j`.\nSee `GlueData.ofGlueData'`\n-/\nstructure GlueData' where\n  /-- Indexing type of a glue data. -/\n  J : Type v\n  /-- Objects of a glue data to be glued. -/\n  U : J → C\n  /-- Objects representing the intersections. -/\n  V : ∀ (i j : J), i ≠ j → C\n  /-- The inclusion maps of the intersection into the object. -/\n  f : ∀ i j h, V i j h ⟶ U i\n  f_mono : ∀ i j h, Mono (f i j h) := by infer_instance\n  f_hasPullback : ∀ i j k hij hik, HasPullback (f i j hij) (f i k hik) := by infer_instance\n  /-- The transition maps between the intersections. -/\n  t : ∀ i j h, V i j h ⟶ V j i h.symm\n  /-- The transition maps between the intersection of intersections. -/\n  t' : ∀ i j k hij hik hjk,\n    pullback (f i j hij) (f i k hik) ⟶ pullback (f j k hjk) (f j i hij.symm)\n  t_fac : ∀ i j k hij hik hjk, t' i j k hij hik hjk ≫ pullback.snd _ _ =\n    pullback.fst _ _ ≫ t i j hij\n  t_inv : ∀ i j hij, t i j hij ≫ t j i hij.symm = 𝟙 _\n  cocycle : ∀ i j k hij hik hjk, t' i j k hij hik hjk ≫\n    t' j k i hjk hij.symm hik.symm ≫ t' k i j hik.symm hjk.symm hij = 𝟙 _\n\n"}
{"name":"CategoryTheory.GlueData'.mk.injEq","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nJ✝ : Type v\nU✝ : J✝ → C\nV✝ : (i j : J✝) → Ne i j → C\nf✝ : (i j : J✝) → (h : Ne i j) → Quiver.Hom (V✝ i j h) (U✝ i)\nf_mono✝ : autoParam (∀ (i j : J✝) (h : Ne i j), CategoryTheory.Mono (f✝ i j h)) _auto✝\nf_hasPullback✝ : autoParam (∀ (i j k : J✝) (hij : Ne i j) (hik : Ne i k), CategoryTheory.Limits.HasPullback (f✝ i j hij) (f✝ i k hik)) _auto✝\nt✝ : (i j : J✝) → (h : Ne i j) → Quiver.Hom (V✝ i j h) (V✝ j i ⋯)\nt'✝ : (i j k : J✝) → (hij : Ne i j) → (hik : Ne i k) → (hjk : Ne j k) → Quiver.Hom (CategoryTheory.Limits.pullback (f✝ i j hij) (f✝ i k hik)) (CategoryTheory.Limits.pullback (f✝ j k hjk) (f✝ j i ⋯))\nt_fac✝ : ∀ (i j k : J✝) (hij : Ne i j) (hik : Ne i k) (hjk : Ne j k), Eq (CategoryTheory.CategoryStruct.comp (t'✝ i j k hij hik hjk) (CategoryTheory.Limits.pullback.snd (f✝ j k hjk) (f✝ j i ⋯))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (f✝ i j hij) (f✝ i k hik)) (t✝ i j hij))\nt_inv✝ : ∀ (i j : J✝) (hij : Ne i j), Eq (CategoryTheory.CategoryStruct.comp (t✝ i j hij) (t✝ j i ⋯)) (CategoryTheory.CategoryStruct.id (V✝ i j hij))\ncocycle✝ : ∀ (i j k : J✝) (hij : Ne i j) (hik : Ne i k) (hjk : Ne j k), Eq (CategoryTheory.CategoryStruct.comp (t'✝ i j k hij hik hjk) (CategoryTheory.CategoryStruct.comp (t'✝ j k i hjk ⋯ ⋯) (t'✝ k i j ⋯ ⋯ hij))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback (f✝ i j hij) (f✝ i k hik)))\nJ : Type v\nU : J → C\nV : (i j : J) → Ne i j → C\nf : (i j : J) → (h : Ne i j) → Quiver.Hom (V i j h) (U i)\nf_mono : autoParam (∀ (i j : J) (h : Ne i j), CategoryTheory.Mono (f i j h)) _auto✝\nf_hasPullback : autoParam (∀ (i j k : J) (hij : Ne i j) (hik : Ne i k), CategoryTheory.Limits.HasPullback (f i j hij) (f i k hik)) _auto✝\nt : (i j : J) → (h : Ne i j) → Quiver.Hom (V i j h) (V j i ⋯)\nt' : (i j k : J) → (hij : Ne i j) → (hik : Ne i k) → (hjk : Ne j k) → Quiver.Hom (CategoryTheory.Limits.pullback (f i j hij) (f i k hik)) (CategoryTheory.Limits.pullback (f j k hjk) (f j i ⋯))\nt_fac : ∀ (i j k : J) (hij : Ne i j) (hik : Ne i k) (hjk : Ne j k), Eq (CategoryTheory.CategoryStruct.comp (t' i j k hij hik hjk) (CategoryTheory.Limits.pullback.snd (f j k hjk) (f j i ⋯))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (f i j hij) (f i k hik)) (t i j hij))\nt_inv : ∀ (i j : J) (hij : Ne i j), Eq (CategoryTheory.CategoryStruct.comp (t i j hij) (t j i ⋯)) (CategoryTheory.CategoryStruct.id (V i j hij))\ncocycle : ∀ (i j k : J) (hij : Ne i j) (hik : Ne i k) (hjk : Ne j k), Eq (CategoryTheory.CategoryStruct.comp (t' i j k hij hik hjk) (CategoryTheory.CategoryStruct.comp (t' j k i hjk ⋯ ⋯) (t' k i j ⋯ ⋯ hij))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback (f i j hij) (f i k hik)))\n⊢ Eq (Eq { J := J✝, U := U✝, V := V✝, f := f✝, f_mono := f_mono✝, f_hasPullback := f_hasPullback✝, t := t✝, t' := t'✝, t_fac := t_fac✝, t_inv := t_inv✝, cocycle := cocycle✝ } { J := J, U := U, V := V, f := f, f_mono := f_mono, f_hasPullback := f_hasPullback, t := t, t' := t', t_fac := t_fac, t_inv := t_inv, cocycle := cocycle }) (And (Eq J✝ J) (And (HEq U✝ U) (And (HEq V✝ V) (And (HEq f✝ f) (And (HEq t✝ t) (HEq t'✝ t'))))))","decl":"/--\nThis is a variant of `GlueData` that only requires conditions on `V (i, j)` when `i ≠ j`.\nSee `GlueData.ofGlueData'`\n-/\nstructure GlueData' where\n  /-- Indexing type of a glue data. -/\n  J : Type v\n  /-- Objects of a glue data to be glued. -/\n  U : J → C\n  /-- Objects representing the intersections. -/\n  V : ∀ (i j : J), i ≠ j → C\n  /-- The inclusion maps of the intersection into the object. -/\n  f : ∀ i j h, V i j h ⟶ U i\n  f_mono : ∀ i j h, Mono (f i j h) := by infer_instance\n  f_hasPullback : ∀ i j k hij hik, HasPullback (f i j hij) (f i k hik) := by infer_instance\n  /-- The transition maps between the intersections. -/\n  t : ∀ i j h, V i j h ⟶ V j i h.symm\n  /-- The transition maps between the intersection of intersections. -/\n  t' : ∀ i j k hij hik hjk,\n    pullback (f i j hij) (f i k hik) ⟶ pullback (f j k hjk) (f j i hij.symm)\n  t_fac : ∀ i j k hij hik hjk, t' i j k hij hik hjk ≫ pullback.snd _ _ =\n    pullback.fst _ _ ≫ t i j hij\n  t_inv : ∀ i j hij, t i j hij ≫ t j i hij.symm = 𝟙 _\n  cocycle : ∀ i j k hij hik hjk, t' i j k hij hik hjk ≫\n    t' j k i hjk hij.symm hik.symm ≫ t' k i j hik.symm hjk.symm hij = 𝟙 _\n\n"}
{"name":"CategoryTheory.GlueData'.f_mono","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nself : CategoryTheory.GlueData' C\ni j : self.J\nh : Ne i j\n⊢ CategoryTheory.Mono (self.f i j h)","decl":"/--\nThis is a variant of `GlueData` that only requires conditions on `V (i, j)` when `i ≠ j`.\nSee `GlueData.ofGlueData'`\n-/\nstructure GlueData' where\n  /-- Indexing type of a glue data. -/\n  J : Type v\n  /-- Objects of a glue data to be glued. -/\n  U : J → C\n  /-- Objects representing the intersections. -/\n  V : ∀ (i j : J), i ≠ j → C\n  /-- The inclusion maps of the intersection into the object. -/\n  f : ∀ i j h, V i j h ⟶ U i\n  f_mono : ∀ i j h, Mono (f i j h) := by infer_instance\n  f_hasPullback : ∀ i j k hij hik, HasPullback (f i j hij) (f i k hik) := by infer_instance\n  /-- The transition maps between the intersections. -/\n  t : ∀ i j h, V i j h ⟶ V j i h.symm\n  /-- The transition maps between the intersection of intersections. -/\n  t' : ∀ i j k hij hik hjk,\n    pullback (f i j hij) (f i k hik) ⟶ pullback (f j k hjk) (f j i hij.symm)\n  t_fac : ∀ i j k hij hik hjk, t' i j k hij hik hjk ≫ pullback.snd _ _ =\n    pullback.fst _ _ ≫ t i j hij\n  t_inv : ∀ i j hij, t i j hij ≫ t j i hij.symm = 𝟙 _\n  cocycle : ∀ i j k hij hik hjk, t' i j k hij hik hjk ≫\n    t' j k i hjk hij.symm hik.symm ≫ t' k i j hik.symm hjk.symm hij = 𝟙 _\n\n"}
{"name":"CategoryTheory.GlueData'.f_hasPullback","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nself : CategoryTheory.GlueData' C\ni j k : self.J\nhij : Ne i j\nhik : Ne i k\n⊢ CategoryTheory.Limits.HasPullback (self.f i j hij) (self.f i k hik)","decl":"/--\nThis is a variant of `GlueData` that only requires conditions on `V (i, j)` when `i ≠ j`.\nSee `GlueData.ofGlueData'`\n-/\nstructure GlueData' where\n  /-- Indexing type of a glue data. -/\n  J : Type v\n  /-- Objects of a glue data to be glued. -/\n  U : J → C\n  /-- Objects representing the intersections. -/\n  V : ∀ (i j : J), i ≠ j → C\n  /-- The inclusion maps of the intersection into the object. -/\n  f : ∀ i j h, V i j h ⟶ U i\n  f_mono : ∀ i j h, Mono (f i j h) := by infer_instance\n  f_hasPullback : ∀ i j k hij hik, HasPullback (f i j hij) (f i k hik) := by infer_instance\n  /-- The transition maps between the intersections. -/\n  t : ∀ i j h, V i j h ⟶ V j i h.symm\n  /-- The transition maps between the intersection of intersections. -/\n  t' : ∀ i j k hij hik hjk,\n    pullback (f i j hij) (f i k hik) ⟶ pullback (f j k hjk) (f j i hij.symm)\n  t_fac : ∀ i j k hij hik hjk, t' i j k hij hik hjk ≫ pullback.snd _ _ =\n    pullback.fst _ _ ≫ t i j hij\n  t_inv : ∀ i j hij, t i j hij ≫ t j i hij.symm = 𝟙 _\n  cocycle : ∀ i j k hij hik hjk, t' i j k hij hik hjk ≫\n    t' j k i hjk hij.symm hik.symm ≫ t' k i j hik.symm hjk.symm hij = 𝟙 _\n\n"}
{"name":"CategoryTheory.GlueData'.cocycle","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nself : CategoryTheory.GlueData' C\ni j k : self.J\nhij : Ne i j\nhik : Ne i k\nhjk : Ne j k\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.t' i j k hij hik hjk) (CategoryTheory.CategoryStruct.comp (self.t' j k i hjk ⋯ ⋯) (self.t' k i j ⋯ ⋯ hij))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback (self.f i j hij) (self.f i k hik)))","decl":"/--\nThis is a variant of `GlueData` that only requires conditions on `V (i, j)` when `i ≠ j`.\nSee `GlueData.ofGlueData'`\n-/\nstructure GlueData' where\n  /-- Indexing type of a glue data. -/\n  J : Type v\n  /-- Objects of a glue data to be glued. -/\n  U : J → C\n  /-- Objects representing the intersections. -/\n  V : ∀ (i j : J), i ≠ j → C\n  /-- The inclusion maps of the intersection into the object. -/\n  f : ∀ i j h, V i j h ⟶ U i\n  f_mono : ∀ i j h, Mono (f i j h) := by infer_instance\n  f_hasPullback : ∀ i j k hij hik, HasPullback (f i j hij) (f i k hik) := by infer_instance\n  /-- The transition maps between the intersections. -/\n  t : ∀ i j h, V i j h ⟶ V j i h.symm\n  /-- The transition maps between the intersection of intersections. -/\n  t' : ∀ i j k hij hik hjk,\n    pullback (f i j hij) (f i k hik) ⟶ pullback (f j k hjk) (f j i hij.symm)\n  t_fac : ∀ i j k hij hik hjk, t' i j k hij hik hjk ≫ pullback.snd _ _ =\n    pullback.fst _ _ ≫ t i j hij\n  t_inv : ∀ i j hij, t i j hij ≫ t j i hij.symm = 𝟙 _\n  cocycle : ∀ i j k hij hik hjk, t' i j k hij hik hjk ≫\n    t' j k i hjk hij.symm hik.symm ≫ t' k i j hik.symm hjk.symm hij = 𝟙 _\n\n"}
{"name":"CategoryTheory.GlueData'.t_inv","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nself : CategoryTheory.GlueData' C\ni j : self.J\nhij : Ne i j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.t i j hij) (self.t j i ⋯)) (CategoryTheory.CategoryStruct.id (self.V i j hij))","decl":"/--\nThis is a variant of `GlueData` that only requires conditions on `V (i, j)` when `i ≠ j`.\nSee `GlueData.ofGlueData'`\n-/\nstructure GlueData' where\n  /-- Indexing type of a glue data. -/\n  J : Type v\n  /-- Objects of a glue data to be glued. -/\n  U : J → C\n  /-- Objects representing the intersections. -/\n  V : ∀ (i j : J), i ≠ j → C\n  /-- The inclusion maps of the intersection into the object. -/\n  f : ∀ i j h, V i j h ⟶ U i\n  f_mono : ∀ i j h, Mono (f i j h) := by infer_instance\n  f_hasPullback : ∀ i j k hij hik, HasPullback (f i j hij) (f i k hik) := by infer_instance\n  /-- The transition maps between the intersections. -/\n  t : ∀ i j h, V i j h ⟶ V j i h.symm\n  /-- The transition maps between the intersection of intersections. -/\n  t' : ∀ i j k hij hik hjk,\n    pullback (f i j hij) (f i k hik) ⟶ pullback (f j k hjk) (f j i hij.symm)\n  t_fac : ∀ i j k hij hik hjk, t' i j k hij hik hjk ≫ pullback.snd _ _ =\n    pullback.fst _ _ ≫ t i j hij\n  t_inv : ∀ i j hij, t i j hij ≫ t j i hij.symm = 𝟙 _\n  cocycle : ∀ i j k hij hik hjk, t' i j k hij hik hjk ≫\n    t' j k i hjk hij.symm hik.symm ≫ t' k i j hik.symm hjk.symm hij = 𝟙 _\n\n"}
{"name":"CategoryTheory.GlueData'.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v, u₁} C\ninst✝ : SizeOf C\nJ : Type v\nU : J → C\nV : (i j : J) → Ne i j → C\nf : (i j : J) → (h : Ne i j) → Quiver.Hom (V i j h) (U i)\nf_mono : autoParam (∀ (i j : J) (h : Ne i j), CategoryTheory.Mono (f i j h)) _auto✝\nf_hasPullback : autoParam (∀ (i j k : J) (hij : Ne i j) (hik : Ne i k), CategoryTheory.Limits.HasPullback (f i j hij) (f i k hik)) _auto✝\nt : (i j : J) → (h : Ne i j) → Quiver.Hom (V i j h) (V j i ⋯)\nt' : (i j k : J) → (hij : Ne i j) → (hik : Ne i k) → (hjk : Ne j k) → Quiver.Hom (CategoryTheory.Limits.pullback (f i j hij) (f i k hik)) (CategoryTheory.Limits.pullback (f j k hjk) (f j i ⋯))\nt_fac : ∀ (i j k : J) (hij : Ne i j) (hik : Ne i k) (hjk : Ne j k), Eq (CategoryTheory.CategoryStruct.comp (t' i j k hij hik hjk) (CategoryTheory.Limits.pullback.snd (f j k hjk) (f j i ⋯))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (f i j hij) (f i k hik)) (t i j hij))\nt_inv : ∀ (i j : J) (hij : Ne i j), Eq (CategoryTheory.CategoryStruct.comp (t i j hij) (t j i ⋯)) (CategoryTheory.CategoryStruct.id (V i j hij))\ncocycle : ∀ (i j k : J) (hij : Ne i j) (hik : Ne i k) (hjk : Ne j k), Eq (CategoryTheory.CategoryStruct.comp (t' i j k hij hik hjk) (CategoryTheory.CategoryStruct.comp (t' j k i hjk ⋯ ⋯) (t' k i j ⋯ ⋯ hij))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback (f i j hij) (f i k hik)))\n⊢ Eq (SizeOf.sizeOf { J := J, U := U, V := V, f := f, f_mono := f_mono, f_hasPullback := f_hasPullback, t := t, t' := t', t_fac := t_fac, t_inv := t_inv, cocycle := cocycle }) (HAdd.hAdd 1 (SizeOf.sizeOf J))","decl":"/--\nThis is a variant of `GlueData` that only requires conditions on `V (i, j)` when `i ≠ j`.\nSee `GlueData.ofGlueData'`\n-/\nstructure GlueData' where\n  /-- Indexing type of a glue data. -/\n  J : Type v\n  /-- Objects of a glue data to be glued. -/\n  U : J → C\n  /-- Objects representing the intersections. -/\n  V : ∀ (i j : J), i ≠ j → C\n  /-- The inclusion maps of the intersection into the object. -/\n  f : ∀ i j h, V i j h ⟶ U i\n  f_mono : ∀ i j h, Mono (f i j h) := by infer_instance\n  f_hasPullback : ∀ i j k hij hik, HasPullback (f i j hij) (f i k hik) := by infer_instance\n  /-- The transition maps between the intersections. -/\n  t : ∀ i j h, V i j h ⟶ V j i h.symm\n  /-- The transition maps between the intersection of intersections. -/\n  t' : ∀ i j k hij hik hjk,\n    pullback (f i j hij) (f i k hik) ⟶ pullback (f j k hjk) (f j i hij.symm)\n  t_fac : ∀ i j k hij hik hjk, t' i j k hij hik hjk ≫ pullback.snd _ _ =\n    pullback.fst _ _ ≫ t i j hij\n  t_inv : ∀ i j hij, t i j hij ≫ t j i hij.symm = 𝟙 _\n  cocycle : ∀ i j k hij hik hjk, t' i j k hij hik hjk ≫\n    t' j k i hjk hij.symm hik.symm ≫ t' k i j hik.symm hjk.symm hij = 𝟙 _\n\n"}
{"name":"CategoryTheory.GlueData'.t_fac","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nself : CategoryTheory.GlueData' C\ni j k : self.J\nhij : Ne i j\nhik : Ne i k\nhjk : Ne j k\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.t' i j k hij hik hjk) (CategoryTheory.Limits.pullback.snd (self.f j k hjk) (self.f j i ⋯))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (self.f i j hij) (self.f i k hik)) (self.t i j hij))","decl":"/--\nThis is a variant of `GlueData` that only requires conditions on `V (i, j)` when `i ≠ j`.\nSee `GlueData.ofGlueData'`\n-/\nstructure GlueData' where\n  /-- Indexing type of a glue data. -/\n  J : Type v\n  /-- Objects of a glue data to be glued. -/\n  U : J → C\n  /-- Objects representing the intersections. -/\n  V : ∀ (i j : J), i ≠ j → C\n  /-- The inclusion maps of the intersection into the object. -/\n  f : ∀ i j h, V i j h ⟶ U i\n  f_mono : ∀ i j h, Mono (f i j h) := by infer_instance\n  f_hasPullback : ∀ i j k hij hik, HasPullback (f i j hij) (f i k hik) := by infer_instance\n  /-- The transition maps between the intersections. -/\n  t : ∀ i j h, V i j h ⟶ V j i h.symm\n  /-- The transition maps between the intersection of intersections. -/\n  t' : ∀ i j k hij hik hjk,\n    pullback (f i j hij) (f i k hik) ⟶ pullback (f j k hjk) (f j i hij.symm)\n  t_fac : ∀ i j k hij hik hjk, t' i j k hij hik hjk ≫ pullback.snd _ _ =\n    pullback.fst _ _ ≫ t i j hij\n  t_inv : ∀ i j hij, t i j hij ≫ t j i hij.symm = 𝟙 _\n  cocycle : ∀ i j k hij hik hjk, t' i j k hij hik hjk ≫\n    t' j k i hjk hij.symm hik.symm ≫ t' k i j hik.symm hjk.symm hij = 𝟙 _\n\n"}
{"name":"CategoryTheory.GlueData'.cocycle_assoc","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nself : CategoryTheory.GlueData' C\ni j k : self.J\nhij : Ne i j\nhik : Ne i k\nhjk : Ne j k\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pullback (self.f i j hij) (self.f i k ⋯)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.t' i j k hij hik hjk) (CategoryTheory.CategoryStruct.comp (self.t' j k i hjk ⋯ ⋯) (CategoryTheory.CategoryStruct.comp (self.t' k i j ⋯ ⋯ hij) h))) h","decl":"attribute [reassoc (attr := simp)] GlueData'.t_inv GlueData'.cocycle\n\n"}
{"name":"CategoryTheory.GlueData'.t_inv_assoc","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nself : CategoryTheory.GlueData' C\ni j : self.J\nhij : Ne i j\nZ : C\nh : Quiver.Hom (self.V i j ⋯) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.t i j hij) (CategoryTheory.CategoryStruct.comp (self.t j i ⋯) h)) h","decl":"attribute [reassoc (attr := simp)] GlueData'.t_inv GlueData'.cocycle\n\n"}
{"name":"CategoryTheory.instMonoF'","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nD : CategoryTheory.GlueData' C\ni j : D.J\n⊢ CategoryTheory.Mono (D.f' i j)","decl":"instance (D : GlueData' C) (i j : D.J) :\n    Mono (D.f' i j) := by dsimp [GlueData'.f']; split_ifs <;> infer_instance\n\n"}
{"name":"CategoryTheory.instIsIsoF'","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nD : CategoryTheory.GlueData' C\ni : D.J\n⊢ CategoryTheory.IsIso (D.f' i i)","decl":"instance (D : GlueData' C) (i : D.J) :\n    IsIso (D.f' i i) := by simp only [GlueData'.f', ↓reduceDIte]; infer_instance\n\n"}
{"name":"CategoryTheory.instHasPullbackF'","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v, u₁} C\nD : CategoryTheory.GlueData' C\ni j k : D.J\n⊢ CategoryTheory.Limits.HasPullback (D.f' i j) (D.f' i k)","decl":"instance (D : GlueData' C) (i j k : D.J) :\n    HasPullback (D.f' i j) (D.f' i k) := by\n  if hij : i = j then\n    apply (config := { allowSynthFailures := true}) hasPullback_of_left_iso\n    simp only [GlueData'.f', dif_pos hij]\n    infer_instance\n  else if hik : i = k then\n    apply (config := { allowSynthFailures := true}) hasPullback_of_right_iso\n    simp only [GlueData'.f', dif_pos hik]\n    infer_instance\n  else\n    have {X Y Z : C} (f : X ⟶ Y) (e : Z = X) : HEq (eqToHom e ≫ f) f := by subst e; simp\n    convert D.f_hasPullback i j k hij hik <;> simp [GlueData'.f', hij, hik, this]\n\n"}
