{"name":"CategoryTheory.GlueData.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v, u‚ÇÅ} C\ninst‚úù : SizeOf C\nJ : Type v\nU : J ‚Üí C\nV : Prod J J ‚Üí C\nf : (i j : J) ‚Üí Quiver.Hom (V { fst := i, snd := j }) (U i)\nf_mono : autoParam (‚àÄ (i j : J), CategoryTheory.Mono (f i j)) _auto‚úù\nf_hasPullback : autoParam (‚àÄ (i j k : J), CategoryTheory.Limits.HasPullback (f i j) (f i k)) _auto‚úù\nf_id : autoParam (‚àÄ (i : J), CategoryTheory.IsIso (f i i)) _auto‚úù\nt : (i j : J) ‚Üí Quiver.Hom (V { fst := i, snd := j }) (V { fst := j, snd := i })\nt_id : ‚àÄ (i : J), Eq (t i i) (CategoryTheory.CategoryStruct.id (V { fst := i, snd := i }))\nt' : (i j k : J) ‚Üí Quiver.Hom (CategoryTheory.Limits.pullback (f i j) (f i k)) (CategoryTheory.Limits.pullback (f j k) (f j i))\nt_fac : ‚àÄ (i j k : J), Eq (CategoryTheory.CategoryStruct.comp (t' i j k) (CategoryTheory.Limits.pullback.snd (f j k) (f j i))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (f i j) (f i k)) (t i j))\ncocycle : ‚àÄ (i j k : J), Eq (CategoryTheory.CategoryStruct.comp (t' i j k) (CategoryTheory.CategoryStruct.comp (t' j k i) (t' k i j))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback (f i j) (f i k)))\n‚ä¢ Eq (SizeOf.sizeOf { J := J, U := U, V := V, f := f, f_mono := f_mono, f_hasPullback := f_hasPullback, f_id := f_id, t := t, t_id := t_id, t' := t', t_fac := t_fac, cocycle := cocycle }) (HAdd.hAdd 1 (SizeOf.sizeOf J))","decl":"/-- A gluing datum consists of\n1. An index type `J`\n2. An object `U i` for each `i : J`.\n3. An object `V i j` for each `i j : J`.\n4. A monomorphism `f i j : V i j ‚ü∂ U i` for each `i j : J`.\n5. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : J`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. The pullback for `f i j` and `f i k` exists.\n9. `V i j √ó[U i] V i k ‚ü∂ V i j ‚ü∂ V j i` factors through `V j k √ó[U j] V j i ‚ü∂ V j i` via some\n    `t' : V i j √ó[U i] V i k ‚ü∂ V j k √ó[U j] V j i`.\n10. `t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _`.\n-/\nstructure GlueData where\n  J : Type v\n  U : J ‚Üí C\n  V : J √ó J ‚Üí C\n  f : ‚àÄ i j, V (i, j) ‚ü∂ U i\n  f_mono : ‚àÄ i j, Mono (f i j) := by infer_instance\n  f_hasPullback : ‚àÄ i j k, HasPullback (f i j) (f i k) := by infer_instance\n  f_id : ‚àÄ i, IsIso (f i i) := by infer_instance\n  t : ‚àÄ i j, V (i, j) ‚ü∂ V (j, i)\n  t_id : ‚àÄ i, t i i = ùüô _\n  t' : ‚àÄ i j k, pullback (f i j) (f i k) ‚ü∂ pullback (f j k) (f j i)\n  t_fac : ‚àÄ i j k, t' i j k ‚â´ pullback.snd _ _ = pullback.fst _ _ ‚â´ t i j\n  cocycle : ‚àÄ i j k, t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _\n\n"}
{"name":"CategoryTheory.GlueData.f_mono","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nself : CategoryTheory.GlueData C\ni j : self.J\n‚ä¢ CategoryTheory.Mono (self.f i j)","decl":"/-- A gluing datum consists of\n1. An index type `J`\n2. An object `U i` for each `i : J`.\n3. An object `V i j` for each `i j : J`.\n4. A monomorphism `f i j : V i j ‚ü∂ U i` for each `i j : J`.\n5. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : J`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. The pullback for `f i j` and `f i k` exists.\n9. `V i j √ó[U i] V i k ‚ü∂ V i j ‚ü∂ V j i` factors through `V j k √ó[U j] V j i ‚ü∂ V j i` via some\n    `t' : V i j √ó[U i] V i k ‚ü∂ V j k √ó[U j] V j i`.\n10. `t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _`.\n-/\nstructure GlueData where\n  J : Type v\n  U : J ‚Üí C\n  V : J √ó J ‚Üí C\n  f : ‚àÄ i j, V (i, j) ‚ü∂ U i\n  f_mono : ‚àÄ i j, Mono (f i j) := by infer_instance\n  f_hasPullback : ‚àÄ i j k, HasPullback (f i j) (f i k) := by infer_instance\n  f_id : ‚àÄ i, IsIso (f i i) := by infer_instance\n  t : ‚àÄ i j, V (i, j) ‚ü∂ V (j, i)\n  t_id : ‚àÄ i, t i i = ùüô _\n  t' : ‚àÄ i j k, pullback (f i j) (f i k) ‚ü∂ pullback (f j k) (f j i)\n  t_fac : ‚àÄ i j k, t' i j k ‚â´ pullback.snd _ _ = pullback.fst _ _ ‚â´ t i j\n  cocycle : ‚àÄ i j k, t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _\n\n"}
{"name":"CategoryTheory.GlueData.f_hasPullback","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nself : CategoryTheory.GlueData C\ni j k : self.J\n‚ä¢ CategoryTheory.Limits.HasPullback (self.f i j) (self.f i k)","decl":"/-- A gluing datum consists of\n1. An index type `J`\n2. An object `U i` for each `i : J`.\n3. An object `V i j` for each `i j : J`.\n4. A monomorphism `f i j : V i j ‚ü∂ U i` for each `i j : J`.\n5. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : J`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. The pullback for `f i j` and `f i k` exists.\n9. `V i j √ó[U i] V i k ‚ü∂ V i j ‚ü∂ V j i` factors through `V j k √ó[U j] V j i ‚ü∂ V j i` via some\n    `t' : V i j √ó[U i] V i k ‚ü∂ V j k √ó[U j] V j i`.\n10. `t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _`.\n-/\nstructure GlueData where\n  J : Type v\n  U : J ‚Üí C\n  V : J √ó J ‚Üí C\n  f : ‚àÄ i j, V (i, j) ‚ü∂ U i\n  f_mono : ‚àÄ i j, Mono (f i j) := by infer_instance\n  f_hasPullback : ‚àÄ i j k, HasPullback (f i j) (f i k) := by infer_instance\n  f_id : ‚àÄ i, IsIso (f i i) := by infer_instance\n  t : ‚àÄ i j, V (i, j) ‚ü∂ V (j, i)\n  t_id : ‚àÄ i, t i i = ùüô _\n  t' : ‚àÄ i j k, pullback (f i j) (f i k) ‚ü∂ pullback (f j k) (f j i)\n  t_fac : ‚àÄ i j k, t' i j k ‚â´ pullback.snd _ _ = pullback.fst _ _ ‚â´ t i j\n  cocycle : ‚àÄ i j k, t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _\n\n"}
{"name":"CategoryTheory.GlueData.f_id","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nself : CategoryTheory.GlueData C\ni : self.J\n‚ä¢ CategoryTheory.IsIso (self.f i i)","decl":"/-- A gluing datum consists of\n1. An index type `J`\n2. An object `U i` for each `i : J`.\n3. An object `V i j` for each `i j : J`.\n4. A monomorphism `f i j : V i j ‚ü∂ U i` for each `i j : J`.\n5. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : J`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. The pullback for `f i j` and `f i k` exists.\n9. `V i j √ó[U i] V i k ‚ü∂ V i j ‚ü∂ V j i` factors through `V j k √ó[U j] V j i ‚ü∂ V j i` via some\n    `t' : V i j √ó[U i] V i k ‚ü∂ V j k √ó[U j] V j i`.\n10. `t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _`.\n-/\nstructure GlueData where\n  J : Type v\n  U : J ‚Üí C\n  V : J √ó J ‚Üí C\n  f : ‚àÄ i j, V (i, j) ‚ü∂ U i\n  f_mono : ‚àÄ i j, Mono (f i j) := by infer_instance\n  f_hasPullback : ‚àÄ i j k, HasPullback (f i j) (f i k) := by infer_instance\n  f_id : ‚àÄ i, IsIso (f i i) := by infer_instance\n  t : ‚àÄ i j, V (i, j) ‚ü∂ V (j, i)\n  t_id : ‚àÄ i, t i i = ùüô _\n  t' : ‚àÄ i j k, pullback (f i j) (f i k) ‚ü∂ pullback (f j k) (f j i)\n  t_fac : ‚àÄ i j k, t' i j k ‚â´ pullback.snd _ _ = pullback.fst _ _ ‚â´ t i j\n  cocycle : ‚àÄ i j k, t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _\n\n"}
{"name":"CategoryTheory.GlueData.cocycle","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nself : CategoryTheory.GlueData C\ni j k : self.J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.t' i j k) (CategoryTheory.CategoryStruct.comp (self.t' j k i) (self.t' k i j))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback (self.f i j) (self.f i k)))","decl":"/-- A gluing datum consists of\n1. An index type `J`\n2. An object `U i` for each `i : J`.\n3. An object `V i j` for each `i j : J`.\n4. A monomorphism `f i j : V i j ‚ü∂ U i` for each `i j : J`.\n5. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : J`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. The pullback for `f i j` and `f i k` exists.\n9. `V i j √ó[U i] V i k ‚ü∂ V i j ‚ü∂ V j i` factors through `V j k √ó[U j] V j i ‚ü∂ V j i` via some\n    `t' : V i j √ó[U i] V i k ‚ü∂ V j k √ó[U j] V j i`.\n10. `t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _`.\n-/\nstructure GlueData where\n  J : Type v\n  U : J ‚Üí C\n  V : J √ó J ‚Üí C\n  f : ‚àÄ i j, V (i, j) ‚ü∂ U i\n  f_mono : ‚àÄ i j, Mono (f i j) := by infer_instance\n  f_hasPullback : ‚àÄ i j k, HasPullback (f i j) (f i k) := by infer_instance\n  f_id : ‚àÄ i, IsIso (f i i) := by infer_instance\n  t : ‚àÄ i j, V (i, j) ‚ü∂ V (j, i)\n  t_id : ‚àÄ i, t i i = ùüô _\n  t' : ‚àÄ i j k, pullback (f i j) (f i k) ‚ü∂ pullback (f j k) (f j i)\n  t_fac : ‚àÄ i j k, t' i j k ‚â´ pullback.snd _ _ = pullback.fst _ _ ‚â´ t i j\n  cocycle : ‚àÄ i j k, t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _\n\n"}
{"name":"CategoryTheory.GlueData.t_fac","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nself : CategoryTheory.GlueData C\ni j k : self.J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.t' i j k) (CategoryTheory.Limits.pullback.snd (self.f j k) (self.f j i))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (self.f i j) (self.f i k)) (self.t i j))","decl":"/-- A gluing datum consists of\n1. An index type `J`\n2. An object `U i` for each `i : J`.\n3. An object `V i j` for each `i j : J`.\n4. A monomorphism `f i j : V i j ‚ü∂ U i` for each `i j : J`.\n5. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : J`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. The pullback for `f i j` and `f i k` exists.\n9. `V i j √ó[U i] V i k ‚ü∂ V i j ‚ü∂ V j i` factors through `V j k √ó[U j] V j i ‚ü∂ V j i` via some\n    `t' : V i j √ó[U i] V i k ‚ü∂ V j k √ó[U j] V j i`.\n10. `t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _`.\n-/\nstructure GlueData where\n  J : Type v\n  U : J ‚Üí C\n  V : J √ó J ‚Üí C\n  f : ‚àÄ i j, V (i, j) ‚ü∂ U i\n  f_mono : ‚àÄ i j, Mono (f i j) := by infer_instance\n  f_hasPullback : ‚àÄ i j k, HasPullback (f i j) (f i k) := by infer_instance\n  f_id : ‚àÄ i, IsIso (f i i) := by infer_instance\n  t : ‚àÄ i j, V (i, j) ‚ü∂ V (j, i)\n  t_id : ‚àÄ i, t i i = ùüô _\n  t' : ‚àÄ i j k, pullback (f i j) (f i k) ‚ü∂ pullback (f j k) (f j i)\n  t_fac : ‚àÄ i j k, t' i j k ‚â´ pullback.snd _ _ = pullback.fst _ _ ‚â´ t i j\n  cocycle : ‚àÄ i j k, t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _\n\n"}
{"name":"CategoryTheory.GlueData.t_id","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nself : CategoryTheory.GlueData C\ni : self.J\n‚ä¢ Eq (self.t i i) (CategoryTheory.CategoryStruct.id (self.V { fst := i, snd := i }))","decl":"/-- A gluing datum consists of\n1. An index type `J`\n2. An object `U i` for each `i : J`.\n3. An object `V i j` for each `i j : J`.\n4. A monomorphism `f i j : V i j ‚ü∂ U i` for each `i j : J`.\n5. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : J`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. The pullback for `f i j` and `f i k` exists.\n9. `V i j √ó[U i] V i k ‚ü∂ V i j ‚ü∂ V j i` factors through `V j k √ó[U j] V j i ‚ü∂ V j i` via some\n    `t' : V i j √ó[U i] V i k ‚ü∂ V j k √ó[U j] V j i`.\n10. `t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _`.\n-/\nstructure GlueData where\n  J : Type v\n  U : J ‚Üí C\n  V : J √ó J ‚Üí C\n  f : ‚àÄ i j, V (i, j) ‚ü∂ U i\n  f_mono : ‚àÄ i j, Mono (f i j) := by infer_instance\n  f_hasPullback : ‚àÄ i j k, HasPullback (f i j) (f i k) := by infer_instance\n  f_id : ‚àÄ i, IsIso (f i i) := by infer_instance\n  t : ‚àÄ i j, V (i, j) ‚ü∂ V (j, i)\n  t_id : ‚àÄ i, t i i = ùüô _\n  t' : ‚àÄ i j k, pullback (f i j) (f i k) ‚ü∂ pullback (f j k) (f j i)\n  t_fac : ‚àÄ i j k, t' i j k ‚â´ pullback.snd _ _ = pullback.fst _ _ ‚â´ t i j\n  cocycle : ‚àÄ i j k, t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _\n\n"}
{"name":"CategoryTheory.GlueData.mk.inj","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nJ‚úù : Type v\nU‚úù : J‚úù ‚Üí C\nV‚úù : Prod J‚úù J‚úù ‚Üí C\nf‚úù : (i j : J‚úù) ‚Üí Quiver.Hom (V‚úù { fst := i, snd := j }) (U‚úù i)\nf_mono‚úù : autoParam (‚àÄ (i j : J‚úù), CategoryTheory.Mono (f‚úù i j)) _auto‚úù\nf_hasPullback‚úù : autoParam (‚àÄ (i j k : J‚úù), CategoryTheory.Limits.HasPullback (f‚úù i j) (f‚úù i k)) _auto‚úù\nf_id‚úù : autoParam (‚àÄ (i : J‚úù), CategoryTheory.IsIso (f‚úù i i)) _auto‚úù\nt‚úù : (i j : J‚úù) ‚Üí Quiver.Hom (V‚úù { fst := i, snd := j }) (V‚úù { fst := j, snd := i })\nt_id‚úù : ‚àÄ (i : J‚úù), Eq (t‚úù i i) (CategoryTheory.CategoryStruct.id (V‚úù { fst := i, snd := i }))\nt'‚úù : (i j k : J‚úù) ‚Üí Quiver.Hom (CategoryTheory.Limits.pullback (f‚úù i j) (f‚úù i k)) (CategoryTheory.Limits.pullback (f‚úù j k) (f‚úù j i))\nt_fac‚úù : ‚àÄ (i j k : J‚úù), Eq (CategoryTheory.CategoryStruct.comp (t'‚úù i j k) (CategoryTheory.Limits.pullback.snd (f‚úù j k) (f‚úù j i))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (f‚úù i j) (f‚úù i k)) (t‚úù i j))\ncocycle‚úù : ‚àÄ (i j k : J‚úù), Eq (CategoryTheory.CategoryStruct.comp (t'‚úù i j k) (CategoryTheory.CategoryStruct.comp (t'‚úù j k i) (t'‚úù k i j))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback (f‚úù i j) (f‚úù i k)))\nJ : Type v\nU : J ‚Üí C\nV : Prod J J ‚Üí C\nf : (i j : J) ‚Üí Quiver.Hom (V { fst := i, snd := j }) (U i)\nf_mono : autoParam (‚àÄ (i j : J), CategoryTheory.Mono (f i j)) _auto‚úù\nf_hasPullback : autoParam (‚àÄ (i j k : J), CategoryTheory.Limits.HasPullback (f i j) (f i k)) _auto‚úù\nf_id : autoParam (‚àÄ (i : J), CategoryTheory.IsIso (f i i)) _auto‚úù\nt : (i j : J) ‚Üí Quiver.Hom (V { fst := i, snd := j }) (V { fst := j, snd := i })\nt_id : ‚àÄ (i : J), Eq (t i i) (CategoryTheory.CategoryStruct.id (V { fst := i, snd := i }))\nt' : (i j k : J) ‚Üí Quiver.Hom (CategoryTheory.Limits.pullback (f i j) (f i k)) (CategoryTheory.Limits.pullback (f j k) (f j i))\nt_fac : ‚àÄ (i j k : J), Eq (CategoryTheory.CategoryStruct.comp (t' i j k) (CategoryTheory.Limits.pullback.snd (f j k) (f j i))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (f i j) (f i k)) (t i j))\ncocycle : ‚àÄ (i j k : J), Eq (CategoryTheory.CategoryStruct.comp (t' i j k) (CategoryTheory.CategoryStruct.comp (t' j k i) (t' k i j))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback (f i j) (f i k)))\nx‚úù : Eq { J := J‚úù, U := U‚úù, V := V‚úù, f := f‚úù, f_mono := f_mono‚úù, f_hasPullback := f_hasPullback‚úù, f_id := f_id‚úù, t := t‚úù, t_id := t_id‚úù, t' := t'‚úù, t_fac := t_fac‚úù, cocycle := cocycle‚úù } { J := J, U := U, V := V, f := f, f_mono := f_mono, f_hasPullback := f_hasPullback, f_id := f_id, t := t, t_id := t_id, t' := t', t_fac := t_fac, cocycle := cocycle }\n‚ä¢ And (Eq J‚úù J) (And (HEq U‚úù U) (And (HEq V‚úù V) (And (HEq f‚úù f) (And (HEq t‚úù t) (HEq t'‚úù t')))))","decl":"/-- A gluing datum consists of\n1. An index type `J`\n2. An object `U i` for each `i : J`.\n3. An object `V i j` for each `i j : J`.\n4. A monomorphism `f i j : V i j ‚ü∂ U i` for each `i j : J`.\n5. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : J`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. The pullback for `f i j` and `f i k` exists.\n9. `V i j √ó[U i] V i k ‚ü∂ V i j ‚ü∂ V j i` factors through `V j k √ó[U j] V j i ‚ü∂ V j i` via some\n    `t' : V i j √ó[U i] V i k ‚ü∂ V j k √ó[U j] V j i`.\n10. `t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _`.\n-/\nstructure GlueData where\n  J : Type v\n  U : J ‚Üí C\n  V : J √ó J ‚Üí C\n  f : ‚àÄ i j, V (i, j) ‚ü∂ U i\n  f_mono : ‚àÄ i j, Mono (f i j) := by infer_instance\n  f_hasPullback : ‚àÄ i j k, HasPullback (f i j) (f i k) := by infer_instance\n  f_id : ‚àÄ i, IsIso (f i i) := by infer_instance\n  t : ‚àÄ i j, V (i, j) ‚ü∂ V (j, i)\n  t_id : ‚àÄ i, t i i = ùüô _\n  t' : ‚àÄ i j k, pullback (f i j) (f i k) ‚ü∂ pullback (f j k) (f j i)\n  t_fac : ‚àÄ i j k, t' i j k ‚â´ pullback.snd _ _ = pullback.fst _ _ ‚â´ t i j\n  cocycle : ‚àÄ i j k, t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _\n\n"}
{"name":"CategoryTheory.GlueData.mk.injEq","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nJ‚úù : Type v\nU‚úù : J‚úù ‚Üí C\nV‚úù : Prod J‚úù J‚úù ‚Üí C\nf‚úù : (i j : J‚úù) ‚Üí Quiver.Hom (V‚úù { fst := i, snd := j }) (U‚úù i)\nf_mono‚úù : autoParam (‚àÄ (i j : J‚úù), CategoryTheory.Mono (f‚úù i j)) _auto‚úù\nf_hasPullback‚úù : autoParam (‚àÄ (i j k : J‚úù), CategoryTheory.Limits.HasPullback (f‚úù i j) (f‚úù i k)) _auto‚úù\nf_id‚úù : autoParam (‚àÄ (i : J‚úù), CategoryTheory.IsIso (f‚úù i i)) _auto‚úù\nt‚úù : (i j : J‚úù) ‚Üí Quiver.Hom (V‚úù { fst := i, snd := j }) (V‚úù { fst := j, snd := i })\nt_id‚úù : ‚àÄ (i : J‚úù), Eq (t‚úù i i) (CategoryTheory.CategoryStruct.id (V‚úù { fst := i, snd := i }))\nt'‚úù : (i j k : J‚úù) ‚Üí Quiver.Hom (CategoryTheory.Limits.pullback (f‚úù i j) (f‚úù i k)) (CategoryTheory.Limits.pullback (f‚úù j k) (f‚úù j i))\nt_fac‚úù : ‚àÄ (i j k : J‚úù), Eq (CategoryTheory.CategoryStruct.comp (t'‚úù i j k) (CategoryTheory.Limits.pullback.snd (f‚úù j k) (f‚úù j i))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (f‚úù i j) (f‚úù i k)) (t‚úù i j))\ncocycle‚úù : ‚àÄ (i j k : J‚úù), Eq (CategoryTheory.CategoryStruct.comp (t'‚úù i j k) (CategoryTheory.CategoryStruct.comp (t'‚úù j k i) (t'‚úù k i j))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback (f‚úù i j) (f‚úù i k)))\nJ : Type v\nU : J ‚Üí C\nV : Prod J J ‚Üí C\nf : (i j : J) ‚Üí Quiver.Hom (V { fst := i, snd := j }) (U i)\nf_mono : autoParam (‚àÄ (i j : J), CategoryTheory.Mono (f i j)) _auto‚úù\nf_hasPullback : autoParam (‚àÄ (i j k : J), CategoryTheory.Limits.HasPullback (f i j) (f i k)) _auto‚úù\nf_id : autoParam (‚àÄ (i : J), CategoryTheory.IsIso (f i i)) _auto‚úù\nt : (i j : J) ‚Üí Quiver.Hom (V { fst := i, snd := j }) (V { fst := j, snd := i })\nt_id : ‚àÄ (i : J), Eq (t i i) (CategoryTheory.CategoryStruct.id (V { fst := i, snd := i }))\nt' : (i j k : J) ‚Üí Quiver.Hom (CategoryTheory.Limits.pullback (f i j) (f i k)) (CategoryTheory.Limits.pullback (f j k) (f j i))\nt_fac : ‚àÄ (i j k : J), Eq (CategoryTheory.CategoryStruct.comp (t' i j k) (CategoryTheory.Limits.pullback.snd (f j k) (f j i))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (f i j) (f i k)) (t i j))\ncocycle : ‚àÄ (i j k : J), Eq (CategoryTheory.CategoryStruct.comp (t' i j k) (CategoryTheory.CategoryStruct.comp (t' j k i) (t' k i j))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback (f i j) (f i k)))\n‚ä¢ Eq (Eq { J := J‚úù, U := U‚úù, V := V‚úù, f := f‚úù, f_mono := f_mono‚úù, f_hasPullback := f_hasPullback‚úù, f_id := f_id‚úù, t := t‚úù, t_id := t_id‚úù, t' := t'‚úù, t_fac := t_fac‚úù, cocycle := cocycle‚úù } { J := J, U := U, V := V, f := f, f_mono := f_mono, f_hasPullback := f_hasPullback, f_id := f_id, t := t, t_id := t_id, t' := t', t_fac := t_fac, cocycle := cocycle }) (And (Eq J‚úù J) (And (HEq U‚úù U) (And (HEq V‚úù V) (And (HEq f‚úù f) (And (HEq t‚úù t) (HEq t'‚úù t'))))))","decl":"/-- A gluing datum consists of\n1. An index type `J`\n2. An object `U i` for each `i : J`.\n3. An object `V i j` for each `i j : J`.\n4. A monomorphism `f i j : V i j ‚ü∂ U i` for each `i j : J`.\n5. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : J`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. The pullback for `f i j` and `f i k` exists.\n9. `V i j √ó[U i] V i k ‚ü∂ V i j ‚ü∂ V j i` factors through `V j k √ó[U j] V j i ‚ü∂ V j i` via some\n    `t' : V i j √ó[U i] V i k ‚ü∂ V j k √ó[U j] V j i`.\n10. `t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _`.\n-/\nstructure GlueData where\n  J : Type v\n  U : J ‚Üí C\n  V : J √ó J ‚Üí C\n  f : ‚àÄ i j, V (i, j) ‚ü∂ U i\n  f_mono : ‚àÄ i j, Mono (f i j) := by infer_instance\n  f_hasPullback : ‚àÄ i j k, HasPullback (f i j) (f i k) := by infer_instance\n  f_id : ‚àÄ i, IsIso (f i i) := by infer_instance\n  t : ‚àÄ i j, V (i, j) ‚ü∂ V (j, i)\n  t_id : ‚àÄ i, t i i = ùüô _\n  t' : ‚àÄ i j k, pullback (f i j) (f i k) ‚ü∂ pullback (f j k) (f j i)\n  t_fac : ‚àÄ i j k, t' i j k ‚â´ pullback.snd _ _ = pullback.fst _ _ ‚â´ t i j\n  cocycle : ‚àÄ i j k, t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _\n\n"}
{"name":"CategoryTheory.GlueData.t_fac_assoc","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nself : CategoryTheory.GlueData C\ni j k : self.J\nZ : C\nh : Quiver.Hom (self.V { fst := j, snd := i }) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.t' i j k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (self.f j k) (self.f j i)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (self.f i j) (self.f i k)) (CategoryTheory.CategoryStruct.comp (self.t i j) h))","decl":"attribute [reassoc] GlueData.t_fac GlueData.cocycle\n\n"}
{"name":"CategoryTheory.GlueData.cocycle_assoc","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nself : CategoryTheory.GlueData C\ni j k : self.J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pullback (self.f i j) (self.f i k)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.t' i j k) (CategoryTheory.CategoryStruct.comp (self.t' j k i) (CategoryTheory.CategoryStruct.comp (self.t' k i j) h))) h","decl":"attribute [reassoc] GlueData.t_fac GlueData.cocycle\n\n"}
{"name":"CategoryTheory.GlueData.t'_iij","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nD : CategoryTheory.GlueData C\ni j : D.J\n‚ä¢ Eq (D.t' i i j) (CategoryTheory.Limits.pullbackSymmetry (D.f i i) (D.f i j)).hom","decl":"@[simp]\ntheorem t'_iij (i j : D.J) : D.t' i i j = (pullbackSymmetry _ _).hom := by\n  have eq‚ÇÅ := D.t_fac i i j\n  have eq‚ÇÇ := (IsIso.eq_comp_inv (D.f i i)).mpr (@pullback.condition _ _ _ _ _ _ (D.f i j) _)\n  rw [D.t_id, Category.comp_id, eq‚ÇÇ] at eq‚ÇÅ\n  have eq‚ÇÉ := (IsIso.eq_comp_inv (D.f i i)).mp eq‚ÇÅ\n  rw [Category.assoc, ‚Üê pullback.condition, ‚Üê Category.assoc] at eq‚ÇÉ\n  exact\n    Mono.right_cancellation _ _\n      ((Mono.right_cancellation _ _ eq‚ÇÉ).trans (pullbackSymmetry_hom_comp_fst _ _).symm)\n\n"}
{"name":"CategoryTheory.GlueData.t'_jii","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nD : CategoryTheory.GlueData C\ni j : D.J\n‚ä¢ Eq (D.t' j i i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (D.f j i) (D.f j i)) (CategoryTheory.CategoryStruct.comp (D.t j i) (CategoryTheory.inv (CategoryTheory.Limits.pullback.snd (D.f i i) (D.f i j)))))","decl":"theorem t'_jii (i j : D.J) : D.t' j i i = pullback.fst _ _ ‚â´ D.t j i ‚â´ inv (pullback.snd _ _) := by\n  rw [‚Üê Category.assoc, ‚Üê D.t_fac]\n  simp\n\n"}
{"name":"CategoryTheory.GlueData.t'_iji","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nD : CategoryTheory.GlueData C\ni j : D.J\n‚ä¢ Eq (D.t' i j i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (D.f i j) (D.f i i)) (CategoryTheory.CategoryStruct.comp (D.t i j) (CategoryTheory.inv (CategoryTheory.Limits.pullback.snd (D.f j i) (D.f j i)))))","decl":"theorem t'_iji (i j : D.J) : D.t' i j i = pullback.fst _ _ ‚â´ D.t i j ‚â´ inv (pullback.snd _ _) := by\n  rw [‚Üê Category.assoc, ‚Üê D.t_fac]\n  simp\n\n"}
{"name":"CategoryTheory.GlueData.t_inv","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nD : CategoryTheory.GlueData C\ni j : D.J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (D.t i j) (D.t j i)) (CategoryTheory.CategoryStruct.id (D.V { fst := i, snd := j }))","decl":"@[reassoc, elementwise (attr := simp)]\ntheorem t_inv (i j : D.J) : D.t i j ‚â´ D.t j i = ùüô _ := by\n  have eq : (pullbackSymmetry (D.f i i) (D.f i j)).hom =\n      pullback.snd _ _ ‚â´ inv (pullback.fst _ _) := by simp\n  have := D.cocycle i j i\n  rw [D.t'_iij, D.t'_jii, D.t'_iji, fst_eq_snd_of_mono_eq, eq] at this\n  simp only [Category.assoc, IsIso.inv_hom_id_assoc] at this\n  rw [‚Üê IsIso.eq_inv_comp, ‚Üê Category.assoc, IsIso.comp_inv_eq] at this\n  simpa using this\n\n"}
{"name":"CategoryTheory.GlueData.t_inv_assoc","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nD : CategoryTheory.GlueData C\ni j : D.J\nZ : C\nh : Quiver.Hom (D.V { fst := i, snd := j }) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (D.t i j) (CategoryTheory.CategoryStruct.comp (D.t j i) h)) h","decl":"@[reassoc, elementwise (attr := simp)]\ntheorem t_inv (i j : D.J) : D.t i j ‚â´ D.t j i = ùüô _ := by\n  have eq : (pullbackSymmetry (D.f i i) (D.f i j)).hom =\n      pullback.snd _ _ ‚â´ inv (pullback.fst _ _) := by simp\n  have := D.cocycle i j i\n  rw [D.t'_iij, D.t'_jii, D.t'_iji, fst_eq_snd_of_mono_eq, eq] at this\n  simp only [Category.assoc, IsIso.inv_hom_id_assoc] at this\n  rw [‚Üê IsIso.eq_inv_comp, ‚Üê Category.assoc, IsIso.comp_inv_eq] at this\n  simpa using this\n\n"}
{"name":"CategoryTheory.GlueData.t_inv_apply","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nD : CategoryTheory.GlueData C\ni j : D.J\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (D.V { fst := i, snd := j })\n‚ä¢ Eq ((D.t j i) ((D.t i j) x)) x","decl":"@[reassoc, elementwise (attr := simp)]\ntheorem t_inv (i j : D.J) : D.t i j ‚â´ D.t j i = ùüô _ := by\n  have eq : (pullbackSymmetry (D.f i i) (D.f i j)).hom =\n      pullback.snd _ _ ‚â´ inv (pullback.fst _ _) := by simp\n  have := D.cocycle i j i\n  rw [D.t'_iij, D.t'_jii, D.t'_iji, fst_eq_snd_of_mono_eq, eq] at this\n  simp only [Category.assoc, IsIso.inv_hom_id_assoc] at this\n  rw [‚Üê IsIso.eq_inv_comp, ‚Üê Category.assoc, IsIso.comp_inv_eq] at this\n  simpa using this\n\n"}
{"name":"CategoryTheory.GlueData.t'_inv","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nD : CategoryTheory.GlueData C\ni j k : D.J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (D.t' i j k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry (D.f j k) (D.f j i)).hom (CategoryTheory.CategoryStruct.comp (D.t' j i k) (CategoryTheory.Limits.pullbackSymmetry (D.f i k) (D.f i j)).hom))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback (D.f i j) (D.f i k)))","decl":"theorem t'_inv (i j k : D.J) :\n    D.t' i j k ‚â´ (pullbackSymmetry _ _).hom ‚â´ D.t' j i k ‚â´ (pullbackSymmetry _ _).hom = ùüô _ := by\n  rw [‚Üê cancel_mono (pullback.fst (D.f i j) (D.f i k))]\n  simp [t_fac, t_fac_assoc]\n\n"}
{"name":"CategoryTheory.GlueData.t_isIso","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nD : CategoryTheory.GlueData C\ni j : D.J\n‚ä¢ CategoryTheory.IsIso (D.t i j)","decl":"instance t_isIso (i j : D.J) : IsIso (D.t i j) :=\n  ‚ü®‚ü®D.t j i, D.t_inv _ _, D.t_inv _ _‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.GlueData.t'_isIso","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nD : CategoryTheory.GlueData C\ni j k : D.J\n‚ä¢ CategoryTheory.IsIso (D.t' i j k)","decl":"instance t'_isIso (i j k : D.J) : IsIso (D.t' i j k) :=\n  ‚ü®‚ü®D.t' j k i ‚â´ D.t' k i j, D.cocycle _ _ _, by simpa using D.cocycle _ _ _‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.GlueData.t'_comp_eq_pullbackSymmetry_assoc","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nD : CategoryTheory.GlueData C\ni j k : D.J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pullback (D.f i j) (D.f i k)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (D.t' j k i) (CategoryTheory.CategoryStruct.comp (D.t' k i j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry (D.f j k) (D.f j i)).hom (CategoryTheory.CategoryStruct.comp (D.t' j i k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry (D.f i k) (D.f i j)).hom h)))","decl":"@[reassoc]\ntheorem t'_comp_eq_pullbackSymmetry (i j k : D.J) :\n    D.t' j k i ‚â´ D.t' k i j =\n      (pullbackSymmetry _ _).hom ‚â´ D.t' j i k ‚â´ (pullbackSymmetry _ _).hom := by\n  trans inv (D.t' i j k)\n  ¬∑ exact IsIso.eq_inv_of_hom_inv_id (D.cocycle _ _ _)\n  ¬∑ rw [‚Üê cancel_mono (pullback.fst (D.f i j) (D.f i k))]\n    simp [t_fac, t_fac_assoc]\n\n"}
{"name":"CategoryTheory.GlueData.t'_comp_eq_pullbackSymmetry","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nD : CategoryTheory.GlueData C\ni j k : D.J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (D.t' j k i) (D.t' k i j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry (D.f j k) (D.f j i)).hom (CategoryTheory.CategoryStruct.comp (D.t' j i k) (CategoryTheory.Limits.pullbackSymmetry (D.f i k) (D.f i j)).hom))","decl":"@[reassoc]\ntheorem t'_comp_eq_pullbackSymmetry (i j k : D.J) :\n    D.t' j k i ‚â´ D.t' k i j =\n      (pullbackSymmetry _ _).hom ‚â´ D.t' j i k ‚â´ (pullbackSymmetry _ _).hom := by\n  trans inv (D.t' i j k)\n  ¬∑ exact IsIso.eq_inv_of_hom_inv_id (D.cocycle _ _ _)\n  ¬∑ rw [‚Üê cancel_mono (pullback.fst (D.f i j) (D.f i k))]\n    simp [t_fac, t_fac_assoc]\n\n"}
{"name":"CategoryTheory.GlueData.diagram_l","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nD : CategoryTheory.GlueData C\n‚ä¢ Eq D.diagram.L (Prod D.J D.J)","decl":"@[simp]\ntheorem diagram_l : D.diagram.L = (D.J √ó D.J) :=\n  rfl\n\n"}
{"name":"CategoryTheory.GlueData.diagram_r","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nD : CategoryTheory.GlueData C\n‚ä¢ Eq D.diagram.R D.J","decl":"@[simp]\ntheorem diagram_r : D.diagram.R = D.J :=\n  rfl\n\n"}
{"name":"CategoryTheory.GlueData.diagram_fstFrom","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nD : CategoryTheory.GlueData C\ni j : D.J\n‚ä¢ Eq (D.diagram.fstFrom { fst := i, snd := j }) i","decl":"@[simp]\ntheorem diagram_fstFrom (i j : D.J) : D.diagram.fstFrom ‚ü®i, j‚ü© = i :=\n  rfl\n\n"}
{"name":"CategoryTheory.GlueData.diagram_sndFrom","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nD : CategoryTheory.GlueData C\ni j : D.J\n‚ä¢ Eq (D.diagram.sndFrom { fst := i, snd := j }) j","decl":"@[simp]\ntheorem diagram_sndFrom (i j : D.J) : D.diagram.sndFrom ‚ü®i, j‚ü© = j :=\n  rfl\n\n"}
{"name":"CategoryTheory.GlueData.diagram_fst","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nD : CategoryTheory.GlueData C\ni j : D.J\n‚ä¢ Eq (D.diagram.fst { fst := i, snd := j }) (D.f i j)","decl":"@[simp]\ntheorem diagram_fst (i j : D.J) : D.diagram.fst ‚ü®i, j‚ü© = D.f i j :=\n  rfl\n\n"}
{"name":"CategoryTheory.GlueData.diagram_snd","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nD : CategoryTheory.GlueData C\ni j : D.J\n‚ä¢ Eq (D.diagram.snd { fst := i, snd := j }) (CategoryTheory.CategoryStruct.comp (D.t i j) (D.f j i))","decl":"@[simp]\ntheorem diagram_snd (i j : D.J) : D.diagram.snd ‚ü®i, j‚ü© = D.t i j ‚â´ D.f j i :=\n  rfl\n\n"}
{"name":"CategoryTheory.GlueData.diagram_left","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nD : CategoryTheory.GlueData C\n‚ä¢ Eq D.diagram.left D.V","decl":"@[simp]\ntheorem diagram_left : D.diagram.left = D.V :=\n  rfl\n\n"}
{"name":"CategoryTheory.GlueData.diagram_right","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nD : CategoryTheory.GlueData C\n‚ä¢ Eq D.diagram.right D.U","decl":"@[simp]\ntheorem diagram_right : D.diagram.right = D.U :=\n  rfl\n\n"}
{"name":"CategoryTheory.GlueData.glue_condition","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v, u‚ÇÅ} C\nD : CategoryTheory.GlueData C\ninst‚úù : CategoryTheory.Limits.HasMulticoequalizer D.diagram\ni j : D.J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (D.t i j) (CategoryTheory.CategoryStruct.comp (D.f j i) (D.Œπ j))) (CategoryTheory.CategoryStruct.comp (D.f i j) (D.Œπ i))","decl":"@[elementwise (attr := simp)]\ntheorem glue_condition (i j : D.J) : D.t i j ‚â´ D.f j i ‚â´ D.Œπ j = D.f i j ‚â´ D.Œπ i :=\n  (Category.assoc _ _ _).symm.trans (Multicoequalizer.condition D.diagram ‚ü®i, j‚ü©).symm\n\n"}
{"name":"CategoryTheory.GlueData.glue_condition_apply","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v, u‚ÇÅ} C\nD : CategoryTheory.GlueData C\ninst‚úù : CategoryTheory.Limits.HasMulticoequalizer D.diagram\ni j : D.J\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (D.V { fst := i, snd := j })\n‚ä¢ Eq ((D.Œπ j) ((D.f j i) ((D.t i j) x))) ((D.Œπ i) ((D.f i j) x))","decl":"@[elementwise (attr := simp)]\ntheorem glue_condition (i j : D.J) : D.t i j ‚â´ D.f j i ‚â´ D.Œπ j = D.f i j ‚â´ D.Œπ i :=\n  (Category.assoc _ _ _).symm.trans (Multicoequalizer.condition D.diagram ‚ü®i, j‚ü©).symm\n\n"}
{"name":"CategoryTheory.GlueData.œÄ_epi","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v, u‚ÇÅ} C\nD : CategoryTheory.GlueData C\ninst‚úù¬π : CategoryTheory.Limits.HasMulticoequalizer D.diagram\ninst‚úù : CategoryTheory.Limits.HasColimits C\n‚ä¢ CategoryTheory.Epi D.œÄ","decl":"instance œÄ_epi : Epi D.œÄ := by\n  unfold œÄ\n  infer_instance\n\n"}
{"name":"CategoryTheory.GlueData.types_œÄ_surjective","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"D : CategoryTheory.GlueData (Type u_1)\n‚ä¢ Function.Surjective D.œÄ","decl":"theorem types_œÄ_surjective (D : GlueData Type*) : Function.Surjective D.œÄ :=\n  (epi_iff_surjective _).mp inferInstance\n\n"}
{"name":"CategoryTheory.GlueData.types_Œπ_jointly_surjective","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"D : CategoryTheory.GlueData (Type v)\nx : D.glued\n‚ä¢ Exists fun i => Exists fun y => Eq (D.Œπ i y) x","decl":"theorem types_Œπ_jointly_surjective (D : GlueData (Type v)) (x : D.glued) :\n    ‚àÉ (i : _) (y : D.U i), D.Œπ i y = x := by\n  delta CategoryTheory.GlueData.Œπ\n  simp_rw [‚Üê Multicoequalizer.Œπ_sigmaœÄ D.diagram]\n  rcases D.types_œÄ_surjective x with ‚ü®x', rfl‚ü©\n  --have := colimit.isoColimitCocone (Types.coproductColimitCocone _)\n  rw [‚Üê show (colimit.isoColimitCocone (Types.coproductColimitCocone.{v, v} _)).inv _ = x' from\n      ConcreteCategory.congr_hom\n        (colimit.isoColimitCocone (Types.coproductColimitCocone _)).hom_inv_id x']\n  rcases (colimit.isoColimitCocone (Types.coproductColimitCocone _)).hom x' with ‚ü®i, y‚ü©\n  exact ‚ü®i, y, by\n    simp [‚Üê Multicoequalizer.Œπ_sigmaœÄ]\n    rfl ‚ü©\n\n"}
{"name":"CategoryTheory.GlueData.instHasPullbackMapF","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v, u‚ÇÅ} C\nC' : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v, u‚ÇÇ} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst‚úù : ‚àÄ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\ni j k : D.J\n‚ä¢ CategoryTheory.Limits.HasPullback (F.map (D.f i j)) (F.map (D.f i k))","decl":"instance (i j k : D.J) : HasPullback (F.map (D.f i j)) (F.map (D.f i k)) :=\n  ‚ü®‚ü®‚ü®_, isLimitOfHasPullbackOfPreservesLimit F (D.f i j) (D.f i k)‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.GlueData.mapGlueData_t'","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v, u‚ÇÅ} C\nC' : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v, u‚ÇÇ} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst‚úù : ‚àÄ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\ni j k : D.J\n‚ä¢ Eq ((D.mapGlueData F).t' i j k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesPullback.iso F (D.f i j) (D.f i k)).inv (CategoryTheory.CategoryStruct.comp (F.map (D.t' i j k)) (CategoryTheory.Limits.PreservesPullback.iso F (D.f j k) (D.f j i)).hom))","decl":"/-- A functor that preserves the pullbacks of `f i j` and `f i k` can map a family of glue data. -/\n@[simps]\ndef mapGlueData : GlueData C' where\n  J := D.J\n  U i := F.obj (D.U i)\n  V i := F.obj (D.V i)\n  f i j := F.map (D.f i j)\n  f_mono _ _ := preserves_mono_of_preservesLimit _ _\n  f_id _ := inferInstance\n  t i j := F.map (D.t i j)\n  t_id i := by\n    simp [D.t_id i]\n  t' i j k :=\n    (PreservesPullback.iso F (D.f i j) (D.f i k)).inv ‚â´\n      F.map (D.t' i j k) ‚â´ (PreservesPullback.iso F (D.f j k) (D.f j i)).hom\n  t_fac i j k := by simpa [Iso.inv_comp_eq] using congr_arg (fun f => F.map f) (D.t_fac i j k)\n  cocycle i j k := by\n    simp only [Category.assoc, Iso.hom_inv_id_assoc, ‚Üê Functor.map_comp_assoc, D.cocycle,\n      Iso.inv_hom_id, CategoryTheory.Functor.map_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.GlueData.mapGlueData_V","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v, u‚ÇÅ} C\nC' : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v, u‚ÇÇ} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst‚úù : ‚àÄ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\ni : Prod D.J D.J\n‚ä¢ Eq ((D.mapGlueData F).V i) (F.obj (D.V i))","decl":"/-- A functor that preserves the pullbacks of `f i j` and `f i k` can map a family of glue data. -/\n@[simps]\ndef mapGlueData : GlueData C' where\n  J := D.J\n  U i := F.obj (D.U i)\n  V i := F.obj (D.V i)\n  f i j := F.map (D.f i j)\n  f_mono _ _ := preserves_mono_of_preservesLimit _ _\n  f_id _ := inferInstance\n  t i j := F.map (D.t i j)\n  t_id i := by\n    simp [D.t_id i]\n  t' i j k :=\n    (PreservesPullback.iso F (D.f i j) (D.f i k)).inv ‚â´\n      F.map (D.t' i j k) ‚â´ (PreservesPullback.iso F (D.f j k) (D.f j i)).hom\n  t_fac i j k := by simpa [Iso.inv_comp_eq] using congr_arg (fun f => F.map f) (D.t_fac i j k)\n  cocycle i j k := by\n    simp only [Category.assoc, Iso.hom_inv_id_assoc, ‚Üê Functor.map_comp_assoc, D.cocycle,\n      Iso.inv_hom_id, CategoryTheory.Functor.map_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.GlueData.mapGlueData_f","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v, u‚ÇÅ} C\nC' : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v, u‚ÇÇ} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst‚úù : ‚àÄ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\ni j : D.J\n‚ä¢ Eq ((D.mapGlueData F).f i j) (F.map (D.f i j))","decl":"/-- A functor that preserves the pullbacks of `f i j` and `f i k` can map a family of glue data. -/\n@[simps]\ndef mapGlueData : GlueData C' where\n  J := D.J\n  U i := F.obj (D.U i)\n  V i := F.obj (D.V i)\n  f i j := F.map (D.f i j)\n  f_mono _ _ := preserves_mono_of_preservesLimit _ _\n  f_id _ := inferInstance\n  t i j := F.map (D.t i j)\n  t_id i := by\n    simp [D.t_id i]\n  t' i j k :=\n    (PreservesPullback.iso F (D.f i j) (D.f i k)).inv ‚â´\n      F.map (D.t' i j k) ‚â´ (PreservesPullback.iso F (D.f j k) (D.f j i)).hom\n  t_fac i j k := by simpa [Iso.inv_comp_eq] using congr_arg (fun f => F.map f) (D.t_fac i j k)\n  cocycle i j k := by\n    simp only [Category.assoc, Iso.hom_inv_id_assoc, ‚Üê Functor.map_comp_assoc, D.cocycle,\n      Iso.inv_hom_id, CategoryTheory.Functor.map_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.GlueData.mapGlueData_t","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v, u‚ÇÅ} C\nC' : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v, u‚ÇÇ} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst‚úù : ‚àÄ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\ni j : D.J\n‚ä¢ Eq ((D.mapGlueData F).t i j) (F.map (D.t i j))","decl":"/-- A functor that preserves the pullbacks of `f i j` and `f i k` can map a family of glue data. -/\n@[simps]\ndef mapGlueData : GlueData C' where\n  J := D.J\n  U i := F.obj (D.U i)\n  V i := F.obj (D.V i)\n  f i j := F.map (D.f i j)\n  f_mono _ _ := preserves_mono_of_preservesLimit _ _\n  f_id _ := inferInstance\n  t i j := F.map (D.t i j)\n  t_id i := by\n    simp [D.t_id i]\n  t' i j k :=\n    (PreservesPullback.iso F (D.f i j) (D.f i k)).inv ‚â´\n      F.map (D.t' i j k) ‚â´ (PreservesPullback.iso F (D.f j k) (D.f j i)).hom\n  t_fac i j k := by simpa [Iso.inv_comp_eq] using congr_arg (fun f => F.map f) (D.t_fac i j k)\n  cocycle i j k := by\n    simp only [Category.assoc, Iso.hom_inv_id_assoc, ‚Üê Functor.map_comp_assoc, D.cocycle,\n      Iso.inv_hom_id, CategoryTheory.Functor.map_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.GlueData.mapGlueData_J","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v, u‚ÇÅ} C\nC' : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v, u‚ÇÇ} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst‚úù : ‚àÄ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\n‚ä¢ Eq (D.mapGlueData F).J D.J","decl":"/-- A functor that preserves the pullbacks of `f i j` and `f i k` can map a family of glue data. -/\n@[simps]\ndef mapGlueData : GlueData C' where\n  J := D.J\n  U i := F.obj (D.U i)\n  V i := F.obj (D.V i)\n  f i j := F.map (D.f i j)\n  f_mono _ _ := preserves_mono_of_preservesLimit _ _\n  f_id _ := inferInstance\n  t i j := F.map (D.t i j)\n  t_id i := by\n    simp [D.t_id i]\n  t' i j k :=\n    (PreservesPullback.iso F (D.f i j) (D.f i k)).inv ‚â´\n      F.map (D.t' i j k) ‚â´ (PreservesPullback.iso F (D.f j k) (D.f j i)).hom\n  t_fac i j k := by simpa [Iso.inv_comp_eq] using congr_arg (fun f => F.map f) (D.t_fac i j k)\n  cocycle i j k := by\n    simp only [Category.assoc, Iso.hom_inv_id_assoc, ‚Üê Functor.map_comp_assoc, D.cocycle,\n      Iso.inv_hom_id, CategoryTheory.Functor.map_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.GlueData.mapGlueData_U","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v, u‚ÇÅ} C\nC' : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v, u‚ÇÇ} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst‚úù : ‚àÄ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\ni : D.J\n‚ä¢ Eq ((D.mapGlueData F).U i) (F.obj (D.U i))","decl":"/-- A functor that preserves the pullbacks of `f i j` and `f i k` can map a family of glue data. -/\n@[simps]\ndef mapGlueData : GlueData C' where\n  J := D.J\n  U i := F.obj (D.U i)\n  V i := F.obj (D.V i)\n  f i j := F.map (D.f i j)\n  f_mono _ _ := preserves_mono_of_preservesLimit _ _\n  f_id _ := inferInstance\n  t i j := F.map (D.t i j)\n  t_id i := by\n    simp [D.t_id i]\n  t' i j k :=\n    (PreservesPullback.iso F (D.f i j) (D.f i k)).inv ‚â´\n      F.map (D.t' i j k) ‚â´ (PreservesPullback.iso F (D.f j k) (D.f j i)).hom\n  t_fac i j k := by simpa [Iso.inv_comp_eq] using congr_arg (fun f => F.map f) (D.t_fac i j k)\n  cocycle i j k := by\n    simp only [Category.assoc, Iso.hom_inv_id_assoc, ‚Üê Functor.map_comp_assoc, D.cocycle,\n      Iso.inv_hom_id, CategoryTheory.Functor.map_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.GlueData.diagramIso_app_left","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v, u‚ÇÅ} C\nC' : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v, u‚ÇÇ} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst‚úù : ‚àÄ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\ni : Prod D.J D.J\n‚ä¢ Eq ((D.diagramIso F).app (CategoryTheory.Limits.WalkingMultispan.left i)) (CategoryTheory.Iso.refl ((D.diagram.multispan.comp F).obj (CategoryTheory.Limits.WalkingMultispan.left i)))","decl":"@[simp]\ntheorem diagramIso_app_left (i : D.J √ó D.J) :\n    (D.diagramIso F).app (WalkingMultispan.left i) = Iso.refl _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.GlueData.diagramIso_app_right","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v, u‚ÇÅ} C\nC' : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v, u‚ÇÇ} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst‚úù : ‚àÄ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\ni : D.J\n‚ä¢ Eq ((D.diagramIso F).app (CategoryTheory.Limits.WalkingMultispan.right i)) (CategoryTheory.Iso.refl ((D.diagram.multispan.comp F).obj (CategoryTheory.Limits.WalkingMultispan.right i)))","decl":"@[simp]\ntheorem diagramIso_app_right (i : D.J) :\n    (D.diagramIso F).app (WalkingMultispan.right i) = Iso.refl _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.GlueData.diagramIso_hom_app_left","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v, u‚ÇÅ} C\nC' : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v, u‚ÇÇ} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst‚úù : ‚àÄ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\ni : Prod D.J D.J\n‚ä¢ Eq ((D.diagramIso F).hom.app (CategoryTheory.Limits.WalkingMultispan.left i)) (CategoryTheory.CategoryStruct.id ((D.diagram.multispan.comp F).obj (CategoryTheory.Limits.WalkingMultispan.left i)))","decl":"@[simp]\ntheorem diagramIso_hom_app_left (i : D.J √ó D.J) :\n    (D.diagramIso F).hom.app (WalkingMultispan.left i) = ùüô _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.GlueData.diagramIso_hom_app_right","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v, u‚ÇÅ} C\nC' : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v, u‚ÇÇ} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst‚úù : ‚àÄ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\ni : D.J\n‚ä¢ Eq ((D.diagramIso F).hom.app (CategoryTheory.Limits.WalkingMultispan.right i)) (CategoryTheory.CategoryStruct.id ((D.diagram.multispan.comp F).obj (CategoryTheory.Limits.WalkingMultispan.right i)))","decl":"@[simp]\ntheorem diagramIso_hom_app_right (i : D.J) :\n    (D.diagramIso F).hom.app (WalkingMultispan.right i) = ùüô _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.GlueData.diagramIso_inv_app_left","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v, u‚ÇÅ} C\nC' : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v, u‚ÇÇ} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst‚úù : ‚àÄ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\ni : Prod D.J D.J\n‚ä¢ Eq ((D.diagramIso F).inv.app (CategoryTheory.Limits.WalkingMultispan.left i)) (CategoryTheory.CategoryStruct.id ((D.mapGlueData F).diagram.multispan.obj (CategoryTheory.Limits.WalkingMultispan.left i)))","decl":"@[simp]\ntheorem diagramIso_inv_app_left (i : D.J √ó D.J) :\n    (D.diagramIso F).inv.app (WalkingMultispan.left i) = ùüô _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.GlueData.diagramIso_inv_app_right","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v, u‚ÇÅ} C\nC' : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v, u‚ÇÇ} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst‚úù : ‚àÄ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\ni : D.J\n‚ä¢ Eq ((D.diagramIso F).inv.app (CategoryTheory.Limits.WalkingMultispan.right i)) (CategoryTheory.CategoryStruct.id ((D.mapGlueData F).diagram.multispan.obj (CategoryTheory.Limits.WalkingMultispan.right i)))","decl":"@[simp]\ntheorem diagramIso_inv_app_right (i : D.J) :\n    (D.diagramIso F).inv.app (WalkingMultispan.right i) = ùüô _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.GlueData.hasColimit_multispan_comp","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v, u‚ÇÅ} C\nC' : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v, u‚ÇÇ} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst‚úù¬π : CategoryTheory.Limits.HasMulticoequalizer D.diagram\ninst‚úù : CategoryTheory.Limits.PreservesColimit D.diagram.multispan F\n‚ä¢ CategoryTheory.Limits.HasColimit (D.diagram.multispan.comp F)","decl":"theorem hasColimit_multispan_comp : HasColimit (D.diagram.multispan ‚ãô F) :=\n  ‚ü®‚ü®‚ü®_, isColimitOfPreserves _ (colimit.isColimit _)‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.GlueData.hasColimit_mapGlueData_diagram","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u‚ÇÅ} C\nC' : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v, u‚ÇÇ} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst‚úù¬≤ : CategoryTheory.Limits.HasMulticoequalizer D.diagram\ninst‚úù¬π : CategoryTheory.Limits.PreservesColimit D.diagram.multispan F\ninst‚úù : ‚àÄ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\n‚ä¢ CategoryTheory.Limits.HasMulticoequalizer (D.mapGlueData F).diagram","decl":"theorem hasColimit_mapGlueData_diagram : HasMulticoequalizer (D.mapGlueData F).diagram :=\n  hasColimitOfIso (D.diagramIso F).symm\n\n"}
{"name":"CategoryTheory.GlueData.Œπ_gluedIso_hom","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u‚ÇÅ} C\nC' : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v, u‚ÇÇ} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst‚úù¬≤ : CategoryTheory.Limits.HasMulticoequalizer D.diagram\ninst‚úù¬π : CategoryTheory.Limits.PreservesColimit D.diagram.multispan F\ninst‚úù : ‚àÄ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\ni : D.J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (D.Œπ i)) (D.gluedIso F).hom) ((D.mapGlueData F).Œπ i)","decl":"@[reassoc (attr := simp)]\ntheorem Œπ_gluedIso_hom (i : D.J) : F.map (D.Œπ i) ‚â´ (D.gluedIso F).hom = (D.mapGlueData F).Œπ i := by\n  haveI : HasColimit (MultispanIndex.multispan (diagram (mapGlueData D F))) := inferInstance\n  erw [Œπ_preservesColimitIso_hom_assoc]\n  rw [HasColimit.isoOfNatIso_Œπ_hom]\n  erw [Category.id_comp]\n  rfl\n\n"}
{"name":"CategoryTheory.GlueData.Œπ_gluedIso_hom_assoc","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u‚ÇÅ} C\nC' : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v, u‚ÇÇ} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst‚úù¬≤ : CategoryTheory.Limits.HasMulticoequalizer D.diagram\ninst‚úù¬π : CategoryTheory.Limits.PreservesColimit D.diagram.multispan F\ninst‚úù : ‚àÄ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\ni : D.J\nZ : C'\nh : Quiver.Hom (D.mapGlueData F).glued Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (D.Œπ i)) (CategoryTheory.CategoryStruct.comp (D.gluedIso F).hom h)) (CategoryTheory.CategoryStruct.comp ((D.mapGlueData F).Œπ i) h)","decl":"@[reassoc (attr := simp)]\ntheorem Œπ_gluedIso_hom (i : D.J) : F.map (D.Œπ i) ‚â´ (D.gluedIso F).hom = (D.mapGlueData F).Œπ i := by\n  haveI : HasColimit (MultispanIndex.multispan (diagram (mapGlueData D F))) := inferInstance\n  erw [Œπ_preservesColimitIso_hom_assoc]\n  rw [HasColimit.isoOfNatIso_Œπ_hom]\n  erw [Category.id_comp]\n  rfl\n\n"}
{"name":"CategoryTheory.GlueData.Œπ_gluedIso_inv_assoc","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u‚ÇÅ} C\nC' : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v, u‚ÇÇ} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst‚úù¬≤ : CategoryTheory.Limits.HasMulticoequalizer D.diagram\ninst‚úù¬π : CategoryTheory.Limits.PreservesColimit D.diagram.multispan F\ninst‚úù : ‚àÄ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\ni : D.J\nZ : C'\nh : Quiver.Hom (F.obj D.glued) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((D.mapGlueData F).Œπ i) (CategoryTheory.CategoryStruct.comp (D.gluedIso F).inv h)) (CategoryTheory.CategoryStruct.comp (F.map (D.Œπ i)) h)","decl":"@[reassoc (attr := simp)]\ntheorem Œπ_gluedIso_inv (i : D.J) : (D.mapGlueData F).Œπ i ‚â´ (D.gluedIso F).inv = F.map (D.Œπ i) := by\n  rw [Iso.comp_inv_eq, Œπ_gluedIso_hom]\n\n"}
{"name":"CategoryTheory.GlueData.Œπ_gluedIso_inv","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u‚ÇÅ} C\nC' : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v, u‚ÇÇ} C'\nD : CategoryTheory.GlueData C\nF : CategoryTheory.Functor C C'\ninst‚úù¬≤ : CategoryTheory.Limits.HasMulticoequalizer D.diagram\ninst‚úù¬π : CategoryTheory.Limits.PreservesColimit D.diagram.multispan F\ninst‚úù : ‚àÄ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\ni : D.J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((D.mapGlueData F).Œπ i) (D.gluedIso F).inv) (F.map (D.Œπ i))","decl":"@[reassoc (attr := simp)]\ntheorem Œπ_gluedIso_inv (i : D.J) : (D.mapGlueData F).Œπ i ‚â´ (D.gluedIso F).inv = F.map (D.Œπ i) := by\n  rw [Iso.comp_inv_eq, Œπ_gluedIso_hom]\n\n"}
{"name":"CategoryTheory.GlueData.Œπ_jointly_surjective","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v, u‚ÇÅ} C\nD : CategoryTheory.GlueData C\ninst‚úù¬≤ : CategoryTheory.Limits.HasMulticoequalizer D.diagram\nF : CategoryTheory.Functor C (Type v)\ninst‚úù¬π : CategoryTheory.Limits.PreservesColimit D.diagram.multispan F\ninst‚úù : ‚àÄ (i j k : D.J), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) F\nx : F.obj D.glued\n‚ä¢ Exists fun i => Exists fun y => Eq (F.map (D.Œπ i) y) x","decl":"/-- If there is a forgetful functor into `Type` that preserves enough (co)limits, then `D.Œπ` will\nbe jointly surjective. -/\ntheorem Œπ_jointly_surjective (F : C ‚•§ Type v) [PreservesColimit D.diagram.multispan F]\n    [‚àÄ i j k : D.J, PreservesLimit (cospan (D.f i j) (D.f i k)) F] (x : F.obj D.glued) :\n    ‚àÉ (i : _) (y : F.obj (D.U i)), F.map (D.Œπ i) y = x := by\n  let e := D.gluedIso F\n  obtain ‚ü®i, y, eq‚ü© := (D.mapGlueData F).types_Œπ_jointly_surjective (e.hom x)\n  replace eq := congr_arg e.inv eq\n  change ((D.mapGlueData F).Œπ i ‚â´ e.inv) y = (e.hom ‚â´ e.inv) x at eq\n  rw [e.hom_inv_id, D.Œπ_gluedIso_inv] at eq\n  exact ‚ü®i, y, eq‚ü©\n\n"}
{"name":"CategoryTheory.GlueData'.mk.inj","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nJ‚úù : Type v\nU‚úù : J‚úù ‚Üí C\nV‚úù : (i j : J‚úù) ‚Üí Ne i j ‚Üí C\nf‚úù : (i j : J‚úù) ‚Üí (h : Ne i j) ‚Üí Quiver.Hom (V‚úù i j h) (U‚úù i)\nf_mono‚úù : autoParam (‚àÄ (i j : J‚úù) (h : Ne i j), CategoryTheory.Mono (f‚úù i j h)) _auto‚úù\nf_hasPullback‚úù : autoParam (‚àÄ (i j k : J‚úù) (hij : Ne i j) (hik : Ne i k), CategoryTheory.Limits.HasPullback (f‚úù i j hij) (f‚úù i k hik)) _auto‚úù\nt‚úù : (i j : J‚úù) ‚Üí (h : Ne i j) ‚Üí Quiver.Hom (V‚úù i j h) (V‚úù j i ‚ãØ)\nt'‚úù : (i j k : J‚úù) ‚Üí (hij : Ne i j) ‚Üí (hik : Ne i k) ‚Üí (hjk : Ne j k) ‚Üí Quiver.Hom (CategoryTheory.Limits.pullback (f‚úù i j hij) (f‚úù i k hik)) (CategoryTheory.Limits.pullback (f‚úù j k hjk) (f‚úù j i ‚ãØ))\nt_fac‚úù : ‚àÄ (i j k : J‚úù) (hij : Ne i j) (hik : Ne i k) (hjk : Ne j k), Eq (CategoryTheory.CategoryStruct.comp (t'‚úù i j k hij hik hjk) (CategoryTheory.Limits.pullback.snd (f‚úù j k hjk) (f‚úù j i ‚ãØ))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (f‚úù i j hij) (f‚úù i k hik)) (t‚úù i j hij))\nt_inv‚úù : ‚àÄ (i j : J‚úù) (hij : Ne i j), Eq (CategoryTheory.CategoryStruct.comp (t‚úù i j hij) (t‚úù j i ‚ãØ)) (CategoryTheory.CategoryStruct.id (V‚úù i j hij))\ncocycle‚úù : ‚àÄ (i j k : J‚úù) (hij : Ne i j) (hik : Ne i k) (hjk : Ne j k), Eq (CategoryTheory.CategoryStruct.comp (t'‚úù i j k hij hik hjk) (CategoryTheory.CategoryStruct.comp (t'‚úù j k i hjk ‚ãØ ‚ãØ) (t'‚úù k i j ‚ãØ ‚ãØ hij))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback (f‚úù i j hij) (f‚úù i k hik)))\nJ : Type v\nU : J ‚Üí C\nV : (i j : J) ‚Üí Ne i j ‚Üí C\nf : (i j : J) ‚Üí (h : Ne i j) ‚Üí Quiver.Hom (V i j h) (U i)\nf_mono : autoParam (‚àÄ (i j : J) (h : Ne i j), CategoryTheory.Mono (f i j h)) _auto‚úù\nf_hasPullback : autoParam (‚àÄ (i j k : J) (hij : Ne i j) (hik : Ne i k), CategoryTheory.Limits.HasPullback (f i j hij) (f i k hik)) _auto‚úù\nt : (i j : J) ‚Üí (h : Ne i j) ‚Üí Quiver.Hom (V i j h) (V j i ‚ãØ)\nt' : (i j k : J) ‚Üí (hij : Ne i j) ‚Üí (hik : Ne i k) ‚Üí (hjk : Ne j k) ‚Üí Quiver.Hom (CategoryTheory.Limits.pullback (f i j hij) (f i k hik)) (CategoryTheory.Limits.pullback (f j k hjk) (f j i ‚ãØ))\nt_fac : ‚àÄ (i j k : J) (hij : Ne i j) (hik : Ne i k) (hjk : Ne j k), Eq (CategoryTheory.CategoryStruct.comp (t' i j k hij hik hjk) (CategoryTheory.Limits.pullback.snd (f j k hjk) (f j i ‚ãØ))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (f i j hij) (f i k hik)) (t i j hij))\nt_inv : ‚àÄ (i j : J) (hij : Ne i j), Eq (CategoryTheory.CategoryStruct.comp (t i j hij) (t j i ‚ãØ)) (CategoryTheory.CategoryStruct.id (V i j hij))\ncocycle : ‚àÄ (i j k : J) (hij : Ne i j) (hik : Ne i k) (hjk : Ne j k), Eq (CategoryTheory.CategoryStruct.comp (t' i j k hij hik hjk) (CategoryTheory.CategoryStruct.comp (t' j k i hjk ‚ãØ ‚ãØ) (t' k i j ‚ãØ ‚ãØ hij))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback (f i j hij) (f i k hik)))\nx‚úù : Eq { J := J‚úù, U := U‚úù, V := V‚úù, f := f‚úù, f_mono := f_mono‚úù, f_hasPullback := f_hasPullback‚úù, t := t‚úù, t' := t'‚úù, t_fac := t_fac‚úù, t_inv := t_inv‚úù, cocycle := cocycle‚úù } { J := J, U := U, V := V, f := f, f_mono := f_mono, f_hasPullback := f_hasPullback, t := t, t' := t', t_fac := t_fac, t_inv := t_inv, cocycle := cocycle }\n‚ä¢ And (Eq J‚úù J) (And (HEq U‚úù U) (And (HEq V‚úù V) (And (HEq f‚úù f) (And (HEq t‚úù t) (HEq t'‚úù t')))))","decl":"/--\nThis is a variant of `GlueData` that only requires conditions on `V (i, j)` when `i ‚â† j`.\nSee `GlueData.ofGlueData'`\n-/\nstructure GlueData' where\n  /-- Indexing type of a glue data. -/\n  J : Type v\n  /-- Objects of a glue data to be glued. -/\n  U : J ‚Üí C\n  /-- Objects representing the intersections. -/\n  V : ‚àÄ (i j : J), i ‚â† j ‚Üí C\n  /-- The inclusion maps of the intersection into the object. -/\n  f : ‚àÄ i j h, V i j h ‚ü∂ U i\n  f_mono : ‚àÄ i j h, Mono (f i j h) := by infer_instance\n  f_hasPullback : ‚àÄ i j k hij hik, HasPullback (f i j hij) (f i k hik) := by infer_instance\n  /-- The transition maps between the intersections. -/\n  t : ‚àÄ i j h, V i j h ‚ü∂ V j i h.symm\n  /-- The transition maps between the intersection of intersections. -/\n  t' : ‚àÄ i j k hij hik hjk,\n    pullback (f i j hij) (f i k hik) ‚ü∂ pullback (f j k hjk) (f j i hij.symm)\n  t_fac : ‚àÄ i j k hij hik hjk, t' i j k hij hik hjk ‚â´ pullback.snd _ _ =\n    pullback.fst _ _ ‚â´ t i j hij\n  t_inv : ‚àÄ i j hij, t i j hij ‚â´ t j i hij.symm = ùüô _\n  cocycle : ‚àÄ i j k hij hik hjk, t' i j k hij hik hjk ‚â´\n    t' j k i hjk hij.symm hik.symm ‚â´ t' k i j hik.symm hjk.symm hij = ùüô _\n\n"}
{"name":"CategoryTheory.GlueData'.mk.injEq","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nJ‚úù : Type v\nU‚úù : J‚úù ‚Üí C\nV‚úù : (i j : J‚úù) ‚Üí Ne i j ‚Üí C\nf‚úù : (i j : J‚úù) ‚Üí (h : Ne i j) ‚Üí Quiver.Hom (V‚úù i j h) (U‚úù i)\nf_mono‚úù : autoParam (‚àÄ (i j : J‚úù) (h : Ne i j), CategoryTheory.Mono (f‚úù i j h)) _auto‚úù\nf_hasPullback‚úù : autoParam (‚àÄ (i j k : J‚úù) (hij : Ne i j) (hik : Ne i k), CategoryTheory.Limits.HasPullback (f‚úù i j hij) (f‚úù i k hik)) _auto‚úù\nt‚úù : (i j : J‚úù) ‚Üí (h : Ne i j) ‚Üí Quiver.Hom (V‚úù i j h) (V‚úù j i ‚ãØ)\nt'‚úù : (i j k : J‚úù) ‚Üí (hij : Ne i j) ‚Üí (hik : Ne i k) ‚Üí (hjk : Ne j k) ‚Üí Quiver.Hom (CategoryTheory.Limits.pullback (f‚úù i j hij) (f‚úù i k hik)) (CategoryTheory.Limits.pullback (f‚úù j k hjk) (f‚úù j i ‚ãØ))\nt_fac‚úù : ‚àÄ (i j k : J‚úù) (hij : Ne i j) (hik : Ne i k) (hjk : Ne j k), Eq (CategoryTheory.CategoryStruct.comp (t'‚úù i j k hij hik hjk) (CategoryTheory.Limits.pullback.snd (f‚úù j k hjk) (f‚úù j i ‚ãØ))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (f‚úù i j hij) (f‚úù i k hik)) (t‚úù i j hij))\nt_inv‚úù : ‚àÄ (i j : J‚úù) (hij : Ne i j), Eq (CategoryTheory.CategoryStruct.comp (t‚úù i j hij) (t‚úù j i ‚ãØ)) (CategoryTheory.CategoryStruct.id (V‚úù i j hij))\ncocycle‚úù : ‚àÄ (i j k : J‚úù) (hij : Ne i j) (hik : Ne i k) (hjk : Ne j k), Eq (CategoryTheory.CategoryStruct.comp (t'‚úù i j k hij hik hjk) (CategoryTheory.CategoryStruct.comp (t'‚úù j k i hjk ‚ãØ ‚ãØ) (t'‚úù k i j ‚ãØ ‚ãØ hij))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback (f‚úù i j hij) (f‚úù i k hik)))\nJ : Type v\nU : J ‚Üí C\nV : (i j : J) ‚Üí Ne i j ‚Üí C\nf : (i j : J) ‚Üí (h : Ne i j) ‚Üí Quiver.Hom (V i j h) (U i)\nf_mono : autoParam (‚àÄ (i j : J) (h : Ne i j), CategoryTheory.Mono (f i j h)) _auto‚úù\nf_hasPullback : autoParam (‚àÄ (i j k : J) (hij : Ne i j) (hik : Ne i k), CategoryTheory.Limits.HasPullback (f i j hij) (f i k hik)) _auto‚úù\nt : (i j : J) ‚Üí (h : Ne i j) ‚Üí Quiver.Hom (V i j h) (V j i ‚ãØ)\nt' : (i j k : J) ‚Üí (hij : Ne i j) ‚Üí (hik : Ne i k) ‚Üí (hjk : Ne j k) ‚Üí Quiver.Hom (CategoryTheory.Limits.pullback (f i j hij) (f i k hik)) (CategoryTheory.Limits.pullback (f j k hjk) (f j i ‚ãØ))\nt_fac : ‚àÄ (i j k : J) (hij : Ne i j) (hik : Ne i k) (hjk : Ne j k), Eq (CategoryTheory.CategoryStruct.comp (t' i j k hij hik hjk) (CategoryTheory.Limits.pullback.snd (f j k hjk) (f j i ‚ãØ))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (f i j hij) (f i k hik)) (t i j hij))\nt_inv : ‚àÄ (i j : J) (hij : Ne i j), Eq (CategoryTheory.CategoryStruct.comp (t i j hij) (t j i ‚ãØ)) (CategoryTheory.CategoryStruct.id (V i j hij))\ncocycle : ‚àÄ (i j k : J) (hij : Ne i j) (hik : Ne i k) (hjk : Ne j k), Eq (CategoryTheory.CategoryStruct.comp (t' i j k hij hik hjk) (CategoryTheory.CategoryStruct.comp (t' j k i hjk ‚ãØ ‚ãØ) (t' k i j ‚ãØ ‚ãØ hij))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback (f i j hij) (f i k hik)))\n‚ä¢ Eq (Eq { J := J‚úù, U := U‚úù, V := V‚úù, f := f‚úù, f_mono := f_mono‚úù, f_hasPullback := f_hasPullback‚úù, t := t‚úù, t' := t'‚úù, t_fac := t_fac‚úù, t_inv := t_inv‚úù, cocycle := cocycle‚úù } { J := J, U := U, V := V, f := f, f_mono := f_mono, f_hasPullback := f_hasPullback, t := t, t' := t', t_fac := t_fac, t_inv := t_inv, cocycle := cocycle }) (And (Eq J‚úù J) (And (HEq U‚úù U) (And (HEq V‚úù V) (And (HEq f‚úù f) (And (HEq t‚úù t) (HEq t'‚úù t'))))))","decl":"/--\nThis is a variant of `GlueData` that only requires conditions on `V (i, j)` when `i ‚â† j`.\nSee `GlueData.ofGlueData'`\n-/\nstructure GlueData' where\n  /-- Indexing type of a glue data. -/\n  J : Type v\n  /-- Objects of a glue data to be glued. -/\n  U : J ‚Üí C\n  /-- Objects representing the intersections. -/\n  V : ‚àÄ (i j : J), i ‚â† j ‚Üí C\n  /-- The inclusion maps of the intersection into the object. -/\n  f : ‚àÄ i j h, V i j h ‚ü∂ U i\n  f_mono : ‚àÄ i j h, Mono (f i j h) := by infer_instance\n  f_hasPullback : ‚àÄ i j k hij hik, HasPullback (f i j hij) (f i k hik) := by infer_instance\n  /-- The transition maps between the intersections. -/\n  t : ‚àÄ i j h, V i j h ‚ü∂ V j i h.symm\n  /-- The transition maps between the intersection of intersections. -/\n  t' : ‚àÄ i j k hij hik hjk,\n    pullback (f i j hij) (f i k hik) ‚ü∂ pullback (f j k hjk) (f j i hij.symm)\n  t_fac : ‚àÄ i j k hij hik hjk, t' i j k hij hik hjk ‚â´ pullback.snd _ _ =\n    pullback.fst _ _ ‚â´ t i j hij\n  t_inv : ‚àÄ i j hij, t i j hij ‚â´ t j i hij.symm = ùüô _\n  cocycle : ‚àÄ i j k hij hik hjk, t' i j k hij hik hjk ‚â´\n    t' j k i hjk hij.symm hik.symm ‚â´ t' k i j hik.symm hjk.symm hij = ùüô _\n\n"}
{"name":"CategoryTheory.GlueData'.f_mono","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nself : CategoryTheory.GlueData' C\ni j : self.J\nh : Ne i j\n‚ä¢ CategoryTheory.Mono (self.f i j h)","decl":"/--\nThis is a variant of `GlueData` that only requires conditions on `V (i, j)` when `i ‚â† j`.\nSee `GlueData.ofGlueData'`\n-/\nstructure GlueData' where\n  /-- Indexing type of a glue data. -/\n  J : Type v\n  /-- Objects of a glue data to be glued. -/\n  U : J ‚Üí C\n  /-- Objects representing the intersections. -/\n  V : ‚àÄ (i j : J), i ‚â† j ‚Üí C\n  /-- The inclusion maps of the intersection into the object. -/\n  f : ‚àÄ i j h, V i j h ‚ü∂ U i\n  f_mono : ‚àÄ i j h, Mono (f i j h) := by infer_instance\n  f_hasPullback : ‚àÄ i j k hij hik, HasPullback (f i j hij) (f i k hik) := by infer_instance\n  /-- The transition maps between the intersections. -/\n  t : ‚àÄ i j h, V i j h ‚ü∂ V j i h.symm\n  /-- The transition maps between the intersection of intersections. -/\n  t' : ‚àÄ i j k hij hik hjk,\n    pullback (f i j hij) (f i k hik) ‚ü∂ pullback (f j k hjk) (f j i hij.symm)\n  t_fac : ‚àÄ i j k hij hik hjk, t' i j k hij hik hjk ‚â´ pullback.snd _ _ =\n    pullback.fst _ _ ‚â´ t i j hij\n  t_inv : ‚àÄ i j hij, t i j hij ‚â´ t j i hij.symm = ùüô _\n  cocycle : ‚àÄ i j k hij hik hjk, t' i j k hij hik hjk ‚â´\n    t' j k i hjk hij.symm hik.symm ‚â´ t' k i j hik.symm hjk.symm hij = ùüô _\n\n"}
{"name":"CategoryTheory.GlueData'.f_hasPullback","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nself : CategoryTheory.GlueData' C\ni j k : self.J\nhij : Ne i j\nhik : Ne i k\n‚ä¢ CategoryTheory.Limits.HasPullback (self.f i j hij) (self.f i k hik)","decl":"/--\nThis is a variant of `GlueData` that only requires conditions on `V (i, j)` when `i ‚â† j`.\nSee `GlueData.ofGlueData'`\n-/\nstructure GlueData' where\n  /-- Indexing type of a glue data. -/\n  J : Type v\n  /-- Objects of a glue data to be glued. -/\n  U : J ‚Üí C\n  /-- Objects representing the intersections. -/\n  V : ‚àÄ (i j : J), i ‚â† j ‚Üí C\n  /-- The inclusion maps of the intersection into the object. -/\n  f : ‚àÄ i j h, V i j h ‚ü∂ U i\n  f_mono : ‚àÄ i j h, Mono (f i j h) := by infer_instance\n  f_hasPullback : ‚àÄ i j k hij hik, HasPullback (f i j hij) (f i k hik) := by infer_instance\n  /-- The transition maps between the intersections. -/\n  t : ‚àÄ i j h, V i j h ‚ü∂ V j i h.symm\n  /-- The transition maps between the intersection of intersections. -/\n  t' : ‚àÄ i j k hij hik hjk,\n    pullback (f i j hij) (f i k hik) ‚ü∂ pullback (f j k hjk) (f j i hij.symm)\n  t_fac : ‚àÄ i j k hij hik hjk, t' i j k hij hik hjk ‚â´ pullback.snd _ _ =\n    pullback.fst _ _ ‚â´ t i j hij\n  t_inv : ‚àÄ i j hij, t i j hij ‚â´ t j i hij.symm = ùüô _\n  cocycle : ‚àÄ i j k hij hik hjk, t' i j k hij hik hjk ‚â´\n    t' j k i hjk hij.symm hik.symm ‚â´ t' k i j hik.symm hjk.symm hij = ùüô _\n\n"}
{"name":"CategoryTheory.GlueData'.cocycle","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nself : CategoryTheory.GlueData' C\ni j k : self.J\nhij : Ne i j\nhik : Ne i k\nhjk : Ne j k\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.t' i j k hij hik hjk) (CategoryTheory.CategoryStruct.comp (self.t' j k i hjk ‚ãØ ‚ãØ) (self.t' k i j ‚ãØ ‚ãØ hij))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback (self.f i j hij) (self.f i k hik)))","decl":"/--\nThis is a variant of `GlueData` that only requires conditions on `V (i, j)` when `i ‚â† j`.\nSee `GlueData.ofGlueData'`\n-/\nstructure GlueData' where\n  /-- Indexing type of a glue data. -/\n  J : Type v\n  /-- Objects of a glue data to be glued. -/\n  U : J ‚Üí C\n  /-- Objects representing the intersections. -/\n  V : ‚àÄ (i j : J), i ‚â† j ‚Üí C\n  /-- The inclusion maps of the intersection into the object. -/\n  f : ‚àÄ i j h, V i j h ‚ü∂ U i\n  f_mono : ‚àÄ i j h, Mono (f i j h) := by infer_instance\n  f_hasPullback : ‚àÄ i j k hij hik, HasPullback (f i j hij) (f i k hik) := by infer_instance\n  /-- The transition maps between the intersections. -/\n  t : ‚àÄ i j h, V i j h ‚ü∂ V j i h.symm\n  /-- The transition maps between the intersection of intersections. -/\n  t' : ‚àÄ i j k hij hik hjk,\n    pullback (f i j hij) (f i k hik) ‚ü∂ pullback (f j k hjk) (f j i hij.symm)\n  t_fac : ‚àÄ i j k hij hik hjk, t' i j k hij hik hjk ‚â´ pullback.snd _ _ =\n    pullback.fst _ _ ‚â´ t i j hij\n  t_inv : ‚àÄ i j hij, t i j hij ‚â´ t j i hij.symm = ùüô _\n  cocycle : ‚àÄ i j k hij hik hjk, t' i j k hij hik hjk ‚â´\n    t' j k i hjk hij.symm hik.symm ‚â´ t' k i j hik.symm hjk.symm hij = ùüô _\n\n"}
{"name":"CategoryTheory.GlueData'.t_inv","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nself : CategoryTheory.GlueData' C\ni j : self.J\nhij : Ne i j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.t i j hij) (self.t j i ‚ãØ)) (CategoryTheory.CategoryStruct.id (self.V i j hij))","decl":"/--\nThis is a variant of `GlueData` that only requires conditions on `V (i, j)` when `i ‚â† j`.\nSee `GlueData.ofGlueData'`\n-/\nstructure GlueData' where\n  /-- Indexing type of a glue data. -/\n  J : Type v\n  /-- Objects of a glue data to be glued. -/\n  U : J ‚Üí C\n  /-- Objects representing the intersections. -/\n  V : ‚àÄ (i j : J), i ‚â† j ‚Üí C\n  /-- The inclusion maps of the intersection into the object. -/\n  f : ‚àÄ i j h, V i j h ‚ü∂ U i\n  f_mono : ‚àÄ i j h, Mono (f i j h) := by infer_instance\n  f_hasPullback : ‚àÄ i j k hij hik, HasPullback (f i j hij) (f i k hik) := by infer_instance\n  /-- The transition maps between the intersections. -/\n  t : ‚àÄ i j h, V i j h ‚ü∂ V j i h.symm\n  /-- The transition maps between the intersection of intersections. -/\n  t' : ‚àÄ i j k hij hik hjk,\n    pullback (f i j hij) (f i k hik) ‚ü∂ pullback (f j k hjk) (f j i hij.symm)\n  t_fac : ‚àÄ i j k hij hik hjk, t' i j k hij hik hjk ‚â´ pullback.snd _ _ =\n    pullback.fst _ _ ‚â´ t i j hij\n  t_inv : ‚àÄ i j hij, t i j hij ‚â´ t j i hij.symm = ùüô _\n  cocycle : ‚àÄ i j k hij hik hjk, t' i j k hij hik hjk ‚â´\n    t' j k i hjk hij.symm hik.symm ‚â´ t' k i j hik.symm hjk.symm hij = ùüô _\n\n"}
{"name":"CategoryTheory.GlueData'.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v, u‚ÇÅ} C\ninst‚úù : SizeOf C\nJ : Type v\nU : J ‚Üí C\nV : (i j : J) ‚Üí Ne i j ‚Üí C\nf : (i j : J) ‚Üí (h : Ne i j) ‚Üí Quiver.Hom (V i j h) (U i)\nf_mono : autoParam (‚àÄ (i j : J) (h : Ne i j), CategoryTheory.Mono (f i j h)) _auto‚úù\nf_hasPullback : autoParam (‚àÄ (i j k : J) (hij : Ne i j) (hik : Ne i k), CategoryTheory.Limits.HasPullback (f i j hij) (f i k hik)) _auto‚úù\nt : (i j : J) ‚Üí (h : Ne i j) ‚Üí Quiver.Hom (V i j h) (V j i ‚ãØ)\nt' : (i j k : J) ‚Üí (hij : Ne i j) ‚Üí (hik : Ne i k) ‚Üí (hjk : Ne j k) ‚Üí Quiver.Hom (CategoryTheory.Limits.pullback (f i j hij) (f i k hik)) (CategoryTheory.Limits.pullback (f j k hjk) (f j i ‚ãØ))\nt_fac : ‚àÄ (i j k : J) (hij : Ne i j) (hik : Ne i k) (hjk : Ne j k), Eq (CategoryTheory.CategoryStruct.comp (t' i j k hij hik hjk) (CategoryTheory.Limits.pullback.snd (f j k hjk) (f j i ‚ãØ))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (f i j hij) (f i k hik)) (t i j hij))\nt_inv : ‚àÄ (i j : J) (hij : Ne i j), Eq (CategoryTheory.CategoryStruct.comp (t i j hij) (t j i ‚ãØ)) (CategoryTheory.CategoryStruct.id (V i j hij))\ncocycle : ‚àÄ (i j k : J) (hij : Ne i j) (hik : Ne i k) (hjk : Ne j k), Eq (CategoryTheory.CategoryStruct.comp (t' i j k hij hik hjk) (CategoryTheory.CategoryStruct.comp (t' j k i hjk ‚ãØ ‚ãØ) (t' k i j ‚ãØ ‚ãØ hij))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback (f i j hij) (f i k hik)))\n‚ä¢ Eq (SizeOf.sizeOf { J := J, U := U, V := V, f := f, f_mono := f_mono, f_hasPullback := f_hasPullback, t := t, t' := t', t_fac := t_fac, t_inv := t_inv, cocycle := cocycle }) (HAdd.hAdd 1 (SizeOf.sizeOf J))","decl":"/--\nThis is a variant of `GlueData` that only requires conditions on `V (i, j)` when `i ‚â† j`.\nSee `GlueData.ofGlueData'`\n-/\nstructure GlueData' where\n  /-- Indexing type of a glue data. -/\n  J : Type v\n  /-- Objects of a glue data to be glued. -/\n  U : J ‚Üí C\n  /-- Objects representing the intersections. -/\n  V : ‚àÄ (i j : J), i ‚â† j ‚Üí C\n  /-- The inclusion maps of the intersection into the object. -/\n  f : ‚àÄ i j h, V i j h ‚ü∂ U i\n  f_mono : ‚àÄ i j h, Mono (f i j h) := by infer_instance\n  f_hasPullback : ‚àÄ i j k hij hik, HasPullback (f i j hij) (f i k hik) := by infer_instance\n  /-- The transition maps between the intersections. -/\n  t : ‚àÄ i j h, V i j h ‚ü∂ V j i h.symm\n  /-- The transition maps between the intersection of intersections. -/\n  t' : ‚àÄ i j k hij hik hjk,\n    pullback (f i j hij) (f i k hik) ‚ü∂ pullback (f j k hjk) (f j i hij.symm)\n  t_fac : ‚àÄ i j k hij hik hjk, t' i j k hij hik hjk ‚â´ pullback.snd _ _ =\n    pullback.fst _ _ ‚â´ t i j hij\n  t_inv : ‚àÄ i j hij, t i j hij ‚â´ t j i hij.symm = ùüô _\n  cocycle : ‚àÄ i j k hij hik hjk, t' i j k hij hik hjk ‚â´\n    t' j k i hjk hij.symm hik.symm ‚â´ t' k i j hik.symm hjk.symm hij = ùüô _\n\n"}
{"name":"CategoryTheory.GlueData'.t_fac","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nself : CategoryTheory.GlueData' C\ni j k : self.J\nhij : Ne i j\nhik : Ne i k\nhjk : Ne j k\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.t' i j k hij hik hjk) (CategoryTheory.Limits.pullback.snd (self.f j k hjk) (self.f j i ‚ãØ))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (self.f i j hij) (self.f i k hik)) (self.t i j hij))","decl":"/--\nThis is a variant of `GlueData` that only requires conditions on `V (i, j)` when `i ‚â† j`.\nSee `GlueData.ofGlueData'`\n-/\nstructure GlueData' where\n  /-- Indexing type of a glue data. -/\n  J : Type v\n  /-- Objects of a glue data to be glued. -/\n  U : J ‚Üí C\n  /-- Objects representing the intersections. -/\n  V : ‚àÄ (i j : J), i ‚â† j ‚Üí C\n  /-- The inclusion maps of the intersection into the object. -/\n  f : ‚àÄ i j h, V i j h ‚ü∂ U i\n  f_mono : ‚àÄ i j h, Mono (f i j h) := by infer_instance\n  f_hasPullback : ‚àÄ i j k hij hik, HasPullback (f i j hij) (f i k hik) := by infer_instance\n  /-- The transition maps between the intersections. -/\n  t : ‚àÄ i j h, V i j h ‚ü∂ V j i h.symm\n  /-- The transition maps between the intersection of intersections. -/\n  t' : ‚àÄ i j k hij hik hjk,\n    pullback (f i j hij) (f i k hik) ‚ü∂ pullback (f j k hjk) (f j i hij.symm)\n  t_fac : ‚àÄ i j k hij hik hjk, t' i j k hij hik hjk ‚â´ pullback.snd _ _ =\n    pullback.fst _ _ ‚â´ t i j hij\n  t_inv : ‚àÄ i j hij, t i j hij ‚â´ t j i hij.symm = ùüô _\n  cocycle : ‚àÄ i j k hij hik hjk, t' i j k hij hik hjk ‚â´\n    t' j k i hjk hij.symm hik.symm ‚â´ t' k i j hik.symm hjk.symm hij = ùüô _\n\n"}
{"name":"CategoryTheory.GlueData'.cocycle_assoc","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nself : CategoryTheory.GlueData' C\ni j k : self.J\nhij : Ne i j\nhik : Ne i k\nhjk : Ne j k\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pullback (self.f i j hij) (self.f i k ‚ãØ)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.t' i j k hij hik hjk) (CategoryTheory.CategoryStruct.comp (self.t' j k i hjk ‚ãØ ‚ãØ) (CategoryTheory.CategoryStruct.comp (self.t' k i j ‚ãØ ‚ãØ hij) h))) h","decl":"attribute [reassoc (attr := simp)] GlueData'.t_inv GlueData'.cocycle\n\n"}
{"name":"CategoryTheory.GlueData'.t_inv_assoc","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nself : CategoryTheory.GlueData' C\ni j : self.J\nhij : Ne i j\nZ : C\nh : Quiver.Hom (self.V i j ‚ãØ) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.t i j hij) (CategoryTheory.CategoryStruct.comp (self.t j i ‚ãØ) h)) h","decl":"attribute [reassoc (attr := simp)] GlueData'.t_inv GlueData'.cocycle\n\n"}
{"name":"CategoryTheory.instMonoF'","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nD : CategoryTheory.GlueData' C\ni j : D.J\n‚ä¢ CategoryTheory.Mono (D.f' i j)","decl":"instance (D : GlueData' C) (i j : D.J) :\n    Mono (D.f' i j) := by dsimp [GlueData'.f']; split_ifs <;> infer_instance\n\n"}
{"name":"CategoryTheory.instIsIsoF'","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nD : CategoryTheory.GlueData' C\ni : D.J\n‚ä¢ CategoryTheory.IsIso (D.f' i i)","decl":"instance (D : GlueData' C) (i : D.J) :\n    IsIso (D.f' i i) := by simp only [GlueData'.f', ‚ÜìreduceDIte]; infer_instance\n\n"}
{"name":"CategoryTheory.instHasPullbackF'","module":"Mathlib.CategoryTheory.GlueData","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v, u‚ÇÅ} C\nD : CategoryTheory.GlueData' C\ni j k : D.J\n‚ä¢ CategoryTheory.Limits.HasPullback (D.f' i j) (D.f' i k)","decl":"instance (D : GlueData' C) (i j k : D.J) :\n    HasPullback (D.f' i j) (D.f' i k) := by\n  if hij : i = j then\n    apply (config := { allowSynthFailures := true}) hasPullback_of_left_iso\n    simp only [GlueData'.f', dif_pos hij]\n    infer_instance\n  else if hik : i = k then\n    apply (config := { allowSynthFailures := true}) hasPullback_of_right_iso\n    simp only [GlueData'.f', dif_pos hik]\n    infer_instance\n  else\n    have {X Y Z : C} (f : X ‚ü∂ Y) (e : Z = X) : HEq (eqToHom e ‚â´ f) f := by subst e; simp\n    convert D.f_hasPullback i j k hij hik <;> simp [GlueData'.f', hij, hik, this]\n\n"}
