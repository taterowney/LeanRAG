{"name":"NormedSpace.exp_continuousMap_eq","module":"Mathlib.Analysis.SpecialFunctions.ContinuousFunctionalCalculus.ExpLog","initialProofState":"𝕜 : Type u_1\nα : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : TopologicalSpace α\ninst✝ : CompactSpace α\nf : ContinuousMap α 𝕜\n⊢ Eq (NormedSpace.exp 𝕜 f) { toFun := Function.comp (NormedSpace.exp 𝕜) ⇑f, continuous_toFun := ⋯ }","decl":"lemma NormedSpace.exp_continuousMap_eq (f : C(α, 𝕜)) :\n    exp 𝕜 f = (⟨exp 𝕜 ∘ f, exp_continuous.comp f.continuous⟩ : C(α, 𝕜)) := by\n  ext a\n  simp only [Function.comp_apply, NormedSpace.exp, FormalMultilinearSeries.sum]\n  have h_sum := NormedSpace.expSeries_summable (𝕂 := 𝕜) f\n  simp_rw [← ContinuousMap.tsum_apply h_sum a, NormedSpace.expSeries_apply_eq]\n  simp [NormedSpace.exp_eq_tsum]\n\n"}
{"name":"CFC.exp_eq_normedSpace_exp","module":"Mathlib.Analysis.SpecialFunctions.ContinuousFunctionalCalculus.ExpLog","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁶ : RCLike 𝕜\np : A → Prop\ninst✝⁵ : NormedRing A\ninst✝⁴ : StarRing A\ninst✝³ : TopologicalRing A\ninst✝² : NormedAlgebra 𝕜 A\ninst✝¹ : CompleteSpace A\ninst✝ : ContinuousFunctionalCalculus 𝕜 p\na : A\nha : autoParam (p a) _auto✝\n⊢ Eq (cfc (NormedSpace.exp 𝕜) a) (NormedSpace.exp 𝕜 a)","decl":"lemma exp_eq_normedSpace_exp {a : A} (ha : p a := by cfc_tac) :\n    cfc (exp 𝕜 : 𝕜 → 𝕜) a = exp 𝕜 a := by\n  conv_rhs => rw [← cfc_id 𝕜 a ha, cfc_apply id a ha]\n  have h := (cfcHom_isClosedEmbedding (R := 𝕜) (show p a from ha)).continuous\n  have _ : ContinuousOn (exp 𝕜) (spectrum 𝕜 a) := exp_continuous.continuousOn\n  simp_rw [← map_exp 𝕜 _ h, cfc_apply (exp 𝕜) a ha]\n  congr 1\n  ext\n  simp [exp_continuousMap_eq]\n\n"}
{"name":"CFC.real_exp_eq_normedSpace_exp","module":"Mathlib.Analysis.SpecialFunctions.ContinuousFunctionalCalculus.ExpLog","initialProofState":"A : Type u_1\ninst✝⁵ : NormedRing A\ninst✝⁴ : StarRing A\ninst✝³ : TopologicalRing A\ninst✝² : NormedAlgebra Real A\ninst✝¹ : CompleteSpace A\ninst✝ : ContinuousFunctionalCalculus Real IsSelfAdjoint\na : A\nha : autoParam (IsSelfAdjoint a) _auto✝\n⊢ Eq (cfc Real.exp a) (NormedSpace.exp Real a)","decl":"lemma real_exp_eq_normedSpace_exp {a : A} (ha : IsSelfAdjoint a := by cfc_tac) :\n    cfc Real.exp a = exp ℝ a :=\n  Real.exp_eq_exp_ℝ ▸ exp_eq_normedSpace_exp ha\n\n"}
{"name":"IsSelfAdjoint.exp_nonneg","module":"Mathlib.Analysis.SpecialFunctions.ContinuousFunctionalCalculus.ExpLog","initialProofState":"A : Type u_1\ninst✝⁹ : NormedRing A\ninst✝⁸ : StarRing A\ninst✝⁷ : TopologicalRing A\ninst✝⁶ : NormedAlgebra Real A\ninst✝⁵ : CompleteSpace A\ninst✝⁴ : ContinuousFunctionalCalculus Real IsSelfAdjoint\n𝕜 : Type u_2\ninst✝³ : Field 𝕜\ninst✝² : Algebra 𝕜 A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na : A\nha : IsSelfAdjoint a\n⊢ LE.le 0 (NormedSpace.exp 𝕜 a)","decl":"@[aesop safe apply (rule_sets := [CStarAlgebra])]\nlemma _root_.IsSelfAdjoint.exp_nonneg {𝕜 : Type*} [Field 𝕜] [Algebra 𝕜 A]\n    [PartialOrder A] [StarOrderedRing A] {a : A} (ha : IsSelfAdjoint a) :\n    0 ≤ exp 𝕜 a := by\n  rw [exp_eq_exp 𝕜 ℝ, ← real_exp_eq_normedSpace_exp]\n  exact cfc_nonneg fun x _ => Real.exp_nonneg x\n\n"}
{"name":"CFC.complex_exp_eq_normedSpace_exp","module":"Mathlib.Analysis.SpecialFunctions.ContinuousFunctionalCalculus.ExpLog","initialProofState":"A : Type u_1\np : A → Prop\ninst✝⁴ : NormedRing A\ninst✝³ : StarRing A\ninst✝² : NormedAlgebra Complex A\ninst✝¹ : CompleteSpace A\ninst✝ : ContinuousFunctionalCalculus Complex p\na : A\nha : autoParam (p a) _auto✝\n⊢ Eq (cfc Complex.exp a) (NormedSpace.exp Complex a)","decl":"lemma complex_exp_eq_normedSpace_exp {a : A} (ha : p a := by cfc_tac) :\n    cfc Complex.exp a = exp ℂ a :=\n  Complex.exp_eq_exp_ℂ ▸ exp_eq_normedSpace_exp ha\n\n"}
{"name":"IsSelfAdjoint.log","module":"Mathlib.Analysis.SpecialFunctions.ContinuousFunctionalCalculus.ExpLog","initialProofState":"A : Type u_1\ninst✝³ : NormedRing A\ninst✝² : StarRing A\ninst✝¹ : NormedAlgebra Real A\ninst✝ : ContinuousFunctionalCalculus Real IsSelfAdjoint\na : A\n⊢ IsSelfAdjoint (CFC.log a)","decl":"@[simp]\nprotected lemma _root_.IsSelfAdjoint.log {a : A} : IsSelfAdjoint (log a) := cfc_predicate _ a\n\n\n"}
{"name":"CFC.log_zero","module":"Mathlib.Analysis.SpecialFunctions.ContinuousFunctionalCalculus.ExpLog","initialProofState":"A : Type u_1\ninst✝³ : NormedRing A\ninst✝² : StarRing A\ninst✝¹ : NormedAlgebra Real A\ninst✝ : ContinuousFunctionalCalculus Real IsSelfAdjoint\n⊢ Eq (CFC.log 0) 0","decl":"@[simp] lemma log_zero : log (0 : A) = 0 := by simp [log]\n\n"}
{"name":"CFC.log_one","module":"Mathlib.Analysis.SpecialFunctions.ContinuousFunctionalCalculus.ExpLog","initialProofState":"A : Type u_1\ninst✝³ : NormedRing A\ninst✝² : StarRing A\ninst✝¹ : NormedAlgebra Real A\ninst✝ : ContinuousFunctionalCalculus Real IsSelfAdjoint\n⊢ Eq (CFC.log 1) 0","decl":"@[simp] lemma log_one : log (1 : A) = 0 := by simp [log]\n\n"}
{"name":"CFC.log_algebraMap","module":"Mathlib.Analysis.SpecialFunctions.ContinuousFunctionalCalculus.ExpLog","initialProofState":"A : Type u_1\ninst✝³ : NormedRing A\ninst✝² : StarRing A\ninst✝¹ : NormedAlgebra Real A\ninst✝ : ContinuousFunctionalCalculus Real IsSelfAdjoint\nr : Real\n⊢ Eq (CFC.log ((algebraMap Real A) r)) ((algebraMap Real A) (Real.log r))","decl":"@[simp]\nlemma log_algebraMap {r : ℝ} : log (algebraMap ℝ A r) = algebraMap ℝ A (Real.log r) := by\n  simp [log]\n\n-- TODO: Relate the hypothesis to a notion of strict positivity\n"}
{"name":"CFC.log_smul","module":"Mathlib.Analysis.SpecialFunctions.ContinuousFunctionalCalculus.ExpLog","initialProofState":"A : Type u_1\ninst✝³ : NormedRing A\ninst✝² : StarRing A\ninst✝¹ : NormedAlgebra Real A\ninst✝ : ContinuousFunctionalCalculus Real IsSelfAdjoint\nr : Real\na : A\nha₂ : ∀ (x : Real), Membership.mem (spectrum Real a) x → LT.lt 0 x\nhr : LT.lt 0 r\nha₁ : autoParam (IsSelfAdjoint a) _auto✝\n⊢ Eq (CFC.log (HSMul.hSMul r a)) (HAdd.hAdd ((algebraMap Real A) (Real.log r)) (CFC.log a))","decl":"lemma log_smul {r : ℝ} (a : A) (ha₂ : ∀ x ∈ spectrum ℝ a, 0 < x) (hr : 0 < r)\n    (ha₁ : IsSelfAdjoint a := by cfc_tac) :\n    log (r • a) = algebraMap ℝ A (Real.log r) + log a := by\n  have : ∀ x ∈ spectrum ℝ a, x ≠ 0 := by peel ha₂ with x hx h; exact h.ne'\n  rw [log, ← cfc_smul_id (R := ℝ) r a, ← cfc_comp Real.log (r • ·) a, log]\n  calc\n    _ = cfc (fun z => Real.log r + Real.log z) a :=\n      cfc_congr (Real.log_mul hr.ne' <| ne_of_gt <| ha₂ · ·)\n    _ = _ := by rw [cfc_const_add _ _ _]\n\n-- TODO: Relate the hypothesis to a notion of strict positivity\n"}
{"name":"CFC.log_pow","module":"Mathlib.Analysis.SpecialFunctions.ContinuousFunctionalCalculus.ExpLog","initialProofState":"A : Type u_1\ninst✝³ : NormedRing A\ninst✝² : StarRing A\ninst✝¹ : NormedAlgebra Real A\ninst✝ : ContinuousFunctionalCalculus Real IsSelfAdjoint\nn : Nat\na : A\nha₂ : ∀ (x : Real), Membership.mem (spectrum Real a) x → LT.lt 0 x\nha₁ : autoParam (IsSelfAdjoint a) _auto✝\n⊢ Eq (CFC.log (HPow.hPow a n)) (HSMul.hSMul n (CFC.log a))","decl":"lemma log_pow (n : ℕ) (a : A) (ha₂ : ∀ x ∈ spectrum ℝ a, 0 < x)\n    (ha₁ : IsSelfAdjoint a := by cfc_tac) : log (a ^ n) = n • log a := by\n  have : ∀ x ∈ spectrum ℝ a, x ≠ 0 := by peel ha₂ with x hx h; exact h.ne'\n  have ha₂' : ContinuousOn Real.log (spectrum ℝ a) := by fun_prop (disch := assumption)\n  have ha₂'' : ContinuousOn Real.log ((· ^ n) '' spectrum ℝ a)  := by fun_prop (disch := aesop)\n  rw [log, ← cfc_pow_id (R := ℝ) a n ha₁, ← cfc_comp' Real.log (· ^ n) a ha₂'', log]\n  simp_rw [Real.log_pow, ← Nat.cast_smul_eq_nsmul ℝ n, cfc_const_mul (n : ℝ) Real.log a ha₂']\n\n"}
{"name":"CFC.log_exp","module":"Mathlib.Analysis.SpecialFunctions.ContinuousFunctionalCalculus.ExpLog","initialProofState":"A : Type u_1\ninst✝⁴ : NormedRing A\ninst✝³ : StarRing A\ninst✝² : NormedAlgebra Real A\ninst✝¹ : ContinuousFunctionalCalculus Real IsSelfAdjoint\ninst✝ : CompleteSpace A\na : A\nha : autoParam (IsSelfAdjoint a) _auto✝\n⊢ Eq (CFC.log (NormedSpace.exp Real a)) a","decl":"lemma log_exp (a : A) (ha : IsSelfAdjoint a := by cfc_tac) : log (NormedSpace.exp ℝ a) = a := by\n  have hcont : ContinuousOn Real.log (Real.exp '' spectrum ℝ a) := by fun_prop (disch := simp)\n  rw [log, ← real_exp_eq_normedSpace_exp, ← cfc_comp' Real.log Real.exp a hcont]\n  simp [cfc_id' (R := ℝ) a]\n\n-- TODO: Relate the hypothesis to a notion of strict positivity\n"}
{"name":"CFC.exp_log","module":"Mathlib.Analysis.SpecialFunctions.ContinuousFunctionalCalculus.ExpLog","initialProofState":"A : Type u_1\ninst✝⁴ : NormedRing A\ninst✝³ : StarRing A\ninst✝² : NormedAlgebra Real A\ninst✝¹ : ContinuousFunctionalCalculus Real IsSelfAdjoint\ninst✝ : CompleteSpace A\na : A\nha₂ : ∀ (x : Real), Membership.mem (spectrum Real a) x → LT.lt 0 x\nha₁ : autoParam (IsSelfAdjoint a) _auto✝\n⊢ Eq (NormedSpace.exp Real (CFC.log a)) a","decl":"lemma exp_log (a : A) (ha₂ : ∀ x ∈ spectrum ℝ a, 0 < x) (ha₁ : IsSelfAdjoint a := by cfc_tac) :\n    NormedSpace.exp ℝ (log a) = a := by\n  have ha₃ : ContinuousOn Real.log (spectrum ℝ a) := by\n    have : ∀ x ∈ spectrum ℝ a, x ≠ 0 := by peel ha₂ with x hx h; exact h.ne'\n    fun_prop (disch := assumption)\n  rw [← real_exp_eq_normedSpace_exp .log, log, ← cfc_comp' Real.exp Real.log a (by fun_prop) ha₃]\n  conv_rhs => rw [← cfc_id (R := ℝ) a ha₁]\n  exact cfc_congr (Real.exp_log <| ha₂ · ·)\n\n"}
