{"name":"LinearMap.quotKerEquivRange_apply_mk","module":"Mathlib.LinearAlgebra.Isomorphisms","initialProofState":"R : Type u_1\nM : Type u_2\nM₂ : Type u_3\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nf : LinearMap (RingHom.id R) M M₂\nx : M\n⊢ Eq (↑(f.quotKerEquivRange (Submodule.Quotient.mk x))) (f x)","decl":"@[simp]\ntheorem quotKerEquivRange_apply_mk (x : M) :\n    (f.quotKerEquivRange (Submodule.Quotient.mk x) : M₂) = f x :=\n  rfl\n\n"}
{"name":"LinearMap.quotKerEquivRange_symm_apply_image","module":"Mathlib.LinearAlgebra.Isomorphisms","initialProofState":"R : Type u_1\nM : Type u_2\nM₂ : Type u_3\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nf : LinearMap (RingHom.id R) M M₂\nx : M\nh : Membership.mem (LinearMap.range f) (f x)\n⊢ Eq (f.quotKerEquivRange.symm ⟨f x, h⟩) ((LinearMap.ker f).mkQ x)","decl":"@[simp]\ntheorem quotKerEquivRange_symm_apply_image (x : M) (h : f x ∈ LinearMap.range f) :\n    f.quotKerEquivRange.symm ⟨f x, h⟩ = f.ker.mkQ x :=\n  f.quotKerEquivRange.symm_apply_apply (f.ker.mkQ x)\n\n-- Porting note: breaking up original definition of quotientInfToSupQuotient to avoid timing out\n"}
{"name":"LinearMap.comap_leq_ker_subToSupQuotient","module":"Mathlib.LinearAlgebra.Isomorphisms","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np p' : Submodule R M\n⊢ LE.le (Submodule.comap p.subtype (Min.min p p')) (LinearMap.ker (LinearMap.subToSupQuotient p p'))","decl":"theorem comap_leq_ker_subToSupQuotient (p p' : Submodule R M) :\n    comap (Submodule.subtype p) (p ⊓ p') ≤ ker (subToSupQuotient p p') := by\n  rw [LinearMap.ker_comp, Submodule.inclusion, comap_codRestrict, ker_mkQ, map_comap_subtype]\n  exact comap_mono (inf_le_inf_right _ le_sup_left)\n\n"}
{"name":"LinearMap.quotientInfEquivSupQuotient_injective","module":"Mathlib.LinearAlgebra.Isomorphisms","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np p' : Submodule R M\n⊢ Function.Injective ⇑(LinearMap.quotientInfToSupQuotient p p')","decl":"theorem quotientInfEquivSupQuotient_injective (p p' : Submodule R M) :\n    Function.Injective (quotientInfToSupQuotient p p') := by\n  rw [← ker_eq_bot, quotientInfToSupQuotient, ker_liftQ_eq_bot]\n  rw [ker_comp, ker_mkQ]\n  exact fun ⟨x, hx1⟩ hx2 => ⟨hx1, hx2⟩\n\n-- Porting note: breaking up original definition of quotientInfEquivSupQuotient to avoid timing out\n"}
{"name":"LinearMap.quotientInfEquivSupQuotient_surjective","module":"Mathlib.LinearAlgebra.Isomorphisms","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np p' : Submodule R M\n⊢ Function.Surjective ⇑(LinearMap.quotientInfToSupQuotient p p')","decl":"theorem quotientInfEquivSupQuotient_surjective (p p' : Submodule R M) :\n    Function.Surjective (quotientInfToSupQuotient p p') := by\n  rw [← range_eq_top, quotientInfToSupQuotient, range_liftQ, eq_top_iff']\n  rintro ⟨x, hx⟩; rcases mem_sup.1 hx with ⟨y, hy, z, hz, rfl⟩\n  use ⟨y, hy⟩; apply (Submodule.Quotient.eq _).2\n  simp only [mem_comap, map_sub, coe_subtype, coe_inclusion, sub_add_cancel_left, neg_mem_iff, hz]\n\n"}
{"name":"LinearMap.coe_quotientInfToSupQuotient","module":"Mathlib.LinearAlgebra.Isomorphisms","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np p' : Submodule R M\n⊢ Eq ⇑(LinearMap.quotientInfToSupQuotient p p') ⇑(LinearMap.quotientInfEquivSupQuotient p p')","decl":"theorem coe_quotientInfToSupQuotient (p p' : Submodule R M) :\n    ⇑(quotientInfToSupQuotient p p') = quotientInfEquivSupQuotient p p' :=\n  rfl\n\n"}
{"name":"LinearMap.quotientInfEquivSupQuotient_apply_mk","module":"Mathlib.LinearAlgebra.Isomorphisms","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np p' : Submodule R M\nx : Subtype fun x => Membership.mem p x\n⊢ let map := Submodule.inclusion ⋯;\n  Eq ((LinearMap.quotientInfEquivSupQuotient p p') (Submodule.Quotient.mk x)) (Submodule.Quotient.mk (map x))","decl":"theorem quotientInfEquivSupQuotient_apply_mk (p p' : Submodule R M) (x : p) :\n    let map := inclusion (le_sup_left : p ≤ p ⊔ p')\n    quotientInfEquivSupQuotient p p' (Submodule.Quotient.mk x) =\n      @Submodule.Quotient.mk R (p ⊔ p' : Submodule R M) _ _ _ (comap (p ⊔ p').subtype p') (map x) :=\n  rfl\n\n"}
{"name":"LinearMap.quotientInfEquivSupQuotient_symm_apply_left","module":"Mathlib.LinearAlgebra.Isomorphisms","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np p' : Submodule R M\nx : Subtype fun x => Membership.mem (Max.max p p') x\nhx : Membership.mem p ↑x\n⊢ Eq ((LinearMap.quotientInfEquivSupQuotient p p').symm (Submodule.Quotient.mk x)) (Submodule.Quotient.mk ⟨↑x, hx⟩)","decl":"theorem quotientInfEquivSupQuotient_symm_apply_left (p p' : Submodule R M) (x : ↥(p ⊔ p'))\n    (hx : (x : M) ∈ p) :\n    (quotientInfEquivSupQuotient p p').symm (Submodule.Quotient.mk x) =\n      Submodule.Quotient.mk ⟨x, hx⟩ :=\n  (LinearEquiv.symm_apply_eq _).2 <| by\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10745): was `simp`.\n    rw [quotientInfEquivSupQuotient_apply_mk, inclusion_apply]\n\n\n"}
{"name":"LinearMap.quotientInfEquivSupQuotient_symm_apply_eq_zero_iff","module":"Mathlib.LinearAlgebra.Isomorphisms","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np p' : Submodule R M\nx : Subtype fun x => Membership.mem (Max.max p p') x\n⊢ Iff (Eq ((LinearMap.quotientInfEquivSupQuotient p p').symm (Submodule.Quotient.mk x)) 0) (Membership.mem p' ↑x)","decl":"theorem quotientInfEquivSupQuotient_symm_apply_eq_zero_iff {p p' : Submodule R M} {x : ↥(p ⊔ p')} :\n    (quotientInfEquivSupQuotient p p').symm (Submodule.Quotient.mk x) = 0 ↔ (x : M) ∈ p' :=\n  (LinearEquiv.symm_apply_eq _).trans <| by simp\n\n"}
{"name":"LinearMap.quotientInfEquivSupQuotient_symm_apply_right","module":"Mathlib.LinearAlgebra.Isomorphisms","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np p' : Submodule R M\nx : Subtype fun x => Membership.mem (Max.max p p') x\nhx : Membership.mem p' ↑x\n⊢ Eq ((LinearMap.quotientInfEquivSupQuotient p p').symm (Submodule.Quotient.mk x)) 0","decl":"theorem quotientInfEquivSupQuotient_symm_apply_right (p p' : Submodule R M) {x : ↥(p ⊔ p')}\n    (hx : (x : M) ∈ p') : (quotientInfEquivSupQuotient p p').symm (Submodule.Quotient.mk x)\n    = 0 :=\n  quotientInfEquivSupQuotient_symm_apply_eq_zero_iff.2 hx\n\n"}
{"name":"Submodule.quotientQuotientEquivQuotientAux_mk","module":"Mathlib.LinearAlgebra.Isomorphisms","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nS T : Submodule R M\nh : LE.le S T\nx : HasQuotient.Quotient M S\n⊢ Eq ((S.quotientQuotientEquivQuotientAux T h) (Submodule.Quotient.mk x)) ((S.mapQ T LinearMap.id h) x)","decl":"@[simp]\ntheorem quotientQuotientEquivQuotientAux_mk (x : M ⧸ S) :\n    quotientQuotientEquivQuotientAux S T h (Quotient.mk x) = mapQ S T LinearMap.id h x :=\n  liftQ_apply _ _ _\n\n"}
{"name":"Submodule.quotientQuotientEquivQuotientAux_mk_mk","module":"Mathlib.LinearAlgebra.Isomorphisms","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nS T : Submodule R M\nh : LE.le S T\nx : M\n⊢ Eq ((S.quotientQuotientEquivQuotientAux T h) (Submodule.Quotient.mk (Submodule.Quotient.mk x))) (Submodule.Quotient.mk x)","decl":"@[simp]\ntheorem quotientQuotientEquivQuotientAux_mk_mk (x : M) :\n    quotientQuotientEquivQuotientAux S T h (Quotient.mk (Quotient.mk x)) = Quotient.mk x := by simp\n\n"}
{"name":"Submodule.card_quotient_mul_card_quotient","module":"Mathlib.LinearAlgebra.Isomorphisms","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nS T : Submodule R M\nhST : LE.le T S\n⊢ Eq (HMul.hMul (Nat.card (Subtype fun x => Membership.mem (Submodule.map T.mkQ S) x)) (Nat.card (HasQuotient.Quotient M S))) (Nat.card (HasQuotient.Quotient M T))","decl":"/-- Corollary of the third isomorphism theorem: `[S : T] [M : S] = [M : T]` -/\ntheorem card_quotient_mul_card_quotient (S T : Submodule R M) (hST : T ≤ S) :\n    Nat.card (S.map T.mkQ) * Nat.card (M ⧸ S) = Nat.card (M ⧸ T) := by\n  rw [Submodule.card_eq_card_quotient_mul_card (map T.mkQ S),\n    Nat.card_congr (quotientQuotientEquivQuotient T S hST).toEquiv]\n\n"}
