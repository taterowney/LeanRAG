{"name":"TopologicalSpace.Opens.mk.injEq","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\ncarrier✝ : Set α\nis_open'✝ : IsOpen carrier✝\ncarrier : Set α\nis_open' : IsOpen carrier\n⊢ Eq (Eq { carrier := carrier✝, is_open' := is_open'✝ } { carrier := carrier, is_open' := is_open' }) (Eq carrier✝ carrier)","decl":"/-- The type of open subsets of a topological space. -/\nstructure Opens where\n  /-- The underlying set of a bundled `TopologicalSpace.Opens` object. -/\n  carrier : Set α\n  /-- The `TopologicalSpace.Opens.carrier _` is an open set. -/\n  is_open' : IsOpen carrier\n\n"}
{"name":"TopologicalSpace.Opens.mk.inj","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\ncarrier✝ : Set α\nis_open'✝ : IsOpen carrier✝\ncarrier : Set α\nis_open' : IsOpen carrier\nx✝ : Eq { carrier := carrier✝, is_open' := is_open'✝ } { carrier := carrier, is_open' := is_open' }\n⊢ Eq carrier✝ carrier","decl":"/-- The type of open subsets of a topological space. -/\nstructure Opens where\n  /-- The underlying set of a bundled `TopologicalSpace.Opens` object. -/\n  carrier : Set α\n  /-- The `TopologicalSpace.Opens.carrier _` is an open set. -/\n  is_open' : IsOpen carrier\n\n"}
{"name":"TopologicalSpace.Opens.mk.sizeOf_spec","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : SizeOf α\ncarrier : Set α\nis_open' : IsOpen carrier\n⊢ Eq (SizeOf.sizeOf { carrier := carrier, is_open' := is_open' }) (HAdd.hAdd 1 (SizeOf.sizeOf is_open'))","decl":"/-- The type of open subsets of a topological space. -/\nstructure Opens where\n  /-- The underlying set of a bundled `TopologicalSpace.Opens` object. -/\n  carrier : Set α\n  /-- The `TopologicalSpace.Opens.carrier _` is an open set. -/\n  is_open' : IsOpen carrier\n\n"}
{"name":"TopologicalSpace.Opens.is_open'","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nself : TopologicalSpace.Opens α\n⊢ IsOpen self.carrier","decl":"/-- The type of open subsets of a topological space. -/\nstructure Opens where\n  /-- The underlying set of a bundled `TopologicalSpace.Opens` object. -/\n  carrier : Set α\n  /-- The `TopologicalSpace.Opens.carrier _` is an open set. -/\n  is_open' : IsOpen carrier\n\n"}
{"name":"TopologicalSpace.Opens.instCanLiftSetCoeIsOpen","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\n⊢ CanLift (Set α) (TopologicalSpace.Opens α) SetLike.coe IsOpen","decl":"instance : CanLift (Set α) (Opens α) (↑) IsOpen :=\n  ⟨fun s h => ⟨⟨s, h⟩, rfl⟩⟩\n\n"}
{"name":"TopologicalSpace.Opens.instSecondCountableOpens","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : SecondCountableTopology α\nU : TopologicalSpace.Opens α\n⊢ SecondCountableTopology (Subtype fun x => Membership.mem U x)","decl":"instance instSecondCountableOpens [SecondCountableTopology α] (U : Opens α) :\n    SecondCountableTopology U := inferInstanceAs (SecondCountableTopology U.1)\n\n"}
{"name":"TopologicalSpace.Opens.forall","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\np : TopologicalSpace.Opens α → Prop\n⊢ Iff (∀ (U : TopologicalSpace.Opens α), p U) (∀ (U : Set α) (hU : IsOpen U), p { carrier := U, is_open' := hU })","decl":"theorem «forall» {p : Opens α → Prop} : (∀ U, p U) ↔ ∀ (U : Set α) (hU : IsOpen U), p ⟨U, hU⟩ :=\n  ⟨fun h _ _ => h _, fun h _ => h _ _⟩\n\n"}
{"name":"TopologicalSpace.Opens.carrier_eq_coe","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nU : TopologicalSpace.Opens α\n⊢ Eq U.carrier ↑U","decl":"@[simp] theorem carrier_eq_coe (U : Opens α) : U.1 = ↑U := rfl\n\n"}
{"name":"TopologicalSpace.Opens.coe_mk","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nU : Set α\nhU : IsOpen U\n⊢ Eq (↑{ carrier := U, is_open' := hU }) U","decl":"/-- the coercion `Opens α → Set α` applied to a pair is the same as taking the first component -/\n@[simp]\ntheorem coe_mk {U : Set α} {hU : IsOpen U} : ↑(⟨U, hU⟩ : Opens α) = U :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.mem_mk","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nx : α\nU : Set α\nh : IsOpen U\n⊢ Iff (Membership.mem { carrier := U, is_open' := h } x) (Membership.mem U x)","decl":"@[simp]\ntheorem mem_mk {x : α} {U : Set α} {h : IsOpen U} : x ∈ mk U h ↔ x ∈ U := Iff.rfl\n\n"}
{"name":"TopologicalSpace.Opens.nonempty_coeSort","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nU : TopologicalSpace.Opens α\n⊢ Iff (Nonempty (Subtype fun x => Membership.mem U x)) (↑U).Nonempty","decl":"protected theorem nonempty_coeSort {U : Opens α} : Nonempty U ↔ (U : Set α).Nonempty :=\n  Set.nonempty_coe_sort\n\n-- TODO: should this theorem be proved for a `SetLike`?\n"}
{"name":"TopologicalSpace.Opens.nonempty_coe","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nU : TopologicalSpace.Opens α\n⊢ Iff (↑U).Nonempty (Exists fun x => Membership.mem U x)","decl":"protected theorem nonempty_coe {U : Opens α} : (U : Set α).Nonempty ↔ ∃ x, x ∈ U :=\n  Iff.rfl\n\n"}
{"name":"TopologicalSpace.Opens.ext_iff","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nU V : TopologicalSpace.Opens α\n⊢ Iff (Eq U V) (Eq ↑U ↑V)","decl":"@[ext] -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: replace with `∀ x, x ∈ U ↔ x ∈ V`\ntheorem ext {U V : Opens α} (h : (U : Set α) = V) : U = V :=\n  SetLike.coe_injective h\n\n"}
{"name":"TopologicalSpace.Opens.ext","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nU V : TopologicalSpace.Opens α\nh : Eq ↑U ↑V\n⊢ Eq U V","decl":"@[ext] -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: replace with `∀ x, x ∈ U ↔ x ∈ V`\ntheorem ext {U V : Opens α} (h : (U : Set α) = V) : U = V :=\n  SetLike.coe_injective h\n\n"}
{"name":"TopologicalSpace.Opens.coe_inj","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nU V : TopologicalSpace.Opens α\n⊢ Iff (Eq ↑U ↑V) (Eq U V)","decl":"theorem coe_inj {U V : Opens α} : (U : Set α) = V ↔ U = V :=\n  SetLike.ext'_iff.symm\n\n"}
{"name":"TopologicalSpace.Opens.isOpen","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nU : TopologicalSpace.Opens α\n⊢ IsOpen ↑U","decl":"protected theorem isOpen (U : Opens α) : IsOpen (U : Set α) :=\n  U.is_open'\n\n"}
{"name":"TopologicalSpace.Opens.mk_coe","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nU : TopologicalSpace.Opens α\n⊢ Eq { carrier := ↑U, is_open' := ⋯ } U","decl":"@[simp] theorem mk_coe (U : Opens α) : mk (↑U) U.isOpen = U := rfl\n\n"}
{"name":"TopologicalSpace.Opens.coe_interior","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\ns : Set α\n⊢ Eq (↑(TopologicalSpace.Opens.interior s)) (interior s)","decl":"/-- The interior of a set, as an element of `Opens`. -/\n@[simps]\nprotected def interior (s : Set α) : Opens α :=\n  ⟨interior s, isOpen_interior⟩\n\n"}
{"name":"TopologicalSpace.Opens.mem_interior","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\ns : Set α\nx : α\n⊢ Iff (Membership.mem (TopologicalSpace.Opens.interior s) x) (Membership.mem (interior s) x)","decl":"@[simp]\ntheorem mem_interior {s : Set α} {x : α} : x ∈ Opens.interior s ↔ x ∈ _root_.interior s := .rfl\n\n"}
{"name":"TopologicalSpace.Opens.gc","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\n⊢ GaloisConnection SetLike.coe TopologicalSpace.Opens.interior","decl":"theorem gc : GaloisConnection ((↑) : Opens α → Set α) Opens.interior := fun U _ =>\n  ⟨fun h => interior_maximal h U.isOpen, fun h => le_trans h interior_subset⟩\n\n"}
{"name":"TopologicalSpace.Opens.mk_inf_mk","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nU V : Set α\nhU : IsOpen U\nhV : IsOpen V\n⊢ Eq (Min.min { carrier := U, is_open' := hU } { carrier := V, is_open' := hV }) { carrier := Min.min U V, is_open' := ⋯ }","decl":"@[simp]\ntheorem mk_inf_mk {U V : Set α} {hU : IsOpen U} {hV : IsOpen V} :\n    (⟨U, hU⟩ ⊓ ⟨V, hV⟩ : Opens α) = ⟨U ⊓ V, IsOpen.inter hU hV⟩ :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.coe_inf","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\ns t : TopologicalSpace.Opens α\n⊢ Eq (↑(Min.min s t)) (Inter.inter ↑s ↑t)","decl":"@[simp, norm_cast]\ntheorem coe_inf (s t : Opens α) : (↑(s ⊓ t) : Set α) = ↑s ∩ ↑t :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.mem_inf","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\ns t : TopologicalSpace.Opens α\nx : α\n⊢ Iff (Membership.mem (Min.min s t) x) (And (Membership.mem s x) (Membership.mem t x))","decl":"@[simp]\nlemma mem_inf {s t : Opens α} {x : α} : x ∈ s ⊓ t ↔ x ∈ s ∧ x ∈ t := Iff.rfl\n\n"}
{"name":"TopologicalSpace.Opens.coe_sup","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\ns t : TopologicalSpace.Opens α\n⊢ Eq (↑(Max.max s t)) (Union.union ↑s ↑t)","decl":"@[simp, norm_cast]\ntheorem coe_sup (s t : Opens α) : (↑(s ⊔ t) : Set α) = ↑s ∪ ↑t :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.coe_bot","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\n⊢ Eq (↑Bot.bot) EmptyCollection.emptyCollection","decl":"@[simp, norm_cast]\ntheorem coe_bot : ((⊥ : Opens α) : Set α) = ∅ :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.mem_bot","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nx : α\n⊢ Iff (Membership.mem Bot.bot x) False","decl":"@[simp]\nlemma mem_bot {x : α} : x ∈ (⊥ : Opens α) ↔ False := Iff.rfl\n\n"}
{"name":"TopologicalSpace.Opens.mk_empty","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\n⊢ Eq { carrier := EmptyCollection.emptyCollection, is_open' := ⋯ } Bot.bot","decl":"@[simp] theorem mk_empty : (⟨∅, isOpen_empty⟩ : Opens α) = ⊥ := rfl\n\n"}
{"name":"TopologicalSpace.Opens.coe_eq_empty","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nU : TopologicalSpace.Opens α\n⊢ Iff (Eq (↑U) EmptyCollection.emptyCollection) (Eq U Bot.bot)","decl":"@[simp, norm_cast]\ntheorem coe_eq_empty {U : Opens α} : (U : Set α) = ∅ ↔ U = ⊥ :=\n  SetLike.coe_injective.eq_iff' rfl\n\n"}
{"name":"TopologicalSpace.Opens.mem_top","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nx : α\n⊢ Membership.mem Top.top x","decl":"@[simp]\nlemma mem_top (x : α) : x ∈ (⊤ : Opens α) := trivial\n\n"}
{"name":"TopologicalSpace.Opens.coe_top","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\n⊢ Eq (↑Top.top) Set.univ","decl":"@[simp, norm_cast]\ntheorem coe_top : ((⊤ : Opens α) : Set α) = Set.univ :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.mk_univ","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\n⊢ Eq { carrier := Set.univ, is_open' := ⋯ } Top.top","decl":"@[simp] theorem mk_univ : (⟨univ, isOpen_univ⟩ : Opens α) = ⊤ := rfl\n\n"}
{"name":"TopologicalSpace.Opens.coe_eq_univ","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nU : TopologicalSpace.Opens α\n⊢ Iff (Eq (↑U) Set.univ) (Eq U Top.top)","decl":"@[simp, norm_cast]\ntheorem coe_eq_univ {U : Opens α} : (U : Set α) = univ ↔ U = ⊤ :=\n  SetLike.coe_injective.eq_iff' rfl\n\n"}
{"name":"TopologicalSpace.Opens.coe_sSup","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nS : Set (TopologicalSpace.Opens α)\n⊢ Eq (↑(SupSet.sSup S)) (Set.iUnion fun i => Set.iUnion fun h => ↑i)","decl":"@[simp, norm_cast]\ntheorem coe_sSup {S : Set (Opens α)} : (↑(sSup S) : Set α) = ⋃ i ∈ S, ↑i :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.coe_finset_sup","module":"Mathlib.Topology.Sets.Opens","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : TopologicalSpace α\nf : ι → TopologicalSpace.Opens α\ns : Finset ι\n⊢ Eq (↑(s.sup f)) (s.sup (Function.comp SetLike.coe f))","decl":"@[simp, norm_cast]\ntheorem coe_finset_sup (f : ι → Opens α) (s : Finset ι) : (↑(s.sup f) : Set α) = s.sup ((↑) ∘ f) :=\n  map_finset_sup (⟨⟨(↑), coe_sup⟩, coe_bot⟩ : SupBotHom (Opens α) (Set α)) _ _\n\n"}
{"name":"TopologicalSpace.Opens.coe_finset_inf","module":"Mathlib.Topology.Sets.Opens","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : TopologicalSpace α\nf : ι → TopologicalSpace.Opens α\ns : Finset ι\n⊢ Eq (↑(s.inf f)) (s.inf (Function.comp SetLike.coe f))","decl":"@[simp, norm_cast]\ntheorem coe_finset_inf (f : ι → Opens α) (s : Finset ι) : (↑(s.inf f) : Set α) = s.inf ((↑) ∘ f) :=\n  map_finset_inf (⟨⟨(↑), coe_inf⟩, coe_top⟩ : InfTopHom (Opens α) (Set α)) _ _\n\n"}
{"name":"TopologicalSpace.Opens.instNontrivialOfNonempty","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : Nonempty α\n⊢ Nontrivial (TopologicalSpace.Opens α)","decl":"instance [Nonempty α] : Nontrivial (Opens α) where\n  exists_pair_ne := ⟨⊥, ⊤, mt coe_inj.2 empty_ne_univ⟩\n\n"}
{"name":"TopologicalSpace.Opens.coe_iSup","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nι : Sort u_5\ns : ι → TopologicalSpace.Opens α\n⊢ Eq (↑(iSup fun i => s i)) (Set.iUnion fun i => ↑(s i))","decl":"@[simp, norm_cast]\ntheorem coe_iSup {ι} (s : ι → Opens α) : ((⨆ i, s i : Opens α) : Set α) = ⋃ i, s i := by\n  simp [iSup]\n\n"}
{"name":"TopologicalSpace.Opens.iSup_def","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nι : Sort u_5\ns : ι → TopologicalSpace.Opens α\n⊢ Eq (iSup fun i => s i) { carrier := Set.iUnion fun i => ↑(s i), is_open' := ⋯ }","decl":"theorem iSup_def {ι} (s : ι → Opens α) : ⨆ i, s i = ⟨⋃ i, s i, isOpen_iUnion fun i => (s i).2⟩ :=\n  ext <| coe_iSup s\n\n"}
{"name":"TopologicalSpace.Opens.iSup_mk","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nι : Sort u_5\ns : ι → Set α\nh : ∀ (i : ι), IsOpen (s i)\n⊢ Eq (iSup fun i => { carrier := s i, is_open' := ⋯ }) { carrier := Set.iUnion fun i => s i, is_open' := ⋯ }","decl":"@[simp]\ntheorem iSup_mk {ι} (s : ι → Set α) (h : ∀ i, IsOpen (s i)) :\n    (⨆ i, ⟨s i, h i⟩ : Opens α) = ⟨⋃ i, s i, isOpen_iUnion h⟩ :=\n  iSup_def _\n\n"}
{"name":"TopologicalSpace.Opens.mem_iSup","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nι : Sort u_5\nx : α\ns : ι → TopologicalSpace.Opens α\n⊢ Iff (Membership.mem (iSup s) x) (Exists fun i => Membership.mem (s i) x)","decl":"@[simp]\ntheorem mem_iSup {ι} {x : α} {s : ι → Opens α} : x ∈ iSup s ↔ ∃ i, x ∈ s i := by\n  rw [← SetLike.mem_coe]\n  simp\n\n"}
{"name":"TopologicalSpace.Opens.mem_sSup","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nUs : Set (TopologicalSpace.Opens α)\nx : α\n⊢ Iff (Membership.mem (SupSet.sSup Us) x) (Exists fun u => And (Membership.mem Us u) (Membership.mem u x))","decl":"@[simp]\ntheorem mem_sSup {Us : Set (Opens α)} {x : α} : x ∈ sSup Us ↔ ∃ u ∈ Us, x ∈ u := by\n  simp_rw [sSup_eq_iSup, mem_iSup, exists_prop]\n\n"}
{"name":"TopologicalSpace.Opens.isOpenEmbedding'","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nU : TopologicalSpace.Opens α\n⊢ Topology.IsOpenEmbedding Subtype.val","decl":"theorem isOpenEmbedding' (U : Opens α) : IsOpenEmbedding (Subtype.val : U → α) :=\n  U.isOpen.isOpenEmbedding_subtypeVal\n\n"}
{"name":"TopologicalSpace.Opens.openEmbedding'","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nU : TopologicalSpace.Opens α\n⊢ Topology.IsOpenEmbedding Subtype.val","decl":"@[deprecated (since := \"2024-10-18\")]\nalias openEmbedding' := isOpenEmbedding'\n\n"}
{"name":"TopologicalSpace.Opens.isOpenEmbedding_of_le","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nU V : TopologicalSpace.Opens α\ni : LE.le U V\n⊢ Topology.IsOpenEmbedding (Set.inclusion ⋯)","decl":"theorem isOpenEmbedding_of_le {U V : Opens α} (i : U ≤ V) :\n    IsOpenEmbedding (Set.inclusion <| SetLike.coe_subset_coe.2 i) where\n  toIsEmbedding := .inclusion i\n  isOpen_range := by\n    rw [Set.range_inclusion i]\n    exact U.isOpen.preimage continuous_subtype_val\n\n"}
{"name":"TopologicalSpace.Opens.openEmbedding_of_le","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nU V : TopologicalSpace.Opens α\ni : LE.le U V\n⊢ Topology.IsOpenEmbedding (Set.inclusion ⋯)","decl":"@[deprecated (since := \"2024-10-18\")]\nalias openEmbedding_of_le := isOpenEmbedding_of_le\n\n"}
{"name":"TopologicalSpace.Opens.not_nonempty_iff_eq_bot","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nU : TopologicalSpace.Opens α\n⊢ Iff (Not (↑U).Nonempty) (Eq U Bot.bot)","decl":"theorem not_nonempty_iff_eq_bot (U : Opens α) : ¬Set.Nonempty (U : Set α) ↔ U = ⊥ := by\n  rw [← coe_inj, coe_bot, ← Set.not_nonempty_iff_eq_empty]\n\n"}
{"name":"TopologicalSpace.Opens.ne_bot_iff_nonempty","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nU : TopologicalSpace.Opens α\n⊢ Iff (Ne U Bot.bot) (↑U).Nonempty","decl":"theorem ne_bot_iff_nonempty (U : Opens α) : U ≠ ⊥ ↔ Set.Nonempty (U : Set α) := by\n  rw [Ne, ← not_nonempty_iff_eq_bot, not_not]\n\n"}
{"name":"TopologicalSpace.Opens.eq_bot_or_top","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_5\nt : TopologicalSpace α\nh : Eq t Top.top\nU : TopologicalSpace.Opens α\n⊢ Or (Eq U Bot.bot) (Eq U Top.top)","decl":"/-- An open set in the indiscrete topology is either empty or the whole space. -/\ntheorem eq_bot_or_top {α} [t : TopologicalSpace α] (h : t = ⊤) (U : Opens α) : U = ⊥ ∨ U = ⊤ := by\n  subst h; letI : TopologicalSpace α := ⊤\n  rw [← coe_eq_empty, ← coe_eq_univ, ← isOpen_top_iff]\n  exact U.2\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10754): new instance\n"}
{"name":"TopologicalSpace.Opens.instIsSimpleOrderOfNonemptyOfSubsingleton","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : Nonempty α\ninst✝ : Subsingleton α\n⊢ IsSimpleOrder (TopologicalSpace.Opens α)","decl":"instance [Nonempty α] [Subsingleton α] : IsSimpleOrder (Opens α) where\n  eq_bot_or_eq_top := eq_bot_or_top <| Subsingleton.elim _ _\n\n"}
{"name":"TopologicalSpace.Opens.isBasis_iff_nbhd","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nB : Set (TopologicalSpace.Opens α)\n⊢ Iff (TopologicalSpace.Opens.IsBasis B) (∀ {U : TopologicalSpace.Opens α} {x : α}, Membership.mem U x → Exists fun U' => And (Membership.mem B U') (And (Membership.mem U' x) (LE.le U' U)))","decl":"theorem isBasis_iff_nbhd {B : Set (Opens α)} :\n    IsBasis B ↔ ∀ {U : Opens α} {x}, x ∈ U → ∃ U' ∈ B, x ∈ U' ∧ U' ≤ U := by\n  constructor <;> intro h\n  · rintro ⟨sU, hU⟩ x hx\n    rcases h.mem_nhds_iff.mp (IsOpen.mem_nhds hU hx) with ⟨sV, ⟨⟨V, H₁, H₂⟩, hsV⟩⟩\n    refine ⟨V, H₁, ?_⟩\n    cases V\n    dsimp at H₂\n    subst H₂\n    exact hsV\n  · refine isTopologicalBasis_of_isOpen_of_nhds ?_ ?_\n    · rintro sU ⟨U, -, rfl⟩\n      exact U.2\n    · intro x sU hx hsU\n      rcases @h ⟨sU, hsU⟩ x hx with ⟨V, hV, H⟩\n      exact ⟨V, ⟨V, hV, rfl⟩, H⟩\n\n"}
{"name":"TopologicalSpace.Opens.isBasis_iff_cover","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nB : Set (TopologicalSpace.Opens α)\n⊢ Iff (TopologicalSpace.Opens.IsBasis B) (∀ (U : TopologicalSpace.Opens α), Exists fun Us => And (HasSubset.Subset Us B) (Eq U (SupSet.sSup Us)))","decl":"theorem isBasis_iff_cover {B : Set (Opens α)} :\n    IsBasis B ↔ ∀ U : Opens α, ∃ Us, Us ⊆ B ∧ U = sSup Us := by\n  constructor\n  · intro hB U\n    refine ⟨{ V : Opens α | V ∈ B ∧ V ≤ U }, fun U hU => hU.left, ext ?_⟩\n    rw [coe_sSup, hB.open_eq_sUnion' U.isOpen]\n    simp_rw [sUnion_eq_biUnion, iUnion, mem_setOf_eq, iSup_and, iSup_image]\n    rfl\n  · intro h\n    rw [isBasis_iff_nbhd]\n    intro U x hx\n    rcases h U with ⟨Us, hUs, rfl⟩\n    rcases mem_sSup.1 hx with ⟨U, Us, xU⟩\n    exact ⟨U, hUs Us, xU, le_sSup Us⟩\n\n"}
{"name":"TopologicalSpace.Opens.IsBasis.isCompact_open_iff_eq_finite_iUnion","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nι : Type u_5\nb : ι → TopologicalSpace.Opens α\nhb : TopologicalSpace.Opens.IsBasis (Set.range b)\nhb' : ∀ (i : ι), IsCompact ↑(b i)\nU : Set α\n⊢ Iff (And (IsCompact U) (IsOpen U)) (Exists fun s => And s.Finite (Eq U (Set.iUnion fun i => Set.iUnion fun h => ↑(b i))))","decl":"/-- If `α` has a basis consisting of compact opens, then an open set in `α` is compact open iff\n  it is a finite union of some elements in the basis -/\ntheorem IsBasis.isCompact_open_iff_eq_finite_iUnion {ι : Type*} (b : ι → Opens α)\n    (hb : IsBasis (Set.range b)) (hb' : ∀ i, IsCompact (b i : Set α)) (U : Set α) :\n    IsCompact U ∧ IsOpen U ↔ ∃ s : Set ι, s.Finite ∧ U = ⋃ i ∈ s, b i := by\n  apply isCompact_open_iff_eq_finite_iUnion_of_isTopologicalBasis fun i : ι => (b i).1\n  · convert (config := {transparency := .default}) hb\n    ext\n    simp\n  · exact hb'\n\n"}
{"name":"TopologicalSpace.Opens.IsBasis.le_iff","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_5\nt₁ t₂ : TopologicalSpace α\nUs : Set (TopologicalSpace.Opens α)\nhUs : TopologicalSpace.Opens.IsBasis Us\n⊢ Iff (LE.le t₁ t₂) (∀ (U : TopologicalSpace.Opens α), Membership.mem Us U → IsOpen ↑U)","decl":"lemma IsBasis.le_iff {α} {t₁ t₂ : TopologicalSpace α}\n    {Us : Set (Opens α)} (hUs : @IsBasis α t₂ Us) :\n    t₁ ≤ t₂ ↔ ∀ U ∈ Us, IsOpen[t₁] U := by\n  conv_lhs => rw [hUs.eq_generateFrom]\n  simp [Set.subset_def, le_generateFrom_iff_subset_isOpen]\n\n"}
{"name":"TopologicalSpace.Opens.isCompactElement_iff","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\ns : TopologicalSpace.Opens α\n⊢ Iff (CompleteLattice.IsCompactElement s) (IsCompact ↑s)","decl":"@[simp]\ntheorem isCompactElement_iff (s : Opens α) :\n    CompleteLattice.IsCompactElement s ↔ IsCompact (s : Set α) := by\n  rw [isCompact_iff_finite_subcover, CompleteLattice.isCompactElement_iff]\n  refine ⟨?_, fun H ι U hU => ?_⟩\n  · introv H hU hU'\n    obtain ⟨t, ht⟩ := H ι (fun i => ⟨U i, hU i⟩) (by simpa)\n    refine ⟨t, Set.Subset.trans ht ?_⟩\n    rw [coe_finset_sup, Finset.sup_eq_iSup]\n    rfl\n  · obtain ⟨t, ht⟩ :=\n      H (fun i => U i) (fun i => (U i).isOpen) (by simpa using show (s : Set α) ⊆ ↑(iSup U) from hU)\n    refine ⟨t, Set.Subset.trans ht ?_⟩\n    simp only [Set.iUnion_subset_iff]\n    show ∀ i ∈ t, U i ≤ t.sup U\n    exact fun i => Finset.le_sup\n\n"}
{"name":"TopologicalSpace.Opens.comap_id","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\n⊢ Eq (TopologicalSpace.Opens.comap (ContinuousMap.id α)) (FrameHom.id (TopologicalSpace.Opens α))","decl":"@[simp]\ntheorem comap_id : comap (ContinuousMap.id α) = FrameHom.id _ :=\n  FrameHom.ext fun _ => ext rfl\n\n"}
{"name":"TopologicalSpace.Opens.comap_mono","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : ContinuousMap α β\ns t : TopologicalSpace.Opens β\nh : LE.le s t\n⊢ LE.le ((TopologicalSpace.Opens.comap f) s) ((TopologicalSpace.Opens.comap f) t)","decl":"theorem comap_mono (f : C(α, β)) {s t : Opens β} (h : s ≤ t) : comap f s ≤ comap f t :=\n  OrderHomClass.mono (comap f) h\n\n"}
{"name":"TopologicalSpace.Opens.coe_comap","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : ContinuousMap α β\nU : TopologicalSpace.Opens β\n⊢ Eq (↑((TopologicalSpace.Opens.comap f) U)) (Set.preimage ⇑f ↑U)","decl":"@[simp]\ntheorem coe_comap (f : C(α, β)) (U : Opens β) : ↑(comap f U) = f ⁻¹' U :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.mem_comap","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : ContinuousMap α β\nU : TopologicalSpace.Opens β\nx : α\n⊢ Iff (Membership.mem ((TopologicalSpace.Opens.comap f) U) x) (Membership.mem U (f x))","decl":"@[simp]\ntheorem mem_comap {f : C(α, β)} {U : Opens β} {x : α} : x ∈ comap f U ↔ f x ∈ U := .rfl\n\n"}
{"name":"TopologicalSpace.Opens.comap_comp","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : TopologicalSpace γ\ng : ContinuousMap β γ\nf : ContinuousMap α β\n⊢ Eq (TopologicalSpace.Opens.comap (g.comp f)) ((TopologicalSpace.Opens.comap f).comp (TopologicalSpace.Opens.comap g))","decl":"protected theorem comap_comp (g : C(β, γ)) (f : C(α, β)) :\n    comap (g.comp f) = (comap f).comp (comap g) :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.comap_comap","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : TopologicalSpace γ\ng : ContinuousMap β γ\nf : ContinuousMap α β\nU : TopologicalSpace.Opens γ\n⊢ Eq ((TopologicalSpace.Opens.comap f) ((TopologicalSpace.Opens.comap g) U)) ((TopologicalSpace.Opens.comap (g.comp f)) U)","decl":"protected theorem comap_comap (g : C(β, γ)) (f : C(α, β)) (U : Opens γ) :\n    comap f (comap g U) = comap (g.comp f) U :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.comap_injective","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : T0Space β\n⊢ Function.Injective TopologicalSpace.Opens.comap","decl":"theorem comap_injective [T0Space β] : Injective (comap : C(α, β) → FrameHom (Opens β) (Opens α)) :=\n  fun f g h =>\n  ContinuousMap.ext fun a =>\n    Inseparable.eq <|\n      inseparable_iff_forall_isOpen.2 fun s hs =>\n        have : comap f ⟨s, hs⟩ = comap g ⟨s, hs⟩ := DFunLike.congr_fun h ⟨_, hs⟩\n        show a ∈ f ⁻¹' s ↔ a ∈ g ⁻¹' s from Set.ext_iff.1 (coe_inj.2 this) a\n\n"}
{"name":"Homeomorph.opensCongr_apply","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : Homeomorph α β\n⊢ Eq ⇑f.opensCongr ⇑(TopologicalSpace.Opens.comap ↑f.symm)","decl":"/-- A homeomorphism induces an order-preserving equivalence on open sets, by taking comaps. -/\n@[simps (config := .asFn) apply]\ndef _root_.Homeomorph.opensCongr (f : α ≃ₜ β) : Opens α ≃o Opens β where\n  toFun := Opens.comap (f.symm : C(β, α))\n  invFun := Opens.comap (f : C(α, β))\n  left_inv _ := ext <| f.toEquiv.preimage_symm_preimage _\n  right_inv _ := ext <| f.toEquiv.symm_preimage_preimage _\n  map_rel_iff' := by\n    simp only [← SetLike.coe_subset_coe]; exact f.symm.surjective.preimage_subset_preimage_iff\n\n"}
{"name":"Homeomorph.opensCongr_symm","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : Homeomorph α β\n⊢ Eq f.opensCongr.symm f.symm.opensCongr","decl":"@[simp]\ntheorem _root_.Homeomorph.opensCongr_symm (f : α ≃ₜ β) : f.opensCongr.symm = f.symm.opensCongr :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.instFinite","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : Finite α\n⊢ Finite (TopologicalSpace.Opens α)","decl":"instance [Finite α] : Finite (Opens α) :=\n  Finite.of_injective _ SetLike.coe_injective\n\n"}
{"name":"TopologicalSpace.OpenNhdsOf.mem'","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nx : α\nself : TopologicalSpace.OpenNhdsOf x\n⊢ Membership.mem self.carrier x","decl":"/-- The open neighborhoods of a point. See also `Opens` or `nhds`. -/\nstructure OpenNhdsOf (x : α) extends Opens α where\n  /-- The point `x` belongs to every `U : TopologicalSpace.OpenNhdsOf x`. -/\n  mem' : x ∈ carrier\n\n"}
{"name":"TopologicalSpace.OpenNhdsOf.mk.inj","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nx : α\ntoOpens✝ : TopologicalSpace.Opens α\nmem'✝ : Membership.mem toOpens✝.carrier x\ntoOpens : TopologicalSpace.Opens α\nmem' : Membership.mem toOpens.carrier x\nx✝ : Eq { toOpens := toOpens✝, mem' := mem'✝ } { toOpens := toOpens, mem' := mem' }\n⊢ Eq toOpens✝ toOpens","decl":"/-- The open neighborhoods of a point. See also `Opens` or `nhds`. -/\nstructure OpenNhdsOf (x : α) extends Opens α where\n  /-- The point `x` belongs to every `U : TopologicalSpace.OpenNhdsOf x`. -/\n  mem' : x ∈ carrier\n\n"}
{"name":"TopologicalSpace.OpenNhdsOf.mk.injEq","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nx : α\ntoOpens✝ : TopologicalSpace.Opens α\nmem'✝ : Membership.mem toOpens✝.carrier x\ntoOpens : TopologicalSpace.Opens α\nmem' : Membership.mem toOpens.carrier x\n⊢ Eq (Eq { toOpens := toOpens✝, mem' := mem'✝ } { toOpens := toOpens, mem' := mem' }) (Eq toOpens✝ toOpens)","decl":"/-- The open neighborhoods of a point. See also `Opens` or `nhds`. -/\nstructure OpenNhdsOf (x : α) extends Opens α where\n  /-- The point `x` belongs to every `U : TopologicalSpace.OpenNhdsOf x`. -/\n  mem' : x ∈ carrier\n\n"}
{"name":"TopologicalSpace.OpenNhdsOf.mk.sizeOf_spec","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝¹ : TopologicalSpace α\nx : α\ninst✝ : SizeOf α\ntoOpens : TopologicalSpace.Opens α\nmem' : Membership.mem toOpens.carrier x\n⊢ Eq (SizeOf.sizeOf { toOpens := toOpens, mem' := mem' }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toOpens)) (SizeOf.sizeOf mem'))","decl":"/-- The open neighborhoods of a point. See also `Opens` or `nhds`. -/\nstructure OpenNhdsOf (x : α) extends Opens α where\n  /-- The point `x` belongs to every `U : TopologicalSpace.OpenNhdsOf x`. -/\n  mem' : x ∈ carrier\n\n"}
{"name":"TopologicalSpace.OpenNhdsOf.toOpens_injective","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nx : α\n⊢ Function.Injective TopologicalSpace.OpenNhdsOf.toOpens","decl":"theorem toOpens_injective : Injective (toOpens : OpenNhdsOf x → Opens α)\n  | ⟨_, _⟩, ⟨_, _⟩, rfl => rfl\n\n"}
{"name":"TopologicalSpace.OpenNhdsOf.canLiftSet","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nx : α\n⊢ CanLift (Set α) (TopologicalSpace.OpenNhdsOf x) SetLike.coe fun s => And (IsOpen s) (Membership.mem s x)","decl":"instance canLiftSet : CanLift (Set α) (OpenNhdsOf x) (↑) fun s => IsOpen s ∧ x ∈ s :=\n  ⟨fun s hs => ⟨⟨⟨s, hs.1⟩, hs.2⟩, rfl⟩⟩\n\n"}
{"name":"TopologicalSpace.OpenNhdsOf.mem","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nx : α\nU : TopologicalSpace.OpenNhdsOf x\n⊢ Membership.mem U x","decl":"protected theorem mem (U : OpenNhdsOf x) : x ∈ U :=\n  U.mem'\n\n"}
{"name":"TopologicalSpace.OpenNhdsOf.isOpen","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nx : α\nU : TopologicalSpace.OpenNhdsOf x\n⊢ IsOpen ↑U","decl":"protected theorem isOpen (U : OpenNhdsOf x) : IsOpen (U : Set α) :=\n  U.is_open'\n\n"}
{"name":"TopologicalSpace.OpenNhdsOf.basis_nhds","module":"Mathlib.Topology.Sets.Opens","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nx : α\n⊢ (nhds x).HasBasis (fun x => True) SetLike.coe","decl":"theorem basis_nhds : (𝓝 x).HasBasis (fun _ : OpenNhdsOf x => True) (↑) :=\n  (nhds_basis_opens x).to_hasBasis (fun U hU => ⟨⟨⟨U, hU.2⟩, hU.1⟩, trivial, Subset.rfl⟩) fun U _ =>\n    ⟨U, ⟨⟨U.mem, U.isOpen⟩, Subset.rfl⟩⟩\n\n"}
