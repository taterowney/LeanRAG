{"name":"TopologicalSpace.Opens.mk.injEq","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\ncarrier‚úù : Set Œ±\nis_open'‚úù : IsOpen carrier‚úù\ncarrier : Set Œ±\nis_open' : IsOpen carrier\n‚ä¢ Eq (Eq { carrier := carrier‚úù, is_open' := is_open'‚úù } { carrier := carrier, is_open' := is_open' }) (Eq carrier‚úù carrier)","decl":"/-- The type of open subsets of a topological space. -/\nstructure Opens where\n  /-- The underlying set of a bundled `TopologicalSpace.Opens` object. -/\n  carrier : Set Œ±\n  /-- The `TopologicalSpace.Opens.carrier _` is an open set. -/\n  is_open' : IsOpen carrier\n\n"}
{"name":"TopologicalSpace.Opens.mk.inj","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\ncarrier‚úù : Set Œ±\nis_open'‚úù : IsOpen carrier‚úù\ncarrier : Set Œ±\nis_open' : IsOpen carrier\nx‚úù : Eq { carrier := carrier‚úù, is_open' := is_open'‚úù } { carrier := carrier, is_open' := is_open' }\n‚ä¢ Eq carrier‚úù carrier","decl":"/-- The type of open subsets of a topological space. -/\nstructure Opens where\n  /-- The underlying set of a bundled `TopologicalSpace.Opens` object. -/\n  carrier : Set Œ±\n  /-- The `TopologicalSpace.Opens.carrier _` is an open set. -/\n  is_open' : IsOpen carrier\n\n"}
{"name":"TopologicalSpace.Opens.mk.sizeOf_spec","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : SizeOf Œ±\ncarrier : Set Œ±\nis_open' : IsOpen carrier\n‚ä¢ Eq (SizeOf.sizeOf { carrier := carrier, is_open' := is_open' }) (HAdd.hAdd 1 (SizeOf.sizeOf is_open'))","decl":"/-- The type of open subsets of a topological space. -/\nstructure Opens where\n  /-- The underlying set of a bundled `TopologicalSpace.Opens` object. -/\n  carrier : Set Œ±\n  /-- The `TopologicalSpace.Opens.carrier _` is an open set. -/\n  is_open' : IsOpen carrier\n\n"}
{"name":"TopologicalSpace.Opens.is_open'","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nself : TopologicalSpace.Opens Œ±\n‚ä¢ IsOpen self.carrier","decl":"/-- The type of open subsets of a topological space. -/\nstructure Opens where\n  /-- The underlying set of a bundled `TopologicalSpace.Opens` object. -/\n  carrier : Set Œ±\n  /-- The `TopologicalSpace.Opens.carrier _` is an open set. -/\n  is_open' : IsOpen carrier\n\n"}
{"name":"TopologicalSpace.Opens.instCanLiftSetCoeIsOpen","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\n‚ä¢ CanLift (Set Œ±) (TopologicalSpace.Opens Œ±) SetLike.coe IsOpen","decl":"instance : CanLift (Set Œ±) (Opens Œ±) (‚Üë) IsOpen :=\n  ‚ü®fun s h => ‚ü®‚ü®s, h‚ü©, rfl‚ü©‚ü©\n\n"}
{"name":"TopologicalSpace.Opens.instSecondCountableOpens","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : SecondCountableTopology Œ±\nU : TopologicalSpace.Opens Œ±\n‚ä¢ SecondCountableTopology (Subtype fun x => Membership.mem U x)","decl":"instance instSecondCountableOpens [SecondCountableTopology Œ±] (U : Opens Œ±) :\n    SecondCountableTopology U := inferInstanceAs (SecondCountableTopology U.1)\n\n"}
{"name":"TopologicalSpace.Opens.forall","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\np : TopologicalSpace.Opens Œ± ‚Üí Prop\n‚ä¢ Iff (‚àÄ (U : TopologicalSpace.Opens Œ±), p U) (‚àÄ (U : Set Œ±) (hU : IsOpen U), p { carrier := U, is_open' := hU })","decl":"theorem ¬´forall¬ª {p : Opens Œ± ‚Üí Prop} : (‚àÄ U, p U) ‚Üî ‚àÄ (U : Set Œ±) (hU : IsOpen U), p ‚ü®U, hU‚ü© :=\n  ‚ü®fun h _ _ => h _, fun h _ => h _ _‚ü©\n\n"}
{"name":"TopologicalSpace.Opens.carrier_eq_coe","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nU : TopologicalSpace.Opens Œ±\n‚ä¢ Eq U.carrier ‚ÜëU","decl":"@[simp] theorem carrier_eq_coe (U : Opens Œ±) : U.1 = ‚ÜëU := rfl\n\n"}
{"name":"TopologicalSpace.Opens.coe_mk","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nU : Set Œ±\nhU : IsOpen U\n‚ä¢ Eq (‚Üë{ carrier := U, is_open' := hU }) U","decl":"/-- the coercion `Opens Œ± ‚Üí Set Œ±` applied to a pair is the same as taking the first component -/\n@[simp]\ntheorem coe_mk {U : Set Œ±} {hU : IsOpen U} : ‚Üë(‚ü®U, hU‚ü© : Opens Œ±) = U :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.mem_mk","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nx : Œ±\nU : Set Œ±\nh : IsOpen U\n‚ä¢ Iff (Membership.mem { carrier := U, is_open' := h } x) (Membership.mem U x)","decl":"@[simp]\ntheorem mem_mk {x : Œ±} {U : Set Œ±} {h : IsOpen U} : x ‚àà mk U h ‚Üî x ‚àà U := Iff.rfl\n\n"}
{"name":"TopologicalSpace.Opens.nonempty_coeSort","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nU : TopologicalSpace.Opens Œ±\n‚ä¢ Iff (Nonempty (Subtype fun x => Membership.mem U x)) (‚ÜëU).Nonempty","decl":"protected theorem nonempty_coeSort {U : Opens Œ±} : Nonempty U ‚Üî (U : Set Œ±).Nonempty :=\n  Set.nonempty_coe_sort\n\n-- TODO: should this theorem be proved for a `SetLike`?\n"}
{"name":"TopologicalSpace.Opens.nonempty_coe","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nU : TopologicalSpace.Opens Œ±\n‚ä¢ Iff (‚ÜëU).Nonempty (Exists fun x => Membership.mem U x)","decl":"protected theorem nonempty_coe {U : Opens Œ±} : (U : Set Œ±).Nonempty ‚Üî ‚àÉ x, x ‚àà U :=\n  Iff.rfl\n\n"}
{"name":"TopologicalSpace.Opens.ext_iff","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nU V : TopologicalSpace.Opens Œ±\n‚ä¢ Iff (Eq U V) (Eq ‚ÜëU ‚ÜëV)","decl":"@[ext] -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: replace with `‚àÄ x, x ‚àà U ‚Üî x ‚àà V`\ntheorem ext {U V : Opens Œ±} (h : (U : Set Œ±) = V) : U = V :=\n  SetLike.coe_injective h\n\n"}
{"name":"TopologicalSpace.Opens.ext","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nU V : TopologicalSpace.Opens Œ±\nh : Eq ‚ÜëU ‚ÜëV\n‚ä¢ Eq U V","decl":"@[ext] -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: replace with `‚àÄ x, x ‚àà U ‚Üî x ‚àà V`\ntheorem ext {U V : Opens Œ±} (h : (U : Set Œ±) = V) : U = V :=\n  SetLike.coe_injective h\n\n"}
{"name":"TopologicalSpace.Opens.coe_inj","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nU V : TopologicalSpace.Opens Œ±\n‚ä¢ Iff (Eq ‚ÜëU ‚ÜëV) (Eq U V)","decl":"theorem coe_inj {U V : Opens Œ±} : (U : Set Œ±) = V ‚Üî U = V :=\n  SetLike.ext'_iff.symm\n\n"}
{"name":"TopologicalSpace.Opens.isOpen","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nU : TopologicalSpace.Opens Œ±\n‚ä¢ IsOpen ‚ÜëU","decl":"protected theorem isOpen (U : Opens Œ±) : IsOpen (U : Set Œ±) :=\n  U.is_open'\n\n"}
{"name":"TopologicalSpace.Opens.mk_coe","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nU : TopologicalSpace.Opens Œ±\n‚ä¢ Eq { carrier := ‚ÜëU, is_open' := ‚ãØ } U","decl":"@[simp] theorem mk_coe (U : Opens Œ±) : mk (‚ÜëU) U.isOpen = U := rfl\n\n"}
{"name":"TopologicalSpace.Opens.coe_interior","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\ns : Set Œ±\n‚ä¢ Eq (‚Üë(TopologicalSpace.Opens.interior s)) (interior s)","decl":"/-- The interior of a set, as an element of `Opens`. -/\n@[simps]\nprotected def interior (s : Set Œ±) : Opens Œ± :=\n  ‚ü®interior s, isOpen_interior‚ü©\n\n"}
{"name":"TopologicalSpace.Opens.mem_interior","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\ns : Set Œ±\nx : Œ±\n‚ä¢ Iff (Membership.mem (TopologicalSpace.Opens.interior s) x) (Membership.mem (interior s) x)","decl":"@[simp]\ntheorem mem_interior {s : Set Œ±} {x : Œ±} : x ‚àà Opens.interior s ‚Üî x ‚àà _root_.interior s := .rfl\n\n"}
{"name":"TopologicalSpace.Opens.gc","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\n‚ä¢ GaloisConnection SetLike.coe TopologicalSpace.Opens.interior","decl":"theorem gc : GaloisConnection ((‚Üë) : Opens Œ± ‚Üí Set Œ±) Opens.interior := fun U _ =>\n  ‚ü®fun h => interior_maximal h U.isOpen, fun h => le_trans h interior_subset‚ü©\n\n"}
{"name":"TopologicalSpace.Opens.mk_inf_mk","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nU V : Set Œ±\nhU : IsOpen U\nhV : IsOpen V\n‚ä¢ Eq (Min.min { carrier := U, is_open' := hU } { carrier := V, is_open' := hV }) { carrier := Min.min U V, is_open' := ‚ãØ }","decl":"@[simp]\ntheorem mk_inf_mk {U V : Set Œ±} {hU : IsOpen U} {hV : IsOpen V} :\n    (‚ü®U, hU‚ü© ‚äì ‚ü®V, hV‚ü© : Opens Œ±) = ‚ü®U ‚äì V, IsOpen.inter hU hV‚ü© :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.coe_inf","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\ns t : TopologicalSpace.Opens Œ±\n‚ä¢ Eq (‚Üë(Min.min s t)) (Inter.inter ‚Üës ‚Üët)","decl":"@[simp, norm_cast]\ntheorem coe_inf (s t : Opens Œ±) : (‚Üë(s ‚äì t) : Set Œ±) = ‚Üës ‚à© ‚Üët :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.mem_inf","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\ns t : TopologicalSpace.Opens Œ±\nx : Œ±\n‚ä¢ Iff (Membership.mem (Min.min s t) x) (And (Membership.mem s x) (Membership.mem t x))","decl":"@[simp]\nlemma mem_inf {s t : Opens Œ±} {x : Œ±} : x ‚àà s ‚äì t ‚Üî x ‚àà s ‚àß x ‚àà t := Iff.rfl\n\n"}
{"name":"TopologicalSpace.Opens.coe_sup","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\ns t : TopologicalSpace.Opens Œ±\n‚ä¢ Eq (‚Üë(Max.max s t)) (Union.union ‚Üës ‚Üët)","decl":"@[simp, norm_cast]\ntheorem coe_sup (s t : Opens Œ±) : (‚Üë(s ‚äî t) : Set Œ±) = ‚Üës ‚à™ ‚Üët :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.coe_bot","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\n‚ä¢ Eq (‚ÜëBot.bot) EmptyCollection.emptyCollection","decl":"@[simp, norm_cast]\ntheorem coe_bot : ((‚ä• : Opens Œ±) : Set Œ±) = ‚àÖ :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.mem_bot","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nx : Œ±\n‚ä¢ Iff (Membership.mem Bot.bot x) False","decl":"@[simp]\nlemma mem_bot {x : Œ±} : x ‚àà (‚ä• : Opens Œ±) ‚Üî False := Iff.rfl\n\n"}
{"name":"TopologicalSpace.Opens.mk_empty","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\n‚ä¢ Eq { carrier := EmptyCollection.emptyCollection, is_open' := ‚ãØ } Bot.bot","decl":"@[simp] theorem mk_empty : (‚ü®‚àÖ, isOpen_empty‚ü© : Opens Œ±) = ‚ä• := rfl\n\n"}
{"name":"TopologicalSpace.Opens.coe_eq_empty","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nU : TopologicalSpace.Opens Œ±\n‚ä¢ Iff (Eq (‚ÜëU) EmptyCollection.emptyCollection) (Eq U Bot.bot)","decl":"@[simp, norm_cast]\ntheorem coe_eq_empty {U : Opens Œ±} : (U : Set Œ±) = ‚àÖ ‚Üî U = ‚ä• :=\n  SetLike.coe_injective.eq_iff' rfl\n\n"}
{"name":"TopologicalSpace.Opens.mem_top","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nx : Œ±\n‚ä¢ Membership.mem Top.top x","decl":"@[simp]\nlemma mem_top (x : Œ±) : x ‚àà (‚ä§ : Opens Œ±) := trivial\n\n"}
{"name":"TopologicalSpace.Opens.coe_top","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\n‚ä¢ Eq (‚ÜëTop.top) Set.univ","decl":"@[simp, norm_cast]\ntheorem coe_top : ((‚ä§ : Opens Œ±) : Set Œ±) = Set.univ :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.mk_univ","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\n‚ä¢ Eq { carrier := Set.univ, is_open' := ‚ãØ } Top.top","decl":"@[simp] theorem mk_univ : (‚ü®univ, isOpen_univ‚ü© : Opens Œ±) = ‚ä§ := rfl\n\n"}
{"name":"TopologicalSpace.Opens.coe_eq_univ","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nU : TopologicalSpace.Opens Œ±\n‚ä¢ Iff (Eq (‚ÜëU) Set.univ) (Eq U Top.top)","decl":"@[simp, norm_cast]\ntheorem coe_eq_univ {U : Opens Œ±} : (U : Set Œ±) = univ ‚Üî U = ‚ä§ :=\n  SetLike.coe_injective.eq_iff' rfl\n\n"}
{"name":"TopologicalSpace.Opens.coe_sSup","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nS : Set (TopologicalSpace.Opens Œ±)\n‚ä¢ Eq (‚Üë(SupSet.sSup S)) (Set.iUnion fun i => Set.iUnion fun h => ‚Üëi)","decl":"@[simp, norm_cast]\ntheorem coe_sSup {S : Set (Opens Œ±)} : (‚Üë(sSup S) : Set Œ±) = ‚ãÉ i ‚àà S, ‚Üëi :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.coe_finset_sup","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œπ : Type u_1\nŒ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nf : Œπ ‚Üí TopologicalSpace.Opens Œ±\ns : Finset Œπ\n‚ä¢ Eq (‚Üë(s.sup f)) (s.sup (Function.comp SetLike.coe f))","decl":"@[simp, norm_cast]\ntheorem coe_finset_sup (f : Œπ ‚Üí Opens Œ±) (s : Finset Œπ) : (‚Üë(s.sup f) : Set Œ±) = s.sup ((‚Üë) ‚àò f) :=\n  map_finset_sup (‚ü®‚ü®(‚Üë), coe_sup‚ü©, coe_bot‚ü© : SupBotHom (Opens Œ±) (Set Œ±)) _ _\n\n"}
{"name":"TopologicalSpace.Opens.coe_finset_inf","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œπ : Type u_1\nŒ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nf : Œπ ‚Üí TopologicalSpace.Opens Œ±\ns : Finset Œπ\n‚ä¢ Eq (‚Üë(s.inf f)) (s.inf (Function.comp SetLike.coe f))","decl":"@[simp, norm_cast]\ntheorem coe_finset_inf (f : Œπ ‚Üí Opens Œ±) (s : Finset Œπ) : (‚Üë(s.inf f) : Set Œ±) = s.inf ((‚Üë) ‚àò f) :=\n  map_finset_inf (‚ü®‚ü®(‚Üë), coe_inf‚ü©, coe_top‚ü© : InfTopHom (Opens Œ±) (Set Œ±)) _ _\n\n"}
{"name":"TopologicalSpace.Opens.instNontrivialOfNonempty","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Nonempty Œ±\n‚ä¢ Nontrivial (TopologicalSpace.Opens Œ±)","decl":"instance [Nonempty Œ±] : Nontrivial (Opens Œ±) where\n  exists_pair_ne := ‚ü®‚ä•, ‚ä§, mt coe_inj.2 empty_ne_univ‚ü©\n\n"}
{"name":"TopologicalSpace.Opens.coe_iSup","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nŒπ : Sort u_5\ns : Œπ ‚Üí TopologicalSpace.Opens Œ±\n‚ä¢ Eq (‚Üë(iSup fun i => s i)) (Set.iUnion fun i => ‚Üë(s i))","decl":"@[simp, norm_cast]\ntheorem coe_iSup {Œπ} (s : Œπ ‚Üí Opens Œ±) : ((‚®Ü i, s i : Opens Œ±) : Set Œ±) = ‚ãÉ i, s i := by\n  simp [iSup]\n\n"}
{"name":"TopologicalSpace.Opens.iSup_def","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nŒπ : Sort u_5\ns : Œπ ‚Üí TopologicalSpace.Opens Œ±\n‚ä¢ Eq (iSup fun i => s i) { carrier := Set.iUnion fun i => ‚Üë(s i), is_open' := ‚ãØ }","decl":"theorem iSup_def {Œπ} (s : Œπ ‚Üí Opens Œ±) : ‚®Ü i, s i = ‚ü®‚ãÉ i, s i, isOpen_iUnion fun i => (s i).2‚ü© :=\n  ext <| coe_iSup s\n\n"}
{"name":"TopologicalSpace.Opens.iSup_mk","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nŒπ : Sort u_5\ns : Œπ ‚Üí Set Œ±\nh : ‚àÄ (i : Œπ), IsOpen (s i)\n‚ä¢ Eq (iSup fun i => { carrier := s i, is_open' := ‚ãØ }) { carrier := Set.iUnion fun i => s i, is_open' := ‚ãØ }","decl":"@[simp]\ntheorem iSup_mk {Œπ} (s : Œπ ‚Üí Set Œ±) (h : ‚àÄ i, IsOpen (s i)) :\n    (‚®Ü i, ‚ü®s i, h i‚ü© : Opens Œ±) = ‚ü®‚ãÉ i, s i, isOpen_iUnion h‚ü© :=\n  iSup_def _\n\n"}
{"name":"TopologicalSpace.Opens.mem_iSup","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nŒπ : Sort u_5\nx : Œ±\ns : Œπ ‚Üí TopologicalSpace.Opens Œ±\n‚ä¢ Iff (Membership.mem (iSup s) x) (Exists fun i => Membership.mem (s i) x)","decl":"@[simp]\ntheorem mem_iSup {Œπ} {x : Œ±} {s : Œπ ‚Üí Opens Œ±} : x ‚àà iSup s ‚Üî ‚àÉ i, x ‚àà s i := by\n  rw [‚Üê SetLike.mem_coe]\n  simp\n\n"}
{"name":"TopologicalSpace.Opens.mem_sSup","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nUs : Set (TopologicalSpace.Opens Œ±)\nx : Œ±\n‚ä¢ Iff (Membership.mem (SupSet.sSup Us) x) (Exists fun u => And (Membership.mem Us u) (Membership.mem u x))","decl":"@[simp]\ntheorem mem_sSup {Us : Set (Opens Œ±)} {x : Œ±} : x ‚àà sSup Us ‚Üî ‚àÉ u ‚àà Us, x ‚àà u := by\n  simp_rw [sSup_eq_iSup, mem_iSup, exists_prop]\n\n"}
{"name":"TopologicalSpace.Opens.isOpenEmbedding'","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nU : TopologicalSpace.Opens Œ±\n‚ä¢ Topology.IsOpenEmbedding Subtype.val","decl":"theorem isOpenEmbedding' (U : Opens Œ±) : IsOpenEmbedding (Subtype.val : U ‚Üí Œ±) :=\n  U.isOpen.isOpenEmbedding_subtypeVal\n\n"}
{"name":"TopologicalSpace.Opens.openEmbedding'","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nU : TopologicalSpace.Opens Œ±\n‚ä¢ Topology.IsOpenEmbedding Subtype.val","decl":"@[deprecated (since := \"2024-10-18\")]\nalias openEmbedding' := isOpenEmbedding'\n\n"}
{"name":"TopologicalSpace.Opens.isOpenEmbedding_of_le","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nU V : TopologicalSpace.Opens Œ±\ni : LE.le U V\n‚ä¢ Topology.IsOpenEmbedding (Set.inclusion ‚ãØ)","decl":"theorem isOpenEmbedding_of_le {U V : Opens Œ±} (i : U ‚â§ V) :\n    IsOpenEmbedding (Set.inclusion <| SetLike.coe_subset_coe.2 i) where\n  toIsEmbedding := .inclusion i\n  isOpen_range := by\n    rw [Set.range_inclusion i]\n    exact U.isOpen.preimage continuous_subtype_val\n\n"}
{"name":"TopologicalSpace.Opens.openEmbedding_of_le","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nU V : TopologicalSpace.Opens Œ±\ni : LE.le U V\n‚ä¢ Topology.IsOpenEmbedding (Set.inclusion ‚ãØ)","decl":"@[deprecated (since := \"2024-10-18\")]\nalias openEmbedding_of_le := isOpenEmbedding_of_le\n\n"}
{"name":"TopologicalSpace.Opens.not_nonempty_iff_eq_bot","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nU : TopologicalSpace.Opens Œ±\n‚ä¢ Iff (Not (‚ÜëU).Nonempty) (Eq U Bot.bot)","decl":"theorem not_nonempty_iff_eq_bot (U : Opens Œ±) : ¬¨Set.Nonempty (U : Set Œ±) ‚Üî U = ‚ä• := by\n  rw [‚Üê coe_inj, coe_bot, ‚Üê Set.not_nonempty_iff_eq_empty]\n\n"}
{"name":"TopologicalSpace.Opens.ne_bot_iff_nonempty","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nU : TopologicalSpace.Opens Œ±\n‚ä¢ Iff (Ne U Bot.bot) (‚ÜëU).Nonempty","decl":"theorem ne_bot_iff_nonempty (U : Opens Œ±) : U ‚â† ‚ä• ‚Üî Set.Nonempty (U : Set Œ±) := by\n  rw [Ne, ‚Üê not_nonempty_iff_eq_bot, not_not]\n\n"}
{"name":"TopologicalSpace.Opens.eq_bot_or_top","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_5\nt : TopologicalSpace Œ±\nh : Eq t Top.top\nU : TopologicalSpace.Opens Œ±\n‚ä¢ Or (Eq U Bot.bot) (Eq U Top.top)","decl":"/-- An open set in the indiscrete topology is either empty or the whole space. -/\ntheorem eq_bot_or_top {Œ±} [t : TopologicalSpace Œ±] (h : t = ‚ä§) (U : Opens Œ±) : U = ‚ä• ‚à® U = ‚ä§ := by\n  subst h; letI : TopologicalSpace Œ± := ‚ä§\n  rw [‚Üê coe_eq_empty, ‚Üê coe_eq_univ, ‚Üê isOpen_top_iff]\n  exact U.2\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10754): new instance\n"}
{"name":"TopologicalSpace.Opens.instIsSimpleOrderOfNonemptyOfSubsingleton","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Nonempty Œ±\ninst‚úù : Subsingleton Œ±\n‚ä¢ IsSimpleOrder (TopologicalSpace.Opens Œ±)","decl":"instance [Nonempty Œ±] [Subsingleton Œ±] : IsSimpleOrder (Opens Œ±) where\n  eq_bot_or_eq_top := eq_bot_or_top <| Subsingleton.elim _ _\n\n"}
{"name":"TopologicalSpace.Opens.isBasis_iff_nbhd","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nB : Set (TopologicalSpace.Opens Œ±)\n‚ä¢ Iff (TopologicalSpace.Opens.IsBasis B) (‚àÄ {U : TopologicalSpace.Opens Œ±} {x : Œ±}, Membership.mem U x ‚Üí Exists fun U' => And (Membership.mem B U') (And (Membership.mem U' x) (LE.le U' U)))","decl":"theorem isBasis_iff_nbhd {B : Set (Opens Œ±)} :\n    IsBasis B ‚Üî ‚àÄ {U : Opens Œ±} {x}, x ‚àà U ‚Üí ‚àÉ U' ‚àà B, x ‚àà U' ‚àß U' ‚â§ U := by\n  constructor <;> intro h\n  ¬∑ rintro ‚ü®sU, hU‚ü© x hx\n    rcases h.mem_nhds_iff.mp (IsOpen.mem_nhds hU hx) with ‚ü®sV, ‚ü®‚ü®V, H‚ÇÅ, H‚ÇÇ‚ü©, hsV‚ü©‚ü©\n    refine ‚ü®V, H‚ÇÅ, ?_‚ü©\n    cases V\n    dsimp at H‚ÇÇ\n    subst H‚ÇÇ\n    exact hsV\n  ¬∑ refine isTopologicalBasis_of_isOpen_of_nhds ?_ ?_\n    ¬∑ rintro sU ‚ü®U, -, rfl‚ü©\n      exact U.2\n    ¬∑ intro x sU hx hsU\n      rcases @h ‚ü®sU, hsU‚ü© x hx with ‚ü®V, hV, H‚ü©\n      exact ‚ü®V, ‚ü®V, hV, rfl‚ü©, H‚ü©\n\n"}
{"name":"TopologicalSpace.Opens.isBasis_iff_cover","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nB : Set (TopologicalSpace.Opens Œ±)\n‚ä¢ Iff (TopologicalSpace.Opens.IsBasis B) (‚àÄ (U : TopologicalSpace.Opens Œ±), Exists fun Us => And (HasSubset.Subset Us B) (Eq U (SupSet.sSup Us)))","decl":"theorem isBasis_iff_cover {B : Set (Opens Œ±)} :\n    IsBasis B ‚Üî ‚àÄ U : Opens Œ±, ‚àÉ Us, Us ‚äÜ B ‚àß U = sSup Us := by\n  constructor\n  ¬∑ intro hB U\n    refine ‚ü®{ V : Opens Œ± | V ‚àà B ‚àß V ‚â§ U }, fun U hU => hU.left, ext ?_‚ü©\n    rw [coe_sSup, hB.open_eq_sUnion' U.isOpen]\n    simp_rw [sUnion_eq_biUnion, iUnion, mem_setOf_eq, iSup_and, iSup_image]\n    rfl\n  ¬∑ intro h\n    rw [isBasis_iff_nbhd]\n    intro U x hx\n    rcases h U with ‚ü®Us, hUs, rfl‚ü©\n    rcases mem_sSup.1 hx with ‚ü®U, Us, xU‚ü©\n    exact ‚ü®U, hUs Us, xU, le_sSup Us‚ü©\n\n"}
{"name":"TopologicalSpace.Opens.IsBasis.isCompact_open_iff_eq_finite_iUnion","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nŒπ : Type u_5\nb : Œπ ‚Üí TopologicalSpace.Opens Œ±\nhb : TopologicalSpace.Opens.IsBasis (Set.range b)\nhb' : ‚àÄ (i : Œπ), IsCompact ‚Üë(b i)\nU : Set Œ±\n‚ä¢ Iff (And (IsCompact U) (IsOpen U)) (Exists fun s => And s.Finite (Eq U (Set.iUnion fun i => Set.iUnion fun h => ‚Üë(b i))))","decl":"/-- If `Œ±` has a basis consisting of compact opens, then an open set in `Œ±` is compact open iff\n  it is a finite union of some elements in the basis -/\ntheorem IsBasis.isCompact_open_iff_eq_finite_iUnion {Œπ : Type*} (b : Œπ ‚Üí Opens Œ±)\n    (hb : IsBasis (Set.range b)) (hb' : ‚àÄ i, IsCompact (b i : Set Œ±)) (U : Set Œ±) :\n    IsCompact U ‚àß IsOpen U ‚Üî ‚àÉ s : Set Œπ, s.Finite ‚àß U = ‚ãÉ i ‚àà s, b i := by\n  apply isCompact_open_iff_eq_finite_iUnion_of_isTopologicalBasis fun i : Œπ => (b i).1\n  ¬∑ convert (config := {transparency := .default}) hb\n    ext\n    simp\n  ¬∑ exact hb'\n\n"}
{"name":"TopologicalSpace.Opens.IsBasis.le_iff","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_5\nt‚ÇÅ t‚ÇÇ : TopologicalSpace Œ±\nUs : Set (TopologicalSpace.Opens Œ±)\nhUs : TopologicalSpace.Opens.IsBasis Us\n‚ä¢ Iff (LE.le t‚ÇÅ t‚ÇÇ) (‚àÄ (U : TopologicalSpace.Opens Œ±), Membership.mem Us U ‚Üí IsOpen ‚ÜëU)","decl":"lemma IsBasis.le_iff {Œ±} {t‚ÇÅ t‚ÇÇ : TopologicalSpace Œ±}\n    {Us : Set (Opens Œ±)} (hUs : @IsBasis Œ± t‚ÇÇ Us) :\n    t‚ÇÅ ‚â§ t‚ÇÇ ‚Üî ‚àÄ U ‚àà Us, IsOpen[t‚ÇÅ] U := by\n  conv_lhs => rw [hUs.eq_generateFrom]\n  simp [Set.subset_def, le_generateFrom_iff_subset_isOpen]\n\n"}
{"name":"TopologicalSpace.Opens.isCompactElement_iff","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\ns : TopologicalSpace.Opens Œ±\n‚ä¢ Iff (CompleteLattice.IsCompactElement s) (IsCompact ‚Üës)","decl":"@[simp]\ntheorem isCompactElement_iff (s : Opens Œ±) :\n    CompleteLattice.IsCompactElement s ‚Üî IsCompact (s : Set Œ±) := by\n  rw [isCompact_iff_finite_subcover, CompleteLattice.isCompactElement_iff]\n  refine ‚ü®?_, fun H Œπ U hU => ?_‚ü©\n  ¬∑ introv H hU hU'\n    obtain ‚ü®t, ht‚ü© := H Œπ (fun i => ‚ü®U i, hU i‚ü©) (by simpa)\n    refine ‚ü®t, Set.Subset.trans ht ?_‚ü©\n    rw [coe_finset_sup, Finset.sup_eq_iSup]\n    rfl\n  ¬∑ obtain ‚ü®t, ht‚ü© :=\n      H (fun i => U i) (fun i => (U i).isOpen) (by simpa using show (s : Set Œ±) ‚äÜ ‚Üë(iSup U) from hU)\n    refine ‚ü®t, Set.Subset.trans ht ?_‚ü©\n    simp only [Set.iUnion_subset_iff]\n    show ‚àÄ i ‚àà t, U i ‚â§ t.sup U\n    exact fun i => Finset.le_sup\n\n"}
{"name":"TopologicalSpace.Opens.comap_id","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\n‚ä¢ Eq (TopologicalSpace.Opens.comap (ContinuousMap.id Œ±)) (FrameHom.id (TopologicalSpace.Opens Œ±))","decl":"@[simp]\ntheorem comap_id : comap (ContinuousMap.id Œ±) = FrameHom.id _ :=\n  FrameHom.ext fun _ => ext rfl\n\n"}
{"name":"TopologicalSpace.Opens.comap_mono","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : TopologicalSpace Œ≤\nf : ContinuousMap Œ± Œ≤\ns t : TopologicalSpace.Opens Œ≤\nh : LE.le s t\n‚ä¢ LE.le ((TopologicalSpace.Opens.comap f) s) ((TopologicalSpace.Opens.comap f) t)","decl":"theorem comap_mono (f : C(Œ±, Œ≤)) {s t : Opens Œ≤} (h : s ‚â§ t) : comap f s ‚â§ comap f t :=\n  OrderHomClass.mono (comap f) h\n\n"}
{"name":"TopologicalSpace.Opens.coe_comap","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : TopologicalSpace Œ≤\nf : ContinuousMap Œ± Œ≤\nU : TopologicalSpace.Opens Œ≤\n‚ä¢ Eq (‚Üë((TopologicalSpace.Opens.comap f) U)) (Set.preimage ‚áëf ‚ÜëU)","decl":"@[simp]\ntheorem coe_comap (f : C(Œ±, Œ≤)) (U : Opens Œ≤) : ‚Üë(comap f U) = f ‚Åª¬π' U :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.mem_comap","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : TopologicalSpace Œ≤\nf : ContinuousMap Œ± Œ≤\nU : TopologicalSpace.Opens Œ≤\nx : Œ±\n‚ä¢ Iff (Membership.mem ((TopologicalSpace.Opens.comap f) U) x) (Membership.mem U (f x))","decl":"@[simp]\ntheorem mem_comap {f : C(Œ±, Œ≤)} {U : Opens Œ≤} {x : Œ±} : x ‚àà comap f U ‚Üî f x ‚àà U := .rfl\n\n"}
{"name":"TopologicalSpace.Opens.comap_comp","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\nŒ≥ : Type u_4\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : TopologicalSpace Œ≥\ng : ContinuousMap Œ≤ Œ≥\nf : ContinuousMap Œ± Œ≤\n‚ä¢ Eq (TopologicalSpace.Opens.comap (g.comp f)) ((TopologicalSpace.Opens.comap f).comp (TopologicalSpace.Opens.comap g))","decl":"protected theorem comap_comp (g : C(Œ≤, Œ≥)) (f : C(Œ±, Œ≤)) :\n    comap (g.comp f) = (comap f).comp (comap g) :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.comap_comap","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\nŒ≥ : Type u_4\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : TopologicalSpace Œ≥\ng : ContinuousMap Œ≤ Œ≥\nf : ContinuousMap Œ± Œ≤\nU : TopologicalSpace.Opens Œ≥\n‚ä¢ Eq ((TopologicalSpace.Opens.comap f) ((TopologicalSpace.Opens.comap g) U)) ((TopologicalSpace.Opens.comap (g.comp f)) U)","decl":"protected theorem comap_comap (g : C(Œ≤, Œ≥)) (f : C(Œ±, Œ≤)) (U : Opens Œ≥) :\n    comap f (comap g U) = comap (g.comp f) U :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.comap_injective","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : T0Space Œ≤\n‚ä¢ Function.Injective TopologicalSpace.Opens.comap","decl":"theorem comap_injective [T0Space Œ≤] : Injective (comap : C(Œ±, Œ≤) ‚Üí FrameHom (Opens Œ≤) (Opens Œ±)) :=\n  fun f g h =>\n  ContinuousMap.ext fun a =>\n    Inseparable.eq <|\n      inseparable_iff_forall_isOpen.2 fun s hs =>\n        have : comap f ‚ü®s, hs‚ü© = comap g ‚ü®s, hs‚ü© := DFunLike.congr_fun h ‚ü®_, hs‚ü©\n        show a ‚àà f ‚Åª¬π' s ‚Üî a ‚àà g ‚Åª¬π' s from Set.ext_iff.1 (coe_inj.2 this) a\n\n"}
{"name":"Homeomorph.opensCongr_apply","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : TopologicalSpace Œ≤\nf : Homeomorph Œ± Œ≤\n‚ä¢ Eq ‚áëf.opensCongr ‚áë(TopologicalSpace.Opens.comap ‚Üëf.symm)","decl":"/-- A homeomorphism induces an order-preserving equivalence on open sets, by taking comaps. -/\n@[simps (config := .asFn) apply]\ndef _root_.Homeomorph.opensCongr (f : Œ± ‚âÉ‚Çú Œ≤) : Opens Œ± ‚âÉo Opens Œ≤ where\n  toFun := Opens.comap (f.symm : C(Œ≤, Œ±))\n  invFun := Opens.comap (f : C(Œ±, Œ≤))\n  left_inv _ := ext <| f.toEquiv.preimage_symm_preimage _\n  right_inv _ := ext <| f.toEquiv.symm_preimage_preimage _\n  map_rel_iff' := by\n    simp only [‚Üê SetLike.coe_subset_coe]; exact f.symm.surjective.preimage_subset_preimage_iff\n\n"}
{"name":"Homeomorph.opensCongr_symm","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : TopologicalSpace Œ≤\nf : Homeomorph Œ± Œ≤\n‚ä¢ Eq f.opensCongr.symm f.symm.opensCongr","decl":"@[simp]\ntheorem _root_.Homeomorph.opensCongr_symm (f : Œ± ‚âÉ‚Çú Œ≤) : f.opensCongr.symm = f.symm.opensCongr :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.instFinite","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Finite Œ±\n‚ä¢ Finite (TopologicalSpace.Opens Œ±)","decl":"instance [Finite Œ±] : Finite (Opens Œ±) :=\n  Finite.of_injective _ SetLike.coe_injective\n\n"}
{"name":"TopologicalSpace.OpenNhdsOf.mem'","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nx : Œ±\nself : TopologicalSpace.OpenNhdsOf x\n‚ä¢ Membership.mem self.carrier x","decl":"/-- The open neighborhoods of a point. See also `Opens` or `nhds`. -/\nstructure OpenNhdsOf (x : Œ±) extends Opens Œ± where\n  /-- The point `x` belongs to every `U : TopologicalSpace.OpenNhdsOf x`. -/\n  mem' : x ‚àà carrier\n\n"}
{"name":"TopologicalSpace.OpenNhdsOf.mk.inj","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nx : Œ±\ntoOpens‚úù : TopologicalSpace.Opens Œ±\nmem'‚úù : Membership.mem toOpens‚úù.carrier x\ntoOpens : TopologicalSpace.Opens Œ±\nmem' : Membership.mem toOpens.carrier x\nx‚úù : Eq { toOpens := toOpens‚úù, mem' := mem'‚úù } { toOpens := toOpens, mem' := mem' }\n‚ä¢ Eq toOpens‚úù toOpens","decl":"/-- The open neighborhoods of a point. See also `Opens` or `nhds`. -/\nstructure OpenNhdsOf (x : Œ±) extends Opens Œ± where\n  /-- The point `x` belongs to every `U : TopologicalSpace.OpenNhdsOf x`. -/\n  mem' : x ‚àà carrier\n\n"}
{"name":"TopologicalSpace.OpenNhdsOf.mk.injEq","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nx : Œ±\ntoOpens‚úù : TopologicalSpace.Opens Œ±\nmem'‚úù : Membership.mem toOpens‚úù.carrier x\ntoOpens : TopologicalSpace.Opens Œ±\nmem' : Membership.mem toOpens.carrier x\n‚ä¢ Eq (Eq { toOpens := toOpens‚úù, mem' := mem'‚úù } { toOpens := toOpens, mem' := mem' }) (Eq toOpens‚úù toOpens)","decl":"/-- The open neighborhoods of a point. See also `Opens` or `nhds`. -/\nstructure OpenNhdsOf (x : Œ±) extends Opens Œ± where\n  /-- The point `x` belongs to every `U : TopologicalSpace.OpenNhdsOf x`. -/\n  mem' : x ‚àà carrier\n\n"}
{"name":"TopologicalSpace.OpenNhdsOf.mk.sizeOf_spec","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù¬π : TopologicalSpace Œ±\nx : Œ±\ninst‚úù : SizeOf Œ±\ntoOpens : TopologicalSpace.Opens Œ±\nmem' : Membership.mem toOpens.carrier x\n‚ä¢ Eq (SizeOf.sizeOf { toOpens := toOpens, mem' := mem' }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toOpens)) (SizeOf.sizeOf mem'))","decl":"/-- The open neighborhoods of a point. See also `Opens` or `nhds`. -/\nstructure OpenNhdsOf (x : Œ±) extends Opens Œ± where\n  /-- The point `x` belongs to every `U : TopologicalSpace.OpenNhdsOf x`. -/\n  mem' : x ‚àà carrier\n\n"}
{"name":"TopologicalSpace.OpenNhdsOf.toOpens_injective","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nx : Œ±\n‚ä¢ Function.Injective TopologicalSpace.OpenNhdsOf.toOpens","decl":"theorem toOpens_injective : Injective (toOpens : OpenNhdsOf x ‚Üí Opens Œ±)\n  | ‚ü®_, _‚ü©, ‚ü®_, _‚ü©, rfl => rfl\n\n"}
{"name":"TopologicalSpace.OpenNhdsOf.canLiftSet","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nx : Œ±\n‚ä¢ CanLift (Set Œ±) (TopologicalSpace.OpenNhdsOf x) SetLike.coe fun s => And (IsOpen s) (Membership.mem s x)","decl":"instance canLiftSet : CanLift (Set Œ±) (OpenNhdsOf x) (‚Üë) fun s => IsOpen s ‚àß x ‚àà s :=\n  ‚ü®fun s hs => ‚ü®‚ü®‚ü®s, hs.1‚ü©, hs.2‚ü©, rfl‚ü©‚ü©\n\n"}
{"name":"TopologicalSpace.OpenNhdsOf.mem","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nx : Œ±\nU : TopologicalSpace.OpenNhdsOf x\n‚ä¢ Membership.mem U x","decl":"protected theorem mem (U : OpenNhdsOf x) : x ‚àà U :=\n  U.mem'\n\n"}
{"name":"TopologicalSpace.OpenNhdsOf.isOpen","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nx : Œ±\nU : TopologicalSpace.OpenNhdsOf x\n‚ä¢ IsOpen ‚ÜëU","decl":"protected theorem isOpen (U : OpenNhdsOf x) : IsOpen (U : Set Œ±) :=\n  U.is_open'\n\n"}
{"name":"TopologicalSpace.OpenNhdsOf.basis_nhds","module":"Mathlib.Topology.Sets.Opens","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nx : Œ±\n‚ä¢ (nhds x).HasBasis (fun x => True) SetLike.coe","decl":"theorem basis_nhds : (ùìù x).HasBasis (fun _ : OpenNhdsOf x => True) (‚Üë) :=\n  (nhds_basis_opens x).to_hasBasis (fun U hU => ‚ü®‚ü®‚ü®U, hU.2‚ü©, hU.1‚ü©, trivial, Subset.rfl‚ü©) fun U _ =>\n    ‚ü®U, ‚ü®‚ü®U.mem, U.isOpen‚ü©, Subset.rfl‚ü©‚ü©\n\n"}
