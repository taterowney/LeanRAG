{"name":"IsIntegralCurveOn.comp_add","module":"Mathlib.Geometry.Manifold.IntegralCurve.Transform","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\nH : Type u_2\ninst✝² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nγ : Real → M\nv : (x : M) → TangentSpace I x\ns : Set Real\nhγ : IsIntegralCurveOn γ v s\ndt : Real\n⊢ IsIntegralCurveOn (Function.comp γ fun x => HAdd.hAdd x dt) v (HVAdd.hVAdd (Neg.neg dt) s)","decl":"lemma IsIntegralCurveOn.comp_add (hγ : IsIntegralCurveOn γ v s) (dt : ℝ) :\n    IsIntegralCurveOn (γ ∘ (· + dt)) v (-dt +ᵥ s) := by\n  intros t ht\n  rw [comp_apply, ← ContinuousLinearMap.comp_id (ContinuousLinearMap.smulRight 1 (v (γ (t + dt))))]\n  rw [mem_vadd_set_iff_neg_vadd_mem, neg_neg, vadd_eq_add, add_comm,\n    ← mem_setOf (p := fun t ↦ t + dt ∈ s)] at ht\n  apply HasMFDerivAt.comp t (hγ (t + dt) ht)\n  refine ⟨(continuous_add_right _).continuousAt, ?_⟩\n  simp only [mfld_simps, hasFDerivWithinAt_univ]\n  exact HasFDerivAt.add_const (hasFDerivAt_id _) _\n\n"}
{"name":"isIntegralCurveOn_comp_add","module":"Mathlib.Geometry.Manifold.IntegralCurve.Transform","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\nH : Type u_2\ninst✝² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nγ : Real → M\nv : (x : M) → TangentSpace I x\ns : Set Real\ndt : Real\n⊢ Iff (IsIntegralCurveOn γ v s) (IsIntegralCurveOn (Function.comp γ fun x => HAdd.hAdd x dt) v (HVAdd.hVAdd (Neg.neg dt) s))","decl":"lemma isIntegralCurveOn_comp_add {dt : ℝ} :\n    IsIntegralCurveOn γ v s ↔ IsIntegralCurveOn (γ ∘ (· + dt)) v (-dt +ᵥ s) := by\n  refine ⟨fun hγ ↦ hγ.comp_add _, fun hγ ↦ ?_⟩\n  convert hγ.comp_add (-dt)\n  · ext t\n    simp only [Function.comp_apply, neg_add_cancel_right]\n  · simp only [neg_neg, vadd_neg_vadd]\n\n"}
{"name":"isIntegralCurveOn_comp_sub","module":"Mathlib.Geometry.Manifold.IntegralCurve.Transform","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\nH : Type u_2\ninst✝² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nγ : Real → M\nv : (x : M) → TangentSpace I x\ns : Set Real\ndt : Real\n⊢ Iff (IsIntegralCurveOn γ v s) (IsIntegralCurveOn (Function.comp γ fun x => HSub.hSub x dt) v (HVAdd.hVAdd dt s))","decl":"lemma isIntegralCurveOn_comp_sub {dt : ℝ} :\n    IsIntegralCurveOn γ v s ↔ IsIntegralCurveOn (γ ∘ (· - dt)) v (dt +ᵥ s) := by\n  simpa using isIntegralCurveOn_comp_add (dt := -dt)\n\n"}
{"name":"IsIntegralCurveAt.comp_add","module":"Mathlib.Geometry.Manifold.IntegralCurve.Transform","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\nH : Type u_2\ninst✝² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nγ : Real → M\nv : (x : M) → TangentSpace I x\nt₀ : Real\nhγ : IsIntegralCurveAt γ v t₀\ndt : Real\n⊢ IsIntegralCurveAt (Function.comp γ fun x => HAdd.hAdd x dt) v (HSub.hSub t₀ dt)","decl":"lemma IsIntegralCurveAt.comp_add (hγ : IsIntegralCurveAt γ v t₀) (dt : ℝ) :\n    IsIntegralCurveAt (γ ∘ (· + dt)) v (t₀ - dt) := by\n  rw [isIntegralCurveAt_iff'] at *\n  obtain ⟨ε, hε, h⟩ := hγ\n  refine ⟨ε, hε, ?_⟩\n  convert h.comp_add dt\n  rw [Metric.vadd_ball, vadd_eq_add, neg_add_eq_sub]\n\n"}
{"name":"isIntegralCurveAt_comp_add","module":"Mathlib.Geometry.Manifold.IntegralCurve.Transform","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\nH : Type u_2\ninst✝² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nγ : Real → M\nv : (x : M) → TangentSpace I x\nt₀ dt : Real\n⊢ Iff (IsIntegralCurveAt γ v t₀) (IsIntegralCurveAt (Function.comp γ fun x => HAdd.hAdd x dt) v (HSub.hSub t₀ dt))","decl":"lemma isIntegralCurveAt_comp_add {dt : ℝ} :\n    IsIntegralCurveAt γ v t₀ ↔ IsIntegralCurveAt (γ ∘ (· + dt)) v (t₀ - dt) := by\n  refine ⟨fun hγ ↦ hγ.comp_add _, fun hγ ↦ ?_⟩\n  convert hγ.comp_add (-dt)\n  · ext t\n    simp only [Function.comp_apply, neg_add_cancel_right]\n  · simp only [sub_neg_eq_add, sub_add_cancel]\n\n"}
{"name":"isIntegralCurveAt_comp_sub","module":"Mathlib.Geometry.Manifold.IntegralCurve.Transform","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\nH : Type u_2\ninst✝² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nγ : Real → M\nv : (x : M) → TangentSpace I x\nt₀ dt : Real\n⊢ Iff (IsIntegralCurveAt γ v t₀) (IsIntegralCurveAt (Function.comp γ fun x => HSub.hSub x dt) v (HAdd.hAdd t₀ dt))","decl":"lemma isIntegralCurveAt_comp_sub {dt : ℝ} :\n    IsIntegralCurveAt γ v t₀ ↔ IsIntegralCurveAt (γ ∘ (· - dt)) v (t₀ + dt) := by\n  simpa using isIntegralCurveAt_comp_add (dt := -dt)\n\n"}
{"name":"IsIntegralCurve.comp_add","module":"Mathlib.Geometry.Manifold.IntegralCurve.Transform","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\nH : Type u_2\ninst✝² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nγ : Real → M\nv : (x : M) → TangentSpace I x\nhγ : IsIntegralCurve γ v\ndt : Real\n⊢ IsIntegralCurve (Function.comp γ fun x => HAdd.hAdd x dt) v","decl":"lemma IsIntegralCurve.comp_add (hγ : IsIntegralCurve γ v) (dt : ℝ) :\n    IsIntegralCurve (γ ∘ (· + dt)) v := by\n  rw [isIntegralCurve_iff_isIntegralCurveOn] at *\n  simpa using hγ.comp_add dt\n\n"}
{"name":"isIntegralCurve_comp_add","module":"Mathlib.Geometry.Manifold.IntegralCurve.Transform","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\nH : Type u_2\ninst✝² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nγ : Real → M\nv : (x : M) → TangentSpace I x\ndt : Real\n⊢ Iff (IsIntegralCurve γ v) (IsIntegralCurve (Function.comp γ fun x => HAdd.hAdd x dt) v)","decl":"lemma isIntegralCurve_comp_add {dt : ℝ} :\n    IsIntegralCurve γ v ↔ IsIntegralCurve (γ ∘ (· + dt)) v := by\n  refine ⟨fun hγ ↦ hγ.comp_add _, fun hγ ↦ ?_⟩\n  convert hγ.comp_add (-dt)\n  ext t\n  simp only [Function.comp_apply, neg_add_cancel_right]\n\n"}
{"name":"isIntegralCurve_comp_sub","module":"Mathlib.Geometry.Manifold.IntegralCurve.Transform","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\nH : Type u_2\ninst✝² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nγ : Real → M\nv : (x : M) → TangentSpace I x\ndt : Real\n⊢ Iff (IsIntegralCurve γ v) (IsIntegralCurve (Function.comp γ fun x => HSub.hSub x dt) v)","decl":"lemma isIntegralCurve_comp_sub {dt : ℝ} :\n    IsIntegralCurve γ v ↔ IsIntegralCurve (γ ∘ (· - dt)) v := by\n  simpa using isIntegralCurve_comp_add (dt := -dt)\n\n"}
{"name":"IsIntegralCurveOn.comp_mul","module":"Mathlib.Geometry.Manifold.IntegralCurve.Transform","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\nH : Type u_2\ninst✝² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nγ : Real → M\nv : (x : M) → TangentSpace I x\ns : Set Real\nhγ : IsIntegralCurveOn γ v s\na : Real\n⊢ IsIntegralCurveOn (Function.comp γ fun x => HMul.hMul x a) (HSMul.hSMul a v) (setOf fun t => Membership.mem s (HMul.hMul t a))","decl":"lemma IsIntegralCurveOn.comp_mul (hγ : IsIntegralCurveOn γ v s) (a : ℝ) :\n    IsIntegralCurveOn (γ ∘ (· * a)) (a • v) { t | t * a ∈ s } := by\n  intros t ht\n  rw [comp_apply, Pi.smul_apply, ← ContinuousLinearMap.smulRight_comp]\n  refine HasMFDerivAt.comp t (hγ (t * a) ht) ⟨(continuous_mul_right _).continuousAt, ?_⟩\n  simp only [mfld_simps, hasFDerivWithinAt_univ]\n  exact HasFDerivAt.mul_const' (hasFDerivAt_id _) _\n\n"}
{"name":"isIntegralCurveOn_comp_mul_ne_zero","module":"Mathlib.Geometry.Manifold.IntegralCurve.Transform","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\nH : Type u_2\ninst✝² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nγ : Real → M\nv : (x : M) → TangentSpace I x\ns : Set Real\na : Real\nha : Ne a 0\n⊢ Iff (IsIntegralCurveOn γ v s) (IsIntegralCurveOn (Function.comp γ fun x => HMul.hMul x a) (HSMul.hSMul a v) (setOf fun t => Membership.mem s (HMul.hMul t a)))","decl":"lemma isIntegralCurveOn_comp_mul_ne_zero {a : ℝ} (ha : a ≠ 0) :\n    IsIntegralCurveOn γ v s ↔ IsIntegralCurveOn (γ ∘ (· * a)) (a • v) { t | t * a ∈ s } := by\n  refine ⟨fun hγ ↦ hγ.comp_mul a, fun hγ ↦ ?_⟩\n  convert hγ.comp_mul a⁻¹\n  · ext t\n    simp only [Function.comp_apply, mul_assoc, inv_mul_eq_div, div_self ha, mul_one]\n  · simp only [smul_smul, inv_mul_eq_div, div_self ha, one_smul]\n  · simp only [mem_setOf_eq, mul_assoc, inv_mul_eq_div, div_self ha, mul_one, setOf_mem_eq]\n\n"}
{"name":"IsIntegralCurveAt.comp_mul_ne_zero","module":"Mathlib.Geometry.Manifold.IntegralCurve.Transform","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\nH : Type u_2\ninst✝² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nγ : Real → M\nv : (x : M) → TangentSpace I x\nt₀ : Real\nhγ : IsIntegralCurveAt γ v t₀\na : Real\nha : Ne a 0\n⊢ IsIntegralCurveAt (Function.comp γ fun x => HMul.hMul x a) (HSMul.hSMul a v) (HDiv.hDiv t₀ a)","decl":"lemma IsIntegralCurveAt.comp_mul_ne_zero (hγ : IsIntegralCurveAt γ v t₀) {a : ℝ} (ha : a ≠ 0) :\n    IsIntegralCurveAt (γ ∘ (· * a)) (a • v) (t₀ / a) := by\n  rw [isIntegralCurveAt_iff'] at *\n  obtain ⟨ε, hε, h⟩ := hγ\n  refine ⟨ε / |a|, by positivity, ?_⟩\n  convert h.comp_mul a\n  ext t\n  rw [mem_setOf_eq, Metric.mem_ball, Metric.mem_ball, Real.dist_eq, Real.dist_eq,\n    lt_div_iff₀ (abs_pos.mpr ha), ← abs_mul, sub_mul, div_mul_cancel₀ _ ha]\n\n"}
{"name":"isIntegralCurveAt_comp_mul_ne_zero","module":"Mathlib.Geometry.Manifold.IntegralCurve.Transform","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\nH : Type u_2\ninst✝² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nγ : Real → M\nv : (x : M) → TangentSpace I x\nt₀ a : Real\nha : Ne a 0\n⊢ Iff (IsIntegralCurveAt γ v t₀) (IsIntegralCurveAt (Function.comp γ fun x => HMul.hMul x a) (HSMul.hSMul a v) (HDiv.hDiv t₀ a))","decl":"lemma isIntegralCurveAt_comp_mul_ne_zero {a : ℝ} (ha : a ≠ 0) :\n    IsIntegralCurveAt γ v t₀ ↔ IsIntegralCurveAt (γ ∘ (· * a)) (a • v) (t₀ / a) := by\n  refine ⟨fun hγ ↦ hγ.comp_mul_ne_zero ha, fun hγ ↦ ?_⟩\n  convert hγ.comp_mul_ne_zero (inv_ne_zero ha)\n  · ext t\n    simp only [Function.comp_apply, mul_assoc, inv_mul_eq_div, div_self ha, mul_one]\n  · simp only [smul_smul, inv_mul_eq_div, div_self ha, one_smul]\n  · simp only [div_inv_eq_mul, div_mul_cancel₀ _ ha]\n\n"}
{"name":"IsIntegralCurve.comp_mul","module":"Mathlib.Geometry.Manifold.IntegralCurve.Transform","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\nH : Type u_2\ninst✝² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nγ : Real → M\nv : (x : M) → TangentSpace I x\nhγ : IsIntegralCurve γ v\na : Real\n⊢ IsIntegralCurve (Function.comp γ fun x => HMul.hMul x a) (HSMul.hSMul a v)","decl":"lemma IsIntegralCurve.comp_mul (hγ : IsIntegralCurve γ v) (a : ℝ) :\n    IsIntegralCurve (γ ∘ (· * a)) (a • v) := by\n  rw [isIntegralCurve_iff_isIntegralCurveOn] at *\n  exact hγ.comp_mul _\n\n"}
{"name":"isIntegralCurve_comp_mul_ne_zero","module":"Mathlib.Geometry.Manifold.IntegralCurve.Transform","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\nH : Type u_2\ninst✝² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nγ : Real → M\nv : (x : M) → TangentSpace I x\na : Real\nha : Ne a 0\n⊢ Iff (IsIntegralCurve γ v) (IsIntegralCurve (Function.comp γ fun x => HMul.hMul x a) (HSMul.hSMul a v))","decl":"lemma isIntegralCurve_comp_mul_ne_zero {a : ℝ} (ha : a ≠ 0) :\n    IsIntegralCurve γ v ↔ IsIntegralCurve (γ ∘ (· * a)) (a • v) := by\n  refine ⟨fun hγ ↦ hγ.comp_mul _, fun hγ ↦ ?_⟩\n  convert hγ.comp_mul a⁻¹\n  · ext t\n    simp only [Function.comp_apply, mul_assoc, inv_mul_eq_div, div_self ha, mul_one]\n  · simp only [smul_smul, inv_mul_eq_div, div_self ha, one_smul]\n\n"}
{"name":"isIntegralCurve_const","module":"Mathlib.Geometry.Manifold.IntegralCurve.Transform","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\nH : Type u_2\ninst✝² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nv : (x : M) → TangentSpace I x\nx : M\nh : Eq (v x) 0\n⊢ IsIntegralCurve (fun x_1 => x) v","decl":"/-- If the vector field `v` vanishes at `x₀`, then the constant curve at `x₀`\nis a global integral curve of `v`. -/\nlemma isIntegralCurve_const {x : M} (h : v x = 0) : IsIntegralCurve (fun _ ↦ x) v := by\n  intro t\n  rw [h, ← ContinuousLinearMap.zero_apply (R₁ := ℝ) (R₂ := ℝ) (1 : ℝ),\n    ContinuousLinearMap.smulRight_one_one]\n  exact hasMFDerivAt_const ..\n\n"}
