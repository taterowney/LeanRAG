{"name":"CategoryTheory.Functor.HomObj.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Functor.FunctorHom","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬≤ : CategoryTheory.Category.{v', u'} D\nF G : CategoryTheory.Functor C D\nA : CategoryTheory.Functor C (Type w)\ninst‚úù¬π : SizeOf C\ninst‚úù : SizeOf D\napp : (c : C) ‚Üí A.obj c ‚Üí Quiver.Hom (F.obj c) (G.obj c)\nnaturality : autoParam (‚àÄ {c d : C} (f : Quiver.Hom c d) (a : A.obj c), Eq (CategoryTheory.CategoryStruct.comp (F.map f) (app d (A.map f a))) (CategoryTheory.CategoryStruct.comp (app c a) (G.map f))) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { app := app, naturality := naturality }) 1","decl":"/-- Given functors `F G : C ‚•§ D`, `HomObj F G A` is a proxy for the type\nof \"morphisms\" `F ‚äó A ‚ü∂ G`, where `A : C ‚•§ Type w` (`w` an arbitrary universe). -/\n@[ext]\nstructure HomObj (A : C ‚•§ Type w) where\n  /-- The morphism `F.obj c ‚ü∂ G.obj c` associated with `a : A.obj c`. -/\n  app (c : C) (a : A.obj c) : F.obj c ‚ü∂ G.obj c\n  naturality {c d : C} (f : c ‚ü∂ d) (a : A.obj c) :\n    F.map f ‚â´ app d (A.map f a) = app c a ‚â´ G.map f := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.HomObj.ext_iff","module":"Mathlib.CategoryTheory.Functor.FunctorHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF G : CategoryTheory.Functor C D\nA : CategoryTheory.Functor C (Type w)\nx y : F.HomObj G A\n‚ä¢ Iff (Eq x y) (Eq x.app y.app)","decl":"/-- Given functors `F G : C ‚•§ D`, `HomObj F G A` is a proxy for the type\nof \"morphisms\" `F ‚äó A ‚ü∂ G`, where `A : C ‚•§ Type w` (`w` an arbitrary universe). -/\n@[ext]\nstructure HomObj (A : C ‚•§ Type w) where\n  /-- The morphism `F.obj c ‚ü∂ G.obj c` associated with `a : A.obj c`. -/\n  app (c : C) (a : A.obj c) : F.obj c ‚ü∂ G.obj c\n  naturality {c d : C} (f : c ‚ü∂ d) (a : A.obj c) :\n    F.map f ‚â´ app d (A.map f a) = app c a ‚â´ G.map f := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.HomObj.mk.inj","module":"Mathlib.CategoryTheory.Functor.FunctorHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF G : CategoryTheory.Functor C D\nA : CategoryTheory.Functor C (Type w)\napp‚úù : (c : C) ‚Üí A.obj c ‚Üí Quiver.Hom (F.obj c) (G.obj c)\nnaturality‚úù : autoParam (‚àÄ {c d : C} (f : Quiver.Hom c d) (a : A.obj c), Eq (CategoryTheory.CategoryStruct.comp (F.map f) (app‚úù d (A.map f a))) (CategoryTheory.CategoryStruct.comp (app‚úù c a) (G.map f))) _auto‚úù\napp : (c : C) ‚Üí A.obj c ‚Üí Quiver.Hom (F.obj c) (G.obj c)\nnaturality : autoParam (‚àÄ {c d : C} (f : Quiver.Hom c d) (a : A.obj c), Eq (CategoryTheory.CategoryStruct.comp (F.map f) (app d (A.map f a))) (CategoryTheory.CategoryStruct.comp (app c a) (G.map f))) _auto‚úù\nx‚úù : Eq { app := app‚úù, naturality := naturality‚úù } { app := app, naturality := naturality }\n‚ä¢ Eq app‚úù app","decl":"/-- Given functors `F G : C ‚•§ D`, `HomObj F G A` is a proxy for the type\nof \"morphisms\" `F ‚äó A ‚ü∂ G`, where `A : C ‚•§ Type w` (`w` an arbitrary universe). -/\n@[ext]\nstructure HomObj (A : C ‚•§ Type w) where\n  /-- The morphism `F.obj c ‚ü∂ G.obj c` associated with `a : A.obj c`. -/\n  app (c : C) (a : A.obj c) : F.obj c ‚ü∂ G.obj c\n  naturality {c d : C} (f : c ‚ü∂ d) (a : A.obj c) :\n    F.map f ‚â´ app d (A.map f a) = app c a ‚â´ G.map f := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.HomObj.mk.injEq","module":"Mathlib.CategoryTheory.Functor.FunctorHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF G : CategoryTheory.Functor C D\nA : CategoryTheory.Functor C (Type w)\napp‚úù : (c : C) ‚Üí A.obj c ‚Üí Quiver.Hom (F.obj c) (G.obj c)\nnaturality‚úù : autoParam (‚àÄ {c d : C} (f : Quiver.Hom c d) (a : A.obj c), Eq (CategoryTheory.CategoryStruct.comp (F.map f) (app‚úù d (A.map f a))) (CategoryTheory.CategoryStruct.comp (app‚úù c a) (G.map f))) _auto‚úù\napp : (c : C) ‚Üí A.obj c ‚Üí Quiver.Hom (F.obj c) (G.obj c)\nnaturality : autoParam (‚àÄ {c d : C} (f : Quiver.Hom c d) (a : A.obj c), Eq (CategoryTheory.CategoryStruct.comp (F.map f) (app d (A.map f a))) (CategoryTheory.CategoryStruct.comp (app c a) (G.map f))) _auto‚úù\n‚ä¢ Eq (Eq { app := app‚úù, naturality := naturality‚úù } { app := app, naturality := naturality }) (Eq app‚úù app)","decl":"/-- Given functors `F G : C ‚•§ D`, `HomObj F G A` is a proxy for the type\nof \"morphisms\" `F ‚äó A ‚ü∂ G`, where `A : C ‚•§ Type w` (`w` an arbitrary universe). -/\n@[ext]\nstructure HomObj (A : C ‚•§ Type w) where\n  /-- The morphism `F.obj c ‚ü∂ G.obj c` associated with `a : A.obj c`. -/\n  app (c : C) (a : A.obj c) : F.obj c ‚ü∂ G.obj c\n  naturality {c d : C} (f : c ‚ü∂ d) (a : A.obj c) :\n    F.map f ‚â´ app d (A.map f a) = app c a ‚â´ G.map f := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.HomObj.naturality","module":"Mathlib.CategoryTheory.Functor.FunctorHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF G : CategoryTheory.Functor C D\nA : CategoryTheory.Functor C (Type w)\nself : F.HomObj G A\nc d : C\nf : Quiver.Hom c d\na : A.obj c\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map f) (self.app d (A.map f a))) (CategoryTheory.CategoryStruct.comp (self.app c a) (G.map f))","decl":"/-- Given functors `F G : C ‚•§ D`, `HomObj F G A` is a proxy for the type\nof \"morphisms\" `F ‚äó A ‚ü∂ G`, where `A : C ‚•§ Type w` (`w` an arbitrary universe). -/\n@[ext]\nstructure HomObj (A : C ‚•§ Type w) where\n  /-- The morphism `F.obj c ‚ü∂ G.obj c` associated with `a : A.obj c`. -/\n  app (c : C) (a : A.obj c) : F.obj c ‚ü∂ G.obj c\n  naturality {c d : C} (f : c ‚ü∂ d) (a : A.obj c) :\n    F.map f ‚â´ app d (A.map f a) = app c a ‚â´ G.map f := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.HomObj.ext","module":"Mathlib.CategoryTheory.Functor.FunctorHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF G : CategoryTheory.Functor C D\nA : CategoryTheory.Functor C (Type w)\nx y : F.HomObj G A\napp : Eq x.app y.app\n‚ä¢ Eq x y","decl":"/-- Given functors `F G : C ‚•§ D`, `HomObj F G A` is a proxy for the type\nof \"morphisms\" `F ‚äó A ‚ü∂ G`, where `A : C ‚•§ Type w` (`w` an arbitrary universe). -/\n@[ext]\nstructure HomObj (A : C ‚•§ Type w) where\n  /-- The morphism `F.obj c ‚ü∂ G.obj c` associated with `a : A.obj c`. -/\n  app (c : C) (a : A.obj c) : F.obj c ‚ü∂ G.obj c\n  naturality {c d : C} (f : c ‚ü∂ d) (a : A.obj c) :\n    F.map f ‚â´ app d (A.map f a) = app c a ‚â´ G.map f := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.homObjEquiv_apply_app","module":"Mathlib.CategoryTheory.Functor.FunctorHom","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G A : CategoryTheory.Functor C (Type w)\na : F.HomObj G A\nX : C\nx‚úù : (CategoryTheory.MonoidalCategoryStruct.tensorObj F A).obj X\n‚ä¢ Eq (((F.homObjEquiv G A) a).app X x‚úù) (CategoryTheory.Functor.homObjEquiv.match_1 F A X (fun x => G.obj X) x‚úù fun x y => a.app X y x)","decl":"/-- When `F`, `G`, and `A` are all functors `C ‚•§ Type w`, then `HomObj F G A` is in\nbijection with `F ‚äó A ‚ü∂ G`. -/\n@[simps]\ndef homObjEquiv (F G A : C ‚•§ Type w) : (HomObj F G A) ‚âÉ (F ‚äó A ‚ü∂ G) where\n  toFun a := ‚ü®fun X ‚ü®x, y‚ü© ‚Ü¶ a.app X y x, fun X Y f ‚Ü¶ by\n    ext ‚ü®x, y‚ü©\n    erw [congr_fun (a.naturality f y) x]\n    rfl ‚ü©\n  invFun a := ‚ü®fun X y x ‚Ü¶ a.app X (x, y), fun œÜ y ‚Ü¶ by\n    ext x\n    erw [congr_fun (a.naturality œÜ) (x, y)]\n    rfl ‚ü©\n  left_inv _ := by aesop\n  right_inv _ := by aesop\n\n"}
{"name":"CategoryTheory.Functor.homObjEquiv_symm_apply_app","module":"Mathlib.CategoryTheory.Functor.FunctorHom","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G A : CategoryTheory.Functor C (Type w)\na : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj F A) G\nX : C\ny : A.obj X\nx : F.obj X\n‚ä¢ Eq (((F.homObjEquiv G A).symm a).app X y x) (a.app X { fst := x, snd := y })","decl":"/-- When `F`, `G`, and `A` are all functors `C ‚•§ Type w`, then `HomObj F G A` is in\nbijection with `F ‚äó A ‚ü∂ G`. -/\n@[simps]\ndef homObjEquiv (F G A : C ‚•§ Type w) : (HomObj F G A) ‚âÉ (F ‚äó A ‚ü∂ G) where\n  toFun a := ‚ü®fun X ‚ü®x, y‚ü© ‚Ü¶ a.app X y x, fun X Y f ‚Ü¶ by\n    ext ‚ü®x, y‚ü©\n    erw [congr_fun (a.naturality f y) x]\n    rfl ‚ü©\n  invFun a := ‚ü®fun X y x ‚Ü¶ a.app X (x, y), fun œÜ y ‚Ü¶ by\n    ext x\n    erw [congr_fun (a.naturality œÜ) (x, y)]\n    rfl ‚ü©\n  left_inv _ := by aesop\n  right_inv _ := by aesop\n\n"}
{"name":"CategoryTheory.Functor.HomObj.naturality_assoc","module":"Mathlib.CategoryTheory.Functor.FunctorHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF G : CategoryTheory.Functor C D\nA : CategoryTheory.Functor C (Type w)\nself : F.HomObj G A\nc d : C\nf : Quiver.Hom c d\na : A.obj c\nZ : D\nh : Quiver.Hom (G.obj d) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map f) (CategoryTheory.CategoryStruct.comp (self.app d (A.map f a)) h)) (CategoryTheory.CategoryStruct.comp (self.app c a) (CategoryTheory.CategoryStruct.comp (G.map f) h))","decl":"attribute [reassoc (attr := simp)] naturality\n\n"}
{"name":"CategoryTheory.Functor.HomObj.congr_app","module":"Mathlib.CategoryTheory.Functor.FunctorHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF G : CategoryTheory.Functor C D\nA : CategoryTheory.Functor C (Type w)\nf g : F.HomObj G A\nh : Eq f g\nX : C\na : A.obj X\n‚ä¢ Eq (f.app X a) (g.app X a)","decl":"lemma congr_app {f g : HomObj F G A} (h : f = g) (X : C)\n    (a : A.obj X) : f.app X a = g.app X a := by subst h; rfl\n\n"}
{"name":"CategoryTheory.Functor.HomObj.ofNatTrans_app","module":"Mathlib.CategoryTheory.Functor.FunctorHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF G : CategoryTheory.Functor C D\nA : CategoryTheory.Functor C (Type w)\nf : Quiver.Hom F G\nX : C\nx‚úù : A.obj X\n‚ä¢ Eq ((CategoryTheory.Functor.HomObj.ofNatTrans f).app X x‚úù) (f.app X)","decl":"/-- Given a natural transformation `F ‚ü∂ G`, get a term of `HomObj F G A` by \"ignoring\" `A`. -/\n@[simps]\ndef ofNatTrans (f : F ‚ü∂ G) : HomObj F G A where\n  app X _ := f.app X\n\n"}
{"name":"CategoryTheory.Functor.HomObj.id_app","module":"Mathlib.CategoryTheory.Functor.FunctorHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\nA : CategoryTheory.Functor C (Type w)\nX : C\nx‚úù : A.obj X\n‚ä¢ Eq ((CategoryTheory.Functor.HomObj.id A).app X x‚úù) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- The identity `HomObj F F A`. -/\n@[simps!]\ndef id (A : C ‚•§ Type w) : HomObj F F A := ofNatTrans (ùüô F)\n\n"}
{"name":"CategoryTheory.Functor.HomObj.comp_app","module":"Mathlib.CategoryTheory.Functor.FunctorHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF G : CategoryTheory.Functor C D\nA : CategoryTheory.Functor C (Type w)\nM : CategoryTheory.Functor C D\nf : F.HomObj G A\ng : G.HomObj M A\nX : C\na : A.obj X\n‚ä¢ Eq ((f.comp g).app X a) (CategoryTheory.CategoryStruct.comp (f.app X a) (g.app X a))","decl":"/-- Composition of `f : HomObj F G A` with `g : HomObj G M A`. -/\n@[simps]\ndef comp {M : C ‚•§ D} (f : HomObj F G A) (g : HomObj G M A) : HomObj F M A where\n  app X a := f.app X a ‚â´ g.app X a\n\n"}
{"name":"CategoryTheory.Functor.HomObj.map_app","module":"Mathlib.CategoryTheory.Functor.FunctorHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF G : CategoryTheory.Functor C D\nA A' : CategoryTheory.Functor C (Type w)\nf : Quiver.Hom A' A\nx : F.HomObj G A\nŒî : C\na : A'.obj Œî\n‚ä¢ Eq ((CategoryTheory.Functor.HomObj.map f x).app Œî a) (x.app Œî (f.app Œî a))","decl":"/-- Given a morphism `A' ‚ü∂ A`, send a term of `HomObj F G A` to a term of `HomObj F G A'`. -/\n@[simps]\ndef map {A' : C ‚•§ Type w} (f : A' ‚ü∂ A) (x : HomObj F G A) : HomObj F G A' where\n  app Œî a := x.app Œî (f.app Œî a)\n  naturality {Œî Œî'} œÜ a := by\n    dsimp\n    rw [‚Üê x.naturality œÜ (f.app Œî a), FunctorToTypes.naturality _ _ f œÜ a]\n\n"}
{"name":"CategoryTheory.Functor.homObjFunctor_map_app","module":"Mathlib.CategoryTheory.Functor.FunctorHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF G : CategoryTheory.Functor C D\nA A' : Opposite (CategoryTheory.Functor C (Type w))\nf : Quiver.Hom A A'\nx : F.HomObj G (Opposite.unop A)\nX : C\na : (Opposite.unop A').obj X\n‚ä¢ Eq (((F.homObjFunctor G).map f x).app X a) (x.app X (f.unop.app X a))","decl":"/-- The contravariant functor taking `A : C ‚•§ Type w` to `HomObj F G A`, i.e. Hom(F ‚äó -, G). -/\n@[simps]\ndef homObjFunctor : (C ‚•§ Type w)·µí·µñ ‚•§ Type max w v' u where\n  obj A := HomObj F G A.unop\n  map {A A'} f x :=\n    { app := fun X a ‚Ü¶ x.app X (f.unop.app _ a)\n      naturality := fun {X Y} œÜ a ‚Ü¶ by\n        dsimp\n        rw [‚Üê HomObj.naturality]\n        congr 2\n        exact congr_fun (f.unop.naturality œÜ) a }\n\n"}
{"name":"CategoryTheory.Functor.homObjFunctor_obj","module":"Mathlib.CategoryTheory.Functor.FunctorHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF G : CategoryTheory.Functor C D\nA : Opposite (CategoryTheory.Functor C (Type w))\n‚ä¢ Eq ((F.homObjFunctor G).obj A) (F.HomObj G (Opposite.unop A))","decl":"/-- The contravariant functor taking `A : C ‚•§ Type w` to `HomObj F G A`, i.e. Hom(F ‚äó -, G). -/\n@[simps]\ndef homObjFunctor : (C ‚•§ Type w)·µí·µñ ‚•§ Type max w v' u where\n  obj A := HomObj F G A.unop\n  map {A A'} f x :=\n    { app := fun X a ‚Ü¶ x.app X (f.unop.app _ a)\n      naturality := fun {X Y} œÜ a ‚Ü¶ by\n        dsimp\n        rw [‚Üê HomObj.naturality]\n        congr 2\n        exact congr_fun (f.unop.naturality œÜ) a }\n\n"}
{"name":"CategoryTheory.Functor.functorHom_ext_iff","module":"Mathlib.CategoryTheory.Functor.FunctorHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF G : CategoryTheory.Functor C D\nX : C\nx y : (F.functorHom G).obj X\n‚ä¢ Iff (Eq x y) (‚àÄ (Y : C) (f : Quiver.Hom X Y), Eq (x.app Y f) (y.app Y f))","decl":"variable {F G} in\n@[ext]\nlemma functorHom_ext {X : C} {x y : (F.functorHom G).obj X}\n    (h : ‚àÄ (Y : C) (f : X ‚ü∂ Y), x.app Y f = y.app Y f) : x = y :=\n  HomObj.ext (by ext; apply h)\n\n"}
{"name":"CategoryTheory.Functor.functorHom_ext","module":"Mathlib.CategoryTheory.Functor.FunctorHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF G : CategoryTheory.Functor C D\nX : C\nx y : (F.functorHom G).obj X\nh : ‚àÄ (Y : C) (f : Quiver.Hom X Y), Eq (x.app Y f) (y.app Y f)\n‚ä¢ Eq x y","decl":"variable {F G} in\n@[ext]\nlemma functorHom_ext {X : C} {x y : (F.functorHom G).obj X}\n    (h : ‚àÄ (Y : C) (f : X ‚ü∂ Y), x.app Y f = y.app Y f) : x = y :=\n  HomObj.ext (by ext; apply h)\n\n"}
{"name":"CategoryTheory.Functor.functorHomEquiv_apply_app","module":"Mathlib.CategoryTheory.Functor.FunctorHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF G : CategoryTheory.Functor C D\nA : CategoryTheory.Functor C (Type (max u v v'))\nœÜ : Quiver.Hom A (F.functorHom G)\nX : C\na : A.obj X\n‚ä¢ Eq (((F.functorHomEquiv G A) œÜ).app X a) ((œÜ.app X a).app X (CategoryTheory.CategoryStruct.id (Opposite.unop { unop := X })))","decl":"/-- The equivalence `(A ‚ü∂ F.functorHom G) ‚âÉ HomObj F G A`. -/\n@[simps]\ndef functorHomEquiv (A : C ‚•§ Type max u v v') : (A ‚ü∂ F.functorHom G) ‚âÉ HomObj F G A where\n  toFun œÜ :=\n    { app := fun X a ‚Ü¶ (œÜ.app X a).app X (ùüô _)\n      naturality := fun {X Y} f a => by\n        rw [‚Üê (œÜ.app X a).naturality f (ùüô _)]\n        have := HomObj.congr_app (congr_fun (œÜ.naturality f) a) Y (ùüô _)\n        dsimp [functorHom, homObjFunctor] at this\n        aesop }\n  invFun x :=\n    { app := fun X a ‚Ü¶ { app := fun Y f => x.app Y (A.map f a) }\n      naturality := fun X Y f => by\n        ext\n        dsimp only [types_comp_apply]\n        rw [‚Üê FunctorToTypes.map_comp_apply]\n        rfl }\n  left_inv œÜ := by\n    ext X a Y f\n    exact (HomObj.congr_app (congr_fun (œÜ.naturality f) a) Y (ùüô _)).trans\n      (congr_arg ((œÜ.app X a).app Y) (by simp))\n  right_inv x := by simp\n\n"}
{"name":"CategoryTheory.Functor.functorHomEquiv_symm_apply_app_app","module":"Mathlib.CategoryTheory.Functor.FunctorHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF G : CategoryTheory.Functor C D\nA : CategoryTheory.Functor C (Type (max u v v'))\nx : F.HomObj G A\nX : C\na : A.obj X\nY : C\nf : (Opposite.unop (CategoryTheory.coyoneda.rightOp.obj X)).obj Y\n‚ä¢ Eq ((((F.functorHomEquiv G A).symm x).app X a).app Y f) (x.app Y (A.map f a))","decl":"/-- The equivalence `(A ‚ü∂ F.functorHom G) ‚âÉ HomObj F G A`. -/\n@[simps]\ndef functorHomEquiv (A : C ‚•§ Type max u v v') : (A ‚ü∂ F.functorHom G) ‚âÉ HomObj F G A where\n  toFun œÜ :=\n    { app := fun X a ‚Ü¶ (œÜ.app X a).app X (ùüô _)\n      naturality := fun {X Y} f a => by\n        rw [‚Üê (œÜ.app X a).naturality f (ùüô _)]\n        have := HomObj.congr_app (congr_fun (œÜ.naturality f) a) Y (ùüô _)\n        dsimp [functorHom, homObjFunctor] at this\n        aesop }\n  invFun x :=\n    { app := fun X a ‚Ü¶ { app := fun Y f => x.app Y (A.map f a) }\n      naturality := fun X Y f => by\n        ext\n        dsimp only [types_comp_apply]\n        rw [‚Üê FunctorToTypes.map_comp_apply]\n        rfl }\n  left_inv œÜ := by\n    ext X a Y f\n    exact (HomObj.congr_app (congr_fun (œÜ.naturality f) a) Y (ùüô _)).trans\n      (congr_arg ((œÜ.app X a).app Y) (by simp))\n  right_inv x := by simp\n\n"}
{"name":"CategoryTheory.Functor.natTransEquiv_apply_app","module":"Mathlib.CategoryTheory.Functor.FunctorHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF G : CategoryTheory.Functor C D\nf : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit (F.functorHom G)\nX : C\n‚ä¢ Eq ((CategoryTheory.Functor.natTransEquiv f).app X) ((f.app X PUnit.unit).app X (CategoryTheory.CategoryStruct.id (Opposite.unop { unop := X })))","decl":"variable {F G} in\n/-- Morphisms `(ùüô_ (C ‚•§ Type max v' v u) ‚ü∂ F.functorHom G)` are in bijection with\nmorphisms `F ‚ü∂ G`. -/\n@[simps]\ndef natTransEquiv : (ùüô_ (C ‚•§ Type max v' v u) ‚ü∂ F.functorHom G) ‚âÉ (F ‚ü∂ G) where\n  toFun f := ‚ü®fun X ‚Ü¶ (f.app X (PUnit.unit)).app X (ùüô _), by\n    intro X Y œÜ\n    rw [‚Üê (f.app X (PUnit.unit)).naturality œÜ]\n    congr 1\n    have := HomObj.congr_app (congr_fun (f.naturality œÜ) PUnit.unit) Y (ùüô Y)\n    dsimp [functorHom, homObjFunctor] at this\n    aesop ‚ü©\n  invFun f := { app _ _ := HomObj.ofNatTrans f }\n  left_inv f := by\n    ext X a Y œÜ\n    have := HomObj.congr_app (congr_fun (f.naturality œÜ) PUnit.unit) Y (ùüô Y)\n    dsimp [functorHom, homObjFunctor] at this\n    aesop\n  right_inv _ := rfl\n\n"}
{"name":"CategoryTheory.Functor.natTransEquiv_symm_apply_app","module":"Mathlib.CategoryTheory.Functor.FunctorHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF G : CategoryTheory.Functor C D\nf : Quiver.Hom F G\nx‚úù¬π : C\nx‚úù : CategoryTheory.MonoidalCategoryStruct.tensorUnit.obj x‚úù¬π\n‚ä¢ Eq ((CategoryTheory.Functor.natTransEquiv.symm f).app x‚úù¬π x‚úù) (CategoryTheory.Functor.HomObj.ofNatTrans f)","decl":"variable {F G} in\n/-- Morphisms `(ùüô_ (C ‚•§ Type max v' v u) ‚ü∂ F.functorHom G)` are in bijection with\nmorphisms `F ‚ü∂ G`. -/\n@[simps]\ndef natTransEquiv : (ùüô_ (C ‚•§ Type max v' v u) ‚ü∂ F.functorHom G) ‚âÉ (F ‚ü∂ G) where\n  toFun f := ‚ü®fun X ‚Ü¶ (f.app X (PUnit.unit)).app X (ùüô _), by\n    intro X Y œÜ\n    rw [‚Üê (f.app X (PUnit.unit)).naturality œÜ]\n    congr 1\n    have := HomObj.congr_app (congr_fun (f.naturality œÜ) PUnit.unit) Y (ùüô Y)\n    dsimp [functorHom, homObjFunctor] at this\n    aesop ‚ü©\n  invFun f := { app _ _ := HomObj.ofNatTrans f }\n  left_inv f := by\n    ext X a Y œÜ\n    have := HomObj.congr_app (congr_fun (f.naturality œÜ) PUnit.unit) Y (ùüô Y)\n    dsimp [functorHom, homObjFunctor] at this\n    aesop\n  right_inv _ := rfl\n\n"}
{"name":"CategoryTheory.Enriched.Functor.natTransEquiv_symm_app_app_apply","module":"Mathlib.CategoryTheory.Functor.FunctorHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF G : CategoryTheory.Functor C D\nf : Quiver.Hom F G\nX : C\na : CategoryTheory.MonoidalCategoryStruct.tensorUnit.obj X\nY : C\nœÜ : Quiver.Hom X Y\n‚ä¢ Eq (((CategoryTheory.Functor.natTransEquiv.symm f).app X a).app Y œÜ) (f.app Y)","decl":"@[simp]\nlemma natTransEquiv_symm_app_app_apply (F G : C ‚•§ D) (f : F ‚ü∂ G)\n    {X : C} {a : (ùüô_ (C ‚•§ Type (max v' v u))).obj X} (Y : C) {œÜ : X ‚ü∂ Y} :\n    ((natTransEquiv.symm f).app X a).app Y œÜ = f.app Y := rfl\n\n"}
{"name":"CategoryTheory.Enriched.Functor.natTransEquiv_symm_whiskerRight_functorHom_app","module":"Mathlib.CategoryTheory.Functor.FunctorHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nK L : CategoryTheory.Functor C D\nX : C\nf : Quiver.Hom K K\nx : CategoryTheory.MonoidalCategoryStruct.tensorObj CategoryTheory.MonoidalCategoryStruct.tensorUnit ((K.functorHom L).obj X)\n‚ä¢ Eq ((CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.natTransEquiv.symm f) (K.functorHom L)).app X x) { fst := CategoryTheory.Functor.HomObj.ofNatTrans f, snd := x.2 }","decl":"@[simp]\nlemma natTransEquiv_symm_whiskerRight_functorHom_app (K L : C ‚•§ D) (X : C) (f : K ‚ü∂ K)\n    (x : ùüô_ _ ‚äó (K.functorHom L).obj X) :\n    ((natTransEquiv.symm f ‚ñ∑ K.functorHom L).app X x) =\n    (HomObj.ofNatTrans f, x.2) := rfl\n\n"}
{"name":"CategoryTheory.Enriched.Functor.functorHom_whiskerLeft_natTransEquiv_symm_app","module":"Mathlib.CategoryTheory.Functor.FunctorHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nK L : CategoryTheory.Functor C D\nX : C\nf : Quiver.Hom L L\nx : CategoryTheory.MonoidalCategoryStruct.tensorObj ((K.functorHom L).obj X) CategoryTheory.MonoidalCategoryStruct.tensorUnit\n‚ä¢ Eq ((CategoryTheory.MonoidalCategoryStruct.whiskerLeft (K.functorHom L) (CategoryTheory.Functor.natTransEquiv.symm f)).app X x) { fst := x.1, snd := CategoryTheory.Functor.HomObj.ofNatTrans f }","decl":"@[simp]\nlemma functorHom_whiskerLeft_natTransEquiv_symm_app (K L : C ‚•§ D) (X : C) (f : L ‚ü∂ L)\n    (x : (K.functorHom L).obj X ‚äó ùüô_ _) :\n    ((K.functorHom L ‚óÅ natTransEquiv.symm f).app X x) =\n    (x.1, HomObj.ofNatTrans f) := rfl\n\n"}
{"name":"CategoryTheory.Enriched.Functor.whiskerLeft_app_apply","module":"Mathlib.CategoryTheory.Functor.FunctorHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nK L M N : CategoryTheory.Functor C D\ng : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (L.functorHom M) (M.functorHom N)) (L.functorHom N)\nX : C\na : (CategoryTheory.MonoidalCategoryStruct.tensorObj (K.functorHom L) (CategoryTheory.MonoidalCategoryStruct.tensorObj (L.functorHom M) (M.functorHom N))).obj X\n‚ä¢ Eq ((CategoryTheory.MonoidalCategoryStruct.whiskerLeft (K.functorHom L) g).app X a) { fst := a.1, snd := g.app X a.2 }","decl":"@[simp]\nlemma whiskerLeft_app_apply (K L M N : C ‚•§ D)\n    (g : L.functorHom M ‚äó M.functorHom N ‚ü∂ L.functorHom N)\n    {X : C} (a : (K.functorHom L ‚äó L.functorHom M ‚äó M.functorHom N).obj X) :\n    (K.functorHom L ‚óÅ g).app X a = ‚ü®a.1, g.app X a.2‚ü© := rfl\n\n"}
{"name":"CategoryTheory.Enriched.Functor.whiskerRight_app_apply","module":"Mathlib.CategoryTheory.Functor.FunctorHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nK L M N : CategoryTheory.Functor C D\nf : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (K.functorHom L) (L.functorHom M)) (K.functorHom M)\nX : C\na : (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj (K.functorHom L) (L.functorHom M)) (M.functorHom N)).obj X\n‚ä¢ Eq ((CategoryTheory.MonoidalCategoryStruct.whiskerRight f (M.functorHom N)).app X a) { fst := f.app X a.1, snd := a.2 }","decl":"@[simp]\nlemma whiskerRight_app_apply (K L M N : C ‚•§ D)\n    (f : K.functorHom L ‚äó L.functorHom M ‚ü∂ K.functorHom M)\n    {X : C} (a : ((K.functorHom L ‚äó L.functorHom M) ‚äó M.functorHom N).obj X) :\n    (f ‚ñ∑  M.functorHom N).app X a = ‚ü®f.app X a.1, a.2‚ü© := rfl\n\n"}
{"name":"CategoryTheory.Enriched.Functor.associator_inv_apply","module":"Mathlib.CategoryTheory.Functor.FunctorHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nK L M N : CategoryTheory.Functor C D\nX : C\nx : (CategoryTheory.MonoidalCategoryStruct.tensorObj (K.functorHom L) (CategoryTheory.MonoidalCategoryStruct.tensorObj (L.functorHom M) (M.functorHom N))).obj X\n‚ä¢ Eq ((CategoryTheory.MonoidalCategoryStruct.associator ((K.functorHom L).obj X) ((L.functorHom M).obj X) ((M.functorHom N).obj X)).inv x) { fst := { fst := x.1, snd := x.2.1 }, snd := x.2.2 }","decl":"@[simp]\nlemma associator_inv_apply (K L M N : C ‚•§ D) {X : C}\n    (x : ((K.functorHom L) ‚äó (L.functorHom M) ‚äó (M.functorHom N)).obj X) :\n    (Œ±_ ((K.functorHom L).obj X) ((L.functorHom M).obj X) ((M.functorHom N).obj X)).inv x =\n    ‚ü®‚ü®x.1, x.2.1‚ü©, x.2.2‚ü© := rfl\n\n"}
{"name":"CategoryTheory.Enriched.Functor.associator_hom_apply","module":"Mathlib.CategoryTheory.Functor.FunctorHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nK L M N : CategoryTheory.Functor C D\nX : C\nx : (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj (K.functorHom L) (L.functorHom M)) (M.functorHom N)).obj X\n‚ä¢ Eq ((CategoryTheory.MonoidalCategoryStruct.associator ((K.functorHom L).obj X) ((L.functorHom M).obj X) ((M.functorHom N).obj X)).hom x) { fst := x.1.1, snd := { fst := x.1.2, snd := x.2 } }","decl":"@[simp]\nlemma associator_hom_apply (K L M N : C ‚•§ D) {X : C}\n    (x : (((K.functorHom L) ‚äó (L.functorHom M)) ‚äó (M.functorHom N)).obj X) :\n    (Œ±_ ((K.functorHom L).obj X) ((L.functorHom M).obj X) ((M.functorHom N).obj X)).hom x =\n    ‚ü®x.1.1, x.1.2, x.2‚ü© := rfl\n\n"}
