{"name":"Nat.roughNumbersUpTo_card_le'","module":"Mathlib.NumberTheory.SumPrimeReciprocals","initialProofState":"N k : Nat\n‚ä¢ LE.le (‚Üë(N.roughNumbersUpTo k).card) (HMul.hMul (‚ÜëN) ((SDiff.sdiff N.succ.primesBelow k.primesBelow).sum fun p => HDiv.hDiv 1 ‚Üëp))","decl":"/-- The cardinality of the set of `k`-rough numbers `‚â§ N` is bounded by `N` times the sum\nof `1/p` over the primes `k ‚â§ p ‚â§ N`. -/\n-- This needs `Mathlib.Analysis.RCLike.Basic`, so we put it here\n-- instead of in `Mathlib.NumberTheory.SmoothNumbers`.\nlemma Nat.roughNumbersUpTo_card_le' (N k : ‚Ñï) :\n    (roughNumbersUpTo N k).card ‚â§\n      N * (N.succ.primesBelow \\ k.primesBelow).sum (fun p ‚Ü¶ (1 : ‚Ñù) / p) := by\n  simp_rw [Finset.mul_sum, mul_one_div]\n  exact (Nat.cast_le.mpr <| roughNumbersUpTo_card_le N k).trans <|\n    (cast_sum (Œ≤ := ‚Ñù) ..) ‚ñ∏ Finset.sum_le_sum fun n _ ‚Ü¶ cast_div_le\n\n"}
{"name":"one_half_le_sum_primes_ge_one_div","module":"Mathlib.NumberTheory.SumPrimeReciprocals","initialProofState":"k : Nat\n‚ä¢ LE.le (1 / 2) ((SDiff.sdiff (HPow.hPow 4 (HAdd.hAdd k.primesBelow.card 1)).succ.primesBelow k.primesBelow).sum fun p => HDiv.hDiv 1 ‚Üëp)","decl":"/-- The sum over primes `k ‚â§ p ‚â§ 4^(œÄ(k-1)+1)` over `1/p` (as a real number) is at least `1/2`. -/\nlemma one_half_le_sum_primes_ge_one_div (k : ‚Ñï) :\n    1 / 2 ‚â§ ‚àë p ‚àà (4 ^ (k.primesBelow.card + 1)).succ.primesBelow \\ k.primesBelow,\n      (1 / p : ‚Ñù) := by\n  set m : ‚Ñï := 2 ^ k.primesBelow.card\n  set N‚ÇÄ : ‚Ñï := 2 * m ^ 2 with hN‚ÇÄ\n  let S : ‚Ñù := ((2 * N‚ÇÄ).succ.primesBelow \\ k.primesBelow).sum (fun p ‚Ü¶ (1 / p : ‚Ñù))\n  suffices 1 / 2 ‚â§ S by\n    convert this using 5\n    rw [show 4 = 2 ^ 2 by norm_num, pow_right_comm]\n    ring\n  suffices 2 * N‚ÇÄ ‚â§ m * (2 * N‚ÇÄ).sqrt + 2 * N‚ÇÄ * S by\n    rwa [hN‚ÇÄ, ‚Üê mul_assoc, ‚Üê pow_two 2, ‚Üê mul_pow, sqrt_eq', ‚Üê sub_le_iff_le_add',\n      cast_mul, cast_mul, cast_pow, cast_two,\n      show (2 * (2 * m ^ 2) - m * (2 * m) : ‚Ñù) = 2 * (2 * m ^ 2) * (1 / 2) by ring,\n      _root_.mul_le_mul_left <| by positivity] at this\n  calc (2 * N‚ÇÄ : ‚Ñù)\n    _ = ((2 * N‚ÇÄ).smoothNumbersUpTo k).card + ((2 * N‚ÇÄ).roughNumbersUpTo k).card := by\n        exact_mod_cast ((2 * N‚ÇÄ).smoothNumbersUpTo_card_add_roughNumbersUpTo_card k).symm\n    _ ‚â§ m * (2 * N‚ÇÄ).sqrt + ((2 * N‚ÇÄ).roughNumbersUpTo k).card := by\n        exact_mod_cast Nat.add_le_add_right ((2 * N‚ÇÄ).smoothNumbersUpTo_card_le k) _\n    _ ‚â§ m * (2 * N‚ÇÄ).sqrt + 2 * N‚ÇÄ * S := add_le_add_left ?_ _\n  exact_mod_cast roughNumbersUpTo_card_le' (2 * N‚ÇÄ) k\n\n"}
{"name":"not_summable_one_div_on_primes","module":"Mathlib.NumberTheory.SumPrimeReciprocals","initialProofState":"‚ä¢ Not (Summable ((setOf fun p => Nat.Prime p).indicator fun n => HDiv.hDiv 1 ‚Üën))","decl":"/-- The sum over the reciprocals of the primes diverges. -/\ntheorem not_summable_one_div_on_primes :\n    ¬¨ Summable (indicator {p | p.Prime} (fun n : ‚Ñï ‚Ü¶ (1 : ‚Ñù) / n)) := by\n  intro h\n  obtain ‚ü®k, hk‚ü© := h.nat_tsum_vanishing (Iio_mem_nhds one_half_pos : Iio (1 / 2 : ‚Ñù) ‚àà ùìù 0)\n  specialize hk ({p | Nat.Prime p} ‚à© {p | k ‚â§ p}) inter_subset_right\n  rw [tsum_subtype, indicator_indicator, inter_eq_left.mpr fun n hn ‚Ü¶ hn.1, mem_Iio] at hk\n  have h' : Summable (indicator ({p | Nat.Prime p} ‚à© {p | k ‚â§ p}) fun n ‚Ü¶ (1 : ‚Ñù) / n) := by\n    convert h.indicator {n : ‚Ñï | k ‚â§ n} using 1\n    simp only [indicator_indicator, inter_comm]\n  refine ((one_half_le_sum_primes_ge_one_div k).trans_lt <| LE.le.trans_lt ?_ hk).false\n  convert sum_le_tsum (primesBelow ((4 ^ (k.primesBelow.card + 1)).succ) \\ primesBelow k)\n    (fun n _ ‚Ü¶ indicator_nonneg (fun p _ ‚Ü¶ by positivity) _) h' using 2 with p hp\n  obtain ‚ü®hp‚ÇÅ, hp‚ÇÇ‚ü© := mem_setOf_eq ‚ñ∏ Finset.mem_sdiff.mp hp\n  have hpp := prime_of_mem_primesBelow hp‚ÇÅ\n  refine (indicator_of_mem (mem_def.mpr ‚ü®hpp, ?_‚ü©) fun n : ‚Ñï ‚Ü¶ (1 / n : ‚Ñù)).symm\n  exact not_lt.mp <| (not_and_or.mp <| (not_congr mem_primesBelow).mp hp‚ÇÇ).neg_resolve_right hpp\n\n"}
{"name":"Nat.Primes.not_summable_one_div","module":"Mathlib.NumberTheory.SumPrimeReciprocals","initialProofState":"‚ä¢ Not (Summable fun p => HDiv.hDiv 1 ‚Üë‚Üëp)","decl":"/-- The sum over the reciprocals of the primes diverges. -/\ntheorem Nat.Primes.not_summable_one_div : ¬¨ Summable (fun p : Nat.Primes ‚Ü¶ (1 / p : ‚Ñù)) := by\n  convert summable_subtype_iff_indicator.mp.mt not_summable_one_div_on_primes\n\n"}
{"name":"Nat.Primes.summable_rpow","module":"Mathlib.NumberTheory.SumPrimeReciprocals","initialProofState":"r : Real\n‚ä¢ Iff (Summable fun p => HPow.hPow (‚Üë‚Üëp) r) (LT.lt r (-1))","decl":"/-- The series over `p^r` for primes `p` converges if and only if `r < -1`. -/\ntheorem Nat.Primes.summable_rpow {r : ‚Ñù} :\n    Summable (fun p : Nat.Primes ‚Ü¶ (p : ‚Ñù) ^ r) ‚Üî r < -1 := by\n  by_cases h : r < -1\n  ¬∑ -- case `r < -1`\n    simp only [h, iff_true]\n    exact (Real.summable_nat_rpow.mpr h).subtype _\n  ¬∑ -- case `-1 ‚â§ r`\n    simp only [h, iff_false]\n    refine fun H ‚Ü¶ Nat.Primes.not_summable_one_div <| H.of_nonneg_of_le (fun _ ‚Ü¶ by positivity) ?_\n    intro p\n    rw [one_div, ‚Üê Real.rpow_neg_one]\n    exact Real.rpow_le_rpow_of_exponent_le (by exact_mod_cast p.prop.one_lt.le) <| not_lt.mp h\n"}
