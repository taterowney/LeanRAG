{"name":"AddCommGrp.isColimit_iff_bijective_desc","module":"Mathlib.Algebra.Category.Grp.LargeColimits","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J AddCommGrp\nc : CategoryTheory.Limits.Cocone F\ninst✝ : DecidableEq J\n⊢ Iff (Nonempty (CategoryTheory.Limits.IsColimit c)) (Function.Bijective ⇑(AddCommGrp.Colimits.Quot.desc F c))","decl":"/--\nIf `c` is a cocone of `F` such that `Quot.desc F c` is bijective, then `c` is a colimit\ncocone of `F`.\n-/\nlemma isColimit_iff_bijective_desc [DecidableEq J] :\n     Nonempty (IsColimit c) ↔ Function.Bijective (Quot.desc F c) := by\n  refine ⟨fun ⟨hc⟩ => ?_, fun h ↦ Nonempty.intro (isColimit_of_bijective_desc F c h)⟩\n  change Function.Bijective (Quot.desc F c).toIntLinearMap\n  rw [← CharacterModule.dual_bijective_iff_bijective]\n  refine ⟨fun χ ψ eq ↦ ?_, fun χ ↦ ?_⟩\n  · apply (AddMonoidHom.postcompEquiv (@AddEquiv.ulift (AddCircle (1 : ℚ)) _).symm _).injective\n    apply ofHom_injective\n    refine hc.hom_ext (fun j ↦ ?_)\n    ext x\n    rw [ConcreteCategory.comp_apply, ConcreteCategory.comp_apply, ← Quot.ι_desc _ c j x]\n    simp only [hom_ofHom, AddMonoidHom.postcompEquiv_apply, AddMonoidHom.comp_apply]\n    exact DFunLike.congr_fun eq (Quot.ι F j x)\n  · set c' : Cocone F :=\n      { pt := AddCommGrp.of (ULift (AddCircle (1 : ℚ)))\n        ι :=\n          { app j := AddCommGrp.ofHom (((@AddEquiv.ulift _ _).symm.toAddMonoidHom.comp χ).comp\n                       (Quot.ι F j))\n            naturality {j j'} u := by\n              ext\n              dsimp\n              rw [Quot.map_ι F (f := u)] } }\n    use AddEquiv.ulift.toAddMonoidHom.comp (hc.desc c').hom\n    refine Quot.addMonoidHom_ext _ (fun j x ↦ ?_)\n    dsimp\n    rw [Quot.ι_desc]\n    change AddEquiv.ulift ((c.ι.app j ≫ hc.desc c') x) = _\n    rw [hc.fac]\n    dsimp [c']\n    rw [AddEquiv.apply_symm_apply]\n\n"}
{"name":"AddCommGrp.hasColimit_iff_small_quot","module":"Mathlib.Algebra.Category.Grp.LargeColimits","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J AddCommGrp\ninst✝ : DecidableEq J\n⊢ Iff (CategoryTheory.Limits.HasColimit F) (Small.{w, max u w} (AddCommGrp.Colimits.Quot F))","decl":"/--\nA functor `F : J ⥤ AddCommGrp.{w}` has a colimit if and only if `Colimits.Quot F` is\n`w`-small.\n-/\nlemma hasColimit_iff_small_quot [DecidableEq J] : HasColimit F ↔ Small.{w} (Quot F) :=\n  ⟨fun _ ↦ Small.mk ⟨_, ⟨(Equiv.ofBijective _ ((isColimit_iff_bijective_desc (colimit.cocone F)).mp\n    ⟨colimit.isColimit _⟩))⟩⟩, hasColimit_of_small_quot F⟩\n\n"}
