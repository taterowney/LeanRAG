{"name":"LightProfinite.instHasPropAndTotallyDisconnectedSpaceŒ±TopologicalSpaceSecondCountableTopology","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TotallyDisconnectedSpace X\ninst‚úù : SecondCountableTopology X\n‚ä¢ CompHausLike.HasProp (fun Y => And (TotallyDisconnectedSpace ‚ÜëY) (SecondCountableTopology ‚ÜëY)) X","decl":"instance (X : Type*) [TopologicalSpace X]\n    [TotallyDisconnectedSpace X] [SecondCountableTopology X] : HasProp (fun Y ‚Ü¶\n      TotallyDisconnectedSpace Y ‚àß SecondCountableTopology Y) X :=\n  ‚ü®‚ü®(inferInstance : TotallyDisconnectedSpace X), (inferInstance : SecondCountableTopology X)‚ü©‚ü©\n\n"}
{"name":"LightProfinite.instTotallyDisconnectedSpaceŒ±TopologicalSpaceToTopAndSecondCountableTopology","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"X : LightProfinite\n‚ä¢ TotallyDisconnectedSpace ‚ÜëX.toTop","decl":"instance {X : LightProfinite} : TotallyDisconnectedSpace X :=\n  X.prop.1\n\n"}
{"name":"LightProfinite.instSecondCountableTopologyŒ±TopologicalSpaceToTopAndTotallyDisconnectedSpace","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"X : LightProfinite\n‚ä¢ SecondCountableTopology ‚ÜëX.toTop","decl":"instance {X : LightProfinite} : SecondCountableTopology X :=\n  X.prop.2\n\n"}
{"name":"LightProfinite.instTotallyDisconnectedSpaceObjForget","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"X : LightProfinite\n‚ä¢ TotallyDisconnectedSpace ((CategoryTheory.forget LightProfinite).obj X)","decl":"instance {X : LightProfinite} : TotallyDisconnectedSpace ((forget LightProfinite).obj X) :=\n  X.prop.1\n\n"}
{"name":"LightProfinite.instSecondCountableTopologyObjForget","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"X : LightProfinite\n‚ä¢ SecondCountableTopology ((CategoryTheory.forget LightProfinite).obj X)","decl":"instance {X : LightProfinite} : SecondCountableTopology ((forget LightProfinite).obj X) :=\n  X.prop.2\n\n"}
{"name":"FintypeCat.toLightProfinite_map_apply","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"X‚úù Y‚úù : FintypeCat\nf : Quiver.Hom X‚úù Y‚úù\na‚úù : ‚ÜëX‚úù\n‚ä¢ Eq ((FintypeCat.toLightProfinite.map f) a‚úù) (f a‚úù)","decl":"/-- The natural functor from `Fintype` to `LightProfinite`, endowing a finite type with the\ndiscrete topology. -/\n@[simps! -isSimp map_apply]\ndef FintypeCat.toLightProfinite : FintypeCat ‚•§ LightProfinite where\n  obj A := LightProfinite.of A\n  map f := ‚ü®f, by continuity‚ü©\n\n"}
{"name":"instFaithfulFintypeCatLightProfiniteToLightProfinite","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"‚ä¢ FintypeCat.toLightProfinite.Faithful","decl":"instance : FintypeCat.toLightProfinite.Faithful :=\n  FintypeCat.toLightProfiniteFullyFaithful.faithful\n\n"}
{"name":"instFullFintypeCatLightProfiniteToLightProfinite","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"‚ä¢ FintypeCat.toLightProfinite.Full","decl":"instance : FintypeCat.toLightProfinite.Full :=\n  FintypeCat.toLightProfiniteFullyFaithful.full\n\n"}
{"name":"LightProfinite.instTotallyDisconnectedSpaceŒ±TopologicalSpaceToTopTruePtCompHausLimitConeCompLightProfiniteToCompHaus","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"J : Type v\ninst‚úù : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J LightProfinite\n‚ä¢ TotallyDisconnectedSpace ‚Üë(CompHaus.limitCone (F.comp lightProfiniteToCompHaus)).pt.toTop","decl":"instance {J : Type v} [SmallCategory J] (F : J ‚•§ LightProfinite.{max u v}) :\n    TotallyDisconnectedSpace\n      (CompHaus.limitCone.{v, u} (F ‚ãô lightProfiniteToCompHaus)).pt.toTop := by\n  change TotallyDisconnectedSpace ({ u : ‚àÄ j : J, F.obj j | _ } : Type _)\n  exact Subtype.totallyDisconnectedSpace\n\n"}
{"name":"LightProfinite.instHasCountableLimits","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"‚ä¢ CategoryTheory.Limits.HasCountableLimits LightProfinite","decl":"instance : HasCountableLimits LightProfinite where\n  out _ := { has_limit := fun F ‚Ü¶ ‚ü®limitCone F, limitConeIsLimit F‚ü© }\n\n"}
{"name":"LightProfinite.instPreservesLimitsOfShapeOppositeNatForget","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"‚ä¢ CategoryTheory.Limits.PreservesLimitsOfShape (Opposite Nat) (CategoryTheory.forget LightProfinite)","decl":"instance : PreservesLimitsOfShape ‚Ñï·µí·µñ (forget LightProfinite.{u}) :=\n  have : PreservesLimitsOfSize.{0, 0} (forget Profinite.{u}) := preservesLimitsOfSize_shrink _\n  inferInstanceAs (PreservesLimitsOfShape ‚Ñï·µí·µñ (lightToProfinite ‚ãô forget Profinite))\n\n"}
{"name":"LightProfinite.isClosedMap","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"X Y : LightProfinite\nf : Quiver.Hom X Y\n‚ä¢ IsClosedMap ‚áëf","decl":"/-- Any morphism of light profinite spaces is a closed map. -/\ntheorem isClosedMap : IsClosedMap f :=\n  CompHausLike.isClosedMap _\n\n"}
{"name":"LightProfinite.isIso_of_bijective","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"X Y : LightProfinite\nf : Quiver.Hom X Y\nbij : Function.Bijective ‚áëf\n‚ä¢ CategoryTheory.IsIso f","decl":"/-- Any continuous bijection of light profinite spaces induces an isomorphism. -/\ntheorem isIso_of_bijective (bij : Function.Bijective f) : IsIso f :=\n  haveI := CompHausLike.isIso_of_bijective (lightProfiniteToCompHaus.map f) bij\n  isIso_of_fully_faithful lightProfiniteToCompHaus _\n\n"}
{"name":"LightProfinite.forget_reflectsIsomorphisms","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"‚ä¢ (CategoryTheory.forget LightProfinite).ReflectsIsomorphisms","decl":"instance forget_reflectsIsomorphisms : (forget LightProfinite).ReflectsIsomorphisms := by\n  constructor\n  intro A B f hf\n  rw [isIso_iff_bijective] at hf\n  exact LightProfinite.isIso_of_bijective _ hf\n\n"}
{"name":"LightProfinite.epi_iff_surjective","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"X Y : LightProfinite\nf : Quiver.Hom X Y\n‚ä¢ Iff (CategoryTheory.Epi f) (Function.Surjective ‚áëf)","decl":"theorem epi_iff_surjective {X Y : LightProfinite.{u}} (f : X ‚ü∂ Y) :\n    Epi f ‚Üî Function.Surjective f := by\n  constructor\n  ¬∑ -- Note: in mathlib3 `contrapose` saw through `Function.Surjective`.\n    dsimp [Function.Surjective]\n    contrapose!\n    rintro ‚ü®y, hy‚ü© hf\n    let C := Set.range f\n    have hC : IsClosed C := (isCompact_range f.continuous).isClosed\n    let U := C·∂ú\n    have hyU : y ‚àà U := by\n      refine Set.mem_compl ?_\n      rintro ‚ü®y', hy'‚ü©\n      exact hy y' hy'\n    have hUy : U ‚àà ùìù y := hC.compl_mem_nhds hyU\n    obtain ‚ü®V, hV, hyV, hVU‚ü© := isTopologicalBasis_isClopen.mem_nhds_iff.mp hUy\n    classical\n      let Z := of (ULift.{u} <| Fin 2)\n      let g : Y ‚ü∂ Z := ‚ü®(LocallyConstant.ofIsClopen hV).map ULift.up, LocallyConstant.continuous _‚ü©\n      let h : Y ‚ü∂ Z := ‚ü®fun _ => ‚ü®1‚ü©, continuous_const‚ü©\n      have H : h = g := by\n        rw [‚Üê cancel_epi f]\n        ext x\n        apply ULift.ext\n        dsimp [g, LocallyConstant.ofIsClopen]\n        -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n        erw [CategoryTheory.comp_apply, ContinuousMap.coe_mk,\n          CategoryTheory.comp_apply, ContinuousMap.coe_mk, Function.comp_apply, if_neg]\n        refine mt (fun Œ± => hVU Œ±) ?_\n        simp only [U, C, Set.mem_range_self, not_true, not_false_iff, Set.mem_compl_iff]\n      apply_fun fun e => (e y).down at H\n      dsimp [g, LocallyConstant.ofIsClopen] at H\n      -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n      erw [ContinuousMap.coe_mk, ContinuousMap.coe_mk, Function.comp_apply, if_pos hyV] at H\n      exact top_ne_bot H\n  ¬∑ rw [‚Üê CategoryTheory.epi_iff_surjective]\n    apply (forget LightProfinite).epi_of_epi_map\n\n"}
{"name":"LightProfinite.instPreservesEpimorphismsProfiniteLightToProfinite","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"‚ä¢ lightToProfinite.PreservesEpimorphisms","decl":"instance : lightToProfinite.PreservesEpimorphisms where\n  preserves f _ := (Profinite.epi_iff_surjective _).mpr ((epi_iff_surjective f).mp inferInstance)\n\n"}
{"name":"LightDiagram.mk.sizeOf_spec","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"diagram : CategoryTheory.Functor (Opposite Nat) FintypeCat\ncone : CategoryTheory.Limits.Cone (diagram.comp FintypeCat.toProfinite)\nisLimit : CategoryTheory.Limits.IsLimit cone\n‚ä¢ Eq (SizeOf.sizeOf { diagram := diagram, cone := cone, isLimit := isLimit }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf diagram)) (SizeOf.sizeOf cone)) (SizeOf.sizeOf isLimit))","decl":"/-- A structure containing the data of sequential limit in `Profinite` of finite sets. -/\nstructure LightDiagram : Type (u+1) where\n  /-- The indexing diagram. -/\n  diagram : ‚Ñï·µí·µñ ‚•§ FintypeCat\n  /-- The limit cone. -/\n  cone : Cone (diagram ‚ãô FintypeCat.toProfinite.{u})\n  /-- The limit cone is limiting. -/\n  isLimit : IsLimit cone\n\n"}
{"name":"LightDiagram.mk.injEq","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"diagram‚úù : CategoryTheory.Functor (Opposite Nat) FintypeCat\ncone‚úù : CategoryTheory.Limits.Cone (diagram‚úù.comp FintypeCat.toProfinite)\nisLimit‚úù : CategoryTheory.Limits.IsLimit cone‚úù\ndiagram : CategoryTheory.Functor (Opposite Nat) FintypeCat\ncone : CategoryTheory.Limits.Cone (diagram.comp FintypeCat.toProfinite)\nisLimit : CategoryTheory.Limits.IsLimit cone\n‚ä¢ Eq (Eq { diagram := diagram‚úù, cone := cone‚úù, isLimit := isLimit‚úù } { diagram := diagram, cone := cone, isLimit := isLimit }) (And (Eq diagram‚úù diagram) (And (HEq cone‚úù cone) (HEq isLimit‚úù isLimit)))","decl":"/-- A structure containing the data of sequential limit in `Profinite` of finite sets. -/\nstructure LightDiagram : Type (u+1) where\n  /-- The indexing diagram. -/\n  diagram : ‚Ñï·µí·µñ ‚•§ FintypeCat\n  /-- The limit cone. -/\n  cone : Cone (diagram ‚ãô FintypeCat.toProfinite.{u})\n  /-- The limit cone is limiting. -/\n  isLimit : IsLimit cone\n\n"}
{"name":"LightDiagram.mk.inj","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"diagram‚úù : CategoryTheory.Functor (Opposite Nat) FintypeCat\ncone‚úù : CategoryTheory.Limits.Cone (diagram‚úù.comp FintypeCat.toProfinite)\nisLimit‚úù : CategoryTheory.Limits.IsLimit cone‚úù\ndiagram : CategoryTheory.Functor (Opposite Nat) FintypeCat\ncone : CategoryTheory.Limits.Cone (diagram.comp FintypeCat.toProfinite)\nisLimit : CategoryTheory.Limits.IsLimit cone\nx‚úù : Eq { diagram := diagram‚úù, cone := cone‚úù, isLimit := isLimit‚úù } { diagram := diagram, cone := cone, isLimit := isLimit }\n‚ä¢ And (Eq diagram‚úù diagram) (And (HEq cone‚úù cone) (HEq isLimit‚úù isLimit))","decl":"/-- A structure containing the data of sequential limit in `Profinite` of finite sets. -/\nstructure LightDiagram : Type (u+1) where\n  /-- The indexing diagram. -/\n  diagram : ‚Ñï·µí·µñ ‚•§ FintypeCat\n  /-- The limit cone. -/\n  cone : Cone (diagram ‚ãô FintypeCat.toProfinite.{u})\n  /-- The limit cone is limiting. -/\n  isLimit : IsLimit cone\n\n"}
{"name":"LightDiagram.instCategory_id_apply","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"X : CategoryTheory.InducedCategory Profinite LightDiagram.toProfinite\na : ‚Üë(LightDiagram.toProfinite X).toTop\n‚ä¢ Eq ((CategoryTheory.CategoryStruct.id X) a) a","decl":"@[simps!]\ninstance : Category LightDiagram := InducedCategory.category toProfinite\n\n"}
{"name":"LightDiagram.instCategory_comp_apply","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"X‚úù Y‚úù Z‚úù : CategoryTheory.InducedCategory Profinite LightDiagram.toProfinite\nf : Quiver.Hom X‚úù Y‚úù\ng : Quiver.Hom Y‚úù Z‚úù\na‚úù : ‚Üë(LightDiagram.toProfinite X‚úù).toTop\n‚ä¢ Eq ((CategoryTheory.CategoryStruct.comp f g) a‚úù) (g (f a‚úù))","decl":"@[simps!]\ninstance : Category LightDiagram := InducedCategory.category toProfinite\n\n"}
{"name":"lightDiagramToProfinite_map","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"X‚úù Y‚úù : CategoryTheory.InducedCategory Profinite LightDiagram.toProfinite\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (lightDiagramToProfinite.map f) f","decl":"/-- The fully faithful embedding `LightDiagram ‚•§ Profinite` -/\n@[simps!]\ndef lightDiagramToProfinite : LightDiagram ‚•§ Profinite := inducedFunctor _\n\n"}
{"name":"lightDiagramToProfinite_obj","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"S : LightDiagram\n‚ä¢ Eq (lightDiagramToProfinite.obj S) S.toProfinite","decl":"/-- The fully faithful embedding `LightDiagram ‚•§ Profinite` -/\n@[simps!]\ndef lightDiagramToProfinite : LightDiagram ‚•§ Profinite := inducedFunctor _\n\n"}
{"name":"instFaithfulLightDiagramProfiniteLightDiagramToProfinite","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"‚ä¢ lightDiagramToProfinite.Faithful","decl":"instance : lightDiagramToProfinite.Faithful := show (inducedFunctor _).Faithful from inferInstance\n\n"}
{"name":"instFullLightDiagramProfiniteLightDiagramToProfinite","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"‚ä¢ lightDiagramToProfinite.Full","decl":"instance : lightDiagramToProfinite.Full := show (inducedFunctor _).Full from inferInstance\n\n"}
{"name":"instTotallyDisconnectedSpaceObjLightDiagramForget","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"X : LightDiagram\n‚ä¢ TotallyDisconnectedSpace ((CategoryTheory.forget LightDiagram).obj X)","decl":"instance {X : LightDiagram} : TotallyDisconnectedSpace ((forget LightDiagram).obj X) :=\n  (inferInstance : TotallyDisconnectedSpace X.cone.pt)\n\n"}
{"name":"instCompactSpaceObjLightDiagramForget","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"X : LightDiagram\n‚ä¢ CompactSpace ((CategoryTheory.forget LightDiagram).obj X)","decl":"instance {X : LightDiagram} : CompactSpace ((forget LightDiagram).obj X) :=\n  (inferInstance : CompactSpace X.cone.pt )\n\n"}
{"name":"instT2SpaceObjLightDiagramForget","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"X : LightDiagram\n‚ä¢ T2Space ((CategoryTheory.forget LightDiagram).obj X)","decl":"instance {X : LightDiagram} : T2Space ((forget LightDiagram).obj X) :=\n  (inferInstance : T2Space X.cone.pt )\n\n"}
{"name":"LightProfinite.instCountableClopensŒ±TopologicalSpaceToTopAndTotallyDisconnectedSpaceSecondCountableTopology","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"S : LightProfinite\n‚ä¢ Countable (TopologicalSpace.Clopens ‚ÜëS.toTop)","decl":"instance (S : LightProfinite) : Countable (Clopens S) := by\n  rw [TopologicalSpace.Clopens.countable_iff_secondCountable]\n  infer_instance\n\n"}
{"name":"LightProfinite.instCountableDiscreteQuotient","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"S : LightProfinite\n‚ä¢ Countable (DiscreteQuotient ‚Üë(lightToProfinite.obj S).toTop)","decl":"instance instCountableDiscreteQuotient (S : LightProfinite)  :\n    Countable (DiscreteQuotient ((lightToProfinite.obj S))) :=\n  (DiscreteQuotient.finsetClopens_inj S).countable\n\n"}
{"name":"lightProfiniteToLightDiagram_obj","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"X : LightProfinite\n‚ä¢ Eq (lightProfiniteToLightDiagram.obj X) X.toLightDiagram","decl":"/-- The functor part of the equivalence `LightProfinite ‚âå LightDiagram` -/\n@[simps]\nnoncomputable def lightProfiniteToLightDiagram : LightProfinite.{u} ‚•§ LightDiagram.{u} where\n  obj X := X.toLightDiagram\n  map f := f\n\n"}
{"name":"lightProfiniteToLightDiagram_map","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"X‚úù Y‚úù : LightProfinite\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (lightProfiniteToLightDiagram.map f) f","decl":"/-- The functor part of the equivalence `LightProfinite ‚âå LightDiagram` -/\n@[simps]\nnoncomputable def lightProfiniteToLightDiagram : LightProfinite.{u} ‚•§ LightDiagram.{u} where\n  obj X := X.toLightDiagram\n  map f := f\n\n"}
{"name":"instSecondCountableTopologyŒ±TopologicalSpaceToTopTotallyDisconnectedSpacePtOppositeNatProfiniteCone","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"S : LightDiagram\n‚ä¢ SecondCountableTopology ‚ÜëS.cone.pt.toTop","decl":"open scoped Classical in\ninstance (S : LightDiagram.{u}) : SecondCountableTopology S.cone.pt := by\n  rw [‚Üê TopologicalSpace.Clopens.countable_iff_secondCountable]\n  refine @Countable.of_equiv _ _ ?_ (LocallyConstant.equivClopens (X := S.cone.pt))\n  refine @Function.Surjective.countable\n    (Œ£ (n : ‚Ñï), LocallyConstant ((S.diagram ‚ãô FintypeCat.toProfinite).obj ‚ü®n‚ü©) (Fin 2)) _ ?_ ?_ ?_\n  ¬∑ apply @instCountableSigma _ _ _ ?_\n    intro n\n    refine @Finite.to_countable _ ?_\n    refine @Finite.of_injective _ ((S.diagram ‚ãô FintypeCat.toProfinite).obj ‚ü®n‚ü© ‚Üí (Fin 2)) ?_ _\n      LocallyConstant.coe_injective\n    refine @Pi.finite _ _ ?_ _\n    simp only [Functor.comp_obj]\n    exact show (Finite (S.diagram.obj _)) from inferInstance\n  ¬∑ exact fun a ‚Ü¶ a.snd.comap (S.cone.œÄ.app ‚ü®a.fst‚ü©)\n  ¬∑ intro a\n    obtain ‚ü®n, g, h‚ü© := Profinite.exists_locallyConstant S.cone S.isLimit a\n    exact ‚ü®‚ü®unop n, g‚ü©, h.symm‚ü©\n\n"}
{"name":"lightDiagramToLightProfinite_obj","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"X : LightDiagram\n‚ä¢ Eq (lightDiagramToLightProfinite.obj X) (LightProfinite.of ‚ÜëX.cone.pt.toTop)","decl":"/-- The inverse part of the equivalence `LightProfinite ‚âå LightDiagram` -/\n@[simps]\ndef lightDiagramToLightProfinite : LightDiagram.{u} ‚•§ LightProfinite.{u} where\n  obj X := LightProfinite.of X.cone.pt\n  map f := f\n\n"}
{"name":"lightDiagramToLightProfinite_map","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"X‚úù Y‚úù : LightDiagram\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (lightDiagramToLightProfinite.map f) f","decl":"/-- The inverse part of the equivalence `LightProfinite ‚âå LightDiagram` -/\n@[simps]\ndef lightDiagramToLightProfinite : LightDiagram.{u} ‚•§ LightProfinite.{u} where\n  obj X := LightProfinite.of X.cone.pt\n  map f := f\n\n"}
{"name":"instIsEquivalenceLightProfiniteLightDiagramLightProfiniteToLightDiagram","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"‚ä¢ lightProfiniteToLightDiagram.IsEquivalence","decl":"instance : lightProfiniteToLightDiagram.IsEquivalence :=\n  show LightProfinite.equivDiagram.functor.IsEquivalence from inferInstance\n\n"}
{"name":"instIsEquivalenceLightDiagramLightProfiniteLightDiagramToLightProfinite","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"‚ä¢ lightDiagramToLightProfinite.IsEquivalence","decl":"instance : lightDiagramToLightProfinite.IsEquivalence :=\n  show LightProfinite.equivDiagram.inverse.IsEquivalence from inferInstance\n\n"}
{"name":"LightDiagram'.mk.inj","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"diagram‚úù diagram : CategoryTheory.Functor (Opposite Nat) FintypeCat.Skeleton\nx‚úù : Eq { diagram := diagram‚úù } { diagram := diagram }\n‚ä¢ Eq diagram‚úù diagram","decl":"/--\nThis is an auxiliary definition used to show that `LightDiagram` is essentially small.\n\nNote that below we put a category instance on this structure which is completely different from the\ncategory instance on `‚Ñï·µí·µñ ‚•§ FintypeCat.Skeleton.{u}`. Neither the morphisms nor the objects are the\nsame.\n-/\nstructure LightDiagram' : Type u where\n  /-- The diagram takes values in a small category equivalent to `FintypeCat`. -/\n  diagram : ‚Ñï·µí·µñ ‚•§ FintypeCat.Skeleton.{u}\n\n"}
{"name":"LightDiagram'.mk.sizeOf_spec","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"diagram : CategoryTheory.Functor (Opposite Nat) FintypeCat.Skeleton\n‚ä¢ Eq (SizeOf.sizeOf { diagram := diagram }) (HAdd.hAdd 1 (SizeOf.sizeOf diagram))","decl":"/--\nThis is an auxiliary definition used to show that `LightDiagram` is essentially small.\n\nNote that below we put a category instance on this structure which is completely different from the\ncategory instance on `‚Ñï·µí·µñ ‚•§ FintypeCat.Skeleton.{u}`. Neither the morphisms nor the objects are the\nsame.\n-/\nstructure LightDiagram' : Type u where\n  /-- The diagram takes values in a small category equivalent to `FintypeCat`. -/\n  diagram : ‚Ñï·µí·µñ ‚•§ FintypeCat.Skeleton.{u}\n\n"}
{"name":"LightDiagram'.mk.injEq","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"diagram‚úù diagram : CategoryTheory.Functor (Opposite Nat) FintypeCat.Skeleton\n‚ä¢ Eq (Eq { diagram := diagram‚úù } { diagram := diagram }) (Eq diagram‚úù diagram)","decl":"/--\nThis is an auxiliary definition used to show that `LightDiagram` is essentially small.\n\nNote that below we put a category instance on this structure which is completely different from the\ncategory instance on `‚Ñï·µí·µñ ‚•§ FintypeCat.Skeleton.{u}`. Neither the morphisms nor the objects are the\nsame.\n-/\nstructure LightDiagram' : Type u where\n  /-- The diagram takes values in a small category equivalent to `FintypeCat`. -/\n  diagram : ‚Ñï·µí·µñ ‚•§ FintypeCat.Skeleton.{u}\n\n"}
{"name":"instFaithfulLightDiagram'LightDiagramToLightFunctor","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"‚ä¢ LightDiagram'.toLightFunctor.Faithful","decl":"instance : LightDiagram'.toLightFunctor.{u}.Faithful := ‚ü®id‚ü©\n\n"}
{"name":"instFullLightDiagram'LightDiagramToLightFunctor","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"‚ä¢ LightDiagram'.toLightFunctor.Full","decl":"instance : LightDiagram'.toLightFunctor.{u}.Full where\n  map_surjective f := ‚ü®f, rfl‚ü©\n\n"}
{"name":"instEssSurjLightDiagram'LightDiagramToLightFunctor","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"‚ä¢ LightDiagram'.toLightFunctor.EssSurj","decl":"instance : LightDiagram'.toLightFunctor.{u}.EssSurj where\n  mem_essImage Y :=\n    ‚ü®‚ü®Y.diagram ‚ãô Skeleton.equivalence.inverse‚ü©, ‚ü®lightDiagramToProfinite.preimageIso (\n      (Limits.lim.mapIso (isoWhiskerRight ((isoWhiskerLeft Y.diagram\n      Skeleton.equivalence.counitIso)) toProfinite)) ‚â™‚â´\n      (limit.isLimit _).conePointUniqueUpToIso Y.isLimit)‚ü©‚ü©\n\n"}
{"name":"instIsEquivalenceLightDiagram'LightDiagramToLightFunctor","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"‚ä¢ LightDiagram'.toLightFunctor.IsEquivalence","decl":"instance : LightDiagram'.toLightFunctor.IsEquivalence where\n\n"}
{"name":"instEssentiallySmallLightDiagram","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"‚ä¢ CategoryTheory.EssentiallySmall.{u, u, u + 1} LightDiagram","decl":"instance : EssentiallySmall.{u} LightDiagram.{u} where\n  equiv_smallCategory := ‚ü®LightDiagram', inferInstance, ‚ü®LightDiagram.equivSmall‚ü©‚ü©\n\n"}
{"name":"instEssentiallySmallLightProfinite","module":"Mathlib.Topology.Category.LightProfinite.Basic","initialProofState":"‚ä¢ CategoryTheory.EssentiallySmall.{u, u, u + 1} LightProfinite","decl":"instance : EssentiallySmall.{u} LightProfinite.{u} where\n  equiv_smallCategory := ‚ü®LightDiagram', inferInstance,\n    ‚ü®LightProfinite.equivDiagram.trans LightDiagram.equivSmall‚ü©‚ü©\n\n"}
