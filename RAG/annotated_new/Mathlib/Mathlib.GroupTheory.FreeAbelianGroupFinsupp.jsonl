{"name":"Finsupp.toFreeAbelianGroup_comp_singleAddHom","module":"Mathlib.GroupTheory.FreeAbelianGroupFinsupp","initialProofState":"X : Type u_1\nx : X\n⊢ Eq (Finsupp.toFreeAbelianGroup.comp (Finsupp.singleAddHom x)) ((smulAddHom Int (FreeAbelianGroup X)).flip (FreeAbelianGroup.of x))","decl":"@[simp]\ntheorem Finsupp.toFreeAbelianGroup_comp_singleAddHom (x : X) :\n    Finsupp.toFreeAbelianGroup.comp (Finsupp.singleAddHom x) =\n      (smulAddHom ℤ (FreeAbelianGroup X)).flip (of x) := by\n  ext\n  simp only [AddMonoidHom.coe_comp, Finsupp.singleAddHom_apply, Function.comp_apply, one_smul,\n    toFreeAbelianGroup, Finsupp.liftAddHom_apply_single]\n\n"}
{"name":"FreeAbelianGroup.toFinsupp_comp_toFreeAbelianGroup","module":"Mathlib.GroupTheory.FreeAbelianGroupFinsupp","initialProofState":"X : Type u_1\n⊢ Eq (FreeAbelianGroup.toFinsupp.comp Finsupp.toFreeAbelianGroup) (AddMonoidHom.id (Finsupp X Int))","decl":"@[simp]\ntheorem FreeAbelianGroup.toFinsupp_comp_toFreeAbelianGroup :\n    toFinsupp.comp toFreeAbelianGroup = AddMonoidHom.id (X →₀ ℤ) := by\n  ext x y; simp only [AddMonoidHom.id_comp]\n  rw [AddMonoidHom.comp_assoc, Finsupp.toFreeAbelianGroup_comp_singleAddHom]\n  simp only [toFinsupp, AddMonoidHom.coe_comp, Finsupp.singleAddHom_apply, Function.comp_apply,\n    one_smul, lift.of, AddMonoidHom.flip_apply, smulAddHom_apply, AddMonoidHom.id_apply]\n\n"}
{"name":"Finsupp.toFreeAbelianGroup_comp_toFinsupp","module":"Mathlib.GroupTheory.FreeAbelianGroupFinsupp","initialProofState":"X : Type u_1\n⊢ Eq (Finsupp.toFreeAbelianGroup.comp FreeAbelianGroup.toFinsupp) (AddMonoidHom.id (FreeAbelianGroup X))","decl":"@[simp]\ntheorem Finsupp.toFreeAbelianGroup_comp_toFinsupp :\n    toFreeAbelianGroup.comp toFinsupp = AddMonoidHom.id (FreeAbelianGroup X) := by\n  ext\n  rw [toFreeAbelianGroup, toFinsupp, AddMonoidHom.comp_apply, lift.of,\n    liftAddHom_apply_single, AddMonoidHom.flip_apply, smulAddHom_apply, one_smul,\n    AddMonoidHom.id_apply]\n\n"}
{"name":"Finsupp.toFreeAbelianGroup_toFinsupp","module":"Mathlib.GroupTheory.FreeAbelianGroupFinsupp","initialProofState":"X : Type u_2\nx : FreeAbelianGroup X\n⊢ Eq (Finsupp.toFreeAbelianGroup (FreeAbelianGroup.toFinsupp x)) x","decl":"@[simp]\ntheorem Finsupp.toFreeAbelianGroup_toFinsupp {X} (x : FreeAbelianGroup X) :\n    Finsupp.toFreeAbelianGroup (FreeAbelianGroup.toFinsupp x) = x := by\n  rw [← AddMonoidHom.comp_apply, Finsupp.toFreeAbelianGroup_comp_toFinsupp, AddMonoidHom.id_apply]\n\n"}
{"name":"FreeAbelianGroup.toFinsupp_of","module":"Mathlib.GroupTheory.FreeAbelianGroupFinsupp","initialProofState":"X : Type u_1\nx : X\n⊢ Eq (FreeAbelianGroup.toFinsupp (FreeAbelianGroup.of x)) (Finsupp.single x 1)","decl":"@[simp]\ntheorem toFinsupp_of (x : X) : toFinsupp (of x) = Finsupp.single x 1 := by\n  simp only [toFinsupp, lift.of]\n\n"}
{"name":"FreeAbelianGroup.toFinsupp_toFreeAbelianGroup","module":"Mathlib.GroupTheory.FreeAbelianGroupFinsupp","initialProofState":"X : Type u_1\nf : Finsupp X Int\n⊢ Eq (FreeAbelianGroup.toFinsupp (Finsupp.toFreeAbelianGroup f)) f","decl":"@[simp]\ntheorem toFinsupp_toFreeAbelianGroup (f : X →₀ ℤ) :\n    FreeAbelianGroup.toFinsupp (Finsupp.toFreeAbelianGroup f) = f := by\n  rw [← AddMonoidHom.comp_apply, toFinsupp_comp_toFreeAbelianGroup, AddMonoidHom.id_apply]\n\n"}
{"name":"FreeAbelianGroup.equivFinsupp_apply","module":"Mathlib.GroupTheory.FreeAbelianGroupFinsupp","initialProofState":"X : Type u_1\na : FreeAbelianGroup X\n⊢ Eq ((FreeAbelianGroup.equivFinsupp X) a) (FreeAbelianGroup.toFinsupp a)","decl":"/-- The additive equivalence between `FreeAbelianGroup X` and `(X →₀ ℤ)`. -/\n@[simps!]\ndef equivFinsupp : FreeAbelianGroup X ≃+ (X →₀ ℤ) where\n  toFun := toFinsupp\n  invFun := toFreeAbelianGroup\n  left_inv := toFreeAbelianGroup_toFinsupp\n  right_inv := toFinsupp_toFreeAbelianGroup\n  map_add' := toFinsupp.map_add\n\n"}
{"name":"FreeAbelianGroup.equivFinsupp_symm_apply","module":"Mathlib.GroupTheory.FreeAbelianGroupFinsupp","initialProofState":"X : Type u_1\na : Finsupp X Int\n⊢ Eq ((FreeAbelianGroup.equivFinsupp X).symm a) (Finsupp.toFreeAbelianGroup a)","decl":"/-- The additive equivalence between `FreeAbelianGroup X` and `(X →₀ ℤ)`. -/\n@[simps!]\ndef equivFinsupp : FreeAbelianGroup X ≃+ (X →₀ ℤ) where\n  toFun := toFinsupp\n  invFun := toFreeAbelianGroup\n  left_inv := toFreeAbelianGroup_toFinsupp\n  right_inv := toFinsupp_toFreeAbelianGroup\n  map_add' := toFinsupp.map_add\n\n"}
{"name":"FreeAbelianGroup.mem_support_iff","module":"Mathlib.GroupTheory.FreeAbelianGroupFinsupp","initialProofState":"X : Type u_1\nx : X\na : FreeAbelianGroup X\n⊢ Iff (Membership.mem a.support x) (Ne ((FreeAbelianGroup.coeff x) a) 0)","decl":"theorem mem_support_iff (x : X) (a : FreeAbelianGroup X) : x ∈ a.support ↔ coeff x a ≠ 0 := by\n  rw [support, Finsupp.mem_support_iff]\n  exact Iff.rfl\n\n"}
{"name":"FreeAbelianGroup.not_mem_support_iff","module":"Mathlib.GroupTheory.FreeAbelianGroupFinsupp","initialProofState":"X : Type u_1\nx : X\na : FreeAbelianGroup X\n⊢ Iff (Not (Membership.mem a.support x)) (Eq ((FreeAbelianGroup.coeff x) a) 0)","decl":"theorem not_mem_support_iff (x : X) (a : FreeAbelianGroup X) : x ∉ a.support ↔ coeff x a = 0 := by\n  rw [support, Finsupp.not_mem_support_iff]\n  exact Iff.rfl\n\n"}
{"name":"FreeAbelianGroup.support_zero","module":"Mathlib.GroupTheory.FreeAbelianGroupFinsupp","initialProofState":"X : Type u_1\n⊢ Eq (FreeAbelianGroup.support 0) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem support_zero : support (0 : FreeAbelianGroup X) = ∅ := by\n  simp only [support, Finsupp.support_zero, AddMonoidHom.map_zero]\n\n"}
{"name":"FreeAbelianGroup.support_of","module":"Mathlib.GroupTheory.FreeAbelianGroupFinsupp","initialProofState":"X : Type u_1\nx : X\n⊢ Eq (FreeAbelianGroup.of x).support (Singleton.singleton x)","decl":"@[simp]\ntheorem support_of (x : X) : support (of x) = {x} := by\n  rw [support, toFinsupp_of, Finsupp.support_single_ne_zero _ one_ne_zero]\n\n"}
{"name":"FreeAbelianGroup.support_neg","module":"Mathlib.GroupTheory.FreeAbelianGroupFinsupp","initialProofState":"X : Type u_1\na : FreeAbelianGroup X\n⊢ Eq (Neg.neg a).support a.support","decl":"@[simp]\ntheorem support_neg (a : FreeAbelianGroup X) : support (-a) = support a := by\n  simp only [support, AddMonoidHom.map_neg, Finsupp.support_neg]\n\n"}
{"name":"FreeAbelianGroup.support_zsmul","module":"Mathlib.GroupTheory.FreeAbelianGroupFinsupp","initialProofState":"X : Type u_1\nk : Int\nh : Ne k 0\na : FreeAbelianGroup X\n⊢ Eq (HSMul.hSMul k a).support a.support","decl":"@[simp]\ntheorem support_zsmul (k : ℤ) (h : k ≠ 0) (a : FreeAbelianGroup X) :\n    support (k • a) = support a := by\n  ext x\n  simp only [mem_support_iff, AddMonoidHom.map_zsmul]\n  simp only [h, zsmul_int_int, false_or, Ne, mul_eq_zero]\n\n"}
{"name":"FreeAbelianGroup.support_nsmul","module":"Mathlib.GroupTheory.FreeAbelianGroupFinsupp","initialProofState":"X : Type u_1\nk : Nat\nh : Ne k 0\na : FreeAbelianGroup X\n⊢ Eq (HSMul.hSMul k a).support a.support","decl":"@[simp]\ntheorem support_nsmul (k : ℕ) (h : k ≠ 0) (a : FreeAbelianGroup X) :\n    support (k • a) = support a := by\n  apply support_zsmul k _ a\n  exact mod_cast h\n\n"}
{"name":"FreeAbelianGroup.support_add","module":"Mathlib.GroupTheory.FreeAbelianGroupFinsupp","initialProofState":"X : Type u_1\na b : FreeAbelianGroup X\n⊢ HasSubset.Subset (HAdd.hAdd a b).support (Union.union a.support b.support)","decl":"open scoped Classical in\ntheorem support_add (a b : FreeAbelianGroup X) : support (a + b) ⊆ a.support ∪ b.support := by\n  simp only [support, AddMonoidHom.map_add]\n  apply Finsupp.support_add\n\n"}
