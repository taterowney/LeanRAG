{"name":"Perfect.small_diam_splitting","module":"Mathlib.Topology.MetricSpace.Perfect","initialProofState":"α : Type u_1\ninst✝ : MetricSpace α\nC : Set α\nε : ENNReal\nhC : Perfect C\nhnonempty : C.Nonempty\nε_pos : LT.lt 0 ε\n⊢ Exists fun C₀ => Exists fun C₁ => And (And (Perfect C₀) (And C₀.Nonempty (And (HasSubset.Subset C₀ C) (LE.le (EMetric.diam C₀) ε)))) (And (And (Perfect C₁) (And C₁.Nonempty (And (HasSubset.Subset C₁ C) (LE.le (EMetric.diam C₁) ε)))) (Disjoint C₀ C₁))","decl":"/-- A refinement of `Perfect.splitting` for metric spaces, where we also control\nthe diameter of the new perfect sets. -/\ntheorem Perfect.small_diam_splitting (hC : Perfect C) (hnonempty : C.Nonempty) (ε_pos : 0 < ε) :\n    ∃ C₀ C₁ : Set α, (Perfect C₀ ∧ C₀.Nonempty ∧ C₀ ⊆ C ∧ EMetric.diam C₀ ≤ ε) ∧\n    (Perfect C₁ ∧ C₁.Nonempty ∧ C₁ ⊆ C ∧ EMetric.diam C₁ ≤ ε) ∧ Disjoint C₀ C₁ := by\n  rcases hC.splitting hnonempty with ⟨D₀, D₁, ⟨perf0, non0, sub0⟩, ⟨perf1, non1, sub1⟩, hdisj⟩\n  cases' non0 with x₀ hx₀\n  cases' non1 with x₁ hx₁\n  rcases perf0.small_diam_aux ε_pos hx₀ with ⟨perf0', non0', sub0', diam0⟩\n  rcases perf1.small_diam_aux ε_pos hx₁ with ⟨perf1', non1', sub1', diam1⟩\n  refine\n    ⟨closure (EMetric.ball x₀ (ε / 2) ∩ D₀), closure (EMetric.ball x₁ (ε / 2) ∩ D₁),\n      ⟨perf0', non0', sub0'.trans sub0, diam0⟩, ⟨perf1', non1', sub1'.trans sub1, diam1⟩, ?_⟩\n  apply Disjoint.mono _ _ hdisj <;> assumption\n\n"}
{"name":"Perfect.exists_nat_bool_injection","module":"Mathlib.Topology.MetricSpace.Perfect","initialProofState":"α : Type u_1\ninst✝¹ : MetricSpace α\nC : Set α\nhC : Perfect C\nhnonempty : C.Nonempty\ninst✝ : CompleteSpace α\n⊢ Exists fun f => And (HasSubset.Subset (Set.range f) C) (And (Continuous f) (Function.Injective f))","decl":"/-- Any nonempty perfect set in a complete metric space admits a continuous injection\nfrom the Cantor space, `ℕ → Bool`. -/\ntheorem Perfect.exists_nat_bool_injection\n    (hC : Perfect C) (hnonempty : C.Nonempty) [CompleteSpace α] :\n    ∃ f : (ℕ → Bool) → α, range f ⊆ C ∧ Continuous f ∧ Injective f := by\n  obtain ⟨u, -, upos', hu⟩ := exists_seq_strictAnti_tendsto' (zero_lt_one' ℝ≥0∞)\n  have upos := fun n => (upos' n).1\n  let P := Subtype fun E : Set α => Perfect E ∧ E.Nonempty\n  choose C0 C1 h0 h1 hdisj using\n    fun {C : Set α} (hC : Perfect C) (hnonempty : C.Nonempty) {ε : ℝ≥0∞} (hε : 0 < ε) =>\n    hC.small_diam_splitting hnonempty hε\n  let DP : List Bool → P := fun l => by\n    induction' l with a l ih; · exact ⟨C, ⟨hC, hnonempty⟩⟩\n    cases a\n    · use C0 ih.property.1 ih.property.2 (upos (l.length + 1))\n      exact ⟨(h0 _ _ _).1, (h0 _ _ _).2.1⟩\n    use C1 ih.property.1 ih.property.2 (upos (l.length + 1))\n    exact ⟨(h1 _ _ _).1, (h1 _ _ _).2.1⟩\n  let D : List Bool → Set α := fun l => (DP l).val\n  have hanti : ClosureAntitone D := by\n    refine Antitone.closureAntitone ?_ fun l => (DP l).property.1.closed\n    intro l a\n    cases a\n    · exact (h0 _ _ _).2.2.1\n    exact (h1 _ _ _).2.2.1\n  have hdiam : VanishingDiam D := by\n    intro x\n    apply tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_const_nhds hu\n    · simp\n    rw [eventually_atTop]\n    refine ⟨1, fun m (hm : 1 ≤ m) => ?_⟩\n    rw [Nat.one_le_iff_ne_zero] at hm\n    rcases Nat.exists_eq_succ_of_ne_zero hm with ⟨n, rfl⟩\n    dsimp\n    cases x n\n    · convert (h0 _ _ _).2.2.2\n      rw [PiNat.res_length]\n    convert (h1 _ _ _).2.2.2\n    rw [PiNat.res_length]\n  have hdisj' : CantorScheme.Disjoint D := by\n    rintro l (a | a) (b | b) hab <;> try contradiction\n    · exact hdisj _ _ _\n    exact (hdisj _ _ _).symm\n  have hdom : ∀ {x : ℕ → Bool}, x ∈ (inducedMap D).1 := fun {x} => by\n    rw [hanti.map_of_vanishingDiam hdiam fun l => (DP l).property.2]\n    apply mem_univ\n  refine ⟨fun x => (inducedMap D).2 ⟨x, hdom⟩, ?_, ?_, ?_⟩\n  · rintro y ⟨x, rfl⟩\n    exact map_mem ⟨_, hdom⟩ 0\n  · apply hdiam.map_continuous.comp\n    continuity\n  intro x y hxy\n  simpa only [← Subtype.val_inj] using hdisj'.map_injective hxy\n\n"}
{"name":"IsClosed.exists_nat_bool_injection_of_not_countable","module":"Mathlib.Topology.MetricSpace.Perfect","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : PolishSpace α\nC : Set α\nhC : IsClosed C\nhunc : Not C.Countable\n⊢ Exists fun f => And (HasSubset.Subset (Set.range f) C) (And (Continuous f) (Function.Injective f))","decl":"/-- Any closed uncountable subset of a Polish space admits a continuous injection\nfrom the Cantor space `ℕ → Bool`. -/\ntheorem IsClosed.exists_nat_bool_injection_of_not_countable {α : Type*} [TopologicalSpace α]\n    [PolishSpace α] {C : Set α} (hC : IsClosed C) (hunc : ¬C.Countable) :\n    ∃ f : (ℕ → Bool) → α, range f ⊆ C ∧ Continuous f ∧ Function.Injective f := by\n  letI := upgradePolishSpace α\n  obtain ⟨D, hD, Dnonempty, hDC⟩ := exists_perfect_nonempty_of_isClosed_of_not_countable hC hunc\n  obtain ⟨f, hfD, hf⟩ := hD.exists_nat_bool_injection Dnonempty\n  exact ⟨f, hfD.trans hDC, hf⟩\n"}
