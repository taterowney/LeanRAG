{"name":"Filter.eventually_curry_iff","module":"Mathlib.Order.Filter.Curry","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nm : Filter β\np : Prod α β → Prop\n⊢ Iff (Filter.Eventually (fun x => p x) (l.curry m)) (Filter.Eventually (fun x => Filter.Eventually (fun y => p { fst := x, snd := y }) m) l)","decl":"theorem eventually_curry_iff {p : α × β → Prop} :\n    (∀ᶠ x : α × β in l.curry m, p x) ↔ ∀ᶠ x : α in l, ∀ᶠ y : β in m, p (x, y) :=\n  Iff.rfl\n\n"}
{"name":"Filter.frequently_curry_iff","module":"Mathlib.Order.Filter.Curry","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nm : Filter β\np : Prod α β → Prop\n⊢ Iff (Filter.Frequently (fun x => p x) (l.curry m)) (Filter.Frequently (fun x => Filter.Frequently (fun y => p { fst := x, snd := y }) m) l)","decl":"theorem frequently_curry_iff\n    (p : (α × β) → Prop) : (∃ᶠ x in l.curry m, p x) ↔ ∃ᶠ x in l, ∃ᶠ y in m, p (x, y) := by\n  simp_rw [Filter.Frequently, not_iff_not, not_not, eventually_curry_iff]\n\n"}
{"name":"Filter.mem_curry_iff","module":"Mathlib.Order.Filter.Curry","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nm : Filter β\ns : Set (Prod α β)\n⊢ Iff (Membership.mem (l.curry m) s) (Filter.Eventually (fun x => Filter.Eventually (fun y => Membership.mem s { fst := x, snd := y }) m) l)","decl":"theorem mem_curry_iff {s : Set (α × β)} :\n    s ∈ l.curry m ↔ ∀ᶠ x : α in l, ∀ᶠ y : β in m, (x, y) ∈ s := Iff.rfl\n\n"}
{"name":"Filter.curry_le_prod","module":"Mathlib.Order.Filter.Curry","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nm : Filter β\n⊢ LE.le (l.curry m) (SProd.sprod l m)","decl":"theorem curry_le_prod : l.curry m ≤ l ×ˢ m := fun _ => Eventually.curry\n\n"}
{"name":"Filter.Tendsto.curry","module":"Mathlib.Order.Filter.Curry","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\nla : Filter α\nlb : Filter β\nlc : Filter γ\nh : Filter.Eventually (fun a => Filter.Tendsto (fun b => f a b) lb lc) la\n⊢ Filter.Tendsto (Function.HasUncurry.uncurry f) (la.curry lb) lc","decl":"theorem Tendsto.curry {f : α → β → γ} {la : Filter α} {lb : Filter β} {lc : Filter γ}\n    (h : ∀ᶠ a in la, Tendsto (fun b : β => f a b) lb lc) : Tendsto (↿f) (la.curry lb) lc :=\n  fun _s hs => h.mono fun _a ha => ha hs\n\n"}
{"name":"Filter.frequently_curry_prod_iff","module":"Mathlib.Order.Filter.Curry","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nm : Filter β\ns : Set α\nt : Set β\n⊢ Iff (Filter.Frequently (fun x => Membership.mem (SProd.sprod s t) x) (l.curry m)) (And (Filter.Frequently (fun x => Membership.mem s x) l) (Filter.Frequently (fun y => Membership.mem t y) m))","decl":"theorem frequently_curry_prod_iff :\n    (∃ᶠ x in l.curry m, x ∈ s ×ˢ t) ↔ (∃ᶠ x in l, x ∈ s) ∧ ∃ᶠ y in m, y ∈ t := by\n  simp [frequently_curry_iff]\n\n"}
{"name":"Filter.eventually_curry_prod_iff","module":"Mathlib.Order.Filter.Curry","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nm : Filter β\ns : Set α\nt : Set β\ninst✝¹ : l.NeBot\ninst✝ : m.NeBot\n⊢ Iff (Filter.Eventually (fun x => Membership.mem (SProd.sprod s t) x) (l.curry m)) (And (Membership.mem l s) (Membership.mem m t))","decl":"theorem eventually_curry_prod_iff [NeBot l] [NeBot m] :\n    (∀ᶠ x in l.curry m, x ∈ s ×ˢ t) ↔ s ∈ l ∧ t ∈ m := by\n  simp [eventually_curry_iff]\n\n"}
{"name":"Filter.prod_mem_curry","module":"Mathlib.Order.Filter.Curry","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nm : Filter β\ns : Set α\nt : Set β\nhs : Membership.mem l s\nht : Membership.mem m t\n⊢ Membership.mem (l.curry m) (SProd.sprod s t)","decl":"theorem prod_mem_curry (hs : s ∈ l) (ht : t ∈ m) : s ×ˢ t ∈ l.curry m :=\n  curry_le_prod <| prod_mem_prod hs ht\n\n"}
