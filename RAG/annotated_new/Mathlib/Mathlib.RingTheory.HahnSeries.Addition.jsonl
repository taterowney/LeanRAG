{"name":"HahnSeries.coeff_add'","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddMonoid R\nx y : HahnSeries Γ R\n⊢ Eq (HAdd.hAdd x y).coeff (HAdd.hAdd x.coeff y.coeff)","decl":"@[simp]\ntheorem coeff_add' {x y : HahnSeries Γ R} : (x + y).coeff = x.coeff + y.coeff :=\n  rfl\n\n"}
{"name":"HahnSeries.add_coeff'","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddMonoid R\nx y : HahnSeries Γ R\n⊢ Eq (HAdd.hAdd x y).coeff (HAdd.hAdd x.coeff y.coeff)","decl":"@[deprecated (since := \"2025-01-31\")] alias add_coeff' := coeff_add'\n\n"}
{"name":"HahnSeries.coeff_add","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddMonoid R\nx y : HahnSeries Γ R\na : Γ\n⊢ Eq ((HAdd.hAdd x y).coeff a) (HAdd.hAdd (x.coeff a) (y.coeff a))","decl":"theorem coeff_add {x y : HahnSeries Γ R} {a : Γ} : (x + y).coeff a = x.coeff a + y.coeff a :=\n  rfl\n\n"}
{"name":"HahnSeries.add_coeff","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddMonoid R\nx y : HahnSeries Γ R\na : Γ\n⊢ Eq ((HAdd.hAdd x y).coeff a) (HAdd.hAdd (x.coeff a) (y.coeff a))","decl":"@[deprecated (since := \"2025-01-31\")] alias add_coeff := coeff_add\n\n"}
{"name":"HahnSeries.coeff_nsmul","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddMonoid R\nx : HahnSeries Γ R\nn : Nat\n⊢ Eq (HSMul.hSMul n x).coeff (HSMul.hSMul n x.coeff)","decl":"@[simp]\ntheorem coeff_nsmul {x : HahnSeries Γ R} {n : ℕ} : (n • x).coeff = n • x.coeff := by\n  induction n with\n  | zero => simp\n  | succ n ih => simp [add_nsmul, ih]\n\n"}
{"name":"HahnSeries.nsmul_coeff","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddMonoid R\nx : HahnSeries Γ R\nn : Nat\n⊢ Eq (HSMul.hSMul n x).coeff (HSMul.hSMul n x.coeff)","decl":"@[deprecated (since := \"2025-01-31\")] alias nsmul_coeff := coeff_nsmul\n\n"}
{"name":"HahnSeries.map_add","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\nS : Type u_4\ninst✝² : PartialOrder Γ\ninst✝¹ : AddMonoid R\ninst✝ : AddMonoid S\nf : AddMonoidHom R S\nx y : HahnSeries Γ R\n⊢ Eq ((HAdd.hAdd x y).map f) (HAdd.hAdd (x.map f) (y.map f))","decl":"@[simp]\nprotected lemma map_add [AddMonoid S] (f : R →+ S) {x y : HahnSeries Γ R} :\n    ((x + y).map f : HahnSeries Γ S) = x.map f + y.map f := by\n  ext; simp\n"}
{"name":"HahnSeries.addOppositeEquiv_apply","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddMonoid R\nx : HahnSeries Γ (AddOpposite R)\n⊢ Eq (HahnSeries.addOppositeEquiv x) (AddOpposite.op { coeff := fun a => AddOpposite.unop (x.coeff a), isPWO_support' := ⋯ })","decl":"/--\n`addOppositeEquiv` is an additive monoid isomorphism between\nHahn series over `Γ` with coefficients in the opposite additive monoid `Rᵃᵒᵖ`\nand the additive opposite of Hahn series over `Γ` with coefficients `R`.\n-/\n@[simps (config := .lemmasOnly)]\ndef addOppositeEquiv : HahnSeries Γ (Rᵃᵒᵖ) ≃+ (HahnSeries Γ R)ᵃᵒᵖ where\n  toFun x := .op ⟨fun a ↦ (x.coeff a).unop, by convert x.isPWO_support; ext; simp⟩\n  invFun x := ⟨fun a ↦ .op (x.unop.coeff a), by convert x.unop.isPWO_support; ext; simp⟩\n  left_inv x := by simp\n  right_inv x := by\n    apply AddOpposite.unop_injective\n    simp\n  map_add' x y := by\n    apply AddOpposite.unop_injective\n    ext\n    simp\n\n"}
{"name":"HahnSeries.addOppositeEquiv_symm_apply_coeff","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddMonoid R\nx : AddOpposite (HahnSeries Γ R)\na : Γ\n⊢ Eq ((HahnSeries.addOppositeEquiv.symm x).coeff a) (AddOpposite.op ((AddOpposite.unop x).coeff a))","decl":"/--\n`addOppositeEquiv` is an additive monoid isomorphism between\nHahn series over `Γ` with coefficients in the opposite additive monoid `Rᵃᵒᵖ`\nand the additive opposite of Hahn series over `Γ` with coefficients `R`.\n-/\n@[simps (config := .lemmasOnly)]\ndef addOppositeEquiv : HahnSeries Γ (Rᵃᵒᵖ) ≃+ (HahnSeries Γ R)ᵃᵒᵖ where\n  toFun x := .op ⟨fun a ↦ (x.coeff a).unop, by convert x.isPWO_support; ext; simp⟩\n  invFun x := ⟨fun a ↦ .op (x.unop.coeff a), by convert x.unop.isPWO_support; ext; simp⟩\n  left_inv x := by simp\n  right_inv x := by\n    apply AddOpposite.unop_injective\n    simp\n  map_add' x y := by\n    apply AddOpposite.unop_injective\n    ext\n    simp\n\n"}
{"name":"HahnSeries.addOppositeEquiv_support","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddMonoid R\nx : HahnSeries Γ (AddOpposite R)\n⊢ Eq (AddOpposite.unop (HahnSeries.addOppositeEquiv x)).support x.support","decl":"@[simp]\nlemma addOppositeEquiv_support (x : HahnSeries Γ (Rᵃᵒᵖ)) :\n    (addOppositeEquiv x).unop.support = x.support := by\n  ext\n  simp [addOppositeEquiv_apply]\n\n"}
{"name":"HahnSeries.addOppositeEquiv_symm_support","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddMonoid R\nx : AddOpposite (HahnSeries Γ R)\n⊢ Eq (HahnSeries.addOppositeEquiv.symm x).support (AddOpposite.unop x).support","decl":"@[simp]\nlemma addOppositeEquiv_symm_support (x : (HahnSeries Γ R)ᵃᵒᵖ) :\n    (addOppositeEquiv.symm x).support = x.unop.support := by\n  rw [← addOppositeEquiv_support, AddEquiv.apply_symm_apply]\n\n"}
{"name":"HahnSeries.addOppositeEquiv_orderTop","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddMonoid R\nx : HahnSeries Γ (AddOpposite R)\n⊢ Eq (AddOpposite.unop (HahnSeries.addOppositeEquiv x)).orderTop x.orderTop","decl":"@[simp]\nlemma addOppositeEquiv_orderTop (x : HahnSeries Γ (Rᵃᵒᵖ)) :\n    (addOppositeEquiv x).unop.orderTop = x.orderTop := by\n  classical\n  simp only [orderTop, AddOpposite.unop_op, mk_eq_zero, EmbeddingLike.map_eq_zero_iff,\n    addOppositeEquiv_support, ne_eq]\n  simp only [addOppositeEquiv_apply, AddOpposite.unop_op, mk_eq_zero, coeff_zero]\n  simp_rw [HahnSeries.ext_iff, funext_iff]\n  simp only [Pi.zero_apply, AddOpposite.unop_eq_zero_iff, coeff_zero]\n\n"}
{"name":"HahnSeries.addOppositeEquiv_symm_orderTop","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddMonoid R\nx : AddOpposite (HahnSeries Γ R)\n⊢ Eq (HahnSeries.addOppositeEquiv.symm x).orderTop (AddOpposite.unop x).orderTop","decl":"@[simp]\nlemma addOppositeEquiv_symm_orderTop (x : (HahnSeries Γ R)ᵃᵒᵖ) :\n    (addOppositeEquiv.symm x).orderTop = x.unop.orderTop := by\n  rw [← addOppositeEquiv_orderTop, AddEquiv.apply_symm_apply]\n\n"}
{"name":"HahnSeries.addOppositeEquiv_leadingCoeff","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddMonoid R\nx : HahnSeries Γ (AddOpposite R)\n⊢ Eq (AddOpposite.unop (HahnSeries.addOppositeEquiv x)).leadingCoeff (AddOpposite.unop x.leadingCoeff)","decl":"@[simp]\nlemma addOppositeEquiv_leadingCoeff (x : HahnSeries Γ (Rᵃᵒᵖ)) :\n    (addOppositeEquiv x).unop.leadingCoeff = x.leadingCoeff.unop := by\n  classical\n  simp only [leadingCoeff, AddOpposite.unop_op, mk_eq_zero, EmbeddingLike.map_eq_zero_iff,\n    addOppositeEquiv_support, ne_eq]\n  simp only [addOppositeEquiv_apply, AddOpposite.unop_op, mk_eq_zero, coeff_zero]\n  simp_rw [HahnSeries.ext_iff, funext_iff]\n  simp only [Pi.zero_apply, AddOpposite.unop_eq_zero_iff, coeff_zero]\n  split <;> rfl\n\n"}
{"name":"HahnSeries.addOppositeEquiv_symm_leadingCoeff","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddMonoid R\nx : AddOpposite (HahnSeries Γ R)\n⊢ Eq (HahnSeries.addOppositeEquiv.symm x).leadingCoeff (AddOpposite.op (AddOpposite.unop x).leadingCoeff)","decl":"@[simp]\nlemma addOppositeEquiv_symm_leadingCoeff (x : (HahnSeries Γ R)ᵃᵒᵖ) :\n    (addOppositeEquiv.symm x).leadingCoeff = .op x.unop.leadingCoeff := by\n  apply AddOpposite.unop_injective\n  rw [← addOppositeEquiv_leadingCoeff, AddEquiv.apply_symm_apply, AddOpposite.unop_op]\n\n"}
{"name":"HahnSeries.support_add_subset","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddMonoid R\nx y : HahnSeries Γ R\n⊢ HasSubset.Subset (HAdd.hAdd x y).support (Union.union x.support y.support)","decl":"theorem support_add_subset {x y : HahnSeries Γ R} : support (x + y) ⊆ support x ∪ support y :=\n  fun a ha => by\n  rw [mem_support, coeff_add] at ha\n  rw [Set.mem_union, mem_support, mem_support]\n  contrapose! ha\n  rw [ha.1, ha.2, add_zero]\n\n"}
{"name":"HahnSeries.min_le_min_add","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"R : Type u_3\ninst✝¹ : AddMonoid R\nΓ : Type u_8\ninst✝ : LinearOrder Γ\nx y : HahnSeries Γ R\nhx : Ne x 0\nhy : Ne y 0\nhxy : Ne (HAdd.hAdd x y) 0\n⊢ LE.le (Min.min (⋯.min ⋯) (⋯.min ⋯)) (⋯.min ⋯)","decl":"protected theorem min_le_min_add {Γ} [LinearOrder Γ] {x y : HahnSeries Γ R} (hx : x ≠ 0)\n    (hy : y ≠ 0) (hxy : x + y ≠ 0) :\n    min (Set.IsWF.min x.isWF_support (support_nonempty_iff.2 hx))\n      (Set.IsWF.min y.isWF_support (support_nonempty_iff.2 hy)) ≤\n      Set.IsWF.min (x + y).isWF_support (support_nonempty_iff.2 hxy) := by\n  rw [← Set.IsWF.min_union]\n  exact Set.IsWF.min_le_min_of_subset (support_add_subset (x := x) (y := y))\n\n"}
{"name":"HahnSeries.min_orderTop_le_orderTop_add","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"R : Type u_3\ninst✝¹ : AddMonoid R\nΓ : Type u_8\ninst✝ : LinearOrder Γ\nx y : HahnSeries Γ R\n⊢ LE.le (Min.min x.orderTop y.orderTop) (HAdd.hAdd x y).orderTop","decl":"theorem min_orderTop_le_orderTop_add {Γ} [LinearOrder Γ] {x y : HahnSeries Γ R} :\n    min x.orderTop y.orderTop ≤ (x + y).orderTop := by\n  by_cases hx : x = 0; · simp [hx]\n  by_cases hy : y = 0; · simp [hy]\n  by_cases hxy : x + y = 0; · simp [hxy]\n  rw [orderTop_of_ne hx, orderTop_of_ne hy, orderTop_of_ne hxy, ← WithTop.coe_min,\n    WithTop.coe_le_coe]\n  exact HahnSeries.min_le_min_add hx hy hxy\n\n"}
{"name":"HahnSeries.min_order_le_order_add","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"R : Type u_3\ninst✝² : AddMonoid R\nΓ : Type u_8\ninst✝¹ : Zero Γ\ninst✝ : LinearOrder Γ\nx y : HahnSeries Γ R\nhxy : Ne (HAdd.hAdd x y) 0\n⊢ LE.le (Min.min x.order y.order) (HAdd.hAdd x y).order","decl":"theorem min_order_le_order_add {Γ} [Zero Γ] [LinearOrder Γ] {x y : HahnSeries Γ R}\n    (hxy : x + y ≠ 0) : min x.order y.order ≤ (x + y).order := by\n  by_cases hx : x = 0; · simp [hx]\n  by_cases hy : y = 0; · simp [hy]\n  rw [order_of_ne hx, order_of_ne hy, order_of_ne hxy]\n  exact HahnSeries.min_le_min_add hx hy hxy\n\n"}
{"name":"HahnSeries.orderTop_add_eq_left","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"R : Type u_3\ninst✝¹ : AddMonoid R\nΓ : Type u_8\ninst✝ : LinearOrder Γ\nx y : HahnSeries Γ R\nhxy : LT.lt x.orderTop y.orderTop\n⊢ Eq (HAdd.hAdd x y).orderTop x.orderTop","decl":"theorem orderTop_add_eq_left {Γ} [LinearOrder Γ] {x y : HahnSeries Γ R}\n    (hxy : x.orderTop < y.orderTop) : (x + y).orderTop = x.orderTop := by\n  have hx : x ≠ 0 := ne_zero_iff_orderTop.mpr hxy.ne_top\n  let g : Γ := Set.IsWF.min x.isWF_support (support_nonempty_iff.2 hx)\n  have hcxyne : (x + y).coeff g ≠ 0 := by\n    rw [coeff_add, coeff_eq_zero_of_lt_orderTop (lt_of_eq_of_lt (orderTop_of_ne hx).symm hxy),\n      add_zero]\n    exact coeff_orderTop_ne (orderTop_of_ne hx)\n  have hxyx : (x + y).orderTop ≤ x.orderTop := by\n    rw [orderTop_of_ne hx]\n    exact orderTop_le_of_coeff_ne_zero hcxyne\n  exact le_antisymm hxyx (le_of_eq_of_le (min_eq_left_of_lt hxy).symm min_orderTop_le_orderTop_add)\n\n"}
{"name":"HahnSeries.orderTop_add_eq_right","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"R : Type u_3\ninst✝¹ : AddMonoid R\nΓ : Type u_8\ninst✝ : LinearOrder Γ\nx y : HahnSeries Γ R\nhxy : LT.lt y.orderTop x.orderTop\n⊢ Eq (HAdd.hAdd x y).orderTop y.orderTop","decl":"theorem orderTop_add_eq_right {Γ} [LinearOrder Γ] {x y : HahnSeries Γ R}\n    (hxy : y.orderTop < x.orderTop) : (x + y).orderTop = y.orderTop := by\n  simpa [← map_add, ← AddOpposite.op_add, hxy] using orderTop_add_eq_left\n    (x := addOppositeEquiv.symm (.op y))\n    (y := addOppositeEquiv.symm (.op x))\n\n"}
{"name":"HahnSeries.leadingCoeff_add_eq_left","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"R : Type u_3\ninst✝¹ : AddMonoid R\nΓ : Type u_8\ninst✝ : LinearOrder Γ\nx y : HahnSeries Γ R\nhxy : LT.lt x.orderTop y.orderTop\n⊢ Eq (HAdd.hAdd x y).leadingCoeff x.leadingCoeff","decl":"theorem leadingCoeff_add_eq_left {Γ} [LinearOrder Γ] {x y : HahnSeries Γ R}\n    (hxy : x.orderTop < y.orderTop) : (x + y).leadingCoeff = x.leadingCoeff := by\n  have hx : x ≠ 0 := ne_zero_iff_orderTop.mpr hxy.ne_top\n  have ho : (x + y).orderTop = x.orderTop := orderTop_add_eq_left hxy\n  by_cases h : x + y = 0\n  · rw [h, orderTop_zero] at ho\n    rw [h, orderTop_eq_top_iff.mp ho.symm]\n  · rw [orderTop_of_ne h, orderTop_of_ne hx, WithTop.coe_eq_coe] at ho\n    rw [leadingCoeff_of_ne h, leadingCoeff_of_ne hx, ho, coeff_add,\n      coeff_eq_zero_of_lt_orderTop (lt_of_eq_of_lt (orderTop_of_ne hx).symm hxy), add_zero]\n\n"}
{"name":"HahnSeries.leadingCoeff_add_eq_right","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"R : Type u_3\ninst✝¹ : AddMonoid R\nΓ : Type u_8\ninst✝ : LinearOrder Γ\nx y : HahnSeries Γ R\nhxy : LT.lt y.orderTop x.orderTop\n⊢ Eq (HAdd.hAdd x y).leadingCoeff y.leadingCoeff","decl":"theorem leadingCoeff_add_eq_right {Γ} [LinearOrder Γ] {x y : HahnSeries Γ R}\n    (hxy : y.orderTop < x.orderTop) : (x + y).leadingCoeff = y.leadingCoeff := by\n  simpa [← map_add, ← AddOpposite.op_add, hxy] using leadingCoeff_add_eq_left\n    (x := addOppositeEquiv.symm (.op y))\n    (y := addOppositeEquiv.symm (.op x))\n\n"}
{"name":"HahnSeries.single.addMonoidHom_apply_coeff","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddMonoid R\na : Γ\nr : R\nj : Γ\n⊢ Eq (((HahnSeries.single.addMonoidHom a) r).coeff j) (Pi.single a r j)","decl":"/-- `single` as an additive monoid/group homomorphism -/\n@[simps!]\ndef single.addMonoidHom (a : Γ) : R →+ HahnSeries Γ R :=\n  { single a with\n    map_add' := fun x y => by\n      ext b\n      by_cases h : b = a <;> simp [h] }\n\n"}
{"name":"HahnSeries.coeff.addMonoidHom_apply","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddMonoid R\ng : Γ\nf : HahnSeries Γ R\n⊢ Eq ((HahnSeries.coeff.addMonoidHom g) f) (f.coeff g)","decl":"/-- `coeff g` as an additive monoid/group homomorphism -/\n@[simps]\ndef coeff.addMonoidHom (g : Γ) : HahnSeries Γ R →+ R where\n  toFun f := f.coeff g\n  map_zero' := coeff_zero\n  map_add' _ _ := coeff_add\n\n"}
{"name":"HahnSeries.embDomain_add","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\ninst✝² : PartialOrder Γ\ninst✝¹ : AddMonoid R\ninst✝ : PartialOrder Γ'\nf : OrderEmbedding Γ Γ'\nx y : HahnSeries Γ R\n⊢ Eq (HahnSeries.embDomain f (HAdd.hAdd x y)) (HAdd.hAdd (HahnSeries.embDomain f x) (HahnSeries.embDomain f y))","decl":"theorem embDomain_add (f : Γ ↪o Γ') (x y : HahnSeries Γ R) :\n    embDomain f (x + y) = embDomain f x + embDomain f y := by\n  ext g\n  by_cases hg : g ∈ Set.range f\n  · obtain ⟨a, rfl⟩ := hg\n    simp\n  · simp [embDomain_notin_range hg]\n\n"}
{"name":"HahnSeries.coeff_sum","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\nα : Type u_7\ninst✝¹ : PartialOrder Γ\ninst✝ : AddCommMonoid R\ns : Finset α\nx : α → HahnSeries Γ R\ng : Γ\n⊢ Eq ((s.sum fun i => x i).coeff g) (s.sum fun i => (x i).coeff g)","decl":"@[simp]\ntheorem coeff_sum {s : Finset α} {x : α → HahnSeries Γ R} (g : Γ) :\n    (∑ i ∈ s, x i).coeff g = ∑ i ∈ s, (x i).coeff g :=\n  cons_induction rfl (fun i s his hsum => by rw [sum_cons, sum_cons, coeff_add, hsum]) s\n\n"}
{"name":"HahnSeries.coeff_neg'","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddGroup R\nx : HahnSeries Γ R\n⊢ Eq (Neg.neg x).coeff (Neg.neg x.coeff)","decl":"@[simp]\ntheorem coeff_neg' {x : HahnSeries Γ R} : (-x).coeff = -x.coeff :=\n  rfl\n\n"}
{"name":"HahnSeries.neg_coeff'","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddGroup R\nx : HahnSeries Γ R\n⊢ Eq (Neg.neg x).coeff (Neg.neg x.coeff)","decl":"@[deprecated (since := \"2025-01-31\")] alias neg_coeff' := coeff_neg'\n\n"}
{"name":"HahnSeries.coeff_neg","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddGroup R\nx : HahnSeries Γ R\na : Γ\n⊢ Eq ((Neg.neg x).coeff a) (Neg.neg (x.coeff a))","decl":"theorem coeff_neg {x : HahnSeries Γ R} {a : Γ} : (-x).coeff a = -x.coeff a :=\n  rfl\n\n"}
{"name":"HahnSeries.neg_coeff","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddGroup R\nx : HahnSeries Γ R\na : Γ\n⊢ Eq ((Neg.neg x).coeff a) (Neg.neg (x.coeff a))","decl":"@[deprecated (since := \"2025-01-31\")] alias neg_coeff := coeff_neg\n\n"}
{"name":"HahnSeries.support_neg","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddGroup R\nx : HahnSeries Γ R\n⊢ Eq (Neg.neg x).support x.support","decl":"@[simp]\ntheorem support_neg {x : HahnSeries Γ R} : (-x).support = x.support := by\n  ext\n  simp\n\n"}
{"name":"HahnSeries.map_neg","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\nS : Type u_4\ninst✝² : PartialOrder Γ\ninst✝¹ : AddGroup R\ninst✝ : AddGroup S\nf : AddMonoidHom R S\nx : HahnSeries Γ R\n⊢ Eq ((Neg.neg x).map f) (Neg.neg (x.map f))","decl":"@[simp]\nprotected lemma map_neg [AddGroup S] (f : R →+ S) {x : HahnSeries Γ R} :\n    ((-x).map f : HahnSeries Γ S) = -(x.map f) := by\n  ext; simp\n\n"}
{"name":"HahnSeries.orderTop_neg","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddGroup R\nx : HahnSeries Γ R\n⊢ Eq (Neg.neg x).orderTop x.orderTop","decl":"theorem orderTop_neg {x : HahnSeries Γ R} : (-x).orderTop = x.orderTop := by\n  classical simp only [orderTop, support_neg, neg_eq_zero]\n\n"}
{"name":"HahnSeries.order_neg","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝² : PartialOrder Γ\ninst✝¹ : AddGroup R\ninst✝ : Zero Γ\nf : HahnSeries Γ R\n⊢ Eq (Neg.neg f).order f.order","decl":"@[simp]\ntheorem order_neg [Zero Γ] {f : HahnSeries Γ R} : (-f).order = f.order := by\n  classical\n  by_cases hf : f = 0\n  · simp only [hf, neg_zero]\n  simp only [order, support_neg, neg_eq_zero]\n\n"}
{"name":"HahnSeries.coeff_sub'","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddGroup R\nx y : HahnSeries Γ R\n⊢ Eq (HSub.hSub x y).coeff (HSub.hSub x.coeff y.coeff)","decl":"@[simp]\ntheorem coeff_sub' {x y : HahnSeries Γ R} : (x - y).coeff = x.coeff - y.coeff := by\n  ext\n  simp [sub_eq_add_neg]\n\n"}
{"name":"HahnSeries.sub_coeff'","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddGroup R\nx y : HahnSeries Γ R\n⊢ Eq (HSub.hSub x y).coeff (HSub.hSub x.coeff y.coeff)","decl":"@[deprecated (since := \"2025-01-31\")] alias sub_coeff' := coeff_sub'\n\n"}
{"name":"HahnSeries.coeff_sub","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddGroup R\nx y : HahnSeries Γ R\na : Γ\n⊢ Eq ((HSub.hSub x y).coeff a) (HSub.hSub (x.coeff a) (y.coeff a))","decl":"theorem coeff_sub {x y : HahnSeries Γ R} {a : Γ} : (x - y).coeff a = x.coeff a - y.coeff a := by\n  simp\n\n"}
{"name":"HahnSeries.sub_coeff","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : AddGroup R\nx y : HahnSeries Γ R\na : Γ\n⊢ Eq ((HSub.hSub x y).coeff a) (HSub.hSub (x.coeff a) (y.coeff a))","decl":"@[deprecated (since := \"2025-01-31\")] alias sub_coeff := coeff_sub\n\n"}
{"name":"HahnSeries.map_sub","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\nS : Type u_4\ninst✝² : PartialOrder Γ\ninst✝¹ : AddGroup R\ninst✝ : AddGroup S\nf : AddMonoidHom R S\nx y : HahnSeries Γ R\n⊢ Eq ((HSub.hSub x y).map f) (HSub.hSub (x.map f) (y.map f))","decl":"@[simp]\nprotected lemma map_sub [AddGroup S] (f : R →+ S) {x y : HahnSeries Γ R} :\n    ((x - y).map f : HahnSeries Γ S) = x.map f - y.map f := by\n  ext; simp\n\n"}
{"name":"HahnSeries.min_orderTop_le_orderTop_sub","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"R : Type u_3\ninst✝¹ : AddGroup R\nΓ : Type u_8\ninst✝ : LinearOrder Γ\nx y : HahnSeries Γ R\n⊢ LE.le (Min.min x.orderTop y.orderTop) (HSub.hSub x y).orderTop","decl":"theorem min_orderTop_le_orderTop_sub {Γ} [LinearOrder Γ] {x y : HahnSeries Γ R} :\n    min x.orderTop y.orderTop ≤ (x - y).orderTop := by\n  rw [sub_eq_add_neg, ← orderTop_neg (x := y)]\n  exact min_orderTop_le_orderTop_add\n\n"}
{"name":"HahnSeries.orderTop_sub","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"R : Type u_3\ninst✝¹ : AddGroup R\nΓ : Type u_8\ninst✝ : LinearOrder Γ\nx y : HahnSeries Γ R\nhxy : LT.lt x.orderTop y.orderTop\n⊢ Eq (HSub.hSub x y).orderTop x.orderTop","decl":"theorem orderTop_sub {Γ} [LinearOrder Γ] {x y : HahnSeries Γ R}\n    (hxy : x.orderTop < y.orderTop) : (x - y).orderTop = x.orderTop := by\n  rw [sub_eq_add_neg]\n  rw [← orderTop_neg (x := y)] at hxy\n  exact orderTop_add_eq_left hxy\n\n"}
{"name":"HahnSeries.leadingCoeff_sub","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"R : Type u_3\ninst✝¹ : AddGroup R\nΓ : Type u_8\ninst✝ : LinearOrder Γ\nx y : HahnSeries Γ R\nhxy : LT.lt x.orderTop y.orderTop\n⊢ Eq (HSub.hSub x y).leadingCoeff x.leadingCoeff","decl":"theorem leadingCoeff_sub {Γ} [LinearOrder Γ] {x y : HahnSeries Γ R}\n    (hxy : x.orderTop < y.orderTop) : (x - y).leadingCoeff = x.leadingCoeff := by\n  rw [sub_eq_add_neg]\n  rw [← orderTop_neg (x := y)] at hxy\n  exact leadingCoeff_add_eq_left hxy\n\n"}
{"name":"HahnSeries.coeff_smul","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝² : PartialOrder Γ\nV : Type u_8\ninst✝¹ : Zero V\ninst✝ : SMulZeroClass R V\nr : R\nx : HahnSeries Γ V\na : Γ\n⊢ Eq ((HSMul.hSMul r x).coeff a) (HSMul.hSMul r (x.coeff a))","decl":"@[simp]\ntheorem coeff_smul {r : R} {x : HahnSeries Γ V} {a : Γ} : (r • x).coeff a = r • x.coeff a :=\n  rfl\n\n"}
{"name":"HahnSeries.smul_coeff","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝² : PartialOrder Γ\nV : Type u_8\ninst✝¹ : Zero V\ninst✝ : SMulZeroClass R V\nr : R\nx : HahnSeries Γ V\na : Γ\n⊢ Eq ((HSMul.hSMul r x).coeff a) (HSMul.hSMul r (x.coeff a))","decl":"@[deprecated (since := \"2025-01-31\")] alias smul_coeff := coeff_smul\n\n"}
{"name":"HahnSeries.orderTop_smul_not_lt","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝² : PartialOrder Γ\nV : Type u_8\ninst✝¹ : Zero V\ninst✝ : SMulZeroClass R V\nr : R\nx : HahnSeries Γ V\n⊢ Not (LT.lt (HSMul.hSMul r x).orderTop x.orderTop)","decl":"theorem orderTop_smul_not_lt (r : R) (x : HahnSeries Γ V) : ¬ (r • x).orderTop < x.orderTop := by\n  by_cases hrx : r • x = 0\n  · rw [hrx, orderTop_zero]\n    exact not_top_lt\n  · simp only [orderTop_of_ne hrx, orderTop_of_ne <| right_ne_zero_of_smul hrx, WithTop.coe_lt_coe]\n    exact Set.IsWF.min_of_subset_not_lt_min\n      (Function.support_smul_subset_right (fun _ => r) x.coeff)\n\n"}
{"name":"HahnSeries.order_smul_not_lt","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝³ : PartialOrder Γ\nV : Type u_8\ninst✝² : Zero V\ninst✝¹ : SMulZeroClass R V\ninst✝ : Zero Γ\nr : R\nx : HahnSeries Γ V\nh : Ne (HSMul.hSMul r x) 0\n⊢ Not (LT.lt (HSMul.hSMul r x).order x.order)","decl":"theorem order_smul_not_lt [Zero Γ] (r : R) (x : HahnSeries Γ V) (h : r • x ≠ 0) :\n    ¬ (r • x).order < x.order := by\n  have hx : x ≠ 0 := right_ne_zero_of_smul h\n  simp_all only [order, dite_false]\n  exact Set.IsWF.min_of_subset_not_lt_min (Function.support_smul_subset_right (fun _ => r) x.coeff)\n\n"}
{"name":"HahnSeries.le_order_smul","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"R : Type u_3\nV : Type u_8\ninst✝³ : Zero V\ninst✝² : SMulZeroClass R V\nΓ : Type u_9\ninst✝¹ : Zero Γ\ninst✝ : LinearOrder Γ\nr : R\nx : HahnSeries Γ V\nh : Ne (HSMul.hSMul r x) 0\n⊢ LE.le x.order (HSMul.hSMul r x).order","decl":"theorem le_order_smul {Γ} [Zero Γ] [LinearOrder Γ] (r : R) (x : HahnSeries Γ V) (h : r • x ≠ 0) :\n    x.order ≤ (r • x).order :=\n  le_of_not_lt (order_smul_not_lt r x h)\n\n"}
{"name":"HahnSeries.instIsScalarTower","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝⁷ : PartialOrder Γ\nV : Type u_8\ninst✝⁶ : Monoid R\ninst✝⁵ : AddMonoid V\ninst✝⁴ : DistribMulAction R V\nS : Type u_9\ninst✝³ : Monoid S\ninst✝² : DistribMulAction S V\ninst✝¹ : SMul R S\ninst✝ : IsScalarTower R S V\n⊢ IsScalarTower R S (HahnSeries Γ V)","decl":"instance [SMul R S] [IsScalarTower R S V] : IsScalarTower R S (HahnSeries Γ V) :=\n  ⟨fun r s a => by\n    ext\n    simp⟩\n\n"}
{"name":"HahnSeries.instSMulCommClass","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝⁶ : PartialOrder Γ\nV : Type u_8\ninst✝⁵ : Monoid R\ninst✝⁴ : AddMonoid V\ninst✝³ : DistribMulAction R V\nS : Type u_9\ninst✝² : Monoid S\ninst✝¹ : DistribMulAction S V\ninst✝ : SMulCommClass R S V\n⊢ SMulCommClass R S (HahnSeries Γ V)","decl":"instance [SMulCommClass R S V] : SMulCommClass R S (HahnSeries Γ V) :=\n  ⟨fun r s a => by\n    ext\n    simp [smul_comm]⟩\n\n"}
{"name":"HahnSeries.single.linearMap_apply","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\nV : Type u_6\ninst✝³ : PartialOrder Γ\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid V\ninst✝ : Module R V\na : Γ\na✝ : V\n⊢ Eq ((HahnSeries.single.linearMap a) a✝) ((↑(HahnSeries.single.addMonoidHom a)).toFun a✝)","decl":"/-- `single` as a linear map -/\n@[simps]\ndef single.linearMap (a : Γ) : V →ₗ[R] HahnSeries Γ V :=\n  { single.addMonoidHom a with\n    map_smul' := fun r s => by\n      ext b\n      by_cases h : b = a <;> simp [h] }\n\n"}
{"name":"HahnSeries.coeff.linearMap_apply","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\nV : Type u_6\ninst✝³ : PartialOrder Γ\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid V\ninst✝ : Module R V\ng : Γ\na✝ : HahnSeries Γ V\n⊢ Eq ((HahnSeries.coeff.linearMap g) a✝) ((↑(HahnSeries.coeff.addMonoidHom g)).toFun a✝)","decl":"/-- `coeff g` as a linear map -/\n@[simps]\ndef coeff.linearMap (g : Γ) : HahnSeries Γ V →ₗ[R] V :=\n  { coeff.addMonoidHom g with map_smul' := fun _ _ => rfl }\n\n"}
{"name":"HahnSeries.map_smul","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nR : Type u_3\nU : Type u_5\nV : Type u_6\ninst✝⁵ : PartialOrder Γ\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid V\ninst✝² : Module R V\ninst✝¹ : AddCommMonoid U\ninst✝ : Module R U\nf : LinearMap (RingHom.id R) U V\nr : R\nx : HahnSeries Γ U\n⊢ Eq ((HSMul.hSMul r x).map f) (HSMul.hSMul r (x.map f))","decl":"@[simp]\nprotected lemma map_smul [AddCommMonoid U] [Module R U] (f : U →ₗ[R] V) {r : R}\n    {x : HahnSeries Γ U} : (r • x).map f = r • ((x.map f) : HahnSeries Γ V) := by\n  ext; simp\n\n"}
{"name":"HahnSeries.embDomain_smul","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\ninst✝² : PartialOrder Γ\ninst✝¹ : Semiring R\ninst✝ : PartialOrder Γ'\nf : OrderEmbedding Γ Γ'\nr : R\nx : HahnSeries Γ R\n⊢ Eq (HahnSeries.embDomain f (HSMul.hSMul r x)) (HSMul.hSMul r (HahnSeries.embDomain f x))","decl":"theorem embDomain_smul (f : Γ ↪o Γ') (r : R) (x : HahnSeries Γ R) :\n    embDomain f (r • x) = r • embDomain f x := by\n  ext g\n  by_cases hg : g ∈ Set.range f\n  · obtain ⟨a, rfl⟩ := hg\n    simp\n  · simp [embDomain_notin_range hg]\n\n"}
{"name":"HahnSeries.embDomainLinearMap_apply","module":"Mathlib.RingTheory.HahnSeries.Addition","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\ninst✝² : PartialOrder Γ\ninst✝¹ : Semiring R\ninst✝ : PartialOrder Γ'\nf : OrderEmbedding Γ Γ'\na✝ : HahnSeries Γ R\n⊢ Eq ((HahnSeries.embDomainLinearMap f) a✝) (HahnSeries.embDomain f a✝)","decl":"/-- Extending the domain of Hahn series is a linear map. -/\n@[simps]\ndef embDomainLinearMap (f : Γ ↪o Γ') : HahnSeries Γ R →ₗ[R] HahnSeries Γ' R where\n  toFun := embDomain f\n  map_add' := embDomain_add f\n  map_smul' := embDomain_smul f\n\n"}
