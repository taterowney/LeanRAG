{"name":"IsDedekindDomain.HeightOneSpectrum.valuationOfNeZeroToFun_eq","module":"Mathlib.RingTheory.DedekindDomain.SelmerGroup","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type v\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\nx : Units K\n⊢ Eq (↑(v.valuationOfNeZeroToFun x)) (v.valuation ↑x)","decl":"@[simp]\ntheorem valuationOfNeZeroToFun_eq (x : Kˣ) :\n    (v.valuationOfNeZeroToFun x : ℤₘ₀) = v.valuation (x : K) := by\n  classical\n  rw [show v.valuation (x : K) = _ * _ by rfl]\n  rw [Units.val_inv_eq_inv_val]\n  change _ = ite _ _ _ * (ite _ _ _)⁻¹\n  simp_rw [IsLocalization.toLocalizationMap_sec, SubmonoidClass.coe_subtype,\n    if_neg <| IsLocalization.sec_fst_ne_zero le_rfl x.ne_zero,\n    if_neg (nonZeroDivisors.coe_ne_zero _),\n    valuationOfNeZeroToFun, ofAdd_sub, ofAdd_neg, div_inv_eq_mul, WithZero.coe_mul,\n    WithZero.coe_inv, inv_inv]\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.valuationOfNeZero_eq","module":"Mathlib.RingTheory.DedekindDomain.SelmerGroup","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type v\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\nx : Units K\n⊢ Eq (↑(v.valuationOfNeZero x)) (v.valuation ↑x)","decl":"@[simp]\ntheorem valuationOfNeZero_eq (x : Kˣ) : (v.valuationOfNeZero x : ℤₘ₀) = v.valuation (x : K) :=\n  valuationOfNeZeroToFun_eq v x\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.valuation_of_unit_eq","module":"Mathlib.RingTheory.DedekindDomain.SelmerGroup","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type v\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\nx : Units R\n⊢ Eq (v.valuationOfNeZero ((Units.map ↑(algebraMap R K)) x)) 1","decl":"@[simp]\ntheorem valuation_of_unit_eq (x : Rˣ) :\n    v.valuationOfNeZero (Units.map (algebraMap R K : R →* K) x) = 1 := by\n  rw [← WithZero.coe_inj, valuationOfNeZero_eq, Units.coe_map, eq_iff_le_not_lt]\n  constructor\n  · exact v.valuation_le_one x\n  · cases' x with x _ hx _\n    change ¬v.valuation (algebraMap R K x) < 1\n    apply_fun v.intValuation at hx\n    rw [map_one, map_mul] at hx\n    rw [not_lt, ← hx, ← mul_one <| v.valuation _, valuation_of_algebraMap,\n      mul_le_mul_left <| zero_lt_iff.2 <| left_ne_zero_of_mul_eq_one hx]\n    exact v.intValuation_le_one _\n\n-- Porting note: invalid attribute 'semireducible', declaration is in an imported module\n-- attribute [local semireducible] MulOpposite\n\n"}
{"name":"IsDedekindDomain.HeightOneSpectrum.valuation_of_unit_mod_eq","module":"Mathlib.RingTheory.DedekindDomain.SelmerGroup","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type v\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nv : IsDedekindDomain.HeightOneSpectrum R\nn : Nat\nx : Units R\n⊢ Eq ((v.valuationOfNeZeroMod n) ↑((Units.map ↑(algebraMap R K)) x)) 1","decl":"@[simp]\ntheorem valuation_of_unit_mod_eq (n : ℕ) (x : Rˣ) :\n    v.valuationOfNeZeroMod n (Units.map (algebraMap R K : R →* K) x : K/n) = 1 := by\n  -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n  erw [valuationOfNeZeroMod, MonoidHom.comp_apply, ← QuotientGroup.coe_mk',\n    QuotientGroup.map_mk' (G := Kˣ) (N := MonoidHom.range (powMonoidHom n)),\n    valuation_of_unit_eq, QuotientGroup.mk_one, map_one]\n\n"}
{"name":"IsDedekindDomain.selmerGroup.monotone","module":"Mathlib.RingTheory.DedekindDomain.SelmerGroup","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type v\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nS S' : Set (IsDedekindDomain.HeightOneSpectrum R)\nn : Nat\nhS : LE.le S S'\n⊢ LE.le IsDedekindDomain.selmerGroup IsDedekindDomain.selmerGroup","decl":"theorem monotone (hS : S ≤ S') : K⟮S,n⟯ ≤ K⟮S',n⟯ := fun _ hx v => hx v ∘ mt (@hS v)\n\n"}
{"name":"IsDedekindDomain.selmerGroup.valuation_ker_eq","module":"Mathlib.RingTheory.DedekindDomain.SelmerGroup","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type v\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nS : Set (IsDedekindDomain.HeightOneSpectrum R)\nn : Nat\n⊢ Eq IsDedekindDomain.selmerGroup.valuation.ker (IsDedekindDomain.selmerGroup.subgroupOf IsDedekindDomain.selmerGroup)","decl":"theorem valuation_ker_eq :\n    valuation.ker = K⟮(∅ : Set <| HeightOneSpectrum R),n⟯.subgroupOf (K⟮S,n⟯) := by\n  ext ⟨_, hx⟩\n  constructor\n  · intro hx' v _\n    by_cases hv : v ∈ S\n    · exact congr_fun hx' ⟨v, hv⟩\n    · exact hx v hv\n  · exact fun hx' => funext fun v => hx' v <| Set.not_mem_empty v\n\n"}
{"name":"IsDedekindDomain.selmerGroup.fromUnit_ker","module":"Mathlib.RingTheory.DedekindDomain.SelmerGroup","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nK : Type v\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nn : Nat\nhn : Fact (LT.lt 0 n)\n⊢ Eq IsDedekindDomain.selmerGroup.fromUnit.ker (powMonoidHom n).range","decl":"theorem fromUnit_ker [hn : Fact <| 0 < n] :\n    (@fromUnit R _ _ K _ _ _ n).ker = (powMonoidHom n : Rˣ →* Rˣ).range := by\n  ext ⟨_, _, _, _⟩\n  constructor\n  · intro hx\n    rcases (QuotientGroup.eq_one_iff _).mp (Subtype.mk.inj hx) with ⟨⟨v, i, vi, iv⟩, hx⟩\n    have hv : ↑(_ ^ n : Kˣ) = algebraMap R K _ := congr_arg Units.val hx\n    have hi : ↑(_ ^ n : Kˣ)⁻¹ = algebraMap R K _ := congr_arg Units.inv hx\n    rw [Units.val_pow_eq_pow_val] at hv\n    rw [← inv_pow, Units.inv_mk, Units.val_pow_eq_pow_val] at hi\n    rcases IsIntegrallyClosed.exists_algebraMap_eq_of_isIntegral_pow (R := R) (x := v) hn.out\n        (hv.symm ▸ isIntegral_algebraMap) with\n      ⟨v', rfl⟩\n    rcases IsIntegrallyClosed.exists_algebraMap_eq_of_isIntegral_pow (R := R) (x := i) hn.out\n        (hi.symm ▸ isIntegral_algebraMap) with\n      ⟨i', rfl⟩\n    rw [← map_mul, map_eq_one_iff _ <| NoZeroSMulDivisors.algebraMap_injective R K] at vi\n    rw [← map_mul, map_eq_one_iff _ <| NoZeroSMulDivisors.algebraMap_injective R K] at iv\n    rw [Units.val_mk, ← map_pow] at hv\n    exact ⟨⟨v', i', vi, iv⟩, by\n      simpa only [Units.ext_iff, powMonoidHom_apply, Units.val_pow_eq_pow_val] using\n         NoZeroSMulDivisors.algebraMap_injective R K hv⟩\n  · rintro ⟨x, hx⟩\n    rw [← hx]\n    exact Subtype.mk_eq_mk.mpr <| (QuotientGroup.eq_one_iff _).mpr ⟨Units.map (algebraMap R K) x,\n      by simp only [powMonoidHom_apply, RingHom.toMonoidHom_eq_coe, map_pow]⟩\n\n"}
{"name":"IsDedekindDomain.selmerGroup.fromUnitLift_injective","module":"Mathlib.RingTheory.DedekindDomain.SelmerGroup","initialProofState":"R : Type u\ninst✝⁵ : CommRing R\ninst✝⁴ : IsDedekindDomain R\nK : Type v\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\nn : Nat\ninst✝ : Fact (LT.lt 0 n)\n⊢ Function.Injective ⇑IsDedekindDomain.selmerGroup.fromUnitLift","decl":"theorem fromUnitLift_injective [Fact <| 0 < n] :\n    Function.Injective <| @fromUnitLift R _ _ K _ _ _ n _ := by\n  dsimp only [fromUnitLift, MonoidHom.coe_comp, MulEquiv.coe_toMonoidHom]\n  exact Function.Injective.comp (QuotientGroup.kerLift_injective _) (MulEquiv.injective _)\n\n"}
