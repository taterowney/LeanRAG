{"name":"Polynomial.mem_span_C_X_sub_C_X_sub_C_iff_eval_eval_eq_zero","module":"Mathlib.RingTheory.Polynomial.Ideal","initialProofState":"R : Type u_1\ninst✝ : CommRing R\na : R\nb : Polynomial R\nP : Polynomial (Polynomial R)\n⊢ Iff (Membership.mem (Ideal.span (Insert.insert (Polynomial.C (HSub.hSub Polynomial.X (Polynomial.C a))) (Singleton.singleton (HSub.hSub Polynomial.X (Polynomial.C b))))) P) (Eq (Polynomial.eval a (Polynomial.eval b P)) 0)","decl":"theorem mem_span_C_X_sub_C_X_sub_C_iff_eval_eval_eq_zero {b : R[X]} {P : R[X][X]} :\n    P ∈ Ideal.span {C (X - C a), X - C b} ↔ (P.eval b).eval a = 0 := by\n  rw [Ideal.mem_span_pair]\n  constructor <;> intro h\n  · rcases h with ⟨_, _, rfl⟩\n    simp only [eval_C, eval_X, eval_add, eval_sub, eval_mul, add_zero, mul_zero, sub_self]\n  · rcases dvd_iff_isRoot.mpr h with ⟨p, hp⟩\n    rcases @X_sub_C_dvd_sub_C_eval _ b _ P with ⟨q, hq⟩\n    exact ⟨C p, q, by rw [mul_comm, mul_comm q, eq_add_of_sub_eq' hq, hp, C_mul]⟩\n\n"}
{"name":"Polynomial.ker_evalRingHom","module":"Mathlib.RingTheory.Polynomial.Ideal","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx : R\n⊢ Eq (RingHom.ker (Polynomial.evalRingHom x)) (Ideal.span (Singleton.singleton (HSub.hSub Polynomial.X (Polynomial.C x))))","decl":"theorem ker_evalRingHom (x : R) : RingHom.ker (evalRingHom x) = Ideal.span {X - C x} := by\n  ext y\n  simp [Ideal.mem_span_singleton, dvd_iff_isRoot, RingHom.mem_ker]\n\n"}
{"name":"Polynomial.ker_modByMonicHom","module":"Mathlib.RingTheory.Polynomial.Ideal","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nq : Polynomial R\nhq : q.Monic\n⊢ Eq (LinearMap.ker q.modByMonicHom) (Submodule.restrictScalars R (Ideal.span (Singleton.singleton q)))","decl":"@[simp]\ntheorem ker_modByMonicHom {q : R[X]} (hq : q.Monic) :\n    LinearMap.ker (Polynomial.modByMonicHom q) = (Ideal.span {q}).restrictScalars R :=\n  Submodule.ext fun _ => (mem_ker_modByMonic hq).trans Ideal.mem_span_singleton.symm\n\n"}
{"name":"Algebra.mem_ideal_map_adjoin","module":"Mathlib.RingTheory.Polynomial.Ideal","initialProofState":"R : Type u_2\nS : Type u_3\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx : S\nI : Ideal R\ny : Subtype fun x_1 => Membership.mem (Algebra.adjoin R (Singleton.singleton x)) x_1\n⊢ Iff (Membership.mem (Ideal.map (algebraMap R (Subtype fun x_1 => Membership.mem (Algebra.adjoin R (Singleton.singleton x)) x_1)) I) y) (Exists fun p => And (∀ (i : Nat), Membership.mem I (p.coeff i)) (Eq ((Polynomial.aeval x) p) ↑y))","decl":"open Algebra in\nlemma _root_.Algebra.mem_ideal_map_adjoin {R S : Type*} [CommRing R] [CommRing S] [Algebra R S]\n    (x : S) (I : Ideal R) {y : adjoin R ({x} : Set S)} :\n    y ∈ I.map (algebraMap R (adjoin R ({x} : Set S))) ↔\n      ∃ p : R[X], (∀ i, p.coeff i ∈ I) ∧ Polynomial.aeval x p = y := by\n  constructor\n  · intro H\n    induction' H using Submodule.span_induction with a ha a b ha hb ha' hb' a b hb hb'\n    · obtain ⟨a, ha, rfl⟩ := ha\n      exact ⟨C a, fun i ↦ by rw [coeff_C]; aesop, aeval_C _ _⟩\n    · exact ⟨0, by simp, aeval_zero _⟩\n    · obtain ⟨a, ha, ha'⟩ := ha'\n      obtain ⟨b, hb, hb'⟩ := hb'\n      exact ⟨a + b, fun i ↦ by simpa using add_mem (ha i) (hb i), by simp [ha', hb']⟩\n    · obtain ⟨b', hb, hb'⟩ := hb'\n      obtain ⟨a, ha⟩ := a\n      rw [Algebra.adjoin_singleton_eq_range_aeval] at ha\n      obtain ⟨p, hp : aeval x p = a⟩ := ha\n      refine ⟨p * b', fun i ↦ ?_, by simp [hp, hb']⟩\n      rw [coeff_mul]\n      exact sum_mem fun i hi ↦ Ideal.mul_mem_left _ _ (hb _)\n  · rintro ⟨p, hp, hp'⟩\n    have : y = ∑ i ∈ p.support, p.coeff i • ⟨_, (X ^ i).aeval_mem_adjoin_singleton _ x⟩ := by\n      trans ∑ i ∈ p.support, ⟨_, (C (p.coeff i) * X ^ i).aeval_mem_adjoin_singleton _ x⟩\n      · ext1\n        simp only [AddSubmonoidClass.coe_finset_sum, ← map_sum, ← hp', ← as_sum_support_C_mul_X_pow]\n      · congr with i\n        simp [Algebra.smul_def]\n    simp_rw [this, Algebra.smul_def]\n    exact sum_mem fun i _ ↦ Ideal.mul_mem_right _ _ (Ideal.mem_map_of_mem _ (hp i))\n\n"}
