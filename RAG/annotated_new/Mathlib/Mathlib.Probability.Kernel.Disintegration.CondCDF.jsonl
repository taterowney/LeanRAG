{"name":"MeasureTheory.Measure.IicSnd_apply","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\nr : Real\ns : Set Î±\nhs : MeasurableSet s\nâŠ¢ Eq ((Ï.IicSnd r) s) (Ï (SProd.sprod s (Set.Iic r)))","decl":"theorem IicSnd_apply (r : â„) {s : Set Î±} (hs : MeasurableSet s) :\n    Ï.IicSnd r s = Ï (s Ã—Ë¢ Iic r) := by\n  rw [IicSnd, fst_apply hs, restrict_apply' (MeasurableSet.univ.prod measurableSet_Iic),\n    univ_prod, Set.prod_eq]\n\n"}
{"name":"MeasureTheory.Measure.IicSnd_univ","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\nr : Real\nâŠ¢ Eq ((Ï.IicSnd r) Set.univ) (Ï (SProd.sprod Set.univ (Set.Iic r)))","decl":"theorem IicSnd_univ (r : â„) : Ï.IicSnd r univ = Ï (univ Ã—Ë¢ Iic r) :=\n  IicSnd_apply Ï r MeasurableSet.univ\n\n"}
{"name":"MeasureTheory.Measure.IicSnd_mono","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\nr r' : Real\nh_le : LE.le r r'\nâŠ¢ LE.le (Ï.IicSnd r) (Ï.IicSnd r')","decl":"@[gcongr]\ntheorem IicSnd_mono {r r' : â„} (h_le : r â‰¤ r') : Ï.IicSnd r â‰¤ Ï.IicSnd r' := by\n  unfold IicSnd; gcongr\n\n"}
{"name":"MeasureTheory.Measure.IicSnd_le_fst","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\nr : Real\nâŠ¢ LE.le (Ï.IicSnd r) Ï.fst","decl":"theorem IicSnd_le_fst (r : â„) : Ï.IicSnd r â‰¤ Ï.fst :=\n  fst_mono restrict_le_self\n\n"}
{"name":"MeasureTheory.Measure.IicSnd_ac_fst","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\nr : Real\nâŠ¢ (Ï.IicSnd r).AbsolutelyContinuous Ï.fst","decl":"theorem IicSnd_ac_fst (r : â„) : Ï.IicSnd r â‰ª Ï.fst :=\n  Measure.absolutelyContinuous_of_le (IicSnd_le_fst Ï r)\n\n"}
{"name":"MeasureTheory.Measure.IsFiniteMeasure.IicSnd","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\ninstâœ : MeasureTheory.IsFiniteMeasure Ï\nr : Real\nâŠ¢ MeasureTheory.IsFiniteMeasure (Ï.IicSnd r)","decl":"theorem IsFiniteMeasure.IicSnd {Ï : Measure (Î± Ã— â„)} [IsFiniteMeasure Ï] (r : â„) :\n    IsFiniteMeasure (Ï.IicSnd r) :=\n  isFiniteMeasure_of_le _ (IicSnd_le_fst Ï _)\n\n"}
{"name":"MeasureTheory.Measure.iInf_IicSnd_gt","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\nt : Rat\ns : Set Î±\nhs : MeasurableSet s\ninstâœ : MeasureTheory.IsFiniteMeasure Ï\nâŠ¢ Eq (iInf fun r => (Ï.IicSnd â†‘â†‘r) s) ((Ï.IicSnd â†‘t) s)","decl":"theorem iInf_IicSnd_gt (t : â„š) {s : Set Î±} (hs : MeasurableSet s) [IsFiniteMeasure Ï] :\n    â¨… r : { r' : â„š // t < r' }, Ï.IicSnd r s = Ï.IicSnd t s := by\n  simp_rw [Ï.IicSnd_apply _ hs, Measure.iInf_rat_gt_prod_Iic hs]\n\n"}
{"name":"MeasureTheory.Measure.tendsto_IicSnd_atTop","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\ns : Set Î±\nhs : MeasurableSet s\nâŠ¢ Filter.Tendsto (fun r => (Ï.IicSnd â†‘r) s) Filter.atTop (nhds (Ï.fst s))","decl":"theorem tendsto_IicSnd_atTop {s : Set Î±} (hs : MeasurableSet s) :\n    Tendsto (fun r : â„š â†¦ Ï.IicSnd r s) atTop (ğ“ (Ï.fst s)) := by\n  simp_rw [Ï.IicSnd_apply _ hs, fst_apply hs, â† prod_univ]\n  rw [â† Real.iUnion_Iic_rat, prod_iUnion]\n  apply tendsto_measure_iUnion_atTop\n  exact monotone_const.set_prod Rat.cast_mono.Iic\n\n"}
{"name":"MeasureTheory.Measure.tendsto_IicSnd_atBot","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\ninstâœ : MeasureTheory.IsFiniteMeasure Ï\ns : Set Î±\nhs : MeasurableSet s\nâŠ¢ Filter.Tendsto (fun r => (Ï.IicSnd â†‘r) s) Filter.atBot (nhds 0)","decl":"theorem tendsto_IicSnd_atBot [IsFiniteMeasure Ï] {s : Set Î±} (hs : MeasurableSet s) :\n    Tendsto (fun r : â„š â†¦ Ï.IicSnd r s) atBot (ğ“ 0) := by\n  simp_rw [Ï.IicSnd_apply _ hs]\n  have h_empty : Ï (s Ã—Ë¢ âˆ…) = 0 := by simp only [prod_empty, measure_empty]\n  rw [â† h_empty, â† Real.iInter_Iic_rat, prod_iInter]\n  suffices h_neg :\n      Tendsto (fun r : â„š â†¦ Ï (s Ã—Ë¢ Iic â†‘(-r))) atTop (ğ“ (Ï (â‹‚ r : â„š, s Ã—Ë¢ Iic â†‘(-r)))) by\n    have h_inter_eq : â‹‚ r : â„š, s Ã—Ë¢ Iic â†‘(-r) = â‹‚ r : â„š, s Ã—Ë¢ Iic (r : â„) := by\n      ext1 x\n      simp only [Rat.cast_eq_id, id, mem_iInter, mem_prod, mem_Iic]\n      refine âŸ¨fun h i â†¦ âŸ¨(h i).1, ?_âŸ©, fun h i â†¦ âŸ¨(h i).1, ?_âŸ©âŸ© <;> have h' := h (-i)\n      Â· rw [neg_neg] at h'; exact h'.2\n      Â· exact h'.2\n    rw [h_inter_eq] at h_neg\n    have h_fun_eq : (fun r : â„š â†¦ Ï (s Ã—Ë¢ Iic (r : â„))) = fun r : â„š â†¦ Ï (s Ã—Ë¢ Iic â†‘(- -r)) := by\n      simp_rw [neg_neg]\n    rw [h_fun_eq]\n    exact h_neg.comp tendsto_neg_atBot_atTop\n  refine tendsto_measure_iInter_atTop (fun q â†¦ (hs.prod measurableSet_Iic).nullMeasurableSet)\n    ?_ âŸ¨0, measure_ne_top Ï _âŸ©\n  refine fun q r hqr â†¦ Set.prod_mono subset_rfl fun x hx â†¦ ?_\n  simp only [Rat.cast_neg, mem_Iic] at hx âŠ¢\n  refine hx.trans (neg_le_neg ?_)\n  exact mod_cast hqr\n\n"}
{"name":"ProbabilityTheory.measurable_preCDF","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\nr : Rat\nâŠ¢ Measurable (ProbabilityTheory.preCDF Ï r)","decl":"theorem measurable_preCDF {Ï : Measure (Î± Ã— â„)} {r : â„š} : Measurable (preCDF Ï r) :=\n  Measure.measurable_rnDeriv _ _\n\n"}
{"name":"ProbabilityTheory.measurable_preCDF'","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\nâŠ¢ Measurable fun a r => (ProbabilityTheory.preCDF Ï r a).toReal","decl":"lemma measurable_preCDF' {Ï : Measure (Î± Ã— â„)} :\n    Measurable fun a r â†¦ (preCDF Ï r a).toReal := by\n  rw [measurable_pi_iff]\n  exact fun _ â†¦ measurable_preCDF.ennreal_toReal\n\n"}
{"name":"ProbabilityTheory.withDensity_preCDF","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\nr : Rat\ninstâœ : MeasureTheory.IsFiniteMeasure Ï\nâŠ¢ Eq (Ï.fst.withDensity (ProbabilityTheory.preCDF Ï r)) (Ï.IicSnd â†‘r)","decl":"theorem withDensity_preCDF (Ï : Measure (Î± Ã— â„)) (r : â„š) [IsFiniteMeasure Ï] :\n    Ï.fst.withDensity (preCDF Ï r) = Ï.IicSnd r :=\n  Measure.absolutelyContinuous_iff_withDensity_rnDeriv_eq.mp (Measure.IicSnd_ac_fst Ï r)\n\n"}
{"name":"ProbabilityTheory.setLIntegral_preCDF_fst","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\nr : Rat\ns : Set Î±\nhs : MeasurableSet s\ninstâœ : MeasureTheory.IsFiniteMeasure Ï\nâŠ¢ Eq (MeasureTheory.lintegral (Ï.fst.restrict s) fun x => ProbabilityTheory.preCDF Ï r x) ((Ï.IicSnd â†‘r) s)","decl":"theorem setLIntegral_preCDF_fst (Ï : Measure (Î± Ã— â„)) (r : â„š) {s : Set Î±} (hs : MeasurableSet s)\n    [IsFiniteMeasure Ï] : âˆ«â» x in s, preCDF Ï r x âˆ‚Ï.fst = Ï.IicSnd r s := by\n  have : âˆ€ r, âˆ«â» x in s, preCDF Ï r x âˆ‚Ï.fst = âˆ«â» x in s, (preCDF Ï r * 1) x âˆ‚Ï.fst := by\n    simp only [mul_one, eq_self_iff_true, forall_const]\n  rw [this, â† setLIntegral_withDensity_eq_setLIntegral_mul _ measurable_preCDF _ hs]\n  Â· simp only [withDensity_preCDF Ï r, Pi.one_apply, lintegral_one, Measure.restrict_apply,\n      MeasurableSet.univ, univ_inter]\n  Â· rw [(_ : (1 : Î± â†’ â„â‰¥0âˆ) = fun _ â†¦ 1)]\n    exacts [measurable_const, rfl]\n\n"}
{"name":"ProbabilityTheory.lintegral_preCDF_fst","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\nr : Rat\ninstâœ : MeasureTheory.IsFiniteMeasure Ï\nâŠ¢ Eq (MeasureTheory.lintegral Ï.fst fun x => ProbabilityTheory.preCDF Ï r x) ((Ï.IicSnd â†‘r) Set.univ)","decl":"lemma lintegral_preCDF_fst (Ï : Measure (Î± Ã— â„)) (r : â„š) [IsFiniteMeasure Ï] :\n    âˆ«â» x, preCDF Ï r x âˆ‚Ï.fst = Ï.IicSnd r univ := by\n  rw [â† setLIntegral_univ, setLIntegral_preCDF_fst Ï r MeasurableSet.univ]\n\n"}
{"name":"ProbabilityTheory.monotone_preCDF","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\ninstâœ : MeasureTheory.IsFiniteMeasure Ï\nâŠ¢ Filter.Eventually (fun a => Monotone fun r => ProbabilityTheory.preCDF Ï r a) (MeasureTheory.ae Ï.fst)","decl":"theorem monotone_preCDF (Ï : Measure (Î± Ã— â„)) [IsFiniteMeasure Ï] :\n    âˆ€áµ a âˆ‚Ï.fst, Monotone fun r â†¦ preCDF Ï r a := by\n  simp_rw [Monotone, ae_all_iff]\n  refine fun r r' hrr' â†¦ ae_le_of_forall_setLIntegral_le_of_sigmaFinite measurable_preCDF\n    fun s hs _ â†¦ ?_\n  rw [setLIntegral_preCDF_fst Ï r hs, setLIntegral_preCDF_fst Ï r' hs]\n  exact Measure.IicSnd_mono Ï (mod_cast hrr') s\n\n"}
{"name":"ProbabilityTheory.preCDF_le_one","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\ninstâœ : MeasureTheory.IsFiniteMeasure Ï\nâŠ¢ Filter.Eventually (fun a => âˆ€ (r : Rat), LE.le (ProbabilityTheory.preCDF Ï r a) 1) (MeasureTheory.ae Ï.fst)","decl":"theorem preCDF_le_one (Ï : Measure (Î± Ã— â„)) [IsFiniteMeasure Ï] :\n    âˆ€áµ a âˆ‚Ï.fst, âˆ€ r, preCDF Ï r a â‰¤ 1 := by\n  rw [ae_all_iff]\n  refine fun r â†¦ ae_le_of_forall_setLIntegral_le_of_sigmaFinite measurable_preCDF fun s hs _ â†¦ ?_\n  rw [setLIntegral_preCDF_fst Ï r hs]\n  simp only [Pi.one_apply, lintegral_one, Measure.restrict_apply, MeasurableSet.univ, univ_inter]\n  exact Measure.IicSnd_le_fst Ï r s\n\n"}
{"name":"ProbabilityTheory.setIntegral_preCDF_fst","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\nr : Rat\ns : Set Î±\nhs : MeasurableSet s\ninstâœ : MeasureTheory.IsFiniteMeasure Ï\nâŠ¢ Eq (MeasureTheory.integral (Ï.fst.restrict s) fun x => (ProbabilityTheory.preCDF Ï r x).toReal) ((Ï.IicSnd â†‘r) s).toReal","decl":"lemma setIntegral_preCDF_fst (Ï : Measure (Î± Ã— â„)) (r : â„š) {s : Set Î±} (hs : MeasurableSet s)\n    [IsFiniteMeasure Ï] :\n    âˆ« x in s, (preCDF Ï r x).toReal âˆ‚Ï.fst = (Ï.IicSnd r s).toReal := by\n  rw [integral_toReal]\n  Â· rw [setLIntegral_preCDF_fst _ _ hs]\n  Â· exact measurable_preCDF.aemeasurable\n  Â· refine ae_restrict_of_ae ?_\n    filter_upwards [preCDF_le_one Ï] with a ha\n    exact (ha r).trans_lt ENNReal.one_lt_top\n\n"}
{"name":"ProbabilityTheory.integral_preCDF_fst","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\nr : Rat\ninstâœ : MeasureTheory.IsFiniteMeasure Ï\nâŠ¢ Eq (MeasureTheory.integral Ï.fst fun x => (ProbabilityTheory.preCDF Ï r x).toReal) ((Ï.IicSnd â†‘r) Set.univ).toReal","decl":"lemma integral_preCDF_fst (Ï : Measure (Î± Ã— â„)) (r : â„š) [IsFiniteMeasure Ï] :\n    âˆ« x, (preCDF Ï r x).toReal âˆ‚Ï.fst = (Ï.IicSnd r univ).toReal := by\n  rw [â† setIntegral_univ, setIntegral_preCDF_fst Ï _ MeasurableSet.univ]\n\n"}
{"name":"ProbabilityTheory.integrable_preCDF","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\ninstâœ : MeasureTheory.IsFiniteMeasure Ï\nx : Rat\nâŠ¢ MeasureTheory.Integrable (fun a => (ProbabilityTheory.preCDF Ï x a).toReal) Ï.fst","decl":"lemma integrable_preCDF (Ï : Measure (Î± Ã— â„)) [IsFiniteMeasure Ï] (x : â„š) :\n    Integrable (fun a â†¦ (preCDF Ï x a).toReal) Ï.fst := by\n  refine integrable_of_forall_fin_meas_le _ (measure_lt_top Ï.fst univ) ?_ fun t _ _ â†¦ ?_\n  Â· exact measurable_preCDF.ennreal_toReal.aestronglyMeasurable\n  Â· simp_rw [â† ofReal_norm_eq_enorm, Real.norm_of_nonneg ENNReal.toReal_nonneg]\n    rw [â† lintegral_one]\n    refine (setLIntegral_le_lintegral _ _).trans (lintegral_mono_ae ?_)\n    filter_upwards [preCDF_le_one Ï] with a ha using ENNReal.ofReal_toReal_le.trans (ha _)\n\n"}
{"name":"ProbabilityTheory.isRatCondKernelCDFAux_preCDF","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\ninstâœ : MeasureTheory.IsFiniteMeasure Ï\nâŠ¢ ProbabilityTheory.IsRatCondKernelCDFAux (fun p r => (ProbabilityTheory.preCDF Ï r p.2).toReal) (ProbabilityTheory.Kernel.const Unit Ï) (ProbabilityTheory.Kernel.const Unit Ï.fst)","decl":"lemma isRatCondKernelCDFAux_preCDF (Ï : Measure (Î± Ã— â„)) [IsFiniteMeasure Ï] :\n    IsRatCondKernelCDFAux (fun p r â†¦ (preCDF Ï r p.2).toReal)\n      (Kernel.const Unit Ï) (Kernel.const Unit Ï.fst) where\n  measurable := measurable_preCDF'.comp measurable_snd\n  mono' a r r' hrr' := by\n    filter_upwards [monotone_preCDF Ï, preCDF_le_one Ï] with a hâ‚ hâ‚‚\n    exact ENNReal.toReal_mono ((hâ‚‚ _).trans_lt ENNReal.one_lt_top).ne (hâ‚ hrr')\n  nonneg' _ q := by simp\n  le_one' a q := by\n    simp only [Kernel.const_apply, forall_const]\n    filter_upwards [preCDF_le_one Ï] with a ha\n    refine ENNReal.toReal_le_of_le_ofReal zero_le_one ?_\n    simp [ha]\n  tendsto_integral_of_antitone a s _ hs_tendsto := by\n    simp_rw [Kernel.const_apply, integral_preCDF_fst Ï]\n    have h := Ï.tendsto_IicSnd_atBot MeasurableSet.univ\n    rw [â† ENNReal.zero_toReal]\n    have h0 : Tendsto ENNReal.toReal (ğ“ 0) (ğ“ 0) :=\n      ENNReal.continuousAt_toReal ENNReal.zero_ne_top\n    exact h0.comp (h.comp hs_tendsto)\n  tendsto_integral_of_monotone a s _ hs_tendsto := by\n    simp_rw [Kernel.const_apply, integral_preCDF_fst Ï]\n    have h := Ï.tendsto_IicSnd_atTop MeasurableSet.univ\n    have h0 : Tendsto ENNReal.toReal (ğ“ (Ï.fst univ)) (ğ“ (Ï.fst univ).toReal) :=\n      ENNReal.continuousAt_toReal (measure_ne_top _ _)\n    exact h0.comp (h.comp hs_tendsto)\n  integrable _ q := integrable_preCDF Ï q\n  setIntegral a s hs q := by rw [Kernel.const_apply, Kernel.const_apply,\n    setIntegral_preCDF_fst _ _ hs, Measure.IicSnd_apply _ _ hs]\n\n"}
{"name":"ProbabilityTheory.isRatCondKernelCDF_preCDF","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\ninstâœ : MeasureTheory.IsFiniteMeasure Ï\nâŠ¢ ProbabilityTheory.IsRatCondKernelCDF (fun p r => (ProbabilityTheory.preCDF Ï r p.2).toReal) (ProbabilityTheory.Kernel.const Unit Ï) (ProbabilityTheory.Kernel.const Unit Ï.fst)","decl":"lemma isRatCondKernelCDF_preCDF (Ï : Measure (Î± Ã— â„)) [IsFiniteMeasure Ï] :\n    IsRatCondKernelCDF (fun p r â†¦ (preCDF Ï r p.2).toReal)\n      (Kernel.const Unit Ï) (Kernel.const Unit Ï.fst) :=\n  (isRatCondKernelCDFAux_preCDF Ï).isRatCondKernelCDF\n\n"}
{"name":"ProbabilityTheory.condCDF_eq_stieltjesOfMeasurableRat_unit_prod","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\na : Î±\nâŠ¢ Eq (ProbabilityTheory.condCDF Ï a) (ProbabilityTheory.stieltjesOfMeasurableRat (fun p r => (ProbabilityTheory.preCDF Ï r p.2).toReal) â‹¯ { fst := Unit.unit, snd := a })","decl":"lemma condCDF_eq_stieltjesOfMeasurableRat_unit_prod (Ï : Measure (Î± Ã— â„)) (a : Î±) :\n    condCDF Ï a = stieltjesOfMeasurableRat (fun (p : Unit Ã— Î±) r â†¦ (preCDF Ï r p.2).toReal)\n      (measurable_preCDF'.comp measurable_snd) ((), a) := by\n  ext x\n  rw [condCDF, â† stieltjesOfMeasurableRat_unit_prod]\n\n"}
{"name":"ProbabilityTheory.isCondKernelCDF_condCDF","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\ninstâœ : MeasureTheory.IsFiniteMeasure Ï\nâŠ¢ ProbabilityTheory.IsCondKernelCDF (fun p => ProbabilityTheory.condCDF Ï p.2) (ProbabilityTheory.Kernel.const Unit Ï) (ProbabilityTheory.Kernel.const Unit Ï.fst)","decl":"lemma isCondKernelCDF_condCDF (Ï : Measure (Î± Ã— â„)) [IsFiniteMeasure Ï] :\n    IsCondKernelCDF (fun p : Unit Ã— Î± â†¦ condCDF Ï p.2) (Kernel.const Unit Ï)\n      (Kernel.const Unit Ï.fst) := by\n  simp_rw [condCDF_eq_stieltjesOfMeasurableRat_unit_prod Ï]\n  exact isCondKernelCDF_stieltjesOfMeasurableRat (isRatCondKernelCDF_preCDF Ï)\n\n"}
{"name":"ProbabilityTheory.condCDF_nonneg","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\na : Î±\nr : Real\nâŠ¢ LE.le 0 (â†‘(ProbabilityTheory.condCDF Ï a) r)","decl":"/-- The conditional cdf is non-negative for all `a : Î±`. -/\ntheorem condCDF_nonneg (Ï : Measure (Î± Ã— â„)) (a : Î±) (r : â„) : 0 â‰¤ condCDF Ï a r :=\n  stieltjesOfMeasurableRat_nonneg _ a r\n\n"}
{"name":"ProbabilityTheory.condCDF_le_one","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\na : Î±\nx : Real\nâŠ¢ LE.le (â†‘(ProbabilityTheory.condCDF Ï a) x) 1","decl":"/-- The conditional cdf is lower or equal to 1 for all `a : Î±`. -/\ntheorem condCDF_le_one (Ï : Measure (Î± Ã— â„)) (a : Î±) (x : â„) : condCDF Ï a x â‰¤ 1 :=\n  stieltjesOfMeasurableRat_le_one _ _ _\n\n"}
{"name":"ProbabilityTheory.tendsto_condCDF_atBot","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\na : Î±\nâŠ¢ Filter.Tendsto (â†‘(ProbabilityTheory.condCDF Ï a)) Filter.atBot (nhds 0)","decl":"/-- The conditional cdf tends to 0 at -âˆ for all `a : Î±`. -/\ntheorem tendsto_condCDF_atBot (Ï : Measure (Î± Ã— â„)) (a : Î±) :\n    Tendsto (condCDF Ï a) atBot (ğ“ 0) := tendsto_stieltjesOfMeasurableRat_atBot _ _\n\n"}
{"name":"ProbabilityTheory.tendsto_condCDF_atTop","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\na : Î±\nâŠ¢ Filter.Tendsto (â†‘(ProbabilityTheory.condCDF Ï a)) Filter.atTop (nhds 1)","decl":"/-- The conditional cdf tends to 1 at +âˆ for all `a : Î±`. -/\ntheorem tendsto_condCDF_atTop (Ï : Measure (Î± Ã— â„)) (a : Î±) :\n    Tendsto (condCDF Ï a) atTop (ğ“ 1) := tendsto_stieltjesOfMeasurableRat_atTop _ _\n\n"}
{"name":"ProbabilityTheory.condCDF_ae_eq","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\ninstâœ : MeasureTheory.IsFiniteMeasure Ï\nr : Rat\nâŠ¢ (MeasureTheory.ae Ï.fst).EventuallyEq (fun a => â†‘(ProbabilityTheory.condCDF Ï a) â†‘r) fun a => (ProbabilityTheory.preCDF Ï r a).toReal","decl":"theorem condCDF_ae_eq (Ï : Measure (Î± Ã— â„)) [IsFiniteMeasure Ï] (r : â„š) :\n    (fun a â†¦ condCDF Ï a r) =áµ[Ï.fst] fun a â†¦ (preCDF Ï r a).toReal := by\n  simp_rw [condCDF_eq_stieltjesOfMeasurableRat_unit_prod Ï]\n  exact stieltjesOfMeasurableRat_ae_eq (isRatCondKernelCDF_preCDF Ï) () r\n\n"}
{"name":"ProbabilityTheory.ofReal_condCDF_ae_eq","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\ninstâœ : MeasureTheory.IsFiniteMeasure Ï\nr : Rat\nâŠ¢ (MeasureTheory.ae Ï.fst).EventuallyEq (fun a => ENNReal.ofReal (â†‘(ProbabilityTheory.condCDF Ï a) â†‘r)) (ProbabilityTheory.preCDF Ï r)","decl":"theorem ofReal_condCDF_ae_eq (Ï : Measure (Î± Ã— â„)) [IsFiniteMeasure Ï] (r : â„š) :\n    (fun a â†¦ ENNReal.ofReal (condCDF Ï a r)) =áµ[Ï.fst] preCDF Ï r := by\n  filter_upwards [condCDF_ae_eq Ï r, preCDF_le_one Ï] with a ha ha_le_one\n  rw [ha, ENNReal.ofReal_toReal]\n  exact ((ha_le_one r).trans_lt ENNReal.one_lt_top).ne\n\n"}
{"name":"ProbabilityTheory.measurable_condCDF","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\nx : Real\nâŠ¢ Measurable fun a => â†‘(ProbabilityTheory.condCDF Ï a) x","decl":"/-- The conditional cdf is a measurable function of `a : Î±` for all `x : â„`. -/\ntheorem measurable_condCDF (Ï : Measure (Î± Ã— â„)) (x : â„) : Measurable fun a â†¦ condCDF Ï a x :=\n  measurable_stieltjesOfMeasurableRat _ _\n\n"}
{"name":"ProbabilityTheory.stronglyMeasurable_condCDF","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\nx : Real\nâŠ¢ MeasureTheory.StronglyMeasurable fun a => â†‘(ProbabilityTheory.condCDF Ï a) x","decl":"/-- The conditional cdf is a strongly measurable function of `a : Î±` for all `x : â„`. -/\ntheorem stronglyMeasurable_condCDF (Ï : Measure (Î± Ã— â„)) (x : â„) :\n    StronglyMeasurable fun a â†¦ condCDF Ï a x := stronglyMeasurable_stieltjesOfMeasurableRat _ _\n\n"}
{"name":"ProbabilityTheory.setLIntegral_condCDF","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\ninstâœ : MeasureTheory.IsFiniteMeasure Ï\nx : Real\ns : Set Î±\nhs : MeasurableSet s\nâŠ¢ Eq (MeasureTheory.lintegral (Ï.fst.restrict s) fun a => ENNReal.ofReal (â†‘(ProbabilityTheory.condCDF Ï a) x)) (Ï (SProd.sprod s (Set.Iic x)))","decl":"theorem setLIntegral_condCDF (Ï : Measure (Î± Ã— â„)) [IsFiniteMeasure Ï] (x : â„) {s : Set Î±}\n    (hs : MeasurableSet s) :\n    âˆ«â» a in s, ENNReal.ofReal (condCDF Ï a x) âˆ‚Ï.fst = Ï (s Ã—Ë¢ Iic x) :=\n  (isCondKernelCDF_condCDF Ï).setLIntegral () hs x\n\n"}
{"name":"ProbabilityTheory.lintegral_condCDF","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\ninstâœ : MeasureTheory.IsFiniteMeasure Ï\nx : Real\nâŠ¢ Eq (MeasureTheory.lintegral Ï.fst fun a => ENNReal.ofReal (â†‘(ProbabilityTheory.condCDF Ï a) x)) (Ï (SProd.sprod Set.univ (Set.Iic x)))","decl":"theorem lintegral_condCDF (Ï : Measure (Î± Ã— â„)) [IsFiniteMeasure Ï] (x : â„) :\n    âˆ«â» a, ENNReal.ofReal (condCDF Ï a x) âˆ‚Ï.fst = Ï (univ Ã—Ë¢ Iic x) :=\n  (isCondKernelCDF_condCDF Ï).lintegral () x\n\n"}
{"name":"ProbabilityTheory.integrable_condCDF","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\ninstâœ : MeasureTheory.IsFiniteMeasure Ï\nx : Real\nâŠ¢ MeasureTheory.Integrable (fun a => â†‘(ProbabilityTheory.condCDF Ï a) x) Ï.fst","decl":"theorem integrable_condCDF (Ï : Measure (Î± Ã— â„)) [IsFiniteMeasure Ï] (x : â„) :\n    Integrable (fun a â†¦ condCDF Ï a x) Ï.fst :=\n  (isCondKernelCDF_condCDF Ï).integrable () x\n\n"}
{"name":"ProbabilityTheory.setIntegral_condCDF","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\ninstâœ : MeasureTheory.IsFiniteMeasure Ï\nx : Real\ns : Set Î±\nhs : MeasurableSet s\nâŠ¢ Eq (MeasureTheory.integral (Ï.fst.restrict s) fun a => â†‘(ProbabilityTheory.condCDF Ï a) x) (Ï (SProd.sprod s (Set.Iic x))).toReal","decl":"theorem setIntegral_condCDF (Ï : Measure (Î± Ã— â„)) [IsFiniteMeasure Ï] (x : â„) {s : Set Î±}\n    (hs : MeasurableSet s) : âˆ« a in s, condCDF Ï a x âˆ‚Ï.fst = (Ï (s Ã—Ë¢ Iic x)).toReal :=\n  (isCondKernelCDF_condCDF Ï).setIntegral () hs x\n\n"}
{"name":"ProbabilityTheory.integral_condCDF","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\ninstâœ : MeasureTheory.IsFiniteMeasure Ï\nx : Real\nâŠ¢ Eq (MeasureTheory.integral Ï.fst fun a => â†‘(ProbabilityTheory.condCDF Ï a) x) (Ï (SProd.sprod Set.univ (Set.Iic x))).toReal","decl":"theorem integral_condCDF (Ï : Measure (Î± Ã— â„)) [IsFiniteMeasure Ï] (x : â„) :\n    âˆ« a, condCDF Ï a x âˆ‚Ï.fst = (Ï (univ Ã—Ë¢ Iic x)).toReal :=\n  (isCondKernelCDF_condCDF Ï).integral () x\n\n"}
{"name":"ProbabilityTheory.measure_condCDF_Iic","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\na : Î±\nx : Real\nâŠ¢ Eq ((ProbabilityTheory.condCDF Ï a).measure (Set.Iic x)) (ENNReal.ofReal (â†‘(ProbabilityTheory.condCDF Ï a) x))","decl":"theorem measure_condCDF_Iic (Ï : Measure (Î± Ã— â„)) (a : Î±) (x : â„) :\n    (condCDF Ï a).measure (Iic x) = ENNReal.ofReal (condCDF Ï a x) := by\n  rw [â† sub_zero (condCDF Ï a x)]\n  exact (condCDF Ï a).measure_Iic (tendsto_condCDF_atBot Ï a) _\n\n"}
{"name":"ProbabilityTheory.measure_condCDF_univ","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\na : Î±\nâŠ¢ Eq ((ProbabilityTheory.condCDF Ï a).measure Set.univ) 1","decl":"theorem measure_condCDF_univ (Ï : Measure (Î± Ã— â„)) (a : Î±) : (condCDF Ï a).measure univ = 1 := by\n  rw [â† ENNReal.ofReal_one, â† sub_zero (1 : â„)]\n  exact StieltjesFunction.measure_univ _ (tendsto_condCDF_atBot Ï a) (tendsto_condCDF_atTop Ï a)\n\n"}
{"name":"ProbabilityTheory.instIsProbabilityMeasureCondCDF","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\na : Î±\nâŠ¢ MeasureTheory.IsProbabilityMeasure (ProbabilityTheory.condCDF Ï a).measure","decl":"instance instIsProbabilityMeasureCondCDF (Ï : Measure (Î± Ã— â„)) (a : Î±) :\n    IsProbabilityMeasure (condCDF Ï a).measure :=\n  âŸ¨measure_condCDF_univ Ï aâŸ©\n\n"}
{"name":"ProbabilityTheory.measurable_measure_condCDF","module":"Mathlib.Probability.Kernel.Disintegration.CondCDF","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÏ : MeasureTheory.Measure (Prod Î± Real)\nâŠ¢ Measurable fun a => (ProbabilityTheory.condCDF Ï a).measure","decl":"/-- The function `a â†¦ (condCDF Ï a).measure` is measurable. -/\ntheorem measurable_measure_condCDF (Ï : Measure (Î± Ã— â„)) :\n    Measurable fun a => (condCDF Ï a).measure :=\n  .measure_of_isPiSystem_of_isProbabilityMeasure (borel_eq_generateFrom_Iic â„) isPiSystem_Iic <| by\n    simp_rw [forall_mem_range, measure_condCDF_Iic]\n    exact fun u â†¦ (measurable_condCDF Ï u).ennreal_ofReal\n\n"}
