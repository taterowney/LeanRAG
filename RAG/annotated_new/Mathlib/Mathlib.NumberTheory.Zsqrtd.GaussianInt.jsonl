{"name":"GaussianInt.toComplex_def","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"x : GaussianInt\n⊢ Eq (GaussianInt.toComplex x) (HAdd.hAdd (↑x.re) (HMul.hMul (↑x.im) Complex.I))","decl":"theorem toComplex_def (x : ℤ[i]) : (x : ℂ) = x.re + x.im * I :=\n  rfl\n\n"}
{"name":"GaussianInt.toComplex_def'","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"x y : Int\n⊢ Eq (GaussianInt.toComplex { re := x, im := y }) (HAdd.hAdd (↑x) (HMul.hMul (↑y) Complex.I))","decl":"theorem toComplex_def' (x y : ℤ) : ((⟨x, y⟩ : ℤ[i]) : ℂ) = x + y * I := by simp [toComplex_def]\n\n"}
{"name":"GaussianInt.toComplex_def₂","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"x : GaussianInt\n⊢ Eq (GaussianInt.toComplex x) { re := ↑x.re, im := ↑x.im }","decl":"theorem toComplex_def₂ (x : ℤ[i]) : (x : ℂ) = ⟨x.re, x.im⟩ := by\n  apply Complex.ext <;> simp [toComplex_def]\n\n"}
{"name":"GaussianInt.to_real_re","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"x : GaussianInt\n⊢ Eq (↑x.re) (GaussianInt.toComplex x).re","decl":"@[simp]\ntheorem to_real_re (x : ℤ[i]) : ((x.re : ℤ) : ℝ) = (x : ℂ).re := by simp [toComplex_def]\n\n"}
{"name":"GaussianInt.to_real_im","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"x : GaussianInt\n⊢ Eq (↑x.im) (GaussianInt.toComplex x).im","decl":"@[simp]\ntheorem to_real_im (x : ℤ[i]) : ((x.im : ℤ) : ℝ) = (x : ℂ).im := by simp [toComplex_def]\n\n"}
{"name":"GaussianInt.toComplex_re","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"x y : Int\n⊢ Eq (GaussianInt.toComplex { re := x, im := y }).re ↑x","decl":"@[simp]\ntheorem toComplex_re (x y : ℤ) : ((⟨x, y⟩ : ℤ[i]) : ℂ).re = x := by simp [toComplex_def]\n\n"}
{"name":"GaussianInt.toComplex_im","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"x y : Int\n⊢ Eq (GaussianInt.toComplex { re := x, im := y }).im ↑y","decl":"@[simp]\ntheorem toComplex_im (x y : ℤ) : ((⟨x, y⟩ : ℤ[i]) : ℂ).im = y := by simp [toComplex_def]\n\n"}
{"name":"GaussianInt.toComplex_add","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"x y : GaussianInt\n⊢ Eq (GaussianInt.toComplex (HAdd.hAdd x y)) (HAdd.hAdd (GaussianInt.toComplex x) (GaussianInt.toComplex y))","decl":"theorem toComplex_add (x y : ℤ[i]) : ((x + y : ℤ[i]) : ℂ) = x + y :=\n  toComplex.map_add _ _\n\n"}
{"name":"GaussianInt.toComplex_mul","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"x y : GaussianInt\n⊢ Eq (GaussianInt.toComplex (HMul.hMul x y)) (HMul.hMul (GaussianInt.toComplex x) (GaussianInt.toComplex y))","decl":"theorem toComplex_mul (x y : ℤ[i]) : ((x * y : ℤ[i]) : ℂ) = x * y :=\n  toComplex.map_mul _ _\n\n"}
{"name":"GaussianInt.toComplex_one","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"⊢ Eq (GaussianInt.toComplex 1) 1","decl":"theorem toComplex_one : ((1 : ℤ[i]) : ℂ) = 1 :=\n  toComplex.map_one\n\n"}
{"name":"GaussianInt.toComplex_zero","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"⊢ Eq (GaussianInt.toComplex 0) 0","decl":"theorem toComplex_zero : ((0 : ℤ[i]) : ℂ) = 0 :=\n  toComplex.map_zero\n\n"}
{"name":"GaussianInt.toComplex_neg","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"x : GaussianInt\n⊢ Eq (GaussianInt.toComplex (Neg.neg x)) (Neg.neg (GaussianInt.toComplex x))","decl":"theorem toComplex_neg (x : ℤ[i]) : ((-x : ℤ[i]) : ℂ) = -x :=\n  toComplex.map_neg _\n\n"}
{"name":"GaussianInt.toComplex_sub","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"x y : GaussianInt\n⊢ Eq (GaussianInt.toComplex (HSub.hSub x y)) (HSub.hSub (GaussianInt.toComplex x) (GaussianInt.toComplex y))","decl":"theorem toComplex_sub (x y : ℤ[i]) : ((x - y : ℤ[i]) : ℂ) = x - y :=\n  toComplex.map_sub _ _\n\n"}
{"name":"GaussianInt.toComplex_star","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"x : GaussianInt\n⊢ Eq (GaussianInt.toComplex (Star.star x)) ((starRingEnd Complex) (GaussianInt.toComplex x))","decl":"@[simp]\ntheorem toComplex_star (x : ℤ[i]) : ((star x : ℤ[i]) : ℂ) = conj (x : ℂ) := by\n  rw [toComplex_def₂, toComplex_def₂]\n  exact congr_arg₂ _ rfl (Int.cast_neg _)\n\n"}
{"name":"GaussianInt.toComplex_inj","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"x y : GaussianInt\n⊢ Iff (Eq (GaussianInt.toComplex x) (GaussianInt.toComplex y)) (Eq x y)","decl":"@[simp]\ntheorem toComplex_inj {x y : ℤ[i]} : (x : ℂ) = y ↔ x = y := by\n  cases x; cases y; simp [toComplex_def₂]\n\n"}
{"name":"GaussianInt.toComplex_injective","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"⊢ Function.Injective ⇑GaussianInt.toComplex","decl":"lemma toComplex_injective : Function.Injective GaussianInt.toComplex :=\n  fun ⦃_ _⦄ ↦ toComplex_inj.mp\n\n"}
{"name":"GaussianInt.toComplex_eq_zero","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"x : GaussianInt\n⊢ Iff (Eq (GaussianInt.toComplex x) 0) (Eq x 0)","decl":"@[simp]\ntheorem toComplex_eq_zero {x : ℤ[i]} : (x : ℂ) = 0 ↔ x = 0 := by\n  rw [← toComplex_zero, toComplex_inj]\n\n"}
{"name":"GaussianInt.intCast_real_norm","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"x : GaussianInt\n⊢ Eq (↑(Zsqrtd.norm x)) (Complex.normSq (GaussianInt.toComplex x))","decl":"@[simp]\ntheorem intCast_real_norm (x : ℤ[i]) : (x.norm : ℝ) = Complex.normSq (x : ℂ) := by\n  rw [Zsqrtd.norm, normSq]; simp\n\n"}
{"name":"GaussianInt.intCast_complex_norm","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"x : GaussianInt\n⊢ Eq ↑(Zsqrtd.norm x) ↑(Complex.normSq (GaussianInt.toComplex x))","decl":"@[simp]\ntheorem intCast_complex_norm (x : ℤ[i]) : (x.norm : ℂ) = Complex.normSq (x : ℂ) := by\n  cases x; rw [Zsqrtd.norm, normSq]; simp\n\n"}
{"name":"GaussianInt.norm_nonneg","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"x : GaussianInt\n⊢ LE.le 0 (Zsqrtd.norm x)","decl":"theorem norm_nonneg (x : ℤ[i]) : 0 ≤ norm x :=\n  Zsqrtd.norm_nonneg (by norm_num) _\n\n"}
{"name":"GaussianInt.norm_eq_zero","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"x : GaussianInt\n⊢ Iff (Eq (Zsqrtd.norm x) 0) (Eq x 0)","decl":"@[simp]\ntheorem norm_eq_zero {x : ℤ[i]} : norm x = 0 ↔ x = 0 := by rw [← @Int.cast_inj ℝ _ _ _]; simp\n\n"}
{"name":"GaussianInt.norm_pos","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"x : GaussianInt\n⊢ Iff (LT.lt 0 (Zsqrtd.norm x)) (Ne x 0)","decl":"theorem norm_pos {x : ℤ[i]} : 0 < norm x ↔ x ≠ 0 := by\n  rw [lt_iff_le_and_ne, Ne, eq_comm, norm_eq_zero]; simp [norm_nonneg]\n\n"}
{"name":"GaussianInt.abs_natCast_norm","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"x : GaussianInt\n⊢ Eq (↑(Zsqrtd.norm x).natAbs) (Zsqrtd.norm x)","decl":"theorem abs_natCast_norm (x : ℤ[i]) : (x.norm.natAbs : ℤ) = x.norm :=\n  Int.natAbs_of_nonneg (norm_nonneg _)\n\n"}
{"name":"GaussianInt.natCast_natAbs_norm","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"α : Type u_1\ninst✝ : Ring α\nx : GaussianInt\n⊢ Eq ↑(Zsqrtd.norm x).natAbs ↑(Zsqrtd.norm x)","decl":"@[simp]\ntheorem natCast_natAbs_norm {α : Type*} [Ring α] (x : ℤ[i]) : (x.norm.natAbs : α) = x.norm := by\n  rw [← Int.cast_natCast, abs_natCast_norm]\n\n"}
{"name":"GaussianInt.natAbs_norm_eq","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"x : GaussianInt\n⊢ Eq (Zsqrtd.norm x).natAbs (HAdd.hAdd (HMul.hMul x.re.natAbs x.re.natAbs) (HMul.hMul x.im.natAbs x.im.natAbs))","decl":"theorem natAbs_norm_eq (x : ℤ[i]) :\n    x.norm.natAbs = x.re.natAbs * x.re.natAbs + x.im.natAbs * x.im.natAbs :=\n  Int.ofNat.inj <| by simp; simp [Zsqrtd.norm]\n\n"}
{"name":"GaussianInt.div_def","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"x y : GaussianInt\n⊢ Eq (HDiv.hDiv x y) { re := round (HDiv.hDiv ↑(HMul.hMul x (Star.star y)).re ↑(Zsqrtd.norm y)), im := round (HDiv.hDiv ↑(HMul.hMul x (Star.star y)).im ↑(Zsqrtd.norm y)) }","decl":"theorem div_def (x y : ℤ[i]) :\n    x / y = ⟨round ((x * star y).re / norm y : ℚ), round ((x * star y).im / norm y : ℚ)⟩ :=\n  show Zsqrtd.mk _ _ = _ by simp [div_eq_mul_inv]\n\n"}
{"name":"GaussianInt.toComplex_div_re","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"x y : GaussianInt\n⊢ Eq (GaussianInt.toComplex (HDiv.hDiv x y)).re ↑(round (HDiv.hDiv (GaussianInt.toComplex x) (GaussianInt.toComplex y)).re)","decl":"theorem toComplex_div_re (x y : ℤ[i]) : ((x / y : ℤ[i]) : ℂ).re = round (x / y : ℂ).re := by\n  rw [div_def, ← @Rat.round_cast ℝ _ _]\n  simp [-Rat.round_cast, mul_assoc, div_eq_mul_inv, mul_add, add_mul]\n\n"}
{"name":"GaussianInt.toComplex_div_im","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"x y : GaussianInt\n⊢ Eq (GaussianInt.toComplex (HDiv.hDiv x y)).im ↑(round (HDiv.hDiv (GaussianInt.toComplex x) (GaussianInt.toComplex y)).im)","decl":"theorem toComplex_div_im (x y : ℤ[i]) : ((x / y : ℤ[i]) : ℂ).im = round (x / y : ℂ).im := by\n  rw [div_def, ← @Rat.round_cast ℝ _ _, ← @Rat.round_cast ℝ _ _]\n  simp [-Rat.round_cast, mul_assoc, div_eq_mul_inv, mul_add, add_mul]\n\n"}
{"name":"GaussianInt.normSq_le_normSq_of_re_le_of_im_le","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"x y : Complex\nhre : LE.le (abs x.re) (abs y.re)\nhim : LE.le (abs x.im) (abs y.im)\n⊢ LE.le (Complex.normSq x) (Complex.normSq y)","decl":"theorem normSq_le_normSq_of_re_le_of_im_le {x y : ℂ} (hre : |x.re| ≤ |y.re|)\n    (him : |x.im| ≤ |y.im|) : Complex.normSq x ≤ Complex.normSq y := by\n  rw [normSq_apply, normSq_apply, ← _root_.abs_mul_self, _root_.abs_mul, ←\n      _root_.abs_mul_self y.re, _root_.abs_mul y.re, ← _root_.abs_mul_self x.im,\n      _root_.abs_mul x.im, ← _root_.abs_mul_self y.im, _root_.abs_mul y.im]\n  exact\n      add_le_add (mul_self_le_mul_self (abs_nonneg _) hre) (mul_self_le_mul_self (abs_nonneg _) him)\n\n"}
{"name":"GaussianInt.normSq_div_sub_div_lt_one","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"x y : GaussianInt\n⊢ LT.lt (Complex.normSq (HSub.hSub (HDiv.hDiv (GaussianInt.toComplex x) (GaussianInt.toComplex y)) (GaussianInt.toComplex (HDiv.hDiv x y)))) 1","decl":"theorem normSq_div_sub_div_lt_one (x y : ℤ[i]) :\n    Complex.normSq ((x / y : ℂ) - ((x / y : ℤ[i]) : ℂ)) < 1 :=\n  calc\n    Complex.normSq ((x / y : ℂ) - ((x / y : ℤ[i]) : ℂ))\n    _ = Complex.normSq\n      ((x / y : ℂ).re - ((x / y : ℤ[i]) : ℂ).re + ((x / y : ℂ).im - ((x / y : ℤ[i]) : ℂ).im) *\n        I : ℂ) :=\n      congr_arg _ <| by apply Complex.ext <;> simp\n    _ ≤ Complex.normSq (1 / 2 + 1 / 2 * I) := by\n      have : |(2⁻¹ : ℝ)| = 2⁻¹ := abs_of_nonneg (by norm_num)\n      exact normSq_le_normSq_of_re_le_of_im_le\n        (by rw [toComplex_div_re]; simp [normSq, this]; simpa using abs_sub_round (x / y : ℂ).re)\n        (by rw [toComplex_div_im]; simp [normSq, this]; simpa using abs_sub_round (x / y : ℂ).im)\n    _ < 1 := by simp [normSq]; norm_num\n\n"}
{"name":"GaussianInt.mod_def","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"x y : GaussianInt\n⊢ Eq (HMod.hMod x y) (HSub.hSub x (HMul.hMul y (HDiv.hDiv x y)))","decl":"theorem mod_def (x y : ℤ[i]) : x % y = x - y * (x / y) :=\n  rfl\n\n"}
{"name":"GaussianInt.norm_mod_lt","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"x y : GaussianInt\nhy : Ne y 0\n⊢ LT.lt (Zsqrtd.norm (HMod.hMod x y)) (Zsqrtd.norm y)","decl":"theorem norm_mod_lt (x : ℤ[i]) {y : ℤ[i]} (hy : y ≠ 0) : (x % y).norm < y.norm :=\n  have : (y : ℂ) ≠ 0 := by rwa [Ne, ← toComplex_zero, toComplex_inj]\n  (@Int.cast_lt ℝ _ _ _ _).1 <|\n    calc\n      ↑(Zsqrtd.norm (x % y)) = Complex.normSq (x - y * (x / y : ℤ[i]) : ℂ) := by simp [mod_def]\n      _ = Complex.normSq (y : ℂ) * Complex.normSq (x / y - (x / y : ℤ[i]) : ℂ) := by\n        rw [← normSq_mul, mul_sub, mul_div_cancel₀ _ this]\n      _ < Complex.normSq (y : ℂ) * 1 :=\n        (mul_lt_mul_of_pos_left (normSq_div_sub_div_lt_one _ _) (normSq_pos.2 this))\n      _ = Zsqrtd.norm y := by simp\n\n"}
{"name":"GaussianInt.natAbs_norm_mod_lt","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"x y : GaussianInt\nhy : Ne y 0\n⊢ LT.lt (Zsqrtd.norm (HMod.hMod x y)).natAbs (Zsqrtd.norm y).natAbs","decl":"theorem natAbs_norm_mod_lt (x : ℤ[i]) {y : ℤ[i]} (hy : y ≠ 0) :\n    (x % y).norm.natAbs < y.norm.natAbs :=\n  Int.ofNat_lt.1 (by simp [-Int.ofNat_lt, norm_mod_lt x hy])\n\n"}
{"name":"GaussianInt.norm_le_norm_mul_left","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"x y : GaussianInt\nhy : Ne y 0\n⊢ LE.le (Zsqrtd.norm x).natAbs (Zsqrtd.norm (HMul.hMul x y)).natAbs","decl":"theorem norm_le_norm_mul_left (x : ℤ[i]) {y : ℤ[i]} (hy : y ≠ 0) :\n    (norm x).natAbs ≤ (norm (x * y)).natAbs := by\n  rw [Zsqrtd.norm_mul, Int.natAbs_mul]\n  exact le_mul_of_one_le_right (Nat.zero_le _) (Int.ofNat_le.1 (by\n    rw [abs_natCast_norm]\n    exact Int.add_one_le_of_lt (norm_pos.2 hy)))\n\n"}
{"name":"GaussianInt.instNontrivial","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"⊢ Nontrivial GaussianInt","decl":"instance instNontrivial : Nontrivial ℤ[i] :=\n  ⟨⟨0, 1, by decide⟩⟩\n\n"}
{"name":"GaussianInt.sq_add_sq_of_nat_prime_of_not_irreducible","module":"Mathlib.NumberTheory.Zsqrtd.GaussianInt","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nhpi : Not (Irreducible ↑p)\n⊢ Exists fun a => Exists fun b => Eq (HAdd.hAdd (HPow.hPow a 2) (HPow.hPow b 2)) p","decl":"theorem sq_add_sq_of_nat_prime_of_not_irreducible (p : ℕ) [hp : Fact p.Prime]\n    (hpi : ¬Irreducible (p : ℤ[i])) : ∃ a b, a ^ 2 + b ^ 2 = p :=\n  have hpu : ¬IsUnit (p : ℤ[i]) :=\n    mt norm_eq_one_iff.2 <| by\n      rw [norm_natCast, Int.natAbs_mul, mul_eq_one]\n      exact fun h => (ne_of_lt hp.1.one_lt).symm h.1\n  have hab : ∃ a b, (p : ℤ[i]) = a * b ∧ ¬IsUnit a ∧ ¬IsUnit b := by\n    -- Porting note: was\n    -- simpa [irreducible_iff, hpu, not_forall, not_or] using hpi\n    simpa only [true_and, not_false_iff, exists_prop, irreducible_iff, hpu, not_forall, not_or]\n      using hpi\n  let ⟨a, b, hpab, hau, hbu⟩ := hab\n  have hnap : (norm a).natAbs = p :=\n    ((hp.1.mul_eq_prime_sq_iff (mt norm_eq_one_iff.1 hau) (mt norm_eq_one_iff.1 hbu)).1 <| by\n        rw [← Int.natCast_inj, Int.natCast_pow, sq, ← @norm_natCast (-1), hpab]; simp).1\n  ⟨a.re.natAbs, a.im.natAbs, by simpa [natAbs_norm_eq, sq] using hnap⟩\n\n"}
