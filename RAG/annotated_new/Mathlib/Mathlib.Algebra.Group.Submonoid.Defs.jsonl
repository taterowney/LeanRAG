{"name":"OneMemClass.one_mem","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"S : Type u_3\nM : outParam (Type u_4)\ninst✝¹ : One M\ninst✝ : SetLike S M\nself : OneMemClass S M\ns : S\n⊢ Membership.mem s 1","decl":"/-- `OneMemClass S M` says `S` is a type of subsets `s ≤ M`, such that `1 ∈ s` for all `s`. -/\nclass OneMemClass (S : Type*) (M : outParam Type*) [One M] [SetLike S M] : Prop where\n  /-- By definition, if we have `OneMemClass S M`, we have `1 ∈ s` for all `s : S`. -/\n  one_mem : ∀ s : S, (1 : M) ∈ s\n\n"}
{"name":"ZeroMemClass.zero_mem","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"S : Type u_3\nM : outParam (Type u_4)\ninst✝¹ : Zero M\ninst✝ : SetLike S M\nself : ZeroMemClass S M\ns : S\n⊢ Membership.mem s 0","decl":"/-- `ZeroMemClass S M` says `S` is a type of subsets `s ≤ M`, such that `0 ∈ s` for all `s`. -/\nclass ZeroMemClass (S : Type*) (M : outParam Type*) [Zero M] [SetLike S M] : Prop where\n  /-- By definition, if we have `ZeroMemClass S M`, we have `0 ∈ s` for all `s : S`. -/\n  zero_mem : ∀ s : S, (0 : M) ∈ s\n\n"}
{"name":"Submonoid.mk.sizeOf_spec","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_3\ninst✝¹ : MulOneClass M\ninst✝ : SizeOf M\ntoSubsemigroup : Subsemigroup M\none_mem' : Membership.mem toSubsemigroup.carrier 1\n⊢ Eq (SizeOf.sizeOf { toSubsemigroup := toSubsemigroup, one_mem' := one_mem' }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toSubsemigroup)) (SizeOf.sizeOf one_mem'))","decl":"/-- A submonoid of a monoid `M` is a subset containing 1 and closed under multiplication. -/\nstructure Submonoid (M : Type*) [MulOneClass M] extends Subsemigroup M where\n  /-- A submonoid contains `1`. -/\n  one_mem' : (1 : M) ∈ carrier\n\n"}
{"name":"Submonoid.mk.inj","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_3\ninst✝ : MulOneClass M\ntoSubsemigroup✝ : Subsemigroup M\none_mem'✝ : Membership.mem toSubsemigroup✝.carrier 1\ntoSubsemigroup : Subsemigroup M\none_mem' : Membership.mem toSubsemigroup.carrier 1\nx✝ : Eq { toSubsemigroup := toSubsemigroup✝, one_mem' := one_mem'✝ } { toSubsemigroup := toSubsemigroup, one_mem' := one_mem' }\n⊢ Eq toSubsemigroup✝ toSubsemigroup","decl":"/-- A submonoid of a monoid `M` is a subset containing 1 and closed under multiplication. -/\nstructure Submonoid (M : Type*) [MulOneClass M] extends Subsemigroup M where\n  /-- A submonoid contains `1`. -/\n  one_mem' : (1 : M) ∈ carrier\n\n"}
{"name":"Submonoid.mk.injEq","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_3\ninst✝ : MulOneClass M\ntoSubsemigroup✝ : Subsemigroup M\none_mem'✝ : Membership.mem toSubsemigroup✝.carrier 1\ntoSubsemigroup : Subsemigroup M\none_mem' : Membership.mem toSubsemigroup.carrier 1\n⊢ Eq (Eq { toSubsemigroup := toSubsemigroup✝, one_mem' := one_mem'✝ } { toSubsemigroup := toSubsemigroup, one_mem' := one_mem' }) (Eq toSubsemigroup✝ toSubsemigroup)","decl":"/-- A submonoid of a monoid `M` is a subset containing 1 and closed under multiplication. -/\nstructure Submonoid (M : Type*) [MulOneClass M] extends Subsemigroup M where\n  /-- A submonoid contains `1`. -/\n  one_mem' : (1 : M) ∈ carrier\n\n"}
{"name":"Submonoid.one_mem'","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_3\ninst✝ : MulOneClass M\nself : Submonoid M\n⊢ Membership.mem self.carrier 1","decl":"/-- A submonoid of a monoid `M` is a subset containing 1 and closed under multiplication. -/\nstructure Submonoid (M : Type*) [MulOneClass M] extends Subsemigroup M where\n  /-- A submonoid contains `1`. -/\n  one_mem' : (1 : M) ∈ carrier\n\n"}
{"name":"SubmonoidClass.toMulMemClass","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"S : Type u_3\nM : outParam (Type u_4)\ninst✝¹ : MulOneClass M\ninst✝ : SetLike S M\nself : SubmonoidClass S M\n⊢ MulMemClass S M","decl":"/-- `SubmonoidClass S M` says `S` is a type of subsets `s ≤ M` that contain `1`\nand are closed under `(*)` -/\nclass SubmonoidClass (S : Type*) (M : outParam Type*) [MulOneClass M] [SetLike S M] extends\n  MulMemClass S M, OneMemClass S M : Prop\n\n"}
{"name":"SubmonoidClass.toOneMemClass","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"S : Type u_3\nM : outParam (Type u_4)\ninst✝¹ : MulOneClass M\ninst✝ : SetLike S M\nself : SubmonoidClass S M\n⊢ OneMemClass S M","decl":"/-- `SubmonoidClass S M` says `S` is a type of subsets `s ≤ M` that contain `1`\nand are closed under `(*)` -/\nclass SubmonoidClass (S : Type*) (M : outParam Type*) [MulOneClass M] [SetLike S M] extends\n  MulMemClass S M, OneMemClass S M : Prop\n\n"}
{"name":"AddSubmonoid.mk.inj","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_3\ninst✝ : AddZeroClass M\ntoAddSubsemigroup✝ : AddSubsemigroup M\nzero_mem'✝ : Membership.mem toAddSubsemigroup✝.carrier 0\ntoAddSubsemigroup : AddSubsemigroup M\nzero_mem' : Membership.mem toAddSubsemigroup.carrier 0\nx✝ : Eq { toAddSubsemigroup := toAddSubsemigroup✝, zero_mem' := zero_mem'✝ } { toAddSubsemigroup := toAddSubsemigroup, zero_mem' := zero_mem' }\n⊢ Eq toAddSubsemigroup✝ toAddSubsemigroup","decl":"/-- An additive submonoid of an additive monoid `M` is a subset containing 0 and\n  closed under addition. -/\nstructure AddSubmonoid (M : Type*) [AddZeroClass M] extends AddSubsemigroup M where\n  /-- An additive submonoid contains `0`. -/\n  zero_mem' : (0 : M) ∈ carrier\n\n"}
{"name":"AddSubmonoid.zero_mem'","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_3\ninst✝ : AddZeroClass M\nself : AddSubmonoid M\n⊢ Membership.mem self.carrier 0","decl":"/-- An additive submonoid of an additive monoid `M` is a subset containing 0 and\n  closed under addition. -/\nstructure AddSubmonoid (M : Type*) [AddZeroClass M] extends AddSubsemigroup M where\n  /-- An additive submonoid contains `0`. -/\n  zero_mem' : (0 : M) ∈ carrier\n\n"}
{"name":"AddSubmonoid.mk.sizeOf_spec","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_3\ninst✝¹ : AddZeroClass M\ninst✝ : SizeOf M\ntoAddSubsemigroup : AddSubsemigroup M\nzero_mem' : Membership.mem toAddSubsemigroup.carrier 0\n⊢ Eq (SizeOf.sizeOf { toAddSubsemigroup := toAddSubsemigroup, zero_mem' := zero_mem' }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toAddSubsemigroup)) (SizeOf.sizeOf zero_mem'))","decl":"/-- An additive submonoid of an additive monoid `M` is a subset containing 0 and\n  closed under addition. -/\nstructure AddSubmonoid (M : Type*) [AddZeroClass M] extends AddSubsemigroup M where\n  /-- An additive submonoid contains `0`. -/\n  zero_mem' : (0 : M) ∈ carrier\n\n"}
{"name":"AddSubmonoid.mk.injEq","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_3\ninst✝ : AddZeroClass M\ntoAddSubsemigroup✝ : AddSubsemigroup M\nzero_mem'✝ : Membership.mem toAddSubsemigroup✝.carrier 0\ntoAddSubsemigroup : AddSubsemigroup M\nzero_mem' : Membership.mem toAddSubsemigroup.carrier 0\n⊢ Eq (Eq { toAddSubsemigroup := toAddSubsemigroup✝, zero_mem' := zero_mem'✝ } { toAddSubsemigroup := toAddSubsemigroup, zero_mem' := zero_mem' }) (Eq toAddSubsemigroup✝ toAddSubsemigroup)","decl":"/-- An additive submonoid of an additive monoid `M` is a subset containing 0 and\n  closed under addition. -/\nstructure AddSubmonoid (M : Type*) [AddZeroClass M] extends AddSubsemigroup M where\n  /-- An additive submonoid contains `0`. -/\n  zero_mem' : (0 : M) ∈ carrier\n\n"}
{"name":"AddSubmonoidClass.toZeroMemClass","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"S : Type u_3\nM : outParam (Type u_4)\ninst✝¹ : AddZeroClass M\ninst✝ : SetLike S M\nself : AddSubmonoidClass S M\n⊢ ZeroMemClass S M","decl":"/-- `AddSubmonoidClass S M` says `S` is a type of subsets `s ≤ M` that contain `0`\nand are closed under `(+)` -/\nclass AddSubmonoidClass (S : Type*) (M : outParam Type*) [AddZeroClass M] [SetLike S M] extends\n  AddMemClass S M, ZeroMemClass S M : Prop\n\n"}
{"name":"AddSubmonoidClass.toAddMemClass","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"S : Type u_3\nM : outParam (Type u_4)\ninst✝¹ : AddZeroClass M\ninst✝ : SetLike S M\nself : AddSubmonoidClass S M\n⊢ AddMemClass S M","decl":"/-- `AddSubmonoidClass S M` says `S` is a type of subsets `s ≤ M` that contain `0`\nand are closed under `(+)` -/\nclass AddSubmonoidClass (S : Type*) (M : outParam Type*) [AddZeroClass M] [SetLike S M] extends\n  AddMemClass S M, ZeroMemClass S M : Prop\n\n"}
{"name":"pow_mem","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_3\nA : Type u_4\ninst✝² : Monoid M\ninst✝¹ : SetLike A M\ninst✝ : SubmonoidClass A M\nS : A\nx : M\nhx : Membership.mem S x\nn : Nat\n⊢ Membership.mem S (HPow.hPow x n)","decl":"@[to_additive (attr := aesop safe apply (rule_sets := [SetLike]))]\ntheorem pow_mem {M A} [Monoid M] [SetLike A M] [SubmonoidClass A M] {S : A} {x : M}\n    (hx : x ∈ S) : ∀ n : ℕ, x ^ n ∈ S\n  | 0 => by\n    rw [pow_zero]\n    exact OneMemClass.one_mem S\n  | n + 1 => by\n    rw [pow_succ]\n    exact mul_mem (pow_mem hx n) hx\n\n"}
{"name":"nsmul_mem","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_3\nA : Type u_4\ninst✝² : AddMonoid M\ninst✝¹ : SetLike A M\ninst✝ : AddSubmonoidClass A M\nS : A\nx : M\nhx : Membership.mem S x\nn : Nat\n⊢ Membership.mem S (HSMul.hSMul n x)","decl":"@[to_additive (attr := aesop safe apply (rule_sets := [SetLike]))]\ntheorem pow_mem {M A} [Monoid M] [SetLike A M] [SubmonoidClass A M] {S : A} {x : M}\n    (hx : x ∈ S) : ∀ n : ℕ, x ^ n ∈ S\n  | 0 => by\n    rw [pow_zero]\n    exact OneMemClass.one_mem S\n  | n + 1 => by\n    rw [pow_succ]\n    exact mul_mem (pow_mem hx n) hx\n\n"}
{"name":"Submonoid.instSubmonoidClass","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\n⊢ SubmonoidClass (Submonoid M) M","decl":"@[to_additive]\ninstance : SubmonoidClass (Submonoid M) M where\n  one_mem := Submonoid.one_mem'\n  mul_mem {s} := s.mul_mem'\n\n"}
{"name":"AddSubmonoid.instAddSubmonoidClass","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\n⊢ AddSubmonoidClass (AddSubmonoid M) M","decl":"@[to_additive]\ninstance : SubmonoidClass (Submonoid M) M where\n  one_mem := Submonoid.one_mem'\n  mul_mem {s} := s.mul_mem'\n\n"}
{"name":"AddSubmonoid.mem_toSubsemigroup","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\ns : AddSubmonoid M\nx : M\n⊢ Iff (Membership.mem s.toAddSubsemigroup x) (Membership.mem s x)","decl":"@[to_additive (attr := simp)]\ntheorem mem_toSubsemigroup {s : Submonoid M} {x : M} : x ∈ s.toSubsemigroup ↔ x ∈ s :=\n  Iff.rfl\n\n-- Porting note: `x ∈ s.carrier` is now syntactically `x ∈ s.toSubsemigroup.carrier`,\n-- which `simp` already simplifies to `x ∈ s.toSubsemigroup`. So we remove the `@[simp]` attribute\n-- here, and instead add the simp lemma `mem_toSubsemigroup` to allow `simp` to do this exact\n-- simplification transitively.\n"}
{"name":"Submonoid.mem_toSubsemigroup","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\ns : Submonoid M\nx : M\n⊢ Iff (Membership.mem s.toSubsemigroup x) (Membership.mem s x)","decl":"@[to_additive (attr := simp)]\ntheorem mem_toSubsemigroup {s : Submonoid M} {x : M} : x ∈ s.toSubsemigroup ↔ x ∈ s :=\n  Iff.rfl\n\n-- Porting note: `x ∈ s.carrier` is now syntactically `x ∈ s.toSubsemigroup.carrier`,\n-- which `simp` already simplifies to `x ∈ s.toSubsemigroup`. So we remove the `@[simp]` attribute\n-- here, and instead add the simp lemma `mem_toSubsemigroup` to allow `simp` to do this exact\n-- simplification transitively.\n"}
{"name":"Submonoid.mem_carrier","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\ns : Submonoid M\nx : M\n⊢ Iff (Membership.mem s.carrier x) (Membership.mem s x)","decl":"@[to_additive]\ntheorem mem_carrier {s : Submonoid M} {x : M} : x ∈ s.carrier ↔ x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"AddSubmonoid.mem_carrier","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\ns : AddSubmonoid M\nx : M\n⊢ Iff (Membership.mem s.carrier x) (Membership.mem s x)","decl":"@[to_additive]\ntheorem mem_carrier {s : Submonoid M} {x : M} : x ∈ s.carrier ↔ x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"AddSubmonoid.mem_mk","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\ns : AddSubsemigroup M\nx : M\nh_one : Membership.mem s.carrier 0\n⊢ Iff (Membership.mem { toAddSubsemigroup := s, zero_mem' := h_one } x) (Membership.mem s x)","decl":"@[to_additive (attr := simp)]\ntheorem mem_mk {s : Subsemigroup M} {x : M} (h_one) : x ∈ mk s h_one ↔ x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Submonoid.mem_mk","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\ns : Subsemigroup M\nx : M\nh_one : Membership.mem s.carrier 1\n⊢ Iff (Membership.mem { toSubsemigroup := s, one_mem' := h_one } x) (Membership.mem s x)","decl":"@[to_additive (attr := simp)]\ntheorem mem_mk {s : Subsemigroup M} {x : M} (h_one) : x ∈ mk s h_one ↔ x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"AddSubmonoid.coe_set_mk","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\ns : AddSubsemigroup M\nh_one : Membership.mem s.carrier 0\n⊢ Eq ↑{ toAddSubsemigroup := s, zero_mem' := h_one } ↑s","decl":"@[to_additive (attr := simp)]\ntheorem coe_set_mk {s : Subsemigroup M} (h_one) : (mk s h_one : Set M) = s :=\n  rfl\n\n"}
{"name":"Submonoid.coe_set_mk","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\ns : Subsemigroup M\nh_one : Membership.mem s.carrier 1\n⊢ Eq ↑{ toSubsemigroup := s, one_mem' := h_one } ↑s","decl":"@[to_additive (attr := simp)]\ntheorem coe_set_mk {s : Subsemigroup M} (h_one) : (mk s h_one : Set M) = s :=\n  rfl\n\n"}
{"name":"AddSubmonoid.mk_le_mk","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\ns t : AddSubsemigroup M\nh_one : Membership.mem s.carrier 0\nh_one' : Membership.mem t.carrier 0\n⊢ Iff (LE.le { toAddSubsemigroup := s, zero_mem' := h_one } { toAddSubsemigroup := t, zero_mem' := h_one' }) (LE.le s t)","decl":"@[to_additive (attr := simp)]\ntheorem mk_le_mk {s t : Subsemigroup M} (h_one) (h_one') : mk s h_one ≤ mk t h_one' ↔ s ≤ t :=\n  Iff.rfl\n\n"}
{"name":"Submonoid.mk_le_mk","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\ns t : Subsemigroup M\nh_one : Membership.mem s.carrier 1\nh_one' : Membership.mem t.carrier 1\n⊢ Iff (LE.le { toSubsemigroup := s, one_mem' := h_one } { toSubsemigroup := t, one_mem' := h_one' }) (LE.le s t)","decl":"@[to_additive (attr := simp)]\ntheorem mk_le_mk {s t : Subsemigroup M} (h_one) (h_one') : mk s h_one ≤ mk t h_one' ↔ s ≤ t :=\n  Iff.rfl\n\n"}
{"name":"Submonoid.ext_iff","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nS T : Submonoid M\n⊢ Iff (Eq S T) (∀ (x : M), Iff (Membership.mem S x) (Membership.mem T x))","decl":"/-- Two submonoids are equal if they have the same elements. -/\n@[to_additive (attr := ext) \"Two `AddSubmonoid`s are equal if they have the same elements.\"]\ntheorem ext {S T : Submonoid M} (h : ∀ x, x ∈ S ↔ x ∈ T) : S = T :=\n  SetLike.ext h\n\n"}
{"name":"AddSubmonoid.ext","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nS T : AddSubmonoid M\nh : ∀ (x : M), Iff (Membership.mem S x) (Membership.mem T x)\n⊢ Eq S T","decl":"/-- Two submonoids are equal if they have the same elements. -/\n@[to_additive (attr := ext) \"Two `AddSubmonoid`s are equal if they have the same elements.\"]\ntheorem ext {S T : Submonoid M} (h : ∀ x, x ∈ S ↔ x ∈ T) : S = T :=\n  SetLike.ext h\n\n"}
{"name":"AddSubmonoid.ext_iff","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nS T : AddSubmonoid M\n⊢ Iff (Eq S T) (∀ (x : M), Iff (Membership.mem S x) (Membership.mem T x))","decl":"/-- Two submonoids are equal if they have the same elements. -/\n@[to_additive (attr := ext) \"Two `AddSubmonoid`s are equal if they have the same elements.\"]\ntheorem ext {S T : Submonoid M} (h : ∀ x, x ∈ S ↔ x ∈ T) : S = T :=\n  SetLike.ext h\n\n"}
{"name":"Submonoid.ext","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nS T : Submonoid M\nh : ∀ (x : M), Iff (Membership.mem S x) (Membership.mem T x)\n⊢ Eq S T","decl":"/-- Two submonoids are equal if they have the same elements. -/\n@[to_additive (attr := ext) \"Two `AddSubmonoid`s are equal if they have the same elements.\"]\ntheorem ext {S T : Submonoid M} (h : ∀ x, x ∈ S ↔ x ∈ T) : S = T :=\n  SetLike.ext h\n\n"}
{"name":"Submonoid.coe_copy","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nS : Submonoid M\ns : Set M\nhs : Eq s ↑S\n⊢ Eq (↑(S.copy s hs)) s","decl":"@[to_additive (attr := simp)]\ntheorem coe_copy {s : Set M} (hs : s = S) : (S.copy s hs : Set M) = s :=\n  rfl\n\n"}
{"name":"AddSubmonoid.coe_copy","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nS : AddSubmonoid M\ns : Set M\nhs : Eq s ↑S\n⊢ Eq (↑(S.copy s hs)) s","decl":"@[to_additive (attr := simp)]\ntheorem coe_copy {s : Set M} (hs : s = S) : (S.copy s hs : Set M) = s :=\n  rfl\n\n"}
{"name":"AddSubmonoid.copy_eq","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nS : AddSubmonoid M\ns : Set M\nhs : Eq s ↑S\n⊢ Eq (S.copy s hs) S","decl":"@[to_additive]\ntheorem copy_eq {s : Set M} (hs : s = S) : S.copy s hs = S :=\n  SetLike.coe_injective hs\n\n"}
{"name":"Submonoid.copy_eq","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nS : Submonoid M\ns : Set M\nhs : Eq s ↑S\n⊢ Eq (S.copy s hs) S","decl":"@[to_additive]\ntheorem copy_eq {s : Set M} (hs : s = S) : S.copy s hs = S :=\n  SetLike.coe_injective hs\n\n"}
{"name":"Submonoid.one_mem","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nS : Submonoid M\n⊢ Membership.mem S 1","decl":"/-- A submonoid contains the monoid's 1. -/\n@[to_additive \"An `AddSubmonoid` contains the monoid's 0.\"]\nprotected theorem one_mem : (1 : M) ∈ S :=\n  one_mem S\n\n"}
{"name":"AddSubmonoid.zero_mem","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nS : AddSubmonoid M\n⊢ Membership.mem S 0","decl":"/-- A submonoid contains the monoid's 1. -/\n@[to_additive \"An `AddSubmonoid` contains the monoid's 0.\"]\nprotected theorem one_mem : (1 : M) ∈ S :=\n  one_mem S\n\n"}
{"name":"AddSubmonoid.add_mem","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nS : AddSubmonoid M\nx y : M\na✝¹ : Membership.mem S x\na✝ : Membership.mem S y\n⊢ Membership.mem S (HAdd.hAdd x y)","decl":"/-- A submonoid is closed under multiplication. -/\n@[to_additive \"An `AddSubmonoid` is closed under addition.\"]\nprotected theorem mul_mem {x y : M} : x ∈ S → y ∈ S → x * y ∈ S :=\n  mul_mem\n\n"}
{"name":"Submonoid.mul_mem","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nS : Submonoid M\nx y : M\na✝¹ : Membership.mem S x\na✝ : Membership.mem S y\n⊢ Membership.mem S (HMul.hMul x y)","decl":"/-- A submonoid is closed under multiplication. -/\n@[to_additive \"An `AddSubmonoid` is closed under addition.\"]\nprotected theorem mul_mem {x y : M} : x ∈ S → y ∈ S → x * y ∈ S :=\n  mul_mem\n\n"}
{"name":"AddSubmonoid.mem_bot","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nx : M\n⊢ Iff (Membership.mem Bot.bot x) (Eq x 0)","decl":"@[to_additive (attr := simp)]\ntheorem mem_bot {x : M} : x ∈ (⊥ : Submonoid M) ↔ x = 1 :=\n  Set.mem_singleton_iff\n\n"}
{"name":"Submonoid.mem_bot","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nx : M\n⊢ Iff (Membership.mem Bot.bot x) (Eq x 1)","decl":"@[to_additive (attr := simp)]\ntheorem mem_bot {x : M} : x ∈ (⊥ : Submonoid M) ↔ x = 1 :=\n  Set.mem_singleton_iff\n\n"}
{"name":"Submonoid.mem_top","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nx : M\n⊢ Membership.mem Top.top x","decl":"@[to_additive (attr := simp)]\ntheorem mem_top (x : M) : x ∈ (⊤ : Submonoid M) :=\n  Set.mem_univ x\n\n"}
{"name":"AddSubmonoid.mem_top","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nx : M\n⊢ Membership.mem Top.top x","decl":"@[to_additive (attr := simp)]\ntheorem mem_top (x : M) : x ∈ (⊤ : Submonoid M) :=\n  Set.mem_univ x\n\n"}
{"name":"AddSubmonoid.coe_top","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\n⊢ Eq (↑Top.top) Set.univ","decl":"@[to_additive (attr := simp)]\ntheorem coe_top : ((⊤ : Submonoid M) : Set M) = Set.univ :=\n  rfl\n\n"}
{"name":"Submonoid.coe_top","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\n⊢ Eq (↑Top.top) Set.univ","decl":"@[to_additive (attr := simp)]\ntheorem coe_top : ((⊤ : Submonoid M) : Set M) = Set.univ :=\n  rfl\n\n"}
{"name":"AddSubmonoid.coe_bot","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\n⊢ Eq (↑Bot.bot) (Singleton.singleton 0)","decl":"@[to_additive (attr := simp)]\ntheorem coe_bot : ((⊥ : Submonoid M) : Set M) = {1} :=\n  rfl\n\n"}
{"name":"Submonoid.coe_bot","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\n⊢ Eq (↑Bot.bot) (Singleton.singleton 1)","decl":"@[to_additive (attr := simp)]\ntheorem coe_bot : ((⊥ : Submonoid M) : Set M) = {1} :=\n  rfl\n\n"}
{"name":"Submonoid.coe_inf","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\np p' : Submonoid M\n⊢ Eq (↑(Min.min p p')) (Inter.inter ↑p ↑p')","decl":"@[to_additive (attr := simp)]\ntheorem coe_inf (p p' : Submonoid M) : ((p ⊓ p' : Submonoid M) : Set M) = (p : Set M) ∩ p' :=\n  rfl\n\n"}
{"name":"AddSubmonoid.coe_inf","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\np p' : AddSubmonoid M\n⊢ Eq (↑(Min.min p p')) (Inter.inter ↑p ↑p')","decl":"@[to_additive (attr := simp)]\ntheorem coe_inf (p p' : Submonoid M) : ((p ⊓ p' : Submonoid M) : Set M) = (p : Set M) ∩ p' :=\n  rfl\n\n"}
{"name":"AddSubmonoid.mem_inf","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\np p' : AddSubmonoid M\nx : M\n⊢ Iff (Membership.mem (Min.min p p') x) (And (Membership.mem p x) (Membership.mem p' x))","decl":"@[to_additive (attr := simp)]\ntheorem mem_inf {p p' : Submonoid M} {x : M} : x ∈ p ⊓ p' ↔ x ∈ p ∧ x ∈ p' :=\n  Iff.rfl\n\n"}
{"name":"Submonoid.mem_inf","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\np p' : Submonoid M\nx : M\n⊢ Iff (Membership.mem (Min.min p p') x) (And (Membership.mem p x) (Membership.mem p' x))","decl":"@[to_additive (attr := simp)]\ntheorem mem_inf {p p' : Submonoid M} {x : M} : x ∈ p ⊓ p' ↔ x ∈ p ∧ x ∈ p' :=\n  Iff.rfl\n\n"}
{"name":"AddSubmonoid.subsingleton_iff","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\n⊢ Iff (Subsingleton (AddSubmonoid M)) (Subsingleton M)","decl":"@[to_additive (attr := simp)]\ntheorem subsingleton_iff : Subsingleton (Submonoid M) ↔ Subsingleton M :=\n  ⟨fun _ =>\n    ⟨fun x y =>\n      have : ∀ i : M, i = 1 := fun i =>\n        mem_bot.mp <| Subsingleton.elim (⊤ : Submonoid M) ⊥ ▸ mem_top i\n      (this x).trans (this y).symm⟩,\n    fun _ =>\n    ⟨fun x y => Submonoid.ext fun i => Subsingleton.elim 1 i ▸ by simp [Submonoid.one_mem]⟩⟩\n\n"}
{"name":"Submonoid.subsingleton_iff","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\n⊢ Iff (Subsingleton (Submonoid M)) (Subsingleton M)","decl":"@[to_additive (attr := simp)]\ntheorem subsingleton_iff : Subsingleton (Submonoid M) ↔ Subsingleton M :=\n  ⟨fun _ =>\n    ⟨fun x y =>\n      have : ∀ i : M, i = 1 := fun i =>\n        mem_bot.mp <| Subsingleton.elim (⊤ : Submonoid M) ⊥ ▸ mem_top i\n      (this x).trans (this y).symm⟩,\n    fun _ =>\n    ⟨fun x y => Submonoid.ext fun i => Subsingleton.elim 1 i ▸ by simp [Submonoid.one_mem]⟩⟩\n\n"}
{"name":"Submonoid.nontrivial_iff","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\n⊢ Iff (Nontrivial (Submonoid M)) (Nontrivial M)","decl":"@[to_additive (attr := simp)]\ntheorem nontrivial_iff : Nontrivial (Submonoid M) ↔ Nontrivial M :=\n  not_iff_not.mp\n    ((not_nontrivial_iff_subsingleton.trans subsingleton_iff).trans\n      not_nontrivial_iff_subsingleton.symm)\n\n"}
{"name":"AddSubmonoid.nontrivial_iff","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\n⊢ Iff (Nontrivial (AddSubmonoid M)) (Nontrivial M)","decl":"@[to_additive (attr := simp)]\ntheorem nontrivial_iff : Nontrivial (Submonoid M) ↔ Nontrivial M :=\n  not_iff_not.mp\n    ((not_nontrivial_iff_subsingleton.trans subsingleton_iff).trans\n      not_nontrivial_iff_subsingleton.symm)\n\n"}
{"name":"Submonoid.instNontrivial","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝¹ : MulOneClass M\ninst✝ : Nontrivial M\n⊢ Nontrivial (Submonoid M)","decl":"@[to_additive]\ninstance [Nontrivial M] : Nontrivial (Submonoid M) :=\n  nontrivial_iff.mpr ‹_›\n\n"}
{"name":"AddSubmonoid.instNontrivial","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\ninst✝¹ : AddZeroClass M\ninst✝ : Nontrivial M\n⊢ Nontrivial (AddSubmonoid M)","decl":"@[to_additive]\ninstance [Nontrivial M] : Nontrivial (Submonoid M) :=\n  nontrivial_iff.mpr ‹_›\n\n"}
{"name":"AddMonoidHom.eqLocusM_same","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf : AddMonoidHom M N\n⊢ Eq (f.eqLocusM f) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem eqLocusM_same (f : M →* N) : f.eqLocusM f = ⊤ :=\n  SetLike.ext fun _ => eq_self_iff_true _\n\n"}
{"name":"MonoidHom.eqLocusM_same","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nf : MonoidHom M N\n⊢ Eq (f.eqLocusM f) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem eqLocusM_same (f : M →* N) : f.eqLocusM f = ⊤ :=\n  SetLike.ext fun _ => eq_self_iff_true _\n\n"}
{"name":"MonoidHom.eq_of_eqOn_topM","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nf g : MonoidHom M N\nh : Set.EqOn ⇑f ⇑g ↑Top.top\n⊢ Eq f g","decl":"@[to_additive]\ntheorem eq_of_eqOn_topM {f g : M →* N} (h : Set.EqOn f g (⊤ : Submonoid M)) : f = g :=\n  ext fun _ => h trivial\n\n"}
{"name":"AddMonoidHom.eq_of_eqOn_topM","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf g : AddMonoidHom M N\nh : Set.EqOn ⇑f ⇑g ↑Top.top\n⊢ Eq f g","decl":"@[to_additive]\ntheorem eq_of_eqOn_topM {f g : M →* N} (h : Set.EqOn f g (⊤ : Submonoid M)) : f = g :=\n  ext fun _ => h trivial\n\n"}
{"name":"OneMemClass.coe_one","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"A : Type u_3\nM₁ : Type u_4\ninst✝¹ : SetLike A M₁\ninst✝ : One M₁\nhA : OneMemClass A M₁\nS' : A\n⊢ Eq (↑1) 1","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_one : ((1 : S') : M₁) = 1 :=\n  rfl\n\n"}
{"name":"ZeroMemClass.coe_zero","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"A : Type u_3\nM₁ : Type u_4\ninst✝¹ : SetLike A M₁\ninst✝ : Zero M₁\nhA : ZeroMemClass A M₁\nS' : A\n⊢ Eq (↑0) 0","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_one : ((1 : S') : M₁) = 1 :=\n  rfl\n\n"}
{"name":"ZeroMemClass.coe_eq_zero","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"A : Type u_3\nM₁ : Type u_4\ninst✝¹ : SetLike A M₁\ninst✝ : Zero M₁\nhA : ZeroMemClass A M₁\nS' : A\nx : Subtype fun x => Membership.mem S' x\n⊢ Iff (Eq (↑x) 0) (Eq x 0)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_eq_one {x : S'} : (↑x : M₁) = 1 ↔ x = 1 :=\n  (Subtype.ext_iff.symm : (x : M₁) = (1 : S') ↔ x = 1)\n\n"}
{"name":"OneMemClass.coe_eq_one","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"A : Type u_3\nM₁ : Type u_4\ninst✝¹ : SetLike A M₁\ninst✝ : One M₁\nhA : OneMemClass A M₁\nS' : A\nx : Subtype fun x => Membership.mem S' x\n⊢ Iff (Eq (↑x) 1) (Eq x 1)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_eq_one {x : S'} : (↑x : M₁) = 1 ↔ x = 1 :=\n  (Subtype.ext_iff.symm : (x : M₁) = (1 : S') ↔ x = 1)\n\n"}
{"name":"OneMemClass.one_def","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"A : Type u_3\nM₁ : Type u_4\ninst✝¹ : SetLike A M₁\ninst✝ : One M₁\nhA : OneMemClass A M₁\nS' : A\n⊢ Eq 1 ⟨1, ⋯⟩","decl":"@[to_additive]\ntheorem one_def : (1 : S') = ⟨1, OneMemClass.one_mem S'⟩ :=\n  rfl\n\n"}
{"name":"ZeroMemClass.zero_def","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"A : Type u_3\nM₁ : Type u_4\ninst✝¹ : SetLike A M₁\ninst✝ : Zero M₁\nhA : ZeroMemClass A M₁\nS' : A\n⊢ Eq 0 ⟨0, ⋯⟩","decl":"@[to_additive]\ntheorem one_def : (1 : S') = ⟨1, OneMemClass.one_mem S'⟩ :=\n  rfl\n\n"}
{"name":"AddSubmonoidClass.coe_nsmul","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_5\ninst✝² : AddMonoid M\nA : Type u_4\ninst✝¹ : SetLike A M\ninst✝ : AddSubmonoidClass A M\nS : A\nx : Subtype fun x => Membership.mem S x\nn : Nat\n⊢ Eq (↑(HSMul.hSMul n x)) (HSMul.hSMul n ↑x)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_pow {M} [Monoid M] {A : Type*} [SetLike A M] [SubmonoidClass A M] {S : A} (x : S)\n    (n : ℕ) : ↑(x ^ n) = (x : M) ^ n :=\n  rfl\n\n"}
{"name":"SubmonoidClass.coe_pow","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_5\ninst✝² : Monoid M\nA : Type u_4\ninst✝¹ : SetLike A M\ninst✝ : SubmonoidClass A M\nS : A\nx : Subtype fun x => Membership.mem S x\nn : Nat\n⊢ Eq (↑(HPow.hPow x n)) (HPow.hPow (↑x) n)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_pow {M} [Monoid M] {A : Type*} [SetLike A M] [SubmonoidClass A M] {S : A} (x : S)\n    (n : ℕ) : ↑(x ^ n) = (x : M) ^ n :=\n  rfl\n\n"}
{"name":"SubmonoidClass.mk_pow","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_5\ninst✝² : Monoid M\nA : Type u_4\ninst✝¹ : SetLike A M\ninst✝ : SubmonoidClass A M\nS : A\nx : M\nhx : Membership.mem S x\nn : Nat\n⊢ Eq (HPow.hPow ⟨x, hx⟩ n) ⟨HPow.hPow x n, ⋯⟩","decl":"@[to_additive (attr := simp)]\ntheorem mk_pow {M} [Monoid M] {A : Type*} [SetLike A M] [SubmonoidClass A M] {S : A} (x : M)\n    (hx : x ∈ S) (n : ℕ) : (⟨x, hx⟩ : S) ^ n = ⟨x ^ n, pow_mem hx n⟩ :=\n  rfl\n\n-- Prefer subclasses of `Monoid` over subclasses of `SubmonoidClass`.\n"}
{"name":"AddSubmonoidClass.mk_nsmul","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_5\ninst✝² : AddMonoid M\nA : Type u_4\ninst✝¹ : SetLike A M\ninst✝ : AddSubmonoidClass A M\nS : A\nx : M\nhx : Membership.mem S x\nn : Nat\n⊢ Eq (HSMul.hSMul n ⟨x, hx⟩) ⟨HSMul.hSMul n x, ⋯⟩","decl":"@[to_additive (attr := simp)]\ntheorem mk_pow {M} [Monoid M] {A : Type*} [SetLike A M] [SubmonoidClass A M] {S : A} (x : M)\n    (hx : x ∈ S) (n : ℕ) : (⟨x, hx⟩ : S) ^ n = ⟨x ^ n, pow_mem hx n⟩ :=\n  rfl\n\n-- Prefer subclasses of `Monoid` over subclasses of `SubmonoidClass`.\n"}
{"name":"AddSubmonoidClass.coe_subtype","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\nA : Type u_3\ninst✝¹ : AddZeroClass M\ninst✝ : SetLike A M\nhA : AddSubmonoidClass A M\nS' : A\n⊢ Eq (⇑(AddSubmonoidClass.subtype S')) Subtype.val","decl":"@[to_additive (attr := simp)]\ntheorem coe_subtype : (SubmonoidClass.subtype S' : S' → M) = Subtype.val :=\n  rfl\n\n"}
{"name":"SubmonoidClass.coe_subtype","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_1\nA : Type u_3\ninst✝¹ : MulOneClass M\ninst✝ : SetLike A M\nhA : SubmonoidClass A M\nS' : A\n⊢ Eq (⇑(SubmonoidClass.subtype S')) Subtype.val","decl":"@[to_additive (attr := simp)]\ntheorem coe_subtype : (SubmonoidClass.subtype S' : S' → M) = Subtype.val :=\n  rfl\n\n"}
{"name":"Submonoid.coe_mul","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_4\ninst✝ : MulOneClass M\nS : Submonoid M\nx y : Subtype fun x => Membership.mem S x\n⊢ Eq (↑(HMul.hMul x y)) (HMul.hMul ↑x ↑y)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_mul (x y : S) : (↑(x * y) : M) = ↑x * ↑y :=\n  rfl\n\n"}
{"name":"AddSubmonoid.coe_add","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_4\ninst✝ : AddZeroClass M\nS : AddSubmonoid M\nx y : Subtype fun x => Membership.mem S x\n⊢ Eq (↑(HAdd.hAdd x y)) (HAdd.hAdd ↑x ↑y)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_mul (x y : S) : (↑(x * y) : M) = ↑x * ↑y :=\n  rfl\n\n"}
{"name":"AddSubmonoid.coe_zero","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_4\ninst✝ : AddZeroClass M\nS : AddSubmonoid M\n⊢ Eq (↑0) 0","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_one : ((1 : S) : M) = 1 :=\n  rfl\n\n"}
{"name":"Submonoid.coe_one","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_4\ninst✝ : MulOneClass M\nS : Submonoid M\n⊢ Eq (↑1) 1","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_one : ((1 : S) : M) = 1 :=\n  rfl\n\n"}
{"name":"AddSubmonoid.mk_eq_zero","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_4\ninst✝ : AddZeroClass M\nS : AddSubmonoid M\na : M\nha : Membership.mem S a\n⊢ Iff (Eq ⟨a, ha⟩ 0) (Eq a 0)","decl":"@[to_additive (attr := simp)]\nlemma mk_eq_one {a : M} {ha} : (⟨a, ha⟩ : S) = 1 ↔ a = 1 := by simp [← SetLike.coe_eq_coe]\n\n"}
{"name":"Submonoid.mk_eq_one","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_4\ninst✝ : MulOneClass M\nS : Submonoid M\na : M\nha : Membership.mem S a\n⊢ Iff (Eq ⟨a, ha⟩ 1) (Eq a 1)","decl":"@[to_additive (attr := simp)]\nlemma mk_eq_one {a : M} {ha} : (⟨a, ha⟩ : S) = 1 ↔ a = 1 := by simp [← SetLike.coe_eq_coe]\n\n"}
{"name":"Submonoid.mk_mul_mk","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_4\ninst✝ : MulOneClass M\nS : Submonoid M\nx y : M\nhx : Membership.mem S x\nhy : Membership.mem S y\n⊢ Eq (HMul.hMul ⟨x, hx⟩ ⟨y, hy⟩) ⟨HMul.hMul x y, ⋯⟩","decl":"@[to_additive (attr := simp)]\ntheorem mk_mul_mk (x y : M) (hx : x ∈ S) (hy : y ∈ S) :\n    (⟨x, hx⟩ : S) * ⟨y, hy⟩ = ⟨x * y, S.mul_mem hx hy⟩ :=\n  rfl\n\n"}
{"name":"AddSubmonoid.mk_add_mk","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_4\ninst✝ : AddZeroClass M\nS : AddSubmonoid M\nx y : M\nhx : Membership.mem S x\nhy : Membership.mem S y\n⊢ Eq (HAdd.hAdd ⟨x, hx⟩ ⟨y, hy⟩) ⟨HAdd.hAdd x y, ⋯⟩","decl":"@[to_additive (attr := simp)]\ntheorem mk_mul_mk (x y : M) (hx : x ∈ S) (hy : y ∈ S) :\n    (⟨x, hx⟩ : S) * ⟨y, hy⟩ = ⟨x * y, S.mul_mem hx hy⟩ :=\n  rfl\n\n"}
{"name":"Submonoid.mul_def","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_4\ninst✝ : MulOneClass M\nS : Submonoid M\nx y : Subtype fun x => Membership.mem S x\n⊢ Eq (HMul.hMul x y) ⟨HMul.hMul ↑x ↑y, ⋯⟩","decl":"@[to_additive]\ntheorem mul_def (x y : S) : x * y = ⟨x * y, S.mul_mem x.2 y.2⟩ :=\n  rfl\n\n"}
{"name":"AddSubmonoid.add_def","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_4\ninst✝ : AddZeroClass M\nS : AddSubmonoid M\nx y : Subtype fun x => Membership.mem S x\n⊢ Eq (HAdd.hAdd x y) ⟨HAdd.hAdd ↑x ↑y, ⋯⟩","decl":"@[to_additive]\ntheorem mul_def (x y : S) : x * y = ⟨x * y, S.mul_mem x.2 y.2⟩ :=\n  rfl\n\n"}
{"name":"AddSubmonoid.zero_def","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_4\ninst✝ : AddZeroClass M\nS : AddSubmonoid M\n⊢ Eq 0 ⟨0, ⋯⟩","decl":"@[to_additive]\ntheorem one_def : (1 : S) = ⟨1, S.one_mem⟩ :=\n  rfl\n\n"}
{"name":"Submonoid.one_def","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_4\ninst✝ : MulOneClass M\nS : Submonoid M\n⊢ Eq 1 ⟨1, ⋯⟩","decl":"@[to_additive]\ntheorem one_def : (1 : S) = ⟨1, S.one_mem⟩ :=\n  rfl\n\n"}
{"name":"Submonoid.pow_mem","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_5\ninst✝ : Monoid M\nS : Submonoid M\nx : M\nhx : Membership.mem S x\nn : Nat\n⊢ Membership.mem S (HPow.hPow x n)","decl":"@[to_additive]\nprotected theorem pow_mem {M : Type*} [Monoid M] (S : Submonoid M) {x : M} (hx : x ∈ S) (n : ℕ) :\n    x ^ n ∈ S :=\n  pow_mem hx n\n\n"}
{"name":"AddSubmonoid.nsmul_mem","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_5\ninst✝ : AddMonoid M\nS : AddSubmonoid M\nx : M\nhx : Membership.mem S x\nn : Nat\n⊢ Membership.mem S (HSMul.hSMul n x)","decl":"@[to_additive]\nprotected theorem pow_mem {M : Type*} [Monoid M] (S : Submonoid M) {x : M} (hx : x ∈ S) (n : ℕ) :\n    x ^ n ∈ S :=\n  pow_mem hx n\n\n"}
{"name":"Submonoid.coe_subtype","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_4\ninst✝ : MulOneClass M\nS : Submonoid M\n⊢ Eq (⇑S.subtype) Subtype.val","decl":"@[to_additive (attr := simp)]\ntheorem coe_subtype : ⇑S.subtype = Subtype.val :=\n  rfl\n\n"}
{"name":"AddSubmonoid.coe_subtype","module":"Mathlib.Algebra.Group.Submonoid.Defs","initialProofState":"M : Type u_4\ninst✝ : AddZeroClass M\nS : AddSubmonoid M\n⊢ Eq (⇑S.subtype) Subtype.val","decl":"@[to_additive (attr := simp)]\ntheorem coe_subtype : ⇑S.subtype = Subtype.val :=\n  rfl\n\n"}
