{"name":"IsUnifLocDoublingMeasure.exists_measure_closedBall_le_mul''","module":"Mathlib.MeasureTheory.Measure.Doubling","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : PseudoMetricSpace Î±\ninstâœ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nself : IsUnifLocDoublingMeasure Î¼\nâŠ¢ Exists fun C => Filter.Eventually (fun Îµ => âˆ€ (x : Î±), LE.le (Î¼ (Metric.closedBall x (HMul.hMul 2 Îµ))) (HMul.hMul (â†‘C) (Î¼ (Metric.closedBall x Îµ)))) (nhdsWithin 0 (Set.Ioi 0))","decl":"/-- A measure `Î¼` is said to be a uniformly locally doubling measure if there exists a constant `C`\nsuch that for all sufficiently small radii `Îµ`, and for any centre, the measure of a ball of radius\n`2 * Îµ` is bounded by `C` times the measure of the concentric ball of radius `Îµ`.\n\nNote: it is important that this definition makes a demand only for sufficiently small `Îµ`. For\nexample we want hyperbolic space to carry the instance `IsUnifLocDoublingMeasure volume` but\nvolumes grow exponentially in hyperbolic space. To be really explicit, consider the hyperbolic plane\nof curvature -1, the area of a disc of radius `Îµ` is `A(Îµ) = 2Ï€(cosh(Îµ) - 1)` so\n`A(2Îµ)/A(Îµ) ~ exp(Îµ)`. -/\nclass IsUnifLocDoublingMeasure {Î± : Type*} [PseudoMetricSpace Î±] [MeasurableSpace Î±]\n  (Î¼ : Measure Î±) : Prop where\n  exists_measure_closedBall_le_mul'' :\n    âˆƒ C : â„â‰¥0, âˆ€á¶  Îµ in ğ“[>] 0, âˆ€ x, Î¼ (closedBall x (2 * Îµ)) â‰¤ C * Î¼ (closedBall x Îµ)\n\n"}
{"name":"IsUnifLocDoublingMeasure.exists_measure_closedBall_le_mul","module":"Mathlib.MeasureTheory.Measure.Doubling","initialProofState":"Î± : Type u_1\ninstâœÂ² : PseudoMetricSpace Î±\ninstâœÂ¹ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : IsUnifLocDoublingMeasure Î¼\nâŠ¢ Exists fun C => Filter.Eventually (fun Îµ => âˆ€ (x : Î±), LE.le (Î¼ (Metric.closedBall x (HMul.hMul 2 Îµ))) (HMul.hMul (â†‘C) (Î¼ (Metric.closedBall x Îµ)))) (nhdsWithin 0 (Set.Ioi 0))","decl":"theorem exists_measure_closedBall_le_mul :\n    âˆƒ C : â„â‰¥0, âˆ€á¶  Îµ in ğ“[>] 0, âˆ€ x, Î¼ (closedBall x (2 * Îµ)) â‰¤ C * Î¼ (closedBall x Îµ) :=\n  exists_measure_closedBall_le_mul''\n\n"}
{"name":"IsUnifLocDoublingMeasure.exists_measure_closedBall_le_mul'","module":"Mathlib.MeasureTheory.Measure.Doubling","initialProofState":"Î± : Type u_1\ninstâœÂ² : PseudoMetricSpace Î±\ninstâœÂ¹ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : IsUnifLocDoublingMeasure Î¼\nâŠ¢ Filter.Eventually (fun Îµ => âˆ€ (x : Î±), LE.le (Î¼ (Metric.closedBall x (HMul.hMul 2 Îµ))) (HMul.hMul (â†‘(IsUnifLocDoublingMeasure.doublingConstant Î¼)) (Î¼ (Metric.closedBall x Îµ)))) (nhdsWithin 0 (Set.Ioi 0))","decl":"theorem exists_measure_closedBall_le_mul' :\n    âˆ€á¶  Îµ in ğ“[>] 0, âˆ€ x, Î¼ (closedBall x (2 * Îµ)) â‰¤ doublingConstant Î¼ * Î¼ (closedBall x Îµ) :=\n  Classical.choose_spec <| exists_measure_closedBall_le_mul Î¼\n\n"}
{"name":"IsUnifLocDoublingMeasure.exists_eventually_forall_measure_closedBall_le_mul","module":"Mathlib.MeasureTheory.Measure.Doubling","initialProofState":"Î± : Type u_1\ninstâœÂ² : PseudoMetricSpace Î±\ninstâœÂ¹ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : IsUnifLocDoublingMeasure Î¼\nK : Real\nâŠ¢ Exists fun C => Filter.Eventually (fun Îµ => âˆ€ (x : Î±) (t : Real), LE.le t K â†’ LE.le (Î¼ (Metric.closedBall x (HMul.hMul t Îµ))) (HMul.hMul (â†‘C) (Î¼ (Metric.closedBall x Îµ)))) (nhdsWithin 0 (Set.Ioi 0))","decl":"theorem exists_eventually_forall_measure_closedBall_le_mul (K : â„) :\n    âˆƒ C : â„â‰¥0, âˆ€á¶  Îµ in ğ“[>] 0, âˆ€ x, âˆ€ t â‰¤ K, Î¼ (closedBall x (t * Îµ)) â‰¤ C * Î¼ (closedBall x Îµ) := by\n  let C := doublingConstant Î¼\n  have hÎ¼ :\n    âˆ€ n : â„•, âˆ€á¶  Îµ in ğ“[>] 0, âˆ€ x,\n      Î¼ (closedBall x ((2 : â„) ^ n * Îµ)) â‰¤ â†‘(C ^ n) * Î¼ (closedBall x Îµ) := by\n    intro n\n    induction' n with n ih\n    Â· simp\n    replace ih := eventually_nhdsGT_zero_mul_left (two_pos : 0 < (2 : â„)) ih\n    refine (ih.and (exists_measure_closedBall_le_mul' Î¼)).mono fun Îµ hÎµ x => ?_\n    calc\n      Î¼ (closedBall x ((2 : â„) ^ (n + 1) * Îµ)) = Î¼ (closedBall x ((2 : â„) ^ n * (2 * Îµ))) := by\n        rw [pow_succ, mul_assoc]\n      _ â‰¤ â†‘(C ^ n) * Î¼ (closedBall x (2 * Îµ)) := hÎµ.1 x\n      _ â‰¤ â†‘(C ^ n) * (C * Î¼ (closedBall x Îµ)) := by gcongr; exact hÎµ.2 x\n      _ = â†‘(C ^ (n + 1)) * Î¼ (closedBall x Îµ) := by rw [â† mul_assoc, pow_succ, ENNReal.coe_mul]\n  rcases lt_or_le K 1 with (hK | hK)\n  Â· refine âŸ¨1, ?_âŸ©\n    simp only [ENNReal.coe_one, one_mul]\n    refine eventually_mem_nhdsWithin.mono fun Îµ hÎµ x t ht â†¦ ?_\n    gcongr\n    nlinarith [mem_Ioi.mp hÎµ]\n  Â· use C ^ âŒˆReal.logb 2 KâŒ‰â‚Š\n    filter_upwards [hÎ¼ âŒˆReal.logb 2 KâŒ‰â‚Š, eventually_mem_nhdsWithin] with Îµ hÎµ hÎµâ‚€ x t ht\n    refine le_trans ?_ (hÎµ x)\n    gcongr\n    Â· exact (mem_Ioi.mp hÎµâ‚€).le\n    Â· refine ht.trans ?_\n      rw [â† Real.rpow_natCast, â† Real.logb_le_iff_le_rpow]\n      exacts [Nat.le_ceil _, by norm_num, by linarith]\n\n"}
{"name":"IsUnifLocDoublingMeasure.one_le_scalingConstantOf","module":"Mathlib.MeasureTheory.Measure.Doubling","initialProofState":"Î± : Type u_1\ninstâœÂ² : PseudoMetricSpace Î±\ninstâœÂ¹ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : IsUnifLocDoublingMeasure Î¼\nK : Real\nâŠ¢ LE.le 1 (IsUnifLocDoublingMeasure.scalingConstantOf Î¼ K)","decl":"@[simp]\ntheorem one_le_scalingConstantOf (K : â„) : 1 â‰¤ scalingConstantOf Î¼ K :=\n  le_max_of_le_right <| le_refl 1\n\n"}
{"name":"IsUnifLocDoublingMeasure.eventually_measure_mul_le_scalingConstantOf_mul","module":"Mathlib.MeasureTheory.Measure.Doubling","initialProofState":"Î± : Type u_1\ninstâœÂ² : PseudoMetricSpace Î±\ninstâœÂ¹ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : IsUnifLocDoublingMeasure Î¼\nK : Real\nâŠ¢ Exists fun R => And (LT.lt 0 R) (âˆ€ (x : Î±) (t r : Real), Membership.mem (Set.Ioc 0 K) t â†’ LE.le r R â†’ LE.le (Î¼ (Metric.closedBall x (HMul.hMul t r))) (HMul.hMul (â†‘(IsUnifLocDoublingMeasure.scalingConstantOf Î¼ K)) (Î¼ (Metric.closedBall x r))))","decl":"theorem eventually_measure_mul_le_scalingConstantOf_mul (K : â„) :\n    âˆƒ R : â„,\n      0 < R âˆ§\n        âˆ€ x t r, t âˆˆ Ioc 0 K â†’ r â‰¤ R â†’\n          Î¼ (closedBall x (t * r)) â‰¤ scalingConstantOf Î¼ K * Î¼ (closedBall x r) := by\n  have h := Classical.choose_spec (exists_eventually_forall_measure_closedBall_le_mul Î¼ K)\n  rcases mem_nhdsGT_iff_exists_Ioc_subset.1 h with âŸ¨R, Rpos, hRâŸ©\n  refine âŸ¨R, Rpos, fun x t r ht hr => ?_âŸ©\n  rcases lt_trichotomy r 0 with (rneg | rfl | rpos)\n  Â· have : t * r < 0 := mul_neg_of_pos_of_neg ht.1 rneg\n    simp only [closedBall_eq_empty.2 this, measure_empty, zero_le']\n  Â· simp only [mul_zero, closedBall_zero]\n    refine le_mul_of_one_le_of_le ?_ le_rfl\n    apply ENNReal.one_le_coe_iff.2 (le_max_right _ _)\n  Â· apply (hR âŸ¨rpos, hrâŸ© x t ht.2).trans\n    gcongr\n    apply le_max_left\n\n"}
{"name":"IsUnifLocDoublingMeasure.eventually_measure_le_scaling_constant_mul","module":"Mathlib.MeasureTheory.Measure.Doubling","initialProofState":"Î± : Type u_1\ninstâœÂ² : PseudoMetricSpace Î±\ninstâœÂ¹ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : IsUnifLocDoublingMeasure Î¼\nK : Real\nâŠ¢ Filter.Eventually (fun r => âˆ€ (x : Î±), LE.le (Î¼ (Metric.closedBall x (HMul.hMul K r))) (HMul.hMul (â†‘(IsUnifLocDoublingMeasure.scalingConstantOf Î¼ K)) (Î¼ (Metric.closedBall x r)))) (nhdsWithin 0 (Set.Ioi 0))","decl":"theorem eventually_measure_le_scaling_constant_mul (K : â„) :\n    âˆ€á¶  r in ğ“[>] 0, âˆ€ x, Î¼ (closedBall x (K * r)) â‰¤ scalingConstantOf Î¼ K * Î¼ (closedBall x r) := by\n  filter_upwards [Classical.choose_spec\n      (exists_eventually_forall_measure_closedBall_le_mul Î¼ K)] with r hr x\n  exact (hr x K le_rfl).trans (mul_le_mul_right' (ENNReal.coe_le_coe.2 (le_max_left _ _)) _)\n\n"}
{"name":"IsUnifLocDoublingMeasure.eventually_measure_le_scaling_constant_mul'","module":"Mathlib.MeasureTheory.Measure.Doubling","initialProofState":"Î± : Type u_1\ninstâœÂ² : PseudoMetricSpace Î±\ninstâœÂ¹ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : IsUnifLocDoublingMeasure Î¼\nK : Real\nhK : LT.lt 0 K\nâŠ¢ Filter.Eventually (fun r => âˆ€ (x : Î±), LE.le (Î¼ (Metric.closedBall x r)) (HMul.hMul (â†‘(IsUnifLocDoublingMeasure.scalingConstantOf Î¼ (Inv.inv K))) (Î¼ (Metric.closedBall x (HMul.hMul K r))))) (nhdsWithin 0 (Set.Ioi 0))","decl":"theorem eventually_measure_le_scaling_constant_mul' (K : â„) (hK : 0 < K) :\n    âˆ€á¶  r in ğ“[>] 0, âˆ€ x,\n      Î¼ (closedBall x r) â‰¤ scalingConstantOf Î¼ Kâ»Â¹ * Î¼ (closedBall x (K * r)) := by\n  convert eventually_nhdsGT_zero_mul_left hK (eventually_measure_le_scaling_constant_mul Î¼ Kâ»Â¹)\n  simp [inv_mul_cancel_leftâ‚€ hK.ne']\n\n"}
{"name":"IsUnifLocDoublingMeasure.scalingScaleOf_pos","module":"Mathlib.MeasureTheory.Measure.Doubling","initialProofState":"Î± : Type u_1\ninstâœÂ² : PseudoMetricSpace Î±\ninstâœÂ¹ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : IsUnifLocDoublingMeasure Î¼\nK : Real\nâŠ¢ LT.lt 0 (IsUnifLocDoublingMeasure.scalingScaleOf Î¼ K)","decl":"theorem scalingScaleOf_pos (K : â„) : 0 < scalingScaleOf Î¼ K :=\n  (eventually_measure_mul_le_scalingConstantOf_mul Î¼ K).choose_spec.1\n\n"}
{"name":"IsUnifLocDoublingMeasure.measure_mul_le_scalingConstantOf_mul","module":"Mathlib.MeasureTheory.Measure.Doubling","initialProofState":"Î± : Type u_1\ninstâœÂ² : PseudoMetricSpace Î±\ninstâœÂ¹ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : IsUnifLocDoublingMeasure Î¼\nK : Real\nx : Î±\nt r : Real\nht : Membership.mem (Set.Ioc 0 K) t\nhr : LE.le r (IsUnifLocDoublingMeasure.scalingScaleOf Î¼ K)\nâŠ¢ LE.le (Î¼ (Metric.closedBall x (HMul.hMul t r))) (HMul.hMul (â†‘(IsUnifLocDoublingMeasure.scalingConstantOf Î¼ K)) (Î¼ (Metric.closedBall x r)))","decl":"theorem measure_mul_le_scalingConstantOf_mul {K : â„} {x : Î±} {t r : â„} (ht : t âˆˆ Ioc 0 K)\n    (hr : r â‰¤ scalingScaleOf Î¼ K) :\n    Î¼ (closedBall x (t * r)) â‰¤ scalingConstantOf Î¼ K * Î¼ (closedBall x r) :=\n  (eventually_measure_mul_le_scalingConstantOf_mul Î¼ K).choose_spec.2 x t r ht hr\n\n"}
