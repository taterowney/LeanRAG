{"name":"IsUnifLocDoublingMeasure.exists_measure_closedBall_le_mul''","module":"Mathlib.MeasureTheory.Measure.Doubling","initialProofState":"α : Type u_1\ninst✝¹ : PseudoMetricSpace α\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nself : IsUnifLocDoublingMeasure μ\n⊢ Exists fun C => Filter.Eventually (fun ε => ∀ (x : α), LE.le (μ (Metric.closedBall x (HMul.hMul 2 ε))) (HMul.hMul (↑C) (μ (Metric.closedBall x ε)))) (nhdsWithin 0 (Set.Ioi 0))","decl":"/-- A measure `μ` is said to be a uniformly locally doubling measure if there exists a constant `C`\nsuch that for all sufficiently small radii `ε`, and for any centre, the measure of a ball of radius\n`2 * ε` is bounded by `C` times the measure of the concentric ball of radius `ε`.\n\nNote: it is important that this definition makes a demand only for sufficiently small `ε`. For\nexample we want hyperbolic space to carry the instance `IsUnifLocDoublingMeasure volume` but\nvolumes grow exponentially in hyperbolic space. To be really explicit, consider the hyperbolic plane\nof curvature -1, the area of a disc of radius `ε` is `A(ε) = 2π(cosh(ε) - 1)` so\n`A(2ε)/A(ε) ~ exp(ε)`. -/\nclass IsUnifLocDoublingMeasure {α : Type*} [PseudoMetricSpace α] [MeasurableSpace α]\n  (μ : Measure α) : Prop where\n  exists_measure_closedBall_le_mul'' :\n    ∃ C : ℝ≥0, ∀ᶠ ε in 𝓝[>] 0, ∀ x, μ (closedBall x (2 * ε)) ≤ C * μ (closedBall x ε)\n\n"}
{"name":"IsUnifLocDoublingMeasure.exists_measure_closedBall_le_mul","module":"Mathlib.MeasureTheory.Measure.Doubling","initialProofState":"α : Type u_1\ninst✝² : PseudoMetricSpace α\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : IsUnifLocDoublingMeasure μ\n⊢ Exists fun C => Filter.Eventually (fun ε => ∀ (x : α), LE.le (μ (Metric.closedBall x (HMul.hMul 2 ε))) (HMul.hMul (↑C) (μ (Metric.closedBall x ε)))) (nhdsWithin 0 (Set.Ioi 0))","decl":"theorem exists_measure_closedBall_le_mul :\n    ∃ C : ℝ≥0, ∀ᶠ ε in 𝓝[>] 0, ∀ x, μ (closedBall x (2 * ε)) ≤ C * μ (closedBall x ε) :=\n  exists_measure_closedBall_le_mul''\n\n"}
{"name":"IsUnifLocDoublingMeasure.exists_measure_closedBall_le_mul'","module":"Mathlib.MeasureTheory.Measure.Doubling","initialProofState":"α : Type u_1\ninst✝² : PseudoMetricSpace α\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : IsUnifLocDoublingMeasure μ\n⊢ Filter.Eventually (fun ε => ∀ (x : α), LE.le (μ (Metric.closedBall x (HMul.hMul 2 ε))) (HMul.hMul (↑(IsUnifLocDoublingMeasure.doublingConstant μ)) (μ (Metric.closedBall x ε)))) (nhdsWithin 0 (Set.Ioi 0))","decl":"theorem exists_measure_closedBall_le_mul' :\n    ∀ᶠ ε in 𝓝[>] 0, ∀ x, μ (closedBall x (2 * ε)) ≤ doublingConstant μ * μ (closedBall x ε) :=\n  Classical.choose_spec <| exists_measure_closedBall_le_mul μ\n\n"}
{"name":"IsUnifLocDoublingMeasure.exists_eventually_forall_measure_closedBall_le_mul","module":"Mathlib.MeasureTheory.Measure.Doubling","initialProofState":"α : Type u_1\ninst✝² : PseudoMetricSpace α\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : IsUnifLocDoublingMeasure μ\nK : Real\n⊢ Exists fun C => Filter.Eventually (fun ε => ∀ (x : α) (t : Real), LE.le t K → LE.le (μ (Metric.closedBall x (HMul.hMul t ε))) (HMul.hMul (↑C) (μ (Metric.closedBall x ε)))) (nhdsWithin 0 (Set.Ioi 0))","decl":"theorem exists_eventually_forall_measure_closedBall_le_mul (K : ℝ) :\n    ∃ C : ℝ≥0, ∀ᶠ ε in 𝓝[>] 0, ∀ x, ∀ t ≤ K, μ (closedBall x (t * ε)) ≤ C * μ (closedBall x ε) := by\n  let C := doublingConstant μ\n  have hμ :\n    ∀ n : ℕ, ∀ᶠ ε in 𝓝[>] 0, ∀ x,\n      μ (closedBall x ((2 : ℝ) ^ n * ε)) ≤ ↑(C ^ n) * μ (closedBall x ε) := by\n    intro n\n    induction' n with n ih\n    · simp\n    replace ih := eventually_nhdsGT_zero_mul_left (two_pos : 0 < (2 : ℝ)) ih\n    refine (ih.and (exists_measure_closedBall_le_mul' μ)).mono fun ε hε x => ?_\n    calc\n      μ (closedBall x ((2 : ℝ) ^ (n + 1) * ε)) = μ (closedBall x ((2 : ℝ) ^ n * (2 * ε))) := by\n        rw [pow_succ, mul_assoc]\n      _ ≤ ↑(C ^ n) * μ (closedBall x (2 * ε)) := hε.1 x\n      _ ≤ ↑(C ^ n) * (C * μ (closedBall x ε)) := by gcongr; exact hε.2 x\n      _ = ↑(C ^ (n + 1)) * μ (closedBall x ε) := by rw [← mul_assoc, pow_succ, ENNReal.coe_mul]\n  rcases lt_or_le K 1 with (hK | hK)\n  · refine ⟨1, ?_⟩\n    simp only [ENNReal.coe_one, one_mul]\n    refine eventually_mem_nhdsWithin.mono fun ε hε x t ht ↦ ?_\n    gcongr\n    nlinarith [mem_Ioi.mp hε]\n  · use C ^ ⌈Real.logb 2 K⌉₊\n    filter_upwards [hμ ⌈Real.logb 2 K⌉₊, eventually_mem_nhdsWithin] with ε hε hε₀ x t ht\n    refine le_trans ?_ (hε x)\n    gcongr\n    · exact (mem_Ioi.mp hε₀).le\n    · refine ht.trans ?_\n      rw [← Real.rpow_natCast, ← Real.logb_le_iff_le_rpow]\n      exacts [Nat.le_ceil _, by norm_num, by linarith]\n\n"}
{"name":"IsUnifLocDoublingMeasure.one_le_scalingConstantOf","module":"Mathlib.MeasureTheory.Measure.Doubling","initialProofState":"α : Type u_1\ninst✝² : PseudoMetricSpace α\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : IsUnifLocDoublingMeasure μ\nK : Real\n⊢ LE.le 1 (IsUnifLocDoublingMeasure.scalingConstantOf μ K)","decl":"@[simp]\ntheorem one_le_scalingConstantOf (K : ℝ) : 1 ≤ scalingConstantOf μ K :=\n  le_max_of_le_right <| le_refl 1\n\n"}
{"name":"IsUnifLocDoublingMeasure.eventually_measure_mul_le_scalingConstantOf_mul","module":"Mathlib.MeasureTheory.Measure.Doubling","initialProofState":"α : Type u_1\ninst✝² : PseudoMetricSpace α\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : IsUnifLocDoublingMeasure μ\nK : Real\n⊢ Exists fun R => And (LT.lt 0 R) (∀ (x : α) (t r : Real), Membership.mem (Set.Ioc 0 K) t → LE.le r R → LE.le (μ (Metric.closedBall x (HMul.hMul t r))) (HMul.hMul (↑(IsUnifLocDoublingMeasure.scalingConstantOf μ K)) (μ (Metric.closedBall x r))))","decl":"theorem eventually_measure_mul_le_scalingConstantOf_mul (K : ℝ) :\n    ∃ R : ℝ,\n      0 < R ∧\n        ∀ x t r, t ∈ Ioc 0 K → r ≤ R →\n          μ (closedBall x (t * r)) ≤ scalingConstantOf μ K * μ (closedBall x r) := by\n  have h := Classical.choose_spec (exists_eventually_forall_measure_closedBall_le_mul μ K)\n  rcases mem_nhdsGT_iff_exists_Ioc_subset.1 h with ⟨R, Rpos, hR⟩\n  refine ⟨R, Rpos, fun x t r ht hr => ?_⟩\n  rcases lt_trichotomy r 0 with (rneg | rfl | rpos)\n  · have : t * r < 0 := mul_neg_of_pos_of_neg ht.1 rneg\n    simp only [closedBall_eq_empty.2 this, measure_empty, zero_le']\n  · simp only [mul_zero, closedBall_zero]\n    refine le_mul_of_one_le_of_le ?_ le_rfl\n    apply ENNReal.one_le_coe_iff.2 (le_max_right _ _)\n  · apply (hR ⟨rpos, hr⟩ x t ht.2).trans\n    gcongr\n    apply le_max_left\n\n"}
{"name":"IsUnifLocDoublingMeasure.eventually_measure_le_scaling_constant_mul","module":"Mathlib.MeasureTheory.Measure.Doubling","initialProofState":"α : Type u_1\ninst✝² : PseudoMetricSpace α\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : IsUnifLocDoublingMeasure μ\nK : Real\n⊢ Filter.Eventually (fun r => ∀ (x : α), LE.le (μ (Metric.closedBall x (HMul.hMul K r))) (HMul.hMul (↑(IsUnifLocDoublingMeasure.scalingConstantOf μ K)) (μ (Metric.closedBall x r)))) (nhdsWithin 0 (Set.Ioi 0))","decl":"theorem eventually_measure_le_scaling_constant_mul (K : ℝ) :\n    ∀ᶠ r in 𝓝[>] 0, ∀ x, μ (closedBall x (K * r)) ≤ scalingConstantOf μ K * μ (closedBall x r) := by\n  filter_upwards [Classical.choose_spec\n      (exists_eventually_forall_measure_closedBall_le_mul μ K)] with r hr x\n  exact (hr x K le_rfl).trans (mul_le_mul_right' (ENNReal.coe_le_coe.2 (le_max_left _ _)) _)\n\n"}
{"name":"IsUnifLocDoublingMeasure.eventually_measure_le_scaling_constant_mul'","module":"Mathlib.MeasureTheory.Measure.Doubling","initialProofState":"α : Type u_1\ninst✝² : PseudoMetricSpace α\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : IsUnifLocDoublingMeasure μ\nK : Real\nhK : LT.lt 0 K\n⊢ Filter.Eventually (fun r => ∀ (x : α), LE.le (μ (Metric.closedBall x r)) (HMul.hMul (↑(IsUnifLocDoublingMeasure.scalingConstantOf μ (Inv.inv K))) (μ (Metric.closedBall x (HMul.hMul K r))))) (nhdsWithin 0 (Set.Ioi 0))","decl":"theorem eventually_measure_le_scaling_constant_mul' (K : ℝ) (hK : 0 < K) :\n    ∀ᶠ r in 𝓝[>] 0, ∀ x,\n      μ (closedBall x r) ≤ scalingConstantOf μ K⁻¹ * μ (closedBall x (K * r)) := by\n  convert eventually_nhdsGT_zero_mul_left hK (eventually_measure_le_scaling_constant_mul μ K⁻¹)\n  simp [inv_mul_cancel_left₀ hK.ne']\n\n"}
{"name":"IsUnifLocDoublingMeasure.scalingScaleOf_pos","module":"Mathlib.MeasureTheory.Measure.Doubling","initialProofState":"α : Type u_1\ninst✝² : PseudoMetricSpace α\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : IsUnifLocDoublingMeasure μ\nK : Real\n⊢ LT.lt 0 (IsUnifLocDoublingMeasure.scalingScaleOf μ K)","decl":"theorem scalingScaleOf_pos (K : ℝ) : 0 < scalingScaleOf μ K :=\n  (eventually_measure_mul_le_scalingConstantOf_mul μ K).choose_spec.1\n\n"}
{"name":"IsUnifLocDoublingMeasure.measure_mul_le_scalingConstantOf_mul","module":"Mathlib.MeasureTheory.Measure.Doubling","initialProofState":"α : Type u_1\ninst✝² : PseudoMetricSpace α\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : IsUnifLocDoublingMeasure μ\nK : Real\nx : α\nt r : Real\nht : Membership.mem (Set.Ioc 0 K) t\nhr : LE.le r (IsUnifLocDoublingMeasure.scalingScaleOf μ K)\n⊢ LE.le (μ (Metric.closedBall x (HMul.hMul t r))) (HMul.hMul (↑(IsUnifLocDoublingMeasure.scalingConstantOf μ K)) (μ (Metric.closedBall x r)))","decl":"theorem measure_mul_le_scalingConstantOf_mul {K : ℝ} {x : α} {t r : ℝ} (ht : t ∈ Ioc 0 K)\n    (hr : r ≤ scalingScaleOf μ K) :\n    μ (closedBall x (t * r)) ≤ scalingConstantOf μ K * μ (closedBall x r) :=\n  (eventually_measure_mul_le_scalingConstantOf_mul μ K).choose_spec.2 x t r ht hr\n\n"}
