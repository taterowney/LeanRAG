{"name":"CategoryTheory.Functor.IsLocalization.pi","module":"Mathlib.CategoryTheory.Localization.Pi","initialProofState":"J : Type w\ninst✝⁴ : Finite J\nC : J → Type u₁\nD : J → Type u₂\ninst✝³ : (j : J) → CategoryTheory.Category.{v₁, u₁} (C j)\ninst✝² : (j : J) → CategoryTheory.Category.{v₂, u₂} (D j)\nL : (j : J) → CategoryTheory.Functor (C j) (D j)\nW : (j : J) → CategoryTheory.MorphismProperty (C j)\ninst✝¹ : ∀ (j : J), (W j).ContainsIdentities\ninst✝ : ∀ (j : J), (L j).IsLocalization (W j)\n⊢ (CategoryTheory.Functor.pi L).IsLocalization (CategoryTheory.MorphismProperty.pi W)","decl":"instance pi {J : Type w} [Finite J] {C : J → Type u₁} {D : J → Type u₂}\n    [∀ j, Category.{v₁} (C j)] [∀ j, Category.{v₂} (D j)]\n    (L : ∀ j, C j ⥤ D j) (W : ∀ j, MorphismProperty (C j))\n    [∀ j, (W j).ContainsIdentities] [∀ j, (L j).IsLocalization (W j)] :\n    (Functor.pi L).IsLocalization (MorphismProperty.pi W) := by\n  revert J\n  apply Finite.induction_empty_option\n  · intro J₁ J₂ e hJ₁ C₂ D₂ _ _ L₂ W₂ _ _\n    let L₁ := fun j => (L₂ (e j))\n    let E := Pi.equivalenceOfEquiv C₂ e\n    let E' := Pi.equivalenceOfEquiv D₂ e\n    haveI : CatCommSq E.functor (Functor.pi L₁) (Functor.pi L₂) E'.functor :=\n      (CatCommSq.hInvEquiv E (Functor.pi L₁) (Functor.pi L₂) E').symm ⟨Iso.refl _⟩\n    refine IsLocalization.of_equivalences (Functor.pi L₁)\n      (MorphismProperty.pi (fun j => (W₂ (e j)))) (Functor.pi L₂)\n      (MorphismProperty.pi W₂) E E' ?_\n      (MorphismProperty.IsInvertedBy.pi _ _ (fun _ => Localization.inverts _ _))\n    intro _ _ f hf\n    refine ⟨_, _, E.functor.map f, fun i => ?_, ⟨Iso.refl _⟩⟩\n    have H : ∀ {j j' : J₂} (h : j = j') {X Y : C₂ j} (g : X ⟶ Y) (_ : W₂ j g),\n        W₂ j' ((Pi.eqToEquivalence C₂ h).functor.map g) := by\n      rintro j _ rfl _ _ g hg\n      exact hg\n    exact H (e.apply_symm_apply i) _ (hf (e.symm i))\n  · intro C D _ _ L W _ _\n    haveI : ∀ j, IsEquivalence (L j) := by rintro ⟨⟩\n    refine IsLocalization.of_isEquivalence _ _ (fun _ _ _ _ => ?_)\n    rw [MorphismProperty.isomorphisms.iff, isIso_pi_iff]\n    rintro ⟨⟩\n  · intro J _ hJ C D _ _ L W _ _\n    let L₁ := (L none).prod (Functor.pi (fun j => L (some j)))\n    haveI : CatCommSq (Pi.optionEquivalence C).symm.functor L₁ (Functor.pi L)\n      (Pi.optionEquivalence D).symm.functor :=\n        ⟨NatIso.pi' (by rintro (_|i) <;> apply Iso.refl)⟩\n    refine IsLocalization.of_equivalences L₁\n      ((W none).prod (MorphismProperty.pi (fun j => W (some j)))) (Functor.pi L) _\n      (Pi.optionEquivalence C).symm (Pi.optionEquivalence D).symm ?_ ?_\n    · intro ⟨X₁, X₂⟩ ⟨Y₁, Y₂⟩ f ⟨hf₁, hf₂⟩\n      refine ⟨_, _, (Pi.optionEquivalence C).inverse.map f, ?_, ⟨Iso.refl _⟩⟩\n      rintro (_|i)\n      · exact hf₁\n      · apply hf₂\n    · apply MorphismProperty.IsInvertedBy.pi\n      rintro (_|i) <;> apply Localization.inverts\n\n"}
{"name":"CategoryTheory.Functor.IsLocalization.instDiscreteObjWhiskeringRightFunctorCategoryOfFiniteOfContainsIdentities","module":"Mathlib.CategoryTheory.Localization.Pi","initialProofState":"J : Type\ninst✝⁴ : Finite J\nC : Type u₁\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : W.ContainsIdentities\ninst✝ : L.IsLocalization W\n⊢ ((CategoryTheory.whiskeringRight (CategoryTheory.Discrete J) C D).obj L).IsLocalization (W.functorCategory (CategoryTheory.Discrete J))","decl":"/-- If `L : C ⥤ D` is a localization functor for `W : MorphismProperty C`, then\nthe induced functor `(Discrete J ⥤ C) ⥤ (Discrete J ⥤ D)` is also a localization\nfor `W.functorCategory (Discrete J)` if `W` contains identities. -/\ninstance {J : Type} [Finite J] {C : Type u₁} {D : Type u₂} [Category.{v₁} C] [Category.{v₂} D]\n    (L : C ⥤ D) (W : MorphismProperty C) [W.ContainsIdentities] [L.IsLocalization W]  :\n    ((whiskeringRight (Discrete J) C D).obj L).IsLocalization\n      (W.functorCategory (Discrete J)) := by\n  let E := piEquivalenceFunctorDiscrete J C\n  let E' := piEquivalenceFunctorDiscrete J D\n  let L₂ := (whiskeringRight (Discrete J) C D).obj L\n  let L₁ := Functor.pi (fun (_ : J) => L)\n  have : CatCommSq E.functor L₁ L₂ E'.functor :=\n    ⟨(Functor.rightUnitor _).symm ≪≫ isoWhiskerLeft _ E'.counitIso.symm ≪≫\n      Functor.associator _ _ _≪≫ isoWhiskerLeft _ ((Functor.associator _ _ _).symm ≪≫\n      isoWhiskerRight (by exact Iso.refl _) _) ≪≫ (Functor.associator _ _ _).symm ≪≫\n      isoWhiskerRight ((Functor.associator _ _ _).symm ≪≫\n      isoWhiskerRight E.unitIso.symm L₁) _ ≪≫ isoWhiskerRight L₁.leftUnitor _⟩\n  refine Functor.IsLocalization.of_equivalences L₁\n    (MorphismProperty.pi (fun _ => W)) L₂ _ E E' ?_ ?_\n  · intro X Y f hf\n    exact MorphismProperty.le_isoClosure _ _ (fun ⟨j⟩ => hf j)\n  · intro X Y f hf\n    have : ∀ (j : Discrete J), IsIso ((L₂.map f).app j) :=\n      fun j => Localization.inverts L W _ (hf j)\n    apply NatIso.isIso_of_isIso_app\n\n"}
