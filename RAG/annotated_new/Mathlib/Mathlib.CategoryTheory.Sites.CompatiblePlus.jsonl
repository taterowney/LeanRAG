{"name":"CategoryTheory.GrothendieckTopology.diagramCompIso_hom_ι","module":"Mathlib.CategoryTheory.Sites.CompatiblePlus","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w₁\ninst✝⁴ : CategoryTheory.Category.{max v u, w₁} D\nE : Type w₂\ninst✝³ : CategoryTheory.Category.{max v u, w₂} E\nF : CategoryTheory.Functor D E\ninst✝² : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) D\ninst✝¹ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) E\ninst✝ : ∀ (X : C) (W : J.Cover X) (P : CategoryTheory.Functor (Opposite C) D), CategoryTheory.Limits.PreservesLimit (W.index P).multicospan F\nP : CategoryTheory.Functor (Opposite C) D\nX : C\nW : Opposite (J.Cover X)\ni : (Opposite.unop W).Arrow\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((J.diagramCompIso F P X).hom.app W) (CategoryTheory.Limits.Multiequalizer.ι ((Opposite.unop W).index (P.comp F)) i)) (F.map (CategoryTheory.Limits.Multiequalizer.ι ((Opposite.unop W).index P) i))","decl":"@[reassoc (attr := simp)]\ntheorem diagramCompIso_hom_ι (X : C) (W : (J.Cover X)ᵒᵖ) (i : W.unop.Arrow) :\n    (J.diagramCompIso F P X).hom.app W ≫ Multiequalizer.ι ((unop W).index (P ⋙ F)) i =\n  F.map (Multiequalizer.ι _ _) := by\n  delta diagramCompIso\n  dsimp\n  simp\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.diagramCompIso_hom_ι_assoc","module":"Mathlib.CategoryTheory.Sites.CompatiblePlus","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w₁\ninst✝⁴ : CategoryTheory.Category.{max v u, w₁} D\nE : Type w₂\ninst✝³ : CategoryTheory.Category.{max v u, w₂} E\nF : CategoryTheory.Functor D E\ninst✝² : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) D\ninst✝¹ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) E\ninst✝ : ∀ (X : C) (W : J.Cover X) (P : CategoryTheory.Functor (Opposite C) D), CategoryTheory.Limits.PreservesLimit (W.index P).multicospan F\nP : CategoryTheory.Functor (Opposite C) D\nX : C\nW : Opposite (J.Cover X)\ni : (Opposite.unop W).Arrow\nZ : E\nh : Quiver.Hom (((Opposite.unop W).index (P.comp F)).left i) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((J.diagramCompIso F P X).hom.app W) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multiequalizer.ι ((Opposite.unop W).index (P.comp F)) i) h)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Limits.Multiequalizer.ι ((Opposite.unop W).index P) i)) h)","decl":"@[reassoc (attr := simp)]\ntheorem diagramCompIso_hom_ι (X : C) (W : (J.Cover X)ᵒᵖ) (i : W.unop.Arrow) :\n    (J.diagramCompIso F P X).hom.app W ≫ Multiequalizer.ι ((unop W).index (P ⋙ F)) i =\n  F.map (Multiequalizer.ι _ _) := by\n  delta diagramCompIso\n  dsimp\n  simp\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.ι_plusCompIso_hom_assoc","module":"Mathlib.CategoryTheory.Sites.CompatiblePlus","initialProofState":"C : Type u\ninst✝⁸ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w₁\ninst✝⁷ : CategoryTheory.Category.{max v u, w₁} D\nE : Type w₂\ninst✝⁶ : CategoryTheory.Category.{max v u, w₂} E\nF : CategoryTheory.Functor D E\ninst✝⁵ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) D\ninst✝⁴ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) E\ninst✝³ : ∀ (X : C) (W : J.Cover X) (P : CategoryTheory.Functor (Opposite C) D), CategoryTheory.Limits.PreservesLimit (W.index P).multicospan F\nP : CategoryTheory.Functor (Opposite C) D\ninst✝² : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) E\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) F\nX : Opposite C\nW : Opposite (J.Cover (Opposite.unop X))\nZ : E\nh : Quiver.Hom ((J.plusObj (P.comp F)).obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Limits.colimit.ι (J.diagram P (Opposite.unop X)) W)) (CategoryTheory.CategoryStruct.comp ((J.plusCompIso F P).hom.app X) h)) (CategoryTheory.CategoryStruct.comp ((J.diagramCompIso F P (Opposite.unop X)).hom.app W) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (J.diagram (P.comp F) (Opposite.unop X)) W) h))","decl":"@[reassoc (attr := simp)]\ntheorem ι_plusCompIso_hom (X) (W) :\n    F.map (colimit.ι _ W) ≫ (J.plusCompIso F P).hom.app X =\n      (J.diagramCompIso F P X.unop).hom.app W ≫ colimit.ι _ W := by\n  delta diagramCompIso plusCompIso\n  simp only [IsColimit.descCoconeMorphism_hom, IsColimit.uniqueUpToIso_hom,\n    Cocones.forget_map, Iso.trans_hom, NatIso.ofComponents_hom_app, Functor.mapIso_hom, ←\n    Category.assoc]\n  erw [(isColimitOfPreserves F (colimit.isColimit (J.diagram P (unop X)))).fac]\n  simp\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.ι_plusCompIso_hom","module":"Mathlib.CategoryTheory.Sites.CompatiblePlus","initialProofState":"C : Type u\ninst✝⁸ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w₁\ninst✝⁷ : CategoryTheory.Category.{max v u, w₁} D\nE : Type w₂\ninst✝⁶ : CategoryTheory.Category.{max v u, w₂} E\nF : CategoryTheory.Functor D E\ninst✝⁵ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) D\ninst✝⁴ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) E\ninst✝³ : ∀ (X : C) (W : J.Cover X) (P : CategoryTheory.Functor (Opposite C) D), CategoryTheory.Limits.PreservesLimit (W.index P).multicospan F\nP : CategoryTheory.Functor (Opposite C) D\ninst✝² : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) E\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) F\nX : Opposite C\nW : Opposite (J.Cover (Opposite.unop X))\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Limits.colimit.ι (J.diagram P (Opposite.unop X)) W)) ((J.plusCompIso F P).hom.app X)) (CategoryTheory.CategoryStruct.comp ((J.diagramCompIso F P (Opposite.unop X)).hom.app W) (CategoryTheory.Limits.colimit.ι (J.diagram (P.comp F) (Opposite.unop X)) W))","decl":"@[reassoc (attr := simp)]\ntheorem ι_plusCompIso_hom (X) (W) :\n    F.map (colimit.ι _ W) ≫ (J.plusCompIso F P).hom.app X =\n      (J.diagramCompIso F P X.unop).hom.app W ≫ colimit.ι _ W := by\n  delta diagramCompIso plusCompIso\n  simp only [IsColimit.descCoconeMorphism_hom, IsColimit.uniqueUpToIso_hom,\n    Cocones.forget_map, Iso.trans_hom, NatIso.ofComponents_hom_app, Functor.mapIso_hom, ←\n    Category.assoc]\n  erw [(isColimitOfPreserves F (colimit.isColimit (J.diagram P (unop X)))).fac]\n  simp\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.plusCompIso_whiskerLeft_assoc","module":"Mathlib.CategoryTheory.Sites.CompatiblePlus","initialProofState":"C : Type u\ninst✝¹⁰ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w₁\ninst✝⁹ : CategoryTheory.Category.{max v u, w₁} D\nE : Type w₂\ninst✝⁸ : CategoryTheory.Category.{max v u, w₂} E\ninst✝⁷ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) D\ninst✝⁶ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) E\ninst✝⁵ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝⁴ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) E\nF G : CategoryTheory.Functor D E\nη : Quiver.Hom F G\nP : CategoryTheory.Functor (Opposite C) D\ninst✝³ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) F\ninst✝² : ∀ (X : C) (W : J.Cover X) (P : CategoryTheory.Functor (Opposite C) D), CategoryTheory.Limits.PreservesLimit (W.index P).multicospan F\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) G\ninst✝ : ∀ (X : C) (W : J.Cover X) (P : CategoryTheory.Functor (Opposite C) D), CategoryTheory.Limits.PreservesLimit (W.index P).multicospan G\nZ : CategoryTheory.Functor (Opposite C) E\nh : Quiver.Hom (J.plusObj (P.comp G)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft (J.plusObj P) η) (CategoryTheory.CategoryStruct.comp (J.plusCompIso G P).hom h)) (CategoryTheory.CategoryStruct.comp (J.plusCompIso F P).hom (CategoryTheory.CategoryStruct.comp (J.plusMap (CategoryTheory.whiskerLeft P η)) h))","decl":"@[reassoc (attr := simp)]\ntheorem plusCompIso_whiskerLeft {F G : D ⥤ E} (η : F ⟶ G) (P : Cᵒᵖ ⥤ D)\n    [∀ X : C, PreservesColimitsOfShape (J.Cover X)ᵒᵖ F]\n    [∀ (X : C) (W : J.Cover X) (P : Cᵒᵖ ⥤ D), PreservesLimit (W.index P).multicospan F]\n    [∀ X : C, PreservesColimitsOfShape (J.Cover X)ᵒᵖ G]\n    [∀ (X : C) (W : J.Cover X) (P : Cᵒᵖ ⥤ D), PreservesLimit (W.index P).multicospan G] :\n    whiskerLeft _ η ≫ (J.plusCompIso G P).hom =\n      (J.plusCompIso F P).hom ≫ J.plusMap (whiskerLeft _ η) := by\n  ext X\n  apply (isColimitOfPreserves F (colimit.isColimit (J.diagram P X.unop))).hom_ext\n  intro W\n  dsimp [plusObj, plusMap]\n  simp only [ι_plusCompIso_hom, ι_colimMap, whiskerLeft_app, ι_plusCompIso_hom_assoc,\n    NatTrans.naturality_assoc, GrothendieckTopology.diagramNatTrans_app]\n  simp only [← Category.assoc]\n  congr 1\n  aesop_cat\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.plusCompIso_whiskerLeft","module":"Mathlib.CategoryTheory.Sites.CompatiblePlus","initialProofState":"C : Type u\ninst✝¹⁰ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w₁\ninst✝⁹ : CategoryTheory.Category.{max v u, w₁} D\nE : Type w₂\ninst✝⁸ : CategoryTheory.Category.{max v u, w₂} E\ninst✝⁷ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) D\ninst✝⁶ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) E\ninst✝⁵ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝⁴ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) E\nF G : CategoryTheory.Functor D E\nη : Quiver.Hom F G\nP : CategoryTheory.Functor (Opposite C) D\ninst✝³ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) F\ninst✝² : ∀ (X : C) (W : J.Cover X) (P : CategoryTheory.Functor (Opposite C) D), CategoryTheory.Limits.PreservesLimit (W.index P).multicospan F\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) G\ninst✝ : ∀ (X : C) (W : J.Cover X) (P : CategoryTheory.Functor (Opposite C) D), CategoryTheory.Limits.PreservesLimit (W.index P).multicospan G\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft (J.plusObj P) η) (J.plusCompIso G P).hom) (CategoryTheory.CategoryStruct.comp (J.plusCompIso F P).hom (J.plusMap (CategoryTheory.whiskerLeft P η)))","decl":"@[reassoc (attr := simp)]\ntheorem plusCompIso_whiskerLeft {F G : D ⥤ E} (η : F ⟶ G) (P : Cᵒᵖ ⥤ D)\n    [∀ X : C, PreservesColimitsOfShape (J.Cover X)ᵒᵖ F]\n    [∀ (X : C) (W : J.Cover X) (P : Cᵒᵖ ⥤ D), PreservesLimit (W.index P).multicospan F]\n    [∀ X : C, PreservesColimitsOfShape (J.Cover X)ᵒᵖ G]\n    [∀ (X : C) (W : J.Cover X) (P : Cᵒᵖ ⥤ D), PreservesLimit (W.index P).multicospan G] :\n    whiskerLeft _ η ≫ (J.plusCompIso G P).hom =\n      (J.plusCompIso F P).hom ≫ J.plusMap (whiskerLeft _ η) := by\n  ext X\n  apply (isColimitOfPreserves F (colimit.isColimit (J.diagram P X.unop))).hom_ext\n  intro W\n  dsimp [plusObj, plusMap]\n  simp only [ι_plusCompIso_hom, ι_colimMap, whiskerLeft_app, ι_plusCompIso_hom_assoc,\n    NatTrans.naturality_assoc, GrothendieckTopology.diagramNatTrans_app]\n  simp only [← Category.assoc]\n  congr 1\n  aesop_cat\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.plusFunctorWhiskerLeftIso_inv_app","module":"Mathlib.CategoryTheory.Sites.CompatiblePlus","initialProofState":"C : Type u\ninst✝⁸ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w₁\ninst✝⁷ : CategoryTheory.Category.{max v u, w₁} D\nE : Type w₂\ninst✝⁶ : CategoryTheory.Category.{max v u, w₂} E\ninst✝⁵ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) D\ninst✝⁴ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) E\ninst✝³ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝² : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) E\nP : CategoryTheory.Functor (Opposite C) D\ninst✝¹ : ∀ (F : CategoryTheory.Functor D E) (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) F\ninst✝ : ∀ (F : CategoryTheory.Functor D E) (X : C) (W : J.Cover X) (P : CategoryTheory.Functor (Opposite C) D), CategoryTheory.Limits.PreservesLimit (W.index P).multicospan F\nX : CategoryTheory.Functor D E\n⊢ Eq ((J.plusFunctorWhiskerLeftIso P).inv.app X) (J.plusCompIso X P).inv","decl":"/-- The isomorphism between `P⁺ ⋙ F` and `(P ⋙ F)⁺`, functorially in `F`. -/\n@[simps! hom_app inv_app]\ndef plusFunctorWhiskerLeftIso (P : Cᵒᵖ ⥤ D)\n    [∀ (F : D ⥤ E) (X : C), PreservesColimitsOfShape (J.Cover X)ᵒᵖ F]\n    [∀ (F : D ⥤ E) (X : C) (W : J.Cover X) (P : Cᵒᵖ ⥤ D),\n        PreservesLimit (W.index P).multicospan F] :\n    (whiskeringLeft _ _ E).obj (J.plusObj P) ≅ (whiskeringLeft _ _ _).obj P ⋙ J.plusFunctor E :=\n  NatIso.ofComponents (fun _ => plusCompIso _ _ _) @fun _ _ _ => plusCompIso_whiskerLeft _ _ _\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.plusFunctorWhiskerLeftIso_hom_app","module":"Mathlib.CategoryTheory.Sites.CompatiblePlus","initialProofState":"C : Type u\ninst✝⁸ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w₁\ninst✝⁷ : CategoryTheory.Category.{max v u, w₁} D\nE : Type w₂\ninst✝⁶ : CategoryTheory.Category.{max v u, w₂} E\ninst✝⁵ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) D\ninst✝⁴ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) E\ninst✝³ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝² : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) E\nP : CategoryTheory.Functor (Opposite C) D\ninst✝¹ : ∀ (F : CategoryTheory.Functor D E) (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) F\ninst✝ : ∀ (F : CategoryTheory.Functor D E) (X : C) (W : J.Cover X) (P : CategoryTheory.Functor (Opposite C) D), CategoryTheory.Limits.PreservesLimit (W.index P).multicospan F\nX : CategoryTheory.Functor D E\n⊢ Eq ((J.plusFunctorWhiskerLeftIso P).hom.app X) (J.plusCompIso X P).hom","decl":"/-- The isomorphism between `P⁺ ⋙ F` and `(P ⋙ F)⁺`, functorially in `F`. -/\n@[simps! hom_app inv_app]\ndef plusFunctorWhiskerLeftIso (P : Cᵒᵖ ⥤ D)\n    [∀ (F : D ⥤ E) (X : C), PreservesColimitsOfShape (J.Cover X)ᵒᵖ F]\n    [∀ (F : D ⥤ E) (X : C) (W : J.Cover X) (P : Cᵒᵖ ⥤ D),\n        PreservesLimit (W.index P).multicospan F] :\n    (whiskeringLeft _ _ E).obj (J.plusObj P) ≅ (whiskeringLeft _ _ _).obj P ⋙ J.plusFunctor E :=\n  NatIso.ofComponents (fun _ => plusCompIso _ _ _) @fun _ _ _ => plusCompIso_whiskerLeft _ _ _\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.plusCompIso_whiskerRight_assoc","module":"Mathlib.CategoryTheory.Sites.CompatiblePlus","initialProofState":"C : Type u\ninst✝⁸ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w₁\ninst✝⁷ : CategoryTheory.Category.{max v u, w₁} D\nE : Type w₂\ninst✝⁶ : CategoryTheory.Category.{max v u, w₂} E\nF : CategoryTheory.Functor D E\ninst✝⁵ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) D\ninst✝⁴ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) E\ninst✝³ : ∀ (X : C) (W : J.Cover X) (P : CategoryTheory.Functor (Opposite C) D), CategoryTheory.Limits.PreservesLimit (W.index P).multicospan F\ninst✝² : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) E\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) F\nP Q : CategoryTheory.Functor (Opposite C) D\nη : Quiver.Hom P Q\nZ : CategoryTheory.Functor (Opposite C) E\nh : Quiver.Hom (J.plusObj (Q.comp F)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (J.plusMap η) F) (CategoryTheory.CategoryStruct.comp (J.plusCompIso F Q).hom h)) (CategoryTheory.CategoryStruct.comp (J.plusCompIso F P).hom (CategoryTheory.CategoryStruct.comp (J.plusMap (CategoryTheory.whiskerRight η F)) h))","decl":"@[reassoc (attr := simp)]\ntheorem plusCompIso_whiskerRight {P Q : Cᵒᵖ ⥤ D} (η : P ⟶ Q) :\n    whiskerRight (J.plusMap η) F ≫ (J.plusCompIso F Q).hom =\n      (J.plusCompIso F P).hom ≫ J.plusMap (whiskerRight η F) := by\n  ext X\n  apply (isColimitOfPreserves F (colimit.isColimit (J.diagram P X.unop))).hom_ext\n  intro W\n  dsimp [plusObj, plusMap]\n  simp only [ι_colimMap, whiskerRight_app, ι_plusCompIso_hom_assoc,\n    GrothendieckTopology.diagramNatTrans_app]\n  simp only [← Category.assoc, ← F.map_comp]\n  dsimp [colimMap, IsColimit.map]\n  simp only [colimit.ι_desc]\n  dsimp [Cocones.precompose]\n  simp only [Functor.map_comp, Category.assoc, ι_plusCompIso_hom]\n  simp only [← Category.assoc]\n  congr 1\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): this used to work with `ext`\n  apply Multiequalizer.hom_ext\n  intro a\n  dsimp\n  simp only [diagramCompIso_hom_ι_assoc, Multiequalizer.lift_ι, diagramCompIso_hom_ι,\n    Category.assoc]\n  simp only [← F.map_comp, Multiequalizer.lift_ι]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.plusCompIso_whiskerRight","module":"Mathlib.CategoryTheory.Sites.CompatiblePlus","initialProofState":"C : Type u\ninst✝⁸ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w₁\ninst✝⁷ : CategoryTheory.Category.{max v u, w₁} D\nE : Type w₂\ninst✝⁶ : CategoryTheory.Category.{max v u, w₂} E\nF : CategoryTheory.Functor D E\ninst✝⁵ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) D\ninst✝⁴ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) E\ninst✝³ : ∀ (X : C) (W : J.Cover X) (P : CategoryTheory.Functor (Opposite C) D), CategoryTheory.Limits.PreservesLimit (W.index P).multicospan F\ninst✝² : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) E\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) F\nP Q : CategoryTheory.Functor (Opposite C) D\nη : Quiver.Hom P Q\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (J.plusMap η) F) (J.plusCompIso F Q).hom) (CategoryTheory.CategoryStruct.comp (J.plusCompIso F P).hom (J.plusMap (CategoryTheory.whiskerRight η F)))","decl":"@[reassoc (attr := simp)]\ntheorem plusCompIso_whiskerRight {P Q : Cᵒᵖ ⥤ D} (η : P ⟶ Q) :\n    whiskerRight (J.plusMap η) F ≫ (J.plusCompIso F Q).hom =\n      (J.plusCompIso F P).hom ≫ J.plusMap (whiskerRight η F) := by\n  ext X\n  apply (isColimitOfPreserves F (colimit.isColimit (J.diagram P X.unop))).hom_ext\n  intro W\n  dsimp [plusObj, plusMap]\n  simp only [ι_colimMap, whiskerRight_app, ι_plusCompIso_hom_assoc,\n    GrothendieckTopology.diagramNatTrans_app]\n  simp only [← Category.assoc, ← F.map_comp]\n  dsimp [colimMap, IsColimit.map]\n  simp only [colimit.ι_desc]\n  dsimp [Cocones.precompose]\n  simp only [Functor.map_comp, Category.assoc, ι_plusCompIso_hom]\n  simp only [← Category.assoc]\n  congr 1\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): this used to work with `ext`\n  apply Multiequalizer.hom_ext\n  intro a\n  dsimp\n  simp only [diagramCompIso_hom_ι_assoc, Multiequalizer.lift_ι, diagramCompIso_hom_ι,\n    Category.assoc]\n  simp only [← F.map_comp, Multiequalizer.lift_ι]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.plusFunctorWhiskerRightIso_inv_app","module":"Mathlib.CategoryTheory.Sites.CompatiblePlus","initialProofState":"C : Type u\ninst✝⁸ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w₁\ninst✝⁷ : CategoryTheory.Category.{max v u, w₁} D\nE : Type w₂\ninst✝⁶ : CategoryTheory.Category.{max v u, w₂} E\nF : CategoryTheory.Functor D E\ninst✝⁵ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) D\ninst✝⁴ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) E\ninst✝³ : ∀ (X : C) (W : J.Cover X) (P : CategoryTheory.Functor (Opposite C) D), CategoryTheory.Limits.PreservesLimit (W.index P).multicospan F\ninst✝² : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) E\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) F\nX : CategoryTheory.Functor (Opposite C) D\n⊢ Eq ((J.plusFunctorWhiskerRightIso F).inv.app X) (J.plusCompIso F X).inv","decl":"/-- The isomorphism between `P⁺ ⋙ F` and `(P ⋙ F)⁺`, functorially in `P`. -/\n@[simps! hom_app inv_app]\ndef plusFunctorWhiskerRightIso :\n    J.plusFunctor D ⋙ (whiskeringRight _ _ _).obj F ≅\n      (whiskeringRight _ _ _).obj F ⋙ J.plusFunctor E :=\n  NatIso.ofComponents (fun _ => J.plusCompIso _ _) @fun _ _ _ => plusCompIso_whiskerRight _ _ _\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.plusFunctorWhiskerRightIso_hom_app","module":"Mathlib.CategoryTheory.Sites.CompatiblePlus","initialProofState":"C : Type u\ninst✝⁸ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w₁\ninst✝⁷ : CategoryTheory.Category.{max v u, w₁} D\nE : Type w₂\ninst✝⁶ : CategoryTheory.Category.{max v u, w₂} E\nF : CategoryTheory.Functor D E\ninst✝⁵ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) D\ninst✝⁴ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) E\ninst✝³ : ∀ (X : C) (W : J.Cover X) (P : CategoryTheory.Functor (Opposite C) D), CategoryTheory.Limits.PreservesLimit (W.index P).multicospan F\ninst✝² : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) E\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) F\nX : CategoryTheory.Functor (Opposite C) D\n⊢ Eq ((J.plusFunctorWhiskerRightIso F).hom.app X) (J.plusCompIso F X).hom","decl":"/-- The isomorphism between `P⁺ ⋙ F` and `(P ⋙ F)⁺`, functorially in `P`. -/\n@[simps! hom_app inv_app]\ndef plusFunctorWhiskerRightIso :\n    J.plusFunctor D ⋙ (whiskeringRight _ _ _).obj F ≅\n      (whiskeringRight _ _ _).obj F ⋙ J.plusFunctor E :=\n  NatIso.ofComponents (fun _ => J.plusCompIso _ _) @fun _ _ _ => plusCompIso_whiskerRight _ _ _\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.whiskerRight_toPlus_comp_plusCompIso_hom","module":"Mathlib.CategoryTheory.Sites.CompatiblePlus","initialProofState":"C : Type u\ninst✝⁸ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w₁\ninst✝⁷ : CategoryTheory.Category.{max v u, w₁} D\nE : Type w₂\ninst✝⁶ : CategoryTheory.Category.{max v u, w₂} E\nF : CategoryTheory.Functor D E\ninst✝⁵ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) D\ninst✝⁴ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) E\ninst✝³ : ∀ (X : C) (W : J.Cover X) (P : CategoryTheory.Functor (Opposite C) D), CategoryTheory.Limits.PreservesLimit (W.index P).multicospan F\nP : CategoryTheory.Functor (Opposite C) D\ninst✝² : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) E\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) F\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (J.toPlus P) F) (J.plusCompIso F P).hom) (J.toPlus (P.comp F))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerRight_toPlus_comp_plusCompIso_hom :\n    whiskerRight (J.toPlus _) _ ≫ (J.plusCompIso F P).hom = J.toPlus _ := by\n  ext\n  dsimp [toPlus]\n  simp only [ι_plusCompIso_hom, Functor.map_comp, Category.assoc]\n  simp only [← Category.assoc]\n  congr 1\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): was ext\n  apply Multiequalizer.hom_ext; intro a\n  rw [Category.assoc, diagramCompIso_hom_ι, ← F.map_comp]\n  simp only [unop_op, limit.lift_π, Multifork.ofι_π_app, Functor.comp_obj, Functor.comp_map]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.whiskerRight_toPlus_comp_plusCompIso_hom_assoc","module":"Mathlib.CategoryTheory.Sites.CompatiblePlus","initialProofState":"C : Type u\ninst✝⁸ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w₁\ninst✝⁷ : CategoryTheory.Category.{max v u, w₁} D\nE : Type w₂\ninst✝⁶ : CategoryTheory.Category.{max v u, w₂} E\nF : CategoryTheory.Functor D E\ninst✝⁵ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) D\ninst✝⁴ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) E\ninst✝³ : ∀ (X : C) (W : J.Cover X) (P : CategoryTheory.Functor (Opposite C) D), CategoryTheory.Limits.PreservesLimit (W.index P).multicospan F\nP : CategoryTheory.Functor (Opposite C) D\ninst✝² : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) E\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) F\nZ : CategoryTheory.Functor (Opposite C) E\nh : Quiver.Hom (J.plusObj (P.comp F)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (J.toPlus P) F) (CategoryTheory.CategoryStruct.comp (J.plusCompIso F P).hom h)) (CategoryTheory.CategoryStruct.comp (J.toPlus (P.comp F)) h)","decl":"@[reassoc (attr := simp)]\ntheorem whiskerRight_toPlus_comp_plusCompIso_hom :\n    whiskerRight (J.toPlus _) _ ≫ (J.plusCompIso F P).hom = J.toPlus _ := by\n  ext\n  dsimp [toPlus]\n  simp only [ι_plusCompIso_hom, Functor.map_comp, Category.assoc]\n  simp only [← Category.assoc]\n  congr 1\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): was ext\n  apply Multiequalizer.hom_ext; intro a\n  rw [Category.assoc, diagramCompIso_hom_ι, ← F.map_comp]\n  simp only [unop_op, limit.lift_π, Multifork.ofι_π_app, Functor.comp_obj, Functor.comp_map]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.toPlus_comp_plusCompIso_inv","module":"Mathlib.CategoryTheory.Sites.CompatiblePlus","initialProofState":"C : Type u\ninst✝⁸ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w₁\ninst✝⁷ : CategoryTheory.Category.{max v u, w₁} D\nE : Type w₂\ninst✝⁶ : CategoryTheory.Category.{max v u, w₂} E\nF : CategoryTheory.Functor D E\ninst✝⁵ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) D\ninst✝⁴ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) E\ninst✝³ : ∀ (X : C) (W : J.Cover X) (P : CategoryTheory.Functor (Opposite C) D), CategoryTheory.Limits.PreservesLimit (W.index P).multicospan F\nP : CategoryTheory.Functor (Opposite C) D\ninst✝² : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) E\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) F\n⊢ Eq (CategoryTheory.CategoryStruct.comp (J.toPlus (P.comp F)) (J.plusCompIso F P).inv) (CategoryTheory.whiskerRight (J.toPlus P) F)","decl":"@[simp]\ntheorem toPlus_comp_plusCompIso_inv :\n    J.toPlus _ ≫ (J.plusCompIso F P).inv = whiskerRight (J.toPlus _) _ := by simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.plusCompIso_inv_eq_plusLift","module":"Mathlib.CategoryTheory.Sites.CompatiblePlus","initialProofState":"C : Type u\ninst✝⁸ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w₁\ninst✝⁷ : CategoryTheory.Category.{max v u, w₁} D\nE : Type w₂\ninst✝⁶ : CategoryTheory.Category.{max v u, w₂} E\nF : CategoryTheory.Functor D E\ninst✝⁵ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) D\ninst✝⁴ : ∀ (α β : Type (max v u)) (fst snd : β → α), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) E\ninst✝³ : ∀ (X : C) (W : J.Cover X) (P : CategoryTheory.Functor (Opposite C) D), CategoryTheory.Limits.PreservesLimit (W.index P).multicospan F\nP : CategoryTheory.Functor (Opposite C) D\ninst✝² : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) E\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) F\nhP : CategoryTheory.Presheaf.IsSheaf J ((J.plusObj P).comp F)\n⊢ Eq (J.plusCompIso F P).inv (J.plusLift (CategoryTheory.whiskerRight (J.toPlus P) F) hP)","decl":"theorem plusCompIso_inv_eq_plusLift (hP : Presheaf.IsSheaf J (J.plusObj P ⋙ F)) :\n    (J.plusCompIso F P).inv = J.plusLift (whiskerRight (J.toPlus _) _) hP := by\n  apply J.plusLift_unique\n  simp [Iso.comp_inv_eq]\n\n"}
