{"name":"TopCat.partialSections.nonempty","module":"Mathlib.Topology.Category.TopCat.Limits.Konig","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J TopCat\ninst✝ : CategoryTheory.IsCofilteredOrEmpty J\nh : ∀ (j : J), Nonempty ↑(F.obj j)\nG : Finset J\nH : Finset (TopCat.FiniteDiagramArrow G)\n⊢ (TopCat.partialSections F H).Nonempty","decl":"theorem partialSections.nonempty [IsCofilteredOrEmpty J] [h : ∀ j : J, Nonempty (F.obj j)]\n    {G : Finset J} (H : Finset (FiniteDiagramArrow G)) : (partialSections F H).Nonempty := by\n  classical\n  cases isEmpty_or_nonempty J\n  · exact ⟨isEmptyElim, fun {j} => IsEmpty.elim' inferInstance j.1⟩\n  haveI : IsCofiltered J := ⟨⟩\n  use fun j : J =>\n    if hj : j ∈ G then F.map (IsCofiltered.infTo G H hj) (h (IsCofiltered.inf G H)).some\n    else (h _).some\n  rintro ⟨X, Y, hX, hY, f⟩ hf\n  dsimp only\n  rwa [dif_pos hX, dif_pos hY, ← comp_app, ← F.map_comp, @IsCofiltered.infTo_commutes _ _ _ G H]\n\n"}
{"name":"TopCat.partialSections.directed","module":"Mathlib.Topology.Category.TopCat.Limits.Konig","initialProofState":"J : Type u\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J TopCat\n⊢ Directed Superset fun G => TopCat.partialSections F G.snd","decl":"theorem partialSections.directed :\n    Directed Superset fun G : FiniteDiagram J => partialSections F G.2 := by\n  classical\n  intro A B\n  let ιA : FiniteDiagramArrow A.1 → FiniteDiagramArrow (A.1 ⊔ B.1) := fun f =>\n    ⟨f.1, f.2.1, Finset.mem_union_left _ f.2.2.1, Finset.mem_union_left _ f.2.2.2.1, f.2.2.2.2⟩\n  let ιB : FiniteDiagramArrow B.1 → FiniteDiagramArrow (A.1 ⊔ B.1) := fun f =>\n    ⟨f.1, f.2.1, Finset.mem_union_right _ f.2.2.1, Finset.mem_union_right _ f.2.2.2.1, f.2.2.2.2⟩\n  refine ⟨⟨A.1 ⊔ B.1, A.2.image ιA ⊔ B.2.image ιB⟩, ?_, ?_⟩\n  · rintro u hu f hf\n    have : ιA f ∈ A.2.image ιA ⊔ B.2.image ιB := by\n      apply Finset.mem_union_left\n      rw [Finset.mem_image]\n      exact ⟨f, hf, rfl⟩\n    exact hu this\n  · rintro u hu f hf\n    have : ιB f ∈ A.2.image ιA ⊔ B.2.image ιB := by\n      apply Finset.mem_union_right\n      rw [Finset.mem_image]\n      exact ⟨f, hf, rfl⟩\n    exact hu this\n\n"}
{"name":"TopCat.partialSections.closed","module":"Mathlib.Topology.Category.TopCat.Limits.Konig","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J TopCat\ninst✝ : ∀ (j : J), T2Space ↑(F.obj j)\nG : Finset J\nH : Finset (TopCat.FiniteDiagramArrow G)\n⊢ IsClosed (TopCat.partialSections F H)","decl":"theorem partialSections.closed [∀ j : J, T2Space (F.obj j)] {G : Finset J}\n    (H : Finset (FiniteDiagramArrow G)) : IsClosed (partialSections F H) := by\n  have :\n    partialSections F H =\n      ⋂ (f : FiniteDiagramArrow G) (_ : f ∈ H), {u | F.map f.2.2.2.2 (u f.1) = u f.2.1} := by\n    ext1\n    simp only [Set.mem_iInter, Set.mem_setOf_eq]\n    rfl\n  rw [this]\n  apply isClosed_biInter\n  intro f _\n  -- Porting note: can't see through forget\n  have : T2Space ((forget TopCat).obj (F.obj f.snd.fst)) :=\n    inferInstanceAs (T2Space (F.obj f.snd.fst))\n  apply isClosed_eq\n  -- Porting note: used to be a single `continuity` that closed both goals\n  · exact (F.map f.snd.snd.snd.snd).continuous.comp (continuous_apply f.fst)\n  · continuity\n\n"}
{"name":"TopCat.nonempty_limitCone_of_compact_t2_cofiltered_system","module":"Mathlib.Topology.Category.TopCat.Limits.Konig","initialProofState":"J : Type u\ninst✝⁴ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J TopCat\ninst✝³ : CategoryTheory.IsCofilteredOrEmpty J\ninst✝² : ∀ (j : J), Nonempty ↑(F.obj j)\ninst✝¹ : ∀ (j : J), CompactSpace ↑(F.obj j)\ninst✝ : ∀ (j : J), T2Space ↑(F.obj j)\n⊢ Nonempty ↑(TopCat.limitCone F).pt","decl":"/-- Cofiltered limits of nonempty compact Hausdorff spaces are nonempty topological spaces.\n-/\n-- Porting note: generalized from `TopCat.{u}` to `TopCat.{max v u}`\ntheorem nonempty_limitCone_of_compact_t2_cofiltered_system (F : J ⥤ TopCat.{max v u})\n    [IsCofilteredOrEmpty J]\n    [∀ j : J, Nonempty (F.obj j)] [∀ j : J, CompactSpace (F.obj j)] [∀ j : J, T2Space (F.obj j)] :\n    Nonempty (TopCat.limitCone F).pt := by\n  classical\n  obtain ⟨u, hu⟩ :=\n    IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed (fun G => partialSections F _)\n      (partialSections.directed F) (fun G => partialSections.nonempty F _)\n      (fun G => IsClosed.isCompact (partialSections.closed F _)) fun G =>\n      partialSections.closed F _\n  use u\n  intro X Y f\n  let G : FiniteDiagram J :=\n    ⟨{X, Y},\n      {⟨X, Y, by simp only [true_or, eq_self_iff_true, Finset.mem_insert], by\n          simp only [eq_self_iff_true, or_true, Finset.mem_insert, Finset.mem_singleton], f⟩}⟩\n  exact hu _ ⟨G, rfl⟩ (Finset.mem_singleton_self _)\n\n"}
