{"name":"SMulZeroClass.smul_zero","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"M : Type u_7\nA : Type u_8\ninst✝ : Zero A\nself : SMulZeroClass M A\na : M\n⊢ Eq (HSMul.hSMul a 0) 0","decl":"/-- Typeclass for scalar multiplication that preserves `0` on the right. -/\nclass SMulZeroClass (M A : Type*) [Zero A] extends SMul M A where\n  /-- Multiplying `0` by a scalar gives `0` -/\n  smul_zero : ∀ a : M, a • (0 : A) = 0\n\n"}
{"name":"smul_zero","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"M : Type u_1\nA : Type u_3\ninst✝¹ : Zero A\ninst✝ : SMulZeroClass M A\na : M\n⊢ Eq (HSMul.hSMul a 0) 0","decl":"@[simp]\ntheorem smul_zero (a : M) : a • (0 : A) = 0 :=\n  SMulZeroClass.smul_zero _\n\n"}
{"name":"smul_ite_zero","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"M : Type u_1\nA : Type u_3\ninst✝² : Zero A\ninst✝¹ : SMulZeroClass M A\np : Prop\ninst✝ : Decidable p\na : M\nb : A\n⊢ Eq (HSMul.hSMul a (ite p b 0)) (ite p (HSMul.hSMul a b) 0)","decl":"lemma smul_ite_zero (p : Prop) [Decidable p] (a : M) (b : A) :\n    (a • if p then b else 0) = if p then a • b else 0 := by split_ifs <;> simp\n\n"}
{"name":"smul_eq_zero_of_right","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"M : Type u_1\nA : Type u_3\ninst✝¹ : Zero A\ninst✝ : SMulZeroClass M A\na : M\nb : A\nh : Eq b 0\n⊢ Eq (HSMul.hSMul a b) 0","decl":"lemma smul_eq_zero_of_right (a : M) {b : A} (h : b = 0) : a • b = 0 := h.symm ▸ smul_zero a\n"}
{"name":"right_ne_zero_of_smul","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"M : Type u_1\nA : Type u_3\ninst✝¹ : Zero A\ninst✝ : SMulZeroClass M A\na : M\nb : A\na✝ : Ne (HSMul.hSMul a b) 0\n⊢ Ne b 0","decl":"lemma right_ne_zero_of_smul {a : M} {b : A} : a • b ≠ 0 → b ≠ 0 := mt <| smul_eq_zero_of_right a\n\n"}
{"name":"SMulZeroClass.toZeroHom_apply","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"M : Type u_1\nA : Type u_3\ninst✝¹ : Zero A\ninst✝ : SMulZeroClass M A\nx : M\nx✝ : A\n⊢ Eq ((SMulZeroClass.toZeroHom A x) x✝) (HSMul.hSMul x x✝)","decl":"/-- Each element of the scalars defines a zero-preserving map. -/\n@[simps]\ndef SMulZeroClass.toZeroHom (x : M) :\n    ZeroHom A A where\n  toFun := (x • ·)\n  map_zero' := smul_zero x\n\n"}
{"name":"DistribSMul.ext","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"M : Type u_7\nA : Type u_8\ninst✝ : AddZeroClass A\nx y : DistribSMul M A\nsmul : Eq SMul.smul SMul.smul\n⊢ Eq x y","decl":"/-- Typeclass for scalar multiplication that preserves `0` and `+` on the right.\n\nThis is exactly `DistribMulAction` without the `MulAction` part.\n-/\n@[ext]\nclass DistribSMul (M A : Type*) [AddZeroClass A] extends SMulZeroClass M A where\n  /-- Scalar multiplication distributes across addition -/\n  smul_add : ∀ (a : M) (x y : A), a • (x + y) = a • x + a • y\n\n"}
{"name":"DistribSMul.ext_iff","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"M : Type u_7\nA : Type u_8\ninst✝ : AddZeroClass A\nx y : DistribSMul M A\n⊢ Iff (Eq x y) (Eq SMul.smul SMul.smul)","decl":"/-- Typeclass for scalar multiplication that preserves `0` and `+` on the right.\n\nThis is exactly `DistribMulAction` without the `MulAction` part.\n-/\n@[ext]\nclass DistribSMul (M A : Type*) [AddZeroClass A] extends SMulZeroClass M A where\n  /-- Scalar multiplication distributes across addition -/\n  smul_add : ∀ (a : M) (x y : A), a • (x + y) = a • x + a • y\n\n"}
{"name":"DistribSMul.smul_add","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"M : Type u_7\nA : Type u_8\ninst✝ : AddZeroClass A\nself : DistribSMul M A\na : M\nx y : A\n⊢ Eq (HSMul.hSMul a (HAdd.hAdd x y)) (HAdd.hAdd (HSMul.hSMul a x) (HSMul.hSMul a y))","decl":"/-- Typeclass for scalar multiplication that preserves `0` and `+` on the right.\n\nThis is exactly `DistribMulAction` without the `MulAction` part.\n-/\n@[ext]\nclass DistribSMul (M A : Type*) [AddZeroClass A] extends SMulZeroClass M A where\n  /-- Scalar multiplication distributes across addition -/\n  smul_add : ∀ (a : M) (x y : A), a • (x + y) = a • x + a • y\n\n"}
{"name":"smul_add","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"M : Type u_1\nA : Type u_3\ninst✝¹ : AddZeroClass A\ninst✝ : DistribSMul M A\na : M\nb₁ b₂ : A\n⊢ Eq (HSMul.hSMul a (HAdd.hAdd b₁ b₂)) (HAdd.hAdd (HSMul.hSMul a b₁) (HSMul.hSMul a b₂))","decl":"theorem smul_add (a : M) (b₁ b₂ : A) : a • (b₁ + b₂) = a • b₁ + a • b₂ :=\n  DistribSMul.smul_add _ _ _\n\n"}
{"name":"DistribSMul.toAddMonoidHom_apply","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"M : Type u_1\nA : Type u_3\ninst✝¹ : AddZeroClass A\ninst✝ : DistribSMul M A\nx : M\nx✝ : A\n⊢ Eq ((DistribSMul.toAddMonoidHom A x) x✝) (HSMul.hSMul x x✝)","decl":"/-- Each element of the scalars defines an additive monoid homomorphism. -/\n@[simps]\ndef DistribSMul.toAddMonoidHom (x : M) : A →+ A :=\n  { SMulZeroClass.toZeroHom A x with toFun := (x • ·), map_add' := smul_add x }\n\n"}
{"name":"DistribMulAction.ext","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"M : Type u_7\nA : Type u_8\ninst✝¹ : Monoid M\ninst✝ : AddMonoid A\nx y : DistribMulAction M A\nsmul : Eq SMul.smul SMul.smul\n⊢ Eq x y","decl":"/-- Typeclass for multiplicative actions on additive structures. This generalizes group modules. -/\n@[ext]\nclass DistribMulAction (M A : Type*) [Monoid M] [AddMonoid A] extends MulAction M A where\n  /-- Multiplying `0` by a scalar gives `0` -/\n  smul_zero : ∀ a : M, a • (0 : A) = 0\n  /-- Scalar multiplication distributes across addition -/\n  smul_add : ∀ (a : M) (x y : A), a • (x + y) = a • x + a • y\n\n"}
{"name":"DistribMulAction.smul_add","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"M : Type u_7\nA : Type u_8\ninst✝¹ : Monoid M\ninst✝ : AddMonoid A\nself : DistribMulAction M A\na : M\nx y : A\n⊢ Eq (HSMul.hSMul a (HAdd.hAdd x y)) (HAdd.hAdd (HSMul.hSMul a x) (HSMul.hSMul a y))","decl":"/-- Typeclass for multiplicative actions on additive structures. This generalizes group modules. -/\n@[ext]\nclass DistribMulAction (M A : Type*) [Monoid M] [AddMonoid A] extends MulAction M A where\n  /-- Multiplying `0` by a scalar gives `0` -/\n  smul_zero : ∀ a : M, a • (0 : A) = 0\n  /-- Scalar multiplication distributes across addition -/\n  smul_add : ∀ (a : M) (x y : A), a • (x + y) = a • x + a • y\n\n"}
{"name":"DistribMulAction.ext_iff","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"M : Type u_7\nA : Type u_8\ninst✝¹ : Monoid M\ninst✝ : AddMonoid A\nx y : DistribMulAction M A\n⊢ Iff (Eq x y) (Eq SMul.smul SMul.smul)","decl":"/-- Typeclass for multiplicative actions on additive structures. This generalizes group modules. -/\n@[ext]\nclass DistribMulAction (M A : Type*) [Monoid M] [AddMonoid A] extends MulAction M A where\n  /-- Multiplying `0` by a scalar gives `0` -/\n  smul_zero : ∀ a : M, a • (0 : A) = 0\n  /-- Scalar multiplication distributes across addition -/\n  smul_add : ∀ (a : M) (x y : A), a • (x + y) = a • x + a • y\n\n"}
{"name":"DistribMulAction.smul_zero","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"M : Type u_7\nA : Type u_8\ninst✝¹ : Monoid M\ninst✝ : AddMonoid A\nself : DistribMulAction M A\na : M\n⊢ Eq (HSMul.hSMul a 0) 0","decl":"/-- Typeclass for multiplicative actions on additive structures. This generalizes group modules. -/\n@[ext]\nclass DistribMulAction (M A : Type*) [Monoid M] [AddMonoid A] extends MulAction M A where\n  /-- Multiplying `0` by a scalar gives `0` -/\n  smul_zero : ∀ a : M, a • (0 : A) = 0\n  /-- Scalar multiplication distributes across addition -/\n  smul_add : ∀ (a : M) (x y : A), a • (x + y) = a • x + a • y\n\n"}
{"name":"DistribMulAction.toAddMonoidHom_apply","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"M : Type u_1\nA : Type u_3\ninst✝² : Monoid M\ninst✝¹ : AddMonoid A\ninst✝ : DistribMulAction M A\nx : M\nx✝ : A\n⊢ Eq ((DistribMulAction.toAddMonoidHom A x) x✝) (HSMul.hSMul x x✝)","decl":"/-- Each element of the monoid defines an additive monoid homomorphism. -/\n@[simps!]\ndef DistribMulAction.toAddMonoidHom (x : M) : A →+ A :=\n  DistribSMul.toAddMonoidHom A x\n\n"}
{"name":"DistribMulAction.toAddMonoidEnd_apply","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"M : Type u_1\nA : Type u_3\ninst✝² : Monoid M\ninst✝¹ : AddMonoid A\ninst✝ : DistribMulAction M A\nx : M\n⊢ Eq ((DistribMulAction.toAddMonoidEnd M A) x) (DistribMulAction.toAddMonoidHom A x)","decl":"/-- Each element of the monoid defines an additive monoid homomorphism. -/\n@[simps]\ndef DistribMulAction.toAddMonoidEnd :\n    M →* AddMonoid.End A where\n  toFun := DistribMulAction.toAddMonoidHom A\n  map_one' := AddMonoidHom.ext <| one_smul M\n  map_mul' x y := AddMonoidHom.ext <| mul_smul x y\n\n"}
{"name":"AddMonoid.nat_smulCommClass","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"M : Type u_1\nA : Type u_3\ninst✝² : Monoid M\ninst✝¹ : AddMonoid A\ninst✝ : DistribMulAction M A\n⊢ SMulCommClass Nat M A","decl":"instance AddMonoid.nat_smulCommClass :\n    SMulCommClass ℕ M\n      A where smul_comm n x y := ((DistribMulAction.toAddMonoidHom A x).map_nsmul y n).symm\n\n-- `SMulCommClass.symm` is not registered as an instance, as it would cause a loop\n"}
{"name":"AddMonoid.nat_smulCommClass'","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"M : Type u_1\nA : Type u_3\ninst✝² : Monoid M\ninst✝¹ : AddMonoid A\ninst✝ : DistribMulAction M A\n⊢ SMulCommClass M Nat A","decl":"instance AddMonoid.nat_smulCommClass' : SMulCommClass M ℕ A :=\n  SMulCommClass.symm _ _ _\n\n"}
{"name":"AddGroup.int_smulCommClass","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"M : Type u_1\nA : Type u_3\ninst✝² : Monoid M\ninst✝¹ : AddGroup A\ninst✝ : DistribMulAction M A\n⊢ SMulCommClass Int M A","decl":"instance AddGroup.int_smulCommClass : SMulCommClass ℤ M A where\n  smul_comm n x y := ((DistribMulAction.toAddMonoidHom A x).map_zsmul y n).symm\n\n-- `SMulCommClass.symm` is not registered as an instance, as it would cause a loop\n"}
{"name":"AddGroup.int_smulCommClass'","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"M : Type u_1\nA : Type u_3\ninst✝² : Monoid M\ninst✝¹ : AddGroup A\ninst✝ : DistribMulAction M A\n⊢ SMulCommClass M Int A","decl":"instance AddGroup.int_smulCommClass' : SMulCommClass M ℤ A :=\n  SMulCommClass.symm _ _ _\n\n"}
{"name":"smul_neg","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"M : Type u_1\nA : Type u_3\ninst✝² : Monoid M\ninst✝¹ : AddGroup A\ninst✝ : DistribMulAction M A\nr : M\nx : A\n⊢ Eq (HSMul.hSMul r (Neg.neg x)) (Neg.neg (HSMul.hSMul r x))","decl":"@[simp]\ntheorem smul_neg (r : M) (x : A) : r • -x = -(r • x) :=\n  eq_neg_of_add_eq_zero_left <| by rw [← smul_add, neg_add_cancel, smul_zero]\n\n"}
{"name":"smul_sub","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"M : Type u_1\nA : Type u_3\ninst✝² : Monoid M\ninst✝¹ : AddGroup A\ninst✝ : DistribMulAction M A\nr : M\nx y : A\n⊢ Eq (HSMul.hSMul r (HSub.hSub x y)) (HSub.hSub (HSMul.hSMul r x) (HSMul.hSMul r y))","decl":"theorem smul_sub (r : M) (x y : A) : r • (x - y) = r • x - r • y := by\n  rw [sub_eq_add_neg, sub_eq_add_neg, smul_add, smul_neg]\n\n"}
{"name":"MulDistribMulAction.smul_mul","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"M : Type u_7\nA : Type u_8\ninst✝¹ : Monoid M\ninst✝ : Monoid A\nself : MulDistribMulAction M A\nr : M\nx y : A\n⊢ Eq (HSMul.hSMul r (HMul.hMul x y)) (HMul.hMul (HSMul.hSMul r x) (HSMul.hSMul r y))","decl":"/-- Typeclass for multiplicative actions on multiplicative structures. This generalizes\nconjugation actions. -/\n@[ext]\nclass MulDistribMulAction (M : Type*) (A : Type*) [Monoid M] [Monoid A] extends\n  MulAction M A where\n  /-- Distributivity of `•` across `*` -/\n  smul_mul : ∀ (r : M) (x y : A), r • (x * y) = r • x * r • y\n  /-- Multiplying `1` by a scalar gives `1` -/\n  smul_one : ∀ r : M, r • (1 : A) = 1\n\n"}
{"name":"MulDistribMulAction.ext_iff","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"M : Type u_7\nA : Type u_8\ninst✝¹ : Monoid M\ninst✝ : Monoid A\nx y : MulDistribMulAction M A\n⊢ Iff (Eq x y) (Eq SMul.smul SMul.smul)","decl":"/-- Typeclass for multiplicative actions on multiplicative structures. This generalizes\nconjugation actions. -/\n@[ext]\nclass MulDistribMulAction (M : Type*) (A : Type*) [Monoid M] [Monoid A] extends\n  MulAction M A where\n  /-- Distributivity of `•` across `*` -/\n  smul_mul : ∀ (r : M) (x y : A), r • (x * y) = r • x * r • y\n  /-- Multiplying `1` by a scalar gives `1` -/\n  smul_one : ∀ r : M, r • (1 : A) = 1\n\n"}
{"name":"MulDistribMulAction.ext","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"M : Type u_7\nA : Type u_8\ninst✝¹ : Monoid M\ninst✝ : Monoid A\nx y : MulDistribMulAction M A\nsmul : Eq SMul.smul SMul.smul\n⊢ Eq x y","decl":"/-- Typeclass for multiplicative actions on multiplicative structures. This generalizes\nconjugation actions. -/\n@[ext]\nclass MulDistribMulAction (M : Type*) (A : Type*) [Monoid M] [Monoid A] extends\n  MulAction M A where\n  /-- Distributivity of `•` across `*` -/\n  smul_mul : ∀ (r : M) (x y : A), r • (x * y) = r • x * r • y\n  /-- Multiplying `1` by a scalar gives `1` -/\n  smul_one : ∀ r : M, r • (1 : A) = 1\n\n"}
{"name":"MulDistribMulAction.smul_one","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"M : Type u_7\nA : Type u_8\ninst✝¹ : Monoid M\ninst✝ : Monoid A\nself : MulDistribMulAction M A\nr : M\n⊢ Eq (HSMul.hSMul r 1) 1","decl":"/-- Typeclass for multiplicative actions on multiplicative structures. This generalizes\nconjugation actions. -/\n@[ext]\nclass MulDistribMulAction (M : Type*) (A : Type*) [Monoid M] [Monoid A] extends\n  MulAction M A where\n  /-- Distributivity of `•` across `*` -/\n  smul_mul : ∀ (r : M) (x y : A), r • (x * y) = r • x * r • y\n  /-- Multiplying `1` by a scalar gives `1` -/\n  smul_one : ∀ r : M, r • (1 : A) = 1\n\n"}
{"name":"smul_mul'","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"M : Type u_1\nA : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Monoid A\ninst✝ : MulDistribMulAction M A\na : M\nb₁ b₂ : A\n⊢ Eq (HSMul.hSMul a (HMul.hMul b₁ b₂)) (HMul.hMul (HSMul.hSMul a b₁) (HSMul.hSMul a b₂))","decl":"theorem smul_mul' (a : M) (b₁ b₂ : A) : a • (b₁ * b₂) = a • b₁ * a • b₂ :=\n  MulDistribMulAction.smul_mul _ _ _\n\n"}
{"name":"MulDistribMulAction.toMonoidHom_apply","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"M : Type u_1\nA : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Monoid A\ninst✝ : MulDistribMulAction M A\nr : M\nx : A\n⊢ Eq ((MulDistribMulAction.toMonoidHom A r) x) (HSMul.hSMul r x)","decl":"@[simp]\ntheorem MulDistribMulAction.toMonoidHom_apply (r : M) (x : A) :\n    MulDistribMulAction.toMonoidHom A r x = r • x :=\n  rfl\n\n"}
{"name":"smul_pow'","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"M : Type u_1\nA : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Monoid A\ninst✝ : MulDistribMulAction M A\nr : M\nx : A\nn : Nat\n⊢ Eq (HSMul.hSMul r (HPow.hPow x n)) (HPow.hPow (HSMul.hSMul r x) n)","decl":"@[simp] lemma smul_pow' (r : M) (x : A) (n : ℕ) : r • x ^ n = (r • x) ^ n :=\n  (MulDistribMulAction.toMonoidHom _ _).map_pow _ _\n\n"}
{"name":"smul_inv'","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"M : Type u_1\nA : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Group A\ninst✝ : MulDistribMulAction M A\nr : M\nx : A\n⊢ Eq (HSMul.hSMul r (Inv.inv x)) (Inv.inv (HSMul.hSMul r x))","decl":"@[simp]\ntheorem smul_inv' (r : M) (x : A) : r • x⁻¹ = (r • x)⁻¹ :=\n  (MulDistribMulAction.toMonoidHom A r).map_inv x\n\n"}
{"name":"smul_div'","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"M : Type u_1\nA : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Group A\ninst✝ : MulDistribMulAction M A\nr : M\nx y : A\n⊢ Eq (HSMul.hSMul r (HDiv.hDiv x y)) (HDiv.hDiv (HSMul.hSMul r x) (HSMul.hSMul r y))","decl":"theorem smul_div' (r : M) (x y : A) : r • (x / y) = r • x / r • y :=\n  map_div (MulDistribMulAction.toMonoidHom A r) x y\n\n"}
{"name":"smul_eq_zero_iff_eq","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝² : Group α\ninst✝¹ : AddMonoid β\ninst✝ : DistribMulAction α β\na : α\nx : β\n⊢ Iff (Eq (HSMul.hSMul a x) 0) (Eq x 0)","decl":"lemma smul_eq_zero_iff_eq (a : α) {x : β} : a • x = 0 ↔ x = 0 :=\n  ⟨fun h => by rw [← inv_smul_smul a x, h, smul_zero], fun h => h.symm ▸ smul_zero _⟩\n\n"}
{"name":"smul_ne_zero_iff_ne","module":"Mathlib.Algebra.GroupWithZero.Action.Defs","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝² : Group α\ninst✝¹ : AddMonoid β\ninst✝ : DistribMulAction α β\na : α\nx : β\n⊢ Iff (Ne (HSMul.hSMul a x) 0) (Ne x 0)","decl":"lemma smul_ne_zero_iff_ne (a : α) {x : β} : a • x ≠ 0 ↔ x ≠ 0 :=\n  not_congr <| smul_eq_zero_iff_eq a\n\n"}
