{"name":"CategoryTheory.Abelian.image.fac","module":"Mathlib.CategoryTheory.Abelian.Images","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasKernels C\ninst✝ : CategoryTheory.Limits.HasCokernels C\nP Q : C\nf : Quiver.Hom P Q\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.factorThruImage f) (CategoryTheory.Abelian.image.ι f)) f","decl":"/-- `f` factors through its image via the canonical morphism `p`. -/\nprotected theorem image.fac : Abelian.factorThruImage f ≫ image.ι f = f :=\n  kernel.lift_ι _ _ _\n\n"}
{"name":"CategoryTheory.Abelian.mono_factorThruImage","module":"Mathlib.CategoryTheory.Abelian.Images","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasKernels C\ninst✝¹ : CategoryTheory.Limits.HasCokernels C\nP Q : C\nf : Quiver.Hom P Q\ninst✝ : CategoryTheory.Mono f\n⊢ CategoryTheory.Mono (CategoryTheory.Abelian.factorThruImage f)","decl":"instance mono_factorThruImage [Mono f] : Mono (Abelian.factorThruImage f) :=\n  mono_of_mono_fac <| image.fac f\n\n"}
{"name":"CategoryTheory.Abelian.coimage.fac","module":"Mathlib.CategoryTheory.Abelian.Images","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasKernels C\ninst✝ : CategoryTheory.Limits.HasCokernels C\nP Q : C\nf : Quiver.Hom P Q\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.coimage.π f) (CategoryTheory.Abelian.factorThruCoimage f)) f","decl":"/-- `f` factors through its coimage via the canonical morphism `p`. -/\nprotected theorem coimage.fac : coimage.π f ≫ Abelian.factorThruCoimage f = f :=\n  cokernel.π_desc _ _ _\n\n"}
{"name":"CategoryTheory.Abelian.epi_factorThruCoimage","module":"Mathlib.CategoryTheory.Abelian.Images","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasKernels C\ninst✝¹ : CategoryTheory.Limits.HasCokernels C\nP Q : C\nf : Quiver.Hom P Q\ninst✝ : CategoryTheory.Epi f\n⊢ CategoryTheory.Epi (CategoryTheory.Abelian.factorThruCoimage f)","decl":"instance epi_factorThruCoimage [Epi f] : Epi (Abelian.factorThruCoimage f) :=\n  epi_of_epi_fac <| coimage.fac f\n\n"}
{"name":"CategoryTheory.Abelian.coimageImageComparison_eq_coimageImageComparison'","module":"Mathlib.CategoryTheory.Abelian.Images","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasKernels C\ninst✝ : CategoryTheory.Limits.HasCokernels C\nP Q : C\nf : Quiver.Hom P Q\n⊢ Eq (CategoryTheory.Abelian.coimageImageComparison f) (CategoryTheory.Abelian.coimageImageComparison' f)","decl":"theorem coimageImageComparison_eq_coimageImageComparison' :\n    coimageImageComparison f = coimageImageComparison' f := by\n  ext\n  simp [coimageImageComparison, coimageImageComparison']\n\n"}
{"name":"CategoryTheory.Abelian.coimage_image_factorisation_assoc","module":"Mathlib.CategoryTheory.Abelian.Images","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasKernels C\ninst✝ : CategoryTheory.Limits.HasCokernels C\nP Q : C\nf : Quiver.Hom P Q\nZ : C\nh : Quiver.Hom Q Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.coimage.π f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.coimageImageComparison f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.image.ι f) h))) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc (attr := simp)]\ntheorem coimage_image_factorisation : coimage.π f ≫ coimageImageComparison f ≫ image.ι f = f := by\n  simp [coimageImageComparison]\n\n"}
{"name":"CategoryTheory.Abelian.coimage_image_factorisation","module":"Mathlib.CategoryTheory.Abelian.Images","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasKernels C\ninst✝ : CategoryTheory.Limits.HasCokernels C\nP Q : C\nf : Quiver.Hom P Q\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.coimage.π f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.coimageImageComparison f) (CategoryTheory.Abelian.image.ι f))) f","decl":"@[reassoc (attr := simp)]\ntheorem coimage_image_factorisation : coimage.π f ≫ coimageImageComparison f ≫ image.ι f = f := by\n  simp [coimageImageComparison]\n\n"}
{"name":"CategoryTheory.Abelian.coimageImageComparisonFunctor_map","module":"Mathlib.CategoryTheory.Abelian.Images","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasKernels C\ninst✝ : CategoryTheory.Limits.HasCokernels C\nf g : CategoryTheory.Arrow C\nη : Quiver.Hom f g\n⊢ Eq (CategoryTheory.Abelian.coimageImageComparisonFunctor.map η) (CategoryTheory.Arrow.homMk (CategoryTheory.Limits.cokernel.map (CategoryTheory.Limits.kernel.ι f.hom) (CategoryTheory.Limits.kernel.ι g.hom) (CategoryTheory.Limits.kernel.map f.hom g.hom η.left η.right ⋯) η.left ⋯) (CategoryTheory.Limits.kernel.map (CategoryTheory.Limits.cokernel.π f.hom) (CategoryTheory.Limits.cokernel.π g.hom) η.right (CategoryTheory.Limits.cokernel.map f.hom g.hom η.left η.right ⋯) ⋯) ⋯)","decl":"/-- The coimage-image comparison morphism is functorial. -/\n@[simps! obj map]\ndef coimageImageComparisonFunctor : Arrow C ⥤ Arrow C where\n  obj f := Arrow.mk (coimageImageComparison f.hom)\n  map {f g} η := Arrow.homMk\n    (cokernel.map _ _ (kernel.map _ _ η.left η.right (by simp)) η.left (by simp))\n    (kernel.map _ _ η.right (cokernel.map _ _ η.left η.right (by simp)) (by simp)) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Abelian.coimageImageComparisonFunctor_obj","module":"Mathlib.CategoryTheory.Abelian.Images","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasKernels C\ninst✝ : CategoryTheory.Limits.HasCokernels C\nf : CategoryTheory.Arrow C\n⊢ Eq (CategoryTheory.Abelian.coimageImageComparisonFunctor.obj f) (CategoryTheory.Arrow.mk (CategoryTheory.Abelian.coimageImageComparison f.hom))","decl":"/-- The coimage-image comparison morphism is functorial. -/\n@[simps! obj map]\ndef coimageImageComparisonFunctor : Arrow C ⥤ Arrow C where\n  obj f := Arrow.mk (coimageImageComparison f.hom)\n  map {f g} η := Arrow.homMk\n    (cokernel.map _ _ (kernel.map _ _ η.left η.right (by simp)) η.left (by simp))\n    (kernel.map _ _ η.right (cokernel.map _ _ η.left η.right (by simp)) (by simp)) (by aesop_cat)\n\n"}
