{"name":"cross_apply","module":"Mathlib.LinearAlgebra.CrossProduct","initialProofState":"R : Type u_1\ninst✝ : CommRing R\na b : Fin 3 → R\n⊢ Eq ((crossProduct a) b) (Matrix.vecCons (HSub.hSub (HMul.hMul (a 1) (b 2)) (HMul.hMul (a 2) (b 1))) (Matrix.vecCons (HSub.hSub (HMul.hMul (a 2) (b 0)) (HMul.hMul (a 0) (b 2))) (Matrix.vecCons (HSub.hSub (HMul.hMul (a 0) (b 1)) (HMul.hMul (a 1) (b 0))) Matrix.vecEmpty)))","decl":"theorem cross_apply (a b : Fin 3 → R) :\n    a ×₃ b = ![a 1 * b 2 - a 2 * b 1, a 2 * b 0 - a 0 * b 2, a 0 * b 1 - a 1 * b 0] := rfl\n\n"}
{"name":"cross_anticomm","module":"Mathlib.LinearAlgebra.CrossProduct","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nv w : Fin 3 → R\n⊢ Eq (Neg.neg ((crossProduct v) w)) ((crossProduct w) v)","decl":"@[simp]\ntheorem cross_anticomm (v w : Fin 3 → R) : -(v ×₃ w) = w ×₃ v := by\n  simp [cross_apply, mul_comm]\n\n"}
{"name":"neg_cross","module":"Mathlib.LinearAlgebra.CrossProduct","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nv w : Fin 3 → R\n⊢ Eq (Neg.neg ((crossProduct v) w)) ((crossProduct w) v)","decl":"alias neg_cross := cross_anticomm\n\n"}
{"name":"cross_anticomm'","module":"Mathlib.LinearAlgebra.CrossProduct","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nv w : Fin 3 → R\n⊢ Eq (HAdd.hAdd ((crossProduct v) w) ((crossProduct w) v)) 0","decl":"@[simp]\ntheorem cross_anticomm' (v w : Fin 3 → R) : v ×₃ w + w ×₃ v = 0 := by\n  rw [add_eq_zero_iff_eq_neg, cross_anticomm]\n\n"}
{"name":"cross_self","module":"Mathlib.LinearAlgebra.CrossProduct","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nv : Fin 3 → R\n⊢ Eq ((crossProduct v) v) 0","decl":"@[simp]\ntheorem cross_self (v : Fin 3 → R) : v ×₃ v = 0 := by\n  simp [cross_apply, mul_comm]\n\n"}
{"name":"dot_self_cross","module":"Mathlib.LinearAlgebra.CrossProduct","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nv w : Fin 3 → R\n⊢ Eq (dotProduct v ((crossProduct v) w)) 0","decl":"/-- The cross product of two vectors is perpendicular to the first vector. -/\n@[simp 1100] -- Porting note: increase priority so that the LHS doesn't simplify\ntheorem dot_self_cross (v w : Fin 3 → R) : v ⬝ᵥ v ×₃ w = 0 := by\n  rw [cross_apply, vec3_dotProduct]\n  norm_num\n  ring\n\n"}
{"name":"dot_cross_self","module":"Mathlib.LinearAlgebra.CrossProduct","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nv w : Fin 3 → R\n⊢ Eq (dotProduct w ((crossProduct v) w)) 0","decl":"/-- The cross product of two vectors is perpendicular to the second vector. -/\n@[simp 1100] -- Porting note: increase priority so that the LHS doesn't simplify\ntheorem dot_cross_self (v w : Fin 3 → R) : w ⬝ᵥ v ×₃ w = 0 := by\n  rw [← cross_anticomm, dotProduct_neg, dot_self_cross, neg_zero]\n\n"}
{"name":"triple_product_permutation","module":"Mathlib.LinearAlgebra.CrossProduct","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nu v w : Fin 3 → R\n⊢ Eq (dotProduct u ((crossProduct v) w)) (dotProduct v ((crossProduct w) u))","decl":"/-- Cyclic permutations preserve the triple product. See also `triple_product_eq_det`. -/\ntheorem triple_product_permutation (u v w : Fin 3 → R) : u ⬝ᵥ v ×₃ w = v ⬝ᵥ w ×₃ u := by\n  simp_rw [cross_apply, vec3_dotProduct]\n  norm_num\n  ring\n\n"}
{"name":"triple_product_eq_det","module":"Mathlib.LinearAlgebra.CrossProduct","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nu v w : Fin 3 → R\n⊢ Eq (dotProduct u ((crossProduct v) w)) (Matrix.det (Matrix.vecCons u (Matrix.vecCons v (Matrix.vecCons w Matrix.vecEmpty))))","decl":"/-- The triple product of `u`, `v`, and `w` is equal to the determinant of the matrix\n    with those vectors as its rows. -/\ntheorem triple_product_eq_det (u v w : Fin 3 → R) : u ⬝ᵥ v ×₃ w = Matrix.det ![u, v, w] := by\n  rw [vec3_dotProduct, cross_apply, det_fin_three]\n  norm_num\n  ring\n\n"}
{"name":"cross_dot_cross","module":"Mathlib.LinearAlgebra.CrossProduct","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nu v w x : Fin 3 → R\n⊢ Eq (dotProduct ((crossProduct u) v) ((crossProduct w) x)) (HSub.hSub (HMul.hMul (dotProduct u w) (dotProduct v x)) (HMul.hMul (dotProduct u x) (dotProduct v w)))","decl":"/-- The scalar quadruple product identity, related to the Binet-Cauchy identity. -/\ntheorem cross_dot_cross (u v w x : Fin 3 → R) :\n    u ×₃ v ⬝ᵥ w ×₃ x = u ⬝ᵥ w * v ⬝ᵥ x - u ⬝ᵥ x * v ⬝ᵥ w := by\n  simp_rw [cross_apply, vec3_dotProduct]\n  norm_num\n  ring\n\n"}
{"name":"leibniz_cross","module":"Mathlib.LinearAlgebra.CrossProduct","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nu v w : Fin 3 → R\n⊢ Eq ((crossProduct u) ((crossProduct v) w)) (HAdd.hAdd ((crossProduct ((crossProduct u) v)) w) ((crossProduct v) ((crossProduct u) w)))","decl":"/-- The cross product satisfies the Leibniz lie property. -/\ntheorem leibniz_cross (u v w : Fin 3 → R) : u ×₃ (v ×₃ w) = u ×₃ v ×₃ w + v ×₃ (u ×₃ w) := by\n  simp_rw [cross_apply, vec3_add]\n  apply vec3_eq <;> norm_num <;> ring\n\n"}
{"name":"cross_cross","module":"Mathlib.LinearAlgebra.CrossProduct","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nu v w : Fin 3 → R\n⊢ Eq ((crossProduct ((crossProduct u) v)) w) (HSub.hSub ((crossProduct u) ((crossProduct v) w)) ((crossProduct v) ((crossProduct u) w)))","decl":"theorem cross_cross (u v w : Fin 3 → R) : u ×₃ v ×₃ w = u ×₃ (v ×₃ w) - v ×₃ (u ×₃ w) :=\n  lie_lie u v w\n\n"}
{"name":"jacobi_cross","module":"Mathlib.LinearAlgebra.CrossProduct","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nu v w : Fin 3 → R\n⊢ Eq (HAdd.hAdd (HAdd.hAdd ((crossProduct u) ((crossProduct v) w)) ((crossProduct v) ((crossProduct w) u))) ((crossProduct w) ((crossProduct u) v))) 0","decl":"/-- **Jacobi identity**: For a cross product of three vectors,\n    their sum over the three even permutations is equal to the zero vector. -/\ntheorem jacobi_cross (u v w : Fin 3 → R) : u ×₃ (v ×₃ w) + v ×₃ (w ×₃ u) + w ×₃ (u ×₃ v) = 0 :=\n  lie_jacobi u v w\n\n"}
{"name":"crossProduct_ne_zero_iff_linearIndependent","module":"Mathlib.LinearAlgebra.CrossProduct","initialProofState":"F : Type u_2\ninst✝ : Field F\nv w : Fin 3 → F\n⊢ Iff (Ne ((crossProduct v) w) 0) (LinearIndependent F (Matrix.vecCons v (Matrix.vecCons w Matrix.vecEmpty)))","decl":"lemma crossProduct_ne_zero_iff_linearIndependent {F : Type*} [Field F] {v w : Fin 3 → F} :\n    crossProduct v w ≠ 0 ↔ LinearIndependent F ![v, w] := by\n  rw [not_iff_comm]\n  by_cases hv : v = 0\n  · rw [hv, map_zero, LinearMap.zero_apply, eq_self, iff_true]\n    exact fun h ↦ h.ne_zero 0 rfl\n  constructor\n  · rw [LinearIndependent.pair_iff' hv, not_forall_not]\n    rintro ⟨a, rfl⟩\n    rw [LinearMap.map_smul, cross_self, smul_zero]\n  have hv' : v = ![v 0, v 1, v 2] := by simp [← List.ofFn_inj]\n  have hw' : w = ![w 0, w 1, w 2] := by simp [← List.ofFn_inj]\n  intro h1 h2\n  simp_rw [cross_apply, cons_eq_zero_iff, zero_empty, and_true, sub_eq_zero] at h1\n  have h20 := LinearIndependent.pair_iff.mp h2 (- w 0) (v 0)\n  have h21 := LinearIndependent.pair_iff.mp h2 (- w 1) (v 1)\n  have h22 := LinearIndependent.pair_iff.mp h2 (- w 2) (v 2)\n  rw [neg_smul, neg_add_eq_zero, hv', hw', smul_vec3, smul_vec3, ← hv', ← hw'] at h20 h21 h22\n  simp only [smul_eq_mul, mul_comm (w 0), mul_comm (w 1), mul_comm (w 2), h1] at h20 h21 h22\n  rw [hv', cons_eq_zero_iff, cons_eq_zero_iff, cons_eq_zero_iff, zero_empty] at hv\n  exact hv ⟨(h20 trivial).2, (h21 trivial).2, (h22 trivial).2, rfl⟩\n"}
