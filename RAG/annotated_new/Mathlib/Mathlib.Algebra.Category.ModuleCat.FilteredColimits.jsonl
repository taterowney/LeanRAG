{"name":"ModuleCat.FilteredColimits.M.mk_eq","module":"Mathlib.Algebra.Category.ModuleCat.FilteredColimits","initialProofState":"R : Type u\ninst✝² : Ring R\nJ : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.IsFiltered J\nF : CategoryTheory.Functor J (ModuleCatMax R)\nx y : Sigma fun j => ↑(F.obj j)\nh : Exists fun k => Exists fun f => Exists fun g => Eq ((CategoryTheory.ConcreteCategory.hom (F.map f)) x.snd) ((CategoryTheory.ConcreteCategory.hom (F.map g)) y.snd)\n⊢ Eq (ModuleCat.FilteredColimits.M.mk F x) (ModuleCat.FilteredColimits.M.mk F y)","decl":"theorem M.mk_eq (x y : Σ j, F.obj j)\n    (h : ∃ (k : J) (f : x.1 ⟶ k) (g : y.1 ⟶ k), F.map f x.2 = F.map g y.2) : M.mk F x = M.mk F y :=\n  Quot.eqvGen_sound (Types.FilteredColimit.eqvGen_quot_rel_of_rel (F ⋙ forget (ModuleCat R)) x y h)\n\n"}
{"name":"ModuleCat.FilteredColimits.colimitSMulAux_eq_of_rel","module":"Mathlib.Algebra.Category.ModuleCat.FilteredColimits","initialProofState":"R : Type u\ninst✝² : Ring R\nJ : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.IsFiltered J\nF : CategoryTheory.Functor J (ModuleCatMax R)\nr : R\nx y : Sigma fun j => ↑(F.obj j)\nh : CategoryTheory.Limits.Types.FilteredColimit.Rel (F.comp (CategoryTheory.forget (ModuleCat R))) x y\n⊢ Eq (ModuleCat.FilteredColimits.colimitSMulAux F r x) (ModuleCat.FilteredColimits.colimitSMulAux F r y)","decl":"theorem colimitSMulAux_eq_of_rel (r : R) (x y : Σ j, F.obj j)\n    (h : Types.FilteredColimit.Rel (F ⋙ forget (ModuleCat R)) x y) :\n    colimitSMulAux F r x = colimitSMulAux F r y := by\n  apply M.mk_eq\n  obtain ⟨k, f, g, hfg⟩ := h\n  use k, f, g\n  simp only [Functor.comp_obj, Functor.comp_map, forget_map] at hfg\n  simp [hfg]\n\n"}
{"name":"ModuleCat.FilteredColimits.colimit_smul_mk_eq","module":"Mathlib.Algebra.Category.ModuleCat.FilteredColimits","initialProofState":"R : Type u\ninst✝² : Ring R\nJ : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.IsFiltered J\nF : CategoryTheory.Functor J (ModuleCatMax R)\nr : R\nx : Sigma fun j => ↑(F.obj j)\n⊢ Eq (HSMul.hSMul r (ModuleCat.FilteredColimits.M.mk F x)) (ModuleCat.FilteredColimits.M.mk F ⟨x.fst, HSMul.hSMul r x.snd⟩)","decl":"@[simp]\ntheorem colimit_smul_mk_eq (r : R) (x : Σ j, F.obj j) : r • M.mk F x = M.mk F ⟨x.1, r • x.2⟩ :=\n  rfl\n\n"}
{"name":"ModuleCat.FilteredColimits.forget₂AddCommGroup_preservesFilteredColimits","module":"Mathlib.Algebra.Category.ModuleCat.FilteredColimits","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget₂ (ModuleCat R) AddCommGrp)","decl":"instance forget₂AddCommGroup_preservesFilteredColimits :\n    PreservesFilteredColimits (forget₂ (ModuleCat.{u} R) AddCommGrp.{u}) where\n  preserves_filtered_colimits J _ _ :=\n  { -- Porting note: without the curly braces for `F`\n    -- here we get a confusing error message about universes.\n    preservesColimit := fun {F : J ⥤ ModuleCat.{u} R} =>\n      preservesColimit_of_preserves_colimit_cocone (colimitCoconeIsColimit F)\n        (AddCommGrp.FilteredColimits.colimitCoconeIsColimit\n          (F ⋙ forget₂ (ModuleCat.{u} R) AddCommGrp.{u})) }\n\n"}
{"name":"ModuleCat.FilteredColimits.forget_preservesFilteredColimits","module":"Mathlib.Algebra.Category.ModuleCat.FilteredColimits","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget (ModuleCat R))","decl":"instance forget_preservesFilteredColimits : PreservesFilteredColimits (forget (ModuleCat.{u} R)) :=\n  Limits.comp_preservesFilteredColimits (forget₂ (ModuleCat R) AddCommGrp)\n    (forget AddCommGrp)\n\n"}
{"name":"ModuleCat.FilteredColimits.forget_reflectsFilteredColimits","module":"Mathlib.Algebra.Category.ModuleCat.FilteredColimits","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ CategoryTheory.Limits.ReflectsFilteredColimits (CategoryTheory.forget (ModuleCat R))","decl":"instance forget_reflectsFilteredColimits : ReflectsFilteredColimits (forget (ModuleCat.{u} R)) where\n  reflects_filtered_colimits _ := { reflectsColimit := reflectsColimit_of_reflectsIsomorphisms _ _ }\n\n"}
