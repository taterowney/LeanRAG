{"name":"Matrix.toLinearEquiv'_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLinearEquiv","initialProofState":"n : Type u_1\ninst✝² : Fintype n\nR : Type u_2\ninst✝¹ : CommRing R\ninst✝ : DecidableEq n\nP : Matrix n n R\nh : Invertible P\n⊢ Eq (↑(P.toLinearEquiv' h)) (Matrix.toLin' P)","decl":"@[simp]\ntheorem toLinearEquiv'_apply (P : Matrix n n R) (h : Invertible P) :\n    (P.toLinearEquiv' h : Module.End R (n → R)) = Matrix.toLin' P :=\n  rfl\n\n"}
{"name":"Matrix.toLinearEquiv'_symm_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLinearEquiv","initialProofState":"n : Type u_1\ninst✝² : Fintype n\nR : Type u_2\ninst✝¹ : CommRing R\ninst✝ : DecidableEq n\nP : Matrix n n R\nh : Invertible P\n⊢ Eq (↑(P.toLinearEquiv' h).symm) (Matrix.toLin' (Invertible.invOf P))","decl":"@[simp]\ntheorem toLinearEquiv'_symm_apply (P : Matrix n n R) (h : Invertible P) :\n    (↑(P.toLinearEquiv' h).symm : Module.End R (n → R)) = Matrix.toLin' (⅟ P) :=\n  rfl\n\n"}
{"name":"Matrix.toLinearEquiv_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLinearEquiv","initialProofState":"n : Type u_1\ninst✝⁴ : Fintype n\nR : Type u_2\nM : Type u_3\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nb : Basis n R M\ninst✝ : DecidableEq n\nA : Matrix n n R\nhA : IsUnit A.det\na : M\n⊢ Eq ((Matrix.toLinearEquiv b A hA) a) (((Matrix.toLin b b) A) a)","decl":"/-- Given `hA : IsUnit A.det` and `b : Basis R b`, `A.toLinearEquiv b hA` is\nthe `LinearEquiv` arising from `toLin b b A`.\n\nSee `Matrix.toLinearEquiv'` for this result on `n → R`.\n-/\n@[simps apply]\nnoncomputable def toLinearEquiv [DecidableEq n] (A : Matrix n n R) (hA : IsUnit A.det) :\n    M ≃ₗ[R] M where\n  __ := toLin b b A\n  toFun := toLin b b A\n  invFun := toLin b b A⁻¹\n  left_inv x := by\n    simp_rw [← LinearMap.comp_apply, ← Matrix.toLin_mul b b b, Matrix.nonsing_inv_mul _ hA,\n      toLin_one, LinearMap.id_apply]\n  right_inv x := by\n    simp_rw [← LinearMap.comp_apply, ← Matrix.toLin_mul b b b, Matrix.mul_nonsing_inv _ hA,\n      toLin_one, LinearMap.id_apply]\n\n"}
{"name":"Matrix.ker_toLin_eq_bot","module":"Mathlib.LinearAlgebra.Matrix.ToLinearEquiv","initialProofState":"n : Type u_1\ninst✝⁴ : Fintype n\nR : Type u_2\nM : Type u_3\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nb : Basis n R M\ninst✝ : DecidableEq n\nA : Matrix n n R\nhA : IsUnit A.det\n⊢ Eq (LinearMap.ker ((Matrix.toLin b b) A)) Bot.bot","decl":"theorem ker_toLin_eq_bot [DecidableEq n] (A : Matrix n n R) (hA : IsUnit A.det) :\n    LinearMap.ker (toLin b b A) = ⊥ :=\n  ker_eq_bot.mpr (toLinearEquiv b A hA).injective\n\n"}
{"name":"Matrix.range_toLin_eq_top","module":"Mathlib.LinearAlgebra.Matrix.ToLinearEquiv","initialProofState":"n : Type u_1\ninst✝⁴ : Fintype n\nR : Type u_2\nM : Type u_3\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nb : Basis n R M\ninst✝ : DecidableEq n\nA : Matrix n n R\nhA : IsUnit A.det\n⊢ Eq (LinearMap.range ((Matrix.toLin b b) A)) Top.top","decl":"theorem range_toLin_eq_top [DecidableEq n] (A : Matrix n n R) (hA : IsUnit A.det) :\n    LinearMap.range (toLin b b A) = ⊤ :=\n  range_eq_top.mpr (toLinearEquiv b A hA).surjective\n\n"}
{"name":"Matrix.exists_mulVec_eq_zero_iff_aux","module":"Mathlib.LinearAlgebra.Matrix.ToLinearEquiv","initialProofState":"n : Type u_1\ninst✝² : Fintype n\nK : Type u_4\ninst✝¹ : DecidableEq n\ninst✝ : Field K\nM : Matrix n n K\n⊢ Iff (Exists fun v => And (Ne v 0) (Eq (M.mulVec v) 0)) (Eq M.det 0)","decl":"/-- This holds for all integral domains (see `Matrix.exists_mulVec_eq_zero_iff`),\nnot just fields, but it's easier to prove it for the field of fractions first. -/\ntheorem exists_mulVec_eq_zero_iff_aux {K : Type*} [DecidableEq n] [Field K] {M : Matrix n n K} :\n    (∃ v ≠ 0, M *ᵥ v = 0) ↔ M.det = 0 := by\n  constructor\n  · rintro ⟨v, hv, mul_eq⟩\n    contrapose! hv\n    exact eq_zero_of_mulVec_eq_zero hv mul_eq\n  · contrapose!\n    intro h\n    have : Function.Injective (Matrix.toLin' M) := by\n      simpa only [← LinearMap.ker_eq_bot, ker_toLin'_eq_bot_iff, not_imp_not] using h\n    have :\n      M *\n          LinearMap.toMatrix'\n            ((LinearEquiv.ofInjectiveEndo (Matrix.toLin' M) this).symm : (n → K) →ₗ[K] n → K) =\n        1 := by\n      refine Matrix.toLin'.injective (LinearMap.ext fun v => ?_)\n      rw [Matrix.toLin'_mul, Matrix.toLin'_one, Matrix.toLin'_toMatrix', LinearMap.comp_apply]\n      exact (LinearEquiv.ofInjectiveEndo (Matrix.toLin' M) this).apply_symm_apply v\n    exact Matrix.det_ne_zero_of_right_inverse this\n\n"}
{"name":"Matrix.exists_mulVec_eq_zero_iff'","module":"Mathlib.LinearAlgebra.Matrix.ToLinearEquiv","initialProofState":"n : Type u_1\ninst✝⁶ : Fintype n\nA : Type u_4\nK : Type u_5\ninst✝⁵ : DecidableEq n\ninst✝⁴ : CommRing A\ninst✝³ : Nontrivial A\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\nM : Matrix n n A\n⊢ Iff (Exists fun v => And (Ne v 0) (Eq (M.mulVec v) 0)) (Eq M.det 0)","decl":"theorem exists_mulVec_eq_zero_iff' {A : Type*} (K : Type*) [DecidableEq n] [CommRing A]\n    [Nontrivial A] [Field K] [Algebra A K] [IsFractionRing A K] {M : Matrix n n A} :\n    (∃ v ≠ 0, M *ᵥ v = 0) ↔ M.det = 0 := by\n  have : (∃ v ≠ 0, (algebraMap A K).mapMatrix M *ᵥ v = 0) ↔ _ :=\n    exists_mulVec_eq_zero_iff_aux\n  rw [← RingHom.map_det, IsFractionRing.to_map_eq_zero_iff] at this\n  refine Iff.trans ?_ this; constructor <;> rintro ⟨v, hv, mul_eq⟩\n  · refine ⟨fun i => algebraMap _ _ (v i), mt (fun h => funext fun i => ?_) hv, ?_⟩\n    · exact IsFractionRing.to_map_eq_zero_iff.mp (congr_fun h i)\n    · ext i\n      refine (RingHom.map_mulVec _ _ _ i).symm.trans ?_\n      rw [mul_eq, Pi.zero_apply, RingHom.map_zero, Pi.zero_apply]\n  · letI := Classical.decEq K\n    obtain ⟨⟨b, hb⟩, ba_eq⟩ :=\n      IsLocalization.exist_integer_multiples_of_finset (nonZeroDivisors A) (Finset.univ.image v)\n    choose f hf using ba_eq\n    refine\n      ⟨fun i => f _ (Finset.mem_image.mpr ⟨i, Finset.mem_univ i, rfl⟩),\n        mt (fun h => funext fun i => ?_) hv, ?_⟩\n    · have := congr_arg (algebraMap A K) (congr_fun h i)\n      rw [hf, Subtype.coe_mk, Pi.zero_apply, RingHom.map_zero, Algebra.smul_def, mul_eq_zero,\n        IsFractionRing.to_map_eq_zero_iff] at this\n      exact this.resolve_left (nonZeroDivisors.ne_zero hb)\n    · ext i\n      refine IsFractionRing.injective A K ?_\n      calc\n        algebraMap A K ((M *ᵥ (fun i : n => f (v i) _)) i) =\n            ((algebraMap A K).mapMatrix M *ᵥ algebraMap _ K b • v) i := ?_\n        _ = 0 := ?_\n        _ = algebraMap A K 0 := (RingHom.map_zero _).symm\n      · simp_rw [RingHom.map_mulVec, mulVec, dotProduct, Function.comp_apply, hf,\n          RingHom.mapMatrix_apply, Pi.smul_apply, smul_eq_mul, Algebra.smul_def]\n      · rw [mulVec_smul, mul_eq, Pi.smul_apply, Pi.zero_apply, smul_zero]\n\n"}
{"name":"Matrix.exists_mulVec_eq_zero_iff","module":"Mathlib.LinearAlgebra.Matrix.ToLinearEquiv","initialProofState":"n : Type u_1\ninst✝³ : Fintype n\nA : Type u_4\ninst✝² : DecidableEq n\ninst✝¹ : CommRing A\ninst✝ : IsDomain A\nM : Matrix n n A\n⊢ Iff (Exists fun v => And (Ne v 0) (Eq (M.mulVec v) 0)) (Eq M.det 0)","decl":"theorem exists_mulVec_eq_zero_iff {A : Type*} [DecidableEq n] [CommRing A] [IsDomain A]\n    {M : Matrix n n A} : (∃ v ≠ 0, M *ᵥ v = 0) ↔ M.det = 0 :=\n  exists_mulVec_eq_zero_iff' (FractionRing A)\n\n"}
{"name":"Matrix.exists_vecMul_eq_zero_iff","module":"Mathlib.LinearAlgebra.Matrix.ToLinearEquiv","initialProofState":"n : Type u_1\ninst✝³ : Fintype n\nA : Type u_4\ninst✝² : DecidableEq n\ninst✝¹ : CommRing A\ninst✝ : IsDomain A\nM : Matrix n n A\n⊢ Iff (Exists fun v => And (Ne v 0) (Eq (Matrix.vecMul v M) 0)) (Eq M.det 0)","decl":"theorem exists_vecMul_eq_zero_iff {A : Type*} [DecidableEq n] [CommRing A] [IsDomain A]\n    {M : Matrix n n A} : (∃ v ≠ 0, v ᵥ* M = 0) ↔ M.det = 0 := by\n  simpa only [← M.det_transpose, ← mulVec_transpose] using exists_mulVec_eq_zero_iff\n\n"}
{"name":"Matrix.nondegenerate_iff_det_ne_zero","module":"Mathlib.LinearAlgebra.Matrix.ToLinearEquiv","initialProofState":"n : Type u_1\ninst✝³ : Fintype n\nA : Type u_4\ninst✝² : DecidableEq n\ninst✝¹ : CommRing A\ninst✝ : IsDomain A\nM : Matrix n n A\n⊢ Iff M.Nondegenerate (Ne M.det 0)","decl":"theorem nondegenerate_iff_det_ne_zero {A : Type*} [DecidableEq n] [CommRing A] [IsDomain A]\n    {M : Matrix n n A} : Nondegenerate M ↔ M.det ≠ 0 := by\n  rw [ne_eq, ← exists_vecMul_eq_zero_iff]\n  push_neg\n  constructor\n  · intro hM v hv hMv\n    obtain ⟨w, hwMv⟩ := hM.exists_not_ortho_of_ne_zero hv\n    simp [dotProduct_mulVec, hMv, zero_dotProduct, ne_eq, not_true] at hwMv\n  · intro h v hv\n    refine not_imp_not.mp (h v) (funext fun i => ?_)\n    simpa only [dotProduct_mulVec, dotProduct_single, mul_one] using hv (Pi.single i 1)\n\n"}
{"name":"Matrix.Nondegenerate.of_det_ne_zero","module":"Mathlib.LinearAlgebra.Matrix.ToLinearEquiv","initialProofState":"n : Type u_1\ninst✝³ : Fintype n\nA : Type u_4\ninst✝² : DecidableEq n\ninst✝¹ : CommRing A\ninst✝ : IsDomain A\nM : Matrix n n A\na✝ : Ne M.det 0\n⊢ M.Nondegenerate","decl":"alias ⟨Nondegenerate.det_ne_zero, Nondegenerate.of_det_ne_zero⟩ := nondegenerate_iff_det_ne_zero\n\n"}
{"name":"Matrix.Nondegenerate.det_ne_zero","module":"Mathlib.LinearAlgebra.Matrix.ToLinearEquiv","initialProofState":"n : Type u_1\ninst✝³ : Fintype n\nA : Type u_4\ninst✝² : DecidableEq n\ninst✝¹ : CommRing A\ninst✝ : IsDomain A\nM : Matrix n n A\na✝ : M.Nondegenerate\n⊢ Ne M.det 0","decl":"alias ⟨Nondegenerate.det_ne_zero, Nondegenerate.of_det_ne_zero⟩ := nondegenerate_iff_det_ne_zero\n\n"}
{"name":"Matrix.det_ne_zero_of_sum_col_pos","module":"Mathlib.LinearAlgebra.Matrix.ToLinearEquiv","initialProofState":"n : Type u_1\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\nS : Type u_2\ninst✝ : LinearOrderedCommRing S\nA : Matrix n n S\nh1 : Pairwise fun i j => LT.lt (A i j) 0\nh2 : ∀ (j : n), LT.lt 0 (Finset.univ.sum fun i => A i j)\n⊢ Ne A.det 0","decl":"/-- A matrix whose nondiagonal entries are negative with the sum of the entries of each\ncolumn positive has nonzero determinant. -/\nlemma det_ne_zero_of_sum_col_pos [DecidableEq n] {S : Type*} [LinearOrderedCommRing S]\n    {A : Matrix n n S} (h1 : Pairwise fun i j => A i j < 0) (h2 : ∀ j, 0 < ∑ i, A i j) :\n    A.det ≠ 0 := by\n  cases isEmpty_or_nonempty n\n  · simp\n  · contrapose! h2\n    obtain ⟨v, ⟨h_vnz, h_vA⟩⟩ := Matrix.exists_vecMul_eq_zero_iff.mpr h2\n    wlog h_sup : 0 < Finset.sup' Finset.univ Finset.univ_nonempty v\n    · refine this h1 inferInstance h2 (-1 • v) ?_ ?_ ?_\n      · exact smul_ne_zero (by norm_num) h_vnz\n      · rw [Matrix.vecMul_smul, h_vA, smul_zero]\n      · obtain ⟨i, hi⟩ := Function.ne_iff.mp h_vnz\n        simp_rw [Finset.lt_sup'_iff, Finset.mem_univ, true_and] at h_sup ⊢\n        simp_rw [not_exists, not_lt] at h_sup\n        refine ⟨i, ?_⟩\n        rw [Pi.smul_apply, neg_smul, one_smul, Left.neg_pos_iff]\n        exact Ne.lt_of_le hi (h_sup i)\n    · obtain ⟨j₀, -, h_j₀⟩ := Finset.exists_mem_eq_sup' Finset.univ_nonempty v\n      refine ⟨j₀, ?_⟩\n      rw [← mul_le_mul_left (h_j₀ ▸ h_sup), Finset.mul_sum, mul_zero]\n      rw [show 0 = ∑ i, v i * A i j₀ from (congrFun h_vA j₀).symm]\n      refine Finset.sum_le_sum (fun i hi => ?_)\n      by_cases h : i = j₀\n      · rw [h]\n      · exact (mul_le_mul_right_of_neg (h1 h)).mpr (h_j₀ ▸ Finset.le_sup' v hi)\n\n"}
{"name":"Matrix.det_ne_zero_of_sum_row_pos","module":"Mathlib.LinearAlgebra.Matrix.ToLinearEquiv","initialProofState":"n : Type u_1\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\nS : Type u_2\ninst✝ : LinearOrderedCommRing S\nA : Matrix n n S\nh1 : Pairwise fun i j => LT.lt (A i j) 0\nh2 : ∀ (i : n), LT.lt 0 (Finset.univ.sum fun j => A i j)\n⊢ Ne A.det 0","decl":"/-- A matrix whose nondiagonal entries are negative with the sum of the entries of each\nrow positive has nonzero determinant. -/\nlemma det_ne_zero_of_sum_row_pos [DecidableEq n] {S : Type*} [LinearOrderedCommRing S]\n    {A : Matrix n n S} (h1 : Pairwise fun i j => A i j < 0) (h2 : ∀ i, 0 < ∑ j, A i j) :\n    A.det ≠ 0 := by\n  rw [← Matrix.det_transpose]\n  refine det_ne_zero_of_sum_col_pos ?_ ?_\n  · simp_rw [Matrix.transpose_apply]\n    exact fun i j h => h1 h.symm\n  · simp_rw [Matrix.transpose_apply]\n    exact h2\n\n"}
