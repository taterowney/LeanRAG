{"name":"Differential.logDeriv_zero","module":"Mathlib.FieldTheory.Differential.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Field R\ninst✝ : Differential R\n⊢ Eq (Differential.logDeriv 0) 0","decl":"@[simp]\nlemma logDeriv_zero : logDeriv (0 : R) = 0 := by\n  simp [logDeriv]\n\n"}
{"name":"Differential.logDeriv_one","module":"Mathlib.FieldTheory.Differential.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Field R\ninst✝ : Differential R\n⊢ Eq (Differential.logDeriv 1) 0","decl":"@[simp]\nlemma logDeriv_one : logDeriv (1 : R) = 0 := by\n  simp [logDeriv]\n\n"}
{"name":"Differential.logDeriv_mul","module":"Mathlib.FieldTheory.Differential.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Field R\ninst✝ : Differential R\na b : R\nha : Ne a 0\nhb : Ne b 0\n⊢ Eq (Differential.logDeriv (HMul.hMul a b)) (HAdd.hAdd (Differential.logDeriv a) (Differential.logDeriv b))","decl":"lemma logDeriv_mul (ha : a ≠ 0) (hb : b ≠ 0) : logDeriv (a * b) = logDeriv a + logDeriv b := by\n  unfold logDeriv\n  field_simp\n  ring\n\n"}
{"name":"Differential.logDeriv_div","module":"Mathlib.FieldTheory.Differential.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Field R\ninst✝ : Differential R\na b : R\nha : Ne a 0\nhb : Ne b 0\n⊢ Eq (Differential.logDeriv (HDiv.hDiv a b)) (HSub.hSub (Differential.logDeriv a) (Differential.logDeriv b))","decl":"lemma logDeriv_div (ha : a ≠ 0) (hb : b ≠ 0) : logDeriv (a / b) = logDeriv a - logDeriv b := by\n  unfold logDeriv\n  field_simp [Derivation.leibniz_div, smul_sub]\n  ring\n\n"}
{"name":"Differential.logDeriv_pow","module":"Mathlib.FieldTheory.Differential.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Field R\ninst✝ : Differential R\nn : Nat\na : R\n⊢ Eq (Differential.logDeriv (HPow.hPow a n)) (HMul.hMul (↑n) (Differential.logDeriv a))","decl":"@[simp]\nlemma logDeriv_pow (n : ℕ) (a : R) : logDeriv (a ^ n) = n * logDeriv a := by\n  induction n with\n  | zero => simp\n  | succ n h2 =>\n    obtain rfl | hb := eq_or_ne a 0\n    · simp\n    · rw [Nat.cast_add, Nat.cast_one, add_mul, one_mul, ← h2, pow_succ, logDeriv_mul] <;>\n      simp [hb]\n\n"}
{"name":"Differential.logDeriv_eq_zero","module":"Mathlib.FieldTheory.Differential.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Field R\ninst✝ : Differential R\na : R\n⊢ Iff (Eq (Differential.logDeriv a) 0) (Eq a′ 0)","decl":"lemma logDeriv_eq_zero : logDeriv a = 0 ↔ a′ = 0 :=\n  ⟨fun h ↦ by simp only [logDeriv, _root_.div_eq_zero_iff] at h; rcases h with h|h <;> simp [h],\n  fun h ↦ by unfold logDeriv at *; simp [h]⟩\n\n"}
{"name":"Differential.logDeriv_multisetProd","module":"Mathlib.FieldTheory.Differential.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Field R\ninst✝ : Differential R\nι : Type u_2\ns : Multiset ι\nf : ι → R\nh : ∀ (x : ι), Membership.mem s x → Ne (f x) 0\n⊢ Eq (Differential.logDeriv (Multiset.map f s).prod) (Multiset.map (fun x => Differential.logDeriv (f x)) s).sum","decl":"lemma logDeriv_multisetProd {ι : Type*} (s : Multiset ι) {f : ι → R} (h : ∀ x ∈ s, f x ≠ 0) :\n    logDeriv (s.map f).prod = (s.map fun x ↦ logDeriv (f x)).sum := by\n  induction s using Multiset.induction_on\n  · simp\n  · rename_i h₂\n    simp only [Function.comp_apply, Multiset.map_cons, Multiset.sum_cons, Multiset.prod_cons]\n    rw [← h₂]\n    · apply logDeriv_mul\n      · simp [h]\n      · simp_all\n    · simp_all\n\n"}
{"name":"Differential.logDeriv_prod","module":"Mathlib.FieldTheory.Differential.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Field R\ninst✝ : Differential R\nι : Type u_2\ns : Finset ι\nf : ι → R\nh : ∀ (x : ι), Membership.mem s x → Ne (f x) 0\n⊢ Eq (Differential.logDeriv (s.prod fun x => f x)) (s.sum fun x => Differential.logDeriv (f x))","decl":"lemma logDeriv_prod (ι : Type*) (s : Finset ι) (f : ι → R) (h : ∀ x ∈ s, f x ≠ 0) :\n    logDeriv (∏ x ∈ s, f x) = ∑ x ∈ s, logDeriv (f x) := logDeriv_multisetProd _ h\n\n"}
{"name":"Differential.logDeriv_prod_of_eq_zero","module":"Mathlib.FieldTheory.Differential.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Field R\ninst✝ : Differential R\nι : Type u_2\ns : Finset ι\nf : ι → R\nh : ∀ (x : ι), Membership.mem s x → Eq (f x) 0\n⊢ Eq (Differential.logDeriv (s.prod fun x => f x)) (s.sum fun x => Differential.logDeriv (f x))","decl":"lemma logDeriv_prod_of_eq_zero (ι : Type*) (s : Finset ι) (f : ι → R) (h : ∀ x ∈ s, f x = 0) :\n    logDeriv (∏ x ∈ s, f x) = ∑ x ∈ s, logDeriv (f x) := by\n  unfold logDeriv\n  simp_all\n\n"}
{"name":"Differential.logDeriv_algebraMap","module":"Mathlib.FieldTheory.Differential.Basic","initialProofState":"F : Type u_2\nK : Type u_3\ninst✝⁵ : Field F\ninst✝⁴ : Field K\ninst✝³ : Differential F\ninst✝² : Differential K\ninst✝¹ : Algebra F K\ninst✝ : DifferentialAlgebra F K\na : F\n⊢ Eq (Differential.logDeriv ((algebraMap F K) a)) ((algebraMap F K) (Differential.logDeriv a))","decl":"lemma logDeriv_algebraMap {F K : Type*} [Field F] [Field K] [Differential F] [Differential K]\n    [Algebra F K] [DifferentialAlgebra F K]\n    (a : F) : logDeriv (algebraMap F K a) = algebraMap F K (logDeriv a) := by\n  unfold logDeriv\n  simp [deriv_algebraMap]\n\n"}
{"name":"algebraMap.coe_logDeriv","module":"Mathlib.FieldTheory.Differential.Basic","initialProofState":"F : Type u_2\nK : Type u_3\ninst✝⁵ : Field F\ninst✝⁴ : Field K\ninst✝³ : Differential F\ninst✝² : Differential K\ninst✝¹ : Algebra F K\ninst✝ : DifferentialAlgebra F K\na : F\n⊢ Eq (↑(Differential.logDeriv a)) (Differential.logDeriv ↑a)","decl":"@[norm_cast]\nlemma _root_.algebraMap.coe_logDeriv {F K : Type*} [Field F] [Field K] [Differential F]\n    [Differential K] [Algebra F K] [DifferentialAlgebra F K]\n    (a : F) : logDeriv a = logDeriv (a : K) := (logDeriv_algebraMap a).symm\n\n"}
{"name":"Differential.instDifferentialAlgebraAdjoinRoot","module":"Mathlib.FieldTheory.Differential.Basic","initialProofState":"F : Type u_2\ninst✝³ : Field F\ninst✝² : Differential F\np : Polynomial F\ninst✝¹ : Fact (Irreducible p)\ninst✝ : Fact p.Monic\n⊢ DifferentialAlgebra F (AdjoinRoot p)","decl":"instance (p : F[X]) [Fact (Irreducible p)] [Fact p.Monic] :\n    DifferentialAlgebra F (AdjoinRoot p) where\n  deriv_algebraMap a := by\n    change (Derivation.liftOfSurjective _ _) ((AdjoinRoot.mk p).toIntAlgHom (C a)) = _\n    rw [Derivation.liftOfSurjective_apply, implicitDeriv_C]\n    rfl\n\n"}
{"name":"Differential.differentialAlgebraFiniteDimensional","module":"Mathlib.FieldTheory.Differential.Basic","initialProofState":"F : Type u_2\ninst✝⁵ : Field F\ninst✝⁴ : Differential F\ninst✝³ : CharZero F\nK : Type u_3\ninst✝² : Field K\ninst✝¹ : Algebra F K\ninst✝ : FiniteDimensional F K\n⊢ DifferentialAlgebra F K","decl":"lemma differentialAlgebraFiniteDimensional [FiniteDimensional F K] :\n    letI := differentialFiniteDimensional F K\n    DifferentialAlgebra F K := by\n  let k := (Field.exists_primitive_element F K).choose\n  haveI h : F⟮k⟯ = ⊤ := (Field.exists_primitive_element F K).choose_spec\n  haveI : Fact (minpoly F k).Monic := ⟨minpoly.monic (IsAlgebraic.of_finite ..).isIntegral⟩\n  haveI : Fact (Irreducible (minpoly F k)) :=\n    ⟨minpoly.irreducible (IsAlgebraic.of_finite ..).isIntegral⟩\n  apply DifferentialAlgebra.equiv\n\n"}
{"name":"Differential.instDifferentialAlgebraSubtypeMemIntermediateField","module":"Mathlib.FieldTheory.Differential.Basic","initialProofState":"F : Type u_2\ninst✝⁵ : Field F\ninst✝⁴ : Differential F\ninst✝³ : CharZero F\nK : Type u_3\ninst✝² : Field K\ninst✝¹ : Algebra F K\nB : IntermediateField F K\ninst✝ : FiniteDimensional F (Subtype fun x => Membership.mem B x)\n⊢ DifferentialAlgebra F (Subtype fun x => Membership.mem B x)","decl":"instance (B : IntermediateField F K) [FiniteDimensional F B] :\n    DifferentialAlgebra F B := differentialAlgebraFiniteDimensional\n\n"}
{"name":"Differential.instDifferentialAlgebraSubtypeMemIntermediateField_1","module":"Mathlib.FieldTheory.Differential.Basic","initialProofState":"F : Type u_2\ninst✝⁷ : Field F\ninst✝⁶ : Differential F\ninst✝⁵ : CharZero F\nK : Type u_3\ninst✝⁴ : Field K\ninst✝³ : Algebra F K\ninst✝² : Differential K\ninst✝¹ : DifferentialAlgebra F K\nB : IntermediateField F K\ninst✝ : FiniteDimensional F (Subtype fun x => Membership.mem B x)\n⊢ DifferentialAlgebra (Subtype fun x => Membership.mem B x) K","decl":"instance [Differential K] [DifferentialAlgebra F K] (B : IntermediateField F K)\n    [FiniteDimensional F B] : DifferentialAlgebra B K where\n  deriv_algebraMap a := by\n    change (B.val a)′ = B.val a′\n    rw [algHom_deriv']\n    exact Subtype.val_injective\n\n"}
