{"name":"CategoryTheory.Presieve.IsSheaf.isSheafFor","module":"Mathlib.CategoryTheory.Sites.SheafOfTypes","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nhp : CategoryTheory.Presieve.IsSheaf J P\nR : CategoryTheory.Presieve X\nhr : Membership.mem (J X) (CategoryTheory.Sieve.generate R)\n‚ä¢ CategoryTheory.Presieve.IsSheafFor P R","decl":"theorem IsSheaf.isSheafFor {P : C·µí·µñ ‚•§ Type w} (hp : IsSheaf J P) (R : Presieve X)\n    (hr : generate R ‚àà J X) : IsSheafFor P R :=\n  (isSheafFor_iff_generate R).2 <| hp _ hr\n\n"}
{"name":"CategoryTheory.Presieve.isSheaf_of_le","module":"Mathlib.CategoryTheory.Sites.SheafOfTypes","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nJ‚ÇÅ J‚ÇÇ : CategoryTheory.GrothendieckTopology C\na‚úù¬π : LE.le J‚ÇÅ J‚ÇÇ\na‚úù : CategoryTheory.Presieve.IsSheaf J‚ÇÇ P\n‚ä¢ CategoryTheory.Presieve.IsSheaf J‚ÇÅ P","decl":"theorem isSheaf_of_le (P : C·µí·µñ ‚•§ Type w) {J‚ÇÅ J‚ÇÇ : GrothendieckTopology C} :\n    J‚ÇÅ ‚â§ J‚ÇÇ ‚Üí IsSheaf J‚ÇÇ P ‚Üí IsSheaf J‚ÇÅ P := fun h t _ S hS => t S (h _ hS)\n\n"}
{"name":"CategoryTheory.Presieve.isSeparated_of_isSheaf","module":"Mathlib.CategoryTheory.Sites.SheafOfTypes","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nh : CategoryTheory.Presieve.IsSheaf J P\n‚ä¢ CategoryTheory.Presieve.IsSeparated J P","decl":"theorem isSeparated_of_isSheaf (P : C·µí·µñ ‚•§ Type w) (h : IsSheaf J P) : IsSeparated J P :=\n  fun S hS => (h S hS).isSeparatedFor\n\n"}
{"name":"CategoryTheory.Presieve.isSheaf_of_nat_equiv","module":"Mathlib.CategoryTheory.Sites.SheafOfTypes","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nP‚ÇÅ : CategoryTheory.Functor (Opposite C) (Type w)\nP‚ÇÇ : CategoryTheory.Functor (Opposite C) (Type w')\ne : ‚¶ÉX : C‚¶Ñ ‚Üí Equiv (P‚ÇÅ.obj { unop := X }) (P‚ÇÇ.obj { unop := X })\nhe : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : Quiver.Hom X Y) (x : P‚ÇÅ.obj { unop := Y }), Eq (e (P‚ÇÅ.map f.op x)) (P‚ÇÇ.map f.op (e x))\nhP‚ÇÅ : CategoryTheory.Presieve.IsSheaf J P‚ÇÅ\n‚ä¢ CategoryTheory.Presieve.IsSheaf J P‚ÇÇ","decl":"include he in\nlemma isSheaf_of_nat_equiv (hP‚ÇÅ : Presieve.IsSheaf J P‚ÇÅ) :\n    Presieve.IsSheaf J P‚ÇÇ := fun _ R hR ‚Ü¶\n  isSheafFor_of_nat_equiv e he (hP‚ÇÅ R hR)\n\n"}
{"name":"CategoryTheory.Presieve.isSheaf_iff_of_nat_equiv","module":"Mathlib.CategoryTheory.Sites.SheafOfTypes","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nP‚ÇÅ : CategoryTheory.Functor (Opposite C) (Type w)\nP‚ÇÇ : CategoryTheory.Functor (Opposite C) (Type w')\ne : ‚¶ÉX : C‚¶Ñ ‚Üí Equiv (P‚ÇÅ.obj { unop := X }) (P‚ÇÇ.obj { unop := X })\nhe : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : Quiver.Hom X Y) (x : P‚ÇÅ.obj { unop := Y }), Eq (e (P‚ÇÅ.map f.op x)) (P‚ÇÇ.map f.op (e x))\n‚ä¢ Iff (CategoryTheory.Presieve.IsSheaf J P‚ÇÅ) (CategoryTheory.Presieve.IsSheaf J P‚ÇÇ)","decl":"include he in\nlemma isSheaf_iff_of_nat_equiv :\n    Presieve.IsSheaf J P‚ÇÅ ‚Üî Presieve.IsSheaf J P‚ÇÇ :=\n  ‚ü®fun hP‚ÇÅ ‚Ü¶ isSheaf_of_nat_equiv e he hP‚ÇÅ,\n    fun hP‚ÇÇ ‚Ü¶\n      isSheaf_of_nat_equiv (fun _ ‚Ü¶ (@e _).symm) (fun X Y f x ‚Ü¶ by\n        obtain ‚ü®y, rfl‚ü© := e.surjective x\n        refine e.injective ?_\n        simp only [Equiv.apply_symm_apply, Equiv.symm_apply_apply, he]) hP‚ÇÇ‚ü©\n\n"}
{"name":"CategoryTheory.Presieve.isSheaf_iso","module":"Mathlib.CategoryTheory.Sites.SheafOfTypes","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nJ : CategoryTheory.GrothendieckTopology C\nP' : CategoryTheory.Functor (Opposite C) (Type w)\ni : CategoryTheory.Iso P P'\nh : CategoryTheory.Presieve.IsSheaf J P\n‚ä¢ CategoryTheory.Presieve.IsSheaf J P'","decl":"/-- The property of being a sheaf is preserved by isomorphism. -/\ntheorem isSheaf_iso {P' : C·µí·µñ ‚•§ Type w} (i : P ‚âÖ P') (h : IsSheaf J P) : IsSheaf J P' :=\n  fun _ S hS => isSheafFor_iso i (h S hS)\n\n"}
{"name":"CategoryTheory.Presieve.isSheaf_of_yoneda","module":"Mathlib.CategoryTheory.Sites.SheafOfTypes","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) (Type v)\nh : ‚àÄ {X : C} (S : CategoryTheory.Sieve X), Membership.mem (J X) S ‚Üí CategoryTheory.Presieve.YonedaSheafCondition P S\n‚ä¢ CategoryTheory.Presieve.IsSheaf J P","decl":"theorem isSheaf_of_yoneda {P : C·µí·µñ ‚•§ Type v}\n    (h : ‚àÄ {X} (S : Sieve X), S ‚àà J X ‚Üí YonedaSheafCondition P S) : IsSheaf J P := fun _ _ hS =>\n  isSheafFor_iff_yonedaSheafCondition.2 (h _ hS)\n\n"}
{"name":"CategoryTheory.Presieve.isSheaf_pretopology","module":"Mathlib.CategoryTheory.Sites.SheafOfTypes","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nK : CategoryTheory.Pretopology C\n‚ä¢ Iff (CategoryTheory.Presieve.IsSheaf (CategoryTheory.Pretopology.toGrothendieck C K) P) (‚àÄ {X : C} (R : CategoryTheory.Presieve X), Membership.mem (K.coverings X) R ‚Üí CategoryTheory.Presieve.IsSheafFor P R)","decl":"/-- For a topology generated by a basis, it suffices to check the sheaf condition on the basis\npresieves only.\n-/\ntheorem isSheaf_pretopology [HasPullbacks C] (K : Pretopology C) :\n    IsSheaf (K.toGrothendieck C) P ‚Üî ‚àÄ {X : C} (R : Presieve X), R ‚àà K X ‚Üí IsSheafFor P R := by\n  constructor\n  ¬∑ intro PJ X R hR\n    rw [isSheafFor_iff_generate]\n    apply PJ (Sieve.generate R) ‚ü®_, hR, le_generate R‚ü©\n  ¬∑ rintro PK X S ‚ü®R, hR, RS‚ü©\n    have gRS : ‚áë(generate R) ‚â§ S := by\n      apply giGenerate.gc.monotone_u\n      rwa [generate_le_iff]\n    apply isSheafFor_subsieve P gRS _\n    intro Y f\n    rw [‚Üê pullbackArrows_comm, ‚Üê isSheafFor_iff_generate]\n    exact PK (pullbackArrows f R) (K.pullbacks f R hR)\n\n"}
{"name":"CategoryTheory.Presieve.isSheaf_bot","module":"Mathlib.CategoryTheory.Sites.SheafOfTypes","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\n‚ä¢ CategoryTheory.Presieve.IsSheaf Bot.bot P","decl":"/-- Any presheaf is a sheaf for the bottom (trivial) grothendieck topology. -/\ntheorem isSheaf_bot : IsSheaf (‚ä• : GrothendieckTopology C) P := fun X => by\n  simp [isSheafFor_top_sieve]\n\n"}
{"name":"CategoryTheory.Sieve.yonedaFamily_fromCocone_compatible","module":"Mathlib.CategoryTheory.Sites.SheafOfTypes","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nS : CategoryTheory.Sieve X\ns : CategoryTheory.Limits.Cocone S.arrows.diagram\n‚ä¢ (S.arrows.yonedaFamilyOfElements_fromCocone s).Compatible","decl":"theorem yonedaFamily_fromCocone_compatible (S : Sieve X) (s : Cocone (diagram S.arrows)) :\n    FamilyOfElements.Compatible <| yonedaFamilyOfElements_fromCocone S.arrows s := by\n  intro Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ hf‚ÇÅ hf‚ÇÇ hgf\n  have Hs := s.Œπ.naturality\n  simp only [Functor.id_obj, yoneda_obj_obj, Opposite.unop_op, yoneda_obj_map, Quiver.Hom.unop_op]\n  dsimp [yonedaFamilyOfElements_fromCocone]\n  have hgf‚ÇÅ : S.arrows (g‚ÇÅ ‚â´ f‚ÇÅ) := by exact Sieve.downward_closed S hf‚ÇÅ g‚ÇÅ\n  have hgf‚ÇÇ : S.arrows (g‚ÇÇ ‚â´ f‚ÇÇ) := by exact Sieve.downward_closed S hf‚ÇÇ g‚ÇÇ\n  let F : (Over.mk (g‚ÇÅ ‚â´ f‚ÇÅ) : Over X) ‚ü∂ (Over.mk (g‚ÇÇ ‚â´ f‚ÇÇ) : Over X) := Over.homMk (ùüô Z)\n  let F‚ÇÅ : (Over.mk (g‚ÇÅ ‚â´ f‚ÇÅ) : Over X) ‚ü∂ (Over.mk f‚ÇÅ : Over X) := Over.homMk g‚ÇÅ\n  let F‚ÇÇ : (Over.mk (g‚ÇÇ ‚â´ f‚ÇÇ) : Over X) ‚ü∂ (Over.mk f‚ÇÇ : Over X) := Over.homMk g‚ÇÇ\n  have hF := @Hs ‚ü®Over.mk (g‚ÇÅ ‚â´ f‚ÇÅ), hgf‚ÇÅ‚ü© ‚ü®Over.mk (g‚ÇÇ ‚â´ f‚ÇÇ), hgf‚ÇÇ‚ü© F\n  have hF‚ÇÅ := @Hs ‚ü®Over.mk (g‚ÇÅ ‚â´ f‚ÇÅ), hgf‚ÇÅ‚ü© ‚ü®Over.mk f‚ÇÅ, hf‚ÇÅ‚ü© F‚ÇÅ\n  have hF‚ÇÇ := @Hs ‚ü®Over.mk (g‚ÇÇ ‚â´ f‚ÇÇ), hgf‚ÇÇ‚ü© ‚ü®Over.mk f‚ÇÇ, hf‚ÇÇ‚ü© F‚ÇÇ\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Sieve.forallYonedaIsSheaf_iff_colimit","module":"Mathlib.CategoryTheory.Sites.SheafOfTypes","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nS : CategoryTheory.Sieve X\n‚ä¢ Iff (‚àÄ (W : C), CategoryTheory.Presieve.IsSheafFor (CategoryTheory.yoneda.obj W) S.arrows) (Nonempty (CategoryTheory.Limits.IsColimit S.arrows.cocone))","decl":"/--\nThe base of a sieve `S` is a colimit of `S` iff all Yoneda-presheaves satisfy\nthe sheaf condition for `S`.\n-/\ntheorem forallYonedaIsSheaf_iff_colimit (S : Sieve X) :\n    (‚àÄ W : C, Presieve.IsSheafFor (yoneda.obj W) (S : Presieve X)) ‚Üî\n      Nonempty (IsColimit S.arrows.cocone) := by\n  constructor\n  ¬∑ intro H\n    refine Nonempty.intro ?_\n    exact\n    { desc := fun s => H s.pt (yonedaFamilyOfElements_fromCocone S.arrows s)\n        (yonedaFamily_fromCocone_compatible S s) |>.choose\n      fac := by\n        intro s f\n        replace H := H s.pt (yonedaFamilyOfElements_fromCocone S.arrows s)\n          (yonedaFamily_fromCocone_compatible S s)\n        have ht := H.choose_spec.1 f.obj.hom f.property\n        aesop_cat\n      uniq := by\n        intro s Fs HFs\n        replace H := H s.pt (yonedaFamilyOfElements_fromCocone S.arrows s)\n          (yonedaFamily_fromCocone_compatible S s)\n        apply H.choose_spec.2 Fs\n        exact fun _ f hf => HFs ‚ü®Over.mk f, hf‚ü© }\n  ¬∑ intro H W x hx\n    replace H := Classical.choice H\n    let s := compatibleYonedaFamily_toCocone S.arrows W x hx\n    use H.desc s\n    constructor\n    ¬∑ exact fun _ f hf => (H.fac s) ‚ü®Over.mk f, hf‚ü©\n    ¬∑ exact fun g hg => H.uniq s g (fun ‚ü®‚ü®f, _, hom‚ü©, hf‚ü© => hg hom hf)\n\n"}
