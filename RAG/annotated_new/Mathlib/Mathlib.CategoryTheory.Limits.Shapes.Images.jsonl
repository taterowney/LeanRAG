{"name":"CategoryTheory.Limits.MonoFactorisation.m_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nself : CategoryTheory.Limits.MonoFactorisation f\n⊢ CategoryTheory.Mono self.m","decl":"/-- A factorisation of a morphism `f = e ≫ m`, with `m` monic. -/\nstructure MonoFactorisation (f : X ⟶ Y) where\n  I : C -- Porting note: violates naming conventions but can't think a better replacement\n  m : I ⟶ Y\n  [m_mono : Mono m]\n  e : X ⟶ I\n  fac : e ≫ m = f := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : SizeOf C\nI : C\nm : Quiver.Hom I Y\nm_mono : CategoryTheory.Mono m\ne : Quiver.Hom X I\nfac : autoParam (Eq (CategoryTheory.CategoryStruct.comp e m) f) _auto✝\n⊢ Eq (SizeOf.sizeOf (CategoryTheory.Limits.MonoFactorisation.mk I m e fac)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf I)) (SizeOf.sizeOf m)) (SizeOf.sizeOf m_mono)) (SizeOf.sizeOf e)) (SizeOf.sizeOf fac))","decl":"/-- A factorisation of a morphism `f = e ≫ m`, with `m` monic. -/\nstructure MonoFactorisation (f : X ⟶ Y) where\n  I : C -- Porting note: violates naming conventions but can't think a better replacement\n  m : I ⟶ Y\n  [m_mono : Mono m]\n  e : X ⟶ I\n  fac : e ≫ m = f := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.fac","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nself : CategoryTheory.Limits.MonoFactorisation f\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.e self.m) f","decl":"/-- A factorisation of a morphism `f = e ≫ m`, with `m` monic. -/\nstructure MonoFactorisation (f : X ⟶ Y) where\n  I : C -- Porting note: violates naming conventions but can't think a better replacement\n  m : I ⟶ Y\n  [m_mono : Mono m]\n  e : X ⟶ I\n  fac : e ≫ m = f := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nI✝ : C\nm✝ : Quiver.Hom I✝ Y\nm_mono✝ : CategoryTheory.Mono m✝\ne✝ : Quiver.Hom X I✝\nfac✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp e✝ m✝) f) _auto✝\nI : C\nm : Quiver.Hom I Y\nm_mono : CategoryTheory.Mono m\ne : Quiver.Hom X I\nfac : autoParam (Eq (CategoryTheory.CategoryStruct.comp e m) f) _auto✝\nx✝ : Eq (CategoryTheory.Limits.MonoFactorisation.mk I✝ m✝ e✝ fac✝) (CategoryTheory.Limits.MonoFactorisation.mk I m e fac)\n⊢ And (Eq I✝ I) (And (HEq m✝ m) (HEq e✝ e))","decl":"/-- A factorisation of a morphism `f = e ≫ m`, with `m` monic. -/\nstructure MonoFactorisation (f : X ⟶ Y) where\n  I : C -- Porting note: violates naming conventions but can't think a better replacement\n  m : I ⟶ Y\n  [m_mono : Mono m]\n  e : X ⟶ I\n  fac : e ≫ m = f := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nI✝ : C\nm✝ : Quiver.Hom I✝ Y\nm_mono✝ : CategoryTheory.Mono m✝\ne✝ : Quiver.Hom X I✝\nfac✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp e✝ m✝) f) _auto✝\nI : C\nm : Quiver.Hom I Y\nm_mono : CategoryTheory.Mono m\ne : Quiver.Hom X I\nfac : autoParam (Eq (CategoryTheory.CategoryStruct.comp e m) f) _auto✝\n⊢ Eq (Eq (CategoryTheory.Limits.MonoFactorisation.mk I✝ m✝ e✝ fac✝) (CategoryTheory.Limits.MonoFactorisation.mk I m e fac)) (And (Eq I✝ I) (And (HEq m✝ m) (HEq e✝ e)))","decl":"/-- A factorisation of a morphism `f = e ≫ m`, with `m` monic. -/\nstructure MonoFactorisation (f : X ⟶ Y) where\n  I : C -- Porting note: violates naming conventions but can't think a better replacement\n  m : I ⟶ Y\n  [m_mono : Mono m]\n  e : X ⟶ I\n  fac : e ≫ m = f := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.fac_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nself : CategoryTheory.Limits.MonoFactorisation f\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.e (CategoryTheory.CategoryStruct.comp self.m h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"attribute [reassoc (attr := simp)] MonoFactorisation.fac\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF F' : CategoryTheory.Limits.MonoFactorisation f\nhI : Eq F.I F'.I\nhm : Eq F.m (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom hI) F'.m)\n⊢ Eq F F'","decl":"/-- The morphism `m` in a factorisation `f = e ≫ m` through a monomorphism is uniquely\ndetermined. -/\n@[ext (iff := false)]\ntheorem ext {F F' : MonoFactorisation f} (hI : F.I = F'.I)\n    (hm : F.m = eqToHom hI ≫ F'.m) : F = F' := by\n  cases' F with _ Fm _ _ Ffac; cases' F' with _ Fm' _ _ Ffac'\n  cases' hI\n  simp? at hm says simp only [eqToHom_refl, Category.id_comp] at hm\n  congr\n  apply (cancel_mono Fm).1\n  rw [Ffac, hm, Ffac']\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.compMono_e","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF : CategoryTheory.Limits.MonoFactorisation f\nY' : C\ng : Quiver.Hom Y Y'\ninst✝ : CategoryTheory.Mono g\n⊢ Eq (F.compMono g).e F.e","decl":"/-- Any mono factorisation of `f` gives a mono factorisation of `f ≫ g` when `g` is a mono. -/\n@[simps]\ndef compMono (F : MonoFactorisation f) {Y' : C} (g : Y ⟶ Y') [Mono g] :\n    MonoFactorisation (f ≫ g) where\n  I := F.I\n  m := F.m ≫ g\n  m_mono := mono_comp _ _\n  e := F.e\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.compMono_I","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF : CategoryTheory.Limits.MonoFactorisation f\nY' : C\ng : Quiver.Hom Y Y'\ninst✝ : CategoryTheory.Mono g\n⊢ Eq (F.compMono g).I F.I","decl":"/-- Any mono factorisation of `f` gives a mono factorisation of `f ≫ g` when `g` is a mono. -/\n@[simps]\ndef compMono (F : MonoFactorisation f) {Y' : C} (g : Y ⟶ Y') [Mono g] :\n    MonoFactorisation (f ≫ g) where\n  I := F.I\n  m := F.m ≫ g\n  m_mono := mono_comp _ _\n  e := F.e\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.compMono_m","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF : CategoryTheory.Limits.MonoFactorisation f\nY' : C\ng : Quiver.Hom Y Y'\ninst✝ : CategoryTheory.Mono g\n⊢ Eq (F.compMono g).m (CategoryTheory.CategoryStruct.comp F.m g)","decl":"/-- Any mono factorisation of `f` gives a mono factorisation of `f ≫ g` when `g` is a mono. -/\n@[simps]\ndef compMono (F : MonoFactorisation f) {Y' : C} (g : Y ⟶ Y') [Mono g] :\n    MonoFactorisation (f ≫ g) where\n  I := F.I\n  m := F.m ≫ g\n  m_mono := mono_comp _ _\n  e := F.e\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.ofCompIso_m","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nY' : C\ng : Quiver.Hom Y Y'\ninst✝ : CategoryTheory.IsIso g\nF : CategoryTheory.Limits.MonoFactorisation (CategoryTheory.CategoryStruct.comp f g)\n⊢ Eq F.ofCompIso.m (CategoryTheory.CategoryStruct.comp F.m (CategoryTheory.inv g))","decl":"/-- A mono factorisation of `f ≫ g`, where `g` is an isomorphism,\ngives a mono factorisation of `f`. -/\n@[simps]\ndef ofCompIso {Y' : C} {g : Y ⟶ Y'} [IsIso g] (F : MonoFactorisation (f ≫ g)) :\n    MonoFactorisation f where\n  I := F.I\n  m := F.m ≫ inv g\n  m_mono := mono_comp _ _\n  e := F.e\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.ofCompIso_I","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nY' : C\ng : Quiver.Hom Y Y'\ninst✝ : CategoryTheory.IsIso g\nF : CategoryTheory.Limits.MonoFactorisation (CategoryTheory.CategoryStruct.comp f g)\n⊢ Eq F.ofCompIso.I F.I","decl":"/-- A mono factorisation of `f ≫ g`, where `g` is an isomorphism,\ngives a mono factorisation of `f`. -/\n@[simps]\ndef ofCompIso {Y' : C} {g : Y ⟶ Y'} [IsIso g] (F : MonoFactorisation (f ≫ g)) :\n    MonoFactorisation f where\n  I := F.I\n  m := F.m ≫ inv g\n  m_mono := mono_comp _ _\n  e := F.e\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.ofCompIso_e","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nY' : C\ng : Quiver.Hom Y Y'\ninst✝ : CategoryTheory.IsIso g\nF : CategoryTheory.Limits.MonoFactorisation (CategoryTheory.CategoryStruct.comp f g)\n⊢ Eq F.ofCompIso.e F.e","decl":"/-- A mono factorisation of `f ≫ g`, where `g` is an isomorphism,\ngives a mono factorisation of `f`. -/\n@[simps]\ndef ofCompIso {Y' : C} {g : Y ⟶ Y'} [IsIso g] (F : MonoFactorisation (f ≫ g)) :\n    MonoFactorisation f where\n  I := F.I\n  m := F.m ≫ inv g\n  m_mono := mono_comp _ _\n  e := F.e\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.isoComp_m","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF : CategoryTheory.Limits.MonoFactorisation f\nX' : C\ng : Quiver.Hom X' X\n⊢ Eq (F.isoComp g).m F.m","decl":"/-- Any mono factorisation of `f` gives a mono factorisation of `g ≫ f`. -/\n@[simps]\ndef isoComp (F : MonoFactorisation f) {X' : C} (g : X' ⟶ X) : MonoFactorisation (g ≫ f) where\n  I := F.I\n  m := F.m\n  e := g ≫ F.e\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.isoComp_e","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF : CategoryTheory.Limits.MonoFactorisation f\nX' : C\ng : Quiver.Hom X' X\n⊢ Eq (F.isoComp g).e (CategoryTheory.CategoryStruct.comp g F.e)","decl":"/-- Any mono factorisation of `f` gives a mono factorisation of `g ≫ f`. -/\n@[simps]\ndef isoComp (F : MonoFactorisation f) {X' : C} (g : X' ⟶ X) : MonoFactorisation (g ≫ f) where\n  I := F.I\n  m := F.m\n  e := g ≫ F.e\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.isoComp_I","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF : CategoryTheory.Limits.MonoFactorisation f\nX' : C\ng : Quiver.Hom X' X\n⊢ Eq (F.isoComp g).I F.I","decl":"/-- Any mono factorisation of `f` gives a mono factorisation of `g ≫ f`. -/\n@[simps]\ndef isoComp (F : MonoFactorisation f) {X' : C} (g : X' ⟶ X) : MonoFactorisation (g ≫ f) where\n  I := F.I\n  m := F.m\n  e := g ≫ F.e\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.ofIsoComp_I","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nX' : C\ng : Quiver.Hom X' X\ninst✝ : CategoryTheory.IsIso g\nF : CategoryTheory.Limits.MonoFactorisation (CategoryTheory.CategoryStruct.comp g f)\n⊢ Eq (CategoryTheory.Limits.MonoFactorisation.ofIsoComp g F).I F.I","decl":"/-- A mono factorisation of `g ≫ f`, where `g` is an isomorphism,\ngives a mono factorisation of `f`. -/\n@[simps]\ndef ofIsoComp {X' : C} (g : X' ⟶ X) [IsIso g] (F : MonoFactorisation (g ≫ f)) :\n    MonoFactorisation f where\n  I := F.I\n  m := F.m\n  e := inv g ≫ F.e\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.ofIsoComp_m","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nX' : C\ng : Quiver.Hom X' X\ninst✝ : CategoryTheory.IsIso g\nF : CategoryTheory.Limits.MonoFactorisation (CategoryTheory.CategoryStruct.comp g f)\n⊢ Eq (CategoryTheory.Limits.MonoFactorisation.ofIsoComp g F).m F.m","decl":"/-- A mono factorisation of `g ≫ f`, where `g` is an isomorphism,\ngives a mono factorisation of `f`. -/\n@[simps]\ndef ofIsoComp {X' : C} (g : X' ⟶ X) [IsIso g] (F : MonoFactorisation (g ≫ f)) :\n    MonoFactorisation f where\n  I := F.I\n  m := F.m\n  e := inv g ≫ F.e\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.ofIsoComp_e","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nX' : C\ng : Quiver.Hom X' X\ninst✝ : CategoryTheory.IsIso g\nF : CategoryTheory.Limits.MonoFactorisation (CategoryTheory.CategoryStruct.comp g f)\n⊢ Eq (CategoryTheory.Limits.MonoFactorisation.ofIsoComp g F).e (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv g) F.e)","decl":"/-- A mono factorisation of `g ≫ f`, where `g` is an isomorphism,\ngives a mono factorisation of `f`. -/\n@[simps]\ndef ofIsoComp {X' : C} (g : X' ⟶ X) [IsIso g] (F : MonoFactorisation (g ≫ f)) :\n    MonoFactorisation f where\n  I := F.I\n  m := F.m\n  e := inv g ≫ F.e\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.ofArrowIso_I","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\nF : CategoryTheory.Limits.MonoFactorisation f.hom\nsq : Quiver.Hom f g\ninst✝ : CategoryTheory.IsIso sq\n⊢ Eq (F.ofArrowIso sq).I F.I","decl":"/-- If `f` and `g` are isomorphic arrows, then a mono factorisation of `f`\ngives a mono factorisation of `g` -/\n@[simps]\ndef ofArrowIso {f g : Arrow C} (F : MonoFactorisation f.hom) (sq : f ⟶ g) [IsIso sq] :\n    MonoFactorisation g.hom where\n  I := F.I\n  m := F.m ≫ sq.right\n  e := inv sq.left ≫ F.e\n  m_mono := mono_comp _ _\n  fac := by simp only [fac_assoc, Arrow.w, IsIso.inv_comp_eq, Category.assoc]\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.ofArrowIso_e","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\nF : CategoryTheory.Limits.MonoFactorisation f.hom\nsq : Quiver.Hom f g\ninst✝ : CategoryTheory.IsIso sq\n⊢ Eq (F.ofArrowIso sq).e (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv sq.left) F.e)","decl":"/-- If `f` and `g` are isomorphic arrows, then a mono factorisation of `f`\ngives a mono factorisation of `g` -/\n@[simps]\ndef ofArrowIso {f g : Arrow C} (F : MonoFactorisation f.hom) (sq : f ⟶ g) [IsIso sq] :\n    MonoFactorisation g.hom where\n  I := F.I\n  m := F.m ≫ sq.right\n  e := inv sq.left ≫ F.e\n  m_mono := mono_comp _ _\n  fac := by simp only [fac_assoc, Arrow.w, IsIso.inv_comp_eq, Category.assoc]\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.ofArrowIso_m","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\nF : CategoryTheory.Limits.MonoFactorisation f.hom\nsq : Quiver.Hom f g\ninst✝ : CategoryTheory.IsIso sq\n⊢ Eq (F.ofArrowIso sq).m (CategoryTheory.CategoryStruct.comp F.m sq.right)","decl":"/-- If `f` and `g` are isomorphic arrows, then a mono factorisation of `f`\ngives a mono factorisation of `g` -/\n@[simps]\ndef ofArrowIso {f g : Arrow C} (F : MonoFactorisation f.hom) (sq : f ⟶ g) [IsIso sq] :\n    MonoFactorisation g.hom where\n  I := F.I\n  m := F.m ≫ sq.right\n  e := inv sq.left ≫ F.e\n  m_mono := mono_comp _ _\n  fac := by simp only [fac_assoc, Arrow.w, IsIso.inv_comp_eq, Category.assoc]\n\n"}
{"name":"CategoryTheory.Limits.IsImage.lift_fac","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF : CategoryTheory.Limits.MonoFactorisation f\nself : CategoryTheory.Limits.IsImage F\nF' : CategoryTheory.Limits.MonoFactorisation f\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.lift F') F'.m) F.m","decl":"/-- Data exhibiting that a given factorisation through a mono is initial. -/\nstructure IsImage (F : MonoFactorisation f) where\n  lift : ∀ F' : MonoFactorisation f, F.I ⟶ F'.I\n  lift_fac : ∀ F' : MonoFactorisation f, lift F' ≫ F'.m = F.m := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.IsImage.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF : CategoryTheory.Limits.MonoFactorisation f\nlift✝ : (F' : CategoryTheory.Limits.MonoFactorisation f) → Quiver.Hom F.I F'.I\nlift_fac✝ : autoParam (∀ (F' : CategoryTheory.Limits.MonoFactorisation f), Eq (CategoryTheory.CategoryStruct.comp (lift✝ F') F'.m) F.m) _auto✝\nlift : (F' : CategoryTheory.Limits.MonoFactorisation f) → Quiver.Hom F.I F'.I\nlift_fac : autoParam (∀ (F' : CategoryTheory.Limits.MonoFactorisation f), Eq (CategoryTheory.CategoryStruct.comp (lift F') F'.m) F.m) _auto✝\n⊢ Eq (Eq { lift := lift✝, lift_fac := lift_fac✝ } { lift := lift, lift_fac := lift_fac }) (Eq lift✝ lift)","decl":"/-- Data exhibiting that a given factorisation through a mono is initial. -/\nstructure IsImage (F : MonoFactorisation f) where\n  lift : ∀ F' : MonoFactorisation f, F.I ⟶ F'.I\n  lift_fac : ∀ F' : MonoFactorisation f, lift F' ≫ F'.m = F.m := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.IsImage.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF : CategoryTheory.Limits.MonoFactorisation f\ninst✝ : SizeOf C\nlift : (F' : CategoryTheory.Limits.MonoFactorisation f) → Quiver.Hom F.I F'.I\nlift_fac : autoParam (∀ (F' : CategoryTheory.Limits.MonoFactorisation f), Eq (CategoryTheory.CategoryStruct.comp (lift F') F'.m) F.m) _auto✝\n⊢ Eq (SizeOf.sizeOf { lift := lift, lift_fac := lift_fac }) 1","decl":"/-- Data exhibiting that a given factorisation through a mono is initial. -/\nstructure IsImage (F : MonoFactorisation f) where\n  lift : ∀ F' : MonoFactorisation f, F.I ⟶ F'.I\n  lift_fac : ∀ F' : MonoFactorisation f, lift F' ≫ F'.m = F.m := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.IsImage.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF : CategoryTheory.Limits.MonoFactorisation f\nlift✝ : (F' : CategoryTheory.Limits.MonoFactorisation f) → Quiver.Hom F.I F'.I\nlift_fac✝ : autoParam (∀ (F' : CategoryTheory.Limits.MonoFactorisation f), Eq (CategoryTheory.CategoryStruct.comp (lift✝ F') F'.m) F.m) _auto✝\nlift : (F' : CategoryTheory.Limits.MonoFactorisation f) → Quiver.Hom F.I F'.I\nlift_fac : autoParam (∀ (F' : CategoryTheory.Limits.MonoFactorisation f), Eq (CategoryTheory.CategoryStruct.comp (lift F') F'.m) F.m) _auto✝\nx✝ : Eq { lift := lift✝, lift_fac := lift_fac✝ } { lift := lift, lift_fac := lift_fac }\n⊢ Eq lift✝ lift","decl":"/-- Data exhibiting that a given factorisation through a mono is initial. -/\nstructure IsImage (F : MonoFactorisation f) where\n  lift : ∀ F' : MonoFactorisation f, F.I ⟶ F'.I\n  lift_fac : ∀ F' : MonoFactorisation f, lift F' ≫ F'.m = F.m := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.IsImage.lift_fac_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF : CategoryTheory.Limits.MonoFactorisation f\nself : CategoryTheory.Limits.IsImage F\nF' : CategoryTheory.Limits.MonoFactorisation f\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.lift F') (CategoryTheory.CategoryStruct.comp F'.m h)) (CategoryTheory.CategoryStruct.comp F.m h)","decl":"attribute [reassoc (attr := simp)] IsImage.lift_fac\n\n"}
{"name":"CategoryTheory.Limits.IsImage.fac_lift","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF : CategoryTheory.Limits.MonoFactorisation f\nhF : CategoryTheory.Limits.IsImage F\nF' : CategoryTheory.Limits.MonoFactorisation f\n⊢ Eq (CategoryTheory.CategoryStruct.comp F.e (hF.lift F')) F'.e","decl":"@[reassoc (attr := simp)]\ntheorem fac_lift {F : MonoFactorisation f} (hF : IsImage F) (F' : MonoFactorisation f) :\n    F.e ≫ hF.lift F' = F'.e :=\n  (cancel_mono F'.m).1 <| by simp\n\n"}
{"name":"CategoryTheory.Limits.IsImage.fac_lift_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF : CategoryTheory.Limits.MonoFactorisation f\nhF : CategoryTheory.Limits.IsImage F\nF' : CategoryTheory.Limits.MonoFactorisation f\nZ : C\nh : Quiver.Hom F'.I Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp F.e (CategoryTheory.CategoryStruct.comp (hF.lift F') h)) (CategoryTheory.CategoryStruct.comp F'.e h)","decl":"@[reassoc (attr := simp)]\ntheorem fac_lift {F : MonoFactorisation f} (hF : IsImage F) (F' : MonoFactorisation f) :\n    F.e ≫ hF.lift F' = F'.e :=\n  (cancel_mono F'.m).1 <| by simp\n\n"}
{"name":"CategoryTheory.Limits.IsImage.self_lift","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\nF' : CategoryTheory.Limits.MonoFactorisation f\n⊢ Eq ((CategoryTheory.Limits.IsImage.self f).lift F') F'.e","decl":"/-- The trivial factorisation of a monomorphism satisfies the universal property. -/\n@[simps]\ndef self [Mono f] : IsImage (MonoFactorisation.self f) where lift F' := F'.e\n\n"}
{"name":"CategoryTheory.Limits.IsImage.isoExt_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF F' : CategoryTheory.Limits.MonoFactorisation f\nhF : CategoryTheory.Limits.IsImage F\nhF' : CategoryTheory.Limits.IsImage F'\n⊢ Eq (hF.isoExt hF').inv (hF'.lift F)","decl":"/-- Two factorisations through monomorphisms satisfying the universal property\nmust factor through isomorphic objects. -/\n@[simps]\ndef isoExt {F F' : MonoFactorisation f} (hF : IsImage F) (hF' : IsImage F') :\n    F.I ≅ F'.I where\n  hom := hF.lift F'\n  inv := hF'.lift F\n  hom_inv_id := (cancel_mono F.m).1 (by simp)\n  inv_hom_id := (cancel_mono F'.m).1 (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsImage.isoExt_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF F' : CategoryTheory.Limits.MonoFactorisation f\nhF : CategoryTheory.Limits.IsImage F\nhF' : CategoryTheory.Limits.IsImage F'\n⊢ Eq (hF.isoExt hF').hom (hF.lift F')","decl":"/-- Two factorisations through monomorphisms satisfying the universal property\nmust factor through isomorphic objects. -/\n@[simps]\ndef isoExt {F F' : MonoFactorisation f} (hF : IsImage F) (hF' : IsImage F') :\n    F.I ≅ F'.I where\n  hom := hF.lift F'\n  inv := hF'.lift F\n  hom_inv_id := (cancel_mono F.m).1 (by simp)\n  inv_hom_id := (cancel_mono F'.m).1 (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsImage.isoExt_hom_m","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF F' : CategoryTheory.Limits.MonoFactorisation f\nhF : CategoryTheory.Limits.IsImage F\nhF' : CategoryTheory.Limits.IsImage F'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hF.isoExt hF').hom F'.m) F.m","decl":"theorem isoExt_hom_m : (isoExt hF hF').hom ≫ F'.m = F.m := by simp\n\n"}
{"name":"CategoryTheory.Limits.IsImage.isoExt_inv_m","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF F' : CategoryTheory.Limits.MonoFactorisation f\nhF : CategoryTheory.Limits.IsImage F\nhF' : CategoryTheory.Limits.IsImage F'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hF.isoExt hF').inv F.m) F'.m","decl":"theorem isoExt_inv_m : (isoExt hF hF').inv ≫ F.m = F'.m := by simp\n\n"}
{"name":"CategoryTheory.Limits.IsImage.e_isoExt_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF F' : CategoryTheory.Limits.MonoFactorisation f\nhF : CategoryTheory.Limits.IsImage F\nhF' : CategoryTheory.Limits.IsImage F'\n⊢ Eq (CategoryTheory.CategoryStruct.comp F.e (hF.isoExt hF').hom) F'.e","decl":"theorem e_isoExt_hom : F.e ≫ (isoExt hF hF').hom = F'.e := by simp\n\n"}
{"name":"CategoryTheory.Limits.IsImage.e_isoExt_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF F' : CategoryTheory.Limits.MonoFactorisation f\nhF : CategoryTheory.Limits.IsImage F\nhF' : CategoryTheory.Limits.IsImage F'\n⊢ Eq (CategoryTheory.CategoryStruct.comp F'.e (hF.isoExt hF').inv) F.e","decl":"theorem e_isoExt_inv : F'.e ≫ (isoExt hF hF').inv = F.e := by simp\n\n"}
{"name":"CategoryTheory.Limits.IsImage.ofArrowIso_lift","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\nF : CategoryTheory.Limits.MonoFactorisation f.hom\nhF : CategoryTheory.Limits.IsImage F\nsq : Quiver.Hom f g\ninst✝ : CategoryTheory.IsIso sq\nF' : CategoryTheory.Limits.MonoFactorisation g.hom\n⊢ Eq ((hF.ofArrowIso sq).lift F') (hF.lift (F'.ofArrowIso (CategoryTheory.inv sq)))","decl":"/-- If `f` and `g` are isomorphic arrows, then a mono factorisation of `f` that is an image\ngives a mono factorisation of `g` that is an image -/\n@[simps]\ndef ofArrowIso {f g : Arrow C} {F : MonoFactorisation f.hom} (hF : IsImage F) (sq : f ⟶ g)\n    [IsIso sq] : IsImage (F.ofArrowIso sq) where\n  lift F' := hF.lift (F'.ofArrowIso (inv sq))\n  lift_fac F' := by\n    simpa only [MonoFactorisation.ofArrowIso_m, Arrow.inv_right, ← Category.assoc,\n      IsIso.comp_inv_eq] using hF.lift_fac (F'.ofArrowIso (inv sq))\n\n"}
{"name":"CategoryTheory.Limits.ImageFactorisation.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF✝ : CategoryTheory.Limits.MonoFactorisation f\nisImage✝ : CategoryTheory.Limits.IsImage F✝\nF : CategoryTheory.Limits.MonoFactorisation f\nisImage : CategoryTheory.Limits.IsImage F\nx✝ : Eq { F := F✝, isImage := isImage✝ } { F := F, isImage := isImage }\n⊢ And (Eq F✝ F) (HEq isImage✝ isImage)","decl":"/-- Data exhibiting that a morphism `f` has an image. -/\nstructure ImageFactorisation (f : X ⟶ Y) where\n  F : MonoFactorisation f -- Porting note: another violation of the naming convention\n  isImage : IsImage F\n\n"}
{"name":"CategoryTheory.Limits.ImageFactorisation.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF✝ : CategoryTheory.Limits.MonoFactorisation f\nisImage✝ : CategoryTheory.Limits.IsImage F✝\nF : CategoryTheory.Limits.MonoFactorisation f\nisImage : CategoryTheory.Limits.IsImage F\n⊢ Eq (Eq { F := F✝, isImage := isImage✝ } { F := F, isImage := isImage }) (And (Eq F✝ F) (HEq isImage✝ isImage))","decl":"/-- Data exhibiting that a morphism `f` has an image. -/\nstructure ImageFactorisation (f : X ⟶ Y) where\n  F : MonoFactorisation f -- Porting note: another violation of the naming convention\n  isImage : IsImage F\n\n"}
{"name":"CategoryTheory.Limits.ImageFactorisation.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : SizeOf C\nF : CategoryTheory.Limits.MonoFactorisation f\nisImage : CategoryTheory.Limits.IsImage F\n⊢ Eq (SizeOf.sizeOf { F := F, isImage := isImage }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf F)) (SizeOf.sizeOf isImage))","decl":"/-- Data exhibiting that a morphism `f` has an image. -/\nstructure ImageFactorisation (f : X ⟶ Y) where\n  F : MonoFactorisation f -- Porting note: another violation of the naming convention\n  isImage : IsImage F\n\n"}
{"name":"CategoryTheory.Limits.ImageFactorisation.ofArrowIso_isImage","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\nF : CategoryTheory.Limits.ImageFactorisation f.hom\nsq : Quiver.Hom f g\ninst✝ : CategoryTheory.IsIso sq\n⊢ Eq (F.ofArrowIso sq).isImage (F.isImage.ofArrowIso sq)","decl":"/-- If `f` and `g` are isomorphic arrows, then an image factorisation of `f`\ngives an image factorisation of `g` -/\n@[simps]\ndef ofArrowIso {f g : Arrow C} (F : ImageFactorisation f.hom) (sq : f ⟶ g) [IsIso sq] :\n    ImageFactorisation g.hom where\n  F := F.F.ofArrowIso sq\n  isImage := F.isImage.ofArrowIso sq\n\n"}
{"name":"CategoryTheory.Limits.ImageFactorisation.ofArrowIso_F","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\nF : CategoryTheory.Limits.ImageFactorisation f.hom\nsq : Quiver.Hom f g\ninst✝ : CategoryTheory.IsIso sq\n⊢ Eq (F.ofArrowIso sq).F (F.F.ofArrowIso sq)","decl":"/-- If `f` and `g` are isomorphic arrows, then an image factorisation of `f`\ngives an image factorisation of `g` -/\n@[simps]\ndef ofArrowIso {f g : Arrow C} (F : ImageFactorisation f.hom) (sq : f ⟶ g) [IsIso sq] :\n    ImageFactorisation g.hom where\n  F := F.F.ofArrowIso sq\n  isImage := F.isImage.ofArrowIso sq\n\n"}
{"name":"CategoryTheory.Limits.HasImage.exists_image","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nself : CategoryTheory.Limits.HasImage f\n⊢ Nonempty (CategoryTheory.Limits.ImageFactorisation f)","decl":"/-- `HasImage f` means that there exists an image factorisation of `f`. -/\nclass HasImage (f : X ⟶ Y) : Prop where mk' ::\n  exists_image : Nonempty (ImageFactorisation f)\n\n"}
{"name":"CategoryTheory.Limits.HasImage.mk","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF : CategoryTheory.Limits.ImageFactorisation f\n⊢ CategoryTheory.Limits.HasImage f","decl":"theorem HasImage.mk {f : X ⟶ Y} (F : ImageFactorisation f) : HasImage f :=\n  ⟨Nonempty.intro F⟩\n\n"}
{"name":"CategoryTheory.Limits.HasImage.of_arrow_iso","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\nh : CategoryTheory.Limits.HasImage f.hom\nsq : Quiver.Hom f g\ninst✝ : CategoryTheory.IsIso sq\n⊢ CategoryTheory.Limits.HasImage g.hom","decl":"theorem HasImage.of_arrow_iso {f g : Arrow C} [h : HasImage f.hom] (sq : f ⟶ g) [IsIso sq] :\n    HasImage g.hom :=\n  ⟨⟨h.exists_image.some.ofArrowIso sq⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.mono_hasImage","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\n⊢ CategoryTheory.Limits.HasImage f","decl":"instance (priority := 100) mono_hasImage (f : X ⟶ Y) [Mono f] : HasImage f :=\n  HasImage.mk ⟨_, IsImage.self f⟩\n\n"}
{"name":"CategoryTheory.Limits.image.as_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasImage f\n⊢ Eq (CategoryTheory.Limits.Image.monoFactorisation f).m (CategoryTheory.Limits.image.ι f)","decl":"@[simp]\ntheorem image.as_ι : (Image.monoFactorisation f).m = image.ι f := rfl\n\n"}
{"name":"CategoryTheory.Limits.instMonoι","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasImage f\n⊢ CategoryTheory.Mono (CategoryTheory.Limits.image.ι f)","decl":"instance : Mono (image.ι f) :=\n  (Image.monoFactorisation f).m_mono\n\n"}
{"name":"CategoryTheory.Limits.as_factorThruImage","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasImage f\n⊢ Eq (CategoryTheory.Limits.Image.monoFactorisation f).e (CategoryTheory.Limits.factorThruImage f)","decl":"/-- Rewrite in terms of the `factorThruImage` interface. -/\n@[simp]\ntheorem as_factorThruImage : (Image.monoFactorisation f).e = factorThruImage f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.image.fac","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasImage f\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImage f) (CategoryTheory.Limits.image.ι f)) f","decl":"@[reassoc (attr := simp)]\ntheorem image.fac : factorThruImage f ≫ image.ι f = f :=\n  (Image.monoFactorisation f).fac\n\n"}
{"name":"CategoryTheory.Limits.image.fac_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasImage f\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImage f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.ι f) h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc (attr := simp)]\ntheorem image.fac : factorThruImage f ≫ image.ι f = f :=\n  (Image.monoFactorisation f).fac\n\n"}
{"name":"CategoryTheory.Limits.image.lift_fac","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasImage f\nF' : CategoryTheory.Limits.MonoFactorisation f\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.lift F') F'.m) (CategoryTheory.Limits.image.ι f)","decl":"@[reassoc (attr := simp)]\ntheorem image.lift_fac (F' : MonoFactorisation f) : image.lift F' ≫ F'.m = image.ι f :=\n  (Image.isImage f).lift_fac F'\n\n"}
{"name":"CategoryTheory.Limits.image.lift_fac_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasImage f\nF' : CategoryTheory.Limits.MonoFactorisation f\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.lift F') (CategoryTheory.CategoryStruct.comp F'.m h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.ι f) h)","decl":"@[reassoc (attr := simp)]\ntheorem image.lift_fac (F' : MonoFactorisation f) : image.lift F' ≫ F'.m = image.ι f :=\n  (Image.isImage f).lift_fac F'\n\n"}
{"name":"CategoryTheory.Limits.image.fac_lift","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasImage f\nF' : CategoryTheory.Limits.MonoFactorisation f\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImage f) (CategoryTheory.Limits.image.lift F')) F'.e","decl":"@[reassoc (attr := simp)]\ntheorem image.fac_lift (F' : MonoFactorisation f) : factorThruImage f ≫ image.lift F' = F'.e :=\n  (Image.isImage f).fac_lift F'\n\n"}
{"name":"CategoryTheory.Limits.image.fac_lift_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasImage f\nF' : CategoryTheory.Limits.MonoFactorisation f\nZ : C\nh : Quiver.Hom F'.I Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImage f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.lift F') h)) (CategoryTheory.CategoryStruct.comp F'.e h)","decl":"@[reassoc (attr := simp)]\ntheorem image.fac_lift (F' : MonoFactorisation f) : factorThruImage f ≫ image.lift F' = F'.e :=\n  (Image.isImage f).fac_lift F'\n\n"}
{"name":"CategoryTheory.Limits.image.isImage_lift","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasImage f\nF : CategoryTheory.Limits.MonoFactorisation f\n⊢ Eq ((CategoryTheory.Limits.Image.isImage f).lift F) (CategoryTheory.Limits.image.lift F)","decl":"@[simp]\ntheorem image.isImage_lift (F : MonoFactorisation f) : (Image.isImage f).lift F = image.lift F :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsImage.lift_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasImage f\nF : CategoryTheory.Limits.MonoFactorisation f\nhF : CategoryTheory.Limits.IsImage F\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hF.lift (CategoryTheory.Limits.Image.monoFactorisation f)) (CategoryTheory.Limits.image.ι f)) F.m","decl":"@[reassoc (attr := simp)]\ntheorem IsImage.lift_ι {F : MonoFactorisation f} (hF : IsImage F) :\n    hF.lift (Image.monoFactorisation f) ≫ image.ι f = F.m :=\n  hF.lift_fac _\n\n-- TODO we could put a category structure on `MonoFactorisation f`,\n-- with the morphisms being `g : I ⟶ I'` commuting with the `m`s\n-- (they then automatically commute with the `e`s)\n-- and show that an `imageOf f` gives an initial object there\n-- (uniqueness of the lift comes for free).\n"}
{"name":"CategoryTheory.Limits.IsImage.lift_ι_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasImage f\nF : CategoryTheory.Limits.MonoFactorisation f\nhF : CategoryTheory.Limits.IsImage F\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hF.lift (CategoryTheory.Limits.Image.monoFactorisation f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.ι f) h)) (CategoryTheory.CategoryStruct.comp F.m h)","decl":"@[reassoc (attr := simp)]\ntheorem IsImage.lift_ι {F : MonoFactorisation f} (hF : IsImage F) :\n    hF.lift (Image.monoFactorisation f) ≫ image.ι f = F.m :=\n  hF.lift_fac _\n\n-- TODO we could put a category structure on `MonoFactorisation f`,\n-- with the morphisms being `g : I ⟶ I'` commuting with the `m`s\n-- (they then automatically commute with the `e`s)\n-- and show that an `imageOf f` gives an initial object there\n-- (uniqueness of the lift comes for free).\n"}
{"name":"CategoryTheory.Limits.image.lift_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasImage f\nF' : CategoryTheory.Limits.MonoFactorisation f\n⊢ CategoryTheory.Mono (CategoryTheory.Limits.image.lift F')","decl":"instance image.lift_mono (F' : MonoFactorisation f) : Mono (image.lift F') := by\n  refine @mono_of_mono _ _ _ _ _ _ F'.m ?_\n  simpa using MonoFactorisation.m_mono _\n\n"}
{"name":"CategoryTheory.Limits.HasImage.uniq","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasImage f\nF' : CategoryTheory.Limits.MonoFactorisation f\nl : Quiver.Hom (CategoryTheory.Limits.image f) F'.I\nw : Eq (CategoryTheory.CategoryStruct.comp l F'.m) (CategoryTheory.Limits.image.ι f)\n⊢ Eq l (CategoryTheory.Limits.image.lift F')","decl":"theorem HasImage.uniq (F' : MonoFactorisation f) (l : image f ⟶ F'.I) (w : l ≫ F'.m = image.ι f) :\n    l = image.lift F' :=\n  (cancel_mono F'.m).1 (by simp [w])\n\n"}
{"name":"CategoryTheory.Limits.instHasImageCompOfIsIso","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.IsIso f\ng : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Limits.HasImage g\n⊢ CategoryTheory.Limits.HasImage (CategoryTheory.CategoryStruct.comp f g)","decl":"/-- If `has_image g`, then `has_image (f ≫ g)` when `f` is an isomorphism. -/\ninstance {X Y Z : C} (f : X ⟶ Y) [IsIso f] (g : Y ⟶ Z) [HasImage g] : HasImage (f ≫ g) where\n  exists_image :=\n    ⟨{  F :=\n          { I := image g\n            m := image.ι g\n            e := f ≫ factorThruImage g }\n        isImage :=\n          { lift := fun F' => image.lift\n                { I := F'.I\n                  m := F'.m\n                  e := inv f ≫ F'.e } } }⟩\n\n"}
{"name":"CategoryTheory.Limits.HasImages.has_image","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Limits.HasImages C\nX Y : C\nf : Quiver.Hom X Y\n⊢ CategoryTheory.Limits.HasImage f","decl":"/-- `HasImages` asserts that every morphism has an image. -/\nclass HasImages : Prop where\n  has_image : ∀ {X Y : C} (f : X ⟶ Y), HasImage f\n\n"}
{"name":"CategoryTheory.Limits.imageMonoIsoSource_inv_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageMonoIsoSource f).inv (CategoryTheory.Limits.image.ι f)) f","decl":"@[reassoc (attr := simp)]\ntheorem imageMonoIsoSource_inv_ι [Mono f] : (imageMonoIsoSource f).inv ≫ image.ι f = f := by\n  simp [imageMonoIsoSource]\n\n"}
{"name":"CategoryTheory.Limits.imageMonoIsoSource_inv_ι_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageMonoIsoSource f).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.ι f) h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc (attr := simp)]\ntheorem imageMonoIsoSource_inv_ι [Mono f] : (imageMonoIsoSource f).inv ≫ image.ι f = f := by\n  simp [imageMonoIsoSource]\n\n"}
{"name":"CategoryTheory.Limits.imageMonoIsoSource_hom_self","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageMonoIsoSource f).hom f) (CategoryTheory.Limits.image.ι f)","decl":"@[reassoc (attr := simp)]\ntheorem imageMonoIsoSource_hom_self [Mono f] : (imageMonoIsoSource f).hom ≫ f = image.ι f := by\n  simp only [← imageMonoIsoSource_inv_ι f]\n  rw [← Category.assoc, Iso.hom_inv_id, Category.id_comp]\n\n-- This is the proof that `factorThruImage f` is an epimorphism\n-- from https://en.wikipedia.org/wiki/Image_%28category_theory%29, which is in turn taken from:\n-- Mitchell, Barry (1965), Theory of categories, MR 0202787, p.12, Proposition 10.1\n"}
{"name":"CategoryTheory.Limits.imageMonoIsoSource_hom_self_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageMonoIsoSource f).hom (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.ι f) h)","decl":"@[reassoc (attr := simp)]\ntheorem imageMonoIsoSource_hom_self [Mono f] : (imageMonoIsoSource f).hom ≫ f = image.ι f := by\n  simp only [← imageMonoIsoSource_inv_ι f]\n  rw [← Category.assoc, Iso.hom_inv_id, Category.id_comp]\n\n-- This is the proof that `factorThruImage f` is an epimorphism\n-- from https://en.wikipedia.org/wiki/Image_%28category_theory%29, which is in turn taken from:\n-- Mitchell, Barry (1965), Theory of categories, MR 0202787, p.12, Proposition 10.1\n"}
{"name":"CategoryTheory.Limits.image.ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasImage f\nW : C\ng h : Quiver.Hom (CategoryTheory.Limits.image f) W\ninst✝ : CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.parallelPair g h)\nw : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImage f) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImage f) h)\n⊢ Eq g h","decl":"@[ext (iff := false)]\ntheorem image.ext [HasImage f] {W : C} {g h : image f ⟶ W} [HasLimit (parallelPair g h)]\n    (w : factorThruImage f ≫ g = factorThruImage f ≫ h) : g = h := by\n  let q := equalizer.ι g h\n  let e' := equalizer.lift _ w\n  let F' : MonoFactorisation f :=\n    { I := equalizer g h\n      m := q ≫ image.ι f\n      m_mono := mono_comp _ _\n      e := e' }\n  let v := image.lift F'\n  have t₀ : v ≫ q ≫ image.ι f = image.ι f := image.lift_fac F'\n  have t : v ≫ q = 𝟙 (image f) :=\n    (cancel_mono_id (image.ι f)).1\n      (by\n        convert t₀ using 1\n        rw [Category.assoc])\n  -- The proof from wikipedia next proves `q ≫ v = 𝟙 _`,\n  -- and concludes that `equalizer g h ≅ image f`,\n  -- but this isn't necessary.\n  calc\n    g = 𝟙 (image f) ≫ g := by rw [Category.id_comp]\n    _ = v ≫ q ≫ g := by rw [← t, Category.assoc]\n    _ = v ≫ q ≫ h := by rw [equalizer.condition g h]\n    _ = 𝟙 (image f) ≫ h := by rw [← Category.assoc, t]\n    _ = h := by rw [Category.id_comp]\n\n"}
{"name":"CategoryTheory.Limits.instEpiFactorThruImageOfHasLimitWalkingParallelPairParallelPair","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasImage f\ninst✝ : ∀ {Z : C} (g h : Quiver.Hom (CategoryTheory.Limits.image f) Z), CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.parallelPair g h)\n⊢ CategoryTheory.Epi (CategoryTheory.Limits.factorThruImage f)","decl":"instance [HasImage f] [∀ {Z : C} (g h : image f ⟶ Z), HasLimit (parallelPair g h)] :\n    Epi (factorThruImage f) :=\n  ⟨fun _ _ w => image.ext f w⟩\n\n"}
{"name":"CategoryTheory.Limits.epi_image_of_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasImage f\nE : CategoryTheory.Epi f\n⊢ CategoryTheory.Epi (CategoryTheory.Limits.image.ι f)","decl":"theorem epi_image_of_epi {X Y : C} (f : X ⟶ Y) [HasImage f] [E : Epi f] : Epi (image.ι f) := by\n  rw [← image.fac f] at E\n  exact epi_of_epi (factorThruImage f) (image.ι f)\n\n"}
{"name":"CategoryTheory.Limits.epi_of_epi_image","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝² : CategoryTheory.Limits.HasImage f\ninst✝¹ : CategoryTheory.Epi (CategoryTheory.Limits.image.ι f)\ninst✝ : CategoryTheory.Epi (CategoryTheory.Limits.factorThruImage f)\n⊢ CategoryTheory.Epi f","decl":"theorem epi_of_epi_image {X Y : C} (f : X ⟶ Y) [HasImage f] [Epi (image.ι f)]\n    [Epi (factorThruImage f)] : Epi f := by\n  rw [← image.fac f]\n  apply epi_comp\n\n"}
{"name":"CategoryTheory.Limits.instIsIsoEqToHom","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\nf f' : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasImage f\ninst✝ : CategoryTheory.Limits.HasImage f'\nh : Eq f f'\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.image.eqToHom h)","decl":"instance (h : f = f') : IsIso (image.eqToHom h) :=\n  ⟨⟨image.eqToHom h.symm,\n      ⟨(cancel_mono (image.ι f)).1 (by\n          -- Porting note: added let's for used to be a simp [image.eqToHom]\n          let F : MonoFactorisation f' :=\n            ⟨image f, image.ι f, factorThruImage f, (by aesop_cat)⟩\n          dsimp [image.eqToHom]\n          rw [Category.id_comp,Category.assoc,image.lift_fac F]\n          let F' : MonoFactorisation f :=\n            ⟨image f', image.ι f', factorThruImage f', (by aesop_cat)⟩\n          rw [image.lift_fac F'] ),\n        (cancel_mono (image.ι f')).1 (by\n          -- Porting note: added let's for used to be a simp [image.eqToHom]\n          let F' : MonoFactorisation f :=\n            ⟨image f', image.ι f', factorThruImage f', (by aesop_cat)⟩\n          dsimp [image.eqToHom]\n          rw [Category.id_comp,Category.assoc,image.lift_fac F']\n          let F : MonoFactorisation f' :=\n            ⟨image f, image.ι f, factorThruImage f, (by aesop_cat)⟩\n          rw [image.lift_fac F])⟩⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.image.eq_fac","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y : C\nf f' : Quiver.Hom X Y\ninst✝² : CategoryTheory.Limits.HasImage f\ninst✝¹ : CategoryTheory.Limits.HasImage f'\ninst✝ : CategoryTheory.Limits.HasEqualizers C\nh : Eq f f'\n⊢ Eq (CategoryTheory.Limits.image.ι f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.eqToIso h).hom (CategoryTheory.Limits.image.ι f'))","decl":"/-- As long as the category has equalizers,\nthe image inclusion maps commute with `image.eqToIso`.\n-/\ntheorem image.eq_fac [HasEqualizers C] (h : f = f') :\n    image.ι f = (image.eqToIso h).hom ≫ image.ι f' := by\n  apply image.ext\n  dsimp [asIso,image.eqToIso, image.eqToHom]\n  rw [image.lift_fac] -- Porting note: simp did not fire with this it seems\n\n"}
{"name":"CategoryTheory.Limits.image.preComp_ι_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nZ✝ : C\ng : Quiver.Hom Y Z✝\ninst✝¹ : CategoryTheory.Limits.HasImage g\ninst✝ : CategoryTheory.Limits.HasImage (CategoryTheory.CategoryStruct.comp f g)\nZ : C\nh : Quiver.Hom Z✝ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.preComp f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.ι g) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.ι (CategoryTheory.CategoryStruct.comp f g)) h)","decl":"@[reassoc (attr := simp)]\ntheorem image.preComp_ι [HasImage g] [HasImage (f ≫ g)] :\n    image.preComp f g ≫ image.ι g = image.ι (f ≫ g) := by\n      dsimp [image.preComp]\n      rw [image.lift_fac] -- Porting note: also here, see image.eq_fac\n\n"}
{"name":"CategoryTheory.Limits.image.preComp_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\ng : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.Limits.HasImage g\ninst✝ : CategoryTheory.Limits.HasImage (CategoryTheory.CategoryStruct.comp f g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.preComp f g) (CategoryTheory.Limits.image.ι g)) (CategoryTheory.Limits.image.ι (CategoryTheory.CategoryStruct.comp f g))","decl":"@[reassoc (attr := simp)]\ntheorem image.preComp_ι [HasImage g] [HasImage (f ≫ g)] :\n    image.preComp f g ≫ image.ι g = image.ι (f ≫ g) := by\n      dsimp [image.preComp]\n      rw [image.lift_fac] -- Porting note: also here, see image.eq_fac\n\n"}
{"name":"CategoryTheory.Limits.image.factorThruImage_preComp","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\ng : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.Limits.HasImage g\ninst✝ : CategoryTheory.Limits.HasImage (CategoryTheory.CategoryStruct.comp f g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImage (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.Limits.image.preComp f g)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.factorThruImage g))","decl":"@[reassoc (attr := simp)]\ntheorem image.factorThruImage_preComp [HasImage g] [HasImage (f ≫ g)] :\n    factorThruImage (f ≫ g) ≫ image.preComp f g = f ≫ factorThruImage g := by simp [image.preComp]\n\n"}
{"name":"CategoryTheory.Limits.image.factorThruImage_preComp_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nZ✝ : C\ng : Quiver.Hom Y Z✝\ninst✝¹ : CategoryTheory.Limits.HasImage g\ninst✝ : CategoryTheory.Limits.HasImage (CategoryTheory.CategoryStruct.comp f g)\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.image g) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImage (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.preComp f g) h)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImage g) h))","decl":"@[reassoc (attr := simp)]\ntheorem image.factorThruImage_preComp [HasImage g] [HasImage (f ≫ g)] :\n    factorThruImage (f ≫ g) ≫ image.preComp f g = f ≫ factorThruImage g := by simp [image.preComp]\n\n"}
{"name":"CategoryTheory.Limits.image.preComp_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\ng : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.Limits.HasImage g\ninst✝ : CategoryTheory.Limits.HasImage (CategoryTheory.CategoryStruct.comp f g)\n⊢ CategoryTheory.Mono (CategoryTheory.Limits.image.preComp f g)","decl":"/-- `image.preComp f g` is a monomorphism.\n-/\ninstance image.preComp_mono [HasImage g] [HasImage (f ≫ g)] : Mono (image.preComp f g) := by\n  refine @mono_of_mono _ _ _ _ _ _ (image.ι g) ?_\n  simp only [image.preComp_ι]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.image.preComp_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\ng : Quiver.Hom Y Z\nW : C\nh : Quiver.Hom Z W\ninst✝³ : CategoryTheory.Limits.HasImage (CategoryTheory.CategoryStruct.comp g h)\ninst✝² : CategoryTheory.Limits.HasImage (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp g h))\ninst✝¹ : CategoryTheory.Limits.HasImage h\ninst✝ : CategoryTheory.Limits.HasImage (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g) h)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.preComp f (CategoryTheory.CategoryStruct.comp g h)) (CategoryTheory.Limits.image.preComp g h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.eqToHom ⋯) (CategoryTheory.Limits.image.preComp (CategoryTheory.CategoryStruct.comp f g) h))","decl":"/-- The two step comparison map\n  `image (f ≫ (g ≫ h)) ⟶ image (g ≫ h) ⟶ image h`\nagrees with the one step comparison map\n  `image (f ≫ (g ≫ h)) ≅ image ((f ≫ g) ≫ h) ⟶ image h`.\n -/\ntheorem image.preComp_comp {W : C} (h : Z ⟶ W) [HasImage (g ≫ h)] [HasImage (f ≫ g ≫ h)]\n    [HasImage h] [HasImage ((f ≫ g) ≫ h)] :\n    image.preComp f (g ≫ h) ≫ image.preComp g h =\n      image.eqToHom (Category.assoc f g h).symm ≫ image.preComp (f ≫ g) h := by\n  apply (cancel_mono (image.ι h)).1\n  dsimp [image.preComp, image.eqToHom]\n  repeat (rw [Category.assoc,image.lift_fac])\n  rw [image.lift_fac,image.lift_fac]\n\n"}
{"name":"CategoryTheory.Limits.image.preComp_epi_of_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\ng : Quiver.Hom Y Z\ninst✝² : CategoryTheory.Limits.HasImage g\ninst✝¹ : CategoryTheory.Limits.HasImage (CategoryTheory.CategoryStruct.comp f g)\ninst✝ : CategoryTheory.Epi f\n⊢ CategoryTheory.Epi (CategoryTheory.Limits.image.preComp f g)","decl":"/-- `image.preComp f g` is an epimorphism when `f` is an epimorphism\n(we need `C` to have equalizers to prove this).\n-/\ninstance image.preComp_epi_of_epi [HasImage g] [HasImage (f ≫ g)] [Epi f] :\n    Epi (image.preComp f g) := by\n  apply @epi_of_epi_fac _ _ _ _ _ _ _ _ ?_ (image.factorThruImage_preComp _ _)\n  exact epi_comp _ _\n\n"}
{"name":"CategoryTheory.Limits.hasImage_iso_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\ng : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.IsIso f\ninst✝ : CategoryTheory.Limits.HasImage g\n⊢ CategoryTheory.Limits.HasImage (CategoryTheory.CategoryStruct.comp f g)","decl":"instance hasImage_iso_comp [IsIso f] [HasImage g] : HasImage (f ≫ g) :=\n  HasImage.mk\n    { F := (Image.monoFactorisation g).isoComp f\n      isImage := { lift := fun F' => image.lift (F'.ofIsoComp f)\n                   lift_fac := fun F' => by\n                    dsimp\n                    have : (MonoFactorisation.ofIsoComp f F').m = F'.m := rfl\n                    rw [← this,image.lift_fac (MonoFactorisation.ofIsoComp f F')] } }\n\n"}
{"name":"CategoryTheory.Limits.image.isIso_precomp_iso","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y Z : C\ng : Quiver.Hom Y Z\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.IsIso f\ninst✝ : CategoryTheory.Limits.HasImage g\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.image.preComp f g)","decl":"/-- `image.preComp f g` is an isomorphism when `f` is an isomorphism\n(we need `C` to have equalizers to prove this).\n-/\ninstance image.isIso_precomp_iso (f : X ⟶ Y) [IsIso f] [HasImage g] : IsIso (image.preComp f g) :=\n  ⟨⟨image.lift\n        { I := image (f ≫ g)\n          m := image.ι (f ≫ g)\n          e := inv f ≫ factorThruImage (f ≫ g) },\n      ⟨by\n        ext\n        simp [image.preComp], by\n        ext\n        simp [image.preComp]⟩⟩⟩\n\n-- Note that in general we don't have the other comparison map you might expect\n-- `image f ⟶ image (f ≫ g)`.\n"}
{"name":"CategoryTheory.Limits.hasImage_comp_iso","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\ng : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.Limits.HasImage f\ninst✝ : CategoryTheory.IsIso g\n⊢ CategoryTheory.Limits.HasImage (CategoryTheory.CategoryStruct.comp f g)","decl":"instance hasImage_comp_iso [HasImage f] [IsIso g] : HasImage (f ≫ g) :=\n  HasImage.mk\n    { F := (Image.monoFactorisation f).compMono g\n      isImage :=\n      { lift := fun F' => image.lift F'.ofCompIso\n        lift_fac := fun F' => by\n          rw [← Category.comp_id (image.lift (MonoFactorisation.ofCompIso F') ≫ F'.m),\n            ← IsIso.inv_hom_id g,← Category.assoc]\n          refine congrArg (· ≫ g) ?_\n          have : (image.lift (MonoFactorisation.ofCompIso F') ≫ F'.m) ≫ inv g =\n            image.lift (MonoFactorisation.ofCompIso F') ≫\n            ((MonoFactorisation.ofCompIso F').m) := by\n              simp only [MonoFactorisation.ofCompIso_I, Category.assoc,\n                MonoFactorisation.ofCompIso_m]\n          rw [this, image.lift_fac (MonoFactorisation.ofCompIso F'),image.as_ι] }}\n\n"}
{"name":"CategoryTheory.Limits.image.compIso_hom_comp_image_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\ng : Quiver.Hom Y Z\ninst✝² : CategoryTheory.Limits.HasEqualizers C\ninst✝¹ : CategoryTheory.Limits.HasImage f\ninst✝ : CategoryTheory.IsIso g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.compIso f g).hom (CategoryTheory.Limits.image.ι (CategoryTheory.CategoryStruct.comp f g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.ι f) g)","decl":"@[reassoc (attr := simp)]\ntheorem image.compIso_hom_comp_image_ι [HasImage f] [IsIso g] :\n    (image.compIso f g).hom ≫ image.ι (f ≫ g) = image.ι f ≫ g := by\n  ext\n  simp [image.compIso]\n\n"}
{"name":"CategoryTheory.Limits.image.compIso_hom_comp_image_ι_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nZ✝ : C\ng : Quiver.Hom Y Z✝\ninst✝² : CategoryTheory.Limits.HasEqualizers C\ninst✝¹ : CategoryTheory.Limits.HasImage f\ninst✝ : CategoryTheory.IsIso g\nZ : C\nh : Quiver.Hom Z✝ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.compIso f g).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.ι (CategoryTheory.CategoryStruct.comp f g)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.ι f) (CategoryTheory.CategoryStruct.comp g h))","decl":"@[reassoc (attr := simp)]\ntheorem image.compIso_hom_comp_image_ι [HasImage f] [IsIso g] :\n    (image.compIso f g).hom ≫ image.ι (f ≫ g) = image.ι f ≫ g := by\n  ext\n  simp [image.compIso]\n\n"}
{"name":"CategoryTheory.Limits.image.compIso_inv_comp_image_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\ng : Quiver.Hom Y Z\ninst✝² : CategoryTheory.Limits.HasEqualizers C\ninst✝¹ : CategoryTheory.Limits.HasImage f\ninst✝ : CategoryTheory.IsIso g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.compIso f g).inv (CategoryTheory.Limits.image.ι f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.ι (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.inv g))","decl":"@[reassoc (attr := simp)]\ntheorem image.compIso_inv_comp_image_ι [HasImage f] [IsIso g] :\n    (image.compIso f g).inv ≫ image.ι f = image.ι (f ≫ g) ≫ inv g := by\n  ext\n  simp [image.compIso]\n\n"}
{"name":"CategoryTheory.Limits.image.compIso_inv_comp_image_ι_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nZ✝ : C\ng : Quiver.Hom Y Z✝\ninst✝² : CategoryTheory.Limits.HasEqualizers C\ninst✝¹ : CategoryTheory.Limits.HasImage f\ninst✝ : CategoryTheory.IsIso g\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.compIso f g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.ι f) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.ι (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv g) h))","decl":"@[reassoc (attr := simp)]\ntheorem image.compIso_inv_comp_image_ι [HasImage f] [IsIso g] :\n    (image.compIso f g).inv ≫ image.ι f = image.ι (f ≫ g) ≫ inv g := by\n  ext\n  simp [image.compIso]\n\n"}
{"name":"CategoryTheory.Limits.instHasImageHomMk","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasImage f\n⊢ CategoryTheory.Limits.HasImage (CategoryTheory.Arrow.mk f).hom","decl":"instance {X Y : C} (f : X ⟶ Y) [HasImage f] : HasImage (Arrow.mk f).hom :=\n  show HasImage f by infer_instance\n\n"}
{"name":"CategoryTheory.Limits.ImageMap.map_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst✝¹ : CategoryTheory.Limits.HasImage f.hom\ninst✝ : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\nself : CategoryTheory.Limits.ImageMap sq\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.map (CategoryTheory.Limits.image.ι g.hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.ι f.hom) sq.right)","decl":"set_option genInjectivity false in\n/-- An image map is a morphism `image f → image g` fitting into a commutative square and satisfying\n    the obvious commutativity conditions. -/\nstructure ImageMap {f g : Arrow C} [HasImage f.hom] [HasImage g.hom] (sq : f ⟶ g) where\n  map : image f.hom ⟶ image g.hom\n  map_ι : map ≫ image.ι g.hom = image.ι f.hom ≫ sq.right := by aesop\n\n"}
{"name":"CategoryTheory.Limits.ImageMap.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst✝² : CategoryTheory.Limits.HasImage f.hom\ninst✝¹ : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\ninst✝ : SizeOf C\nmap : Quiver.Hom (CategoryTheory.Limits.image f.hom) (CategoryTheory.Limits.image g.hom)\nmap_ι : autoParam (Eq (CategoryTheory.CategoryStruct.comp map (CategoryTheory.Limits.image.ι g.hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.ι f.hom) sq.right)) _auto✝\n⊢ Eq (SizeOf.sizeOf { map := map, map_ι := map_ι }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf map)) (SizeOf.sizeOf map_ι))","decl":"set_option genInjectivity false in\n/-- An image map is a morphism `image f → image g` fitting into a commutative square and satisfying\n    the obvious commutativity conditions. -/\nstructure ImageMap {f g : Arrow C} [HasImage f.hom] [HasImage g.hom] (sq : f ⟶ g) where\n  map : image f.hom ⟶ image g.hom\n  map_ι : map ≫ image.ι g.hom = image.ι f.hom ≫ sq.right := by aesop\n\n"}
{"name":"CategoryTheory.Limits.ImageMap.map_ι_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst✝¹ : CategoryTheory.Limits.HasImage f.hom\ninst✝ : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\nself : CategoryTheory.Limits.ImageMap sq\nZ : C\nh : Quiver.Hom g.right Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.map (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.ι g.hom) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.ι f.hom) (CategoryTheory.CategoryStruct.comp sq.right h))","decl":"attribute [reassoc (attr := simp)] ImageMap.map_ι\n\n"}
{"name":"CategoryTheory.Limits.ImageMap.factor_map_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst✝¹ : CategoryTheory.Limits.HasImage f.hom\ninst✝ : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\nm : CategoryTheory.Limits.ImageMap sq\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.image g.hom) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImage f.hom) (CategoryTheory.CategoryStruct.comp m.map h)) (CategoryTheory.CategoryStruct.comp sq.left (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImage g.hom) h))","decl":"@[reassoc (attr := simp)]\ntheorem ImageMap.factor_map {f g : Arrow C} [HasImage f.hom] [HasImage g.hom] (sq : f ⟶ g)\n    (m : ImageMap sq) : factorThruImage f.hom ≫ m.map = sq.left ≫ factorThruImage g.hom :=\n  (cancel_mono (image.ι g.hom)).1 <| by simp\n\n"}
{"name":"CategoryTheory.Limits.ImageMap.factor_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst✝¹ : CategoryTheory.Limits.HasImage f.hom\ninst✝ : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\nm : CategoryTheory.Limits.ImageMap sq\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImage f.hom) m.map) (CategoryTheory.CategoryStruct.comp sq.left (CategoryTheory.Limits.factorThruImage g.hom))","decl":"@[reassoc (attr := simp)]\ntheorem ImageMap.factor_map {f g : Arrow C} [HasImage f.hom] [HasImage g.hom] (sq : f ⟶ g)\n    (m : ImageMap sq) : factorThruImage f.hom ≫ m.map = sq.left ≫ factorThruImage g.hom :=\n  (cancel_mono (image.ι g.hom)).1 <| by simp\n\n"}
{"name":"CategoryTheory.Limits.HasImageMap.has_image_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst✝¹ : CategoryTheory.Limits.HasImage f.hom\ninst✝ : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\nself : CategoryTheory.Limits.HasImageMap sq\n⊢ Nonempty (CategoryTheory.Limits.ImageMap sq)","decl":"/-- `HasImageMap sq` means that there is an `ImageMap` for the square `sq`. -/\nclass HasImageMap {f g : Arrow C} [HasImage f.hom] [HasImage g.hom] (sq : f ⟶ g) : Prop where\nmk' ::\n  has_image_map : Nonempty (ImageMap sq)\n\n"}
{"name":"CategoryTheory.Limits.HasImageMap.mk","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst✝¹ : CategoryTheory.Limits.HasImage f.hom\ninst✝ : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\nm : CategoryTheory.Limits.ImageMap sq\n⊢ CategoryTheory.Limits.HasImageMap sq","decl":"theorem HasImageMap.mk {f g : Arrow C} [HasImage f.hom] [HasImage g.hom] {sq : f ⟶ g}\n    (m : ImageMap sq) : HasImageMap sq :=\n  ⟨Nonempty.intro m⟩\n\n"}
{"name":"CategoryTheory.Limits.HasImageMap.transport","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst✝¹ : CategoryTheory.Limits.HasImage f.hom\ninst✝ : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\nF : CategoryTheory.Limits.MonoFactorisation f.hom\nF' : CategoryTheory.Limits.MonoFactorisation g.hom\nhF' : CategoryTheory.Limits.IsImage F'\nmap : Quiver.Hom F.I F'.I\nmap_ι : Eq (CategoryTheory.CategoryStruct.comp map F'.m) (CategoryTheory.CategoryStruct.comp F.m sq.right)\n⊢ CategoryTheory.Limits.HasImageMap sq","decl":"theorem HasImageMap.transport {f g : Arrow C} [HasImage f.hom] [HasImage g.hom] (sq : f ⟶ g)\n    (F : MonoFactorisation f.hom) {F' : MonoFactorisation g.hom} (hF' : IsImage F')\n    (map : F.I ⟶ F'.I) (map_ι : map ≫ F'.m = F.m ≫ sq.right) : HasImageMap sq :=\n  HasImageMap.mk <| ImageMap.transport sq F hF' map_ι\n\n"}
{"name":"CategoryTheory.Limits.hasImageMapOfIsIso","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst✝² : CategoryTheory.Limits.HasImage f.hom\ninst✝¹ : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\ninst✝ : CategoryTheory.IsIso sq\n⊢ CategoryTheory.Limits.HasImageMap sq","decl":"instance (priority := 100) hasImageMapOfIsIso {f g : Arrow C} [HasImage f.hom] [HasImage g.hom]\n    (sq : f ⟶ g) [IsIso sq] : HasImageMap sq :=\n  HasImageMap.mk\n    { map := image.lift ((Image.monoFactorisation g.hom).ofArrowIso (inv sq))\n      map_ι := by\n        erw [← cancel_mono (inv sq).right, Category.assoc, ← MonoFactorisation.ofArrowIso_m,\n          image.lift_fac, Category.assoc, ← Comma.comp_right, IsIso.hom_inv_id, Comma.id_right,\n          Category.comp_id] }\n\n"}
{"name":"CategoryTheory.Limits.HasImageMap.comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nf g h : CategoryTheory.Arrow C\ninst✝⁴ : CategoryTheory.Limits.HasImage f.hom\ninst✝³ : CategoryTheory.Limits.HasImage g.hom\ninst✝² : CategoryTheory.Limits.HasImage h.hom\nsq1 : Quiver.Hom f g\nsq2 : Quiver.Hom g h\ninst✝¹ : CategoryTheory.Limits.HasImageMap sq1\ninst✝ : CategoryTheory.Limits.HasImageMap sq2\n⊢ CategoryTheory.Limits.HasImageMap (CategoryTheory.CategoryStruct.comp sq1 sq2)","decl":"instance HasImageMap.comp {f g h : Arrow C} [HasImage f.hom] [HasImage g.hom] [HasImage h.hom]\n    (sq1 : f ⟶ g) (sq2 : g ⟶ h) [HasImageMap sq1] [HasImageMap sq2] : HasImageMap (sq1 ≫ sq2) :=\n  HasImageMap.mk\n    { map := (HasImageMap.imageMap sq1).map ≫ (HasImageMap.imageMap sq2).map\n      map_ι := by\n        rw [Category.assoc,ImageMap.map_ι, ImageMap.map_ι_assoc, Comma.comp_right] }\n\n"}
{"name":"CategoryTheory.Limits.ImageMap.ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst✝¹ : CategoryTheory.Limits.HasImage f.hom\ninst✝ : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\nx y : CategoryTheory.Limits.ImageMap sq\nmap : Eq x.map y.map\n⊢ Eq x y","decl":"attribute [local ext] ImageMap\n\n/- Porting note: ImageMap.mk.injEq has LHS simplify to True due to the next instance\nWe make a replacement -/\n"}
{"name":"CategoryTheory.Limits.ImageMap.ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst✝¹ : CategoryTheory.Limits.HasImage f.hom\ninst✝ : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\nx y : CategoryTheory.Limits.ImageMap sq\n⊢ Iff (Eq x y) (Eq x.map y.map)","decl":"attribute [local ext] ImageMap\n\n/- Porting note: ImageMap.mk.injEq has LHS simplify to True due to the next instance\nWe make a replacement -/\n"}
{"name":"CategoryTheory.Limits.ImageMap.map_uniq_aux","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst✝¹ : CategoryTheory.Limits.HasImage f.hom\ninst✝ : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\nmap : Quiver.Hom (CategoryTheory.Limits.image f.hom) (CategoryTheory.Limits.image g.hom)\nmap_ι : autoParam (Eq (CategoryTheory.CategoryStruct.comp map (CategoryTheory.Limits.image.ι g.hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.ι f.hom) sq.right)) _auto✝\nmap' : Quiver.Hom (CategoryTheory.Limits.image f.hom) (CategoryTheory.Limits.image g.hom)\nmap_ι' : Eq (CategoryTheory.CategoryStruct.comp map' (CategoryTheory.Limits.image.ι g.hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.ι f.hom) sq.right)\n⊢ Eq map map'","decl":"theorem ImageMap.map_uniq_aux {f g : Arrow C} [HasImage f.hom] [HasImage g.hom] {sq : f ⟶ g}\n    (map : image f.hom ⟶ image g.hom)\n    (map_ι : map ≫ image.ι g.hom = image.ι f.hom ≫ sq.right := by aesop_cat)\n    (map' : image f.hom ⟶ image g.hom)\n    (map_ι' : map' ≫ image.ι g.hom = image.ι f.hom ≫ sq.right) : (map = map') := by\n  have : map ≫ image.ι g.hom = map' ≫ image.ι g.hom := by rw [map_ι,map_ι']\n  apply (cancel_mono (image.ι g.hom)).1 this\n\n-- Porting note: added to get variant on ImageMap.mk.injEq below\n"}
{"name":"CategoryTheory.Limits.ImageMap.map_uniq","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst✝¹ : CategoryTheory.Limits.HasImage f.hom\ninst✝ : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\nF G : CategoryTheory.Limits.ImageMap sq\n⊢ Eq F.map G.map","decl":"theorem ImageMap.map_uniq {f g : Arrow C} [HasImage f.hom] [HasImage g.hom]\n    {sq : f ⟶ g} (F G : ImageMap sq) : F.map = G.map := by\n  apply ImageMap.map_uniq_aux _ F.map_ι _ G.map_ι\n\n"}
{"name":"CategoryTheory.Limits.ImageMap.mk.injEq'","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst✝¹ : CategoryTheory.Limits.HasImage f.hom\ninst✝ : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\nmap : Quiver.Hom (CategoryTheory.Limits.image f.hom) (CategoryTheory.Limits.image g.hom)\nmap_ι : autoParam (Eq (CategoryTheory.CategoryStruct.comp map (CategoryTheory.Limits.image.ι g.hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.ι f.hom) sq.right)) _auto✝\nmap' : Quiver.Hom (CategoryTheory.Limits.image f.hom) (CategoryTheory.Limits.image g.hom)\nmap_ι' : Eq (CategoryTheory.CategoryStruct.comp map' (CategoryTheory.Limits.image.ι g.hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.ι f.hom) sq.right)\n⊢ Eq (Eq map map') True","decl":"@[simp]\ntheorem ImageMap.mk.injEq' {f g : Arrow C} [HasImage f.hom] [HasImage g.hom] {sq : f ⟶ g}\n    (map : image f.hom ⟶ image g.hom)\n    (map_ι : map ≫ image.ι g.hom = image.ι f.hom ≫ sq.right := by aesop_cat)\n    (map' : image f.hom ⟶ image g.hom)\n    (map_ι' : map' ≫ image.ι g.hom = image.ι f.hom ≫ sq.right) : (map = map') = True := by\n  simp only [Functor.id_obj, eq_iff_iff, iff_true]\n  apply ImageMap.map_uniq_aux _ map_ι _ map_ι'\n\n"}
{"name":"CategoryTheory.Limits.instSubsingletonImageMap","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst✝¹ : CategoryTheory.Limits.HasImage f.hom\ninst✝ : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\n⊢ Subsingleton (CategoryTheory.Limits.ImageMap sq)","decl":"instance : Subsingleton (ImageMap sq) :=\n  Subsingleton.intro fun a b =>\n    ImageMap.ext <| ImageMap.map_uniq a b\n\n"}
{"name":"CategoryTheory.Limits.image.factor_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst✝² : CategoryTheory.Limits.HasImage f.hom\ninst✝¹ : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\ninst✝ : CategoryTheory.Limits.HasImageMap sq\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImage f.hom) (CategoryTheory.Limits.image.map sq)) (CategoryTheory.CategoryStruct.comp sq.left (CategoryTheory.Limits.factorThruImage g.hom))","decl":"theorem image.factor_map :\n    factorThruImage f.hom ≫ image.map sq = sq.left ≫ factorThruImage g.hom := by simp\n\n"}
{"name":"CategoryTheory.Limits.image.map_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst✝² : CategoryTheory.Limits.HasImage f.hom\ninst✝¹ : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\ninst✝ : CategoryTheory.Limits.HasImageMap sq\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.map sq) (CategoryTheory.Limits.image.ι g.hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.ι f.hom) sq.right)","decl":"theorem image.map_ι : image.map sq ≫ image.ι g.hom = image.ι f.hom ≫ sq.right := by simp\n\n"}
{"name":"CategoryTheory.Limits.image.map_homMk'_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y P Q : C\nk : Quiver.Hom X Y\ninst✝² : CategoryTheory.Limits.HasImage k\nl : Quiver.Hom P Q\ninst✝¹ : CategoryTheory.Limits.HasImage l\nm : Quiver.Hom X P\nn : Quiver.Hom Y Q\nw : Eq (CategoryTheory.CategoryStruct.comp m l) (CategoryTheory.CategoryStruct.comp k n)\ninst✝ : CategoryTheory.Limits.HasImageMap (CategoryTheory.Arrow.homMk' m n w)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.map (CategoryTheory.Arrow.homMk' m n w)) (CategoryTheory.Limits.image.ι l)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.ι k) n)","decl":"theorem image.map_homMk'_ι {X Y P Q : C} {k : X ⟶ Y} [HasImage k] {l : P ⟶ Q} [HasImage l]\n    {m : X ⟶ P} {n : Y ⟶ Q} (w : m ≫ l = k ≫ n) [HasImageMap (Arrow.homMk' _ _ w)] :\n    image.map (Arrow.homMk' _ _ w) ≫ image.ι l = image.ι k ≫ n :=\n  image.map_ι _\n\n"}
{"name":"CategoryTheory.Limits.image.map_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst✝⁵ : CategoryTheory.Limits.HasImage f.hom\ninst✝⁴ : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\ninst✝³ : CategoryTheory.Limits.HasImageMap sq\nh : CategoryTheory.Arrow C\ninst✝² : CategoryTheory.Limits.HasImage h.hom\nsq' : Quiver.Hom g h\ninst✝¹ : CategoryTheory.Limits.HasImageMap sq'\ninst✝ : CategoryTheory.Limits.HasImageMap (CategoryTheory.CategoryStruct.comp sq sq')\n⊢ Eq (CategoryTheory.Limits.image.map (CategoryTheory.CategoryStruct.comp sq sq')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.map sq) (CategoryTheory.Limits.image.map sq'))","decl":"@[simp]\ntheorem image.map_comp [HasImageMap (sq ≫ sq')] :\n    image.map (sq ≫ sq') = image.map sq ≫ image.map sq' :=\n  show (HasImageMap.imageMap (sq ≫ sq')).map = (imageMapComp sq sq').map by\n    congr; simp only [eq_iff_true_of_subsingleton]\n\n"}
{"name":"CategoryTheory.Limits.image.map_id","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow C\ninst✝¹ : CategoryTheory.Limits.HasImage f.hom\ninst✝ : CategoryTheory.Limits.HasImageMap (CategoryTheory.CategoryStruct.id f)\n⊢ Eq (CategoryTheory.Limits.image.map (CategoryTheory.CategoryStruct.id f)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.image f.hom))","decl":"@[simp]\ntheorem image.map_id [HasImageMap (𝟙 f)] : image.map (𝟙 f) = 𝟙 (image f.hom) :=\n  show (HasImageMap.imageMap (𝟙 f)).map = (imageMapId f).map by\n    congr; simp only [eq_iff_true_of_subsingleton]\n\n"}
{"name":"CategoryTheory.Limits.HasImageMaps.has_image_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasImages C\nself : CategoryTheory.Limits.HasImageMaps C\nf g : CategoryTheory.Arrow C\nst : Quiver.Hom f g\n⊢ CategoryTheory.Limits.HasImageMap st","decl":"/-- If a category `has_image_maps`, then all commutative squares induce morphisms on images. -/\nclass HasImageMaps : Prop where\n  has_image_map : ∀ {f g : Arrow C} (st : f ⟶ g), HasImageMap st\n\n"}
{"name":"CategoryTheory.Limits.im_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasImages C\ninst✝ : CategoryTheory.Limits.HasImageMaps C\nX✝ Y✝ : CategoryTheory.Arrow C\nst : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Limits.im.map st) (CategoryTheory.Limits.image.map st)","decl":"/-- The functor from the arrow category of `C` to `C` itself that maps a morphism to its image\n    and a commutative square to the induced morphism on images. -/\n@[simps]\ndef im : Arrow C ⥤ C where\n  obj f := image f.hom\n  map st := image.map st\n\n"}
{"name":"CategoryTheory.Limits.im_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasImages C\ninst✝ : CategoryTheory.Limits.HasImageMaps C\nf : CategoryTheory.Arrow C\n⊢ Eq (CategoryTheory.Limits.im.obj f) (CategoryTheory.Limits.image f.hom)","decl":"/-- The functor from the arrow category of `C` to `C` itself that maps a morphism to its image\n    and a commutative square to the induced morphism on images. -/\n@[simps]\ndef im : Arrow C ⥤ C where\n  obj f := image f.hom\n  map st := image.map st\n\n"}
{"name":"CategoryTheory.Limits.StrongEpiMonoFactorisation.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : SizeOf C\ntoMonoFactorisation : CategoryTheory.Limits.MonoFactorisation f\ne_strong_epi : CategoryTheory.StrongEpi toMonoFactorisation.e\n⊢ Eq (SizeOf.sizeOf (CategoryTheory.Limits.StrongEpiMonoFactorisation.mk toMonoFactorisation)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toMonoFactorisation)) (SizeOf.sizeOf e_strong_epi))","decl":"/-- A strong epi-mono factorisation is a decomposition `f = e ≫ m` with `e` a strong epimorphism\n    and `m` a monomorphism. -/\nstructure StrongEpiMonoFactorisation {X Y : C} (f : X ⟶ Y) extends MonoFactorisation f where\n  [e_strong_epi : StrongEpi e]\n\n"}
{"name":"CategoryTheory.Limits.StrongEpiMonoFactorisation.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ntoMonoFactorisation✝ : CategoryTheory.Limits.MonoFactorisation f\ne_strong_epi✝ : CategoryTheory.StrongEpi toMonoFactorisation✝.e\ntoMonoFactorisation : CategoryTheory.Limits.MonoFactorisation f\ne_strong_epi : CategoryTheory.StrongEpi toMonoFactorisation.e\n⊢ Eq (Eq (CategoryTheory.Limits.StrongEpiMonoFactorisation.mk toMonoFactorisation✝) (CategoryTheory.Limits.StrongEpiMonoFactorisation.mk toMonoFactorisation)) (Eq toMonoFactorisation✝ toMonoFactorisation)","decl":"/-- A strong epi-mono factorisation is a decomposition `f = e ≫ m` with `e` a strong epimorphism\n    and `m` a monomorphism. -/\nstructure StrongEpiMonoFactorisation {X Y : C} (f : X ⟶ Y) extends MonoFactorisation f where\n  [e_strong_epi : StrongEpi e]\n\n"}
{"name":"CategoryTheory.Limits.StrongEpiMonoFactorisation.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ntoMonoFactorisation✝ : CategoryTheory.Limits.MonoFactorisation f\ne_strong_epi✝ : CategoryTheory.StrongEpi toMonoFactorisation✝.e\ntoMonoFactorisation : CategoryTheory.Limits.MonoFactorisation f\ne_strong_epi : CategoryTheory.StrongEpi toMonoFactorisation.e\nx✝ : Eq (CategoryTheory.Limits.StrongEpiMonoFactorisation.mk toMonoFactorisation✝) (CategoryTheory.Limits.StrongEpiMonoFactorisation.mk toMonoFactorisation)\n⊢ Eq toMonoFactorisation✝ toMonoFactorisation","decl":"/-- A strong epi-mono factorisation is a decomposition `f = e ≫ m` with `e` a strong epimorphism\n    and `m` a monomorphism. -/\nstructure StrongEpiMonoFactorisation {X Y : C} (f : X ⟶ Y) extends MonoFactorisation f where\n  [e_strong_epi : StrongEpi e]\n\n"}
{"name":"CategoryTheory.Limits.StrongEpiMonoFactorisation.e_strong_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nself : CategoryTheory.Limits.StrongEpiMonoFactorisation f\n⊢ CategoryTheory.StrongEpi self.e","decl":"/-- A strong epi-mono factorisation is a decomposition `f = e ≫ m` with `e` a strong epimorphism\n    and `m` a monomorphism. -/\nstructure StrongEpiMonoFactorisation {X Y : C} (f : X ⟶ Y) extends MonoFactorisation f where\n  [e_strong_epi : StrongEpi e]\n\n"}
{"name":"CategoryTheory.Limits.HasStrongEpiMonoFactorisations.has_fac","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Limits.HasStrongEpiMonoFactorisations C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Nonempty (CategoryTheory.Limits.StrongEpiMonoFactorisation f)","decl":"/-- A category has strong epi-mono factorisations if every morphism admits a strong epi-mono\n    factorisation. -/\nclass HasStrongEpiMonoFactorisations : Prop where mk' ::\n  has_fac : ∀ {X Y : C} (f : X ⟶ Y), Nonempty (StrongEpiMonoFactorisation f)\n\n"}
{"name":"CategoryTheory.Limits.HasStrongEpiMonoFactorisations.mk","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nd : {X Y : C} → (f : Quiver.Hom X Y) → CategoryTheory.Limits.StrongEpiMonoFactorisation f\n⊢ CategoryTheory.Limits.HasStrongEpiMonoFactorisations C","decl":"theorem HasStrongEpiMonoFactorisations.mk\n    (d : ∀ {X Y : C} (f : X ⟶ Y), StrongEpiMonoFactorisation f) :\n    HasStrongEpiMonoFactorisations C :=\n  ⟨fun f => Nonempty.intro <| d f⟩\n\n"}
{"name":"CategoryTheory.Limits.hasImages_of_hasStrongEpiMonoFactorisations","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasStrongEpiMonoFactorisations C\n⊢ CategoryTheory.Limits.HasImages C","decl":"instance (priority := 100) hasImages_of_hasStrongEpiMonoFactorisations\n    [HasStrongEpiMonoFactorisations C] : HasImages C where\n  has_image f :=\n    let F' := Classical.choice (HasStrongEpiMonoFactorisations.has_fac f)\n    HasImage.mk\n      { F := F'.toMonoFactorisation\n        isImage := F'.toMonoIsImage }\n\n"}
{"name":"CategoryTheory.Limits.HasStrongEpiImages.strong_factorThruImage","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasImages C\nself : CategoryTheory.Limits.HasStrongEpiImages C\nX Y : C\nf : Quiver.Hom X Y\n⊢ CategoryTheory.StrongEpi (CategoryTheory.Limits.factorThruImage f)","decl":"/-- A category has strong epi images if it has all images and `factorThruImage f` is a strong\n    epimorphism for all `f`. -/\nclass HasStrongEpiImages : Prop where\n  strong_factorThruImage : ∀ {X Y : C} (f : X ⟶ Y), StrongEpi (factorThruImage f)\n\n"}
{"name":"CategoryTheory.Limits.strongEpi_of_strongEpiMonoFactorisation","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF : CategoryTheory.Limits.StrongEpiMonoFactorisation f\nF' : CategoryTheory.Limits.MonoFactorisation f\nhF' : CategoryTheory.Limits.IsImage F'\n⊢ CategoryTheory.StrongEpi F'.e","decl":"/-- If there is a single strong epi-mono factorisation of `f`, then every image factorisation is a\n    strong epi-mono factorisation. -/\ntheorem strongEpi_of_strongEpiMonoFactorisation {X Y : C} {f : X ⟶ Y}\n    (F : StrongEpiMonoFactorisation f) {F' : MonoFactorisation f} (hF' : IsImage F') :\n    StrongEpi F'.e := by\n  rw [← IsImage.e_isoExt_hom F.toMonoIsImage hF']\n  apply strongEpi_comp\n\n"}
{"name":"CategoryTheory.Limits.strongEpi_factorThruImage_of_strongEpiMonoFactorisation","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasImage f\nF : CategoryTheory.Limits.StrongEpiMonoFactorisation f\n⊢ CategoryTheory.StrongEpi (CategoryTheory.Limits.factorThruImage f)","decl":"theorem strongEpi_factorThruImage_of_strongEpiMonoFactorisation {X Y : C} {f : X ⟶ Y} [HasImage f]\n    (F : StrongEpiMonoFactorisation f) : StrongEpi (factorThruImage f) :=\n  strongEpi_of_strongEpiMonoFactorisation F <| Image.isImage f\n\n"}
{"name":"CategoryTheory.Limits.hasStrongEpiImages_of_hasStrongEpiMonoFactorisations","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasStrongEpiMonoFactorisations C\n⊢ CategoryTheory.Limits.HasStrongEpiImages C","decl":"/-- If we constructed our images from strong epi-mono factorisations, then these images are\n    strong epi images. -/\ninstance (priority := 100) hasStrongEpiImages_of_hasStrongEpiMonoFactorisations\n    [HasStrongEpiMonoFactorisations C] : HasStrongEpiImages C where\n  strong_factorThruImage f :=\n    strongEpi_factorThruImage_of_strongEpiMonoFactorisation <|\n      Classical.choice <| HasStrongEpiMonoFactorisations.has_fac f\n\n"}
{"name":"CategoryTheory.Limits.hasImageMapsOfHasStrongEpiImages","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasImages C\ninst✝ : CategoryTheory.Limits.HasStrongEpiImages C\n⊢ CategoryTheory.Limits.HasImageMaps C","decl":"/-- A category with strong epi images has image maps. -/\ninstance (priority := 100) hasImageMapsOfHasStrongEpiImages [HasStrongEpiImages C] :\n    HasImageMaps C where\n  has_image_map {f} {g} st :=\n    HasImageMap.mk\n      { map :=\n          (CommSq.mk\n              (show\n                (st.left ≫ factorThruImage g.hom) ≫ image.ι g.hom =\n                  factorThruImage f.hom ≫ image.ι f.hom ≫ st.right\n                by simp)).lift }\n\n"}
{"name":"CategoryTheory.Limits.hasStrongEpiImages_of_hasPullbacks_of_hasEqualizers","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasImages C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\ninst✝ : CategoryTheory.Limits.HasEqualizers C\n⊢ CategoryTheory.Limits.HasStrongEpiImages C","decl":"/-- If a category has images, equalizers and pullbacks, then images are automatically strong epi\n    images. -/\ninstance (priority := 100) hasStrongEpiImages_of_hasPullbacks_of_hasEqualizers [HasPullbacks C]\n    [HasEqualizers C] : HasStrongEpiImages C where\n  strong_factorThruImage f :=\n    StrongEpi.mk' fun {A} {B} h h_mono x y sq =>\n      CommSq.HasLift.mk'\n        { l :=\n            image.lift\n                { I := pullback h y\n                  m := pullback.snd h y ≫ image.ι f\n                  m_mono := mono_comp _ _\n                  e := pullback.lift _ _ sq.w } ≫\n              pullback.fst h y\n          fac_left := by simp only [image.fac_lift_assoc, pullback.lift_fst]\n          fac_right := by\n            apply image.ext\n            simp only [sq.w, Category.assoc, image.fac_lift_assoc, pullback.lift_fst_assoc] }\n\n"}
{"name":"CategoryTheory.Limits.image.isoStrongEpiMono_hom_comp_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasStrongEpiMonoFactorisations C\nX Y : C\nf : Quiver.Hom X Y\nI' : C\ne : Quiver.Hom X I'\nm : Quiver.Hom I' Y\ncomm : Eq (CategoryTheory.CategoryStruct.comp e m) f\ninst✝¹ : CategoryTheory.StrongEpi e\ninst✝ : CategoryTheory.Mono m\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.isoStrongEpiMono e m comm).hom (CategoryTheory.Limits.image.ι f)) m","decl":"@[simp]\ntheorem image.isoStrongEpiMono_hom_comp_ι {I' : C} (e : X ⟶ I') (m : I' ⟶ Y) (comm : e ≫ m = f)\n    [StrongEpi e] [Mono m] : (image.isoStrongEpiMono e m comm).hom ≫ image.ι f = m := by\n  dsimp [isoStrongEpiMono]\n  apply IsImage.lift_fac\n\n"}
{"name":"CategoryTheory.Limits.image.isoStrongEpiMono_inv_comp_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasStrongEpiMonoFactorisations C\nX Y : C\nf : Quiver.Hom X Y\nI' : C\ne : Quiver.Hom X I'\nm : Quiver.Hom I' Y\ncomm : Eq (CategoryTheory.CategoryStruct.comp e m) f\ninst✝¹ : CategoryTheory.StrongEpi e\ninst✝ : CategoryTheory.Mono m\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.isoStrongEpiMono e m comm).inv m) (CategoryTheory.Limits.image.ι f)","decl":"@[simp]\ntheorem image.isoStrongEpiMono_inv_comp_mono {I' : C} (e : X ⟶ I') (m : I' ⟶ Y) (comm : e ≫ m = f)\n    [StrongEpi e] [Mono m] : (image.isoStrongEpiMono e m comm).inv ≫ m = image.ι f :=\n  image.lift_fac _\n\n"}
{"name":"CategoryTheory.Functor.hasStrongEpiMonoFactorisations_imp_of_isEquivalence","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\ninst✝ : F.IsEquivalence\nh : CategoryTheory.Limits.HasStrongEpiMonoFactorisations C\n⊢ CategoryTheory.Limits.HasStrongEpiMonoFactorisations D","decl":"theorem hasStrongEpiMonoFactorisations_imp_of_isEquivalence (F : C ⥤ D) [IsEquivalence F]\n    [h : HasStrongEpiMonoFactorisations C] : HasStrongEpiMonoFactorisations D :=\n  ⟨fun {X} {Y} f => by\n    let em : StrongEpiMonoFactorisation (F.inv.map f) :=\n      (HasStrongEpiMonoFactorisations.has_fac (F.inv.map f)).some\n    haveI : Mono (F.map em.m ≫ F.asEquivalence.counitIso.hom.app Y) := mono_comp _ _\n    haveI : StrongEpi (F.asEquivalence.counitIso.inv.app X ≫ F.map em.e) := strongEpi_comp _ _\n    exact\n      Nonempty.intro\n        { I := F.obj em.I\n          e := F.asEquivalence.counitIso.inv.app X ≫ F.map em.e\n          m := F.map em.m ≫ F.asEquivalence.counitIso.hom.app Y\n          fac := by\n            simp only [asEquivalence_functor, Category.assoc, ← F.map_comp_assoc,\n              MonoFactorisation.fac, fun_inv_map, id_obj, Iso.inv_hom_id_app, Category.comp_id,\n              Iso.inv_hom_id_app_assoc] }⟩\n\n"}
