{"name":"CategoryTheory.Limits.MonoFactorisation.m_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nself : CategoryTheory.Limits.MonoFactorisation f\n‚ä¢ CategoryTheory.Mono self.m","decl":"/-- A factorisation of a morphism `f = e ‚â´ m`, with `m` monic. -/\nstructure MonoFactorisation (f : X ‚ü∂ Y) where\n  I : C -- Porting note: violates naming conventions but can't think a better replacement\n  m : I ‚ü∂ Y\n  [m_mono : Mono m]\n  e : X ‚ü∂ I\n  fac : e ‚â´ m = f := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : SizeOf C\nI : C\nm : Quiver.Hom I Y\nm_mono : CategoryTheory.Mono m\ne : Quiver.Hom X I\nfac : autoParam (Eq (CategoryTheory.CategoryStruct.comp e m) f) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf (CategoryTheory.Limits.MonoFactorisation.mk I m e fac)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf I)) (SizeOf.sizeOf m)) (SizeOf.sizeOf m_mono)) (SizeOf.sizeOf e)) (SizeOf.sizeOf fac))","decl":"/-- A factorisation of a morphism `f = e ‚â´ m`, with `m` monic. -/\nstructure MonoFactorisation (f : X ‚ü∂ Y) where\n  I : C -- Porting note: violates naming conventions but can't think a better replacement\n  m : I ‚ü∂ Y\n  [m_mono : Mono m]\n  e : X ‚ü∂ I\n  fac : e ‚â´ m = f := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.fac","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nself : CategoryTheory.Limits.MonoFactorisation f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.e self.m) f","decl":"/-- A factorisation of a morphism `f = e ‚â´ m`, with `m` monic. -/\nstructure MonoFactorisation (f : X ‚ü∂ Y) where\n  I : C -- Porting note: violates naming conventions but can't think a better replacement\n  m : I ‚ü∂ Y\n  [m_mono : Mono m]\n  e : X ‚ü∂ I\n  fac : e ‚â´ m = f := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nI‚úù : C\nm‚úù : Quiver.Hom I‚úù Y\nm_mono‚úù : CategoryTheory.Mono m‚úù\ne‚úù : Quiver.Hom X I‚úù\nfac‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp e‚úù m‚úù) f) _auto‚úù\nI : C\nm : Quiver.Hom I Y\nm_mono : CategoryTheory.Mono m\ne : Quiver.Hom X I\nfac : autoParam (Eq (CategoryTheory.CategoryStruct.comp e m) f) _auto‚úù\nx‚úù : Eq (CategoryTheory.Limits.MonoFactorisation.mk I‚úù m‚úù e‚úù fac‚úù) (CategoryTheory.Limits.MonoFactorisation.mk I m e fac)\n‚ä¢ And (Eq I‚úù I) (And (HEq m‚úù m) (HEq e‚úù e))","decl":"/-- A factorisation of a morphism `f = e ‚â´ m`, with `m` monic. -/\nstructure MonoFactorisation (f : X ‚ü∂ Y) where\n  I : C -- Porting note: violates naming conventions but can't think a better replacement\n  m : I ‚ü∂ Y\n  [m_mono : Mono m]\n  e : X ‚ü∂ I\n  fac : e ‚â´ m = f := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nI‚úù : C\nm‚úù : Quiver.Hom I‚úù Y\nm_mono‚úù : CategoryTheory.Mono m‚úù\ne‚úù : Quiver.Hom X I‚úù\nfac‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp e‚úù m‚úù) f) _auto‚úù\nI : C\nm : Quiver.Hom I Y\nm_mono : CategoryTheory.Mono m\ne : Quiver.Hom X I\nfac : autoParam (Eq (CategoryTheory.CategoryStruct.comp e m) f) _auto‚úù\n‚ä¢ Eq (Eq (CategoryTheory.Limits.MonoFactorisation.mk I‚úù m‚úù e‚úù fac‚úù) (CategoryTheory.Limits.MonoFactorisation.mk I m e fac)) (And (Eq I‚úù I) (And (HEq m‚úù m) (HEq e‚úù e)))","decl":"/-- A factorisation of a morphism `f = e ‚â´ m`, with `m` monic. -/\nstructure MonoFactorisation (f : X ‚ü∂ Y) where\n  I : C -- Porting note: violates naming conventions but can't think a better replacement\n  m : I ‚ü∂ Y\n  [m_mono : Mono m]\n  e : X ‚ü∂ I\n  fac : e ‚â´ m = f := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.fac_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nself : CategoryTheory.Limits.MonoFactorisation f\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.e (CategoryTheory.CategoryStruct.comp self.m h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"attribute [reassoc (attr := simp)] MonoFactorisation.fac\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF F' : CategoryTheory.Limits.MonoFactorisation f\nhI : Eq F.I F'.I\nhm : Eq F.m (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom hI) F'.m)\n‚ä¢ Eq F F'","decl":"/-- The morphism `m` in a factorisation `f = e ‚â´ m` through a monomorphism is uniquely\ndetermined. -/\n@[ext (iff := false)]\ntheorem ext {F F' : MonoFactorisation f} (hI : F.I = F'.I)\n    (hm : F.m = eqToHom hI ‚â´ F'.m) : F = F' := by\n  cases' F with _ Fm _ _ Ffac; cases' F' with _ Fm' _ _ Ffac'\n  cases' hI\n  simp? at hm says simp only [eqToHom_refl, Category.id_comp] at hm\n  congr\n  apply (cancel_mono Fm).1\n  rw [Ffac, hm, Ffac']\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.compMono_e","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF : CategoryTheory.Limits.MonoFactorisation f\nY' : C\ng : Quiver.Hom Y Y'\ninst‚úù : CategoryTheory.Mono g\n‚ä¢ Eq (F.compMono g).e F.e","decl":"/-- Any mono factorisation of `f` gives a mono factorisation of `f ‚â´ g` when `g` is a mono. -/\n@[simps]\ndef compMono (F : MonoFactorisation f) {Y' : C} (g : Y ‚ü∂ Y') [Mono g] :\n    MonoFactorisation (f ‚â´ g) where\n  I := F.I\n  m := F.m ‚â´ g\n  m_mono := mono_comp _ _\n  e := F.e\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.compMono_I","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF : CategoryTheory.Limits.MonoFactorisation f\nY' : C\ng : Quiver.Hom Y Y'\ninst‚úù : CategoryTheory.Mono g\n‚ä¢ Eq (F.compMono g).I F.I","decl":"/-- Any mono factorisation of `f` gives a mono factorisation of `f ‚â´ g` when `g` is a mono. -/\n@[simps]\ndef compMono (F : MonoFactorisation f) {Y' : C} (g : Y ‚ü∂ Y') [Mono g] :\n    MonoFactorisation (f ‚â´ g) where\n  I := F.I\n  m := F.m ‚â´ g\n  m_mono := mono_comp _ _\n  e := F.e\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.compMono_m","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF : CategoryTheory.Limits.MonoFactorisation f\nY' : C\ng : Quiver.Hom Y Y'\ninst‚úù : CategoryTheory.Mono g\n‚ä¢ Eq (F.compMono g).m (CategoryTheory.CategoryStruct.comp F.m g)","decl":"/-- Any mono factorisation of `f` gives a mono factorisation of `f ‚â´ g` when `g` is a mono. -/\n@[simps]\ndef compMono (F : MonoFactorisation f) {Y' : C} (g : Y ‚ü∂ Y') [Mono g] :\n    MonoFactorisation (f ‚â´ g) where\n  I := F.I\n  m := F.m ‚â´ g\n  m_mono := mono_comp _ _\n  e := F.e\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.ofCompIso_m","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nY' : C\ng : Quiver.Hom Y Y'\ninst‚úù : CategoryTheory.IsIso g\nF : CategoryTheory.Limits.MonoFactorisation (CategoryTheory.CategoryStruct.comp f g)\n‚ä¢ Eq F.ofCompIso.m (CategoryTheory.CategoryStruct.comp F.m (CategoryTheory.inv g))","decl":"/-- A mono factorisation of `f ‚â´ g`, where `g` is an isomorphism,\ngives a mono factorisation of `f`. -/\n@[simps]\ndef ofCompIso {Y' : C} {g : Y ‚ü∂ Y'} [IsIso g] (F : MonoFactorisation (f ‚â´ g)) :\n    MonoFactorisation f where\n  I := F.I\n  m := F.m ‚â´ inv g\n  m_mono := mono_comp _ _\n  e := F.e\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.ofCompIso_I","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nY' : C\ng : Quiver.Hom Y Y'\ninst‚úù : CategoryTheory.IsIso g\nF : CategoryTheory.Limits.MonoFactorisation (CategoryTheory.CategoryStruct.comp f g)\n‚ä¢ Eq F.ofCompIso.I F.I","decl":"/-- A mono factorisation of `f ‚â´ g`, where `g` is an isomorphism,\ngives a mono factorisation of `f`. -/\n@[simps]\ndef ofCompIso {Y' : C} {g : Y ‚ü∂ Y'} [IsIso g] (F : MonoFactorisation (f ‚â´ g)) :\n    MonoFactorisation f where\n  I := F.I\n  m := F.m ‚â´ inv g\n  m_mono := mono_comp _ _\n  e := F.e\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.ofCompIso_e","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nY' : C\ng : Quiver.Hom Y Y'\ninst‚úù : CategoryTheory.IsIso g\nF : CategoryTheory.Limits.MonoFactorisation (CategoryTheory.CategoryStruct.comp f g)\n‚ä¢ Eq F.ofCompIso.e F.e","decl":"/-- A mono factorisation of `f ‚â´ g`, where `g` is an isomorphism,\ngives a mono factorisation of `f`. -/\n@[simps]\ndef ofCompIso {Y' : C} {g : Y ‚ü∂ Y'} [IsIso g] (F : MonoFactorisation (f ‚â´ g)) :\n    MonoFactorisation f where\n  I := F.I\n  m := F.m ‚â´ inv g\n  m_mono := mono_comp _ _\n  e := F.e\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.isoComp_m","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF : CategoryTheory.Limits.MonoFactorisation f\nX' : C\ng : Quiver.Hom X' X\n‚ä¢ Eq (F.isoComp g).m F.m","decl":"/-- Any mono factorisation of `f` gives a mono factorisation of `g ‚â´ f`. -/\n@[simps]\ndef isoComp (F : MonoFactorisation f) {X' : C} (g : X' ‚ü∂ X) : MonoFactorisation (g ‚â´ f) where\n  I := F.I\n  m := F.m\n  e := g ‚â´ F.e\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.isoComp_e","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF : CategoryTheory.Limits.MonoFactorisation f\nX' : C\ng : Quiver.Hom X' X\n‚ä¢ Eq (F.isoComp g).e (CategoryTheory.CategoryStruct.comp g F.e)","decl":"/-- Any mono factorisation of `f` gives a mono factorisation of `g ‚â´ f`. -/\n@[simps]\ndef isoComp (F : MonoFactorisation f) {X' : C} (g : X' ‚ü∂ X) : MonoFactorisation (g ‚â´ f) where\n  I := F.I\n  m := F.m\n  e := g ‚â´ F.e\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.isoComp_I","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF : CategoryTheory.Limits.MonoFactorisation f\nX' : C\ng : Quiver.Hom X' X\n‚ä¢ Eq (F.isoComp g).I F.I","decl":"/-- Any mono factorisation of `f` gives a mono factorisation of `g ‚â´ f`. -/\n@[simps]\ndef isoComp (F : MonoFactorisation f) {X' : C} (g : X' ‚ü∂ X) : MonoFactorisation (g ‚â´ f) where\n  I := F.I\n  m := F.m\n  e := g ‚â´ F.e\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.ofIsoComp_I","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nX' : C\ng : Quiver.Hom X' X\ninst‚úù : CategoryTheory.IsIso g\nF : CategoryTheory.Limits.MonoFactorisation (CategoryTheory.CategoryStruct.comp g f)\n‚ä¢ Eq (CategoryTheory.Limits.MonoFactorisation.ofIsoComp g F).I F.I","decl":"/-- A mono factorisation of `g ‚â´ f`, where `g` is an isomorphism,\ngives a mono factorisation of `f`. -/\n@[simps]\ndef ofIsoComp {X' : C} (g : X' ‚ü∂ X) [IsIso g] (F : MonoFactorisation (g ‚â´ f)) :\n    MonoFactorisation f where\n  I := F.I\n  m := F.m\n  e := inv g ‚â´ F.e\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.ofIsoComp_m","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nX' : C\ng : Quiver.Hom X' X\ninst‚úù : CategoryTheory.IsIso g\nF : CategoryTheory.Limits.MonoFactorisation (CategoryTheory.CategoryStruct.comp g f)\n‚ä¢ Eq (CategoryTheory.Limits.MonoFactorisation.ofIsoComp g F).m F.m","decl":"/-- A mono factorisation of `g ‚â´ f`, where `g` is an isomorphism,\ngives a mono factorisation of `f`. -/\n@[simps]\ndef ofIsoComp {X' : C} (g : X' ‚ü∂ X) [IsIso g] (F : MonoFactorisation (g ‚â´ f)) :\n    MonoFactorisation f where\n  I := F.I\n  m := F.m\n  e := inv g ‚â´ F.e\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.ofIsoComp_e","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nX' : C\ng : Quiver.Hom X' X\ninst‚úù : CategoryTheory.IsIso g\nF : CategoryTheory.Limits.MonoFactorisation (CategoryTheory.CategoryStruct.comp g f)\n‚ä¢ Eq (CategoryTheory.Limits.MonoFactorisation.ofIsoComp g F).e (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv g) F.e)","decl":"/-- A mono factorisation of `g ‚â´ f`, where `g` is an isomorphism,\ngives a mono factorisation of `f`. -/\n@[simps]\ndef ofIsoComp {X' : C} (g : X' ‚ü∂ X) [IsIso g] (F : MonoFactorisation (g ‚â´ f)) :\n    MonoFactorisation f where\n  I := F.I\n  m := F.m\n  e := inv g ‚â´ F.e\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.ofArrowIso_I","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\nF : CategoryTheory.Limits.MonoFactorisation f.hom\nsq : Quiver.Hom f g\ninst‚úù : CategoryTheory.IsIso sq\n‚ä¢ Eq (F.ofArrowIso sq).I F.I","decl":"/-- If `f` and `g` are isomorphic arrows, then a mono factorisation of `f`\ngives a mono factorisation of `g` -/\n@[simps]\ndef ofArrowIso {f g : Arrow C} (F : MonoFactorisation f.hom) (sq : f ‚ü∂ g) [IsIso sq] :\n    MonoFactorisation g.hom where\n  I := F.I\n  m := F.m ‚â´ sq.right\n  e := inv sq.left ‚â´ F.e\n  m_mono := mono_comp _ _\n  fac := by simp only [fac_assoc, Arrow.w, IsIso.inv_comp_eq, Category.assoc]\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.ofArrowIso_e","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\nF : CategoryTheory.Limits.MonoFactorisation f.hom\nsq : Quiver.Hom f g\ninst‚úù : CategoryTheory.IsIso sq\n‚ä¢ Eq (F.ofArrowIso sq).e (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv sq.left) F.e)","decl":"/-- If `f` and `g` are isomorphic arrows, then a mono factorisation of `f`\ngives a mono factorisation of `g` -/\n@[simps]\ndef ofArrowIso {f g : Arrow C} (F : MonoFactorisation f.hom) (sq : f ‚ü∂ g) [IsIso sq] :\n    MonoFactorisation g.hom where\n  I := F.I\n  m := F.m ‚â´ sq.right\n  e := inv sq.left ‚â´ F.e\n  m_mono := mono_comp _ _\n  fac := by simp only [fac_assoc, Arrow.w, IsIso.inv_comp_eq, Category.assoc]\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.ofArrowIso_m","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\nF : CategoryTheory.Limits.MonoFactorisation f.hom\nsq : Quiver.Hom f g\ninst‚úù : CategoryTheory.IsIso sq\n‚ä¢ Eq (F.ofArrowIso sq).m (CategoryTheory.CategoryStruct.comp F.m sq.right)","decl":"/-- If `f` and `g` are isomorphic arrows, then a mono factorisation of `f`\ngives a mono factorisation of `g` -/\n@[simps]\ndef ofArrowIso {f g : Arrow C} (F : MonoFactorisation f.hom) (sq : f ‚ü∂ g) [IsIso sq] :\n    MonoFactorisation g.hom where\n  I := F.I\n  m := F.m ‚â´ sq.right\n  e := inv sq.left ‚â´ F.e\n  m_mono := mono_comp _ _\n  fac := by simp only [fac_assoc, Arrow.w, IsIso.inv_comp_eq, Category.assoc]\n\n"}
{"name":"CategoryTheory.Limits.IsImage.lift_fac","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF : CategoryTheory.Limits.MonoFactorisation f\nself : CategoryTheory.Limits.IsImage F\nF' : CategoryTheory.Limits.MonoFactorisation f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.lift F') F'.m) F.m","decl":"/-- Data exhibiting that a given factorisation through a mono is initial. -/\nstructure IsImage (F : MonoFactorisation f) where\n  lift : ‚àÄ F' : MonoFactorisation f, F.I ‚ü∂ F'.I\n  lift_fac : ‚àÄ F' : MonoFactorisation f, lift F' ‚â´ F'.m = F.m := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.IsImage.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF : CategoryTheory.Limits.MonoFactorisation f\nlift‚úù : (F' : CategoryTheory.Limits.MonoFactorisation f) ‚Üí Quiver.Hom F.I F'.I\nlift_fac‚úù : autoParam (‚àÄ (F' : CategoryTheory.Limits.MonoFactorisation f), Eq (CategoryTheory.CategoryStruct.comp (lift‚úù F') F'.m) F.m) _auto‚úù\nlift : (F' : CategoryTheory.Limits.MonoFactorisation f) ‚Üí Quiver.Hom F.I F'.I\nlift_fac : autoParam (‚àÄ (F' : CategoryTheory.Limits.MonoFactorisation f), Eq (CategoryTheory.CategoryStruct.comp (lift F') F'.m) F.m) _auto‚úù\n‚ä¢ Eq (Eq { lift := lift‚úù, lift_fac := lift_fac‚úù } { lift := lift, lift_fac := lift_fac }) (Eq lift‚úù lift)","decl":"/-- Data exhibiting that a given factorisation through a mono is initial. -/\nstructure IsImage (F : MonoFactorisation f) where\n  lift : ‚àÄ F' : MonoFactorisation f, F.I ‚ü∂ F'.I\n  lift_fac : ‚àÄ F' : MonoFactorisation f, lift F' ‚â´ F'.m = F.m := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.IsImage.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF : CategoryTheory.Limits.MonoFactorisation f\ninst‚úù : SizeOf C\nlift : (F' : CategoryTheory.Limits.MonoFactorisation f) ‚Üí Quiver.Hom F.I F'.I\nlift_fac : autoParam (‚àÄ (F' : CategoryTheory.Limits.MonoFactorisation f), Eq (CategoryTheory.CategoryStruct.comp (lift F') F'.m) F.m) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { lift := lift, lift_fac := lift_fac }) 1","decl":"/-- Data exhibiting that a given factorisation through a mono is initial. -/\nstructure IsImage (F : MonoFactorisation f) where\n  lift : ‚àÄ F' : MonoFactorisation f, F.I ‚ü∂ F'.I\n  lift_fac : ‚àÄ F' : MonoFactorisation f, lift F' ‚â´ F'.m = F.m := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.IsImage.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF : CategoryTheory.Limits.MonoFactorisation f\nlift‚úù : (F' : CategoryTheory.Limits.MonoFactorisation f) ‚Üí Quiver.Hom F.I F'.I\nlift_fac‚úù : autoParam (‚àÄ (F' : CategoryTheory.Limits.MonoFactorisation f), Eq (CategoryTheory.CategoryStruct.comp (lift‚úù F') F'.m) F.m) _auto‚úù\nlift : (F' : CategoryTheory.Limits.MonoFactorisation f) ‚Üí Quiver.Hom F.I F'.I\nlift_fac : autoParam (‚àÄ (F' : CategoryTheory.Limits.MonoFactorisation f), Eq (CategoryTheory.CategoryStruct.comp (lift F') F'.m) F.m) _auto‚úù\nx‚úù : Eq { lift := lift‚úù, lift_fac := lift_fac‚úù } { lift := lift, lift_fac := lift_fac }\n‚ä¢ Eq lift‚úù lift","decl":"/-- Data exhibiting that a given factorisation through a mono is initial. -/\nstructure IsImage (F : MonoFactorisation f) where\n  lift : ‚àÄ F' : MonoFactorisation f, F.I ‚ü∂ F'.I\n  lift_fac : ‚àÄ F' : MonoFactorisation f, lift F' ‚â´ F'.m = F.m := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.IsImage.lift_fac_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF : CategoryTheory.Limits.MonoFactorisation f\nself : CategoryTheory.Limits.IsImage F\nF' : CategoryTheory.Limits.MonoFactorisation f\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.lift F') (CategoryTheory.CategoryStruct.comp F'.m h)) (CategoryTheory.CategoryStruct.comp F.m h)","decl":"attribute [reassoc (attr := simp)] IsImage.lift_fac\n\n"}
{"name":"CategoryTheory.Limits.IsImage.fac_lift","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF : CategoryTheory.Limits.MonoFactorisation f\nhF : CategoryTheory.Limits.IsImage F\nF' : CategoryTheory.Limits.MonoFactorisation f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp F.e (hF.lift F')) F'.e","decl":"@[reassoc (attr := simp)]\ntheorem fac_lift {F : MonoFactorisation f} (hF : IsImage F) (F' : MonoFactorisation f) :\n    F.e ‚â´ hF.lift F' = F'.e :=\n  (cancel_mono F'.m).1 <| by simp\n\n"}
{"name":"CategoryTheory.Limits.IsImage.fac_lift_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF : CategoryTheory.Limits.MonoFactorisation f\nhF : CategoryTheory.Limits.IsImage F\nF' : CategoryTheory.Limits.MonoFactorisation f\nZ : C\nh : Quiver.Hom F'.I Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp F.e (CategoryTheory.CategoryStruct.comp (hF.lift F') h)) (CategoryTheory.CategoryStruct.comp F'.e h)","decl":"@[reassoc (attr := simp)]\ntheorem fac_lift {F : MonoFactorisation f} (hF : IsImage F) (F' : MonoFactorisation f) :\n    F.e ‚â´ hF.lift F' = F'.e :=\n  (cancel_mono F'.m).1 <| by simp\n\n"}
{"name":"CategoryTheory.Limits.IsImage.self_lift","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\nF' : CategoryTheory.Limits.MonoFactorisation f\n‚ä¢ Eq ((CategoryTheory.Limits.IsImage.self f).lift F') F'.e","decl":"/-- The trivial factorisation of a monomorphism satisfies the universal property. -/\n@[simps]\ndef self [Mono f] : IsImage (MonoFactorisation.self f) where lift F' := F'.e\n\n"}
{"name":"CategoryTheory.Limits.IsImage.isoExt_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF F' : CategoryTheory.Limits.MonoFactorisation f\nhF : CategoryTheory.Limits.IsImage F\nhF' : CategoryTheory.Limits.IsImage F'\n‚ä¢ Eq (hF.isoExt hF').inv (hF'.lift F)","decl":"/-- Two factorisations through monomorphisms satisfying the universal property\nmust factor through isomorphic objects. -/\n@[simps]\ndef isoExt {F F' : MonoFactorisation f} (hF : IsImage F) (hF' : IsImage F') :\n    F.I ‚âÖ F'.I where\n  hom := hF.lift F'\n  inv := hF'.lift F\n  hom_inv_id := (cancel_mono F.m).1 (by simp)\n  inv_hom_id := (cancel_mono F'.m).1 (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsImage.isoExt_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF F' : CategoryTheory.Limits.MonoFactorisation f\nhF : CategoryTheory.Limits.IsImage F\nhF' : CategoryTheory.Limits.IsImage F'\n‚ä¢ Eq (hF.isoExt hF').hom (hF.lift F')","decl":"/-- Two factorisations through monomorphisms satisfying the universal property\nmust factor through isomorphic objects. -/\n@[simps]\ndef isoExt {F F' : MonoFactorisation f} (hF : IsImage F) (hF' : IsImage F') :\n    F.I ‚âÖ F'.I where\n  hom := hF.lift F'\n  inv := hF'.lift F\n  hom_inv_id := (cancel_mono F.m).1 (by simp)\n  inv_hom_id := (cancel_mono F'.m).1 (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsImage.isoExt_hom_m","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF F' : CategoryTheory.Limits.MonoFactorisation f\nhF : CategoryTheory.Limits.IsImage F\nhF' : CategoryTheory.Limits.IsImage F'\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (hF.isoExt hF').hom F'.m) F.m","decl":"theorem isoExt_hom_m : (isoExt hF hF').hom ‚â´ F'.m = F.m := by simp\n\n"}
{"name":"CategoryTheory.Limits.IsImage.isoExt_inv_m","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF F' : CategoryTheory.Limits.MonoFactorisation f\nhF : CategoryTheory.Limits.IsImage F\nhF' : CategoryTheory.Limits.IsImage F'\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (hF.isoExt hF').inv F.m) F'.m","decl":"theorem isoExt_inv_m : (isoExt hF hF').inv ‚â´ F.m = F'.m := by simp\n\n"}
{"name":"CategoryTheory.Limits.IsImage.e_isoExt_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF F' : CategoryTheory.Limits.MonoFactorisation f\nhF : CategoryTheory.Limits.IsImage F\nhF' : CategoryTheory.Limits.IsImage F'\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp F.e (hF.isoExt hF').hom) F'.e","decl":"theorem e_isoExt_hom : F.e ‚â´ (isoExt hF hF').hom = F'.e := by simp\n\n"}
{"name":"CategoryTheory.Limits.IsImage.e_isoExt_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF F' : CategoryTheory.Limits.MonoFactorisation f\nhF : CategoryTheory.Limits.IsImage F\nhF' : CategoryTheory.Limits.IsImage F'\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp F'.e (hF.isoExt hF').inv) F.e","decl":"theorem e_isoExt_inv : F'.e ‚â´ (isoExt hF hF').inv = F.e := by simp\n\n"}
{"name":"CategoryTheory.Limits.IsImage.ofArrowIso_lift","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\nF : CategoryTheory.Limits.MonoFactorisation f.hom\nhF : CategoryTheory.Limits.IsImage F\nsq : Quiver.Hom f g\ninst‚úù : CategoryTheory.IsIso sq\nF' : CategoryTheory.Limits.MonoFactorisation g.hom\n‚ä¢ Eq ((hF.ofArrowIso sq).lift F') (hF.lift (F'.ofArrowIso (CategoryTheory.inv sq)))","decl":"/-- If `f` and `g` are isomorphic arrows, then a mono factorisation of `f` that is an image\ngives a mono factorisation of `g` that is an image -/\n@[simps]\ndef ofArrowIso {f g : Arrow C} {F : MonoFactorisation f.hom} (hF : IsImage F) (sq : f ‚ü∂ g)\n    [IsIso sq] : IsImage (F.ofArrowIso sq) where\n  lift F' := hF.lift (F'.ofArrowIso (inv sq))\n  lift_fac F' := by\n    simpa only [MonoFactorisation.ofArrowIso_m, Arrow.inv_right, ‚Üê Category.assoc,\n      IsIso.comp_inv_eq] using hF.lift_fac (F'.ofArrowIso (inv sq))\n\n"}
{"name":"CategoryTheory.Limits.ImageFactorisation.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF‚úù : CategoryTheory.Limits.MonoFactorisation f\nisImage‚úù : CategoryTheory.Limits.IsImage F‚úù\nF : CategoryTheory.Limits.MonoFactorisation f\nisImage : CategoryTheory.Limits.IsImage F\nx‚úù : Eq { F := F‚úù, isImage := isImage‚úù } { F := F, isImage := isImage }\n‚ä¢ And (Eq F‚úù F) (HEq isImage‚úù isImage)","decl":"/-- Data exhibiting that a morphism `f` has an image. -/\nstructure ImageFactorisation (f : X ‚ü∂ Y) where\n  F : MonoFactorisation f -- Porting note: another violation of the naming convention\n  isImage : IsImage F\n\n"}
{"name":"CategoryTheory.Limits.ImageFactorisation.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF‚úù : CategoryTheory.Limits.MonoFactorisation f\nisImage‚úù : CategoryTheory.Limits.IsImage F‚úù\nF : CategoryTheory.Limits.MonoFactorisation f\nisImage : CategoryTheory.Limits.IsImage F\n‚ä¢ Eq (Eq { F := F‚úù, isImage := isImage‚úù } { F := F, isImage := isImage }) (And (Eq F‚úù F) (HEq isImage‚úù isImage))","decl":"/-- Data exhibiting that a morphism `f` has an image. -/\nstructure ImageFactorisation (f : X ‚ü∂ Y) where\n  F : MonoFactorisation f -- Porting note: another violation of the naming convention\n  isImage : IsImage F\n\n"}
{"name":"CategoryTheory.Limits.ImageFactorisation.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : SizeOf C\nF : CategoryTheory.Limits.MonoFactorisation f\nisImage : CategoryTheory.Limits.IsImage F\n‚ä¢ Eq (SizeOf.sizeOf { F := F, isImage := isImage }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf F)) (SizeOf.sizeOf isImage))","decl":"/-- Data exhibiting that a morphism `f` has an image. -/\nstructure ImageFactorisation (f : X ‚ü∂ Y) where\n  F : MonoFactorisation f -- Porting note: another violation of the naming convention\n  isImage : IsImage F\n\n"}
{"name":"CategoryTheory.Limits.ImageFactorisation.ofArrowIso_isImage","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\nF : CategoryTheory.Limits.ImageFactorisation f.hom\nsq : Quiver.Hom f g\ninst‚úù : CategoryTheory.IsIso sq\n‚ä¢ Eq (F.ofArrowIso sq).isImage (F.isImage.ofArrowIso sq)","decl":"/-- If `f` and `g` are isomorphic arrows, then an image factorisation of `f`\ngives an image factorisation of `g` -/\n@[simps]\ndef ofArrowIso {f g : Arrow C} (F : ImageFactorisation f.hom) (sq : f ‚ü∂ g) [IsIso sq] :\n    ImageFactorisation g.hom where\n  F := F.F.ofArrowIso sq\n  isImage := F.isImage.ofArrowIso sq\n\n"}
{"name":"CategoryTheory.Limits.ImageFactorisation.ofArrowIso_F","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\nF : CategoryTheory.Limits.ImageFactorisation f.hom\nsq : Quiver.Hom f g\ninst‚úù : CategoryTheory.IsIso sq\n‚ä¢ Eq (F.ofArrowIso sq).F (F.F.ofArrowIso sq)","decl":"/-- If `f` and `g` are isomorphic arrows, then an image factorisation of `f`\ngives an image factorisation of `g` -/\n@[simps]\ndef ofArrowIso {f g : Arrow C} (F : ImageFactorisation f.hom) (sq : f ‚ü∂ g) [IsIso sq] :\n    ImageFactorisation g.hom where\n  F := F.F.ofArrowIso sq\n  isImage := F.isImage.ofArrowIso sq\n\n"}
{"name":"CategoryTheory.Limits.HasImage.exists_image","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nself : CategoryTheory.Limits.HasImage f\n‚ä¢ Nonempty (CategoryTheory.Limits.ImageFactorisation f)","decl":"/-- `HasImage f` means that there exists an image factorisation of `f`. -/\nclass HasImage (f : X ‚ü∂ Y) : Prop where mk' ::\n  exists_image : Nonempty (ImageFactorisation f)\n\n"}
{"name":"CategoryTheory.Limits.HasImage.mk","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF : CategoryTheory.Limits.ImageFactorisation f\n‚ä¢ CategoryTheory.Limits.HasImage f","decl":"theorem HasImage.mk {f : X ‚ü∂ Y} (F : ImageFactorisation f) : HasImage f :=\n  ‚ü®Nonempty.intro F‚ü©\n\n"}
{"name":"CategoryTheory.Limits.HasImage.of_arrow_iso","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\nh : CategoryTheory.Limits.HasImage f.hom\nsq : Quiver.Hom f g\ninst‚úù : CategoryTheory.IsIso sq\n‚ä¢ CategoryTheory.Limits.HasImage g.hom","decl":"theorem HasImage.of_arrow_iso {f g : Arrow C} [h : HasImage f.hom] (sq : f ‚ü∂ g) [IsIso sq] :\n    HasImage g.hom :=\n  ‚ü®‚ü®h.exists_image.some.ofArrowIso sq‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.mono_hasImage","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ CategoryTheory.Limits.HasImage f","decl":"instance (priority := 100) mono_hasImage (f : X ‚ü∂ Y) [Mono f] : HasImage f :=\n  HasImage.mk ‚ü®_, IsImage.self f‚ü©\n\n"}
{"name":"CategoryTheory.Limits.image.as_Œπ","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasImage f\n‚ä¢ Eq (CategoryTheory.Limits.Image.monoFactorisation f).m (CategoryTheory.Limits.image.Œπ f)","decl":"@[simp]\ntheorem image.as_Œπ : (Image.monoFactorisation f).m = image.Œπ f := rfl\n\n"}
{"name":"CategoryTheory.Limits.instMonoŒπ","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasImage f\n‚ä¢ CategoryTheory.Mono (CategoryTheory.Limits.image.Œπ f)","decl":"instance : Mono (image.Œπ f) :=\n  (Image.monoFactorisation f).m_mono\n\n"}
{"name":"CategoryTheory.Limits.as_factorThruImage","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasImage f\n‚ä¢ Eq (CategoryTheory.Limits.Image.monoFactorisation f).e (CategoryTheory.Limits.factorThruImage f)","decl":"/-- Rewrite in terms of the `factorThruImage` interface. -/\n@[simp]\ntheorem as_factorThruImage : (Image.monoFactorisation f).e = factorThruImage f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.image.fac","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasImage f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImage f) (CategoryTheory.Limits.image.Œπ f)) f","decl":"@[reassoc (attr := simp)]\ntheorem image.fac : factorThruImage f ‚â´ image.Œπ f = f :=\n  (Image.monoFactorisation f).fac\n\n"}
{"name":"CategoryTheory.Limits.image.fac_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasImage f\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImage f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.Œπ f) h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc (attr := simp)]\ntheorem image.fac : factorThruImage f ‚â´ image.Œπ f = f :=\n  (Image.monoFactorisation f).fac\n\n"}
{"name":"CategoryTheory.Limits.image.lift_fac","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasImage f\nF' : CategoryTheory.Limits.MonoFactorisation f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.lift F') F'.m) (CategoryTheory.Limits.image.Œπ f)","decl":"@[reassoc (attr := simp)]\ntheorem image.lift_fac (F' : MonoFactorisation f) : image.lift F' ‚â´ F'.m = image.Œπ f :=\n  (Image.isImage f).lift_fac F'\n\n"}
{"name":"CategoryTheory.Limits.image.lift_fac_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasImage f\nF' : CategoryTheory.Limits.MonoFactorisation f\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.lift F') (CategoryTheory.CategoryStruct.comp F'.m h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.Œπ f) h)","decl":"@[reassoc (attr := simp)]\ntheorem image.lift_fac (F' : MonoFactorisation f) : image.lift F' ‚â´ F'.m = image.Œπ f :=\n  (Image.isImage f).lift_fac F'\n\n"}
{"name":"CategoryTheory.Limits.image.fac_lift","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasImage f\nF' : CategoryTheory.Limits.MonoFactorisation f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImage f) (CategoryTheory.Limits.image.lift F')) F'.e","decl":"@[reassoc (attr := simp)]\ntheorem image.fac_lift (F' : MonoFactorisation f) : factorThruImage f ‚â´ image.lift F' = F'.e :=\n  (Image.isImage f).fac_lift F'\n\n"}
{"name":"CategoryTheory.Limits.image.fac_lift_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasImage f\nF' : CategoryTheory.Limits.MonoFactorisation f\nZ : C\nh : Quiver.Hom F'.I Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImage f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.lift F') h)) (CategoryTheory.CategoryStruct.comp F'.e h)","decl":"@[reassoc (attr := simp)]\ntheorem image.fac_lift (F' : MonoFactorisation f) : factorThruImage f ‚â´ image.lift F' = F'.e :=\n  (Image.isImage f).fac_lift F'\n\n"}
{"name":"CategoryTheory.Limits.image.isImage_lift","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasImage f\nF : CategoryTheory.Limits.MonoFactorisation f\n‚ä¢ Eq ((CategoryTheory.Limits.Image.isImage f).lift F) (CategoryTheory.Limits.image.lift F)","decl":"@[simp]\ntheorem image.isImage_lift (F : MonoFactorisation f) : (Image.isImage f).lift F = image.lift F :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsImage.lift_Œπ","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasImage f\nF : CategoryTheory.Limits.MonoFactorisation f\nhF : CategoryTheory.Limits.IsImage F\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (hF.lift (CategoryTheory.Limits.Image.monoFactorisation f)) (CategoryTheory.Limits.image.Œπ f)) F.m","decl":"@[reassoc (attr := simp)]\ntheorem IsImage.lift_Œπ {F : MonoFactorisation f} (hF : IsImage F) :\n    hF.lift (Image.monoFactorisation f) ‚â´ image.Œπ f = F.m :=\n  hF.lift_fac _\n\n-- TODO we could put a category structure on `MonoFactorisation f`,\n-- with the morphisms being `g : I ‚ü∂ I'` commuting with the `m`s\n-- (they then automatically commute with the `e`s)\n-- and show that an `imageOf f` gives an initial object there\n-- (uniqueness of the lift comes for free).\n"}
{"name":"CategoryTheory.Limits.IsImage.lift_Œπ_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasImage f\nF : CategoryTheory.Limits.MonoFactorisation f\nhF : CategoryTheory.Limits.IsImage F\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (hF.lift (CategoryTheory.Limits.Image.monoFactorisation f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.Œπ f) h)) (CategoryTheory.CategoryStruct.comp F.m h)","decl":"@[reassoc (attr := simp)]\ntheorem IsImage.lift_Œπ {F : MonoFactorisation f} (hF : IsImage F) :\n    hF.lift (Image.monoFactorisation f) ‚â´ image.Œπ f = F.m :=\n  hF.lift_fac _\n\n-- TODO we could put a category structure on `MonoFactorisation f`,\n-- with the morphisms being `g : I ‚ü∂ I'` commuting with the `m`s\n-- (they then automatically commute with the `e`s)\n-- and show that an `imageOf f` gives an initial object there\n-- (uniqueness of the lift comes for free).\n"}
{"name":"CategoryTheory.Limits.image.lift_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasImage f\nF' : CategoryTheory.Limits.MonoFactorisation f\n‚ä¢ CategoryTheory.Mono (CategoryTheory.Limits.image.lift F')","decl":"instance image.lift_mono (F' : MonoFactorisation f) : Mono (image.lift F') := by\n  refine @mono_of_mono _ _ _ _ _ _ F'.m ?_\n  simpa using MonoFactorisation.m_mono _\n\n"}
{"name":"CategoryTheory.Limits.HasImage.uniq","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasImage f\nF' : CategoryTheory.Limits.MonoFactorisation f\nl : Quiver.Hom (CategoryTheory.Limits.image f) F'.I\nw : Eq (CategoryTheory.CategoryStruct.comp l F'.m) (CategoryTheory.Limits.image.Œπ f)\n‚ä¢ Eq l (CategoryTheory.Limits.image.lift F')","decl":"theorem HasImage.uniq (F' : MonoFactorisation f) (l : image f ‚ü∂ F'.I) (w : l ‚â´ F'.m = image.Œπ f) :\n    l = image.lift F' :=\n  (cancel_mono F'.m).1 (by simp [w])\n\n"}
{"name":"CategoryTheory.Limits.instHasImageCompOfIsIso","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.IsIso f\ng : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.Limits.HasImage g\n‚ä¢ CategoryTheory.Limits.HasImage (CategoryTheory.CategoryStruct.comp f g)","decl":"/-- If `has_image g`, then `has_image (f ‚â´ g)` when `f` is an isomorphism. -/\ninstance {X Y Z : C} (f : X ‚ü∂ Y) [IsIso f] (g : Y ‚ü∂ Z) [HasImage g] : HasImage (f ‚â´ g) where\n  exists_image :=\n    ‚ü®{  F :=\n          { I := image g\n            m := image.Œπ g\n            e := f ‚â´ factorThruImage g }\n        isImage :=\n          { lift := fun F' => image.lift\n                { I := F'.I\n                  m := F'.m\n                  e := inv f ‚â´ F'.e } } }‚ü©\n\n"}
{"name":"CategoryTheory.Limits.HasImages.has_image","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Limits.HasImages C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ CategoryTheory.Limits.HasImage f","decl":"/-- `HasImages` asserts that every morphism has an image. -/\nclass HasImages : Prop where\n  has_image : ‚àÄ {X Y : C} (f : X ‚ü∂ Y), HasImage f\n\n"}
{"name":"CategoryTheory.Limits.imageMonoIsoSource_inv_Œπ","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageMonoIsoSource f).inv (CategoryTheory.Limits.image.Œπ f)) f","decl":"@[reassoc (attr := simp)]\ntheorem imageMonoIsoSource_inv_Œπ [Mono f] : (imageMonoIsoSource f).inv ‚â´ image.Œπ f = f := by\n  simp [imageMonoIsoSource]\n\n"}
{"name":"CategoryTheory.Limits.imageMonoIsoSource_inv_Œπ_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageMonoIsoSource f).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.Œπ f) h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc (attr := simp)]\ntheorem imageMonoIsoSource_inv_Œπ [Mono f] : (imageMonoIsoSource f).inv ‚â´ image.Œπ f = f := by\n  simp [imageMonoIsoSource]\n\n"}
{"name":"CategoryTheory.Limits.imageMonoIsoSource_hom_self","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageMonoIsoSource f).hom f) (CategoryTheory.Limits.image.Œπ f)","decl":"@[reassoc (attr := simp)]\ntheorem imageMonoIsoSource_hom_self [Mono f] : (imageMonoIsoSource f).hom ‚â´ f = image.Œπ f := by\n  simp only [‚Üê imageMonoIsoSource_inv_Œπ f]\n  rw [‚Üê Category.assoc, Iso.hom_inv_id, Category.id_comp]\n\n-- This is the proof that `factorThruImage f` is an epimorphism\n-- from https://en.wikipedia.org/wiki/Image_%28category_theory%29, which is in turn taken from:\n-- Mitchell, Barry (1965), Theory of categories, MR 0202787, p.12, Proposition 10.1\n"}
{"name":"CategoryTheory.Limits.imageMonoIsoSource_hom_self_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.imageMonoIsoSource f).hom (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.Œπ f) h)","decl":"@[reassoc (attr := simp)]\ntheorem imageMonoIsoSource_hom_self [Mono f] : (imageMonoIsoSource f).hom ‚â´ f = image.Œπ f := by\n  simp only [‚Üê imageMonoIsoSource_inv_Œπ f]\n  rw [‚Üê Category.assoc, Iso.hom_inv_id, Category.id_comp]\n\n-- This is the proof that `factorThruImage f` is an epimorphism\n-- from https://en.wikipedia.org/wiki/Image_%28category_theory%29, which is in turn taken from:\n-- Mitchell, Barry (1965), Theory of categories, MR 0202787, p.12, Proposition 10.1\n"}
{"name":"CategoryTheory.Limits.image.ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasImage f\nW : C\ng h : Quiver.Hom (CategoryTheory.Limits.image f) W\ninst‚úù : CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.parallelPair g h)\nw : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImage f) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImage f) h)\n‚ä¢ Eq g h","decl":"@[ext (iff := false)]\ntheorem image.ext [HasImage f] {W : C} {g h : image f ‚ü∂ W} [HasLimit (parallelPair g h)]\n    (w : factorThruImage f ‚â´ g = factorThruImage f ‚â´ h) : g = h := by\n  let q := equalizer.Œπ g h\n  let e' := equalizer.lift _ w\n  let F' : MonoFactorisation f :=\n    { I := equalizer g h\n      m := q ‚â´ image.Œπ f\n      m_mono := mono_comp _ _\n      e := e' }\n  let v := image.lift F'\n  have t‚ÇÄ : v ‚â´ q ‚â´ image.Œπ f = image.Œπ f := image.lift_fac F'\n  have t : v ‚â´ q = ùüô (image f) :=\n    (cancel_mono_id (image.Œπ f)).1\n      (by\n        convert t‚ÇÄ using 1\n        rw [Category.assoc])\n  -- The proof from wikipedia next proves `q ‚â´ v = ùüô _`,\n  -- and concludes that `equalizer g h ‚âÖ image f`,\n  -- but this isn't necessary.\n  calc\n    g = ùüô (image f) ‚â´ g := by rw [Category.id_comp]\n    _ = v ‚â´ q ‚â´ g := by rw [‚Üê t, Category.assoc]\n    _ = v ‚â´ q ‚â´ h := by rw [equalizer.condition g h]\n    _ = ùüô (image f) ‚â´ h := by rw [‚Üê Category.assoc, t]\n    _ = h := by rw [Category.id_comp]\n\n"}
{"name":"CategoryTheory.Limits.instEpiFactorThruImageOfHasLimitWalkingParallelPairParallelPair","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasImage f\ninst‚úù : ‚àÄ {Z : C} (g h : Quiver.Hom (CategoryTheory.Limits.image f) Z), CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.parallelPair g h)\n‚ä¢ CategoryTheory.Epi (CategoryTheory.Limits.factorThruImage f)","decl":"instance [HasImage f] [‚àÄ {Z : C} (g h : image f ‚ü∂ Z), HasLimit (parallelPair g h)] :\n    Epi (factorThruImage f) :=\n  ‚ü®fun _ _ w => image.ext f w‚ü©\n\n"}
{"name":"CategoryTheory.Limits.epi_image_of_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasImage f\nE : CategoryTheory.Epi f\n‚ä¢ CategoryTheory.Epi (CategoryTheory.Limits.image.Œπ f)","decl":"theorem epi_image_of_epi {X Y : C} (f : X ‚ü∂ Y) [HasImage f] [E : Epi f] : Epi (image.Œπ f) := by\n  rw [‚Üê image.fac f] at E\n  exact epi_of_epi (factorThruImage f) (image.Œπ f)\n\n"}
{"name":"CategoryTheory.Limits.epi_of_epi_image","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù¬≤ : CategoryTheory.Limits.HasImage f\ninst‚úù¬π : CategoryTheory.Epi (CategoryTheory.Limits.image.Œπ f)\ninst‚úù : CategoryTheory.Epi (CategoryTheory.Limits.factorThruImage f)\n‚ä¢ CategoryTheory.Epi f","decl":"theorem epi_of_epi_image {X Y : C} (f : X ‚ü∂ Y) [HasImage f] [Epi (image.Œπ f)]\n    [Epi (factorThruImage f)] : Epi f := by\n  rw [‚Üê image.fac f]\n  apply epi_comp\n\n"}
{"name":"CategoryTheory.Limits.instIsIsoEqToHom","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf f' : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasImage f\ninst‚úù : CategoryTheory.Limits.HasImage f'\nh : Eq f f'\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.image.eqToHom h)","decl":"instance (h : f = f') : IsIso (image.eqToHom h) :=\n  ‚ü®‚ü®image.eqToHom h.symm,\n      ‚ü®(cancel_mono (image.Œπ f)).1 (by\n          -- Porting note: added let's for used to be a simp [image.eqToHom]\n          let F : MonoFactorisation f' :=\n            ‚ü®image f, image.Œπ f, factorThruImage f, (by aesop_cat)‚ü©\n          dsimp [image.eqToHom]\n          rw [Category.id_comp,Category.assoc,image.lift_fac F]\n          let F' : MonoFactorisation f :=\n            ‚ü®image f', image.Œπ f', factorThruImage f', (by aesop_cat)‚ü©\n          rw [image.lift_fac F'] ),\n        (cancel_mono (image.Œπ f')).1 (by\n          -- Porting note: added let's for used to be a simp [image.eqToHom]\n          let F' : MonoFactorisation f :=\n            ‚ü®image f', image.Œπ f', factorThruImage f', (by aesop_cat)‚ü©\n          dsimp [image.eqToHom]\n          rw [Category.id_comp,Category.assoc,image.lift_fac F']\n          let F : MonoFactorisation f' :=\n            ‚ü®image f, image.Œπ f, factorThruImage f, (by aesop_cat)‚ü©\n          rw [image.lift_fac F])‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.image.eq_fac","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\nf f' : Quiver.Hom X Y\ninst‚úù¬≤ : CategoryTheory.Limits.HasImage f\ninst‚úù¬π : CategoryTheory.Limits.HasImage f'\ninst‚úù : CategoryTheory.Limits.HasEqualizers C\nh : Eq f f'\n‚ä¢ Eq (CategoryTheory.Limits.image.Œπ f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.eqToIso h).hom (CategoryTheory.Limits.image.Œπ f'))","decl":"/-- As long as the category has equalizers,\nthe image inclusion maps commute with `image.eqToIso`.\n-/\ntheorem image.eq_fac [HasEqualizers C] (h : f = f') :\n    image.Œπ f = (image.eqToIso h).hom ‚â´ image.Œπ f' := by\n  apply image.ext\n  dsimp [asIso,image.eqToIso, image.eqToHom]\n  rw [image.lift_fac] -- Porting note: simp did not fire with this it seems\n\n"}
{"name":"CategoryTheory.Limits.image.preComp_Œπ_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nZ‚úù : C\ng : Quiver.Hom Y Z‚úù\ninst‚úù¬π : CategoryTheory.Limits.HasImage g\ninst‚úù : CategoryTheory.Limits.HasImage (CategoryTheory.CategoryStruct.comp f g)\nZ : C\nh : Quiver.Hom Z‚úù Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.preComp f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.Œπ g) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.Œπ (CategoryTheory.CategoryStruct.comp f g)) h)","decl":"@[reassoc (attr := simp)]\ntheorem image.preComp_Œπ [HasImage g] [HasImage (f ‚â´ g)] :\n    image.preComp f g ‚â´ image.Œπ g = image.Œπ (f ‚â´ g) := by\n      dsimp [image.preComp]\n      rw [image.lift_fac] -- Porting note: also here, see image.eq_fac\n\n"}
{"name":"CategoryTheory.Limits.image.preComp_Œπ","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\ng : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.Limits.HasImage g\ninst‚úù : CategoryTheory.Limits.HasImage (CategoryTheory.CategoryStruct.comp f g)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.preComp f g) (CategoryTheory.Limits.image.Œπ g)) (CategoryTheory.Limits.image.Œπ (CategoryTheory.CategoryStruct.comp f g))","decl":"@[reassoc (attr := simp)]\ntheorem image.preComp_Œπ [HasImage g] [HasImage (f ‚â´ g)] :\n    image.preComp f g ‚â´ image.Œπ g = image.Œπ (f ‚â´ g) := by\n      dsimp [image.preComp]\n      rw [image.lift_fac] -- Porting note: also here, see image.eq_fac\n\n"}
{"name":"CategoryTheory.Limits.image.factorThruImage_preComp","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\ng : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.Limits.HasImage g\ninst‚úù : CategoryTheory.Limits.HasImage (CategoryTheory.CategoryStruct.comp f g)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImage (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.Limits.image.preComp f g)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.factorThruImage g))","decl":"@[reassoc (attr := simp)]\ntheorem image.factorThruImage_preComp [HasImage g] [HasImage (f ‚â´ g)] :\n    factorThruImage (f ‚â´ g) ‚â´ image.preComp f g = f ‚â´ factorThruImage g := by simp [image.preComp]\n\n"}
{"name":"CategoryTheory.Limits.image.factorThruImage_preComp_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nZ‚úù : C\ng : Quiver.Hom Y Z‚úù\ninst‚úù¬π : CategoryTheory.Limits.HasImage g\ninst‚úù : CategoryTheory.Limits.HasImage (CategoryTheory.CategoryStruct.comp f g)\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.image g) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImage (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.preComp f g) h)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImage g) h))","decl":"@[reassoc (attr := simp)]\ntheorem image.factorThruImage_preComp [HasImage g] [HasImage (f ‚â´ g)] :\n    factorThruImage (f ‚â´ g) ‚â´ image.preComp f g = f ‚â´ factorThruImage g := by simp [image.preComp]\n\n"}
{"name":"CategoryTheory.Limits.image.preComp_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\ng : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.Limits.HasImage g\ninst‚úù : CategoryTheory.Limits.HasImage (CategoryTheory.CategoryStruct.comp f g)\n‚ä¢ CategoryTheory.Mono (CategoryTheory.Limits.image.preComp f g)","decl":"/-- `image.preComp f g` is a monomorphism.\n-/\ninstance image.preComp_mono [HasImage g] [HasImage (f ‚â´ g)] : Mono (image.preComp f g) := by\n  refine @mono_of_mono _ _ _ _ _ _ (image.Œπ g) ?_\n  simp only [image.preComp_Œπ]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.image.preComp_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\ng : Quiver.Hom Y Z\nW : C\nh : Quiver.Hom Z W\ninst‚úù¬≥ : CategoryTheory.Limits.HasImage (CategoryTheory.CategoryStruct.comp g h)\ninst‚úù¬≤ : CategoryTheory.Limits.HasImage (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp g h))\ninst‚úù¬π : CategoryTheory.Limits.HasImage h\ninst‚úù : CategoryTheory.Limits.HasImage (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g) h)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.preComp f (CategoryTheory.CategoryStruct.comp g h)) (CategoryTheory.Limits.image.preComp g h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.eqToHom ‚ãØ) (CategoryTheory.Limits.image.preComp (CategoryTheory.CategoryStruct.comp f g) h))","decl":"/-- The two step comparison map\n  `image (f ‚â´ (g ‚â´ h)) ‚ü∂ image (g ‚â´ h) ‚ü∂ image h`\nagrees with the one step comparison map\n  `image (f ‚â´ (g ‚â´ h)) ‚âÖ image ((f ‚â´ g) ‚â´ h) ‚ü∂ image h`.\n -/\ntheorem image.preComp_comp {W : C} (h : Z ‚ü∂ W) [HasImage (g ‚â´ h)] [HasImage (f ‚â´ g ‚â´ h)]\n    [HasImage h] [HasImage ((f ‚â´ g) ‚â´ h)] :\n    image.preComp f (g ‚â´ h) ‚â´ image.preComp g h =\n      image.eqToHom (Category.assoc f g h).symm ‚â´ image.preComp (f ‚â´ g) h := by\n  apply (cancel_mono (image.Œπ h)).1\n  dsimp [image.preComp, image.eqToHom]\n  repeat (rw [Category.assoc,image.lift_fac])\n  rw [image.lift_fac,image.lift_fac]\n\n"}
{"name":"CategoryTheory.Limits.image.preComp_epi_of_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\ng : Quiver.Hom Y Z\ninst‚úù¬≤ : CategoryTheory.Limits.HasImage g\ninst‚úù¬π : CategoryTheory.Limits.HasImage (CategoryTheory.CategoryStruct.comp f g)\ninst‚úù : CategoryTheory.Epi f\n‚ä¢ CategoryTheory.Epi (CategoryTheory.Limits.image.preComp f g)","decl":"/-- `image.preComp f g` is an epimorphism when `f` is an epimorphism\n(we need `C` to have equalizers to prove this).\n-/\ninstance image.preComp_epi_of_epi [HasImage g] [HasImage (f ‚â´ g)] [Epi f] :\n    Epi (image.preComp f g) := by\n  apply @epi_of_epi_fac _ _ _ _ _ _ _ _ ?_ (image.factorThruImage_preComp _ _)\n  exact epi_comp _ _\n\n"}
{"name":"CategoryTheory.Limits.hasImage_iso_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\ng : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.IsIso f\ninst‚úù : CategoryTheory.Limits.HasImage g\n‚ä¢ CategoryTheory.Limits.HasImage (CategoryTheory.CategoryStruct.comp f g)","decl":"instance hasImage_iso_comp [IsIso f] [HasImage g] : HasImage (f ‚â´ g) :=\n  HasImage.mk\n    { F := (Image.monoFactorisation g).isoComp f\n      isImage := { lift := fun F' => image.lift (F'.ofIsoComp f)\n                   lift_fac := fun F' => by\n                    dsimp\n                    have : (MonoFactorisation.ofIsoComp f F').m = F'.m := rfl\n                    rw [‚Üê this,image.lift_fac (MonoFactorisation.ofIsoComp f F')] } }\n\n"}
{"name":"CategoryTheory.Limits.image.isIso_precomp_iso","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y Z : C\ng : Quiver.Hom Y Z\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.IsIso f\ninst‚úù : CategoryTheory.Limits.HasImage g\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.image.preComp f g)","decl":"/-- `image.preComp f g` is an isomorphism when `f` is an isomorphism\n(we need `C` to have equalizers to prove this).\n-/\ninstance image.isIso_precomp_iso (f : X ‚ü∂ Y) [IsIso f] [HasImage g] : IsIso (image.preComp f g) :=\n  ‚ü®‚ü®image.lift\n        { I := image (f ‚â´ g)\n          m := image.Œπ (f ‚â´ g)\n          e := inv f ‚â´ factorThruImage (f ‚â´ g) },\n      ‚ü®by\n        ext\n        simp [image.preComp], by\n        ext\n        simp [image.preComp]‚ü©‚ü©‚ü©\n\n-- Note that in general we don't have the other comparison map you might expect\n-- `image f ‚ü∂ image (f ‚â´ g)`.\n"}
{"name":"CategoryTheory.Limits.hasImage_comp_iso","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\ng : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.Limits.HasImage f\ninst‚úù : CategoryTheory.IsIso g\n‚ä¢ CategoryTheory.Limits.HasImage (CategoryTheory.CategoryStruct.comp f g)","decl":"instance hasImage_comp_iso [HasImage f] [IsIso g] : HasImage (f ‚â´ g) :=\n  HasImage.mk\n    { F := (Image.monoFactorisation f).compMono g\n      isImage :=\n      { lift := fun F' => image.lift F'.ofCompIso\n        lift_fac := fun F' => by\n          rw [‚Üê Category.comp_id (image.lift (MonoFactorisation.ofCompIso F') ‚â´ F'.m),\n            ‚Üê IsIso.inv_hom_id g,‚Üê Category.assoc]\n          refine congrArg (¬∑ ‚â´ g) ?_\n          have : (image.lift (MonoFactorisation.ofCompIso F') ‚â´ F'.m) ‚â´ inv g =\n            image.lift (MonoFactorisation.ofCompIso F') ‚â´\n            ((MonoFactorisation.ofCompIso F').m) := by\n              simp only [MonoFactorisation.ofCompIso_I, Category.assoc,\n                MonoFactorisation.ofCompIso_m]\n          rw [this, image.lift_fac (MonoFactorisation.ofCompIso F'),image.as_Œπ] }}\n\n"}
{"name":"CategoryTheory.Limits.image.compIso_hom_comp_image_Œπ","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\ng : Quiver.Hom Y Z\ninst‚úù¬≤ : CategoryTheory.Limits.HasEqualizers C\ninst‚úù¬π : CategoryTheory.Limits.HasImage f\ninst‚úù : CategoryTheory.IsIso g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.compIso f g).hom (CategoryTheory.Limits.image.Œπ (CategoryTheory.CategoryStruct.comp f g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.Œπ f) g)","decl":"@[reassoc (attr := simp)]\ntheorem image.compIso_hom_comp_image_Œπ [HasImage f] [IsIso g] :\n    (image.compIso f g).hom ‚â´ image.Œπ (f ‚â´ g) = image.Œπ f ‚â´ g := by\n  ext\n  simp [image.compIso]\n\n"}
{"name":"CategoryTheory.Limits.image.compIso_hom_comp_image_Œπ_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nZ‚úù : C\ng : Quiver.Hom Y Z‚úù\ninst‚úù¬≤ : CategoryTheory.Limits.HasEqualizers C\ninst‚úù¬π : CategoryTheory.Limits.HasImage f\ninst‚úù : CategoryTheory.IsIso g\nZ : C\nh : Quiver.Hom Z‚úù Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.compIso f g).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.Œπ (CategoryTheory.CategoryStruct.comp f g)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.Œπ f) (CategoryTheory.CategoryStruct.comp g h))","decl":"@[reassoc (attr := simp)]\ntheorem image.compIso_hom_comp_image_Œπ [HasImage f] [IsIso g] :\n    (image.compIso f g).hom ‚â´ image.Œπ (f ‚â´ g) = image.Œπ f ‚â´ g := by\n  ext\n  simp [image.compIso]\n\n"}
{"name":"CategoryTheory.Limits.image.compIso_inv_comp_image_Œπ","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\ng : Quiver.Hom Y Z\ninst‚úù¬≤ : CategoryTheory.Limits.HasEqualizers C\ninst‚úù¬π : CategoryTheory.Limits.HasImage f\ninst‚úù : CategoryTheory.IsIso g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.compIso f g).inv (CategoryTheory.Limits.image.Œπ f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.Œπ (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.inv g))","decl":"@[reassoc (attr := simp)]\ntheorem image.compIso_inv_comp_image_Œπ [HasImage f] [IsIso g] :\n    (image.compIso f g).inv ‚â´ image.Œπ f = image.Œπ (f ‚â´ g) ‚â´ inv g := by\n  ext\n  simp [image.compIso]\n\n"}
{"name":"CategoryTheory.Limits.image.compIso_inv_comp_image_Œπ_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nZ‚úù : C\ng : Quiver.Hom Y Z‚úù\ninst‚úù¬≤ : CategoryTheory.Limits.HasEqualizers C\ninst‚úù¬π : CategoryTheory.Limits.HasImage f\ninst‚úù : CategoryTheory.IsIso g\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.compIso f g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.Œπ f) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.Œπ (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv g) h))","decl":"@[reassoc (attr := simp)]\ntheorem image.compIso_inv_comp_image_Œπ [HasImage f] [IsIso g] :\n    (image.compIso f g).inv ‚â´ image.Œπ f = image.Œπ (f ‚â´ g) ‚â´ inv g := by\n  ext\n  simp [image.compIso]\n\n"}
{"name":"CategoryTheory.Limits.instHasImageHomMk","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasImage f\n‚ä¢ CategoryTheory.Limits.HasImage (CategoryTheory.Arrow.mk f).hom","decl":"instance {X Y : C} (f : X ‚ü∂ Y) [HasImage f] : HasImage (Arrow.mk f).hom :=\n  show HasImage f by infer_instance\n\n"}
{"name":"CategoryTheory.Limits.ImageMap.map_Œπ","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst‚úù¬π : CategoryTheory.Limits.HasImage f.hom\ninst‚úù : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\nself : CategoryTheory.Limits.ImageMap sq\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.map (CategoryTheory.Limits.image.Œπ g.hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.Œπ f.hom) sq.right)","decl":"set_option genInjectivity false in\n/-- An image map is a morphism `image f ‚Üí image g` fitting into a commutative square and satisfying\n    the obvious commutativity conditions. -/\nstructure ImageMap {f g : Arrow C} [HasImage f.hom] [HasImage g.hom] (sq : f ‚ü∂ g) where\n  map : image f.hom ‚ü∂ image g.hom\n  map_Œπ : map ‚â´ image.Œπ g.hom = image.Œπ f.hom ‚â´ sq.right := by aesop\n\n"}
{"name":"CategoryTheory.Limits.ImageMap.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst‚úù¬≤ : CategoryTheory.Limits.HasImage f.hom\ninst‚úù¬π : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\ninst‚úù : SizeOf C\nmap : Quiver.Hom (CategoryTheory.Limits.image f.hom) (CategoryTheory.Limits.image g.hom)\nmap_Œπ : autoParam (Eq (CategoryTheory.CategoryStruct.comp map (CategoryTheory.Limits.image.Œπ g.hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.Œπ f.hom) sq.right)) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { map := map, map_Œπ := map_Œπ }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf map)) (SizeOf.sizeOf map_Œπ))","decl":"set_option genInjectivity false in\n/-- An image map is a morphism `image f ‚Üí image g` fitting into a commutative square and satisfying\n    the obvious commutativity conditions. -/\nstructure ImageMap {f g : Arrow C} [HasImage f.hom] [HasImage g.hom] (sq : f ‚ü∂ g) where\n  map : image f.hom ‚ü∂ image g.hom\n  map_Œπ : map ‚â´ image.Œπ g.hom = image.Œπ f.hom ‚â´ sq.right := by aesop\n\n"}
{"name":"CategoryTheory.Limits.ImageMap.map_Œπ_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst‚úù¬π : CategoryTheory.Limits.HasImage f.hom\ninst‚úù : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\nself : CategoryTheory.Limits.ImageMap sq\nZ : C\nh : Quiver.Hom g.right Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.map (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.Œπ g.hom) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.Œπ f.hom) (CategoryTheory.CategoryStruct.comp sq.right h))","decl":"attribute [reassoc (attr := simp)] ImageMap.map_Œπ\n\n"}
{"name":"CategoryTheory.Limits.ImageMap.factor_map_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst‚úù¬π : CategoryTheory.Limits.HasImage f.hom\ninst‚úù : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\nm : CategoryTheory.Limits.ImageMap sq\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.image g.hom) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImage f.hom) (CategoryTheory.CategoryStruct.comp m.map h)) (CategoryTheory.CategoryStruct.comp sq.left (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImage g.hom) h))","decl":"@[reassoc (attr := simp)]\ntheorem ImageMap.factor_map {f g : Arrow C} [HasImage f.hom] [HasImage g.hom] (sq : f ‚ü∂ g)\n    (m : ImageMap sq) : factorThruImage f.hom ‚â´ m.map = sq.left ‚â´ factorThruImage g.hom :=\n  (cancel_mono (image.Œπ g.hom)).1 <| by simp\n\n"}
{"name":"CategoryTheory.Limits.ImageMap.factor_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst‚úù¬π : CategoryTheory.Limits.HasImage f.hom\ninst‚úù : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\nm : CategoryTheory.Limits.ImageMap sq\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImage f.hom) m.map) (CategoryTheory.CategoryStruct.comp sq.left (CategoryTheory.Limits.factorThruImage g.hom))","decl":"@[reassoc (attr := simp)]\ntheorem ImageMap.factor_map {f g : Arrow C} [HasImage f.hom] [HasImage g.hom] (sq : f ‚ü∂ g)\n    (m : ImageMap sq) : factorThruImage f.hom ‚â´ m.map = sq.left ‚â´ factorThruImage g.hom :=\n  (cancel_mono (image.Œπ g.hom)).1 <| by simp\n\n"}
{"name":"CategoryTheory.Limits.HasImageMap.has_image_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst‚úù¬π : CategoryTheory.Limits.HasImage f.hom\ninst‚úù : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\nself : CategoryTheory.Limits.HasImageMap sq\n‚ä¢ Nonempty (CategoryTheory.Limits.ImageMap sq)","decl":"/-- `HasImageMap sq` means that there is an `ImageMap` for the square `sq`. -/\nclass HasImageMap {f g : Arrow C} [HasImage f.hom] [HasImage g.hom] (sq : f ‚ü∂ g) : Prop where\nmk' ::\n  has_image_map : Nonempty (ImageMap sq)\n\n"}
{"name":"CategoryTheory.Limits.HasImageMap.mk","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst‚úù¬π : CategoryTheory.Limits.HasImage f.hom\ninst‚úù : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\nm : CategoryTheory.Limits.ImageMap sq\n‚ä¢ CategoryTheory.Limits.HasImageMap sq","decl":"theorem HasImageMap.mk {f g : Arrow C} [HasImage f.hom] [HasImage g.hom] {sq : f ‚ü∂ g}\n    (m : ImageMap sq) : HasImageMap sq :=\n  ‚ü®Nonempty.intro m‚ü©\n\n"}
{"name":"CategoryTheory.Limits.HasImageMap.transport","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst‚úù¬π : CategoryTheory.Limits.HasImage f.hom\ninst‚úù : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\nF : CategoryTheory.Limits.MonoFactorisation f.hom\nF' : CategoryTheory.Limits.MonoFactorisation g.hom\nhF' : CategoryTheory.Limits.IsImage F'\nmap : Quiver.Hom F.I F'.I\nmap_Œπ : Eq (CategoryTheory.CategoryStruct.comp map F'.m) (CategoryTheory.CategoryStruct.comp F.m sq.right)\n‚ä¢ CategoryTheory.Limits.HasImageMap sq","decl":"theorem HasImageMap.transport {f g : Arrow C} [HasImage f.hom] [HasImage g.hom] (sq : f ‚ü∂ g)\n    (F : MonoFactorisation f.hom) {F' : MonoFactorisation g.hom} (hF' : IsImage F')\n    (map : F.I ‚ü∂ F'.I) (map_Œπ : map ‚â´ F'.m = F.m ‚â´ sq.right) : HasImageMap sq :=\n  HasImageMap.mk <| ImageMap.transport sq F hF' map_Œπ\n\n"}
{"name":"CategoryTheory.Limits.hasImageMapOfIsIso","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst‚úù¬≤ : CategoryTheory.Limits.HasImage f.hom\ninst‚úù¬π : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\ninst‚úù : CategoryTheory.IsIso sq\n‚ä¢ CategoryTheory.Limits.HasImageMap sq","decl":"instance (priority := 100) hasImageMapOfIsIso {f g : Arrow C} [HasImage f.hom] [HasImage g.hom]\n    (sq : f ‚ü∂ g) [IsIso sq] : HasImageMap sq :=\n  HasImageMap.mk\n    { map := image.lift ((Image.monoFactorisation g.hom).ofArrowIso (inv sq))\n      map_Œπ := by\n        erw [‚Üê cancel_mono (inv sq).right, Category.assoc, ‚Üê MonoFactorisation.ofArrowIso_m,\n          image.lift_fac, Category.assoc, ‚Üê Comma.comp_right, IsIso.hom_inv_id, Comma.id_right,\n          Category.comp_id] }\n\n"}
{"name":"CategoryTheory.Limits.HasImageMap.comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nf g h : CategoryTheory.Arrow C\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasImage f.hom\ninst‚úù¬≥ : CategoryTheory.Limits.HasImage g.hom\ninst‚úù¬≤ : CategoryTheory.Limits.HasImage h.hom\nsq1 : Quiver.Hom f g\nsq2 : Quiver.Hom g h\ninst‚úù¬π : CategoryTheory.Limits.HasImageMap sq1\ninst‚úù : CategoryTheory.Limits.HasImageMap sq2\n‚ä¢ CategoryTheory.Limits.HasImageMap (CategoryTheory.CategoryStruct.comp sq1 sq2)","decl":"instance HasImageMap.comp {f g h : Arrow C} [HasImage f.hom] [HasImage g.hom] [HasImage h.hom]\n    (sq1 : f ‚ü∂ g) (sq2 : g ‚ü∂ h) [HasImageMap sq1] [HasImageMap sq2] : HasImageMap (sq1 ‚â´ sq2) :=\n  HasImageMap.mk\n    { map := (HasImageMap.imageMap sq1).map ‚â´ (HasImageMap.imageMap sq2).map\n      map_Œπ := by\n        rw [Category.assoc,ImageMap.map_Œπ, ImageMap.map_Œπ_assoc, Comma.comp_right] }\n\n"}
{"name":"CategoryTheory.Limits.ImageMap.ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst‚úù¬π : CategoryTheory.Limits.HasImage f.hom\ninst‚úù : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\nx y : CategoryTheory.Limits.ImageMap sq\nmap : Eq x.map y.map\n‚ä¢ Eq x y","decl":"attribute [local ext] ImageMap\n\n/- Porting note: ImageMap.mk.injEq has LHS simplify to True due to the next instance\nWe make a replacement -/\n"}
{"name":"CategoryTheory.Limits.ImageMap.ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst‚úù¬π : CategoryTheory.Limits.HasImage f.hom\ninst‚úù : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\nx y : CategoryTheory.Limits.ImageMap sq\n‚ä¢ Iff (Eq x y) (Eq x.map y.map)","decl":"attribute [local ext] ImageMap\n\n/- Porting note: ImageMap.mk.injEq has LHS simplify to True due to the next instance\nWe make a replacement -/\n"}
{"name":"CategoryTheory.Limits.ImageMap.map_uniq_aux","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst‚úù¬π : CategoryTheory.Limits.HasImage f.hom\ninst‚úù : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\nmap : Quiver.Hom (CategoryTheory.Limits.image f.hom) (CategoryTheory.Limits.image g.hom)\nmap_Œπ : autoParam (Eq (CategoryTheory.CategoryStruct.comp map (CategoryTheory.Limits.image.Œπ g.hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.Œπ f.hom) sq.right)) _auto‚úù\nmap' : Quiver.Hom (CategoryTheory.Limits.image f.hom) (CategoryTheory.Limits.image g.hom)\nmap_Œπ' : Eq (CategoryTheory.CategoryStruct.comp map' (CategoryTheory.Limits.image.Œπ g.hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.Œπ f.hom) sq.right)\n‚ä¢ Eq map map'","decl":"theorem ImageMap.map_uniq_aux {f g : Arrow C} [HasImage f.hom] [HasImage g.hom] {sq : f ‚ü∂ g}\n    (map : image f.hom ‚ü∂ image g.hom)\n    (map_Œπ : map ‚â´ image.Œπ g.hom = image.Œπ f.hom ‚â´ sq.right := by aesop_cat)\n    (map' : image f.hom ‚ü∂ image g.hom)\n    (map_Œπ' : map' ‚â´ image.Œπ g.hom = image.Œπ f.hom ‚â´ sq.right) : (map = map') := by\n  have : map ‚â´ image.Œπ g.hom = map' ‚â´ image.Œπ g.hom := by rw [map_Œπ,map_Œπ']\n  apply (cancel_mono (image.Œπ g.hom)).1 this\n\n-- Porting note: added to get variant on ImageMap.mk.injEq below\n"}
{"name":"CategoryTheory.Limits.ImageMap.map_uniq","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst‚úù¬π : CategoryTheory.Limits.HasImage f.hom\ninst‚úù : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\nF G : CategoryTheory.Limits.ImageMap sq\n‚ä¢ Eq F.map G.map","decl":"theorem ImageMap.map_uniq {f g : Arrow C} [HasImage f.hom] [HasImage g.hom]\n    {sq : f ‚ü∂ g} (F G : ImageMap sq) : F.map = G.map := by\n  apply ImageMap.map_uniq_aux _ F.map_Œπ _ G.map_Œπ\n\n"}
{"name":"CategoryTheory.Limits.ImageMap.mk.injEq'","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst‚úù¬π : CategoryTheory.Limits.HasImage f.hom\ninst‚úù : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\nmap : Quiver.Hom (CategoryTheory.Limits.image f.hom) (CategoryTheory.Limits.image g.hom)\nmap_Œπ : autoParam (Eq (CategoryTheory.CategoryStruct.comp map (CategoryTheory.Limits.image.Œπ g.hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.Œπ f.hom) sq.right)) _auto‚úù\nmap' : Quiver.Hom (CategoryTheory.Limits.image f.hom) (CategoryTheory.Limits.image g.hom)\nmap_Œπ' : Eq (CategoryTheory.CategoryStruct.comp map' (CategoryTheory.Limits.image.Œπ g.hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.Œπ f.hom) sq.right)\n‚ä¢ Eq (Eq map map') True","decl":"@[simp]\ntheorem ImageMap.mk.injEq' {f g : Arrow C} [HasImage f.hom] [HasImage g.hom] {sq : f ‚ü∂ g}\n    (map : image f.hom ‚ü∂ image g.hom)\n    (map_Œπ : map ‚â´ image.Œπ g.hom = image.Œπ f.hom ‚â´ sq.right := by aesop_cat)\n    (map' : image f.hom ‚ü∂ image g.hom)\n    (map_Œπ' : map' ‚â´ image.Œπ g.hom = image.Œπ f.hom ‚â´ sq.right) : (map = map') = True := by\n  simp only [Functor.id_obj, eq_iff_iff, iff_true]\n  apply ImageMap.map_uniq_aux _ map_Œπ _ map_Œπ'\n\n"}
{"name":"CategoryTheory.Limits.instSubsingletonImageMap","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst‚úù¬π : CategoryTheory.Limits.HasImage f.hom\ninst‚úù : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\n‚ä¢ Subsingleton (CategoryTheory.Limits.ImageMap sq)","decl":"instance : Subsingleton (ImageMap sq) :=\n  Subsingleton.intro fun a b =>\n    ImageMap.ext <| ImageMap.map_uniq a b\n\n"}
{"name":"CategoryTheory.Limits.image.factor_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst‚úù¬≤ : CategoryTheory.Limits.HasImage f.hom\ninst‚úù¬π : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\ninst‚úù : CategoryTheory.Limits.HasImageMap sq\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImage f.hom) (CategoryTheory.Limits.image.map sq)) (CategoryTheory.CategoryStruct.comp sq.left (CategoryTheory.Limits.factorThruImage g.hom))","decl":"theorem image.factor_map :\n    factorThruImage f.hom ‚â´ image.map sq = sq.left ‚â´ factorThruImage g.hom := by simp\n\n"}
{"name":"CategoryTheory.Limits.image.map_Œπ","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst‚úù¬≤ : CategoryTheory.Limits.HasImage f.hom\ninst‚úù¬π : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\ninst‚úù : CategoryTheory.Limits.HasImageMap sq\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.map sq) (CategoryTheory.Limits.image.Œπ g.hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.Œπ f.hom) sq.right)","decl":"theorem image.map_Œπ : image.map sq ‚â´ image.Œπ g.hom = image.Œπ f.hom ‚â´ sq.right := by simp\n\n"}
{"name":"CategoryTheory.Limits.image.map_homMk'_Œπ","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y P Q : C\nk : Quiver.Hom X Y\ninst‚úù¬≤ : CategoryTheory.Limits.HasImage k\nl : Quiver.Hom P Q\ninst‚úù¬π : CategoryTheory.Limits.HasImage l\nm : Quiver.Hom X P\nn : Quiver.Hom Y Q\nw : Eq (CategoryTheory.CategoryStruct.comp m l) (CategoryTheory.CategoryStruct.comp k n)\ninst‚úù : CategoryTheory.Limits.HasImageMap (CategoryTheory.Arrow.homMk' m n w)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.map (CategoryTheory.Arrow.homMk' m n w)) (CategoryTheory.Limits.image.Œπ l)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.Œπ k) n)","decl":"theorem image.map_homMk'_Œπ {X Y P Q : C} {k : X ‚ü∂ Y} [HasImage k] {l : P ‚ü∂ Q} [HasImage l]\n    {m : X ‚ü∂ P} {n : Y ‚ü∂ Q} (w : m ‚â´ l = k ‚â´ n) [HasImageMap (Arrow.homMk' _ _ w)] :\n    image.map (Arrow.homMk' _ _ w) ‚â´ image.Œπ l = image.Œπ k ‚â´ n :=\n  image.map_Œπ _\n\n"}
{"name":"CategoryTheory.Limits.image.map_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nf g : CategoryTheory.Arrow C\ninst‚úù‚Åµ : CategoryTheory.Limits.HasImage f.hom\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasImage g.hom\nsq : Quiver.Hom f g\ninst‚úù¬≥ : CategoryTheory.Limits.HasImageMap sq\nh : CategoryTheory.Arrow C\ninst‚úù¬≤ : CategoryTheory.Limits.HasImage h.hom\nsq' : Quiver.Hom g h\ninst‚úù¬π : CategoryTheory.Limits.HasImageMap sq'\ninst‚úù : CategoryTheory.Limits.HasImageMap (CategoryTheory.CategoryStruct.comp sq sq')\n‚ä¢ Eq (CategoryTheory.Limits.image.map (CategoryTheory.CategoryStruct.comp sq sq')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.map sq) (CategoryTheory.Limits.image.map sq'))","decl":"@[simp]\ntheorem image.map_comp [HasImageMap (sq ‚â´ sq')] :\n    image.map (sq ‚â´ sq') = image.map sq ‚â´ image.map sq' :=\n  show (HasImageMap.imageMap (sq ‚â´ sq')).map = (imageMapComp sq sq').map by\n    congr; simp only [eq_iff_true_of_subsingleton]\n\n"}
{"name":"CategoryTheory.Limits.image.map_id","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nf : CategoryTheory.Arrow C\ninst‚úù¬π : CategoryTheory.Limits.HasImage f.hom\ninst‚úù : CategoryTheory.Limits.HasImageMap (CategoryTheory.CategoryStruct.id f)\n‚ä¢ Eq (CategoryTheory.Limits.image.map (CategoryTheory.CategoryStruct.id f)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.image f.hom))","decl":"@[simp]\ntheorem image.map_id [HasImageMap (ùüô f)] : image.map (ùüô f) = ùüô (image f.hom) :=\n  show (HasImageMap.imageMap (ùüô f)).map = (imageMapId f).map by\n    congr; simp only [eq_iff_true_of_subsingleton]\n\n"}
{"name":"CategoryTheory.Limits.HasImageMaps.has_image_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasImages C\nself : CategoryTheory.Limits.HasImageMaps C\nf g : CategoryTheory.Arrow C\nst : Quiver.Hom f g\n‚ä¢ CategoryTheory.Limits.HasImageMap st","decl":"/-- If a category `has_image_maps`, then all commutative squares induce morphisms on images. -/\nclass HasImageMaps : Prop where\n  has_image_map : ‚àÄ {f g : Arrow C} (st : f ‚ü∂ g), HasImageMap st\n\n"}
{"name":"CategoryTheory.Limits.im_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasImages C\ninst‚úù : CategoryTheory.Limits.HasImageMaps C\nX‚úù Y‚úù : CategoryTheory.Arrow C\nst : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Limits.im.map st) (CategoryTheory.Limits.image.map st)","decl":"/-- The functor from the arrow category of `C` to `C` itself that maps a morphism to its image\n    and a commutative square to the induced morphism on images. -/\n@[simps]\ndef im : Arrow C ‚•§ C where\n  obj f := image f.hom\n  map st := image.map st\n\n"}
{"name":"CategoryTheory.Limits.im_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasImages C\ninst‚úù : CategoryTheory.Limits.HasImageMaps C\nf : CategoryTheory.Arrow C\n‚ä¢ Eq (CategoryTheory.Limits.im.obj f) (CategoryTheory.Limits.image f.hom)","decl":"/-- The functor from the arrow category of `C` to `C` itself that maps a morphism to its image\n    and a commutative square to the induced morphism on images. -/\n@[simps]\ndef im : Arrow C ‚•§ C where\n  obj f := image f.hom\n  map st := image.map st\n\n"}
{"name":"CategoryTheory.Limits.StrongEpiMonoFactorisation.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : SizeOf C\ntoMonoFactorisation : CategoryTheory.Limits.MonoFactorisation f\ne_strong_epi : CategoryTheory.StrongEpi toMonoFactorisation.e\n‚ä¢ Eq (SizeOf.sizeOf (CategoryTheory.Limits.StrongEpiMonoFactorisation.mk toMonoFactorisation)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toMonoFactorisation)) (SizeOf.sizeOf e_strong_epi))","decl":"/-- A strong epi-mono factorisation is a decomposition `f = e ‚â´ m` with `e` a strong epimorphism\n    and `m` a monomorphism. -/\nstructure StrongEpiMonoFactorisation {X Y : C} (f : X ‚ü∂ Y) extends MonoFactorisation f where\n  [e_strong_epi : StrongEpi e]\n\n"}
{"name":"CategoryTheory.Limits.StrongEpiMonoFactorisation.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ntoMonoFactorisation‚úù : CategoryTheory.Limits.MonoFactorisation f\ne_strong_epi‚úù : CategoryTheory.StrongEpi toMonoFactorisation‚úù.e\ntoMonoFactorisation : CategoryTheory.Limits.MonoFactorisation f\ne_strong_epi : CategoryTheory.StrongEpi toMonoFactorisation.e\n‚ä¢ Eq (Eq (CategoryTheory.Limits.StrongEpiMonoFactorisation.mk toMonoFactorisation‚úù) (CategoryTheory.Limits.StrongEpiMonoFactorisation.mk toMonoFactorisation)) (Eq toMonoFactorisation‚úù toMonoFactorisation)","decl":"/-- A strong epi-mono factorisation is a decomposition `f = e ‚â´ m` with `e` a strong epimorphism\n    and `m` a monomorphism. -/\nstructure StrongEpiMonoFactorisation {X Y : C} (f : X ‚ü∂ Y) extends MonoFactorisation f where\n  [e_strong_epi : StrongEpi e]\n\n"}
{"name":"CategoryTheory.Limits.StrongEpiMonoFactorisation.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ntoMonoFactorisation‚úù : CategoryTheory.Limits.MonoFactorisation f\ne_strong_epi‚úù : CategoryTheory.StrongEpi toMonoFactorisation‚úù.e\ntoMonoFactorisation : CategoryTheory.Limits.MonoFactorisation f\ne_strong_epi : CategoryTheory.StrongEpi toMonoFactorisation.e\nx‚úù : Eq (CategoryTheory.Limits.StrongEpiMonoFactorisation.mk toMonoFactorisation‚úù) (CategoryTheory.Limits.StrongEpiMonoFactorisation.mk toMonoFactorisation)\n‚ä¢ Eq toMonoFactorisation‚úù toMonoFactorisation","decl":"/-- A strong epi-mono factorisation is a decomposition `f = e ‚â´ m` with `e` a strong epimorphism\n    and `m` a monomorphism. -/\nstructure StrongEpiMonoFactorisation {X Y : C} (f : X ‚ü∂ Y) extends MonoFactorisation f where\n  [e_strong_epi : StrongEpi e]\n\n"}
{"name":"CategoryTheory.Limits.StrongEpiMonoFactorisation.e_strong_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nself : CategoryTheory.Limits.StrongEpiMonoFactorisation f\n‚ä¢ CategoryTheory.StrongEpi self.e","decl":"/-- A strong epi-mono factorisation is a decomposition `f = e ‚â´ m` with `e` a strong epimorphism\n    and `m` a monomorphism. -/\nstructure StrongEpiMonoFactorisation {X Y : C} (f : X ‚ü∂ Y) extends MonoFactorisation f where\n  [e_strong_epi : StrongEpi e]\n\n"}
{"name":"CategoryTheory.Limits.HasStrongEpiMonoFactorisations.has_fac","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Limits.HasStrongEpiMonoFactorisations C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Nonempty (CategoryTheory.Limits.StrongEpiMonoFactorisation f)","decl":"/-- A category has strong epi-mono factorisations if every morphism admits a strong epi-mono\n    factorisation. -/\nclass HasStrongEpiMonoFactorisations : Prop where mk' ::\n  has_fac : ‚àÄ {X Y : C} (f : X ‚ü∂ Y), Nonempty (StrongEpiMonoFactorisation f)\n\n"}
{"name":"CategoryTheory.Limits.HasStrongEpiMonoFactorisations.mk","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nd : {X Y : C} ‚Üí (f : Quiver.Hom X Y) ‚Üí CategoryTheory.Limits.StrongEpiMonoFactorisation f\n‚ä¢ CategoryTheory.Limits.HasStrongEpiMonoFactorisations C","decl":"theorem HasStrongEpiMonoFactorisations.mk\n    (d : ‚àÄ {X Y : C} (f : X ‚ü∂ Y), StrongEpiMonoFactorisation f) :\n    HasStrongEpiMonoFactorisations C :=\n  ‚ü®fun f => Nonempty.intro <| d f‚ü©\n\n"}
{"name":"CategoryTheory.Limits.hasImages_of_hasStrongEpiMonoFactorisations","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasStrongEpiMonoFactorisations C\n‚ä¢ CategoryTheory.Limits.HasImages C","decl":"instance (priority := 100) hasImages_of_hasStrongEpiMonoFactorisations\n    [HasStrongEpiMonoFactorisations C] : HasImages C where\n  has_image f :=\n    let F' := Classical.choice (HasStrongEpiMonoFactorisations.has_fac f)\n    HasImage.mk\n      { F := F'.toMonoFactorisation\n        isImage := F'.toMonoIsImage }\n\n"}
{"name":"CategoryTheory.Limits.HasStrongEpiImages.strong_factorThruImage","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasImages C\nself : CategoryTheory.Limits.HasStrongEpiImages C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ CategoryTheory.StrongEpi (CategoryTheory.Limits.factorThruImage f)","decl":"/-- A category has strong epi images if it has all images and `factorThruImage f` is a strong\n    epimorphism for all `f`. -/\nclass HasStrongEpiImages : Prop where\n  strong_factorThruImage : ‚àÄ {X Y : C} (f : X ‚ü∂ Y), StrongEpi (factorThruImage f)\n\n"}
{"name":"CategoryTheory.Limits.strongEpi_of_strongEpiMonoFactorisation","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nF : CategoryTheory.Limits.StrongEpiMonoFactorisation f\nF' : CategoryTheory.Limits.MonoFactorisation f\nhF' : CategoryTheory.Limits.IsImage F'\n‚ä¢ CategoryTheory.StrongEpi F'.e","decl":"/-- If there is a single strong epi-mono factorisation of `f`, then every image factorisation is a\n    strong epi-mono factorisation. -/\ntheorem strongEpi_of_strongEpiMonoFactorisation {X Y : C} {f : X ‚ü∂ Y}\n    (F : StrongEpiMonoFactorisation f) {F' : MonoFactorisation f} (hF' : IsImage F') :\n    StrongEpi F'.e := by\n  rw [‚Üê IsImage.e_isoExt_hom F.toMonoIsImage hF']\n  apply strongEpi_comp\n\n"}
{"name":"CategoryTheory.Limits.strongEpi_factorThruImage_of_strongEpiMonoFactorisation","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasImage f\nF : CategoryTheory.Limits.StrongEpiMonoFactorisation f\n‚ä¢ CategoryTheory.StrongEpi (CategoryTheory.Limits.factorThruImage f)","decl":"theorem strongEpi_factorThruImage_of_strongEpiMonoFactorisation {X Y : C} {f : X ‚ü∂ Y} [HasImage f]\n    (F : StrongEpiMonoFactorisation f) : StrongEpi (factorThruImage f) :=\n  strongEpi_of_strongEpiMonoFactorisation F <| Image.isImage f\n\n"}
{"name":"CategoryTheory.Limits.hasStrongEpiImages_of_hasStrongEpiMonoFactorisations","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasStrongEpiMonoFactorisations C\n‚ä¢ CategoryTheory.Limits.HasStrongEpiImages C","decl":"/-- If we constructed our images from strong epi-mono factorisations, then these images are\n    strong epi images. -/\ninstance (priority := 100) hasStrongEpiImages_of_hasStrongEpiMonoFactorisations\n    [HasStrongEpiMonoFactorisations C] : HasStrongEpiImages C where\n  strong_factorThruImage f :=\n    strongEpi_factorThruImage_of_strongEpiMonoFactorisation <|\n      Classical.choice <| HasStrongEpiMonoFactorisations.has_fac f\n\n"}
{"name":"CategoryTheory.Limits.hasImageMapsOfHasStrongEpiImages","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasImages C\ninst‚úù : CategoryTheory.Limits.HasStrongEpiImages C\n‚ä¢ CategoryTheory.Limits.HasImageMaps C","decl":"/-- A category with strong epi images has image maps. -/\ninstance (priority := 100) hasImageMapsOfHasStrongEpiImages [HasStrongEpiImages C] :\n    HasImageMaps C where\n  has_image_map {f} {g} st :=\n    HasImageMap.mk\n      { map :=\n          (CommSq.mk\n              (show\n                (st.left ‚â´ factorThruImage g.hom) ‚â´ image.Œπ g.hom =\n                  factorThruImage f.hom ‚â´ image.Œπ f.hom ‚â´ st.right\n                by simp)).lift }\n\n"}
{"name":"CategoryTheory.Limits.hasStrongEpiImages_of_hasPullbacks_of_hasEqualizers","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasImages C\ninst‚úù¬π : CategoryTheory.Limits.HasPullbacks C\ninst‚úù : CategoryTheory.Limits.HasEqualizers C\n‚ä¢ CategoryTheory.Limits.HasStrongEpiImages C","decl":"/-- If a category has images, equalizers and pullbacks, then images are automatically strong epi\n    images. -/\ninstance (priority := 100) hasStrongEpiImages_of_hasPullbacks_of_hasEqualizers [HasPullbacks C]\n    [HasEqualizers C] : HasStrongEpiImages C where\n  strong_factorThruImage f :=\n    StrongEpi.mk' fun {A} {B} h h_mono x y sq =>\n      CommSq.HasLift.mk'\n        { l :=\n            image.lift\n                { I := pullback h y\n                  m := pullback.snd h y ‚â´ image.Œπ f\n                  m_mono := mono_comp _ _\n                  e := pullback.lift _ _ sq.w } ‚â´\n              pullback.fst h y\n          fac_left := by simp only [image.fac_lift_assoc, pullback.lift_fst]\n          fac_right := by\n            apply image.ext\n            simp only [sq.w, Category.assoc, image.fac_lift_assoc, pullback.lift_fst_assoc] }\n\n"}
{"name":"CategoryTheory.Limits.image.isoStrongEpiMono_hom_comp_Œπ","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasStrongEpiMonoFactorisations C\nX Y : C\nf : Quiver.Hom X Y\nI' : C\ne : Quiver.Hom X I'\nm : Quiver.Hom I' Y\ncomm : Eq (CategoryTheory.CategoryStruct.comp e m) f\ninst‚úù¬π : CategoryTheory.StrongEpi e\ninst‚úù : CategoryTheory.Mono m\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.isoStrongEpiMono e m comm).hom (CategoryTheory.Limits.image.Œπ f)) m","decl":"@[simp]\ntheorem image.isoStrongEpiMono_hom_comp_Œπ {I' : C} (e : X ‚ü∂ I') (m : I' ‚ü∂ Y) (comm : e ‚â´ m = f)\n    [StrongEpi e] [Mono m] : (image.isoStrongEpiMono e m comm).hom ‚â´ image.Œπ f = m := by\n  dsimp [isoStrongEpiMono]\n  apply IsImage.lift_fac\n\n"}
{"name":"CategoryTheory.Limits.image.isoStrongEpiMono_inv_comp_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasStrongEpiMonoFactorisations C\nX Y : C\nf : Quiver.Hom X Y\nI' : C\ne : Quiver.Hom X I'\nm : Quiver.Hom I' Y\ncomm : Eq (CategoryTheory.CategoryStruct.comp e m) f\ninst‚úù¬π : CategoryTheory.StrongEpi e\ninst‚úù : CategoryTheory.Mono m\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.isoStrongEpiMono e m comm).inv m) (CategoryTheory.Limits.image.Œπ f)","decl":"@[simp]\ntheorem image.isoStrongEpiMono_inv_comp_mono {I' : C} (e : X ‚ü∂ I') (m : I' ‚ü∂ Y) (comm : e ‚â´ m = f)\n    [StrongEpi e] [Mono m] : (image.isoStrongEpiMono e m comm).inv ‚â´ m = image.Œπ f :=\n  image.lift_fac _\n\n"}
{"name":"CategoryTheory.Functor.hasStrongEpiMonoFactorisations_imp_of_isEquivalence","module":"Mathlib.CategoryTheory.Limits.Shapes.Images","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\ninst‚úù : F.IsEquivalence\nh : CategoryTheory.Limits.HasStrongEpiMonoFactorisations C\n‚ä¢ CategoryTheory.Limits.HasStrongEpiMonoFactorisations D","decl":"theorem hasStrongEpiMonoFactorisations_imp_of_isEquivalence (F : C ‚•§ D) [IsEquivalence F]\n    [h : HasStrongEpiMonoFactorisations C] : HasStrongEpiMonoFactorisations D :=\n  ‚ü®fun {X} {Y} f => by\n    let em : StrongEpiMonoFactorisation (F.inv.map f) :=\n      (HasStrongEpiMonoFactorisations.has_fac (F.inv.map f)).some\n    haveI : Mono (F.map em.m ‚â´ F.asEquivalence.counitIso.hom.app Y) := mono_comp _ _\n    haveI : StrongEpi (F.asEquivalence.counitIso.inv.app X ‚â´ F.map em.e) := strongEpi_comp _ _\n    exact\n      Nonempty.intro\n        { I := F.obj em.I\n          e := F.asEquivalence.counitIso.inv.app X ‚â´ F.map em.e\n          m := F.map em.m ‚â´ F.asEquivalence.counitIso.hom.app Y\n          fac := by\n            simp only [asEquivalence_functor, Category.assoc, ‚Üê F.map_comp_assoc,\n              MonoFactorisation.fac, fun_inv_map, id_obj, Iso.inv_hom_id_app, Category.comp_id,\n              Iso.inv_hom_id_app_assoc] }‚ü©\n\n"}
