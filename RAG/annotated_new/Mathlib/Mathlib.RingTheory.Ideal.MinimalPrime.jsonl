{"name":"minimalPrimes_eq_minimals","module":"Mathlib.RingTheory.Ideal.MinimalPrime","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (minimalPrimes R) (setOf fun x => Minimal Ideal.IsPrime x)","decl":"lemma minimalPrimes_eq_minimals : minimalPrimes R = {x | Minimal Ideal.IsPrime x} :=\n  congr_arg Minimal (by simp)\n\n"}
{"name":"Ideal.minimalPrimes_isPrime","module":"Mathlib.RingTheory.Ideal.MinimalPrime","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nI p : Ideal R\nh : Membership.mem I.minimalPrimes p\n⊢ p.IsPrime","decl":"theorem Ideal.minimalPrimes_isPrime {p : Ideal R} (h : p ∈ I.minimalPrimes) : p.IsPrime :=\n  h.1.1\n\n"}
{"name":"Ideal.exists_minimalPrimes_le","module":"Mathlib.RingTheory.Ideal.MinimalPrime","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\nI J : Ideal R\ninst✝ : J.IsPrime\ne : LE.le I J\n⊢ Exists fun p => And (Membership.mem I.minimalPrimes p) (LE.le p J)","decl":"theorem Ideal.exists_minimalPrimes_le [J.IsPrime] (e : I ≤ J) : ∃ p ∈ I.minimalPrimes, p ≤ J := by\n  set S := { p : (Ideal R)ᵒᵈ | Ideal.IsPrime p ∧ I ≤ OrderDual.ofDual p }\n  suffices h : ∃ m, OrderDual.toDual J ≤ m ∧ Maximal (· ∈ S) m by\n    obtain ⟨p, hJp, hp⟩ := h\n    exact ⟨p, ⟨hp.prop, fun q hq hle ↦ hp.le_of_ge hq hle⟩, hJp⟩\n  apply zorn_le_nonempty₀\n  swap\n  · refine ⟨show J.IsPrime by infer_instance, e⟩\n  rintro (c : Set (Ideal R)) hc hc' J' hJ'\n  refine\n    ⟨OrderDual.toDual (sInf c),\n      ⟨Ideal.sInf_isPrime_of_isChain ⟨J', hJ'⟩ hc'.symm fun x hx => (hc hx).1, ?_⟩, ?_⟩\n  · rw [OrderDual.ofDual_toDual, le_sInf_iff]\n    exact fun _ hx => (hc hx).2\n  · rintro z hz\n    rw [OrderDual.le_toDual]\n    exact sInf_le hz\n\n"}
{"name":"Ideal.nonempty_minimalPrimes","module":"Mathlib.RingTheory.Ideal.MinimalPrime","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nI : Ideal R\nh : Ne I Top.top\n⊢ Nonempty ↑I.minimalPrimes","decl":"theorem Ideal.nonempty_minimalPrimes (h : I ≠ ⊤) : Nonempty I.minimalPrimes := by\n  obtain ⟨m, hm, hle⟩ := Ideal.exists_le_maximal I h\n  obtain ⟨p, hp, -⟩ := Ideal.exists_minimalPrimes_le hle\n  exact ⟨p, hp⟩\n\n"}
{"name":"Ideal.eq_bot_of_minimalPrimes_eq_empty","module":"Mathlib.RingTheory.Ideal.MinimalPrime","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nI : Ideal R\nh : Eq I.minimalPrimes EmptyCollection.emptyCollection\n⊢ Eq I Top.top","decl":"theorem Ideal.eq_bot_of_minimalPrimes_eq_empty (h : I.minimalPrimes = ∅) : I = ⊤ := by\n  by_contra hI\n  obtain ⟨p, hp⟩ := Ideal.nonempty_minimalPrimes hI\n  exact Set.not_mem_empty p (h ▸ hp)\n\n"}
{"name":"Ideal.radical_minimalPrimes","module":"Mathlib.RingTheory.Ideal.MinimalPrime","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nI : Ideal R\n⊢ Eq I.radical.minimalPrimes I.minimalPrimes","decl":"@[simp]\ntheorem Ideal.radical_minimalPrimes : I.radical.minimalPrimes = I.minimalPrimes := by\n  rw [Ideal.minimalPrimes, Ideal.minimalPrimes]\n  ext p\n  refine ⟨?_, ?_⟩ <;> rintro ⟨⟨a, ha⟩, b⟩\n  · refine ⟨⟨a, a.radical_le_iff.1 ha⟩, ?_⟩\n    simp only [Set.mem_setOf_eq, and_imp] at *\n    exact fun _ h2 h3 h4 => b h2 (h2.radical_le_iff.2 h3) h4\n  · refine ⟨⟨a, a.radical_le_iff.2 ha⟩, ?_⟩\n    simp only [Set.mem_setOf_eq, and_imp] at *\n    exact fun _ h2 h3 h4 => b h2 (h2.radical_le_iff.1 h3) h4\n\n"}
{"name":"Ideal.sInf_minimalPrimes","module":"Mathlib.RingTheory.Ideal.MinimalPrime","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nI : Ideal R\n⊢ Eq (InfSet.sInf I.minimalPrimes) I.radical","decl":"@[simp]\ntheorem Ideal.sInf_minimalPrimes : sInf I.minimalPrimes = I.radical := by\n  rw [I.radical_eq_sInf]\n  apply le_antisymm\n  · intro x hx\n    rw [Ideal.mem_sInf] at hx ⊢\n    rintro J ⟨e, hJ⟩\n    obtain ⟨p, hp, hp'⟩ := Ideal.exists_minimalPrimes_le e\n    exact hp' (hx hp)\n  · apply sInf_le_sInf _\n    intro I hI\n    exact hI.1.symm\n\n"}
{"name":"Ideal.iUnion_minimalPrimes","module":"Mathlib.RingTheory.Ideal.MinimalPrime","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nI : Ideal R\n⊢ Eq (Set.iUnion fun p => Set.iUnion fun h => ↑p) (setOf fun x => Exists fun y => And (Not (Membership.mem I.radical y)) (Membership.mem I.radical (HMul.hMul x y)))","decl":"theorem Ideal.iUnion_minimalPrimes :\n    ⋃ p ∈ I.minimalPrimes, p = { x | ∃ y ∉ I.radical, x * y ∈ I.radical } := by\n  classical\n  ext x\n  simp only [Set.mem_iUnion, SetLike.mem_coe, exists_prop, Set.mem_setOf_eq]\n  constructor\n  · rintro ⟨p, ⟨⟨hp₁, hp₂⟩, hp₃⟩, hxp⟩\n    have : p.map (algebraMap R (Localization.AtPrime p)) ≤ (I.map (algebraMap _ _)).radical := by\n      rw [Ideal.radical_eq_sInf, le_sInf_iff]\n      rintro q ⟨hq', hq⟩\n      obtain ⟨h₁, h₂⟩ := ((IsLocalization.AtPrime.orderIsoOfPrime _ p) ⟨q, hq⟩).2\n      rw [Ideal.map_le_iff_le_comap] at hq' ⊢\n      exact hp₃ ⟨h₁, hq'⟩ h₂\n    obtain ⟨n, hn⟩ := this (Ideal.mem_map_of_mem _ hxp)\n    rw [IsLocalization.mem_map_algebraMap_iff (M := p.primeCompl)] at hn\n    obtain ⟨⟨a, b⟩, hn⟩ := hn\n    rw [← map_pow, ← _root_.map_mul, IsLocalization.eq_iff_exists p.primeCompl] at hn\n    obtain ⟨t, ht⟩ := hn\n    refine ⟨t * b, fun h ↦ (t * b).2 (hp₁.radical_le_iff.mpr hp₂ h), n + 1, ?_⟩\n    simp only at ht\n    have : (x * (t.1 * b.1)) ^ (n + 1) = (t.1 ^ n * b.1 ^ n * x * t.1) * a := by\n      rw [mul_assoc, ← ht]; ring\n    rw [this]\n    exact I.mul_mem_left _ a.2\n  · rintro ⟨y, hy, hx⟩\n    obtain ⟨p, hp, hyp⟩ : ∃ p ∈ I.minimalPrimes, y ∉ p := by\n      simpa [← Ideal.sInf_minimalPrimes] using hy\n    refine ⟨p, hp, (hp.1.1.mem_or_mem ?_).resolve_right hyp⟩\n    exact hp.1.1.radical_le_iff.mpr hp.1.2 hx\n\n"}
{"name":"Ideal.exists_mul_mem_of_mem_minimalPrimes","module":"Mathlib.RingTheory.Ideal.MinimalPrime","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nI p : Ideal R\nhp : Membership.mem I.minimalPrimes p\nx : R\nhx : Membership.mem p x\n⊢ Exists fun y => And (Not (Membership.mem I y)) (Membership.mem I (HMul.hMul x y))","decl":"theorem Ideal.exists_mul_mem_of_mem_minimalPrimes\n    {p : Ideal R} (hp : p ∈ I.minimalPrimes) {x : R} (hx : x ∈ p) :\n    ∃ y ∉ I, x * y ∈ I := by\n  classical\n  obtain ⟨y, hy, n, hx⟩ := Ideal.iUnion_minimalPrimes.subset (Set.mem_biUnion hp hx)\n  have H : ∃ m, x ^ m * y ^ n ∈ I := ⟨n, mul_pow x y n ▸ hx⟩\n  have : Nat.find H ≠ 0 :=\n    fun h ↦ hy ⟨n, by simpa only [h, pow_zero, one_mul] using Nat.find_spec H⟩\n  refine ⟨x ^ (Nat.find H - 1) * y ^ n, Nat.find_min H (Nat.sub_one_lt this), ?_⟩\n  rw [← mul_assoc, ← pow_succ', tsub_add_cancel_of_le (Nat.one_le_iff_ne_zero.mpr this)]\n  exact Nat.find_spec H\n\n"}
{"name":"Ideal.disjoint_nonZeroDivisors_of_mem_minimalPrimes","module":"Mathlib.RingTheory.Ideal.MinimalPrime","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\np : Ideal R\nhp : Membership.mem (minimalPrimes R) p\n⊢ Disjoint ↑p ↑(nonZeroDivisors R)","decl":"/-- minimal primes are contained in zero divisors. -/\nlemma Ideal.disjoint_nonZeroDivisors_of_mem_minimalPrimes {p : Ideal R} (hp : p ∈ minimalPrimes R) :\n    Disjoint (p : Set R) (nonZeroDivisors R) := by\n  classical\n  rw [← Set.subset_compl_iff_disjoint_right, Set.subset_def]\n  simp only [SetLike.mem_coe, Set.mem_compl_iff, mem_nonZeroDivisors_iff, not_forall,\n    Classical.not_imp]\n  intro x hxp\n  simp_rw [exists_prop, @and_comm (_ * _ = _), ← mul_comm x]\n  exact Ideal.exists_mul_mem_of_mem_minimalPrimes hp hxp\n\n"}
{"name":"Ideal.exists_comap_eq_of_mem_minimalPrimes_of_injective","module":"Mathlib.RingTheory.Ideal.MinimalPrime","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\nhf : Function.Injective ⇑f\np : Ideal R\nH : Membership.mem (minimalPrimes R) p\n⊢ Exists fun p' => And p'.IsPrime (Eq (Ideal.comap f p') p)","decl":"theorem Ideal.exists_comap_eq_of_mem_minimalPrimes_of_injective {f : R →+* S}\n    (hf : Function.Injective f) (p) (H : p ∈ minimalPrimes R) :\n    ∃ p' : Ideal S, p'.IsPrime ∧ p'.comap f = p := by\n  have := H.1.1\n  have : Nontrivial (Localization (Submonoid.map f p.primeCompl)) := by\n    refine ⟨⟨1, 0, ?_⟩⟩\n    convert (IsLocalization.map_injective_of_injective p.primeCompl (Localization.AtPrime p)\n        (Localization <| p.primeCompl.map f) hf).ne one_ne_zero\n    · rw [map_one]\n    · rw [map_zero]\n  obtain ⟨M, hM⟩ := Ideal.exists_maximal (Localization (Submonoid.map f p.primeCompl))\n  refine ⟨M.comap (algebraMap S <| Localization (Submonoid.map f p.primeCompl)), inferInstance, ?_⟩\n  rw [Ideal.comap_comap, ← @IsLocalization.map_comp _ _ _ _ _ _ _ _ Localization.isLocalization\n      _ _ _ _ _ Localization.isLocalization p.primeCompl.le_comap_map,\n    ← Ideal.comap_comap]\n  suffices _ ≤ p by exact this.antisymm (H.2 ⟨inferInstance, bot_le⟩ this)\n  intro x hx\n  by_contra h\n  apply hM.ne_top\n  apply M.eq_top_of_isUnit_mem hx\n  apply IsUnit.map\n  apply IsLocalization.map_units _ (show p.primeCompl from ⟨x, h⟩)\n\n"}
{"name":"Ideal.exists_comap_eq_of_mem_minimalPrimes","module":"Mathlib.RingTheory.Ideal.MinimalPrime","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nI : Ideal S\nf : RingHom R S\np : Ideal R\nH : Membership.mem (Ideal.comap f I).minimalPrimes p\n⊢ Exists fun p' => And p'.IsPrime (And (LE.le I p') (Eq (Ideal.comap f p') p))","decl":"theorem Ideal.exists_comap_eq_of_mem_minimalPrimes {I : Ideal S} (f : R →+* S) (p)\n    (H : p ∈ (I.comap f).minimalPrimes) : ∃ p' : Ideal S, p'.IsPrime ∧ I ≤ p' ∧ p'.comap f = p := by\n  have := H.1.1\n  let f' := (Ideal.Quotient.mk I).comp f\n  have e : RingHom.ker f' = I.comap f := by\n    ext1\n    exact Submodule.Quotient.mk_eq_zero _\n  have : RingHom.ker (Ideal.Quotient.mk <| RingHom.ker f') ≤ p := by\n    rw [Ideal.mk_ker, e]\n    exact H.1.2\n  suffices _ by\n    have ⟨p', hp₁, hp₂⟩ := Ideal.exists_comap_eq_of_mem_minimalPrimes_of_injective\n      (RingHom.kerLift_injective f') (p.map <| Ideal.Quotient.mk <| RingHom.ker f') this\n    refine ⟨p'.comap <| Ideal.Quotient.mk I, Ideal.IsPrime.comap _, ?_, ?_⟩\n    · exact Ideal.mk_ker.symm.trans_le (Ideal.comap_mono bot_le)\n    · convert congr_arg (Ideal.comap <| Ideal.Quotient.mk <| RingHom.ker f') hp₂\n      rwa [Ideal.comap_map_of_surjective (Ideal.Quotient.mk <| RingHom.ker f')\n        Ideal.Quotient.mk_surjective, eq_comm, sup_eq_left]\n  refine ⟨⟨?_, bot_le⟩, ?_⟩\n  · apply Ideal.map_isPrime_of_surjective _ this\n    exact Ideal.Quotient.mk_surjective\n  · rintro q ⟨hq, -⟩ hq'\n    rw [← Ideal.map_comap_of_surjective\n        (Ideal.Quotient.mk (RingHom.ker ((Ideal.Quotient.mk I).comp f)))\n        Ideal.Quotient.mk_surjective q]\n    apply Ideal.map_mono\n    apply H.2\n    · refine ⟨inferInstance, (Ideal.mk_ker.trans e).symm.trans_le (Ideal.comap_mono bot_le)⟩\n    · refine (Ideal.comap_mono hq').trans ?_\n      rw [Ideal.comap_map_of_surjective]\n      exacts [sup_le rfl.le this, Ideal.Quotient.mk_surjective]\n\n"}
{"name":"Ideal.exists_minimalPrimes_comap_eq","module":"Mathlib.RingTheory.Ideal.MinimalPrime","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nI : Ideal S\nf : RingHom R S\np : Ideal R\nH : Membership.mem (Ideal.comap f I).minimalPrimes p\n⊢ Exists fun p' => And (Membership.mem I.minimalPrimes p') (Eq (Ideal.comap f p') p)","decl":"theorem Ideal.exists_minimalPrimes_comap_eq {I : Ideal S} (f : R →+* S) (p)\n    (H : p ∈ (I.comap f).minimalPrimes) : ∃ p' ∈ I.minimalPrimes, Ideal.comap f p' = p := by\n  obtain ⟨p', h₁, h₂, h₃⟩ := Ideal.exists_comap_eq_of_mem_minimalPrimes f p H\n  obtain ⟨q, hq, hq'⟩ := Ideal.exists_minimalPrimes_le h₂\n  refine ⟨q, hq, Eq.symm ?_⟩\n  have := hq.1.1\n  have := (Ideal.comap_mono hq').trans_eq h₃\n  exact (H.2 ⟨inferInstance, Ideal.comap_mono hq.1.2⟩ this).antisymm this\n\n"}
{"name":"Ideal.minimal_primes_comap_of_surjective","module":"Mathlib.RingTheory.Ideal.MinimalPrime","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nhf : Function.Surjective ⇑f\nI J : Ideal S\nh : Membership.mem I.minimalPrimes J\n⊢ Membership.mem (Ideal.comap f I).minimalPrimes (Ideal.comap f J)","decl":"theorem Ideal.minimal_primes_comap_of_surjective {f : R →+* S} (hf : Function.Surjective f)\n    {I J : Ideal S} (h : J ∈ I.minimalPrimes) : J.comap f ∈ (I.comap f).minimalPrimes := by\n  have := h.1.1\n  refine ⟨⟨inferInstance, Ideal.comap_mono h.1.2⟩, ?_⟩\n  rintro K ⟨hK, e₁⟩ e₂\n  have : RingHom.ker f ≤ K := (Ideal.comap_mono bot_le).trans e₁\n  rw [← sup_eq_left.mpr this, RingHom.ker_eq_comap_bot, ← Ideal.comap_map_of_surjective f hf]\n  apply Ideal.comap_mono _\n  apply h.2 _ _\n  · exact ⟨Ideal.map_isPrime_of_surjective hf this, Ideal.le_map_of_comap_le_of_surjective f hf e₁⟩\n  · exact Ideal.map_le_of_le_comap e₂\n\n"}
{"name":"Ideal.comap_minimalPrimes_eq_of_surjective","module":"Mathlib.RingTheory.Ideal.MinimalPrime","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nhf : Function.Surjective ⇑f\nI : Ideal S\n⊢ Eq (Ideal.comap f I).minimalPrimes (Set.image (Ideal.comap f) I.minimalPrimes)","decl":"theorem Ideal.comap_minimalPrimes_eq_of_surjective {f : R →+* S} (hf : Function.Surjective f)\n    (I : Ideal S) : (I.comap f).minimalPrimes = Ideal.comap f '' I.minimalPrimes := by\n  ext J\n  constructor\n  · intro H\n    obtain ⟨p, h, rfl⟩ := Ideal.exists_minimalPrimes_comap_eq f J H\n    exact ⟨p, h, rfl⟩\n  · rintro ⟨J, hJ, rfl⟩\n    exact Ideal.minimal_primes_comap_of_surjective hf hJ\n\n"}
{"name":"Ideal.minimalPrimes_eq_comap","module":"Mathlib.RingTheory.Ideal.MinimalPrime","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nI : Ideal R\n⊢ Eq I.minimalPrimes (Set.image (Ideal.comap (Ideal.Quotient.mk I)) (minimalPrimes (HasQuotient.Quotient R I)))","decl":"theorem Ideal.minimalPrimes_eq_comap :\n    I.minimalPrimes = Ideal.comap (Ideal.Quotient.mk I) '' minimalPrimes (R ⧸ I) := by\n  rw [minimalPrimes, ← Ideal.comap_minimalPrimes_eq_of_surjective Ideal.Quotient.mk_surjective,\n    ← RingHom.ker_eq_comap_bot, Ideal.mk_ker]\n\n"}
{"name":"Ideal.minimalPrimes_eq_subsingleton","module":"Mathlib.RingTheory.Ideal.MinimalPrime","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nI : Ideal R\nhI : I.IsPrimary\n⊢ Eq I.minimalPrimes (Singleton.singleton I.radical)","decl":"theorem Ideal.minimalPrimes_eq_subsingleton (hI : I.IsPrimary) : I.minimalPrimes = {I.radical} := by\n  ext J\n  constructor\n  · exact fun H =>\n      let e := H.1.1.radical_le_iff.mpr H.1.2\n      (H.2 ⟨Ideal.isPrime_radical hI, Ideal.le_radical⟩ e).antisymm e\n  · rintro (rfl : J = I.radical)\n    exact ⟨⟨Ideal.isPrime_radical hI, Ideal.le_radical⟩, fun _ H _ => H.1.radical_le_iff.mpr H.2⟩\n\n"}
{"name":"Ideal.minimalPrimes_eq_subsingleton_self","module":"Mathlib.RingTheory.Ideal.MinimalPrime","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nI : Ideal R\ninst✝ : I.IsPrime\n⊢ Eq I.minimalPrimes (Singleton.singleton I)","decl":"theorem Ideal.minimalPrimes_eq_subsingleton_self [I.IsPrime] : I.minimalPrimes = {I} := by\n  ext J\n  constructor\n  · exact fun H => (H.2 ⟨inferInstance, rfl.le⟩ H.1.2).antisymm H.1.2\n  · rintro (rfl : J = I)\n    exact ⟨⟨inferInstance, rfl.le⟩, fun _ h _ => h.2⟩\n\n"}
{"name":"IsLocalization.AtPrime.prime_unique_of_minimal","module":"Mathlib.RingTheory.Ideal.MinimalPrime","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nI : Ideal R\nhI : I.IsPrime\nhMin : Membership.mem (minimalPrimes R) I\nS : Type u_2\ninst✝⁴ : CommSemiring S\ninst✝³ : Algebra R S\ninst✝² : IsLocalization.AtPrime S I\nJ K : Ideal S\ninst✝¹ : J.IsPrime\ninst✝ : K.IsPrime\n⊢ Eq J K","decl":"theorem _root_.IsLocalization.AtPrime.prime_unique_of_minimal {S} [CommSemiring S] [Algebra R S]\n    [IsLocalization.AtPrime S I] {J K : Ideal S} [J.IsPrime] [K.IsPrime] : J = K :=\n  haveI : Subsingleton {i : Ideal R // i.IsPrime ∧ i ≤ I} := ⟨fun i₁ i₂ ↦ Subtype.ext <| by\n    rw [minimalPrimes_eq_minimals, Set.mem_setOf] at hMin\n    rw [hMin.eq_of_le i₁.2.1 i₁.2.2, hMin.eq_of_le i₂.2.1 i₂.2.2]⟩\n  Subtype.ext_iff.mp <| (IsLocalization.AtPrime.orderIsoOfPrime S I).injective\n    (a₁ := ⟨J, ‹_›⟩) (a₂ := ⟨K, ‹_›⟩) (Subsingleton.elim _ _)\n\n"}
{"name":"Localization.AtPrime.prime_unique_of_minimal","module":"Mathlib.RingTheory.Ideal.MinimalPrime","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\nI : Ideal R\nhI : I.IsPrime\nhMin : Membership.mem (minimalPrimes R) I\nJ : Ideal (Localization I.primeCompl)\ninst✝ : J.IsPrime\n⊢ Eq J (IsLocalRing.maximalIdeal (Localization I.primeCompl))","decl":"theorem prime_unique_of_minimal (J : Ideal (Localization I.primeCompl)) [J.IsPrime] :\n    J = IsLocalRing.maximalIdeal (Localization I.primeCompl) :=\n  IsLocalization.AtPrime.prime_unique_of_minimal hMin\n\n"}
{"name":"Localization.AtPrime.nilpotent_iff_mem_maximal_of_minimal","module":"Mathlib.RingTheory.Ideal.MinimalPrime","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nI : Ideal R\nhI : I.IsPrime\nhMin : Membership.mem (minimalPrimes R) I\nx : Localization I.primeCompl\n⊢ Iff (IsNilpotent x) (Membership.mem (IsLocalRing.maximalIdeal (Localization I.primeCompl)) x)","decl":"theorem nilpotent_iff_mem_maximal_of_minimal {x : _} :\n    IsNilpotent x ↔ x ∈ IsLocalRing.maximalIdeal (Localization I.primeCompl) := by\n  rw [nilpotent_iff_mem_prime]\n  exact ⟨(· (IsLocalRing.maximalIdeal _) (Ideal.IsMaximal.isPrime' _)), fun _ J _ =>\n    by simpa [prime_unique_of_minimal hMin J]⟩\n\n"}
{"name":"Localization.AtPrime.nilpotent_iff_not_unit_of_minimal","module":"Mathlib.RingTheory.Ideal.MinimalPrime","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nI : Ideal R\nhI : I.IsPrime\nhMin : Membership.mem (minimalPrimes R) I\nx : Localization I.primeCompl\n⊢ Iff (IsNilpotent x) (Membership.mem (nonunits (Localization I.primeCompl)) x)","decl":"theorem nilpotent_iff_not_unit_of_minimal {x : Localization I.primeCompl} :\n    IsNilpotent x ↔ x ∈ nonunits _ := by\n  simpa only [← IsLocalRing.mem_maximalIdeal] using nilpotent_iff_mem_maximal_of_minimal hMin\n\n"}
{"name":"Ideal.minimalPrimes_top","module":"Mathlib.RingTheory.Ideal.MinimalPrime","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq Top.top.minimalPrimes EmptyCollection.emptyCollection","decl":"theorem Ideal.minimalPrimes_top : (⊤ : Ideal R).minimalPrimes = ∅ := by\n  ext p\n  constructor\n  · intro h\n    exact False.elim (h.1.1.ne_top (top_le_iff.mp h.1.2))\n  · intro h\n    exact False.elim (Set.not_mem_empty p h)\n\n"}
{"name":"Ideal.minimalPrimes_eq_empty_iff","module":"Mathlib.RingTheory.Ideal.MinimalPrime","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nI : Ideal R\n⊢ Iff (Eq I.minimalPrimes EmptyCollection.emptyCollection) (Eq I Top.top)","decl":"theorem Ideal.minimalPrimes_eq_empty_iff (I : Ideal R) :\n    I.minimalPrimes = ∅ ↔ I = ⊤ := by\n  constructor\n  · intro e\n    by_contra h\n    have ⟨M, hM, hM'⟩ := Ideal.exists_le_maximal I h\n    have ⟨p, hp⟩ := Ideal.exists_minimalPrimes_le hM'\n    show p ∈ (∅ : Set (Ideal R))\n    rw [← e]; exact hp.1\n  · intro h; rw [h]\n    exact Ideal.minimalPrimes_top\n\n"}
