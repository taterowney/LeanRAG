{"name":"CategoryTheory.discreteSieve_apply","module":"Mathlib.CategoryTheory.Sites.Types","initialProofState":"Œ± x‚úù : Type u\nf : Quiver.Hom x‚úù Œ±\n‚ä¢ Eq ((CategoryTheory.discreteSieve Œ±).arrows f) (Exists fun x => ‚àÄ (y : x‚úù), Eq (f y) x)","decl":"/-- The discrete sieve on a type, which only includes arrows whose image is a subsingleton. -/\n@[simps]\ndef discreteSieve (Œ± : Type u) : Sieve Œ± where\n  arrows _ f := ‚àÉ x, ‚àÄ y, f y = x\n  downward_closed := fun ‚ü®x, hx‚ü© g => ‚ü®x, fun y => hx <| g y‚ü©\n\n"}
{"name":"CategoryTheory.discreteSieve_mem","module":"Mathlib.CategoryTheory.Sites.Types","initialProofState":"Œ± : Type u\n‚ä¢ Membership.mem (CategoryTheory.typesGrothendieckTopology Œ±) (CategoryTheory.discreteSieve Œ±)","decl":"theorem discreteSieve_mem (Œ± : Type u) : discreteSieve Œ± ‚àà typesGrothendieckTopology Œ± :=\n  fun x => ‚ü®x, fun _ => rfl‚ü©\n\n"}
{"name":"CategoryTheory.generate_discretePresieve_mem","module":"Mathlib.CategoryTheory.Sites.Types","initialProofState":"Œ± : Type u\n‚ä¢ Membership.mem (CategoryTheory.typesGrothendieckTopology Œ±) (CategoryTheory.Sieve.generate (CategoryTheory.discretePresieve Œ±))","decl":"theorem generate_discretePresieve_mem (Œ± : Type u) :\n    Sieve.generate (discretePresieve Œ±) ‚àà typesGrothendieckTopology Œ± :=\n  fun x => ‚ü®PUnit, id, fun _ => x, ‚ü®PUnit.unit, fun _ => Subsingleton.elim _ _‚ü©, rfl‚ü©\n\n"}
{"name":"CategoryTheory.Presieve.isSheaf_yoneda'","module":"Mathlib.CategoryTheory.Sites.Types","initialProofState":"Œ± : Type u\n‚ä¢ CategoryTheory.Presieve.IsSheaf CategoryTheory.typesGrothendieckTopology (CategoryTheory.yoneda.obj Œ±)","decl":"/-- The sheaf condition for `yoneda'`. -/\ntheorem Presieve.isSheaf_yoneda' {Œ± : Type u} :\n    Presieve.IsSheaf typesGrothendieckTopology (yoneda.obj Œ±) :=\n  fun Œ≤ _ hs x hx =>\n  ‚ü®fun y => x _ (hs y) PUnit.unit, fun Œ≥ f h =>\n    funext fun z => by\n      convert congr_fun (hx (ùüô _) (fun _ => z) (hs <| f z) h rfl) PUnit.unit using 1,\n    fun f hf => funext fun y => by convert congr_fun (hf _ (hs y)) PUnit.unit‚ü©\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_yoneda'","module":"Mathlib.CategoryTheory.Sites.Types","initialProofState":"Œ± : Type u\n‚ä¢ CategoryTheory.Presheaf.IsSheaf CategoryTheory.typesGrothendieckTopology (CategoryTheory.yoneda.obj Œ±)","decl":"/-- The sheaf condition for `yoneda'`. -/\ntheorem Presheaf.isSheaf_yoneda' {Œ± : Type u} :\n    Presheaf.IsSheaf typesGrothendieckTopology (yoneda.obj Œ±) := by\n  rw [isSheaf_iff_isSheaf_of_type]\n  exact Presieve.isSheaf_yoneda'\n\n"}
{"name":"CategoryTheory.isSheaf_yoneda'","module":"Mathlib.CategoryTheory.Sites.Types","initialProofState":"Œ± : Type u\n‚ä¢ CategoryTheory.Presieve.IsSheaf CategoryTheory.typesGrothendieckTopology (CategoryTheory.yoneda.obj Œ±)","decl":"@[deprecated (since := \"2024-11-26\")] alias isSheaf_yoneda' := Presieve.isSheaf_yoneda'\n\n"}
{"name":"CategoryTheory.yoneda'_map_val","module":"Mathlib.CategoryTheory.Sites.Types","initialProofState":"X‚úù Y‚úù : Type u\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.yoneda'.map f).val (CategoryTheory.yoneda.map f)","decl":"/-- The yoneda functor that sends a type to a sheaf over the category of types. -/\n@[simps]\ndef yoneda' : Type u ‚•§ Sheaf typesGrothendieckTopology (Type u) where\n  obj Œ± := ‚ü®yoneda.obj Œ±, Presheaf.isSheaf_yoneda'‚ü©\n  map f := ‚ü®yoneda.map f‚ü©\n\n"}
{"name":"CategoryTheory.yoneda'_obj_val","module":"Mathlib.CategoryTheory.Sites.Types","initialProofState":"Œ± : Type u\n‚ä¢ Eq (CategoryTheory.yoneda'.obj Œ±).val (CategoryTheory.yoneda.obj Œ±)","decl":"/-- The yoneda functor that sends a type to a sheaf over the category of types. -/\n@[simps]\ndef yoneda' : Type u ‚•§ Sheaf typesGrothendieckTopology (Type u) where\n  obj Œ± := ‚ü®yoneda.obj Œ±, Presheaf.isSheaf_yoneda'‚ü©\n  map f := ‚ü®yoneda.map f‚ü©\n\n"}
{"name":"CategoryTheory.yoneda'_comp","module":"Mathlib.CategoryTheory.Sites.Types","initialProofState":"‚ä¢ Eq (CategoryTheory.yoneda'.comp (CategoryTheory.sheafToPresheaf CategoryTheory.typesGrothendieckTopology (Type u))) CategoryTheory.yoneda","decl":"@[simp]\ntheorem yoneda'_comp : yoneda'.{u} ‚ãô sheafToPresheaf _ _ = yoneda :=\n  rfl\n\n"}
{"name":"CategoryTheory.eval_typesGlue","module":"Mathlib.CategoryTheory.Sites.Types","initialProofState":"S : CategoryTheory.Functor (Opposite (Type u)) (Type u)\nhs : CategoryTheory.Presieve.IsSheaf CategoryTheory.typesGrothendieckTopology S\nŒ± : Type u\nf : Œ± ‚Üí S.obj { unop := PUnit.{u + 1} }\n‚ä¢ Eq (CategoryTheory.eval S Œ± (CategoryTheory.typesGlue S hs Œ± f)) f","decl":"theorem eval_typesGlue {S hs Œ±} (f) : eval.{u} S Œ± (typesGlue S hs Œ± f) = f := by\n  funext x\n  apply (IsSheafFor.valid_glue _ _ _ <| ‚ü®PUnit.unit, fun _ => Subsingleton.elim _ _‚ü©).trans\n  convert FunctorToTypes.map_id_apply S _\n\n"}
{"name":"CategoryTheory.typesGlue_eval","module":"Mathlib.CategoryTheory.Sites.Types","initialProofState":"S : CategoryTheory.Functor (Opposite (Type u)) (Type u)\nhs : CategoryTheory.Presieve.IsSheaf CategoryTheory.typesGrothendieckTopology S\nŒ± : Type u\ns : S.obj { unop := Œ± }\n‚ä¢ Eq (CategoryTheory.typesGlue S hs Œ± (CategoryTheory.eval S Œ± s)) s","decl":"theorem typesGlue_eval {S hs Œ±} (s) : typesGlue.{u} S hs Œ± (eval S Œ± s) = s := by\n  apply (hs.isSheafFor _ _ (generate_discretePresieve_mem Œ±)).isSeparatedFor.ext\n  intro Œ≤ f hf\n  apply (IsSheafFor.valid_glue _ _ _ hf).trans\n  apply (FunctorToTypes.map_comp_apply _ _ _ _).symm.trans\n  rw [‚Üê op_comp]\n  --congr 2 -- Porting note: This tactic didn't work. Find an alternative.\n  suffices ((‚Üæfun _ ‚Ü¶ PUnit.unit) ‚â´ ‚Üæfun _ ‚Ü¶ f (Classical.choose hf)) = f by rw [this]\n  funext x\n  exact congr_arg f (Classical.choose_spec hf x).symm\n\n"}
{"name":"CategoryTheory.evalEquiv_symm_apply","module":"Mathlib.CategoryTheory.Sites.Types","initialProofState":"S : CategoryTheory.Functor (Opposite (Type u)) (Type u)\nhs : CategoryTheory.Presheaf.IsSheaf CategoryTheory.typesGrothendieckTopology S\nŒ± : Type u\nf : Œ± ‚Üí S.obj { unop := PUnit.{u + 1} }\n‚ä¢ Eq ((CategoryTheory.evalEquiv S hs Œ±).symm f) (CategoryTheory.typesGlue S ‚ãØ Œ± f)","decl":"/-- Given a sheaf `S`, construct an equivalence `S(Œ±) ‚âÉ (Œ± ‚Üí S(*))`. -/\n@[simps]\nnoncomputable def evalEquiv (S : Type u·µí·µñ ‚•§ Type u)\n    (hs : Presheaf.IsSheaf typesGrothendieckTopology S)\n    (Œ± : Type u) : S.obj (op Œ±) ‚âÉ (Œ± ‚Üí S.obj (op PUnit)) where\n  toFun := eval S Œ±\n  invFun := typesGlue S ((isSheaf_iff_isSheaf_of_type _ _ ).1 hs) Œ±\n  left_inv := typesGlue_eval\n  right_inv := eval_typesGlue\n\n"}
{"name":"CategoryTheory.evalEquiv_apply","module":"Mathlib.CategoryTheory.Sites.Types","initialProofState":"S : CategoryTheory.Functor (Opposite (Type u)) (Type u)\nhs : CategoryTheory.Presheaf.IsSheaf CategoryTheory.typesGrothendieckTopology S\nŒ± : Type u\ns : S.obj { unop := Œ± }\nx : Œ±\n‚ä¢ Eq ((CategoryTheory.evalEquiv S hs Œ±) s x) (CategoryTheory.eval S Œ± s x)","decl":"/-- Given a sheaf `S`, construct an equivalence `S(Œ±) ‚âÉ (Œ± ‚Üí S(*))`. -/\n@[simps]\nnoncomputable def evalEquiv (S : Type u·µí·µñ ‚•§ Type u)\n    (hs : Presheaf.IsSheaf typesGrothendieckTopology S)\n    (Œ± : Type u) : S.obj (op Œ±) ‚âÉ (Œ± ‚Üí S.obj (op PUnit)) where\n  toFun := eval S Œ±\n  invFun := typesGlue S ((isSheaf_iff_isSheaf_of_type _ _ ).1 hs) Œ±\n  left_inv := typesGlue_eval\n  right_inv := eval_typesGlue\n\n"}
{"name":"CategoryTheory.eval_map","module":"Mathlib.CategoryTheory.Sites.Types","initialProofState":"S : CategoryTheory.Functor (Opposite (Type u)) (Type u)\nŒ± Œ≤ : Type u\nf : Quiver.Hom Œ≤ Œ±\ns : S.obj { unop := Œ± }\nx : Œ≤\n‚ä¢ Eq (CategoryTheory.eval S Œ≤ (S.map f.op s) x) (CategoryTheory.eval S Œ± s (f x))","decl":"theorem eval_map (S : Type u·µí·µñ ‚•§ Type u) (Œ± Œ≤) (f : Œ≤ ‚ü∂ Œ±) (s x) :\n    eval S Œ≤ (S.map f.op s) x = eval S Œ± s (f x) := by\n  simp_rw [eval, ‚Üê FunctorToTypes.map_comp_apply, ‚Üê op_comp]; rfl\n\n"}
{"name":"CategoryTheory.equivYoneda_inv_app","module":"Mathlib.CategoryTheory.Sites.Types","initialProofState":"S : CategoryTheory.Functor (Opposite (Type u)) (Type u)\nhs : CategoryTheory.Presheaf.IsSheaf CategoryTheory.typesGrothendieckTopology S\nX : Opposite (Type u)\na‚úù : (CategoryTheory.yoneda.obj (S.obj { unop := PUnit.{u + 1} })).obj X\n‚ä¢ Eq ((CategoryTheory.equivYoneda S hs).inv.app X a‚úù) ((CategoryTheory.evalEquiv S hs (Opposite.unop X)).symm a‚úù)","decl":"/-- Given a sheaf `S`, construct an isomorphism `S ‚âÖ [-, S(*)]`. -/\n@[simps!]\nnoncomputable def equivYoneda (S : Type u·µí·µñ ‚•§ Type u)\n    (hs : Presheaf.IsSheaf typesGrothendieckTopology S) :\n    S ‚âÖ yoneda.obj (S.obj (op PUnit)) :=\n  NatIso.ofComponents (fun Œ± => Equiv.toIso <| evalEquiv S hs <| unop Œ±) fun {Œ± Œ≤} f =>\n    funext fun _ => funext fun _ => eval_map S (unop Œ±) (unop Œ≤) f.unop _ _\n\n"}
{"name":"CategoryTheory.equivYoneda_hom_app","module":"Mathlib.CategoryTheory.Sites.Types","initialProofState":"S : CategoryTheory.Functor (Opposite (Type u)) (Type u)\nhs : CategoryTheory.Presheaf.IsSheaf CategoryTheory.typesGrothendieckTopology S\nX : Opposite (Type u)\na‚úù : S.obj X\n‚ä¢ Eq ((CategoryTheory.equivYoneda S hs).hom.app X a‚úù) ((CategoryTheory.evalEquiv S hs (Opposite.unop X)) a‚úù)","decl":"/-- Given a sheaf `S`, construct an isomorphism `S ‚âÖ [-, S(*)]`. -/\n@[simps!]\nnoncomputable def equivYoneda (S : Type u·µí·µñ ‚•§ Type u)\n    (hs : Presheaf.IsSheaf typesGrothendieckTopology S) :\n    S ‚âÖ yoneda.obj (S.obj (op PUnit)) :=\n  NatIso.ofComponents (fun Œ± => Equiv.toIso <| evalEquiv S hs <| unop Œ±) fun {Œ± Œ≤} f =>\n    funext fun _ => funext fun _ => eval_map S (unop Œ±) (unop Œ≤) f.unop _ _\n\n"}
{"name":"CategoryTheory.equivYoneda'_hom_val","module":"Mathlib.CategoryTheory.Sites.Types","initialProofState":"S : CategoryTheory.Sheaf CategoryTheory.typesGrothendieckTopology (Type u)\n‚ä¢ Eq (CategoryTheory.equivYoneda' S).hom.val (CategoryTheory.equivYoneda S.val ‚ãØ).hom","decl":"/-- Given a sheaf `S`, construct an isomorphism `S ‚âÖ [-, S(*)]`. -/\n@[simps]\nnoncomputable def equivYoneda' (S : Sheaf typesGrothendieckTopology (Type u)) :\n    S ‚âÖ yoneda'.obj (S.1.obj (op PUnit)) where\n  hom := ‚ü®(equivYoneda S.1 S.2).hom‚ü©\n  inv := ‚ü®(equivYoneda S.1 S.2).inv‚ü©\n  hom_inv_id := by ext1; apply (equivYoneda S.1 S.2).hom_inv_id\n  inv_hom_id := by ext1; apply (equivYoneda S.1 S.2).inv_hom_id\n\n"}
{"name":"CategoryTheory.equivYoneda'_inv_val","module":"Mathlib.CategoryTheory.Sites.Types","initialProofState":"S : CategoryTheory.Sheaf CategoryTheory.typesGrothendieckTopology (Type u)\n‚ä¢ Eq (CategoryTheory.equivYoneda' S).inv.val (CategoryTheory.equivYoneda S.val ‚ãØ).inv","decl":"/-- Given a sheaf `S`, construct an isomorphism `S ‚âÖ [-, S(*)]`. -/\n@[simps]\nnoncomputable def equivYoneda' (S : Sheaf typesGrothendieckTopology (Type u)) :\n    S ‚âÖ yoneda'.obj (S.1.obj (op PUnit)) where\n  hom := ‚ü®(equivYoneda S.1 S.2).hom‚ü©\n  inv := ‚ü®(equivYoneda S.1 S.2).inv‚ü©\n  hom_inv_id := by ext1; apply (equivYoneda S.1 S.2).hom_inv_id\n  inv_hom_id := by ext1; apply (equivYoneda S.1 S.2).inv_hom_id\n\n"}
{"name":"CategoryTheory.eval_app","module":"Mathlib.CategoryTheory.Sites.Types","initialProofState":"S‚ÇÅ S‚ÇÇ : CategoryTheory.Sheaf CategoryTheory.typesGrothendieckTopology (Type u)\nf : Quiver.Hom S‚ÇÅ S‚ÇÇ\nŒ± : Type u\ns : S‚ÇÅ.val.obj { unop := Œ± }\nx : Œ±\n‚ä¢ Eq (CategoryTheory.eval S‚ÇÇ.val Œ± (f.val.app { unop := Œ± } s) x) (f.val.app { unop := PUnit.{u + 1} } (CategoryTheory.eval S‚ÇÅ.val Œ± s x))","decl":"theorem eval_app (S‚ÇÅ S‚ÇÇ : Sheaf typesGrothendieckTopology (Type u)) (f : S‚ÇÅ ‚ü∂ S‚ÇÇ) (Œ± : Type u)\n    (s : S‚ÇÅ.1.obj (op Œ±)) (x : Œ±) :\n    eval S‚ÇÇ.1 Œ± (f.val.app (op Œ±) s) x = f.val.app (op PUnit) (eval S‚ÇÅ.1 Œ± s x) :=\n  (congr_fun (f.val.naturality (‚Üæfun _ : PUnit => x).op) s).symm\n\n"}
{"name":"CategoryTheory.typeEquiv_functor_obj_val_map","module":"Mathlib.CategoryTheory.Sites.Types","initialProofState":"Œ± : Type u\nX‚úù Y‚úù : Opposite (Type u)\nf : Quiver.Hom X‚úù Y‚úù\ng : Quiver.Hom (Opposite.unop X‚úù) Œ±\na‚úù : Opposite.unop Y‚úù\n‚ä¢ Eq ((CategoryTheory.typeEquiv.functor.obj Œ±).val.map f g a‚úù) (g (f.unop a‚úù))","decl":"/-- `yoneda'` induces an equivalence of category between `Type u` and\n`Sheaf typesGrothendieckTopology (Type u)`. -/\n@[simps!]\nnoncomputable def typeEquiv : Type u ‚âå Sheaf typesGrothendieckTopology (Type u) where\n  functor := yoneda'\n  inverse := sheafToPresheaf _ _ ‚ãô (evaluation _ _).obj (op PUnit)\n  unitIso := NatIso.ofComponents\n      (fun _Œ± => -- Œ± ‚âÖ PUnit ‚ü∂ Œ±\n        { hom := fun x _ => x\n          inv := fun f => f PUnit.unit\n          hom_inv_id := funext fun _ => rfl\n          inv_hom_id := funext fun _ => funext fun y => PUnit.casesOn y rfl })\n      fun _ => rfl\n  counitIso := Iso.symm <|\n      NatIso.ofComponents (fun S => equivYoneda' S) (fun {S‚ÇÅ S‚ÇÇ} f => by\n        ext ‚ü®Œ±‚ü© s\n        dsimp at s ‚ä¢\n        ext x\n        exact eval_app S‚ÇÅ S‚ÇÇ f Œ± s x)\n  functor_unitIso_comp X := by\n    ext1\n    apply yonedaEquiv.injective\n    dsimp [yoneda', yonedaEquiv, evalEquiv]\n    erw [typesGlue_eval]\n\n"}
{"name":"CategoryTheory.typeEquiv_unitIso_hom_app","module":"Mathlib.CategoryTheory.Sites.Types","initialProofState":"X : Type u\na‚úù : (CategoryTheory.Functor.id (Type u)).obj X\n‚ä¢ Eq (CategoryTheory.typeEquiv.unitIso.hom.app X a‚úù) fun x => a‚úù","decl":"/-- `yoneda'` induces an equivalence of category between `Type u` and\n`Sheaf typesGrothendieckTopology (Type u)`. -/\n@[simps!]\nnoncomputable def typeEquiv : Type u ‚âå Sheaf typesGrothendieckTopology (Type u) where\n  functor := yoneda'\n  inverse := sheafToPresheaf _ _ ‚ãô (evaluation _ _).obj (op PUnit)\n  unitIso := NatIso.ofComponents\n      (fun _Œ± => -- Œ± ‚âÖ PUnit ‚ü∂ Œ±\n        { hom := fun x _ => x\n          inv := fun f => f PUnit.unit\n          hom_inv_id := funext fun _ => rfl\n          inv_hom_id := funext fun _ => funext fun y => PUnit.casesOn y rfl })\n      fun _ => rfl\n  counitIso := Iso.symm <|\n      NatIso.ofComponents (fun S => equivYoneda' S) (fun {S‚ÇÅ S‚ÇÇ} f => by\n        ext ‚ü®Œ±‚ü© s\n        dsimp at s ‚ä¢\n        ext x\n        exact eval_app S‚ÇÅ S‚ÇÇ f Œ± s x)\n  functor_unitIso_comp X := by\n    ext1\n    apply yonedaEquiv.injective\n    dsimp [yoneda', yonedaEquiv, evalEquiv]\n    erw [typesGlue_eval]\n\n"}
{"name":"CategoryTheory.typeEquiv_counitIso_hom_app_val_app","module":"Mathlib.CategoryTheory.Sites.Types","initialProofState":"X‚úù : CategoryTheory.Sheaf CategoryTheory.typesGrothendieckTopology (Type u)\nX : Opposite (Type u)\na‚úù : (CategoryTheory.yoneda.obj (X‚úù.val.obj { unop := PUnit.{u + 1} })).obj X\n‚ä¢ Eq ((CategoryTheory.typeEquiv.counitIso.hom.app X‚úù).val.app X a‚úù) ((CategoryTheory.evalEquiv X‚úù.val ‚ãØ (Opposite.unop X)).symm a‚úù)","decl":"/-- `yoneda'` induces an equivalence of category between `Type u` and\n`Sheaf typesGrothendieckTopology (Type u)`. -/\n@[simps!]\nnoncomputable def typeEquiv : Type u ‚âå Sheaf typesGrothendieckTopology (Type u) where\n  functor := yoneda'\n  inverse := sheafToPresheaf _ _ ‚ãô (evaluation _ _).obj (op PUnit)\n  unitIso := NatIso.ofComponents\n      (fun _Œ± => -- Œ± ‚âÖ PUnit ‚ü∂ Œ±\n        { hom := fun x _ => x\n          inv := fun f => f PUnit.unit\n          hom_inv_id := funext fun _ => rfl\n          inv_hom_id := funext fun _ => funext fun y => PUnit.casesOn y rfl })\n      fun _ => rfl\n  counitIso := Iso.symm <|\n      NatIso.ofComponents (fun S => equivYoneda' S) (fun {S‚ÇÅ S‚ÇÇ} f => by\n        ext ‚ü®Œ±‚ü© s\n        dsimp at s ‚ä¢\n        ext x\n        exact eval_app S‚ÇÅ S‚ÇÇ f Œ± s x)\n  functor_unitIso_comp X := by\n    ext1\n    apply yonedaEquiv.injective\n    dsimp [yoneda', yonedaEquiv, evalEquiv]\n    erw [typesGlue_eval]\n\n"}
{"name":"CategoryTheory.typeEquiv_functor_map_val_app","module":"Mathlib.CategoryTheory.Sites.Types","initialProofState":"X‚úù Y‚úù : Type u\nf : Quiver.Hom X‚úù Y‚úù\nx‚úù : Opposite (Type u)\ng : ((fun X => { obj := fun Y => Quiver.Hom (Opposite.unop Y) X, map := fun {X_1 Y} f g => CategoryTheory.CategoryStruct.comp f.unop g, map_id := ‚ãØ, map_comp := ‚ãØ }) X‚úù).obj x‚úù\na‚úù : Opposite.unop x‚úù\n‚ä¢ Eq ((CategoryTheory.typeEquiv.functor.map f).val.app x‚úù g a‚úù) (f (g a‚úù))","decl":"/-- `yoneda'` induces an equivalence of category between `Type u` and\n`Sheaf typesGrothendieckTopology (Type u)`. -/\n@[simps!]\nnoncomputable def typeEquiv : Type u ‚âå Sheaf typesGrothendieckTopology (Type u) where\n  functor := yoneda'\n  inverse := sheafToPresheaf _ _ ‚ãô (evaluation _ _).obj (op PUnit)\n  unitIso := NatIso.ofComponents\n      (fun _Œ± => -- Œ± ‚âÖ PUnit ‚ü∂ Œ±\n        { hom := fun x _ => x\n          inv := fun f => f PUnit.unit\n          hom_inv_id := funext fun _ => rfl\n          inv_hom_id := funext fun _ => funext fun y => PUnit.casesOn y rfl })\n      fun _ => rfl\n  counitIso := Iso.symm <|\n      NatIso.ofComponents (fun S => equivYoneda' S) (fun {S‚ÇÅ S‚ÇÇ} f => by\n        ext ‚ü®Œ±‚ü© s\n        dsimp at s ‚ä¢\n        ext x\n        exact eval_app S‚ÇÅ S‚ÇÇ f Œ± s x)\n  functor_unitIso_comp X := by\n    ext1\n    apply yonedaEquiv.injective\n    dsimp [yoneda', yonedaEquiv, evalEquiv]\n    erw [typesGlue_eval]\n\n"}
{"name":"CategoryTheory.typeEquiv_inverse_map","module":"Mathlib.CategoryTheory.Sites.Types","initialProofState":"X‚úù Y‚úù : CategoryTheory.Sheaf CategoryTheory.typesGrothendieckTopology (Type u)\nf : Quiver.Hom X‚úù Y‚úù\na‚úù : ((CategoryTheory.evaluation (Opposite (Type u)) (Type u)).obj { unop := PUnit.{u + 1} }).obj ((CategoryTheory.sheafToPresheaf CategoryTheory.typesGrothendieckTopology (Type u)).obj X‚úù)\n‚ä¢ Eq (CategoryTheory.typeEquiv.inverse.map f a‚úù) (f.val.app { unop := PUnit.{u + 1} } a‚úù)","decl":"/-- `yoneda'` induces an equivalence of category between `Type u` and\n`Sheaf typesGrothendieckTopology (Type u)`. -/\n@[simps!]\nnoncomputable def typeEquiv : Type u ‚âå Sheaf typesGrothendieckTopology (Type u) where\n  functor := yoneda'\n  inverse := sheafToPresheaf _ _ ‚ãô (evaluation _ _).obj (op PUnit)\n  unitIso := NatIso.ofComponents\n      (fun _Œ± => -- Œ± ‚âÖ PUnit ‚ü∂ Œ±\n        { hom := fun x _ => x\n          inv := fun f => f PUnit.unit\n          hom_inv_id := funext fun _ => rfl\n          inv_hom_id := funext fun _ => funext fun y => PUnit.casesOn y rfl })\n      fun _ => rfl\n  counitIso := Iso.symm <|\n      NatIso.ofComponents (fun S => equivYoneda' S) (fun {S‚ÇÅ S‚ÇÇ} f => by\n        ext ‚ü®Œ±‚ü© s\n        dsimp at s ‚ä¢\n        ext x\n        exact eval_app S‚ÇÅ S‚ÇÇ f Œ± s x)\n  functor_unitIso_comp X := by\n    ext1\n    apply yonedaEquiv.injective\n    dsimp [yoneda', yonedaEquiv, evalEquiv]\n    erw [typesGlue_eval]\n\n"}
{"name":"CategoryTheory.typeEquiv_inverse_obj","module":"Mathlib.CategoryTheory.Sites.Types","initialProofState":"X : CategoryTheory.Sheaf CategoryTheory.typesGrothendieckTopology (Type u)\n‚ä¢ Eq (CategoryTheory.typeEquiv.inverse.obj X) (X.val.obj { unop := PUnit.{u + 1} })","decl":"/-- `yoneda'` induces an equivalence of category between `Type u` and\n`Sheaf typesGrothendieckTopology (Type u)`. -/\n@[simps!]\nnoncomputable def typeEquiv : Type u ‚âå Sheaf typesGrothendieckTopology (Type u) where\n  functor := yoneda'\n  inverse := sheafToPresheaf _ _ ‚ãô (evaluation _ _).obj (op PUnit)\n  unitIso := NatIso.ofComponents\n      (fun _Œ± => -- Œ± ‚âÖ PUnit ‚ü∂ Œ±\n        { hom := fun x _ => x\n          inv := fun f => f PUnit.unit\n          hom_inv_id := funext fun _ => rfl\n          inv_hom_id := funext fun _ => funext fun y => PUnit.casesOn y rfl })\n      fun _ => rfl\n  counitIso := Iso.symm <|\n      NatIso.ofComponents (fun S => equivYoneda' S) (fun {S‚ÇÅ S‚ÇÇ} f => by\n        ext ‚ü®Œ±‚ü© s\n        dsimp at s ‚ä¢\n        ext x\n        exact eval_app S‚ÇÅ S‚ÇÇ f Œ± s x)\n  functor_unitIso_comp X := by\n    ext1\n    apply yonedaEquiv.injective\n    dsimp [yoneda', yonedaEquiv, evalEquiv]\n    erw [typesGlue_eval]\n\n"}
{"name":"CategoryTheory.typeEquiv_counitIso_inv_app_val_app","module":"Mathlib.CategoryTheory.Sites.Types","initialProofState":"X‚úù : CategoryTheory.Sheaf CategoryTheory.typesGrothendieckTopology (Type u)\nX : Opposite (Type u)\na‚úù : X‚úù.val.obj X\n‚ä¢ Eq ((CategoryTheory.typeEquiv.counitIso.inv.app X‚úù).val.app X a‚úù) ((CategoryTheory.evalEquiv X‚úù.val ‚ãØ (Opposite.unop X)) a‚úù)","decl":"/-- `yoneda'` induces an equivalence of category between `Type u` and\n`Sheaf typesGrothendieckTopology (Type u)`. -/\n@[simps!]\nnoncomputable def typeEquiv : Type u ‚âå Sheaf typesGrothendieckTopology (Type u) where\n  functor := yoneda'\n  inverse := sheafToPresheaf _ _ ‚ãô (evaluation _ _).obj (op PUnit)\n  unitIso := NatIso.ofComponents\n      (fun _Œ± => -- Œ± ‚âÖ PUnit ‚ü∂ Œ±\n        { hom := fun x _ => x\n          inv := fun f => f PUnit.unit\n          hom_inv_id := funext fun _ => rfl\n          inv_hom_id := funext fun _ => funext fun y => PUnit.casesOn y rfl })\n      fun _ => rfl\n  counitIso := Iso.symm <|\n      NatIso.ofComponents (fun S => equivYoneda' S) (fun {S‚ÇÅ S‚ÇÇ} f => by\n        ext ‚ü®Œ±‚ü© s\n        dsimp at s ‚ä¢\n        ext x\n        exact eval_app S‚ÇÅ S‚ÇÇ f Œ± s x)\n  functor_unitIso_comp X := by\n    ext1\n    apply yonedaEquiv.injective\n    dsimp [yoneda', yonedaEquiv, evalEquiv]\n    erw [typesGlue_eval]\n\n"}
{"name":"CategoryTheory.typeEquiv_functor_obj_val_obj","module":"Mathlib.CategoryTheory.Sites.Types","initialProofState":"Œ± : Type u\nY : Opposite (Type u)\n‚ä¢ Eq ((CategoryTheory.typeEquiv.functor.obj Œ±).val.obj Y) (Quiver.Hom (Opposite.unop Y) Œ±)","decl":"/-- `yoneda'` induces an equivalence of category between `Type u` and\n`Sheaf typesGrothendieckTopology (Type u)`. -/\n@[simps!]\nnoncomputable def typeEquiv : Type u ‚âå Sheaf typesGrothendieckTopology (Type u) where\n  functor := yoneda'\n  inverse := sheafToPresheaf _ _ ‚ãô (evaluation _ _).obj (op PUnit)\n  unitIso := NatIso.ofComponents\n      (fun _Œ± => -- Œ± ‚âÖ PUnit ‚ü∂ Œ±\n        { hom := fun x _ => x\n          inv := fun f => f PUnit.unit\n          hom_inv_id := funext fun _ => rfl\n          inv_hom_id := funext fun _ => funext fun y => PUnit.casesOn y rfl })\n      fun _ => rfl\n  counitIso := Iso.symm <|\n      NatIso.ofComponents (fun S => equivYoneda' S) (fun {S‚ÇÅ S‚ÇÇ} f => by\n        ext ‚ü®Œ±‚ü© s\n        dsimp at s ‚ä¢\n        ext x\n        exact eval_app S‚ÇÅ S‚ÇÇ f Œ± s x)\n  functor_unitIso_comp X := by\n    ext1\n    apply yonedaEquiv.injective\n    dsimp [yoneda', yonedaEquiv, evalEquiv]\n    erw [typesGlue_eval]\n\n"}
{"name":"CategoryTheory.typeEquiv_unitIso_inv_app","module":"Mathlib.CategoryTheory.Sites.Types","initialProofState":"X : Type u\na‚úù : (CategoryTheory.yoneda'.comp ((CategoryTheory.sheafToPresheaf CategoryTheory.typesGrothendieckTopology (Type u)).comp ((CategoryTheory.evaluation (Opposite (Type u)) (Type u)).obj { unop := PUnit.{u + 1} }))).obj X\n‚ä¢ Eq (CategoryTheory.typeEquiv.unitIso.inv.app X a‚úù) (a‚úù PUnit.unit)","decl":"/-- `yoneda'` induces an equivalence of category between `Type u` and\n`Sheaf typesGrothendieckTopology (Type u)`. -/\n@[simps!]\nnoncomputable def typeEquiv : Type u ‚âå Sheaf typesGrothendieckTopology (Type u) where\n  functor := yoneda'\n  inverse := sheafToPresheaf _ _ ‚ãô (evaluation _ _).obj (op PUnit)\n  unitIso := NatIso.ofComponents\n      (fun _Œ± => -- Œ± ‚âÖ PUnit ‚ü∂ Œ±\n        { hom := fun x _ => x\n          inv := fun f => f PUnit.unit\n          hom_inv_id := funext fun _ => rfl\n          inv_hom_id := funext fun _ => funext fun y => PUnit.casesOn y rfl })\n      fun _ => rfl\n  counitIso := Iso.symm <|\n      NatIso.ofComponents (fun S => equivYoneda' S) (fun {S‚ÇÅ S‚ÇÇ} f => by\n        ext ‚ü®Œ±‚ü© s\n        dsimp at s ‚ä¢\n        ext x\n        exact eval_app S‚ÇÅ S‚ÇÇ f Œ± s x)\n  functor_unitIso_comp X := by\n    ext1\n    apply yonedaEquiv.injective\n    dsimp [yoneda', yonedaEquiv, evalEquiv]\n    erw [typesGlue_eval]\n\n"}
{"name":"CategoryTheory.subcanonical_typesGrothendieckTopology","module":"Mathlib.CategoryTheory.Sites.Types","initialProofState":"‚ä¢ CategoryTheory.typesGrothendieckTopology.Subcanonical","decl":"instance subcanonical_typesGrothendieckTopology : typesGrothendieckTopology.{u}.Subcanonical :=\n  GrothendieckTopology.Subcanonical.of_isSheaf_yoneda_obj _ fun _ => Presieve.isSheaf_yoneda'\n\n"}
{"name":"CategoryTheory.typesGrothendieckTopology_eq_canonical","module":"Mathlib.CategoryTheory.Sites.Types","initialProofState":"‚ä¢ Eq CategoryTheory.typesGrothendieckTopology (CategoryTheory.Sheaf.canonicalTopology (Type u))","decl":"theorem typesGrothendieckTopology_eq_canonical :\n    typesGrothendieckTopology.{u} = Sheaf.canonicalTopology (Type u) := by\n  refine le_antisymm typesGrothendieckTopology.le_canonical (sInf_le ?_)\n  refine ‚ü®yoneda.obj (ULift Bool), ‚ü®_, rfl‚ü©, GrothendieckTopology.ext ?_‚ü©\n  funext Œ±\n  ext S\n  refine ‚ü®fun hs x => ?_, fun hs Œ≤ f => Presieve.isSheaf_yoneda' _ fun y => hs _‚ü©\n  by_contra hsx\n  have : (fun _ => ULift.up true) = fun _ => ULift.up false :=\n    (hs PUnit fun _ => x).isSeparatedFor.ext\n      fun Œ≤ f hf => funext fun y => hsx.elim <| S.2 hf fun _ => y\n  simp [funext_iff] at this\n\n"}
