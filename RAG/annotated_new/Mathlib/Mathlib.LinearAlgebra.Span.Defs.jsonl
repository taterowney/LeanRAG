{"name":"Submodule.isPrincipal_iff","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nS : Submodule R M\n⊢ Iff S.IsPrincipal (Exists fun a => Eq S (Submodule.span R (Singleton.singleton a)))","decl":"/-- An `R`-submodule of `M` is principal if it is generated by one element. -/\n@[mk_iff]\nclass IsPrincipal (S : Submodule R M) : Prop where\n  principal' : ∃ a, S = span R {a}\n\n"}
{"name":"Submodule.IsPrincipal.principal'","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nS : Submodule R M\nself : S.IsPrincipal\n⊢ Exists fun a => Eq S (Submodule.span R (Singleton.singleton a))","decl":"/-- An `R`-submodule of `M` is principal if it is generated by one element. -/\n@[mk_iff]\nclass IsPrincipal (S : Submodule R M) : Prop where\n  principal' : ∃ a, S = span R {a}\n\n"}
{"name":"Submodule.IsPrincipal.principal","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nS : Submodule R M\ninst✝ : S.IsPrincipal\n⊢ Exists fun a => Eq S (Submodule.span R (Singleton.singleton a))","decl":"theorem IsPrincipal.principal (S : Submodule R M) [S.IsPrincipal] :\n    ∃ a, S = span R {a} :=\n  Submodule.IsPrincipal.principal'\n\n"}
{"name":"Submodule.mem_span","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\ns : Set M\n⊢ Iff (Membership.mem (Submodule.span R s) x) (∀ (p : Submodule R M), HasSubset.Subset s ↑p → Membership.mem p x)","decl":"theorem mem_span : x ∈ span R s ↔ ∀ p : Submodule R M, s ⊆ p → x ∈ p :=\n  mem_iInter₂\n\n"}
{"name":"Submodule.subset_span","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set M\n⊢ HasSubset.Subset s ↑(Submodule.span R s)","decl":"@[aesop safe 20 apply (rule_sets := [SetLike])]\ntheorem subset_span : s ⊆ span R s := fun _ h => mem_span.2 fun _ hp => hp h\n\n"}
{"name":"Submodule.span_le","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set M\np : Submodule R M\n⊢ Iff (LE.le (Submodule.span R s) p) (HasSubset.Subset s ↑p)","decl":"theorem span_le {p} : span R s ≤ p ↔ s ⊆ p :=\n  ⟨Subset.trans subset_span, fun ss _ h => mem_span.1 h _ ss⟩\n\n"}
{"name":"Submodule.span_mono","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns t : Set M\nh : HasSubset.Subset s t\n⊢ LE.le (Submodule.span R s) (Submodule.span R t)","decl":"@[gcongr] theorem span_mono (h : s ⊆ t) : span R s ≤ span R t :=\n  span_le.2 <| Subset.trans h subset_span\n\n"}
{"name":"Submodule.span_monotone","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Monotone (Submodule.span R)","decl":"theorem span_monotone : Monotone (span R : Set M → Submodule R M) := fun _ _ => span_mono\n\n"}
{"name":"Submodule.span_eq_of_le","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Submodule R M\ns : Set M\nh₁ : HasSubset.Subset s ↑p\nh₂ : LE.le p (Submodule.span R s)\n⊢ Eq (Submodule.span R s) p","decl":"theorem span_eq_of_le (h₁ : s ⊆ p) (h₂ : p ≤ span R s) : span R s = p :=\n  le_antisymm (span_le.2 h₁) h₂\n\n"}
{"name":"Submodule.span_eq","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Submodule R M\n⊢ Eq (Submodule.span R ↑p) p","decl":"theorem span_eq : span R (p : Set M) = p :=\n  span_eq_of_le _ (Subset.refl _) subset_span\n\n"}
{"name":"Submodule.span_eq_span","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns t : Set M\nhs : HasSubset.Subset s ↑(Submodule.span R t)\nht : HasSubset.Subset t ↑(Submodule.span R s)\n⊢ Eq (Submodule.span R s) (Submodule.span R t)","decl":"theorem span_eq_span (hs : s ⊆ span R t) (ht : t ⊆ span R s) : span R s = span R t :=\n  le_antisymm (span_le.2 hs) (span_le.2 ht)\n\n"}
{"name":"Submodule.coe_span_eq_self","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\nS : Type u_7\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : SetLike S M\ninst✝¹ : AddSubmonoidClass S M\ninst✝ : SMulMemClass S R M\ns : S\n⊢ Eq ↑(Submodule.span R ↑s) ↑s","decl":"/-- A version of `Submodule.span_eq` for subobjects closed under addition and scalar multiplication\nand containing zero. In general, this should not be used directly, but can be used to quickly\ngenerate proofs for specific types of subobjects. -/\nlemma coe_span_eq_self [SetLike S M] [AddSubmonoidClass S M] [SMulMemClass S R M] (s : S) :\n    (span R (s : Set M) : Set M) = s := by\n  refine le_antisymm ?_ subset_span\n  let s' : Submodule R M :=\n    { carrier := s\n      add_mem' := add_mem\n      zero_mem' := zero_mem _\n      smul_mem' := SMulMemClass.smul_mem }\n  exact span_le (p := s') |>.mpr le_rfl\n\n"}
{"name":"Submodule.span_insert_zero","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set M\n⊢ Eq (Submodule.span R (Insert.insert 0 s)) (Submodule.span R s)","decl":"@[simp]\ntheorem span_insert_zero : span R (insert (0 : M) s) = span R s := by\n  refine le_antisymm ?_ (Submodule.span_mono (Set.subset_insert 0 s))\n  rw [span_le, Set.insert_subset_iff]\n  exact ⟨by simp only [SetLike.mem_coe, Submodule.zero_mem], Submodule.subset_span⟩\n\n"}
{"name":"Submodule.closure_subset_span","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set M\n⊢ HasSubset.Subset ↑(AddSubmonoid.closure s) ↑(Submodule.span R s)","decl":"theorem closure_subset_span {s : Set M} : (AddSubmonoid.closure s : Set M) ⊆ span R s :=\n  (@AddSubmonoid.closure_le _ _ _ (span R s).toAddSubmonoid).mpr subset_span\n\n"}
{"name":"Submodule.closure_le_toAddSubmonoid_span","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set M\n⊢ LE.le (AddSubmonoid.closure s) (Submodule.span R s).toAddSubmonoid","decl":"theorem closure_le_toAddSubmonoid_span {s : Set M} :\n    AddSubmonoid.closure s ≤ (span R s).toAddSubmonoid :=\n  closure_subset_span\n\n"}
{"name":"Submodule.span_closure","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set M\n⊢ Eq (Submodule.span R ↑(AddSubmonoid.closure s)) (Submodule.span R s)","decl":"@[simp]\ntheorem span_closure {s : Set M} : span R (AddSubmonoid.closure s : Set M) = span R s :=\n  le_antisymm (span_le.mpr closure_subset_span) (span_mono AddSubmonoid.subset_closure)\n\n"}
{"name":"Submodule.span_induction","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set M\np : (x : M) → Membership.mem (Submodule.span R s) x → Prop\nmem : ∀ (x : M) (h : Membership.mem s x), p x ⋯\nzero : p 0 ⋯\nadd : ∀ (x y : M) (hx : Membership.mem (Submodule.span R s) x) (hy : Membership.mem (Submodule.span R s) y), p x hx → p y hy → p (HAdd.hAdd x y) ⋯\nsmul : ∀ (a : R) (x : M) (hx : Membership.mem (Submodule.span R s) x), p x hx → p (HSMul.hSMul a x) ⋯\nx : M\nhx : Membership.mem (Submodule.span R s) x\n⊢ p x hx","decl":"/-- An induction principle for span membership. If `p` holds for 0 and all elements of `s`, and is\npreserved under addition and scalar multiplication, then `p` holds for all elements of the span of\n`s`. -/\n@[elab_as_elim]\ntheorem span_induction {p : (x : M) → x ∈ span R s → Prop}\n    (mem : ∀ (x) (h : x ∈ s), p x (subset_span h))\n    (zero : p 0 (Submodule.zero_mem _))\n    (add : ∀ x y hx hy, p x hx → p y hy → p (x + y) (Submodule.add_mem _ ‹_› ‹_›))\n    (smul : ∀ (a : R) (x hx), p x hx → p (a • x) (Submodule.smul_mem _ _ ‹_›)) {x}\n    (hx : x ∈ span R s) : p x hx := by\n  let p : Submodule R M :=\n    { carrier := { x | ∃ hx, p x hx }\n      add_mem' := fun ⟨_, hpx⟩ ⟨_, hpy⟩ ↦ ⟨_, add _ _ _ _ hpx hpy⟩\n      zero_mem' := ⟨_, zero⟩\n      smul_mem' := fun r ↦ fun ⟨_, hpx⟩ ↦ ⟨_, smul r _ _ hpx⟩ }\n  exact span_le (p := p) |>.mpr (fun y hy ↦ ⟨subset_span hy, mem y hy⟩) hx |>.elim fun _ ↦ id\n\n"}
{"name":"Submodule.span_induction'","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set M\np : (x : M) → Membership.mem (Submodule.span R s) x → Prop\nmem : ∀ (x : M) (h : Membership.mem s x), p x ⋯\nzero : p 0 ⋯\nadd : ∀ (x y : M) (hx : Membership.mem (Submodule.span R s) x) (hy : Membership.mem (Submodule.span R s) y), p x hx → p y hy → p (HAdd.hAdd x y) ⋯\nsmul : ∀ (a : R) (x : M) (hx : Membership.mem (Submodule.span R s) x), p x hx → p (HSMul.hSMul a x) ⋯\nx : M\nhx : Membership.mem (Submodule.span R s) x\n⊢ p x hx","decl":"@[deprecated span_induction (since := \"2024-10-10\")]\nalias span_induction' := span_induction\n\n"}
{"name":"Submodule.span_induction₂","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ns : Set M\nN : Type u_9\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nt : Set N\np : (x : M) → (y : N) → Membership.mem (Submodule.span R s) x → Membership.mem (Submodule.span R t) y → Prop\nmem_mem : ∀ (x : M) (y : N) (hx : Membership.mem s x) (hy : Membership.mem t y), p x y ⋯ ⋯\nzero_left : ∀ (y : N) (hy : Membership.mem (Submodule.span R t) y), p 0 y ⋯ hy\nzero_right : ∀ (x : M) (hx : Membership.mem (Submodule.span R s) x), p x 0 hx ⋯\nadd_left : ∀ (x y : M) (z : N) (hx : Membership.mem (Submodule.span R s) x) (hy : Membership.mem (Submodule.span R s) y) (hz : Membership.mem (Submodule.span R t) z), p x z hx hz → p y z hy hz → p (HAdd.hAdd x y) z ⋯ hz\nadd_right : ∀ (x : M) (y z : N) (hx : Membership.mem (Submodule.span R s) x) (hy : Membership.mem (Submodule.span R t) y) (hz : Membership.mem (Submodule.span R t) z), p x y hx hy → p x z hx hz → p x (HAdd.hAdd y z) hx ⋯\nsmul_left : ∀ (r : R) (x : M) (y : N) (hx : Membership.mem (Submodule.span R s) x) (hy : Membership.mem (Submodule.span R t) y), p x y hx hy → p (HSMul.hSMul r x) y ⋯ hy\nsmul_right : ∀ (r : R) (x : M) (y : N) (hx : Membership.mem (Submodule.span R s) x) (hy : Membership.mem (Submodule.span R t) y), p x y hx hy → p x (HSMul.hSMul r y) hx ⋯\na : M\nb : N\nha : Membership.mem (Submodule.span R s) a\nhb : Membership.mem (Submodule.span R t) b\n⊢ p a b ha hb","decl":"/-- An induction principle for span membership. This is a version of `Submodule.span_induction`\nfor binary predicates. -/\ntheorem span_induction₂ {N : Type*} [AddCommMonoid N] [Module R N] {t : Set N}\n    {p : (x : M) → (y : N) → x ∈ span R s → y ∈ span R t → Prop}\n    (mem_mem : ∀ (x) (y) (hx : x ∈ s) (hy : y ∈ t), p x y (subset_span hx) (subset_span hy))\n    (zero_left : ∀ y hy, p 0 y (zero_mem _) hy) (zero_right : ∀ x hx, p x 0 hx (zero_mem _))\n    (add_left : ∀ x y z hx hy hz, p x z hx hz → p y z hy hz → p (x + y) z (add_mem hx hy) hz)\n    (add_right : ∀ x y z hx hy hz, p x y hx hy → p x z hx hz → p x (y + z) hx (add_mem hy hz))\n    (smul_left : ∀ (r : R) x y hx hy, p x y hx hy → p (r • x) y (smul_mem _ r hx) hy)\n    (smul_right : ∀ (r : R) x y hx hy, p x y hx hy → p x (r • y) hx (smul_mem _ r hy))\n    {a : M} {b : N} (ha : a ∈ Submodule.span R s)\n    (hb : b ∈ Submodule.span R t) : p a b ha hb := by\n  induction hb using span_induction with\n  | mem z hz => induction ha using span_induction with\n    | mem _ h => exact mem_mem _ _ h hz\n    | zero => exact zero_left _ _\n    | add _ _ _ _ h₁ h₂ => exact add_left _ _ _ _ _ _ h₁ h₂\n    | smul _ _ _ h => exact smul_left _ _ _ _ _ h\n  | zero => exact zero_right a ha\n  | add _ _ _ _ h₁ h₂ => exact add_right _ _ _ _ _ _ h₁ h₂\n  | smul _ _ _ h => exact smul_right _ _ _ _ _ h\n\n"}
{"name":"Submodule.span_eq_closure","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set M\n⊢ Eq (Submodule.span R s).toAddSubmonoid (AddSubmonoid.closure (HSMul.hSMul Set.univ s))","decl":"open AddSubmonoid in\ntheorem span_eq_closure {s : Set M} : (span R s).toAddSubmonoid = closure (@univ R • s) := by\n  refine le_antisymm (fun x (hx : x ∈ span R s) ↦ ?of_mem_span) (fun x hx ↦ ?of_mem_closure)\n  case of_mem_span =>\n    induction hx using span_induction with\n    | mem x hx => exact subset_closure ⟨1, trivial, x, hx, one_smul R x⟩\n    | zero => exact zero_mem _\n    | add _ _ _ _ h₁ h₂ => exact add_mem h₁ h₂\n    | smul r₁ y _h hy =>\n      clear _h\n      induction hy using AddSubmonoid.closure_induction with\n      | mem _ h =>\n        obtain ⟨r₂, -, x, hx, rfl⟩ := h\n        exact subset_closure ⟨r₁ * r₂, trivial, x, hx, mul_smul ..⟩\n      | one => simpa only [smul_zero] using zero_mem _\n      | mul _ _ _ _ h₁ h₂ => simpa only [smul_add] using add_mem h₁ h₂\n  case of_mem_closure =>\n    refine closure_le.2 ?_ hx\n    rintro - ⟨r, -, x, hx, rfl⟩\n    exact smul_mem _ _ (subset_span hx)\n\n"}
{"name":"Submodule.closure_induction","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set M\np : (x : M) → Membership.mem (Submodule.span R s) x → Prop\nzero : p 0 ⋯\nadd : ∀ (x y : M) (hx : Membership.mem (Submodule.span R s) x) (hy : Membership.mem (Submodule.span R s) y), p x hx → p y hy → p (HAdd.hAdd x y) ⋯\nsmul_mem : ∀ (r : R) (x : M) (h : Membership.mem s x), p (HSMul.hSMul r x) ⋯\nx : M\nhx : Membership.mem (Submodule.span R s) x\n⊢ p x hx","decl":"open AddSubmonoid in\n/-- A variant of `span_induction` that combines `∀ x ∈ s, p x` and `∀ r x, p x → p (r • x)`\ninto a single condition `∀ r, ∀ x ∈ s, p (r • x)`, which can be easier to verify. -/\n@[elab_as_elim]\ntheorem closure_induction {p : (x : M) → x ∈ span R s → Prop}\n    (zero : p 0 (Submodule.zero_mem _))\n    (add : ∀ x y hx hy, p x hx → p y hy → p (x + y) (Submodule.add_mem _ ‹_› ‹_›))\n    (smul_mem : ∀ (r x) (h : x ∈ s), p (r • x) (Submodule.smul_mem _ _ <| subset_span h)) {x}\n    (hx : x ∈ span R s) : p x hx := by\n  have key {v} : v ∈ span R s ↔ v ∈ closure (@univ R • s) := by simp [← span_eq_closure]\n  refine AddSubmonoid.closure_induction (p := fun x hx ↦ p x (key.mpr hx))\n    ?_ zero (by simpa only [key] using add) (key.mp hx)\n  rintro - ⟨r, -, x, hx, rfl⟩\n  exact smul_mem r x hx\n\n"}
{"name":"Submodule.closure_induction'","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set M\np : (x : M) → Membership.mem (Submodule.span R s) x → Prop\nzero : p 0 ⋯\nadd : ∀ (x y : M) (hx : Membership.mem (Submodule.span R s) x) (hy : Membership.mem (Submodule.span R s) y), p x hx → p y hy → p (HAdd.hAdd x y) ⋯\nsmul_mem : ∀ (r : R) (x : M) (h : Membership.mem s x), p (HSMul.hSMul r x) ⋯\nx : M\nhx : Membership.mem (Submodule.span R s) x\n⊢ p x hx","decl":"@[deprecated closure_induction (since := \"2024-10-10\")]\nalias closure_induction' := closure_induction\n\n"}
{"name":"Submodule.span_span_coe_preimage","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set M\n⊢ Eq (Submodule.span R (Set.preimage Subtype.val s)) Top.top","decl":"@[simp]\ntheorem span_span_coe_preimage : span R (((↑) : span R s → M) ⁻¹' s) = ⊤ :=\n  eq_top_iff.2 fun x _ ↦ Subtype.recOn x fun _ hx' ↦\n    span_induction (fun _ h ↦ subset_span h) (zero_mem _) (fun _ _ _ _ ↦ add_mem)\n      (fun _ _ _ ↦ smul_mem _ _) hx'\n\n"}
{"name":"Submodule.span_setOf_mem_eq_top","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set M\n⊢ Eq (Submodule.span R (setOf fun x => Membership.mem s ↑x)) Top.top","decl":"@[simp]\nlemma span_setOf_mem_eq_top :\n    span R {x : span R s | (x : M) ∈ s} = ⊤ :=\n  span_span_coe_preimage\n\n"}
{"name":"Submodule.span_nat_eq_addSubmonoid_closure","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"M : Type u_4\ninst✝ : AddCommMonoid M\ns : Set M\n⊢ Eq (Submodule.span Nat s).toAddSubmonoid (AddSubmonoid.closure s)","decl":"theorem span_nat_eq_addSubmonoid_closure (s : Set M) :\n    (span ℕ s).toAddSubmonoid = AddSubmonoid.closure s := by\n  refine Eq.symm (AddSubmonoid.closure_eq_of_le subset_span ?_)\n  apply (OrderIso.to_galoisConnection (AddSubmonoid.toNatSubmodule (M := M)).symm).l_le\n     (a := span ℕ s) (b := AddSubmonoid.closure s)\n  rw [span_le]\n  exact AddSubmonoid.subset_closure\n\n"}
{"name":"Submodule.span_nat_eq","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"M : Type u_4\ninst✝ : AddCommMonoid M\ns : AddSubmonoid M\n⊢ Eq (Submodule.span Nat ↑s).toAddSubmonoid s","decl":"@[simp]\ntheorem span_nat_eq (s : AddSubmonoid M) : (span ℕ (s : Set M)).toAddSubmonoid = s := by\n  rw [span_nat_eq_addSubmonoid_closure, s.closure_eq]\n\n"}
{"name":"Submodule.span_int_eq_addSubgroup_closure","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"M : Type u_9\ninst✝ : AddCommGroup M\ns : Set M\n⊢ Eq (Submodule.span Int s).toAddSubgroup (AddSubgroup.closure s)","decl":"theorem span_int_eq_addSubgroup_closure {M : Type*} [AddCommGroup M] (s : Set M) :\n    (span ℤ s).toAddSubgroup = AddSubgroup.closure s :=\n  Eq.symm <|\n    AddSubgroup.closure_eq_of_le _ subset_span fun _ hx =>\n      span_induction (fun _ hx => AddSubgroup.subset_closure hx) (AddSubgroup.zero_mem _)\n        (fun _ _ _ _ => AddSubgroup.add_mem _) (fun _ _ _ _ => AddSubgroup.zsmul_mem _ ‹_› _) hx\n\n"}
{"name":"Submodule.span_int_eq","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"M : Type u_9\ninst✝ : AddCommGroup M\ns : AddSubgroup M\n⊢ Eq (Submodule.span Int ↑s).toAddSubgroup s","decl":"@[simp]\ntheorem span_int_eq {M : Type*} [AddCommGroup M] (s : AddSubgroup M) :\n    (span ℤ (s : Set M)).toAddSubgroup = s := by rw [span_int_eq_addSubgroup_closure, s.closure_eq]\n\n"}
{"name":"Submodule.span_empty","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (Submodule.span R EmptyCollection.emptyCollection) Bot.bot","decl":"@[simp]\ntheorem span_empty : span R (∅ : Set M) = ⊥ :=\n  (Submodule.gi R M).gc.l_bot\n\n"}
{"name":"Submodule.span_univ","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (Submodule.span R Set.univ) Top.top","decl":"@[simp]\ntheorem span_univ : span R (univ : Set M) = ⊤ :=\n  eq_top_iff.2 <| SetLike.le_def.2 <| subset_span\n\n"}
{"name":"Submodule.span_union","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns t : Set M\n⊢ Eq (Submodule.span R (Union.union s t)) (Max.max (Submodule.span R s) (Submodule.span R t))","decl":"theorem span_union (s t : Set M) : span R (s ∪ t) = span R s ⊔ span R t :=\n  (Submodule.gi R M).gc.l_sup\n\n"}
{"name":"Submodule.span_iUnion","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Sort u_9\ns : ι → Set M\n⊢ Eq (Submodule.span R (Set.iUnion fun i => s i)) (iSup fun i => Submodule.span R (s i))","decl":"theorem span_iUnion {ι} (s : ι → Set M) : span R (⋃ i, s i) = ⨆ i, span R (s i) :=\n  (Submodule.gi R M).gc.l_iSup\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Submodule.span_iUnion₂","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Sort u_10\nκ : ι → Sort u_9\ns : (i : ι) → κ i → Set M\n⊢ Eq (Submodule.span R (Set.iUnion fun i => Set.iUnion fun j => s i j)) (iSup fun i => iSup fun j => Submodule.span R (s i j))","decl":"theorem span_iUnion₂ {ι} {κ : ι → Sort*} (s : ∀ i, κ i → Set M) :\n    span R (⋃ (i) (j), s i j) = ⨆ (i) (j), span R (s i j) :=\n  (Submodule.gi R M).gc.l_iSup₂\n\n"}
{"name":"Submodule.span_attach_biUnion","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : DecidableEq M\nα : Type u_9\ns : Finset α\nf : (Subtype fun x => Membership.mem s x) → Finset M\n⊢ Eq (Submodule.span R ↑(s.attach.biUnion f)) (iSup fun x => Submodule.span R ↑(f x))","decl":"theorem span_attach_biUnion [DecidableEq M] {α : Type*} (s : Finset α) (f : s → Finset M) :\n    span R (s.attach.biUnion f : Set M) = ⨆ x, span R (f x) := by simp [span_iUnion]\n\n"}
{"name":"Submodule.sup_span","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Submodule R M\ns : Set M\n⊢ Eq (Max.max p (Submodule.span R s)) (Submodule.span R (Union.union (↑p) s))","decl":"theorem sup_span : p ⊔ span R s = span R (p ∪ s) := by rw [Submodule.span_union, p.span_eq]\n\n"}
{"name":"Submodule.span_sup","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Submodule R M\ns : Set M\n⊢ Eq (Max.max (Submodule.span R s) p) (Submodule.span R (Union.union s ↑p))","decl":"theorem span_sup : span R s ⊔ p = span R (s ∪ p) := by rw [Submodule.span_union, p.span_eq]\n\n"}
{"name":"Submodule.span_eq_iSup_of_singleton_spans","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set M\n⊢ Eq (Submodule.span R s) (iSup fun x => iSup fun h => Submodule.span R (Singleton.singleton x))","decl":"theorem span_eq_iSup_of_singleton_spans (s : Set M) : span R s = ⨆ x ∈ s, R ∙ x := by\n  simp only [← span_iUnion, Set.biUnion_of_singleton s]\n\n"}
{"name":"Submodule.span_range_eq_iSup","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Sort u_9\nv : ι → M\n⊢ Eq (Submodule.span R (Set.range v)) (iSup fun i => Submodule.span R (Singleton.singleton (v i)))","decl":"theorem span_range_eq_iSup {ι : Sort*} {v : ι → M} : span R (range v) = ⨆ i, R ∙ v i := by\n  rw [span_eq_iSup_of_singleton_spans, iSup_range]\n\n"}
{"name":"Submodule.span_smul_le","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set M\nr : R\n⊢ LE.le (Submodule.span R (HSMul.hSMul r s)) (Submodule.span R s)","decl":"theorem span_smul_le (s : Set M) (r : R) : span R (r • s) ≤ span R s := by\n  rw [span_le]\n  rintro _ ⟨x, hx, rfl⟩\n  exact smul_mem (span R s) r (subset_span hx)\n\n"}
{"name":"Submodule.subset_span_trans","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nU V W : Set M\nhUV : HasSubset.Subset U ↑(Submodule.span R V)\nhVW : HasSubset.Subset V ↑(Submodule.span R W)\n⊢ HasSubset.Subset U ↑(Submodule.span R W)","decl":"theorem subset_span_trans {U V W : Set M} (hUV : U ⊆ Submodule.span R V)\n    (hVW : V ⊆ Submodule.span R W) : U ⊆ Submodule.span R W :=\n  (Submodule.gi R M).gc.le_u_l_trans hUV hVW\n\n"}
{"name":"Submodule.coe_iSup_of_directed","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nι : Sort u_9\ninst✝ : Nonempty ι\nS : ι → Submodule R M\nH : Directed (fun x1 x2 => LE.le x1 x2) S\n⊢ Eq (↑(iSup S)) (Set.iUnion fun i => ↑(S i))","decl":"@[simp]\ntheorem coe_iSup_of_directed {ι} [Nonempty ι] (S : ι → Submodule R M)\n    (H : Directed (· ≤ ·) S) : ((iSup S : Submodule R M) : Set M) = ⋃ i, S i :=\n  let s : Submodule R M :=\n    { __ := AddSubmonoid.copy _ _ (AddSubmonoid.coe_iSup_of_directed H).symm\n      smul_mem' := fun r _ hx ↦ have ⟨i, hi⟩ := Set.mem_iUnion.mp hx\n        Set.mem_iUnion.mpr ⟨i, (S i).smul_mem' r hi⟩ }\n  have : iSup S = s := le_antisymm\n    (iSup_le fun i ↦ le_iSup (fun i ↦ (S i : Set M)) i) (Set.iUnion_subset fun _ ↦ le_iSup S _)\n  this.symm ▸ rfl\n\n"}
{"name":"Submodule.mem_iSup_of_directed","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nι : Sort u_9\ninst✝ : Nonempty ι\nS : ι → Submodule R M\nH : Directed (fun x1 x2 => LE.le x1 x2) S\nx : M\n⊢ Iff (Membership.mem (iSup S) x) (Exists fun i => Membership.mem (S i) x)","decl":"@[simp]\ntheorem mem_iSup_of_directed {ι} [Nonempty ι] (S : ι → Submodule R M) (H : Directed (· ≤ ·) S) {x} :\n    x ∈ iSup S ↔ ∃ i, x ∈ S i := by\n  rw [← SetLike.mem_coe, coe_iSup_of_directed S H, mem_iUnion]\n  rfl\n\n"}
{"name":"Submodule.mem_sSup_of_directed","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set (Submodule R M)\nz : M\nhs : s.Nonempty\nhdir : DirectedOn (fun x1 x2 => LE.le x1 x2) s\n⊢ Iff (Membership.mem (SupSet.sSup s) z) (Exists fun y => And (Membership.mem s y) (Membership.mem y z))","decl":"theorem mem_sSup_of_directed {s : Set (Submodule R M)} {z} (hs : s.Nonempty)\n    (hdir : DirectedOn (· ≤ ·) s) : z ∈ sSup s ↔ ∃ y ∈ s, z ∈ y := by\n  have : Nonempty s := hs.to_subtype\n  simp only [sSup_eq_iSup', mem_iSup_of_directed _ hdir.directed_val, SetCoe.exists, Subtype.coe_mk,\n    exists_prop]\n\n"}
{"name":"Submodule.coe_iSup_of_chain","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na : OrderHom Nat (Submodule R M)\n⊢ Eq (↑(iSup fun k => a k)) (Set.iUnion fun k => ↑(a k))","decl":"@[norm_cast, simp]\ntheorem coe_iSup_of_chain (a : ℕ →o Submodule R M) : (↑(⨆ k, a k) : Set M) = ⋃ k, (a k : Set M) :=\n  coe_iSup_of_directed a a.monotone.directed_le\n\n"}
{"name":"Submodule.mem_iSup_of_chain","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na : OrderHom Nat (Submodule R M)\nm : M\n⊢ Iff (Membership.mem (iSup fun k => a k) m) (Exists fun k => Membership.mem (a k) m)","decl":"@[simp]\ntheorem mem_iSup_of_chain (a : ℕ →o Submodule R M) (m : M) : (m ∈ ⨆ k, a k) ↔ ∃ k, m ∈ a k :=\n  mem_iSup_of_directed a a.monotone.directed_le\n\n"}
{"name":"Submodule.mem_sup","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\np p' : Submodule R M\n⊢ Iff (Membership.mem (Max.max p p') x) (Exists fun y => And (Membership.mem p y) (Exists fun z => And (Membership.mem p' z) (Eq (HAdd.hAdd y z) x)))","decl":"theorem mem_sup : x ∈ p ⊔ p' ↔ ∃ y ∈ p, ∃ z ∈ p', y + z = x :=\n  ⟨fun h => by\n    rw [← span_eq p, ← span_eq p', ← span_union] at h\n    refine span_induction ?_ ?_ ?_ ?_ h\n    · rintro y (h | h)\n      · exact ⟨y, h, 0, by simp, by simp⟩\n      · exact ⟨0, by simp, y, h, by simp⟩\n    · exact ⟨0, by simp, 0, by simp⟩\n    · rintro _ _ - - ⟨y₁, hy₁, z₁, hz₁, rfl⟩ ⟨y₂, hy₂, z₂, hz₂, rfl⟩\n      exact ⟨_, add_mem hy₁ hy₂, _, add_mem hz₁ hz₂, by\n        rw [add_assoc, add_assoc, ← add_assoc y₂, ← add_assoc z₁, add_comm y₂]⟩\n    · rintro a - _ ⟨y, hy, z, hz, rfl⟩\n      exact ⟨_, smul_mem _ a hy, _, smul_mem _ a hz, by simp [smul_add]⟩, by\n    rintro ⟨y, hy, z, hz, rfl⟩\n    exact add_mem ((le_sup_left : p ≤ p ⊔ p') hy) ((le_sup_right : p' ≤ p ⊔ p') hz)⟩\n\n"}
{"name":"Submodule.mem_sup'","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\np p' : Submodule R M\n⊢ Iff (Membership.mem (Max.max p p') x) (Exists fun y => Exists fun z => Eq (HAdd.hAdd ↑y ↑z) x)","decl":"theorem mem_sup' : x ∈ p ⊔ p' ↔ ∃ (y : p) (z : p'), (y : M) + z = x :=\n  mem_sup.trans <| by simp only [Subtype.exists, exists_prop]\n\n"}
{"name":"Submodule.exists_add_eq_of_codisjoint","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np p' : Submodule R M\nh : Codisjoint p p'\nx : M\n⊢ Exists fun y => And (Membership.mem p y) (Exists fun z => And (Membership.mem p' z) (Eq (HAdd.hAdd y z) x))","decl":"lemma exists_add_eq_of_codisjoint (h : Codisjoint p p') (x : M) :\n    ∃ y ∈ p, ∃ z ∈ p', y + z = x := by\n  suffices x ∈ p ⊔ p' by exact Submodule.mem_sup.mp this\n  simpa only [h.eq_top] using Submodule.mem_top\n\n"}
{"name":"Submodule.coe_sup","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np p' : Submodule R M\n⊢ Eq (↑(Max.max p p')) (HAdd.hAdd ↑p ↑p')","decl":"theorem coe_sup : ↑(p ⊔ p') = (p + p' : Set M) := by\n  ext\n  rw [SetLike.mem_coe, mem_sup, Set.mem_add]\n  simp\n\n"}
{"name":"Submodule.sup_toAddSubmonoid","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np p' : Submodule R M\n⊢ Eq (Max.max p p').toAddSubmonoid (Max.max p.toAddSubmonoid p'.toAddSubmonoid)","decl":"theorem sup_toAddSubmonoid : (p ⊔ p').toAddSubmonoid = p.toAddSubmonoid ⊔ p'.toAddSubmonoid := by\n  ext x\n  rw [mem_toAddSubmonoid, mem_sup, AddSubmonoid.mem_sup]\n  rfl\n\n"}
{"name":"Submodule.mem_span_singleton_self","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\n⊢ Membership.mem (Submodule.span R (Singleton.singleton x)) x","decl":"theorem mem_span_singleton_self (x : M) : x ∈ R ∙ x :=\n  subset_span rfl\n\n"}
{"name":"Submodule.nontrivial_span_singleton","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\nh : Ne x 0\n⊢ Nontrivial (Subtype fun x_1 => Membership.mem (Submodule.span R (Singleton.singleton x)) x_1)","decl":"theorem nontrivial_span_singleton {x : M} (h : x ≠ 0) : Nontrivial (R ∙ x) :=\n  ⟨by\n    use 0, ⟨x, Submodule.mem_span_singleton_self x⟩\n    intro H\n    rw [eq_comm, Submodule.mk_eq_zero] at H\n    exact h H⟩\n\n"}
{"name":"Submodule.mem_span_singleton","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx y : M\n⊢ Iff (Membership.mem (Submodule.span R (Singleton.singleton y)) x) (Exists fun a => Eq (HSMul.hSMul a y) x)","decl":"theorem mem_span_singleton {y : M} : (x ∈ R ∙ y) ↔ ∃ a : R, a • y = x :=\n  ⟨fun h => by\n    refine span_induction ?_ ?_ ?_ ?_ h\n    · rintro y (rfl | ⟨⟨_⟩⟩)\n      exact ⟨1, by simp⟩\n    · exact ⟨0, by simp⟩\n    · rintro _ _ - - ⟨a, rfl⟩ ⟨b, rfl⟩\n      exact ⟨a + b, by simp [add_smul]⟩\n    · rintro a _ - ⟨b, rfl⟩\n      exact ⟨a * b, by simp [smul_smul]⟩, by\n    rintro ⟨a, y, rfl⟩; exact smul_mem _ _ (subset_span <| by simp)⟩\n\n"}
{"name":"Submodule.le_span_singleton_iff","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Submodule R M\nv₀ : M\n⊢ Iff (LE.le s (Submodule.span R (Singleton.singleton v₀))) (∀ (v : M), Membership.mem s v → Exists fun r => Eq (HSMul.hSMul r v₀) v)","decl":"theorem le_span_singleton_iff {s : Submodule R M} {v₀ : M} :\n    (s ≤ R ∙ v₀) ↔ ∀ v ∈ s, ∃ r : R, r • v₀ = v := by simp_rw [SetLike.le_def, mem_span_singleton]\n\n"}
{"name":"Submodule.span_singleton_eq_top_iff","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\n⊢ Iff (Eq (Submodule.span R (Singleton.singleton x)) Top.top) (∀ (v : M), Exists fun r => Eq (HSMul.hSMul r x) v)","decl":"theorem span_singleton_eq_top_iff (x : M) : (R ∙ x) = ⊤ ↔ ∀ v, ∃ r : R, r • x = v := by\n  rw [eq_top_iff, le_span_singleton_iff]\n  tauto\n\n"}
{"name":"Submodule.span_zero_singleton","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (Submodule.span R (Singleton.singleton 0)) Bot.bot","decl":"@[simp]\ntheorem span_zero_singleton : (R ∙ (0 : M)) = ⊥ := by\n  ext\n  simp [mem_span_singleton, eq_comm]\n\n"}
{"name":"Submodule.span_singleton_eq_range","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ny : M\n⊢ Eq (↑(Submodule.span R (Singleton.singleton y))) (Set.range fun x => HSMul.hSMul x y)","decl":"theorem span_singleton_eq_range (y : M) : ↑(R ∙ y) = range ((· • y) : R → M) :=\n  Set.ext fun _ => mem_span_singleton\n\n"}
{"name":"Submodule.span_singleton_smul_le","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nS : Type u_9\ninst✝³ : Monoid S\ninst✝² : SMul S R\ninst✝¹ : MulAction S M\ninst✝ : IsScalarTower S R M\nr : S\nx : M\n⊢ LE.le (Submodule.span R (Singleton.singleton (HSMul.hSMul r x))) (Submodule.span R (Singleton.singleton x))","decl":"theorem span_singleton_smul_le {S} [Monoid S] [SMul S R] [MulAction S M] [IsScalarTower S R M]\n    (r : S) (x : M) : (R ∙ r • x) ≤ R ∙ x := by\n  rw [span_le, Set.singleton_subset_iff, SetLike.mem_coe]\n  exact smul_of_tower_mem _ _ (mem_span_singleton_self _)\n\n"}
{"name":"Submodule.span_singleton_group_smul_eq","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nG : Type u_9\ninst✝³ : Group G\ninst✝² : SMul G R\ninst✝¹ : MulAction G M\ninst✝ : IsScalarTower G R M\ng : G\nx : M\n⊢ Eq (Submodule.span R (Singleton.singleton (HSMul.hSMul g x))) (Submodule.span R (Singleton.singleton x))","decl":"theorem span_singleton_group_smul_eq {G} [Group G] [SMul G R] [MulAction G M] [IsScalarTower G R M]\n    (g : G) (x : M) : (R ∙ g • x) = R ∙ x := by\n  refine le_antisymm (span_singleton_smul_le R g x) ?_\n  convert span_singleton_smul_le R g⁻¹ (g • x)\n  exact (inv_smul_smul g x).symm\n\n"}
{"name":"Submodule.span_singleton_smul_eq","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nr : R\nhr : IsUnit r\nx : M\n⊢ Eq (Submodule.span R (Singleton.singleton (HSMul.hSMul r x))) (Submodule.span R (Singleton.singleton x))","decl":"theorem span_singleton_smul_eq {r : R} (hr : IsUnit r) (x : M) : (R ∙ r • x) = R ∙ x := by\n  lift r to Rˣ using hr\n  rw [← Units.smul_def]\n  exact span_singleton_group_smul_eq R r x\n\n"}
{"name":"Submodule.mem_span_singleton_trans","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx y z : M\nhxy : Membership.mem (Submodule.span R (Singleton.singleton y)) x\nhyz : Membership.mem (Submodule.span R (Singleton.singleton z)) y\n⊢ Membership.mem (Submodule.span R (Singleton.singleton z)) x","decl":"theorem mem_span_singleton_trans {x y z : M} (hxy : x ∈ R ∙ y) (hyz : y ∈ R ∙ z) : x ∈ R ∙ z := by\n  rw [← SetLike.mem_coe, ← singleton_subset_iff] at *\n  exact Submodule.subset_span_trans hxy hyz\n\n"}
{"name":"Submodule.span_insert","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\ns : Set M\n⊢ Eq (Submodule.span R (Insert.insert x s)) (Max.max (Submodule.span R (Singleton.singleton x)) (Submodule.span R s))","decl":"theorem span_insert (x) (s : Set M) : span R (insert x s) = (R ∙ x) ⊔ span R s := by\n  rw [insert_eq, span_union]\n\n"}
{"name":"Submodule.span_insert_eq_span","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\ns : Set M\nh : Membership.mem (Submodule.span R s) x\n⊢ Eq (Submodule.span R (Insert.insert x s)) (Submodule.span R s)","decl":"theorem span_insert_eq_span (h : x ∈ span R s) : span R (insert x s) = span R s :=\n  span_eq_of_le _ (Set.insert_subset_iff.mpr ⟨h, subset_span⟩) (span_mono <| subset_insert _ _)\n\n"}
{"name":"Submodule.span_span","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set M\n⊢ Eq (Submodule.span R ↑(Submodule.span R s)) (Submodule.span R s)","decl":"theorem span_span : span R (span R s : Set M) = span R s :=\n  span_eq _\n\n"}
{"name":"Submodule.mem_span_insert","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\ns : Set M\ny : M\n⊢ Iff (Membership.mem (Submodule.span R (Insert.insert y s)) x) (Exists fun a => Exists fun z => And (Membership.mem (Submodule.span R s) z) (Eq x (HAdd.hAdd (HSMul.hSMul a y) z)))","decl":"theorem mem_span_insert {y} :\n    x ∈ span R (insert y s) ↔ ∃ a : R, ∃ z ∈ span R s, x = a • y + z := by\n  simp [span_insert, mem_sup, mem_span_singleton, eq_comm (a := x)]\n\n"}
{"name":"Submodule.mem_span_pair","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx y z : M\n⊢ Iff (Membership.mem (Submodule.span R (Insert.insert x (Singleton.singleton y))) z) (Exists fun a => Exists fun b => Eq (HAdd.hAdd (HSMul.hSMul a x) (HSMul.hSMul b y)) z)","decl":"theorem mem_span_pair {x y z : M} :\n    z ∈ span R ({x, y} : Set M) ↔ ∃ a b : R, a • x + b • y = z := by\n  simp_rw [mem_span_insert, mem_span_singleton, exists_exists_eq_and, eq_comm]\n\n"}
{"name":"Submodule.span_eq_bot","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set M\n⊢ Iff (Eq (Submodule.span R s) Bot.bot) (∀ (x : M), Membership.mem s x → Eq x 0)","decl":"theorem span_eq_bot : span R (s : Set M) = ⊥ ↔ ∀ x ∈ s, (x : M) = 0 :=\n  eq_bot_iff.trans\n    ⟨fun H _ h => (mem_bot R).1 <| H <| subset_span h, fun H =>\n      span_le.2 fun x h => (mem_bot R).2 <| H x h⟩\n\n"}
{"name":"Submodule.span_singleton_eq_bot","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\n⊢ Iff (Eq (Submodule.span R (Singleton.singleton x)) Bot.bot) (Eq x 0)","decl":"@[simp]\ntheorem span_singleton_eq_bot : (R ∙ x) = ⊥ ↔ x = 0 :=\n  span_eq_bot.trans <| by simp\n\n"}
{"name":"Submodule.span_zero","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (Submodule.span R 0) Bot.bot","decl":"@[simp]\ntheorem span_zero : span R (0 : Set M) = ⊥ := by rw [← singleton_zero, span_singleton_eq_bot]\n\n"}
{"name":"Submodule.span_singleton_le_iff_mem","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nm : M\np : Submodule R M\n⊢ Iff (LE.le (Submodule.span R (Singleton.singleton m)) p) (Membership.mem p m)","decl":"@[simp]\ntheorem span_singleton_le_iff_mem (m : M) (p : Submodule R M) : (R ∙ m) ≤ p ↔ m ∈ p := by\n  rw [span_le, singleton_subset_iff, SetLike.mem_coe]\n\n"}
{"name":"Submodule.iSup_span","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Sort u_9\np : ι → Set M\n⊢ Eq (iSup fun i => Submodule.span R (p i)) (Submodule.span R (Set.iUnion fun i => p i))","decl":"theorem iSup_span {ι : Sort*} (p : ι → Set M) : ⨆ i, span R (p i) = span R (⋃ i, p i) :=\n  le_antisymm (iSup_le fun i => span_mono <| subset_iUnion _ i) <|\n    span_le.mpr <| iUnion_subset fun i _ hm => mem_iSup_of_mem i <| subset_span hm\n\n"}
{"name":"Submodule.iSup_eq_span","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Sort u_9\np : ι → Submodule R M\n⊢ Eq (iSup fun i => p i) (Submodule.span R (Set.iUnion fun i => ↑(p i)))","decl":"theorem iSup_eq_span {ι : Sort*} (p : ι → Submodule R M) : ⨆ i, p i = span R (⋃ i, ↑(p i)) := by\n  simp_rw [← iSup_span, span_eq]\n\n"}
{"name":"Submodule.submodule_eq_sSup_le_nonzero_spans","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Submodule R M\n⊢ Eq p (SupSet.sSup (setOf fun T => Exists fun m => And (Membership.mem p m) (And (Ne m 0) (Eq T (Submodule.span R (Singleton.singleton m))))))","decl":"/-- A submodule is equal to the supremum of the spans of the submodule's nonzero elements. -/\ntheorem submodule_eq_sSup_le_nonzero_spans (p : Submodule R M) :\n    p = sSup { T : Submodule R M | ∃ m ∈ p, m ≠ 0 ∧ T = span R {m} } := by\n  let S := { T : Submodule R M | ∃ m ∈ p, m ≠ 0 ∧ T = span R {m} }\n  apply le_antisymm\n  · intro m hm\n    by_cases h : m = 0\n    · rw [h]\n      simp\n    · exact @le_sSup _ _ S _ ⟨m, ⟨hm, ⟨h, rfl⟩⟩⟩ m (mem_span_singleton_self m)\n  · rw [sSup_le_iff]\n    rintro S ⟨_, ⟨_, ⟨_, rfl⟩⟩⟩\n    rwa [span_singleton_le_iff_mem]\n\n"}
{"name":"Submodule.lt_sup_iff_not_mem","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nI : Submodule R M\na : M\n⊢ Iff (LT.lt I (Max.max I (Submodule.span R (Singleton.singleton a)))) (Not (Membership.mem I a))","decl":"theorem lt_sup_iff_not_mem {I : Submodule R M} {a : M} : (I < I ⊔ R ∙ a) ↔ a ∉ I := by simp\n\n"}
{"name":"Submodule.mem_iSup","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Sort u_9\np : ι → Submodule R M\nm : M\n⊢ Iff (Membership.mem (iSup fun i => p i) m) (∀ (N : Submodule R M), (∀ (i : ι), LE.le (p i) N) → Membership.mem N m)","decl":"theorem mem_iSup {ι : Sort*} (p : ι → Submodule R M) {m : M} :\n    (m ∈ ⨆ i, p i) ↔ ∀ N, (∀ i, p i ≤ N) → m ∈ N := by\n  rw [← span_singleton_le_iff_mem, le_iSup_iff]\n  simp only [span_singleton_le_iff_mem]\n\n"}
{"name":"Submodule.mem_sSup","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set (Submodule R M)\nm : M\n⊢ Iff (Membership.mem (SupSet.sSup s) m) (∀ (N : Submodule R M), (∀ (p : Submodule R M), Membership.mem s p → LE.le p N) → Membership.mem N m)","decl":"theorem mem_sSup {s : Set (Submodule R M)} {m : M} :\n    (m ∈ sSup s) ↔ ∀ N, (∀ p ∈ s, p ≤ N) → m ∈ N := by\n  simp_rw [sSup_eq_iSup, Submodule.mem_iSup, iSup_le_iff]\n\n"}
{"name":"Submodule.mem_span_finite_of_mem_span","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nS : Set M\nx : M\nhx : Membership.mem (Submodule.span R S) x\n⊢ Exists fun T => And (HasSubset.Subset (↑T) S) (Membership.mem (Submodule.span R ↑T) x)","decl":"/-- For every element in the span of a set, there exists a finite subset of the set\nsuch that the element is contained in the span of the subset. -/\ntheorem mem_span_finite_of_mem_span {S : Set M} {x : M} (hx : x ∈ span R S) :\n    ∃ T : Finset M, ↑T ⊆ S ∧ x ∈ span R (T : Set M) := by\n  classical\n  refine span_induction (fun x hx => ?_) ?_ ?_ ?_ hx\n  · refine ⟨{x}, ?_, ?_⟩\n    · rwa [Finset.coe_singleton, Set.singleton_subset_iff]\n    · rw [Finset.coe_singleton]\n      exact Submodule.mem_span_singleton_self x\n  · use ∅\n    simp\n  · rintro x y - - ⟨X, hX, hxX⟩ ⟨Y, hY, hyY⟩\n    refine ⟨X ∪ Y, ?_, ?_⟩\n    · rw [Finset.coe_union]\n      exact Set.union_subset hX hY\n    rw [Finset.coe_union, span_union, mem_sup]\n    exact ⟨x, hxX, y, hyY, rfl⟩\n  · rintro a x - ⟨T, hT, h2⟩\n    exact ⟨T, hT, smul_mem _ _ h2⟩\n\n"}
{"name":"Submodule.sup_toAddSubgroup","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np p' : Submodule R M\n⊢ Eq (Max.max p p').toAddSubgroup (Max.max p.toAddSubgroup p'.toAddSubgroup)","decl":"lemma sup_toAddSubgroup (p p' : Submodule R M) :\n    (p ⊔ p').toAddSubgroup = p.toAddSubgroup ⊔ p'.toAddSubgroup := by\n  ext x\n  rw [mem_toAddSubgroup, mem_sup, AddSubgroup.mem_sup]\n  rfl\n\n"}
{"name":"Submodule.mem_span_insert'","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : M\ns : Set M\n⊢ Iff (Membership.mem (Submodule.span R (Insert.insert y s)) x) (Exists fun a => Membership.mem (Submodule.span R s) (HAdd.hAdd x (HSMul.hSMul a y)))","decl":"theorem mem_span_insert' {x y} {s : Set M} :\n    x ∈ span R (insert y s) ↔ ∃ a : R, x + a • y ∈ span R s := by\n  rw [mem_span_insert]; constructor\n  · rintro ⟨a, z, hz, rfl⟩\n    exact ⟨-a, by simp [hz, add_assoc]⟩\n  · rintro ⟨a, h⟩\n    exact ⟨-a, _, h, by simp [add_comm, add_left_comm]⟩\n\n"}
{"name":"Submodule.span_range_update_add_smul","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nι : Type u_8\ninst✝ : DecidableEq ι\ni j : ι\nhij : Ne i j\nv : ι → M\nr : R\n⊢ Eq (Submodule.span R (Set.range (Function.update v j (HAdd.hAdd (v j) (HSMul.hSMul r (v i)))))) (Submodule.span R (Set.range v))","decl":"lemma span_range_update_add_smul (hij : i ≠ j) (v : ι → M) (r : R) :\n    span R (Set.range (Function.update v j (v j + r • v i))) = span R (Set.range v) := by\n  refine le_antisymm ?_ ?_ <;> simp only [span_le, Set.range_subset_iff, SetLike.mem_coe] <;>\n    intro k <;> obtain rfl | hjk := eq_or_ne j k\n  · rw [update_self]\n    exact add_mem (subset_span ⟨j, rfl⟩) <| smul_mem _ _ <| subset_span ⟨i, rfl⟩\n  · exact subset_span ⟨k, (update_of_ne hjk.symm ..).symm⟩\n  · nth_rw 2 [← add_sub_cancel_right (v j) (r • v i)]\n    exact sub_mem (subset_span ⟨j, update_self ..⟩)\n      (smul_mem _ _ (subset_span ⟨i, update_of_ne hij ..⟩))\n  · exact subset_span ⟨k, update_of_ne hjk.symm ..⟩\n\n"}
{"name":"Submodule.span_range_update_sub_smul","module":"Mathlib.LinearAlgebra.Span.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nι : Type u_8\ninst✝ : DecidableEq ι\ni j : ι\nhij : Ne i j\nv : ι → M\nr : R\n⊢ Eq (Submodule.span R (Set.range (Function.update v j (HSub.hSub (v j) (HSMul.hSMul r (v i)))))) (Submodule.span R (Set.range v))","decl":"lemma span_range_update_sub_smul (hij : i ≠ j) (v : ι → M) (r : R) :\n    span R (Set.range (Function.update v j (v j - r • v i))) = span R (Set.range v) := by\n  rw [sub_eq_add_neg, ← neg_smul, span_range_update_add_smul hij]\n\n"}
