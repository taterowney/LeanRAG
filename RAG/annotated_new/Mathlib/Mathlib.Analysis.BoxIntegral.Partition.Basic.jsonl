{"name":"BoxIntegral.Prepartition.mk.sizeOf_spec","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ninst✝ : SizeOf ι\nboxes : Finset (BoxIntegral.Box ι)\nle_of_mem' : ∀ (J : BoxIntegral.Box ι), Membership.mem boxes J → LE.le J I\npairwiseDisjoint : (↑boxes).Pairwise (Function.onFun Disjoint BoxIntegral.Box.toSet)\n⊢ Eq (SizeOf.sizeOf { boxes := boxes, le_of_mem' := le_of_mem', pairwiseDisjoint := pairwiseDisjoint }) (HAdd.hAdd 1 (SizeOf.sizeOf boxes))","decl":"/-- A prepartition of `I : BoxIntegral.Box ι` is a finite set of pairwise disjoint subboxes of\n`I`. -/\nstructure Prepartition (I : Box ι) where\n  /-- The underlying set of boxes -/\n  boxes : Finset (Box ι)\n  /-- Each box is a sub-box of `I` -/\n  le_of_mem' : ∀ J ∈ boxes, J ≤ I\n  /-- The boxes in a prepartition are pairwise disjoint. -/\n  pairwiseDisjoint : Set.Pairwise (↑boxes) (Disjoint on ((↑) : Box ι → Set (ι → ℝ)))\n\n"}
{"name":"BoxIntegral.Prepartition.mk.injEq","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nboxes✝ : Finset (BoxIntegral.Box ι)\nle_of_mem'✝ : ∀ (J : BoxIntegral.Box ι), Membership.mem boxes✝ J → LE.le J I\npairwiseDisjoint✝ : (↑boxes✝).Pairwise (Function.onFun Disjoint BoxIntegral.Box.toSet)\nboxes : Finset (BoxIntegral.Box ι)\nle_of_mem' : ∀ (J : BoxIntegral.Box ι), Membership.mem boxes J → LE.le J I\npairwiseDisjoint : (↑boxes).Pairwise (Function.onFun Disjoint BoxIntegral.Box.toSet)\n⊢ Eq (Eq { boxes := boxes✝, le_of_mem' := le_of_mem'✝, pairwiseDisjoint := pairwiseDisjoint✝ } { boxes := boxes, le_of_mem' := le_of_mem', pairwiseDisjoint := pairwiseDisjoint }) (Eq boxes✝ boxes)","decl":"/-- A prepartition of `I : BoxIntegral.Box ι` is a finite set of pairwise disjoint subboxes of\n`I`. -/\nstructure Prepartition (I : Box ι) where\n  /-- The underlying set of boxes -/\n  boxes : Finset (Box ι)\n  /-- Each box is a sub-box of `I` -/\n  le_of_mem' : ∀ J ∈ boxes, J ≤ I\n  /-- The boxes in a prepartition are pairwise disjoint. -/\n  pairwiseDisjoint : Set.Pairwise (↑boxes) (Disjoint on ((↑) : Box ι → Set (ι → ℝ)))\n\n"}
{"name":"BoxIntegral.Prepartition.pairwiseDisjoint","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nself : BoxIntegral.Prepartition I\n⊢ (↑self.boxes).Pairwise (Function.onFun Disjoint BoxIntegral.Box.toSet)","decl":"/-- A prepartition of `I : BoxIntegral.Box ι` is a finite set of pairwise disjoint subboxes of\n`I`. -/\nstructure Prepartition (I : Box ι) where\n  /-- The underlying set of boxes -/\n  boxes : Finset (Box ι)\n  /-- Each box is a sub-box of `I` -/\n  le_of_mem' : ∀ J ∈ boxes, J ≤ I\n  /-- The boxes in a prepartition are pairwise disjoint. -/\n  pairwiseDisjoint : Set.Pairwise (↑boxes) (Disjoint on ((↑) : Box ι → Set (ι → ℝ)))\n\n"}
{"name":"BoxIntegral.Prepartition.mk.inj","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nboxes✝ : Finset (BoxIntegral.Box ι)\nle_of_mem'✝ : ∀ (J : BoxIntegral.Box ι), Membership.mem boxes✝ J → LE.le J I\npairwiseDisjoint✝ : (↑boxes✝).Pairwise (Function.onFun Disjoint BoxIntegral.Box.toSet)\nboxes : Finset (BoxIntegral.Box ι)\nle_of_mem' : ∀ (J : BoxIntegral.Box ι), Membership.mem boxes J → LE.le J I\npairwiseDisjoint : (↑boxes).Pairwise (Function.onFun Disjoint BoxIntegral.Box.toSet)\nx✝ : Eq { boxes := boxes✝, le_of_mem' := le_of_mem'✝, pairwiseDisjoint := pairwiseDisjoint✝ } { boxes := boxes, le_of_mem' := le_of_mem', pairwiseDisjoint := pairwiseDisjoint }\n⊢ Eq boxes✝ boxes","decl":"/-- A prepartition of `I : BoxIntegral.Box ι` is a finite set of pairwise disjoint subboxes of\n`I`. -/\nstructure Prepartition (I : Box ι) where\n  /-- The underlying set of boxes -/\n  boxes : Finset (Box ι)\n  /-- Each box is a sub-box of `I` -/\n  le_of_mem' : ∀ J ∈ boxes, J ≤ I\n  /-- The boxes in a prepartition are pairwise disjoint. -/\n  pairwiseDisjoint : Set.Pairwise (↑boxes) (Disjoint on ((↑) : Box ι → Set (ι → ℝ)))\n\n"}
{"name":"BoxIntegral.Prepartition.le_of_mem'","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nself : BoxIntegral.Prepartition I\nJ : BoxIntegral.Box ι\na✝ : Membership.mem self.boxes J\n⊢ LE.le J I","decl":"/-- A prepartition of `I : BoxIntegral.Box ι` is a finite set of pairwise disjoint subboxes of\n`I`. -/\nstructure Prepartition (I : Box ι) where\n  /-- The underlying set of boxes -/\n  boxes : Finset (Box ι)\n  /-- Each box is a sub-box of `I` -/\n  le_of_mem' : ∀ J ∈ boxes, J ≤ I\n  /-- The boxes in a prepartition are pairwise disjoint. -/\n  pairwiseDisjoint : Set.Pairwise (↑boxes) (Disjoint on ((↑) : Box ι → Set (ι → ℝ)))\n\n"}
{"name":"BoxIntegral.Prepartition.mem_boxes","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\n⊢ Iff (Membership.mem π.boxes J) (Membership.mem π J)","decl":"@[simp]\ntheorem mem_boxes : J ∈ π.boxes ↔ J ∈ π := Iff.rfl\n\n"}
{"name":"BoxIntegral.Prepartition.mem_mk","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\ns : Finset (BoxIntegral.Box ι)\nh₁ : ∀ (J : BoxIntegral.Box ι), Membership.mem s J → LE.le J I\nh₂ : (↑s).Pairwise (Function.onFun Disjoint BoxIntegral.Box.toSet)\n⊢ Iff (Membership.mem { boxes := s, le_of_mem' := h₁, pairwiseDisjoint := h₂ } J) (Membership.mem s J)","decl":"@[simp]\ntheorem mem_mk {s h₁ h₂} : J ∈ (mk s h₁ h₂ : Prepartition I) ↔ J ∈ s := Iff.rfl\n\n"}
{"name":"BoxIntegral.Prepartition.disjoint_coe_of_mem","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J₁ J₂ : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nh₁ : Membership.mem π J₁\nh₂ : Membership.mem π J₂\nh : Ne J₁ J₂\n⊢ Disjoint ↑J₁ ↑J₂","decl":"theorem disjoint_coe_of_mem (h₁ : J₁ ∈ π) (h₂ : J₂ ∈ π) (h : J₁ ≠ J₂) :\n    Disjoint (J₁ : Set (ι → ℝ)) J₂ :=\n  π.pairwiseDisjoint h₁ h₂ h\n\n"}
{"name":"BoxIntegral.Prepartition.eq_of_mem_of_mem","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J₁ J₂ : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nx : ι → Real\nh₁ : Membership.mem π J₁\nh₂ : Membership.mem π J₂\nhx₁ : Membership.mem J₁ x\nhx₂ : Membership.mem J₂ x\n⊢ Eq J₁ J₂","decl":"theorem eq_of_mem_of_mem (h₁ : J₁ ∈ π) (h₂ : J₂ ∈ π) (hx₁ : x ∈ J₁) (hx₂ : x ∈ J₂) : J₁ = J₂ :=\n  by_contra fun H => (π.disjoint_coe_of_mem h₁ h₂ H).le_bot ⟨hx₁, hx₂⟩\n\n"}
{"name":"BoxIntegral.Prepartition.eq_of_le_of_le","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J J₁ J₂ : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nh₁ : Membership.mem π J₁\nh₂ : Membership.mem π J₂\nhle₁ : LE.le J J₁\nhle₂ : LE.le J J₂\n⊢ Eq J₁ J₂","decl":"theorem eq_of_le_of_le (h₁ : J₁ ∈ π) (h₂ : J₂ ∈ π) (hle₁ : J ≤ J₁) (hle₂ : J ≤ J₂) : J₁ = J₂ :=\n  π.eq_of_mem_of_mem h₁ h₂ (hle₁ J.upper_mem) (hle₂ J.upper_mem)\n\n"}
{"name":"BoxIntegral.Prepartition.eq_of_le","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J₁ J₂ : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nh₁ : Membership.mem π J₁\nh₂ : Membership.mem π J₂\nhle : LE.le J₁ J₂\n⊢ Eq J₁ J₂","decl":"theorem eq_of_le (h₁ : J₁ ∈ π) (h₂ : J₂ ∈ π) (hle : J₁ ≤ J₂) : J₁ = J₂ :=\n  π.eq_of_le_of_le h₁ h₂ le_rfl hle\n\n"}
{"name":"BoxIntegral.Prepartition.le_of_mem","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nhJ : Membership.mem π J\n⊢ LE.le J I","decl":"theorem le_of_mem (hJ : J ∈ π) : J ≤ I :=\n  π.le_of_mem' J hJ\n\n"}
{"name":"BoxIntegral.Prepartition.lower_le_lower","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nhJ : Membership.mem π J\n⊢ LE.le I.lower J.lower","decl":"theorem lower_le_lower (hJ : J ∈ π) : I.lower ≤ J.lower :=\n  Box.antitone_lower (π.le_of_mem hJ)\n\n"}
{"name":"BoxIntegral.Prepartition.upper_le_upper","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nhJ : Membership.mem π J\n⊢ LE.le J.upper I.upper","decl":"theorem upper_le_upper (hJ : J ∈ π) : J.upper ≤ I.upper :=\n  Box.monotone_upper (π.le_of_mem hJ)\n\n"}
{"name":"BoxIntegral.Prepartition.injective_boxes","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\n⊢ Function.Injective BoxIntegral.Prepartition.boxes","decl":"theorem injective_boxes : Function.Injective (boxes : Prepartition I → Finset (Box ι)) := by\n  rintro ⟨s₁, h₁, h₁'⟩ ⟨s₂, h₂, h₂'⟩ (rfl : s₁ = s₂)\n  rfl\n\n"}
{"name":"BoxIntegral.Prepartition.ext_iff","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ₁ π₂ : BoxIntegral.Prepartition I\n⊢ Iff (Eq π₁ π₂) (∀ (J : BoxIntegral.Box ι), Iff (Membership.mem π₁ J) (Membership.mem π₂ J))","decl":"@[ext]\ntheorem ext (h : ∀ J, J ∈ π₁ ↔ J ∈ π₂) : π₁ = π₂ :=\n  injective_boxes <| Finset.ext h\n\n"}
{"name":"BoxIntegral.Prepartition.ext","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ₁ π₂ : BoxIntegral.Prepartition I\nh : ∀ (J : BoxIntegral.Box ι), Iff (Membership.mem π₁ J) (Membership.mem π₂ J)\n⊢ Eq π₁ π₂","decl":"@[ext]\ntheorem ext (h : ∀ J, J ∈ π₁ ↔ J ∈ π₂) : π₁ = π₂ :=\n  injective_boxes <| Finset.ext h\n\n"}
{"name":"BoxIntegral.Prepartition.single_boxes","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nh : LE.le J I\n⊢ Eq (BoxIntegral.Prepartition.single I J h).boxes (Singleton.singleton J)","decl":"/-- The singleton prepartition `{J}`, `J ≤ I`. -/\n@[simps]\ndef single (I J : Box ι) (h : J ≤ I) : Prepartition I :=\n  ⟨{J}, by simpa, by simp⟩\n\n"}
{"name":"BoxIntegral.Prepartition.mem_single","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J J' : BoxIntegral.Box ι\nh : LE.le J I\n⊢ Iff (Membership.mem (BoxIntegral.Prepartition.single I J h) J') (Eq J' J)","decl":"@[simp]\ntheorem mem_single {J'} (h : J ≤ I) : J' ∈ single I J h ↔ J' = J :=\n  mem_singleton\n\n"}
{"name":"BoxIntegral.Prepartition.le_def","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ₁ π₂ : BoxIntegral.Prepartition I\n⊢ Iff (LE.le π₁ π₂) (∀ (J : BoxIntegral.Box ι), Membership.mem π₁ J → Exists fun J' => And (Membership.mem π₂ J') (LE.le J J'))","decl":"theorem le_def : π₁ ≤ π₂ ↔ ∀ J ∈ π₁, ∃ J' ∈ π₂, J ≤ J' := Iff.rfl\n\n"}
{"name":"BoxIntegral.Prepartition.mem_top","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\n⊢ Iff (Membership.mem Top.top J) (Eq J I)","decl":"@[simp]\ntheorem mem_top : J ∈ (⊤ : Prepartition I) ↔ J = I :=\n  mem_singleton\n\n"}
{"name":"BoxIntegral.Prepartition.top_boxes","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\n⊢ Eq Top.top.boxes (Singleton.singleton I)","decl":"@[simp]\ntheorem top_boxes : (⊤ : Prepartition I).boxes = {I} := rfl\n\n"}
{"name":"BoxIntegral.Prepartition.not_mem_bot","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\n⊢ Not (Membership.mem Bot.bot J)","decl":"@[simp]\ntheorem not_mem_bot : J ∉ (⊥ : Prepartition I) :=\n  Finset.not_mem_empty _\n\n"}
{"name":"BoxIntegral.Prepartition.bot_boxes","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\n⊢ Eq Bot.bot.boxes EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem bot_boxes : (⊥ : Prepartition I).boxes = ∅ := rfl\n\n"}
{"name":"BoxIntegral.Prepartition.injOn_setOf_mem_Icc_setOf_lower_eq","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nx : ι → Real\n⊢ Set.InjOn (fun J => setOf fun i => Eq (J.lower i) (x i)) (setOf fun J => And (Membership.mem π J) (Membership.mem (BoxIntegral.Box.Icc J) x))","decl":"/-- An auxiliary lemma used to prove that the same point can't belong to more than\n`2 ^ Fintype.card ι` closed boxes of a prepartition. -/\ntheorem injOn_setOf_mem_Icc_setOf_lower_eq (x : ι → ℝ) :\n    InjOn (fun J : Box ι => { i | J.lower i = x i }) { J | J ∈ π ∧ x ∈ Box.Icc J } := by\n  rintro J₁ ⟨h₁, hx₁⟩ J₂ ⟨h₂, hx₂⟩ (H : { i | J₁.lower i = x i } = { i | J₂.lower i = x i })\n  suffices ∀ i, (Ioc (J₁.lower i) (J₁.upper i) ∩ Ioc (J₂.lower i) (J₂.upper i)).Nonempty by\n    choose y hy₁ hy₂ using this\n    exact π.eq_of_mem_of_mem h₁ h₂ hy₁ hy₂\n  intro i\n  simp only [Set.ext_iff, mem_setOf] at H\n  rcases (hx₁.1 i).eq_or_lt with hi₁ | hi₁\n  · have hi₂ : J₂.lower i = x i := (H _).1 hi₁\n    have H₁ : x i < J₁.upper i := by simpa only [hi₁] using J₁.lower_lt_upper i\n    have H₂ : x i < J₂.upper i := by simpa only [hi₂] using J₂.lower_lt_upper i\n    rw [Ioc_inter_Ioc, hi₁, hi₂, sup_idem, Set.nonempty_Ioc]\n    exact lt_min H₁ H₂\n  · have hi₂ : J₂.lower i < x i := (hx₂.1 i).lt_of_ne (mt (H _).2 hi₁.ne)\n    exact ⟨x i, ⟨hi₁, hx₁.2 i⟩, ⟨hi₂, hx₂.2 i⟩⟩\n\n"}
{"name":"BoxIntegral.Prepartition.card_filter_mem_Icc_le","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\ninst✝ : Fintype ι\nx : ι → Real\n⊢ LE.le (Finset.filter (fun J => Membership.mem (BoxIntegral.Box.Icc J) x) π.boxes).card (HPow.hPow 2 (Fintype.card ι))","decl":"open scoped Classical in\n/-- The set of boxes of a prepartition that contain `x` in their closures has cardinality\nat most `2 ^ Fintype.card ι`. -/\ntheorem card_filter_mem_Icc_le [Fintype ι] (x : ι → ℝ) :\n    #{J ∈ π.boxes | x ∈ Box.Icc J} ≤ 2 ^ Fintype.card ι := by\n  rw [← Fintype.card_set]\n  refine Finset.card_le_card_of_injOn (fun J : Box ι => { i | J.lower i = x i })\n    (fun _ _ => Finset.mem_univ _) ?_\n  simpa using π.injOn_setOf_mem_Icc_setOf_lower_eq x\n\n"}
{"name":"BoxIntegral.Prepartition.iUnion_def","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\n⊢ Eq π.iUnion (Set.iUnion fun J => Set.iUnion fun h => ↑J)","decl":"theorem iUnion_def : π.iUnion = ⋃ J ∈ π, ↑J := rfl\n\n"}
{"name":"BoxIntegral.Prepartition.iUnion_def'","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\n⊢ Eq π.iUnion (Set.iUnion fun J => Set.iUnion fun h => ↑J)","decl":"theorem iUnion_def' : π.iUnion = ⋃ J ∈ π.boxes, ↑J := rfl\n\n-- Porting note: Previous proof was `:= Set.mem_iUnion₂`\n"}
{"name":"BoxIntegral.Prepartition.mem_iUnion","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nx : ι → Real\n⊢ Iff (Membership.mem π.iUnion x) (Exists fun J => And (Membership.mem π J) (Membership.mem J x))","decl":"@[simp]\ntheorem mem_iUnion : x ∈ π.iUnion ↔ ∃ J ∈ π, x ∈ J := by\n  convert Set.mem_iUnion₂\n  rw [Box.mem_coe, exists_prop]\n\n"}
{"name":"BoxIntegral.Prepartition.iUnion_single","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nh : LE.le J I\n⊢ Eq (BoxIntegral.Prepartition.single I J h).iUnion ↑J","decl":"@[simp]\ntheorem iUnion_single (h : J ≤ I) : (single I J h).iUnion = J := by simp [iUnion_def]\n\n"}
{"name":"BoxIntegral.Prepartition.iUnion_top","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\n⊢ Eq Top.top.iUnion ↑I","decl":"@[simp]\ntheorem iUnion_top : (⊤ : Prepartition I).iUnion = I := by simp [Prepartition.iUnion]\n\n"}
{"name":"BoxIntegral.Prepartition.iUnion_eq_empty","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ₁ : BoxIntegral.Prepartition I\n⊢ Iff (Eq π₁.iUnion EmptyCollection.emptyCollection) (Eq π₁ Bot.bot)","decl":"@[simp]\ntheorem iUnion_eq_empty : π₁.iUnion = ∅ ↔ π₁ = ⊥ := by\n  simp [← injective_boxes.eq_iff, Finset.ext_iff, Prepartition.iUnion, imp_false]\n\n"}
{"name":"BoxIntegral.Prepartition.iUnion_bot","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\n⊢ Eq Bot.bot.iUnion EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem iUnion_bot : (⊥ : Prepartition I).iUnion = ∅ :=\n  iUnion_eq_empty.2 rfl\n\n"}
{"name":"BoxIntegral.Prepartition.subset_iUnion","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nh : Membership.mem π J\n⊢ HasSubset.Subset (↑J) π.iUnion","decl":"theorem subset_iUnion (h : J ∈ π) : ↑J ⊆ π.iUnion :=\n  subset_biUnion_of_mem h\n\n"}
{"name":"BoxIntegral.Prepartition.iUnion_subset","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\n⊢ HasSubset.Subset π.iUnion ↑I","decl":"theorem iUnion_subset : π.iUnion ⊆ I :=\n  iUnion₂_subset π.le_of_mem'\n\n"}
{"name":"BoxIntegral.Prepartition.iUnion_mono","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ₁ π₂ : BoxIntegral.Prepartition I\nh : LE.le π₁ π₂\n⊢ HasSubset.Subset π₁.iUnion π₂.iUnion","decl":"@[mono]\ntheorem iUnion_mono (h : π₁ ≤ π₂) : π₁.iUnion ⊆ π₂.iUnion := fun _ hx =>\n  let ⟨_, hJ₁, hx⟩ := π₁.mem_iUnion.1 hx\n  let ⟨J₂, hJ₂, hle⟩ := h hJ₁\n  π₂.mem_iUnion.2 ⟨J₂, hJ₂, hle hx⟩\n\n"}
{"name":"BoxIntegral.Prepartition.disjoint_boxes_of_disjoint_iUnion","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ₁ π₂ : BoxIntegral.Prepartition I\nh : Disjoint π₁.iUnion π₂.iUnion\n⊢ Disjoint π₁.boxes π₂.boxes","decl":"theorem disjoint_boxes_of_disjoint_iUnion (h : Disjoint π₁.iUnion π₂.iUnion) :\n    Disjoint π₁.boxes π₂.boxes :=\n  Finset.disjoint_left.2 fun J h₁ h₂ =>\n    Disjoint.le_bot (h.mono (π₁.subset_iUnion h₁) (π₂.subset_iUnion h₂)) ⟨J.upper_mem, J.upper_mem⟩\n\n"}
{"name":"BoxIntegral.Prepartition.le_iff_nonempty_imp_le_and_iUnion_subset","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ₁ π₂ : BoxIntegral.Prepartition I\n⊢ Iff (LE.le π₁ π₂) (And (∀ (J : BoxIntegral.Box ι), Membership.mem π₁ J → ∀ (J' : BoxIntegral.Box ι), Membership.mem π₂ J' → (Inter.inter ↑J ↑J').Nonempty → LE.le J J') (HasSubset.Subset π₁.iUnion π₂.iUnion))","decl":"theorem le_iff_nonempty_imp_le_and_iUnion_subset :\n    π₁ ≤ π₂ ↔\n      (∀ J ∈ π₁, ∀ J' ∈ π₂, (J ∩ J' : Set (ι → ℝ)).Nonempty → J ≤ J') ∧ π₁.iUnion ⊆ π₂.iUnion := by\n  constructor\n  · refine fun H => ⟨fun J hJ J' hJ' Hne => ?_, iUnion_mono H⟩\n    rcases H hJ with ⟨J'', hJ'', Hle⟩\n    rcases Hne with ⟨x, hx, hx'⟩\n    rwa [π₂.eq_of_mem_of_mem hJ' hJ'' hx' (Hle hx)]\n  · rintro ⟨H, HU⟩ J hJ\n    simp only [Set.subset_def, mem_iUnion] at HU\n    rcases HU J.upper ⟨J, hJ, J.upper_mem⟩ with ⟨J₂, hJ₂, hx⟩\n    exact ⟨J₂, hJ₂, H _ hJ _ hJ₂ ⟨_, J.upper_mem, hx⟩⟩\n\n"}
{"name":"BoxIntegral.Prepartition.eq_of_boxes_subset_iUnion_superset","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ₁ π₂ : BoxIntegral.Prepartition I\nh₁ : HasSubset.Subset π₁.boxes π₂.boxes\nh₂ : HasSubset.Subset π₂.iUnion π₁.iUnion\n⊢ Eq π₁ π₂","decl":"theorem eq_of_boxes_subset_iUnion_superset (h₁ : π₁.boxes ⊆ π₂.boxes) (h₂ : π₂.iUnion ⊆ π₁.iUnion) :\n    π₁ = π₂ :=\n  le_antisymm (fun J hJ => ⟨J, h₁ hJ, le_rfl⟩) <|\n    le_iff_nonempty_imp_le_and_iUnion_subset.2\n      ⟨fun _ hJ₁ _ hJ₂ Hne =>\n        (π₂.eq_of_mem_of_mem hJ₁ (h₁ hJ₂) Hne.choose_spec.1 Hne.choose_spec.2).le, h₂⟩\n\n"}
{"name":"BoxIntegral.Prepartition.biUnion_boxes","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nπi : (J : BoxIntegral.Box ι) → BoxIntegral.Prepartition J\n⊢ Eq (π.biUnion πi).boxes (π.boxes.biUnion fun J => (πi J).boxes)","decl":"open scoped Classical in\n/-- Given a prepartition `π` of a box `I` and a collection of prepartitions `πi J` of all boxes\n`J ∈ π`, returns the prepartition of `I` into the union of the boxes of all `πi J`.\n\nThough we only use the values of `πi` on the boxes of `π`, we require `πi` to be a globally defined\nfunction. -/\n@[simps]\ndef biUnion (πi : ∀ J : Box ι, Prepartition J) : Prepartition I where\n  boxes := π.boxes.biUnion fun J => (πi J).boxes\n  le_of_mem' J hJ := by\n    simp only [Finset.mem_biUnion, exists_prop, mem_boxes] at hJ\n    rcases hJ with ⟨J', hJ', hJ⟩\n    exact ((πi J').le_of_mem hJ).trans (π.le_of_mem hJ')\n  pairwiseDisjoint := by\n    simp only [Set.Pairwise, Finset.mem_coe, Finset.mem_biUnion]\n    rintro J₁' ⟨J₁, hJ₁, hJ₁'⟩ J₂' ⟨J₂, hJ₂, hJ₂'⟩ Hne\n    rw [Function.onFun, Set.disjoint_left]\n    rintro x hx₁ hx₂; apply Hne\n    obtain rfl : J₁ = J₂ :=\n      π.eq_of_mem_of_mem hJ₁ hJ₂ ((πi J₁).le_of_mem hJ₁' hx₁) ((πi J₂).le_of_mem hJ₂' hx₂)\n    exact (πi J₁).eq_of_mem_of_mem hJ₁' hJ₂' hx₁ hx₂\n\n"}
{"name":"BoxIntegral.Prepartition.mem_biUnion","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nπi : (J : BoxIntegral.Box ι) → BoxIntegral.Prepartition J\n⊢ Iff (Membership.mem (π.biUnion πi) J) (Exists fun J' => And (Membership.mem π J') (Membership.mem (πi J') J))","decl":"@[simp]\ntheorem mem_biUnion : J ∈ π.biUnion πi ↔ ∃ J' ∈ π, J ∈ πi J' := by simp [biUnion]\n\n"}
{"name":"BoxIntegral.Prepartition.biUnion_le","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nπi : (J : BoxIntegral.Box ι) → BoxIntegral.Prepartition J\n⊢ LE.le (π.biUnion πi) π","decl":"theorem biUnion_le (πi : ∀ J, Prepartition J) : π.biUnion πi ≤ π := fun _ hJ =>\n  let ⟨J', hJ', hJ⟩ := π.mem_biUnion.1 hJ\n  ⟨J', hJ', (πi J').le_of_mem hJ⟩\n\n"}
{"name":"BoxIntegral.Prepartition.biUnion_top","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\n⊢ Eq (π.biUnion fun x => Top.top) π","decl":"@[simp]\ntheorem biUnion_top : (π.biUnion fun _ => ⊤) = π := by\n  ext\n  simp\n\n"}
{"name":"BoxIntegral.Prepartition.biUnion_congr","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ₁ π₂ : BoxIntegral.Prepartition I\nπi₁ πi₂ : (J : BoxIntegral.Box ι) → BoxIntegral.Prepartition J\nh : Eq π₁ π₂\nhi : ∀ (J : BoxIntegral.Box ι), Membership.mem π₁ J → Eq (πi₁ J) (πi₂ J)\n⊢ Eq (π₁.biUnion πi₁) (π₂.biUnion πi₂)","decl":"@[congr]\ntheorem biUnion_congr (h : π₁ = π₂) (hi : ∀ J ∈ π₁, πi₁ J = πi₂ J) :\n    π₁.biUnion πi₁ = π₂.biUnion πi₂ := by\n  subst π₂\n  ext J\n  simp only [mem_biUnion]\n  constructor <;> exact fun ⟨J', h₁, h₂⟩ => ⟨J', h₁, hi J' h₁ ▸ h₂⟩\n\n"}
{"name":"BoxIntegral.Prepartition.biUnion_congr_of_le","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ₁ π₂ : BoxIntegral.Prepartition I\nπi₁ πi₂ : (J : BoxIntegral.Box ι) → BoxIntegral.Prepartition J\nh : Eq π₁ π₂\nhi : ∀ (J : BoxIntegral.Box ι), LE.le J I → Eq (πi₁ J) (πi₂ J)\n⊢ Eq (π₁.biUnion πi₁) (π₂.biUnion πi₂)","decl":"theorem biUnion_congr_of_le (h : π₁ = π₂) (hi : ∀ J ≤ I, πi₁ J = πi₂ J) :\n    π₁.biUnion πi₁ = π₂.biUnion πi₂ :=\n  biUnion_congr h fun J hJ => hi J (π₁.le_of_mem hJ)\n\n"}
{"name":"BoxIntegral.Prepartition.iUnion_biUnion","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nπi : (J : BoxIntegral.Box ι) → BoxIntegral.Prepartition J\n⊢ Eq (π.biUnion πi).iUnion (Set.iUnion fun J => Set.iUnion fun h => (πi J).iUnion)","decl":"@[simp]\ntheorem iUnion_biUnion (πi : ∀ J : Box ι, Prepartition J) :\n    (π.biUnion πi).iUnion = ⋃ J ∈ π, (πi J).iUnion := by simp [Prepartition.iUnion]\n\n"}
{"name":"BoxIntegral.Prepartition.sum_biUnion_boxes","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nM : Type u_2\ninst✝ : AddCommMonoid M\nπ : BoxIntegral.Prepartition I\nπi : (J : BoxIntegral.Box ι) → BoxIntegral.Prepartition J\nf : BoxIntegral.Box ι → M\n⊢ Eq ((π.boxes.biUnion fun J => (πi J).boxes).sum fun J => f J) (π.boxes.sum fun J => (πi J).boxes.sum fun J' => f J')","decl":"open scoped Classical in\n@[simp]\ntheorem sum_biUnion_boxes {M : Type*} [AddCommMonoid M] (π : Prepartition I)\n    (πi : ∀ J, Prepartition J) (f : Box ι → M) :\n    (∑ J ∈ π.boxes.biUnion fun J => (πi J).boxes, f J) =\n      ∑ J ∈ π.boxes, ∑ J' ∈ (πi J).boxes, f J' := by\n  refine Finset.sum_biUnion fun J₁ h₁ J₂ h₂ hne => Finset.disjoint_left.2 fun J' h₁' h₂' => ?_\n  exact hne (π.eq_of_le_of_le h₁ h₂ ((πi J₁).le_of_mem h₁') ((πi J₂).le_of_mem h₂'))\n\n"}
{"name":"BoxIntegral.Prepartition.biUnionIndex_mem","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nπi : (J : BoxIntegral.Box ι) → BoxIntegral.Prepartition J\nhJ : Membership.mem (π.biUnion πi) J\n⊢ Membership.mem π (π.biUnionIndex πi J)","decl":"theorem biUnionIndex_mem (hJ : J ∈ π.biUnion πi) : π.biUnionIndex πi J ∈ π := by\n  rw [biUnionIndex, dif_pos hJ]\n  exact (π.mem_biUnion.1 hJ).choose_spec.1\n\n"}
{"name":"BoxIntegral.Prepartition.biUnionIndex_le","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nπi : (J : BoxIntegral.Box ι) → BoxIntegral.Prepartition J\nJ : BoxIntegral.Box ι\n⊢ LE.le (π.biUnionIndex πi J) I","decl":"theorem biUnionIndex_le (πi : ∀ J, Prepartition J) (J : Box ι) : π.biUnionIndex πi J ≤ I := by\n  by_cases hJ : J ∈ π.biUnion πi\n  · exact π.le_of_mem (π.biUnionIndex_mem hJ)\n  · rw [biUnionIndex, dif_neg hJ]\n\n"}
{"name":"BoxIntegral.Prepartition.mem_biUnionIndex","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nπi : (J : BoxIntegral.Box ι) → BoxIntegral.Prepartition J\nhJ : Membership.mem (π.biUnion πi) J\n⊢ Membership.mem (πi (π.biUnionIndex πi J)) J","decl":"theorem mem_biUnionIndex (hJ : J ∈ π.biUnion πi) : J ∈ πi (π.biUnionIndex πi J) := by\n  convert (π.mem_biUnion.1 hJ).choose_spec.2 <;> exact dif_pos hJ\n\n"}
{"name":"BoxIntegral.Prepartition.le_biUnionIndex","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nπi : (J : BoxIntegral.Box ι) → BoxIntegral.Prepartition J\nhJ : Membership.mem (π.biUnion πi) J\n⊢ LE.le J (π.biUnionIndex πi J)","decl":"theorem le_biUnionIndex (hJ : J ∈ π.biUnion πi) : J ≤ π.biUnionIndex πi J :=\n  le_of_mem _ (π.mem_biUnionIndex hJ)\n\n"}
{"name":"BoxIntegral.Prepartition.biUnionIndex_of_mem","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nπi : (J : BoxIntegral.Box ι) → BoxIntegral.Prepartition J\nhJ : Membership.mem π J\nJ' : BoxIntegral.Box ι\nhJ' : Membership.mem (πi J) J'\n⊢ Eq (π.biUnionIndex πi J') J","decl":"/-- Uniqueness property of `BoxIntegral.Prepartition.biUnionIndex`. -/\ntheorem biUnionIndex_of_mem (hJ : J ∈ π) {J'} (hJ' : J' ∈ πi J) : π.biUnionIndex πi J' = J :=\n  have : J' ∈ π.biUnion πi := π.mem_biUnion.2 ⟨J, hJ, hJ'⟩\n  π.eq_of_le_of_le (π.biUnionIndex_mem this) hJ (π.le_biUnionIndex this) (le_of_mem _ hJ')\n\n"}
{"name":"BoxIntegral.Prepartition.biUnion_assoc","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nπi : (J : BoxIntegral.Box ι) → BoxIntegral.Prepartition J\nπi' : BoxIntegral.Box ι → (J : BoxIntegral.Box ι) → BoxIntegral.Prepartition J\n⊢ Eq (π.biUnion fun J => (πi J).biUnion (πi' J)) ((π.biUnion πi).biUnion fun J => πi' (π.biUnionIndex πi J) J)","decl":"theorem biUnion_assoc (πi : ∀ J, Prepartition J) (πi' : Box ι → ∀ J : Box ι, Prepartition J) :\n    (π.biUnion fun J => (πi J).biUnion (πi' J)) =\n      (π.biUnion πi).biUnion fun J => πi' (π.biUnionIndex πi J) J := by\n  ext J\n  simp only [mem_biUnion, exists_prop]\n  constructor\n  · rintro ⟨J₁, hJ₁, J₂, hJ₂, hJ⟩\n    refine ⟨J₂, ⟨J₁, hJ₁, hJ₂⟩, ?_⟩\n    rwa [π.biUnionIndex_of_mem hJ₁ hJ₂]\n  · rintro ⟨J₁, ⟨J₂, hJ₂, hJ₁⟩, hJ⟩\n    refine ⟨J₂, hJ₂, J₁, hJ₁, ?_⟩\n    rwa [π.biUnionIndex_of_mem hJ₂ hJ₁] at hJ\n\n"}
{"name":"BoxIntegral.Prepartition.mem_ofWithBot","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nboxes : Finset (WithBot (BoxIntegral.Box ι))\nh₁ : ∀ (J : WithBot (BoxIntegral.Box ι)), Membership.mem boxes J → LE.le J ↑I\nh₂ : (↑boxes).Pairwise Disjoint\n⊢ Iff (Membership.mem (BoxIntegral.Prepartition.ofWithBot boxes h₁ h₂) J) (Membership.mem boxes ↑J)","decl":"@[simp]\ntheorem mem_ofWithBot {boxes : Finset (WithBot (Box ι))} {h₁ h₂} :\n    J ∈ (ofWithBot boxes h₁ h₂ : Prepartition I) ↔ (J : WithBot (Box ι)) ∈ boxes :=\n  mem_eraseNone\n\n"}
{"name":"BoxIntegral.Prepartition.iUnion_ofWithBot","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nboxes : Finset (WithBot (BoxIntegral.Box ι))\nle_of_mem : ∀ (J : WithBot (BoxIntegral.Box ι)), Membership.mem boxes J → LE.le J ↑I\npairwise_disjoint : (↑boxes).Pairwise Disjoint\n⊢ Eq (BoxIntegral.Prepartition.ofWithBot boxes le_of_mem pairwise_disjoint).iUnion (Set.iUnion fun J => Set.iUnion fun h => ↑J)","decl":"@[simp]\ntheorem iUnion_ofWithBot (boxes : Finset (WithBot (Box ι)))\n    (le_of_mem : ∀ J ∈ boxes, (J : WithBot (Box ι)) ≤ I)\n    (pairwise_disjoint : Set.Pairwise (boxes : Set (WithBot (Box ι))) Disjoint) :\n    (ofWithBot boxes le_of_mem pairwise_disjoint).iUnion = ⋃ J ∈ boxes, ↑J := by\n  suffices ⋃ (J : Box ι) (_ : ↑J ∈ boxes), ↑J = ⋃ J ∈ boxes, (J : Set (ι → ℝ)) by\n    simpa [ofWithBot, Prepartition.iUnion]\n  simp only [← Box.biUnion_coe_eq_coe, @iUnion_comm _ _ (Box ι), @iUnion_comm _ _ (@Eq _ _ _),\n    iUnion_iUnion_eq_right]\n\n"}
{"name":"BoxIntegral.Prepartition.ofWithBot_le","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nboxes : Finset (WithBot (BoxIntegral.Box ι))\nle_of_mem : ∀ (J : WithBot (BoxIntegral.Box ι)), Membership.mem boxes J → LE.le J ↑I\npairwise_disjoint : (↑boxes).Pairwise Disjoint\nH : ∀ (J : WithBot (BoxIntegral.Box ι)), Membership.mem boxes J → Ne J Bot.bot → Exists fun J' => And (Membership.mem π J') (LE.le J ↑J')\n⊢ LE.le (BoxIntegral.Prepartition.ofWithBot boxes le_of_mem pairwise_disjoint) π","decl":"theorem ofWithBot_le {boxes : Finset (WithBot (Box ι))}\n    {le_of_mem : ∀ J ∈ boxes, (J : WithBot (Box ι)) ≤ I}\n    {pairwise_disjoint : Set.Pairwise (boxes : Set (WithBot (Box ι))) Disjoint}\n    (H : ∀ J ∈ boxes, J ≠ ⊥ → ∃ J' ∈ π, J ≤ ↑J') :\n    ofWithBot boxes le_of_mem pairwise_disjoint ≤ π := by\n  have : ∀ J : Box ι, ↑J ∈ boxes → ∃ J' ∈ π, J ≤ J' := fun J hJ => by\n    simpa only [WithBot.coe_le_coe] using H J hJ WithBot.coe_ne_bot\n  simpa [ofWithBot, le_def]\n\n"}
{"name":"BoxIntegral.Prepartition.le_ofWithBot","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nboxes : Finset (WithBot (BoxIntegral.Box ι))\nle_of_mem : ∀ (J : WithBot (BoxIntegral.Box ι)), Membership.mem boxes J → LE.le J ↑I\npairwise_disjoint : (↑boxes).Pairwise Disjoint\nH : ∀ (J : BoxIntegral.Box ι), Membership.mem π J → Exists fun J' => And (Membership.mem boxes J') (LE.le (↑J) J')\n⊢ LE.le π (BoxIntegral.Prepartition.ofWithBot boxes le_of_mem pairwise_disjoint)","decl":"theorem le_ofWithBot {boxes : Finset (WithBot (Box ι))}\n    {le_of_mem : ∀ J ∈ boxes, (J : WithBot (Box ι)) ≤ I}\n    {pairwise_disjoint : Set.Pairwise (boxes : Set (WithBot (Box ι))) Disjoint}\n    (H : ∀ J ∈ π, ∃ J' ∈ boxes, ↑J ≤ J') : π ≤ ofWithBot boxes le_of_mem pairwise_disjoint := by\n  intro J hJ\n  rcases H J hJ with ⟨J', J'mem, hle⟩\n  lift J' to Box ι using ne_bot_of_le_ne_bot WithBot.coe_ne_bot hle\n  exact ⟨J', mem_ofWithBot.2 J'mem, WithBot.coe_le_coe.1 hle⟩\n\n"}
{"name":"BoxIntegral.Prepartition.ofWithBot_mono","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nboxes₁ : Finset (WithBot (BoxIntegral.Box ι))\nle_of_mem₁ : ∀ (J : WithBot (BoxIntegral.Box ι)), Membership.mem boxes₁ J → LE.le J ↑I\npairwise_disjoint₁ : (↑boxes₁).Pairwise Disjoint\nboxes₂ : Finset (WithBot (BoxIntegral.Box ι))\nle_of_mem₂ : ∀ (J : WithBot (BoxIntegral.Box ι)), Membership.mem boxes₂ J → LE.le J ↑I\npairwise_disjoint₂ : (↑boxes₂).Pairwise Disjoint\nH : ∀ (J : WithBot (BoxIntegral.Box ι)), Membership.mem boxes₁ J → Ne J Bot.bot → Exists fun J' => And (Membership.mem boxes₂ J') (LE.le J J')\n⊢ LE.le (BoxIntegral.Prepartition.ofWithBot boxes₁ le_of_mem₁ pairwise_disjoint₁) (BoxIntegral.Prepartition.ofWithBot boxes₂ le_of_mem₂ pairwise_disjoint₂)","decl":"theorem ofWithBot_mono {boxes₁ : Finset (WithBot (Box ι))}\n    {le_of_mem₁ : ∀ J ∈ boxes₁, (J : WithBot (Box ι)) ≤ I}\n    {pairwise_disjoint₁ : Set.Pairwise (boxes₁ : Set (WithBot (Box ι))) Disjoint}\n    {boxes₂ : Finset (WithBot (Box ι))} {le_of_mem₂ : ∀ J ∈ boxes₂, (J : WithBot (Box ι)) ≤ I}\n    {pairwise_disjoint₂ : Set.Pairwise (boxes₂ : Set (WithBot (Box ι))) Disjoint}\n    (H : ∀ J ∈ boxes₁, J ≠ ⊥ → ∃ J' ∈ boxes₂, J ≤ J') :\n    ofWithBot boxes₁ le_of_mem₁ pairwise_disjoint₁ ≤\n      ofWithBot boxes₂ le_of_mem₂ pairwise_disjoint₂ :=\n  le_ofWithBot _ fun J hJ => H J (mem_ofWithBot.1 hJ) WithBot.coe_ne_bot\n\n"}
{"name":"BoxIntegral.Prepartition.sum_ofWithBot","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nM : Type u_2\ninst✝ : AddCommMonoid M\nboxes : Finset (WithBot (BoxIntegral.Box ι))\nle_of_mem : ∀ (J : WithBot (BoxIntegral.Box ι)), Membership.mem boxes J → LE.le J ↑I\npairwise_disjoint : (↑boxes).Pairwise Disjoint\nf : BoxIntegral.Box ι → M\n⊢ Eq ((BoxIntegral.Prepartition.ofWithBot boxes le_of_mem pairwise_disjoint).boxes.sum fun J => f J) (boxes.sum fun J => Option.elim' 0 f J)","decl":"theorem sum_ofWithBot {M : Type*} [AddCommMonoid M] (boxes : Finset (WithBot (Box ι)))\n    (le_of_mem : ∀ J ∈ boxes, (J : WithBot (Box ι)) ≤ I)\n    (pairwise_disjoint : Set.Pairwise (boxes : Set (WithBot (Box ι))) Disjoint) (f : Box ι → M) :\n    (∑ J ∈ (ofWithBot boxes le_of_mem pairwise_disjoint).boxes, f J) =\n      ∑ J ∈ boxes, Option.elim' 0 f J :=\n  Finset.sum_eraseNone _ _\n\n"}
{"name":"BoxIntegral.Prepartition.mem_restrict","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J J₁ : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\n⊢ Iff (Membership.mem (π.restrict J) J₁) (Exists fun J' => And (Membership.mem π J') (Eq (↑J₁) (Min.min ↑J ↑J')))","decl":"@[simp]\ntheorem mem_restrict : J₁ ∈ π.restrict J ↔ ∃ J' ∈ π, (J₁ : WithBot (Box ι)) = ↑J ⊓ ↑J' := by\n  simp [restrict, eq_comm]\n\n"}
{"name":"BoxIntegral.Prepartition.mem_restrict'","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J J₁ : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\n⊢ Iff (Membership.mem (π.restrict J) J₁) (Exists fun J' => And (Membership.mem π J') (Eq (↑J₁) (Inter.inter ↑J ↑J')))","decl":"theorem mem_restrict' : J₁ ∈ π.restrict J ↔ ∃ J' ∈ π, (J₁ : Set (ι → ℝ)) = ↑J ∩ ↑J' := by\n  simp only [mem_restrict, ← Box.withBotCoe_inj, Box.coe_inf, Box.coe_coe]\n\n"}
{"name":"BoxIntegral.Prepartition.restrict_mono","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nπ₁ π₂ : BoxIntegral.Prepartition I\nHle : LE.le π₁ π₂\n⊢ LE.le (π₁.restrict J) (π₂.restrict J)","decl":"@[mono]\ntheorem restrict_mono {π₁ π₂ : Prepartition I} (Hle : π₁ ≤ π₂) : π₁.restrict J ≤ π₂.restrict J := by\n  classical\n  refine ofWithBot_mono fun J₁ hJ₁ hne => ?_\n  rw [Finset.mem_image] at hJ₁; rcases hJ₁ with ⟨J₁, hJ₁, rfl⟩\n  rcases Hle hJ₁ with ⟨J₂, hJ₂, hle⟩\n  exact ⟨_, Finset.mem_image_of_mem _ hJ₂, inf_le_inf_left _ <| WithBot.coe_le_coe.2 hle⟩\n\n"}
{"name":"BoxIntegral.Prepartition.monotone_restrict","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\n⊢ Monotone fun π => π.restrict J","decl":"theorem monotone_restrict : Monotone fun π : Prepartition I => restrict π J :=\n  fun _ _ => restrict_mono\n\n"}
{"name":"BoxIntegral.Prepartition.restrict_boxes_of_le","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nh : LE.le I J\n⊢ Eq (π.restrict J).boxes π.boxes","decl":"/-- Restricting to a larger box does not change the set of boxes. We cannot claim equality\nof prepartitions because they have different types. -/\ntheorem restrict_boxes_of_le (π : Prepartition I) (h : I ≤ J) : (π.restrict J).boxes = π.boxes := by\n  classical\n  simp only [restrict, ofWithBot, eraseNone_eq_biUnion]\n  refine Finset.image_biUnion.trans ?_\n  refine (Finset.biUnion_congr rfl ?_).trans Finset.biUnion_singleton_eq_self\n  intro J' hJ'\n  rw [inf_of_le_right, ← WithBot.some_eq_coe, Option.toFinset_some]\n  exact WithBot.coe_le_coe.2 ((π.le_of_mem hJ').trans h)\n\n"}
{"name":"BoxIntegral.Prepartition.restrict_self","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\n⊢ Eq (π.restrict I) π","decl":"@[simp]\ntheorem restrict_self : π.restrict I = π :=\n  injective_boxes <| restrict_boxes_of_le π le_rfl\n\n"}
{"name":"BoxIntegral.Prepartition.iUnion_restrict","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\n⊢ Eq (π.restrict J).iUnion (Inter.inter (↑J) π.iUnion)","decl":"@[simp]\ntheorem iUnion_restrict : (π.restrict J).iUnion = (J : Set (ι → ℝ)) ∩ (π.iUnion) := by\n  simp [restrict, ← inter_iUnion, ← iUnion_def]\n\n"}
{"name":"BoxIntegral.Prepartition.restrict_biUnion","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nπi : (J : BoxIntegral.Box ι) → BoxIntegral.Prepartition J\nhJ : Membership.mem π J\n⊢ Eq ((π.biUnion πi).restrict J) (πi J)","decl":"@[simp]\ntheorem restrict_biUnion (πi : ∀ J, Prepartition J) (hJ : J ∈ π) :\n    (π.biUnion πi).restrict J = πi J := by\n  refine (eq_of_boxes_subset_iUnion_superset (fun J₁ h₁ => ?_) ?_).symm\n  · refine (mem_restrict _).2 ⟨J₁, π.mem_biUnion.2 ⟨J, hJ, h₁⟩, (inf_of_le_right ?_).symm⟩\n    exact WithBot.coe_le_coe.2 (le_of_mem _ h₁)\n  · simp only [iUnion_restrict, iUnion_biUnion, Set.subset_def, Set.mem_inter_iff, Set.mem_iUnion]\n    rintro x ⟨hxJ, J₁, h₁, hx⟩\n    obtain rfl : J = J₁ := π.eq_of_mem_of_mem hJ h₁ hxJ (iUnion_subset _ hx)\n    exact hx\n\n"}
{"name":"BoxIntegral.Prepartition.biUnion_le_iff","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nπi : (J : BoxIntegral.Box ι) → BoxIntegral.Prepartition J\nπ' : BoxIntegral.Prepartition I\n⊢ Iff (LE.le (π.biUnion πi) π') (∀ (J : BoxIntegral.Box ι), Membership.mem π J → LE.le (πi J) (π'.restrict J))","decl":"theorem biUnion_le_iff {πi : ∀ J, Prepartition J} {π' : Prepartition I} :\n    π.biUnion πi ≤ π' ↔ ∀ J ∈ π, πi J ≤ π'.restrict J := by\n  constructor <;> intro H J hJ\n  · rw [← π.restrict_biUnion πi hJ]\n    exact restrict_mono H\n  · rw [mem_biUnion] at hJ\n    rcases hJ with ⟨J₁, h₁, hJ⟩\n    rcases H J₁ h₁ hJ with ⟨J₂, h₂, Hle⟩\n    rcases π'.mem_restrict.mp h₂ with ⟨J₃, h₃, H⟩\n    exact ⟨J₃, h₃, Hle.trans <| WithBot.coe_le_coe.1 <| H.trans_le inf_le_right⟩\n\n"}
{"name":"BoxIntegral.Prepartition.le_biUnion_iff","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nπi : (J : BoxIntegral.Box ι) → BoxIntegral.Prepartition J\nπ' : BoxIntegral.Prepartition I\n⊢ Iff (LE.le π' (π.biUnion πi)) (And (LE.le π' π) (∀ (J : BoxIntegral.Box ι), Membership.mem π J → LE.le (π'.restrict J) (πi J)))","decl":"theorem le_biUnion_iff {πi : ∀ J, Prepartition J} {π' : Prepartition I} :\n    π' ≤ π.biUnion πi ↔ π' ≤ π ∧ ∀ J ∈ π, π'.restrict J ≤ πi J := by\n  refine ⟨fun H => ⟨H.trans (π.biUnion_le πi), fun J hJ => ?_⟩, ?_⟩\n  · rw [← π.restrict_biUnion πi hJ]\n    exact restrict_mono H\n  · rintro ⟨H, Hi⟩ J' hJ'\n    rcases H hJ' with ⟨J, hJ, hle⟩\n    have : J' ∈ π'.restrict J :=\n      π'.mem_restrict.2 ⟨J', hJ', (inf_of_le_right <| WithBot.coe_le_coe.2 hle).symm⟩\n    rcases Hi J hJ this with ⟨Ji, hJi, hlei⟩\n    exact ⟨Ji, π.mem_biUnion.2 ⟨J, hJ, hJi⟩, hlei⟩\n\n"}
{"name":"BoxIntegral.Prepartition.inf_def","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ₁ π₂ : BoxIntegral.Prepartition I\n⊢ Eq (Min.min π₁ π₂) (π₁.biUnion fun J => π₂.restrict J)","decl":"theorem inf_def (π₁ π₂ : Prepartition I) : π₁ ⊓ π₂ = π₁.biUnion fun J => π₂.restrict J := rfl\n\n"}
{"name":"BoxIntegral.Prepartition.mem_inf","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nπ₁ π₂ : BoxIntegral.Prepartition I\n⊢ Iff (Membership.mem (Min.min π₁ π₂) J) (Exists fun J₁ => And (Membership.mem π₁ J₁) (Exists fun J₂ => And (Membership.mem π₂ J₂) (Eq (↑J) (Min.min ↑J₁ ↑J₂))))","decl":"@[simp]\ntheorem mem_inf {π₁ π₂ : Prepartition I} :\n    J ∈ π₁ ⊓ π₂ ↔ ∃ J₁ ∈ π₁, ∃ J₂ ∈ π₂, (J : WithBot (Box ι)) = ↑J₁ ⊓ ↑J₂ := by\n  simp only [inf_def, mem_biUnion, mem_restrict]\n\n"}
{"name":"BoxIntegral.Prepartition.iUnion_inf","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ₁ π₂ : BoxIntegral.Prepartition I\n⊢ Eq (Min.min π₁ π₂).iUnion (Inter.inter π₁.iUnion π₂.iUnion)","decl":"@[simp]\ntheorem iUnion_inf (π₁ π₂ : Prepartition I) : (π₁ ⊓ π₂).iUnion = π₁.iUnion ∩ π₂.iUnion := by\n  simp only [inf_def, iUnion_biUnion, iUnion_restrict, ← iUnion_inter, ← iUnion_def]\n\n"}
{"name":"BoxIntegral.Prepartition.filter_boxes","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\np : BoxIntegral.Box ι → Prop\n⊢ Eq (π.filter p).boxes (Finset.filter (fun J => p J) π.boxes)","decl":"open scoped Classical in\n/-- The prepartition with boxes `{J ∈ π | p J}`. -/\n@[simps]\ndef filter (π : Prepartition I) (p : Box ι → Prop) : Prepartition I where\n  boxes := {J ∈ π.boxes | p J}\n  le_of_mem' _ hJ := π.le_of_mem (mem_filter.1 hJ).1\n  pairwiseDisjoint _ h₁ _ h₂ := π.disjoint_coe_of_mem (mem_filter.1 h₁).1 (mem_filter.1 h₂).1\n\n"}
{"name":"BoxIntegral.Prepartition.mem_filter","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\np : BoxIntegral.Box ι → Prop\n⊢ Iff (Membership.mem (π.filter p) J) (And (Membership.mem π J) (p J))","decl":"@[simp]\ntheorem mem_filter {p : Box ι → Prop} : J ∈ π.filter p ↔ J ∈ π ∧ p J := by\n  classical\n  exact Finset.mem_filter\n\n"}
{"name":"BoxIntegral.Prepartition.filter_le","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\np : BoxIntegral.Box ι → Prop\n⊢ LE.le (π.filter p) π","decl":"theorem filter_le (π : Prepartition I) (p : Box ι → Prop) : π.filter p ≤ π := fun J hJ =>\n  let ⟨hπ, _⟩ := π.mem_filter.1 hJ\n  ⟨J, hπ, le_rfl⟩\n\n"}
{"name":"BoxIntegral.Prepartition.filter_of_true","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\np : BoxIntegral.Box ι → Prop\nhp : ∀ (J : BoxIntegral.Box ι), Membership.mem π J → p J\n⊢ Eq (π.filter p) π","decl":"theorem filter_of_true {p : Box ι → Prop} (hp : ∀ J ∈ π, p J) : π.filter p = π := by\n  ext J\n  simpa using hp J\n\n"}
{"name":"BoxIntegral.Prepartition.filter_true","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\n⊢ Eq (π.filter fun x => True) π","decl":"@[simp]\ntheorem filter_true : (π.filter fun _ => True) = π :=\n  π.filter_of_true fun _ _ => trivial\n\n"}
{"name":"BoxIntegral.Prepartition.iUnion_filter_not","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\np : BoxIntegral.Box ι → Prop\n⊢ Eq (π.filter fun J => Not (p J)).iUnion (SDiff.sdiff π.iUnion (π.filter p).iUnion)","decl":"@[simp]\ntheorem iUnion_filter_not (π : Prepartition I) (p : Box ι → Prop) :\n    (π.filter fun J => ¬p J).iUnion = π.iUnion \\ (π.filter p).iUnion := by\n  simp only [Prepartition.iUnion]\n  convert\n    (@Set.biUnion_diff_biUnion_eq (ι → ℝ) (Box ι) π.boxes (π.filter p).boxes (↑) _).symm using 4\n  · simp +contextual\n  · rw [Set.PairwiseDisjoint]\n    convert π.pairwiseDisjoint\n    rw [Set.union_eq_left, filter_boxes, coe_filter]\n    exact fun _ ⟨h, _⟩ => h\n\n"}
{"name":"BoxIntegral.Prepartition.sum_fiberwise","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nα : Type u_2\nM : Type u_3\ninst✝ : AddCommMonoid M\nπ : BoxIntegral.Prepartition I\nf : BoxIntegral.Box ι → α\ng : BoxIntegral.Box ι → M\n⊢ Eq ((Finset.image f π.boxes).sum fun y => (π.filter fun J => Eq (f J) y).boxes.sum fun J => g J) (π.boxes.sum fun J => g J)","decl":"open scoped Classical in\ntheorem sum_fiberwise {α M} [AddCommMonoid M] (π : Prepartition I) (f : Box ι → α) (g : Box ι → M) :\n    (∑ y ∈ π.boxes.image f, ∑ J ∈ (π.filter fun J => f J = y).boxes, g J) =\n      ∑ J ∈ π.boxes, g J := by\n  convert sum_fiberwise_of_maps_to (fun _ => Finset.mem_image_of_mem f) g\n\n"}
{"name":"BoxIntegral.Prepartition.disjUnion_boxes","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ₁ π₂ : BoxIntegral.Prepartition I\nh : Disjoint π₁.iUnion π₂.iUnion\n⊢ Eq (π₁.disjUnion π₂ h).boxes (Union.union π₁.boxes π₂.boxes)","decl":"open scoped Classical in\n/-- Union of two disjoint prepartitions. -/\n@[simps]\ndef disjUnion (π₁ π₂ : Prepartition I) (h : Disjoint π₁.iUnion π₂.iUnion) : Prepartition I where\n  boxes := π₁.boxes ∪ π₂.boxes\n  le_of_mem' _ hJ := (Finset.mem_union.1 hJ).elim π₁.le_of_mem π₂.le_of_mem\n  pairwiseDisjoint :=\n    suffices ∀ J₁ ∈ π₁, ∀ J₂ ∈ π₂, J₁ ≠ J₂ → Disjoint (J₁ : Set (ι → ℝ)) J₂ by\n      simpa [pairwise_union_of_symmetric (symmetric_disjoint.comap _), pairwiseDisjoint]\n    fun _ h₁ _ h₂ _ => h.mono (π₁.subset_iUnion h₁) (π₂.subset_iUnion h₂)\n\n"}
{"name":"BoxIntegral.Prepartition.mem_disjUnion","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nπ₁ π₂ : BoxIntegral.Prepartition I\nH : Disjoint π₁.iUnion π₂.iUnion\n⊢ Iff (Membership.mem (π₁.disjUnion π₂ H) J) (Or (Membership.mem π₁ J) (Membership.mem π₂ J))","decl":"@[simp]\ntheorem mem_disjUnion (H : Disjoint π₁.iUnion π₂.iUnion) :\n    J ∈ π₁.disjUnion π₂ H ↔ J ∈ π₁ ∨ J ∈ π₂ := by\n  classical exact Finset.mem_union\n\n"}
{"name":"BoxIntegral.Prepartition.iUnion_disjUnion","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ₁ π₂ : BoxIntegral.Prepartition I\nh : Disjoint π₁.iUnion π₂.iUnion\n⊢ Eq (π₁.disjUnion π₂ h).iUnion (Union.union π₁.iUnion π₂.iUnion)","decl":"@[simp]\ntheorem iUnion_disjUnion (h : Disjoint π₁.iUnion π₂.iUnion) :\n    (π₁.disjUnion π₂ h).iUnion = π₁.iUnion ∪ π₂.iUnion := by\n  simp [disjUnion, Prepartition.iUnion, iUnion_or, iUnion_union_distrib]\n\n"}
{"name":"BoxIntegral.Prepartition.sum_disj_union_boxes","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ₁ π₂ : BoxIntegral.Prepartition I\nM : Type u_2\ninst✝ : AddCommMonoid M\nh : Disjoint π₁.iUnion π₂.iUnion\nf : BoxIntegral.Box ι → M\n⊢ Eq ((Union.union π₁.boxes π₂.boxes).sum fun J => f J) (HAdd.hAdd (π₁.boxes.sum fun J => f J) (π₂.boxes.sum fun J => f J))","decl":"open scoped Classical in\n@[simp]\ntheorem sum_disj_union_boxes {M : Type*} [AddCommMonoid M] (h : Disjoint π₁.iUnion π₂.iUnion)\n    (f : Box ι → M) :\n    ∑ J ∈ π₁.boxes ∪ π₂.boxes, f J = (∑ J ∈ π₁.boxes, f J) + ∑ J ∈ π₂.boxes, f J :=\n  sum_union <| disjoint_boxes_of_disjoint_iUnion h\n\n"}
{"name":"BoxIntegral.Prepartition.distortion_le_of_mem","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\ninst✝ : Fintype ι\nh : Membership.mem π J\n⊢ LE.le J.distortion π.distortion","decl":"theorem distortion_le_of_mem (h : J ∈ π) : J.distortion ≤ π.distortion :=\n  le_sup h\n\n"}
{"name":"BoxIntegral.Prepartition.distortion_le_iff","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\ninst✝ : Fintype ι\nc : NNReal\n⊢ Iff (LE.le π.distortion c) (∀ (J : BoxIntegral.Box ι), Membership.mem π J → LE.le J.distortion c)","decl":"theorem distortion_le_iff {c : ℝ≥0} : π.distortion ≤ c ↔ ∀ J ∈ π, Box.distortion J ≤ c :=\n  Finset.sup_le_iff\n\n"}
{"name":"BoxIntegral.Prepartition.distortion_biUnion","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nπ : BoxIntegral.Prepartition I\nπi : (J : BoxIntegral.Box ι) → BoxIntegral.Prepartition J\n⊢ Eq (π.biUnion πi).distortion (π.boxes.sup fun J => (πi J).distortion)","decl":"theorem distortion_biUnion (π : Prepartition I) (πi : ∀ J, Prepartition J) :\n    (π.biUnion πi).distortion = π.boxes.sup fun J => (πi J).distortion := by\n  classical exact sup_biUnion _ _\n\n"}
{"name":"BoxIntegral.Prepartition.distortion_disjUnion","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ₁ π₂ : BoxIntegral.Prepartition I\ninst✝ : Fintype ι\nh : Disjoint π₁.iUnion π₂.iUnion\n⊢ Eq (π₁.disjUnion π₂ h).distortion (Max.max π₁.distortion π₂.distortion)","decl":"@[simp]\ntheorem distortion_disjUnion (h : Disjoint π₁.iUnion π₂.iUnion) :\n    (π₁.disjUnion π₂ h).distortion = max π₁.distortion π₂.distortion := by\n  classical exact sup_union\n\n"}
{"name":"BoxIntegral.Prepartition.distortion_of_const","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\ninst✝ : Fintype ι\nc : NNReal\nh₁ : π.boxes.Nonempty\nh₂ : ∀ (J : BoxIntegral.Box ι), Membership.mem π J → Eq J.distortion c\n⊢ Eq π.distortion c","decl":"theorem distortion_of_const {c} (h₁ : π.boxes.Nonempty) (h₂ : ∀ J ∈ π, Box.distortion J = c) :\n    π.distortion = c :=\n  (sup_congr rfl h₂).trans (sup_const h₁ _)\n\n"}
{"name":"BoxIntegral.Prepartition.distortion_top","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI : BoxIntegral.Box ι\n⊢ Eq Top.top.distortion I.distortion","decl":"@[simp]\ntheorem distortion_top (I : Box ι) : distortion (⊤ : Prepartition I) = I.distortion :=\n  sup_singleton\n\n"}
{"name":"BoxIntegral.Prepartition.distortion_bot","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI : BoxIntegral.Box ι\n⊢ Eq Bot.bot.distortion 0","decl":"@[simp]\ntheorem distortion_bot (I : Box ι) : distortion (⊥ : Prepartition I) = 0 :=\n  sup_empty\n\n"}
{"name":"BoxIntegral.Prepartition.isPartition_iff_iUnion_eq","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\n⊢ Iff π.IsPartition (Eq π.iUnion ↑I)","decl":"theorem isPartition_iff_iUnion_eq {π : Prepartition I} : π.IsPartition ↔ π.iUnion = I := by\n  simp_rw [IsPartition, Set.Subset.antisymm_iff, π.iUnion_subset, true_and, Set.subset_def,\n    mem_iUnion, Box.mem_coe]\n\n"}
{"name":"BoxIntegral.Prepartition.isPartition_single_iff","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nh : LE.le J I\n⊢ Iff (BoxIntegral.Prepartition.single I J h).IsPartition (Eq J I)","decl":"@[simp]\ntheorem isPartition_single_iff (h : J ≤ I) : IsPartition (single I J h) ↔ J = I := by\n  simp [isPartition_iff_iUnion_eq]\n\n"}
{"name":"BoxIntegral.Prepartition.isPartitionTop","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\n⊢ Top.top.IsPartition","decl":"theorem isPartitionTop (I : Box ι) : IsPartition (⊤ : Prepartition I) :=\n  fun _ hx => ⟨I, mem_top.2 rfl, hx⟩\n\n"}
{"name":"BoxIntegral.Prepartition.IsPartition.iUnion_eq","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nh : π.IsPartition\n⊢ Eq π.iUnion ↑I","decl":"theorem iUnion_eq (h : π.IsPartition) : π.iUnion = I :=\n  isPartition_iff_iUnion_eq.1 h\n\n"}
{"name":"BoxIntegral.Prepartition.IsPartition.iUnion_subset","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nh : π.IsPartition\nπ₁ : BoxIntegral.Prepartition I\n⊢ HasSubset.Subset π₁.iUnion π.iUnion","decl":"theorem iUnion_subset (h : π.IsPartition) (π₁ : Prepartition I) : π₁.iUnion ⊆ π.iUnion :=\n  h.iUnion_eq.symm ▸ π₁.iUnion_subset\n\n"}
{"name":"BoxIntegral.Prepartition.IsPartition.existsUnique","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nx : ι → Real\nh : π.IsPartition\nhx : Membership.mem I x\n⊢ ExistsUnique fun J => And (Membership.mem π J) (Membership.mem J x)","decl":"protected theorem existsUnique (h : π.IsPartition) (hx : x ∈ I) :\n    ∃! J ∈ π, x ∈ J := by\n  rcases h x hx with ⟨J, h, hx⟩\n  exact ExistsUnique.intro J ⟨h, hx⟩ fun J' ⟨h', hx'⟩ => π.eq_of_mem_of_mem h' h hx' hx\n\n"}
{"name":"BoxIntegral.Prepartition.IsPartition.nonempty_boxes","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nh : π.IsPartition\n⊢ π.boxes.Nonempty","decl":"theorem nonempty_boxes (h : π.IsPartition) : π.boxes.Nonempty :=\n  let ⟨J, hJ, _⟩ := h _ I.upper_mem\n  ⟨J, hJ⟩\n\n"}
{"name":"BoxIntegral.Prepartition.IsPartition.eq_of_boxes_subset","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ₁ π₂ : BoxIntegral.Prepartition I\nh₁ : π₁.IsPartition\nh₂ : HasSubset.Subset π₁.boxes π₂.boxes\n⊢ Eq π₁ π₂","decl":"theorem eq_of_boxes_subset (h₁ : π₁.IsPartition) (h₂ : π₁.boxes ⊆ π₂.boxes) : π₁ = π₂ :=\n  eq_of_boxes_subset_iUnion_superset h₂ <| h₁.iUnion_subset _\n\n"}
{"name":"BoxIntegral.Prepartition.IsPartition.le_iff","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ₁ π₂ : BoxIntegral.Prepartition I\nh : π₂.IsPartition\n⊢ Iff (LE.le π₁ π₂) (∀ (J : BoxIntegral.Box ι), Membership.mem π₁ J → ∀ (J' : BoxIntegral.Box ι), Membership.mem π₂ J' → (Inter.inter ↑J ↑J').Nonempty → LE.le J J')","decl":"theorem le_iff (h : π₂.IsPartition) :\n    π₁ ≤ π₂ ↔ ∀ J ∈ π₁, ∀ J' ∈ π₂, (J ∩ J' : Set (ι → ℝ)).Nonempty → J ≤ J' :=\n  le_iff_nonempty_imp_le_and_iUnion_subset.trans <| and_iff_left <| h.iUnion_subset _\n\n"}
{"name":"BoxIntegral.Prepartition.IsPartition.biUnion","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nπi : (J : BoxIntegral.Box ι) → BoxIntegral.Prepartition J\nh : π.IsPartition\nhi : ∀ (J : BoxIntegral.Box ι), Membership.mem π J → (πi J).IsPartition\n⊢ (π.biUnion πi).IsPartition","decl":"protected theorem biUnion (h : IsPartition π) (hi : ∀ J ∈ π, IsPartition (πi J)) :\n    IsPartition (π.biUnion πi) := fun x hx =>\n  let ⟨J, hJ, hxi⟩ := h x hx\n  let ⟨Ji, hJi, hx⟩ := hi J hJ x hxi\n  ⟨Ji, π.mem_biUnion.2 ⟨J, hJ, hJi⟩, hx⟩\n\n"}
{"name":"BoxIntegral.Prepartition.IsPartition.restrict","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nh : π.IsPartition\nhJ : LE.le J I\n⊢ (π.restrict J).IsPartition","decl":"protected theorem restrict (h : IsPartition π) (hJ : J ≤ I) : IsPartition (π.restrict J) :=\n  isPartition_iff_iUnion_eq.2 <| by simp [h.iUnion_eq, hJ]\n\n"}
{"name":"BoxIntegral.Prepartition.IsPartition.inf","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ₁ π₂ : BoxIntegral.Prepartition I\nh₁ : π₁.IsPartition\nh₂ : π₂.IsPartition\n⊢ (Min.min π₁ π₂).IsPartition","decl":"protected theorem inf (h₁ : IsPartition π₁) (h₂ : IsPartition π₂) : IsPartition (π₁ ⊓ π₂) :=\n  isPartition_iff_iUnion_eq.2 <| by simp [h₁.iUnion_eq, h₂.iUnion_eq]\n\n"}
{"name":"BoxIntegral.Prepartition.iUnion_biUnion_partition","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nπi : (J : BoxIntegral.Box ι) → BoxIntegral.Prepartition J\nh : ∀ (J : BoxIntegral.Box ι), Membership.mem π J → (πi J).IsPartition\n⊢ Eq (π.biUnion πi).iUnion π.iUnion","decl":"theorem iUnion_biUnion_partition (h : ∀ J ∈ π, (πi J).IsPartition) :\n    (π.biUnion πi).iUnion = π.iUnion :=\n  (iUnion_biUnion _ _).trans <|\n    iUnion_congr_of_surjective id surjective_id fun J =>\n      iUnion_congr_of_surjective id surjective_id fun hJ => (h J hJ).iUnion_eq\n\n"}
{"name":"BoxIntegral.Prepartition.isPartitionDisjUnionOfEqDiff","module":"Mathlib.Analysis.BoxIntegral.Partition.Basic","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ₁ π₂ : BoxIntegral.Prepartition I\nh : Eq π₂.iUnion (SDiff.sdiff (↑I) π₁.iUnion)\n⊢ (π₁.disjUnion π₂ ⋯).IsPartition","decl":"theorem isPartitionDisjUnionOfEqDiff (h : π₂.iUnion = ↑I \\ π₁.iUnion) :\n    IsPartition (π₁.disjUnion π₂ <| h.symm ▸ disjoint_sdiff_self_right) :=\n  isPartition_iff_iUnion_eq.2 <| (iUnion_disjUnion _).trans <| by simp [h, π₁.iUnion_subset]\n\n"}
