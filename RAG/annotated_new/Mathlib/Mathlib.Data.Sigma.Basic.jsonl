{"name":"Sigma.mk.inj_iff","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_4\na₁ a₂ : α\nb₁ : β a₁\nb₂ : β a₂\n⊢ Iff (Eq ⟨a₁, b₁⟩ ⟨a₂, b₂⟩) (And (Eq a₁ a₂) (HEq b₁ b₂))","decl":"@[simp]\ntheorem mk.inj_iff {a₁ a₂ : α} {b₁ : β a₁} {b₂ : β a₂} :\n    Sigma.mk a₁ b₁ = ⟨a₂, b₂⟩ ↔ a₁ = a₂ ∧ HEq b₁ b₂ :=\n  ⟨fun h ↦ by cases h; simp,\n   fun ⟨h₁, h₂⟩ ↦ by subst h₁; rw [eq_of_heq h₂]⟩\n\n"}
{"name":"Sigma.eta","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_4\nx : Sigma fun a => β a\n⊢ Eq ⟨x.fst, x.snd⟩ x","decl":"@[simp]\ntheorem eta : ∀ x : Σa, β a, Sigma.mk x.1 x.2 = x\n  | ⟨_, _⟩ => rfl\n\n"}
{"name":"Sigma.eq","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α : Type u_7\nβ : α → Type u_8\np₁ p₂ : Sigma fun a => β a\nh₁ : Eq p₁.fst p₂.fst\na✝ : Eq (Eq.recOn h₁ p₁.snd) p₂.snd\n⊢ Eq p₁ p₂","decl":"protected theorem eq {α : Type*} {β : α → Type*} : ∀ {p₁ p₂ : Σ a, β a} (h₁ : p₁.1 = p₂.1),\n    (Eq.recOn h₁ p₁.2 : β p₂.1) = p₂.2 → p₁ = p₂\n  | ⟨_, _⟩, _, rfl, rfl => rfl\n\n"}
{"name":"Function.eq_of_sigmaMk_comp","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_4\nγ : Type u_7\ninst✝ : Nonempty γ\na b : α\nf : γ → β a\ng : γ → β b\nh : Eq (Function.comp (Sigma.mk a) f) (Function.comp (Sigma.mk b) g)\n⊢ And (Eq a b) (HEq f g)","decl":"/-- A version of `Iff.mp Sigma.ext_iff` for functions from a nonempty type to a sigma type. -/\ntheorem _root_.Function.eq_of_sigmaMk_comp {γ : Type*} [Nonempty γ]\n    {a b : α} {f : γ → β a} {g : γ → β b} (h : Sigma.mk a ∘ f = Sigma.mk b ∘ g) :\n    a = b ∧ HEq f g := by\n  rcases ‹Nonempty γ› with ⟨i⟩\n  obtain rfl : a = b := congr_arg Sigma.fst (congr_fun h i)\n  simpa [funext_iff] using h\n\n"}
{"name":"Sigma.subtype_ext","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α : Type u_1\nβ : Type u_7\np : α → β → Prop\nx₀ x₁ : Sigma fun a => Subtype (p a)\na✝¹ : Eq x₀.fst x₁.fst\na✝ : Eq x₀.snd.val x₁.snd.val\n⊢ Eq x₀ x₁","decl":"/-- A specialized ext lemma for equality of sigma types over an indexed subtype. -/\n@[ext]\ntheorem subtype_ext {β : Type*} {p : α → β → Prop} :\n    ∀ {x₀ x₁ : Σa, Subtype (p a)}, x₀.fst = x₁.fst → (x₀.snd : β) = x₁.snd → x₀ = x₁\n  | ⟨_, _, _⟩, ⟨_, _, _⟩, rfl, rfl => rfl\n\n-- This is not a good simp lemma, as its discrimination tree key is just an arrow.\n"}
{"name":"Sigma.subtype_ext_iff","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α : Type u_1\nβ : Type u_7\np : α → β → Prop\nx₀ x₁ : Sigma fun a => Subtype (p a)\n⊢ Iff (Eq x₀ x₁) (And (Eq x₀.fst x₁.fst) (Eq x₀.snd.val x₁.snd.val))","decl":"/-- A specialized ext lemma for equality of sigma types over an indexed subtype. -/\n@[ext]\ntheorem subtype_ext {β : Type*} {p : α → β → Prop} :\n    ∀ {x₀ x₁ : Σa, Subtype (p a)}, x₀.fst = x₁.fst → (x₀.snd : β) = x₁.snd → x₀ = x₁\n  | ⟨_, _, _⟩, ⟨_, _, _⟩, rfl, rfl => rfl\n\n-- This is not a good simp lemma, as its discrimination tree key is just an arrow.\n"}
{"name":"Sigma.forall","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_4\np : (Sigma fun a => β a) → Prop\n⊢ Iff (∀ (x : Sigma fun a => β a), p x) (∀ (a : α) (b : β a), p ⟨a, b⟩)","decl":"theorem «forall» {p : (Σa, β a) → Prop} : (∀ x, p x) ↔ ∀ a b, p ⟨a, b⟩ :=\n  ⟨fun h a b ↦ h ⟨a, b⟩, fun h ⟨a, b⟩ ↦ h a b⟩\n\n"}
{"name":"Sigma.exists","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_4\np : (Sigma fun a => β a) → Prop\n⊢ Iff (Exists fun x => p x) (Exists fun a => Exists fun b => p ⟨a, b⟩)","decl":"@[simp]\ntheorem «exists» {p : (Σa, β a) → Prop} : (∃ x, p x) ↔ ∃ a b, p ⟨a, b⟩ :=\n  ⟨fun ⟨⟨a, b⟩, h⟩ ↦ ⟨a, b, h⟩, fun ⟨a, b, h⟩ ↦ ⟨⟨a, b⟩, h⟩⟩\n\n"}
{"name":"Sigma.exists'","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_4\np : (a : α) → β a → Prop\n⊢ Iff (Exists fun a => Exists fun b => p a b) (Exists fun x => p x.fst x.snd)","decl":"lemma exists' {p : ∀ a, β a → Prop} : (∃ a b, p a b) ↔ ∃ x : Σ a, β a, p x.1 x.2 :=\n  (Sigma.exists (p := fun x ↦ p x.1 x.2)).symm\n\n"}
{"name":"Sigma.forall'","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_4\np : (a : α) → β a → Prop\n⊢ Iff (∀ (a : α) (b : β a), p a b) (∀ (x : Sigma fun a => β a), p x.fst x.snd)","decl":"lemma forall' {p : ∀ a, β a → Prop} : (∀ a b, p a b) ↔ ∀ x : Σ a, β a, p x.1 x.2 :=\n  (Sigma.forall (p := fun x ↦ p x.1 x.2)).symm\n\n"}
{"name":"sigma_mk_injective","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_4\ni : α\n⊢ Function.Injective (Sigma.mk i)","decl":"theorem _root_.sigma_mk_injective {i : α} : Injective (@Sigma.mk α β i)\n  | _, _, rfl => rfl\n\n"}
{"name":"Sigma.fst_surjective","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_4\nh : ∀ (a : α), Nonempty (β a)\n⊢ Function.Surjective Sigma.fst","decl":"theorem fst_surjective [h : ∀ a, Nonempty (β a)] : Surjective (fst : (Σ a, β a) → α) := fun a ↦\n  let ⟨b⟩ := h a; ⟨⟨a, b⟩, rfl⟩\n\n"}
{"name":"Sigma.fst_surjective_iff","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_4\n⊢ Iff (Function.Surjective Sigma.fst) (∀ (a : α), Nonempty (β a))","decl":"theorem fst_surjective_iff : Surjective (fst : (Σ a, β a) → α) ↔ ∀ a, Nonempty (β a) :=\n  ⟨fun h a ↦ let ⟨x, hx⟩ := h a; hx ▸ ⟨x.2⟩, @fst_surjective _ _⟩\n\n"}
{"name":"Sigma.fst_injective","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_4\nh : ∀ (a : α), Subsingleton (β a)\n⊢ Function.Injective Sigma.fst","decl":"theorem fst_injective [h : ∀ a, Subsingleton (β a)] : Injective (fst : (Σ a, β a) → α) := by\n  rintro ⟨a₁, b₁⟩ ⟨a₂, b₂⟩ (rfl : a₁ = a₂)\n  exact congr_arg (mk a₁) <| Subsingleton.elim _ _\n\n"}
{"name":"Sigma.fst_injective_iff","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_4\n⊢ Iff (Function.Injective Sigma.fst) (∀ (a : α), Subsingleton (β a))","decl":"theorem fst_injective_iff : Injective (fst : (Σ a, β a) → α) ↔ ∀ a, Subsingleton (β a) :=\n  ⟨fun h _ ↦ ⟨fun _ _ ↦ sigma_mk_injective <| h rfl⟩, @fst_injective _ _⟩\n\n"}
{"name":"Sigma.map_mk","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α₁ : Type u_2\nα₂ : Type u_3\nβ₁ : α₁ → Type u_5\nβ₂ : α₂ → Type u_6\nf₁ : α₁ → α₂\nf₂ : (a : α₁) → β₁ a → β₂ (f₁ a)\nx : α₁\ny : β₁ x\n⊢ Eq (Sigma.map f₁ f₂ ⟨x, y⟩) ⟨f₁ x, f₂ x y⟩","decl":"lemma map_mk (f₁ : α₁ → α₂) (f₂ : ∀ a, β₁ a → β₂ (f₁ a)) (x : α₁) (y : β₁ x) :\n    map f₁ f₂ ⟨x, y⟩ = ⟨f₁ x, f₂ x y⟩ := rfl\n"}
{"name":"Function.Injective.sigma_map","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α₁ : Type u_2\nα₂ : Type u_3\nβ₁ : α₁ → Type u_5\nβ₂ : α₂ → Type u_6\nf₁ : α₁ → α₂\nf₂ : (a : α₁) → β₁ a → β₂ (f₁ a)\nh₁ : Function.Injective f₁\nh₂ : ∀ (a : α₁), Function.Injective (f₂ a)\n⊢ Function.Injective (Sigma.map f₁ f₂)","decl":"theorem Function.Injective.sigma_map {f₁ : α₁ → α₂} {f₂ : ∀ a, β₁ a → β₂ (f₁ a)}\n    (h₁ : Injective f₁) (h₂ : ∀ a, Injective (f₂ a)) : Injective (Sigma.map f₁ f₂)\n  | ⟨i, x⟩, ⟨j, y⟩, h => by\n    obtain rfl : i = j := h₁ (Sigma.mk.inj_iff.mp h).1\n    obtain rfl : x = y := h₂ i (sigma_mk_injective h)\n    rfl\n\n"}
{"name":"Function.Injective.of_sigma_map","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α₁ : Type u_2\nα₂ : Type u_3\nβ₁ : α₁ → Type u_5\nβ₂ : α₂ → Type u_6\nf₁ : α₁ → α₂\nf₂ : (a : α₁) → β₁ a → β₂ (f₁ a)\nh : Function.Injective (Sigma.map f₁ f₂)\na : α₁\n⊢ Function.Injective (f₂ a)","decl":"theorem Function.Injective.of_sigma_map {f₁ : α₁ → α₂} {f₂ : ∀ a, β₁ a → β₂ (f₁ a)}\n    (h : Injective (Sigma.map f₁ f₂)) (a : α₁) : Injective (f₂ a) := fun x y hxy ↦\n  sigma_mk_injective <| @h ⟨a, x⟩ ⟨a, y⟩ (Sigma.ext rfl (heq_of_eq hxy))\n\n"}
{"name":"Function.Injective.sigma_map_iff","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α₁ : Type u_2\nα₂ : Type u_3\nβ₁ : α₁ → Type u_5\nβ₂ : α₂ → Type u_6\nf₁ : α₁ → α₂\nf₂ : (a : α₁) → β₁ a → β₂ (f₁ a)\nh₁ : Function.Injective f₁\n⊢ Iff (Function.Injective (Sigma.map f₁ f₂)) (∀ (a : α₁), Function.Injective (f₂ a))","decl":"theorem Function.Injective.sigma_map_iff {f₁ : α₁ → α₂} {f₂ : ∀ a, β₁ a → β₂ (f₁ a)}\n    (h₁ : Injective f₁) : Injective (Sigma.map f₁ f₂) ↔ ∀ a, Injective (f₂ a) :=\n  ⟨fun h ↦ h.of_sigma_map, h₁.sigma_map⟩\n\n"}
{"name":"Function.Surjective.sigma_map","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α₁ : Type u_2\nα₂ : Type u_3\nβ₁ : α₁ → Type u_5\nβ₂ : α₂ → Type u_6\nf₁ : α₁ → α₂\nf₂ : (a : α₁) → β₁ a → β₂ (f₁ a)\nh₁ : Function.Surjective f₁\nh₂ : ∀ (a : α₁), Function.Surjective (f₂ a)\n⊢ Function.Surjective (Sigma.map f₁ f₂)","decl":"theorem Function.Surjective.sigma_map {f₁ : α₁ → α₂} {f₂ : ∀ a, β₁ a → β₂ (f₁ a)}\n    (h₁ : Surjective f₁) (h₂ : ∀ a, Surjective (f₂ a)) : Surjective (Sigma.map f₁ f₂) := by\n  simp only [Surjective, Sigma.forall, h₁.forall]\n  exact fun i ↦ (h₂ _).forall.2 fun x ↦ ⟨⟨i, x⟩, rfl⟩\n\n"}
{"name":"Sigma.uncurry_curry","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_4\nγ : (a : α) → β a → Type u_7\nf : (x : Sigma β) → γ x.fst x.snd\n⊢ Eq (Sigma.uncurry (Sigma.curry f)) f","decl":"@[simp]\ntheorem Sigma.uncurry_curry {γ : ∀ a, β a → Type*} (f : ∀ x : Sigma β, γ x.1 x.2) :\n    Sigma.uncurry (Sigma.curry f) = f :=\n  funext fun ⟨_, _⟩ ↦ rfl\n\n"}
{"name":"Sigma.curry_uncurry","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_4\nγ : (a : α) → β a → Type u_7\nf : (x : α) → (y : β x) → γ x y\n⊢ Eq (Sigma.curry (Sigma.uncurry f)) f","decl":"@[simp]\ntheorem Sigma.curry_uncurry {γ : ∀ a, β a → Type*} (f : ∀ (x) (y : β x), γ x y) :\n    Sigma.curry (Sigma.uncurry f) = f :=\n  rfl\n\n"}
{"name":"Sigma.curry_update","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_4\nγ : (a : α) → β a → Type u_7\ninst✝¹ : DecidableEq α\ninst✝ : (a : α) → DecidableEq (β a)\ni : Sigma fun a => β a\nf : (i : Sigma fun a => β a) → γ i.fst i.snd\nx : γ i.fst i.snd\n⊢ Eq (Sigma.curry (Function.update f i x)) (Function.update (Sigma.curry f) i.fst (Function.update (Sigma.curry f i.fst) i.snd x))","decl":"theorem Sigma.curry_update {γ : ∀ a, β a → Type*} [DecidableEq α] [∀ a, DecidableEq (β a)]\n    (i : Σ a, β a) (f : (i : Σ a, β a) → γ i.1 i.2) (x : γ i.1 i.2) :\n    Sigma.curry (Function.update f i x) =\n      Function.update (Sigma.curry f) i.1 (Function.update (Sigma.curry f i.1) i.2 x) := by\n  obtain ⟨ia, ib⟩ := i\n  ext ja jb\n  unfold Sigma.curry\n  obtain rfl | ha := eq_or_ne ia ja\n  · obtain rfl | hb := eq_or_ne ib jb\n    · simp\n    · simp only [update_self]\n      rw [Function.update_of_ne (mt _ hb.symm), Function.update_of_ne hb.symm]\n      rintro h\n      injection h\n  · rw [Function.update_of_ne (ne_of_apply_ne Sigma.fst _), Function.update_of_ne]\n    · exact ha.symm\n    · exact ha.symm\n\n"}
{"name":"Prod.fst_comp_toSigma","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α : Type u_7\nβ : Type u_8\n⊢ Eq (Function.comp Sigma.fst Prod.toSigma) Prod.fst","decl":"@[simp]\ntheorem Prod.fst_comp_toSigma {α β} : Sigma.fst ∘ @Prod.toSigma α β = Prod.fst :=\n  rfl\n\n"}
{"name":"Prod.fst_toSigma","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α : Type u_7\nβ : Type u_8\nx : Prod α β\n⊢ Eq x.toSigma.fst x.fst","decl":"@[simp]\ntheorem Prod.fst_toSigma {α β} (x : α × β) : (Prod.toSigma x).fst = x.fst :=\n  rfl\n\n"}
{"name":"Prod.snd_toSigma","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α : Type u_7\nβ : Type u_8\nx : Prod α β\n⊢ Eq x.toSigma.snd x.snd","decl":"@[simp]\ntheorem Prod.snd_toSigma {α β} (x : α × β) : (Prod.toSigma x).snd = x.snd :=\n  rfl\n\n"}
{"name":"Prod.toSigma_mk","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α : Type u_7\nβ : Type u_8\nx : α\ny : β\n⊢ Eq { fst := x, snd := y }.toSigma ⟨x, y⟩","decl":"@[simp]\ntheorem Prod.toSigma_mk {α β} (x : α) (y : β) : (x, y).toSigma = ⟨x, y⟩ :=\n  rfl\n\n-- Porting note: the meta instance `has_reflect (Σa, β a)` was removed here.\n\n"}
{"name":"PSigma.elim_val","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α : Sort u_1\nβ : α → Sort u_2\nγ : Sort u_3\nf : (a : α) → β a → γ\na : α\nb : β a\n⊢ Eq (PSigma.elim f ⟨a, b⟩) (f a b)","decl":"@[simp]\ntheorem elim_val {γ} (f : ∀ a, β a → γ) (a b) : PSigma.elim f ⟨a, b⟩ = f a b :=\n  rfl\n\n"}
{"name":"PSigma.mk.inj","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α : Sort u\nβ : α → Sort v\nfst✝ : α\nsnd✝ : β fst✝\nfst : α\nsnd : β fst\nx✝ : Eq ⟨fst✝, snd✝⟩ ⟨fst, snd⟩\n⊢ And (Eq fst✝ fst) (HEq snd✝ snd)","decl":"gen_injective_theorems% PSigma\n\n"}
{"name":"PSigma.mk.injEq","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α : Sort u\nβ : α → Sort v\nfst✝ : α\nsnd✝ : β fst✝\nfst : α\nsnd : β fst\n⊢ Eq (Eq ⟨fst✝, snd✝⟩ ⟨fst, snd⟩) (And (Eq fst✝ fst) (HEq snd✝ snd))","decl":"gen_injective_theorems% PSigma\n\n"}
{"name":"PSigma.mk.inj_iff","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α : Sort u_1\nβ : α → Sort u_2\na₁ a₂ : α\nb₁ : β a₁\nb₂ : β a₂\n⊢ Iff (Eq ⟨a₁, b₁⟩ ⟨a₂, b₂⟩) (And (Eq a₁ a₂) (HEq b₁ b₂))","decl":"theorem mk.inj_iff {a₁ a₂ : α} {b₁ : β a₁} {b₂ : β a₂} :\n    @PSigma.mk α β a₁ b₁ = @PSigma.mk α β a₂ b₂ ↔ a₁ = a₂ ∧ HEq b₁ b₂ :=\n  (Iff.intro PSigma.mk.inj) fun ⟨h₁, h₂⟩ ↦\n    match a₁, a₂, b₁, b₂, h₁, h₂ with\n    | _, _, _, _, Eq.refl _, HEq.refl _ => rfl\n\n-- This should not be a simp lemma, since its discrimination tree key would just be `→`.\n"}
{"name":"PSigma.forall","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α : Sort u_1\nβ : α → Sort u_2\np : (PSigma fun a => β a) → Prop\n⊢ Iff (∀ (x : PSigma fun a => β a), p x) (∀ (a : α) (b : β a), p ⟨a, b⟩)","decl":"theorem «forall» {p : (Σ'a, β a) → Prop} : (∀ x, p x) ↔ ∀ a b, p ⟨a, b⟩ :=\n  ⟨fun h a b ↦ h ⟨a, b⟩, fun h ⟨a, b⟩ ↦ h a b⟩\n\n"}
{"name":"PSigma.exists","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α : Sort u_1\nβ : α → Sort u_2\np : (PSigma fun a => β a) → Prop\n⊢ Iff (Exists fun x => p x) (Exists fun a => Exists fun b => p ⟨a, b⟩)","decl":"@[simp] lemma «exists» {p : (Σ' a, β a) → Prop} : (∃ x, p x) ↔ ∃ a b, p ⟨a, b⟩ :=\n  ⟨fun ⟨⟨a, b⟩, h⟩ ↦ ⟨a, b, h⟩, fun ⟨a, b, h⟩ ↦ ⟨⟨a, b⟩, h⟩⟩\n\n"}
{"name":"PSigma.subtype_ext","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_3\np : α → β → Prop\nx₀ x₁ : PSigma fun a => Subtype (p a)\na✝¹ : Eq x₀.fst x₁.fst\na✝ : Eq x₀.snd.val x₁.snd.val\n⊢ Eq x₀ x₁","decl":"/-- A specialized ext lemma for equality of `PSigma` types over an indexed subtype. -/\n@[ext]\ntheorem subtype_ext {β : Sort*} {p : α → β → Prop} :\n    ∀ {x₀ x₁ : Σ'a, Subtype (p a)}, x₀.fst = x₁.fst → (x₀.snd : β) = x₁.snd → x₀ = x₁\n  | ⟨_, _, _⟩, ⟨_, _, _⟩, rfl, rfl => rfl\n\n"}
{"name":"PSigma.subtype_ext_iff","module":"Mathlib.Data.Sigma.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_3\np : α → β → Prop\nx₀ x₁ : PSigma fun a => Subtype (p a)\n⊢ Iff (Eq x₀ x₁) (And (Eq x₀.fst x₁.fst) (Eq x₀.snd.val x₁.snd.val))","decl":"/-- A specialized ext lemma for equality of `PSigma` types over an indexed subtype. -/\n@[ext]\ntheorem subtype_ext {β : Sort*} {p : α → β → Prop} :\n    ∀ {x₀ x₁ : Σ'a, Subtype (p a)}, x₀.fst = x₁.fst → (x₀.snd : β) = x₁.snd → x₀ = x₁\n  | ⟨_, _, _⟩, ⟨_, _, _⟩, rfl, rfl => rfl\n\n"}
