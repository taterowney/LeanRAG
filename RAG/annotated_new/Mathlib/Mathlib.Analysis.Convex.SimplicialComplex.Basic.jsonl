{"name":"Geometry.SimplicialComplex.mk.injEq","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nfaces✝ : Set (Finset E)\nnot_empty_mem✝ : Not (Membership.mem faces✝ EmptyCollection.emptyCollection)\nindep✝ : ∀ {s : Finset E}, Membership.mem faces✝ s → AffineIndependent 𝕜 Subtype.val\ndown_closed✝ : ∀ {s t : Finset E}, Membership.mem faces✝ s → HasSubset.Subset t s → Ne t EmptyCollection.emptyCollection → Membership.mem faces✝ t\ninter_subset_convexHull✝ : ∀ {s t : Finset E}, Membership.mem faces✝ s → Membership.mem faces✝ t → HasSubset.Subset (Inter.inter ((convexHull 𝕜) ↑s) ((convexHull 𝕜) ↑t)) ((convexHull 𝕜) (Inter.inter ↑s ↑t))\nfaces : Set (Finset E)\nnot_empty_mem : Not (Membership.mem faces EmptyCollection.emptyCollection)\nindep : ∀ {s : Finset E}, Membership.mem faces s → AffineIndependent 𝕜 Subtype.val\ndown_closed : ∀ {s t : Finset E}, Membership.mem faces s → HasSubset.Subset t s → Ne t EmptyCollection.emptyCollection → Membership.mem faces t\ninter_subset_convexHull : ∀ {s t : Finset E}, Membership.mem faces s → Membership.mem faces t → HasSubset.Subset (Inter.inter ((convexHull 𝕜) ↑s) ((convexHull 𝕜) ↑t)) ((convexHull 𝕜) (Inter.inter ↑s ↑t))\n⊢ Eq (Eq { faces := faces✝, not_empty_mem := not_empty_mem✝, indep := indep✝, down_closed := down_closed✝, inter_subset_convexHull := inter_subset_convexHull✝ } { faces := faces, not_empty_mem := not_empty_mem, indep := indep, down_closed := down_closed, inter_subset_convexHull := inter_subset_convexHull }) (Eq faces✝ faces)","decl":"/-- A simplicial complex in a `𝕜`-module is a collection of simplices which glue nicely together.\nNote that the textbook meaning of \"glue nicely\" is given in\n`Geometry.SimplicialComplex.disjoint_or_exists_inter_eq_convexHull`. It is mostly useless, as\n`Geometry.SimplicialComplex.convexHull_inter_convexHull` is enough for all purposes. -/\n@[ext]\nstructure SimplicialComplex where\n  /-- the faces of this simplicial complex: currently, given by their spanning vertices -/\n  faces : Set (Finset E)\n  /-- the empty set is not a face: hence, all faces are non-empty -/\n  not_empty_mem : ∅ ∉ faces\n  /-- the vertices in each face are affine independent: this is an implementation detail -/\n  indep : ∀ {s}, s ∈ faces → AffineIndependent 𝕜 ((↑) : s → E)\n  /-- faces are downward closed: a non-empty subset of its spanning vertices spans another face -/\n  down_closed : ∀ {s t}, s ∈ faces → t ⊆ s → t ≠ ∅ → t ∈ faces\n  inter_subset_convexHull : ∀ {s t}, s ∈ faces → t ∈ faces →\n    convexHull 𝕜 ↑s ∩ convexHull 𝕜 ↑t ⊆ convexHull 𝕜 (s ∩ t : Set E)\n\n"}
{"name":"Geometry.SimplicialComplex.inter_subset_convexHull","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nself : Geometry.SimplicialComplex 𝕜 E\ns t : Finset E\na✝¹ : Membership.mem self.faces s\na✝ : Membership.mem self.faces t\n⊢ HasSubset.Subset (Inter.inter ((convexHull 𝕜) ↑s) ((convexHull 𝕜) ↑t)) ((convexHull 𝕜) (Inter.inter ↑s ↑t))","decl":"/-- A simplicial complex in a `𝕜`-module is a collection of simplices which glue nicely together.\nNote that the textbook meaning of \"glue nicely\" is given in\n`Geometry.SimplicialComplex.disjoint_or_exists_inter_eq_convexHull`. It is mostly useless, as\n`Geometry.SimplicialComplex.convexHull_inter_convexHull` is enough for all purposes. -/\n@[ext]\nstructure SimplicialComplex where\n  /-- the faces of this simplicial complex: currently, given by their spanning vertices -/\n  faces : Set (Finset E)\n  /-- the empty set is not a face: hence, all faces are non-empty -/\n  not_empty_mem : ∅ ∉ faces\n  /-- the vertices in each face are affine independent: this is an implementation detail -/\n  indep : ∀ {s}, s ∈ faces → AffineIndependent 𝕜 ((↑) : s → E)\n  /-- faces are downward closed: a non-empty subset of its spanning vertices spans another face -/\n  down_closed : ∀ {s t}, s ∈ faces → t ⊆ s → t ≠ ∅ → t ∈ faces\n  inter_subset_convexHull : ∀ {s t}, s ∈ faces → t ∈ faces →\n    convexHull 𝕜 ↑s ∩ convexHull 𝕜 ↑t ⊆ convexHull 𝕜 (s ∩ t : Set E)\n\n"}
{"name":"Geometry.SimplicialComplex.mk.inj","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nfaces✝ : Set (Finset E)\nnot_empty_mem✝ : Not (Membership.mem faces✝ EmptyCollection.emptyCollection)\nindep✝ : ∀ {s : Finset E}, Membership.mem faces✝ s → AffineIndependent 𝕜 Subtype.val\ndown_closed✝ : ∀ {s t : Finset E}, Membership.mem faces✝ s → HasSubset.Subset t s → Ne t EmptyCollection.emptyCollection → Membership.mem faces✝ t\ninter_subset_convexHull✝ : ∀ {s t : Finset E}, Membership.mem faces✝ s → Membership.mem faces✝ t → HasSubset.Subset (Inter.inter ((convexHull 𝕜) ↑s) ((convexHull 𝕜) ↑t)) ((convexHull 𝕜) (Inter.inter ↑s ↑t))\nfaces : Set (Finset E)\nnot_empty_mem : Not (Membership.mem faces EmptyCollection.emptyCollection)\nindep : ∀ {s : Finset E}, Membership.mem faces s → AffineIndependent 𝕜 Subtype.val\ndown_closed : ∀ {s t : Finset E}, Membership.mem faces s → HasSubset.Subset t s → Ne t EmptyCollection.emptyCollection → Membership.mem faces t\ninter_subset_convexHull : ∀ {s t : Finset E}, Membership.mem faces s → Membership.mem faces t → HasSubset.Subset (Inter.inter ((convexHull 𝕜) ↑s) ((convexHull 𝕜) ↑t)) ((convexHull 𝕜) (Inter.inter ↑s ↑t))\nx✝ : Eq { faces := faces✝, not_empty_mem := not_empty_mem✝, indep := indep✝, down_closed := down_closed✝, inter_subset_convexHull := inter_subset_convexHull✝ } { faces := faces, not_empty_mem := not_empty_mem, indep := indep, down_closed := down_closed, inter_subset_convexHull := inter_subset_convexHull }\n⊢ Eq faces✝ faces","decl":"/-- A simplicial complex in a `𝕜`-module is a collection of simplices which glue nicely together.\nNote that the textbook meaning of \"glue nicely\" is given in\n`Geometry.SimplicialComplex.disjoint_or_exists_inter_eq_convexHull`. It is mostly useless, as\n`Geometry.SimplicialComplex.convexHull_inter_convexHull` is enough for all purposes. -/\n@[ext]\nstructure SimplicialComplex where\n  /-- the faces of this simplicial complex: currently, given by their spanning vertices -/\n  faces : Set (Finset E)\n  /-- the empty set is not a face: hence, all faces are non-empty -/\n  not_empty_mem : ∅ ∉ faces\n  /-- the vertices in each face are affine independent: this is an implementation detail -/\n  indep : ∀ {s}, s ∈ faces → AffineIndependent 𝕜 ((↑) : s → E)\n  /-- faces are downward closed: a non-empty subset of its spanning vertices spans another face -/\n  down_closed : ∀ {s t}, s ∈ faces → t ⊆ s → t ≠ ∅ → t ∈ faces\n  inter_subset_convexHull : ∀ {s t}, s ∈ faces → t ∈ faces →\n    convexHull 𝕜 ↑s ∩ convexHull 𝕜 ↑t ⊆ convexHull 𝕜 (s ∩ t : Set E)\n\n"}
{"name":"Geometry.SimplicialComplex.indep","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nself : Geometry.SimplicialComplex 𝕜 E\ns : Finset E\na✝ : Membership.mem self.faces s\n⊢ AffineIndependent 𝕜 Subtype.val","decl":"/-- A simplicial complex in a `𝕜`-module is a collection of simplices which glue nicely together.\nNote that the textbook meaning of \"glue nicely\" is given in\n`Geometry.SimplicialComplex.disjoint_or_exists_inter_eq_convexHull`. It is mostly useless, as\n`Geometry.SimplicialComplex.convexHull_inter_convexHull` is enough for all purposes. -/\n@[ext]\nstructure SimplicialComplex where\n  /-- the faces of this simplicial complex: currently, given by their spanning vertices -/\n  faces : Set (Finset E)\n  /-- the empty set is not a face: hence, all faces are non-empty -/\n  not_empty_mem : ∅ ∉ faces\n  /-- the vertices in each face are affine independent: this is an implementation detail -/\n  indep : ∀ {s}, s ∈ faces → AffineIndependent 𝕜 ((↑) : s → E)\n  /-- faces are downward closed: a non-empty subset of its spanning vertices spans another face -/\n  down_closed : ∀ {s t}, s ∈ faces → t ⊆ s → t ≠ ∅ → t ∈ faces\n  inter_subset_convexHull : ∀ {s t}, s ∈ faces → t ∈ faces →\n    convexHull 𝕜 ↑s ∩ convexHull 𝕜 ↑t ⊆ convexHull 𝕜 (s ∩ t : Set E)\n\n"}
{"name":"Geometry.SimplicialComplex.not_empty_mem","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nself : Geometry.SimplicialComplex 𝕜 E\n⊢ Not (Membership.mem self.faces EmptyCollection.emptyCollection)","decl":"/-- A simplicial complex in a `𝕜`-module is a collection of simplices which glue nicely together.\nNote that the textbook meaning of \"glue nicely\" is given in\n`Geometry.SimplicialComplex.disjoint_or_exists_inter_eq_convexHull`. It is mostly useless, as\n`Geometry.SimplicialComplex.convexHull_inter_convexHull` is enough for all purposes. -/\n@[ext]\nstructure SimplicialComplex where\n  /-- the faces of this simplicial complex: currently, given by their spanning vertices -/\n  faces : Set (Finset E)\n  /-- the empty set is not a face: hence, all faces are non-empty -/\n  not_empty_mem : ∅ ∉ faces\n  /-- the vertices in each face are affine independent: this is an implementation detail -/\n  indep : ∀ {s}, s ∈ faces → AffineIndependent 𝕜 ((↑) : s → E)\n  /-- faces are downward closed: a non-empty subset of its spanning vertices spans another face -/\n  down_closed : ∀ {s t}, s ∈ faces → t ⊆ s → t ≠ ∅ → t ∈ faces\n  inter_subset_convexHull : ∀ {s t}, s ∈ faces → t ∈ faces →\n    convexHull 𝕜 ↑s ∩ convexHull 𝕜 ↑t ⊆ convexHull 𝕜 (s ∩ t : Set E)\n\n"}
{"name":"Geometry.SimplicialComplex.ext_iff","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nx y : Geometry.SimplicialComplex 𝕜 E\n⊢ Iff (Eq x y) (Eq x.faces y.faces)","decl":"/-- A simplicial complex in a `𝕜`-module is a collection of simplices which glue nicely together.\nNote that the textbook meaning of \"glue nicely\" is given in\n`Geometry.SimplicialComplex.disjoint_or_exists_inter_eq_convexHull`. It is mostly useless, as\n`Geometry.SimplicialComplex.convexHull_inter_convexHull` is enough for all purposes. -/\n@[ext]\nstructure SimplicialComplex where\n  /-- the faces of this simplicial complex: currently, given by their spanning vertices -/\n  faces : Set (Finset E)\n  /-- the empty set is not a face: hence, all faces are non-empty -/\n  not_empty_mem : ∅ ∉ faces\n  /-- the vertices in each face are affine independent: this is an implementation detail -/\n  indep : ∀ {s}, s ∈ faces → AffineIndependent 𝕜 ((↑) : s → E)\n  /-- faces are downward closed: a non-empty subset of its spanning vertices spans another face -/\n  down_closed : ∀ {s t}, s ∈ faces → t ⊆ s → t ≠ ∅ → t ∈ faces\n  inter_subset_convexHull : ∀ {s t}, s ∈ faces → t ∈ faces →\n    convexHull 𝕜 ↑s ∩ convexHull 𝕜 ↑t ⊆ convexHull 𝕜 (s ∩ t : Set E)\n\n"}
{"name":"Geometry.SimplicialComplex.down_closed","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nself : Geometry.SimplicialComplex 𝕜 E\ns t : Finset E\na✝² : Membership.mem self.faces s\na✝¹ : HasSubset.Subset t s\na✝ : Ne t EmptyCollection.emptyCollection\n⊢ Membership.mem self.faces t","decl":"/-- A simplicial complex in a `𝕜`-module is a collection of simplices which glue nicely together.\nNote that the textbook meaning of \"glue nicely\" is given in\n`Geometry.SimplicialComplex.disjoint_or_exists_inter_eq_convexHull`. It is mostly useless, as\n`Geometry.SimplicialComplex.convexHull_inter_convexHull` is enough for all purposes. -/\n@[ext]\nstructure SimplicialComplex where\n  /-- the faces of this simplicial complex: currently, given by their spanning vertices -/\n  faces : Set (Finset E)\n  /-- the empty set is not a face: hence, all faces are non-empty -/\n  not_empty_mem : ∅ ∉ faces\n  /-- the vertices in each face are affine independent: this is an implementation detail -/\n  indep : ∀ {s}, s ∈ faces → AffineIndependent 𝕜 ((↑) : s → E)\n  /-- faces are downward closed: a non-empty subset of its spanning vertices spans another face -/\n  down_closed : ∀ {s t}, s ∈ faces → t ⊆ s → t ≠ ∅ → t ∈ faces\n  inter_subset_convexHull : ∀ {s t}, s ∈ faces → t ∈ faces →\n    convexHull 𝕜 ↑s ∩ convexHull 𝕜 ↑t ⊆ convexHull 𝕜 (s ∩ t : Set E)\n\n"}
{"name":"Geometry.SimplicialComplex.ext","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nx y : Geometry.SimplicialComplex 𝕜 E\nfaces : Eq x.faces y.faces\n⊢ Eq x y","decl":"/-- A simplicial complex in a `𝕜`-module is a collection of simplices which glue nicely together.\nNote that the textbook meaning of \"glue nicely\" is given in\n`Geometry.SimplicialComplex.disjoint_or_exists_inter_eq_convexHull`. It is mostly useless, as\n`Geometry.SimplicialComplex.convexHull_inter_convexHull` is enough for all purposes. -/\n@[ext]\nstructure SimplicialComplex where\n  /-- the faces of this simplicial complex: currently, given by their spanning vertices -/\n  faces : Set (Finset E)\n  /-- the empty set is not a face: hence, all faces are non-empty -/\n  not_empty_mem : ∅ ∉ faces\n  /-- the vertices in each face are affine independent: this is an implementation detail -/\n  indep : ∀ {s}, s ∈ faces → AffineIndependent 𝕜 ((↑) : s → E)\n  /-- faces are downward closed: a non-empty subset of its spanning vertices spans another face -/\n  down_closed : ∀ {s t}, s ∈ faces → t ⊆ s → t ≠ ∅ → t ∈ faces\n  inter_subset_convexHull : ∀ {s t}, s ∈ faces → t ∈ faces →\n    convexHull 𝕜 ↑s ∩ convexHull 𝕜 ↑t ⊆ convexHull 𝕜 (s ∩ t : Set E)\n\n"}
{"name":"Geometry.SimplicialComplex.mk.sizeOf_spec","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : OrderedRing 𝕜\ninst✝³ : AddCommGroup E\ninst✝² : Module 𝕜 E\ninst✝¹ : SizeOf 𝕜\ninst✝ : SizeOf E\nfaces : Set (Finset E)\nnot_empty_mem : Not (Membership.mem faces EmptyCollection.emptyCollection)\nindep : ∀ {s : Finset E}, Membership.mem faces s → AffineIndependent 𝕜 Subtype.val\ndown_closed : ∀ {s t : Finset E}, Membership.mem faces s → HasSubset.Subset t s → Ne t EmptyCollection.emptyCollection → Membership.mem faces t\ninter_subset_convexHull : ∀ {s t : Finset E}, Membership.mem faces s → Membership.mem faces t → HasSubset.Subset (Inter.inter ((convexHull 𝕜) ↑s) ((convexHull 𝕜) ↑t)) ((convexHull 𝕜) (Inter.inter ↑s ↑t))\n⊢ Eq (SizeOf.sizeOf { faces := faces, not_empty_mem := not_empty_mem, indep := indep, down_closed := down_closed, inter_subset_convexHull := inter_subset_convexHull }) 1","decl":"/-- A simplicial complex in a `𝕜`-module is a collection of simplices which glue nicely together.\nNote that the textbook meaning of \"glue nicely\" is given in\n`Geometry.SimplicialComplex.disjoint_or_exists_inter_eq_convexHull`. It is mostly useless, as\n`Geometry.SimplicialComplex.convexHull_inter_convexHull` is enough for all purposes. -/\n@[ext]\nstructure SimplicialComplex where\n  /-- the faces of this simplicial complex: currently, given by their spanning vertices -/\n  faces : Set (Finset E)\n  /-- the empty set is not a face: hence, all faces are non-empty -/\n  not_empty_mem : ∅ ∉ faces\n  /-- the vertices in each face are affine independent: this is an implementation detail -/\n  indep : ∀ {s}, s ∈ faces → AffineIndependent 𝕜 ((↑) : s → E)\n  /-- faces are downward closed: a non-empty subset of its spanning vertices spans another face -/\n  down_closed : ∀ {s t}, s ∈ faces → t ⊆ s → t ≠ ∅ → t ∈ faces\n  inter_subset_convexHull : ∀ {s t}, s ∈ faces → t ∈ faces →\n    convexHull 𝕜 ↑s ∩ convexHull 𝕜 ↑t ⊆ convexHull 𝕜 (s ∩ t : Set E)\n\n"}
{"name":"Geometry.SimplicialComplex.mem_space_iff","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nK : Geometry.SimplicialComplex 𝕜 E\nx : E\n⊢ Iff (Membership.mem K.space x) (Exists fun s => And (Membership.mem K.faces s) (Membership.mem ((convexHull 𝕜) ↑s) x))","decl":"theorem mem_space_iff : x ∈ K.space ↔ ∃ s ∈ K.faces, x ∈ convexHull 𝕜 (s : Set E) := by\n  simp [space]\n\n-- Porting note: Original proof was `:= subset_biUnion_of_mem hs`\n"}
{"name":"Geometry.SimplicialComplex.convexHull_subset_space","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nK : Geometry.SimplicialComplex 𝕜 E\ns : Finset E\nhs : Membership.mem K.faces s\n⊢ HasSubset.Subset ((convexHull 𝕜) ↑s) K.space","decl":"theorem convexHull_subset_space (hs : s ∈ K.faces) : convexHull 𝕜 ↑s ⊆ K.space := by\n  convert subset_biUnion_of_mem hs\n  rfl\n\n"}
{"name":"Geometry.SimplicialComplex.subset_space","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nK : Geometry.SimplicialComplex 𝕜 E\ns : Finset E\nhs : Membership.mem K.faces s\n⊢ HasSubset.Subset (↑s) K.space","decl":"protected theorem subset_space (hs : s ∈ K.faces) : (s : Set E) ⊆ K.space :=\n  (subset_convexHull 𝕜 _).trans <| convexHull_subset_space hs\n\n"}
{"name":"Geometry.SimplicialComplex.convexHull_inter_convexHull","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nK : Geometry.SimplicialComplex 𝕜 E\ns t : Finset E\nhs : Membership.mem K.faces s\nht : Membership.mem K.faces t\n⊢ Eq (Inter.inter ((convexHull 𝕜) ↑s) ((convexHull 𝕜) ↑t)) ((convexHull 𝕜) (Inter.inter ↑s ↑t))","decl":"theorem convexHull_inter_convexHull (hs : s ∈ K.faces) (ht : t ∈ K.faces) :\n    convexHull 𝕜 ↑s ∩ convexHull 𝕜 ↑t = convexHull 𝕜 (s ∩ t : Set E) :=\n  (K.inter_subset_convexHull hs ht).antisymm <|\n    subset_inter (convexHull_mono Set.inter_subset_left) <|\n      convexHull_mono Set.inter_subset_right\n\n"}
{"name":"Geometry.SimplicialComplex.disjoint_or_exists_inter_eq_convexHull","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nK : Geometry.SimplicialComplex 𝕜 E\ns t : Finset E\nhs : Membership.mem K.faces s\nht : Membership.mem K.faces t\n⊢ Or (Disjoint ((convexHull 𝕜) ↑s) ((convexHull 𝕜) ↑t)) (Exists fun u => And (Membership.mem K.faces u) (Eq (Inter.inter ((convexHull 𝕜) ↑s) ((convexHull 𝕜) ↑t)) ((convexHull 𝕜) ↑u)))","decl":"/-- The conclusion is the usual meaning of \"glue nicely\" in textbooks. It turns out to be quite\nunusable, as it's about faces as sets in space rather than simplices. Further, additional structure\non `𝕜` means the only choice of `u` is `s ∩ t` (but it's hard to prove). -/\ntheorem disjoint_or_exists_inter_eq_convexHull (hs : s ∈ K.faces) (ht : t ∈ K.faces) :\n    Disjoint (convexHull 𝕜 (s : Set E)) (convexHull 𝕜 ↑t) ∨\n      ∃ u ∈ K.faces, convexHull 𝕜 (s : Set E) ∩ convexHull 𝕜 ↑t = convexHull 𝕜 ↑u := by\n  classical\n  by_contra! h\n  refine h.2 (s ∩ t) (K.down_closed hs inter_subset_left fun hst => h.1 <|\n    disjoint_iff_inf_le.mpr <| (K.inter_subset_convexHull hs ht).trans ?_) ?_\n  · rw [← coe_inter, hst, coe_empty, convexHull_empty]\n    rfl\n  · rw [coe_inter, convexHull_inter_convexHull hs ht]\n\n"}
{"name":"Geometry.SimplicialComplex.ofErase_faces","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nfaces : Set (Finset E)\nindep : ∀ (s : Finset E), Membership.mem faces s → AffineIndependent 𝕜 Subtype.val\ndown_closed : ∀ (s : Finset E), Membership.mem faces s → ∀ (t : Finset E), HasSubset.Subset t s → Membership.mem faces t\ninter_subset_convexHull : ∀ (s : Finset E), Membership.mem faces s → ∀ (t : Finset E), Membership.mem faces t → HasSubset.Subset (Inter.inter ((convexHull 𝕜) ↑s) ((convexHull 𝕜) ↑t)) ((convexHull 𝕜) (Inter.inter ↑s ↑t))\n⊢ Eq (Geometry.SimplicialComplex.ofErase faces indep down_closed inter_subset_convexHull).faces (SDiff.sdiff faces (Singleton.singleton EmptyCollection.emptyCollection))","decl":"/-- Construct a simplicial complex by removing the empty face for you. -/\n@[simps]\ndef ofErase (faces : Set (Finset E)) (indep : ∀ s ∈ faces, AffineIndependent 𝕜 ((↑) : s → E))\n    (down_closed : ∀ s ∈ faces, ∀ t ⊆ s, t ∈ faces)\n    (inter_subset_convexHull : ∀ᵉ (s ∈ faces) (t ∈ faces),\n      convexHull 𝕜 ↑s ∩ convexHull 𝕜 ↑t ⊆ convexHull 𝕜 (s ∩ t : Set E)) :\n    SimplicialComplex 𝕜 E where\n  faces := faces \\ {∅}\n  not_empty_mem h := h.2 (mem_singleton _)\n  indep hs := indep _ hs.1\n  down_closed hs hts ht := ⟨down_closed _ hs.1 _ hts, ht⟩\n  inter_subset_convexHull hs ht := inter_subset_convexHull _ hs.1 _ ht.1\n\n"}
{"name":"Geometry.SimplicialComplex.ofSubcomplex_faces","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nK : Geometry.SimplicialComplex 𝕜 E\nfaces : Set (Finset E)\nsubset : HasSubset.Subset faces K.faces\ndown_closed : ∀ {s t : Finset E}, Membership.mem faces s → HasSubset.Subset t s → Membership.mem faces t\n⊢ Eq (K.ofSubcomplex faces subset down_closed).faces faces","decl":"/-- Construct a simplicial complex as a subset of a given simplicial complex. -/\n@[simps]\ndef ofSubcomplex (K : SimplicialComplex 𝕜 E) (faces : Set (Finset E)) (subset : faces ⊆ K.faces)\n    (down_closed : ∀ {s t}, s ∈ faces → t ⊆ s → t ∈ faces) : SimplicialComplex 𝕜 E :=\n  { faces\n    not_empty_mem := fun h => K.not_empty_mem (subset h)\n    indep := fun hs => K.indep (subset hs)\n    down_closed := fun hs hts _ => down_closed hs hts\n    inter_subset_convexHull := fun hs ht => K.inter_subset_convexHull (subset hs) (subset ht) }\n\n"}
{"name":"Geometry.SimplicialComplex.mem_vertices","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nK : Geometry.SimplicialComplex 𝕜 E\nx : E\n⊢ Iff (Membership.mem K.vertices x) (Membership.mem K.faces (Singleton.singleton x))","decl":"theorem mem_vertices : x ∈ K.vertices ↔ {x} ∈ K.faces := Iff.rfl\n\n"}
{"name":"Geometry.SimplicialComplex.vertices_eq","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nK : Geometry.SimplicialComplex 𝕜 E\n⊢ Eq K.vertices (Set.iUnion fun k => Set.iUnion fun h => ↑k)","decl":"theorem vertices_eq : K.vertices = ⋃ k ∈ K.faces, (k : Set E) := by\n  ext x\n  refine ⟨fun h => mem_biUnion h <| mem_coe.2 <| mem_singleton_self x, fun h => ?_⟩\n  obtain ⟨s, hs, hx⟩ := mem_iUnion₂.1 h\n  exact K.down_closed hs (Finset.singleton_subset_iff.2 <| mem_coe.1 hx) (singleton_ne_empty _)\n\n"}
{"name":"Geometry.SimplicialComplex.vertices_subset_space","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nK : Geometry.SimplicialComplex 𝕜 E\n⊢ HasSubset.Subset K.vertices K.space","decl":"theorem vertices_subset_space : K.vertices ⊆ K.space :=\n  vertices_eq.subset.trans <| iUnion₂_mono fun x _ => subset_convexHull 𝕜 (x : Set E)\n\n"}
{"name":"Geometry.SimplicialComplex.vertex_mem_convexHull_iff","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nK : Geometry.SimplicialComplex 𝕜 E\ns : Finset E\nx : E\nhx : Membership.mem K.vertices x\nhs : Membership.mem K.faces s\n⊢ Iff (Membership.mem ((convexHull 𝕜) ↑s) x) (Membership.mem s x)","decl":"theorem vertex_mem_convexHull_iff (hx : x ∈ K.vertices) (hs : s ∈ K.faces) :\n    x ∈ convexHull 𝕜 (s : Set E) ↔ x ∈ s := by\n  refine ⟨fun h => ?_, fun h => subset_convexHull 𝕜 _ h⟩\n  classical\n  have h := K.inter_subset_convexHull hx hs ⟨by simp, h⟩\n  by_contra H\n  rwa [← coe_inter, Finset.disjoint_iff_inter_eq_empty.1 (Finset.disjoint_singleton_right.2 H).symm,\n    coe_empty, convexHull_empty] at h\n\n"}
{"name":"Geometry.SimplicialComplex.face_subset_face_iff","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nK : Geometry.SimplicialComplex 𝕜 E\ns t : Finset E\nhs : Membership.mem K.faces s\nht : Membership.mem K.faces t\n⊢ Iff (HasSubset.Subset ((convexHull 𝕜) ↑s) ((convexHull 𝕜) ↑t)) (HasSubset.Subset s t)","decl":"/-- A face is a subset of another one iff its vertices are. -/\ntheorem face_subset_face_iff (hs : s ∈ K.faces) (ht : t ∈ K.faces) :\n    convexHull 𝕜 (s : Set E) ⊆ convexHull 𝕜 ↑t ↔ s ⊆ t :=\n  ⟨fun h _ hxs =>\n    (vertex_mem_convexHull_iff\n          (K.down_closed hs (Finset.singleton_subset_iff.2 hxs) <| singleton_ne_empty _) ht).1\n      (h (subset_convexHull 𝕜 (E := E) s hxs)),\n    convexHull_mono⟩\n\n"}
{"name":"Geometry.SimplicialComplex.mem_facets","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nK : Geometry.SimplicialComplex 𝕜 E\ns : Finset E\n⊢ Iff (Membership.mem K.facets s) (And (Membership.mem K.faces s) (∀ (t : Finset E), Membership.mem K.faces t → HasSubset.Subset s t → Eq s t))","decl":"theorem mem_facets : s ∈ K.facets ↔ s ∈ K.faces ∧ ∀ t ∈ K.faces, s ⊆ t → s = t :=\n  mem_sep_iff\n\n"}
{"name":"Geometry.SimplicialComplex.facets_subset","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nK : Geometry.SimplicialComplex 𝕜 E\n⊢ HasSubset.Subset K.facets K.faces","decl":"theorem facets_subset : K.facets ⊆ K.faces := fun _ hs => hs.1\n\n"}
{"name":"Geometry.SimplicialComplex.not_facet_iff_subface","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nK : Geometry.SimplicialComplex 𝕜 E\ns : Finset E\nhs : Membership.mem K.faces s\n⊢ Iff (Not (Membership.mem K.facets s)) (Exists fun t => And (Membership.mem K.faces t) (HasSSubset.SSubset s t))","decl":"theorem not_facet_iff_subface (hs : s ∈ K.faces) : s ∉ K.facets ↔ ∃ t, t ∈ K.faces ∧ s ⊂ t := by\n  refine ⟨fun hs' : ¬(_ ∧ _) => ?_, ?_⟩\n  · push_neg at hs'\n    obtain ⟨t, ht⟩ := hs' hs\n    exact ⟨t, ht.1, ⟨ht.2.1, fun hts => ht.2.2 (Subset.antisymm ht.2.1 hts)⟩⟩\n  · rintro ⟨t, ht⟩ ⟨hs, hs'⟩\n    have := hs' ht.1 ht.2.1\n    rw [this] at ht\n    exact ht.2.2 (Subset.refl t)\n\n"}
{"name":"Geometry.SimplicialComplex.faces_bot","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\n⊢ Eq Bot.bot.faces EmptyCollection.emptyCollection","decl":"theorem faces_bot : (⊥ : SimplicialComplex 𝕜 E).faces = ∅ := rfl\n\n"}
{"name":"Geometry.SimplicialComplex.space_bot","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\n⊢ Eq Bot.bot.space EmptyCollection.emptyCollection","decl":"theorem space_bot : (⊥ : SimplicialComplex 𝕜 E).space = ∅ :=\n  Set.biUnion_empty _\n\n"}
{"name":"Geometry.SimplicialComplex.facets_bot","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\n⊢ Eq Bot.bot.facets EmptyCollection.emptyCollection","decl":"theorem facets_bot : (⊥ : SimplicialComplex 𝕜 E).facets = ∅ :=\n  eq_empty_of_subset_empty facets_subset\n\n"}
