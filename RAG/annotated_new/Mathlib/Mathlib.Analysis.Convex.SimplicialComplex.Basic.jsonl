{"name":"Geometry.SimplicialComplex.mk.injEq","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nfacesâœ : Set (Finset E)\nnot_empty_memâœ : Not (Membership.mem facesâœ EmptyCollection.emptyCollection)\nindepâœ : âˆ€ {s : Finset E}, Membership.mem facesâœ s â†’ AffineIndependent ğ•œ Subtype.val\ndown_closedâœ : âˆ€ {s t : Finset E}, Membership.mem facesâœ s â†’ HasSubset.Subset t s â†’ Ne t EmptyCollection.emptyCollection â†’ Membership.mem facesâœ t\ninter_subset_convexHullâœ : âˆ€ {s t : Finset E}, Membership.mem facesâœ s â†’ Membership.mem facesâœ t â†’ HasSubset.Subset (Inter.inter ((convexHull ğ•œ) â†‘s) ((convexHull ğ•œ) â†‘t)) ((convexHull ğ•œ) (Inter.inter â†‘s â†‘t))\nfaces : Set (Finset E)\nnot_empty_mem : Not (Membership.mem faces EmptyCollection.emptyCollection)\nindep : âˆ€ {s : Finset E}, Membership.mem faces s â†’ AffineIndependent ğ•œ Subtype.val\ndown_closed : âˆ€ {s t : Finset E}, Membership.mem faces s â†’ HasSubset.Subset t s â†’ Ne t EmptyCollection.emptyCollection â†’ Membership.mem faces t\ninter_subset_convexHull : âˆ€ {s t : Finset E}, Membership.mem faces s â†’ Membership.mem faces t â†’ HasSubset.Subset (Inter.inter ((convexHull ğ•œ) â†‘s) ((convexHull ğ•œ) â†‘t)) ((convexHull ğ•œ) (Inter.inter â†‘s â†‘t))\nâŠ¢ Eq (Eq { faces := facesâœ, not_empty_mem := not_empty_memâœ, indep := indepâœ, down_closed := down_closedâœ, inter_subset_convexHull := inter_subset_convexHullâœ } { faces := faces, not_empty_mem := not_empty_mem, indep := indep, down_closed := down_closed, inter_subset_convexHull := inter_subset_convexHull }) (Eq facesâœ faces)","decl":"/-- A simplicial complex in a `ğ•œ`-module is a collection of simplices which glue nicely together.\nNote that the textbook meaning of \"glue nicely\" is given in\n`Geometry.SimplicialComplex.disjoint_or_exists_inter_eq_convexHull`. It is mostly useless, as\n`Geometry.SimplicialComplex.convexHull_inter_convexHull` is enough for all purposes. -/\n@[ext]\nstructure SimplicialComplex where\n  /-- the faces of this simplicial complex: currently, given by their spanning vertices -/\n  faces : Set (Finset E)\n  /-- the empty set is not a face: hence, all faces are non-empty -/\n  not_empty_mem : âˆ… âˆ‰ faces\n  /-- the vertices in each face are affine independent: this is an implementation detail -/\n  indep : âˆ€ {s}, s âˆˆ faces â†’ AffineIndependent ğ•œ ((â†‘) : s â†’ E)\n  /-- faces are downward closed: a non-empty subset of its spanning vertices spans another face -/\n  down_closed : âˆ€ {s t}, s âˆˆ faces â†’ t âŠ† s â†’ t â‰  âˆ… â†’ t âˆˆ faces\n  inter_subset_convexHull : âˆ€ {s t}, s âˆˆ faces â†’ t âˆˆ faces â†’\n    convexHull ğ•œ â†‘s âˆ© convexHull ğ•œ â†‘t âŠ† convexHull ğ•œ (s âˆ© t : Set E)\n\n"}
{"name":"Geometry.SimplicialComplex.inter_subset_convexHull","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nself : Geometry.SimplicialComplex ğ•œ E\ns t : Finset E\naâœÂ¹ : Membership.mem self.faces s\naâœ : Membership.mem self.faces t\nâŠ¢ HasSubset.Subset (Inter.inter ((convexHull ğ•œ) â†‘s) ((convexHull ğ•œ) â†‘t)) ((convexHull ğ•œ) (Inter.inter â†‘s â†‘t))","decl":"/-- A simplicial complex in a `ğ•œ`-module is a collection of simplices which glue nicely together.\nNote that the textbook meaning of \"glue nicely\" is given in\n`Geometry.SimplicialComplex.disjoint_or_exists_inter_eq_convexHull`. It is mostly useless, as\n`Geometry.SimplicialComplex.convexHull_inter_convexHull` is enough for all purposes. -/\n@[ext]\nstructure SimplicialComplex where\n  /-- the faces of this simplicial complex: currently, given by their spanning vertices -/\n  faces : Set (Finset E)\n  /-- the empty set is not a face: hence, all faces are non-empty -/\n  not_empty_mem : âˆ… âˆ‰ faces\n  /-- the vertices in each face are affine independent: this is an implementation detail -/\n  indep : âˆ€ {s}, s âˆˆ faces â†’ AffineIndependent ğ•œ ((â†‘) : s â†’ E)\n  /-- faces are downward closed: a non-empty subset of its spanning vertices spans another face -/\n  down_closed : âˆ€ {s t}, s âˆˆ faces â†’ t âŠ† s â†’ t â‰  âˆ… â†’ t âˆˆ faces\n  inter_subset_convexHull : âˆ€ {s t}, s âˆˆ faces â†’ t âˆˆ faces â†’\n    convexHull ğ•œ â†‘s âˆ© convexHull ğ•œ â†‘t âŠ† convexHull ğ•œ (s âˆ© t : Set E)\n\n"}
{"name":"Geometry.SimplicialComplex.mk.inj","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nfacesâœ : Set (Finset E)\nnot_empty_memâœ : Not (Membership.mem facesâœ EmptyCollection.emptyCollection)\nindepâœ : âˆ€ {s : Finset E}, Membership.mem facesâœ s â†’ AffineIndependent ğ•œ Subtype.val\ndown_closedâœ : âˆ€ {s t : Finset E}, Membership.mem facesâœ s â†’ HasSubset.Subset t s â†’ Ne t EmptyCollection.emptyCollection â†’ Membership.mem facesâœ t\ninter_subset_convexHullâœ : âˆ€ {s t : Finset E}, Membership.mem facesâœ s â†’ Membership.mem facesâœ t â†’ HasSubset.Subset (Inter.inter ((convexHull ğ•œ) â†‘s) ((convexHull ğ•œ) â†‘t)) ((convexHull ğ•œ) (Inter.inter â†‘s â†‘t))\nfaces : Set (Finset E)\nnot_empty_mem : Not (Membership.mem faces EmptyCollection.emptyCollection)\nindep : âˆ€ {s : Finset E}, Membership.mem faces s â†’ AffineIndependent ğ•œ Subtype.val\ndown_closed : âˆ€ {s t : Finset E}, Membership.mem faces s â†’ HasSubset.Subset t s â†’ Ne t EmptyCollection.emptyCollection â†’ Membership.mem faces t\ninter_subset_convexHull : âˆ€ {s t : Finset E}, Membership.mem faces s â†’ Membership.mem faces t â†’ HasSubset.Subset (Inter.inter ((convexHull ğ•œ) â†‘s) ((convexHull ğ•œ) â†‘t)) ((convexHull ğ•œ) (Inter.inter â†‘s â†‘t))\nxâœ : Eq { faces := facesâœ, not_empty_mem := not_empty_memâœ, indep := indepâœ, down_closed := down_closedâœ, inter_subset_convexHull := inter_subset_convexHullâœ } { faces := faces, not_empty_mem := not_empty_mem, indep := indep, down_closed := down_closed, inter_subset_convexHull := inter_subset_convexHull }\nâŠ¢ Eq facesâœ faces","decl":"/-- A simplicial complex in a `ğ•œ`-module is a collection of simplices which glue nicely together.\nNote that the textbook meaning of \"glue nicely\" is given in\n`Geometry.SimplicialComplex.disjoint_or_exists_inter_eq_convexHull`. It is mostly useless, as\n`Geometry.SimplicialComplex.convexHull_inter_convexHull` is enough for all purposes. -/\n@[ext]\nstructure SimplicialComplex where\n  /-- the faces of this simplicial complex: currently, given by their spanning vertices -/\n  faces : Set (Finset E)\n  /-- the empty set is not a face: hence, all faces are non-empty -/\n  not_empty_mem : âˆ… âˆ‰ faces\n  /-- the vertices in each face are affine independent: this is an implementation detail -/\n  indep : âˆ€ {s}, s âˆˆ faces â†’ AffineIndependent ğ•œ ((â†‘) : s â†’ E)\n  /-- faces are downward closed: a non-empty subset of its spanning vertices spans another face -/\n  down_closed : âˆ€ {s t}, s âˆˆ faces â†’ t âŠ† s â†’ t â‰  âˆ… â†’ t âˆˆ faces\n  inter_subset_convexHull : âˆ€ {s t}, s âˆˆ faces â†’ t âˆˆ faces â†’\n    convexHull ğ•œ â†‘s âˆ© convexHull ğ•œ â†‘t âŠ† convexHull ğ•œ (s âˆ© t : Set E)\n\n"}
{"name":"Geometry.SimplicialComplex.indep","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nself : Geometry.SimplicialComplex ğ•œ E\ns : Finset E\naâœ : Membership.mem self.faces s\nâŠ¢ AffineIndependent ğ•œ Subtype.val","decl":"/-- A simplicial complex in a `ğ•œ`-module is a collection of simplices which glue nicely together.\nNote that the textbook meaning of \"glue nicely\" is given in\n`Geometry.SimplicialComplex.disjoint_or_exists_inter_eq_convexHull`. It is mostly useless, as\n`Geometry.SimplicialComplex.convexHull_inter_convexHull` is enough for all purposes. -/\n@[ext]\nstructure SimplicialComplex where\n  /-- the faces of this simplicial complex: currently, given by their spanning vertices -/\n  faces : Set (Finset E)\n  /-- the empty set is not a face: hence, all faces are non-empty -/\n  not_empty_mem : âˆ… âˆ‰ faces\n  /-- the vertices in each face are affine independent: this is an implementation detail -/\n  indep : âˆ€ {s}, s âˆˆ faces â†’ AffineIndependent ğ•œ ((â†‘) : s â†’ E)\n  /-- faces are downward closed: a non-empty subset of its spanning vertices spans another face -/\n  down_closed : âˆ€ {s t}, s âˆˆ faces â†’ t âŠ† s â†’ t â‰  âˆ… â†’ t âˆˆ faces\n  inter_subset_convexHull : âˆ€ {s t}, s âˆˆ faces â†’ t âˆˆ faces â†’\n    convexHull ğ•œ â†‘s âˆ© convexHull ğ•œ â†‘t âŠ† convexHull ğ•œ (s âˆ© t : Set E)\n\n"}
{"name":"Geometry.SimplicialComplex.not_empty_mem","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nself : Geometry.SimplicialComplex ğ•œ E\nâŠ¢ Not (Membership.mem self.faces EmptyCollection.emptyCollection)","decl":"/-- A simplicial complex in a `ğ•œ`-module is a collection of simplices which glue nicely together.\nNote that the textbook meaning of \"glue nicely\" is given in\n`Geometry.SimplicialComplex.disjoint_or_exists_inter_eq_convexHull`. It is mostly useless, as\n`Geometry.SimplicialComplex.convexHull_inter_convexHull` is enough for all purposes. -/\n@[ext]\nstructure SimplicialComplex where\n  /-- the faces of this simplicial complex: currently, given by their spanning vertices -/\n  faces : Set (Finset E)\n  /-- the empty set is not a face: hence, all faces are non-empty -/\n  not_empty_mem : âˆ… âˆ‰ faces\n  /-- the vertices in each face are affine independent: this is an implementation detail -/\n  indep : âˆ€ {s}, s âˆˆ faces â†’ AffineIndependent ğ•œ ((â†‘) : s â†’ E)\n  /-- faces are downward closed: a non-empty subset of its spanning vertices spans another face -/\n  down_closed : âˆ€ {s t}, s âˆˆ faces â†’ t âŠ† s â†’ t â‰  âˆ… â†’ t âˆˆ faces\n  inter_subset_convexHull : âˆ€ {s t}, s âˆˆ faces â†’ t âˆˆ faces â†’\n    convexHull ğ•œ â†‘s âˆ© convexHull ğ•œ â†‘t âŠ† convexHull ğ•œ (s âˆ© t : Set E)\n\n"}
{"name":"Geometry.SimplicialComplex.ext_iff","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nx y : Geometry.SimplicialComplex ğ•œ E\nâŠ¢ Iff (Eq x y) (Eq x.faces y.faces)","decl":"/-- A simplicial complex in a `ğ•œ`-module is a collection of simplices which glue nicely together.\nNote that the textbook meaning of \"glue nicely\" is given in\n`Geometry.SimplicialComplex.disjoint_or_exists_inter_eq_convexHull`. It is mostly useless, as\n`Geometry.SimplicialComplex.convexHull_inter_convexHull` is enough for all purposes. -/\n@[ext]\nstructure SimplicialComplex where\n  /-- the faces of this simplicial complex: currently, given by their spanning vertices -/\n  faces : Set (Finset E)\n  /-- the empty set is not a face: hence, all faces are non-empty -/\n  not_empty_mem : âˆ… âˆ‰ faces\n  /-- the vertices in each face are affine independent: this is an implementation detail -/\n  indep : âˆ€ {s}, s âˆˆ faces â†’ AffineIndependent ğ•œ ((â†‘) : s â†’ E)\n  /-- faces are downward closed: a non-empty subset of its spanning vertices spans another face -/\n  down_closed : âˆ€ {s t}, s âˆˆ faces â†’ t âŠ† s â†’ t â‰  âˆ… â†’ t âˆˆ faces\n  inter_subset_convexHull : âˆ€ {s t}, s âˆˆ faces â†’ t âˆˆ faces â†’\n    convexHull ğ•œ â†‘s âˆ© convexHull ğ•œ â†‘t âŠ† convexHull ğ•œ (s âˆ© t : Set E)\n\n"}
{"name":"Geometry.SimplicialComplex.down_closed","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nself : Geometry.SimplicialComplex ğ•œ E\ns t : Finset E\naâœÂ² : Membership.mem self.faces s\naâœÂ¹ : HasSubset.Subset t s\naâœ : Ne t EmptyCollection.emptyCollection\nâŠ¢ Membership.mem self.faces t","decl":"/-- A simplicial complex in a `ğ•œ`-module is a collection of simplices which glue nicely together.\nNote that the textbook meaning of \"glue nicely\" is given in\n`Geometry.SimplicialComplex.disjoint_or_exists_inter_eq_convexHull`. It is mostly useless, as\n`Geometry.SimplicialComplex.convexHull_inter_convexHull` is enough for all purposes. -/\n@[ext]\nstructure SimplicialComplex where\n  /-- the faces of this simplicial complex: currently, given by their spanning vertices -/\n  faces : Set (Finset E)\n  /-- the empty set is not a face: hence, all faces are non-empty -/\n  not_empty_mem : âˆ… âˆ‰ faces\n  /-- the vertices in each face are affine independent: this is an implementation detail -/\n  indep : âˆ€ {s}, s âˆˆ faces â†’ AffineIndependent ğ•œ ((â†‘) : s â†’ E)\n  /-- faces are downward closed: a non-empty subset of its spanning vertices spans another face -/\n  down_closed : âˆ€ {s t}, s âˆˆ faces â†’ t âŠ† s â†’ t â‰  âˆ… â†’ t âˆˆ faces\n  inter_subset_convexHull : âˆ€ {s t}, s âˆˆ faces â†’ t âˆˆ faces â†’\n    convexHull ğ•œ â†‘s âˆ© convexHull ğ•œ â†‘t âŠ† convexHull ğ•œ (s âˆ© t : Set E)\n\n"}
{"name":"Geometry.SimplicialComplex.ext","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nx y : Geometry.SimplicialComplex ğ•œ E\nfaces : Eq x.faces y.faces\nâŠ¢ Eq x y","decl":"/-- A simplicial complex in a `ğ•œ`-module is a collection of simplices which glue nicely together.\nNote that the textbook meaning of \"glue nicely\" is given in\n`Geometry.SimplicialComplex.disjoint_or_exists_inter_eq_convexHull`. It is mostly useless, as\n`Geometry.SimplicialComplex.convexHull_inter_convexHull` is enough for all purposes. -/\n@[ext]\nstructure SimplicialComplex where\n  /-- the faces of this simplicial complex: currently, given by their spanning vertices -/\n  faces : Set (Finset E)\n  /-- the empty set is not a face: hence, all faces are non-empty -/\n  not_empty_mem : âˆ… âˆ‰ faces\n  /-- the vertices in each face are affine independent: this is an implementation detail -/\n  indep : âˆ€ {s}, s âˆˆ faces â†’ AffineIndependent ğ•œ ((â†‘) : s â†’ E)\n  /-- faces are downward closed: a non-empty subset of its spanning vertices spans another face -/\n  down_closed : âˆ€ {s t}, s âˆˆ faces â†’ t âŠ† s â†’ t â‰  âˆ… â†’ t âˆˆ faces\n  inter_subset_convexHull : âˆ€ {s t}, s âˆˆ faces â†’ t âˆˆ faces â†’\n    convexHull ğ•œ â†‘s âˆ© convexHull ğ•œ â†‘t âŠ† convexHull ğ•œ (s âˆ© t : Set E)\n\n"}
{"name":"Geometry.SimplicialComplex.mk.sizeOf_spec","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : OrderedRing ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : SizeOf ğ•œ\ninstâœ : SizeOf E\nfaces : Set (Finset E)\nnot_empty_mem : Not (Membership.mem faces EmptyCollection.emptyCollection)\nindep : âˆ€ {s : Finset E}, Membership.mem faces s â†’ AffineIndependent ğ•œ Subtype.val\ndown_closed : âˆ€ {s t : Finset E}, Membership.mem faces s â†’ HasSubset.Subset t s â†’ Ne t EmptyCollection.emptyCollection â†’ Membership.mem faces t\ninter_subset_convexHull : âˆ€ {s t : Finset E}, Membership.mem faces s â†’ Membership.mem faces t â†’ HasSubset.Subset (Inter.inter ((convexHull ğ•œ) â†‘s) ((convexHull ğ•œ) â†‘t)) ((convexHull ğ•œ) (Inter.inter â†‘s â†‘t))\nâŠ¢ Eq (SizeOf.sizeOf { faces := faces, not_empty_mem := not_empty_mem, indep := indep, down_closed := down_closed, inter_subset_convexHull := inter_subset_convexHull }) 1","decl":"/-- A simplicial complex in a `ğ•œ`-module is a collection of simplices which glue nicely together.\nNote that the textbook meaning of \"glue nicely\" is given in\n`Geometry.SimplicialComplex.disjoint_or_exists_inter_eq_convexHull`. It is mostly useless, as\n`Geometry.SimplicialComplex.convexHull_inter_convexHull` is enough for all purposes. -/\n@[ext]\nstructure SimplicialComplex where\n  /-- the faces of this simplicial complex: currently, given by their spanning vertices -/\n  faces : Set (Finset E)\n  /-- the empty set is not a face: hence, all faces are non-empty -/\n  not_empty_mem : âˆ… âˆ‰ faces\n  /-- the vertices in each face are affine independent: this is an implementation detail -/\n  indep : âˆ€ {s}, s âˆˆ faces â†’ AffineIndependent ğ•œ ((â†‘) : s â†’ E)\n  /-- faces are downward closed: a non-empty subset of its spanning vertices spans another face -/\n  down_closed : âˆ€ {s t}, s âˆˆ faces â†’ t âŠ† s â†’ t â‰  âˆ… â†’ t âˆˆ faces\n  inter_subset_convexHull : âˆ€ {s t}, s âˆˆ faces â†’ t âˆˆ faces â†’\n    convexHull ğ•œ â†‘s âˆ© convexHull ğ•œ â†‘t âŠ† convexHull ğ•œ (s âˆ© t : Set E)\n\n"}
{"name":"Geometry.SimplicialComplex.mem_space_iff","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nK : Geometry.SimplicialComplex ğ•œ E\nx : E\nâŠ¢ Iff (Membership.mem K.space x) (Exists fun s => And (Membership.mem K.faces s) (Membership.mem ((convexHull ğ•œ) â†‘s) x))","decl":"theorem mem_space_iff : x âˆˆ K.space â†” âˆƒ s âˆˆ K.faces, x âˆˆ convexHull ğ•œ (s : Set E) := by\n  simp [space]\n\n-- Porting note: Original proof was `:= subset_biUnion_of_mem hs`\n"}
{"name":"Geometry.SimplicialComplex.convexHull_subset_space","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nK : Geometry.SimplicialComplex ğ•œ E\ns : Finset E\nhs : Membership.mem K.faces s\nâŠ¢ HasSubset.Subset ((convexHull ğ•œ) â†‘s) K.space","decl":"theorem convexHull_subset_space (hs : s âˆˆ K.faces) : convexHull ğ•œ â†‘s âŠ† K.space := by\n  convert subset_biUnion_of_mem hs\n  rfl\n\n"}
{"name":"Geometry.SimplicialComplex.subset_space","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nK : Geometry.SimplicialComplex ğ•œ E\ns : Finset E\nhs : Membership.mem K.faces s\nâŠ¢ HasSubset.Subset (â†‘s) K.space","decl":"protected theorem subset_space (hs : s âˆˆ K.faces) : (s : Set E) âŠ† K.space :=\n  (subset_convexHull ğ•œ _).trans <| convexHull_subset_space hs\n\n"}
{"name":"Geometry.SimplicialComplex.convexHull_inter_convexHull","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nK : Geometry.SimplicialComplex ğ•œ E\ns t : Finset E\nhs : Membership.mem K.faces s\nht : Membership.mem K.faces t\nâŠ¢ Eq (Inter.inter ((convexHull ğ•œ) â†‘s) ((convexHull ğ•œ) â†‘t)) ((convexHull ğ•œ) (Inter.inter â†‘s â†‘t))","decl":"theorem convexHull_inter_convexHull (hs : s âˆˆ K.faces) (ht : t âˆˆ K.faces) :\n    convexHull ğ•œ â†‘s âˆ© convexHull ğ•œ â†‘t = convexHull ğ•œ (s âˆ© t : Set E) :=\n  (K.inter_subset_convexHull hs ht).antisymm <|\n    subset_inter (convexHull_mono Set.inter_subset_left) <|\n      convexHull_mono Set.inter_subset_right\n\n"}
{"name":"Geometry.SimplicialComplex.disjoint_or_exists_inter_eq_convexHull","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nK : Geometry.SimplicialComplex ğ•œ E\ns t : Finset E\nhs : Membership.mem K.faces s\nht : Membership.mem K.faces t\nâŠ¢ Or (Disjoint ((convexHull ğ•œ) â†‘s) ((convexHull ğ•œ) â†‘t)) (Exists fun u => And (Membership.mem K.faces u) (Eq (Inter.inter ((convexHull ğ•œ) â†‘s) ((convexHull ğ•œ) â†‘t)) ((convexHull ğ•œ) â†‘u)))","decl":"/-- The conclusion is the usual meaning of \"glue nicely\" in textbooks. It turns out to be quite\nunusable, as it's about faces as sets in space rather than simplices. Further, additional structure\non `ğ•œ` means the only choice of `u` is `s âˆ© t` (but it's hard to prove). -/\ntheorem disjoint_or_exists_inter_eq_convexHull (hs : s âˆˆ K.faces) (ht : t âˆˆ K.faces) :\n    Disjoint (convexHull ğ•œ (s : Set E)) (convexHull ğ•œ â†‘t) âˆ¨\n      âˆƒ u âˆˆ K.faces, convexHull ğ•œ (s : Set E) âˆ© convexHull ğ•œ â†‘t = convexHull ğ•œ â†‘u := by\n  classical\n  by_contra! h\n  refine h.2 (s âˆ© t) (K.down_closed hs inter_subset_left fun hst => h.1 <|\n    disjoint_iff_inf_le.mpr <| (K.inter_subset_convexHull hs ht).trans ?_) ?_\n  Â· rw [â† coe_inter, hst, coe_empty, convexHull_empty]\n    rfl\n  Â· rw [coe_inter, convexHull_inter_convexHull hs ht]\n\n"}
{"name":"Geometry.SimplicialComplex.ofErase_faces","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nfaces : Set (Finset E)\nindep : âˆ€ (s : Finset E), Membership.mem faces s â†’ AffineIndependent ğ•œ Subtype.val\ndown_closed : âˆ€ (s : Finset E), Membership.mem faces s â†’ âˆ€ (t : Finset E), HasSubset.Subset t s â†’ Membership.mem faces t\ninter_subset_convexHull : âˆ€ (s : Finset E), Membership.mem faces s â†’ âˆ€ (t : Finset E), Membership.mem faces t â†’ HasSubset.Subset (Inter.inter ((convexHull ğ•œ) â†‘s) ((convexHull ğ•œ) â†‘t)) ((convexHull ğ•œ) (Inter.inter â†‘s â†‘t))\nâŠ¢ Eq (Geometry.SimplicialComplex.ofErase faces indep down_closed inter_subset_convexHull).faces (SDiff.sdiff faces (Singleton.singleton EmptyCollection.emptyCollection))","decl":"/-- Construct a simplicial complex by removing the empty face for you. -/\n@[simps]\ndef ofErase (faces : Set (Finset E)) (indep : âˆ€ s âˆˆ faces, AffineIndependent ğ•œ ((â†‘) : s â†’ E))\n    (down_closed : âˆ€ s âˆˆ faces, âˆ€ t âŠ† s, t âˆˆ faces)\n    (inter_subset_convexHull : âˆ€áµ‰ (s âˆˆ faces) (t âˆˆ faces),\n      convexHull ğ•œ â†‘s âˆ© convexHull ğ•œ â†‘t âŠ† convexHull ğ•œ (s âˆ© t : Set E)) :\n    SimplicialComplex ğ•œ E where\n  faces := faces \\ {âˆ…}\n  not_empty_mem h := h.2 (mem_singleton _)\n  indep hs := indep _ hs.1\n  down_closed hs hts ht := âŸ¨down_closed _ hs.1 _ hts, htâŸ©\n  inter_subset_convexHull hs ht := inter_subset_convexHull _ hs.1 _ ht.1\n\n"}
{"name":"Geometry.SimplicialComplex.ofSubcomplex_faces","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nK : Geometry.SimplicialComplex ğ•œ E\nfaces : Set (Finset E)\nsubset : HasSubset.Subset faces K.faces\ndown_closed : âˆ€ {s t : Finset E}, Membership.mem faces s â†’ HasSubset.Subset t s â†’ Membership.mem faces t\nâŠ¢ Eq (K.ofSubcomplex faces subset down_closed).faces faces","decl":"/-- Construct a simplicial complex as a subset of a given simplicial complex. -/\n@[simps]\ndef ofSubcomplex (K : SimplicialComplex ğ•œ E) (faces : Set (Finset E)) (subset : faces âŠ† K.faces)\n    (down_closed : âˆ€ {s t}, s âˆˆ faces â†’ t âŠ† s â†’ t âˆˆ faces) : SimplicialComplex ğ•œ E :=\n  { faces\n    not_empty_mem := fun h => K.not_empty_mem (subset h)\n    indep := fun hs => K.indep (subset hs)\n    down_closed := fun hs hts _ => down_closed hs hts\n    inter_subset_convexHull := fun hs ht => K.inter_subset_convexHull (subset hs) (subset ht) }\n\n"}
{"name":"Geometry.SimplicialComplex.mem_vertices","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nK : Geometry.SimplicialComplex ğ•œ E\nx : E\nâŠ¢ Iff (Membership.mem K.vertices x) (Membership.mem K.faces (Singleton.singleton x))","decl":"theorem mem_vertices : x âˆˆ K.vertices â†” {x} âˆˆ K.faces := Iff.rfl\n\n"}
{"name":"Geometry.SimplicialComplex.vertices_eq","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nK : Geometry.SimplicialComplex ğ•œ E\nâŠ¢ Eq K.vertices (Set.iUnion fun k => Set.iUnion fun h => â†‘k)","decl":"theorem vertices_eq : K.vertices = â‹ƒ k âˆˆ K.faces, (k : Set E) := by\n  ext x\n  refine âŸ¨fun h => mem_biUnion h <| mem_coe.2 <| mem_singleton_self x, fun h => ?_âŸ©\n  obtain âŸ¨s, hs, hxâŸ© := mem_iUnionâ‚‚.1 h\n  exact K.down_closed hs (Finset.singleton_subset_iff.2 <| mem_coe.1 hx) (singleton_ne_empty _)\n\n"}
{"name":"Geometry.SimplicialComplex.vertices_subset_space","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nK : Geometry.SimplicialComplex ğ•œ E\nâŠ¢ HasSubset.Subset K.vertices K.space","decl":"theorem vertices_subset_space : K.vertices âŠ† K.space :=\n  vertices_eq.subset.trans <| iUnionâ‚‚_mono fun x _ => subset_convexHull ğ•œ (x : Set E)\n\n"}
{"name":"Geometry.SimplicialComplex.vertex_mem_convexHull_iff","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nK : Geometry.SimplicialComplex ğ•œ E\ns : Finset E\nx : E\nhx : Membership.mem K.vertices x\nhs : Membership.mem K.faces s\nâŠ¢ Iff (Membership.mem ((convexHull ğ•œ) â†‘s) x) (Membership.mem s x)","decl":"theorem vertex_mem_convexHull_iff (hx : x âˆˆ K.vertices) (hs : s âˆˆ K.faces) :\n    x âˆˆ convexHull ğ•œ (s : Set E) â†” x âˆˆ s := by\n  refine âŸ¨fun h => ?_, fun h => subset_convexHull ğ•œ _ hâŸ©\n  classical\n  have h := K.inter_subset_convexHull hx hs âŸ¨by simp, hâŸ©\n  by_contra H\n  rwa [â† coe_inter, Finset.disjoint_iff_inter_eq_empty.1 (Finset.disjoint_singleton_right.2 H).symm,\n    coe_empty, convexHull_empty] at h\n\n"}
{"name":"Geometry.SimplicialComplex.face_subset_face_iff","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nK : Geometry.SimplicialComplex ğ•œ E\ns t : Finset E\nhs : Membership.mem K.faces s\nht : Membership.mem K.faces t\nâŠ¢ Iff (HasSubset.Subset ((convexHull ğ•œ) â†‘s) ((convexHull ğ•œ) â†‘t)) (HasSubset.Subset s t)","decl":"/-- A face is a subset of another one iff its vertices are. -/\ntheorem face_subset_face_iff (hs : s âˆˆ K.faces) (ht : t âˆˆ K.faces) :\n    convexHull ğ•œ (s : Set E) âŠ† convexHull ğ•œ â†‘t â†” s âŠ† t :=\n  âŸ¨fun h _ hxs =>\n    (vertex_mem_convexHull_iff\n          (K.down_closed hs (Finset.singleton_subset_iff.2 hxs) <| singleton_ne_empty _) ht).1\n      (h (subset_convexHull ğ•œ (E := E) s hxs)),\n    convexHull_monoâŸ©\n\n"}
{"name":"Geometry.SimplicialComplex.mem_facets","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nK : Geometry.SimplicialComplex ğ•œ E\ns : Finset E\nâŠ¢ Iff (Membership.mem K.facets s) (And (Membership.mem K.faces s) (âˆ€ (t : Finset E), Membership.mem K.faces t â†’ HasSubset.Subset s t â†’ Eq s t))","decl":"theorem mem_facets : s âˆˆ K.facets â†” s âˆˆ K.faces âˆ§ âˆ€ t âˆˆ K.faces, s âŠ† t â†’ s = t :=\n  mem_sep_iff\n\n"}
{"name":"Geometry.SimplicialComplex.facets_subset","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nK : Geometry.SimplicialComplex ğ•œ E\nâŠ¢ HasSubset.Subset K.facets K.faces","decl":"theorem facets_subset : K.facets âŠ† K.faces := fun _ hs => hs.1\n\n"}
{"name":"Geometry.SimplicialComplex.not_facet_iff_subface","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nK : Geometry.SimplicialComplex ğ•œ E\ns : Finset E\nhs : Membership.mem K.faces s\nâŠ¢ Iff (Not (Membership.mem K.facets s)) (Exists fun t => And (Membership.mem K.faces t) (HasSSubset.SSubset s t))","decl":"theorem not_facet_iff_subface (hs : s âˆˆ K.faces) : s âˆ‰ K.facets â†” âˆƒ t, t âˆˆ K.faces âˆ§ s âŠ‚ t := by\n  refine âŸ¨fun hs' : Â¬(_ âˆ§ _) => ?_, ?_âŸ©\n  Â· push_neg at hs'\n    obtain âŸ¨t, htâŸ© := hs' hs\n    exact âŸ¨t, ht.1, âŸ¨ht.2.1, fun hts => ht.2.2 (Subset.antisymm ht.2.1 hts)âŸ©âŸ©\n  Â· rintro âŸ¨t, htâŸ© âŸ¨hs, hs'âŸ©\n    have := hs' ht.1 ht.2.1\n    rw [this] at ht\n    exact ht.2.2 (Subset.refl t)\n\n"}
{"name":"Geometry.SimplicialComplex.faces_bot","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nâŠ¢ Eq Bot.bot.faces EmptyCollection.emptyCollection","decl":"theorem faces_bot : (âŠ¥ : SimplicialComplex ğ•œ E).faces = âˆ… := rfl\n\n"}
{"name":"Geometry.SimplicialComplex.space_bot","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nâŠ¢ Eq Bot.bot.space EmptyCollection.emptyCollection","decl":"theorem space_bot : (âŠ¥ : SimplicialComplex ğ•œ E).space = âˆ… :=\n  Set.biUnion_empty _\n\n"}
{"name":"Geometry.SimplicialComplex.facets_bot","module":"Mathlib.Analysis.Convex.SimplicialComplex.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nâŠ¢ Eq Bot.bot.facets EmptyCollection.emptyCollection","decl":"theorem facets_bot : (âŠ¥ : SimplicialComplex ğ•œ E).facets = âˆ… :=\n  eq_empty_of_subset_empty facets_subset\n\n"}
