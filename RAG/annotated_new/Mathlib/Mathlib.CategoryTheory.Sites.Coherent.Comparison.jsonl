{"name":"CategoryTheory.instPreregularOfPrecoherentOfHasFiniteCoproducts","module":"Mathlib.CategoryTheory.Sites.Coherent.Comparison","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Precoherent C\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\n⊢ CategoryTheory.Preregular C","decl":"instance [Precoherent C] [HasFiniteCoproducts C] : Preregular C where\n  exists_fac {X Y Z} f g _ := by\n    have hp := Precoherent.pullback f PUnit (fun () ↦ Z) (fun () ↦ g)\n    simp only [exists_const] at hp\n    rw [← effectiveEpi_iff_effectiveEpiFamily g] at hp\n    obtain ⟨β, _, X₂, π₂, h, ι, hι⟩ := hp inferInstance\n    refine ⟨∐ X₂, Sigma.desc π₂, inferInstance, Sigma.desc ι, ?_⟩\n    ext b\n    simpa using hι b\n\n"}
{"name":"CategoryTheory.instPrecoherentOfFinitaryPreExtensiveOfPreregular","module":"Mathlib.CategoryTheory.Sites.Coherent.Comparison","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.FinitaryPreExtensive C\ninst✝ : CategoryTheory.Preregular C\n⊢ CategoryTheory.Precoherent C","decl":"instance [FinitaryPreExtensive C] [Preregular C] : Precoherent C where\n  pullback {B₁ B₂} f α _ X₁ π₁ h := by\n    refine ⟨α, inferInstance, ?_⟩\n    obtain ⟨Y, g, _, g', hg⟩ := Preregular.exists_fac f (Sigma.desc π₁)\n    let X₂ := fun a ↦ pullback g' (Sigma.ι X₁ a)\n    let π₂ := fun a ↦ pullback.fst g' (Sigma.ι X₁ a) ≫ g\n    let π' := fun a ↦ pullback.fst g' (Sigma.ι X₁ a)\n    have _ := FinitaryPreExtensive.sigma_desc_iso (fun a ↦ Sigma.ι X₁ a) g' inferInstance\n    refine ⟨X₂, π₂, ?_, ?_⟩\n    · have : (Sigma.desc π' ≫ g) = Sigma.desc π₂ := by ext; simp [π₂, π']\n      rw [← effectiveEpi_desc_iff_effectiveEpiFamily, ← this]\n      infer_instance\n    · refine ⟨id, fun b ↦ pullback.snd _ _, fun b ↦ ?_⟩\n      simp only [X₂, π₂, id_eq, Category.assoc, ← hg]\n      rw [← Category.assoc, pullback.condition]\n      simp\n\n"}
{"name":"CategoryTheory.extensive_regular_generate_coherent","module":"Mathlib.CategoryTheory.Sites.Coherent.Comparison","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preregular C\ninst✝ : CategoryTheory.FinitaryPreExtensive C\n⊢ Eq (CategoryTheory.Coverage.toGrothendieck C (Max.max (CategoryTheory.extensiveCoverage C) (CategoryTheory.regularCoverage C))) (CategoryTheory.coherentTopology C)","decl":"/-- The union of the extensive and regular coverages generates the coherent topology on `C`. -/\ntheorem extensive_regular_generate_coherent [Preregular C] [FinitaryPreExtensive C] :\n    ((extensiveCoverage C) ⊔ (regularCoverage C)).toGrothendieck =\n    (coherentTopology C) := by\n  ext B S\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · induction h with\n    | of Y T hT =>\n      apply Coverage.Saturate.of\n      simp only [Coverage.sup_covering, Set.mem_union] at hT\n      exact Or.elim hT\n        (fun ⟨α, x, X, π, ⟨h, _⟩⟩ ↦ ⟨α, x, X, π, ⟨h, inferInstance⟩⟩)\n        (fun ⟨Z, f, ⟨h, _⟩⟩ ↦ ⟨Unit, inferInstance, fun _ ↦ Z, fun _ ↦ f, ⟨h, inferInstance⟩⟩)\n    | top => apply Coverage.Saturate.top\n    | transitive Y T => apply Coverage.Saturate.transitive Y T<;> [assumption; assumption]\n  · induction h with\n    | of Y T hT =>\n      obtain ⟨I, _, X, f, rfl, hT⟩ := hT\n      apply Coverage.Saturate.transitive Y (generate (Presieve.ofArrows\n        (fun (_ : Unit) ↦ (∐ fun (i : I) => X i)) (fun (_ : Unit) ↦ Sigma.desc f)))\n      · apply Coverage.Saturate.of\n        simp only [Coverage.sup_covering, extensiveCoverage, regularCoverage, Set.mem_union,\n          Set.mem_setOf_eq]\n        exact Or.inr ⟨_, Sigma.desc f, ⟨rfl, inferInstance⟩⟩\n      · rintro R g ⟨W, ψ, σ, ⟨⟩, rfl⟩\n        change _ ∈ ((extensiveCoverage C) ⊔ (regularCoverage C)).toGrothendieck _ R\n        rw [Sieve.pullback_comp]\n        apply pullback_stable\n        have : generate (Presieve.ofArrows X fun (i : I) ↦ Sigma.ι X i) ≤\n            (generate (Presieve.ofArrows X f)).pullback (Sigma.desc f) := by\n          rintro Q q ⟨E, e, r, ⟨hq, rfl⟩⟩\n          exact ⟨E, e, r ≫ (Sigma.desc f), by cases hq; simpa using Presieve.ofArrows.mk _, by simp⟩\n        apply Coverage.saturate_of_superset _ this\n        apply Coverage.Saturate.of\n        refine Or.inl ⟨I, inferInstance, _, _, ⟨rfl, ?_⟩⟩\n        convert IsIso.id _\n        aesop\n    | top => apply Coverage.Saturate.top\n    | transitive Y T => apply Coverage.Saturate.transitive Y T<;> [assumption; assumption]\n\n"}
