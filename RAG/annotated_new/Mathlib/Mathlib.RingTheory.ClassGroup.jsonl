{"name":"toPrincipalIdeal_def","module":"Mathlib.RingTheory.ClassGroup","initialProofState":"R : Type u_3\nK : Type u_4\ninst✝³ : CommRing R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\n⊢ Eq (toPrincipalIdeal R K) { toFun := fun x => { val := FractionalIdeal.spanSingleton (nonZeroDivisors R) ↑x, inv := FractionalIdeal.spanSingleton (nonZeroDivisors R) (Inv.inv ↑x), val_inv := ⋯, inv_val := ⋯ }, map_one' := ⋯, map_mul' := ⋯ }","decl":"/-- `toPrincipalIdeal R K x` sends `x ≠ 0 : K` to the fractional `R`-ideal generated by `x` -/\nirreducible_def toPrincipalIdeal : Kˣ →* (FractionalIdeal R⁰ K)ˣ :=\n  { toFun := fun x =>\n      ⟨spanSingleton _ x, spanSingleton _ x⁻¹, by\n        simp only [spanSingleton_one, Units.mul_inv', spanSingleton_mul_spanSingleton], by\n        simp only [spanSingleton_one, Units.inv_mul', spanSingleton_mul_spanSingleton]⟩\n    map_mul' := fun x y =>\n      ext (by simp only [Units.val_mk, Units.val_mul, spanSingleton_mul_spanSingleton])\n    map_one' := ext (by simp only [spanSingleton_one, Units.val_mk, Units.val_one]) }\n\n"}
{"name":"coe_toPrincipalIdeal","module":"Mathlib.RingTheory.ClassGroup","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝³ : CommRing R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nx : Units K\n⊢ Eq (↑((toPrincipalIdeal R K) x)) (FractionalIdeal.spanSingleton (nonZeroDivisors R) ↑x)","decl":"@[simp]\ntheorem coe_toPrincipalIdeal (x : Kˣ) :\n    (toPrincipalIdeal R K x : FractionalIdeal R⁰ K) = spanSingleton _ (x : K) := by\n  simp only [toPrincipalIdeal]; rfl\n\n"}
{"name":"toPrincipalIdeal_eq_iff","module":"Mathlib.RingTheory.ClassGroup","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝³ : CommRing R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nI : Units (FractionalIdeal (nonZeroDivisors R) K)\nx : Units K\n⊢ Iff (Eq ((toPrincipalIdeal R K) x) I) (Eq (FractionalIdeal.spanSingleton (nonZeroDivisors R) ↑x) ↑I)","decl":"@[simp]\ntheorem toPrincipalIdeal_eq_iff {I : (FractionalIdeal R⁰ K)ˣ} {x : Kˣ} :\n    toPrincipalIdeal R K x = I ↔ spanSingleton R⁰ (x : K) = I := by\n  simp only [toPrincipalIdeal]; exact Units.ext_iff\n\n"}
{"name":"mem_principal_ideals_iff","module":"Mathlib.RingTheory.ClassGroup","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝³ : CommRing R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nI : Units (FractionalIdeal (nonZeroDivisors R) K)\n⊢ Iff (Membership.mem (toPrincipalIdeal R K).range I) (Exists fun x => Eq (FractionalIdeal.spanSingleton (nonZeroDivisors R) x) ↑I)","decl":"theorem mem_principal_ideals_iff {I : (FractionalIdeal R⁰ K)ˣ} :\n    I ∈ (toPrincipalIdeal R K).range ↔ ∃ x : K, spanSingleton R⁰ x = I := by\n  simp only [MonoidHom.mem_range, toPrincipalIdeal_eq_iff]\n  constructor <;> rintro ⟨x, hx⟩\n  · exact ⟨x, hx⟩\n  · refine ⟨Units.mk0 x ?_, hx⟩\n    rintro rfl\n    simp [I.ne_zero.symm] at hx\n\n"}
{"name":"PrincipalIdeals.normal","module":"Mathlib.RingTheory.ClassGroup","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝³ : CommRing R\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\n⊢ (toPrincipalIdeal R K).range.Normal","decl":"instance PrincipalIdeals.normal : (toPrincipalIdeal R K).range.Normal :=\n  Subgroup.normal_of_comm _\n\n"}
{"name":"ClassGroup.Quot_mk_eq_mk","module":"Mathlib.RingTheory.ClassGroup","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nI : Units (FractionalIdeal (nonZeroDivisors R) (FractionRing R))\n⊢ Eq (Quot.mk (⇑(QuotientGroup.leftRel (toPrincipalIdeal R (FractionRing R)).range)) I) (ClassGroup.mk I)","decl":"theorem ClassGroup.Quot_mk_eq_mk (I : (FractionalIdeal R⁰ (FractionRing R))ˣ) :\n    Quot.mk _ I = ClassGroup.mk I := by\n  rw [ClassGroup.mk, canonicalEquiv_self, RingEquiv.coe_monoidHom_refl, Units.map_id]\n  -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n  erw [MonoidHom.comp_apply]\n  rw [MonoidHom.id_apply, QuotientGroup.mk'_apply]\n  rfl\n\n"}
{"name":"ClassGroup.mk_eq_mk","module":"Mathlib.RingTheory.ClassGroup","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nI J : Units (FractionalIdeal (nonZeroDivisors R) (FractionRing R))\n⊢ Iff (Eq (ClassGroup.mk I) (ClassGroup.mk J)) (Exists fun x => Eq (HMul.hMul I ((toPrincipalIdeal R (FractionRing R)) x)) J)","decl":"theorem ClassGroup.mk_eq_mk {I J : (FractionalIdeal R⁰ <| FractionRing R)ˣ} :\n    ClassGroup.mk I = ClassGroup.mk J ↔\n      ∃ x : (FractionRing R)ˣ, I * toPrincipalIdeal R (FractionRing R) x = J := by\n  erw [QuotientGroup.mk'_eq_mk', canonicalEquiv_self, Units.map_id, Set.exists_range_iff]\n  rfl\n\n"}
{"name":"ClassGroup.mk_eq_mk_of_coe_ideal","module":"Mathlib.RingTheory.ClassGroup","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nI J : Units (FractionalIdeal (nonZeroDivisors R) (FractionRing R))\nI' J' : Ideal R\nhI : Eq ↑I ↑I'\nhJ : Eq ↑J ↑J'\n⊢ Iff (Eq (ClassGroup.mk I) (ClassGroup.mk J)) (Exists fun x => Exists fun y => And (Ne x 0) (And (Ne y 0) (Eq (HMul.hMul (Ideal.span (Singleton.singleton x)) I') (HMul.hMul (Ideal.span (Singleton.singleton y)) J'))))","decl":"theorem ClassGroup.mk_eq_mk_of_coe_ideal {I J : (FractionalIdeal R⁰ <| FractionRing R)ˣ}\n    {I' J' : Ideal R} (hI : (I : FractionalIdeal R⁰ <| FractionRing R) = I')\n    (hJ : (J : FractionalIdeal R⁰ <| FractionRing R) = J') :\n    ClassGroup.mk I = ClassGroup.mk J ↔\n      ∃ x y : R, x ≠ 0 ∧ y ≠ 0 ∧ Ideal.span {x} * I' = Ideal.span {y} * J' := by\n  rw [ClassGroup.mk_eq_mk]\n  constructor\n  · rintro ⟨x, rfl⟩\n    rw [Units.val_mul, hI, coe_toPrincipalIdeal, mul_comm,\n      spanSingleton_mul_coeIdeal_eq_coeIdeal] at hJ\n    exact ⟨_, _, sec_fst_ne_zero (R := R) le_rfl x.ne_zero,\n      sec_snd_ne_zero (R := R) le_rfl (x : FractionRing R), hJ⟩\n  · rintro ⟨x, y, hx, hy, h⟩\n    have : IsUnit (mk' (FractionRing R) x ⟨y, mem_nonZeroDivisors_of_ne_zero hy⟩) := by\n      simpa only [isUnit_iff_ne_zero, ne_eq, mk'_eq_zero_iff_eq_zero] using hx\n    refine ⟨this.unit, ?_⟩\n    rw [mul_comm, ← Units.eq_iff, Units.val_mul, coe_toPrincipalIdeal]\n    convert\n      (mk'_mul_coeIdeal_eq_coeIdeal (FractionRing R) <| mem_nonZeroDivisors_of_ne_zero hy).2 h\n\n"}
{"name":"ClassGroup.mk_eq_one_of_coe_ideal","module":"Mathlib.RingTheory.ClassGroup","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nI : Units (FractionalIdeal (nonZeroDivisors R) (FractionRing R))\nI' : Ideal R\nhI : Eq ↑I ↑I'\n⊢ Iff (Eq (ClassGroup.mk I) 1) (Exists fun x => And (Ne x 0) (Eq I' (Ideal.span (Singleton.singleton x))))","decl":"theorem ClassGroup.mk_eq_one_of_coe_ideal {I : (FractionalIdeal R⁰ <| FractionRing R)ˣ}\n    {I' : Ideal R} (hI : (I : FractionalIdeal R⁰ <| FractionRing R) = I') :\n    ClassGroup.mk I = 1 ↔ ∃ x : R, x ≠ 0 ∧ I' = Ideal.span {x} := by\n  rw [← map_one (ClassGroup.mk (R := R) (K := FractionRing R)),\n    ClassGroup.mk_eq_mk_of_coe_ideal hI]\n  any_goals rfl\n  constructor\n  · rintro ⟨x, y, hx, hy, h⟩\n    rw [Ideal.mul_top] at h\n    rcases Ideal.mem_span_singleton_mul.mp ((Ideal.span_singleton_le_iff_mem _).mp h.ge) with\n      ⟨i, _hi, rfl⟩\n    rw [← Ideal.span_singleton_mul_span_singleton, Ideal.span_singleton_mul_right_inj hx] at h\n    exact ⟨i, right_ne_zero_of_mul hy, h⟩\n  · rintro ⟨x, hx, rfl⟩\n    exact ⟨1, x, one_ne_zero, hx, by rw [Ideal.span_singleton_one, Ideal.top_mul, Ideal.mul_top]⟩\n\n"}
{"name":"ClassGroup.induction","module":"Mathlib.RingTheory.ClassGroup","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDomain R\nP : ClassGroup R → Prop\nh : ∀ (I : Units (FractionalIdeal (nonZeroDivisors R) K)), P (ClassGroup.mk I)\nx : ClassGroup R\n⊢ P x","decl":"/-- Induction principle for the class group: to show something holds for all `x : ClassGroup R`,\nwe can choose a fraction field `K` and show it holds for the equivalence class of each\n`I : FractionalIdeal R⁰ K`. -/\n@[elab_as_elim]\ntheorem ClassGroup.induction {P : ClassGroup R → Prop}\n    (h : ∀ I : (FractionalIdeal R⁰ K)ˣ, P (ClassGroup.mk I)) (x : ClassGroup R) : P x :=\n  QuotientGroup.induction_on x fun I => by\n    have : I = (Units.mapEquiv (canonicalEquiv R⁰ K (FractionRing R)).toMulEquiv)\n      (Units.mapEquiv (canonicalEquiv R⁰ (FractionRing R) K).toMulEquiv I) := by\n      simp [← Units.eq_iff]\n    rw [congr_arg (QuotientGroup.mk (s := (toPrincipalIdeal R (FractionRing R)).range)) this]\n    exact h _\n\n"}
{"name":"ClassGroup.equiv_mk","module":"Mathlib.RingTheory.ClassGroup","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁷ : CommRing R\ninst✝⁶ : Field K\ninst✝⁵ : Algebra R K\ninst✝⁴ : IsFractionRing R K\ninst✝³ : IsDomain R\nK' : Type u_3\ninst✝² : Field K'\ninst✝¹ : Algebra R K'\ninst✝ : IsFractionRing R K'\nI : Units (FractionalIdeal (nonZeroDivisors R) K)\n⊢ Eq ((ClassGroup.equiv K') (ClassGroup.mk I)) ((QuotientGroup.mk' (toPrincipalIdeal R K').range) ((Units.mapEquiv ↑(FractionalIdeal.canonicalEquiv (nonZeroDivisors R) K K')) I))","decl":"@[simp]\ntheorem ClassGroup.equiv_mk (K' : Type*) [Field K'] [Algebra R K'] [IsFractionRing R K']\n    (I : (FractionalIdeal R⁰ K)ˣ) :\n    ClassGroup.equiv K' (ClassGroup.mk I) =\n      QuotientGroup.mk' _ (Units.mapEquiv (↑(FractionalIdeal.canonicalEquiv R⁰ K K')) I) := by\n  -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n  erw [ClassGroup.equiv, ClassGroup.mk, MonoidHom.comp_apply, QuotientGroup.congr_mk']\n  congr\n  rw [← Units.eq_iff, Units.coe_mapEquiv, Units.coe_mapEquiv, Units.coe_map]\n  exact FractionalIdeal.canonicalEquiv_canonicalEquiv _ _ _ _ _\n\n"}
{"name":"ClassGroup.mk_canonicalEquiv","module":"Mathlib.RingTheory.ClassGroup","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁷ : CommRing R\ninst✝⁶ : Field K\ninst✝⁵ : Algebra R K\ninst✝⁴ : IsFractionRing R K\ninst✝³ : IsDomain R\nK' : Type u_3\ninst✝² : Field K'\ninst✝¹ : Algebra R K'\ninst✝ : IsFractionRing R K'\nI : Units (FractionalIdeal (nonZeroDivisors R) K)\n⊢ Eq (ClassGroup.mk ((Units.map ↑(FractionalIdeal.canonicalEquiv (nonZeroDivisors R) K K')) I)) (ClassGroup.mk I)","decl":"@[simp]\ntheorem ClassGroup.mk_canonicalEquiv (K' : Type*) [Field K'] [Algebra R K'] [IsFractionRing R K']\n    (I : (FractionalIdeal R⁰ K)ˣ) :\n    ClassGroup.mk (Units.map (↑(canonicalEquiv R⁰ K K')) I : (FractionalIdeal R⁰ K')ˣ) =\n      ClassGroup.mk I := by\n  -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n  erw [ClassGroup.mk, MonoidHom.comp_apply, ← MonoidHom.comp_apply (Units.map _),\n      ← Units.map_comp, ← RingEquiv.coe_monoidHom_trans,\n      FractionalIdeal.canonicalEquiv_trans_canonicalEquiv]\n  rfl\n\n"}
{"name":"FractionalIdeal.coe_mk0","module":"Mathlib.RingTheory.ClassGroup","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁵ : CommRing R\ninst✝⁴ : Field K\ninst✝³ : Algebra R K\ninst✝² : IsFractionRing R K\ninst✝¹ : IsDomain R\ninst✝ : IsDedekindDomain R\nI : Subtype fun x => Membership.mem (nonZeroDivisors (Ideal R)) x\n⊢ Eq ↑((FractionalIdeal.mk0 K) I) ↑↑I","decl":"@[simp]\ntheorem FractionalIdeal.coe_mk0 [IsDedekindDomain R] (I : (Ideal R)⁰) :\n    (FractionalIdeal.mk0 K I : FractionalIdeal R⁰ K) = I := rfl\n\n"}
{"name":"FractionalIdeal.canonicalEquiv_mk0","module":"Mathlib.RingTheory.ClassGroup","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁸ : CommRing R\ninst✝⁷ : Field K\ninst✝⁶ : Algebra R K\ninst✝⁵ : IsFractionRing R K\ninst✝⁴ : IsDomain R\ninst✝³ : IsDedekindDomain R\nK' : Type u_3\ninst✝² : Field K'\ninst✝¹ : Algebra R K'\ninst✝ : IsFractionRing R K'\nI : Subtype fun x => Membership.mem (nonZeroDivisors (Ideal R)) x\n⊢ Eq ((FractionalIdeal.canonicalEquiv (nonZeroDivisors R) K K') ↑((FractionalIdeal.mk0 K) I)) ↑((FractionalIdeal.mk0 K') I)","decl":"theorem FractionalIdeal.canonicalEquiv_mk0 [IsDedekindDomain R] (K' : Type*) [Field K']\n    [Algebra R K'] [IsFractionRing R K'] (I : (Ideal R)⁰) :\n    FractionalIdeal.canonicalEquiv R⁰ K K' (FractionalIdeal.mk0 K I) =\n    FractionalIdeal.mk0 K' I := by\n  simp only [FractionalIdeal.coe_mk0, FractionalIdeal.canonicalEquiv_coeIdeal]\n\n"}
{"name":"FractionalIdeal.map_canonicalEquiv_mk0","module":"Mathlib.RingTheory.ClassGroup","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁸ : CommRing R\ninst✝⁷ : Field K\ninst✝⁶ : Algebra R K\ninst✝⁵ : IsFractionRing R K\ninst✝⁴ : IsDomain R\ninst✝³ : IsDedekindDomain R\nK' : Type u_3\ninst✝² : Field K'\ninst✝¹ : Algebra R K'\ninst✝ : IsFractionRing R K'\nI : Subtype fun x => Membership.mem (nonZeroDivisors (Ideal R)) x\n⊢ Eq ((Units.map ↑(FractionalIdeal.canonicalEquiv (nonZeroDivisors R) K K')) ((FractionalIdeal.mk0 K) I)) ((FractionalIdeal.mk0 K') I)","decl":"@[simp]\ntheorem FractionalIdeal.map_canonicalEquiv_mk0 [IsDedekindDomain R] (K' : Type*) [Field K']\n    [Algebra R K'] [IsFractionRing R K'] (I : (Ideal R)⁰) :\n    Units.map (↑(FractionalIdeal.canonicalEquiv R⁰ K K')) (FractionalIdeal.mk0 K I) =\n      FractionalIdeal.mk0 K' I :=\n  Units.ext (FractionalIdeal.canonicalEquiv_mk0 K K' I)\n\n"}
{"name":"ClassGroup.mk_mk0","module":"Mathlib.RingTheory.ClassGroup","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁵ : CommRing R\ninst✝⁴ : Field K\ninst✝³ : Algebra R K\ninst✝² : IsFractionRing R K\ninst✝¹ : IsDomain R\ninst✝ : IsDedekindDomain R\nI : Subtype fun x => Membership.mem (nonZeroDivisors (Ideal R)) x\n⊢ Eq (ClassGroup.mk ((FractionalIdeal.mk0 K) I)) (ClassGroup.mk0 I)","decl":"@[simp]\ntheorem ClassGroup.mk_mk0 [IsDedekindDomain R] (I : (Ideal R)⁰) :\n    ClassGroup.mk (FractionalIdeal.mk0 K I) = ClassGroup.mk0 I := by\n  rw [ClassGroup.mk0, MonoidHom.comp_apply, ← ClassGroup.mk_canonicalEquiv K (FractionRing R),\n    FractionalIdeal.map_canonicalEquiv_mk0]\n\n"}
{"name":"ClassGroup.equiv_mk0","module":"Mathlib.RingTheory.ClassGroup","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁵ : CommRing R\ninst✝⁴ : Field K\ninst✝³ : Algebra R K\ninst✝² : IsFractionRing R K\ninst✝¹ : IsDomain R\ninst✝ : IsDedekindDomain R\nI : Subtype fun x => Membership.mem (nonZeroDivisors (Ideal R)) x\n⊢ Eq ((ClassGroup.equiv K) (ClassGroup.mk0 I)) ((QuotientGroup.mk' (toPrincipalIdeal R K).range) ((FractionalIdeal.mk0 K) I))","decl":"@[simp]\ntheorem ClassGroup.equiv_mk0 [IsDedekindDomain R] (I : (Ideal R)⁰) :\n    ClassGroup.equiv K (ClassGroup.mk0 I) =\n      QuotientGroup.mk' (toPrincipalIdeal R K).range (FractionalIdeal.mk0 K I) := by\n  rw [ClassGroup.mk0, MonoidHom.comp_apply, ClassGroup.equiv_mk]\n  congr 1\n  simp [← Units.eq_iff]\n\n"}
{"name":"ClassGroup.mk0_eq_mk0_iff_exists_fraction_ring","module":"Mathlib.RingTheory.ClassGroup","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁵ : CommRing R\ninst✝⁴ : Field K\ninst✝³ : Algebra R K\ninst✝² : IsFractionRing R K\ninst✝¹ : IsDomain R\ninst✝ : IsDedekindDomain R\nI J : Subtype fun x => Membership.mem (nonZeroDivisors (Ideal R)) x\n⊢ Iff (Eq (ClassGroup.mk0 I) (ClassGroup.mk0 J)) (Exists fun x => Exists fun x_1 => Eq (HMul.hMul (FractionalIdeal.spanSingleton (nonZeroDivisors R) x) ↑↑I) ↑↑J)","decl":"theorem ClassGroup.mk0_eq_mk0_iff_exists_fraction_ring [IsDedekindDomain R] {I J : (Ideal R)⁰} :\n    ClassGroup.mk0 I =\n      ClassGroup.mk0 J ↔ ∃ (x : _) (_ : x ≠ (0 : K)), spanSingleton R⁰ x * I = J := by\n  refine (ClassGroup.equiv K).injective.eq_iff.symm.trans ?_\n  simp only [ClassGroup.equiv_mk0, QuotientGroup.mk'_eq_mk', mem_principal_ideals_iff,\n    Units.ext_iff, Units.val_mul, FractionalIdeal.coe_mk0, exists_prop]\n  constructor\n  · rintro ⟨X, ⟨x, hX⟩, hx⟩\n    refine ⟨x, ?_, ?_⟩\n    · rintro rfl; simp [X.ne_zero.symm] at hX\n    simpa only [hX, mul_comm] using hx\n  · rintro ⟨x, hx, eq_J⟩\n    refine ⟨Units.mk0 _ (spanSingleton_ne_zero_iff.mpr hx), ⟨x, rfl⟩, ?_⟩\n    simpa only [mul_comm] using eq_J\n\n"}
{"name":"ClassGroup.mk0_eq_mk0_iff","module":"Mathlib.RingTheory.ClassGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsDedekindDomain R\nI J : Subtype fun x => Membership.mem (nonZeroDivisors (Ideal R)) x\n⊢ Iff (Eq (ClassGroup.mk0 I) (ClassGroup.mk0 J)) (Exists fun x => Exists fun y => Exists fun _hx => Exists fun _hy => Eq (HMul.hMul (Ideal.span (Singleton.singleton x)) ↑I) (HMul.hMul (Ideal.span (Singleton.singleton y)) ↑J))","decl":"theorem ClassGroup.mk0_eq_mk0_iff [IsDedekindDomain R] {I J : (Ideal R)⁰} :\n    ClassGroup.mk0 I = ClassGroup.mk0 J ↔\n      ∃ (x y : R) (_hx : x ≠ 0) (_hy : y ≠ 0), Ideal.span {x} * (I : Ideal R) =\n      Ideal.span {y} * J := by\n  refine (ClassGroup.mk0_eq_mk0_iff_exists_fraction_ring (FractionRing R)).trans ⟨?_, ?_⟩\n  · rintro ⟨z, hz, h⟩\n    obtain ⟨x, ⟨y, hy⟩, rfl⟩ := IsLocalization.mk'_surjective R⁰ z\n    refine ⟨x, y, ?_, mem_nonZeroDivisors_iff_ne_zero.mp hy, ?_⟩\n    · rintro hx; apply hz\n      rw [hx, IsFractionRing.mk'_eq_div, _root_.map_zero, zero_div]\n    · exact (FractionalIdeal.mk'_mul_coeIdeal_eq_coeIdeal _ hy).mp h\n  · rintro ⟨x, y, hx, hy, h⟩\n    have hy' : y ∈ R⁰ := mem_nonZeroDivisors_iff_ne_zero.mpr hy\n    refine ⟨IsLocalization.mk' _ x ⟨y, hy'⟩, ?_, ?_⟩\n    · contrapose! hx\n      rwa [mk'_eq_iff_eq_mul, zero_mul, ← (algebraMap R (FractionRing R)).map_zero,\n        (IsFractionRing.injective R (FractionRing R)).eq_iff] at hx\n    · exact (FractionalIdeal.mk'_mul_coeIdeal_eq_coeIdeal _ hy').mpr h\n\n"}
{"name":"ClassGroup.integralRep_mem_nonZeroDivisors","module":"Mathlib.RingTheory.ClassGroup","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nI : FractionalIdeal (nonZeroDivisors R) (FractionRing R)\nhI : Ne I 0\n⊢ Membership.mem (nonZeroDivisors (Ideal R)) I.num","decl":"theorem ClassGroup.integralRep_mem_nonZeroDivisors\n    {I : FractionalIdeal R⁰ (FractionRing R)} (hI : I ≠ 0) :\n    I.num ∈ (Ideal R)⁰ := by\n  rwa [mem_nonZeroDivisors_iff_ne_zero, ne_eq, FractionalIdeal.num_eq_zero_iff]\n\n"}
{"name":"ClassGroup.mk0_integralRep","module":"Mathlib.RingTheory.ClassGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsDedekindDomain R\nI : Units (FractionalIdeal (nonZeroDivisors R) (FractionRing R))\n⊢ Eq (ClassGroup.mk0 ⟨ClassGroup.integralRep ↑I, ⋯⟩) (ClassGroup.mk I)","decl":"theorem ClassGroup.mk0_integralRep [IsDedekindDomain R]\n    (I : (FractionalIdeal R⁰ (FractionRing R))ˣ) :\n    ClassGroup.mk0 ⟨ClassGroup.integralRep I, ClassGroup.integralRep_mem_nonZeroDivisors I.ne_zero⟩\n      = ClassGroup.mk I := by\n  rw [← ClassGroup.mk_mk0 (FractionRing R), eq_comm, ClassGroup.mk_eq_mk]\n  have fd_ne_zero : (algebraMap R (FractionRing R)) I.1.den ≠ 0 := by\n    exact IsFractionRing.to_map_ne_zero_of_mem_nonZeroDivisors (SetLike.coe_mem _)\n  refine ⟨Units.mk0 (algebraMap R _ I.1.den) fd_ne_zero, ?_⟩\n  apply Units.ext\n  rw [mul_comm, val_mul, coe_toPrincipalIdeal, val_mk0]\n  exact FractionalIdeal.den_mul_self_eq_num' R⁰ (FractionRing R) I\n\n"}
{"name":"ClassGroup.mk0_surjective","module":"Mathlib.RingTheory.ClassGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsDedekindDomain R\n⊢ Function.Surjective ⇑ClassGroup.mk0","decl":"theorem ClassGroup.mk0_surjective [IsDedekindDomain R] :\n    Function.Surjective (ClassGroup.mk0 : (Ideal R)⁰ → ClassGroup R) := by\n  rintro ⟨I⟩\n  refine ⟨⟨ClassGroup.integralRep I.1, ClassGroup.integralRep_mem_nonZeroDivisors I.ne_zero⟩, ?_⟩\n  rw [ClassGroup.mk0_integralRep, ClassGroup.Quot_mk_eq_mk]\n\n"}
{"name":"ClassGroup.mk_eq_one_iff","module":"Mathlib.RingTheory.ClassGroup","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDomain R\nI : Units (FractionalIdeal (nonZeroDivisors R) K)\n⊢ Iff (Eq (ClassGroup.mk I) 1) (↑↑I).IsPrincipal","decl":"theorem ClassGroup.mk_eq_one_iff {I : (FractionalIdeal R⁰ K)ˣ} :\n    ClassGroup.mk I = 1 ↔ (I : Submodule R K).IsPrincipal := by\n  rw [← (ClassGroup.equiv K).injective.eq_iff]\n  simp only [equiv_mk, canonicalEquiv_self, RingEquiv.coe_mulEquiv_refl, QuotientGroup.mk'_apply,\n    _root_.map_one, QuotientGroup.eq_one_iff, MonoidHom.mem_range, Units.ext_iff,\n    coe_toPrincipalIdeal, coe_mapEquiv, MulEquiv.refl_apply]\n  refine ⟨fun ⟨x, hx⟩ => ⟨⟨x, by rw [← hx, coe_spanSingleton]⟩⟩, ?_⟩\n  intro hI\n  obtain ⟨x, hx⟩ := @Submodule.IsPrincipal.principal _ _ _ _ _ _ hI\n  have hx' : (I : FractionalIdeal R⁰ K) = spanSingleton R⁰ x := by\n    apply Subtype.coe_injective\n    simp only [val_eq_coe, hx, coe_spanSingleton]\n  refine ⟨Units.mk0 x ?_, ?_⟩\n  · intro x_eq; apply Units.ne_zero I; simp [hx', x_eq]\n  · simp [hx']\n\n"}
{"name":"ClassGroup.mk0_eq_one_iff","module":"Mathlib.RingTheory.ClassGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsDedekindDomain R\nI : Ideal R\nhI : Membership.mem (nonZeroDivisors (Ideal R)) I\n⊢ Iff (Eq (ClassGroup.mk0 ⟨I, hI⟩) 1) (Submodule.IsPrincipal I)","decl":"theorem ClassGroup.mk0_eq_one_iff [IsDedekindDomain R] {I : Ideal R} (hI : I ∈ (Ideal R)⁰) :\n    ClassGroup.mk0 ⟨I, hI⟩ = 1 ↔ I.IsPrincipal :=\n  ClassGroup.mk_eq_one_iff.trans (coeSubmodule_isPrincipal R _)\n\n"}
{"name":"ClassGroup.mk0_eq_mk0_inv_iff","module":"Mathlib.RingTheory.ClassGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsDedekindDomain R\nI J : Subtype fun x => Membership.mem (nonZeroDivisors (Ideal R)) x\n⊢ Iff (Eq (ClassGroup.mk0 I) (Inv.inv (ClassGroup.mk0 J))) (Exists fun x => And (Ne x 0) (Eq (HMul.hMul ↑I ↑J) (Ideal.span (Singleton.singleton x))))","decl":"theorem ClassGroup.mk0_eq_mk0_inv_iff [IsDedekindDomain R] {I J : (Ideal R)⁰} :\n    ClassGroup.mk0 I = (ClassGroup.mk0 J)⁻¹ ↔\n      ∃ x ≠ (0 : R), I * J = Ideal.span {x} := by\n  rw [eq_inv_iff_mul_eq_one, ← _root_.map_mul, ClassGroup.mk0_eq_one_iff,\n    Submodule.isPrincipal_iff, Submonoid.coe_mul]\n  refine ⟨fun ⟨a, ha⟩ ↦ ⟨a, ?_, ha⟩, fun ⟨a, _, ha⟩ ↦ ⟨a, ha⟩⟩\n  by_contra!\n  rw [this, Submodule.span_zero_singleton] at ha\n  exact nonZeroDivisors.coe_ne_zero _ <| J.prop _ ha\n\n"}
{"name":"card_classGroup_eq_one","module":"Mathlib.RingTheory.ClassGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsPrincipalIdealRing R\n⊢ Eq (Fintype.card (ClassGroup R)) 1","decl":"/-- The class number of a principal ideal domain is `1`. -/\ntheorem card_classGroup_eq_one [IsPrincipalIdealRing R] : Fintype.card (ClassGroup R) = 1 := by\n  rw [Fintype.card_eq_one_iff]\n  use 1\n  refine ClassGroup.induction (R := R) (FractionRing R) (fun I => ?_)\n  exact ClassGroup.mk_eq_one_iff.mpr (I : FractionalIdeal R⁰ (FractionRing R)).isPrincipal\n\n"}
{"name":"card_classGroup_eq_one_iff","module":"Mathlib.RingTheory.ClassGroup","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\ninst✝² : IsDomain R\ninst✝¹ : IsDedekindDomain R\ninst✝ : Fintype (ClassGroup R)\n⊢ Iff (Eq (Fintype.card (ClassGroup R)) 1) (IsPrincipalIdealRing R)","decl":"/-- The class number is `1` iff the ring of integers is a principal ideal domain. -/\ntheorem card_classGroup_eq_one_iff [IsDedekindDomain R] [Fintype (ClassGroup R)] :\n    Fintype.card (ClassGroup R) = 1 ↔ IsPrincipalIdealRing R := by\n  constructor; swap; · intros; convert card_classGroup_eq_one (R := R)\n  rw [Fintype.card_eq_one_iff]\n  rintro ⟨I, hI⟩\n  have eq_one : ∀ J : ClassGroup R, J = 1 := fun J => (hI J).trans (hI 1).symm\n  refine ⟨fun I => ?_⟩\n  by_cases hI : I = ⊥\n  · rw [hI]; exact bot_isPrincipal\n  · exact (ClassGroup.mk0_eq_one_iff (mem_nonZeroDivisors_iff_ne_zero.mpr hI)).mp (eq_one _)\n"}
