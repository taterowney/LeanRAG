{"name":"ENat.iSup_coe_eq_top","module":"Mathlib.Data.ENat.Lattice","initialProofState":"ι : Sort u_1\nf : ι → Nat\n⊢ Iff (Eq (iSup fun i => ↑(f i)) Top.top) (Not (BddAbove (Set.range f)))","decl":"lemma iSup_coe_eq_top : ⨆ i, (f i : ℕ∞) = ⊤ ↔ ¬ BddAbove (range f) := WithTop.iSup_coe_eq_top\n"}
{"name":"ENat.iSup_coe_ne_top","module":"Mathlib.Data.ENat.Lattice","initialProofState":"ι : Sort u_1\nf : ι → Nat\n⊢ Iff (Ne (iSup fun i => ↑(f i)) Top.top) (BddAbove (Set.range f))","decl":"lemma iSup_coe_ne_top : ⨆ i, (f i : ℕ∞) ≠ ⊤ ↔ BddAbove (range f) := iSup_coe_eq_top.not_left\n"}
{"name":"ENat.iSup_coe_lt_top","module":"Mathlib.Data.ENat.Lattice","initialProofState":"ι : Sort u_1\nf : ι → Nat\n⊢ Iff (LT.lt (iSup fun i => ↑(f i)) Top.top) (BddAbove (Set.range f))","decl":"lemma iSup_coe_lt_top : ⨆ i, (f i : ℕ∞) < ⊤ ↔ BddAbove (range f) := WithTop.iSup_coe_lt_top\n"}
{"name":"ENat.iInf_coe_eq_top","module":"Mathlib.Data.ENat.Lattice","initialProofState":"ι : Sort u_1\nf : ι → Nat\n⊢ Iff (Eq (iInf fun i => ↑(f i)) Top.top) (IsEmpty ι)","decl":"lemma iInf_coe_eq_top : ⨅ i, (f i : ℕ∞) = ⊤ ↔ IsEmpty ι := WithTop.iInf_coe_eq_top\n"}
{"name":"ENat.iInf_coe_ne_top","module":"Mathlib.Data.ENat.Lattice","initialProofState":"ι : Sort u_1\nf : ι → Nat\n⊢ Iff (Ne (iInf fun i => ↑(f i)) Top.top) (Nonempty ι)","decl":"lemma iInf_coe_ne_top : ⨅ i, (f i : ℕ∞) ≠ ⊤ ↔ Nonempty ι := by\n  rw [Ne, iInf_coe_eq_top, not_isEmpty_iff]\n"}
{"name":"ENat.iInf_coe_lt_top","module":"Mathlib.Data.ENat.Lattice","initialProofState":"ι : Sort u_1\nf : ι → Nat\n⊢ Iff (LT.lt (iInf fun i => ↑(f i)) Top.top) (Nonempty ι)","decl":"lemma iInf_coe_lt_top : ⨅ i, (f i : ℕ∞) < ⊤ ↔ Nonempty ι := WithTop.iInf_coe_lt_top\n\n"}
{"name":"ENat.coe_sSup","module":"Mathlib.Data.ENat.Lattice","initialProofState":"s : Set Nat\na✝ : BddAbove s\n⊢ Eq (↑(SupSet.sSup s)) (iSup fun a => iSup fun h => ↑a)","decl":"lemma coe_sSup : BddAbove s → ↑(sSup s) = ⨆ a ∈ s, (a : ℕ∞) := WithTop.coe_sSup\n\n"}
{"name":"ENat.coe_sInf","module":"Mathlib.Data.ENat.Lattice","initialProofState":"s : Set Nat\nhs : s.Nonempty\n⊢ Eq (↑(InfSet.sInf s)) (iInf fun a => iInf fun h => ↑a)","decl":"lemma coe_sInf (hs : s.Nonempty) : ↑(sInf s) = ⨅ a ∈ s, (a : ℕ∞) :=\n  WithTop.coe_sInf hs (OrderBot.bddBelow s)\n\n"}
{"name":"ENat.coe_iSup","module":"Mathlib.Data.ENat.Lattice","initialProofState":"ι : Sort u_1\nf : ι → Nat\na✝ : BddAbove (Set.range f)\n⊢ Eq (↑(iSup fun i => f i)) (iSup fun i => ↑(f i))","decl":"lemma coe_iSup : BddAbove (range f) → ↑(⨆ i, f i) = ⨆ i, (f i : ℕ∞) := WithTop.coe_iSup _\n\n"}
{"name":"ENat.coe_iInf","module":"Mathlib.Data.ENat.Lattice","initialProofState":"ι : Sort u_1\nf : ι → Nat\ninst✝ : Nonempty ι\n⊢ Eq (↑(iInf fun i => f i)) (iInf fun i => ↑(f i))","decl":"@[norm_cast] lemma coe_iInf [Nonempty ι] : ↑(⨅ i, f i) = ⨅ i, (f i : ℕ∞) :=\n  WithTop.coe_iInf (OrderBot.bddBelow _)\n\n"}
{"name":"ENat.iInf_eq_top_of_isEmpty","module":"Mathlib.Data.ENat.Lattice","initialProofState":"ι : Sort u_1\nf : ι → Nat\ninst✝ : IsEmpty ι\n⊢ Eq (iInf fun i => ↑(f i)) Top.top","decl":"@[simp]\nlemma iInf_eq_top_of_isEmpty [IsEmpty ι] : ⨅ i, (f i : ℕ∞) = ⊤ :=\n  iInf_coe_eq_top.mpr ‹_›\n\n"}
{"name":"ENat.iInf_toNat","module":"Mathlib.Data.ENat.Lattice","initialProofState":"ι : Sort u_1\nf : ι → Nat\n⊢ Eq (iInf fun i => ↑(f i)).toNat (iInf fun i => f i)","decl":"lemma iInf_toNat : (⨅ i, (f i : ℕ∞)).toNat = ⨅ i, f i := by\n  cases isEmpty_or_nonempty ι\n  · simp\n  · norm_cast\n\n"}
{"name":"ENat.iInf_eq_zero","module":"Mathlib.Data.ENat.Lattice","initialProofState":"ι : Sort u_1\nf : ι → Nat\n⊢ Iff (Eq (iInf fun i => ↑(f i)) 0) (Exists fun i => Eq (f i) 0)","decl":"lemma iInf_eq_zero : ⨅ i, (f i : ℕ∞) = 0 ↔ ∃ i, f i = 0 := by\n  cases isEmpty_or_nonempty ι\n  · simp\n  · norm_cast\n    rw [iInf, Nat.sInf_eq_zero]\n    exact ⟨fun h ↦ by simp_all, .inl⟩\n\n"}
{"name":"ENat.sSup_eq_zero","module":"Mathlib.Data.ENat.Lattice","initialProofState":"s : Set ENat\n⊢ Iff (Eq (SupSet.sSup s) 0) (∀ (a : ENat), Membership.mem s a → Eq a 0)","decl":"lemma sSup_eq_zero : sSup s = 0 ↔ ∀ a ∈ s, a = 0 :=\n  sSup_eq_bot\n\n"}
{"name":"ENat.sInf_eq_zero","module":"Mathlib.Data.ENat.Lattice","initialProofState":"s : Set ENat\n⊢ Iff (Eq (InfSet.sInf s) 0) (Membership.mem s 0)","decl":"lemma sInf_eq_zero : sInf s = 0 ↔ 0 ∈ s := by\n  rw [← lt_one_iff_eq_zero]\n  simp only [sInf_lt_iff, lt_one_iff_eq_zero, exists_eq_right]\n\n"}
{"name":"ENat.sSup_eq_zero'","module":"Mathlib.Data.ENat.Lattice","initialProofState":"s : Set ENat\n⊢ Iff (Eq (SupSet.sSup s) 0) (Or (Eq s EmptyCollection.emptyCollection) (Eq s (Singleton.singleton 0)))","decl":"lemma sSup_eq_zero' : sSup s = 0 ↔ s = ∅ ∨ s = {0} :=\n  sSup_eq_bot'\n\n"}
{"name":"ENat.iSup_eq_zero","module":"Mathlib.Data.ENat.Lattice","initialProofState":"ι : Sort u_1\nf : ι → ENat\n⊢ Iff (Eq (iSup f) 0) (∀ (i : ι), Eq (f i) 0)","decl":"@[simp] lemma iSup_eq_zero : iSup f = 0 ↔ ∀ i, f i = 0 := iSup_eq_bot\n"}
{"name":"ENat.iSup_zero","module":"Mathlib.Data.ENat.Lattice","initialProofState":"ι : Sort u_1\n⊢ Eq (iSup fun x => 0) 0","decl":"@[simp] lemma iSup_zero : ⨆ _ : ι, (0 : ℕ∞) = 0 := by simp\n\n"}
{"name":"ENat.sSup_eq_top_of_infinite","module":"Mathlib.Data.ENat.Lattice","initialProofState":"s : Set ENat\nh : s.Infinite\n⊢ Eq (SupSet.sSup s) Top.top","decl":"lemma sSup_eq_top_of_infinite (h : s.Infinite) : sSup s = ⊤ := by\n  apply (sSup_eq_top ..).mpr\n  intro x hx\n  cases x with\n  | top => simp at hx\n  | coe x =>\n    contrapose! h\n    simp only [not_infinite]\n    apply Finite.subset <| Finite.Set.finite_image {n : ℕ | n ≤ x} (fun (n : ℕ) => (n : ℕ∞))\n    intro y hy\n    specialize h y hy\n    have hxt : y < ⊤ := lt_of_le_of_lt h hx\n    use y.toNat\n    simp [toNat_le_of_le_coe h, LT.lt.ne_top hxt]\n\n"}
{"name":"ENat.finite_of_sSup_lt_top","module":"Mathlib.Data.ENat.Lattice","initialProofState":"s : Set ENat\nh : LT.lt (SupSet.sSup s) Top.top\n⊢ s.Finite","decl":"lemma finite_of_sSup_lt_top (h : sSup s < ⊤) : s.Finite := by\n  contrapose! h\n  simp only [top_le_iff]\n  exact sSup_eq_top_of_infinite h\n\n"}
{"name":"ENat.sSup_mem_of_nonempty_of_lt_top","module":"Mathlib.Data.ENat.Lattice","initialProofState":"s : Set ENat\ninst✝ : Nonempty ↑s\nhs' : LT.lt (SupSet.sSup s) Top.top\n⊢ Membership.mem s (SupSet.sSup s)","decl":"lemma sSup_mem_of_nonempty_of_lt_top [Nonempty s] (hs' : sSup s < ⊤) : sSup s ∈ s :=\n  Nonempty.csSup_mem .of_subtype (finite_of_sSup_lt_top hs')\n\n"}
{"name":"ENat.exists_eq_iSup_of_lt_top","module":"Mathlib.Data.ENat.Lattice","initialProofState":"ι : Sort u_1\nf : ι → ENat\ninst✝ : Nonempty ι\nh : LT.lt (iSup fun i => f i) Top.top\n⊢ Exists fun i => Eq (f i) (iSup fun i => f i)","decl":"lemma exists_eq_iSup_of_lt_top [Nonempty ι] (h : ⨆ i, f i < ⊤) :\n    ∃ i, f i = ⨆ i, f i :=\n  sSup_mem_of_nonempty_of_lt_top h\n\n"}
{"name":"ENat.exists_eq_iSup₂_of_lt_top","module":"Mathlib.Data.ENat.Lattice","initialProofState":"ι₁ : Type u_2\nι₂ : Type u_3\nf : ι₁ → ι₂ → ENat\ninst✝¹ : Nonempty ι₁\ninst✝ : Nonempty ι₂\nh : LT.lt (iSup fun i => iSup fun j => f i j) Top.top\n⊢ Exists fun i => Exists fun j => Eq (f i j) (iSup fun i => iSup fun j => f i j)","decl":"lemma exists_eq_iSup₂_of_lt_top {ι₁ ι₂ : Type*} {f : ι₁ → ι₂ → ℕ∞} [Nonempty ι₁] [Nonempty ι₂]\n    (h : ⨆ i, ⨆ j, f i j < ⊤) : ∃ i j, f i j = ⨆ i, ⨆ j, f i j := by\n  rw [iSup_prod'] at h ⊢\n  exact Prod.exists'.mp (exists_eq_iSup_of_lt_top h)\n\n"}
{"name":"ENat.iSup_natCast","module":"Mathlib.Data.ENat.Lattice","initialProofState":"⊢ Eq (iSup fun n => ↑n) Top.top","decl":"lemma iSup_natCast : ⨆ n : ℕ, (n : ℕ∞) = ⊤ :=\n  (iSup_eq_top _).2 fun _b hb ↦ ENat.exists_nat_gt (lt_top_iff_ne_top.1 hb)\n\n"}
{"name":"ENat.add_iSup","module":"Mathlib.Data.ENat.Lattice","initialProofState":"ι : Sort u_2\na : ENat\ninst✝ : Nonempty ι\nf : ι → ENat\n⊢ Eq (HAdd.hAdd a (iSup fun i => f i)) (iSup fun i => HAdd.hAdd a (f i))","decl":"lemma add_iSup [Nonempty ι] (f : ι → ℕ∞) : a + ⨆ i, f i = ⨆ i, a + f i := by\n  obtain rfl | ha := eq_or_ne a ⊤\n  · simp\n  refine le_antisymm ?_ <| iSup_le fun i ↦ add_le_add_left (le_iSup ..) _\n  refine add_le_of_le_tsub_left_of_le (le_iSup_of_le (Classical.arbitrary _) le_self_add) ?_\n  exact iSup_le fun i ↦ ENat.le_sub_of_add_le_left ha <| le_iSup (a + f ·) i\n\n"}
{"name":"ENat.iSup_add","module":"Mathlib.Data.ENat.Lattice","initialProofState":"ι : Sort u_2\na : ENat\ninst✝ : Nonempty ι\nf : ι → ENat\n⊢ Eq (HAdd.hAdd (iSup fun i => f i) a) (iSup fun i => HAdd.hAdd (f i) a)","decl":"lemma iSup_add [Nonempty ι] (f : ι → ℕ∞) : (⨆ i, f i) + a = ⨆ i, f i + a := by\n  simp [add_comm, add_iSup]\n\n"}
{"name":"ENat.add_biSup'","module":"Mathlib.Data.ENat.Lattice","initialProofState":"ι : Sort u_2\na : ENat\np : ι → Prop\nh : Exists fun i => p i\nf : ι → ENat\n⊢ Eq (HAdd.hAdd a (iSup fun i => iSup fun x => f i)) (iSup fun i => iSup fun x => HAdd.hAdd a (f i))","decl":"lemma add_biSup' {p : ι → Prop} (h : ∃ i, p i) (f : ι → ℕ∞) :\n    a + ⨆ i, ⨆ _ : p i, f i = ⨆ i, ⨆ _ : p i, a + f i := by\n  haveI : Nonempty {i // p i} := nonempty_subtype.2 h\n  simp only [iSup_subtype', add_iSup]\n\n"}
{"name":"ENat.biSup_add'","module":"Mathlib.Data.ENat.Lattice","initialProofState":"ι : Sort u_2\na : ENat\np : ι → Prop\nh : Exists fun i => p i\nf : ι → ENat\n⊢ Eq (HAdd.hAdd (iSup fun i => iSup fun x => f i) a) (iSup fun i => iSup fun x => HAdd.hAdd (f i) a)","decl":"lemma biSup_add' {p : ι → Prop} (h : ∃ i, p i) (f : ι → ℕ∞) :\n    (⨆ i, ⨆ _ : p i, f i) + a = ⨆ i, ⨆ _ : p i, f i + a := by simp only [add_comm, add_biSup' h]\n\n"}
{"name":"ENat.add_biSup","module":"Mathlib.Data.ENat.Lattice","initialProofState":"a : ENat\nι : Type u_4\ns : Set ι\nhs : s.Nonempty\nf : ι → ENat\n⊢ Eq (HAdd.hAdd a (iSup fun i => iSup fun h => f i)) (iSup fun i => iSup fun h => HAdd.hAdd a (f i))","decl":"lemma add_biSup {ι : Type*} {s : Set ι} (hs : s.Nonempty) (f : ι → ℕ∞) :\n    a + ⨆ i ∈ s, f i = ⨆ i ∈ s, a + f i := add_biSup' hs _\n\n"}
{"name":"ENat.biSup_add","module":"Mathlib.Data.ENat.Lattice","initialProofState":"a : ENat\nι : Type u_4\ns : Set ι\nhs : s.Nonempty\nf : ι → ENat\n⊢ Eq (HAdd.hAdd (iSup fun i => iSup fun h => f i) a) (iSup fun i => iSup fun h => HAdd.hAdd (f i) a)","decl":"lemma biSup_add {ι : Type*} {s : Set ι} (hs : s.Nonempty) (f : ι → ℕ∞) :\n    (⨆ i ∈ s, f i) + a = ⨆ i ∈ s, f i + a := biSup_add' hs _\n\n"}
{"name":"ENat.add_sSup","module":"Mathlib.Data.ENat.Lattice","initialProofState":"s : Set ENat\na : ENat\nhs : s.Nonempty\n⊢ Eq (HAdd.hAdd a (SupSet.sSup s)) (iSup fun b => iSup fun h => HAdd.hAdd a b)","decl":"lemma add_sSup (hs : s.Nonempty) : a + sSup s = ⨆ b ∈ s, a + b := by\n  rw [sSup_eq_iSup, add_biSup hs]\n\n"}
{"name":"ENat.sSup_add","module":"Mathlib.Data.ENat.Lattice","initialProofState":"s : Set ENat\na : ENat\nhs : s.Nonempty\n⊢ Eq (HAdd.hAdd (SupSet.sSup s) a) (iSup fun b => iSup fun h => HAdd.hAdd b a)","decl":"lemma sSup_add (hs : s.Nonempty) : sSup s + a = ⨆ b ∈ s, b + a := by\n  rw [sSup_eq_iSup, biSup_add hs]\n\n"}
{"name":"ENat.iSup_add_iSup_le","module":"Mathlib.Data.ENat.Lattice","initialProofState":"ι : Sort u_2\nκ : Sort u_3\nf : ι → ENat\na : ENat\ninst✝¹ : Nonempty ι\ninst✝ : Nonempty κ\ng : κ → ENat\nh : ∀ (i : ι) (j : κ), LE.le (HAdd.hAdd (f i) (g j)) a\n⊢ LE.le (HAdd.hAdd (iSup f) (iSup g)) a","decl":"lemma iSup_add_iSup_le [Nonempty ι] [Nonempty κ] {g : κ → ℕ∞} (h : ∀ i j, f i + g j ≤ a) :\n    iSup f + iSup g ≤ a := by simp_rw [iSup_add, add_iSup]; exact iSup₂_le h\n\n"}
{"name":"ENat.biSup_add_biSup_le'","module":"Mathlib.Data.ENat.Lattice","initialProofState":"ι : Sort u_2\nκ : Sort u_3\nf : ι → ENat\na : ENat\np : ι → Prop\nq : κ → Prop\nhp : Exists fun i => p i\nhq : Exists fun j => q j\ng : κ → ENat\nh : ∀ (i : ι), p i → ∀ (j : κ), q j → LE.le (HAdd.hAdd (f i) (g j)) a\n⊢ LE.le (HAdd.hAdd (iSup fun i => iSup fun x => f i) (iSup fun j => iSup fun x => g j)) a","decl":"lemma biSup_add_biSup_le' {p : ι → Prop} {q : κ → Prop} (hp : ∃ i, p i) (hq : ∃ j, q j)\n    {g : κ → ℕ∞} (h : ∀ i, p i → ∀ j, q j → f i + g j ≤ a) :\n    (⨆ i, ⨆ _ : p i, f i) + ⨆ j, ⨆ _ : q j, g j ≤ a := by\n  simp_rw [biSup_add' hp, add_biSup' hq]\n  exact iSup₂_le fun i hi => iSup₂_le (h i hi)\n\n"}
{"name":"ENat.biSup_add_biSup_le","module":"Mathlib.Data.ENat.Lattice","initialProofState":"ι : Type u_4\nκ : Type u_5\ns : Set ι\nt : Set κ\nhs : s.Nonempty\nht : t.Nonempty\nf : ι → ENat\ng : κ → ENat\na : ENat\nh : ∀ (i : ι), Membership.mem s i → ∀ (j : κ), Membership.mem t j → LE.le (HAdd.hAdd (f i) (g j)) a\n⊢ LE.le (HAdd.hAdd (iSup fun i => iSup fun h => f i) (iSup fun j => iSup fun h => g j)) a","decl":"lemma biSup_add_biSup_le {ι κ : Type*} {s : Set ι} {t : Set κ} (hs : s.Nonempty) (ht : t.Nonempty)\n    {f : ι → ℕ∞} {g : κ → ℕ∞} {a : ℕ∞} (h : ∀ i ∈ s, ∀ j ∈ t, f i + g j ≤ a) :\n    (⨆ i ∈ s, f i) + ⨆ j ∈ t, g j ≤ a := biSup_add_biSup_le' hs ht h\n\n"}
{"name":"ENat.iSup_add_iSup","module":"Mathlib.Data.ENat.Lattice","initialProofState":"ι : Sort u_2\nf g : ι → ENat\nh : ∀ (i j : ι), Exists fun k => LE.le (HAdd.hAdd (f i) (g j)) (HAdd.hAdd (f k) (g k))\n⊢ Eq (HAdd.hAdd (iSup f) (iSup g)) (iSup fun i => HAdd.hAdd (f i) (g i))","decl":"lemma iSup_add_iSup (h : ∀ i j, ∃ k, f i + g j ≤ f k + g k) : iSup f + iSup g = ⨆ i, f i + g i := by\n  cases isEmpty_or_nonempty ι\n  · simp only [iSup_of_empty, bot_eq_zero, zero_add]\n  · refine le_antisymm ?_ (iSup_le fun a => add_le_add (le_iSup _ _) (le_iSup _ _))\n    refine iSup_add_iSup_le fun i j => ?_\n    rcases h i j with ⟨k, hk⟩\n    exact le_iSup_of_le k hk\n\n"}
{"name":"ENat.iSup_add_iSup_of_monotone","module":"Mathlib.Data.ENat.Lattice","initialProofState":"ι : Type u_4\ninst✝¹ : Preorder ι\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nf g : ι → ENat\nhf : Monotone f\nhg : Monotone g\n⊢ Eq (HAdd.hAdd (iSup f) (iSup g)) (iSup fun a => HAdd.hAdd (f a) (g a))","decl":"lemma iSup_add_iSup_of_monotone {ι : Type*} [Preorder ι] [IsDirected ι (· ≤ ·)] {f g : ι → ℕ∞}\n    (hf : Monotone f) (hg : Monotone g) : iSup f + iSup g = ⨆ a, f a + g a :=\n  iSup_add_iSup fun i j ↦ (exists_ge_ge i j).imp fun _k ⟨hi, hj⟩ ↦ by gcongr <;> apply_rules\n\n"}
{"name":"ENat.sub_iSup","module":"Mathlib.Data.ENat.Lattice","initialProofState":"ι : Sort u_2\nf : ι → ENat\na : ENat\ninst✝ : Nonempty ι\nha : Ne a Top.top\n⊢ Eq (HSub.hSub a (iSup fun i => f i)) (iInf fun i => HSub.hSub a (f i))","decl":"lemma sub_iSup [Nonempty ι] (ha : a ≠ ⊤) : a - ⨆ i, f i = ⨅ i, a - f i := by\n  obtain ⟨i, hi⟩ | h := em (∃ i, a < f i)\n  · rw [tsub_eq_zero_iff_le.2 <| le_iSup_of_le _ hi.le, (iInf_eq_bot _).2, bot_eq_zero]\n    exact fun x hx ↦ ⟨i, by simpa [hi.le, tsub_eq_zero_of_le]⟩\n  simp_rw [not_exists, not_lt] at h\n  refine le_antisymm (le_iInf fun i ↦ tsub_le_tsub_left (le_iSup ..) _) <|\n    ENat.le_sub_of_add_le_left (ne_top_of_le_ne_top ha <| iSup_le h) <|\n    add_le_of_le_tsub_right_of_le (iInf_le_of_le (Classical.arbitrary _) tsub_le_self) <|\n    iSup_le fun i ↦ ?_\n  rw [← ENat.sub_sub_cancel ha (h _)]\n  exact tsub_le_tsub_left (iInf_le (a - f ·) i) _\n\n"}
