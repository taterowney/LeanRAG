{"name":"Multiset.prod_nonneg","module":"Mathlib.Algebra.Order.BigOperators.GroupWithZero.Multiset","initialProofState":"R : Type u_1\ninst✝³ : CommMonoidWithZero R\ninst✝² : PartialOrder R\ninst✝¹ : ZeroLEOneClass R\ninst✝ : PosMulMono R\ns : Multiset R\nh : ∀ (a : R), Membership.mem s a → LE.le 0 a\n⊢ LE.le 0 s.prod","decl":"lemma prod_nonneg {s : Multiset R} (h : ∀ a ∈ s, 0 ≤ a) : 0 ≤ s.prod := by\n  cases s using Quotient.ind\n  simp only [quot_mk_to_coe, mem_coe, prod_coe] at *\n  apply List.prod_nonneg h\n\n"}
{"name":"Multiset.one_le_prod","module":"Mathlib.Algebra.Order.BigOperators.GroupWithZero.Multiset","initialProofState":"R : Type u_1\ninst✝³ : CommMonoidWithZero R\ninst✝² : PartialOrder R\ninst✝¹ : ZeroLEOneClass R\ninst✝ : PosMulMono R\ns : Multiset R\nh : ∀ (a : R), Membership.mem s a → LE.le 1 a\n⊢ LE.le 1 s.prod","decl":"lemma one_le_prod {s : Multiset R} (h : ∀ a ∈ s, 1 ≤ a) : 1 ≤ s.prod := by\n  cases s using Quotient.ind\n  simp only [quot_mk_to_coe, mem_coe, prod_coe] at *\n  apply List.one_le_prod h\n\n"}
{"name":"Multiset.prod_map_le_prod_map₀","module":"Mathlib.Algebra.Order.BigOperators.GroupWithZero.Multiset","initialProofState":"R : Type u_1\ninst✝³ : CommMonoidWithZero R\ninst✝² : PartialOrder R\ninst✝¹ : ZeroLEOneClass R\ninst✝ : PosMulMono R\nι : Type u_2\ns : Multiset ι\nf g : ι → R\nh0 : ∀ (i : ι), Membership.mem s i → LE.le 0 (f i)\nh : ∀ (i : ι), Membership.mem s i → LE.le (f i) (g i)\n⊢ LE.le (Multiset.map f s).prod (Multiset.map g s).prod","decl":"theorem prod_map_le_prod_map₀ {ι : Type*} {s : Multiset ι} (f : ι → R) (g : ι → R)\n    (h0 : ∀ i ∈ s, 0 ≤ f i) (h : ∀ i ∈ s, f i ≤ g i) :\n    (map f s).prod ≤ (map g s).prod := by\n  cases s using Quotient.ind\n  simp only [quot_mk_to_coe, mem_coe, map_coe, prod_coe] at *\n  apply List.prod_map_le_prod_map₀ f g h0 h\n\n"}
{"name":"Multiset.prod_pos","module":"Mathlib.Algebra.Order.BigOperators.GroupWithZero.Multiset","initialProofState":"R : Type u_1\ninst✝⁴ : CommMonoidWithZero R\ninst✝³ : PartialOrder R\ninst✝² : ZeroLEOneClass R\ninst✝¹ : PosMulStrictMono R\ninst✝ : NeZero 1\ns : Multiset R\nh : ∀ (a : R), Membership.mem s a → LT.lt 0 a\n⊢ LT.lt 0 s.prod","decl":"lemma prod_pos {s : Multiset R} (h : ∀ a ∈ s, 0 < a) : 0 < s.prod := by\n  cases s using Quotient.ind\n  simp only [quot_mk_to_coe, mem_coe, map_coe, prod_coe] at *\n  apply List.prod_pos h\n\n"}
{"name":"Multiset.prod_map_lt_prod_map","module":"Mathlib.Algebra.Order.BigOperators.GroupWithZero.Multiset","initialProofState":"R : Type u_1\ninst✝⁴ : CommMonoidWithZero R\ninst✝³ : PartialOrder R\ninst✝² : ZeroLEOneClass R\ninst✝¹ : PosMulStrictMono R\ninst✝ : NeZero 1\nι : Type u_2\ns : Multiset ι\nhs : Ne s 0\nf g : ι → R\nh0 : ∀ (i : ι), Membership.mem s i → LT.lt 0 (f i)\nh : ∀ (i : ι), Membership.mem s i → LT.lt (f i) (g i)\n⊢ LT.lt (Multiset.map f s).prod (Multiset.map g s).prod","decl":"theorem prod_map_lt_prod_map {ι : Type*} {s : Multiset ι} (hs : s ≠ 0)\n    (f : ι → R) (g : ι → R) (h0 : ∀ i ∈ s, 0 < f i) (h : ∀ i ∈ s, f i < g i) :\n    (map f s).prod < (map g s).prod := by\n  cases s using Quotient.ind\n  simp only [quot_mk_to_coe, mem_coe, map_coe, prod_coe, ne_eq, coe_eq_zero] at *\n  apply List.prod_map_lt_prod_map hs f g h0 h\n\n"}
