{"name":"HahnSeries.SummableFamily.powerSeriesFamily_apply","module":"Mathlib.RingTheory.HahnSeries.HEval","initialProofState":"Γ : Type u_1\nR : Type u_3\nV : Type u_4\ninst✝³ : LinearOrderedCancelAddCommMonoid Γ\ninst✝² : CommRing R\ninst✝¹ : CommRing V\ninst✝ : Algebra R V\nx : HahnSeries Γ V\nhx : LT.lt 0 x.orderTop\nf : PowerSeries R\nn : Nat\n⊢ Eq ((HahnSeries.SummableFamily.powerSeriesFamily hx f) n) (HSMul.hSMul ((PowerSeries.coeff R n) f) (HPow.hPow x n))","decl":"@[simp]\ntheorem powerSeriesFamily_apply (n : ℕ) :\n    powerSeriesFamily hx f n = f.coeff R n • x ^ n :=\n  rfl\n\n"}
{"name":"HahnSeries.SummableFamily.powerSeriesFamily_add","module":"Mathlib.RingTheory.HahnSeries.HEval","initialProofState":"Γ : Type u_1\nR : Type u_3\nV : Type u_4\ninst✝³ : LinearOrderedCancelAddCommMonoid Γ\ninst✝² : CommRing R\ninst✝¹ : CommRing V\ninst✝ : Algebra R V\nx : HahnSeries Γ V\nhx : LT.lt 0 x.orderTop\nf g : PowerSeries R\n⊢ Eq (HahnSeries.SummableFamily.powerSeriesFamily hx (HAdd.hAdd f g)) (HAdd.hAdd (HahnSeries.SummableFamily.powerSeriesFamily hx f) (HahnSeries.SummableFamily.powerSeriesFamily hx g))","decl":"theorem powerSeriesFamily_add (g : PowerSeries R) :\n    powerSeriesFamily hx (f + g) = powerSeriesFamily hx f + powerSeriesFamily hx g := by\n  ext1 n\n  simp [add_smul]\n\n"}
{"name":"HahnSeries.SummableFamily.powerSeriesFamily_smul","module":"Mathlib.RingTheory.HahnSeries.HEval","initialProofState":"Γ : Type u_1\nR : Type u_3\nV : Type u_4\ninst✝³ : LinearOrderedCancelAddCommMonoid Γ\ninst✝² : CommRing R\ninst✝¹ : CommRing V\ninst✝ : Algebra R V\nx : HahnSeries Γ V\nhx : LT.lt 0 x.orderTop\nf : PowerSeries R\nr : R\n⊢ Eq (HahnSeries.SummableFamily.powerSeriesFamily hx (HSMul.hSMul r f)) (HSMul.hSMul ((HahnSeries.single 0) r) (HahnSeries.SummableFamily.powerSeriesFamily hx f))","decl":"theorem powerSeriesFamily_smul (r : R) :\n    powerSeriesFamily hx (r • f) = HahnSeries.single (0 : Γ) r • powerSeriesFamily hx f := by\n  ext1 n\n  simp [mul_smul]\n\n"}
{"name":"HahnSeries.SummableFamily.support_powerSeriesFamily_subset","module":"Mathlib.RingTheory.HahnSeries.HEval","initialProofState":"Γ : Type u_1\nR : Type u_3\nV : Type u_4\ninst✝³ : LinearOrderedCancelAddCommMonoid Γ\ninst✝² : CommRing R\ninst✝¹ : CommRing V\ninst✝ : Algebra R V\nx : HahnSeries Γ V\nhx : LT.lt 0 x.orderTop\na b : PowerSeries R\ng : Γ\n⊢ HasSubset.Subset ((HahnSeries.SummableFamily.powerSeriesFamily hx (HMul.hMul a b)).coeff g).support (Finset.image (fun i => HAdd.hAdd i.1 i.2) (((HahnSeries.SummableFamily.powerSeriesFamily hx a).mul (HahnSeries.SummableFamily.powerSeriesFamily hx b)).coeff g).support)","decl":"theorem support_powerSeriesFamily_subset (hx : 0 < x.orderTop) (a b : PowerSeries R) (g : Γ) :\n    ((powerSeriesFamily hx (a * b)).coeff g).support ⊆\n    (((powerSeriesFamily hx a).mul (powerSeriesFamily hx b)).coeff g).support.image\n      fun i => i.1 + i.2 := by\n  simp only [coeff_support, smulFamily_toFun, HahnSeries.coeff_smul, Set.Finite.toFinset_subset,\n    coe_image, support_subset_iff, Set.mem_image, Prod.exists]\n  intro n hn\n  simp_rw [PowerSeries.coeff_mul, sum_smul, mul_smul] at hn\n  have he := exists_ne_zero_of_sum_ne_zero hn\n  simp only [powers_toFun, mem_antidiagonal] at he\n  use he.choose.1, he.choose.2\n  refine ⟨?_, he.choose_spec.1⟩\n  simp only [mul_toFun, smulFamily_toFun, powers_toFun, Algebra.mul_smul_comm,\n    Algebra.smul_mul_assoc, HahnSeries.coeff_smul, Set.Finite.coe_toFinset, ne_eq, Prod.mk.eta,\n    Function.mem_support]\n  rw [← pow_add, smul_comm, he.choose_spec.1]\n  exact he.choose_spec.2\n\n"}
{"name":"HahnSeries.SummableFamily.hsum_powerSeriesFamily_mul","module":"Mathlib.RingTheory.HahnSeries.HEval","initialProofState":"Γ : Type u_1\nR : Type u_3\nV : Type u_4\ninst✝³ : LinearOrderedCancelAddCommMonoid Γ\ninst✝² : CommRing R\ninst✝¹ : CommRing V\ninst✝ : Algebra R V\nx : HahnSeries Γ V\nhx : LT.lt 0 x.orderTop\na b : PowerSeries R\n⊢ Eq (HahnSeries.SummableFamily.powerSeriesFamily hx (HMul.hMul a b)).hsum ((HahnSeries.SummableFamily.powerSeriesFamily hx a).mul (HahnSeries.SummableFamily.powerSeriesFamily hx b)).hsum","decl":"theorem hsum_powerSeriesFamily_mul (hx : 0 < x.orderTop) (a b : PowerSeries R) :\n    (powerSeriesFamily hx (a * b)).hsum =\n    ((powerSeriesFamily hx a).mul (powerSeriesFamily hx b)).hsum := by\n  ext g\n  simp only [powerSeriesFamily_apply, PowerSeries.coeff_mul, Finset.sum_smul, ← Finset.sum_product,\n    coeff_hsum_eq_sum, mul_toFun]\n  rw [sum_subset (support_powerSeriesFamily_subset hx a b g)]\n  · rw [← coeff_sum, sum_sigma', coeff_sum]\n    refine (Finset.sum_of_injOn (fun x => ⟨x.1 + x.2, x⟩) (fun _ _ _ _ => by simp_all) ?_ ?_\n      (fun _ _ => by simp only [smul_mul_smul_comm, pow_add])).symm\n    · intro ij hij\n      simp only [coe_sigma, coe_image, Set.mem_sigma_iff, Set.mem_image, Prod.exists, mem_coe,\n        mem_antidiagonal, and_true]\n      use ij.1, ij.2\n      simp_all\n    · intro i hi his\n      have hisc : ∀ j k : ℕ, ⟨j + k, (j, k)⟩ = i → (PowerSeries.coeff R k) b •\n          (PowerSeries.coeff R j a • (x ^ j * x ^ k).coeff g) = 0 := by\n        intro m n\n        contrapose!\n        simp only [coeff_support, mul_toFun, smulFamily_toFun, Algebra.mul_smul_comm,\n          Algebra.smul_mul_assoc, Set.Finite.coe_toFinset, Set.mem_image,\n          Prod.exists, not_exists, not_and] at his\n        exact his m n\n      simp only [mem_sigma, mem_antidiagonal] at hi\n      rw [mul_comm ((PowerSeries.coeff R i.snd.1) a), ← hi.2, mul_smul, pow_add]\n      exact hisc i.snd.1 i.snd.2 <| Sigma.eq hi.2 (by simp)\n  · intro i hi his\n    simpa [PowerSeries.coeff_mul, sum_smul] using his\n\n"}
