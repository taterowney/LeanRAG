{"name":"IsGalois.to_isSeparable","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nself : IsGalois F E\n⊢ Algebra.IsSeparable F E","decl":"/-- A field extension E/F is Galois if it is both separable and normal. Note that in mathlib\na separable extension of fields is by definition algebraic. -/\n@[stacks 09I0]\nclass IsGalois : Prop where\n  [to_isSeparable : Algebra.IsSeparable F E]\n  [to_normal : Normal F E]\n\n"}
{"name":"IsGalois.to_normal","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nself : IsGalois F E\n⊢ Normal F E","decl":"/-- A field extension E/F is Galois if it is both separable and normal. Note that in mathlib\na separable extension of fields is by definition algebraic. -/\n@[stacks 09I0]\nclass IsGalois : Prop where\n  [to_isSeparable : Algebra.IsSeparable F E]\n  [to_normal : Normal F E]\n\n"}
{"name":"isGalois_iff","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Iff (IsGalois F E) (And (Algebra.IsSeparable F E) (Normal F E))","decl":"theorem isGalois_iff : IsGalois F E ↔ Algebra.IsSeparable F E ∧ Normal F E :=\n  ⟨fun h => ⟨h.1, h.2⟩, fun h =>\n    { to_isSeparable := h.1\n      to_normal := h.2 }⟩\n\n"}
{"name":"IsGalois.self","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"F : Type u_1\ninst✝ : Field F\n⊢ IsGalois F F","decl":"instance self : IsGalois F F :=\n  ⟨⟩\n\n"}
{"name":"IsGalois.integral","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"F : Type u_1\ninst✝³ : Field F\nE : Type u_2\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : IsGalois F E\nx : E\n⊢ IsIntegral F x","decl":"theorem integral [IsGalois F E] (x : E) : IsIntegral F x :=\n  to_normal.isIntegral x\n\n"}
{"name":"IsGalois.separable","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"F : Type u_1\ninst✝³ : Field F\nE : Type u_2\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : IsGalois F E\nx : E\n⊢ IsSeparable F x","decl":"theorem separable [IsGalois F E] (x : E) : IsSeparable F x :=\n  Algebra.IsSeparable.isSeparable F x\n\n"}
{"name":"IsGalois.splits","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"F : Type u_1\ninst✝³ : Field F\nE : Type u_2\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : IsGalois F E\nx : E\n⊢ Polynomial.Splits (algebraMap F E) (minpoly F x)","decl":"theorem splits [IsGalois F E] (x : E) : (minpoly F x).Splits (algebraMap F E) :=\n  Normal.splits' x\n\n"}
{"name":"IsGalois.of_fixed_field","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"E : Type u_2\ninst✝³ : Field E\nG : Type u_3\ninst✝² : Group G\ninst✝¹ : Finite G\ninst✝ : MulSemiringAction G E\n⊢ IsGalois (Subtype fun x => Membership.mem (FixedPoints.subfield G E) x) E","decl":"/-- Let $E$ be a field. Let $G$ be a finite group acting on $E$.\nThen the extension $E / E^G$ is Galois. -/\n@[stacks 09I3 \"first part\"]\ninstance of_fixed_field (G : Type*) [Group G] [Finite G] [MulSemiringAction G E] :\n    IsGalois (FixedPoints.subfield G E) E :=\n  ⟨⟩\n\n"}
{"name":"IsGalois.IntermediateField.AdjoinSimple.card_aut_eq_finrank","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"F : Type u_1\ninst✝³ : Field F\nE : Type u_2\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : FiniteDimensional F E\nα : E\nhα : IsIntegral F α\nh_sep : IsSeparable F α\nh_splits : Polynomial.Splits (algebraMap F (Subtype fun x => Membership.mem (IntermediateField.adjoin F (Singleton.singleton α)) x)) (minpoly F α)\n⊢ Eq (Fintype.card (AlgEquiv F (Subtype fun x => Membership.mem (IntermediateField.adjoin F (Singleton.singleton α)) x) (Subtype fun x => Membership.mem (IntermediateField.adjoin F (Singleton.singleton α)) x))) (Module.finrank F (Subtype fun x => Membership.mem (IntermediateField.adjoin F (Singleton.singleton α)) x))","decl":"theorem IntermediateField.AdjoinSimple.card_aut_eq_finrank [FiniteDimensional F E] {α : E}\n    (hα : IsIntegral F α) (h_sep : IsSeparable F α)\n    (h_splits : (minpoly F α).Splits (algebraMap F F⟮α⟯)) :\n    Fintype.card (F⟮α⟯ ≃ₐ[F] F⟮α⟯) = finrank F F⟮α⟯ := by\n  letI : Fintype (F⟮α⟯ →ₐ[F] F⟮α⟯) := IntermediateField.fintypeOfAlgHomAdjoinIntegral F hα\n  rw [IntermediateField.adjoin.finrank hα]\n  rw [← IntermediateField.card_algHom_adjoin_integral F hα h_sep h_splits]\n  exact Fintype.card_congr (algEquivEquivAlgHom F F⟮α⟯)\n\n"}
{"name":"IsGalois.card_aut_eq_finrank","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"F : Type u_1\ninst✝⁴ : Field F\nE : Type u_2\ninst✝³ : Field E\ninst✝² : Algebra F E\ninst✝¹ : FiniteDimensional F E\ninst✝ : IsGalois F E\n⊢ Eq (Fintype.card (AlgEquiv F E E)) (Module.finrank F E)","decl":"/-- Let $E / F$ be a finite extension of fields. If $E$ is Galois over $F$, then\n$|\\text{Aut}(E/F)| = [E : F]$. -/\n@[stacks 09I1 \"'only if' part\"]\ntheorem card_aut_eq_finrank [FiniteDimensional F E] [IsGalois F E] :\n    Fintype.card (E ≃ₐ[F] E) = finrank F E := by\n  cases' Field.exists_primitive_element F E with α hα\n  let iso : F⟮α⟯ ≃ₐ[F] E :=\n    { toFun := fun e => e.val\n      invFun := fun e => ⟨e, by rw [hα]; exact IntermediateField.mem_top⟩\n      left_inv := fun _ => by ext; rfl\n      right_inv := fun _ => rfl\n      map_mul' := fun _ _ => rfl\n      map_add' := fun _ _ => rfl\n      commutes' := fun _ => rfl }\n  have H : IsIntegral F α := IsGalois.integral F α\n  have h_sep : IsSeparable F α := IsGalois.separable F α\n  have h_splits : (minpoly F α).Splits (algebraMap F E) := IsGalois.splits F α\n  replace h_splits : Polynomial.Splits (algebraMap F F⟮α⟯) (minpoly F α) := by\n    simpa using\n      Polynomial.splits_comp_of_splits (algebraMap F E) iso.symm.toAlgHom.toRingHom h_splits\n  rw [← LinearEquiv.finrank_eq iso.toLinearEquiv]\n  rw [← IntermediateField.AdjoinSimple.card_aut_eq_finrank F E H h_sep h_splits]\n  apply Fintype.card_congr\n  apply Equiv.mk (fun ϕ => iso.trans (ϕ.trans iso.symm)) fun ϕ => iso.symm.trans (ϕ.trans iso)\n  · intro ϕ; ext1; simp only [trans_apply, apply_symm_apply]\n  · intro ϕ; ext1; simp only [trans_apply, symm_apply_apply]\n\n"}
{"name":"IsGalois.tower_top_of_isGalois","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"F : Type u_1\nK : Type u_2\nE : Type u_3\ninst✝⁷ : Field F\ninst✝⁶ : Field K\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F K\ninst✝³ : Algebra F E\ninst✝² : Algebra K E\ninst✝¹ : IsScalarTower F K E\ninst✝ : IsGalois F E\n⊢ IsGalois K E","decl":"/-- Let $E / K / F$ be a tower of field extensions.\nIf $E$ is Galois over $F$, then $E$ is Galois over $K$. -/\n@[stacks 09I2]\ntheorem IsGalois.tower_top_of_isGalois [IsGalois F E] : IsGalois K E :=\n  { to_isSeparable := Algebra.isSeparable_tower_top_of_isSeparable F K E\n    to_normal := Normal.tower_top_of_normal F K E }\n\n"}
{"name":"IsGalois.tower_top_intermediateField","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"F : Type u_1\nE : Type u_3\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\nK : IntermediateField F E\ninst✝ : IsGalois F E\n⊢ IsGalois (Subtype fun x => Membership.mem K x) E","decl":"instance (priority := 100) IsGalois.tower_top_intermediateField (K : IntermediateField F E)\n    [IsGalois F E] : IsGalois K E :=\n  IsGalois.tower_top_of_isGalois F K E\n\n"}
{"name":"isGalois_iff_isGalois_bot","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"F : Type u_1\nE : Type u_3\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Iff (IsGalois (Subtype fun x => Membership.mem Bot.bot x) E) (IsGalois F E)","decl":"theorem isGalois_iff_isGalois_bot : IsGalois (⊥ : IntermediateField F E) E ↔ IsGalois F E := by\n  constructor\n  · intro h\n    exact IsGalois.tower_top_of_isGalois (⊥ : IntermediateField F E) F E\n  · intro h; infer_instance\n\n"}
{"name":"IsGalois.of_algEquiv","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"F : Type u_1\nE : Type u_3\ninst✝⁵ : Field F\ninst✝⁴ : Field E\nE' : Type u_4\ninst✝³ : Field E'\ninst✝² : Algebra F E'\ninst✝¹ : Algebra F E\ninst✝ : IsGalois F E\nf : AlgEquiv F E E'\n⊢ IsGalois F E'","decl":"theorem IsGalois.of_algEquiv [IsGalois F E] (f : E ≃ₐ[F] E') : IsGalois F E' :=\n  { to_isSeparable := Algebra.IsSeparable.of_algHom F E f.symm\n    to_normal := Normal.of_algEquiv f }\n\n"}
{"name":"AlgEquiv.transfer_galois","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"F : Type u_1\nE : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field E\nE' : Type u_4\ninst✝² : Field E'\ninst✝¹ : Algebra F E'\ninst✝ : Algebra F E\nf : AlgEquiv F E E'\n⊢ Iff (IsGalois F E) (IsGalois F E')","decl":"theorem AlgEquiv.transfer_galois (f : E ≃ₐ[F] E') : IsGalois F E ↔ IsGalois F E' :=\n  ⟨fun _ => IsGalois.of_algEquiv f, fun _ => IsGalois.of_algEquiv f.symm⟩\n\n"}
{"name":"isGalois_iff_isGalois_top","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"F : Type u_1\nE : Type u_3\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Iff (IsGalois F (Subtype fun x => Membership.mem Top.top x)) (IsGalois F E)","decl":"theorem isGalois_iff_isGalois_top : IsGalois F (⊤ : IntermediateField F E) ↔ IsGalois F E :=\n  (IntermediateField.topEquiv : (⊤ : IntermediateField F E) ≃ₐ[F] E).transfer_galois\n\n"}
{"name":"isGalois_bot","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"F : Type u_1\nE : Type u_3\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ IsGalois F (Subtype fun x => Membership.mem Bot.bot x)","decl":"instance isGalois_bot : IsGalois F (⊥ : IntermediateField F E) :=\n  (IntermediateField.botEquiv F E).transfer_galois.mpr (IsGalois.self F)\n\n"}
{"name":"IntermediateField.mem_fixedField_iff","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nH : Subgroup (AlgEquiv F E E)\nx : E\n⊢ Iff (Membership.mem (IntermediateField.fixedField H) x) (∀ (f : AlgEquiv F E E), Membership.mem H f → Eq (f x) x)","decl":"theorem mem_fixedField_iff (x) :\n    x ∈ fixedField H ↔ ∀ f ∈ H, f x = x := by\n  show x ∈ MulAction.fixedPoints H E ↔ _\n  simp only [MulAction.mem_fixedPoints, Subtype.forall, Subgroup.mk_smul, AlgEquiv.smul_def]\n\n"}
{"name":"IntermediateField.finrank_fixedField_eq_card","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"F : Type u_1\ninst✝⁴ : Field F\nE : Type u_2\ninst✝³ : Field E\ninst✝² : Algebra F E\nH : Subgroup (AlgEquiv F E E)\ninst✝¹ : FiniteDimensional F E\ninst✝ : DecidablePred fun x => Membership.mem H x\n⊢ Eq (Module.finrank (Subtype fun x => Membership.mem (IntermediateField.fixedField H) x) E) (Fintype.card (Subtype fun x => Membership.mem H x))","decl":"theorem finrank_fixedField_eq_card [FiniteDimensional F E] [DecidablePred (· ∈ H)] :\n    finrank (fixedField H) E = Fintype.card H :=\n  FixedPoints.finrank_eq_card H E\n\n"}
{"name":"IntermediateField.le_iff_le","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nH : Subgroup (AlgEquiv F E E)\nK : IntermediateField F E\n⊢ Iff (LE.le K (IntermediateField.fixedField H)) (LE.le H K.fixingSubgroup)","decl":"theorem le_iff_le : K ≤ fixedField H ↔ H ≤ fixingSubgroup K :=\n  ⟨fun h g hg x => h (Subtype.mem x) ⟨g, hg⟩, fun h x hx g => h (Subtype.mem g) ⟨x, hx⟩⟩\n\n"}
{"name":"IntermediateField.fixingSubgroup_fixedField","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"F : Type u_1\ninst✝³ : Field F\nE : Type u_2\ninst✝² : Field E\ninst✝¹ : Algebra F E\nH : Subgroup (AlgEquiv F E E)\ninst✝ : FiniteDimensional F E\n⊢ Eq (IntermediateField.fixedField H).fixingSubgroup H","decl":"theorem fixingSubgroup_fixedField [FiniteDimensional F E] : fixingSubgroup (fixedField H) = H := by\n  have H_le : H ≤ fixingSubgroup (fixedField H) := (le_iff_le _ _).mp le_rfl\n  classical\n  suffices Fintype.card H = Fintype.card (fixingSubgroup (fixedField H)) by\n    exact SetLike.coe_injective (Set.eq_of_inclusion_surjective\n      ((Fintype.bijective_iff_injective_and_card (Set.inclusion H_le)).mpr\n        ⟨Set.inclusion_injective H_le, this⟩).2).symm\n  apply Fintype.card_congr\n  refine (FixedPoints.toAlgHomEquiv H E).trans ?_\n  refine (algEquivEquivAlgHom (fixedField H) E).toEquiv.symm.trans ?_\n  exact (fixingSubgroupEquiv (fixedField H)).toEquiv.symm\n\n-- Porting note: added `fixedField.smul` for `fixedField.isScalarTower`\n"}
{"name":"IntermediateField.fixedField.isScalarTower","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nK : IntermediateField F E\n⊢ IsScalarTower (Subtype fun x => Membership.mem K x) (Subtype fun x => Membership.mem (IntermediateField.fixedField K.fixingSubgroup) x) E","decl":"instance fixedField.isScalarTower : IsScalarTower K (fixedField (fixingSubgroup K)) E :=\n  ⟨fun _ _ _ => mul_assoc _ _ _⟩\n\n"}
{"name":"IsGalois.fixedField_fixingSubgroup","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"F : Type u_1\ninst✝³ : Field F\nE : Type u_2\ninst✝² : Field E\ninst✝¹ : Algebra F E\nK : IntermediateField F E\ninst✝ : FiniteDimensional F E\nh : IsGalois F E\n⊢ Eq (IntermediateField.fixedField K.fixingSubgroup) K","decl":"theorem fixedField_fixingSubgroup [FiniteDimensional F E] [h : IsGalois F E] :\n    IntermediateField.fixedField (IntermediateField.fixingSubgroup K) = K := by\n  have K_le : K ≤ IntermediateField.fixedField (IntermediateField.fixingSubgroup K) :=\n    (IntermediateField.le_iff_le _ _).mpr le_rfl\n  suffices\n    finrank K E = finrank (IntermediateField.fixedField (IntermediateField.fixingSubgroup K)) E by\n    exact (IntermediateField.eq_of_le_of_finrank_eq' K_le this).symm\n  classical\n  rw [IntermediateField.finrank_fixedField_eq_card,\n    Fintype.card_congr (IntermediateField.fixingSubgroupEquiv K).toEquiv]\n  exact (card_aut_eq_finrank K E).symm\n\n"}
{"name":"IsGalois.card_fixingSubgroup_eq_finrank","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"F : Type u_1\ninst✝⁵ : Field F\nE : Type u_2\ninst✝⁴ : Field E\ninst✝³ : Algebra F E\nK : IntermediateField F E\ninst✝² : DecidablePred fun x => Membership.mem K.fixingSubgroup x\ninst✝¹ : FiniteDimensional F E\ninst✝ : IsGalois F E\n⊢ Eq (Fintype.card (Subtype fun x => Membership.mem K.fixingSubgroup x)) (Module.finrank (Subtype fun x => Membership.mem K x) E)","decl":"theorem card_fixingSubgroup_eq_finrank [DecidablePred (· ∈ IntermediateField.fixingSubgroup K)]\n    [FiniteDimensional F E] [IsGalois F E] :\n    Fintype.card (IntermediateField.fixingSubgroup K) = finrank K E := by\n  conv_rhs => rw [← fixedField_fixingSubgroup K, IntermediateField.finrank_fixedField_eq_card]\n\n"}
{"name":"IntermediateField.restrictNormalHom_ker","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"K : Type u_3\nL : Type u_4\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra K L\nE : IntermediateField K L\ninst✝ : Normal K (Subtype fun x => Membership.mem E x)\n⊢ Eq (AlgEquiv.restrictNormalHom (Subtype fun x => Membership.mem E x)).ker E.fixingSubgroup","decl":"lemma IntermediateField.restrictNormalHom_ker (E : IntermediateField K L) [Normal K E] :\n    (restrictNormalHom E).ker = E.fixingSubgroup := by\n  simp [fixingSubgroup, Subgroup.ext_iff, AlgEquiv.ext_iff, Subtype.ext_iff,\n    restrictNormalHom_apply, mem_fixingSubgroup_iff]\n\n"}
{"name":"IsGalois.of_fixedField_normal_subgroup","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"K : Type u_3\nL : Type u_4\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra K L\ninst✝ : IsGalois K L\nH : Subgroup (AlgEquiv K L L)\nhn : H.Normal\n⊢ IsGalois K (Subtype fun x => Membership.mem (IntermediateField.fixedField H) x)","decl":"/-- If `H` is a normal Subgroup of `Gal(L / K)`, then `fixedField H` is Galois over `K`. -/\ninstance of_fixedField_normal_subgroup [IsGalois K L]\n    (H : Subgroup (L ≃ₐ[K] L)) [hn : Subgroup.Normal H] : IsGalois K (fixedField H) where\n  to_isSeparable := Algebra.isSeparable_tower_bot_of_isSeparable K (fixedField H) L\n  to_normal := by\n    apply normal_iff_forall_map_le'.mpr\n    rintro σ x ⟨a, ha, rfl⟩ τ\n    exact (symm_apply_eq σ).mp (ha ⟨σ⁻¹ * τ * σ, Subgroup.Normal.conj_mem' hn τ.1 τ.2 σ⟩)\n\n"}
{"name":"IsGalois.normalAutEquivQuotient_apply","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"K : Type u_3\nL : Type u_4\ninst✝⁵ : Field K\ninst✝⁴ : Field L\ninst✝³ : Algebra K L\ninst✝² : FiniteDimensional K L\ninst✝¹ : IsGalois K L\nH : Subgroup (AlgEquiv K L L)\ninst✝ : H.Normal\nσ : AlgEquiv K L L\n⊢ Eq ((IsGalois.normalAutEquivQuotient H) ↑σ) ((AlgEquiv.restrictNormalHom (Subtype fun x => Membership.mem (IntermediateField.fixedField H) x)) σ)","decl":"lemma normalAutEquivQuotient_apply [FiniteDimensional K L] [IsGalois K L]\n    (H : Subgroup (L ≃ₐ[K] L)) [Subgroup.Normal H] (σ : (L ≃ₐ[K] L)) :\n    normalAutEquivQuotient H σ = (restrictNormalHom (fixedField H)) σ := rfl\n\n"}
{"name":"IsGalois.map_fixingSubgroup","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"K : Type u_3\nL : Type u_4\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nE : IntermediateField K L\nσ : AlgEquiv K L L\n⊢ Eq (IntermediateField.map (↑σ) E).fixingSubgroup (HSMul.hSMul (MulAut.conj σ) E.fixingSubgroup)","decl":"@[simp]\ntheorem map_fixingSubgroup (σ : L ≃ₐ[K] L) :\n    (E.map σ).fixingSubgroup = (MulAut.conj σ) • E.fixingSubgroup := by\n  ext τ\n  simp only [coe_map, AlgHom.coe_coe, Set.mem_image, SetLike.mem_coe, AlgEquiv.smul_def,\n    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, Subtype.forall,\n    Subgroup.mem_pointwise_smul_iff_inv_smul_mem, ← symm_apply_eq,\n    IntermediateField.fixingSubgroup, mem_fixingSubgroup_iff]\n  rfl\n\n"}
{"name":"IsGalois.fixingSubgroup_normal_of_isGalois","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"K : Type u_3\nL : Type u_4\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra K L\nE : IntermediateField K L\ninst✝¹ : IsGalois K L\ninst✝ : IsGalois K (Subtype fun x => Membership.mem E x)\n⊢ E.fixingSubgroup.Normal","decl":"/-- Let `E` be an intermediateField of a Galois extension `L / K`. If `E / K` is\nGalois extension, then `E.fixingSubgroup` is a normal subgroup of `Gal(L / K)`. -/\ninstance fixingSubgroup_normal_of_isGalois [IsGalois K L] [IsGalois K E] :\n    E.fixingSubgroup.Normal := by\n  apply Subgroup.Normal.of_conjugate_fixed (fun σ ↦ ?_)\n  rw [← map_fixingSubgroup, normal_iff_forall_map_eq'.mp inferInstance σ]\n\n"}
{"name":"IsGalois.is_separable_splitting_field","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"F : Type u_1\ninst✝⁴ : Field F\nE : Type u_2\ninst✝³ : Field E\ninst✝² : Algebra F E\ninst✝¹ : FiniteDimensional F E\ninst✝ : IsGalois F E\n⊢ Exists fun p => And p.Separable (Polynomial.IsSplittingField F E p)","decl":"theorem is_separable_splitting_field [FiniteDimensional F E] [IsGalois F E] :\n    ∃ p : F[X], p.Separable ∧ p.IsSplittingField F E := by\n  cases' Field.exists_primitive_element F E with α h1\n  use minpoly F α, separable F α, IsGalois.splits F α\n  rw [eq_top_iff, ← IntermediateField.top_toSubalgebra, ← h1]\n  rw [IntermediateField.adjoin_simple_toSubalgebra_of_integral (integral F α)]\n  apply Algebra.adjoin_mono\n  rw [Set.singleton_subset_iff, Polynomial.mem_rootSet]\n  exact ⟨minpoly.ne_zero (integral F α), minpoly.aeval _ _⟩\n\n"}
{"name":"IsGalois.of_fixedField_eq_bot","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"F : Type u_1\ninst✝³ : Field F\nE : Type u_2\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : FiniteDimensional F E\nh : Eq (IntermediateField.fixedField Top.top) Bot.bot\n⊢ IsGalois F E","decl":"theorem of_fixedField_eq_bot [FiniteDimensional F E]\n    (h : IntermediateField.fixedField (⊤ : Subgroup (E ≃ₐ[F] E)) = ⊥) : IsGalois F E := by\n  rw [← isGalois_iff_isGalois_bot, ← h]\n  classical exact IsGalois.of_fixed_field E (⊤ : Subgroup (E ≃ₐ[F] E))\n\n"}
{"name":"IsGalois.of_card_aut_eq_finrank","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"F : Type u_1\ninst✝³ : Field F\nE : Type u_2\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : FiniteDimensional F E\nh : Eq (Fintype.card (AlgEquiv F E E)) (Module.finrank F E)\n⊢ IsGalois F E","decl":"/-- Let $E / F$ be a finite extension of fields. If $|\\text{Aut}(E/F)| = [E : F]$, then\n$E$ is Galois over $F$. -/\n@[stacks 09I1 \"'if' part\"]\ntheorem of_card_aut_eq_finrank [FiniteDimensional F E]\n    (h : Fintype.card (E ≃ₐ[F] E) = finrank F E) : IsGalois F E := by\n  apply of_fixedField_eq_bot\n  have p : 0 < finrank (IntermediateField.fixedField (⊤ : Subgroup (E ≃ₐ[F] E))) E := finrank_pos\n  classical\n  rw [← IntermediateField.finrank_eq_one_iff, ← mul_left_inj' (ne_of_lt p).symm,\n    finrank_mul_finrank, ← h, one_mul, IntermediateField.finrank_fixedField_eq_card]\n  apply Fintype.card_congr\n  exact\n    { toFun := fun g => ⟨g, Subgroup.mem_top g⟩\n      invFun := (↑)\n      left_inv := fun g => rfl\n      right_inv := fun _ => by ext; rfl }\n\n"}
{"name":"IsGalois.of_separable_splitting_field_aux","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"F : Type u_1\ninst✝⁸ : Field F\nE : Type u_2\ninst✝⁷ : Field E\ninst✝⁶ : Algebra F E\np : Polynomial F\nhFE : FiniteDimensional F E\nsp : Polynomial.IsSplittingField F E p\nhp : p.Separable\nK : Type u_3\ninst✝⁵ : Field K\ninst✝⁴ : Algebra F K\ninst✝³ : Algebra K E\ninst✝² : IsScalarTower F K E\nx : E\nhx : Membership.mem (p.aroots E) x\ninst✝¹ : Fintype (AlgHom F K E)\ninst✝ : Fintype (AlgHom F (Subtype fun x_1 => Membership.mem (IntermediateField.restrictScalars F (IntermediateField.adjoin K (Singleton.singleton x))) x_1) E)\n⊢ Eq (Fintype.card (AlgHom F (Subtype fun x_1 => Membership.mem (IntermediateField.restrictScalars F (IntermediateField.adjoin K (Singleton.singleton x))) x_1) E)) (HMul.hMul (Fintype.card (AlgHom F K E)) (Module.finrank K (Subtype fun x_1 => Membership.mem (IntermediateField.adjoin K (Singleton.singleton x)) x_1)))","decl":"theorem of_separable_splitting_field_aux [hFE : FiniteDimensional F E] [sp : p.IsSplittingField F E]\n    (hp : p.Separable) (K : Type*) [Field K] [Algebra F K] [Algebra K E] [IsScalarTower F K E]\n    {x : E} (hx : x ∈ p.aroots E)\n    -- these are both implied by `hFE`, but as they carry data this makes the lemma more general\n    [Fintype (K →ₐ[F] E)]\n    [Fintype (K⟮x⟯.restrictScalars F →ₐ[F] E)] :\n    Fintype.card (K⟮x⟯.restrictScalars F →ₐ[F] E) = Fintype.card (K →ₐ[F] E) * finrank K K⟮x⟯ := by\n  have h : IsIntegral K x := (isIntegral_of_noetherian (IsNoetherian.iff_fg.2 hFE) x).tower_top\n  have h1 : p ≠ 0 := fun hp => by\n    rw [hp, Polynomial.aroots_zero] at hx\n    exact Multiset.not_mem_zero x hx\n  have h2 : minpoly K x ∣ p.map (algebraMap F K) := by\n    apply minpoly.dvd\n    rw [Polynomial.aeval_def, Polynomial.eval₂_map, ← Polynomial.eval_map, ←\n      IsScalarTower.algebraMap_eq]\n    exact (Polynomial.mem_roots (Polynomial.map_ne_zero h1)).mp hx\n  let key_equiv : (K⟮x⟯.restrictScalars F →ₐ[F] E) ≃\n      Σ f : K →ₐ[F] E, @AlgHom K K⟮x⟯ E _ _ _ _ (RingHom.toAlgebra f) := by\n    change (K⟮x⟯ →ₐ[F] E) ≃ Σ f : K →ₐ[F] E, _\n    exact algHomEquivSigma\n  haveI : ∀ f : K →ₐ[F] E, Fintype (@AlgHom K K⟮x⟯ E _ _ _ _ (RingHom.toAlgebra f)) := fun f => by\n    have := Fintype.ofEquiv _ key_equiv\n    apply Fintype.ofInjective (Sigma.mk f) fun _ _ H => eq_of_heq (Sigma.ext_iff.mp H).2\n  rw [Fintype.card_congr key_equiv, Fintype.card_sigma, IntermediateField.adjoin.finrank h]\n  apply Finset.sum_const_nat\n  intro f _\n  rw [← @IntermediateField.card_algHom_adjoin_integral K _ E _ _ x E _ (RingHom.toAlgebra f) h]\n  · congr!\n  · exact Polynomial.Separable.of_dvd ((Polynomial.separable_map (algebraMap F K)).mpr hp) h2\n  · refine Polynomial.splits_of_splits_of_dvd _ (Polynomial.map_ne_zero h1) ?_ h2\n    -- Porting note: use unification instead of synthesis for one argument of `algebraMap_eq`\n    rw [Polynomial.splits_map_iff, ← @IsScalarTower.algebraMap_eq _ _ _ _ _ _ _ (_) _ _]\n    exact sp.splits\n\n"}
{"name":"IsGalois.of_separable_splitting_field","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\np : Polynomial F\nsp : Polynomial.IsSplittingField F E p\nhp : p.Separable\n⊢ IsGalois F E","decl":"theorem of_separable_splitting_field [sp : p.IsSplittingField F E] (hp : p.Separable) :\n    IsGalois F E := by\n  haveI hFE : FiniteDimensional F E := Polynomial.IsSplittingField.finiteDimensional E p\n  letI := Classical.decEq E\n  let s := p.rootSet E\n  have adjoin_root : IntermediateField.adjoin F s = ⊤ := by\n    apply IntermediateField.toSubalgebra_injective\n    rw [IntermediateField.top_toSubalgebra, ← top_le_iff, ← sp.adjoin_rootSet]\n    apply IntermediateField.algebra_adjoin_le_adjoin\n  let P : IntermediateField F E → Prop := fun K => Fintype.card (K →ₐ[F] E) = finrank F K\n  suffices P (IntermediateField.adjoin F s) by\n    rw [adjoin_root] at this\n    apply of_card_aut_eq_finrank\n    rw [← Eq.trans this (LinearEquiv.finrank_eq IntermediateField.topEquiv.toLinearEquiv)]\n    exact Fintype.card_congr ((algEquivEquivAlgHom F E).toEquiv.trans\n      (IntermediateField.topEquiv.symm.arrowCongr AlgEquiv.refl))\n  apply IntermediateField.induction_on_adjoin_finset _ P\n  · have key := IntermediateField.card_algHom_adjoin_integral F (K := E)\n      (show IsIntegral F (0 : E) from isIntegral_zero)\n    rw [IsSeparable, minpoly.zero, Polynomial.natDegree_X] at key\n    specialize key Polynomial.separable_X (Polynomial.splits_X (algebraMap F E))\n    rw [← @Subalgebra.finrank_bot F E _ _ _, ← IntermediateField.bot_toSubalgebra] at key\n    refine Eq.trans ?_ key\n    -- Porting note: use unification instead of synthesis for one argument of `card_congr`\n    apply @Fintype.card_congr _ _ _ (_) _\n    rw [IntermediateField.adjoin_zero]\n  intro K x hx hK\n  simp only [P] at *\n  rw [of_separable_splitting_field_aux hp K (Multiset.mem_toFinset.mp hx), hK, finrank_mul_finrank]\n  symm\n  refine LinearEquiv.finrank_eq ?_\n  rfl\n\n"}
{"name":"IsGalois.tfae","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"F : Type u_1\ninst✝³ : Field F\nE : Type u_2\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : FiniteDimensional F E\n⊢ (List.cons (IsGalois F E) (List.cons (Eq (IntermediateField.fixedField Top.top) Bot.bot) (List.cons (Eq (Fintype.card (AlgEquiv F E E)) (Module.finrank F E)) (List.cons (Exists fun p => And p.Separable (Polynomial.IsSplittingField F E p)) List.nil)))).TFAE","decl":"/-- Equivalent characterizations of a Galois extension of finite degree -/\ntheorem tfae [FiniteDimensional F E] : List.TFAE [\n    IsGalois F E,\n    IntermediateField.fixedField (⊤ : Subgroup (E ≃ₐ[F] E)) = ⊥,\n    Fintype.card (E ≃ₐ[F] E) = finrank F E,\n    ∃ p : F[X], p.Separable ∧ p.IsSplittingField F E] := by\n  tfae_have 1 → 2 := fun h ↦ OrderIso.map_bot (@intermediateFieldEquivSubgroup F _ E _ _ _ h).symm\n  tfae_have 1 → 3 := fun _ ↦ card_aut_eq_finrank F E\n  tfae_have 1 → 4 := fun _ ↦ is_separable_splitting_field F E\n  tfae_have 2 → 1 := of_fixedField_eq_bot F E\n  tfae_have 3 → 1 := of_card_aut_eq_finrank F E\n  tfae_have 4 → 1 := fun ⟨h, hp1, _⟩ ↦ of_separable_splitting_field hp1\n  tfae_finish\n\n"}
{"name":"IsGalois.normalClosure","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"k : Type u_1\nK : Type u_2\nF : Type u_3\ninst✝⁵ : Field k\ninst✝⁴ : Field K\ninst✝³ : Field F\ninst✝² : Algebra k K\ninst✝¹ : Algebra k F\ninst✝ : IsGalois k F\n⊢ IsGalois k (Subtype fun x => Membership.mem (normalClosure k K F) x)","decl":"/-- Let $F / K / k$ be a tower of field extensions. If $F$ is Galois over $k$,\nthen the normal closure of $K$ over $k$ in $F$ is Galois over $k$. -/\n@[stacks 0EXM]\ninstance IsGalois.normalClosure : IsGalois k (normalClosure k K F) where\n  to_isSeparable := Algebra.isSeparable_tower_bot_of_isSeparable k _ F\n\n"}
{"name":"IsAlgClosure.isGalois","module":"Mathlib.FieldTheory.Galois.Basic","initialProofState":"k : Type u_1\nK : Type u_2\ninst✝⁴ : Field k\ninst✝³ : Field K\ninst✝² : Algebra k K\ninst✝¹ : IsAlgClosure k K\ninst✝ : CharZero k\n⊢ IsGalois k K","decl":"instance (priority := 100) IsAlgClosure.isGalois (k K : Type*) [Field k] [Field K] [Algebra k K]\n    [IsAlgClosure k K] [CharZero k] : IsGalois k K where\n\n"}
