{"name":"CoxeterSystem.isReflection_simple","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\ni : B\n⊢ cs.IsReflection (cs.simple i)","decl":"theorem isReflection_simple (i : B) : cs.IsReflection (s i) := by use 1, i; simp\n\n"}
{"name":"CoxeterSystem.IsReflection.pow_two","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nt : W\nht : cs.IsReflection t\n⊢ Eq (HPow.hPow t 2) 1","decl":"theorem pow_two : t ^ 2 = 1 := by\n  rcases ht with ⟨w, i, rfl⟩\n  simp\n\n"}
{"name":"CoxeterSystem.IsReflection.mul_self","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nt : W\nht : cs.IsReflection t\n⊢ Eq (HMul.hMul t t) 1","decl":"theorem mul_self : t * t = 1 := by\n  rcases ht with ⟨w, i, rfl⟩\n  simp\n\n"}
{"name":"CoxeterSystem.IsReflection.inv","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nt : W\nht : cs.IsReflection t\n⊢ Eq (Inv.inv t) t","decl":"theorem inv : t⁻¹ = t := by\n  rcases ht with ⟨w, i, rfl⟩\n  simp [mul_assoc]\n\n"}
{"name":"CoxeterSystem.IsReflection.isReflection_inv","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nt : W\nht : cs.IsReflection t\n⊢ cs.IsReflection (Inv.inv t)","decl":"theorem isReflection_inv : cs.IsReflection t⁻¹ := by rwa [ht.inv]\n\n"}
{"name":"CoxeterSystem.IsReflection.odd_length","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nt : W\nht : cs.IsReflection t\n⊢ Odd (cs.length t)","decl":"theorem odd_length : Odd (ℓ t) := by\n  suffices cs.lengthParity t = Multiplicative.ofAdd 1 by\n    simpa [lengthParity_eq_ofAdd_length, ZMod.eq_one_iff_odd]\n  rcases ht with ⟨w, i, rfl⟩\n  simp [lengthParity_simple]\n\n"}
{"name":"CoxeterSystem.IsReflection.length_mul_left_ne","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nt : W\nht : cs.IsReflection t\nw : W\n⊢ Ne (cs.length (HMul.hMul w t)) (cs.length w)","decl":"theorem length_mul_left_ne (w : W) : ℓ (w * t) ≠ ℓ w := by\n  suffices cs.lengthParity (w * t) ≠ cs.lengthParity w by\n    contrapose! this\n    simp only [lengthParity_eq_ofAdd_length, this]\n  rcases ht with ⟨w, i, rfl⟩\n  simp [lengthParity_simple]\n\n"}
{"name":"CoxeterSystem.IsReflection.length_mul_right_ne","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nt : W\nht : cs.IsReflection t\nw : W\n⊢ Ne (cs.length (HMul.hMul t w)) (cs.length w)","decl":"theorem length_mul_right_ne (w : W) : ℓ (t * w) ≠ ℓ w := by\n  suffices cs.lengthParity (t * w) ≠ cs.lengthParity w by\n    contrapose! this\n    simp only [lengthParity_eq_ofAdd_length, this]\n  rcases ht with ⟨w, i, rfl⟩\n  simp [lengthParity_simple]\n\n"}
{"name":"CoxeterSystem.IsReflection.conj","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nt : W\nht : cs.IsReflection t\nw : W\n⊢ cs.IsReflection (HMul.hMul (HMul.hMul w t) (Inv.inv w))","decl":"theorem conj (w : W) : cs.IsReflection (w * t * w⁻¹) := by\n  obtain ⟨u, i, rfl⟩ := ht\n  use w * u, i\n  group\n\n"}
{"name":"CoxeterSystem.isReflection_conj_iff","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw t : W\n⊢ Iff (cs.IsReflection (HMul.hMul (HMul.hMul w t) (Inv.inv w))) (cs.IsReflection t)","decl":"@[simp]\ntheorem isReflection_conj_iff (w t : W) :\n    cs.IsReflection (w * t * w⁻¹) ↔ cs.IsReflection t := by\n  constructor\n  · intro h\n    simpa [← mul_assoc] using h.conj w⁻¹\n  · exact IsReflection.conj (w := w)\n\n"}
{"name":"CoxeterSystem.isRightInversion_inv_iff","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw t : W\n⊢ Iff (cs.IsRightInversion (Inv.inv w) t) (cs.IsLeftInversion w t)","decl":"theorem isRightInversion_inv_iff {w t : W} :\n    cs.IsRightInversion w⁻¹ t ↔ cs.IsLeftInversion w t := by\n  apply and_congr_right\n  intro ht\n  rw [← length_inv, mul_inv_rev, inv_inv, ht.inv, cs.length_inv w]\n\n"}
{"name":"CoxeterSystem.isLeftInversion_inv_iff","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw t : W\n⊢ Iff (cs.IsLeftInversion (Inv.inv w) t) (cs.IsRightInversion w t)","decl":"theorem isLeftInversion_inv_iff {w t : W} :\n    cs.IsLeftInversion w⁻¹ t ↔ cs.IsRightInversion w t := by\n  convert cs.isRightInversion_inv_iff.symm\n  simp\n\n"}
{"name":"CoxeterSystem.IsReflection.isRightInversion_mul_left_iff","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nt : W\nht : cs.IsReflection t\nw : W\n⊢ Iff (cs.IsRightInversion (HMul.hMul w t) t) (Not (cs.IsRightInversion w t))","decl":"theorem isRightInversion_mul_left_iff {w : W} :\n    cs.IsRightInversion (w * t) t ↔ ¬cs.IsRightInversion w t := by\n  unfold IsRightInversion\n  simp only [mul_assoc, ht.inv, ht.mul_self, mul_one, ht, true_and, not_lt]\n  constructor\n  · exact le_of_lt\n  · exact (lt_of_le_of_ne' · (ht.length_mul_left_ne w))\n\n"}
{"name":"CoxeterSystem.IsReflection.not_isRightInversion_mul_left_iff","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nt : W\nht : cs.IsReflection t\nw : W\n⊢ Iff (Not (cs.IsRightInversion (HMul.hMul w t) t)) (cs.IsRightInversion w t)","decl":"theorem not_isRightInversion_mul_left_iff {w : W} :\n    ¬cs.IsRightInversion (w * t) t ↔ cs.IsRightInversion w t :=\n  ht.isRightInversion_mul_left_iff.not_left\n\n"}
{"name":"CoxeterSystem.IsReflection.isLeftInversion_mul_right_iff","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nt : W\nht : cs.IsReflection t\nw : W\n⊢ Iff (cs.IsLeftInversion (HMul.hMul t w) t) (Not (cs.IsLeftInversion w t))","decl":"theorem isLeftInversion_mul_right_iff {w : W} :\n    cs.IsLeftInversion (t * w) t ↔ ¬cs.IsLeftInversion w t := by\n  rw [← isRightInversion_inv_iff, ← isRightInversion_inv_iff, mul_inv_rev, ht.inv,\n    ht.isRightInversion_mul_left_iff]\n\n"}
{"name":"CoxeterSystem.IsReflection.not_isLeftInversion_mul_right_iff","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nt : W\nht : cs.IsReflection t\nw : W\n⊢ Iff (Not (cs.IsLeftInversion (HMul.hMul t w) t)) (cs.IsLeftInversion w t)","decl":"theorem not_isLeftInversion_mul_right_iff {w : W}  :\n    ¬cs.IsLeftInversion (t * w) t ↔ cs.IsLeftInversion w t :=\n  ht.isLeftInversion_mul_right_iff.not_left\n\n"}
{"name":"CoxeterSystem.isRightInversion_simple_iff_isRightDescent","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\n⊢ Iff (cs.IsRightInversion w (cs.simple i)) (cs.IsRightDescent w i)","decl":"@[simp]\ntheorem isRightInversion_simple_iff_isRightDescent (w : W) (i : B) :\n    cs.IsRightInversion w (s i) ↔ cs.IsRightDescent w i := by\n  simp [IsRightInversion, IsRightDescent, cs.isReflection_simple i]\n\n"}
{"name":"CoxeterSystem.isLeftInversion_simple_iff_isLeftDescent","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\n⊢ Iff (cs.IsLeftInversion w (cs.simple i)) (cs.IsLeftDescent w i)","decl":"@[simp]\ntheorem isLeftInversion_simple_iff_isLeftDescent (w : W) (i : B) :\n    cs.IsLeftInversion w (s i) ↔ cs.IsLeftDescent w i := by\n  simp [IsLeftInversion, IsLeftDescent, cs.isReflection_simple i]\n\n"}
{"name":"CoxeterSystem.rightInvSeq_nil","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\n⊢ Eq (cs.rightInvSeq List.nil) List.nil","decl":"@[simp] theorem rightInvSeq_nil : ris [] = [] := rfl\n\n"}
{"name":"CoxeterSystem.leftInvSeq_nil","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\n⊢ Eq (cs.leftInvSeq List.nil) List.nil","decl":"@[simp] theorem leftInvSeq_nil : lis [] = [] := rfl\n\n"}
{"name":"CoxeterSystem.rightInvSeq_singleton","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\ni : B\n⊢ Eq (cs.rightInvSeq (List.cons i List.nil)) (List.cons (cs.simple i) List.nil)","decl":"@[simp] theorem rightInvSeq_singleton (i : B) : ris [i] = [s i] := by simp [rightInvSeq]\n\n"}
{"name":"CoxeterSystem.leftInvSeq_singleton","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\ni : B\n⊢ Eq (cs.leftInvSeq (List.cons i List.nil)) (List.cons (cs.simple i) List.nil)","decl":"@[simp] theorem leftInvSeq_singleton (i : B) : lis [i] = [s i] := rfl\n\n"}
{"name":"CoxeterSystem.rightInvSeq_concat","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nω : List B\ni : B\n⊢ Eq (cs.rightInvSeq (ω.concat i)) ((List.map (⇑(MulAut.conj (cs.simple i))) (cs.rightInvSeq ω)).concat (cs.simple i))","decl":"theorem rightInvSeq_concat (ω : List B) (i : B) :\n    ris (ω.concat i) = (List.map (MulAut.conj (s i)) (ris ω)).concat (s i) := by\n  induction' ω with j ω ih\n  · simp\n  · dsimp [rightInvSeq, concat]\n    rw [ih]\n    simp only [concat_eq_append, wordProd_append, wordProd_cons, wordProd_nil, mul_one, mul_inv_rev,\n      inv_simple, cons_append, cons.injEq, and_true]\n    group\n\n"}
{"name":"CoxeterSystem.leftInvSeq_concat","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nω : List B\ni : B\n⊢ Eq (cs.leftInvSeq (ω.concat i)) ((cs.leftInvSeq ω).concat (HMul.hMul (HMul.hMul (cs.wordProd ω) (cs.simple i)) (Inv.inv (cs.wordProd ω))))","decl":"theorem leftInvSeq_concat (ω : List B) (i : B) :\n    lis (ω.concat i) = (lis ω).concat ((π ω) * (s i) * (π ω)⁻¹) := by\n  simp [leftInvSeq_eq_reverse_rightInvSeq_reverse, rightInvSeq]\n\n"}
{"name":"CoxeterSystem.rightInvSeq_reverse","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nω : List B\n⊢ Eq (cs.rightInvSeq ω.reverse) (cs.leftInvSeq ω).reverse","decl":"theorem rightInvSeq_reverse (ω : List B) :\n    ris (ω.reverse) = (lis ω).reverse := by\n  simp [leftInvSeq_eq_reverse_rightInvSeq_reverse]\n\n"}
{"name":"CoxeterSystem.leftInvSeq_reverse","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nω : List B\n⊢ Eq (cs.leftInvSeq ω.reverse) (cs.rightInvSeq ω).reverse","decl":"theorem leftInvSeq_reverse (ω : List B) :\n    lis (ω.reverse) = (ris ω).reverse := by\n  simp [leftInvSeq_eq_reverse_rightInvSeq_reverse]\n\n"}
{"name":"CoxeterSystem.length_rightInvSeq","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nω : List B\n⊢ Eq (cs.rightInvSeq ω).length ω.length","decl":"@[simp] theorem length_rightInvSeq (ω : List B) : (ris ω).length = ω.length := by\n  induction' ω with i ω ih\n  · simp\n  · simpa [rightInvSeq]\n\n"}
{"name":"CoxeterSystem.length_leftInvSeq","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nω : List B\n⊢ Eq (cs.leftInvSeq ω).length ω.length","decl":"@[simp] theorem length_leftInvSeq (ω : List B) : (lis ω).length = ω.length := by\n  simp [leftInvSeq_eq_reverse_rightInvSeq_reverse]\n\n"}
{"name":"CoxeterSystem.getD_rightInvSeq","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nω : List B\nj : Nat\n⊢ Eq ((cs.rightInvSeq ω).getD j 1) (HMul.hMul (HMul.hMul (Inv.inv (cs.wordProd (List.drop (HAdd.hAdd j 1) ω))) ((Option.map cs.simple (GetElem?.getElem? ω j)).getD 1)) (cs.wordProd (List.drop (HAdd.hAdd j 1) ω)))","decl":"theorem getD_rightInvSeq (ω : List B) (j : ℕ) :\n    (ris ω).getD j 1 =\n      (π (ω.drop (j + 1)))⁻¹\n        * (Option.map (cs.simple) ω[j]?).getD 1\n        * π (ω.drop (j + 1)) := by\n  induction' ω with i ω ih generalizing j\n  · simp\n  · dsimp only [rightInvSeq]\n    rcases j with _ | j'\n    · simp [getD_cons_zero]\n    · simp only [getD_eq_getElem?_getD, get?_eq_getElem?] at ih\n      simp [getD_cons_succ, ih j']\n\n"}
{"name":"CoxeterSystem.getElem_rightInvSeq","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nω : List B\nj : Nat\nh : LT.lt j ω.length\n⊢ Eq (GetElem.getElem (cs.rightInvSeq ω) j ⋯) (HMul.hMul (HMul.hMul (Inv.inv (cs.wordProd (List.drop (HAdd.hAdd j 1) ω))) ((Option.map cs.simple (GetElem?.getElem? ω j)).getD 1)) (cs.wordProd (List.drop (HAdd.hAdd j 1) ω)))","decl":"lemma getElem_rightInvSeq (ω : List B) (j : ℕ) (h : j < ω.length) :\n    (ris ω)[j]'(by simp[h]) =\n    (π (ω.drop (j + 1)))⁻¹\n      * (Option.map (cs.simple) ω[j]?).getD 1\n      * π (ω.drop (j + 1)) := by\n  rw [← List.getD_eq_getElem (ris ω) 1, getD_rightInvSeq]\n\n"}
{"name":"CoxeterSystem.getD_leftInvSeq","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nω : List B\nj : Nat\n⊢ Eq ((cs.leftInvSeq ω).getD j 1) (HMul.hMul (HMul.hMul (cs.wordProd (List.take j ω)) ((Option.map cs.simple (GetElem?.getElem? ω j)).getD 1)) (Inv.inv (cs.wordProd (List.take j ω))))","decl":"theorem getD_leftInvSeq (ω : List B) (j : ℕ) :\n    (lis ω).getD j 1 =\n      π (ω.take j)\n        * (Option.map (cs.simple) ω[j]?).getD 1\n        * (π (ω.take j))⁻¹ := by\n  induction' ω with i ω ih generalizing j\n  · simp\n  · dsimp [leftInvSeq]\n    rcases j with _ | j'\n    · simp [getD_cons_zero]\n    · rw [getD_cons_succ]\n      rw [(by simp : 1 = ⇑(MulAut.conj (s i)) 1)]\n      rw [getD_map]\n      rw [ih j']\n      simp [← mul_assoc, wordProd_cons]\n\n"}
{"name":"CoxeterSystem.getElem_leftInvSeq","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nω : List B\nj : Nat\nh : LT.lt j ω.length\n⊢ Eq (GetElem.getElem (cs.leftInvSeq ω) j ⋯) (HMul.hMul (HMul.hMul (cs.wordProd (List.take j ω)) (cs.simple (GetElem.getElem ω j ⋯))) (Inv.inv (cs.wordProd (List.take j ω))))","decl":"lemma getElem_leftInvSeq (ω : List B) (j : ℕ) (h : j < ω.length) :\n    (lis ω)[j]'(by simp[h]) =\n    cs.wordProd (List.take j ω) * s ω[j] * (cs.wordProd (List.take j ω))⁻¹ := by\n  rw [← List.getD_eq_getElem (lis ω) 1, getD_leftInvSeq]\n  simp [h]\n\n"}
{"name":"CoxeterSystem.getD_rightInvSeq_mul_self","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nω : List B\nj : Nat\n⊢ Eq (HMul.hMul ((cs.rightInvSeq ω).getD j 1) ((cs.rightInvSeq ω).getD j 1)) 1","decl":"theorem getD_rightInvSeq_mul_self (ω : List B) (j : ℕ) :\n    ((ris ω).getD j 1) * ((ris ω).getD j 1) = 1 := by\n  simp_rw [getD_rightInvSeq, mul_assoc]\n  rcases em (j < ω.length) with hj | nhj\n  · rw [getElem?_eq_getElem hj]\n    simp [← mul_assoc]\n  · rw [getElem?_eq_none_iff.mpr (by omega)]\n    simp\n\n"}
{"name":"CoxeterSystem.getD_leftInvSeq_mul_self","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nω : List B\nj : Nat\n⊢ Eq (HMul.hMul ((cs.leftInvSeq ω).getD j 1) ((cs.leftInvSeq ω).getD j 1)) 1","decl":"theorem getD_leftInvSeq_mul_self (ω : List B) (j : ℕ) :\n    ((lis ω).getD j 1) * ((lis ω).getD j 1) = 1 := by\n  simp_rw [getD_leftInvSeq, mul_assoc]\n  rcases em (j < ω.length) with hj | nhj\n  · rw [getElem?_eq_getElem hj]\n    simp [← mul_assoc]\n  · rw [getElem?_eq_none_iff.mpr (by omega)]\n    simp\n\n"}
{"name":"CoxeterSystem.rightInvSeq_drop","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nω : List B\nj : Nat\n⊢ Eq (cs.rightInvSeq (List.drop j ω)) (List.drop j (cs.rightInvSeq ω))","decl":"theorem rightInvSeq_drop (ω : List B) (j : ℕ) :\n    ris (ω.drop j) = (ris ω).drop j := by\n  induction' j with j ih₁ generalizing ω\n  · simp\n  · induction' ω with k ω _\n    · simp\n    · rw [drop_succ_cons, ih₁ ω, rightInvSeq, drop_succ_cons]\n\n"}
{"name":"CoxeterSystem.leftInvSeq_take","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nω : List B\nj : Nat\n⊢ Eq (cs.leftInvSeq (List.take j ω)) (List.take j (cs.leftInvSeq ω))","decl":"theorem leftInvSeq_take (ω : List B) (j : ℕ) :\n    lis (ω.take j) = (lis ω).take j := by\n  simp only [leftInvSeq_eq_reverse_rightInvSeq_reverse]\n  rw [List.take_reverse]\n  nth_rw 1 [← List.reverse_reverse ω]\n  rw [List.take_reverse]\n  simp [rightInvSeq_drop]\n\n"}
{"name":"CoxeterSystem.isReflection_of_mem_rightInvSeq","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nω : List B\nt : W\nht : Membership.mem (cs.rightInvSeq ω) t\n⊢ cs.IsReflection t","decl":"theorem isReflection_of_mem_rightInvSeq (ω : List B) {t : W} (ht : t ∈ ris ω) :\n    cs.IsReflection t := by\n  induction' ω with i ω ih\n  · simp at ht\n  · dsimp [rightInvSeq] at ht\n    rcases ht with _ | ⟨_, mem⟩\n    · use (π ω)⁻¹, i\n      group\n    · exact ih mem\n\n"}
{"name":"CoxeterSystem.isReflection_of_mem_leftInvSeq","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nω : List B\nt : W\nht : Membership.mem (cs.leftInvSeq ω) t\n⊢ cs.IsReflection t","decl":"theorem isReflection_of_mem_leftInvSeq (ω : List B) {t : W} (ht : t ∈ lis ω) :\n    cs.IsReflection t := by\n  simp only [leftInvSeq_eq_reverse_rightInvSeq_reverse, mem_reverse] at ht\n  exact cs.isReflection_of_mem_rightInvSeq ω.reverse ht\n\n"}
{"name":"CoxeterSystem.wordProd_mul_getD_rightInvSeq","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nω : List B\nj : Nat\n⊢ Eq (HMul.hMul (cs.wordProd ω) ((cs.rightInvSeq ω).getD j 1)) (cs.wordProd (ω.eraseIdx j))","decl":"theorem wordProd_mul_getD_rightInvSeq (ω : List B) (j : ℕ) :\n    π ω * ((ris ω).getD j 1) = π (ω.eraseIdx j) := by\n  rw [getD_rightInvSeq, eraseIdx_eq_take_drop_succ]\n  nth_rw 1 [← take_append_drop (j + 1) ω]\n  rw [take_succ]\n  obtain lt | le := lt_or_le j ω.length\n  · simp only [get?_eq_getElem?, getElem?_eq_getElem lt, wordProd_append, wordProd_cons, mul_assoc]\n    simp\n  · simp only [get?_eq_getElem?, getElem?_eq_none le]\n    simp\n\n"}
{"name":"CoxeterSystem.getD_leftInvSeq_mul_wordProd","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nω : List B\nj : Nat\n⊢ Eq (HMul.hMul ((cs.leftInvSeq ω).getD j 1) (cs.wordProd ω)) (cs.wordProd (ω.eraseIdx j))","decl":"theorem getD_leftInvSeq_mul_wordProd (ω : List B) (j : ℕ) :\n    ((lis ω).getD j 1) * π ω = π (ω.eraseIdx j) := by\n  rw [getD_leftInvSeq, eraseIdx_eq_take_drop_succ]\n  nth_rw 4 [← take_append_drop (j + 1) ω]\n  rw [take_succ]\n  obtain lt | le := lt_or_le j ω.length\n  · simp only [get?_eq_getElem?, getElem?_eq_getElem lt, wordProd_append, wordProd_cons, mul_assoc]\n    simp\n  · simp only [get?_eq_getElem?, getElem?_eq_none le]\n    simp\n\n"}
{"name":"CoxeterSystem.isRightInversion_of_mem_rightInvSeq","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nω : List B\nhω : cs.IsReduced ω\nt : W\nht : Membership.mem (cs.rightInvSeq ω) t\n⊢ cs.IsRightInversion (cs.wordProd ω) t","decl":"theorem isRightInversion_of_mem_rightInvSeq {ω : List B} (hω : cs.IsReduced ω) {t : W}\n    (ht : t ∈ ris ω) : cs.IsRightInversion (π ω) t := by\n  constructor\n  · exact cs.isReflection_of_mem_rightInvSeq ω ht\n  · obtain ⟨j, hj, rfl⟩ := List.mem_iff_getElem.mp ht\n    rw [← List.getD_eq_getElem _ 1 hj, wordProd_mul_getD_rightInvSeq]\n    rw [cs.length_rightInvSeq] at hj\n    calc\n      ℓ (π (ω.eraseIdx j))\n      _ ≤ (ω.eraseIdx j).length   := cs.length_wordProd_le _\n      _ < ω.length                := by rw [← List.length_eraseIdx_add_one hj]; exact lt_add_one _\n      _ = ℓ (π ω)                 := hω.symm\n\n"}
{"name":"CoxeterSystem.isLeftInversion_of_mem_leftInvSeq","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nω : List B\nhω : cs.IsReduced ω\nt : W\nht : Membership.mem (cs.leftInvSeq ω) t\n⊢ cs.IsLeftInversion (cs.wordProd ω) t","decl":"theorem isLeftInversion_of_mem_leftInvSeq {ω : List B} (hω : cs.IsReduced ω) {t : W}\n    (ht : t ∈ lis ω) : cs.IsLeftInversion (π ω) t := by\n  constructor\n  · exact cs.isReflection_of_mem_leftInvSeq ω ht\n  · obtain ⟨j, hj, rfl⟩ := List.mem_iff_getElem.mp ht\n    rw [← List.getD_eq_getElem _ 1 hj, getD_leftInvSeq_mul_wordProd]\n    rw [cs.length_leftInvSeq] at hj\n    calc\n      ℓ (π (ω.eraseIdx j))\n      _ ≤ (ω.eraseIdx j).length   := cs.length_wordProd_le _\n      _ < ω.length                := by rw [← List.length_eraseIdx_add_one hj]; exact lt_add_one _\n      _ = ℓ (π ω)                 := hω.symm\n\n"}
{"name":"CoxeterSystem.prod_rightInvSeq","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nω : List B\n⊢ Eq (cs.rightInvSeq ω).prod (Inv.inv (cs.wordProd ω))","decl":"theorem prod_rightInvSeq (ω : List B) : prod (ris ω) = (π ω)⁻¹ := by\n  induction' ω with i ω ih\n  · simp\n  · simp [rightInvSeq, ih, wordProd_cons]\n\n"}
{"name":"CoxeterSystem.prod_leftInvSeq","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nω : List B\n⊢ Eq (cs.leftInvSeq ω).prod (Inv.inv (cs.wordProd ω))","decl":"theorem prod_leftInvSeq (ω : List B) : prod (lis ω) = (π ω)⁻¹ := by\n  simp only [leftInvSeq_eq_reverse_rightInvSeq_reverse, prod_reverse_noncomm, inv_inj]\n  have : List.map (fun x ↦ x⁻¹) (ris ω.reverse) = ris ω.reverse := calc\n    List.map (fun x ↦ x⁻¹) (ris ω.reverse)\n    _ = List.map id (ris ω.reverse)             := by\n        apply List.map_congr_left\n        intro t ht\n        exact (cs.isReflection_of_mem_rightInvSeq _ ht).inv\n    _ = ris ω.reverse                           := map_id _\n  rw [this]\n  nth_rw 2 [← reverse_reverse ω]\n  rw [wordProd_reverse]\n  exact cs.prod_rightInvSeq _\n\n"}
{"name":"CoxeterSystem.IsReduced.nodup_rightInvSeq","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nω : List B\nrω : cs.IsReduced ω\n⊢ (cs.rightInvSeq ω).Nodup","decl":"theorem IsReduced.nodup_rightInvSeq {ω : List B} (rω : cs.IsReduced ω) : List.Nodup (ris ω) := by\n  apply List.nodup_iff_getElem?_ne_getElem?.mpr\n  intro j j' j_lt_j' j'_lt_length (dup : (rightInvSeq cs ω)[j]? = (rightInvSeq cs ω)[j']?)\n  show False\n  replace j'_lt_length : j' < List.length ω := by simpa using j'_lt_length\n  rw [getElem?_eq_getElem (by simp; omega), getElem?_eq_getElem (by simp; omega)] at dup\n  apply Option.some_injective at dup\n  rw [← getD_eq_getElem _ 1, ← getD_eq_getElem _ 1] at dup\n  set! t := (ris ω).getD j 1 with h₁\n  set! t' := (ris (ω.eraseIdx j)).getD (j' - 1) 1 with h₂\n  have h₃ : t' = (ris ω).getD j' 1                    := by\n    rw [h₂, cs.getD_rightInvSeq, cs.getD_rightInvSeq,\n      (Nat.sub_add_cancel (by omega) : j' - 1 + 1 = j'), eraseIdx_eq_take_drop_succ,\n      drop_append_eq_append_drop, drop_of_length_le (by simp [j_lt_j'.le]), length_take,\n      drop_drop, nil_append, min_eq_left_of_lt (j_lt_j'.trans j'_lt_length), Nat.add_comm,\n      ← add_assoc, Nat.sub_add_cancel (by omega), mul_left_inj, mul_right_inj]\n    congr 2\n    show (List.take j ω ++ List.drop (j + 1) ω)[j' - 1]? = ω[j']?\n    rw [getElem?_append_right (by simp [Nat.le_sub_one_of_lt j_lt_j']), getElem?_drop]\n    congr\n    show j + 1 + (j' - 1 - List.length (List.take j ω)) = j'\n    rw [length_take]\n    omega\n  have h₄ : t * t' = 1                                := by\n    rw [h₁, h₃, dup]\n    exact cs.getD_rightInvSeq_mul_self _ _\n  have h₅ := calc\n    π ω   = π ω * t * t'                              := by rw [mul_assoc, h₄]; group\n    _     = (π (ω.eraseIdx j)) * t'                   :=\n        congrArg (· * t') (cs.wordProd_mul_getD_rightInvSeq _ _)\n    _     = π ((ω.eraseIdx j).eraseIdx (j' - 1))      :=\n        cs.wordProd_mul_getD_rightInvSeq _ _\n  have h₆ := calc\n    ω.length = ℓ (π ω)                                    := rω.symm\n    _        = ℓ (π ((ω.eraseIdx j).eraseIdx (j' - 1)))   := congrArg cs.length h₅\n    _        ≤ ((ω.eraseIdx j).eraseIdx (j' - 1)).length  := cs.length_wordProd_le _\n  have h₇ := add_le_add_right (add_le_add_right h₆ 1) 1\n  have h₈ : j' - 1 < List.length (eraseIdx ω j)           := by\n    apply (@Nat.add_lt_add_iff_right 1).mp\n    rw [Nat.sub_add_cancel (by omega)]\n    rw [length_eraseIdx_add_one (by omega)]\n    omega\n  rw [length_eraseIdx_add_one h₈] at h₇\n  rw [length_eraseIdx_add_one (by omega)] at h₇\n  omega\n\n"}
{"name":"CoxeterSystem.IsReduced.nodup_leftInvSeq","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nω : List B\nrω : cs.IsReduced ω\n⊢ (cs.leftInvSeq ω).Nodup","decl":"theorem IsReduced.nodup_leftInvSeq {ω : List B} (rω : cs.IsReduced ω) : List.Nodup (lis ω) := by\n  simp only [leftInvSeq_eq_reverse_rightInvSeq_reverse, nodup_reverse]\n  apply nodup_rightInvSeq\n  rwa [isReduced_reverse_iff]\n\n"}
{"name":"CoxeterSystem.getElem_succ_leftInvSeq_alternatingWord","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\ni j : B\np k : Nat\nh : LT.lt (HAdd.hAdd k 1) (HMul.hMul 2 p)\n⊢ Eq (GetElem.getElem (cs.leftInvSeq (CoxeterSystem.alternatingWord i j (HMul.hMul 2 p))) (HAdd.hAdd k 1) ⋯) ((MulAut.conj (cs.simple i)) (GetElem.getElem (cs.leftInvSeq (CoxeterSystem.alternatingWord j i (HMul.hMul 2 p))) k ⋯))","decl":"lemma getElem_succ_leftInvSeq_alternatingWord\n    (i j : B) (p k : ℕ) (h : k + 1 < 2 * p) :\n    (lis (alternatingWord i j (2 * p)))[k + 1]'(by simp; exact h) =\n    MulAut.conj (s i) ((lis (alternatingWord j i (2 * p)))[k]'(by simp; omega)) := by\n  rw [cs.getElem_leftInvSeq (alternatingWord i j (2 * p)) (k + 1) (by simp[h]),\n    cs.getElem_leftInvSeq (alternatingWord j i (2 * p)) k (by simp[h]; omega)]\n  simp only [MulAut.conj, listTake_succ_alternatingWord i j p k h, cs.wordProd_cons, mul_assoc,\n    mul_inv_rev, inv_simple, MonoidHom.coe_mk, OneHom.coe_mk, MulEquiv.coe_mk, Equiv.coe_fn_mk,\n    mul_right_inj, mul_left_inj]\n  rw [getElem_alternatingWord_swapIndices i j (2 * p) k]\n  omega\n\n"}
{"name":"CoxeterSystem.getElem_leftInvSeq_alternatingWord","module":"Mathlib.GroupTheory.Coxeter.Inversion","initialProofState":"B : Type u_1\nW : Type u_2\ninst✝ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\ni j : B\np k : Nat\nh : LT.lt k (HMul.hMul 2 p)\n⊢ Eq (GetElem.getElem (cs.leftInvSeq (CoxeterSystem.alternatingWord i j (HMul.hMul 2 p))) k ⋯) (cs.wordProd (CoxeterSystem.alternatingWord j i (HAdd.hAdd (HMul.hMul 2 k) 1)))","decl":"theorem getElem_leftInvSeq_alternatingWord\n    (i j : B) (p k : ℕ) (h : k < 2 * p) :\n    (lis (alternatingWord i j (2 * p)))[k]'(by simp; omega) =\n    π alternatingWord j i (2 * k + 1) := by\n  revert i j\n  induction k with\n  | zero =>\n    intro i j\n    simp only [CoxeterSystem.getElem_leftInvSeq cs (alternatingWord i j (2 * p)) 0 (by simp [h]),\n      take_zero, wordProd_nil, one_mul, inv_one, mul_one, alternatingWord, concat_eq_append,\n      nil_append, wordProd_singleton]\n    apply congr_arg\n    simp only [getElem_alternatingWord i j (2 * p) 0 (by simp [h]), add_zero, even_two,\n      Even.mul_right, ↓reduceIte]\n  | succ k hk =>\n    intro i j\n    simp only [getElem_succ_leftInvSeq_alternatingWord cs i j p k h, hk (by omega),\n      MulAut.conj_apply, inv_simple, alternatingWord_succ' j i, even_two, Even.mul_right,\n      ↓reduceIte, wordProd_cons]\n    rw [(by ring: 2 * (k + 1) = 2 * k + 1 + 1), alternatingWord_succ j i, wordProd_concat]\n    simp [mul_assoc]\n\n"}
