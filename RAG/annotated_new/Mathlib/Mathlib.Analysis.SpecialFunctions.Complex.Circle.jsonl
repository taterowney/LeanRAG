{"name":"Circle.injective_arg","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"⊢ Function.Injective fun z => (↑z).arg","decl":"theorem injective_arg : Injective fun z : Circle => arg z := fun z w h =>\n  Subtype.ext <| ext_abs_arg (z.abs_coe.trans w.abs_coe.symm) h\n\n"}
{"name":"Circle.arg_eq_arg","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"z w : Circle\n⊢ Iff (Eq (↑z).arg (↑w).arg) (Eq z w)","decl":"@[simp]\ntheorem arg_eq_arg {z w : Circle} : arg z = arg w ↔ z = w :=\n  injective_arg.eq_iff\n\n"}
{"name":"Circle.arg_exp","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"x : Real\nh₁ : LT.lt (Neg.neg Real.pi) x\nh₂ : LE.le x Real.pi\n⊢ Eq (↑(Circle.exp x)).arg x","decl":"theorem arg_exp {x : ℝ} (h₁ : -π < x) (h₂ : x ≤ π) : arg (exp x) = x := by\n  rw [coe_exp, exp_mul_I, arg_cos_add_sin_mul_I ⟨h₁, h₂⟩]\n\n"}
{"name":"Circle.exp_arg","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"z : Circle\n⊢ Eq (Circle.exp (↑z).arg) z","decl":"@[simp]\ntheorem exp_arg (z : Circle) : exp (arg z) = z :=\n  injective_arg <| arg_exp (neg_pi_lt_arg _) (arg_le_pi _)\n\n"}
{"name":"Circle.argPartialEquiv_apply","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"⊢ Eq (↑Circle.argPartialEquiv) (Function.comp Complex.arg Subtype.val)","decl":"/-- `Complex.arg ∘ (↑)` and `expMapCircle` define a partial equivalence between `circle` and `ℝ`\nwith `source = Set.univ` and `target = Set.Ioc (-π) π`. -/\n@[simps (config := .asFn)]\nnoncomputable def argPartialEquiv : PartialEquiv Circle ℝ where\n  toFun := arg ∘ (↑)\n  invFun := exp\n  source := univ\n  target := Ioc (-π) π\n  map_source' _ _ := ⟨neg_pi_lt_arg _, arg_le_pi _⟩\n  map_target' := mapsTo_univ _ _\n  left_inv' z _ := exp_arg z\n  right_inv' _ hx := arg_exp hx.1 hx.2\n\n"}
{"name":"Circle.argPartialEquiv_symm_apply","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"⊢ Eq ↑Circle.argPartialEquiv.symm ⇑Circle.exp","decl":"/-- `Complex.arg ∘ (↑)` and `expMapCircle` define a partial equivalence between `circle` and `ℝ`\nwith `source = Set.univ` and `target = Set.Ioc (-π) π`. -/\n@[simps (config := .asFn)]\nnoncomputable def argPartialEquiv : PartialEquiv Circle ℝ where\n  toFun := arg ∘ (↑)\n  invFun := exp\n  source := univ\n  target := Ioc (-π) π\n  map_source' _ _ := ⟨neg_pi_lt_arg _, arg_le_pi _⟩\n  map_target' := mapsTo_univ _ _\n  left_inv' z _ := exp_arg z\n  right_inv' _ hx := arg_exp hx.1 hx.2\n\n"}
{"name":"Circle.argPartialEquiv_source","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"⊢ Eq Circle.argPartialEquiv.source Set.univ","decl":"/-- `Complex.arg ∘ (↑)` and `expMapCircle` define a partial equivalence between `circle` and `ℝ`\nwith `source = Set.univ` and `target = Set.Ioc (-π) π`. -/\n@[simps (config := .asFn)]\nnoncomputable def argPartialEquiv : PartialEquiv Circle ℝ where\n  toFun := arg ∘ (↑)\n  invFun := exp\n  source := univ\n  target := Ioc (-π) π\n  map_source' _ _ := ⟨neg_pi_lt_arg _, arg_le_pi _⟩\n  map_target' := mapsTo_univ _ _\n  left_inv' z _ := exp_arg z\n  right_inv' _ hx := arg_exp hx.1 hx.2\n\n"}
{"name":"Circle.argPartialEquiv_target","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"⊢ Eq Circle.argPartialEquiv.target (Set.Ioc (Neg.neg Real.pi) Real.pi)","decl":"/-- `Complex.arg ∘ (↑)` and `expMapCircle` define a partial equivalence between `circle` and `ℝ`\nwith `source = Set.univ` and `target = Set.Ioc (-π) π`. -/\n@[simps (config := .asFn)]\nnoncomputable def argPartialEquiv : PartialEquiv Circle ℝ where\n  toFun := arg ∘ (↑)\n  invFun := exp\n  source := univ\n  target := Ioc (-π) π\n  map_source' _ _ := ⟨neg_pi_lt_arg _, arg_le_pi _⟩\n  map_target' := mapsTo_univ _ _\n  left_inv' z _ := exp_arg z\n  right_inv' _ hx := arg_exp hx.1 hx.2\n\n"}
{"name":"Circle.argEquiv_apply_coe","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"z : Circle\n⊢ Eq (↑(Circle.argEquiv z)) (↑z).arg","decl":"/-- `Complex.arg` and `expMapCircle` define an equivalence between `circle` and `(-π, π]`. -/\n@[simps (config := .asFn)]\nnoncomputable def argEquiv : Circle ≃ Ioc (-π) π where\n  toFun z := ⟨arg z, neg_pi_lt_arg _, arg_le_pi _⟩\n  invFun := exp ∘ (↑)\n  left_inv _ := argPartialEquiv.left_inv trivial\n  right_inv x := Subtype.ext <| argPartialEquiv.right_inv x.2\n\n"}
{"name":"Circle.argEquiv_symm_apply","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"⊢ Eq (⇑Circle.argEquiv.symm) (Function.comp (⇑Circle.exp) Subtype.val)","decl":"/-- `Complex.arg` and `expMapCircle` define an equivalence between `circle` and `(-π, π]`. -/\n@[simps (config := .asFn)]\nnoncomputable def argEquiv : Circle ≃ Ioc (-π) π where\n  toFun z := ⟨arg z, neg_pi_lt_arg _, arg_le_pi _⟩\n  invFun := exp ∘ (↑)\n  left_inv _ := argPartialEquiv.left_inv trivial\n  right_inv x := Subtype.ext <| argPartialEquiv.right_inv x.2\n\n"}
{"name":"Circle.leftInverse_exp_arg","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"⊢ Function.LeftInverse (⇑Circle.exp) (Function.comp Complex.arg Subtype.val)","decl":"lemma leftInverse_exp_arg : LeftInverse exp (arg ∘ (↑)) := exp_arg\n"}
{"name":"Circle.invOn_arg_exp","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"⊢ Set.InvOn (Function.comp Complex.arg Subtype.val) (⇑Circle.exp) (Set.Ioc (Neg.neg Real.pi) Real.pi) Set.univ","decl":"lemma invOn_arg_exp : InvOn (arg ∘ (↑)) exp (Ioc (-π) π) univ := argPartialEquiv.symm.invOn\n"}
{"name":"Circle.surjOn_exp_neg_pi_pi","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"⊢ Set.SurjOn (⇑Circle.exp) (Set.Ioc (Neg.neg Real.pi) Real.pi) Set.univ","decl":"lemma surjOn_exp_neg_pi_pi : SurjOn exp (Ioc (-π) π) univ := argPartialEquiv.symm.surjOn\n\n"}
{"name":"Circle.exp_eq_exp","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"x y : Real\n⊢ Iff (Eq (Circle.exp x) (Circle.exp y)) (Exists fun m => Eq x (HAdd.hAdd y (HMul.hMul (↑m) (HMul.hMul 2 Real.pi))))","decl":"lemma exp_eq_exp {x y : ℝ} : exp x = exp y ↔ ∃ m : ℤ, x = y + m * (2 * π) := by\n  rw [Subtype.ext_iff, coe_exp, coe_exp, exp_eq_exp_iff_exists_int]\n  refine exists_congr fun n => ?_\n  rw [← mul_assoc, ← add_mul, mul_left_inj' I_ne_zero]\n  norm_cast\n\n"}
{"name":"Circle.periodic_exp","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"⊢ Function.Periodic (⇑Circle.exp) (HMul.hMul 2 Real.pi)","decl":"lemma periodic_exp : Periodic exp (2 * π) := fun z ↦ exp_eq_exp.2 ⟨1, by rw [Int.cast_one, one_mul]⟩\n\n"}
{"name":"Circle.exp_two_pi","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"⊢ Eq (Circle.exp (HMul.hMul 2 Real.pi)) 1","decl":"@[simp] lemma exp_two_pi : exp (2 * π) = 1 := periodic_exp.eq.trans exp_zero\n\n"}
{"name":"Circle.exp_int_mul_two_pi","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"n : Int\n⊢ Eq (Circle.exp (HMul.hMul (↑n) (HMul.hMul 2 Real.pi))) 1","decl":"lemma exp_int_mul_two_pi (n : ℤ) : exp (n * (2 * π)) = 1 :=\n  ext <| by simpa [mul_assoc] using Complex.exp_int_mul_two_pi_mul_I n\n\n"}
{"name":"Circle.exp_two_pi_mul_int","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"n : Int\n⊢ Eq (Circle.exp (HMul.hMul (HMul.hMul 2 Real.pi) ↑n)) 1","decl":"lemma exp_two_pi_mul_int (n : ℤ) : exp (2 * π * n) = 1 := by\n  simpa only [mul_comm] using exp_int_mul_two_pi n\n\n"}
{"name":"Circle.exp_eq_one","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"r : Real\n⊢ Iff (Eq (Circle.exp r) 1) (Exists fun n => Eq r (HMul.hMul (↑n) (HMul.hMul 2 Real.pi)))","decl":"lemma exp_eq_one {r : ℝ} : exp r = 1 ↔ ∃ n : ℤ, r = n * (2 * π) := by\n  simp [Circle.ext_iff, Complex.exp_eq_one_iff, ← mul_assoc, Complex.I_ne_zero,\n    ← Complex.ofReal_inj]\n\n"}
{"name":"Circle.exp_inj","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"r s : Real\n⊢ Iff (Eq (Circle.exp r) (Circle.exp s)) (AddCommGroup.ModEq (HMul.hMul 2 Real.pi) r s)","decl":"lemma exp_inj {r s : ℝ} : exp r = exp s ↔ r ≡ s [PMOD (2 * π)] := by\n  simp [AddCommGroup.ModEq, ← exp_eq_one, div_eq_one, eq_comm (a := exp r)]\n\n"}
{"name":"Circle.exp_sub_two_pi","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"x : Real\n⊢ Eq (Circle.exp (HSub.hSub x (HMul.hMul 2 Real.pi))) (Circle.exp x)","decl":"lemma exp_sub_two_pi (x : ℝ) : exp (x - 2 * π) = exp x := periodic_exp.sub_eq x\n"}
{"name":"Circle.exp_add_two_pi","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"x : Real\n⊢ Eq (Circle.exp (HAdd.hAdd x (HMul.hMul 2 Real.pi))) (Circle.exp x)","decl":"lemma exp_add_two_pi (x : ℝ) : exp (x + 2 * π) = exp x := periodic_exp x\n\n"}
{"name":"Real.Angle.toCircle_coe","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"x : Real\n⊢ Eq (↑x).toCircle (Circle.exp x)","decl":"@[simp] lemma toCircle_coe (x : ℝ) : toCircle x = .exp x := rfl\n\n"}
{"name":"Real.Angle.coe_toCircle","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"θ : Real.Angle\n⊢ Eq (↑θ.toCircle) (HAdd.hAdd (↑θ.cos) (HMul.hMul (↑θ.sin) Complex.I))","decl":"lemma coe_toCircle (θ : Angle) : (θ.toCircle : ℂ) = θ.cos + θ.sin * I := by\n  induction θ using Real.Angle.induction_on\n  simp [exp_mul_I]\n\n"}
{"name":"Real.Angle.toCircle_zero","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"⊢ Eq (Real.Angle.toCircle 0) 1","decl":"@[simp] lemma toCircle_zero : toCircle 0 = 1 := by rw [← coe_zero, toCircle_coe, Circle.exp_zero]\n\n"}
{"name":"Real.Angle.toCircle_neg","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"θ : Real.Angle\n⊢ Eq (Neg.neg θ).toCircle (Inv.inv θ.toCircle)","decl":"@[simp] lemma toCircle_neg (θ : Angle) : toCircle (-θ) = (toCircle θ)⁻¹ := by\n  induction θ using Real.Angle.induction_on\n  simp_rw [← coe_neg, toCircle_coe, Circle.exp_neg]\n\n"}
{"name":"Real.Angle.toCircle_add","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"θ₁ θ₂ : Real.Angle\n⊢ Eq (HAdd.hAdd θ₁ θ₂).toCircle (HMul.hMul θ₁.toCircle θ₂.toCircle)","decl":"@[simp] lemma toCircle_add (θ₁ θ₂ : Angle) : toCircle (θ₁ + θ₂) = toCircle θ₁ * toCircle θ₂ := by\n  induction θ₁ using Real.Angle.induction_on\n  induction θ₂ using Real.Angle.induction_on\n  exact Circle.exp_add _ _\n\n"}
{"name":"Real.Angle.arg_toCircle","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"θ : Real.Angle\n⊢ Eq (↑(↑θ.toCircle).arg) θ","decl":"@[simp] lemma arg_toCircle (θ : Real.Angle) : (arg θ.toCircle : Angle) = θ := by\n  induction θ using Real.Angle.induction_on\n  rw [toCircle_coe, Circle.coe_exp, exp_mul_I, ← ofReal_cos, ← ofReal_sin, ←\n    Real.Angle.cos_coe, ← Real.Angle.sin_coe, arg_cos_add_sin_mul_I_coe_angle]\n\n"}
{"name":"AddCircle.scaled_exp_map_periodic","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"T : Real\n⊢ Function.Periodic (fun x => Circle.exp (HMul.hMul (HDiv.hDiv (HMul.hMul 2 Real.pi) T) x)) T","decl":"theorem scaled_exp_map_periodic : Function.Periodic (fun x => Circle.exp (2 * π / T * x)) T := by\n  -- The case T = 0 is not interesting, but it is true, so we prove it to save hypotheses\n  rcases eq_or_ne T 0 with (rfl | hT)\n  · intro x; simp\n  · intro x; simp_rw [mul_add]; rw [div_mul_cancel₀ _ hT, Circle.periodic_exp]\n\n"}
{"name":"AddCircle.toCircle_apply_mk","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"T x : Real\n⊢ Eq (AddCircle.toCircle ↑x) (Circle.exp (HMul.hMul (HDiv.hDiv (HMul.hMul 2 Real.pi) T) x))","decl":"theorem toCircle_apply_mk (x : ℝ) : @toCircle T x = Circle.exp (2 * π / T * x) :=\n  rfl\n\n"}
{"name":"AddCircle.toCircle_add","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"T : Real\nx y : AddCircle T\n⊢ Eq (HAdd.hAdd x y).toCircle (HMul.hMul x.toCircle y.toCircle)","decl":"theorem toCircle_add (x : AddCircle T) (y : AddCircle T) :\n    @toCircle T (x + y) = toCircle x * toCircle y := by\n  induction x using QuotientAddGroup.induction_on\n  induction y using QuotientAddGroup.induction_on\n  simp_rw [← coe_add, toCircle_apply_mk, mul_add, Circle.exp_add]\n\n"}
{"name":"AddCircle.toCircle_zero","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"T : Real\n⊢ Eq (AddCircle.toCircle 0) 1","decl":"@[simp] lemma toCircle_zero : toCircle (0 : AddCircle T) = 1 := by\n  rw [← QuotientAddGroup.mk_zero, toCircle_apply_mk, mul_zero, Circle.exp_zero]\n\n"}
{"name":"AddCircle.continuous_toCircle","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"T : Real\n⊢ Continuous AddCircle.toCircle","decl":"theorem continuous_toCircle : Continuous (@toCircle T) :=\n  continuous_coinduced_dom.mpr (Circle.exp.continuous.comp <| continuous_const.mul continuous_id')\n\n"}
{"name":"AddCircle.injective_toCircle","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"T : Real\nhT : Ne T 0\n⊢ Function.Injective AddCircle.toCircle","decl":"theorem injective_toCircle (hT : T ≠ 0) : Function.Injective (@toCircle T) := by\n  intro a b h\n  induction a using QuotientAddGroup.induction_on\n  induction b using QuotientAddGroup.induction_on\n  simp_rw [toCircle_apply_mk] at h\n  obtain ⟨m, hm⟩ := Circle.exp_eq_exp.mp h.symm\n  rw [QuotientAddGroup.eq]; simp_rw [AddSubgroup.mem_zmultiples_iff, zsmul_eq_mul]\n  use m\n  field_simp at hm\n  rw [← mul_right_inj' Real.two_pi_pos.ne']\n  linarith\n\n"}
{"name":"AddCircle.homeomorphCircle'_symm_apply","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"x : Circle\n⊢ Eq (AddCircle.homeomorphCircle'.symm x) ↑(↑x).arg","decl":"/-- The homeomorphism between `AddCircle (2 * π)` and `Circle`. -/\n@[simps] noncomputable def homeomorphCircle' : AddCircle (2 * π) ≃ₜ Circle where\n  toFun := Angle.toCircle\n  invFun := fun x ↦ arg x\n  left_inv := Angle.arg_toCircle\n  right_inv := Circle.exp_arg\n  continuous_toFun := continuous_coinduced_dom.mpr Circle.exp.continuous\n  continuous_invFun := by\n    rw [continuous_iff_continuousAt]\n    intro x\n    exact (continuousAt_arg_coe_angle x.coe_ne_zero).comp continuousAt_subtype_val\n\n"}
{"name":"AddCircle.homeomorphCircle'_apply","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"θ : Real.Angle\n⊢ Eq (AddCircle.homeomorphCircle' θ) θ.toCircle","decl":"/-- The homeomorphism between `AddCircle (2 * π)` and `Circle`. -/\n@[simps] noncomputable def homeomorphCircle' : AddCircle (2 * π) ≃ₜ Circle where\n  toFun := Angle.toCircle\n  invFun := fun x ↦ arg x\n  left_inv := Angle.arg_toCircle\n  right_inv := Circle.exp_arg\n  continuous_toFun := continuous_coinduced_dom.mpr Circle.exp.continuous\n  continuous_invFun := by\n    rw [continuous_iff_continuousAt]\n    intro x\n    exact (continuousAt_arg_coe_angle x.coe_ne_zero).comp continuousAt_subtype_val\n\n"}
{"name":"AddCircle.homeomorphCircle'_apply_mk","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"x : Real\n⊢ Eq (AddCircle.homeomorphCircle' ↑x) (Circle.exp x)","decl":"theorem homeomorphCircle'_apply_mk (x : ℝ) : homeomorphCircle' x = Circle.exp x := rfl\n\n"}
{"name":"AddCircle.homeomorphCircle_apply","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"T : Real\nhT : Ne T 0\nx : AddCircle T\n⊢ Eq ((AddCircle.homeomorphCircle hT) x) x.toCircle","decl":"theorem homeomorphCircle_apply (hT : T ≠ 0) (x : AddCircle T) :\n    homeomorphCircle hT x = toCircle x := by\n  induction' x using QuotientAddGroup.induction_on with x\n  rw [homeomorphCircle, Homeomorph.trans_apply,\n    homeomorphAddCircle_apply_mk, homeomorphCircle'_apply_mk, toCircle_apply_mk]\n  ring_nf\n\n"}
{"name":"isLocalHomeomorph_circleExp","module":"Mathlib.Analysis.SpecialFunctions.Complex.Circle","initialProofState":"⊢ IsLocalHomeomorph ⇑Circle.exp","decl":"lemma isLocalHomeomorph_circleExp : IsLocalHomeomorph Circle.exp := by\n  have : Fact (0 < 2 * π) := ⟨by positivity⟩\n  exact homeomorphCircle'.isLocalHomeomorph.comp (isLocalHomeomorph_coe (2 * π))\n"}
