{"name":"IsInvariantSubfield.smul_mem","module":"Mathlib.FieldTheory.Fixed","initialProofState":"M : Type u\ninst✝² : Monoid M\nF : Type v\ninst✝¹ : Field F\ninst✝ : MulSemiringAction M F\nS : Subfield F\nself : IsInvariantSubfield M S\nm : M\nx : F\na✝ : Membership.mem S x\n⊢ Membership.mem S (HSMul.hSMul m x)","decl":"/-- A typeclass for subrings invariant under a `MulSemiringAction`. -/\nclass IsInvariantSubfield (S : Subfield F) : Prop where\n  smul_mem : ∀ (m : M) {x : F}, x ∈ S → m • x ∈ S\n\n"}
{"name":"instIsInvariantSubringOfIsInvariantSubfield","module":"Mathlib.FieldTheory.Fixed","initialProofState":"M : Type u\ninst✝³ : Monoid M\nF : Type v\ninst✝² : Field F\ninst✝¹ : MulSemiringAction M F\nS : Subfield F\ninst✝ : IsInvariantSubfield M S\n⊢ IsInvariantSubring M S.toSubring","decl":"instance [IsInvariantSubfield M S] : IsInvariantSubring M S.toSubring where\n  smul_mem := IsInvariantSubfield.smul_mem\n\n"}
{"name":"FixedPoints.instIsInvariantSubfieldSubfield","module":"Mathlib.FieldTheory.Fixed","initialProofState":"M : Type u\ninst✝² : Monoid M\nF : Type v\ninst✝¹ : Field F\ninst✝ : MulSemiringAction M F\n⊢ IsInvariantSubfield M (FixedPoints.subfield M F)","decl":"instance : IsInvariantSubfield M (FixedPoints.subfield M F) where\n  smul_mem g x hx g' := by rw [hx, hx]\n\n"}
{"name":"FixedPoints.instSMulCommClassSubtypeMemSubfieldSubfield","module":"Mathlib.FieldTheory.Fixed","initialProofState":"M : Type u\ninst✝² : Monoid M\nF : Type v\ninst✝¹ : Field F\ninst✝ : MulSemiringAction M F\n⊢ SMulCommClass M (Subtype fun x => Membership.mem (FixedPoints.subfield M F) x) F","decl":"instance : SMulCommClass M (FixedPoints.subfield M F) F where\n  smul_comm m f f' := show m • (↑f * f') = f * m • f' by rw [smul_mul', f.prop m]\n\n"}
{"name":"FixedPoints.smulCommClass'","module":"Mathlib.FieldTheory.Fixed","initialProofState":"M : Type u\ninst✝² : Monoid M\nF : Type v\ninst✝¹ : Field F\ninst✝ : MulSemiringAction M F\n⊢ SMulCommClass (Subtype fun x => Membership.mem (FixedPoints.subfield M F) x) M F","decl":"instance smulCommClass' : SMulCommClass (FixedPoints.subfield M F) M F :=\n  SMulCommClass.symm _ _ _\n\n"}
{"name":"FixedPoints.smul","module":"Mathlib.FieldTheory.Fixed","initialProofState":"M : Type u\ninst✝² : Monoid M\nF : Type v\ninst✝¹ : Field F\ninst✝ : MulSemiringAction M F\nm : M\nx : Subtype fun x => Membership.mem (FixedPoints.subfield M F) x\n⊢ Eq (HSMul.hSMul m x) x","decl":"@[simp]\ntheorem smul (m : M) (x : FixedPoints.subfield M F) : m • x = x :=\n  Subtype.eq <| x.2 m\n\n-- Why is this so slow?\n"}
{"name":"FixedPoints.smul_polynomial","module":"Mathlib.FieldTheory.Fixed","initialProofState":"M : Type u\ninst✝² : Monoid M\nF : Type v\ninst✝¹ : Field F\ninst✝ : MulSemiringAction M F\nm : M\np : Polynomial (Subtype fun x => Membership.mem (FixedPoints.subfield M F) x)\n⊢ Eq (HSMul.hSMul m p) p","decl":"@[simp]\ntheorem smul_polynomial (m : M) (p : Polynomial (FixedPoints.subfield M F)) : m • p = p :=\n  Polynomial.induction_on p (fun x => by rw [Polynomial.smul_C, smul])\n    (fun p q ihp ihq => by rw [smul_add, ihp, ihq]) fun n x _ => by\n    rw [smul_mul', Polynomial.smul_C, smul, smul_pow', Polynomial.smul_X]\n\n"}
{"name":"FixedPoints.coe_algebraMap","module":"Mathlib.FieldTheory.Fixed","initialProofState":"M : Type u\ninst✝² : Monoid M\nF : Type v\ninst✝¹ : Field F\ninst✝ : MulSemiringAction M F\n⊢ Eq (algebraMap (Subtype fun x => Membership.mem (FixedPoints.subfield M F) x) F) (FixedPoints.subfield M F).subtype","decl":"theorem coe_algebraMap :\n    algebraMap (FixedPoints.subfield M F) F = Subfield.subtype (FixedPoints.subfield M F) :=\n  rfl\n\n"}
{"name":"FixedPoints.linearIndependent_smul_of_linearIndependent","module":"Mathlib.FieldTheory.Fixed","initialProofState":"G : Type u\ninst✝² : Group G\nF : Type v\ninst✝¹ : Field F\ninst✝ : MulSemiringAction G F\ns : Finset F\na✝ : LinearIndependent (Subtype fun x => Membership.mem (FixedPoints.subfield G F) x) fun i => ↑i\n⊢ LinearIndependent F fun i => (MulAction.toFun G F) ↑i","decl":"theorem linearIndependent_smul_of_linearIndependent {s : Finset F} :\n    (LinearIndependent (FixedPoints.subfield G F) fun i : (s : Set F) => (i : F)) →\n      LinearIndependent F fun i : (s : Set F) => MulAction.toFun G F i := by\n  classical\n  have : IsEmpty ((∅ : Finset F) : Set F) := by simp\n  refine Finset.induction_on s (fun _ => linearIndependent_empty_type) fun a s has ih hs => ?_\n  rw [coe_insert] at hs ⊢\n  rw [linearIndependent_insert (mt mem_coe.1 has)] at hs\n  rw [linearIndependent_insert' (mt mem_coe.1 has)]; refine ⟨ih hs.1, fun ha => ?_⟩\n  rw [Finsupp.mem_span_image_iff_linearCombination] at ha; rcases ha with ⟨l, hl, hla⟩\n  rw [Finsupp.linearCombination_apply_of_mem_supported F hl] at hla\n  suffices ∀ i ∈ s, l i ∈ FixedPoints.subfield G F by\n    replace hla := (sum_apply _ _ fun i => l i • toFun G F i).symm.trans (congr_fun hla 1)\n    simp_rw [Pi.smul_apply, toFun_apply, one_smul] at hla\n    refine hs.2 (hla ▸ Submodule.sum_mem _ fun c hcs => ?_)\n    change (⟨l c, this c hcs⟩ : FixedPoints.subfield G F) • c ∈ _\n    exact Submodule.smul_mem _ _ (Submodule.subset_span <| mem_coe.2 hcs)\n  intro i his g\n  refine\n    eq_of_sub_eq_zero\n      (linearIndependent_iff'.1 (ih hs.1) s.attach (fun i => g • l i - l i) ?_ ⟨i, his⟩\n          (mem_attach _ _) :\n        _)\n  refine (sum_attach s fun i ↦ (g • l i - l i) • MulAction.toFun G F i).trans ?_\n  ext g'; dsimp only\n  conv_lhs =>\n    rw [sum_apply]\n    congr\n    · skip\n    · ext\n      rw [Pi.smul_apply, sub_smul, smul_eq_mul]\n  rw [sum_sub_distrib, Pi.zero_apply, sub_eq_zero]\n  conv_lhs =>\n    congr\n    · skip\n    · ext x\n      rw [toFun_apply, ← mul_inv_cancel_left g g', mul_smul, ← smul_mul', ← toFun_apply _ x]\n  show\n    (∑ x ∈ s, g • (fun y => l y • MulAction.toFun G F y) x (g⁻¹ * g')) =\n      ∑ x ∈ s, (fun y => l y • MulAction.toFun G F y) x g'\n  rw [← smul_sum, ← sum_apply _ _ fun y => l y • toFun G F y, ←\n    sum_apply _ _ fun y => l y • toFun G F y]\n  rw [hla, toFun_apply, toFun_apply, smul_smul, mul_inv_cancel_left]\n\n"}
{"name":"FixedPoints.minpoly.monic","module":"Mathlib.FieldTheory.Fixed","initialProofState":"G : Type u\ninst✝³ : Group G\nF : Type v\ninst✝² : Field F\ninst✝¹ : MulSemiringAction G F\ninst✝ : Fintype G\nx : F\n⊢ (FixedPoints.minpoly G F x).Monic","decl":"theorem monic : (minpoly G F x).Monic := by\n  simp only [minpoly]\n  rw [Polynomial.monic_toSubring]\n  exact prodXSubSMul.monic G F x\n\n"}
{"name":"FixedPoints.minpoly.eval₂","module":"Mathlib.FieldTheory.Fixed","initialProofState":"G : Type u\ninst✝³ : Group G\nF : Type v\ninst✝² : Field F\ninst✝¹ : MulSemiringAction G F\ninst✝ : Fintype G\nx : F\n⊢ Eq (Polynomial.eval₂ (FixedPoints.subfield G F).subtype x (FixedPoints.minpoly G F x)) 0","decl":"theorem eval₂ :\n    Polynomial.eval₂ (Subring.subtype <| (FixedPoints.subfield G F).toSubring) x (minpoly G F x) =\n      0 := by\n  rw [← prodXSubSMul.eval G F x, Polynomial.eval₂_eq_eval_map]\n  simp only [minpoly, Polynomial.map_toSubring]\n\n"}
{"name":"FixedPoints.minpoly.eval₂'","module":"Mathlib.FieldTheory.Fixed","initialProofState":"G : Type u\ninst✝³ : Group G\nF : Type v\ninst✝² : Field F\ninst✝¹ : MulSemiringAction G F\ninst✝ : Fintype G\nx : F\n⊢ Eq (Polynomial.eval₂ (FixedPoints.subfield G F).subtype x (FixedPoints.minpoly G F x)) 0","decl":"theorem eval₂' :\n    Polynomial.eval₂ (Subfield.subtype <| FixedPoints.subfield G F) x (minpoly G F x) = 0 :=\n  eval₂ G F x\n\n"}
{"name":"FixedPoints.minpoly.ne_one","module":"Mathlib.FieldTheory.Fixed","initialProofState":"G : Type u\ninst✝³ : Group G\nF : Type v\ninst✝² : Field F\ninst✝¹ : MulSemiringAction G F\ninst✝ : Fintype G\nx : F\n⊢ Ne (FixedPoints.minpoly G F x) 1","decl":"theorem ne_one : minpoly G F x ≠ (1 : Polynomial (FixedPoints.subfield G F)) := fun H =>\n  have := eval₂ G F x\n  (one_ne_zero : (1 : F) ≠ 0) <| by rwa [H, Polynomial.eval₂_one] at this\n\n"}
{"name":"FixedPoints.minpoly.of_eval₂","module":"Mathlib.FieldTheory.Fixed","initialProofState":"G : Type u\ninst✝³ : Group G\nF : Type v\ninst✝² : Field F\ninst✝¹ : MulSemiringAction G F\ninst✝ : Fintype G\nx : F\nf : Polynomial (Subtype fun x => Membership.mem (FixedPoints.subfield G F) x)\nhf : Eq (Polynomial.eval₂ (FixedPoints.subfield G F).subtype x f) 0\n⊢ Dvd.dvd (FixedPoints.minpoly G F x) f","decl":"theorem of_eval₂ (f : Polynomial (FixedPoints.subfield G F))\n    (hf : Polynomial.eval₂ (Subfield.subtype <| FixedPoints.subfield G F) x f = 0) :\n    minpoly G F x ∣ f := by\n  classical\n-- Porting note: the two `have` below were not needed.\n  have : (subfield G F).subtype = (subfield G F).toSubring.subtype := rfl\n  have h : Polynomial.map (MulSemiringActionHom.toRingHom (IsInvariantSubring.subtypeHom G\n    (subfield G F).toSubring)) f = Polynomial.map\n    ((IsInvariantSubring.subtypeHom G (subfield G F).toSubring)) f := rfl\n  rw [← Polynomial.map_dvd_map' (Subfield.subtype <| FixedPoints.subfield G F), minpoly, this,\n    Polynomial.map_toSubring _ _, prodXSubSMul]\n  refine\n    Fintype.prod_dvd_of_coprime\n      (Polynomial.pairwise_coprime_X_sub_C <| MulAction.injective_ofQuotientStabilizer G x) fun y =>\n      QuotientGroup.induction_on y fun g => ?_\n  rw [Polynomial.dvd_iff_isRoot, Polynomial.IsRoot.def, MulAction.ofQuotientStabilizer_mk,\n    Polynomial.eval_smul', ← this, ← Subfield.toSubring_subtype_eq_subtype, ←\n    IsInvariantSubring.coe_subtypeHom' G (FixedPoints.subfield G F).toSubring, h,\n    ← MulSemiringActionHom.coe_polynomial, ← MulSemiringActionHom.map_smul, smul_polynomial,\n    MulSemiringActionHom.coe_polynomial, ← h, IsInvariantSubring.coe_subtypeHom',\n    Polynomial.eval_map, Subfield.toSubring_subtype_eq_subtype, hf, smul_zero]\n\n-- Why is this so slow?\n"}
{"name":"FixedPoints.minpoly.irreducible_aux","module":"Mathlib.FieldTheory.Fixed","initialProofState":"G : Type u\ninst✝³ : Group G\nF : Type v\ninst✝² : Field F\ninst✝¹ : MulSemiringAction G F\ninst✝ : Fintype G\nx : F\nf g : Polynomial (Subtype fun x => Membership.mem (FixedPoints.subfield G F) x)\nhf : f.Monic\nhg : g.Monic\nhfg : Eq (HMul.hMul f g) (FixedPoints.minpoly G F x)\n⊢ Or (Eq f 1) (Eq g 1)","decl":"theorem irreducible_aux (f g : Polynomial (FixedPoints.subfield G F)) (hf : f.Monic) (hg : g.Monic)\n    (hfg : f * g = minpoly G F x) : f = 1 ∨ g = 1 := by\n  have hf2 : f ∣ minpoly G F x := by rw [← hfg]; exact dvd_mul_right _ _\n  have hg2 : g ∣ minpoly G F x := by rw [← hfg]; exact dvd_mul_left _ _\n  have := eval₂ G F x\n  rw [← hfg, Polynomial.eval₂_mul, mul_eq_zero] at this\n  cases' this with this this\n  · right\n    have hf3 : f = minpoly G F x :=\n      Polynomial.eq_of_monic_of_associated hf (monic G F x)\n        (associated_of_dvd_dvd hf2 <| @of_eval₂ G _ F _ _ _ x f this)\n    rwa [← mul_one (minpoly G F x), hf3, mul_right_inj' (monic G F x).ne_zero] at hfg\n  · left\n    have hg3 : g = minpoly G F x :=\n      Polynomial.eq_of_monic_of_associated hg (monic G F x)\n        (associated_of_dvd_dvd hg2 <| @of_eval₂ G _ F _ _ _ x g this)\n    rwa [← one_mul (minpoly G F x), hg3, mul_left_inj' (monic G F x).ne_zero] at hfg\n\n"}
{"name":"FixedPoints.minpoly.irreducible","module":"Mathlib.FieldTheory.Fixed","initialProofState":"G : Type u\ninst✝³ : Group G\nF : Type v\ninst✝² : Field F\ninst✝¹ : MulSemiringAction G F\ninst✝ : Fintype G\nx : F\n⊢ Irreducible (FixedPoints.minpoly G F x)","decl":"theorem irreducible : Irreducible (minpoly G F x) :=\n  (Polynomial.irreducible_of_monic (monic G F x) (ne_one G F x)).2 (irreducible_aux G F x)\n\n"}
{"name":"FixedPoints.isIntegral","module":"Mathlib.FieldTheory.Fixed","initialProofState":"G : Type u\ninst✝³ : Group G\nF : Type v\ninst✝² : Field F\ninst✝¹ : MulSemiringAction G F\ninst✝ : Finite G\nx : F\n⊢ IsIntegral (Subtype fun x => Membership.mem (FixedPoints.subfield G F) x) x","decl":"theorem isIntegral [Finite G] (x : F) : IsIntegral (FixedPoints.subfield G F) x := by\n  cases nonempty_fintype G; exact ⟨minpoly G F x, minpoly.monic G F x, minpoly.eval₂ G F x⟩\n\n"}
{"name":"FixedPoints.minpoly_eq_minpoly","module":"Mathlib.FieldTheory.Fixed","initialProofState":"G : Type u\ninst✝³ : Group G\nF : Type v\ninst✝² : Field F\ninst✝¹ : MulSemiringAction G F\ninst✝ : Fintype G\nx : F\n⊢ Eq (FixedPoints.minpoly G F x) (minpoly (Subtype fun x => Membership.mem (FixedPoints.subfield G F) x) x)","decl":"theorem minpoly_eq_minpoly : minpoly G F x = _root_.minpoly (FixedPoints.subfield G F) x :=\n  minpoly.eq_of_irreducible_of_monic (minpoly.irreducible G F x) (minpoly.eval₂ G F x)\n    (minpoly.monic G F x)\n\n"}
{"name":"FixedPoints.rank_le_card","module":"Mathlib.FieldTheory.Fixed","initialProofState":"G : Type u\ninst✝³ : Group G\nF : Type v\ninst✝² : Field F\ninst✝¹ : MulSemiringAction G F\ninst✝ : Fintype G\n⊢ LE.le (Module.rank (Subtype fun x => Membership.mem (FixedPoints.subfield G F) x) F) ↑(Fintype.card G)","decl":"theorem rank_le_card : Module.rank (FixedPoints.subfield G F) F ≤ Fintype.card G :=\n  rank_le fun s hs => by\n    simpa only [rank_fun', Cardinal.mk_coe_finset, Finset.coe_sort_coe, Cardinal.lift_natCast,\n      Nat.cast_le] using\n      (linearIndependent_smul_of_linearIndependent G F hs).cardinal_lift_le_rank\n\n"}
{"name":"FixedPoints.normal","module":"Mathlib.FieldTheory.Fixed","initialProofState":"G : Type u\ninst✝³ : Group G\nF : Type v\ninst✝² : Field F\ninst✝¹ : MulSemiringAction G F\ninst✝ : Finite G\n⊢ Normal (Subtype fun x => Membership.mem (FixedPoints.subfield G F) x) F","decl":"instance normal : Normal (FixedPoints.subfield G F) F where\n  isAlgebraic x := (isIntegral G F x).isAlgebraic\n  splits' x :=\n    (Polynomial.splits_id_iff_splits _).1 <| by\n      cases nonempty_fintype G\n      rw [← minpoly_eq_minpoly, minpoly, coe_algebraMap, ← Subfield.toSubring_subtype_eq_subtype,\n        Polynomial.map_toSubring _ (subfield G F).toSubring, prodXSubSMul]\n      exact Polynomial.splits_prod _ fun _ _ => Polynomial.splits_X_sub_C _\n\n"}
{"name":"FixedPoints.isSeparable","module":"Mathlib.FieldTheory.Fixed","initialProofState":"G : Type u\ninst✝² : Group G\nF : Type v\ninst✝¹ : Field F\ninst✝ : MulSemiringAction G F\n⊢ Algebra.IsSeparable (Subtype fun x => Membership.mem (FixedPoints.subfield G F) x) F","decl":"instance isSeparable : Algebra.IsSeparable (FixedPoints.subfield G F) F := by\n  classical\n  exact ⟨fun x => by\n    cases nonempty_fintype G\n    -- this was a plain rw when we were using unbundled subrings\n    erw [IsSeparable, ← minpoly_eq_minpoly,\n      ← Polynomial.separable_map (FixedPoints.subfield G F).subtype, minpoly,\n      Polynomial.map_toSubring _ (subfield G F).toSubring]\n    exact Polynomial.separable_prod_X_sub_C_iff.2 (injective_ofQuotientStabilizer G x)⟩\n\n"}
{"name":"FixedPoints.instFiniteDimensionalSubtypeMemSubfieldSubfield","module":"Mathlib.FieldTheory.Fixed","initialProofState":"G : Type u\ninst✝² : Group G\nF : Type v\ninst✝¹ : Field F\ninst✝ : MulSemiringAction G F\n⊢ FiniteDimensional (Subtype fun x => Membership.mem (FixedPoints.subfield G F) x) F","decl":"instance : FiniteDimensional (subfield G F) F := by\n  cases nonempty_fintype G\n  exact IsNoetherian.iff_fg.1\n      (IsNoetherian.iff_rank_lt_aleph0.2 <| (rank_le_card G F).trans_lt <| Cardinal.nat_lt_aleph0 _)\n\n"}
{"name":"FixedPoints.finrank_le_card","module":"Mathlib.FieldTheory.Fixed","initialProofState":"G : Type u\ninst✝³ : Group G\nF : Type v\ninst✝² : Field F\ninst✝¹ : MulSemiringAction G F\ninst✝ : Fintype G\n⊢ LE.le (Module.finrank (Subtype fun x => Membership.mem (FixedPoints.subfield G F) x) F) (Fintype.card G)","decl":"theorem finrank_le_card [Fintype G] : finrank (subfield G F) F ≤ Fintype.card G := by\n  rw [← @Nat.cast_le Cardinal, finrank_eq_rank]\n  apply rank_le_card\n\n"}
{"name":"linearIndependent_toLinearMap","module":"Mathlib.FieldTheory.Fixed","initialProofState":"R : Type u\nA : Type v\nB : Type w\ninst✝⁵ : CommSemiring R\ninst✝⁴ : Ring A\ninst✝³ : Algebra R A\ninst✝² : CommRing B\ninst✝¹ : IsDomain B\ninst✝ : Algebra R B\n⊢ LinearIndependent B AlgHom.toLinearMap","decl":"theorem linearIndependent_toLinearMap (R : Type u) (A : Type v) (B : Type w) [CommSemiring R]\n    [Ring A] [Algebra R A] [CommRing B] [IsDomain B] [Algebra R B] :\n    LinearIndependent B (AlgHom.toLinearMap : (A →ₐ[R] B) → A →ₗ[R] B) :=\n  have : LinearIndependent B (LinearMap.ltoFun R A B ∘ AlgHom.toLinearMap) :=\n    ((linearIndependent_monoidHom A B).comp ((↑) : (A →ₐ[R] B) → A →* B) fun _ _ hfg =>\n        AlgHom.ext fun _ => DFunLike.ext_iff.1 hfg _ :\n      _)\n  this.of_comp _\n\n"}
{"name":"cardinalMk_algHom","module":"Mathlib.FieldTheory.Fixed","initialProofState":"K : Type u\nV : Type v\nW : Type w\ninst✝⁵ : Field K\ninst✝⁴ : Field V\ninst✝³ : Algebra K V\ninst✝² : FiniteDimensional K V\ninst✝¹ : Field W\ninst✝ : Algebra K W\n⊢ LE.le (Cardinal.mk (AlgHom K V W)) ↑(Module.finrank W (LinearMap (RingHom.id K) V W))","decl":"theorem cardinalMk_algHom (K : Type u) (V : Type v) (W : Type w) [Field K] [Field V] [Algebra K V]\n    [FiniteDimensional K V] [Field W] [Algebra K W] :\n    Cardinal.mk (V →ₐ[K] W) ≤ finrank W (V →ₗ[K] W) :=\n  (linearIndependent_toLinearMap K V W).cardinalMk_le_finrank\n\n"}
{"name":"cardinal_mk_algHom","module":"Mathlib.FieldTheory.Fixed","initialProofState":"K : Type u\nV : Type v\nW : Type w\ninst✝⁵ : Field K\ninst✝⁴ : Field V\ninst✝³ : Algebra K V\ninst✝² : FiniteDimensional K V\ninst✝¹ : Field W\ninst✝ : Algebra K W\n⊢ LE.le (Cardinal.mk (AlgHom K V W)) ↑(Module.finrank W (LinearMap (RingHom.id K) V W))","decl":"@[deprecated (since := \"2024-11-10\")] alias cardinal_mk_algHom := cardinalMk_algHom\n\n"}
{"name":"finrank_algHom","module":"Mathlib.FieldTheory.Fixed","initialProofState":"K : Type u\nV : Type v\ninst✝³ : Field K\ninst✝² : Field V\ninst✝¹ : Algebra K V\ninst✝ : FiniteDimensional K V\n⊢ LE.le (Fintype.card (AlgHom K V V)) (Module.finrank V (LinearMap (RingHom.id K) V V))","decl":"theorem finrank_algHom (K : Type u) (V : Type v) [Field K] [Field V] [Algebra K V]\n    [FiniteDimensional K V] : Fintype.card (V →ₐ[K] V) ≤ finrank V (V →ₗ[K] V) :=\n  (linearIndependent_toLinearMap K V V).fintype_card_le_finrank\n\n"}
{"name":"FixedPoints.finrank_eq_card","module":"Mathlib.FieldTheory.Fixed","initialProofState":"G : Type u_1\nF : Type u_2\ninst✝⁴ : Group G\ninst✝³ : Field F\ninst✝² : MulSemiringAction G F\ninst✝¹ : Fintype G\ninst✝ : FaithfulSMul G F\n⊢ Eq (Module.finrank (Subtype fun x => Membership.mem (FixedPoints.subfield G F) x) F) (Fintype.card G)","decl":"/-- Let $F$ be a field. Let $G$ be a finite group acting faithfully on $F$.\nThen $[F : F^G] = |G|$. -/\n@[stacks 09I3 \"second part\"]\ntheorem finrank_eq_card [Fintype G] [FaithfulSMul G F] :\n    finrank (FixedPoints.subfield G F) F = Fintype.card G :=\n  le_antisymm (FixedPoints.finrank_le_card G F) <|\n    calc\n      Fintype.card G ≤ Fintype.card (F →ₐ[FixedPoints.subfield G F] F) :=\n        Fintype.card_le_of_injective _ (MulSemiringAction.toAlgHom_injective _ F)\n      _ ≤ finrank F (F →ₗ[FixedPoints.subfield G F] F) := finrank_algHom (subfield G F) F\n      _ = finrank (FixedPoints.subfield G F) F := finrank_linearMap_self _ _ _\n\n"}
{"name":"FixedPoints.toAlgHom_bijective","module":"Mathlib.FieldTheory.Fixed","initialProofState":"G : Type u_1\nF : Type u_2\ninst✝⁴ : Group G\ninst✝³ : Field F\ninst✝² : MulSemiringAction G F\ninst✝¹ : Finite G\ninst✝ : FaithfulSMul G F\n⊢ Function.Bijective (MulSemiringAction.toAlgHom (Subtype fun x => Membership.mem (FixedPoints.subfield G F) x) F)","decl":"/-- `MulSemiringAction.toAlgHom` is bijective. -/\ntheorem toAlgHom_bijective [Finite G] [FaithfulSMul G F] :\n    Function.Bijective (MulSemiringAction.toAlgHom _ _ : G → F →ₐ[subfield G F] F) := by\n  cases nonempty_fintype G\n  rw [Fintype.bijective_iff_injective_and_card]\n  constructor\n  · exact MulSemiringAction.toAlgHom_injective _ F\n  · apply le_antisymm\n    · exact Fintype.card_le_of_injective _ (MulSemiringAction.toAlgHom_injective _ F)\n    · rw [← finrank_eq_card G F]\n      exact LE.le.trans_eq (finrank_algHom _ F) (finrank_linearMap_self _ _ _)\n\n"}
{"name":"FixedPoints.toAlgAut_bijective","module":"Mathlib.FieldTheory.Fixed","initialProofState":"G : Type u_1\nF : Type u_2\ninst✝⁴ : Group G\ninst✝³ : Field F\ninst✝² : MulSemiringAction G F\ninst✝¹ : Finite G\ninst✝ : FaithfulSMul G F\n⊢ Function.Bijective ⇑(MulSemiringAction.toAlgAut G (Subtype fun x => Membership.mem (FixedPoints.subfield G F) x) F)","decl":"/-- `MulSemiringAction.toAlgAut` is bijective. -/\ntheorem toAlgAut_bijective [Finite G] [FaithfulSMul G F] :\n    Function.Bijective (MulSemiringAction.toAlgAut G (FixedPoints.subfield G F) F) := by\n  refine ⟨fun _ _ h ↦ (FixedPoints.toAlgHom_bijective G F).injective ?_,\n    fun f ↦ ((FixedPoints.toAlgHom_bijective G F).surjective f).imp (fun _ h ↦ ?_)⟩ <;>\n      rwa [DFunLike.ext_iff] at h ⊢\n\n"}
{"name":"FixedPoints.toAlgAut_surjective","module":"Mathlib.FieldTheory.Fixed","initialProofState":"G : Type u_1\nF : Type u_2\ninst✝³ : Group G\ninst✝² : Field F\ninst✝¹ : MulSemiringAction G F\ninst✝ : Finite G\n⊢ Function.Surjective ⇑(MulSemiringAction.toAlgAut G (Subtype fun x => Membership.mem (FixedPoints.subfield G F) x) F)","decl":"/-- `MulSemiringAction.toAlgAut` is surjective. -/\ntheorem toAlgAut_surjective [Finite G] :\n    Function.Surjective (MulSemiringAction.toAlgAut G (FixedPoints.subfield G F) F) := by\n  let f : G →* F ≃ₐ[FixedPoints.subfield G F] F :=\n    MulSemiringAction.toAlgAut G (FixedPoints.subfield G F) F\n  let Q := G ⧸ f.ker\n  let _ : MulSemiringAction Q F := MulSemiringAction.compHom _ (QuotientGroup.kerLift f)\n  have : FaithfulSMul Q F := ⟨by\n    intro q₁ q₂\n    refine Quotient.inductionOn₂' q₁ q₂ (fun g₁ g₂ h ↦ QuotientGroup.eq.mpr ?_)\n    rwa [MonoidHom.mem_ker, map_mul, map_inv, inv_mul_eq_one, AlgEquiv.ext_iff]⟩\n  intro f\n  obtain ⟨q, hq⟩ := (toAlgAut_bijective Q F).surjective\n    (AlgEquiv.ofRingEquiv (f := f) (fun ⟨x, hx⟩ ↦ f.commutes' ⟨x, fun g ↦ hx g⟩))\n  revert hq\n  refine QuotientGroup.induction_on q (fun g hg ↦ ⟨g, ?_⟩)\n  rwa [AlgEquiv.ext_iff] at hg ⊢\n\n"}
