{"name":"CategoryTheory.Limits.coyonedaOpColimitIsoLimitCoyoneda_hom_comp_π","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\nI : Type v₁\ninst✝¹ : CategoryTheory.Category.{v₂, v₁} I\nF : CategoryTheory.Functor I C\ninst✝ : CategoryTheory.Limits.HasColimit F\ni : I\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coyonedaOpColimitIsoLimitCoyoneda F).hom (CategoryTheory.Limits.limit.π (F.op.comp CategoryTheory.coyoneda) { unop := i })) (CategoryTheory.coyoneda.map (CategoryTheory.Limits.colimit.ι F i).op)","decl":"@[reassoc (attr := simp)]\nlemma coyonedaOpColimitIsoLimitCoyoneda_hom_comp_π (i : I) :\n    (coyonedaOpColimitIsoLimitCoyoneda F).hom ≫ limit.π (F.op.comp coyoneda) ⟨i⟩\n      = coyoneda.map (colimit.ι F i).op := by\n  simp only [coyonedaOpColimitIsoLimitCoyoneda, Functor.mapIso_symm,\n    Iso.trans_hom, Iso.symm_hom, Functor.mapIso_inv, Category.assoc, preservesLimitIso_hom_π,\n    ← Functor.map_comp, limitOpIsoOpColimit_inv_comp_π]\n\n"}
{"name":"CategoryTheory.Limits.coyonedaOpColimitIsoLimitCoyoneda_hom_comp_π_assoc","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\nI : Type v₁\ninst✝¹ : CategoryTheory.Category.{v₂, v₁} I\nF : CategoryTheory.Functor I C\ninst✝ : CategoryTheory.Limits.HasColimit F\ni : I\nZ : CategoryTheory.Functor C (Type u₂)\nh : Quiver.Hom (CategoryTheory.coyoneda.obj (F.op.obj { unop := i })) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coyonedaOpColimitIsoLimitCoyoneda F).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.op.comp CategoryTheory.coyoneda) { unop := i }) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.coyoneda.map (CategoryTheory.Limits.colimit.ι F i).op) h)","decl":"@[reassoc (attr := simp)]\nlemma coyonedaOpColimitIsoLimitCoyoneda_hom_comp_π (i : I) :\n    (coyonedaOpColimitIsoLimitCoyoneda F).hom ≫ limit.π (F.op.comp coyoneda) ⟨i⟩\n      = coyoneda.map (colimit.ι F i).op := by\n  simp only [coyonedaOpColimitIsoLimitCoyoneda, Functor.mapIso_symm,\n    Iso.trans_hom, Iso.symm_hom, Functor.mapIso_inv, Category.assoc, preservesLimitIso_hom_π,\n    ← Functor.map_comp, limitOpIsoOpColimit_inv_comp_π]\n\n"}
{"name":"CategoryTheory.Limits.coyonedaOpColimitIsoLimitCoyoneda_inv_comp_π_assoc","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\nI : Type v₁\ninst✝¹ : CategoryTheory.Category.{v₂, v₁} I\nF : CategoryTheory.Functor I C\ninst✝ : CategoryTheory.Limits.HasColimit F\ni : I\nZ : CategoryTheory.Functor C (Type u₂)\nh : Quiver.Hom (CategoryTheory.coyoneda.obj { unop := F.obj i }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coyonedaOpColimitIsoLimitCoyoneda F).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.coyoneda.map (CategoryTheory.Limits.colimit.ι F i).op) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.op.comp CategoryTheory.coyoneda) { unop := i }) h)","decl":"@[reassoc (attr := simp)]\nlemma coyonedaOpColimitIsoLimitCoyoneda_inv_comp_π (i : I) :\n    (coyonedaOpColimitIsoLimitCoyoneda F).inv ≫ coyoneda.map (colimit.ι F i).op =\n      limit.π (F.op.comp coyoneda) ⟨i⟩ := by\n  rw [← coyonedaOpColimitIsoLimitCoyoneda_hom_comp_π, ← Category.assoc,\n    Iso.inv_hom_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.Limits.coyonedaOpColimitIsoLimitCoyoneda_inv_comp_π","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\nI : Type v₁\ninst✝¹ : CategoryTheory.Category.{v₂, v₁} I\nF : CategoryTheory.Functor I C\ninst✝ : CategoryTheory.Limits.HasColimit F\ni : I\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coyonedaOpColimitIsoLimitCoyoneda F).inv (CategoryTheory.coyoneda.map (CategoryTheory.Limits.colimit.ι F i).op)) (CategoryTheory.Limits.limit.π (F.op.comp CategoryTheory.coyoneda) { unop := i })","decl":"@[reassoc (attr := simp)]\nlemma coyonedaOpColimitIsoLimitCoyoneda_inv_comp_π (i : I) :\n    (coyonedaOpColimitIsoLimitCoyoneda F).inv ≫ coyoneda.map (colimit.ι F i).op =\n      limit.π (F.op.comp coyoneda) ⟨i⟩ := by\n  rw [← coyonedaOpColimitIsoLimitCoyoneda_hom_comp_π, ← Category.assoc,\n    Iso.inv_hom_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.Limits.colimitHomIsoLimitYoneda_hom_comp_π_assoc","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\nI : Type v₁\ninst✝² : CategoryTheory.Category.{v₂, v₁} I\nF : CategoryTheory.Functor I C\ninst✝¹ : CategoryTheory.Limits.HasColimit F\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (Opposite I) (Type u₂)\nA : C\ni : I\nZ : Type u₂\nh : Quiver.Hom ((CategoryTheory.yoneda.obj A).obj (F.op.obj { unop := i })) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitHomIsoLimitYoneda F A).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.op.comp (CategoryTheory.yoneda.obj A)) { unop := i }) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.coyoneda.map (CategoryTheory.Limits.colimit.ι F i).op).app A) h)","decl":"@[reassoc (attr := simp)]\nlemma colimitHomIsoLimitYoneda_hom_comp_π [HasLimitsOfShape Iᵒᵖ (Type u₂)] (A : C) (i : I) :\n    (colimitHomIsoLimitYoneda F A).hom ≫ limit.π (F.op ⋙ yoneda.obj A) ⟨i⟩ =\n      (coyoneda.map (colimit.ι F i).op).app A := by\n  simp only [colimitHomIsoLimitYoneda, Iso.trans_hom, Iso.app_hom, Category.assoc]\n  erw [limitObjIsoLimitCompEvaluation_hom_π]\n  change ((coyonedaOpColimitIsoLimitCoyoneda F).hom ≫ _).app A = _\n  rw [coyonedaOpColimitIsoLimitCoyoneda_hom_comp_π]\n\n"}
{"name":"CategoryTheory.Limits.colimitHomIsoLimitYoneda_hom_comp_π","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\nI : Type v₁\ninst✝² : CategoryTheory.Category.{v₂, v₁} I\nF : CategoryTheory.Functor I C\ninst✝¹ : CategoryTheory.Limits.HasColimit F\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (Opposite I) (Type u₂)\nA : C\ni : I\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitHomIsoLimitYoneda F A).hom (CategoryTheory.Limits.limit.π (F.op.comp (CategoryTheory.yoneda.obj A)) { unop := i })) ((CategoryTheory.coyoneda.map (CategoryTheory.Limits.colimit.ι F i).op).app A)","decl":"@[reassoc (attr := simp)]\nlemma colimitHomIsoLimitYoneda_hom_comp_π [HasLimitsOfShape Iᵒᵖ (Type u₂)] (A : C) (i : I) :\n    (colimitHomIsoLimitYoneda F A).hom ≫ limit.π (F.op ⋙ yoneda.obj A) ⟨i⟩ =\n      (coyoneda.map (colimit.ι F i).op).app A := by\n  simp only [colimitHomIsoLimitYoneda, Iso.trans_hom, Iso.app_hom, Category.assoc]\n  erw [limitObjIsoLimitCompEvaluation_hom_π]\n  change ((coyonedaOpColimitIsoLimitCoyoneda F).hom ≫ _).app A = _\n  rw [coyonedaOpColimitIsoLimitCoyoneda_hom_comp_π]\n\n"}
{"name":"CategoryTheory.Limits.colimitHomIsoLimitYoneda_inv_comp_π_assoc","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\nI : Type v₁\ninst✝² : CategoryTheory.Category.{v₂, v₁} I\nF : CategoryTheory.Functor I C\ninst✝¹ : CategoryTheory.Limits.HasColimit F\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (Opposite I) (Type u₂)\nA : C\ni : I\nZ : Type u₂\nh : Quiver.Hom ((CategoryTheory.coyoneda.obj { unop := F.obj i }).obj A) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitHomIsoLimitYoneda F A).inv (CategoryTheory.CategoryStruct.comp ((CategoryTheory.coyoneda.map (CategoryTheory.Limits.colimit.ι F i).op).app A) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.op.comp (CategoryTheory.yoneda.obj A)) { unop := i }) h)","decl":"@[reassoc (attr := simp)]\nlemma colimitHomIsoLimitYoneda_inv_comp_π [HasLimitsOfShape Iᵒᵖ (Type u₂)] (A : C) (i : I) :\n    (colimitHomIsoLimitYoneda F A).inv ≫ (coyoneda.map (colimit.ι F i).op).app A =\n      limit.π (F.op ⋙ yoneda.obj A) ⟨i⟩ := by\n  rw [← colimitHomIsoLimitYoneda_hom_comp_π, ← Category.assoc,\n    Iso.inv_hom_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.Limits.colimitHomIsoLimitYoneda_inv_comp_π","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\nI : Type v₁\ninst✝² : CategoryTheory.Category.{v₂, v₁} I\nF : CategoryTheory.Functor I C\ninst✝¹ : CategoryTheory.Limits.HasColimit F\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (Opposite I) (Type u₂)\nA : C\ni : I\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitHomIsoLimitYoneda F A).inv ((CategoryTheory.coyoneda.map (CategoryTheory.Limits.colimit.ι F i).op).app A)) (CategoryTheory.Limits.limit.π (F.op.comp (CategoryTheory.yoneda.obj A)) { unop := i })","decl":"@[reassoc (attr := simp)]\nlemma colimitHomIsoLimitYoneda_inv_comp_π [HasLimitsOfShape Iᵒᵖ (Type u₂)] (A : C) (i : I) :\n    (colimitHomIsoLimitYoneda F A).inv ≫ (coyoneda.map (colimit.ι F i).op).app A =\n      limit.π (F.op ⋙ yoneda.obj A) ⟨i⟩ := by\n  rw [← colimitHomIsoLimitYoneda_hom_comp_π, ← Category.assoc,\n    Iso.inv_hom_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.Limits.coyonedaOpColimitIsoLimitCoyoneda'_hom_comp_π","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\nI : Type v₁\ninst✝¹ : CategoryTheory.Category.{v₂, v₁} I\nF : CategoryTheory.Functor (Opposite I) C\ninst✝ : CategoryTheory.Limits.HasColimit F\ni : I\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coyonedaOpColimitIsoLimitCoyoneda' F).hom (CategoryTheory.Limits.limit.π (F.rightOp.comp CategoryTheory.coyoneda) i)) (CategoryTheory.coyoneda.map (CategoryTheory.Limits.colimit.ι F { unop := i }).op)","decl":"@[reassoc (attr := simp)]\nlemma coyonedaOpColimitIsoLimitCoyoneda'_hom_comp_π (i : I) :\n    (coyonedaOpColimitIsoLimitCoyoneda' F).hom ≫ limit.π (F.rightOp ⋙ coyoneda) i =\n      coyoneda.map (colimit.ι F ⟨i⟩).op := by\n  simp only [coyonedaOpColimitIsoLimitCoyoneda', Functor.mapIso_symm, Iso.trans_hom, Iso.symm_hom,\n    Functor.mapIso_inv, Category.assoc, preservesLimitIso_hom_π, ← Functor.map_comp,\n    limitRightOpIsoOpColimit_inv_comp_π]\n\n"}
{"name":"CategoryTheory.Limits.coyonedaOpColimitIsoLimitCoyoneda'_hom_comp_π_assoc","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\nI : Type v₁\ninst✝¹ : CategoryTheory.Category.{v₂, v₁} I\nF : CategoryTheory.Functor (Opposite I) C\ninst✝ : CategoryTheory.Limits.HasColimit F\ni : I\nZ : CategoryTheory.Functor C (Type u₂)\nh : Quiver.Hom (CategoryTheory.coyoneda.obj (F.rightOp.obj i)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coyonedaOpColimitIsoLimitCoyoneda' F).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.rightOp.comp CategoryTheory.coyoneda) i) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.coyoneda.map (CategoryTheory.Limits.colimit.ι F { unop := i }).op) h)","decl":"@[reassoc (attr := simp)]\nlemma coyonedaOpColimitIsoLimitCoyoneda'_hom_comp_π (i : I) :\n    (coyonedaOpColimitIsoLimitCoyoneda' F).hom ≫ limit.π (F.rightOp ⋙ coyoneda) i =\n      coyoneda.map (colimit.ι F ⟨i⟩).op := by\n  simp only [coyonedaOpColimitIsoLimitCoyoneda', Functor.mapIso_symm, Iso.trans_hom, Iso.symm_hom,\n    Functor.mapIso_inv, Category.assoc, preservesLimitIso_hom_π, ← Functor.map_comp,\n    limitRightOpIsoOpColimit_inv_comp_π]\n\n"}
{"name":"CategoryTheory.Limits.coyonedaOpColimitIsoLimitCoyoneda'_inv_comp_π","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\nI : Type v₁\ninst✝¹ : CategoryTheory.Category.{v₂, v₁} I\nF : CategoryTheory.Functor (Opposite I) C\ninst✝ : CategoryTheory.Limits.HasColimit F\ni : I\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coyonedaOpColimitIsoLimitCoyoneda' F).inv (CategoryTheory.coyoneda.map (CategoryTheory.Limits.colimit.ι F { unop := i }).op)) (CategoryTheory.Limits.limit.π (F.rightOp.comp CategoryTheory.coyoneda) i)","decl":"@[reassoc (attr := simp)]\nlemma coyonedaOpColimitIsoLimitCoyoneda'_inv_comp_π (i : I) :\n    (coyonedaOpColimitIsoLimitCoyoneda' F).inv ≫ coyoneda.map (colimit.ι F ⟨i⟩).op =\n      limit.π (F.rightOp ⋙ coyoneda) i := by\n  rw [← coyonedaOpColimitIsoLimitCoyoneda'_hom_comp_π, ← Category.assoc,\n    Iso.inv_hom_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.Limits.coyonedaOpColimitIsoLimitCoyoneda'_inv_comp_π_assoc","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\nI : Type v₁\ninst✝¹ : CategoryTheory.Category.{v₂, v₁} I\nF : CategoryTheory.Functor (Opposite I) C\ninst✝ : CategoryTheory.Limits.HasColimit F\ni : I\nZ : CategoryTheory.Functor C (Type u₂)\nh : Quiver.Hom (CategoryTheory.coyoneda.obj { unop := F.obj { unop := i } }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coyonedaOpColimitIsoLimitCoyoneda' F).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.coyoneda.map (CategoryTheory.Limits.colimit.ι F { unop := i }).op) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.rightOp.comp CategoryTheory.coyoneda) i) h)","decl":"@[reassoc (attr := simp)]\nlemma coyonedaOpColimitIsoLimitCoyoneda'_inv_comp_π (i : I) :\n    (coyonedaOpColimitIsoLimitCoyoneda' F).inv ≫ coyoneda.map (colimit.ι F ⟨i⟩).op =\n      limit.π (F.rightOp ⋙ coyoneda) i := by\n  rw [← coyonedaOpColimitIsoLimitCoyoneda'_hom_comp_π, ← Category.assoc,\n    Iso.inv_hom_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.Limits.colimitHomIsoLimitYoneda'_hom_comp_π_assoc","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\nI : Type v₁\ninst✝² : CategoryTheory.Category.{v₂, v₁} I\nF : CategoryTheory.Functor (Opposite I) C\ninst✝¹ : CategoryTheory.Limits.HasColimit F\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape I (Type u₂)\nA : C\ni : I\nZ : Type u₂\nh : Quiver.Hom ((CategoryTheory.yoneda.obj A).obj (F.rightOp.obj i)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitHomIsoLimitYoneda' F A).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.rightOp.comp (CategoryTheory.yoneda.obj A)) i) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.coyoneda.map (CategoryTheory.Limits.colimit.ι F { unop := i }).op).app A) h)","decl":"@[reassoc (attr := simp)]\nlemma colimitHomIsoLimitYoneda'_hom_comp_π [HasLimitsOfShape I (Type u₂)] (A : C) (i : I) :\n    (colimitHomIsoLimitYoneda' F A).hom ≫ limit.π (F.rightOp ⋙ yoneda.obj A) i =\n      (coyoneda.map (colimit.ι F ⟨i⟩).op).app A := by\n  simp only [yoneda_obj_obj, colimitHomIsoLimitYoneda', Iso.trans_hom,\n    Iso.app_hom, Category.assoc]\n  erw [limitObjIsoLimitCompEvaluation_hom_π]\n  change ((coyonedaOpColimitIsoLimitCoyoneda' F).hom ≫ _).app A = _\n  rw [coyonedaOpColimitIsoLimitCoyoneda'_hom_comp_π]\n\n"}
{"name":"CategoryTheory.Limits.colimitHomIsoLimitYoneda'_hom_comp_π","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\nI : Type v₁\ninst✝² : CategoryTheory.Category.{v₂, v₁} I\nF : CategoryTheory.Functor (Opposite I) C\ninst✝¹ : CategoryTheory.Limits.HasColimit F\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape I (Type u₂)\nA : C\ni : I\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitHomIsoLimitYoneda' F A).hom (CategoryTheory.Limits.limit.π (F.rightOp.comp (CategoryTheory.yoneda.obj A)) i)) ((CategoryTheory.coyoneda.map (CategoryTheory.Limits.colimit.ι F { unop := i }).op).app A)","decl":"@[reassoc (attr := simp)]\nlemma colimitHomIsoLimitYoneda'_hom_comp_π [HasLimitsOfShape I (Type u₂)] (A : C) (i : I) :\n    (colimitHomIsoLimitYoneda' F A).hom ≫ limit.π (F.rightOp ⋙ yoneda.obj A) i =\n      (coyoneda.map (colimit.ι F ⟨i⟩).op).app A := by\n  simp only [yoneda_obj_obj, colimitHomIsoLimitYoneda', Iso.trans_hom,\n    Iso.app_hom, Category.assoc]\n  erw [limitObjIsoLimitCompEvaluation_hom_π]\n  change ((coyonedaOpColimitIsoLimitCoyoneda' F).hom ≫ _).app A = _\n  rw [coyonedaOpColimitIsoLimitCoyoneda'_hom_comp_π]\n\n"}
{"name":"CategoryTheory.Limits.colimitHomIsoLimitYoneda'_inv_comp_π_assoc","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\nI : Type v₁\ninst✝² : CategoryTheory.Category.{v₂, v₁} I\nF : CategoryTheory.Functor (Opposite I) C\ninst✝¹ : CategoryTheory.Limits.HasColimit F\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape I (Type u₂)\nA : C\ni : I\nZ : Type u₂\nh : Quiver.Hom ((CategoryTheory.coyoneda.obj { unop := F.obj { unop := i } }).obj A) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitHomIsoLimitYoneda' F A).inv (CategoryTheory.CategoryStruct.comp ((CategoryTheory.coyoneda.map (CategoryTheory.Limits.colimit.ι F { unop := i }).op).app A) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.rightOp.comp (CategoryTheory.yoneda.obj A)) i) h)","decl":"@[reassoc (attr := simp)]\nlemma colimitHomIsoLimitYoneda'_inv_comp_π [HasLimitsOfShape I (Type u₂)] (A : C) (i : I) :\n    (colimitHomIsoLimitYoneda' F A).inv ≫ (coyoneda.map (colimit.ι F ⟨i⟩).op).app A =\n      limit.π (F.rightOp ⋙ yoneda.obj A) i := by\n  rw [← colimitHomIsoLimitYoneda'_hom_comp_π, ← Category.assoc,\n    Iso.inv_hom_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.Limits.colimitHomIsoLimitYoneda'_inv_comp_π","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\nI : Type v₁\ninst✝² : CategoryTheory.Category.{v₂, v₁} I\nF : CategoryTheory.Functor (Opposite I) C\ninst✝¹ : CategoryTheory.Limits.HasColimit F\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape I (Type u₂)\nA : C\ni : I\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitHomIsoLimitYoneda' F A).inv ((CategoryTheory.coyoneda.map (CategoryTheory.Limits.colimit.ι F { unop := i }).op).app A)) (CategoryTheory.Limits.limit.π (F.rightOp.comp (CategoryTheory.yoneda.obj A)) i)","decl":"@[reassoc (attr := simp)]\nlemma colimitHomIsoLimitYoneda'_inv_comp_π [HasLimitsOfShape I (Type u₂)] (A : C) (i : I) :\n    (colimitHomIsoLimitYoneda' F A).inv ≫ (coyoneda.map (colimit.ι F ⟨i⟩).op).app A =\n      limit.π (F.rightOp ⋙ yoneda.obj A) i := by\n  rw [← colimitHomIsoLimitYoneda'_hom_comp_π, ← Category.assoc,\n    Iso.inv_hom_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.Limits.colimitCoyonedaHomIsoLimit_π_apply","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\nI : Type v₁\ninst✝² : CategoryTheory.Category.{v₂, v₁} I\nD : CategoryTheory.Functor (Opposite I) C\nF : CategoryTheory.Functor C (Type u₂)\ninst✝¹ : CategoryTheory.Limits.HasColimit (D.rightOp.comp CategoryTheory.coyoneda)\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (Opposite I) (Type (max u₁ u₂))\nf : Quiver.Hom (CategoryTheory.Limits.colimit (D.rightOp.comp CategoryTheory.coyoneda)) F\ni : I\n⊢ Eq (CategoryTheory.Limits.limit.π (D.comp (F.comp CategoryTheory.uliftFunctor.{u₁, u₂})) { unop := i } ((CategoryTheory.Limits.colimitCoyonedaHomIsoLimit D F).hom f)) { down := f.app (D.obj { unop := i }) ((CategoryTheory.Limits.colimit.ι (D.rightOp.comp CategoryTheory.coyoneda) i).app (D.obj { unop := i }) (CategoryTheory.CategoryStruct.id (D.obj { unop := i }))) }","decl":"@[simp]\nlemma colimitCoyonedaHomIsoLimit_π_apply (f : colimit (D.rightOp ⋙ coyoneda) ⟶ F) (i : I) :\n    limit.π (D ⋙ F ⋙ uliftFunctor.{u₁}) (op i) ((colimitCoyonedaHomIsoLimit D F).hom f) =\n      ⟨f.app (D.obj (op i)) ((colimit.ι (D.rightOp ⋙ coyoneda) i).app (D.obj (op i))\n          (𝟙 (D.obj (op i))))⟩ := by\n  change ((colimitCoyonedaHomIsoLimit D F).hom ≫ (limit.π (D ⋙ F ⋙ uliftFunctor.{u₁}) (op i))) f = _\n  simp only [colimitCoyonedaHomIsoLimit, Iso.trans_hom, Category.assoc,\n    HasLimit.isoOfNatIso_hom_π]\n  rw [← Category.assoc, colimitHomIsoLimitYoneda_hom_comp_π]\n  dsimp [coyonedaLemma, types_comp_apply]\n  erw [coyonedaEquiv_comp, coyonedaEquiv_apply]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.colimitCoyonedaHomIsoLimitLeftOp_π_apply","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\nI : Type v₁\ninst✝² : CategoryTheory.Category.{v₂, v₁} I\nD : CategoryTheory.Functor I (Opposite C)\nF : CategoryTheory.Functor C (Type u₂)\ninst✝¹ : CategoryTheory.Limits.HasColimit (D.comp CategoryTheory.coyoneda)\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (Opposite I) (Type (max u₁ u₂))\nf : Quiver.Hom (CategoryTheory.Limits.colimit (D.comp CategoryTheory.coyoneda)) F\ni : I\n⊢ Eq (CategoryTheory.Limits.limit.π (D.leftOp.comp (F.comp CategoryTheory.uliftFunctor.{u₁, u₂})) { unop := i } ((CategoryTheory.Limits.colimitCoyonedaHomIsoLimitLeftOp D F).hom f)) { down := f.app (Opposite.unop (D.obj i)) ((CategoryTheory.Limits.colimit.ι (D.comp CategoryTheory.coyoneda) i).app (Opposite.unop (D.obj i)) (CategoryTheory.CategoryStruct.id (Opposite.unop (D.obj i)))) }","decl":"@[simp]\nlemma colimitCoyonedaHomIsoLimitLeftOp_π_apply (f : colimit (D ⋙ coyoneda) ⟶ F) (i : I) :\n    limit.π (D.leftOp ⋙ F ⋙ uliftFunctor.{u₁}) (op i)\n        ((colimitCoyonedaHomIsoLimitLeftOp D F).hom f) =\n      ⟨f.app (D.obj i).unop ((colimit.ι (D ⋙ coyoneda) i).app (D.obj i).unop\n          (𝟙 (D.obj i).unop))⟩ :=\n  haveI : HasColimit (D.leftOp.rightOp ⋙ coyoneda) :=\n    inferInstanceAs <| HasColimit (D ⋙ coyoneda)\n  colimitCoyonedaHomIsoLimit_π_apply _ _ _ _\n\n"}
{"name":"CategoryTheory.Limits.colimitYonedaHomIsoLimit_π_apply","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\nI : Type v₁\ninst✝² : CategoryTheory.Category.{v₂, v₁} I\nD : CategoryTheory.Functor (Opposite I) (Opposite C)\nF : CategoryTheory.Functor (Opposite C) (Type u₂)\ninst✝¹ : CategoryTheory.Limits.HasColimit (D.unop.comp CategoryTheory.yoneda)\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (Opposite I) (Type (max u₁ u₂))\nf : Quiver.Hom (CategoryTheory.Limits.colimit (D.unop.comp CategoryTheory.yoneda)) F\ni : Opposite I\n⊢ Eq (CategoryTheory.Limits.limit.π (D.comp (F.comp CategoryTheory.uliftFunctor.{u₁, u₂})) i ((CategoryTheory.Limits.colimitYonedaHomIsoLimit D F).hom f)) { down := f.app (D.obj i) ((CategoryTheory.Limits.colimit.ι (D.unop.comp CategoryTheory.yoneda) (Opposite.unop i)).app (D.obj i) (CategoryTheory.CategoryStruct.id (Opposite.unop (D.obj i)))) }","decl":"@[simp]\nlemma colimitYonedaHomIsoLimit_π_apply (f : colimit (D.unop ⋙ yoneda) ⟶ F) (i : Iᵒᵖ) :\n    limit.π (D ⋙ F ⋙ uliftFunctor.{u₁}) i ((colimitYonedaHomIsoLimit D F).hom f) =\n      ⟨f.app (D.obj i)\n        ((colimit.ι (D.unop ⋙ yoneda) i.unop).app (D.obj i) (𝟙 (D.obj i).unop))⟩ := by\n  change ((colimitYonedaHomIsoLimit D F).hom ≫ (limit.π (D ⋙ F ⋙ uliftFunctor.{u₁}) i)) f = _\n  simp only [colimitYonedaHomIsoLimit, Iso.trans_hom, Category.assoc, HasLimit.isoOfNatIso_hom_π]\n  rw [← Category.assoc, colimitHomIsoLimitYoneda_hom_comp_π]\n  dsimp [yonedaLemma]\n  erw [yonedaEquiv_comp, yonedaEquiv_apply]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.colimitYonedaHomIsoLimitOp_π_apply","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\nI : Type v₁\ninst✝² : CategoryTheory.Category.{v₂, v₁} I\nD : CategoryTheory.Functor I C\nF : CategoryTheory.Functor (Opposite C) (Type u₂)\ninst✝¹ : CategoryTheory.Limits.HasColimit (D.comp CategoryTheory.yoneda)\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (Opposite I) (Type (max u₁ u₂))\nf : Quiver.Hom (CategoryTheory.Limits.colimit (D.comp CategoryTheory.yoneda)) F\ni : Opposite I\n⊢ Eq (CategoryTheory.Limits.limit.π (D.op.comp (F.comp CategoryTheory.uliftFunctor.{u₁, u₂})) i ((CategoryTheory.Limits.colimitYonedaHomIsoLimitOp D F).hom f)) { down := f.app { unop := D.obj (Opposite.unop i) } ((CategoryTheory.Limits.colimit.ι (D.comp CategoryTheory.yoneda) (Opposite.unop i)).app { unop := D.obj (Opposite.unop i) } (CategoryTheory.CategoryStruct.id (D.obj (Opposite.unop i)))) }","decl":"@[simp]\nlemma colimitYonedaHomIsoLimitOp_π_apply (f : colimit (D ⋙ yoneda) ⟶ F) (i : Iᵒᵖ) :\n    limit.π (D.op ⋙ F ⋙ uliftFunctor.{u₁}) i ((colimitYonedaHomIsoLimitOp D F).hom f) =\n      ⟨f.app (op (D.obj i.unop))\n        ((colimit.ι (D ⋙ yoneda) i.unop).app (op (D.obj i.unop)) (𝟙 (D.obj i.unop)))⟩ :=\n  haveI : HasColimit (D.op.unop ⋙ yoneda) :=\n    inferInstanceAs <| HasColimit (D ⋙ yoneda)\n  colimitYonedaHomIsoLimit_π_apply _ _ _ _\n\n"}
{"name":"CategoryTheory.Limits.colimitCoyonedaHomIsoLimit'_π_apply","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\nI : Type v₁\ninst✝² : CategoryTheory.Category.{v₂, v₁} I\nD : CategoryTheory.Functor I C\nF : CategoryTheory.Functor C (Type u₂)\ninst✝¹ : CategoryTheory.Limits.HasColimit (D.op.comp CategoryTheory.coyoneda)\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape I (Type (max u₁ u₂))\nf : Quiver.Hom (CategoryTheory.Limits.colimit (D.op.comp CategoryTheory.coyoneda)) F\ni : I\n⊢ Eq (CategoryTheory.Limits.limit.π (D.comp (F.comp CategoryTheory.uliftFunctor.{u₁, u₂})) i ((CategoryTheory.Limits.colimitCoyonedaHomIsoLimit' D F).hom f)) { down := f.app (D.obj i) ((CategoryTheory.Limits.colimit.ι (D.op.comp CategoryTheory.coyoneda) { unop := i }).app (D.obj i) (CategoryTheory.CategoryStruct.id (D.obj i))) }","decl":"@[simp]\nlemma colimitCoyonedaHomIsoLimit'_π_apply (f : colimit (D.op ⋙ coyoneda) ⟶ F) (i : I) :\n    limit.π (D ⋙ F ⋙ uliftFunctor.{u₁}) i ((colimitCoyonedaHomIsoLimit' D F).hom f) =\n      ⟨f.app (D.obj i) ((colimit.ι (D.op ⋙ coyoneda) ⟨i⟩).app (D.obj i) (𝟙 (D.obj i)))⟩ := by\n  change ((colimitCoyonedaHomIsoLimit' D F).hom ≫ (limit.π (D ⋙ F ⋙ uliftFunctor.{u₁}) i)) f = _\n  simp only [colimitCoyonedaHomIsoLimit', Iso.trans_hom, Category.assoc, HasLimit.isoOfNatIso_hom_π]\n  rw [← Category.assoc, colimitHomIsoLimitYoneda'_hom_comp_π]\n  dsimp [coyonedaLemma]\n  erw [coyonedaEquiv_comp, coyonedaEquiv_apply]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.colimitCoyonedaHomIsoLimitUnop_π_apply","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\nI : Type v₁\ninst✝² : CategoryTheory.Category.{v₂, v₁} I\nD : CategoryTheory.Functor (Opposite I) (Opposite C)\nF : CategoryTheory.Functor C (Type u₂)\ninst✝¹ : CategoryTheory.Limits.HasColimit (D.comp CategoryTheory.coyoneda)\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape I (Type (max u₁ u₂))\nf : Quiver.Hom (CategoryTheory.Limits.colimit (D.comp CategoryTheory.coyoneda)) F\ni : I\n⊢ Eq (CategoryTheory.Limits.limit.π (D.unop.comp (F.comp CategoryTheory.uliftFunctor.{u₁, u₂})) i ((CategoryTheory.Limits.colimitCoyonedaHomIsoLimitUnop D F).hom f)) { down := f.app (Opposite.unop (D.obj { unop := i })) ((CategoryTheory.Limits.colimit.ι (D.comp CategoryTheory.coyoneda) { unop := i }).app (Opposite.unop (D.obj { unop := i })) (CategoryTheory.CategoryStruct.id (Opposite.unop (D.obj { unop := i })))) }","decl":"@[simp]\nlemma colimitCoyonedaHomIsoLimitUnop_π_apply (f : colimit (D ⋙ coyoneda) ⟶ F) (i : I) :\n    limit.π (D.unop ⋙ F ⋙ uliftFunctor.{u₁}) i ((colimitCoyonedaHomIsoLimitUnop D F).hom f) =\n      ⟨f.app (D.obj (op i)).unop\n          ((colimit.ι (D ⋙ coyoneda) ⟨i⟩).app (D.obj (op i)).unop (𝟙 (D.obj (op i)).unop))⟩ :=\n  haveI : HasColimit (D.unop.op ⋙ coyoneda) :=\n    inferInstanceAs <| HasColimit (D ⋙ coyoneda)\n  colimitCoyonedaHomIsoLimit'_π_apply _ _ _ _\n\n"}
{"name":"CategoryTheory.Limits.colimitYonedaHomIsoLimit'_π_apply","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\nI : Type v₁\ninst✝² : CategoryTheory.Category.{v₂, v₁} I\nD : CategoryTheory.Functor I (Opposite C)\nF : CategoryTheory.Functor (Opposite C) (Type u₂)\ninst✝¹ : CategoryTheory.Limits.HasColimit (D.leftOp.comp CategoryTheory.yoneda)\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape I (Type (max u₁ u₂))\nf : Quiver.Hom (CategoryTheory.Limits.colimit (D.leftOp.comp CategoryTheory.yoneda)) F\ni : I\n⊢ Eq (CategoryTheory.Limits.limit.π (D.comp (F.comp CategoryTheory.uliftFunctor.{u₁, u₂})) i ((CategoryTheory.Limits.colimitYonedaHomIsoLimit' D F).hom f)) { down := f.app (D.obj i) ((CategoryTheory.Limits.colimit.ι (D.leftOp.comp CategoryTheory.yoneda) { unop := i }).app (D.obj i) (CategoryTheory.CategoryStruct.id (Opposite.unop (D.obj i)))) }","decl":"@[simp]\nlemma colimitYonedaHomIsoLimit'_π_apply (f : colimit (D.leftOp ⋙ yoneda) ⟶ F) (i : I) :\n    limit.π (D ⋙ F ⋙ uliftFunctor.{u₁}) i ((colimitYonedaHomIsoLimit' D F).hom f) =\n      ⟨f.app (D.obj i)\n        ((colimit.ι (D.leftOp ⋙ yoneda) (op i)).app (D.obj i) (𝟙 (D.obj i).unop))⟩ := by\n  change ((colimitYonedaHomIsoLimit' D F).hom ≫ (limit.π (D ⋙ F ⋙ uliftFunctor.{u₁}) i)) f = _\n  simp only [colimitYonedaHomIsoLimit', Iso.trans_hom, Category.assoc, HasLimit.isoOfNatIso_hom_π]\n  rw [← Category.assoc, colimitHomIsoLimitYoneda'_hom_comp_π]\n  dsimp [yonedaLemma]\n  erw [yonedaEquiv_comp, yonedaEquiv_apply]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.colimitYonedaHomIsoLimitRightOp_π_apply","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\nI : Type v₁\ninst✝² : CategoryTheory.Category.{v₂, v₁} I\nD : CategoryTheory.Functor (Opposite I) C\nF : CategoryTheory.Functor (Opposite C) (Type u₂)\ninst✝¹ : CategoryTheory.Limits.HasColimit (D.comp CategoryTheory.yoneda)\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape I (Type (max u₁ u₂))\nf : Quiver.Hom (CategoryTheory.Limits.colimit (D.comp CategoryTheory.yoneda)) F\ni : I\n⊢ Eq (CategoryTheory.Limits.limit.π (D.rightOp.comp (F.comp CategoryTheory.uliftFunctor.{u₁, u₂})) i ((CategoryTheory.Limits.colimitYonedaHomIsoLimitRightOp D F).hom f)) { down := f.app { unop := D.obj { unop := i } } ((CategoryTheory.Limits.colimit.ι (D.comp CategoryTheory.yoneda) { unop := i }).app { unop := D.obj { unop := i } } (CategoryTheory.CategoryStruct.id (D.obj { unop := i }))) }","decl":"@[simp]\nlemma colimitYonedaHomIsoLimitRightOp_π_apply (f : colimit (D ⋙ yoneda) ⟶ F) (i : I) :\n    limit.π (D.rightOp ⋙ F ⋙ uliftFunctor.{u₁}) i ((colimitYonedaHomIsoLimitRightOp D F).hom f) =\n      ⟨f.app (op (D.obj (op i)))\n        ((colimit.ι (D ⋙ yoneda) (op i)).app (op (D.obj (op i))) (𝟙 (D.obj (op i))))⟩ :=\n  haveI : HasColimit (D.rightOp.leftOp ⋙ yoneda) :=\n    inferInstanceAs <| HasColimit (D ⋙ yoneda)\n  colimitYonedaHomIsoLimit'_π_apply _ _ _ _\n\n"}
