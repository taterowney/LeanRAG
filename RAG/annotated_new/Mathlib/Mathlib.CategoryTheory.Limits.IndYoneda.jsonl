{"name":"CategoryTheory.Limits.coyonedaOpColimitIsoLimitCoyoneda_hom_comp_œÄ","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nI : Type v‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, v‚ÇÅ} I\nF : CategoryTheory.Functor I C\ninst‚úù : CategoryTheory.Limits.HasColimit F\ni : I\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coyonedaOpColimitIsoLimitCoyoneda F).hom (CategoryTheory.Limits.limit.œÄ (F.op.comp CategoryTheory.coyoneda) { unop := i })) (CategoryTheory.coyoneda.map (CategoryTheory.Limits.colimit.Œπ F i).op)","decl":"@[reassoc (attr := simp)]\nlemma coyonedaOpColimitIsoLimitCoyoneda_hom_comp_œÄ (i : I) :\n    (coyonedaOpColimitIsoLimitCoyoneda F).hom ‚â´ limit.œÄ (F.op.comp coyoneda) ‚ü®i‚ü©\n      = coyoneda.map (colimit.Œπ F i).op := by\n  simp only [coyonedaOpColimitIsoLimitCoyoneda, Functor.mapIso_symm,\n    Iso.trans_hom, Iso.symm_hom, Functor.mapIso_inv, Category.assoc, preservesLimitIso_hom_œÄ,\n    ‚Üê Functor.map_comp, limitOpIsoOpColimit_inv_comp_œÄ]\n\n"}
{"name":"CategoryTheory.Limits.coyonedaOpColimitIsoLimitCoyoneda_hom_comp_œÄ_assoc","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nI : Type v‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, v‚ÇÅ} I\nF : CategoryTheory.Functor I C\ninst‚úù : CategoryTheory.Limits.HasColimit F\ni : I\nZ : CategoryTheory.Functor C (Type u‚ÇÇ)\nh : Quiver.Hom (CategoryTheory.coyoneda.obj (F.op.obj { unop := i })) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coyonedaOpColimitIsoLimitCoyoneda F).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.œÄ (F.op.comp CategoryTheory.coyoneda) { unop := i }) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.coyoneda.map (CategoryTheory.Limits.colimit.Œπ F i).op) h)","decl":"@[reassoc (attr := simp)]\nlemma coyonedaOpColimitIsoLimitCoyoneda_hom_comp_œÄ (i : I) :\n    (coyonedaOpColimitIsoLimitCoyoneda F).hom ‚â´ limit.œÄ (F.op.comp coyoneda) ‚ü®i‚ü©\n      = coyoneda.map (colimit.Œπ F i).op := by\n  simp only [coyonedaOpColimitIsoLimitCoyoneda, Functor.mapIso_symm,\n    Iso.trans_hom, Iso.symm_hom, Functor.mapIso_inv, Category.assoc, preservesLimitIso_hom_œÄ,\n    ‚Üê Functor.map_comp, limitOpIsoOpColimit_inv_comp_œÄ]\n\n"}
{"name":"CategoryTheory.Limits.coyonedaOpColimitIsoLimitCoyoneda_inv_comp_œÄ_assoc","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nI : Type v‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, v‚ÇÅ} I\nF : CategoryTheory.Functor I C\ninst‚úù : CategoryTheory.Limits.HasColimit F\ni : I\nZ : CategoryTheory.Functor C (Type u‚ÇÇ)\nh : Quiver.Hom (CategoryTheory.coyoneda.obj { unop := F.obj i }) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coyonedaOpColimitIsoLimitCoyoneda F).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.coyoneda.map (CategoryTheory.Limits.colimit.Œπ F i).op) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.œÄ (F.op.comp CategoryTheory.coyoneda) { unop := i }) h)","decl":"@[reassoc (attr := simp)]\nlemma coyonedaOpColimitIsoLimitCoyoneda_inv_comp_œÄ (i : I) :\n    (coyonedaOpColimitIsoLimitCoyoneda F).inv ‚â´ coyoneda.map (colimit.Œπ F i).op =\n      limit.œÄ (F.op.comp coyoneda) ‚ü®i‚ü© := by\n  rw [‚Üê coyonedaOpColimitIsoLimitCoyoneda_hom_comp_œÄ, ‚Üê Category.assoc,\n    Iso.inv_hom_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.Limits.coyonedaOpColimitIsoLimitCoyoneda_inv_comp_œÄ","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nI : Type v‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, v‚ÇÅ} I\nF : CategoryTheory.Functor I C\ninst‚úù : CategoryTheory.Limits.HasColimit F\ni : I\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coyonedaOpColimitIsoLimitCoyoneda F).inv (CategoryTheory.coyoneda.map (CategoryTheory.Limits.colimit.Œπ F i).op)) (CategoryTheory.Limits.limit.œÄ (F.op.comp CategoryTheory.coyoneda) { unop := i })","decl":"@[reassoc (attr := simp)]\nlemma coyonedaOpColimitIsoLimitCoyoneda_inv_comp_œÄ (i : I) :\n    (coyonedaOpColimitIsoLimitCoyoneda F).inv ‚â´ coyoneda.map (colimit.Œπ F i).op =\n      limit.œÄ (F.op.comp coyoneda) ‚ü®i‚ü© := by\n  rw [‚Üê coyonedaOpColimitIsoLimitCoyoneda_hom_comp_œÄ, ‚Üê Category.assoc,\n    Iso.inv_hom_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.Limits.colimitHomIsoLimitYoneda_hom_comp_œÄ_assoc","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nI : Type v‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, v‚ÇÅ} I\nF : CategoryTheory.Functor I C\ninst‚úù¬π : CategoryTheory.Limits.HasColimit F\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape (Opposite I) (Type u‚ÇÇ)\nA : C\ni : I\nZ : Type u‚ÇÇ\nh : Quiver.Hom ((CategoryTheory.yoneda.obj A).obj (F.op.obj { unop := i })) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitHomIsoLimitYoneda F A).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.œÄ (F.op.comp (CategoryTheory.yoneda.obj A)) { unop := i }) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.coyoneda.map (CategoryTheory.Limits.colimit.Œπ F i).op).app A) h)","decl":"@[reassoc (attr := simp)]\nlemma colimitHomIsoLimitYoneda_hom_comp_œÄ [HasLimitsOfShape I·µí·µñ (Type u‚ÇÇ)] (A : C) (i : I) :\n    (colimitHomIsoLimitYoneda F A).hom ‚â´ limit.œÄ (F.op ‚ãô yoneda.obj A) ‚ü®i‚ü© =\n      (coyoneda.map (colimit.Œπ F i).op).app A := by\n  simp only [colimitHomIsoLimitYoneda, Iso.trans_hom, Iso.app_hom, Category.assoc]\n  erw [limitObjIsoLimitCompEvaluation_hom_œÄ]\n  change ((coyonedaOpColimitIsoLimitCoyoneda F).hom ‚â´ _).app A = _\n  rw [coyonedaOpColimitIsoLimitCoyoneda_hom_comp_œÄ]\n\n"}
{"name":"CategoryTheory.Limits.colimitHomIsoLimitYoneda_hom_comp_œÄ","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nI : Type v‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, v‚ÇÅ} I\nF : CategoryTheory.Functor I C\ninst‚úù¬π : CategoryTheory.Limits.HasColimit F\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape (Opposite I) (Type u‚ÇÇ)\nA : C\ni : I\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitHomIsoLimitYoneda F A).hom (CategoryTheory.Limits.limit.œÄ (F.op.comp (CategoryTheory.yoneda.obj A)) { unop := i })) ((CategoryTheory.coyoneda.map (CategoryTheory.Limits.colimit.Œπ F i).op).app A)","decl":"@[reassoc (attr := simp)]\nlemma colimitHomIsoLimitYoneda_hom_comp_œÄ [HasLimitsOfShape I·µí·µñ (Type u‚ÇÇ)] (A : C) (i : I) :\n    (colimitHomIsoLimitYoneda F A).hom ‚â´ limit.œÄ (F.op ‚ãô yoneda.obj A) ‚ü®i‚ü© =\n      (coyoneda.map (colimit.Œπ F i).op).app A := by\n  simp only [colimitHomIsoLimitYoneda, Iso.trans_hom, Iso.app_hom, Category.assoc]\n  erw [limitObjIsoLimitCompEvaluation_hom_œÄ]\n  change ((coyonedaOpColimitIsoLimitCoyoneda F).hom ‚â´ _).app A = _\n  rw [coyonedaOpColimitIsoLimitCoyoneda_hom_comp_œÄ]\n\n"}
{"name":"CategoryTheory.Limits.colimitHomIsoLimitYoneda_inv_comp_œÄ_assoc","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nI : Type v‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, v‚ÇÅ} I\nF : CategoryTheory.Functor I C\ninst‚úù¬π : CategoryTheory.Limits.HasColimit F\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape (Opposite I) (Type u‚ÇÇ)\nA : C\ni : I\nZ : Type u‚ÇÇ\nh : Quiver.Hom ((CategoryTheory.coyoneda.obj { unop := F.obj i }).obj A) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitHomIsoLimitYoneda F A).inv (CategoryTheory.CategoryStruct.comp ((CategoryTheory.coyoneda.map (CategoryTheory.Limits.colimit.Œπ F i).op).app A) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.œÄ (F.op.comp (CategoryTheory.yoneda.obj A)) { unop := i }) h)","decl":"@[reassoc (attr := simp)]\nlemma colimitHomIsoLimitYoneda_inv_comp_œÄ [HasLimitsOfShape I·µí·µñ (Type u‚ÇÇ)] (A : C) (i : I) :\n    (colimitHomIsoLimitYoneda F A).inv ‚â´ (coyoneda.map (colimit.Œπ F i).op).app A =\n      limit.œÄ (F.op ‚ãô yoneda.obj A) ‚ü®i‚ü© := by\n  rw [‚Üê colimitHomIsoLimitYoneda_hom_comp_œÄ, ‚Üê Category.assoc,\n    Iso.inv_hom_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.Limits.colimitHomIsoLimitYoneda_inv_comp_œÄ","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nI : Type v‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, v‚ÇÅ} I\nF : CategoryTheory.Functor I C\ninst‚úù¬π : CategoryTheory.Limits.HasColimit F\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape (Opposite I) (Type u‚ÇÇ)\nA : C\ni : I\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitHomIsoLimitYoneda F A).inv ((CategoryTheory.coyoneda.map (CategoryTheory.Limits.colimit.Œπ F i).op).app A)) (CategoryTheory.Limits.limit.œÄ (F.op.comp (CategoryTheory.yoneda.obj A)) { unop := i })","decl":"@[reassoc (attr := simp)]\nlemma colimitHomIsoLimitYoneda_inv_comp_œÄ [HasLimitsOfShape I·µí·µñ (Type u‚ÇÇ)] (A : C) (i : I) :\n    (colimitHomIsoLimitYoneda F A).inv ‚â´ (coyoneda.map (colimit.Œπ F i).op).app A =\n      limit.œÄ (F.op ‚ãô yoneda.obj A) ‚ü®i‚ü© := by\n  rw [‚Üê colimitHomIsoLimitYoneda_hom_comp_œÄ, ‚Üê Category.assoc,\n    Iso.inv_hom_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.Limits.coyonedaOpColimitIsoLimitCoyoneda'_hom_comp_œÄ","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nI : Type v‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, v‚ÇÅ} I\nF : CategoryTheory.Functor (Opposite I) C\ninst‚úù : CategoryTheory.Limits.HasColimit F\ni : I\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coyonedaOpColimitIsoLimitCoyoneda' F).hom (CategoryTheory.Limits.limit.œÄ (F.rightOp.comp CategoryTheory.coyoneda) i)) (CategoryTheory.coyoneda.map (CategoryTheory.Limits.colimit.Œπ F { unop := i }).op)","decl":"@[reassoc (attr := simp)]\nlemma coyonedaOpColimitIsoLimitCoyoneda'_hom_comp_œÄ (i : I) :\n    (coyonedaOpColimitIsoLimitCoyoneda' F).hom ‚â´ limit.œÄ (F.rightOp ‚ãô coyoneda) i =\n      coyoneda.map (colimit.Œπ F ‚ü®i‚ü©).op := by\n  simp only [coyonedaOpColimitIsoLimitCoyoneda', Functor.mapIso_symm, Iso.trans_hom, Iso.symm_hom,\n    Functor.mapIso_inv, Category.assoc, preservesLimitIso_hom_œÄ, ‚Üê Functor.map_comp,\n    limitRightOpIsoOpColimit_inv_comp_œÄ]\n\n"}
{"name":"CategoryTheory.Limits.coyonedaOpColimitIsoLimitCoyoneda'_hom_comp_œÄ_assoc","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nI : Type v‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, v‚ÇÅ} I\nF : CategoryTheory.Functor (Opposite I) C\ninst‚úù : CategoryTheory.Limits.HasColimit F\ni : I\nZ : CategoryTheory.Functor C (Type u‚ÇÇ)\nh : Quiver.Hom (CategoryTheory.coyoneda.obj (F.rightOp.obj i)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coyonedaOpColimitIsoLimitCoyoneda' F).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.œÄ (F.rightOp.comp CategoryTheory.coyoneda) i) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.coyoneda.map (CategoryTheory.Limits.colimit.Œπ F { unop := i }).op) h)","decl":"@[reassoc (attr := simp)]\nlemma coyonedaOpColimitIsoLimitCoyoneda'_hom_comp_œÄ (i : I) :\n    (coyonedaOpColimitIsoLimitCoyoneda' F).hom ‚â´ limit.œÄ (F.rightOp ‚ãô coyoneda) i =\n      coyoneda.map (colimit.Œπ F ‚ü®i‚ü©).op := by\n  simp only [coyonedaOpColimitIsoLimitCoyoneda', Functor.mapIso_symm, Iso.trans_hom, Iso.symm_hom,\n    Functor.mapIso_inv, Category.assoc, preservesLimitIso_hom_œÄ, ‚Üê Functor.map_comp,\n    limitRightOpIsoOpColimit_inv_comp_œÄ]\n\n"}
{"name":"CategoryTheory.Limits.coyonedaOpColimitIsoLimitCoyoneda'_inv_comp_œÄ","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nI : Type v‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, v‚ÇÅ} I\nF : CategoryTheory.Functor (Opposite I) C\ninst‚úù : CategoryTheory.Limits.HasColimit F\ni : I\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coyonedaOpColimitIsoLimitCoyoneda' F).inv (CategoryTheory.coyoneda.map (CategoryTheory.Limits.colimit.Œπ F { unop := i }).op)) (CategoryTheory.Limits.limit.œÄ (F.rightOp.comp CategoryTheory.coyoneda) i)","decl":"@[reassoc (attr := simp)]\nlemma coyonedaOpColimitIsoLimitCoyoneda'_inv_comp_œÄ (i : I) :\n    (coyonedaOpColimitIsoLimitCoyoneda' F).inv ‚â´ coyoneda.map (colimit.Œπ F ‚ü®i‚ü©).op =\n      limit.œÄ (F.rightOp ‚ãô coyoneda) i := by\n  rw [‚Üê coyonedaOpColimitIsoLimitCoyoneda'_hom_comp_œÄ, ‚Üê Category.assoc,\n    Iso.inv_hom_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.Limits.coyonedaOpColimitIsoLimitCoyoneda'_inv_comp_œÄ_assoc","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nI : Type v‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, v‚ÇÅ} I\nF : CategoryTheory.Functor (Opposite I) C\ninst‚úù : CategoryTheory.Limits.HasColimit F\ni : I\nZ : CategoryTheory.Functor C (Type u‚ÇÇ)\nh : Quiver.Hom (CategoryTheory.coyoneda.obj { unop := F.obj { unop := i } }) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coyonedaOpColimitIsoLimitCoyoneda' F).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.coyoneda.map (CategoryTheory.Limits.colimit.Œπ F { unop := i }).op) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.œÄ (F.rightOp.comp CategoryTheory.coyoneda) i) h)","decl":"@[reassoc (attr := simp)]\nlemma coyonedaOpColimitIsoLimitCoyoneda'_inv_comp_œÄ (i : I) :\n    (coyonedaOpColimitIsoLimitCoyoneda' F).inv ‚â´ coyoneda.map (colimit.Œπ F ‚ü®i‚ü©).op =\n      limit.œÄ (F.rightOp ‚ãô coyoneda) i := by\n  rw [‚Üê coyonedaOpColimitIsoLimitCoyoneda'_hom_comp_œÄ, ‚Üê Category.assoc,\n    Iso.inv_hom_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.Limits.colimitHomIsoLimitYoneda'_hom_comp_œÄ_assoc","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nI : Type v‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, v‚ÇÅ} I\nF : CategoryTheory.Functor (Opposite I) C\ninst‚úù¬π : CategoryTheory.Limits.HasColimit F\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape I (Type u‚ÇÇ)\nA : C\ni : I\nZ : Type u‚ÇÇ\nh : Quiver.Hom ((CategoryTheory.yoneda.obj A).obj (F.rightOp.obj i)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitHomIsoLimitYoneda' F A).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.œÄ (F.rightOp.comp (CategoryTheory.yoneda.obj A)) i) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.coyoneda.map (CategoryTheory.Limits.colimit.Œπ F { unop := i }).op).app A) h)","decl":"@[reassoc (attr := simp)]\nlemma colimitHomIsoLimitYoneda'_hom_comp_œÄ [HasLimitsOfShape I (Type u‚ÇÇ)] (A : C) (i : I) :\n    (colimitHomIsoLimitYoneda' F A).hom ‚â´ limit.œÄ (F.rightOp ‚ãô yoneda.obj A) i =\n      (coyoneda.map (colimit.Œπ F ‚ü®i‚ü©).op).app A := by\n  simp only [yoneda_obj_obj, colimitHomIsoLimitYoneda', Iso.trans_hom,\n    Iso.app_hom, Category.assoc]\n  erw [limitObjIsoLimitCompEvaluation_hom_œÄ]\n  change ((coyonedaOpColimitIsoLimitCoyoneda' F).hom ‚â´ _).app A = _\n  rw [coyonedaOpColimitIsoLimitCoyoneda'_hom_comp_œÄ]\n\n"}
{"name":"CategoryTheory.Limits.colimitHomIsoLimitYoneda'_hom_comp_œÄ","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nI : Type v‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, v‚ÇÅ} I\nF : CategoryTheory.Functor (Opposite I) C\ninst‚úù¬π : CategoryTheory.Limits.HasColimit F\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape I (Type u‚ÇÇ)\nA : C\ni : I\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitHomIsoLimitYoneda' F A).hom (CategoryTheory.Limits.limit.œÄ (F.rightOp.comp (CategoryTheory.yoneda.obj A)) i)) ((CategoryTheory.coyoneda.map (CategoryTheory.Limits.colimit.Œπ F { unop := i }).op).app A)","decl":"@[reassoc (attr := simp)]\nlemma colimitHomIsoLimitYoneda'_hom_comp_œÄ [HasLimitsOfShape I (Type u‚ÇÇ)] (A : C) (i : I) :\n    (colimitHomIsoLimitYoneda' F A).hom ‚â´ limit.œÄ (F.rightOp ‚ãô yoneda.obj A) i =\n      (coyoneda.map (colimit.Œπ F ‚ü®i‚ü©).op).app A := by\n  simp only [yoneda_obj_obj, colimitHomIsoLimitYoneda', Iso.trans_hom,\n    Iso.app_hom, Category.assoc]\n  erw [limitObjIsoLimitCompEvaluation_hom_œÄ]\n  change ((coyonedaOpColimitIsoLimitCoyoneda' F).hom ‚â´ _).app A = _\n  rw [coyonedaOpColimitIsoLimitCoyoneda'_hom_comp_œÄ]\n\n"}
{"name":"CategoryTheory.Limits.colimitHomIsoLimitYoneda'_inv_comp_œÄ_assoc","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nI : Type v‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, v‚ÇÅ} I\nF : CategoryTheory.Functor (Opposite I) C\ninst‚úù¬π : CategoryTheory.Limits.HasColimit F\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape I (Type u‚ÇÇ)\nA : C\ni : I\nZ : Type u‚ÇÇ\nh : Quiver.Hom ((CategoryTheory.coyoneda.obj { unop := F.obj { unop := i } }).obj A) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitHomIsoLimitYoneda' F A).inv (CategoryTheory.CategoryStruct.comp ((CategoryTheory.coyoneda.map (CategoryTheory.Limits.colimit.Œπ F { unop := i }).op).app A) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.œÄ (F.rightOp.comp (CategoryTheory.yoneda.obj A)) i) h)","decl":"@[reassoc (attr := simp)]\nlemma colimitHomIsoLimitYoneda'_inv_comp_œÄ [HasLimitsOfShape I (Type u‚ÇÇ)] (A : C) (i : I) :\n    (colimitHomIsoLimitYoneda' F A).inv ‚â´ (coyoneda.map (colimit.Œπ F ‚ü®i‚ü©).op).app A =\n      limit.œÄ (F.rightOp ‚ãô yoneda.obj A) i := by\n  rw [‚Üê colimitHomIsoLimitYoneda'_hom_comp_œÄ, ‚Üê Category.assoc,\n    Iso.inv_hom_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.Limits.colimitHomIsoLimitYoneda'_inv_comp_œÄ","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nI : Type v‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, v‚ÇÅ} I\nF : CategoryTheory.Functor (Opposite I) C\ninst‚úù¬π : CategoryTheory.Limits.HasColimit F\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape I (Type u‚ÇÇ)\nA : C\ni : I\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitHomIsoLimitYoneda' F A).inv ((CategoryTheory.coyoneda.map (CategoryTheory.Limits.colimit.Œπ F { unop := i }).op).app A)) (CategoryTheory.Limits.limit.œÄ (F.rightOp.comp (CategoryTheory.yoneda.obj A)) i)","decl":"@[reassoc (attr := simp)]\nlemma colimitHomIsoLimitYoneda'_inv_comp_œÄ [HasLimitsOfShape I (Type u‚ÇÇ)] (A : C) (i : I) :\n    (colimitHomIsoLimitYoneda' F A).inv ‚â´ (coyoneda.map (colimit.Œπ F ‚ü®i‚ü©).op).app A =\n      limit.œÄ (F.rightOp ‚ãô yoneda.obj A) i := by\n  rw [‚Üê colimitHomIsoLimitYoneda'_hom_comp_œÄ, ‚Üê Category.assoc,\n    Iso.inv_hom_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.Limits.colimitCoyonedaHomIsoLimit_œÄ_apply","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nI : Type v‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, v‚ÇÅ} I\nD : CategoryTheory.Functor (Opposite I) C\nF : CategoryTheory.Functor C (Type u‚ÇÇ)\ninst‚úù¬π : CategoryTheory.Limits.HasColimit (D.rightOp.comp CategoryTheory.coyoneda)\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape (Opposite I) (Type (max u‚ÇÅ u‚ÇÇ))\nf : Quiver.Hom (CategoryTheory.Limits.colimit (D.rightOp.comp CategoryTheory.coyoneda)) F\ni : I\n‚ä¢ Eq (CategoryTheory.Limits.limit.œÄ (D.comp (F.comp CategoryTheory.uliftFunctor.{u‚ÇÅ, u‚ÇÇ})) { unop := i } ((CategoryTheory.Limits.colimitCoyonedaHomIsoLimit D F).hom f)) { down := f.app (D.obj { unop := i }) ((CategoryTheory.Limits.colimit.Œπ (D.rightOp.comp CategoryTheory.coyoneda) i).app (D.obj { unop := i }) (CategoryTheory.CategoryStruct.id (D.obj { unop := i }))) }","decl":"@[simp]\nlemma colimitCoyonedaHomIsoLimit_œÄ_apply (f : colimit (D.rightOp ‚ãô coyoneda) ‚ü∂ F) (i : I) :\n    limit.œÄ (D ‚ãô F ‚ãô uliftFunctor.{u‚ÇÅ}) (op i) ((colimitCoyonedaHomIsoLimit D F).hom f) =\n      ‚ü®f.app (D.obj (op i)) ((colimit.Œπ (D.rightOp ‚ãô coyoneda) i).app (D.obj (op i))\n          (ùüô (D.obj (op i))))‚ü© := by\n  change ((colimitCoyonedaHomIsoLimit D F).hom ‚â´ (limit.œÄ (D ‚ãô F ‚ãô uliftFunctor.{u‚ÇÅ}) (op i))) f = _\n  simp only [colimitCoyonedaHomIsoLimit, Iso.trans_hom, Category.assoc,\n    HasLimit.isoOfNatIso_hom_œÄ]\n  rw [‚Üê Category.assoc, colimitHomIsoLimitYoneda_hom_comp_œÄ]\n  dsimp [coyonedaLemma, types_comp_apply]\n  erw [coyonedaEquiv_comp, coyonedaEquiv_apply]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.colimitCoyonedaHomIsoLimitLeftOp_œÄ_apply","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nI : Type v‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, v‚ÇÅ} I\nD : CategoryTheory.Functor I (Opposite C)\nF : CategoryTheory.Functor C (Type u‚ÇÇ)\ninst‚úù¬π : CategoryTheory.Limits.HasColimit (D.comp CategoryTheory.coyoneda)\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape (Opposite I) (Type (max u‚ÇÅ u‚ÇÇ))\nf : Quiver.Hom (CategoryTheory.Limits.colimit (D.comp CategoryTheory.coyoneda)) F\ni : I\n‚ä¢ Eq (CategoryTheory.Limits.limit.œÄ (D.leftOp.comp (F.comp CategoryTheory.uliftFunctor.{u‚ÇÅ, u‚ÇÇ})) { unop := i } ((CategoryTheory.Limits.colimitCoyonedaHomIsoLimitLeftOp D F).hom f)) { down := f.app (Opposite.unop (D.obj i)) ((CategoryTheory.Limits.colimit.Œπ (D.comp CategoryTheory.coyoneda) i).app (Opposite.unop (D.obj i)) (CategoryTheory.CategoryStruct.id (Opposite.unop (D.obj i)))) }","decl":"@[simp]\nlemma colimitCoyonedaHomIsoLimitLeftOp_œÄ_apply (f : colimit (D ‚ãô coyoneda) ‚ü∂ F) (i : I) :\n    limit.œÄ (D.leftOp ‚ãô F ‚ãô uliftFunctor.{u‚ÇÅ}) (op i)\n        ((colimitCoyonedaHomIsoLimitLeftOp D F).hom f) =\n      ‚ü®f.app (D.obj i).unop ((colimit.Œπ (D ‚ãô coyoneda) i).app (D.obj i).unop\n          (ùüô (D.obj i).unop))‚ü© :=\n  haveI : HasColimit (D.leftOp.rightOp ‚ãô coyoneda) :=\n    inferInstanceAs <| HasColimit (D ‚ãô coyoneda)\n  colimitCoyonedaHomIsoLimit_œÄ_apply _ _ _ _\n\n"}
{"name":"CategoryTheory.Limits.colimitYonedaHomIsoLimit_œÄ_apply","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nI : Type v‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, v‚ÇÅ} I\nD : CategoryTheory.Functor (Opposite I) (Opposite C)\nF : CategoryTheory.Functor (Opposite C) (Type u‚ÇÇ)\ninst‚úù¬π : CategoryTheory.Limits.HasColimit (D.unop.comp CategoryTheory.yoneda)\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape (Opposite I) (Type (max u‚ÇÅ u‚ÇÇ))\nf : Quiver.Hom (CategoryTheory.Limits.colimit (D.unop.comp CategoryTheory.yoneda)) F\ni : Opposite I\n‚ä¢ Eq (CategoryTheory.Limits.limit.œÄ (D.comp (F.comp CategoryTheory.uliftFunctor.{u‚ÇÅ, u‚ÇÇ})) i ((CategoryTheory.Limits.colimitYonedaHomIsoLimit D F).hom f)) { down := f.app (D.obj i) ((CategoryTheory.Limits.colimit.Œπ (D.unop.comp CategoryTheory.yoneda) (Opposite.unop i)).app (D.obj i) (CategoryTheory.CategoryStruct.id (Opposite.unop (D.obj i)))) }","decl":"@[simp]\nlemma colimitYonedaHomIsoLimit_œÄ_apply (f : colimit (D.unop ‚ãô yoneda) ‚ü∂ F) (i : I·µí·µñ) :\n    limit.œÄ (D ‚ãô F ‚ãô uliftFunctor.{u‚ÇÅ}) i ((colimitYonedaHomIsoLimit D F).hom f) =\n      ‚ü®f.app (D.obj i)\n        ((colimit.Œπ (D.unop ‚ãô yoneda) i.unop).app (D.obj i) (ùüô (D.obj i).unop))‚ü© := by\n  change ((colimitYonedaHomIsoLimit D F).hom ‚â´ (limit.œÄ (D ‚ãô F ‚ãô uliftFunctor.{u‚ÇÅ}) i)) f = _\n  simp only [colimitYonedaHomIsoLimit, Iso.trans_hom, Category.assoc, HasLimit.isoOfNatIso_hom_œÄ]\n  rw [‚Üê Category.assoc, colimitHomIsoLimitYoneda_hom_comp_œÄ]\n  dsimp [yonedaLemma]\n  erw [yonedaEquiv_comp, yonedaEquiv_apply]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.colimitYonedaHomIsoLimitOp_œÄ_apply","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nI : Type v‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, v‚ÇÅ} I\nD : CategoryTheory.Functor I C\nF : CategoryTheory.Functor (Opposite C) (Type u‚ÇÇ)\ninst‚úù¬π : CategoryTheory.Limits.HasColimit (D.comp CategoryTheory.yoneda)\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape (Opposite I) (Type (max u‚ÇÅ u‚ÇÇ))\nf : Quiver.Hom (CategoryTheory.Limits.colimit (D.comp CategoryTheory.yoneda)) F\ni : Opposite I\n‚ä¢ Eq (CategoryTheory.Limits.limit.œÄ (D.op.comp (F.comp CategoryTheory.uliftFunctor.{u‚ÇÅ, u‚ÇÇ})) i ((CategoryTheory.Limits.colimitYonedaHomIsoLimitOp D F).hom f)) { down := f.app { unop := D.obj (Opposite.unop i) } ((CategoryTheory.Limits.colimit.Œπ (D.comp CategoryTheory.yoneda) (Opposite.unop i)).app { unop := D.obj (Opposite.unop i) } (CategoryTheory.CategoryStruct.id (D.obj (Opposite.unop i)))) }","decl":"@[simp]\nlemma colimitYonedaHomIsoLimitOp_œÄ_apply (f : colimit (D ‚ãô yoneda) ‚ü∂ F) (i : I·µí·µñ) :\n    limit.œÄ (D.op ‚ãô F ‚ãô uliftFunctor.{u‚ÇÅ}) i ((colimitYonedaHomIsoLimitOp D F).hom f) =\n      ‚ü®f.app (op (D.obj i.unop))\n        ((colimit.Œπ (D ‚ãô yoneda) i.unop).app (op (D.obj i.unop)) (ùüô (D.obj i.unop)))‚ü© :=\n  haveI : HasColimit (D.op.unop ‚ãô yoneda) :=\n    inferInstanceAs <| HasColimit (D ‚ãô yoneda)\n  colimitYonedaHomIsoLimit_œÄ_apply _ _ _ _\n\n"}
{"name":"CategoryTheory.Limits.colimitCoyonedaHomIsoLimit'_œÄ_apply","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nI : Type v‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, v‚ÇÅ} I\nD : CategoryTheory.Functor I C\nF : CategoryTheory.Functor C (Type u‚ÇÇ)\ninst‚úù¬π : CategoryTheory.Limits.HasColimit (D.op.comp CategoryTheory.coyoneda)\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape I (Type (max u‚ÇÅ u‚ÇÇ))\nf : Quiver.Hom (CategoryTheory.Limits.colimit (D.op.comp CategoryTheory.coyoneda)) F\ni : I\n‚ä¢ Eq (CategoryTheory.Limits.limit.œÄ (D.comp (F.comp CategoryTheory.uliftFunctor.{u‚ÇÅ, u‚ÇÇ})) i ((CategoryTheory.Limits.colimitCoyonedaHomIsoLimit' D F).hom f)) { down := f.app (D.obj i) ((CategoryTheory.Limits.colimit.Œπ (D.op.comp CategoryTheory.coyoneda) { unop := i }).app (D.obj i) (CategoryTheory.CategoryStruct.id (D.obj i))) }","decl":"@[simp]\nlemma colimitCoyonedaHomIsoLimit'_œÄ_apply (f : colimit (D.op ‚ãô coyoneda) ‚ü∂ F) (i : I) :\n    limit.œÄ (D ‚ãô F ‚ãô uliftFunctor.{u‚ÇÅ}) i ((colimitCoyonedaHomIsoLimit' D F).hom f) =\n      ‚ü®f.app (D.obj i) ((colimit.Œπ (D.op ‚ãô coyoneda) ‚ü®i‚ü©).app (D.obj i) (ùüô (D.obj i)))‚ü© := by\n  change ((colimitCoyonedaHomIsoLimit' D F).hom ‚â´ (limit.œÄ (D ‚ãô F ‚ãô uliftFunctor.{u‚ÇÅ}) i)) f = _\n  simp only [colimitCoyonedaHomIsoLimit', Iso.trans_hom, Category.assoc, HasLimit.isoOfNatIso_hom_œÄ]\n  rw [‚Üê Category.assoc, colimitHomIsoLimitYoneda'_hom_comp_œÄ]\n  dsimp [coyonedaLemma]\n  erw [coyonedaEquiv_comp, coyonedaEquiv_apply]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.colimitCoyonedaHomIsoLimitUnop_œÄ_apply","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nI : Type v‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, v‚ÇÅ} I\nD : CategoryTheory.Functor (Opposite I) (Opposite C)\nF : CategoryTheory.Functor C (Type u‚ÇÇ)\ninst‚úù¬π : CategoryTheory.Limits.HasColimit (D.comp CategoryTheory.coyoneda)\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape I (Type (max u‚ÇÅ u‚ÇÇ))\nf : Quiver.Hom (CategoryTheory.Limits.colimit (D.comp CategoryTheory.coyoneda)) F\ni : I\n‚ä¢ Eq (CategoryTheory.Limits.limit.œÄ (D.unop.comp (F.comp CategoryTheory.uliftFunctor.{u‚ÇÅ, u‚ÇÇ})) i ((CategoryTheory.Limits.colimitCoyonedaHomIsoLimitUnop D F).hom f)) { down := f.app (Opposite.unop (D.obj { unop := i })) ((CategoryTheory.Limits.colimit.Œπ (D.comp CategoryTheory.coyoneda) { unop := i }).app (Opposite.unop (D.obj { unop := i })) (CategoryTheory.CategoryStruct.id (Opposite.unop (D.obj { unop := i })))) }","decl":"@[simp]\nlemma colimitCoyonedaHomIsoLimitUnop_œÄ_apply (f : colimit (D ‚ãô coyoneda) ‚ü∂ F) (i : I) :\n    limit.œÄ (D.unop ‚ãô F ‚ãô uliftFunctor.{u‚ÇÅ}) i ((colimitCoyonedaHomIsoLimitUnop D F).hom f) =\n      ‚ü®f.app (D.obj (op i)).unop\n          ((colimit.Œπ (D ‚ãô coyoneda) ‚ü®i‚ü©).app (D.obj (op i)).unop (ùüô (D.obj (op i)).unop))‚ü© :=\n  haveI : HasColimit (D.unop.op ‚ãô coyoneda) :=\n    inferInstanceAs <| HasColimit (D ‚ãô coyoneda)\n  colimitCoyonedaHomIsoLimit'_œÄ_apply _ _ _ _\n\n"}
{"name":"CategoryTheory.Limits.colimitYonedaHomIsoLimit'_œÄ_apply","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nI : Type v‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, v‚ÇÅ} I\nD : CategoryTheory.Functor I (Opposite C)\nF : CategoryTheory.Functor (Opposite C) (Type u‚ÇÇ)\ninst‚úù¬π : CategoryTheory.Limits.HasColimit (D.leftOp.comp CategoryTheory.yoneda)\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape I (Type (max u‚ÇÅ u‚ÇÇ))\nf : Quiver.Hom (CategoryTheory.Limits.colimit (D.leftOp.comp CategoryTheory.yoneda)) F\ni : I\n‚ä¢ Eq (CategoryTheory.Limits.limit.œÄ (D.comp (F.comp CategoryTheory.uliftFunctor.{u‚ÇÅ, u‚ÇÇ})) i ((CategoryTheory.Limits.colimitYonedaHomIsoLimit' D F).hom f)) { down := f.app (D.obj i) ((CategoryTheory.Limits.colimit.Œπ (D.leftOp.comp CategoryTheory.yoneda) { unop := i }).app (D.obj i) (CategoryTheory.CategoryStruct.id (Opposite.unop (D.obj i)))) }","decl":"@[simp]\nlemma colimitYonedaHomIsoLimit'_œÄ_apply (f : colimit (D.leftOp ‚ãô yoneda) ‚ü∂ F) (i : I) :\n    limit.œÄ (D ‚ãô F ‚ãô uliftFunctor.{u‚ÇÅ}) i ((colimitYonedaHomIsoLimit' D F).hom f) =\n      ‚ü®f.app (D.obj i)\n        ((colimit.Œπ (D.leftOp ‚ãô yoneda) (op i)).app (D.obj i) (ùüô (D.obj i).unop))‚ü© := by\n  change ((colimitYonedaHomIsoLimit' D F).hom ‚â´ (limit.œÄ (D ‚ãô F ‚ãô uliftFunctor.{u‚ÇÅ}) i)) f = _\n  simp only [colimitYonedaHomIsoLimit', Iso.trans_hom, Category.assoc, HasLimit.isoOfNatIso_hom_œÄ]\n  rw [‚Üê Category.assoc, colimitHomIsoLimitYoneda'_hom_comp_œÄ]\n  dsimp [yonedaLemma]\n  erw [yonedaEquiv_comp, yonedaEquiv_apply]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.colimitYonedaHomIsoLimitRightOp_œÄ_apply","module":"Mathlib.CategoryTheory.Limits.IndYoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nI : Type v‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, v‚ÇÅ} I\nD : CategoryTheory.Functor (Opposite I) C\nF : CategoryTheory.Functor (Opposite C) (Type u‚ÇÇ)\ninst‚úù¬π : CategoryTheory.Limits.HasColimit (D.comp CategoryTheory.yoneda)\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape I (Type (max u‚ÇÅ u‚ÇÇ))\nf : Quiver.Hom (CategoryTheory.Limits.colimit (D.comp CategoryTheory.yoneda)) F\ni : I\n‚ä¢ Eq (CategoryTheory.Limits.limit.œÄ (D.rightOp.comp (F.comp CategoryTheory.uliftFunctor.{u‚ÇÅ, u‚ÇÇ})) i ((CategoryTheory.Limits.colimitYonedaHomIsoLimitRightOp D F).hom f)) { down := f.app { unop := D.obj { unop := i } } ((CategoryTheory.Limits.colimit.Œπ (D.comp CategoryTheory.yoneda) { unop := i }).app { unop := D.obj { unop := i } } (CategoryTheory.CategoryStruct.id (D.obj { unop := i }))) }","decl":"@[simp]\nlemma colimitYonedaHomIsoLimitRightOp_œÄ_apply (f : colimit (D ‚ãô yoneda) ‚ü∂ F) (i : I) :\n    limit.œÄ (D.rightOp ‚ãô F ‚ãô uliftFunctor.{u‚ÇÅ}) i ((colimitYonedaHomIsoLimitRightOp D F).hom f) =\n      ‚ü®f.app (op (D.obj (op i)))\n        ((colimit.Œπ (D ‚ãô yoneda) (op i)).app (op (D.obj (op i))) (ùüô (D.obj (op i))))‚ü© :=\n  haveI : HasColimit (D.rightOp.leftOp ‚ãô yoneda) :=\n    inferInstanceAs <| HasColimit (D ‚ãô yoneda)\n  colimitYonedaHomIsoLimit'_œÄ_apply _ _ _ _\n\n"}
