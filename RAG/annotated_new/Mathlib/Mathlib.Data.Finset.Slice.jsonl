{"name":"Set.Sized.mono","module":"Mathlib.Data.Finset.Slice","initialProofState":"Î± : Type u_1\nA B : Set (Finset Î±)\nr : Nat\nh : HasSubset.Subset A B\nhB : Set.Sized r B\nâŠ¢ Set.Sized r A","decl":"theorem Sized.mono (h : A âŠ† B) (hB : B.Sized r) : A.Sized r := fun _x hx => hB <| h hx\n\n"}
{"name":"Set.sized_empty","module":"Mathlib.Data.Finset.Slice","initialProofState":"Î± : Type u_1\nr : Nat\nâŠ¢ Set.Sized r EmptyCollection.emptyCollection","decl":"@[simp] lemma sized_empty : (âˆ… : Set (Finset Î±)).Sized r := by simp [Sized]\n"}
{"name":"Set.sized_singleton","module":"Mathlib.Data.Finset.Slice","initialProofState":"Î± : Type u_1\ns : Finset Î±\nr : Nat\nâŠ¢ Iff (Set.Sized r (Singleton.singleton s)) (Eq s.card r)","decl":"@[simp] lemma sized_singleton : ({s} : Set (Finset Î±)).Sized r â†” #s = r := by simp [Sized]\n\n"}
{"name":"Set.sized_union","module":"Mathlib.Data.Finset.Slice","initialProofState":"Î± : Type u_1\nA B : Set (Finset Î±)\nr : Nat\nâŠ¢ Iff (Set.Sized r (Union.union A B)) (And (Set.Sized r A) (Set.Sized r B))","decl":"theorem sized_union : (A âˆª B).Sized r â†” A.Sized r âˆ§ B.Sized r :=\n  âŸ¨fun hA => âŸ¨hA.mono subset_union_left, hA.mono subset_union_rightâŸ©, fun hA _x hx =>\n    hx.elim (fun h => hA.1 h) fun h => hA.2 hâŸ©\n\n"}
{"name":"Set.sized.union","module":"Mathlib.Data.Finset.Slice","initialProofState":"Î± : Type u_1\nA B : Set (Finset Î±)\nr : Nat\naâœ : And (Set.Sized r A) (Set.Sized r B)\nâŠ¢ Set.Sized r (Union.union A B)","decl":"alias âŸ¨_, sized.unionâŸ© := sized_union\n\n--TODO: A `forall_iUnion` lemma would be handy here.\n"}
{"name":"Set.sized_iUnion","module":"Mathlib.Data.Finset.Slice","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_2\nr : Nat\nf : Î¹ â†’ Set (Finset Î±)\nâŠ¢ Iff (Set.Sized r (Set.iUnion fun i => f i)) (âˆ€ (i : Î¹), Set.Sized r (f i))","decl":"@[simp]\ntheorem sized_iUnion {f : Î¹ â†’ Set (Finset Î±)} : (â‹ƒ i, f i).Sized r â†” âˆ€ i, (f i).Sized r := by\n  simp_rw [Set.Sized, Set.mem_iUnion, forall_exists_index]\n  exact forall_swap\n\n-- @[simp] -- Porting note: left hand side is not simp-normal form.\n"}
{"name":"Set.sized_iUnionâ‚‚","module":"Mathlib.Data.Finset.Slice","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_2\nÎº : Î¹ â†’ Sort u_3\nr : Nat\nf : (i : Î¹) â†’ Îº i â†’ Set (Finset Î±)\nâŠ¢ Iff (Set.Sized r (Set.iUnion fun i => Set.iUnion fun j => f i j)) (âˆ€ (i : Î¹) (j : Îº i), Set.Sized r (f i j))","decl":"theorem sized_iUnionâ‚‚ {f : âˆ€ i, Îº i â†’ Set (Finset Î±)} :\n    (â‹ƒ (i) (j), f i j).Sized r â†” âˆ€ i j, (f i j).Sized r := by\n simp only [Set.sized_iUnion]\n\n"}
{"name":"Set.Sized.isAntichain","module":"Mathlib.Data.Finset.Slice","initialProofState":"Î± : Type u_1\nA : Set (Finset Î±)\nr : Nat\nhA : Set.Sized r A\nâŠ¢ IsAntichain (fun x1 x2 => HasSubset.Subset x1 x2) A","decl":"protected theorem Sized.isAntichain (hA : A.Sized r) : IsAntichain (Â· âŠ† Â·) A :=\n  fun _s hs _t ht h hst => h <| Finset.eq_of_subset_of_card_le hst ((hA ht).trans (hA hs).symm).le\n\n"}
{"name":"Set.Sized.subsingleton","module":"Mathlib.Data.Finset.Slice","initialProofState":"Î± : Type u_1\nA : Set (Finset Î±)\nhA : Set.Sized 0 A\nâŠ¢ A.Subsingleton","decl":"protected theorem Sized.subsingleton (hA : A.Sized 0) : A.Subsingleton :=\n  subsingleton_of_forall_eq âˆ… fun _s hs => card_eq_zero.1 <| hA hs\n\n"}
{"name":"Set.Sized.subsingleton'","module":"Mathlib.Data.Finset.Slice","initialProofState":"Î± : Type u_1\nA : Set (Finset Î±)\ninstâœ : Fintype Î±\nhA : Set.Sized (Fintype.card Î±) A\nâŠ¢ A.Subsingleton","decl":"theorem Sized.subsingleton' [Fintype Î±] (hA : A.Sized (Fintype.card Î±)) : A.Subsingleton :=\n  subsingleton_of_forall_eq Finset.univ fun s hs => s.card_eq_iff_eq_univ.1 <| hA hs\n\n"}
{"name":"Set.Sized.empty_mem_iff","module":"Mathlib.Data.Finset.Slice","initialProofState":"Î± : Type u_1\nA : Set (Finset Î±)\nr : Nat\nhA : Set.Sized r A\nâŠ¢ Iff (Membership.mem A EmptyCollection.emptyCollection) (Eq A (Singleton.singleton EmptyCollection.emptyCollection))","decl":"theorem Sized.empty_mem_iff (hA : A.Sized r) : âˆ… âˆˆ A â†” A = {âˆ…} :=\n  hA.isAntichain.bot_mem_iff\n\n"}
{"name":"Set.Sized.univ_mem_iff","module":"Mathlib.Data.Finset.Slice","initialProofState":"Î± : Type u_1\nA : Set (Finset Î±)\nr : Nat\ninstâœ : Fintype Î±\nhA : Set.Sized r A\nâŠ¢ Iff (Membership.mem A Finset.univ) (Eq A (Singleton.singleton Finset.univ))","decl":"theorem Sized.univ_mem_iff [Fintype Î±] (hA : A.Sized r) : Finset.univ âˆˆ A â†” A = {Finset.univ} :=\n  hA.isAntichain.top_mem_iff\n\n"}
{"name":"Set.sized_powersetCard","module":"Mathlib.Data.Finset.Slice","initialProofState":"Î± : Type u_1\ns : Finset Î±\nr : Nat\nâŠ¢ Set.Sized r â†‘(Finset.powersetCard r s)","decl":"theorem sized_powersetCard (s : Finset Î±) (r : â„•) : (powersetCard r s : Set (Finset Î±)).Sized r :=\n  fun _t ht => (mem_powersetCard.1 ht).2\n\n"}
{"name":"Finset.subset_powersetCard_univ_iff","module":"Mathlib.Data.Finset.Slice","initialProofState":"Î± : Type u_1\ninstâœ : Fintype Î±\nğ’œ : Finset (Finset Î±)\nr : Nat\nâŠ¢ Iff (HasSubset.Subset ğ’œ (Finset.powersetCard r Finset.univ)) (Set.Sized r â†‘ğ’œ)","decl":"theorem subset_powersetCard_univ_iff : ğ’œ âŠ† powersetCard r univ â†” (ğ’œ : Set (Finset Î±)).Sized r :=\n  forall_congr' fun A => by rw [mem_powersetCard_univ, mem_coe]\n\n"}
{"name":"Set.Sized.subset_powersetCard_univ","module":"Mathlib.Data.Finset.Slice","initialProofState":"Î± : Type u_1\ninstâœ : Fintype Î±\nğ’œ : Finset (Finset Î±)\nr : Nat\naâœ : Set.Sized r â†‘ğ’œ\nâŠ¢ HasSubset.Subset ğ’œ (Finset.powersetCard r Finset.univ)","decl":"alias âŸ¨_, _root_.Set.Sized.subset_powersetCard_univâŸ© := subset_powersetCard_univ_iff\n\n"}
{"name":"Set.Sized.card_le","module":"Mathlib.Data.Finset.Slice","initialProofState":"Î± : Type u_1\ninstâœ : Fintype Î±\nğ’œ : Finset (Finset Î±)\nr : Nat\nhğ’œ : Set.Sized r â†‘ğ’œ\nâŠ¢ LE.le ğ’œ.card ((Fintype.card Î±).choose r)","decl":"theorem _root_.Set.Sized.card_le (hğ’œ : (ğ’œ : Set (Finset Î±)).Sized r) :\n    #ğ’œ â‰¤ (Fintype.card Î±).choose r := by\n  rw [Fintype.card, â† card_powersetCard]\n  exact card_le_card (subset_powersetCard_univ_iff.mpr hğ’œ)\n\n"}
{"name":"Finset.mem_slice","module":"Mathlib.Data.Finset.Slice","initialProofState":"Î± : Type u_1\nğ’œ : Finset (Finset Î±)\nA : Finset Î±\nr : Nat\nâŠ¢ Iff (Membership.mem (ğ’œ.slice r) A) (And (Membership.mem ğ’œ A) (Eq A.card r))","decl":"/-- `A` is in the `r`-th slice of `ğ’œ` iff it's in `ğ’œ` and has cardinality `r`. -/\ntheorem mem_slice : A âˆˆ ğ’œ # r â†” A âˆˆ ğ’œ âˆ§ #A = r :=\n  mem_filter\n\n"}
{"name":"Finset.slice_subset","module":"Mathlib.Data.Finset.Slice","initialProofState":"Î± : Type u_1\nğ’œ : Finset (Finset Î±)\nr : Nat\nâŠ¢ HasSubset.Subset (ğ’œ.slice r) ğ’œ","decl":"/-- The `r`-th slice of `ğ’œ` is a subset of `ğ’œ`. -/\ntheorem slice_subset : ğ’œ # r âŠ† ğ’œ :=\n  filter_subset _ _\n\n"}
{"name":"Finset.sized_slice","module":"Mathlib.Data.Finset.Slice","initialProofState":"Î± : Type u_1\nğ’œ : Finset (Finset Î±)\nr : Nat\nâŠ¢ Set.Sized r â†‘(ğ’œ.slice r)","decl":"/-- Everything in the `r`-th slice of `ğ’œ` has size `r`. -/\ntheorem sized_slice : (ğ’œ # r : Set (Finset Î±)).Sized r := fun _ => And.right âˆ˜ mem_slice.mp\n\n"}
{"name":"Finset.eq_of_mem_slice","module":"Mathlib.Data.Finset.Slice","initialProofState":"Î± : Type u_1\nğ’œ : Finset (Finset Î±)\nA : Finset Î±\nrâ‚ râ‚‚ : Nat\nhâ‚ : Membership.mem (ğ’œ.slice râ‚) A\nhâ‚‚ : Membership.mem (ğ’œ.slice râ‚‚) A\nâŠ¢ Eq râ‚ râ‚‚","decl":"theorem eq_of_mem_slice (hâ‚ : A âˆˆ ğ’œ # râ‚) (hâ‚‚ : A âˆˆ ğ’œ # râ‚‚) : râ‚ = râ‚‚ :=\n  (sized_slice hâ‚).symm.trans <| sized_slice hâ‚‚\n\n"}
{"name":"Finset.ne_of_mem_slice","module":"Mathlib.Data.Finset.Slice","initialProofState":"Î± : Type u_1\nğ’œ : Finset (Finset Î±)\nAâ‚ Aâ‚‚ : Finset Î±\nrâ‚ râ‚‚ : Nat\nhâ‚ : Membership.mem (ğ’œ.slice râ‚) Aâ‚\nhâ‚‚ : Membership.mem (ğ’œ.slice râ‚‚) Aâ‚‚\naâœ : Ne râ‚ râ‚‚\nâŠ¢ Ne Aâ‚ Aâ‚‚","decl":"/-- Elements in distinct slices must be distinct. -/\ntheorem ne_of_mem_slice (hâ‚ : Aâ‚ âˆˆ ğ’œ # râ‚) (hâ‚‚ : Aâ‚‚ âˆˆ ğ’œ # râ‚‚) : râ‚ â‰  râ‚‚ â†’ Aâ‚ â‰  Aâ‚‚ :=\n  mt fun h => (sized_slice hâ‚).symm.trans ((congr_arg card h).trans (sized_slice hâ‚‚))\n\n"}
{"name":"Finset.pairwiseDisjoint_slice","module":"Mathlib.Data.Finset.Slice","initialProofState":"Î± : Type u_1\nğ’œ : Finset (Finset Î±)\nâŠ¢ Set.univ.PairwiseDisjoint ğ’œ.slice","decl":"theorem pairwiseDisjoint_slice : (Set.univ : Set â„•).PairwiseDisjoint (slice ğ’œ) := fun _ _ _ _ hmn =>\n  disjoint_filter.2 fun _s _hs hm hn => hmn <| hm.symm.trans hn\n\n"}
{"name":"Finset.biUnion_slice","module":"Mathlib.Data.Finset.Slice","initialProofState":"Î± : Type u_1\nğ’œ : Finset (Finset Î±)\ninstâœÂ¹ : Fintype Î±\ninstâœ : DecidableEq Î±\nâŠ¢ Eq ((Finset.Iic (Fintype.card Î±)).biUnion ğ’œ.slice) ğ’œ","decl":"@[simp]\ntheorem biUnion_slice [DecidableEq Î±] : (Iic <| Fintype.card Î±).biUnion ğ’œ.slice = ğ’œ :=\n  Subset.antisymm (biUnion_subset.2 fun _r _ => slice_subset) fun s hs =>\n    mem_biUnion.2 âŸ¨#s, mem_Iic.2 <| s.card_le_univ, mem_slice.2 <| âŸ¨hs, rflâŸ©âŸ©\n\n"}
{"name":"Finset.sum_card_slice","module":"Mathlib.Data.Finset.Slice","initialProofState":"Î± : Type u_1\nğ’œ : Finset (Finset Î±)\ninstâœ : Fintype Î±\nâŠ¢ Eq ((Finset.Iic (Fintype.card Î±)).sum fun r => (ğ’œ.slice r).card) ğ’œ.card","decl":"@[simp]\ntheorem sum_card_slice : âˆ‘ r âˆˆ Iic (Fintype.card Î±), #(ğ’œ # r) = #ğ’œ := by\n  letI := Classical.decEq Î±\n  rw [â† card_biUnion, biUnion_slice]\n  exact Finset.pairwiseDisjoint_slice.subset (Set.subset_univ _)\n\n"}
