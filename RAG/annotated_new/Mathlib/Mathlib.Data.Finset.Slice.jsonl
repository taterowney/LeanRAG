{"name":"Set.Sized.mono","module":"Mathlib.Data.Finset.Slice","initialProofState":"α : Type u_1\nA B : Set (Finset α)\nr : Nat\nh : HasSubset.Subset A B\nhB : Set.Sized r B\n⊢ Set.Sized r A","decl":"theorem Sized.mono (h : A ⊆ B) (hB : B.Sized r) : A.Sized r := fun _x hx => hB <| h hx\n\n"}
{"name":"Set.sized_empty","module":"Mathlib.Data.Finset.Slice","initialProofState":"α : Type u_1\nr : Nat\n⊢ Set.Sized r EmptyCollection.emptyCollection","decl":"@[simp] lemma sized_empty : (∅ : Set (Finset α)).Sized r := by simp [Sized]\n"}
{"name":"Set.sized_singleton","module":"Mathlib.Data.Finset.Slice","initialProofState":"α : Type u_1\ns : Finset α\nr : Nat\n⊢ Iff (Set.Sized r (Singleton.singleton s)) (Eq s.card r)","decl":"@[simp] lemma sized_singleton : ({s} : Set (Finset α)).Sized r ↔ #s = r := by simp [Sized]\n\n"}
{"name":"Set.sized_union","module":"Mathlib.Data.Finset.Slice","initialProofState":"α : Type u_1\nA B : Set (Finset α)\nr : Nat\n⊢ Iff (Set.Sized r (Union.union A B)) (And (Set.Sized r A) (Set.Sized r B))","decl":"theorem sized_union : (A ∪ B).Sized r ↔ A.Sized r ∧ B.Sized r :=\n  ⟨fun hA => ⟨hA.mono subset_union_left, hA.mono subset_union_right⟩, fun hA _x hx =>\n    hx.elim (fun h => hA.1 h) fun h => hA.2 h⟩\n\n"}
{"name":"Set.sized.union","module":"Mathlib.Data.Finset.Slice","initialProofState":"α : Type u_1\nA B : Set (Finset α)\nr : Nat\na✝ : And (Set.Sized r A) (Set.Sized r B)\n⊢ Set.Sized r (Union.union A B)","decl":"alias ⟨_, sized.union⟩ := sized_union\n\n--TODO: A `forall_iUnion` lemma would be handy here.\n"}
{"name":"Set.sized_iUnion","module":"Mathlib.Data.Finset.Slice","initialProofState":"α : Type u_1\nι : Sort u_2\nr : Nat\nf : ι → Set (Finset α)\n⊢ Iff (Set.Sized r (Set.iUnion fun i => f i)) (∀ (i : ι), Set.Sized r (f i))","decl":"@[simp]\ntheorem sized_iUnion {f : ι → Set (Finset α)} : (⋃ i, f i).Sized r ↔ ∀ i, (f i).Sized r := by\n  simp_rw [Set.Sized, Set.mem_iUnion, forall_exists_index]\n  exact forall_swap\n\n-- @[simp] -- Porting note: left hand side is not simp-normal form.\n"}
{"name":"Set.sized_iUnion₂","module":"Mathlib.Data.Finset.Slice","initialProofState":"α : Type u_1\nι : Sort u_2\nκ : ι → Sort u_3\nr : Nat\nf : (i : ι) → κ i → Set (Finset α)\n⊢ Iff (Set.Sized r (Set.iUnion fun i => Set.iUnion fun j => f i j)) (∀ (i : ι) (j : κ i), Set.Sized r (f i j))","decl":"theorem sized_iUnion₂ {f : ∀ i, κ i → Set (Finset α)} :\n    (⋃ (i) (j), f i j).Sized r ↔ ∀ i j, (f i j).Sized r := by\n simp only [Set.sized_iUnion]\n\n"}
{"name":"Set.Sized.isAntichain","module":"Mathlib.Data.Finset.Slice","initialProofState":"α : Type u_1\nA : Set (Finset α)\nr : Nat\nhA : Set.Sized r A\n⊢ IsAntichain (fun x1 x2 => HasSubset.Subset x1 x2) A","decl":"protected theorem Sized.isAntichain (hA : A.Sized r) : IsAntichain (· ⊆ ·) A :=\n  fun _s hs _t ht h hst => h <| Finset.eq_of_subset_of_card_le hst ((hA ht).trans (hA hs).symm).le\n\n"}
{"name":"Set.Sized.subsingleton","module":"Mathlib.Data.Finset.Slice","initialProofState":"α : Type u_1\nA : Set (Finset α)\nhA : Set.Sized 0 A\n⊢ A.Subsingleton","decl":"protected theorem Sized.subsingleton (hA : A.Sized 0) : A.Subsingleton :=\n  subsingleton_of_forall_eq ∅ fun _s hs => card_eq_zero.1 <| hA hs\n\n"}
{"name":"Set.Sized.subsingleton'","module":"Mathlib.Data.Finset.Slice","initialProofState":"α : Type u_1\nA : Set (Finset α)\ninst✝ : Fintype α\nhA : Set.Sized (Fintype.card α) A\n⊢ A.Subsingleton","decl":"theorem Sized.subsingleton' [Fintype α] (hA : A.Sized (Fintype.card α)) : A.Subsingleton :=\n  subsingleton_of_forall_eq Finset.univ fun s hs => s.card_eq_iff_eq_univ.1 <| hA hs\n\n"}
{"name":"Set.Sized.empty_mem_iff","module":"Mathlib.Data.Finset.Slice","initialProofState":"α : Type u_1\nA : Set (Finset α)\nr : Nat\nhA : Set.Sized r A\n⊢ Iff (Membership.mem A EmptyCollection.emptyCollection) (Eq A (Singleton.singleton EmptyCollection.emptyCollection))","decl":"theorem Sized.empty_mem_iff (hA : A.Sized r) : ∅ ∈ A ↔ A = {∅} :=\n  hA.isAntichain.bot_mem_iff\n\n"}
{"name":"Set.Sized.univ_mem_iff","module":"Mathlib.Data.Finset.Slice","initialProofState":"α : Type u_1\nA : Set (Finset α)\nr : Nat\ninst✝ : Fintype α\nhA : Set.Sized r A\n⊢ Iff (Membership.mem A Finset.univ) (Eq A (Singleton.singleton Finset.univ))","decl":"theorem Sized.univ_mem_iff [Fintype α] (hA : A.Sized r) : Finset.univ ∈ A ↔ A = {Finset.univ} :=\n  hA.isAntichain.top_mem_iff\n\n"}
{"name":"Set.sized_powersetCard","module":"Mathlib.Data.Finset.Slice","initialProofState":"α : Type u_1\ns : Finset α\nr : Nat\n⊢ Set.Sized r ↑(Finset.powersetCard r s)","decl":"theorem sized_powersetCard (s : Finset α) (r : ℕ) : (powersetCard r s : Set (Finset α)).Sized r :=\n  fun _t ht => (mem_powersetCard.1 ht).2\n\n"}
{"name":"Finset.subset_powersetCard_univ_iff","module":"Mathlib.Data.Finset.Slice","initialProofState":"α : Type u_1\ninst✝ : Fintype α\n𝒜 : Finset (Finset α)\nr : Nat\n⊢ Iff (HasSubset.Subset 𝒜 (Finset.powersetCard r Finset.univ)) (Set.Sized r ↑𝒜)","decl":"theorem subset_powersetCard_univ_iff : 𝒜 ⊆ powersetCard r univ ↔ (𝒜 : Set (Finset α)).Sized r :=\n  forall_congr' fun A => by rw [mem_powersetCard_univ, mem_coe]\n\n"}
{"name":"Set.Sized.subset_powersetCard_univ","module":"Mathlib.Data.Finset.Slice","initialProofState":"α : Type u_1\ninst✝ : Fintype α\n𝒜 : Finset (Finset α)\nr : Nat\na✝ : Set.Sized r ↑𝒜\n⊢ HasSubset.Subset 𝒜 (Finset.powersetCard r Finset.univ)","decl":"alias ⟨_, _root_.Set.Sized.subset_powersetCard_univ⟩ := subset_powersetCard_univ_iff\n\n"}
{"name":"Set.Sized.card_le","module":"Mathlib.Data.Finset.Slice","initialProofState":"α : Type u_1\ninst✝ : Fintype α\n𝒜 : Finset (Finset α)\nr : Nat\nh𝒜 : Set.Sized r ↑𝒜\n⊢ LE.le 𝒜.card ((Fintype.card α).choose r)","decl":"theorem _root_.Set.Sized.card_le (h𝒜 : (𝒜 : Set (Finset α)).Sized r) :\n    #𝒜 ≤ (Fintype.card α).choose r := by\n  rw [Fintype.card, ← card_powersetCard]\n  exact card_le_card (subset_powersetCard_univ_iff.mpr h𝒜)\n\n"}
{"name":"Finset.mem_slice","module":"Mathlib.Data.Finset.Slice","initialProofState":"α : Type u_1\n𝒜 : Finset (Finset α)\nA : Finset α\nr : Nat\n⊢ Iff (Membership.mem (𝒜.slice r) A) (And (Membership.mem 𝒜 A) (Eq A.card r))","decl":"/-- `A` is in the `r`-th slice of `𝒜` iff it's in `𝒜` and has cardinality `r`. -/\ntheorem mem_slice : A ∈ 𝒜 # r ↔ A ∈ 𝒜 ∧ #A = r :=\n  mem_filter\n\n"}
{"name":"Finset.slice_subset","module":"Mathlib.Data.Finset.Slice","initialProofState":"α : Type u_1\n𝒜 : Finset (Finset α)\nr : Nat\n⊢ HasSubset.Subset (𝒜.slice r) 𝒜","decl":"/-- The `r`-th slice of `𝒜` is a subset of `𝒜`. -/\ntheorem slice_subset : 𝒜 # r ⊆ 𝒜 :=\n  filter_subset _ _\n\n"}
{"name":"Finset.sized_slice","module":"Mathlib.Data.Finset.Slice","initialProofState":"α : Type u_1\n𝒜 : Finset (Finset α)\nr : Nat\n⊢ Set.Sized r ↑(𝒜.slice r)","decl":"/-- Everything in the `r`-th slice of `𝒜` has size `r`. -/\ntheorem sized_slice : (𝒜 # r : Set (Finset α)).Sized r := fun _ => And.right ∘ mem_slice.mp\n\n"}
{"name":"Finset.eq_of_mem_slice","module":"Mathlib.Data.Finset.Slice","initialProofState":"α : Type u_1\n𝒜 : Finset (Finset α)\nA : Finset α\nr₁ r₂ : Nat\nh₁ : Membership.mem (𝒜.slice r₁) A\nh₂ : Membership.mem (𝒜.slice r₂) A\n⊢ Eq r₁ r₂","decl":"theorem eq_of_mem_slice (h₁ : A ∈ 𝒜 # r₁) (h₂ : A ∈ 𝒜 # r₂) : r₁ = r₂ :=\n  (sized_slice h₁).symm.trans <| sized_slice h₂\n\n"}
{"name":"Finset.ne_of_mem_slice","module":"Mathlib.Data.Finset.Slice","initialProofState":"α : Type u_1\n𝒜 : Finset (Finset α)\nA₁ A₂ : Finset α\nr₁ r₂ : Nat\nh₁ : Membership.mem (𝒜.slice r₁) A₁\nh₂ : Membership.mem (𝒜.slice r₂) A₂\na✝ : Ne r₁ r₂\n⊢ Ne A₁ A₂","decl":"/-- Elements in distinct slices must be distinct. -/\ntheorem ne_of_mem_slice (h₁ : A₁ ∈ 𝒜 # r₁) (h₂ : A₂ ∈ 𝒜 # r₂) : r₁ ≠ r₂ → A₁ ≠ A₂ :=\n  mt fun h => (sized_slice h₁).symm.trans ((congr_arg card h).trans (sized_slice h₂))\n\n"}
{"name":"Finset.pairwiseDisjoint_slice","module":"Mathlib.Data.Finset.Slice","initialProofState":"α : Type u_1\n𝒜 : Finset (Finset α)\n⊢ Set.univ.PairwiseDisjoint 𝒜.slice","decl":"theorem pairwiseDisjoint_slice : (Set.univ : Set ℕ).PairwiseDisjoint (slice 𝒜) := fun _ _ _ _ hmn =>\n  disjoint_filter.2 fun _s _hs hm hn => hmn <| hm.symm.trans hn\n\n"}
{"name":"Finset.biUnion_slice","module":"Mathlib.Data.Finset.Slice","initialProofState":"α : Type u_1\n𝒜 : Finset (Finset α)\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\n⊢ Eq ((Finset.Iic (Fintype.card α)).biUnion 𝒜.slice) 𝒜","decl":"@[simp]\ntheorem biUnion_slice [DecidableEq α] : (Iic <| Fintype.card α).biUnion 𝒜.slice = 𝒜 :=\n  Subset.antisymm (biUnion_subset.2 fun _r _ => slice_subset) fun s hs =>\n    mem_biUnion.2 ⟨#s, mem_Iic.2 <| s.card_le_univ, mem_slice.2 <| ⟨hs, rfl⟩⟩\n\n"}
{"name":"Finset.sum_card_slice","module":"Mathlib.Data.Finset.Slice","initialProofState":"α : Type u_1\n𝒜 : Finset (Finset α)\ninst✝ : Fintype α\n⊢ Eq ((Finset.Iic (Fintype.card α)).sum fun r => (𝒜.slice r).card) 𝒜.card","decl":"@[simp]\ntheorem sum_card_slice : ∑ r ∈ Iic (Fintype.card α), #(𝒜 # r) = #𝒜 := by\n  letI := Classical.decEq α\n  rw [← card_biUnion, biUnion_slice]\n  exact Finset.pairwiseDisjoint_slice.subset (Set.subset_univ _)\n\n"}
