{"name":"dvd_geom_sum₂_iff_of_dvd_sub","module":"Mathlib.NumberTheory.Multiplicity","initialProofState":"R : Type u_1\nn : Nat\ninst✝ : CommRing R\nx y p : R\nh : Dvd.dvd p (HSub.hSub x y)\n⊢ Iff (Dvd.dvd p ((Finset.range n).sum fun i => HMul.hMul (HPow.hPow x i) (HPow.hPow y (HSub.hSub (HSub.hSub n 1) i)))) (Dvd.dvd p (HMul.hMul (↑n) (HPow.hPow y (HSub.hSub n 1))))","decl":"theorem dvd_geom_sum₂_iff_of_dvd_sub {x y p : R} (h : p ∣ x - y) :\n    (p ∣ ∑ i ∈ range n, x ^ i * y ^ (n - 1 - i)) ↔ p ∣ n * y ^ (n - 1) := by\n  rw [← mem_span_singleton, ← Ideal.Quotient.eq] at h\n  simp only [← mem_span_singleton, ← eq_zero_iff_mem, RingHom.map_geom_sum₂, h, geom_sum₂_self,\n    _root_.map_mul, map_pow, map_natCast]\n\n"}
{"name":"dvd_geom_sum₂_iff_of_dvd_sub'","module":"Mathlib.NumberTheory.Multiplicity","initialProofState":"R : Type u_1\nn : Nat\ninst✝ : CommRing R\nx y p : R\nh : Dvd.dvd p (HSub.hSub x y)\n⊢ Iff (Dvd.dvd p ((Finset.range n).sum fun i => HMul.hMul (HPow.hPow x i) (HPow.hPow y (HSub.hSub (HSub.hSub n 1) i)))) (Dvd.dvd p (HMul.hMul (↑n) (HPow.hPow x (HSub.hSub n 1))))","decl":"theorem dvd_geom_sum₂_iff_of_dvd_sub' {x y p : R} (h : p ∣ x - y) :\n    (p ∣ ∑ i ∈ range n, x ^ i * y ^ (n - 1 - i)) ↔ p ∣ n * x ^ (n - 1) := by\n  rw [geom_sum₂_comm, dvd_geom_sum₂_iff_of_dvd_sub]; simpa using h.neg_right\n\n"}
{"name":"dvd_geom_sum₂_self","module":"Mathlib.NumberTheory.Multiplicity","initialProofState":"R : Type u_1\nn : Nat\ninst✝ : CommRing R\nx y : R\nh : Dvd.dvd (↑n) (HSub.hSub x y)\n⊢ Dvd.dvd (↑n) ((Finset.range n).sum fun i => HMul.hMul (HPow.hPow x i) (HPow.hPow y (HSub.hSub (HSub.hSub n 1) i)))","decl":"theorem dvd_geom_sum₂_self {x y : R} (h : ↑n ∣ x - y) :\n    ↑n ∣ ∑ i ∈ range n, x ^ i * y ^ (n - 1 - i) :=\n  (dvd_geom_sum₂_iff_of_dvd_sub h).mpr (dvd_mul_right _ _)\n\n"}
{"name":"sq_dvd_add_pow_sub_sub","module":"Mathlib.NumberTheory.Multiplicity","initialProofState":"R : Type u_1\ninst✝ : CommRing R\np x : R\nn : Nat\n⊢ Dvd.dvd (HPow.hPow p 2) (HSub.hSub (HSub.hSub (HPow.hPow (HAdd.hAdd x p) n) (HMul.hMul (HMul.hMul (HPow.hPow x (HSub.hSub n 1)) p) ↑n)) (HPow.hPow x n))","decl":"theorem sq_dvd_add_pow_sub_sub (p x : R) (n : ℕ) :\n    p ^ 2 ∣ (x + p) ^ n - x ^ (n - 1) * p * n - x ^ n := by\n  cases' n with n n\n  · simp only [pow_zero, Nat.cast_zero, sub_zero, sub_self, dvd_zero, mul_zero]\n  · simp only [Nat.succ_sub_succ_eq_sub, tsub_zero, Nat.cast_succ, add_pow, Finset.sum_range_succ,\n      Nat.choose_self, Nat.succ_sub _, tsub_self, pow_one, Nat.choose_succ_self_right, pow_zero,\n      mul_one, Nat.cast_zero, zero_add, Nat.succ_eq_add_one, add_tsub_cancel_left]\n    suffices p ^ 2 ∣ ∑ i ∈ range n, x ^ i * p ^ (n + 1 - i) * ↑((n + 1).choose i) by\n      convert this; abel\n    apply Finset.dvd_sum\n    intro y hy\n    calc\n      p ^ 2 ∣ p ^ (n + 1 - y) :=\n        pow_dvd_pow p (le_tsub_of_add_le_left (by linarith [Finset.mem_range.mp hy]))\n      _ ∣ x ^ y * p ^ (n + 1 - y) * ↑((n + 1).choose y) :=\n        dvd_mul_of_dvd_left (dvd_mul_left _ _) _\n\n"}
{"name":"not_dvd_geom_sum₂","module":"Mathlib.NumberTheory.Multiplicity","initialProofState":"R : Type u_1\nn : Nat\ninst✝ : CommRing R\nx y p : R\nhp : Prime p\nhxy : Dvd.dvd p (HSub.hSub x y)\nhx : Not (Dvd.dvd p x)\nhn : Not (Dvd.dvd p ↑n)\n⊢ Not (Dvd.dvd p ((Finset.range n).sum fun i => HMul.hMul (HPow.hPow x i) (HPow.hPow y (HSub.hSub (HSub.hSub n 1) i))))","decl":"theorem not_dvd_geom_sum₂ {p : R} (hp : Prime p) (hxy : p ∣ x - y) (hx : ¬p ∣ x) (hn : ¬p ∣ n) :\n    ¬p ∣ ∑ i ∈ range n, x ^ i * y ^ (n - 1 - i) := fun h =>\n  hx <|\n    hp.dvd_of_dvd_pow <| (hp.dvd_or_dvd <| (dvd_geom_sum₂_iff_of_dvd_sub' hxy).mp h).resolve_left hn\n\n"}
{"name":"odd_sq_dvd_geom_sum₂_sub","module":"Mathlib.NumberTheory.Multiplicity","initialProofState":"R : Type u_1\ninst✝ : CommRing R\na b : R\np : Nat\nhp : Odd p\n⊢ Dvd.dvd (HPow.hPow (↑p) 2) (HSub.hSub ((Finset.range p).sum fun i => HMul.hMul (HPow.hPow (HAdd.hAdd a (HMul.hMul (↑p) b)) i) (HPow.hPow a (HSub.hSub (HSub.hSub p 1) i))) (HMul.hMul (↑p) (HPow.hPow a (HSub.hSub p 1))))","decl":"theorem odd_sq_dvd_geom_sum₂_sub (hp : Odd p) :\n    (p : R) ^ 2 ∣ (∑ i ∈ range p, (a + p * b) ^ i * a ^ (p - 1 - i)) - p * a ^ (p - 1) := by\n  have h1 : ∀ (i : ℕ),\n      (p : R) ^ 2 ∣ (a + ↑p * b) ^ i - (a ^ (i - 1) * (↑p * b) * i + a ^ i) := by\n    intro i\n    calc\n      ↑p ^ 2 ∣ (↑p * b) ^ 2 := by simp only [mul_pow, dvd_mul_right]\n      _ ∣ (a + ↑p * b) ^ i - (a ^ (i - 1) * (↑p * b) * ↑i + a ^ i) := by\n        simp only [sq_dvd_add_pow_sub_sub (↑p * b) a i, ← sub_sub]\n  simp_rw [← mem_span_singleton, ← Ideal.Quotient.eq] at *\n  let s : R := (p : R)^2\n  calc\n    (Ideal.Quotient.mk (span {s})) (∑ i ∈ range p, (a + (p : R) * b) ^ i * a ^ (p - 1 - i)) =\n        ∑ i ∈ Finset.range p,\n        mk (span {s}) ((a ^ (i - 1) * (↑p * b) * ↑i + a ^ i) * a ^ (p - 1 - i)) := by\n      simp_rw [s, RingHom.map_geom_sum₂, ← map_pow, h1, ← _root_.map_mul]\n    _ =\n        mk (span {s})\n            (∑ x ∈ Finset.range p, a ^ (x - 1) * (a ^ (p - 1 - x) * (↑p * (b * ↑x)))) +\n          mk (span {s}) (∑ x ∈ Finset.range p, a ^ (x + (p - 1 - x))) := by\n      ring_nf\n      simp only [← pow_add, map_add, Finset.sum_add_distrib, ← map_sum]\n      congr\n      simp [pow_add a, mul_assoc]\n    _ =\n        mk (span {s})\n            (∑ x ∈ Finset.range p, a ^ (x - 1) * (a ^ (p - 1 - x) * (↑p * (b * ↑x)))) +\n          mk (span {s}) (∑ _x ∈ Finset.range p, a ^ (p - 1)) := by\n      rw [add_right_inj]\n      have : ∀ (x : ℕ), (hx : x ∈ range p) → a ^ (x + (p - 1 - x)) = a ^ (p - 1) := by\n        intro x hx\n        rw [← Nat.add_sub_assoc _ x, Nat.add_sub_cancel_left]\n        exact Nat.le_sub_one_of_lt (Finset.mem_range.mp hx)\n      rw [Finset.sum_congr rfl this]\n    _ =\n        mk (span {s})\n            (∑ x ∈ Finset.range p, a ^ (x - 1) * (a ^ (p - 1 - x) * (↑p * (b * ↑x)))) +\n          mk (span {s}) (↑p * a ^ (p - 1)) := by\n      simp only [add_right_inj, Finset.sum_const, Finset.card_range, nsmul_eq_mul]\n    _ =\n        mk (span {s}) (↑p * b * ∑ x ∈ Finset.range p, a ^ (p - 2) * x) +\n          mk (span {s}) (↑p * a ^ (p - 1)) := by\n      simp only [Finset.mul_sum, ← mul_assoc, ← pow_add]\n      rw [Finset.sum_congr rfl]\n      rintro (⟨⟩ | ⟨x⟩) hx\n      · rw [Nat.cast_zero, mul_zero, mul_zero]\n      · have : x.succ - 1 + (p - 1 - x.succ) = p - 2 := by\n          rw [← Nat.add_sub_assoc (Nat.le_sub_one_of_lt (Finset.mem_range.mp hx))]\n          exact congr_arg Nat.pred (Nat.add_sub_cancel_left _ _)\n        rw [this]\n        ring1\n    _ = mk (span {s}) (↑p * a ^ (p - 1)) := by\n      have : Finset.sum (range p) (fun (x : ℕ) ↦ (x : R)) =\n          ((Finset.sum (range p) (fun (x : ℕ) ↦ (x : ℕ)))) := by simp only [Nat.cast_sum]\n      simp only [add_left_eq_self, ← Finset.mul_sum, this]\n      norm_cast\n      simp only [Finset.sum_range_id]\n      norm_cast\n      simp only [Nat.cast_mul, _root_.map_mul,\n          Nat.mul_div_assoc p (even_iff_two_dvd.mp (Nat.Odd.sub_odd hp odd_one))]\n      ring_nf\n      rw [mul_assoc, mul_assoc]\n      refine mul_eq_zero_of_left ?_ _\n      refine Ideal.Quotient.eq_zero_iff_mem.mpr ?_\n      simp [s, mem_span_singleton]\n\n"}
{"name":"emultiplicity_pow_sub_pow_of_prime","module":"Mathlib.NumberTheory.Multiplicity","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : R\nhp : Prime p\nx y : R\nhxy : Dvd.dvd p (HSub.hSub x y)\nhx : Not (Dvd.dvd p x)\nn : Nat\nhn : Not (Dvd.dvd p ↑n)\n⊢ Eq (emultiplicity p (HSub.hSub (HPow.hPow x n) (HPow.hPow y n))) (emultiplicity p (HSub.hSub x y))","decl":"theorem emultiplicity_pow_sub_pow_of_prime {p : R} (hp : Prime p) {x y : R}\n    (hxy : p ∣ x - y) (hx : ¬p ∣ x) {n : ℕ} (hn : ¬p ∣ n) :\n    emultiplicity p (x ^ n - y ^ n) = emultiplicity p (x - y) := by\n  rw [← geom_sum₂_mul, emultiplicity_mul hp,\n    emultiplicity_eq_zero.2 (not_dvd_geom_sum₂ hp hxy hx hn), zero_add]\n\n"}
{"name":"multiplicity.pow_sub_pow_of_prime","module":"Mathlib.NumberTheory.Multiplicity","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : R\nhp : Prime p\nx y : R\nhxy : Dvd.dvd p (HSub.hSub x y)\nhx : Not (Dvd.dvd p x)\nn : Nat\nhn : Not (Dvd.dvd p ↑n)\n⊢ Eq (emultiplicity p (HSub.hSub (HPow.hPow x n) (HPow.hPow y n))) (emultiplicity p (HSub.hSub x y))","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.pow_sub_pow_of_prime := emultiplicity_pow_sub_pow_of_prime\n\n"}
{"name":"emultiplicity_geom_sum₂_eq_one","module":"Mathlib.NumberTheory.Multiplicity","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nx y : R\np : Nat\ninst✝ : IsDomain R\nhp : Prime ↑p\nhp1 : Odd p\nhxy : Dvd.dvd (↑p) (HSub.hSub x y)\nhx : Not (Dvd.dvd (↑p) x)\n⊢ Eq (emultiplicity (↑p) ((Finset.range p).sum fun i => HMul.hMul (HPow.hPow x i) (HPow.hPow y (HSub.hSub (HSub.hSub p 1) i)))) 1","decl":"theorem emultiplicity_geom_sum₂_eq_one :\n    emultiplicity (↑p) (∑ i ∈ range p, x ^ i * y ^ (p - 1 - i)) = 1 := by\n  rw [← Nat.cast_one]\n  refine emultiplicity_eq_coe.2 ⟨?_, ?_⟩\n  · rw [pow_one]\n    exact dvd_geom_sum₂_self hxy\n  rw [dvd_iff_dvd_of_dvd_sub hxy] at hx\n  cases' hxy with k hk\n  rw [one_add_one_eq_two, eq_add_of_sub_eq' hk]\n  refine mt (dvd_iff_dvd_of_dvd_sub (@odd_sq_dvd_geom_sum₂_sub _ _ y k _ hp1)).mp ?_\n  rw [pow_two, mul_dvd_mul_iff_left hp.ne_zero]\n  exact mt hp.dvd_of_dvd_pow hx\n\n"}
{"name":"multiplicity.geom_sum₂_eq_one","module":"Mathlib.NumberTheory.Multiplicity","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nx y : R\np : Nat\ninst✝ : IsDomain R\nhp : Prime ↑p\nhp1 : Odd p\nhxy : Dvd.dvd (↑p) (HSub.hSub x y)\nhx : Not (Dvd.dvd (↑p) x)\n⊢ Eq (emultiplicity (↑p) ((Finset.range p).sum fun i => HMul.hMul (HPow.hPow x i) (HPow.hPow y (HSub.hSub (HSub.hSub p 1) i)))) 1","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.geom_sum₂_eq_one := emultiplicity_geom_sum₂_eq_one\n\n"}
{"name":"emultiplicity_pow_prime_sub_pow_prime","module":"Mathlib.NumberTheory.Multiplicity","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nx y : R\np : Nat\ninst✝ : IsDomain R\nhp : Prime ↑p\nhp1 : Odd p\nhxy : Dvd.dvd (↑p) (HSub.hSub x y)\nhx : Not (Dvd.dvd (↑p) x)\n⊢ Eq (emultiplicity (↑p) (HSub.hSub (HPow.hPow x p) (HPow.hPow y p))) (HAdd.hAdd (emultiplicity (↑p) (HSub.hSub x y)) 1)","decl":"theorem emultiplicity_pow_prime_sub_pow_prime :\n    emultiplicity (↑p) (x ^ p - y ^ p) = emultiplicity (↑p) (x - y) + 1 := by\n  rw [← geom_sum₂_mul, emultiplicity_mul hp, emultiplicity_geom_sum₂_eq_one hp hp1 hxy hx, add_comm]\n\n"}
{"name":"multiplicity.pow_prime_sub_pow_prime","module":"Mathlib.NumberTheory.Multiplicity","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nx y : R\np : Nat\ninst✝ : IsDomain R\nhp : Prime ↑p\nhp1 : Odd p\nhxy : Dvd.dvd (↑p) (HSub.hSub x y)\nhx : Not (Dvd.dvd (↑p) x)\n⊢ Eq (emultiplicity (↑p) (HSub.hSub (HPow.hPow x p) (HPow.hPow y p))) (HAdd.hAdd (emultiplicity (↑p) (HSub.hSub x y)) 1)","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.pow_prime_sub_pow_prime := emultiplicity_pow_prime_sub_pow_prime\n\n"}
{"name":"emultiplicity_pow_prime_pow_sub_pow_prime_pow","module":"Mathlib.NumberTheory.Multiplicity","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nx y : R\np : Nat\ninst✝ : IsDomain R\nhp : Prime ↑p\nhp1 : Odd p\nhxy : Dvd.dvd (↑p) (HSub.hSub x y)\nhx : Not (Dvd.dvd (↑p) x)\na : Nat\n⊢ Eq (emultiplicity (↑p) (HSub.hSub (HPow.hPow x (HPow.hPow p a)) (HPow.hPow y (HPow.hPow p a)))) (HAdd.hAdd (emultiplicity (↑p) (HSub.hSub x y)) ↑a)","decl":"theorem emultiplicity_pow_prime_pow_sub_pow_prime_pow (a : ℕ) :\n    emultiplicity (↑p) (x ^ p ^ a - y ^ p ^ a) = emultiplicity (↑p) (x - y) + a := by\n  induction' a with a h_ind\n  · rw [Nat.cast_zero, add_zero, pow_zero, pow_one, pow_one]\n  rw [Nat.cast_add, Nat.cast_one, ← add_assoc, ← h_ind, pow_succ, pow_mul, pow_mul]\n  apply emultiplicity_pow_prime_sub_pow_prime hp hp1\n  · rw [← geom_sum₂_mul]\n    exact dvd_mul_of_dvd_right hxy _\n  · exact fun h => hx (hp.dvd_of_dvd_pow h)\n\n"}
{"name":"multiplicity.pow_prime_pow_sub_pow_prime_pow","module":"Mathlib.NumberTheory.Multiplicity","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nx y : R\np : Nat\ninst✝ : IsDomain R\nhp : Prime ↑p\nhp1 : Odd p\nhxy : Dvd.dvd (↑p) (HSub.hSub x y)\nhx : Not (Dvd.dvd (↑p) x)\na : Nat\n⊢ Eq (emultiplicity (↑p) (HSub.hSub (HPow.hPow x (HPow.hPow p a)) (HPow.hPow y (HPow.hPow p a)))) (HAdd.hAdd (emultiplicity (↑p) (HSub.hSub x y)) ↑a)","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.pow_prime_pow_sub_pow_prime_pow := emultiplicity_pow_prime_pow_sub_pow_prime_pow\n\n"}
{"name":"Int.emultiplicity_pow_sub_pow","module":"Mathlib.NumberTheory.Multiplicity","initialProofState":"p : Nat\nhp : Nat.Prime p\nhp1 : Odd p\nx y : Int\nhxy : Dvd.dvd (↑p) (HSub.hSub x y)\nhx : Not (Dvd.dvd (↑p) x)\nn : Nat\n⊢ Eq (emultiplicity (↑p) (HSub.hSub (HPow.hPow x n) (HPow.hPow y n))) (HAdd.hAdd (emultiplicity (↑p) (HSub.hSub x y)) (emultiplicity p n))","decl":"/-- **Lifting the exponent lemma** for odd primes. -/\ntheorem Int.emultiplicity_pow_sub_pow {x y : ℤ} (hxy : ↑p ∣ x - y) (hx : ¬↑p ∣ x) (n : ℕ) :\n    emultiplicity (↑p) (x ^ n - y ^ n) = emultiplicity (↑p) (x - y) + emultiplicity p n := by\n  cases' n with n\n  · simp only [emultiplicity_zero, add_top, pow_zero, sub_self]\n  have h : FiniteMultiplicity _ _ := Nat.finiteMultiplicity_iff.mpr ⟨hp.ne_one, n.succ_pos⟩\n  simp only [Nat.succ_eq_add_one] at h\n  rcases emultiplicity_eq_coe.mp h.emultiplicity_eq_multiplicity with ⟨⟨k, hk⟩, hpn⟩\n  conv_lhs => rw [hk, pow_mul, pow_mul]\n  rw [Nat.prime_iff_prime_int] at hp\n  rw [emultiplicity_pow_sub_pow_of_prime hp,\n    emultiplicity_pow_prime_pow_sub_pow_prime_pow hp hp1 hxy hx, h.emultiplicity_eq_multiplicity]\n  · rw [← geom_sum₂_mul]\n    exact dvd_mul_of_dvd_right hxy _\n  · exact fun h => hx (hp.dvd_of_dvd_pow h)\n  · rw [Int.natCast_dvd_natCast]\n    rintro ⟨c, rfl⟩\n    refine hpn ⟨c, ?_⟩\n    rwa [pow_succ, mul_assoc]\n\n"}
{"name":"multiplicity.Int.pow_sub_pow","module":"Mathlib.NumberTheory.Multiplicity","initialProofState":"p : Nat\nhp : Nat.Prime p\nhp1 : Odd p\nx y : Int\nhxy : Dvd.dvd (↑p) (HSub.hSub x y)\nhx : Not (Dvd.dvd (↑p) x)\nn : Nat\n⊢ Eq (emultiplicity (↑p) (HSub.hSub (HPow.hPow x n) (HPow.hPow y n))) (HAdd.hAdd (emultiplicity (↑p) (HSub.hSub x y)) (emultiplicity p n))","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Int.pow_sub_pow := Int.emultiplicity_pow_sub_pow\n\n"}
{"name":"Int.emultiplicity_pow_add_pow","module":"Mathlib.NumberTheory.Multiplicity","initialProofState":"p : Nat\nhp : Nat.Prime p\nhp1 : Odd p\nx y : Int\nhxy : Dvd.dvd (↑p) (HAdd.hAdd x y)\nhx : Not (Dvd.dvd (↑p) x)\nn : Nat\nhn : Odd n\n⊢ Eq (emultiplicity (↑p) (HAdd.hAdd (HPow.hPow x n) (HPow.hPow y n))) (HAdd.hAdd (emultiplicity (↑p) (HAdd.hAdd x y)) (emultiplicity p n))","decl":"theorem Int.emultiplicity_pow_add_pow {x y : ℤ} (hxy : ↑p ∣ x + y) (hx : ¬↑p ∣ x)\n    {n : ℕ} (hn : Odd n) :\n    emultiplicity (↑p) (x ^ n + y ^ n) = emultiplicity (↑p) (x + y) + emultiplicity p n := by\n  rw [← sub_neg_eq_add] at hxy\n  rw [← sub_neg_eq_add, ← sub_neg_eq_add, ← Odd.neg_pow hn]\n  exact Int.emultiplicity_pow_sub_pow hp hp1 hxy hx n\n\n"}
{"name":"multiplicity.Int.pow_add_pow","module":"Mathlib.NumberTheory.Multiplicity","initialProofState":"p : Nat\nhp : Nat.Prime p\nhp1 : Odd p\nx y : Int\nhxy : Dvd.dvd (↑p) (HAdd.hAdd x y)\nhx : Not (Dvd.dvd (↑p) x)\nn : Nat\nhn : Odd n\n⊢ Eq (emultiplicity (↑p) (HAdd.hAdd (HPow.hPow x n) (HPow.hPow y n))) (HAdd.hAdd (emultiplicity (↑p) (HAdd.hAdd x y)) (emultiplicity p n))","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Int.pow_add_pow := Int.emultiplicity_pow_add_pow\n\n"}
{"name":"Nat.emultiplicity_pow_sub_pow","module":"Mathlib.NumberTheory.Multiplicity","initialProofState":"p : Nat\nhp : Nat.Prime p\nhp1 : Odd p\nx y : Nat\nhxy : Dvd.dvd p (HSub.hSub x y)\nhx : Not (Dvd.dvd p x)\nn : Nat\n⊢ Eq (emultiplicity p (HSub.hSub (HPow.hPow x n) (HPow.hPow y n))) (HAdd.hAdd (emultiplicity p (HSub.hSub x y)) (emultiplicity p n))","decl":"theorem Nat.emultiplicity_pow_sub_pow {x y : ℕ} (hxy : p ∣ x - y) (hx : ¬p ∣ x) (n : ℕ) :\n    emultiplicity p (x ^ n - y ^ n) = emultiplicity p (x - y) + emultiplicity p n := by\n  obtain hyx | hyx := le_total y x\n  · iterate 2 rw [← Int.natCast_emultiplicity]\n    rw [Int.ofNat_sub (Nat.pow_le_pow_left hyx n)]\n    rw [← Int.natCast_dvd_natCast] at hxy hx\n    rw [Int.natCast_sub hyx] at *\n    push_cast at *\n    exact Int.emultiplicity_pow_sub_pow hp hp1 hxy hx n\n  · simp only [Nat.sub_eq_zero_iff_le.mpr (Nat.pow_le_pow_left hyx n), emultiplicity_zero,\n    Nat.sub_eq_zero_iff_le.mpr hyx, top_add]\n\n"}
{"name":"multiplicity.Nat.pow_sub_pow","module":"Mathlib.NumberTheory.Multiplicity","initialProofState":"p : Nat\nhp : Nat.Prime p\nhp1 : Odd p\nx y : Nat\nhxy : Dvd.dvd p (HSub.hSub x y)\nhx : Not (Dvd.dvd p x)\nn : Nat\n⊢ Eq (emultiplicity p (HSub.hSub (HPow.hPow x n) (HPow.hPow y n))) (HAdd.hAdd (emultiplicity p (HSub.hSub x y)) (emultiplicity p n))","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Nat.pow_sub_pow := Nat.emultiplicity_pow_sub_pow\n\n"}
{"name":"Nat.emultiplicity_pow_add_pow","module":"Mathlib.NumberTheory.Multiplicity","initialProofState":"p : Nat\nhp : Nat.Prime p\nhp1 : Odd p\nx y : Nat\nhxy : Dvd.dvd p (HAdd.hAdd x y)\nhx : Not (Dvd.dvd p x)\nn : Nat\nhn : Odd n\n⊢ Eq (emultiplicity p (HAdd.hAdd (HPow.hPow x n) (HPow.hPow y n))) (HAdd.hAdd (emultiplicity p (HAdd.hAdd x y)) (emultiplicity p n))","decl":"theorem Nat.emultiplicity_pow_add_pow {x y : ℕ} (hxy : p ∣ x + y) (hx : ¬p ∣ x)\n    {n : ℕ} (hn : Odd n) :\n    emultiplicity p (x ^ n + y ^ n) = emultiplicity p (x + y) + emultiplicity p n := by\n  iterate 2 rw [← Int.natCast_emultiplicity]\n  rw [← Int.natCast_dvd_natCast] at hxy hx\n  push_cast at *\n  exact Int.emultiplicity_pow_add_pow hp hp1 hxy hx hn\n\n"}
{"name":"multiplicity.Nat.pow_add_pow","module":"Mathlib.NumberTheory.Multiplicity","initialProofState":"p : Nat\nhp : Nat.Prime p\nhp1 : Odd p\nx y : Nat\nhxy : Dvd.dvd p (HAdd.hAdd x y)\nhx : Not (Dvd.dvd p x)\nn : Nat\nhn : Odd n\n⊢ Eq (emultiplicity p (HAdd.hAdd (HPow.hPow x n) (HPow.hPow y n))) (HAdd.hAdd (emultiplicity p (HAdd.hAdd x y)) (emultiplicity p n))","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.Nat.pow_add_pow := Nat.emultiplicity_pow_add_pow\n\n"}
{"name":"pow_two_pow_sub_pow_two_pow","module":"Mathlib.NumberTheory.Multiplicity","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y : R\nn : Nat\n⊢ Eq (HSub.hSub (HPow.hPow x (HPow.hPow 2 n)) (HPow.hPow y (HPow.hPow 2 n))) (HMul.hMul ((Finset.range n).prod fun i => HAdd.hAdd (HPow.hPow x (HPow.hPow 2 i)) (HPow.hPow y (HPow.hPow 2 i))) (HSub.hSub x y))","decl":"theorem pow_two_pow_sub_pow_two_pow [CommRing R] {x y : R} (n : ℕ) :\n    x ^ 2 ^ n - y ^ 2 ^ n = (∏ i ∈ Finset.range n, (x ^ 2 ^ i + y ^ 2 ^ i)) * (x - y) := by\n  induction' n with d hd\n  · simp only [pow_zero, pow_one, range_zero, prod_empty, one_mul]\n  · suffices x ^ 2 ^ d.succ - y ^ 2 ^ d.succ = (x ^ 2 ^ d + y ^ 2 ^ d) * (x ^ 2 ^ d - y ^ 2 ^ d) by\n      rw [this, hd, Finset.prod_range_succ, ← mul_assoc, mul_comm (x ^ 2 ^ d + y ^ 2 ^ d)]\n    rw [Nat.succ_eq_add_one]\n    ring\n\n-- Porting note: simplified proof because `fin_cases` was not available in that case\n"}
{"name":"Int.sq_mod_four_eq_one_of_odd","module":"Mathlib.NumberTheory.Multiplicity","initialProofState":"x : Int\na✝ : Odd x\n⊢ Eq (HMod.hMod (HPow.hPow x 2) 4) 1","decl":"theorem Int.sq_mod_four_eq_one_of_odd {x : ℤ} : Odd x → x ^ 2 % 4 = 1 := by\n  intro hx\n  unfold Odd at hx\n  rcases hx with ⟨_, rfl⟩\n  ring_nf\n  rw [add_assoc, ← add_mul, Int.add_mul_emod_self]\n  decide\n\n"}
{"name":"Int.two_pow_two_pow_add_two_pow_two_pow","module":"Mathlib.NumberTheory.Multiplicity","initialProofState":"x y : Int\nhx : Not (Dvd.dvd 2 x)\nhxy : Dvd.dvd 4 (HSub.hSub x y)\ni : Nat\n⊢ Eq (emultiplicity 2 (HAdd.hAdd (HPow.hPow x (HPow.hPow 2 i)) (HPow.hPow y (HPow.hPow 2 i)))) ↑1","decl":"theorem Int.two_pow_two_pow_add_two_pow_two_pow {x y : ℤ} (hx : ¬2 ∣ x) (hxy : 4 ∣ x - y) (i : ℕ) :\n    emultiplicity 2 (x ^ 2 ^ i + y ^ 2 ^ i) = ↑(1 : ℕ) := by\n  have hx_odd : Odd x := by rwa [← Int.not_even_iff_odd, even_iff_two_dvd]\n  have hxy_even : Even (x - y) := even_iff_two_dvd.mpr (dvd_trans (by decide) hxy)\n  have hy_odd : Odd y := by simpa using hx_odd.sub_even hxy_even\n  refine emultiplicity_eq_coe.mpr ⟨?_, ?_⟩\n  · rw [pow_one, ← even_iff_two_dvd]\n    exact hx_odd.pow.add_odd hy_odd.pow\n  cases' i with i\n  · intro hxy'\n    have : 2 * 2 ∣ 2 * x := by\n      have := dvd_add hxy hxy'\n      norm_num at *\n      rw [two_mul]\n      exact this\n    have : 2 ∣ x := (mul_dvd_mul_iff_left (by norm_num)).mp this\n    contradiction\n  suffices ∀ x : ℤ, Odd x → x ^ 2 ^ (i + 1) % 4 = 1 by\n    rw [show (2 ^ (1 + 1) : ℤ) = 4 by norm_num, Int.dvd_iff_emod_eq_zero, Int.add_emod,\n      this _ hx_odd, this _ hy_odd]\n    decide\n  intro x hx\n  rw [pow_succ', mul_comm, pow_mul, Int.sq_mod_four_eq_one_of_odd hx.pow]\n\n"}
{"name":"Int.two_pow_two_pow_sub_pow_two_pow","module":"Mathlib.NumberTheory.Multiplicity","initialProofState":"x y : Int\nn : Nat\nhxy : Dvd.dvd 4 (HSub.hSub x y)\nhx : Not (Dvd.dvd 2 x)\n⊢ Eq (emultiplicity 2 (HSub.hSub (HPow.hPow x (HPow.hPow 2 n)) (HPow.hPow y (HPow.hPow 2 n)))) (HAdd.hAdd (emultiplicity 2 (HSub.hSub x y)) ↑n)","decl":"theorem Int.two_pow_two_pow_sub_pow_two_pow {x y : ℤ} (n : ℕ) (hxy : 4 ∣ x - y) (hx : ¬2 ∣ x) :\n    emultiplicity 2 (x ^ 2 ^ n - y ^ 2 ^ n) = emultiplicity 2 (x - y) + n := by\n  simp only [pow_two_pow_sub_pow_two_pow n, emultiplicity_mul Int.prime_two,\n    Finset.emultiplicity_prod Int.prime_two, add_comm, Nat.cast_one, Finset.sum_const,\n    Finset.card_range, nsmul_one, Int.two_pow_two_pow_add_two_pow_two_pow hx hxy]\n\n"}
{"name":"Int.two_pow_sub_pow'","module":"Mathlib.NumberTheory.Multiplicity","initialProofState":"x y : Int\nn : Nat\nhxy : Dvd.dvd 4 (HSub.hSub x y)\nhx : Not (Dvd.dvd 2 x)\n⊢ Eq (emultiplicity 2 (HSub.hSub (HPow.hPow x n) (HPow.hPow y n))) (HAdd.hAdd (emultiplicity 2 (HSub.hSub x y)) (emultiplicity 2 ↑n))","decl":"theorem Int.two_pow_sub_pow' {x y : ℤ} (n : ℕ) (hxy : 4 ∣ x - y) (hx : ¬2 ∣ x) :\n    emultiplicity 2 (x ^ n - y ^ n) = emultiplicity 2 (x - y) + emultiplicity (2 : ℤ) n := by\n  have hx_odd : Odd x := by rwa [← Int.not_even_iff_odd, even_iff_two_dvd]\n  have hxy_even : Even (x - y) := even_iff_two_dvd.mpr (dvd_trans (by decide) hxy)\n  have hy_odd : Odd y := by simpa using hx_odd.sub_even hxy_even\n  cases' n with n\n  · simp only [pow_zero, sub_self, emultiplicity_zero, Int.ofNat_zero, add_top]\n  have h : FiniteMultiplicity 2 n.succ := Nat.finiteMultiplicity_iff.mpr ⟨by norm_num, n.succ_pos⟩\n  simp only [Nat.succ_eq_add_one] at h\n  rcases emultiplicity_eq_coe.mp h.emultiplicity_eq_multiplicity with ⟨⟨k, hk⟩, hpn⟩\n  rw [hk, pow_mul, pow_mul, emultiplicity_pow_sub_pow_of_prime,\n    Int.two_pow_two_pow_sub_pow_two_pow _ hxy hx, ← hk]\n  · norm_cast\n    rw [h.emultiplicity_eq_multiplicity]\n  · exact Int.prime_two\n  · simpa only [even_iff_two_dvd] using hx_odd.pow.sub_odd hy_odd.pow\n  · simpa only [even_iff_two_dvd, ← Int.not_even_iff_odd] using hx_odd.pow\n  erw [Int.natCast_dvd_natCast]\n  -- `erw` to deal with `2 : ℤ` vs `(2 : ℕ) : ℤ`\n  contrapose! hpn\n  rw [pow_succ]\n  conv_rhs => rw [hk]\n  exact mul_dvd_mul_left _ hpn\n\n"}
{"name":"Int.two_pow_sub_pow","module":"Mathlib.NumberTheory.Multiplicity","initialProofState":"x y : Int\nn : Nat\nhxy : Dvd.dvd 2 (HSub.hSub x y)\nhx : Not (Dvd.dvd 2 x)\nhn : Even n\n⊢ Eq (HAdd.hAdd (emultiplicity 2 (HSub.hSub (HPow.hPow x n) (HPow.hPow y n))) 1) (HAdd.hAdd (HAdd.hAdd (emultiplicity 2 (HAdd.hAdd x y)) (emultiplicity 2 (HSub.hSub x y))) (emultiplicity 2 ↑n))","decl":"/-- **Lifting the exponent lemma** for `p = 2` -/\ntheorem Int.two_pow_sub_pow {x y : ℤ} {n : ℕ} (hxy : 2 ∣ x - y) (hx : ¬2 ∣ x) (hn : Even n) :\n    emultiplicity 2 (x ^ n - y ^ n) + 1 =\n      emultiplicity 2 (x + y) + emultiplicity 2 (x - y) + emultiplicity (2 : ℤ) n := by\n  have hy : Odd y := by\n    rw [← even_iff_two_dvd, Int.not_even_iff_odd] at hx\n    replace hxy := (@even_neg _ _ (x - y)).mpr (even_iff_two_dvd.mpr hxy)\n    convert Even.add_odd hxy hx\n    abel\n  cases' hn with d hd\n  subst hd\n  simp only [← two_mul, pow_mul]\n  have hxy4 : 4 ∣ x ^ 2 - y ^ 2 := by\n    rw [Int.dvd_iff_emod_eq_zero, Int.sub_emod, Int.sq_mod_four_eq_one_of_odd _,\n      Int.sq_mod_four_eq_one_of_odd hy]\n    · norm_num\n    · simp only [← Int.not_even_iff_odd, even_iff_two_dvd, hx, not_false_iff]\n  rw [Int.two_pow_sub_pow' d hxy4 _, sq_sub_sq, ← Int.ofNat_mul_out,\n    emultiplicity_mul Int.prime_two, emultiplicity_mul Int.prime_two]\n  · suffices emultiplicity (2 : ℤ) ↑(2 : ℕ) = 1 by rw [this, add_comm 1, ← add_assoc]\n    norm_cast\n    rw [FiniteMultiplicity.emultiplicity_self]\n    rw [Nat.finiteMultiplicity_iff]\n    decide\n  · rw [← even_iff_two_dvd, Int.not_even_iff_odd]\n    apply Odd.pow\n    simp only [← Int.not_even_iff_odd, even_iff_two_dvd, hx, not_false_iff]\n\n"}
{"name":"Nat.two_pow_sub_pow","module":"Mathlib.NumberTheory.Multiplicity","initialProofState":"x y : Nat\nhxy : Dvd.dvd 2 (HSub.hSub x y)\nhx : Not (Dvd.dvd 2 x)\nn : Nat\nhn : Even n\n⊢ Eq (HAdd.hAdd (emultiplicity 2 (HSub.hSub (HPow.hPow x n) (HPow.hPow y n))) 1) (HAdd.hAdd (HAdd.hAdd (emultiplicity 2 (HAdd.hAdd x y)) (emultiplicity 2 (HSub.hSub x y))) (emultiplicity 2 n))","decl":"theorem Nat.two_pow_sub_pow {x y : ℕ} (hxy : 2 ∣ x - y) (hx : ¬2 ∣ x) {n : ℕ} (hn : Even n) :\n    emultiplicity 2 (x ^ n - y ^ n) + 1 =\n      emultiplicity 2 (x + y) + emultiplicity 2 (x - y) + emultiplicity 2 n := by\n  obtain hyx | hyx := le_total y x\n  · iterate 3 rw [← Int.natCast_emultiplicity]\n    simp only [Int.ofNat_sub hyx, Int.ofNat_sub (pow_le_pow_left' hyx _), Int.ofNat_add,\n      Int.natCast_pow]\n    rw [← Int.natCast_dvd_natCast] at hx\n    rw [← Int.natCast_dvd_natCast, Int.ofNat_sub hyx] at hxy\n    convert Int.two_pow_sub_pow hxy hx hn using 2\n    rw [← Int.natCast_emultiplicity]\n    rfl\n  · simp only [Nat.sub_eq_zero_iff_le.mpr hyx,\n      Nat.sub_eq_zero_iff_le.mpr (pow_le_pow_left' hyx n), emultiplicity_zero,\n      top_add, add_top]\n\n"}
{"name":"padicValNat.pow_two_sub_pow","module":"Mathlib.NumberTheory.Multiplicity","initialProofState":"x y : Nat\nhyx : LT.lt y x\nhxy : Dvd.dvd 2 (HSub.hSub x y)\nhx : Not (Dvd.dvd 2 x)\nn : Nat\nhn : Ne n 0\nhneven : Even n\n⊢ Eq (HAdd.hAdd (padicValNat 2 (HSub.hSub (HPow.hPow x n) (HPow.hPow y n))) 1) (HAdd.hAdd (HAdd.hAdd (padicValNat 2 (HAdd.hAdd x y)) (padicValNat 2 (HSub.hSub x y))) (padicValNat 2 n))","decl":"theorem pow_two_sub_pow (hyx : y < x) (hxy : 2 ∣ x - y) (hx : ¬2 ∣ x) {n : ℕ} (hn : n ≠ 0)\n    (hneven : Even n) :\n    padicValNat 2 (x ^ n - y ^ n) + 1 =\n      padicValNat 2 (x + y) + padicValNat 2 (x - y) + padicValNat 2 n := by\n  simp only [← Nat.cast_inj (R := ℕ∞), Nat.cast_add]\n  iterate 4 rw [padicValNat_eq_emultiplicity]\n  · exact Nat.two_pow_sub_pow hxy hx hneven\n  · exact hn.bot_lt\n  · exact Nat.sub_pos_of_lt hyx\n  · omega\n  · simp only [tsub_pos_iff_lt, Nat.pow_lt_pow_left hyx hn]\n\n"}
{"name":"padicValNat.pow_sub_pow","module":"Mathlib.NumberTheory.Multiplicity","initialProofState":"x y p : Nat\nhp : Fact (Nat.Prime p)\nhp1 : Odd p\nhyx : LT.lt y x\nhxy : Dvd.dvd p (HSub.hSub x y)\nhx : Not (Dvd.dvd p x)\nn : Nat\nhn : Ne n 0\n⊢ Eq (padicValNat p (HSub.hSub (HPow.hPow x n) (HPow.hPow y n))) (HAdd.hAdd (padicValNat p (HSub.hSub x y)) (padicValNat p n))","decl":"theorem pow_sub_pow (hyx : y < x) (hxy : p ∣ x - y) (hx : ¬p ∣ x) {n : ℕ} (hn : n ≠ 0) :\n    padicValNat p (x ^ n - y ^ n) = padicValNat p (x - y) + padicValNat p n := by\n  rw [← Nat.cast_inj (R := ℕ∞), Nat.cast_add]\n  iterate 3 rw [padicValNat_eq_emultiplicity]\n  · exact Nat.emultiplicity_pow_sub_pow hp.out hp1 hxy hx n\n  · exact hn.bot_lt\n  · exact Nat.sub_pos_of_lt hyx\n  · exact Nat.sub_pos_of_lt (Nat.pow_lt_pow_left hyx hn)\n\n"}
{"name":"padicValNat.pow_add_pow","module":"Mathlib.NumberTheory.Multiplicity","initialProofState":"x y p : Nat\nhp : Fact (Nat.Prime p)\nhp1 : Odd p\nhxy : Dvd.dvd p (HAdd.hAdd x y)\nhx : Not (Dvd.dvd p x)\nn : Nat\nhn : Odd n\n⊢ Eq (padicValNat p (HAdd.hAdd (HPow.hPow x n) (HPow.hPow y n))) (HAdd.hAdd (padicValNat p (HAdd.hAdd x y)) (padicValNat p n))","decl":"theorem pow_add_pow (hxy : p ∣ x + y) (hx : ¬p ∣ x) {n : ℕ} (hn : Odd n) :\n    padicValNat p (x ^ n + y ^ n) = padicValNat p (x + y) + padicValNat p n := by\n  cases' y with y\n  · contradiction\n  rw [← Nat.cast_inj (R := ℕ∞), Nat.cast_add]\n  iterate 3 rw [padicValNat_eq_emultiplicity]\n  · exact Nat.emultiplicity_pow_add_pow hp.out hp1 hxy hx hn\n  · exact Odd.pos hn\n  · simp only [add_pos_iff, Nat.succ_pos', or_true]\n  · exact Nat.lt_add_left _ (pow_pos y.succ_pos _)\n\n"}
