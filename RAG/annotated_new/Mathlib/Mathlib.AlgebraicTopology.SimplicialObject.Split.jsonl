{"name":"SimplicialObject.Splitting.IndexSet.mk_snd_coe","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"Œî Œî' : SimplexCategory\nf : Quiver.Hom Œî Œî'\ninst‚úù : CategoryTheory.Epi f\n‚ä¢ Eq (‚Üë(SimplicialObject.Splitting.IndexSet.mk f).snd) f","decl":"/-- The element in `Splitting.IndexSet Œî` attached to an epimorphism `f : Œî ‚ü∂ Œî'`. -/\n@[simps]\ndef mk {Œî Œî' : SimplexCategory} (f : Œî ‚ü∂ Œî') [Epi f] : IndexSet (op Œî) :=\n  ‚ü®op Œî', f, inferInstance‚ü©\n\n"}
{"name":"SimplicialObject.Splitting.IndexSet.mk_fst","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"Œî Œî' : SimplexCategory\nf : Quiver.Hom Œî Œî'\ninst‚úù : CategoryTheory.Epi f\n‚ä¢ Eq (SimplicialObject.Splitting.IndexSet.mk f).fst { unop := Œî' }","decl":"/-- The element in `Splitting.IndexSet Œî` attached to an epimorphism `f : Œî ‚ü∂ Œî'`. -/\n@[simps]\ndef mk {Œî Œî' : SimplexCategory} (f : Œî ‚ü∂ Œî') [Epi f] : IndexSet (op Œî) :=\n  ‚ü®op Œî', f, inferInstance‚ü©\n\n"}
{"name":"SimplicialObject.Splitting.IndexSet.instEpiSimplexCategoryE","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"Œî : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Œî\n‚ä¢ CategoryTheory.Epi A.e","decl":"instance : Epi A.e :=\n  A.2.2\n\n"}
{"name":"SimplicialObject.Splitting.IndexSet.ext'","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"Œî : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Œî\n‚ä¢ Eq A ‚ü®A.fst, ‚ü®A.e, ‚ãØ‚ü©‚ü©","decl":"theorem ext' : A = ‚ü®A.1, ‚ü®A.e, A.2.2‚ü©‚ü© := rfl\n\n"}
{"name":"SimplicialObject.Splitting.IndexSet.ext","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"Œî : Opposite SimplexCategory\nA‚ÇÅ A‚ÇÇ : SimplicialObject.Splitting.IndexSet Œî\nh‚ÇÅ : Eq A‚ÇÅ.fst A‚ÇÇ.fst\nh‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp A‚ÇÅ.e (CategoryTheory.eqToHom ‚ãØ)) A‚ÇÇ.e\n‚ä¢ Eq A‚ÇÅ A‚ÇÇ","decl":"theorem ext (A‚ÇÅ A‚ÇÇ : IndexSet Œî) (h‚ÇÅ : A‚ÇÅ.1 = A‚ÇÇ.1) (h‚ÇÇ : A‚ÇÅ.e ‚â´ eqToHom (by rw [h‚ÇÅ]) = A‚ÇÇ.e) :\n    A‚ÇÅ = A‚ÇÇ := by\n  rcases A‚ÇÅ with ‚ü®Œî‚ÇÅ, ‚ü®Œ±‚ÇÅ, hŒ±‚ÇÅ‚ü©‚ü©\n  rcases A‚ÇÇ with ‚ü®Œî‚ÇÇ, ‚ü®Œ±‚ÇÇ, hŒ±‚ÇÇ‚ü©‚ü©\n  simp only at h‚ÇÅ\n  subst h‚ÇÅ\n  simp only [eqToHom_refl, comp_id, IndexSet.e] at h‚ÇÇ\n  simp only [h‚ÇÇ]\n\n"}
{"name":"SimplicialObject.Splitting.IndexSet.id_fst","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"Œî : Opposite SimplexCategory\n‚ä¢ Eq (SimplicialObject.Splitting.IndexSet.id Œî).fst Œî","decl":"/-- The distinguished element in `Splitting.IndexSet Œî` which corresponds to the\nidentity of `Œî`. -/\n@[simps]\ndef id : IndexSet Œî :=\n  ‚ü®Œî, ‚ü®ùüô _, by infer_instance‚ü©‚ü©\n\n"}
{"name":"SimplicialObject.Splitting.IndexSet.id_snd_coe","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"Œî : Opposite SimplexCategory\n‚ä¢ Eq (‚Üë(SimplicialObject.Splitting.IndexSet.id Œî).snd) (CategoryTheory.CategoryStruct.id (Opposite.unop Œî))","decl":"/-- The distinguished element in `Splitting.IndexSet Œî` which corresponds to the\nidentity of `Œî`. -/\n@[simps]\ndef id : IndexSet Œî :=\n  ‚ü®Œî, ‚ü®ùüô _, by infer_instance‚ü©‚ü©\n\n"}
{"name":"SimplicialObject.Splitting.IndexSet.eqId_iff_eq","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"Œî : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Œî\n‚ä¢ Iff A.EqId (Eq A.fst Œî)","decl":"theorem eqId_iff_eq : A.EqId ‚Üî A.1 = Œî := by\n  constructor\n  ¬∑ intro h\n    dsimp at h\n    rw [h]\n    rfl\n  ¬∑ intro h\n    rcases A with ‚ü®_, ‚ü®f, hf‚ü©‚ü©\n    simp only at h\n    subst h\n    refine ext _ _ rfl ?_\n    haveI := hf\n    simp only [eqToHom_refl, comp_id]\n    exact eq_id_of_epi f\n\n"}
{"name":"SimplicialObject.Splitting.IndexSet.eqId_iff_len_eq","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"Œî : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Œî\n‚ä¢ Iff A.EqId (Eq (Opposite.unop A.fst).len (Opposite.unop Œî).len)","decl":"theorem eqId_iff_len_eq : A.EqId ‚Üî A.1.unop.len = Œî.unop.len := by\n  rw [eqId_iff_eq]\n  constructor\n  ¬∑ intro h\n    rw [h]\n  ¬∑ intro h\n    rw [‚Üê unop_inj_iff]\n    ext\n    exact h\n\n"}
{"name":"SimplicialObject.Splitting.IndexSet.eqId_iff_len_le","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"Œî : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Œî\n‚ä¢ Iff A.EqId (LE.le (Opposite.unop Œî).len (Opposite.unop A.fst).len)","decl":"theorem eqId_iff_len_le : A.EqId ‚Üî Œî.unop.len ‚â§ A.1.unop.len := by\n  rw [eqId_iff_len_eq]\n  constructor\n  ¬∑ intro h\n    rw [h]\n  ¬∑ exact le_antisymm (len_le_of_epi (inferInstance : Epi A.e))\n\n"}
{"name":"SimplicialObject.Splitting.IndexSet.eqId_iff_mono","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"Œî : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Œî\n‚ä¢ Iff A.EqId (CategoryTheory.Mono A.e)","decl":"theorem eqId_iff_mono : A.EqId ‚Üî Mono A.e := by\n  constructor\n  ¬∑ intro h\n    dsimp at h\n    subst h\n    dsimp only [id, e]\n    infer_instance\n  ¬∑ intro h\n    rw [eqId_iff_len_le]\n    exact len_le_of_mono h\n\n"}
{"name":"SimplicialObject.Splitting.IndexSet.epiComp_snd_coe","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"Œî‚ÇÅ Œî‚ÇÇ : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Œî‚ÇÅ\np : Quiver.Hom Œî‚ÇÅ Œî‚ÇÇ\ninst‚úù : CategoryTheory.Epi p.unop\n‚ä¢ Eq (‚Üë(A.epiComp p).snd) (CategoryTheory.CategoryStruct.comp p.unop A.e)","decl":"/-- Given `A : IndexSet Œî‚ÇÅ`, if `p.unop : unop Œî‚ÇÇ ‚ü∂ unop Œî‚ÇÅ` is an epi, this\nis the obvious element in `A : IndexSet Œî‚ÇÇ` associated to the composition\nof epimorphisms `p.unop ‚â´ A.e`. -/\n@[simps]\ndef epiComp {Œî‚ÇÅ Œî‚ÇÇ : SimplexCategory·µí·µñ} (A : IndexSet Œî‚ÇÅ) (p : Œî‚ÇÅ ‚ü∂ Œî‚ÇÇ) [Epi p.unop] :\n    IndexSet Œî‚ÇÇ :=\n  ‚ü®A.1, ‚ü®p.unop ‚â´ A.e, epi_comp _ _‚ü©‚ü©\n\n\n"}
{"name":"SimplicialObject.Splitting.IndexSet.epiComp_fst","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"Œî‚ÇÅ Œî‚ÇÇ : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Œî‚ÇÅ\np : Quiver.Hom Œî‚ÇÅ Œî‚ÇÇ\ninst‚úù : CategoryTheory.Epi p.unop\n‚ä¢ Eq (A.epiComp p).fst A.fst","decl":"/-- Given `A : IndexSet Œî‚ÇÅ`, if `p.unop : unop Œî‚ÇÇ ‚ü∂ unop Œî‚ÇÅ` is an epi, this\nis the obvious element in `A : IndexSet Œî‚ÇÇ` associated to the composition\nof epimorphisms `p.unop ‚â´ A.e`. -/\n@[simps]\ndef epiComp {Œî‚ÇÅ Œî‚ÇÇ : SimplexCategory·µí·µñ} (A : IndexSet Œî‚ÇÅ) (p : Œî‚ÇÅ ‚ü∂ Œî‚ÇÇ) [Epi p.unop] :\n    IndexSet Œî‚ÇÇ :=\n  ‚ü®A.1, ‚ü®p.unop ‚â´ A.e, epi_comp _ _‚ü©‚ü©\n\n\n"}
{"name":"SimplicialObject.Splitting.IndexSet.fac_pull_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"Œî : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Œî\nŒî' : Opposite SimplexCategory\nŒ∏ : Quiver.Hom Œî Œî'\nZ : SimplexCategory\nh : Quiver.Hom (Opposite.unop A.fst) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (A.pull Œ∏).e (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.Œπ (CategoryTheory.CategoryStruct.comp Œ∏.unop A.e)) h)) (CategoryTheory.CategoryStruct.comp Œ∏.unop (CategoryTheory.CategoryStruct.comp A.e h))","decl":"@[reassoc]\ntheorem fac_pull : (A.pull Œ∏).e ‚â´ image.Œπ (Œ∏.unop ‚â´ A.e) = Œ∏.unop ‚â´ A.e :=\n  image.fac _\n\n"}
{"name":"SimplicialObject.Splitting.IndexSet.fac_pull","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"Œî : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Œî\nŒî' : Opposite SimplexCategory\nŒ∏ : Quiver.Hom Œî Œî'\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (A.pull Œ∏).e (CategoryTheory.Limits.image.Œπ (CategoryTheory.CategoryStruct.comp Œ∏.unop A.e))) (CategoryTheory.CategoryStruct.comp Œ∏.unop A.e)","decl":"@[reassoc]\ntheorem fac_pull : (A.pull Œ∏).e ‚â´ image.Œπ (Œ∏.unop ‚â´ A.e) = Œ∏.unop ‚â´ A.e :=\n  image.fac _\n\n"}
{"name":"SimplicialObject.Splitting.mk.sizeOf_spec","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ninst‚úù : SizeOf C\nN : Nat ‚Üí C\nŒπ : (n : Nat) ‚Üí Quiver.Hom (N n) (X.obj { unop := SimplexCategory.mk n })\nisColimit' : (Œî : Opposite SimplexCategory) ‚Üí CategoryTheory.Limits.IsColimit (SimplicialObject.Splitting.cofan' N X Œπ Œî)\n‚ä¢ Eq (SizeOf.sizeOf { N := N, Œπ := Œπ, isColimit' := isColimit' }) 1","decl":"/-- A splitting of a simplicial object `X` consists of the datum of a sequence\nof objects `N`, a sequence of morphisms `Œπ : N n ‚ü∂ X _[n]` such that\nfor all `Œî : SimplexCategory·µí·µñ`, the canonical map `Splitting.map X Œπ Œî`\nis an isomorphism. -/\nstructure Splitting (X : SimplicialObject C) where\n  /-- The \"nondegenerate simplices\" `N n` for all `n : ‚Ñï`. -/\n  N : ‚Ñï ‚Üí C\n  /-- The \"inclusion\" `N n ‚ü∂ X _[n]` for all `n : ‚Ñï`. -/\n  Œπ : ‚àÄ n, N n ‚ü∂ X _[n]\n  /-- For each `Œî`, `X.obj Œî` identifies to the coproduct of the objects `N A.1.unop.len`\n  for all `A : IndexSet Œî`. -/\n  isColimit' : ‚àÄ Œî : SimplexCategory·µí·µñ, IsColimit (Splitting.cofan' N X Œπ Œî)\n\n"}
{"name":"SimplicialObject.Splitting.mk.injEq","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\nN‚úù : Nat ‚Üí C\nŒπ‚úù : (n : Nat) ‚Üí Quiver.Hom (N‚úù n) (X.obj { unop := SimplexCategory.mk n })\nisColimit'‚úù : (Œî : Opposite SimplexCategory) ‚Üí CategoryTheory.Limits.IsColimit (SimplicialObject.Splitting.cofan' N‚úù X Œπ‚úù Œî)\nN : Nat ‚Üí C\nŒπ : (n : Nat) ‚Üí Quiver.Hom (N n) (X.obj { unop := SimplexCategory.mk n })\nisColimit' : (Œî : Opposite SimplexCategory) ‚Üí CategoryTheory.Limits.IsColimit (SimplicialObject.Splitting.cofan' N X Œπ Œî)\n‚ä¢ Eq (Eq { N := N‚úù, Œπ := Œπ‚úù, isColimit' := isColimit'‚úù } { N := N, Œπ := Œπ, isColimit' := isColimit' }) (And (Eq N‚úù N) (And (HEq Œπ‚úù Œπ) (HEq isColimit'‚úù isColimit')))","decl":"/-- A splitting of a simplicial object `X` consists of the datum of a sequence\nof objects `N`, a sequence of morphisms `Œπ : N n ‚ü∂ X _[n]` such that\nfor all `Œî : SimplexCategory·µí·µñ`, the canonical map `Splitting.map X Œπ Œî`\nis an isomorphism. -/\nstructure Splitting (X : SimplicialObject C) where\n  /-- The \"nondegenerate simplices\" `N n` for all `n : ‚Ñï`. -/\n  N : ‚Ñï ‚Üí C\n  /-- The \"inclusion\" `N n ‚ü∂ X _[n]` for all `n : ‚Ñï`. -/\n  Œπ : ‚àÄ n, N n ‚ü∂ X _[n]\n  /-- For each `Œî`, `X.obj Œî` identifies to the coproduct of the objects `N A.1.unop.len`\n  for all `A : IndexSet Œî`. -/\n  isColimit' : ‚àÄ Œî : SimplexCategory·µí·µñ, IsColimit (Splitting.cofan' N X Œπ Œî)\n\n"}
{"name":"SimplicialObject.Splitting.mk.inj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\nN‚úù : Nat ‚Üí C\nŒπ‚úù : (n : Nat) ‚Üí Quiver.Hom (N‚úù n) (X.obj { unop := SimplexCategory.mk n })\nisColimit'‚úù : (Œî : Opposite SimplexCategory) ‚Üí CategoryTheory.Limits.IsColimit (SimplicialObject.Splitting.cofan' N‚úù X Œπ‚úù Œî)\nN : Nat ‚Üí C\nŒπ : (n : Nat) ‚Üí Quiver.Hom (N n) (X.obj { unop := SimplexCategory.mk n })\nisColimit' : (Œî : Opposite SimplexCategory) ‚Üí CategoryTheory.Limits.IsColimit (SimplicialObject.Splitting.cofan' N X Œπ Œî)\nx‚úù : Eq { N := N‚úù, Œπ := Œπ‚úù, isColimit' := isColimit'‚úù } { N := N, Œπ := Œπ, isColimit' := isColimit' }\n‚ä¢ And (Eq N‚úù N) (And (HEq Œπ‚úù Œπ) (HEq isColimit'‚úù isColimit'))","decl":"/-- A splitting of a simplicial object `X` consists of the datum of a sequence\nof objects `N`, a sequence of morphisms `Œπ : N n ‚ü∂ X _[n]` such that\nfor all `Œî : SimplexCategory·µí·µñ`, the canonical map `Splitting.map X Œπ Œî`\nis an isomorphism. -/\nstructure Splitting (X : SimplicialObject C) where\n  /-- The \"nondegenerate simplices\" `N n` for all `n : ‚Ñï`. -/\n  N : ‚Ñï ‚Üí C\n  /-- The \"inclusion\" `N n ‚ü∂ X _[n]` for all `n : ‚Ñï`. -/\n  Œπ : ‚àÄ n, N n ‚ü∂ X _[n]\n  /-- For each `Œî`, `X.obj Œî` identifies to the coproduct of the objects `N A.1.unop.len`\n  for all `A : IndexSet Œî`. -/\n  isColimit' : ‚àÄ Œî : SimplexCategory·µí·µñ, IsColimit (Splitting.cofan' N X Œπ Œî)\n\n"}
{"name":"SimplicialObject.Splitting.cofan_inj_eq","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\nŒî : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Œî\n‚ä¢ Eq ((s.cofan Œî).inj A) (CategoryTheory.CategoryStruct.comp (s.Œπ (Opposite.unop A.fst).len) (X.map A.e.op))","decl":"@[reassoc]\ntheorem cofan_inj_eq {Œî : SimplexCategory·µí·µñ} (A : IndexSet Œî) :\n    (s.cofan Œî).inj  A = s.Œπ A.1.unop.len ‚â´ X.map A.e.op := rfl\n\n"}
{"name":"SimplicialObject.Splitting.cofan_inj_eq_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\nŒî : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Œî\nZ : C\nh : Quiver.Hom (s.cofan Œî).pt Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((s.cofan Œî).inj A) h) (CategoryTheory.CategoryStruct.comp (s.Œπ (Opposite.unop A.fst).len) (CategoryTheory.CategoryStruct.comp (X.map A.e.op) h))","decl":"@[reassoc]\ntheorem cofan_inj_eq {Œî : SimplexCategory·µí·µñ} (A : IndexSet Œî) :\n    (s.cofan Œî).inj  A = s.Œπ A.1.unop.len ‚â´ X.map A.e.op := rfl\n\n"}
{"name":"SimplicialObject.Splitting.cofan_inj_id","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\nn : Nat\n‚ä¢ Eq ((s.cofan { unop := SimplexCategory.mk n }).inj (SimplicialObject.Splitting.IndexSet.id { unop := SimplexCategory.mk n })) (s.Œπ n)","decl":"theorem cofan_inj_id (n : ‚Ñï) : (s.cofan _).inj (IndexSet.id (op [n])) = s.Œπ n := by\n  erw [cofan_inj_eq, X.map_id, comp_id]\n  rfl\n\n"}
{"name":"SimplicialObject.Splitting.cofan_inj_comp_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX Y : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\nf : Quiver.Hom X Y\nŒî : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Œî\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((s.cofan Œî).inj A) (f.app Œî)) (CategoryTheory.CategoryStruct.comp (s.œÜ f (Opposite.unop A.fst).len) (Y.map A.e.op))","decl":"@[reassoc (attr := simp)]\ntheorem cofan_inj_comp_app (f : X ‚ü∂ Y) {Œî : SimplexCategory·µí·µñ} (A : IndexSet Œî) :\n    (s.cofan Œî).inj A ‚â´ f.app Œî = s.œÜ f A.1.unop.len ‚â´ Y.map A.e.op := by\n  simp only [cofan_inj_eq_assoc, œÜ, assoc]\n  rw [NatTrans.naturality]\n\n"}
{"name":"SimplicialObject.Splitting.cofan_inj_comp_app_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX Y : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\nf : Quiver.Hom X Y\nŒî : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Œî\nZ : C\nh : Quiver.Hom (Y.obj Œî) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((s.cofan Œî).inj A) (CategoryTheory.CategoryStruct.comp (f.app Œî) h)) (CategoryTheory.CategoryStruct.comp (s.œÜ f (Opposite.unop A.fst).len) (CategoryTheory.CategoryStruct.comp (Y.map A.e.op) h))","decl":"@[reassoc (attr := simp)]\ntheorem cofan_inj_comp_app (f : X ‚ü∂ Y) {Œî : SimplexCategory·µí·µñ} (A : IndexSet Œî) :\n    (s.cofan Œî).inj A ‚â´ f.app Œî = s.œÜ f A.1.unop.len ‚â´ Y.map A.e.op := by\n  simp only [cofan_inj_eq_assoc, œÜ, assoc]\n  rw [NatTrans.naturality]\n\n"}
{"name":"SimplicialObject.Splitting.hom_ext'","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\nZ : C\nŒî : Opposite SimplexCategory\nf g : Quiver.Hom (X.obj Œî) Z\nh : ‚àÄ (A : SimplicialObject.Splitting.IndexSet Œî), Eq (CategoryTheory.CategoryStruct.comp ((s.cofan Œî).inj A) f) (CategoryTheory.CategoryStruct.comp ((s.cofan Œî).inj A) g)\n‚ä¢ Eq f g","decl":"theorem hom_ext' {Z : C} {Œî : SimplexCategory·µí·µñ} (f g : X.obj Œî ‚ü∂ Z)\n    (h : ‚àÄ A : IndexSet Œî, (s.cofan Œî).inj A ‚â´ f = (s.cofan Œî).inj A ‚â´ g) : f = g :=\n  Cofan.IsColimit.hom_ext (s.isColimit Œî) _ _ h\n\n"}
{"name":"SimplicialObject.Splitting.hom_ext","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX Y : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\nf g : Quiver.Hom X Y\nh : ‚àÄ (n : Nat), Eq (s.œÜ f n) (s.œÜ g n)\n‚ä¢ Eq f g","decl":"theorem hom_ext (f g : X ‚ü∂ Y) (h : ‚àÄ n : ‚Ñï, s.œÜ f n = s.œÜ g n) : f = g := by\n  ext Œî\n  apply s.hom_ext'\n  intro A\n  induction' Œî using Opposite.rec with Œî\n  induction' Œî using SimplexCategory.rec with n\n  dsimp\n  simp only [s.cofan_inj_comp_app, h]\n\n"}
{"name":"SimplicialObject.Splitting.Œπ_desc_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\nZ‚úù : C\nŒî : Opposite SimplexCategory\nF : (A : SimplicialObject.Splitting.IndexSet Œî) ‚Üí Quiver.Hom (s.N (Opposite.unop A.fst).len) Z‚úù\nA : SimplicialObject.Splitting.IndexSet Œî\nZ : C\nh : Quiver.Hom Z‚úù Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((s.cofan Œî).inj A) (CategoryTheory.CategoryStruct.comp (s.desc Œî F) h)) (CategoryTheory.CategoryStruct.comp (F A) h)","decl":"@[reassoc (attr := simp)]\ntheorem Œπ_desc {Z : C} (Œî : SimplexCategory·µí·µñ) (F : ‚àÄ A : IndexSet Œî, s.N A.1.unop.len ‚ü∂ Z)\n    (A : IndexSet Œî) : (s.cofan Œî).inj A ‚â´ s.desc Œî F = F A := by\n  apply Cofan.IsColimit.fac\n\n"}
{"name":"SimplicialObject.Splitting.Œπ_desc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\nZ : C\nŒî : Opposite SimplexCategory\nF : (A : SimplicialObject.Splitting.IndexSet Œî) ‚Üí Quiver.Hom (s.N (Opposite.unop A.fst).len) Z\nA : SimplicialObject.Splitting.IndexSet Œî\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((s.cofan Œî).inj A) (s.desc Œî F)) (F A)","decl":"@[reassoc (attr := simp)]\ntheorem Œπ_desc {Z : C} (Œî : SimplexCategory·µí·µñ) (F : ‚àÄ A : IndexSet Œî, s.N A.1.unop.len ‚ü∂ Z)\n    (A : IndexSet Œî) : (s.cofan Œî).inj A ‚â´ s.desc Œî F = F A := by\n  apply Cofan.IsColimit.fac\n\n"}
{"name":"SimplicialObject.Splitting.ofIso_isColimit'","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX Y : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\ne : CategoryTheory.Iso X Y\nŒî : Opposite SimplexCategory\n‚ä¢ Eq ((s.ofIso e).isColimit' Œî) ((s.isColimit Œî).ofIsoColimit (CategoryTheory.Limits.Cofan.ext (e.app Œî) ‚ãØ))","decl":"/-- A simplicial object that is isomorphic to a split simplicial object is split. -/\n@[simps]\ndef ofIso (e : X ‚âÖ Y) : Splitting Y where\n  N := s.N\n  Œπ n := s.Œπ n ‚â´ e.hom.app (op [n])\n  isColimit' Œî := IsColimit.ofIsoColimit (s.isColimit Œî ) (Cofan.ext (e.app Œî)\n    (fun A => by simp [cofan, cofan']))\n\n"}
{"name":"SimplicialObject.Splitting.ofIso_Œπ","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX Y : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\ne : CategoryTheory.Iso X Y\nn : Nat\n‚ä¢ Eq ((s.ofIso e).Œπ n) (CategoryTheory.CategoryStruct.comp (s.Œπ n) (e.hom.app { unop := SimplexCategory.mk n }))","decl":"/-- A simplicial object that is isomorphic to a split simplicial object is split. -/\n@[simps]\ndef ofIso (e : X ‚âÖ Y) : Splitting Y where\n  N := s.N\n  Œπ n := s.Œπ n ‚â´ e.hom.app (op [n])\n  isColimit' Œî := IsColimit.ofIsoColimit (s.isColimit Œî ) (Cofan.ext (e.app Œî)\n    (fun A => by simp [cofan, cofan']))\n\n"}
{"name":"SimplicialObject.Splitting.ofIso_N","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX Y : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\ne : CategoryTheory.Iso X Y\na‚úù : Nat\n‚ä¢ Eq ((s.ofIso e).N a‚úù) (s.N a‚úù)","decl":"/-- A simplicial object that is isomorphic to a split simplicial object is split. -/\n@[simps]\ndef ofIso (e : X ‚âÖ Y) : Splitting Y where\n  N := s.N\n  Œπ n := s.Œπ n ‚â´ e.hom.app (op [n])\n  isColimit' Œî := IsColimit.ofIsoColimit (s.isColimit Œî ) (Cofan.ext (e.app Œî)\n    (fun A => by simp [cofan, cofan']))\n\n"}
{"name":"SimplicialObject.Splitting.cofan_inj_epi_naturality","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\nŒî‚ÇÅ Œî‚ÇÇ : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Œî‚ÇÅ\np : Quiver.Hom Œî‚ÇÅ Œî‚ÇÇ\ninst‚úù : CategoryTheory.Epi p.unop\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((s.cofan Œî‚ÇÅ).inj A) (X.map p)) ((s.cofan Œî‚ÇÇ).inj (A.epiComp p))","decl":"@[reassoc]\ntheorem cofan_inj_epi_naturality {Œî‚ÇÅ Œî‚ÇÇ : SimplexCategory·µí·µñ} (A : IndexSet Œî‚ÇÅ) (p : Œî‚ÇÅ ‚ü∂ Œî‚ÇÇ)\n    [Epi p.unop] : (s.cofan Œî‚ÇÅ).inj A ‚â´ X.map p = (s.cofan Œî‚ÇÇ).inj (A.epiComp p) := by\n  dsimp [cofan]\n  rw [assoc, ‚Üê X.map_comp]\n  rfl\n\n"}
{"name":"SimplicialObject.Splitting.cofan_inj_epi_naturality_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\nŒî‚ÇÅ Œî‚ÇÇ : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Œî‚ÇÅ\np : Quiver.Hom Œî‚ÇÅ Œî‚ÇÇ\ninst‚úù : CategoryTheory.Epi p.unop\nZ : C\nh : Quiver.Hom (X.obj Œî‚ÇÇ) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((s.cofan Œî‚ÇÅ).inj A) (CategoryTheory.CategoryStruct.comp (X.map p) h)) (CategoryTheory.CategoryStruct.comp ((s.cofan Œî‚ÇÇ).inj (A.epiComp p)) h)","decl":"@[reassoc]\ntheorem cofan_inj_epi_naturality {Œî‚ÇÅ Œî‚ÇÇ : SimplexCategory·µí·µñ} (A : IndexSet Œî‚ÇÅ) (p : Œî‚ÇÅ ‚ü∂ Œî‚ÇÇ)\n    [Epi p.unop] : (s.cofan Œî‚ÇÅ).inj A ‚â´ X.map p = (s.cofan Œî‚ÇÇ).inj (A.epiComp p) := by\n  dsimp [cofan]\n  rw [assoc, ‚Üê X.map_comp]\n  rfl\n\n"}
{"name":"SimplicialObject.Split.mk.injEq","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX‚úù : CategoryTheory.SimplicialObject C\ns‚úù : SimplicialObject.Splitting X‚úù\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\n‚ä¢ Eq (Eq { X := X‚úù, s := s‚úù } { X := X, s := s }) (And (Eq X‚úù X) (HEq s‚úù s))","decl":"/-- The category `SimplicialObject.Split C` is the category of simplicial objects\nin `C` equipped with a splitting, and morphisms are morphisms of simplicial objects\nwhich are compatible with the splittings. -/\n@[ext]\nstructure Split where\n  /-- the underlying simplicial object -/\n  X : SimplicialObject C\n  /-- a splitting of the simplicial object -/\n  s : Splitting X\n\n"}
{"name":"SimplicialObject.Split.mk.inj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX‚úù : CategoryTheory.SimplicialObject C\ns‚úù : SimplicialObject.Splitting X‚úù\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\nx‚úù : Eq { X := X‚úù, s := s‚úù } { X := X, s := s }\n‚ä¢ And (Eq X‚úù X) (HEq s‚úù s)","decl":"/-- The category `SimplicialObject.Split C` is the category of simplicial objects\nin `C` equipped with a splitting, and morphisms are morphisms of simplicial objects\nwhich are compatible with the splittings. -/\n@[ext]\nstructure Split where\n  /-- the underlying simplicial object -/\n  X : SimplicialObject C\n  /-- a splitting of the simplicial object -/\n  s : Splitting X\n\n"}
{"name":"SimplicialObject.Split.ext","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nx y : SimplicialObject.Split C\nX : Eq x.X y.X\ns : HEq x.s y.s\n‚ä¢ Eq x y","decl":"/-- The category `SimplicialObject.Split C` is the category of simplicial objects\nin `C` equipped with a splitting, and morphisms are morphisms of simplicial objects\nwhich are compatible with the splittings. -/\n@[ext]\nstructure Split where\n  /-- the underlying simplicial object -/\n  X : SimplicialObject C\n  /-- a splitting of the simplicial object -/\n  s : Splitting X\n\n"}
{"name":"SimplicialObject.Split.mk.sizeOf_spec","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : SizeOf C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\n‚ä¢ Eq (SizeOf.sizeOf { X := X, s := s }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf X)) (SizeOf.sizeOf s))","decl":"/-- The category `SimplicialObject.Split C` is the category of simplicial objects\nin `C` equipped with a splitting, and morphisms are morphisms of simplicial objects\nwhich are compatible with the splittings. -/\n@[ext]\nstructure Split where\n  /-- the underlying simplicial object -/\n  X : SimplicialObject C\n  /-- a splitting of the simplicial object -/\n  s : Splitting X\n\n"}
{"name":"SimplicialObject.Split.ext_iff","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nx y : SimplicialObject.Split C\n‚ä¢ Iff (Eq x y) (And (Eq x.X y.X) (HEq x.s y.s))","decl":"/-- The category `SimplicialObject.Split C` is the category of simplicial objects\nin `C` equipped with a splitting, and morphisms are morphisms of simplicial objects\nwhich are compatible with the splittings. -/\n@[ext]\nstructure Split where\n  /-- the underlying simplicial object -/\n  X : SimplicialObject C\n  /-- a splitting of the simplicial object -/\n  s : Splitting X\n\n"}
{"name":"SimplicialObject.Split.mk'_s","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\n‚ä¢ Eq (SimplicialObject.Split.mk' s).s s","decl":"/-- The object in `SimplicialObject.Split C` attached to a splitting `s : Splitting X`\nof a simplicial object `X`. -/\n@[simps]\ndef mk' {X : SimplicialObject C} (s : Splitting X) : Split C :=\n  ‚ü®X, s‚ü©\n\n"}
{"name":"SimplicialObject.Split.mk'_X","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\n‚ä¢ Eq (SimplicialObject.Split.mk' s).X X","decl":"/-- The object in `SimplicialObject.Split C` attached to a splitting `s : Splitting X`\nof a simplicial object `X`. -/\n@[simps]\ndef mk' {X : SimplicialObject C} (s : Splitting X) : Split C :=\n  ‚ü®X, s‚ü©\n\n"}
{"name":"SimplicialObject.Split.Hom.mk.sizeOf_spec","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nS‚ÇÅ S‚ÇÇ : SimplicialObject.Split C\ninst‚úù : SizeOf C\nF : Quiver.Hom S‚ÇÅ.X S‚ÇÇ.X\nf : (n : Nat) ‚Üí Quiver.Hom (S‚ÇÅ.s.N n) (S‚ÇÇ.s.N n)\ncomm : autoParam (‚àÄ (n : Nat), Eq (CategoryTheory.CategoryStruct.comp (S‚ÇÅ.s.Œπ n) (F.app { unop := SimplexCategory.mk n })) (CategoryTheory.CategoryStruct.comp (f n) (S‚ÇÇ.s.Œπ n))) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { F := F, f := f, comm := comm }) (HAdd.hAdd 1 (SizeOf.sizeOf F))","decl":"/-- Morphisms in `SimplicialObject.Split C` are morphisms of simplicial objects that\nare compatible with the splittings. -/\nstructure Hom (S‚ÇÅ S‚ÇÇ : Split C) where\n  /-- the morphism between the underlying simplicial objects -/\n  F : S‚ÇÅ.X ‚ü∂ S‚ÇÇ.X\n  /-- the morphism between the \"nondegenerate\" `n`-simplices for all `n : ‚Ñï` -/\n  f : ‚àÄ n : ‚Ñï, S‚ÇÅ.s.N n ‚ü∂ S‚ÇÇ.s.N n\n  comm : ‚àÄ n : ‚Ñï, S‚ÇÅ.s.Œπ n ‚â´ F.app (op [n]) = f n ‚â´ S‚ÇÇ.s.Œπ n := by aesop_cat\n\n"}
{"name":"SimplicialObject.Split.Hom.comm","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nS‚ÇÅ S‚ÇÇ : SimplicialObject.Split C\nself : S‚ÇÅ.Hom S‚ÇÇ\nn : Nat\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (S‚ÇÅ.s.Œπ n) (self.F.app { unop := SimplexCategory.mk n })) (CategoryTheory.CategoryStruct.comp (self.f n) (S‚ÇÇ.s.Œπ n))","decl":"/-- Morphisms in `SimplicialObject.Split C` are morphisms of simplicial objects that\nare compatible with the splittings. -/\nstructure Hom (S‚ÇÅ S‚ÇÇ : Split C) where\n  /-- the morphism between the underlying simplicial objects -/\n  F : S‚ÇÅ.X ‚ü∂ S‚ÇÇ.X\n  /-- the morphism between the \"nondegenerate\" `n`-simplices for all `n : ‚Ñï` -/\n  f : ‚àÄ n : ‚Ñï, S‚ÇÅ.s.N n ‚ü∂ S‚ÇÇ.s.N n\n  comm : ‚àÄ n : ‚Ñï, S‚ÇÅ.s.Œπ n ‚â´ F.app (op [n]) = f n ‚â´ S‚ÇÇ.s.Œπ n := by aesop_cat\n\n"}
{"name":"SimplicialObject.Split.Hom.mk.injEq","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nS‚ÇÅ S‚ÇÇ : SimplicialObject.Split C\nF‚úù : Quiver.Hom S‚ÇÅ.X S‚ÇÇ.X\nf‚úù : (n : Nat) ‚Üí Quiver.Hom (S‚ÇÅ.s.N n) (S‚ÇÇ.s.N n)\ncomm‚úù : autoParam (‚àÄ (n : Nat), Eq (CategoryTheory.CategoryStruct.comp (S‚ÇÅ.s.Œπ n) (F‚úù.app { unop := SimplexCategory.mk n })) (CategoryTheory.CategoryStruct.comp (f‚úù n) (S‚ÇÇ.s.Œπ n))) _auto‚úù\nF : Quiver.Hom S‚ÇÅ.X S‚ÇÇ.X\nf : (n : Nat) ‚Üí Quiver.Hom (S‚ÇÅ.s.N n) (S‚ÇÇ.s.N n)\ncomm : autoParam (‚àÄ (n : Nat), Eq (CategoryTheory.CategoryStruct.comp (S‚ÇÅ.s.Œπ n) (F.app { unop := SimplexCategory.mk n })) (CategoryTheory.CategoryStruct.comp (f n) (S‚ÇÇ.s.Œπ n))) _auto‚úù\n‚ä¢ Eq (Eq { F := F‚úù, f := f‚úù, comm := comm‚úù } { F := F, f := f, comm := comm }) (And (Eq F‚úù F) (Eq f‚úù f))","decl":"/-- Morphisms in `SimplicialObject.Split C` are morphisms of simplicial objects that\nare compatible with the splittings. -/\nstructure Hom (S‚ÇÅ S‚ÇÇ : Split C) where\n  /-- the morphism between the underlying simplicial objects -/\n  F : S‚ÇÅ.X ‚ü∂ S‚ÇÇ.X\n  /-- the morphism between the \"nondegenerate\" `n`-simplices for all `n : ‚Ñï` -/\n  f : ‚àÄ n : ‚Ñï, S‚ÇÅ.s.N n ‚ü∂ S‚ÇÇ.s.N n\n  comm : ‚àÄ n : ‚Ñï, S‚ÇÅ.s.Œπ n ‚â´ F.app (op [n]) = f n ‚â´ S‚ÇÇ.s.Œπ n := by aesop_cat\n\n"}
{"name":"SimplicialObject.Split.Hom.mk.inj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nS‚ÇÅ S‚ÇÇ : SimplicialObject.Split C\nF‚úù : Quiver.Hom S‚ÇÅ.X S‚ÇÇ.X\nf‚úù : (n : Nat) ‚Üí Quiver.Hom (S‚ÇÅ.s.N n) (S‚ÇÇ.s.N n)\ncomm‚úù : autoParam (‚àÄ (n : Nat), Eq (CategoryTheory.CategoryStruct.comp (S‚ÇÅ.s.Œπ n) (F‚úù.app { unop := SimplexCategory.mk n })) (CategoryTheory.CategoryStruct.comp (f‚úù n) (S‚ÇÇ.s.Œπ n))) _auto‚úù\nF : Quiver.Hom S‚ÇÅ.X S‚ÇÇ.X\nf : (n : Nat) ‚Üí Quiver.Hom (S‚ÇÅ.s.N n) (S‚ÇÇ.s.N n)\ncomm : autoParam (‚àÄ (n : Nat), Eq (CategoryTheory.CategoryStruct.comp (S‚ÇÅ.s.Œπ n) (F.app { unop := SimplexCategory.mk n })) (CategoryTheory.CategoryStruct.comp (f n) (S‚ÇÇ.s.Œπ n))) _auto‚úù\nx‚úù : Eq { F := F‚úù, f := f‚úù, comm := comm‚úù } { F := F, f := f, comm := comm }\n‚ä¢ And (Eq F‚úù F) (Eq f‚úù f)","decl":"/-- Morphisms in `SimplicialObject.Split C` are morphisms of simplicial objects that\nare compatible with the splittings. -/\nstructure Hom (S‚ÇÅ S‚ÇÇ : Split C) where\n  /-- the morphism between the underlying simplicial objects -/\n  F : S‚ÇÅ.X ‚ü∂ S‚ÇÇ.X\n  /-- the morphism between the \"nondegenerate\" `n`-simplices for all `n : ‚Ñï` -/\n  f : ‚àÄ n : ‚Ñï, S‚ÇÅ.s.N n ‚ü∂ S‚ÇÇ.s.N n\n  comm : ‚àÄ n : ‚Ñï, S‚ÇÅ.s.Œπ n ‚â´ F.app (op [n]) = f n ‚â´ S‚ÇÇ.s.Œπ n := by aesop_cat\n\n"}
{"name":"SimplicialObject.Split.Hom.ext","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nS‚ÇÅ S‚ÇÇ : SimplicialObject.Split C\nŒ¶‚ÇÅ Œ¶‚ÇÇ : S‚ÇÅ.Hom S‚ÇÇ\nh : ‚àÄ (n : Nat), Eq (Œ¶‚ÇÅ.f n) (Œ¶‚ÇÇ.f n)\n‚ä¢ Eq Œ¶‚ÇÅ Œ¶‚ÇÇ","decl":"@[ext]\ntheorem Hom.ext {S‚ÇÅ S‚ÇÇ : Split C} (Œ¶‚ÇÅ Œ¶‚ÇÇ : Hom S‚ÇÅ S‚ÇÇ) (h : ‚àÄ n : ‚Ñï, Œ¶‚ÇÅ.f n = Œ¶‚ÇÇ.f n) : Œ¶‚ÇÅ = Œ¶‚ÇÇ := by\n  rcases Œ¶‚ÇÅ with ‚ü®F‚ÇÅ, f‚ÇÅ, c‚ÇÅ‚ü©\n  rcases Œ¶‚ÇÇ with ‚ü®F‚ÇÇ, f‚ÇÇ, c‚ÇÇ‚ü©\n  have h' : f‚ÇÅ = f‚ÇÇ := by\n    ext\n    apply h\n  subst h'\n  simp only [mk.injEq, and_true]\n  apply S‚ÇÅ.s.hom_ext\n  intro n\n  dsimp\n  rw [c‚ÇÅ, c‚ÇÇ]\n\n"}
{"name":"SimplicialObject.Split.Hom.ext_iff","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nS‚ÇÅ S‚ÇÇ : SimplicialObject.Split C\nŒ¶‚ÇÅ Œ¶‚ÇÇ : S‚ÇÅ.Hom S‚ÇÇ\n‚ä¢ Iff (Eq Œ¶‚ÇÅ Œ¶‚ÇÇ) (‚àÄ (n : Nat), Eq (Œ¶‚ÇÅ.f n) (Œ¶‚ÇÇ.f n))","decl":"@[ext]\ntheorem Hom.ext {S‚ÇÅ S‚ÇÇ : Split C} (Œ¶‚ÇÅ Œ¶‚ÇÇ : Hom S‚ÇÅ S‚ÇÇ) (h : ‚àÄ n : ‚Ñï, Œ¶‚ÇÅ.f n = Œ¶‚ÇÇ.f n) : Œ¶‚ÇÅ = Œ¶‚ÇÇ := by\n  rcases Œ¶‚ÇÅ with ‚ü®F‚ÇÅ, f‚ÇÅ, c‚ÇÅ‚ü©\n  rcases Œ¶‚ÇÇ with ‚ü®F‚ÇÇ, f‚ÇÇ, c‚ÇÇ‚ü©\n  have h' : f‚ÇÅ = f‚ÇÇ := by\n    ext\n    apply h\n  subst h'\n  simp only [mk.injEq, and_true]\n  apply S‚ÇÅ.s.hom_ext\n  intro n\n  dsimp\n  rw [c‚ÇÅ, c‚ÇÇ]\n\n"}
{"name":"SimplicialObject.Split.Hom.comm_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nS‚ÇÅ S‚ÇÇ : SimplicialObject.Split C\nself : S‚ÇÅ.Hom S‚ÇÇ\nn : Nat\nZ : C\nh : Quiver.Hom (S‚ÇÇ.X.obj { unop := SimplexCategory.mk n }) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (S‚ÇÅ.s.Œπ n) (CategoryTheory.CategoryStruct.comp (self.F.app { unop := SimplexCategory.mk n }) h)) (CategoryTheory.CategoryStruct.comp (self.f n) (CategoryTheory.CategoryStruct.comp (S‚ÇÇ.s.Œπ n) h))","decl":"attribute [simp, reassoc] Hom.comm\n\n"}
{"name":"SimplicialObject.Split.hom_ext_iff","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nS‚ÇÅ S‚ÇÇ : SimplicialObject.Split C\nŒ¶‚ÇÅ Œ¶‚ÇÇ : Quiver.Hom S‚ÇÅ S‚ÇÇ\n‚ä¢ Iff (Eq Œ¶‚ÇÅ Œ¶‚ÇÇ) (‚àÄ (n : Nat), Eq (Œ¶‚ÇÅ.f n) (Œ¶‚ÇÇ.f n))","decl":"@[ext]\ntheorem hom_ext {S‚ÇÅ S‚ÇÇ : Split C} (Œ¶‚ÇÅ Œ¶‚ÇÇ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (h : ‚àÄ n : ‚Ñï, Œ¶‚ÇÅ.f n = Œ¶‚ÇÇ.f n) : Œ¶‚ÇÅ = Œ¶‚ÇÇ :=\n  Hom.ext _ _ h\n\n"}
{"name":"SimplicialObject.Split.hom_ext","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nS‚ÇÅ S‚ÇÇ : SimplicialObject.Split C\nŒ¶‚ÇÅ Œ¶‚ÇÇ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh : ‚àÄ (n : Nat), Eq (Œ¶‚ÇÅ.f n) (Œ¶‚ÇÇ.f n)\n‚ä¢ Eq Œ¶‚ÇÅ Œ¶‚ÇÇ","decl":"@[ext]\ntheorem hom_ext {S‚ÇÅ S‚ÇÇ : Split C} (Œ¶‚ÇÅ Œ¶‚ÇÇ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (h : ‚àÄ n : ‚Ñï, Œ¶‚ÇÅ.f n = Œ¶‚ÇÇ.f n) : Œ¶‚ÇÅ = Œ¶‚ÇÇ :=\n  Hom.ext _ _ h\n\n"}
{"name":"SimplicialObject.Split.congr_F","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nS‚ÇÅ S‚ÇÇ : SimplicialObject.Split C\nŒ¶‚ÇÅ Œ¶‚ÇÇ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh : Eq Œ¶‚ÇÅ Œ¶‚ÇÇ\n‚ä¢ Eq Œ¶‚ÇÅ.f Œ¶‚ÇÇ.f","decl":"theorem congr_F {S‚ÇÅ S‚ÇÇ : Split C} {Œ¶‚ÇÅ Œ¶‚ÇÇ : S‚ÇÅ ‚ü∂ S‚ÇÇ} (h : Œ¶‚ÇÅ = Œ¶‚ÇÇ) : Œ¶‚ÇÅ.f = Œ¶‚ÇÇ.f := by rw [h]\n\n"}
{"name":"SimplicialObject.Split.congr_f","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nS‚ÇÅ S‚ÇÇ : SimplicialObject.Split C\nŒ¶‚ÇÅ Œ¶‚ÇÇ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nh : Eq Œ¶‚ÇÅ Œ¶‚ÇÇ\nn : Nat\n‚ä¢ Eq (Œ¶‚ÇÅ.f n) (Œ¶‚ÇÇ.f n)","decl":"theorem congr_f {S‚ÇÅ S‚ÇÇ : Split C} {Œ¶‚ÇÅ Œ¶‚ÇÇ : S‚ÇÅ ‚ü∂ S‚ÇÇ} (h : Œ¶‚ÇÅ = Œ¶‚ÇÇ) (n : ‚Ñï) : Œ¶‚ÇÅ.f n = Œ¶‚ÇÇ.f n := by\n  rw [h]\n\n"}
{"name":"SimplicialObject.Split.id_F","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nS : SimplicialObject.Split C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id S).F (CategoryTheory.CategoryStruct.id S.X)","decl":"@[simp]\ntheorem id_F (S : Split C) : (ùüô S : S ‚ü∂ S).F = ùüô S.X :=\n  rfl\n\n"}
{"name":"SimplicialObject.Split.id_f","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nS : SimplicialObject.Split C\nn : Nat\n‚ä¢ Eq ((CategoryTheory.CategoryStruct.id S).f n) (CategoryTheory.CategoryStruct.id (S.s.N n))","decl":"@[simp]\ntheorem id_f (S : Split C) (n : ‚Ñï) : (ùüô S : S ‚ü∂ S).f n = ùüô (S.s.N n) :=\n  rfl\n\n"}
{"name":"SimplicialObject.Split.comp_F","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nS‚ÇÅ S‚ÇÇ S‚ÇÉ : SimplicialObject.Split C\nŒ¶‚ÇÅ‚ÇÇ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nŒ¶‚ÇÇ‚ÇÉ : Quiver.Hom S‚ÇÇ S‚ÇÉ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Œ¶‚ÇÅ‚ÇÇ Œ¶‚ÇÇ‚ÇÉ).F (CategoryTheory.CategoryStruct.comp Œ¶‚ÇÅ‚ÇÇ.F Œ¶‚ÇÇ‚ÇÉ.F)","decl":"@[simp]\ntheorem comp_F {S‚ÇÅ S‚ÇÇ S‚ÇÉ : Split C} (Œ¶‚ÇÅ‚ÇÇ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (Œ¶‚ÇÇ‚ÇÉ : S‚ÇÇ ‚ü∂ S‚ÇÉ) :\n    (Œ¶‚ÇÅ‚ÇÇ ‚â´ Œ¶‚ÇÇ‚ÇÉ).F = Œ¶‚ÇÅ‚ÇÇ.F ‚â´ Œ¶‚ÇÇ‚ÇÉ.F :=\n  rfl\n\n"}
{"name":"SimplicialObject.Split.comp_f","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nS‚ÇÅ S‚ÇÇ S‚ÇÉ : SimplicialObject.Split C\nŒ¶‚ÇÅ‚ÇÇ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nŒ¶‚ÇÇ‚ÇÉ : Quiver.Hom S‚ÇÇ S‚ÇÉ\nn : Nat\n‚ä¢ Eq ((CategoryTheory.CategoryStruct.comp Œ¶‚ÇÅ‚ÇÇ Œ¶‚ÇÇ‚ÇÉ).f n) (CategoryTheory.CategoryStruct.comp (Œ¶‚ÇÅ‚ÇÇ.f n) (Œ¶‚ÇÇ‚ÇÉ.f n))","decl":"@[simp]\ntheorem comp_f {S‚ÇÅ S‚ÇÇ S‚ÇÉ : Split C} (Œ¶‚ÇÅ‚ÇÇ : S‚ÇÅ ‚ü∂ S‚ÇÇ) (Œ¶‚ÇÇ‚ÇÉ : S‚ÇÇ ‚ü∂ S‚ÇÉ) (n : ‚Ñï) :\n    (Œ¶‚ÇÅ‚ÇÇ ‚â´ Œ¶‚ÇÇ‚ÇÉ).f n = Œ¶‚ÇÅ‚ÇÇ.f n ‚â´ Œ¶‚ÇÇ‚ÇÉ.f n :=\n  rfl\n\n-- This is not a `@[simp]` lemma as it can later be proved by `simp`.\n"}
{"name":"SimplicialObject.Split.cofan_inj_naturality_symm","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nS‚ÇÅ S‚ÇÇ : SimplicialObject.Split C\nŒ¶ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nŒî : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Œî\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((S‚ÇÅ.s.cofan Œî).inj A) (Œ¶.F.app Œî)) (CategoryTheory.CategoryStruct.comp (Œ¶.f (Opposite.unop A.fst).len) ((S‚ÇÇ.s.cofan Œî).inj A))","decl":"@[reassoc]\ntheorem cofan_inj_naturality_symm {S‚ÇÅ S‚ÇÇ : Split C} (Œ¶ : S‚ÇÅ ‚ü∂ S‚ÇÇ) {Œî : SimplexCategory·µí·µñ}\n    (A : Splitting.IndexSet Œî) :\n    (S‚ÇÅ.s.cofan Œî).inj A ‚â´ Œ¶.F.app Œî = Œ¶.f A.1.unop.len ‚â´ (S‚ÇÇ.s.cofan Œî).inj A := by\n  rw [S‚ÇÅ.s.cofan_inj_eq, S‚ÇÇ.s.cofan_inj_eq, assoc, Œ¶.F.naturality, ‚Üê Œ¶.comm_assoc]\n\n"}
{"name":"SimplicialObject.Split.cofan_inj_naturality_symm_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nS‚ÇÅ S‚ÇÇ : SimplicialObject.Split C\nŒ¶ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nŒî : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Œî\nZ : C\nh : Quiver.Hom (S‚ÇÇ.X.obj Œî) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((S‚ÇÅ.s.cofan Œî).inj A) (CategoryTheory.CategoryStruct.comp (Œ¶.F.app Œî) h)) (CategoryTheory.CategoryStruct.comp (Œ¶.f (Opposite.unop A.fst).len) (CategoryTheory.CategoryStruct.comp ((S‚ÇÇ.s.cofan Œî).inj A) h))","decl":"@[reassoc]\ntheorem cofan_inj_naturality_symm {S‚ÇÅ S‚ÇÇ : Split C} (Œ¶ : S‚ÇÅ ‚ü∂ S‚ÇÇ) {Œî : SimplexCategory·µí·µñ}\n    (A : Splitting.IndexSet Œî) :\n    (S‚ÇÅ.s.cofan Œî).inj A ‚â´ Œ¶.F.app Œî = Œ¶.f A.1.unop.len ‚â´ (S‚ÇÇ.s.cofan Œî).inj A := by\n  rw [S‚ÇÅ.s.cofan_inj_eq, S‚ÇÇ.s.cofan_inj_eq, assoc, Œ¶.F.naturality, ‚Üê Œ¶.comm_assoc]\n\n"}
{"name":"SimplicialObject.Split.forget_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nS : SimplicialObject.Split C\n‚ä¢ Eq ((SimplicialObject.Split.forget C).obj S) S.X","decl":"/-- The functor `SimplicialObject.Split C ‚•§ SimplicialObject C` which forgets\nthe splitting. -/\n@[simps]\ndef forget : Split C ‚•§ SimplicialObject C where\n  obj S := S.X\n  map Œ¶ := Œ¶.F\n\n"}
{"name":"SimplicialObject.Split.forget_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX‚úù Y‚úù : SimplicialObject.Split C\nŒ¶ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((SimplicialObject.Split.forget C).map Œ¶) Œ¶.F","decl":"/-- The functor `SimplicialObject.Split C ‚•§ SimplicialObject C` which forgets\nthe splitting. -/\n@[simps]\ndef forget : Split C ‚•§ SimplicialObject C where\n  obj S := S.X\n  map Œ¶ := Œ¶.F\n\n"}
{"name":"SimplicialObject.Split.evalN_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nS : SimplicialObject.Split C\n‚ä¢ Eq ((SimplicialObject.Split.evalN C n).obj S) (S.s.N n)","decl":"/-- The functor `SimplicialObject.Split C ‚•§ C` which sends a simplicial object equipped\nwith a splitting to its nondegenerate `n`-simplices. -/\n@[simps]\ndef evalN (n : ‚Ñï) : Split C ‚•§ C where\n  obj S := S.s.N n\n  map Œ¶ := Œ¶.f n\n\n"}
{"name":"SimplicialObject.Split.evalN_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nX‚úù Y‚úù : SimplicialObject.Split C\nŒ¶ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((SimplicialObject.Split.evalN C n).map Œ¶) (Œ¶.f n)","decl":"/-- The functor `SimplicialObject.Split C ‚•§ C` which sends a simplicial object equipped\nwith a splitting to its nondegenerate `n`-simplices. -/\n@[simps]\ndef evalN (n : ‚Ñï) : Split C ‚•§ C where\n  obj S := S.s.N n\n  map Œ¶ := Œ¶.f n\n\n"}
{"name":"SimplicialObject.Split.natTransCofanInj_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nŒî : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Œî\nS : SimplicialObject.Split C\n‚ä¢ Eq ((SimplicialObject.Split.natTransCofanInj C A).app S) ((S.s.cofan Œî).inj A)","decl":"/-- The inclusion of each summand in the coproduct decomposition of simplices\nin split simplicial objects is a natural transformation of functors\n`SimplicialObject.Split C ‚•§ C` -/\n@[simps]\ndef natTransCofanInj {Œî : SimplexCategory·µí·µñ} (A : Splitting.IndexSet Œî) :\n    evalN C A.1.unop.len ‚ü∂ forget C ‚ãô (evaluation SimplexCategory·µí·µñ C).obj Œî where\n  app S := (S.s.cofan Œî).inj A\n  naturality _ _ Œ¶ := (cofan_inj_naturality_symm Œ¶ A).symm\n\n"}
