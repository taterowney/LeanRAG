{"name":"SimplicialObject.Splitting.IndexSet.mk_snd_coe","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"Δ Δ' : SimplexCategory\nf : Quiver.Hom Δ Δ'\ninst✝ : CategoryTheory.Epi f\n⊢ Eq (↑(SimplicialObject.Splitting.IndexSet.mk f).snd) f","decl":"/-- The element in `Splitting.IndexSet Δ` attached to an epimorphism `f : Δ ⟶ Δ'`. -/\n@[simps]\ndef mk {Δ Δ' : SimplexCategory} (f : Δ ⟶ Δ') [Epi f] : IndexSet (op Δ) :=\n  ⟨op Δ', f, inferInstance⟩\n\n"}
{"name":"SimplicialObject.Splitting.IndexSet.mk_fst","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"Δ Δ' : SimplexCategory\nf : Quiver.Hom Δ Δ'\ninst✝ : CategoryTheory.Epi f\n⊢ Eq (SimplicialObject.Splitting.IndexSet.mk f).fst { unop := Δ' }","decl":"/-- The element in `Splitting.IndexSet Δ` attached to an epimorphism `f : Δ ⟶ Δ'`. -/\n@[simps]\ndef mk {Δ Δ' : SimplexCategory} (f : Δ ⟶ Δ') [Epi f] : IndexSet (op Δ) :=\n  ⟨op Δ', f, inferInstance⟩\n\n"}
{"name":"SimplicialObject.Splitting.IndexSet.instEpiSimplexCategoryE","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"Δ : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Δ\n⊢ CategoryTheory.Epi A.e","decl":"instance : Epi A.e :=\n  A.2.2\n\n"}
{"name":"SimplicialObject.Splitting.IndexSet.ext'","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"Δ : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Δ\n⊢ Eq A ⟨A.fst, ⟨A.e, ⋯⟩⟩","decl":"theorem ext' : A = ⟨A.1, ⟨A.e, A.2.2⟩⟩ := rfl\n\n"}
{"name":"SimplicialObject.Splitting.IndexSet.ext","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"Δ : Opposite SimplexCategory\nA₁ A₂ : SimplicialObject.Splitting.IndexSet Δ\nh₁ : Eq A₁.fst A₂.fst\nh₂ : Eq (CategoryTheory.CategoryStruct.comp A₁.e (CategoryTheory.eqToHom ⋯)) A₂.e\n⊢ Eq A₁ A₂","decl":"theorem ext (A₁ A₂ : IndexSet Δ) (h₁ : A₁.1 = A₂.1) (h₂ : A₁.e ≫ eqToHom (by rw [h₁]) = A₂.e) :\n    A₁ = A₂ := by\n  rcases A₁ with ⟨Δ₁, ⟨α₁, hα₁⟩⟩\n  rcases A₂ with ⟨Δ₂, ⟨α₂, hα₂⟩⟩\n  simp only at h₁\n  subst h₁\n  simp only [eqToHom_refl, comp_id, IndexSet.e] at h₂\n  simp only [h₂]\n\n"}
{"name":"SimplicialObject.Splitting.IndexSet.id_fst","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"Δ : Opposite SimplexCategory\n⊢ Eq (SimplicialObject.Splitting.IndexSet.id Δ).fst Δ","decl":"/-- The distinguished element in `Splitting.IndexSet Δ` which corresponds to the\nidentity of `Δ`. -/\n@[simps]\ndef id : IndexSet Δ :=\n  ⟨Δ, ⟨𝟙 _, by infer_instance⟩⟩\n\n"}
{"name":"SimplicialObject.Splitting.IndexSet.id_snd_coe","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"Δ : Opposite SimplexCategory\n⊢ Eq (↑(SimplicialObject.Splitting.IndexSet.id Δ).snd) (CategoryTheory.CategoryStruct.id (Opposite.unop Δ))","decl":"/-- The distinguished element in `Splitting.IndexSet Δ` which corresponds to the\nidentity of `Δ`. -/\n@[simps]\ndef id : IndexSet Δ :=\n  ⟨Δ, ⟨𝟙 _, by infer_instance⟩⟩\n\n"}
{"name":"SimplicialObject.Splitting.IndexSet.eqId_iff_eq","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"Δ : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Δ\n⊢ Iff A.EqId (Eq A.fst Δ)","decl":"theorem eqId_iff_eq : A.EqId ↔ A.1 = Δ := by\n  constructor\n  · intro h\n    dsimp at h\n    rw [h]\n    rfl\n  · intro h\n    rcases A with ⟨_, ⟨f, hf⟩⟩\n    simp only at h\n    subst h\n    refine ext _ _ rfl ?_\n    haveI := hf\n    simp only [eqToHom_refl, comp_id]\n    exact eq_id_of_epi f\n\n"}
{"name":"SimplicialObject.Splitting.IndexSet.eqId_iff_len_eq","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"Δ : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Δ\n⊢ Iff A.EqId (Eq (Opposite.unop A.fst).len (Opposite.unop Δ).len)","decl":"theorem eqId_iff_len_eq : A.EqId ↔ A.1.unop.len = Δ.unop.len := by\n  rw [eqId_iff_eq]\n  constructor\n  · intro h\n    rw [h]\n  · intro h\n    rw [← unop_inj_iff]\n    ext\n    exact h\n\n"}
{"name":"SimplicialObject.Splitting.IndexSet.eqId_iff_len_le","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"Δ : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Δ\n⊢ Iff A.EqId (LE.le (Opposite.unop Δ).len (Opposite.unop A.fst).len)","decl":"theorem eqId_iff_len_le : A.EqId ↔ Δ.unop.len ≤ A.1.unop.len := by\n  rw [eqId_iff_len_eq]\n  constructor\n  · intro h\n    rw [h]\n  · exact le_antisymm (len_le_of_epi (inferInstance : Epi A.e))\n\n"}
{"name":"SimplicialObject.Splitting.IndexSet.eqId_iff_mono","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"Δ : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Δ\n⊢ Iff A.EqId (CategoryTheory.Mono A.e)","decl":"theorem eqId_iff_mono : A.EqId ↔ Mono A.e := by\n  constructor\n  · intro h\n    dsimp at h\n    subst h\n    dsimp only [id, e]\n    infer_instance\n  · intro h\n    rw [eqId_iff_len_le]\n    exact len_le_of_mono h\n\n"}
{"name":"SimplicialObject.Splitting.IndexSet.epiComp_snd_coe","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"Δ₁ Δ₂ : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Δ₁\np : Quiver.Hom Δ₁ Δ₂\ninst✝ : CategoryTheory.Epi p.unop\n⊢ Eq (↑(A.epiComp p).snd) (CategoryTheory.CategoryStruct.comp p.unop A.e)","decl":"/-- Given `A : IndexSet Δ₁`, if `p.unop : unop Δ₂ ⟶ unop Δ₁` is an epi, this\nis the obvious element in `A : IndexSet Δ₂` associated to the composition\nof epimorphisms `p.unop ≫ A.e`. -/\n@[simps]\ndef epiComp {Δ₁ Δ₂ : SimplexCategoryᵒᵖ} (A : IndexSet Δ₁) (p : Δ₁ ⟶ Δ₂) [Epi p.unop] :\n    IndexSet Δ₂ :=\n  ⟨A.1, ⟨p.unop ≫ A.e, epi_comp _ _⟩⟩\n\n\n"}
{"name":"SimplicialObject.Splitting.IndexSet.epiComp_fst","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"Δ₁ Δ₂ : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Δ₁\np : Quiver.Hom Δ₁ Δ₂\ninst✝ : CategoryTheory.Epi p.unop\n⊢ Eq (A.epiComp p).fst A.fst","decl":"/-- Given `A : IndexSet Δ₁`, if `p.unop : unop Δ₂ ⟶ unop Δ₁` is an epi, this\nis the obvious element in `A : IndexSet Δ₂` associated to the composition\nof epimorphisms `p.unop ≫ A.e`. -/\n@[simps]\ndef epiComp {Δ₁ Δ₂ : SimplexCategoryᵒᵖ} (A : IndexSet Δ₁) (p : Δ₁ ⟶ Δ₂) [Epi p.unop] :\n    IndexSet Δ₂ :=\n  ⟨A.1, ⟨p.unop ≫ A.e, epi_comp _ _⟩⟩\n\n\n"}
{"name":"SimplicialObject.Splitting.IndexSet.fac_pull_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"Δ : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Δ\nΔ' : Opposite SimplexCategory\nθ : Quiver.Hom Δ Δ'\nZ : SimplexCategory\nh : Quiver.Hom (Opposite.unop A.fst) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (A.pull θ).e (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.ι (CategoryTheory.CategoryStruct.comp θ.unop A.e)) h)) (CategoryTheory.CategoryStruct.comp θ.unop (CategoryTheory.CategoryStruct.comp A.e h))","decl":"@[reassoc]\ntheorem fac_pull : (A.pull θ).e ≫ image.ι (θ.unop ≫ A.e) = θ.unop ≫ A.e :=\n  image.fac _\n\n"}
{"name":"SimplicialObject.Splitting.IndexSet.fac_pull","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"Δ : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Δ\nΔ' : Opposite SimplexCategory\nθ : Quiver.Hom Δ Δ'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (A.pull θ).e (CategoryTheory.Limits.image.ι (CategoryTheory.CategoryStruct.comp θ.unop A.e))) (CategoryTheory.CategoryStruct.comp θ.unop A.e)","decl":"@[reassoc]\ntheorem fac_pull : (A.pull θ).e ≫ image.ι (θ.unop ≫ A.e) = θ.unop ≫ A.e :=\n  image.fac _\n\n"}
{"name":"SimplicialObject.Splitting.mk.sizeOf_spec","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ninst✝ : SizeOf C\nN : Nat → C\nι : (n : Nat) → Quiver.Hom (N n) (X.obj { unop := SimplexCategory.mk n })\nisColimit' : (Δ : Opposite SimplexCategory) → CategoryTheory.Limits.IsColimit (SimplicialObject.Splitting.cofan' N X ι Δ)\n⊢ Eq (SizeOf.sizeOf { N := N, ι := ι, isColimit' := isColimit' }) 1","decl":"/-- A splitting of a simplicial object `X` consists of the datum of a sequence\nof objects `N`, a sequence of morphisms `ι : N n ⟶ X _[n]` such that\nfor all `Δ : SimplexCategoryᵒᵖ`, the canonical map `Splitting.map X ι Δ`\nis an isomorphism. -/\nstructure Splitting (X : SimplicialObject C) where\n  /-- The \"nondegenerate simplices\" `N n` for all `n : ℕ`. -/\n  N : ℕ → C\n  /-- The \"inclusion\" `N n ⟶ X _[n]` for all `n : ℕ`. -/\n  ι : ∀ n, N n ⟶ X _[n]\n  /-- For each `Δ`, `X.obj Δ` identifies to the coproduct of the objects `N A.1.unop.len`\n  for all `A : IndexSet Δ`. -/\n  isColimit' : ∀ Δ : SimplexCategoryᵒᵖ, IsColimit (Splitting.cofan' N X ι Δ)\n\n"}
{"name":"SimplicialObject.Splitting.mk.injEq","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\nN✝ : Nat → C\nι✝ : (n : Nat) → Quiver.Hom (N✝ n) (X.obj { unop := SimplexCategory.mk n })\nisColimit'✝ : (Δ : Opposite SimplexCategory) → CategoryTheory.Limits.IsColimit (SimplicialObject.Splitting.cofan' N✝ X ι✝ Δ)\nN : Nat → C\nι : (n : Nat) → Quiver.Hom (N n) (X.obj { unop := SimplexCategory.mk n })\nisColimit' : (Δ : Opposite SimplexCategory) → CategoryTheory.Limits.IsColimit (SimplicialObject.Splitting.cofan' N X ι Δ)\n⊢ Eq (Eq { N := N✝, ι := ι✝, isColimit' := isColimit'✝ } { N := N, ι := ι, isColimit' := isColimit' }) (And (Eq N✝ N) (And (HEq ι✝ ι) (HEq isColimit'✝ isColimit')))","decl":"/-- A splitting of a simplicial object `X` consists of the datum of a sequence\nof objects `N`, a sequence of morphisms `ι : N n ⟶ X _[n]` such that\nfor all `Δ : SimplexCategoryᵒᵖ`, the canonical map `Splitting.map X ι Δ`\nis an isomorphism. -/\nstructure Splitting (X : SimplicialObject C) where\n  /-- The \"nondegenerate simplices\" `N n` for all `n : ℕ`. -/\n  N : ℕ → C\n  /-- The \"inclusion\" `N n ⟶ X _[n]` for all `n : ℕ`. -/\n  ι : ∀ n, N n ⟶ X _[n]\n  /-- For each `Δ`, `X.obj Δ` identifies to the coproduct of the objects `N A.1.unop.len`\n  for all `A : IndexSet Δ`. -/\n  isColimit' : ∀ Δ : SimplexCategoryᵒᵖ, IsColimit (Splitting.cofan' N X ι Δ)\n\n"}
{"name":"SimplicialObject.Splitting.mk.inj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\nN✝ : Nat → C\nι✝ : (n : Nat) → Quiver.Hom (N✝ n) (X.obj { unop := SimplexCategory.mk n })\nisColimit'✝ : (Δ : Opposite SimplexCategory) → CategoryTheory.Limits.IsColimit (SimplicialObject.Splitting.cofan' N✝ X ι✝ Δ)\nN : Nat → C\nι : (n : Nat) → Quiver.Hom (N n) (X.obj { unop := SimplexCategory.mk n })\nisColimit' : (Δ : Opposite SimplexCategory) → CategoryTheory.Limits.IsColimit (SimplicialObject.Splitting.cofan' N X ι Δ)\nx✝ : Eq { N := N✝, ι := ι✝, isColimit' := isColimit'✝ } { N := N, ι := ι, isColimit' := isColimit' }\n⊢ And (Eq N✝ N) (And (HEq ι✝ ι) (HEq isColimit'✝ isColimit'))","decl":"/-- A splitting of a simplicial object `X` consists of the datum of a sequence\nof objects `N`, a sequence of morphisms `ι : N n ⟶ X _[n]` such that\nfor all `Δ : SimplexCategoryᵒᵖ`, the canonical map `Splitting.map X ι Δ`\nis an isomorphism. -/\nstructure Splitting (X : SimplicialObject C) where\n  /-- The \"nondegenerate simplices\" `N n` for all `n : ℕ`. -/\n  N : ℕ → C\n  /-- The \"inclusion\" `N n ⟶ X _[n]` for all `n : ℕ`. -/\n  ι : ∀ n, N n ⟶ X _[n]\n  /-- For each `Δ`, `X.obj Δ` identifies to the coproduct of the objects `N A.1.unop.len`\n  for all `A : IndexSet Δ`. -/\n  isColimit' : ∀ Δ : SimplexCategoryᵒᵖ, IsColimit (Splitting.cofan' N X ι Δ)\n\n"}
{"name":"SimplicialObject.Splitting.cofan_inj_eq","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\nΔ : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Δ\n⊢ Eq ((s.cofan Δ).inj A) (CategoryTheory.CategoryStruct.comp (s.ι (Opposite.unop A.fst).len) (X.map A.e.op))","decl":"@[reassoc]\ntheorem cofan_inj_eq {Δ : SimplexCategoryᵒᵖ} (A : IndexSet Δ) :\n    (s.cofan Δ).inj  A = s.ι A.1.unop.len ≫ X.map A.e.op := rfl\n\n"}
{"name":"SimplicialObject.Splitting.cofan_inj_eq_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\nΔ : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Δ\nZ : C\nh : Quiver.Hom (s.cofan Δ).pt Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((s.cofan Δ).inj A) h) (CategoryTheory.CategoryStruct.comp (s.ι (Opposite.unop A.fst).len) (CategoryTheory.CategoryStruct.comp (X.map A.e.op) h))","decl":"@[reassoc]\ntheorem cofan_inj_eq {Δ : SimplexCategoryᵒᵖ} (A : IndexSet Δ) :\n    (s.cofan Δ).inj  A = s.ι A.1.unop.len ≫ X.map A.e.op := rfl\n\n"}
{"name":"SimplicialObject.Splitting.cofan_inj_id","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\nn : Nat\n⊢ Eq ((s.cofan { unop := SimplexCategory.mk n }).inj (SimplicialObject.Splitting.IndexSet.id { unop := SimplexCategory.mk n })) (s.ι n)","decl":"theorem cofan_inj_id (n : ℕ) : (s.cofan _).inj (IndexSet.id (op [n])) = s.ι n := by\n  erw [cofan_inj_eq, X.map_id, comp_id]\n  rfl\n\n"}
{"name":"SimplicialObject.Splitting.cofan_inj_comp_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX Y : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\nf : Quiver.Hom X Y\nΔ : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Δ\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((s.cofan Δ).inj A) (f.app Δ)) (CategoryTheory.CategoryStruct.comp (s.φ f (Opposite.unop A.fst).len) (Y.map A.e.op))","decl":"@[reassoc (attr := simp)]\ntheorem cofan_inj_comp_app (f : X ⟶ Y) {Δ : SimplexCategoryᵒᵖ} (A : IndexSet Δ) :\n    (s.cofan Δ).inj A ≫ f.app Δ = s.φ f A.1.unop.len ≫ Y.map A.e.op := by\n  simp only [cofan_inj_eq_assoc, φ, assoc]\n  rw [NatTrans.naturality]\n\n"}
{"name":"SimplicialObject.Splitting.cofan_inj_comp_app_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX Y : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\nf : Quiver.Hom X Y\nΔ : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Δ\nZ : C\nh : Quiver.Hom (Y.obj Δ) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((s.cofan Δ).inj A) (CategoryTheory.CategoryStruct.comp (f.app Δ) h)) (CategoryTheory.CategoryStruct.comp (s.φ f (Opposite.unop A.fst).len) (CategoryTheory.CategoryStruct.comp (Y.map A.e.op) h))","decl":"@[reassoc (attr := simp)]\ntheorem cofan_inj_comp_app (f : X ⟶ Y) {Δ : SimplexCategoryᵒᵖ} (A : IndexSet Δ) :\n    (s.cofan Δ).inj A ≫ f.app Δ = s.φ f A.1.unop.len ≫ Y.map A.e.op := by\n  simp only [cofan_inj_eq_assoc, φ, assoc]\n  rw [NatTrans.naturality]\n\n"}
{"name":"SimplicialObject.Splitting.hom_ext'","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\nZ : C\nΔ : Opposite SimplexCategory\nf g : Quiver.Hom (X.obj Δ) Z\nh : ∀ (A : SimplicialObject.Splitting.IndexSet Δ), Eq (CategoryTheory.CategoryStruct.comp ((s.cofan Δ).inj A) f) (CategoryTheory.CategoryStruct.comp ((s.cofan Δ).inj A) g)\n⊢ Eq f g","decl":"theorem hom_ext' {Z : C} {Δ : SimplexCategoryᵒᵖ} (f g : X.obj Δ ⟶ Z)\n    (h : ∀ A : IndexSet Δ, (s.cofan Δ).inj A ≫ f = (s.cofan Δ).inj A ≫ g) : f = g :=\n  Cofan.IsColimit.hom_ext (s.isColimit Δ) _ _ h\n\n"}
{"name":"SimplicialObject.Splitting.hom_ext","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX Y : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\nf g : Quiver.Hom X Y\nh : ∀ (n : Nat), Eq (s.φ f n) (s.φ g n)\n⊢ Eq f g","decl":"theorem hom_ext (f g : X ⟶ Y) (h : ∀ n : ℕ, s.φ f n = s.φ g n) : f = g := by\n  ext Δ\n  apply s.hom_ext'\n  intro A\n  induction' Δ using Opposite.rec with Δ\n  induction' Δ using SimplexCategory.rec with n\n  dsimp\n  simp only [s.cofan_inj_comp_app, h]\n\n"}
{"name":"SimplicialObject.Splitting.ι_desc_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\nZ✝ : C\nΔ : Opposite SimplexCategory\nF : (A : SimplicialObject.Splitting.IndexSet Δ) → Quiver.Hom (s.N (Opposite.unop A.fst).len) Z✝\nA : SimplicialObject.Splitting.IndexSet Δ\nZ : C\nh : Quiver.Hom Z✝ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((s.cofan Δ).inj A) (CategoryTheory.CategoryStruct.comp (s.desc Δ F) h)) (CategoryTheory.CategoryStruct.comp (F A) h)","decl":"@[reassoc (attr := simp)]\ntheorem ι_desc {Z : C} (Δ : SimplexCategoryᵒᵖ) (F : ∀ A : IndexSet Δ, s.N A.1.unop.len ⟶ Z)\n    (A : IndexSet Δ) : (s.cofan Δ).inj A ≫ s.desc Δ F = F A := by\n  apply Cofan.IsColimit.fac\n\n"}
{"name":"SimplicialObject.Splitting.ι_desc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\nZ : C\nΔ : Opposite SimplexCategory\nF : (A : SimplicialObject.Splitting.IndexSet Δ) → Quiver.Hom (s.N (Opposite.unop A.fst).len) Z\nA : SimplicialObject.Splitting.IndexSet Δ\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((s.cofan Δ).inj A) (s.desc Δ F)) (F A)","decl":"@[reassoc (attr := simp)]\ntheorem ι_desc {Z : C} (Δ : SimplexCategoryᵒᵖ) (F : ∀ A : IndexSet Δ, s.N A.1.unop.len ⟶ Z)\n    (A : IndexSet Δ) : (s.cofan Δ).inj A ≫ s.desc Δ F = F A := by\n  apply Cofan.IsColimit.fac\n\n"}
{"name":"SimplicialObject.Splitting.ofIso_isColimit'","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX Y : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\ne : CategoryTheory.Iso X Y\nΔ : Opposite SimplexCategory\n⊢ Eq ((s.ofIso e).isColimit' Δ) ((s.isColimit Δ).ofIsoColimit (CategoryTheory.Limits.Cofan.ext (e.app Δ) ⋯))","decl":"/-- A simplicial object that is isomorphic to a split simplicial object is split. -/\n@[simps]\ndef ofIso (e : X ≅ Y) : Splitting Y where\n  N := s.N\n  ι n := s.ι n ≫ e.hom.app (op [n])\n  isColimit' Δ := IsColimit.ofIsoColimit (s.isColimit Δ ) (Cofan.ext (e.app Δ)\n    (fun A => by simp [cofan, cofan']))\n\n"}
{"name":"SimplicialObject.Splitting.ofIso_ι","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX Y : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\ne : CategoryTheory.Iso X Y\nn : Nat\n⊢ Eq ((s.ofIso e).ι n) (CategoryTheory.CategoryStruct.comp (s.ι n) (e.hom.app { unop := SimplexCategory.mk n }))","decl":"/-- A simplicial object that is isomorphic to a split simplicial object is split. -/\n@[simps]\ndef ofIso (e : X ≅ Y) : Splitting Y where\n  N := s.N\n  ι n := s.ι n ≫ e.hom.app (op [n])\n  isColimit' Δ := IsColimit.ofIsoColimit (s.isColimit Δ ) (Cofan.ext (e.app Δ)\n    (fun A => by simp [cofan, cofan']))\n\n"}
{"name":"SimplicialObject.Splitting.ofIso_N","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX Y : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\ne : CategoryTheory.Iso X Y\na✝ : Nat\n⊢ Eq ((s.ofIso e).N a✝) (s.N a✝)","decl":"/-- A simplicial object that is isomorphic to a split simplicial object is split. -/\n@[simps]\ndef ofIso (e : X ≅ Y) : Splitting Y where\n  N := s.N\n  ι n := s.ι n ≫ e.hom.app (op [n])\n  isColimit' Δ := IsColimit.ofIsoColimit (s.isColimit Δ ) (Cofan.ext (e.app Δ)\n    (fun A => by simp [cofan, cofan']))\n\n"}
{"name":"SimplicialObject.Splitting.cofan_inj_epi_naturality","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\nΔ₁ Δ₂ : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Δ₁\np : Quiver.Hom Δ₁ Δ₂\ninst✝ : CategoryTheory.Epi p.unop\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((s.cofan Δ₁).inj A) (X.map p)) ((s.cofan Δ₂).inj (A.epiComp p))","decl":"@[reassoc]\ntheorem cofan_inj_epi_naturality {Δ₁ Δ₂ : SimplexCategoryᵒᵖ} (A : IndexSet Δ₁) (p : Δ₁ ⟶ Δ₂)\n    [Epi p.unop] : (s.cofan Δ₁).inj A ≫ X.map p = (s.cofan Δ₂).inj (A.epiComp p) := by\n  dsimp [cofan]\n  rw [assoc, ← X.map_comp]\n  rfl\n\n"}
{"name":"SimplicialObject.Splitting.cofan_inj_epi_naturality_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\nΔ₁ Δ₂ : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Δ₁\np : Quiver.Hom Δ₁ Δ₂\ninst✝ : CategoryTheory.Epi p.unop\nZ : C\nh : Quiver.Hom (X.obj Δ₂) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((s.cofan Δ₁).inj A) (CategoryTheory.CategoryStruct.comp (X.map p) h)) (CategoryTheory.CategoryStruct.comp ((s.cofan Δ₂).inj (A.epiComp p)) h)","decl":"@[reassoc]\ntheorem cofan_inj_epi_naturality {Δ₁ Δ₂ : SimplexCategoryᵒᵖ} (A : IndexSet Δ₁) (p : Δ₁ ⟶ Δ₂)\n    [Epi p.unop] : (s.cofan Δ₁).inj A ≫ X.map p = (s.cofan Δ₂).inj (A.epiComp p) := by\n  dsimp [cofan]\n  rw [assoc, ← X.map_comp]\n  rfl\n\n"}
{"name":"SimplicialObject.Split.mk.injEq","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX✝ : CategoryTheory.SimplicialObject C\ns✝ : SimplicialObject.Splitting X✝\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\n⊢ Eq (Eq { X := X✝, s := s✝ } { X := X, s := s }) (And (Eq X✝ X) (HEq s✝ s))","decl":"/-- The category `SimplicialObject.Split C` is the category of simplicial objects\nin `C` equipped with a splitting, and morphisms are morphisms of simplicial objects\nwhich are compatible with the splittings. -/\n@[ext]\nstructure Split where\n  /-- the underlying simplicial object -/\n  X : SimplicialObject C\n  /-- a splitting of the simplicial object -/\n  s : Splitting X\n\n"}
{"name":"SimplicialObject.Split.mk.inj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX✝ : CategoryTheory.SimplicialObject C\ns✝ : SimplicialObject.Splitting X✝\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\nx✝ : Eq { X := X✝, s := s✝ } { X := X, s := s }\n⊢ And (Eq X✝ X) (HEq s✝ s)","decl":"/-- The category `SimplicialObject.Split C` is the category of simplicial objects\nin `C` equipped with a splitting, and morphisms are morphisms of simplicial objects\nwhich are compatible with the splittings. -/\n@[ext]\nstructure Split where\n  /-- the underlying simplicial object -/\n  X : SimplicialObject C\n  /-- a splitting of the simplicial object -/\n  s : Splitting X\n\n"}
{"name":"SimplicialObject.Split.ext","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nx y : SimplicialObject.Split C\nX : Eq x.X y.X\ns : HEq x.s y.s\n⊢ Eq x y","decl":"/-- The category `SimplicialObject.Split C` is the category of simplicial objects\nin `C` equipped with a splitting, and morphisms are morphisms of simplicial objects\nwhich are compatible with the splittings. -/\n@[ext]\nstructure Split where\n  /-- the underlying simplicial object -/\n  X : SimplicialObject C\n  /-- a splitting of the simplicial object -/\n  s : Splitting X\n\n"}
{"name":"SimplicialObject.Split.mk.sizeOf_spec","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : SizeOf C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\n⊢ Eq (SizeOf.sizeOf { X := X, s := s }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf X)) (SizeOf.sizeOf s))","decl":"/-- The category `SimplicialObject.Split C` is the category of simplicial objects\nin `C` equipped with a splitting, and morphisms are morphisms of simplicial objects\nwhich are compatible with the splittings. -/\n@[ext]\nstructure Split where\n  /-- the underlying simplicial object -/\n  X : SimplicialObject C\n  /-- a splitting of the simplicial object -/\n  s : Splitting X\n\n"}
{"name":"SimplicialObject.Split.ext_iff","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nx y : SimplicialObject.Split C\n⊢ Iff (Eq x y) (And (Eq x.X y.X) (HEq x.s y.s))","decl":"/-- The category `SimplicialObject.Split C` is the category of simplicial objects\nin `C` equipped with a splitting, and morphisms are morphisms of simplicial objects\nwhich are compatible with the splittings. -/\n@[ext]\nstructure Split where\n  /-- the underlying simplicial object -/\n  X : SimplicialObject C\n  /-- a splitting of the simplicial object -/\n  s : Splitting X\n\n"}
{"name":"SimplicialObject.Split.mk'_s","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\n⊢ Eq (SimplicialObject.Split.mk' s).s s","decl":"/-- The object in `SimplicialObject.Split C` attached to a splitting `s : Splitting X`\nof a simplicial object `X`. -/\n@[simps]\ndef mk' {X : SimplicialObject C} (s : Splitting X) : Split C :=\n  ⟨X, s⟩\n\n"}
{"name":"SimplicialObject.Split.mk'_X","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\n⊢ Eq (SimplicialObject.Split.mk' s).X X","decl":"/-- The object in `SimplicialObject.Split C` attached to a splitting `s : Splitting X`\nof a simplicial object `X`. -/\n@[simps]\ndef mk' {X : SimplicialObject C} (s : Splitting X) : Split C :=\n  ⟨X, s⟩\n\n"}
{"name":"SimplicialObject.Split.Hom.mk.sizeOf_spec","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nS₁ S₂ : SimplicialObject.Split C\ninst✝ : SizeOf C\nF : Quiver.Hom S₁.X S₂.X\nf : (n : Nat) → Quiver.Hom (S₁.s.N n) (S₂.s.N n)\ncomm : autoParam (∀ (n : Nat), Eq (CategoryTheory.CategoryStruct.comp (S₁.s.ι n) (F.app { unop := SimplexCategory.mk n })) (CategoryTheory.CategoryStruct.comp (f n) (S₂.s.ι n))) _auto✝\n⊢ Eq (SizeOf.sizeOf { F := F, f := f, comm := comm }) (HAdd.hAdd 1 (SizeOf.sizeOf F))","decl":"/-- Morphisms in `SimplicialObject.Split C` are morphisms of simplicial objects that\nare compatible with the splittings. -/\nstructure Hom (S₁ S₂ : Split C) where\n  /-- the morphism between the underlying simplicial objects -/\n  F : S₁.X ⟶ S₂.X\n  /-- the morphism between the \"nondegenerate\" `n`-simplices for all `n : ℕ` -/\n  f : ∀ n : ℕ, S₁.s.N n ⟶ S₂.s.N n\n  comm : ∀ n : ℕ, S₁.s.ι n ≫ F.app (op [n]) = f n ≫ S₂.s.ι n := by aesop_cat\n\n"}
{"name":"SimplicialObject.Split.Hom.comm","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nS₁ S₂ : SimplicialObject.Split C\nself : S₁.Hom S₂\nn : Nat\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S₁.s.ι n) (self.F.app { unop := SimplexCategory.mk n })) (CategoryTheory.CategoryStruct.comp (self.f n) (S₂.s.ι n))","decl":"/-- Morphisms in `SimplicialObject.Split C` are morphisms of simplicial objects that\nare compatible with the splittings. -/\nstructure Hom (S₁ S₂ : Split C) where\n  /-- the morphism between the underlying simplicial objects -/\n  F : S₁.X ⟶ S₂.X\n  /-- the morphism between the \"nondegenerate\" `n`-simplices for all `n : ℕ` -/\n  f : ∀ n : ℕ, S₁.s.N n ⟶ S₂.s.N n\n  comm : ∀ n : ℕ, S₁.s.ι n ≫ F.app (op [n]) = f n ≫ S₂.s.ι n := by aesop_cat\n\n"}
{"name":"SimplicialObject.Split.Hom.mk.injEq","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nS₁ S₂ : SimplicialObject.Split C\nF✝ : Quiver.Hom S₁.X S₂.X\nf✝ : (n : Nat) → Quiver.Hom (S₁.s.N n) (S₂.s.N n)\ncomm✝ : autoParam (∀ (n : Nat), Eq (CategoryTheory.CategoryStruct.comp (S₁.s.ι n) (F✝.app { unop := SimplexCategory.mk n })) (CategoryTheory.CategoryStruct.comp (f✝ n) (S₂.s.ι n))) _auto✝\nF : Quiver.Hom S₁.X S₂.X\nf : (n : Nat) → Quiver.Hom (S₁.s.N n) (S₂.s.N n)\ncomm : autoParam (∀ (n : Nat), Eq (CategoryTheory.CategoryStruct.comp (S₁.s.ι n) (F.app { unop := SimplexCategory.mk n })) (CategoryTheory.CategoryStruct.comp (f n) (S₂.s.ι n))) _auto✝\n⊢ Eq (Eq { F := F✝, f := f✝, comm := comm✝ } { F := F, f := f, comm := comm }) (And (Eq F✝ F) (Eq f✝ f))","decl":"/-- Morphisms in `SimplicialObject.Split C` are morphisms of simplicial objects that\nare compatible with the splittings. -/\nstructure Hom (S₁ S₂ : Split C) where\n  /-- the morphism between the underlying simplicial objects -/\n  F : S₁.X ⟶ S₂.X\n  /-- the morphism between the \"nondegenerate\" `n`-simplices for all `n : ℕ` -/\n  f : ∀ n : ℕ, S₁.s.N n ⟶ S₂.s.N n\n  comm : ∀ n : ℕ, S₁.s.ι n ≫ F.app (op [n]) = f n ≫ S₂.s.ι n := by aesop_cat\n\n"}
{"name":"SimplicialObject.Split.Hom.mk.inj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nS₁ S₂ : SimplicialObject.Split C\nF✝ : Quiver.Hom S₁.X S₂.X\nf✝ : (n : Nat) → Quiver.Hom (S₁.s.N n) (S₂.s.N n)\ncomm✝ : autoParam (∀ (n : Nat), Eq (CategoryTheory.CategoryStruct.comp (S₁.s.ι n) (F✝.app { unop := SimplexCategory.mk n })) (CategoryTheory.CategoryStruct.comp (f✝ n) (S₂.s.ι n))) _auto✝\nF : Quiver.Hom S₁.X S₂.X\nf : (n : Nat) → Quiver.Hom (S₁.s.N n) (S₂.s.N n)\ncomm : autoParam (∀ (n : Nat), Eq (CategoryTheory.CategoryStruct.comp (S₁.s.ι n) (F.app { unop := SimplexCategory.mk n })) (CategoryTheory.CategoryStruct.comp (f n) (S₂.s.ι n))) _auto✝\nx✝ : Eq { F := F✝, f := f✝, comm := comm✝ } { F := F, f := f, comm := comm }\n⊢ And (Eq F✝ F) (Eq f✝ f)","decl":"/-- Morphisms in `SimplicialObject.Split C` are morphisms of simplicial objects that\nare compatible with the splittings. -/\nstructure Hom (S₁ S₂ : Split C) where\n  /-- the morphism between the underlying simplicial objects -/\n  F : S₁.X ⟶ S₂.X\n  /-- the morphism between the \"nondegenerate\" `n`-simplices for all `n : ℕ` -/\n  f : ∀ n : ℕ, S₁.s.N n ⟶ S₂.s.N n\n  comm : ∀ n : ℕ, S₁.s.ι n ≫ F.app (op [n]) = f n ≫ S₂.s.ι n := by aesop_cat\n\n"}
{"name":"SimplicialObject.Split.Hom.ext","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nS₁ S₂ : SimplicialObject.Split C\nΦ₁ Φ₂ : S₁.Hom S₂\nh : ∀ (n : Nat), Eq (Φ₁.f n) (Φ₂.f n)\n⊢ Eq Φ₁ Φ₂","decl":"@[ext]\ntheorem Hom.ext {S₁ S₂ : Split C} (Φ₁ Φ₂ : Hom S₁ S₂) (h : ∀ n : ℕ, Φ₁.f n = Φ₂.f n) : Φ₁ = Φ₂ := by\n  rcases Φ₁ with ⟨F₁, f₁, c₁⟩\n  rcases Φ₂ with ⟨F₂, f₂, c₂⟩\n  have h' : f₁ = f₂ := by\n    ext\n    apply h\n  subst h'\n  simp only [mk.injEq, and_true]\n  apply S₁.s.hom_ext\n  intro n\n  dsimp\n  rw [c₁, c₂]\n\n"}
{"name":"SimplicialObject.Split.Hom.ext_iff","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nS₁ S₂ : SimplicialObject.Split C\nΦ₁ Φ₂ : S₁.Hom S₂\n⊢ Iff (Eq Φ₁ Φ₂) (∀ (n : Nat), Eq (Φ₁.f n) (Φ₂.f n))","decl":"@[ext]\ntheorem Hom.ext {S₁ S₂ : Split C} (Φ₁ Φ₂ : Hom S₁ S₂) (h : ∀ n : ℕ, Φ₁.f n = Φ₂.f n) : Φ₁ = Φ₂ := by\n  rcases Φ₁ with ⟨F₁, f₁, c₁⟩\n  rcases Φ₂ with ⟨F₂, f₂, c₂⟩\n  have h' : f₁ = f₂ := by\n    ext\n    apply h\n  subst h'\n  simp only [mk.injEq, and_true]\n  apply S₁.s.hom_ext\n  intro n\n  dsimp\n  rw [c₁, c₂]\n\n"}
{"name":"SimplicialObject.Split.Hom.comm_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nS₁ S₂ : SimplicialObject.Split C\nself : S₁.Hom S₂\nn : Nat\nZ : C\nh : Quiver.Hom (S₂.X.obj { unop := SimplexCategory.mk n }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S₁.s.ι n) (CategoryTheory.CategoryStruct.comp (self.F.app { unop := SimplexCategory.mk n }) h)) (CategoryTheory.CategoryStruct.comp (self.f n) (CategoryTheory.CategoryStruct.comp (S₂.s.ι n) h))","decl":"attribute [simp, reassoc] Hom.comm\n\n"}
{"name":"SimplicialObject.Split.hom_ext_iff","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nS₁ S₂ : SimplicialObject.Split C\nΦ₁ Φ₂ : Quiver.Hom S₁ S₂\n⊢ Iff (Eq Φ₁ Φ₂) (∀ (n : Nat), Eq (Φ₁.f n) (Φ₂.f n))","decl":"@[ext]\ntheorem hom_ext {S₁ S₂ : Split C} (Φ₁ Φ₂ : S₁ ⟶ S₂) (h : ∀ n : ℕ, Φ₁.f n = Φ₂.f n) : Φ₁ = Φ₂ :=\n  Hom.ext _ _ h\n\n"}
{"name":"SimplicialObject.Split.hom_ext","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nS₁ S₂ : SimplicialObject.Split C\nΦ₁ Φ₂ : Quiver.Hom S₁ S₂\nh : ∀ (n : Nat), Eq (Φ₁.f n) (Φ₂.f n)\n⊢ Eq Φ₁ Φ₂","decl":"@[ext]\ntheorem hom_ext {S₁ S₂ : Split C} (Φ₁ Φ₂ : S₁ ⟶ S₂) (h : ∀ n : ℕ, Φ₁.f n = Φ₂.f n) : Φ₁ = Φ₂ :=\n  Hom.ext _ _ h\n\n"}
{"name":"SimplicialObject.Split.congr_F","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nS₁ S₂ : SimplicialObject.Split C\nΦ₁ Φ₂ : Quiver.Hom S₁ S₂\nh : Eq Φ₁ Φ₂\n⊢ Eq Φ₁.f Φ₂.f","decl":"theorem congr_F {S₁ S₂ : Split C} {Φ₁ Φ₂ : S₁ ⟶ S₂} (h : Φ₁ = Φ₂) : Φ₁.f = Φ₂.f := by rw [h]\n\n"}
{"name":"SimplicialObject.Split.congr_f","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nS₁ S₂ : SimplicialObject.Split C\nΦ₁ Φ₂ : Quiver.Hom S₁ S₂\nh : Eq Φ₁ Φ₂\nn : Nat\n⊢ Eq (Φ₁.f n) (Φ₂.f n)","decl":"theorem congr_f {S₁ S₂ : Split C} {Φ₁ Φ₂ : S₁ ⟶ S₂} (h : Φ₁ = Φ₂) (n : ℕ) : Φ₁.f n = Φ₂.f n := by\n  rw [h]\n\n"}
{"name":"SimplicialObject.Split.id_F","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nS : SimplicialObject.Split C\n⊢ Eq (CategoryTheory.CategoryStruct.id S).F (CategoryTheory.CategoryStruct.id S.X)","decl":"@[simp]\ntheorem id_F (S : Split C) : (𝟙 S : S ⟶ S).F = 𝟙 S.X :=\n  rfl\n\n"}
{"name":"SimplicialObject.Split.id_f","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nS : SimplicialObject.Split C\nn : Nat\n⊢ Eq ((CategoryTheory.CategoryStruct.id S).f n) (CategoryTheory.CategoryStruct.id (S.s.N n))","decl":"@[simp]\ntheorem id_f (S : Split C) (n : ℕ) : (𝟙 S : S ⟶ S).f n = 𝟙 (S.s.N n) :=\n  rfl\n\n"}
{"name":"SimplicialObject.Split.comp_F","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nS₁ S₂ S₃ : SimplicialObject.Split C\nΦ₁₂ : Quiver.Hom S₁ S₂\nΦ₂₃ : Quiver.Hom S₂ S₃\n⊢ Eq (CategoryTheory.CategoryStruct.comp Φ₁₂ Φ₂₃).F (CategoryTheory.CategoryStruct.comp Φ₁₂.F Φ₂₃.F)","decl":"@[simp]\ntheorem comp_F {S₁ S₂ S₃ : Split C} (Φ₁₂ : S₁ ⟶ S₂) (Φ₂₃ : S₂ ⟶ S₃) :\n    (Φ₁₂ ≫ Φ₂₃).F = Φ₁₂.F ≫ Φ₂₃.F :=\n  rfl\n\n"}
{"name":"SimplicialObject.Split.comp_f","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nS₁ S₂ S₃ : SimplicialObject.Split C\nΦ₁₂ : Quiver.Hom S₁ S₂\nΦ₂₃ : Quiver.Hom S₂ S₃\nn : Nat\n⊢ Eq ((CategoryTheory.CategoryStruct.comp Φ₁₂ Φ₂₃).f n) (CategoryTheory.CategoryStruct.comp (Φ₁₂.f n) (Φ₂₃.f n))","decl":"@[simp]\ntheorem comp_f {S₁ S₂ S₃ : Split C} (Φ₁₂ : S₁ ⟶ S₂) (Φ₂₃ : S₂ ⟶ S₃) (n : ℕ) :\n    (Φ₁₂ ≫ Φ₂₃).f n = Φ₁₂.f n ≫ Φ₂₃.f n :=\n  rfl\n\n-- This is not a `@[simp]` lemma as it can later be proved by `simp`.\n"}
{"name":"SimplicialObject.Split.cofan_inj_naturality_symm","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nS₁ S₂ : SimplicialObject.Split C\nΦ : Quiver.Hom S₁ S₂\nΔ : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Δ\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((S₁.s.cofan Δ).inj A) (Φ.F.app Δ)) (CategoryTheory.CategoryStruct.comp (Φ.f (Opposite.unop A.fst).len) ((S₂.s.cofan Δ).inj A))","decl":"@[reassoc]\ntheorem cofan_inj_naturality_symm {S₁ S₂ : Split C} (Φ : S₁ ⟶ S₂) {Δ : SimplexCategoryᵒᵖ}\n    (A : Splitting.IndexSet Δ) :\n    (S₁.s.cofan Δ).inj A ≫ Φ.F.app Δ = Φ.f A.1.unop.len ≫ (S₂.s.cofan Δ).inj A := by\n  rw [S₁.s.cofan_inj_eq, S₂.s.cofan_inj_eq, assoc, Φ.F.naturality, ← Φ.comm_assoc]\n\n"}
{"name":"SimplicialObject.Split.cofan_inj_naturality_symm_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nS₁ S₂ : SimplicialObject.Split C\nΦ : Quiver.Hom S₁ S₂\nΔ : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Δ\nZ : C\nh : Quiver.Hom (S₂.X.obj Δ) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((S₁.s.cofan Δ).inj A) (CategoryTheory.CategoryStruct.comp (Φ.F.app Δ) h)) (CategoryTheory.CategoryStruct.comp (Φ.f (Opposite.unop A.fst).len) (CategoryTheory.CategoryStruct.comp ((S₂.s.cofan Δ).inj A) h))","decl":"@[reassoc]\ntheorem cofan_inj_naturality_symm {S₁ S₂ : Split C} (Φ : S₁ ⟶ S₂) {Δ : SimplexCategoryᵒᵖ}\n    (A : Splitting.IndexSet Δ) :\n    (S₁.s.cofan Δ).inj A ≫ Φ.F.app Δ = Φ.f A.1.unop.len ≫ (S₂.s.cofan Δ).inj A := by\n  rw [S₁.s.cofan_inj_eq, S₂.s.cofan_inj_eq, assoc, Φ.F.naturality, ← Φ.comm_assoc]\n\n"}
{"name":"SimplicialObject.Split.forget_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nS : SimplicialObject.Split C\n⊢ Eq ((SimplicialObject.Split.forget C).obj S) S.X","decl":"/-- The functor `SimplicialObject.Split C ⥤ SimplicialObject C` which forgets\nthe splitting. -/\n@[simps]\ndef forget : Split C ⥤ SimplicialObject C where\n  obj S := S.X\n  map Φ := Φ.F\n\n"}
{"name":"SimplicialObject.Split.forget_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX✝ Y✝ : SimplicialObject.Split C\nΦ : Quiver.Hom X✝ Y✝\n⊢ Eq ((SimplicialObject.Split.forget C).map Φ) Φ.F","decl":"/-- The functor `SimplicialObject.Split C ⥤ SimplicialObject C` which forgets\nthe splitting. -/\n@[simps]\ndef forget : Split C ⥤ SimplicialObject C where\n  obj S := S.X\n  map Φ := Φ.F\n\n"}
{"name":"SimplicialObject.Split.evalN_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nS : SimplicialObject.Split C\n⊢ Eq ((SimplicialObject.Split.evalN C n).obj S) (S.s.N n)","decl":"/-- The functor `SimplicialObject.Split C ⥤ C` which sends a simplicial object equipped\nwith a splitting to its nondegenerate `n`-simplices. -/\n@[simps]\ndef evalN (n : ℕ) : Split C ⥤ C where\n  obj S := S.s.N n\n  map Φ := Φ.f n\n\n"}
{"name":"SimplicialObject.Split.evalN_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nX✝ Y✝ : SimplicialObject.Split C\nΦ : Quiver.Hom X✝ Y✝\n⊢ Eq ((SimplicialObject.Split.evalN C n).map Φ) (Φ.f n)","decl":"/-- The functor `SimplicialObject.Split C ⥤ C` which sends a simplicial object equipped\nwith a splitting to its nondegenerate `n`-simplices. -/\n@[simps]\ndef evalN (n : ℕ) : Split C ⥤ C where\n  obj S := S.s.N n\n  map Φ := Φ.f n\n\n"}
{"name":"SimplicialObject.Split.natTransCofanInj_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Split","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nΔ : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Δ\nS : SimplicialObject.Split C\n⊢ Eq ((SimplicialObject.Split.natTransCofanInj C A).app S) ((S.s.cofan Δ).inj A)","decl":"/-- The inclusion of each summand in the coproduct decomposition of simplices\nin split simplicial objects is a natural transformation of functors\n`SimplicialObject.Split C ⥤ C` -/\n@[simps]\ndef natTransCofanInj {Δ : SimplexCategoryᵒᵖ} (A : Splitting.IndexSet Δ) :\n    evalN C A.1.unop.len ⟶ forget C ⋙ (evaluation SimplexCategoryᵒᵖ C).obj Δ where\n  app S := (S.s.cofan Δ).inj A\n  naturality _ _ Φ := (cofan_inj_naturality_symm Φ A).symm\n\n"}
