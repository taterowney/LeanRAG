{"name":"CategoryTheory.PreGaloisCategory.has_decomp_quotients","module":"Mathlib.CategoryTheory.Galois.EssSurj","initialProofState":"G : Type u_1\ninst‚úù‚Å∂ : Group G\ninst‚úù‚Åµ : TopologicalSpace G\ninst‚úù‚Å¥ : TopologicalGroup G\ninst‚úù¬≥ : CompactSpace G\nX : Action FintypeCat (MonCat.of G)\ninst‚úù¬≤ : TopologicalSpace ‚ÜëX.V\ninst‚úù¬π : DiscreteTopology ‚ÜëX.V\ninst‚úù : ContinuousSMul G ‚ÜëX.V\n‚ä¢ Exists fun Œπ => Exists fun x => Exists fun f => Nonempty (CategoryTheory.Iso (CategoryTheory.Limits.sigmaObj fun i => Action.FintypeCat.ofMulAction G (FintypeCat.of (HasQuotient.Quotient G ‚Üë(f i)))) X)","decl":"/-- If `X` is a finite discrete `G`-set, it can be written as the finite disjoint union\nof quotients of the form `G ‚ß∏ U·µ¢` for open subgroups `(U·µ¢)`. Note that this\nis simply the decomposition into orbits. -/\nlemma has_decomp_quotients (X : Action FintypeCat (MonCat.of G))\n    [TopologicalSpace X.V] [DiscreteTopology X.V] [ContinuousSMul G X.V] :\n    ‚àÉ (Œπ : Type) (_ : Finite Œπ) (f : Œπ ‚Üí OpenSubgroup (G)),\n      Nonempty ((‚àê fun i ‚Ü¶ G ‚ß∏‚Çê (f i).toSubgroup) ‚âÖ X) := by\n  obtain ‚ü®Œπ, hf, f, u, hc‚ü© := has_decomp_connected_components' X\n  letI (i : Œπ) : TopologicalSpace (f i).V := ‚ä•\n  haveI (i : Œπ) : DiscreteTopology (f i).V := ‚ü®rfl‚ü©\n  have (i : Œπ) : ContinuousSMul G (f i).V := ContinuousSMul.mk <| by\n    let r : f i ‚ü∂ X := Sigma.Œπ f i ‚â´ u.hom\n    let r'' (p : G √ó (f i).V) : G √ó X.V := (p.1, r.hom p.2)\n    let q (p : G √ó X.V) : X.V := X.œÅ p.1 p.2\n    let q' (p : G √ó (f i).V) : (f i).V := (f i).œÅ p.1 p.2\n    have heq : q ‚àò r'' = r.hom ‚àò q' := by\n      ext (p : G √ó (f i).V)\n      exact (congr_fun (r.comm p.1) p.2).symm\n    have hrinj : Function.Injective r.hom :=\n      (ConcreteCategory.mono_iff_injective_of_preservesPullback r).mp <| mono_comp _ _\n    let t‚ÇÅ : TopologicalSpace (G √ó (f i).V) := inferInstance\n    show @Continuous _ _ _ ‚ä• q'\n    have : TopologicalSpace.induced r.hom inferInstance = ‚ä• := by\n      rw [‚Üê le_bot_iff]\n      exact fun s _ ‚Ü¶ ‚ü®r.hom '' s, ‚ü®isOpen_discrete (r.hom '' s), Set.preimage_image_eq s hrinj‚ü©‚ü©\n    rw [‚Üê this, continuous_induced_rng, ‚Üê heq]\n    exact Continuous.comp continuous_smul (by fun_prop)\n  have (i : Œπ) : ‚àÉ (U : OpenSubgroup (G)), (Nonempty ((f i) ‚âÖ G ‚ß∏‚Çê U.toSubgroup)) := by\n    obtain ‚ü®(x : (f i).V)‚ü© := nonempty_fiber_of_isConnected (forget‚ÇÇ _ _) (f i)\n    let U : OpenSubgroup (G) := ‚ü®MulAction.stabilizer (G) x, stabilizer_isOpen (G) x‚ü©\n    letI : Fintype (G ‚ß∏ MulAction.stabilizer (G) x) := fintypeQuotient U\n    exact ‚ü®U, ‚ü®FintypeCat.isoQuotientStabilizerOfIsConnected (f i) x‚ü©‚ü©\n  choose g ui using this\n  exact ‚ü®Œπ, hf, g, ‚ü®(Sigma.mapIso (fun i ‚Ü¶ (ui i).some)).symm ‚â™‚â´ u‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.exists_lift_of_quotient_openSubgroup","module":"Mathlib.CategoryTheory.Galois.EssSurj","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nF : CategoryTheory.Functor C FintypeCat\ninst‚úù¬π : CategoryTheory.GaloisCategory C\ninst‚úù : CategoryTheory.PreGaloisCategory.FiberFunctor F\nV : OpenSubgroup (CategoryTheory.Aut F)\n‚ä¢ Exists fun X => Nonempty (CategoryTheory.Iso ((CategoryTheory.PreGaloisCategory.functorToAction F).obj X) (Action.FintypeCat.ofMulAction (CategoryTheory.Aut F) (FintypeCat.of (HasQuotient.Quotient (CategoryTheory.Aut F) ‚ÜëV))))","decl":"/-- For every open subgroup `V` of `Aut F`, there exists an `X : C` such that\n`F.obj X ‚âÖ Aut F ‚ß∏ V` as `Aut F`-sets. -/\nlemma exists_lift_of_quotient_openSubgroup (V : OpenSubgroup (Aut F)) :\n    ‚àÉ (X : C), Nonempty ((functorToAction F).obj X ‚âÖ Aut F ‚ß∏‚Çê V.toSubgroup) := by\n  obtain ‚ü®I, hf, hc, hi‚ü© := exists_set_ker_evaluation_subset_of_isOpen F (one_mem V) V.isOpen'\n  haveI (X : I) : IsConnected X.val := hc X X.property\n  haveI (X : I) : Nonempty (F.obj X.val) := nonempty_fiber_of_isConnected F X\n  have hn : Nonempty (F.obj <| (‚àè·∂ú fun X : I => X)) := nonempty_fiber_pi_of_nonempty_of_finite F _\n  obtain ‚ü®A, f, hgal‚ü© := exists_hom_from_galois_of_fiber_nonempty F (‚àè·∂ú fun X : I => X) hn\n  obtain ‚ü®a‚ü© := nonempty_fiber_of_isConnected F A\n  let U : OpenSubgroup (Aut F) := ‚ü®MulAction.stabilizer (Aut F) a, stabilizer_isOpen (Aut F) a‚ü©\n  let u := fiberIsoQuotientStabilizer A a\n  have hUnormal : U.toSubgroup.Normal := stabilizer_normal_of_isGalois F A a\n  have h1 (œÉ : Aut F) (œÉinU : œÉ ‚àà U) : œÉ.hom.app A = ùüô (F.obj A) := by\n    have hi : (Aut F ‚ß∏‚Çê MulAction.stabilizer (Aut F) a).œÅ œÉ = ùüô _ := by\n      refine FintypeCat.hom_ext _ _ (fun x ‚Ü¶ ?_)\n      induction' x using Quotient.inductionOn with œÑ\n      show ‚ü¶œÉ * œÑ‚üß = ‚ü¶œÑ‚üß\n      apply Quotient.sound\n      apply (QuotientGroup.leftRel_apply).mpr\n      simp only [mul_inv_rev]\n      exact Subgroup.Normal.conj_mem hUnormal _ (Subgroup.inv_mem U.toSubgroup œÉinU) _\n    simp [‚Üê cancel_mono u.hom.hom, show œÉ.hom.app A ‚â´ u.hom.hom = _ from u.hom.comm œÉ, hi]\n  have h2 (œÉ : Aut F) (œÉinU : œÉ ‚àà U) : ‚àÄ X : I, œÉ.hom.app X = ùüô (F.obj X) := by\n    intro ‚ü®X, hX‚ü©\n    ext (x : F.obj X)\n    let p : A ‚ü∂ X := f ‚â´ Pi.œÄ (fun Z : I => (Z : C)) ‚ü®X, hX‚ü©\n    have : IsConnected X := hc X hX\n    obtain ‚ü®a, rfl‚ü© := surjective_of_nonempty_fiber_of_isConnected F p x\n    simp only [FintypeCat.id_apply, FunctorToFintypeCat.naturality, h1 œÉ œÉinU]\n  have hUinV : (U : Set (Aut F)) ‚â§ V := fun u uinU ‚Ü¶ hi u (h2 u uinU)\n  have := V.quotient_finite_of_isOpen' (U.subgroupOf V) V.isOpen (V.subgroupOf_isOpen U U.isOpen)\n  exact ‚ü®colimit (quotientDiag V hUnormal u),\n    ‚ü®preservesColimitIso (functorToAction F) (quotientDiag V hUnormal u) ‚â™‚â´\n    colimit.isoColimitCocone ‚ü®coconeQuotientDiag hUnormal u hUinV,\n    coconeQuotientDiagIsColimit hUnormal u hUinV‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.exists_lift_of_continuous","module":"Mathlib.CategoryTheory.Galois.EssSurj","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C\nF : CategoryTheory.Functor C FintypeCat\ninst‚úù‚Å¥ : CategoryTheory.GaloisCategory C\ninst‚úù¬≥ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nX : Action FintypeCat (MonCat.of (CategoryTheory.Aut F))\ninst‚úù¬≤ : TopologicalSpace ‚ÜëX.V\ninst‚úù¬π : DiscreteTopology ‚ÜëX.V\ninst‚úù : ContinuousSMul (CategoryTheory.Aut F) ‚ÜëX.V\n‚ä¢ Exists fun A => Nonempty (CategoryTheory.Iso ((CategoryTheory.PreGaloisCategory.functorToAction F).obj A) X)","decl":"/--\nIf `X` is a finite, discrete `Aut F`-set with continuous `Aut F`-action, then\nthere exists `A : C` such that `F.obj A ‚âÖ X` as `Aut F`-sets.\n-/\n@[stacks 0BN4 \"Essential surjectivity part\"]\ntheorem exists_lift_of_continuous (X : Action FintypeCat (MonCat.of (Aut F)))\n    [TopologicalSpace X.V] [DiscreteTopology X.V] [ContinuousSMul (Aut F) X.V] :\n    ‚àÉ A, Nonempty ((functorToAction F).obj A ‚âÖ X) := by\n  obtain ‚ü®Œπ, hfin, f, ‚ü®u‚ü©‚ü© := has_decomp_quotients X\n  choose g gu using (fun i ‚Ü¶ exists_lift_of_quotient_openSubgroup (f i))\n  exact ‚ü®‚àê g, ‚ü®PreservesCoproduct.iso (functorToAction F) g ‚â™‚â´\n    Sigma.mapIso (fun i ‚Ü¶ (gu i).some) ‚â™‚â´ u‚ü©‚ü©\n\n"}
