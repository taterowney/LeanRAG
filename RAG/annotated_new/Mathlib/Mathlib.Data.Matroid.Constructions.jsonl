{"name":"Matroid.emptyOn_ground","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\n⊢ Eq (Matroid.emptyOn α).E EmptyCollection.emptyCollection","decl":"@[simp] theorem emptyOn_ground : (emptyOn α).E = ∅ := rfl\n\n"}
{"name":"Matroid.emptyOn_base_iff","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nB : Set α\n⊢ Iff ((Matroid.emptyOn α).Base B) (Eq B EmptyCollection.emptyCollection)","decl":"@[simp] theorem emptyOn_base_iff : (emptyOn α).Base B ↔ B = ∅ := Iff.rfl\n\n"}
{"name":"Matroid.emptyOn_indep_iff","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nI : Set α\n⊢ Iff ((Matroid.emptyOn α).Indep I) (Eq I EmptyCollection.emptyCollection)","decl":"@[simp] theorem emptyOn_indep_iff : (emptyOn α).Indep I ↔ I = ∅ := Iff.rfl\n\n"}
{"name":"Matroid.ground_eq_empty_iff","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nM : Matroid α\n⊢ Iff (Eq M.E EmptyCollection.emptyCollection) (Eq M (Matroid.emptyOn α))","decl":"theorem ground_eq_empty_iff : (M.E = ∅) ↔ M = emptyOn α := by\n  simp only [emptyOn, ext_iff_indep, iff_self_and]\n  exact fun h ↦ by simp [h, subset_empty_iff]\n\n"}
{"name":"Matroid.emptyOn_dual_eq","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\n⊢ Eq (Matroid.emptyOn α).dual (Matroid.emptyOn α)","decl":"@[simp] theorem emptyOn_dual_eq : (emptyOn α)✶ = emptyOn α := by\n  rw [← ground_eq_empty_iff]; rfl\n\n"}
{"name":"Matroid.restrict_empty","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nM : Matroid α\n⊢ Eq (M.restrict EmptyCollection.emptyCollection) (Matroid.emptyOn α)","decl":"@[simp] theorem restrict_empty (M : Matroid α) : M ↾ (∅ : Set α) = emptyOn α := by\n  simp [← ground_eq_empty_iff]\n\n"}
{"name":"Matroid.eq_emptyOn_or_nonempty","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nM : Matroid α\n⊢ Or (Eq M (Matroid.emptyOn α)) M.Nonempty","decl":"theorem eq_emptyOn_or_nonempty (M : Matroid α) : M = emptyOn α ∨ Matroid.Nonempty M := by\n  rw [← ground_eq_empty_iff]\n  exact M.E.eq_empty_or_nonempty.elim Or.inl (fun h ↦ Or.inr ⟨h⟩)\n\n"}
{"name":"Matroid.eq_emptyOn","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\ninst✝ : IsEmpty α\nM : Matroid α\n⊢ Eq M (Matroid.emptyOn α)","decl":"theorem eq_emptyOn [IsEmpty α] (M : Matroid α) : M = emptyOn α := by\n  rw [← ground_eq_empty_iff]\n  exact M.E.eq_empty_of_isEmpty\n\n"}
{"name":"Matroid.finite_emptyOn","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_2\n⊢ (Matroid.emptyOn α).Finite","decl":"instance finite_emptyOn (α : Type*) : (emptyOn α).Finite :=\n  ⟨finite_empty⟩\n\n"}
{"name":"Matroid.loopyOn_ground","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nE : Set α\n⊢ Eq (Matroid.loopyOn E).E E","decl":"@[simp] theorem loopyOn_ground (E : Set α) : (loopyOn E).E = E := rfl\n\n"}
{"name":"Matroid.loopyOn_empty","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_2\n⊢ Eq (Matroid.loopyOn EmptyCollection.emptyCollection) (Matroid.emptyOn α)","decl":"@[simp] theorem loopyOn_empty (α : Type*) : loopyOn (∅ : Set α) = emptyOn α := by\n  rw [← ground_eq_empty_iff, loopyOn_ground]\n\n"}
{"name":"Matroid.loopyOn_indep_iff","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nE I : Set α\n⊢ Iff ((Matroid.loopyOn E).Indep I) (Eq I EmptyCollection.emptyCollection)","decl":"@[simp] theorem loopyOn_indep_iff : (loopyOn E).Indep I ↔ I = ∅ := by\n  simp only [loopyOn, restrict_indep_iff, emptyOn_indep_iff, and_iff_left_iff_imp]\n  rintro rfl; apply empty_subset\n\n"}
{"name":"Matroid.eq_loopyOn_iff","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nM : Matroid α\nE : Set α\n⊢ Iff (Eq M (Matroid.loopyOn E)) (And (Eq M.E E) (∀ (X : Set α), HasSubset.Subset X M.E → M.Indep X → Eq X EmptyCollection.emptyCollection))","decl":"theorem eq_loopyOn_iff : M = loopyOn E ↔ M.E = E ∧ ∀ X ⊆ M.E, M.Indep X → X = ∅ := by\n  simp only [ext_iff_indep, loopyOn_ground, loopyOn_indep_iff, and_congr_right_iff]\n  rintro rfl\n  refine ⟨fun h I hI ↦ (h hI).1, fun h I hIE ↦ ⟨h I hIE, by rintro rfl; simp⟩⟩\n\n"}
{"name":"Matroid.loopyOn_base_iff","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nE B : Set α\n⊢ Iff ((Matroid.loopyOn E).Base B) (Eq B EmptyCollection.emptyCollection)","decl":"@[simp] theorem loopyOn_base_iff : (loopyOn E).Base B ↔ B = ∅ := by\n  simp [Maximal, base_iff_maximal_indep]\n\n"}
{"name":"Matroid.loopyOn_basis_iff","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nE I X : Set α\n⊢ Iff ((Matroid.loopyOn E).Basis I X) (And (Eq I EmptyCollection.emptyCollection) (HasSubset.Subset X E))","decl":"@[simp] theorem loopyOn_basis_iff : (loopyOn E).Basis I X ↔ I = ∅ ∧ X ⊆ E :=\n  ⟨fun h ↦ ⟨loopyOn_indep_iff.mp h.indep, h.subset_ground⟩,\n    by rintro ⟨rfl, hX⟩; rw [basis_iff]; simp⟩\n\n"}
{"name":"Matroid.instFiniteRkLoopyOn","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nE : Set α\n⊢ (Matroid.loopyOn E).FiniteRk","decl":"instance : FiniteRk (loopyOn E) :=\n  ⟨⟨∅, loopyOn_base_iff.2 rfl, finite_empty⟩⟩\n\n"}
{"name":"Matroid.Finite.loopyOn_finite","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nE : Set α\nhE : E.Finite\n⊢ (Matroid.loopyOn E).Finite","decl":"theorem Finite.loopyOn_finite (hE : E.Finite) : Matroid.Finite (loopyOn E) :=\n  ⟨hE⟩\n\n"}
{"name":"Matroid.loopyOn_restrict","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nE R : Set α\n⊢ Eq ((Matroid.loopyOn E).restrict R) (Matroid.loopyOn R)","decl":"@[simp] theorem loopyOn_restrict (E R : Set α) : (loopyOn E) ↾ R = loopyOn R := by\n  refine ext_indep rfl ?_\n  simp only [restrict_ground_eq, restrict_indep_iff, loopyOn_indep_iff, and_iff_left_iff_imp]\n  exact fun _ h _ ↦ h\n\n"}
{"name":"Matroid.empty_base_iff","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nM : Matroid α\n⊢ Iff (M.Base EmptyCollection.emptyCollection) (Eq M (Matroid.loopyOn M.E))","decl":"theorem empty_base_iff : M.Base ∅ ↔ M = loopyOn M.E := by\n  simp only [base_iff_maximal_indep, Maximal, empty_indep, le_eq_subset, empty_subset,\n    subset_empty_iff, true_implies, true_and, ext_iff_indep, loopyOn_ground,\n    loopyOn_indep_iff]\n  exact ⟨fun h I _ ↦ ⟨@h _, fun hI ↦ by simp [hI]⟩, fun h I hI ↦ (h hI.subset_ground).1 hI⟩\n\n"}
{"name":"Matroid.eq_loopyOn_or_rkPos","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nM : Matroid α\n⊢ Or (Eq M (Matroid.loopyOn M.E)) M.RkPos","decl":"theorem eq_loopyOn_or_rkPos (M : Matroid α) : M = loopyOn M.E ∨ RkPos M := by\n  rw [← empty_base_iff, rkPos_iff]; apply em\n\n"}
{"name":"Matroid.not_rkPos_iff","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nM : Matroid α\n⊢ Iff (Not M.RkPos) (Eq M (Matroid.loopyOn M.E))","decl":"theorem not_rkPos_iff : ¬RkPos M ↔ M = loopyOn M.E := by\n  rw [rkPos_iff, not_iff_comm, empty_base_iff]\n\n"}
{"name":"Matroid.loopyOn_finiteRk","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nE : Set α\n⊢ (Matroid.loopyOn E).FiniteRk","decl":"instance loopyOn_finiteRk : FiniteRk (loopyOn E) :=\n  ⟨∅, by simp⟩\n\n"}
{"name":"Matroid.freeOn_ground","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nE : Set α\n⊢ Eq (Matroid.freeOn E).E E","decl":"@[simp] theorem freeOn_ground : (freeOn E).E = E := rfl\n\n"}
{"name":"Matroid.freeOn_dual_eq","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nE : Set α\n⊢ Eq (Matroid.freeOn E).dual (Matroid.loopyOn E)","decl":"@[simp] theorem freeOn_dual_eq : (freeOn E)✶ = loopyOn E := by\n  rw [freeOn, dual_dual]\n\n"}
{"name":"Matroid.loopyOn_dual_eq","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nE : Set α\n⊢ Eq (Matroid.loopyOn E).dual (Matroid.freeOn E)","decl":"@[simp] theorem loopyOn_dual_eq : (loopyOn E)✶ = freeOn E := rfl\n\n"}
{"name":"Matroid.freeOn_empty","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_2\n⊢ Eq (Matroid.freeOn EmptyCollection.emptyCollection) (Matroid.emptyOn α)","decl":"@[simp] theorem freeOn_empty (α : Type*) : freeOn (∅ : Set α) = emptyOn α := by\n  simp [freeOn]\n\n"}
{"name":"Matroid.freeOn_base_iff","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nE B : Set α\n⊢ Iff ((Matroid.freeOn E).Base B) (Eq B E)","decl":"@[simp] theorem freeOn_base_iff : (freeOn E).Base B ↔ B = E := by\n  simp only [freeOn, loopyOn_ground, dual_base_iff', loopyOn_base_iff, diff_eq_empty,\n    ← subset_antisymm_iff, eq_comm (a := E)]\n\n"}
{"name":"Matroid.freeOn_indep_iff","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nE I : Set α\n⊢ Iff ((Matroid.freeOn E).Indep I) (HasSubset.Subset I E)","decl":"@[simp] theorem freeOn_indep_iff : (freeOn E).Indep I ↔ I ⊆ E := by\n  simp [indep_iff]\n\n"}
{"name":"Matroid.freeOn_indep","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nE I : Set α\nhIE : HasSubset.Subset I E\n⊢ (Matroid.freeOn E).Indep I","decl":"theorem freeOn_indep (hIE : I ⊆ E) : (freeOn E).Indep I :=\n  freeOn_indep_iff.2 hIE\n\n"}
{"name":"Matroid.freeOn_basis_iff","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nE I X : Set α\n⊢ Iff ((Matroid.freeOn E).Basis I X) (And (Eq I X) (HasSubset.Subset X E))","decl":"@[simp] theorem freeOn_basis_iff : (freeOn E).Basis I X ↔ I = X ∧ X ⊆ E := by\n  use fun h ↦ ⟨(freeOn_indep h.subset_ground).eq_of_basis h ,h.subset_ground⟩\n  rintro ⟨rfl, hIE⟩\n  exact (freeOn_indep hIE).basis_self\n\n"}
{"name":"Matroid.freeOn_basis'_iff","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nE I X : Set α\n⊢ Iff ((Matroid.freeOn E).Basis' I X) (Eq I (Inter.inter X E))","decl":"@[simp] theorem freeOn_basis'_iff : (freeOn E).Basis' I X ↔ I = X ∩ E := by\n  rw [basis'_iff_basis_inter_ground, freeOn_basis_iff, freeOn_ground,\n    and_iff_left inter_subset_right]\n\n"}
{"name":"Matroid.eq_freeOn_iff","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nM : Matroid α\nE : Set α\n⊢ Iff (Eq M (Matroid.freeOn E)) (And (Eq M.E E) (M.Indep E))","decl":"theorem eq_freeOn_iff : M = freeOn E ↔ M.E = E ∧ M.Indep E := by\n  refine ⟨?_, fun h ↦ ?_⟩\n  · rintro rfl; simp [Subset.rfl]\n  simp only [ext_iff_indep, freeOn_ground, freeOn_indep_iff, h.1, true_and]\n  exact fun I hIX ↦ iff_of_true (h.2.subset hIX) hIX\n\n"}
{"name":"Matroid.ground_indep_iff_eq_freeOn","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nM : Matroid α\n⊢ Iff (M.Indep M.E) (Eq M (Matroid.freeOn M.E))","decl":"theorem ground_indep_iff_eq_freeOn : M.Indep M.E ↔ M = freeOn M.E := by\n  simp [eq_freeOn_iff]\n\n"}
{"name":"Matroid.freeOn_restrict","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nE R : Set α\nh : HasSubset.Subset R E\n⊢ Eq ((Matroid.freeOn E).restrict R) (Matroid.freeOn R)","decl":"theorem freeOn_restrict (h : R ⊆ E) : (freeOn E) ↾ R = freeOn R := by\n  simp [h, eq_freeOn_iff, Subset.rfl]\n\n"}
{"name":"Matroid.restrict_eq_freeOn_iff","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\n⊢ Iff (Eq (M.restrict I) (Matroid.freeOn I)) (M.Indep I)","decl":"theorem restrict_eq_freeOn_iff : M ↾ I = freeOn I ↔ M.Indep I := by\n  rw [eq_freeOn_iff, and_iff_right M.restrict_ground_eq, restrict_indep_iff,\n    and_iff_left Subset.rfl]\n\n"}
{"name":"Matroid.Indep.restrict_eq_freeOn","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\nhI : M.Indep I\n⊢ Eq (M.restrict I) (Matroid.freeOn I)","decl":"theorem Indep.restrict_eq_freeOn (hI : M.Indep I) : M ↾ I = freeOn I := by\n  rwa [restrict_eq_freeOn_iff]\n\n"}
{"name":"Matroid.freeOn_finitary","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nE : Set α\n⊢ (Matroid.freeOn E).Finitary","decl":"instance freeOn_finitary : Finitary (freeOn E) := by\n  simp only [finitary_iff, freeOn_indep_iff]\n  exact fun I h e heI ↦ by simpa using h {e} (by simpa)\n\n"}
{"name":"Matroid.freeOn_rkPos","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nE : Set α\nhE : E.Nonempty\n⊢ (Matroid.freeOn E).RkPos","decl":"lemma freeOn_rkPos (hE : E.Nonempty) : RkPos (freeOn E) := by\n  simp [rkPos_iff, hE.ne_empty.symm]\n\n"}
{"name":"Matroid.uniqueBaseOn_ground","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nE I : Set α\n⊢ Eq (Matroid.uniqueBaseOn I E).E E","decl":"@[simp] theorem uniqueBaseOn_ground : (uniqueBaseOn I E).E = E :=\n  rfl\n\n"}
{"name":"Matroid.uniqueBaseOn_base_iff","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nE B I : Set α\nhIE : HasSubset.Subset I E\n⊢ Iff ((Matroid.uniqueBaseOn I E).Base B) (Eq B I)","decl":"theorem uniqueBaseOn_base_iff (hIE : I ⊆ E) : (uniqueBaseOn I E).Base B ↔ B = I := by\n  rw [uniqueBaseOn, base_restrict_iff', freeOn_basis'_iff, inter_eq_self_of_subset_right hIE]\n\n"}
{"name":"Matroid.uniqueBaseOn_inter_ground_eq","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nI E : Set α\n⊢ Eq (Matroid.uniqueBaseOn (Inter.inter I E) E) (Matroid.uniqueBaseOn I E)","decl":"theorem uniqueBaseOn_inter_ground_eq (I E : Set α) :\n    uniqueBaseOn (I ∩ E) E = uniqueBaseOn I E := by\n  simp only [uniqueBaseOn, restrict_eq_restrict_iff, freeOn_indep_iff, subset_inter_iff,\n    iff_self_and]\n  tauto\n\n"}
{"name":"Matroid.uniqueBaseOn_indep_iff'","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nE I J : Set α\n⊢ Iff ((Matroid.uniqueBaseOn I E).Indep J) (HasSubset.Subset J (Inter.inter I E))","decl":"@[simp] theorem uniqueBaseOn_indep_iff' : (uniqueBaseOn I E).Indep J ↔ J ⊆ I ∩ E := by\n  rw [uniqueBaseOn, restrict_indep_iff, freeOn_indep_iff, subset_inter_iff]\n\n"}
{"name":"Matroid.uniqueBaseOn_indep_iff","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nE I J : Set α\nhIE : HasSubset.Subset I E\n⊢ Iff ((Matroid.uniqueBaseOn I E).Indep J) (HasSubset.Subset J I)","decl":"theorem uniqueBaseOn_indep_iff (hIE : I ⊆ E) : (uniqueBaseOn I E).Indep J ↔ J ⊆ I := by\n  rw [uniqueBaseOn, restrict_indep_iff, freeOn_indep_iff, and_iff_left_iff_imp]\n  exact fun h ↦ h.trans hIE\n\n"}
{"name":"Matroid.uniqueBaseOn_basis_iff","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nE I X J : Set α\nhX : HasSubset.Subset X E\n⊢ Iff ((Matroid.uniqueBaseOn I E).Basis J X) (Eq J (Inter.inter X I))","decl":"theorem uniqueBaseOn_basis_iff (hX : X ⊆ E) : (uniqueBaseOn I E).Basis J X ↔ J = X ∩ I := by\n  rw [basis_iff_maximal]\n  exact maximal_iff_eq (by simp [inter_subset_left.trans hX])\n    (by simp (config := {contextual := true}))\n\n"}
{"name":"Matroid.uniqueBaseOn_inter_basis","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nE I X : Set α\nhX : HasSubset.Subset X E\n⊢ (Matroid.uniqueBaseOn I E).Basis (Inter.inter X I) X","decl":"theorem uniqueBaseOn_inter_basis (hX : X ⊆ E) : (uniqueBaseOn I E).Basis (X ∩ I) X := by\n  rw [uniqueBaseOn_basis_iff hX]\n\n"}
{"name":"Matroid.uniqueBaseOn_dual_eq","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nI E : Set α\n⊢ Eq (Matroid.uniqueBaseOn I E).dual (Matroid.uniqueBaseOn (SDiff.sdiff E I) E)","decl":"@[simp] theorem uniqueBaseOn_dual_eq (I E : Set α) :\n    (uniqueBaseOn I E)✶ = uniqueBaseOn (E \\ I) E := by\n  rw [← uniqueBaseOn_inter_ground_eq]\n  refine ext_base rfl (fun B (hB : B ⊆ E) ↦ ?_)\n  rw [dual_base_iff, uniqueBaseOn_base_iff inter_subset_right, uniqueBaseOn_base_iff diff_subset,\n    uniqueBaseOn_ground]\n  exact ⟨fun h ↦ by rw [← diff_diff_cancel_left hB, h, diff_inter_self_eq_diff],\n    fun h ↦ by rw [h, inter_comm I]; simp⟩\n\n"}
{"name":"Matroid.uniqueBaseOn_self","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nI : Set α\n⊢ Eq (Matroid.uniqueBaseOn I I) (Matroid.freeOn I)","decl":"@[simp] theorem uniqueBaseOn_self (I : Set α) : uniqueBaseOn I I = freeOn I := by\n  rw [uniqueBaseOn, freeOn_restrict rfl.subset]\n\n"}
{"name":"Matroid.uniqueBaseOn_empty","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nI : Set α\n⊢ Eq (Matroid.uniqueBaseOn EmptyCollection.emptyCollection I) (Matroid.loopyOn I)","decl":"@[simp] theorem uniqueBaseOn_empty (I : Set α) : uniqueBaseOn ∅ I = loopyOn I := by\n  rw [← dual_inj, uniqueBaseOn_dual_eq, diff_empty, uniqueBaseOn_self, loopyOn_dual_eq]\n\n"}
{"name":"Matroid.uniqueBaseOn_restrict'","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nI E R : Set α\n⊢ Eq ((Matroid.uniqueBaseOn I E).restrict R) (Matroid.uniqueBaseOn (Inter.inter (Inter.inter I R) E) R)","decl":"theorem uniqueBaseOn_restrict' (I E R : Set α) :\n    (uniqueBaseOn I E) ↾ R = uniqueBaseOn (I ∩ R ∩ E) R := by\n  simp_rw [ext_iff_indep, restrict_ground_eq, uniqueBaseOn_ground, true_and,\n    restrict_indep_iff, uniqueBaseOn_indep_iff', subset_inter_iff]\n  tauto\n\n"}
{"name":"Matroid.uniqueBaseOn_restrict","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nE I : Set α\nh : HasSubset.Subset I E\nR : Set α\n⊢ Eq ((Matroid.uniqueBaseOn I E).restrict R) (Matroid.uniqueBaseOn (Inter.inter I R) R)","decl":"theorem uniqueBaseOn_restrict (h : I ⊆ E) (R : Set α) :\n    (uniqueBaseOn I E) ↾ R = uniqueBaseOn (I ∩ R) R := by\n  rw [uniqueBaseOn_restrict', inter_right_comm, inter_eq_self_of_subset_left h]\n\n"}
{"name":"Matroid.uniqueBaseOn_finiteRk","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nE I : Set α\nhI : I.Finite\n⊢ (Matroid.uniqueBaseOn I E).FiniteRk","decl":"lemma uniqueBaseOn_finiteRk (hI : I.Finite) : FiniteRk (uniqueBaseOn I E) := by\n  rw [← uniqueBaseOn_inter_ground_eq]\n  refine ⟨I ∩ E, ?_⟩\n  rw [uniqueBaseOn_base_iff inter_subset_right, and_iff_right rfl]\n  exact hI.subset inter_subset_left\n\n"}
{"name":"Matroid.uniqueBaseOn_finitary","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nE I : Set α\n⊢ (Matroid.uniqueBaseOn I E).Finitary","decl":"instance uniqueBaseOn_finitary : Finitary (uniqueBaseOn I E) := by\n  refine ⟨fun K hK ↦ ?_⟩\n  simp only [uniqueBaseOn_indep_iff'] at hK ⊢\n  exact fun e heK ↦ singleton_subset_iff.1 <| hK _ (by simpa) (by simp)\n\n"}
{"name":"Matroid.uniqueBaseOn_rkPos","module":"Mathlib.Data.Matroid.Constructions","initialProofState":"α : Type u_1\nE I : Set α\nhIE : HasSubset.Subset I E\nhI : I.Nonempty\n⊢ (Matroid.uniqueBaseOn I E).RkPos","decl":"lemma uniqueBaseOn_rkPos (hIE : I ⊆ E) (hI : I.Nonempty) : RkPos (uniqueBaseOn I E) where\n  empty_not_base := by simpa [uniqueBaseOn_base_iff hIE] using Ne.symm <| hI.ne_empty\n\n"}
