{"name":"Finset.mem_zero","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : Zero α\na : α\n⊢ Iff (Membership.mem 0 a) (Eq a 0)","decl":"@[to_additive (attr := simp)]\ntheorem mem_one : a ∈ (1 : Finset α) ↔ a = 1 :=\n  mem_singleton\n\n"}
{"name":"Finset.mem_one","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : One α\na : α\n⊢ Iff (Membership.mem 1 a) (Eq a 1)","decl":"@[to_additive (attr := simp)]\ntheorem mem_one : a ∈ (1 : Finset α) ↔ a = 1 :=\n  mem_singleton\n\n"}
{"name":"Finset.coe_one","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : One α\n⊢ Eq (↑1) 1","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_one : ↑(1 : Finset α) = (1 : Set α) :=\n  coe_singleton 1\n\n"}
{"name":"Finset.coe_zero","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : Zero α\n⊢ Eq (↑0) 0","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_one : ↑(1 : Finset α) = (1 : Set α) :=\n  coe_singleton 1\n\n"}
{"name":"Finset.coe_eq_one","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : One α\ns : Finset α\n⊢ Iff (Eq (↑s) 1) (Eq s 1)","decl":"@[to_additive (attr := simp, norm_cast)]\nlemma coe_eq_one : (s : Set α) = 1 ↔ s = 1 := coe_eq_singleton\n\n"}
{"name":"Finset.coe_eq_zero","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : Zero α\ns : Finset α\n⊢ Iff (Eq (↑s) 0) (Eq s 0)","decl":"@[to_additive (attr := simp, norm_cast)]\nlemma coe_eq_one : (s : Set α) = 1 ↔ s = 1 := coe_eq_singleton\n\n"}
{"name":"Finset.zero_subset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : Zero α\ns : Finset α\n⊢ Iff (HasSubset.Subset 0 s) (Membership.mem s 0)","decl":"@[to_additive (attr := simp)]\ntheorem one_subset : (1 : Finset α) ⊆ s ↔ (1 : α) ∈ s :=\n  singleton_subset_iff\n\n-- TODO: This would be a good simp lemma scoped to `Pointwise`, but it seems `@[simp]` can't be\n-- scoped\n"}
{"name":"Finset.one_subset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : One α\ns : Finset α\n⊢ Iff (HasSubset.Subset 1 s) (Membership.mem s 1)","decl":"@[to_additive (attr := simp)]\ntheorem one_subset : (1 : Finset α) ⊆ s ↔ (1 : α) ∈ s :=\n  singleton_subset_iff\n\n-- TODO: This would be a good simp lemma scoped to `Pointwise`, but it seems `@[simp]` can't be\n-- scoped\n"}
{"name":"Finset.singleton_zero","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : Zero α\n⊢ Eq (Singleton.singleton 0) 0","decl":"@[to_additive]\ntheorem singleton_one : ({1} : Finset α) = 1 :=\n  rfl\n\n"}
{"name":"Finset.singleton_one","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : One α\n⊢ Eq (Singleton.singleton 1) 1","decl":"@[to_additive]\ntheorem singleton_one : ({1} : Finset α) = 1 :=\n  rfl\n\n"}
{"name":"Finset.one_mem_one","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : One α\n⊢ Membership.mem 1 1","decl":"@[to_additive]\ntheorem one_mem_one : (1 : α) ∈ (1 : Finset α) :=\n  mem_singleton_self _\n\n"}
{"name":"Finset.zero_mem_zero","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : Zero α\n⊢ Membership.mem 0 0","decl":"@[to_additive]\ntheorem one_mem_one : (1 : α) ∈ (1 : Finset α) :=\n  mem_singleton_self _\n\n"}
{"name":"Finset.zero_nonempty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : Zero α\n⊢ Finset.Nonempty 0","decl":"@[to_additive (attr := simp, aesop safe apply (rule_sets := [finsetNonempty]))]\ntheorem one_nonempty : (1 : Finset α).Nonempty :=\n  ⟨1, one_mem_one⟩\n\n"}
{"name":"Finset.one_nonempty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : One α\n⊢ Finset.Nonempty 1","decl":"@[to_additive (attr := simp, aesop safe apply (rule_sets := [finsetNonempty]))]\ntheorem one_nonempty : (1 : Finset α).Nonempty :=\n  ⟨1, one_mem_one⟩\n\n"}
{"name":"Finset.map_one","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : One α\nf : Function.Embedding α β\n⊢ Eq (Finset.map f 1) (Singleton.singleton (f 1))","decl":"@[to_additive (attr := simp)]\nprotected theorem map_one {f : α ↪ β} : map f 1 = {f 1} :=\n  map_singleton f 1\n\n"}
{"name":"Finset.map_zero","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : Zero α\nf : Function.Embedding α β\n⊢ Eq (Finset.map f 0) (Singleton.singleton (f 0))","decl":"@[to_additive (attr := simp)]\nprotected theorem map_one {f : α ↪ β} : map f 1 = {f 1} :=\n  map_singleton f 1\n\n"}
{"name":"Finset.image_one","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : One α\ninst✝ : DecidableEq β\nf : α → β\n⊢ Eq (Finset.image f 1) (Singleton.singleton (f 1))","decl":"@[to_additive (attr := simp)]\ntheorem image_one [DecidableEq β] {f : α → β} : image f 1 = {f 1} :=\n  image_singleton _ _\n\n"}
{"name":"Finset.image_zero","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Zero α\ninst✝ : DecidableEq β\nf : α → β\n⊢ Eq (Finset.image f 0) (Singleton.singleton (f 0))","decl":"@[to_additive (attr := simp)]\ntheorem image_one [DecidableEq β] {f : α → β} : image f 1 = {f 1} :=\n  image_singleton _ _\n\n"}
{"name":"Finset.subset_one_iff_eq","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : One α\ns : Finset α\n⊢ Iff (HasSubset.Subset s 1) (Or (Eq s EmptyCollection.emptyCollection) (Eq s 1))","decl":"@[to_additive]\ntheorem subset_one_iff_eq : s ⊆ 1 ↔ s = ∅ ∨ s = 1 :=\n  subset_singleton_iff\n\n"}
{"name":"Finset.subset_zero_iff_eq","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : Zero α\ns : Finset α\n⊢ Iff (HasSubset.Subset s 0) (Or (Eq s EmptyCollection.emptyCollection) (Eq s 0))","decl":"@[to_additive]\ntheorem subset_one_iff_eq : s ⊆ 1 ↔ s = ∅ ∨ s = 1 :=\n  subset_singleton_iff\n\n"}
{"name":"Finset.Nonempty.subset_zero_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : Zero α\ns : Finset α\nh : s.Nonempty\n⊢ Iff (HasSubset.Subset s 0) (Eq s 0)","decl":"@[to_additive]\ntheorem Nonempty.subset_one_iff (h : s.Nonempty) : s ⊆ 1 ↔ s = 1 :=\n  h.subset_singleton_iff\n\n"}
{"name":"Finset.Nonempty.subset_one_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : One α\ns : Finset α\nh : s.Nonempty\n⊢ Iff (HasSubset.Subset s 1) (Eq s 1)","decl":"@[to_additive]\ntheorem Nonempty.subset_one_iff (h : s.Nonempty) : s ⊆ 1 ↔ s = 1 :=\n  h.subset_singleton_iff\n\n"}
{"name":"Finset.card_one","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : One α\n⊢ Eq (Finset.card 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem card_one : (1 : Finset α).card = 1 :=\n  card_singleton _\n\n"}
{"name":"Finset.card_zero","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : Zero α\n⊢ Eq (Finset.card 0) 1","decl":"@[to_additive (attr := simp)]\ntheorem card_one : (1 : Finset α).card = 1 :=\n  card_singleton _\n\n"}
{"name":"Finset.coe_singletonZeroHom","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : Zero α\n⊢ Eq (⇑Finset.singletonZeroHom) Singleton.singleton","decl":"@[to_additive (attr := simp)]\ntheorem coe_singletonOneHom : (singletonOneHom : α → Finset α) = singleton :=\n  rfl\n\n"}
{"name":"Finset.coe_singletonOneHom","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : One α\n⊢ Eq (⇑Finset.singletonOneHom) Singleton.singleton","decl":"@[to_additive (attr := simp)]\ntheorem coe_singletonOneHom : (singletonOneHom : α → Finset α) = singleton :=\n  rfl\n\n"}
{"name":"Finset.singletonOneHom_apply","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : One α\na : α\n⊢ Eq (Finset.singletonOneHom a) (Singleton.singleton a)","decl":"@[to_additive (attr := simp)]\ntheorem singletonOneHom_apply (a : α) : singletonOneHom a = {a} :=\n  rfl\n\n"}
{"name":"Finset.singletonZeroHom_apply","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : Zero α\na : α\n⊢ Eq (Finset.singletonZeroHom a) (Singleton.singleton a)","decl":"@[to_additive (attr := simp)]\ntheorem singletonOneHom_apply (a : α) : singletonOneHom a = {a} :=\n  rfl\n\n"}
{"name":"Finset.imageOneHom_apply","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁴ : One α\ninst✝³ : DecidableEq β\ninst✝² : One β\ninst✝¹ : FunLike F α β\ninst✝ : OneHomClass F α β\nf : F\ns : Finset α\n⊢ Eq ((Finset.imageOneHom f) s) (Finset.image (⇑f) s)","decl":"/-- Lift a `OneHom` to `Finset` via `image`. -/\n@[to_additive (attr := simps) \"Lift a `ZeroHom` to `Finset` via `image`\"]\ndef imageOneHom [DecidableEq β] [One β] [FunLike F α β] [OneHomClass F α β] (f : F) :\n    OneHom (Finset α) (Finset β) where\n  toFun := Finset.image f\n  map_one' := by rw [image_one, map_one, singleton_one]\n\n"}
{"name":"Finset.imageZeroHom_apply","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁴ : Zero α\ninst✝³ : DecidableEq β\ninst✝² : Zero β\ninst✝¹ : FunLike F α β\ninst✝ : ZeroHomClass F α β\nf : F\ns : Finset α\n⊢ Eq ((Finset.imageZeroHom f) s) (Finset.image (⇑f) s)","decl":"/-- Lift a `OneHom` to `Finset` via `image`. -/\n@[to_additive (attr := simps) \"Lift a `ZeroHom` to `Finset` via `image`\"]\ndef imageOneHom [DecidableEq β] [One β] [FunLike F α β] [OneHomClass F α β] (f : F) :\n    OneHom (Finset α) (Finset β) where\n  toFun := Finset.image f\n  map_one' := by rw [image_one, map_one, singleton_one]\n\n"}
{"name":"Finset.sup_zero","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Zero α\ninst✝¹ : SemilatticeSup β\ninst✝ : OrderBot β\nf : α → β\n⊢ Eq (Finset.sup 0 f) (f 0)","decl":"@[to_additive (attr := simp)]\nlemma sup_one [SemilatticeSup β] [OrderBot β] (f : α → β) : sup 1 f = f 1 := sup_singleton\n\n"}
{"name":"Finset.sup_one","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : One α\ninst✝¹ : SemilatticeSup β\ninst✝ : OrderBot β\nf : α → β\n⊢ Eq (Finset.sup 1 f) (f 1)","decl":"@[to_additive (attr := simp)]\nlemma sup_one [SemilatticeSup β] [OrderBot β] (f : α → β) : sup 1 f = f 1 := sup_singleton\n\n"}
{"name":"Finset.sup'_zero","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Zero α\ninst✝ : SemilatticeSup β\nf : α → β\n⊢ Eq (Finset.sup' 0 ⋯ f) (f 0)","decl":"@[to_additive (attr := simp)]\nlemma sup'_one [SemilatticeSup β] (f : α → β) : sup' 1 one_nonempty f = f 1 := rfl\n\n"}
{"name":"Finset.sup'_one","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : One α\ninst✝ : SemilatticeSup β\nf : α → β\n⊢ Eq (Finset.sup' 1 ⋯ f) (f 1)","decl":"@[to_additive (attr := simp)]\nlemma sup'_one [SemilatticeSup β] (f : α → β) : sup' 1 one_nonempty f = f 1 := rfl\n\n"}
{"name":"Finset.inf_one","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : One α\ninst✝¹ : SemilatticeInf β\ninst✝ : OrderTop β\nf : α → β\n⊢ Eq (Finset.inf 1 f) (f 1)","decl":"@[to_additive (attr := simp)]\nlemma inf_one [SemilatticeInf β] [OrderTop β] (f : α → β) : inf 1 f = f 1 := inf_singleton\n\n"}
{"name":"Finset.inf_zero","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Zero α\ninst✝¹ : SemilatticeInf β\ninst✝ : OrderTop β\nf : α → β\n⊢ Eq (Finset.inf 0 f) (f 0)","decl":"@[to_additive (attr := simp)]\nlemma inf_one [SemilatticeInf β] [OrderTop β] (f : α → β) : inf 1 f = f 1 := inf_singleton\n\n"}
{"name":"Finset.inf'_one","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : One α\ninst✝ : SemilatticeInf β\nf : α → β\n⊢ Eq (Finset.inf' 1 ⋯ f) (f 1)","decl":"@[to_additive (attr := simp)]\nlemma inf'_one [SemilatticeInf β] (f : α → β) : inf' 1 one_nonempty f = f 1 := rfl\n\n"}
{"name":"Finset.inf'_zero","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Zero α\ninst✝ : SemilatticeInf β\nf : α → β\n⊢ Eq (Finset.inf' 0 ⋯ f) (f 0)","decl":"@[to_additive (attr := simp)]\nlemma inf'_one [SemilatticeInf β] (f : α → β) : inf' 1 one_nonempty f = f 1 := rfl\n\n"}
{"name":"Finset.max_zero","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Zero α\ninst✝ : LinearOrder α\n⊢ Eq (Finset.max 0) 0","decl":"@[to_additive (attr := simp)]\nlemma max_one [LinearOrder α] : (1 : Finset α).max = 1 := rfl\n\n"}
{"name":"Finset.max_one","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : One α\ninst✝ : LinearOrder α\n⊢ Eq (Finset.max 1) 1","decl":"@[to_additive (attr := simp)]\nlemma max_one [LinearOrder α] : (1 : Finset α).max = 1 := rfl\n\n"}
{"name":"Finset.min_zero","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Zero α\ninst✝ : LinearOrder α\n⊢ Eq (Finset.min 0) 0","decl":"@[to_additive (attr := simp)]\nlemma min_one [LinearOrder α] : (1 : Finset α).min = 1 := rfl\n\n"}
{"name":"Finset.min_one","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : One α\ninst✝ : LinearOrder α\n⊢ Eq (Finset.min 1) 1","decl":"@[to_additive (attr := simp)]\nlemma min_one [LinearOrder α] : (1 : Finset α).min = 1 := rfl\n\n"}
{"name":"Finset.max'_one","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : One α\ninst✝ : LinearOrder α\n⊢ Eq (Finset.max' 1 ⋯) 1","decl":"@[to_additive (attr := simp)]\nlemma max'_one [LinearOrder α] : (1 : Finset α).max' one_nonempty = 1 := rfl\n\n"}
{"name":"Finset.max'_zero","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Zero α\ninst✝ : LinearOrder α\n⊢ Eq (Finset.max' 0 ⋯) 0","decl":"@[to_additive (attr := simp)]\nlemma max'_one [LinearOrder α] : (1 : Finset α).max' one_nonempty = 1 := rfl\n\n"}
{"name":"Finset.min'_zero","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Zero α\ninst✝ : LinearOrder α\n⊢ Eq (Finset.min' 0 ⋯) 0","decl":"@[to_additive (attr := simp)]\nlemma min'_one [LinearOrder α] : (1 : Finset α).min' one_nonempty = 1 := rfl\n\n"}
{"name":"Finset.min'_one","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : One α\ninst✝ : LinearOrder α\n⊢ Eq (Finset.min' 1 ⋯) 1","decl":"@[to_additive (attr := simp)]\nlemma min'_one [LinearOrder α] : (1 : Finset α).min' one_nonempty = 1 := rfl\n\n"}
{"name":"Finset.image_op_one","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : One α\ninst✝ : DecidableEq α\n⊢ Eq (Finset.image MulOpposite.op 1) 1","decl":"@[to_additive (attr := simp)]\nlemma image_op_one [DecidableEq α] : (1 : Finset α).image op = 1 := rfl\n\n"}
{"name":"Finset.image_op_zero","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Zero α\ninst✝ : DecidableEq α\n⊢ Eq (Finset.image AddOpposite.op 0) 0","decl":"@[to_additive (attr := simp)]\nlemma image_op_one [DecidableEq α] : (1 : Finset α).image op = 1 := rfl\n\n"}
{"name":"Finset.map_op_one","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : One α\n⊢ Eq (Finset.map MulOpposite.opEquiv.toEmbedding 1) 1","decl":"@[to_additive (attr := simp)]\nlemma map_op_one : (1 : Finset α).map opEquiv.toEmbedding = 1 := rfl\n\n"}
{"name":"Finset.map_op_zero","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : Zero α\n⊢ Eq (Finset.map AddOpposite.opEquiv.toEmbedding 0) 0","decl":"@[to_additive (attr := simp)]\nlemma map_op_one : (1 : Finset α).map opEquiv.toEmbedding = 1 := rfl\n\n"}
{"name":"Finset.zero_product_zero","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Zero α\ninst✝ : Zero β\n⊢ Eq (SProd.sprod 0 0) 0","decl":"@[to_additive (attr := simp)]\nlemma one_product_one [One β] : (1 ×ˢ 1 : Finset (α × β)) = 1 := by ext; simp [Prod.ext_iff]\n\n"}
{"name":"Finset.one_product_one","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : One α\ninst✝ : One β\n⊢ Eq (SProd.sprod 1 1) 1","decl":"@[to_additive (attr := simp)]\nlemma one_product_one [One β] : (1 ×ˢ 1 : Finset (α × β)) = 1 := by ext; simp [Prod.ext_iff]\n\n"}
{"name":"Finset.inv_def","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Inv α\ns : Finset α\n⊢ Eq (Inv.inv s) (Finset.image (fun x => Inv.inv x) s)","decl":"@[to_additive]\ntheorem inv_def : s⁻¹ = s.image fun x => x⁻¹ :=\n  rfl\n\n"}
{"name":"Finset.neg_def","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Neg α\ns : Finset α\n⊢ Eq (Neg.neg s) (Finset.image (fun x => Neg.neg x) s)","decl":"@[to_additive]\ntheorem inv_def : s⁻¹ = s.image fun x => x⁻¹ :=\n  rfl\n\n"}
{"name":"Finset.image_neg_eq_neg","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Neg α\ns : Finset α\n⊢ Eq (Finset.image (fun x => Neg.neg x) s) (Neg.neg s)","decl":"@[to_additive] lemma image_inv_eq_inv (s : Finset α) : s.image (·⁻¹) = s⁻¹ := rfl\n\n"}
{"name":"Finset.image_inv_eq_inv","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Inv α\ns : Finset α\n⊢ Eq (Finset.image (fun x => Inv.inv x) s) (Inv.inv s)","decl":"@[to_additive] lemma image_inv_eq_inv (s : Finset α) : s.image (·⁻¹) = s⁻¹ := rfl\n\n"}
{"name":"Finset.mem_neg","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Neg α\ns : Finset α\nx : α\n⊢ Iff (Membership.mem (Neg.neg s) x) (Exists fun y => And (Membership.mem s y) (Eq (Neg.neg y) x))","decl":"@[to_additive]\ntheorem mem_inv {x : α} : x ∈ s⁻¹ ↔ ∃ y ∈ s, y⁻¹ = x :=\n  mem_image\n\n"}
{"name":"Finset.mem_inv","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Inv α\ns : Finset α\nx : α\n⊢ Iff (Membership.mem (Inv.inv s) x) (Exists fun y => And (Membership.mem s y) (Eq (Inv.inv y) x))","decl":"@[to_additive]\ntheorem mem_inv {x : α} : x ∈ s⁻¹ ↔ ∃ y ∈ s, y⁻¹ = x :=\n  mem_image\n\n"}
{"name":"Finset.neg_mem_neg","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Neg α\ns : Finset α\na : α\nha : Membership.mem s a\n⊢ Membership.mem (Neg.neg s) (Neg.neg a)","decl":"@[to_additive]\ntheorem inv_mem_inv (ha : a ∈ s) : a⁻¹ ∈ s⁻¹ :=\n  mem_image_of_mem _ ha\n\n"}
{"name":"Finset.inv_mem_inv","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Inv α\ns : Finset α\na : α\nha : Membership.mem s a\n⊢ Membership.mem (Inv.inv s) (Inv.inv a)","decl":"@[to_additive]\ntheorem inv_mem_inv (ha : a ∈ s) : a⁻¹ ∈ s⁻¹ :=\n  mem_image_of_mem _ ha\n\n"}
{"name":"Finset.card_inv_le","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Inv α\ns : Finset α\n⊢ LE.le (Inv.inv s).card s.card","decl":"@[to_additive]\ntheorem card_inv_le : s⁻¹.card ≤ s.card :=\n  card_image_le\n\n"}
{"name":"Finset.card_neg_le","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Neg α\ns : Finset α\n⊢ LE.le (Neg.neg s).card s.card","decl":"@[to_additive]\ntheorem card_inv_le : s⁻¹.card ≤ s.card :=\n  card_image_le\n\n"}
{"name":"Finset.inv_empty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Inv α\n⊢ Eq (Inv.inv EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)]\ntheorem inv_empty : (∅ : Finset α)⁻¹ = ∅ :=\n  image_empty _\n\n"}
{"name":"Finset.neg_empty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Neg α\n⊢ Eq (Neg.neg EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)]\ntheorem inv_empty : (∅ : Finset α)⁻¹ = ∅ :=\n  image_empty _\n\n"}
{"name":"Finset.neg_nonempty_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Neg α\ns : Finset α\n⊢ Iff (Neg.neg s).Nonempty s.Nonempty","decl":"@[to_additive (attr := simp)]\ntheorem inv_nonempty_iff : s⁻¹.Nonempty ↔ s.Nonempty := image_nonempty\n\n"}
{"name":"Finset.inv_nonempty_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Inv α\ns : Finset α\n⊢ Iff (Inv.inv s).Nonempty s.Nonempty","decl":"@[to_additive (attr := simp)]\ntheorem inv_nonempty_iff : s⁻¹.Nonempty ↔ s.Nonempty := image_nonempty\n\n"}
{"name":"Finset.Nonempty.inv","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Inv α\ns : Finset α\na✝ : s.Nonempty\n⊢ (Inv.inv s).Nonempty","decl":"alias ⟨Nonempty.of_inv, Nonempty.inv⟩ := inv_nonempty_iff\n\n"}
{"name":"Finset.Nonempty.of_inv","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Inv α\ns : Finset α\na✝ : (Inv.inv s).Nonempty\n⊢ s.Nonempty","decl":"alias ⟨Nonempty.of_inv, Nonempty.inv⟩ := inv_nonempty_iff\n\n"}
{"name":"Finset.Nonempty.of_neg","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Neg α\ns : Finset α\na✝ : (Neg.neg s).Nonempty\n⊢ s.Nonempty","decl":"attribute [to_additive] Nonempty.inv Nonempty.of_inv\n"}
{"name":"Finset.Nonempty.neg","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Neg α\ns : Finset α\na✝ : s.Nonempty\n⊢ (Neg.neg s).Nonempty","decl":"attribute [to_additive] Nonempty.inv Nonempty.of_inv\n"}
{"name":"Finset.neg_eq_empty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Neg α\ns : Finset α\n⊢ Iff (Eq (Neg.neg s) EmptyCollection.emptyCollection) (Eq s EmptyCollection.emptyCollection)","decl":"@[to_additive (attr := simp)]\ntheorem inv_eq_empty : s⁻¹ = ∅ ↔ s = ∅ := image_eq_empty\n\n"}
{"name":"Finset.inv_eq_empty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Inv α\ns : Finset α\n⊢ Iff (Eq (Inv.inv s) EmptyCollection.emptyCollection) (Eq s EmptyCollection.emptyCollection)","decl":"@[to_additive (attr := simp)]\ntheorem inv_eq_empty : s⁻¹ = ∅ ↔ s = ∅ := image_eq_empty\n\n"}
{"name":"Finset.inv_subset_inv","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Inv α\ns t : Finset α\nh : HasSubset.Subset s t\n⊢ HasSubset.Subset (Inv.inv s) (Inv.inv t)","decl":"@[to_additive (attr := mono, gcongr)]\ntheorem inv_subset_inv (h : s ⊆ t) : s⁻¹ ⊆ t⁻¹ :=\n  image_subset_image h\n\n"}
{"name":"Finset.neg_subset_neg","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Neg α\ns t : Finset α\nh : HasSubset.Subset s t\n⊢ HasSubset.Subset (Neg.neg s) (Neg.neg t)","decl":"@[to_additive (attr := mono, gcongr)]\ntheorem inv_subset_inv (h : s ⊆ t) : s⁻¹ ⊆ t⁻¹ :=\n  image_subset_image h\n\n"}
{"name":"Finset.neg_singleton","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Neg α\na : α\n⊢ Eq (Neg.neg (Singleton.singleton a)) (Singleton.singleton (Neg.neg a))","decl":"@[to_additive (attr := simp)]\ntheorem inv_singleton (a : α) : ({a} : Finset α)⁻¹ = {a⁻¹} :=\n  image_singleton _ _\n\n"}
{"name":"Finset.inv_singleton","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Inv α\na : α\n⊢ Eq (Inv.inv (Singleton.singleton a)) (Singleton.singleton (Inv.inv a))","decl":"@[to_additive (attr := simp)]\ntheorem inv_singleton (a : α) : ({a} : Finset α)⁻¹ = {a⁻¹} :=\n  image_singleton _ _\n\n"}
{"name":"Finset.inv_insert","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Inv α\na : α\ns : Finset α\n⊢ Eq (Inv.inv (Insert.insert a s)) (Insert.insert (Inv.inv a) (Inv.inv s))","decl":"@[to_additive (attr := simp)]\ntheorem inv_insert (a : α) (s : Finset α) : (insert a s)⁻¹ = insert a⁻¹ s⁻¹ :=\n  image_insert _ _ _\n\n"}
{"name":"Finset.neg_insert","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Neg α\na : α\ns : Finset α\n⊢ Eq (Neg.neg (Insert.insert a s)) (Insert.insert (Neg.neg a) (Neg.neg s))","decl":"@[to_additive (attr := simp)]\ntheorem inv_insert (a : α) (s : Finset α) : (insert a s)⁻¹ = insert a⁻¹ s⁻¹ :=\n  image_insert _ _ _\n\n"}
{"name":"Finset.sup_neg","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq α\ninst✝² : Neg α\ninst✝¹ : SemilatticeSup β\ninst✝ : OrderBot β\ns : Finset α\nf : α → β\n⊢ Eq ((Neg.neg s).sup f) (s.sup fun x => f (Neg.neg x))","decl":"@[to_additive (attr := simp)]\nlemma sup_inv [SemilatticeSup β] [OrderBot β] (s : Finset α) (f : α → β) :\n    sup s⁻¹ f = sup s (f ·⁻¹) :=\n  sup_image ..\n\n"}
{"name":"Finset.sup_inv","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq α\ninst✝² : Inv α\ninst✝¹ : SemilatticeSup β\ninst✝ : OrderBot β\ns : Finset α\nf : α → β\n⊢ Eq ((Inv.inv s).sup f) (s.sup fun x => f (Inv.inv x))","decl":"@[to_additive (attr := simp)]\nlemma sup_inv [SemilatticeSup β] [OrderBot β] (s : Finset α) (f : α → β) :\n    sup s⁻¹ f = sup s (f ·⁻¹) :=\n  sup_image ..\n\n"}
{"name":"Finset.sup'_neg","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq α\ninst✝¹ : Neg α\ninst✝ : SemilatticeSup β\ns : Finset α\nhs : (Neg.neg s).Nonempty\nf : α → β\n⊢ Eq ((Neg.neg s).sup' hs f) (s.sup' ⋯ fun x => f (Neg.neg x))","decl":"@[to_additive (attr := simp)]\nlemma sup'_inv [SemilatticeSup β] {s : Finset α} (hs : s⁻¹.Nonempty) (f : α → β) :\n    sup' s⁻¹ hs f = sup' s hs.of_inv (f ·⁻¹) :=\n  sup'_image ..\n\n"}
{"name":"Finset.sup'_inv","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq α\ninst✝¹ : Inv α\ninst✝ : SemilatticeSup β\ns : Finset α\nhs : (Inv.inv s).Nonempty\nf : α → β\n⊢ Eq ((Inv.inv s).sup' hs f) (s.sup' ⋯ fun x => f (Inv.inv x))","decl":"@[to_additive (attr := simp)]\nlemma sup'_inv [SemilatticeSup β] {s : Finset α} (hs : s⁻¹.Nonempty) (f : α → β) :\n    sup' s⁻¹ hs f = sup' s hs.of_inv (f ·⁻¹) :=\n  sup'_image ..\n\n"}
{"name":"Finset.inf_neg","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq α\ninst✝² : Neg α\ninst✝¹ : SemilatticeInf β\ninst✝ : OrderTop β\ns : Finset α\nf : α → β\n⊢ Eq ((Neg.neg s).inf f) (s.inf fun x => f (Neg.neg x))","decl":"@[to_additive (attr := simp)]\nlemma inf_inv [SemilatticeInf β] [OrderTop β] (s : Finset α) (f : α → β) :\n    inf s⁻¹ f = inf s (f ·⁻¹) :=\n  inf_image ..\n\n"}
{"name":"Finset.inf_inv","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq α\ninst✝² : Inv α\ninst✝¹ : SemilatticeInf β\ninst✝ : OrderTop β\ns : Finset α\nf : α → β\n⊢ Eq ((Inv.inv s).inf f) (s.inf fun x => f (Inv.inv x))","decl":"@[to_additive (attr := simp)]\nlemma inf_inv [SemilatticeInf β] [OrderTop β] (s : Finset α) (f : α → β) :\n    inf s⁻¹ f = inf s (f ·⁻¹) :=\n  inf_image ..\n\n"}
{"name":"Finset.inf'_neg","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq α\ninst✝¹ : Neg α\ninst✝ : SemilatticeInf β\ns : Finset α\nhs : (Neg.neg s).Nonempty\nf : α → β\n⊢ Eq ((Neg.neg s).inf' hs f) (s.inf' ⋯ fun x => f (Neg.neg x))","decl":"@[to_additive (attr := simp)]\nlemma inf'_inv [SemilatticeInf β] {s : Finset α} (hs : s⁻¹.Nonempty) (f : α → β) :\n    inf' s⁻¹ hs f = inf' s hs.of_inv (f ·⁻¹) :=\n  inf'_image ..\n\n"}
{"name":"Finset.inf'_inv","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq α\ninst✝¹ : Inv α\ninst✝ : SemilatticeInf β\ns : Finset α\nhs : (Inv.inv s).Nonempty\nf : α → β\n⊢ Eq ((Inv.inv s).inf' hs f) (s.inf' ⋯ fun x => f (Inv.inv x))","decl":"@[to_additive (attr := simp)]\nlemma inf'_inv [SemilatticeInf β] {s : Finset α} (hs : s⁻¹.Nonempty) (f : α → β) :\n    inf' s⁻¹ hs f = inf' s hs.of_inv (f ·⁻¹) :=\n  inf'_image ..\n\n"}
{"name":"Finset.image_op_neg","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Neg α\ns : Finset α\n⊢ Eq (Finset.image AddOpposite.op (Neg.neg s)) (Neg.neg (Finset.image AddOpposite.op s))","decl":"@[to_additive] lemma image_op_inv (s : Finset α) : s⁻¹.image op = (s.image op)⁻¹ :=\n  image_comm op_inv\n\n"}
{"name":"Finset.image_op_inv","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Inv α\ns : Finset α\n⊢ Eq (Finset.image MulOpposite.op (Inv.inv s)) (Inv.inv (Finset.image MulOpposite.op s))","decl":"@[to_additive] lemma image_op_inv (s : Finset α) : s⁻¹.image op = (s.image op)⁻¹ :=\n  image_comm op_inv\n\n"}
{"name":"Finset.map_op_inv","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Inv α\ns : Finset α\n⊢ Eq (Finset.map MulOpposite.opEquiv.toEmbedding (Inv.inv s)) (Inv.inv (Finset.map MulOpposite.opEquiv.toEmbedding s))","decl":"@[to_additive]\nlemma map_op_inv (s : Finset α) : s⁻¹.map opEquiv.toEmbedding = (s.map opEquiv.toEmbedding)⁻¹ := by\n  simp [map_eq_image, image_op_inv]\n\n"}
{"name":"Finset.map_op_neg","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Neg α\ns : Finset α\n⊢ Eq (Finset.map AddOpposite.opEquiv.toEmbedding (Neg.neg s)) (Neg.neg (Finset.map AddOpposite.opEquiv.toEmbedding s))","decl":"@[to_additive]\nlemma map_op_inv (s : Finset α) : s⁻¹.map opEquiv.toEmbedding = (s.map opEquiv.toEmbedding)⁻¹ := by\n  simp [map_eq_image, image_op_inv]\n\n"}
{"name":"Finset.mem_neg'","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : InvolutiveNeg α\ns : Finset α\na : α\n⊢ Iff (Membership.mem (Neg.neg s) a) (Membership.mem s (Neg.neg a))","decl":"@[to_additive (attr := simp)]\nlemma mem_inv' : a ∈ s⁻¹ ↔ a⁻¹ ∈ s := by simp [mem_inv, inv_eq_iff_eq_inv]\n\n"}
{"name":"Finset.mem_inv'","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : InvolutiveInv α\ns : Finset α\na : α\n⊢ Iff (Membership.mem (Inv.inv s) a) (Membership.mem s (Inv.inv a))","decl":"@[to_additive (attr := simp)]\nlemma mem_inv' : a ∈ s⁻¹ ↔ a⁻¹ ∈ s := by simp [mem_inv, inv_eq_iff_eq_inv]\n\n"}
{"name":"Finset.coe_neg","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : InvolutiveNeg α\ns : Finset α\n⊢ Eq (↑(Neg.neg s)) (Neg.neg ↑s)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_inv (s : Finset α) : ↑s⁻¹ = (s : Set α)⁻¹ := coe_image.trans Set.image_inv_eq_inv\n\n"}
{"name":"Finset.coe_inv","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : InvolutiveInv α\ns : Finset α\n⊢ Eq (↑(Inv.inv s)) (Inv.inv ↑s)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_inv (s : Finset α) : ↑s⁻¹ = (s : Set α)⁻¹ := coe_image.trans Set.image_inv_eq_inv\n\n"}
{"name":"Finset.card_inv","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : InvolutiveInv α\ns : Finset α\n⊢ Eq (Inv.inv s).card s.card","decl":"@[to_additive (attr := simp)]\ntheorem card_inv (s : Finset α) : s⁻¹.card = s.card := card_image_of_injective _ inv_injective\n\n"}
{"name":"Finset.card_neg","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : InvolutiveNeg α\ns : Finset α\n⊢ Eq (Neg.neg s).card s.card","decl":"@[to_additive (attr := simp)]\ntheorem card_inv (s : Finset α) : s⁻¹.card = s.card := card_image_of_injective _ inv_injective\n\n"}
{"name":"Finset.dens_neg","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : InvolutiveNeg α\ninst✝ : Fintype α\ns : Finset α\n⊢ Eq (Neg.neg s).dens s.dens","decl":"@[to_additive (attr := simp)]\nlemma dens_inv [Fintype α] (s : Finset α) : s⁻¹.dens = s.dens := by simp [dens]\n\n"}
{"name":"Finset.dens_inv","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : InvolutiveInv α\ninst✝ : Fintype α\ns : Finset α\n⊢ Eq (Inv.inv s).dens s.dens","decl":"@[to_additive (attr := simp)]\nlemma dens_inv [Fintype α] (s : Finset α) : s⁻¹.dens = s.dens := by simp [dens]\n\n"}
{"name":"Finset.preimage_neg","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : InvolutiveNeg α\ns : Finset α\n⊢ Eq (s.preimage (fun x => Neg.neg x) ⋯) (Neg.neg s)","decl":"@[to_additive (attr := simp)]\ntheorem preimage_inv (s : Finset α) : s.preimage (·⁻¹) inv_injective.injOn = s⁻¹ :=\n  coe_injective <| by rw [coe_preimage, Set.inv_preimage, coe_inv]\n\n"}
{"name":"Finset.preimage_inv","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : InvolutiveInv α\ns : Finset α\n⊢ Eq (s.preimage (fun x => Inv.inv x) ⋯) (Inv.inv s)","decl":"@[to_additive (attr := simp)]\ntheorem preimage_inv (s : Finset α) : s.preimage (·⁻¹) inv_injective.injOn = s⁻¹ :=\n  coe_injective <| by rw [coe_preimage, Set.inv_preimage, coe_inv]\n\n"}
{"name":"Finset.neg_univ","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : InvolutiveNeg α\ninst✝ : Fintype α\n⊢ Eq (Neg.neg Finset.univ) Finset.univ","decl":"@[to_additive (attr := simp)]\nlemma inv_univ [Fintype α] : (univ : Finset α)⁻¹ = univ := by ext; simp\n\n"}
{"name":"Finset.inv_univ","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : InvolutiveInv α\ninst✝ : Fintype α\n⊢ Eq (Inv.inv Finset.univ) Finset.univ","decl":"@[to_additive (attr := simp)]\nlemma inv_univ [Fintype α] : (univ : Finset α)⁻¹ = univ := by ext; simp\n\n"}
{"name":"Finset.neg_inter","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : InvolutiveNeg α\ns t : Finset α\n⊢ Eq (Neg.neg (Inter.inter s t)) (Inter.inter (Neg.neg s) (Neg.neg t))","decl":"@[to_additive (attr := simp)]\nlemma inv_inter (s t : Finset α) : (s ∩ t)⁻¹ = s⁻¹ ∩ t⁻¹ := coe_injective <| by simp\n\n"}
{"name":"Finset.inv_inter","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : InvolutiveInv α\ns t : Finset α\n⊢ Eq (Inv.inv (Inter.inter s t)) (Inter.inter (Inv.inv s) (Inv.inv t))","decl":"@[to_additive (attr := simp)]\nlemma inv_inter (s t : Finset α) : (s ∩ t)⁻¹ = s⁻¹ ∩ t⁻¹ := coe_injective <| by simp\n\n"}
{"name":"Finset.inv_product","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq α\ninst✝² : InvolutiveInv α\ninst✝¹ : DecidableEq β\ninst✝ : InvolutiveInv β\ns : Finset α\nt : Finset β\n⊢ Eq (Inv.inv (SProd.sprod s t)) (SProd.sprod (Inv.inv s) (Inv.inv t))","decl":"@[to_additive (attr := simp)]\nlemma inv_product [DecidableEq β] [InvolutiveInv β] (s : Finset α) (t : Finset β) :\n    (s ×ˢ t)⁻¹ = s⁻¹ ×ˢ t⁻¹ := mod_cast s.toSet.inv_prod t.toSet\n\n"}
{"name":"Finset.neg_product","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq α\ninst✝² : InvolutiveNeg α\ninst✝¹ : DecidableEq β\ninst✝ : InvolutiveNeg β\ns : Finset α\nt : Finset β\n⊢ Eq (Neg.neg (SProd.sprod s t)) (SProd.sprod (Neg.neg s) (Neg.neg t))","decl":"@[to_additive (attr := simp)]\nlemma inv_product [DecidableEq β] [InvolutiveInv β] (s : Finset α) (t : Finset β) :\n    (s ×ˢ t)⁻¹ = s⁻¹ ×ˢ t⁻¹ := mod_cast s.toSet.inv_prod t.toSet\n\n"}
{"name":"Finset.vadd_def","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\ns : Finset α\nt : Finset β\n⊢ Eq (HVAdd.hVAdd s t) (Finset.image (fun p => HVAdd.hVAdd p.1 p.2) (SProd.sprod s t))","decl":"@[to_additive] lemma smul_def : s • t = (s ×ˢ t).image fun p : α × β => p.1 • p.2 := rfl\n\n"}
{"name":"Finset.smul_def","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\ns : Finset α\nt : Finset β\n⊢ Eq (HSMul.hSMul s t) (Finset.image (fun p => HSMul.hSMul p.1 p.2) (SProd.sprod s t))","decl":"@[to_additive] lemma smul_def : s • t = (s ×ˢ t).image fun p : α × β => p.1 • p.2 := rfl\n\n"}
{"name":"Finset.image_smul_product","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\ns : Finset α\nt : Finset β\n⊢ Eq (Finset.image (fun x => HSMul.hSMul x.1 x.2) (SProd.sprod s t)) (HSMul.hSMul s t)","decl":"@[to_additive]\nlemma image_smul_product : ((s ×ˢ t).image fun x : α × β => x.fst • x.snd) = s • t := rfl\n\n"}
{"name":"Finset.image_vadd_product","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\ns : Finset α\nt : Finset β\n⊢ Eq (Finset.image (fun x => HVAdd.hVAdd x.1 x.2) (SProd.sprod s t)) (HVAdd.hVAdd s t)","decl":"@[to_additive]\nlemma image_smul_product : ((s ×ˢ t).image fun x : α × β => x.fst • x.snd) = s • t := rfl\n\n"}
{"name":"Finset.mem_smul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\ns : Finset α\nt : Finset β\nx : β\n⊢ Iff (Membership.mem (HSMul.hSMul s t) x) (Exists fun y => And (Membership.mem s y) (Exists fun z => And (Membership.mem t z) (Eq (HSMul.hSMul y z) x)))","decl":"@[to_additive] lemma mem_smul {x : β} : x ∈ s • t ↔ ∃ y ∈ s, ∃ z ∈ t, y • z = x := mem_image₂\n\n"}
{"name":"Finset.mem_vadd","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\ns : Finset α\nt : Finset β\nx : β\n⊢ Iff (Membership.mem (HVAdd.hVAdd s t) x) (Exists fun y => And (Membership.mem s y) (Exists fun z => And (Membership.mem t z) (Eq (HVAdd.hVAdd y z) x)))","decl":"@[to_additive] lemma mem_smul {x : β} : x ∈ s • t ↔ ∃ y ∈ s, ∃ z ∈ t, y • z = x := mem_image₂\n\n"}
{"name":"Finset.coe_smul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\ns : Finset α\nt : Finset β\n⊢ Eq (↑(HSMul.hSMul s t)) (HSMul.hSMul ↑s ↑t)","decl":"@[to_additive (attr := simp, norm_cast)]\nlemma coe_smul (s : Finset α) (t : Finset β) : ↑(s • t) = (s : Set α) • (t : Set β) := coe_image₂ ..\n\n"}
{"name":"Finset.coe_vadd","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\ns : Finset α\nt : Finset β\n⊢ Eq (↑(HVAdd.hVAdd s t)) (HVAdd.hVAdd ↑s ↑t)","decl":"@[to_additive (attr := simp, norm_cast)]\nlemma coe_smul (s : Finset α) (t : Finset β) : ↑(s • t) = (s : Set α) • (t : Set β) := coe_image₂ ..\n\n"}
{"name":"Finset.vadd_mem_vadd","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\ns : Finset α\nt : Finset β\na : α\nb : β\na✝¹ : Membership.mem s a\na✝ : Membership.mem t b\n⊢ Membership.mem (HVAdd.hVAdd s t) (HVAdd.hVAdd a b)","decl":"@[to_additive] lemma smul_mem_smul : a ∈ s → b ∈ t → a • b ∈ s • t := mem_image₂_of_mem\n\n"}
{"name":"Finset.smul_mem_smul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\ns : Finset α\nt : Finset β\na : α\nb : β\na✝¹ : Membership.mem s a\na✝ : Membership.mem t b\n⊢ Membership.mem (HSMul.hSMul s t) (HSMul.hSMul a b)","decl":"@[to_additive] lemma smul_mem_smul : a ∈ s → b ∈ t → a • b ∈ s • t := mem_image₂_of_mem\n\n"}
{"name":"Finset.card_vadd_le","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\ns : Finset α\nt : Finset β\n⊢ LE.le (HVAdd.hVAdd s t).card (HMul.hMul s.card t.card)","decl":"@[to_additive] lemma card_smul_le : #(s • t) ≤ #s * #t := card_image₂_le ..\n\n"}
{"name":"Finset.card_smul_le","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\ns : Finset α\nt : Finset β\n⊢ LE.le (HSMul.hSMul s t).card (HMul.hMul s.card t.card)","decl":"@[to_additive] lemma card_smul_le : #(s • t) ≤ #s * #t := card_image₂_le ..\n\n"}
{"name":"Finset.smul_card_le","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\ns : Finset α\nt : Finset β\n⊢ LE.le (HSMul.hSMul s t).card (HMul.hMul s.card t.card)","decl":"@[deprecated (since := \"2024-11-19\")] alias smul_card_le := card_smul_le\n"}
{"name":"Finset.vadd_card_le","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\ns : Finset α\nt : Finset β\n⊢ LE.le (HVAdd.hVAdd s t).card (HMul.hMul s.card t.card)","decl":"@[deprecated (since := \"2024-11-19\")] alias vadd_card_le := card_vadd_le\n\n"}
{"name":"Finset.empty_vadd","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\nt : Finset β\n⊢ Eq (HVAdd.hVAdd EmptyCollection.emptyCollection t) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)]\nlemma empty_smul (t : Finset β) : (∅ : Finset α) • t = ∅ := image₂_empty_left\n\n"}
{"name":"Finset.empty_smul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\nt : Finset β\n⊢ Eq (HSMul.hSMul EmptyCollection.emptyCollection t) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)]\nlemma empty_smul (t : Finset β) : (∅ : Finset α) • t = ∅ := image₂_empty_left\n\n"}
{"name":"Finset.vadd_empty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\ns : Finset α\n⊢ Eq (HVAdd.hVAdd s EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)]\nlemma smul_empty (s : Finset α) : s • (∅ : Finset β) = ∅ := image₂_empty_right\n\n"}
{"name":"Finset.smul_empty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\ns : Finset α\n⊢ Eq (HSMul.hSMul s EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)]\nlemma smul_empty (s : Finset α) : s • (∅ : Finset β) = ∅ := image₂_empty_right\n\n"}
{"name":"Finset.smul_eq_empty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\ns : Finset α\nt : Finset β\n⊢ Iff (Eq (HSMul.hSMul s t) EmptyCollection.emptyCollection) (Or (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection))","decl":"@[to_additive (attr := simp)]\nlemma smul_eq_empty : s • t = ∅ ↔ s = ∅ ∨ t = ∅ := image₂_eq_empty_iff\n\n"}
{"name":"Finset.vadd_eq_empty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\ns : Finset α\nt : Finset β\n⊢ Iff (Eq (HVAdd.hVAdd s t) EmptyCollection.emptyCollection) (Or (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection))","decl":"@[to_additive (attr := simp)]\nlemma smul_eq_empty : s • t = ∅ ↔ s = ∅ ∨ t = ∅ := image₂_eq_empty_iff\n\n"}
{"name":"Finset.smul_nonempty_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\ns : Finset α\nt : Finset β\n⊢ Iff (HSMul.hSMul s t).Nonempty (And s.Nonempty t.Nonempty)","decl":"@[to_additive (attr := simp)]\nlemma smul_nonempty_iff : (s • t).Nonempty ↔ s.Nonempty ∧ t.Nonempty := image₂_nonempty_iff\n\n"}
{"name":"Finset.vadd_nonempty_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\ns : Finset α\nt : Finset β\n⊢ Iff (HVAdd.hVAdd s t).Nonempty (And s.Nonempty t.Nonempty)","decl":"@[to_additive (attr := simp)]\nlemma smul_nonempty_iff : (s • t).Nonempty ↔ s.Nonempty ∧ t.Nonempty := image₂_nonempty_iff\n\n"}
{"name":"Finset.Nonempty.smul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\ns : Finset α\nt : Finset β\na✝¹ : s.Nonempty\na✝ : t.Nonempty\n⊢ (HSMul.hSMul s t).Nonempty","decl":"@[to_additive (attr := aesop safe apply (rule_sets := [finsetNonempty]))]\nlemma Nonempty.smul : s.Nonempty → t.Nonempty → (s • t).Nonempty := .image₂\n\n"}
{"name":"Finset.Nonempty.vadd","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\ns : Finset α\nt : Finset β\na✝¹ : s.Nonempty\na✝ : t.Nonempty\n⊢ (HVAdd.hVAdd s t).Nonempty","decl":"@[to_additive (attr := aesop safe apply (rule_sets := [finsetNonempty]))]\nlemma Nonempty.smul : s.Nonempty → t.Nonempty → (s • t).Nonempty := .image₂\n\n"}
{"name":"Finset.Nonempty.of_smul_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\ns : Finset α\nt : Finset β\na✝ : (HSMul.hSMul s t).Nonempty\n⊢ s.Nonempty","decl":"@[to_additive] lemma Nonempty.of_smul_left : (s • t).Nonempty → s.Nonempty := .of_image₂_left\n"}
{"name":"Finset.Nonempty.of_vadd_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\ns : Finset α\nt : Finset β\na✝ : (HVAdd.hVAdd s t).Nonempty\n⊢ s.Nonempty","decl":"@[to_additive] lemma Nonempty.of_smul_left : (s • t).Nonempty → s.Nonempty := .of_image₂_left\n"}
{"name":"Finset.Nonempty.of_smul_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\ns : Finset α\nt : Finset β\na✝ : (HSMul.hSMul s t).Nonempty\n⊢ t.Nonempty","decl":"@[to_additive] lemma Nonempty.of_smul_right : (s • t).Nonempty → t.Nonempty := .of_image₂_right\n\n"}
{"name":"Finset.Nonempty.of_vadd_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\ns : Finset α\nt : Finset β\na✝ : (HVAdd.hVAdd s t).Nonempty\n⊢ t.Nonempty","decl":"@[to_additive] lemma Nonempty.of_smul_right : (s • t).Nonempty → t.Nonempty := .of_image₂_right\n\n"}
{"name":"Finset.smul_singleton","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\ns : Finset α\nb : β\n⊢ Eq (HSMul.hSMul s (Singleton.singleton b)) (Finset.image (fun x => HSMul.hSMul x b) s)","decl":"@[to_additive]\nlemma smul_singleton (b : β) : s • ({b} : Finset β) = s.image (· • b) := image₂_singleton_right\n\n"}
{"name":"Finset.vadd_singleton","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\ns : Finset α\nb : β\n⊢ Eq (HVAdd.hVAdd s (Singleton.singleton b)) (Finset.image (fun x => HVAdd.hVAdd x b) s)","decl":"@[to_additive]\nlemma smul_singleton (b : β) : s • ({b} : Finset β) = s.image (· • b) := image₂_singleton_right\n\n"}
{"name":"Finset.singleton_vadd_singleton","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\na : α\nb : β\n⊢ Eq (HVAdd.hVAdd (Singleton.singleton a) (Singleton.singleton b)) (Singleton.singleton (HVAdd.hVAdd a b))","decl":"@[to_additive]\nlemma singleton_smul_singleton (a : α) (b : β) : ({a} : Finset α) • ({b} : Finset β) = {a • b} :=\n  image₂_singleton\n\n"}
{"name":"Finset.singleton_smul_singleton","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\na : α\nb : β\n⊢ Eq (HSMul.hSMul (Singleton.singleton a) (Singleton.singleton b)) (Singleton.singleton (HSMul.hSMul a b))","decl":"@[to_additive]\nlemma singleton_smul_singleton (a : α) (b : β) : ({a} : Finset α) • ({b} : Finset β) = {a • b} :=\n  image₂_singleton\n\n"}
{"name":"Finset.smul_subset_smul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\ns₁ s₂ : Finset α\nt₁ t₂ : Finset β\na✝¹ : HasSubset.Subset s₁ s₂\na✝ : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (HSMul.hSMul s₁ t₁) (HSMul.hSMul s₂ t₂)","decl":"@[to_additive (attr := mono, gcongr)]\nlemma smul_subset_smul : s₁ ⊆ s₂ → t₁ ⊆ t₂ → s₁ • t₁ ⊆ s₂ • t₂ := image₂_subset\n\n"}
{"name":"Finset.vadd_subset_vadd","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\ns₁ s₂ : Finset α\nt₁ t₂ : Finset β\na✝¹ : HasSubset.Subset s₁ s₂\na✝ : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (HVAdd.hVAdd s₁ t₁) (HVAdd.hVAdd s₂ t₂)","decl":"@[to_additive (attr := mono, gcongr)]\nlemma smul_subset_smul : s₁ ⊆ s₂ → t₁ ⊆ t₂ → s₁ • t₁ ⊆ s₂ • t₂ := image₂_subset\n\n"}
{"name":"Finset.smul_subset_smul_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\ns : Finset α\nt₁ t₂ : Finset β\na✝ : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (HSMul.hSMul s t₁) (HSMul.hSMul s t₂)","decl":"@[to_additive] lemma smul_subset_smul_left : t₁ ⊆ t₂ → s • t₁ ⊆ s • t₂ := image₂_subset_left\n"}
{"name":"Finset.vadd_subset_vadd_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\ns : Finset α\nt₁ t₂ : Finset β\na✝ : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (HVAdd.hVAdd s t₁) (HVAdd.hVAdd s t₂)","decl":"@[to_additive] lemma smul_subset_smul_left : t₁ ⊆ t₂ → s • t₁ ⊆ s • t₂ := image₂_subset_left\n"}
{"name":"Finset.smul_subset_smul_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\ns₁ s₂ : Finset α\nt : Finset β\na✝ : HasSubset.Subset s₁ s₂\n⊢ HasSubset.Subset (HSMul.hSMul s₁ t) (HSMul.hSMul s₂ t)","decl":"@[to_additive] lemma smul_subset_smul_right : s₁ ⊆ s₂ → s₁ • t ⊆ s₂ • t := image₂_subset_right\n"}
{"name":"Finset.vadd_subset_vadd_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\ns₁ s₂ : Finset α\nt : Finset β\na✝ : HasSubset.Subset s₁ s₂\n⊢ HasSubset.Subset (HVAdd.hVAdd s₁ t) (HVAdd.hVAdd s₂ t)","decl":"@[to_additive] lemma smul_subset_smul_right : s₁ ⊆ s₂ → s₁ • t ⊆ s₂ • t := image₂_subset_right\n"}
{"name":"Finset.vadd_subset_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\ns : Finset α\nt u : Finset β\n⊢ Iff (HasSubset.Subset (HVAdd.hVAdd s t) u) (∀ (a : α), Membership.mem s a → ∀ (b : β), Membership.mem t b → Membership.mem u (HVAdd.hVAdd a b))","decl":"@[to_additive] lemma smul_subset_iff : s • t ⊆ u ↔ ∀ a ∈ s, ∀ b ∈ t, a • b ∈ u := image₂_subset_iff\n\n"}
{"name":"Finset.smul_subset_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\ns : Finset α\nt u : Finset β\n⊢ Iff (HasSubset.Subset (HSMul.hSMul s t) u) (∀ (a : α), Membership.mem s a → ∀ (b : β), Membership.mem t b → Membership.mem u (HSMul.hSMul a b))","decl":"@[to_additive] lemma smul_subset_iff : s • t ⊆ u ↔ ∀ a ∈ s, ∀ b ∈ t, a • b ∈ u := image₂_subset_iff\n\n"}
{"name":"Finset.union_vadd","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq β\ninst✝¹ : VAdd α β\ns₁ s₂ : Finset α\nt : Finset β\ninst✝ : DecidableEq α\n⊢ Eq (HVAdd.hVAdd (Union.union s₁ s₂) t) (Union.union (HVAdd.hVAdd s₁ t) (HVAdd.hVAdd s₂ t))","decl":"@[to_additive]\nlemma union_smul [DecidableEq α] : (s₁ ∪ s₂) • t = s₁ • t ∪ s₂ • t := image₂_union_left\n\n"}
{"name":"Finset.union_smul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq β\ninst✝¹ : SMul α β\ns₁ s₂ : Finset α\nt : Finset β\ninst✝ : DecidableEq α\n⊢ Eq (HSMul.hSMul (Union.union s₁ s₂) t) (Union.union (HSMul.hSMul s₁ t) (HSMul.hSMul s₂ t))","decl":"@[to_additive]\nlemma union_smul [DecidableEq α] : (s₁ ∪ s₂) • t = s₁ • t ∪ s₂ • t := image₂_union_left\n\n"}
{"name":"Finset.smul_union","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\ns : Finset α\nt₁ t₂ : Finset β\n⊢ Eq (HSMul.hSMul s (Union.union t₁ t₂)) (Union.union (HSMul.hSMul s t₁) (HSMul.hSMul s t₂))","decl":"@[to_additive]\nlemma smul_union : s • (t₁ ∪ t₂) = s • t₁ ∪ s • t₂ := image₂_union_right\n\n"}
{"name":"Finset.vadd_union","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\ns : Finset α\nt₁ t₂ : Finset β\n⊢ Eq (HVAdd.hVAdd s (Union.union t₁ t₂)) (Union.union (HVAdd.hVAdd s t₁) (HVAdd.hVAdd s t₂))","decl":"@[to_additive]\nlemma smul_union : s • (t₁ ∪ t₂) = s • t₁ ∪ s • t₂ := image₂_union_right\n\n"}
{"name":"Finset.inter_smul_subset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq β\ninst✝¹ : SMul α β\ns₁ s₂ : Finset α\nt : Finset β\ninst✝ : DecidableEq α\n⊢ HasSubset.Subset (HSMul.hSMul (Inter.inter s₁ s₂) t) (Inter.inter (HSMul.hSMul s₁ t) (HSMul.hSMul s₂ t))","decl":"@[to_additive]\nlemma inter_smul_subset [DecidableEq α] : (s₁ ∩ s₂) • t ⊆ s₁ • t ∩ s₂ • t :=\n  image₂_inter_subset_left\n\n"}
{"name":"Finset.inter_vadd_subset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq β\ninst✝¹ : VAdd α β\ns₁ s₂ : Finset α\nt : Finset β\ninst✝ : DecidableEq α\n⊢ HasSubset.Subset (HVAdd.hVAdd (Inter.inter s₁ s₂) t) (Inter.inter (HVAdd.hVAdd s₁ t) (HVAdd.hVAdd s₂ t))","decl":"@[to_additive]\nlemma inter_smul_subset [DecidableEq α] : (s₁ ∩ s₂) • t ⊆ s₁ • t ∩ s₂ • t :=\n  image₂_inter_subset_left\n\n"}
{"name":"Finset.smul_inter_subset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\ns : Finset α\nt₁ t₂ : Finset β\n⊢ HasSubset.Subset (HSMul.hSMul s (Inter.inter t₁ t₂)) (Inter.inter (HSMul.hSMul s t₁) (HSMul.hSMul s t₂))","decl":"@[to_additive]\nlemma smul_inter_subset : s • (t₁ ∩ t₂) ⊆ s • t₁ ∩ s • t₂ := image₂_inter_subset_right\n\n"}
{"name":"Finset.vadd_inter_subset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\ns : Finset α\nt₁ t₂ : Finset β\n⊢ HasSubset.Subset (HVAdd.hVAdd s (Inter.inter t₁ t₂)) (Inter.inter (HVAdd.hVAdd s t₁) (HVAdd.hVAdd s t₂))","decl":"@[to_additive]\nlemma smul_inter_subset : s • (t₁ ∩ t₂) ⊆ s • t₁ ∩ s • t₂ := image₂_inter_subset_right\n\n"}
{"name":"Finset.inter_smul_union_subset_union","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq β\ninst✝¹ : SMul α β\ns₁ s₂ : Finset α\nt₁ t₂ : Finset β\ninst✝ : DecidableEq α\n⊢ HasSubset.Subset (HSMul.hSMul (Inter.inter s₁ s₂) (Union.union t₁ t₂)) (Union.union (HSMul.hSMul s₁ t₁) (HSMul.hSMul s₂ t₂))","decl":"@[to_additive]\nlemma inter_smul_union_subset_union [DecidableEq α] : (s₁ ∩ s₂) • (t₁ ∪ t₂) ⊆ s₁ • t₁ ∪ s₂ • t₂ :=\n  image₂_inter_union_subset_union\n\n"}
{"name":"Finset.inter_vadd_union_subset_union","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq β\ninst✝¹ : VAdd α β\ns₁ s₂ : Finset α\nt₁ t₂ : Finset β\ninst✝ : DecidableEq α\n⊢ HasSubset.Subset (HVAdd.hVAdd (Inter.inter s₁ s₂) (Union.union t₁ t₂)) (Union.union (HVAdd.hVAdd s₁ t₁) (HVAdd.hVAdd s₂ t₂))","decl":"@[to_additive]\nlemma inter_smul_union_subset_union [DecidableEq α] : (s₁ ∩ s₂) • (t₁ ∪ t₂) ⊆ s₁ • t₁ ∪ s₂ • t₂ :=\n  image₂_inter_union_subset_union\n\n"}
{"name":"Finset.union_smul_inter_subset_union","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq β\ninst✝¹ : SMul α β\ns₁ s₂ : Finset α\nt₁ t₂ : Finset β\ninst✝ : DecidableEq α\n⊢ HasSubset.Subset (HSMul.hSMul (Union.union s₁ s₂) (Inter.inter t₁ t₂)) (Union.union (HSMul.hSMul s₁ t₁) (HSMul.hSMul s₂ t₂))","decl":"@[to_additive]\nlemma union_smul_inter_subset_union [DecidableEq α] : (s₁ ∪ s₂) • (t₁ ∩ t₂) ⊆ s₁ • t₁ ∪ s₂ • t₂ :=\n  image₂_union_inter_subset_union\n\n"}
{"name":"Finset.union_vadd_inter_subset_union","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq β\ninst✝¹ : VAdd α β\ns₁ s₂ : Finset α\nt₁ t₂ : Finset β\ninst✝ : DecidableEq α\n⊢ HasSubset.Subset (HVAdd.hVAdd (Union.union s₁ s₂) (Inter.inter t₁ t₂)) (Union.union (HVAdd.hVAdd s₁ t₁) (HVAdd.hVAdd s₂ t₂))","decl":"@[to_additive]\nlemma union_smul_inter_subset_union [DecidableEq α] : (s₁ ∪ s₂) • (t₁ ∩ t₂) ⊆ s₁ • t₁ ∪ s₂ • t₂ :=\n  image₂_union_inter_subset_union\n\n"}
{"name":"Finset.subset_vadd","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\nu : Finset β\ns : Set α\nt : Set β\na✝ : HasSubset.Subset (↑u) (HVAdd.hVAdd s t)\n⊢ Exists fun s' => Exists fun t' => And (HasSubset.Subset (↑s') s) (And (HasSubset.Subset (↑t') t) (HasSubset.Subset u (HVAdd.hVAdd s' t')))","decl":"/-- If a finset `u` is contained in the scalar product of two sets `s • t`, we can find two finsets\n`s'`, `t'` such that `s' ⊆ s`, `t' ⊆ t` and `u ⊆ s' • t'`. -/\n@[to_additive\n\"If a finset `u` is contained in the scalar sum of two sets `s +ᵥ t`, we can find two\nfinsets `s'`, `t'` such that `s' ⊆ s`, `t' ⊆ t` and `u ⊆ s' +ᵥ t'`.\"]\nlemma subset_smul {s : Set α} {t : Set β} :\n    ↑u ⊆ s • t → ∃ (s' : Finset α) (t' : Finset β), ↑s' ⊆ s ∧ ↑t' ⊆ t ∧ u ⊆ s' • t' :=\n  subset_set_image₂\n\n"}
{"name":"Finset.subset_smul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\nu : Finset β\ns : Set α\nt : Set β\na✝ : HasSubset.Subset (↑u) (HSMul.hSMul s t)\n⊢ Exists fun s' => Exists fun t' => And (HasSubset.Subset (↑s') s) (And (HasSubset.Subset (↑t') t) (HasSubset.Subset u (HSMul.hSMul s' t')))","decl":"/-- If a finset `u` is contained in the scalar product of two sets `s • t`, we can find two finsets\n`s'`, `t'` such that `s' ⊆ s`, `t' ⊆ t` and `u ⊆ s' • t'`. -/\n@[to_additive\n\"If a finset `u` is contained in the scalar sum of two sets `s +ᵥ t`, we can find two\nfinsets `s'`, `t'` such that `s' ⊆ s`, `t' ⊆ t` and `u ⊆ s' +ᵥ t'`.\"]\nlemma subset_smul {s : Set α} {t : Set β} :\n    ↑u ⊆ s • t → ∃ (s' : Finset α) (t' : Finset β), ↑s' ⊆ s ∧ ↑t' ⊆ t ∧ u ⊆ s' • t' :=\n  subset_set_image₂\n\n"}
{"name":"Finset.vadd_finset_def","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\ns : Finset β\na : α\n⊢ Eq (HVAdd.hVAdd a s) (Finset.image (fun x => HVAdd.hVAdd a x) s)","decl":"@[to_additive] lemma smul_finset_def : a • s = s.image (a • ·) := rfl\n\n"}
{"name":"Finset.smul_finset_def","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\ns : Finset β\na : α\n⊢ Eq (HSMul.hSMul a s) (Finset.image (fun x => HSMul.hSMul a x) s)","decl":"@[to_additive] lemma smul_finset_def : a • s = s.image (a • ·) := rfl\n\n"}
{"name":"Finset.image_vadd","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\ns : Finset β\na : α\n⊢ Eq (Finset.image (fun x => HVAdd.hVAdd a x) s) (HVAdd.hVAdd a s)","decl":"@[to_additive] lemma image_smul : s.image (a • ·) = a • s := rfl\n\n"}
{"name":"Finset.image_smul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\ns : Finset β\na : α\n⊢ Eq (Finset.image (fun x => HSMul.hSMul a x) s) (HSMul.hSMul a s)","decl":"@[to_additive] lemma image_smul : s.image (a • ·) = a • s := rfl\n\n"}
{"name":"Finset.mem_vadd_finset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\ns : Finset β\na : α\nx : β\n⊢ Iff (Membership.mem (HVAdd.hVAdd a s) x) (Exists fun y => And (Membership.mem s y) (Eq (HVAdd.hVAdd a y) x))","decl":"@[to_additive]\nlemma mem_smul_finset {x : β} : x ∈ a • s ↔ ∃ y, y ∈ s ∧ a • y = x := by\n  simp only [Finset.smul_finset_def, and_assoc, mem_image, exists_prop, Prod.exists, mem_product]\n\n"}
{"name":"Finset.mem_smul_finset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\ns : Finset β\na : α\nx : β\n⊢ Iff (Membership.mem (HSMul.hSMul a s) x) (Exists fun y => And (Membership.mem s y) (Eq (HSMul.hSMul a y) x))","decl":"@[to_additive]\nlemma mem_smul_finset {x : β} : x ∈ a • s ↔ ∃ y, y ∈ s ∧ a • y = x := by\n  simp only [Finset.smul_finset_def, and_assoc, mem_image, exists_prop, Prod.exists, mem_product]\n\n"}
{"name":"Finset.coe_vadd_finset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\na : α\ns : Finset β\n⊢ Eq (↑(HVAdd.hVAdd a s)) (HVAdd.hVAdd a ↑s)","decl":"@[to_additive (attr := simp, norm_cast)]\nlemma coe_smul_finset (a : α) (s : Finset β) : ↑(a • s) = a • (↑s : Set β) := coe_image\n\n"}
{"name":"Finset.coe_smul_finset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\na : α\ns : Finset β\n⊢ Eq (↑(HSMul.hSMul a s)) (HSMul.hSMul a ↑s)","decl":"@[to_additive (attr := simp, norm_cast)]\nlemma coe_smul_finset (a : α) (s : Finset β) : ↑(a • s) = a • (↑s : Set β) := coe_image\n\n"}
{"name":"Finset.smul_mem_smul_finset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\ns : Finset β\na : α\nb : β\na✝ : Membership.mem s b\n⊢ Membership.mem (HSMul.hSMul a s) (HSMul.hSMul a b)","decl":"@[to_additive] lemma smul_mem_smul_finset : b ∈ s → a • b ∈ a • s := mem_image_of_mem _\n\n"}
{"name":"Finset.vadd_mem_vadd_finset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\ns : Finset β\na : α\nb : β\na✝ : Membership.mem s b\n⊢ Membership.mem (HVAdd.hVAdd a s) (HVAdd.hVAdd a b)","decl":"@[to_additive] lemma smul_mem_smul_finset : b ∈ s → a • b ∈ a • s := mem_image_of_mem _\n\n"}
{"name":"Finset.smul_finset_card_le","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\ns : Finset β\na : α\n⊢ LE.le (HSMul.hSMul a s).card s.card","decl":"@[to_additive] lemma smul_finset_card_le : (a • s).card ≤ s.card := card_image_le\n\n"}
{"name":"Finset.vadd_finset_card_le","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\ns : Finset β\na : α\n⊢ LE.le (HVAdd.hVAdd a s).card s.card","decl":"@[to_additive] lemma smul_finset_card_le : (a • s).card ≤ s.card := card_image_le\n\n"}
{"name":"Finset.smul_finset_empty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\na : α\n⊢ Eq (HSMul.hSMul a EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)]\nlemma smul_finset_empty (a : α) : a • (∅ : Finset β) = ∅ := image_empty _\n\n"}
{"name":"Finset.vadd_finset_empty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\na : α\n⊢ Eq (HVAdd.hVAdd a EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)]\nlemma smul_finset_empty (a : α) : a • (∅ : Finset β) = ∅ := image_empty _\n\n"}
{"name":"Finset.smul_finset_eq_empty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\ns : Finset β\na : α\n⊢ Iff (Eq (HSMul.hSMul a s) EmptyCollection.emptyCollection) (Eq s EmptyCollection.emptyCollection)","decl":"@[to_additive (attr := simp)]\nlemma smul_finset_eq_empty : a • s = ∅ ↔ s = ∅ := image_eq_empty\n\n"}
{"name":"Finset.vadd_finset_eq_empty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\ns : Finset β\na : α\n⊢ Iff (Eq (HVAdd.hVAdd a s) EmptyCollection.emptyCollection) (Eq s EmptyCollection.emptyCollection)","decl":"@[to_additive (attr := simp)]\nlemma smul_finset_eq_empty : a • s = ∅ ↔ s = ∅ := image_eq_empty\n\n"}
{"name":"Finset.smul_finset_nonempty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\ns : Finset β\na : α\n⊢ Iff (HSMul.hSMul a s).Nonempty s.Nonempty","decl":"@[to_additive (attr := simp)]\nlemma smul_finset_nonempty : (a • s).Nonempty ↔ s.Nonempty := image_nonempty\n\n"}
{"name":"Finset.vadd_finset_nonempty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\ns : Finset β\na : α\n⊢ Iff (HVAdd.hVAdd a s).Nonempty s.Nonempty","decl":"@[to_additive (attr := simp)]\nlemma smul_finset_nonempty : (a • s).Nonempty ↔ s.Nonempty := image_nonempty\n\n"}
{"name":"Finset.Nonempty.smul_finset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\ns : Finset β\na : α\nhs : s.Nonempty\n⊢ (HSMul.hSMul a s).Nonempty","decl":"@[to_additive (attr := aesop safe apply (rule_sets := [finsetNonempty]))]\nlemma Nonempty.smul_finset (hs : s.Nonempty) : (a • s).Nonempty :=\n  hs.image _\n\n"}
{"name":"Finset.Nonempty.vadd_finset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\ns : Finset β\na : α\nhs : s.Nonempty\n⊢ (HVAdd.hVAdd a s).Nonempty","decl":"@[to_additive (attr := aesop safe apply (rule_sets := [finsetNonempty]))]\nlemma Nonempty.smul_finset (hs : s.Nonempty) : (a • s).Nonempty :=\n  hs.image _\n\n"}
{"name":"Finset.singleton_smul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\nt : Finset β\na : α\n⊢ Eq (HSMul.hSMul (Singleton.singleton a) t) (HSMul.hSMul a t)","decl":"@[to_additive (attr := simp)]\nlemma singleton_smul (a : α) : ({a} : Finset α) • t = a • t := image₂_singleton_left\n\n"}
{"name":"Finset.singleton_vadd","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\nt : Finset β\na : α\n⊢ Eq (HVAdd.hVAdd (Singleton.singleton a) t) (HVAdd.hVAdd a t)","decl":"@[to_additive (attr := simp)]\nlemma singleton_smul (a : α) : ({a} : Finset α) • t = a • t := image₂_singleton_left\n\n"}
{"name":"Finset.vadd_finset_subset_vadd_finset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\ns t : Finset β\na : α\na✝ : HasSubset.Subset s t\n⊢ HasSubset.Subset (HVAdd.hVAdd a s) (HVAdd.hVAdd a t)","decl":"@[to_additive (attr := mono, gcongr)]\nlemma smul_finset_subset_smul_finset : s ⊆ t → a • s ⊆ a • t := image_subset_image\n\n"}
{"name":"Finset.smul_finset_subset_smul_finset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\ns t : Finset β\na : α\na✝ : HasSubset.Subset s t\n⊢ HasSubset.Subset (HSMul.hSMul a s) (HSMul.hSMul a t)","decl":"@[to_additive (attr := mono, gcongr)]\nlemma smul_finset_subset_smul_finset : s ⊆ t → a • s ⊆ a • t := image_subset_image\n\n"}
{"name":"Finset.smul_finset_singleton","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\na : α\nb : β\n⊢ Eq (HSMul.hSMul a (Singleton.singleton b)) (Singleton.singleton (HSMul.hSMul a b))","decl":"@[to_additive (attr := simp)]\nlemma smul_finset_singleton (b : β) : a • ({b} : Finset β) = {a • b} := image_singleton ..\n\n"}
{"name":"Finset.vadd_finset_singleton","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\na : α\nb : β\n⊢ Eq (HVAdd.hVAdd a (Singleton.singleton b)) (Singleton.singleton (HVAdd.hVAdd a b))","decl":"@[to_additive (attr := simp)]\nlemma smul_finset_singleton (b : β) : a • ({b} : Finset β) = {a • b} := image_singleton ..\n\n"}
{"name":"Finset.smul_finset_union","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\ns₁ s₂ : Finset β\na : α\n⊢ Eq (HSMul.hSMul a (Union.union s₁ s₂)) (Union.union (HSMul.hSMul a s₁) (HSMul.hSMul a s₂))","decl":"@[to_additive]\nlemma smul_finset_union : a • (s₁ ∪ s₂) = a • s₁ ∪ a • s₂ := image_union _ _\n\n"}
{"name":"Finset.vadd_finset_union","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\ns₁ s₂ : Finset β\na : α\n⊢ Eq (HVAdd.hVAdd a (Union.union s₁ s₂)) (Union.union (HVAdd.hVAdd a s₁) (HVAdd.hVAdd a s₂))","decl":"@[to_additive]\nlemma smul_finset_union : a • (s₁ ∪ s₂) = a • s₁ ∪ a • s₂ := image_union _ _\n\n"}
{"name":"Finset.vadd_finset_insert","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\na : α\nb : β\ns : Finset β\n⊢ Eq (HVAdd.hVAdd a (Insert.insert b s)) (Insert.insert (HVAdd.hVAdd a b) (HVAdd.hVAdd a s))","decl":"@[to_additive]\nlemma smul_finset_insert (a : α) (b : β) (s : Finset β) : a • insert b s = insert (a • b) (a • s) :=\n  image_insert ..\n\n"}
{"name":"Finset.smul_finset_insert","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\na : α\nb : β\ns : Finset β\n⊢ Eq (HSMul.hSMul a (Insert.insert b s)) (Insert.insert (HSMul.hSMul a b) (HSMul.hSMul a s))","decl":"@[to_additive]\nlemma smul_finset_insert (a : α) (b : β) (s : Finset β) : a • insert b s = insert (a • b) (a • s) :=\n  image_insert ..\n\n"}
{"name":"Finset.vadd_finset_inter_subset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\ns₁ s₂ : Finset β\na : α\n⊢ HasSubset.Subset (HVAdd.hVAdd a (Inter.inter s₁ s₂)) (Inter.inter (HVAdd.hVAdd a s₁) (HVAdd.hVAdd a s₂))","decl":"@[to_additive]\nlemma smul_finset_inter_subset : a • (s₁ ∩ s₂) ⊆ a • s₁ ∩ a • s₂ := image_inter_subset _ _ _\n\n"}
{"name":"Finset.smul_finset_inter_subset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\ns₁ s₂ : Finset β\na : α\n⊢ HasSubset.Subset (HSMul.hSMul a (Inter.inter s₁ s₂)) (Inter.inter (HSMul.hSMul a s₁) (HSMul.hSMul a s₂))","decl":"@[to_additive]\nlemma smul_finset_inter_subset : a • (s₁ ∩ s₂) ⊆ a • s₁ ∩ a • s₂ := image_inter_subset _ _ _\n\n"}
{"name":"Finset.vadd_finset_subset_vadd","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\nt : Finset β\na : α\ns : Finset α\na✝ : Membership.mem s a\n⊢ HasSubset.Subset (HVAdd.hVAdd a t) (HVAdd.hVAdd s t)","decl":"@[to_additive]\nlemma smul_finset_subset_smul {s : Finset α} : a ∈ s → a • t ⊆ s • t := image_subset_image₂_right\n\n"}
{"name":"Finset.smul_finset_subset_smul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\nt : Finset β\na : α\ns : Finset α\na✝ : Membership.mem s a\n⊢ HasSubset.Subset (HSMul.hSMul a t) (HSMul.hSMul s t)","decl":"@[to_additive]\nlemma smul_finset_subset_smul {s : Finset α} : a ∈ s → a • t ⊆ s • t := image_subset_image₂_right\n\n"}
{"name":"Finset.biUnion_vadd_finset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\ns : Finset α\nt : Finset β\n⊢ Eq (s.biUnion fun x => HVAdd.hVAdd x t) (HVAdd.hVAdd s t)","decl":"@[to_additive (attr := simp)]\nlemma biUnion_smul_finset (s : Finset α) (t : Finset β) : s.biUnion (· • t) = s • t :=\n  biUnion_image_left\n\n"}
{"name":"Finset.biUnion_smul_finset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\ns : Finset α\nt : Finset β\n⊢ Eq (s.biUnion fun x => HSMul.hSMul x t) (HSMul.hSMul s t)","decl":"@[to_additive (attr := simp)]\nlemma biUnion_smul_finset (s : Finset α) (t : Finset β) : s.biUnion (· • t) = s • t :=\n  biUnion_image_left\n\n"}
{"name":"Finset.add_def","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns t : Finset α\n⊢ Eq (HAdd.hAdd s t) (Finset.image (fun p => HAdd.hAdd p.1 p.2) (SProd.sprod s t))","decl":"@[to_additive]\ntheorem mul_def : s * t = (s ×ˢ t).image fun p : α × α => p.1 * p.2 :=\n  rfl\n\n"}
{"name":"Finset.mul_def","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns t : Finset α\n⊢ Eq (HMul.hMul s t) (Finset.image (fun p => HMul.hMul p.1 p.2) (SProd.sprod s t))","decl":"@[to_additive]\ntheorem mul_def : s * t = (s ×ˢ t).image fun p : α × α => p.1 * p.2 :=\n  rfl\n\n"}
{"name":"Finset.image_mul_product","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns t : Finset α\n⊢ Eq (Finset.image (fun x => HMul.hMul x.1 x.2) (SProd.sprod s t)) (HMul.hMul s t)","decl":"@[to_additive]\ntheorem image_mul_product : ((s ×ˢ t).image fun x : α × α => x.fst * x.snd) = s * t :=\n  rfl\n\n"}
{"name":"Finset.image_add_product","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns t : Finset α\n⊢ Eq (Finset.image (fun x => HAdd.hAdd x.1 x.2) (SProd.sprod s t)) (HAdd.hAdd s t)","decl":"@[to_additive]\ntheorem image_mul_product : ((s ×ˢ t).image fun x : α × α => x.fst * x.snd) = s * t :=\n  rfl\n\n"}
{"name":"Finset.mem_mul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns t : Finset α\nx : α\n⊢ Iff (Membership.mem (HMul.hMul s t) x) (Exists fun y => And (Membership.mem s y) (Exists fun z => And (Membership.mem t z) (Eq (HMul.hMul y z) x)))","decl":"@[to_additive]\ntheorem mem_mul {x : α} : x ∈ s * t ↔ ∃ y ∈ s, ∃ z ∈ t, y * z = x := mem_image₂\n\n"}
{"name":"Finset.mem_add","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns t : Finset α\nx : α\n⊢ Iff (Membership.mem (HAdd.hAdd s t) x) (Exists fun y => And (Membership.mem s y) (Exists fun z => And (Membership.mem t z) (Eq (HAdd.hAdd y z) x)))","decl":"@[to_additive]\ntheorem mem_mul {x : α} : x ∈ s * t ↔ ∃ y ∈ s, ∃ z ∈ t, y * z = x := mem_image₂\n\n"}
{"name":"Finset.coe_add","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns t : Finset α\n⊢ Eq (↑(HAdd.hAdd s t)) (HAdd.hAdd ↑s ↑t)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_mul (s t : Finset α) : (↑(s * t) : Set α) = ↑s * ↑t :=\n  coe_image₂ _ _ _\n\n"}
{"name":"Finset.coe_mul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns t : Finset α\n⊢ Eq (↑(HMul.hMul s t)) (HMul.hMul ↑s ↑t)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_mul (s t : Finset α) : (↑(s * t) : Set α) = ↑s * ↑t :=\n  coe_image₂ _ _ _\n\n"}
{"name":"Finset.add_mem_add","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns t : Finset α\na b : α\na✝¹ : Membership.mem s a\na✝ : Membership.mem t b\n⊢ Membership.mem (HAdd.hAdd s t) (HAdd.hAdd a b)","decl":"@[to_additive]\ntheorem mul_mem_mul : a ∈ s → b ∈ t → a * b ∈ s * t :=\n  mem_image₂_of_mem\n\n"}
{"name":"Finset.mul_mem_mul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns t : Finset α\na b : α\na✝¹ : Membership.mem s a\na✝ : Membership.mem t b\n⊢ Membership.mem (HMul.hMul s t) (HMul.hMul a b)","decl":"@[to_additive]\ntheorem mul_mem_mul : a ∈ s → b ∈ t → a * b ∈ s * t :=\n  mem_image₂_of_mem\n\n"}
{"name":"Finset.card_add_le","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns t : Finset α\n⊢ LE.le (HAdd.hAdd s t).card (HMul.hMul s.card t.card)","decl":"@[to_additive]\ntheorem card_mul_le : (s * t).card ≤ s.card * t.card :=\n  card_image₂_le _ _ _\n\n"}
{"name":"Finset.card_mul_le","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns t : Finset α\n⊢ LE.le (HMul.hMul s t).card (HMul.hMul s.card t.card)","decl":"@[to_additive]\ntheorem card_mul_le : (s * t).card ≤ s.card * t.card :=\n  card_image₂_le _ _ _\n\n"}
{"name":"Finset.card_mul_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns t : Finset α\n⊢ Iff (Eq (HMul.hMul s t).card (HMul.hMul s.card t.card)) (Set.InjOn (fun p => HMul.hMul p.1 p.2) (SProd.sprod ↑s ↑t))","decl":"@[to_additive]\ntheorem card_mul_iff :\n    (s * t).card = s.card * t.card ↔ (s ×ˢ t : Set (α × α)).InjOn fun p => p.1 * p.2 :=\n  card_image₂_iff\n\n"}
{"name":"Finset.card_add_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns t : Finset α\n⊢ Iff (Eq (HAdd.hAdd s t).card (HMul.hMul s.card t.card)) (Set.InjOn (fun p => HAdd.hAdd p.1 p.2) (SProd.sprod ↑s ↑t))","decl":"@[to_additive]\ntheorem card_mul_iff :\n    (s * t).card = s.card * t.card ↔ (s ×ˢ t : Set (α × α)).InjOn fun p => p.1 * p.2 :=\n  card_image₂_iff\n\n"}
{"name":"Finset.empty_add","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns : Finset α\n⊢ Eq (HAdd.hAdd EmptyCollection.emptyCollection s) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)]\ntheorem empty_mul (s : Finset α) : ∅ * s = ∅ :=\n  image₂_empty_left\n\n"}
{"name":"Finset.empty_mul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns : Finset α\n⊢ Eq (HMul.hMul EmptyCollection.emptyCollection s) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)]\ntheorem empty_mul (s : Finset α) : ∅ * s = ∅ :=\n  image₂_empty_left\n\n"}
{"name":"Finset.add_empty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns : Finset α\n⊢ Eq (HAdd.hAdd s EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)]\ntheorem mul_empty (s : Finset α) : s * ∅ = ∅ :=\n  image₂_empty_right\n\n"}
{"name":"Finset.mul_empty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns : Finset α\n⊢ Eq (HMul.hMul s EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)]\ntheorem mul_empty (s : Finset α) : s * ∅ = ∅ :=\n  image₂_empty_right\n\n"}
{"name":"Finset.add_eq_empty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns t : Finset α\n⊢ Iff (Eq (HAdd.hAdd s t) EmptyCollection.emptyCollection) (Or (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection))","decl":"@[to_additive (attr := simp)]\ntheorem mul_eq_empty : s * t = ∅ ↔ s = ∅ ∨ t = ∅ :=\n  image₂_eq_empty_iff\n\n"}
{"name":"Finset.mul_eq_empty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns t : Finset α\n⊢ Iff (Eq (HMul.hMul s t) EmptyCollection.emptyCollection) (Or (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection))","decl":"@[to_additive (attr := simp)]\ntheorem mul_eq_empty : s * t = ∅ ↔ s = ∅ ∨ t = ∅ :=\n  image₂_eq_empty_iff\n\n"}
{"name":"Finset.add_nonempty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns t : Finset α\n⊢ Iff (HAdd.hAdd s t).Nonempty (And s.Nonempty t.Nonempty)","decl":"@[to_additive (attr := simp)]\ntheorem mul_nonempty : (s * t).Nonempty ↔ s.Nonempty ∧ t.Nonempty :=\n  image₂_nonempty_iff\n\n"}
{"name":"Finset.mul_nonempty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns t : Finset α\n⊢ Iff (HMul.hMul s t).Nonempty (And s.Nonempty t.Nonempty)","decl":"@[to_additive (attr := simp)]\ntheorem mul_nonempty : (s * t).Nonempty ↔ s.Nonempty ∧ t.Nonempty :=\n  image₂_nonempty_iff\n\n"}
{"name":"Finset.Nonempty.mul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns t : Finset α\na✝¹ : s.Nonempty\na✝ : t.Nonempty\n⊢ (HMul.hMul s t).Nonempty","decl":"@[to_additive (attr := aesop safe apply (rule_sets := [finsetNonempty]))]\ntheorem Nonempty.mul : s.Nonempty → t.Nonempty → (s * t).Nonempty :=\n  Nonempty.image₂\n\n"}
{"name":"Finset.Nonempty.add","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns t : Finset α\na✝¹ : s.Nonempty\na✝ : t.Nonempty\n⊢ (HAdd.hAdd s t).Nonempty","decl":"@[to_additive (attr := aesop safe apply (rule_sets := [finsetNonempty]))]\ntheorem Nonempty.mul : s.Nonempty → t.Nonempty → (s * t).Nonempty :=\n  Nonempty.image₂\n\n"}
{"name":"Finset.Nonempty.of_mul_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns t : Finset α\na✝ : (HMul.hMul s t).Nonempty\n⊢ s.Nonempty","decl":"@[to_additive]\ntheorem Nonempty.of_mul_left : (s * t).Nonempty → s.Nonempty :=\n  Nonempty.of_image₂_left\n\n"}
{"name":"Finset.Nonempty.of_add_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns t : Finset α\na✝ : (HAdd.hAdd s t).Nonempty\n⊢ s.Nonempty","decl":"@[to_additive]\ntheorem Nonempty.of_mul_left : (s * t).Nonempty → s.Nonempty :=\n  Nonempty.of_image₂_left\n\n"}
{"name":"Finset.Nonempty.of_add_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns t : Finset α\na✝ : (HAdd.hAdd s t).Nonempty\n⊢ t.Nonempty","decl":"@[to_additive]\ntheorem Nonempty.of_mul_right : (s * t).Nonempty → t.Nonempty :=\n  Nonempty.of_image₂_right\n\n"}
{"name":"Finset.Nonempty.of_mul_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns t : Finset α\na✝ : (HMul.hMul s t).Nonempty\n⊢ t.Nonempty","decl":"@[to_additive]\ntheorem Nonempty.of_mul_right : (s * t).Nonempty → t.Nonempty :=\n  Nonempty.of_image₂_right\n\n"}
{"name":"Finset.add_singleton","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns : Finset α\na : α\n⊢ Eq (HAdd.hAdd s (Singleton.singleton a)) (HVAdd.hVAdd (AddOpposite.op a) s)","decl":"open scoped RightActions in\n@[to_additive] lemma mul_singleton (a : α) : s * {a} = s <• a := image₂_singleton_right\n"}
{"name":"Finset.mul_singleton","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns : Finset α\na : α\n⊢ Eq (HMul.hMul s (Singleton.singleton a)) (HSMul.hSMul (MulOpposite.op a) s)","decl":"open scoped RightActions in\n@[to_additive] lemma mul_singleton (a : α) : s * {a} = s <• a := image₂_singleton_right\n"}
{"name":"Finset.singleton_add","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns : Finset α\na : α\n⊢ Eq (HAdd.hAdd (Singleton.singleton a) s) (HVAdd.hVAdd a s)","decl":"@[to_additive] lemma singleton_mul (a : α) : {a} * s = a • s := image₂_singleton_left\n\n"}
{"name":"Finset.singleton_mul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns : Finset α\na : α\n⊢ Eq (HMul.hMul (Singleton.singleton a) s) (HSMul.hSMul a s)","decl":"@[to_additive] lemma singleton_mul (a : α) : {a} * s = a • s := image₂_singleton_left\n\n"}
{"name":"Finset.singleton_add_singleton","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\na b : α\n⊢ Eq (HAdd.hAdd (Singleton.singleton a) (Singleton.singleton b)) (Singleton.singleton (HAdd.hAdd a b))","decl":"@[to_additive (attr := simp)]\ntheorem singleton_mul_singleton (a b : α) : ({a} : Finset α) * {b} = {a * b} :=\n  image₂_singleton\n\n"}
{"name":"Finset.singleton_mul_singleton","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\na b : α\n⊢ Eq (HMul.hMul (Singleton.singleton a) (Singleton.singleton b)) (Singleton.singleton (HMul.hMul a b))","decl":"@[to_additive (attr := simp)]\ntheorem singleton_mul_singleton (a b : α) : ({a} : Finset α) * {b} = {a * b} :=\n  image₂_singleton\n\n"}
{"name":"Finset.mul_subset_mul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns₁ s₂ t₁ t₂ : Finset α\na✝¹ : HasSubset.Subset s₁ s₂\na✝ : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (HMul.hMul s₁ t₁) (HMul.hMul s₂ t₂)","decl":"@[to_additive (attr := mono, gcongr)]\ntheorem mul_subset_mul : s₁ ⊆ s₂ → t₁ ⊆ t₂ → s₁ * t₁ ⊆ s₂ * t₂ :=\n  image₂_subset\n\n"}
{"name":"Finset.add_subset_add","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns₁ s₂ t₁ t₂ : Finset α\na✝¹ : HasSubset.Subset s₁ s₂\na✝ : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (HAdd.hAdd s₁ t₁) (HAdd.hAdd s₂ t₂)","decl":"@[to_additive (attr := mono, gcongr)]\ntheorem mul_subset_mul : s₁ ⊆ s₂ → t₁ ⊆ t₂ → s₁ * t₁ ⊆ s₂ * t₂ :=\n  image₂_subset\n\n"}
{"name":"Finset.add_subset_add_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns t₁ t₂ : Finset α\na✝ : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (HAdd.hAdd s t₁) (HAdd.hAdd s t₂)","decl":"@[to_additive (attr := gcongr)]\ntheorem mul_subset_mul_left : t₁ ⊆ t₂ → s * t₁ ⊆ s * t₂ :=\n  image₂_subset_left\n\n"}
{"name":"Finset.mul_subset_mul_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns t₁ t₂ : Finset α\na✝ : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (HMul.hMul s t₁) (HMul.hMul s t₂)","decl":"@[to_additive (attr := gcongr)]\ntheorem mul_subset_mul_left : t₁ ⊆ t₂ → s * t₁ ⊆ s * t₂ :=\n  image₂_subset_left\n\n"}
{"name":"Finset.mul_subset_mul_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns₁ s₂ t : Finset α\na✝ : HasSubset.Subset s₁ s₂\n⊢ HasSubset.Subset (HMul.hMul s₁ t) (HMul.hMul s₂ t)","decl":"@[to_additive (attr := gcongr)]\ntheorem mul_subset_mul_right : s₁ ⊆ s₂ → s₁ * t ⊆ s₂ * t :=\n  image₂_subset_right\n\n"}
{"name":"Finset.add_subset_add_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns₁ s₂ t : Finset α\na✝ : HasSubset.Subset s₁ s₂\n⊢ HasSubset.Subset (HAdd.hAdd s₁ t) (HAdd.hAdd s₂ t)","decl":"@[to_additive (attr := gcongr)]\ntheorem mul_subset_mul_right : s₁ ⊆ s₂ → s₁ * t ⊆ s₂ * t :=\n  image₂_subset_right\n\n"}
{"name":"Finset.instMulLeftMono","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\n⊢ MulLeftMono (Finset α)","decl":"@[to_additive] instance : MulLeftMono (Finset α) where elim _s _t₁ _t₂ := mul_subset_mul_left\n"}
{"name":"Finset.instAddLeftMono","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\n⊢ AddLeftMono (Finset α)","decl":"@[to_additive] instance : MulLeftMono (Finset α) where elim _s _t₁ _t₂ := mul_subset_mul_left\n"}
{"name":"Finset.instAddRightMono","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\n⊢ AddRightMono (Finset α)","decl":"@[to_additive] instance : MulRightMono (Finset α) where elim _t _s₁ _s₂ := mul_subset_mul_right\n\n"}
{"name":"Finset.instMulRightMono","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\n⊢ MulRightMono (Finset α)","decl":"@[to_additive] instance : MulRightMono (Finset α) where elim _t _s₁ _s₂ := mul_subset_mul_right\n\n"}
{"name":"Finset.mul_subset_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns t u : Finset α\n⊢ Iff (HasSubset.Subset (HMul.hMul s t) u) (∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem t y → Membership.mem u (HMul.hMul x y))","decl":"@[to_additive]\ntheorem mul_subset_iff : s * t ⊆ u ↔ ∀ x ∈ s, ∀ y ∈ t, x * y ∈ u :=\n  image₂_subset_iff\n\n"}
{"name":"Finset.add_subset_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns t u : Finset α\n⊢ Iff (HasSubset.Subset (HAdd.hAdd s t) u) (∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem t y → Membership.mem u (HAdd.hAdd x y))","decl":"@[to_additive]\ntheorem mul_subset_iff : s * t ⊆ u ↔ ∀ x ∈ s, ∀ y ∈ t, x * y ∈ u :=\n  image₂_subset_iff\n\n"}
{"name":"Finset.union_add","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns₁ s₂ t : Finset α\n⊢ Eq (HAdd.hAdd (Union.union s₁ s₂) t) (Union.union (HAdd.hAdd s₁ t) (HAdd.hAdd s₂ t))","decl":"@[to_additive]\ntheorem union_mul : (s₁ ∪ s₂) * t = s₁ * t ∪ s₂ * t :=\n  image₂_union_left\n\n"}
{"name":"Finset.union_mul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns₁ s₂ t : Finset α\n⊢ Eq (HMul.hMul (Union.union s₁ s₂) t) (Union.union (HMul.hMul s₁ t) (HMul.hMul s₂ t))","decl":"@[to_additive]\ntheorem union_mul : (s₁ ∪ s₂) * t = s₁ * t ∪ s₂ * t :=\n  image₂_union_left\n\n"}
{"name":"Finset.mul_union","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns t₁ t₂ : Finset α\n⊢ Eq (HMul.hMul s (Union.union t₁ t₂)) (Union.union (HMul.hMul s t₁) (HMul.hMul s t₂))","decl":"@[to_additive]\ntheorem mul_union : s * (t₁ ∪ t₂) = s * t₁ ∪ s * t₂ :=\n  image₂_union_right\n\n"}
{"name":"Finset.add_union","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns t₁ t₂ : Finset α\n⊢ Eq (HAdd.hAdd s (Union.union t₁ t₂)) (Union.union (HAdd.hAdd s t₁) (HAdd.hAdd s t₂))","decl":"@[to_additive]\ntheorem mul_union : s * (t₁ ∪ t₂) = s * t₁ ∪ s * t₂ :=\n  image₂_union_right\n\n"}
{"name":"Finset.inter_add_subset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns₁ s₂ t : Finset α\n⊢ HasSubset.Subset (HAdd.hAdd (Inter.inter s₁ s₂) t) (Inter.inter (HAdd.hAdd s₁ t) (HAdd.hAdd s₂ t))","decl":"@[to_additive]\ntheorem inter_mul_subset : s₁ ∩ s₂ * t ⊆ s₁ * t ∩ (s₂ * t) :=\n  image₂_inter_subset_left\n\n"}
{"name":"Finset.inter_mul_subset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns₁ s₂ t : Finset α\n⊢ HasSubset.Subset (HMul.hMul (Inter.inter s₁ s₂) t) (Inter.inter (HMul.hMul s₁ t) (HMul.hMul s₂ t))","decl":"@[to_additive]\ntheorem inter_mul_subset : s₁ ∩ s₂ * t ⊆ s₁ * t ∩ (s₂ * t) :=\n  image₂_inter_subset_left\n\n"}
{"name":"Finset.mul_inter_subset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns t₁ t₂ : Finset α\n⊢ HasSubset.Subset (HMul.hMul s (Inter.inter t₁ t₂)) (Inter.inter (HMul.hMul s t₁) (HMul.hMul s t₂))","decl":"@[to_additive]\ntheorem mul_inter_subset : s * (t₁ ∩ t₂) ⊆ s * t₁ ∩ (s * t₂) :=\n  image₂_inter_subset_right\n\n"}
{"name":"Finset.add_inter_subset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns t₁ t₂ : Finset α\n⊢ HasSubset.Subset (HAdd.hAdd s (Inter.inter t₁ t₂)) (Inter.inter (HAdd.hAdd s t₁) (HAdd.hAdd s t₂))","decl":"@[to_additive]\ntheorem mul_inter_subset : s * (t₁ ∩ t₂) ⊆ s * t₁ ∩ (s * t₂) :=\n  image₂_inter_subset_right\n\n"}
{"name":"Finset.inter_mul_union_subset_union","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns₁ s₂ t₁ t₂ : Finset α\n⊢ HasSubset.Subset (HMul.hMul (Inter.inter s₁ s₂) (Union.union t₁ t₂)) (Union.union (HMul.hMul s₁ t₁) (HMul.hMul s₂ t₂))","decl":"@[to_additive]\ntheorem inter_mul_union_subset_union : s₁ ∩ s₂ * (t₁ ∪ t₂) ⊆ s₁ * t₁ ∪ s₂ * t₂ :=\n  image₂_inter_union_subset_union\n\n"}
{"name":"Finset.inter_add_union_subset_union","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns₁ s₂ t₁ t₂ : Finset α\n⊢ HasSubset.Subset (HAdd.hAdd (Inter.inter s₁ s₂) (Union.union t₁ t₂)) (Union.union (HAdd.hAdd s₁ t₁) (HAdd.hAdd s₂ t₂))","decl":"@[to_additive]\ntheorem inter_mul_union_subset_union : s₁ ∩ s₂ * (t₁ ∪ t₂) ⊆ s₁ * t₁ ∪ s₂ * t₂ :=\n  image₂_inter_union_subset_union\n\n"}
{"name":"Finset.union_add_inter_subset_union","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns₁ s₂ t₁ t₂ : Finset α\n⊢ HasSubset.Subset (HAdd.hAdd (Union.union s₁ s₂) (Inter.inter t₁ t₂)) (Union.union (HAdd.hAdd s₁ t₁) (HAdd.hAdd s₂ t₂))","decl":"@[to_additive]\ntheorem union_mul_inter_subset_union : (s₁ ∪ s₂) * (t₁ ∩ t₂) ⊆ s₁ * t₁ ∪ s₂ * t₂ :=\n  image₂_union_inter_subset_union\n\n"}
{"name":"Finset.union_mul_inter_subset_union","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns₁ s₂ t₁ t₂ : Finset α\n⊢ HasSubset.Subset (HMul.hMul (Union.union s₁ s₂) (Inter.inter t₁ t₂)) (Union.union (HMul.hMul s₁ t₁) (HMul.hMul s₂ t₂))","decl":"@[to_additive]\ntheorem union_mul_inter_subset_union : (s₁ ∪ s₂) * (t₁ ∩ t₂) ⊆ s₁ * t₁ ∪ s₂ * t₂ :=\n  image₂_union_inter_subset_union\n\n"}
{"name":"Finset.subset_mul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\nu : Finset α\ns t : Set α\na✝ : HasSubset.Subset (↑u) (HMul.hMul s t)\n⊢ Exists fun s' => Exists fun t' => And (HasSubset.Subset (↑s') s) (And (HasSubset.Subset (↑t') t) (HasSubset.Subset u (HMul.hMul s' t')))","decl":"/-- If a finset `u` is contained in the product of two sets `s * t`, we can find two finsets `s'`,\n`t'` such that `s' ⊆ s`, `t' ⊆ t` and `u ⊆ s' * t'`. -/\n@[to_additive\n      \"If a finset `u` is contained in the sum of two sets `s + t`, we can find two finsets\n      `s'`, `t'` such that `s' ⊆ s`, `t' ⊆ t` and `u ⊆ s' + t'`.\"]\ntheorem subset_mul {s t : Set α} :\n    ↑u ⊆ s * t → ∃ s' t' : Finset α, ↑s' ⊆ s ∧ ↑t' ⊆ t ∧ u ⊆ s' * t' :=\n  subset_set_image₂\n\n"}
{"name":"Finset.subset_add","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\nu : Finset α\ns t : Set α\na✝ : HasSubset.Subset (↑u) (HAdd.hAdd s t)\n⊢ Exists fun s' => Exists fun t' => And (HasSubset.Subset (↑s') s) (And (HasSubset.Subset (↑t') t) (HasSubset.Subset u (HAdd.hAdd s' t')))","decl":"/-- If a finset `u` is contained in the product of two sets `s * t`, we can find two finsets `s'`,\n`t'` such that `s' ⊆ s`, `t' ⊆ t` and `u ⊆ s' * t'`. -/\n@[to_additive\n      \"If a finset `u` is contained in the sum of two sets `s + t`, we can find two finsets\n      `s'`, `t'` such that `s' ⊆ s`, `t' ⊆ t` and `u ⊆ s' + t'`.\"]\ntheorem subset_mul {s t : Set α} :\n    ↑u ⊆ s * t → ∃ s' t' : Finset α, ↑s' ⊆ s ∧ ↑t' ⊆ t ∧ u ⊆ s' * t' :=\n  subset_set_image₂\n\n"}
{"name":"Finset.image_mul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : DecidableEq α\ninst✝⁴ : Mul α\ninst✝³ : Mul β\ninst✝² : FunLike F α β\ninst✝¹ : MulHomClass F α β\nf : F\ns t : Finset α\ninst✝ : DecidableEq β\n⊢ Eq (Finset.image (⇑f) (HMul.hMul s t)) (HMul.hMul (Finset.image (⇑f) s) (Finset.image (⇑f) t))","decl":"@[to_additive]\ntheorem image_mul [DecidableEq β] : (s * t).image (f : α → β) = s.image f * t.image f :=\n  image_image₂_distrib <| map_mul f\n\n"}
{"name":"Finset.image_add","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : DecidableEq α\ninst✝⁴ : Add α\ninst✝³ : Add β\ninst✝² : FunLike F α β\ninst✝¹ : AddHomClass F α β\nf : F\ns t : Finset α\ninst✝ : DecidableEq β\n⊢ Eq (Finset.image (⇑f) (HAdd.hAdd s t)) (HAdd.hAdd (Finset.image (⇑f) s) (Finset.image (⇑f) t))","decl":"@[to_additive]\ntheorem image_mul [DecidableEq β] : (s * t).image (f : α → β) = s.image f * t.image f :=\n  image_image₂_distrib <| map_mul f\n\n"}
{"name":"Finset.image_op_mul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns t : Finset α\n⊢ Eq (Finset.image MulOpposite.op (HMul.hMul s t)) (HMul.hMul (Finset.image MulOpposite.op t) (Finset.image MulOpposite.op s))","decl":"@[to_additive]\nlemma image_op_mul (s t : Finset α) : (s * t).image op = t.image op * s.image op :=\n  image_image₂_antidistrib op_mul\n\n"}
{"name":"Finset.image_op_add","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns t : Finset α\n⊢ Eq (Finset.image AddOpposite.op (HAdd.hAdd s t)) (HAdd.hAdd (Finset.image AddOpposite.op t) (Finset.image AddOpposite.op s))","decl":"@[to_additive]\nlemma image_op_mul (s t : Finset α) : (s * t).image op = t.image op * s.image op :=\n  image_image₂_antidistrib op_mul\n\n"}
{"name":"Finset.product_mul_product_comm","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq α\ninst✝² : Mul α\ninst✝¹ : Mul β\ninst✝ : DecidableEq β\ns₁ s₂ : Finset α\nt₁ t₂ : Finset β\n⊢ Eq (HMul.hMul (SProd.sprod s₁ t₁) (SProd.sprod s₂ t₂)) (SProd.sprod (HMul.hMul s₁ s₂) (HMul.hMul t₁ t₂))","decl":"@[to_additive (attr := simp)]\nlemma product_mul_product_comm [DecidableEq β] (s₁ s₂ : Finset α) (t₁ t₂ : Finset β) :\n    (s₁ ×ˢ t₁) * (s₂ ×ˢ t₂) = (s₁ * s₂) ×ˢ (t₁ * t₂) :=\n  mod_cast s₁.toSet.prod_mul_prod_comm s₂ t₁.toSet t₂\n\n"}
{"name":"Finset.product_add_product_comm","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq α\ninst✝² : Add α\ninst✝¹ : Add β\ninst✝ : DecidableEq β\ns₁ s₂ : Finset α\nt₁ t₂ : Finset β\n⊢ Eq (HAdd.hAdd (SProd.sprod s₁ t₁) (SProd.sprod s₂ t₂)) (SProd.sprod (HAdd.hAdd s₁ s₂) (HAdd.hAdd t₁ t₂))","decl":"@[to_additive (attr := simp)]\nlemma product_mul_product_comm [DecidableEq β] (s₁ s₂ : Finset α) (t₁ t₂ : Finset β) :\n    (s₁ ×ˢ t₁) * (s₂ ×ˢ t₂) = (s₁ * s₂) ×ˢ (t₁ * t₂) :=\n  mod_cast s₁.toSet.prod_mul_prod_comm s₂ t₁.toSet t₂\n\n"}
{"name":"Finset.map_op_mul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns t : Finset α\n⊢ Eq (Finset.map MulOpposite.opEquiv.toEmbedding (HMul.hMul s t)) (HMul.hMul (Finset.map MulOpposite.opEquiv.toEmbedding t) (Finset.map MulOpposite.opEquiv.toEmbedding s))","decl":"@[to_additive]\nlemma map_op_mul (s t : Finset α) :\n    (s * t).map opEquiv.toEmbedding = t.map opEquiv.toEmbedding * s.map opEquiv.toEmbedding := by\n  simp [map_eq_image, image_op_mul]\n\n"}
{"name":"Finset.map_op_add","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns t : Finset α\n⊢ Eq (Finset.map AddOpposite.opEquiv.toEmbedding (HAdd.hAdd s t)) (HAdd.hAdd (Finset.map AddOpposite.opEquiv.toEmbedding t) (Finset.map AddOpposite.opEquiv.toEmbedding s))","decl":"@[to_additive]\nlemma map_op_mul (s t : Finset α) :\n    (s * t).map opEquiv.toEmbedding = t.map opEquiv.toEmbedding * s.map opEquiv.toEmbedding := by\n  simp [map_eq_image, image_op_mul]\n\n"}
{"name":"Finset.coe_singletonMulHom","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\n⊢ Eq (⇑Finset.singletonMulHom) Singleton.singleton","decl":"@[to_additive (attr := simp)]\ntheorem coe_singletonMulHom : (singletonMulHom : α → Finset α) = singleton :=\n  rfl\n\n"}
{"name":"Finset.coe_singletonAddHom","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\n⊢ Eq (⇑Finset.singletonAddHom) Singleton.singleton","decl":"@[to_additive (attr := simp)]\ntheorem coe_singletonMulHom : (singletonMulHom : α → Finset α) = singleton :=\n  rfl\n\n"}
{"name":"Finset.singletonAddHom_apply","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\na : α\n⊢ Eq (Finset.singletonAddHom a) (Singleton.singleton a)","decl":"@[to_additive (attr := simp)]\ntheorem singletonMulHom_apply (a : α) : singletonMulHom a = {a} :=\n  rfl\n\n"}
{"name":"Finset.singletonMulHom_apply","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\na : α\n⊢ Eq (Finset.singletonMulHom a) (Singleton.singleton a)","decl":"@[to_additive (attr := simp)]\ntheorem singletonMulHom_apply (a : α) : singletonMulHom a = {a} :=\n  rfl\n\n"}
{"name":"Finset.imageAddHom_apply","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : DecidableEq α\ninst✝⁴ : Add α\ninst✝³ : Add β\ninst✝² : FunLike F α β\ninst✝¹ : AddHomClass F α β\nf : F\ninst✝ : DecidableEq β\ns : Finset α\n⊢ Eq ((Finset.imageAddHom f) s) (Finset.image (⇑f) s)","decl":"/-- Lift a `MulHom` to `Finset` via `image`. -/\n@[to_additive (attr := simps) \"Lift an `AddHom` to `Finset` via `image`\"]\ndef imageMulHom [DecidableEq β] : Finset α →ₙ* Finset β where\n  toFun := Finset.image f\n  map_mul' _ _ := image_mul _\n\n"}
{"name":"Finset.imageMulHom_apply","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : DecidableEq α\ninst✝⁴ : Mul α\ninst✝³ : Mul β\ninst✝² : FunLike F α β\ninst✝¹ : MulHomClass F α β\nf : F\ninst✝ : DecidableEq β\ns : Finset α\n⊢ Eq ((Finset.imageMulHom f) s) (Finset.image (⇑f) s)","decl":"/-- Lift a `MulHom` to `Finset` via `image`. -/\n@[to_additive (attr := simps) \"Lift an `AddHom` to `Finset` via `image`\"]\ndef imageMulHom [DecidableEq β] : Finset α →ₙ* Finset β where\n  toFun := Finset.image f\n  map_mul' _ _ := image_mul _\n\n"}
{"name":"Finset.sup_add_le","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝³ : DecidableEq α\ninst✝² : Add α\nβ : Type u_5\ninst✝¹ : SemilatticeSup β\ninst✝ : OrderBot β\ns t : Finset α\nf : α → β\na : β\n⊢ Iff (LE.le ((HAdd.hAdd s t).sup f) a) (∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem t y → LE.le (f (HAdd.hAdd x y)) a)","decl":"@[to_additive (attr := simp (default + 1))]\nlemma sup_mul_le {β} [SemilatticeSup β] [OrderBot β] {s t : Finset α} {f : α → β} {a : β} :\n    sup (s * t) f ≤ a ↔ ∀ x ∈ s, ∀ y ∈ t, f (x * y) ≤ a :=\n  sup_image₂_le\n\n"}
{"name":"Finset.sup_mul_le","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝³ : DecidableEq α\ninst✝² : Mul α\nβ : Type u_5\ninst✝¹ : SemilatticeSup β\ninst✝ : OrderBot β\ns t : Finset α\nf : α → β\na : β\n⊢ Iff (LE.le ((HMul.hMul s t).sup f) a) (∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem t y → LE.le (f (HMul.hMul x y)) a)","decl":"@[to_additive (attr := simp (default + 1))]\nlemma sup_mul_le {β} [SemilatticeSup β] [OrderBot β] {s t : Finset α} {f : α → β} {a : β} :\n    sup (s * t) f ≤ a ↔ ∀ x ∈ s, ∀ y ∈ t, f (x * y) ≤ a :=\n  sup_image₂_le\n\n"}
{"name":"Finset.sup_mul_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝³ : DecidableEq α\ninst✝² : Mul α\nβ : Type u_5\ninst✝¹ : SemilatticeSup β\ninst✝ : OrderBot β\ns t : Finset α\nf : α → β\n⊢ Eq ((HMul.hMul s t).sup f) (s.sup fun x => t.sup fun x_1 => f (HMul.hMul x x_1))","decl":"@[to_additive]\nlemma sup_mul_left {β} [SemilatticeSup β] [OrderBot β] (s t : Finset α) (f : α → β) :\n    sup (s * t) f = sup s fun x ↦ sup t (f <| x * ·) :=\n  sup_image₂_left ..\n\n"}
{"name":"Finset.sup_add_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝³ : DecidableEq α\ninst✝² : Add α\nβ : Type u_5\ninst✝¹ : SemilatticeSup β\ninst✝ : OrderBot β\ns t : Finset α\nf : α → β\n⊢ Eq ((HAdd.hAdd s t).sup f) (s.sup fun x => t.sup fun x_1 => f (HAdd.hAdd x x_1))","decl":"@[to_additive]\nlemma sup_mul_left {β} [SemilatticeSup β] [OrderBot β] (s t : Finset α) (f : α → β) :\n    sup (s * t) f = sup s fun x ↦ sup t (f <| x * ·) :=\n  sup_image₂_left ..\n\n"}
{"name":"Finset.sup_mul_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝³ : DecidableEq α\ninst✝² : Mul α\nβ : Type u_5\ninst✝¹ : SemilatticeSup β\ninst✝ : OrderBot β\ns t : Finset α\nf : α → β\n⊢ Eq ((HMul.hMul s t).sup f) (t.sup fun y => s.sup fun x => f (HMul.hMul x y))","decl":"@[to_additive]\nlemma sup_mul_right {β} [SemilatticeSup β] [OrderBot β] (s t : Finset α) (f : α → β) :\n    sup (s * t) f = sup t fun y ↦ sup s (f <| · * y) :=\n  sup_image₂_right ..\n\n"}
{"name":"Finset.sup_add_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝³ : DecidableEq α\ninst✝² : Add α\nβ : Type u_5\ninst✝¹ : SemilatticeSup β\ninst✝ : OrderBot β\ns t : Finset α\nf : α → β\n⊢ Eq ((HAdd.hAdd s t).sup f) (t.sup fun y => s.sup fun x => f (HAdd.hAdd x y))","decl":"@[to_additive]\nlemma sup_mul_right {β} [SemilatticeSup β] [OrderBot β] (s t : Finset α) (f : α → β) :\n    sup (s * t) f = sup t fun y ↦ sup s (f <| · * y) :=\n  sup_image₂_right ..\n\n"}
{"name":"Finset.le_inf_mul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝³ : DecidableEq α\ninst✝² : Mul α\nβ : Type u_5\ninst✝¹ : SemilatticeInf β\ninst✝ : OrderTop β\ns t : Finset α\nf : α → β\na : β\n⊢ Iff (LE.le a ((HMul.hMul s t).inf f)) (∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem t y → LE.le a (f (HMul.hMul x y)))","decl":"@[to_additive (attr := simp (default + 1))]\nlemma le_inf_mul {β} [SemilatticeInf β] [OrderTop β] {s t : Finset α} {f : α → β} {a : β} :\n    a ≤ inf (s * t) f ↔ ∀ x ∈ s, ∀ y ∈ t, a ≤ f (x * y) :=\n  le_inf_image₂\n\n"}
{"name":"Finset.le_inf_add","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝³ : DecidableEq α\ninst✝² : Add α\nβ : Type u_5\ninst✝¹ : SemilatticeInf β\ninst✝ : OrderTop β\ns t : Finset α\nf : α → β\na : β\n⊢ Iff (LE.le a ((HAdd.hAdd s t).inf f)) (∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem t y → LE.le a (f (HAdd.hAdd x y)))","decl":"@[to_additive (attr := simp (default + 1))]\nlemma le_inf_mul {β} [SemilatticeInf β] [OrderTop β] {s t : Finset α} {f : α → β} {a : β} :\n    a ≤ inf (s * t) f ↔ ∀ x ∈ s, ∀ y ∈ t, a ≤ f (x * y) :=\n  le_inf_image₂\n\n"}
{"name":"Finset.inf_mul_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝³ : DecidableEq α\ninst✝² : Mul α\nβ : Type u_5\ninst✝¹ : SemilatticeInf β\ninst✝ : OrderTop β\ns t : Finset α\nf : α → β\n⊢ Eq ((HMul.hMul s t).inf f) (s.inf fun x => t.inf fun x_1 => f (HMul.hMul x x_1))","decl":"@[to_additive]\nlemma inf_mul_left {β} [SemilatticeInf β] [OrderTop β] (s t : Finset α) (f : α → β) :\n    inf (s * t) f = inf s fun x ↦ inf t (f <| x * ·) :=\n  inf_image₂_left ..\n\n"}
{"name":"Finset.inf_add_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝³ : DecidableEq α\ninst✝² : Add α\nβ : Type u_5\ninst✝¹ : SemilatticeInf β\ninst✝ : OrderTop β\ns t : Finset α\nf : α → β\n⊢ Eq ((HAdd.hAdd s t).inf f) (s.inf fun x => t.inf fun x_1 => f (HAdd.hAdd x x_1))","decl":"@[to_additive]\nlemma inf_mul_left {β} [SemilatticeInf β] [OrderTop β] (s t : Finset α) (f : α → β) :\n    inf (s * t) f = inf s fun x ↦ inf t (f <| x * ·) :=\n  inf_image₂_left ..\n\n"}
{"name":"Finset.inf_add_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝³ : DecidableEq α\ninst✝² : Add α\nβ : Type u_5\ninst✝¹ : SemilatticeInf β\ninst✝ : OrderTop β\ns t : Finset α\nf : α → β\n⊢ Eq ((HAdd.hAdd s t).inf f) (t.inf fun y => s.inf fun x => f (HAdd.hAdd x y))","decl":"@[to_additive]\nlemma inf_mul_right {β} [SemilatticeInf β] [OrderTop β] (s t : Finset α) (f : α → β) :\n    inf (s * t) f = inf t fun y ↦ inf s (f <| · * y) :=\n  inf_image₂_right ..\n\n"}
{"name":"Finset.inf_mul_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝³ : DecidableEq α\ninst✝² : Mul α\nβ : Type u_5\ninst✝¹ : SemilatticeInf β\ninst✝ : OrderTop β\ns t : Finset α\nf : α → β\n⊢ Eq ((HMul.hMul s t).inf f) (t.inf fun y => s.inf fun x => f (HMul.hMul x y))","decl":"@[to_additive]\nlemma inf_mul_right {β} [SemilatticeInf β] [OrderTop β] (s t : Finset α) (f : α → β) :\n    inf (s * t) f = inf t fun y ↦ inf s (f <| · * y) :=\n  inf_image₂_right ..\n\n"}
{"name":"Finset.sub_def","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Sub α\ns t : Finset α\n⊢ Eq (HSub.hSub s t) (Finset.image (fun p => HSub.hSub p.1 p.2) (SProd.sprod s t))","decl":"@[to_additive]\ntheorem div_def : s / t = (s ×ˢ t).image fun p : α × α => p.1 / p.2 :=\n  rfl\n\n"}
{"name":"Finset.div_def","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Div α\ns t : Finset α\n⊢ Eq (HDiv.hDiv s t) (Finset.image (fun p => HDiv.hDiv p.1 p.2) (SProd.sprod s t))","decl":"@[to_additive]\ntheorem div_def : s / t = (s ×ˢ t).image fun p : α × α => p.1 / p.2 :=\n  rfl\n\n"}
{"name":"Finset.image_div_product","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Div α\ns t : Finset α\n⊢ Eq (Finset.image (fun x => HDiv.hDiv x.1 x.2) (SProd.sprod s t)) (HDiv.hDiv s t)","decl":"@[to_additive]\ntheorem image_div_product : ((s ×ˢ t).image fun x : α × α => x.fst / x.snd) = s / t :=\n  rfl\n\n"}
{"name":"Finset.image_sub_product","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Sub α\ns t : Finset α\n⊢ Eq (Finset.image (fun x => HSub.hSub x.1 x.2) (SProd.sprod s t)) (HSub.hSub s t)","decl":"@[to_additive]\ntheorem image_div_product : ((s ×ˢ t).image fun x : α × α => x.fst / x.snd) = s / t :=\n  rfl\n\n"}
{"name":"Finset.mem_sub","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Sub α\ns t : Finset α\na : α\n⊢ Iff (Membership.mem (HSub.hSub s t) a) (Exists fun b => And (Membership.mem s b) (Exists fun c => And (Membership.mem t c) (Eq (HSub.hSub b c) a)))","decl":"@[to_additive]\ntheorem mem_div : a ∈ s / t ↔ ∃ b ∈ s, ∃ c ∈ t, b / c = a :=\n  mem_image₂\n\n"}
{"name":"Finset.mem_div","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Div α\ns t : Finset α\na : α\n⊢ Iff (Membership.mem (HDiv.hDiv s t) a) (Exists fun b => And (Membership.mem s b) (Exists fun c => And (Membership.mem t c) (Eq (HDiv.hDiv b c) a)))","decl":"@[to_additive]\ntheorem mem_div : a ∈ s / t ↔ ∃ b ∈ s, ∃ c ∈ t, b / c = a :=\n  mem_image₂\n\n"}
{"name":"Finset.coe_div","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Div α\ns t : Finset α\n⊢ Eq (↑(HDiv.hDiv s t)) (HDiv.hDiv ↑s ↑t)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_div (s t : Finset α) : (↑(s / t) : Set α) = ↑s / ↑t :=\n  coe_image₂ _ _ _\n\n"}
{"name":"Finset.coe_sub","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Sub α\ns t : Finset α\n⊢ Eq (↑(HSub.hSub s t)) (HSub.hSub ↑s ↑t)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_div (s t : Finset α) : (↑(s / t) : Set α) = ↑s / ↑t :=\n  coe_image₂ _ _ _\n\n"}
{"name":"Finset.sub_mem_sub","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Sub α\ns t : Finset α\na b : α\na✝¹ : Membership.mem s a\na✝ : Membership.mem t b\n⊢ Membership.mem (HSub.hSub s t) (HSub.hSub a b)","decl":"@[to_additive]\ntheorem div_mem_div : a ∈ s → b ∈ t → a / b ∈ s / t :=\n  mem_image₂_of_mem\n\n"}
{"name":"Finset.div_mem_div","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Div α\ns t : Finset α\na b : α\na✝¹ : Membership.mem s a\na✝ : Membership.mem t b\n⊢ Membership.mem (HDiv.hDiv s t) (HDiv.hDiv a b)","decl":"@[to_additive]\ntheorem div_mem_div : a ∈ s → b ∈ t → a / b ∈ s / t :=\n  mem_image₂_of_mem\n\n"}
{"name":"Finset.sub_card_le","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Sub α\ns t : Finset α\n⊢ LE.le (HSub.hSub s t).card (HMul.hMul s.card t.card)","decl":"@[to_additive]\ntheorem div_card_le : (s / t).card ≤ s.card * t.card :=\n  card_image₂_le _ _ _\n\n"}
{"name":"Finset.div_card_le","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Div α\ns t : Finset α\n⊢ LE.le (HDiv.hDiv s t).card (HMul.hMul s.card t.card)","decl":"@[to_additive]\ntheorem div_card_le : (s / t).card ≤ s.card * t.card :=\n  card_image₂_le _ _ _\n\n"}
{"name":"Finset.empty_div","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Div α\ns : Finset α\n⊢ Eq (HDiv.hDiv EmptyCollection.emptyCollection s) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)]\ntheorem empty_div (s : Finset α) : ∅ / s = ∅ :=\n  image₂_empty_left\n\n"}
{"name":"Finset.empty_sub","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Sub α\ns : Finset α\n⊢ Eq (HSub.hSub EmptyCollection.emptyCollection s) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)]\ntheorem empty_div (s : Finset α) : ∅ / s = ∅ :=\n  image₂_empty_left\n\n"}
{"name":"Finset.div_empty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Div α\ns : Finset α\n⊢ Eq (HDiv.hDiv s EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)]\ntheorem div_empty (s : Finset α) : s / ∅ = ∅ :=\n  image₂_empty_right\n\n"}
{"name":"Finset.sub_empty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Sub α\ns : Finset α\n⊢ Eq (HSub.hSub s EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)]\ntheorem div_empty (s : Finset α) : s / ∅ = ∅ :=\n  image₂_empty_right\n\n"}
{"name":"Finset.div_eq_empty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Div α\ns t : Finset α\n⊢ Iff (Eq (HDiv.hDiv s t) EmptyCollection.emptyCollection) (Or (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection))","decl":"@[to_additive (attr := simp)]\ntheorem div_eq_empty : s / t = ∅ ↔ s = ∅ ∨ t = ∅ :=\n  image₂_eq_empty_iff\n\n"}
{"name":"Finset.sub_eq_empty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Sub α\ns t : Finset α\n⊢ Iff (Eq (HSub.hSub s t) EmptyCollection.emptyCollection) (Or (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection))","decl":"@[to_additive (attr := simp)]\ntheorem div_eq_empty : s / t = ∅ ↔ s = ∅ ∨ t = ∅ :=\n  image₂_eq_empty_iff\n\n"}
{"name":"Finset.div_nonempty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Div α\ns t : Finset α\n⊢ Iff (HDiv.hDiv s t).Nonempty (And s.Nonempty t.Nonempty)","decl":"@[to_additive (attr := simp)]\ntheorem div_nonempty : (s / t).Nonempty ↔ s.Nonempty ∧ t.Nonempty :=\n  image₂_nonempty_iff\n\n"}
{"name":"Finset.sub_nonempty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Sub α\ns t : Finset α\n⊢ Iff (HSub.hSub s t).Nonempty (And s.Nonempty t.Nonempty)","decl":"@[to_additive (attr := simp)]\ntheorem div_nonempty : (s / t).Nonempty ↔ s.Nonempty ∧ t.Nonempty :=\n  image₂_nonempty_iff\n\n"}
{"name":"Finset.Nonempty.sub","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Sub α\ns t : Finset α\na✝¹ : s.Nonempty\na✝ : t.Nonempty\n⊢ (HSub.hSub s t).Nonempty","decl":"@[to_additive (attr := aesop safe apply (rule_sets := [finsetNonempty]))]\ntheorem Nonempty.div : s.Nonempty → t.Nonempty → (s / t).Nonempty :=\n  Nonempty.image₂\n\n"}
{"name":"Finset.Nonempty.div","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Div α\ns t : Finset α\na✝¹ : s.Nonempty\na✝ : t.Nonempty\n⊢ (HDiv.hDiv s t).Nonempty","decl":"@[to_additive (attr := aesop safe apply (rule_sets := [finsetNonempty]))]\ntheorem Nonempty.div : s.Nonempty → t.Nonempty → (s / t).Nonempty :=\n  Nonempty.image₂\n\n"}
{"name":"Finset.Nonempty.of_div_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Div α\ns t : Finset α\na✝ : (HDiv.hDiv s t).Nonempty\n⊢ s.Nonempty","decl":"@[to_additive]\ntheorem Nonempty.of_div_left : (s / t).Nonempty → s.Nonempty :=\n  Nonempty.of_image₂_left\n\n"}
{"name":"Finset.Nonempty.of_sub_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Sub α\ns t : Finset α\na✝ : (HSub.hSub s t).Nonempty\n⊢ s.Nonempty","decl":"@[to_additive]\ntheorem Nonempty.of_div_left : (s / t).Nonempty → s.Nonempty :=\n  Nonempty.of_image₂_left\n\n"}
{"name":"Finset.Nonempty.of_sub_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Sub α\ns t : Finset α\na✝ : (HSub.hSub s t).Nonempty\n⊢ t.Nonempty","decl":"@[to_additive]\ntheorem Nonempty.of_div_right : (s / t).Nonempty → t.Nonempty :=\n  Nonempty.of_image₂_right\n\n"}
{"name":"Finset.Nonempty.of_div_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Div α\ns t : Finset α\na✝ : (HDiv.hDiv s t).Nonempty\n⊢ t.Nonempty","decl":"@[to_additive]\ntheorem Nonempty.of_div_right : (s / t).Nonempty → t.Nonempty :=\n  Nonempty.of_image₂_right\n\n"}
{"name":"Finset.sub_singleton","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Sub α\ns : Finset α\na : α\n⊢ Eq (HSub.hSub s (Singleton.singleton a)) (Finset.image (fun x => HSub.hSub x a) s)","decl":"@[to_additive (attr := simp)]\ntheorem div_singleton (a : α) : s / {a} = s.image (· / a) :=\n  image₂_singleton_right\n\n"}
{"name":"Finset.div_singleton","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Div α\ns : Finset α\na : α\n⊢ Eq (HDiv.hDiv s (Singleton.singleton a)) (Finset.image (fun x => HDiv.hDiv x a) s)","decl":"@[to_additive (attr := simp)]\ntheorem div_singleton (a : α) : s / {a} = s.image (· / a) :=\n  image₂_singleton_right\n\n"}
{"name":"Finset.singleton_div","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Div α\ns : Finset α\na : α\n⊢ Eq (HDiv.hDiv (Singleton.singleton a) s) (Finset.image (fun x => HDiv.hDiv a x) s)","decl":"@[to_additive (attr := simp)]\ntheorem singleton_div (a : α) : {a} / s = s.image (a / ·) :=\n  image₂_singleton_left\n\n"}
{"name":"Finset.singleton_sub","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Sub α\ns : Finset α\na : α\n⊢ Eq (HSub.hSub (Singleton.singleton a) s) (Finset.image (fun x => HSub.hSub a x) s)","decl":"@[to_additive (attr := simp)]\ntheorem singleton_div (a : α) : {a} / s = s.image (a / ·) :=\n  image₂_singleton_left\n\n"}
{"name":"Finset.singleton_div_singleton","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Div α\na b : α\n⊢ Eq (HDiv.hDiv (Singleton.singleton a) (Singleton.singleton b)) (Singleton.singleton (HDiv.hDiv a b))","decl":"@[to_additive]\ntheorem singleton_div_singleton (a b : α) : ({a} : Finset α) / {b} = {a / b} :=\n  image₂_singleton\n\n"}
{"name":"Finset.singleton_sub_singleton","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Sub α\na b : α\n⊢ Eq (HSub.hSub (Singleton.singleton a) (Singleton.singleton b)) (Singleton.singleton (HSub.hSub a b))","decl":"@[to_additive]\ntheorem singleton_div_singleton (a b : α) : ({a} : Finset α) / {b} = {a / b} :=\n  image₂_singleton\n\n"}
{"name":"Finset.div_subset_div","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Div α\ns₁ s₂ t₁ t₂ : Finset α\na✝¹ : HasSubset.Subset s₁ s₂\na✝ : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (HDiv.hDiv s₁ t₁) (HDiv.hDiv s₂ t₂)","decl":"@[to_additive (attr := mono, gcongr)]\ntheorem div_subset_div : s₁ ⊆ s₂ → t₁ ⊆ t₂ → s₁ / t₁ ⊆ s₂ / t₂ :=\n  image₂_subset\n\n"}
{"name":"Finset.sub_subset_sub","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Sub α\ns₁ s₂ t₁ t₂ : Finset α\na✝¹ : HasSubset.Subset s₁ s₂\na✝ : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (HSub.hSub s₁ t₁) (HSub.hSub s₂ t₂)","decl":"@[to_additive (attr := mono, gcongr)]\ntheorem div_subset_div : s₁ ⊆ s₂ → t₁ ⊆ t₂ → s₁ / t₁ ⊆ s₂ / t₂ :=\n  image₂_subset\n\n"}
{"name":"Finset.div_subset_div_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Div α\ns t₁ t₂ : Finset α\na✝ : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (HDiv.hDiv s t₁) (HDiv.hDiv s t₂)","decl":"@[to_additive (attr := gcongr)]\ntheorem div_subset_div_left : t₁ ⊆ t₂ → s / t₁ ⊆ s / t₂ :=\n  image₂_subset_left\n\n"}
{"name":"Finset.sub_subset_sub_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Sub α\ns t₁ t₂ : Finset α\na✝ : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (HSub.hSub s t₁) (HSub.hSub s t₂)","decl":"@[to_additive (attr := gcongr)]\ntheorem div_subset_div_left : t₁ ⊆ t₂ → s / t₁ ⊆ s / t₂ :=\n  image₂_subset_left\n\n"}
{"name":"Finset.div_subset_div_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Div α\ns₁ s₂ t : Finset α\na✝ : HasSubset.Subset s₁ s₂\n⊢ HasSubset.Subset (HDiv.hDiv s₁ t) (HDiv.hDiv s₂ t)","decl":"@[to_additive (attr := gcongr)]\ntheorem div_subset_div_right : s₁ ⊆ s₂ → s₁ / t ⊆ s₂ / t :=\n  image₂_subset_right\n\n"}
{"name":"Finset.sub_subset_sub_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Sub α\ns₁ s₂ t : Finset α\na✝ : HasSubset.Subset s₁ s₂\n⊢ HasSubset.Subset (HSub.hSub s₁ t) (HSub.hSub s₂ t)","decl":"@[to_additive (attr := gcongr)]\ntheorem div_subset_div_right : s₁ ⊆ s₂ → s₁ / t ⊆ s₂ / t :=\n  image₂_subset_right\n\n"}
{"name":"Finset.sub_subset_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Sub α\ns t u : Finset α\n⊢ Iff (HasSubset.Subset (HSub.hSub s t) u) (∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem t y → Membership.mem u (HSub.hSub x y))","decl":"@[to_additive]\ntheorem div_subset_iff : s / t ⊆ u ↔ ∀ x ∈ s, ∀ y ∈ t, x / y ∈ u :=\n  image₂_subset_iff\n\n"}
{"name":"Finset.div_subset_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Div α\ns t u : Finset α\n⊢ Iff (HasSubset.Subset (HDiv.hDiv s t) u) (∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem t y → Membership.mem u (HDiv.hDiv x y))","decl":"@[to_additive]\ntheorem div_subset_iff : s / t ⊆ u ↔ ∀ x ∈ s, ∀ y ∈ t, x / y ∈ u :=\n  image₂_subset_iff\n\n"}
{"name":"Finset.union_sub","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Sub α\ns₁ s₂ t : Finset α\n⊢ Eq (HSub.hSub (Union.union s₁ s₂) t) (Union.union (HSub.hSub s₁ t) (HSub.hSub s₂ t))","decl":"@[to_additive]\ntheorem union_div : (s₁ ∪ s₂) / t = s₁ / t ∪ s₂ / t :=\n  image₂_union_left\n\n"}
{"name":"Finset.union_div","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Div α\ns₁ s₂ t : Finset α\n⊢ Eq (HDiv.hDiv (Union.union s₁ s₂) t) (Union.union (HDiv.hDiv s₁ t) (HDiv.hDiv s₂ t))","decl":"@[to_additive]\ntheorem union_div : (s₁ ∪ s₂) / t = s₁ / t ∪ s₂ / t :=\n  image₂_union_left\n\n"}
{"name":"Finset.sub_union","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Sub α\ns t₁ t₂ : Finset α\n⊢ Eq (HSub.hSub s (Union.union t₁ t₂)) (Union.union (HSub.hSub s t₁) (HSub.hSub s t₂))","decl":"@[to_additive]\ntheorem div_union : s / (t₁ ∪ t₂) = s / t₁ ∪ s / t₂ :=\n  image₂_union_right\n\n"}
{"name":"Finset.div_union","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Div α\ns t₁ t₂ : Finset α\n⊢ Eq (HDiv.hDiv s (Union.union t₁ t₂)) (Union.union (HDiv.hDiv s t₁) (HDiv.hDiv s t₂))","decl":"@[to_additive]\ntheorem div_union : s / (t₁ ∪ t₂) = s / t₁ ∪ s / t₂ :=\n  image₂_union_right\n\n"}
{"name":"Finset.inter_sub_subset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Sub α\ns₁ s₂ t : Finset α\n⊢ HasSubset.Subset (HSub.hSub (Inter.inter s₁ s₂) t) (Inter.inter (HSub.hSub s₁ t) (HSub.hSub s₂ t))","decl":"@[to_additive]\ntheorem inter_div_subset : s₁ ∩ s₂ / t ⊆ s₁ / t ∩ (s₂ / t) :=\n  image₂_inter_subset_left\n\n"}
{"name":"Finset.inter_div_subset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Div α\ns₁ s₂ t : Finset α\n⊢ HasSubset.Subset (HDiv.hDiv (Inter.inter s₁ s₂) t) (Inter.inter (HDiv.hDiv s₁ t) (HDiv.hDiv s₂ t))","decl":"@[to_additive]\ntheorem inter_div_subset : s₁ ∩ s₂ / t ⊆ s₁ / t ∩ (s₂ / t) :=\n  image₂_inter_subset_left\n\n"}
{"name":"Finset.sub_inter_subset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Sub α\ns t₁ t₂ : Finset α\n⊢ HasSubset.Subset (HSub.hSub s (Inter.inter t₁ t₂)) (Inter.inter (HSub.hSub s t₁) (HSub.hSub s t₂))","decl":"@[to_additive]\ntheorem div_inter_subset : s / (t₁ ∩ t₂) ⊆ s / t₁ ∩ (s / t₂) :=\n  image₂_inter_subset_right\n\n"}
{"name":"Finset.div_inter_subset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Div α\ns t₁ t₂ : Finset α\n⊢ HasSubset.Subset (HDiv.hDiv s (Inter.inter t₁ t₂)) (Inter.inter (HDiv.hDiv s t₁) (HDiv.hDiv s t₂))","decl":"@[to_additive]\ntheorem div_inter_subset : s / (t₁ ∩ t₂) ⊆ s / t₁ ∩ (s / t₂) :=\n  image₂_inter_subset_right\n\n"}
{"name":"Finset.inter_div_union_subset_union","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Div α\ns₁ s₂ t₁ t₂ : Finset α\n⊢ HasSubset.Subset (HDiv.hDiv (Inter.inter s₁ s₂) (Union.union t₁ t₂)) (Union.union (HDiv.hDiv s₁ t₁) (HDiv.hDiv s₂ t₂))","decl":"@[to_additive]\ntheorem inter_div_union_subset_union : s₁ ∩ s₂ / (t₁ ∪ t₂) ⊆ s₁ / t₁ ∪ s₂ / t₂ :=\n  image₂_inter_union_subset_union\n\n"}
{"name":"Finset.inter_sub_union_subset_union","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Sub α\ns₁ s₂ t₁ t₂ : Finset α\n⊢ HasSubset.Subset (HSub.hSub (Inter.inter s₁ s₂) (Union.union t₁ t₂)) (Union.union (HSub.hSub s₁ t₁) (HSub.hSub s₂ t₂))","decl":"@[to_additive]\ntheorem inter_div_union_subset_union : s₁ ∩ s₂ / (t₁ ∪ t₂) ⊆ s₁ / t₁ ∪ s₂ / t₂ :=\n  image₂_inter_union_subset_union\n\n"}
{"name":"Finset.union_sub_inter_subset_union","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Sub α\ns₁ s₂ t₁ t₂ : Finset α\n⊢ HasSubset.Subset (HSub.hSub (Union.union s₁ s₂) (Inter.inter t₁ t₂)) (Union.union (HSub.hSub s₁ t₁) (HSub.hSub s₂ t₂))","decl":"@[to_additive]\ntheorem union_div_inter_subset_union : (s₁ ∪ s₂) / (t₁ ∩ t₂) ⊆ s₁ / t₁ ∪ s₂ / t₂ :=\n  image₂_union_inter_subset_union\n\n"}
{"name":"Finset.union_div_inter_subset_union","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Div α\ns₁ s₂ t₁ t₂ : Finset α\n⊢ HasSubset.Subset (HDiv.hDiv (Union.union s₁ s₂) (Inter.inter t₁ t₂)) (Union.union (HDiv.hDiv s₁ t₁) (HDiv.hDiv s₂ t₂))","decl":"@[to_additive]\ntheorem union_div_inter_subset_union : (s₁ ∪ s₂) / (t₁ ∩ t₂) ⊆ s₁ / t₁ ∪ s₂ / t₂ :=\n  image₂_union_inter_subset_union\n\n"}
{"name":"Finset.subset_sub","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Sub α\nu : Finset α\ns t : Set α\na✝ : HasSubset.Subset (↑u) (HSub.hSub s t)\n⊢ Exists fun s' => Exists fun t' => And (HasSubset.Subset (↑s') s) (And (HasSubset.Subset (↑t') t) (HasSubset.Subset u (HSub.hSub s' t')))","decl":"/-- If a finset `u` is contained in the product of two sets `s / t`, we can find two finsets `s'`,\n`t'` such that `s' ⊆ s`, `t' ⊆ t` and `u ⊆ s' / t'`. -/\n@[to_additive\n      \"If a finset `u` is contained in the sum of two sets `s - t`, we can find two finsets\n      `s'`, `t'` such that `s' ⊆ s`, `t' ⊆ t` and `u ⊆ s' - t'`.\"]\ntheorem subset_div {s t : Set α} :\n    ↑u ⊆ s / t → ∃ s' t' : Finset α, ↑s' ⊆ s ∧ ↑t' ⊆ t ∧ u ⊆ s' / t' :=\n  subset_set_image₂\n\n"}
{"name":"Finset.subset_div","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Div α\nu : Finset α\ns t : Set α\na✝ : HasSubset.Subset (↑u) (HDiv.hDiv s t)\n⊢ Exists fun s' => Exists fun t' => And (HasSubset.Subset (↑s') s) (And (HasSubset.Subset (↑t') t) (HasSubset.Subset u (HDiv.hDiv s' t')))","decl":"/-- If a finset `u` is contained in the product of two sets `s / t`, we can find two finsets `s'`,\n`t'` such that `s' ⊆ s`, `t' ⊆ t` and `u ⊆ s' / t'`. -/\n@[to_additive\n      \"If a finset `u` is contained in the sum of two sets `s - t`, we can find two finsets\n      `s'`, `t'` such that `s' ⊆ s`, `t' ⊆ t` and `u ⊆ s' - t'`.\"]\ntheorem subset_div {s t : Set α} :\n    ↑u ⊆ s / t → ∃ s' t' : Finset α, ↑s' ⊆ s ∧ ↑t' ⊆ t ∧ u ⊆ s' / t' :=\n  subset_set_image₂\n\n"}
{"name":"Finset.sup_sub_le","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq α\ninst✝² : Sub α\ninst✝¹ : SemilatticeSup β\ninst✝ : OrderBot β\ns t : Finset α\nf : α → β\na : β\n⊢ Iff (LE.le ((HSub.hSub s t).sup f) a) (∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem t y → LE.le (f (HSub.hSub x y)) a)","decl":"@[to_additive (attr := simp (default + 1))]\nlemma sup_div_le [SemilatticeSup β] [OrderBot β] {s t : Finset α} {f : α → β} {a : β} :\n    sup (s / t) f ≤ a ↔ ∀ x ∈ s, ∀ y ∈ t, f (x /  y) ≤ a :=\n  sup_image₂_le\n\n"}
{"name":"Finset.sup_div_le","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq α\ninst✝² : Div α\ninst✝¹ : SemilatticeSup β\ninst✝ : OrderBot β\ns t : Finset α\nf : α → β\na : β\n⊢ Iff (LE.le ((HDiv.hDiv s t).sup f) a) (∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem t y → LE.le (f (HDiv.hDiv x y)) a)","decl":"@[to_additive (attr := simp (default + 1))]\nlemma sup_div_le [SemilatticeSup β] [OrderBot β] {s t : Finset α} {f : α → β} {a : β} :\n    sup (s / t) f ≤ a ↔ ∀ x ∈ s, ∀ y ∈ t, f (x /  y) ≤ a :=\n  sup_image₂_le\n\n"}
{"name":"Finset.sup_sub_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq α\ninst✝² : Sub α\ninst✝¹ : SemilatticeSup β\ninst✝ : OrderBot β\ns t : Finset α\nf : α → β\n⊢ Eq ((HSub.hSub s t).sup f) (s.sup fun x => t.sup fun x_1 => f (HSub.hSub x x_1))","decl":"@[to_additive]\nlemma sup_div_left [SemilatticeSup β] [OrderBot β] (s t : Finset α) (f : α → β) :\n    sup (s / t) f = sup s fun x ↦ sup t (f <| x / ·) :=\n  sup_image₂_left ..\n\n"}
{"name":"Finset.sup_div_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq α\ninst✝² : Div α\ninst✝¹ : SemilatticeSup β\ninst✝ : OrderBot β\ns t : Finset α\nf : α → β\n⊢ Eq ((HDiv.hDiv s t).sup f) (s.sup fun x => t.sup fun x_1 => f (HDiv.hDiv x x_1))","decl":"@[to_additive]\nlemma sup_div_left [SemilatticeSup β] [OrderBot β] (s t : Finset α) (f : α → β) :\n    sup (s / t) f = sup s fun x ↦ sup t (f <| x / ·) :=\n  sup_image₂_left ..\n\n"}
{"name":"Finset.sup_sub_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq α\ninst✝² : Sub α\ninst✝¹ : SemilatticeSup β\ninst✝ : OrderBot β\ns t : Finset α\nf : α → β\n⊢ Eq ((HSub.hSub s t).sup f) (t.sup fun y => s.sup fun x => f (HSub.hSub x y))","decl":"@[to_additive]\nlemma sup_div_right [SemilatticeSup β] [OrderBot β] (s t : Finset α) (f : α → β) :\n    sup (s / t) f = sup t fun y ↦ sup s (f <| · / y) :=\n  sup_image₂_right ..\n\n"}
{"name":"Finset.sup_div_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq α\ninst✝² : Div α\ninst✝¹ : SemilatticeSup β\ninst✝ : OrderBot β\ns t : Finset α\nf : α → β\n⊢ Eq ((HDiv.hDiv s t).sup f) (t.sup fun y => s.sup fun x => f (HDiv.hDiv x y))","decl":"@[to_additive]\nlemma sup_div_right [SemilatticeSup β] [OrderBot β] (s t : Finset α) (f : α → β) :\n    sup (s / t) f = sup t fun y ↦ sup s (f <| · / y) :=\n  sup_image₂_right ..\n\n"}
{"name":"Finset.le_inf_div","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq α\ninst✝² : Div α\ninst✝¹ : SemilatticeInf β\ninst✝ : OrderTop β\ns t : Finset α\nf : α → β\na : β\n⊢ Iff (LE.le a ((HDiv.hDiv s t).inf f)) (∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem t y → LE.le a (f (HDiv.hDiv x y)))","decl":"@[to_additive (attr := simp (default + 1))]\nlemma le_inf_div [SemilatticeInf β] [OrderTop β] {s t : Finset α} {f : α → β} {a : β} :\n    a ≤ inf (s / t) f ↔ ∀ x ∈ s, ∀ y ∈ t, a ≤ f (x / y) :=\n  le_inf_image₂\n\n"}
{"name":"Finset.le_inf_sub","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq α\ninst✝² : Sub α\ninst✝¹ : SemilatticeInf β\ninst✝ : OrderTop β\ns t : Finset α\nf : α → β\na : β\n⊢ Iff (LE.le a ((HSub.hSub s t).inf f)) (∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem t y → LE.le a (f (HSub.hSub x y)))","decl":"@[to_additive (attr := simp (default + 1))]\nlemma le_inf_div [SemilatticeInf β] [OrderTop β] {s t : Finset α} {f : α → β} {a : β} :\n    a ≤ inf (s / t) f ↔ ∀ x ∈ s, ∀ y ∈ t, a ≤ f (x / y) :=\n  le_inf_image₂\n\n"}
{"name":"Finset.inf_div_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq α\ninst✝² : Div α\ninst✝¹ : SemilatticeInf β\ninst✝ : OrderTop β\ns t : Finset α\nf : α → β\n⊢ Eq ((HDiv.hDiv s t).inf f) (s.inf fun x => t.inf fun x_1 => f (HDiv.hDiv x x_1))","decl":"@[to_additive]\nlemma inf_div_left [SemilatticeInf β] [OrderTop β] (s t : Finset α) (f : α → β) :\n    inf (s / t) f = inf s fun x ↦ inf t (f <| x / ·) :=\n  inf_image₂_left ..\n\n"}
{"name":"Finset.inf_sub_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq α\ninst✝² : Sub α\ninst✝¹ : SemilatticeInf β\ninst✝ : OrderTop β\ns t : Finset α\nf : α → β\n⊢ Eq ((HSub.hSub s t).inf f) (s.inf fun x => t.inf fun x_1 => f (HSub.hSub x x_1))","decl":"@[to_additive]\nlemma inf_div_left [SemilatticeInf β] [OrderTop β] (s t : Finset α) (f : α → β) :\n    inf (s / t) f = inf s fun x ↦ inf t (f <| x / ·) :=\n  inf_image₂_left ..\n\n"}
{"name":"Finset.inf_sub_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq α\ninst✝² : Sub α\ninst✝¹ : SemilatticeInf β\ninst✝ : OrderTop β\ns t : Finset α\nf : α → β\n⊢ Eq ((HSub.hSub s t).inf f) (t.inf fun y => s.inf fun x => f (HSub.hSub x y))","decl":"@[to_additive]\nlemma inf_div_right [SemilatticeInf β] [OrderTop β] (s t : Finset α) (f : α → β) :\n    inf (s / t) f = inf t fun y ↦ inf s (f <| · / y) :=\n  inf_image₂_right ..\n\n"}
{"name":"Finset.inf_div_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq α\ninst✝² : Div α\ninst✝¹ : SemilatticeInf β\ninst✝ : OrderTop β\ns t : Finset α\nf : α → β\n⊢ Eq ((HDiv.hDiv s t).inf f) (t.inf fun y => s.inf fun x => f (HDiv.hDiv x y))","decl":"@[to_additive]\nlemma inf_div_right [SemilatticeInf β] [OrderTop β] (s t : Finset α) (f : α → β) :\n    inf (s / t) f = inf t fun y ↦ inf s (f <| · / y) :=\n  inf_image₂_right ..\n\n"}
{"name":"Finset.inter_add_union_subset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddCommSemigroup α\ns t : Finset α\n⊢ HasSubset.Subset (HAdd.hAdd (Inter.inter s t) (Union.union s t)) (HAdd.hAdd s t)","decl":"@[to_additive]\ntheorem inter_mul_union_subset : s ∩ t * (s ∪ t) ⊆ s * t :=\n  image₂_inter_union_subset mul_comm\n\n"}
{"name":"Finset.inter_mul_union_subset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : CommSemigroup α\ns t : Finset α\n⊢ HasSubset.Subset (HMul.hMul (Inter.inter s t) (Union.union s t)) (HMul.hMul s t)","decl":"@[to_additive]\ntheorem inter_mul_union_subset : s ∩ t * (s ∪ t) ⊆ s * t :=\n  image₂_inter_union_subset mul_comm\n\n"}
{"name":"Finset.union_mul_inter_subset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : CommSemigroup α\ns t : Finset α\n⊢ HasSubset.Subset (HMul.hMul (Union.union s t) (Inter.inter s t)) (HMul.hMul s t)","decl":"@[to_additive]\ntheorem union_mul_inter_subset : (s ∪ t) * (s ∩ t) ⊆ s * t :=\n  image₂_union_inter_subset mul_comm\n\n"}
{"name":"Finset.union_add_inter_subset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddCommSemigroup α\ns t : Finset α\n⊢ HasSubset.Subset (HAdd.hAdd (Union.union s t) (Inter.inter s t)) (HAdd.hAdd s t)","decl":"@[to_additive]\ntheorem union_mul_inter_subset : (s ∪ t) * (s ∩ t) ⊆ s * t :=\n  image₂_union_inter_subset mul_comm\n\n"}
{"name":"Finset.subset_add_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddZeroClass α\ns t : Finset α\nht : Membership.mem t 0\n⊢ HasSubset.Subset s (HAdd.hAdd s t)","decl":"@[to_additive]\ntheorem subset_mul_left (s : Finset α) {t : Finset α} (ht : (1 : α) ∈ t) : s ⊆ s * t := fun a ha =>\n  mem_mul.2 ⟨a, ha, 1, ht, mul_one _⟩\n\n"}
{"name":"Finset.subset_mul_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : MulOneClass α\ns t : Finset α\nht : Membership.mem t 1\n⊢ HasSubset.Subset s (HMul.hMul s t)","decl":"@[to_additive]\ntheorem subset_mul_left (s : Finset α) {t : Finset α} (ht : (1 : α) ∈ t) : s ⊆ s * t := fun a ha =>\n  mem_mul.2 ⟨a, ha, 1, ht, mul_one _⟩\n\n"}
{"name":"Finset.subset_add_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddZeroClass α\ns t : Finset α\nhs : Membership.mem s 0\n⊢ HasSubset.Subset t (HAdd.hAdd s t)","decl":"@[to_additive]\ntheorem subset_mul_right {s : Finset α} (t : Finset α) (hs : (1 : α) ∈ s) : t ⊆ s * t := fun a ha =>\n  mem_mul.2 ⟨1, hs, a, ha, one_mul _⟩\n\n"}
{"name":"Finset.subset_mul_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : MulOneClass α\ns t : Finset α\nhs : Membership.mem s 1\n⊢ HasSubset.Subset t (HMul.hMul s t)","decl":"@[to_additive]\ntheorem subset_mul_right {s : Finset α} (t : Finset α) (hs : (1 : α) ∈ s) : t ⊆ s * t := fun a ha =>\n  mem_mul.2 ⟨1, hs, a, ha, one_mul _⟩\n\n"}
{"name":"Finset.coe_singletonAddMonoidHom","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddZeroClass α\n⊢ Eq (⇑Finset.singletonAddMonoidHom) Singleton.singleton","decl":"@[to_additive (attr := simp)]\ntheorem coe_singletonMonoidHom : (singletonMonoidHom : α → Finset α) = singleton :=\n  rfl\n\n"}
{"name":"Finset.coe_singletonMonoidHom","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : MulOneClass α\n⊢ Eq (⇑Finset.singletonMonoidHom) Singleton.singleton","decl":"@[to_additive (attr := simp)]\ntheorem coe_singletonMonoidHom : (singletonMonoidHom : α → Finset α) = singleton :=\n  rfl\n\n"}
{"name":"Finset.singletonMonoidHom_apply","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : MulOneClass α\na : α\n⊢ Eq (Finset.singletonMonoidHom a) (Singleton.singleton a)","decl":"@[to_additive (attr := simp)]\ntheorem singletonMonoidHom_apply (a : α) : singletonMonoidHom a = {a} :=\n  rfl\n\n"}
{"name":"Finset.singletonAddMonoidHom_apply","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddZeroClass α\na : α\n⊢ Eq (Finset.singletonAddMonoidHom a) (Singleton.singleton a)","decl":"@[to_additive (attr := simp)]\ntheorem singletonMonoidHom_apply (a : α) : singletonMonoidHom a = {a} :=\n  rfl\n\n"}
{"name":"Finset.coe_coeMonoidHom","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : MulOneClass α\n⊢ Eq (⇑Finset.coeMonoidHom) CoeTC.coe","decl":"@[to_additive (attr := simp)]\ntheorem coe_coeMonoidHom : (coeMonoidHom : Finset α → Set α) = CoeTC.coe :=\n  rfl\n\n"}
{"name":"Finset.coe_coeAddMonoidHom","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddZeroClass α\n⊢ Eq (⇑Finset.coeAddMonoidHom) CoeTC.coe","decl":"@[to_additive (attr := simp)]\ntheorem coe_coeMonoidHom : (coeMonoidHom : Finset α → Set α) = CoeTC.coe :=\n  rfl\n\n"}
{"name":"Finset.coeMonoidHom_apply","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : MulOneClass α\ns : Finset α\n⊢ Eq (Finset.coeMonoidHom s) ↑s","decl":"@[to_additive (attr := simp)]\ntheorem coeMonoidHom_apply (s : Finset α) : coeMonoidHom s = s :=\n  rfl\n\n"}
{"name":"Finset.coeAddMonoidHom_apply","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddZeroClass α\ns : Finset α\n⊢ Eq (Finset.coeAddMonoidHom s) ↑s","decl":"@[to_additive (attr := simp)]\ntheorem coeMonoidHom_apply (s : Finset α) : coeMonoidHom s = s :=\n  rfl\n\n"}
{"name":"Finset.imageMonoidHom_apply","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : DecidableEq α\ninst✝⁴ : DecidableEq β\ninst✝³ : MulOneClass α\ninst✝² : MulOneClass β\ninst✝¹ : FunLike F α β\ninst✝ : MonoidHomClass F α β\nf : F\na✝ : Finset α\n⊢ Eq ((Finset.imageMonoidHom f) a✝) ((Finset.imageMulHom f).toFun a✝)","decl":"/-- Lift a `MonoidHom` to `Finset` via `image`. -/\n@[to_additive (attr := simps) \"Lift an `add_monoid_hom` to `Finset` via `image`\"]\ndef imageMonoidHom [MulOneClass β] [FunLike F α β] [MonoidHomClass F α β] (f : F) :\n    Finset α →* Finset β :=\n  { imageMulHom f, imageOneHom f with }\n\n"}
{"name":"Finset.imageAddMonoidHom_apply","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : DecidableEq α\ninst✝⁴ : DecidableEq β\ninst✝³ : AddZeroClass α\ninst✝² : AddZeroClass β\ninst✝¹ : FunLike F α β\ninst✝ : AddMonoidHomClass F α β\nf : F\na✝ : Finset α\n⊢ Eq ((Finset.imageAddMonoidHom f) a✝) ((Finset.imageAddHom f).toFun a✝)","decl":"/-- Lift a `MonoidHom` to `Finset` via `image`. -/\n@[to_additive (attr := simps) \"Lift an `add_monoid_hom` to `Finset` via `image`\"]\ndef imageMonoidHom [MulOneClass β] [FunLike F α β] [MonoidHomClass F α β] (f : F) :\n    Finset α →* Finset β :=\n  { imageMulHom f, imageOneHom f with }\n\n"}
{"name":"Finset.coe_pow","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Monoid α\ns : Finset α\nn : Nat\n⊢ Eq (↑(HPow.hPow s n)) (HPow.hPow (↑s) n)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_pow (s : Finset α) (n : ℕ) : ↑(s ^ n) = (s : Set α) ^ n := by\n  change ↑(npowRec n s) = (s : Set α) ^ n\n  induction' n with n ih\n  · rw [npowRec, pow_zero, coe_one]\n  · rw [npowRec, pow_succ, coe_mul, ih]\n\n"}
{"name":"Finset.coe_nsmul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddMonoid α\ns : Finset α\nn : Nat\n⊢ Eq (↑(HSMul.hSMul n s)) (HSMul.hSMul n ↑s)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_pow (s : Finset α) (n : ℕ) : ↑(s ^ n) = (s : Set α) ^ n := by\n  change ↑(npowRec n s) = (s : Set α) ^ n\n  induction' n with n ih\n  · rw [npowRec, pow_zero, coe_one]\n  · rw [npowRec, pow_succ, coe_mul, ih]\n\n"}
{"name":"Finset.pow_right_monotone","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Monoid α\ns : Finset α\nhs : Membership.mem s 1\n⊢ Monotone fun x => HPow.hPow s x","decl":"@[to_additive]\nprotected lemma pow_right_monotone (hs : 1 ∈ s) : Monotone (s ^ ·) :=\n  pow_right_monotone <| one_subset.2 hs\n\n"}
{"name":"Finset.nsmul_right_monotone","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddMonoid α\ns : Finset α\nhs : Membership.mem s 0\n⊢ Monotone fun x => HSMul.hSMul x s","decl":"@[to_additive]\nprotected lemma pow_right_monotone (hs : 1 ∈ s) : Monotone (s ^ ·) :=\n  pow_right_monotone <| one_subset.2 hs\n\n"}
{"name":"Finset.nsmul_subset_nsmul_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddMonoid α\ns t : Finset α\nn : Nat\nhst : HasSubset.Subset s t\n⊢ HasSubset.Subset (HSMul.hSMul n s) (HSMul.hSMul n t)","decl":"@[to_additive (attr := gcongr)]\nlemma pow_subset_pow_left (hst : s ⊆ t) : s ^ n ⊆ t ^ n := subset_of_le (pow_left_mono n hst)\n\n"}
{"name":"Finset.pow_subset_pow_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Monoid α\ns t : Finset α\nn : Nat\nhst : HasSubset.Subset s t\n⊢ HasSubset.Subset (HPow.hPow s n) (HPow.hPow t n)","decl":"@[to_additive (attr := gcongr)]\nlemma pow_subset_pow_left (hst : s ⊆ t) : s ^ n ⊆ t ^ n := subset_of_le (pow_left_mono n hst)\n\n"}
{"name":"Finset.pow_subset_pow_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Monoid α\ns : Finset α\nm n : Nat\nhs : Membership.mem s 1\nhmn : LE.le m n\n⊢ HasSubset.Subset (HPow.hPow s m) (HPow.hPow s n)","decl":"@[to_additive (attr := gcongr)]\nlemma pow_subset_pow_right (hs : 1 ∈ s) (hmn : m ≤ n) : s ^ m ⊆ s ^ n :=\n  Finset.pow_right_monotone hs hmn\n\n"}
{"name":"Finset.nsmul_subset_nsmul_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddMonoid α\ns : Finset α\nm n : Nat\nhs : Membership.mem s 0\nhmn : LE.le m n\n⊢ HasSubset.Subset (HSMul.hSMul m s) (HSMul.hSMul n s)","decl":"@[to_additive (attr := gcongr)]\nlemma pow_subset_pow_right (hs : 1 ∈ s) (hmn : m ≤ n) : s ^ m ⊆ s ^ n :=\n  Finset.pow_right_monotone hs hmn\n\n"}
{"name":"Finset.pow_subset_pow","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Monoid α\ns t : Finset α\nm n : Nat\nhst : HasSubset.Subset s t\nht : Membership.mem t 1\nhmn : LE.le m n\n⊢ HasSubset.Subset (HPow.hPow s m) (HPow.hPow t n)","decl":"@[to_additive (attr := gcongr)]\nlemma pow_subset_pow (hst : s ⊆ t) (ht : 1 ∈ t) (hmn : m ≤ n) : s ^ m ⊆ t ^ n :=\n  (pow_subset_pow_left hst).trans (pow_subset_pow_right ht hmn)\n\n"}
{"name":"Finset.nsmul_subset_nsmul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddMonoid α\ns t : Finset α\nm n : Nat\nhst : HasSubset.Subset s t\nht : Membership.mem t 0\nhmn : LE.le m n\n⊢ HasSubset.Subset (HSMul.hSMul m s) (HSMul.hSMul n t)","decl":"@[to_additive (attr := gcongr)]\nlemma pow_subset_pow (hst : s ⊆ t) (ht : 1 ∈ t) (hmn : m ≤ n) : s ^ m ⊆ t ^ n :=\n  (pow_subset_pow_left hst).trans (pow_subset_pow_right ht hmn)\n\n"}
{"name":"Finset.subset_nsmul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddMonoid α\ns : Finset α\nn : Nat\nhs : Membership.mem s 0\nhn : Ne n 0\n⊢ HasSubset.Subset s (HSMul.hSMul n s)","decl":"@[to_additive]\nlemma subset_pow (hs : 1 ∈ s) (hn : n ≠ 0) : s ⊆ s ^ n := by\n  simpa using pow_subset_pow_right hs <| Nat.one_le_iff_ne_zero.2 hn\n\n"}
{"name":"Finset.subset_pow","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Monoid α\ns : Finset α\nn : Nat\nhs : Membership.mem s 1\nhn : Ne n 0\n⊢ HasSubset.Subset s (HPow.hPow s n)","decl":"@[to_additive]\nlemma subset_pow (hs : 1 ∈ s) (hn : n ≠ 0) : s ⊆ s ^ n := by\n  simpa using pow_subset_pow_right hs <| Nat.one_le_iff_ne_zero.2 hn\n\n"}
{"name":"Finset.pow_subset_pow_of_one_mem","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Monoid α\ns : Finset α\nm n : Nat\nhs : Membership.mem s 1\nhmn : LE.le m n\n⊢ HasSubset.Subset (HPow.hPow s m) (HPow.hPow s n)","decl":"@[deprecated (since := \"2024-11-19\")] alias pow_subset_pow_of_one_mem := pow_subset_pow_right\n\n"}
{"name":"Finset.nsmul_subset_nsmul_of_zero_mem","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddMonoid α\ns : Finset α\nm n : Nat\nhs : Membership.mem s 0\nhmn : LE.le m n\n⊢ HasSubset.Subset (HSMul.hSMul m s) (HSMul.hSMul n s)","decl":"@[deprecated (since := \"2024-11-19\")]\nalias nsmul_subset_nsmul_of_zero_mem := nsmul_subset_nsmul_right\n\n"}
{"name":"Finset.pow_subset_pow_mul_of_sq_subset_mul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Monoid α\ns t : Finset α\nn : Nat\nhst : HasSubset.Subset (HPow.hPow s 2) (HMul.hMul t s)\nhn : Ne n 0\n⊢ HasSubset.Subset (HPow.hPow s n) (HMul.hMul (HPow.hPow t (HSub.hSub n 1)) s)","decl":"@[to_additive]\nlemma pow_subset_pow_mul_of_sq_subset_mul (hst : s ^ 2 ⊆ t * s) (hn : n ≠ 0) :\n    s ^ n ⊆ t ^ (n - 1) * s := subset_of_le (pow_le_pow_mul_of_sq_le_mul hst hn)\n\n"}
{"name":"Finset.nsmul_subset_nsmul_add_of_sq_subset_add","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddMonoid α\ns t : Finset α\nn : Nat\nhst : HasSubset.Subset (HSMul.hSMul 2 s) (HAdd.hAdd t s)\nhn : Ne n 0\n⊢ HasSubset.Subset (HSMul.hSMul n s) (HAdd.hAdd (HSMul.hSMul (HSub.hSub n 1) t) s)","decl":"@[to_additive]\nlemma pow_subset_pow_mul_of_sq_subset_mul (hst : s ^ 2 ⊆ t * s) (hn : n ≠ 0) :\n    s ^ n ⊆ t ^ (n - 1) * s := subset_of_le (pow_le_pow_mul_of_sq_le_mul hst hn)\n\n"}
{"name":"Finset.empty_pow","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Monoid α\nn : Nat\nhn : Ne n 0\n⊢ Eq (HPow.hPow EmptyCollection.emptyCollection n) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp) nsmul_empty]\nlemma empty_pow (hn : n ≠ 0) : (∅ : Finset α) ^ n = ∅ := match n with | n + 1 => by simp [pow_succ]\n\n"}
{"name":"Finset.nsmul_empty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddMonoid α\nn : Nat\nhn : Ne n 0\n⊢ Eq (HSMul.hSMul n EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp) nsmul_empty]\nlemma empty_pow (hn : n ≠ 0) : (∅ : Finset α) ^ n = ∅ := match n with | n + 1 => by simp [pow_succ]\n\n"}
{"name":"Finset.empty_nsmul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddMonoid α\nn : Nat\nhn : Ne n 0\n⊢ Eq (HSMul.hSMul n EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[deprecated (since := \"2024-10-21\")] alias empty_nsmul := nsmul_empty\n\n"}
{"name":"Finset.Nonempty.pow","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Monoid α\ns : Finset α\nhs : s.Nonempty\nn : Nat\n⊢ (HPow.hPow s n).Nonempty","decl":"@[to_additive]\nlemma Nonempty.pow (hs : s.Nonempty) : ∀ {n}, (s ^ n).Nonempty\n  | 0 => by simp\n  | n + 1 => by rw [pow_succ]; exact hs.pow.mul hs\n\n"}
{"name":"Finset.Nonempty.nsmul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddMonoid α\ns : Finset α\nhs : s.Nonempty\nn : Nat\n⊢ (HSMul.hSMul n s).Nonempty","decl":"@[to_additive]\nlemma Nonempty.pow (hs : s.Nonempty) : ∀ {n}, (s ^ n).Nonempty\n  | 0 => by simp\n  | n + 1 => by rw [pow_succ]; exact hs.pow.mul hs\n\n"}
{"name":"Finset.nsmul_eq_empty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddMonoid α\ns : Finset α\nn : Nat\n⊢ Iff (Eq (HSMul.hSMul n s) EmptyCollection.emptyCollection) (And (Eq s EmptyCollection.emptyCollection) (Ne n 0))","decl":"set_option push_neg.use_distrib true in\n@[to_additive (attr := simp)] lemma pow_eq_empty : s ^ n = ∅ ↔ s = ∅ ∧ n ≠ 0 := by\n  constructor\n  · contrapose!\n    rintro (hs | rfl)\n    -- TODO: The `nonempty_iff_ne_empty` would be unnecessary if `push_neg` knew how to simplify\n    -- `s ≠ ∅` to `s.Nonempty` when `s : Finset α`.\n    -- See https://leanprover.zulipchat.com/#narrow/channel/287929-mathlib4/topic/push_neg.20extensibility\n    · exact nonempty_iff_ne_empty.1 (nonempty_iff_ne_empty.2 hs).pow\n    · rw [← nonempty_iff_ne_empty]\n      simp\n  · rintro ⟨rfl, hn⟩\n    exact empty_pow hn\n\n"}
{"name":"Finset.pow_eq_empty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Monoid α\ns : Finset α\nn : Nat\n⊢ Iff (Eq (HPow.hPow s n) EmptyCollection.emptyCollection) (And (Eq s EmptyCollection.emptyCollection) (Ne n 0))","decl":"set_option push_neg.use_distrib true in\n@[to_additive (attr := simp)] lemma pow_eq_empty : s ^ n = ∅ ↔ s = ∅ ∧ n ≠ 0 := by\n  constructor\n  · contrapose!\n    rintro (hs | rfl)\n    -- TODO: The `nonempty_iff_ne_empty` would be unnecessary if `push_neg` knew how to simplify\n    -- `s ≠ ∅` to `s.Nonempty` when `s : Finset α`.\n    -- See https://leanprover.zulipchat.com/#narrow/channel/287929-mathlib4/topic/push_neg.20extensibility\n    · exact nonempty_iff_ne_empty.1 (nonempty_iff_ne_empty.2 hs).pow\n    · rw [← nonempty_iff_ne_empty]\n      simp\n  · rintro ⟨rfl, hn⟩\n    exact empty_pow hn\n\n"}
{"name":"Finset.singleton_pow","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Monoid α\na : α\nn : Nat\n⊢ Eq (HPow.hPow (Singleton.singleton a) n) (Singleton.singleton (HPow.hPow a n))","decl":"@[to_additive (attr := simp) nsmul_singleton]\nlemma singleton_pow (a : α) : ∀ n, ({a} : Finset α) ^ n = {a ^ n}\n  | 0 => by simp [singleton_one]\n  | n + 1 => by simp [pow_succ, singleton_pow _ n]\n\n"}
{"name":"Finset.nsmul_singleton","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddMonoid α\na : α\nn : Nat\n⊢ Eq (HSMul.hSMul n (Singleton.singleton a)) (Singleton.singleton (HSMul.hSMul n a))","decl":"@[to_additive (attr := simp) nsmul_singleton]\nlemma singleton_pow (a : α) : ∀ n, ({a} : Finset α) ^ n = {a ^ n}\n  | 0 => by simp [singleton_one]\n  | n + 1 => by simp [pow_succ, singleton_pow _ n]\n\n"}
{"name":"Finset.nsmul_mem_nsmul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddMonoid α\ns : Finset α\na : α\nn : Nat\nha : Membership.mem s a\n⊢ Membership.mem (HSMul.hSMul n s) (HSMul.hSMul n a)","decl":"@[to_additive] lemma pow_mem_pow (ha : a ∈ s) : a ^ n ∈ s ^ n := by\n  simpa using pow_subset_pow_left (singleton_subset_iff.2 ha)\n\n"}
{"name":"Finset.pow_mem_pow","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Monoid α\ns : Finset α\na : α\nn : Nat\nha : Membership.mem s a\n⊢ Membership.mem (HPow.hPow s n) (HPow.hPow a n)","decl":"@[to_additive] lemma pow_mem_pow (ha : a ∈ s) : a ^ n ∈ s ^ n := by\n  simpa using pow_subset_pow_left (singleton_subset_iff.2 ha)\n\n"}
{"name":"Finset.one_mem_pow","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Monoid α\ns : Finset α\nn : Nat\nhs : Membership.mem s 1\n⊢ Membership.mem (HPow.hPow s n) 1","decl":"@[to_additive] lemma one_mem_pow (hs : 1 ∈ s) : 1 ∈ s ^ n := by simpa using pow_mem_pow hs\n\n"}
{"name":"Finset.zero_mem_nsmul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddMonoid α\ns : Finset α\nn : Nat\nhs : Membership.mem s 0\n⊢ Membership.mem (HSMul.hSMul n s) 0","decl":"@[to_additive] lemma one_mem_pow (hs : 1 ∈ s) : 1 ∈ s ^ n := by simpa using pow_mem_pow hs\n\n"}
{"name":"Finset.inter_pow_subset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Monoid α\ns t : Finset α\nn : Nat\n⊢ HasSubset.Subset (HPow.hPow (Inter.inter s t) n) (Inter.inter (HPow.hPow s n) (HPow.hPow t n))","decl":"@[to_additive]\nlemma inter_pow_subset : (s ∩ t) ^ n ⊆ s ^ n ∩ t ^ n := by apply subset_inter <;> gcongr <;> simp\n\n"}
{"name":"Finset.inter_nsmul_subset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddMonoid α\ns t : Finset α\nn : Nat\n⊢ HasSubset.Subset (HSMul.hSMul n (Inter.inter s t)) (Inter.inter (HSMul.hSMul n s) (HSMul.hSMul n t))","decl":"@[to_additive]\nlemma inter_pow_subset : (s ∩ t) ^ n ⊆ s ^ n ∩ t ^ n := by apply subset_inter <;> gcongr <;> simp\n\n"}
{"name":"Finset.coe_list_prod","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Monoid α\ns : List (Finset α)\n⊢ Eq (↑s.prod) (List.map Finset.toSet s).prod","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_list_prod (s : List (Finset α)) : (↑s.prod : Set α) = (s.map (↑)).prod :=\n  map_list_prod (coeMonoidHom : Finset α →* Set α) _\n\n"}
{"name":"Finset.coe_list_sum","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddMonoid α\ns : List (Finset α)\n⊢ Eq (↑s.sum) (List.map Finset.toSet s).sum","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_list_prod (s : List (Finset α)) : (↑s.prod : Set α) = (s.map (↑)).prod :=\n  map_list_prod (coeMonoidHom : Finset α →* Set α) _\n\n"}
{"name":"Finset.mem_sum_list_ofFn","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddMonoid α\nn : Nat\na : α\ns : Fin n → Finset α\n⊢ Iff (Membership.mem (List.ofFn s).sum a) (Exists fun f => Eq (List.ofFn fun i => ↑(f i)).sum a)","decl":"@[to_additive]\ntheorem mem_prod_list_ofFn {a : α} {s : Fin n → Finset α} :\n    a ∈ (List.ofFn s).prod ↔ ∃ f : ∀ i : Fin n, s i, (List.ofFn fun i => (f i : α)).prod = a := by\n  rw [← mem_coe, coe_list_prod, List.map_ofFn, Set.mem_prod_list_ofFn]\n  rfl\n\n"}
{"name":"Finset.mem_prod_list_ofFn","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Monoid α\nn : Nat\na : α\ns : Fin n → Finset α\n⊢ Iff (Membership.mem (List.ofFn s).prod a) (Exists fun f => Eq (List.ofFn fun i => ↑(f i)).prod a)","decl":"@[to_additive]\ntheorem mem_prod_list_ofFn {a : α} {s : Fin n → Finset α} :\n    a ∈ (List.ofFn s).prod ↔ ∃ f : ∀ i : Fin n, s i, (List.ofFn fun i => (f i : α)).prod = a := by\n  rw [← mem_coe, coe_list_prod, List.map_ofFn, Set.mem_prod_list_ofFn]\n  rfl\n\n"}
{"name":"Finset.mem_pow","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Monoid α\ns : Finset α\na : α\nn : Nat\n⊢ Iff (Membership.mem (HPow.hPow s n) a) (Exists fun f => Eq (List.ofFn fun i => ↑(f i)).prod a)","decl":"@[to_additive]\ntheorem mem_pow {a : α} {n : ℕ} :\n    a ∈ s ^ n ↔ ∃ f : Fin n → s, (List.ofFn fun i => ↑(f i)).prod = a := by\n  simp [← mem_coe, coe_pow, Set.mem_pow]\n\n"}
{"name":"Finset.mem_nsmul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddMonoid α\ns : Finset α\na : α\nn : Nat\n⊢ Iff (Membership.mem (HSMul.hSMul n s) a) (Exists fun f => Eq (List.ofFn fun i => ↑(f i)).sum a)","decl":"@[to_additive]\ntheorem mem_pow {a : α} {n : ℕ} :\n    a ∈ s ^ n ↔ ∃ f : Fin n → s, (List.ofFn fun i => ↑(f i)).prod = a := by\n  simp [← mem_coe, coe_pow, Set.mem_pow]\n\n"}
{"name":"Finset.card_nsmul_le","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddMonoid α\ns : Finset α\nn : Nat\n⊢ LE.le (HSMul.hSMul n s).card (HPow.hPow s.card n)","decl":"@[to_additive]\nlemma card_pow_le : ∀ {n}, (s ^ n).card ≤ s.card ^ n\n  | 0 => by simp\n  | n + 1 => by rw [pow_succ, pow_succ]; refine card_mul_le.trans (by gcongr; exact card_pow_le)\n\n"}
{"name":"Finset.card_pow_le","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Monoid α\ns : Finset α\nn : Nat\n⊢ LE.le (HPow.hPow s n).card (HPow.hPow s.card n)","decl":"@[to_additive]\nlemma card_pow_le : ∀ {n}, (s ^ n).card ≤ s.card ^ n\n  | 0 => by simp\n  | n + 1 => by rw [pow_succ, pow_succ]; refine card_mul_le.trans (by gcongr; exact card_pow_le)\n\n"}
{"name":"Finset.mul_univ_of_one_mem","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : Monoid α\ns : Finset α\ninst✝ : Fintype α\nhs : Membership.mem s 1\n⊢ Eq (HMul.hMul s Finset.univ) Finset.univ","decl":"@[to_additive]\ntheorem mul_univ_of_one_mem [Fintype α] (hs : (1 : α) ∈ s) : s * univ = univ :=\n  eq_univ_iff_forall.2 fun _ => mem_mul.2 ⟨_, hs, _, mem_univ _, one_mul _⟩\n\n"}
{"name":"Finset.add_univ_of_zero_mem","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : AddMonoid α\ns : Finset α\ninst✝ : Fintype α\nhs : Membership.mem s 0\n⊢ Eq (HAdd.hAdd s Finset.univ) Finset.univ","decl":"@[to_additive]\ntheorem mul_univ_of_one_mem [Fintype α] (hs : (1 : α) ∈ s) : s * univ = univ :=\n  eq_univ_iff_forall.2 fun _ => mem_mul.2 ⟨_, hs, _, mem_univ _, one_mul _⟩\n\n"}
{"name":"Finset.univ_add_of_zero_mem","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : AddMonoid α\nt : Finset α\ninst✝ : Fintype α\nht : Membership.mem t 0\n⊢ Eq (HAdd.hAdd Finset.univ t) Finset.univ","decl":"@[to_additive]\ntheorem univ_mul_of_one_mem [Fintype α] (ht : (1 : α) ∈ t) : univ * t = univ :=\n  eq_univ_iff_forall.2 fun _ => mem_mul.2 ⟨_, mem_univ _, _, ht, mul_one _⟩\n\n"}
{"name":"Finset.univ_mul_of_one_mem","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : Monoid α\nt : Finset α\ninst✝ : Fintype α\nht : Membership.mem t 1\n⊢ Eq (HMul.hMul Finset.univ t) Finset.univ","decl":"@[to_additive]\ntheorem univ_mul_of_one_mem [Fintype α] (ht : (1 : α) ∈ t) : univ * t = univ :=\n  eq_univ_iff_forall.2 fun _ => mem_mul.2 ⟨_, mem_univ _, _, ht, mul_one _⟩\n\n"}
{"name":"Finset.univ_mul_univ","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : Monoid α\ninst✝ : Fintype α\n⊢ Eq (HMul.hMul Finset.univ Finset.univ) Finset.univ","decl":"@[to_additive (attr := simp)]\ntheorem univ_mul_univ [Fintype α] : (univ : Finset α) * univ = univ :=\n  mul_univ_of_one_mem <| mem_univ _\n\n"}
{"name":"Finset.univ_add_univ","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : AddMonoid α\ninst✝ : Fintype α\n⊢ Eq (HAdd.hAdd Finset.univ Finset.univ) Finset.univ","decl":"@[to_additive (attr := simp)]\ntheorem univ_mul_univ [Fintype α] : (univ : Finset α) * univ = univ :=\n  mul_univ_of_one_mem <| mem_univ _\n\n"}
{"name":"Finset.nsmul_univ","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : AddMonoid α\nn : Nat\ninst✝ : Fintype α\nhn : Ne n 0\n⊢ Eq (HSMul.hSMul n Finset.univ) Finset.univ","decl":"@[to_additive (attr := simp) nsmul_univ]\ntheorem univ_pow [Fintype α] (hn : n ≠ 0) : (univ : Finset α) ^ n = univ :=\n  coe_injective <| by rw [coe_pow, coe_univ, Set.univ_pow hn]\n\n"}
{"name":"Finset.univ_pow","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : Monoid α\nn : Nat\ninst✝ : Fintype α\nhn : Ne n 0\n⊢ Eq (HPow.hPow Finset.univ n) Finset.univ","decl":"@[to_additive (attr := simp) nsmul_univ]\ntheorem univ_pow [Fintype α] (hn : n ≠ 0) : (univ : Finset α) ^ n = univ :=\n  coe_injective <| by rw [coe_pow, coe_univ, Set.univ_pow hn]\n\n"}
{"name":"IsUnit.finset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Monoid α\na : α\na✝ : IsUnit a\n⊢ IsUnit (Singleton.singleton a)","decl":"@[to_additive]\nprotected theorem _root_.IsUnit.finset : IsUnit a → IsUnit ({a} : Finset α) :=\n  IsUnit.map (singletonMonoidHom : α →* Finset α)\n\n"}
{"name":"IsAddUnit.finset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddMonoid α\na : α\na✝ : IsAddUnit a\n⊢ IsAddUnit (Singleton.singleton a)","decl":"@[to_additive]\nprotected theorem _root_.IsUnit.finset : IsUnit a → IsUnit ({a} : Finset α) :=\n  IsUnit.map (singletonMonoidHom : α →* Finset α)\n\n"}
{"name":"Finset.image_op_nsmul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddMonoid α\ns : Finset α\nn : Nat\n⊢ Eq (Finset.image AddOpposite.op (HSMul.hSMul n s)) (HSMul.hSMul n (Finset.image AddOpposite.op s))","decl":"@[to_additive]\nlemma image_op_pow (s : Finset α) : ∀ n : ℕ, (s ^ n).image op = s.image op ^ n\n  | 0 => by simp [singleton_one]\n  | n + 1 => by rw [pow_succ, pow_succ', image_op_mul, image_op_pow]\n\n"}
{"name":"Finset.image_op_pow","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Monoid α\ns : Finset α\nn : Nat\n⊢ Eq (Finset.image MulOpposite.op (HPow.hPow s n)) (HPow.hPow (Finset.image MulOpposite.op s) n)","decl":"@[to_additive]\nlemma image_op_pow (s : Finset α) : ∀ n : ℕ, (s ^ n).image op = s.image op ^ n\n  | 0 => by simp [singleton_one]\n  | n + 1 => by rw [pow_succ, pow_succ', image_op_mul, image_op_pow]\n\n"}
{"name":"Finset.map_op_pow","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Monoid α\ns : Finset α\nn : Nat\n⊢ Eq (Finset.map MulOpposite.opEquiv.toEmbedding (HPow.hPow s n)) (HPow.hPow (Finset.map MulOpposite.opEquiv.toEmbedding s) n)","decl":"@[to_additive]\nlemma map_op_pow (s : Finset α) :\n    ∀ n : ℕ, (s ^ n).map opEquiv.toEmbedding = s.map opEquiv.toEmbedding ^ n\n  | 0 => by simp [singleton_one]\n  | n + 1 => by rw [pow_succ, pow_succ', map_op_mul, map_op_pow]\n\n"}
{"name":"Finset.map_op_nsmul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddMonoid α\ns : Finset α\nn : Nat\n⊢ Eq (Finset.map AddOpposite.opEquiv.toEmbedding (HSMul.hSMul n s)) (HSMul.hSMul n (Finset.map AddOpposite.opEquiv.toEmbedding s))","decl":"@[to_additive]\nlemma map_op_pow (s : Finset α) :\n    ∀ n : ℕ, (s ^ n).map opEquiv.toEmbedding = s.map opEquiv.toEmbedding ^ n\n  | 0 => by simp [singleton_one]\n  | n + 1 => by rw [pow_succ, pow_succ', map_op_mul, map_op_pow]\n\n"}
{"name":"Finset.product_pow","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq α\ninst✝² : DecidableEq β\ninst✝¹ : Monoid α\ninst✝ : Monoid β\ns : Finset α\nt : Finset β\nn : Nat\n⊢ Eq (HPow.hPow (SProd.sprod s t) n) (SProd.sprod (HPow.hPow s n) (HPow.hPow t n))","decl":"@[to_additive]\nlemma product_pow [Monoid β] (s : Finset α) (t : Finset β) : ∀ n, (s ×ˢ t) ^ n = (s ^ n) ×ˢ (t ^ n)\n  | 0 => by simp\n  | n + 1 => by simp [pow_succ, product_pow _ _ n]\n\n"}
{"name":"Finset.product_nsmul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq α\ninst✝² : DecidableEq β\ninst✝¹ : AddMonoid α\ninst✝ : AddMonoid β\ns : Finset α\nt : Finset β\nn : Nat\n⊢ Eq (HSMul.hSMul n (SProd.sprod s t)) (SProd.sprod (HSMul.hSMul n s) (HSMul.hSMul n t))","decl":"@[to_additive]\nlemma product_pow [Monoid β] (s : Finset α) (t : Finset β) : ∀ n, (s ×ˢ t) ^ n = (s ^ n) ×ˢ (t ^ n)\n  | 0 => by simp\n  | n + 1 => by simp [pow_succ, product_pow _ _ n]\n\n"}
{"name":"Finset.coe_prod","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : CommMonoid α\nι : Type u_5\ns : Finset ι\nf : ι → Finset α\n⊢ Eq (↑(s.prod fun i => f i)) (s.prod fun i => ↑(f i))","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_prod {ι : Type*} (s : Finset ι) (f : ι → Finset α) :\n    ↑(∏ i ∈ s, f i) = ∏ i ∈ s, (f i : Set α) :=\n  map_prod ((coeMonoidHom) : Finset α →* Set α) _ _\n\n"}
{"name":"Finset.coe_sum","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddCommMonoid α\nι : Type u_5\ns : Finset ι\nf : ι → Finset α\n⊢ Eq (↑(s.sum fun i => f i)) (s.sum fun i => ↑(f i))","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_prod {ι : Type*} (s : Finset ι) (f : ι → Finset α) :\n    ↑(∏ i ∈ s, f i) = ∏ i ∈ s, (f i : Set α) :=\n  map_prod ((coeMonoidHom) : Finset α →* Set α) _ _\n\n"}
{"name":"Finset.coe_zsmul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : SubtractionMonoid α\ns : Finset α\nn : Int\n⊢ Eq (↑(HSMul.hSMul n s)) (HSMul.hSMul n ↑s)","decl":"@[to_additive (attr := simp)]\ntheorem coe_zpow (s : Finset α) : ∀ n : ℤ, ↑(s ^ n) = (s : Set α) ^ n\n  | Int.ofNat _ => coe_pow _ _\n  | Int.negSucc n => by\n    refine (coe_inv _).trans ?_\n    exact congr_arg Inv.inv (coe_pow _ _)\n\n"}
{"name":"Finset.coe_zpow","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : DivisionMonoid α\ns : Finset α\nn : Int\n⊢ Eq (↑(HPow.hPow s n)) (HPow.hPow (↑s) n)","decl":"@[to_additive (attr := simp)]\ntheorem coe_zpow (s : Finset α) : ∀ n : ℤ, ↑(s ^ n) = (s : Set α) ^ n\n  | Int.ofNat _ => coe_pow _ _\n  | Int.negSucc n => by\n    refine (coe_inv _).trans ?_\n    exact congr_arg Inv.inv (coe_pow _ _)\n\n"}
{"name":"Finset.add_eq_zero_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : SubtractionMonoid α\ns t : Finset α\n⊢ Iff (Eq (HAdd.hAdd s t) 0) (Exists fun a => Exists fun b => And (Eq s (Singleton.singleton a)) (And (Eq t (Singleton.singleton b)) (Eq (HAdd.hAdd a b) 0)))","decl":"@[to_additive]\nprotected theorem mul_eq_one_iff : s * t = 1 ↔ ∃ a b, s = {a} ∧ t = {b} ∧ a * b = 1 := by\n  simp_rw [← coe_inj, coe_mul, coe_one, Set.mul_eq_one_iff, coe_singleton]\n\n"}
{"name":"Finset.mul_eq_one_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : DivisionMonoid α\ns t : Finset α\n⊢ Iff (Eq (HMul.hMul s t) 1) (Exists fun a => Exists fun b => And (Eq s (Singleton.singleton a)) (And (Eq t (Singleton.singleton b)) (Eq (HMul.hMul a b) 1)))","decl":"@[to_additive]\nprotected theorem mul_eq_one_iff : s * t = 1 ↔ ∃ a b, s = {a} ∧ t = {b} ∧ a * b = 1 := by\n  simp_rw [← coe_inj, coe_mul, coe_one, Set.mul_eq_one_iff, coe_singleton]\n\n"}
{"name":"Finset.isAddUnit_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : SubtractionMonoid α\ns : Finset α\n⊢ Iff (IsAddUnit s) (Exists fun a => And (Eq s (Singleton.singleton a)) (IsAddUnit a))","decl":"@[to_additive (attr := simp)]\ntheorem isUnit_iff : IsUnit s ↔ ∃ a, s = {a} ∧ IsUnit a := by\n  constructor\n  · rintro ⟨u, rfl⟩\n    obtain ⟨a, b, ha, hb, h⟩ := Finset.mul_eq_one_iff.1 u.mul_inv\n    refine ⟨a, ha, ⟨a, b, h, singleton_injective ?_⟩, rfl⟩\n    rw [← singleton_mul_singleton, ← ha, ← hb]\n    exact u.inv_mul\n  · rintro ⟨a, rfl, ha⟩\n    exact ha.finset\n\n"}
{"name":"Finset.isUnit_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : DivisionMonoid α\ns : Finset α\n⊢ Iff (IsUnit s) (Exists fun a => And (Eq s (Singleton.singleton a)) (IsUnit a))","decl":"@[to_additive (attr := simp)]\ntheorem isUnit_iff : IsUnit s ↔ ∃ a, s = {a} ∧ IsUnit a := by\n  constructor\n  · rintro ⟨u, rfl⟩\n    obtain ⟨a, b, ha, hb, h⟩ := Finset.mul_eq_one_iff.1 u.mul_inv\n    refine ⟨a, ha, ⟨a, b, h, singleton_injective ?_⟩, rfl⟩\n    rw [← singleton_mul_singleton, ← ha, ← hb]\n    exact u.inv_mul\n  · rintro ⟨a, rfl, ha⟩\n    exact ha.finset\n\n"}
{"name":"Finset.isUnit_coe","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : DivisionMonoid α\ns : Finset α\n⊢ Iff (IsUnit ↑s) (IsUnit s)","decl":"@[to_additive (attr := simp)]\ntheorem isUnit_coe : IsUnit (s : Set α) ↔ IsUnit s := by\n  simp_rw [isUnit_iff, Set.isUnit_iff, coe_eq_singleton]\n\n"}
{"name":"Finset.isAddUnit_coe","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : SubtractionMonoid α\ns : Finset α\n⊢ Iff (IsAddUnit ↑s) (IsAddUnit s)","decl":"@[to_additive (attr := simp)]\ntheorem isUnit_coe : IsUnit (s : Set α) ↔ IsUnit s := by\n  simp_rw [isUnit_iff, Set.isUnit_iff, coe_eq_singleton]\n\n"}
{"name":"Finset.univ_div_univ","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : DivisionMonoid α\ninst✝ : Fintype α\n⊢ Eq (HDiv.hDiv Finset.univ Finset.univ) Finset.univ","decl":"@[to_additive (attr := simp)]\nlemma univ_div_univ [Fintype α] : (univ / univ : Finset α) = univ := by simp [div_eq_mul_inv]\n\n"}
{"name":"Finset.univ_sub_univ","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : SubtractionMonoid α\ninst✝ : Fintype α\n⊢ Eq (HSub.hSub Finset.univ Finset.univ) Finset.univ","decl":"@[to_additive (attr := simp)]\nlemma univ_div_univ [Fintype α] : (univ / univ : Finset α) = univ := by simp [div_eq_mul_inv]\n\n"}
{"name":"Finset.subset_sub_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : SubtractionMonoid α\ns t : Finset α\nht : Membership.mem t 0\n⊢ HasSubset.Subset s (HSub.hSub s t)","decl":"@[to_additive] lemma subset_div_left (ht : 1 ∈ t) : s ⊆ s / t := by\n  rw [div_eq_mul_inv]; exact subset_mul_left _ <| by simpa\n\n"}
{"name":"Finset.subset_div_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : DivisionMonoid α\ns t : Finset α\nht : Membership.mem t 1\n⊢ HasSubset.Subset s (HDiv.hDiv s t)","decl":"@[to_additive] lemma subset_div_left (ht : 1 ∈ t) : s ⊆ s / t := by\n  rw [div_eq_mul_inv]; exact subset_mul_left _ <| by simpa\n\n"}
{"name":"Finset.neg_subset_sub_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : SubtractionMonoid α\ns t : Finset α\nhs : Membership.mem s 0\n⊢ HasSubset.Subset (Neg.neg t) (HSub.hSub s t)","decl":"@[to_additive] lemma inv_subset_div_right (hs : 1 ∈ s) : t⁻¹ ⊆ s / t := by\n  rw [div_eq_mul_inv]; exact subset_mul_right _ hs\n\n"}
{"name":"Finset.inv_subset_div_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : DivisionMonoid α\ns t : Finset α\nhs : Membership.mem s 1\n⊢ HasSubset.Subset (Inv.inv t) (HDiv.hDiv s t)","decl":"@[to_additive] lemma inv_subset_div_right (hs : 1 ∈ s) : t⁻¹ ⊆ s / t := by\n  rw [div_eq_mul_inv]; exact subset_mul_right _ hs\n\n"}
{"name":"Finset.empty_zpow","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : DivisionMonoid α\nn : Int\nhn : Ne n 0\n⊢ Eq (HPow.hPow EmptyCollection.emptyCollection n) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp) zsmul_empty]\nlemma empty_zpow (hn : n ≠ 0) : (∅ : Finset α) ^ n = ∅ := by cases n <;> aesop\n\n"}
{"name":"Finset.zsmul_empty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : SubtractionMonoid α\nn : Int\nhn : Ne n 0\n⊢ Eq (HSMul.hSMul n EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp) zsmul_empty]\nlemma empty_zpow (hn : n ≠ 0) : (∅ : Finset α) ^ n = ∅ := by cases n <;> aesop\n\n"}
{"name":"Finset.Nonempty.zsmul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : SubtractionMonoid α\ns : Finset α\nhs : s.Nonempty\nn : Int\n⊢ (HSMul.hSMul n s).Nonempty","decl":"@[to_additive]\nlemma Nonempty.zpow (hs : s.Nonempty) : ∀ {n : ℤ}, (s ^ n).Nonempty\n  | (n : ℕ) => hs.pow\n  | .negSucc n => by simpa using hs.pow\n\n"}
{"name":"Finset.Nonempty.zpow","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : DivisionMonoid α\ns : Finset α\nhs : s.Nonempty\nn : Int\n⊢ (HPow.hPow s n).Nonempty","decl":"@[to_additive]\nlemma Nonempty.zpow (hs : s.Nonempty) : ∀ {n : ℤ}, (s ^ n).Nonempty\n  | (n : ℕ) => hs.pow\n  | .negSucc n => by simpa using hs.pow\n\n"}
{"name":"Finset.zsmul_eq_empty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : SubtractionMonoid α\ns : Finset α\nn : Int\n⊢ Iff (Eq (HSMul.hSMul n s) EmptyCollection.emptyCollection) (And (Eq s EmptyCollection.emptyCollection) (Ne n 0))","decl":"set_option push_neg.use_distrib true in\n@[to_additive (attr := simp)] lemma zpow_eq_empty : s ^ n = ∅ ↔ s = ∅ ∧ n ≠ 0 := by\n  constructor\n  · contrapose!\n    rintro (hs | rfl)\n    · exact nonempty_iff_ne_empty.1 (nonempty_iff_ne_empty.2 hs).zpow\n    · rw [← nonempty_iff_ne_empty]\n      simp\n  · rintro ⟨rfl, hn⟩\n    exact empty_zpow hn\n\n"}
{"name":"Finset.zpow_eq_empty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : DivisionMonoid α\ns : Finset α\nn : Int\n⊢ Iff (Eq (HPow.hPow s n) EmptyCollection.emptyCollection) (And (Eq s EmptyCollection.emptyCollection) (Ne n 0))","decl":"set_option push_neg.use_distrib true in\n@[to_additive (attr := simp)] lemma zpow_eq_empty : s ^ n = ∅ ↔ s = ∅ ∧ n ≠ 0 := by\n  constructor\n  · contrapose!\n    rintro (hs | rfl)\n    · exact nonempty_iff_ne_empty.1 (nonempty_iff_ne_empty.2 hs).zpow\n    · rw [← nonempty_iff_ne_empty]\n      simp\n  · rintro ⟨rfl, hn⟩\n    exact empty_zpow hn\n\n"}
{"name":"Finset.zsmul_singleton","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : SubtractionMonoid α\na : α\nn : Int\n⊢ Eq (HSMul.hSMul n (Singleton.singleton a)) (Singleton.singleton (HSMul.hSMul n a))","decl":"@[to_additive (attr := simp) zsmul_singleton]\nlemma singleton_zpow (a : α) (n : ℤ) : ({a} : Finset α) ^ n = {a ^ n} := by cases n <;> simp\n\n"}
{"name":"Finset.singleton_zpow","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : DivisionMonoid α\na : α\nn : Int\n⊢ Eq (HPow.hPow (Singleton.singleton a) n) (Singleton.singleton (HPow.hPow a n))","decl":"@[to_additive (attr := simp) zsmul_singleton]\nlemma singleton_zpow (a : α) (n : ℤ) : ({a} : Finset α) ^ n = {a ^ n} := by cases n <;> simp\n\n"}
{"name":"Finset.one_mem_div_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Group α\ns t : Finset α\n⊢ Iff (Membership.mem (HDiv.hDiv s t) 1) (Not (Disjoint s t))","decl":"@[to_additive (attr := simp)]\ntheorem one_mem_div_iff : (1 : α) ∈ s / t ↔ ¬Disjoint s t := by\n  rw [← mem_coe, ← disjoint_coe, coe_div, Set.one_mem_div_iff]\n\n"}
{"name":"Finset.zero_mem_sub_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddGroup α\ns t : Finset α\n⊢ Iff (Membership.mem (HSub.hSub s t) 0) (Not (Disjoint s t))","decl":"@[to_additive (attr := simp)]\ntheorem one_mem_div_iff : (1 : α) ∈ s / t ↔ ¬Disjoint s t := by\n  rw [← mem_coe, ← disjoint_coe, coe_div, Set.one_mem_div_iff]\n\n"}
{"name":"Finset.zero_mem_neg_add_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddGroup α\ns t : Finset α\n⊢ Iff (Membership.mem (HAdd.hAdd (Neg.neg t) s) 0) (Not (Disjoint s t))","decl":"@[to_additive (attr := simp)]\nlemma one_mem_inv_mul_iff : (1 : α) ∈ t⁻¹ * s ↔ ¬Disjoint s t := by\n  aesop (add simp [not_disjoint_iff_nonempty_inter, mem_mul, mul_eq_one_iff_eq_inv,\n    Finset.Nonempty])\n\n"}
{"name":"Finset.one_mem_inv_mul_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Group α\ns t : Finset α\n⊢ Iff (Membership.mem (HMul.hMul (Inv.inv t) s) 1) (Not (Disjoint s t))","decl":"@[to_additive (attr := simp)]\nlemma one_mem_inv_mul_iff : (1 : α) ∈ t⁻¹ * s ↔ ¬Disjoint s t := by\n  aesop (add simp [not_disjoint_iff_nonempty_inter, mem_mul, mul_eq_one_iff_eq_inv,\n    Finset.Nonempty])\n\n"}
{"name":"Finset.not_one_mem_div_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Group α\ns t : Finset α\n⊢ Iff (Not (Membership.mem (HDiv.hDiv s t) 1)) (Disjoint s t)","decl":"@[to_additive]\ntheorem not_one_mem_div_iff : (1 : α) ∉ s / t ↔ Disjoint s t :=\n  one_mem_div_iff.not_left\n\n"}
{"name":"Finset.not_zero_mem_sub_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddGroup α\ns t : Finset α\n⊢ Iff (Not (Membership.mem (HSub.hSub s t) 0)) (Disjoint s t)","decl":"@[to_additive]\ntheorem not_one_mem_div_iff : (1 : α) ∉ s / t ↔ Disjoint s t :=\n  one_mem_div_iff.not_left\n\n"}
{"name":"Finset.not_zero_mem_neg_add_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddGroup α\ns t : Finset α\n⊢ Iff (Not (Membership.mem (HAdd.hAdd (Neg.neg t) s) 0)) (Disjoint s t)","decl":"@[to_additive]\nlemma not_one_mem_inv_mul_iff : (1 : α) ∉ t⁻¹ * s ↔ Disjoint s t := one_mem_inv_mul_iff.not_left\n\n"}
{"name":"Finset.not_one_mem_inv_mul_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Group α\ns t : Finset α\n⊢ Iff (Not (Membership.mem (HMul.hMul (Inv.inv t) s) 1)) (Disjoint s t)","decl":"@[to_additive]\nlemma not_one_mem_inv_mul_iff : (1 : α) ∉ t⁻¹ * s ↔ Disjoint s t := one_mem_inv_mul_iff.not_left\n\n"}
{"name":"Finset.Nonempty.zero_mem_sub","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddGroup α\ns : Finset α\nh : s.Nonempty\n⊢ Membership.mem (HSub.hSub s s) 0","decl":"@[to_additive]\ntheorem Nonempty.one_mem_div (h : s.Nonempty) : (1 : α) ∈ s / s :=\n  let ⟨a, ha⟩ := h\n  mem_div.2 ⟨a, ha, a, ha, div_self' _⟩\n\n"}
{"name":"Finset.Nonempty.one_mem_div","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Group α\ns : Finset α\nh : s.Nonempty\n⊢ Membership.mem (HDiv.hDiv s s) 1","decl":"@[to_additive]\ntheorem Nonempty.one_mem_div (h : s.Nonempty) : (1 : α) ∈ s / s :=\n  let ⟨a, ha⟩ := h\n  mem_div.2 ⟨a, ha, a, ha, div_self' _⟩\n\n"}
{"name":"Finset.isUnit_singleton","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Group α\na : α\n⊢ IsUnit (Singleton.singleton a)","decl":"@[to_additive]\ntheorem isUnit_singleton (a : α) : IsUnit ({a} : Finset α) :=\n  (Group.isUnit a).finset\n\n/- Porting note: not in simp nf; Added non-simpable part as `isUnit_iff_singleton_aux` below\nLeft-hand side simplifies from\n  IsUnit s\nto\n  ∃ a, s = {a} ∧ IsUnit a -/\n-- @[simp]\n"}
{"name":"Finset.isAddUnit_singleton","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddGroup α\na : α\n⊢ IsAddUnit (Singleton.singleton a)","decl":"@[to_additive]\ntheorem isUnit_singleton (a : α) : IsUnit ({a} : Finset α) :=\n  (Group.isUnit a).finset\n\n/- Porting note: not in simp nf; Added non-simpable part as `isUnit_iff_singleton_aux` below\nLeft-hand side simplifies from\n  IsUnit s\nto\n  ∃ a, s = {a} ∧ IsUnit a -/\n-- @[simp]\n"}
{"name":"Finset.isUnit_iff_singleton","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Group α\ns : Finset α\n⊢ Iff (IsUnit s) (Exists fun a => Eq s (Singleton.singleton a))","decl":"theorem isUnit_iff_singleton : IsUnit s ↔ ∃ a, s = {a} := by\n  simp only [isUnit_iff, Group.isUnit, and_true]\n\n"}
{"name":"Finset.isUnit_iff_singleton_aux","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_5\ninst✝ : Group α\ns : Finset α\n⊢ Iff (Exists fun a => And (Eq s (Singleton.singleton a)) (IsUnit a)) (Exists fun a => Eq s (Singleton.singleton a))","decl":"@[simp]\ntheorem isUnit_iff_singleton_aux {α} [Group α] {s : Finset α} :\n    (∃ a, s = {a} ∧ IsUnit a) ↔ ∃ a, s = {a} := by\n  simp only [Group.isUnit, and_true]\n\n"}
{"name":"Finset.image_add_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddGroup α\nt : Finset α\na : α\n⊢ Eq (Finset.image (fun b => HAdd.hAdd a b) t) (t.preimage (fun b => HAdd.hAdd (Neg.neg a) b) ⋯)","decl":"@[to_additive (attr := simp)]\ntheorem image_mul_left :\n    image (fun b => a * b) t = preimage t (fun b => a⁻¹ * b) (mul_right_injective _).injOn :=\n  coe_injective <| by simp\n\n"}
{"name":"Finset.image_mul_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Group α\nt : Finset α\na : α\n⊢ Eq (Finset.image (fun b => HMul.hMul a b) t) (t.preimage (fun b => HMul.hMul (Inv.inv a) b) ⋯)","decl":"@[to_additive (attr := simp)]\ntheorem image_mul_left :\n    image (fun b => a * b) t = preimage t (fun b => a⁻¹ * b) (mul_right_injective _).injOn :=\n  coe_injective <| by simp\n\n"}
{"name":"Finset.image_add_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddGroup α\nt : Finset α\nb : α\n⊢ Eq (Finset.image (fun x => HAdd.hAdd x b) t) (t.preimage (fun x => HAdd.hAdd x (Neg.neg b)) ⋯)","decl":"@[to_additive (attr := simp)]\ntheorem image_mul_right : image (· * b) t = preimage t (· * b⁻¹) (mul_left_injective _).injOn :=\n  coe_injective <| by simp\n\n"}
{"name":"Finset.image_mul_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Group α\nt : Finset α\nb : α\n⊢ Eq (Finset.image (fun x => HMul.hMul x b) t) (t.preimage (fun x => HMul.hMul x (Inv.inv b)) ⋯)","decl":"@[to_additive (attr := simp)]\ntheorem image_mul_right : image (· * b) t = preimage t (· * b⁻¹) (mul_left_injective _).injOn :=\n  coe_injective <| by simp\n\n"}
{"name":"Finset.image_add_left'","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddGroup α\nt : Finset α\na : α\n⊢ Eq (Finset.image (fun b => HAdd.hAdd (Neg.neg a) b) t) (t.preimage (fun b => HAdd.hAdd a b) ⋯)","decl":"@[to_additive]\ntheorem image_mul_left' :\n    image (fun b => a⁻¹ * b) t = preimage t (fun b => a * b) (mul_right_injective _).injOn := by\n  simp\n\n"}
{"name":"Finset.image_mul_left'","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Group α\nt : Finset α\na : α\n⊢ Eq (Finset.image (fun b => HMul.hMul (Inv.inv a) b) t) (t.preimage (fun b => HMul.hMul a b) ⋯)","decl":"@[to_additive]\ntheorem image_mul_left' :\n    image (fun b => a⁻¹ * b) t = preimage t (fun b => a * b) (mul_right_injective _).injOn := by\n  simp\n\n"}
{"name":"Finset.image_add_right'","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddGroup α\nt : Finset α\nb : α\n⊢ Eq (Finset.image (fun x => HAdd.hAdd x (Neg.neg b)) t) (t.preimage (fun x => HAdd.hAdd x b) ⋯)","decl":"@[to_additive]\ntheorem image_mul_right' :\n    image (· * b⁻¹) t = preimage t (· * b) (mul_left_injective _).injOn := by simp\n\n"}
{"name":"Finset.image_mul_right'","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Group α\nt : Finset α\nb : α\n⊢ Eq (Finset.image (fun x => HMul.hMul x (Inv.inv b)) t) (t.preimage (fun x => HMul.hMul x b) ⋯)","decl":"@[to_additive]\ntheorem image_mul_right' :\n    image (· * b⁻¹) t = preimage t (· * b) (mul_left_injective _).injOn := by simp\n\n"}
{"name":"Finset.image_inv","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : DecidableEq α\ninst✝⁴ : DecidableEq β\ninst✝³ : Group α\ninst✝² : DivisionMonoid β\ninst✝¹ : FunLike F α β\ninst✝ : MonoidHomClass F α β\nf : F\ns : Finset α\n⊢ Eq (Finset.image (⇑f) (Inv.inv s)) (Inv.inv (Finset.image (⇑f) s))","decl":"@[to_additive]\nlemma image_inv (f : F) (s : Finset α) : s⁻¹.image f = (s.image f)⁻¹ := image_comm (map_inv _)\n\n"}
{"name":"Finset.image_neg","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : DecidableEq α\ninst✝⁴ : DecidableEq β\ninst✝³ : AddGroup α\ninst✝² : SubtractionMonoid β\ninst✝¹ : FunLike F α β\ninst✝ : AddMonoidHomClass F α β\nf : F\ns : Finset α\n⊢ Eq (Finset.image (⇑f) (Neg.neg s)) (Neg.neg (Finset.image (⇑f) s))","decl":"@[to_additive]\nlemma image_inv (f : F) (s : Finset α) : s⁻¹.image f = (s.image f)⁻¹ := image_comm (map_inv _)\n\n"}
{"name":"Finset.image_div","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : DecidableEq α\ninst✝⁴ : DecidableEq β\ninst✝³ : Group α\ninst✝² : DivisionMonoid β\ninst✝¹ : FunLike F α β\ninst✝ : MonoidHomClass F α β\nf : F\ns t : Finset α\n⊢ Eq (Finset.image (⇑f) (HDiv.hDiv s t)) (HDiv.hDiv (Finset.image (⇑f) s) (Finset.image (⇑f) t))","decl":"theorem image_div : (s / t).image (f : α → β) = s.image f / t.image f :=\n  image_image₂_distrib <| map_div f\n\n"}
{"name":"Finset.preimage_mul_left_singleton","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : Group α\na b : α\n⊢ Eq ((Singleton.singleton b).preimage (fun x => HMul.hMul a x) ⋯) (Singleton.singleton (HMul.hMul (Inv.inv a) b))","decl":"@[to_additive (attr := simp)]\ntheorem preimage_mul_left_singleton :\n    preimage {b} (a * ·) (mul_right_injective _).injOn = {a⁻¹ * b} := by\n  classical rw [← image_mul_left', image_singleton]\n\n"}
{"name":"Finset.preimage_add_left_singleton","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\na b : α\n⊢ Eq ((Singleton.singleton b).preimage (fun x => HAdd.hAdd a x) ⋯) (Singleton.singleton (HAdd.hAdd (Neg.neg a) b))","decl":"@[to_additive (attr := simp)]\ntheorem preimage_mul_left_singleton :\n    preimage {b} (a * ·) (mul_right_injective _).injOn = {a⁻¹ * b} := by\n  classical rw [← image_mul_left', image_singleton]\n\n"}
{"name":"Finset.preimage_add_right_singleton","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\na b : α\n⊢ Eq ((Singleton.singleton b).preimage (fun x => HAdd.hAdd x a) ⋯) (Singleton.singleton (HAdd.hAdd b (Neg.neg a)))","decl":"@[to_additive (attr := simp)]\ntheorem preimage_mul_right_singleton :\n    preimage {b} (· * a) (mul_left_injective _).injOn = {b * a⁻¹} := by\n  classical rw [← image_mul_right', image_singleton]\n\n"}
{"name":"Finset.preimage_mul_right_singleton","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : Group α\na b : α\n⊢ Eq ((Singleton.singleton b).preimage (fun x => HMul.hMul x a) ⋯) (Singleton.singleton (HMul.hMul b (Inv.inv a)))","decl":"@[to_additive (attr := simp)]\ntheorem preimage_mul_right_singleton :\n    preimage {b} (· * a) (mul_left_injective _).injOn = {b * a⁻¹} := by\n  classical rw [← image_mul_right', image_singleton]\n\n"}
{"name":"Finset.preimage_add_left_zero","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\na : α\n⊢ Eq (Finset.preimage 0 (fun x => HAdd.hAdd a x) ⋯) (Singleton.singleton (Neg.neg a))","decl":"@[to_additive (attr := simp)]\ntheorem preimage_mul_left_one : preimage 1 (a * ·) (mul_right_injective _).injOn = {a⁻¹} := by\n  classical rw [← image_mul_left', image_one, mul_one]\n\n"}
{"name":"Finset.preimage_mul_left_one","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : Group α\na : α\n⊢ Eq (Finset.preimage 1 (fun x => HMul.hMul a x) ⋯) (Singleton.singleton (Inv.inv a))","decl":"@[to_additive (attr := simp)]\ntheorem preimage_mul_left_one : preimage 1 (a * ·) (mul_right_injective _).injOn = {a⁻¹} := by\n  classical rw [← image_mul_left', image_one, mul_one]\n\n"}
{"name":"Finset.preimage_mul_right_one","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : Group α\nb : α\n⊢ Eq (Finset.preimage 1 (fun x => HMul.hMul x b) ⋯) (Singleton.singleton (Inv.inv b))","decl":"@[to_additive (attr := simp)]\ntheorem preimage_mul_right_one : preimage 1 (· * b) (mul_left_injective _).injOn = {b⁻¹} := by\n  classical rw [← image_mul_right', image_one, one_mul]\n\n"}
{"name":"Finset.preimage_add_right_zero","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\nb : α\n⊢ Eq (Finset.preimage 0 (fun x => HAdd.hAdd x b) ⋯) (Singleton.singleton (Neg.neg b))","decl":"@[to_additive (attr := simp)]\ntheorem preimage_mul_right_one : preimage 1 (· * b) (mul_left_injective _).injOn = {b⁻¹} := by\n  classical rw [← image_mul_right', image_one, one_mul]\n\n"}
{"name":"Finset.preimage_add_left_zero'","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\na : α\n⊢ Eq (Finset.preimage 0 (fun x => HAdd.hAdd (Neg.neg a) x) ⋯) (Singleton.singleton a)","decl":"@[to_additive]\ntheorem preimage_mul_left_one' : preimage 1 (a⁻¹ * ·) (mul_right_injective _).injOn = {a} := by\n  rw [preimage_mul_left_one, inv_inv]\n\n"}
{"name":"Finset.preimage_mul_left_one'","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : Group α\na : α\n⊢ Eq (Finset.preimage 1 (fun x => HMul.hMul (Inv.inv a) x) ⋯) (Singleton.singleton a)","decl":"@[to_additive]\ntheorem preimage_mul_left_one' : preimage 1 (a⁻¹ * ·) (mul_right_injective _).injOn = {a} := by\n  rw [preimage_mul_left_one, inv_inv]\n\n"}
{"name":"Finset.preimage_add_right_zero'","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\nb : α\n⊢ Eq (Finset.preimage 0 (fun x => HAdd.hAdd x (Neg.neg b)) ⋯) (Singleton.singleton b)","decl":"@[to_additive]\ntheorem preimage_mul_right_one' : preimage 1 (· * b⁻¹) (mul_left_injective _).injOn = {b} := by\n  rw [preimage_mul_right_one, inv_inv]\n\n"}
{"name":"Finset.preimage_mul_right_one'","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : Group α\nb : α\n⊢ Eq (Finset.preimage 1 (fun x => HMul.hMul x (Inv.inv b)) ⋯) (Singleton.singleton b)","decl":"@[to_additive]\ntheorem preimage_mul_right_one' : preimage 1 (· * b⁻¹) (mul_left_injective _).injOn = {b} := by\n  rw [preimage_mul_right_one, inv_inv]\n\n"}
{"name":"Finset.vsub_def","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : VSub α β\ninst✝ : DecidableEq α\ns t : Finset β\n⊢ Eq (VSub.vsub s t) (Finset.image₂ (fun x1 x2 => VSub.vsub x1 x2) s t)","decl":"theorem vsub_def : s -ᵥ t = image₂ (· -ᵥ ·) s t :=\n  rfl\n\n"}
{"name":"Finset.image_vsub_product","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : VSub α β\ninst✝ : DecidableEq α\ns t : Finset β\n⊢ Eq (Finset.image₂ (fun x1 x2 => VSub.vsub x1 x2) s t) (VSub.vsub s t)","decl":"@[simp]\ntheorem image_vsub_product : image₂ (· -ᵥ ·) s t = s -ᵥ t :=\n  rfl\n\n"}
{"name":"Finset.mem_vsub","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : VSub α β\ninst✝ : DecidableEq α\ns t : Finset β\na : α\n⊢ Iff (Membership.mem (VSub.vsub s t) a) (Exists fun b => And (Membership.mem s b) (Exists fun c => And (Membership.mem t c) (Eq (VSub.vsub b c) a)))","decl":"theorem mem_vsub : a ∈ s -ᵥ t ↔ ∃ b ∈ s, ∃ c ∈ t, b -ᵥ c = a :=\n  mem_image₂\n\n"}
{"name":"Finset.coe_vsub","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : VSub α β\ninst✝ : DecidableEq α\ns t : Finset β\n⊢ Eq (↑(VSub.vsub s t)) (VSub.vsub ↑s ↑t)","decl":"@[simp, norm_cast]\ntheorem coe_vsub (s t : Finset β) : (↑(s -ᵥ t) : Set α) = (s : Set β) -ᵥ t :=\n  coe_image₂ _ _ _\n\n"}
{"name":"Finset.vsub_mem_vsub","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : VSub α β\ninst✝ : DecidableEq α\ns t : Finset β\nb c : β\na✝¹ : Membership.mem s b\na✝ : Membership.mem t c\n⊢ Membership.mem (VSub.vsub s t) (VSub.vsub b c)","decl":"theorem vsub_mem_vsub : b ∈ s → c ∈ t → b -ᵥ c ∈ s -ᵥ t :=\n  mem_image₂_of_mem\n\n"}
{"name":"Finset.vsub_card_le","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : VSub α β\ninst✝ : DecidableEq α\ns t : Finset β\n⊢ LE.le (VSub.vsub s t).card (HMul.hMul s.card t.card)","decl":"theorem vsub_card_le : (s -ᵥ t : Finset α).card ≤ s.card * t.card :=\n  card_image₂_le _ _ _\n\n"}
{"name":"Finset.empty_vsub","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : VSub α β\ninst✝ : DecidableEq α\nt : Finset β\n⊢ Eq (VSub.vsub EmptyCollection.emptyCollection t) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem empty_vsub (t : Finset β) : (∅ : Finset β) -ᵥ t = ∅ :=\n  image₂_empty_left\n\n"}
{"name":"Finset.vsub_empty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : VSub α β\ninst✝ : DecidableEq α\ns : Finset β\n⊢ Eq (VSub.vsub s EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem vsub_empty (s : Finset β) : s -ᵥ (∅ : Finset β) = ∅ :=\n  image₂_empty_right\n\n"}
{"name":"Finset.vsub_eq_empty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : VSub α β\ninst✝ : DecidableEq α\ns t : Finset β\n⊢ Iff (Eq (VSub.vsub s t) EmptyCollection.emptyCollection) (Or (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection))","decl":"@[simp]\ntheorem vsub_eq_empty : s -ᵥ t = ∅ ↔ s = ∅ ∨ t = ∅ :=\n  image₂_eq_empty_iff\n\n"}
{"name":"Finset.vsub_nonempty","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : VSub α β\ninst✝ : DecidableEq α\ns t : Finset β\n⊢ Iff (VSub.vsub s t).Nonempty (And s.Nonempty t.Nonempty)","decl":"@[simp]\ntheorem vsub_nonempty : (s -ᵥ t : Finset α).Nonempty ↔ s.Nonempty ∧ t.Nonempty :=\n  image₂_nonempty_iff\n\n"}
{"name":"Finset.Nonempty.vsub","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : VSub α β\ninst✝ : DecidableEq α\ns t : Finset β\na✝¹ : s.Nonempty\na✝ : t.Nonempty\n⊢ (VSub.vsub s t).Nonempty","decl":"@[aesop safe apply (rule_sets := [finsetNonempty])]\ntheorem Nonempty.vsub : s.Nonempty → t.Nonempty → (s -ᵥ t : Finset α).Nonempty :=\n  Nonempty.image₂\n\n"}
{"name":"Finset.Nonempty.of_vsub_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : VSub α β\ninst✝ : DecidableEq α\ns t : Finset β\na✝ : (VSub.vsub s t).Nonempty\n⊢ s.Nonempty","decl":"theorem Nonempty.of_vsub_left : (s -ᵥ t : Finset α).Nonempty → s.Nonempty :=\n  Nonempty.of_image₂_left\n\n"}
{"name":"Finset.Nonempty.of_vsub_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : VSub α β\ninst✝ : DecidableEq α\ns t : Finset β\na✝ : (VSub.vsub s t).Nonempty\n⊢ t.Nonempty","decl":"theorem Nonempty.of_vsub_right : (s -ᵥ t : Finset α).Nonempty → t.Nonempty :=\n  Nonempty.of_image₂_right\n\n"}
{"name":"Finset.vsub_singleton","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : VSub α β\ninst✝ : DecidableEq α\ns : Finset β\nb : β\n⊢ Eq (VSub.vsub s (Singleton.singleton b)) (Finset.image (fun x => VSub.vsub x b) s)","decl":"@[simp]\ntheorem vsub_singleton (b : β) : s -ᵥ ({b} : Finset β) = s.image (· -ᵥ b) :=\n  image₂_singleton_right\n\n"}
{"name":"Finset.singleton_vsub","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : VSub α β\ninst✝ : DecidableEq α\nt : Finset β\na : β\n⊢ Eq (VSub.vsub (Singleton.singleton a) t) (Finset.image (fun x => VSub.vsub a x) t)","decl":"theorem singleton_vsub (a : β) : ({a} : Finset β) -ᵥ t = t.image (a -ᵥ ·) :=\n  image₂_singleton_left\n\n"}
{"name":"Finset.singleton_vsub_singleton","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : VSub α β\ninst✝ : DecidableEq α\na b : β\n⊢ Eq (VSub.vsub (Singleton.singleton a) (Singleton.singleton b)) (Singleton.singleton (VSub.vsub a b))","decl":"theorem singleton_vsub_singleton (a b : β) : ({a} : Finset β) -ᵥ {b} = {a -ᵥ b} :=\n  image₂_singleton\n\n"}
{"name":"Finset.vsub_subset_vsub","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : VSub α β\ninst✝ : DecidableEq α\ns₁ s₂ t₁ t₂ : Finset β\na✝¹ : HasSubset.Subset s₁ s₂\na✝ : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (VSub.vsub s₁ t₁) (VSub.vsub s₂ t₂)","decl":"@[mono, gcongr]\ntheorem vsub_subset_vsub : s₁ ⊆ s₂ → t₁ ⊆ t₂ → s₁ -ᵥ t₁ ⊆ s₂ -ᵥ t₂ :=\n  image₂_subset\n\n"}
{"name":"Finset.vsub_subset_vsub_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : VSub α β\ninst✝ : DecidableEq α\ns t₁ t₂ : Finset β\na✝ : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (VSub.vsub s t₁) (VSub.vsub s t₂)","decl":"theorem vsub_subset_vsub_left : t₁ ⊆ t₂ → s -ᵥ t₁ ⊆ s -ᵥ t₂ :=\n  image₂_subset_left\n\n"}
{"name":"Finset.vsub_subset_vsub_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : VSub α β\ninst✝ : DecidableEq α\ns₁ s₂ t : Finset β\na✝ : HasSubset.Subset s₁ s₂\n⊢ HasSubset.Subset (VSub.vsub s₁ t) (VSub.vsub s₂ t)","decl":"theorem vsub_subset_vsub_right : s₁ ⊆ s₂ → s₁ -ᵥ t ⊆ s₂ -ᵥ t :=\n  image₂_subset_right\n\n"}
{"name":"Finset.vsub_subset_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : VSub α β\ninst✝ : DecidableEq α\ns t : Finset β\nu : Finset α\n⊢ Iff (HasSubset.Subset (VSub.vsub s t) u) (∀ (x : β), Membership.mem s x → ∀ (y : β), Membership.mem t y → Membership.mem u (VSub.vsub x y))","decl":"theorem vsub_subset_iff : s -ᵥ t ⊆ u ↔ ∀ x ∈ s, ∀ y ∈ t, x -ᵥ y ∈ u :=\n  image₂_subset_iff\n\n"}
{"name":"Finset.union_vsub","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : VSub α β\ninst✝¹ : DecidableEq α\ns₁ s₂ t : Finset β\ninst✝ : DecidableEq β\n⊢ Eq (VSub.vsub (Union.union s₁ s₂) t) (Union.union (VSub.vsub s₁ t) (VSub.vsub s₂ t))","decl":"theorem union_vsub : s₁ ∪ s₂ -ᵥ t = s₁ -ᵥ t ∪ (s₂ -ᵥ t) :=\n  image₂_union_left\n\n"}
{"name":"Finset.vsub_union","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : VSub α β\ninst✝¹ : DecidableEq α\ns t₁ t₂ : Finset β\ninst✝ : DecidableEq β\n⊢ Eq (VSub.vsub s (Union.union t₁ t₂)) (Union.union (VSub.vsub s t₁) (VSub.vsub s t₂))","decl":"theorem vsub_union : s -ᵥ (t₁ ∪ t₂) = s -ᵥ t₁ ∪ (s -ᵥ t₂) :=\n  image₂_union_right\n\n"}
{"name":"Finset.inter_vsub_subset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : VSub α β\ninst✝¹ : DecidableEq α\ns₁ s₂ t : Finset β\ninst✝ : DecidableEq β\n⊢ HasSubset.Subset (VSub.vsub (Inter.inter s₁ s₂) t) (Inter.inter (VSub.vsub s₁ t) (VSub.vsub s₂ t))","decl":"theorem inter_vsub_subset : s₁ ∩ s₂ -ᵥ t ⊆ (s₁ -ᵥ t) ∩ (s₂ -ᵥ t) :=\n  image₂_inter_subset_left\n\n"}
{"name":"Finset.vsub_inter_subset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : VSub α β\ninst✝¹ : DecidableEq α\ns t₁ t₂ : Finset β\ninst✝ : DecidableEq β\n⊢ HasSubset.Subset (VSub.vsub s (Inter.inter t₁ t₂)) (Inter.inter (VSub.vsub s t₁) (VSub.vsub s t₂))","decl":"theorem vsub_inter_subset : s -ᵥ t₁ ∩ t₂ ⊆ (s -ᵥ t₁) ∩ (s -ᵥ t₂) :=\n  image₂_inter_subset_right\n\n"}
{"name":"Finset.subset_vsub","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : VSub α β\ninst✝ : DecidableEq α\nu : Finset α\ns t : Set β\na✝ : HasSubset.Subset (↑u) (VSub.vsub s t)\n⊢ Exists fun s' => Exists fun t' => And (HasSubset.Subset (↑s') s) (And (HasSubset.Subset (↑t') t) (HasSubset.Subset u (VSub.vsub s' t')))","decl":"/-- If a finset `u` is contained in the pointwise subtraction of two sets `s -ᵥ t`, we can find two\nfinsets `s'`, `t'` such that `s' ⊆ s`, `t' ⊆ t` and `u ⊆ s' -ᵥ t'`. -/\ntheorem subset_vsub {s t : Set β} :\n    ↑u ⊆ s -ᵥ t → ∃ s' t' : Finset β, ↑s' ⊆ s ∧ ↑t' ⊆ t ∧ u ⊆ s' -ᵥ t' :=\n  subset_set_image₂\n\n"}
{"name":"Finset.vaddCommClass_finset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝³ : DecidableEq γ\ninst✝² : VAdd α γ\ninst✝¹ : VAdd β γ\ninst✝ : VAddCommClass α β γ\n⊢ VAddCommClass α β (Finset γ)","decl":"@[to_additive]\ninstance smulCommClass_finset [SMul α γ] [SMul β γ] [SMulCommClass α β γ] :\n    SMulCommClass α β (Finset γ) :=\n  ⟨fun _ _ => Commute.finset_image <| smul_comm _ _⟩\n\n"}
{"name":"Finset.smulCommClass_finset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝³ : DecidableEq γ\ninst✝² : SMul α γ\ninst✝¹ : SMul β γ\ninst✝ : SMulCommClass α β γ\n⊢ SMulCommClass α β (Finset γ)","decl":"@[to_additive]\ninstance smulCommClass_finset [SMul α γ] [SMul β γ] [SMulCommClass α β γ] :\n    SMulCommClass α β (Finset γ) :=\n  ⟨fun _ _ => Commute.finset_image <| smul_comm _ _⟩\n\n"}
{"name":"Finset.vaddCommClass_finset'","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝³ : DecidableEq γ\ninst✝² : VAdd α γ\ninst✝¹ : VAdd β γ\ninst✝ : VAddCommClass α β γ\n⊢ VAddCommClass α (Finset β) (Finset γ)","decl":"@[to_additive]\ninstance smulCommClass_finset' [SMul α γ] [SMul β γ] [SMulCommClass α β γ] :\n    SMulCommClass α (Finset β) (Finset γ) :=\n  ⟨fun a s t => coe_injective <| by simp only [coe_smul_finset, coe_smul, smul_comm]⟩\n\n"}
{"name":"Finset.smulCommClass_finset'","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝³ : DecidableEq γ\ninst✝² : SMul α γ\ninst✝¹ : SMul β γ\ninst✝ : SMulCommClass α β γ\n⊢ SMulCommClass α (Finset β) (Finset γ)","decl":"@[to_additive]\ninstance smulCommClass_finset' [SMul α γ] [SMul β γ] [SMulCommClass α β γ] :\n    SMulCommClass α (Finset β) (Finset γ) :=\n  ⟨fun a s t => coe_injective <| by simp only [coe_smul_finset, coe_smul, smul_comm]⟩\n\n"}
{"name":"Finset.smulCommClass_finset''","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝³ : DecidableEq γ\ninst✝² : SMul α γ\ninst✝¹ : SMul β γ\ninst✝ : SMulCommClass α β γ\n⊢ SMulCommClass (Finset α) β (Finset γ)","decl":"@[to_additive]\ninstance smulCommClass_finset'' [SMul α γ] [SMul β γ] [SMulCommClass α β γ] :\n    SMulCommClass (Finset α) β (Finset γ) :=\n  haveI := SMulCommClass.symm α β γ\n  SMulCommClass.symm _ _ _\n\n"}
{"name":"Finset.vaddCommClass_finset''","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝³ : DecidableEq γ\ninst✝² : VAdd α γ\ninst✝¹ : VAdd β γ\ninst✝ : VAddCommClass α β γ\n⊢ VAddCommClass (Finset α) β (Finset γ)","decl":"@[to_additive]\ninstance smulCommClass_finset'' [SMul α γ] [SMul β γ] [SMulCommClass α β γ] :\n    SMulCommClass (Finset α) β (Finset γ) :=\n  haveI := SMulCommClass.symm α β γ\n  SMulCommClass.symm _ _ _\n\n"}
{"name":"Finset.vaddCommClass","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝³ : DecidableEq γ\ninst✝² : VAdd α γ\ninst✝¹ : VAdd β γ\ninst✝ : VAddCommClass α β γ\n⊢ VAddCommClass (Finset α) (Finset β) (Finset γ)","decl":"@[to_additive]\ninstance smulCommClass [SMul α γ] [SMul β γ] [SMulCommClass α β γ] :\n    SMulCommClass (Finset α) (Finset β) (Finset γ) :=\n  ⟨fun s t u => coe_injective <| by simp_rw [coe_smul, smul_comm]⟩\n\n"}
{"name":"Finset.smulCommClass","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝³ : DecidableEq γ\ninst✝² : SMul α γ\ninst✝¹ : SMul β γ\ninst✝ : SMulCommClass α β γ\n⊢ SMulCommClass (Finset α) (Finset β) (Finset γ)","decl":"@[to_additive]\ninstance smulCommClass [SMul α γ] [SMul β γ] [SMulCommClass α β γ] :\n    SMulCommClass (Finset α) (Finset β) (Finset γ) :=\n  ⟨fun s t u => coe_injective <| by simp_rw [coe_smul, smul_comm]⟩\n\n"}
{"name":"Finset.isScalarTower","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁴ : DecidableEq γ\ninst✝³ : SMul α β\ninst✝² : SMul α γ\ninst✝¹ : SMul β γ\ninst✝ : IsScalarTower α β γ\n⊢ IsScalarTower α β (Finset γ)","decl":"@[to_additive vaddAssocClass]\ninstance isScalarTower [SMul α β] [SMul α γ] [SMul β γ] [IsScalarTower α β γ] :\n    IsScalarTower α β (Finset γ) :=\n  ⟨fun a b s => by simp only [← image_smul, image_image, smul_assoc, Function.comp_def]⟩\n\n"}
{"name":"Finset.vaddAssocClass","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁴ : DecidableEq γ\ninst✝³ : VAdd α β\ninst✝² : VAdd α γ\ninst✝¹ : VAdd β γ\ninst✝ : VAddAssocClass α β γ\n⊢ VAddAssocClass α β (Finset γ)","decl":"@[to_additive vaddAssocClass]\ninstance isScalarTower [SMul α β] [SMul α γ] [SMul β γ] [IsScalarTower α β γ] :\n    IsScalarTower α β (Finset γ) :=\n  ⟨fun a b s => by simp only [← image_smul, image_image, smul_assoc, Function.comp_def]⟩\n\n"}
{"name":"Finset.vaddAssocClass'","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : DecidableEq γ\ninst✝⁴ : DecidableEq β\ninst✝³ : VAdd α β\ninst✝² : VAdd α γ\ninst✝¹ : VAdd β γ\ninst✝ : VAddAssocClass α β γ\n⊢ VAddAssocClass α (Finset β) (Finset γ)","decl":"@[to_additive vaddAssocClass']\ninstance isScalarTower' [SMul α β] [SMul α γ] [SMul β γ] [IsScalarTower α β γ] :\n    IsScalarTower α (Finset β) (Finset γ) :=\n  ⟨fun a s t => coe_injective <| by simp only [coe_smul_finset, coe_smul, smul_assoc]⟩\n\n"}
{"name":"Finset.isScalarTower'","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : DecidableEq γ\ninst✝⁴ : DecidableEq β\ninst✝³ : SMul α β\ninst✝² : SMul α γ\ninst✝¹ : SMul β γ\ninst✝ : IsScalarTower α β γ\n⊢ IsScalarTower α (Finset β) (Finset γ)","decl":"@[to_additive vaddAssocClass']\ninstance isScalarTower' [SMul α β] [SMul α γ] [SMul β γ] [IsScalarTower α β γ] :\n    IsScalarTower α (Finset β) (Finset γ) :=\n  ⟨fun a s t => coe_injective <| by simp only [coe_smul_finset, coe_smul, smul_assoc]⟩\n\n"}
{"name":"Finset.isScalarTower''","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : DecidableEq γ\ninst✝⁴ : DecidableEq β\ninst✝³ : SMul α β\ninst✝² : SMul α γ\ninst✝¹ : SMul β γ\ninst✝ : IsScalarTower α β γ\n⊢ IsScalarTower (Finset α) (Finset β) (Finset γ)","decl":"@[to_additive vaddAssocClass'']\ninstance isScalarTower'' [SMul α β] [SMul α γ] [SMul β γ] [IsScalarTower α β γ] :\n    IsScalarTower (Finset α) (Finset β) (Finset γ) :=\n  ⟨fun a s t => coe_injective <| by simp only [coe_smul_finset, coe_smul, smul_assoc]⟩\n\n"}
{"name":"Finset.vaddAssocClass''","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : DecidableEq γ\ninst✝⁴ : DecidableEq β\ninst✝³ : VAdd α β\ninst✝² : VAdd α γ\ninst✝¹ : VAdd β γ\ninst✝ : VAddAssocClass α β γ\n⊢ VAddAssocClass (Finset α) (Finset β) (Finset γ)","decl":"@[to_additive vaddAssocClass'']\ninstance isScalarTower'' [SMul α β] [SMul α γ] [SMul β γ] [IsScalarTower α β γ] :\n    IsScalarTower (Finset α) (Finset β) (Finset γ) :=\n  ⟨fun a s t => coe_injective <| by simp only [coe_smul_finset, coe_smul, smul_assoc]⟩\n\n"}
{"name":"Finset.isCentralVAdd","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq β\ninst✝² : VAdd α β\ninst✝¹ : VAdd (AddOpposite α) β\ninst✝ : IsCentralVAdd α β\n⊢ IsCentralVAdd α (Finset β)","decl":"@[to_additive]\ninstance isCentralScalar [SMul α β] [SMul αᵐᵒᵖ β] [IsCentralScalar α β] :\n    IsCentralScalar α (Finset β) :=\n  ⟨fun a s => coe_injective <| by simp only [coe_smul_finset, coe_smul, op_smul_eq_smul]⟩\n\n"}
{"name":"Finset.isCentralScalar","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq β\ninst✝² : SMul α β\ninst✝¹ : SMul (MulOpposite α) β\ninst✝ : IsCentralScalar α β\n⊢ IsCentralScalar α (Finset β)","decl":"@[to_additive]\ninstance isCentralScalar [SMul α β] [SMul αᵐᵒᵖ β] [IsCentralScalar α β] :\n    IsCentralScalar α (Finset β) :=\n  ⟨fun a s => coe_injective <| by simp only [coe_smul_finset, coe_smul, op_smul_eq_smul]⟩\n\n"}
{"name":"Finset.op_smul_finset_smul_eq_smul_smul_finset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁴ : DecidableEq β\ninst✝³ : DecidableEq γ\ninst✝² : SMul (MulOpposite α) β\ninst✝¹ : SMul β γ\ninst✝ : SMul α γ\na : α\ns : Finset β\nt : Finset γ\nh : ∀ (a : α) (b : β) (c : γ), Eq (HSMul.hSMul (HSMul.hSMul (MulOpposite.op a) b) c) (HSMul.hSMul b (HSMul.hSMul a c))\n⊢ Eq (HSMul.hSMul (HSMul.hSMul (MulOpposite.op a) s) t) (HSMul.hSMul s (HSMul.hSMul a t))","decl":"@[to_additive]\ntheorem op_smul_finset_smul_eq_smul_smul_finset (a : α) (s : Finset β) (t : Finset γ)\n    (h : ∀ (a : α) (b : β) (c : γ), (op a • b) • c = b • a • c) : (op a • s) • t = s • a • t := by\n  ext\n  simp [mem_smul, mem_smul_finset, h]\n\n"}
{"name":"Finset.op_vadd_finset_vadd_eq_vadd_vadd_finset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁴ : DecidableEq β\ninst✝³ : DecidableEq γ\ninst✝² : VAdd (AddOpposite α) β\ninst✝¹ : VAdd β γ\ninst✝ : VAdd α γ\na : α\ns : Finset β\nt : Finset γ\nh : ∀ (a : α) (b : β) (c : γ), Eq (HVAdd.hVAdd (HVAdd.hVAdd (AddOpposite.op a) b) c) (HVAdd.hVAdd b (HVAdd.hVAdd a c))\n⊢ Eq (HVAdd.hVAdd (HVAdd.hVAdd (AddOpposite.op a) s) t) (HVAdd.hVAdd s (HVAdd.hVAdd a t))","decl":"@[to_additive]\ntheorem op_smul_finset_smul_eq_smul_smul_finset (a : α) (s : Finset β) (t : Finset γ)\n    (h : ∀ (a : α) (b : β) (c : γ), (op a • b) • c = b • a • c) : (op a • s) • t = s • a • t := by\n  ext\n  simp [mem_smul, mem_smul_finset, h]\n\n"}
{"name":"Finset.vadd_finset_subset_add","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Add α\ninst✝ : DecidableEq α\ns t : Finset α\na : α\na✝ : Membership.mem s a\n⊢ HasSubset.Subset (HVAdd.hVAdd a t) (HAdd.hAdd s t)","decl":"@[to_additive] lemma smul_finset_subset_mul : a ∈ s → a • t ⊆ s * t := image_subset_image₂_right\n\n"}
{"name":"Finset.smul_finset_subset_mul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Mul α\ninst✝ : DecidableEq α\ns t : Finset α\na : α\na✝ : Membership.mem s a\n⊢ HasSubset.Subset (HSMul.hSMul a t) (HMul.hMul s t)","decl":"@[to_additive] lemma smul_finset_subset_mul : a ∈ s → a • t ⊆ s * t := image_subset_image₂_right\n\n"}
{"name":"Finset.op_vadd_finset_subset_add","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Add α\ninst✝ : DecidableEq α\ns t : Finset α\na : α\na✝ : Membership.mem t a\n⊢ HasSubset.Subset (HVAdd.hVAdd (AddOpposite.op a) s) (HAdd.hAdd s t)","decl":"@[to_additive]\ntheorem op_smul_finset_subset_mul : a ∈ t → op a • s ⊆ s * t :=\n  image_subset_image₂_left\n\n"}
{"name":"Finset.op_smul_finset_subset_mul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Mul α\ninst✝ : DecidableEq α\ns t : Finset α\na : α\na✝ : Membership.mem t a\n⊢ HasSubset.Subset (HSMul.hSMul (MulOpposite.op a) s) (HMul.hMul s t)","decl":"@[to_additive]\ntheorem op_smul_finset_subset_mul : a ∈ t → op a • s ⊆ s * t :=\n  image_subset_image₂_left\n\n"}
{"name":"Finset.biUnion_op_vadd_finset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Add α\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Eq (t.biUnion fun a => HVAdd.hVAdd (AddOpposite.op a) s) (HAdd.hAdd s t)","decl":"@[to_additive (attr := simp)]\ntheorem biUnion_op_smul_finset (s t : Finset α) : (t.biUnion fun a => op a • s) = s * t :=\n  biUnion_image_right\n\n"}
{"name":"Finset.biUnion_op_smul_finset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Mul α\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Eq (t.biUnion fun a => HSMul.hSMul (MulOpposite.op a) s) (HMul.hMul s t)","decl":"@[to_additive (attr := simp)]\ntheorem biUnion_op_smul_finset (s t : Finset α) : (t.biUnion fun a => op a • s) = s * t :=\n  biUnion_image_right\n\n"}
{"name":"Finset.add_subset_iff_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Add α\ninst✝ : DecidableEq α\ns t u : Finset α\n⊢ Iff (HasSubset.Subset (HAdd.hAdd s t) u) (∀ (a : α), Membership.mem s a → HasSubset.Subset (HVAdd.hVAdd a t) u)","decl":"@[to_additive]\ntheorem mul_subset_iff_left : s * t ⊆ u ↔ ∀ a ∈ s, a • t ⊆ u :=\n  image₂_subset_iff_left\n\n"}
{"name":"Finset.mul_subset_iff_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Mul α\ninst✝ : DecidableEq α\ns t u : Finset α\n⊢ Iff (HasSubset.Subset (HMul.hMul s t) u) (∀ (a : α), Membership.mem s a → HasSubset.Subset (HSMul.hSMul a t) u)","decl":"@[to_additive]\ntheorem mul_subset_iff_left : s * t ⊆ u ↔ ∀ a ∈ s, a • t ⊆ u :=\n  image₂_subset_iff_left\n\n"}
{"name":"Finset.add_subset_iff_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Add α\ninst✝ : DecidableEq α\ns t u : Finset α\n⊢ Iff (HasSubset.Subset (HAdd.hAdd s t) u) (∀ (b : α), Membership.mem t b → HasSubset.Subset (HVAdd.hVAdd (AddOpposite.op b) s) u)","decl":"@[to_additive]\ntheorem mul_subset_iff_right : s * t ⊆ u ↔ ∀ b ∈ t, op b • s ⊆ u :=\n  image₂_subset_iff_right\n\n"}
{"name":"Finset.mul_subset_iff_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Mul α\ninst✝ : DecidableEq α\ns t u : Finset α\n⊢ Iff (HasSubset.Subset (HMul.hMul s t) u) (∀ (b : α), Membership.mem t b → HasSubset.Subset (HSMul.hSMul (MulOpposite.op b) s) u)","decl":"@[to_additive]\ntheorem mul_subset_iff_right : s * t ⊆ u ↔ ∀ b ∈ t, op b • s ⊆ u :=\n  image₂_subset_iff_right\n\n"}
{"name":"Finset.image_nsmul_of_ne_zero","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : DecidableEq α\ninst✝⁴ : DecidableEq β\ninst✝³ : AddMonoid α\ninst✝² : AddMonoid β\ninst✝¹ : FunLike F α β\ninst✝ : AddHomClass F α β\nn : Nat\na✝ : Ne n 0\nf : F\ns : Finset α\n⊢ Eq (Finset.image (⇑f) (HSMul.hSMul n s)) (HSMul.hSMul n (Finset.image (⇑f) s))","decl":"@[to_additive]\nlemma image_pow_of_ne_zero [MulHomClass F α β] :\n    ∀ {n}, n ≠ 0 → ∀ (f : F) (s : Finset α), (s ^ n).image f = s.image f ^ n\n  | 1, _ => by simp\n  | n + 2, _ => by simp [image_mul, pow_succ _ n.succ, image_pow_of_ne_zero]\n\n"}
{"name":"Finset.image_pow_of_ne_zero","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : DecidableEq α\ninst✝⁴ : DecidableEq β\ninst✝³ : Monoid α\ninst✝² : Monoid β\ninst✝¹ : FunLike F α β\ninst✝ : MulHomClass F α β\nn : Nat\na✝ : Ne n 0\nf : F\ns : Finset α\n⊢ Eq (Finset.image (⇑f) (HPow.hPow s n)) (HPow.hPow (Finset.image (⇑f) s) n)","decl":"@[to_additive]\nlemma image_pow_of_ne_zero [MulHomClass F α β] :\n    ∀ {n}, n ≠ 0 → ∀ (f : F) (s : Finset α), (s ^ n).image f = s.image f ^ n\n  | 1, _ => by simp\n  | n + 2, _ => by simp [image_mul, pow_succ _ n.succ, image_pow_of_ne_zero]\n\n"}
{"name":"Finset.image_nsmul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : DecidableEq α\ninst✝⁴ : DecidableEq β\ninst✝³ : AddMonoid α\ninst✝² : AddMonoid β\ninst✝¹ : FunLike F α β\ninst✝ : AddMonoidHomClass F α β\nf : F\ns : Finset α\nn : Nat\n⊢ Eq (Finset.image (⇑f) (HSMul.hSMul n s)) (HSMul.hSMul n (Finset.image (⇑f) s))","decl":"@[to_additive]\nlemma image_pow [MonoidHomClass F α β] (f : F) (s : Finset α) : ∀ n, (s ^ n).image f = s.image f ^ n\n  | 0 => by simp [singleton_one]\n  | n + 1 => image_pow_of_ne_zero n.succ_ne_zero ..\n\n"}
{"name":"Finset.image_pow","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : DecidableEq α\ninst✝⁴ : DecidableEq β\ninst✝³ : Monoid α\ninst✝² : Monoid β\ninst✝¹ : FunLike F α β\ninst✝ : MonoidHomClass F α β\nf : F\ns : Finset α\nn : Nat\n⊢ Eq (Finset.image (⇑f) (HPow.hPow s n)) (HPow.hPow (Finset.image (⇑f) s) n)","decl":"@[to_additive]\nlemma image_pow [MonoidHomClass F α β] (f : F) (s : Finset α) : ∀ n, (s ^ n).image f = s.image f ^ n\n  | 0 => by simp [singleton_one]\n  | n + 1 => image_pow_of_ne_zero n.succ_ne_zero ..\n\n"}
{"name":"Finset.op_smul_finset_mul_eq_mul_smul_finset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Semigroup α\ninst✝ : DecidableEq α\na : α\ns t : Finset α\n⊢ Eq (HMul.hMul (HSMul.hSMul (MulOpposite.op a) s) t) (HMul.hMul s (HSMul.hSMul a t))","decl":"@[to_additive]\ntheorem op_smul_finset_mul_eq_mul_smul_finset (a : α) (s : Finset α) (t : Finset α) :\n    op a • s * t = s * a • t :=\n  op_smul_finset_smul_eq_smul_smul_finset _ _ _ fun _ _ _ => mul_assoc _ _ _\n\n"}
{"name":"Finset.op_vadd_finset_add_eq_add_vadd_finset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : AddSemigroup α\ninst✝ : DecidableEq α\na : α\ns t : Finset α\n⊢ Eq (HAdd.hAdd (HVAdd.hVAdd (AddOpposite.op a) s) t) (HAdd.hAdd s (HVAdd.hVAdd a t))","decl":"@[to_additive]\ntheorem op_smul_finset_mul_eq_mul_smul_finset (a : α) (s : Finset α) (t : Finset α) :\n    op a • s * t = s * a • t :=\n  op_smul_finset_smul_eq_smul_smul_finset _ _ _ fun _ _ _ => mul_assoc _ _ _\n\n"}
{"name":"Finset.Nontrivial.add_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : Add α\ninst✝¹ : IsLeftCancelAdd α\ninst✝ : DecidableEq α\ns t : Finset α\na✝¹ : t.Nontrivial\na✝ : s.Nonempty\n⊢ (HAdd.hAdd s t).Nontrivial","decl":"@[to_additive]\nlemma Nontrivial.mul_left : t.Nontrivial → s.Nonempty → (s * t).Nontrivial := by\n  rintro ⟨a, ha, b, hb, hab⟩ ⟨c, hc⟩\n  exact ⟨c * a, mul_mem_mul hc ha, c * b, mul_mem_mul hc hb, by simpa⟩\n\n"}
{"name":"Finset.Nontrivial.mul_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : Mul α\ninst✝¹ : IsLeftCancelMul α\ninst✝ : DecidableEq α\ns t : Finset α\na✝¹ : t.Nontrivial\na✝ : s.Nonempty\n⊢ (HMul.hMul s t).Nontrivial","decl":"@[to_additive]\nlemma Nontrivial.mul_left : t.Nontrivial → s.Nonempty → (s * t).Nontrivial := by\n  rintro ⟨a, ha, b, hb, hab⟩ ⟨c, hc⟩\n  exact ⟨c * a, mul_mem_mul hc ha, c * b, mul_mem_mul hc hb, by simpa⟩\n\n"}
{"name":"Finset.Nontrivial.mul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : Mul α\ninst✝¹ : IsLeftCancelMul α\ninst✝ : DecidableEq α\ns t : Finset α\nhs : s.Nontrivial\nht : t.Nontrivial\n⊢ (HMul.hMul s t).Nontrivial","decl":"@[to_additive]\nlemma Nontrivial.mul (hs : s.Nontrivial) (ht : t.Nontrivial) : (s * t).Nontrivial :=\n  ht.mul_left hs.nonempty\n\n"}
{"name":"Finset.Nontrivial.add","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : Add α\ninst✝¹ : IsLeftCancelAdd α\ninst✝ : DecidableEq α\ns t : Finset α\nhs : s.Nontrivial\nht : t.Nontrivial\n⊢ (HAdd.hAdd s t).Nontrivial","decl":"@[to_additive]\nlemma Nontrivial.mul (hs : s.Nontrivial) (ht : t.Nontrivial) : (s * t).Nontrivial :=\n  ht.mul_left hs.nonempty\n\n"}
{"name":"Finset.pairwiseDisjoint_vadd_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : Add α\ninst✝¹ : IsLeftCancelAdd α\ninst✝ : DecidableEq α\ns : Set α\nt : Finset α\n⊢ Iff (s.PairwiseDisjoint fun x => HVAdd.hVAdd x t) (Set.InjOn (fun p => HAdd.hAdd p.1 p.2) (SProd.sprod s ↑t))","decl":"@[to_additive]\ntheorem pairwiseDisjoint_smul_iff {s : Set α} {t : Finset α} :\n    s.PairwiseDisjoint (· • t) ↔ (s ×ˢ t : Set (α × α)).InjOn fun p => p.1 * p.2 := by\n  simp_rw [← pairwiseDisjoint_coe, coe_smul_finset, Set.pairwiseDisjoint_smul_iff]\n\n"}
{"name":"Finset.pairwiseDisjoint_smul_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : Mul α\ninst✝¹ : IsLeftCancelMul α\ninst✝ : DecidableEq α\ns : Set α\nt : Finset α\n⊢ Iff (s.PairwiseDisjoint fun x => HSMul.hSMul x t) (Set.InjOn (fun p => HMul.hMul p.1 p.2) (SProd.sprod s ↑t))","decl":"@[to_additive]\ntheorem pairwiseDisjoint_smul_iff {s : Set α} {t : Finset α} :\n    s.PairwiseDisjoint (· • t) ↔ (s ×ˢ t : Set (α × α)).InjOn fun p => p.1 * p.2 := by\n  simp_rw [← pairwiseDisjoint_coe, coe_smul_finset, Set.pairwiseDisjoint_smul_iff]\n\n"}
{"name":"Finset.card_singleton_add","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : Add α\ninst✝¹ : IsLeftCancelAdd α\ninst✝ : DecidableEq α\na : α\nt : Finset α\n⊢ Eq (HAdd.hAdd (Singleton.singleton a) t).card t.card","decl":"@[to_additive (attr := simp)]\ntheorem card_singleton_mul (a : α) (t : Finset α) : ({a} * t).card = t.card :=\n  card_image₂_singleton_left _ <| mul_right_injective _\n\n"}
{"name":"Finset.card_singleton_mul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : Mul α\ninst✝¹ : IsLeftCancelMul α\ninst✝ : DecidableEq α\na : α\nt : Finset α\n⊢ Eq (HMul.hMul (Singleton.singleton a) t).card t.card","decl":"@[to_additive (attr := simp)]\ntheorem card_singleton_mul (a : α) (t : Finset α) : ({a} * t).card = t.card :=\n  card_image₂_singleton_left _ <| mul_right_injective _\n\n"}
{"name":"Finset.singleton_mul_inter","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : Mul α\ninst✝¹ : IsLeftCancelMul α\ninst✝ : DecidableEq α\na : α\ns t : Finset α\n⊢ Eq (HMul.hMul (Singleton.singleton a) (Inter.inter s t)) (Inter.inter (HMul.hMul (Singleton.singleton a) s) (HMul.hMul (Singleton.singleton a) t))","decl":"@[to_additive]\ntheorem singleton_mul_inter (a : α) (s t : Finset α) : {a} * (s ∩ t) = {a} * s ∩ ({a} * t) :=\n  image₂_singleton_inter _ _ <| mul_right_injective _\n\n"}
{"name":"Finset.singleton_add_inter","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : Add α\ninst✝¹ : IsLeftCancelAdd α\ninst✝ : DecidableEq α\na : α\ns t : Finset α\n⊢ Eq (HAdd.hAdd (Singleton.singleton a) (Inter.inter s t)) (Inter.inter (HAdd.hAdd (Singleton.singleton a) s) (HAdd.hAdd (Singleton.singleton a) t))","decl":"@[to_additive]\ntheorem singleton_mul_inter (a : α) (s t : Finset α) : {a} * (s ∩ t) = {a} * s ∩ ({a} * t) :=\n  image₂_singleton_inter _ _ <| mul_right_injective _\n\n"}
{"name":"Finset.card_le_card_add_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : Add α\ninst✝¹ : IsLeftCancelAdd α\ninst✝ : DecidableEq α\nt s : Finset α\nhs : s.Nonempty\n⊢ LE.le t.card (HAdd.hAdd s t).card","decl":"@[to_additive]\ntheorem card_le_card_mul_left {s : Finset α} (hs : s.Nonempty) : t.card ≤ (s * t).card :=\n  card_le_card_image₂_left _ hs mul_right_injective\n\n"}
{"name":"Finset.card_le_card_mul_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : Mul α\ninst✝¹ : IsLeftCancelMul α\ninst✝ : DecidableEq α\nt s : Finset α\nhs : s.Nonempty\n⊢ LE.le t.card (HMul.hMul s t).card","decl":"@[to_additive]\ntheorem card_le_card_mul_left {s : Finset α} (hs : s.Nonempty) : t.card ≤ (s * t).card :=\n  card_le_card_image₂_left _ hs mul_right_injective\n\n"}
{"name":"Finset.card_le_card_mul_self","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : Mul α\ninst✝¹ : IsLeftCancelMul α\ninst✝ : DecidableEq α\ns : Finset α\n⊢ LE.le s.card (HMul.hMul s s).card","decl":"/--\nThe size of `s * s` is at least the size of `s`, version with left-cancellative multiplication.\nSee `card_le_card_mul_self'` for the version with right-cancellative multiplication.\n-/\n@[to_additive\n\"The size of `s + s` is at least the size of `s`, version with left-cancellative addition.\nSee `card_le_card_add_self'` for the version with right-cancellative addition.\"\n]\ntheorem card_le_card_mul_self {s : Finset α} : s.card ≤ (s * s).card := by\n  cases s.eq_empty_or_nonempty <;> simp [card_le_card_mul_left, *]\n\n"}
{"name":"Finset.card_le_card_add_self","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : Add α\ninst✝¹ : IsLeftCancelAdd α\ninst✝ : DecidableEq α\ns : Finset α\n⊢ LE.le s.card (HAdd.hAdd s s).card","decl":"/--\nThe size of `s * s` is at least the size of `s`, version with left-cancellative multiplication.\nSee `card_le_card_mul_self'` for the version with right-cancellative multiplication.\n-/\n@[to_additive\n\"The size of `s + s` is at least the size of `s`, version with left-cancellative addition.\nSee `card_le_card_add_self'` for the version with right-cancellative addition.\"\n]\ntheorem card_le_card_mul_self {s : Finset α} : s.card ≤ (s * s).card := by\n  cases s.eq_empty_or_nonempty <;> simp [card_le_card_mul_left, *]\n\n"}
{"name":"Finset.Nontrivial.add_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : Add α\ninst✝¹ : IsRightCancelAdd α\ninst✝ : DecidableEq α\ns t : Finset α\na✝¹ : s.Nontrivial\na✝ : t.Nonempty\n⊢ (HAdd.hAdd s t).Nontrivial","decl":"@[to_additive]\nlemma Nontrivial.mul_right : s.Nontrivial → t.Nonempty → (s * t).Nontrivial := by\n  rintro ⟨a, ha, b, hb, hab⟩ ⟨c, hc⟩\n  exact ⟨a * c, mul_mem_mul ha hc, b * c, mul_mem_mul hb hc, by simpa⟩\n\n"}
{"name":"Finset.Nontrivial.mul_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : Mul α\ninst✝¹ : IsRightCancelMul α\ninst✝ : DecidableEq α\ns t : Finset α\na✝¹ : s.Nontrivial\na✝ : t.Nonempty\n⊢ (HMul.hMul s t).Nontrivial","decl":"@[to_additive]\nlemma Nontrivial.mul_right : s.Nontrivial → t.Nonempty → (s * t).Nontrivial := by\n  rintro ⟨a, ha, b, hb, hab⟩ ⟨c, hc⟩\n  exact ⟨a * c, mul_mem_mul ha hc, b * c, mul_mem_mul hb hc, by simpa⟩\n\n"}
{"name":"Finset.card_mul_singleton","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : Mul α\ninst✝¹ : IsRightCancelMul α\ninst✝ : DecidableEq α\ns : Finset α\na : α\n⊢ Eq (HMul.hMul s (Singleton.singleton a)).card s.card","decl":"@[to_additive (attr := simp)]\ntheorem card_mul_singleton (s : Finset α) (a : α) : (s * {a}).card = s.card :=\n  card_image₂_singleton_right _ <| mul_left_injective _\n\n"}
{"name":"Finset.card_add_singleton","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : Add α\ninst✝¹ : IsRightCancelAdd α\ninst✝ : DecidableEq α\ns : Finset α\na : α\n⊢ Eq (HAdd.hAdd s (Singleton.singleton a)).card s.card","decl":"@[to_additive (attr := simp)]\ntheorem card_mul_singleton (s : Finset α) (a : α) : (s * {a}).card = s.card :=\n  card_image₂_singleton_right _ <| mul_left_injective _\n\n"}
{"name":"Finset.inter_add_singleton","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : Add α\ninst✝¹ : IsRightCancelAdd α\ninst✝ : DecidableEq α\ns t : Finset α\na : α\n⊢ Eq (HAdd.hAdd (Inter.inter s t) (Singleton.singleton a)) (Inter.inter (HAdd.hAdd s (Singleton.singleton a)) (HAdd.hAdd t (Singleton.singleton a)))","decl":"@[to_additive]\ntheorem inter_mul_singleton (s t : Finset α) (a : α) : s ∩ t * {a} = s * {a} ∩ (t * {a}) :=\n  image₂_inter_singleton _ _ <| mul_left_injective _\n\n"}
{"name":"Finset.inter_mul_singleton","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : Mul α\ninst✝¹ : IsRightCancelMul α\ninst✝ : DecidableEq α\ns t : Finset α\na : α\n⊢ Eq (HMul.hMul (Inter.inter s t) (Singleton.singleton a)) (Inter.inter (HMul.hMul s (Singleton.singleton a)) (HMul.hMul t (Singleton.singleton a)))","decl":"@[to_additive]\ntheorem inter_mul_singleton (s t : Finset α) (a : α) : s ∩ t * {a} = s * {a} ∩ (t * {a}) :=\n  image₂_inter_singleton _ _ <| mul_left_injective _\n\n"}
{"name":"Finset.card_le_card_add_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : Add α\ninst✝¹ : IsRightCancelAdd α\ninst✝ : DecidableEq α\ns t : Finset α\nht : t.Nonempty\n⊢ LE.le s.card (HAdd.hAdd s t).card","decl":"@[to_additive]\ntheorem card_le_card_mul_right (ht : t.Nonempty) : s.card ≤ (s * t).card :=\n  card_le_card_image₂_right _ ht mul_left_injective\n\n"}
{"name":"Finset.card_le_card_mul_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : Mul α\ninst✝¹ : IsRightCancelMul α\ninst✝ : DecidableEq α\ns t : Finset α\nht : t.Nonempty\n⊢ LE.le s.card (HMul.hMul s t).card","decl":"@[to_additive]\ntheorem card_le_card_mul_right (ht : t.Nonempty) : s.card ≤ (s * t).card :=\n  card_le_card_image₂_right _ ht mul_left_injective\n\n"}
{"name":"Finset.card_le_card_add_self'","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : Add α\ninst✝¹ : IsRightCancelAdd α\ninst✝ : DecidableEq α\ns : Finset α\n⊢ LE.le s.card (HAdd.hAdd s s).card","decl":"/--\nThe size of `s * s` is at least the size of `s`, version with right-cancellative multiplication.\nSee `card_le_card_mul_self` for the version with left-cancellative multiplication.\n-/\n@[to_additive\n\"The size of `s + s` is at least the size of `s`, version with right-cancellative addition.\nSee `card_le_card_add_self` for the version with left-cancellative addition.\"\n]\ntheorem card_le_card_mul_self' : s.card ≤ (s * s).card := by\n  cases s.eq_empty_or_nonempty <;> simp [card_le_card_mul_right, *]\n\n"}
{"name":"Finset.card_le_card_mul_self'","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : Mul α\ninst✝¹ : IsRightCancelMul α\ninst✝ : DecidableEq α\ns : Finset α\n⊢ LE.le s.card (HMul.hMul s s).card","decl":"/--\nThe size of `s * s` is at least the size of `s`, version with right-cancellative multiplication.\nSee `card_le_card_mul_self` for the version with left-cancellative multiplication.\n-/\n@[to_additive\n\"The size of `s + s` is at least the size of `s`, version with right-cancellative addition.\nSee `card_le_card_add_self` for the version with left-cancellative addition.\"\n]\ntheorem card_le_card_mul_self' : s.card ≤ (s * s).card := by\n  cases s.eq_empty_or_nonempty <;> simp [card_le_card_mul_right, *]\n\n"}
{"name":"Finset.Nontrivial.pow","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : CancelMonoid α\ns : Finset α\nhs : s.Nontrivial\nn : Nat\na✝ : Ne n 0\n⊢ (HPow.hPow s n).Nontrivial","decl":"@[to_additive]\nlemma Nontrivial.pow (hs : s.Nontrivial) : ∀ {n}, n ≠ 0 → (s ^ n).Nontrivial\n  | 1, _ => by simpa\n  | n + 2, _ => by simpa [pow_succ] using (hs.pow n.succ_ne_zero).mul hs\n\n"}
{"name":"Finset.Nontrivial.nsmul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddCancelMonoid α\ns : Finset α\nhs : s.Nontrivial\nn : Nat\na✝ : Ne n 0\n⊢ (HSMul.hSMul n s).Nontrivial","decl":"@[to_additive]\nlemma Nontrivial.pow (hs : s.Nontrivial) : ∀ {n}, n ≠ 0 → (s ^ n).Nontrivial\n  | 1, _ => by simpa\n  | n + 2, _ => by simpa [pow_succ] using (hs.pow n.succ_ne_zero).mul hs\n\n"}
{"name":"Finset.Nonempty.card_nsmul_mono","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddCancelMonoid α\ns : Finset α\nhs : s.Nonempty\n⊢ Monotone fun n => (HSMul.hSMul n s).card","decl":"/-- See `Finset.card_pow_mono` for a version that works for the empty set. -/\n@[to_additive \"See `Finset.card_nsmul_mono` for a version that works for the empty set.\"]\nprotected lemma Nonempty.card_pow_mono (hs : s.Nonempty) : Monotone fun n : ℕ ↦ (s ^ n).card :=\n  monotone_nat_of_le_succ fun n ↦ by rw [pow_succ]; exact card_le_card_mul_right hs\n\n"}
{"name":"Finset.Nonempty.card_pow_mono","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : CancelMonoid α\ns : Finset α\nhs : s.Nonempty\n⊢ Monotone fun n => (HPow.hPow s n).card","decl":"/-- See `Finset.card_pow_mono` for a version that works for the empty set. -/\n@[to_additive \"See `Finset.card_nsmul_mono` for a version that works for the empty set.\"]\nprotected lemma Nonempty.card_pow_mono (hs : s.Nonempty) : Monotone fun n : ℕ ↦ (s ^ n).card :=\n  monotone_nat_of_le_succ fun n ↦ by rw [pow_succ]; exact card_le_card_mul_right hs\n\n"}
{"name":"Finset.card_pow_mono","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : CancelMonoid α\ns : Finset α\nm n : Nat\nhm : Ne m 0\nhmn : LE.le m n\n⊢ LE.le (HPow.hPow s m).card (HPow.hPow s n).card","decl":"/-- See `Finset.Nonempty.card_pow_mono` for a version that works for zero powers. -/\n@[to_additive \"See `Finset.Nonempty.card_nsmul_mono` for a version that works for zero scalars.\"]\nlemma card_pow_mono (hm : m ≠ 0) (hmn : m ≤ n) : (s ^ m).card ≤ (s ^ n).card := by\n  obtain rfl | hs := s.eq_empty_or_nonempty\n  · simp [hm]\n  · exact hs.card_pow_mono hmn\n\n"}
{"name":"Finset.card_nsmul_mono","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddCancelMonoid α\ns : Finset α\nm n : Nat\nhm : Ne m 0\nhmn : LE.le m n\n⊢ LE.le (HSMul.hSMul m s).card (HSMul.hSMul n s).card","decl":"/-- See `Finset.Nonempty.card_pow_mono` for a version that works for zero powers. -/\n@[to_additive \"See `Finset.Nonempty.card_nsmul_mono` for a version that works for zero scalars.\"]\nlemma card_pow_mono (hm : m ≠ 0) (hmn : m ≤ n) : (s ^ m).card ≤ (s ^ n).card := by\n  obtain rfl | hs := s.eq_empty_or_nonempty\n  · simp [hm]\n  · exact hs.card_pow_mono hmn\n\n"}
{"name":"Finset.card_le_card_pow","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : CancelMonoid α\ns : Finset α\nn : Nat\nhn : Ne n 0\n⊢ LE.le s.card (HPow.hPow s n).card","decl":"@[to_additive]\nlemma card_le_card_pow (hn : n ≠ 0) : s.card ≤ (s ^ n).card := by\n  simpa using card_pow_mono (s := s) one_ne_zero (Nat.one_le_iff_ne_zero.2 hn)\n\n"}
{"name":"Finset.card_le_card_nsmul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddCancelMonoid α\ns : Finset α\nn : Nat\nhn : Ne n 0\n⊢ LE.le s.card (HSMul.hSMul n s).card","decl":"@[to_additive]\nlemma card_le_card_pow (hn : n ≠ 0) : s.card ≤ (s ^ n).card := by\n  simpa using card_pow_mono (s := s) one_ne_zero (Nat.one_le_iff_ne_zero.2 hn)\n\n"}
{"name":"Finset.card_le_card_sub_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : AddGroup α\ninst✝ : DecidableEq α\ns t : Finset α\nhs : s.Nonempty\n⊢ LE.le t.card (HSub.hSub s t).card","decl":"@[to_additive] lemma card_le_card_div_left (hs : s.Nonempty) : t.card ≤ (s / t).card :=\n  card_le_card_image₂_left _ hs fun _ ↦ div_right_injective\n\n"}
{"name":"Finset.card_le_card_div_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Group α\ninst✝ : DecidableEq α\ns t : Finset α\nhs : s.Nonempty\n⊢ LE.le t.card (HDiv.hDiv s t).card","decl":"@[to_additive] lemma card_le_card_div_left (hs : s.Nonempty) : t.card ≤ (s / t).card :=\n  card_le_card_image₂_left _ hs fun _ ↦ div_right_injective\n\n"}
{"name":"Finset.card_le_card_sub_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : AddGroup α\ninst✝ : DecidableEq α\ns t : Finset α\nht : t.Nonempty\n⊢ LE.le s.card (HSub.hSub s t).card","decl":"@[to_additive] lemma card_le_card_div_right (ht : t.Nonempty) : s.card ≤ (s / t).card :=\n  card_le_card_image₂_right _ ht fun _ ↦ div_left_injective\n\n"}
{"name":"Finset.card_le_card_div_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Group α\ninst✝ : DecidableEq α\ns t : Finset α\nht : t.Nonempty\n⊢ LE.le s.card (HDiv.hDiv s t).card","decl":"@[to_additive] lemma card_le_card_div_right (ht : t.Nonempty) : s.card ≤ (s / t).card :=\n  card_le_card_image₂_right _ ht fun _ ↦ div_left_injective\n\n"}
{"name":"Finset.card_le_card_sub_self","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : AddGroup α\ninst✝ : DecidableEq α\ns : Finset α\n⊢ LE.le s.card (HSub.hSub s s).card","decl":"@[to_additive] lemma card_le_card_div_self : s.card ≤ (s / s).card := by\n  cases s.eq_empty_or_nonempty <;> simp [card_le_card_div_left, *]\n\n"}
{"name":"Finset.card_le_card_div_self","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Group α\ninst✝ : DecidableEq α\ns : Finset α\n⊢ LE.le s.card (HDiv.hDiv s s).card","decl":"@[to_additive] lemma card_le_card_div_self : s.card ≤ (s / s).card := by\n  cases s.eq_empty_or_nonempty <;> simp [card_le_card_div_left, *]\n\n"}
{"name":"Finset.image_vadd_comm","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝³ : DecidableEq β\ninst✝² : DecidableEq γ\ninst✝¹ : VAdd α β\ninst✝ : VAdd α γ\nf : β → γ\na : α\ns : Finset β\na✝ : ∀ (b : β), Eq (f (HVAdd.hVAdd a b)) (HVAdd.hVAdd a (f b))\n⊢ Eq (Finset.image f (HVAdd.hVAdd a s)) (HVAdd.hVAdd a (Finset.image f s))","decl":"@[to_additive]\ntheorem image_smul_comm [DecidableEq β] [DecidableEq γ] [SMul α β] [SMul α γ] (f : β → γ) (a : α)\n    (s : Finset β) : (∀ b, f (a • b) = a • f b) → (a • s).image f = a • s.image f :=\n  image_comm\n\n"}
{"name":"Finset.image_smul_comm","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝³ : DecidableEq β\ninst✝² : DecidableEq γ\ninst✝¹ : SMul α β\ninst✝ : SMul α γ\nf : β → γ\na : α\ns : Finset β\na✝ : ∀ (b : β), Eq (f (HSMul.hSMul a b)) (HSMul.hSMul a (f b))\n⊢ Eq (Finset.image f (HSMul.hSMul a s)) (HSMul.hSMul a (Finset.image f s))","decl":"@[to_additive]\ntheorem image_smul_comm [DecidableEq β] [DecidableEq γ] [SMul α β] [SMul α γ] (f : β → γ) (a : α)\n    (s : Finset β) : (∀ b, f (a • b) = a • f b) → (a • s).image f = a • s.image f :=\n  image_comm\n\n"}
{"name":"Finset.image_vadd_distrib","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : DecidableEq α\ninst✝⁴ : DecidableEq β\ninst✝³ : AddMonoid α\ninst✝² : AddMonoid β\ninst✝¹ : FunLike F α β\ninst✝ : AddMonoidHomClass F α β\nf : F\na : α\ns : Finset α\n⊢ Eq (Finset.image (⇑f) (HVAdd.hVAdd a s)) (HVAdd.hVAdd (f a) (Finset.image (⇑f) s))","decl":"@[to_additive]\ntheorem image_smul_distrib [DecidableEq α] [DecidableEq β] [Monoid α] [Monoid β] [FunLike F α β]\n    [MonoidHomClass F α β] (f : F) (a : α) (s : Finset α) : (a • s).image f = f a • s.image f :=\n  image_comm <| map_mul _ _\n\n"}
{"name":"Finset.image_smul_distrib","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : DecidableEq α\ninst✝⁴ : DecidableEq β\ninst✝³ : Monoid α\ninst✝² : Monoid β\ninst✝¹ : FunLike F α β\ninst✝ : MonoidHomClass F α β\nf : F\na : α\ns : Finset α\n⊢ Eq (Finset.image (⇑f) (HSMul.hSMul a s)) (HSMul.hSMul (f a) (Finset.image (⇑f) s))","decl":"@[to_additive]\ntheorem image_smul_distrib [DecidableEq α] [DecidableEq β] [Monoid α] [Monoid β] [FunLike F α β]\n    [MonoidHomClass F α β] (f : F) (a : α) (s : Finset α) : (a • s).image f = f a • s.image f :=\n  image_comm <| map_mul _ _\n\n"}
{"name":"Finset.smul_mem_smul_finset_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq β\ninst✝¹ : Group α\ninst✝ : MulAction α β\ns : Finset β\nb : β\na : α\n⊢ Iff (Membership.mem (HSMul.hSMul a s) (HSMul.hSMul a b)) (Membership.mem s b)","decl":"@[to_additive (attr := simp)]\ntheorem smul_mem_smul_finset_iff (a : α) : a • b ∈ a • s ↔ b ∈ s :=\n  (MulAction.injective _).mem_finset_image\n\n"}
{"name":"Finset.vadd_mem_vadd_finset_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq β\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\ns : Finset β\nb : β\na : α\n⊢ Iff (Membership.mem (HVAdd.hVAdd a s) (HVAdd.hVAdd a b)) (Membership.mem s b)","decl":"@[to_additive (attr := simp)]\ntheorem smul_mem_smul_finset_iff (a : α) : a • b ∈ a • s ↔ b ∈ s :=\n  (MulAction.injective _).mem_finset_image\n\n"}
{"name":"Finset.inv_smul_mem_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq β\ninst✝¹ : Group α\ninst✝ : MulAction α β\ns : Finset β\na : α\nb : β\n⊢ Iff (Membership.mem s (HSMul.hSMul (Inv.inv a) b)) (Membership.mem (HSMul.hSMul a s) b)","decl":"@[to_additive]\ntheorem inv_smul_mem_iff : a⁻¹ • b ∈ s ↔ b ∈ a • s := by\n  rw [← smul_mem_smul_finset_iff a, smul_inv_smul]\n\n"}
{"name":"Finset.neg_vadd_mem_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq β\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\ns : Finset β\na : α\nb : β\n⊢ Iff (Membership.mem s (HVAdd.hVAdd (Neg.neg a) b)) (Membership.mem (HVAdd.hVAdd a s) b)","decl":"@[to_additive]\ntheorem inv_smul_mem_iff : a⁻¹ • b ∈ s ↔ b ∈ a • s := by\n  rw [← smul_mem_smul_finset_iff a, smul_inv_smul]\n\n"}
{"name":"Finset.mem_inv_smul_finset_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq β\ninst✝¹ : Group α\ninst✝ : MulAction α β\ns : Finset β\na : α\nb : β\n⊢ Iff (Membership.mem (HSMul.hSMul (Inv.inv a) s) b) (Membership.mem s (HSMul.hSMul a b))","decl":"@[to_additive]\ntheorem mem_inv_smul_finset_iff : b ∈ a⁻¹ • s ↔ a • b ∈ s := by\n  rw [← smul_mem_smul_finset_iff a, smul_inv_smul]\n\n"}
{"name":"Finset.mem_neg_vadd_finset_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq β\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\ns : Finset β\na : α\nb : β\n⊢ Iff (Membership.mem (HVAdd.hVAdd (Neg.neg a) s) b) (Membership.mem s (HVAdd.hVAdd a b))","decl":"@[to_additive]\ntheorem mem_inv_smul_finset_iff : b ∈ a⁻¹ • s ↔ a • b ∈ s := by\n  rw [← smul_mem_smul_finset_iff a, smul_inv_smul]\n\n"}
{"name":"Finset.vadd_finset_subset_vadd_finset_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq β\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\ns t : Finset β\na : α\n⊢ Iff (HasSubset.Subset (HVAdd.hVAdd a s) (HVAdd.hVAdd a t)) (HasSubset.Subset s t)","decl":"@[to_additive (attr := simp)]\ntheorem smul_finset_subset_smul_finset_iff : a • s ⊆ a • t ↔ s ⊆ t :=\n  image_subset_image_iff <| MulAction.injective _\n\n"}
{"name":"Finset.smul_finset_subset_smul_finset_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq β\ninst✝¹ : Group α\ninst✝ : MulAction α β\ns t : Finset β\na : α\n⊢ Iff (HasSubset.Subset (HSMul.hSMul a s) (HSMul.hSMul a t)) (HasSubset.Subset s t)","decl":"@[to_additive (attr := simp)]\ntheorem smul_finset_subset_smul_finset_iff : a • s ⊆ a • t ↔ s ⊆ t :=\n  image_subset_image_iff <| MulAction.injective _\n\n"}
{"name":"Finset.vadd_finset_subset_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq β\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\ns t : Finset β\na : α\n⊢ Iff (HasSubset.Subset (HVAdd.hVAdd a s) t) (HasSubset.Subset s (HVAdd.hVAdd (Neg.neg a) t))","decl":"@[to_additive]\ntheorem smul_finset_subset_iff : a • s ⊆ t ↔ s ⊆ a⁻¹ • t := by\n  simp_rw [← coe_subset]\n  push_cast\n  exact Set.smul_set_subset_iff_subset_inv_smul_set\n\n"}
{"name":"Finset.smul_finset_subset_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq β\ninst✝¹ : Group α\ninst✝ : MulAction α β\ns t : Finset β\na : α\n⊢ Iff (HasSubset.Subset (HSMul.hSMul a s) t) (HasSubset.Subset s (HSMul.hSMul (Inv.inv a) t))","decl":"@[to_additive]\ntheorem smul_finset_subset_iff : a • s ⊆ t ↔ s ⊆ a⁻¹ • t := by\n  simp_rw [← coe_subset]\n  push_cast\n  exact Set.smul_set_subset_iff_subset_inv_smul_set\n\n"}
{"name":"Finset.subset_smul_finset_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq β\ninst✝¹ : Group α\ninst✝ : MulAction α β\ns t : Finset β\na : α\n⊢ Iff (HasSubset.Subset s (HSMul.hSMul a t)) (HasSubset.Subset (HSMul.hSMul (Inv.inv a) s) t)","decl":"@[to_additive]\ntheorem subset_smul_finset_iff : s ⊆ a • t ↔ a⁻¹ • s ⊆ t := by\n  simp_rw [← coe_subset]\n  push_cast\n  exact Set.subset_smul_set_iff\n\n"}
{"name":"Finset.subset_vadd_finset_iff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq β\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\ns t : Finset β\na : α\n⊢ Iff (HasSubset.Subset s (HVAdd.hVAdd a t)) (HasSubset.Subset (HVAdd.hVAdd (Neg.neg a) s) t)","decl":"@[to_additive]\ntheorem subset_smul_finset_iff : s ⊆ a • t ↔ a⁻¹ • s ⊆ t := by\n  simp_rw [← coe_subset]\n  push_cast\n  exact Set.subset_smul_set_iff\n\n"}
{"name":"Finset.smul_finset_inter","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq β\ninst✝¹ : Group α\ninst✝ : MulAction α β\ns t : Finset β\na : α\n⊢ Eq (HSMul.hSMul a (Inter.inter s t)) (Inter.inter (HSMul.hSMul a s) (HSMul.hSMul a t))","decl":"@[to_additive]\ntheorem smul_finset_inter : a • (s ∩ t) = a • s ∩ a • t :=\n  image_inter _ _ <| MulAction.injective a\n\n"}
{"name":"Finset.vadd_finset_inter","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq β\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\ns t : Finset β\na : α\n⊢ Eq (HVAdd.hVAdd a (Inter.inter s t)) (Inter.inter (HVAdd.hVAdd a s) (HVAdd.hVAdd a t))","decl":"@[to_additive]\ntheorem smul_finset_inter : a • (s ∩ t) = a • s ∩ a • t :=\n  image_inter _ _ <| MulAction.injective a\n\n"}
{"name":"Finset.smul_finset_sdiff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq β\ninst✝¹ : Group α\ninst✝ : MulAction α β\ns t : Finset β\na : α\n⊢ Eq (HSMul.hSMul a (SDiff.sdiff s t)) (SDiff.sdiff (HSMul.hSMul a s) (HSMul.hSMul a t))","decl":"@[to_additive]\ntheorem smul_finset_sdiff : a • (s \\ t) = a • s \\ a • t :=\n  image_sdiff _ _ <| MulAction.injective a\n\n"}
{"name":"Finset.vadd_finset_sdiff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq β\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\ns t : Finset β\na : α\n⊢ Eq (HVAdd.hVAdd a (SDiff.sdiff s t)) (SDiff.sdiff (HVAdd.hVAdd a s) (HVAdd.hVAdd a t))","decl":"@[to_additive]\ntheorem smul_finset_sdiff : a • (s \\ t) = a • s \\ a • t :=\n  image_sdiff _ _ <| MulAction.injective a\n\n"}
{"name":"Finset.vadd_finset_symmDiff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq β\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\ns t : Finset β\na : α\n⊢ Eq (HVAdd.hVAdd a (symmDiff s t)) (symmDiff (HVAdd.hVAdd a s) (HVAdd.hVAdd a t))","decl":"open scoped symmDiff in\n@[to_additive]\ntheorem smul_finset_symmDiff : a • s ∆ t = (a • s) ∆ (a • t) :=\n  image_symmDiff _ _ <| MulAction.injective a\n\n"}
{"name":"Finset.smul_finset_symmDiff","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq β\ninst✝¹ : Group α\ninst✝ : MulAction α β\ns t : Finset β\na : α\n⊢ Eq (HSMul.hSMul a (symmDiff s t)) (symmDiff (HSMul.hSMul a s) (HSMul.hSMul a t))","decl":"open scoped symmDiff in\n@[to_additive]\ntheorem smul_finset_symmDiff : a • s ∆ t = (a • s) ∆ (a • t) :=\n  image_symmDiff _ _ <| MulAction.injective a\n\n"}
{"name":"Finset.vadd_finset_univ","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq β\ninst✝² : AddGroup α\ninst✝¹ : AddAction α β\na : α\ninst✝ : Fintype β\n⊢ Eq (HVAdd.hVAdd a Finset.univ) Finset.univ","decl":"@[to_additive (attr := simp)]\ntheorem smul_finset_univ [Fintype β] : a • (univ : Finset β) = univ :=\n  image_univ_of_surjective <| MulAction.surjective a\n\n"}
{"name":"Finset.smul_finset_univ","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq β\ninst✝² : Group α\ninst✝¹ : MulAction α β\na : α\ninst✝ : Fintype β\n⊢ Eq (HSMul.hSMul a Finset.univ) Finset.univ","decl":"@[to_additive (attr := simp)]\ntheorem smul_finset_univ [Fintype β] : a • (univ : Finset β) = univ :=\n  image_univ_of_surjective <| MulAction.surjective a\n\n"}
{"name":"Finset.vadd_univ","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq β\ninst✝² : AddGroup α\ninst✝¹ : AddAction α β\ninst✝ : Fintype β\ns : Finset α\nhs : s.Nonempty\n⊢ Eq (HVAdd.hVAdd s Finset.univ) Finset.univ","decl":"@[to_additive (attr := simp)]\ntheorem smul_univ [Fintype β] {s : Finset α} (hs : s.Nonempty) : s • (univ : Finset β) = univ :=\n  coe_injective <| by\n    push_cast\n    exact Set.smul_univ hs\n\n"}
{"name":"Finset.smul_univ","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq β\ninst✝² : Group α\ninst✝¹ : MulAction α β\ninst✝ : Fintype β\ns : Finset α\nhs : s.Nonempty\n⊢ Eq (HSMul.hSMul s Finset.univ) Finset.univ","decl":"@[to_additive (attr := simp)]\ntheorem smul_univ [Fintype β] {s : Finset α} (hs : s.Nonempty) : s • (univ : Finset β) = univ :=\n  coe_injective <| by\n    push_cast\n    exact Set.smul_univ hs\n\n"}
{"name":"Finset.card_vadd_finset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq β\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\na : α\ns : Finset β\n⊢ Eq (HVAdd.hVAdd a s).card s.card","decl":"@[to_additive (attr := simp)]\ntheorem card_smul_finset (a : α) (s : Finset β) : (a • s).card = s.card :=\n  card_image_of_injective _ <| MulAction.injective _\n\n"}
{"name":"Finset.card_smul_finset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq β\ninst✝¹ : Group α\ninst✝ : MulAction α β\na : α\ns : Finset β\n⊢ Eq (HSMul.hSMul a s).card s.card","decl":"@[to_additive (attr := simp)]\ntheorem card_smul_finset (a : α) (s : Finset β) : (a • s).card = s.card :=\n  card_image_of_injective _ <| MulAction.injective _\n\n"}
{"name":"Finset.dens_vadd_finset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq β\ninst✝² : AddGroup α\ninst✝¹ : AddAction α β\ninst✝ : Fintype β\na : α\ns : Finset β\n⊢ Eq (HVAdd.hVAdd a s).dens s.dens","decl":"@[to_additive (attr := simp)]\nlemma dens_smul_finset [Fintype β] (a : α) (s : Finset β) : (a • s).dens = s.dens := by simp [dens]\n\n"}
{"name":"Finset.dens_smul_finset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq β\ninst✝² : Group α\ninst✝¹ : MulAction α β\ninst✝ : Fintype β\na : α\ns : Finset β\n⊢ Eq (HSMul.hSMul a s).dens s.dens","decl":"@[to_additive (attr := simp)]\nlemma dens_smul_finset [Fintype β] (a : α) (s : Finset β) : (a • s).dens = s.dens := by simp [dens]\n\n"}
{"name":"Finset.card_dvd_card_vadd_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq β\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\nt : Finset β\ns : Finset α\na✝ : (Set.image (fun x => HVAdd.hVAdd x t) ↑s).PairwiseDisjoint id\n⊢ Dvd.dvd t.card (HVAdd.hVAdd s t).card","decl":"/-- If the left cosets of `t` by elements of `s` are disjoint (but not necessarily distinct!), then\nthe size of `t` divides the size of `s • t`. -/\n@[to_additive \"If the left cosets of `t` by elements of `s` are disjoint (but not necessarily\ndistinct!), then the size of `t` divides the size of `s +ᵥ t`.\"]\ntheorem card_dvd_card_smul_right {s : Finset α} :\n    ((· • t) '' (s : Set α)).PairwiseDisjoint id → t.card ∣ (s • t).card :=\n  card_dvd_card_image₂_right fun _ _ => MulAction.injective _\n\n"}
{"name":"Finset.card_dvd_card_smul_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : DecidableEq β\ninst✝¹ : Group α\ninst✝ : MulAction α β\nt : Finset β\ns : Finset α\na✝ : (Set.image (fun x => HSMul.hSMul x t) ↑s).PairwiseDisjoint id\n⊢ Dvd.dvd t.card (HSMul.hSMul s t).card","decl":"/-- If the left cosets of `t` by elements of `s` are disjoint (but not necessarily distinct!), then\nthe size of `t` divides the size of `s • t`. -/\n@[to_additive \"If the left cosets of `t` by elements of `s` are disjoint (but not necessarily\ndistinct!), then the size of `t` divides the size of `s +ᵥ t`.\"]\ntheorem card_dvd_card_smul_right {s : Finset α} :\n    ((· • t) '' (s : Set α)).PairwiseDisjoint id → t.card ∣ (s • t).card :=\n  card_dvd_card_image₂_right fun _ _ => MulAction.injective _\n\n"}
{"name":"Finset.card_dvd_card_add_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : AddGroup α\ninst✝ : DecidableEq α\ns t : Finset α\na✝ : (Set.image (fun b => Finset.image (fun a => HAdd.hAdd a b) s) ↑t).PairwiseDisjoint id\n⊢ Dvd.dvd s.card (HAdd.hAdd s t).card","decl":"/-- If the right cosets of `s` by elements of `t` are disjoint (but not necessarily distinct!), then\nthe size of `s` divides the size of `s * t`. -/\n@[to_additive \"If the right cosets of `s` by elements of `t` are disjoint (but not necessarily\ndistinct!), then the size of `s` divides the size of `s + t`.\"]\ntheorem card_dvd_card_mul_left {s t : Finset α} :\n    ((fun b => s.image fun a => a * b) '' (t : Set α)).PairwiseDisjoint id →\n      s.card ∣ (s * t).card :=\n  card_dvd_card_image₂_left fun _ _ => mul_left_injective _\n\n"}
{"name":"Finset.card_dvd_card_mul_left","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Group α\ninst✝ : DecidableEq α\ns t : Finset α\na✝ : (Set.image (fun b => Finset.image (fun a => HMul.hMul a b) s) ↑t).PairwiseDisjoint id\n⊢ Dvd.dvd s.card (HMul.hMul s t).card","decl":"/-- If the right cosets of `s` by elements of `t` are disjoint (but not necessarily distinct!), then\nthe size of `s` divides the size of `s * t`. -/\n@[to_additive \"If the right cosets of `s` by elements of `t` are disjoint (but not necessarily\ndistinct!), then the size of `s` divides the size of `s + t`.\"]\ntheorem card_dvd_card_mul_left {s t : Finset α} :\n    ((fun b => s.image fun a => a * b) '' (t : Set α)).PairwiseDisjoint id →\n      s.card ∣ (s * t).card :=\n  card_dvd_card_image₂_left fun _ _ => mul_left_injective _\n\n"}
{"name":"Finset.card_dvd_card_mul_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Group α\ninst✝ : DecidableEq α\ns t : Finset α\na✝ : (Set.image (fun x => HSMul.hSMul x t) ↑s).PairwiseDisjoint id\n⊢ Dvd.dvd t.card (HMul.hMul s t).card","decl":"/-- If the left cosets of `t` by elements of `s` are disjoint (but not necessarily distinct!), then\nthe size of `t` divides the size of `s * t`. -/\n@[to_additive \"If the left cosets of `t` by elements of `s` are disjoint (but not necessarily\ndistinct!), then the size of `t` divides the size of `s + t`.\"]\ntheorem card_dvd_card_mul_right {s t : Finset α} :\n    ((· • t) '' (s : Set α)).PairwiseDisjoint id → t.card ∣ (s * t).card :=\n  card_dvd_card_image₂_right fun _ _ => mul_right_injective _\n\n"}
{"name":"Finset.card_dvd_card_add_right","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : AddGroup α\ninst✝ : DecidableEq α\ns t : Finset α\na✝ : (Set.image (fun x => HVAdd.hVAdd x t) ↑s).PairwiseDisjoint id\n⊢ Dvd.dvd t.card (HAdd.hAdd s t).card","decl":"/-- If the left cosets of `t` by elements of `s` are disjoint (but not necessarily distinct!), then\nthe size of `t` divides the size of `s * t`. -/\n@[to_additive \"If the left cosets of `t` by elements of `s` are disjoint (but not necessarily\ndistinct!), then the size of `t` divides the size of `s + t`.\"]\ntheorem card_dvd_card_mul_right {s t : Finset α} :\n    ((· • t) '' (s : Set α)).PairwiseDisjoint id → t.card ∣ (s * t).card :=\n  card_dvd_card_image₂_right fun _ _ => mul_right_injective _\n\n"}
{"name":"Finset.neg_vadd_finset_distrib","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : AddGroup α\ninst✝ : DecidableEq α\na : α\ns : Finset α\n⊢ Eq (Neg.neg (HVAdd.hVAdd a s)) (HVAdd.hVAdd (AddOpposite.op (Neg.neg a)) (Neg.neg s))","decl":"@[to_additive (attr := simp)]\nlemma inv_smul_finset_distrib (a : α) (s : Finset α) : (a • s)⁻¹ = op a⁻¹ • s⁻¹ := by\n  ext; simp [← inv_smul_mem_iff]\n\n"}
{"name":"Finset.inv_smul_finset_distrib","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Group α\ninst✝ : DecidableEq α\na : α\ns : Finset α\n⊢ Eq (Inv.inv (HSMul.hSMul a s)) (HSMul.hSMul (MulOpposite.op (Inv.inv a)) (Inv.inv s))","decl":"@[to_additive (attr := simp)]\nlemma inv_smul_finset_distrib (a : α) (s : Finset α) : (a • s)⁻¹ = op a⁻¹ • s⁻¹ := by\n  ext; simp [← inv_smul_mem_iff]\n\n"}
{"name":"Finset.inv_op_smul_finset_distrib","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Group α\ninst✝ : DecidableEq α\na : α\ns : Finset α\n⊢ Eq (Inv.inv (HSMul.hSMul (MulOpposite.op a) s)) (HSMul.hSMul (Inv.inv a) (Inv.inv s))","decl":"@[to_additive (attr := simp)]\nlemma inv_op_smul_finset_distrib (a : α) (s : Finset α) : (op a • s)⁻¹ = a⁻¹ • s⁻¹ := by\n  ext; simp [← inv_smul_mem_iff]\n\n"}
{"name":"Finset.neg_op_vadd_finset_distrib","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : AddGroup α\ninst✝ : DecidableEq α\na : α\ns : Finset α\n⊢ Eq (Neg.neg (HVAdd.hVAdd (AddOpposite.op a) s)) (HVAdd.hVAdd (Neg.neg a) (Neg.neg s))","decl":"@[to_additive (attr := simp)]\nlemma inv_op_smul_finset_distrib (a : α) (s : Finset α) : (op a • s)⁻¹ = a⁻¹ • s⁻¹ := by\n  ext; simp [← inv_smul_mem_iff]\n\n"}
{"name":"Finset.sum_neg_index","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : AddCommMonoid α\nι : Type u_5\ninst✝¹ : DecidableEq ι\ninst✝ : InvolutiveNeg ι\ns : Finset ι\nf : ι → α\n⊢ Eq ((Neg.neg s).sum fun i => f i) (s.sum fun i => f (Neg.neg i))","decl":"@[to_additive (attr := simp)] lemma prod_inv_index [InvolutiveInv ι] (s : Finset ι) (f : ι → α) :\n    ∏ i ∈ s⁻¹, f i = ∏ i ∈ s, f i⁻¹ := prod_image inv_injective.injOn\n\n"}
{"name":"Finset.prod_inv_index","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : CommMonoid α\nι : Type u_5\ninst✝¹ : DecidableEq ι\ninst✝ : InvolutiveInv ι\ns : Finset ι\nf : ι → α\n⊢ Eq ((Inv.inv s).prod fun i => f i) (s.prod fun i => f (Inv.inv i))","decl":"@[to_additive (attr := simp)] lemma prod_inv_index [InvolutiveInv ι] (s : Finset ι) (f : ι → α) :\n    ∏ i ∈ s⁻¹, f i = ∏ i ∈ s, f i⁻¹ := prod_image inv_injective.injOn\n\n"}
{"name":"Finset.prod_neg_index","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : CommMonoid α\nι : Type u_5\ninst✝¹ : DecidableEq ι\ninst✝ : InvolutiveNeg ι\ns : Finset ι\nf : ι → α\n⊢ Eq ((Neg.neg s).prod fun i => f i) (s.prod fun i => f (Neg.neg i))","decl":"@[to_additive existing, simp] lemma prod_neg_index [InvolutiveNeg ι] (s : Finset ι) (f : ι → α) :\n    ∏ i ∈ -s, f i = ∏ i ∈ s, f (-i) := prod_image neg_injective.injOn\n\n"}
{"name":"Finset.sum_inv_index","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : AddCommMonoid α\nι : Type u_5\ninst✝¹ : DecidableEq ι\ninst✝ : InvolutiveInv ι\ns : Finset ι\nf : ι → α\n⊢ Eq ((Inv.inv s).sum fun i => f i) (s.sum fun i => f (Inv.inv i))","decl":"@[to_additive existing, simp] lemma sum_inv_index [InvolutiveInv ι] (s : Finset ι) (f : ι → α) :\n    ∑ i ∈ s⁻¹, f i = ∑ i ∈ s, f i⁻¹ := sum_image inv_injective.injOn\n\n"}
{"name":"Fintype.piFinset_smul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"ι : Type u_5\nα : ι → Type u_6\nβ : ι → Type u_7\ninst✝³ : Fintype ι\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → DecidableEq (β i)\ninst✝ : (i : ι) → SMul (α i) (β i)\ns : (i : ι) → Finset (α i)\nt : (i : ι) → Finset (β i)\n⊢ Eq (Fintype.piFinset fun i => HSMul.hSMul (s i) (t i)) (HSMul.hSMul (Fintype.piFinset s) (Fintype.piFinset t))","decl":"@[to_additive]\nlemma piFinset_smul [∀ i, SMul (α i) (β i)] (s : ∀ i, Finset (α i)) (t : ∀ i, Finset (β i)) :\n    piFinset (fun i ↦ s i • t i) = piFinset s • piFinset t := piFinset_image₂ _ _ _\n\n"}
{"name":"Fintype.piFinset_vadd","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"ι : Type u_5\nα : ι → Type u_6\nβ : ι → Type u_7\ninst✝³ : Fintype ι\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → DecidableEq (β i)\ninst✝ : (i : ι) → VAdd (α i) (β i)\ns : (i : ι) → Finset (α i)\nt : (i : ι) → Finset (β i)\n⊢ Eq (Fintype.piFinset fun i => HVAdd.hVAdd (s i) (t i)) (HVAdd.hVAdd (Fintype.piFinset s) (Fintype.piFinset t))","decl":"@[to_additive]\nlemma piFinset_smul [∀ i, SMul (α i) (β i)] (s : ∀ i, Finset (α i)) (t : ∀ i, Finset (β i)) :\n    piFinset (fun i ↦ s i • t i) = piFinset s • piFinset t := piFinset_image₂ _ _ _\n\n"}
{"name":"Fintype.piFinset_vadd_finset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"ι : Type u_5\nα : ι → Type u_6\nβ : ι → Type u_7\ninst✝³ : Fintype ι\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → DecidableEq (β i)\ninst✝ : (i : ι) → VAdd (α i) (β i)\na : (i : ι) → α i\ns : (i : ι) → Finset (β i)\n⊢ Eq (Fintype.piFinset fun i => HVAdd.hVAdd (a i) (s i)) (HVAdd.hVAdd a (Fintype.piFinset s))","decl":"@[to_additive]\nlemma piFinset_smul_finset [∀ i, SMul (α i) (β i)] (a : ∀ i, α i) (s : ∀ i, Finset (β i)) :\n    piFinset (fun i ↦ a i • s i) = a • piFinset s := piFinset_image _ _\n\n"}
{"name":"Fintype.piFinset_smul_finset","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"ι : Type u_5\nα : ι → Type u_6\nβ : ι → Type u_7\ninst✝³ : Fintype ι\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → DecidableEq (β i)\ninst✝ : (i : ι) → SMul (α i) (β i)\na : (i : ι) → α i\ns : (i : ι) → Finset (β i)\n⊢ Eq (Fintype.piFinset fun i => HSMul.hSMul (a i) (s i)) (HSMul.hSMul a (Fintype.piFinset s))","decl":"@[to_additive]\nlemma piFinset_smul_finset [∀ i, SMul (α i) (β i)] (a : ∀ i, α i) (s : ∀ i, Finset (β i)) :\n    piFinset (fun i ↦ a i • s i) = a • piFinset s := piFinset_image _ _\n\n"}
{"name":"Fintype.piFinset_add","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"ι : Type u_5\nα : ι → Type u_6\ninst✝³ : Fintype ι\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → DecidableEq (α i)\ninst✝ : (i : ι) → Add (α i)\ns t : (i : ι) → Finset (α i)\n⊢ Eq (Fintype.piFinset fun i => HAdd.hAdd (s i) (t i)) (HAdd.hAdd (Fintype.piFinset s) (Fintype.piFinset t))","decl":"@[to_additive]\nlemma piFinset_mul [∀ i, Mul (α i)] (s t : ∀ i, Finset (α i)) :\n    piFinset (fun i ↦ s i * t i) = piFinset s * piFinset t := piFinset_image₂ _ _ _\n\n"}
{"name":"Fintype.piFinset_mul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"ι : Type u_5\nα : ι → Type u_6\ninst✝³ : Fintype ι\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → DecidableEq (α i)\ninst✝ : (i : ι) → Mul (α i)\ns t : (i : ι) → Finset (α i)\n⊢ Eq (Fintype.piFinset fun i => HMul.hMul (s i) (t i)) (HMul.hMul (Fintype.piFinset s) (Fintype.piFinset t))","decl":"@[to_additive]\nlemma piFinset_mul [∀ i, Mul (α i)] (s t : ∀ i, Finset (α i)) :\n    piFinset (fun i ↦ s i * t i) = piFinset s * piFinset t := piFinset_image₂ _ _ _\n\n"}
{"name":"Fintype.piFinset_sub","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"ι : Type u_5\nα : ι → Type u_6\ninst✝³ : Fintype ι\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → DecidableEq (α i)\ninst✝ : (i : ι) → Sub (α i)\ns t : (i : ι) → Finset (α i)\n⊢ Eq (Fintype.piFinset fun i => HSub.hSub (s i) (t i)) (HSub.hSub (Fintype.piFinset s) (Fintype.piFinset t))","decl":"@[to_additive]\nlemma piFinset_div [∀ i, Div (α i)] (s t : ∀ i, Finset (α i)) :\n    piFinset (fun i ↦ s i / t i) = piFinset s / piFinset t := piFinset_image₂ _ _ _\n\n"}
{"name":"Fintype.piFinset_div","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"ι : Type u_5\nα : ι → Type u_6\ninst✝³ : Fintype ι\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → DecidableEq (α i)\ninst✝ : (i : ι) → Div (α i)\ns t : (i : ι) → Finset (α i)\n⊢ Eq (Fintype.piFinset fun i => HDiv.hDiv (s i) (t i)) (HDiv.hDiv (Fintype.piFinset s) (Fintype.piFinset t))","decl":"@[to_additive]\nlemma piFinset_div [∀ i, Div (α i)] (s t : ∀ i, Finset (α i)) :\n    piFinset (fun i ↦ s i / t i) = piFinset s / piFinset t := piFinset_image₂ _ _ _\n\n"}
{"name":"Fintype.piFinset_inv","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"ι : Type u_5\nα : ι → Type u_6\ninst✝³ : Fintype ι\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → DecidableEq (α i)\ninst✝ : (i : ι) → Inv (α i)\ns : (i : ι) → Finset (α i)\n⊢ Eq (Fintype.piFinset fun i => Inv.inv (s i)) (Inv.inv (Fintype.piFinset s))","decl":"@[to_additive (attr := simp)]\nlemma piFinset_inv [∀ i, Inv (α i)] (s : ∀ i, Finset (α i)) :\n    piFinset (fun i ↦ (s i)⁻¹) = (piFinset s)⁻¹ := piFinset_image _ _\n\n\n\n-- Note: We don't currently state `piFinset_vsub` because there's no\n-- `[∀ i, VSub (β i) (α i)] → VSub (∀ i, β i) (∀ i, α i)` instance\n\n"}
{"name":"Fintype.piFinset_neg","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"ι : Type u_5\nα : ι → Type u_6\ninst✝³ : Fintype ι\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → DecidableEq (α i)\ninst✝ : (i : ι) → Neg (α i)\ns : (i : ι) → Finset (α i)\n⊢ Eq (Fintype.piFinset fun i => Neg.neg (s i)) (Neg.neg (Fintype.piFinset s))","decl":"@[to_additive (attr := simp)]\nlemma piFinset_inv [∀ i, Inv (α i)] (s : ∀ i, Finset (α i)) :\n    piFinset (fun i ↦ (s i)⁻¹) = (piFinset s)⁻¹ := piFinset_image _ _\n\n\n\n-- Note: We don't currently state `piFinset_vsub` because there's no\n-- `[∀ i, VSub (β i) (α i)] → VSub (∀ i, β i) (∀ i, α i)` instance\n\n"}
{"name":"Set.toFinset_zero","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : Zero α\n⊢ Eq (Set.toFinset 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem toFinset_one : (1 : Set α).toFinset = 1 :=\n  rfl\n\n-- Porting note: should take priority over `Finite.toFinset_singleton`\n"}
{"name":"Set.toFinset_one","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : One α\n⊢ Eq (Set.toFinset 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem toFinset_one : (1 : Set α).toFinset = 1 :=\n  rfl\n\n-- Porting note: should take priority over `Finite.toFinset_singleton`\n"}
{"name":"Set.Finite.toFinset_zero","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : Zero α\nh : optParam (Set.Finite 0) ⋯\n⊢ Eq (Set.Finite.toFinset h) 0","decl":"@[to_additive (attr := simp high)]\ntheorem Finite.toFinset_one (h : (1 : Set α).Finite := finite_one) : h.toFinset = 1 :=\n  Finite.toFinset_singleton _\n\n"}
{"name":"Set.Finite.toFinset_one","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝ : One α\nh : optParam (Set.Finite 1) ⋯\n⊢ Eq (Set.Finite.toFinset h) 1","decl":"@[to_additive (attr := simp high)]\ntheorem Finite.toFinset_one (h : (1 : Set α).Finite := finite_one) : h.toFinset = 1 :=\n  Finite.toFinset_singleton _\n\n"}
{"name":"Set.toFinset_add","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝⁴ : DecidableEq α\ninst✝³ : Add α\ns t : Set α\ninst✝² : Fintype ↑s\ninst✝¹ : Fintype ↑t\ninst✝ : Fintype ↑(HAdd.hAdd s t)\n⊢ Eq (HAdd.hAdd s t).toFinset (HAdd.hAdd s.toFinset t.toFinset)","decl":"@[to_additive (attr := simp)]\ntheorem toFinset_mul (s t : Set α) [Fintype s] [Fintype t] [Fintype ↑(s * t)] :\n    (s * t).toFinset = s.toFinset * t.toFinset :=\n  toFinset_image2 _ _ _\n\n"}
{"name":"Set.toFinset_mul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝⁴ : DecidableEq α\ninst✝³ : Mul α\ns t : Set α\ninst✝² : Fintype ↑s\ninst✝¹ : Fintype ↑t\ninst✝ : Fintype ↑(HMul.hMul s t)\n⊢ Eq (HMul.hMul s t).toFinset (HMul.hMul s.toFinset t.toFinset)","decl":"@[to_additive (attr := simp)]\ntheorem toFinset_mul (s t : Set α) [Fintype s] [Fintype t] [Fintype ↑(s * t)] :\n    (s * t).toFinset = s.toFinset * t.toFinset :=\n  toFinset_image2 _ _ _\n\n"}
{"name":"Set.Finite.toFinset_mul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Mul α\ns t : Set α\nhs : s.Finite\nht : t.Finite\nhf : optParam (HMul.hMul s t).Finite ⋯\n⊢ Eq (Set.Finite.toFinset hf) (HMul.hMul hs.toFinset ht.toFinset)","decl":"@[to_additive]\ntheorem Finite.toFinset_mul (hs : s.Finite) (ht : t.Finite) (hf := hs.mul ht) :\n    hf.toFinset = hs.toFinset * ht.toFinset :=\n  Finite.toFinset_image2 _ _ _\n\n"}
{"name":"Set.Finite.toFinset_add","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Add α\ns t : Set α\nhs : s.Finite\nht : t.Finite\nhf : optParam (HAdd.hAdd s t).Finite ⋯\n⊢ Eq (Set.Finite.toFinset hf) (HAdd.hAdd hs.toFinset ht.toFinset)","decl":"@[to_additive]\ntheorem Finite.toFinset_mul (hs : s.Finite) (ht : t.Finite) (hf := hs.mul ht) :\n    hf.toFinset = hs.toFinset * ht.toFinset :=\n  Finite.toFinset_image2 _ _ _\n\n"}
{"name":"Set.toFinset_vadd","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁴ : VAdd α β\ninst✝³ : DecidableEq β\ns : Set α\nt : Set β\ninst✝² : Fintype ↑s\ninst✝¹ : Fintype ↑t\ninst✝ : Fintype ↑(HVAdd.hVAdd s t)\n⊢ Eq (HVAdd.hVAdd s t).toFinset (HVAdd.hVAdd s.toFinset t.toFinset)","decl":"@[to_additive (attr := simp)]\ntheorem toFinset_smul (s : Set α) (t : Set β) [Fintype s] [Fintype t] [Fintype ↑(s • t)] :\n    (s • t).toFinset = s.toFinset • t.toFinset :=\n  toFinset_image2 _ _ _\n\n"}
{"name":"Set.toFinset_smul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁴ : SMul α β\ninst✝³ : DecidableEq β\ns : Set α\nt : Set β\ninst✝² : Fintype ↑s\ninst✝¹ : Fintype ↑t\ninst✝ : Fintype ↑(HSMul.hSMul s t)\n⊢ Eq (HSMul.hSMul s t).toFinset (HSMul.hSMul s.toFinset t.toFinset)","decl":"@[to_additive (attr := simp)]\ntheorem toFinset_smul (s : Set α) (t : Set β) [Fintype s] [Fintype t] [Fintype ↑(s • t)] :\n    (s • t).toFinset = s.toFinset • t.toFinset :=\n  toFinset_image2 _ _ _\n\n"}
{"name":"Set.Finite.toFinset_vadd","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : VAdd α β\ninst✝ : DecidableEq β\ns : Set α\nt : Set β\nhs : s.Finite\nht : t.Finite\nhf : optParam (HVAdd.hVAdd s t).Finite ⋯\n⊢ Eq (Set.Finite.toFinset hf) (HVAdd.hVAdd hs.toFinset ht.toFinset)","decl":"@[to_additive]\ntheorem Finite.toFinset_smul (hs : s.Finite) (ht : t.Finite) (hf := hs.smul ht) :\n    hf.toFinset = hs.toFinset • ht.toFinset :=\n  Finite.toFinset_image2 _ _ _\n\n"}
{"name":"Set.Finite.toFinset_smul","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SMul α β\ninst✝ : DecidableEq β\ns : Set α\nt : Set β\nhs : s.Finite\nht : t.Finite\nhf : optParam (HSMul.hSMul s t).Finite ⋯\n⊢ Eq (Set.Finite.toFinset hf) (HSMul.hSMul hs.toFinset ht.toFinset)","decl":"@[to_additive]\ntheorem Finite.toFinset_smul (hs : s.Finite) (ht : t.Finite) (hf := hs.smul ht) :\n    hf.toFinset = hs.toFinset • ht.toFinset :=\n  Finite.toFinset_image2 _ _ _\n\n"}
{"name":"Set.toFinset_vadd_set","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq β\ninst✝² : VAdd α β\na : α\ns : Set β\ninst✝¹ : Fintype ↑s\ninst✝ : Fintype ↑(HVAdd.hVAdd a s)\n⊢ Eq (HVAdd.hVAdd a s).toFinset (HVAdd.hVAdd a s.toFinset)","decl":"@[to_additive (attr := simp)]\ntheorem toFinset_smul_set (a : α) (s : Set β) [Fintype s] [Fintype ↑(a • s)] :\n    (a • s).toFinset = a • s.toFinset :=\n  toFinset_image _ _\n\n"}
{"name":"Set.toFinset_smul_set","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq β\ninst✝² : SMul α β\na : α\ns : Set β\ninst✝¹ : Fintype ↑s\ninst✝ : Fintype ↑(HSMul.hSMul a s)\n⊢ Eq (HSMul.hSMul a s).toFinset (HSMul.hSMul a s.toFinset)","decl":"@[to_additive (attr := simp)]\ntheorem toFinset_smul_set (a : α) (s : Set β) [Fintype s] [Fintype ↑(a • s)] :\n    (a • s).toFinset = a • s.toFinset :=\n  toFinset_image _ _\n\n"}
{"name":"Set.Finite.toFinset_smul_set","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : SMul α β\na : α\ns : Set β\nhs : s.Finite\nhf : optParam (HSMul.hSMul a s).Finite ⋯\n⊢ Eq (Set.Finite.toFinset hf) (HSMul.hSMul a hs.toFinset)","decl":"@[to_additive]\ntheorem Finite.toFinset_smul_set (hs : s.Finite) (hf : (a • s).Finite := hs.smul_set) :\n    hf.toFinset = a • hs.toFinset :=\n  Finite.toFinset_image _ _ _\n\n"}
{"name":"Set.Finite.toFinset_vadd_set","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : VAdd α β\na : α\ns : Set β\nhs : s.Finite\nhf : optParam (HVAdd.hVAdd a s).Finite ⋯\n⊢ Eq (Set.Finite.toFinset hf) (HVAdd.hVAdd a hs.toFinset)","decl":"@[to_additive]\ntheorem Finite.toFinset_smul_set (hs : s.Finite) (hf : (a • s).Finite := hs.smul_set) :\n    hf.toFinset = a • hs.toFinset :=\n  Finite.toFinset_image _ _ _\n\n"}
{"name":"Set.toFinset_vsub","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁴ : DecidableEq α\ninst✝³ : VSub α β\ns t : Set β\ninst✝² : Fintype ↑s\ninst✝¹ : Fintype ↑t\ninst✝ : Fintype ↑(VSub.vsub s t)\n⊢ Eq (VSub.vsub s t).toFinset (VSub.vsub s.toFinset t.toFinset)","decl":"@[simp]\ntheorem toFinset_vsub (s t : Set β) [Fintype s] [Fintype t] [Fintype ↑(s -ᵥ t)] :\n    (s -ᵥ t : Set α).toFinset = s.toFinset -ᵥ t.toFinset :=\n  toFinset_image2 _ _ _\n\n"}
{"name":"Set.Finite.toFinset_vsub","module":"Mathlib.Algebra.Group.Pointwise.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : DecidableEq α\ninst✝ : VSub α β\ns t : Set β\nhs : s.Finite\nht : t.Finite\nhf : optParam (VSub.vsub s t).Finite ⋯\n⊢ Eq (Set.Finite.toFinset hf) (VSub.vsub hs.toFinset ht.toFinset)","decl":"theorem Finite.toFinset_vsub (hs : s.Finite) (ht : t.Finite) (hf := hs.vsub ht) :\n    hf.toFinset = hs.toFinset -ᵥ ht.toFinset :=\n  Finite.toFinset_image2 _ _ _\n\n"}
