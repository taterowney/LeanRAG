{"name":"Polynomial.mem_annIdeal_iff_aeval_eq_zero","module":"Mathlib.LinearAlgebra.AnnihilatingPolynomial","initialProofState":"R : Type u_1\nA : Type u_2\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Semiring A\ninstâœ : Algebra R A\na : A\np : Polynomial R\nâŠ¢ Iff (Membership.mem (Polynomial.annIdeal R a) p) (Eq ((Polynomial.aeval a) p) 0)","decl":"/-- It is useful to refer to ideal membership sometimes\n and the annihilation condition other times. -/\ntheorem mem_annIdeal_iff_aeval_eq_zero {a : A} {p : R[X]} : p âˆˆ annIdeal R a â†” aeval a p = 0 :=\n  Iff.rfl\n\n"}
{"name":"Polynomial.annIdealGenerator_eq_zero_iff","module":"Mathlib.LinearAlgebra.AnnihilatingPolynomial","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ² : Field ğ•œ\ninstâœÂ¹ : Ring A\ninstâœ : Algebra ğ•œ A\na : A\nâŠ¢ Iff (Eq (Polynomial.annIdealGenerator ğ•œ a) 0) (Eq (Polynomial.annIdeal ğ•œ a) Bot.bot)","decl":"@[simp]\ntheorem annIdealGenerator_eq_zero_iff {a : A} : annIdealGenerator ğ•œ a = 0 â†” annIdeal ğ•œ a = âŠ¥ := by\n  simp only [annIdealGenerator, mul_eq_zero, IsPrincipal.eq_bot_iff_generator_eq_zero,\n    Polynomial.C_eq_zero, inv_eq_zero, Polynomial.leadingCoeff_eq_zero, or_self_iff]\n\n"}
{"name":"Polynomial.span_singleton_annIdealGenerator","module":"Mathlib.LinearAlgebra.AnnihilatingPolynomial","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ² : Field ğ•œ\ninstâœÂ¹ : Ring A\ninstâœ : Algebra ğ•œ A\na : A\nâŠ¢ Eq (Ideal.span (Singleton.singleton (Polynomial.annIdealGenerator ğ•œ a))) (Polynomial.annIdeal ğ•œ a)","decl":"/-- `annIdealGenerator ğ•œ a` is indeed a generator. -/\n@[simp]\ntheorem span_singleton_annIdealGenerator (a : A) :\n    Ideal.span {annIdealGenerator ğ•œ a} = annIdeal ğ•œ a := by\n  by_cases h : annIdealGenerator ğ•œ a = 0\n  Â· rw [h, annIdealGenerator_eq_zero_iff.mp h, Set.singleton_zero, Ideal.span_zero]\n  Â· rw [annIdealGenerator, Ideal.span_singleton_mul_right_unit, Ideal.span_singleton_generator]\n    apply Polynomial.isUnit_C.mpr\n    apply IsUnit.mk0\n    apply inv_eq_zero.not.mpr\n    apply Polynomial.leadingCoeff_eq_zero.not.mpr\n    apply (mul_ne_zero_iff.mp h).1\n\n"}
{"name":"Polynomial.annIdealGenerator_mem","module":"Mathlib.LinearAlgebra.AnnihilatingPolynomial","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ² : Field ğ•œ\ninstâœÂ¹ : Ring A\ninstâœ : Algebra ğ•œ A\na : A\nâŠ¢ Membership.mem (Polynomial.annIdeal ğ•œ a) (Polynomial.annIdealGenerator ğ•œ a)","decl":"/-- The annihilating ideal generator is a member of the annihilating ideal. -/\ntheorem annIdealGenerator_mem (a : A) : annIdealGenerator ğ•œ a âˆˆ annIdeal ğ•œ a :=\n  Ideal.mul_mem_right _ _ (Submodule.IsPrincipal.generator_mem _)\n\n"}
{"name":"Polynomial.mem_iff_eq_smul_annIdealGenerator","module":"Mathlib.LinearAlgebra.AnnihilatingPolynomial","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ² : Field ğ•œ\ninstâœÂ¹ : Ring A\ninstâœ : Algebra ğ•œ A\np : Polynomial ğ•œ\na : A\nâŠ¢ Iff (Membership.mem (Polynomial.annIdeal ğ•œ a) p) (Exists fun s => Eq p (HSMul.hSMul s (Polynomial.annIdealGenerator ğ•œ a)))","decl":"theorem mem_iff_eq_smul_annIdealGenerator {p : ğ•œ[X]} (a : A) :\n    p âˆˆ annIdeal ğ•œ a â†” âˆƒ s : ğ•œ[X], p = s â€¢ annIdealGenerator ğ•œ a := by\n  simp_rw [@eq_comm _ p, â† mem_span_singleton, â† span_singleton_annIdealGenerator ğ•œ a, Ideal.span]\n\n"}
{"name":"Polynomial.monic_annIdealGenerator","module":"Mathlib.LinearAlgebra.AnnihilatingPolynomial","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ² : Field ğ•œ\ninstâœÂ¹ : Ring A\ninstâœ : Algebra ğ•œ A\na : A\nhg : Ne (Polynomial.annIdealGenerator ğ•œ a) 0\nâŠ¢ (Polynomial.annIdealGenerator ğ•œ a).Monic","decl":"/-- The generator we chose for the annihilating ideal is monic when the ideal is non-zero. -/\ntheorem monic_annIdealGenerator (a : A) (hg : annIdealGenerator ğ•œ a â‰  0) :\n    Monic (annIdealGenerator ğ•œ a) :=\n  monic_mul_leadingCoeff_inv (mul_ne_zero_iff.mp hg).1\n\n"}
{"name":"Polynomial.annIdealGenerator_aeval_eq_zero","module":"Mathlib.LinearAlgebra.AnnihilatingPolynomial","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ² : Field ğ•œ\ninstâœÂ¹ : Ring A\ninstâœ : Algebra ğ•œ A\na : A\nâŠ¢ Eq ((Polynomial.aeval a) (Polynomial.annIdealGenerator ğ•œ a)) 0","decl":"theorem annIdealGenerator_aeval_eq_zero (a : A) : aeval a (annIdealGenerator ğ•œ a) = 0 :=\n  mem_annIdeal_iff_aeval_eq_zero.mp (annIdealGenerator_mem ğ•œ a)\n\n"}
{"name":"Polynomial.mem_iff_annIdealGenerator_dvd","module":"Mathlib.LinearAlgebra.AnnihilatingPolynomial","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ² : Field ğ•œ\ninstâœÂ¹ : Ring A\ninstâœ : Algebra ğ•œ A\np : Polynomial ğ•œ\na : A\nâŠ¢ Iff (Membership.mem (Polynomial.annIdeal ğ•œ a) p) (Dvd.dvd (Polynomial.annIdealGenerator ğ•œ a) p)","decl":"theorem mem_iff_annIdealGenerator_dvd {p : ğ•œ[X]} {a : A} :\n    p âˆˆ annIdeal ğ•œ a â†” annIdealGenerator ğ•œ a âˆ£ p := by\n  rw [â† Ideal.mem_span_singleton, span_singleton_annIdealGenerator]\n\n"}
{"name":"Polynomial.degree_annIdealGenerator_le_of_mem","module":"Mathlib.LinearAlgebra.AnnihilatingPolynomial","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ² : Field ğ•œ\ninstâœÂ¹ : Ring A\ninstâœ : Algebra ğ•œ A\na : A\np : Polynomial ğ•œ\nhp : Membership.mem (Polynomial.annIdeal ğ•œ a) p\nhpn0 : Ne p 0\nâŠ¢ LE.le (Polynomial.annIdealGenerator ğ•œ a).degree p.degree","decl":"/-- The generator of the annihilating ideal has minimal degree among\n the non-zero members of the annihilating ideal -/\ntheorem degree_annIdealGenerator_le_of_mem (a : A) (p : ğ•œ[X]) (hp : p âˆˆ annIdeal ğ•œ a)\n    (hpn0 : p â‰  0) : degree (annIdealGenerator ğ•œ a) â‰¤ degree p :=\n  degree_le_of_dvd (mem_iff_annIdealGenerator_dvd.1 hp) hpn0\n\n"}
{"name":"Polynomial.annIdealGenerator_eq_minpoly","module":"Mathlib.LinearAlgebra.AnnihilatingPolynomial","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ² : Field ğ•œ\ninstâœÂ¹ : Ring A\ninstâœ : Algebra ğ•œ A\na : A\nâŠ¢ Eq (Polynomial.annIdealGenerator ğ•œ a) (minpoly ğ•œ a)","decl":"/-- The generator of the annihilating ideal is the minimal polynomial. -/\ntheorem annIdealGenerator_eq_minpoly (a : A) : annIdealGenerator ğ•œ a = minpoly ğ•œ a := by\n  by_cases h : annIdealGenerator ğ•œ a = 0\n  Â· rw [h, minpoly.eq_zero]\n    rintro âŸ¨p, p_monic, hp : aeval a p = 0âŸ©\n    refine p_monic.ne_zero (Ideal.mem_bot.mp ?_)\n    simpa only [annIdealGenerator_eq_zero_iff.mp h] using mem_annIdeal_iff_aeval_eq_zero.mpr hp\n  Â· exact minpoly.unique _ _ (monic_annIdealGenerator _ _ h) (annIdealGenerator_aeval_eq_zero _ _)\n      fun q q_monic hq =>\n        degree_annIdealGenerator_le_of_mem a q (mem_annIdeal_iff_aeval_eq_zero.mpr hq)\n          q_monic.ne_zero\n\n"}
{"name":"Polynomial.monic_generator_eq_minpoly","module":"Mathlib.LinearAlgebra.AnnihilatingPolynomial","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ² : Field ğ•œ\ninstâœÂ¹ : Ring A\ninstâœ : Algebra ğ•œ A\na : A\np : Polynomial ğ•œ\np_monic : p.Monic\np_gen : Eq (Ideal.span (Singleton.singleton p)) (Polynomial.annIdeal ğ•œ a)\nâŠ¢ Eq (Polynomial.annIdealGenerator ğ•œ a) p","decl":"/-- If a monic generates the annihilating ideal, it must match our choice\n of the annihilating ideal generator. -/\ntheorem monic_generator_eq_minpoly (a : A) (p : ğ•œ[X]) (p_monic : p.Monic)\n    (p_gen : Ideal.span {p} = annIdeal ğ•œ a) : annIdealGenerator ğ•œ a = p := by\n  by_cases h : p = 0\n  Â· rwa [h, annIdealGenerator_eq_zero_iff, â† p_gen, Ideal.span_singleton_eq_bot.mpr]\n  Â· rw [â† span_singleton_annIdealGenerator, Ideal.span_singleton_eq_span_singleton] at p_gen\n    rw [eq_comm]\n    apply eq_of_monic_of_associated p_monic _ p_gen\n    apply monic_annIdealGenerator _ _ ((Associated.ne_zero_iff p_gen).mp h)\n\n"}
{"name":"Polynomial.span_minpoly_eq_annihilator","module":"Mathlib.LinearAlgebra.AnnihilatingPolynomial","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : Field ğ•œ\nM : Type u_3\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module ğ•œ M\nf : Module.End ğ•œ M\nâŠ¢ Eq (Ideal.span (Singleton.singleton (minpoly ğ•œ f))) (Module.annihilator (Polynomial ğ•œ) (Module.AEval' f))","decl":"theorem span_minpoly_eq_annihilator {M} [AddCommGroup M] [Module ğ•œ M] (f : Module.End ğ•œ M) :\n    Ideal.span {minpoly ğ•œ f} = Module.annihilator ğ•œ[X] (Module.AEval' f) := by\n  rw [â† annIdealGenerator_eq_minpoly, span_singleton_annIdealGenerator]; ext\n  rw [mem_annIdeal_iff_aeval_eq_zero, DFunLike.ext_iff, Module.mem_annihilator]; rfl\n\n"}
