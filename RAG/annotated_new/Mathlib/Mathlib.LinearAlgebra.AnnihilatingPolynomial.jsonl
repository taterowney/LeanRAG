{"name":"Polynomial.mem_annIdeal_iff_aeval_eq_zero","module":"Mathlib.LinearAlgebra.AnnihilatingPolynomial","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\na : A\np : Polynomial R\n⊢ Iff (Membership.mem (Polynomial.annIdeal R a) p) (Eq ((Polynomial.aeval a) p) 0)","decl":"/-- It is useful to refer to ideal membership sometimes\n and the annihilation condition other times. -/\ntheorem mem_annIdeal_iff_aeval_eq_zero {a : A} {p : R[X]} : p ∈ annIdeal R a ↔ aeval a p = 0 :=\n  Iff.rfl\n\n"}
{"name":"Polynomial.annIdealGenerator_eq_zero_iff","module":"Mathlib.LinearAlgebra.AnnihilatingPolynomial","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝² : Field 𝕜\ninst✝¹ : Ring A\ninst✝ : Algebra 𝕜 A\na : A\n⊢ Iff (Eq (Polynomial.annIdealGenerator 𝕜 a) 0) (Eq (Polynomial.annIdeal 𝕜 a) Bot.bot)","decl":"@[simp]\ntheorem annIdealGenerator_eq_zero_iff {a : A} : annIdealGenerator 𝕜 a = 0 ↔ annIdeal 𝕜 a = ⊥ := by\n  simp only [annIdealGenerator, mul_eq_zero, IsPrincipal.eq_bot_iff_generator_eq_zero,\n    Polynomial.C_eq_zero, inv_eq_zero, Polynomial.leadingCoeff_eq_zero, or_self_iff]\n\n"}
{"name":"Polynomial.span_singleton_annIdealGenerator","module":"Mathlib.LinearAlgebra.AnnihilatingPolynomial","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝² : Field 𝕜\ninst✝¹ : Ring A\ninst✝ : Algebra 𝕜 A\na : A\n⊢ Eq (Ideal.span (Singleton.singleton (Polynomial.annIdealGenerator 𝕜 a))) (Polynomial.annIdeal 𝕜 a)","decl":"/-- `annIdealGenerator 𝕜 a` is indeed a generator. -/\n@[simp]\ntheorem span_singleton_annIdealGenerator (a : A) :\n    Ideal.span {annIdealGenerator 𝕜 a} = annIdeal 𝕜 a := by\n  by_cases h : annIdealGenerator 𝕜 a = 0\n  · rw [h, annIdealGenerator_eq_zero_iff.mp h, Set.singleton_zero, Ideal.span_zero]\n  · rw [annIdealGenerator, Ideal.span_singleton_mul_right_unit, Ideal.span_singleton_generator]\n    apply Polynomial.isUnit_C.mpr\n    apply IsUnit.mk0\n    apply inv_eq_zero.not.mpr\n    apply Polynomial.leadingCoeff_eq_zero.not.mpr\n    apply (mul_ne_zero_iff.mp h).1\n\n"}
{"name":"Polynomial.annIdealGenerator_mem","module":"Mathlib.LinearAlgebra.AnnihilatingPolynomial","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝² : Field 𝕜\ninst✝¹ : Ring A\ninst✝ : Algebra 𝕜 A\na : A\n⊢ Membership.mem (Polynomial.annIdeal 𝕜 a) (Polynomial.annIdealGenerator 𝕜 a)","decl":"/-- The annihilating ideal generator is a member of the annihilating ideal. -/\ntheorem annIdealGenerator_mem (a : A) : annIdealGenerator 𝕜 a ∈ annIdeal 𝕜 a :=\n  Ideal.mul_mem_right _ _ (Submodule.IsPrincipal.generator_mem _)\n\n"}
{"name":"Polynomial.mem_iff_eq_smul_annIdealGenerator","module":"Mathlib.LinearAlgebra.AnnihilatingPolynomial","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝² : Field 𝕜\ninst✝¹ : Ring A\ninst✝ : Algebra 𝕜 A\np : Polynomial 𝕜\na : A\n⊢ Iff (Membership.mem (Polynomial.annIdeal 𝕜 a) p) (Exists fun s => Eq p (HSMul.hSMul s (Polynomial.annIdealGenerator 𝕜 a)))","decl":"theorem mem_iff_eq_smul_annIdealGenerator {p : 𝕜[X]} (a : A) :\n    p ∈ annIdeal 𝕜 a ↔ ∃ s : 𝕜[X], p = s • annIdealGenerator 𝕜 a := by\n  simp_rw [@eq_comm _ p, ← mem_span_singleton, ← span_singleton_annIdealGenerator 𝕜 a, Ideal.span]\n\n"}
{"name":"Polynomial.monic_annIdealGenerator","module":"Mathlib.LinearAlgebra.AnnihilatingPolynomial","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝² : Field 𝕜\ninst✝¹ : Ring A\ninst✝ : Algebra 𝕜 A\na : A\nhg : Ne (Polynomial.annIdealGenerator 𝕜 a) 0\n⊢ (Polynomial.annIdealGenerator 𝕜 a).Monic","decl":"/-- The generator we chose for the annihilating ideal is monic when the ideal is non-zero. -/\ntheorem monic_annIdealGenerator (a : A) (hg : annIdealGenerator 𝕜 a ≠ 0) :\n    Monic (annIdealGenerator 𝕜 a) :=\n  monic_mul_leadingCoeff_inv (mul_ne_zero_iff.mp hg).1\n\n"}
{"name":"Polynomial.annIdealGenerator_aeval_eq_zero","module":"Mathlib.LinearAlgebra.AnnihilatingPolynomial","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝² : Field 𝕜\ninst✝¹ : Ring A\ninst✝ : Algebra 𝕜 A\na : A\n⊢ Eq ((Polynomial.aeval a) (Polynomial.annIdealGenerator 𝕜 a)) 0","decl":"theorem annIdealGenerator_aeval_eq_zero (a : A) : aeval a (annIdealGenerator 𝕜 a) = 0 :=\n  mem_annIdeal_iff_aeval_eq_zero.mp (annIdealGenerator_mem 𝕜 a)\n\n"}
{"name":"Polynomial.mem_iff_annIdealGenerator_dvd","module":"Mathlib.LinearAlgebra.AnnihilatingPolynomial","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝² : Field 𝕜\ninst✝¹ : Ring A\ninst✝ : Algebra 𝕜 A\np : Polynomial 𝕜\na : A\n⊢ Iff (Membership.mem (Polynomial.annIdeal 𝕜 a) p) (Dvd.dvd (Polynomial.annIdealGenerator 𝕜 a) p)","decl":"theorem mem_iff_annIdealGenerator_dvd {p : 𝕜[X]} {a : A} :\n    p ∈ annIdeal 𝕜 a ↔ annIdealGenerator 𝕜 a ∣ p := by\n  rw [← Ideal.mem_span_singleton, span_singleton_annIdealGenerator]\n\n"}
{"name":"Polynomial.degree_annIdealGenerator_le_of_mem","module":"Mathlib.LinearAlgebra.AnnihilatingPolynomial","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝² : Field 𝕜\ninst✝¹ : Ring A\ninst✝ : Algebra 𝕜 A\na : A\np : Polynomial 𝕜\nhp : Membership.mem (Polynomial.annIdeal 𝕜 a) p\nhpn0 : Ne p 0\n⊢ LE.le (Polynomial.annIdealGenerator 𝕜 a).degree p.degree","decl":"/-- The generator of the annihilating ideal has minimal degree among\n the non-zero members of the annihilating ideal -/\ntheorem degree_annIdealGenerator_le_of_mem (a : A) (p : 𝕜[X]) (hp : p ∈ annIdeal 𝕜 a)\n    (hpn0 : p ≠ 0) : degree (annIdealGenerator 𝕜 a) ≤ degree p :=\n  degree_le_of_dvd (mem_iff_annIdealGenerator_dvd.1 hp) hpn0\n\n"}
{"name":"Polynomial.annIdealGenerator_eq_minpoly","module":"Mathlib.LinearAlgebra.AnnihilatingPolynomial","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝² : Field 𝕜\ninst✝¹ : Ring A\ninst✝ : Algebra 𝕜 A\na : A\n⊢ Eq (Polynomial.annIdealGenerator 𝕜 a) (minpoly 𝕜 a)","decl":"/-- The generator of the annihilating ideal is the minimal polynomial. -/\ntheorem annIdealGenerator_eq_minpoly (a : A) : annIdealGenerator 𝕜 a = minpoly 𝕜 a := by\n  by_cases h : annIdealGenerator 𝕜 a = 0\n  · rw [h, minpoly.eq_zero]\n    rintro ⟨p, p_monic, hp : aeval a p = 0⟩\n    refine p_monic.ne_zero (Ideal.mem_bot.mp ?_)\n    simpa only [annIdealGenerator_eq_zero_iff.mp h] using mem_annIdeal_iff_aeval_eq_zero.mpr hp\n  · exact minpoly.unique _ _ (monic_annIdealGenerator _ _ h) (annIdealGenerator_aeval_eq_zero _ _)\n      fun q q_monic hq =>\n        degree_annIdealGenerator_le_of_mem a q (mem_annIdeal_iff_aeval_eq_zero.mpr hq)\n          q_monic.ne_zero\n\n"}
{"name":"Polynomial.monic_generator_eq_minpoly","module":"Mathlib.LinearAlgebra.AnnihilatingPolynomial","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝² : Field 𝕜\ninst✝¹ : Ring A\ninst✝ : Algebra 𝕜 A\na : A\np : Polynomial 𝕜\np_monic : p.Monic\np_gen : Eq (Ideal.span (Singleton.singleton p)) (Polynomial.annIdeal 𝕜 a)\n⊢ Eq (Polynomial.annIdealGenerator 𝕜 a) p","decl":"/-- If a monic generates the annihilating ideal, it must match our choice\n of the annihilating ideal generator. -/\ntheorem monic_generator_eq_minpoly (a : A) (p : 𝕜[X]) (p_monic : p.Monic)\n    (p_gen : Ideal.span {p} = annIdeal 𝕜 a) : annIdealGenerator 𝕜 a = p := by\n  by_cases h : p = 0\n  · rwa [h, annIdealGenerator_eq_zero_iff, ← p_gen, Ideal.span_singleton_eq_bot.mpr]\n  · rw [← span_singleton_annIdealGenerator, Ideal.span_singleton_eq_span_singleton] at p_gen\n    rw [eq_comm]\n    apply eq_of_monic_of_associated p_monic _ p_gen\n    apply monic_annIdealGenerator _ _ ((Associated.ne_zero_iff p_gen).mp h)\n\n"}
{"name":"Polynomial.span_minpoly_eq_annihilator","module":"Mathlib.LinearAlgebra.AnnihilatingPolynomial","initialProofState":"𝕜 : Type u_1\ninst✝² : Field 𝕜\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module 𝕜 M\nf : Module.End 𝕜 M\n⊢ Eq (Ideal.span (Singleton.singleton (minpoly 𝕜 f))) (Module.annihilator (Polynomial 𝕜) (Module.AEval' f))","decl":"theorem span_minpoly_eq_annihilator {M} [AddCommGroup M] [Module 𝕜 M] (f : Module.End 𝕜 M) :\n    Ideal.span {minpoly 𝕜 f} = Module.annihilator 𝕜[X] (Module.AEval' f) := by\n  rw [← annIdealGenerator_eq_minpoly, span_singleton_annIdealGenerator]; ext\n  rw [mem_annIdeal_iff_aeval_eq_zero, DFunLike.ext_iff, Module.mem_annihilator]; rfl\n\n"}
