{"name":"LieModule.nontrivial_of_isIrreducible","module":"Mathlib.Algebra.Lie.Semisimple.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule.IsIrreducible R L M\n⊢ Nontrivial M","decl":"lemma LieModule.nontrivial_of_isIrreducible [LieModule.IsIrreducible R L M] : Nontrivial M where\n  exists_pair_ne := by\n    have aux : (⊥ : LieSubmodule R L M) ≠ ⊤ := bot_ne_top\n    contrapose! aux\n    ext m\n    simpa using aux m 0\n\n"}
{"name":"LieAlgebra.HasTrivialRadical.eq_bot_of_isSolvable","module":"Mathlib.Algebra.Lie.Semisimple.Basic","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\ninst✝ : LieAlgebra.HasTrivialRadical R L\nI : LieIdeal R L\nhI : LieAlgebra.IsSolvable (Subtype fun x => Membership.mem I x)\n⊢ Eq I Bot.bot","decl":"variable {R L} in\ntheorem HasTrivialRadical.eq_bot_of_isSolvable [HasTrivialRadical R L]\n    (I : LieIdeal R L) [hI : IsSolvable I] : I = ⊥ :=\n  sSup_eq_bot.mp radical_eq_bot _ hI\n\n"}
{"name":"LieAlgebra.HasTrivialRadical.center_eq_bot","module":"Mathlib.Algebra.Lie.Semisimple.Basic","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\ninst✝ : LieAlgebra.HasTrivialRadical R L\n⊢ Eq (LieAlgebra.center R L) Bot.bot","decl":"@[simp]\ntheorem HasTrivialRadical.center_eq_bot [HasTrivialRadical R L] : center R L = ⊥ :=\n  HasTrivialRadical.eq_bot_of_isSolvable _\n\n"}
{"name":"LieAlgebra.hasTrivialRadical_of_no_solvable_ideals","module":"Mathlib.Algebra.Lie.Semisimple.Basic","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nh : ∀ (I : LieIdeal R L), LieAlgebra.IsSolvable (Subtype fun x => Membership.mem I x) → Eq I Bot.bot\n⊢ LieAlgebra.HasTrivialRadical R L","decl":"variable {R L} in\ntheorem hasTrivialRadical_of_no_solvable_ideals (h : ∀ I : LieIdeal R L, IsSolvable I → I = ⊥) :\n    HasTrivialRadical R L :=\n  ⟨sSup_eq_bot.mpr h⟩\n\n"}
{"name":"LieAlgebra.hasTrivialRadical_iff_no_solvable_ideals","module":"Mathlib.Algebra.Lie.Semisimple.Basic","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ Iff (LieAlgebra.HasTrivialRadical R L) (∀ (I : LieIdeal R L), LieAlgebra.IsSolvable (Subtype fun x => Membership.mem I x) → Eq I Bot.bot)","decl":"theorem hasTrivialRadical_iff_no_solvable_ideals :\n    HasTrivialRadical R L ↔ ∀ I : LieIdeal R L, IsSolvable I → I = ⊥ :=\n  ⟨@HasTrivialRadical.eq_bot_of_isSolvable _ _ _ _ _, hasTrivialRadical_of_no_solvable_ideals⟩\n\n"}
{"name":"LieAlgebra.hasTrivialRadical_iff_no_abelian_ideals","module":"Mathlib.Algebra.Lie.Semisimple.Basic","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ Iff (LieAlgebra.HasTrivialRadical R L) (∀ (I : LieIdeal R L), IsLieAbelian (Subtype fun x => Membership.mem I x) → Eq I Bot.bot)","decl":"theorem hasTrivialRadical_iff_no_abelian_ideals :\n    HasTrivialRadical R L ↔ ∀ I : LieIdeal R L, IsLieAbelian I → I = ⊥ := by\n  rw [hasTrivialRadical_iff_no_solvable_ideals]\n  constructor <;> intro h₁ I h₂\n  · exact h₁ _ <| LieAlgebra.ofAbelianIsSolvable I\n  · rw [← abelian_of_solvable_ideal_eq_bot_iff]\n    exact h₁ _ <| abelian_derivedAbelianOfIdeal I\n\n"}
{"name":"LieAlgebra.IsSimple.instIsIrreducible","module":"Mathlib.Algebra.Lie.Semisimple.Basic","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ LieModule.IsIrreducible R L L","decl":"instance : LieModule.IsIrreducible R L L := by\n  suffices Nontrivial (LieIdeal R L) from ⟨IsSimple.eq_bot_or_eq_top⟩\n  rw [LieSubmodule.nontrivial_iff, ← not_subsingleton_iff_nontrivial]\n  have _i : ¬ IsLieAbelian L := IsSimple.non_abelian R\n  contrapose! _i\n  infer_instance\n\n"}
{"name":"LieAlgebra.IsSimple.eq_top_of_isAtom","module":"Mathlib.Algebra.Lie.Semisimple.Basic","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\ninst✝ : LieAlgebra.IsSimple R L\nI : LieIdeal R L\nhI : IsAtom I\n⊢ Eq I Top.top","decl":"variable {R L} in\nlemma eq_top_of_isAtom (I : LieIdeal R L) (hI : IsAtom I) : I = ⊤ :=\n  (IsSimple.eq_bot_or_eq_top I).resolve_left hI.1\n\n"}
{"name":"LieAlgebra.IsSimple.isAtom_top","module":"Mathlib.Algebra.Lie.Semisimple.Basic","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\ninst✝ : LieAlgebra.IsSimple R L\n⊢ IsAtom Top.top","decl":"lemma isAtom_top : IsAtom (⊤ : LieIdeal R L) :=\n  ⟨bot_ne_top.symm, fun _ h ↦ h.eq_bot⟩\n\n"}
{"name":"LieAlgebra.IsSimple.isAtom_iff_eq_top","module":"Mathlib.Algebra.Lie.Semisimple.Basic","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\ninst✝ : LieAlgebra.IsSimple R L\nI : LieIdeal R L\n⊢ Iff (IsAtom I) (Eq I Top.top)","decl":"variable {R L} in\n@[simp] lemma isAtom_iff_eq_top (I : LieIdeal R L) : IsAtom I ↔ I = ⊤ :=\n  ⟨eq_top_of_isAtom I, fun h ↦ h ▸ isAtom_top R L⟩\n\n"}
{"name":"LieAlgebra.IsSimple.instHasTrivialRadical","module":"Mathlib.Algebra.Lie.Semisimple.Basic","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ LieAlgebra.HasTrivialRadical R L","decl":"instance : HasTrivialRadical R L := by\n  rw [hasTrivialRadical_iff_no_abelian_ideals]\n  intro I hI\n  apply (IsSimple.eq_bot_or_eq_top I).resolve_right\n  rintro rfl\n  rw [lie_abelian_iff_equiv_lie_abelian LieIdeal.topEquiv] at hI\n  exact IsSimple.non_abelian R (L := L) hI\n\n"}
{"name":"LieAlgebra.IsSemisimple.isSimple_of_isAtom","module":"Mathlib.Algebra.Lie.Semisimple.Basic","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\ninst✝ : LieAlgebra.IsSemisimple R L\nI : LieIdeal R L\nhI : IsAtom I\n⊢ LieAlgebra.IsSimple R (Subtype fun x => Membership.mem I x)","decl":"lemma isSimple_of_isAtom (I : LieIdeal R L) (hI : IsAtom I) : IsSimple R I where\n  non_abelian := IsSemisimple.non_abelian_of_isAtom I hI\n  eq_bot_or_eq_top := by\n    -- Suppose that `J` is an ideal of `I`.\n    intro J\n    -- We first show that `J` is also an ideal of the ambient Lie algebra `L`.\n    let J' : LieIdeal R L :=\n    { __ := J.toSubmodule.map I.incl.toLinearMap\n      lie_mem := by\n        rintro x _ ⟨y, hy, rfl⟩\n        dsimp\n        -- We need to show that `⁅x, y⁆ ∈ J` for any `x ∈ L` and `y ∈ J`.\n        -- Since `L` is semisimple, `x` is contained\n        -- in the supremum of `I` and the atoms not equal to `I`.\n        have hx : x ∈ I ⊔ sSup ({I' : LieIdeal R L | IsAtom I'} \\ {I}) := by\n          nth_rewrite 1 [← sSup_singleton (a := I)]\n          rw [← sSup_union, Set.union_diff_self, Set.union_eq_self_of_subset_left,\n            IsSemisimple.sSup_atoms_eq_top]\n          · apply LieSubmodule.mem_top\n          · simp only [Set.singleton_subset_iff, Set.mem_setOf_eq, hI]\n        -- Hence we can write `x` as `a + b` with `a ∈ I`\n        -- and `b` in the supremum of the atoms not equal to `I`.\n        rw [LieSubmodule.mem_sup] at hx\n        obtain ⟨a, ha, b, hb, rfl⟩ := hx\n        -- Therefore it suffices to show that `⁅a, y⁆ ∈ J` and `⁅b, y⁆ ∈ J`.\n        simp only [add_lie, AddSubsemigroup.mem_carrier, AddSubmonoid.mem_toSubsemigroup,\n          Submodule.mem_toAddSubmonoid]\n        apply add_mem\n        -- Now `⁅a, y⁆ ∈ J` since `a ∈ I`, `y ∈ J`, and `J` is an ideal of `I`.\n        · simp only [Submodule.mem_map, LieSubmodule.mem_toSubmodule, Subtype.exists]\n          erw [Submodule.coe_subtype]\n          simp only [exists_and_right, exists_eq_right, ha, lie_mem_left, exists_true_left]\n          exact lie_mem_right R I J ⟨a, ha⟩ y hy\n        -- Finally `⁅b, y⁆ = 0`, by the independence of the atoms.\n        · suffices ⁅b, y.val⁆ = 0 by erw [this]; simp only [zero_mem]\n          rw [← LieSubmodule.mem_bot (R := R) (L := L),\n              ← (IsSemisimple.sSupIndep_isAtom hI).eq_bot]\n          exact ⟨lie_mem_right R L I b y y.2, lie_mem_left _ _ _ _ _ hb⟩ }\n    -- Now that we know that `J` is an ideal of `L`,\n    -- we start with the proof that `I` is a simple Lie algebra.\n    -- Assume that `J ≠ ⊤`.\n    rw [or_iff_not_imp_right]\n    intro hJ\n    suffices J' = ⊥ by\n      rw [eq_bot_iff] at this ⊢\n      intro x hx\n      suffices x ∈ J → x = 0 from this hx\n      have := @this x.1\n      simp only [LieIdeal.incl_coe, LieIdeal.toLieSubalgebra_toSubmodule,\n        LieSubmodule.mem_mk_iff', Submodule.mem_map, LieSubmodule.mem_toSubmodule, Subtype.exists,\n        LieSubmodule.mem_bot, ZeroMemClass.coe_eq_zero, forall_exists_index, and_imp, J'] at this\n      exact fun _ ↦ this (↑x) x.property hx rfl\n    -- We need to show that `J = ⊥`.\n    -- Since `J` is an ideal of `L`, and `I` is an atom,\n    -- it suffices to show that `J < I`.\n    apply hI.2\n    rw [lt_iff_le_and_ne]\n    constructor\n    -- We know that `J ≤ I` since `J` is an ideal of `I`.\n    · rintro _ ⟨x, -, rfl⟩\n      exact x.2\n    -- So we need to show `J ≠ I` as ideals of `L`.\n    -- This follows from our assumption that `J ≠ ⊤` as ideals of `I`.\n    contrapose! hJ\n    rw [eq_top_iff]\n    rintro ⟨x, hx⟩ -\n    rw [← hJ] at hx\n    rcases hx with ⟨y, hy, rfl⟩\n    exact hy\n\n"}
{"name":"LieAlgebra.IsSemisimple.booleanGenerators","module":"Mathlib.Algebra.Lie.Semisimple.Basic","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\ninst✝ : LieAlgebra.IsSemisimple R L\n⊢ IsCompactlyGenerated.BooleanGenerators (setOf fun I => IsAtom I)","decl":"variable (R L) in\nlemma booleanGenerators : BooleanGenerators {I : LieIdeal R L | IsAtom I} where\n  isAtom _ hI := hI\n  finitelyAtomistic _ _ hs _ hIs := finitelyAtomistic _ hs _ hIs\n\n"}
{"name":"LieAlgebra.IsSemisimple.instHasTrivialRadical","module":"Mathlib.Algebra.Lie.Semisimple.Basic","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ LieAlgebra.HasTrivialRadical R L","decl":"/-- A semisimple Lie algebra has trivial radical. -/\ninstance (priority := 100) instHasTrivialRadical : HasTrivialRadical R L := by\n  rw [hasTrivialRadical_iff_no_abelian_ideals]\n  intro I hI\n  apply (eq_bot_or_exists_atom_le I).resolve_right\n  rintro ⟨J, hJ, hJ'⟩\n  apply IsSemisimple.non_abelian_of_isAtom J hJ\n  constructor\n  intro x y\n  ext\n  simp only [LieIdeal.coe_bracket_of_module, LieSubmodule.coe_bracket, ZeroMemClass.coe_zero]\n  have : (⁅(⟨x, hJ' x.2⟩ : I), ⟨y, hJ' y.2⟩⁆ : I) = 0 := trivial_lie_zero _ _ _ _\n  apply_fun Subtype.val at this\n  exact this\n\n"}
{"name":"LieAlgebra.IsSimple.instIsSemisimple","module":"Mathlib.Algebra.Lie.Semisimple.Basic","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\ninst✝ : LieAlgebra.IsSimple R L\n⊢ LieAlgebra.IsSemisimple R L","decl":"/-- A simple Lie algebra is semisimple. -/\ninstance (priority := 100) IsSimple.instIsSemisimple [IsSimple R L] :\n    IsSemisimple R L := by\n  constructor\n  · simp\n  · simpa using sSupIndep_singleton _\n  · intro I hI₁ hI₂\n    apply IsSimple.non_abelian (R := R) (L := L)\n    rw [IsSimple.isAtom_iff_eq_top] at hI₁\n    rwa [hI₁, lie_abelian_iff_equiv_lie_abelian LieIdeal.topEquiv] at hI₂\n\n"}
{"name":"LieAlgebra.subsingleton_of_hasTrivialRadical_lie_abelian","module":"Mathlib.Algebra.Lie.Semisimple.Basic","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\ninst✝ : LieAlgebra.HasTrivialRadical R L\nh : IsLieAbelian L\n⊢ Subsingleton L","decl":"/-- An abelian Lie algebra with trivial radical is trivial. -/\ntheorem subsingleton_of_hasTrivialRadical_lie_abelian [HasTrivialRadical R L] [h : IsLieAbelian L] :\n    Subsingleton L := by\n  rw [isLieAbelian_iff_center_eq_top R L, HasTrivialRadical.center_eq_bot] at h\n  exact (LieSubmodule.subsingleton_iff R L L).mp (subsingleton_of_bot_eq_top h)\n\n"}
{"name":"LieAlgebra.abelian_radical_of_hasTrivialRadical","module":"Mathlib.Algebra.Lie.Semisimple.Basic","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\ninst✝ : LieAlgebra.HasTrivialRadical R L\n⊢ IsLieAbelian (Subtype fun x => Membership.mem (LieAlgebra.radical R L) x)","decl":"theorem abelian_radical_of_hasTrivialRadical [HasTrivialRadical R L] :\n    IsLieAbelian (radical R L) := by\n  rw [HasTrivialRadical.radical_eq_bot]; exact LieIdeal.isLieAbelian_of_trivial ..\n\n"}
{"name":"LieAlgebra.abelian_radical_iff_solvable_is_abelian","module":"Mathlib.Algebra.Lie.Semisimple.Basic","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\ninst✝ : IsNoetherian R L\n⊢ Iff (IsLieAbelian (Subtype fun x => Membership.mem (LieAlgebra.radical R L) x)) (∀ (I : LieIdeal R L), LieAlgebra.IsSolvable (Subtype fun x => Membership.mem I x) → IsLieAbelian (Subtype fun x => Membership.mem I x))","decl":"/-- The two properties shown to be equivalent here are possible definitions for a Lie algebra\nto be reductive.\n\nNote that there is absolutely [no agreement](https://mathoverflow.net/questions/284713/) on what\nthe label 'reductive' should mean when the coefficients are not a field of characteristic zero. -/\ntheorem abelian_radical_iff_solvable_is_abelian [IsNoetherian R L] :\n    IsLieAbelian (radical R L) ↔ ∀ I : LieIdeal R L, IsSolvable I → IsLieAbelian I := by\n  constructor\n  · rintro h₁ I h₂\n    rw [LieIdeal.solvable_iff_le_radical] at h₂\n    exact (LieIdeal.inclusion_injective h₂).isLieAbelian h₁\n  · intro h; apply h; infer_instance\n\n"}
{"name":"LieAlgebra.ad_ker_eq_bot_of_hasTrivialRadical","module":"Mathlib.Algebra.Lie.Semisimple.Basic","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\ninst✝ : LieAlgebra.HasTrivialRadical R L\n⊢ Eq (LieAlgebra.ad R L).ker Bot.bot","decl":"theorem ad_ker_eq_bot_of_hasTrivialRadical [HasTrivialRadical R L] : (ad R L).ker = ⊥ := by simp\n\n"}
