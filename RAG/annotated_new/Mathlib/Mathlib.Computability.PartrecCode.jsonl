{"name":"Nat.Partrec.rfind'","module":"Mathlib.Computability.PartrecCode","initialProofState":"f : PFun Nat Nat\nhf : Nat.Partrec f\n⊢ Nat.Partrec (Nat.unpaired fun a m => Part.map (fun x => HAdd.hAdd x m) (Nat.rfind fun n => Functor.map (fun m => Decidable.decide (Eq m 0)) (f (Nat.pair a (HAdd.hAdd n m)))))","decl":"theorem rfind' {f} (hf : Nat.Partrec f) :\n    Nat.Partrec\n      (Nat.unpaired fun a m =>\n        (Nat.rfind fun n => (fun m => m = 0) <$> f (Nat.pair a (n + m))).map (· + m)) :=\n  Partrec₂.unpaired'.2 <| by\n    refine\n      Partrec.map\n        ((@Partrec₂.unpaired' fun a b : ℕ =>\n              Nat.rfind fun n => (fun m => m = 0) <$> f (Nat.pair a (n + b))).1\n          ?_)\n        (Primrec.nat_add.comp Primrec.snd <| Primrec.snd.comp Primrec.fst).to_comp.to₂\n    have : Nat.Partrec (fun a => Nat.rfind (fun n => (fun m => decide (m = 0)) <$>\n      Nat.unpaired (fun a b => f (Nat.pair (Nat.unpair a).1 (b + (Nat.unpair a).2)))\n        (Nat.pair a n))) :=\n      rfind\n        (Partrec₂.unpaired'.2\n          ((Partrec.nat_iff.2 hf).comp\n              (Primrec₂.pair.comp (Primrec.fst.comp <| Primrec.unpair.comp Primrec.fst)\n                  (Primrec.nat_add.comp Primrec.snd\n                    (Primrec.snd.comp <| Primrec.unpair.comp Primrec.fst))).to_comp))\n    simpa\n\n"}
{"name":"Nat.Partrec.Code.prec.inj","module":"Mathlib.Computability.PartrecCode","initialProofState":"a✝³ a✝² a✝¹ a✝ : Nat.Partrec.Code\nx✝ : Eq (a✝³.prec a✝²) (a✝¹.prec a✝)\n⊢ And (Eq a✝³ a✝¹) (Eq a✝² a✝)","decl":"/-- Code for partial recursive functions from ℕ to ℕ.\nSee `Nat.Partrec.Code.eval` for the interpretation of these constructors.\n-/\ninductive Code : Type\n  | zero : Code\n  | succ : Code\n  | left : Code\n  | right : Code\n  | pair : Code → Code → Code\n  | comp : Code → Code → Code\n  | prec : Code → Code → Code\n  | rfind' : Code → Code\n\n"}
{"name":"Nat.Partrec.Code.comp.inj","module":"Mathlib.Computability.PartrecCode","initialProofState":"a✝³ a✝² a✝¹ a✝ : Nat.Partrec.Code\nx✝ : Eq (a✝³.comp a✝²) (a✝¹.comp a✝)\n⊢ And (Eq a✝³ a✝¹) (Eq a✝² a✝)","decl":"/-- Code for partial recursive functions from ℕ to ℕ.\nSee `Nat.Partrec.Code.eval` for the interpretation of these constructors.\n-/\ninductive Code : Type\n  | zero : Code\n  | succ : Code\n  | left : Code\n  | right : Code\n  | pair : Code → Code → Code\n  | comp : Code → Code → Code\n  | prec : Code → Code → Code\n  | rfind' : Code → Code\n\n"}
{"name":"Nat.Partrec.Code.succ.sizeOf_spec","module":"Mathlib.Computability.PartrecCode","initialProofState":"⊢ Eq (SizeOf.sizeOf Nat.Partrec.Code.succ) 1","decl":"/-- Code for partial recursive functions from ℕ to ℕ.\nSee `Nat.Partrec.Code.eval` for the interpretation of these constructors.\n-/\ninductive Code : Type\n  | zero : Code\n  | succ : Code\n  | left : Code\n  | right : Code\n  | pair : Code → Code → Code\n  | comp : Code → Code → Code\n  | prec : Code → Code → Code\n  | rfind' : Code → Code\n\n"}
{"name":"Nat.Partrec.Code.pair.injEq","module":"Mathlib.Computability.PartrecCode","initialProofState":"a✝³ a✝² a✝¹ a✝ : Nat.Partrec.Code\n⊢ Eq (Eq (a✝³.pair a✝²) (a✝¹.pair a✝)) (And (Eq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- Code for partial recursive functions from ℕ to ℕ.\nSee `Nat.Partrec.Code.eval` for the interpretation of these constructors.\n-/\ninductive Code : Type\n  | zero : Code\n  | succ : Code\n  | left : Code\n  | right : Code\n  | pair : Code → Code → Code\n  | comp : Code → Code → Code\n  | prec : Code → Code → Code\n  | rfind' : Code → Code\n\n"}
{"name":"Nat.Partrec.Code.prec.sizeOf_spec","module":"Mathlib.Computability.PartrecCode","initialProofState":"a✝¹ a✝ : Nat.Partrec.Code\n⊢ Eq (SizeOf.sizeOf (a✝¹.prec a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- Code for partial recursive functions from ℕ to ℕ.\nSee `Nat.Partrec.Code.eval` for the interpretation of these constructors.\n-/\ninductive Code : Type\n  | zero : Code\n  | succ : Code\n  | left : Code\n  | right : Code\n  | pair : Code → Code → Code\n  | comp : Code → Code → Code\n  | prec : Code → Code → Code\n  | rfind' : Code → Code\n\n"}
{"name":"Nat.Partrec.Code.prec.injEq","module":"Mathlib.Computability.PartrecCode","initialProofState":"a✝³ a✝² a✝¹ a✝ : Nat.Partrec.Code\n⊢ Eq (Eq (a✝³.prec a✝²) (a✝¹.prec a✝)) (And (Eq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- Code for partial recursive functions from ℕ to ℕ.\nSee `Nat.Partrec.Code.eval` for the interpretation of these constructors.\n-/\ninductive Code : Type\n  | zero : Code\n  | succ : Code\n  | left : Code\n  | right : Code\n  | pair : Code → Code → Code\n  | comp : Code → Code → Code\n  | prec : Code → Code → Code\n  | rfind' : Code → Code\n\n"}
{"name":"Nat.Partrec.Code.pair.sizeOf_spec","module":"Mathlib.Computability.PartrecCode","initialProofState":"a✝¹ a✝ : Nat.Partrec.Code\n⊢ Eq (SizeOf.sizeOf (a✝¹.pair a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- Code for partial recursive functions from ℕ to ℕ.\nSee `Nat.Partrec.Code.eval` for the interpretation of these constructors.\n-/\ninductive Code : Type\n  | zero : Code\n  | succ : Code\n  | left : Code\n  | right : Code\n  | pair : Code → Code → Code\n  | comp : Code → Code → Code\n  | prec : Code → Code → Code\n  | rfind' : Code → Code\n\n"}
{"name":"Nat.Partrec.Code.comp.injEq","module":"Mathlib.Computability.PartrecCode","initialProofState":"a✝³ a✝² a✝¹ a✝ : Nat.Partrec.Code\n⊢ Eq (Eq (a✝³.comp a✝²) (a✝¹.comp a✝)) (And (Eq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- Code for partial recursive functions from ℕ to ℕ.\nSee `Nat.Partrec.Code.eval` for the interpretation of these constructors.\n-/\ninductive Code : Type\n  | zero : Code\n  | succ : Code\n  | left : Code\n  | right : Code\n  | pair : Code → Code → Code\n  | comp : Code → Code → Code\n  | prec : Code → Code → Code\n  | rfind' : Code → Code\n\n"}
{"name":"Nat.Partrec.Code.pair.inj","module":"Mathlib.Computability.PartrecCode","initialProofState":"a✝³ a✝² a✝¹ a✝ : Nat.Partrec.Code\nx✝ : Eq (a✝³.pair a✝²) (a✝¹.pair a✝)\n⊢ And (Eq a✝³ a✝¹) (Eq a✝² a✝)","decl":"/-- Code for partial recursive functions from ℕ to ℕ.\nSee `Nat.Partrec.Code.eval` for the interpretation of these constructors.\n-/\ninductive Code : Type\n  | zero : Code\n  | succ : Code\n  | left : Code\n  | right : Code\n  | pair : Code → Code → Code\n  | comp : Code → Code → Code\n  | prec : Code → Code → Code\n  | rfind' : Code → Code\n\n"}
{"name":"Nat.Partrec.Code.comp.sizeOf_spec","module":"Mathlib.Computability.PartrecCode","initialProofState":"a✝¹ a✝ : Nat.Partrec.Code\n⊢ Eq (SizeOf.sizeOf (a✝¹.comp a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- Code for partial recursive functions from ℕ to ℕ.\nSee `Nat.Partrec.Code.eval` for the interpretation of these constructors.\n-/\ninductive Code : Type\n  | zero : Code\n  | succ : Code\n  | left : Code\n  | right : Code\n  | pair : Code → Code → Code\n  | comp : Code → Code → Code\n  | prec : Code → Code → Code\n  | rfind' : Code → Code\n\n"}
{"name":"Nat.Partrec.Code.rfind'.inj","module":"Mathlib.Computability.PartrecCode","initialProofState":"a✝¹ a✝ : Nat.Partrec.Code\nx✝ : Eq a✝¹.rfind' a✝.rfind'\n⊢ Eq a✝¹ a✝","decl":"/-- Code for partial recursive functions from ℕ to ℕ.\nSee `Nat.Partrec.Code.eval` for the interpretation of these constructors.\n-/\ninductive Code : Type\n  | zero : Code\n  | succ : Code\n  | left : Code\n  | right : Code\n  | pair : Code → Code → Code\n  | comp : Code → Code → Code\n  | prec : Code → Code → Code\n  | rfind' : Code → Code\n\n"}
{"name":"Nat.Partrec.Code.left.sizeOf_spec","module":"Mathlib.Computability.PartrecCode","initialProofState":"⊢ Eq (SizeOf.sizeOf Nat.Partrec.Code.left) 1","decl":"/-- Code for partial recursive functions from ℕ to ℕ.\nSee `Nat.Partrec.Code.eval` for the interpretation of these constructors.\n-/\ninductive Code : Type\n  | zero : Code\n  | succ : Code\n  | left : Code\n  | right : Code\n  | pair : Code → Code → Code\n  | comp : Code → Code → Code\n  | prec : Code → Code → Code\n  | rfind' : Code → Code\n\n"}
{"name":"Nat.Partrec.Code.zero.sizeOf_spec","module":"Mathlib.Computability.PartrecCode","initialProofState":"⊢ Eq (SizeOf.sizeOf Nat.Partrec.Code.zero) 1","decl":"/-- Code for partial recursive functions from ℕ to ℕ.\nSee `Nat.Partrec.Code.eval` for the interpretation of these constructors.\n-/\ninductive Code : Type\n  | zero : Code\n  | succ : Code\n  | left : Code\n  | right : Code\n  | pair : Code → Code → Code\n  | comp : Code → Code → Code\n  | prec : Code → Code → Code\n  | rfind' : Code → Code\n\n"}
{"name":"Nat.Partrec.Code.rfind'.sizeOf_spec","module":"Mathlib.Computability.PartrecCode","initialProofState":"a✝ : Nat.Partrec.Code\n⊢ Eq (SizeOf.sizeOf a✝.rfind') (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- Code for partial recursive functions from ℕ to ℕ.\nSee `Nat.Partrec.Code.eval` for the interpretation of these constructors.\n-/\ninductive Code : Type\n  | zero : Code\n  | succ : Code\n  | left : Code\n  | right : Code\n  | pair : Code → Code → Code\n  | comp : Code → Code → Code\n  | prec : Code → Code → Code\n  | rfind' : Code → Code\n\n"}
{"name":"Nat.Partrec.Code.rfind'.injEq","module":"Mathlib.Computability.PartrecCode","initialProofState":"a✝¹ a✝ : Nat.Partrec.Code\n⊢ Eq (Eq a✝¹.rfind' a✝.rfind') (Eq a✝¹ a✝)","decl":"/-- Code for partial recursive functions from ℕ to ℕ.\nSee `Nat.Partrec.Code.eval` for the interpretation of these constructors.\n-/\ninductive Code : Type\n  | zero : Code\n  | succ : Code\n  | left : Code\n  | right : Code\n  | pair : Code → Code → Code\n  | comp : Code → Code → Code\n  | prec : Code → Code → Code\n  | rfind' : Code → Code\n\n"}
{"name":"Nat.Partrec.Code.right.sizeOf_spec","module":"Mathlib.Computability.PartrecCode","initialProofState":"⊢ Eq (SizeOf.sizeOf Nat.Partrec.Code.right) 1","decl":"/-- Code for partial recursive functions from ℕ to ℕ.\nSee `Nat.Partrec.Code.eval` for the interpretation of these constructors.\n-/\ninductive Code : Type\n  | zero : Code\n  | succ : Code\n  | left : Code\n  | right : Code\n  | pair : Code → Code → Code\n  | comp : Code → Code → Code\n  | prec : Code → Code → Code\n  | rfind' : Code → Code\n\n"}
{"name":"Nat.Partrec.Code.const_inj","module":"Mathlib.Computability.PartrecCode","initialProofState":"n₁ n₂ : Nat\na✝ : Eq (Nat.Partrec.Code.const n₁) (Nat.Partrec.Code.const n₂)\n⊢ Eq n₁ n₂","decl":"theorem const_inj : ∀ {n₁ n₂}, Nat.Partrec.Code.const n₁ = Nat.Partrec.Code.const n₂ → n₁ = n₂\n  | 0, 0, _ => by simp\n  | n₁ + 1, n₂ + 1, h => by\n    dsimp [Nat.Partrec.Code.const] at h\n    injection h with h₁ h₂\n    simp only [const_inj h₂]\n\n"}
{"name":"Nat.Partrec.Code.encodeCode_eq","module":"Mathlib.Computability.PartrecCode","initialProofState":"⊢ Eq Encodable.encode Nat.Partrec.Code.encodeCode","decl":"theorem encodeCode_eq : encode = encodeCode :=\n  rfl\n\n"}
{"name":"Nat.Partrec.Code.ofNatCode_eq","module":"Mathlib.Computability.PartrecCode","initialProofState":"⊢ Eq (Denumerable.ofNat Nat.Partrec.Code) Nat.Partrec.Code.ofNatCode","decl":"theorem ofNatCode_eq : ofNat Code = ofNatCode :=\n  rfl\n\n"}
{"name":"Nat.Partrec.Code.encode_lt_pair","module":"Mathlib.Computability.PartrecCode","initialProofState":"cf cg : Nat.Partrec.Code\n⊢ And (LT.lt (Encodable.encode cf) (Encodable.encode (cf.pair cg))) (LT.lt (Encodable.encode cg) (Encodable.encode (cf.pair cg)))","decl":"theorem encode_lt_pair (cf cg) :\n    encode cf < encode (pair cf cg) ∧ encode cg < encode (pair cf cg) := by\n  simp only [encodeCode_eq, encodeCode]\n  have := Nat.mul_le_mul_right (Nat.pair cf.encodeCode cg.encodeCode) (by decide : 1 ≤ 2 * 2)\n  rw [one_mul, mul_assoc] at this\n  have := lt_of_le_of_lt this (lt_add_of_pos_right _ (by decide : 0 < 4))\n  exact ⟨lt_of_le_of_lt (Nat.left_le_pair _ _) this, lt_of_le_of_lt (Nat.right_le_pair _ _) this⟩\n\n"}
{"name":"Nat.Partrec.Code.encode_lt_comp","module":"Mathlib.Computability.PartrecCode","initialProofState":"cf cg : Nat.Partrec.Code\n⊢ And (LT.lt (Encodable.encode cf) (Encodable.encode (cf.comp cg))) (LT.lt (Encodable.encode cg) (Encodable.encode (cf.comp cg)))","decl":"theorem encode_lt_comp (cf cg) :\n    encode cf < encode (comp cf cg) ∧ encode cg < encode (comp cf cg) := by\n  have : encode (pair cf cg) < encode (comp cf cg) := by simp [encodeCode_eq, encodeCode]\n  exact (encode_lt_pair cf cg).imp (fun h => lt_trans h this) fun h => lt_trans h this\n\n"}
{"name":"Nat.Partrec.Code.encode_lt_prec","module":"Mathlib.Computability.PartrecCode","initialProofState":"cf cg : Nat.Partrec.Code\n⊢ And (LT.lt (Encodable.encode cf) (Encodable.encode (cf.prec cg))) (LT.lt (Encodable.encode cg) (Encodable.encode (cf.prec cg)))","decl":"theorem encode_lt_prec (cf cg) :\n    encode cf < encode (prec cf cg) ∧ encode cg < encode (prec cf cg) := by\n  have : encode (pair cf cg) < encode (prec cf cg) := by simp [encodeCode_eq, encodeCode]\n  exact (encode_lt_pair cf cg).imp (fun h => lt_trans h this) fun h => lt_trans h this\n\n"}
{"name":"Nat.Partrec.Code.encode_lt_rfind'","module":"Mathlib.Computability.PartrecCode","initialProofState":"cf : Nat.Partrec.Code\n⊢ LT.lt (Encodable.encode cf) (Encodable.encode cf.rfind')","decl":"theorem encode_lt_rfind' (cf) : encode cf < encode (rfind' cf) := by\n  simp only [encodeCode_eq, encodeCode]\n  omega\n\n"}
{"name":"Nat.Partrec.Code.pair_prim","module":"Mathlib.Computability.PartrecCode","initialProofState":"⊢ Primrec₂ Nat.Partrec.Code.pair","decl":"theorem pair_prim : Primrec₂ pair :=\n  Primrec₂.ofNat_iff.2 <|\n    Primrec₂.encode_iff.1 <|\n      nat_add.comp\n        (nat_double.comp <|\n          nat_double.comp <|\n            Primrec₂.natPair.comp (encode_iff.2 <| (Primrec.ofNat Code).comp fst)\n              (encode_iff.2 <| (Primrec.ofNat Code).comp snd))\n        (Primrec₂.const 4)\n\n"}
{"name":"Nat.Partrec.Code.comp_prim","module":"Mathlib.Computability.PartrecCode","initialProofState":"⊢ Primrec₂ Nat.Partrec.Code.comp","decl":"theorem comp_prim : Primrec₂ comp :=\n  Primrec₂.ofNat_iff.2 <|\n    Primrec₂.encode_iff.1 <|\n      nat_add.comp\n        (nat_double.comp <|\n          nat_double_succ.comp <|\n            Primrec₂.natPair.comp (encode_iff.2 <| (Primrec.ofNat Code).comp fst)\n              (encode_iff.2 <| (Primrec.ofNat Code).comp snd))\n        (Primrec₂.const 4)\n\n"}
{"name":"Nat.Partrec.Code.prec_prim","module":"Mathlib.Computability.PartrecCode","initialProofState":"⊢ Primrec₂ Nat.Partrec.Code.prec","decl":"theorem prec_prim : Primrec₂ prec :=\n  Primrec₂.ofNat_iff.2 <|\n    Primrec₂.encode_iff.1 <|\n      nat_add.comp\n        (nat_double_succ.comp <|\n          nat_double.comp <|\n            Primrec₂.natPair.comp (encode_iff.2 <| (Primrec.ofNat Code).comp fst)\n              (encode_iff.2 <| (Primrec.ofNat Code).comp snd))\n        (Primrec₂.const 4)\n\n"}
{"name":"Nat.Partrec.Code.rfind_prim","module":"Mathlib.Computability.PartrecCode","initialProofState":"⊢ Primrec Nat.Partrec.Code.rfind'","decl":"theorem rfind_prim : Primrec rfind' :=\n  ofNat_iff.2 <|\n    encode_iff.1 <|\n      nat_add.comp\n        (nat_double_succ.comp <| nat_double_succ.comp <|\n          encode_iff.2 <| Primrec.ofNat Code)\n        (const 4)\n\n"}
{"name":"Nat.Partrec.Code.rec_prim'","module":"Mathlib.Computability.PartrecCode","initialProofState":"α : Type u_1\nσ : Type u_2\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nc : α → Nat.Partrec.Code\nhc : Primrec c\nz : α → σ\nhz : Primrec z\ns : α → σ\nhs : Primrec s\nl : α → σ\nhl : Primrec l\nr : α → σ\nhr : Primrec r\npr : α → Prod Nat.Partrec.Code (Prod Nat.Partrec.Code (Prod σ σ)) → σ\nhpr : Primrec₂ pr\nco : α → Prod Nat.Partrec.Code (Prod Nat.Partrec.Code (Prod σ σ)) → σ\nhco : Primrec₂ co\npc : α → Prod Nat.Partrec.Code (Prod Nat.Partrec.Code (Prod σ σ)) → σ\nhpc : Primrec₂ pc\nrf : α → Prod Nat.Partrec.Code σ → σ\nhrf : Primrec₂ rf\n⊢ let PR := fun a cf cg hf hg => pr a { fst := cf, snd := { fst := cg, snd := { fst := hf, snd := hg } } };\n  let CO := fun a cf cg hf hg => co a { fst := cf, snd := { fst := cg, snd := { fst := hf, snd := hg } } };\n  let PC := fun a cf cg hf hg => pc a { fst := cf, snd := { fst := cg, snd := { fst := hf, snd := hg } } };\n  let RF := fun a cf hf => rf a { fst := cf, snd := hf };\n  let F := fun a c => Nat.Partrec.Code.recOn c (z a) (s a) (l a) (r a) (PR a) (CO a) (PC a) (RF a);\n  Primrec fun a => F a (c a)","decl":"theorem rec_prim' {α σ} [Primcodable α] [Primcodable σ] {c : α → Code} (hc : Primrec c) {z : α → σ}\n    (hz : Primrec z) {s : α → σ} (hs : Primrec s) {l : α → σ} (hl : Primrec l) {r : α → σ}\n    (hr : Primrec r) {pr : α → Code × Code × σ × σ → σ} (hpr : Primrec₂ pr)\n    {co : α → Code × Code × σ × σ → σ} (hco : Primrec₂ co) {pc : α → Code × Code × σ × σ → σ}\n    (hpc : Primrec₂ pc) {rf : α → Code × σ → σ} (hrf : Primrec₂ rf) :\n    let PR (a) cf cg hf hg := pr a (cf, cg, hf, hg)\n    let CO (a) cf cg hf hg := co a (cf, cg, hf, hg)\n    let PC (a) cf cg hf hg := pc a (cf, cg, hf, hg)\n    let RF (a) cf hf := rf a (cf, hf)\n    let F (a : α) (c : Code) : σ :=\n      Nat.Partrec.Code.recOn c (z a) (s a) (l a) (r a) (PR a) (CO a) (PC a) (RF a)\n    Primrec (fun a => F a (c a) : α → σ) := by\n  intros _ _ _ _ F\n  let G₁ : (α × List σ) × ℕ × ℕ → Option σ := fun p =>\n    letI a := p.1.1; letI IH := p.1.2; letI n := p.2.1; letI m := p.2.2\n    (IH.get? m).bind fun s =>\n    (IH.get? m.unpair.1).bind fun s₁ =>\n    (IH.get? m.unpair.2).map fun s₂ =>\n    cond n.bodd\n      (cond n.div2.bodd (rf a (ofNat Code m, s))\n        (pc a (ofNat Code m.unpair.1, ofNat Code m.unpair.2, s₁, s₂)))\n      (cond n.div2.bodd (co a (ofNat Code m.unpair.1, ofNat Code m.unpair.2, s₁, s₂))\n        (pr a (ofNat Code m.unpair.1, ofNat Code m.unpair.2, s₁, s₂)))\n  have : Primrec G₁ :=\n    option_bind (list_get?.comp (snd.comp fst) (snd.comp snd)) <| .mk <|\n    option_bind ((list_get?.comp (snd.comp fst)\n      (fst.comp <| Primrec.unpair.comp (snd.comp snd))).comp fst) <| .mk <|\n    option_map ((list_get?.comp (snd.comp fst)\n      (snd.comp <| Primrec.unpair.comp (snd.comp snd))).comp <| fst.comp fst) <| .mk <|\n    have a := fst.comp (fst.comp <| fst.comp <| fst.comp fst)\n    have n := fst.comp (snd.comp <| fst.comp <| fst.comp fst)\n    have m := snd.comp (snd.comp <| fst.comp <| fst.comp fst)\n    have m₁ := fst.comp (Primrec.unpair.comp m)\n    have m₂ := snd.comp (Primrec.unpair.comp m)\n    have s := snd.comp (fst.comp fst)\n    have s₁ := snd.comp fst\n    have s₂ := snd\n    (nat_bodd.comp n).cond\n      ((nat_bodd.comp <| nat_div2.comp n).cond\n        (hrf.comp a (((Primrec.ofNat Code).comp m).pair s))\n        (hpc.comp a (((Primrec.ofNat Code).comp m₁).pair <|\n          ((Primrec.ofNat Code).comp m₂).pair <| s₁.pair s₂)))\n      (Primrec.cond (nat_bodd.comp <| nat_div2.comp n)\n        (hco.comp a (((Primrec.ofNat Code).comp m₁).pair <|\n          ((Primrec.ofNat Code).comp m₂).pair <| s₁.pair s₂))\n        (hpr.comp a (((Primrec.ofNat Code).comp m₁).pair <|\n          ((Primrec.ofNat Code).comp m₂).pair <| s₁.pair s₂)))\n  let G : α → List σ → Option σ := fun a IH =>\n    IH.length.casesOn (some (z a)) fun n =>\n    n.casesOn (some (s a)) fun n =>\n    n.casesOn (some (l a)) fun n =>\n    n.casesOn (some (r a)) fun n =>\n    G₁ ((a, IH), n, n.div2.div2)\n  have : Primrec₂ G := .mk <|\n    nat_casesOn (list_length.comp snd) (option_some_iff.2 (hz.comp fst)) <| .mk <|\n    nat_casesOn snd (option_some_iff.2 (hs.comp (fst.comp fst))) <| .mk <|\n    nat_casesOn snd (option_some_iff.2 (hl.comp (fst.comp <| fst.comp fst))) <| .mk <|\n    nat_casesOn snd (option_some_iff.2 (hr.comp (fst.comp <| fst.comp <| fst.comp fst))) <| .mk <|\n    this.comp <|\n      ((fst.pair snd).comp <| fst.comp <| fst.comp <| fst.comp <| fst).pair <|\n      snd.pair <| nat_div2.comp <| nat_div2.comp snd\n  refine (nat_strong_rec (fun a n => F a (ofNat Code n)) this.to₂ fun a n => ?_)\n    |>.comp .id (encode_iff.2 hc) |>.of_eq fun a => by simp\n  iterate 4 cases' n with n; · simp [ofNatCode_eq, ofNatCode]; rfl\n  simp only [G]; rw [List.length_map, List.length_range]\n  let m := n.div2.div2\n  show G₁ ((a, (List.range (n + 4)).map fun n => F a (ofNat Code n)), n, m)\n    = some (F a (ofNat Code (n + 4)))\n  have hm : m < n + 4 := by\n    simp only [m, div2_val]\n    exact lt_of_le_of_lt\n      (le_trans (Nat.div_le_self ..) (Nat.div_le_self ..))\n      (Nat.succ_le_succ (Nat.le_add_right ..))\n  have m1 : m.unpair.1 < n + 4 := lt_of_le_of_lt m.unpair_left_le hm\n  have m2 : m.unpair.2 < n + 4 := lt_of_le_of_lt m.unpair_right_le hm\n  simp [G₁, m, List.getElem?_map, List.getElem?_range, hm, m1, m2]\n  rw [show ofNat Code (n + 4) = ofNatCode (n + 4) from rfl]\n  simp [ofNatCode]\n  cases n.bodd <;> cases n.div2.bodd <;> rfl\n\n"}
{"name":"Nat.Partrec.Code.rec_prim","module":"Mathlib.Computability.PartrecCode","initialProofState":"α : Type u_1\nσ : Type u_2\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nc : α → Nat.Partrec.Code\nhc : Primrec c\nz : α → σ\nhz : Primrec z\ns : α → σ\nhs : Primrec s\nl : α → σ\nhl : Primrec l\nr : α → σ\nhr : Primrec r\npr : α → Nat.Partrec.Code → Nat.Partrec.Code → σ → σ → σ\nhpr : Primrec fun a => pr a.1 a.2.1 a.2.2.1 a.2.2.2.1 a.2.2.2.2\nco : α → Nat.Partrec.Code → Nat.Partrec.Code → σ → σ → σ\nhco : Primrec fun a => co a.1 a.2.1 a.2.2.1 a.2.2.2.1 a.2.2.2.2\npc : α → Nat.Partrec.Code → Nat.Partrec.Code → σ → σ → σ\nhpc : Primrec fun a => pc a.1 a.2.1 a.2.2.1 a.2.2.2.1 a.2.2.2.2\nrf : α → Nat.Partrec.Code → σ → σ\nhrf : Primrec fun a => rf a.1 a.2.1 a.2.2\n⊢ let F := fun a c => Nat.Partrec.Code.recOn c (z a) (s a) (l a) (r a) (pr a) (co a) (pc a) (rf a);\n  Primrec fun a => F a (c a)","decl":"/-- Recursion on `Nat.Partrec.Code` is primitive recursive. -/\ntheorem rec_prim {α σ} [Primcodable α] [Primcodable σ] {c : α → Code} (hc : Primrec c) {z : α → σ}\n    (hz : Primrec z) {s : α → σ} (hs : Primrec s) {l : α → σ} (hl : Primrec l) {r : α → σ}\n    (hr : Primrec r) {pr : α → Code → Code → σ → σ → σ}\n    (hpr : Primrec fun a : α × Code × Code × σ × σ => pr a.1 a.2.1 a.2.2.1 a.2.2.2.1 a.2.2.2.2)\n    {co : α → Code → Code → σ → σ → σ}\n    (hco : Primrec fun a : α × Code × Code × σ × σ => co a.1 a.2.1 a.2.2.1 a.2.2.2.1 a.2.2.2.2)\n    {pc : α → Code → Code → σ → σ → σ}\n    (hpc : Primrec fun a : α × Code × Code × σ × σ => pc a.1 a.2.1 a.2.2.1 a.2.2.2.1 a.2.2.2.2)\n    {rf : α → Code → σ → σ} (hrf : Primrec fun a : α × Code × σ => rf a.1 a.2.1 a.2.2) :\n    let F (a : α) (c : Code) : σ :=\n      Nat.Partrec.Code.recOn c (z a) (s a) (l a) (r a) (pr a) (co a) (pc a) (rf a)\n    Primrec fun a => F a (c a) :=\n  rec_prim' hc hz hs hl hr\n    (pr := fun a b => pr a b.1 b.2.1 b.2.2.1 b.2.2.2) (.mk hpr)\n    (co := fun a b => co a b.1 b.2.1 b.2.2.1 b.2.2.2) (.mk hco)\n    (pc := fun a b => pc a b.1 b.2.1 b.2.2.1 b.2.2.2) (.mk hpc)\n    (rf := fun a b => rf a b.1 b.2) (.mk hrf)\n\n"}
{"name":"Nat.Partrec.Code.rec_computable","module":"Mathlib.Computability.PartrecCode","initialProofState":"α : Type u_1\nσ : Type u_2\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nc : α → Nat.Partrec.Code\nhc : Computable c\nz : α → σ\nhz : Computable z\ns : α → σ\nhs : Computable s\nl : α → σ\nhl : Computable l\nr : α → σ\nhr : Computable r\npr : α → Prod Nat.Partrec.Code (Prod Nat.Partrec.Code (Prod σ σ)) → σ\nhpr : Computable₂ pr\nco : α → Prod Nat.Partrec.Code (Prod Nat.Partrec.Code (Prod σ σ)) → σ\nhco : Computable₂ co\npc : α → Prod Nat.Partrec.Code (Prod Nat.Partrec.Code (Prod σ σ)) → σ\nhpc : Computable₂ pc\nrf : α → Prod Nat.Partrec.Code σ → σ\nhrf : Computable₂ rf\n⊢ let PR := fun a cf cg hf hg => pr a { fst := cf, snd := { fst := cg, snd := { fst := hf, snd := hg } } };\n  let CO := fun a cf cg hf hg => co a { fst := cf, snd := { fst := cg, snd := { fst := hf, snd := hg } } };\n  let PC := fun a cf cg hf hg => pc a { fst := cf, snd := { fst := cg, snd := { fst := hf, snd := hg } } };\n  let RF := fun a cf hf => rf a { fst := cf, snd := hf };\n  let F := fun a c => Nat.Partrec.Code.recOn c (z a) (s a) (l a) (r a) (PR a) (CO a) (PC a) (RF a);\n  Computable fun a => F a (c a)","decl":"/-- Recursion on `Nat.Partrec.Code` is computable. -/\ntheorem rec_computable {α σ} [Primcodable α] [Primcodable σ] {c : α → Code} (hc : Computable c)\n    {z : α → σ} (hz : Computable z) {s : α → σ} (hs : Computable s) {l : α → σ} (hl : Computable l)\n    {r : α → σ} (hr : Computable r) {pr : α → Code × Code × σ × σ → σ} (hpr : Computable₂ pr)\n    {co : α → Code × Code × σ × σ → σ} (hco : Computable₂ co) {pc : α → Code × Code × σ × σ → σ}\n    (hpc : Computable₂ pc) {rf : α → Code × σ → σ} (hrf : Computable₂ rf) :\n    let PR (a) cf cg hf hg := pr a (cf, cg, hf, hg)\n    let CO (a) cf cg hf hg := co a (cf, cg, hf, hg)\n    let PC (a) cf cg hf hg := pc a (cf, cg, hf, hg)\n    let RF (a) cf hf := rf a (cf, hf)\n    let F (a : α) (c : Code) : σ :=\n      Nat.Partrec.Code.recOn c (z a) (s a) (l a) (r a) (PR a) (CO a) (PC a) (RF a)\n    Computable fun a => F a (c a) := by\n  -- TODO(Mario): less copy-paste from previous proof\n  intros _ _ _ _ F\n  let G₁ : (α × List σ) × ℕ × ℕ → Option σ := fun p =>\n    letI a := p.1.1; letI IH := p.1.2; letI n := p.2.1; letI m := p.2.2\n    (IH.get? m).bind fun s =>\n    (IH.get? m.unpair.1).bind fun s₁ =>\n    (IH.get? m.unpair.2).map fun s₂ =>\n    cond n.bodd\n      (cond n.div2.bodd (rf a (ofNat Code m, s))\n        (pc a (ofNat Code m.unpair.1, ofNat Code m.unpair.2, s₁, s₂)))\n      (cond n.div2.bodd (co a (ofNat Code m.unpair.1, ofNat Code m.unpair.2, s₁, s₂))\n        (pr a (ofNat Code m.unpair.1, ofNat Code m.unpair.2, s₁, s₂)))\n  have : Computable G₁ := by\n    refine option_bind (list_get?.comp (snd.comp fst) (snd.comp snd)) <| .mk ?_\n    refine option_bind ((list_get?.comp (snd.comp fst)\n      (fst.comp <| Computable.unpair.comp (snd.comp snd))).comp fst) <| .mk ?_\n    refine option_map ((list_get?.comp (snd.comp fst)\n      (snd.comp <| Computable.unpair.comp (snd.comp snd))).comp <| fst.comp fst) <| .mk ?_\n    exact\n      have a := fst.comp (fst.comp <| fst.comp <| fst.comp fst)\n      have n := fst.comp (snd.comp <| fst.comp <| fst.comp fst)\n      have m := snd.comp (snd.comp <| fst.comp <| fst.comp fst)\n      have m₁ := fst.comp (Computable.unpair.comp m)\n      have m₂ := snd.comp (Computable.unpair.comp m)\n      have s := snd.comp (fst.comp fst)\n      have s₁ := snd.comp fst\n      have s₂ := snd\n      (nat_bodd.comp n).cond\n        ((nat_bodd.comp <| nat_div2.comp n).cond\n          (hrf.comp a (((Computable.ofNat Code).comp m).pair s))\n          (hpc.comp a (((Computable.ofNat Code).comp m₁).pair <|\n            ((Computable.ofNat Code).comp m₂).pair <| s₁.pair s₂)))\n        (Computable.cond (nat_bodd.comp <| nat_div2.comp n)\n          (hco.comp a (((Computable.ofNat Code).comp m₁).pair <|\n            ((Computable.ofNat Code).comp m₂).pair <| s₁.pair s₂))\n          (hpr.comp a (((Computable.ofNat Code).comp m₁).pair <|\n            ((Computable.ofNat Code).comp m₂).pair <| s₁.pair s₂)))\n  let G : α → List σ → Option σ := fun a IH =>\n    IH.length.casesOn (some (z a)) fun n =>\n    n.casesOn (some (s a)) fun n =>\n    n.casesOn (some (l a)) fun n =>\n    n.casesOn (some (r a)) fun n =>\n    G₁ ((a, IH), n, n.div2.div2)\n  have : Computable₂ G := .mk <|\n    nat_casesOn (list_length.comp snd) (option_some_iff.2 (hz.comp fst)) <| .mk <|\n    nat_casesOn snd (option_some_iff.2 (hs.comp (fst.comp fst))) <| .mk <|\n    nat_casesOn snd (option_some_iff.2 (hl.comp (fst.comp <| fst.comp fst))) <| .mk <|\n    nat_casesOn snd (option_some_iff.2 (hr.comp (fst.comp <| fst.comp <| fst.comp fst))) <| .mk <|\n    this.comp <|\n      ((fst.pair snd).comp <| fst.comp <| fst.comp <| fst.comp <| fst).pair <|\n      snd.pair <| nat_div2.comp <| nat_div2.comp snd\n  refine (nat_strong_rec (fun a n => F a (ofNat Code n)) this.to₂ fun a n => ?_)\n    |>.comp .id (encode_iff.2 hc) |>.of_eq fun a => by simp\n  iterate 4 cases' n with n; · simp [ofNatCode_eq, ofNatCode]; rfl\n  simp only [G]; rw [List.length_map, List.length_range]\n  let m := n.div2.div2\n  show G₁ ((a, (List.range (n + 4)).map fun n => F a (ofNat Code n)), n, m)\n    = some (F a (ofNat Code (n + 4)))\n  have hm : m < n + 4 := by\n    simp only [m, div2_val]\n    exact lt_of_le_of_lt\n      (le_trans (Nat.div_le_self ..) (Nat.div_le_self ..))\n      (Nat.succ_le_succ (Nat.le_add_right ..))\n  have m1 : m.unpair.1 < n + 4 := lt_of_le_of_lt m.unpair_left_le hm\n  have m2 : m.unpair.2 < n + 4 := lt_of_le_of_lt m.unpair_right_le hm\n  simp [G₁, m, List.getElem?_map, List.getElem?_range, hm, m1, m2]\n  rw [show ofNat Code (n + 4) = ofNatCode (n + 4) from rfl]\n  simp [ofNatCode]\n  cases n.bodd <;> cases n.div2.bodd <;> rfl\n\n"}
{"name":"Nat.Partrec.Code.eval_prec_zero","module":"Mathlib.Computability.PartrecCode","initialProofState":"cf cg : Nat.Partrec.Code\na : Nat\n⊢ Eq ((cf.prec cg).eval (Nat.pair a 0)) (cf.eval a)","decl":"/-- Helper lemma for the evaluation of `prec` in the base case. -/\n@[simp]\ntheorem eval_prec_zero (cf cg : Code) (a : ℕ) : eval (prec cf cg) (Nat.pair a 0) = eval cf a := by\n  rw [eval, Nat.unpaired, Nat.unpair_pair]\n  simp (config := { Lean.Meta.Simp.neutralConfig with proj := true }) only []\n  rw [Nat.rec_zero]\n\n"}
{"name":"Nat.Partrec.Code.eval_prec_succ","module":"Mathlib.Computability.PartrecCode","initialProofState":"cf cg : Nat.Partrec.Code\na k : Nat\n⊢ Eq ((cf.prec cg).eval (Nat.pair a k.succ)) (Bind.bind ((cf.prec cg).eval (Nat.pair a k)) fun ih => cg.eval (Nat.pair a (Nat.pair k ih)))","decl":"/-- Helper lemma for the evaluation of `prec` in the recursive case. -/\ntheorem eval_prec_succ (cf cg : Code) (a k : ℕ) :\n    eval (prec cf cg) (Nat.pair a (Nat.succ k)) =\n      do {let ih ← eval (prec cf cg) (Nat.pair a k); eval cg (Nat.pair a (Nat.pair k ih))} := by\n  rw [eval, Nat.unpaired, Part.bind_eq_bind, Nat.unpair_pair]\n  simp\n\n"}
{"name":"Nat.Partrec.Code.eval_const","module":"Mathlib.Computability.PartrecCode","initialProofState":"n m : Nat\n⊢ Eq ((Nat.Partrec.Code.const n).eval m) (Part.some n)","decl":"@[simp]\ntheorem eval_const : ∀ n m, eval (Code.const n) m = Part.some n\n  | 0, _ => rfl\n  | n + 1, m => by simp! [eval_const n m]\n\n"}
{"name":"Nat.Partrec.Code.eval_id","module":"Mathlib.Computability.PartrecCode","initialProofState":"n : Nat\n⊢ Eq (Nat.Partrec.Code.id.eval n) (Part.some n)","decl":"@[simp]\ntheorem eval_id (n) : eval Code.id n = Part.some n := by simp! [Seq.seq, Code.id]\n\n"}
{"name":"Nat.Partrec.Code.eval_curry","module":"Mathlib.Computability.PartrecCode","initialProofState":"c : Nat.Partrec.Code\nn x : Nat\n⊢ Eq ((c.curry n).eval x) (c.eval (Nat.pair n x))","decl":"@[simp]\ntheorem eval_curry (c n x) : eval (curry c n) x = eval c (Nat.pair n x) := by simp! [Seq.seq, curry]\n\n"}
{"name":"Nat.Partrec.Code.const_prim","module":"Mathlib.Computability.PartrecCode","initialProofState":"⊢ Primrec Nat.Partrec.Code.const","decl":"theorem const_prim : Primrec Code.const :=\n  (_root_.Primrec.id.nat_iterate (_root_.Primrec.const zero)\n    (comp_prim.comp (_root_.Primrec.const succ) Primrec.snd).to₂).of_eq\n    fun n => by simp; induction n <;>\n      simp [*, Code.const, Function.iterate_succ', -Function.iterate_succ]\n\n"}
{"name":"Nat.Partrec.Code.curry_prim","module":"Mathlib.Computability.PartrecCode","initialProofState":"⊢ Primrec₂ Nat.Partrec.Code.curry","decl":"theorem curry_prim : Primrec₂ curry :=\n  comp_prim.comp Primrec.fst <| pair_prim.comp (const_prim.comp Primrec.snd)\n    (_root_.Primrec.const Code.id)\n\n"}
{"name":"Nat.Partrec.Code.curry_inj","module":"Mathlib.Computability.PartrecCode","initialProofState":"c₁ c₂ : Nat.Partrec.Code\nn₁ n₂ : Nat\nh : Eq (c₁.curry n₁) (c₂.curry n₂)\n⊢ And (Eq c₁ c₂) (Eq n₁ n₂)","decl":"theorem curry_inj {c₁ c₂ n₁ n₂} (h : curry c₁ n₁ = curry c₂ n₂) : c₁ = c₂ ∧ n₁ = n₂ :=\n  ⟨by injection h, by\n    injection h with h₁ h₂\n    injection h₂ with h₃ h₄\n    exact const_inj h₃⟩\n\n"}
{"name":"Nat.Partrec.Code.smn","module":"Mathlib.Computability.PartrecCode","initialProofState":"⊢ Exists fun f => And (Computable₂ f) (∀ (c : Nat.Partrec.Code) (n x : Nat), Eq ((f c n).eval x) (c.eval (Nat.pair n x)))","decl":"/--\nThe $S_n^m$ theorem: There is a computable function, namely `Nat.Partrec.Code.curry`, that takes a\nprogram and a ℕ `n`, and returns a new program using `n` as the first argument.\n-/\ntheorem smn :\n    ∃ f : Code → ℕ → Code, Computable₂ f ∧ ∀ c n x, eval (f c n) x = eval c (Nat.pair n x) :=\n  ⟨curry, Primrec₂.to_comp curry_prim, eval_curry⟩\n\n"}
{"name":"Nat.Partrec.Code.exists_code","module":"Mathlib.Computability.PartrecCode","initialProofState":"f : PFun Nat Nat\n⊢ Iff (Nat.Partrec f) (Exists fun c => Eq c.eval f)","decl":"/-- A function is partial recursive if and only if there is a code implementing it. Therefore,\n`eval` is a **universal partial recursive function**. -/\ntheorem exists_code {f : ℕ →. ℕ} : Nat.Partrec f ↔ ∃ c : Code, eval c = f := by\n  refine ⟨fun h => ?_, ?_⟩\n  · induction h with\n    | zero => exact ⟨zero, rfl⟩\n    | succ => exact ⟨succ, rfl⟩\n    | left => exact ⟨left, rfl⟩\n    | right => exact ⟨right, rfl⟩\n    | pair pf pg hf hg =>\n      rcases hf with ⟨cf, rfl⟩; rcases hg with ⟨cg, rfl⟩\n      exact ⟨pair cf cg, rfl⟩\n    | comp pf pg hf hg =>\n      rcases hf with ⟨cf, rfl⟩; rcases hg with ⟨cg, rfl⟩\n      exact ⟨comp cf cg, rfl⟩\n    | prec pf pg hf hg =>\n      rcases hf with ⟨cf, rfl⟩; rcases hg with ⟨cg, rfl⟩\n      exact ⟨prec cf cg, rfl⟩\n    | rfind pf hf =>\n      rcases hf with ⟨cf, rfl⟩\n      refine ⟨comp (rfind' cf) (pair Code.id zero), ?_⟩\n      simp [eval, Seq.seq, pure, PFun.pure, Part.map_id']\n  · rintro ⟨c, rfl⟩\n    induction c with\n    | zero => exact Nat.Partrec.zero\n    | succ => exact Nat.Partrec.succ\n    | left => exact Nat.Partrec.left\n    | right => exact Nat.Partrec.right\n    | pair cf cg pf pg => exact pf.pair pg\n    | comp cf cg pf pg => exact pf.comp pg\n    | prec cf cg pf pg => exact pf.prec pg\n    | rfind' cf pf => exact pf.rfind'\n\n"}
{"name":"Nat.Partrec.Code.evaln_bound","module":"Mathlib.Computability.PartrecCode","initialProofState":"k : Nat\nc : Nat.Partrec.Code\nn x : Nat\na✝ : Membership.mem (Nat.Partrec.Code.evaln k c n) x\n⊢ LT.lt n k","decl":"theorem evaln_bound : ∀ {k c n x}, x ∈ evaln k c n → n < k\n  | 0, c, n, x, h => by simp [evaln] at h\n  | k + 1, c, n, x, h => by\n    suffices ∀ {o : Option ℕ}, x ∈ do { guard (n ≤ k); o } → n < k + 1 by\n      cases c <;> rw [evaln] at h <;> exact this h\n    simpa [Option.bind_eq_some] using Nat.lt_succ_of_le\n\n"}
{"name":"Nat.Partrec.Code.evaln_mono","module":"Mathlib.Computability.PartrecCode","initialProofState":"k₁ k₂ : Nat\nc : Nat.Partrec.Code\nn x : Nat\na✝¹ : LE.le k₁ k₂\na✝ : Membership.mem (Nat.Partrec.Code.evaln k₁ c n) x\n⊢ Membership.mem (Nat.Partrec.Code.evaln k₂ c n) x","decl":"theorem evaln_mono : ∀ {k₁ k₂ c n x}, k₁ ≤ k₂ → x ∈ evaln k₁ c n → x ∈ evaln k₂ c n\n  | 0, k₂, c, n, x, _, h => by simp [evaln] at h\n  | k + 1, k₂ + 1, c, n, x, hl, h => by\n    have hl' := Nat.le_of_succ_le_succ hl\n    have :\n      ∀ {k k₂ n x : ℕ} {o₁ o₂ : Option ℕ},\n        k ≤ k₂ → (x ∈ o₁ → x ∈ o₂) →\n          x ∈ do { guard (n ≤ k); o₁ } → x ∈ do { guard (n ≤ k₂); o₂ } := by\n      simp only [Option.mem_def, bind, Option.bind_eq_some, Option.guard_eq_some', exists_and_left,\n        exists_const, and_imp]\n      introv h h₁ h₂ h₃\n      exact ⟨le_trans h₂ h, h₁ h₃⟩\n    simp? at h ⊢ says simp only [Option.mem_def] at h ⊢\n    induction' c with cf cg hf hg cf cg hf hg cf cg hf hg cf hf generalizing x n <;>\n      rw [evaln] at h ⊢ <;> refine this hl' (fun h => ?_) h\n    iterate 4 exact h\n    · -- pair cf cg\n      simp? [Seq.seq, Option.bind_eq_some] at h ⊢ says\n        simp only [Seq.seq, Option.map_eq_map, Option.mem_def, Option.bind_eq_some,\n          Option.map_eq_some', exists_exists_and_eq_and] at h ⊢\n      exact h.imp fun a => And.imp (hf _ _) <| Exists.imp fun b => And.imp_left (hg _ _)\n    · -- comp cf cg\n      simp? [Bind.bind, Option.bind_eq_some] at h ⊢ says\n        simp only [bind, Option.mem_def, Option.bind_eq_some] at h ⊢\n      exact h.imp fun a => And.imp (hg _ _) (hf _ _)\n    · -- prec cf cg\n      revert h\n      simp only [unpaired, bind, Option.mem_def]\n      induction n.unpair.2 <;> simp [Option.bind_eq_some]\n      · apply hf\n      · exact fun y h₁ h₂ => ⟨y, evaln_mono hl' h₁, hg _ _ h₂⟩\n    · -- rfind' cf\n      simp? [Bind.bind, Option.bind_eq_some] at h ⊢ says\n        simp only [unpaired, bind, pair_unpair, Option.pure_def, Option.mem_def,\n          Option.bind_eq_some] at h ⊢\n      refine h.imp fun x => And.imp (hf _ _) ?_\n      by_cases x0 : x = 0 <;> simp [x0]\n      exact evaln_mono hl'\n\n"}
{"name":"Nat.Partrec.Code.evaln_sound","module":"Mathlib.Computability.PartrecCode","initialProofState":"k : Nat\nc : Nat.Partrec.Code\nn x : Nat\na✝ : Membership.mem (Nat.Partrec.Code.evaln k c n) x\n⊢ Membership.mem (c.eval n) x","decl":"theorem evaln_sound : ∀ {k c n x}, x ∈ evaln k c n → x ∈ eval c n\n  | 0, _, n, x, h => by simp [evaln] at h\n  | k + 1, c, n, x, h => by\n    induction' c with cf cg hf hg cf cg hf hg cf cg hf hg cf hf generalizing x n <;>\n        simp [eval, evaln, Option.bind_eq_some, Seq.seq] at h ⊢ <;>\n      cases' h with _ h\n    iterate 4 simpa [pure, PFun.pure, eq_comm] using h\n    · -- pair cf cg\n      rcases h with ⟨y, ef, z, eg, rfl⟩\n      exact ⟨_, hf _ _ ef, _, hg _ _ eg, rfl⟩\n    · --comp hf hg\n      rcases h with ⟨y, eg, ef⟩\n      exact ⟨_, hg _ _ eg, hf _ _ ef⟩\n    · -- prec cf cg\n      revert h\n      induction' n.unpair.2 with m IH generalizing x <;> simp [Option.bind_eq_some]\n      · apply hf\n      · refine fun y h₁ h₂ => ⟨y, IH _ ?_, ?_⟩\n        · have := evaln_mono k.le_succ h₁\n          simp [evaln, Option.bind_eq_some] at this\n          exact this.2\n        · exact hg _ _ h₂\n    · -- rfind' cf\n      rcases h with ⟨m, h₁, h₂⟩\n      by_cases m0 : m = 0 <;> simp [m0] at h₂\n      · exact\n          ⟨0, ⟨by simpa [m0] using hf _ _ h₁, fun {m} => (Nat.not_lt_zero _).elim⟩, by simp [h₂]⟩\n      · have := evaln_sound h₂\n        simp [eval] at this\n        rcases this with ⟨y, ⟨hy₁, hy₂⟩, rfl⟩\n        refine\n          ⟨y + 1, ⟨by simpa [add_comm, add_left_comm] using hy₁, fun {i} im => ?_⟩, by\n            simp [add_comm, add_left_comm]⟩\n        cases' i with i\n        · exact ⟨m, by simpa using hf _ _ h₁, m0⟩\n        · rcases hy₂ (Nat.lt_of_succ_lt_succ im) with ⟨z, hz, z0⟩\n          exact ⟨z, by simpa [add_comm, add_left_comm] using hz, z0⟩\n\n"}
{"name":"Nat.Partrec.Code.evaln_complete","module":"Mathlib.Computability.PartrecCode","initialProofState":"c : Nat.Partrec.Code\nn x : Nat\n⊢ Iff (Membership.mem (c.eval n) x) (Exists fun k => Membership.mem (Nat.Partrec.Code.evaln k c n) x)","decl":"theorem evaln_complete {c n x} : x ∈ eval c n ↔ ∃ k, x ∈ evaln k c n := by\n  refine ⟨fun h => ?_, fun ⟨k, h⟩ => evaln_sound h⟩\n  rsuffices ⟨k, h⟩ : ∃ k, x ∈ evaln (k + 1) c n\n  · exact ⟨k + 1, h⟩\n  induction c generalizing n x with\n      simp [eval, evaln, pure, PFun.pure, Seq.seq, Option.bind_eq_some] at h ⊢\n  | pair cf cg hf hg =>\n    rcases h with ⟨x, hx, y, hy, rfl⟩\n    rcases hf hx with ⟨k₁, hk₁⟩; rcases hg hy with ⟨k₂, hk₂⟩\n    refine ⟨max k₁ k₂, ?_⟩\n    refine\n      ⟨le_max_of_le_left <| Nat.le_of_lt_succ <| evaln_bound hk₁, _,\n        evaln_mono (Nat.succ_le_succ <| le_max_left _ _) hk₁, _,\n        evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hk₂, rfl⟩\n  | comp cf cg hf hg =>\n    rcases h with ⟨y, hy, hx⟩\n    rcases hg hy with ⟨k₁, hk₁⟩; rcases hf hx with ⟨k₂, hk₂⟩\n    refine ⟨max k₁ k₂, ?_⟩\n    exact\n      ⟨le_max_of_le_left <| Nat.le_of_lt_succ <| evaln_bound hk₁, _,\n        evaln_mono (Nat.succ_le_succ <| le_max_left _ _) hk₁,\n        evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hk₂⟩\n  | prec cf cg hf hg =>\n    revert h\n    generalize n.unpair.1 = n₁; generalize n.unpair.2 = n₂\n    induction' n₂ with m IH generalizing x n <;> simp [Option.bind_eq_some]\n    · intro h\n      rcases hf h with ⟨k, hk⟩\n      exact ⟨_, le_max_left _ _, evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hk⟩\n    · intro y hy hx\n      rcases IH hy with ⟨k₁, nk₁, hk₁⟩\n      rcases hg hx with ⟨k₂, hk₂⟩\n      refine\n        ⟨(max k₁ k₂).succ,\n          Nat.le_succ_of_le <| le_max_of_le_left <|\n            le_trans (le_max_left _ (Nat.pair n₁ m)) nk₁, y,\n          evaln_mono (Nat.succ_le_succ <| le_max_left _ _) ?_,\n          evaln_mono (Nat.succ_le_succ <| Nat.le_succ_of_le <| le_max_right _ _) hk₂⟩\n      simp only [evaln.eq_8, bind, unpaired, unpair_pair, Option.mem_def, Option.bind_eq_some,\n        Option.guard_eq_some', exists_and_left, exists_const]\n      exact ⟨le_trans (le_max_right _ _) nk₁, hk₁⟩\n  | rfind' cf hf =>\n    rcases h with ⟨y, ⟨hy₁, hy₂⟩, rfl⟩\n    suffices ∃ k, y + n.unpair.2 ∈ evaln (k + 1) (rfind' cf) (Nat.pair n.unpair.1 n.unpair.2) by\n      simpa [evaln, Option.bind_eq_some]\n    revert hy₁ hy₂\n    generalize n.unpair.2 = m\n    intro hy₁ hy₂\n    induction' y with y IH generalizing m <;> simp [evaln, Option.bind_eq_some]\n    · simp at hy₁\n      rcases hf hy₁ with ⟨k, hk⟩\n      exact ⟨_, Nat.le_of_lt_succ <| evaln_bound hk, _, hk, by simp⟩\n    · rcases hy₂ (Nat.succ_pos _) with ⟨a, ha, a0⟩\n      rcases hf ha with ⟨k₁, hk₁⟩\n      rcases IH m.succ (by simpa [Nat.succ_eq_add_one, add_comm, add_left_comm] using hy₁)\n          fun {i} hi => by\n          simpa [Nat.succ_eq_add_one, add_comm, add_left_comm] using\n            hy₂ (Nat.succ_lt_succ hi) with\n        ⟨k₂, hk₂⟩\n      use (max k₁ k₂).succ\n      rw [zero_add] at hk₁\n      use Nat.le_succ_of_le <| le_max_of_le_left <| Nat.le_of_lt_succ <| evaln_bound hk₁\n      use a\n      use evaln_mono (Nat.succ_le_succ <| Nat.le_succ_of_le <| le_max_left _ _) hk₁\n      simpa [a0, add_comm, add_left_comm] using\n        evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hk₂\n  | _ => exact ⟨⟨_, le_rfl⟩, h.symm⟩\n\n"}
{"name":"Nat.Partrec.Code.evaln_prim","module":"Mathlib.Computability.PartrecCode","initialProofState":"⊢ Primrec fun a => Nat.Partrec.Code.evaln a.1.1 a.1.2 a.2","decl":"/-- The `Nat.Partrec.Code.evaln` function is primitive recursive. -/\ntheorem evaln_prim : Primrec fun a : (ℕ × Code) × ℕ => evaln a.1.1 a.1.2 a.2 :=\n  have :\n    Primrec₂ fun (_ : Unit) (n : ℕ) =>\n      let a := ofNat (ℕ × Code) n\n      (List.range a.1).map (evaln a.1 a.2) :=\n    Primrec.nat_strong_rec _ (hG.comp Primrec.snd).to₂ fun _ p => by\n      simp only [G, prod_ofNat_val, ofNat_nat, List.length_map, List.length_range,\n        Nat.pair_unpair, Option.some_inj]\n      refine List.map_congr_left fun n => ?_\n      have : List.range p = List.range (Nat.pair p.unpair.1 (encode (ofNat Code p.unpair.2))) := by\n        simp\n      rw [this]\n      generalize p.unpair.1 = k\n      generalize ofNat Code p.unpair.2 = c\n      intro nk\n      cases' k with k'\n      · simp [evaln]\n      let k := k' + 1\n      simp only [show k'.succ = k from rfl]\n      simp? [Nat.lt_succ_iff] at nk says simp only [List.mem_range, Nat.lt_succ_iff] at nk\n      have hg :\n        ∀ {k' c' n},\n          Nat.pair k' (encode c') < Nat.pair k (encode c) →\n            lup ((List.range (Nat.pair k (encode c))).map fun n =>\n              (List.range n.unpair.1).map (evaln n.unpair.1 (ofNat Code n.unpair.2))) (k', c') n =\n            evaln k' c' n := by\n        intro k₁ c₁ n₁ hl\n        simp [lup, List.getElem?_range hl, evaln_map, Bind.bind, Option.bind_map]\n      cases' c with cf cg cf cg cf cg cf <;>\n        simp [evaln, nk, Bind.bind, Functor.map, Seq.seq, pure]\n      · cases' encode_lt_pair cf cg with lf lg\n        rw [hg (Nat.pair_lt_pair_right _ lf), hg (Nat.pair_lt_pair_right _ lg)]\n        cases evaln k cf n\n        · rfl\n        cases evaln k cg n <;> rfl\n      · cases' encode_lt_comp cf cg with lf lg\n        rw [hg (Nat.pair_lt_pair_right _ lg)]\n        cases evaln k cg n\n        · rfl\n        simp [k, hg (Nat.pair_lt_pair_right _ lf)]\n      · cases' encode_lt_prec cf cg with lf lg\n        rw [hg (Nat.pair_lt_pair_right _ lf)]\n        cases n.unpair.2\n        · rfl\n        simp only [decode_eq_ofNat, Option.some.injEq]\n        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]\n        cases evaln k' _ _\n        · rfl\n        simp [k, hg (Nat.pair_lt_pair_right _ lg)]\n      · have lf := encode_lt_rfind' cf\n        rw [hg (Nat.pair_lt_pair_right _ lf)]\n        cases' evaln k cf n with x\n        · rfl\n        simp only [decode_eq_ofNat, Option.some.injEq, Option.some_bind]\n        cases x <;> simp [Nat.succ_ne_zero]\n        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]\n  (Primrec.option_bind\n    (Primrec.list_get?.comp (this.comp (_root_.Primrec.const ())\n      (Primrec.encode_iff.2 Primrec.fst)) Primrec.snd) Primrec.snd.to₂).of_eq\n    fun ⟨⟨k, c⟩, n⟩ => by simp [evaln_map, Option.bind_map]\n\n"}
{"name":"Nat.Partrec.Code.eval_eq_rfindOpt","module":"Mathlib.Computability.PartrecCode","initialProofState":"c : Nat.Partrec.Code\nn : Nat\n⊢ Eq (c.eval n) (Nat.rfindOpt fun k => Nat.Partrec.Code.evaln k c n)","decl":"theorem eval_eq_rfindOpt (c n) : eval c n = Nat.rfindOpt fun k => evaln k c n :=\n  Part.ext fun x => by\n    refine evaln_complete.trans (Nat.rfindOpt_mono ?_).symm\n    intro a m n hl; apply evaln_mono hl\n\n"}
{"name":"Nat.Partrec.Code.eval_part","module":"Mathlib.Computability.PartrecCode","initialProofState":"⊢ Partrec₂ Nat.Partrec.Code.eval","decl":"theorem eval_part : Partrec₂ eval :=\n  (Partrec.rfindOpt\n    (evaln_prim.to_comp.comp ((Computable.snd.pair (fst.comp fst)).pair (snd.comp fst))).to₂).of_eq\n    fun a => by simp [eval_eq_rfindOpt]\n\n"}
{"name":"Nat.Partrec.Code.fixed_point","module":"Mathlib.Computability.PartrecCode","initialProofState":"f : Nat.Partrec.Code → Nat.Partrec.Code\nhf : Computable f\n⊢ Exists fun c => Eq (f c).eval c.eval","decl":"/-- **Roger's fixed-point theorem**: any total, computable `f` has a fixed point.\nThat is, under the interpretation given by `Nat.Partrec.Code.eval`, there is a code `c`\nsuch that `c` and `f c` have the same evaluation.\n-/\ntheorem fixed_point {f : Code → Code} (hf : Computable f) : ∃ c : Code, eval (f c) = eval c :=\n  let g (x y : ℕ) : Part ℕ := eval (ofNat Code x) x >>= fun b => eval (ofNat Code b) y\n  have : Partrec₂ g :=\n    (eval_part.comp ((Computable.ofNat _).comp fst) fst).bind\n      (eval_part.comp ((Computable.ofNat _).comp snd) (snd.comp fst)).to₂\n  let ⟨cg, eg⟩ := exists_code.1 this\n  have eg' : ∀ a n, eval cg (Nat.pair a n) = Part.map encode (g a n) := by simp [eg]\n  let F (x : ℕ) : Code := f (curry cg x)\n  have : Computable F :=\n    hf.comp (curry_prim.comp (_root_.Primrec.const cg) _root_.Primrec.id).to_comp\n  let ⟨cF, eF⟩ := exists_code.1 this\n  have eF' : eval cF (encode cF) = Part.some (encode (F (encode cF))) := by simp [eF]\n  ⟨curry cg (encode cF),\n    funext fun n =>\n      show eval (f (curry cg (encode cF))) n = eval (curry cg (encode cF)) n by\n        simp [F, g, eg', eF', Part.map_id']⟩\n\n"}
{"name":"Nat.Partrec.Code.fixed_point₂","module":"Mathlib.Computability.PartrecCode","initialProofState":"f : Nat.Partrec.Code → PFun Nat Nat\nhf : Partrec₂ f\n⊢ Exists fun c => Eq c.eval (f c)","decl":"/-- **Kleene's second recursion theorem** -/\ntheorem fixed_point₂ {f : Code → ℕ →. ℕ} (hf : Partrec₂ f) : ∃ c : Code, eval c = f c :=\n  let ⟨cf, ef⟩ := exists_code.1 hf\n  (fixed_point (curry_prim.comp (_root_.Primrec.const cf) Primrec.encode).to_comp).imp fun c e =>\n    funext fun n => by simp [e.symm, ef, Part.map_id']\n\n"}
{"name":"Nat.Partrec.Code.instCountableSubtypePFunPartrec","module":"Mathlib.Computability.PartrecCode","initialProofState":"⊢ Countable (Subtype fun f => Partrec f)","decl":"/-- There are only countably many partial recursive partial functions `ℕ →. ℕ`. -/\ninstance : Countable {f : ℕ →. ℕ // _root_.Partrec f} := by\n  apply Function.Surjective.countable (f := fun c => ⟨eval c, eval_part.comp (.const c) .id⟩)\n  intro ⟨f, hf⟩; simpa using exists_code.1 hf\n\n"}
{"name":"Nat.Partrec.Code.instCountableSubtypeForallComputable","module":"Mathlib.Computability.PartrecCode","initialProofState":"⊢ Countable (Subtype fun f => Computable f)","decl":"/-- There are only countably many computable functions `ℕ → ℕ`. -/\ninstance : Countable {f : ℕ → ℕ // Computable f} :=\n  @Function.Injective.countable {f : ℕ → ℕ // Computable f} {f : ℕ →. ℕ // _root_.Partrec f} _\n    (fun f => ⟨f.val, f.2⟩)\n    (fun _ _ h => Subtype.val_inj.1 (PFun.lift_injective (by simpa using h)))\n\n"}
