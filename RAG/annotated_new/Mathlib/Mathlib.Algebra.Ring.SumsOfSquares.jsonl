{"name":"IsSumSq.brecOn","module":"Mathlib.Algebra.Ring.SumsOfSquares","initialProofState":"R : Type u_1\ninst✝² : Mul R\ninst✝¹ : Add R\ninst✝ : Zero R\nmotive✝ : (a : R) → IsSumSq a → Prop\na✝ : R\nx✝ : IsSumSq a✝\nih✝ : ∀ (a : R) (x : IsSumSq a), x.below → motive✝ a x\n⊢ motive✝ a✝ x✝","decl":"/--\nThe property of being a sum of squares is defined inductively by:\n`0 : R` is a sum of squares and if `s : R` is a sum of squares,\nthen for all `a : R`, `a * a + s` is a sum of squares in `R`.\n-/\n@[mk_iff]\ninductive IsSumSq [Mul R] [Add R] [Zero R] : R → Prop\n  | zero                                    : IsSumSq 0\n  | sq_add (a : R) {s : R} (hs : IsSumSq s) : IsSumSq (a * a + s)\n\n"}
{"name":"isSumSq_iff","module":"Mathlib.Algebra.Ring.SumsOfSquares","initialProofState":"R : Type u_1\ninst✝² : Mul R\ninst✝¹ : Add R\ninst✝ : Zero R\na✝ : R\n⊢ Iff (IsSumSq a✝) (Or (Eq a✝ 0) (Exists fun a => Exists fun s => And (IsSumSq s) (Eq a✝ (HAdd.hAdd (HMul.hMul a a) s))))","decl":"/--\nThe property of being a sum of squares is defined inductively by:\n`0 : R` is a sum of squares and if `s : R` is a sum of squares,\nthen for all `a : R`, `a * a + s` is a sum of squares in `R`.\n-/\n@[mk_iff]\ninductive IsSumSq [Mul R] [Add R] [Zero R] : R → Prop\n  | zero                                    : IsSumSq 0\n  | sq_add (a : R) {s : R} (hs : IsSumSq s) : IsSumSq (a * a + s)\n\n"}
{"name":"IsSumSq.rec'","module":"Mathlib.Algebra.Ring.SumsOfSquares","initialProofState":"R : Type u_1\ninst✝² : Mul R\ninst✝¹ : Add R\ninst✝ : Zero R\nmotive : (s : R) → IsSumSq s → Prop\nzero : motive 0 ⋯\nsq_add : ∀ {x s : R}, IsSquare x → ∀ (hs : IsSumSq s), motive s hs → motive (HAdd.hAdd x s) ⋯\ns : R\nh : IsSumSq s\n⊢ motive s h","decl":"/-- Alternative induction scheme for `IsSumSq` which uses `IsSquare`. -/\ntheorem IsSumSq.rec' [Mul R] [Add R] [Zero R]\n    {motive : (s : R) → (h : IsSumSq s) → Prop}\n    (zero : motive 0 zero)\n    (sq_add : ∀ {x s}, (hx : IsSquare x) → (hs : IsSumSq s) → motive s hs →\n      motive (x + s) (by rcases hx with ⟨_, rfl⟩; exact sq_add _ hs))\n    {s : R} (h : IsSumSq s) : motive s h :=\n  match h with\n  | .zero        => zero\n  | .sq_add _ hs => sq_add (.mul_self _) hs (rec' zero sq_add _)\n\n"}
{"name":"IsSumSq.add","module":"Mathlib.Algebra.Ring.SumsOfSquares","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoid R\ninst✝ : Mul R\ns₁ s₂ : R\nh₁ : IsSumSq s₁\nh₂ : IsSumSq s₂\n⊢ IsSumSq (HAdd.hAdd s₁ s₂)","decl":"/--\nIn an additive monoid with multiplication,\nif `s₁` and `s₂` are sums of squares, then `s₁ + s₂` is a sum of squares.\n-/\ntheorem IsSumSq.add [AddMonoid R] [Mul R] {s₁ s₂ : R}\n    (h₁ : IsSumSq s₁) (h₂ : IsSumSq s₂) : IsSumSq (s₁ + s₂) := by\n  induction h₁ <;> simp_all [add_assoc, sq_add]\n\n"}
{"name":"isSumSq.add","module":"Mathlib.Algebra.Ring.SumsOfSquares","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoid R\ninst✝ : Mul R\ns₁ s₂ : R\nh₁ : IsSumSq s₁\nh₂ : IsSumSq s₂\n⊢ IsSumSq (HAdd.hAdd s₁ s₂)","decl":"@[deprecated (since := \"2024-08-09\")] alias isSumSq.add := IsSumSq.add\n\n"}
{"name":"AddSubmonoid.coe_sumSq","module":"Mathlib.Algebra.Ring.SumsOfSquares","initialProofState":"T : Type u_2\ninst✝¹ : Mul T\ninst✝ : AddMonoid T\n⊢ Eq (↑(AddSubmonoid.sumSq T)) (setOf fun s => IsSumSq s)","decl":"variable (T) in\n/--\nIn an additive monoid with multiplication `R`, `AddSubmonoid.sumSq R` is the submonoid of sums of\nsquares in `R`.\n-/\n@[simps]\ndef sumSq [AddMonoid T] : AddSubmonoid T where\n  carrier   := {s : T | IsSumSq s}\n  zero_mem' := .zero\n  add_mem'  := .add\n\n"}
{"name":"AddSubmonoid.mem_sumSq","module":"Mathlib.Algebra.Ring.SumsOfSquares","initialProofState":"T : Type u_2\ninst✝¹ : AddMonoid T\ninst✝ : Mul T\ns : T\n⊢ Iff (Membership.mem (AddSubmonoid.sumSq T) s) (IsSumSq s)","decl":"@[simp] theorem mem_sumSq : s ∈ sumSq T ↔ IsSumSq s := Iff.rfl\n\n"}
{"name":"IsSumSq.mul_self","module":"Mathlib.Algebra.Ring.SumsOfSquares","initialProofState":"R : Type u_1\ninst✝¹ : AddZeroClass R\ninst✝ : Mul R\na : R\n⊢ IsSumSq (HMul.hMul a a)","decl":"/-- In an additive unital magma with multiplication, `x * x` is a sum of squares for all `x`. -/\n@[simp] theorem IsSumSq.mul_self [AddZeroClass R] [Mul R] (a : R) : IsSumSq (a * a) := by\n  simpa using sq_add a zero\n\n"}
{"name":"IsSquare.isSumSq","module":"Mathlib.Algebra.Ring.SumsOfSquares","initialProofState":"R : Type u_1\ninst✝¹ : AddZeroClass R\ninst✝ : Mul R\nx : R\nhx : IsSquare x\n⊢ IsSumSq x","decl":"/--\nIn an additive unital magma with multiplication, squares are sums of squares\n(see Mathlib.Algebra.Group.Even).\n-/\ntheorem IsSquare.isSumSq [AddZeroClass R] [Mul R] {x : R} (hx : IsSquare x) :\n    IsSumSq x := by rcases hx with ⟨_, rfl⟩; apply IsSumSq.mul_self\n\n"}
{"name":"AddSubmonoid.closure_isSquare","module":"Mathlib.Algebra.Ring.SumsOfSquares","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoid R\ninst✝ : Mul R\n⊢ Eq (AddSubmonoid.closure (setOf fun x => IsSquare x)) (AddSubmonoid.sumSq R)","decl":"/--\nIn an additive monoid with multiplication `R`, the submonoid generated by the squares is the set of\nsums of squares in `R`.\n-/\n@[simp]\ntheorem AddSubmonoid.closure_isSquare [AddMonoid R] [Mul R] :\n    closure {x : R | IsSquare x} = sumSq R := by\n  refine closure_eq_of_le (fun x hx ↦ IsSquare.isSumSq hx) (fun x hx ↦ ?_)\n  induction hx with\n  | zero => apply zero_mem\n  | sq_add a hs ih => exact add_mem (subset_closure (IsSquare.mul_self a)) ih\n\n"}
{"name":"SquaresAddClosure","module":"Mathlib.Algebra.Ring.SumsOfSquares","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoid R\ninst✝ : Mul R\n⊢ Eq (AddSubmonoid.closure (setOf fun x => IsSquare x)) (AddSubmonoid.sumSq R)","decl":"@[deprecated (since := \"2024-08-09\")] alias SquaresAddClosure := AddSubmonoid.closure_isSquare\n\n"}
{"name":"IsSumSq.sum","module":"Mathlib.Algebra.Ring.SumsOfSquares","initialProofState":"R : Type u_1\ninst✝¹ : AddCommMonoid R\ninst✝ : Mul R\nι : Type u_2\nI : Finset ι\ns : ι → R\nhs : ∀ (i : ι), Membership.mem I i → IsSumSq (s i)\n⊢ IsSumSq (I.sum fun i => s i)","decl":"/--\nIn an additive commutative monoid with multiplication, a finite sum of sums of squares\nis a sum of squares.\n-/\ntheorem IsSumSq.sum [AddCommMonoid R] [Mul R] {ι : Type*} {I : Finset ι} {s : ι → R}\n    (hs : ∀ i ∈ I, IsSumSq <| s i) : IsSumSq (∑ i ∈ I, s i) := by\n  simpa using sum_mem (S := AddSubmonoid.sumSq _) hs\n\n"}
{"name":"IsSumSq.sum_isSquare","module":"Mathlib.Algebra.Ring.SumsOfSquares","initialProofState":"R : Type u_1\ninst✝¹ : AddCommMonoid R\ninst✝ : Mul R\nι : Type u_2\nI : Finset ι\nx : ι → R\nhx : ∀ (i : ι), Membership.mem I i → IsSquare (x i)\n⊢ IsSumSq (I.sum fun i => x i)","decl":"/--\nIn an additive commutative monoid with multiplication,\n`∑ i ∈ I, x i`, where each `x i` is a square, is a sum of squares.\n-/\ntheorem IsSumSq.sum_isSquare [AddCommMonoid R] [Mul R] {ι : Type*} (I : Finset ι) {x : ι → R}\n    (hx : ∀ i ∈ I, IsSquare <| x i) : IsSumSq (∑ i ∈ I, x i) :=\n  .sum fun _ hi => IsSquare.isSumSq (hx _ hi)\n\n"}
{"name":"IsSumSq.sum_mul_self","module":"Mathlib.Algebra.Ring.SumsOfSquares","initialProofState":"R : Type u_1\ninst✝¹ : AddCommMonoid R\ninst✝ : Mul R\nι : Type u_2\nI : Finset ι\na : ι → R\n⊢ IsSumSq (I.sum fun i => HMul.hMul (a i) (a i))","decl":"/--\nIn an additive commutative monoid with multiplication,\n`∑ i ∈ I, a i * a i` is a sum of squares.\n-/\n@[simp]\ntheorem IsSumSq.sum_mul_self [AddCommMonoid R] [Mul R] {ι : Type*} (I : Finset ι) (a : ι → R) :\n    IsSumSq (∑ i ∈ I, a i * a i) := .sum fun _ _ => .mul_self _\n\n"}
{"name":"isSumSq_sum_mul_self","module":"Mathlib.Algebra.Ring.SumsOfSquares","initialProofState":"R : Type u_1\ninst✝¹ : AddCommMonoid R\ninst✝ : Mul R\nι : Type u_2\nI : Finset ι\na : ι → R\n⊢ IsSumSq (I.sum fun i => HMul.hMul (a i) (a i))","decl":"@[deprecated (since := \"2024-12-27\")] alias isSumSq_sum_mul_self := IsSumSq.sum_mul_self\n\n"}
{"name":"NonUnitalSubsemiring.sumSq_toAddSubmonoid","module":"Mathlib.Algebra.Ring.SumsOfSquares","initialProofState":"T : Type u_2\ninst✝ : NonUnitalCommSemiring T\n⊢ Eq (NonUnitalSubsemiring.sumSq T).toAddSubmonoid (AddSubmonoid.sumSq T)","decl":"@[simp] theorem sumSq_toAddSubmonoid : (sumSq T).toAddSubmonoid = .sumSq T := by\n  simp [sumSq, ← AddSubmonoid.closure_isSquare,\n    Subsemigroup.nonUnitalSubsemiringClosure_toAddSubmonoid]\n\n"}
{"name":"NonUnitalSubsemiring.mem_sumSq","module":"Mathlib.Algebra.Ring.SumsOfSquares","initialProofState":"T : Type u_2\ninst✝ : NonUnitalCommSemiring T\ns : T\n⊢ Iff (Membership.mem (NonUnitalSubsemiring.sumSq T) s) (IsSumSq s)","decl":"@[simp]\ntheorem mem_sumSq {s : T} : s ∈ sumSq T ↔ IsSumSq s := by\n  simp [← NonUnitalSubsemiring.mem_toAddSubmonoid]\n\n"}
{"name":"NonUnitalSubsemiring.coe_sumSq","module":"Mathlib.Algebra.Ring.SumsOfSquares","initialProofState":"T : Type u_2\ninst✝ : NonUnitalCommSemiring T\n⊢ Eq (↑(NonUnitalSubsemiring.sumSq T)) (setOf fun s => IsSumSq s)","decl":"@[simp, norm_cast] theorem coe_sumSq : sumSq T = {s : T | IsSumSq s} := by ext; simp\n\n"}
{"name":"NonUnitalSubsemiring.closure_isSquare","module":"Mathlib.Algebra.Ring.SumsOfSquares","initialProofState":"T : Type u_2\ninst✝ : NonUnitalCommSemiring T\n⊢ Eq (NonUnitalSubsemiring.closure (setOf fun x => IsSquare x)) (NonUnitalSubsemiring.sumSq T)","decl":"@[simp] theorem closure_isSquare : closure {x : T | IsSquare x} = sumSq T := by\n  simp [sumSq, Subsemigroup.nonUnitalSubsemiringClosure_eq_closure]\n\n"}
{"name":"IsSumSq.mul","module":"Mathlib.Algebra.Ring.SumsOfSquares","initialProofState":"R : Type u_1\ninst✝ : NonUnitalCommSemiring R\ns₁ s₂ : R\nh₁ : IsSumSq s₁\nh₂ : IsSumSq s₂\n⊢ IsSumSq (HMul.hMul s₁ s₂)","decl":"/--\nIn a commutative (possibly non-unital) semiring,\nif `s₁` and `s₂` are sums of squares, then `s₁ * s₂` is a sum of squares.\n-/\ntheorem IsSumSq.mul [NonUnitalCommSemiring R] {s₁ s₂ : R}\n    (h₁ : IsSumSq s₁) (h₂ : IsSumSq s₂) : IsSumSq (s₁ * s₂) := by\n  simpa using mul_mem (by simpa : _ ∈ NonUnitalSubsemiring.sumSq R) (by simpa)\n\n"}
{"name":"Subsemiring.sumSq_toNonUnitalSubsemiring","module":"Mathlib.Algebra.Ring.SumsOfSquares","initialProofState":"T : Type u_2\ninst✝ : CommSemiring T\n⊢ Eq (Subsemiring.sumSq T).toNonUnitalSubsemiring (NonUnitalSubsemiring.sumSq T)","decl":"@[simp] theorem sumSq_toNonUnitalSubsemiring :\n    (sumSq T).toNonUnitalSubsemiring = .sumSq T := rfl\n\n"}
{"name":"Subsemiring.mem_sumSq","module":"Mathlib.Algebra.Ring.SumsOfSquares","initialProofState":"T : Type u_2\ninst✝ : CommSemiring T\ns : T\n⊢ Iff (Membership.mem (Subsemiring.sumSq T) s) (IsSumSq s)","decl":"@[simp]\ntheorem mem_sumSq {s : T} : s ∈ sumSq T ↔ IsSumSq s := by\n  simp [← Subsemiring.mem_toNonUnitalSubsemiring]\n\n"}
{"name":"Subsemiring.coe_sumSq","module":"Mathlib.Algebra.Ring.SumsOfSquares","initialProofState":"T : Type u_2\ninst✝ : CommSemiring T\n⊢ Eq (↑(Subsemiring.sumSq T)) (setOf fun s => IsSumSq s)","decl":"@[simp, norm_cast] theorem coe_sumSq : sumSq T = {s : T | IsSumSq s} := by ext; simp\n\n"}
{"name":"Subsemiring.closure_isSquare","module":"Mathlib.Algebra.Ring.SumsOfSquares","initialProofState":"T : Type u_2\ninst✝ : CommSemiring T\n⊢ Eq (Subsemiring.closure (setOf fun x => IsSquare x)) (Subsemiring.sumSq T)","decl":"@[simp] theorem closure_isSquare : closure {x : T | IsSquare x} = sumSq T := by\n  apply_fun toNonUnitalSubsemiring using toNonUnitalSubsemiring_injective\n  simp [← Submonoid.square_subsemiringClosure]\n\n"}
{"name":"IsSumSq.prod","module":"Mathlib.Algebra.Ring.SumsOfSquares","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nι : Type u_2\nI : Finset ι\nx : ι → R\nhx : ∀ (i : ι), Membership.mem I i → IsSumSq (x i)\n⊢ IsSumSq (I.prod fun i => x i)","decl":"/-- In a commutative semiring, a finite product of sums of squares is a sum of squares. -/\ntheorem IsSumSq.prod [CommSemiring R] {ι : Type*} {I : Finset ι} {x : ι → R}\n    (hx : ∀ i ∈ I, IsSumSq <| x i) : IsSumSq (∏ i ∈ I, x i) := by\n  simpa using prod_mem (S := Subsemiring.sumSq R) (by simpa)\n\n"}
{"name":"IsSumSq.nonneg","module":"Mathlib.Algebra.Ring.SumsOfSquares","initialProofState":"R : Type u_2\ninst✝¹ : LinearOrderedSemiring R\ninst✝ : ExistsAddOfLE R\ns : R\nhs : IsSumSq s\n⊢ LE.le 0 s","decl":"/--\nIn a linearly ordered semiring with the property `a ≤ b → ∃ c, a + c = b` (e.g. `ℕ`),\nsums of squares are non-negative.\n-/\ntheorem IsSumSq.nonneg {R : Type*} [LinearOrderedSemiring R] [ExistsAddOfLE R] {s : R}\n    (hs : IsSumSq s) : 0 ≤ s := by\n  induction hs using IsSumSq.rec' with\n  | zero          => simp\n  | sq_add hx _ h => exact add_nonneg (IsSquare.nonneg hx) h\n\n"}
{"name":"isSumSq.nonneg","module":"Mathlib.Algebra.Ring.SumsOfSquares","initialProofState":"R : Type u_2\ninst✝¹ : LinearOrderedSemiring R\ninst✝ : ExistsAddOfLE R\ns : R\nhs : IsSumSq s\n⊢ LE.le 0 s","decl":"@[deprecated (since := \"2024-08-09\")] alias isSumSq.nonneg := IsSumSq.nonneg\n"}
