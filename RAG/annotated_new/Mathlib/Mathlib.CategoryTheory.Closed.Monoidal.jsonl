{"name":"CategoryTheory.ihom.ihom_adjunction_counit","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA : C\ninst✝ : CategoryTheory.Closed A\n⊢ Eq (CategoryTheory.ihom.adjunction A).counit (CategoryTheory.ihom.ev A)","decl":"@[simp]\ntheorem ihom_adjunction_counit : (ihom.adjunction A).counit = ev A :=\n  rfl\n\n"}
{"name":"CategoryTheory.ihom.ihom_adjunction_unit","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA : C\ninst✝ : CategoryTheory.Closed A\n⊢ Eq (CategoryTheory.ihom.adjunction A).unit (CategoryTheory.ihom.coev A)","decl":"@[simp]\ntheorem ihom_adjunction_unit : (ihom.adjunction A).unit = coev A :=\n  rfl\n\n"}
{"name":"CategoryTheory.ihom.ev_naturality","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA : C\ninst✝ : CategoryTheory.Closed A\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A ((CategoryTheory.ihom A).map f)) ((CategoryTheory.ihom.ev A).app Y)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ihom.ev A).app X) f)","decl":"@[reassoc (attr := simp)]\ntheorem ev_naturality {X Y : C} (f : X ⟶ Y) :\n    A ◁ (ihom A).map f ≫ (ev A).app Y = (ev A).app X ≫ f :=\n  (ev A).naturality f\n\n"}
{"name":"CategoryTheory.ihom.ev_naturality_assoc","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA : C\ninst✝ : CategoryTheory.Closed A\nX Y : C\nf : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A ((CategoryTheory.ihom A).map f)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ihom.ev A).app Y) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ihom.ev A).app X) (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc (attr := simp)]\ntheorem ev_naturality {X Y : C} (f : X ⟶ Y) :\n    A ◁ (ihom A).map f ≫ (ev A).app Y = (ev A).app X ≫ f :=\n  (ev A).naturality f\n\n"}
{"name":"CategoryTheory.ihom.coev_naturality","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA : C\ninst✝ : CategoryTheory.Closed A\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp f ((CategoryTheory.ihom.coev A).app Y)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ihom.coev A).app X) ((CategoryTheory.ihom A).map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A f)))","decl":"@[reassoc (attr := simp)]\ntheorem coev_naturality {X Y : C} (f : X ⟶ Y) :\n    f ≫ (coev A).app Y = (coev A).app X ≫ (ihom A).map (A ◁ f) :=\n  (coev A).naturality f\n\n"}
{"name":"CategoryTheory.ihom.coev_naturality_assoc","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA : C\ninst✝ : CategoryTheory.Closed A\nX Y : C\nf : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom ((CategoryTheory.ihom A).obj ((CategoryTheory.MonoidalCategory.tensorLeft A).obj Y)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ihom.coev A).app Y) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ihom.coev A).app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ihom A).map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A f)) h))","decl":"@[reassoc (attr := simp)]\ntheorem coev_naturality {X Y : C} (f : X ⟶ Y) :\n    f ≫ (coev A).app Y = (coev A).app X ≫ (ihom A).map (A ◁ f) :=\n  (coev A).naturality f\n\n"}
{"name":"CategoryTheory.ihom.ev_coev","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA B : C\ninst✝ : CategoryTheory.Closed A\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A ((CategoryTheory.ihom.coev A).app B)) ((CategoryTheory.ihom.ev A).app (CategoryTheory.MonoidalCategoryStruct.tensorObj A B))) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj A B))","decl":"@[reassoc (attr := simp)]\ntheorem ev_coev : (A ◁ (coev A).app B) ≫ (ev A).app (A ⊗ B) = 𝟙 (A ⊗ B) :=\n  (ihom.adjunction A).left_triangle_components _\n\n"}
{"name":"CategoryTheory.ihom.ev_coev_assoc","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA B : C\ninst✝ : CategoryTheory.Closed A\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A B) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A ((CategoryTheory.ihom.coev A).app B)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ihom.ev A).app (CategoryTheory.MonoidalCategoryStruct.tensorObj A B)) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem ev_coev : (A ◁ (coev A).app B) ≫ (ev A).app (A ⊗ B) = 𝟙 (A ⊗ B) :=\n  (ihom.adjunction A).left_triangle_components _\n\n"}
{"name":"CategoryTheory.ihom.coev_ev_assoc","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA B : C\ninst✝ : CategoryTheory.Closed A\nZ : C\nh : Quiver.Hom ((CategoryTheory.ihom A).obj B) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ihom.coev A).app ((CategoryTheory.ihom A).obj B)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ihom A).map ((CategoryTheory.ihom.ev A).app B)) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem coev_ev : (coev A).app (A ⟶[C] B) ≫ (ihom A).map ((ev A).app B) = 𝟙 (A ⟶[C] B) :=\n  Adjunction.right_triangle_components (ihom.adjunction A) _\n\n"}
{"name":"CategoryTheory.ihom.coev_ev","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA B : C\ninst✝ : CategoryTheory.Closed A\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ihom.coev A).app ((CategoryTheory.ihom A).obj B)) ((CategoryTheory.ihom A).map ((CategoryTheory.ihom.ev A).app B))) (CategoryTheory.CategoryStruct.id ((CategoryTheory.ihom A).obj B))","decl":"@[reassoc (attr := simp)]\ntheorem coev_ev : (coev A).app (A ⟶[C] B) ≫ (ihom A).map ((ev A).app B) = 𝟙 (A ⟶[C] B) :=\n  Adjunction.right_triangle_components (ihom.adjunction A) _\n\n"}
{"name":"CategoryTheory.instPreservesColimitsTensorLeft","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA : C\ninst✝ : CategoryTheory.Closed A\n⊢ CategoryTheory.Limits.PreservesColimits (CategoryTheory.MonoidalCategory.tensorLeft A)","decl":"instance : PreservesColimits (tensorLeft A) :=\n  (ihom.adjunction A).leftAdjoint_preservesColimits\n\n"}
{"name":"CategoryTheory.MonoidalClosed.homEquiv_apply_eq","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA X Y : C\ninst✝ : CategoryTheory.Closed A\nf : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A Y) X\n⊢ Eq (((CategoryTheory.ihom.adjunction A).homEquiv Y X) f) (CategoryTheory.MonoidalClosed.curry f)","decl":"@[simp, nolint simpNF]\ntheorem homEquiv_apply_eq (f : A ⊗ Y ⟶ X) : (ihom.adjunction A).homEquiv _ _ f = curry f :=\n  rfl\n\n-- This lemma has always been bad, but the linter only noticed after https://github.com/leanprover/lean4/pull/2644.\n"}
{"name":"CategoryTheory.MonoidalClosed.homEquiv_symm_apply_eq","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA X Y : C\ninst✝ : CategoryTheory.Closed A\nf : Quiver.Hom Y ((CategoryTheory.ihom A).obj X)\n⊢ Eq (((CategoryTheory.ihom.adjunction A).homEquiv Y X).symm f) (CategoryTheory.MonoidalClosed.uncurry f)","decl":"@[simp, nolint simpNF]\ntheorem homEquiv_symm_apply_eq (f : Y ⟶ A ⟶[C] X) :\n    ((ihom.adjunction A).homEquiv _ _).symm f = uncurry f :=\n  rfl\n\n"}
{"name":"CategoryTheory.MonoidalClosed.curry_natural_left","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA X X' Y : C\ninst✝ : CategoryTheory.Closed A\nf : Quiver.Hom X X'\ng : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A X') Y\n⊢ Eq (CategoryTheory.MonoidalClosed.curry (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A f) g)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.MonoidalClosed.curry g))","decl":"@[reassoc]\ntheorem curry_natural_left (f : X ⟶ X') (g : A ⊗ X' ⟶ Y) : curry (_ ◁ f ≫ g) = f ≫ curry g :=\n  Adjunction.homEquiv_naturality_left _ _ _\n\n"}
{"name":"CategoryTheory.MonoidalClosed.curry_natural_left_assoc","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA X X' Y : C\ninst✝ : CategoryTheory.Closed A\nf : Quiver.Hom X X'\ng : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A X') Y\nZ : C\nh : Quiver.Hom ((CategoryTheory.ihom A).obj Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalClosed.curry (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A f) g)) h) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalClosed.curry g) h))","decl":"@[reassoc]\ntheorem curry_natural_left (f : X ⟶ X') (g : A ⊗ X' ⟶ Y) : curry (_ ◁ f ≫ g) = f ≫ curry g :=\n  Adjunction.homEquiv_naturality_left _ _ _\n\n"}
{"name":"CategoryTheory.MonoidalClosed.curry_natural_right_assoc","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA X Y Y' : C\ninst✝ : CategoryTheory.Closed A\nf : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A X) Y\ng : Quiver.Hom Y Y'\nZ : C\nh : Quiver.Hom ((CategoryTheory.ihom A).obj Y') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalClosed.curry (CategoryTheory.CategoryStruct.comp f g)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalClosed.curry f) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ihom A).map g) h))","decl":"@[reassoc]\ntheorem curry_natural_right (f : A ⊗ X ⟶ Y) (g : Y ⟶ Y') :\n    curry (f ≫ g) = curry f ≫ (ihom _).map g :=\n  Adjunction.homEquiv_naturality_right _ _ _\n\n"}
{"name":"CategoryTheory.MonoidalClosed.curry_natural_right","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA X Y Y' : C\ninst✝ : CategoryTheory.Closed A\nf : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A X) Y\ng : Quiver.Hom Y Y'\n⊢ Eq (CategoryTheory.MonoidalClosed.curry (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalClosed.curry f) ((CategoryTheory.ihom A).map g))","decl":"@[reassoc]\ntheorem curry_natural_right (f : A ⊗ X ⟶ Y) (g : Y ⟶ Y') :\n    curry (f ≫ g) = curry f ≫ (ihom _).map g :=\n  Adjunction.homEquiv_naturality_right _ _ _\n\n"}
{"name":"CategoryTheory.MonoidalClosed.uncurry_natural_right_assoc","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA X Y Y' : C\ninst✝ : CategoryTheory.Closed A\nf : Quiver.Hom X ((CategoryTheory.ihom A).obj Y)\ng : Quiver.Hom Y Y'\nZ : C\nh : Quiver.Hom Y' Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalClosed.uncurry (CategoryTheory.CategoryStruct.comp f ((CategoryTheory.ihom A).map g))) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalClosed.uncurry f) (CategoryTheory.CategoryStruct.comp g h))","decl":"@[reassoc]\ntheorem uncurry_natural_right (f : X ⟶ A ⟶[C] Y) (g : Y ⟶ Y') :\n    uncurry (f ≫ (ihom _).map g) = uncurry f ≫ g :=\n  Adjunction.homEquiv_naturality_right_symm _ _ _\n\n"}
{"name":"CategoryTheory.MonoidalClosed.uncurry_natural_right","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA X Y Y' : C\ninst✝ : CategoryTheory.Closed A\nf : Quiver.Hom X ((CategoryTheory.ihom A).obj Y)\ng : Quiver.Hom Y Y'\n⊢ Eq (CategoryTheory.MonoidalClosed.uncurry (CategoryTheory.CategoryStruct.comp f ((CategoryTheory.ihom A).map g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalClosed.uncurry f) g)","decl":"@[reassoc]\ntheorem uncurry_natural_right (f : X ⟶ A ⟶[C] Y) (g : Y ⟶ Y') :\n    uncurry (f ≫ (ihom _).map g) = uncurry f ≫ g :=\n  Adjunction.homEquiv_naturality_right_symm _ _ _\n\n"}
{"name":"CategoryTheory.MonoidalClosed.uncurry_natural_left","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA X X' Y : C\ninst✝ : CategoryTheory.Closed A\nf : Quiver.Hom X X'\ng : Quiver.Hom X' ((CategoryTheory.ihom A).obj Y)\n⊢ Eq (CategoryTheory.MonoidalClosed.uncurry (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A f) (CategoryTheory.MonoidalClosed.uncurry g))","decl":"@[reassoc]\ntheorem uncurry_natural_left (f : X ⟶ X') (g : X' ⟶ A ⟶[C] Y) :\n    uncurry (f ≫ g) = _ ◁ f ≫ uncurry g :=\n  Adjunction.homEquiv_naturality_left_symm _ _ _\n\n"}
{"name":"CategoryTheory.MonoidalClosed.uncurry_natural_left_assoc","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA X X' Y : C\ninst✝ : CategoryTheory.Closed A\nf : Quiver.Hom X X'\ng : Quiver.Hom X' ((CategoryTheory.ihom A).obj Y)\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalClosed.uncurry (CategoryTheory.CategoryStruct.comp f g)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalClosed.uncurry g) h))","decl":"@[reassoc]\ntheorem uncurry_natural_left (f : X ⟶ X') (g : X' ⟶ A ⟶[C] Y) :\n    uncurry (f ≫ g) = _ ◁ f ≫ uncurry g :=\n  Adjunction.homEquiv_naturality_left_symm _ _ _\n\n"}
{"name":"CategoryTheory.MonoidalClosed.uncurry_curry","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA X Y : C\ninst✝ : CategoryTheory.Closed A\nf : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A X) Y\n⊢ Eq (CategoryTheory.MonoidalClosed.uncurry (CategoryTheory.MonoidalClosed.curry f)) f","decl":"@[simp]\ntheorem uncurry_curry (f : A ⊗ X ⟶ Y) : uncurry (curry f) = f :=\n  (Closed.adj.homEquiv _ _).left_inv f\n\n"}
{"name":"CategoryTheory.MonoidalClosed.curry_uncurry","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA X Y : C\ninst✝ : CategoryTheory.Closed A\nf : Quiver.Hom X ((CategoryTheory.ihom A).obj Y)\n⊢ Eq (CategoryTheory.MonoidalClosed.curry (CategoryTheory.MonoidalClosed.uncurry f)) f","decl":"@[simp]\ntheorem curry_uncurry (f : X ⟶ A ⟶[C] Y) : curry (uncurry f) = f :=\n  (Closed.adj.homEquiv _ _).right_inv f\n\n"}
{"name":"CategoryTheory.MonoidalClosed.curry_eq_iff","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA X Y : C\ninst✝ : CategoryTheory.Closed A\nf : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A Y) X\ng : Quiver.Hom Y ((CategoryTheory.ihom A).obj X)\n⊢ Iff (Eq (CategoryTheory.MonoidalClosed.curry f) g) (Eq f (CategoryTheory.MonoidalClosed.uncurry g))","decl":"theorem curry_eq_iff (f : A ⊗ Y ⟶ X) (g : Y ⟶ A ⟶[C] X) : curry f = g ↔ f = uncurry g :=\n  Adjunction.homEquiv_apply_eq (ihom.adjunction A) f g\n\n"}
{"name":"CategoryTheory.MonoidalClosed.eq_curry_iff","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA X Y : C\ninst✝ : CategoryTheory.Closed A\nf : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A Y) X\ng : Quiver.Hom Y ((CategoryTheory.ihom A).obj X)\n⊢ Iff (Eq g (CategoryTheory.MonoidalClosed.curry f)) (Eq (CategoryTheory.MonoidalClosed.uncurry g) f)","decl":"theorem eq_curry_iff (f : A ⊗ Y ⟶ X) (g : Y ⟶ A ⟶[C] X) : g = curry f ↔ uncurry g = f :=\n  Adjunction.eq_homEquiv_apply (ihom.adjunction A) f g\n\n-- I don't think these two should be simp.\n"}
{"name":"CategoryTheory.MonoidalClosed.uncurry_eq","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA X Y : C\ninst✝ : CategoryTheory.Closed A\ng : Quiver.Hom Y ((CategoryTheory.ihom A).obj X)\n⊢ Eq (CategoryTheory.MonoidalClosed.uncurry g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A g) ((CategoryTheory.ihom.ev A).app X))","decl":"theorem uncurry_eq (g : Y ⟶ A ⟶[C] X) : uncurry g = (A ◁ g) ≫ (ihom.ev A).app X := by\n  rfl\n\n"}
{"name":"CategoryTheory.MonoidalClosed.curry_eq","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA X Y : C\ninst✝ : CategoryTheory.Closed A\ng : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A Y) X\n⊢ Eq (CategoryTheory.MonoidalClosed.curry g) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ihom.coev A).app Y) ((CategoryTheory.ihom A).map g))","decl":"theorem curry_eq (g : A ⊗ Y ⟶ X) : curry g = (ihom.coev A).app Y ≫ (ihom A).map g :=\n  rfl\n\n"}
{"name":"CategoryTheory.MonoidalClosed.curry_injective","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA X Y : C\ninst✝ : CategoryTheory.Closed A\n⊢ Function.Injective CategoryTheory.MonoidalClosed.curry","decl":"theorem curry_injective : Function.Injective (curry : (A ⊗ Y ⟶ X) → (Y ⟶ A ⟶[C] X)) :=\n  (Closed.adj.homEquiv _ _).injective\n\n"}
{"name":"CategoryTheory.MonoidalClosed.uncurry_injective","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA X Y : C\ninst✝ : CategoryTheory.Closed A\n⊢ Function.Injective CategoryTheory.MonoidalClosed.uncurry","decl":"theorem uncurry_injective : Function.Injective (uncurry : (Y ⟶ A ⟶[C] X) → (A ⊗ Y ⟶ X)) :=\n  (Closed.adj.homEquiv _ _).symm.injective\n\n"}
{"name":"CategoryTheory.MonoidalClosed.uncurry_id_eq_ev","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA X : C\ninst✝ : CategoryTheory.Closed A\n⊢ Eq (CategoryTheory.MonoidalClosed.uncurry (CategoryTheory.CategoryStruct.id ((CategoryTheory.ihom A).obj X))) ((CategoryTheory.ihom.ev A).app X)","decl":"theorem uncurry_id_eq_ev : uncurry (𝟙 (A ⟶[C] X)) = (ihom.ev A).app X := by\n  simp [uncurry_eq]\n\n"}
{"name":"CategoryTheory.MonoidalClosed.curry_id_eq_coev","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA X : C\ninst✝ : CategoryTheory.Closed A\n⊢ Eq (CategoryTheory.MonoidalClosed.curry (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj A ((CategoryTheory.Functor.id C).obj X)))) ((CategoryTheory.ihom.coev A).app X)","decl":"theorem curry_id_eq_coev : curry (𝟙 _) = (ihom.coev A).app X := by\n  rw [curry_eq, (ihom A).map_id (A ⊗ _)]\n  apply comp_id\n\n"}
{"name":"CategoryTheory.MonoidalClosed.id_tensor_pre_app_comp_ev","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.MonoidalCategory C\nA B : C\ninst✝¹ : CategoryTheory.Closed A\ninst✝ : CategoryTheory.Closed B\nf : Quiver.Hom B A\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft B ((CategoryTheory.MonoidalClosed.pre f).app X)) ((CategoryTheory.ihom.ev B).app X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f ((CategoryTheory.ihom A).obj X)) ((CategoryTheory.ihom.ev A).app X))","decl":"@[reassoc (attr := simp)]\ntheorem id_tensor_pre_app_comp_ev (f : B ⟶ A) (X : C) :\n    B ◁ (pre f).app X ≫ (ihom.ev B).app X = f ▷ (A ⟶[C] X) ≫ (ihom.ev A).app X :=\n  conjugateEquiv_counit _ _ ((tensoringLeft C).map f) X\n\n"}
{"name":"CategoryTheory.MonoidalClosed.id_tensor_pre_app_comp_ev_assoc","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.MonoidalCategory C\nA B : C\ninst✝¹ : CategoryTheory.Closed A\ninst✝ : CategoryTheory.Closed B\nf : Quiver.Hom B A\nX Z : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft B ((CategoryTheory.MonoidalClosed.pre f).app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ihom.ev B).app X) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f ((CategoryTheory.ihom A).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ihom.ev A).app X) h))","decl":"@[reassoc (attr := simp)]\ntheorem id_tensor_pre_app_comp_ev (f : B ⟶ A) (X : C) :\n    B ◁ (pre f).app X ≫ (ihom.ev B).app X = f ▷ (A ⟶[C] X) ≫ (ihom.ev A).app X :=\n  conjugateEquiv_counit _ _ ((tensoringLeft C).map f) X\n\n"}
{"name":"CategoryTheory.MonoidalClosed.uncurry_pre","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.MonoidalCategory C\nA B : C\ninst✝¹ : CategoryTheory.Closed A\ninst✝ : CategoryTheory.Closed B\nf : Quiver.Hom B A\nX : C\n⊢ Eq (CategoryTheory.MonoidalClosed.uncurry ((CategoryTheory.MonoidalClosed.pre f).app X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f ((CategoryTheory.ihom A).obj X)) ((CategoryTheory.ihom.ev A).app X))","decl":"@[simp]\ntheorem uncurry_pre (f : B ⟶ A) (X : C) :\n    MonoidalClosed.uncurry ((pre f).app X) = f ▷ _ ≫ (ihom.ev A).app X := by\n  simp [uncurry_eq]\n\n"}
{"name":"CategoryTheory.MonoidalClosed.coev_app_comp_pre_app_assoc","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.MonoidalCategory C\nA B X : C\ninst✝¹ : CategoryTheory.Closed A\ninst✝ : CategoryTheory.Closed B\nf : Quiver.Hom B A\nZ : C\nh : Quiver.Hom ((CategoryTheory.ihom B).obj (CategoryTheory.MonoidalCategoryStruct.tensorObj A X)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ihom.coev A).app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.MonoidalClosed.pre f).app (CategoryTheory.MonoidalCategoryStruct.tensorObj A X)) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ihom.coev B).app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ihom B).map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X)) h))","decl":"@[reassoc (attr := simp)]\ntheorem coev_app_comp_pre_app (f : B ⟶ A) :\n    (ihom.coev A).app X ≫ (pre f).app (A ⊗ X) = (ihom.coev B).app X ≫ (ihom B).map (f ▷ _) :=\n  unit_conjugateEquiv _ _ ((tensoringLeft C).map f) X\n\n"}
{"name":"CategoryTheory.MonoidalClosed.coev_app_comp_pre_app","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.MonoidalCategory C\nA B X : C\ninst✝¹ : CategoryTheory.Closed A\ninst✝ : CategoryTheory.Closed B\nf : Quiver.Hom B A\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ihom.coev A).app X) ((CategoryTheory.MonoidalClosed.pre f).app (CategoryTheory.MonoidalCategoryStruct.tensorObj A X))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ihom.coev B).app X) ((CategoryTheory.ihom B).map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X)))","decl":"@[reassoc (attr := simp)]\ntheorem coev_app_comp_pre_app (f : B ⟶ A) :\n    (ihom.coev A).app X ≫ (pre f).app (A ⊗ X) = (ihom.coev B).app X ≫ (ihom B).map (f ▷ _) :=\n  unit_conjugateEquiv _ _ ((tensoringLeft C).map f) X\n\n"}
{"name":"CategoryTheory.MonoidalClosed.pre_id","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA : C\ninst✝ : CategoryTheory.Closed A\n⊢ Eq (CategoryTheory.MonoidalClosed.pre (CategoryTheory.CategoryStruct.id A)) (CategoryTheory.CategoryStruct.id (CategoryTheory.ihom A))","decl":"@[simp]\ntheorem pre_id (A : C) [Closed A] : pre (𝟙 A) = 𝟙 _ := by\n  rw [pre, Functor.map_id]\n  apply conjugateEquiv_id\n\n"}
{"name":"CategoryTheory.MonoidalClosed.pre_map","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nA₁ A₂ A₃ : C\ninst✝² : CategoryTheory.Closed A₁\ninst✝¹ : CategoryTheory.Closed A₂\ninst✝ : CategoryTheory.Closed A₃\nf : Quiver.Hom A₁ A₂\ng : Quiver.Hom A₂ A₃\n⊢ Eq (CategoryTheory.MonoidalClosed.pre (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalClosed.pre g) (CategoryTheory.MonoidalClosed.pre f))","decl":"@[simp]\ntheorem pre_map {A₁ A₂ A₃ : C} [Closed A₁] [Closed A₂] [Closed A₃] (f : A₁ ⟶ A₂) (g : A₂ ⟶ A₃) :\n    pre (f ≫ g) = pre g ≫ pre f := by\n  rw [pre, pre, pre, conjugateEquiv_comp, (tensoringLeft C).map_comp]\n\n"}
{"name":"CategoryTheory.MonoidalClosed.pre_comm_ihom_map","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.MonoidalCategory C\nW X Y Z : C\ninst✝¹ : CategoryTheory.Closed W\ninst✝ : CategoryTheory.Closed X\nf : Quiver.Hom W X\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.MonoidalClosed.pre f).app Y) ((CategoryTheory.ihom W).map g)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ihom X).map g) ((CategoryTheory.MonoidalClosed.pre f).app Z))","decl":"theorem pre_comm_ihom_map {W X Y Z : C} [Closed W] [Closed X] (f : W ⟶ X) (g : Y ⟶ Z) :\n    (pre f).app Y ≫ (ihom W).map g = (ihom X).map g ≫ (pre f).app Z := by simp\n\n"}
{"name":"CategoryTheory.MonoidalClosed.internalHom_map","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.MonoidalClosed C\nX✝ Y✝ : Opposite C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.MonoidalClosed.internalHom.map f) (CategoryTheory.MonoidalClosed.pre f.unop)","decl":"/-- The internal hom functor given by the monoidal closed structure. -/\n@[simps]\ndef internalHom [MonoidalClosed C] : Cᵒᵖ ⥤ C ⥤ C where\n  obj X := ihom X.unop\n  map f := pre f.unop\n\n"}
{"name":"CategoryTheory.MonoidalClosed.internalHom_obj","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.MonoidalClosed C\nX : Opposite C\n⊢ Eq (CategoryTheory.MonoidalClosed.internalHom.obj X) (CategoryTheory.ihom (Opposite.unop X))","decl":"/-- The internal hom functor given by the monoidal closed structure. -/\n@[simps]\ndef internalHom [MonoidalClosed C] : Cᵒᵖ ⥤ C ⥤ C where\n  obj X := ihom X.unop\n  map f := pre f.unop\n\n"}
{"name":"CategoryTheory.MonoidalClosed.ofEquiv_curry_def","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\ninst✝⁵ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝² : F.Monoidal\ninst✝¹ : F.IsEquivalence\ninst✝ : CategoryTheory.MonoidalClosed D\nX Y Z : C\nf : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z\n⊢ Eq (CategoryTheory.MonoidalClosed.curry f) ((adj.homEquiv Y ((CategoryTheory.ihom (F.obj X)).obj (F.obj Z))) (CategoryTheory.MonoidalClosed.curry ((adj.toEquivalence.symm.toAdjunction.homEquiv (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) Z) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.Monoidal.commTensorLeft F X).compInverseIso.hom.app Y) f))))","decl":"/-- Suppose we have a monoidal equivalence `F : C ≌ D`, with `D` monoidal closed. We can pull the\nmonoidal closed instance back along the equivalence. For `X, Y, Z : C`, this lemma describes the\nresulting currying map `Hom(X ⊗ Y, Z) → Hom(Y, (X ⟶[C] Z))`. (`X ⟶[C] Z` is defined to be\n`F⁻¹(F(X) ⟶[D] F(Z))`, so currying in `C` is given by essentially conjugating currying in\n`D` by `F.`) -/\ntheorem ofEquiv_curry_def {X Y Z : C} (f : X ⊗ Y ⟶ Z) :\n    letI := ofEquiv F adj\n    MonoidalClosed.curry f =\n      adj.homEquiv Y ((ihom (F.obj X)).obj (F.obj Z))\n        (MonoidalClosed.curry (adj.toEquivalence.symm.toAdjunction.homEquiv (F.obj X ⊗ F.obj Y) Z\n        ((Iso.compInverseIso (H := adj.toEquivalence)\n          (Functor.Monoidal.commTensorLeft F X)).hom.app Y ≫ f))) := by\n  -- This whole proof used to be `rfl` before https://github.com/leanprover-community/mathlib4/pull/16317.\n  change ((adj.comp ((ihom.adjunction (F.obj X)).comp\n      adj.toEquivalence.symm.toAdjunction)).ofNatIsoLeft _).homEquiv _ _ _ = _\n  dsimp only [Adjunction.ofNatIsoLeft]\n  rw [Adjunction.mkOfHomEquiv_homEquiv]\n  dsimp\n  rw [Adjunction.comp_homEquiv, Adjunction.comp_homEquiv]\n  rfl\n\n"}
{"name":"CategoryTheory.MonoidalClosed.ofEquiv_uncurry_def","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\ninst✝⁵ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝² : F.Monoidal\ninst✝¹ : F.IsEquivalence\ninst✝ : CategoryTheory.MonoidalClosed D\nX Y Z : C\nf : Quiver.Hom Y ((CategoryTheory.ihom X).obj Z)\n⊢ Eq (CategoryTheory.MonoidalClosed.uncurry f) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.Monoidal.commTensorLeft F X).compInverseIso.inv.app Y) ((adj.toEquivalence.symm.toAdjunction.homEquiv ((F.comp (CategoryTheory.MonoidalCategory.tensorLeft (F.obj X))).obj Y) Z).symm (CategoryTheory.MonoidalClosed.uncurry ((adj.homEquiv Y ((CategoryTheory.ihom (F.obj X)).obj (adj.toEquivalence.symm.inverse.obj Z))).symm f))))","decl":"/-- Suppose we have a monoidal equivalence `F : C ≌ D`, with `D` monoidal closed. We can pull the\nmonoidal closed instance back along the equivalence. For `X, Y, Z : C`, this lemma describes the\nresulting uncurrying map `Hom(Y, (X ⟶[C] Z)) → Hom(X ⊗ Y ⟶ Z)`. (`X ⟶[C] Z` is\ndefined to be `F⁻¹(F(X) ⟶[D] F(Z))`, so uncurrying in `C` is given by essentially conjugating\nuncurrying in `D` by `F.`) -/\ntheorem ofEquiv_uncurry_def {X Y Z : C} :\n    letI := ofEquiv F adj\n    ∀ (f : Y ⟶ (ihom X).obj Z), MonoidalClosed.uncurry f =\n      ((Iso.compInverseIso (H := adj.toEquivalence)\n          (Functor.Monoidal.commTensorLeft F X)).inv.app Y) ≫\n            (adj.toEquivalence.symm.toAdjunction.homEquiv _ _).symm\n              (MonoidalClosed.uncurry ((adj.homEquiv _ _).symm f)) := by\n  intro f\n  -- This whole proof used to be `rfl` before https://github.com/leanprover-community/mathlib4/pull/16317.\n  change (((adj.comp ((ihom.adjunction (F.obj X)).comp\n      adj.toEquivalence.symm.toAdjunction)).ofNatIsoLeft _).homEquiv _ _).symm _ = _\n  dsimp only [Adjunction.ofNatIsoLeft]\n  rw [Adjunction.mkOfHomEquiv_homEquiv]\n  dsimp\n  rw [Adjunction.comp_homEquiv, Adjunction.comp_homEquiv]\n  rfl\n\n"}
{"name":"CategoryTheory.MonoidalClosed.id_eq","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nx : C\ninst✝ : CategoryTheory.Closed x\n⊢ Eq (CategoryTheory.MonoidalClosed.id x) (CategoryTheory.MonoidalClosed.curry (CategoryTheory.MonoidalCategoryStruct.rightUnitor x).hom)","decl":"/-- Unfold the definition of `id`.\nThis exists to streamline the proofs of `MonoidalClosed.id_comp` and `MonoidalClosed.comp_id` -/\nlemma id_eq (x : C) [Closed x] : id x = curry (ρ_ x).hom := rfl\n\n"}
{"name":"CategoryTheory.MonoidalClosed.compTranspose_eq","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.MonoidalCategory C\nx y z : C\ninst✝¹ : CategoryTheory.Closed x\ninst✝ : CategoryTheory.Closed y\n⊢ Eq (CategoryTheory.MonoidalClosed.compTranspose x y z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator x ((CategoryTheory.ihom x).obj y) ((CategoryTheory.ihom y).obj z)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight ((CategoryTheory.ihom.ev x).app y) ((CategoryTheory.ihom y).obj z)) ((CategoryTheory.ihom.ev y).app z)))","decl":"/-- Unfold the definition of `compTranspose`.\nThis exists to streamline the proof of `MonoidalClosed.assoc` -/\nlemma compTranspose_eq (x y z : C) [Closed x] [Closed y] :\n    compTranspose x y z = (α_ _ _ _).inv ≫ (ihom.ev x).app y ▷ _ ≫ (ihom.ev y).app z :=\n  rfl\n\n"}
{"name":"CategoryTheory.MonoidalClosed.comp_eq","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.MonoidalCategory C\nx y z : C\ninst✝¹ : CategoryTheory.Closed x\ninst✝ : CategoryTheory.Closed y\n⊢ Eq (CategoryTheory.MonoidalClosed.comp x y z) (CategoryTheory.MonoidalClosed.curry (CategoryTheory.MonoidalClosed.compTranspose x y z))","decl":"/-- Unfold the definition of `comp`.\nThis exists to streamline the proof of `MonoidalClosed.assoc` -/\nlemma comp_eq (x y z : C) [Closed x] [Closed y] : comp x y z = curry (compTranspose x y z) := rfl\n\n"}
{"name":"CategoryTheory.MonoidalClosed.id_comp_assoc","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nx y : C\ninst✝ : CategoryTheory.Closed x\nZ : C\nh : Quiver.Hom ((CategoryTheory.ihom x).obj y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor ((CategoryTheory.ihom x).obj y)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalClosed.id x) ((CategoryTheory.ihom x).obj y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalClosed.comp x x y) h))) h","decl":"/-- Left unitality of the enriched structure -/\n@[reassoc (attr := simp)]\nlemma id_comp (x y : C) [Closed x] :\n    (λ_ ((ihom x).obj y)).inv ≫ id x ▷ _ ≫ comp x x y = 𝟙 _:= by\n  apply uncurry_injective\n  rw [uncurry_natural_left, uncurry_natural_left, comp_eq, uncurry_curry, id_eq, compTranspose_eq,\n      associator_inv_naturality_middle_assoc, ← comp_whiskerRight_assoc, ← uncurry_eq,\n      uncurry_curry, triangle_assoc_comp_right_assoc, whiskerLeft_inv_hom_assoc,\n      uncurry_id_eq_ev _ _]\n\n"}
{"name":"CategoryTheory.MonoidalClosed.id_comp","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nx y : C\ninst✝ : CategoryTheory.Closed x\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor ((CategoryTheory.ihom x).obj y)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalClosed.id x) ((CategoryTheory.ihom x).obj y)) (CategoryTheory.MonoidalClosed.comp x x y))) (CategoryTheory.CategoryStruct.id ((CategoryTheory.ihom x).obj y))","decl":"/-- Left unitality of the enriched structure -/\n@[reassoc (attr := simp)]\nlemma id_comp (x y : C) [Closed x] :\n    (λ_ ((ihom x).obj y)).inv ≫ id x ▷ _ ≫ comp x x y = 𝟙 _:= by\n  apply uncurry_injective\n  rw [uncurry_natural_left, uncurry_natural_left, comp_eq, uncurry_curry, id_eq, compTranspose_eq,\n      associator_inv_naturality_middle_assoc, ← comp_whiskerRight_assoc, ← uncurry_eq,\n      uncurry_curry, triangle_assoc_comp_right_assoc, whiskerLeft_inv_hom_assoc,\n      uncurry_id_eq_ev _ _]\n\n"}
{"name":"CategoryTheory.MonoidalClosed.comp_id_assoc","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.MonoidalCategory C\nx y : C\ninst✝¹ : CategoryTheory.Closed x\ninst✝ : CategoryTheory.Closed y\nZ : C\nh : Quiver.Hom ((CategoryTheory.ihom x).obj y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor ((CategoryTheory.ihom x).obj y)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft ((CategoryTheory.ihom x).obj y) (CategoryTheory.MonoidalClosed.id y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalClosed.comp x y y) h))) h","decl":"/-- Right unitality of the enriched structure -/\n@[reassoc (attr := simp)]\nlemma comp_id (x y : C) [Closed x] [Closed y] :\n    (ρ_ ((ihom x).obj y)).inv ≫ _ ◁ id y ≫ comp x y y = 𝟙 _ := by\n  apply uncurry_injective\n  rw [uncurry_natural_left, uncurry_natural_left, comp_eq, uncurry_curry, compTranspose_eq,\n    associator_inv_naturality_right_assoc, ← rightUnitor_tensor_inv_assoc,\n    whisker_exchange_assoc, ← rightUnitor_inv_naturality_assoc, ← uncurry_id_eq_ev y y]\n  simp only [Functor.id_obj]\n  rw [← uncurry_natural_left]\n  simp [id_eq, uncurry_id_eq_ev]\n\n"}
{"name":"CategoryTheory.MonoidalClosed.comp_id","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.MonoidalCategory C\nx y : C\ninst✝¹ : CategoryTheory.Closed x\ninst✝ : CategoryTheory.Closed y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor ((CategoryTheory.ihom x).obj y)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft ((CategoryTheory.ihom x).obj y) (CategoryTheory.MonoidalClosed.id y)) (CategoryTheory.MonoidalClosed.comp x y y))) (CategoryTheory.CategoryStruct.id ((CategoryTheory.ihom x).obj y))","decl":"/-- Right unitality of the enriched structure -/\n@[reassoc (attr := simp)]\nlemma comp_id (x y : C) [Closed x] [Closed y] :\n    (ρ_ ((ihom x).obj y)).inv ≫ _ ◁ id y ≫ comp x y y = 𝟙 _ := by\n  apply uncurry_injective\n  rw [uncurry_natural_left, uncurry_natural_left, comp_eq, uncurry_curry, compTranspose_eq,\n    associator_inv_naturality_right_assoc, ← rightUnitor_tensor_inv_assoc,\n    whisker_exchange_assoc, ← rightUnitor_inv_naturality_assoc, ← uncurry_id_eq_ev y y]\n  simp only [Functor.id_obj]\n  rw [← uncurry_natural_left]\n  simp [id_eq, uncurry_id_eq_ev]\n\n"}
{"name":"CategoryTheory.MonoidalClosed.assoc","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nw x y z : C\ninst✝² : CategoryTheory.Closed w\ninst✝¹ : CategoryTheory.Closed x\ninst✝ : CategoryTheory.Closed y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator ((CategoryTheory.ihom w).obj x) ((CategoryTheory.ihom x).obj y) ((CategoryTheory.ihom y).obj z)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalClosed.comp w x y) ((CategoryTheory.ihom y).obj z)) (CategoryTheory.MonoidalClosed.comp w y z))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft ((CategoryTheory.ihom w).obj x) (CategoryTheory.MonoidalClosed.comp x y z)) (CategoryTheory.MonoidalClosed.comp w x z))","decl":"/-- Associativity of the enriched structure -/\n@[reassoc]\nlemma assoc (w x y z : C) [Closed w] [Closed x] [Closed y] :\n    (α_ _ _ _).inv ≫ comp w x y ▷ _ ≫ comp w y z = _ ◁ comp x y z ≫ comp w x z := by\n  apply uncurry_injective\n  simp only [uncurry_natural_left, comp_eq]\n  rw [uncurry_curry, uncurry_curry]; simp only [compTranspose_eq, Category.assoc]\n  rw [associator_inv_naturality_middle_assoc, ← comp_whiskerRight_assoc]; dsimp\n  rw [← uncurry_eq, uncurry_curry, associator_inv_naturality_right_assoc, whisker_exchange_assoc,\n    ← uncurry_eq, uncurry_curry]\n  simp only [comp_whiskerRight, tensorLeft_obj, Category.assoc, pentagon_inv_assoc,\n    whiskerRight_tensor, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.MonoidalClosed.assoc_assoc","module":"Mathlib.CategoryTheory.Closed.Monoidal","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nw x y z : C\ninst✝² : CategoryTheory.Closed w\ninst✝¹ : CategoryTheory.Closed x\ninst✝ : CategoryTheory.Closed y\nZ : C\nh : Quiver.Hom ((CategoryTheory.ihom w).obj z) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator ((CategoryTheory.ihom w).obj x) ((CategoryTheory.ihom x).obj y) ((CategoryTheory.ihom y).obj z)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalClosed.comp w x y) ((CategoryTheory.ihom y).obj z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalClosed.comp w y z) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft ((CategoryTheory.ihom w).obj x) (CategoryTheory.MonoidalClosed.comp x y z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalClosed.comp w x z) h))","decl":"/-- Associativity of the enriched structure -/\n@[reassoc]\nlemma assoc (w x y z : C) [Closed w] [Closed x] [Closed y] :\n    (α_ _ _ _).inv ≫ comp w x y ▷ _ ≫ comp w y z = _ ◁ comp x y z ≫ comp w x z := by\n  apply uncurry_injective\n  simp only [uncurry_natural_left, comp_eq]\n  rw [uncurry_curry, uncurry_curry]; simp only [compTranspose_eq, Category.assoc]\n  rw [associator_inv_naturality_middle_assoc, ← comp_whiskerRight_assoc]; dsimp\n  rw [← uncurry_eq, uncurry_curry, associator_inv_naturality_right_assoc, whisker_exchange_assoc,\n    ← uncurry_eq, uncurry_curry]\n  simp only [comp_whiskerRight, tensorLeft_obj, Category.assoc, pentagon_inv_assoc,\n    whiskerRight_tensor, Iso.hom_inv_id_assoc]\n\n"}
