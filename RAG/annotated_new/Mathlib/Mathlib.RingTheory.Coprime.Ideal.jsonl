{"name":"Ideal.iSup_iInf_eq_top_iff_pairwise","module":"Mathlib.RingTheory.Coprime.Ideal","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝ : CommSemiring R\nt : Finset ι\nh : t.Nonempty\nI : ι → Ideal R\n⊢ Iff (Eq (iSup fun i => iSup fun h => iInf fun j => iInf fun x => iInf fun x => I j) Top.top) ((↑t).Pairwise fun i j => Eq (Max.max (I i) (I j)) Top.top)","decl":"/-- A finite family of ideals is pairwise coprime (that is, any two of them generate the whole ring)\niff when taking all the possible intersections of all but one of these ideals, the resulting family\nof ideals still generate the whole ring.\n\nFor example with three ideals : `I ⊔ J = I ⊔ K = J ⊔ K = ⊤ ↔ (I ⊓ J) ⊔ (I ⊓ K) ⊔ (J ⊓ K) = ⊤`.\n\nWhen ideals are all of the form `I i = R ∙ s i`, this is equivalent to the\n`exists_sum_eq_one_iff_pairwise_coprime` lemma. -/\ntheorem iSup_iInf_eq_top_iff_pairwise {t : Finset ι} (h : t.Nonempty) (I : ι → Ideal R) :\n    (⨆ i ∈ t, ⨅ (j) (_ : j ∈ t) (_ : j ≠ i), I j) = ⊤ ↔\n      (t : Set ι).Pairwise fun i j => I i ⊔ I j = ⊤ := by\n  haveI : DecidableEq ι := Classical.decEq ι\n  rw [eq_top_iff_one, Submodule.mem_iSup_finset_iff_exists_sum]\n  refine h.cons_induction ?_ ?_ <;> clear t h\n  · simp only [Finset.sum_singleton, Finset.coe_singleton, Set.pairwise_singleton, iff_true]\n    refine fun a => ⟨fun i => if h : i = a then ⟨1, ?_⟩ else 0, ?_⟩\n    · simp [h]\n    · simp only [dif_pos, Submodule.coe_mk, eq_self_iff_true]\n  intro a t hat h ih\n  rw [Finset.coe_cons,\n    Set.pairwise_insert_of_symmetric fun i j (h : I i ⊔ I j = ⊤) ↦ (sup_comm _ _).trans h]\n  constructor\n  · rintro ⟨μ, hμ⟩\n    rw [Finset.sum_cons] at hμ\n    -- Porting note: `refine` yields goals in a different order than in lean3.\n    refine ⟨ih.mp ⟨Pi.single h.choose ⟨μ a, ?a1⟩ + fun i => ⟨μ i, ?a2⟩, ?a3⟩, fun b hb ab => ?a4⟩\n    case a1 =>\n      have := Submodule.coe_mem (μ a)\n      rw [mem_iInf] at this ⊢\n      --for some reason `simp only [mem_iInf]` times out\n      intro i\n      specialize this i\n      rw [mem_iInf, mem_iInf] at this ⊢\n      intro hi _\n      apply this (Finset.subset_cons _ hi)\n      rintro rfl\n      exact hat hi\n    case a2 =>\n      have := Submodule.coe_mem (μ i)\n      simp only [mem_iInf] at this ⊢\n      intro j hj ij\n      exact this _ (Finset.subset_cons _ hj) ij\n    case a3 =>\n      rw [← @if_pos _ _ h.choose_spec R (μ a) 0, ← Finset.sum_pi_single', ← Finset.sum_add_distrib]\n        at hμ\n      convert hμ\n      rename_i i _\n      rw [Pi.add_apply, Submodule.coe_add, Submodule.coe_mk]\n      by_cases hi : i = h.choose\n      · rw [hi, Pi.single_eq_same, Pi.single_eq_same, Submodule.coe_mk]\n      · rw [Pi.single_eq_of_ne hi, Pi.single_eq_of_ne hi, Submodule.coe_zero]\n    case a4 =>\n      rw [eq_top_iff_one, Submodule.mem_sup]\n      rw [add_comm] at hμ\n      refine ⟨_, ?_, _, ?_, hμ⟩\n      · refine sum_mem _ fun x hx => ?_\n        have := Submodule.coe_mem (μ x)\n        simp only [mem_iInf] at this\n        apply this _ (Finset.mem_cons_self _ _)\n        rintro rfl\n        exact hat hx\n      · have := Submodule.coe_mem (μ a)\n        simp only [mem_iInf] at this\n        exact this _ (Finset.subset_cons _ hb) ab.symm\n  · rintro ⟨hs, Hb⟩\n    obtain ⟨μ, hμ⟩ := ih.mpr hs\n    have := sup_iInf_eq_top fun b hb => Hb b hb (ne_of_mem_of_not_mem hb hat).symm\n    rw [eq_top_iff_one, Submodule.mem_sup] at this\n    obtain ⟨u, hu, v, hv, huv⟩ := this\n    refine ⟨fun i => if hi : i = a then ⟨v, ?_⟩ else ⟨u * μ i, ?_⟩, ?_⟩\n    · simp only [mem_iInf] at hv ⊢\n      intro j hj ij\n      rw [Finset.mem_cons, ← hi] at hj\n      exact hv _ (hj.resolve_left ij)\n    · have := Submodule.coe_mem (μ i)\n      simp only [mem_iInf] at this ⊢\n      intro j hj ij\n      rcases Finset.mem_cons.mp hj with (rfl | hj)\n      · exact mul_mem_right _ _ hu\n      · exact mul_mem_left _ _ (this _ hj ij)\n    · dsimp only\n      rw [Finset.sum_cons, dif_pos rfl, add_comm]\n      rw [← mul_one u] at huv\n      rw [← huv, ← hμ, Finset.mul_sum]\n      congr 1\n      apply Finset.sum_congr rfl\n      intro j hj\n      rw [dif_neg]\n      rintro rfl\n      exact hat hj\n\n"}
