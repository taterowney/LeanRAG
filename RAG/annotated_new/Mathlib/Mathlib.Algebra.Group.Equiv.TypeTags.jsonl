{"name":"AddEquiv.toMultiplicative_symm_apply_apply","module":"Mathlib.Algebra.Group.Equiv.TypeTags","initialProofState":"G : Type u_2\nH : Type u_3\ninst✝¹ : AddZeroClass G\ninst✝ : AddZeroClass H\nf : MulEquiv (Multiplicative G) (Multiplicative H)\na : G\n⊢ Eq ((AddEquiv.toMultiplicative.symm f) a) ((AddMonoidHom.toMultiplicative.symm f.toMonoidHom) a)","decl":"/-- Reinterpret `G ≃+ H` as `Multiplicative G ≃* Multiplicative H`. -/\n@[simps]\ndef AddEquiv.toMultiplicative [AddZeroClass G] [AddZeroClass H] :\n    G ≃+ H ≃ (Multiplicative G ≃* Multiplicative H) where\n  toFun f :=\n  { toFun := AddMonoidHom.toMultiplicative f.toAddMonoidHom\n    invFun := AddMonoidHom.toMultiplicative f.symm.toAddMonoidHom\n    left_inv := f.left_inv\n    right_inv := f.right_inv\n    map_mul' := map_add f }\n  invFun f :=\n  { toFun := AddMonoidHom.toMultiplicative.symm f.toMonoidHom\n    invFun := AddMonoidHom.toMultiplicative.symm f.symm.toMonoidHom\n    left_inv := f.left_inv\n    right_inv := f.right_inv\n    map_add' := map_mul f }\n  left_inv x := by ext; rfl\n  right_inv x := by ext; rfl\n\n"}
{"name":"AddEquiv.toMultiplicative_apply_apply","module":"Mathlib.Algebra.Group.Equiv.TypeTags","initialProofState":"G : Type u_2\nH : Type u_3\ninst✝¹ : AddZeroClass G\ninst✝ : AddZeroClass H\nf : AddEquiv G H\na : Multiplicative G\n⊢ Eq ((AddEquiv.toMultiplicative f) a) ((AddMonoidHom.toMultiplicative f.toAddMonoidHom) a)","decl":"/-- Reinterpret `G ≃+ H` as `Multiplicative G ≃* Multiplicative H`. -/\n@[simps]\ndef AddEquiv.toMultiplicative [AddZeroClass G] [AddZeroClass H] :\n    G ≃+ H ≃ (Multiplicative G ≃* Multiplicative H) where\n  toFun f :=\n  { toFun := AddMonoidHom.toMultiplicative f.toAddMonoidHom\n    invFun := AddMonoidHom.toMultiplicative f.symm.toAddMonoidHom\n    left_inv := f.left_inv\n    right_inv := f.right_inv\n    map_mul' := map_add f }\n  invFun f :=\n  { toFun := AddMonoidHom.toMultiplicative.symm f.toMonoidHom\n    invFun := AddMonoidHom.toMultiplicative.symm f.symm.toMonoidHom\n    left_inv := f.left_inv\n    right_inv := f.right_inv\n    map_add' := map_mul f }\n  left_inv x := by ext; rfl\n  right_inv x := by ext; rfl\n\n"}
{"name":"AddEquiv.toMultiplicative_symm_apply_symm_apply","module":"Mathlib.Algebra.Group.Equiv.TypeTags","initialProofState":"G : Type u_2\nH : Type u_3\ninst✝¹ : AddZeroClass G\ninst✝ : AddZeroClass H\nf : MulEquiv (Multiplicative G) (Multiplicative H)\na : H\n⊢ Eq ((AddEquiv.toMultiplicative.symm f).symm a) ((AddMonoidHom.toMultiplicative.symm f.symm.toMonoidHom) a)","decl":"/-- Reinterpret `G ≃+ H` as `Multiplicative G ≃* Multiplicative H`. -/\n@[simps]\ndef AddEquiv.toMultiplicative [AddZeroClass G] [AddZeroClass H] :\n    G ≃+ H ≃ (Multiplicative G ≃* Multiplicative H) where\n  toFun f :=\n  { toFun := AddMonoidHom.toMultiplicative f.toAddMonoidHom\n    invFun := AddMonoidHom.toMultiplicative f.symm.toAddMonoidHom\n    left_inv := f.left_inv\n    right_inv := f.right_inv\n    map_mul' := map_add f }\n  invFun f :=\n  { toFun := AddMonoidHom.toMultiplicative.symm f.toMonoidHom\n    invFun := AddMonoidHom.toMultiplicative.symm f.symm.toMonoidHom\n    left_inv := f.left_inv\n    right_inv := f.right_inv\n    map_add' := map_mul f }\n  left_inv x := by ext; rfl\n  right_inv x := by ext; rfl\n\n"}
{"name":"AddEquiv.toMultiplicative_apply_symm_apply","module":"Mathlib.Algebra.Group.Equiv.TypeTags","initialProofState":"G : Type u_2\nH : Type u_3\ninst✝¹ : AddZeroClass G\ninst✝ : AddZeroClass H\nf : AddEquiv G H\na : Multiplicative H\n⊢ Eq ((AddEquiv.toMultiplicative f).symm a) ((AddMonoidHom.toMultiplicative f.symm.toAddMonoidHom) a)","decl":"/-- Reinterpret `G ≃+ H` as `Multiplicative G ≃* Multiplicative H`. -/\n@[simps]\ndef AddEquiv.toMultiplicative [AddZeroClass G] [AddZeroClass H] :\n    G ≃+ H ≃ (Multiplicative G ≃* Multiplicative H) where\n  toFun f :=\n  { toFun := AddMonoidHom.toMultiplicative f.toAddMonoidHom\n    invFun := AddMonoidHom.toMultiplicative f.symm.toAddMonoidHom\n    left_inv := f.left_inv\n    right_inv := f.right_inv\n    map_mul' := map_add f }\n  invFun f :=\n  { toFun := AddMonoidHom.toMultiplicative.symm f.toMonoidHom\n    invFun := AddMonoidHom.toMultiplicative.symm f.symm.toMonoidHom\n    left_inv := f.left_inv\n    right_inv := f.right_inv\n    map_add' := map_mul f }\n  left_inv x := by ext; rfl\n  right_inv x := by ext; rfl\n\n"}
{"name":"MulEquiv.toAdditive_apply_apply","module":"Mathlib.Algebra.Group.Equiv.TypeTags","initialProofState":"G : Type u_2\nH : Type u_3\ninst✝¹ : MulOneClass G\ninst✝ : MulOneClass H\nf : MulEquiv G H\na : Additive G\n⊢ Eq ((MulEquiv.toAdditive f) a) ((MonoidHom.toAdditive f.toMonoidHom) a)","decl":"/-- Reinterpret `G ≃* H` as `Additive G ≃+ Additive H`. -/\n@[simps]\ndef MulEquiv.toAdditive [MulOneClass G] [MulOneClass H] :\n    G ≃* H ≃ (Additive G ≃+ Additive H) where\n  toFun f :=\n  { toFun := MonoidHom.toAdditive f.toMonoidHom\n    invFun := MonoidHom.toAdditive f.symm.toMonoidHom\n    left_inv := f.left_inv\n    right_inv := f.right_inv\n    map_add' := map_mul f }\n  invFun f :=\n  { toFun := MonoidHom.toAdditive.symm f.toAddMonoidHom\n    invFun := MonoidHom.toAdditive.symm f.symm.toAddMonoidHom\n    left_inv := f.left_inv\n    right_inv := f.right_inv\n    map_mul' := map_add f }\n  left_inv x := by ext; rfl\n  right_inv x := by ext; rfl\n\n"}
{"name":"MulEquiv.toAdditive_symm_apply_apply","module":"Mathlib.Algebra.Group.Equiv.TypeTags","initialProofState":"G : Type u_2\nH : Type u_3\ninst✝¹ : MulOneClass G\ninst✝ : MulOneClass H\nf : AddEquiv (Additive G) (Additive H)\na : G\n⊢ Eq ((MulEquiv.toAdditive.symm f) a) ((MonoidHom.toAdditive.symm f.toAddMonoidHom) a)","decl":"/-- Reinterpret `G ≃* H` as `Additive G ≃+ Additive H`. -/\n@[simps]\ndef MulEquiv.toAdditive [MulOneClass G] [MulOneClass H] :\n    G ≃* H ≃ (Additive G ≃+ Additive H) where\n  toFun f :=\n  { toFun := MonoidHom.toAdditive f.toMonoidHom\n    invFun := MonoidHom.toAdditive f.symm.toMonoidHom\n    left_inv := f.left_inv\n    right_inv := f.right_inv\n    map_add' := map_mul f }\n  invFun f :=\n  { toFun := MonoidHom.toAdditive.symm f.toAddMonoidHom\n    invFun := MonoidHom.toAdditive.symm f.symm.toAddMonoidHom\n    left_inv := f.left_inv\n    right_inv := f.right_inv\n    map_mul' := map_add f }\n  left_inv x := by ext; rfl\n  right_inv x := by ext; rfl\n\n"}
{"name":"MulEquiv.toAdditive_apply_symm_apply","module":"Mathlib.Algebra.Group.Equiv.TypeTags","initialProofState":"G : Type u_2\nH : Type u_3\ninst✝¹ : MulOneClass G\ninst✝ : MulOneClass H\nf : MulEquiv G H\na : Additive H\n⊢ Eq ((MulEquiv.toAdditive f).symm a) ((MonoidHom.toAdditive f.symm.toMonoidHom) a)","decl":"/-- Reinterpret `G ≃* H` as `Additive G ≃+ Additive H`. -/\n@[simps]\ndef MulEquiv.toAdditive [MulOneClass G] [MulOneClass H] :\n    G ≃* H ≃ (Additive G ≃+ Additive H) where\n  toFun f :=\n  { toFun := MonoidHom.toAdditive f.toMonoidHom\n    invFun := MonoidHom.toAdditive f.symm.toMonoidHom\n    left_inv := f.left_inv\n    right_inv := f.right_inv\n    map_add' := map_mul f }\n  invFun f :=\n  { toFun := MonoidHom.toAdditive.symm f.toAddMonoidHom\n    invFun := MonoidHom.toAdditive.symm f.symm.toAddMonoidHom\n    left_inv := f.left_inv\n    right_inv := f.right_inv\n    map_mul' := map_add f }\n  left_inv x := by ext; rfl\n  right_inv x := by ext; rfl\n\n"}
{"name":"MulEquiv.toAdditive_symm_apply_symm_apply","module":"Mathlib.Algebra.Group.Equiv.TypeTags","initialProofState":"G : Type u_2\nH : Type u_3\ninst✝¹ : MulOneClass G\ninst✝ : MulOneClass H\nf : AddEquiv (Additive G) (Additive H)\na : H\n⊢ Eq ((MulEquiv.toAdditive.symm f).symm a) ((MonoidHom.toAdditive.symm f.symm.toAddMonoidHom) a)","decl":"/-- Reinterpret `G ≃* H` as `Additive G ≃+ Additive H`. -/\n@[simps]\ndef MulEquiv.toAdditive [MulOneClass G] [MulOneClass H] :\n    G ≃* H ≃ (Additive G ≃+ Additive H) where\n  toFun f :=\n  { toFun := MonoidHom.toAdditive f.toMonoidHom\n    invFun := MonoidHom.toAdditive f.symm.toMonoidHom\n    left_inv := f.left_inv\n    right_inv := f.right_inv\n    map_add' := map_mul f }\n  invFun f :=\n  { toFun := MonoidHom.toAdditive.symm f.toAddMonoidHom\n    invFun := MonoidHom.toAdditive.symm f.symm.toAddMonoidHom\n    left_inv := f.left_inv\n    right_inv := f.right_inv\n    map_mul' := map_add f }\n  left_inv x := by ext; rfl\n  right_inv x := by ext; rfl\n\n"}
{"name":"AddEquiv.toMultiplicative'_symm_apply_apply","module":"Mathlib.Algebra.Group.Equiv.TypeTags","initialProofState":"G : Type u_2\nH : Type u_3\ninst✝¹ : MulOneClass G\ninst✝ : AddZeroClass H\nf : MulEquiv G (Multiplicative H)\na : Additive G\n⊢ Eq ((AddEquiv.toMultiplicative'.symm f) a) ((AddMonoidHom.toMultiplicative'.symm f.toMonoidHom) a)","decl":"/-- Reinterpret `Additive G ≃+ H` as `G ≃* Multiplicative H`. -/\n@[simps]\ndef AddEquiv.toMultiplicative' [MulOneClass G] [AddZeroClass H] :\n    Additive G ≃+ H ≃ (G ≃* Multiplicative H) where\n  toFun f :=\n  { toFun := AddMonoidHom.toMultiplicative' f.toAddMonoidHom\n    invFun := AddMonoidHom.toMultiplicative'' f.symm.toAddMonoidHom\n    left_inv := f.left_inv\n    right_inv := f.right_inv\n    map_mul' := map_add f }\n  invFun f :=\n  { toFun := AddMonoidHom.toMultiplicative'.symm f.toMonoidHom\n    invFun := AddMonoidHom.toMultiplicative''.symm f.symm.toMonoidHom\n    left_inv := f.left_inv\n    right_inv := f.right_inv\n    map_add' := map_mul f }\n  left_inv x := by ext; rfl\n  right_inv x := by ext; rfl\n\n"}
{"name":"AddEquiv.toMultiplicative'_apply_symm_apply","module":"Mathlib.Algebra.Group.Equiv.TypeTags","initialProofState":"G : Type u_2\nH : Type u_3\ninst✝¹ : MulOneClass G\ninst✝ : AddZeroClass H\nf : AddEquiv (Additive G) H\na : Multiplicative H\n⊢ Eq ((AddEquiv.toMultiplicative' f).symm a) ((AddMonoidHom.toMultiplicative'' f.symm.toAddMonoidHom) a)","decl":"/-- Reinterpret `Additive G ≃+ H` as `G ≃* Multiplicative H`. -/\n@[simps]\ndef AddEquiv.toMultiplicative' [MulOneClass G] [AddZeroClass H] :\n    Additive G ≃+ H ≃ (G ≃* Multiplicative H) where\n  toFun f :=\n  { toFun := AddMonoidHom.toMultiplicative' f.toAddMonoidHom\n    invFun := AddMonoidHom.toMultiplicative'' f.symm.toAddMonoidHom\n    left_inv := f.left_inv\n    right_inv := f.right_inv\n    map_mul' := map_add f }\n  invFun f :=\n  { toFun := AddMonoidHom.toMultiplicative'.symm f.toMonoidHom\n    invFun := AddMonoidHom.toMultiplicative''.symm f.symm.toMonoidHom\n    left_inv := f.left_inv\n    right_inv := f.right_inv\n    map_add' := map_mul f }\n  left_inv x := by ext; rfl\n  right_inv x := by ext; rfl\n\n"}
{"name":"AddEquiv.toMultiplicative'_apply_apply","module":"Mathlib.Algebra.Group.Equiv.TypeTags","initialProofState":"G : Type u_2\nH : Type u_3\ninst✝¹ : MulOneClass G\ninst✝ : AddZeroClass H\nf : AddEquiv (Additive G) H\na : G\n⊢ Eq ((AddEquiv.toMultiplicative' f) a) ((AddMonoidHom.toMultiplicative' f.toAddMonoidHom) a)","decl":"/-- Reinterpret `Additive G ≃+ H` as `G ≃* Multiplicative H`. -/\n@[simps]\ndef AddEquiv.toMultiplicative' [MulOneClass G] [AddZeroClass H] :\n    Additive G ≃+ H ≃ (G ≃* Multiplicative H) where\n  toFun f :=\n  { toFun := AddMonoidHom.toMultiplicative' f.toAddMonoidHom\n    invFun := AddMonoidHom.toMultiplicative'' f.symm.toAddMonoidHom\n    left_inv := f.left_inv\n    right_inv := f.right_inv\n    map_mul' := map_add f }\n  invFun f :=\n  { toFun := AddMonoidHom.toMultiplicative'.symm f.toMonoidHom\n    invFun := AddMonoidHom.toMultiplicative''.symm f.symm.toMonoidHom\n    left_inv := f.left_inv\n    right_inv := f.right_inv\n    map_add' := map_mul f }\n  left_inv x := by ext; rfl\n  right_inv x := by ext; rfl\n\n"}
{"name":"AddEquiv.toMultiplicative'_symm_apply_symm_apply","module":"Mathlib.Algebra.Group.Equiv.TypeTags","initialProofState":"G : Type u_2\nH : Type u_3\ninst✝¹ : MulOneClass G\ninst✝ : AddZeroClass H\nf : MulEquiv G (Multiplicative H)\na : H\n⊢ Eq ((AddEquiv.toMultiplicative'.symm f).symm a) ((AddMonoidHom.toMultiplicative''.symm f.symm.toMonoidHom) a)","decl":"/-- Reinterpret `Additive G ≃+ H` as `G ≃* Multiplicative H`. -/\n@[simps]\ndef AddEquiv.toMultiplicative' [MulOneClass G] [AddZeroClass H] :\n    Additive G ≃+ H ≃ (G ≃* Multiplicative H) where\n  toFun f :=\n  { toFun := AddMonoidHom.toMultiplicative' f.toAddMonoidHom\n    invFun := AddMonoidHom.toMultiplicative'' f.symm.toAddMonoidHom\n    left_inv := f.left_inv\n    right_inv := f.right_inv\n    map_mul' := map_add f }\n  invFun f :=\n  { toFun := AddMonoidHom.toMultiplicative'.symm f.toMonoidHom\n    invFun := AddMonoidHom.toMultiplicative''.symm f.symm.toMonoidHom\n    left_inv := f.left_inv\n    right_inv := f.right_inv\n    map_add' := map_mul f }\n  left_inv x := by ext; rfl\n  right_inv x := by ext; rfl\n\n"}
{"name":"AddEquiv.toMultiplicative''_apply_apply","module":"Mathlib.Algebra.Group.Equiv.TypeTags","initialProofState":"G : Type u_2\nH : Type u_3\ninst✝¹ : AddZeroClass G\ninst✝ : MulOneClass H\nf : AddEquiv G (Additive H)\na : Multiplicative G\n⊢ Eq ((AddEquiv.toMultiplicative'' f) a) ((AddMonoidHom.toMultiplicative'' f.toAddMonoidHom) a)","decl":"/-- Reinterpret `G ≃+ Additive H` as `Multiplicative G ≃* H`. -/\n@[simps]\ndef AddEquiv.toMultiplicative'' [AddZeroClass G] [MulOneClass H] :\n    G ≃+ Additive H ≃ (Multiplicative G ≃* H) where\n  toFun f :=\n  { toFun := AddMonoidHom.toMultiplicative'' f.toAddMonoidHom\n    invFun := AddMonoidHom.toMultiplicative' f.symm.toAddMonoidHom\n    left_inv := f.left_inv\n    right_inv := f.right_inv\n    map_mul' := map_add f }\n  invFun f :=\n  { toFun := AddMonoidHom.toMultiplicative''.symm f.toMonoidHom\n    invFun := AddMonoidHom.toMultiplicative'.symm f.symm.toMonoidHom\n    left_inv := f.left_inv\n    right_inv := f.right_inv\n    map_add' := map_mul f }\n  left_inv x := by ext; rfl\n  right_inv x := by ext; rfl\n\n"}
{"name":"AddEquiv.toMultiplicative''_symm_apply_apply","module":"Mathlib.Algebra.Group.Equiv.TypeTags","initialProofState":"G : Type u_2\nH : Type u_3\ninst✝¹ : AddZeroClass G\ninst✝ : MulOneClass H\nf : MulEquiv (Multiplicative G) H\na : G\n⊢ Eq ((AddEquiv.toMultiplicative''.symm f) a) ((AddMonoidHom.toMultiplicative''.symm f.toMonoidHom) a)","decl":"/-- Reinterpret `G ≃+ Additive H` as `Multiplicative G ≃* H`. -/\n@[simps]\ndef AddEquiv.toMultiplicative'' [AddZeroClass G] [MulOneClass H] :\n    G ≃+ Additive H ≃ (Multiplicative G ≃* H) where\n  toFun f :=\n  { toFun := AddMonoidHom.toMultiplicative'' f.toAddMonoidHom\n    invFun := AddMonoidHom.toMultiplicative' f.symm.toAddMonoidHom\n    left_inv := f.left_inv\n    right_inv := f.right_inv\n    map_mul' := map_add f }\n  invFun f :=\n  { toFun := AddMonoidHom.toMultiplicative''.symm f.toMonoidHom\n    invFun := AddMonoidHom.toMultiplicative'.symm f.symm.toMonoidHom\n    left_inv := f.left_inv\n    right_inv := f.right_inv\n    map_add' := map_mul f }\n  left_inv x := by ext; rfl\n  right_inv x := by ext; rfl\n\n"}
{"name":"AddEquiv.toMultiplicative''_apply_symm_apply","module":"Mathlib.Algebra.Group.Equiv.TypeTags","initialProofState":"G : Type u_2\nH : Type u_3\ninst✝¹ : AddZeroClass G\ninst✝ : MulOneClass H\nf : AddEquiv G (Additive H)\na : H\n⊢ Eq ((AddEquiv.toMultiplicative'' f).symm a) ((AddMonoidHom.toMultiplicative' f.symm.toAddMonoidHom) a)","decl":"/-- Reinterpret `G ≃+ Additive H` as `Multiplicative G ≃* H`. -/\n@[simps]\ndef AddEquiv.toMultiplicative'' [AddZeroClass G] [MulOneClass H] :\n    G ≃+ Additive H ≃ (Multiplicative G ≃* H) where\n  toFun f :=\n  { toFun := AddMonoidHom.toMultiplicative'' f.toAddMonoidHom\n    invFun := AddMonoidHom.toMultiplicative' f.symm.toAddMonoidHom\n    left_inv := f.left_inv\n    right_inv := f.right_inv\n    map_mul' := map_add f }\n  invFun f :=\n  { toFun := AddMonoidHom.toMultiplicative''.symm f.toMonoidHom\n    invFun := AddMonoidHom.toMultiplicative'.symm f.symm.toMonoidHom\n    left_inv := f.left_inv\n    right_inv := f.right_inv\n    map_add' := map_mul f }\n  left_inv x := by ext; rfl\n  right_inv x := by ext; rfl\n\n"}
{"name":"AddEquiv.toMultiplicative''_symm_apply_symm_apply","module":"Mathlib.Algebra.Group.Equiv.TypeTags","initialProofState":"G : Type u_2\nH : Type u_3\ninst✝¹ : AddZeroClass G\ninst✝ : MulOneClass H\nf : MulEquiv (Multiplicative G) H\na : Additive H\n⊢ Eq ((AddEquiv.toMultiplicative''.symm f).symm a) ((AddMonoidHom.toMultiplicative'.symm f.symm.toMonoidHom) a)","decl":"/-- Reinterpret `G ≃+ Additive H` as `Multiplicative G ≃* H`. -/\n@[simps]\ndef AddEquiv.toMultiplicative'' [AddZeroClass G] [MulOneClass H] :\n    G ≃+ Additive H ≃ (Multiplicative G ≃* H) where\n  toFun f :=\n  { toFun := AddMonoidHom.toMultiplicative'' f.toAddMonoidHom\n    invFun := AddMonoidHom.toMultiplicative' f.symm.toAddMonoidHom\n    left_inv := f.left_inv\n    right_inv := f.right_inv\n    map_mul' := map_add f }\n  invFun f :=\n  { toFun := AddMonoidHom.toMultiplicative''.symm f.toMonoidHom\n    invFun := AddMonoidHom.toMultiplicative'.symm f.symm.toMonoidHom\n    left_inv := f.left_inv\n    right_inv := f.right_inv\n    map_add' := map_mul f }\n  left_inv x := by ext; rfl\n  right_inv x := by ext; rfl\n\n"}
{"name":"monoidEndToAdditive_apply_apply","module":"Mathlib.Algebra.Group.Equiv.TypeTags","initialProofState":"M : Type u_4\ninst✝ : MulOneClass M\nf : MonoidHom M M\na : Additive M\n⊢ Eq (((monoidEndToAdditive M) f) a) (Additive.ofMul (f (Additive.toMul a)))","decl":"/-- Multiplicative equivalence between multiplicative endomorphisms of a `MulOneClass` `M`\nand additive endomorphisms of `Additive M`. -/\n@[simps!] def monoidEndToAdditive (M : Type*) [MulOneClass M] :\n    Monoid.End M ≃* AddMonoid.End (Additive M) :=\n  { MonoidHom.toAdditive with\n    map_mul' := fun _ _ => rfl }\n\n"}
{"name":"monoidEndToAdditive_symm_apply_apply","module":"Mathlib.Algebra.Group.Equiv.TypeTags","initialProofState":"M : Type u_4\ninst✝ : MulOneClass M\nf : AddMonoidHom (Additive M) (Additive M)\na : M\n⊢ Eq (((monoidEndToAdditive M).symm f) a) (Additive.toMul (f (Additive.ofMul a)))","decl":"/-- Multiplicative equivalence between multiplicative endomorphisms of a `MulOneClass` `M`\nand additive endomorphisms of `Additive M`. -/\n@[simps!] def monoidEndToAdditive (M : Type*) [MulOneClass M] :\n    Monoid.End M ≃* AddMonoid.End (Additive M) :=\n  { MonoidHom.toAdditive with\n    map_mul' := fun _ _ => rfl }\n\n"}
{"name":"addMonoidEndToMultiplicative_symm_apply_apply","module":"Mathlib.Algebra.Group.Equiv.TypeTags","initialProofState":"A : Type u_4\ninst✝ : AddZeroClass A\nf : MonoidHom (Multiplicative A) (Multiplicative A)\na : A\n⊢ Eq (((addMonoidEndToMultiplicative A).symm f) a) (Multiplicative.toAdd (f (Multiplicative.ofAdd a)))","decl":"/-- Multiplicative equivalence between additive endomorphisms of an `AddZeroClass` `A`\nand multiplicative endomorphisms of `Multiplicative A`. -/\n@[simps!] def addMonoidEndToMultiplicative (A : Type*) [AddZeroClass A] :\n    AddMonoid.End A ≃* Monoid.End (Multiplicative A) :=\n  { AddMonoidHom.toMultiplicative with\n    map_mul' := fun _ _ => rfl }\n\n"}
{"name":"addMonoidEndToMultiplicative_apply_apply","module":"Mathlib.Algebra.Group.Equiv.TypeTags","initialProofState":"A : Type u_4\ninst✝ : AddZeroClass A\nf : AddMonoidHom A A\na : Multiplicative A\n⊢ Eq (((addMonoidEndToMultiplicative A) f) a) (Multiplicative.ofAdd (f (Multiplicative.toAdd a)))","decl":"/-- Multiplicative equivalence between additive endomorphisms of an `AddZeroClass` `A`\nand multiplicative endomorphisms of `Multiplicative A`. -/\n@[simps!] def addMonoidEndToMultiplicative (A : Type*) [AddZeroClass A] :\n    AddMonoid.End A ≃* Monoid.End (Multiplicative A) :=\n  { AddMonoidHom.toMultiplicative with\n    map_mul' := fun _ _ => rfl }\n\n"}
{"name":"MulEquiv.piMultiplicative_symm_apply","module":"Mathlib.Algebra.Group.Equiv.TypeTags","initialProofState":"ι : Type u_1\nK : ι → Type u_4\ninst✝ : (i : ι) → Add (K i)\nx : (i : ι) → Multiplicative (K i)\n⊢ Eq ((MulEquiv.piMultiplicative K).symm x) (Multiplicative.ofAdd fun i => Multiplicative.toAdd (x i))","decl":"/-- `Multiplicative (∀ i : ι, K i)` is equivalent to `∀ i : ι, Multiplicative (K i)`. -/\n@[simps]\ndef MulEquiv.piMultiplicative (K : ι → Type*) [∀ i, Add (K i)] :\n    Multiplicative (∀ i : ι, K i) ≃* (∀ i : ι, Multiplicative (K i)) where\n  toFun x := fun i ↦ Multiplicative.ofAdd <| x.toAdd i\n  invFun x := Multiplicative.ofAdd fun i ↦ (x i).toAdd\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"MulEquiv.piMultiplicative_apply","module":"Mathlib.Algebra.Group.Equiv.TypeTags","initialProofState":"ι : Type u_1\nK : ι → Type u_4\ninst✝ : (i : ι) → Add (K i)\nx : Multiplicative ((i : ι) → K i)\ni : ι\n⊢ Eq ((MulEquiv.piMultiplicative K) x i) (Multiplicative.ofAdd (Multiplicative.toAdd x i))","decl":"/-- `Multiplicative (∀ i : ι, K i)` is equivalent to `∀ i : ι, Multiplicative (K i)`. -/\n@[simps]\ndef MulEquiv.piMultiplicative (K : ι → Type*) [∀ i, Add (K i)] :\n    Multiplicative (∀ i : ι, K i) ≃* (∀ i : ι, Multiplicative (K i)) where\n  toFun x := fun i ↦ Multiplicative.ofAdd <| x.toAdd i\n  invFun x := Multiplicative.ofAdd fun i ↦ (x i).toAdd\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"AddEquiv.piAdditive_apply","module":"Mathlib.Algebra.Group.Equiv.TypeTags","initialProofState":"ι : Type u_1\nK : ι → Type u_4\ninst✝ : (i : ι) → Mul (K i)\nx : Additive ((i : ι) → K i)\ni : ι\n⊢ Eq ((AddEquiv.piAdditive K) x i) (Additive.ofMul (Additive.toMul x i))","decl":"/-- `Additive (∀ i : ι, K i)` is equivalent to `∀ i : ι, Additive (K i)`. -/\n@[simps]\ndef AddEquiv.piAdditive (K : ι → Type*) [∀ i, Mul (K i)] :\n    Additive (∀ i : ι, K i) ≃+ (∀ i : ι, Additive (K i)) where\n  toFun x := fun i ↦ Additive.ofMul <| x.toMul i\n  invFun x := Additive.ofMul fun i ↦ (x i).toMul\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_add' _ _ := rfl\n\n"}
{"name":"AddEquiv.piAdditive_symm_apply","module":"Mathlib.Algebra.Group.Equiv.TypeTags","initialProofState":"ι : Type u_1\nK : ι → Type u_4\ninst✝ : (i : ι) → Mul (K i)\nx : (i : ι) → Additive (K i)\n⊢ Eq ((AddEquiv.piAdditive K).symm x) (Additive.ofMul fun i => Additive.toMul (x i))","decl":"/-- `Additive (∀ i : ι, K i)` is equivalent to `∀ i : ι, Additive (K i)`. -/\n@[simps]\ndef AddEquiv.piAdditive (K : ι → Type*) [∀ i, Mul (K i)] :\n    Additive (∀ i : ι, K i) ≃+ (∀ i : ι, Additive (K i)) where\n  toFun x := fun i ↦ Additive.ofMul <| x.toMul i\n  invFun x := Additive.ofMul fun i ↦ (x i).toMul\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_add' _ _ := rfl\n\n"}
{"name":"AddEquiv.additiveMultiplicative_symm_apply","module":"Mathlib.Algebra.Group.Equiv.TypeTags","initialProofState":"G : Type u_2\ninst✝ : AddZeroClass G\na : G\n⊢ Eq ((AddEquiv.additiveMultiplicative G).symm a) (Additive.ofMul (Multiplicative.ofAdd a))","decl":"/-- `Additive (Multiplicative G)` is just `G`. -/\n@[simps!]\ndef AddEquiv.additiveMultiplicative [AddZeroClass G] : Additive (Multiplicative G) ≃+ G :=\n  MulEquiv.toAdditive' (MulEquiv.refl (Multiplicative G))\n\n"}
{"name":"AddEquiv.additiveMultiplicative_apply","module":"Mathlib.Algebra.Group.Equiv.TypeTags","initialProofState":"G : Type u_2\ninst✝ : AddZeroClass G\na : Additive (Multiplicative G)\n⊢ Eq ((AddEquiv.additiveMultiplicative G) a) (Multiplicative.toAdd (Additive.toMul a))","decl":"/-- `Additive (Multiplicative G)` is just `G`. -/\n@[simps!]\ndef AddEquiv.additiveMultiplicative [AddZeroClass G] : Additive (Multiplicative G) ≃+ G :=\n  MulEquiv.toAdditive' (MulEquiv.refl (Multiplicative G))\n\n"}
{"name":"MulEquiv.multiplicativeAdditive_symm_apply","module":"Mathlib.Algebra.Group.Equiv.TypeTags","initialProofState":"H : Type u_3\ninst✝ : MulOneClass H\na : H\n⊢ Eq ((MulEquiv.multiplicativeAdditive H).symm a) (Multiplicative.ofAdd (Additive.ofMul a))","decl":"/-- `Multiplicative (Additive H)` is just `H`. -/\n@[simps!]\ndef MulEquiv.multiplicativeAdditive [MulOneClass H] : Multiplicative (Additive H) ≃* H :=\n  AddEquiv.toMultiplicative'' (AddEquiv.refl (Additive H))\n\n"}
{"name":"MulEquiv.multiplicativeAdditive_apply","module":"Mathlib.Algebra.Group.Equiv.TypeTags","initialProofState":"H : Type u_3\ninst✝ : MulOneClass H\na : Multiplicative (Additive H)\n⊢ Eq ((MulEquiv.multiplicativeAdditive H) a) (Additive.toMul (Multiplicative.toAdd a))","decl":"/-- `Multiplicative (Additive H)` is just `H`. -/\n@[simps!]\ndef MulEquiv.multiplicativeAdditive [MulOneClass H] : Multiplicative (Additive H) ≃* H :=\n  AddEquiv.toMultiplicative'' (AddEquiv.refl (Additive H))\n\n"}
{"name":"MulEquiv.prodMultiplicative_symm_apply","module":"Mathlib.Algebra.Group.Equiv.TypeTags","initialProofState":"G : Type u_2\nH : Type u_3\ninst✝¹ : Add G\ninst✝ : Add H\nx✝ : Prod (Multiplicative G) (Multiplicative H)\n⊢ Eq ((MulEquiv.prodMultiplicative G H).symm x✝) (MulEquiv.prodMultiplicative.match_1 G H (fun x => Multiplicative (Prod G H)) x✝ fun x y => Multiplicative.ofAdd { fst := Multiplicative.toAdd x, snd := Multiplicative.toAdd y })","decl":"/-- `Multiplicative (G × H)` is equivalent to `Multiplicative G × Multiplicative H`. -/\n@[simps]\ndef MulEquiv.prodMultiplicative [Add G] [Add H] :\n    Multiplicative (G × H) ≃* Multiplicative G × Multiplicative H where\n  toFun x := (Multiplicative.ofAdd x.toAdd.1,\n    Multiplicative.ofAdd x.toAdd.2)\n  invFun := fun (x, y) ↦ Multiplicative.ofAdd (x.toAdd, y.toAdd)\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"MulEquiv.prodMultiplicative_apply","module":"Mathlib.Algebra.Group.Equiv.TypeTags","initialProofState":"G : Type u_2\nH : Type u_3\ninst✝¹ : Add G\ninst✝ : Add H\nx : Multiplicative (Prod G H)\n⊢ Eq ((MulEquiv.prodMultiplicative G H) x) { fst := Multiplicative.ofAdd (Multiplicative.toAdd x).1, snd := Multiplicative.ofAdd (Multiplicative.toAdd x).2 }","decl":"/-- `Multiplicative (G × H)` is equivalent to `Multiplicative G × Multiplicative H`. -/\n@[simps]\ndef MulEquiv.prodMultiplicative [Add G] [Add H] :\n    Multiplicative (G × H) ≃* Multiplicative G × Multiplicative H where\n  toFun x := (Multiplicative.ofAdd x.toAdd.1,\n    Multiplicative.ofAdd x.toAdd.2)\n  invFun := fun (x, y) ↦ Multiplicative.ofAdd (x.toAdd, y.toAdd)\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"AddEquiv.prodAdditive_apply","module":"Mathlib.Algebra.Group.Equiv.TypeTags","initialProofState":"G : Type u_2\nH : Type u_3\ninst✝¹ : Mul G\ninst✝ : Mul H\nx : Additive (Prod G H)\n⊢ Eq ((AddEquiv.prodAdditive G H) x) { fst := Additive.ofMul (Additive.toMul x).1, snd := Additive.ofMul (Additive.toMul x).2 }","decl":"/-- `Additive (G × H)` is equivalent to `Additive G × Additive H`. -/\n@[simps]\ndef AddEquiv.prodAdditive [Mul G] [Mul H] :\n    Additive (G × H) ≃+ Additive G × Additive H where\n  toFun x := (Additive.ofMul x.toMul.1,\n    Additive.ofMul x.toMul.2)\n  invFun := fun (x, y) ↦ Additive.ofMul (x.toMul, y.toMul)\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_add' _ _ := rfl\n\n"}
{"name":"AddEquiv.prodAdditive_symm_apply","module":"Mathlib.Algebra.Group.Equiv.TypeTags","initialProofState":"G : Type u_2\nH : Type u_3\ninst✝¹ : Mul G\ninst✝ : Mul H\nx✝ : Prod (Additive G) (Additive H)\n⊢ Eq ((AddEquiv.prodAdditive G H).symm x✝) (AddEquiv.prodAdditive.match_1 G H (fun x => Additive (Prod G H)) x✝ fun x y => Additive.ofMul { fst := Additive.toMul x, snd := Additive.toMul y })","decl":"/-- `Additive (G × H)` is equivalent to `Additive G × Additive H`. -/\n@[simps]\ndef AddEquiv.prodAdditive [Mul G] [Mul H] :\n    Additive (G × H) ≃+ Additive G × Additive H where\n  toFun x := (Additive.ofMul x.toMul.1,\n    Additive.ofMul x.toMul.2)\n  invFun := fun (x, y) ↦ Additive.ofMul (x.toMul, y.toMul)\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_add' _ _ := rfl\n\n"}
