{"name":"mem_intrinsicInterior","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : Module ğ•œ V\ninstâœÂ¹ : TopologicalSpace P\ninstâœ : AddTorsor V P\ns : Set P\nx : P\nâŠ¢ Iff (Membership.mem (intrinsicInterior ğ•œ s) x) (Exists fun y => And (Membership.mem (interior (Set.preimage Subtype.val s)) y) (Eq (â†‘y) x))","decl":"@[simp]\ntheorem mem_intrinsicInterior :\n    x âˆˆ intrinsicInterior ğ•œ s â†” âˆƒ y, y âˆˆ interior ((â†‘) â»Â¹' s : Set <| affineSpan ğ•œ s) âˆ§ â†‘y = x :=\n  mem_image _ _ _\n\n"}
{"name":"mem_intrinsicFrontier","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : Module ğ•œ V\ninstâœÂ¹ : TopologicalSpace P\ninstâœ : AddTorsor V P\ns : Set P\nx : P\nâŠ¢ Iff (Membership.mem (intrinsicFrontier ğ•œ s) x) (Exists fun y => And (Membership.mem (frontier (Set.preimage Subtype.val s)) y) (Eq (â†‘y) x))","decl":"@[simp]\ntheorem mem_intrinsicFrontier :\n    x âˆˆ intrinsicFrontier ğ•œ s â†” âˆƒ y, y âˆˆ frontier ((â†‘) â»Â¹' s : Set <| affineSpan ğ•œ s) âˆ§ â†‘y = x :=\n  mem_image _ _ _\n\n"}
{"name":"mem_intrinsicClosure","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : Module ğ•œ V\ninstâœÂ¹ : TopologicalSpace P\ninstâœ : AddTorsor V P\ns : Set P\nx : P\nâŠ¢ Iff (Membership.mem (intrinsicClosure ğ•œ s) x) (Exists fun y => And (Membership.mem (closure (Set.preimage Subtype.val s)) y) (Eq (â†‘y) x))","decl":"@[simp]\ntheorem mem_intrinsicClosure :\n    x âˆˆ intrinsicClosure ğ•œ s â†” âˆƒ y, y âˆˆ closure ((â†‘) â»Â¹' s : Set <| affineSpan ğ•œ s) âˆ§ â†‘y = x :=\n  mem_image _ _ _\n\n"}
{"name":"intrinsicInterior_subset","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : Module ğ•œ V\ninstâœÂ¹ : TopologicalSpace P\ninstâœ : AddTorsor V P\ns : Set P\nâŠ¢ HasSubset.Subset (intrinsicInterior ğ•œ s) s","decl":"theorem intrinsicInterior_subset : intrinsicInterior ğ•œ s âŠ† s :=\n  image_subset_iff.2 interior_subset\n\n"}
{"name":"intrinsicFrontier_subset","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : Module ğ•œ V\ninstâœÂ¹ : TopologicalSpace P\ninstâœ : AddTorsor V P\ns : Set P\nhs : IsClosed s\nâŠ¢ HasSubset.Subset (intrinsicFrontier ğ•œ s) s","decl":"theorem intrinsicFrontier_subset (hs : IsClosed s) : intrinsicFrontier ğ•œ s âŠ† s :=\n  image_subset_iff.2 (hs.preimage continuous_induced_dom).frontier_subset\n\n"}
{"name":"intrinsicFrontier_subset_intrinsicClosure","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : Module ğ•œ V\ninstâœÂ¹ : TopologicalSpace P\ninstâœ : AddTorsor V P\ns : Set P\nâŠ¢ HasSubset.Subset (intrinsicFrontier ğ•œ s) (intrinsicClosure ğ•œ s)","decl":"theorem intrinsicFrontier_subset_intrinsicClosure : intrinsicFrontier ğ•œ s âŠ† intrinsicClosure ğ•œ s :=\n  image_subset _ frontier_subset_closure\n\n"}
{"name":"subset_intrinsicClosure","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : Module ğ•œ V\ninstâœÂ¹ : TopologicalSpace P\ninstâœ : AddTorsor V P\ns : Set P\nâŠ¢ HasSubset.Subset s (intrinsicClosure ğ•œ s)","decl":"theorem subset_intrinsicClosure : s âŠ† intrinsicClosure ğ•œ s :=\n  fun x hx => âŸ¨âŸ¨x, subset_affineSpan _ _ hxâŸ©, subset_closure hx, rflâŸ©\n\n"}
{"name":"intrinsicInterior_empty","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : Module ğ•œ V\ninstâœÂ¹ : TopologicalSpace P\ninstâœ : AddTorsor V P\nâŠ¢ Eq (intrinsicInterior ğ•œ EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem intrinsicInterior_empty : intrinsicInterior ğ•œ (âˆ… : Set P) = âˆ… := by simp [intrinsicInterior]\n\n"}
{"name":"intrinsicFrontier_empty","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : Module ğ•œ V\ninstâœÂ¹ : TopologicalSpace P\ninstâœ : AddTorsor V P\nâŠ¢ Eq (intrinsicFrontier ğ•œ EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem intrinsicFrontier_empty : intrinsicFrontier ğ•œ (âˆ… : Set P) = âˆ… := by simp [intrinsicFrontier]\n\n"}
{"name":"intrinsicClosure_empty","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : Module ğ•œ V\ninstâœÂ¹ : TopologicalSpace P\ninstâœ : AddTorsor V P\nâŠ¢ Eq (intrinsicClosure ğ•œ EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem intrinsicClosure_empty : intrinsicClosure ğ•œ (âˆ… : Set P) = âˆ… := by simp [intrinsicClosure]\n\n"}
{"name":"intrinsicClosure_nonempty","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : Module ğ•œ V\ninstâœÂ¹ : TopologicalSpace P\ninstâœ : AddTorsor V P\ns : Set P\nâŠ¢ Iff (intrinsicClosure ğ•œ s).Nonempty s.Nonempty","decl":"@[simp]\ntheorem intrinsicClosure_nonempty : (intrinsicClosure ğ•œ s).Nonempty â†” s.Nonempty :=\n  âŸ¨by simp_rw [nonempty_iff_ne_empty]; rintro h rfl; exact h intrinsicClosure_empty,\n    Nonempty.mono subset_intrinsicClosureâŸ©\n\n"}
{"name":"Set.Nonempty.ofIntrinsicClosure","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : Module ğ•œ V\ninstâœÂ¹ : TopologicalSpace P\ninstâœ : AddTorsor V P\ns : Set P\naâœ : (intrinsicClosure ğ•œ s).Nonempty\nâŠ¢ s.Nonempty","decl":"alias âŸ¨Set.Nonempty.ofIntrinsicClosure, Set.Nonempty.intrinsicClosureâŸ© := intrinsicClosure_nonempty\n\n--attribute [protected] Set.Nonempty.intrinsicClosure -- Porting note: removed\n\n"}
{"name":"Set.Nonempty.intrinsicClosure","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : Module ğ•œ V\ninstâœÂ¹ : TopologicalSpace P\ninstâœ : AddTorsor V P\ns : Set P\naâœ : s.Nonempty\nâŠ¢ (intrinsicClosure ğ•œ s).Nonempty","decl":"alias âŸ¨Set.Nonempty.ofIntrinsicClosure, Set.Nonempty.intrinsicClosureâŸ© := intrinsicClosure_nonempty\n\n--attribute [protected] Set.Nonempty.intrinsicClosure -- Porting note: removed\n\n"}
{"name":"intrinsicInterior_singleton","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : Module ğ•œ V\ninstâœÂ¹ : TopologicalSpace P\ninstâœ : AddTorsor V P\nx : P\nâŠ¢ Eq (intrinsicInterior ğ•œ (Singleton.singleton x)) (Singleton.singleton x)","decl":"@[simp]\ntheorem intrinsicInterior_singleton (x : P) : intrinsicInterior ğ•œ ({x} : Set P) = {x} := by\n  simp only [intrinsicInterior, preimage_coe_affineSpan_singleton, interior_univ, image_univ,\n    Subtype.range_coe_subtype, mem_affineSpan_singleton, setOf_eq_eq_singleton]\n\n"}
{"name":"intrinsicFrontier_singleton","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : Module ğ•œ V\ninstâœÂ¹ : TopologicalSpace P\ninstâœ : AddTorsor V P\nx : P\nâŠ¢ Eq (intrinsicFrontier ğ•œ (Singleton.singleton x)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem intrinsicFrontier_singleton (x : P) : intrinsicFrontier ğ•œ ({x} : Set P) = âˆ… := by\n  rw [intrinsicFrontier, preimage_coe_affineSpan_singleton, frontier_univ, image_empty]\n\n"}
{"name":"intrinsicClosure_singleton","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : Module ğ•œ V\ninstâœÂ¹ : TopologicalSpace P\ninstâœ : AddTorsor V P\nx : P\nâŠ¢ Eq (intrinsicClosure ğ•œ (Singleton.singleton x)) (Singleton.singleton x)","decl":"@[simp]\ntheorem intrinsicClosure_singleton (x : P) : intrinsicClosure ğ•œ ({x} : Set P) = {x} := by\n  simp only [intrinsicClosure, preimage_coe_affineSpan_singleton, closure_univ, image_univ,\n    Subtype.range_coe_subtype, mem_affineSpan_singleton, setOf_eq_eq_singleton]\n\n"}
{"name":"intrinsicClosure_mono","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : Module ğ•œ V\ninstâœÂ¹ : TopologicalSpace P\ninstâœ : AddTorsor V P\ns t : Set P\nh : HasSubset.Subset s t\nâŠ¢ HasSubset.Subset (intrinsicClosure ğ•œ s) (intrinsicClosure ğ•œ t)","decl":"theorem intrinsicClosure_mono (h : s âŠ† t) : intrinsicClosure ğ•œ s âŠ† intrinsicClosure ğ•œ t := by\n  refine image_subset_iff.2 fun x hx => ?_\n  refine âŸ¨Set.inclusion (affineSpan_mono _ h) x, ?_, rflâŸ©\n  refine (continuous_inclusion (affineSpan_mono _ h)).closure_preimage_subset _ (closure_mono ?_ hx)\n  exact fun y hy => h hy\n\n"}
{"name":"interior_subset_intrinsicInterior","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : Module ğ•œ V\ninstâœÂ¹ : TopologicalSpace P\ninstâœ : AddTorsor V P\ns : Set P\nâŠ¢ HasSubset.Subset (interior s) (intrinsicInterior ğ•œ s)","decl":"theorem interior_subset_intrinsicInterior : interior s âŠ† intrinsicInterior ğ•œ s :=\n  fun x hx => âŸ¨âŸ¨x, subset_affineSpan _ _ <| interior_subset hxâŸ©,\n    preimage_interior_subset_interior_preimage continuous_subtype_val hx, rflâŸ©\n\n"}
{"name":"intrinsicClosure_subset_closure","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : Module ğ•œ V\ninstâœÂ¹ : TopologicalSpace P\ninstâœ : AddTorsor V P\ns : Set P\nâŠ¢ HasSubset.Subset (intrinsicClosure ğ•œ s) (closure s)","decl":"theorem intrinsicClosure_subset_closure : intrinsicClosure ğ•œ s âŠ† closure s :=\n  image_subset_iff.2 <| continuous_subtype_val.closure_preimage_subset _\n\n"}
{"name":"intrinsicFrontier_subset_frontier","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : Module ğ•œ V\ninstâœÂ¹ : TopologicalSpace P\ninstâœ : AddTorsor V P\ns : Set P\nâŠ¢ HasSubset.Subset (intrinsicFrontier ğ•œ s) (frontier s)","decl":"theorem intrinsicFrontier_subset_frontier : intrinsicFrontier ğ•œ s âŠ† frontier s :=\n  image_subset_iff.2 <| continuous_subtype_val.frontier_preimage_subset _\n\n"}
{"name":"intrinsicClosure_subset_affineSpan","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : Module ğ•œ V\ninstâœÂ¹ : TopologicalSpace P\ninstâœ : AddTorsor V P\ns : Set P\nâŠ¢ HasSubset.Subset (intrinsicClosure ğ•œ s) â†‘(affineSpan ğ•œ s)","decl":"theorem intrinsicClosure_subset_affineSpan : intrinsicClosure ğ•œ s âŠ† affineSpan ğ•œ s :=\n  (image_subset_range _ _).trans Subtype.range_coe.subset\n\n"}
{"name":"intrinsicClosure_diff_intrinsicFrontier","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : Module ğ•œ V\ninstâœÂ¹ : TopologicalSpace P\ninstâœ : AddTorsor V P\ns : Set P\nâŠ¢ Eq (SDiff.sdiff (intrinsicClosure ğ•œ s) (intrinsicFrontier ğ•œ s)) (intrinsicInterior ğ•œ s)","decl":"@[simp]\ntheorem intrinsicClosure_diff_intrinsicFrontier (s : Set P) :\n    intrinsicClosure ğ•œ s \\ intrinsicFrontier ğ•œ s = intrinsicInterior ğ•œ s :=\n  (image_diff Subtype.coe_injective _ _).symm.trans <| by\n    rw [closure_diff_frontier, intrinsicInterior]\n\n"}
{"name":"intrinsicClosure_diff_intrinsicInterior","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : Module ğ•œ V\ninstâœÂ¹ : TopologicalSpace P\ninstâœ : AddTorsor V P\ns : Set P\nâŠ¢ Eq (SDiff.sdiff (intrinsicClosure ğ•œ s) (intrinsicInterior ğ•œ s)) (intrinsicFrontier ğ•œ s)","decl":"@[simp]\ntheorem intrinsicClosure_diff_intrinsicInterior (s : Set P) :\n    intrinsicClosure ğ•œ s \\ intrinsicInterior ğ•œ s = intrinsicFrontier ğ•œ s :=\n  (image_diff Subtype.coe_injective _ _).symm\n\n"}
{"name":"intrinsicInterior_union_intrinsicFrontier","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : Module ğ•œ V\ninstâœÂ¹ : TopologicalSpace P\ninstâœ : AddTorsor V P\ns : Set P\nâŠ¢ Eq (Union.union (intrinsicInterior ğ•œ s) (intrinsicFrontier ğ•œ s)) (intrinsicClosure ğ•œ s)","decl":"@[simp]\ntheorem intrinsicInterior_union_intrinsicFrontier (s : Set P) :\n    intrinsicInterior ğ•œ s âˆª intrinsicFrontier ğ•œ s = intrinsicClosure ğ•œ s := by\n  simp [intrinsicClosure, intrinsicInterior, intrinsicFrontier, closure_eq_interior_union_frontier,\n    image_union]\n\n"}
{"name":"intrinsicFrontier_union_intrinsicInterior","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : Module ğ•œ V\ninstâœÂ¹ : TopologicalSpace P\ninstâœ : AddTorsor V P\ns : Set P\nâŠ¢ Eq (Union.union (intrinsicFrontier ğ•œ s) (intrinsicInterior ğ•œ s)) (intrinsicClosure ğ•œ s)","decl":"@[simp]\ntheorem intrinsicFrontier_union_intrinsicInterior (s : Set P) :\n    intrinsicFrontier ğ•œ s âˆª intrinsicInterior ğ•œ s = intrinsicClosure ğ•œ s := by\n  rw [union_comm, intrinsicInterior_union_intrinsicFrontier]\n\n"}
{"name":"isClosed_intrinsicClosure","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : Module ğ•œ V\ninstâœÂ¹ : TopologicalSpace P\ninstâœ : AddTorsor V P\ns : Set P\nhs : IsClosed â†‘(affineSpan ğ•œ s)\nâŠ¢ IsClosed (intrinsicClosure ğ•œ s)","decl":"theorem isClosed_intrinsicClosure (hs : IsClosed (affineSpan ğ•œ s : Set P)) :\n    IsClosed (intrinsicClosure ğ•œ s) :=\n  hs.isClosedEmbedding_subtypeVal.isClosedMap _ isClosed_closure\n\n"}
{"name":"isClosed_intrinsicFrontier","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : Module ğ•œ V\ninstâœÂ¹ : TopologicalSpace P\ninstâœ : AddTorsor V P\ns : Set P\nhs : IsClosed â†‘(affineSpan ğ•œ s)\nâŠ¢ IsClosed (intrinsicFrontier ğ•œ s)","decl":"theorem isClosed_intrinsicFrontier (hs : IsClosed (affineSpan ğ•œ s : Set P)) :\n    IsClosed (intrinsicFrontier ğ•œ s) :=\n  hs.isClosedEmbedding_subtypeVal.isClosedMap _ isClosed_frontier\n\n"}
{"name":"affineSpan_intrinsicClosure","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : Module ğ•œ V\ninstâœÂ¹ : TopologicalSpace P\ninstâœ : AddTorsor V P\ns : Set P\nâŠ¢ Eq (affineSpan ğ•œ (intrinsicClosure ğ•œ s)) (affineSpan ğ•œ s)","decl":"@[simp]\ntheorem affineSpan_intrinsicClosure (s : Set P) :\n    affineSpan ğ•œ (intrinsicClosure ğ•œ s) = affineSpan ğ•œ s :=\n  (affineSpan_le.2 intrinsicClosure_subset_affineSpan).antisymm <|\n    affineSpan_mono _ subset_intrinsicClosure\n\n"}
{"name":"IsClosed.intrinsicClosure","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : Module ğ•œ V\ninstâœÂ¹ : TopologicalSpace P\ninstâœ : AddTorsor V P\ns : Set P\nhs : IsClosed (Set.preimage Subtype.val s)\nâŠ¢ Eq (intrinsicClosure ğ•œ s) s","decl":"protected theorem IsClosed.intrinsicClosure (hs : IsClosed ((â†‘) â»Â¹' s : Set <| affineSpan ğ•œ s)) :\n    intrinsicClosure ğ•œ s = s := by\n  rw [intrinsicClosure, hs.closure_eq, image_preimage_eq_of_subset]\n  exact (subset_affineSpan _ _).trans Subtype.range_coe.superset\n\n"}
{"name":"intrinsicClosure_idem","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : Module ğ•œ V\ninstâœÂ¹ : TopologicalSpace P\ninstâœ : AddTorsor V P\ns : Set P\nâŠ¢ Eq (intrinsicClosure ğ•œ (intrinsicClosure ğ•œ s)) (intrinsicClosure ğ•œ s)","decl":"@[simp]\ntheorem intrinsicClosure_idem (s : Set P) :\n    intrinsicClosure ğ•œ (intrinsicClosure ğ•œ s) = intrinsicClosure ğ•œ s := by\n  refine IsClosed.intrinsicClosure ?_\n  set t := affineSpan ğ•œ (intrinsicClosure ğ•œ s) with ht\n  clear_value t\n  obtain rfl := ht.trans (affineSpan_intrinsicClosure _)\n  rw [intrinsicClosure, preimage_image_eq _ Subtype.coe_injective]\n  exact isClosed_closure\n\n"}
{"name":"AffineIsometry.image_intrinsicInterior","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nW : Type u_3\nQ : Type u_4\nP : Type u_5\ninstâœâ¸ : NormedField ğ•œ\ninstâœâ· : SeminormedAddCommGroup V\ninstâœâ¶ : SeminormedAddCommGroup W\ninstâœâµ : NormedSpace ğ•œ V\ninstâœâ´ : NormedSpace ğ•œ W\ninstâœÂ³ : MetricSpace P\ninstâœÂ² : PseudoMetricSpace Q\ninstâœÂ¹ : NormedAddTorsor V P\ninstâœ : NormedAddTorsor W Q\nÏ† : AffineIsometry ğ•œ P Q\ns : Set P\nâŠ¢ Eq (intrinsicInterior ğ•œ (Set.image (â‡‘Ï†) s)) (Set.image (â‡‘Ï†) (intrinsicInterior ğ•œ s))","decl":"@[simp]\ntheorem image_intrinsicInterior (Ï† : P â†’áµƒâ±[ğ•œ] Q) (s : Set P) :\n    intrinsicInterior ğ•œ (Ï† '' s) = Ï† '' intrinsicInterior ğ•œ s := by\n  obtain rfl | hs := s.eq_empty_or_nonempty\n  Â· simp only [intrinsicInterior_empty, image_empty]\n  haveI : Nonempty s := hs.to_subtype\n  let f := ((affineSpan ğ•œ s).isometryEquivMap Ï†).toHomeomorph\n  have : Ï†.toAffineMap âˆ˜ (â†‘) âˆ˜ f.symm = (â†‘) := funext isometryEquivMap.apply_symm_apply\n  rw [intrinsicInterior, intrinsicInterior, â† Ï†.coe_toAffineMap, â† map_span Ï†.toAffineMap s, â† this,\n    â† Function.comp_assoc, image_comp, image_comp, f.symm.image_interior, f.image_symm,\n    â† preimage_comp, Function.comp_assoc, f.symm_comp_self, AffineIsometry.coe_toAffineMap,\n    Function.comp_id, preimage_comp, Ï†.injective.preimage_image]\n\n"}
{"name":"AffineIsometry.image_intrinsicFrontier","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nW : Type u_3\nQ : Type u_4\nP : Type u_5\ninstâœâ¸ : NormedField ğ•œ\ninstâœâ· : SeminormedAddCommGroup V\ninstâœâ¶ : SeminormedAddCommGroup W\ninstâœâµ : NormedSpace ğ•œ V\ninstâœâ´ : NormedSpace ğ•œ W\ninstâœÂ³ : MetricSpace P\ninstâœÂ² : PseudoMetricSpace Q\ninstâœÂ¹ : NormedAddTorsor V P\ninstâœ : NormedAddTorsor W Q\nÏ† : AffineIsometry ğ•œ P Q\ns : Set P\nâŠ¢ Eq (intrinsicFrontier ğ•œ (Set.image (â‡‘Ï†) s)) (Set.image (â‡‘Ï†) (intrinsicFrontier ğ•œ s))","decl":"@[simp]\ntheorem image_intrinsicFrontier (Ï† : P â†’áµƒâ±[ğ•œ] Q) (s : Set P) :\n    intrinsicFrontier ğ•œ (Ï† '' s) = Ï† '' intrinsicFrontier ğ•œ s := by\n  obtain rfl | hs := s.eq_empty_or_nonempty\n  Â· simp\n  haveI : Nonempty s := hs.to_subtype\n  let f := ((affineSpan ğ•œ s).isometryEquivMap Ï†).toHomeomorph\n  have : Ï†.toAffineMap âˆ˜ (â†‘) âˆ˜ f.symm = (â†‘) := funext isometryEquivMap.apply_symm_apply\n  rw [intrinsicFrontier, intrinsicFrontier, â† Ï†.coe_toAffineMap, â† map_span Ï†.toAffineMap s, â† this,\n    â† Function.comp_assoc, image_comp, image_comp, f.symm.image_frontier, f.image_symm,\n    â† preimage_comp, Function.comp_assoc, f.symm_comp_self, AffineIsometry.coe_toAffineMap,\n    Function.comp_id, preimage_comp, Ï†.injective.preimage_image]\n\n"}
{"name":"AffineIsometry.image_intrinsicClosure","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nW : Type u_3\nQ : Type u_4\nP : Type u_5\ninstâœâ¸ : NormedField ğ•œ\ninstâœâ· : SeminormedAddCommGroup V\ninstâœâ¶ : SeminormedAddCommGroup W\ninstâœâµ : NormedSpace ğ•œ V\ninstâœâ´ : NormedSpace ğ•œ W\ninstâœÂ³ : MetricSpace P\ninstâœÂ² : PseudoMetricSpace Q\ninstâœÂ¹ : NormedAddTorsor V P\ninstâœ : NormedAddTorsor W Q\nÏ† : AffineIsometry ğ•œ P Q\ns : Set P\nâŠ¢ Eq (intrinsicClosure ğ•œ (Set.image (â‡‘Ï†) s)) (Set.image (â‡‘Ï†) (intrinsicClosure ğ•œ s))","decl":"@[simp]\ntheorem image_intrinsicClosure (Ï† : P â†’áµƒâ±[ğ•œ] Q) (s : Set P) :\n    intrinsicClosure ğ•œ (Ï† '' s) = Ï† '' intrinsicClosure ğ•œ s := by\n  obtain rfl | hs := s.eq_empty_or_nonempty\n  Â· simp\n  haveI : Nonempty s := hs.to_subtype\n  let f := ((affineSpan ğ•œ s).isometryEquivMap Ï†).toHomeomorph\n  have : Ï†.toAffineMap âˆ˜ (â†‘) âˆ˜ f.symm = (â†‘) := funext isometryEquivMap.apply_symm_apply\n  rw [intrinsicClosure, intrinsicClosure, â† Ï†.coe_toAffineMap, â† map_span Ï†.toAffineMap s, â† this,\n    â† Function.comp_assoc, image_comp, image_comp, f.symm.image_closure, f.image_symm,\n    â† preimage_comp, Function.comp_assoc, f.symm_comp_self, AffineIsometry.coe_toAffineMap,\n    Function.comp_id, preimage_comp, Ï†.injective.preimage_image]\n\n"}
{"name":"intrinsicClosure_eq_closure","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : CompleteSpace ğ•œ\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : NormedSpace ğ•œ V\ninstâœÂ² : FiniteDimensional ğ•œ V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\ns : Set P\nâŠ¢ Eq (intrinsicClosure ğ•œ s) (closure s)","decl":"@[simp]\ntheorem intrinsicClosure_eq_closure : intrinsicClosure ğ•œ s = closure s := by\n  ext x\n  simp only [mem_closure_iff, mem_intrinsicClosure]\n  refine âŸ¨?_, fun h => âŸ¨âŸ¨x, _âŸ©, ?_, Subtype.coe_mk _ ?_âŸ©âŸ©\n  Â· rintro âŸ¨x, h, rflâŸ© t ht hx\n    obtain âŸ¨z, hzâ‚, hzâ‚‚âŸ© := h _ (continuous_induced_dom.isOpen_preimage t ht) hx\n    exact âŸ¨z, hzâ‚, hzâ‚‚âŸ©\n  Â· rintro _ âŸ¨t, ht, rflâŸ© hx\n    obtain âŸ¨y, hyt, hysâŸ© := h _ ht hx\n    exact âŸ¨âŸ¨_, subset_affineSpan ğ•œ s hysâŸ©, hyt, hysâŸ©\n  Â· by_contra hc\n    obtain âŸ¨z, hzâ‚, hzâ‚‚âŸ© := h _ (affineSpan ğ•œ s).closed_of_finiteDimensional.isOpen_compl hc\n    exact hzâ‚ (subset_affineSpan ğ•œ s hzâ‚‚)\n\n"}
{"name":"closure_diff_intrinsicInterior","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : CompleteSpace ğ•œ\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : NormedSpace ğ•œ V\ninstâœÂ² : FiniteDimensional ğ•œ V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\ns : Set P\nâŠ¢ Eq (SDiff.sdiff (closure s) (intrinsicInterior ğ•œ s)) (intrinsicFrontier ğ•œ s)","decl":"@[simp]\ntheorem closure_diff_intrinsicInterior (s : Set P) :\n    closure s \\ intrinsicInterior ğ•œ s = intrinsicFrontier ğ•œ s :=\n  intrinsicClosure_eq_closure ğ•œ s â–¸ intrinsicClosure_diff_intrinsicInterior s\n\n"}
{"name":"closure_diff_intrinsicFrontier","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\nP : Type u_5\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : CompleteSpace ğ•œ\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : NormedSpace ğ•œ V\ninstâœÂ² : FiniteDimensional ğ•œ V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\ns : Set P\nâŠ¢ Eq (SDiff.sdiff (closure s) (intrinsicFrontier ğ•œ s)) (intrinsicInterior ğ•œ s)","decl":"@[simp]\ntheorem closure_diff_intrinsicFrontier (s : Set P) :\n    closure s \\ intrinsicFrontier ğ•œ s = intrinsicInterior ğ•œ s :=\n  intrinsicClosure_eq_closure ğ•œ s â–¸ intrinsicClosure_diff_intrinsicFrontier s\n\n"}
{"name":"Set.Nonempty.intrinsicInterior","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"V : Type u_2\ninstâœÂ² : NormedAddCommGroup V\ninstâœÂ¹ : NormedSpace Real V\ninstâœ : FiniteDimensional Real V\ns : Set V\nhscv : Convex Real s\nhsne : s.Nonempty\nâŠ¢ (intrinsicInterior Real s).Nonempty","decl":"/-- The intrinsic interior of a nonempty convex set is nonempty. -/\nprotected theorem Set.Nonempty.intrinsicInterior (hscv : Convex â„ s) (hsne : s.Nonempty) :\n    (intrinsicInterior â„ s).Nonempty := by\n  haveI := hsne.coe_sort\n  obtain âŸ¨p, hpâŸ© := hsne\n  let p' : _root_.affineSpan â„ s := âŸ¨p, subset_affineSpan _ _ hpâŸ©\n  rw [intrinsicInterior, image_nonempty,\n    aux (AffineIsometryEquiv.constVSub â„ p').symm.toHomeomorph,\n    Convex.interior_nonempty_iff_affineSpan_eq_top, AffineIsometryEquiv.coe_toHomeomorph, â†\n    AffineIsometryEquiv.coe_toAffineEquiv, â† comap_span, affineSpan_coe_preimage_eq_top, comap_top]\n  exact hscv.affine_preimage\n    ((_root_.affineSpan â„ s).subtype.comp\n      (AffineIsometryEquiv.constVSub â„ p').symm.toAffineEquiv.toAffineMap)\n\n"}
{"name":"intrinsicInterior_nonempty","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"V : Type u_2\ninstâœÂ² : NormedAddCommGroup V\ninstâœÂ¹ : NormedSpace Real V\ninstâœ : FiniteDimensional Real V\ns : Set V\nhs : Convex Real s\nâŠ¢ Iff (intrinsicInterior Real s).Nonempty s.Nonempty","decl":"theorem intrinsicInterior_nonempty (hs : Convex â„ s) :\n    (intrinsicInterior â„ s).Nonempty â†” s.Nonempty :=\n  âŸ¨by simp_rw [nonempty_iff_ne_empty]; rintro h rfl; exact h intrinsicInterior_empty,\n    Set.Nonempty.intrinsicInterior hsâŸ©\n"}
