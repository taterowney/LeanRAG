{"name":"mem_intrinsicInterior","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : AddCommGroup V\ninst✝² : Module 𝕜 V\ninst✝¹ : TopologicalSpace P\ninst✝ : AddTorsor V P\ns : Set P\nx : P\n⊢ Iff (Membership.mem (intrinsicInterior 𝕜 s) x) (Exists fun y => And (Membership.mem (interior (Set.preimage Subtype.val s)) y) (Eq (↑y) x))","decl":"@[simp]\ntheorem mem_intrinsicInterior :\n    x ∈ intrinsicInterior 𝕜 s ↔ ∃ y, y ∈ interior ((↑) ⁻¹' s : Set <| affineSpan 𝕜 s) ∧ ↑y = x :=\n  mem_image _ _ _\n\n"}
{"name":"mem_intrinsicFrontier","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : AddCommGroup V\ninst✝² : Module 𝕜 V\ninst✝¹ : TopologicalSpace P\ninst✝ : AddTorsor V P\ns : Set P\nx : P\n⊢ Iff (Membership.mem (intrinsicFrontier 𝕜 s) x) (Exists fun y => And (Membership.mem (frontier (Set.preimage Subtype.val s)) y) (Eq (↑y) x))","decl":"@[simp]\ntheorem mem_intrinsicFrontier :\n    x ∈ intrinsicFrontier 𝕜 s ↔ ∃ y, y ∈ frontier ((↑) ⁻¹' s : Set <| affineSpan 𝕜 s) ∧ ↑y = x :=\n  mem_image _ _ _\n\n"}
{"name":"mem_intrinsicClosure","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : AddCommGroup V\ninst✝² : Module 𝕜 V\ninst✝¹ : TopologicalSpace P\ninst✝ : AddTorsor V P\ns : Set P\nx : P\n⊢ Iff (Membership.mem (intrinsicClosure 𝕜 s) x) (Exists fun y => And (Membership.mem (closure (Set.preimage Subtype.val s)) y) (Eq (↑y) x))","decl":"@[simp]\ntheorem mem_intrinsicClosure :\n    x ∈ intrinsicClosure 𝕜 s ↔ ∃ y, y ∈ closure ((↑) ⁻¹' s : Set <| affineSpan 𝕜 s) ∧ ↑y = x :=\n  mem_image _ _ _\n\n"}
{"name":"intrinsicInterior_subset","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : AddCommGroup V\ninst✝² : Module 𝕜 V\ninst✝¹ : TopologicalSpace P\ninst✝ : AddTorsor V P\ns : Set P\n⊢ HasSubset.Subset (intrinsicInterior 𝕜 s) s","decl":"theorem intrinsicInterior_subset : intrinsicInterior 𝕜 s ⊆ s :=\n  image_subset_iff.2 interior_subset\n\n"}
{"name":"intrinsicFrontier_subset","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : AddCommGroup V\ninst✝² : Module 𝕜 V\ninst✝¹ : TopologicalSpace P\ninst✝ : AddTorsor V P\ns : Set P\nhs : IsClosed s\n⊢ HasSubset.Subset (intrinsicFrontier 𝕜 s) s","decl":"theorem intrinsicFrontier_subset (hs : IsClosed s) : intrinsicFrontier 𝕜 s ⊆ s :=\n  image_subset_iff.2 (hs.preimage continuous_induced_dom).frontier_subset\n\n"}
{"name":"intrinsicFrontier_subset_intrinsicClosure","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : AddCommGroup V\ninst✝² : Module 𝕜 V\ninst✝¹ : TopologicalSpace P\ninst✝ : AddTorsor V P\ns : Set P\n⊢ HasSubset.Subset (intrinsicFrontier 𝕜 s) (intrinsicClosure 𝕜 s)","decl":"theorem intrinsicFrontier_subset_intrinsicClosure : intrinsicFrontier 𝕜 s ⊆ intrinsicClosure 𝕜 s :=\n  image_subset _ frontier_subset_closure\n\n"}
{"name":"subset_intrinsicClosure","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : AddCommGroup V\ninst✝² : Module 𝕜 V\ninst✝¹ : TopologicalSpace P\ninst✝ : AddTorsor V P\ns : Set P\n⊢ HasSubset.Subset s (intrinsicClosure 𝕜 s)","decl":"theorem subset_intrinsicClosure : s ⊆ intrinsicClosure 𝕜 s :=\n  fun x hx => ⟨⟨x, subset_affineSpan _ _ hx⟩, subset_closure hx, rfl⟩\n\n"}
{"name":"intrinsicInterior_empty","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : AddCommGroup V\ninst✝² : Module 𝕜 V\ninst✝¹ : TopologicalSpace P\ninst✝ : AddTorsor V P\n⊢ Eq (intrinsicInterior 𝕜 EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem intrinsicInterior_empty : intrinsicInterior 𝕜 (∅ : Set P) = ∅ := by simp [intrinsicInterior]\n\n"}
{"name":"intrinsicFrontier_empty","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : AddCommGroup V\ninst✝² : Module 𝕜 V\ninst✝¹ : TopologicalSpace P\ninst✝ : AddTorsor V P\n⊢ Eq (intrinsicFrontier 𝕜 EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem intrinsicFrontier_empty : intrinsicFrontier 𝕜 (∅ : Set P) = ∅ := by simp [intrinsicFrontier]\n\n"}
{"name":"intrinsicClosure_empty","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : AddCommGroup V\ninst✝² : Module 𝕜 V\ninst✝¹ : TopologicalSpace P\ninst✝ : AddTorsor V P\n⊢ Eq (intrinsicClosure 𝕜 EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem intrinsicClosure_empty : intrinsicClosure 𝕜 (∅ : Set P) = ∅ := by simp [intrinsicClosure]\n\n"}
{"name":"intrinsicClosure_nonempty","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : AddCommGroup V\ninst✝² : Module 𝕜 V\ninst✝¹ : TopologicalSpace P\ninst✝ : AddTorsor V P\ns : Set P\n⊢ Iff (intrinsicClosure 𝕜 s).Nonempty s.Nonempty","decl":"@[simp]\ntheorem intrinsicClosure_nonempty : (intrinsicClosure 𝕜 s).Nonempty ↔ s.Nonempty :=\n  ⟨by simp_rw [nonempty_iff_ne_empty]; rintro h rfl; exact h intrinsicClosure_empty,\n    Nonempty.mono subset_intrinsicClosure⟩\n\n"}
{"name":"Set.Nonempty.ofIntrinsicClosure","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : AddCommGroup V\ninst✝² : Module 𝕜 V\ninst✝¹ : TopologicalSpace P\ninst✝ : AddTorsor V P\ns : Set P\na✝ : (intrinsicClosure 𝕜 s).Nonempty\n⊢ s.Nonempty","decl":"alias ⟨Set.Nonempty.ofIntrinsicClosure, Set.Nonempty.intrinsicClosure⟩ := intrinsicClosure_nonempty\n\n--attribute [protected] Set.Nonempty.intrinsicClosure -- Porting note: removed\n\n"}
{"name":"Set.Nonempty.intrinsicClosure","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : AddCommGroup V\ninst✝² : Module 𝕜 V\ninst✝¹ : TopologicalSpace P\ninst✝ : AddTorsor V P\ns : Set P\na✝ : s.Nonempty\n⊢ (intrinsicClosure 𝕜 s).Nonempty","decl":"alias ⟨Set.Nonempty.ofIntrinsicClosure, Set.Nonempty.intrinsicClosure⟩ := intrinsicClosure_nonempty\n\n--attribute [protected] Set.Nonempty.intrinsicClosure -- Porting note: removed\n\n"}
{"name":"intrinsicInterior_singleton","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : AddCommGroup V\ninst✝² : Module 𝕜 V\ninst✝¹ : TopologicalSpace P\ninst✝ : AddTorsor V P\nx : P\n⊢ Eq (intrinsicInterior 𝕜 (Singleton.singleton x)) (Singleton.singleton x)","decl":"@[simp]\ntheorem intrinsicInterior_singleton (x : P) : intrinsicInterior 𝕜 ({x} : Set P) = {x} := by\n  simp only [intrinsicInterior, preimage_coe_affineSpan_singleton, interior_univ, image_univ,\n    Subtype.range_coe_subtype, mem_affineSpan_singleton, setOf_eq_eq_singleton]\n\n"}
{"name":"intrinsicFrontier_singleton","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : AddCommGroup V\ninst✝² : Module 𝕜 V\ninst✝¹ : TopologicalSpace P\ninst✝ : AddTorsor V P\nx : P\n⊢ Eq (intrinsicFrontier 𝕜 (Singleton.singleton x)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem intrinsicFrontier_singleton (x : P) : intrinsicFrontier 𝕜 ({x} : Set P) = ∅ := by\n  rw [intrinsicFrontier, preimage_coe_affineSpan_singleton, frontier_univ, image_empty]\n\n"}
{"name":"intrinsicClosure_singleton","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : AddCommGroup V\ninst✝² : Module 𝕜 V\ninst✝¹ : TopologicalSpace P\ninst✝ : AddTorsor V P\nx : P\n⊢ Eq (intrinsicClosure 𝕜 (Singleton.singleton x)) (Singleton.singleton x)","decl":"@[simp]\ntheorem intrinsicClosure_singleton (x : P) : intrinsicClosure 𝕜 ({x} : Set P) = {x} := by\n  simp only [intrinsicClosure, preimage_coe_affineSpan_singleton, closure_univ, image_univ,\n    Subtype.range_coe_subtype, mem_affineSpan_singleton, setOf_eq_eq_singleton]\n\n"}
{"name":"intrinsicClosure_mono","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : AddCommGroup V\ninst✝² : Module 𝕜 V\ninst✝¹ : TopologicalSpace P\ninst✝ : AddTorsor V P\ns t : Set P\nh : HasSubset.Subset s t\n⊢ HasSubset.Subset (intrinsicClosure 𝕜 s) (intrinsicClosure 𝕜 t)","decl":"theorem intrinsicClosure_mono (h : s ⊆ t) : intrinsicClosure 𝕜 s ⊆ intrinsicClosure 𝕜 t := by\n  refine image_subset_iff.2 fun x hx => ?_\n  refine ⟨Set.inclusion (affineSpan_mono _ h) x, ?_, rfl⟩\n  refine (continuous_inclusion (affineSpan_mono _ h)).closure_preimage_subset _ (closure_mono ?_ hx)\n  exact fun y hy => h hy\n\n"}
{"name":"interior_subset_intrinsicInterior","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : AddCommGroup V\ninst✝² : Module 𝕜 V\ninst✝¹ : TopologicalSpace P\ninst✝ : AddTorsor V P\ns : Set P\n⊢ HasSubset.Subset (interior s) (intrinsicInterior 𝕜 s)","decl":"theorem interior_subset_intrinsicInterior : interior s ⊆ intrinsicInterior 𝕜 s :=\n  fun x hx => ⟨⟨x, subset_affineSpan _ _ <| interior_subset hx⟩,\n    preimage_interior_subset_interior_preimage continuous_subtype_val hx, rfl⟩\n\n"}
{"name":"intrinsicClosure_subset_closure","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : AddCommGroup V\ninst✝² : Module 𝕜 V\ninst✝¹ : TopologicalSpace P\ninst✝ : AddTorsor V P\ns : Set P\n⊢ HasSubset.Subset (intrinsicClosure 𝕜 s) (closure s)","decl":"theorem intrinsicClosure_subset_closure : intrinsicClosure 𝕜 s ⊆ closure s :=\n  image_subset_iff.2 <| continuous_subtype_val.closure_preimage_subset _\n\n"}
{"name":"intrinsicFrontier_subset_frontier","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : AddCommGroup V\ninst✝² : Module 𝕜 V\ninst✝¹ : TopologicalSpace P\ninst✝ : AddTorsor V P\ns : Set P\n⊢ HasSubset.Subset (intrinsicFrontier 𝕜 s) (frontier s)","decl":"theorem intrinsicFrontier_subset_frontier : intrinsicFrontier 𝕜 s ⊆ frontier s :=\n  image_subset_iff.2 <| continuous_subtype_val.frontier_preimage_subset _\n\n"}
{"name":"intrinsicClosure_subset_affineSpan","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : AddCommGroup V\ninst✝² : Module 𝕜 V\ninst✝¹ : TopologicalSpace P\ninst✝ : AddTorsor V P\ns : Set P\n⊢ HasSubset.Subset (intrinsicClosure 𝕜 s) ↑(affineSpan 𝕜 s)","decl":"theorem intrinsicClosure_subset_affineSpan : intrinsicClosure 𝕜 s ⊆ affineSpan 𝕜 s :=\n  (image_subset_range _ _).trans Subtype.range_coe.subset\n\n"}
{"name":"intrinsicClosure_diff_intrinsicFrontier","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : AddCommGroup V\ninst✝² : Module 𝕜 V\ninst✝¹ : TopologicalSpace P\ninst✝ : AddTorsor V P\ns : Set P\n⊢ Eq (SDiff.sdiff (intrinsicClosure 𝕜 s) (intrinsicFrontier 𝕜 s)) (intrinsicInterior 𝕜 s)","decl":"@[simp]\ntheorem intrinsicClosure_diff_intrinsicFrontier (s : Set P) :\n    intrinsicClosure 𝕜 s \\ intrinsicFrontier 𝕜 s = intrinsicInterior 𝕜 s :=\n  (image_diff Subtype.coe_injective _ _).symm.trans <| by\n    rw [closure_diff_frontier, intrinsicInterior]\n\n"}
{"name":"intrinsicClosure_diff_intrinsicInterior","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : AddCommGroup V\ninst✝² : Module 𝕜 V\ninst✝¹ : TopologicalSpace P\ninst✝ : AddTorsor V P\ns : Set P\n⊢ Eq (SDiff.sdiff (intrinsicClosure 𝕜 s) (intrinsicInterior 𝕜 s)) (intrinsicFrontier 𝕜 s)","decl":"@[simp]\ntheorem intrinsicClosure_diff_intrinsicInterior (s : Set P) :\n    intrinsicClosure 𝕜 s \\ intrinsicInterior 𝕜 s = intrinsicFrontier 𝕜 s :=\n  (image_diff Subtype.coe_injective _ _).symm\n\n"}
{"name":"intrinsicInterior_union_intrinsicFrontier","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : AddCommGroup V\ninst✝² : Module 𝕜 V\ninst✝¹ : TopologicalSpace P\ninst✝ : AddTorsor V P\ns : Set P\n⊢ Eq (Union.union (intrinsicInterior 𝕜 s) (intrinsicFrontier 𝕜 s)) (intrinsicClosure 𝕜 s)","decl":"@[simp]\ntheorem intrinsicInterior_union_intrinsicFrontier (s : Set P) :\n    intrinsicInterior 𝕜 s ∪ intrinsicFrontier 𝕜 s = intrinsicClosure 𝕜 s := by\n  simp [intrinsicClosure, intrinsicInterior, intrinsicFrontier, closure_eq_interior_union_frontier,\n    image_union]\n\n"}
{"name":"intrinsicFrontier_union_intrinsicInterior","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : AddCommGroup V\ninst✝² : Module 𝕜 V\ninst✝¹ : TopologicalSpace P\ninst✝ : AddTorsor V P\ns : Set P\n⊢ Eq (Union.union (intrinsicFrontier 𝕜 s) (intrinsicInterior 𝕜 s)) (intrinsicClosure 𝕜 s)","decl":"@[simp]\ntheorem intrinsicFrontier_union_intrinsicInterior (s : Set P) :\n    intrinsicFrontier 𝕜 s ∪ intrinsicInterior 𝕜 s = intrinsicClosure 𝕜 s := by\n  rw [union_comm, intrinsicInterior_union_intrinsicFrontier]\n\n"}
{"name":"isClosed_intrinsicClosure","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : AddCommGroup V\ninst✝² : Module 𝕜 V\ninst✝¹ : TopologicalSpace P\ninst✝ : AddTorsor V P\ns : Set P\nhs : IsClosed ↑(affineSpan 𝕜 s)\n⊢ IsClosed (intrinsicClosure 𝕜 s)","decl":"theorem isClosed_intrinsicClosure (hs : IsClosed (affineSpan 𝕜 s : Set P)) :\n    IsClosed (intrinsicClosure 𝕜 s) :=\n  hs.isClosedEmbedding_subtypeVal.isClosedMap _ isClosed_closure\n\n"}
{"name":"isClosed_intrinsicFrontier","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : AddCommGroup V\ninst✝² : Module 𝕜 V\ninst✝¹ : TopologicalSpace P\ninst✝ : AddTorsor V P\ns : Set P\nhs : IsClosed ↑(affineSpan 𝕜 s)\n⊢ IsClosed (intrinsicFrontier 𝕜 s)","decl":"theorem isClosed_intrinsicFrontier (hs : IsClosed (affineSpan 𝕜 s : Set P)) :\n    IsClosed (intrinsicFrontier 𝕜 s) :=\n  hs.isClosedEmbedding_subtypeVal.isClosedMap _ isClosed_frontier\n\n"}
{"name":"affineSpan_intrinsicClosure","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : AddCommGroup V\ninst✝² : Module 𝕜 V\ninst✝¹ : TopologicalSpace P\ninst✝ : AddTorsor V P\ns : Set P\n⊢ Eq (affineSpan 𝕜 (intrinsicClosure 𝕜 s)) (affineSpan 𝕜 s)","decl":"@[simp]\ntheorem affineSpan_intrinsicClosure (s : Set P) :\n    affineSpan 𝕜 (intrinsicClosure 𝕜 s) = affineSpan 𝕜 s :=\n  (affineSpan_le.2 intrinsicClosure_subset_affineSpan).antisymm <|\n    affineSpan_mono _ subset_intrinsicClosure\n\n"}
{"name":"IsClosed.intrinsicClosure","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : AddCommGroup V\ninst✝² : Module 𝕜 V\ninst✝¹ : TopologicalSpace P\ninst✝ : AddTorsor V P\ns : Set P\nhs : IsClosed (Set.preimage Subtype.val s)\n⊢ Eq (intrinsicClosure 𝕜 s) s","decl":"protected theorem IsClosed.intrinsicClosure (hs : IsClosed ((↑) ⁻¹' s : Set <| affineSpan 𝕜 s)) :\n    intrinsicClosure 𝕜 s = s := by\n  rw [intrinsicClosure, hs.closure_eq, image_preimage_eq_of_subset]\n  exact (subset_affineSpan _ _).trans Subtype.range_coe.superset\n\n"}
{"name":"intrinsicClosure_idem","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : AddCommGroup V\ninst✝² : Module 𝕜 V\ninst✝¹ : TopologicalSpace P\ninst✝ : AddTorsor V P\ns : Set P\n⊢ Eq (intrinsicClosure 𝕜 (intrinsicClosure 𝕜 s)) (intrinsicClosure 𝕜 s)","decl":"@[simp]\ntheorem intrinsicClosure_idem (s : Set P) :\n    intrinsicClosure 𝕜 (intrinsicClosure 𝕜 s) = intrinsicClosure 𝕜 s := by\n  refine IsClosed.intrinsicClosure ?_\n  set t := affineSpan 𝕜 (intrinsicClosure 𝕜 s) with ht\n  clear_value t\n  obtain rfl := ht.trans (affineSpan_intrinsicClosure _)\n  rw [intrinsicClosure, preimage_image_eq _ Subtype.coe_injective]\n  exact isClosed_closure\n\n"}
{"name":"AffineIsometry.image_intrinsicInterior","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nW : Type u_3\nQ : Type u_4\nP : Type u_5\ninst✝⁸ : NormedField 𝕜\ninst✝⁷ : SeminormedAddCommGroup V\ninst✝⁶ : SeminormedAddCommGroup W\ninst✝⁵ : NormedSpace 𝕜 V\ninst✝⁴ : NormedSpace 𝕜 W\ninst✝³ : MetricSpace P\ninst✝² : PseudoMetricSpace Q\ninst✝¹ : NormedAddTorsor V P\ninst✝ : NormedAddTorsor W Q\nφ : AffineIsometry 𝕜 P Q\ns : Set P\n⊢ Eq (intrinsicInterior 𝕜 (Set.image (⇑φ) s)) (Set.image (⇑φ) (intrinsicInterior 𝕜 s))","decl":"@[simp]\ntheorem image_intrinsicInterior (φ : P →ᵃⁱ[𝕜] Q) (s : Set P) :\n    intrinsicInterior 𝕜 (φ '' s) = φ '' intrinsicInterior 𝕜 s := by\n  obtain rfl | hs := s.eq_empty_or_nonempty\n  · simp only [intrinsicInterior_empty, image_empty]\n  haveI : Nonempty s := hs.to_subtype\n  let f := ((affineSpan 𝕜 s).isometryEquivMap φ).toHomeomorph\n  have : φ.toAffineMap ∘ (↑) ∘ f.symm = (↑) := funext isometryEquivMap.apply_symm_apply\n  rw [intrinsicInterior, intrinsicInterior, ← φ.coe_toAffineMap, ← map_span φ.toAffineMap s, ← this,\n    ← Function.comp_assoc, image_comp, image_comp, f.symm.image_interior, f.image_symm,\n    ← preimage_comp, Function.comp_assoc, f.symm_comp_self, AffineIsometry.coe_toAffineMap,\n    Function.comp_id, preimage_comp, φ.injective.preimage_image]\n\n"}
{"name":"AffineIsometry.image_intrinsicFrontier","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nW : Type u_3\nQ : Type u_4\nP : Type u_5\ninst✝⁸ : NormedField 𝕜\ninst✝⁷ : SeminormedAddCommGroup V\ninst✝⁶ : SeminormedAddCommGroup W\ninst✝⁵ : NormedSpace 𝕜 V\ninst✝⁴ : NormedSpace 𝕜 W\ninst✝³ : MetricSpace P\ninst✝² : PseudoMetricSpace Q\ninst✝¹ : NormedAddTorsor V P\ninst✝ : NormedAddTorsor W Q\nφ : AffineIsometry 𝕜 P Q\ns : Set P\n⊢ Eq (intrinsicFrontier 𝕜 (Set.image (⇑φ) s)) (Set.image (⇑φ) (intrinsicFrontier 𝕜 s))","decl":"@[simp]\ntheorem image_intrinsicFrontier (φ : P →ᵃⁱ[𝕜] Q) (s : Set P) :\n    intrinsicFrontier 𝕜 (φ '' s) = φ '' intrinsicFrontier 𝕜 s := by\n  obtain rfl | hs := s.eq_empty_or_nonempty\n  · simp\n  haveI : Nonempty s := hs.to_subtype\n  let f := ((affineSpan 𝕜 s).isometryEquivMap φ).toHomeomorph\n  have : φ.toAffineMap ∘ (↑) ∘ f.symm = (↑) := funext isometryEquivMap.apply_symm_apply\n  rw [intrinsicFrontier, intrinsicFrontier, ← φ.coe_toAffineMap, ← map_span φ.toAffineMap s, ← this,\n    ← Function.comp_assoc, image_comp, image_comp, f.symm.image_frontier, f.image_symm,\n    ← preimage_comp, Function.comp_assoc, f.symm_comp_self, AffineIsometry.coe_toAffineMap,\n    Function.comp_id, preimage_comp, φ.injective.preimage_image]\n\n"}
{"name":"AffineIsometry.image_intrinsicClosure","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nW : Type u_3\nQ : Type u_4\nP : Type u_5\ninst✝⁸ : NormedField 𝕜\ninst✝⁷ : SeminormedAddCommGroup V\ninst✝⁶ : SeminormedAddCommGroup W\ninst✝⁵ : NormedSpace 𝕜 V\ninst✝⁴ : NormedSpace 𝕜 W\ninst✝³ : MetricSpace P\ninst✝² : PseudoMetricSpace Q\ninst✝¹ : NormedAddTorsor V P\ninst✝ : NormedAddTorsor W Q\nφ : AffineIsometry 𝕜 P Q\ns : Set P\n⊢ Eq (intrinsicClosure 𝕜 (Set.image (⇑φ) s)) (Set.image (⇑φ) (intrinsicClosure 𝕜 s))","decl":"@[simp]\ntheorem image_intrinsicClosure (φ : P →ᵃⁱ[𝕜] Q) (s : Set P) :\n    intrinsicClosure 𝕜 (φ '' s) = φ '' intrinsicClosure 𝕜 s := by\n  obtain rfl | hs := s.eq_empty_or_nonempty\n  · simp\n  haveI : Nonempty s := hs.to_subtype\n  let f := ((affineSpan 𝕜 s).isometryEquivMap φ).toHomeomorph\n  have : φ.toAffineMap ∘ (↑) ∘ f.symm = (↑) := funext isometryEquivMap.apply_symm_apply\n  rw [intrinsicClosure, intrinsicClosure, ← φ.coe_toAffineMap, ← map_span φ.toAffineMap s, ← this,\n    ← Function.comp_assoc, image_comp, image_comp, f.symm.image_closure, f.image_symm,\n    ← preimage_comp, Function.comp_assoc, f.symm_comp_self, AffineIsometry.coe_toAffineMap,\n    Function.comp_id, preimage_comp, φ.injective.preimage_image]\n\n"}
{"name":"intrinsicClosure_eq_closure","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : CompleteSpace 𝕜\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : NormedSpace 𝕜 V\ninst✝² : FiniteDimensional 𝕜 V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\ns : Set P\n⊢ Eq (intrinsicClosure 𝕜 s) (closure s)","decl":"@[simp]\ntheorem intrinsicClosure_eq_closure : intrinsicClosure 𝕜 s = closure s := by\n  ext x\n  simp only [mem_closure_iff, mem_intrinsicClosure]\n  refine ⟨?_, fun h => ⟨⟨x, _⟩, ?_, Subtype.coe_mk _ ?_⟩⟩\n  · rintro ⟨x, h, rfl⟩ t ht hx\n    obtain ⟨z, hz₁, hz₂⟩ := h _ (continuous_induced_dom.isOpen_preimage t ht) hx\n    exact ⟨z, hz₁, hz₂⟩\n  · rintro _ ⟨t, ht, rfl⟩ hx\n    obtain ⟨y, hyt, hys⟩ := h _ ht hx\n    exact ⟨⟨_, subset_affineSpan 𝕜 s hys⟩, hyt, hys⟩\n  · by_contra hc\n    obtain ⟨z, hz₁, hz₂⟩ := h _ (affineSpan 𝕜 s).closed_of_finiteDimensional.isOpen_compl hc\n    exact hz₁ (subset_affineSpan 𝕜 s hz₂)\n\n"}
{"name":"closure_diff_intrinsicInterior","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : CompleteSpace 𝕜\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : NormedSpace 𝕜 V\ninst✝² : FiniteDimensional 𝕜 V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\ns : Set P\n⊢ Eq (SDiff.sdiff (closure s) (intrinsicInterior 𝕜 s)) (intrinsicFrontier 𝕜 s)","decl":"@[simp]\ntheorem closure_diff_intrinsicInterior (s : Set P) :\n    closure s \\ intrinsicInterior 𝕜 s = intrinsicFrontier 𝕜 s :=\n  intrinsicClosure_eq_closure 𝕜 s ▸ intrinsicClosure_diff_intrinsicInterior s\n\n"}
{"name":"closure_diff_intrinsicFrontier","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"𝕜 : Type u_1\nV : Type u_2\nP : Type u_5\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : CompleteSpace 𝕜\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : NormedSpace 𝕜 V\ninst✝² : FiniteDimensional 𝕜 V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\ns : Set P\n⊢ Eq (SDiff.sdiff (closure s) (intrinsicFrontier 𝕜 s)) (intrinsicInterior 𝕜 s)","decl":"@[simp]\ntheorem closure_diff_intrinsicFrontier (s : Set P) :\n    closure s \\ intrinsicFrontier 𝕜 s = intrinsicInterior 𝕜 s :=\n  intrinsicClosure_eq_closure 𝕜 s ▸ intrinsicClosure_diff_intrinsicFrontier s\n\n"}
{"name":"Set.Nonempty.intrinsicInterior","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"V : Type u_2\ninst✝² : NormedAddCommGroup V\ninst✝¹ : NormedSpace Real V\ninst✝ : FiniteDimensional Real V\ns : Set V\nhscv : Convex Real s\nhsne : s.Nonempty\n⊢ (intrinsicInterior Real s).Nonempty","decl":"/-- The intrinsic interior of a nonempty convex set is nonempty. -/\nprotected theorem Set.Nonempty.intrinsicInterior (hscv : Convex ℝ s) (hsne : s.Nonempty) :\n    (intrinsicInterior ℝ s).Nonempty := by\n  haveI := hsne.coe_sort\n  obtain ⟨p, hp⟩ := hsne\n  let p' : _root_.affineSpan ℝ s := ⟨p, subset_affineSpan _ _ hp⟩\n  rw [intrinsicInterior, image_nonempty,\n    aux (AffineIsometryEquiv.constVSub ℝ p').symm.toHomeomorph,\n    Convex.interior_nonempty_iff_affineSpan_eq_top, AffineIsometryEquiv.coe_toHomeomorph, ←\n    AffineIsometryEquiv.coe_toAffineEquiv, ← comap_span, affineSpan_coe_preimage_eq_top, comap_top]\n  exact hscv.affine_preimage\n    ((_root_.affineSpan ℝ s).subtype.comp\n      (AffineIsometryEquiv.constVSub ℝ p').symm.toAffineEquiv.toAffineMap)\n\n"}
{"name":"intrinsicInterior_nonempty","module":"Mathlib.Analysis.Convex.Intrinsic","initialProofState":"V : Type u_2\ninst✝² : NormedAddCommGroup V\ninst✝¹ : NormedSpace Real V\ninst✝ : FiniteDimensional Real V\ns : Set V\nhs : Convex Real s\n⊢ Iff (intrinsicInterior Real s).Nonempty s.Nonempty","decl":"theorem intrinsicInterior_nonempty (hs : Convex ℝ s) :\n    (intrinsicInterior ℝ s).Nonempty ↔ s.Nonempty :=\n  ⟨by simp_rw [nonempty_iff_ne_empty]; rintro h rfl; exact h intrinsicInterior_empty,\n    Set.Nonempty.intrinsicInterior hs⟩\n"}
