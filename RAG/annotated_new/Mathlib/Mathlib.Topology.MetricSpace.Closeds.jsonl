{"name":"EMetric.continuous_infEdist_hausdorffEdist","module":"Mathlib.Topology.MetricSpace.Closeds","initialProofState":"α : Type u\ninst✝ : EMetricSpace α\n⊢ Continuous fun p => EMetric.infEdist p.1 ↑p.2","decl":"/-- The edistance to a closed set depends continuously on the point and the set -/\ntheorem continuous_infEdist_hausdorffEdist :\n    Continuous fun p : α × Closeds α => infEdist p.1 p.2 := by\n  refine continuous_of_le_add_edist 2 (by simp) ?_\n  rintro ⟨x, s⟩ ⟨y, t⟩\n  calc\n    infEdist x s ≤ infEdist x t + hausdorffEdist (t : Set α) s :=\n      infEdist_le_infEdist_add_hausdorffEdist\n    _ ≤ infEdist y t + edist x y + hausdorffEdist (t : Set α) s :=\n      (add_le_add_right infEdist_le_infEdist_add_edist _)\n    _ = infEdist y t + (edist x y + hausdorffEdist (s : Set α) t) := by\n      rw [add_assoc, hausdorffEdist_comm]\n    _ ≤ infEdist y t + (edist (x, s) (y, t) + edist (x, s) (y, t)) :=\n      (add_le_add_left (add_le_add (le_max_left _ _) (le_max_right _ _)) _)\n    _ = infEdist y t + 2 * edist (x, s) (y, t) := by rw [← mul_two, mul_comm]\n\n"}
{"name":"EMetric.isClosed_subsets_of_isClosed","module":"Mathlib.Topology.MetricSpace.Closeds","initialProofState":"α : Type u\ninst✝ : EMetricSpace α\ns : Set α\nhs : IsClosed s\n⊢ IsClosed (setOf fun t => HasSubset.Subset (↑t) s)","decl":"/-- Subsets of a given closed subset form a closed set -/\ntheorem isClosed_subsets_of_isClosed (hs : IsClosed s) :\n    IsClosed { t : Closeds α | (t : Set α) ⊆ s } := by\n  refine isClosed_of_closure_subset fun\n    (t : Closeds α) (ht : t ∈ closure {t : Closeds α | (t : Set α) ⊆ s}) (x : α) (hx : x ∈ t) => ?_\n  have : x ∈ closure s := by\n    refine mem_closure_iff.2 fun ε εpos => ?_\n    obtain ⟨u : Closeds α, hu : u ∈ {t : Closeds α | (t : Set α) ⊆ s}, Dtu : edist t u < ε⟩ :=\n      mem_closure_iff.1 ht ε εpos\n    obtain ⟨y : α, hy : y ∈ u, Dxy : edist x y < ε⟩ := exists_edist_lt_of_hausdorffEdist_lt hx Dtu\n    exact ⟨y, hu hy, Dxy⟩\n  rwa [hs.closure_eq] at this\n\n"}
{"name":"EMetric.Closeds.edist_eq","module":"Mathlib.Topology.MetricSpace.Closeds","initialProofState":"α : Type u\ninst✝ : EMetricSpace α\ns t : TopologicalSpace.Closeds α\n⊢ Eq (EDist.edist s t) (EMetric.hausdorffEdist ↑s ↑t)","decl":"/-- By definition, the edistance on `Closeds α` is given by the Hausdorff edistance -/\ntheorem Closeds.edist_eq {s t : Closeds α} : edist s t = hausdorffEdist (s : Set α) t :=\n  rfl\n\n"}
{"name":"EMetric.Closeds.completeSpace","module":"Mathlib.Topology.MetricSpace.Closeds","initialProofState":"α : Type u\ninst✝¹ : EMetricSpace α\ninst✝ : CompleteSpace α\n⊢ CompleteSpace (TopologicalSpace.Closeds α)","decl":"/-- In a complete space, the type of closed subsets is complete for the\nHausdorff edistance. -/\ninstance Closeds.completeSpace [CompleteSpace α] : CompleteSpace (Closeds α) := by\n  /- We will show that, if a sequence of sets `s n` satisfies\n    `edist (s n) (s (n+1)) < 2^{-n}`, then it converges. This is enough to guarantee\n    completeness, by a standard completeness criterion.\n    We use the shorthand `B n = 2^{-n}` in ennreal. -/\n  let B : ℕ → ℝ≥0∞ := fun n => 2⁻¹ ^ n\n  have B_pos : ∀ n, (0 : ℝ≥0∞) < B n := by simp [B, ENNReal.pow_pos]\n  have B_ne_top : ∀ n, B n ≠ ⊤ := by simp [B, ENNReal.pow_ne_top]\n  /- Consider a sequence of closed sets `s n` with `edist (s n) (s (n+1)) < B n`.\n    We will show that it converges. The limit set is `t0 = ⋂n, closure (⋃m≥n, s m)`.\n    We will have to show that a point in `s n` is close to a point in `t0`, and a point\n    in `t0` is close to a point in `s n`. The completeness then follows from a\n    standard criterion. -/\n  refine complete_of_convergent_controlled_sequences B B_pos fun s hs => ?_\n  let t0 := ⋂ n, closure (⋃ m ≥ n, s m : Set α)\n  let t : Closeds α := ⟨t0, isClosed_iInter fun _ => isClosed_closure⟩\n  use t\n  -- The inequality is written this way to agree with `edist_le_of_edist_le_geometric_of_tendsto₀`\n  have I1 : ∀ n, ∀ x ∈ s n, ∃ y ∈ t0, edist x y ≤ 2 * B n := by\n    /- This is the main difficulty of the proof. Starting from `x ∈ s n`, we want\n           to find a point in `t0` which is close to `x`. Define inductively a sequence of\n           points `z m` with `z n = x` and `z m ∈ s m` and `edist (z m) (z (m+1)) ≤ B m`. This is\n           possible since the Hausdorff distance between `s m` and `s (m+1)` is at most `B m`.\n           This sequence is a Cauchy sequence, therefore converging as the space is complete, to\n           a limit which satisfies the required properties. -/\n    intro n x hx\n    obtain ⟨z, hz₀, hz⟩ :\n      ∃ z : ∀ l, s (n + l), (z 0 : α) = x ∧ ∀ k, edist (z k : α) (z (k + 1) : α) ≤ B n / 2 ^ k := by\n      -- We prove existence of the sequence by induction.\n      have : ∀ (l) (z : s (n + l)), ∃ z' : s (n + l + 1), edist (z : α) z' ≤ B n / 2 ^ l := by\n        intro l z\n        obtain ⟨z', z'_mem, hz'⟩ : ∃ z' ∈ s (n + l + 1), edist (z : α) z' < B n / 2 ^ l := by\n          refine exists_edist_lt_of_hausdorffEdist_lt (s := s (n + l)) z.2 ?_\n          simp only [ENNReal.inv_pow, div_eq_mul_inv]\n          rw [← pow_add]\n          apply hs <;> simp\n        exact ⟨⟨z', z'_mem⟩, le_of_lt hz'⟩\n      use fun k => Nat.recOn k ⟨x, hx⟩ fun l z => (this l z).choose\n      simp only [Nat.add_zero, Nat.rec_zero, Nat.rec_add_one, true_and]\n      exact fun k => (this k _).choose_spec\n    -- it follows from the previous bound that `z` is a Cauchy sequence\n    have : CauchySeq fun k => (z k : α) := cauchySeq_of_edist_le_geometric_two (B n) (B_ne_top n) hz\n    -- therefore, it converges\n    rcases cauchySeq_tendsto_of_complete this with ⟨y, y_lim⟩\n    use y\n    -- the limit point `y` will be the desired point, in `t0` and close to our initial point `x`.\n    -- First, we check it belongs to `t0`.\n    have : y ∈ t0 :=\n      mem_iInter.2 fun k =>\n        mem_closure_of_tendsto y_lim\n          (by\n            simp only [exists_prop, Set.mem_iUnion, Filter.eventually_atTop, Set.mem_preimage,\n              Set.preimage_iUnion]\n            exact ⟨k, fun m hm => ⟨n + m, zero_add k ▸ add_le_add (zero_le n) hm, (z m).2⟩⟩)\n    use this\n    -- Then, we check that `y` is close to `x = z n`. This follows from the fact that `y`\n    -- is the limit of `z k`, and the distance between `z n` and `z k` has already been estimated.\n    rw [← hz₀]\n    exact edist_le_of_edist_le_geometric_two_of_tendsto₀ (B n) hz y_lim\n  have I2 : ∀ n, ∀ x ∈ t0, ∃ y ∈ s n, edist x y ≤ 2 * B n := by\n    /- For the (much easier) reverse inequality, we start from a point `x ∈ t0` and we want\n            to find a point `y ∈ s n` which is close to `x`.\n            `x` belongs to `t0`, the intersection of the closures. In particular, it is well\n            approximated by a point `z` in `⋃m≥n, s m`, say in `s m`. Since `s m` and\n            `s n` are close, this point is itself well approximated by a point `y` in `s n`,\n            as required. -/\n    intro n x xt0\n    have : x ∈ closure (⋃ m ≥ n, s m : Set α) := by apply mem_iInter.1 xt0 n\n    obtain ⟨z : α, hz, Dxz : edist x z < B n⟩ := mem_closure_iff.1 this (B n) (B_pos n)\n    simp only [exists_prop, Set.mem_iUnion] at hz\n    obtain ⟨m : ℕ, m_ge_n : m ≥ n, hm : z ∈ (s m : Set α)⟩ := hz\n    have : hausdorffEdist (s m : Set α) (s n) < B n := hs n m n m_ge_n (le_refl n)\n    obtain ⟨y : α, hy : y ∈ (s n : Set α), Dzy : edist z y < B n⟩ :=\n      exists_edist_lt_of_hausdorffEdist_lt hm this\n    exact\n      ⟨y, hy,\n        calc\n          edist x y ≤ edist x z + edist z y := edist_triangle _ _ _\n          _ ≤ B n + B n := add_le_add (le_of_lt Dxz) (le_of_lt Dzy)\n          _ = 2 * B n := (two_mul _).symm\n          ⟩\n  -- Deduce from the above inequalities that the distance between `s n` and `t0` is at most `2 B n`.\n  have main : ∀ n : ℕ, edist (s n) t ≤ 2 * B n := fun n =>\n    hausdorffEdist_le_of_mem_edist (I1 n) (I2 n)\n  -- from this, the convergence of `s n` to `t0` follows.\n  refine tendsto_atTop.2 fun ε εpos => ?_\n  have : Tendsto (fun n => 2 * B n) atTop (𝓝 (2 * 0)) :=\n    ENNReal.Tendsto.const_mul (ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one <|\n      by simp [ENNReal.one_lt_two]) (Or.inr <| by simp)\n  rw [mul_zero] at this\n  obtain ⟨N, hN⟩ : ∃ N, ∀ b ≥ N, ε > 2 * B b :=\n    ((tendsto_order.1 this).2 ε εpos).exists_forall_of_atTop\n  exact ⟨N, fun n hn => lt_of_le_of_lt (main n) (hN n hn)⟩\n\n"}
{"name":"EMetric.Closeds.compactSpace","module":"Mathlib.Topology.MetricSpace.Closeds","initialProofState":"α : Type u\ninst✝¹ : EMetricSpace α\ninst✝ : CompactSpace α\n⊢ CompactSpace (TopologicalSpace.Closeds α)","decl":"/-- In a compact space, the type of closed subsets is compact. -/\ninstance Closeds.compactSpace [CompactSpace α] : CompactSpace (Closeds α) :=\n  ⟨by\n    /- by completeness, it suffices to show that it is totally bounded,\n        i.e., for all ε>0, there is a finite set which is ε-dense.\n        start from a set `s` which is ε-dense in α. Then the subsets of `s`\n        are finitely many, and ε-dense for the Hausdorff distance. -/\n    refine\n      isCompact_of_totallyBounded_isClosed (EMetric.totallyBounded_iff.2 fun ε εpos => ?_)\n        isClosed_univ\n    rcases exists_between εpos with ⟨δ, δpos, δlt⟩\n    obtain ⟨s : Set α, fs : s.Finite, hs : univ ⊆ ⋃ y ∈ s, ball y δ⟩ :=\n      EMetric.totallyBounded_iff.1\n        (isCompact_iff_totallyBounded_isComplete.1 (@isCompact_univ α _ _)).1 δ δpos\n    -- we first show that any set is well approximated by a subset of `s`.\n    have main : ∀ u : Set α, ∃ v ⊆ s, hausdorffEdist u v ≤ δ := by\n      intro u\n      let v := { x : α | x ∈ s ∧ ∃ y ∈ u, edist x y < δ }\n      exists v, (fun x hx => hx.1 : v ⊆ s)\n      refine hausdorffEdist_le_of_mem_edist ?_ ?_\n      · intro x hx\n        have : x ∈ ⋃ y ∈ s, ball y δ := hs (by simp)\n        rcases mem_iUnion₂.1 this with ⟨y, ys, dy⟩\n        have : edist y x < δ := by simpa [edist_comm]\n        exact ⟨y, ⟨ys, ⟨x, hx, this⟩⟩, le_of_lt dy⟩\n      · rintro x ⟨_, ⟨y, yu, hy⟩⟩\n        exact ⟨y, yu, le_of_lt hy⟩\n    -- introduce the set F of all subsets of `s` (seen as members of `Closeds α`).\n    let F := { f : Closeds α | (f : Set α) ⊆ s }\n    refine ⟨F, ?_, fun u _ => ?_⟩\n    -- `F` is finite\n    · apply @Finite.of_finite_image _ _ F _\n      · apply fs.finite_subsets.subset fun b => _\n        · exact fun s => (s : Set α)\n        simp only [F, and_imp, Set.mem_image, Set.mem_setOf_eq, exists_imp]\n        intro _ x hx hx'\n        rwa [hx'] at hx\n      · exact SetLike.coe_injective.injOn\n    -- `F` is ε-dense\n    · obtain ⟨t0, t0s, Dut0⟩ := main u\n      have : IsClosed t0 := (fs.subset t0s).isCompact.isClosed\n      let t : Closeds α := ⟨t0, this⟩\n      have : t ∈ F := t0s\n      have : edist u t < ε := lt_of_le_of_lt Dut0 δlt\n      apply mem_iUnion₂.2\n      exact ⟨t, ‹t ∈ F›, this⟩⟩\n\n"}
{"name":"EMetric.NonemptyCompacts.ToCloseds.isUniformEmbedding","module":"Mathlib.Topology.MetricSpace.Closeds","initialProofState":"α : Type u\ninst✝ : EMetricSpace α\n⊢ IsUniformEmbedding TopologicalSpace.NonemptyCompacts.toCloseds","decl":"/-- `NonemptyCompacts.toCloseds` is a uniform embedding (as it is an isometry) -/\ntheorem NonemptyCompacts.ToCloseds.isUniformEmbedding :\n    IsUniformEmbedding (@NonemptyCompacts.toCloseds α _ _) :=\n  Isometry.isUniformEmbedding fun _ _ => rfl\n\n"}
{"name":"EMetric.NonemptyCompacts.ToCloseds.uniformEmbedding","module":"Mathlib.Topology.MetricSpace.Closeds","initialProofState":"α : Type u\ninst✝ : EMetricSpace α\n⊢ IsUniformEmbedding TopologicalSpace.NonemptyCompacts.toCloseds","decl":"@[deprecated (since := \"2024-10-01\")]\nalias NonemptyCompacts.ToCloseds.uniformEmbedding := NonemptyCompacts.ToCloseds.isUniformEmbedding\n\n"}
{"name":"EMetric.NonemptyCompacts.isClosed_in_closeds","module":"Mathlib.Topology.MetricSpace.Closeds","initialProofState":"α : Type u\ninst✝¹ : EMetricSpace α\ninst✝ : CompleteSpace α\n⊢ IsClosed (Set.range TopologicalSpace.NonemptyCompacts.toCloseds)","decl":"/-- The range of `NonemptyCompacts.toCloseds` is closed in a complete space -/\ntheorem NonemptyCompacts.isClosed_in_closeds [CompleteSpace α] :\n    IsClosed (range <| @NonemptyCompacts.toCloseds α _ _) := by\n  have :\n    range NonemptyCompacts.toCloseds =\n      { s : Closeds α | (s : Set α).Nonempty ∧ IsCompact (s : Set α) } := by\n    ext s\n    refine ⟨?_, fun h => ⟨⟨⟨s, h.2⟩, h.1⟩, Closeds.ext rfl⟩⟩\n    rintro ⟨s, hs, rfl⟩\n    exact ⟨s.nonempty, s.isCompact⟩\n  rw [this]\n  refine isClosed_of_closure_subset fun s hs => ⟨?_, ?_⟩\n  · -- take a set t which is nonempty and at a finite distance of s\n    rcases mem_closure_iff.1 hs ⊤ ENNReal.coe_lt_top with ⟨t, ht, Dst⟩\n    rw [edist_comm] at Dst\n    -- since `t` is nonempty, so is `s`\n    exact nonempty_of_hausdorffEdist_ne_top ht.1 (ne_of_lt Dst)\n  · refine isCompact_iff_totallyBounded_isComplete.2 ⟨?_, s.closed.isComplete⟩\n    refine totallyBounded_iff.2 fun ε (εpos : 0 < ε) => ?_\n    -- we have to show that s is covered by finitely many eballs of radius ε\n    -- pick a nonempty compact set t at distance at most ε/2 of s\n    rcases mem_closure_iff.1 hs (ε / 2) (ENNReal.half_pos εpos.ne') with ⟨t, ht, Dst⟩\n    -- cover this space with finitely many balls of radius ε/2\n    rcases totallyBounded_iff.1 (isCompact_iff_totallyBounded_isComplete.1 ht.2).1 (ε / 2)\n        (ENNReal.half_pos εpos.ne') with\n      ⟨u, fu, ut⟩\n    refine ⟨u, ⟨fu, fun x hx => ?_⟩⟩\n    -- u : set α, fu : u.finite, ut : t ⊆ ⋃ (y : α) (H : y ∈ u), eball y (ε / 2)\n    -- then s is covered by the union of the balls centered at u of radius ε\n    rcases exists_edist_lt_of_hausdorffEdist_lt hx Dst with ⟨z, hz, Dxz⟩\n    rcases mem_iUnion₂.1 (ut hz) with ⟨y, hy, Dzy⟩\n    have : edist x y < ε :=\n      calc\n        edist x y ≤ edist x z + edist z y := edist_triangle _ _ _\n        _ < ε / 2 + ε / 2 := ENNReal.add_lt_add Dxz Dzy\n        _ = ε := ENNReal.add_halves _\n    exact mem_biUnion hy this\n\n"}
{"name":"EMetric.NonemptyCompacts.completeSpace","module":"Mathlib.Topology.MetricSpace.Closeds","initialProofState":"α : Type u\ninst✝¹ : EMetricSpace α\ninst✝ : CompleteSpace α\n⊢ CompleteSpace (TopologicalSpace.NonemptyCompacts α)","decl":"/-- In a complete space, the type of nonempty compact subsets is complete. This follows\nfrom the same statement for closed subsets -/\ninstance NonemptyCompacts.completeSpace [CompleteSpace α] : CompleteSpace (NonemptyCompacts α) :=\n  (completeSpace_iff_isComplete_range\n        NonemptyCompacts.ToCloseds.isUniformEmbedding.isUniformInducing).2 <|\n    NonemptyCompacts.isClosed_in_closeds.isComplete\n\n"}
{"name":"EMetric.NonemptyCompacts.compactSpace","module":"Mathlib.Topology.MetricSpace.Closeds","initialProofState":"α : Type u\ninst✝¹ : EMetricSpace α\ninst✝ : CompactSpace α\n⊢ CompactSpace (TopologicalSpace.NonemptyCompacts α)","decl":"/-- In a compact space, the type of nonempty compact subsets is compact. This follows from\nthe same statement for closed subsets -/\ninstance NonemptyCompacts.compactSpace [CompactSpace α] : CompactSpace (NonemptyCompacts α) :=\n  ⟨by\n    rw [NonemptyCompacts.ToCloseds.isUniformEmbedding.isEmbedding.isCompact_iff, image_univ]\n    exact NonemptyCompacts.isClosed_in_closeds.isCompact⟩\n\n"}
{"name":"EMetric.NonemptyCompacts.secondCountableTopology","module":"Mathlib.Topology.MetricSpace.Closeds","initialProofState":"α : Type u\ninst✝¹ : EMetricSpace α\ninst✝ : SecondCountableTopology α\n⊢ SecondCountableTopology (TopologicalSpace.NonemptyCompacts α)","decl":"/-- In a second countable space, the type of nonempty compact subsets is second countable -/\ninstance NonemptyCompacts.secondCountableTopology [SecondCountableTopology α] :\n    SecondCountableTopology (NonemptyCompacts α) :=\n  haveI : SeparableSpace (NonemptyCompacts α) := by\n    /- To obtain a countable dense subset of `NonemptyCompacts α`, start from\n        a countable dense subset `s` of α, and then consider all its finite nonempty subsets.\n        This set is countable and made of nonempty compact sets. It turns out to be dense:\n        by total boundedness, any compact set `t` can be covered by finitely many small balls, and\n        approximations in `s` of the centers of these balls give the required finite approximation\n        of `t`. -/\n    rcases exists_countable_dense α with ⟨s, cs, s_dense⟩\n    let v0 := { t : Set α | t.Finite ∧ t ⊆ s }\n    let v : Set (NonemptyCompacts α) := { t : NonemptyCompacts α | (t : Set α) ∈ v0 }\n    refine ⟨⟨v, ?_, ?_⟩⟩\n    · have : v0.Countable := countable_setOf_finite_subset cs\n      exact this.preimage SetLike.coe_injective\n    · refine fun t => mem_closure_iff.2 fun ε εpos => ?_\n      -- t is a compact nonempty set, that we have to approximate uniformly by a a set in `v`.\n      rcases exists_between εpos with ⟨δ, δpos, δlt⟩\n      have δpos' : 0 < δ / 2 := ENNReal.half_pos δpos.ne'\n      -- construct a map F associating to a point in α an approximating point in s, up to δ/2.\n      have Exy : ∀ x, ∃ y, y ∈ s ∧ edist x y < δ / 2 := by\n        intro x\n        rcases mem_closure_iff.1 (s_dense x) (δ / 2) δpos' with ⟨y, ys, hy⟩\n        exact ⟨y, ⟨ys, hy⟩⟩\n      let F x := (Exy x).choose\n      have Fspec : ∀ x, F x ∈ s ∧ edist x (F x) < δ / 2 := fun x => (Exy x).choose_spec\n      -- cover `t` with finitely many balls. Their centers form a set `a`\n      have : TotallyBounded (t : Set α) := t.isCompact.totallyBounded\n      obtain ⟨a : Set α, af : Set.Finite a, ta : (t : Set α) ⊆ ⋃ y ∈ a, ball y (δ / 2)⟩ :=\n        totallyBounded_iff.1 this (δ / 2) δpos'\n      -- replace each center by a nearby approximation in `s`, giving a new set `b`\n      let b := F '' a\n      have : b.Finite := af.image _\n      have tb : ∀ x ∈ t, ∃ y ∈ b, edist x y < δ := by\n        intro x hx\n        rcases mem_iUnion₂.1 (ta hx) with ⟨z, za, Dxz⟩\n        exists F z, mem_image_of_mem _ za\n        calc\n          edist x (F z) ≤ edist x z + edist z (F z) := edist_triangle _ _ _\n          _ < δ / 2 + δ / 2 := ENNReal.add_lt_add Dxz (Fspec z).2\n          _ = δ := ENNReal.add_halves _\n      -- keep only the points in `b` that are close to point in `t`, yielding a new set `c`\n      let c := { y ∈ b | ∃ x ∈ t, edist x y < δ }\n      have : c.Finite := ‹b.Finite›.subset fun x hx => hx.1\n      -- points in `t` are well approximated by points in `c`\n      have tc : ∀ x ∈ t, ∃ y ∈ c, edist x y ≤ δ := by\n        intro x hx\n        rcases tb x hx with ⟨y, yv, Dxy⟩\n        have : y ∈ c := by simpa [c, -mem_image] using ⟨yv, ⟨x, hx, Dxy⟩⟩\n        exact ⟨y, this, le_of_lt Dxy⟩\n      -- points in `c` are well approximated by points in `t`\n      have ct : ∀ y ∈ c, ∃ x ∈ t, edist y x ≤ δ := by\n        rintro y ⟨_, x, xt, Dyx⟩\n        have : edist y x ≤ δ :=\n          calc\n            edist y x = edist x y := edist_comm _ _\n            _ ≤ δ := le_of_lt Dyx\n        exact ⟨x, xt, this⟩\n      -- it follows that their Hausdorff distance is small\n      have : hausdorffEdist (t : Set α) c ≤ δ := hausdorffEdist_le_of_mem_edist tc ct\n      have Dtc : hausdorffEdist (t : Set α) c < ε := this.trans_lt δlt\n      -- the set `c` is not empty, as it is well approximated by a nonempty set\n      have hc : c.Nonempty := nonempty_of_hausdorffEdist_ne_top t.nonempty (ne_top_of_lt Dtc)\n      -- let `d` be the version of `c` in the type `NonemptyCompacts α`\n      let d : NonemptyCompacts α := ⟨⟨c, ‹c.Finite›.isCompact⟩, hc⟩\n      have : c ⊆ s := by\n        intro x hx\n        rcases (mem_image _ _ _).1 hx.1 with ⟨y, ⟨_, yx⟩⟩\n        rw [← yx]\n        exact (Fspec y).1\n      have : d ∈ v := ⟨‹c.Finite›, this⟩\n      -- we have proved that `d` is a good approximation of `t` as requested\n      exact ⟨d, ‹d ∈ v›, Dtc⟩\n  UniformSpace.secondCountable_of_separable (NonemptyCompacts α)\n\n"}
{"name":"Metric.NonemptyCompacts.dist_eq","module":"Mathlib.Topology.MetricSpace.Closeds","initialProofState":"α : Type u\ninst✝ : MetricSpace α\nx y : TopologicalSpace.NonemptyCompacts α\n⊢ Eq (Dist.dist x y) (Metric.hausdorffDist ↑x ↑y)","decl":"/-- The distance on `NonemptyCompacts α` is the Hausdorff distance, by construction -/\ntheorem NonemptyCompacts.dist_eq {x y : NonemptyCompacts α} :\n    dist x y = hausdorffDist (x : Set α) y :=\n  rfl\n\n"}
{"name":"Metric.lipschitz_infDist_set","module":"Mathlib.Topology.MetricSpace.Closeds","initialProofState":"α : Type u\ninst✝ : MetricSpace α\nx : α\n⊢ LipschitzWith 1 fun s => Metric.infDist x ↑s","decl":"theorem lipschitz_infDist_set (x : α) : LipschitzWith 1 fun s : NonemptyCompacts α => infDist x s :=\n  LipschitzWith.of_le_add fun s t => by\n    rw [dist_comm]\n    exact infDist_le_infDist_add_hausdorffDist (edist_ne_top t s)\n\n"}
{"name":"Metric.lipschitz_infDist","module":"Mathlib.Topology.MetricSpace.Closeds","initialProofState":"α : Type u\ninst✝ : MetricSpace α\n⊢ LipschitzWith 2 fun p => Metric.infDist p.1 ↑p.2","decl":"theorem lipschitz_infDist : LipschitzWith 2 fun p : α × NonemptyCompacts α => infDist p.1 p.2 := by\n  -- Porting note: Changed tactic from `exact` to `convert`, because Lean had trouble with 2 = 1 + 1\n  convert @LipschitzWith.uncurry α (NonemptyCompacts α) ℝ _ _ _\n    (fun (x : α) (s : NonemptyCompacts α) => infDist x s) 1 1\n    (fun s => lipschitz_infDist_pt ↑s) lipschitz_infDist_set\n  norm_num\n\n"}
{"name":"Metric.uniformContinuous_infDist_Hausdorff_dist","module":"Mathlib.Topology.MetricSpace.Closeds","initialProofState":"α : Type u\ninst✝ : MetricSpace α\n⊢ UniformContinuous fun p => Metric.infDist p.1 ↑p.2","decl":"theorem uniformContinuous_infDist_Hausdorff_dist :\n    UniformContinuous fun p : α × NonemptyCompacts α => infDist p.1 p.2 :=\n  lipschitz_infDist.uniformContinuous\n\n"}
