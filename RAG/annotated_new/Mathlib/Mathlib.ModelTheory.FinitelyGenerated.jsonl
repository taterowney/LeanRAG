{"name":"FirstOrder.Language.Substructure.fg_def","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\nN : L.Substructure M\n⊢ Iff N.FG (Exists fun S => And S.Finite (Eq ((FirstOrder.Language.Substructure.closure L).toFun S) N))","decl":"theorem fg_def {N : L.Substructure M} : N.FG ↔ ∃ S : Set M, S.Finite ∧ closure L S = N :=\n  ⟨fun ⟨t, h⟩ => ⟨_, Finset.finite_toSet t, h⟩, by\n    rintro ⟨t', h, rfl⟩\n    rcases Finite.exists_finset_coe h with ⟨t, rfl⟩\n    exact ⟨t, rfl⟩⟩\n\n"}
{"name":"FirstOrder.Language.Substructure.fg_iff_exists_fin_generating_family","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\nN : L.Substructure M\n⊢ Iff N.FG (Exists fun n => Exists fun s => Eq ((FirstOrder.Language.Substructure.closure L).toFun (Set.range s)) N)","decl":"theorem fg_iff_exists_fin_generating_family {N : L.Substructure M} :\n    N.FG ↔ ∃ (n : ℕ) (s : Fin n → M), closure L (range s) = N := by\n  rw [fg_def]\n  constructor\n  · rintro ⟨S, Sfin, hS⟩\n    obtain ⟨n, f, rfl⟩ := Sfin.fin_embedding\n    exact ⟨n, f, hS⟩\n  · rintro ⟨n, s, hs⟩\n    exact ⟨range s, finite_range s, hs⟩\n\n"}
{"name":"FirstOrder.Language.Substructure.fg_bot","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\n⊢ Bot.bot.FG","decl":"theorem fg_bot : (⊥ : L.Substructure M).FG :=\n  ⟨∅, by rw [Finset.coe_empty, closure_empty]⟩\n\n"}
{"name":"FirstOrder.Language.Substructure.fg_closure","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\ns : Set M\nhs : s.Finite\n⊢ ((FirstOrder.Language.Substructure.closure L).toFun s).FG","decl":"theorem fg_closure {s : Set M} (hs : s.Finite) : FG (closure L s) :=\n  ⟨hs.toFinset, by rw [hs.coe_toFinset]⟩\n\n"}
{"name":"FirstOrder.Language.Substructure.fg_closure_singleton","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\nx : M\n⊢ ((FirstOrder.Language.Substructure.closure L).toFun (Singleton.singleton x)).FG","decl":"theorem fg_closure_singleton (x : M) : FG (closure L ({x} : Set M)) :=\n  fg_closure (finite_singleton x)\n\n"}
{"name":"FirstOrder.Language.Substructure.FG.sup","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\nN₁ N₂ : L.Substructure M\nhN₁ : N₁.FG\nhN₂ : N₂.FG\n⊢ (Max.max N₁ N₂).FG","decl":"theorem FG.sup {N₁ N₂ : L.Substructure M} (hN₁ : N₁.FG) (hN₂ : N₂.FG) : (N₁ ⊔ N₂).FG :=\n  let ⟨t₁, ht₁⟩ := fg_def.1 hN₁\n  let ⟨t₂, ht₂⟩ := fg_def.1 hN₂\n  fg_def.2 ⟨t₁ ∪ t₂, ht₁.1.union ht₂.1, by rw [closure_union, ht₁.2, ht₂.2]⟩\n\n"}
{"name":"FirstOrder.Language.Substructure.FG.map","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝¹ : L.Structure M\nN : Type u_2\ninst✝ : L.Structure N\nf : L.Hom M N\ns : L.Substructure M\nhs : s.FG\n⊢ (FirstOrder.Language.Substructure.map f s).FG","decl":"theorem FG.map {N : Type*} [L.Structure N] (f : M →[L] N) {s : L.Substructure M} (hs : s.FG) :\n    (s.map f).FG :=\n  let ⟨t, ht⟩ := fg_def.1 hs\n  fg_def.2 ⟨f '' t, ht.1.image _, by rw [closure_image, ht.2]⟩\n\n"}
{"name":"FirstOrder.Language.Substructure.FG.of_map_embedding","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝¹ : L.Structure M\nN : Type u_2\ninst✝ : L.Structure N\nf : L.Embedding M N\ns : L.Substructure M\nhs : (FirstOrder.Language.Substructure.map f.toHom s).FG\n⊢ s.FG","decl":"theorem FG.of_map_embedding {N : Type*} [L.Structure N] (f : M ↪[L] N) {s : L.Substructure M}\n    (hs : (s.map f.toHom).FG) : s.FG := by\n  rcases hs with ⟨t, h⟩\n  rw [fg_def]\n  refine ⟨f ⁻¹' t, t.finite_toSet.preimage f.injective.injOn, ?_⟩\n  have hf : Function.Injective f.toHom := f.injective\n  refine map_injective_of_injective hf ?_\n  rw [← h, map_closure, Embedding.coe_toHom, image_preimage_eq_of_subset]\n  intro x hx\n  have h' := subset_closure (L := L) hx\n  rw [h] at h'\n  exact Hom.map_le_range h'\n\n"}
{"name":"FirstOrder.Language.Substructure.FG.of_finite","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\ns : L.Substructure M\nh : Finite (Subtype fun x => Membership.mem s x)\n⊢ s.FG","decl":"theorem FG.of_finite {s : L.Substructure M} [h : Finite s] : s.FG :=\n  ⟨Set.Finite.toFinset h, by simp only [Finite.coe_toFinset, closure_eq]⟩\n\n"}
{"name":"FirstOrder.Language.Substructure.FG.finite","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.IsRelational\nS : L.Substructure M\nh : S.FG\n⊢ Finite (Subtype fun x => Membership.mem S x)","decl":"theorem FG.finite [L.IsRelational] {S : L.Substructure M} (h : S.FG) : Finite S := by\n  obtain ⟨s, rfl⟩ := h\n  have hs := s.finite_toSet\n  rw [← closure_eq_of_isRelational L (s : Set M)] at hs\n  exact hs\n\n"}
{"name":"FirstOrder.Language.Substructure.fg_iff_finite","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.IsRelational\nS : L.Substructure M\n⊢ Iff S.FG (Finite (Subtype fun x => Membership.mem S x))","decl":"theorem fg_iff_finite [L.IsRelational] {S : L.Substructure M} : S.FG ↔ Finite S :=\n  ⟨FG.finite, fun _ => FG.of_finite⟩\n\n"}
{"name":"FirstOrder.Language.Substructure.cg_def","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\nN : L.Substructure M\n⊢ Iff N.CG (Exists fun S => And S.Countable (Eq ((FirstOrder.Language.Substructure.closure L).toFun S) N))","decl":"theorem cg_def {N : L.Substructure M} : N.CG ↔ ∃ S : Set M, S.Countable ∧ closure L S = N :=\n  Iff.refl _\n\n"}
{"name":"FirstOrder.Language.Substructure.FG.cg","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\nN : L.Substructure M\nh : N.FG\n⊢ N.CG","decl":"theorem FG.cg {N : L.Substructure M} (h : N.FG) : N.CG := by\n  obtain ⟨s, hf, rfl⟩ := fg_def.1 h\n  exact ⟨s, hf.countable, rfl⟩\n\n"}
{"name":"FirstOrder.Language.Substructure.cg_iff_empty_or_exists_nat_generating_family","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\nN : L.Substructure M\n⊢ Iff N.CG (Or (Eq (↑N) EmptyCollection.emptyCollection) (Exists fun s => Eq ((FirstOrder.Language.Substructure.closure L).toFun (Set.range s)) N))","decl":"theorem cg_iff_empty_or_exists_nat_generating_family {N : L.Substructure M} :\n    N.CG ↔ N = (∅ : Set M) ∨ ∃ s : ℕ → M, closure L (range s) = N := by\n  rw [cg_def]\n  constructor\n  · rintro ⟨S, Scount, hS⟩\n    rcases eq_empty_or_nonempty (N : Set M) with h | h\n    · exact Or.intro_left _ h\n    obtain ⟨f, h'⟩ :=\n      (Scount.union (Set.countable_singleton h.some)).exists_eq_range\n        (singleton_nonempty h.some).inr\n    refine Or.intro_right _ ⟨f, ?_⟩\n    rw [← h', closure_union, hS, sup_eq_left, closure_le]\n    exact singleton_subset_iff.2 h.some_mem\n  · intro h\n    cases' h with h h\n    · refine ⟨∅, countable_empty, closure_eq_of_le (empty_subset _) ?_⟩\n      rw [← SetLike.coe_subset_coe, h]\n      exact empty_subset _\n    · obtain ⟨f, rfl⟩ := h\n      exact ⟨range f, countable_range _, rfl⟩\n\n"}
{"name":"FirstOrder.Language.Substructure.cg_bot","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\n⊢ Bot.bot.CG","decl":"theorem cg_bot : (⊥ : L.Substructure M).CG :=\n  fg_bot.cg\n\n"}
{"name":"FirstOrder.Language.Substructure.cg_closure","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\ns : Set M\nhs : s.Countable\n⊢ ((FirstOrder.Language.Substructure.closure L).toFun s).CG","decl":"theorem cg_closure {s : Set M} (hs : s.Countable) : CG (closure L s) :=\n  ⟨s, hs, rfl⟩\n\n"}
{"name":"FirstOrder.Language.Substructure.cg_closure_singleton","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\nx : M\n⊢ ((FirstOrder.Language.Substructure.closure L).toFun (Singleton.singleton x)).CG","decl":"theorem cg_closure_singleton (x : M) : CG (closure L ({x} : Set M)) :=\n  (fg_closure_singleton x).cg\n\n"}
{"name":"FirstOrder.Language.Substructure.CG.sup","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\nN₁ N₂ : L.Substructure M\nhN₁ : N₁.CG\nhN₂ : N₂.CG\n⊢ (Max.max N₁ N₂).CG","decl":"theorem CG.sup {N₁ N₂ : L.Substructure M} (hN₁ : N₁.CG) (hN₂ : N₂.CG) : (N₁ ⊔ N₂).CG :=\n  let ⟨t₁, ht₁⟩ := cg_def.1 hN₁\n  let ⟨t₂, ht₂⟩ := cg_def.1 hN₂\n  cg_def.2 ⟨t₁ ∪ t₂, ht₁.1.union ht₂.1, by rw [closure_union, ht₁.2, ht₂.2]⟩\n\n"}
{"name":"FirstOrder.Language.Substructure.CG.map","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝¹ : L.Structure M\nN : Type u_2\ninst✝ : L.Structure N\nf : L.Hom M N\ns : L.Substructure M\nhs : s.CG\n⊢ (FirstOrder.Language.Substructure.map f s).CG","decl":"theorem CG.map {N : Type*} [L.Structure N] (f : M →[L] N) {s : L.Substructure M} (hs : s.CG) :\n    (s.map f).CG :=\n  let ⟨t, ht⟩ := cg_def.1 hs\n  cg_def.2 ⟨f '' t, ht.1.image _, by rw [closure_image, ht.2]⟩\n\n"}
{"name":"FirstOrder.Language.Substructure.CG.of_map_embedding","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝¹ : L.Structure M\nN : Type u_2\ninst✝ : L.Structure N\nf : L.Embedding M N\ns : L.Substructure M\nhs : (FirstOrder.Language.Substructure.map f.toHom s).CG\n⊢ s.CG","decl":"theorem CG.of_map_embedding {N : Type*} [L.Structure N] (f : M ↪[L] N) {s : L.Substructure M}\n    (hs : (s.map f.toHom).CG) : s.CG := by\n  rcases hs with ⟨t, h1, h2⟩\n  rw [cg_def]\n  refine ⟨f ⁻¹' t, h1.preimage f.injective, ?_⟩\n  have hf : Function.Injective f.toHom := f.injective\n  refine map_injective_of_injective hf ?_\n  rw [← h2, map_closure, Embedding.coe_toHom, image_preimage_eq_of_subset]\n  intro x hx\n  have h' := subset_closure (L := L) hx\n  rw [h2] at h'\n  exact Hom.map_le_range h'\n\n"}
{"name":"FirstOrder.Language.Substructure.cg_iff_countable","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : Countable (Sigma fun l => L.Functions l)\ns : L.Substructure M\n⊢ Iff s.CG (Countable (Subtype fun x => Membership.mem s x))","decl":"theorem cg_iff_countable [Countable (Σl, L.Functions l)] {s : L.Substructure M} :\n    s.CG ↔ Countable s := by\n  refine ⟨?_, fun h => ⟨s, h.to_set, s.closure_eq⟩⟩\n  rintro ⟨s, h, rfl⟩\n  exact h.substructure_closure L\n\n"}
{"name":"FirstOrder.Language.Substructure.cg_of_countable","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\ns : L.Substructure M\nh : Countable (Subtype fun x => Membership.mem s x)\n⊢ s.CG","decl":"theorem cg_of_countable {s : L.Substructure M} [h : Countable s] : s.CG :=\n  ⟨s, h.to_set, s.closure_eq⟩\n\n"}
{"name":"FirstOrder.Language.Structure.FG.out","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\nself : FirstOrder.Language.Structure.FG L M\n⊢ Top.top.FG","decl":"/-- A structure is finitely generated if it is the closure of a finite subset. -/\nclass FG : Prop where\n  out : (⊤ : L.Substructure M).FG\n\n"}
{"name":"FirstOrder.Language.Structure.CG.out","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\nself : FirstOrder.Language.Structure.CG L M\n⊢ Top.top.CG","decl":"/-- A structure is countably generated if it is the closure of a countable subset. -/\nclass CG : Prop where\n  out : (⊤ : L.Substructure M).CG\n\n"}
{"name":"FirstOrder.Language.Structure.fg_def","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\n⊢ Iff (FirstOrder.Language.Structure.FG L M) Top.top.FG","decl":"theorem fg_def : FG L M ↔ (⊤ : L.Substructure M).FG :=\n  ⟨fun h => h.1, fun h => ⟨h⟩⟩\n\n"}
{"name":"FirstOrder.Language.Structure.fg_iff","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\n⊢ Iff (FirstOrder.Language.Structure.FG L M) (Exists fun S => And S.Finite (Eq ((FirstOrder.Language.Substructure.closure L).toFun S) Top.top))","decl":"/-- An equivalent expression of `Structure.FG` in terms of `Set.Finite` instead of `Finset`. -/\ntheorem fg_iff : FG L M ↔ ∃ S : Set M, S.Finite ∧ closure L S = (⊤ : L.Substructure M) := by\n  rw [fg_def, Substructure.fg_def]\n\n"}
{"name":"FirstOrder.Language.Structure.FG.range","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝¹ : L.Structure M\nN : Type u_2\ninst✝ : L.Structure N\nh : FirstOrder.Language.Structure.FG L M\nf : L.Hom M N\n⊢ f.range.FG","decl":"theorem FG.range {N : Type*} [L.Structure N] (h : FG L M) (f : M →[L] N) : f.range.FG := by\n  rw [Hom.range_eq_map]\n  exact (fg_def.1 h).map f\n\n"}
{"name":"FirstOrder.Language.Structure.FG.map_of_surjective","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝¹ : L.Structure M\nN : Type u_2\ninst✝ : L.Structure N\nh : FirstOrder.Language.Structure.FG L M\nf : L.Hom M N\nhs : Function.Surjective ⇑f\n⊢ FirstOrder.Language.Structure.FG L N","decl":"theorem FG.map_of_surjective {N : Type*} [L.Structure N] (h : FG L M) (f : M →[L] N)\n    (hs : Function.Surjective f) : FG L N := by\n  rw [← Hom.range_eq_top] at hs\n  rw [fg_def, ← hs]\n  exact h.range f\n\n"}
{"name":"FirstOrder.Language.Structure.FG.countable_hom","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝² : L.Structure M\nN : Type u_2\ninst✝¹ : L.Structure N\ninst✝ : Countable N\nh : FirstOrder.Language.Structure.FG L M\n⊢ Countable (L.Hom M N)","decl":"theorem FG.countable_hom (N : Type*) [L.Structure N] [Countable N] (h : FG L M) :\n    Countable (M →[L] N) := by\n  let ⟨S, finite_S, closure_S⟩ := fg_iff.1 h\n  let g : (M →[L] N) → (S → N) :=\n    fun f ↦ f ∘ (↑)\n  have g_inj : Function.Injective g := by\n    intro f f' h\n    apply Hom.eq_of_eqOn_dense closure_S\n    intro x x_in_S\n    exact congr_fun h ⟨x, x_in_S⟩\n  have : Finite ↑S := (S.finite_coe_iff).2 finite_S\n  exact Function.Embedding.countable ⟨g, g_inj⟩\n\n"}
{"name":"FirstOrder.Language.Structure.FG.instCountable_hom","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝² : L.Structure M\nN : Type u_2\ninst✝¹ : L.Structure N\ninst✝ : Countable N\nh : FirstOrder.Language.Structure.FG L M\n⊢ Countable (L.Hom M N)","decl":"instance FG.instCountable_hom (N : Type*) [L.Structure N] [Countable N] [h : FG L M] :\n    Countable (M →[L] N) :=\n  FG.countable_hom N h\n\n"}
{"name":"FirstOrder.Language.Structure.FG.countable_embedding","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝² : L.Structure M\nN : Type u_2\ninst✝¹ : L.Structure N\ninst✝ : Countable N\nx✝ : FirstOrder.Language.Structure.FG L M\n⊢ Countable (L.Embedding M N)","decl":"theorem FG.countable_embedding (N : Type*) [L.Structure N] [Countable N] (_ : FG L M) :\n    Countable (M ↪[L] N) :=\n  Function.Embedding.countable ⟨Embedding.toHom, Embedding.toHom_injective⟩\n\n"}
{"name":"FirstOrder.Language.Structure.Fg.instCountable_embedding","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝² : L.Structure M\nN : Type u_2\ninst✝¹ : L.Structure N\ninst✝ : Countable N\nh : FirstOrder.Language.Structure.FG L M\n⊢ Countable (L.Embedding M N)","decl":"instance Fg.instCountable_embedding (N : Type*) [L.Structure N]\n    [Countable N] [h : FG L M] : Countable (M ↪[L] N) :=\n  FG.countable_embedding N h\n\n"}
{"name":"FirstOrder.Language.Structure.FG.of_finite","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : Finite M\n⊢ FirstOrder.Language.Structure.FG L M","decl":"theorem FG.of_finite [Finite M] : FG L M := by\n  simp only [fg_def, Substructure.FG.of_finite, topEquiv.toEquiv.finite_iff]\n\n"}
{"name":"FirstOrder.Language.Structure.FG.finite","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.IsRelational\nh : FirstOrder.Language.Structure.FG L M\n⊢ Finite M","decl":"theorem FG.finite [L.IsRelational] (h : FG L M) : Finite M :=\n  Finite.of_finite_univ (Substructure.FG.finite (fg_def.1 h))\n\n"}
{"name":"FirstOrder.Language.Structure.fg_iff_finite","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.IsRelational\n⊢ Iff (FirstOrder.Language.Structure.FG L M) (Finite M)","decl":"theorem fg_iff_finite [L.IsRelational] : FG L M ↔ Finite M :=\n  ⟨FG.finite, fun _ => FG.of_finite⟩\n\n"}
{"name":"FirstOrder.Language.Structure.cg_def","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\n⊢ Iff (FirstOrder.Language.Structure.CG L M) Top.top.CG","decl":"theorem cg_def : CG L M ↔ (⊤ : L.Substructure M).CG :=\n  ⟨fun h => h.1, fun h => ⟨h⟩⟩\n\n"}
{"name":"FirstOrder.Language.Structure.cg_iff","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\n⊢ Iff (FirstOrder.Language.Structure.CG L M) (Exists fun S => And S.Countable (Eq ((FirstOrder.Language.Substructure.closure L).toFun S) Top.top))","decl":"/-- An equivalent expression of `Structure.cg`. -/\ntheorem cg_iff : CG L M ↔ ∃ S : Set M, S.Countable ∧ closure L S = (⊤ : L.Substructure M) := by\n  rw [cg_def, Substructure.cg_def]\n\n"}
{"name":"FirstOrder.Language.Structure.CG.range","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝¹ : L.Structure M\nN : Type u_2\ninst✝ : L.Structure N\nh : FirstOrder.Language.Structure.CG L M\nf : L.Hom M N\n⊢ f.range.CG","decl":"theorem CG.range {N : Type*} [L.Structure N] (h : CG L M) (f : M →[L] N) : f.range.CG := by\n  rw [Hom.range_eq_map]\n  exact (cg_def.1 h).map f\n\n"}
{"name":"FirstOrder.Language.Structure.CG.map_of_surjective","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝¹ : L.Structure M\nN : Type u_2\ninst✝ : L.Structure N\nh : FirstOrder.Language.Structure.CG L M\nf : L.Hom M N\nhs : Function.Surjective ⇑f\n⊢ FirstOrder.Language.Structure.CG L N","decl":"theorem CG.map_of_surjective {N : Type*} [L.Structure N] (h : CG L M) (f : M →[L] N)\n    (hs : Function.Surjective f) : CG L N := by\n  rw [← Hom.range_eq_top] at hs\n  rw [cg_def, ← hs]\n  exact h.range f\n\n"}
{"name":"FirstOrder.Language.Structure.cg_iff_countable","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : Countable (Sigma fun l => L.Functions l)\n⊢ Iff (FirstOrder.Language.Structure.CG L M) (Countable M)","decl":"theorem cg_iff_countable [Countable (Σl, L.Functions l)] : CG L M ↔ Countable M := by\n  rw [cg_def, Substructure.cg_iff_countable, topEquiv.toEquiv.countable_iff]\n\n"}
{"name":"FirstOrder.Language.Structure.cg_of_countable","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : Countable M\n⊢ FirstOrder.Language.Structure.CG L M","decl":"theorem cg_of_countable [Countable M] : CG L M := by\n  simp only [cg_def, Substructure.cg_of_countable, topEquiv.toEquiv.countable_iff]\n\n"}
{"name":"FirstOrder.Language.Structure.FG.cg","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\nh : FirstOrder.Language.Structure.FG L M\n⊢ FirstOrder.Language.Structure.CG L M","decl":"theorem FG.cg (h : FG L M) : CG L M :=\n  cg_def.2 (fg_def.1 h).cg\n\n"}
{"name":"FirstOrder.Language.Structure.cg_of_fg","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\nh : FirstOrder.Language.Structure.FG L M\n⊢ FirstOrder.Language.Structure.CG L M","decl":"instance (priority := 100) cg_of_fg [h : FG L M] : CG L M :=\n  h.cg\n\n"}
{"name":"FirstOrder.Language.Equiv.fg_iff","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝¹ : L.Structure M\nN : Type u_2\ninst✝ : L.Structure N\nf : L.Equiv M N\n⊢ Iff (FirstOrder.Language.Structure.FG L M) (FirstOrder.Language.Structure.FG L N)","decl":"theorem Equiv.fg_iff {N : Type*} [L.Structure N] (f : M ≃[L] N) :\n    Structure.FG L M ↔ Structure.FG L N :=\n  ⟨fun h => h.map_of_surjective f.toHom f.toEquiv.surjective, fun h =>\n    h.map_of_surjective f.symm.toHom f.toEquiv.symm.surjective⟩\n\n"}
{"name":"FirstOrder.Language.Substructure.fg_iff_structure_fg","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\nS : L.Substructure M\n⊢ Iff S.FG (FirstOrder.Language.Structure.FG L (Subtype fun x => Membership.mem S x))","decl":"theorem Substructure.fg_iff_structure_fg (S : L.Substructure M) : S.FG ↔ Structure.FG L S := by\n  rw [Structure.fg_def]\n  refine ⟨fun h => FG.of_map_embedding S.subtype ?_, fun h => ?_⟩\n  · rw [← Hom.range_eq_map, range_subtype]\n    exact h\n  · have h := h.map S.subtype.toHom\n    rw [← Hom.range_eq_map, range_subtype] at h\n    exact h\n\n"}
{"name":"FirstOrder.Language.Equiv.cg_iff","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝¹ : L.Structure M\nN : Type u_2\ninst✝ : L.Structure N\nf : L.Equiv M N\n⊢ Iff (FirstOrder.Language.Structure.CG L M) (FirstOrder.Language.Structure.CG L N)","decl":"theorem Equiv.cg_iff {N : Type*} [L.Structure N] (f : M ≃[L] N) :\n    Structure.CG L M ↔ Structure.CG L N :=\n  ⟨fun h => h.map_of_surjective f.toHom f.toEquiv.surjective, fun h =>\n    h.map_of_surjective f.symm.toHom f.toEquiv.symm.surjective⟩\n\n"}
{"name":"FirstOrder.Language.Substructure.cg_iff_structure_cg","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\nS : L.Substructure M\n⊢ Iff S.CG (FirstOrder.Language.Structure.CG L (Subtype fun x => Membership.mem S x))","decl":"theorem Substructure.cg_iff_structure_cg (S : L.Substructure M) : S.CG ↔ Structure.CG L S := by\n  rw [Structure.cg_def]\n  refine ⟨fun h => CG.of_map_embedding S.subtype ?_, fun h => ?_⟩\n  · rw [← Hom.range_eq_map, range_subtype]\n    exact h\n  · have h := h.map S.subtype.toHom\n    rw [← Hom.range_eq_map, range_subtype] at h\n    exact h\n\n"}
{"name":"FirstOrder.Language.Substructure.countable_fg_substructures_of_countable","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : Countable M\n⊢ Countable (Subtype fun S => S.FG)","decl":"theorem Substructure.countable_fg_substructures_of_countable [Countable M] :\n    Countable { S : L.Substructure M // S.FG } := by\n  let g : { S : L.Substructure M // S.FG } → Finset M :=\n    fun S ↦ Exists.choose S.prop\n  have g_inj : Function.Injective g := by\n    intro S S' h\n    apply Subtype.eq\n    rw [(Exists.choose_spec S.prop).symm, (Exists.choose_spec S'.prop).symm]\n    exact congr_arg ((closure L) ∘ Finset.toSet) h\n  exact Function.Embedding.countable ⟨g, g_inj⟩\n\n"}
{"name":"FirstOrder.Language.Substructure.instCountable_fg_substructures_of_countable","module":"Mathlib.ModelTheory.FinitelyGenerated","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : Countable M\n⊢ Countable (Subtype fun S => S.FG)","decl":"instance Substructure.instCountable_fg_substructures_of_countable [Countable M] :\n    Countable { S : L.Substructure M // S.FG } :=\n  countable_fg_substructures_of_countable\n\n"}
