{"name":"CategoryTheory.Limits.HasIterationOfShape.hasColimitsOfShape_of_isSuccLimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Preorder.HasIterationOfShape","initialProofState":"J : Type w\ninst✝¹ : LinearOrder J\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Limits.HasIterationOfShape J C\nj : J\nhj : Order.IsSuccLimit j\n⊢ CategoryTheory.Limits.HasColimitsOfShape (↑(Set.Iio j)) C","decl":"/-- A category `C` has iterations of shape a linearly ordered type `J`\nwhen certain specific shapes of colimits exists: colimits indexed by `J`,\nand by `Set.Iio j` for `j : J`. -/\nclass HasIterationOfShape : Prop where\n  hasColimitsOfShape_of_isSuccLimit (j : J) (hj : Order.IsSuccLimit j) :\n    HasColimitsOfShape (Set.Iio j) C := by infer_instance\n  hasColimitsOfShape : HasColimitsOfShape J C := by infer_instance\n\n"}
{"name":"CategoryTheory.Limits.HasIterationOfShape.hasColimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Shapes.Preorder.HasIterationOfShape","initialProofState":"J : Type w\ninst✝¹ : LinearOrder J\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Limits.HasIterationOfShape J C\n⊢ CategoryTheory.Limits.HasColimitsOfShape J C","decl":"/-- A category `C` has iterations of shape a linearly ordered type `J`\nwhen certain specific shapes of colimits exists: colimits indexed by `J`,\nand by `Set.Iio j` for `j : J`. -/\nclass HasIterationOfShape : Prop where\n  hasColimitsOfShape_of_isSuccLimit (j : J) (hj : Order.IsSuccLimit j) :\n    HasColimitsOfShape (Set.Iio j) C := by infer_instance\n  hasColimitsOfShape : HasColimitsOfShape J C := by infer_instance\n\n"}
{"name":"CategoryTheory.Limits.hasColimitsOfShape_of_isSuccLimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Preorder.HasIterationOfShape","initialProofState":"J : Type w\ninst✝² : LinearOrder J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasIterationOfShape J C\nj : J\nhj : Order.IsSuccLimit j\n⊢ CategoryTheory.Limits.HasColimitsOfShape (↑(Set.Iio j)) C","decl":"variable {J} in\nlemma hasColimitsOfShape_of_isSuccLimit (j : J)\n    (hj : Order.IsSuccLimit j) :\n    HasColimitsOfShape (Set.Iio j) C :=\n  HasIterationOfShape.hasColimitsOfShape_of_isSuccLimit j hj\n\n"}
{"name":"CategoryTheory.Limits.hasColimitsOfShape_of_isSuccLimit'","module":"Mathlib.CategoryTheory.Limits.Shapes.Preorder.HasIterationOfShape","initialProofState":"J : Type w\ninst✝³ : LinearOrder J\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasIterationOfShape J C\nα : Type u_1\ninst✝ : PartialOrder α\nh : PrincipalSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\nhα : Order.IsSuccLimit h.top\n⊢ CategoryTheory.Limits.HasColimitsOfShape α C","decl":"variable {J} in\nlemma hasColimitsOfShape_of_isSuccLimit'\n    {α : Type*} [PartialOrder α] (h : α <i J) (hα : Order.IsSuccLimit h.top) :\n    HasColimitsOfShape α C := by\n  have := hasColimitsOfShape_of_isSuccLimit C h.top hα\n  exact hasColimitsOfShape_of_equivalence h.orderIsoIio.equivalence.symm\n\n"}
{"name":"CategoryTheory.Limits.instHasIterationOfShapeArrow","module":"Mathlib.CategoryTheory.Limits.Shapes.Preorder.HasIterationOfShape","initialProofState":"J : Type w\ninst✝¹ : LinearOrder J\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ CategoryTheory.Limits.HasIterationOfShape J (CategoryTheory.Arrow C)","decl":"instance : HasIterationOfShape J (Arrow C) where\n  hasColimitsOfShape_of_isSuccLimit j hj := by\n    have := hasColimitsOfShape_of_isSuccLimit C j hj\n    infer_instance\n\n"}
{"name":"CategoryTheory.Limits.instHasIterationOfShapeFunctor","module":"Mathlib.CategoryTheory.Limits.Shapes.Preorder.HasIterationOfShape","initialProofState":"J : Type w\ninst✝² : LinearOrder J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nK : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} K\n⊢ CategoryTheory.Limits.HasIterationOfShape J (CategoryTheory.Functor K C)","decl":"instance : HasIterationOfShape J (K ⥤ C) where\n  hasColimitsOfShape_of_isSuccLimit j hj := by\n    have := hasColimitsOfShape_of_isSuccLimit C j hj\n    infer_instance\n\n"}
{"name":"CategoryTheory.Limits.hasColimitsOfShape_of_initialSeg","module":"Mathlib.CategoryTheory.Limits.Shapes.Preorder.HasIterationOfShape","initialProofState":"J : Type w\ninst✝⁶ : LinearOrder J\nC : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.Limits.HasIterationOfShape J C\ninst✝³ : SuccOrder J\ninst✝² : WellFoundedLT J\nα : Type u_1\ninst✝¹ : LinearOrder α\nf : InitialSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\ninst✝ : Nonempty α\n⊢ CategoryTheory.Limits.HasColimitsOfShape α C","decl":"lemma hasColimitsOfShape_of_initialSeg\n    {α : Type*} [LinearOrder α] (f : α ≤i J) [Nonempty α] :\n    HasColimitsOfShape α C := by\n  by_cases hf : Function.Surjective f\n  · exact hasColimitsOfShape_of_equivalence\n      (OrderIso.ofRelIsoLT (RelIso.ofSurjective f.toRelEmbedding hf)).equivalence.symm\n  · let s := f.toPrincipalSeg hf\n    obtain ⟨i, hi₀⟩ : ∃ i, i = s.top := ⟨_, rfl⟩\n    induction i using SuccOrder.limitRecOn with\n    | hm i hi =>\n      subst hi₀\n      exact (hi.not_lt (s.lt_top (Classical.arbitrary _))).elim\n    | hs i hi _ =>\n      obtain ⟨a, rfl⟩ := (s.mem_range_iff_rel (b := i)).2 (by\n        simpa only [← hi₀] using Order.lt_succ_of_not_isMax hi)\n      have : OrderTop α :=\n        { top := a\n          le_top b := by\n            rw [← s.le_iff_le]\n            exact Order.le_of_lt_succ (by simpa only [hi₀] using s.lt_top b) }\n      infer_instance\n    | hl i hi =>\n      subst hi₀\n      exact hasColimitsOfShape_of_isSuccLimit' C s hi\n\n"}
{"name":"CategoryTheory.Limits.hasIterationOfShape_of_initialSeg","module":"Mathlib.CategoryTheory.Limits.Shapes.Preorder.HasIterationOfShape","initialProofState":"J : Type w\ninst✝⁶ : LinearOrder J\nC : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.Limits.HasIterationOfShape J C\ninst✝³ : SuccOrder J\ninst✝² : WellFoundedLT J\nα : Type u_1\ninst✝¹ : LinearOrder α\nh : InitialSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\ninst✝ : Nonempty α\n⊢ CategoryTheory.Limits.HasIterationOfShape α C","decl":"lemma hasIterationOfShape_of_initialSeg {α : Type*} [LinearOrder α]\n    (h : α ≤i J) [Nonempty α] :\n    HasIterationOfShape α C where\n  hasColimitsOfShape := hasColimitsOfShape_of_initialSeg C h\n  hasColimitsOfShape_of_isSuccLimit j hj := by\n    have : Nonempty (Set.Iio j) := by\n      obtain ⟨a, ha⟩ := not_isMin_iff.1 hj.1\n      exact ⟨⟨a, ha⟩⟩\n    exact hasColimitsOfShape_of_initialSeg  _\n      (InitialSeg.trans (Set.principalSegIio j) h)\n\n"}
