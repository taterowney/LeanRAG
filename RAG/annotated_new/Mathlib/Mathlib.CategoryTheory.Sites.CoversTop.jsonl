{"name":"CategoryTheory.GrothendieckTopology.coversTop_iff_of_isTerminal","module":"Mathlib.CategoryTheory.Sites.CoversTop","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nX : C\nhX : CategoryTheory.Limits.IsTerminal X\nI : Type u_1\nY : I ‚Üí C\n‚ä¢ Iff (J.CoversTop Y) (Membership.mem (J X) (CategoryTheory.Sieve.ofObjects Y X))","decl":"lemma coversTop_iff_of_isTerminal (X : C) (hX : IsTerminal X)\n    {I : Type*} (Y : I ‚Üí C) :\n    J.CoversTop Y ‚Üî Sieve.ofObjects Y X ‚àà J X := by\n  constructor\n  ¬∑ tauto\n  ¬∑ intro h W\n    apply J.superset_covering _ (J.pullback_stable (hX.from W) h)\n    rintro T a ‚ü®i, ‚ü®b‚ü©‚ü©\n    exact ‚ü®i, ‚ü®b‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.CoversTop.ext","module":"Mathlib.CategoryTheory.Sites.CoversTop","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} A\nI : Type u_1\nY : I ‚Üí C\nhY : J.CoversTop Y\nF : CategoryTheory.Sheaf J A\nc : CategoryTheory.Limits.Cone F.val\nhc : CategoryTheory.Limits.IsLimit c\nX : A\nf g : Quiver.Hom X c.pt\nh : ‚àÄ (i : I), Eq (CategoryTheory.CategoryStruct.comp f (c.œÄ.app { unop := Y i })) (CategoryTheory.CategoryStruct.comp g (c.œÄ.app { unop := Y i }))\n‚ä¢ Eq f g","decl":"lemma ext (F : Sheaf J A) {c : Cone F.1} (hc : IsLimit c) {X : A} {f g : X ‚ü∂ c.pt}\n    (h : ‚àÄ (i : I), f ‚â´ c.œÄ.app (Opposite.op (Y i)) =\n      g ‚â´ c.œÄ.app (Opposite.op (Y i))) :\n    f = g := by\n  refine hc.hom_ext (fun Z => F.2.hom_ext (hY.cover Z.unop) _ _ ?_)\n  rintro ‚ü®W, a, ‚ü®i, ‚ü®b‚ü©‚ü©‚ü©\n  simpa using h i =‚â´ F.1.map b.op\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.CoversTop.sections_ext","module":"Mathlib.CategoryTheory.Sites.CoversTop","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nI : Type u_1\nY : I ‚Üí C\nhY : J.CoversTop Y\nF : CategoryTheory.Sheaf J (Type u_2)\nx y : ‚ÜëF.val.sections\nh : ‚àÄ (i : I), Eq (‚Üëx { unop := Y i }) (‚Üëy { unop := Y i })\n‚ä¢ Eq x y","decl":"lemma sections_ext (F : Sheaf J (Type _)) {x y : F.1.sections}\n    (h : ‚àÄ (i : I), x.1 (Opposite.op (Y i)) = y.1 (Opposite.op (Y i))) :\n    x = y := by\n  ext W\n  apply (Presieve.isSeparated_of_isSheaf J F.1\n    ((isSheaf_iff_isSheaf_of_type _ _).1 F.2) _ (hY W.unop)).ext\n  rintro T a ‚ü®i, ‚ü®b‚ü©‚ü©\n  simpa using congr_arg (F.1.map b.op) (h i)\n\n"}
{"name":"CategoryTheory.Presheaf.FamilyOfElementsOnObjects.IsCompatible.familyOfElements_apply","module":"Mathlib.CategoryTheory.Sites.CoversTop","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nI : Type u_1\nY : I ‚Üí C\nx : CategoryTheory.Presheaf.FamilyOfElementsOnObjects F Y\nhx : x.IsCompatible\nX Z : C\nf : Quiver.Hom Z X\ni : I\nœÜ : Quiver.Hom Z (Y i)\n‚ä¢ Eq (x.familyOfElements X f ‚ãØ) (F.map œÜ.op (x i))","decl":"lemma familyOfElements_apply (hx : x.IsCompatible) {X Z : C} (f : Z ‚ü∂ X) (i : I) (œÜ : Z ‚ü∂ Y i) :\n    familyOfElements x X f ‚ü®i, ‚ü®œÜ‚ü©‚ü© = F.map œÜ.op (x i) := by\n  apply hx\n\n"}
{"name":"CategoryTheory.Presheaf.FamilyOfElementsOnObjects.IsCompatible.familyOfElements_isCompatible","module":"Mathlib.CategoryTheory.Sites.CoversTop","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nI : Type u_1\nY : I ‚Üí C\nx : CategoryTheory.Presheaf.FamilyOfElementsOnObjects F Y\nhx : x.IsCompatible\nX : C\n‚ä¢ (x.familyOfElements X).Compatible","decl":"lemma familyOfElements_isCompatible (hx : x.IsCompatible) (X : C) :\n    (familyOfElements x X).Compatible := by\n  intro Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ ‚ü®i‚ÇÅ, ‚ü®œÜ‚ÇÅ‚ü©‚ü© ‚ü®i‚ÇÇ, ‚ü®œÜ‚ÇÇ‚ü©‚ü© _\n  simpa [hx.familyOfElements_apply f‚ÇÅ i‚ÇÅ œÜ‚ÇÅ,\n    hx.familyOfElements_apply f‚ÇÇ i‚ÇÇ œÜ‚ÇÇ] using hx Z i‚ÇÅ i‚ÇÇ (g‚ÇÅ ‚â´ œÜ‚ÇÅ) (g‚ÇÇ ‚â´ œÜ‚ÇÇ)\n\n"}
{"name":"CategoryTheory.Presheaf.FamilyOfElementsOnObjects.IsCompatible.existsUnique_section","module":"Mathlib.CategoryTheory.Sites.CoversTop","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nI : Type u_1\nY : I ‚Üí C\nx : CategoryTheory.Presheaf.FamilyOfElementsOnObjects F Y\nhx : x.IsCompatible\nhY : J.CoversTop Y\nhF : CategoryTheory.Presheaf.IsSheaf J F\n‚ä¢ ExistsUnique fun s => ‚àÄ (i : I), Eq (‚Üës { unop := Y i }) (x i)","decl":"lemma existsUnique_section (hx : x.IsCompatible) (hY : J.CoversTop Y) (hF : IsSheaf J F) :\n    ‚àÉ! (s : F.sections), ‚àÄ (i : I), s.1 (Opposite.op (Y i)) = x i := by\n  have H := (isSheaf_iff_isSheaf_of_type _ _).1 hF\n  apply existsUnique_of_exists_of_unique\n  ¬∑ let s := fun (X : C) => (H _ (hY X)).amalgamate _\n      (hx.familyOfElements_isCompatible X)\n    have hs : ‚àÄ {X : C} (i : I) (f : X ‚ü∂ Y i), s X = F.map f.op (x i) := fun {X} i f => by\n      have h := Presieve.IsSheafFor.valid_glue (H _ (hY X))\n          (hx.familyOfElements_isCompatible _) (ùüô _) ‚ü®i, ‚ü®f‚ü©‚ü©\n      simp only [op_id, F.map_id, types_id_apply] at h\n      exact h.trans (hx.familyOfElements_apply _ _ _)\n    have hs' : ‚àÄ {W X : C} (a : W ‚ü∂ X) (i : I) (_ : W ‚ü∂ Y i), F.map a.op (s X) = s W := by\n      intro W X a i b\n      rw [hs i b]\n      exact (Presieve.IsSheafFor.valid_glue (H _ (hY X))\n        (hx.familyOfElements_isCompatible _) a ‚ü®i, ‚ü®b‚ü©‚ü©).trans (familyOfElements_apply hx _ _ _)\n    refine ‚ü®‚ü®fun X => s X.unop, ?_‚ü©, fun i => (hs i (ùüô (Y i))).trans (by simp)‚ü©\n    rintro ‚ü®Y‚ÇÅ‚ü© ‚ü®Y‚ÇÇ‚ü© ‚ü®f : Y‚ÇÇ ‚ü∂ Y‚ÇÅ‚ü©\n    change F.map f.op (s Y‚ÇÅ) = s Y‚ÇÇ\n    apply (Presieve.isSeparated_of_isSheaf J F H _ (hY Y‚ÇÇ)).ext\n    rintro Z œÜ ‚ü®i, ‚ü®g‚ü©‚ü©\n    rw [hs' œÜ i g, ‚Üê hs' (œÜ ‚â´ f) i g, op_comp, F.map_comp]\n    rfl\n  ¬∑ intro y‚ÇÅ y‚ÇÇ hy‚ÇÅ hy‚ÇÇ\n    exact hY.sections_ext ‚ü®F, hF‚ü© (fun i => by rw [hy‚ÇÅ, hy‚ÇÇ])\n\n"}
{"name":"CategoryTheory.Presheaf.FamilyOfElementsOnObjects.IsCompatible.exists_unique_section","module":"Mathlib.CategoryTheory.Sites.CoversTop","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nI : Type u_1\nY : I ‚Üí C\nx : CategoryTheory.Presheaf.FamilyOfElementsOnObjects F Y\nhx : x.IsCompatible\nhY : J.CoversTop Y\nhF : CategoryTheory.Presheaf.IsSheaf J F\n‚ä¢ ExistsUnique fun s => ‚àÄ (i : I), Eq (‚Üës { unop := Y i }) (x i)","decl":"@[deprecated (since := \"2024-12-17\")] alias exists_unique_section := existsUnique_section\n\n"}
{"name":"CategoryTheory.Presheaf.FamilyOfElementsOnObjects.IsCompatible.section_apply","module":"Mathlib.CategoryTheory.Sites.CoversTop","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nI : Type u_1\nY : I ‚Üí C\nx : CategoryTheory.Presheaf.FamilyOfElementsOnObjects F Y\nhx : x.IsCompatible\nhY : J.CoversTop Y\nhF : CategoryTheory.Presheaf.IsSheaf J F\ni : I\n‚ä¢ Eq (‚Üë(hx.section_ hY hF) { unop := Y i }) (x i)","decl":"@[simp]\nlemma section_apply (i : I) : (hx.section_ hY hF).1 (Opposite.op (Y i)) = x i :=\n  (hx.existsUnique_section hY hF).choose_spec.1 i\n\n"}
