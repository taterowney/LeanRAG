{"name":"AdicCompletion.map_surjective","module":"Mathlib.RingTheory.AdicCompletion.Exactness","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\nI : Ideal R\nM : Type v\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type w\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M N\nhf : Function.Surjective ⇑f\n⊢ Function.Surjective ⇑(AdicCompletion.map I f)","decl":"variable (I) in\n/-- Adic completion preserves surjectivity -/\ntheorem map_surjective (hf : Function.Surjective f) : Function.Surjective (map I f) := fun y ↦ by\n  apply AdicCompletion.induction_on I N y (fun b ↦ ?_)\n  let a := mapPreimage hf b\n  refine ⟨AdicCompletion.mk I M (AdicCauchySequence.mk I M (fun n ↦ (a n : M)) ?_), ?_⟩\n  · refine fun n ↦ SModEq.symm ?_\n    simp only [SModEq.symm, SModEq, mapPreimage, Submodule.Quotient.mk_sub,\n      sub_eq_self, Submodule.Quotient.mk_eq_zero, SetLike.coe_mem, a]\n  · exact _root_.AdicCompletion.ext fun n ↦ congrArg _ ((a n).property)\n\n"}
{"name":"AdicCompletion.map_injective","module":"Mathlib.RingTheory.AdicCompletion.Exactness","initialProofState":"R : Type u\ninst✝⁶ : CommRing R\nI : Ideal R\nM : Type u\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nN : Type u\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : IsNoetherianRing R\ninst✝ : Module.Finite R N\nf : LinearMap (RingHom.id R) M N\nhf : Function.Injective ⇑f\n⊢ Function.Injective ⇑(AdicCompletion.map I f)","decl":"/-- Adic completion preserves injectivity of finite modules over a Noetherian ring. -/\ntheorem map_injective {f : M →ₗ[R] N} (hf : Function.Injective f) :\n    Function.Injective (map I f) := by\n  obtain ⟨k, hk⟩ := Ideal.exists_pow_inf_eq_pow_smul I (range f)\n  rw [← LinearMap.ker_eq_bot, LinearMap.ker_eq_bot']\n  intro x\n  apply AdicCompletion.induction_on I M x (fun a ↦ ?_)\n  intro hx\n  refine AdicCompletion.mk_zero_of _ _ _ ⟨42, fun n _ ↦ ⟨n + k, by omega, n, by omega, ?_⟩⟩\n  rw [← Submodule.comap_map_eq_of_injective hf (I ^ n • ⊤ : Submodule R M),\n    Submodule.map_smul'', Submodule.map_top]\n  apply (smul_mono_right _ inf_le_right : I ^ n • (I ^ k • ⊤ ⊓ (range f)) ≤ _)\n  nth_rw 1 [show n = n + k - k by omega]\n  rw [← hk (n + k) (show n + k ≥ k by omega)]\n  exact ⟨by simpa using congrArg (fun x ↦ x.val (n + k)) hx, ⟨a (n + k), rfl⟩⟩\n\n"}
{"name":"AdicCompletion.map_exact","module":"Mathlib.RingTheory.AdicCompletion.Exactness","initialProofState":"R : Type u\ninst✝⁸ : CommRing R\nI : Ideal R\nM : Type u\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\nN : Type u\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nP : Type u\ninst✝³ : AddCommGroup P\ninst✝² : Module R P\ninst✝¹ : IsNoetherianRing R\ninst✝ : Module.Finite R N\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\nhf : Function.Injective ⇑f\nhfg : Function.Exact ⇑f ⇑g\nhg : Function.Surjective ⇑g\n⊢ Function.Exact ⇑(AdicCompletion.map I f) ⇑(AdicCompletion.map I g)","decl":"include hf hfg hg in\n/-- `AdicCompletion` over a Noetherian ring is exact on finitely generated modules. -/\ntheorem map_exact : Function.Exact (map I f) (map I g) := by\n  refine LinearMap.exact_of_comp_eq_zero_of_ker_le_range ?_ (fun y ↦ ?_)\n  · rw [map_comp, hfg.linearMap_comp_eq_zero, AdicCompletion.map_zero]\n  · apply AdicCompletion.induction_on I N y (fun b ↦ ?_)\n    intro hz\n    obtain ⟨k, hk⟩ := Ideal.exists_pow_inf_eq_pow_smul I (LinearMap.range f)\n    have hb (n : ℕ) : g (b n) ∈ (I ^ n • ⊤ : Submodule R P) := by\n      simpa using congrArg (fun x ↦ x.val n) hz\n    let a := mapExactAux hf hfg hg hk b hb\n    refine ⟨AdicCompletion.mk I M (AdicCauchySequence.mk I M (fun n ↦ (a n : M)) ?_), ?_⟩\n    · refine fun n ↦ SModEq.symm ?_\n      simp [a, mapExactAux, SModEq]\n    · ext n\n      suffices h : Submodule.Quotient.mk (p := (I ^ n • ⊤ : Submodule R N)) (f (a n)) =\n            Submodule.Quotient.mk (p := (I ^ n • ⊤ : Submodule R N)) (b (k + n)) by\n        simp [h, AdicCauchySequence.mk_eq_mk (show n ≤ k + n by omega)]\n      rw [Submodule.Quotient.eq]\n      have hle : (I ^ (k + n) • ⊤ : Submodule R N) ≤ (I ^ n • ⊤ : Submodule R N) :=\n        Submodule.smul_mono_left (Ideal.pow_le_pow_right (by omega))\n      exact hle (a n).property\n\n"}
