{"name":"Ideal.FG.map","module":"Mathlib.RingTheory.Finiteness.Ideal","initialProofState":"R : Type u_3\nS : Type u_4\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nI : Ideal R\nh : I.FG\nf : RingHom R S\n⊢ (Ideal.map f I).FG","decl":"/-- The image of a finitely generated ideal is finitely generated.\n\nThis is the `Ideal` version of `Submodule.FG.map`. -/\ntheorem FG.map {R S : Type*} [Semiring R] [Semiring S] {I : Ideal R} (h : I.FG) (f : R →+* S) :\n    (I.map f).FG := by\n  classical\n    obtain ⟨s, hs⟩ := h\n    refine ⟨s.image f, ?_⟩\n    rw [Finset.coe_image, ← Ideal.map_span, hs]\n\n"}
{"name":"Ideal.fg_ker_comp","module":"Mathlib.RingTheory.Finiteness.Ideal","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : CommRing A\nf : RingHom R S\ng : RingHom S A\nhf : (RingHom.ker f).FG\nhg : (RingHom.ker g).FG\nhsur : Function.Surjective ⇑f\n⊢ (RingHom.ker (g.comp f)).FG","decl":"theorem fg_ker_comp {R S A : Type*} [CommRing R] [CommRing S] [CommRing A] (f : R →+* S)\n    (g : S →+* A) (hf : f.ker.FG) (hg : g.ker.FG) (hsur : Function.Surjective f) :\n    (g.comp f).ker.FG := by\n  letI : Algebra R S := RingHom.toAlgebra f\n  letI : Algebra R A := RingHom.toAlgebra (g.comp f)\n  letI : Algebra S A := RingHom.toAlgebra g\n  letI : IsScalarTower R S A := IsScalarTower.of_algebraMap_eq fun _ => rfl\n  let f₁ := Algebra.linearMap R S\n  let g₁ := (IsScalarTower.toAlgHom R S A).toLinearMap\n  exact Submodule.fg_ker_comp f₁ g₁ hf (Submodule.fg_restrictScalars (RingHom.ker g) hg hsur) hsur\n\n"}
{"name":"Ideal.exists_radical_pow_le_of_fg","module":"Mathlib.RingTheory.Finiteness.Ideal","initialProofState":"R : Type u_3\ninst✝ : CommSemiring R\nI : Ideal R\nh : I.radical.FG\n⊢ Exists fun n => LE.le (HPow.hPow I.radical n) I","decl":"theorem exists_radical_pow_le_of_fg {R : Type*} [CommSemiring R] (I : Ideal R) (h : I.radical.FG) :\n    ∃ n : ℕ, I.radical ^ n ≤ I := by\n  have := le_refl I.radical; revert this\n  refine Submodule.fg_induction _ _ (fun J => J ≤ I.radical → ∃ n : ℕ, J ^ n ≤ I) ?_ ?_ _ h\n  · intro x hx\n    obtain ⟨n, hn⟩ := hx (subset_span (Set.mem_singleton x))\n    exact ⟨n, by rwa [← Ideal.span, span_singleton_pow, span_le, Set.singleton_subset_iff]⟩\n  · intro J K hJ hK hJK\n    obtain ⟨n, hn⟩ := hJ fun x hx => hJK <| Ideal.mem_sup_left hx\n    obtain ⟨m, hm⟩ := hK fun x hx => hJK <| Ideal.mem_sup_right hx\n    use n + m\n    rw [← Ideal.add_eq_sup, add_pow, Ideal.sum_eq_sup, Finset.sup_le_iff]\n    refine fun i _ => Ideal.mul_le_right.trans ?_\n    obtain h | h := le_or_lt n i\n    · apply Ideal.mul_le_right.trans ((Ideal.pow_le_pow_right h).trans hn)\n    · apply Ideal.mul_le_left.trans\n      refine (Ideal.pow_le_pow_right ?_).trans hm\n      rw [add_comm, Nat.add_sub_assoc h.le]\n      apply Nat.le_add_right\n\n"}
{"name":"Ideal.exists_pow_le_of_le_radical_of_fg_radical","module":"Mathlib.RingTheory.Finiteness.Ideal","initialProofState":"R : Type u_3\ninst✝ : CommSemiring R\nI J : Ideal R\nhIJ : LE.le I J.radical\nhJ : J.radical.FG\n⊢ Exists fun k => LE.le (HPow.hPow I k) J","decl":"theorem exists_pow_le_of_le_radical_of_fg_radical {R : Type*} [CommSemiring R] {I J : Ideal R}\n    (hIJ : I ≤ J.radical) (hJ : J.radical.FG) :\n    ∃ k : ℕ, I ^ k ≤ J := by\n  obtain ⟨k, hk⟩ := J.exists_radical_pow_le_of_fg hJ\n  use k\n  calc\n    I ^ k ≤ J.radical ^ k := Ideal.pow_right_mono hIJ _\n    _ ≤ J := hk\n\n"}
{"name":"Ideal.exists_pow_le_of_le_radical_of_fG","module":"Mathlib.RingTheory.Finiteness.Ideal","initialProofState":"R : Type u_3\ninst✝ : CommSemiring R\nI J : Ideal R\nhIJ : LE.le I J.radical\nhJ : J.radical.FG\n⊢ Exists fun k => LE.le (HPow.hPow I k) J","decl":"@[deprecated (since := \"2024-10-24\")]\nalias exists_pow_le_of_le_radical_of_fG := exists_pow_le_of_le_radical_of_fg_radical\n\n"}
{"name":"Ideal.exists_pow_le_of_le_radical_of_fg","module":"Mathlib.RingTheory.Finiteness.Ideal","initialProofState":"R : Type u_3\ninst✝ : CommSemiring R\nI J : Ideal R\nh' : LE.le I J.radical\nh : I.FG\n⊢ Exists fun n => LE.le (HPow.hPow I n) J","decl":"lemma exists_pow_le_of_le_radical_of_fg {R : Type*} [CommSemiring R] {I J : Ideal R}\n    (h' : I ≤ J.radical) (h : I.FG) :\n    ∃ n : ℕ, I ^ n ≤ J := by\n  revert h'\n  apply Submodule.fg_induction _ _ _ _ _ I h\n  · intro x hJ\n    simp only [Ideal.submodule_span_eq, Ideal.span_le,\n      Set.singleton_subset_iff, SetLike.mem_coe] at hJ\n    obtain ⟨n, hn⟩ := hJ\n    refine ⟨n, by simpa [Ideal.span_singleton_pow, Ideal.span_le]⟩\n  · intros I₁ I₂ h₁ h₂ hJ\n    obtain ⟨n₁, hn₁⟩ := h₁ (le_sup_left.trans hJ)\n    obtain ⟨n₂, hn₂⟩ := h₂ (le_sup_right.trans hJ)\n    use n₁ + n₂\n    exact Ideal.sup_pow_add_le_pow_sup_pow.trans (sup_le hn₁ hn₂)\n\n"}
