{"name":"WithZeroTopology.nhds_eq_update","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Γ₀ : Type u_2\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\n⊢ Eq nhds (Function.update Pure.pure 0 (iInf fun γ => iInf fun h => Filter.principal (Set.Iio γ)))","decl":"theorem nhds_eq_update : (𝓝 : Γ₀ → Filter Γ₀) = update pure 0 (⨅ γ ≠ 0, 𝓟 (Iio γ)) := by\n   rw [nhds_nhdsAdjoint, sup_of_le_right]\n   exact le_iInf₂ fun γ hγ ↦ le_principal_iff.2 <| zero_lt_iff.2 hγ\n\n"}
{"name":"WithZeroTopology.nhds_zero","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Γ₀ : Type u_2\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\n⊢ Eq (nhds 0) (iInf fun γ => iInf fun h => Filter.principal (Set.Iio γ))","decl":"theorem nhds_zero : 𝓝 (0 : Γ₀) = ⨅ γ ≠ 0, 𝓟 (Iio γ) := by\n  rw [nhds_eq_update, update_self]\n\n"}
{"name":"WithZeroTopology.hasBasis_nhds_zero","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Γ₀ : Type u_2\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\n⊢ (nhds 0).HasBasis (fun γ => Ne γ 0) Set.Iio","decl":"/-- In a linearly ordered group with zero element adjoined, `U` is a neighbourhood of `0` if and\nonly if there exists a nonzero element `γ₀` such that `Iio γ₀ ⊆ U`. -/\ntheorem hasBasis_nhds_zero : (𝓝 (0 : Γ₀)).HasBasis (fun γ : Γ₀ => γ ≠ 0) Iio := by\n  rw [nhds_zero]\n  refine hasBasis_biInf_principal ?_ ⟨1, one_ne_zero⟩\n  exact directedOn_iff_directed.2 (Monotone.directed_ge fun a b hab => Iio_subset_Iio hab)\n\n"}
{"name":"WithZeroTopology.Iio_mem_nhds_zero","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Γ₀ : Type u_2\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\nγ : Γ₀\nhγ : Ne γ 0\n⊢ Membership.mem (nhds 0) (Set.Iio γ)","decl":"theorem Iio_mem_nhds_zero (hγ : γ ≠ 0) : Iio γ ∈ 𝓝 (0 : Γ₀) :=\n  hasBasis_nhds_zero.mem_of_mem hγ\n\n"}
{"name":"WithZeroTopology.nhds_zero_of_units","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Γ₀ : Type u_2\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\nγ : Units Γ₀\n⊢ Membership.mem (nhds 0) (Set.Iio ↑γ)","decl":"/-- If `γ` is an invertible element of a linearly ordered group with zero element adjoined, then\n`Iio (γ : Γ₀)` is a neighbourhood of `0`. -/\ntheorem nhds_zero_of_units (γ : Γ₀ˣ) : Iio ↑γ ∈ 𝓝 (0 : Γ₀) :=\n  Iio_mem_nhds_zero γ.ne_zero\n\n"}
{"name":"WithZeroTopology.tendsto_zero","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"α : Type u_1\nΓ₀ : Type u_2\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\nl : Filter α\nf : α → Γ₀\n⊢ Iff (Filter.Tendsto f l (nhds 0)) (∀ (γ₀ : Γ₀), Ne γ₀ 0 → Filter.Eventually (fun x => LT.lt (f x) γ₀) l)","decl":"theorem tendsto_zero : Tendsto f l (𝓝 (0 : Γ₀)) ↔ ∀ (γ₀) (_ : γ₀ ≠ 0), ∀ᶠ x in l, f x < γ₀ := by\n  simp [nhds_zero]\n\n"}
{"name":"WithZeroTopology.nhds_of_ne_zero","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Γ₀ : Type u_2\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\nγ : Γ₀\nh₀ : Ne γ 0\n⊢ Eq (nhds γ) (Pure.pure γ)","decl":"/-- The neighbourhood filter of a nonzero element consists of all sets containing that\nelement. -/\n@[simp]\ntheorem nhds_of_ne_zero {γ : Γ₀} (h₀ : γ ≠ 0) : 𝓝 γ = pure γ :=\n  nhds_nhdsAdjoint_of_ne _ h₀\n\n"}
{"name":"WithZeroTopology.nhds_coe_units","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Γ₀ : Type u_2\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\nγ : Units Γ₀\n⊢ Eq (nhds ↑γ) (Pure.pure ↑γ)","decl":"/-- The neighbourhood filter of an invertible element consists of all sets containing that\nelement. -/\ntheorem nhds_coe_units (γ : Γ₀ˣ) : 𝓝 (γ : Γ₀) = pure (γ : Γ₀) :=\n  nhds_of_ne_zero γ.ne_zero\n\n"}
{"name":"WithZeroTopology.singleton_mem_nhds_of_units","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Γ₀ : Type u_2\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\nγ : Units Γ₀\n⊢ Membership.mem (nhds ↑γ) (Singleton.singleton ↑γ)","decl":"/-- If `γ` is an invertible element of a linearly ordered group with zero element adjoined, then\n`{γ}` is a neighbourhood of `γ`. -/\ntheorem singleton_mem_nhds_of_units (γ : Γ₀ˣ) : ({↑γ} : Set Γ₀) ∈ 𝓝 (γ : Γ₀) := by simp\n\n"}
{"name":"WithZeroTopology.singleton_mem_nhds_of_ne_zero","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Γ₀ : Type u_2\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\nγ : Γ₀\nh : Ne γ 0\n⊢ Membership.mem (nhds γ) (Singleton.singleton γ)","decl":"/-- If `γ` is a nonzero element of a linearly ordered group with zero element adjoined, then `{γ}`\nis a neighbourhood of `γ`. -/\ntheorem singleton_mem_nhds_of_ne_zero (h : γ ≠ 0) : ({γ} : Set Γ₀) ∈ 𝓝 (γ : Γ₀) := by simp [h]\n\n"}
{"name":"WithZeroTopology.hasBasis_nhds_of_ne_zero","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Γ₀ : Type u_2\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\nx : Γ₀\nh : Ne x 0\n⊢ (nhds x).HasBasis (fun x => True) fun x_1 => Singleton.singleton x","decl":"theorem hasBasis_nhds_of_ne_zero {x : Γ₀} (h : x ≠ 0) :\n    HasBasis (𝓝 x) (fun _ : Unit => True) fun _ => {x} := by\n  rw [nhds_of_ne_zero h]\n  exact hasBasis_pure _\n\n"}
{"name":"WithZeroTopology.hasBasis_nhds_units","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Γ₀ : Type u_2\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\nγ : Units Γ₀\n⊢ (nhds ↑γ).HasBasis (fun x => True) fun x => Singleton.singleton ↑γ","decl":"theorem hasBasis_nhds_units (γ : Γ₀ˣ) :\n    HasBasis (𝓝 (γ : Γ₀)) (fun _ : Unit => True) fun _ => {↑γ} :=\n  hasBasis_nhds_of_ne_zero γ.ne_zero\n\n"}
{"name":"WithZeroTopology.tendsto_of_ne_zero","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"α : Type u_1\nΓ₀ : Type u_2\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\nl : Filter α\nf : α → Γ₀\nγ : Γ₀\nh : Ne γ 0\n⊢ Iff (Filter.Tendsto f l (nhds γ)) (Filter.Eventually (fun x => Eq (f x) γ) l)","decl":"theorem tendsto_of_ne_zero {γ : Γ₀} (h : γ ≠ 0) : Tendsto f l (𝓝 γ) ↔ ∀ᶠ x in l, f x = γ := by\n  rw [nhds_of_ne_zero h, tendsto_pure]\n\n"}
{"name":"WithZeroTopology.tendsto_units","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"α : Type u_1\nΓ₀ : Type u_2\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\nl : Filter α\nf : α → Γ₀\nγ₀ : Units Γ₀\n⊢ Iff (Filter.Tendsto f l (nhds ↑γ₀)) (Filter.Eventually (fun x => Eq (f x) ↑γ₀) l)","decl":"theorem tendsto_units {γ₀ : Γ₀ˣ} : Tendsto f l (𝓝 (γ₀ : Γ₀)) ↔ ∀ᶠ x in l, f x = γ₀ :=\n  tendsto_of_ne_zero γ₀.ne_zero\n\n"}
{"name":"WithZeroTopology.Iio_mem_nhds","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Γ₀ : Type u_2\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\nγ₁ γ₂ : Γ₀\nh : LT.lt γ₁ γ₂\n⊢ Membership.mem (nhds γ₁) (Set.Iio γ₂)","decl":"theorem Iio_mem_nhds (h : γ₁ < γ₂) : Iio γ₂ ∈ 𝓝 γ₁ := by\n  rcases eq_or_ne γ₁ 0 with (rfl | h₀) <;> simp [*, h.ne', Iio_mem_nhds_zero]\n\n"}
{"name":"WithZeroTopology.isOpen_iff","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Γ₀ : Type u_2\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\ns : Set Γ₀\n⊢ Iff (IsOpen s) (Or (Not (Membership.mem s 0)) (Exists fun γ => And (Ne γ 0) (HasSubset.Subset (Set.Iio γ) s)))","decl":"theorem isOpen_iff {s : Set Γ₀} : IsOpen s ↔ (0 : Γ₀) ∉ s ∨ ∃ γ, γ ≠ 0 ∧ Iio γ ⊆ s := by\n  rw [isOpen_iff_mem_nhds, ← and_forall_ne (0 : Γ₀)]\n  simp +contextual [nhds_of_ne_zero, imp_iff_not_or,\n    hasBasis_nhds_zero.mem_iff]\n\n"}
{"name":"WithZeroTopology.isClosed_iff","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Γ₀ : Type u_2\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\ns : Set Γ₀\n⊢ Iff (IsClosed s) (Or (Membership.mem s 0) (Exists fun γ => And (Ne γ 0) (HasSubset.Subset s (Set.Ici γ))))","decl":"theorem isClosed_iff {s : Set Γ₀} : IsClosed s ↔ (0 : Γ₀) ∈ s ∨ ∃ γ, γ ≠ 0 ∧ s ⊆ Ici γ := by\n  simp only [← isOpen_compl_iff, isOpen_iff, mem_compl_iff, not_not, ← compl_Ici,\n    compl_subset_compl]\n\n"}
{"name":"WithZeroTopology.isOpen_Iio","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Γ₀ : Type u_2\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\na : Γ₀\n⊢ IsOpen (Set.Iio a)","decl":"theorem isOpen_Iio {a : Γ₀} : IsOpen (Iio a) :=\n  isOpen_iff.mpr <| imp_iff_not_or.mp fun ha => ⟨a, ne_of_gt ha, Subset.rfl⟩\n\n"}
{"name":"WithZeroTopology.orderClosedTopology","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Γ₀ : Type u_2\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\n⊢ OrderClosedTopology Γ₀","decl":"/-- The topology on a linearly ordered group with zero element adjoined is compatible with the order\nstructure: the set `{p : Γ₀ × Γ₀ | p.1 ≤ p.2}` is closed. -/\n@[nolint defLemma]\nscoped instance (priority := 100) orderClosedTopology : OrderClosedTopology Γ₀ where\n  isClosed_le' := by\n    simp only [← isOpen_compl_iff, compl_setOf, not_le, isOpen_iff_mem_nhds]\n    rintro ⟨a, b⟩ (hab : b < a)\n    rw [nhds_prod_eq, nhds_of_ne_zero (zero_le'.trans_lt hab).ne', pure_prod]\n    exact Iio_mem_nhds hab\n\n"}
{"name":"WithZeroTopology.t5Space","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Γ₀ : Type u_2\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\n⊢ T5Space Γ₀","decl":"/-- The topology on a linearly ordered group with zero element adjoined is T₅. -/\n@[nolint defLemma]\nscoped instance (priority := 100) t5Space : T5Space Γ₀ where\n  completely_normal := fun s t h₁ h₂ => by\n    by_cases hs : 0 ∈ s\n    · have ht : 0 ∉ t := fun ht => disjoint_left.1 h₁ (subset_closure hs) ht\n      rwa [(isOpen_iff.2 (.inl ht)).nhdsSet_eq, disjoint_nhdsSet_principal]\n    · rwa [(isOpen_iff.2 (.inl hs)).nhdsSet_eq, disjoint_principal_nhdsSet]\n\n"}
{"name":"WithZeroTopology.instContinuousMul","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Γ₀ : Type u_2\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\n⊢ ContinuousMul Γ₀","decl":"/-- The topology on a linearly ordered group with zero element adjoined makes it a topological\nmonoid. -/\n@[nolint defLemma]\nscoped instance (priority := 100) : ContinuousMul Γ₀ where\n  continuous_mul := by\n    simp only [continuous_iff_continuousAt, ContinuousAt]\n    rintro ⟨x, y⟩\n    wlog hle : x ≤ y generalizing x y\n    · have := (this y x (le_of_not_le hle)).comp (continuous_swap.tendsto (x, y))\n      simpa only [mul_comm, Function.comp_def, Prod.swap] using this\n    rcases eq_or_ne x 0 with (rfl | hx) <;> [rcases eq_or_ne y 0 with (rfl | hy); skip]\n    · rw [zero_mul]\n      refine ((hasBasis_nhds_zero.prod_nhds hasBasis_nhds_zero).tendsto_iff hasBasis_nhds_zero).2\n        fun γ hγ => ⟨(γ, 1), ⟨hγ, one_ne_zero⟩, ?_⟩\n      rintro ⟨x, y⟩ ⟨hx : x < γ, hy : y < 1⟩\n      exact (mul_lt_mul'' hx hy zero_le' zero_le').trans_eq (mul_one γ)\n    · rw [zero_mul, nhds_prod_eq, nhds_of_ne_zero hy, prod_pure, tendsto_map'_iff]\n      refine (hasBasis_nhds_zero.tendsto_iff hasBasis_nhds_zero).2 fun γ hγ => ?_\n      refine ⟨γ / y, div_ne_zero hγ hy, fun x hx => ?_⟩\n      calc x * y < γ / y * y := mul_lt_mul_of_pos_right hx (zero_lt_iff.2 hy)\n      _ = γ := div_mul_cancel₀ _ hy\n    · have hy : y ≠ 0 := ((zero_lt_iff.mpr hx).trans_le hle).ne'\n      rw [nhds_prod_eq, nhds_of_ne_zero hx, nhds_of_ne_zero hy, prod_pure_pure]\n      exact pure_le_nhds (x * y)\n\n"}
{"name":"WithZeroTopology.instHasContinuousInv₀","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Γ₀ : Type u_2\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\n⊢ HasContinuousInv₀ Γ₀","decl":"@[nolint defLemma]\nscoped instance (priority := 100) : HasContinuousInv₀ Γ₀ :=\n  ⟨fun γ h => by\n    rw [ContinuousAt, nhds_of_ne_zero h]\n    exact pure_le_nhds γ⁻¹⟩\n\n"}
