{"name":"WithZeroTopology.nhds_eq_update","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Î“â‚€ : Type u_2\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\nâŠ¢ Eq nhds (Function.update Pure.pure 0 (iInf fun Î³ => iInf fun h => Filter.principal (Set.Iio Î³)))","decl":"theorem nhds_eq_update : (ğ“ : Î“â‚€ â†’ Filter Î“â‚€) = update pure 0 (â¨… Î³ â‰  0, ğ“Ÿ (Iio Î³)) := by\n   rw [nhds_nhdsAdjoint, sup_of_le_right]\n   exact le_iInfâ‚‚ fun Î³ hÎ³ â†¦ le_principal_iff.2 <| zero_lt_iff.2 hÎ³\n\n"}
{"name":"WithZeroTopology.nhds_zero","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Î“â‚€ : Type u_2\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\nâŠ¢ Eq (nhds 0) (iInf fun Î³ => iInf fun h => Filter.principal (Set.Iio Î³))","decl":"theorem nhds_zero : ğ“ (0 : Î“â‚€) = â¨… Î³ â‰  0, ğ“Ÿ (Iio Î³) := by\n  rw [nhds_eq_update, update_self]\n\n"}
{"name":"WithZeroTopology.hasBasis_nhds_zero","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Î“â‚€ : Type u_2\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\nâŠ¢ (nhds 0).HasBasis (fun Î³ => Ne Î³ 0) Set.Iio","decl":"/-- In a linearly ordered group with zero element adjoined, `U` is a neighbourhood of `0` if and\nonly if there exists a nonzero element `Î³â‚€` such that `Iio Î³â‚€ âŠ† U`. -/\ntheorem hasBasis_nhds_zero : (ğ“ (0 : Î“â‚€)).HasBasis (fun Î³ : Î“â‚€ => Î³ â‰  0) Iio := by\n  rw [nhds_zero]\n  refine hasBasis_biInf_principal ?_ âŸ¨1, one_ne_zeroâŸ©\n  exact directedOn_iff_directed.2 (Monotone.directed_ge fun a b hab => Iio_subset_Iio hab)\n\n"}
{"name":"WithZeroTopology.Iio_mem_nhds_zero","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Î“â‚€ : Type u_2\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\nÎ³ : Î“â‚€\nhÎ³ : Ne Î³ 0\nâŠ¢ Membership.mem (nhds 0) (Set.Iio Î³)","decl":"theorem Iio_mem_nhds_zero (hÎ³ : Î³ â‰  0) : Iio Î³ âˆˆ ğ“ (0 : Î“â‚€) :=\n  hasBasis_nhds_zero.mem_of_mem hÎ³\n\n"}
{"name":"WithZeroTopology.nhds_zero_of_units","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Î“â‚€ : Type u_2\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\nÎ³ : Units Î“â‚€\nâŠ¢ Membership.mem (nhds 0) (Set.Iio â†‘Î³)","decl":"/-- If `Î³` is an invertible element of a linearly ordered group with zero element adjoined, then\n`Iio (Î³ : Î“â‚€)` is a neighbourhood of `0`. -/\ntheorem nhds_zero_of_units (Î³ : Î“â‚€Ë£) : Iio â†‘Î³ âˆˆ ğ“ (0 : Î“â‚€) :=\n  Iio_mem_nhds_zero Î³.ne_zero\n\n"}
{"name":"WithZeroTopology.tendsto_zero","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Î± : Type u_1\nÎ“â‚€ : Type u_2\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\nl : Filter Î±\nf : Î± â†’ Î“â‚€\nâŠ¢ Iff (Filter.Tendsto f l (nhds 0)) (âˆ€ (Î³â‚€ : Î“â‚€), Ne Î³â‚€ 0 â†’ Filter.Eventually (fun x => LT.lt (f x) Î³â‚€) l)","decl":"theorem tendsto_zero : Tendsto f l (ğ“ (0 : Î“â‚€)) â†” âˆ€ (Î³â‚€) (_ : Î³â‚€ â‰  0), âˆ€á¶  x in l, f x < Î³â‚€ := by\n  simp [nhds_zero]\n\n"}
{"name":"WithZeroTopology.nhds_of_ne_zero","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Î“â‚€ : Type u_2\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\nÎ³ : Î“â‚€\nhâ‚€ : Ne Î³ 0\nâŠ¢ Eq (nhds Î³) (Pure.pure Î³)","decl":"/-- The neighbourhood filter of a nonzero element consists of all sets containing that\nelement. -/\n@[simp]\ntheorem nhds_of_ne_zero {Î³ : Î“â‚€} (hâ‚€ : Î³ â‰  0) : ğ“ Î³ = pure Î³ :=\n  nhds_nhdsAdjoint_of_ne _ hâ‚€\n\n"}
{"name":"WithZeroTopology.nhds_coe_units","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Î“â‚€ : Type u_2\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\nÎ³ : Units Î“â‚€\nâŠ¢ Eq (nhds â†‘Î³) (Pure.pure â†‘Î³)","decl":"/-- The neighbourhood filter of an invertible element consists of all sets containing that\nelement. -/\ntheorem nhds_coe_units (Î³ : Î“â‚€Ë£) : ğ“ (Î³ : Î“â‚€) = pure (Î³ : Î“â‚€) :=\n  nhds_of_ne_zero Î³.ne_zero\n\n"}
{"name":"WithZeroTopology.singleton_mem_nhds_of_units","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Î“â‚€ : Type u_2\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\nÎ³ : Units Î“â‚€\nâŠ¢ Membership.mem (nhds â†‘Î³) (Singleton.singleton â†‘Î³)","decl":"/-- If `Î³` is an invertible element of a linearly ordered group with zero element adjoined, then\n`{Î³}` is a neighbourhood of `Î³`. -/\ntheorem singleton_mem_nhds_of_units (Î³ : Î“â‚€Ë£) : ({â†‘Î³} : Set Î“â‚€) âˆˆ ğ“ (Î³ : Î“â‚€) := by simp\n\n"}
{"name":"WithZeroTopology.singleton_mem_nhds_of_ne_zero","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Î“â‚€ : Type u_2\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\nÎ³ : Î“â‚€\nh : Ne Î³ 0\nâŠ¢ Membership.mem (nhds Î³) (Singleton.singleton Î³)","decl":"/-- If `Î³` is a nonzero element of a linearly ordered group with zero element adjoined, then `{Î³}`\nis a neighbourhood of `Î³`. -/\ntheorem singleton_mem_nhds_of_ne_zero (h : Î³ â‰  0) : ({Î³} : Set Î“â‚€) âˆˆ ğ“ (Î³ : Î“â‚€) := by simp [h]\n\n"}
{"name":"WithZeroTopology.hasBasis_nhds_of_ne_zero","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Î“â‚€ : Type u_2\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\nx : Î“â‚€\nh : Ne x 0\nâŠ¢ (nhds x).HasBasis (fun x => True) fun x_1 => Singleton.singleton x","decl":"theorem hasBasis_nhds_of_ne_zero {x : Î“â‚€} (h : x â‰  0) :\n    HasBasis (ğ“ x) (fun _ : Unit => True) fun _ => {x} := by\n  rw [nhds_of_ne_zero h]\n  exact hasBasis_pure _\n\n"}
{"name":"WithZeroTopology.hasBasis_nhds_units","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Î“â‚€ : Type u_2\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\nÎ³ : Units Î“â‚€\nâŠ¢ (nhds â†‘Î³).HasBasis (fun x => True) fun x => Singleton.singleton â†‘Î³","decl":"theorem hasBasis_nhds_units (Î³ : Î“â‚€Ë£) :\n    HasBasis (ğ“ (Î³ : Î“â‚€)) (fun _ : Unit => True) fun _ => {â†‘Î³} :=\n  hasBasis_nhds_of_ne_zero Î³.ne_zero\n\n"}
{"name":"WithZeroTopology.tendsto_of_ne_zero","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Î± : Type u_1\nÎ“â‚€ : Type u_2\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\nl : Filter Î±\nf : Î± â†’ Î“â‚€\nÎ³ : Î“â‚€\nh : Ne Î³ 0\nâŠ¢ Iff (Filter.Tendsto f l (nhds Î³)) (Filter.Eventually (fun x => Eq (f x) Î³) l)","decl":"theorem tendsto_of_ne_zero {Î³ : Î“â‚€} (h : Î³ â‰  0) : Tendsto f l (ğ“ Î³) â†” âˆ€á¶  x in l, f x = Î³ := by\n  rw [nhds_of_ne_zero h, tendsto_pure]\n\n"}
{"name":"WithZeroTopology.tendsto_units","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Î± : Type u_1\nÎ“â‚€ : Type u_2\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\nl : Filter Î±\nf : Î± â†’ Î“â‚€\nÎ³â‚€ : Units Î“â‚€\nâŠ¢ Iff (Filter.Tendsto f l (nhds â†‘Î³â‚€)) (Filter.Eventually (fun x => Eq (f x) â†‘Î³â‚€) l)","decl":"theorem tendsto_units {Î³â‚€ : Î“â‚€Ë£} : Tendsto f l (ğ“ (Î³â‚€ : Î“â‚€)) â†” âˆ€á¶  x in l, f x = Î³â‚€ :=\n  tendsto_of_ne_zero Î³â‚€.ne_zero\n\n"}
{"name":"WithZeroTopology.Iio_mem_nhds","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Î“â‚€ : Type u_2\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\nÎ³â‚ Î³â‚‚ : Î“â‚€\nh : LT.lt Î³â‚ Î³â‚‚\nâŠ¢ Membership.mem (nhds Î³â‚) (Set.Iio Î³â‚‚)","decl":"theorem Iio_mem_nhds (h : Î³â‚ < Î³â‚‚) : Iio Î³â‚‚ âˆˆ ğ“ Î³â‚ := by\n  rcases eq_or_ne Î³â‚ 0 with (rfl | hâ‚€) <;> simp [*, h.ne', Iio_mem_nhds_zero]\n\n"}
{"name":"WithZeroTopology.isOpen_iff","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Î“â‚€ : Type u_2\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\ns : Set Î“â‚€\nâŠ¢ Iff (IsOpen s) (Or (Not (Membership.mem s 0)) (Exists fun Î³ => And (Ne Î³ 0) (HasSubset.Subset (Set.Iio Î³) s)))","decl":"theorem isOpen_iff {s : Set Î“â‚€} : IsOpen s â†” (0 : Î“â‚€) âˆ‰ s âˆ¨ âˆƒ Î³, Î³ â‰  0 âˆ§ Iio Î³ âŠ† s := by\n  rw [isOpen_iff_mem_nhds, â† and_forall_ne (0 : Î“â‚€)]\n  simp +contextual [nhds_of_ne_zero, imp_iff_not_or,\n    hasBasis_nhds_zero.mem_iff]\n\n"}
{"name":"WithZeroTopology.isClosed_iff","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Î“â‚€ : Type u_2\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\ns : Set Î“â‚€\nâŠ¢ Iff (IsClosed s) (Or (Membership.mem s 0) (Exists fun Î³ => And (Ne Î³ 0) (HasSubset.Subset s (Set.Ici Î³))))","decl":"theorem isClosed_iff {s : Set Î“â‚€} : IsClosed s â†” (0 : Î“â‚€) âˆˆ s âˆ¨ âˆƒ Î³, Î³ â‰  0 âˆ§ s âŠ† Ici Î³ := by\n  simp only [â† isOpen_compl_iff, isOpen_iff, mem_compl_iff, not_not, â† compl_Ici,\n    compl_subset_compl]\n\n"}
{"name":"WithZeroTopology.isOpen_Iio","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Î“â‚€ : Type u_2\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\na : Î“â‚€\nâŠ¢ IsOpen (Set.Iio a)","decl":"theorem isOpen_Iio {a : Î“â‚€} : IsOpen (Iio a) :=\n  isOpen_iff.mpr <| imp_iff_not_or.mp fun ha => âŸ¨a, ne_of_gt ha, Subset.rflâŸ©\n\n"}
{"name":"WithZeroTopology.orderClosedTopology","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Î“â‚€ : Type u_2\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\nâŠ¢ OrderClosedTopology Î“â‚€","decl":"/-- The topology on a linearly ordered group with zero element adjoined is compatible with the order\nstructure: the set `{p : Î“â‚€ Ã— Î“â‚€ | p.1 â‰¤ p.2}` is closed. -/\n@[nolint defLemma]\nscoped instance (priority := 100) orderClosedTopology : OrderClosedTopology Î“â‚€ where\n  isClosed_le' := by\n    simp only [â† isOpen_compl_iff, compl_setOf, not_le, isOpen_iff_mem_nhds]\n    rintro âŸ¨a, bâŸ© (hab : b < a)\n    rw [nhds_prod_eq, nhds_of_ne_zero (zero_le'.trans_lt hab).ne', pure_prod]\n    exact Iio_mem_nhds hab\n\n"}
{"name":"WithZeroTopology.t5Space","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Î“â‚€ : Type u_2\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\nâŠ¢ T5Space Î“â‚€","decl":"/-- The topology on a linearly ordered group with zero element adjoined is Tâ‚…. -/\n@[nolint defLemma]\nscoped instance (priority := 100) t5Space : T5Space Î“â‚€ where\n  completely_normal := fun s t hâ‚ hâ‚‚ => by\n    by_cases hs : 0 âˆˆ s\n    Â· have ht : 0 âˆ‰ t := fun ht => disjoint_left.1 hâ‚ (subset_closure hs) ht\n      rwa [(isOpen_iff.2 (.inl ht)).nhdsSet_eq, disjoint_nhdsSet_principal]\n    Â· rwa [(isOpen_iff.2 (.inl hs)).nhdsSet_eq, disjoint_principal_nhdsSet]\n\n"}
{"name":"WithZeroTopology.instContinuousMul","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Î“â‚€ : Type u_2\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\nâŠ¢ ContinuousMul Î“â‚€","decl":"/-- The topology on a linearly ordered group with zero element adjoined makes it a topological\nmonoid. -/\n@[nolint defLemma]\nscoped instance (priority := 100) : ContinuousMul Î“â‚€ where\n  continuous_mul := by\n    simp only [continuous_iff_continuousAt, ContinuousAt]\n    rintro âŸ¨x, yâŸ©\n    wlog hle : x â‰¤ y generalizing x y\n    Â· have := (this y x (le_of_not_le hle)).comp (continuous_swap.tendsto (x, y))\n      simpa only [mul_comm, Function.comp_def, Prod.swap] using this\n    rcases eq_or_ne x 0 with (rfl | hx) <;> [rcases eq_or_ne y 0 with (rfl | hy); skip]\n    Â· rw [zero_mul]\n      refine ((hasBasis_nhds_zero.prod_nhds hasBasis_nhds_zero).tendsto_iff hasBasis_nhds_zero).2\n        fun Î³ hÎ³ => âŸ¨(Î³, 1), âŸ¨hÎ³, one_ne_zeroâŸ©, ?_âŸ©\n      rintro âŸ¨x, yâŸ© âŸ¨hx : x < Î³, hy : y < 1âŸ©\n      exact (mul_lt_mul'' hx hy zero_le' zero_le').trans_eq (mul_one Î³)\n    Â· rw [zero_mul, nhds_prod_eq, nhds_of_ne_zero hy, prod_pure, tendsto_map'_iff]\n      refine (hasBasis_nhds_zero.tendsto_iff hasBasis_nhds_zero).2 fun Î³ hÎ³ => ?_\n      refine âŸ¨Î³ / y, div_ne_zero hÎ³ hy, fun x hx => ?_âŸ©\n      calc x * y < Î³ / y * y := mul_lt_mul_of_pos_right hx (zero_lt_iff.2 hy)\n      _ = Î³ := div_mul_cancelâ‚€ _ hy\n    Â· have hy : y â‰  0 := ((zero_lt_iff.mpr hx).trans_le hle).ne'\n      rw [nhds_prod_eq, nhds_of_ne_zero hx, nhds_of_ne_zero hy, prod_pure_pure]\n      exact pure_le_nhds (x * y)\n\n"}
{"name":"WithZeroTopology.instHasContinuousInvâ‚€","module":"Mathlib.Topology.Algebra.WithZeroTopology","initialProofState":"Î“â‚€ : Type u_2\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\nâŠ¢ HasContinuousInvâ‚€ Î“â‚€","decl":"@[nolint defLemma]\nscoped instance (priority := 100) : HasContinuousInvâ‚€ Î“â‚€ :=\n  âŸ¨fun Î³ h => by\n    rw [ContinuousAt, nhds_of_ne_zero h]\n    exact pure_le_nhds Î³â»Â¹âŸ©\n\n"}
