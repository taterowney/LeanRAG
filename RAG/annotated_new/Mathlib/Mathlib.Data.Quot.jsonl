{"name":"Setoid.ext","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_3\ns t : Setoid α\na✝ : ∀ (a b : α), Iff (s a b) (t a b)\n⊢ Eq s t","decl":"theorem ext {α : Sort*} : ∀ {s t : Setoid α}, (∀ a b, s a b ↔ t a b) → s = t\n  | ⟨r, _⟩, ⟨p, _⟩, Eq =>\n  by have : r = p := funext fun a ↦ funext fun b ↦ propext <| Eq a b\n     subst this\n     rfl\n\n"}
{"name":"Quot.induction_on","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_4\nr : α → α → Prop\nβ : Quot r → Prop\nq : Quot r\nh : ∀ (a : α), β (Quot.mk r a)\n⊢ β q","decl":"@[elab_as_elim]\nprotected theorem induction_on {α : Sort*} {r : α → α → Prop} {β : Quot r → Prop} (q : Quot r)\n    (h : ∀ a, β (Quot.mk r a)) : β q :=\n  ind h q\n\n"}
{"name":"Quot.Subsingleton","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nra : α → α → Prop\ninst✝ : Subsingleton α\n⊢ Subsingleton (Quot ra)","decl":"protected instance Subsingleton [Subsingleton α] : Subsingleton (Quot ra) :=\n  ⟨fun x ↦ Quot.induction_on x fun _ ↦ Quot.ind fun _ ↦ congr_arg _ (Subsingleton.elim _ _)⟩\n\n"}
{"name":"Quot.factor_mk_eq","module":"Mathlib.Data.Quot","initialProofState":"α : Type u_4\nr s : α → α → Prop\nh : ∀ (x y : α), r x y → s x y\n⊢ Eq (Function.comp (Quot.factor r s h) (Quot.mk r)) (Quot.mk s)","decl":"theorem factor_mk_eq {α : Type*} (r s : α → α → Prop) (h : ∀ x y, r x y → s x y) :\n    factor r s h ∘ Quot.mk _ = Quot.mk _ :=\n  rfl\n\n"}
{"name":"Quot.lift_mk","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nγ : Sort u_4\nr : α → α → Prop\nf : α → γ\nh : ∀ (a₁ a₂ : α), r a₁ a₂ → Eq (f a₁) (f a₂)\na : α\n⊢ Eq (Quot.lift f h (Quot.mk r a)) (f a)","decl":"theorem lift_mk (f : α → γ) (h : ∀ a₁ a₂, r a₁ a₂ → f a₁ = f a₂) (a : α) :\n    Quot.lift f h (Quot.mk r a) = f a :=\n  rfl\n\n"}
{"name":"Quot.liftOn_mk","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nγ : Sort u_4\nr : α → α → Prop\na : α\nf : α → γ\nh : ∀ (a₁ a₂ : α), r a₁ a₂ → Eq (f a₁) (f a₂)\n⊢ Eq ((Quot.mk r a).liftOn f h) (f a)","decl":"theorem liftOn_mk (a : α) (f : α → γ) (h : ∀ a₁ a₂, r a₁ a₂ → f a₁ = f a₂) :\n    Quot.liftOn (Quot.mk r a) f h = f a :=\n  rfl\n\n"}
{"name":"Quot.surjective_lift","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nγ : Sort u_4\nr : α → α → Prop\nf : α → γ\nh : ∀ (a₁ a₂ : α), r a₁ a₂ → Eq (f a₁) (f a₂)\n⊢ Iff (Function.Surjective (Quot.lift f h)) (Function.Surjective f)","decl":"@[simp] theorem surjective_lift {f : α → γ} (h : ∀ a₁ a₂, r a₁ a₂ → f a₁ = f a₂) :\n    Function.Surjective (lift f h) ↔ Function.Surjective f :=\n  ⟨fun hf => hf.comp Quot.exists_rep, fun hf y => let ⟨x, hx⟩ := hf y; ⟨Quot.mk _ x, hx⟩⟩\n\n"}
{"name":"Quot.lift₂_mk","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_4\nr : α → α → Prop\ns : β → β → Prop\nf : α → β → γ\nhr : ∀ (a : α) (b₁ b₂ : β), s b₁ b₂ → Eq (f a b₁) (f a b₂)\nhs : ∀ (a₁ a₂ : α) (b : β), r a₁ a₂ → Eq (f a₁ b) (f a₂ b)\na : α\nb : β\n⊢ Eq (Quot.lift₂ f hr hs (Quot.mk r a) (Quot.mk s b)) (f a b)","decl":"@[simp]\ntheorem lift₂_mk (f : α → β → γ) (hr : ∀ a b₁ b₂, s b₁ b₂ → f a b₁ = f a b₂)\n    (hs : ∀ a₁ a₂ b, r a₁ a₂ → f a₁ b = f a₂ b)\n    (a : α) (b : β) : Quot.lift₂ f hr hs (Quot.mk r a) (Quot.mk s b) = f a b :=\n  rfl\n\n"}
{"name":"Quot.liftOn₂_mk","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_4\nr : α → α → Prop\ns : β → β → Prop\na : α\nb : β\nf : α → β → γ\nhr : ∀ (a : α) (b₁ b₂ : β), s b₁ b₂ → Eq (f a b₁) (f a b₂)\nhs : ∀ (a₁ a₂ : α) (b : β), r a₁ a₂ → Eq (f a₁ b) (f a₂ b)\n⊢ Eq ((Quot.mk r a).liftOn₂ (Quot.mk s b) f hr hs) (f a b)","decl":"@[simp]\ntheorem liftOn₂_mk (a : α) (b : β) (f : α → β → γ) (hr : ∀ a b₁ b₂, s b₁ b₂ → f a b₁ = f a b₂)\n    (hs : ∀ a₁ a₂ b, r a₁ a₂ → f a₁ b = f a₂ b) :\n    Quot.liftOn₂ (Quot.mk r a) (Quot.mk s b) f hr hs = f a b :=\n  rfl\n\n"}
{"name":"Quot.map₂_mk","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_4\nr : α → α → Prop\ns : β → β → Prop\nt : γ → γ → Prop\nf : α → β → γ\nhr : ∀ (a : α) (b₁ b₂ : β), s b₁ b₂ → t (f a b₁) (f a b₂)\nhs : ∀ (a₁ a₂ : α) (b : β), r a₁ a₂ → t (f a₁ b) (f a₂ b)\na : α\nb : β\n⊢ Eq (Quot.map₂ f hr hs (Quot.mk r a) (Quot.mk s b)) (Quot.mk t (f a b))","decl":"@[simp]\ntheorem map₂_mk (f : α → β → γ) (hr : ∀ a b₁ b₂, s b₁ b₂ → t (f a b₁) (f a b₂))\n    (hs : ∀ a₁ a₂ b, r a₁ a₂ → t (f a₁ b) (f a₂ b)) (a : α) (b : β) :\n    Quot.map₂ f hr hs (Quot.mk r a) (Quot.mk s b) = Quot.mk t (f a b) :=\n  rfl\n\n"}
{"name":"Quot.induction_on₂","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nβ : Sort u_2\nr : α → α → Prop\ns : β → β → Prop\nδ : Quot r → Quot s → Prop\nq₁ : Quot r\nq₂ : Quot s\nh : ∀ (a : α) (b : β), δ (Quot.mk r a) (Quot.mk s b)\n⊢ δ q₁ q₂","decl":"@[elab_as_elim]\nprotected theorem induction_on₂ {δ : Quot r → Quot s → Prop} (q₁ : Quot r) (q₂ : Quot s)\n    (h : ∀ a b, δ (Quot.mk r a) (Quot.mk s b)) : δ q₁ q₂ :=\n  Quot.ind (β := fun a ↦ δ a q₂) (fun a₁ ↦ Quot.ind (fun a₂ ↦ h a₁ a₂) q₂) q₁\n\n"}
{"name":"Quot.induction_on₃","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_4\nr : α → α → Prop\ns : β → β → Prop\nt : γ → γ → Prop\nδ : Quot r → Quot s → Quot t → Prop\nq₁ : Quot r\nq₂ : Quot s\nq₃ : Quot t\nh : ∀ (a : α) (b : β) (c : γ), δ (Quot.mk r a) (Quot.mk s b) (Quot.mk t c)\n⊢ δ q₁ q₂ q₃","decl":"@[elab_as_elim]\nprotected theorem induction_on₃ {δ : Quot r → Quot s → Quot t → Prop} (q₁ : Quot r)\n    (q₂ : Quot s) (q₃ : Quot t) (h : ∀ a b c, δ (Quot.mk r a) (Quot.mk s b) (Quot.mk t c)) :\n    δ q₁ q₂ q₃ :=\n  Quot.ind (β := fun a ↦ δ a q₂ q₃) (fun a₁ ↦ Quot.ind (β := fun b ↦ δ _ b q₃)\n    (fun a₂ ↦ Quot.ind (fun a₃ ↦ h a₁ a₂ a₃) q₃) q₂) q₁\n\n"}
{"name":"Quotient.instSubsingletonQuotient","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\ns : Setoid α\ninst✝ : Subsingleton α\n⊢ Subsingleton (Quotient s)","decl":"instance instSubsingletonQuotient (s : Setoid α) [Subsingleton α] : Subsingleton (Quotient s) :=\n  Quot.Subsingleton\n\n"}
{"name":"Quotient.instIsEquivEquiv","module":"Mathlib.Data.Quot","initialProofState":"α : Type u_4\ninst✝ : Setoid α\n⊢ IsEquiv α fun x1 x2 => HasEquiv.Equiv x1 x2","decl":"instance {α : Type*} [Setoid α] : IsEquiv α (· ≈ ·) where\n  refl := Setoid.refl\n  symm _ _ := Setoid.symm\n  trans _ _ _ := Setoid.trans\n\n"}
{"name":"Quotient.map_mk","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nβ : Sort u_2\nsa : Setoid α\nsb : Setoid β\nf : α → β\nh : ∀ ⦃a b : α⦄, HasEquiv.Equiv a b → HasEquiv.Equiv (f a) (f b)\nx : α\n⊢ Eq (Quotient.map f h (Quotient.mk sa x)) (Quotient.mk sb (f x))","decl":"@[simp]\ntheorem map_mk (f : α → β) (h) (x : α) :\n    Quotient.map f h (⟦x⟧ : Quotient sa) = (⟦f x⟧ : Quotient sb) :=\n  rfl\n\n"}
{"name":"Quotient.map₂_mk","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nβ : Sort u_2\nsa : Setoid α\nsb : Setoid β\nγ : Sort u_4\nsc : Setoid γ\nf : α → β → γ\nh : ∀ ⦃a₁ a₂ : α⦄, HasEquiv.Equiv a₁ a₂ → ∀ ⦃b₁ b₂ : β⦄, HasEquiv.Equiv b₁ b₂ → HasEquiv.Equiv (f a₁ b₁) (f a₂ b₂)\nx : α\ny : β\n⊢ Eq (Quotient.map₂ f h (Quotient.mk sa x) (Quotient.mk sb y)) (Quotient.mk sc (f x y))","decl":"@[simp]\ntheorem map₂_mk (f : α → β → γ) (h) (x : α) (y : β) :\n    Quotient.map₂ f h (⟦x⟧ : Quotient sa) (⟦y⟧ : Quotient sb) = (⟦f x y⟧ : Quotient sc) :=\n  rfl\n\n"}
{"name":"Quot.eq","module":"Mathlib.Data.Quot","initialProofState":"α : Type u_3\nr : α → α → Prop\nx y : α\n⊢ Iff (Eq (Quot.mk r x) (Quot.mk r y)) (Relation.EqvGen r x y)","decl":"theorem Quot.eq {α : Type*} {r : α → α → Prop} {x y : α} :\n    Quot.mk r x = Quot.mk r y ↔ Relation.EqvGen r x y :=\n  ⟨Quot.eqvGen_exact, Quot.eqvGen_sound⟩\n\n"}
{"name":"Quotient.eq","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nr : Setoid α\nx y : α\n⊢ Iff (Eq (Quotient.mk r x) (Quotient.mk r y)) (r x y)","decl":"@[simp]\ntheorem Quotient.eq {r : Setoid α} {x y : α} : Quotient.mk r x = ⟦y⟧ ↔ r x y :=\n  ⟨Quotient.exact, Quotient.sound⟩\n\n"}
{"name":"Quotient.eq_iff_equiv","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nr : Setoid α\nx y : α\n⊢ Iff (Eq (Quotient.mk r x) (Quotient.mk r y)) (HasEquiv.Equiv x y)","decl":"theorem Quotient.eq_iff_equiv {r : Setoid α} {x y : α} : Quotient.mk r x = ⟦y⟧ ↔ x ≈ y :=\n  Quotient.eq\n\n"}
{"name":"Quotient.forall","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_3\ns : Setoid α\np : Quotient s → Prop\n⊢ Iff (∀ (a : Quotient s), p a) (∀ (a : α), p (Quotient.mk s a))","decl":"theorem Quotient.forall {α : Sort*} {s : Setoid α} {p : Quotient s → Prop} :\n    (∀ a, p a) ↔ ∀ a : α, p ⟦a⟧ :=\n  ⟨fun h _ ↦ h _, fun h a ↦ a.ind h⟩\n\n"}
{"name":"Quotient.exists","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_3\ns : Setoid α\np : Quotient s → Prop\n⊢ Iff (Exists fun a => p a) (Exists fun a => p (Quotient.mk s a))","decl":"theorem Quotient.exists {α : Sort*} {s : Setoid α} {p : Quotient s → Prop} :\n    (∃ a, p a) ↔ ∃ a : α, p ⟦a⟧ :=\n  ⟨fun ⟨q, hq⟩ ↦ q.ind (motive := (p · → _)) .intro hq, fun ⟨a, ha⟩ ↦ ⟨⟦a⟧, ha⟩⟩\n\n"}
{"name":"Quotient.lift_mk","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nβ : Sort u_2\ns : Setoid α\nf : α → β\nh : ∀ (a b : α), HasEquiv.Equiv a b → Eq (f a) (f b)\nx : α\n⊢ Eq (Quotient.lift f h (Quotient.mk s x)) (f x)","decl":"@[simp]\ntheorem Quotient.lift_mk {s : Setoid α} (f : α → β) (h : ∀ a b : α, a ≈ b → f a = f b) (x : α) :\n    Quotient.lift f h (Quotient.mk s x) = f x :=\n  rfl\n\n"}
{"name":"Quotient.lift_comp_mk","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nβ : Sort u_2\nx✝ : Setoid α\nf : α → β\nh : ∀ (a b : α), HasEquiv.Equiv a b → Eq (f a) (f b)\n⊢ Eq (Function.comp (Quotient.lift f h) (Quotient.mk x✝)) f","decl":"@[simp]\ntheorem Quotient.lift_comp_mk {_ : Setoid α} (f : α → β) (h : ∀ a b : α, a ≈ b → f a = f b) :\n    Quotient.lift f h ∘ Quotient.mk _ = f :=\n  rfl\n\n"}
{"name":"Quotient.lift₂_mk","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_3\nβ : Sort u_4\nγ : Sort u_5\nx✝¹ : Setoid α\nx✝ : Setoid β\nf : α → β → γ\nh : ∀ (a₁ : α) (a₂ : β) (b₁ : α) (b₂ : β), HasEquiv.Equiv a₁ b₁ → HasEquiv.Equiv a₂ b₂ → Eq (f a₁ a₂) (f b₁ b₂)\na : α\nb : β\n⊢ Eq (Quotient.lift₂ f h (Quotient.mk x✝¹ a) (Quotient.mk x✝ b)) (f a b)","decl":"@[simp]\ntheorem Quotient.lift₂_mk {α : Sort*} {β : Sort*} {γ : Sort*} {_ : Setoid α} {_ : Setoid β}\n    (f : α → β → γ)\n    (h : ∀ (a₁ : α) (a₂ : β) (b₁ : α) (b₂ : β), a₁ ≈ b₁ → a₂ ≈ b₂ → f a₁ a₂ = f b₁ b₂)\n    (a : α) (b : β) :\n    Quotient.lift₂ f h (Quotient.mk _ a) (Quotient.mk _ b) = f a b :=\n  rfl\n\n"}
{"name":"Quotient.liftOn_mk","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nβ : Sort u_2\ns : Setoid α\nf : α → β\nh : ∀ (a b : α), HasEquiv.Equiv a b → Eq (f a) (f b)\nx : α\n⊢ Eq ((Quotient.mk s x).liftOn f h) (f x)","decl":"theorem Quotient.liftOn_mk {s : Setoid α} (f : α → β) (h : ∀ a b : α, a ≈ b → f a = f b) (x : α) :\n    Quotient.liftOn (Quotient.mk s x) f h = f x :=\n  rfl\n\n"}
{"name":"Quotient.liftOn₂_mk","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_3\nβ : Sort u_4\nx✝ : Setoid α\nf : α → α → β\nh : ∀ (a₁ a₂ b₁ b₂ : α), HasEquiv.Equiv a₁ b₁ → HasEquiv.Equiv a₂ b₂ → Eq (f a₁ a₂) (f b₁ b₂)\nx y : α\n⊢ Eq ((Quotient.mk x✝ x).liftOn₂ (Quotient.mk x✝ y) f h) (f x y)","decl":"@[simp]\ntheorem Quotient.liftOn₂_mk {α : Sort*} {β : Sort*} {_ : Setoid α} (f : α → α → β)\n    (h : ∀ a₁ a₂ b₁ b₂ : α, a₁ ≈ b₁ → a₂ ≈ b₂ → f a₁ a₂ = f b₁ b₂) (x y : α) :\n    Quotient.liftOn₂ (Quotient.mk _ x) (Quotient.mk _ y) f h = f x y :=\n  rfl\n\n"}
{"name":"Quot.mk_surjective","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nr : α → α → Prop\n⊢ Function.Surjective (Quot.mk r)","decl":"/-- `Quot.mk r` is a surjective function. -/\ntheorem Quot.mk_surjective {r : α → α → Prop} : Function.Surjective (Quot.mk r) :=\n  Quot.exists_rep\n\n"}
{"name":"Quotient.mk_surjective","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\ns : Setoid α\n⊢ Function.Surjective (Quotient.mk s)","decl":"/-- `Quotient.mk` is a surjective function. -/\ntheorem Quotient.mk_surjective {s : Setoid α} :\n    Function.Surjective (Quotient.mk s) :=\n  Quot.exists_rep\n\n"}
{"name":"Quotient.mk'_surjective","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\ns : Setoid α\n⊢ Function.Surjective Quotient.mk'","decl":"/-- `Quotient.mk'` is a surjective function. -/\ntheorem Quotient.mk'_surjective [s : Setoid α] :\n    Function.Surjective (Quotient.mk' : α → Quotient s) :=\n  Quot.exists_rep\n\n"}
{"name":"surjective_quot_mk","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nr : α → α → Prop\n⊢ Function.Surjective (Quot.mk r)","decl":"/-- `Quot.mk r` is a surjective function. -/\n@[deprecated Quot.mk_surjective (since := \"2024-09-02\")]\ntheorem surjective_quot_mk (r : α → α → Prop) : Function.Surjective (Quot.mk r) :=\n  Quot.exists_rep\n\n"}
{"name":"surjective_quotient_mk","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_3\ns : Setoid α\n⊢ Function.Surjective (Quotient.mk s)","decl":"/-- `Quotient.mk` is a surjective function. -/\n@[deprecated Quotient.mk_surjective (since := \"2024-09-02\")]\ntheorem surjective_quotient_mk {α : Sort*} (s : Setoid α) :\n    Function.Surjective (Quotient.mk s) :=\n  Quot.exists_rep\n\n"}
{"name":"surjective_quotient_mk'","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_3\ns : Setoid α\n⊢ Function.Surjective Quotient.mk'","decl":"/-- `Quotient.mk'` is a surjective function. -/\n@[deprecated Quotient.mk'_surjective (since := \"2024-09-02\")]\ntheorem surjective_quotient_mk' (α : Sort*) [s : Setoid α] :\n    Function.Surjective (Quotient.mk' : α → Quotient s) :=\n  Quot.exists_rep\n\n"}
{"name":"Quot.out_eq","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nr : α → α → Prop\nq : Quot r\n⊢ Eq (Quot.mk r q.out) q","decl":"@[simp]\ntheorem Quot.out_eq {r : α → α → Prop} (q : Quot r) : Quot.mk r q.out = q :=\n  Classical.choose_spec (Quot.exists_rep q)\n\n"}
{"name":"Quotient.out_eq","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\ns : Setoid α\nq : Quotient s\n⊢ Eq (Quotient.mk s q.out) q","decl":"@[simp]\ntheorem Quotient.out_eq {s : Setoid α} (q : Quotient s) : ⟦q.out⟧ = q :=\n  Quot.out_eq q\n\n"}
{"name":"Quotient.mk_out","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\ns : Setoid α\na : α\n⊢ s (Quotient.mk s a).out a","decl":"theorem Quotient.mk_out {s : Setoid α} (a : α) : s (⟦a⟧ : Quotient s).out a :=\n  Quotient.exact (Quotient.out_eq _)\n\n"}
{"name":"Quotient.mk_eq_iff_out","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\ns : Setoid α\nx : α\ny : Quotient s\n⊢ Iff (Eq (Quotient.mk s x) y) (HasEquiv.Equiv x y.out)","decl":"theorem Quotient.mk_eq_iff_out {s : Setoid α} {x : α} {y : Quotient s} :\n    ⟦x⟧ = y ↔ x ≈ Quotient.out y := by\n  refine Iff.trans ?_ Quotient.eq\n  rw [Quotient.out_eq y]\n\n"}
{"name":"Quotient.eq_mk_iff_out","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\ns : Setoid α\nx : Quotient s\ny : α\n⊢ Iff (Eq x (Quotient.mk s y)) (HasEquiv.Equiv x.out y)","decl":"theorem Quotient.eq_mk_iff_out {s : Setoid α} {x : Quotient s} {y : α} :\n    x = ⟦y⟧ ↔ Quotient.out x ≈ y := by\n  refine Iff.trans ?_ Quotient.eq\n  rw [Quotient.out_eq x]\n\n"}
{"name":"Quotient.out_equiv_out","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\ns : Setoid α\nx y : Quotient s\n⊢ Iff (HasEquiv.Equiv x.out y.out) (Eq x y)","decl":"@[simp]\ntheorem Quotient.out_equiv_out {s : Setoid α} {x y : Quotient s} : x.out ≈ y.out ↔ x = y := by\n  rw [← Quotient.eq_mk_iff_out, Quotient.out_eq]\n\n"}
{"name":"Quotient.out_injective","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\ns : Setoid α\n⊢ Function.Injective Quotient.out","decl":"theorem Quotient.out_injective {s : Setoid α} : Function.Injective (@Quotient.out α s) :=\n  fun _ _ h ↦ Quotient.out_equiv_out.1 <| h ▸ Setoid.refl _\n\n"}
{"name":"Quotient.out_inj","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\ns : Setoid α\nx y : Quotient s\n⊢ Iff (Eq x.out y.out) (Eq x y)","decl":"@[simp]\ntheorem Quotient.out_inj {s : Setoid α} {x y : Quotient s} : x.out = y.out ↔ x = y :=\n  ⟨fun h ↦ Quotient.out_injective h, fun h ↦ h ▸ rfl⟩\n\n"}
{"name":"Quotient.eval_mk","module":"Mathlib.Data.Quot","initialProofState":"ι : Type u_3\nα : ι → Type u_4\nS : (i : ι) → Setoid (α i)\nf : (i : ι) → α i\n⊢ Eq (Quotient.mk inferInstance f).eval fun i => Quotient.mk (S i) (f i)","decl":"@[simp]\ntheorem Quotient.eval_mk {ι : Type*} {α : ι → Type*} {S : ∀ i, Setoid (α i)} (f : ∀ i, α i) :\n    Quotient.eval (S := S) ⟦f⟧ = fun i ↦ ⟦f i⟧ :=\n  rfl\n\n"}
{"name":"Quotient.choice_eq","module":"Mathlib.Data.Quot","initialProofState":"ι : Type u_3\nα : ι → Type u_4\nS : (i : ι) → Setoid (α i)\nf : (i : ι) → α i\n⊢ Eq (Quotient.choice fun i => Quotient.mk (S i) (f i)) (Quotient.mk inferInstance f)","decl":"@[simp]\ntheorem Quotient.choice_eq {ι : Type*} {α : ι → Type*} {S : ∀ i, Setoid (α i)} (f : ∀ i, α i) :\n    (Quotient.choice (S := S) fun i ↦ ⟦f i⟧) = ⟦f⟧ :=\n  Quotient.sound fun _ ↦ Quotient.mk_out _\n\n"}
{"name":"Quotient.induction_on_pi","module":"Mathlib.Data.Quot","initialProofState":"ι : Type u_3\nα : ι → Sort u_4\ns : (i : ι) → Setoid (α i)\np : ((i : ι) → Quotient (s i)) → Prop\nf : (i : ι) → Quotient (s i)\nh : ∀ (a : (i : ι) → α i), p fun i => Quotient.mk (s i) (a i)\n⊢ p f","decl":"@[elab_as_elim]\ntheorem Quotient.induction_on_pi {ι : Type*} {α : ι → Sort*} {s : ∀ i, Setoid (α i)}\n    {p : (∀ i, Quotient (s i)) → Prop} (f : ∀ i, Quotient (s i))\n    (h : ∀ a : ∀ i, α i, p fun i ↦ ⟦a i⟧) : p f := by\n  rw [← (funext fun i ↦ Quotient.out_eq (f i) : (fun i ↦ ⟦(f i).out⟧) = f)]\n  apply h\n\n"}
{"name":"nonempty_quotient_iff","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\ns : Setoid α\n⊢ Iff (Nonempty (Quotient s)) (Nonempty α)","decl":"theorem nonempty_quotient_iff (s : Setoid α) : Nonempty (Quotient s) ↔ Nonempty α :=\n  ⟨fun ⟨a⟩ ↦ Quotient.inductionOn a Nonempty.intro, fun ⟨a⟩ ↦ ⟨⟦a⟧⟩⟩\n\n"}
{"name":"true_equivalence","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\n⊢ Equivalence fun x x => True","decl":"theorem true_equivalence : @Equivalence α fun _ _ ↦ True :=\n  ⟨fun _ ↦ trivial, fun _ ↦ trivial, fun _ _ ↦ trivial⟩\n\n"}
{"name":"Trunc.ind","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nβ : Trunc α → Prop\na✝ : ∀ (a : α), β (Trunc.mk a)\nq : Trunc α\n⊢ β q","decl":"theorem ind {β : Trunc α → Prop} : (∀ a : α, β (mk a)) → ∀ q : Trunc α, β q :=\n  Quot.ind\n\n"}
{"name":"Trunc.lift_mk","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\nc : ∀ (a b : α), Eq (f a) (f b)\na : α\n⊢ Eq (Trunc.lift f c (Trunc.mk a)) (f a)","decl":"protected theorem lift_mk (f : α → β) (c) (a : α) : lift f c (mk a) = f a :=\n  rfl\n\n"}
{"name":"Trunc.induction_on","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nβ : Trunc α → Prop\nq : Trunc α\nh : ∀ (a : α), β (Trunc.mk a)\n⊢ β q","decl":"@[elab_as_elim]\nprotected theorem induction_on {β : Trunc α → Prop} (q : Trunc α) (h : ∀ a, β (mk a)) : β q :=\n  ind h q\n\n"}
{"name":"Trunc.exists_rep","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nq : Trunc α\n⊢ Exists fun a => Eq (Trunc.mk a) q","decl":"theorem exists_rep (q : Trunc α) : ∃ a : α, mk a = q :=\n  Quot.exists_rep q\n\n"}
{"name":"Trunc.induction_on₂","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nβ : Sort u_2\nC : Trunc α → Trunc β → Prop\nq₁ : Trunc α\nq₂ : Trunc β\nh : ∀ (a : α) (b : β), C (Trunc.mk a) (Trunc.mk b)\n⊢ C q₁ q₂","decl":"@[elab_as_elim]\nprotected theorem induction_on₂ {C : Trunc α → Trunc β → Prop} (q₁ : Trunc α) (q₂ : Trunc β)\n    (h : ∀ a b, C (mk a) (mk b)) : C q₁ q₂ :=\n  Trunc.induction_on q₁ fun a₁ ↦ Trunc.induction_on q₂ (h a₁)\n\n"}
{"name":"Trunc.eq","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\na b : Trunc α\n⊢ Eq a b","decl":"protected theorem eq (a b : Trunc α) : a = b :=\n  Trunc.induction_on₂ a b fun _ _ ↦ Quot.sound trivial\n\n"}
{"name":"Trunc.instSubsingletonTrunc","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\n⊢ Subsingleton (Trunc α)","decl":"instance instSubsingletonTrunc : Subsingleton (Trunc α) :=\n  ⟨Trunc.eq⟩\n\n"}
{"name":"Trunc.instLawfulMonad","module":"Mathlib.Data.Quot","initialProofState":"⊢ LawfulMonad Trunc","decl":"instance : LawfulMonad Trunc where\n  id_map _ := Trunc.eq _ _\n  pure_bind _ _ := rfl\n  bind_assoc _ _ _ := Trunc.eq _ _\n  -- Porting note: the fields below are new in Lean 4\n  map_const := rfl\n  seqLeft_eq _ _ := Trunc.eq _ _\n  seqRight_eq _ _ := Trunc.eq _ _\n  pure_seq _ _ := rfl\n  bind_pure_comp _ _ := rfl\n  bind_map _ _ := rfl\n\n"}
{"name":"Trunc.out_eq","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nq : Trunc α\n⊢ Eq (Trunc.mk q.out) q","decl":"@[simp]\ntheorem out_eq (q : Trunc α) : mk q.out = q :=\n  Trunc.eq _ _\n\n"}
{"name":"Trunc.nonempty","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nq : Trunc α\n⊢ Nonempty α","decl":"protected theorem nonempty (q : Trunc α) : Nonempty α :=\n  nonempty_of_exists q.exists_rep\n\n"}
{"name":"Quotient.mk''_surjective","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\ns₁ : Setoid α\n⊢ Function.Surjective Quotient.mk''","decl":"/-- `Quotient.mk''` is a surjective function. -/\ntheorem mk''_surjective : Function.Surjective (Quotient.mk'' : α → Quotient s₁) :=\n  Quot.exists_rep\n\n"}
{"name":"Quotient.surjective_Quotient_mk''","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\ns₁ : Setoid α\n⊢ Function.Surjective Quotient.mk''","decl":"@[deprecated (since := \"2024-09-02\")]\nalias surjective_Quotient_mk'' := mk''_surjective\n\n"}
{"name":"Quotient.liftOn'_mk''","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nφ : Sort u_4\ns₁ : Setoid α\nf : α → φ\nh : ∀ (a b : α), s₁ a b → Eq (f a) (f b)\nx : α\n⊢ Eq ((Quotient.mk'' x).liftOn' f h) (f x)","decl":"@[simp]\nprotected theorem liftOn'_mk'' (f : α → φ) (h) (x : α) :\n    Quotient.liftOn' (@Quotient.mk'' _ s₁ x) f h = f x :=\n  rfl\n\n"}
{"name":"Quotient.surjective_liftOn'","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nφ : Sort u_4\ns₁ : Setoid α\nf : α → φ\nh : ∀ (a b : α), s₁ a b → Eq (f a) (f b)\n⊢ Iff (Function.Surjective fun x => x.liftOn' f h) (Function.Surjective f)","decl":"@[simp] lemma surjective_liftOn' {f : α → φ} (h) :\n    Function.Surjective (fun x : Quotient s₁ ↦ x.liftOn' f h) ↔ Function.Surjective f :=\n  Quot.surjective_lift _\n\n"}
{"name":"Quotient.liftOn₂'_mk''","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\ns₁ : Setoid α\ns₂ : Setoid β\nf : α → β → γ\nh : ∀ (a₁ : α) (a₂ : β) (b₁ : α) (b₂ : β), s₁ a₁ b₁ → s₂ a₂ b₂ → Eq (f a₁ a₂) (f b₁ b₂)\na : α\nb : β\n⊢ Eq ((Quotient.mk'' a).liftOn₂' (Quotient.mk'' b) f h) (f a b)","decl":"@[simp]\nprotected theorem liftOn₂'_mk'' (f : α → β → γ) (h) (a : α) (b : β) :\n    Quotient.liftOn₂' (@Quotient.mk'' _ s₁ a) (@Quotient.mk'' _ s₂ b) f h = f a b :=\n  rfl\n\n"}
{"name":"Quotient.ind'","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\ns₁ : Setoid α\np : Quotient s₁ → Prop\nh : ∀ (a : α), p (Quotient.mk'' a)\nq : Quotient s₁\n⊢ p q","decl":"/-- A version of `Quotient.ind` taking `{s : Setoid α}` as an implicit argument instead of an\ninstance argument. -/\n@[elab_as_elim]\nprotected theorem ind' {p : Quotient s₁ → Prop} (h : ∀ a, p (Quotient.mk'' a)) (q : Quotient s₁) :\n    p q :=\n  Quotient.ind h q\n\n"}
{"name":"Quotient.ind₂'","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nβ : Sort u_2\ns₁ : Setoid α\ns₂ : Setoid β\np : Quotient s₁ → Quotient s₂ → Prop\nh : ∀ (a₁ : α) (a₂ : β), p (Quotient.mk'' a₁) (Quotient.mk'' a₂)\nq₁ : Quotient s₁\nq₂ : Quotient s₂\n⊢ p q₁ q₂","decl":"/-- A version of `Quotient.ind₂` taking `{s₁ : Setoid α} {s₂ : Setoid β}` as implicit arguments\ninstead of instance arguments. -/\n@[elab_as_elim]\nprotected theorem ind₂' {p : Quotient s₁ → Quotient s₂ → Prop}\n    (h : ∀ a₁ a₂, p (Quotient.mk'' a₁) (Quotient.mk'' a₂))\n    (q₁ : Quotient s₁) (q₂ : Quotient s₂) : p q₁ q₂ :=\n  Quotient.ind₂ h q₁ q₂\n\n"}
{"name":"Quotient.inductionOn'","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\ns₁ : Setoid α\np : Quotient s₁ → Prop\nq : Quotient s₁\nh : ∀ (a : α), p (Quotient.mk'' a)\n⊢ p q","decl":"/-- A version of `Quotient.inductionOn` taking `{s : Setoid α}` as an implicit argument instead\nof an instance argument. -/\n@[elab_as_elim]\nprotected theorem inductionOn' {p : Quotient s₁ → Prop} (q : Quotient s₁)\n    (h : ∀ a, p (Quotient.mk'' a)) : p q :=\n  Quotient.inductionOn q h\n\n"}
{"name":"Quotient.inductionOn₂'","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nβ : Sort u_2\ns₁ : Setoid α\ns₂ : Setoid β\np : Quotient s₁ → Quotient s₂ → Prop\nq₁ : Quotient s₁\nq₂ : Quotient s₂\nh : ∀ (a₁ : α) (a₂ : β), p (Quotient.mk'' a₁) (Quotient.mk'' a₂)\n⊢ p q₁ q₂","decl":"/-- A version of `Quotient.inductionOn₂` taking `{s₁ : Setoid α} {s₂ : Setoid β}` as implicit\narguments instead of instance arguments. -/\n@[elab_as_elim]\nprotected theorem inductionOn₂' {p : Quotient s₁ → Quotient s₂ → Prop} (q₁ : Quotient s₁)\n    (q₂ : Quotient s₂)\n    (h : ∀ a₁ a₂, p (Quotient.mk'' a₁) (Quotient.mk'' a₂)) : p q₁ q₂ :=\n  Quotient.inductionOn₂ q₁ q₂ h\n\n"}
{"name":"Quotient.inductionOn₃'","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\ns₁ : Setoid α\ns₂ : Setoid β\ns₃ : Setoid γ\np : Quotient s₁ → Quotient s₂ → Quotient s₃ → Prop\nq₁ : Quotient s₁\nq₂ : Quotient s₂\nq₃ : Quotient s₃\nh : ∀ (a₁ : α) (a₂ : β) (a₃ : γ), p (Quotient.mk'' a₁) (Quotient.mk'' a₂) (Quotient.mk'' a₃)\n⊢ p q₁ q₂ q₃","decl":"/-- A version of `Quotient.inductionOn₃` taking `{s₁ : Setoid α} {s₂ : Setoid β} {s₃ : Setoid γ}`\nas implicit arguments instead of instance arguments. -/\n@[elab_as_elim]\nprotected theorem inductionOn₃' {p : Quotient s₁ → Quotient s₂ → Quotient s₃ → Prop}\n    (q₁ : Quotient s₁) (q₂ : Quotient s₂) (q₃ : Quotient s₃)\n    (h : ∀ a₁ a₂ a₃, p (Quotient.mk'' a₁) (Quotient.mk'' a₂) (Quotient.mk'' a₃)) :\n    p q₁ q₂ q₃ :=\n  Quotient.inductionOn₃ q₁ q₂ q₃ h\n\n"}
{"name":"Quotient.hrecOn'_mk''","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\ns₁ : Setoid α\nφ : Quotient s₁ → Sort u_5\nf : (a : α) → φ (Quotient.mk'' a)\nc : ∀ (a₁ a₂ : α), HasEquiv.Equiv a₁ a₂ → HEq (f a₁) (f a₂)\nx : α\n⊢ Eq ((Quotient.mk'' x).hrecOn' f c) (f x)","decl":"@[simp]\ntheorem hrecOn'_mk'' {φ : Quotient s₁ → Sort*} (f : ∀ a, φ (Quotient.mk'' a))\n    (c : ∀ a₁ a₂, a₁ ≈ a₂ → HEq (f a₁) (f a₂))\n    (x : α) : (Quotient.mk'' x).hrecOn' f c = f x :=\n  rfl\n\n"}
{"name":"Quotient.hrecOn₂'_mk''","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nβ : Sort u_2\ns₁ : Setoid α\ns₂ : Setoid β\nφ : Quotient s₁ → Quotient s₂ → Sort u_5\nf : (a : α) → (b : β) → φ (Quotient.mk'' a) (Quotient.mk'' b)\nc : ∀ (a₁ : α) (b₁ : β) (a₂ : α) (b₂ : β), HasEquiv.Equiv a₁ a₂ → HasEquiv.Equiv b₁ b₂ → HEq (f a₁ b₁) (f a₂ b₂)\nx : α\nqb : Quotient s₂\n⊢ Eq ((Quotient.mk'' x).hrecOn₂' qb f c) (qb.hrecOn' (f x) ⋯)","decl":"@[simp]\ntheorem hrecOn₂'_mk'' {φ : Quotient s₁ → Quotient s₂ → Sort*}\n    (f : ∀ a b, φ (Quotient.mk'' a) (Quotient.mk'' b))\n    (c : ∀ a₁ b₁ a₂ b₂, a₁ ≈ a₂ → b₁ ≈ b₂ → HEq (f a₁ b₁) (f a₂ b₂)) (x : α) (qb : Quotient s₂) :\n    (Quotient.mk'' x).hrecOn₂' qb f c = qb.hrecOn' (f x) fun _ _ ↦ c _ _ _ _ (Setoid.refl _) :=\n  rfl\n\n"}
{"name":"Quotient.map'_mk''","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nβ : Sort u_2\ns₁ : Setoid α\ns₂ : Setoid β\nf : α → β\nh : ∀ (a b : α), s₁ a b → s₂ (f a) (f b)\nx : α\n⊢ Eq (Quotient.map' f h (Quotient.mk'' x)) (Quotient.mk'' (f x))","decl":"@[simp]\ntheorem map'_mk'' (f : α → β) (h) (x : α) :\n    (Quotient.mk'' x : Quotient s₁).map' f h = (Quotient.mk'' (f x) : Quotient s₂) :=\n  rfl\n\n"}
{"name":"Quotient.exact'","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\ns₁ : Setoid α\na b : α\na✝ : Eq (Quotient.mk'' a) (Quotient.mk'' b)\n⊢ s₁ a b","decl":"theorem exact' {a b : α} :\n    (Quotient.mk'' a : Quotient s₁) = Quotient.mk'' b → s₁ a b :=\n  Quotient.exact\n\n"}
{"name":"Quotient.sound'","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\ns₁ : Setoid α\na b : α\na✝ : s₁ a b\n⊢ Eq (Quotient.mk'' a) (Quotient.mk'' b)","decl":"theorem sound' {a b : α} : s₁ a b → @Quotient.mk'' α s₁ a = Quotient.mk'' b :=\n  Quotient.sound\n\n"}
{"name":"Quotient.eq'","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\ns₁ : Setoid α\na b : α\n⊢ Iff (Eq (Quotient.mk' a) (Quotient.mk' b)) (s₁ a b)","decl":"@[simp]\nprotected theorem eq' {s₁ : Setoid α} {a b : α} :\n    @Quotient.mk' α s₁ a = @Quotient.mk' α s₁ b ↔ s₁ a b :=\n  Quotient.eq\n\n"}
{"name":"Quotient.eq''","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\ns₁ : Setoid α\na b : α\n⊢ Iff (Eq (Quotient.mk'' a) (Quotient.mk'' b)) (s₁ a b)","decl":"protected theorem eq'' {a b : α} : @Quotient.mk'' α s₁ a = Quotient.mk'' b ↔ s₁ a b :=\n  Quotient.eq\n\n"}
{"name":"Quotient.out_eq'","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\ns₁ : Setoid α\nq : Quotient s₁\n⊢ Eq (Quotient.mk'' q.out) q","decl":"theorem out_eq' (q : Quotient s₁) : Quotient.mk'' q.out = q :=\n  q.out_eq\n\n"}
{"name":"Quotient.mk_out'","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\ns₁ : Setoid α\na : α\n⊢ s₁ (Quotient.mk'' a).out a","decl":"theorem mk_out' (a : α) : s₁ (Quotient.mk'' a : Quotient s₁).out a :=\n  Quotient.exact (Quotient.out_eq _)\n\n"}
{"name":"Quotient.mk''_eq_mk","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\ns : Setoid α\n⊢ Eq Quotient.mk'' (Quotient.mk s)","decl":"protected theorem mk''_eq_mk : Quotient.mk'' = Quotient.mk s :=\n  rfl\n\n"}
{"name":"Quotient.liftOn'_mk","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nβ : Sort u_2\ns : Setoid α\nx : α\nf : α → β\nh : ∀ (a b : α), s a b → Eq (f a) (f b)\n⊢ Eq ((Quotient.mk s x).liftOn' f h) (f x)","decl":"@[simp]\nprotected theorem liftOn'_mk (x : α) (f : α → β) (h) : (Quotient.mk s x).liftOn' f h = f x :=\n  rfl\n\n"}
{"name":"Quotient.liftOn₂'_mk","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\ns : Setoid α\nt : Setoid β\nf : α → β → γ\nh : ∀ (a₁ : α) (a₂ : β) (b₁ : α) (b₂ : β), s a₁ b₁ → t a₂ b₂ → Eq (f a₁ a₂) (f b₁ b₂)\na : α\nb : β\n⊢ Eq ((Quotient.mk s a).liftOn₂' (Quotient.mk t b) f h) (f a b)","decl":"@[simp]\nprotected theorem liftOn₂'_mk {t : Setoid β} (f : α → β → γ) (h) (a : α) (b : β) :\n    Quotient.liftOn₂' (Quotient.mk s a) (Quotient.mk t b) f h = f a b :=\n  Quotient.liftOn₂'_mk'' _ _ _ _\n\n"}
{"name":"Quotient.map'_mk","module":"Mathlib.Data.Quot","initialProofState":"α : Sort u_1\nβ : Sort u_2\ns : Setoid α\nt : Setoid β\nf : α → β\nh : ∀ (a b : α), s a b → t (f a) (f b)\nx : α\n⊢ Eq (Quotient.map' f h (Quotient.mk s x)) (Quotient.mk t (f x))","decl":"theorem map'_mk {t : Setoid β} (f : α → β) (h) (x : α) :\n    (Quotient.mk s x).map' f h = (Quotient.mk t (f x)) :=\n  rfl\n\n"}
{"name":"Equivalence.quot_mk_eq_iff","module":"Mathlib.Data.Quot","initialProofState":"α : Type u_3\nr : α → α → Prop\nh : Equivalence r\nx y : α\n⊢ Iff (Eq (Quot.mk r x) (Quot.mk r y)) (r x y)","decl":"@[simp]\nlemma Equivalence.quot_mk_eq_iff {α : Type*} {r : α → α → Prop} (h : Equivalence r) (x y : α) :\n    Quot.mk r x = Quot.mk r y ↔ r x y := by\n  constructor\n  · rw [Quot.eq]\n    intro hxy\n    induction hxy with\n    | rel _ _ H => exact H\n    | refl _ => exact h.refl _\n    | symm _ _ _ H => exact h.symm H\n    | trans _ _ _ _ _ h₁₂ h₂₃ => exact h.trans h₁₂ h₂₃\n  · exact Quot.sound\n"}
