{"name":"AddCircle.ae_empty_or_univ_of_forall_vadd_ae_eq_self","module":"Mathlib.Dynamics.Ergodic.AddCircle","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\ns : Set (AddCircle T)\nhs : MeasureTheory.NullMeasurableSet s MeasureTheory.MeasureSpace.volume\nŒπ : Type u_1\nl : Filter Œπ\ninst‚úù : l.NeBot\nu : Œπ ‚Üí AddCircle T\nhu‚ÇÅ : ‚àÄ (i : Œπ), (MeasureTheory.ae MeasureTheory.MeasureSpace.volume).EventuallyEq (HVAdd.hVAdd (u i) s) s\nhu‚ÇÇ : Filter.Tendsto (Function.comp addOrderOf u) l Filter.atTop\n‚ä¢ Or ((MeasureTheory.ae MeasureTheory.MeasureSpace.volume).EventuallyEq s EmptyCollection.emptyCollection) ((MeasureTheory.ae MeasureTheory.MeasureSpace.volume).EventuallyEq s Set.univ)","decl":"/-- If a null-measurable subset of the circle is almost invariant under rotation by a family of\nrational angles with denominators tending to infinity, then it must be almost empty or almost full.\n-/\ntheorem ae_empty_or_univ_of_forall_vadd_ae_eq_self {s : Set <| AddCircle T}\n    (hs : NullMeasurableSet s volume) {Œπ : Type*} {l : Filter Œπ} [l.NeBot] {u : Œπ ‚Üí AddCircle T}\n    (hu‚ÇÅ : ‚àÄ i, (u i +·µ• s : Set _) =·µê[volume] s) (hu‚ÇÇ : Tendsto (addOrderOf ‚àò u) l atTop) :\n    s =·µê[volume] (‚àÖ : Set <| AddCircle T) ‚à® s =·µê[volume] univ := by\n  /- Sketch of proof:\n    Assume `T = 1` for simplicity and let `Œº` be the Haar measure. We may assume `s` has positive\n    measure since otherwise there is nothing to prove. In this case, by Lebesgue's density theorem,\n    there exists a point `d` of positive density. Let `I‚±º` be the sequence of closed balls about `d`\n    of diameter `1 / n‚±º` where `n‚±º` is the additive order of `u‚±º`. Since `d` has positive density we\n    must have `Œº (s ‚à© I‚±º) / Œº I‚±º ‚Üí 1` along `l`. However since `s` is invariant under the action of\n    `u‚±º` and since `I‚±º` is a fundamental domain for this action, we must have\n    `Œº (s ‚à© I‚±º) = n‚±º * Œº s = (Œº I‚±º) * Œº s`. We thus have `Œº s ‚Üí 1` and thus `Œº s = 1`. -/\n  set Œº := (volume : Measure <| AddCircle T)\n  set n : Œπ ‚Üí ‚Ñï := addOrderOf ‚àò u\n  have hT‚ÇÄ : 0 < T := hT.out\n  have hT‚ÇÅ : ENNReal.ofReal T ‚â† 0 := by simpa\n  rw [ae_eq_empty, ae_eq_univ_iff_measure_eq hs, AddCircle.measure_univ]\n  rcases eq_or_ne (Œº s) 0 with h | h; ¬∑ exact Or.inl h\n  right\n  obtain ‚ü®d, -, hd‚ü© : ‚àÉ d, d ‚àà s ‚àß ‚àÄ {Œπ'} {l : Filter Œπ'} (w : Œπ' ‚Üí AddCircle T) (Œ¥ : Œπ' ‚Üí ‚Ñù),\n    Tendsto Œ¥ l (ùìù[>] 0) ‚Üí (‚àÄ·∂† j in l, d ‚àà closedBall (w j) (1 * Œ¥ j)) ‚Üí\n      Tendsto (fun j => Œº (s ‚à© closedBall (w j) (Œ¥ j)) / Œº (closedBall (w j) (Œ¥ j))) l (ùìù 1) :=\n    exists_mem_of_measure_ne_zero_of_ae h\n      (IsUnifLocDoublingMeasure.ae_tendsto_measure_inter_div Œº s 1)\n  let I : Œπ ‚Üí Set (AddCircle T) := fun j => closedBall d (T / (2 * ‚Üë(n j)))\n  replace hd : Tendsto (fun j => Œº (s ‚à© I j) / Œº (I j)) l (ùìù 1) := by\n    let Œ¥ : Œπ ‚Üí ‚Ñù := fun j => T / (2 * ‚Üë(n j))\n    have hŒ¥‚ÇÄ : ‚àÄ·∂† j in l, 0 < Œ¥ j :=\n      (hu‚ÇÇ.eventually_gt_atTop 0).mono fun j hj => div_pos hT‚ÇÄ <| by positivity\n    have hŒ¥‚ÇÅ : Tendsto Œ¥ l (ùìù[>] 0) := by\n      refine tendsto_nhdsWithin_iff.mpr ‚ü®?_, hŒ¥‚ÇÄ‚ü©\n      replace hu‚ÇÇ : Tendsto (fun j => T‚Åª¬π * 2 * n j) l atTop :=\n        (tendsto_natCast_atTop_iff.mpr hu‚ÇÇ).const_mul_atTop (by positivity : 0 < T‚Åª¬π * 2)\n      convert hu‚ÇÇ.inv_tendsto_atTop\n      ext j\n      simp only [Œ¥, Pi.inv_apply, mul_inv_rev, inv_inv, div_eq_inv_mul, ‚Üê mul_assoc]\n    have hw : ‚àÄ·∂† j in l, d ‚àà closedBall d (1 * Œ¥ j) := hŒ¥‚ÇÄ.mono fun j hj => by\n      simp only [comp_apply, one_mul, mem_closedBall, dist_self]\n      apply hj.le\n    exact hd _ Œ¥ hŒ¥‚ÇÅ hw\n  suffices ‚àÄ·∂† j in l, Œº (s ‚à© I j) / Œº (I j) = Œº s / ENNReal.ofReal T by\n    replace hd := hd.congr' this\n    rwa [tendsto_const_nhds_iff, ENNReal.div_eq_one_iff hT‚ÇÅ ENNReal.ofReal_ne_top] at hd\n  refine (hu‚ÇÇ.eventually_gt_atTop 0).mono fun j hj => ?_\n  have : addOrderOf (u j) = n j := rfl\n  have huj : IsOfFinAddOrder (u j) := addOrderOf_pos_iff.mp hj\n  have huj' : 1 ‚â§ (‚Üë(n j) : ‚Ñù) := by norm_cast\n  have hI‚ÇÄ : Œº (I j) ‚â† 0 := (measure_closedBall_pos _ d <| by positivity).ne.symm\n  have hI‚ÇÅ : Œº (I j) ‚â† ‚ä§ := measure_ne_top _ _\n  have hI‚ÇÇ : Œº (I j) * ‚Üë(n j) = ENNReal.ofReal T := by\n    rw [volume_closedBall, mul_div, mul_div_mul_left T _ two_ne_zero,\n      min_eq_right (div_le_self hT‚ÇÄ.le huj'), mul_comm, ‚Üê nsmul_eq_mul, ‚Üê ENNReal.ofReal_nsmul,\n      nsmul_eq_mul, mul_div_cancel‚ÇÄ]\n    exact Nat.cast_ne_zero.mpr hj.ne'\n  rw [ENNReal.div_eq_div_iff hT‚ÇÅ ENNReal.ofReal_ne_top hI‚ÇÄ hI‚ÇÅ,\n    volume_of_add_preimage_eq s _ (u j) d huj (hu‚ÇÅ j) closedBall_ae_eq_ball, nsmul_eq_mul, ‚Üê\n    mul_assoc, this, hI‚ÇÇ]\n\n"}
{"name":"AddCircle.ergodic_zsmul","module":"Mathlib.Dynamics.Ergodic.AddCircle","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\nn : Int\nhn : LT.lt 1 (abs n)\n‚ä¢ Ergodic (fun y => HSMul.hSMul n y) MeasureTheory.MeasureSpace.volume","decl":"theorem ergodic_zsmul {n : ‚Ñ§} (hn : 1 < |n|) : Ergodic fun y : AddCircle T => n ‚Ä¢ y :=\n  { measurePreserving_zsmul volume (abs_pos.mp <| lt_trans zero_lt_one hn) with\n    aeconst_set := fun s hs hs' => by\n      let u : ‚Ñï ‚Üí AddCircle T := fun j => ‚Üë((‚Üë1 : ‚Ñù) / ‚Üë(n.natAbs ^ j) * T)\n      replace hn : 1 < n.natAbs := by rwa [Int.abs_eq_natAbs, Nat.one_lt_cast] at hn\n      have hu‚ÇÄ : ‚àÄ j, addOrderOf (u j) = n.natAbs ^ j := fun j => by\n        convert addOrderOf_div_of_gcd_eq_one (p := T) (m := 1)\n          (pow_pos (pos_of_gt hn) j) (gcd_one_left _)\n        norm_cast\n      have hnu : ‚àÄ j, n ^ j ‚Ä¢ u j = 0 := fun j => by\n        rw [‚Üê addOrderOf_dvd_iff_zsmul_eq_zero, hu‚ÇÄ, Int.natCast_pow, Int.natCast_natAbs, ‚Üê abs_pow,\n          abs_dvd]\n      have hu‚ÇÅ : ‚àÄ j, (u j +·µ• s : Set _) =·µê[volume] s := fun j => by\n        rw [vadd_eq_self_of_preimage_zsmul_eq_self hs' (hnu j)]\n      have hu‚ÇÇ : Tendsto (fun j => addOrderOf <| u j) atTop atTop := by\n        simp_rw [hu‚ÇÄ]; exact Nat.tendsto_pow_atTop_atTop_of_one_lt hn\n      rw [eventuallyConst_set']\n      exact ae_empty_or_univ_of_forall_vadd_ae_eq_self hs.nullMeasurableSet hu‚ÇÅ hu‚ÇÇ }\n\n"}
{"name":"AddCircle.ergodic_nsmul","module":"Mathlib.Dynamics.Ergodic.AddCircle","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\nn : Nat\nhn : LT.lt 1 n\n‚ä¢ Ergodic (fun y => HSMul.hSMul n y) MeasureTheory.MeasureSpace.volume","decl":"theorem ergodic_nsmul {n : ‚Ñï} (hn : 1 < n) : Ergodic fun y : AddCircle T => n ‚Ä¢ y :=\n  ergodic_zsmul (by simp [hn] : 1 < |(n : ‚Ñ§)|)\n\n"}
{"name":"AddCircle.ergodic_zsmul_add","module":"Mathlib.Dynamics.Ergodic.AddCircle","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\nx : AddCircle T\nn : Int\nh : LT.lt 1 (abs n)\n‚ä¢ Ergodic (fun y => HAdd.hAdd (HSMul.hSMul n y) x) MeasureTheory.MeasureSpace.volume","decl":"theorem ergodic_zsmul_add (x : AddCircle T) {n : ‚Ñ§} (h : 1 < |n|) : Ergodic fun y => n ‚Ä¢ y + x := by\n  set f : AddCircle T ‚Üí AddCircle T := fun y => n ‚Ä¢ y + x\n  let e : AddCircle T ‚âÉ·µê AddCircle T := MeasurableEquiv.addLeft (DivisibleBy.div x <| n - 1)\n  have he : MeasurePreserving e volume volume :=\n    measurePreserving_add_left volume (DivisibleBy.div x <| n - 1)\n  suffices e ‚àò f ‚àò e.symm = fun y => n ‚Ä¢ y by\n    rw [‚Üê he.ergodic_conjugate_iff, this]; exact ergodic_zsmul h\n  replace h : n - 1 ‚â† 0 := by\n    rw [‚Üê abs_one] at h; rw [sub_ne_zero]; exact ne_of_apply_ne _ (ne_of_gt h)\n  have hnx : n ‚Ä¢ DivisibleBy.div x (n - 1) = x + DivisibleBy.div x (n - 1) := by\n    conv_rhs => congr; rw [‚Üê DivisibleBy.div_cancel x h]\n    rw [sub_smul, one_smul, sub_add_cancel]\n  ext y\n  simp only [f, e, hnx, MeasurableEquiv.coe_addLeft, MeasurableEquiv.symm_addLeft, comp_apply,\n    smul_add, zsmul_neg', neg_smul, neg_add_rev]\n  abel\n\n"}
{"name":"AddCircle.ergodic_nsmul_add","module":"Mathlib.Dynamics.Ergodic.AddCircle","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\nx : AddCircle T\nn : Nat\nh : LT.lt 1 n\n‚ä¢ Ergodic (fun y => HAdd.hAdd (HSMul.hSMul n y) x) MeasureTheory.MeasureSpace.volume","decl":"theorem ergodic_nsmul_add (x : AddCircle T) {n : ‚Ñï} (h : 1 < n) : Ergodic fun y => n ‚Ä¢ y + x :=\n  ergodic_zsmul_add x (by simp [h] : 1 < |(n : ‚Ñ§)|)\n\n"}
