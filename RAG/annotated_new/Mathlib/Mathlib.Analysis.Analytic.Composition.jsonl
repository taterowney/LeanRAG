{"name":"FormalMultilinearSeries.applyComposition_ones","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ¹â° : CommRing ğ•œ\ninstâœâ¹ : AddCommGroup E\ninstâœâ¸ : AddCommGroup F\ninstâœâ· : Module ğ•œ E\ninstâœâ¶ : Module ğ•œ F\ninstâœâµ : TopologicalSpace E\ninstâœâ´ : TopologicalSpace F\ninstâœÂ³ : TopologicalAddGroup E\ninstâœÂ² : ContinuousConstSMul ğ•œ E\ninstâœÂ¹ : TopologicalAddGroup F\ninstâœ : ContinuousConstSMul ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nn : Nat\nâŠ¢ Eq (p.applyComposition (Composition.ones n)) fun v i => (p 1) fun x => v (Fin.castLE â‹¯ i)","decl":"theorem applyComposition_ones (p : FormalMultilinearSeries ğ•œ E F) (n : â„•) :\n    p.applyComposition (Composition.ones n) = fun v i =>\n      p 1 fun _ => v (Fin.castLE (Composition.length_le _) i) := by\n  funext v i\n  apply p.congr (Composition.ones_blocksFun _ _)\n  intro j hjn hj1\n  obtain rfl : j = 0 := by omega\n  refine congr_arg v ?_\n  rw [Fin.ext_iff, Fin.coe_castLE, Composition.ones_embedding, Fin.val_mk]\n\n"}
{"name":"FormalMultilinearSeries.applyComposition_single","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ¹â° : CommRing ğ•œ\ninstâœâ¹ : AddCommGroup E\ninstâœâ¸ : AddCommGroup F\ninstâœâ· : Module ğ•œ E\ninstâœâ¶ : Module ğ•œ F\ninstâœâµ : TopologicalSpace E\ninstâœâ´ : TopologicalSpace F\ninstâœÂ³ : TopologicalAddGroup E\ninstâœÂ² : ContinuousConstSMul ğ•œ E\ninstâœÂ¹ : TopologicalAddGroup F\ninstâœ : ContinuousConstSMul ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nn : Nat\nhn : LT.lt 0 n\nv : Fin n â†’ E\nâŠ¢ Eq (p.applyComposition (Composition.single n hn) v) fun _j => (p n) v","decl":"theorem applyComposition_single (p : FormalMultilinearSeries ğ•œ E F) {n : â„•} (hn : 0 < n)\n    (v : Fin n â†’ E) : p.applyComposition (Composition.single n hn) v = fun _j => p n v := by\n  ext j\n  refine p.congr (by simp) fun i hi1 hi2 => ?_\n  dsimp\n  congr 1\n  convert Composition.single_embedding hn âŸ¨i, hi2âŸ© using 1\n  cases' j with j_val j_property\n  have : j_val = 0 := le_bot_iff.1 (Nat.lt_succ_iff.1 j_property)\n  congr!\n  simp\n\n"}
{"name":"FormalMultilinearSeries.removeZero_applyComposition","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ¹â° : CommRing ğ•œ\ninstâœâ¹ : AddCommGroup E\ninstâœâ¸ : AddCommGroup F\ninstâœâ· : Module ğ•œ E\ninstâœâ¶ : Module ğ•œ F\ninstâœâµ : TopologicalSpace E\ninstâœâ´ : TopologicalSpace F\ninstâœÂ³ : TopologicalAddGroup E\ninstâœÂ² : ContinuousConstSMul ğ•œ E\ninstâœÂ¹ : TopologicalAddGroup F\ninstâœ : ContinuousConstSMul ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nn : Nat\nc : Composition n\nâŠ¢ Eq (p.removeZero.applyComposition c) (p.applyComposition c)","decl":"@[simp]\ntheorem removeZero_applyComposition (p : FormalMultilinearSeries ğ•œ E F) {n : â„•}\n    (c : Composition n) : p.removeZero.applyComposition c = p.applyComposition c := by\n  ext v i\n  simp [applyComposition, zero_lt_one.trans_le (c.one_le_blocksFun i), removeZero_of_pos]\n\n"}
{"name":"FormalMultilinearSeries.applyComposition_update","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ¹â° : CommRing ğ•œ\ninstâœâ¹ : AddCommGroup E\ninstâœâ¸ : AddCommGroup F\ninstâœâ· : Module ğ•œ E\ninstâœâ¶ : Module ğ•œ F\ninstâœâµ : TopologicalSpace E\ninstâœâ´ : TopologicalSpace F\ninstâœÂ³ : TopologicalAddGroup E\ninstâœÂ² : ContinuousConstSMul ğ•œ E\ninstâœÂ¹ : TopologicalAddGroup F\ninstâœ : ContinuousConstSMul ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nn : Nat\nc : Composition n\nj : Fin n\nv : Fin n â†’ E\nz : E\nâŠ¢ Eq (p.applyComposition c (Function.update v j z)) (Function.update (p.applyComposition c v) (c.index j) ((p (c.blocksFun (c.index j))) (Function.update (Function.comp v â‡‘(c.embedding (c.index j))) (c.invEmbedding j) z)))","decl":"/-- Technical lemma stating how `p.applyComposition` commutes with updating variables. This\nwill be the key point to show that functions constructed from `applyComposition` retain\nmultilinearity. -/\ntheorem applyComposition_update (p : FormalMultilinearSeries ğ•œ E F) {n : â„•} (c : Composition n)\n    (j : Fin n) (v : Fin n â†’ E) (z : E) :\n    p.applyComposition c (Function.update v j z) =\n      Function.update (p.applyComposition c v) (c.index j)\n        (p (c.blocksFun (c.index j))\n          (Function.update (v âˆ˜ c.embedding (c.index j)) (c.invEmbedding j) z)) := by\n  ext k\n  by_cases h : k = c.index j\n  Â· rw [h]\n    let r : Fin (c.blocksFun (c.index j)) â†’ Fin n := c.embedding (c.index j)\n    simp only [Function.update_self]\n    change p (c.blocksFun (c.index j)) (Function.update v j z âˆ˜ r) = _\n    let j' := c.invEmbedding j\n    suffices B : Function.update v j z âˆ˜ r = Function.update (v âˆ˜ r) j' z by rw [B]\n    suffices C : Function.update v (r j') z âˆ˜ r = Function.update (v âˆ˜ r) j' z by\n      convert C; exact (c.embedding_comp_inv j).symm\n    exact Function.update_comp_eq_of_injective _ (c.embedding _).injective _ _\n  Â· simp only [h, Function.update_eq_self, Function.update_of_ne, Ne, not_false_iff]\n    let r : Fin (c.blocksFun k) â†’ Fin n := c.embedding k\n    change p (c.blocksFun k) (Function.update v j z âˆ˜ r) = p (c.blocksFun k) (v âˆ˜ r)\n    suffices B : Function.update v j z âˆ˜ r = v âˆ˜ r by rw [B]\n    apply Function.update_comp_eq_of_not_mem_range\n    rwa [c.mem_range_embedding_iff']\n\n"}
{"name":"FormalMultilinearSeries.compContinuousLinearMap_applyComposition","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœÂ¹âµ : CommRing ğ•œ\ninstâœÂ¹â´ : AddCommGroup E\ninstâœÂ¹Â³ : AddCommGroup F\ninstâœÂ¹Â² : AddCommGroup G\ninstâœÂ¹Â¹ : Module ğ•œ E\ninstâœÂ¹â° : Module ğ•œ F\ninstâœâ¹ : Module ğ•œ G\ninstâœâ¸ : TopologicalSpace E\ninstâœâ· : TopologicalSpace F\ninstâœâ¶ : TopologicalSpace G\ninstâœâµ : TopologicalAddGroup E\ninstâœâ´ : ContinuousConstSMul ğ•œ E\ninstâœÂ³ : TopologicalAddGroup F\ninstâœÂ² : ContinuousConstSMul ğ•œ F\ninstâœÂ¹ : TopologicalAddGroup G\ninstâœ : ContinuousConstSMul ğ•œ G\nn : Nat\np : FormalMultilinearSeries ğ•œ F G\nf : ContinuousLinearMap (RingHom.id ğ•œ) E F\nc : Composition n\nv : Fin n â†’ E\nâŠ¢ Eq ((p.compContinuousLinearMap f).applyComposition c v) (p.applyComposition c (Function.comp (â‡‘f) v))","decl":"@[simp]\ntheorem compContinuousLinearMap_applyComposition {n : â„•} (p : FormalMultilinearSeries ğ•œ F G)\n    (f : E â†’L[ğ•œ] F) (c : Composition n) (v : Fin n â†’ E) :\n    (p.compContinuousLinearMap f).applyComposition c v = p.applyComposition c (f âˆ˜ v) := by\n  simp (config := {unfoldPartialApp := true}) [applyComposition]; rfl\n\n"}
{"name":"ContinuousMultilinearMap.compAlongComposition_apply","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœÂ¹Â³ : CommRing ğ•œ\ninstâœÂ¹Â² : AddCommGroup E\ninstâœÂ¹Â¹ : AddCommGroup F\ninstâœÂ¹â° : AddCommGroup G\ninstâœâ¹ : Module ğ•œ E\ninstâœâ¸ : Module ğ•œ F\ninstâœâ· : Module ğ•œ G\ninstâœâ¶ : TopologicalSpace E\ninstâœâµ : TopologicalSpace F\ninstâœâ´ : TopologicalSpace G\ninstâœÂ³ : TopologicalAddGroup E\ninstâœÂ² : ContinuousConstSMul ğ•œ E\ninstâœÂ¹ : TopologicalAddGroup F\ninstâœ : ContinuousConstSMul ğ•œ F\nn : Nat\np : FormalMultilinearSeries ğ•œ E F\nc : Composition n\nf : ContinuousMultilinearMap ğ•œ (fun i => F) G\nv : Fin n â†’ E\nâŠ¢ Eq ((ContinuousMultilinearMap.compAlongComposition p c f) v) (f (p.applyComposition c v))","decl":"@[simp]\ntheorem compAlongComposition_apply {n : â„•} (p : FormalMultilinearSeries ğ•œ E F) (c : Composition n)\n    (f : F [Ã—c.length]â†’L[ğ•œ] G) (v : Fin n â†’ E) :\n    (f.compAlongComposition p c) v = f (p.applyComposition c v) :=\n  rfl\n\n"}
{"name":"FormalMultilinearSeries.compAlongComposition_apply","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœÂ¹âµ : CommRing ğ•œ\ninstâœÂ¹â´ : AddCommGroup E\ninstâœÂ¹Â³ : AddCommGroup F\ninstâœÂ¹Â² : AddCommGroup G\ninstâœÂ¹Â¹ : Module ğ•œ E\ninstâœÂ¹â° : Module ğ•œ F\ninstâœâ¹ : Module ğ•œ G\ninstâœâ¸ : TopologicalSpace E\ninstâœâ· : TopologicalSpace F\ninstâœâ¶ : TopologicalSpace G\ninstâœâµ : TopologicalAddGroup E\ninstâœâ´ : ContinuousConstSMul ğ•œ E\ninstâœÂ³ : TopologicalAddGroup F\ninstâœÂ² : ContinuousConstSMul ğ•œ F\ninstâœÂ¹ : TopologicalAddGroup G\ninstâœ : ContinuousConstSMul ğ•œ G\nn : Nat\nq : FormalMultilinearSeries ğ•œ F G\np : FormalMultilinearSeries ğ•œ E F\nc : Composition n\nv : Fin n â†’ E\nâŠ¢ Eq ((q.compAlongComposition p c) v) ((q c.length) (p.applyComposition c v))","decl":"@[simp]\ntheorem compAlongComposition_apply {n : â„•} (q : FormalMultilinearSeries ğ•œ F G)\n    (p : FormalMultilinearSeries ğ•œ E F) (c : Composition n) (v : Fin n â†’ E) :\n    (q.compAlongComposition p c) v = q c.length (p.applyComposition c v) :=\n  rfl\n\n"}
{"name":"FormalMultilinearSeries.comp_coeff_zero","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœÂ¹âµ : CommRing ğ•œ\ninstâœÂ¹â´ : AddCommGroup E\ninstâœÂ¹Â³ : AddCommGroup F\ninstâœÂ¹Â² : AddCommGroup G\ninstâœÂ¹Â¹ : Module ğ•œ E\ninstâœÂ¹â° : Module ğ•œ F\ninstâœâ¹ : Module ğ•œ G\ninstâœâ¸ : TopologicalSpace E\ninstâœâ· : TopologicalSpace F\ninstâœâ¶ : TopologicalSpace G\ninstâœâµ : TopologicalAddGroup E\ninstâœâ´ : ContinuousConstSMul ğ•œ E\ninstâœÂ³ : TopologicalAddGroup F\ninstâœÂ² : ContinuousConstSMul ğ•œ F\ninstâœÂ¹ : TopologicalAddGroup G\ninstâœ : ContinuousConstSMul ğ•œ G\nq : FormalMultilinearSeries ğ•œ F G\np : FormalMultilinearSeries ğ•œ E F\nv : Fin 0 â†’ E\nv' : Fin 0 â†’ F\nâŠ¢ Eq ((q.comp p 0) v) ((q 0) v')","decl":"/-- The `0`-th coefficient of `q.comp p` is `q 0`. Since these maps are multilinear maps in zero\nvariables, but on different spaces, we can not state this directly, so we state it when applied to\narbitrary vectors (which have to be the zero vector). -/\ntheorem comp_coeff_zero (q : FormalMultilinearSeries ğ•œ F G) (p : FormalMultilinearSeries ğ•œ E F)\n    (v : Fin 0 â†’ E) (v' : Fin 0 â†’ F) : (q.comp p) 0 v = q 0 v' := by\n  let c : Composition 0 := Composition.ones 0\n  dsimp [FormalMultilinearSeries.comp]\n  have : {c} = (Finset.univ : Finset (Composition 0)) := by\n    apply Finset.eq_of_subset_of_card_le <;> simp [Finset.card_univ, composition_card 0]\n  rw [â† this, Finset.sum_singleton, compAlongComposition_apply]\n  symm; congr! -- Porting note: needed the stronger `congr!`!\n\n"}
{"name":"FormalMultilinearSeries.comp_coeff_zero'","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœÂ¹âµ : CommRing ğ•œ\ninstâœÂ¹â´ : AddCommGroup E\ninstâœÂ¹Â³ : AddCommGroup F\ninstâœÂ¹Â² : AddCommGroup G\ninstâœÂ¹Â¹ : Module ğ•œ E\ninstâœÂ¹â° : Module ğ•œ F\ninstâœâ¹ : Module ğ•œ G\ninstâœâ¸ : TopologicalSpace E\ninstâœâ· : TopologicalSpace F\ninstâœâ¶ : TopologicalSpace G\ninstâœâµ : TopologicalAddGroup E\ninstâœâ´ : ContinuousConstSMul ğ•œ E\ninstâœÂ³ : TopologicalAddGroup F\ninstâœÂ² : ContinuousConstSMul ğ•œ F\ninstâœÂ¹ : TopologicalAddGroup G\ninstâœ : ContinuousConstSMul ğ•œ G\nq : FormalMultilinearSeries ğ•œ F G\np : FormalMultilinearSeries ğ•œ E F\nv : Fin 0 â†’ E\nâŠ¢ Eq ((q.comp p 0) v) ((q 0) fun _i => 0)","decl":"@[simp]\ntheorem comp_coeff_zero' (q : FormalMultilinearSeries ğ•œ F G) (p : FormalMultilinearSeries ğ•œ E F)\n    (v : Fin 0 â†’ E) : (q.comp p) 0 v = q 0 fun _i => 0 :=\n  q.comp_coeff_zero p v _\n\n"}
{"name":"FormalMultilinearSeries.comp_coeff_zero''","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ¹â° : CommRing ğ•œ\ninstâœâ¹ : AddCommGroup E\ninstâœâ¸ : AddCommGroup F\ninstâœâ· : Module ğ•œ E\ninstâœâ¶ : Module ğ•œ F\ninstâœâµ : TopologicalSpace E\ninstâœâ´ : TopologicalSpace F\ninstâœÂ³ : TopologicalAddGroup E\ninstâœÂ² : ContinuousConstSMul ğ•œ E\ninstâœÂ¹ : TopologicalAddGroup F\ninstâœ : ContinuousConstSMul ğ•œ F\nq : FormalMultilinearSeries ğ•œ E F\np : FormalMultilinearSeries ğ•œ E E\nâŠ¢ Eq (q.comp p 0) (q 0)","decl":"/-- The `0`-th coefficient of `q.comp p` is `q 0`. When `p` goes from `E` to `E`, this can be\nexpressed as a direct equality -/\ntheorem comp_coeff_zero'' (q : FormalMultilinearSeries ğ•œ E F) (p : FormalMultilinearSeries ğ•œ E E) :\n    (q.comp p) 0 = q 0 := by ext v; exact q.comp_coeff_zero p _ _\n\n"}
{"name":"FormalMultilinearSeries.comp_coeff_one","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœÂ¹âµ : CommRing ğ•œ\ninstâœÂ¹â´ : AddCommGroup E\ninstâœÂ¹Â³ : AddCommGroup F\ninstâœÂ¹Â² : AddCommGroup G\ninstâœÂ¹Â¹ : Module ğ•œ E\ninstâœÂ¹â° : Module ğ•œ F\ninstâœâ¹ : Module ğ•œ G\ninstâœâ¸ : TopologicalSpace E\ninstâœâ· : TopologicalSpace F\ninstâœâ¶ : TopologicalSpace G\ninstâœâµ : TopologicalAddGroup E\ninstâœâ´ : ContinuousConstSMul ğ•œ E\ninstâœÂ³ : TopologicalAddGroup F\ninstâœÂ² : ContinuousConstSMul ğ•œ F\ninstâœÂ¹ : TopologicalAddGroup G\ninstâœ : ContinuousConstSMul ğ•œ G\nq : FormalMultilinearSeries ğ•œ F G\np : FormalMultilinearSeries ğ•œ E F\nv : Fin 1 â†’ E\nâŠ¢ Eq ((q.comp p 1) v) ((q 1) fun _i => (p 1) v)","decl":"/-- The first coefficient of a composition of formal multilinear series is the composition of the\nfirst coefficients seen as continuous linear maps. -/\ntheorem comp_coeff_one (q : FormalMultilinearSeries ğ•œ F G) (p : FormalMultilinearSeries ğ•œ E F)\n    (v : Fin 1 â†’ E) : (q.comp p) 1 v = q 1 fun _i => p 1 v := by\n  have : {Composition.ones 1} = (Finset.univ : Finset (Composition 1)) :=\n    Finset.eq_univ_of_card _ (by simp [composition_card])\n  simp only [FormalMultilinearSeries.comp, compAlongComposition_apply, â† this,\n    Finset.sum_singleton]\n  refine q.congr (by simp) fun i hi1 hi2 => ?_\n  simp only [applyComposition_ones]\n  exact p.congr rfl fun j _hj1 hj2 => by congr! -- Porting note: needed the stronger `congr!`\n\n"}
{"name":"FormalMultilinearSeries.removeZero_comp_of_pos","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœÂ¹âµ : CommRing ğ•œ\ninstâœÂ¹â´ : AddCommGroup E\ninstâœÂ¹Â³ : AddCommGroup F\ninstâœÂ¹Â² : AddCommGroup G\ninstâœÂ¹Â¹ : Module ğ•œ E\ninstâœÂ¹â° : Module ğ•œ F\ninstâœâ¹ : Module ğ•œ G\ninstâœâ¸ : TopologicalSpace E\ninstâœâ· : TopologicalSpace F\ninstâœâ¶ : TopologicalSpace G\ninstâœâµ : TopologicalAddGroup E\ninstâœâ´ : ContinuousConstSMul ğ•œ E\ninstâœÂ³ : TopologicalAddGroup F\ninstâœÂ² : ContinuousConstSMul ğ•œ F\ninstâœÂ¹ : TopologicalAddGroup G\ninstâœ : ContinuousConstSMul ğ•œ G\nq : FormalMultilinearSeries ğ•œ F G\np : FormalMultilinearSeries ğ•œ E F\nn : Nat\nhn : LT.lt 0 n\nâŠ¢ Eq (q.removeZero.comp p n) (q.comp p n)","decl":"/-- Only `0`-th coefficient of `q.comp p` depends on `q 0`. -/\ntheorem removeZero_comp_of_pos (q : FormalMultilinearSeries ğ•œ F G)\n    (p : FormalMultilinearSeries ğ•œ E F) {n : â„•} (hn : 0 < n) :\n    q.removeZero.comp p n = q.comp p n := by\n  ext v\n  simp only [FormalMultilinearSeries.comp, compAlongComposition,\n    ContinuousMultilinearMap.compAlongComposition_apply, ContinuousMultilinearMap.sum_apply]\n  refine Finset.sum_congr rfl fun c _hc => ?_\n  rw [removeZero_of_pos _ (c.length_pos_of_pos hn)]\n\n"}
{"name":"FormalMultilinearSeries.comp_removeZero","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœÂ¹âµ : CommRing ğ•œ\ninstâœÂ¹â´ : AddCommGroup E\ninstâœÂ¹Â³ : AddCommGroup F\ninstâœÂ¹Â² : AddCommGroup G\ninstâœÂ¹Â¹ : Module ğ•œ E\ninstâœÂ¹â° : Module ğ•œ F\ninstâœâ¹ : Module ğ•œ G\ninstâœâ¸ : TopologicalSpace E\ninstâœâ· : TopologicalSpace F\ninstâœâ¶ : TopologicalSpace G\ninstâœâµ : TopologicalAddGroup E\ninstâœâ´ : ContinuousConstSMul ğ•œ E\ninstâœÂ³ : TopologicalAddGroup F\ninstâœÂ² : ContinuousConstSMul ğ•œ F\ninstâœÂ¹ : TopologicalAddGroup G\ninstâœ : ContinuousConstSMul ğ•œ G\nq : FormalMultilinearSeries ğ•œ F G\np : FormalMultilinearSeries ğ•œ E F\nâŠ¢ Eq (q.comp p.removeZero) (q.comp p)","decl":"@[simp]\ntheorem comp_removeZero (q : FormalMultilinearSeries ğ•œ F G) (p : FormalMultilinearSeries ğ•œ E F) :\n    q.comp p.removeZero = q.comp p := by ext n; simp [FormalMultilinearSeries.comp]\n\n"}
{"name":"FormalMultilinearSeries.compAlongComposition_bound","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : Nat\np : FormalMultilinearSeries ğ•œ E F\nc : Composition n\nf : ContinuousMultilinearMap ğ•œ (fun i => F) G\nv : Fin n â†’ E\nâŠ¢ LE.le (Norm.norm ((ContinuousMultilinearMap.compAlongComposition p c f) v)) (HMul.hMul (HMul.hMul (Norm.norm f) (Finset.univ.prod fun i => Norm.norm (p (c.blocksFun i)))) (Finset.univ.prod fun i => Norm.norm (v i)))","decl":"/-- The norm of `f.compAlongComposition p c` is controlled by the product of\nthe norms of the relevant bits of `f` and `p`. -/\ntheorem compAlongComposition_bound {n : â„•} (p : FormalMultilinearSeries ğ•œ E F) (c : Composition n)\n    (f : F [Ã—c.length]â†’L[ğ•œ] G) (v : Fin n â†’ E) :\n    â€–f.compAlongComposition p c vâ€– â‰¤ (â€–fâ€– * âˆ i, â€–p (c.blocksFun i)â€–) * âˆ i : Fin n, â€–v iâ€– :=\n  calc\n    â€–f.compAlongComposition p c vâ€– = â€–f (p.applyComposition c v)â€– := rfl\n    _ â‰¤ â€–fâ€– * âˆ i, â€–p.applyComposition c v iâ€– := ContinuousMultilinearMap.le_opNorm _ _\n    _ â‰¤ â€–fâ€– * âˆ i, â€–p (c.blocksFun i)â€– * âˆ j : Fin (c.blocksFun i), â€–(v âˆ˜ c.embedding i) jâ€– := by\n      apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)\n      refine Finset.prod_le_prod (fun i _hi => norm_nonneg _) fun i _hi => ?_\n      apply ContinuousMultilinearMap.le_opNorm\n    _ = (â€–fâ€– * âˆ i, â€–p (c.blocksFun i)â€–) *\n        âˆ i, âˆ j : Fin (c.blocksFun i), â€–(v âˆ˜ c.embedding i) jâ€– := by\n      rw [Finset.prod_mul_distrib, mul_assoc]\n    _ = (â€–fâ€– * âˆ i, â€–p (c.blocksFun i)â€–) * âˆ i : Fin n, â€–v iâ€– := by\n      rw [â† c.blocksFinEquiv.prod_comp, â† Finset.univ_sigma_univ, Finset.prod_sigma]\n      congr\n\n"}
{"name":"FormalMultilinearSeries.compAlongComposition_norm","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : Nat\nq : FormalMultilinearSeries ğ•œ F G\np : FormalMultilinearSeries ğ•œ E F\nc : Composition n\nâŠ¢ LE.le (Norm.norm (q.compAlongComposition p c)) (HMul.hMul (Norm.norm (q c.length)) (Finset.univ.prod fun i => Norm.norm (p (c.blocksFun i))))","decl":"/-- The norm of `q.compAlongComposition p c` is controlled by the product of\nthe norms of the relevant bits of `q` and `p`. -/\ntheorem compAlongComposition_norm {n : â„•} (q : FormalMultilinearSeries ğ•œ F G)\n    (p : FormalMultilinearSeries ğ•œ E F) (c : Composition n) :\n    â€–q.compAlongComposition p câ€– â‰¤ â€–q c.lengthâ€– * âˆ i, â€–p (c.blocksFun i)â€– :=\n  ContinuousMultilinearMap.opNorm_le_bound (by positivity) (compAlongComposition_bound _ _ _)\n\n"}
{"name":"FormalMultilinearSeries.compAlongComposition_nnnorm","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : Nat\nq : FormalMultilinearSeries ğ•œ F G\np : FormalMultilinearSeries ğ•œ E F\nc : Composition n\nâŠ¢ LE.le (NNNorm.nnnorm (q.compAlongComposition p c)) (HMul.hMul (NNNorm.nnnorm (q c.length)) (Finset.univ.prod fun i => NNNorm.nnnorm (p (c.blocksFun i))))","decl":"theorem compAlongComposition_nnnorm {n : â„•} (q : FormalMultilinearSeries ğ•œ F G)\n    (p : FormalMultilinearSeries ğ•œ E F) (c : Composition n) :\n    â€–q.compAlongComposition p câ€–â‚Š â‰¤ â€–q c.lengthâ€–â‚Š * âˆ i, â€–p (c.blocksFun i)â€–â‚Š := by\n  rw [â† NNReal.coe_le_coe]; push_cast; exact q.compAlongComposition_norm p c\n\n"}
{"name":"FormalMultilinearSeries.id_apply_zero","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\nv : Fin 0 â†’ E\nâŠ¢ Eq ((FormalMultilinearSeries.id ğ•œ E x 0) v) x","decl":"@[simp] theorem id_apply_zero (x : E) (v : Fin 0 â†’ E) :\n    (FormalMultilinearSeries.id ğ•œ E x) 0 v = x := rfl\n\n"}
{"name":"FormalMultilinearSeries.id_apply_one","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\nv : Fin 1 â†’ E\nâŠ¢ Eq ((FormalMultilinearSeries.id ğ•œ E x 1) v) (v 0)","decl":"/-- The first coefficient of `id ğ•œ E` is the identity. -/\n@[simp]\ntheorem id_apply_one (x : E) (v : Fin 1 â†’ E) : (FormalMultilinearSeries.id ğ•œ E x) 1 v = v 0 :=\n  rfl\n\n"}
{"name":"FormalMultilinearSeries.id_apply_one'","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\nn : Nat\nh : Eq n 1\nv : Fin n â†’ E\nâŠ¢ Eq ((FormalMultilinearSeries.id ğ•œ E x n) v) (v âŸ¨0, â‹¯âŸ©)","decl":"/-- The `n`th coefficient of `id ğ•œ E` is the identity when `n = 1`. We state this in a dependent\nway, as it will often appear in this form. -/\ntheorem id_apply_one' (x : E) {n : â„•} (h : n = 1) (v : Fin n â†’ E) :\n    (id ğ•œ E x) n v = v âŸ¨0, h.symm â–¸ zero_lt_oneâŸ© := by\n  subst n\n  apply id_apply_one\n\n"}
{"name":"FormalMultilinearSeries.id_apply_of_one_lt","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\nn : Nat\nh : LT.lt 1 n\nâŠ¢ Eq (FormalMultilinearSeries.id ğ•œ E x n) 0","decl":"/-- For `n â‰  1`, the `n`-th coefficient of `id ğ•œ E` is zero, by definition. -/\n@[simp]\ntheorem id_apply_of_one_lt (x : E) {n : â„•} (h : 1 < n) :\n    (FormalMultilinearSeries.id ğ•œ E x) n = 0 := by\n  cases' n with n\n  Â· contradiction\n  Â· cases n\n    Â· contradiction\n    Â· rfl\n\n"}
{"name":"FormalMultilinearSeries.comp_id","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nâŠ¢ Eq (p.comp (FormalMultilinearSeries.id ğ•œ E x)) p","decl":"@[simp]\ntheorem comp_id (p : FormalMultilinearSeries ğ•œ E F) (x : E) : p.comp (id ğ•œ E x) = p := by\n  ext1 n\n  dsimp [FormalMultilinearSeries.comp]\n  rw [Finset.sum_eq_single (Composition.ones n)]\n  Â· show compAlongComposition p (id ğ•œ E x) (Composition.ones n) = p n\n    ext v\n    rw [compAlongComposition_apply]\n    apply p.congr (Composition.ones_length n)\n    intros\n    rw [applyComposition_ones]\n    refine congr_arg v ?_\n    rw [Fin.ext_iff, Fin.coe_castLE, Fin.val_mk]\n  Â· show\n    âˆ€ b : Composition n,\n      b âˆˆ Finset.univ â†’ b â‰  Composition.ones n â†’ compAlongComposition p (id ğ•œ E x) b = 0\n    intro b _ hb\n    obtain âŸ¨k, hk, lt_kâŸ© : âˆƒ (k : â„•), k âˆˆ Composition.blocks b âˆ§ 1 < k :=\n      Composition.ne_ones_iff.1 hb\n    obtain âŸ¨i, hiâŸ© : âˆƒ (i : Fin b.blocks.length), b.blocks[i] = k :=\n      List.get_of_mem hk\n    let j : Fin b.length := âŸ¨i.val, b.blocks_length â–¸ i.propâŸ©\n    have A : 1 < b.blocksFun j := by convert lt_k\n    ext v\n    rw [compAlongComposition_apply, ContinuousMultilinearMap.zero_apply]\n    apply ContinuousMultilinearMap.map_coord_zero _ j\n    dsimp [applyComposition]\n    rw [id_apply_of_one_lt _ _ _ A]\n    rfl\n  Â· simp\n\n"}
{"name":"FormalMultilinearSeries.id_comp","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nv0 : Fin 0 â†’ E\nâŠ¢ Eq ((FormalMultilinearSeries.id ğ•œ F ((p 0) v0)).comp p) p","decl":"@[simp]\ntheorem id_comp (p : FormalMultilinearSeries ğ•œ E F) (v0 : Fin 0 â†’ E) :\n    (id ğ•œ F (p 0 v0)).comp p = p := by\n  ext1 n\n  by_cases hn : n = 0\n  Â· rw [hn]\n    ext v\n    simp only [comp_coeff_zero', id_apply_zero]\n    congr with i\n    exact i.elim0\n  Â· dsimp [FormalMultilinearSeries.comp]\n    have n_pos : 0 < n := bot_lt_iff_ne_bot.mpr hn\n    rw [Finset.sum_eq_single (Composition.single n n_pos)]\n    Â· show compAlongComposition (id ğ•œ F (p 0 v0)) p (Composition.single n n_pos) = p n\n      ext v\n      rw [compAlongComposition_apply, id_apply_one' _ _ _ (Composition.single_length n_pos)]\n      dsimp [applyComposition]\n      refine p.congr rfl fun i him hin => congr_arg v <| ?_\n      ext; simp\n    Â· show\n      âˆ€ b : Composition n, b âˆˆ Finset.univ â†’ b â‰  Composition.single n n_pos â†’\n        compAlongComposition (id ğ•œ F (p 0 v0)) p b = 0\n      intro b _ hb\n      have A : 1 < b.length := by\n        have : b.length â‰  1 := by simpa [Composition.eq_single_iff_length] using hb\n        have : 0 < b.length := Composition.length_pos_of_pos b n_pos\n        omega\n      ext v\n      rw [compAlongComposition_apply, id_apply_of_one_lt _ _ _ A]\n      rfl\n    Â· simp\n\n"}
{"name":"FormalMultilinearSeries.id_comp'","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nx : F\nv0 : Fin 0 â†’ E\nh : Eq x ((p 0) v0)\nâŠ¢ Eq ((FormalMultilinearSeries.id ğ•œ F x).comp p) p","decl":"/-- Variant of `id_comp` in which the zero coefficient is given by an equality hypothesis instead\nof a definitional equality. Useful for rewriting or simplifying out in some situations. -/\ntheorem id_comp' (p : FormalMultilinearSeries ğ•œ E F) (x : F) (v0 : Fin 0 â†’ E) (h : x = p 0 v0) :\n    (id ğ•œ F x).comp p = p := by\n  simp [h]\n\n"}
{"name":"FormalMultilinearSeries.comp_summable_nnreal","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nq : FormalMultilinearSeries ğ•œ F G\np : FormalMultilinearSeries ğ•œ E F\nhq : LT.lt 0 q.radius\nhp : LT.lt 0 p.radius\nâŠ¢ Exists fun r => And (GT.gt r 0) (Summable fun i => HMul.hMul (NNNorm.nnnorm (q.compAlongComposition p i.snd)) (HPow.hPow r i.fst))","decl":"/-- If two formal multilinear series have positive radius of convergence, then the terms appearing\nin the definition of their composition are also summable (when multiplied by a suitable positive\ngeometric term). -/\ntheorem comp_summable_nnreal (q : FormalMultilinearSeries ğ•œ F G) (p : FormalMultilinearSeries ğ•œ E F)\n    (hq : 0 < q.radius) (hp : 0 < p.radius) :\n    âˆƒ r > (0 : â„â‰¥0),\n      Summable fun i : Î£ n, Composition n => â€–q.compAlongComposition p i.2â€–â‚Š * r ^ i.1 := by\n  /- This follows from the fact that the growth rate of `â€–qâ‚™â€–` and `â€–pâ‚™â€–` is at most geometric,\n    giving a geometric bound on each `â€–q.compAlongComposition p opâ€–`, together with the\n    fact that there are `2^(n-1)` compositions of `n`, giving at most a geometric loss. -/\n  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 (lt_min zero_lt_one hq) with âŸ¨rq, rq_pos, hrqâŸ©\n  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 (lt_min zero_lt_one hp) with âŸ¨rp, rp_pos, hrpâŸ©\n  simp only [lt_min_iff, ENNReal.coe_lt_one_iff, ENNReal.coe_pos] at hrp hrq rp_pos rq_pos\n  obtain âŸ¨Cq, _hCq0, hCqâŸ© : âˆƒ Cq > 0, âˆ€ n, â€–q nâ€–â‚Š * rq ^ n â‰¤ Cq :=\n    q.nnnorm_mul_pow_le_of_lt_radius hrq.2\n  obtain âŸ¨Cp, hCp1, hCpâŸ© : âˆƒ Cp â‰¥ 1, âˆ€ n, â€–p nâ€–â‚Š * rp ^ n â‰¤ Cp := by\n    rcases p.nnnorm_mul_pow_le_of_lt_radius hrp.2 with âŸ¨Cp, -, hCpâŸ©\n    exact âŸ¨max Cp 1, le_max_right _ _, fun n => (hCp n).trans (le_max_left _ _)âŸ©\n  let r0 : â„â‰¥0 := (4 * Cp)â»Â¹\n  have r0_pos : 0 < r0 := inv_pos.2 (mul_pos zero_lt_four (zero_lt_one.trans_le hCp1))\n  set r : â„â‰¥0 := rp * rq * r0\n  have r_pos : 0 < r := mul_pos (mul_pos rp_pos rq_pos) r0_pos\n  have I :\n    âˆ€ i : Î£ n : â„•, Composition n, â€–q.compAlongComposition p i.2â€–â‚Š * r ^ i.1 â‰¤ Cq / 4 ^ i.1 := by\n    rintro âŸ¨n, câŸ©\n    have A := calc\n      â€–q c.lengthâ€–â‚Š * rq ^ n â‰¤ â€–q c.lengthâ€–â‚Š * rq ^ c.length :=\n        mul_le_mul' le_rfl (pow_le_pow_of_le_one rq.2 hrq.1.le c.length_le)\n      _ â‰¤ Cq := hCq _\n    have B := calc\n      (âˆ i, â€–p (c.blocksFun i)â€–â‚Š) * rp ^ n = âˆ i, â€–p (c.blocksFun i)â€–â‚Š * rp ^ c.blocksFun i := by\n        simp only [Finset.prod_mul_distrib, Finset.prod_pow_eq_pow_sum, c.sum_blocksFun]\n      _ â‰¤ âˆ _i : Fin c.length, Cp := Finset.prod_le_prod' fun i _ => hCp _\n      _ = Cp ^ c.length := by simp\n      _ â‰¤ Cp ^ n := pow_right_monoâ‚€ hCp1 c.length_le\n    calc\n      â€–q.compAlongComposition p câ€–â‚Š * r ^ n â‰¤\n          (â€–q c.lengthâ€–â‚Š * âˆ i, â€–p (c.blocksFun i)â€–â‚Š) * r ^ n :=\n        mul_le_mul' (q.compAlongComposition_nnnorm p c) le_rfl\n      _ = â€–q c.lengthâ€–â‚Š * rq ^ n * ((âˆ i, â€–p (c.blocksFun i)â€–â‚Š) * rp ^ n) * r0 ^ n := by\n        ring\n      _ â‰¤ Cq * Cp ^ n * r0 ^ n := mul_le_mul' (mul_le_mul' A B) le_rfl\n      _ = Cq / 4 ^ n := by\n        simp only [r0]\n        field_simp [mul_pow, (zero_lt_one.trans_le hCp1).ne']\n        ring\n  refine âŸ¨r, r_pos, NNReal.summable_of_le I ?_âŸ©\n  simp_rw [div_eq_mul_inv]\n  refine Summable.mul_left _ ?_\n  have : âˆ€ n : â„•, HasSum (fun c : Composition n => (4 ^ n : â„â‰¥0)â»Â¹) (2 ^ (n - 1) / 4 ^ n) := by\n    intro n\n    convert hasSum_fintype fun c : Composition n => (4 ^ n : â„â‰¥0)â»Â¹\n    simp [Finset.card_univ, composition_card, div_eq_mul_inv]\n  refine NNReal.summable_sigma.2 âŸ¨fun n => (this n).summable, (NNReal.summable_nat_add_iff 1).1 ?_âŸ©\n  convert (NNReal.summable_geometric (NNReal.div_lt_one_of_lt one_lt_two)).mul_left (1 / 4) using 1\n  ext1 n\n  rw [(this _).tsum_eq, add_tsub_cancel_right]\n  field_simp [â† mul_assoc, pow_succ, mul_pow, show (4 : â„â‰¥0) = 2 * 2 by norm_num,\n    mul_right_comm]\n\n"}
{"name":"FormalMultilinearSeries.le_comp_radius_of_summable","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nq : FormalMultilinearSeries ğ•œ F G\np : FormalMultilinearSeries ğ•œ E F\nr : NNReal\nhr : Summable fun i => HMul.hMul (NNNorm.nnnorm (q.compAlongComposition p i.snd)) (HPow.hPow r i.fst)\nâŠ¢ LE.le (â†‘r) (q.comp p).radius","decl":"/-- Bounding below the radius of the composition of two formal multilinear series assuming\nsummability over all compositions. -/\ntheorem le_comp_radius_of_summable (q : FormalMultilinearSeries ğ•œ F G)\n    (p : FormalMultilinearSeries ğ•œ E F) (r : â„â‰¥0)\n    (hr : Summable fun i : Î£ n, Composition n => â€–q.compAlongComposition p i.2â€–â‚Š * r ^ i.1) :\n    (r : â„â‰¥0âˆ) â‰¤ (q.comp p).radius := by\n  refine\n    le_radius_of_bound_nnreal _\n      (âˆ‘' i : Î£ n, Composition n, â€–compAlongComposition q p i.sndâ€–â‚Š * r ^ i.fst) fun n => ?_\n  calc\n    â€–FormalMultilinearSeries.comp q p nâ€–â‚Š * r ^ n â‰¤\n        âˆ‘' c : Composition n, â€–compAlongComposition q p câ€–â‚Š * r ^ n := by\n      rw [tsum_fintype, â† Finset.sum_mul]\n      exact mul_le_mul' (nnnorm_sum_le _ _) le_rfl\n    _ â‰¤ âˆ‘' i : Î£ n : â„•, Composition n, â€–compAlongComposition q p i.sndâ€–â‚Š * r ^ i.fst :=\n      NNReal.tsum_comp_le_tsum_of_inj hr sigma_mk_injective\n\n"}
{"name":"FormalMultilinearSeries.mem_compPartialSumSource_iff","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"m M N : Nat\ni : Sigma fun n => Fin n â†’ Nat\nâŠ¢ Iff (Membership.mem (FormalMultilinearSeries.compPartialSumSource m M N) i) (And (And (LE.le m i.fst) (LT.lt i.fst M)) (âˆ€ (a : Fin i.fst), And (LE.le 1 (i.snd a)) (LT.lt (i.snd a) N)))","decl":"@[simp]\ntheorem mem_compPartialSumSource_iff (m M N : â„•) (i : Î£ n, Fin n â†’ â„•) :\n    i âˆˆ compPartialSumSource m M N â†”\n      (m â‰¤ i.1 âˆ§ i.1 < M) âˆ§ âˆ€ a : Fin i.1, 1 â‰¤ i.2 a âˆ§ i.2 a < N := by\n  simp only [compPartialSumSource, Finset.mem_Ico, Fintype.mem_piFinset, Finset.mem_sigma]\n\n"}
{"name":"FormalMultilinearSeries.compChangeOfVariables_length","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"m M N : Nat\ni : Sigma fun n => Fin n â†’ Nat\nhi : Membership.mem (FormalMultilinearSeries.compPartialSumSource m M N) i\nâŠ¢ Eq (FormalMultilinearSeries.compChangeOfVariables m M N i hi).snd.length i.fst","decl":"@[simp]\ntheorem compChangeOfVariables_length (m M N : â„•) {i : Î£ n, Fin n â†’ â„•}\n    (hi : i âˆˆ compPartialSumSource m M N) :\n    Composition.length (compChangeOfVariables m M N i hi).2 = i.1 := by\n  rcases i with âŸ¨k, blocks_funâŸ©\n  dsimp [compChangeOfVariables]\n  simp only [Composition.length, map_ofFn, length_ofFn]\n\n"}
{"name":"FormalMultilinearSeries.compChangeOfVariables_blocksFun","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"m M N : Nat\ni : Sigma fun n => Fin n â†’ Nat\nhi : Membership.mem (FormalMultilinearSeries.compPartialSumSource m M N) i\nj : Fin i.fst\nâŠ¢ Eq ((FormalMultilinearSeries.compChangeOfVariables m M N i hi).snd.blocksFun âŸ¨â†‘j, â‹¯âŸ©) (i.snd j)","decl":"theorem compChangeOfVariables_blocksFun (m M N : â„•) {i : Î£ n, Fin n â†’ â„•}\n    (hi : i âˆˆ compPartialSumSource m M N) (j : Fin i.1) :\n    (compChangeOfVariables m M N i hi).2.blocksFun\n        âŸ¨j, (compChangeOfVariables_length m M N hi).symm â–¸ j.2âŸ© =\n      i.2 j := by\n  rcases i with âŸ¨n, fâŸ©\n  dsimp [Composition.blocksFun, Composition.blocks, compChangeOfVariables]\n  simp only [map_ofFn, List.getElem_ofFn, Function.comp_apply]\n\n"}
{"name":"FormalMultilinearSeries.compPartialSumTargetSet_image_compPartialSumSource","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"m M N : Nat\ni : Sigma fun n => Composition n\nhi : Membership.mem (FormalMultilinearSeries.compPartialSumTargetSet m M N) i\nâŠ¢ Exists fun j => Exists fun hj => Eq (FormalMultilinearSeries.compChangeOfVariables m M N j hj) i","decl":"theorem compPartialSumTargetSet_image_compPartialSumSource (m M N : â„•)\n    (i : Î£ n, Composition n) (hi : i âˆˆ compPartialSumTargetSet m M N) :\n    âˆƒ (j : _) (hj : j âˆˆ compPartialSumSource m M N), compChangeOfVariables m M N j hj = i := by\n  rcases i with âŸ¨n, câŸ©\n  refine âŸ¨âŸ¨c.length, c.blocksFunâŸ©, ?_, ?_âŸ©\n  Â· simp only [compPartialSumTargetSet, Set.mem_setOf_eq] at hi\n    simp only [mem_compPartialSumSource_iff, hi.left, hi.right, true_and, and_true]\n    exact fun a => c.one_le_blocks' _\n  Â· dsimp [compChangeOfVariables]\n    rw [Composition.sigma_eq_iff_blocks_eq]\n    simp only [Composition.blocksFun, Composition.blocks, Subtype.coe_eta]\n    conv_rhs => rw [â† List.ofFn_get c.blocks]\n\n"}
{"name":"FormalMultilinearSeries.mem_compPartialSumTarget_iff","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"m M N : Nat\na : Sigma fun n => Composition n\nâŠ¢ Iff (Membership.mem (FormalMultilinearSeries.compPartialSumTarget m M N) a) (And (LE.le m a.snd.length) (And (LT.lt a.snd.length M) (âˆ€ (j : Fin a.snd.length), LT.lt (a.snd.blocksFun j) N)))","decl":"@[simp]\ntheorem mem_compPartialSumTarget_iff {m M N : â„•} {a : Î£ n, Composition n} :\n    a âˆˆ compPartialSumTarget m M N â†”\n      m â‰¤ a.2.length âˆ§ a.2.length < M âˆ§ âˆ€ j : Fin a.2.length, a.2.blocksFun j < N := by\n  simp [compPartialSumTarget, compPartialSumTargetSet]\n\n"}
{"name":"FormalMultilinearSeries.compChangeOfVariables_sum","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"Î± : Type u_6\ninstâœ : AddCommMonoid Î±\nm M N : Nat\nf : (Sigma fun n => Fin n â†’ Nat) â†’ Î±\ng : (Sigma fun n => Composition n) â†’ Î±\nh : âˆ€ (e : Sigma fun n => Fin n â†’ Nat) (he : Membership.mem (FormalMultilinearSeries.compPartialSumSource m M N) e), Eq (f e) (g (FormalMultilinearSeries.compChangeOfVariables m M N e he))\nâŠ¢ Eq ((FormalMultilinearSeries.compPartialSumSource m M N).sum fun e => f e) ((FormalMultilinearSeries.compPartialSumTarget m M N).sum fun e => g e)","decl":"/-- `compChangeOfVariables m M N` is a bijection between `compPartialSumSource m M N`\nand `compPartialSumTarget m M N`, yielding equal sums for functions that correspond to each\nother under the bijection. As `compChangeOfVariables m M N` is a dependent function, stating\nthat it is a bijection is not directly possible, but the consequence on sums can be stated\nmore easily. -/\ntheorem compChangeOfVariables_sum {Î± : Type*} [AddCommMonoid Î±] (m M N : â„•)\n    (f : (Î£ n : â„•, Fin n â†’ â„•) â†’ Î±) (g : (Î£ n, Composition n) â†’ Î±)\n    (h : âˆ€ (e) (he : e âˆˆ compPartialSumSource m M N), f e = g (compChangeOfVariables m M N e he)) :\n    âˆ‘ e âˆˆ compPartialSumSource m M N, f e = âˆ‘ e âˆˆ compPartialSumTarget m M N, g e := by\n  apply Finset.sum_bij (compChangeOfVariables m M N)\n  -- We should show that the correspondence we have set up is indeed a bijection\n  -- between the index sets of the two sums.\n  -- 1 - show that the image belongs to `compPartialSumTarget m N N`\n  Â· rintro âŸ¨k, blocks_funâŸ© H\n    rw [mem_compPartialSumSource_iff] at H\n    -- Porting note: added\n    simp only at H\n    simp only [mem_compPartialSumTarget_iff, Composition.length, Composition.blocks, H.left,\n      map_ofFn, length_ofFn, true_and, compChangeOfVariables]\n    intro j\n    simp only [Composition.blocksFun, (H.right _).right, List.get_ofFn]\n  -- 2 - show that the map is injective\n  Â· rintro âŸ¨k, blocks_funâŸ© H âŸ¨k', blocks_fun'âŸ© H' heq\n    obtain rfl : k = k' := by\n      have := (compChangeOfVariables_length m M N H).symm\n      rwa [heq, compChangeOfVariables_length] at this\n    congr\n    funext i\n    calc\n      blocks_fun i = (compChangeOfVariables m M N _ H).2.blocksFun _ :=\n        (compChangeOfVariables_blocksFun m M N H i).symm\n      _ = (compChangeOfVariables m M N _ H').2.blocksFun _ := by\n        apply Composition.blocksFun_congr <;>\n        first | rw [heq] | rfl\n      _ = blocks_fun' i := compChangeOfVariables_blocksFun m M N H' i\n  -- 3 - show that the map is surjective\n  Â· intro i hi\n    apply compPartialSumTargetSet_image_compPartialSumSource m M N i\n    simpa [compPartialSumTarget] using hi\n  -- 4 - show that the composition gives the `compAlongComposition` application\n  Â· rintro âŸ¨k, blocks_funâŸ© H\n    rw [h]\n\n"}
{"name":"FormalMultilinearSeries.compPartialSumTarget_tendsto_prod_atTop","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"âŠ¢ Filter.Tendsto (fun p => FormalMultilinearSeries.compPartialSumTarget 0 p.1 p.2) Filter.atTop Filter.atTop","decl":"/-- The auxiliary set corresponding to the composition of partial sums asymptotically contains\nall possible compositions. -/\ntheorem compPartialSumTarget_tendsto_prod_atTop :\n    Tendsto (fun (p : â„• Ã— â„•) => compPartialSumTarget 0 p.1 p.2) atTop atTop := by\n  apply Monotone.tendsto_atTop_finset\n  Â· intro m n hmn a ha\n    have : âˆ€ i, i < m.1 â†’ i < n.1 := fun i hi => lt_of_lt_of_le hi hmn.1\n    have : âˆ€ i, i < m.2 â†’ i < n.2 := fun i hi => lt_of_lt_of_le hi hmn.2\n    aesop\n  Â· rintro âŸ¨n, câŸ©\n    simp only [mem_compPartialSumTarget_iff]\n    obtain âŸ¨n, hnâŸ© : BddAbove ((Finset.univ.image fun i : Fin c.length => c.blocksFun i) : Set â„•) :=\n      Finset.bddAbove _\n    refine\n      âŸ¨max n c.length + 1, bot_le, lt_of_le_of_lt (le_max_right n c.length) (lt_add_one _), fun j =>\n        lt_of_le_of_lt (le_trans ?_ (le_max_left _ _)) (lt_add_one _)âŸ©\n    apply hn\n    simp only [Finset.mem_image_of_mem, Finset.mem_coe, Finset.mem_univ]\n\n"}
{"name":"FormalMultilinearSeries.compPartialSumTarget_tendsto_atTop","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"âŠ¢ Filter.Tendsto (fun N => FormalMultilinearSeries.compPartialSumTarget 0 N N) Filter.atTop Filter.atTop","decl":"/-- The auxiliary set corresponding to the composition of partial sums asymptotically contains\nall possible compositions. -/\ntheorem compPartialSumTarget_tendsto_atTop :\n    Tendsto (fun N => compPartialSumTarget 0 N N) atTop atTop := by\n  apply Tendsto.comp compPartialSumTarget_tendsto_prod_atTop tendsto_atTop_diagonal\n\n"}
{"name":"FormalMultilinearSeries.comp_partialSum","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nq : FormalMultilinearSeries ğ•œ F G\np : FormalMultilinearSeries ğ•œ E F\nM N : Nat\nz : E\nâŠ¢ Eq (q.partialSum M ((Finset.Ico 1 N).sum fun i => (p i) fun _j => z)) ((FormalMultilinearSeries.compPartialSumTarget 0 M N).sum fun i => (q.compAlongComposition p i.snd) fun _j => z)","decl":"/-- Composing the partial sums of two multilinear series coincides with the sum over all\ncompositions in `compPartialSumTarget 0 N N`. This is precisely the motivation for the\ndefinition of `compPartialSumTarget`. -/\ntheorem comp_partialSum (q : FormalMultilinearSeries ğ•œ F G) (p : FormalMultilinearSeries ğ•œ E F)\n    (M N : â„•) (z : E) :\n    q.partialSum M (âˆ‘ i âˆˆ Finset.Ico 1 N, p i fun _j => z) =\n      âˆ‘ i âˆˆ compPartialSumTarget 0 M N, q.compAlongComposition p i.2 fun _j => z := by\n  -- we expand the composition, using the multilinearity of `q` to expand along each coordinate.\n  suffices H :\n    (âˆ‘ n âˆˆ Finset.range M,\n        âˆ‘ r âˆˆ Fintype.piFinset fun i : Fin n => Finset.Ico 1 N,\n          q n fun i : Fin n => p (r i) fun _j => z) =\n      âˆ‘ i âˆˆ compPartialSumTarget 0 M N, q.compAlongComposition p i.2 fun _j => z by\n    simpa only [FormalMultilinearSeries.partialSum, ContinuousMultilinearMap.map_sum_finset] using H\n  -- rewrite the first sum as a big sum over a sigma type, in the finset\n  -- `compPartialSumTarget 0 N N`\n  rw [Finset.range_eq_Ico, Finset.sum_sigma']\n  -- use `compChangeOfVariables_sum`, saying that this change of variables respects sums\n  apply compChangeOfVariables_sum 0 M N\n  rintro âŸ¨k, blocks_funâŸ© H\n  apply congr _ (compChangeOfVariables_length 0 M N H).symm\n  intros\n  rw [â† compChangeOfVariables_blocksFun 0 M N H]\n  rfl\n\n"}
{"name":"HasFPowerSeriesWithinAt.comp","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ng : F â†’ G\nf : E â†’ F\nq : FormalMultilinearSeries ğ•œ F G\np : FormalMultilinearSeries ğ•œ E F\nx : E\nt : Set F\ns : Set E\nhg : HasFPowerSeriesWithinAt g q t (f x)\nhf : HasFPowerSeriesWithinAt f p s x\nhs : Set.MapsTo f s t\nâŠ¢ HasFPowerSeriesWithinAt (Function.comp g f) (q.comp p) s x","decl":"/-- If two functions `g` and `f` have power series `q` and `p` respectively at `f x` and `x`, within\ntwo sets `s` and `t` such that `f` maps `s` to `t`, then `g âˆ˜ f` admits the power\nseries `q.comp p` at `x` within `s`. -/\ntheorem HasFPowerSeriesWithinAt.comp {g : F â†’ G} {f : E â†’ F} {q : FormalMultilinearSeries ğ•œ F G}\n    {p : FormalMultilinearSeries ğ•œ E F} {x : E} {t : Set F} {s : Set E}\n    (hg : HasFPowerSeriesWithinAt g q t (f x)) (hf : HasFPowerSeriesWithinAt f p s x)\n    (hs : Set.MapsTo f s t) : HasFPowerSeriesWithinAt (g âˆ˜ f) (q.comp p) s x := by\n  /- Consider `rf` and `rg` such that `f` and `g` have power series expansion on the disks\n    of radius `rf` and `rg`. -/\n  rcases hg with âŸ¨rg, HgâŸ©\n  rcases hf with âŸ¨rf, HfâŸ©\n  -- The terms defining `q.comp p` are geometrically summable in a disk of some radius `r`.\n  rcases q.comp_summable_nnreal p Hg.radius_pos Hf.radius_pos with âŸ¨r, r_pos : 0 < r, hrâŸ©\n  /- We will consider `y` which is smaller than `r` and `rf`, and also small enough that\n    `f (x + y)` is close enough to `f x` to be in the disk where `g` is well behaved. Let\n    `min (r, rf, Î´)` be this new radius. -/\n  obtain âŸ¨Î´, Î´pos, hÎ´âŸ© :\n    âˆƒ Î´ : â„â‰¥0âˆ, 0 < Î´ âˆ§ âˆ€ {z : E}, z âˆˆ insert x s âˆ© EMetric.ball x Î´\n      â†’ f z âˆˆ insert (f x) t âˆ© EMetric.ball (f x) rg := by\n    have : insert (f x) t âˆ© EMetric.ball (f x) rg âˆˆ ğ“[insert (f x) t] (f x) := by\n      apply inter_mem_nhdsWithin\n      exact EMetric.ball_mem_nhds _ Hg.r_pos\n    have := Hf.analyticWithinAt.continuousWithinAt_insert.tendsto_nhdsWithin (hs.insert x) this\n    rcases EMetric.mem_nhdsWithin_iff.1 this with âŸ¨Î´, Î´pos, HÎ´âŸ©\n    exact âŸ¨Î´, Î´pos, fun {z} hz => HÎ´ (by rwa [Set.inter_comm])âŸ©\n  let rf' := min rf Î´\n  have min_pos : 0 < min rf' r := by\n    simp only [rf', r_pos, Hf.r_pos, Î´pos, lt_min_iff, ENNReal.coe_pos, and_self_iff]\n  /- We will show that `g âˆ˜ f` admits the power series `q.comp p` in the disk of\n    radius `min (r, rf', Î´)`. -/\n  refine âŸ¨min rf' r, ?_âŸ©\n  refine\n    âŸ¨le_trans (min_le_right rf' r) (FormalMultilinearSeries.le_comp_radius_of_summable q p r hr),\n      min_pos, fun {y} h'y hy â†¦ ?_âŸ©\n  /- Let `y` satisfy `â€–yâ€– < min (r, rf', Î´)`. We want to show that `g (f (x + y))` is the sum of\n    `q.comp p` applied to `y`. -/\n  -- First, check that `y` is small enough so that estimates for `f` and `g` apply.\n  have y_mem : y âˆˆ EMetric.ball (0 : E) rf :=\n    (EMetric.ball_subset_ball (le_trans (min_le_left _ _) (min_le_left _ _))) hy\n  have fy_mem : f (x + y) âˆˆ insert (f x) t âˆ© EMetric.ball (f x) rg := by\n    apply hÎ´\n    have : y âˆˆ EMetric.ball (0 : E) Î´ :=\n      (EMetric.ball_subset_ball (le_trans (min_le_left _ _) (min_le_right _ _))) hy\n    simpa [-Set.mem_insert_iff, edist_eq_enorm_sub, h'y]\n  /- Now the proof starts. To show that the sum of `q.comp p` at `y` is `g (f (x + y))`,\n    we will write `q.comp p` applied to `y` as a big sum over all compositions.\n    Since the sum is summable, to get its convergence it suffices to get\n    the convergence along some increasing sequence of sets.\n    We will use the sequence of sets `compPartialSumTarget 0 n n`,\n    along which the sum is exactly the composition of the partial sums of `q` and `p`, by design.\n    To show that it converges to `g (f (x + y))`, pointwise convergence would not be enough,\n    but we have uniform convergence to save the day. -/\n  -- First step: the partial sum of `p` converges to `f (x + y)`.\n  have A : Tendsto (fun n â†¦ (n, âˆ‘ a âˆˆ Finset.Ico 1 n, p a fun _ â†¦ y))\n      atTop (atTop Ã—Ë¢ ğ“ (f (x + y) - f x)) := by\n    apply Tendsto.prod_mk tendsto_id\n    have L : âˆ€á¶  n in atTop, (âˆ‘ a âˆˆ Finset.range n, p a fun _b â†¦ y) - f x\n        = âˆ‘ a âˆˆ Finset.Ico 1 n, p a fun _b â†¦ y := by\n      rw [eventually_atTop]\n      refine âŸ¨1, fun n hn => ?_âŸ©\n      symm\n      rw [eq_sub_iff_add_eq', Finset.range_eq_Ico, â† Hf.coeff_zero fun _i => y,\n        Finset.sum_eq_sum_Ico_succ_bot hn]\n    have :\n      Tendsto (fun n => (âˆ‘ a âˆˆ Finset.range n, p a fun _b => y) - f x) atTop\n        (ğ“ (f (x + y) - f x)) :=\n      (Hf.hasSum h'y y_mem).tendsto_sum_nat.sub tendsto_const_nhds\n    exact Tendsto.congr' L this\n  -- Second step: the composition of the partial sums of `q` and `p` converges to `g (f (x + y))`.\n  have B : Tendsto (fun n => q.partialSum n (âˆ‘ a âˆˆ Finset.Ico 1 n, p a fun _b â†¦ y)) atTop\n      (ğ“ (g (f (x + y)))) := by\n    -- we use the fact that the partial sums of `q` converge to `g (f (x + y))`, uniformly on a\n    -- neighborhood of `f (x + y)`.\n    have : Tendsto (fun (z : â„• Ã— F) â†¦ q.partialSum z.1 z.2)\n        (atTop Ã—Ë¢ ğ“ (f (x + y) - f x)) (ğ“ (g (f x + (f (x + y) - f x)))) := by\n      apply Hg.tendsto_partialSum_prod (y := f (x + y) - f x)\n      Â· simpa [edist_eq_enorm_sub] using fy_mem.2\n      Â· simpa using fy_mem.1\n    simpa using this.comp A\n  -- Third step: the sum over all compositions in `compPartialSumTarget 0 n n` converges to\n  -- `g (f (x + y))`. As this sum is exactly the composition of the partial sum, this is a direct\n  -- consequence of the second step\n  have C :\n    Tendsto\n      (fun n => âˆ‘ i âˆˆ compPartialSumTarget 0 n n, q.compAlongComposition p i.2 fun _j => y)\n      atTop (ğ“ (g (f (x + y)))) := by\n    simpa [comp_partialSum] using B\n  -- Fourth step: the sum over all compositions is `g (f (x + y))`. This follows from the\n  -- convergence along a subsequence proved in the third step, and the fact that the sum is Cauchy\n  -- thanks to the summability properties.\n  have D :\n    HasSum (fun i : Î£ n, Composition n => q.compAlongComposition p i.2 fun _j => y)\n      (g (f (x + y))) :=\n    haveI cau :\n      CauchySeq fun s : Finset (Î£ n, Composition n) =>\n        âˆ‘ i âˆˆ s, q.compAlongComposition p i.2 fun _j => y := by\n      apply cauchySeq_finset_of_norm_bounded _ (NNReal.summable_coe.2 hr) _\n      simp only [coe_nnnorm, NNReal.coe_mul, NNReal.coe_pow]\n      rintro âŸ¨n, câŸ©\n      calc\n        â€–(compAlongComposition q p c) fun _j : Fin n => yâ€– â‰¤\n            â€–compAlongComposition q p câ€– * âˆ _j : Fin n, â€–yâ€– := by\n          apply ContinuousMultilinearMap.le_opNorm\n        _ â‰¤ â€–compAlongComposition q p câ€– * (r : â„) ^ n := by\n          apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)\n          rw [Finset.prod_const, Finset.card_fin]\n          gcongr\n          rw [EMetric.mem_ball, edist_zero_eq_enorm] at hy\n          have := le_trans (le_of_lt hy) (min_le_right _ _)\n          rwa [enorm_le_coe, â† NNReal.coe_le_coe, coe_nnnorm] at this\n    tendsto_nhds_of_cauchySeq_of_subseq cau compPartialSumTarget_tendsto_atTop C\n  -- Fifth step: the sum over `n` of `q.comp p n` can be expressed as a particular resummation of\n  -- the sum over all compositions, by grouping together the compositions of the same\n  -- integer `n`. The convergence of the whole sum therefore implies the converence of the sum\n  -- of `q.comp p n`\n  have E : HasSum (fun n => (q.comp p) n fun _j => y) (g (f (x + y))) := by\n    apply D.sigma\n    intro n\n    dsimp [FormalMultilinearSeries.comp]\n    convert hasSum_fintype (Î± := G) (Î² := Composition n) _\n    simp only [ContinuousMultilinearMap.sum_apply]\n    rfl\n  rw [Function.comp_apply]\n  exact E\n\n"}
{"name":"HasFPowerSeriesAt.comp","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ng : F â†’ G\nf : E â†’ F\nq : FormalMultilinearSeries ğ•œ F G\np : FormalMultilinearSeries ğ•œ E F\nx : E\nhg : HasFPowerSeriesAt g q (f x)\nhf : HasFPowerSeriesAt f p x\nâŠ¢ HasFPowerSeriesAt (Function.comp g f) (q.comp p) x","decl":"/-- If two functions `g` and `f` have power series `q` and `p` respectively at `f x` and `x`,\nthen `g âˆ˜ f` admits the power  series `q.comp p` at `x` within `s`. -/\ntheorem HasFPowerSeriesAt.comp {g : F â†’ G} {f : E â†’ F} {q : FormalMultilinearSeries ğ•œ F G}\n    {p : FormalMultilinearSeries ğ•œ E F} {x : E}\n    (hg : HasFPowerSeriesAt g q (f x)) (hf : HasFPowerSeriesAt f p x) :\n    HasFPowerSeriesAt (g âˆ˜ f) (q.comp p) x := by\n  rw [â† hasFPowerSeriesWithinAt_univ] at hf hg âŠ¢\n  apply hg.comp hf (by simp)\n\n"}
{"name":"AnalyticWithinAt.comp","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ng : F â†’ G\nf : E â†’ F\nx : E\nt : Set F\ns : Set E\nhg : AnalyticWithinAt ğ•œ g t (f x)\nhf : AnalyticWithinAt ğ•œ f s x\nh : Set.MapsTo f s t\nâŠ¢ AnalyticWithinAt ğ•œ (Function.comp g f) s x","decl":"/-- If two functions `g` and `f` are analytic respectively at `f x` and `x`, within\ntwo sets `s` and `t` such that `f` maps `s` to `t`, then `g âˆ˜ f` is analytic at `x` within `s`. -/\ntheorem AnalyticWithinAt.comp {g : F â†’ G} {f : E â†’ F} {x : E} {t : Set F} {s : Set E}\n    (hg : AnalyticWithinAt ğ•œ g t (f x)) (hf : AnalyticWithinAt ğ•œ f s x) (h : Set.MapsTo f s t) :\n    AnalyticWithinAt ğ•œ (g âˆ˜ f) s x := by\n  let âŸ¨_q, hqâŸ© := hg\n  let âŸ¨_p, hpâŸ© := hf\n  exact (hq.comp hp h).analyticWithinAt\n\n"}
{"name":"AnalyticWithinAt.comp_of_eq","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ng : F â†’ G\nf : E â†’ F\ny : F\nx : E\nt : Set F\ns : Set E\nhg : AnalyticWithinAt ğ•œ g t y\nhf : AnalyticWithinAt ğ•œ f s x\nh : Set.MapsTo f s t\nhy : Eq (f x) y\nâŠ¢ AnalyticWithinAt ğ•œ (Function.comp g f) s x","decl":"/-- Version of `AnalyticWithinAt.comp` where point equality is a separate hypothesis. -/\ntheorem AnalyticWithinAt.comp_of_eq {g : F â†’ G} {f : E â†’ F} {y : F} {x : E} {t : Set F} {s : Set E}\n    (hg : AnalyticWithinAt ğ•œ g t y) (hf : AnalyticWithinAt ğ•œ f s x) (h : Set.MapsTo f s t)\n    (hy : f x = y) :\n    AnalyticWithinAt ğ•œ (g âˆ˜ f) s x := by\n  rw [â† hy] at hg\n  exact hg.comp hf h\n\n"}
{"name":"AnalyticOn.comp","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : F â†’ G\ng : E â†’ F\ns : Set F\nt : Set E\nhf : AnalyticOn ğ•œ f s\nhg : AnalyticOn ğ•œ g t\nh : Set.MapsTo g t s\nâŠ¢ AnalyticOn ğ•œ (Function.comp f g) t","decl":"lemma AnalyticOn.comp {f : F â†’ G} {g : E â†’ F} {s : Set F}\n    {t : Set E} (hf : AnalyticOn ğ•œ f s) (hg : AnalyticOn ğ•œ g t) (h : Set.MapsTo g t s) :\n    AnalyticOn ğ•œ (f âˆ˜ g) t :=\n  fun x m â†¦ (hf _ (h m)).comp (hg x m) h\n\n"}
{"name":"AnalyticWithinOn.comp","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : F â†’ G\ng : E â†’ F\ns : Set F\nt : Set E\nhf : AnalyticOn ğ•œ f s\nhg : AnalyticOn ğ•œ g t\nh : Set.MapsTo g t s\nâŠ¢ AnalyticOn ğ•œ (Function.comp f g) t","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.comp := AnalyticOn.comp\n\n"}
{"name":"AnalyticAt.comp","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ng : F â†’ G\nf : E â†’ F\nx : E\nhg : AnalyticAt ğ•œ g (f x)\nhf : AnalyticAt ğ•œ f x\nâŠ¢ AnalyticAt ğ•œ (Function.comp g f) x","decl":"/-- If two functions `g` and `f` are analytic respectively at `f x` and `x`, then `g âˆ˜ f` is\nanalytic at `x`. -/\n@[fun_prop]\ntheorem AnalyticAt.comp {g : F â†’ G} {f : E â†’ F} {x : E} (hg : AnalyticAt ğ•œ g (f x))\n    (hf : AnalyticAt ğ•œ f x) : AnalyticAt ğ•œ (g âˆ˜ f) x := by\n  rw [â† analyticWithinAt_univ] at hg hf âŠ¢\n  apply hg.comp hf (by simp)\n\n"}
{"name":"AnalyticAt.comp'","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ng : F â†’ G\nf : E â†’ F\nx : E\nhg : AnalyticAt ğ•œ g (f x)\nhf : AnalyticAt ğ•œ f x\nâŠ¢ AnalyticAt ğ•œ (fun z => g (f z)) x","decl":"/-- If two functions `g` and `f` are analytic respectively at `f x` and `x`, then `g âˆ˜ f` is\nanalytic at `x`. -/\n@[fun_prop]\ntheorem AnalyticAt.comp' {g : F â†’ G} {f : E â†’ F} {x : E} (hg : AnalyticAt ğ•œ g (f x))\n    (hf : AnalyticAt ğ•œ f x) : AnalyticAt ğ•œ (fun z â†¦ g (f z)) x :=\n  hg.comp hf\n\n"}
{"name":"AnalyticAt.comp_of_eq","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ng : F â†’ G\nf : E â†’ F\ny : F\nx : E\nhg : AnalyticAt ğ•œ g y\nhf : AnalyticAt ğ•œ f x\nhy : Eq (f x) y\nâŠ¢ AnalyticAt ğ•œ (Function.comp g f) x","decl":"/-- Version of `AnalyticAt.comp` where point equality is a separate hypothesis. -/\ntheorem AnalyticAt.comp_of_eq {g : F â†’ G} {f : E â†’ F} {y : F} {x : E} (hg : AnalyticAt ğ•œ g y)\n    (hf : AnalyticAt ğ•œ f x) (hy : f x = y) : AnalyticAt ğ•œ (g âˆ˜ f) x := by\n  rw [â† hy] at hg\n  exact hg.comp hf\n\n"}
{"name":"AnalyticAt.comp_of_eq'","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ng : F â†’ G\nf : E â†’ F\ny : F\nx : E\nhg : AnalyticAt ğ•œ g y\nhf : AnalyticAt ğ•œ f x\nhy : Eq (f x) y\nâŠ¢ AnalyticAt ğ•œ (fun z => g (f z)) x","decl":"/-- Version of `AnalyticAt.comp` where point equality is a separate hypothesis. -/\ntheorem AnalyticAt.comp_of_eq' {g : F â†’ G} {f : E â†’ F} {y : F} {x : E} (hg : AnalyticAt ğ•œ g y)\n    (hf : AnalyticAt ğ•œ f x) (hy : f x = y) : AnalyticAt ğ•œ (fun z â†¦ g (f z)) x := by\n  apply hg.comp_of_eq hf hy\n\n"}
{"name":"AnalyticAt.comp_analyticWithinAt","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ng : F â†’ G\nf : E â†’ F\nx : E\ns : Set E\nhg : AnalyticAt ğ•œ g (f x)\nhf : AnalyticWithinAt ğ•œ f s x\nâŠ¢ AnalyticWithinAt ğ•œ (Function.comp g f) s x","decl":"theorem AnalyticAt.comp_analyticWithinAt {g : F â†’ G} {f : E â†’ F} {x : E} {s : Set E}\n    (hg : AnalyticAt ğ•œ g (f x)) (hf : AnalyticWithinAt ğ•œ f s x) :\n    AnalyticWithinAt ğ•œ (g âˆ˜ f) s x := by\n  rw [â† analyticWithinAt_univ] at hg\n  exact hg.comp hf (Set.mapsTo_univ _ _)\n\n"}
{"name":"AnalyticAt.comp_analyticWithinAt_of_eq","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ng : F â†’ G\nf : E â†’ F\nx : E\ny : F\ns : Set E\nhg : AnalyticAt ğ•œ g y\nhf : AnalyticWithinAt ğ•œ f s x\nh : Eq (f x) y\nâŠ¢ AnalyticWithinAt ğ•œ (Function.comp g f) s x","decl":"theorem AnalyticAt.comp_analyticWithinAt_of_eq {g : F â†’ G} {f : E â†’ F} {x : E} {y : F} {s : Set E}\n    (hg : AnalyticAt ğ•œ g y) (hf : AnalyticWithinAt ğ•œ f s x) (h : f x = y) :\n    AnalyticWithinAt ğ•œ (g âˆ˜ f) s x := by\n  rw [â† h] at hg\n  exact hg.comp_analyticWithinAt hf\n\n"}
{"name":"AnalyticOnNhd.comp'","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\ng : F â†’ G\nf : E â†’ F\nhg : AnalyticOnNhd ğ•œ g (Set.image f s)\nhf : AnalyticOnNhd ğ•œ f s\nâŠ¢ AnalyticOnNhd ğ•œ (Function.comp g f) s","decl":"/-- If two functions `g` and `f` are analytic respectively on `s.image f` and `s`, then `g âˆ˜ f` is\nanalytic on `s`. -/\ntheorem AnalyticOnNhd.comp' {s : Set E} {g : F â†’ G} {f : E â†’ F} (hg : AnalyticOnNhd ğ•œ g (s.image f))\n    (hf : AnalyticOnNhd ğ•œ f s) : AnalyticOnNhd ğ•œ (g âˆ˜ f) s :=\n  fun z hz => (hg (f z) (Set.mem_image_of_mem f hz)).comp (hf z hz)\n\n"}
{"name":"AnalyticOn.comp'","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\ng : F â†’ G\nf : E â†’ F\nhg : AnalyticOnNhd ğ•œ g (Set.image f s)\nhf : AnalyticOnNhd ğ•œ f s\nâŠ¢ AnalyticOnNhd ğ•œ (Function.comp g f) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticOn.comp' := AnalyticOnNhd.comp'\n\n"}
{"name":"AnalyticOnNhd.comp","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\nt : Set F\ng : F â†’ G\nf : E â†’ F\nhg : AnalyticOnNhd ğ•œ g t\nhf : AnalyticOnNhd ğ•œ f s\nst : Set.MapsTo f s t\nâŠ¢ AnalyticOnNhd ğ•œ (Function.comp g f) s","decl":"theorem AnalyticOnNhd.comp {s : Set E} {t : Set F} {g : F â†’ G} {f : E â†’ F}\n    (hg : AnalyticOnNhd ğ•œ g t) (hf : AnalyticOnNhd ğ•œ f s) (st : Set.MapsTo f s t) :\n    AnalyticOnNhd ğ•œ (g âˆ˜ f) s :=\n  comp' (mono hg (Set.mapsTo'.mp st)) hf\n\n"}
{"name":"AnalyticOnNhd.comp_analyticOn","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : F â†’ G\ng : E â†’ F\ns : Set F\nt : Set E\nhf : AnalyticOnNhd ğ•œ f s\nhg : AnalyticOn ğ•œ g t\nh : Set.MapsTo g t s\nâŠ¢ AnalyticOn ğ•œ (Function.comp f g) t","decl":"lemma AnalyticOnNhd.comp_analyticOn {f : F â†’ G} {g : E â†’ F} {s : Set F}\n    {t : Set E} (hf : AnalyticOnNhd ğ•œ f s) (hg : AnalyticOn ğ•œ g t) (h : Set.MapsTo g t s) :\n    AnalyticOn ğ•œ (f âˆ˜ g) t :=\n  fun x m â†¦ (hf _ (h m)).comp_analyticWithinAt (hg x m)\n\n"}
{"name":"AnalyticOn.comp_analyticWithinOn","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : F â†’ G\ng : E â†’ F\ns : Set F\nt : Set E\nhf : AnalyticOnNhd ğ•œ f s\nhg : AnalyticOn ğ•œ g t\nh : Set.MapsTo g t s\nâŠ¢ AnalyticOn ğ•œ (Function.comp f g) t","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticOn.comp_analyticWithinOn := AnalyticOnNhd.comp_analyticOn\n\n"}
{"name":"Composition.sigma_composition_eq_iff","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"n : Nat\ni j : Sigma fun a => Composition a.length\nâŠ¢ Iff (Eq i j) (And (Eq i.fst.blocks j.fst.blocks) (Eq i.snd.blocks j.snd.blocks))","decl":"/-- Rewriting equality in the dependent type `Î£ (a : Composition n), Composition a.length)` in\nnon-dependent terms with lists, requiring that the blocks coincide. -/\ntheorem sigma_composition_eq_iff (i j : Î£ a : Composition n, Composition a.length) :\n    i = j â†” i.1.blocks = j.1.blocks âˆ§ i.2.blocks = j.2.blocks := by\n  refine âŸ¨by rintro rfl; exact âŸ¨rfl, rflâŸ©, ?_âŸ©\n  rcases i with âŸ¨a, bâŸ©\n  rcases j with âŸ¨a', b'âŸ©\n  rintro âŸ¨h, h'âŸ©\n  have H : a = a' := by ext1; exact h\n  induction H; congr; ext1; exact h'\n\n"}
{"name":"Composition.sigma_pi_composition_eq_iff","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"n : Nat\nu v : Sigma fun c => (i : Fin c.length) â†’ Composition (c.blocksFun i)\nâŠ¢ Iff (Eq u v) (Eq (List.ofFn fun i => (u.snd i).blocks) (List.ofFn fun i => (v.snd i).blocks))","decl":"/-- Rewriting equality in the dependent type\n`Î£ (c : Composition n), Î  (i : Fin c.length), Composition (c.blocksFun i)` in\nnon-dependent terms with lists, requiring that the lists of blocks coincide. -/\ntheorem sigma_pi_composition_eq_iff\n    (u v : Î£ c : Composition n, âˆ€ i : Fin c.length, Composition (c.blocksFun i)) :\n    u = v â†” (ofFn fun i => (u.2 i).blocks) = ofFn fun i => (v.2 i).blocks := by\n  refine âŸ¨fun H => by rw [H], fun H => ?_âŸ©\n  rcases u with âŸ¨a, bâŸ©\n  rcases v with âŸ¨a', b'âŸ©\n  dsimp at H\n  have h : a = a' := by\n    ext1\n    have :\n      map List.sum (ofFn fun i : Fin (Composition.length a) => (b i).blocks) =\n        map List.sum (ofFn fun i : Fin (Composition.length a') => (b' i).blocks) := by\n      rw [H]\n    simp only [map_ofFn] at this\n    change\n      (ofFn fun i : Fin (Composition.length a) => (b i).blocks.sum) =\n        ofFn fun i : Fin (Composition.length a') => (b' i).blocks.sum at this\n    simpa [Composition.blocks_sum, Composition.ofFn_blocksFun] using this\n  induction h\n  ext1\n  Â· rfl\n  Â· simp only [heq_eq_eq, ofFn_inj] at H âŠ¢\n    ext1 i\n    ext1\n    exact congrFun H i\n\n"}
{"name":"Composition.length_gather","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"n : Nat\na : Composition n\nb : Composition a.length\nâŠ¢ Eq (a.gather b).length b.length","decl":"theorem length_gather (a : Composition n) (b : Composition a.length) :\n    length (a.gather b) = b.length :=\n  show (map List.sum (a.blocks.splitWrtComposition b)).length = b.blocks.length by\n    rw [length_map, length_splitWrtComposition]\n\n"}
{"name":"Composition.length_sigmaCompositionAux","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"n : Nat\na : Composition n\nb : Composition a.length\ni : Fin b.length\nâŠ¢ Eq (a.sigmaCompositionAux b âŸ¨â†‘i, â‹¯âŸ©).length (b.blocksFun i)","decl":"theorem length_sigmaCompositionAux (a : Composition n) (b : Composition a.length)\n    (i : Fin b.length) :\n    Composition.length (Composition.sigmaCompositionAux a b âŸ¨i, (length_gather a b).symm â–¸ i.2âŸ©) =\n      Composition.blocksFun b i :=\n  show List.length ((splitWrtComposition a.blocks b)[i.1]) = blocksFun b i by\n    rw [getElem_map_rev List.length, getElem_of_eq (map_length_splitWrtComposition _ _), blocksFun,\n      get_eq_getElem]\n\n"}
{"name":"Composition.blocksFun_sigmaCompositionAux","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"n : Nat\na : Composition n\nb : Composition a.length\ni : Fin b.length\nj : Fin (b.blocksFun i)\nâŠ¢ Eq ((a.sigmaCompositionAux b âŸ¨â†‘i, â‹¯âŸ©).blocksFun âŸ¨â†‘j, â‹¯âŸ©) (a.blocksFun ((b.embedding i) j))","decl":"theorem blocksFun_sigmaCompositionAux (a : Composition n) (b : Composition a.length)\n    (i : Fin b.length) (j : Fin (blocksFun b i)) :\n    blocksFun (sigmaCompositionAux a b âŸ¨i, (length_gather a b).symm â–¸ i.2âŸ©)\n        âŸ¨j, (length_sigmaCompositionAux a b i).symm â–¸ j.2âŸ© =\n      blocksFun a (embedding b i j) := by\n  unfold sigmaCompositionAux\n  rw [blocksFun, get_eq_getElem, getElem_of_eq (getElem_splitWrtComposition _ _ _ _),\n    getElem_drop, getElem_take]; rfl\n\n"}
{"name":"Composition.sizeUpTo_sizeUpTo_add","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"n : Nat\na : Composition n\nb : Composition a.length\ni j : Nat\nhi : LT.lt i b.length\nhj : LT.lt j (b.blocksFun âŸ¨i, hiâŸ©)\nâŠ¢ Eq (a.sizeUpTo (HAdd.hAdd (b.sizeUpTo i) j)) (HAdd.hAdd ((a.gather b).sizeUpTo i) ((a.sigmaCompositionAux b âŸ¨i, â‹¯âŸ©).sizeUpTo j))","decl":"/-- Auxiliary lemma to prove that the composition of formal multilinear series is associative.\n\nConsider a composition `a` of `n` and a composition `b` of `a.length`. Grouping together some\nblocks of `a` according to `b` as in `a.gather b`, one can compute the total size of the blocks\nof `a` up to an index `sizeUpTo b i + j` (where the `j` corresponds to a set of blocks of `a`\nthat do not fill a whole block of `a.gather b`). The first part corresponds to a sum of blocks\nin `a.gather b`, and the second one to a sum of blocks in the next block of\n`sigmaCompositionAux a b`. This is the content of this lemma. -/\ntheorem sizeUpTo_sizeUpTo_add (a : Composition n) (b : Composition a.length) {i j : â„•}\n    (hi : i < b.length) (hj : j < blocksFun b âŸ¨i, hiâŸ©) :\n    sizeUpTo a (sizeUpTo b i + j) =\n      sizeUpTo (a.gather b) i +\n        sizeUpTo (sigmaCompositionAux a b âŸ¨i, (length_gather a b).symm â–¸ hiâŸ©) j := by\n  -- Porting note: `induction'` left a spurious `hj` in the context\n  induction j with\n  | zero =>\n    show\n      sum (take (b.blocks.take i).sum a.blocks) =\n        sum (take i (map sum (splitWrtComposition a.blocks b)))\n    induction' i with i IH\n    Â· rfl\n    Â· have A : i < b.length := Nat.lt_of_succ_lt hi\n      have B : i < List.length (map List.sum (splitWrtComposition a.blocks b)) := by simp [A]\n      have C : 0 < blocksFun b âŸ¨i, AâŸ© := Composition.blocks_pos' _ _ _\n      rw [sum_take_succ _ _ B, â† IH A C]\n      have :\n        take (sum (take i b.blocks)) a.blocks =\n          take (sum (take i b.blocks)) (take (sum (take (i + 1) b.blocks)) a.blocks) := by\n        rw [take_take, min_eq_left]\n        apply monotone_sum_take _ (Nat.le_succ _)\n      rw [this, getElem_map, getElem_splitWrtComposition, â†\n        take_append_drop (sum (take i b.blocks)) (take (sum (take (Nat.succ i) b.blocks)) a.blocks),\n        sum_append]\n      congr\n      rw [take_append_drop]\n  | succ j IHj =>\n    have A : j < blocksFun b âŸ¨i, hiâŸ© := lt_trans (lt_add_one j) hj\n    have B : j < length (sigmaCompositionAux a b âŸ¨i, (length_gather a b).symm â–¸ hiâŸ©) := by\n      convert A; rw [â† length_sigmaCompositionAux]\n    have C : sizeUpTo b i + j < sizeUpTo b (i + 1) := by\n      simp only [sizeUpTo_succ b hi, add_lt_add_iff_left]\n      exact A\n    have D : sizeUpTo b i + j < length a := lt_of_lt_of_le C (b.sizeUpTo_le _)\n    have : sizeUpTo b i + Nat.succ j = (sizeUpTo b i + j).succ := rfl\n    rw [this, sizeUpTo_succ _ D, IHj A, sizeUpTo_succ _ B]\n    simp only [sigmaCompositionAux, add_assoc, add_left_inj, Fin.val_mk]\n    rw [getElem_of_eq (getElem_splitWrtComposition _ _ _ _), getElem_drop, getElem_take' _ _ C]\n\n"}
{"name":"FormalMultilinearSeries.comp_assoc","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\nH : Type u_5\ninstâœâ¸ : NontriviallyNormedField ğ•œ\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nr : FormalMultilinearSeries ğ•œ G H\nq : FormalMultilinearSeries ğ•œ F G\np : FormalMultilinearSeries ğ•œ E F\nâŠ¢ Eq ((r.comp q).comp p) (r.comp (q.comp p))","decl":"theorem comp_assoc (r : FormalMultilinearSeries ğ•œ G H) (q : FormalMultilinearSeries ğ•œ F G)\n    (p : FormalMultilinearSeries ğ•œ E F) : (r.comp q).comp p = r.comp (q.comp p) := by\n  ext n v\n  /- First, rewrite the two compositions appearing in the theorem as two sums over complicated\n    sigma types, as in the description of the proof above. -/\n  let f : (Î£ a : Composition n, Composition a.length) â†’ H := fun c =>\n    r c.2.length (applyComposition q c.2 (applyComposition p c.1 v))\n  let g : (Î£ c : Composition n, âˆ€ i : Fin c.length, Composition (c.blocksFun i)) â†’ H := fun c =>\n    r c.1.length fun i : Fin c.1.length =>\n      q (c.2 i).length (applyComposition p (c.2 i) (v âˆ˜ c.1.embedding i))\n  suffices âˆ‘ c, f c = âˆ‘ c, g c by\n    simpa (config := { unfoldPartialApp := true }) only [FormalMultilinearSeries.comp,\n      ContinuousMultilinearMap.sum_apply, compAlongComposition_apply, Finset.sum_sigma',\n      applyComposition, ContinuousMultilinearMap.map_sum]\n  /- Now, we use `Composition.sigmaEquivSigmaPi n` to change\n    variables in the second sum, and check that we get exactly the same sums. -/\n  rw [â† (sigmaEquivSigmaPi n).sum_comp]\n  /- To check that we have the same terms, we should check that we apply the same component of\n    `r`, and the same component of `q`, and the same component of `p`, to the same coordinate of\n    `v`. This is true by definition, but at each step one needs to convince Lean that the types\n    one considers are the same, using a suitable congruence lemma to avoid dependent type issues.\n    This dance has to be done three times, one for `r`, one for `q` and one for `p`. -/\n  apply Finset.sum_congr rfl\n  rintro âŸ¨a, bâŸ© _\n  dsimp [sigmaEquivSigmaPi]\n  -- check that the `r` components are the same. Based on `Composition.length_gather`\n  apply r.congr (Composition.length_gather a b).symm\n  intro i hi1 hi2\n  -- check that the `q` components are the same. Based on `length_sigmaCompositionAux`\n  apply q.congr (length_sigmaCompositionAux a b _).symm\n  intro j hj1 hj2\n  -- check that the `p` components are the same. Based on `blocksFun_sigmaCompositionAux`\n  apply p.congr (blocksFun_sigmaCompositionAux a b _ _).symm\n  intro k hk1 hk2\n  -- finally, check that the coordinates of `v` one is using are the same. Based on\n  -- `sizeUpTo_sizeUpTo_add`.\n  refine congr_arg v (Fin.ext ?_)\n  dsimp [Composition.embedding]\n  rw [sizeUpTo_sizeUpTo_add _ _ hi1 hj1, add_assoc]\n\n"}
