{"name":"FormalMultilinearSeries.applyComposition_ones","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝¹⁰ : CommRing 𝕜\ninst✝⁹ : AddCommGroup E\ninst✝⁸ : AddCommGroup F\ninst✝⁷ : Module 𝕜 E\ninst✝⁶ : Module 𝕜 F\ninst✝⁵ : TopologicalSpace E\ninst✝⁴ : TopologicalSpace F\ninst✝³ : TopologicalAddGroup E\ninst✝² : ContinuousConstSMul 𝕜 E\ninst✝¹ : TopologicalAddGroup F\ninst✝ : ContinuousConstSMul 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nn : Nat\n⊢ Eq (p.applyComposition (Composition.ones n)) fun v i => (p 1) fun x => v (Fin.castLE ⋯ i)","decl":"theorem applyComposition_ones (p : FormalMultilinearSeries 𝕜 E F) (n : ℕ) :\n    p.applyComposition (Composition.ones n) = fun v i =>\n      p 1 fun _ => v (Fin.castLE (Composition.length_le _) i) := by\n  funext v i\n  apply p.congr (Composition.ones_blocksFun _ _)\n  intro j hjn hj1\n  obtain rfl : j = 0 := by omega\n  refine congr_arg v ?_\n  rw [Fin.ext_iff, Fin.coe_castLE, Composition.ones_embedding, Fin.val_mk]\n\n"}
{"name":"FormalMultilinearSeries.applyComposition_single","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝¹⁰ : CommRing 𝕜\ninst✝⁹ : AddCommGroup E\ninst✝⁸ : AddCommGroup F\ninst✝⁷ : Module 𝕜 E\ninst✝⁶ : Module 𝕜 F\ninst✝⁵ : TopologicalSpace E\ninst✝⁴ : TopologicalSpace F\ninst✝³ : TopologicalAddGroup E\ninst✝² : ContinuousConstSMul 𝕜 E\ninst✝¹ : TopologicalAddGroup F\ninst✝ : ContinuousConstSMul 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nn : Nat\nhn : LT.lt 0 n\nv : Fin n → E\n⊢ Eq (p.applyComposition (Composition.single n hn) v) fun _j => (p n) v","decl":"theorem applyComposition_single (p : FormalMultilinearSeries 𝕜 E F) {n : ℕ} (hn : 0 < n)\n    (v : Fin n → E) : p.applyComposition (Composition.single n hn) v = fun _j => p n v := by\n  ext j\n  refine p.congr (by simp) fun i hi1 hi2 => ?_\n  dsimp\n  congr 1\n  convert Composition.single_embedding hn ⟨i, hi2⟩ using 1\n  cases' j with j_val j_property\n  have : j_val = 0 := le_bot_iff.1 (Nat.lt_succ_iff.1 j_property)\n  congr!\n  simp\n\n"}
{"name":"FormalMultilinearSeries.removeZero_applyComposition","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝¹⁰ : CommRing 𝕜\ninst✝⁹ : AddCommGroup E\ninst✝⁸ : AddCommGroup F\ninst✝⁷ : Module 𝕜 E\ninst✝⁶ : Module 𝕜 F\ninst✝⁵ : TopologicalSpace E\ninst✝⁴ : TopologicalSpace F\ninst✝³ : TopologicalAddGroup E\ninst✝² : ContinuousConstSMul 𝕜 E\ninst✝¹ : TopologicalAddGroup F\ninst✝ : ContinuousConstSMul 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nn : Nat\nc : Composition n\n⊢ Eq (p.removeZero.applyComposition c) (p.applyComposition c)","decl":"@[simp]\ntheorem removeZero_applyComposition (p : FormalMultilinearSeries 𝕜 E F) {n : ℕ}\n    (c : Composition n) : p.removeZero.applyComposition c = p.applyComposition c := by\n  ext v i\n  simp [applyComposition, zero_lt_one.trans_le (c.one_le_blocksFun i), removeZero_of_pos]\n\n"}
{"name":"FormalMultilinearSeries.applyComposition_update","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝¹⁰ : CommRing 𝕜\ninst✝⁹ : AddCommGroup E\ninst✝⁸ : AddCommGroup F\ninst✝⁷ : Module 𝕜 E\ninst✝⁶ : Module 𝕜 F\ninst✝⁵ : TopologicalSpace E\ninst✝⁴ : TopologicalSpace F\ninst✝³ : TopologicalAddGroup E\ninst✝² : ContinuousConstSMul 𝕜 E\ninst✝¹ : TopologicalAddGroup F\ninst✝ : ContinuousConstSMul 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nn : Nat\nc : Composition n\nj : Fin n\nv : Fin n → E\nz : E\n⊢ Eq (p.applyComposition c (Function.update v j z)) (Function.update (p.applyComposition c v) (c.index j) ((p (c.blocksFun (c.index j))) (Function.update (Function.comp v ⇑(c.embedding (c.index j))) (c.invEmbedding j) z)))","decl":"/-- Technical lemma stating how `p.applyComposition` commutes with updating variables. This\nwill be the key point to show that functions constructed from `applyComposition` retain\nmultilinearity. -/\ntheorem applyComposition_update (p : FormalMultilinearSeries 𝕜 E F) {n : ℕ} (c : Composition n)\n    (j : Fin n) (v : Fin n → E) (z : E) :\n    p.applyComposition c (Function.update v j z) =\n      Function.update (p.applyComposition c v) (c.index j)\n        (p (c.blocksFun (c.index j))\n          (Function.update (v ∘ c.embedding (c.index j)) (c.invEmbedding j) z)) := by\n  ext k\n  by_cases h : k = c.index j\n  · rw [h]\n    let r : Fin (c.blocksFun (c.index j)) → Fin n := c.embedding (c.index j)\n    simp only [Function.update_self]\n    change p (c.blocksFun (c.index j)) (Function.update v j z ∘ r) = _\n    let j' := c.invEmbedding j\n    suffices B : Function.update v j z ∘ r = Function.update (v ∘ r) j' z by rw [B]\n    suffices C : Function.update v (r j') z ∘ r = Function.update (v ∘ r) j' z by\n      convert C; exact (c.embedding_comp_inv j).symm\n    exact Function.update_comp_eq_of_injective _ (c.embedding _).injective _ _\n  · simp only [h, Function.update_eq_self, Function.update_of_ne, Ne, not_false_iff]\n    let r : Fin (c.blocksFun k) → Fin n := c.embedding k\n    change p (c.blocksFun k) (Function.update v j z ∘ r) = p (c.blocksFun k) (v ∘ r)\n    suffices B : Function.update v j z ∘ r = v ∘ r by rw [B]\n    apply Function.update_comp_eq_of_not_mem_range\n    rwa [c.mem_range_embedding_iff']\n\n"}
{"name":"FormalMultilinearSeries.compContinuousLinearMap_applyComposition","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝¹⁵ : CommRing 𝕜\ninst✝¹⁴ : AddCommGroup E\ninst✝¹³ : AddCommGroup F\ninst✝¹² : AddCommGroup G\ninst✝¹¹ : Module 𝕜 E\ninst✝¹⁰ : Module 𝕜 F\ninst✝⁹ : Module 𝕜 G\ninst✝⁸ : TopologicalSpace E\ninst✝⁷ : TopologicalSpace F\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : TopologicalAddGroup E\ninst✝⁴ : ContinuousConstSMul 𝕜 E\ninst✝³ : TopologicalAddGroup F\ninst✝² : ContinuousConstSMul 𝕜 F\ninst✝¹ : TopologicalAddGroup G\ninst✝ : ContinuousConstSMul 𝕜 G\nn : Nat\np : FormalMultilinearSeries 𝕜 F G\nf : ContinuousLinearMap (RingHom.id 𝕜) E F\nc : Composition n\nv : Fin n → E\n⊢ Eq ((p.compContinuousLinearMap f).applyComposition c v) (p.applyComposition c (Function.comp (⇑f) v))","decl":"@[simp]\ntheorem compContinuousLinearMap_applyComposition {n : ℕ} (p : FormalMultilinearSeries 𝕜 F G)\n    (f : E →L[𝕜] F) (c : Composition n) (v : Fin n → E) :\n    (p.compContinuousLinearMap f).applyComposition c v = p.applyComposition c (f ∘ v) := by\n  simp (config := {unfoldPartialApp := true}) [applyComposition]; rfl\n\n"}
{"name":"ContinuousMultilinearMap.compAlongComposition_apply","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝¹³ : CommRing 𝕜\ninst✝¹² : AddCommGroup E\ninst✝¹¹ : AddCommGroup F\ninst✝¹⁰ : AddCommGroup G\ninst✝⁹ : Module 𝕜 E\ninst✝⁸ : Module 𝕜 F\ninst✝⁷ : Module 𝕜 G\ninst✝⁶ : TopologicalSpace E\ninst✝⁵ : TopologicalSpace F\ninst✝⁴ : TopologicalSpace G\ninst✝³ : TopologicalAddGroup E\ninst✝² : ContinuousConstSMul 𝕜 E\ninst✝¹ : TopologicalAddGroup F\ninst✝ : ContinuousConstSMul 𝕜 F\nn : Nat\np : FormalMultilinearSeries 𝕜 E F\nc : Composition n\nf : ContinuousMultilinearMap 𝕜 (fun i => F) G\nv : Fin n → E\n⊢ Eq ((ContinuousMultilinearMap.compAlongComposition p c f) v) (f (p.applyComposition c v))","decl":"@[simp]\ntheorem compAlongComposition_apply {n : ℕ} (p : FormalMultilinearSeries 𝕜 E F) (c : Composition n)\n    (f : F [×c.length]→L[𝕜] G) (v : Fin n → E) :\n    (f.compAlongComposition p c) v = f (p.applyComposition c v) :=\n  rfl\n\n"}
{"name":"FormalMultilinearSeries.compAlongComposition_apply","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝¹⁵ : CommRing 𝕜\ninst✝¹⁴ : AddCommGroup E\ninst✝¹³ : AddCommGroup F\ninst✝¹² : AddCommGroup G\ninst✝¹¹ : Module 𝕜 E\ninst✝¹⁰ : Module 𝕜 F\ninst✝⁹ : Module 𝕜 G\ninst✝⁸ : TopologicalSpace E\ninst✝⁷ : TopologicalSpace F\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : TopologicalAddGroup E\ninst✝⁴ : ContinuousConstSMul 𝕜 E\ninst✝³ : TopologicalAddGroup F\ninst✝² : ContinuousConstSMul 𝕜 F\ninst✝¹ : TopologicalAddGroup G\ninst✝ : ContinuousConstSMul 𝕜 G\nn : Nat\nq : FormalMultilinearSeries 𝕜 F G\np : FormalMultilinearSeries 𝕜 E F\nc : Composition n\nv : Fin n → E\n⊢ Eq ((q.compAlongComposition p c) v) ((q c.length) (p.applyComposition c v))","decl":"@[simp]\ntheorem compAlongComposition_apply {n : ℕ} (q : FormalMultilinearSeries 𝕜 F G)\n    (p : FormalMultilinearSeries 𝕜 E F) (c : Composition n) (v : Fin n → E) :\n    (q.compAlongComposition p c) v = q c.length (p.applyComposition c v) :=\n  rfl\n\n"}
{"name":"FormalMultilinearSeries.comp_coeff_zero","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝¹⁵ : CommRing 𝕜\ninst✝¹⁴ : AddCommGroup E\ninst✝¹³ : AddCommGroup F\ninst✝¹² : AddCommGroup G\ninst✝¹¹ : Module 𝕜 E\ninst✝¹⁰ : Module 𝕜 F\ninst✝⁹ : Module 𝕜 G\ninst✝⁸ : TopologicalSpace E\ninst✝⁷ : TopologicalSpace F\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : TopologicalAddGroup E\ninst✝⁴ : ContinuousConstSMul 𝕜 E\ninst✝³ : TopologicalAddGroup F\ninst✝² : ContinuousConstSMul 𝕜 F\ninst✝¹ : TopologicalAddGroup G\ninst✝ : ContinuousConstSMul 𝕜 G\nq : FormalMultilinearSeries 𝕜 F G\np : FormalMultilinearSeries 𝕜 E F\nv : Fin 0 → E\nv' : Fin 0 → F\n⊢ Eq ((q.comp p 0) v) ((q 0) v')","decl":"/-- The `0`-th coefficient of `q.comp p` is `q 0`. Since these maps are multilinear maps in zero\nvariables, but on different spaces, we can not state this directly, so we state it when applied to\narbitrary vectors (which have to be the zero vector). -/\ntheorem comp_coeff_zero (q : FormalMultilinearSeries 𝕜 F G) (p : FormalMultilinearSeries 𝕜 E F)\n    (v : Fin 0 → E) (v' : Fin 0 → F) : (q.comp p) 0 v = q 0 v' := by\n  let c : Composition 0 := Composition.ones 0\n  dsimp [FormalMultilinearSeries.comp]\n  have : {c} = (Finset.univ : Finset (Composition 0)) := by\n    apply Finset.eq_of_subset_of_card_le <;> simp [Finset.card_univ, composition_card 0]\n  rw [← this, Finset.sum_singleton, compAlongComposition_apply]\n  symm; congr! -- Porting note: needed the stronger `congr!`!\n\n"}
{"name":"FormalMultilinearSeries.comp_coeff_zero'","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝¹⁵ : CommRing 𝕜\ninst✝¹⁴ : AddCommGroup E\ninst✝¹³ : AddCommGroup F\ninst✝¹² : AddCommGroup G\ninst✝¹¹ : Module 𝕜 E\ninst✝¹⁰ : Module 𝕜 F\ninst✝⁹ : Module 𝕜 G\ninst✝⁸ : TopologicalSpace E\ninst✝⁷ : TopologicalSpace F\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : TopologicalAddGroup E\ninst✝⁴ : ContinuousConstSMul 𝕜 E\ninst✝³ : TopologicalAddGroup F\ninst✝² : ContinuousConstSMul 𝕜 F\ninst✝¹ : TopologicalAddGroup G\ninst✝ : ContinuousConstSMul 𝕜 G\nq : FormalMultilinearSeries 𝕜 F G\np : FormalMultilinearSeries 𝕜 E F\nv : Fin 0 → E\n⊢ Eq ((q.comp p 0) v) ((q 0) fun _i => 0)","decl":"@[simp]\ntheorem comp_coeff_zero' (q : FormalMultilinearSeries 𝕜 F G) (p : FormalMultilinearSeries 𝕜 E F)\n    (v : Fin 0 → E) : (q.comp p) 0 v = q 0 fun _i => 0 :=\n  q.comp_coeff_zero p v _\n\n"}
{"name":"FormalMultilinearSeries.comp_coeff_zero''","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝¹⁰ : CommRing 𝕜\ninst✝⁹ : AddCommGroup E\ninst✝⁸ : AddCommGroup F\ninst✝⁷ : Module 𝕜 E\ninst✝⁶ : Module 𝕜 F\ninst✝⁵ : TopologicalSpace E\ninst✝⁴ : TopologicalSpace F\ninst✝³ : TopologicalAddGroup E\ninst✝² : ContinuousConstSMul 𝕜 E\ninst✝¹ : TopologicalAddGroup F\ninst✝ : ContinuousConstSMul 𝕜 F\nq : FormalMultilinearSeries 𝕜 E F\np : FormalMultilinearSeries 𝕜 E E\n⊢ Eq (q.comp p 0) (q 0)","decl":"/-- The `0`-th coefficient of `q.comp p` is `q 0`. When `p` goes from `E` to `E`, this can be\nexpressed as a direct equality -/\ntheorem comp_coeff_zero'' (q : FormalMultilinearSeries 𝕜 E F) (p : FormalMultilinearSeries 𝕜 E E) :\n    (q.comp p) 0 = q 0 := by ext v; exact q.comp_coeff_zero p _ _\n\n"}
{"name":"FormalMultilinearSeries.comp_coeff_one","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝¹⁵ : CommRing 𝕜\ninst✝¹⁴ : AddCommGroup E\ninst✝¹³ : AddCommGroup F\ninst✝¹² : AddCommGroup G\ninst✝¹¹ : Module 𝕜 E\ninst✝¹⁰ : Module 𝕜 F\ninst✝⁹ : Module 𝕜 G\ninst✝⁸ : TopologicalSpace E\ninst✝⁷ : TopologicalSpace F\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : TopologicalAddGroup E\ninst✝⁴ : ContinuousConstSMul 𝕜 E\ninst✝³ : TopologicalAddGroup F\ninst✝² : ContinuousConstSMul 𝕜 F\ninst✝¹ : TopologicalAddGroup G\ninst✝ : ContinuousConstSMul 𝕜 G\nq : FormalMultilinearSeries 𝕜 F G\np : FormalMultilinearSeries 𝕜 E F\nv : Fin 1 → E\n⊢ Eq ((q.comp p 1) v) ((q 1) fun _i => (p 1) v)","decl":"/-- The first coefficient of a composition of formal multilinear series is the composition of the\nfirst coefficients seen as continuous linear maps. -/\ntheorem comp_coeff_one (q : FormalMultilinearSeries 𝕜 F G) (p : FormalMultilinearSeries 𝕜 E F)\n    (v : Fin 1 → E) : (q.comp p) 1 v = q 1 fun _i => p 1 v := by\n  have : {Composition.ones 1} = (Finset.univ : Finset (Composition 1)) :=\n    Finset.eq_univ_of_card _ (by simp [composition_card])\n  simp only [FormalMultilinearSeries.comp, compAlongComposition_apply, ← this,\n    Finset.sum_singleton]\n  refine q.congr (by simp) fun i hi1 hi2 => ?_\n  simp only [applyComposition_ones]\n  exact p.congr rfl fun j _hj1 hj2 => by congr! -- Porting note: needed the stronger `congr!`\n\n"}
{"name":"FormalMultilinearSeries.removeZero_comp_of_pos","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝¹⁵ : CommRing 𝕜\ninst✝¹⁴ : AddCommGroup E\ninst✝¹³ : AddCommGroup F\ninst✝¹² : AddCommGroup G\ninst✝¹¹ : Module 𝕜 E\ninst✝¹⁰ : Module 𝕜 F\ninst✝⁹ : Module 𝕜 G\ninst✝⁸ : TopologicalSpace E\ninst✝⁷ : TopologicalSpace F\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : TopologicalAddGroup E\ninst✝⁴ : ContinuousConstSMul 𝕜 E\ninst✝³ : TopologicalAddGroup F\ninst✝² : ContinuousConstSMul 𝕜 F\ninst✝¹ : TopologicalAddGroup G\ninst✝ : ContinuousConstSMul 𝕜 G\nq : FormalMultilinearSeries 𝕜 F G\np : FormalMultilinearSeries 𝕜 E F\nn : Nat\nhn : LT.lt 0 n\n⊢ Eq (q.removeZero.comp p n) (q.comp p n)","decl":"/-- Only `0`-th coefficient of `q.comp p` depends on `q 0`. -/\ntheorem removeZero_comp_of_pos (q : FormalMultilinearSeries 𝕜 F G)\n    (p : FormalMultilinearSeries 𝕜 E F) {n : ℕ} (hn : 0 < n) :\n    q.removeZero.comp p n = q.comp p n := by\n  ext v\n  simp only [FormalMultilinearSeries.comp, compAlongComposition,\n    ContinuousMultilinearMap.compAlongComposition_apply, ContinuousMultilinearMap.sum_apply]\n  refine Finset.sum_congr rfl fun c _hc => ?_\n  rw [removeZero_of_pos _ (c.length_pos_of_pos hn)]\n\n"}
{"name":"FormalMultilinearSeries.comp_removeZero","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝¹⁵ : CommRing 𝕜\ninst✝¹⁴ : AddCommGroup E\ninst✝¹³ : AddCommGroup F\ninst✝¹² : AddCommGroup G\ninst✝¹¹ : Module 𝕜 E\ninst✝¹⁰ : Module 𝕜 F\ninst✝⁹ : Module 𝕜 G\ninst✝⁸ : TopologicalSpace E\ninst✝⁷ : TopologicalSpace F\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : TopologicalAddGroup E\ninst✝⁴ : ContinuousConstSMul 𝕜 E\ninst✝³ : TopologicalAddGroup F\ninst✝² : ContinuousConstSMul 𝕜 F\ninst✝¹ : TopologicalAddGroup G\ninst✝ : ContinuousConstSMul 𝕜 G\nq : FormalMultilinearSeries 𝕜 F G\np : FormalMultilinearSeries 𝕜 E F\n⊢ Eq (q.comp p.removeZero) (q.comp p)","decl":"@[simp]\ntheorem comp_removeZero (q : FormalMultilinearSeries 𝕜 F G) (p : FormalMultilinearSeries 𝕜 E F) :\n    q.comp p.removeZero = q.comp p := by ext n; simp [FormalMultilinearSeries.comp]\n\n"}
{"name":"FormalMultilinearSeries.compAlongComposition_bound","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : Nat\np : FormalMultilinearSeries 𝕜 E F\nc : Composition n\nf : ContinuousMultilinearMap 𝕜 (fun i => F) G\nv : Fin n → E\n⊢ LE.le (Norm.norm ((ContinuousMultilinearMap.compAlongComposition p c f) v)) (HMul.hMul (HMul.hMul (Norm.norm f) (Finset.univ.prod fun i => Norm.norm (p (c.blocksFun i)))) (Finset.univ.prod fun i => Norm.norm (v i)))","decl":"/-- The norm of `f.compAlongComposition p c` is controlled by the product of\nthe norms of the relevant bits of `f` and `p`. -/\ntheorem compAlongComposition_bound {n : ℕ} (p : FormalMultilinearSeries 𝕜 E F) (c : Composition n)\n    (f : F [×c.length]→L[𝕜] G) (v : Fin n → E) :\n    ‖f.compAlongComposition p c v‖ ≤ (‖f‖ * ∏ i, ‖p (c.blocksFun i)‖) * ∏ i : Fin n, ‖v i‖ :=\n  calc\n    ‖f.compAlongComposition p c v‖ = ‖f (p.applyComposition c v)‖ := rfl\n    _ ≤ ‖f‖ * ∏ i, ‖p.applyComposition c v i‖ := ContinuousMultilinearMap.le_opNorm _ _\n    _ ≤ ‖f‖ * ∏ i, ‖p (c.blocksFun i)‖ * ∏ j : Fin (c.blocksFun i), ‖(v ∘ c.embedding i) j‖ := by\n      apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)\n      refine Finset.prod_le_prod (fun i _hi => norm_nonneg _) fun i _hi => ?_\n      apply ContinuousMultilinearMap.le_opNorm\n    _ = (‖f‖ * ∏ i, ‖p (c.blocksFun i)‖) *\n        ∏ i, ∏ j : Fin (c.blocksFun i), ‖(v ∘ c.embedding i) j‖ := by\n      rw [Finset.prod_mul_distrib, mul_assoc]\n    _ = (‖f‖ * ∏ i, ‖p (c.blocksFun i)‖) * ∏ i : Fin n, ‖v i‖ := by\n      rw [← c.blocksFinEquiv.prod_comp, ← Finset.univ_sigma_univ, Finset.prod_sigma]\n      congr\n\n"}
{"name":"FormalMultilinearSeries.compAlongComposition_norm","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : Nat\nq : FormalMultilinearSeries 𝕜 F G\np : FormalMultilinearSeries 𝕜 E F\nc : Composition n\n⊢ LE.le (Norm.norm (q.compAlongComposition p c)) (HMul.hMul (Norm.norm (q c.length)) (Finset.univ.prod fun i => Norm.norm (p (c.blocksFun i))))","decl":"/-- The norm of `q.compAlongComposition p c` is controlled by the product of\nthe norms of the relevant bits of `q` and `p`. -/\ntheorem compAlongComposition_norm {n : ℕ} (q : FormalMultilinearSeries 𝕜 F G)\n    (p : FormalMultilinearSeries 𝕜 E F) (c : Composition n) :\n    ‖q.compAlongComposition p c‖ ≤ ‖q c.length‖ * ∏ i, ‖p (c.blocksFun i)‖ :=\n  ContinuousMultilinearMap.opNorm_le_bound (by positivity) (compAlongComposition_bound _ _ _)\n\n"}
{"name":"FormalMultilinearSeries.compAlongComposition_nnnorm","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : Nat\nq : FormalMultilinearSeries 𝕜 F G\np : FormalMultilinearSeries 𝕜 E F\nc : Composition n\n⊢ LE.le (NNNorm.nnnorm (q.compAlongComposition p c)) (HMul.hMul (NNNorm.nnnorm (q c.length)) (Finset.univ.prod fun i => NNNorm.nnnorm (p (c.blocksFun i))))","decl":"theorem compAlongComposition_nnnorm {n : ℕ} (q : FormalMultilinearSeries 𝕜 F G)\n    (p : FormalMultilinearSeries 𝕜 E F) (c : Composition n) :\n    ‖q.compAlongComposition p c‖₊ ≤ ‖q c.length‖₊ * ∏ i, ‖p (c.blocksFun i)‖₊ := by\n  rw [← NNReal.coe_le_coe]; push_cast; exact q.compAlongComposition_norm p c\n\n"}
{"name":"FormalMultilinearSeries.id_apply_zero","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\nv : Fin 0 → E\n⊢ Eq ((FormalMultilinearSeries.id 𝕜 E x 0) v) x","decl":"@[simp] theorem id_apply_zero (x : E) (v : Fin 0 → E) :\n    (FormalMultilinearSeries.id 𝕜 E x) 0 v = x := rfl\n\n"}
{"name":"FormalMultilinearSeries.id_apply_one","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\nv : Fin 1 → E\n⊢ Eq ((FormalMultilinearSeries.id 𝕜 E x 1) v) (v 0)","decl":"/-- The first coefficient of `id 𝕜 E` is the identity. -/\n@[simp]\ntheorem id_apply_one (x : E) (v : Fin 1 → E) : (FormalMultilinearSeries.id 𝕜 E x) 1 v = v 0 :=\n  rfl\n\n"}
{"name":"FormalMultilinearSeries.id_apply_one'","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\nn : Nat\nh : Eq n 1\nv : Fin n → E\n⊢ Eq ((FormalMultilinearSeries.id 𝕜 E x n) v) (v ⟨0, ⋯⟩)","decl":"/-- The `n`th coefficient of `id 𝕜 E` is the identity when `n = 1`. We state this in a dependent\nway, as it will often appear in this form. -/\ntheorem id_apply_one' (x : E) {n : ℕ} (h : n = 1) (v : Fin n → E) :\n    (id 𝕜 E x) n v = v ⟨0, h.symm ▸ zero_lt_one⟩ := by\n  subst n\n  apply id_apply_one\n\n"}
{"name":"FormalMultilinearSeries.id_apply_of_one_lt","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\nn : Nat\nh : LT.lt 1 n\n⊢ Eq (FormalMultilinearSeries.id 𝕜 E x n) 0","decl":"/-- For `n ≠ 1`, the `n`-th coefficient of `id 𝕜 E` is zero, by definition. -/\n@[simp]\ntheorem id_apply_of_one_lt (x : E) {n : ℕ} (h : 1 < n) :\n    (FormalMultilinearSeries.id 𝕜 E x) n = 0 := by\n  cases' n with n\n  · contradiction\n  · cases n\n    · contradiction\n    · rfl\n\n"}
{"name":"FormalMultilinearSeries.comp_id","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nx : E\n⊢ Eq (p.comp (FormalMultilinearSeries.id 𝕜 E x)) p","decl":"@[simp]\ntheorem comp_id (p : FormalMultilinearSeries 𝕜 E F) (x : E) : p.comp (id 𝕜 E x) = p := by\n  ext1 n\n  dsimp [FormalMultilinearSeries.comp]\n  rw [Finset.sum_eq_single (Composition.ones n)]\n  · show compAlongComposition p (id 𝕜 E x) (Composition.ones n) = p n\n    ext v\n    rw [compAlongComposition_apply]\n    apply p.congr (Composition.ones_length n)\n    intros\n    rw [applyComposition_ones]\n    refine congr_arg v ?_\n    rw [Fin.ext_iff, Fin.coe_castLE, Fin.val_mk]\n  · show\n    ∀ b : Composition n,\n      b ∈ Finset.univ → b ≠ Composition.ones n → compAlongComposition p (id 𝕜 E x) b = 0\n    intro b _ hb\n    obtain ⟨k, hk, lt_k⟩ : ∃ (k : ℕ), k ∈ Composition.blocks b ∧ 1 < k :=\n      Composition.ne_ones_iff.1 hb\n    obtain ⟨i, hi⟩ : ∃ (i : Fin b.blocks.length), b.blocks[i] = k :=\n      List.get_of_mem hk\n    let j : Fin b.length := ⟨i.val, b.blocks_length ▸ i.prop⟩\n    have A : 1 < b.blocksFun j := by convert lt_k\n    ext v\n    rw [compAlongComposition_apply, ContinuousMultilinearMap.zero_apply]\n    apply ContinuousMultilinearMap.map_coord_zero _ j\n    dsimp [applyComposition]\n    rw [id_apply_of_one_lt _ _ _ A]\n    rfl\n  · simp\n\n"}
{"name":"FormalMultilinearSeries.id_comp","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nv0 : Fin 0 → E\n⊢ Eq ((FormalMultilinearSeries.id 𝕜 F ((p 0) v0)).comp p) p","decl":"@[simp]\ntheorem id_comp (p : FormalMultilinearSeries 𝕜 E F) (v0 : Fin 0 → E) :\n    (id 𝕜 F (p 0 v0)).comp p = p := by\n  ext1 n\n  by_cases hn : n = 0\n  · rw [hn]\n    ext v\n    simp only [comp_coeff_zero', id_apply_zero]\n    congr with i\n    exact i.elim0\n  · dsimp [FormalMultilinearSeries.comp]\n    have n_pos : 0 < n := bot_lt_iff_ne_bot.mpr hn\n    rw [Finset.sum_eq_single (Composition.single n n_pos)]\n    · show compAlongComposition (id 𝕜 F (p 0 v0)) p (Composition.single n n_pos) = p n\n      ext v\n      rw [compAlongComposition_apply, id_apply_one' _ _ _ (Composition.single_length n_pos)]\n      dsimp [applyComposition]\n      refine p.congr rfl fun i him hin => congr_arg v <| ?_\n      ext; simp\n    · show\n      ∀ b : Composition n, b ∈ Finset.univ → b ≠ Composition.single n n_pos →\n        compAlongComposition (id 𝕜 F (p 0 v0)) p b = 0\n      intro b _ hb\n      have A : 1 < b.length := by\n        have : b.length ≠ 1 := by simpa [Composition.eq_single_iff_length] using hb\n        have : 0 < b.length := Composition.length_pos_of_pos b n_pos\n        omega\n      ext v\n      rw [compAlongComposition_apply, id_apply_of_one_lt _ _ _ A]\n      rfl\n    · simp\n\n"}
{"name":"FormalMultilinearSeries.id_comp'","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nx : F\nv0 : Fin 0 → E\nh : Eq x ((p 0) v0)\n⊢ Eq ((FormalMultilinearSeries.id 𝕜 F x).comp p) p","decl":"/-- Variant of `id_comp` in which the zero coefficient is given by an equality hypothesis instead\nof a definitional equality. Useful for rewriting or simplifying out in some situations. -/\ntheorem id_comp' (p : FormalMultilinearSeries 𝕜 E F) (x : F) (v0 : Fin 0 → E) (h : x = p 0 v0) :\n    (id 𝕜 F x).comp p = p := by\n  simp [h]\n\n"}
{"name":"FormalMultilinearSeries.comp_summable_nnreal","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nq : FormalMultilinearSeries 𝕜 F G\np : FormalMultilinearSeries 𝕜 E F\nhq : LT.lt 0 q.radius\nhp : LT.lt 0 p.radius\n⊢ Exists fun r => And (GT.gt r 0) (Summable fun i => HMul.hMul (NNNorm.nnnorm (q.compAlongComposition p i.snd)) (HPow.hPow r i.fst))","decl":"/-- If two formal multilinear series have positive radius of convergence, then the terms appearing\nin the definition of their composition are also summable (when multiplied by a suitable positive\ngeometric term). -/\ntheorem comp_summable_nnreal (q : FormalMultilinearSeries 𝕜 F G) (p : FormalMultilinearSeries 𝕜 E F)\n    (hq : 0 < q.radius) (hp : 0 < p.radius) :\n    ∃ r > (0 : ℝ≥0),\n      Summable fun i : Σ n, Composition n => ‖q.compAlongComposition p i.2‖₊ * r ^ i.1 := by\n  /- This follows from the fact that the growth rate of `‖qₙ‖` and `‖pₙ‖` is at most geometric,\n    giving a geometric bound on each `‖q.compAlongComposition p op‖`, together with the\n    fact that there are `2^(n-1)` compositions of `n`, giving at most a geometric loss. -/\n  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 (lt_min zero_lt_one hq) with ⟨rq, rq_pos, hrq⟩\n  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 (lt_min zero_lt_one hp) with ⟨rp, rp_pos, hrp⟩\n  simp only [lt_min_iff, ENNReal.coe_lt_one_iff, ENNReal.coe_pos] at hrp hrq rp_pos rq_pos\n  obtain ⟨Cq, _hCq0, hCq⟩ : ∃ Cq > 0, ∀ n, ‖q n‖₊ * rq ^ n ≤ Cq :=\n    q.nnnorm_mul_pow_le_of_lt_radius hrq.2\n  obtain ⟨Cp, hCp1, hCp⟩ : ∃ Cp ≥ 1, ∀ n, ‖p n‖₊ * rp ^ n ≤ Cp := by\n    rcases p.nnnorm_mul_pow_le_of_lt_radius hrp.2 with ⟨Cp, -, hCp⟩\n    exact ⟨max Cp 1, le_max_right _ _, fun n => (hCp n).trans (le_max_left _ _)⟩\n  let r0 : ℝ≥0 := (4 * Cp)⁻¹\n  have r0_pos : 0 < r0 := inv_pos.2 (mul_pos zero_lt_four (zero_lt_one.trans_le hCp1))\n  set r : ℝ≥0 := rp * rq * r0\n  have r_pos : 0 < r := mul_pos (mul_pos rp_pos rq_pos) r0_pos\n  have I :\n    ∀ i : Σ n : ℕ, Composition n, ‖q.compAlongComposition p i.2‖₊ * r ^ i.1 ≤ Cq / 4 ^ i.1 := by\n    rintro ⟨n, c⟩\n    have A := calc\n      ‖q c.length‖₊ * rq ^ n ≤ ‖q c.length‖₊ * rq ^ c.length :=\n        mul_le_mul' le_rfl (pow_le_pow_of_le_one rq.2 hrq.1.le c.length_le)\n      _ ≤ Cq := hCq _\n    have B := calc\n      (∏ i, ‖p (c.blocksFun i)‖₊) * rp ^ n = ∏ i, ‖p (c.blocksFun i)‖₊ * rp ^ c.blocksFun i := by\n        simp only [Finset.prod_mul_distrib, Finset.prod_pow_eq_pow_sum, c.sum_blocksFun]\n      _ ≤ ∏ _i : Fin c.length, Cp := Finset.prod_le_prod' fun i _ => hCp _\n      _ = Cp ^ c.length := by simp\n      _ ≤ Cp ^ n := pow_right_mono₀ hCp1 c.length_le\n    calc\n      ‖q.compAlongComposition p c‖₊ * r ^ n ≤\n          (‖q c.length‖₊ * ∏ i, ‖p (c.blocksFun i)‖₊) * r ^ n :=\n        mul_le_mul' (q.compAlongComposition_nnnorm p c) le_rfl\n      _ = ‖q c.length‖₊ * rq ^ n * ((∏ i, ‖p (c.blocksFun i)‖₊) * rp ^ n) * r0 ^ n := by\n        ring\n      _ ≤ Cq * Cp ^ n * r0 ^ n := mul_le_mul' (mul_le_mul' A B) le_rfl\n      _ = Cq / 4 ^ n := by\n        simp only [r0]\n        field_simp [mul_pow, (zero_lt_one.trans_le hCp1).ne']\n        ring\n  refine ⟨r, r_pos, NNReal.summable_of_le I ?_⟩\n  simp_rw [div_eq_mul_inv]\n  refine Summable.mul_left _ ?_\n  have : ∀ n : ℕ, HasSum (fun c : Composition n => (4 ^ n : ℝ≥0)⁻¹) (2 ^ (n - 1) / 4 ^ n) := by\n    intro n\n    convert hasSum_fintype fun c : Composition n => (4 ^ n : ℝ≥0)⁻¹\n    simp [Finset.card_univ, composition_card, div_eq_mul_inv]\n  refine NNReal.summable_sigma.2 ⟨fun n => (this n).summable, (NNReal.summable_nat_add_iff 1).1 ?_⟩\n  convert (NNReal.summable_geometric (NNReal.div_lt_one_of_lt one_lt_two)).mul_left (1 / 4) using 1\n  ext1 n\n  rw [(this _).tsum_eq, add_tsub_cancel_right]\n  field_simp [← mul_assoc, pow_succ, mul_pow, show (4 : ℝ≥0) = 2 * 2 by norm_num,\n    mul_right_comm]\n\n"}
{"name":"FormalMultilinearSeries.le_comp_radius_of_summable","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nq : FormalMultilinearSeries 𝕜 F G\np : FormalMultilinearSeries 𝕜 E F\nr : NNReal\nhr : Summable fun i => HMul.hMul (NNNorm.nnnorm (q.compAlongComposition p i.snd)) (HPow.hPow r i.fst)\n⊢ LE.le (↑r) (q.comp p).radius","decl":"/-- Bounding below the radius of the composition of two formal multilinear series assuming\nsummability over all compositions. -/\ntheorem le_comp_radius_of_summable (q : FormalMultilinearSeries 𝕜 F G)\n    (p : FormalMultilinearSeries 𝕜 E F) (r : ℝ≥0)\n    (hr : Summable fun i : Σ n, Composition n => ‖q.compAlongComposition p i.2‖₊ * r ^ i.1) :\n    (r : ℝ≥0∞) ≤ (q.comp p).radius := by\n  refine\n    le_radius_of_bound_nnreal _\n      (∑' i : Σ n, Composition n, ‖compAlongComposition q p i.snd‖₊ * r ^ i.fst) fun n => ?_\n  calc\n    ‖FormalMultilinearSeries.comp q p n‖₊ * r ^ n ≤\n        ∑' c : Composition n, ‖compAlongComposition q p c‖₊ * r ^ n := by\n      rw [tsum_fintype, ← Finset.sum_mul]\n      exact mul_le_mul' (nnnorm_sum_le _ _) le_rfl\n    _ ≤ ∑' i : Σ n : ℕ, Composition n, ‖compAlongComposition q p i.snd‖₊ * r ^ i.fst :=\n      NNReal.tsum_comp_le_tsum_of_inj hr sigma_mk_injective\n\n"}
{"name":"FormalMultilinearSeries.mem_compPartialSumSource_iff","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"m M N : Nat\ni : Sigma fun n => Fin n → Nat\n⊢ Iff (Membership.mem (FormalMultilinearSeries.compPartialSumSource m M N) i) (And (And (LE.le m i.fst) (LT.lt i.fst M)) (∀ (a : Fin i.fst), And (LE.le 1 (i.snd a)) (LT.lt (i.snd a) N)))","decl":"@[simp]\ntheorem mem_compPartialSumSource_iff (m M N : ℕ) (i : Σ n, Fin n → ℕ) :\n    i ∈ compPartialSumSource m M N ↔\n      (m ≤ i.1 ∧ i.1 < M) ∧ ∀ a : Fin i.1, 1 ≤ i.2 a ∧ i.2 a < N := by\n  simp only [compPartialSumSource, Finset.mem_Ico, Fintype.mem_piFinset, Finset.mem_sigma]\n\n"}
{"name":"FormalMultilinearSeries.compChangeOfVariables_length","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"m M N : Nat\ni : Sigma fun n => Fin n → Nat\nhi : Membership.mem (FormalMultilinearSeries.compPartialSumSource m M N) i\n⊢ Eq (FormalMultilinearSeries.compChangeOfVariables m M N i hi).snd.length i.fst","decl":"@[simp]\ntheorem compChangeOfVariables_length (m M N : ℕ) {i : Σ n, Fin n → ℕ}\n    (hi : i ∈ compPartialSumSource m M N) :\n    Composition.length (compChangeOfVariables m M N i hi).2 = i.1 := by\n  rcases i with ⟨k, blocks_fun⟩\n  dsimp [compChangeOfVariables]\n  simp only [Composition.length, map_ofFn, length_ofFn]\n\n"}
{"name":"FormalMultilinearSeries.compChangeOfVariables_blocksFun","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"m M N : Nat\ni : Sigma fun n => Fin n → Nat\nhi : Membership.mem (FormalMultilinearSeries.compPartialSumSource m M N) i\nj : Fin i.fst\n⊢ Eq ((FormalMultilinearSeries.compChangeOfVariables m M N i hi).snd.blocksFun ⟨↑j, ⋯⟩) (i.snd j)","decl":"theorem compChangeOfVariables_blocksFun (m M N : ℕ) {i : Σ n, Fin n → ℕ}\n    (hi : i ∈ compPartialSumSource m M N) (j : Fin i.1) :\n    (compChangeOfVariables m M N i hi).2.blocksFun\n        ⟨j, (compChangeOfVariables_length m M N hi).symm ▸ j.2⟩ =\n      i.2 j := by\n  rcases i with ⟨n, f⟩\n  dsimp [Composition.blocksFun, Composition.blocks, compChangeOfVariables]\n  simp only [map_ofFn, List.getElem_ofFn, Function.comp_apply]\n\n"}
{"name":"FormalMultilinearSeries.compPartialSumTargetSet_image_compPartialSumSource","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"m M N : Nat\ni : Sigma fun n => Composition n\nhi : Membership.mem (FormalMultilinearSeries.compPartialSumTargetSet m M N) i\n⊢ Exists fun j => Exists fun hj => Eq (FormalMultilinearSeries.compChangeOfVariables m M N j hj) i","decl":"theorem compPartialSumTargetSet_image_compPartialSumSource (m M N : ℕ)\n    (i : Σ n, Composition n) (hi : i ∈ compPartialSumTargetSet m M N) :\n    ∃ (j : _) (hj : j ∈ compPartialSumSource m M N), compChangeOfVariables m M N j hj = i := by\n  rcases i with ⟨n, c⟩\n  refine ⟨⟨c.length, c.blocksFun⟩, ?_, ?_⟩\n  · simp only [compPartialSumTargetSet, Set.mem_setOf_eq] at hi\n    simp only [mem_compPartialSumSource_iff, hi.left, hi.right, true_and, and_true]\n    exact fun a => c.one_le_blocks' _\n  · dsimp [compChangeOfVariables]\n    rw [Composition.sigma_eq_iff_blocks_eq]\n    simp only [Composition.blocksFun, Composition.blocks, Subtype.coe_eta]\n    conv_rhs => rw [← List.ofFn_get c.blocks]\n\n"}
{"name":"FormalMultilinearSeries.mem_compPartialSumTarget_iff","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"m M N : Nat\na : Sigma fun n => Composition n\n⊢ Iff (Membership.mem (FormalMultilinearSeries.compPartialSumTarget m M N) a) (And (LE.le m a.snd.length) (And (LT.lt a.snd.length M) (∀ (j : Fin a.snd.length), LT.lt (a.snd.blocksFun j) N)))","decl":"@[simp]\ntheorem mem_compPartialSumTarget_iff {m M N : ℕ} {a : Σ n, Composition n} :\n    a ∈ compPartialSumTarget m M N ↔\n      m ≤ a.2.length ∧ a.2.length < M ∧ ∀ j : Fin a.2.length, a.2.blocksFun j < N := by\n  simp [compPartialSumTarget, compPartialSumTargetSet]\n\n"}
{"name":"FormalMultilinearSeries.compChangeOfVariables_sum","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"α : Type u_6\ninst✝ : AddCommMonoid α\nm M N : Nat\nf : (Sigma fun n => Fin n → Nat) → α\ng : (Sigma fun n => Composition n) → α\nh : ∀ (e : Sigma fun n => Fin n → Nat) (he : Membership.mem (FormalMultilinearSeries.compPartialSumSource m M N) e), Eq (f e) (g (FormalMultilinearSeries.compChangeOfVariables m M N e he))\n⊢ Eq ((FormalMultilinearSeries.compPartialSumSource m M N).sum fun e => f e) ((FormalMultilinearSeries.compPartialSumTarget m M N).sum fun e => g e)","decl":"/-- `compChangeOfVariables m M N` is a bijection between `compPartialSumSource m M N`\nand `compPartialSumTarget m M N`, yielding equal sums for functions that correspond to each\nother under the bijection. As `compChangeOfVariables m M N` is a dependent function, stating\nthat it is a bijection is not directly possible, but the consequence on sums can be stated\nmore easily. -/\ntheorem compChangeOfVariables_sum {α : Type*} [AddCommMonoid α] (m M N : ℕ)\n    (f : (Σ n : ℕ, Fin n → ℕ) → α) (g : (Σ n, Composition n) → α)\n    (h : ∀ (e) (he : e ∈ compPartialSumSource m M N), f e = g (compChangeOfVariables m M N e he)) :\n    ∑ e ∈ compPartialSumSource m M N, f e = ∑ e ∈ compPartialSumTarget m M N, g e := by\n  apply Finset.sum_bij (compChangeOfVariables m M N)\n  -- We should show that the correspondence we have set up is indeed a bijection\n  -- between the index sets of the two sums.\n  -- 1 - show that the image belongs to `compPartialSumTarget m N N`\n  · rintro ⟨k, blocks_fun⟩ H\n    rw [mem_compPartialSumSource_iff] at H\n    -- Porting note: added\n    simp only at H\n    simp only [mem_compPartialSumTarget_iff, Composition.length, Composition.blocks, H.left,\n      map_ofFn, length_ofFn, true_and, compChangeOfVariables]\n    intro j\n    simp only [Composition.blocksFun, (H.right _).right, List.get_ofFn]\n  -- 2 - show that the map is injective\n  · rintro ⟨k, blocks_fun⟩ H ⟨k', blocks_fun'⟩ H' heq\n    obtain rfl : k = k' := by\n      have := (compChangeOfVariables_length m M N H).symm\n      rwa [heq, compChangeOfVariables_length] at this\n    congr\n    funext i\n    calc\n      blocks_fun i = (compChangeOfVariables m M N _ H).2.blocksFun _ :=\n        (compChangeOfVariables_blocksFun m M N H i).symm\n      _ = (compChangeOfVariables m M N _ H').2.blocksFun _ := by\n        apply Composition.blocksFun_congr <;>\n        first | rw [heq] | rfl\n      _ = blocks_fun' i := compChangeOfVariables_blocksFun m M N H' i\n  -- 3 - show that the map is surjective\n  · intro i hi\n    apply compPartialSumTargetSet_image_compPartialSumSource m M N i\n    simpa [compPartialSumTarget] using hi\n  -- 4 - show that the composition gives the `compAlongComposition` application\n  · rintro ⟨k, blocks_fun⟩ H\n    rw [h]\n\n"}
{"name":"FormalMultilinearSeries.compPartialSumTarget_tendsto_prod_atTop","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"⊢ Filter.Tendsto (fun p => FormalMultilinearSeries.compPartialSumTarget 0 p.1 p.2) Filter.atTop Filter.atTop","decl":"/-- The auxiliary set corresponding to the composition of partial sums asymptotically contains\nall possible compositions. -/\ntheorem compPartialSumTarget_tendsto_prod_atTop :\n    Tendsto (fun (p : ℕ × ℕ) => compPartialSumTarget 0 p.1 p.2) atTop atTop := by\n  apply Monotone.tendsto_atTop_finset\n  · intro m n hmn a ha\n    have : ∀ i, i < m.1 → i < n.1 := fun i hi => lt_of_lt_of_le hi hmn.1\n    have : ∀ i, i < m.2 → i < n.2 := fun i hi => lt_of_lt_of_le hi hmn.2\n    aesop\n  · rintro ⟨n, c⟩\n    simp only [mem_compPartialSumTarget_iff]\n    obtain ⟨n, hn⟩ : BddAbove ((Finset.univ.image fun i : Fin c.length => c.blocksFun i) : Set ℕ) :=\n      Finset.bddAbove _\n    refine\n      ⟨max n c.length + 1, bot_le, lt_of_le_of_lt (le_max_right n c.length) (lt_add_one _), fun j =>\n        lt_of_le_of_lt (le_trans ?_ (le_max_left _ _)) (lt_add_one _)⟩\n    apply hn\n    simp only [Finset.mem_image_of_mem, Finset.mem_coe, Finset.mem_univ]\n\n"}
{"name":"FormalMultilinearSeries.compPartialSumTarget_tendsto_atTop","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"⊢ Filter.Tendsto (fun N => FormalMultilinearSeries.compPartialSumTarget 0 N N) Filter.atTop Filter.atTop","decl":"/-- The auxiliary set corresponding to the composition of partial sums asymptotically contains\nall possible compositions. -/\ntheorem compPartialSumTarget_tendsto_atTop :\n    Tendsto (fun N => compPartialSumTarget 0 N N) atTop atTop := by\n  apply Tendsto.comp compPartialSumTarget_tendsto_prod_atTop tendsto_atTop_diagonal\n\n"}
{"name":"FormalMultilinearSeries.comp_partialSum","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nq : FormalMultilinearSeries 𝕜 F G\np : FormalMultilinearSeries 𝕜 E F\nM N : Nat\nz : E\n⊢ Eq (q.partialSum M ((Finset.Ico 1 N).sum fun i => (p i) fun _j => z)) ((FormalMultilinearSeries.compPartialSumTarget 0 M N).sum fun i => (q.compAlongComposition p i.snd) fun _j => z)","decl":"/-- Composing the partial sums of two multilinear series coincides with the sum over all\ncompositions in `compPartialSumTarget 0 N N`. This is precisely the motivation for the\ndefinition of `compPartialSumTarget`. -/\ntheorem comp_partialSum (q : FormalMultilinearSeries 𝕜 F G) (p : FormalMultilinearSeries 𝕜 E F)\n    (M N : ℕ) (z : E) :\n    q.partialSum M (∑ i ∈ Finset.Ico 1 N, p i fun _j => z) =\n      ∑ i ∈ compPartialSumTarget 0 M N, q.compAlongComposition p i.2 fun _j => z := by\n  -- we expand the composition, using the multilinearity of `q` to expand along each coordinate.\n  suffices H :\n    (∑ n ∈ Finset.range M,\n        ∑ r ∈ Fintype.piFinset fun i : Fin n => Finset.Ico 1 N,\n          q n fun i : Fin n => p (r i) fun _j => z) =\n      ∑ i ∈ compPartialSumTarget 0 M N, q.compAlongComposition p i.2 fun _j => z by\n    simpa only [FormalMultilinearSeries.partialSum, ContinuousMultilinearMap.map_sum_finset] using H\n  -- rewrite the first sum as a big sum over a sigma type, in the finset\n  -- `compPartialSumTarget 0 N N`\n  rw [Finset.range_eq_Ico, Finset.sum_sigma']\n  -- use `compChangeOfVariables_sum`, saying that this change of variables respects sums\n  apply compChangeOfVariables_sum 0 M N\n  rintro ⟨k, blocks_fun⟩ H\n  apply congr _ (compChangeOfVariables_length 0 M N H).symm\n  intros\n  rw [← compChangeOfVariables_blocksFun 0 M N H]\n  rfl\n\n"}
{"name":"HasFPowerSeriesWithinAt.comp","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ng : F → G\nf : E → F\nq : FormalMultilinearSeries 𝕜 F G\np : FormalMultilinearSeries 𝕜 E F\nx : E\nt : Set F\ns : Set E\nhg : HasFPowerSeriesWithinAt g q t (f x)\nhf : HasFPowerSeriesWithinAt f p s x\nhs : Set.MapsTo f s t\n⊢ HasFPowerSeriesWithinAt (Function.comp g f) (q.comp p) s x","decl":"/-- If two functions `g` and `f` have power series `q` and `p` respectively at `f x` and `x`, within\ntwo sets `s` and `t` such that `f` maps `s` to `t`, then `g ∘ f` admits the power\nseries `q.comp p` at `x` within `s`. -/\ntheorem HasFPowerSeriesWithinAt.comp {g : F → G} {f : E → F} {q : FormalMultilinearSeries 𝕜 F G}\n    {p : FormalMultilinearSeries 𝕜 E F} {x : E} {t : Set F} {s : Set E}\n    (hg : HasFPowerSeriesWithinAt g q t (f x)) (hf : HasFPowerSeriesWithinAt f p s x)\n    (hs : Set.MapsTo f s t) : HasFPowerSeriesWithinAt (g ∘ f) (q.comp p) s x := by\n  /- Consider `rf` and `rg` such that `f` and `g` have power series expansion on the disks\n    of radius `rf` and `rg`. -/\n  rcases hg with ⟨rg, Hg⟩\n  rcases hf with ⟨rf, Hf⟩\n  -- The terms defining `q.comp p` are geometrically summable in a disk of some radius `r`.\n  rcases q.comp_summable_nnreal p Hg.radius_pos Hf.radius_pos with ⟨r, r_pos : 0 < r, hr⟩\n  /- We will consider `y` which is smaller than `r` and `rf`, and also small enough that\n    `f (x + y)` is close enough to `f x` to be in the disk where `g` is well behaved. Let\n    `min (r, rf, δ)` be this new radius. -/\n  obtain ⟨δ, δpos, hδ⟩ :\n    ∃ δ : ℝ≥0∞, 0 < δ ∧ ∀ {z : E}, z ∈ insert x s ∩ EMetric.ball x δ\n      → f z ∈ insert (f x) t ∩ EMetric.ball (f x) rg := by\n    have : insert (f x) t ∩ EMetric.ball (f x) rg ∈ 𝓝[insert (f x) t] (f x) := by\n      apply inter_mem_nhdsWithin\n      exact EMetric.ball_mem_nhds _ Hg.r_pos\n    have := Hf.analyticWithinAt.continuousWithinAt_insert.tendsto_nhdsWithin (hs.insert x) this\n    rcases EMetric.mem_nhdsWithin_iff.1 this with ⟨δ, δpos, Hδ⟩\n    exact ⟨δ, δpos, fun {z} hz => Hδ (by rwa [Set.inter_comm])⟩\n  let rf' := min rf δ\n  have min_pos : 0 < min rf' r := by\n    simp only [rf', r_pos, Hf.r_pos, δpos, lt_min_iff, ENNReal.coe_pos, and_self_iff]\n  /- We will show that `g ∘ f` admits the power series `q.comp p` in the disk of\n    radius `min (r, rf', δ)`. -/\n  refine ⟨min rf' r, ?_⟩\n  refine\n    ⟨le_trans (min_le_right rf' r) (FormalMultilinearSeries.le_comp_radius_of_summable q p r hr),\n      min_pos, fun {y} h'y hy ↦ ?_⟩\n  /- Let `y` satisfy `‖y‖ < min (r, rf', δ)`. We want to show that `g (f (x + y))` is the sum of\n    `q.comp p` applied to `y`. -/\n  -- First, check that `y` is small enough so that estimates for `f` and `g` apply.\n  have y_mem : y ∈ EMetric.ball (0 : E) rf :=\n    (EMetric.ball_subset_ball (le_trans (min_le_left _ _) (min_le_left _ _))) hy\n  have fy_mem : f (x + y) ∈ insert (f x) t ∩ EMetric.ball (f x) rg := by\n    apply hδ\n    have : y ∈ EMetric.ball (0 : E) δ :=\n      (EMetric.ball_subset_ball (le_trans (min_le_left _ _) (min_le_right _ _))) hy\n    simpa [-Set.mem_insert_iff, edist_eq_enorm_sub, h'y]\n  /- Now the proof starts. To show that the sum of `q.comp p` at `y` is `g (f (x + y))`,\n    we will write `q.comp p` applied to `y` as a big sum over all compositions.\n    Since the sum is summable, to get its convergence it suffices to get\n    the convergence along some increasing sequence of sets.\n    We will use the sequence of sets `compPartialSumTarget 0 n n`,\n    along which the sum is exactly the composition of the partial sums of `q` and `p`, by design.\n    To show that it converges to `g (f (x + y))`, pointwise convergence would not be enough,\n    but we have uniform convergence to save the day. -/\n  -- First step: the partial sum of `p` converges to `f (x + y)`.\n  have A : Tendsto (fun n ↦ (n, ∑ a ∈ Finset.Ico 1 n, p a fun _ ↦ y))\n      atTop (atTop ×ˢ 𝓝 (f (x + y) - f x)) := by\n    apply Tendsto.prod_mk tendsto_id\n    have L : ∀ᶠ n in atTop, (∑ a ∈ Finset.range n, p a fun _b ↦ y) - f x\n        = ∑ a ∈ Finset.Ico 1 n, p a fun _b ↦ y := by\n      rw [eventually_atTop]\n      refine ⟨1, fun n hn => ?_⟩\n      symm\n      rw [eq_sub_iff_add_eq', Finset.range_eq_Ico, ← Hf.coeff_zero fun _i => y,\n        Finset.sum_eq_sum_Ico_succ_bot hn]\n    have :\n      Tendsto (fun n => (∑ a ∈ Finset.range n, p a fun _b => y) - f x) atTop\n        (𝓝 (f (x + y) - f x)) :=\n      (Hf.hasSum h'y y_mem).tendsto_sum_nat.sub tendsto_const_nhds\n    exact Tendsto.congr' L this\n  -- Second step: the composition of the partial sums of `q` and `p` converges to `g (f (x + y))`.\n  have B : Tendsto (fun n => q.partialSum n (∑ a ∈ Finset.Ico 1 n, p a fun _b ↦ y)) atTop\n      (𝓝 (g (f (x + y)))) := by\n    -- we use the fact that the partial sums of `q` converge to `g (f (x + y))`, uniformly on a\n    -- neighborhood of `f (x + y)`.\n    have : Tendsto (fun (z : ℕ × F) ↦ q.partialSum z.1 z.2)\n        (atTop ×ˢ 𝓝 (f (x + y) - f x)) (𝓝 (g (f x + (f (x + y) - f x)))) := by\n      apply Hg.tendsto_partialSum_prod (y := f (x + y) - f x)\n      · simpa [edist_eq_enorm_sub] using fy_mem.2\n      · simpa using fy_mem.1\n    simpa using this.comp A\n  -- Third step: the sum over all compositions in `compPartialSumTarget 0 n n` converges to\n  -- `g (f (x + y))`. As this sum is exactly the composition of the partial sum, this is a direct\n  -- consequence of the second step\n  have C :\n    Tendsto\n      (fun n => ∑ i ∈ compPartialSumTarget 0 n n, q.compAlongComposition p i.2 fun _j => y)\n      atTop (𝓝 (g (f (x + y)))) := by\n    simpa [comp_partialSum] using B\n  -- Fourth step: the sum over all compositions is `g (f (x + y))`. This follows from the\n  -- convergence along a subsequence proved in the third step, and the fact that the sum is Cauchy\n  -- thanks to the summability properties.\n  have D :\n    HasSum (fun i : Σ n, Composition n => q.compAlongComposition p i.2 fun _j => y)\n      (g (f (x + y))) :=\n    haveI cau :\n      CauchySeq fun s : Finset (Σ n, Composition n) =>\n        ∑ i ∈ s, q.compAlongComposition p i.2 fun _j => y := by\n      apply cauchySeq_finset_of_norm_bounded _ (NNReal.summable_coe.2 hr) _\n      simp only [coe_nnnorm, NNReal.coe_mul, NNReal.coe_pow]\n      rintro ⟨n, c⟩\n      calc\n        ‖(compAlongComposition q p c) fun _j : Fin n => y‖ ≤\n            ‖compAlongComposition q p c‖ * ∏ _j : Fin n, ‖y‖ := by\n          apply ContinuousMultilinearMap.le_opNorm\n        _ ≤ ‖compAlongComposition q p c‖ * (r : ℝ) ^ n := by\n          apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)\n          rw [Finset.prod_const, Finset.card_fin]\n          gcongr\n          rw [EMetric.mem_ball, edist_zero_eq_enorm] at hy\n          have := le_trans (le_of_lt hy) (min_le_right _ _)\n          rwa [enorm_le_coe, ← NNReal.coe_le_coe, coe_nnnorm] at this\n    tendsto_nhds_of_cauchySeq_of_subseq cau compPartialSumTarget_tendsto_atTop C\n  -- Fifth step: the sum over `n` of `q.comp p n` can be expressed as a particular resummation of\n  -- the sum over all compositions, by grouping together the compositions of the same\n  -- integer `n`. The convergence of the whole sum therefore implies the converence of the sum\n  -- of `q.comp p n`\n  have E : HasSum (fun n => (q.comp p) n fun _j => y) (g (f (x + y))) := by\n    apply D.sigma\n    intro n\n    dsimp [FormalMultilinearSeries.comp]\n    convert hasSum_fintype (α := G) (β := Composition n) _\n    simp only [ContinuousMultilinearMap.sum_apply]\n    rfl\n  rw [Function.comp_apply]\n  exact E\n\n"}
{"name":"HasFPowerSeriesAt.comp","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ng : F → G\nf : E → F\nq : FormalMultilinearSeries 𝕜 F G\np : FormalMultilinearSeries 𝕜 E F\nx : E\nhg : HasFPowerSeriesAt g q (f x)\nhf : HasFPowerSeriesAt f p x\n⊢ HasFPowerSeriesAt (Function.comp g f) (q.comp p) x","decl":"/-- If two functions `g` and `f` have power series `q` and `p` respectively at `f x` and `x`,\nthen `g ∘ f` admits the power  series `q.comp p` at `x` within `s`. -/\ntheorem HasFPowerSeriesAt.comp {g : F → G} {f : E → F} {q : FormalMultilinearSeries 𝕜 F G}\n    {p : FormalMultilinearSeries 𝕜 E F} {x : E}\n    (hg : HasFPowerSeriesAt g q (f x)) (hf : HasFPowerSeriesAt f p x) :\n    HasFPowerSeriesAt (g ∘ f) (q.comp p) x := by\n  rw [← hasFPowerSeriesWithinAt_univ] at hf hg ⊢\n  apply hg.comp hf (by simp)\n\n"}
{"name":"AnalyticWithinAt.comp","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ng : F → G\nf : E → F\nx : E\nt : Set F\ns : Set E\nhg : AnalyticWithinAt 𝕜 g t (f x)\nhf : AnalyticWithinAt 𝕜 f s x\nh : Set.MapsTo f s t\n⊢ AnalyticWithinAt 𝕜 (Function.comp g f) s x","decl":"/-- If two functions `g` and `f` are analytic respectively at `f x` and `x`, within\ntwo sets `s` and `t` such that `f` maps `s` to `t`, then `g ∘ f` is analytic at `x` within `s`. -/\ntheorem AnalyticWithinAt.comp {g : F → G} {f : E → F} {x : E} {t : Set F} {s : Set E}\n    (hg : AnalyticWithinAt 𝕜 g t (f x)) (hf : AnalyticWithinAt 𝕜 f s x) (h : Set.MapsTo f s t) :\n    AnalyticWithinAt 𝕜 (g ∘ f) s x := by\n  let ⟨_q, hq⟩ := hg\n  let ⟨_p, hp⟩ := hf\n  exact (hq.comp hp h).analyticWithinAt\n\n"}
{"name":"AnalyticWithinAt.comp_of_eq","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ng : F → G\nf : E → F\ny : F\nx : E\nt : Set F\ns : Set E\nhg : AnalyticWithinAt 𝕜 g t y\nhf : AnalyticWithinAt 𝕜 f s x\nh : Set.MapsTo f s t\nhy : Eq (f x) y\n⊢ AnalyticWithinAt 𝕜 (Function.comp g f) s x","decl":"/-- Version of `AnalyticWithinAt.comp` where point equality is a separate hypothesis. -/\ntheorem AnalyticWithinAt.comp_of_eq {g : F → G} {f : E → F} {y : F} {x : E} {t : Set F} {s : Set E}\n    (hg : AnalyticWithinAt 𝕜 g t y) (hf : AnalyticWithinAt 𝕜 f s x) (h : Set.MapsTo f s t)\n    (hy : f x = y) :\n    AnalyticWithinAt 𝕜 (g ∘ f) s x := by\n  rw [← hy] at hg\n  exact hg.comp hf h\n\n"}
{"name":"AnalyticOn.comp","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : F → G\ng : E → F\ns : Set F\nt : Set E\nhf : AnalyticOn 𝕜 f s\nhg : AnalyticOn 𝕜 g t\nh : Set.MapsTo g t s\n⊢ AnalyticOn 𝕜 (Function.comp f g) t","decl":"lemma AnalyticOn.comp {f : F → G} {g : E → F} {s : Set F}\n    {t : Set E} (hf : AnalyticOn 𝕜 f s) (hg : AnalyticOn 𝕜 g t) (h : Set.MapsTo g t s) :\n    AnalyticOn 𝕜 (f ∘ g) t :=\n  fun x m ↦ (hf _ (h m)).comp (hg x m) h\n\n"}
{"name":"AnalyticWithinOn.comp","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : F → G\ng : E → F\ns : Set F\nt : Set E\nhf : AnalyticOn 𝕜 f s\nhg : AnalyticOn 𝕜 g t\nh : Set.MapsTo g t s\n⊢ AnalyticOn 𝕜 (Function.comp f g) t","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.comp := AnalyticOn.comp\n\n"}
{"name":"AnalyticAt.comp","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ng : F → G\nf : E → F\nx : E\nhg : AnalyticAt 𝕜 g (f x)\nhf : AnalyticAt 𝕜 f x\n⊢ AnalyticAt 𝕜 (Function.comp g f) x","decl":"/-- If two functions `g` and `f` are analytic respectively at `f x` and `x`, then `g ∘ f` is\nanalytic at `x`. -/\n@[fun_prop]\ntheorem AnalyticAt.comp {g : F → G} {f : E → F} {x : E} (hg : AnalyticAt 𝕜 g (f x))\n    (hf : AnalyticAt 𝕜 f x) : AnalyticAt 𝕜 (g ∘ f) x := by\n  rw [← analyticWithinAt_univ] at hg hf ⊢\n  apply hg.comp hf (by simp)\n\n"}
{"name":"AnalyticAt.comp'","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ng : F → G\nf : E → F\nx : E\nhg : AnalyticAt 𝕜 g (f x)\nhf : AnalyticAt 𝕜 f x\n⊢ AnalyticAt 𝕜 (fun z => g (f z)) x","decl":"/-- If two functions `g` and `f` are analytic respectively at `f x` and `x`, then `g ∘ f` is\nanalytic at `x`. -/\n@[fun_prop]\ntheorem AnalyticAt.comp' {g : F → G} {f : E → F} {x : E} (hg : AnalyticAt 𝕜 g (f x))\n    (hf : AnalyticAt 𝕜 f x) : AnalyticAt 𝕜 (fun z ↦ g (f z)) x :=\n  hg.comp hf\n\n"}
{"name":"AnalyticAt.comp_of_eq","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ng : F → G\nf : E → F\ny : F\nx : E\nhg : AnalyticAt 𝕜 g y\nhf : AnalyticAt 𝕜 f x\nhy : Eq (f x) y\n⊢ AnalyticAt 𝕜 (Function.comp g f) x","decl":"/-- Version of `AnalyticAt.comp` where point equality is a separate hypothesis. -/\ntheorem AnalyticAt.comp_of_eq {g : F → G} {f : E → F} {y : F} {x : E} (hg : AnalyticAt 𝕜 g y)\n    (hf : AnalyticAt 𝕜 f x) (hy : f x = y) : AnalyticAt 𝕜 (g ∘ f) x := by\n  rw [← hy] at hg\n  exact hg.comp hf\n\n"}
{"name":"AnalyticAt.comp_of_eq'","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ng : F → G\nf : E → F\ny : F\nx : E\nhg : AnalyticAt 𝕜 g y\nhf : AnalyticAt 𝕜 f x\nhy : Eq (f x) y\n⊢ AnalyticAt 𝕜 (fun z => g (f z)) x","decl":"/-- Version of `AnalyticAt.comp` where point equality is a separate hypothesis. -/\ntheorem AnalyticAt.comp_of_eq' {g : F → G} {f : E → F} {y : F} {x : E} (hg : AnalyticAt 𝕜 g y)\n    (hf : AnalyticAt 𝕜 f x) (hy : f x = y) : AnalyticAt 𝕜 (fun z ↦ g (f z)) x := by\n  apply hg.comp_of_eq hf hy\n\n"}
{"name":"AnalyticAt.comp_analyticWithinAt","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ng : F → G\nf : E → F\nx : E\ns : Set E\nhg : AnalyticAt 𝕜 g (f x)\nhf : AnalyticWithinAt 𝕜 f s x\n⊢ AnalyticWithinAt 𝕜 (Function.comp g f) s x","decl":"theorem AnalyticAt.comp_analyticWithinAt {g : F → G} {f : E → F} {x : E} {s : Set E}\n    (hg : AnalyticAt 𝕜 g (f x)) (hf : AnalyticWithinAt 𝕜 f s x) :\n    AnalyticWithinAt 𝕜 (g ∘ f) s x := by\n  rw [← analyticWithinAt_univ] at hg\n  exact hg.comp hf (Set.mapsTo_univ _ _)\n\n"}
{"name":"AnalyticAt.comp_analyticWithinAt_of_eq","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ng : F → G\nf : E → F\nx : E\ny : F\ns : Set E\nhg : AnalyticAt 𝕜 g y\nhf : AnalyticWithinAt 𝕜 f s x\nh : Eq (f x) y\n⊢ AnalyticWithinAt 𝕜 (Function.comp g f) s x","decl":"theorem AnalyticAt.comp_analyticWithinAt_of_eq {g : F → G} {f : E → F} {x : E} {y : F} {s : Set E}\n    (hg : AnalyticAt 𝕜 g y) (hf : AnalyticWithinAt 𝕜 f s x) (h : f x = y) :\n    AnalyticWithinAt 𝕜 (g ∘ f) s x := by\n  rw [← h] at hg\n  exact hg.comp_analyticWithinAt hf\n\n"}
{"name":"AnalyticOnNhd.comp'","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\ng : F → G\nf : E → F\nhg : AnalyticOnNhd 𝕜 g (Set.image f s)\nhf : AnalyticOnNhd 𝕜 f s\n⊢ AnalyticOnNhd 𝕜 (Function.comp g f) s","decl":"/-- If two functions `g` and `f` are analytic respectively on `s.image f` and `s`, then `g ∘ f` is\nanalytic on `s`. -/\ntheorem AnalyticOnNhd.comp' {s : Set E} {g : F → G} {f : E → F} (hg : AnalyticOnNhd 𝕜 g (s.image f))\n    (hf : AnalyticOnNhd 𝕜 f s) : AnalyticOnNhd 𝕜 (g ∘ f) s :=\n  fun z hz => (hg (f z) (Set.mem_image_of_mem f hz)).comp (hf z hz)\n\n"}
{"name":"AnalyticOn.comp'","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\ng : F → G\nf : E → F\nhg : AnalyticOnNhd 𝕜 g (Set.image f s)\nhf : AnalyticOnNhd 𝕜 f s\n⊢ AnalyticOnNhd 𝕜 (Function.comp g f) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticOn.comp' := AnalyticOnNhd.comp'\n\n"}
{"name":"AnalyticOnNhd.comp","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nt : Set F\ng : F → G\nf : E → F\nhg : AnalyticOnNhd 𝕜 g t\nhf : AnalyticOnNhd 𝕜 f s\nst : Set.MapsTo f s t\n⊢ AnalyticOnNhd 𝕜 (Function.comp g f) s","decl":"theorem AnalyticOnNhd.comp {s : Set E} {t : Set F} {g : F → G} {f : E → F}\n    (hg : AnalyticOnNhd 𝕜 g t) (hf : AnalyticOnNhd 𝕜 f s) (st : Set.MapsTo f s t) :\n    AnalyticOnNhd 𝕜 (g ∘ f) s :=\n  comp' (mono hg (Set.mapsTo'.mp st)) hf\n\n"}
{"name":"AnalyticOnNhd.comp_analyticOn","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : F → G\ng : E → F\ns : Set F\nt : Set E\nhf : AnalyticOnNhd 𝕜 f s\nhg : AnalyticOn 𝕜 g t\nh : Set.MapsTo g t s\n⊢ AnalyticOn 𝕜 (Function.comp f g) t","decl":"lemma AnalyticOnNhd.comp_analyticOn {f : F → G} {g : E → F} {s : Set F}\n    {t : Set E} (hf : AnalyticOnNhd 𝕜 f s) (hg : AnalyticOn 𝕜 g t) (h : Set.MapsTo g t s) :\n    AnalyticOn 𝕜 (f ∘ g) t :=\n  fun x m ↦ (hf _ (h m)).comp_analyticWithinAt (hg x m)\n\n"}
{"name":"AnalyticOn.comp_analyticWithinOn","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : F → G\ng : E → F\ns : Set F\nt : Set E\nhf : AnalyticOnNhd 𝕜 f s\nhg : AnalyticOn 𝕜 g t\nh : Set.MapsTo g t s\n⊢ AnalyticOn 𝕜 (Function.comp f g) t","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticOn.comp_analyticWithinOn := AnalyticOnNhd.comp_analyticOn\n\n"}
{"name":"Composition.sigma_composition_eq_iff","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"n : Nat\ni j : Sigma fun a => Composition a.length\n⊢ Iff (Eq i j) (And (Eq i.fst.blocks j.fst.blocks) (Eq i.snd.blocks j.snd.blocks))","decl":"/-- Rewriting equality in the dependent type `Σ (a : Composition n), Composition a.length)` in\nnon-dependent terms with lists, requiring that the blocks coincide. -/\ntheorem sigma_composition_eq_iff (i j : Σ a : Composition n, Composition a.length) :\n    i = j ↔ i.1.blocks = j.1.blocks ∧ i.2.blocks = j.2.blocks := by\n  refine ⟨by rintro rfl; exact ⟨rfl, rfl⟩, ?_⟩\n  rcases i with ⟨a, b⟩\n  rcases j with ⟨a', b'⟩\n  rintro ⟨h, h'⟩\n  have H : a = a' := by ext1; exact h\n  induction H; congr; ext1; exact h'\n\n"}
{"name":"Composition.sigma_pi_composition_eq_iff","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"n : Nat\nu v : Sigma fun c => (i : Fin c.length) → Composition (c.blocksFun i)\n⊢ Iff (Eq u v) (Eq (List.ofFn fun i => (u.snd i).blocks) (List.ofFn fun i => (v.snd i).blocks))","decl":"/-- Rewriting equality in the dependent type\n`Σ (c : Composition n), Π (i : Fin c.length), Composition (c.blocksFun i)` in\nnon-dependent terms with lists, requiring that the lists of blocks coincide. -/\ntheorem sigma_pi_composition_eq_iff\n    (u v : Σ c : Composition n, ∀ i : Fin c.length, Composition (c.blocksFun i)) :\n    u = v ↔ (ofFn fun i => (u.2 i).blocks) = ofFn fun i => (v.2 i).blocks := by\n  refine ⟨fun H => by rw [H], fun H => ?_⟩\n  rcases u with ⟨a, b⟩\n  rcases v with ⟨a', b'⟩\n  dsimp at H\n  have h : a = a' := by\n    ext1\n    have :\n      map List.sum (ofFn fun i : Fin (Composition.length a) => (b i).blocks) =\n        map List.sum (ofFn fun i : Fin (Composition.length a') => (b' i).blocks) := by\n      rw [H]\n    simp only [map_ofFn] at this\n    change\n      (ofFn fun i : Fin (Composition.length a) => (b i).blocks.sum) =\n        ofFn fun i : Fin (Composition.length a') => (b' i).blocks.sum at this\n    simpa [Composition.blocks_sum, Composition.ofFn_blocksFun] using this\n  induction h\n  ext1\n  · rfl\n  · simp only [heq_eq_eq, ofFn_inj] at H ⊢\n    ext1 i\n    ext1\n    exact congrFun H i\n\n"}
{"name":"Composition.length_gather","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"n : Nat\na : Composition n\nb : Composition a.length\n⊢ Eq (a.gather b).length b.length","decl":"theorem length_gather (a : Composition n) (b : Composition a.length) :\n    length (a.gather b) = b.length :=\n  show (map List.sum (a.blocks.splitWrtComposition b)).length = b.blocks.length by\n    rw [length_map, length_splitWrtComposition]\n\n"}
{"name":"Composition.length_sigmaCompositionAux","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"n : Nat\na : Composition n\nb : Composition a.length\ni : Fin b.length\n⊢ Eq (a.sigmaCompositionAux b ⟨↑i, ⋯⟩).length (b.blocksFun i)","decl":"theorem length_sigmaCompositionAux (a : Composition n) (b : Composition a.length)\n    (i : Fin b.length) :\n    Composition.length (Composition.sigmaCompositionAux a b ⟨i, (length_gather a b).symm ▸ i.2⟩) =\n      Composition.blocksFun b i :=\n  show List.length ((splitWrtComposition a.blocks b)[i.1]) = blocksFun b i by\n    rw [getElem_map_rev List.length, getElem_of_eq (map_length_splitWrtComposition _ _), blocksFun,\n      get_eq_getElem]\n\n"}
{"name":"Composition.blocksFun_sigmaCompositionAux","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"n : Nat\na : Composition n\nb : Composition a.length\ni : Fin b.length\nj : Fin (b.blocksFun i)\n⊢ Eq ((a.sigmaCompositionAux b ⟨↑i, ⋯⟩).blocksFun ⟨↑j, ⋯⟩) (a.blocksFun ((b.embedding i) j))","decl":"theorem blocksFun_sigmaCompositionAux (a : Composition n) (b : Composition a.length)\n    (i : Fin b.length) (j : Fin (blocksFun b i)) :\n    blocksFun (sigmaCompositionAux a b ⟨i, (length_gather a b).symm ▸ i.2⟩)\n        ⟨j, (length_sigmaCompositionAux a b i).symm ▸ j.2⟩ =\n      blocksFun a (embedding b i j) := by\n  unfold sigmaCompositionAux\n  rw [blocksFun, get_eq_getElem, getElem_of_eq (getElem_splitWrtComposition _ _ _ _),\n    getElem_drop, getElem_take]; rfl\n\n"}
{"name":"Composition.sizeUpTo_sizeUpTo_add","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"n : Nat\na : Composition n\nb : Composition a.length\ni j : Nat\nhi : LT.lt i b.length\nhj : LT.lt j (b.blocksFun ⟨i, hi⟩)\n⊢ Eq (a.sizeUpTo (HAdd.hAdd (b.sizeUpTo i) j)) (HAdd.hAdd ((a.gather b).sizeUpTo i) ((a.sigmaCompositionAux b ⟨i, ⋯⟩).sizeUpTo j))","decl":"/-- Auxiliary lemma to prove that the composition of formal multilinear series is associative.\n\nConsider a composition `a` of `n` and a composition `b` of `a.length`. Grouping together some\nblocks of `a` according to `b` as in `a.gather b`, one can compute the total size of the blocks\nof `a` up to an index `sizeUpTo b i + j` (where the `j` corresponds to a set of blocks of `a`\nthat do not fill a whole block of `a.gather b`). The first part corresponds to a sum of blocks\nin `a.gather b`, and the second one to a sum of blocks in the next block of\n`sigmaCompositionAux a b`. This is the content of this lemma. -/\ntheorem sizeUpTo_sizeUpTo_add (a : Composition n) (b : Composition a.length) {i j : ℕ}\n    (hi : i < b.length) (hj : j < blocksFun b ⟨i, hi⟩) :\n    sizeUpTo a (sizeUpTo b i + j) =\n      sizeUpTo (a.gather b) i +\n        sizeUpTo (sigmaCompositionAux a b ⟨i, (length_gather a b).symm ▸ hi⟩) j := by\n  -- Porting note: `induction'` left a spurious `hj` in the context\n  induction j with\n  | zero =>\n    show\n      sum (take (b.blocks.take i).sum a.blocks) =\n        sum (take i (map sum (splitWrtComposition a.blocks b)))\n    induction' i with i IH\n    · rfl\n    · have A : i < b.length := Nat.lt_of_succ_lt hi\n      have B : i < List.length (map List.sum (splitWrtComposition a.blocks b)) := by simp [A]\n      have C : 0 < blocksFun b ⟨i, A⟩ := Composition.blocks_pos' _ _ _\n      rw [sum_take_succ _ _ B, ← IH A C]\n      have :\n        take (sum (take i b.blocks)) a.blocks =\n          take (sum (take i b.blocks)) (take (sum (take (i + 1) b.blocks)) a.blocks) := by\n        rw [take_take, min_eq_left]\n        apply monotone_sum_take _ (Nat.le_succ _)\n      rw [this, getElem_map, getElem_splitWrtComposition, ←\n        take_append_drop (sum (take i b.blocks)) (take (sum (take (Nat.succ i) b.blocks)) a.blocks),\n        sum_append]\n      congr\n      rw [take_append_drop]\n  | succ j IHj =>\n    have A : j < blocksFun b ⟨i, hi⟩ := lt_trans (lt_add_one j) hj\n    have B : j < length (sigmaCompositionAux a b ⟨i, (length_gather a b).symm ▸ hi⟩) := by\n      convert A; rw [← length_sigmaCompositionAux]\n    have C : sizeUpTo b i + j < sizeUpTo b (i + 1) := by\n      simp only [sizeUpTo_succ b hi, add_lt_add_iff_left]\n      exact A\n    have D : sizeUpTo b i + j < length a := lt_of_lt_of_le C (b.sizeUpTo_le _)\n    have : sizeUpTo b i + Nat.succ j = (sizeUpTo b i + j).succ := rfl\n    rw [this, sizeUpTo_succ _ D, IHj A, sizeUpTo_succ _ B]\n    simp only [sigmaCompositionAux, add_assoc, add_left_inj, Fin.val_mk]\n    rw [getElem_of_eq (getElem_splitWrtComposition _ _ _ _), getElem_drop, getElem_take' _ _ C]\n\n"}
{"name":"FormalMultilinearSeries.comp_assoc","module":"Mathlib.Analysis.Analytic.Composition","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\nH : Type u_5\ninst✝⁸ : NontriviallyNormedField 𝕜\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nr : FormalMultilinearSeries 𝕜 G H\nq : FormalMultilinearSeries 𝕜 F G\np : FormalMultilinearSeries 𝕜 E F\n⊢ Eq ((r.comp q).comp p) (r.comp (q.comp p))","decl":"theorem comp_assoc (r : FormalMultilinearSeries 𝕜 G H) (q : FormalMultilinearSeries 𝕜 F G)\n    (p : FormalMultilinearSeries 𝕜 E F) : (r.comp q).comp p = r.comp (q.comp p) := by\n  ext n v\n  /- First, rewrite the two compositions appearing in the theorem as two sums over complicated\n    sigma types, as in the description of the proof above. -/\n  let f : (Σ a : Composition n, Composition a.length) → H := fun c =>\n    r c.2.length (applyComposition q c.2 (applyComposition p c.1 v))\n  let g : (Σ c : Composition n, ∀ i : Fin c.length, Composition (c.blocksFun i)) → H := fun c =>\n    r c.1.length fun i : Fin c.1.length =>\n      q (c.2 i).length (applyComposition p (c.2 i) (v ∘ c.1.embedding i))\n  suffices ∑ c, f c = ∑ c, g c by\n    simpa (config := { unfoldPartialApp := true }) only [FormalMultilinearSeries.comp,\n      ContinuousMultilinearMap.sum_apply, compAlongComposition_apply, Finset.sum_sigma',\n      applyComposition, ContinuousMultilinearMap.map_sum]\n  /- Now, we use `Composition.sigmaEquivSigmaPi n` to change\n    variables in the second sum, and check that we get exactly the same sums. -/\n  rw [← (sigmaEquivSigmaPi n).sum_comp]\n  /- To check that we have the same terms, we should check that we apply the same component of\n    `r`, and the same component of `q`, and the same component of `p`, to the same coordinate of\n    `v`. This is true by definition, but at each step one needs to convince Lean that the types\n    one considers are the same, using a suitable congruence lemma to avoid dependent type issues.\n    This dance has to be done three times, one for `r`, one for `q` and one for `p`. -/\n  apply Finset.sum_congr rfl\n  rintro ⟨a, b⟩ _\n  dsimp [sigmaEquivSigmaPi]\n  -- check that the `r` components are the same. Based on `Composition.length_gather`\n  apply r.congr (Composition.length_gather a b).symm\n  intro i hi1 hi2\n  -- check that the `q` components are the same. Based on `length_sigmaCompositionAux`\n  apply q.congr (length_sigmaCompositionAux a b _).symm\n  intro j hj1 hj2\n  -- check that the `p` components are the same. Based on `blocksFun_sigmaCompositionAux`\n  apply p.congr (blocksFun_sigmaCompositionAux a b _ _).symm\n  intro k hk1 hk2\n  -- finally, check that the coordinates of `v` one is using are the same. Based on\n  -- `sizeUpTo_sizeUpTo_add`.\n  refine congr_arg v (Fin.ext ?_)\n  dsimp [Composition.embedding]\n  rw [sizeUpTo_sizeUpTo_add _ _ hi1 hj1, add_assoc]\n\n"}
