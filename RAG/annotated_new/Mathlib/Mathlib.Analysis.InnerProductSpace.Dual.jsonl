{"name":"InnerProductSpace.toDualMap_apply","module":"Mathlib.Analysis.InnerProductSpace.Dual","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ Eq (((InnerProductSpace.toDualMap 𝕜 E) x) y) (Inner.inner x y)","decl":"@[simp]\ntheorem toDualMap_apply {x y : E} : toDualMap 𝕜 E x y = ⟪x, y⟫ :=\n  rfl\n\n"}
{"name":"InnerProductSpace.nullSubmodule_le_ker_toDualMap_right","module":"Mathlib.Analysis.InnerProductSpace.Dual","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx : E\n⊢ LE.le (nullSubmodule 𝕜 E) (LinearMap.ker ((InnerProductSpace.toDualMap 𝕜 E) x))","decl":"/-- For each `x : E`, the kernel of `⟪x, ⬝⟫` includes the null space. -/\nlemma nullSubmodule_le_ker_toDualMap_right (x : E) : nullSubmodule 𝕜 E ≤ ker (toDualMap 𝕜 E x) :=\n  fun _ hx ↦ inner_eq_zero_of_right x ((mem_nullSubmodule_iff).mp hx)\n\n"}
{"name":"InnerProductSpace.nullSubmodule_le_ker_toDualMap_left","module":"Mathlib.Analysis.InnerProductSpace.Dual","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\n⊢ LE.le (nullSubmodule 𝕜 E) (LinearMap.ker (InnerProductSpace.toDualMap 𝕜 E))","decl":"/-- The kernel of the map `x ↦ ⟪·, x⟫` includes the null space. -/\nlemma nullSubmodule_le_ker_toDualMap_left : nullSubmodule 𝕜 E ≤ ker (toDualMap 𝕜 E) :=\n  fun _ hx ↦ ContinuousLinearMap.ext <| fun y ↦ inner_eq_zero_of_left y hx\n\n"}
{"name":"InnerProductSpace.innerSL_norm","module":"Mathlib.Analysis.InnerProductSpace.Dual","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : Nontrivial E\n⊢ Eq (Norm.norm (innerSL 𝕜)) 1","decl":"theorem innerSL_norm [Nontrivial E] : ‖(innerSL 𝕜 : E →L⋆[𝕜] E →L[𝕜] 𝕜)‖ = 1 :=\n  show ‖(toDualMap 𝕜 E).toContinuousLinearMap‖ = 1 from LinearIsometry.norm_toContinuousLinearMap _\n\n"}
{"name":"InnerProductSpace.ext_inner_left_basis","module":"Mathlib.Analysis.InnerProductSpace.Dual","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nι : Type u_3\nx y : E\nb : Basis ι 𝕜 E\nh : ∀ (i : ι), Eq (Inner.inner (b i) x) (Inner.inner (b i) y)\n⊢ Eq x y","decl":"theorem ext_inner_left_basis {ι : Type*} {x y : E} (b : Basis ι 𝕜 E)\n    (h : ∀ i : ι, ⟪b i, x⟫ = ⟪b i, y⟫) : x = y := by\n  apply (toDualMap 𝕜 E).map_eq_iff.mp\n  refine (Function.Injective.eq_iff ContinuousLinearMap.coe_injective).mp (Basis.ext b ?_)\n  intro i\n  simp only [ContinuousLinearMap.coe_coe]\n  rw [toDualMap_apply, toDualMap_apply]\n  rw [← inner_conj_symm]\n  conv_rhs => rw [← inner_conj_symm]\n  exact congr_arg conj (h i)\n\n"}
{"name":"InnerProductSpace.ext_inner_right_basis","module":"Mathlib.Analysis.InnerProductSpace.Dual","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nι : Type u_3\nx y : E\nb : Basis ι 𝕜 E\nh : ∀ (i : ι), Eq (Inner.inner x (b i)) (Inner.inner y (b i))\n⊢ Eq x y","decl":"theorem ext_inner_right_basis {ι : Type*} {x y : E} (b : Basis ι 𝕜 E)\n    (h : ∀ i : ι, ⟪x, b i⟫ = ⟪y, b i⟫) : x = y := by\n  refine ext_inner_left_basis b fun i => ?_\n  rw [← inner_conj_symm]\n  conv_rhs => rw [← inner_conj_symm]\n  exact congr_arg conj (h i)\n\n"}
{"name":"InnerProductSpace.toDual_apply","module":"Mathlib.Analysis.InnerProductSpace.Dual","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\nx y : E\n⊢ Eq (((InnerProductSpace.toDual 𝕜 E) x) y) (Inner.inner x y)","decl":"@[simp]\ntheorem toDual_apply {x y : E} : toDual 𝕜 E x y = ⟪x, y⟫ :=\n  rfl\n\n"}
{"name":"InnerProductSpace.toDual_symm_apply","module":"Mathlib.Analysis.InnerProductSpace.Dual","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\nx : E\ny : NormedSpace.Dual 𝕜 E\n⊢ Eq (Inner.inner ((InnerProductSpace.toDual 𝕜 E).symm y) x) (y x)","decl":"@[simp]\ntheorem toDual_symm_apply {x : E} {y : NormedSpace.Dual 𝕜 E} : ⟪(toDual 𝕜 E).symm y, x⟫ = y x := by\n  rw [← toDual_apply]\n  simp only [LinearIsometryEquiv.apply_symm_apply]\n\n"}
{"name":"InnerProductSpace.continuousLinearMapOfBilin_apply","module":"Mathlib.Analysis.InnerProductSpace.Dual","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\nB : ContinuousLinearMap (starRingEnd 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E 𝕜)\nv w : E\n⊢ Eq (Inner.inner ((InnerProductSpace.continuousLinearMapOfBilin B) v) w) ((B v) w)","decl":"@[simp]\ntheorem continuousLinearMapOfBilin_apply (v w : E) : ⟪B♯ v, w⟫ = B v w := by\n  rw [continuousLinearMapOfBilin, coe_comp', ContinuousLinearEquiv.coe_coe,\n    LinearIsometryEquiv.coe_toContinuousLinearEquiv, Function.comp_apply, toDual_symm_apply]\n\n"}
{"name":"InnerProductSpace.unique_continuousLinearMapOfBilin","module":"Mathlib.Analysis.InnerProductSpace.Dual","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\nB : ContinuousLinearMap (starRingEnd 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E 𝕜)\nv f : E\nis_lax_milgram : ∀ (w : E), Eq (Inner.inner f w) ((B v) w)\n⊢ Eq f ((InnerProductSpace.continuousLinearMapOfBilin B) v)","decl":"theorem unique_continuousLinearMapOfBilin {v f : E} (is_lax_milgram : ∀ w, ⟪f, w⟫ = B v w) :\n    f = B♯ v := by\n  refine ext_inner_right 𝕜 ?_\n  intro w\n  rw [continuousLinearMapOfBilin_apply]\n  exact is_lax_milgram w\n\n"}
