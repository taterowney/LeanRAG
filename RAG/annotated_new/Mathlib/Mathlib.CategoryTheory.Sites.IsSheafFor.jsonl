{"name":"CategoryTheory.Presieve.FamilyOfElements.map_apply","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP Q : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\np : CategoryTheory.Presieve.FamilyOfElements P R\nφ : Quiver.Hom P Q\nY : C\nf : Quiver.Hom Y X\nhf : R f\n⊢ Eq (p.map φ f hf) (φ.app { unop := Y } (p f hf))","decl":"@[simp]\nlemma FamilyOfElements.map_apply\n    (p : FamilyOfElements P R) (φ : P ⟶ Q) {Y : C} (f : Y ⟶ X) (hf : R f) :\n    p.map φ f hf = φ.app _ (p f hf) := rfl\n\n"}
{"name":"CategoryTheory.Presieve.FamilyOfElements.restrict_map","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP Q : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\np : CategoryTheory.Presieve.FamilyOfElements P R\nφ : Quiver.Hom P Q\nR' : CategoryTheory.Presieve X\nh : LE.le R' R\n⊢ Eq ((CategoryTheory.Presieve.FamilyOfElements.restrict h p).map φ) (CategoryTheory.Presieve.FamilyOfElements.restrict h (p.map φ))","decl":"lemma FamilyOfElements.restrict_map\n    (p : FamilyOfElements P R) (φ : P ⟶ Q) {R' : Presieve X} (h : R' ≤ R) :\n    (p.restrict h).map φ = (p.map φ).restrict h := rfl\n\n"}
{"name":"CategoryTheory.Presieve.pullbackCompatible_iff","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nx : CategoryTheory.Presieve.FamilyOfElements P R\ninst✝ : R.hasPullbacks\n⊢ Iff x.Compatible x.PullbackCompatible","decl":"theorem pullbackCompatible_iff (x : FamilyOfElements P R) [R.hasPullbacks] :\n    x.Compatible ↔ x.PullbackCompatible := by\n  constructor\n  · intro t Y₁ Y₂ f₁ f₂ hf₁ hf₂\n    apply t\n    haveI := hasPullbacks.has_pullbacks hf₁ hf₂\n    apply pullback.condition\n  · intro t Y₁ Y₂ Z g₁ g₂ f₁ f₂ hf₁ hf₂ comm\n    haveI := hasPullbacks.has_pullbacks hf₁ hf₂\n    rw [← pullback.lift_fst _ _ comm, op_comp, FunctorToTypes.map_comp_apply, t hf₁ hf₂,\n      ← FunctorToTypes.map_comp_apply, ← op_comp, pullback.lift_snd]\n\n"}
{"name":"CategoryTheory.Presieve.FamilyOfElements.Compatible.restrict","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR₁ R₂ : CategoryTheory.Presieve X\nh : LE.le R₁ R₂\nx : CategoryTheory.Presieve.FamilyOfElements P R₂\na✝ : x.Compatible\n⊢ (CategoryTheory.Presieve.FamilyOfElements.restrict h x).Compatible","decl":"/-- The restriction of a compatible family is compatible. -/\ntheorem FamilyOfElements.Compatible.restrict {R₁ R₂ : Presieve X} (h : R₁ ≤ R₂)\n    {x : FamilyOfElements P R₂} : x.Compatible → (x.restrict h).Compatible :=\n  fun q _ _ _ g₁ g₂ _ _ h₁ h₂ comm => q g₁ g₂ (h _ h₁) (h _ h₂) comm\n\n"}
{"name":"CategoryTheory.Presieve.FamilyOfElements.Compatible.sieveExtend","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nx : CategoryTheory.Presieve.FamilyOfElements P R\nhx : x.Compatible\n⊢ x.sieveExtend.Compatible","decl":"/-- The extension of a compatible family to the generated sieve is compatible. -/\ntheorem FamilyOfElements.Compatible.sieveExtend {x : FamilyOfElements P R} (hx : x.Compatible) :\n    x.sieveExtend.Compatible := by\n  intro _ _ _ _ _ _ _ h₁ h₂ comm\n  iterate 2 erw [← FunctorToTypes.map_comp_apply]; rw [← op_comp]\n  apply hx\n  simp [comm, h₁.choose_spec.choose_spec.choose_spec.2, h₂.choose_spec.choose_spec.choose_spec.2]\n\n"}
{"name":"CategoryTheory.Presieve.extend_agrees","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX Y : C\nR : CategoryTheory.Presieve X\nx : CategoryTheory.Presieve.FamilyOfElements P R\nt : x.Compatible\nf : Quiver.Hom Y X\nhf : R f\n⊢ Eq (x.sieveExtend f ⋯) (x f hf)","decl":"/-- The extension of a family agrees with the original family. -/\ntheorem extend_agrees {x : FamilyOfElements P R} (t : x.Compatible) {f : Y ⟶ X} (hf : R f) :\n    x.sieveExtend f (le_generate R Y hf) = x f hf := by\n  have h := (le_generate R Y hf).choose_spec\n  unfold FamilyOfElements.sieveExtend\n  rw [t h.choose (𝟙 _) _ hf _]\n  · simp\n  · rw [id_comp]\n    exact h.choose_spec.choose_spec.2\n\n"}
{"name":"CategoryTheory.Presieve.restrict_extend","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nx : CategoryTheory.Presieve.FamilyOfElements P R\nt : x.Compatible\n⊢ Eq (CategoryTheory.Presieve.FamilyOfElements.restrict ⋯ x.sieveExtend) x","decl":"/-- The restriction of an extension is the original. -/\n@[simp]\ntheorem restrict_extend {x : FamilyOfElements P R} (t : x.Compatible) :\n    x.sieveExtend.restrict (le_generate R) = x := by\n  funext Y f hf\n  exact extend_agrees t hf\n\n"}
{"name":"CategoryTheory.Presieve.compatible_iff_sieveCompatible","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nS : CategoryTheory.Sieve X\nx : CategoryTheory.Presieve.FamilyOfElements P S.arrows\n⊢ Iff x.Compatible x.SieveCompatible","decl":"theorem compatible_iff_sieveCompatible (x : FamilyOfElements P (S : Presieve X)) :\n    x.Compatible ↔ x.SieveCompatible := by\n  constructor\n  · intro h Y Z f g hf\n    simpa using h (𝟙 _) g (S.downward_closed hf g) hf (id_comp _)\n  · intro h Y₁ Y₂ Z g₁ g₂ f₁ f₂ h₁ h₂ k\n    simp_rw [← h f₁ g₁ h₁, ← h f₂ g₂ h₂]\n    congr\n\n"}
{"name":"CategoryTheory.Presieve.FamilyOfElements.Compatible.to_sieveCompatible","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nS : CategoryTheory.Sieve X\nx : CategoryTheory.Presieve.FamilyOfElements P S.arrows\nt : x.Compatible\n⊢ x.SieveCompatible","decl":"theorem FamilyOfElements.Compatible.to_sieveCompatible {x : FamilyOfElements P (S : Presieve X)}\n    (t : x.Compatible) : x.SieveCompatible :=\n  (compatible_iff_sieveCompatible x).1 t\n\n"}
{"name":"CategoryTheory.Presieve.extend_restrict","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nx : CategoryTheory.Presieve.FamilyOfElements P (CategoryTheory.Sieve.generate R).arrows\nt : x.Compatible\n⊢ Eq (CategoryTheory.Presieve.FamilyOfElements.restrict ⋯ x).sieveExtend x","decl":"/--\nGiven a family of elements `x` for the sieve `S` generated by a presieve `R`, if `x` is restricted\nto `R` and then extended back up to `S`, the resulting extension equals `x`.\n-/\n@[simp]\ntheorem extend_restrict {x : FamilyOfElements P (generate R).arrows} (t : x.Compatible) :\n    (x.restrict (le_generate R)).sieveExtend = x := by\n  rw [compatible_iff_sieveCompatible] at t\n  funext _ _ h\n  apply (t _ _ _).symm.trans\n  congr\n  exact h.choose_spec.choose_spec.choose_spec.2\n\n"}
{"name":"CategoryTheory.Presieve.restrict_inj","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nx₁ x₂ : CategoryTheory.Presieve.FamilyOfElements P (CategoryTheory.Sieve.generate R).arrows\nt₁ : x₁.Compatible\nt₂ : x₂.Compatible\na✝ : Eq (CategoryTheory.Presieve.FamilyOfElements.restrict ⋯ x₁) (CategoryTheory.Presieve.FamilyOfElements.restrict ⋯ x₂)\n⊢ Eq x₁ x₂","decl":"/--\nTwo compatible families on the sieve generated by a presieve `R` are equal if and only if they are\nequal when restricted to `R`.\n-/\ntheorem restrict_inj {x₁ x₂ : FamilyOfElements P (generate R).arrows} (t₁ : x₁.Compatible)\n    (t₂ : x₂.Compatible) : x₁.restrict (le_generate R) = x₂.restrict (le_generate R) → x₁ = x₂ :=\n  fun h => by\n  rw [← extend_restrict t₁, ← extend_restrict t₂]\n  -- Porting note: congr fails to make progress\n  apply congr_arg\n  exact h\n\n"}
{"name":"CategoryTheory.Presieve.compatibleEquivGenerateSieveCompatible_symm_apply_coe","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nx : Subtype fun x => x.Compatible\n⊢ Eq (↑(CategoryTheory.Presieve.compatibleEquivGenerateSieveCompatible.symm x)) (CategoryTheory.Presieve.FamilyOfElements.restrict ⋯ ↑x)","decl":"/-- Compatible families of elements for a presheaf of types `P` and a presieve `R`\n    are in 1-1 correspondence with compatible families for the same presheaf and\n    the sieve generated by `R`, through extension and restriction. -/\n@[simps]\nnoncomputable def compatibleEquivGenerateSieveCompatible :\n    { x : FamilyOfElements P R // x.Compatible } ≃\n      { x : FamilyOfElements P (generate R : Presieve X) // x.Compatible } where\n  toFun x := ⟨x.1.sieveExtend, x.2.sieveExtend⟩\n  invFun x := ⟨x.1.restrict (le_generate R), x.2.restrict _⟩\n  left_inv x := Subtype.ext (restrict_extend x.2)\n  right_inv x := Subtype.ext (extend_restrict x.2)\n\n"}
{"name":"CategoryTheory.Presieve.compatibleEquivGenerateSieveCompatible_apply_coe","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nx : Subtype fun x => x.Compatible\n⊢ Eq (↑(CategoryTheory.Presieve.compatibleEquivGenerateSieveCompatible x)) (↑x).sieveExtend","decl":"/-- Compatible families of elements for a presheaf of types `P` and a presieve `R`\n    are in 1-1 correspondence with compatible families for the same presheaf and\n    the sieve generated by `R`, through extension and restriction. -/\n@[simps]\nnoncomputable def compatibleEquivGenerateSieveCompatible :\n    { x : FamilyOfElements P R // x.Compatible } ≃\n      { x : FamilyOfElements P (generate R : Presieve X) // x.Compatible } where\n  toFun x := ⟨x.1.sieveExtend, x.2.sieveExtend⟩\n  invFun x := ⟨x.1.restrict (le_generate R), x.2.restrict _⟩\n  left_inv x := Subtype.ext (restrict_extend x.2)\n  right_inv x := Subtype.ext (extend_restrict x.2)\n\n"}
{"name":"CategoryTheory.Presieve.FamilyOfElements.comp_of_compatible","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX Y : C\nS : CategoryTheory.Sieve X\nx : CategoryTheory.Presieve.FamilyOfElements P S.arrows\nt : x.Compatible\nf : Quiver.Hom Y X\nhf : S.arrows f\nZ : C\ng : Quiver.Hom Z Y\n⊢ Eq (x (CategoryTheory.CategoryStruct.comp g f) ⋯) (P.map g.op (x f hf))","decl":"theorem FamilyOfElements.comp_of_compatible (S : Sieve X) {x : FamilyOfElements P S}\n    (t : x.Compatible) {f : Y ⟶ X} (hf : S f) {Z} (g : Z ⟶ Y) :\n    x (g ≫ f) (S.downward_closed hf g) = P.map g.op (x f hf) := by\n  simpa using t (𝟙 _) g (S.downward_closed hf g) hf (id_comp _)\n\n"}
{"name":"CategoryTheory.Presieve.FamilyOfElements.Compatible.functorPullback","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor D C\nZ : D\nT : CategoryTheory.Presieve (F.obj Z)\nx : CategoryTheory.Presieve.FamilyOfElements P T\nh : x.Compatible\n⊢ (CategoryTheory.Presieve.FamilyOfElements.functorPullback F x).Compatible","decl":"theorem FamilyOfElements.Compatible.functorPullback (h : x.Compatible) :\n    (x.functorPullback F).Compatible := by\n  intro Z₁ Z₂ W g₁ g₂ f₁ f₂ h₁ h₂ eq\n  exact h (F.map g₁) (F.map g₂) h₁ h₂ (by simp only [← F.map_comp, eq])\n\n"}
{"name":"CategoryTheory.Presieve.FamilyOfElements.Compatible.pullback","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX Y : C\nS : CategoryTheory.Sieve X\nf : Quiver.Hom Y X\nx : CategoryTheory.Presieve.FamilyOfElements P S.arrows\nh : x.Compatible\n⊢ (CategoryTheory.Presieve.FamilyOfElements.pullback f x).Compatible","decl":"theorem FamilyOfElements.Compatible.pullback (f : Y ⟶ X) {x : FamilyOfElements P S.arrows}\n    (h : x.Compatible) : (x.pullback f).Compatible := by\n  simp only [compatible_iff_sieveCompatible] at h ⊢\n  intro W Z f₁ f₂ hf\n  unfold FamilyOfElements.pullback\n  rw [← h (f₁ ≫ f) f₂ hf]\n  congr 1\n  simp only [assoc]\n\n"}
{"name":"CategoryTheory.Presieve.FamilyOfElements.compPresheafMap_id","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nx : CategoryTheory.Presieve.FamilyOfElements P R\n⊢ Eq (CategoryTheory.Presieve.FamilyOfElements.compPresheafMap (CategoryTheory.CategoryStruct.id P) x) x","decl":"@[simp]\ntheorem FamilyOfElements.compPresheafMap_id (x : FamilyOfElements P R) :\n    x.compPresheafMap (𝟙 P) = x :=\n  rfl\n\n"}
{"name":"CategoryTheory.Presieve.FamilyOfElements.compPresheafMap_comp","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP Q U : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nx : CategoryTheory.Presieve.FamilyOfElements P R\nf : Quiver.Hom P Q\ng : Quiver.Hom Q U\n⊢ Eq (CategoryTheory.Presieve.FamilyOfElements.compPresheafMap g (CategoryTheory.Presieve.FamilyOfElements.compPresheafMap f x)) (CategoryTheory.Presieve.FamilyOfElements.compPresheafMap (CategoryTheory.CategoryStruct.comp f g) x)","decl":"@[simp]\ntheorem FamilyOfElements.compPresheafMap_comp (x : FamilyOfElements P R) (f : P ⟶ Q)\n    (g : Q ⟶ U) : (x.compPresheafMap f).compPresheafMap g = x.compPresheafMap (f ≫ g) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Presieve.FamilyOfElements.Compatible.compPresheafMap","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP Q : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nf : Quiver.Hom P Q\nx : CategoryTheory.Presieve.FamilyOfElements P R\nh : x.Compatible\n⊢ (CategoryTheory.Presieve.FamilyOfElements.compPresheafMap f x).Compatible","decl":"theorem FamilyOfElements.Compatible.compPresheafMap (f : P ⟶ Q) {x : FamilyOfElements P R}\n    (h : x.Compatible) : (x.compPresheafMap f).Compatible := by\n  intro Z₁ Z₂ W g₁ g₂ f₁ f₂ h₁ h₂ eq\n  unfold FamilyOfElements.compPresheafMap\n  rwa [← FunctorToTypes.naturality, ← FunctorToTypes.naturality, h]\n\n"}
{"name":"CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation.compPresheafMap","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP Q : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nx : CategoryTheory.Presieve.FamilyOfElements P R\nt : P.obj { unop := X }\nf : Quiver.Hom P Q\nh : x.IsAmalgamation t\n⊢ (CategoryTheory.Presieve.FamilyOfElements.compPresheafMap f x).IsAmalgamation (f.app { unop := X } t)","decl":"theorem FamilyOfElements.IsAmalgamation.compPresheafMap {x : FamilyOfElements P R} {t} (f : P ⟶ Q)\n    (h : x.IsAmalgamation t) : (x.compPresheafMap f).IsAmalgamation (f.app (op X) t) := by\n  intro Y g hg\n  dsimp [FamilyOfElements.compPresheafMap]\n  change (f.app _ ≫ Q.map _) _ = _\n  rw [← f.naturality, types_comp_apply, h g hg]\n\n"}
{"name":"CategoryTheory.Presieve.is_compatible_of_exists_amalgamation","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nx : CategoryTheory.Presieve.FamilyOfElements P R\nh : Exists fun t => x.IsAmalgamation t\n⊢ x.Compatible","decl":"theorem is_compatible_of_exists_amalgamation (x : FamilyOfElements P R)\n    (h : ∃ t, x.IsAmalgamation t) : x.Compatible := by\n  cases' h with t ht\n  intro Y₁ Y₂ Z g₁ g₂ f₁ f₂ h₁ h₂ comm\n  rw [← ht _ h₁, ← ht _ h₂, ← FunctorToTypes.map_comp_apply, ← op_comp, comm]\n  simp\n\n"}
{"name":"CategoryTheory.Presieve.isAmalgamation_restrict","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR₁ R₂ : CategoryTheory.Presieve X\nh : LE.le R₁ R₂\nx : CategoryTheory.Presieve.FamilyOfElements P R₂\nt : P.obj { unop := X }\nht : x.IsAmalgamation t\n⊢ (CategoryTheory.Presieve.FamilyOfElements.restrict h x).IsAmalgamation t","decl":"theorem isAmalgamation_restrict {R₁ R₂ : Presieve X} (h : R₁ ≤ R₂) (x : FamilyOfElements P R₂)\n    (t : P.obj (op X)) (ht : x.IsAmalgamation t) : (x.restrict h).IsAmalgamation t := fun Y f hf =>\n  ht f (h Y hf)\n\n"}
{"name":"CategoryTheory.Presieve.isAmalgamation_sieveExtend","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nx : CategoryTheory.Presieve.FamilyOfElements P R\nt : P.obj { unop := X }\nht : x.IsAmalgamation t\n⊢ x.sieveExtend.IsAmalgamation t","decl":"theorem isAmalgamation_sieveExtend {R : Presieve X} (x : FamilyOfElements P R) (t : P.obj (op X))\n    (ht : x.IsAmalgamation t) : x.sieveExtend.IsAmalgamation t := by\n  intro Y f hf\n  dsimp [FamilyOfElements.sieveExtend]\n  rw [← ht _, ← FunctorToTypes.map_comp_apply, ← op_comp, hf.choose_spec.choose_spec.choose_spec.2]\n\n"}
{"name":"CategoryTheory.Presieve.IsSeparatedFor.ext","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nhR : CategoryTheory.Presieve.IsSeparatedFor P R\nt₁ t₂ : P.obj { unop := X }\nh : ∀ ⦃Y : C⦄ ⦃f : Quiver.Hom Y X⦄, R f → Eq (P.map f.op t₁) (P.map f.op t₂)\n⊢ Eq t₁ t₂","decl":"theorem IsSeparatedFor.ext {R : Presieve X} (hR : IsSeparatedFor P R) {t₁ t₂ : P.obj (op X)}\n    (h : ∀ ⦃Y⦄ ⦃f : Y ⟶ X⦄ (_ : R f), P.map f.op t₁ = P.map f.op t₂) : t₁ = t₂ :=\n  hR (fun _ f _ => P.map f.op t₂) t₁ t₂ (fun _ _ hf => h hf) fun _ _ _ => rfl\n\n"}
{"name":"CategoryTheory.Presieve.isSeparatedFor_iff_generate","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\n⊢ Iff (CategoryTheory.Presieve.IsSeparatedFor P R) (CategoryTheory.Presieve.IsSeparatedFor P (CategoryTheory.Sieve.generate R).arrows)","decl":"theorem isSeparatedFor_iff_generate :\n    IsSeparatedFor P R ↔ IsSeparatedFor P (generate R : Presieve X) := by\n  constructor\n  · intro h x t₁ t₂ ht₁ ht₂\n    apply h (x.restrict (le_generate R)) t₁ t₂ _ _\n    · exact isAmalgamation_restrict _ x t₁ ht₁\n    · exact isAmalgamation_restrict _ x t₂ ht₂\n  · intro h x t₁ t₂ ht₁ ht₂\n    apply h x.sieveExtend\n    · exact isAmalgamation_sieveExtend x t₁ ht₁\n    · exact isAmalgamation_sieveExtend x t₂ ht₂\n\n"}
{"name":"CategoryTheory.Presieve.isSeparatedFor_top","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nP : CategoryTheory.Functor (Opposite C) (Type w)\n⊢ CategoryTheory.Presieve.IsSeparatedFor P Top.top","decl":"theorem isSeparatedFor_top (P : Cᵒᵖ ⥤ Type w) : IsSeparatedFor P (⊤ : Presieve X) :=\n  fun x t₁ t₂ h₁ h₂ => by\n  have q₁ := h₁ (𝟙 X) (by tauto)\n  have q₂ := h₂ (𝟙 X) (by tauto)\n  simp only [op_id, FunctorToTypes.map_id_apply] at q₁ q₂\n  rw [q₁, q₂]\n\n"}
{"name":"CategoryTheory.Presieve.extension_iff_amalgamation","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nS : CategoryTheory.Sieve X\nP : CategoryTheory.Functor (Opposite C) (Type v₁)\nx : Quiver.Hom S.functor P\ng : Quiver.Hom (CategoryTheory.yoneda.obj X) P\n⊢ Iff (Eq (CategoryTheory.CategoryStruct.comp S.functorInclusion g) x) ((↑(CategoryTheory.Presieve.natTransEquivCompatibleFamily x)).IsAmalgamation (CategoryTheory.yonedaEquiv g))","decl":"/-- (Implementation). A lemma useful to prove `isSheafFor_iff_yonedaSheafCondition`. -/\ntheorem extension_iff_amalgamation {P : Cᵒᵖ ⥤ Type v₁} (x : S.functor ⟶ P) (g : yoneda.obj X ⟶ P) :\n    S.functorInclusion ≫ g = x ↔\n      (natTransEquivCompatibleFamily x).1.IsAmalgamation (yonedaEquiv g) := by\n  change _ ↔ ∀ ⦃Y : C⦄ (f : Y ⟶ X) (h : S f), P.map f.op (yonedaEquiv g) = x.app (op Y) ⟨f, h⟩\n  constructor\n  · rintro rfl Y f hf\n    rw [yonedaEquiv_naturality]\n    dsimp\n    simp [yonedaEquiv_apply]\n  -- See note [dsimp, simp].\n  · intro h\n    ext Y ⟨f, hf⟩\n    convert h f hf\n    rw [yonedaEquiv_naturality]\n    dsimp [yonedaEquiv]\n    simp\n\n"}
{"name":"CategoryTheory.Presieve.isSheafFor_iff_yonedaSheafCondition","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nS : CategoryTheory.Sieve X\nP : CategoryTheory.Functor (Opposite C) (Type v₁)\n⊢ Iff (CategoryTheory.Presieve.IsSheafFor P S.arrows) (CategoryTheory.Presieve.YonedaSheafCondition P S)","decl":"/-- The yoneda version of the sheaf condition is equivalent to the sheaf condition.\n\nC2.1.4 of [Elephant].\n-/\ntheorem isSheafFor_iff_yonedaSheafCondition {P : Cᵒᵖ ⥤ Type v₁} :\n    IsSheafFor P (S : Presieve X) ↔ YonedaSheafCondition P S := by\n  rw [IsSheafFor, YonedaSheafCondition]\n  simp_rw [extension_iff_amalgamation]\n  rw [Equiv.forall_congr_left natTransEquivCompatibleFamily]\n  rw [Subtype.forall]\n  exact forall₂_congr fun x hx ↦ by simp [Equiv.existsUnique_congr_right]\n\n"}
{"name":"CategoryTheory.Presieve.IsSheafFor.functorInclusion_comp_extend_assoc","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nS : CategoryTheory.Sieve X\nP : CategoryTheory.Functor (Opposite C) (Type v₁)\nh✝ : CategoryTheory.Presieve.IsSheafFor P S.arrows\nf : Quiver.Hom S.functor P\nZ : CategoryTheory.Functor (Opposite C) (Type v₁)\nh : Quiver.Hom P Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.functorInclusion (CategoryTheory.CategoryStruct.comp (h✝.extend f) h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"/--\nShow that the extension of `f : S.functor ⟶ P` to all of `yoneda.obj X` is in fact an extension, ie\nthat the triangle below commutes, provided `P` is a sheaf for `S`\n\n      f\n   S  →  P\n   ↓  ↗\n   yX\n\n-/\n@[reassoc (attr := simp)]\ntheorem IsSheafFor.functorInclusion_comp_extend {P : Cᵒᵖ ⥤ Type v₁} (h : IsSheafFor P S.arrows)\n    (f : S.functor ⟶ P) : S.functorInclusion ≫ h.extend f = f :=\n  (isSheafFor_iff_yonedaSheafCondition.1 h f).exists.choose_spec\n\n"}
{"name":"CategoryTheory.Presieve.IsSheafFor.functorInclusion_comp_extend","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nS : CategoryTheory.Sieve X\nP : CategoryTheory.Functor (Opposite C) (Type v₁)\nh : CategoryTheory.Presieve.IsSheafFor P S.arrows\nf : Quiver.Hom S.functor P\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.functorInclusion (h.extend f)) f","decl":"/--\nShow that the extension of `f : S.functor ⟶ P` to all of `yoneda.obj X` is in fact an extension, ie\nthat the triangle below commutes, provided `P` is a sheaf for `S`\n\n      f\n   S  →  P\n   ↓  ↗\n   yX\n\n-/\n@[reassoc (attr := simp)]\ntheorem IsSheafFor.functorInclusion_comp_extend {P : Cᵒᵖ ⥤ Type v₁} (h : IsSheafFor P S.arrows)\n    (f : S.functor ⟶ P) : S.functorInclusion ≫ h.extend f = f :=\n  (isSheafFor_iff_yonedaSheafCondition.1 h f).exists.choose_spec\n\n"}
{"name":"CategoryTheory.Presieve.IsSheafFor.unique_extend","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nS : CategoryTheory.Sieve X\nP : CategoryTheory.Functor (Opposite C) (Type v₁)\nh : CategoryTheory.Presieve.IsSheafFor P S.arrows\nf : Quiver.Hom S.functor P\nt : Quiver.Hom (CategoryTheory.yoneda.obj X) P\nht : Eq (CategoryTheory.CategoryStruct.comp S.functorInclusion t) f\n⊢ Eq t (h.extend f)","decl":"/-- The extension of `f` to `yoneda.obj X` is unique. -/\ntheorem IsSheafFor.unique_extend {P : Cᵒᵖ ⥤ Type v₁} (h : IsSheafFor P S.arrows) {f : S.functor ⟶ P}\n    (t : yoneda.obj X ⟶ P) (ht : S.functorInclusion ≫ t = f) : t = h.extend f :=\n  (isSheafFor_iff_yonedaSheafCondition.1 h f).unique ht (h.functorInclusion_comp_extend f)\n\n"}
{"name":"CategoryTheory.Presieve.IsSheafFor.hom_ext","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nS : CategoryTheory.Sieve X\nP : CategoryTheory.Functor (Opposite C) (Type v₁)\nh : CategoryTheory.Presieve.IsSheafFor P S.arrows\nt₁ t₂ : Quiver.Hom (CategoryTheory.yoneda.obj X) P\nht : Eq (CategoryTheory.CategoryStruct.comp S.functorInclusion t₁) (CategoryTheory.CategoryStruct.comp S.functorInclusion t₂)\n⊢ Eq t₁ t₂","decl":"/--\nIf `P` is a sheaf for the sieve `S` on `X`, then if two natural transformations from `yoneda.obj X`\nto `P` agree when restricted to the subfunctor given by `S`, they are equal.\n-/\ntheorem IsSheafFor.hom_ext {P : Cᵒᵖ ⥤ Type v₁} (h : IsSheafFor P (S : Presieve X))\n    (t₁ t₂ : yoneda.obj X ⟶ P) (ht : S.functorInclusion ≫ t₁ = S.functorInclusion ≫ t₂) :\n    t₁ = t₂ :=\n  (h.unique_extend t₁ ht).trans (h.unique_extend t₂ rfl).symm\n\n"}
{"name":"CategoryTheory.Presieve.isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\n⊢ Iff (And (CategoryTheory.Presieve.IsSeparatedFor P R) (∀ (x : CategoryTheory.Presieve.FamilyOfElements P R), x.Compatible → Exists fun t => x.IsAmalgamation t)) (CategoryTheory.Presieve.IsSheafFor P R)","decl":"/-- `P` is a sheaf for `R` iff it is separated for `R` and there exists an amalgamation. -/\ntheorem isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor :\n    (IsSeparatedFor P R ∧ ∀ x : FamilyOfElements P R, x.Compatible → ∃ t, x.IsAmalgamation t) ↔\n      IsSheafFor P R := by\n  rw [IsSeparatedFor, ← forall_and]\n  apply forall_congr'\n  intro x\n  constructor\n  · intro z hx\n    exact existsUnique_of_exists_of_unique (z.2 hx) z.1\n  · intro h\n    refine ⟨?_, ExistsUnique.exists ∘ h⟩\n    intro t₁ t₂ ht₁ ht₂\n    apply (h _).unique ht₁ ht₂\n    exact is_compatible_of_exists_amalgamation x ⟨_, ht₂⟩\n\n"}
{"name":"CategoryTheory.Presieve.IsSeparatedFor.isSheafFor","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nt : CategoryTheory.Presieve.IsSeparatedFor P R\na✝ : ∀ (x : CategoryTheory.Presieve.FamilyOfElements P R), x.Compatible → Exists fun t => x.IsAmalgamation t\n⊢ CategoryTheory.Presieve.IsSheafFor P R","decl":"/-- If `P` is separated for `R` and every family has an amalgamation, then `P` is a sheaf for `R`.\n-/\ntheorem IsSeparatedFor.isSheafFor (t : IsSeparatedFor P R) :\n    (∀ x : FamilyOfElements P R, x.Compatible → ∃ t, x.IsAmalgamation t) → IsSheafFor P R := by\n  rw [← isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor]\n  exact And.intro t\n\n"}
{"name":"CategoryTheory.Presieve.IsSheafFor.isSeparatedFor","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\na✝ : CategoryTheory.Presieve.IsSheafFor P R\n⊢ CategoryTheory.Presieve.IsSeparatedFor P R","decl":"/-- If `P` is a sheaf for `R`, it is separated for `R`. -/\ntheorem IsSheafFor.isSeparatedFor : IsSheafFor P R → IsSeparatedFor P R := fun q =>\n  (isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor.2 q).1\n\n"}
{"name":"CategoryTheory.Presieve.IsSheafFor.isAmalgamation","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nt : CategoryTheory.Presieve.IsSheafFor P R\nx : CategoryTheory.Presieve.FamilyOfElements P R\nhx : x.Compatible\n⊢ x.IsAmalgamation (t.amalgamate x hx)","decl":"theorem IsSheafFor.isAmalgamation (t : IsSheafFor P R) {x : FamilyOfElements P R}\n    (hx : x.Compatible) : x.IsAmalgamation (t.amalgamate x hx) :=\n  (t x hx).exists.choose_spec\n\n"}
{"name":"CategoryTheory.Presieve.IsSheafFor.valid_glue","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX Y : C\nR : CategoryTheory.Presieve X\nt : CategoryTheory.Presieve.IsSheafFor P R\nx : CategoryTheory.Presieve.FamilyOfElements P R\nhx : x.Compatible\nf : Quiver.Hom Y X\nHf : R f\n⊢ Eq (P.map f.op (t.amalgamate x hx)) (x f Hf)","decl":"@[simp]\ntheorem IsSheafFor.valid_glue (t : IsSheafFor P R) {x : FamilyOfElements P R} (hx : x.Compatible)\n    (f : Y ⟶ X) (Hf : R f) : P.map f.op (t.amalgamate x hx) = x f Hf :=\n  t.isAmalgamation hx f Hf\n\n"}
{"name":"CategoryTheory.Presieve.isSheafFor_iff_generate","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\n⊢ Iff (CategoryTheory.Presieve.IsSheafFor P R) (CategoryTheory.Presieve.IsSheafFor P (CategoryTheory.Sieve.generate R).arrows)","decl":"/-- C2.1.3 in [Elephant] -/\ntheorem isSheafFor_iff_generate (R : Presieve X) :\n    IsSheafFor P R ↔ IsSheafFor P (generate R : Presieve X) := by\n  rw [← isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor]\n  rw [← isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor]\n  rw [← isSeparatedFor_iff_generate]\n  apply and_congr (Iff.refl _)\n  constructor\n  · intro q x hx\n    apply Exists.imp _ (q _ (hx.restrict (le_generate R)))\n    intro t ht\n    simpa [hx] using isAmalgamation_sieveExtend _ _ ht\n  · intro q x hx\n    apply Exists.imp _ (q _ hx.sieveExtend)\n    intro t ht\n    simpa [hx] using isAmalgamation_restrict (le_generate R) _ _ ht\n\n"}
{"name":"CategoryTheory.Presieve.isSheafFor_singleton_iso","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nP : CategoryTheory.Functor (Opposite C) (Type w)\n⊢ CategoryTheory.Presieve.IsSheafFor P (CategoryTheory.Presieve.singleton (CategoryTheory.CategoryStruct.id X))","decl":"/-- Every presheaf is a sheaf for the family {𝟙 X}.\n\n[Elephant] C2.1.5(i)\n-/\ntheorem isSheafFor_singleton_iso (P : Cᵒᵖ ⥤ Type w) : IsSheafFor P (Presieve.singleton (𝟙 X)) := by\n  intro x _\n  refine ⟨x _ (Presieve.singleton_self _), ?_, ?_⟩\n  · rintro _ _ ⟨rfl, rfl⟩\n    simp\n  · intro t ht\n    simpa using ht _ (Presieve.singleton_self _)\n\n"}
{"name":"CategoryTheory.Presieve.isSheafFor_top_sieve","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nP : CategoryTheory.Functor (Opposite C) (Type w)\n⊢ CategoryTheory.Presieve.IsSheafFor P Top.top.arrows","decl":"/-- Every presheaf is a sheaf for the maximal sieve.\n\n[Elephant] C2.1.5(ii)\n-/\ntheorem isSheafFor_top_sieve (P : Cᵒᵖ ⥤ Type w) : IsSheafFor P ((⊤ : Sieve X) : Presieve X) := by\n  rw [← generate_of_singleton_isSplitEpi (𝟙 X)]\n  rw [← isSheafFor_iff_generate]\n  apply isSheafFor_singleton_iso\n\n"}
{"name":"CategoryTheory.Presieve.isSheafFor_of_nat_equiv","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP₁ : CategoryTheory.Functor (Opposite C) (Type w)\nP₂ : CategoryTheory.Functor (Opposite C) (Type w')\ne : ⦃X : C⦄ → Equiv (P₁.obj { unop := X }) (P₂.obj { unop := X })\nhe : ∀ ⦃X Y : C⦄ (f : Quiver.Hom X Y) (x : P₁.obj { unop := Y }), Eq (e (P₁.map f.op x)) (P₂.map f.op (e x))\nX : C\nR : CategoryTheory.Presieve X\nhP₁ : CategoryTheory.Presieve.IsSheafFor P₁ R\n⊢ CategoryTheory.Presieve.IsSheafFor P₂ R","decl":"/-- If `P₁ : Cᵒᵖ ⥤ Type w` and `P₂  : Cᵒᵖ ⥤ Type w` are two naturally equivalent\npresheaves, and `P₁` is a sheaf for a presieve `R`, then `P₂` is also a sheaf for `R`. -/\nlemma isSheafFor_of_nat_equiv {P₁ : Cᵒᵖ ⥤ Type w} {P₂ : Cᵒᵖ ⥤ Type w'}\n    (e : ∀ ⦃X : C⦄, P₁.obj (op X) ≃ P₂.obj (op X))\n    (he : ∀ ⦃X Y : C⦄ (f : X ⟶ Y) (x : P₁.obj (op Y)),\n      e (P₁.map f.op x) = P₂.map f.op (e x))\n    {X : C} {R : Presieve X} (hP₁ : IsSheafFor P₁ R) :\n    IsSheafFor P₂ R := fun x₂ hx₂ ↦ by\n  have he' : ∀ ⦃X Y : C⦄ (f : X ⟶ Y) (x : P₂.obj (op Y)),\n    e.symm (P₂.map f.op x) = P₁.map f.op (e.symm x) := fun X Y f x ↦\n      e.injective (by simp only [Equiv.apply_symm_apply, he])\n  let x₁ : FamilyOfElements P₁ R := fun Y f hf ↦ e.symm (x₂ f hf)\n  have hx₁ : x₁.Compatible := fun Y₁ Y₂ Z g₁ g₂ f₁ f₂ h₁ h₂ fac ↦ e.injective\n    (by simp only [he, Equiv.apply_symm_apply, hx₂ g₁ g₂ h₁ h₂ fac, x₁])\n  have : ∀ (t₂ : P₂.obj (op X)),\n      x₂.IsAmalgamation t₂ ↔ x₁.IsAmalgamation (e.symm t₂) := fun t₂ ↦ by\n    simp only [FamilyOfElements.IsAmalgamation, x₁,\n      ← he', EmbeddingLike.apply_eq_iff_eq]\n  refine ⟨e (hP₁.amalgamate x₁ hx₁), ?_, ?_⟩\n  · dsimp\n    simp only [this, Equiv.symm_apply_apply]\n    exact IsSheafFor.isAmalgamation hP₁ hx₁\n  · intro t₂ ht₂\n    refine e.symm.injective ?_\n    simp only [Equiv.symm_apply_apply]\n    exact hP₁.isSeparatedFor x₁ _ _ (by simpa only [this] using ht₂)\n      (IsSheafFor.isAmalgamation hP₁ hx₁)\n\n"}
{"name":"CategoryTheory.Presieve.isSheafFor_iso","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nP' : CategoryTheory.Functor (Opposite C) (Type w)\ni : CategoryTheory.Iso P P'\nhP : CategoryTheory.Presieve.IsSheafFor P R\n⊢ CategoryTheory.Presieve.IsSheafFor P' R","decl":"/-- If `P` is a sheaf for `S`, and it is iso to `P'`, then `P'` is a sheaf for `S`. This shows that\n\"being a sheaf for a presieve\" is a mathematical or hygienic property.\n-/\ntheorem isSheafFor_iso {P' : Cᵒᵖ ⥤ Type w} (i : P ≅ P') (hP : IsSheafFor P R) :\n    IsSheafFor P' R :=\n  isSheafFor_of_nat_equiv (fun X ↦ (i.app (op X)).toEquiv)\n    (fun _ _ f x ↦ congr_fun (i.hom.naturality f.op) x) hP\n\n"}
{"name":"CategoryTheory.Presieve.isSheafFor_subsieve_aux","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nS : CategoryTheory.Sieve X\nR : CategoryTheory.Presieve X\nh : LE.le S.arrows R\nhS : CategoryTheory.Presieve.IsSheafFor P S.arrows\ntrans : ∀ ⦃Y : C⦄ ⦃f : Quiver.Hom Y X⦄, R f → CategoryTheory.Presieve.IsSeparatedFor P (CategoryTheory.Sieve.pullback f S).arrows\n⊢ CategoryTheory.Presieve.IsSheafFor P R","decl":"/-- If a presieve `R` on `X` has a subsieve `S` such that:\n\n* `P` is a sheaf for `S`.\n* For every `f` in `R`, `P` is separated for the pullback of `S` along `f`,\n\nthen `P` is a sheaf for `R`.\n\nThis is closely related to [Elephant] C2.1.6(i).\n-/\ntheorem isSheafFor_subsieve_aux (P : Cᵒᵖ ⥤ Type w) {S : Sieve X} {R : Presieve X}\n    (h : (S : Presieve X) ≤ R) (hS : IsSheafFor P (S : Presieve X))\n    (trans : ∀ ⦃Y⦄ ⦃f : Y ⟶ X⦄, R f → IsSeparatedFor P (S.pullback f : Presieve Y)) :\n    IsSheafFor P R := by\n  rw [← isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor]\n  constructor\n  · intro x t₁ t₂ ht₁ ht₂\n    exact\n      hS.isSeparatedFor _ _ _ (isAmalgamation_restrict h x t₁ ht₁)\n        (isAmalgamation_restrict h x t₂ ht₂)\n  · intro x hx\n    use hS.amalgamate _ (hx.restrict h)\n    intro W j hj\n    apply (trans hj).ext\n    intro Y f hf\n    rw [← FunctorToTypes.map_comp_apply, ← op_comp, hS.valid_glue (hx.restrict h) _ hf,\n      FamilyOfElements.restrict, ← hx (𝟙 _) f (h _ hf) _ (id_comp _)]\n    simp\n\n"}
{"name":"CategoryTheory.Presieve.isSheafFor_subsieve","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nS : CategoryTheory.Sieve X\nR : CategoryTheory.Presieve X\nh : LE.le S.arrows R\ntrans : ∀ ⦃Y : C⦄ (f : Quiver.Hom Y X), CategoryTheory.Presieve.IsSheafFor P (CategoryTheory.Sieve.pullback f S).arrows\n⊢ CategoryTheory.Presieve.IsSheafFor P R","decl":"/--\nIf `P` is a sheaf for every pullback of the sieve `S`, then `P` is a sheaf for any presieve which\ncontains `S`.\nThis is closely related to [Elephant] C2.1.6.\n-/\ntheorem isSheafFor_subsieve (P : Cᵒᵖ ⥤ Type w) {S : Sieve X} {R : Presieve X}\n    (h : (S : Presieve X) ≤ R) (trans : ∀ ⦃Y⦄ (f : Y ⟶ X),\n      IsSheafFor P (S.pullback f : Presieve Y)) :\n    IsSheafFor P R :=\n  isSheafFor_subsieve_aux P h (by simpa using trans (𝟙 _)) fun _ f _ => (trans f).isSeparatedFor\n\n"}
{"name":"CategoryTheory.Presieve.FamilyOfElements.isAmalgamation_iff_ofArrows","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nB : C\nI : Type u_1\nX : I → C\nπ : (i : I) → Quiver.Hom (X i) B\nx : CategoryTheory.Presieve.FamilyOfElements P (CategoryTheory.Presieve.ofArrows X π)\nt : P.obj { unop := B }\n⊢ Iff (x.IsAmalgamation t) (∀ (i : I), Eq (P.map (π i).op t) (x (π i) ⋯))","decl":"lemma FamilyOfElements.isAmalgamation_iff_ofArrows (x : FamilyOfElements P (ofArrows X π))\n    (t : P.obj (op B)) :\n    x.IsAmalgamation t ↔ ∀ (i : I), P.map (π i).op t = x _ (ofArrows.mk i) :=\n  ⟨fun h i ↦ h _ (ofArrows.mk i), fun h _ f ⟨i⟩ ↦ h i⟩\n\n"}
{"name":"CategoryTheory.Presieve.Arrows.Compatible.exists_familyOfElements","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nB : C\nI : Type u_1\nX : I → C\nπ : (i : I) → Quiver.Hom (X i) B\nx : (i : I) → P.obj { unop := X i }\nhx : CategoryTheory.Presieve.Arrows.Compatible P π x\n⊢ Exists fun x' => ∀ (i : I), Eq (x' (π i) ⋯) (x i)","decl":"theorem exists_familyOfElements (hx : Compatible P π x) :\n    ∃ (x' : FamilyOfElements P (ofArrows X π)), ∀ (i : I), x' _ (ofArrows.mk i) = x i := by\n  choose i h h' using @ofArrows_surj _ _ _ _ _ π\n  exact ⟨fun Y f hf ↦ P.map (eqToHom (h f hf).symm).op (x _),\n    fun j ↦ (hx _ j (X j) _ (𝟙 _) <| by rw [← h', id_comp]).trans <| by simp⟩\n\n"}
{"name":"CategoryTheory.Presieve.Arrows.Compatible.familyOfElements_ofArrows_mk","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nB : C\nI : Type u_1\nX : I → C\nπ : (i : I) → Quiver.Hom (X i) B\nx : (i : I) → P.obj { unop := X i }\nhx : CategoryTheory.Presieve.Arrows.Compatible P π x\ni : I\n⊢ Eq (hx.familyOfElements (π i) ⋯) (x i)","decl":"@[simp]\ntheorem familyOfElements_ofArrows_mk (i : I) :\n    hx.familyOfElements _ (ofArrows.mk i) = x i :=\n  (exists_familyOfElements hx).choose_spec _\n\n"}
{"name":"CategoryTheory.Presieve.Arrows.Compatible.familyOfElements_compatible","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nB : C\nI : Type u_1\nX : I → C\nπ : (i : I) → Quiver.Hom (X i) B\nx : (i : I) → P.obj { unop := X i }\nhx : CategoryTheory.Presieve.Arrows.Compatible P π x\n⊢ hx.familyOfElements.Compatible","decl":"theorem familyOfElements_compatible : hx.familyOfElements.Compatible := by\n  rintro Y₁ Y₂ Z g₁ g₂ f₁ f₂ ⟨i⟩ ⟨j⟩ hgf\n  simp [hx i j Z g₁ g₂ hgf]\n\n"}
{"name":"CategoryTheory.Presieve.isSheafFor_arrows_iff","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nB : C\nI : Type u_1\nX : I → C\nπ : (i : I) → Quiver.Hom (X i) B\n⊢ Iff (CategoryTheory.Presieve.IsSheafFor P (CategoryTheory.Presieve.ofArrows X π)) (∀ (x : (i : I) → P.obj { unop := X i }), CategoryTheory.Presieve.Arrows.Compatible P π x → ExistsUnique fun t => ∀ (i : I), Eq (P.map (π i).op t) (x i))","decl":"theorem isSheafFor_arrows_iff : (ofArrows X π).IsSheafFor P ↔\n    (∀ (x : (i : I) → P.obj (op (X i))), Arrows.Compatible P π x →\n    ∃! t, ∀ i, P.map (π i).op t = x i) := by\n  refine ⟨fun h x hx ↦ ?_, fun h x hx ↦ ?_⟩\n  · obtain ⟨t, ht₁, ht₂⟩ := h _ hx.familyOfElements_compatible\n    refine ⟨t, fun i ↦ ?_, fun t' ht' ↦ ht₂ _ fun _ _ ⟨i⟩ ↦ ?_⟩\n    · rw [ht₁ _ (ofArrows.mk i), hx.familyOfElements_ofArrows_mk]\n    · rw [ht', hx.familyOfElements_ofArrows_mk]\n  · obtain ⟨t, hA, ht⟩ := h (fun i ↦ x (π i) (ofArrows.mk _))\n      (fun i j Z gi gj ↦ hx gi gj (ofArrows.mk _) (ofArrows.mk _))\n    exact ⟨t, fun Y f ⟨i⟩ ↦ hA i, fun y hy ↦ ht y (fun i ↦ hy (π i) (ofArrows.mk _))⟩\n\n"}
{"name":"CategoryTheory.Presieve.Arrows.pullbackCompatible_iff","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nB : C\nI : Type u_1\nX : I → C\nπ : (i : I) → Quiver.Hom (X i) B\ninst✝ : (CategoryTheory.Presieve.ofArrows X π).hasPullbacks\nx : (i : I) → P.obj { unop := X i }\n⊢ Iff (CategoryTheory.Presieve.Arrows.Compatible P π x) (CategoryTheory.Presieve.Arrows.PullbackCompatible P π x)","decl":"theorem Arrows.pullbackCompatible_iff (x : (i : I) → P.obj (op (X i))) :\n    Compatible P π x ↔ PullbackCompatible P π x := by\n  refine ⟨fun t i j ↦ ?_, fun t i j Z gi gj comm ↦ ?_⟩\n  · apply t\n    exact pullback.condition\n  · rw [← pullback.lift_fst _ _ comm, op_comp, FunctorToTypes.map_comp_apply, t i j,\n      ← FunctorToTypes.map_comp_apply, ← op_comp, pullback.lift_snd]\n\n"}
{"name":"CategoryTheory.Presieve.isSheafFor_arrows_iff_pullbacks","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nB : C\nI : Type u_1\nX : I → C\nπ : (i : I) → Quiver.Hom (X i) B\ninst✝ : (CategoryTheory.Presieve.ofArrows X π).hasPullbacks\n⊢ Iff (CategoryTheory.Presieve.IsSheafFor P (CategoryTheory.Presieve.ofArrows X π)) (∀ (x : (i : I) → P.obj { unop := X i }), CategoryTheory.Presieve.Arrows.PullbackCompatible P π x → ExistsUnique fun t => ∀ (i : I), Eq (P.map (π i).op t) (x i))","decl":"theorem isSheafFor_arrows_iff_pullbacks : (ofArrows X π).IsSheafFor P ↔\n    (∀ (x : (i : I) → P.obj (op (X i))), Arrows.PullbackCompatible P π x →\n    ∃! t, ∀ i, P.map (π i).op t = x i) := by\n  simp_rw [← Arrows.pullbackCompatible_iff, isSheafFor_arrows_iff]\n\n"}
