{"name":"CategoryTheory.Presieve.FamilyOfElements.map_apply","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP Q : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\np : CategoryTheory.Presieve.FamilyOfElements P R\nÏ† : Quiver.Hom P Q\nY : C\nf : Quiver.Hom Y X\nhf : R f\nâŠ¢ Eq (p.map Ï† f hf) (Ï†.app { unop := Y } (p f hf))","decl":"@[simp]\nlemma FamilyOfElements.map_apply\n    (p : FamilyOfElements P R) (Ï† : P âŸ¶ Q) {Y : C} (f : Y âŸ¶ X) (hf : R f) :\n    p.map Ï† f hf = Ï†.app _ (p f hf) := rfl\n\n"}
{"name":"CategoryTheory.Presieve.FamilyOfElements.restrict_map","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP Q : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\np : CategoryTheory.Presieve.FamilyOfElements P R\nÏ† : Quiver.Hom P Q\nR' : CategoryTheory.Presieve X\nh : LE.le R' R\nâŠ¢ Eq ((CategoryTheory.Presieve.FamilyOfElements.restrict h p).map Ï†) (CategoryTheory.Presieve.FamilyOfElements.restrict h (p.map Ï†))","decl":"lemma FamilyOfElements.restrict_map\n    (p : FamilyOfElements P R) (Ï† : P âŸ¶ Q) {R' : Presieve X} (h : R' â‰¤ R) :\n    (p.restrict h).map Ï† = (p.map Ï†).restrict h := rfl\n\n"}
{"name":"CategoryTheory.Presieve.pullbackCompatible_iff","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nx : CategoryTheory.Presieve.FamilyOfElements P R\ninstâœ : R.hasPullbacks\nâŠ¢ Iff x.Compatible x.PullbackCompatible","decl":"theorem pullbackCompatible_iff (x : FamilyOfElements P R) [R.hasPullbacks] :\n    x.Compatible â†” x.PullbackCompatible := by\n  constructor\n  Â· intro t Yâ‚ Yâ‚‚ fâ‚ fâ‚‚ hfâ‚ hfâ‚‚\n    apply t\n    haveI := hasPullbacks.has_pullbacks hfâ‚ hfâ‚‚\n    apply pullback.condition\n  Â· intro t Yâ‚ Yâ‚‚ Z gâ‚ gâ‚‚ fâ‚ fâ‚‚ hfâ‚ hfâ‚‚ comm\n    haveI := hasPullbacks.has_pullbacks hfâ‚ hfâ‚‚\n    rw [â† pullback.lift_fst _ _ comm, op_comp, FunctorToTypes.map_comp_apply, t hfâ‚ hfâ‚‚,\n      â† FunctorToTypes.map_comp_apply, â† op_comp, pullback.lift_snd]\n\n"}
{"name":"CategoryTheory.Presieve.FamilyOfElements.Compatible.restrict","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nRâ‚ Râ‚‚ : CategoryTheory.Presieve X\nh : LE.le Râ‚ Râ‚‚\nx : CategoryTheory.Presieve.FamilyOfElements P Râ‚‚\naâœ : x.Compatible\nâŠ¢ (CategoryTheory.Presieve.FamilyOfElements.restrict h x).Compatible","decl":"/-- The restriction of a compatible family is compatible. -/\ntheorem FamilyOfElements.Compatible.restrict {Râ‚ Râ‚‚ : Presieve X} (h : Râ‚ â‰¤ Râ‚‚)\n    {x : FamilyOfElements P Râ‚‚} : x.Compatible â†’ (x.restrict h).Compatible :=\n  fun q _ _ _ gâ‚ gâ‚‚ _ _ hâ‚ hâ‚‚ comm => q gâ‚ gâ‚‚ (h _ hâ‚) (h _ hâ‚‚) comm\n\n"}
{"name":"CategoryTheory.Presieve.FamilyOfElements.Compatible.sieveExtend","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nx : CategoryTheory.Presieve.FamilyOfElements P R\nhx : x.Compatible\nâŠ¢ x.sieveExtend.Compatible","decl":"/-- The extension of a compatible family to the generated sieve is compatible. -/\ntheorem FamilyOfElements.Compatible.sieveExtend {x : FamilyOfElements P R} (hx : x.Compatible) :\n    x.sieveExtend.Compatible := by\n  intro _ _ _ _ _ _ _ hâ‚ hâ‚‚ comm\n  iterate 2 erw [â† FunctorToTypes.map_comp_apply]; rw [â† op_comp]\n  apply hx\n  simp [comm, hâ‚.choose_spec.choose_spec.choose_spec.2, hâ‚‚.choose_spec.choose_spec.choose_spec.2]\n\n"}
{"name":"CategoryTheory.Presieve.extend_agrees","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX Y : C\nR : CategoryTheory.Presieve X\nx : CategoryTheory.Presieve.FamilyOfElements P R\nt : x.Compatible\nf : Quiver.Hom Y X\nhf : R f\nâŠ¢ Eq (x.sieveExtend f â‹¯) (x f hf)","decl":"/-- The extension of a family agrees with the original family. -/\ntheorem extend_agrees {x : FamilyOfElements P R} (t : x.Compatible) {f : Y âŸ¶ X} (hf : R f) :\n    x.sieveExtend f (le_generate R Y hf) = x f hf := by\n  have h := (le_generate R Y hf).choose_spec\n  unfold FamilyOfElements.sieveExtend\n  rw [t h.choose (ğŸ™ _) _ hf _]\n  Â· simp\n  Â· rw [id_comp]\n    exact h.choose_spec.choose_spec.2\n\n"}
{"name":"CategoryTheory.Presieve.restrict_extend","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nx : CategoryTheory.Presieve.FamilyOfElements P R\nt : x.Compatible\nâŠ¢ Eq (CategoryTheory.Presieve.FamilyOfElements.restrict â‹¯ x.sieveExtend) x","decl":"/-- The restriction of an extension is the original. -/\n@[simp]\ntheorem restrict_extend {x : FamilyOfElements P R} (t : x.Compatible) :\n    x.sieveExtend.restrict (le_generate R) = x := by\n  funext Y f hf\n  exact extend_agrees t hf\n\n"}
{"name":"CategoryTheory.Presieve.compatible_iff_sieveCompatible","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nS : CategoryTheory.Sieve X\nx : CategoryTheory.Presieve.FamilyOfElements P S.arrows\nâŠ¢ Iff x.Compatible x.SieveCompatible","decl":"theorem compatible_iff_sieveCompatible (x : FamilyOfElements P (S : Presieve X)) :\n    x.Compatible â†” x.SieveCompatible := by\n  constructor\n  Â· intro h Y Z f g hf\n    simpa using h (ğŸ™ _) g (S.downward_closed hf g) hf (id_comp _)\n  Â· intro h Yâ‚ Yâ‚‚ Z gâ‚ gâ‚‚ fâ‚ fâ‚‚ hâ‚ hâ‚‚ k\n    simp_rw [â† h fâ‚ gâ‚ hâ‚, â† h fâ‚‚ gâ‚‚ hâ‚‚]\n    congr\n\n"}
{"name":"CategoryTheory.Presieve.FamilyOfElements.Compatible.to_sieveCompatible","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nS : CategoryTheory.Sieve X\nx : CategoryTheory.Presieve.FamilyOfElements P S.arrows\nt : x.Compatible\nâŠ¢ x.SieveCompatible","decl":"theorem FamilyOfElements.Compatible.to_sieveCompatible {x : FamilyOfElements P (S : Presieve X)}\n    (t : x.Compatible) : x.SieveCompatible :=\n  (compatible_iff_sieveCompatible x).1 t\n\n"}
{"name":"CategoryTheory.Presieve.extend_restrict","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nx : CategoryTheory.Presieve.FamilyOfElements P (CategoryTheory.Sieve.generate R).arrows\nt : x.Compatible\nâŠ¢ Eq (CategoryTheory.Presieve.FamilyOfElements.restrict â‹¯ x).sieveExtend x","decl":"/--\nGiven a family of elements `x` for the sieve `S` generated by a presieve `R`, if `x` is restricted\nto `R` and then extended back up to `S`, the resulting extension equals `x`.\n-/\n@[simp]\ntheorem extend_restrict {x : FamilyOfElements P (generate R).arrows} (t : x.Compatible) :\n    (x.restrict (le_generate R)).sieveExtend = x := by\n  rw [compatible_iff_sieveCompatible] at t\n  funext _ _ h\n  apply (t _ _ _).symm.trans\n  congr\n  exact h.choose_spec.choose_spec.choose_spec.2\n\n"}
{"name":"CategoryTheory.Presieve.restrict_inj","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nxâ‚ xâ‚‚ : CategoryTheory.Presieve.FamilyOfElements P (CategoryTheory.Sieve.generate R).arrows\ntâ‚ : xâ‚.Compatible\ntâ‚‚ : xâ‚‚.Compatible\naâœ : Eq (CategoryTheory.Presieve.FamilyOfElements.restrict â‹¯ xâ‚) (CategoryTheory.Presieve.FamilyOfElements.restrict â‹¯ xâ‚‚)\nâŠ¢ Eq xâ‚ xâ‚‚","decl":"/--\nTwo compatible families on the sieve generated by a presieve `R` are equal if and only if they are\nequal when restricted to `R`.\n-/\ntheorem restrict_inj {xâ‚ xâ‚‚ : FamilyOfElements P (generate R).arrows} (tâ‚ : xâ‚.Compatible)\n    (tâ‚‚ : xâ‚‚.Compatible) : xâ‚.restrict (le_generate R) = xâ‚‚.restrict (le_generate R) â†’ xâ‚ = xâ‚‚ :=\n  fun h => by\n  rw [â† extend_restrict tâ‚, â† extend_restrict tâ‚‚]\n  -- Porting note: congr fails to make progress\n  apply congr_arg\n  exact h\n\n"}
{"name":"CategoryTheory.Presieve.compatibleEquivGenerateSieveCompatible_symm_apply_coe","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nx : Subtype fun x => x.Compatible\nâŠ¢ Eq (â†‘(CategoryTheory.Presieve.compatibleEquivGenerateSieveCompatible.symm x)) (CategoryTheory.Presieve.FamilyOfElements.restrict â‹¯ â†‘x)","decl":"/-- Compatible families of elements for a presheaf of types `P` and a presieve `R`\n    are in 1-1 correspondence with compatible families for the same presheaf and\n    the sieve generated by `R`, through extension and restriction. -/\n@[simps]\nnoncomputable def compatibleEquivGenerateSieveCompatible :\n    { x : FamilyOfElements P R // x.Compatible } â‰ƒ\n      { x : FamilyOfElements P (generate R : Presieve X) // x.Compatible } where\n  toFun x := âŸ¨x.1.sieveExtend, x.2.sieveExtendâŸ©\n  invFun x := âŸ¨x.1.restrict (le_generate R), x.2.restrict _âŸ©\n  left_inv x := Subtype.ext (restrict_extend x.2)\n  right_inv x := Subtype.ext (extend_restrict x.2)\n\n"}
{"name":"CategoryTheory.Presieve.compatibleEquivGenerateSieveCompatible_apply_coe","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nx : Subtype fun x => x.Compatible\nâŠ¢ Eq (â†‘(CategoryTheory.Presieve.compatibleEquivGenerateSieveCompatible x)) (â†‘x).sieveExtend","decl":"/-- Compatible families of elements for a presheaf of types `P` and a presieve `R`\n    are in 1-1 correspondence with compatible families for the same presheaf and\n    the sieve generated by `R`, through extension and restriction. -/\n@[simps]\nnoncomputable def compatibleEquivGenerateSieveCompatible :\n    { x : FamilyOfElements P R // x.Compatible } â‰ƒ\n      { x : FamilyOfElements P (generate R : Presieve X) // x.Compatible } where\n  toFun x := âŸ¨x.1.sieveExtend, x.2.sieveExtendâŸ©\n  invFun x := âŸ¨x.1.restrict (le_generate R), x.2.restrict _âŸ©\n  left_inv x := Subtype.ext (restrict_extend x.2)\n  right_inv x := Subtype.ext (extend_restrict x.2)\n\n"}
{"name":"CategoryTheory.Presieve.FamilyOfElements.comp_of_compatible","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX Y : C\nS : CategoryTheory.Sieve X\nx : CategoryTheory.Presieve.FamilyOfElements P S.arrows\nt : x.Compatible\nf : Quiver.Hom Y X\nhf : S.arrows f\nZ : C\ng : Quiver.Hom Z Y\nâŠ¢ Eq (x (CategoryTheory.CategoryStruct.comp g f) â‹¯) (P.map g.op (x f hf))","decl":"theorem FamilyOfElements.comp_of_compatible (S : Sieve X) {x : FamilyOfElements P S}\n    (t : x.Compatible) {f : Y âŸ¶ X} (hf : S f) {Z} (g : Z âŸ¶ Y) :\n    x (g â‰« f) (S.downward_closed hf g) = P.map g.op (x f hf) := by\n  simpa using t (ğŸ™ _) g (S.downward_closed hf g) hf (id_comp _)\n\n"}
{"name":"CategoryTheory.Presieve.FamilyOfElements.Compatible.functorPullback","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor D C\nZ : D\nT : CategoryTheory.Presieve (F.obj Z)\nx : CategoryTheory.Presieve.FamilyOfElements P T\nh : x.Compatible\nâŠ¢ (CategoryTheory.Presieve.FamilyOfElements.functorPullback F x).Compatible","decl":"theorem FamilyOfElements.Compatible.functorPullback (h : x.Compatible) :\n    (x.functorPullback F).Compatible := by\n  intro Zâ‚ Zâ‚‚ W gâ‚ gâ‚‚ fâ‚ fâ‚‚ hâ‚ hâ‚‚ eq\n  exact h (F.map gâ‚) (F.map gâ‚‚) hâ‚ hâ‚‚ (by simp only [â† F.map_comp, eq])\n\n"}
{"name":"CategoryTheory.Presieve.FamilyOfElements.Compatible.pullback","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX Y : C\nS : CategoryTheory.Sieve X\nf : Quiver.Hom Y X\nx : CategoryTheory.Presieve.FamilyOfElements P S.arrows\nh : x.Compatible\nâŠ¢ (CategoryTheory.Presieve.FamilyOfElements.pullback f x).Compatible","decl":"theorem FamilyOfElements.Compatible.pullback (f : Y âŸ¶ X) {x : FamilyOfElements P S.arrows}\n    (h : x.Compatible) : (x.pullback f).Compatible := by\n  simp only [compatible_iff_sieveCompatible] at h âŠ¢\n  intro W Z fâ‚ fâ‚‚ hf\n  unfold FamilyOfElements.pullback\n  rw [â† h (fâ‚ â‰« f) fâ‚‚ hf]\n  congr 1\n  simp only [assoc]\n\n"}
{"name":"CategoryTheory.Presieve.FamilyOfElements.compPresheafMap_id","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nx : CategoryTheory.Presieve.FamilyOfElements P R\nâŠ¢ Eq (CategoryTheory.Presieve.FamilyOfElements.compPresheafMap (CategoryTheory.CategoryStruct.id P) x) x","decl":"@[simp]\ntheorem FamilyOfElements.compPresheafMap_id (x : FamilyOfElements P R) :\n    x.compPresheafMap (ğŸ™ P) = x :=\n  rfl\n\n"}
{"name":"CategoryTheory.Presieve.FamilyOfElements.compPresheafMap_comp","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP Q U : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nx : CategoryTheory.Presieve.FamilyOfElements P R\nf : Quiver.Hom P Q\ng : Quiver.Hom Q U\nâŠ¢ Eq (CategoryTheory.Presieve.FamilyOfElements.compPresheafMap g (CategoryTheory.Presieve.FamilyOfElements.compPresheafMap f x)) (CategoryTheory.Presieve.FamilyOfElements.compPresheafMap (CategoryTheory.CategoryStruct.comp f g) x)","decl":"@[simp]\ntheorem FamilyOfElements.compPresheafMap_comp (x : FamilyOfElements P R) (f : P âŸ¶ Q)\n    (g : Q âŸ¶ U) : (x.compPresheafMap f).compPresheafMap g = x.compPresheafMap (f â‰« g) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Presieve.FamilyOfElements.Compatible.compPresheafMap","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP Q : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nf : Quiver.Hom P Q\nx : CategoryTheory.Presieve.FamilyOfElements P R\nh : x.Compatible\nâŠ¢ (CategoryTheory.Presieve.FamilyOfElements.compPresheafMap f x).Compatible","decl":"theorem FamilyOfElements.Compatible.compPresheafMap (f : P âŸ¶ Q) {x : FamilyOfElements P R}\n    (h : x.Compatible) : (x.compPresheafMap f).Compatible := by\n  intro Zâ‚ Zâ‚‚ W gâ‚ gâ‚‚ fâ‚ fâ‚‚ hâ‚ hâ‚‚ eq\n  unfold FamilyOfElements.compPresheafMap\n  rwa [â† FunctorToTypes.naturality, â† FunctorToTypes.naturality, h]\n\n"}
{"name":"CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation.compPresheafMap","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP Q : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nx : CategoryTheory.Presieve.FamilyOfElements P R\nt : P.obj { unop := X }\nf : Quiver.Hom P Q\nh : x.IsAmalgamation t\nâŠ¢ (CategoryTheory.Presieve.FamilyOfElements.compPresheafMap f x).IsAmalgamation (f.app { unop := X } t)","decl":"theorem FamilyOfElements.IsAmalgamation.compPresheafMap {x : FamilyOfElements P R} {t} (f : P âŸ¶ Q)\n    (h : x.IsAmalgamation t) : (x.compPresheafMap f).IsAmalgamation (f.app (op X) t) := by\n  intro Y g hg\n  dsimp [FamilyOfElements.compPresheafMap]\n  change (f.app _ â‰« Q.map _) _ = _\n  rw [â† f.naturality, types_comp_apply, h g hg]\n\n"}
{"name":"CategoryTheory.Presieve.is_compatible_of_exists_amalgamation","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nx : CategoryTheory.Presieve.FamilyOfElements P R\nh : Exists fun t => x.IsAmalgamation t\nâŠ¢ x.Compatible","decl":"theorem is_compatible_of_exists_amalgamation (x : FamilyOfElements P R)\n    (h : âˆƒ t, x.IsAmalgamation t) : x.Compatible := by\n  cases' h with t ht\n  intro Yâ‚ Yâ‚‚ Z gâ‚ gâ‚‚ fâ‚ fâ‚‚ hâ‚ hâ‚‚ comm\n  rw [â† ht _ hâ‚, â† ht _ hâ‚‚, â† FunctorToTypes.map_comp_apply, â† op_comp, comm]\n  simp\n\n"}
{"name":"CategoryTheory.Presieve.isAmalgamation_restrict","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nRâ‚ Râ‚‚ : CategoryTheory.Presieve X\nh : LE.le Râ‚ Râ‚‚\nx : CategoryTheory.Presieve.FamilyOfElements P Râ‚‚\nt : P.obj { unop := X }\nht : x.IsAmalgamation t\nâŠ¢ (CategoryTheory.Presieve.FamilyOfElements.restrict h x).IsAmalgamation t","decl":"theorem isAmalgamation_restrict {Râ‚ Râ‚‚ : Presieve X} (h : Râ‚ â‰¤ Râ‚‚) (x : FamilyOfElements P Râ‚‚)\n    (t : P.obj (op X)) (ht : x.IsAmalgamation t) : (x.restrict h).IsAmalgamation t := fun Y f hf =>\n  ht f (h Y hf)\n\n"}
{"name":"CategoryTheory.Presieve.isAmalgamation_sieveExtend","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nx : CategoryTheory.Presieve.FamilyOfElements P R\nt : P.obj { unop := X }\nht : x.IsAmalgamation t\nâŠ¢ x.sieveExtend.IsAmalgamation t","decl":"theorem isAmalgamation_sieveExtend {R : Presieve X} (x : FamilyOfElements P R) (t : P.obj (op X))\n    (ht : x.IsAmalgamation t) : x.sieveExtend.IsAmalgamation t := by\n  intro Y f hf\n  dsimp [FamilyOfElements.sieveExtend]\n  rw [â† ht _, â† FunctorToTypes.map_comp_apply, â† op_comp, hf.choose_spec.choose_spec.choose_spec.2]\n\n"}
{"name":"CategoryTheory.Presieve.IsSeparatedFor.ext","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nhR : CategoryTheory.Presieve.IsSeparatedFor P R\ntâ‚ tâ‚‚ : P.obj { unop := X }\nh : âˆ€ â¦ƒY : Câ¦„ â¦ƒf : Quiver.Hom Y Xâ¦„, R f â†’ Eq (P.map f.op tâ‚) (P.map f.op tâ‚‚)\nâŠ¢ Eq tâ‚ tâ‚‚","decl":"theorem IsSeparatedFor.ext {R : Presieve X} (hR : IsSeparatedFor P R) {tâ‚ tâ‚‚ : P.obj (op X)}\n    (h : âˆ€ â¦ƒYâ¦„ â¦ƒf : Y âŸ¶ Xâ¦„ (_ : R f), P.map f.op tâ‚ = P.map f.op tâ‚‚) : tâ‚ = tâ‚‚ :=\n  hR (fun _ f _ => P.map f.op tâ‚‚) tâ‚ tâ‚‚ (fun _ _ hf => h hf) fun _ _ _ => rfl\n\n"}
{"name":"CategoryTheory.Presieve.isSeparatedFor_iff_generate","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nâŠ¢ Iff (CategoryTheory.Presieve.IsSeparatedFor P R) (CategoryTheory.Presieve.IsSeparatedFor P (CategoryTheory.Sieve.generate R).arrows)","decl":"theorem isSeparatedFor_iff_generate :\n    IsSeparatedFor P R â†” IsSeparatedFor P (generate R : Presieve X) := by\n  constructor\n  Â· intro h x tâ‚ tâ‚‚ htâ‚ htâ‚‚\n    apply h (x.restrict (le_generate R)) tâ‚ tâ‚‚ _ _\n    Â· exact isAmalgamation_restrict _ x tâ‚ htâ‚\n    Â· exact isAmalgamation_restrict _ x tâ‚‚ htâ‚‚\n  Â· intro h x tâ‚ tâ‚‚ htâ‚ htâ‚‚\n    apply h x.sieveExtend\n    Â· exact isAmalgamation_sieveExtend x tâ‚ htâ‚\n    Â· exact isAmalgamation_sieveExtend x tâ‚‚ htâ‚‚\n\n"}
{"name":"CategoryTheory.Presieve.isSeparatedFor_top","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nX : C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nâŠ¢ CategoryTheory.Presieve.IsSeparatedFor P Top.top","decl":"theorem isSeparatedFor_top (P : Cáµ’áµ– â¥¤ Type w) : IsSeparatedFor P (âŠ¤ : Presieve X) :=\n  fun x tâ‚ tâ‚‚ hâ‚ hâ‚‚ => by\n  have qâ‚ := hâ‚ (ğŸ™ X) (by tauto)\n  have qâ‚‚ := hâ‚‚ (ğŸ™ X) (by tauto)\n  simp only [op_id, FunctorToTypes.map_id_apply] at qâ‚ qâ‚‚\n  rw [qâ‚, qâ‚‚]\n\n"}
{"name":"CategoryTheory.Presieve.extension_iff_amalgamation","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nX : C\nS : CategoryTheory.Sieve X\nP : CategoryTheory.Functor (Opposite C) (Type vâ‚)\nx : Quiver.Hom S.functor P\ng : Quiver.Hom (CategoryTheory.yoneda.obj X) P\nâŠ¢ Iff (Eq (CategoryTheory.CategoryStruct.comp S.functorInclusion g) x) ((â†‘(CategoryTheory.Presieve.natTransEquivCompatibleFamily x)).IsAmalgamation (CategoryTheory.yonedaEquiv g))","decl":"/-- (Implementation). A lemma useful to prove `isSheafFor_iff_yonedaSheafCondition`. -/\ntheorem extension_iff_amalgamation {P : Cáµ’áµ– â¥¤ Type vâ‚} (x : S.functor âŸ¶ P) (g : yoneda.obj X âŸ¶ P) :\n    S.functorInclusion â‰« g = x â†”\n      (natTransEquivCompatibleFamily x).1.IsAmalgamation (yonedaEquiv g) := by\n  change _ â†” âˆ€ â¦ƒY : Câ¦„ (f : Y âŸ¶ X) (h : S f), P.map f.op (yonedaEquiv g) = x.app (op Y) âŸ¨f, hâŸ©\n  constructor\n  Â· rintro rfl Y f hf\n    rw [yonedaEquiv_naturality]\n    dsimp\n    simp [yonedaEquiv_apply]\n  -- See note [dsimp, simp].\n  Â· intro h\n    ext Y âŸ¨f, hfâŸ©\n    convert h f hf\n    rw [yonedaEquiv_naturality]\n    dsimp [yonedaEquiv]\n    simp\n\n"}
{"name":"CategoryTheory.Presieve.isSheafFor_iff_yonedaSheafCondition","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nX : C\nS : CategoryTheory.Sieve X\nP : CategoryTheory.Functor (Opposite C) (Type vâ‚)\nâŠ¢ Iff (CategoryTheory.Presieve.IsSheafFor P S.arrows) (CategoryTheory.Presieve.YonedaSheafCondition P S)","decl":"/-- The yoneda version of the sheaf condition is equivalent to the sheaf condition.\n\nC2.1.4 of [Elephant].\n-/\ntheorem isSheafFor_iff_yonedaSheafCondition {P : Cáµ’áµ– â¥¤ Type vâ‚} :\n    IsSheafFor P (S : Presieve X) â†” YonedaSheafCondition P S := by\n  rw [IsSheafFor, YonedaSheafCondition]\n  simp_rw [extension_iff_amalgamation]\n  rw [Equiv.forall_congr_left natTransEquivCompatibleFamily]\n  rw [Subtype.forall]\n  exact forallâ‚‚_congr fun x hx â†¦ by simp [Equiv.existsUnique_congr_right]\n\n"}
{"name":"CategoryTheory.Presieve.IsSheafFor.functorInclusion_comp_extend_assoc","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nX : C\nS : CategoryTheory.Sieve X\nP : CategoryTheory.Functor (Opposite C) (Type vâ‚)\nhâœ : CategoryTheory.Presieve.IsSheafFor P S.arrows\nf : Quiver.Hom S.functor P\nZ : CategoryTheory.Functor (Opposite C) (Type vâ‚)\nh : Quiver.Hom P Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp S.functorInclusion (CategoryTheory.CategoryStruct.comp (hâœ.extend f) h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"/--\nShow that the extension of `f : S.functor âŸ¶ P` to all of `yoneda.obj X` is in fact an extension, ie\nthat the triangle below commutes, provided `P` is a sheaf for `S`\n\n      f\n   S  â†’  P\n   â†“  â†—\n   yX\n\n-/\n@[reassoc (attr := simp)]\ntheorem IsSheafFor.functorInclusion_comp_extend {P : Cáµ’áµ– â¥¤ Type vâ‚} (h : IsSheafFor P S.arrows)\n    (f : S.functor âŸ¶ P) : S.functorInclusion â‰« h.extend f = f :=\n  (isSheafFor_iff_yonedaSheafCondition.1 h f).exists.choose_spec\n\n"}
{"name":"CategoryTheory.Presieve.IsSheafFor.functorInclusion_comp_extend","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nX : C\nS : CategoryTheory.Sieve X\nP : CategoryTheory.Functor (Opposite C) (Type vâ‚)\nh : CategoryTheory.Presieve.IsSheafFor P S.arrows\nf : Quiver.Hom S.functor P\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp S.functorInclusion (h.extend f)) f","decl":"/--\nShow that the extension of `f : S.functor âŸ¶ P` to all of `yoneda.obj X` is in fact an extension, ie\nthat the triangle below commutes, provided `P` is a sheaf for `S`\n\n      f\n   S  â†’  P\n   â†“  â†—\n   yX\n\n-/\n@[reassoc (attr := simp)]\ntheorem IsSheafFor.functorInclusion_comp_extend {P : Cáµ’áµ– â¥¤ Type vâ‚} (h : IsSheafFor P S.arrows)\n    (f : S.functor âŸ¶ P) : S.functorInclusion â‰« h.extend f = f :=\n  (isSheafFor_iff_yonedaSheafCondition.1 h f).exists.choose_spec\n\n"}
{"name":"CategoryTheory.Presieve.IsSheafFor.unique_extend","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nX : C\nS : CategoryTheory.Sieve X\nP : CategoryTheory.Functor (Opposite C) (Type vâ‚)\nh : CategoryTheory.Presieve.IsSheafFor P S.arrows\nf : Quiver.Hom S.functor P\nt : Quiver.Hom (CategoryTheory.yoneda.obj X) P\nht : Eq (CategoryTheory.CategoryStruct.comp S.functorInclusion t) f\nâŠ¢ Eq t (h.extend f)","decl":"/-- The extension of `f` to `yoneda.obj X` is unique. -/\ntheorem IsSheafFor.unique_extend {P : Cáµ’áµ– â¥¤ Type vâ‚} (h : IsSheafFor P S.arrows) {f : S.functor âŸ¶ P}\n    (t : yoneda.obj X âŸ¶ P) (ht : S.functorInclusion â‰« t = f) : t = h.extend f :=\n  (isSheafFor_iff_yonedaSheafCondition.1 h f).unique ht (h.functorInclusion_comp_extend f)\n\n"}
{"name":"CategoryTheory.Presieve.IsSheafFor.hom_ext","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nX : C\nS : CategoryTheory.Sieve X\nP : CategoryTheory.Functor (Opposite C) (Type vâ‚)\nh : CategoryTheory.Presieve.IsSheafFor P S.arrows\ntâ‚ tâ‚‚ : Quiver.Hom (CategoryTheory.yoneda.obj X) P\nht : Eq (CategoryTheory.CategoryStruct.comp S.functorInclusion tâ‚) (CategoryTheory.CategoryStruct.comp S.functorInclusion tâ‚‚)\nâŠ¢ Eq tâ‚ tâ‚‚","decl":"/--\nIf `P` is a sheaf for the sieve `S` on `X`, then if two natural transformations from `yoneda.obj X`\nto `P` agree when restricted to the subfunctor given by `S`, they are equal.\n-/\ntheorem IsSheafFor.hom_ext {P : Cáµ’áµ– â¥¤ Type vâ‚} (h : IsSheafFor P (S : Presieve X))\n    (tâ‚ tâ‚‚ : yoneda.obj X âŸ¶ P) (ht : S.functorInclusion â‰« tâ‚ = S.functorInclusion â‰« tâ‚‚) :\n    tâ‚ = tâ‚‚ :=\n  (h.unique_extend tâ‚ ht).trans (h.unique_extend tâ‚‚ rfl).symm\n\n"}
{"name":"CategoryTheory.Presieve.isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nâŠ¢ Iff (And (CategoryTheory.Presieve.IsSeparatedFor P R) (âˆ€ (x : CategoryTheory.Presieve.FamilyOfElements P R), x.Compatible â†’ Exists fun t => x.IsAmalgamation t)) (CategoryTheory.Presieve.IsSheafFor P R)","decl":"/-- `P` is a sheaf for `R` iff it is separated for `R` and there exists an amalgamation. -/\ntheorem isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor :\n    (IsSeparatedFor P R âˆ§ âˆ€ x : FamilyOfElements P R, x.Compatible â†’ âˆƒ t, x.IsAmalgamation t) â†”\n      IsSheafFor P R := by\n  rw [IsSeparatedFor, â† forall_and]\n  apply forall_congr'\n  intro x\n  constructor\n  Â· intro z hx\n    exact existsUnique_of_exists_of_unique (z.2 hx) z.1\n  Â· intro h\n    refine âŸ¨?_, ExistsUnique.exists âˆ˜ hâŸ©\n    intro tâ‚ tâ‚‚ htâ‚ htâ‚‚\n    apply (h _).unique htâ‚ htâ‚‚\n    exact is_compatible_of_exists_amalgamation x âŸ¨_, htâ‚‚âŸ©\n\n"}
{"name":"CategoryTheory.Presieve.IsSeparatedFor.isSheafFor","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nt : CategoryTheory.Presieve.IsSeparatedFor P R\naâœ : âˆ€ (x : CategoryTheory.Presieve.FamilyOfElements P R), x.Compatible â†’ Exists fun t => x.IsAmalgamation t\nâŠ¢ CategoryTheory.Presieve.IsSheafFor P R","decl":"/-- If `P` is separated for `R` and every family has an amalgamation, then `P` is a sheaf for `R`.\n-/\ntheorem IsSeparatedFor.isSheafFor (t : IsSeparatedFor P R) :\n    (âˆ€ x : FamilyOfElements P R, x.Compatible â†’ âˆƒ t, x.IsAmalgamation t) â†’ IsSheafFor P R := by\n  rw [â† isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor]\n  exact And.intro t\n\n"}
{"name":"CategoryTheory.Presieve.IsSheafFor.isSeparatedFor","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\naâœ : CategoryTheory.Presieve.IsSheafFor P R\nâŠ¢ CategoryTheory.Presieve.IsSeparatedFor P R","decl":"/-- If `P` is a sheaf for `R`, it is separated for `R`. -/\ntheorem IsSheafFor.isSeparatedFor : IsSheafFor P R â†’ IsSeparatedFor P R := fun q =>\n  (isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor.2 q).1\n\n"}
{"name":"CategoryTheory.Presieve.IsSheafFor.isAmalgamation","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nt : CategoryTheory.Presieve.IsSheafFor P R\nx : CategoryTheory.Presieve.FamilyOfElements P R\nhx : x.Compatible\nâŠ¢ x.IsAmalgamation (t.amalgamate x hx)","decl":"theorem IsSheafFor.isAmalgamation (t : IsSheafFor P R) {x : FamilyOfElements P R}\n    (hx : x.Compatible) : x.IsAmalgamation (t.amalgamate x hx) :=\n  (t x hx).exists.choose_spec\n\n"}
{"name":"CategoryTheory.Presieve.IsSheafFor.valid_glue","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX Y : C\nR : CategoryTheory.Presieve X\nt : CategoryTheory.Presieve.IsSheafFor P R\nx : CategoryTheory.Presieve.FamilyOfElements P R\nhx : x.Compatible\nf : Quiver.Hom Y X\nHf : R f\nâŠ¢ Eq (P.map f.op (t.amalgamate x hx)) (x f Hf)","decl":"@[simp]\ntheorem IsSheafFor.valid_glue (t : IsSheafFor P R) {x : FamilyOfElements P R} (hx : x.Compatible)\n    (f : Y âŸ¶ X) (Hf : R f) : P.map f.op (t.amalgamate x hx) = x f Hf :=\n  t.isAmalgamation hx f Hf\n\n"}
{"name":"CategoryTheory.Presieve.isSheafFor_iff_generate","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nâŠ¢ Iff (CategoryTheory.Presieve.IsSheafFor P R) (CategoryTheory.Presieve.IsSheafFor P (CategoryTheory.Sieve.generate R).arrows)","decl":"/-- C2.1.3 in [Elephant] -/\ntheorem isSheafFor_iff_generate (R : Presieve X) :\n    IsSheafFor P R â†” IsSheafFor P (generate R : Presieve X) := by\n  rw [â† isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor]\n  rw [â† isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor]\n  rw [â† isSeparatedFor_iff_generate]\n  apply and_congr (Iff.refl _)\n  constructor\n  Â· intro q x hx\n    apply Exists.imp _ (q _ (hx.restrict (le_generate R)))\n    intro t ht\n    simpa [hx] using isAmalgamation_sieveExtend _ _ ht\n  Â· intro q x hx\n    apply Exists.imp _ (q _ hx.sieveExtend)\n    intro t ht\n    simpa [hx] using isAmalgamation_restrict (le_generate R) _ _ ht\n\n"}
{"name":"CategoryTheory.Presieve.isSheafFor_singleton_iso","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nX : C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nâŠ¢ CategoryTheory.Presieve.IsSheafFor P (CategoryTheory.Presieve.singleton (CategoryTheory.CategoryStruct.id X))","decl":"/-- Every presheaf is a sheaf for the family {ğŸ™ X}.\n\n[Elephant] C2.1.5(i)\n-/\ntheorem isSheafFor_singleton_iso (P : Cáµ’áµ– â¥¤ Type w) : IsSheafFor P (Presieve.singleton (ğŸ™ X)) := by\n  intro x _\n  refine âŸ¨x _ (Presieve.singleton_self _), ?_, ?_âŸ©\n  Â· rintro _ _ âŸ¨rfl, rflâŸ©\n    simp\n  Â· intro t ht\n    simpa using ht _ (Presieve.singleton_self _)\n\n"}
{"name":"CategoryTheory.Presieve.isSheafFor_top_sieve","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nX : C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nâŠ¢ CategoryTheory.Presieve.IsSheafFor P Top.top.arrows","decl":"/-- Every presheaf is a sheaf for the maximal sieve.\n\n[Elephant] C2.1.5(ii)\n-/\ntheorem isSheafFor_top_sieve (P : Cáµ’áµ– â¥¤ Type w) : IsSheafFor P ((âŠ¤ : Sieve X) : Presieve X) := by\n  rw [â† generate_of_singleton_isSplitEpi (ğŸ™ X)]\n  rw [â† isSheafFor_iff_generate]\n  apply isSheafFor_singleton_iso\n\n"}
{"name":"CategoryTheory.Presieve.isSheafFor_of_nat_equiv","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nPâ‚ : CategoryTheory.Functor (Opposite C) (Type w)\nPâ‚‚ : CategoryTheory.Functor (Opposite C) (Type w')\ne : â¦ƒX : Câ¦„ â†’ Equiv (Pâ‚.obj { unop := X }) (Pâ‚‚.obj { unop := X })\nhe : âˆ€ â¦ƒX Y : Câ¦„ (f : Quiver.Hom X Y) (x : Pâ‚.obj { unop := Y }), Eq (e (Pâ‚.map f.op x)) (Pâ‚‚.map f.op (e x))\nX : C\nR : CategoryTheory.Presieve X\nhPâ‚ : CategoryTheory.Presieve.IsSheafFor Pâ‚ R\nâŠ¢ CategoryTheory.Presieve.IsSheafFor Pâ‚‚ R","decl":"/-- If `Pâ‚ : Cáµ’áµ– â¥¤ Type w` and `Pâ‚‚  : Cáµ’áµ– â¥¤ Type w` are two naturally equivalent\npresheaves, and `Pâ‚` is a sheaf for a presieve `R`, then `Pâ‚‚` is also a sheaf for `R`. -/\nlemma isSheafFor_of_nat_equiv {Pâ‚ : Cáµ’áµ– â¥¤ Type w} {Pâ‚‚ : Cáµ’áµ– â¥¤ Type w'}\n    (e : âˆ€ â¦ƒX : Câ¦„, Pâ‚.obj (op X) â‰ƒ Pâ‚‚.obj (op X))\n    (he : âˆ€ â¦ƒX Y : Câ¦„ (f : X âŸ¶ Y) (x : Pâ‚.obj (op Y)),\n      e (Pâ‚.map f.op x) = Pâ‚‚.map f.op (e x))\n    {X : C} {R : Presieve X} (hPâ‚ : IsSheafFor Pâ‚ R) :\n    IsSheafFor Pâ‚‚ R := fun xâ‚‚ hxâ‚‚ â†¦ by\n  have he' : âˆ€ â¦ƒX Y : Câ¦„ (f : X âŸ¶ Y) (x : Pâ‚‚.obj (op Y)),\n    e.symm (Pâ‚‚.map f.op x) = Pâ‚.map f.op (e.symm x) := fun X Y f x â†¦\n      e.injective (by simp only [Equiv.apply_symm_apply, he])\n  let xâ‚ : FamilyOfElements Pâ‚ R := fun Y f hf â†¦ e.symm (xâ‚‚ f hf)\n  have hxâ‚ : xâ‚.Compatible := fun Yâ‚ Yâ‚‚ Z gâ‚ gâ‚‚ fâ‚ fâ‚‚ hâ‚ hâ‚‚ fac â†¦ e.injective\n    (by simp only [he, Equiv.apply_symm_apply, hxâ‚‚ gâ‚ gâ‚‚ hâ‚ hâ‚‚ fac, xâ‚])\n  have : âˆ€ (tâ‚‚ : Pâ‚‚.obj (op X)),\n      xâ‚‚.IsAmalgamation tâ‚‚ â†” xâ‚.IsAmalgamation (e.symm tâ‚‚) := fun tâ‚‚ â†¦ by\n    simp only [FamilyOfElements.IsAmalgamation, xâ‚,\n      â† he', EmbeddingLike.apply_eq_iff_eq]\n  refine âŸ¨e (hPâ‚.amalgamate xâ‚ hxâ‚), ?_, ?_âŸ©\n  Â· dsimp\n    simp only [this, Equiv.symm_apply_apply]\n    exact IsSheafFor.isAmalgamation hPâ‚ hxâ‚\n  Â· intro tâ‚‚ htâ‚‚\n    refine e.symm.injective ?_\n    simp only [Equiv.symm_apply_apply]\n    exact hPâ‚.isSeparatedFor xâ‚ _ _ (by simpa only [this] using htâ‚‚)\n      (IsSheafFor.isAmalgamation hPâ‚ hxâ‚)\n\n"}
{"name":"CategoryTheory.Presieve.isSheafFor_iso","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nX : C\nR : CategoryTheory.Presieve X\nP' : CategoryTheory.Functor (Opposite C) (Type w)\ni : CategoryTheory.Iso P P'\nhP : CategoryTheory.Presieve.IsSheafFor P R\nâŠ¢ CategoryTheory.Presieve.IsSheafFor P' R","decl":"/-- If `P` is a sheaf for `S`, and it is iso to `P'`, then `P'` is a sheaf for `S`. This shows that\n\"being a sheaf for a presieve\" is a mathematical or hygienic property.\n-/\ntheorem isSheafFor_iso {P' : Cáµ’áµ– â¥¤ Type w} (i : P â‰… P') (hP : IsSheafFor P R) :\n    IsSheafFor P' R :=\n  isSheafFor_of_nat_equiv (fun X â†¦ (i.app (op X)).toEquiv)\n    (fun _ _ f x â†¦ congr_fun (i.hom.naturality f.op) x) hP\n\n"}
{"name":"CategoryTheory.Presieve.isSheafFor_subsieve_aux","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nX : C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nS : CategoryTheory.Sieve X\nR : CategoryTheory.Presieve X\nh : LE.le S.arrows R\nhS : CategoryTheory.Presieve.IsSheafFor P S.arrows\ntrans : âˆ€ â¦ƒY : Câ¦„ â¦ƒf : Quiver.Hom Y Xâ¦„, R f â†’ CategoryTheory.Presieve.IsSeparatedFor P (CategoryTheory.Sieve.pullback f S).arrows\nâŠ¢ CategoryTheory.Presieve.IsSheafFor P R","decl":"/-- If a presieve `R` on `X` has a subsieve `S` such that:\n\n* `P` is a sheaf for `S`.\n* For every `f` in `R`, `P` is separated for the pullback of `S` along `f`,\n\nthen `P` is a sheaf for `R`.\n\nThis is closely related to [Elephant] C2.1.6(i).\n-/\ntheorem isSheafFor_subsieve_aux (P : Cáµ’áµ– â¥¤ Type w) {S : Sieve X} {R : Presieve X}\n    (h : (S : Presieve X) â‰¤ R) (hS : IsSheafFor P (S : Presieve X))\n    (trans : âˆ€ â¦ƒYâ¦„ â¦ƒf : Y âŸ¶ Xâ¦„, R f â†’ IsSeparatedFor P (S.pullback f : Presieve Y)) :\n    IsSheafFor P R := by\n  rw [â† isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor]\n  constructor\n  Â· intro x tâ‚ tâ‚‚ htâ‚ htâ‚‚\n    exact\n      hS.isSeparatedFor _ _ _ (isAmalgamation_restrict h x tâ‚ htâ‚)\n        (isAmalgamation_restrict h x tâ‚‚ htâ‚‚)\n  Â· intro x hx\n    use hS.amalgamate _ (hx.restrict h)\n    intro W j hj\n    apply (trans hj).ext\n    intro Y f hf\n    rw [â† FunctorToTypes.map_comp_apply, â† op_comp, hS.valid_glue (hx.restrict h) _ hf,\n      FamilyOfElements.restrict, â† hx (ğŸ™ _) f (h _ hf) _ (id_comp _)]\n    simp\n\n"}
{"name":"CategoryTheory.Presieve.isSheafFor_subsieve","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nX : C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nS : CategoryTheory.Sieve X\nR : CategoryTheory.Presieve X\nh : LE.le S.arrows R\ntrans : âˆ€ â¦ƒY : Câ¦„ (f : Quiver.Hom Y X), CategoryTheory.Presieve.IsSheafFor P (CategoryTheory.Sieve.pullback f S).arrows\nâŠ¢ CategoryTheory.Presieve.IsSheafFor P R","decl":"/--\nIf `P` is a sheaf for every pullback of the sieve `S`, then `P` is a sheaf for any presieve which\ncontains `S`.\nThis is closely related to [Elephant] C2.1.6.\n-/\ntheorem isSheafFor_subsieve (P : Cáµ’áµ– â¥¤ Type w) {S : Sieve X} {R : Presieve X}\n    (h : (S : Presieve X) â‰¤ R) (trans : âˆ€ â¦ƒYâ¦„ (f : Y âŸ¶ X),\n      IsSheafFor P (S.pullback f : Presieve Y)) :\n    IsSheafFor P R :=\n  isSheafFor_subsieve_aux P h (by simpa using trans (ğŸ™ _)) fun _ f _ => (trans f).isSeparatedFor\n\n"}
{"name":"CategoryTheory.Presieve.FamilyOfElements.isAmalgamation_iff_ofArrows","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nB : C\nI : Type u_1\nX : I â†’ C\nÏ€ : (i : I) â†’ Quiver.Hom (X i) B\nx : CategoryTheory.Presieve.FamilyOfElements P (CategoryTheory.Presieve.ofArrows X Ï€)\nt : P.obj { unop := B }\nâŠ¢ Iff (x.IsAmalgamation t) (âˆ€ (i : I), Eq (P.map (Ï€ i).op t) (x (Ï€ i) â‹¯))","decl":"lemma FamilyOfElements.isAmalgamation_iff_ofArrows (x : FamilyOfElements P (ofArrows X Ï€))\n    (t : P.obj (op B)) :\n    x.IsAmalgamation t â†” âˆ€ (i : I), P.map (Ï€ i).op t = x _ (ofArrows.mk i) :=\n  âŸ¨fun h i â†¦ h _ (ofArrows.mk i), fun h _ f âŸ¨iâŸ© â†¦ h iâŸ©\n\n"}
{"name":"CategoryTheory.Presieve.Arrows.Compatible.exists_familyOfElements","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nB : C\nI : Type u_1\nX : I â†’ C\nÏ€ : (i : I) â†’ Quiver.Hom (X i) B\nx : (i : I) â†’ P.obj { unop := X i }\nhx : CategoryTheory.Presieve.Arrows.Compatible P Ï€ x\nâŠ¢ Exists fun x' => âˆ€ (i : I), Eq (x' (Ï€ i) â‹¯) (x i)","decl":"theorem exists_familyOfElements (hx : Compatible P Ï€ x) :\n    âˆƒ (x' : FamilyOfElements P (ofArrows X Ï€)), âˆ€ (i : I), x' _ (ofArrows.mk i) = x i := by\n  choose i h h' using @ofArrows_surj _ _ _ _ _ Ï€\n  exact âŸ¨fun Y f hf â†¦ P.map (eqToHom (h f hf).symm).op (x _),\n    fun j â†¦ (hx _ j (X j) _ (ğŸ™ _) <| by rw [â† h', id_comp]).trans <| by simpâŸ©\n\n"}
{"name":"CategoryTheory.Presieve.Arrows.Compatible.familyOfElements_ofArrows_mk","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nB : C\nI : Type u_1\nX : I â†’ C\nÏ€ : (i : I) â†’ Quiver.Hom (X i) B\nx : (i : I) â†’ P.obj { unop := X i }\nhx : CategoryTheory.Presieve.Arrows.Compatible P Ï€ x\ni : I\nâŠ¢ Eq (hx.familyOfElements (Ï€ i) â‹¯) (x i)","decl":"@[simp]\ntheorem familyOfElements_ofArrows_mk (i : I) :\n    hx.familyOfElements _ (ofArrows.mk i) = x i :=\n  (exists_familyOfElements hx).choose_spec _\n\n"}
{"name":"CategoryTheory.Presieve.Arrows.Compatible.familyOfElements_compatible","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nB : C\nI : Type u_1\nX : I â†’ C\nÏ€ : (i : I) â†’ Quiver.Hom (X i) B\nx : (i : I) â†’ P.obj { unop := X i }\nhx : CategoryTheory.Presieve.Arrows.Compatible P Ï€ x\nâŠ¢ hx.familyOfElements.Compatible","decl":"theorem familyOfElements_compatible : hx.familyOfElements.Compatible := by\n  rintro Yâ‚ Yâ‚‚ Z gâ‚ gâ‚‚ fâ‚ fâ‚‚ âŸ¨iâŸ© âŸ¨jâŸ© hgf\n  simp [hx i j Z gâ‚ gâ‚‚ hgf]\n\n"}
{"name":"CategoryTheory.Presieve.isSheafFor_arrows_iff","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nB : C\nI : Type u_1\nX : I â†’ C\nÏ€ : (i : I) â†’ Quiver.Hom (X i) B\nâŠ¢ Iff (CategoryTheory.Presieve.IsSheafFor P (CategoryTheory.Presieve.ofArrows X Ï€)) (âˆ€ (x : (i : I) â†’ P.obj { unop := X i }), CategoryTheory.Presieve.Arrows.Compatible P Ï€ x â†’ ExistsUnique fun t => âˆ€ (i : I), Eq (P.map (Ï€ i).op t) (x i))","decl":"theorem isSheafFor_arrows_iff : (ofArrows X Ï€).IsSheafFor P â†”\n    (âˆ€ (x : (i : I) â†’ P.obj (op (X i))), Arrows.Compatible P Ï€ x â†’\n    âˆƒ! t, âˆ€ i, P.map (Ï€ i).op t = x i) := by\n  refine âŸ¨fun h x hx â†¦ ?_, fun h x hx â†¦ ?_âŸ©\n  Â· obtain âŸ¨t, htâ‚, htâ‚‚âŸ© := h _ hx.familyOfElements_compatible\n    refine âŸ¨t, fun i â†¦ ?_, fun t' ht' â†¦ htâ‚‚ _ fun _ _ âŸ¨iâŸ© â†¦ ?_âŸ©\n    Â· rw [htâ‚ _ (ofArrows.mk i), hx.familyOfElements_ofArrows_mk]\n    Â· rw [ht', hx.familyOfElements_ofArrows_mk]\n  Â· obtain âŸ¨t, hA, htâŸ© := h (fun i â†¦ x (Ï€ i) (ofArrows.mk _))\n      (fun i j Z gi gj â†¦ hx gi gj (ofArrows.mk _) (ofArrows.mk _))\n    exact âŸ¨t, fun Y f âŸ¨iâŸ© â†¦ hA i, fun y hy â†¦ ht y (fun i â†¦ hy (Ï€ i) (ofArrows.mk _))âŸ©\n\n"}
{"name":"CategoryTheory.Presieve.Arrows.pullbackCompatible_iff","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nB : C\nI : Type u_1\nX : I â†’ C\nÏ€ : (i : I) â†’ Quiver.Hom (X i) B\ninstâœ : (CategoryTheory.Presieve.ofArrows X Ï€).hasPullbacks\nx : (i : I) â†’ P.obj { unop := X i }\nâŠ¢ Iff (CategoryTheory.Presieve.Arrows.Compatible P Ï€ x) (CategoryTheory.Presieve.Arrows.PullbackCompatible P Ï€ x)","decl":"theorem Arrows.pullbackCompatible_iff (x : (i : I) â†’ P.obj (op (X i))) :\n    Compatible P Ï€ x â†” PullbackCompatible P Ï€ x := by\n  refine âŸ¨fun t i j â†¦ ?_, fun t i j Z gi gj comm â†¦ ?_âŸ©\n  Â· apply t\n    exact pullback.condition\n  Â· rw [â† pullback.lift_fst _ _ comm, op_comp, FunctorToTypes.map_comp_apply, t i j,\n      â† FunctorToTypes.map_comp_apply, â† op_comp, pullback.lift_snd]\n\n"}
{"name":"CategoryTheory.Presieve.isSheafFor_arrows_iff_pullbacks","module":"Mathlib.CategoryTheory.Sites.IsSheafFor","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nB : C\nI : Type u_1\nX : I â†’ C\nÏ€ : (i : I) â†’ Quiver.Hom (X i) B\ninstâœ : (CategoryTheory.Presieve.ofArrows X Ï€).hasPullbacks\nâŠ¢ Iff (CategoryTheory.Presieve.IsSheafFor P (CategoryTheory.Presieve.ofArrows X Ï€)) (âˆ€ (x : (i : I) â†’ P.obj { unop := X i }), CategoryTheory.Presieve.Arrows.PullbackCompatible P Ï€ x â†’ ExistsUnique fun t => âˆ€ (i : I), Eq (P.map (Ï€ i).op t) (x i))","decl":"theorem isSheafFor_arrows_iff_pullbacks : (ofArrows X Ï€).IsSheafFor P â†”\n    (âˆ€ (x : (i : I) â†’ P.obj (op (X i))), Arrows.PullbackCompatible P Ï€ x â†’\n    âˆƒ! t, âˆ€ i, P.map (Ï€ i).op t = x i) := by\n  simp_rw [â† Arrows.pullbackCompatible_iff, isSheafFor_arrows_iff]\n\n"}
