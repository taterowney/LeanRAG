{"name":"AlgebraicGeometry.Proj.lift_awayMapâ‚_awayMapâ‚_surjective","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Proper","initialProofState":"R : Type u_1\nA : Type u_2\ninstâœÂ³ : CommRing R\ninstâœÂ² : CommRing A\ninstâœÂ¹ : Algebra R A\nğ’œ : Nat â†’ Submodule R A\ninstâœ : GradedAlgebra ğ’œ\nd e : Nat\nf : A\nhf : Membership.mem (ğ’œ d) f\ng : A\nhg : Membership.mem (ğ’œ e) g\nx : A\nhx : Eq x (HMul.hMul f g)\nhd : LT.lt 0 d\nâŠ¢ Function.Surjective â‡‘(Algebra.TensorProduct.lift (HomogeneousLocalization.awayMapâ‚ ğ’œ hg hx) (HomogeneousLocalization.awayMapâ‚ ğ’œ hf â‹¯) â‹¯)","decl":"lemma lift_awayMapâ‚_awayMapâ‚_surjective {d e : â„•} {f : A} (hf : f âˆˆ ğ’œ d)\n    {g : A} (hg : g âˆˆ ğ’œ e) {x : A} (hx : x = f * g) (hd : 0 < d) :\n    Function.Surjective\n      (Algebra.TensorProduct.lift (awayMapâ‚ ğ’œ hg hx) (awayMapâ‚ ğ’œ hf (hx.trans (mul_comm _ _)))\n        (fun _ _ â†¦ .all _ _)) := by\n  intro z\n  obtain âŸ¨âŸ¨n, âŸ¨a, haâŸ©, âŸ¨b, hb'âŸ©, âŸ¨j, (rfl : _ = b)âŸ©âŸ©, rflâŸ© := mk_surjective z\n  by_cases hfg : (f * g) ^ j = 0\n  Â· use 0\n    have := HomogeneousLocalization.subsingleton ğ’œ (x := Submonoid.powers x) âŸ¨j, hx â–¸ hfgâŸ©\n    exact this.elim _ _\n  have : n = j * (d + e) := by\n    apply DirectSum.degree_eq_of_mem_mem ğ’œ hb'\n    convert SetLike.pow_mem_graded _ _ using 2\n    Â· infer_instance\n    Â· exact hx â–¸ SetLike.mul_mem_graded hf hg\n    Â· exact hx â–¸ hfg\n  let x0 : NumDenSameDeg ğ’œ (.powers f) :=\n  { deg := j * (d * (e + 1))\n    num := âŸ¨a * g ^ (j * (d - 1)), by\n      convert SetLike.mul_mem_graded ha (SetLike.pow_mem_graded _ hg) using 2\n      rw [this]\n      cases d\n      Â· contradiction\n      Â· simp; ringâŸ©\n    den := âŸ¨f ^ (j * (e + 1)), by convert SetLike.pow_mem_graded _ hf using 2; ringâŸ©\n    den_mem := âŸ¨_,rflâŸ© }\n  let y0 : NumDenSameDeg ğ’œ (.powers g) :=\n  { deg := j * (d * e)\n    num := âŸ¨f ^ (j * e), by convert SetLike.pow_mem_graded _ hf using 2; ringâŸ©\n    den := âŸ¨g ^ (j * d), by convert SetLike.pow_mem_graded _ hg using 2; ringâŸ©\n    den_mem := âŸ¨_,rflâŸ© }\n  use mk x0 âŠ—â‚œ mk y0\n  ext\n  simp only [Algebra.TensorProduct.lift_tmul, awayMapâ‚_apply, val_mul,\n    val_awayMap_mk, Localization.mk_mul, val_mk, x0, y0]\n  rw [Localization.mk_eq_mk_iff, Localization.r_iff_exists]\n  use 1\n  simp only [OneMemClass.coe_one, one_mul, Submonoid.mk_mul_mk]\n  cases d\n  Â· contradiction\n  Â· simp only [hx, add_tsub_cancel_right]\n    ring\n\n"}
{"name":"AlgebraicGeometry.Proj.isSeparated","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Proper","initialProofState":"R : Type u_1\nA : Type u_2\ninstâœÂ³ : CommRing R\ninstâœÂ² : CommRing A\ninstâœÂ¹ : Algebra R A\nğ’œ : Nat â†’ Submodule R A\ninstâœ : GradedAlgebra ğ’œ\nâŠ¢ AlgebraicGeometry.IsSeparated (AlgebraicGeometry.Proj.toSpecZero ğ’œ)","decl":"open TensorProduct in\ninstance isSeparated : IsSeparated (toSpecZero ğ’œ) := by\n  refine âŸ¨IsLocalAtTarget.of_openCover (Pullback.openCoverOfLeftRight\n    (affineOpenCover ğ’œ).openCover (affineOpenCover ğ’œ).openCover _ _) ?_âŸ©\n  intro âŸ¨i, jâŸ©\n  dsimp [Scheme, Cover.pullbackHom]\n  refine (MorphismProperty.cancel_left_of_respectsIso (P := @IsClosedImmersion)\n    (f := (pullbackDiagonalMapIdIso ..).inv) _).mp ?_\n  let eâ‚ : pullback ((affineOpenCover ğ’œ).map i â‰« toSpecZero ğ’œ)\n        ((affineOpenCover ğ’œ).map j â‰« toSpecZero ğ’œ) â‰…\n        Spec (.of <| TensorProduct (ğ’œ 0) (Away ğ’œ i.2) (Away ğ’œ j.2)) := by\n    refine pullback.congrHom ?_ ?_ â‰ªâ‰« pullbackSpecIso (ğ’œ 0) (Away ğ’œ i.2) (Away ğ’œ j.2)\n    Â· simp [affineOpenCover, openCoverOfISupEqTop, awayÎ¹_toSpecZero]; rfl\n    Â· simp [affineOpenCover, openCoverOfISupEqTop, awayÎ¹_toSpecZero]; rfl\n  let eâ‚‚ : pullback ((affineOpenCover ğ’œ).map i) ((affineOpenCover ğ’œ).map j) â‰…\n        Spec (.of <| (Away ğ’œ (i.2 * j.2))) :=\n    pullbackAwayÎ¹Iso ğ’œ _ _ _ _ rfl\n  rw [â† MorphismProperty.cancel_right_of_respectsIso (P := @IsClosedImmersion) _ eâ‚.hom,\n    â† MorphismProperty.cancel_left_of_respectsIso (P := @IsClosedImmersion) eâ‚‚.inv]\n  let F : Away ğ’œ i.2.1 âŠ—[ğ’œ 0] Away ğ’œ j.2.1 â†’+* Away ğ’œ (i.2.1 * j.2.1) :=\n    (Algebra.TensorProduct.lift (awayMapâ‚ ğ’œ j.2.2 rfl) (awayMapâ‚ ğ’œ i.2.2 (mul_comm _ _))\n      (fun _ _ â†¦ .all _ _)).toRingHom\n  have : Function.Surjective F := lift_awayMapâ‚_awayMapâ‚_surjective ğ’œ i.2.2 j.2.2 rfl i.1.2\n  convert IsClosedImmersion.spec_of_surjective\n    (CommRingCat.ofHom (R := Away ğ’œ i.2.1 âŠ—[ğ’œ 0] Away ğ’œ j.2.1) F) this using 1\n  rw [â† cancel_mono (pullbackSpecIso ..).inv]\n  apply pullback.hom_ext\n  Â· simp only [Iso.trans_hom, congrHom_hom, Category.assoc, Iso.hom_inv_id, Category.comp_id,\n      limit.lift_Ï€, id_eq, eq_mpr_eq_cast, PullbackCone.mk_pt, PullbackCone.mk_Ï€_app, eâ‚‚, eâ‚,\n      pullbackDiagonalMapIdIso_inv_snd_fst, AlgHom.toRingHom_eq_coe, pullbackSpecIso_inv_fst,\n      â† Spec.map_comp]\n    erw [pullbackAwayÎ¹Iso_inv_fst]\n    congr 1\n    ext x : 2\n    exact DFunLike.congr_fun (Algebra.TensorProduct.lift_comp_includeLeft\n      (awayMapâ‚ ğ’œ j.2.2 rfl) (awayMapâ‚ ğ’œ i.2.2 (mul_comm _ _)) (fun _ _ â†¦ .all _ _)).symm x\n  Â· simp only [Iso.trans_hom, congrHom_hom, Category.assoc, Iso.hom_inv_id, Category.comp_id,\n      limit.lift_Ï€, id_eq, eq_mpr_eq_cast, PullbackCone.mk_pt, PullbackCone.mk_Ï€_app,\n      pullbackDiagonalMapIdIso_inv_snd_snd, AlgHom.toRingHom_eq_coe, pullbackSpecIso_inv_snd, â†\n      Spec.map_comp, eâ‚‚, eâ‚]\n    erw [pullbackAwayÎ¹Iso_inv_snd]\n    congr 1\n    ext x : 2\n    exact DFunLike.congr_fun (Algebra.TensorProduct.lift_comp_includeRight\n      (awayMapâ‚ ğ’œ j.2.2 rfl) (awayMapâ‚ ğ’œ i.2.2 (mul_comm _ _)) (fun _ _ â†¦ .all _ _)).symm x\n\n"}
{"name":"AlgebraicGeometry.Proj.instIsSeparated","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Proper","initialProofState":"R : Type u_1\nA : Type u_2\ninstâœÂ³ : CommRing R\ninstâœÂ² : CommRing A\ninstâœÂ¹ : Algebra R A\nğ’œ : Nat â†’ Submodule R A\ninstâœ : GradedAlgebra ğ’œ\nâŠ¢ (AlgebraicGeometry.Proj ğ’œ).IsSeparated","decl":"@[stacks 01MC]\ninstance : Scheme.IsSeparated (Proj ğ’œ) :=\n  (HasAffineProperty.iff_of_isAffine (P := @IsSeparated)).mp (isSeparated ğ’œ)\n\n"}
