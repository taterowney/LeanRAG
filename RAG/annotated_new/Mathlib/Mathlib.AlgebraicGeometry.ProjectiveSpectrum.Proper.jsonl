{"name":"AlgebraicGeometry.Proj.lift_awayMapₐ_awayMapₐ_surjective","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Proper","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nd e : Nat\nf : A\nhf : Membership.mem (𝒜 d) f\ng : A\nhg : Membership.mem (𝒜 e) g\nx : A\nhx : Eq x (HMul.hMul f g)\nhd : LT.lt 0 d\n⊢ Function.Surjective ⇑(Algebra.TensorProduct.lift (HomogeneousLocalization.awayMapₐ 𝒜 hg hx) (HomogeneousLocalization.awayMapₐ 𝒜 hf ⋯) ⋯)","decl":"lemma lift_awayMapₐ_awayMapₐ_surjective {d e : ℕ} {f : A} (hf : f ∈ 𝒜 d)\n    {g : A} (hg : g ∈ 𝒜 e) {x : A} (hx : x = f * g) (hd : 0 < d) :\n    Function.Surjective\n      (Algebra.TensorProduct.lift (awayMapₐ 𝒜 hg hx) (awayMapₐ 𝒜 hf (hx.trans (mul_comm _ _)))\n        (fun _ _ ↦ .all _ _)) := by\n  intro z\n  obtain ⟨⟨n, ⟨a, ha⟩, ⟨b, hb'⟩, ⟨j, (rfl : _ = b)⟩⟩, rfl⟩ := mk_surjective z\n  by_cases hfg : (f * g) ^ j = 0\n  · use 0\n    have := HomogeneousLocalization.subsingleton 𝒜 (x := Submonoid.powers x) ⟨j, hx ▸ hfg⟩\n    exact this.elim _ _\n  have : n = j * (d + e) := by\n    apply DirectSum.degree_eq_of_mem_mem 𝒜 hb'\n    convert SetLike.pow_mem_graded _ _ using 2\n    · infer_instance\n    · exact hx ▸ SetLike.mul_mem_graded hf hg\n    · exact hx ▸ hfg\n  let x0 : NumDenSameDeg 𝒜 (.powers f) :=\n  { deg := j * (d * (e + 1))\n    num := ⟨a * g ^ (j * (d - 1)), by\n      convert SetLike.mul_mem_graded ha (SetLike.pow_mem_graded _ hg) using 2\n      rw [this]\n      cases d\n      · contradiction\n      · simp; ring⟩\n    den := ⟨f ^ (j * (e + 1)), by convert SetLike.pow_mem_graded _ hf using 2; ring⟩\n    den_mem := ⟨_,rfl⟩ }\n  let y0 : NumDenSameDeg 𝒜 (.powers g) :=\n  { deg := j * (d * e)\n    num := ⟨f ^ (j * e), by convert SetLike.pow_mem_graded _ hf using 2; ring⟩\n    den := ⟨g ^ (j * d), by convert SetLike.pow_mem_graded _ hg using 2; ring⟩\n    den_mem := ⟨_,rfl⟩ }\n  use mk x0 ⊗ₜ mk y0\n  ext\n  simp only [Algebra.TensorProduct.lift_tmul, awayMapₐ_apply, val_mul,\n    val_awayMap_mk, Localization.mk_mul, val_mk, x0, y0]\n  rw [Localization.mk_eq_mk_iff, Localization.r_iff_exists]\n  use 1\n  simp only [OneMemClass.coe_one, one_mul, Submonoid.mk_mul_mk]\n  cases d\n  · contradiction\n  · simp only [hx, add_tsub_cancel_right]\n    ring\n\n"}
{"name":"AlgebraicGeometry.Proj.isSeparated","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Proper","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\n⊢ AlgebraicGeometry.IsSeparated (AlgebraicGeometry.Proj.toSpecZero 𝒜)","decl":"open TensorProduct in\ninstance isSeparated : IsSeparated (toSpecZero 𝒜) := by\n  refine ⟨IsLocalAtTarget.of_openCover (Pullback.openCoverOfLeftRight\n    (affineOpenCover 𝒜).openCover (affineOpenCover 𝒜).openCover _ _) ?_⟩\n  intro ⟨i, j⟩\n  dsimp [Scheme, Cover.pullbackHom]\n  refine (MorphismProperty.cancel_left_of_respectsIso (P := @IsClosedImmersion)\n    (f := (pullbackDiagonalMapIdIso ..).inv) _).mp ?_\n  let e₁ : pullback ((affineOpenCover 𝒜).map i ≫ toSpecZero 𝒜)\n        ((affineOpenCover 𝒜).map j ≫ toSpecZero 𝒜) ≅\n        Spec (.of <| TensorProduct (𝒜 0) (Away 𝒜 i.2) (Away 𝒜 j.2)) := by\n    refine pullback.congrHom ?_ ?_ ≪≫ pullbackSpecIso (𝒜 0) (Away 𝒜 i.2) (Away 𝒜 j.2)\n    · simp [affineOpenCover, openCoverOfISupEqTop, awayι_toSpecZero]; rfl\n    · simp [affineOpenCover, openCoverOfISupEqTop, awayι_toSpecZero]; rfl\n  let e₂ : pullback ((affineOpenCover 𝒜).map i) ((affineOpenCover 𝒜).map j) ≅\n        Spec (.of <| (Away 𝒜 (i.2 * j.2))) :=\n    pullbackAwayιIso 𝒜 _ _ _ _ rfl\n  rw [← MorphismProperty.cancel_right_of_respectsIso (P := @IsClosedImmersion) _ e₁.hom,\n    ← MorphismProperty.cancel_left_of_respectsIso (P := @IsClosedImmersion) e₂.inv]\n  let F : Away 𝒜 i.2.1 ⊗[𝒜 0] Away 𝒜 j.2.1 →+* Away 𝒜 (i.2.1 * j.2.1) :=\n    (Algebra.TensorProduct.lift (awayMapₐ 𝒜 j.2.2 rfl) (awayMapₐ 𝒜 i.2.2 (mul_comm _ _))\n      (fun _ _ ↦ .all _ _)).toRingHom\n  have : Function.Surjective F := lift_awayMapₐ_awayMapₐ_surjective 𝒜 i.2.2 j.2.2 rfl i.1.2\n  convert IsClosedImmersion.spec_of_surjective\n    (CommRingCat.ofHom (R := Away 𝒜 i.2.1 ⊗[𝒜 0] Away 𝒜 j.2.1) F) this using 1\n  rw [← cancel_mono (pullbackSpecIso ..).inv]\n  apply pullback.hom_ext\n  · simp only [Iso.trans_hom, congrHom_hom, Category.assoc, Iso.hom_inv_id, Category.comp_id,\n      limit.lift_π, id_eq, eq_mpr_eq_cast, PullbackCone.mk_pt, PullbackCone.mk_π_app, e₂, e₁,\n      pullbackDiagonalMapIdIso_inv_snd_fst, AlgHom.toRingHom_eq_coe, pullbackSpecIso_inv_fst,\n      ← Spec.map_comp]\n    erw [pullbackAwayιIso_inv_fst]\n    congr 1\n    ext x : 2\n    exact DFunLike.congr_fun (Algebra.TensorProduct.lift_comp_includeLeft\n      (awayMapₐ 𝒜 j.2.2 rfl) (awayMapₐ 𝒜 i.2.2 (mul_comm _ _)) (fun _ _ ↦ .all _ _)).symm x\n  · simp only [Iso.trans_hom, congrHom_hom, Category.assoc, Iso.hom_inv_id, Category.comp_id,\n      limit.lift_π, id_eq, eq_mpr_eq_cast, PullbackCone.mk_pt, PullbackCone.mk_π_app,\n      pullbackDiagonalMapIdIso_inv_snd_snd, AlgHom.toRingHom_eq_coe, pullbackSpecIso_inv_snd, ←\n      Spec.map_comp, e₂, e₁]\n    erw [pullbackAwayιIso_inv_snd]\n    congr 1\n    ext x : 2\n    exact DFunLike.congr_fun (Algebra.TensorProduct.lift_comp_includeRight\n      (awayMapₐ 𝒜 j.2.2 rfl) (awayMapₐ 𝒜 i.2.2 (mul_comm _ _)) (fun _ _ ↦ .all _ _)).symm x\n\n"}
{"name":"AlgebraicGeometry.Proj.instIsSeparated","module":"Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Proper","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\n𝒜 : Nat → Submodule R A\ninst✝ : GradedAlgebra 𝒜\n⊢ (AlgebraicGeometry.Proj 𝒜).IsSeparated","decl":"@[stacks 01MC]\ninstance : Scheme.IsSeparated (Proj 𝒜) :=\n  (HasAffineProperty.iff_of_isAffine (P := @IsSeparated)).mp (isSeparated 𝒜)\n\n"}
