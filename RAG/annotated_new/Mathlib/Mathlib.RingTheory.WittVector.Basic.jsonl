{"name":"WittVector.mapFun.injective","module":"Mathlib.RingTheory.WittVector.Basic","initialProofState":"p : Nat\nα : Type u_3\nβ : Type u_4\nf : α → β\nhf : Function.Injective f\n⊢ Function.Injective (WittVector.mapFun f)","decl":"theorem injective (f : α → β) (hf : Injective f) : Injective (mapFun f : 𝕎 α → 𝕎 β) := by\n  intros _ _ h\n  ext p\n  exact hf (congr_arg (fun x => coeff x p) h :)\n\n"}
{"name":"WittVector.mapFun.surjective","module":"Mathlib.RingTheory.WittVector.Basic","initialProofState":"p : Nat\nα : Type u_3\nβ : Type u_4\nf : α → β\nhf : Function.Surjective f\n⊢ Function.Surjective (WittVector.mapFun f)","decl":"theorem surjective (f : α → β) (hf : Surjective f) : Surjective (mapFun f : 𝕎 α → 𝕎 β) := fun x =>\n  ⟨mk _ fun n => Classical.choose <| hf <| x.coeff n,\n    by ext n; simp only [mapFun, coeff_mk, comp_apply, Classical.choose_spec (hf (x.coeff n))]⟩\n\n"}
{"name":"WittVector.mapFun.zero","module":"Mathlib.RingTheory.WittVector.Basic","initialProofState":"p : Nat\nR : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Fact (Nat.Prime p)\nf : RingHom R S\n⊢ Eq (WittVector.mapFun (⇑f) 0) 0","decl":"theorem zero : mapFun f (0 : 𝕎 R) = 0 := by map_fun_tac\n\n"}
{"name":"WittVector.mapFun.one","module":"Mathlib.RingTheory.WittVector.Basic","initialProofState":"p : Nat\nR : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Fact (Nat.Prime p)\nf : RingHom R S\n⊢ Eq (WittVector.mapFun (⇑f) 1) 1","decl":"theorem one : mapFun f (1 : 𝕎 R) = 1 := by map_fun_tac\n\n"}
{"name":"WittVector.mapFun.add","module":"Mathlib.RingTheory.WittVector.Basic","initialProofState":"p : Nat\nR : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Fact (Nat.Prime p)\nf : RingHom R S\nx y : WittVector p R\n⊢ Eq (WittVector.mapFun (⇑f) (HAdd.hAdd x y)) (HAdd.hAdd (WittVector.mapFun (⇑f) x) (WittVector.mapFun (⇑f) y))","decl":"theorem add : mapFun f (x + y) = mapFun f x + mapFun f y := by map_fun_tac\n\n"}
{"name":"WittVector.mapFun.sub","module":"Mathlib.RingTheory.WittVector.Basic","initialProofState":"p : Nat\nR : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Fact (Nat.Prime p)\nf : RingHom R S\nx y : WittVector p R\n⊢ Eq (WittVector.mapFun (⇑f) (HSub.hSub x y)) (HSub.hSub (WittVector.mapFun (⇑f) x) (WittVector.mapFun (⇑f) y))","decl":"theorem sub : mapFun f (x - y) = mapFun f x - mapFun f y := by map_fun_tac\n\n"}
{"name":"WittVector.mapFun.mul","module":"Mathlib.RingTheory.WittVector.Basic","initialProofState":"p : Nat\nR : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Fact (Nat.Prime p)\nf : RingHom R S\nx y : WittVector p R\n⊢ Eq (WittVector.mapFun (⇑f) (HMul.hMul x y)) (HMul.hMul (WittVector.mapFun (⇑f) x) (WittVector.mapFun (⇑f) y))","decl":"theorem mul : mapFun f (x * y) = mapFun f x * mapFun f y := by map_fun_tac\n\n"}
{"name":"WittVector.mapFun.neg","module":"Mathlib.RingTheory.WittVector.Basic","initialProofState":"p : Nat\nR : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Fact (Nat.Prime p)\nf : RingHom R S\nx : WittVector p R\n⊢ Eq (WittVector.mapFun (⇑f) (Neg.neg x)) (Neg.neg (WittVector.mapFun (⇑f) x))","decl":"theorem neg : mapFun f (-x) = -mapFun f x := by map_fun_tac\n\n"}
{"name":"WittVector.mapFun.nsmul","module":"Mathlib.RingTheory.WittVector.Basic","initialProofState":"p : Nat\nR : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Fact (Nat.Prime p)\nf : RingHom R S\nn : Nat\nx : WittVector p R\n⊢ Eq (WittVector.mapFun (⇑f) (HSMul.hSMul n x)) (HSMul.hSMul n (WittVector.mapFun (⇑f) x))","decl":"theorem nsmul (n : ℕ) (x : WittVector p R) : mapFun f (n • x) = n • mapFun f x := by map_fun_tac\n\n"}
{"name":"WittVector.mapFun.zsmul","module":"Mathlib.RingTheory.WittVector.Basic","initialProofState":"p : Nat\nR : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Fact (Nat.Prime p)\nf : RingHom R S\nz : Int\nx : WittVector p R\n⊢ Eq (WittVector.mapFun (⇑f) (HSMul.hSMul z x)) (HSMul.hSMul z (WittVector.mapFun (⇑f) x))","decl":"theorem zsmul (z : ℤ) (x : WittVector p R) : mapFun f (z • x) = z • mapFun f x := by map_fun_tac\n\n"}
{"name":"WittVector.mapFun.pow","module":"Mathlib.RingTheory.WittVector.Basic","initialProofState":"p : Nat\nR : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Fact (Nat.Prime p)\nf : RingHom R S\nx : WittVector p R\nn : Nat\n⊢ Eq (WittVector.mapFun (⇑f) (HPow.hPow x n)) (HPow.hPow (WittVector.mapFun (⇑f) x) n)","decl":"theorem pow (n : ℕ) : mapFun f (x ^ n) = mapFun f x ^ n := by map_fun_tac\n\n"}
{"name":"WittVector.mapFun.natCast","module":"Mathlib.RingTheory.WittVector.Basic","initialProofState":"p : Nat\nR : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Fact (Nat.Prime p)\nf : RingHom R S\nn : Nat\n⊢ Eq (WittVector.mapFun ⇑f ↑n) ↑n","decl":"theorem natCast (n : ℕ) : mapFun f (n : 𝕎 R) = n :=\n  show mapFun f n.unaryCast = (n : WittVector p S) by\n    induction n <;> simp [*, Nat.unaryCast, add, one, zero] <;> rfl\n\n"}
{"name":"WittVector.mapFun.intCast","module":"Mathlib.RingTheory.WittVector.Basic","initialProofState":"p : Nat\nR : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Fact (Nat.Prime p)\nf : RingHom R S\nn : Int\n⊢ Eq (WittVector.mapFun ⇑f ↑n) ↑n","decl":"theorem intCast (n : ℤ) : mapFun f (n : 𝕎 R) = n :=\n  show mapFun f n.castDef = (n : WittVector p S) by\n    cases n <;> simp [*, Int.castDef, add, one, neg, zero, natCast] <;> rfl\n\n"}
{"name":"WittVector.matrix_vecEmpty_coeff","module":"Mathlib.RingTheory.WittVector.Basic","initialProofState":"p : Nat\nR : Type u_5\ni : Fin 0\nj : Nat\n⊢ Eq ((Matrix.vecEmpty i).coeff j) (Matrix.vecEmpty i j)","decl":"@[local simp]\ntheorem matrix_vecEmpty_coeff {R} (i j) :\n    @coeff p R (Matrix.vecEmpty i) j = (Matrix.vecEmpty i : ℕ → R) j := by\n  rcases i with ⟨_ | _ | _ | _ | i_val, ⟨⟩⟩\n\n"}
{"name":"WittVector.map_injective","module":"Mathlib.RingTheory.WittVector.Basic","initialProofState":"p : Nat\nR : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Fact (Nat.Prime p)\nf : RingHom R S\nhf : Function.Injective ⇑f\n⊢ Function.Injective ⇑(WittVector.map f)","decl":"theorem map_injective (f : R →+* S) (hf : Injective f) : Injective (map f : 𝕎 R → 𝕎 S) :=\n  mapFun.injective f hf\n\n"}
{"name":"WittVector.map_surjective","module":"Mathlib.RingTheory.WittVector.Basic","initialProofState":"p : Nat\nR : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Fact (Nat.Prime p)\nf : RingHom R S\nhf : Function.Surjective ⇑f\n⊢ Function.Surjective ⇑(WittVector.map f)","decl":"theorem map_surjective (f : R →+* S) (hf : Surjective f) : Surjective (map f : 𝕎 R → 𝕎 S) :=\n  mapFun.surjective f hf\n\n"}
{"name":"WittVector.map_coeff","module":"Mathlib.RingTheory.WittVector.Basic","initialProofState":"p : Nat\nR : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Fact (Nat.Prime p)\nf : RingHom R S\nx : WittVector p R\nn : Nat\n⊢ Eq (((WittVector.map f) x).coeff n) (f (x.coeff n))","decl":"@[simp]\ntheorem map_coeff (f : R →+* S) (x : 𝕎 R) (n : ℕ) : (map f x).coeff n = f (x.coeff n) :=\n  rfl\n\n"}
{"name":"WittVector.ghostComponent_apply","module":"Mathlib.RingTheory.WittVector.Basic","initialProofState":"p : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\nn : Nat\nx : WittVector p R\n⊢ Eq ((WittVector.ghostComponent n) x) ((MvPolynomial.aeval x.coeff) (wittPolynomial p Int n))","decl":"theorem ghostComponent_apply (n : ℕ) (x : 𝕎 R) : ghostComponent n x = aeval x.coeff (W_ ℤ n) :=\n  rfl\n\n"}
{"name":"WittVector.ghostMap_apply","module":"Mathlib.RingTheory.WittVector.Basic","initialProofState":"p : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\nx : WittVector p R\nn : Nat\n⊢ Eq (WittVector.ghostMap x n) ((WittVector.ghostComponent n) x)","decl":"@[simp]\ntheorem ghostMap_apply (x : 𝕎 R) (n : ℕ) : ghostMap x n = ghostComponent n x :=\n  rfl\n\n"}
{"name":"WittVector.ghostEquiv_coe","module":"Mathlib.RingTheory.WittVector.Basic","initialProofState":"p : Nat\nR : Type u_1\ninst✝² : CommRing R\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : Invertible ↑p\n⊢ Eq (↑(WittVector.ghostEquiv p R)) WittVector.ghostMap","decl":"@[simp]\ntheorem ghostEquiv_coe : (ghostEquiv p R : 𝕎 R →+* ℕ → R) = ghostMap :=\n  rfl\n\n"}
{"name":"WittVector.ghostMap.bijective_of_invertible","module":"Mathlib.RingTheory.WittVector.Basic","initialProofState":"p : Nat\nR : Type u_1\ninst✝² : CommRing R\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : Invertible ↑p\n⊢ Function.Bijective ⇑WittVector.ghostMap","decl":"theorem ghostMap.bijective_of_invertible : Function.Bijective (ghostMap : 𝕎 R → ℕ → R) :=\n  (ghostEquiv p R).bijective\n\n"}
{"name":"WittVector.constantCoeff_apply","module":"Mathlib.RingTheory.WittVector.Basic","initialProofState":"p : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\nx : WittVector p R\n⊢ Eq (WittVector.constantCoeff x) (x.coeff 0)","decl":"/-- `WittVector.coeff x 0` as a `RingHom` -/\n@[simps]\nnoncomputable def constantCoeff : 𝕎 R →+* R where\n  toFun x := x.coeff 0\n  map_zero' := by simp\n  map_one' := by simp\n  map_add' := add_coeff_zero\n  map_mul' := mul_coeff_zero\n\n"}
{"name":"WittVector.instNontrivial","module":"Mathlib.RingTheory.WittVector.Basic","initialProofState":"p : Nat\nR : Type u_1\ninst✝² : CommRing R\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : Nontrivial R\n⊢ Nontrivial (WittVector p R)","decl":"instance [Nontrivial R] : Nontrivial (𝕎 R) :=\n  constantCoeff.domain_nontrivial\n\n"}
