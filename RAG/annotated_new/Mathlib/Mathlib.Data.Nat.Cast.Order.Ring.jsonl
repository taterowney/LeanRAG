{"name":"Nat.cast_nonneg","module":"Mathlib.Data.Nat.Cast.Order.Ring","initialProofState":"α : Type u_2\ninst✝ : OrderedSemiring α\nn : Nat\n⊢ LE.le 0 ↑n","decl":"/-- Specialisation of `Nat.cast_nonneg'`, which seems to be easier for Lean to use. -/\n@[simp]\ntheorem cast_nonneg {α} [OrderedSemiring α] (n : ℕ) : 0 ≤ (n : α) :=\n  cast_nonneg' n\n\n"}
{"name":"Nat.ofNat_nonneg","module":"Mathlib.Data.Nat.Cast.Order.Ring","initialProofState":"α : Type u_2\ninst✝¹ : OrderedSemiring α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ LE.le 0 (OfNat.ofNat n)","decl":"/-- Specialisation of `Nat.ofNat_nonneg'`, which seems to be easier for Lean to use. -/\n@[simp]\ntheorem ofNat_nonneg {α} [OrderedSemiring α] (n : ℕ) [n.AtLeastTwo] :\n    0 ≤ (ofNat(n) : α) :=\n  ofNat_nonneg' n\n\n"}
{"name":"Nat.cast_min","module":"Mathlib.Data.Nat.Cast.Order.Ring","initialProofState":"α : Type u_2\ninst✝ : LinearOrderedSemiring α\nm n : Nat\n⊢ Eq (↑(Min.min m n)) (Min.min ↑m ↑n)","decl":"@[simp, norm_cast]\ntheorem cast_min {α} [LinearOrderedSemiring α] (m n : ℕ) : (↑(min m n : ℕ) : α) = min (m : α) n :=\n  (@mono_cast α _).map_min\n\n"}
{"name":"Nat.cast_max","module":"Mathlib.Data.Nat.Cast.Order.Ring","initialProofState":"α : Type u_2\ninst✝ : LinearOrderedSemiring α\nm n : Nat\n⊢ Eq (↑(Max.max m n)) (Max.max ↑m ↑n)","decl":"@[simp, norm_cast]\ntheorem cast_max {α} [LinearOrderedSemiring α] (m n : ℕ) : (↑(max m n : ℕ) : α) = max (m : α) n :=\n  (@mono_cast α _).map_max\n\n"}
{"name":"Nat.cast_pos","module":"Mathlib.Data.Nat.Cast.Order.Ring","initialProofState":"α : Type u_2\ninst✝¹ : OrderedSemiring α\ninst✝ : Nontrivial α\nn : Nat\n⊢ Iff (LT.lt 0 ↑n) (LT.lt 0 n)","decl":"/-- Specialisation of `Nat.cast_pos'`, which seems to be easier for Lean to use. -/\n@[simp]\ntheorem cast_pos {α} [OrderedSemiring α] [Nontrivial α] {n : ℕ} : (0 : α) < n ↔ 0 < n := cast_pos'\n\n"}
{"name":"Nat.ofNat_pos'","module":"Mathlib.Data.Nat.Cast.Order.Ring","initialProofState":"α : Type u_1\ninst✝⁵ : AddMonoidWithOne α\ninst✝⁴ : PartialOrder α\ninst✝³ : AddLeftMono α\ninst✝² : ZeroLEOneClass α\ninst✝¹ : NeZero 1\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ LT.lt 0 (OfNat.ofNat n)","decl":"/-- See also `Nat.ofNat_pos`, specialised for an `OrderedSemiring`. -/\n@[simp low]\ntheorem ofNat_pos' {n : ℕ} [n.AtLeastTwo] : 0 < (ofNat(n) : α) :=\n  cast_pos'.mpr (NeZero.pos n)\n\n"}
{"name":"Nat.ofNat_pos","module":"Mathlib.Data.Nat.Cast.Order.Ring","initialProofState":"α : Type u_2\ninst✝² : OrderedSemiring α\ninst✝¹ : Nontrivial α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ LT.lt 0 (OfNat.ofNat n)","decl":"/-- Specialisation of `Nat.ofNat_pos'`, which seems to be easier for Lean to use. -/\n@[simp]\ntheorem ofNat_pos {α} [OrderedSemiring α] [Nontrivial α] {n : ℕ} [n.AtLeastTwo] :\n    0 < (ofNat(n) : α) :=\n  ofNat_pos'\n\n"}
{"name":"Nat.cast_tsub","module":"Mathlib.Data.Nat.Cast.Order.Ring","initialProofState":"α : Type u_1\ninst✝⁴ : OrderedCommSemiring α\ninst✝³ : CanonicallyOrderedAdd α\ninst✝² : Sub α\ninst✝¹ : OrderedSub α\ninst✝ : AddLeftReflectLE α\nm n : Nat\n⊢ Eq (↑(HSub.hSub m n)) (HSub.hSub ↑m ↑n)","decl":"/-- A version of `Nat.cast_sub` that works for `ℝ≥0` and `ℚ≥0`. Note that this proof doesn't work\nfor `ℕ∞` and `ℝ≥0∞`, so we use type-specific lemmas for these types. -/\n@[simp, norm_cast]\ntheorem cast_tsub [OrderedCommSemiring α] [CanonicallyOrderedAdd α] [Sub α] [OrderedSub α]\n    [AddLeftReflectLE α] (m n : ℕ) : ↑(m - n) = (m - n : α) := by\n  rcases le_total m n with h | h\n  · rw [Nat.sub_eq_zero_of_le h, cast_zero, tsub_eq_zero_of_le]\n    exact mono_cast h\n  · rcases le_iff_exists_add'.mp h with ⟨m, rfl⟩\n    rw [add_tsub_cancel_right, cast_add, add_tsub_cancel_right]\n\n"}
{"name":"Nat.abs_cast","module":"Mathlib.Data.Nat.Cast.Order.Ring","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedRing α\na : Nat\n⊢ Eq (abs ↑a) ↑a","decl":"@[simp, norm_cast]\ntheorem abs_cast [LinearOrderedRing α] (a : ℕ) : |(a : α)| = a :=\n  abs_of_nonneg (cast_nonneg a)\n\n"}
{"name":"Nat.abs_ofNat","module":"Mathlib.Data.Nat.Cast.Order.Ring","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedRing α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (abs (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp]\ntheorem abs_ofNat [LinearOrderedRing α] (n : ℕ) [n.AtLeastTwo] :\n    |(ofNat(n) : α)| = ofNat(n) :=\n  abs_cast n\n\n"}
{"name":"Nat.mul_le_pow","module":"Mathlib.Data.Nat.Cast.Order.Ring","initialProofState":"a : Nat\nha : Ne a 1\nb : Nat\n⊢ LE.le (HMul.hMul a b) (HPow.hPow a b)","decl":"lemma mul_le_pow {a : ℕ} (ha : a ≠ 1) (b : ℕ) :\n    a * b ≤ a ^ b := by\n  induction b generalizing a with\n  | zero => simp\n  | succ b hb =>\n    rw [mul_add_one, pow_succ]\n    rcases a with (_|_|a)\n    · simp\n    · simp at ha\n    · rw [mul_add_one, mul_add_one, add_comm (_ * a), add_assoc _ (_ * a)]\n      rcases b with (_|b)\n      · simp [add_assoc, add_comm]\n      refine add_le_add (hb (by simp)) ?_\n      rw [pow_succ']\n      refine (le_add_left ?_ ?_).trans' ?_\n      exact le_mul_of_one_le_right' (one_le_pow _ _ (by simp))\n\n"}
{"name":"Nat.two_mul_sq_add_one_le_two_pow_two_mul","module":"Mathlib.Data.Nat.Cast.Order.Ring","initialProofState":"k : Nat\n⊢ LE.le (HAdd.hAdd (HMul.hMul 2 (HPow.hPow k 2)) 1) (HPow.hPow 2 (HMul.hMul 2 k))","decl":"lemma two_mul_sq_add_one_le_two_pow_two_mul (k : ℕ) : 2 * k ^ 2 + 1 ≤ 2 ^ (2 * k) := by\n  induction k with\n  | zero => simp\n  | succ k hk =>\n    rw [add_pow_two, one_pow, mul_one, add_assoc, mul_add, add_right_comm]\n    refine (add_le_add_right hk _).trans ?_\n    rw [mul_add 2 k, pow_add, mul_one, pow_two, ← mul_assoc, mul_two, mul_two, add_assoc]\n    gcongr\n    rw [← two_mul, ← pow_succ']\n    exact le_add_of_le_right (mul_le_pow (by simp) _)\n\n"}
