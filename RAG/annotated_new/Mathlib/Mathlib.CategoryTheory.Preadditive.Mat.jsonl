{"name":"CategoryTheory.Mat_.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝ : SizeOf C\nι : Type\nfintype : Fintype ι\nX : ι → C\n⊢ Eq (SizeOf.sizeOf (CategoryTheory.Mat_.mk ι X)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf ι)) (SizeOf.sizeOf fintype))","decl":"/-- An object in `Mat_ C` is a finite tuple of objects in `C`.\n-/\nstructure Mat_ where\n  ι : Type\n  [fintype : Fintype ι]\n  X : ι → C\n\n"}
{"name":"CategoryTheory.Mat_.mk.injEq","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\nι✝ : Type\nfintype✝ : Fintype ι✝\nX✝ : ι✝ → C\nι : Type\nfintype : Fintype ι\nX : ι → C\n⊢ Eq (Eq (CategoryTheory.Mat_.mk ι✝ X✝) (CategoryTheory.Mat_.mk ι X)) (And (Eq ι✝ ι) (And (HEq fintype✝ fintype) (HEq X✝ X)))","decl":"/-- An object in `Mat_ C` is a finite tuple of objects in `C`.\n-/\nstructure Mat_ where\n  ι : Type\n  [fintype : Fintype ι]\n  X : ι → C\n\n"}
{"name":"CategoryTheory.Mat_.mk.inj","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\nι✝ : Type\nfintype✝ : Fintype ι✝\nX✝ : ι✝ → C\nι : Type\nfintype : Fintype ι\nX : ι → C\nx✝ : Eq (CategoryTheory.Mat_.mk ι✝ X✝) (CategoryTheory.Mat_.mk ι X)\n⊢ And (Eq ι✝ ι) (And (HEq fintype✝ fintype) (HEq X✝ X))","decl":"/-- An object in `Mat_ C` is a finite tuple of objects in `C`.\n-/\nstructure Mat_ where\n  ι : Type\n  [fintype : Fintype ι]\n  X : ι → C\n\n"}
{"name":"CategoryTheory.Mat_.hom_ext_iff","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\nM N : CategoryTheory.Mat_ C\nf g : Quiver.Hom M N\n⊢ Iff (Eq f g) (∀ (i : M.ι) (j : N.ι), Eq (f i j) (g i j))","decl":"@[ext]\ntheorem hom_ext {M N : Mat_ C} (f g : M ⟶ N) (H : ∀ i j, f i j = g i j) : f = g :=\n  DMatrix.ext_iff.mp H\n\n"}
{"name":"CategoryTheory.Mat_.hom_ext","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\nM N : CategoryTheory.Mat_ C\nf g : Quiver.Hom M N\nH : ∀ (i : M.ι) (j : N.ι), Eq (f i j) (g i j)\n⊢ Eq f g","decl":"@[ext]\ntheorem hom_ext {M N : Mat_ C} (f g : M ⟶ N) (H : ∀ i j, f i j = g i j) : f = g :=\n  DMatrix.ext_iff.mp H\n\n"}
{"name":"CategoryTheory.Mat_.id_def","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\nM : CategoryTheory.Mat_ C\n⊢ Eq (CategoryTheory.CategoryStruct.id M) fun i j => dite (Eq i j) (fun h => CategoryTheory.eqToHom ⋯) fun h => 0","decl":"open scoped Classical in\ntheorem id_def (M : Mat_ C) :\n    (𝟙 M : Hom M M) = fun i j => if h : i = j then eqToHom (congr_arg M.X h) else 0 :=\n  rfl\n\n"}
{"name":"CategoryTheory.Mat_.id_apply","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\nM : CategoryTheory.Mat_ C\ni j : M.ι\n⊢ Eq (CategoryTheory.CategoryStruct.id M i j) (dite (Eq i j) (fun h => CategoryTheory.eqToHom ⋯) fun h => 0)","decl":"open scoped Classical in\ntheorem id_apply (M : Mat_ C) (i j : M.ι) :\n    (𝟙 M : Hom M M) i j = if h : i = j then eqToHom (congr_arg M.X h) else 0 :=\n  rfl\n\n"}
{"name":"CategoryTheory.Mat_.id_apply_self","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\nM : CategoryTheory.Mat_ C\ni : M.ι\n⊢ Eq (CategoryTheory.CategoryStruct.id M i i) (CategoryTheory.CategoryStruct.id (M.X i))","decl":"@[simp]\ntheorem id_apply_self (M : Mat_ C) (i : M.ι) : (𝟙 M : Hom M M) i i = 𝟙 _ := by simp [id_apply]\n\n"}
{"name":"CategoryTheory.Mat_.id_apply_of_ne","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\nM : CategoryTheory.Mat_ C\ni j : M.ι\nh : Ne i j\n⊢ Eq (CategoryTheory.CategoryStruct.id M i j) 0","decl":"@[simp]\ntheorem id_apply_of_ne (M : Mat_ C) (i j : M.ι) (h : i ≠ j) : (𝟙 M : Hom M M) i j = 0 := by\n  simp [id_apply, h]\n\n"}
{"name":"CategoryTheory.Mat_.comp_def","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\nM N K : CategoryTheory.Mat_ C\nf : Quiver.Hom M N\ng : Quiver.Hom N K\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g) fun i k => Finset.univ.sum fun j => CategoryTheory.CategoryStruct.comp (f i j) (g j k)","decl":"theorem comp_def {M N K : Mat_ C} (f : M ⟶ N) (g : N ⟶ K) :\n    f ≫ g = fun i k => ∑ j : N.ι, f i j ≫ g j k :=\n  rfl\n\n"}
{"name":"CategoryTheory.Mat_.comp_apply","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\nM N K : CategoryTheory.Mat_ C\nf : Quiver.Hom M N\ng : Quiver.Hom N K\ni : M.ι\nk : K.ι\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g i k) (Finset.univ.sum fun j => CategoryTheory.CategoryStruct.comp (f i j) (g j k))","decl":"@[simp]\ntheorem comp_apply {M N K : Mat_ C} (f : M ⟶ N) (g : N ⟶ K) (i k) :\n    (f ≫ g) i k = ∑ j : N.ι, f i j ≫ g j k :=\n  rfl\n\n"}
{"name":"CategoryTheory.Mat_.add_apply","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\nM N : CategoryTheory.Mat_ C\nf g : Quiver.Hom M N\ni : M.ι\nj : N.ι\n⊢ Eq (HAdd.hAdd f g i j) (HAdd.hAdd (f i j) (g i j))","decl":"@[simp]\ntheorem add_apply {M N : Mat_ C} (f g : M ⟶ N) (i j) : (f + g) i j = f i j + g i j :=\n  rfl\n\n"}
{"name":"CategoryTheory.Mat_.hasFiniteBiproducts","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\n⊢ CategoryTheory.Limits.HasFiniteBiproducts (CategoryTheory.Mat_ C)","decl":"open scoped Classical in\n/-- We now prove that `Mat_ C` has finite biproducts.\n\nBe warned, however, that `Mat_ C` is not necessarily Krull-Schmidt,\nand so the internal indexing of a biproduct may have nothing to do with the external indexing,\neven though the construction we give uses a sigma type.\nSee however `isoBiproductEmbedding`.\n-/\ninstance hasFiniteBiproducts : HasFiniteBiproducts (Mat_ C) where\n  out n :=\n    { has_biproduct := fun f =>\n        hasBiproduct_of_total\n          { pt := ⟨Σ j, (f j).ι, fun p => (f p.1).X p.2⟩\n            π := fun j x y => by\n              refine if h : x.1 = j then ?_ else 0\n              refine if h' : @Eq.ndrec (Fin n) x.1 (fun j => (f j).ι) x.2 _ h = y then ?_ else 0\n              apply eqToHom\n              substs h h'\n              rfl\n            -- Notice we were careful not to use `subst` until we had a goal in `Prop`.\n            ι := fun j x y => by\n              refine if h : y.1 = j then ?_ else 0\n              refine if h' : @Eq.ndrec _ y.1 (fun j => (f j).ι) y.2 _ h = x then ?_ else 0\n              apply eqToHom\n              substs h h'\n              rfl\n            ι_π := fun j j' => by\n              ext x y\n              dsimp\n              simp_rw [dite_comp, comp_dite]\n              simp only [ite_self, dite_eq_ite, Limits.comp_zero, Limits.zero_comp,\n                eqToHom_trans, Finset.sum_congr]\n              erw [Finset.sum_sigma]\n              dsimp\n              simp only [if_true, Finset.sum_dite_irrel, Finset.mem_univ,\n                Finset.sum_const_zero, Finset.sum_congr, Finset.sum_dite_eq']\n              split_ifs with h h'\n              · substs h h'\n                simp only [CategoryTheory.eqToHom_refl, CategoryTheory.Mat_.id_apply_self]\n              · subst h\n                rw [eqToHom_refl, id_apply_of_ne _ _ _ h']\n              · rfl }\n          (by\n            dsimp\n            ext1 ⟨i, j⟩\n            rintro ⟨i', j'⟩\n            rw [Finset.sum_apply, Finset.sum_apply]\n            dsimp\n            rw [Finset.sum_eq_single i]; rotate_left\n            · intro b _ hb\n              apply Finset.sum_eq_zero\n              intro x _\n              rw [dif_neg hb.symm, zero_comp]\n            · intro hi\n              simp at hi\n            rw [Finset.sum_eq_single j]; rotate_left\n            · intro b _ hb\n              rw [dif_pos rfl, dif_neg, zero_comp]\n              simp only\n              tauto\n            · intro hj\n              simp at hj\n            simp only [eqToHom_refl, dite_eq_ite, ite_true, Category.id_comp, ne_eq,\n              Sigma.mk.inj_iff, not_and, id_def]\n            by_cases h : i' = i\n            · subst h\n              rw [dif_pos rfl]\n              simp only [heq_eq_eq, true_and]\n              by_cases h : j' = j\n              · subst h\n                simp\n              · rw [dif_neg h, dif_neg (Ne.symm h)]\n            · rw [dif_neg h, dif_neg]\n              tauto) }\n\n"}
{"name":"CategoryTheory.Functor.mapMat__obj_fintype","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Preadditive C\nD : Type u_1\ninst✝² : CategoryTheory.Category.{v₁, u_1} D\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nM : CategoryTheory.Mat_ C\n⊢ Eq (F.mapMat_.obj M).fintype M.fintype","decl":"/-- A functor induces a functor of matrix categories.\n-/\n@[simps]\ndef mapMat_ (F : C ⥤ D) [Functor.Additive F] : Mat_ C ⥤ Mat_ D where\n  obj M := ⟨M.ι, fun i => F.obj (M.X i)⟩\n  map f i j := F.map (f i j)\n\n"}
{"name":"CategoryTheory.Functor.mapMat__map","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Preadditive C\nD : Type u_1\ninst✝² : CategoryTheory.Category.{v₁, u_1} D\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nX✝ Y✝ : CategoryTheory.Mat_ C\nf : Quiver.Hom X✝ Y✝\ni : ((fun M => CategoryTheory.Mat_.mk M.ι fun i => F.obj (M.X i)) X✝).ι\nj : ((fun M => CategoryTheory.Mat_.mk M.ι fun i => F.obj (M.X i)) Y✝).ι\n⊢ Eq (F.mapMat_.map f i j) (F.map (f i j))","decl":"/-- A functor induces a functor of matrix categories.\n-/\n@[simps]\ndef mapMat_ (F : C ⥤ D) [Functor.Additive F] : Mat_ C ⥤ Mat_ D where\n  obj M := ⟨M.ι, fun i => F.obj (M.X i)⟩\n  map f i j := F.map (f i j)\n\n"}
{"name":"CategoryTheory.Functor.mapMat__obj_ι","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Preadditive C\nD : Type u_1\ninst✝² : CategoryTheory.Category.{v₁, u_1} D\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nM : CategoryTheory.Mat_ C\n⊢ Eq (F.mapMat_.obj M).ι M.ι","decl":"/-- A functor induces a functor of matrix categories.\n-/\n@[simps]\ndef mapMat_ (F : C ⥤ D) [Functor.Additive F] : Mat_ C ⥤ Mat_ D where\n  obj M := ⟨M.ι, fun i => F.obj (M.X i)⟩\n  map f i j := F.map (f i j)\n\n"}
{"name":"CategoryTheory.Functor.mapMat__obj_X","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Preadditive C\nD : Type u_1\ninst✝² : CategoryTheory.Category.{v₁, u_1} D\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nM : CategoryTheory.Mat_ C\ni : M.ι\n⊢ Eq ((F.mapMat_.obj M).X i) (F.obj (M.X i))","decl":"/-- A functor induces a functor of matrix categories.\n-/\n@[simps]\ndef mapMat_ (F : C ⥤ D) [Functor.Additive F] : Mat_ C ⥤ Mat_ D where\n  obj M := ⟨M.ι, fun i => F.obj (M.X i)⟩\n  map f i j := F.map (f i j)\n\n"}
{"name":"CategoryTheory.Functor.mapMatId_hom_app","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\nX : CategoryTheory.Mat_ C\n⊢ Eq (CategoryTheory.Functor.mapMatId.hom.app X) (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.id C).mapMat_.obj X))","decl":"/-- The identity functor induces the identity functor on matrix categories.\n-/\n@[simps!]\ndef mapMatId : (𝟭 C).mapMat_ ≅ 𝟭 (Mat_ C) :=\n  NatIso.ofComponents (fun M => eqToIso (by cases M; rfl)) fun {M N} f => by\n    classical\n    ext\n    cases M; cases N\n    simp [comp_dite, dite_comp]\n\n"}
{"name":"CategoryTheory.Functor.mapMatId_inv_app","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\nX : CategoryTheory.Mat_ C\n⊢ Eq (CategoryTheory.Functor.mapMatId.inv.app X) (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.id C).mapMat_.obj X))","decl":"/-- The identity functor induces the identity functor on matrix categories.\n-/\n@[simps!]\ndef mapMatId : (𝟭 C).mapMat_ ≅ 𝟭 (Mat_ C) :=\n  NatIso.ofComponents (fun M => eqToIso (by cases M; rfl)) fun {M N} f => by\n    classical\n    ext\n    cases M; cases N\n    simp [comp_dite, dite_comp]\n\n"}
{"name":"CategoryTheory.Functor.mapMatComp_inv_app","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁶ : CategoryTheory.Preadditive C\nD : Type u_1\ninst✝⁵ : CategoryTheory.Category.{v₁, u_1} D\ninst✝⁴ : CategoryTheory.Preadditive D\nE : Type u_2\ninst✝³ : CategoryTheory.Category.{v₁, u_2} E\ninst✝² : CategoryTheory.Preadditive E\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Additive\nG : CategoryTheory.Functor D E\ninst✝ : G.Additive\nX : CategoryTheory.Mat_ C\n⊢ Eq ((F.mapMatComp G).inv.app X) (CategoryTheory.CategoryStruct.id ((F.comp G).mapMat_.obj X))","decl":"/-- Composite functors induce composite functors on matrix categories.\n-/\n@[simps!]\ndef mapMatComp {E : Type*} [Category.{v₁} E] [Preadditive E] (F : C ⥤ D) [Functor.Additive F]\n    (G : D ⥤ E) [Functor.Additive G] : (F ⋙ G).mapMat_ ≅ F.mapMat_ ⋙ G.mapMat_ :=\n  NatIso.ofComponents (fun M => eqToIso (by cases M; rfl)) fun {M N} f => by\n    classical\n    ext\n    cases M; cases N\n    simp [comp_dite, dite_comp]\n\n"}
{"name":"CategoryTheory.Functor.mapMatComp_hom_app","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁶ : CategoryTheory.Preadditive C\nD : Type u_1\ninst✝⁵ : CategoryTheory.Category.{v₁, u_1} D\ninst✝⁴ : CategoryTheory.Preadditive D\nE : Type u_2\ninst✝³ : CategoryTheory.Category.{v₁, u_2} E\ninst✝² : CategoryTheory.Preadditive E\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Additive\nG : CategoryTheory.Functor D E\ninst✝ : G.Additive\nX : CategoryTheory.Mat_ C\n⊢ Eq ((F.mapMatComp G).hom.app X) (CategoryTheory.CategoryStruct.id ((F.comp G).mapMat_.obj X))","decl":"/-- Composite functors induce composite functors on matrix categories.\n-/\n@[simps!]\ndef mapMatComp {E : Type*} [Category.{v₁} E] [Preadditive E] (F : C ⥤ D) [Functor.Additive F]\n    (G : D ⥤ E) [Functor.Additive G] : (F ⋙ G).mapMat_ ≅ F.mapMat_ ⋙ G.mapMat_ :=\n  NatIso.ofComponents (fun M => eqToIso (by cases M; rfl)) fun {M N} f => by\n    classical\n    ext\n    cases M; cases N\n    simp [comp_dite, dite_comp]\n\n"}
{"name":"CategoryTheory.Mat_.embedding_obj_ι","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\nX : C\n⊢ Eq ((CategoryTheory.Mat_.embedding C).obj X).ι PUnit.{1}","decl":"/-- The embedding of `C` into `Mat_ C` as one-by-one matrices.\n(We index the summands by `PUnit`.) -/\n@[simps]\ndef embedding : C ⥤ Mat_ C where\n  obj X := ⟨PUnit, fun _ => X⟩\n  map f _ _ := f\n  map_id _ := by ext ⟨⟩; simp\n  map_comp _ _ := by ext ⟨⟩; simp\n\n"}
{"name":"CategoryTheory.Mat_.embedding_map","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\nx✝¹ : ((fun X => CategoryTheory.Mat_.mk PUnit.{1} fun x => X) X✝).ι\nx✝ : ((fun X => CategoryTheory.Mat_.mk PUnit.{1} fun x => X) Y✝).ι\n⊢ Eq ((CategoryTheory.Mat_.embedding C).map f x✝¹ x✝) f","decl":"/-- The embedding of `C` into `Mat_ C` as one-by-one matrices.\n(We index the summands by `PUnit`.) -/\n@[simps]\ndef embedding : C ⥤ Mat_ C where\n  obj X := ⟨PUnit, fun _ => X⟩\n  map f _ _ := f\n  map_id _ := by ext ⟨⟩; simp\n  map_comp _ _ := by ext ⟨⟩; simp\n\n"}
{"name":"CategoryTheory.Mat_.embedding_obj_fintype","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\nX : C\n⊢ Eq ((CategoryTheory.Mat_.embedding C).obj X).fintype PUnit.fintype","decl":"/-- The embedding of `C` into `Mat_ C` as one-by-one matrices.\n(We index the summands by `PUnit`.) -/\n@[simps]\ndef embedding : C ⥤ Mat_ C where\n  obj X := ⟨PUnit, fun _ => X⟩\n  map f _ _ := f\n  map_id _ := by ext ⟨⟩; simp\n  map_comp _ _ := by ext ⟨⟩; simp\n\n"}
{"name":"CategoryTheory.Mat_.embedding_obj_X","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\nX : C\nx✝ : PUnit.{1}\n⊢ Eq (((CategoryTheory.Mat_.embedding C).obj X).X x✝) X","decl":"/-- The embedding of `C` into `Mat_ C` as one-by-one matrices.\n(We index the summands by `PUnit`.) -/\n@[simps]\ndef embedding : C ⥤ Mat_ C where\n  obj X := ⟨PUnit, fun _ => X⟩\n  map f _ _ := f\n  map_id _ := by ext ⟨⟩; simp\n  map_comp _ _ := by ext ⟨⟩; simp\n\n"}
{"name":"CategoryTheory.Mat_.Embedding.instFaithfulEmbedding","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\n⊢ (CategoryTheory.Mat_.embedding C).Faithful","decl":"instance : (embedding C).Faithful where\n  map_injective h := congr_fun (congr_fun h PUnit.unit) PUnit.unit\n\n"}
{"name":"CategoryTheory.Mat_.Embedding.instFullEmbedding","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\n⊢ (CategoryTheory.Mat_.embedding C).Full","decl":"instance : (embedding C).Full where map_surjective f := ⟨f PUnit.unit PUnit.unit, rfl⟩\n\n"}
{"name":"CategoryTheory.Mat_.Embedding.instAdditiveEmbedding","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\n⊢ (CategoryTheory.Mat_.embedding C).Additive","decl":"instance : Functor.Additive (embedding C) where\n\n"}
{"name":"CategoryTheory.Mat_.isoBiproductEmbedding_inv","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\nM : CategoryTheory.Mat_ C\n⊢ Eq M.isoBiproductEmbedding.inv (CategoryTheory.Limits.biproduct.desc fun i x k => dite (Eq i k) (fun h => CategoryTheory.eqToHom ⋯) fun h => 0)","decl":"open scoped Classical in\n/-- Every object in `Mat_ C` is isomorphic to the biproduct of its summands.\n-/\n@[simps]\ndef isoBiproductEmbedding (M : Mat_ C) : M ≅ ⨁ fun i => (embedding C).obj (M.X i) where\n  hom := biproduct.lift fun i j _ => if h : j = i then eqToHom (congr_arg M.X h) else 0\n  inv := biproduct.desc fun i _ k => if h : i = k then eqToHom (congr_arg M.X h) else 0\n  hom_inv_id := by\n    simp only [biproduct.lift_desc]\n    funext i j\n    dsimp [id_def]\n    rw [Finset.sum_apply, Finset.sum_apply, Finset.sum_eq_single i]; rotate_left\n    · intro b _ hb\n      dsimp\n      rw [Fintype.univ_ofSubsingleton, Finset.sum_singleton, dif_neg hb.symm, zero_comp]\n    · intro h\n      simp at h\n    simp\n  inv_hom_id := by\n    apply biproduct.hom_ext\n    intro i\n    apply biproduct.hom_ext'\n    intro j\n    simp only [Category.id_comp, Category.assoc, biproduct.lift_π, biproduct.ι_desc_assoc,\n      biproduct.ι_π]\n    ext ⟨⟩ ⟨⟩\n    simp only [embedding, comp_apply, comp_dite, dite_comp, comp_zero, zero_comp,\n      Finset.sum_dite_eq', Finset.mem_univ, ite_true, eqToHom_refl, Category.comp_id]\n    split_ifs with h\n    · subst h\n      simp\n    · rfl\n\n"}
{"name":"CategoryTheory.Mat_.isoBiproductEmbedding_hom","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\nM : CategoryTheory.Mat_ C\n⊢ Eq M.isoBiproductEmbedding.hom (CategoryTheory.Limits.biproduct.lift fun i j x => dite (Eq j i) (fun h => CategoryTheory.eqToHom ⋯) fun h => 0)","decl":"open scoped Classical in\n/-- Every object in `Mat_ C` is isomorphic to the biproduct of its summands.\n-/\n@[simps]\ndef isoBiproductEmbedding (M : Mat_ C) : M ≅ ⨁ fun i => (embedding C).obj (M.X i) where\n  hom := biproduct.lift fun i j _ => if h : j = i then eqToHom (congr_arg M.X h) else 0\n  inv := biproduct.desc fun i _ k => if h : i = k then eqToHom (congr_arg M.X h) else 0\n  hom_inv_id := by\n    simp only [biproduct.lift_desc]\n    funext i j\n    dsimp [id_def]\n    rw [Finset.sum_apply, Finset.sum_apply, Finset.sum_eq_single i]; rotate_left\n    · intro b _ hb\n      dsimp\n      rw [Fintype.univ_ofSubsingleton, Finset.sum_singleton, dif_neg hb.symm, zero_comp]\n    · intro h\n      simp at h\n    simp\n  inv_hom_id := by\n    apply biproduct.hom_ext\n    intro i\n    apply biproduct.hom_ext'\n    intro j\n    simp only [Category.id_comp, Category.assoc, biproduct.lift_π, biproduct.ι_desc_assoc,\n      biproduct.ι_π]\n    ext ⟨⟩ ⟨⟩\n    simp only [embedding, comp_apply, comp_dite, dite_comp, comp_zero, zero_comp,\n      Finset.sum_dite_eq', Finset.mem_univ, ite_true, eqToHom_refl, Category.comp_id]\n    split_ifs with h\n    · subst h\n      simp\n    · rfl\n\n"}
{"name":"CategoryTheory.Mat_.instHasBiproductιObjEmbeddingXOfAdditive","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Preadditive C\nD : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} D\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor (CategoryTheory.Mat_ C) D\ninst✝ : F.Additive\nM : CategoryTheory.Mat_ C\n⊢ CategoryTheory.Limits.HasBiproduct fun i => F.obj ((CategoryTheory.Mat_.embedding C).obj (M.X i))","decl":"instance (F : Mat_ C ⥤ D) [Functor.Additive F] (M : Mat_ C) :\n    HasBiproduct (fun i => F.obj ((embedding C).obj (M.X i))) :=\n  F.hasBiproduct_of_preserves _\n\n-- Porting note: removed the @[simps] attribute as the automatically generated lemmas\n-- are not very useful; two more useful lemmas have been added just after this\n-- definition in order to ease the proof of `additiveObjIsoBiproduct_naturality`\n"}
{"name":"CategoryTheory.Mat_.additiveObjIsoBiproduct_hom_π","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Preadditive C\nD : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} D\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor (CategoryTheory.Mat_ C) D\ninst✝ : F.Additive\nM : CategoryTheory.Mat_ C\ni : M.ι\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Mat_.additiveObjIsoBiproduct F M).hom (CategoryTheory.Limits.biproduct.π (fun i => F.obj ((CategoryTheory.Mat_.embedding C).obj (M.X i))) i)) (F.map (CategoryTheory.CategoryStruct.comp M.isoBiproductEmbedding.hom (CategoryTheory.Limits.biproduct.π (fun i => (CategoryTheory.Mat_.embedding C).obj (M.X i)) i)))","decl":"@[reassoc (attr := simp)]\nlemma additiveObjIsoBiproduct_hom_π (F : Mat_ C ⥤ D) [Functor.Additive F] (M : Mat_ C) (i : M.ι) :\n    (additiveObjIsoBiproduct F M).hom ≫ biproduct.π _ i =\n      F.map (M.isoBiproductEmbedding.hom ≫ biproduct.π _ i) := by\n  dsimp [additiveObjIsoBiproduct]\n  rw [biproduct.lift_π, Category.assoc]\n  erw [biproduct.lift_π, ← F.map_comp]\n  simp\n\n"}
{"name":"CategoryTheory.Mat_.additiveObjIsoBiproduct_hom_π_assoc","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Preadditive C\nD : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} D\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor (CategoryTheory.Mat_ C) D\ninst✝ : F.Additive\nM : CategoryTheory.Mat_ C\ni : M.ι\nZ : D\nh : Quiver.Hom (F.obj ((CategoryTheory.Mat_.embedding C).obj (M.X i))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Mat_.additiveObjIsoBiproduct F M).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.π (fun i => F.obj ((CategoryTheory.Mat_.embedding C).obj (M.X i))) i) h)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.CategoryStruct.comp M.isoBiproductEmbedding.hom (CategoryTheory.Limits.biproduct.π (fun i => (CategoryTheory.Mat_.embedding C).obj (M.X i)) i))) h)","decl":"@[reassoc (attr := simp)]\nlemma additiveObjIsoBiproduct_hom_π (F : Mat_ C ⥤ D) [Functor.Additive F] (M : Mat_ C) (i : M.ι) :\n    (additiveObjIsoBiproduct F M).hom ≫ biproduct.π _ i =\n      F.map (M.isoBiproductEmbedding.hom ≫ biproduct.π _ i) := by\n  dsimp [additiveObjIsoBiproduct]\n  rw [biproduct.lift_π, Category.assoc]\n  erw [biproduct.lift_π, ← F.map_comp]\n  simp\n\n"}
{"name":"CategoryTheory.Mat_.ι_additiveObjIsoBiproduct_inv","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Preadditive C\nD : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} D\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor (CategoryTheory.Mat_ C) D\ninst✝ : F.Additive\nM : CategoryTheory.Mat_ C\ni : M.ι\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι (fun i => F.obj ((CategoryTheory.Mat_.embedding C).obj (M.X i))) i) (CategoryTheory.Mat_.additiveObjIsoBiproduct F M).inv) (F.map (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι (fun i => (CategoryTheory.Mat_.embedding C).obj (M.X i)) i) M.isoBiproductEmbedding.inv))","decl":"@[reassoc (attr := simp)]\nlemma ι_additiveObjIsoBiproduct_inv (F : Mat_ C ⥤ D) [Functor.Additive F] (M : Mat_ C) (i : M.ι) :\n    biproduct.ι _ i ≫ (additiveObjIsoBiproduct F M).inv =\n      F.map (biproduct.ι _ i ≫ M.isoBiproductEmbedding.inv) := by\n  dsimp [additiveObjIsoBiproduct, Functor.mapBiproduct, Functor.mapBicone]\n  simp only [biproduct.ι_desc, biproduct.ι_desc_assoc, ← F.map_comp]\n\n"}
{"name":"CategoryTheory.Mat_.ι_additiveObjIsoBiproduct_inv_assoc","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Preadditive C\nD : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} D\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor (CategoryTheory.Mat_ C) D\ninst✝ : F.Additive\nM : CategoryTheory.Mat_ C\ni : M.ι\nZ : D\nh : Quiver.Hom (F.obj M) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι (fun i => F.obj ((CategoryTheory.Mat_.embedding C).obj (M.X i))) i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Mat_.additiveObjIsoBiproduct F M).inv h)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι (fun i => (CategoryTheory.Mat_.embedding C).obj (M.X i)) i) M.isoBiproductEmbedding.inv)) h)","decl":"@[reassoc (attr := simp)]\nlemma ι_additiveObjIsoBiproduct_inv (F : Mat_ C ⥤ D) [Functor.Additive F] (M : Mat_ C) (i : M.ι) :\n    biproduct.ι _ i ≫ (additiveObjIsoBiproduct F M).inv =\n      F.map (biproduct.ι _ i ≫ M.isoBiproductEmbedding.inv) := by\n  dsimp [additiveObjIsoBiproduct, Functor.mapBiproduct, Functor.mapBicone]\n  simp only [biproduct.ι_desc, biproduct.ι_desc_assoc, ← F.map_comp]\n\n"}
{"name":"CategoryTheory.Mat_.additiveObjIsoBiproduct_naturality_assoc","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.Preadditive C\nD : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} D\ninst✝² : CategoryTheory.Preadditive D\ninst✝¹ : CategoryTheory.Limits.HasFiniteBiproducts D\nF : CategoryTheory.Functor (CategoryTheory.Mat_ C) D\ninst✝ : F.Additive\nM N : CategoryTheory.Mat_ C\nf : Quiver.Hom M N\nZ : D\nh : Quiver.Hom (CategoryTheory.Limits.biproduct fun i => F.obj ((CategoryTheory.Mat_.embedding C).obj (N.X i))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Mat_.additiveObjIsoBiproduct F N).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Mat_.additiveObjIsoBiproduct F M).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.matrix fun i j => F.map ((CategoryTheory.Mat_.embedding C).map (f i j))) h))","decl":"@[reassoc]\ntheorem additiveObjIsoBiproduct_naturality (F : Mat_ C ⥤ D) [Functor.Additive F] {M N : Mat_ C}\n    (f : M ⟶ N) :\n    F.map f ≫ (additiveObjIsoBiproduct F N).hom =\n      (additiveObjIsoBiproduct F M).hom ≫\n        biproduct.matrix fun i j => F.map ((embedding C).map (f i j)) := by\n  classical\n  ext i : 1\n  simp only [Category.assoc, additiveObjIsoBiproduct_hom_π, isoBiproductEmbedding_hom,\n    embedding_obj_ι, embedding_obj_X, biproduct.lift_π, biproduct.matrix_π,\n    ← cancel_epi (additiveObjIsoBiproduct F M).inv, Iso.inv_hom_id_assoc]\n  ext j : 1\n  simp only [ι_additiveObjIsoBiproduct_inv_assoc, isoBiproductEmbedding_inv,\n    biproduct.ι_desc, ← F.map_comp]\n  congr 1\n  funext ⟨⟩ ⟨⟩\n  simp [comp_apply, dite_comp, comp_dite]\n\n"}
{"name":"CategoryTheory.Mat_.additiveObjIsoBiproduct_naturality","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.Preadditive C\nD : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} D\ninst✝² : CategoryTheory.Preadditive D\ninst✝¹ : CategoryTheory.Limits.HasFiniteBiproducts D\nF : CategoryTheory.Functor (CategoryTheory.Mat_ C) D\ninst✝ : F.Additive\nM N : CategoryTheory.Mat_ C\nf : Quiver.Hom M N\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map f) (CategoryTheory.Mat_.additiveObjIsoBiproduct F N).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Mat_.additiveObjIsoBiproduct F M).hom (CategoryTheory.Limits.biproduct.matrix fun i j => F.map ((CategoryTheory.Mat_.embedding C).map (f i j))))","decl":"@[reassoc]\ntheorem additiveObjIsoBiproduct_naturality (F : Mat_ C ⥤ D) [Functor.Additive F] {M N : Mat_ C}\n    (f : M ⟶ N) :\n    F.map f ≫ (additiveObjIsoBiproduct F N).hom =\n      (additiveObjIsoBiproduct F M).hom ≫\n        biproduct.matrix fun i j => F.map ((embedding C).map (f i j)) := by\n  classical\n  ext i : 1\n  simp only [Category.assoc, additiveObjIsoBiproduct_hom_π, isoBiproductEmbedding_hom,\n    embedding_obj_ι, embedding_obj_X, biproduct.lift_π, biproduct.matrix_π,\n    ← cancel_epi (additiveObjIsoBiproduct F M).inv, Iso.inv_hom_id_assoc]\n  ext j : 1\n  simp only [ι_additiveObjIsoBiproduct_inv_assoc, isoBiproductEmbedding_inv,\n    biproduct.ι_desc, ← F.map_comp]\n  congr 1\n  funext ⟨⟩ ⟨⟩\n  simp [comp_apply, dite_comp, comp_dite]\n\n"}
{"name":"CategoryTheory.Mat_.additiveObjIsoBiproduct_naturality'_assoc","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.Preadditive C\nD : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} D\ninst✝² : CategoryTheory.Preadditive D\ninst✝¹ : CategoryTheory.Limits.HasFiniteBiproducts D\nF : CategoryTheory.Functor (CategoryTheory.Mat_ C) D\ninst✝ : F.Additive\nM N : CategoryTheory.Mat_ C\nf : Quiver.Hom M N\nZ : D\nh : Quiver.Hom (F.obj N) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Mat_.additiveObjIsoBiproduct F M).inv (CategoryTheory.CategoryStruct.comp (F.map f) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.matrix fun i j => F.map ((CategoryTheory.Mat_.embedding C).map (f i j))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Mat_.additiveObjIsoBiproduct F N).inv h))","decl":"@[reassoc]\ntheorem additiveObjIsoBiproduct_naturality' (F : Mat_ C ⥤ D) [Functor.Additive F] {M N : Mat_ C}\n    (f : M ⟶ N) :\n    (additiveObjIsoBiproduct F M).inv ≫ F.map f =\n      biproduct.matrix (fun i j => F.map ((embedding C).map (f i j)) :) ≫\n        (additiveObjIsoBiproduct F N).inv := by\n  rw [Iso.inv_comp_eq, ← Category.assoc, Iso.eq_comp_inv, additiveObjIsoBiproduct_naturality]\n\n"}
{"name":"CategoryTheory.Mat_.additiveObjIsoBiproduct_naturality'","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.Preadditive C\nD : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} D\ninst✝² : CategoryTheory.Preadditive D\ninst✝¹ : CategoryTheory.Limits.HasFiniteBiproducts D\nF : CategoryTheory.Functor (CategoryTheory.Mat_ C) D\ninst✝ : F.Additive\nM N : CategoryTheory.Mat_ C\nf : Quiver.Hom M N\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Mat_.additiveObjIsoBiproduct F M).inv (F.map f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.matrix fun i j => F.map ((CategoryTheory.Mat_.embedding C).map (f i j))) (CategoryTheory.Mat_.additiveObjIsoBiproduct F N).inv)","decl":"@[reassoc]\ntheorem additiveObjIsoBiproduct_naturality' (F : Mat_ C ⥤ D) [Functor.Additive F] {M N : Mat_ C}\n    (f : M ⟶ N) :\n    (additiveObjIsoBiproduct F M).inv ≫ F.map f =\n      biproduct.matrix (fun i j => F.map ((embedding C).map (f i j)) :) ≫\n        (additiveObjIsoBiproduct F N).inv := by\n  rw [Iso.inv_comp_eq, ← Category.assoc, Iso.eq_comp_inv, additiveObjIsoBiproduct_naturality]\n\n"}
{"name":"CategoryTheory.Mat_.lift_map","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.Preadditive C\nD : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} D\ninst✝² : CategoryTheory.Preadditive D\ninst✝¹ : CategoryTheory.Limits.HasFiniteBiproducts D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nX✝ Y✝ : CategoryTheory.Mat_ C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Mat_.lift F).map f) (CategoryTheory.Limits.biproduct.matrix fun i j => F.map (f i j))","decl":"/-- Any additive functor `C ⥤ D` to a category `D` with finite biproducts extends to\na functor `Mat_ C ⥤ D`. -/\n@[simps]\ndef lift (F : C ⥤ D) [Functor.Additive F] : Mat_ C ⥤ D where\n  obj X := ⨁ fun i => F.obj (X.X i)\n  map f := biproduct.matrix fun i j => F.map (f i j)\n  map_id X := by\n    dsimp\n    ext i j\n    by_cases h : j = i\n    · subst h; simp\n    · simp [h]\n\n"}
{"name":"CategoryTheory.Mat_.lift_obj","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.Preadditive C\nD : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} D\ninst✝² : CategoryTheory.Preadditive D\ninst✝¹ : CategoryTheory.Limits.HasFiniteBiproducts D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nX : CategoryTheory.Mat_ C\n⊢ Eq ((CategoryTheory.Mat_.lift F).obj X) (CategoryTheory.Limits.biproduct fun i => F.obj (X.X i))","decl":"/-- Any additive functor `C ⥤ D` to a category `D` with finite biproducts extends to\na functor `Mat_ C ⥤ D`. -/\n@[simps]\ndef lift (F : C ⥤ D) [Functor.Additive F] : Mat_ C ⥤ D where\n  obj X := ⨁ fun i => F.obj (X.X i)\n  map f := biproduct.matrix fun i j => F.map (f i j)\n  map_id X := by\n    dsimp\n    ext i j\n    by_cases h : j = i\n    · subst h; simp\n    · simp [h]\n\n"}
{"name":"CategoryTheory.Mat_.lift_additive","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.Preadditive C\nD : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} D\ninst✝² : CategoryTheory.Preadditive D\ninst✝¹ : CategoryTheory.Limits.HasFiniteBiproducts D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\n⊢ (CategoryTheory.Mat_.lift F).Additive","decl":"instance lift_additive (F : C ⥤ D) [Functor.Additive F] : Functor.Additive (lift F) where\n\n"}
{"name":"CategoryTheory.Mat_.embeddingLiftIso_hom_app","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.Preadditive C\nD : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} D\ninst✝² : CategoryTheory.Preadditive D\ninst✝¹ : CategoryTheory.Limits.HasFiniteBiproducts D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nX : C\n⊢ Eq ((CategoryTheory.Mat_.embeddingLiftIso F).hom.app X) (CategoryTheory.Limits.biproduct.desc fun x => CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- An additive functor `C ⥤ D` factors through its lift to `Mat_ C ⥤ D`. -/\n@[simps!]\ndef embeddingLiftIso (F : C ⥤ D) [Functor.Additive F] : embedding C ⋙ lift F ≅ F :=\n  NatIso.ofComponents\n    (fun X =>\n      { hom := biproduct.desc fun _ => 𝟙 (F.obj X)\n        inv := biproduct.lift fun _ => 𝟙 (F.obj X) })\n\n"}
{"name":"CategoryTheory.Mat_.embeddingLiftIso_inv_app","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.Preadditive C\nD : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} D\ninst✝² : CategoryTheory.Preadditive D\ninst✝¹ : CategoryTheory.Limits.HasFiniteBiproducts D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nX : C\n⊢ Eq ((CategoryTheory.Mat_.embeddingLiftIso F).inv.app X) (CategoryTheory.Limits.biproduct.lift fun x => CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- An additive functor `C ⥤ D` factors through its lift to `Mat_ C ⥤ D`. -/\n@[simps!]\ndef embeddingLiftIso (F : C ⥤ D) [Functor.Additive F] : embedding C ⋙ lift F ≅ F :=\n  NatIso.ofComponents\n    (fun X =>\n      { hom := biproduct.desc fun _ => 𝟙 (F.obj X)\n        inv := biproduct.lift fun _ => 𝟙 (F.obj X) })\n\n"}
{"name":"CategoryTheory.Mat_.equivalenceSelfOfHasFiniteBiproducts_functor","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type (u₁ + 1)\ninst✝² : CategoryTheory.LargeCategory C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasFiniteBiproducts C\n⊢ Eq (CategoryTheory.Mat_.equivalenceSelfOfHasFiniteBiproducts C).functor (CategoryTheory.Mat_.lift (CategoryTheory.Functor.id C))","decl":"@[simp]\ntheorem equivalenceSelfOfHasFiniteBiproducts_functor {C : Type (u₁ + 1)} [LargeCategory C]\n    [Preadditive C] [HasFiniteBiproducts C] :\n    (equivalenceSelfOfHasFiniteBiproducts C).functor = lift (𝟭 C) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Mat_.equivalenceSelfOfHasFiniteBiproducts_inverse","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type (u₁ + 1)\ninst✝² : CategoryTheory.LargeCategory C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasFiniteBiproducts C\n⊢ Eq (CategoryTheory.Mat_.equivalenceSelfOfHasFiniteBiproducts C).inverse (CategoryTheory.Mat_.embedding C)","decl":"@[simp]\ntheorem equivalenceSelfOfHasFiniteBiproducts_inverse {C : Type (u₁ + 1)} [LargeCategory C]\n    [Preadditive C] [HasFiniteBiproducts C] :\n    (equivalenceSelfOfHasFiniteBiproducts C).inverse = embedding C :=\n  rfl\n\n"}
{"name":"CategoryTheory.Mat.hom_ext","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"R : Type u\ninst✝ : Semiring R\nX Y : CategoryTheory.Mat R\nf g : Quiver.Hom X Y\nh : ∀ (i : ↑X) (j : ↑Y), Eq (f i j) (g i j)\n⊢ Eq f g","decl":"@[ext]\ntheorem hom_ext {X Y : Mat R} (f g : X ⟶ Y) (h : ∀ i j, f i j = g i j) : f = g :=\n  Matrix.ext_iff.mp h\n\n"}
{"name":"CategoryTheory.Mat.hom_ext_iff","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"R : Type u\ninst✝ : Semiring R\nX Y : CategoryTheory.Mat R\nf g : Quiver.Hom X Y\n⊢ Iff (Eq f g) (∀ (i : ↑X) (j : ↑Y), Eq (f i j) (g i j))","decl":"@[ext]\ntheorem hom_ext {X Y : Mat R} (f g : X ⟶ Y) (h : ∀ i j, f i j = g i j) : f = g :=\n  Matrix.ext_iff.mp h\n\n"}
{"name":"CategoryTheory.Mat.id_def","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"R : Type u\ninst✝ : Semiring R\nM : CategoryTheory.Mat R\n⊢ Eq (CategoryTheory.CategoryStruct.id M) fun i j => ite (Eq i j) 1 0","decl":"open scoped Classical in\ntheorem id_def (M : Mat R) : 𝟙 M = fun i j => if i = j then 1 else 0 :=\n  rfl\n\n"}
{"name":"CategoryTheory.Mat.id_apply","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"R : Type u\ninst✝ : Semiring R\nM : CategoryTheory.Mat R\ni j : ↑M\n⊢ Eq (CategoryTheory.CategoryStruct.id M i j) (ite (Eq i j) 1 0)","decl":"open scoped Classical in\ntheorem id_apply (M : Mat R) (i j : M) : (𝟙 M : Matrix M M R) i j = if i = j then 1 else 0 :=\n  rfl\n\n"}
{"name":"CategoryTheory.Mat.id_apply_self","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"R : Type u\ninst✝ : Semiring R\nM : CategoryTheory.Mat R\ni : ↑M\n⊢ Eq (CategoryTheory.CategoryStruct.id M i i) 1","decl":"@[simp]\ntheorem id_apply_self (M : Mat R) (i : M) : (𝟙 M : Matrix M M R) i i = 1 := by simp [id_apply]\n\n"}
{"name":"CategoryTheory.Mat.id_apply_of_ne","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"R : Type u\ninst✝ : Semiring R\nM : CategoryTheory.Mat R\ni j : ↑M\nh : Ne i j\n⊢ Eq (CategoryTheory.CategoryStruct.id M i j) 0","decl":"@[simp]\ntheorem id_apply_of_ne (M : Mat R) (i j : M) (h : i ≠ j) : (𝟙 M : Matrix M M R) i j = 0 := by\n  simp [id_apply, h]\n\n"}
{"name":"CategoryTheory.Mat.comp_def","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"R : Type u\ninst✝ : Semiring R\nM N K : CategoryTheory.Mat R\nf : Quiver.Hom M N\ng : Quiver.Hom N K\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g) fun i k => Finset.univ.sum fun j => HMul.hMul (f i j) (g j k)","decl":"theorem comp_def {M N K : Mat R} (f : M ⟶ N) (g : N ⟶ K) :\n    f ≫ g = fun i k => ∑ j : N, f i j * g j k :=\n  rfl\n\n"}
{"name":"CategoryTheory.Mat.comp_apply","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"R : Type u\ninst✝ : Semiring R\nM N K : CategoryTheory.Mat R\nf : Quiver.Hom M N\ng : Quiver.Hom N K\ni : ↑M\nk : ↑K\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g i k) (Finset.univ.sum fun j => HMul.hMul (f i j) (g j k))","decl":"@[simp]\ntheorem comp_apply {M N K : Mat R} (f : M ⟶ N) (g : N ⟶ K) (i k) :\n    (f ≫ g) i k = ∑ j : N, f i j * g j k :=\n  rfl\n\n"}
{"name":"CategoryTheory.Mat.equivalenceSingleObjInverse_map","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"R : Type\ninst✝ : Ring R\nX✝ Y✝ : CategoryTheory.Mat_ (CategoryTheory.SingleObj (MulOpposite R))\nf : Quiver.Hom X✝ Y✝\ni : ↑((fun X => FintypeCat.of X.ι) X✝)\nj : ↑((fun X => FintypeCat.of X.ι) Y✝)\n⊢ Eq ((CategoryTheory.Mat.equivalenceSingleObjInverse R).map f i j) (MulOpposite.unop (f i j))","decl":"/-- Auxiliary definition for `CategoryTheory.Mat.equivalenceSingleObj`. -/\n@[simps]\ndef equivalenceSingleObjInverse : Mat_ (SingleObj Rᵐᵒᵖ) ⥤ Mat R where\n  obj X := FintypeCat.of X.ι\n  map f i j := MulOpposite.unop (f i j)\n  map_id X := by\n    ext\n    simp only [Mat_.id_def, id_def]\n    split_ifs <;> rfl\n  map_comp f g := by\n    -- Porting note: this proof was automatic in mathlib3\n    ext\n    simp only [Mat_.comp_apply, comp_apply]\n    apply Finset.unop_sum\n\n"}
{"name":"CategoryTheory.Mat.equivalenceSingleObjInverse_obj","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"R : Type\ninst✝ : Ring R\nX : CategoryTheory.Mat_ (CategoryTheory.SingleObj (MulOpposite R))\n⊢ Eq ((CategoryTheory.Mat.equivalenceSingleObjInverse R).obj X) (FintypeCat.of X.ι)","decl":"/-- Auxiliary definition for `CategoryTheory.Mat.equivalenceSingleObj`. -/\n@[simps]\ndef equivalenceSingleObjInverse : Mat_ (SingleObj Rᵐᵒᵖ) ⥤ Mat R where\n  obj X := FintypeCat.of X.ι\n  map f i j := MulOpposite.unop (f i j)\n  map_id X := by\n    ext\n    simp only [Mat_.id_def, id_def]\n    split_ifs <;> rfl\n  map_comp f g := by\n    -- Porting note: this proof was automatic in mathlib3\n    ext\n    simp only [Mat_.comp_apply, comp_apply]\n    apply Finset.unop_sum\n\n"}
{"name":"CategoryTheory.Mat.instFaithfulMat_SingleObjMulOppositeEquivalenceSingleObjInverse","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"R : Type\ninst✝ : Ring R\n⊢ (CategoryTheory.Mat.equivalenceSingleObjInverse R).Faithful","decl":"instance : (equivalenceSingleObjInverse R).Faithful where\n  map_injective w := by\n    ext\n    apply_fun MulOpposite.unop using MulOpposite.unop_injective\n    exact congr_fun (congr_fun w _) _\n\n"}
{"name":"CategoryTheory.Mat.instFullMat_SingleObjMulOppositeEquivalenceSingleObjInverse","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"R : Type\ninst✝ : Ring R\n⊢ (CategoryTheory.Mat.equivalenceSingleObjInverse R).Full","decl":"instance : (equivalenceSingleObjInverse R).Full where\n  map_surjective f := ⟨fun i j => MulOpposite.op (f i j), rfl⟩\n\n"}
{"name":"CategoryTheory.Mat.instEssSurjMat_SingleObjMulOppositeEquivalenceSingleObjInverse","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"R : Type\ninst✝ : Ring R\n⊢ (CategoryTheory.Mat.equivalenceSingleObjInverse R).EssSurj","decl":"instance : (equivalenceSingleObjInverse R).EssSurj where\n  mem_essImage X :=\n    ⟨{  ι := X\n        X := fun _ => PUnit.unit }, ⟨eqToIso (by dsimp; cases X; congr)⟩⟩\n\n"}
{"name":"CategoryTheory.Mat.instIsEquivalenceMat_SingleObjMulOppositeEquivalenceSingleObjInverse","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"R : Type\ninst✝ : Ring R\n⊢ (CategoryTheory.Mat.equivalenceSingleObjInverse R).IsEquivalence","decl":"instance : (equivalenceSingleObjInverse R).IsEquivalence where\n\n"}
{"name":"CategoryTheory.Mat.add_apply","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"R : Type\ninst✝ : Ring R\nM N : CategoryTheory.Mat R\nf g : Quiver.Hom M N\ni : ↑M\nj : ↑N\n⊢ Eq (HAdd.hAdd f g i j) (HAdd.hAdd (f i j) (g i j))","decl":"@[simp]\ntheorem add_apply {M N : Mat R} (f g : M ⟶ N) (i j) : (f + g) i j = f i j + g i j :=\n  rfl\n\n"}
