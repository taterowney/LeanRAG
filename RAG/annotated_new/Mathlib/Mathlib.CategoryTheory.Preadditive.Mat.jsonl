{"name":"CategoryTheory.Mat_.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : SizeOf C\nŒπ : Type\nfintype : Fintype Œπ\nX : Œπ ‚Üí C\n‚ä¢ Eq (SizeOf.sizeOf (CategoryTheory.Mat_.mk Œπ X)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf Œπ)) (SizeOf.sizeOf fintype))","decl":"/-- An object in `Mat_ C` is a finite tuple of objects in `C`.\n-/\nstructure Mat_ where\n  Œπ : Type\n  [fintype : Fintype Œπ]\n  X : Œπ ‚Üí C\n\n"}
{"name":"CategoryTheory.Mat_.mk.injEq","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\nŒπ‚úù : Type\nfintype‚úù : Fintype Œπ‚úù\nX‚úù : Œπ‚úù ‚Üí C\nŒπ : Type\nfintype : Fintype Œπ\nX : Œπ ‚Üí C\n‚ä¢ Eq (Eq (CategoryTheory.Mat_.mk Œπ‚úù X‚úù) (CategoryTheory.Mat_.mk Œπ X)) (And (Eq Œπ‚úù Œπ) (And (HEq fintype‚úù fintype) (HEq X‚úù X)))","decl":"/-- An object in `Mat_ C` is a finite tuple of objects in `C`.\n-/\nstructure Mat_ where\n  Œπ : Type\n  [fintype : Fintype Œπ]\n  X : Œπ ‚Üí C\n\n"}
{"name":"CategoryTheory.Mat_.mk.inj","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\nŒπ‚úù : Type\nfintype‚úù : Fintype Œπ‚úù\nX‚úù : Œπ‚úù ‚Üí C\nŒπ : Type\nfintype : Fintype Œπ\nX : Œπ ‚Üí C\nx‚úù : Eq (CategoryTheory.Mat_.mk Œπ‚úù X‚úù) (CategoryTheory.Mat_.mk Œπ X)\n‚ä¢ And (Eq Œπ‚úù Œπ) (And (HEq fintype‚úù fintype) (HEq X‚úù X))","decl":"/-- An object in `Mat_ C` is a finite tuple of objects in `C`.\n-/\nstructure Mat_ where\n  Œπ : Type\n  [fintype : Fintype Œπ]\n  X : Œπ ‚Üí C\n\n"}
{"name":"CategoryTheory.Mat_.hom_ext_iff","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Preadditive C\nM N : CategoryTheory.Mat_ C\nf g : Quiver.Hom M N\n‚ä¢ Iff (Eq f g) (‚àÄ (i : M.Œπ) (j : N.Œπ), Eq (f i j) (g i j))","decl":"@[ext]\ntheorem hom_ext {M N : Mat_ C} (f g : M ‚ü∂ N) (H : ‚àÄ i j, f i j = g i j) : f = g :=\n  DMatrix.ext_iff.mp H\n\n"}
{"name":"CategoryTheory.Mat_.hom_ext","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Preadditive C\nM N : CategoryTheory.Mat_ C\nf g : Quiver.Hom M N\nH : ‚àÄ (i : M.Œπ) (j : N.Œπ), Eq (f i j) (g i j)\n‚ä¢ Eq f g","decl":"@[ext]\ntheorem hom_ext {M N : Mat_ C} (f g : M ‚ü∂ N) (H : ‚àÄ i j, f i j = g i j) : f = g :=\n  DMatrix.ext_iff.mp H\n\n"}
{"name":"CategoryTheory.Mat_.id_def","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Preadditive C\nM : CategoryTheory.Mat_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id M) fun i j => dite (Eq i j) (fun h => CategoryTheory.eqToHom ‚ãØ) fun h => 0","decl":"open scoped Classical in\ntheorem id_def (M : Mat_ C) :\n    (ùüô M : Hom M M) = fun i j => if h : i = j then eqToHom (congr_arg M.X h) else 0 :=\n  rfl\n\n"}
{"name":"CategoryTheory.Mat_.id_apply","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Preadditive C\nM : CategoryTheory.Mat_ C\ni j : M.Œπ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id M i j) (dite (Eq i j) (fun h => CategoryTheory.eqToHom ‚ãØ) fun h => 0)","decl":"open scoped Classical in\ntheorem id_apply (M : Mat_ C) (i j : M.Œπ) :\n    (ùüô M : Hom M M) i j = if h : i = j then eqToHom (congr_arg M.X h) else 0 :=\n  rfl\n\n"}
{"name":"CategoryTheory.Mat_.id_apply_self","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Preadditive C\nM : CategoryTheory.Mat_ C\ni : M.Œπ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id M i i) (CategoryTheory.CategoryStruct.id (M.X i))","decl":"@[simp]\ntheorem id_apply_self (M : Mat_ C) (i : M.Œπ) : (ùüô M : Hom M M) i i = ùüô _ := by simp [id_apply]\n\n"}
{"name":"CategoryTheory.Mat_.id_apply_of_ne","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Preadditive C\nM : CategoryTheory.Mat_ C\ni j : M.Œπ\nh : Ne i j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id M i j) 0","decl":"@[simp]\ntheorem id_apply_of_ne (M : Mat_ C) (i j : M.Œπ) (h : i ‚â† j) : (ùüô M : Hom M M) i j = 0 := by\n  simp [id_apply, h]\n\n"}
{"name":"CategoryTheory.Mat_.comp_def","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Preadditive C\nM N K : CategoryTheory.Mat_ C\nf : Quiver.Hom M N\ng : Quiver.Hom N K\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g) fun i k => Finset.univ.sum fun j => CategoryTheory.CategoryStruct.comp (f i j) (g j k)","decl":"theorem comp_def {M N K : Mat_ C} (f : M ‚ü∂ N) (g : N ‚ü∂ K) :\n    f ‚â´ g = fun i k => ‚àë j : N.Œπ, f i j ‚â´ g j k :=\n  rfl\n\n"}
{"name":"CategoryTheory.Mat_.comp_apply","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Preadditive C\nM N K : CategoryTheory.Mat_ C\nf : Quiver.Hom M N\ng : Quiver.Hom N K\ni : M.Œπ\nk : K.Œπ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g i k) (Finset.univ.sum fun j => CategoryTheory.CategoryStruct.comp (f i j) (g j k))","decl":"@[simp]\ntheorem comp_apply {M N K : Mat_ C} (f : M ‚ü∂ N) (g : N ‚ü∂ K) (i k) :\n    (f ‚â´ g) i k = ‚àë j : N.Œπ, f i j ‚â´ g j k :=\n  rfl\n\n"}
{"name":"CategoryTheory.Mat_.add_apply","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Preadditive C\nM N : CategoryTheory.Mat_ C\nf g : Quiver.Hom M N\ni : M.Œπ\nj : N.Œπ\n‚ä¢ Eq (HAdd.hAdd f g i j) (HAdd.hAdd (f i j) (g i j))","decl":"@[simp]\ntheorem add_apply {M N : Mat_ C} (f g : M ‚ü∂ N) (i j) : (f + g) i j = f i j + g i j :=\n  rfl\n\n"}
{"name":"CategoryTheory.Mat_.hasFiniteBiproducts","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Preadditive C\n‚ä¢ CategoryTheory.Limits.HasFiniteBiproducts (CategoryTheory.Mat_ C)","decl":"open scoped Classical in\n/-- We now prove that `Mat_ C` has finite biproducts.\n\nBe warned, however, that `Mat_ C` is not necessarily Krull-Schmidt,\nand so the internal indexing of a biproduct may have nothing to do with the external indexing,\neven though the construction we give uses a sigma type.\nSee however `isoBiproductEmbedding`.\n-/\ninstance hasFiniteBiproducts : HasFiniteBiproducts (Mat_ C) where\n  out n :=\n    { has_biproduct := fun f =>\n        hasBiproduct_of_total\n          { pt := ‚ü®Œ£ j, (f j).Œπ, fun p => (f p.1).X p.2‚ü©\n            œÄ := fun j x y => by\n              refine if h : x.1 = j then ?_ else 0\n              refine if h' : @Eq.ndrec (Fin n) x.1 (fun j => (f j).Œπ) x.2 _ h = y then ?_ else 0\n              apply eqToHom\n              substs h h'\n              rfl\n            -- Notice we were careful not to use `subst` until we had a goal in `Prop`.\n            Œπ := fun j x y => by\n              refine if h : y.1 = j then ?_ else 0\n              refine if h' : @Eq.ndrec _ y.1 (fun j => (f j).Œπ) y.2 _ h = x then ?_ else 0\n              apply eqToHom\n              substs h h'\n              rfl\n            Œπ_œÄ := fun j j' => by\n              ext x y\n              dsimp\n              simp_rw [dite_comp, comp_dite]\n              simp only [ite_self, dite_eq_ite, Limits.comp_zero, Limits.zero_comp,\n                eqToHom_trans, Finset.sum_congr]\n              erw [Finset.sum_sigma]\n              dsimp\n              simp only [if_true, Finset.sum_dite_irrel, Finset.mem_univ,\n                Finset.sum_const_zero, Finset.sum_congr, Finset.sum_dite_eq']\n              split_ifs with h h'\n              ¬∑ substs h h'\n                simp only [CategoryTheory.eqToHom_refl, CategoryTheory.Mat_.id_apply_self]\n              ¬∑ subst h\n                rw [eqToHom_refl, id_apply_of_ne _ _ _ h']\n              ¬∑ rfl }\n          (by\n            dsimp\n            ext1 ‚ü®i, j‚ü©\n            rintro ‚ü®i', j'‚ü©\n            rw [Finset.sum_apply, Finset.sum_apply]\n            dsimp\n            rw [Finset.sum_eq_single i]; rotate_left\n            ¬∑ intro b _ hb\n              apply Finset.sum_eq_zero\n              intro x _\n              rw [dif_neg hb.symm, zero_comp]\n            ¬∑ intro hi\n              simp at hi\n            rw [Finset.sum_eq_single j]; rotate_left\n            ¬∑ intro b _ hb\n              rw [dif_pos rfl, dif_neg, zero_comp]\n              simp only\n              tauto\n            ¬∑ intro hj\n              simp at hj\n            simp only [eqToHom_refl, dite_eq_ite, ite_true, Category.id_comp, ne_eq,\n              Sigma.mk.inj_iff, not_and, id_def]\n            by_cases h : i' = i\n            ¬∑ subst h\n              rw [dif_pos rfl]\n              simp only [heq_eq_eq, true_and]\n              by_cases h : j' = j\n              ¬∑ subst h\n                simp\n              ¬∑ rw [dif_neg h, dif_neg (Ne.symm h)]\n            ¬∑ rw [dif_neg h, dif_neg]\n              tauto) }\n\n"}
{"name":"CategoryTheory.Functor.mapMat__obj_fintype","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≥ : CategoryTheory.Preadditive C\nD : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u_1} D\ninst‚úù¬π : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nM : CategoryTheory.Mat_ C\n‚ä¢ Eq (F.mapMat_.obj M).fintype M.fintype","decl":"/-- A functor induces a functor of matrix categories.\n-/\n@[simps]\ndef mapMat_ (F : C ‚•§ D) [Functor.Additive F] : Mat_ C ‚•§ Mat_ D where\n  obj M := ‚ü®M.Œπ, fun i => F.obj (M.X i)‚ü©\n  map f i j := F.map (f i j)\n\n"}
{"name":"CategoryTheory.Functor.mapMat__map","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≥ : CategoryTheory.Preadditive C\nD : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u_1} D\ninst‚úù¬π : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nX‚úù Y‚úù : CategoryTheory.Mat_ C\nf : Quiver.Hom X‚úù Y‚úù\ni : ((fun M => CategoryTheory.Mat_.mk M.Œπ fun i => F.obj (M.X i)) X‚úù).Œπ\nj : ((fun M => CategoryTheory.Mat_.mk M.Œπ fun i => F.obj (M.X i)) Y‚úù).Œπ\n‚ä¢ Eq (F.mapMat_.map f i j) (F.map (f i j))","decl":"/-- A functor induces a functor of matrix categories.\n-/\n@[simps]\ndef mapMat_ (F : C ‚•§ D) [Functor.Additive F] : Mat_ C ‚•§ Mat_ D where\n  obj M := ‚ü®M.Œπ, fun i => F.obj (M.X i)‚ü©\n  map f i j := F.map (f i j)\n\n"}
{"name":"CategoryTheory.Functor.mapMat__obj_Œπ","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≥ : CategoryTheory.Preadditive C\nD : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u_1} D\ninst‚úù¬π : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nM : CategoryTheory.Mat_ C\n‚ä¢ Eq (F.mapMat_.obj M).Œπ M.Œπ","decl":"/-- A functor induces a functor of matrix categories.\n-/\n@[simps]\ndef mapMat_ (F : C ‚•§ D) [Functor.Additive F] : Mat_ C ‚•§ Mat_ D where\n  obj M := ‚ü®M.Œπ, fun i => F.obj (M.X i)‚ü©\n  map f i j := F.map (f i j)\n\n"}
{"name":"CategoryTheory.Functor.mapMat__obj_X","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≥ : CategoryTheory.Preadditive C\nD : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u_1} D\ninst‚úù¬π : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nM : CategoryTheory.Mat_ C\ni : M.Œπ\n‚ä¢ Eq ((F.mapMat_.obj M).X i) (F.obj (M.X i))","decl":"/-- A functor induces a functor of matrix categories.\n-/\n@[simps]\ndef mapMat_ (F : C ‚•§ D) [Functor.Additive F] : Mat_ C ‚•§ Mat_ D where\n  obj M := ‚ü®M.Œπ, fun i => F.obj (M.X i)‚ü©\n  map f i j := F.map (f i j)\n\n"}
{"name":"CategoryTheory.Functor.mapMatId_hom_app","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Preadditive C\nX : CategoryTheory.Mat_ C\n‚ä¢ Eq (CategoryTheory.Functor.mapMatId.hom.app X) (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.id C).mapMat_.obj X))","decl":"/-- The identity functor induces the identity functor on matrix categories.\n-/\n@[simps!]\ndef mapMatId : (ùü≠ C).mapMat_ ‚âÖ ùü≠ (Mat_ C) :=\n  NatIso.ofComponents (fun M => eqToIso (by cases M; rfl)) fun {M N} f => by\n    classical\n    ext\n    cases M; cases N\n    simp [comp_dite, dite_comp]\n\n"}
{"name":"CategoryTheory.Functor.mapMatId_inv_app","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Preadditive C\nX : CategoryTheory.Mat_ C\n‚ä¢ Eq (CategoryTheory.Functor.mapMatId.inv.app X) (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.id C).mapMat_.obj X))","decl":"/-- The identity functor induces the identity functor on matrix categories.\n-/\n@[simps!]\ndef mapMatId : (ùü≠ C).mapMat_ ‚âÖ ùü≠ (Mat_ C) :=\n  NatIso.ofComponents (fun M => eqToIso (by cases M; rfl)) fun {M N} f => by\n    classical\n    ext\n    cases M; cases N\n    simp [comp_dite, dite_comp]\n\n"}
{"name":"CategoryTheory.Functor.mapMatComp_inv_app","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∑ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Å∂ : CategoryTheory.Preadditive C\nD : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u_1} D\ninst‚úù‚Å¥ : CategoryTheory.Preadditive D\nE : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u_2} E\ninst‚úù¬≤ : CategoryTheory.Preadditive E\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Additive\nG : CategoryTheory.Functor D E\ninst‚úù : G.Additive\nX : CategoryTheory.Mat_ C\n‚ä¢ Eq ((F.mapMatComp G).inv.app X) (CategoryTheory.CategoryStruct.id ((F.comp G).mapMat_.obj X))","decl":"/-- Composite functors induce composite functors on matrix categories.\n-/\n@[simps!]\ndef mapMatComp {E : Type*} [Category.{v‚ÇÅ} E] [Preadditive E] (F : C ‚•§ D) [Functor.Additive F]\n    (G : D ‚•§ E) [Functor.Additive G] : (F ‚ãô G).mapMat_ ‚âÖ F.mapMat_ ‚ãô G.mapMat_ :=\n  NatIso.ofComponents (fun M => eqToIso (by cases M; rfl)) fun {M N} f => by\n    classical\n    ext\n    cases M; cases N\n    simp [comp_dite, dite_comp]\n\n"}
{"name":"CategoryTheory.Functor.mapMatComp_hom_app","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∑ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Å∂ : CategoryTheory.Preadditive C\nD : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u_1} D\ninst‚úù‚Å¥ : CategoryTheory.Preadditive D\nE : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u_2} E\ninst‚úù¬≤ : CategoryTheory.Preadditive E\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Additive\nG : CategoryTheory.Functor D E\ninst‚úù : G.Additive\nX : CategoryTheory.Mat_ C\n‚ä¢ Eq ((F.mapMatComp G).hom.app X) (CategoryTheory.CategoryStruct.id ((F.comp G).mapMat_.obj X))","decl":"/-- Composite functors induce composite functors on matrix categories.\n-/\n@[simps!]\ndef mapMatComp {E : Type*} [Category.{v‚ÇÅ} E] [Preadditive E] (F : C ‚•§ D) [Functor.Additive F]\n    (G : D ‚•§ E) [Functor.Additive G] : (F ‚ãô G).mapMat_ ‚âÖ F.mapMat_ ‚ãô G.mapMat_ :=\n  NatIso.ofComponents (fun M => eqToIso (by cases M; rfl)) fun {M N} f => by\n    classical\n    ext\n    cases M; cases N\n    simp [comp_dite, dite_comp]\n\n"}
{"name":"CategoryTheory.Mat_.embedding_obj_Œπ","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Preadditive C\nX : C\n‚ä¢ Eq ((CategoryTheory.Mat_.embedding C).obj X).Œπ PUnit.{1}","decl":"/-- The embedding of `C` into `Mat_ C` as one-by-one matrices.\n(We index the summands by `PUnit`.) -/\n@[simps]\ndef embedding : C ‚•§ Mat_ C where\n  obj X := ‚ü®PUnit, fun _ => X‚ü©\n  map f _ _ := f\n  map_id _ := by ext ‚ü®‚ü©; simp\n  map_comp _ _ := by ext ‚ü®‚ü©; simp\n\n"}
{"name":"CategoryTheory.Mat_.embedding_map","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Preadditive C\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\nx‚úù¬π : ((fun X => CategoryTheory.Mat_.mk PUnit.{1} fun x => X) X‚úù).Œπ\nx‚úù : ((fun X => CategoryTheory.Mat_.mk PUnit.{1} fun x => X) Y‚úù).Œπ\n‚ä¢ Eq ((CategoryTheory.Mat_.embedding C).map f x‚úù¬π x‚úù) f","decl":"/-- The embedding of `C` into `Mat_ C` as one-by-one matrices.\n(We index the summands by `PUnit`.) -/\n@[simps]\ndef embedding : C ‚•§ Mat_ C where\n  obj X := ‚ü®PUnit, fun _ => X‚ü©\n  map f _ _ := f\n  map_id _ := by ext ‚ü®‚ü©; simp\n  map_comp _ _ := by ext ‚ü®‚ü©; simp\n\n"}
{"name":"CategoryTheory.Mat_.embedding_obj_fintype","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Preadditive C\nX : C\n‚ä¢ Eq ((CategoryTheory.Mat_.embedding C).obj X).fintype PUnit.fintype","decl":"/-- The embedding of `C` into `Mat_ C` as one-by-one matrices.\n(We index the summands by `PUnit`.) -/\n@[simps]\ndef embedding : C ‚•§ Mat_ C where\n  obj X := ‚ü®PUnit, fun _ => X‚ü©\n  map f _ _ := f\n  map_id _ := by ext ‚ü®‚ü©; simp\n  map_comp _ _ := by ext ‚ü®‚ü©; simp\n\n"}
{"name":"CategoryTheory.Mat_.embedding_obj_X","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Preadditive C\nX : C\nx‚úù : PUnit.{1}\n‚ä¢ Eq (((CategoryTheory.Mat_.embedding C).obj X).X x‚úù) X","decl":"/-- The embedding of `C` into `Mat_ C` as one-by-one matrices.\n(We index the summands by `PUnit`.) -/\n@[simps]\ndef embedding : C ‚•§ Mat_ C where\n  obj X := ‚ü®PUnit, fun _ => X‚ü©\n  map f _ _ := f\n  map_id _ := by ext ‚ü®‚ü©; simp\n  map_comp _ _ := by ext ‚ü®‚ü©; simp\n\n"}
{"name":"CategoryTheory.Mat_.Embedding.instFaithfulEmbedding","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Preadditive C\n‚ä¢ (CategoryTheory.Mat_.embedding C).Faithful","decl":"instance : (embedding C).Faithful where\n  map_injective h := congr_fun (congr_fun h PUnit.unit) PUnit.unit\n\n"}
{"name":"CategoryTheory.Mat_.Embedding.instFullEmbedding","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Preadditive C\n‚ä¢ (CategoryTheory.Mat_.embedding C).Full","decl":"instance : (embedding C).Full where map_surjective f := ‚ü®f PUnit.unit PUnit.unit, rfl‚ü©\n\n"}
{"name":"CategoryTheory.Mat_.Embedding.instAdditiveEmbedding","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Preadditive C\n‚ä¢ (CategoryTheory.Mat_.embedding C).Additive","decl":"instance : Functor.Additive (embedding C) where\n\n"}
{"name":"CategoryTheory.Mat_.isoBiproductEmbedding_inv","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Preadditive C\nM : CategoryTheory.Mat_ C\n‚ä¢ Eq M.isoBiproductEmbedding.inv (CategoryTheory.Limits.biproduct.desc fun i x k => dite (Eq i k) (fun h => CategoryTheory.eqToHom ‚ãØ) fun h => 0)","decl":"open scoped Classical in\n/-- Every object in `Mat_ C` is isomorphic to the biproduct of its summands.\n-/\n@[simps]\ndef isoBiproductEmbedding (M : Mat_ C) : M ‚âÖ ‚®Å fun i => (embedding C).obj (M.X i) where\n  hom := biproduct.lift fun i j _ => if h : j = i then eqToHom (congr_arg M.X h) else 0\n  inv := biproduct.desc fun i _ k => if h : i = k then eqToHom (congr_arg M.X h) else 0\n  hom_inv_id := by\n    simp only [biproduct.lift_desc]\n    funext i j\n    dsimp [id_def]\n    rw [Finset.sum_apply, Finset.sum_apply, Finset.sum_eq_single i]; rotate_left\n    ¬∑ intro b _ hb\n      dsimp\n      rw [Fintype.univ_ofSubsingleton, Finset.sum_singleton, dif_neg hb.symm, zero_comp]\n    ¬∑ intro h\n      simp at h\n    simp\n  inv_hom_id := by\n    apply biproduct.hom_ext\n    intro i\n    apply biproduct.hom_ext'\n    intro j\n    simp only [Category.id_comp, Category.assoc, biproduct.lift_œÄ, biproduct.Œπ_desc_assoc,\n      biproduct.Œπ_œÄ]\n    ext ‚ü®‚ü© ‚ü®‚ü©\n    simp only [embedding, comp_apply, comp_dite, dite_comp, comp_zero, zero_comp,\n      Finset.sum_dite_eq', Finset.mem_univ, ite_true, eqToHom_refl, Category.comp_id]\n    split_ifs with h\n    ¬∑ subst h\n      simp\n    ¬∑ rfl\n\n"}
{"name":"CategoryTheory.Mat_.isoBiproductEmbedding_hom","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Preadditive C\nM : CategoryTheory.Mat_ C\n‚ä¢ Eq M.isoBiproductEmbedding.hom (CategoryTheory.Limits.biproduct.lift fun i j x => dite (Eq j i) (fun h => CategoryTheory.eqToHom ‚ãØ) fun h => 0)","decl":"open scoped Classical in\n/-- Every object in `Mat_ C` is isomorphic to the biproduct of its summands.\n-/\n@[simps]\ndef isoBiproductEmbedding (M : Mat_ C) : M ‚âÖ ‚®Å fun i => (embedding C).obj (M.X i) where\n  hom := biproduct.lift fun i j _ => if h : j = i then eqToHom (congr_arg M.X h) else 0\n  inv := biproduct.desc fun i _ k => if h : i = k then eqToHom (congr_arg M.X h) else 0\n  hom_inv_id := by\n    simp only [biproduct.lift_desc]\n    funext i j\n    dsimp [id_def]\n    rw [Finset.sum_apply, Finset.sum_apply, Finset.sum_eq_single i]; rotate_left\n    ¬∑ intro b _ hb\n      dsimp\n      rw [Fintype.univ_ofSubsingleton, Finset.sum_singleton, dif_neg hb.symm, zero_comp]\n    ¬∑ intro h\n      simp at h\n    simp\n  inv_hom_id := by\n    apply biproduct.hom_ext\n    intro i\n    apply biproduct.hom_ext'\n    intro j\n    simp only [Category.id_comp, Category.assoc, biproduct.lift_œÄ, biproduct.Œπ_desc_assoc,\n      biproduct.Œπ_œÄ]\n    ext ‚ü®‚ü© ‚ü®‚ü©\n    simp only [embedding, comp_apply, comp_dite, dite_comp, comp_zero, zero_comp,\n      Finset.sum_dite_eq', Finset.mem_univ, ite_true, eqToHom_refl, Category.comp_id]\n    split_ifs with h\n    ¬∑ subst h\n      simp\n    ¬∑ rfl\n\n"}
{"name":"CategoryTheory.Mat_.instHasBiproductŒπObjEmbeddingXOfAdditive","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≥ : CategoryTheory.Preadditive C\nD : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬π : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor (CategoryTheory.Mat_ C) D\ninst‚úù : F.Additive\nM : CategoryTheory.Mat_ C\n‚ä¢ CategoryTheory.Limits.HasBiproduct fun i => F.obj ((CategoryTheory.Mat_.embedding C).obj (M.X i))","decl":"instance (F : Mat_ C ‚•§ D) [Functor.Additive F] (M : Mat_ C) :\n    HasBiproduct (fun i => F.obj ((embedding C).obj (M.X i))) :=\n  F.hasBiproduct_of_preserves _\n\n-- Porting note: removed the @[simps] attribute as the automatically generated lemmas\n-- are not very useful; two more useful lemmas have been added just after this\n-- definition in order to ease the proof of `additiveObjIsoBiproduct_naturality`\n"}
{"name":"CategoryTheory.Mat_.additiveObjIsoBiproduct_hom_œÄ","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≥ : CategoryTheory.Preadditive C\nD : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬π : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor (CategoryTheory.Mat_ C) D\ninst‚úù : F.Additive\nM : CategoryTheory.Mat_ C\ni : M.Œπ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Mat_.additiveObjIsoBiproduct F M).hom (CategoryTheory.Limits.biproduct.œÄ (fun i => F.obj ((CategoryTheory.Mat_.embedding C).obj (M.X i))) i)) (F.map (CategoryTheory.CategoryStruct.comp M.isoBiproductEmbedding.hom (CategoryTheory.Limits.biproduct.œÄ (fun i => (CategoryTheory.Mat_.embedding C).obj (M.X i)) i)))","decl":"@[reassoc (attr := simp)]\nlemma additiveObjIsoBiproduct_hom_œÄ (F : Mat_ C ‚•§ D) [Functor.Additive F] (M : Mat_ C) (i : M.Œπ) :\n    (additiveObjIsoBiproduct F M).hom ‚â´ biproduct.œÄ _ i =\n      F.map (M.isoBiproductEmbedding.hom ‚â´ biproduct.œÄ _ i) := by\n  dsimp [additiveObjIsoBiproduct]\n  rw [biproduct.lift_œÄ, Category.assoc]\n  erw [biproduct.lift_œÄ, ‚Üê F.map_comp]\n  simp\n\n"}
{"name":"CategoryTheory.Mat_.additiveObjIsoBiproduct_hom_œÄ_assoc","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≥ : CategoryTheory.Preadditive C\nD : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬π : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor (CategoryTheory.Mat_ C) D\ninst‚úù : F.Additive\nM : CategoryTheory.Mat_ C\ni : M.Œπ\nZ : D\nh : Quiver.Hom (F.obj ((CategoryTheory.Mat_.embedding C).obj (M.X i))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Mat_.additiveObjIsoBiproduct F M).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.œÄ (fun i => F.obj ((CategoryTheory.Mat_.embedding C).obj (M.X i))) i) h)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.CategoryStruct.comp M.isoBiproductEmbedding.hom (CategoryTheory.Limits.biproduct.œÄ (fun i => (CategoryTheory.Mat_.embedding C).obj (M.X i)) i))) h)","decl":"@[reassoc (attr := simp)]\nlemma additiveObjIsoBiproduct_hom_œÄ (F : Mat_ C ‚•§ D) [Functor.Additive F] (M : Mat_ C) (i : M.Œπ) :\n    (additiveObjIsoBiproduct F M).hom ‚â´ biproduct.œÄ _ i =\n      F.map (M.isoBiproductEmbedding.hom ‚â´ biproduct.œÄ _ i) := by\n  dsimp [additiveObjIsoBiproduct]\n  rw [biproduct.lift_œÄ, Category.assoc]\n  erw [biproduct.lift_œÄ, ‚Üê F.map_comp]\n  simp\n\n"}
{"name":"CategoryTheory.Mat_.Œπ_additiveObjIsoBiproduct_inv","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≥ : CategoryTheory.Preadditive C\nD : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬π : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor (CategoryTheory.Mat_ C) D\ninst‚úù : F.Additive\nM : CategoryTheory.Mat_ C\ni : M.Œπ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Œπ (fun i => F.obj ((CategoryTheory.Mat_.embedding C).obj (M.X i))) i) (CategoryTheory.Mat_.additiveObjIsoBiproduct F M).inv) (F.map (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Œπ (fun i => (CategoryTheory.Mat_.embedding C).obj (M.X i)) i) M.isoBiproductEmbedding.inv))","decl":"@[reassoc (attr := simp)]\nlemma Œπ_additiveObjIsoBiproduct_inv (F : Mat_ C ‚•§ D) [Functor.Additive F] (M : Mat_ C) (i : M.Œπ) :\n    biproduct.Œπ _ i ‚â´ (additiveObjIsoBiproduct F M).inv =\n      F.map (biproduct.Œπ _ i ‚â´ M.isoBiproductEmbedding.inv) := by\n  dsimp [additiveObjIsoBiproduct, Functor.mapBiproduct, Functor.mapBicone]\n  simp only [biproduct.Œπ_desc, biproduct.Œπ_desc_assoc, ‚Üê F.map_comp]\n\n"}
{"name":"CategoryTheory.Mat_.Œπ_additiveObjIsoBiproduct_inv_assoc","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≥ : CategoryTheory.Preadditive C\nD : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬π : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor (CategoryTheory.Mat_ C) D\ninst‚úù : F.Additive\nM : CategoryTheory.Mat_ C\ni : M.Œπ\nZ : D\nh : Quiver.Hom (F.obj M) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Œπ (fun i => F.obj ((CategoryTheory.Mat_.embedding C).obj (M.X i))) i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Mat_.additiveObjIsoBiproduct F M).inv h)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Œπ (fun i => (CategoryTheory.Mat_.embedding C).obj (M.X i)) i) M.isoBiproductEmbedding.inv)) h)","decl":"@[reassoc (attr := simp)]\nlemma Œπ_additiveObjIsoBiproduct_inv (F : Mat_ C ‚•§ D) [Functor.Additive F] (M : Mat_ C) (i : M.Œπ) :\n    biproduct.Œπ _ i ‚â´ (additiveObjIsoBiproduct F M).inv =\n      F.map (biproduct.Œπ _ i ‚â´ M.isoBiproductEmbedding.inv) := by\n  dsimp [additiveObjIsoBiproduct, Functor.mapBiproduct, Functor.mapBicone]\n  simp only [biproduct.Œπ_desc, biproduct.Œπ_desc_assoc, ‚Üê F.map_comp]\n\n"}
{"name":"CategoryTheory.Mat_.additiveObjIsoBiproduct_naturality_assoc","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\nD : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬≤ : CategoryTheory.Preadditive D\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts D\nF : CategoryTheory.Functor (CategoryTheory.Mat_ C) D\ninst‚úù : F.Additive\nM N : CategoryTheory.Mat_ C\nf : Quiver.Hom M N\nZ : D\nh : Quiver.Hom (CategoryTheory.Limits.biproduct fun i => F.obj ((CategoryTheory.Mat_.embedding C).obj (N.X i))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Mat_.additiveObjIsoBiproduct F N).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Mat_.additiveObjIsoBiproduct F M).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.matrix fun i j => F.map ((CategoryTheory.Mat_.embedding C).map (f i j))) h))","decl":"@[reassoc]\ntheorem additiveObjIsoBiproduct_naturality (F : Mat_ C ‚•§ D) [Functor.Additive F] {M N : Mat_ C}\n    (f : M ‚ü∂ N) :\n    F.map f ‚â´ (additiveObjIsoBiproduct F N).hom =\n      (additiveObjIsoBiproduct F M).hom ‚â´\n        biproduct.matrix fun i j => F.map ((embedding C).map (f i j)) := by\n  classical\n  ext i : 1\n  simp only [Category.assoc, additiveObjIsoBiproduct_hom_œÄ, isoBiproductEmbedding_hom,\n    embedding_obj_Œπ, embedding_obj_X, biproduct.lift_œÄ, biproduct.matrix_œÄ,\n    ‚Üê cancel_epi (additiveObjIsoBiproduct F M).inv, Iso.inv_hom_id_assoc]\n  ext j : 1\n  simp only [Œπ_additiveObjIsoBiproduct_inv_assoc, isoBiproductEmbedding_inv,\n    biproduct.Œπ_desc, ‚Üê F.map_comp]\n  congr 1\n  funext ‚ü®‚ü© ‚ü®‚ü©\n  simp [comp_apply, dite_comp, comp_dite]\n\n"}
{"name":"CategoryTheory.Mat_.additiveObjIsoBiproduct_naturality","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\nD : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬≤ : CategoryTheory.Preadditive D\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts D\nF : CategoryTheory.Functor (CategoryTheory.Mat_ C) D\ninst‚úù : F.Additive\nM N : CategoryTheory.Mat_ C\nf : Quiver.Hom M N\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map f) (CategoryTheory.Mat_.additiveObjIsoBiproduct F N).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Mat_.additiveObjIsoBiproduct F M).hom (CategoryTheory.Limits.biproduct.matrix fun i j => F.map ((CategoryTheory.Mat_.embedding C).map (f i j))))","decl":"@[reassoc]\ntheorem additiveObjIsoBiproduct_naturality (F : Mat_ C ‚•§ D) [Functor.Additive F] {M N : Mat_ C}\n    (f : M ‚ü∂ N) :\n    F.map f ‚â´ (additiveObjIsoBiproduct F N).hom =\n      (additiveObjIsoBiproduct F M).hom ‚â´\n        biproduct.matrix fun i j => F.map ((embedding C).map (f i j)) := by\n  classical\n  ext i : 1\n  simp only [Category.assoc, additiveObjIsoBiproduct_hom_œÄ, isoBiproductEmbedding_hom,\n    embedding_obj_Œπ, embedding_obj_X, biproduct.lift_œÄ, biproduct.matrix_œÄ,\n    ‚Üê cancel_epi (additiveObjIsoBiproduct F M).inv, Iso.inv_hom_id_assoc]\n  ext j : 1\n  simp only [Œπ_additiveObjIsoBiproduct_inv_assoc, isoBiproductEmbedding_inv,\n    biproduct.Œπ_desc, ‚Üê F.map_comp]\n  congr 1\n  funext ‚ü®‚ü© ‚ü®‚ü©\n  simp [comp_apply, dite_comp, comp_dite]\n\n"}
{"name":"CategoryTheory.Mat_.additiveObjIsoBiproduct_naturality'_assoc","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\nD : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬≤ : CategoryTheory.Preadditive D\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts D\nF : CategoryTheory.Functor (CategoryTheory.Mat_ C) D\ninst‚úù : F.Additive\nM N : CategoryTheory.Mat_ C\nf : Quiver.Hom M N\nZ : D\nh : Quiver.Hom (F.obj N) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Mat_.additiveObjIsoBiproduct F M).inv (CategoryTheory.CategoryStruct.comp (F.map f) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.matrix fun i j => F.map ((CategoryTheory.Mat_.embedding C).map (f i j))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Mat_.additiveObjIsoBiproduct F N).inv h))","decl":"@[reassoc]\ntheorem additiveObjIsoBiproduct_naturality' (F : Mat_ C ‚•§ D) [Functor.Additive F] {M N : Mat_ C}\n    (f : M ‚ü∂ N) :\n    (additiveObjIsoBiproduct F M).inv ‚â´ F.map f =\n      biproduct.matrix (fun i j => F.map ((embedding C).map (f i j)) :) ‚â´\n        (additiveObjIsoBiproduct F N).inv := by\n  rw [Iso.inv_comp_eq, ‚Üê Category.assoc, Iso.eq_comp_inv, additiveObjIsoBiproduct_naturality]\n\n"}
{"name":"CategoryTheory.Mat_.additiveObjIsoBiproduct_naturality'","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\nD : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬≤ : CategoryTheory.Preadditive D\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts D\nF : CategoryTheory.Functor (CategoryTheory.Mat_ C) D\ninst‚úù : F.Additive\nM N : CategoryTheory.Mat_ C\nf : Quiver.Hom M N\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Mat_.additiveObjIsoBiproduct F M).inv (F.map f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.matrix fun i j => F.map ((CategoryTheory.Mat_.embedding C).map (f i j))) (CategoryTheory.Mat_.additiveObjIsoBiproduct F N).inv)","decl":"@[reassoc]\ntheorem additiveObjIsoBiproduct_naturality' (F : Mat_ C ‚•§ D) [Functor.Additive F] {M N : Mat_ C}\n    (f : M ‚ü∂ N) :\n    (additiveObjIsoBiproduct F M).inv ‚â´ F.map f =\n      biproduct.matrix (fun i j => F.map ((embedding C).map (f i j)) :) ‚â´\n        (additiveObjIsoBiproduct F N).inv := by\n  rw [Iso.inv_comp_eq, ‚Üê Category.assoc, Iso.eq_comp_inv, additiveObjIsoBiproduct_naturality]\n\n"}
{"name":"CategoryTheory.Mat_.lift_map","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\nD : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬≤ : CategoryTheory.Preadditive D\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nX‚úù Y‚úù : CategoryTheory.Mat_ C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Mat_.lift F).map f) (CategoryTheory.Limits.biproduct.matrix fun i j => F.map (f i j))","decl":"/-- Any additive functor `C ‚•§ D` to a category `D` with finite biproducts extends to\na functor `Mat_ C ‚•§ D`. -/\n@[simps]\ndef lift (F : C ‚•§ D) [Functor.Additive F] : Mat_ C ‚•§ D where\n  obj X := ‚®Å fun i => F.obj (X.X i)\n  map f := biproduct.matrix fun i j => F.map (f i j)\n  map_id X := by\n    dsimp\n    ext i j\n    by_cases h : j = i\n    ¬∑ subst h; simp\n    ¬∑ simp [h]\n\n"}
{"name":"CategoryTheory.Mat_.lift_obj","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\nD : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬≤ : CategoryTheory.Preadditive D\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nX : CategoryTheory.Mat_ C\n‚ä¢ Eq ((CategoryTheory.Mat_.lift F).obj X) (CategoryTheory.Limits.biproduct fun i => F.obj (X.X i))","decl":"/-- Any additive functor `C ‚•§ D` to a category `D` with finite biproducts extends to\na functor `Mat_ C ‚•§ D`. -/\n@[simps]\ndef lift (F : C ‚•§ D) [Functor.Additive F] : Mat_ C ‚•§ D where\n  obj X := ‚®Å fun i => F.obj (X.X i)\n  map f := biproduct.matrix fun i j => F.map (f i j)\n  map_id X := by\n    dsimp\n    ext i j\n    by_cases h : j = i\n    ¬∑ subst h; simp\n    ¬∑ simp [h]\n\n"}
{"name":"CategoryTheory.Mat_.lift_additive","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\nD : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬≤ : CategoryTheory.Preadditive D\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\n‚ä¢ (CategoryTheory.Mat_.lift F).Additive","decl":"instance lift_additive (F : C ‚•§ D) [Functor.Additive F] : Functor.Additive (lift F) where\n\n"}
{"name":"CategoryTheory.Mat_.embeddingLiftIso_hom_app","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\nD : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬≤ : CategoryTheory.Preadditive D\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nX : C\n‚ä¢ Eq ((CategoryTheory.Mat_.embeddingLiftIso F).hom.app X) (CategoryTheory.Limits.biproduct.desc fun x => CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- An additive functor `C ‚•§ D` factors through its lift to `Mat_ C ‚•§ D`. -/\n@[simps!]\ndef embeddingLiftIso (F : C ‚•§ D) [Functor.Additive F] : embedding C ‚ãô lift F ‚âÖ F :=\n  NatIso.ofComponents\n    (fun X =>\n      { hom := biproduct.desc fun _ => ùüô (F.obj X)\n        inv := biproduct.lift fun _ => ùüô (F.obj X) })\n\n"}
{"name":"CategoryTheory.Mat_.embeddingLiftIso_inv_app","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\nD : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\ninst‚úù¬≤ : CategoryTheory.Preadditive D\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nX : C\n‚ä¢ Eq ((CategoryTheory.Mat_.embeddingLiftIso F).inv.app X) (CategoryTheory.Limits.biproduct.lift fun x => CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- An additive functor `C ‚•§ D` factors through its lift to `Mat_ C ‚•§ D`. -/\n@[simps!]\ndef embeddingLiftIso (F : C ‚•§ D) [Functor.Additive F] : embedding C ‚ãô lift F ‚âÖ F :=\n  NatIso.ofComponents\n    (fun X =>\n      { hom := biproduct.desc fun _ => ùüô (F.obj X)\n        inv := biproduct.lift fun _ => ùüô (F.obj X) })\n\n"}
{"name":"CategoryTheory.Mat_.equivalenceSelfOfHasFiniteBiproducts_functor","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type (u‚ÇÅ + 1)\ninst‚úù¬≤ : CategoryTheory.LargeCategory C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasFiniteBiproducts C\n‚ä¢ Eq (CategoryTheory.Mat_.equivalenceSelfOfHasFiniteBiproducts C).functor (CategoryTheory.Mat_.lift (CategoryTheory.Functor.id C))","decl":"@[simp]\ntheorem equivalenceSelfOfHasFiniteBiproducts_functor {C : Type (u‚ÇÅ + 1)} [LargeCategory C]\n    [Preadditive C] [HasFiniteBiproducts C] :\n    (equivalenceSelfOfHasFiniteBiproducts C).functor = lift (ùü≠ C) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Mat_.equivalenceSelfOfHasFiniteBiproducts_inverse","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"C : Type (u‚ÇÅ + 1)\ninst‚úù¬≤ : CategoryTheory.LargeCategory C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasFiniteBiproducts C\n‚ä¢ Eq (CategoryTheory.Mat_.equivalenceSelfOfHasFiniteBiproducts C).inverse (CategoryTheory.Mat_.embedding C)","decl":"@[simp]\ntheorem equivalenceSelfOfHasFiniteBiproducts_inverse {C : Type (u‚ÇÅ + 1)} [LargeCategory C]\n    [Preadditive C] [HasFiniteBiproducts C] :\n    (equivalenceSelfOfHasFiniteBiproducts C).inverse = embedding C :=\n  rfl\n\n"}
{"name":"CategoryTheory.Mat.hom_ext","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"R : Type u\ninst‚úù : Semiring R\nX Y : CategoryTheory.Mat R\nf g : Quiver.Hom X Y\nh : ‚àÄ (i : ‚ÜëX) (j : ‚ÜëY), Eq (f i j) (g i j)\n‚ä¢ Eq f g","decl":"@[ext]\ntheorem hom_ext {X Y : Mat R} (f g : X ‚ü∂ Y) (h : ‚àÄ i j, f i j = g i j) : f = g :=\n  Matrix.ext_iff.mp h\n\n"}
{"name":"CategoryTheory.Mat.hom_ext_iff","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"R : Type u\ninst‚úù : Semiring R\nX Y : CategoryTheory.Mat R\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq f g) (‚àÄ (i : ‚ÜëX) (j : ‚ÜëY), Eq (f i j) (g i j))","decl":"@[ext]\ntheorem hom_ext {X Y : Mat R} (f g : X ‚ü∂ Y) (h : ‚àÄ i j, f i j = g i j) : f = g :=\n  Matrix.ext_iff.mp h\n\n"}
{"name":"CategoryTheory.Mat.id_def","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"R : Type u\ninst‚úù : Semiring R\nM : CategoryTheory.Mat R\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id M) fun i j => ite (Eq i j) 1 0","decl":"open scoped Classical in\ntheorem id_def (M : Mat R) : ùüô M = fun i j => if i = j then 1 else 0 :=\n  rfl\n\n"}
{"name":"CategoryTheory.Mat.id_apply","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"R : Type u\ninst‚úù : Semiring R\nM : CategoryTheory.Mat R\ni j : ‚ÜëM\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id M i j) (ite (Eq i j) 1 0)","decl":"open scoped Classical in\ntheorem id_apply (M : Mat R) (i j : M) : (ùüô M : Matrix M M R) i j = if i = j then 1 else 0 :=\n  rfl\n\n"}
{"name":"CategoryTheory.Mat.id_apply_self","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"R : Type u\ninst‚úù : Semiring R\nM : CategoryTheory.Mat R\ni : ‚ÜëM\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id M i i) 1","decl":"@[simp]\ntheorem id_apply_self (M : Mat R) (i : M) : (ùüô M : Matrix M M R) i i = 1 := by simp [id_apply]\n\n"}
{"name":"CategoryTheory.Mat.id_apply_of_ne","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"R : Type u\ninst‚úù : Semiring R\nM : CategoryTheory.Mat R\ni j : ‚ÜëM\nh : Ne i j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id M i j) 0","decl":"@[simp]\ntheorem id_apply_of_ne (M : Mat R) (i j : M) (h : i ‚â† j) : (ùüô M : Matrix M M R) i j = 0 := by\n  simp [id_apply, h]\n\n"}
{"name":"CategoryTheory.Mat.comp_def","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"R : Type u\ninst‚úù : Semiring R\nM N K : CategoryTheory.Mat R\nf : Quiver.Hom M N\ng : Quiver.Hom N K\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g) fun i k => Finset.univ.sum fun j => HMul.hMul (f i j) (g j k)","decl":"theorem comp_def {M N K : Mat R} (f : M ‚ü∂ N) (g : N ‚ü∂ K) :\n    f ‚â´ g = fun i k => ‚àë j : N, f i j * g j k :=\n  rfl\n\n"}
{"name":"CategoryTheory.Mat.comp_apply","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"R : Type u\ninst‚úù : Semiring R\nM N K : CategoryTheory.Mat R\nf : Quiver.Hom M N\ng : Quiver.Hom N K\ni : ‚ÜëM\nk : ‚ÜëK\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g i k) (Finset.univ.sum fun j => HMul.hMul (f i j) (g j k))","decl":"@[simp]\ntheorem comp_apply {M N K : Mat R} (f : M ‚ü∂ N) (g : N ‚ü∂ K) (i k) :\n    (f ‚â´ g) i k = ‚àë j : N, f i j * g j k :=\n  rfl\n\n"}
{"name":"CategoryTheory.Mat.equivalenceSingleObjInverse_map","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"R : Type\ninst‚úù : Ring R\nX‚úù Y‚úù : CategoryTheory.Mat_ (CategoryTheory.SingleObj (MulOpposite R))\nf : Quiver.Hom X‚úù Y‚úù\ni : ‚Üë((fun X => FintypeCat.of X.Œπ) X‚úù)\nj : ‚Üë((fun X => FintypeCat.of X.Œπ) Y‚úù)\n‚ä¢ Eq ((CategoryTheory.Mat.equivalenceSingleObjInverse R).map f i j) (MulOpposite.unop (f i j))","decl":"/-- Auxiliary definition for `CategoryTheory.Mat.equivalenceSingleObj`. -/\n@[simps]\ndef equivalenceSingleObjInverse : Mat_ (SingleObj R·µê·µí·µñ) ‚•§ Mat R where\n  obj X := FintypeCat.of X.Œπ\n  map f i j := MulOpposite.unop (f i j)\n  map_id X := by\n    ext\n    simp only [Mat_.id_def, id_def]\n    split_ifs <;> rfl\n  map_comp f g := by\n    -- Porting note: this proof was automatic in mathlib3\n    ext\n    simp only [Mat_.comp_apply, comp_apply]\n    apply Finset.unop_sum\n\n"}
{"name":"CategoryTheory.Mat.equivalenceSingleObjInverse_obj","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"R : Type\ninst‚úù : Ring R\nX : CategoryTheory.Mat_ (CategoryTheory.SingleObj (MulOpposite R))\n‚ä¢ Eq ((CategoryTheory.Mat.equivalenceSingleObjInverse R).obj X) (FintypeCat.of X.Œπ)","decl":"/-- Auxiliary definition for `CategoryTheory.Mat.equivalenceSingleObj`. -/\n@[simps]\ndef equivalenceSingleObjInverse : Mat_ (SingleObj R·µê·µí·µñ) ‚•§ Mat R where\n  obj X := FintypeCat.of X.Œπ\n  map f i j := MulOpposite.unop (f i j)\n  map_id X := by\n    ext\n    simp only [Mat_.id_def, id_def]\n    split_ifs <;> rfl\n  map_comp f g := by\n    -- Porting note: this proof was automatic in mathlib3\n    ext\n    simp only [Mat_.comp_apply, comp_apply]\n    apply Finset.unop_sum\n\n"}
{"name":"CategoryTheory.Mat.instFaithfulMat_SingleObjMulOppositeEquivalenceSingleObjInverse","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"R : Type\ninst‚úù : Ring R\n‚ä¢ (CategoryTheory.Mat.equivalenceSingleObjInverse R).Faithful","decl":"instance : (equivalenceSingleObjInverse R).Faithful where\n  map_injective w := by\n    ext\n    apply_fun MulOpposite.unop using MulOpposite.unop_injective\n    exact congr_fun (congr_fun w _) _\n\n"}
{"name":"CategoryTheory.Mat.instFullMat_SingleObjMulOppositeEquivalenceSingleObjInverse","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"R : Type\ninst‚úù : Ring R\n‚ä¢ (CategoryTheory.Mat.equivalenceSingleObjInverse R).Full","decl":"instance : (equivalenceSingleObjInverse R).Full where\n  map_surjective f := ‚ü®fun i j => MulOpposite.op (f i j), rfl‚ü©\n\n"}
{"name":"CategoryTheory.Mat.instEssSurjMat_SingleObjMulOppositeEquivalenceSingleObjInverse","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"R : Type\ninst‚úù : Ring R\n‚ä¢ (CategoryTheory.Mat.equivalenceSingleObjInverse R).EssSurj","decl":"instance : (equivalenceSingleObjInverse R).EssSurj where\n  mem_essImage X :=\n    ‚ü®{  Œπ := X\n        X := fun _ => PUnit.unit }, ‚ü®eqToIso (by dsimp; cases X; congr)‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Mat.instIsEquivalenceMat_SingleObjMulOppositeEquivalenceSingleObjInverse","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"R : Type\ninst‚úù : Ring R\n‚ä¢ (CategoryTheory.Mat.equivalenceSingleObjInverse R).IsEquivalence","decl":"instance : (equivalenceSingleObjInverse R).IsEquivalence where\n\n"}
{"name":"CategoryTheory.Mat.add_apply","module":"Mathlib.CategoryTheory.Preadditive.Mat","initialProofState":"R : Type\ninst‚úù : Ring R\nM N : CategoryTheory.Mat R\nf g : Quiver.Hom M N\ni : ‚ÜëM\nj : ‚ÜëN\n‚ä¢ Eq (HAdd.hAdd f g i j) (HAdd.hAdd (f i j) (g i j))","decl":"@[simp]\ntheorem add_apply {M N : Mat R} (f g : M ‚ü∂ N) (i j) : (f + g) i j = f i j + g i j :=\n  rfl\n\n"}
