{"name":"Fin2.fs.inj","module":"Mathlib.Data.Fin.Fin2","initialProofState":"n : Nat\na✝¹ a✝ : Fin2 n\nx✝ : Eq a✝¹.fs a✝.fs\n⊢ Eq a✝¹ a✝","decl":"/-- An alternate definition of `Fin n` defined as an inductive type instead of a subtype of `ℕ`. -/\ninductive Fin2 : ℕ → Type\n  /-- `0` as a member of `Fin (n + 1)` (`Fin 0` is empty) -/\n  | fz {n} : Fin2 (n + 1)\n  /-- `n` as a member of `Fin (n + 1)` -/\n  | fs {n} : Fin2 n → Fin2 (n + 1)\n\n"}
{"name":"Fin2.fs.sizeOf_spec","module":"Mathlib.Data.Fin.Fin2","initialProofState":"n : Nat\na✝ : Fin2 n\n⊢ Eq (SizeOf.sizeOf a✝.fs) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf n)) (SizeOf.sizeOf a✝))","decl":"/-- An alternate definition of `Fin n` defined as an inductive type instead of a subtype of `ℕ`. -/\ninductive Fin2 : ℕ → Type\n  /-- `0` as a member of `Fin (n + 1)` (`Fin 0` is empty) -/\n  | fz {n} : Fin2 (n + 1)\n  /-- `n` as a member of `Fin (n + 1)` -/\n  | fs {n} : Fin2 n → Fin2 (n + 1)\n\n"}
{"name":"Fin2.fs.injEq","module":"Mathlib.Data.Fin.Fin2","initialProofState":"n : Nat\na✝¹ a✝ : Fin2 n\n⊢ Eq (Eq a✝¹.fs a✝.fs) (Eq a✝¹ a✝)","decl":"/-- An alternate definition of `Fin n` defined as an inductive type instead of a subtype of `ℕ`. -/\ninductive Fin2 : ℕ → Type\n  /-- `0` as a member of `Fin (n + 1)` (`Fin 0` is empty) -/\n  | fz {n} : Fin2 (n + 1)\n  /-- `n` as a member of `Fin (n + 1)` -/\n  | fs {n} : Fin2 n → Fin2 (n + 1)\n\n"}
{"name":"Fin2.fz.sizeOf_spec","module":"Mathlib.Data.Fin.Fin2","initialProofState":"n : Nat\n⊢ Eq (SizeOf.sizeOf Fin2.fz) (HAdd.hAdd 1 (SizeOf.sizeOf n))","decl":"/-- An alternate definition of `Fin n` defined as an inductive type instead of a subtype of `ℕ`. -/\ninductive Fin2 : ℕ → Type\n  /-- `0` as a member of `Fin (n + 1)` (`Fin 0` is empty) -/\n  | fz {n} : Fin2 (n + 1)\n  /-- `n` as a member of `Fin (n + 1)` -/\n  | fs {n} : Fin2 n → Fin2 (n + 1)\n\n"}
{"name":"Fin2.IsLT.h","module":"Mathlib.Data.Fin.Fin2","initialProofState":"m n : Nat\nself : Fin2.IsLT m n\n⊢ LT.lt m n","decl":"/-- This is a simple type class inference prover for proof obligations\n  of the form `m < n` where `m n : ℕ`. -/\nclass IsLT (m n : ℕ) : Prop where\n  /-- The unique field of `Fin2.IsLT`, a proof that `m < n`. -/\n  h : m < n\n\n"}
{"name":"Fin2.IsLT.zero","module":"Mathlib.Data.Fin.Fin2","initialProofState":"n : Nat\n⊢ Fin2.IsLT 0 n.succ","decl":"instance IsLT.zero (n) : IsLT 0 (succ n) :=\n  ⟨succ_pos _⟩\n\n"}
{"name":"Fin2.IsLT.succ","module":"Mathlib.Data.Fin.Fin2","initialProofState":"m n : Nat\nl : Fin2.IsLT m n\n⊢ Fin2.IsLT m.succ n.succ","decl":"instance IsLT.succ (m n) [l : IsLT m n] : IsLT (succ m) (succ n) :=\n  ⟨succ_lt_succ l.h⟩\n\n"}
{"name":"Fin2.rev_last","module":"Mathlib.Data.Fin.Fin2","initialProofState":"n : Nat\n⊢ Eq Fin2.last.rev Fin2.fz","decl":"@[simp] lemma rev_last {n} : rev (@last n) = fz := by\n  induction n <;> simp_all [rev, castSucc, last]\n\n"}
{"name":"Fin2.rev_castSucc","module":"Mathlib.Data.Fin.Fin2","initialProofState":"n : Nat\ni : Fin2 n\n⊢ Eq i.castSucc.rev i.rev.fs","decl":"@[simp] lemma rev_castSucc {n} (i : Fin2 n) : rev (castSucc i) = fs (rev i) := by\n  induction i <;> simp_all [rev, castSucc, last]\n\n"}
{"name":"Fin2.rev_rev","module":"Mathlib.Data.Fin.Fin2","initialProofState":"n : Nat\ni : Fin2 n\n⊢ Eq i.rev.rev i","decl":"@[simp] lemma rev_rev {n} (i : Fin2 n) : i.rev.rev = i := by\n  induction i <;> simp_all [rev]\n\n"}
{"name":"Fin2.rev_involutive","module":"Mathlib.Data.Fin.Fin2","initialProofState":"n : Nat\n⊢ Function.Involutive Fin2.rev","decl":"theorem rev_involutive {n} : Function.Involutive (@rev n) := rev_rev\n\n"}
