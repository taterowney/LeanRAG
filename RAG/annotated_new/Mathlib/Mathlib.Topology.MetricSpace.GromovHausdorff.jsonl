{"name":"GromovHausdorff.eq_toGHSpace_iff","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"X : Type u\ninst✝² : MetricSpace X\ninst✝¹ : CompactSpace X\ninst✝ : Nonempty X\np : TopologicalSpace.NonemptyCompacts (Subtype fun x => Membership.mem (lp (fun n => Real) Top.top) x)\n⊢ Iff (Eq (Quotient.mk GromovHausdorff.IsometryRel.setoid p) (GromovHausdorff.toGHSpace X)) (Exists fun Ψ => And (Isometry Ψ) (Eq (Set.range Ψ) ↑p))","decl":"theorem eq_toGHSpace_iff {X : Type u} [MetricSpace X] [CompactSpace X] [Nonempty X]\n    {p : NonemptyCompacts ℓ_infty_ℝ} :\n    ⟦p⟧ = toGHSpace X ↔ ∃ Ψ : X → ℓ_infty_ℝ, Isometry Ψ ∧ range Ψ = p := by\n  simp only [toGHSpace, Quotient.eq]\n  refine ⟨fun h => ?_, ?_⟩\n  · rcases Setoid.symm h with ⟨e⟩\n    have f := (kuratowskiEmbedding.isometry X).isometryEquivOnRange.trans e\n    use fun x => f x, isometry_subtype_coe.comp f.isometry\n    erw [range_comp, f.range_eq_univ, Set.image_univ, Subtype.range_coe]\n  · rintro ⟨Ψ, ⟨isomΨ, rangeΨ⟩⟩\n    have f :=\n      ((kuratowskiEmbedding.isometry X).isometryEquivOnRange.symm.trans\n          isomΨ.isometryEquivOnRange).symm\n    have E : (range Ψ ≃ᵢ NonemptyCompacts.kuratowskiEmbedding X)\n        = (p ≃ᵢ range (kuratowskiEmbedding X)) := by\n      dsimp only [NonemptyCompacts.kuratowskiEmbedding]; rw [rangeΨ]; rfl\n    exact ⟨cast E f⟩\n\n"}
{"name":"GromovHausdorff.eq_toGHSpace","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"p : TopologicalSpace.NonemptyCompacts (Subtype fun x => Membership.mem (lp (fun n => Real) Top.top) x)\n⊢ Eq (Quotient.mk GromovHausdorff.IsometryRel.setoid p) (GromovHausdorff.toGHSpace (Subtype fun x => Membership.mem p x))","decl":"theorem eq_toGHSpace {p : NonemptyCompacts ℓ_infty_ℝ} : ⟦p⟧ = toGHSpace p :=\n  eq_toGHSpace_iff.2 ⟨fun x => x, isometry_subtype_coe, Subtype.range_coe⟩\n\n"}
{"name":"GromovHausdorff.rep_gHSpace_compactSpace","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"p : GromovHausdorff.GHSpace\n⊢ CompactSpace p.Rep","decl":"instance rep_gHSpace_compactSpace {p : GHSpace} : CompactSpace p.Rep :=\n  inferInstanceAs <| CompactSpace p.out\n\n"}
{"name":"GromovHausdorff.rep_gHSpace_nonempty","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"p : GromovHausdorff.GHSpace\n⊢ Nonempty p.Rep","decl":"instance rep_gHSpace_nonempty {p : GHSpace} : Nonempty p.Rep :=\n  inferInstanceAs <| Nonempty p.out\n\n"}
{"name":"GromovHausdorff.GHSpace.toGHSpace_rep","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"p : GromovHausdorff.GHSpace\n⊢ Eq (GromovHausdorff.toGHSpace p.Rep) p","decl":"theorem GHSpace.toGHSpace_rep (p : GHSpace) : toGHSpace p.Rep = p := by\n  change toGHSpace (Quot.out p : NonemptyCompacts ℓ_infty_ℝ) = p\n  rw [← eq_toGHSpace]\n  exact Quot.out_eq p\n\n"}
{"name":"GromovHausdorff.toGHSpace_eq_toGHSpace_iff_isometryEquiv","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"X : Type u\ninst✝⁵ : MetricSpace X\ninst✝⁴ : CompactSpace X\ninst✝³ : Nonempty X\nY : Type v\ninst✝² : MetricSpace Y\ninst✝¹ : CompactSpace Y\ninst✝ : Nonempty Y\n⊢ Iff (Eq (GromovHausdorff.toGHSpace X) (GromovHausdorff.toGHSpace Y)) (Nonempty (IsometryEquiv X Y))","decl":"/-- Two nonempty compact spaces have the same image in `GHSpace` if and only if they are\nisometric. -/\ntheorem toGHSpace_eq_toGHSpace_iff_isometryEquiv {X : Type u} [MetricSpace X] [CompactSpace X]\n    [Nonempty X] {Y : Type v} [MetricSpace Y] [CompactSpace Y] [Nonempty Y] :\n    toGHSpace X = toGHSpace Y ↔ Nonempty (X ≃ᵢ Y) :=\n  ⟨by\n    simp only [toGHSpace]\n    rw [Quotient.eq]\n    rintro ⟨e⟩\n    have I :\n      (NonemptyCompacts.kuratowskiEmbedding X ≃ᵢ NonemptyCompacts.kuratowskiEmbedding Y) =\n        (range (kuratowskiEmbedding X) ≃ᵢ range (kuratowskiEmbedding Y)) := by\n      dsimp only [NonemptyCompacts.kuratowskiEmbedding]; rfl\n    have f := (kuratowskiEmbedding.isometry X).isometryEquivOnRange\n    have g := (kuratowskiEmbedding.isometry Y).isometryEquivOnRange.symm\n    exact ⟨f.trans <| (cast I e).trans g⟩, by\n    rintro ⟨e⟩\n    simp only [toGHSpace, Quotient.eq']\n    have f := (kuratowskiEmbedding.isometry X).isometryEquivOnRange.symm\n    have g := (kuratowskiEmbedding.isometry Y).isometryEquivOnRange\n    have I :\n      (range (kuratowskiEmbedding X) ≃ᵢ range (kuratowskiEmbedding Y)) =\n        (NonemptyCompacts.kuratowskiEmbedding X ≃ᵢ NonemptyCompacts.kuratowskiEmbedding Y) := by\n      dsimp only [NonemptyCompacts.kuratowskiEmbedding]; rfl\n    rw [Quotient.eq]\n    exact ⟨cast I ((f.trans e).trans g)⟩⟩\n\n"}
{"name":"GromovHausdorff.dist_ghDist","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"p q : GromovHausdorff.GHSpace\n⊢ Eq (Dist.dist p q) (GromovHausdorff.ghDist p.Rep q.Rep)","decl":"theorem dist_ghDist (p q : GHSpace) : dist p q = ghDist p.Rep q.Rep := by\n  rw [ghDist, p.toGHSpace_rep, q.toGHSpace_rep]\n\n"}
{"name":"GromovHausdorff.ghDist_le_hausdorffDist","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"X : Type u\ninst✝⁶ : MetricSpace X\ninst✝⁵ : CompactSpace X\ninst✝⁴ : Nonempty X\nY : Type v\ninst✝³ : MetricSpace Y\ninst✝² : CompactSpace Y\ninst✝¹ : Nonempty Y\nγ : Type w\ninst✝ : MetricSpace γ\nΦ : X → γ\nΨ : Y → γ\nha : Isometry Φ\nhb : Isometry Ψ\n⊢ LE.le (GromovHausdorff.ghDist X Y) (Metric.hausdorffDist (Set.range Φ) (Set.range Ψ))","decl":"/-- The Gromov-Hausdorff distance between two spaces is bounded by the Hausdorff distance\nof isometric copies of the spaces, in any metric space. -/\ntheorem ghDist_le_hausdorffDist {X : Type u} [MetricSpace X] [CompactSpace X] [Nonempty X]\n    {Y : Type v} [MetricSpace Y] [CompactSpace Y] [Nonempty Y] {γ : Type w} [MetricSpace γ]\n    {Φ : X → γ} {Ψ : Y → γ} (ha : Isometry Φ) (hb : Isometry Ψ) :\n    ghDist X Y ≤ hausdorffDist (range Φ) (range Ψ) := by\n  /- For the proof, we want to embed `γ` in `ℓ^∞(ℝ)`, to say that the Hausdorff distance is realized\n    in `ℓ^∞(ℝ)` and therefore bounded below by the Gromov-Hausdorff-distance. However, `γ` is not\n    separable in general. We restrict to the union of the images of `X` and `Y` in `γ`, which is\n    separable and therefore embeddable in `ℓ^∞(ℝ)`. -/\n  rcases exists_mem_of_nonempty X with ⟨xX, _⟩\n  let s : Set γ := range Φ ∪ range Ψ\n  let Φ' : X → Subtype s := fun y => ⟨Φ y, mem_union_left _ (mem_range_self _)⟩\n  let Ψ' : Y → Subtype s := fun y => ⟨Ψ y, mem_union_right _ (mem_range_self _)⟩\n  have IΦ' : Isometry Φ' := fun x y => ha x y\n  have IΨ' : Isometry Ψ' := fun x y => hb x y\n  have : IsCompact s := (isCompact_range ha.continuous).union (isCompact_range hb.continuous)\n  letI : MetricSpace (Subtype s) := by infer_instance\n  haveI : CompactSpace (Subtype s) := ⟨isCompact_iff_isCompact_univ.1 ‹IsCompact s›⟩\n  haveI : Nonempty (Subtype s) := ⟨Φ' xX⟩\n  have ΦΦ' : Φ = Subtype.val ∘ Φ' := by funext; rfl\n  have ΨΨ' : Ψ = Subtype.val ∘ Ψ' := by funext; rfl\n  have : hausdorffDist (range Φ) (range Ψ) = hausdorffDist (range Φ') (range Ψ') := by\n    rw [ΦΦ', ΨΨ', range_comp, range_comp]\n    exact hausdorffDist_image isometry_subtype_coe\n  rw [this]\n  -- Embed `s` in `ℓ^∞(ℝ)` through its Kuratowski embedding\n  let F := kuratowskiEmbedding (Subtype s)\n  have : hausdorffDist (F '' range Φ') (F '' range Ψ') = hausdorffDist (range Φ') (range Ψ') :=\n    hausdorffDist_image (kuratowskiEmbedding.isometry _)\n  rw [← this]\n  -- Let `A` and `B` be the images of `X` and `Y` under this embedding. They are in `ℓ^∞(ℝ)`, and\n  -- their Hausdorff distance is the same as in the original space.\n  let A : NonemptyCompacts ℓ_infty_ℝ :=\n    ⟨⟨F '' range Φ',\n        (isCompact_range IΦ'.continuous).image (kuratowskiEmbedding.isometry _).continuous⟩,\n      (range_nonempty _).image _⟩\n  let B : NonemptyCompacts ℓ_infty_ℝ :=\n    ⟨⟨F '' range Ψ',\n        (isCompact_range IΨ'.continuous).image (kuratowskiEmbedding.isometry _).continuous⟩,\n      (range_nonempty _).image _⟩\n  have AX : ⟦A⟧ = toGHSpace X := by\n    rw [eq_toGHSpace_iff]\n    exact ⟨fun x => F (Φ' x), (kuratowskiEmbedding.isometry _).comp IΦ', range_comp _ _⟩\n  have BY : ⟦B⟧ = toGHSpace Y := by\n    rw [eq_toGHSpace_iff]\n    exact ⟨fun x => F (Ψ' x), (kuratowskiEmbedding.isometry _).comp IΨ', range_comp _ _⟩\n  refine csInf_le ⟨0, ?_⟩ ?_\n  · simp only [lowerBounds, mem_image, mem_prod, mem_setOf_eq, Prod.exists, and_imp,\n      forall_exists_index]\n    intro t _ _ _ _ ht\n    rw [← ht]\n    exact hausdorffDist_nonneg\n  apply (mem_image _ _ _).2\n  exists (⟨A, B⟩ : NonemptyCompacts ℓ_infty_ℝ × NonemptyCompacts ℓ_infty_ℝ)\n\n"}
{"name":"GromovHausdorff.hausdorffDist_optimal","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"X : Type u\ninst✝⁵ : MetricSpace X\ninst✝⁴ : CompactSpace X\ninst✝³ : Nonempty X\nY : Type v\ninst✝² : MetricSpace Y\ninst✝¹ : CompactSpace Y\ninst✝ : Nonempty Y\n⊢ Eq (Metric.hausdorffDist (Set.range (GromovHausdorff.optimalGHInjl X Y)) (Set.range (GromovHausdorff.optimalGHInjr X Y))) (GromovHausdorff.ghDist X Y)","decl":"/-- The optimal coupling constructed above realizes exactly the Gromov-Hausdorff distance,\nessentially by design. -/\ntheorem hausdorffDist_optimal {X : Type u} [MetricSpace X] [CompactSpace X] [Nonempty X]\n    {Y : Type v} [MetricSpace Y] [CompactSpace Y] [Nonempty Y] :\n    hausdorffDist (range (optimalGHInjl X Y)) (range (optimalGHInjr X Y)) = ghDist X Y := by\n  inhabit X; inhabit Y\n  /- we only need to check the inequality `≤`, as the other one follows from the previous lemma.\n       As the Gromov-Hausdorff distance is an infimum, we need to check that the Hausdorff distance\n       in the optimal coupling is smaller than the Hausdorff distance of any coupling.\n       First, we check this for couplings which already have small Hausdorff distance: in this\n       case, the induced \"distance\" on `X ⊕ Y` belongs to the candidates family introduced in the\n       definition of the optimal coupling, and the conclusion follows from the optimality\n       of the optimal coupling within this family.\n    -/\n  have A :\n    ∀ p q : NonemptyCompacts ℓ_infty_ℝ,\n      ⟦p⟧ = toGHSpace X →\n        ⟦q⟧ = toGHSpace Y →\n          hausdorffDist (p : Set ℓ_infty_ℝ) q < diam (univ : Set X) + 1 + diam (univ : Set Y) →\n            hausdorffDist (range (optimalGHInjl X Y)) (range (optimalGHInjr X Y)) ≤\n              hausdorffDist (p : Set ℓ_infty_ℝ) q := by\n    intro p q hp hq bound\n    rcases eq_toGHSpace_iff.1 hp with ⟨Φ, ⟨Φisom, Φrange⟩⟩\n    rcases eq_toGHSpace_iff.1 hq with ⟨Ψ, ⟨Ψisom, Ψrange⟩⟩\n    have I : diam (range Φ ∪ range Ψ) ≤ 2 * diam (univ : Set X) + 1 + 2 * diam (univ : Set Y) := by\n      rcases exists_mem_of_nonempty X with ⟨xX, _⟩\n      have : ∃ y ∈ range Ψ, dist (Φ xX) y < diam (univ : Set X) + 1 + diam (univ : Set Y) := by\n        rw [Ψrange]\n        have : Φ xX ∈ (p : Set _) := Φrange ▸ (mem_range_self _)\n        exact\n          exists_dist_lt_of_hausdorffDist_lt this bound\n            (hausdorffEdist_ne_top_of_nonempty_of_bounded p.nonempty q.nonempty\n              p.isCompact.isBounded q.isCompact.isBounded)\n      rcases this with ⟨y, hy, dy⟩\n      rcases mem_range.1 hy with ⟨z, hzy⟩\n      rw [← hzy] at dy\n      have DΦ : diam (range Φ) = diam (univ : Set X) := Φisom.diam_range\n      have DΨ : diam (range Ψ) = diam (univ : Set Y) := Ψisom.diam_range\n      calc\n        diam (range Φ ∪ range Ψ) ≤ diam (range Φ) + dist (Φ xX) (Ψ z) + diam (range Ψ) :=\n          diam_union (mem_range_self _) (mem_range_self _)\n        _ ≤\n            diam (univ : Set X) + (diam (univ : Set X) + 1 + diam (univ : Set Y)) +\n              diam (univ : Set Y) := by\n          rw [DΦ, DΨ]\n          gcongr\n          -- apply add_le_add (add_le_add le_rfl (le_of_lt dy)) le_rfl\n        _ = 2 * diam (univ : Set X) + 1 + 2 * diam (univ : Set Y) := by ring\n    let f : X ⊕ Y → ℓ_infty_ℝ := fun x =>\n      match x with\n      | inl y => Φ y\n      | inr z => Ψ z\n    let F : (X ⊕ Y) × (X ⊕ Y) → ℝ := fun p => dist (f p.1) (f p.2)\n    -- check that the induced \"distance\" is a candidate\n    have Fgood : F ∈ candidates X Y := by\n      simp only [F, candidates, forall_const, add_comm, eq_self_iff_true,\n        dist_eq_zero, and_self_iff, Set.mem_setOf_eq]\n      repeat' constructor\n      · exact fun x y =>\n          calc\n            F (inl x, inl y) = dist (Φ x) (Φ y) := rfl\n            _ = dist x y := Φisom.dist_eq x y\n\n      · exact fun x y =>\n          calc\n            F (inr x, inr y) = dist (Ψ x) (Ψ y) := rfl\n            _ = dist x y := Ψisom.dist_eq x y\n\n      · exact fun x y => dist_comm _ _\n      · exact fun x y z => dist_triangle _ _ _\n      · exact fun x y =>\n          calc\n            F (x, y) ≤ diam (range Φ ∪ range Ψ) := by\n              have A : ∀ z : X ⊕ Y, f z ∈ range Φ ∪ range Ψ := by\n                intro z\n                cases z\n                · apply mem_union_left; apply mem_range_self\n                · apply mem_union_right; apply mem_range_self\n              refine dist_le_diam_of_mem ?_ (A _) (A _)\n              rw [Φrange, Ψrange]\n              exact (p ⊔ q).isCompact.isBounded\n            _ ≤ 2 * diam (univ : Set X) + 1 + 2 * diam (univ : Set Y) := I\n    let Fb := candidatesBOfCandidates F Fgood\n    have : hausdorffDist (range (optimalGHInjl X Y)) (range (optimalGHInjr X Y)) ≤ HD Fb :=\n      hausdorffDist_optimal_le_HD _ _ (candidatesBOfCandidates_mem F Fgood)\n    refine le_trans this (le_of_forall_gt_imp_ge_of_dense fun r hr => ?_)\n    have I1 : ∀ x : X, (⨅ y, Fb (inl x, inr y)) ≤ r := by\n      intro x\n      have : f (inl x) ∈ (p : Set _) := Φrange ▸ (mem_range_self _)\n      rcases exists_dist_lt_of_hausdorffDist_lt this hr\n          (hausdorffEdist_ne_top_of_nonempty_of_bounded p.nonempty q.nonempty p.isCompact.isBounded\n            q.isCompact.isBounded) with\n        ⟨z, zq, hz⟩\n      have : z ∈ range Ψ := by rwa [← Ψrange] at zq\n      rcases mem_range.1 this with ⟨y, hy⟩\n      calc\n        (⨅ y, Fb (inl x, inr y)) ≤ Fb (inl x, inr y) :=\n          ciInf_le (by simpa only [add_zero] using HD_below_aux1 0) y\n        _ = dist (Φ x) (Ψ y) := rfl\n        _ = dist (f (inl x)) z := by rw [hy]\n        _ ≤ r := le_of_lt hz\n\n    have I2 : ∀ y : Y, (⨅ x, Fb (inl x, inr y)) ≤ r := by\n      intro y\n      have : f (inr y) ∈ (q : Set _) := Ψrange ▸ (mem_range_self _)\n      rcases exists_dist_lt_of_hausdorffDist_lt' this hr\n          (hausdorffEdist_ne_top_of_nonempty_of_bounded p.nonempty q.nonempty p.isCompact.isBounded\n            q.isCompact.isBounded) with\n        ⟨z, zq, hz⟩\n      have : z ∈ range Φ := by rwa [← Φrange] at zq\n      rcases mem_range.1 this with ⟨x, hx⟩\n      calc\n        (⨅ x, Fb (inl x, inr y)) ≤ Fb (inl x, inr y) :=\n          ciInf_le (by simpa only [add_zero] using HD_below_aux2 0) x\n        _ = dist (Φ x) (Ψ y) := rfl\n        _ = dist z (f (inr y)) := by rw [hx]\n        _ ≤ r := le_of_lt hz\n\n    simp only [HD, ciSup_le I1, ciSup_le I2, max_le_iff, and_self_iff]\n  /- Get the same inequality for any coupling. If the coupling is quite good, the desired\n    inequality has been proved above. If it is bad, then the inequality is obvious. -/\n  have B :\n    ∀ p q : NonemptyCompacts ℓ_infty_ℝ,\n      ⟦p⟧ = toGHSpace X →\n        ⟦q⟧ = toGHSpace Y →\n          hausdorffDist (range (optimalGHInjl X Y)) (range (optimalGHInjr X Y)) ≤\n            hausdorffDist (p : Set ℓ_infty_ℝ) q := by\n    intro p q hp hq\n    by_cases h :\n      hausdorffDist (p : Set ℓ_infty_ℝ) q < diam (univ : Set X) + 1 + diam (univ : Set Y)\n    · exact A p q hp hq h\n    · calc\n        hausdorffDist (range (optimalGHInjl X Y)) (range (optimalGHInjr X Y)) ≤\n            HD (candidatesBDist X Y) :=\n          hausdorffDist_optimal_le_HD _ _ candidatesBDist_mem_candidatesB\n        _ ≤ diam (univ : Set X) + 1 + diam (univ : Set Y) := HD_candidatesBDist_le\n        _ ≤ hausdorffDist (p : Set ℓ_infty_ℝ) q := not_lt.1 h\n  refine le_antisymm ?_ ?_\n  · apply le_csInf\n    · refine (Set.Nonempty.prod ?_ ?_).image _ <;> exact ⟨_, rfl⟩\n    · rintro b ⟨⟨p, q⟩, ⟨hp, hq⟩, rfl⟩\n      exact B p q hp hq\n  · exact ghDist_le_hausdorffDist (isometry_optimalGHInjl X Y) (isometry_optimalGHInjr X Y)\n\n"}
{"name":"GromovHausdorff.ghDist_eq_hausdorffDist","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"X : Type u\ninst✝⁵ : MetricSpace X\ninst✝⁴ : CompactSpace X\ninst✝³ : Nonempty X\nY : Type v\ninst✝² : MetricSpace Y\ninst✝¹ : CompactSpace Y\ninst✝ : Nonempty Y\n⊢ Exists fun Φ => Exists fun Ψ => And (Isometry Φ) (And (Isometry Ψ) (Eq (GromovHausdorff.ghDist X Y) (Metric.hausdorffDist (Set.range Φ) (Set.range Ψ))))","decl":"/-- The Gromov-Hausdorff distance can also be realized by a coupling in `ℓ^∞(ℝ)`, by embedding\nthe optimal coupling through its Kuratowski embedding. -/\ntheorem ghDist_eq_hausdorffDist (X : Type u) [MetricSpace X] [CompactSpace X] [Nonempty X]\n    (Y : Type v) [MetricSpace Y] [CompactSpace Y] [Nonempty Y] :\n    ∃ Φ : X → ℓ_infty_ℝ,\n      ∃ Ψ : Y → ℓ_infty_ℝ,\n        Isometry Φ ∧ Isometry Ψ ∧ ghDist X Y = hausdorffDist (range Φ) (range Ψ) := by\n  let F := kuratowskiEmbedding (OptimalGHCoupling X Y)\n  let Φ := F ∘ optimalGHInjl X Y\n  let Ψ := F ∘ optimalGHInjr X Y\n  refine ⟨Φ, Ψ, ?_, ?_, ?_⟩\n  · exact (kuratowskiEmbedding.isometry _).comp (isometry_optimalGHInjl X Y)\n  · exact (kuratowskiEmbedding.isometry _).comp (isometry_optimalGHInjr X Y)\n  · rw [← image_univ, ← image_univ, image_comp F, image_univ, image_comp F (optimalGHInjr X Y),\n      image_univ, ← hausdorffDist_optimal]\n    exact (hausdorffDist_image (kuratowskiEmbedding.isometry _)).symm\n\n"}
{"name":"GromovHausdorff.ghDist_le_nonemptyCompacts_dist","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"X : Type u\ninst✝ : MetricSpace X\np q : TopologicalSpace.NonemptyCompacts X\n⊢ LE.le (Dist.dist p.toGHSpace q.toGHSpace) (Dist.dist p q)","decl":"theorem ghDist_le_nonemptyCompacts_dist (p q : NonemptyCompacts X) :\n    dist p.toGHSpace q.toGHSpace ≤ dist p q := by\n  have ha : Isometry ((↑) : p → X) := isometry_subtype_coe\n  have hb : Isometry ((↑) : q → X) := isometry_subtype_coe\n  have A : dist p q = hausdorffDist (p : Set X) q := rfl\n  have I : ↑p = range ((↑) : p → X) := Subtype.range_coe_subtype.symm\n  have J : ↑q = range ((↑) : q → X) := Subtype.range_coe_subtype.symm\n  rw [A, I, J]\n  exact ghDist_le_hausdorffDist ha hb\n\n"}
{"name":"GromovHausdorff.toGHSpace_lipschitz","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"⊢ sorryAx (Unit → Prop) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 523).num 4).num 523).num 79).num 4).num 79).str \"_sorry\").str \"_@\").str \"_hyg\").num 1838))","decl":"theorem toGHSpace_lipschitz :\n    LipschitzWith 1 (NonemptyCompacts.toGHSpace : NonemptyCompacts X → GHSpace) :=\n  LipschitzWith.mk_one ghDist_le_nonemptyCompacts_dist\n\n"}
{"name":"GromovHausdorff.toGHSpace_continuous","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"⊢ sorryAx (Unit → Prop) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 527).num 4).num 527).num 74).num 4).num 74).str \"_sorry\").str \"_@\").str \"_hyg\").num 1862))","decl":"theorem toGHSpace_continuous :\n    Continuous (NonemptyCompacts.toGHSpace : NonemptyCompacts X → GHSpace) :=\n  toGHSpace_lipschitz.continuous\n\n"}
{"name":"GromovHausdorff.ghDist_le_of_approx_subsets","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"X : Type u\ninst✝⁵ : MetricSpace X\ninst✝⁴ : CompactSpace X\ninst✝³ : Nonempty X\nY : Type v\ninst✝² : MetricSpace Y\ninst✝¹ : CompactSpace Y\ninst✝ : Nonempty Y\ns : Set X\nΦ : ↑s → Y\nε₁ ε₂ ε₃ : Real\nhs : ∀ (x : X), Exists fun y => And (Membership.mem s y) (LE.le (Dist.dist x y) ε₁)\nhs' : ∀ (x : Y), Exists fun y => LE.le (Dist.dist x (Φ y)) ε₃\nH : ∀ (x y : ↑s), LE.le (abs (HSub.hSub (Dist.dist x y) (Dist.dist (Φ x) (Φ y)))) ε₂\n⊢ LE.le (GromovHausdorff.ghDist X Y) (HAdd.hAdd (HAdd.hAdd ε₁ (HDiv.hDiv ε₂ 2)) ε₃)","decl":"/-- If there are subsets which are `ε₁`-dense and `ε₃`-dense in two spaces, and\nisometric up to `ε₂`, then the Gromov-Hausdorff distance between the spaces is bounded by\n`ε₁ + ε₂/2 + ε₃`. -/\ntheorem ghDist_le_of_approx_subsets {s : Set X} (Φ : s → Y) {ε₁ ε₂ ε₃ : ℝ}\n    (hs : ∀ x : X, ∃ y ∈ s, dist x y ≤ ε₁) (hs' : ∀ x : Y, ∃ y : s, dist x (Φ y) ≤ ε₃)\n    (H : ∀ x y : s, |dist x y - dist (Φ x) (Φ y)| ≤ ε₂) : ghDist X Y ≤ ε₁ + ε₂ / 2 + ε₃ := by\n  refine le_of_forall_pos_le_add fun δ δ0 => ?_\n  rcases exists_mem_of_nonempty X with ⟨xX, _⟩\n  rcases hs xX with ⟨xs, hxs, Dxs⟩\n  have sne : s.Nonempty := ⟨xs, hxs⟩\n  letI : Nonempty s := sne.to_subtype\n  have : 0 ≤ ε₂ := le_trans (abs_nonneg _) (H ⟨xs, hxs⟩ ⟨xs, hxs⟩)\n  have : ∀ p q : s, |dist p q - dist (Φ p) (Φ q)| ≤ 2 * (ε₂ / 2 + δ) := fun p q =>\n    calc\n      |dist p q - dist (Φ p) (Φ q)| ≤ ε₂ := H p q\n      _ ≤ 2 * (ε₂ / 2 + δ) := by linarith\n  -- glue `X` and `Y` along the almost matching subsets\n  letI : MetricSpace (X ⊕ Y) :=\n    glueMetricApprox (fun x : s => (x : X)) (fun x => Φ x) (ε₂ / 2 + δ) (by linarith) this\n  let Fl := @Sum.inl X Y\n  let Fr := @Sum.inr X Y\n  have Il : Isometry Fl := Isometry.of_dist_eq fun x y => rfl\n  have Ir : Isometry Fr := Isometry.of_dist_eq fun x y => rfl\n  /- The proof goes as follows : the `GH_dist` is bounded by the Hausdorff distance of the images\n    in the coupling, which is bounded (using the triangular inequality) by the sum of the Hausdorff\n    distances of `X` and `s` (in the coupling or, equivalently in the original space), of `s` and\n    `Φ s`, and of `Φ s` and `Y` (in the coupling or, equivalently, in the original space).\n    The first term is bounded by `ε₁`, by `ε₁`-density. The third one is bounded by `ε₃`.\n    And the middle one is bounded by `ε₂/2` as in the coupling the points `x` and `Φ x` are\n    at distance `ε₂/2` by construction of the coupling (in fact `ε₂/2 + δ` where `δ` is an\n    arbitrarily small positive constant where positivity is used to ensure that the coupling\n    is really a metric space and not a premetric space on `X ⊕ Y`). -/\n  have : ghDist X Y ≤ hausdorffDist (range Fl) (range Fr) := ghDist_le_hausdorffDist Il Ir\n  have :\n    hausdorffDist (range Fl) (range Fr) ≤\n      hausdorffDist (range Fl) (Fl '' s) + hausdorffDist (Fl '' s) (range Fr) :=\n    have B : IsBounded (range Fl) := (isCompact_range Il.continuous).isBounded\n    hausdorffDist_triangle\n      (hausdorffEdist_ne_top_of_nonempty_of_bounded (range_nonempty _) (sne.image _) B\n        (B.subset (image_subset_range _ _)))\n  have :\n    hausdorffDist (Fl '' s) (range Fr) ≤\n      hausdorffDist (Fl '' s) (Fr '' range Φ) + hausdorffDist (Fr '' range Φ) (range Fr) :=\n    have B : IsBounded (range Fr) := (isCompact_range Ir.continuous).isBounded\n    hausdorffDist_triangle'\n      (hausdorffEdist_ne_top_of_nonempty_of_bounded ((range_nonempty _).image _) (range_nonempty _)\n        (B.subset (image_subset_range _ _)) B)\n  have : hausdorffDist (range Fl) (Fl '' s) ≤ ε₁ := by\n    rw [← image_univ, hausdorffDist_image Il]\n    have : 0 ≤ ε₁ := le_trans dist_nonneg Dxs\n    refine hausdorffDist_le_of_mem_dist this (fun x _ => hs x) fun x _ =>\n      ⟨x, mem_univ _, by simpa only [dist_self]⟩\n  have : hausdorffDist (Fl '' s) (Fr '' range Φ) ≤ ε₂ / 2 + δ := by\n    refine hausdorffDist_le_of_mem_dist (by linarith) ?_ ?_\n    · intro x' hx'\n      rcases (Set.mem_image _ _ _).1 hx' with ⟨x, ⟨x_in_s, xx'⟩⟩\n      rw [← xx']\n      use Fr (Φ ⟨x, x_in_s⟩), mem_image_of_mem Fr (mem_range_self _)\n      exact le_of_eq (glueDist_glued_points (fun x : s => (x : X)) Φ (ε₂ / 2 + δ) ⟨x, x_in_s⟩)\n    · intro x' hx'\n      rcases (Set.mem_image _ _ _).1 hx' with ⟨y, ⟨y_in_s', yx'⟩⟩\n      rcases mem_range.1 y_in_s' with ⟨x, xy⟩\n      use Fl x, mem_image_of_mem _ x.2\n      rw [← yx', ← xy, dist_comm]\n      exact le_of_eq (glueDist_glued_points (Z := s) (@Subtype.val X s) Φ (ε₂ / 2 + δ) x)\n  have : hausdorffDist (Fr '' range Φ) (range Fr) ≤ ε₃ := by\n    rw [← @image_univ _ _ Fr, hausdorffDist_image Ir]\n    rcases exists_mem_of_nonempty Y with ⟨xY, _⟩\n    rcases hs' xY with ⟨xs', Dxs'⟩\n    have : 0 ≤ ε₃ := le_trans dist_nonneg Dxs'\n    refine hausdorffDist_le_of_mem_dist this\n      (fun x _ => ⟨x, mem_univ _, by simpa only [dist_self]⟩)\n      fun x _ => ?_\n    rcases hs' x with ⟨y, Dy⟩\n    exact ⟨Φ y, mem_range_self _, Dy⟩\n  linarith\n\n"}
{"name":"GromovHausdorff.totallyBounded","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"t : Set GromovHausdorff.GHSpace\nC : Real\nu : Nat → Real\nK : Nat → Nat\nulim : Filter.Tendsto u Filter.atTop (nhds 0)\nhdiam : ∀ (p : GromovHausdorff.GHSpace), Membership.mem t p → LE.le (Metric.diam Set.univ) C\nhcov : ∀ (p : GromovHausdorff.GHSpace), Membership.mem t p → ∀ (n : Nat), Exists fun s => And (LE.le (Cardinal.mk ↑s) ↑(K n)) (HasSubset.Subset Set.univ (Set.iUnion fun x => Set.iUnion fun h => Metric.ball x (u n)))\n⊢ sorryAx (Unit → Prop) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 762).num 4).num 762).num 20).num 4).num 20).str \"_sorry\").str \"_@\").str \"_hyg\").num 2195))","decl":"/-- Compactness criterion: a closed set of compact metric spaces is compact if the spaces have\na uniformly bounded diameter, and for all `ε` the number of balls of radius `ε` required\nto cover the spaces is uniformly bounded. This is an equivalence, but we only prove the\ninteresting direction that these conditions imply compactness. -/\ntheorem totallyBounded {t : Set GHSpace} {C : ℝ} {u : ℕ → ℝ} {K : ℕ → ℕ}\n    (ulim : Tendsto u atTop (𝓝 0)) (hdiam : ∀ p ∈ t, diam (univ : Set (GHSpace.Rep p)) ≤ C)\n    (hcov : ∀ p ∈ t, ∀ n : ℕ, ∃ s : Set (GHSpace.Rep p),\n      (#s) ≤ K n ∧ univ ⊆ ⋃ x ∈ s, ball x (u n)) :\n    TotallyBounded t := by\n  /- Let `δ>0`, and `ε = δ/5`. For each `p`, we construct a finite subset `s p` of `p`, which\n    is `ε`-dense and has cardinality at most `K n`. Encoding the mutual distances of points\n    in `s p`, up to `ε`, we will get a map `F` associating to `p` finitely many data, and making\n    it possible to reconstruct `p` up to `ε`. This is enough to prove total boundedness. -/\n  refine Metric.totallyBounded_of_finite_discretization fun δ δpos => ?_\n  let ε := 1 / 5 * δ\n  have εpos : 0 < ε := mul_pos (by norm_num) δpos\n  -- choose `n` for which `u n < ε`\n  rcases Metric.tendsto_atTop.1 ulim ε εpos with ⟨n, hn⟩\n  have u_le_ε : u n ≤ ε := by\n    have := hn n le_rfl\n    simp only [Real.dist_eq, add_zero, sub_eq_add_neg, neg_zero] at this\n    exact le_of_lt (lt_of_le_of_lt (le_abs_self _) this)\n  -- construct a finite subset `s p` of `p` which is `ε`-dense and has cardinal `≤ K n`\n  have :\n    ∀ p : GHSpace,\n      ∃ s : Set p.Rep, ∃ N ≤ K n, ∃ _ : Equiv s (Fin N), p ∈ t → univ ⊆ ⋃ x ∈ s, ball x (u n) := by\n    intro p\n    by_cases hp : p ∉ t\n    · have : Nonempty (Equiv (∅ : Set p.Rep) (Fin 0)) := by\n        rw [← Fintype.card_eq]\n        simp only [empty_card', Fintype.card_fin]\n      use ∅, 0, bot_le, this.some\n      -- Porting note: unclear why this next line wasn't needed in Lean 3\n      exact fun hp' => (hp hp').elim\n    · rcases hcov _ (Set.not_not_mem.1 hp) n with ⟨s, ⟨scard, scover⟩⟩\n      rcases Cardinal.lt_aleph0.1 (lt_of_le_of_lt scard (Cardinal.nat_lt_aleph0 _)) with ⟨N, hN⟩\n      rw [hN, Nat.cast_le] at scard\n      have : #s = #(Fin N) := by rw [hN, Cardinal.mk_fin]\n      cases' Quotient.exact this with E\n      use s, N, scard, E\n      simp only [scover, imp_true_iff]\n  choose s N hN E hs using this\n  -- Define a function `F` taking values in a finite type and associating to `p` enough data\n  -- to reconstruct it up to `ε`, namely the (discretized) distances between elements of `s p`.\n  let M := ⌊ε⁻¹ * max C 0⌋₊\n  let F : GHSpace → Σ k : Fin (K n).succ, Fin k → Fin k → Fin M.succ := fun p =>\n    ⟨⟨N p, lt_of_le_of_lt (hN p) (Nat.lt_succ_self _)⟩, fun a b =>\n      ⟨min M ⌊ε⁻¹ * dist ((E p).symm a) ((E p).symm b)⌋₊,\n        (min_le_left _ _).trans_lt (Nat.lt_succ_self _)⟩⟩\n  refine ⟨_, ?_, fun p => F p, ?_⟩\n  · infer_instance\n  -- It remains to show that if `F p = F q`, then `p` and `q` are `ε`-close\n  rintro ⟨p, pt⟩ ⟨q, qt⟩ hpq\n  have Npq : N p = N q := Fin.ext_iff.1 (Sigma.mk.inj_iff.1 hpq).1\n  let Ψ : s p → s q := fun x => (E q).symm (Fin.cast Npq ((E p) x))\n  let Φ : s p → q.Rep := fun x => Ψ x\n  have main : ghDist p.Rep q.Rep ≤ ε + ε / 2 + ε := by\n    -- to prove the main inequality, argue that `s p` is `ε`-dense in `p`, and `s q` is `ε`-dense\n    -- in `q`, and `s p` and `s q` are almost isometric. Then closeness follows\n    -- from `ghDist_le_of_approx_subsets`\n    refine ghDist_le_of_approx_subsets Φ ?_ ?_ ?_\n    · show ∀ x : p.Rep, ∃ y ∈ s p, dist x y ≤ ε\n      -- by construction, `s p` is `ε`-dense\n      intro x\n      have : x ∈ ⋃ y ∈ s p, ball y (u n) := (hs p pt) (mem_univ _)\n      rcases mem_iUnion₂.1 this with ⟨y, ys, hy⟩\n      exact ⟨y, ys, le_trans (le_of_lt hy) u_le_ε⟩\n    · show ∀ x : q.Rep, ∃ z : s p, dist x (Φ z) ≤ ε\n      -- by construction, `s q` is `ε`-dense, and it is the range of `Φ`\n      intro x\n      have : x ∈ ⋃ y ∈ s q, ball y (u n) := (hs q qt) (mem_univ _)\n      rcases mem_iUnion₂.1 this with ⟨y, ys, hy⟩\n      let i : ℕ := E q ⟨y, ys⟩\n      let hi := ((E q) ⟨y, ys⟩).2\n      have ihi_eq : (⟨i, hi⟩ : Fin (N q)) = (E q) ⟨y, ys⟩ := by rw [Fin.ext_iff, Fin.val_mk]\n      have hiq : i < N q := hi\n      have hip : i < N p := by rwa [Npq.symm] at hiq\n      let z := (E p).symm ⟨i, hip⟩\n      use z\n      have C1 : (E p) z = ⟨i, hip⟩ := (E p).apply_symm_apply ⟨i, hip⟩\n      have C2 : Fin.cast Npq ⟨i, hip⟩ = ⟨i, hi⟩ := rfl\n      have C3 : (E q).symm ⟨i, hi⟩ = ⟨y, ys⟩ := by\n        rw [ihi_eq]; exact (E q).symm_apply_apply ⟨y, ys⟩\n      have : Φ z = y := by simp only [Ψ, Φ]; rw [C1, C2, C3]\n      rw [this]\n      exact le_trans (le_of_lt hy) u_le_ε\n    · show ∀ x y : s p, |dist x y - dist (Φ x) (Φ y)| ≤ ε\n      /- the distance between `x` and `y` is encoded in `F p`, and the distance between\n            `Φ x` and `Φ y` (two points of `s q`) is encoded in `F q`, all this up to `ε`.\n            As `F p = F q`, the distances are almost equal. -/\n      intro x y\n      have : dist (Φ x) (Φ y) = dist (Ψ x) (Ψ y) := rfl\n      rw [this]\n      -- introduce `i`, that codes both `x` and `Φ x` in `Fin (N p) = Fin (N q)`\n      let i : ℕ := E p x\n      have hip : i < N p := ((E p) x).2\n      have hiq : i < N q := by rwa [Npq] at hip\n      have i' : i = (E q) (Ψ x) := by simp only [i, Ψ, Equiv.apply_symm_apply, Fin.coe_cast]\n      -- introduce `j`, that codes both `y` and `Φ y` in `Fin (N p) = Fin (N q)`\n      let j : ℕ := E p y\n      have hjp : j < N p := ((E p) y).2\n      have hjq : j < N q := by rwa [Npq] at hjp\n      have j' : j = (E q) (Ψ y) := by simp only [j, Ψ, Equiv.apply_symm_apply, Fin.coe_cast]\n      -- Express `dist x y` in terms of `F p`\n      have Ap : ((F p).2 ⟨i, hip⟩ ⟨j, hjp⟩).1 = ⌊ε⁻¹ * dist x y⌋₊ :=\n        calc\n          ((F p).2 ⟨i, hip⟩ ⟨j, hjp⟩).1 = ((F p).2 ((E p) x) ((E p) y)).1 := by\n            congr\n          _ = min M ⌊ε⁻¹ * dist x y⌋₊ := by simp only [F, (E p).symm_apply_apply]\n          _ = ⌊ε⁻¹ * dist x y⌋₊ := by\n            refine min_eq_right (Nat.floor_mono ?_)\n            refine mul_le_mul_of_nonneg_left (le_trans ?_ (le_max_left _ _)) (inv_pos.2 εpos).le\n            change dist (x : p.Rep) y ≤ C\n            refine (dist_le_diam_of_mem isCompact_univ.isBounded (mem_univ _) (mem_univ _)).trans ?_\n            exact hdiam p pt\n      -- Express `dist (Φ x) (Φ y)` in terms of `F q`\n      have Aq : ((F q).2 ⟨i, hiq⟩ ⟨j, hjq⟩).1 = ⌊ε⁻¹ * dist (Ψ x) (Ψ y)⌋₊ :=\n        calc\n          ((F q).2 ⟨i, hiq⟩ ⟨j, hjq⟩).1 = ((F q).2 ((E q) (Ψ x)) ((E q) (Ψ y))).1 := by\n            -- Porting note: `congr` drops `Fin.val` but fails to make further progress\n            exact congr_arg₂ (Fin.val <| (F q).2 · ·) (Fin.ext i') (Fin.ext j')\n          _ = min M ⌊ε⁻¹ * dist (Ψ x) (Ψ y)⌋₊ := by simp only [F, (E q).symm_apply_apply]\n          _ = ⌊ε⁻¹ * dist (Ψ x) (Ψ y)⌋₊ := by\n            refine min_eq_right (Nat.floor_mono ?_)\n            refine mul_le_mul_of_nonneg_left (le_trans ?_ (le_max_left _ _)) (inv_pos.2 εpos).le\n            change dist (Ψ x : q.Rep) (Ψ y) ≤ C\n            refine (dist_le_diam_of_mem isCompact_univ.isBounded (mem_univ _) (mem_univ _)).trans ?_\n            exact hdiam q qt\n      -- use the equality between `F p` and `F q` to deduce that the distances have equal\n      -- integer parts\n      have : ((F p).2 ⟨i, hip⟩ ⟨j, hjp⟩).1 = ((F q).2 ⟨i, hiq⟩ ⟨j, hjq⟩).1 := by\n        have hpq' : HEq (F p).snd (F q).snd := (Sigma.mk.inj_iff.1 hpq).2\n        rw [Fin.heq_fun₂_iff Npq Npq] at hpq'\n        rw [← hpq']\n        -- Porting note: new version above because `subst…` does not work\n        -- we want to `subst hpq` where `hpq : F p = F q`, except that `subst` only works\n        -- with a constant, so replace `F q` (and everything that depends on it) by a constant `f`\n        -- then `subst`\n        -- dsimp only [show N q = (F q).1 from rfl] at hiq hjq ⊢\n        -- generalize F q = f at hpq ⊢\n        -- subst hpq\n        -- intros\n        -- rfl\n      have : ⌊ε⁻¹ * dist x y⌋ = ⌊ε⁻¹ * dist (Ψ x) (Ψ y)⌋ := by\n        rw [Ap, Aq] at this\n        have D : 0 ≤ ⌊ε⁻¹ * dist x y⌋ :=\n          floor_nonneg.2 (mul_nonneg (le_of_lt (inv_pos.2 εpos)) dist_nonneg)\n        have D' : 0 ≤ ⌊ε⁻¹ * dist (Ψ x) (Ψ y)⌋ :=\n          floor_nonneg.2 (mul_nonneg (le_of_lt (inv_pos.2 εpos)) dist_nonneg)\n        rw [← Int.toNat_of_nonneg D, ← Int.toNat_of_nonneg D', Int.floor_toNat, Int.floor_toNat,\n          this]\n      -- deduce that the distances coincide up to `ε`, by a straightforward computation\n      -- that should be automated\n      have I :=\n        calc\n          |ε⁻¹| * |dist x y - dist (Ψ x) (Ψ y)| = |ε⁻¹ * (dist x y - dist (Ψ x) (Ψ y))| :=\n            (abs_mul _ _).symm\n          _ = |ε⁻¹ * dist x y - ε⁻¹ * dist (Ψ x) (Ψ y)| := by congr; ring\n          _ ≤ 1 := le_of_lt (abs_sub_lt_one_of_floor_eq_floor this)\n      calc\n        |dist x y - dist (Ψ x) (Ψ y)| = ε * ε⁻¹ * |dist x y - dist (Ψ x) (Ψ y)| := by\n          rw [mul_inv_cancel₀ (ne_of_gt εpos), one_mul]\n        _ = ε * (|ε⁻¹| * |dist x y - dist (Ψ x) (Ψ y)|) := by\n          rw [abs_of_nonneg (le_of_lt (inv_pos.2 εpos)), mul_assoc]\n        _ ≤ ε * 1 := mul_le_mul_of_nonneg_left I (le_of_lt εpos)\n        _ = ε := mul_one _\n  calc\n    dist p q = ghDist p.Rep q.Rep := dist_ghDist p q\n    _ ≤ ε + ε / 2 + ε := main\n    _ = δ / 2 := by simp only [ε, one_div]; ring\n    _ < δ := half_lt_self δpos\n\n"}
{"name":"GromovHausdorff.AuxGluingStruct.isom","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"A : Type\ninst✝ : MetricSpace A\nself : GromovHausdorff.AuxGluingStruct A\n⊢ Isometry self.embed","decl":"/-- Auxiliary structure used to glue metric spaces below, recording an isometric embedding\nof a type `A` in another metric space. -/\nstructure AuxGluingStruct (A : Type) [MetricSpace A] : Type 1 where\n  Space : Type\n  metric : MetricSpace Space\n  embed : A → Space\n  isom : Isometry embed\n\n"}
{"name":"GromovHausdorff.AuxGluingStruct.mk.injEq","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"A : Type\ninst✝ : MetricSpace A\nSpace✝ : Type\nmetric✝ : MetricSpace Space✝\nembed✝ : A → Space✝\nisom✝ : Isometry embed✝\nSpace : Type\nmetric : MetricSpace Space\nembed : A → Space\nisom : Isometry embed\n⊢ Eq (Eq { Space := Space✝, metric := metric✝, embed := embed✝, isom := isom✝ } { Space := Space, metric := metric, embed := embed, isom := isom }) (And (Eq Space✝ Space) (And (HEq metric✝ metric) (HEq embed✝ embed)))","decl":"/-- Auxiliary structure used to glue metric spaces below, recording an isometric embedding\nof a type `A` in another metric space. -/\nstructure AuxGluingStruct (A : Type) [MetricSpace A] : Type 1 where\n  Space : Type\n  metric : MetricSpace Space\n  embed : A → Space\n  isom : Isometry embed\n\n"}
{"name":"GromovHausdorff.AuxGluingStruct.mk.inj","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"A : Type\ninst✝ : MetricSpace A\nSpace✝ : Type\nmetric✝ : MetricSpace Space✝\nembed✝ : A → Space✝\nisom✝ : Isometry embed✝\nSpace : Type\nmetric : MetricSpace Space\nembed : A → Space\nisom : Isometry embed\nx✝ : Eq { Space := Space✝, metric := metric✝, embed := embed✝, isom := isom✝ } { Space := Space, metric := metric, embed := embed, isom := isom }\n⊢ And (Eq Space✝ Space) (And (HEq metric✝ metric) (HEq embed✝ embed))","decl":"/-- Auxiliary structure used to glue metric spaces below, recording an isometric embedding\nof a type `A` in another metric space. -/\nstructure AuxGluingStruct (A : Type) [MetricSpace A] : Type 1 where\n  Space : Type\n  metric : MetricSpace Space\n  embed : A → Space\n  isom : Isometry embed\n\n"}
{"name":"GromovHausdorff.AuxGluingStruct.mk.sizeOf_spec","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"A : Type\ninst✝¹ : MetricSpace A\ninst✝ : SizeOf A\nSpace : Type\nmetric : MetricSpace Space\nembed : A → Space\nisom : Isometry embed\n⊢ Eq (SizeOf.sizeOf { Space := Space, metric := metric, embed := embed, isom := isom }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf Space)) (SizeOf.sizeOf metric))","decl":"/-- Auxiliary structure used to glue metric spaces below, recording an isometric embedding\nof a type `A` in another metric space. -/\nstructure AuxGluingStruct (A : Type) [MetricSpace A] : Type 1 where\n  Space : Type\n  metric : MetricSpace Space\n  embed : A → Space\n  isom : Isometry embed\n\n"}
