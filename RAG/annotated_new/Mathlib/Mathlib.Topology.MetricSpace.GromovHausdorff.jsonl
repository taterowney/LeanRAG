{"name":"GromovHausdorff.eq_toGHSpace_iff","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"X : Type u\ninst‚úù¬≤ : MetricSpace X\ninst‚úù¬π : CompactSpace X\ninst‚úù : Nonempty X\np : TopologicalSpace.NonemptyCompacts (Subtype fun x => Membership.mem (lp (fun n => Real) Top.top) x)\n‚ä¢ Iff (Eq (Quotient.mk GromovHausdorff.IsometryRel.setoid p) (GromovHausdorff.toGHSpace X)) (Exists fun Œ® => And (Isometry Œ®) (Eq (Set.range Œ®) ‚Üëp))","decl":"theorem eq_toGHSpace_iff {X : Type u} [MetricSpace X] [CompactSpace X] [Nonempty X]\n    {p : NonemptyCompacts ‚Ñì_infty_‚Ñù} :\n    ‚ü¶p‚üß = toGHSpace X ‚Üî ‚àÉ Œ® : X ‚Üí ‚Ñì_infty_‚Ñù, Isometry Œ® ‚àß range Œ® = p := by\n  simp only [toGHSpace, Quotient.eq]\n  refine ‚ü®fun h => ?_, ?_‚ü©\n  ¬∑ rcases Setoid.symm h with ‚ü®e‚ü©\n    have f := (kuratowskiEmbedding.isometry X).isometryEquivOnRange.trans e\n    use fun x => f x, isometry_subtype_coe.comp f.isometry\n    erw [range_comp, f.range_eq_univ, Set.image_univ, Subtype.range_coe]\n  ¬∑ rintro ‚ü®Œ®, ‚ü®isomŒ®, rangeŒ®‚ü©‚ü©\n    have f :=\n      ((kuratowskiEmbedding.isometry X).isometryEquivOnRange.symm.trans\n          isomŒ®.isometryEquivOnRange).symm\n    have E : (range Œ® ‚âÉ·µ¢ NonemptyCompacts.kuratowskiEmbedding X)\n        = (p ‚âÉ·µ¢ range (kuratowskiEmbedding X)) := by\n      dsimp only [NonemptyCompacts.kuratowskiEmbedding]; rw [rangeŒ®]; rfl\n    exact ‚ü®cast E f‚ü©\n\n"}
{"name":"GromovHausdorff.eq_toGHSpace","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"p : TopologicalSpace.NonemptyCompacts (Subtype fun x => Membership.mem (lp (fun n => Real) Top.top) x)\n‚ä¢ Eq (Quotient.mk GromovHausdorff.IsometryRel.setoid p) (GromovHausdorff.toGHSpace (Subtype fun x => Membership.mem p x))","decl":"theorem eq_toGHSpace {p : NonemptyCompacts ‚Ñì_infty_‚Ñù} : ‚ü¶p‚üß = toGHSpace p :=\n  eq_toGHSpace_iff.2 ‚ü®fun x => x, isometry_subtype_coe, Subtype.range_coe‚ü©\n\n"}
{"name":"GromovHausdorff.rep_gHSpace_compactSpace","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"p : GromovHausdorff.GHSpace\n‚ä¢ CompactSpace p.Rep","decl":"instance rep_gHSpace_compactSpace {p : GHSpace} : CompactSpace p.Rep :=\n  inferInstanceAs <| CompactSpace p.out\n\n"}
{"name":"GromovHausdorff.rep_gHSpace_nonempty","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"p : GromovHausdorff.GHSpace\n‚ä¢ Nonempty p.Rep","decl":"instance rep_gHSpace_nonempty {p : GHSpace} : Nonempty p.Rep :=\n  inferInstanceAs <| Nonempty p.out\n\n"}
{"name":"GromovHausdorff.GHSpace.toGHSpace_rep","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"p : GromovHausdorff.GHSpace\n‚ä¢ Eq (GromovHausdorff.toGHSpace p.Rep) p","decl":"theorem GHSpace.toGHSpace_rep (p : GHSpace) : toGHSpace p.Rep = p := by\n  change toGHSpace (Quot.out p : NonemptyCompacts ‚Ñì_infty_‚Ñù) = p\n  rw [‚Üê eq_toGHSpace]\n  exact Quot.out_eq p\n\n"}
{"name":"GromovHausdorff.toGHSpace_eq_toGHSpace_iff_isometryEquiv","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"X : Type u\ninst‚úù‚Åµ : MetricSpace X\ninst‚úù‚Å¥ : CompactSpace X\ninst‚úù¬≥ : Nonempty X\nY : Type v\ninst‚úù¬≤ : MetricSpace Y\ninst‚úù¬π : CompactSpace Y\ninst‚úù : Nonempty Y\n‚ä¢ Iff (Eq (GromovHausdorff.toGHSpace X) (GromovHausdorff.toGHSpace Y)) (Nonempty (IsometryEquiv X Y))","decl":"/-- Two nonempty compact spaces have the same image in `GHSpace` if and only if they are\nisometric. -/\ntheorem toGHSpace_eq_toGHSpace_iff_isometryEquiv {X : Type u} [MetricSpace X] [CompactSpace X]\n    [Nonempty X] {Y : Type v} [MetricSpace Y] [CompactSpace Y] [Nonempty Y] :\n    toGHSpace X = toGHSpace Y ‚Üî Nonempty (X ‚âÉ·µ¢ Y) :=\n  ‚ü®by\n    simp only [toGHSpace]\n    rw [Quotient.eq]\n    rintro ‚ü®e‚ü©\n    have I :\n      (NonemptyCompacts.kuratowskiEmbedding X ‚âÉ·µ¢ NonemptyCompacts.kuratowskiEmbedding Y) =\n        (range (kuratowskiEmbedding X) ‚âÉ·µ¢ range (kuratowskiEmbedding Y)) := by\n      dsimp only [NonemptyCompacts.kuratowskiEmbedding]; rfl\n    have f := (kuratowskiEmbedding.isometry X).isometryEquivOnRange\n    have g := (kuratowskiEmbedding.isometry Y).isometryEquivOnRange.symm\n    exact ‚ü®f.trans <| (cast I e).trans g‚ü©, by\n    rintro ‚ü®e‚ü©\n    simp only [toGHSpace, Quotient.eq']\n    have f := (kuratowskiEmbedding.isometry X).isometryEquivOnRange.symm\n    have g := (kuratowskiEmbedding.isometry Y).isometryEquivOnRange\n    have I :\n      (range (kuratowskiEmbedding X) ‚âÉ·µ¢ range (kuratowskiEmbedding Y)) =\n        (NonemptyCompacts.kuratowskiEmbedding X ‚âÉ·µ¢ NonemptyCompacts.kuratowskiEmbedding Y) := by\n      dsimp only [NonemptyCompacts.kuratowskiEmbedding]; rfl\n    rw [Quotient.eq]\n    exact ‚ü®cast I ((f.trans e).trans g)‚ü©‚ü©\n\n"}
{"name":"GromovHausdorff.dist_ghDist","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"p q : GromovHausdorff.GHSpace\n‚ä¢ Eq (Dist.dist p q) (GromovHausdorff.ghDist p.Rep q.Rep)","decl":"theorem dist_ghDist (p q : GHSpace) : dist p q = ghDist p.Rep q.Rep := by\n  rw [ghDist, p.toGHSpace_rep, q.toGHSpace_rep]\n\n"}
{"name":"GromovHausdorff.ghDist_le_hausdorffDist","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"X : Type u\ninst‚úù‚Å∂ : MetricSpace X\ninst‚úù‚Åµ : CompactSpace X\ninst‚úù‚Å¥ : Nonempty X\nY : Type v\ninst‚úù¬≥ : MetricSpace Y\ninst‚úù¬≤ : CompactSpace Y\ninst‚úù¬π : Nonempty Y\nŒ≥ : Type w\ninst‚úù : MetricSpace Œ≥\nŒ¶ : X ‚Üí Œ≥\nŒ® : Y ‚Üí Œ≥\nha : Isometry Œ¶\nhb : Isometry Œ®\n‚ä¢ LE.le (GromovHausdorff.ghDist X Y) (Metric.hausdorffDist (Set.range Œ¶) (Set.range Œ®))","decl":"/-- The Gromov-Hausdorff distance between two spaces is bounded by the Hausdorff distance\nof isometric copies of the spaces, in any metric space. -/\ntheorem ghDist_le_hausdorffDist {X : Type u} [MetricSpace X] [CompactSpace X] [Nonempty X]\n    {Y : Type v} [MetricSpace Y] [CompactSpace Y] [Nonempty Y] {Œ≥ : Type w} [MetricSpace Œ≥]\n    {Œ¶ : X ‚Üí Œ≥} {Œ® : Y ‚Üí Œ≥} (ha : Isometry Œ¶) (hb : Isometry Œ®) :\n    ghDist X Y ‚â§ hausdorffDist (range Œ¶) (range Œ®) := by\n  /- For the proof, we want to embed `Œ≥` in `‚Ñì^‚àû(‚Ñù)`, to say that the Hausdorff distance is realized\n    in `‚Ñì^‚àû(‚Ñù)` and therefore bounded below by the Gromov-Hausdorff-distance. However, `Œ≥` is not\n    separable in general. We restrict to the union of the images of `X` and `Y` in `Œ≥`, which is\n    separable and therefore embeddable in `‚Ñì^‚àû(‚Ñù)`. -/\n  rcases exists_mem_of_nonempty X with ‚ü®xX, _‚ü©\n  let s : Set Œ≥ := range Œ¶ ‚à™ range Œ®\n  let Œ¶' : X ‚Üí Subtype s := fun y => ‚ü®Œ¶ y, mem_union_left _ (mem_range_self _)‚ü©\n  let Œ®' : Y ‚Üí Subtype s := fun y => ‚ü®Œ® y, mem_union_right _ (mem_range_self _)‚ü©\n  have IŒ¶' : Isometry Œ¶' := fun x y => ha x y\n  have IŒ®' : Isometry Œ®' := fun x y => hb x y\n  have : IsCompact s := (isCompact_range ha.continuous).union (isCompact_range hb.continuous)\n  letI : MetricSpace (Subtype s) := by infer_instance\n  haveI : CompactSpace (Subtype s) := ‚ü®isCompact_iff_isCompact_univ.1 ‚ÄπIsCompact s‚Ä∫‚ü©\n  haveI : Nonempty (Subtype s) := ‚ü®Œ¶' xX‚ü©\n  have Œ¶Œ¶' : Œ¶ = Subtype.val ‚àò Œ¶' := by funext; rfl\n  have Œ®Œ®' : Œ® = Subtype.val ‚àò Œ®' := by funext; rfl\n  have : hausdorffDist (range Œ¶) (range Œ®) = hausdorffDist (range Œ¶') (range Œ®') := by\n    rw [Œ¶Œ¶', Œ®Œ®', range_comp, range_comp]\n    exact hausdorffDist_image isometry_subtype_coe\n  rw [this]\n  -- Embed `s` in `‚Ñì^‚àû(‚Ñù)` through its Kuratowski embedding\n  let F := kuratowskiEmbedding (Subtype s)\n  have : hausdorffDist (F '' range Œ¶') (F '' range Œ®') = hausdorffDist (range Œ¶') (range Œ®') :=\n    hausdorffDist_image (kuratowskiEmbedding.isometry _)\n  rw [‚Üê this]\n  -- Let `A` and `B` be the images of `X` and `Y` under this embedding. They are in `‚Ñì^‚àû(‚Ñù)`, and\n  -- their Hausdorff distance is the same as in the original space.\n  let A : NonemptyCompacts ‚Ñì_infty_‚Ñù :=\n    ‚ü®‚ü®F '' range Œ¶',\n        (isCompact_range IŒ¶'.continuous).image (kuratowskiEmbedding.isometry _).continuous‚ü©,\n      (range_nonempty _).image _‚ü©\n  let B : NonemptyCompacts ‚Ñì_infty_‚Ñù :=\n    ‚ü®‚ü®F '' range Œ®',\n        (isCompact_range IŒ®'.continuous).image (kuratowskiEmbedding.isometry _).continuous‚ü©,\n      (range_nonempty _).image _‚ü©\n  have AX : ‚ü¶A‚üß = toGHSpace X := by\n    rw [eq_toGHSpace_iff]\n    exact ‚ü®fun x => F (Œ¶' x), (kuratowskiEmbedding.isometry _).comp IŒ¶', range_comp _ _‚ü©\n  have BY : ‚ü¶B‚üß = toGHSpace Y := by\n    rw [eq_toGHSpace_iff]\n    exact ‚ü®fun x => F (Œ®' x), (kuratowskiEmbedding.isometry _).comp IŒ®', range_comp _ _‚ü©\n  refine csInf_le ‚ü®0, ?_‚ü© ?_\n  ¬∑ simp only [lowerBounds, mem_image, mem_prod, mem_setOf_eq, Prod.exists, and_imp,\n      forall_exists_index]\n    intro t _ _ _ _ ht\n    rw [‚Üê ht]\n    exact hausdorffDist_nonneg\n  apply (mem_image _ _ _).2\n  exists (‚ü®A, B‚ü© : NonemptyCompacts ‚Ñì_infty_‚Ñù √ó NonemptyCompacts ‚Ñì_infty_‚Ñù)\n\n"}
{"name":"GromovHausdorff.hausdorffDist_optimal","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"X : Type u\ninst‚úù‚Åµ : MetricSpace X\ninst‚úù‚Å¥ : CompactSpace X\ninst‚úù¬≥ : Nonempty X\nY : Type v\ninst‚úù¬≤ : MetricSpace Y\ninst‚úù¬π : CompactSpace Y\ninst‚úù : Nonempty Y\n‚ä¢ Eq (Metric.hausdorffDist (Set.range (GromovHausdorff.optimalGHInjl X Y)) (Set.range (GromovHausdorff.optimalGHInjr X Y))) (GromovHausdorff.ghDist X Y)","decl":"/-- The optimal coupling constructed above realizes exactly the Gromov-Hausdorff distance,\nessentially by design. -/\ntheorem hausdorffDist_optimal {X : Type u} [MetricSpace X] [CompactSpace X] [Nonempty X]\n    {Y : Type v} [MetricSpace Y] [CompactSpace Y] [Nonempty Y] :\n    hausdorffDist (range (optimalGHInjl X Y)) (range (optimalGHInjr X Y)) = ghDist X Y := by\n  inhabit X; inhabit Y\n  /- we only need to check the inequality `‚â§`, as the other one follows from the previous lemma.\n       As the Gromov-Hausdorff distance is an infimum, we need to check that the Hausdorff distance\n       in the optimal coupling is smaller than the Hausdorff distance of any coupling.\n       First, we check this for couplings which already have small Hausdorff distance: in this\n       case, the induced \"distance\" on `X ‚äï Y` belongs to the candidates family introduced in the\n       definition of the optimal coupling, and the conclusion follows from the optimality\n       of the optimal coupling within this family.\n    -/\n  have A :\n    ‚àÄ p q : NonemptyCompacts ‚Ñì_infty_‚Ñù,\n      ‚ü¶p‚üß = toGHSpace X ‚Üí\n        ‚ü¶q‚üß = toGHSpace Y ‚Üí\n          hausdorffDist (p : Set ‚Ñì_infty_‚Ñù) q < diam (univ : Set X) + 1 + diam (univ : Set Y) ‚Üí\n            hausdorffDist (range (optimalGHInjl X Y)) (range (optimalGHInjr X Y)) ‚â§\n              hausdorffDist (p : Set ‚Ñì_infty_‚Ñù) q := by\n    intro p q hp hq bound\n    rcases eq_toGHSpace_iff.1 hp with ‚ü®Œ¶, ‚ü®Œ¶isom, Œ¶range‚ü©‚ü©\n    rcases eq_toGHSpace_iff.1 hq with ‚ü®Œ®, ‚ü®Œ®isom, Œ®range‚ü©‚ü©\n    have I : diam (range Œ¶ ‚à™ range Œ®) ‚â§ 2 * diam (univ : Set X) + 1 + 2 * diam (univ : Set Y) := by\n      rcases exists_mem_of_nonempty X with ‚ü®xX, _‚ü©\n      have : ‚àÉ y ‚àà range Œ®, dist (Œ¶ xX) y < diam (univ : Set X) + 1 + diam (univ : Set Y) := by\n        rw [Œ®range]\n        have : Œ¶ xX ‚àà (p : Set _) := Œ¶range ‚ñ∏ (mem_range_self _)\n        exact\n          exists_dist_lt_of_hausdorffDist_lt this bound\n            (hausdorffEdist_ne_top_of_nonempty_of_bounded p.nonempty q.nonempty\n              p.isCompact.isBounded q.isCompact.isBounded)\n      rcases this with ‚ü®y, hy, dy‚ü©\n      rcases mem_range.1 hy with ‚ü®z, hzy‚ü©\n      rw [‚Üê hzy] at dy\n      have DŒ¶ : diam (range Œ¶) = diam (univ : Set X) := Œ¶isom.diam_range\n      have DŒ® : diam (range Œ®) = diam (univ : Set Y) := Œ®isom.diam_range\n      calc\n        diam (range Œ¶ ‚à™ range Œ®) ‚â§ diam (range Œ¶) + dist (Œ¶ xX) (Œ® z) + diam (range Œ®) :=\n          diam_union (mem_range_self _) (mem_range_self _)\n        _ ‚â§\n            diam (univ : Set X) + (diam (univ : Set X) + 1 + diam (univ : Set Y)) +\n              diam (univ : Set Y) := by\n          rw [DŒ¶, DŒ®]\n          gcongr\n          -- apply add_le_add (add_le_add le_rfl (le_of_lt dy)) le_rfl\n        _ = 2 * diam (univ : Set X) + 1 + 2 * diam (univ : Set Y) := by ring\n    let f : X ‚äï Y ‚Üí ‚Ñì_infty_‚Ñù := fun x =>\n      match x with\n      | inl y => Œ¶ y\n      | inr z => Œ® z\n    let F : (X ‚äï Y) √ó (X ‚äï Y) ‚Üí ‚Ñù := fun p => dist (f p.1) (f p.2)\n    -- check that the induced \"distance\" is a candidate\n    have Fgood : F ‚àà candidates X Y := by\n      simp only [F, candidates, forall_const, add_comm, eq_self_iff_true,\n        dist_eq_zero, and_self_iff, Set.mem_setOf_eq]\n      repeat' constructor\n      ¬∑ exact fun x y =>\n          calc\n            F (inl x, inl y) = dist (Œ¶ x) (Œ¶ y) := rfl\n            _ = dist x y := Œ¶isom.dist_eq x y\n\n      ¬∑ exact fun x y =>\n          calc\n            F (inr x, inr y) = dist (Œ® x) (Œ® y) := rfl\n            _ = dist x y := Œ®isom.dist_eq x y\n\n      ¬∑ exact fun x y => dist_comm _ _\n      ¬∑ exact fun x y z => dist_triangle _ _ _\n      ¬∑ exact fun x y =>\n          calc\n            F (x, y) ‚â§ diam (range Œ¶ ‚à™ range Œ®) := by\n              have A : ‚àÄ z : X ‚äï Y, f z ‚àà range Œ¶ ‚à™ range Œ® := by\n                intro z\n                cases z\n                ¬∑ apply mem_union_left; apply mem_range_self\n                ¬∑ apply mem_union_right; apply mem_range_self\n              refine dist_le_diam_of_mem ?_ (A _) (A _)\n              rw [Œ¶range, Œ®range]\n              exact (p ‚äî q).isCompact.isBounded\n            _ ‚â§ 2 * diam (univ : Set X) + 1 + 2 * diam (univ : Set Y) := I\n    let Fb := candidatesBOfCandidates F Fgood\n    have : hausdorffDist (range (optimalGHInjl X Y)) (range (optimalGHInjr X Y)) ‚â§ HD Fb :=\n      hausdorffDist_optimal_le_HD _ _ (candidatesBOfCandidates_mem F Fgood)\n    refine le_trans this (le_of_forall_gt_imp_ge_of_dense fun r hr => ?_)\n    have I1 : ‚àÄ x : X, (‚®Ö y, Fb (inl x, inr y)) ‚â§ r := by\n      intro x\n      have : f (inl x) ‚àà (p : Set _) := Œ¶range ‚ñ∏ (mem_range_self _)\n      rcases exists_dist_lt_of_hausdorffDist_lt this hr\n          (hausdorffEdist_ne_top_of_nonempty_of_bounded p.nonempty q.nonempty p.isCompact.isBounded\n            q.isCompact.isBounded) with\n        ‚ü®z, zq, hz‚ü©\n      have : z ‚àà range Œ® := by rwa [‚Üê Œ®range] at zq\n      rcases mem_range.1 this with ‚ü®y, hy‚ü©\n      calc\n        (‚®Ö y, Fb (inl x, inr y)) ‚â§ Fb (inl x, inr y) :=\n          ciInf_le (by simpa only [add_zero] using HD_below_aux1 0) y\n        _ = dist (Œ¶ x) (Œ® y) := rfl\n        _ = dist (f (inl x)) z := by rw [hy]\n        _ ‚â§ r := le_of_lt hz\n\n    have I2 : ‚àÄ y : Y, (‚®Ö x, Fb (inl x, inr y)) ‚â§ r := by\n      intro y\n      have : f (inr y) ‚àà (q : Set _) := Œ®range ‚ñ∏ (mem_range_self _)\n      rcases exists_dist_lt_of_hausdorffDist_lt' this hr\n          (hausdorffEdist_ne_top_of_nonempty_of_bounded p.nonempty q.nonempty p.isCompact.isBounded\n            q.isCompact.isBounded) with\n        ‚ü®z, zq, hz‚ü©\n      have : z ‚àà range Œ¶ := by rwa [‚Üê Œ¶range] at zq\n      rcases mem_range.1 this with ‚ü®x, hx‚ü©\n      calc\n        (‚®Ö x, Fb (inl x, inr y)) ‚â§ Fb (inl x, inr y) :=\n          ciInf_le (by simpa only [add_zero] using HD_below_aux2 0) x\n        _ = dist (Œ¶ x) (Œ® y) := rfl\n        _ = dist z (f (inr y)) := by rw [hx]\n        _ ‚â§ r := le_of_lt hz\n\n    simp only [HD, ciSup_le I1, ciSup_le I2, max_le_iff, and_self_iff]\n  /- Get the same inequality for any coupling. If the coupling is quite good, the desired\n    inequality has been proved above. If it is bad, then the inequality is obvious. -/\n  have B :\n    ‚àÄ p q : NonemptyCompacts ‚Ñì_infty_‚Ñù,\n      ‚ü¶p‚üß = toGHSpace X ‚Üí\n        ‚ü¶q‚üß = toGHSpace Y ‚Üí\n          hausdorffDist (range (optimalGHInjl X Y)) (range (optimalGHInjr X Y)) ‚â§\n            hausdorffDist (p : Set ‚Ñì_infty_‚Ñù) q := by\n    intro p q hp hq\n    by_cases h :\n      hausdorffDist (p : Set ‚Ñì_infty_‚Ñù) q < diam (univ : Set X) + 1 + diam (univ : Set Y)\n    ¬∑ exact A p q hp hq h\n    ¬∑ calc\n        hausdorffDist (range (optimalGHInjl X Y)) (range (optimalGHInjr X Y)) ‚â§\n            HD (candidatesBDist X Y) :=\n          hausdorffDist_optimal_le_HD _ _ candidatesBDist_mem_candidatesB\n        _ ‚â§ diam (univ : Set X) + 1 + diam (univ : Set Y) := HD_candidatesBDist_le\n        _ ‚â§ hausdorffDist (p : Set ‚Ñì_infty_‚Ñù) q := not_lt.1 h\n  refine le_antisymm ?_ ?_\n  ¬∑ apply le_csInf\n    ¬∑ refine (Set.Nonempty.prod ?_ ?_).image _ <;> exact ‚ü®_, rfl‚ü©\n    ¬∑ rintro b ‚ü®‚ü®p, q‚ü©, ‚ü®hp, hq‚ü©, rfl‚ü©\n      exact B p q hp hq\n  ¬∑ exact ghDist_le_hausdorffDist (isometry_optimalGHInjl X Y) (isometry_optimalGHInjr X Y)\n\n"}
{"name":"GromovHausdorff.ghDist_eq_hausdorffDist","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"X : Type u\ninst‚úù‚Åµ : MetricSpace X\ninst‚úù‚Å¥ : CompactSpace X\ninst‚úù¬≥ : Nonempty X\nY : Type v\ninst‚úù¬≤ : MetricSpace Y\ninst‚úù¬π : CompactSpace Y\ninst‚úù : Nonempty Y\n‚ä¢ Exists fun Œ¶ => Exists fun Œ® => And (Isometry Œ¶) (And (Isometry Œ®) (Eq (GromovHausdorff.ghDist X Y) (Metric.hausdorffDist (Set.range Œ¶) (Set.range Œ®))))","decl":"/-- The Gromov-Hausdorff distance can also be realized by a coupling in `‚Ñì^‚àû(‚Ñù)`, by embedding\nthe optimal coupling through its Kuratowski embedding. -/\ntheorem ghDist_eq_hausdorffDist (X : Type u) [MetricSpace X] [CompactSpace X] [Nonempty X]\n    (Y : Type v) [MetricSpace Y] [CompactSpace Y] [Nonempty Y] :\n    ‚àÉ Œ¶ : X ‚Üí ‚Ñì_infty_‚Ñù,\n      ‚àÉ Œ® : Y ‚Üí ‚Ñì_infty_‚Ñù,\n        Isometry Œ¶ ‚àß Isometry Œ® ‚àß ghDist X Y = hausdorffDist (range Œ¶) (range Œ®) := by\n  let F := kuratowskiEmbedding (OptimalGHCoupling X Y)\n  let Œ¶ := F ‚àò optimalGHInjl X Y\n  let Œ® := F ‚àò optimalGHInjr X Y\n  refine ‚ü®Œ¶, Œ®, ?_, ?_, ?_‚ü©\n  ¬∑ exact (kuratowskiEmbedding.isometry _).comp (isometry_optimalGHInjl X Y)\n  ¬∑ exact (kuratowskiEmbedding.isometry _).comp (isometry_optimalGHInjr X Y)\n  ¬∑ rw [‚Üê image_univ, ‚Üê image_univ, image_comp F, image_univ, image_comp F (optimalGHInjr X Y),\n      image_univ, ‚Üê hausdorffDist_optimal]\n    exact (hausdorffDist_image (kuratowskiEmbedding.isometry _)).symm\n\n"}
{"name":"GromovHausdorff.ghDist_le_nonemptyCompacts_dist","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"X : Type u\ninst‚úù : MetricSpace X\np q : TopologicalSpace.NonemptyCompacts X\n‚ä¢ LE.le (Dist.dist p.toGHSpace q.toGHSpace) (Dist.dist p q)","decl":"theorem ghDist_le_nonemptyCompacts_dist (p q : NonemptyCompacts X) :\n    dist p.toGHSpace q.toGHSpace ‚â§ dist p q := by\n  have ha : Isometry ((‚Üë) : p ‚Üí X) := isometry_subtype_coe\n  have hb : Isometry ((‚Üë) : q ‚Üí X) := isometry_subtype_coe\n  have A : dist p q = hausdorffDist (p : Set X) q := rfl\n  have I : ‚Üëp = range ((‚Üë) : p ‚Üí X) := Subtype.range_coe_subtype.symm\n  have J : ‚Üëq = range ((‚Üë) : q ‚Üí X) := Subtype.range_coe_subtype.symm\n  rw [A, I, J]\n  exact ghDist_le_hausdorffDist ha hb\n\n"}
{"name":"GromovHausdorff.toGHSpace_lipschitz","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"‚ä¢ sorryAx (Unit ‚Üí Prop) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 523).num 4).num 523).num 79).num 4).num 79).str \"_sorry\").str \"_@\").str \"_hyg\").num 1838))","decl":"theorem toGHSpace_lipschitz :\n    LipschitzWith 1 (NonemptyCompacts.toGHSpace : NonemptyCompacts X ‚Üí GHSpace) :=\n  LipschitzWith.mk_one ghDist_le_nonemptyCompacts_dist\n\n"}
{"name":"GromovHausdorff.toGHSpace_continuous","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"‚ä¢ sorryAx (Unit ‚Üí Prop) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 527).num 4).num 527).num 74).num 4).num 74).str \"_sorry\").str \"_@\").str \"_hyg\").num 1862))","decl":"theorem toGHSpace_continuous :\n    Continuous (NonemptyCompacts.toGHSpace : NonemptyCompacts X ‚Üí GHSpace) :=\n  toGHSpace_lipschitz.continuous\n\n"}
{"name":"GromovHausdorff.ghDist_le_of_approx_subsets","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"X : Type u\ninst‚úù‚Åµ : MetricSpace X\ninst‚úù‚Å¥ : CompactSpace X\ninst‚úù¬≥ : Nonempty X\nY : Type v\ninst‚úù¬≤ : MetricSpace Y\ninst‚úù¬π : CompactSpace Y\ninst‚úù : Nonempty Y\ns : Set X\nŒ¶ : ‚Üës ‚Üí Y\nŒµ‚ÇÅ Œµ‚ÇÇ Œµ‚ÇÉ : Real\nhs : ‚àÄ (x : X), Exists fun y => And (Membership.mem s y) (LE.le (Dist.dist x y) Œµ‚ÇÅ)\nhs' : ‚àÄ (x : Y), Exists fun y => LE.le (Dist.dist x (Œ¶ y)) Œµ‚ÇÉ\nH : ‚àÄ (x y : ‚Üës), LE.le (abs (HSub.hSub (Dist.dist x y) (Dist.dist (Œ¶ x) (Œ¶ y)))) Œµ‚ÇÇ\n‚ä¢ LE.le (GromovHausdorff.ghDist X Y) (HAdd.hAdd (HAdd.hAdd Œµ‚ÇÅ (HDiv.hDiv Œµ‚ÇÇ 2)) Œµ‚ÇÉ)","decl":"/-- If there are subsets which are `Œµ‚ÇÅ`-dense and `Œµ‚ÇÉ`-dense in two spaces, and\nisometric up to `Œµ‚ÇÇ`, then the Gromov-Hausdorff distance between the spaces is bounded by\n`Œµ‚ÇÅ + Œµ‚ÇÇ/2 + Œµ‚ÇÉ`. -/\ntheorem ghDist_le_of_approx_subsets {s : Set X} (Œ¶ : s ‚Üí Y) {Œµ‚ÇÅ Œµ‚ÇÇ Œµ‚ÇÉ : ‚Ñù}\n    (hs : ‚àÄ x : X, ‚àÉ y ‚àà s, dist x y ‚â§ Œµ‚ÇÅ) (hs' : ‚àÄ x : Y, ‚àÉ y : s, dist x (Œ¶ y) ‚â§ Œµ‚ÇÉ)\n    (H : ‚àÄ x y : s, |dist x y - dist (Œ¶ x) (Œ¶ y)| ‚â§ Œµ‚ÇÇ) : ghDist X Y ‚â§ Œµ‚ÇÅ + Œµ‚ÇÇ / 2 + Œµ‚ÇÉ := by\n  refine le_of_forall_pos_le_add fun Œ¥ Œ¥0 => ?_\n  rcases exists_mem_of_nonempty X with ‚ü®xX, _‚ü©\n  rcases hs xX with ‚ü®xs, hxs, Dxs‚ü©\n  have sne : s.Nonempty := ‚ü®xs, hxs‚ü©\n  letI : Nonempty s := sne.to_subtype\n  have : 0 ‚â§ Œµ‚ÇÇ := le_trans (abs_nonneg _) (H ‚ü®xs, hxs‚ü© ‚ü®xs, hxs‚ü©)\n  have : ‚àÄ p q : s, |dist p q - dist (Œ¶ p) (Œ¶ q)| ‚â§ 2 * (Œµ‚ÇÇ / 2 + Œ¥) := fun p q =>\n    calc\n      |dist p q - dist (Œ¶ p) (Œ¶ q)| ‚â§ Œµ‚ÇÇ := H p q\n      _ ‚â§ 2 * (Œµ‚ÇÇ / 2 + Œ¥) := by linarith\n  -- glue `X` and `Y` along the almost matching subsets\n  letI : MetricSpace (X ‚äï Y) :=\n    glueMetricApprox (fun x : s => (x : X)) (fun x => Œ¶ x) (Œµ‚ÇÇ / 2 + Œ¥) (by linarith) this\n  let Fl := @Sum.inl X Y\n  let Fr := @Sum.inr X Y\n  have Il : Isometry Fl := Isometry.of_dist_eq fun x y => rfl\n  have Ir : Isometry Fr := Isometry.of_dist_eq fun x y => rfl\n  /- The proof goes as follows : the `GH_dist` is bounded by the Hausdorff distance of the images\n    in the coupling, which is bounded (using the triangular inequality) by the sum of the Hausdorff\n    distances of `X` and `s` (in the coupling or, equivalently in the original space), of `s` and\n    `Œ¶ s`, and of `Œ¶ s` and `Y` (in the coupling or, equivalently, in the original space).\n    The first term is bounded by `Œµ‚ÇÅ`, by `Œµ‚ÇÅ`-density. The third one is bounded by `Œµ‚ÇÉ`.\n    And the middle one is bounded by `Œµ‚ÇÇ/2` as in the coupling the points `x` and `Œ¶ x` are\n    at distance `Œµ‚ÇÇ/2` by construction of the coupling (in fact `Œµ‚ÇÇ/2 + Œ¥` where `Œ¥` is an\n    arbitrarily small positive constant where positivity is used to ensure that the coupling\n    is really a metric space and not a premetric space on `X ‚äï Y`). -/\n  have : ghDist X Y ‚â§ hausdorffDist (range Fl) (range Fr) := ghDist_le_hausdorffDist Il Ir\n  have :\n    hausdorffDist (range Fl) (range Fr) ‚â§\n      hausdorffDist (range Fl) (Fl '' s) + hausdorffDist (Fl '' s) (range Fr) :=\n    have B : IsBounded (range Fl) := (isCompact_range Il.continuous).isBounded\n    hausdorffDist_triangle\n      (hausdorffEdist_ne_top_of_nonempty_of_bounded (range_nonempty _) (sne.image _) B\n        (B.subset (image_subset_range _ _)))\n  have :\n    hausdorffDist (Fl '' s) (range Fr) ‚â§\n      hausdorffDist (Fl '' s) (Fr '' range Œ¶) + hausdorffDist (Fr '' range Œ¶) (range Fr) :=\n    have B : IsBounded (range Fr) := (isCompact_range Ir.continuous).isBounded\n    hausdorffDist_triangle'\n      (hausdorffEdist_ne_top_of_nonempty_of_bounded ((range_nonempty _).image _) (range_nonempty _)\n        (B.subset (image_subset_range _ _)) B)\n  have : hausdorffDist (range Fl) (Fl '' s) ‚â§ Œµ‚ÇÅ := by\n    rw [‚Üê image_univ, hausdorffDist_image Il]\n    have : 0 ‚â§ Œµ‚ÇÅ := le_trans dist_nonneg Dxs\n    refine hausdorffDist_le_of_mem_dist this (fun x _ => hs x) fun x _ =>\n      ‚ü®x, mem_univ _, by simpa only [dist_self]‚ü©\n  have : hausdorffDist (Fl '' s) (Fr '' range Œ¶) ‚â§ Œµ‚ÇÇ / 2 + Œ¥ := by\n    refine hausdorffDist_le_of_mem_dist (by linarith) ?_ ?_\n    ¬∑ intro x' hx'\n      rcases (Set.mem_image _ _ _).1 hx' with ‚ü®x, ‚ü®x_in_s, xx'‚ü©‚ü©\n      rw [‚Üê xx']\n      use Fr (Œ¶ ‚ü®x, x_in_s‚ü©), mem_image_of_mem Fr (mem_range_self _)\n      exact le_of_eq (glueDist_glued_points (fun x : s => (x : X)) Œ¶ (Œµ‚ÇÇ / 2 + Œ¥) ‚ü®x, x_in_s‚ü©)\n    ¬∑ intro x' hx'\n      rcases (Set.mem_image _ _ _).1 hx' with ‚ü®y, ‚ü®y_in_s', yx'‚ü©‚ü©\n      rcases mem_range.1 y_in_s' with ‚ü®x, xy‚ü©\n      use Fl x, mem_image_of_mem _ x.2\n      rw [‚Üê yx', ‚Üê xy, dist_comm]\n      exact le_of_eq (glueDist_glued_points (Z := s) (@Subtype.val X s) Œ¶ (Œµ‚ÇÇ / 2 + Œ¥) x)\n  have : hausdorffDist (Fr '' range Œ¶) (range Fr) ‚â§ Œµ‚ÇÉ := by\n    rw [‚Üê @image_univ _ _ Fr, hausdorffDist_image Ir]\n    rcases exists_mem_of_nonempty Y with ‚ü®xY, _‚ü©\n    rcases hs' xY with ‚ü®xs', Dxs'‚ü©\n    have : 0 ‚â§ Œµ‚ÇÉ := le_trans dist_nonneg Dxs'\n    refine hausdorffDist_le_of_mem_dist this\n      (fun x _ => ‚ü®x, mem_univ _, by simpa only [dist_self]‚ü©)\n      fun x _ => ?_\n    rcases hs' x with ‚ü®y, Dy‚ü©\n    exact ‚ü®Œ¶ y, mem_range_self _, Dy‚ü©\n  linarith\n\n"}
{"name":"GromovHausdorff.totallyBounded","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"t : Set GromovHausdorff.GHSpace\nC : Real\nu : Nat ‚Üí Real\nK : Nat ‚Üí Nat\nulim : Filter.Tendsto u Filter.atTop (nhds 0)\nhdiam : ‚àÄ (p : GromovHausdorff.GHSpace), Membership.mem t p ‚Üí LE.le (Metric.diam Set.univ) C\nhcov : ‚àÄ (p : GromovHausdorff.GHSpace), Membership.mem t p ‚Üí ‚àÄ (n : Nat), Exists fun s => And (LE.le (Cardinal.mk ‚Üës) ‚Üë(K n)) (HasSubset.Subset Set.univ (Set.iUnion fun x => Set.iUnion fun h => Metric.ball x (u n)))\n‚ä¢ sorryAx (Unit ‚Üí Prop) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 762).num 4).num 762).num 20).num 4).num 20).str \"_sorry\").str \"_@\").str \"_hyg\").num 2195))","decl":"/-- Compactness criterion: a closed set of compact metric spaces is compact if the spaces have\na uniformly bounded diameter, and for all `Œµ` the number of balls of radius `Œµ` required\nto cover the spaces is uniformly bounded. This is an equivalence, but we only prove the\ninteresting direction that these conditions imply compactness. -/\ntheorem totallyBounded {t : Set GHSpace} {C : ‚Ñù} {u : ‚Ñï ‚Üí ‚Ñù} {K : ‚Ñï ‚Üí ‚Ñï}\n    (ulim : Tendsto u atTop (ùìù 0)) (hdiam : ‚àÄ p ‚àà t, diam (univ : Set (GHSpace.Rep p)) ‚â§ C)\n    (hcov : ‚àÄ p ‚àà t, ‚àÄ n : ‚Ñï, ‚àÉ s : Set (GHSpace.Rep p),\n      (#s) ‚â§ K n ‚àß univ ‚äÜ ‚ãÉ x ‚àà s, ball x (u n)) :\n    TotallyBounded t := by\n  /- Let `Œ¥>0`, and `Œµ = Œ¥/5`. For each `p`, we construct a finite subset `s p` of `p`, which\n    is `Œµ`-dense and has cardinality at most `K n`. Encoding the mutual distances of points\n    in `s p`, up to `Œµ`, we will get a map `F` associating to `p` finitely many data, and making\n    it possible to reconstruct `p` up to `Œµ`. This is enough to prove total boundedness. -/\n  refine Metric.totallyBounded_of_finite_discretization fun Œ¥ Œ¥pos => ?_\n  let Œµ := 1 / 5 * Œ¥\n  have Œµpos : 0 < Œµ := mul_pos (by norm_num) Œ¥pos\n  -- choose `n` for which `u n < Œµ`\n  rcases Metric.tendsto_atTop.1 ulim Œµ Œµpos with ‚ü®n, hn‚ü©\n  have u_le_Œµ : u n ‚â§ Œµ := by\n    have := hn n le_rfl\n    simp only [Real.dist_eq, add_zero, sub_eq_add_neg, neg_zero] at this\n    exact le_of_lt (lt_of_le_of_lt (le_abs_self _) this)\n  -- construct a finite subset `s p` of `p` which is `Œµ`-dense and has cardinal `‚â§ K n`\n  have :\n    ‚àÄ p : GHSpace,\n      ‚àÉ s : Set p.Rep, ‚àÉ N ‚â§ K n, ‚àÉ _ : Equiv s (Fin N), p ‚àà t ‚Üí univ ‚äÜ ‚ãÉ x ‚àà s, ball x (u n) := by\n    intro p\n    by_cases hp : p ‚àâ t\n    ¬∑ have : Nonempty (Equiv (‚àÖ : Set p.Rep) (Fin 0)) := by\n        rw [‚Üê Fintype.card_eq]\n        simp only [empty_card', Fintype.card_fin]\n      use ‚àÖ, 0, bot_le, this.some\n      -- Porting note: unclear why this next line wasn't needed in Lean 3\n      exact fun hp' => (hp hp').elim\n    ¬∑ rcases hcov _ (Set.not_not_mem.1 hp) n with ‚ü®s, ‚ü®scard, scover‚ü©‚ü©\n      rcases Cardinal.lt_aleph0.1 (lt_of_le_of_lt scard (Cardinal.nat_lt_aleph0 _)) with ‚ü®N, hN‚ü©\n      rw [hN, Nat.cast_le] at scard\n      have : #s = #(Fin N) := by rw [hN, Cardinal.mk_fin]\n      cases' Quotient.exact this with E\n      use s, N, scard, E\n      simp only [scover, imp_true_iff]\n  choose s N hN E hs using this\n  -- Define a function `F` taking values in a finite type and associating to `p` enough data\n  -- to reconstruct it up to `Œµ`, namely the (discretized) distances between elements of `s p`.\n  let M := ‚åäŒµ‚Åª¬π * max C 0‚åã‚Çä\n  let F : GHSpace ‚Üí Œ£ k : Fin (K n).succ, Fin k ‚Üí Fin k ‚Üí Fin M.succ := fun p =>\n    ‚ü®‚ü®N p, lt_of_le_of_lt (hN p) (Nat.lt_succ_self _)‚ü©, fun a b =>\n      ‚ü®min M ‚åäŒµ‚Åª¬π * dist ((E p).symm a) ((E p).symm b)‚åã‚Çä,\n        (min_le_left _ _).trans_lt (Nat.lt_succ_self _)‚ü©‚ü©\n  refine ‚ü®_, ?_, fun p => F p, ?_‚ü©\n  ¬∑ infer_instance\n  -- It remains to show that if `F p = F q`, then `p` and `q` are `Œµ`-close\n  rintro ‚ü®p, pt‚ü© ‚ü®q, qt‚ü© hpq\n  have Npq : N p = N q := Fin.ext_iff.1 (Sigma.mk.inj_iff.1 hpq).1\n  let Œ® : s p ‚Üí s q := fun x => (E q).symm (Fin.cast Npq ((E p) x))\n  let Œ¶ : s p ‚Üí q.Rep := fun x => Œ® x\n  have main : ghDist p.Rep q.Rep ‚â§ Œµ + Œµ / 2 + Œµ := by\n    -- to prove the main inequality, argue that `s p` is `Œµ`-dense in `p`, and `s q` is `Œµ`-dense\n    -- in `q`, and `s p` and `s q` are almost isometric. Then closeness follows\n    -- from `ghDist_le_of_approx_subsets`\n    refine ghDist_le_of_approx_subsets Œ¶ ?_ ?_ ?_\n    ¬∑ show ‚àÄ x : p.Rep, ‚àÉ y ‚àà s p, dist x y ‚â§ Œµ\n      -- by construction, `s p` is `Œµ`-dense\n      intro x\n      have : x ‚àà ‚ãÉ y ‚àà s p, ball y (u n) := (hs p pt) (mem_univ _)\n      rcases mem_iUnion‚ÇÇ.1 this with ‚ü®y, ys, hy‚ü©\n      exact ‚ü®y, ys, le_trans (le_of_lt hy) u_le_Œµ‚ü©\n    ¬∑ show ‚àÄ x : q.Rep, ‚àÉ z : s p, dist x (Œ¶ z) ‚â§ Œµ\n      -- by construction, `s q` is `Œµ`-dense, and it is the range of `Œ¶`\n      intro x\n      have : x ‚àà ‚ãÉ y ‚àà s q, ball y (u n) := (hs q qt) (mem_univ _)\n      rcases mem_iUnion‚ÇÇ.1 this with ‚ü®y, ys, hy‚ü©\n      let i : ‚Ñï := E q ‚ü®y, ys‚ü©\n      let hi := ((E q) ‚ü®y, ys‚ü©).2\n      have ihi_eq : (‚ü®i, hi‚ü© : Fin (N q)) = (E q) ‚ü®y, ys‚ü© := by rw [Fin.ext_iff, Fin.val_mk]\n      have hiq : i < N q := hi\n      have hip : i < N p := by rwa [Npq.symm] at hiq\n      let z := (E p).symm ‚ü®i, hip‚ü©\n      use z\n      have C1 : (E p) z = ‚ü®i, hip‚ü© := (E p).apply_symm_apply ‚ü®i, hip‚ü©\n      have C2 : Fin.cast Npq ‚ü®i, hip‚ü© = ‚ü®i, hi‚ü© := rfl\n      have C3 : (E q).symm ‚ü®i, hi‚ü© = ‚ü®y, ys‚ü© := by\n        rw [ihi_eq]; exact (E q).symm_apply_apply ‚ü®y, ys‚ü©\n      have : Œ¶ z = y := by simp only [Œ®, Œ¶]; rw [C1, C2, C3]\n      rw [this]\n      exact le_trans (le_of_lt hy) u_le_Œµ\n    ¬∑ show ‚àÄ x y : s p, |dist x y - dist (Œ¶ x) (Œ¶ y)| ‚â§ Œµ\n      /- the distance between `x` and `y` is encoded in `F p`, and the distance between\n            `Œ¶ x` and `Œ¶ y` (two points of `s q`) is encoded in `F q`, all this up to `Œµ`.\n            As `F p = F q`, the distances are almost equal. -/\n      intro x y\n      have : dist (Œ¶ x) (Œ¶ y) = dist (Œ® x) (Œ® y) := rfl\n      rw [this]\n      -- introduce `i`, that codes both `x` and `Œ¶ x` in `Fin (N p) = Fin (N q)`\n      let i : ‚Ñï := E p x\n      have hip : i < N p := ((E p) x).2\n      have hiq : i < N q := by rwa [Npq] at hip\n      have i' : i = (E q) (Œ® x) := by simp only [i, Œ®, Equiv.apply_symm_apply, Fin.coe_cast]\n      -- introduce `j`, that codes both `y` and `Œ¶ y` in `Fin (N p) = Fin (N q)`\n      let j : ‚Ñï := E p y\n      have hjp : j < N p := ((E p) y).2\n      have hjq : j < N q := by rwa [Npq] at hjp\n      have j' : j = (E q) (Œ® y) := by simp only [j, Œ®, Equiv.apply_symm_apply, Fin.coe_cast]\n      -- Express `dist x y` in terms of `F p`\n      have Ap : ((F p).2 ‚ü®i, hip‚ü© ‚ü®j, hjp‚ü©).1 = ‚åäŒµ‚Åª¬π * dist x y‚åã‚Çä :=\n        calc\n          ((F p).2 ‚ü®i, hip‚ü© ‚ü®j, hjp‚ü©).1 = ((F p).2 ((E p) x) ((E p) y)).1 := by\n            congr\n          _ = min M ‚åäŒµ‚Åª¬π * dist x y‚åã‚Çä := by simp only [F, (E p).symm_apply_apply]\n          _ = ‚åäŒµ‚Åª¬π * dist x y‚åã‚Çä := by\n            refine min_eq_right (Nat.floor_mono ?_)\n            refine mul_le_mul_of_nonneg_left (le_trans ?_ (le_max_left _ _)) (inv_pos.2 Œµpos).le\n            change dist (x : p.Rep) y ‚â§ C\n            refine (dist_le_diam_of_mem isCompact_univ.isBounded (mem_univ _) (mem_univ _)).trans ?_\n            exact hdiam p pt\n      -- Express `dist (Œ¶ x) (Œ¶ y)` in terms of `F q`\n      have Aq : ((F q).2 ‚ü®i, hiq‚ü© ‚ü®j, hjq‚ü©).1 = ‚åäŒµ‚Åª¬π * dist (Œ® x) (Œ® y)‚åã‚Çä :=\n        calc\n          ((F q).2 ‚ü®i, hiq‚ü© ‚ü®j, hjq‚ü©).1 = ((F q).2 ((E q) (Œ® x)) ((E q) (Œ® y))).1 := by\n            -- Porting note: `congr` drops `Fin.val` but fails to make further progress\n            exact congr_arg‚ÇÇ (Fin.val <| (F q).2 ¬∑ ¬∑) (Fin.ext i') (Fin.ext j')\n          _ = min M ‚åäŒµ‚Åª¬π * dist (Œ® x) (Œ® y)‚åã‚Çä := by simp only [F, (E q).symm_apply_apply]\n          _ = ‚åäŒµ‚Åª¬π * dist (Œ® x) (Œ® y)‚åã‚Çä := by\n            refine min_eq_right (Nat.floor_mono ?_)\n            refine mul_le_mul_of_nonneg_left (le_trans ?_ (le_max_left _ _)) (inv_pos.2 Œµpos).le\n            change dist (Œ® x : q.Rep) (Œ® y) ‚â§ C\n            refine (dist_le_diam_of_mem isCompact_univ.isBounded (mem_univ _) (mem_univ _)).trans ?_\n            exact hdiam q qt\n      -- use the equality between `F p` and `F q` to deduce that the distances have equal\n      -- integer parts\n      have : ((F p).2 ‚ü®i, hip‚ü© ‚ü®j, hjp‚ü©).1 = ((F q).2 ‚ü®i, hiq‚ü© ‚ü®j, hjq‚ü©).1 := by\n        have hpq' : HEq (F p).snd (F q).snd := (Sigma.mk.inj_iff.1 hpq).2\n        rw [Fin.heq_fun‚ÇÇ_iff Npq Npq] at hpq'\n        rw [‚Üê hpq']\n        -- Porting note: new version above because `subst‚Ä¶` does not work\n        -- we want to `subst hpq` where `hpq : F p = F q`, except that `subst` only works\n        -- with a constant, so replace `F q` (and everything that depends on it) by a constant `f`\n        -- then `subst`\n        -- dsimp only [show N q = (F q).1 from rfl] at hiq hjq ‚ä¢\n        -- generalize F q = f at hpq ‚ä¢\n        -- subst hpq\n        -- intros\n        -- rfl\n      have : ‚åäŒµ‚Åª¬π * dist x y‚åã = ‚åäŒµ‚Åª¬π * dist (Œ® x) (Œ® y)‚åã := by\n        rw [Ap, Aq] at this\n        have D : 0 ‚â§ ‚åäŒµ‚Åª¬π * dist x y‚åã :=\n          floor_nonneg.2 (mul_nonneg (le_of_lt (inv_pos.2 Œµpos)) dist_nonneg)\n        have D' : 0 ‚â§ ‚åäŒµ‚Åª¬π * dist (Œ® x) (Œ® y)‚åã :=\n          floor_nonneg.2 (mul_nonneg (le_of_lt (inv_pos.2 Œµpos)) dist_nonneg)\n        rw [‚Üê Int.toNat_of_nonneg D, ‚Üê Int.toNat_of_nonneg D', Int.floor_toNat, Int.floor_toNat,\n          this]\n      -- deduce that the distances coincide up to `Œµ`, by a straightforward computation\n      -- that should be automated\n      have I :=\n        calc\n          |Œµ‚Åª¬π| * |dist x y - dist (Œ® x) (Œ® y)| = |Œµ‚Åª¬π * (dist x y - dist (Œ® x) (Œ® y))| :=\n            (abs_mul _ _).symm\n          _ = |Œµ‚Åª¬π * dist x y - Œµ‚Åª¬π * dist (Œ® x) (Œ® y)| := by congr; ring\n          _ ‚â§ 1 := le_of_lt (abs_sub_lt_one_of_floor_eq_floor this)\n      calc\n        |dist x y - dist (Œ® x) (Œ® y)| = Œµ * Œµ‚Åª¬π * |dist x y - dist (Œ® x) (Œ® y)| := by\n          rw [mul_inv_cancel‚ÇÄ (ne_of_gt Œµpos), one_mul]\n        _ = Œµ * (|Œµ‚Åª¬π| * |dist x y - dist (Œ® x) (Œ® y)|) := by\n          rw [abs_of_nonneg (le_of_lt (inv_pos.2 Œµpos)), mul_assoc]\n        _ ‚â§ Œµ * 1 := mul_le_mul_of_nonneg_left I (le_of_lt Œµpos)\n        _ = Œµ := mul_one _\n  calc\n    dist p q = ghDist p.Rep q.Rep := dist_ghDist p q\n    _ ‚â§ Œµ + Œµ / 2 + Œµ := main\n    _ = Œ¥ / 2 := by simp only [Œµ, one_div]; ring\n    _ < Œ¥ := half_lt_self Œ¥pos\n\n"}
{"name":"GromovHausdorff.AuxGluingStruct.isom","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"A : Type\ninst‚úù : MetricSpace A\nself : GromovHausdorff.AuxGluingStruct A\n‚ä¢ Isometry self.embed","decl":"/-- Auxiliary structure used to glue metric spaces below, recording an isometric embedding\nof a type `A` in another metric space. -/\nstructure AuxGluingStruct (A : Type) [MetricSpace A] : Type 1 where\n  Space : Type\n  metric : MetricSpace Space\n  embed : A ‚Üí Space\n  isom : Isometry embed\n\n"}
{"name":"GromovHausdorff.AuxGluingStruct.mk.injEq","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"A : Type\ninst‚úù : MetricSpace A\nSpace‚úù : Type\nmetric‚úù : MetricSpace Space‚úù\nembed‚úù : A ‚Üí Space‚úù\nisom‚úù : Isometry embed‚úù\nSpace : Type\nmetric : MetricSpace Space\nembed : A ‚Üí Space\nisom : Isometry embed\n‚ä¢ Eq (Eq { Space := Space‚úù, metric := metric‚úù, embed := embed‚úù, isom := isom‚úù } { Space := Space, metric := metric, embed := embed, isom := isom }) (And (Eq Space‚úù Space) (And (HEq metric‚úù metric) (HEq embed‚úù embed)))","decl":"/-- Auxiliary structure used to glue metric spaces below, recording an isometric embedding\nof a type `A` in another metric space. -/\nstructure AuxGluingStruct (A : Type) [MetricSpace A] : Type 1 where\n  Space : Type\n  metric : MetricSpace Space\n  embed : A ‚Üí Space\n  isom : Isometry embed\n\n"}
{"name":"GromovHausdorff.AuxGluingStruct.mk.inj","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"A : Type\ninst‚úù : MetricSpace A\nSpace‚úù : Type\nmetric‚úù : MetricSpace Space‚úù\nembed‚úù : A ‚Üí Space‚úù\nisom‚úù : Isometry embed‚úù\nSpace : Type\nmetric : MetricSpace Space\nembed : A ‚Üí Space\nisom : Isometry embed\nx‚úù : Eq { Space := Space‚úù, metric := metric‚úù, embed := embed‚úù, isom := isom‚úù } { Space := Space, metric := metric, embed := embed, isom := isom }\n‚ä¢ And (Eq Space‚úù Space) (And (HEq metric‚úù metric) (HEq embed‚úù embed))","decl":"/-- Auxiliary structure used to glue metric spaces below, recording an isometric embedding\nof a type `A` in another metric space. -/\nstructure AuxGluingStruct (A : Type) [MetricSpace A] : Type 1 where\n  Space : Type\n  metric : MetricSpace Space\n  embed : A ‚Üí Space\n  isom : Isometry embed\n\n"}
{"name":"GromovHausdorff.AuxGluingStruct.mk.sizeOf_spec","module":"Mathlib.Topology.MetricSpace.GromovHausdorff","initialProofState":"A : Type\ninst‚úù¬π : MetricSpace A\ninst‚úù : SizeOf A\nSpace : Type\nmetric : MetricSpace Space\nembed : A ‚Üí Space\nisom : Isometry embed\n‚ä¢ Eq (SizeOf.sizeOf { Space := Space, metric := metric, embed := embed, isom := isom }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf Space)) (SizeOf.sizeOf metric))","decl":"/-- Auxiliary structure used to glue metric spaces below, recording an isometric embedding\nof a type `A` in another metric space. -/\nstructure AuxGluingStruct (A : Type) [MetricSpace A] : Type 1 where\n  Space : Type\n  metric : MetricSpace Space\n  embed : A ‚Üí Space\n  isom : Isometry embed\n\n"}
