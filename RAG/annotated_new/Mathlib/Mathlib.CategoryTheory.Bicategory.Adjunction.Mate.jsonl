{"name":"CategoryTheory.Bicategory.mateEquiv_symm_apply","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Mate","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\nc d e f : B\ng : Quiver.Hom c e\nh : Quiver.Hom d f\nl₁ : Quiver.Hom c d\nr₁ : Quiver.Hom d c\nl₂ : Quiver.Hom e f\nr₂ : Quiver.Hom f e\nadj₁ : CategoryTheory.Bicategory.Adjunction l₁ r₁\nadj₂ : CategoryTheory.Bicategory.Adjunction l₂ r₂\nβ : Quiver.Hom (CategoryTheory.CategoryStruct.comp r₁ g) (CategoryTheory.CategoryStruct.comp h r₂)\n⊢ Eq ((CategoryTheory.Bicategory.mateEquiv adj₁ adj₂).symm β) (CategoryTheory.bicategoricalComp (CategoryTheory.CategoryStruct.id (CategoryTheory.CategoryStruct.comp g l₂)) (CategoryTheory.bicategoricalComp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.whiskerRight adj₁.unit g) l₂) (CategoryTheory.bicategoricalComp (CategoryTheory.Bicategory.whiskerLeft l₁ (CategoryTheory.Bicategory.whiskerRight β l₂)) (CategoryTheory.bicategoricalComp (CategoryTheory.Bicategory.whiskerLeft l₁ (CategoryTheory.Bicategory.whiskerLeft h adj₂.counit)) (CategoryTheory.CategoryStruct.id (CategoryTheory.CategoryStruct.comp l₁ h))))))","decl":"/-- Suppose we have a square of 1-morphisms (where the top and bottom are adjunctions `l₁ ⊣ r₁`\nand `l₂ ⊣ r₂` respectively).\n\n      c ↔ d\n    g ↓   ↓ h\n      e ↔ f\n\nThen we have a bijection between natural transformations `g ≫ l₂ ⟶ l₁ ≫ h` and\n`r₁ ≫ g ⟶ h ≫ r₂`. This can be seen as a bijection of the 2-cells:\n\n         l₁                  r₁\n      c --→ d             c ←-- d\n    g ↓  ↗  ↓ h         g ↓  ↘  ↓ h\n      e --→ f             e ←-- f\n         L₂                  R₂\n\nNote that if one of the transformations is an iso, it does not imply the other is an iso.\n-/\n@[simps]\ndef mateEquiv : (g ≫ l₂ ⟶ l₁ ≫ h) ≃ (r₁ ≫ g ⟶ h ≫ r₂) where\n  toFun α   := 𝟙 _ ⊗≫ r₁ ◁ g ◁ adj₂.unit ⊗≫ r₁ ◁ α ▷ r₂ ⊗≫ adj₁.counit ▷ h ▷ r₂ ⊗≫ 𝟙 _\n  invFun β  := 𝟙 _ ⊗≫ adj₁.unit ▷ g ▷ l₂ ⊗≫ l₁ ◁ β ▷ l₂ ⊗≫ l₁ ◁ h ◁ adj₂.counit ⊗≫ 𝟙 _\n  left_inv α :=\n    calc\n      _ = 𝟙 _ ⊗≫ (adj₁.unit ▷ (g ≫ 𝟙 e) ≫ (l₁ ≫ r₁) ◁ g ◁ adj₂.unit) ▷ l₂ ⊗≫\n            l₁ ◁ r₁ ◁ α ▷ r₂ ▷ l₂ ⊗≫\n              l₁ ◁ (adj₁.counit ▷ h ▷ (r₂ ≫ l₂) ≫ (𝟙 d ≫ h) ◁ adj₂.counit) ⊗≫ 𝟙 _ := by\n        bicategory\n      _ = 𝟙 _ ⊗≫ g ◁ adj₂.unit ▷ l₂ ⊗≫\n            (adj₁.unit ▷ (g ≫ l₂) ≫ (l₁ ≫ r₁) ◁ α) ▷ (r₂ ≫ l₂) ⊗≫\n              l₁ ◁ (((r₁ ≫ l₁) ≫ h) ◁ adj₂.counit ≫ adj₁.counit ▷ h ▷ 𝟙 f) ⊗≫ 𝟙 _ := by\n        rw [← whisker_exchange, ← whisker_exchange]\n        bicategory\n      _ = 𝟙 _ ⊗≫ g ◁ adj₂.unit ▷ l₂ ⊗≫ α ▷ r₂ ▷ l₂ ⊗≫\n            leftZigzag adj₁.unit adj₁.counit ▷ h ▷ r₂ ▷ l₂ ⊗≫ l₁ ◁ h ◁ adj₂.counit ⊗≫ 𝟙 _ := by\n        rw [← whisker_exchange, whisker_exchange _ adj₂.counit]\n        bicategory\n      _ = 𝟙 _ ⊗≫ g ◁ adj₂.unit ▷ l₂ ⊗≫ (α ▷ (r₂ ≫ l₂) ≫ (l₁ ≫ h) ◁ adj₂.counit) ⊗≫ 𝟙 _ := by\n        rw [adj₁.left_triangle]\n        bicategory\n      _ = 𝟙 _ ⊗≫ g ◁ (leftZigzag adj₂.unit adj₂.counit) ⊗≫ α ⊗≫ 𝟙 _ := by\n        rw [← whisker_exchange]\n        bicategory\n      _ = α := by\n        rw [adj₂.left_triangle]\n        bicategory\n  right_inv β :=\n    calc\n      _ = 𝟙 _ ⊗≫ r₁ ◁ ((𝟙 c ≫ g) ◁ adj₂.unit ≫ adj₁.unit ▷ g ▷ (l₂ ≫ r₂)) ⊗≫\n            r₁ ◁ l₁ ◁ β ▷ l₂ ▷ r₂ ⊗≫\n              ((r₁ ≫ l₁) ◁ h ◁ adj₂.counit ≫ adj₁.counit ▷ (h ≫ 𝟙 f)) ▷ r₂ ⊗≫ 𝟙 _ := by\n        bicategory\n      _ = 𝟙 _ ⊗≫ r₁ ◁ (adj₁.unit ▷ g ▷ 𝟙 e ≫ ((l₁ ≫ r₁) ≫ g) ◁ adj₂.unit) ⊗≫\n            ((r₁ ≫ l₁) ◁ β ≫ adj₁.counit ▷ (h ≫ r₂)) ▷ l₂ ▷ r₂ ⊗≫\n              h ◁ adj₂.counit ▷ r₂ ⊗≫ 𝟙 _ := by\n        rw [whisker_exchange, whisker_exchange]\n        bicategory\n      _ = 𝟙 _ ⊗≫ r₁ ◁ g ◁ adj₂.unit ⊗≫ rightZigzag adj₁.unit adj₁.counit ▷ g ▷ l₂ ▷ r₂ ⊗≫\n            β ▷ l₂ ▷ r₂ ⊗≫ h ◁ adj₂.counit ▷ r₂ ⊗≫ 𝟙 _ := by\n        rw [whisker_exchange, ← whisker_exchange _ adj₂.unit]\n        bicategory\n      _ = 𝟙 _ ⊗≫ ((r₁ ≫ g) ◁ adj₂.unit ≫ β ▷ (l₂ ≫ r₂)) ⊗≫ h ◁ adj₂.counit ▷ r₂ ⊗≫ 𝟙 _ := by\n        rw [adj₁.right_triangle]\n        bicategory\n      _ = 𝟙 _ ⊗≫ β ⊗≫ h ◁ rightZigzag adj₂.unit adj₂.counit ⊗≫ 𝟙 _ := by\n        rw [whisker_exchange]\n        bicategory\n      _ = β := by\n        rw [adj₂.right_triangle]\n        bicategory\n\n"}
{"name":"CategoryTheory.Bicategory.mateEquiv_apply","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Mate","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\nc d e f : B\ng : Quiver.Hom c e\nh : Quiver.Hom d f\nl₁ : Quiver.Hom c d\nr₁ : Quiver.Hom d c\nl₂ : Quiver.Hom e f\nr₂ : Quiver.Hom f e\nadj₁ : CategoryTheory.Bicategory.Adjunction l₁ r₁\nadj₂ : CategoryTheory.Bicategory.Adjunction l₂ r₂\nα : Quiver.Hom (CategoryTheory.CategoryStruct.comp g l₂) (CategoryTheory.CategoryStruct.comp l₁ h)\n⊢ Eq ((CategoryTheory.Bicategory.mateEquiv adj₁ adj₂) α) (CategoryTheory.bicategoricalComp (CategoryTheory.CategoryStruct.id (CategoryTheory.CategoryStruct.comp r₁ g)) (CategoryTheory.bicategoricalComp (CategoryTheory.Bicategory.whiskerLeft r₁ (CategoryTheory.Bicategory.whiskerLeft g adj₂.unit)) (CategoryTheory.bicategoricalComp (CategoryTheory.Bicategory.whiskerLeft r₁ (CategoryTheory.Bicategory.whiskerRight α r₂)) (CategoryTheory.bicategoricalComp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.whiskerRight adj₁.counit h) r₂) (CategoryTheory.CategoryStruct.id (CategoryTheory.CategoryStruct.comp h r₂))))))","decl":"/-- Suppose we have a square of 1-morphisms (where the top and bottom are adjunctions `l₁ ⊣ r₁`\nand `l₂ ⊣ r₂` respectively).\n\n      c ↔ d\n    g ↓   ↓ h\n      e ↔ f\n\nThen we have a bijection between natural transformations `g ≫ l₂ ⟶ l₁ ≫ h` and\n`r₁ ≫ g ⟶ h ≫ r₂`. This can be seen as a bijection of the 2-cells:\n\n         l₁                  r₁\n      c --→ d             c ←-- d\n    g ↓  ↗  ↓ h         g ↓  ↘  ↓ h\n      e --→ f             e ←-- f\n         L₂                  R₂\n\nNote that if one of the transformations is an iso, it does not imply the other is an iso.\n-/\n@[simps]\ndef mateEquiv : (g ≫ l₂ ⟶ l₁ ≫ h) ≃ (r₁ ≫ g ⟶ h ≫ r₂) where\n  toFun α   := 𝟙 _ ⊗≫ r₁ ◁ g ◁ adj₂.unit ⊗≫ r₁ ◁ α ▷ r₂ ⊗≫ adj₁.counit ▷ h ▷ r₂ ⊗≫ 𝟙 _\n  invFun β  := 𝟙 _ ⊗≫ adj₁.unit ▷ g ▷ l₂ ⊗≫ l₁ ◁ β ▷ l₂ ⊗≫ l₁ ◁ h ◁ adj₂.counit ⊗≫ 𝟙 _\n  left_inv α :=\n    calc\n      _ = 𝟙 _ ⊗≫ (adj₁.unit ▷ (g ≫ 𝟙 e) ≫ (l₁ ≫ r₁) ◁ g ◁ adj₂.unit) ▷ l₂ ⊗≫\n            l₁ ◁ r₁ ◁ α ▷ r₂ ▷ l₂ ⊗≫\n              l₁ ◁ (adj₁.counit ▷ h ▷ (r₂ ≫ l₂) ≫ (𝟙 d ≫ h) ◁ adj₂.counit) ⊗≫ 𝟙 _ := by\n        bicategory\n      _ = 𝟙 _ ⊗≫ g ◁ adj₂.unit ▷ l₂ ⊗≫\n            (adj₁.unit ▷ (g ≫ l₂) ≫ (l₁ ≫ r₁) ◁ α) ▷ (r₂ ≫ l₂) ⊗≫\n              l₁ ◁ (((r₁ ≫ l₁) ≫ h) ◁ adj₂.counit ≫ adj₁.counit ▷ h ▷ 𝟙 f) ⊗≫ 𝟙 _ := by\n        rw [← whisker_exchange, ← whisker_exchange]\n        bicategory\n      _ = 𝟙 _ ⊗≫ g ◁ adj₂.unit ▷ l₂ ⊗≫ α ▷ r₂ ▷ l₂ ⊗≫\n            leftZigzag adj₁.unit adj₁.counit ▷ h ▷ r₂ ▷ l₂ ⊗≫ l₁ ◁ h ◁ adj₂.counit ⊗≫ 𝟙 _ := by\n        rw [← whisker_exchange, whisker_exchange _ adj₂.counit]\n        bicategory\n      _ = 𝟙 _ ⊗≫ g ◁ adj₂.unit ▷ l₂ ⊗≫ (α ▷ (r₂ ≫ l₂) ≫ (l₁ ≫ h) ◁ adj₂.counit) ⊗≫ 𝟙 _ := by\n        rw [adj₁.left_triangle]\n        bicategory\n      _ = 𝟙 _ ⊗≫ g ◁ (leftZigzag adj₂.unit adj₂.counit) ⊗≫ α ⊗≫ 𝟙 _ := by\n        rw [← whisker_exchange]\n        bicategory\n      _ = α := by\n        rw [adj₂.left_triangle]\n        bicategory\n  right_inv β :=\n    calc\n      _ = 𝟙 _ ⊗≫ r₁ ◁ ((𝟙 c ≫ g) ◁ adj₂.unit ≫ adj₁.unit ▷ g ▷ (l₂ ≫ r₂)) ⊗≫\n            r₁ ◁ l₁ ◁ β ▷ l₂ ▷ r₂ ⊗≫\n              ((r₁ ≫ l₁) ◁ h ◁ adj₂.counit ≫ adj₁.counit ▷ (h ≫ 𝟙 f)) ▷ r₂ ⊗≫ 𝟙 _ := by\n        bicategory\n      _ = 𝟙 _ ⊗≫ r₁ ◁ (adj₁.unit ▷ g ▷ 𝟙 e ≫ ((l₁ ≫ r₁) ≫ g) ◁ adj₂.unit) ⊗≫\n            ((r₁ ≫ l₁) ◁ β ≫ adj₁.counit ▷ (h ≫ r₂)) ▷ l₂ ▷ r₂ ⊗≫\n              h ◁ adj₂.counit ▷ r₂ ⊗≫ 𝟙 _ := by\n        rw [whisker_exchange, whisker_exchange]\n        bicategory\n      _ = 𝟙 _ ⊗≫ r₁ ◁ g ◁ adj₂.unit ⊗≫ rightZigzag adj₁.unit adj₁.counit ▷ g ▷ l₂ ▷ r₂ ⊗≫\n            β ▷ l₂ ▷ r₂ ⊗≫ h ◁ adj₂.counit ▷ r₂ ⊗≫ 𝟙 _ := by\n        rw [whisker_exchange, ← whisker_exchange _ adj₂.unit]\n        bicategory\n      _ = 𝟙 _ ⊗≫ ((r₁ ≫ g) ◁ adj₂.unit ≫ β ▷ (l₂ ≫ r₂)) ⊗≫ h ◁ adj₂.counit ▷ r₂ ⊗≫ 𝟙 _ := by\n        rw [adj₁.right_triangle]\n        bicategory\n      _ = 𝟙 _ ⊗≫ β ⊗≫ h ◁ rightZigzag adj₂.unit adj₂.counit ⊗≫ 𝟙 _ := by\n        rw [whisker_exchange]\n        bicategory\n      _ = β := by\n        rw [adj₂.right_triangle]\n        bicategory\n\n"}
{"name":"CategoryTheory.Bicategory.mateEquiv_vcomp","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Mate","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b c d e f : B\ng₁ : Quiver.Hom a c\ng₂ : Quiver.Hom c e\nh₁ : Quiver.Hom b d\nh₂ : Quiver.Hom d f\nl₁ : Quiver.Hom a b\nr₁ : Quiver.Hom b a\nl₂ : Quiver.Hom c d\nr₂ : Quiver.Hom d c\nl₃ : Quiver.Hom e f\nr₃ : Quiver.Hom f e\nadj₁ : CategoryTheory.Bicategory.Adjunction l₁ r₁\nadj₂ : CategoryTheory.Bicategory.Adjunction l₂ r₂\nadj₃ : CategoryTheory.Bicategory.Adjunction l₃ r₃\nα : Quiver.Hom (CategoryTheory.CategoryStruct.comp g₁ l₂) (CategoryTheory.CategoryStruct.comp l₁ h₁)\nβ : Quiver.Hom (CategoryTheory.CategoryStruct.comp g₂ l₃) (CategoryTheory.CategoryStruct.comp l₂ h₂)\n⊢ Eq ((CategoryTheory.Bicategory.mateEquiv adj₁ adj₃) (CategoryTheory.Bicategory.leftAdjointSquare.vcomp α β)) (CategoryTheory.Bicategory.rightAdjointSquare.vcomp ((CategoryTheory.Bicategory.mateEquiv adj₁ adj₂) α) ((CategoryTheory.Bicategory.mateEquiv adj₂ adj₃) β))","decl":"/-- The mates equivalence commutes with vertical composition. -/\ntheorem mateEquiv_vcomp (α : g₁ ≫ l₂ ⟶ l₁ ≫ h₁) (β : g₂ ≫ l₃ ⟶ l₂ ≫ h₂) :\n    mateEquiv adj₁ adj₃ (leftAdjointSquare.vcomp α β) =\n      rightAdjointSquare.vcomp (mateEquiv adj₁ adj₂ α) (mateEquiv adj₂ adj₃ β) := by\n  dsimp only [leftAdjointSquare.vcomp, mateEquiv_apply, rightAdjointSquare.vcomp]\n  symm\n  calc\n    _ = 𝟙 _ ⊗≫ r₁ ◁ g₁ ◁ adj₂.unit ▷ g₂ ⊗≫ r₁ ◁ α ▷ r₂ ▷ g₂ ⊗≫\n          ((adj₁.counit ▷ (h₁ ≫ r₂ ≫ g₂ ≫ 𝟙 e)) ≫ 𝟙 b ◁ (h₁ ◁ r₂ ◁ g₂ ◁ adj₃.unit)) ⊗≫\n            h₁ ◁ r₂ ◁ β ▷ r₃ ⊗≫ h₁ ◁ adj₂.counit ▷ h₂ ▷ r₃ ⊗≫ 𝟙 _ := by\n      bicategory\n    _ = 𝟙 _ ⊗≫ r₁ ◁ g₁ ◁ adj₂.unit ▷ g₂ ⊗≫\n          (r₁ ◁ (α ▷ (r₂ ≫ g₂ ≫ 𝟙 e) ≫ (l₁ ≫ h₁) ◁ r₂ ◁ g₂ ◁ adj₃.unit)) ⊗≫\n            ((adj₁.counit ▷ (h₁ ≫ r₂) ▷ (g₂ ≫ l₃) ≫ (𝟙 b ≫ h₁ ≫ r₂) ◁ β) ▷ r₃) ⊗≫\n              h₁ ◁ adj₂.counit ▷ h₂ ▷ r₃ ⊗≫ 𝟙 _ := by\n      rw [← whisker_exchange]\n      bicategory\n    _ = 𝟙 _ ⊗≫ r₁ ◁ g₁ ◁ (adj₂.unit ▷ (g₂ ≫ 𝟙 e) ≫ (l₂ ≫ r₂) ◁ g₂ ◁ adj₃.unit) ⊗≫\n          (r₁ ◁ (α ▷ (r₂ ≫ g₂ ≫ l₃) ≫ (l₁ ≫ h₁) ◁ r₂ ◁ β) ▷ r₃) ⊗≫\n            (adj₁.counit ▷ h₁ ▷ (r₂ ≫ l₂) ≫ (𝟙 b ≫ h₁) ◁ adj₂.counit) ▷ h₂ ▷ r₃ ⊗≫ 𝟙 _ := by\n      rw [← whisker_exchange, ← whisker_exchange]\n      bicategory\n    _ = 𝟙 _ ⊗≫ r₁ ◁ g₁ ◁ g₂ ◁ adj₃.unit ⊗≫\n          r₁ ◁ g₁ ◁ (adj₂.unit ▷ (g₂ ≫ l₃) ≫ (l₂ ≫ r₂) ◁ β) ▷ r₃ ⊗≫\n            r₁ ◁ (α ▷ (r₂ ≫ l₂) ≫ (l₁ ≫ h₁) ◁ adj₂.counit) ▷ h₂ ▷ r₃ ⊗≫\n              adj₁.counit ▷ h₁ ▷ h₂ ▷ r₃ ⊗≫ 𝟙 _ := by\n      rw [← whisker_exchange, ← whisker_exchange, ← whisker_exchange]\n      bicategory\n    _ = 𝟙 _ ⊗≫ r₁ ◁ g₁ ◁ g₂ ◁ adj₃.unit ⊗≫ r₁ ◁ g₁ ◁ β ▷ r₃ ⊗≫\n          ((r₁ ≫ g₁) ◁ leftZigzag adj₂.unit adj₂.counit ▷ (h₂ ≫ r₃)) ⊗≫\n            r₁ ◁ α ▷ h₂ ▷ r₃ ⊗≫ adj₁.counit ▷ h₁ ▷ h₂ ▷ r₃ ⊗≫ 𝟙 _ := by\n      rw [← whisker_exchange, ← whisker_exchange]\n      bicategory\n    _ = _ := by\n      rw [adj₂.left_triangle]\n      bicategory\n\n"}
{"name":"CategoryTheory.Bicategory.mateEquiv_hcomp","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Mate","initialProofState":"B : Type u\ninst✝ : CategoryTheory.Bicategory B\na b c d e f : B\ng : Quiver.Hom a d\nh : Quiver.Hom b e\nk : Quiver.Hom c f\nl₁ : Quiver.Hom a b\nr₁ : Quiver.Hom b a\nl₂ : Quiver.Hom d e\nr₂ : Quiver.Hom e d\nl₃ : Quiver.Hom b c\nr₃ : Quiver.Hom c b\nl₄ : Quiver.Hom e f\nr₄ : Quiver.Hom f e\nadj₁ : CategoryTheory.Bicategory.Adjunction l₁ r₁\nadj₂ : CategoryTheory.Bicategory.Adjunction l₂ r₂\nadj₃ : CategoryTheory.Bicategory.Adjunction l₃ r₃\nadj₄ : CategoryTheory.Bicategory.Adjunction l₄ r₄\nα : Quiver.Hom (CategoryTheory.CategoryStruct.comp g l₂) (CategoryTheory.CategoryStruct.comp l₁ h)\nβ : Quiver.Hom (CategoryTheory.CategoryStruct.comp h l₄) (CategoryTheory.CategoryStruct.comp l₃ k)\n⊢ Eq ((CategoryTheory.Bicategory.mateEquiv (adj₁.comp adj₃) (adj₂.comp adj₄)) (CategoryTheory.Bicategory.leftAdjointSquare.hcomp α β)) (CategoryTheory.Bicategory.rightAdjointSquare.hcomp ((CategoryTheory.Bicategory.mateEquiv adj₁ adj₂) α) ((CategoryTheory.Bicategory.mateEquiv adj₃ adj₄) β))","decl":"/-- The mates equivalence commutes with horizontal composition of squares. -/\ntheorem mateEquiv_hcomp (α : g ≫ l₂ ⟶ l₁ ≫ h) (β : h ≫ l₄ ⟶ l₃ ≫ k) :\n    (mateEquiv (adj₁.comp adj₃) (adj₂.comp adj₄)) (leftAdjointSquare.hcomp α β) =\n      rightAdjointSquare.hcomp (mateEquiv adj₁ adj₂ α) (mateEquiv adj₃ adj₄ β) := by\n  dsimp [mateEquiv, leftAdjointSquare.hcomp, rightAdjointSquare.hcomp]\n  calc\n    _ = 𝟙 _ ⊗≫ r₃ ◁ r₁ ◁ g ◁ adj₂.unit ⊗≫\n          r₃ ◁ r₁ ◁ ((g ≫ l₂) ◁ adj₄.unit ≫ α ▷ (l₄ ≫ r₄)) ▷ r₂ ⊗≫\n            r₃ ◁ ((r₁ ≫ l₁) ◁ β ≫ adj₁.counit ▷ (l₃ ≫ k)) ▷ r₄ ▷ r₂ ⊗≫\n              adj₃.counit ▷ k ▷ r₄ ▷ r₂ ⊗≫ 𝟙 _ := by\n      bicategory\n    _ = 𝟙 _ ⊗≫ r₃ ◁ r₁ ◁ g ◁ adj₂.unit ⊗≫ r₃ ◁ r₁ ◁ α ▷ r₂ ⊗≫\n          r₃ ◁ ((r₁ ≫ l₁) ◁ h ◁ adj₄.unit ≫ adj₁.counit ▷ (h ≫ l₄ ≫ r₄)) ▷ r₂ ⊗≫\n            r₃ ◁ β ▷ r₄ ▷ r₂ ⊗≫ adj₃.counit ▷ k ▷ r₄ ▷ r₂ ⊗≫ 𝟙 _ := by\n      rw [whisker_exchange, whisker_exchange]\n      bicategory\n    _ = _ := by\n      rw [whisker_exchange]\n      bicategory\n\n"}
