{"name":"CategoryTheory.Bicategory.mateEquiv_symm_apply","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Mate","initialProofState":"B : Type u\ninstâœ : CategoryTheory.Bicategory B\nc d e f : B\ng : Quiver.Hom c e\nh : Quiver.Hom d f\nlâ‚ : Quiver.Hom c d\nrâ‚ : Quiver.Hom d c\nlâ‚‚ : Quiver.Hom e f\nrâ‚‚ : Quiver.Hom f e\nadjâ‚ : CategoryTheory.Bicategory.Adjunction lâ‚ râ‚\nadjâ‚‚ : CategoryTheory.Bicategory.Adjunction lâ‚‚ râ‚‚\nÎ² : Quiver.Hom (CategoryTheory.CategoryStruct.comp râ‚ g) (CategoryTheory.CategoryStruct.comp h râ‚‚)\nâŠ¢ Eq ((CategoryTheory.Bicategory.mateEquiv adjâ‚ adjâ‚‚).symm Î²) (CategoryTheory.bicategoricalComp (CategoryTheory.CategoryStruct.id (CategoryTheory.CategoryStruct.comp g lâ‚‚)) (CategoryTheory.bicategoricalComp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.whiskerRight adjâ‚.unit g) lâ‚‚) (CategoryTheory.bicategoricalComp (CategoryTheory.Bicategory.whiskerLeft lâ‚ (CategoryTheory.Bicategory.whiskerRight Î² lâ‚‚)) (CategoryTheory.bicategoricalComp (CategoryTheory.Bicategory.whiskerLeft lâ‚ (CategoryTheory.Bicategory.whiskerLeft h adjâ‚‚.counit)) (CategoryTheory.CategoryStruct.id (CategoryTheory.CategoryStruct.comp lâ‚ h))))))","decl":"/-- Suppose we have a square of 1-morphisms (where the top and bottom are adjunctions `lâ‚ âŠ£ râ‚`\nand `lâ‚‚ âŠ£ râ‚‚` respectively).\n\n      c â†” d\n    g â†“   â†“ h\n      e â†” f\n\nThen we have a bijection between natural transformations `g â‰« lâ‚‚ âŸ¶ lâ‚ â‰« h` and\n`râ‚ â‰« g âŸ¶ h â‰« râ‚‚`. This can be seen as a bijection of the 2-cells:\n\n         lâ‚                  râ‚\n      c --â†’ d             c â†-- d\n    g â†“  â†—  â†“ h         g â†“  â†˜  â†“ h\n      e --â†’ f             e â†-- f\n         Lâ‚‚                  Râ‚‚\n\nNote that if one of the transformations is an iso, it does not imply the other is an iso.\n-/\n@[simps]\ndef mateEquiv : (g â‰« lâ‚‚ âŸ¶ lâ‚ â‰« h) â‰ƒ (râ‚ â‰« g âŸ¶ h â‰« râ‚‚) where\n  toFun Î±   := ğŸ™ _ âŠ—â‰« râ‚ â— g â— adjâ‚‚.unit âŠ—â‰« râ‚ â— Î± â–· râ‚‚ âŠ—â‰« adjâ‚.counit â–· h â–· râ‚‚ âŠ—â‰« ğŸ™ _\n  invFun Î²  := ğŸ™ _ âŠ—â‰« adjâ‚.unit â–· g â–· lâ‚‚ âŠ—â‰« lâ‚ â— Î² â–· lâ‚‚ âŠ—â‰« lâ‚ â— h â— adjâ‚‚.counit âŠ—â‰« ğŸ™ _\n  left_inv Î± :=\n    calc\n      _ = ğŸ™ _ âŠ—â‰« (adjâ‚.unit â–· (g â‰« ğŸ™ e) â‰« (lâ‚ â‰« râ‚) â— g â— adjâ‚‚.unit) â–· lâ‚‚ âŠ—â‰«\n            lâ‚ â— râ‚ â— Î± â–· râ‚‚ â–· lâ‚‚ âŠ—â‰«\n              lâ‚ â— (adjâ‚.counit â–· h â–· (râ‚‚ â‰« lâ‚‚) â‰« (ğŸ™ d â‰« h) â— adjâ‚‚.counit) âŠ—â‰« ğŸ™ _ := by\n        bicategory\n      _ = ğŸ™ _ âŠ—â‰« g â— adjâ‚‚.unit â–· lâ‚‚ âŠ—â‰«\n            (adjâ‚.unit â–· (g â‰« lâ‚‚) â‰« (lâ‚ â‰« râ‚) â— Î±) â–· (râ‚‚ â‰« lâ‚‚) âŠ—â‰«\n              lâ‚ â— (((râ‚ â‰« lâ‚) â‰« h) â— adjâ‚‚.counit â‰« adjâ‚.counit â–· h â–· ğŸ™ f) âŠ—â‰« ğŸ™ _ := by\n        rw [â† whisker_exchange, â† whisker_exchange]\n        bicategory\n      _ = ğŸ™ _ âŠ—â‰« g â— adjâ‚‚.unit â–· lâ‚‚ âŠ—â‰« Î± â–· râ‚‚ â–· lâ‚‚ âŠ—â‰«\n            leftZigzag adjâ‚.unit adjâ‚.counit â–· h â–· râ‚‚ â–· lâ‚‚ âŠ—â‰« lâ‚ â— h â— adjâ‚‚.counit âŠ—â‰« ğŸ™ _ := by\n        rw [â† whisker_exchange, whisker_exchange _ adjâ‚‚.counit]\n        bicategory\n      _ = ğŸ™ _ âŠ—â‰« g â— adjâ‚‚.unit â–· lâ‚‚ âŠ—â‰« (Î± â–· (râ‚‚ â‰« lâ‚‚) â‰« (lâ‚ â‰« h) â— adjâ‚‚.counit) âŠ—â‰« ğŸ™ _ := by\n        rw [adjâ‚.left_triangle]\n        bicategory\n      _ = ğŸ™ _ âŠ—â‰« g â— (leftZigzag adjâ‚‚.unit adjâ‚‚.counit) âŠ—â‰« Î± âŠ—â‰« ğŸ™ _ := by\n        rw [â† whisker_exchange]\n        bicategory\n      _ = Î± := by\n        rw [adjâ‚‚.left_triangle]\n        bicategory\n  right_inv Î² :=\n    calc\n      _ = ğŸ™ _ âŠ—â‰« râ‚ â— ((ğŸ™ c â‰« g) â— adjâ‚‚.unit â‰« adjâ‚.unit â–· g â–· (lâ‚‚ â‰« râ‚‚)) âŠ—â‰«\n            râ‚ â— lâ‚ â— Î² â–· lâ‚‚ â–· râ‚‚ âŠ—â‰«\n              ((râ‚ â‰« lâ‚) â— h â— adjâ‚‚.counit â‰« adjâ‚.counit â–· (h â‰« ğŸ™ f)) â–· râ‚‚ âŠ—â‰« ğŸ™ _ := by\n        bicategory\n      _ = ğŸ™ _ âŠ—â‰« râ‚ â— (adjâ‚.unit â–· g â–· ğŸ™ e â‰« ((lâ‚ â‰« râ‚) â‰« g) â— adjâ‚‚.unit) âŠ—â‰«\n            ((râ‚ â‰« lâ‚) â— Î² â‰« adjâ‚.counit â–· (h â‰« râ‚‚)) â–· lâ‚‚ â–· râ‚‚ âŠ—â‰«\n              h â— adjâ‚‚.counit â–· râ‚‚ âŠ—â‰« ğŸ™ _ := by\n        rw [whisker_exchange, whisker_exchange]\n        bicategory\n      _ = ğŸ™ _ âŠ—â‰« râ‚ â— g â— adjâ‚‚.unit âŠ—â‰« rightZigzag adjâ‚.unit adjâ‚.counit â–· g â–· lâ‚‚ â–· râ‚‚ âŠ—â‰«\n            Î² â–· lâ‚‚ â–· râ‚‚ âŠ—â‰« h â— adjâ‚‚.counit â–· râ‚‚ âŠ—â‰« ğŸ™ _ := by\n        rw [whisker_exchange, â† whisker_exchange _ adjâ‚‚.unit]\n        bicategory\n      _ = ğŸ™ _ âŠ—â‰« ((râ‚ â‰« g) â— adjâ‚‚.unit â‰« Î² â–· (lâ‚‚ â‰« râ‚‚)) âŠ—â‰« h â— adjâ‚‚.counit â–· râ‚‚ âŠ—â‰« ğŸ™ _ := by\n        rw [adjâ‚.right_triangle]\n        bicategory\n      _ = ğŸ™ _ âŠ—â‰« Î² âŠ—â‰« h â— rightZigzag adjâ‚‚.unit adjâ‚‚.counit âŠ—â‰« ğŸ™ _ := by\n        rw [whisker_exchange]\n        bicategory\n      _ = Î² := by\n        rw [adjâ‚‚.right_triangle]\n        bicategory\n\n"}
{"name":"CategoryTheory.Bicategory.mateEquiv_apply","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Mate","initialProofState":"B : Type u\ninstâœ : CategoryTheory.Bicategory B\nc d e f : B\ng : Quiver.Hom c e\nh : Quiver.Hom d f\nlâ‚ : Quiver.Hom c d\nrâ‚ : Quiver.Hom d c\nlâ‚‚ : Quiver.Hom e f\nrâ‚‚ : Quiver.Hom f e\nadjâ‚ : CategoryTheory.Bicategory.Adjunction lâ‚ râ‚\nadjâ‚‚ : CategoryTheory.Bicategory.Adjunction lâ‚‚ râ‚‚\nÎ± : Quiver.Hom (CategoryTheory.CategoryStruct.comp g lâ‚‚) (CategoryTheory.CategoryStruct.comp lâ‚ h)\nâŠ¢ Eq ((CategoryTheory.Bicategory.mateEquiv adjâ‚ adjâ‚‚) Î±) (CategoryTheory.bicategoricalComp (CategoryTheory.CategoryStruct.id (CategoryTheory.CategoryStruct.comp râ‚ g)) (CategoryTheory.bicategoricalComp (CategoryTheory.Bicategory.whiskerLeft râ‚ (CategoryTheory.Bicategory.whiskerLeft g adjâ‚‚.unit)) (CategoryTheory.bicategoricalComp (CategoryTheory.Bicategory.whiskerLeft râ‚ (CategoryTheory.Bicategory.whiskerRight Î± râ‚‚)) (CategoryTheory.bicategoricalComp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.whiskerRight adjâ‚.counit h) râ‚‚) (CategoryTheory.CategoryStruct.id (CategoryTheory.CategoryStruct.comp h râ‚‚))))))","decl":"/-- Suppose we have a square of 1-morphisms (where the top and bottom are adjunctions `lâ‚ âŠ£ râ‚`\nand `lâ‚‚ âŠ£ râ‚‚` respectively).\n\n      c â†” d\n    g â†“   â†“ h\n      e â†” f\n\nThen we have a bijection between natural transformations `g â‰« lâ‚‚ âŸ¶ lâ‚ â‰« h` and\n`râ‚ â‰« g âŸ¶ h â‰« râ‚‚`. This can be seen as a bijection of the 2-cells:\n\n         lâ‚                  râ‚\n      c --â†’ d             c â†-- d\n    g â†“  â†—  â†“ h         g â†“  â†˜  â†“ h\n      e --â†’ f             e â†-- f\n         Lâ‚‚                  Râ‚‚\n\nNote that if one of the transformations is an iso, it does not imply the other is an iso.\n-/\n@[simps]\ndef mateEquiv : (g â‰« lâ‚‚ âŸ¶ lâ‚ â‰« h) â‰ƒ (râ‚ â‰« g âŸ¶ h â‰« râ‚‚) where\n  toFun Î±   := ğŸ™ _ âŠ—â‰« râ‚ â— g â— adjâ‚‚.unit âŠ—â‰« râ‚ â— Î± â–· râ‚‚ âŠ—â‰« adjâ‚.counit â–· h â–· râ‚‚ âŠ—â‰« ğŸ™ _\n  invFun Î²  := ğŸ™ _ âŠ—â‰« adjâ‚.unit â–· g â–· lâ‚‚ âŠ—â‰« lâ‚ â— Î² â–· lâ‚‚ âŠ—â‰« lâ‚ â— h â— adjâ‚‚.counit âŠ—â‰« ğŸ™ _\n  left_inv Î± :=\n    calc\n      _ = ğŸ™ _ âŠ—â‰« (adjâ‚.unit â–· (g â‰« ğŸ™ e) â‰« (lâ‚ â‰« râ‚) â— g â— adjâ‚‚.unit) â–· lâ‚‚ âŠ—â‰«\n            lâ‚ â— râ‚ â— Î± â–· râ‚‚ â–· lâ‚‚ âŠ—â‰«\n              lâ‚ â— (adjâ‚.counit â–· h â–· (râ‚‚ â‰« lâ‚‚) â‰« (ğŸ™ d â‰« h) â— adjâ‚‚.counit) âŠ—â‰« ğŸ™ _ := by\n        bicategory\n      _ = ğŸ™ _ âŠ—â‰« g â— adjâ‚‚.unit â–· lâ‚‚ âŠ—â‰«\n            (adjâ‚.unit â–· (g â‰« lâ‚‚) â‰« (lâ‚ â‰« râ‚) â— Î±) â–· (râ‚‚ â‰« lâ‚‚) âŠ—â‰«\n              lâ‚ â— (((râ‚ â‰« lâ‚) â‰« h) â— adjâ‚‚.counit â‰« adjâ‚.counit â–· h â–· ğŸ™ f) âŠ—â‰« ğŸ™ _ := by\n        rw [â† whisker_exchange, â† whisker_exchange]\n        bicategory\n      _ = ğŸ™ _ âŠ—â‰« g â— adjâ‚‚.unit â–· lâ‚‚ âŠ—â‰« Î± â–· râ‚‚ â–· lâ‚‚ âŠ—â‰«\n            leftZigzag adjâ‚.unit adjâ‚.counit â–· h â–· râ‚‚ â–· lâ‚‚ âŠ—â‰« lâ‚ â— h â— adjâ‚‚.counit âŠ—â‰« ğŸ™ _ := by\n        rw [â† whisker_exchange, whisker_exchange _ adjâ‚‚.counit]\n        bicategory\n      _ = ğŸ™ _ âŠ—â‰« g â— adjâ‚‚.unit â–· lâ‚‚ âŠ—â‰« (Î± â–· (râ‚‚ â‰« lâ‚‚) â‰« (lâ‚ â‰« h) â— adjâ‚‚.counit) âŠ—â‰« ğŸ™ _ := by\n        rw [adjâ‚.left_triangle]\n        bicategory\n      _ = ğŸ™ _ âŠ—â‰« g â— (leftZigzag adjâ‚‚.unit adjâ‚‚.counit) âŠ—â‰« Î± âŠ—â‰« ğŸ™ _ := by\n        rw [â† whisker_exchange]\n        bicategory\n      _ = Î± := by\n        rw [adjâ‚‚.left_triangle]\n        bicategory\n  right_inv Î² :=\n    calc\n      _ = ğŸ™ _ âŠ—â‰« râ‚ â— ((ğŸ™ c â‰« g) â— adjâ‚‚.unit â‰« adjâ‚.unit â–· g â–· (lâ‚‚ â‰« râ‚‚)) âŠ—â‰«\n            râ‚ â— lâ‚ â— Î² â–· lâ‚‚ â–· râ‚‚ âŠ—â‰«\n              ((râ‚ â‰« lâ‚) â— h â— adjâ‚‚.counit â‰« adjâ‚.counit â–· (h â‰« ğŸ™ f)) â–· râ‚‚ âŠ—â‰« ğŸ™ _ := by\n        bicategory\n      _ = ğŸ™ _ âŠ—â‰« râ‚ â— (adjâ‚.unit â–· g â–· ğŸ™ e â‰« ((lâ‚ â‰« râ‚) â‰« g) â— adjâ‚‚.unit) âŠ—â‰«\n            ((râ‚ â‰« lâ‚) â— Î² â‰« adjâ‚.counit â–· (h â‰« râ‚‚)) â–· lâ‚‚ â–· râ‚‚ âŠ—â‰«\n              h â— adjâ‚‚.counit â–· râ‚‚ âŠ—â‰« ğŸ™ _ := by\n        rw [whisker_exchange, whisker_exchange]\n        bicategory\n      _ = ğŸ™ _ âŠ—â‰« râ‚ â— g â— adjâ‚‚.unit âŠ—â‰« rightZigzag adjâ‚.unit adjâ‚.counit â–· g â–· lâ‚‚ â–· râ‚‚ âŠ—â‰«\n            Î² â–· lâ‚‚ â–· râ‚‚ âŠ—â‰« h â— adjâ‚‚.counit â–· râ‚‚ âŠ—â‰« ğŸ™ _ := by\n        rw [whisker_exchange, â† whisker_exchange _ adjâ‚‚.unit]\n        bicategory\n      _ = ğŸ™ _ âŠ—â‰« ((râ‚ â‰« g) â— adjâ‚‚.unit â‰« Î² â–· (lâ‚‚ â‰« râ‚‚)) âŠ—â‰« h â— adjâ‚‚.counit â–· râ‚‚ âŠ—â‰« ğŸ™ _ := by\n        rw [adjâ‚.right_triangle]\n        bicategory\n      _ = ğŸ™ _ âŠ—â‰« Î² âŠ—â‰« h â— rightZigzag adjâ‚‚.unit adjâ‚‚.counit âŠ—â‰« ğŸ™ _ := by\n        rw [whisker_exchange]\n        bicategory\n      _ = Î² := by\n        rw [adjâ‚‚.right_triangle]\n        bicategory\n\n"}
{"name":"CategoryTheory.Bicategory.mateEquiv_vcomp","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Mate","initialProofState":"B : Type u\ninstâœ : CategoryTheory.Bicategory B\na b c d e f : B\ngâ‚ : Quiver.Hom a c\ngâ‚‚ : Quiver.Hom c e\nhâ‚ : Quiver.Hom b d\nhâ‚‚ : Quiver.Hom d f\nlâ‚ : Quiver.Hom a b\nrâ‚ : Quiver.Hom b a\nlâ‚‚ : Quiver.Hom c d\nrâ‚‚ : Quiver.Hom d c\nlâ‚ƒ : Quiver.Hom e f\nrâ‚ƒ : Quiver.Hom f e\nadjâ‚ : CategoryTheory.Bicategory.Adjunction lâ‚ râ‚\nadjâ‚‚ : CategoryTheory.Bicategory.Adjunction lâ‚‚ râ‚‚\nadjâ‚ƒ : CategoryTheory.Bicategory.Adjunction lâ‚ƒ râ‚ƒ\nÎ± : Quiver.Hom (CategoryTheory.CategoryStruct.comp gâ‚ lâ‚‚) (CategoryTheory.CategoryStruct.comp lâ‚ hâ‚)\nÎ² : Quiver.Hom (CategoryTheory.CategoryStruct.comp gâ‚‚ lâ‚ƒ) (CategoryTheory.CategoryStruct.comp lâ‚‚ hâ‚‚)\nâŠ¢ Eq ((CategoryTheory.Bicategory.mateEquiv adjâ‚ adjâ‚ƒ) (CategoryTheory.Bicategory.leftAdjointSquare.vcomp Î± Î²)) (CategoryTheory.Bicategory.rightAdjointSquare.vcomp ((CategoryTheory.Bicategory.mateEquiv adjâ‚ adjâ‚‚) Î±) ((CategoryTheory.Bicategory.mateEquiv adjâ‚‚ adjâ‚ƒ) Î²))","decl":"/-- The mates equivalence commutes with vertical composition. -/\ntheorem mateEquiv_vcomp (Î± : gâ‚ â‰« lâ‚‚ âŸ¶ lâ‚ â‰« hâ‚) (Î² : gâ‚‚ â‰« lâ‚ƒ âŸ¶ lâ‚‚ â‰« hâ‚‚) :\n    mateEquiv adjâ‚ adjâ‚ƒ (leftAdjointSquare.vcomp Î± Î²) =\n      rightAdjointSquare.vcomp (mateEquiv adjâ‚ adjâ‚‚ Î±) (mateEquiv adjâ‚‚ adjâ‚ƒ Î²) := by\n  dsimp only [leftAdjointSquare.vcomp, mateEquiv_apply, rightAdjointSquare.vcomp]\n  symm\n  calc\n    _ = ğŸ™ _ âŠ—â‰« râ‚ â— gâ‚ â— adjâ‚‚.unit â–· gâ‚‚ âŠ—â‰« râ‚ â— Î± â–· râ‚‚ â–· gâ‚‚ âŠ—â‰«\n          ((adjâ‚.counit â–· (hâ‚ â‰« râ‚‚ â‰« gâ‚‚ â‰« ğŸ™ e)) â‰« ğŸ™ b â— (hâ‚ â— râ‚‚ â— gâ‚‚ â— adjâ‚ƒ.unit)) âŠ—â‰«\n            hâ‚ â— râ‚‚ â— Î² â–· râ‚ƒ âŠ—â‰« hâ‚ â— adjâ‚‚.counit â–· hâ‚‚ â–· râ‚ƒ âŠ—â‰« ğŸ™ _ := by\n      bicategory\n    _ = ğŸ™ _ âŠ—â‰« râ‚ â— gâ‚ â— adjâ‚‚.unit â–· gâ‚‚ âŠ—â‰«\n          (râ‚ â— (Î± â–· (râ‚‚ â‰« gâ‚‚ â‰« ğŸ™ e) â‰« (lâ‚ â‰« hâ‚) â— râ‚‚ â— gâ‚‚ â— adjâ‚ƒ.unit)) âŠ—â‰«\n            ((adjâ‚.counit â–· (hâ‚ â‰« râ‚‚) â–· (gâ‚‚ â‰« lâ‚ƒ) â‰« (ğŸ™ b â‰« hâ‚ â‰« râ‚‚) â— Î²) â–· râ‚ƒ) âŠ—â‰«\n              hâ‚ â— adjâ‚‚.counit â–· hâ‚‚ â–· râ‚ƒ âŠ—â‰« ğŸ™ _ := by\n      rw [â† whisker_exchange]\n      bicategory\n    _ = ğŸ™ _ âŠ—â‰« râ‚ â— gâ‚ â— (adjâ‚‚.unit â–· (gâ‚‚ â‰« ğŸ™ e) â‰« (lâ‚‚ â‰« râ‚‚) â— gâ‚‚ â— adjâ‚ƒ.unit) âŠ—â‰«\n          (râ‚ â— (Î± â–· (râ‚‚ â‰« gâ‚‚ â‰« lâ‚ƒ) â‰« (lâ‚ â‰« hâ‚) â— râ‚‚ â— Î²) â–· râ‚ƒ) âŠ—â‰«\n            (adjâ‚.counit â–· hâ‚ â–· (râ‚‚ â‰« lâ‚‚) â‰« (ğŸ™ b â‰« hâ‚) â— adjâ‚‚.counit) â–· hâ‚‚ â–· râ‚ƒ âŠ—â‰« ğŸ™ _ := by\n      rw [â† whisker_exchange, â† whisker_exchange]\n      bicategory\n    _ = ğŸ™ _ âŠ—â‰« râ‚ â— gâ‚ â— gâ‚‚ â— adjâ‚ƒ.unit âŠ—â‰«\n          râ‚ â— gâ‚ â— (adjâ‚‚.unit â–· (gâ‚‚ â‰« lâ‚ƒ) â‰« (lâ‚‚ â‰« râ‚‚) â— Î²) â–· râ‚ƒ âŠ—â‰«\n            râ‚ â— (Î± â–· (râ‚‚ â‰« lâ‚‚) â‰« (lâ‚ â‰« hâ‚) â— adjâ‚‚.counit) â–· hâ‚‚ â–· râ‚ƒ âŠ—â‰«\n              adjâ‚.counit â–· hâ‚ â–· hâ‚‚ â–· râ‚ƒ âŠ—â‰« ğŸ™ _ := by\n      rw [â† whisker_exchange, â† whisker_exchange, â† whisker_exchange]\n      bicategory\n    _ = ğŸ™ _ âŠ—â‰« râ‚ â— gâ‚ â— gâ‚‚ â— adjâ‚ƒ.unit âŠ—â‰« râ‚ â— gâ‚ â— Î² â–· râ‚ƒ âŠ—â‰«\n          ((râ‚ â‰« gâ‚) â— leftZigzag adjâ‚‚.unit adjâ‚‚.counit â–· (hâ‚‚ â‰« râ‚ƒ)) âŠ—â‰«\n            râ‚ â— Î± â–· hâ‚‚ â–· râ‚ƒ âŠ—â‰« adjâ‚.counit â–· hâ‚ â–· hâ‚‚ â–· râ‚ƒ âŠ—â‰« ğŸ™ _ := by\n      rw [â† whisker_exchange, â† whisker_exchange]\n      bicategory\n    _ = _ := by\n      rw [adjâ‚‚.left_triangle]\n      bicategory\n\n"}
{"name":"CategoryTheory.Bicategory.mateEquiv_hcomp","module":"Mathlib.CategoryTheory.Bicategory.Adjunction.Mate","initialProofState":"B : Type u\ninstâœ : CategoryTheory.Bicategory B\na b c d e f : B\ng : Quiver.Hom a d\nh : Quiver.Hom b e\nk : Quiver.Hom c f\nlâ‚ : Quiver.Hom a b\nrâ‚ : Quiver.Hom b a\nlâ‚‚ : Quiver.Hom d e\nrâ‚‚ : Quiver.Hom e d\nlâ‚ƒ : Quiver.Hom b c\nrâ‚ƒ : Quiver.Hom c b\nlâ‚„ : Quiver.Hom e f\nrâ‚„ : Quiver.Hom f e\nadjâ‚ : CategoryTheory.Bicategory.Adjunction lâ‚ râ‚\nadjâ‚‚ : CategoryTheory.Bicategory.Adjunction lâ‚‚ râ‚‚\nadjâ‚ƒ : CategoryTheory.Bicategory.Adjunction lâ‚ƒ râ‚ƒ\nadjâ‚„ : CategoryTheory.Bicategory.Adjunction lâ‚„ râ‚„\nÎ± : Quiver.Hom (CategoryTheory.CategoryStruct.comp g lâ‚‚) (CategoryTheory.CategoryStruct.comp lâ‚ h)\nÎ² : Quiver.Hom (CategoryTheory.CategoryStruct.comp h lâ‚„) (CategoryTheory.CategoryStruct.comp lâ‚ƒ k)\nâŠ¢ Eq ((CategoryTheory.Bicategory.mateEquiv (adjâ‚.comp adjâ‚ƒ) (adjâ‚‚.comp adjâ‚„)) (CategoryTheory.Bicategory.leftAdjointSquare.hcomp Î± Î²)) (CategoryTheory.Bicategory.rightAdjointSquare.hcomp ((CategoryTheory.Bicategory.mateEquiv adjâ‚ adjâ‚‚) Î±) ((CategoryTheory.Bicategory.mateEquiv adjâ‚ƒ adjâ‚„) Î²))","decl":"/-- The mates equivalence commutes with horizontal composition of squares. -/\ntheorem mateEquiv_hcomp (Î± : g â‰« lâ‚‚ âŸ¶ lâ‚ â‰« h) (Î² : h â‰« lâ‚„ âŸ¶ lâ‚ƒ â‰« k) :\n    (mateEquiv (adjâ‚.comp adjâ‚ƒ) (adjâ‚‚.comp adjâ‚„)) (leftAdjointSquare.hcomp Î± Î²) =\n      rightAdjointSquare.hcomp (mateEquiv adjâ‚ adjâ‚‚ Î±) (mateEquiv adjâ‚ƒ adjâ‚„ Î²) := by\n  dsimp [mateEquiv, leftAdjointSquare.hcomp, rightAdjointSquare.hcomp]\n  calc\n    _ = ğŸ™ _ âŠ—â‰« râ‚ƒ â— râ‚ â— g â— adjâ‚‚.unit âŠ—â‰«\n          râ‚ƒ â— râ‚ â— ((g â‰« lâ‚‚) â— adjâ‚„.unit â‰« Î± â–· (lâ‚„ â‰« râ‚„)) â–· râ‚‚ âŠ—â‰«\n            râ‚ƒ â— ((râ‚ â‰« lâ‚) â— Î² â‰« adjâ‚.counit â–· (lâ‚ƒ â‰« k)) â–· râ‚„ â–· râ‚‚ âŠ—â‰«\n              adjâ‚ƒ.counit â–· k â–· râ‚„ â–· râ‚‚ âŠ—â‰« ğŸ™ _ := by\n      bicategory\n    _ = ğŸ™ _ âŠ—â‰« râ‚ƒ â— râ‚ â— g â— adjâ‚‚.unit âŠ—â‰« râ‚ƒ â— râ‚ â— Î± â–· râ‚‚ âŠ—â‰«\n          râ‚ƒ â— ((râ‚ â‰« lâ‚) â— h â— adjâ‚„.unit â‰« adjâ‚.counit â–· (h â‰« lâ‚„ â‰« râ‚„)) â–· râ‚‚ âŠ—â‰«\n            râ‚ƒ â— Î² â–· râ‚„ â–· râ‚‚ âŠ—â‰« adjâ‚ƒ.counit â–· k â–· râ‚„ â–· râ‚‚ âŠ—â‰« ğŸ™ _ := by\n      rw [whisker_exchange, whisker_exchange]\n      bicategory\n    _ = _ := by\n      rw [whisker_exchange]\n      bicategory\n\n"}
