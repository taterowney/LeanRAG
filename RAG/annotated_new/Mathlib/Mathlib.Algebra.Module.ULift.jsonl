{"name":"ULift.smul_def","module":"Mathlib.Algebra.Module.ULift","initialProofState":"R : Type u\nM : Type v\ninst✝ : SMul R M\ns : ULift.{u_1, u} R\nx : M\n⊢ Eq (HSMul.hSMul s x) (HSMul.hSMul s.down x)","decl":"@[to_additive (attr := simp)]\ntheorem smul_def [SMul R M] (s : ULift R) (x : M) : s • x = s.down • x :=\n  rfl\n\n"}
{"name":"ULift.vadd_def","module":"Mathlib.Algebra.Module.ULift","initialProofState":"R : Type u\nM : Type v\ninst✝ : VAdd R M\ns : ULift.{u_1, u} R\nx : M\n⊢ Eq (HVAdd.hVAdd s x) (HVAdd.hVAdd s.down x)","decl":"@[to_additive (attr := simp)]\ntheorem smul_def [SMul R M] (s : ULift R) (x : M) : s • x = s.down • x :=\n  rfl\n\n"}
{"name":"ULift.isScalarTower","module":"Mathlib.Algebra.Module.ULift","initialProofState":"R : Type u\nM : Type v\nN : Type w\ninst✝³ : SMul R M\ninst✝² : SMul M N\ninst✝¹ : SMul R N\ninst✝ : IsScalarTower R M N\n⊢ IsScalarTower (ULift.{u_1, u} R) M N","decl":"instance isScalarTower [SMul R M] [SMul M N] [SMul R N] [IsScalarTower R M N] :\n    IsScalarTower (ULift R) M N :=\n  ⟨fun x y z => show (x.down • y) • z = x.down • y • z from smul_assoc _ _ _⟩\n\n"}
{"name":"ULift.isScalarTower'","module":"Mathlib.Algebra.Module.ULift","initialProofState":"R : Type u\nM : Type v\nN : Type w\ninst✝³ : SMul R M\ninst✝² : SMul M N\ninst✝¹ : SMul R N\ninst✝ : IsScalarTower R M N\n⊢ IsScalarTower R (ULift.{u_1, v} M) N","decl":"instance isScalarTower' [SMul R M] [SMul M N] [SMul R N] [IsScalarTower R M N] :\n    IsScalarTower R (ULift M) N :=\n  ⟨fun x y z => show (x • y.down) • z = x • y.down • z from smul_assoc _ _ _⟩\n\n"}
{"name":"ULift.isScalarTower''","module":"Mathlib.Algebra.Module.ULift","initialProofState":"R : Type u\nM : Type v\nN : Type w\ninst✝³ : SMul R M\ninst✝² : SMul M N\ninst✝¹ : SMul R N\ninst✝ : IsScalarTower R M N\n⊢ IsScalarTower R M (ULift.{u_1, w} N)","decl":"instance isScalarTower'' [SMul R M] [SMul M N] [SMul R N] [IsScalarTower R M N] :\n    IsScalarTower R M (ULift N) :=\n  ⟨fun x y z => show up ((x • y) • z.down) = ⟨x • y • z.down⟩ by rw [smul_assoc]⟩\n\n"}
{"name":"ULift.instIsCentralScalar","module":"Mathlib.Algebra.Module.ULift","initialProofState":"R : Type u\nM : Type v\ninst✝² : SMul R M\ninst✝¹ : SMul (MulOpposite R) M\ninst✝ : IsCentralScalar R M\n⊢ IsCentralScalar R (ULift.{u_1, v} M)","decl":"instance [SMul R M] [SMul Rᵐᵒᵖ M] [IsCentralScalar R M] : IsCentralScalar R (ULift M) :=\n  ⟨fun r m => congr_arg up <| op_smul_eq_smul r m.down⟩\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO this takes way longer to elaborate than it should\n"}
{"name":"ULift.moduleEquiv_apply","module":"Mathlib.Algebra.Module.ULift","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nself : ULift.{w, v} M\n⊢ Eq (ULift.moduleEquiv self) self.down","decl":"/-- The `R`-linear equivalence between `ULift M` and `M`.\n\nThis is a linear version of `AddEquiv.ulift`. -/\n@[simps apply symm_apply]\ndef moduleEquiv [Semiring R] [AddCommMonoid M] [Module R M] : ULift.{w} M ≃ₗ[R] M where\n  toFun := ULift.down\n  invFun := ULift.up\n  map_smul' _ _ := rfl\n  __ := AddEquiv.ulift\n\n"}
{"name":"ULift.moduleEquiv_symm_apply","module":"Mathlib.Algebra.Module.ULift","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ndown : M\n⊢ Eq (ULift.moduleEquiv.symm down) { down := down }","decl":"/-- The `R`-linear equivalence between `ULift M` and `M`.\n\nThis is a linear version of `AddEquiv.ulift`. -/\n@[simps apply symm_apply]\ndef moduleEquiv [Semiring R] [AddCommMonoid M] [Module R M] : ULift.{w} M ≃ₗ[R] M where\n  toFun := ULift.down\n  invFun := ULift.up\n  map_smul' _ _ := rfl\n  __ := AddEquiv.ulift\n\n"}
