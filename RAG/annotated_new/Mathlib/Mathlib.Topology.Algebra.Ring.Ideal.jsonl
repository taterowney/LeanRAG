{"name":"Ideal.coe_closure","module":"Mathlib.Topology.Algebra.Ring.Ideal","initialProofState":"R : Type u_1\ninst✝² : TopologicalSpace R\ninst✝¹ : Ring R\ninst✝ : TopologicalRing R\nI : Ideal R\n⊢ Eq (↑I.closure) (closure ↑I)","decl":"@[simp]\ntheorem Ideal.coe_closure (I : Ideal R) : (I.closure : Set R) = closure I :=\n  rfl\n\n-- Porting note: removed `@[simp]` because we make the instance argument explicit since otherwise\n-- it causes timeouts as `simp` tries and fails to generated an `IsClosed` instance.\n-- https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/!4.234852.20heartbeats.20of.20the.20linter\n"}
{"name":"Ideal.closure_eq_of_isClosed","module":"Mathlib.Topology.Algebra.Ring.Ideal","initialProofState":"R : Type u_1\ninst✝² : TopologicalSpace R\ninst✝¹ : Ring R\ninst✝ : TopologicalRing R\nI : Ideal R\nhI : IsClosed ↑I\n⊢ Eq I.closure I","decl":"theorem Ideal.closure_eq_of_isClosed (I : Ideal R) (hI : IsClosed (I : Set R)) : I.closure = I :=\n  SetLike.ext' hI.closure_eq\n\n"}
{"name":"QuotientRing.isOpenMap_coe","module":"Mathlib.Topology.Algebra.Ring.Ideal","initialProofState":"R : Type u_1\ninst✝² : TopologicalSpace R\ninst✝¹ : CommRing R\nN : Ideal R\ninst✝ : TopologicalRing R\n⊢ IsOpenMap ⇑(Ideal.Quotient.mk N)","decl":"theorem QuotientRing.isOpenMap_coe : IsOpenMap (mk N) :=\n  QuotientAddGroup.isOpenMap_coe\n\n"}
{"name":"QuotientRing.isOpenQuotientMap_mk","module":"Mathlib.Topology.Algebra.Ring.Ideal","initialProofState":"R : Type u_1\ninst✝² : TopologicalSpace R\ninst✝¹ : CommRing R\nN : Ideal R\ninst✝ : TopologicalRing R\n⊢ IsOpenQuotientMap ⇑(Ideal.Quotient.mk N)","decl":"theorem QuotientRing.isOpenQuotientMap_mk : IsOpenQuotientMap (mk N) :=\n  QuotientAddGroup.isOpenQuotientMap_mk\n\n"}
{"name":"QuotientRing.isQuotientMap_coe_coe","module":"Mathlib.Topology.Algebra.Ring.Ideal","initialProofState":"R : Type u_1\ninst✝² : TopologicalSpace R\ninst✝¹ : CommRing R\nN : Ideal R\ninst✝ : TopologicalRing R\n⊢ Topology.IsQuotientMap fun p => { fst := (Ideal.Quotient.mk N) p.1, snd := (Ideal.Quotient.mk N) p.2 }","decl":"theorem QuotientRing.isQuotientMap_coe_coe : IsQuotientMap fun p : R × R => (mk N p.1, mk N p.2) :=\n  ((isOpenQuotientMap_mk N).prodMap (isOpenQuotientMap_mk N)).isQuotientMap\n\n"}
{"name":"QuotientRing.quotientMap_coe_coe","module":"Mathlib.Topology.Algebra.Ring.Ideal","initialProofState":"R : Type u_1\ninst✝² : TopologicalSpace R\ninst✝¹ : CommRing R\nN : Ideal R\ninst✝ : TopologicalRing R\n⊢ Topology.IsQuotientMap fun p => { fst := (Ideal.Quotient.mk N) p.1, snd := (Ideal.Quotient.mk N) p.2 }","decl":"@[deprecated (since := \"2024-10-22\")]\nalias QuotientRing.quotientMap_coe_coe := QuotientRing.isQuotientMap_coe_coe\n\n"}
{"name":"topologicalRing_quotient","module":"Mathlib.Topology.Algebra.Ring.Ideal","initialProofState":"R : Type u_1\ninst✝² : TopologicalSpace R\ninst✝¹ : CommRing R\nN : Ideal R\ninst✝ : TopologicalRing R\n⊢ TopologicalRing (HasQuotient.Quotient R N)","decl":"instance topologicalRing_quotient : TopologicalRing (R ⧸ N) where\n  __ := QuotientAddGroup.instTopologicalAddGroup _\n  continuous_mul := (QuotientRing.isQuotientMap_coe_coe N).continuous_iff.2 <|\n    continuous_quot_mk.comp continuous_mul\n\n"}
