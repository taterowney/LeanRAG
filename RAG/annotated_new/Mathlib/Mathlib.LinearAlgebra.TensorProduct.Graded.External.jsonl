{"name":"TensorProduct.gradedCommAux_lof_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\ninstâœâ· : CommSemiring Î¹\ninstâœâ¶ : Module Î¹ (Additive (Units Int))\ninstâœâµ : DecidableEq Î¹\nğ’œ : Î¹ â†’ Type u_3\nâ„¬ : Î¹ â†’ Type u_4\ninstâœâ´ : CommRing R\ninstâœÂ³ : (i : Î¹) â†’ AddCommGroup (ğ’œ i)\ninstâœÂ² : (i : Î¹) â†’ AddCommGroup (â„¬ i)\ninstâœÂ¹ : (i : Î¹) â†’ Module R (ğ’œ i)\ninstâœ : (i : Î¹) â†’ Module R (â„¬ i)\ni j : Î¹\na : ğ’œ i\nb : â„¬ j\nâŠ¢ Eq ((TensorProduct.gradedCommAux R ğ’œ â„¬) ((DirectSum.lof R (Prod Î¹ Î¹) (fun i => TensorProduct R (ğ’œ i.1) (â„¬ i.2)) { fst := i, snd := j }) (TensorProduct.tmul R a b))) (HSMul.hSMul (HPow.hPow (-1) (HMul.hMul j i)) ((DirectSum.lof R (Prod Î¹ Î¹) (fun i => TensorProduct R (â„¬ i.1) (ğ’œ i.2)) { fst := j, snd := i }) (TensorProduct.tmul R b a)))","decl":"@[simp]\ntheorem gradedCommAux_lof_tmul (i j : Î¹) (a : ğ’œ i) (b : â„¬ j) :\n    gradedCommAux R ğ’œ â„¬ (lof R _ ğ’œâ„¬ (i, j) (a âŠ—â‚œ b)) =\n      (-1 : â„¤Ë£)^(j * i) â€¢ lof R _ â„¬ğ’œ (j, i) (b âŠ—â‚œ a) := by\n  rw [gradedCommAux]\n  dsimp\n  simp [mul_comm i j]\n\n"}
{"name":"TensorProduct.gradedCommAux_comp_gradedCommAux","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\ninstâœâ· : CommSemiring Î¹\ninstâœâ¶ : Module Î¹ (Additive (Units Int))\ninstâœâµ : DecidableEq Î¹\nğ’œ : Î¹ â†’ Type u_3\nâ„¬ : Î¹ â†’ Type u_4\ninstâœâ´ : CommRing R\ninstâœÂ³ : (i : Î¹) â†’ AddCommGroup (ğ’œ i)\ninstâœÂ² : (i : Î¹) â†’ AddCommGroup (â„¬ i)\ninstâœÂ¹ : (i : Î¹) â†’ Module R (ğ’œ i)\ninstâœ : (i : Î¹) â†’ Module R (â„¬ i)\nâŠ¢ Eq ((TensorProduct.gradedCommAux R ğ’œ â„¬).comp (TensorProduct.gradedCommAux R â„¬ ğ’œ)) LinearMap.id","decl":"@[simp]\ntheorem gradedCommAux_comp_gradedCommAux :\n    gradedCommAux R ğ’œ â„¬ âˆ˜â‚— gradedCommAux R â„¬ ğ’œ = LinearMap.id := by\n  ext i a b\n  dsimp\n  rw [gradedCommAux_lof_tmul, LinearMap.map_smul_of_tower, gradedCommAux_lof_tmul, smul_smul,\n    mul_comm i.2 i.1, Int.units_mul_self, one_smul]\n\n"}
{"name":"TensorProduct.gradedComm_symm","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\ninstâœâ· : CommSemiring Î¹\ninstâœâ¶ : Module Î¹ (Additive (Units Int))\ninstâœâµ : DecidableEq Î¹\nğ’œ : Î¹ â†’ Type u_3\nâ„¬ : Î¹ â†’ Type u_4\ninstâœâ´ : CommRing R\ninstâœÂ³ : (i : Î¹) â†’ AddCommGroup (ğ’œ i)\ninstâœÂ² : (i : Î¹) â†’ AddCommGroup (â„¬ i)\ninstâœÂ¹ : (i : Î¹) â†’ Module R (ğ’œ i)\ninstâœ : (i : Î¹) â†’ Module R (â„¬ i)\nâŠ¢ Eq (TensorProduct.gradedComm R ğ’œ â„¬).symm (TensorProduct.gradedComm R â„¬ ğ’œ)","decl":"/-- The braiding is symmetric. -/\n@[simp]\ntheorem gradedComm_symm : (gradedComm R ğ’œ â„¬).symm = gradedComm R â„¬ ğ’œ := by\n  rw [gradedComm, gradedComm, LinearEquiv.trans_symm, LinearEquiv.symm_symm]\n  ext\n  rfl\n\n"}
{"name":"TensorProduct.gradedComm_of_tmul_of","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\ninstâœâ· : CommSemiring Î¹\ninstâœâ¶ : Module Î¹ (Additive (Units Int))\ninstâœâµ : DecidableEq Î¹\nğ’œ : Î¹ â†’ Type u_3\nâ„¬ : Î¹ â†’ Type u_4\ninstâœâ´ : CommRing R\ninstâœÂ³ : (i : Î¹) â†’ AddCommGroup (ğ’œ i)\ninstâœÂ² : (i : Î¹) â†’ AddCommGroup (â„¬ i)\ninstâœÂ¹ : (i : Î¹) â†’ Module R (ğ’œ i)\ninstâœ : (i : Î¹) â†’ Module R (â„¬ i)\ni j : Î¹\na : ğ’œ i\nb : â„¬ j\nâŠ¢ Eq ((TensorProduct.gradedComm R ğ’œ â„¬) (TensorProduct.tmul R ((DirectSum.lof R Î¹ ğ’œ i) a) ((DirectSum.lof R Î¹ â„¬ j) b))) (HSMul.hSMul (HPow.hPow (-1) (HMul.hMul j i)) (TensorProduct.tmul R ((DirectSum.lof R Î¹ â„¬ j) b) ((DirectSum.lof R Î¹ ğ’œ i) a)))","decl":"theorem gradedComm_of_tmul_of (i j : Î¹) (a : ğ’œ i) (b : â„¬ j) :\n    gradedComm R ğ’œ â„¬ (lof R _ ğ’œ i a âŠ—â‚œ lof R _ â„¬ j b) =\n      (-1 : â„¤Ë£)^(j * i) â€¢ (lof R _ â„¬ _ b âŠ—â‚œ lof R _ ğ’œ _ a) := by\n  rw [gradedComm]\n  dsimp only [LinearEquiv.trans_apply, LinearEquiv.ofLinear_apply]\n  rw [TensorProduct.directSum_lof_tmul_lof, gradedCommAux_lof_tmul, Units.smul_def,\n    -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 specialized `map_smul` to `LinearEquiv.map_smul` to avoid timeouts.\n    â† Int.cast_smul_eq_zsmul R, LinearEquiv.map_smul, TensorProduct.directSum_symm_lof_tmul,\n    Int.cast_smul_eq_zsmul, â† Units.smul_def]\n\n"}
{"name":"TensorProduct.gradedComm_tmul_of_zero","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\ninstâœâ· : CommSemiring Î¹\ninstâœâ¶ : Module Î¹ (Additive (Units Int))\ninstâœâµ : DecidableEq Î¹\nğ’œ : Î¹ â†’ Type u_3\nâ„¬ : Î¹ â†’ Type u_4\ninstâœâ´ : CommRing R\ninstâœÂ³ : (i : Î¹) â†’ AddCommGroup (ğ’œ i)\ninstâœÂ² : (i : Î¹) â†’ AddCommGroup (â„¬ i)\ninstâœÂ¹ : (i : Î¹) â†’ Module R (ğ’œ i)\ninstâœ : (i : Î¹) â†’ Module R (â„¬ i)\na : DirectSum Î¹ fun i => ğ’œ i\nb : â„¬ 0\nâŠ¢ Eq ((TensorProduct.gradedComm R ğ’œ â„¬) (TensorProduct.tmul R a ((DirectSum.lof R Î¹ â„¬ 0) b))) (TensorProduct.tmul R ((DirectSum.lof R Î¹ â„¬ 0) b) a)","decl":"theorem gradedComm_tmul_of_zero (a : â¨ i, ğ’œ i) (b : â„¬ 0) :\n    gradedComm R ğ’œ â„¬ (a âŠ—â‚œ lof R _ â„¬ 0 b) = lof R _ â„¬ _ b âŠ—â‚œ a := by\n  suffices\n    (gradedComm R ğ’œ â„¬).toLinearMap âˆ˜â‚—\n        (TensorProduct.mk R (â¨ i, ğ’œ i) (â¨ i, â„¬ i)).flip (lof R _ â„¬ 0 b) =\n      TensorProduct.mk R _ _ (lof R _ â„¬ 0 b) from\n    DFunLike.congr_fun this a\n  ext i a\n  dsimp\n  rw [gradedComm_of_tmul_of, zero_mul, uzpow_zero, one_smul]\n\n"}
{"name":"TensorProduct.gradedComm_of_zero_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\ninstâœâ· : CommSemiring Î¹\ninstâœâ¶ : Module Î¹ (Additive (Units Int))\ninstâœâµ : DecidableEq Î¹\nğ’œ : Î¹ â†’ Type u_3\nâ„¬ : Î¹ â†’ Type u_4\ninstâœâ´ : CommRing R\ninstâœÂ³ : (i : Î¹) â†’ AddCommGroup (ğ’œ i)\ninstâœÂ² : (i : Î¹) â†’ AddCommGroup (â„¬ i)\ninstâœÂ¹ : (i : Î¹) â†’ Module R (ğ’œ i)\ninstâœ : (i : Î¹) â†’ Module R (â„¬ i)\na : ğ’œ 0\nb : DirectSum Î¹ fun i => â„¬ i\nâŠ¢ Eq ((TensorProduct.gradedComm R ğ’œ â„¬) (TensorProduct.tmul R ((DirectSum.lof R Î¹ ğ’œ 0) a) b)) (TensorProduct.tmul R b ((DirectSum.lof R Î¹ ğ’œ 0) a))","decl":"theorem gradedComm_of_zero_tmul (a : ğ’œ 0) (b : â¨ i, â„¬ i) :\n    gradedComm R ğ’œ â„¬ (lof R _ ğ’œ 0 a âŠ—â‚œ b) = b âŠ—â‚œ lof R _ ğ’œ _ a := by\n  suffices\n    (gradedComm R ğ’œ â„¬).toLinearMap âˆ˜â‚— (TensorProduct.mk R (â¨ i, ğ’œ i) (â¨ i, â„¬ i)) (lof R _ ğ’œ 0 a) =\n      (TensorProduct.mk R _ _).flip (lof R _ ğ’œ 0 a) from\n    DFunLike.congr_fun this b\n  ext i b\n  dsimp\n  rw [gradedComm_of_tmul_of, mul_zero, uzpow_zero, one_smul]\n\n"}
{"name":"TensorProduct.gradedComm_tmul_one","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\ninstâœâ¸ : CommSemiring Î¹\ninstâœâ· : Module Î¹ (Additive (Units Int))\ninstâœâ¶ : DecidableEq Î¹\nğ’œ : Î¹ â†’ Type u_3\nâ„¬ : Î¹ â†’ Type u_4\ninstâœâµ : CommRing R\ninstâœâ´ : (i : Î¹) â†’ AddCommGroup (ğ’œ i)\ninstâœÂ³ : (i : Î¹) â†’ AddCommGroup (â„¬ i)\ninstâœÂ² : (i : Î¹) â†’ Module R (ğ’œ i)\ninstâœÂ¹ : (i : Î¹) â†’ Module R (â„¬ i)\ninstâœ : DirectSum.GRing â„¬\na : DirectSum Î¹ fun i => ğ’œ i\nâŠ¢ Eq ((TensorProduct.gradedComm R ğ’œ â„¬) (TensorProduct.tmul R a 1)) (TensorProduct.tmul R 1 a)","decl":"theorem gradedComm_tmul_one [DirectSum.GRing â„¬] (a : â¨ i, ğ’œ i) :\n    gradedComm R ğ’œ â„¬ (a âŠ—â‚œ 1) = 1 âŠ—â‚œ a :=\n  gradedComm_tmul_of_zero _ _ _ _ _\n\n"}
{"name":"TensorProduct.gradedComm_one_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\ninstâœâ¸ : CommSemiring Î¹\ninstâœâ· : Module Î¹ (Additive (Units Int))\ninstâœâ¶ : DecidableEq Î¹\nğ’œ : Î¹ â†’ Type u_3\nâ„¬ : Î¹ â†’ Type u_4\ninstâœâµ : CommRing R\ninstâœâ´ : (i : Î¹) â†’ AddCommGroup (ğ’œ i)\ninstâœÂ³ : (i : Î¹) â†’ AddCommGroup (â„¬ i)\ninstâœÂ² : (i : Î¹) â†’ Module R (ğ’œ i)\ninstâœÂ¹ : (i : Î¹) â†’ Module R (â„¬ i)\ninstâœ : DirectSum.GRing ğ’œ\nb : DirectSum Î¹ fun i => â„¬ i\nâŠ¢ Eq ((TensorProduct.gradedComm R ğ’œ â„¬) (TensorProduct.tmul R 1 b)) (TensorProduct.tmul R b 1)","decl":"theorem gradedComm_one_tmul [DirectSum.GRing ğ’œ] (b : â¨ i, â„¬ i) :\n    gradedComm R ğ’œ â„¬ (1 âŠ—â‚œ b) = b âŠ—â‚œ 1 :=\n  gradedComm_of_zero_tmul _ _ _ _ _\n\n"}
{"name":"TensorProduct.gradedComm_one","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\ninstâœâ¹ : CommSemiring Î¹\ninstâœâ¸ : Module Î¹ (Additive (Units Int))\ninstâœâ· : DecidableEq Î¹\nğ’œ : Î¹ â†’ Type u_3\nâ„¬ : Î¹ â†’ Type u_4\ninstâœâ¶ : CommRing R\ninstâœâµ : (i : Î¹) â†’ AddCommGroup (ğ’œ i)\ninstâœâ´ : (i : Î¹) â†’ AddCommGroup (â„¬ i)\ninstâœÂ³ : (i : Î¹) â†’ Module R (ğ’œ i)\ninstâœÂ² : (i : Î¹) â†’ Module R (â„¬ i)\ninstâœÂ¹ : DirectSum.GRing ğ’œ\ninstâœ : DirectSum.GRing â„¬\nâŠ¢ Eq ((TensorProduct.gradedComm R ğ’œ â„¬) 1) 1","decl":"@[simp, nolint simpNF] -- linter times out\ntheorem gradedComm_one [DirectSum.GRing ğ’œ] [DirectSum.GRing â„¬] : gradedComm R ğ’œ â„¬ 1 = 1 :=\n  gradedComm_one_tmul _ _ _ _\n\n"}
{"name":"TensorProduct.gradedComm_tmul_algebraMap","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\ninstâœâ¹ : CommSemiring Î¹\ninstâœâ¸ : Module Î¹ (Additive (Units Int))\ninstâœâ· : DecidableEq Î¹\nğ’œ : Î¹ â†’ Type u_3\nâ„¬ : Î¹ â†’ Type u_4\ninstâœâ¶ : CommRing R\ninstâœâµ : (i : Î¹) â†’ AddCommGroup (ğ’œ i)\ninstâœâ´ : (i : Î¹) â†’ AddCommGroup (â„¬ i)\ninstâœÂ³ : (i : Î¹) â†’ Module R (ğ’œ i)\ninstâœÂ² : (i : Î¹) â†’ Module R (â„¬ i)\ninstâœÂ¹ : DirectSum.GRing â„¬\ninstâœ : DirectSum.GAlgebra R â„¬\na : DirectSum Î¹ fun i => ğ’œ i\nr : R\nâŠ¢ Eq ((TensorProduct.gradedComm R ğ’œ â„¬) (TensorProduct.tmul R a ((algebraMap R (DirectSum Î¹ fun i => â„¬ i)) r))) (TensorProduct.tmul R ((algebraMap R (DirectSum Î¹ fun i => â„¬ i)) r) a)","decl":"theorem gradedComm_tmul_algebraMap [DirectSum.GRing â„¬] [DirectSum.GAlgebra R â„¬]\n    (a : â¨ i, ğ’œ i) (r : R) :\n    gradedComm R ğ’œ â„¬ (a âŠ—â‚œ algebraMap R _ r) = algebraMap R _ r âŠ—â‚œ a :=\n  gradedComm_tmul_of_zero _ _ _ _ _\n\n"}
{"name":"TensorProduct.gradedComm_algebraMap_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\ninstâœâ¹ : CommSemiring Î¹\ninstâœâ¸ : Module Î¹ (Additive (Units Int))\ninstâœâ· : DecidableEq Î¹\nğ’œ : Î¹ â†’ Type u_3\nâ„¬ : Î¹ â†’ Type u_4\ninstâœâ¶ : CommRing R\ninstâœâµ : (i : Î¹) â†’ AddCommGroup (ğ’œ i)\ninstâœâ´ : (i : Î¹) â†’ AddCommGroup (â„¬ i)\ninstâœÂ³ : (i : Î¹) â†’ Module R (ğ’œ i)\ninstâœÂ² : (i : Î¹) â†’ Module R (â„¬ i)\ninstâœÂ¹ : DirectSum.GRing ğ’œ\ninstâœ : DirectSum.GAlgebra R ğ’œ\nr : R\nb : DirectSum Î¹ fun i => â„¬ i\nâŠ¢ Eq ((TensorProduct.gradedComm R ğ’œ â„¬) (TensorProduct.tmul R ((algebraMap R (DirectSum Î¹ fun i => ğ’œ i)) r) b)) (TensorProduct.tmul R b ((algebraMap R (DirectSum Î¹ fun i => ğ’œ i)) r))","decl":"theorem gradedComm_algebraMap_tmul [DirectSum.GRing ğ’œ] [DirectSum.GAlgebra R ğ’œ]\n    (r : R) (b : â¨ i, â„¬ i) :\n    gradedComm R ğ’œ â„¬ (algebraMap R _ r âŠ—â‚œ b) = b âŠ—â‚œ algebraMap R _ r :=\n  gradedComm_of_zero_tmul _ _ _ _ _\n\n"}
{"name":"TensorProduct.gradedComm_algebraMap","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\ninstâœÂ¹Â¹ : CommSemiring Î¹\ninstâœÂ¹â° : Module Î¹ (Additive (Units Int))\ninstâœâ¹ : DecidableEq Î¹\nğ’œ : Î¹ â†’ Type u_3\nâ„¬ : Î¹ â†’ Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : (i : Î¹) â†’ AddCommGroup (ğ’œ i)\ninstâœâ¶ : (i : Î¹) â†’ AddCommGroup (â„¬ i)\ninstâœâµ : (i : Î¹) â†’ Module R (ğ’œ i)\ninstâœâ´ : (i : Î¹) â†’ Module R (â„¬ i)\ninstâœÂ³ : DirectSum.GRing ğ’œ\ninstâœÂ² : DirectSum.GRing â„¬\ninstâœÂ¹ : DirectSum.GAlgebra R ğ’œ\ninstâœ : DirectSum.GAlgebra R â„¬\nr : R\nâŠ¢ Eq ((TensorProduct.gradedComm R ğ’œ â„¬) ((algebraMap R (TensorProduct R (DirectSum Î¹ fun i => ğ’œ i) (DirectSum Î¹ fun i => â„¬ i))) r)) ((algebraMap R (TensorProduct R (DirectSum Î¹ fun i => â„¬ i) (DirectSum Î¹ fun i => ğ’œ i))) r)","decl":"theorem gradedComm_algebraMap [DirectSum.GRing ğ’œ] [DirectSum.GRing â„¬]\n    [DirectSum.GAlgebra R ğ’œ] [DirectSum.GAlgebra R â„¬] (r : R) :\n    gradedComm R ğ’œ â„¬ (algebraMap R _ r) = algebraMap R _ r :=\n  (gradedComm_algebraMap_tmul R ğ’œ â„¬ r 1).trans (Algebra.TensorProduct.algebraMap_apply' r).symm\n\n"}
{"name":"TensorProduct.gradedMul_def","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_5\nÎ¹ : Type u_6\ninstâœÂ¹Â¹ : CommSemiring Î¹\ninstâœÂ¹â° : Module Î¹ (Additive (Units Int))\ninstâœâ¹ : DecidableEq Î¹\nğ’œ : Î¹ â†’ Type u_7\nâ„¬ : Î¹ â†’ Type u_8\ninstâœâ¸ : CommRing R\ninstâœâ· : (i : Î¹) â†’ AddCommGroup (ğ’œ i)\ninstâœâ¶ : (i : Î¹) â†’ AddCommGroup (â„¬ i)\ninstâœâµ : (i : Î¹) â†’ Module R (ğ’œ i)\ninstâœâ´ : (i : Î¹) â†’ Module R (â„¬ i)\ninstâœÂ³ : DirectSum.GRing ğ’œ\ninstâœÂ² : DirectSum.GRing â„¬\ninstâœÂ¹ : DirectSum.GAlgebra R ğ’œ\ninstâœ : DirectSum.GAlgebra R â„¬\nâŠ¢ Eq (TensorProduct.gradedMul R ğ’œ â„¬) (TensorProduct.curry ((TensorProduct.map (LinearMap.mul' R (DirectSum Î¹ fun i => ğ’œ i)) (LinearMap.mul' R (DirectSum Î¹ fun i => â„¬ i))).comp ((â†‘(TensorProduct.assoc R (DirectSum Î¹ fun i => ğ’œ i) (DirectSum Î¹ fun i => ğ’œ i) (TensorProduct R (DirectSum Î¹ fun i => â„¬ i) (DirectSum Î¹ fun i => â„¬ i))).symm).comp ((LinearMap.lTensor (DirectSum Î¹ fun i => ğ’œ i) ((â†‘(TensorProduct.assoc R (DirectSum Î¹ fun i => ğ’œ i) (DirectSum Î¹ fun i => â„¬ i) (DirectSum Î¹ fun i => â„¬ i))).comp ((LinearMap.rTensor (DirectSum Î¹ fun i => â„¬ i) â†‘(TensorProduct.gradedComm R â„¬ ğ’œ)).comp â†‘(TensorProduct.assoc R (DirectSum Î¹ â„¬) (DirectSum Î¹ ğ’œ) (DirectSum Î¹ â„¬)).symm))).comp â†‘(TensorProduct.assoc R (DirectSum Î¹ ğ’œ) (DirectSum Î¹ â„¬) (TensorProduct R (DirectSum Î¹ ğ’œ) (DirectSum Î¹ â„¬)))))))","decl":"open TensorProduct (assoc map) in\n/-- The multiplication operation for tensor products of externally `Î¹`-graded algebras. -/\nnoncomputable irreducible_def gradedMul :\n    letI AB := DirectSum _ ğ’œ âŠ—[R] DirectSum _ â„¬\n    letI : Module R AB := TensorProduct.leftModule\n    AB â†’â‚—[R] AB â†’â‚—[R] AB := by\n  refine TensorProduct.curry ?_\n  refine map (LinearMap.mul' R (â¨ i, ğ’œ i)) (LinearMap.mul' R (â¨ i, â„¬ i)) âˆ˜â‚— ?_\n  refine (assoc R _ _ _).symm.toLinearMap âˆ˜â‚— .lTensor _ ?_ âˆ˜â‚— (assoc R _ _ _).toLinearMap\n  refine (assoc R _ _ _).toLinearMap âˆ˜â‚— .rTensor _ ?_ âˆ˜â‚— (assoc R _ _ _).symm.toLinearMap\n  exact (gradedComm _ _ _).toLinearMap\n\n"}
{"name":"TensorProduct.tmul_of_gradedMul_of_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\ninstâœÂ¹Â¹ : CommSemiring Î¹\ninstâœÂ¹â° : Module Î¹ (Additive (Units Int))\ninstâœâ¹ : DecidableEq Î¹\nğ’œ : Î¹ â†’ Type u_3\nâ„¬ : Î¹ â†’ Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : (i : Î¹) â†’ AddCommGroup (ğ’œ i)\ninstâœâ¶ : (i : Î¹) â†’ AddCommGroup (â„¬ i)\ninstâœâµ : (i : Î¹) â†’ Module R (ğ’œ i)\ninstâœâ´ : (i : Î¹) â†’ Module R (â„¬ i)\ninstâœÂ³ : DirectSum.GRing ğ’œ\ninstâœÂ² : DirectSum.GRing â„¬\ninstâœÂ¹ : DirectSum.GAlgebra R ğ’œ\ninstâœ : DirectSum.GAlgebra R â„¬\njâ‚ iâ‚‚ : Î¹\naâ‚ : DirectSum Î¹ fun i => ğ’œ i\nbâ‚ : â„¬ jâ‚\naâ‚‚ : ğ’œ iâ‚‚\nbâ‚‚ : DirectSum Î¹ fun i => â„¬ i\nâŠ¢ Eq (((TensorProduct.gradedMul R ğ’œ â„¬) (TensorProduct.tmul R aâ‚ ((DirectSum.lof R Î¹ â„¬ jâ‚) bâ‚))) (TensorProduct.tmul R ((DirectSum.lof R Î¹ ğ’œ iâ‚‚) aâ‚‚) bâ‚‚)) (HSMul.hSMul (HPow.hPow (-1) (HMul.hMul jâ‚ iâ‚‚)) (TensorProduct.tmul R (HMul.hMul aâ‚ ((DirectSum.lof R Î¹ ğ’œ iâ‚‚) aâ‚‚)) (HMul.hMul ((DirectSum.lof R Î¹ â„¬ jâ‚) bâ‚) bâ‚‚)))","decl":"theorem tmul_of_gradedMul_of_tmul (jâ‚ iâ‚‚ : Î¹)\n    (aâ‚ : â¨ i, ğ’œ i) (bâ‚ : â„¬ jâ‚) (aâ‚‚ : ğ’œ iâ‚‚) (bâ‚‚ : â¨ i, â„¬ i) :\n    gradedMul R ğ’œ â„¬ (aâ‚ âŠ—â‚œ lof R _ â„¬ jâ‚ bâ‚) (lof R _ ğ’œ iâ‚‚ aâ‚‚ âŠ—â‚œ bâ‚‚) =\n      (-1 : â„¤Ë£)^(jâ‚ * iâ‚‚) â€¢ ((aâ‚ * lof R _ ğ’œ _ aâ‚‚) âŠ—â‚œ (lof R _ â„¬ _ bâ‚ * bâ‚‚)) := by\n  rw [gradedMul]\n  dsimp only [curry_apply, LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply, assoc_tmul,\n    map_tmul, LinearMap.id_coe, id_eq, assoc_symm_tmul, LinearMap.rTensor_tmul,\n    LinearMap.lTensor_tmul]\n  rw [mul_comm jâ‚ iâ‚‚, gradedComm_of_tmul_of]\n  -- the tower smul lemmas elaborate too slowly\n  rw [Units.smul_def, Units.smul_def, â† Int.cast_smul_eq_zsmul R, â† Int.cast_smul_eq_zsmul R]\n  -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 had to specialize `map_smul` to avoid timeouts.\n  rw [â† smul_tmul', LinearEquiv.map_smul, tmul_smul, LinearEquiv.map_smul, LinearMap.map_smul]\n  dsimp\n\n"}
{"name":"TensorProduct.algebraMap_gradedMul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\ninstâœÂ¹Â¹ : CommSemiring Î¹\ninstâœÂ¹â° : Module Î¹ (Additive (Units Int))\ninstâœâ¹ : DecidableEq Î¹\nğ’œ : Î¹ â†’ Type u_3\nâ„¬ : Î¹ â†’ Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : (i : Î¹) â†’ AddCommGroup (ğ’œ i)\ninstâœâ¶ : (i : Î¹) â†’ AddCommGroup (â„¬ i)\ninstâœâµ : (i : Î¹) â†’ Module R (ğ’œ i)\ninstâœâ´ : (i : Î¹) â†’ Module R (â„¬ i)\ninstâœÂ³ : DirectSum.GRing ğ’œ\ninstâœÂ² : DirectSum.GRing â„¬\ninstâœÂ¹ : DirectSum.GAlgebra R ğ’œ\ninstâœ : DirectSum.GAlgebra R â„¬\nr : R\nx : TensorProduct R (DirectSum Î¹ fun i => ğ’œ i) (DirectSum Î¹ fun i => â„¬ i)\nâŠ¢ Eq (((TensorProduct.gradedMul R ğ’œ â„¬) (TensorProduct.tmul R ((algebraMap R (DirectSum Î¹ ğ’œ)) r) 1)) x) (HSMul.hSMul r x)","decl":"theorem algebraMap_gradedMul (r : R) (x : (â¨ i, ğ’œ i) âŠ—[R] (â¨ i, â„¬ i)) :\n    gradedMul R ğ’œ â„¬ (algebraMap R _ r âŠ—â‚œ 1) x = r â€¢ x := by\n  suffices gradedMul R ğ’œ â„¬ (algebraMap R _ r âŠ—â‚œ 1) = DistribMulAction.toLinearMap R _ r by\n    exact DFunLike.congr_fun this x\n  ext ia a ib b\n  dsimp\n  erw [tmul_of_gradedMul_of_tmul]\n  rw [zero_mul, uzpow_zero, one_smul, smul_tmul']\n  erw [one_mul, _root_.Algebra.smul_def]\n\n"}
{"name":"TensorProduct.one_gradedMul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\ninstâœÂ¹Â¹ : CommSemiring Î¹\ninstâœÂ¹â° : Module Î¹ (Additive (Units Int))\ninstâœâ¹ : DecidableEq Î¹\nğ’œ : Î¹ â†’ Type u_3\nâ„¬ : Î¹ â†’ Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : (i : Î¹) â†’ AddCommGroup (ğ’œ i)\ninstâœâ¶ : (i : Î¹) â†’ AddCommGroup (â„¬ i)\ninstâœâµ : (i : Î¹) â†’ Module R (ğ’œ i)\ninstâœâ´ : (i : Î¹) â†’ Module R (â„¬ i)\ninstâœÂ³ : DirectSum.GRing ğ’œ\ninstâœÂ² : DirectSum.GRing â„¬\ninstâœÂ¹ : DirectSum.GAlgebra R ğ’œ\ninstâœ : DirectSum.GAlgebra R â„¬\nx : TensorProduct R (DirectSum Î¹ fun i => ğ’œ i) (DirectSum Î¹ fun i => â„¬ i)\nâŠ¢ Eq (((TensorProduct.gradedMul R ğ’œ â„¬) 1) x) x","decl":"theorem one_gradedMul (x : (â¨ i, ğ’œ i) âŠ—[R] (â¨ i, â„¬ i)) :\n    gradedMul R ğ’œ â„¬ 1 x = x := by\n  -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 had to specialize `map_one` to avoid timeouts.\n  simpa only [RingHom.map_one, one_smul] using algebraMap_gradedMul ğ’œ â„¬ 1 x\n\n"}
{"name":"TensorProduct.gradedMul_algebraMap","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\ninstâœÂ¹Â¹ : CommSemiring Î¹\ninstâœÂ¹â° : Module Î¹ (Additive (Units Int))\ninstâœâ¹ : DecidableEq Î¹\nğ’œ : Î¹ â†’ Type u_3\nâ„¬ : Î¹ â†’ Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : (i : Î¹) â†’ AddCommGroup (ğ’œ i)\ninstâœâ¶ : (i : Î¹) â†’ AddCommGroup (â„¬ i)\ninstâœâµ : (i : Î¹) â†’ Module R (ğ’œ i)\ninstâœâ´ : (i : Î¹) â†’ Module R (â„¬ i)\ninstâœÂ³ : DirectSum.GRing ğ’œ\ninstâœÂ² : DirectSum.GRing â„¬\ninstâœÂ¹ : DirectSum.GAlgebra R ğ’œ\ninstâœ : DirectSum.GAlgebra R â„¬\nx : TensorProduct R (DirectSum Î¹ fun i => ğ’œ i) (DirectSum Î¹ fun i => â„¬ i)\nr : R\nâŠ¢ Eq (((TensorProduct.gradedMul R ğ’œ â„¬) x) (TensorProduct.tmul R ((algebraMap R (DirectSum Î¹ ğ’œ)) r) 1)) (HSMul.hSMul r x)","decl":"theorem gradedMul_algebraMap (x : (â¨ i, ğ’œ i) âŠ—[R] (â¨ i, â„¬ i)) (r : R) :\n    gradedMul R ğ’œ â„¬ x (algebraMap R _ r âŠ—â‚œ 1) = r â€¢ x := by\n  suffices (gradedMul R ğ’œ â„¬).flip (algebraMap R _ r âŠ—â‚œ 1) = DistribMulAction.toLinearMap R _ r by\n    exact DFunLike.congr_fun this x\n  ext\n  dsimp\n  erw [tmul_of_gradedMul_of_tmul]\n  rw [mul_zero, uzpow_zero, one_smul, smul_tmul',\n      mul_one, _root_.Algebra.smul_def, Algebra.commutes]\n  rfl\n\n"}
{"name":"TensorProduct.gradedMul_one","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\ninstâœÂ¹Â¹ : CommSemiring Î¹\ninstâœÂ¹â° : Module Î¹ (Additive (Units Int))\ninstâœâ¹ : DecidableEq Î¹\nğ’œ : Î¹ â†’ Type u_3\nâ„¬ : Î¹ â†’ Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : (i : Î¹) â†’ AddCommGroup (ğ’œ i)\ninstâœâ¶ : (i : Î¹) â†’ AddCommGroup (â„¬ i)\ninstâœâµ : (i : Î¹) â†’ Module R (ğ’œ i)\ninstâœâ´ : (i : Î¹) â†’ Module R (â„¬ i)\ninstâœÂ³ : DirectSum.GRing ğ’œ\ninstâœÂ² : DirectSum.GRing â„¬\ninstâœÂ¹ : DirectSum.GAlgebra R ğ’œ\ninstâœ : DirectSum.GAlgebra R â„¬\nx : TensorProduct R (DirectSum Î¹ fun i => ğ’œ i) (DirectSum Î¹ fun i => â„¬ i)\nâŠ¢ Eq (((TensorProduct.gradedMul R ğ’œ â„¬) x) 1) x","decl":"theorem gradedMul_one (x : (â¨ i, ğ’œ i) âŠ—[R] (â¨ i, â„¬ i)) :\n    gradedMul R ğ’œ â„¬ x 1 = x := by\n  -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 had to specialize `map_one` to avoid timeouts.\n  simpa only [RingHom.map_one, one_smul] using gradedMul_algebraMap ğ’œ â„¬ x 1\n\n"}
{"name":"TensorProduct.gradedMul_assoc","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\ninstâœÂ¹Â¹ : CommSemiring Î¹\ninstâœÂ¹â° : Module Î¹ (Additive (Units Int))\ninstâœâ¹ : DecidableEq Î¹\nğ’œ : Î¹ â†’ Type u_3\nâ„¬ : Î¹ â†’ Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : (i : Î¹) â†’ AddCommGroup (ğ’œ i)\ninstâœâ¶ : (i : Î¹) â†’ AddCommGroup (â„¬ i)\ninstâœâµ : (i : Î¹) â†’ Module R (ğ’œ i)\ninstâœâ´ : (i : Î¹) â†’ Module R (â„¬ i)\ninstâœÂ³ : DirectSum.GRing ğ’œ\ninstâœÂ² : DirectSum.GRing â„¬\ninstâœÂ¹ : DirectSum.GAlgebra R ğ’œ\ninstâœ : DirectSum.GAlgebra R â„¬\nx y z : TensorProduct R (DirectSum Î¹ ğ’œ) (DirectSum Î¹ â„¬)\nâŠ¢ Eq (((TensorProduct.gradedMul R ğ’œ â„¬) (((TensorProduct.gradedMul R ğ’œ â„¬) x) y)) z) (((TensorProduct.gradedMul R ğ’œ â„¬) x) (((TensorProduct.gradedMul R ğ’œ â„¬) y) z))","decl":"theorem gradedMul_assoc (x y z : DirectSum _ ğ’œ âŠ—[R] DirectSum _ â„¬) :\n    gradedMul R ğ’œ â„¬ (gradedMul R ğ’œ â„¬ x y) z = gradedMul R ğ’œ â„¬ x (gradedMul R ğ’œ â„¬ y z) := by\n  let mA := gradedMul R ğ’œ â„¬\n    -- restate as an equality of morphisms so that we can use `ext`\n  suffices LinearMap.llcomp R _ _ _ mA âˆ˜â‚— mA =\n      (LinearMap.llcomp R _ _ _ LinearMap.lflip <| LinearMap.llcomp R _ _ _ mA.flip âˆ˜â‚— mA).flip by\n    exact DFunLike.congr_fun (DFunLike.congr_fun (DFunLike.congr_fun this x) y) z\n  ext ixa xa ixb xb iya ya iyb yb iza za izb zb\n  dsimp [mA]\n  simp_rw [tmul_of_gradedMul_of_tmul, Units.smul_def, â† Int.cast_smul_eq_zsmul R,\n    LinearMap.map_smulâ‚‚, LinearMap.map_smul, DirectSum.lof_eq_of, DirectSum.of_mul_of,\n    â† DirectSum.lof_eq_of R, tmul_of_gradedMul_of_tmul, DirectSum.lof_eq_of, â† DirectSum.of_mul_of,\n    â† DirectSum.lof_eq_of R, mul_assoc]\n  simp_rw [Int.cast_smul_eq_zsmul R, â† Units.smul_def, smul_smul, â† uzpow_add, add_mul, mul_add]\n  congr 2\n  abel\n\n"}
{"name":"TensorProduct.gradedComm_gradedMul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\ninstâœÂ¹Â¹ : CommSemiring Î¹\ninstâœÂ¹â° : Module Î¹ (Additive (Units Int))\ninstâœâ¹ : DecidableEq Î¹\nğ’œ : Î¹ â†’ Type u_3\nâ„¬ : Î¹ â†’ Type u_4\ninstâœâ¸ : CommRing R\ninstâœâ· : (i : Î¹) â†’ AddCommGroup (ğ’œ i)\ninstâœâ¶ : (i : Î¹) â†’ AddCommGroup (â„¬ i)\ninstâœâµ : (i : Î¹) â†’ Module R (ğ’œ i)\ninstâœâ´ : (i : Î¹) â†’ Module R (â„¬ i)\ninstâœÂ³ : DirectSum.GRing ğ’œ\ninstâœÂ² : DirectSum.GRing â„¬\ninstâœÂ¹ : DirectSum.GAlgebra R ğ’œ\ninstâœ : DirectSum.GAlgebra R â„¬\nx y : TensorProduct R (DirectSum Î¹ ğ’œ) (DirectSum Î¹ â„¬)\nâŠ¢ Eq ((TensorProduct.gradedComm R ğ’œ â„¬) (((TensorProduct.gradedMul R ğ’œ â„¬) x) y)) (((TensorProduct.gradedMul R â„¬ ğ’œ) ((TensorProduct.gradedComm R ğ’œ â„¬) x)) ((TensorProduct.gradedComm R ğ’œ â„¬) y))","decl":"theorem gradedComm_gradedMul (x y : DirectSum _ ğ’œ âŠ—[R] DirectSum _ â„¬) :\n    gradedComm R ğ’œ â„¬ (gradedMul R ğ’œ â„¬ x y)\n      = gradedMul R â„¬ ğ’œ (gradedComm R ğ’œ â„¬ x) (gradedComm R ğ’œ â„¬ y) := by\n  suffices (gradedMul R ğ’œ â„¬).comprâ‚‚ (gradedComm R ğ’œ â„¬).toLinearMap\n      = (gradedMul R â„¬ ğ’œ âˆ˜â‚— (gradedComm R ğ’œ â„¬).toLinearMap).complâ‚‚\n        (gradedComm R ğ’œ â„¬).toLinearMap from\n    LinearMap.congr_funâ‚‚ this x y\n  ext iâ‚ aâ‚ jâ‚ bâ‚ iâ‚‚ aâ‚‚ jâ‚‚ bâ‚‚\n  dsimp\n  rw [gradedComm_of_tmul_of, gradedComm_of_tmul_of, tmul_of_gradedMul_of_tmul]\n  -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 had to specialize `map_smul` to avoid timeouts.\n  simp_rw [Units.smul_def, â† Int.cast_smul_eq_zsmul R, LinearEquiv.map_smul, LinearMap.map_smul,\n    LinearMap.smul_apply]\n  simp_rw [Int.cast_smul_eq_zsmul R, â† Units.smul_def, DirectSum.lof_eq_of, DirectSum.of_mul_of,\n    â† DirectSum.lof_eq_of R, gradedComm_of_tmul_of, tmul_of_gradedMul_of_tmul, smul_smul,\n    DirectSum.lof_eq_of, â† DirectSum.of_mul_of, â† DirectSum.lof_eq_of R]\n  simp_rw [â† uzpow_add, mul_add, add_mul, mul_comm iâ‚ jâ‚‚]\n  congr 1\n  abel_nf\n  rw [two_nsmul, uzpow_add, uzpow_add, Int.units_mul_self, one_mul]\n\n"}
