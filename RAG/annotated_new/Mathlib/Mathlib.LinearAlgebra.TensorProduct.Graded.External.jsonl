{"name":"TensorProduct.gradedCommAux_lof_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝⁷ : CommSemiring ι\ninst✝⁶ : Module ι (Additive (Units Int))\ninst✝⁵ : DecidableEq ι\n𝒜 : ι → Type u_3\nℬ : ι → Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : (i : ι) → AddCommGroup (𝒜 i)\ninst✝² : (i : ι) → AddCommGroup (ℬ i)\ninst✝¹ : (i : ι) → Module R (𝒜 i)\ninst✝ : (i : ι) → Module R (ℬ i)\ni j : ι\na : 𝒜 i\nb : ℬ j\n⊢ Eq ((TensorProduct.gradedCommAux R 𝒜 ℬ) ((DirectSum.lof R (Prod ι ι) (fun i => TensorProduct R (𝒜 i.1) (ℬ i.2)) { fst := i, snd := j }) (TensorProduct.tmul R a b))) (HSMul.hSMul (HPow.hPow (-1) (HMul.hMul j i)) ((DirectSum.lof R (Prod ι ι) (fun i => TensorProduct R (ℬ i.1) (𝒜 i.2)) { fst := j, snd := i }) (TensorProduct.tmul R b a)))","decl":"@[simp]\ntheorem gradedCommAux_lof_tmul (i j : ι) (a : 𝒜 i) (b : ℬ j) :\n    gradedCommAux R 𝒜 ℬ (lof R _ 𝒜ℬ (i, j) (a ⊗ₜ b)) =\n      (-1 : ℤˣ)^(j * i) • lof R _ ℬ𝒜 (j, i) (b ⊗ₜ a) := by\n  rw [gradedCommAux]\n  dsimp\n  simp [mul_comm i j]\n\n"}
{"name":"TensorProduct.gradedCommAux_comp_gradedCommAux","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝⁷ : CommSemiring ι\ninst✝⁶ : Module ι (Additive (Units Int))\ninst✝⁵ : DecidableEq ι\n𝒜 : ι → Type u_3\nℬ : ι → Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : (i : ι) → AddCommGroup (𝒜 i)\ninst✝² : (i : ι) → AddCommGroup (ℬ i)\ninst✝¹ : (i : ι) → Module R (𝒜 i)\ninst✝ : (i : ι) → Module R (ℬ i)\n⊢ Eq ((TensorProduct.gradedCommAux R 𝒜 ℬ).comp (TensorProduct.gradedCommAux R ℬ 𝒜)) LinearMap.id","decl":"@[simp]\ntheorem gradedCommAux_comp_gradedCommAux :\n    gradedCommAux R 𝒜 ℬ ∘ₗ gradedCommAux R ℬ 𝒜 = LinearMap.id := by\n  ext i a b\n  dsimp\n  rw [gradedCommAux_lof_tmul, LinearMap.map_smul_of_tower, gradedCommAux_lof_tmul, smul_smul,\n    mul_comm i.2 i.1, Int.units_mul_self, one_smul]\n\n"}
{"name":"TensorProduct.gradedComm_symm","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝⁷ : CommSemiring ι\ninst✝⁶ : Module ι (Additive (Units Int))\ninst✝⁵ : DecidableEq ι\n𝒜 : ι → Type u_3\nℬ : ι → Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : (i : ι) → AddCommGroup (𝒜 i)\ninst✝² : (i : ι) → AddCommGroup (ℬ i)\ninst✝¹ : (i : ι) → Module R (𝒜 i)\ninst✝ : (i : ι) → Module R (ℬ i)\n⊢ Eq (TensorProduct.gradedComm R 𝒜 ℬ).symm (TensorProduct.gradedComm R ℬ 𝒜)","decl":"/-- The braiding is symmetric. -/\n@[simp]\ntheorem gradedComm_symm : (gradedComm R 𝒜 ℬ).symm = gradedComm R ℬ 𝒜 := by\n  rw [gradedComm, gradedComm, LinearEquiv.trans_symm, LinearEquiv.symm_symm]\n  ext\n  rfl\n\n"}
{"name":"TensorProduct.gradedComm_of_tmul_of","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝⁷ : CommSemiring ι\ninst✝⁶ : Module ι (Additive (Units Int))\ninst✝⁵ : DecidableEq ι\n𝒜 : ι → Type u_3\nℬ : ι → Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : (i : ι) → AddCommGroup (𝒜 i)\ninst✝² : (i : ι) → AddCommGroup (ℬ i)\ninst✝¹ : (i : ι) → Module R (𝒜 i)\ninst✝ : (i : ι) → Module R (ℬ i)\ni j : ι\na : 𝒜 i\nb : ℬ j\n⊢ Eq ((TensorProduct.gradedComm R 𝒜 ℬ) (TensorProduct.tmul R ((DirectSum.lof R ι 𝒜 i) a) ((DirectSum.lof R ι ℬ j) b))) (HSMul.hSMul (HPow.hPow (-1) (HMul.hMul j i)) (TensorProduct.tmul R ((DirectSum.lof R ι ℬ j) b) ((DirectSum.lof R ι 𝒜 i) a)))","decl":"theorem gradedComm_of_tmul_of (i j : ι) (a : 𝒜 i) (b : ℬ j) :\n    gradedComm R 𝒜 ℬ (lof R _ 𝒜 i a ⊗ₜ lof R _ ℬ j b) =\n      (-1 : ℤˣ)^(j * i) • (lof R _ ℬ _ b ⊗ₜ lof R _ 𝒜 _ a) := by\n  rw [gradedComm]\n  dsimp only [LinearEquiv.trans_apply, LinearEquiv.ofLinear_apply]\n  rw [TensorProduct.directSum_lof_tmul_lof, gradedCommAux_lof_tmul, Units.smul_def,\n    -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 specialized `map_smul` to `LinearEquiv.map_smul` to avoid timeouts.\n    ← Int.cast_smul_eq_zsmul R, LinearEquiv.map_smul, TensorProduct.directSum_symm_lof_tmul,\n    Int.cast_smul_eq_zsmul, ← Units.smul_def]\n\n"}
{"name":"TensorProduct.gradedComm_tmul_of_zero","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝⁷ : CommSemiring ι\ninst✝⁶ : Module ι (Additive (Units Int))\ninst✝⁵ : DecidableEq ι\n𝒜 : ι → Type u_3\nℬ : ι → Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : (i : ι) → AddCommGroup (𝒜 i)\ninst✝² : (i : ι) → AddCommGroup (ℬ i)\ninst✝¹ : (i : ι) → Module R (𝒜 i)\ninst✝ : (i : ι) → Module R (ℬ i)\na : DirectSum ι fun i => 𝒜 i\nb : ℬ 0\n⊢ Eq ((TensorProduct.gradedComm R 𝒜 ℬ) (TensorProduct.tmul R a ((DirectSum.lof R ι ℬ 0) b))) (TensorProduct.tmul R ((DirectSum.lof R ι ℬ 0) b) a)","decl":"theorem gradedComm_tmul_of_zero (a : ⨁ i, 𝒜 i) (b : ℬ 0) :\n    gradedComm R 𝒜 ℬ (a ⊗ₜ lof R _ ℬ 0 b) = lof R _ ℬ _ b ⊗ₜ a := by\n  suffices\n    (gradedComm R 𝒜 ℬ).toLinearMap ∘ₗ\n        (TensorProduct.mk R (⨁ i, 𝒜 i) (⨁ i, ℬ i)).flip (lof R _ ℬ 0 b) =\n      TensorProduct.mk R _ _ (lof R _ ℬ 0 b) from\n    DFunLike.congr_fun this a\n  ext i a\n  dsimp\n  rw [gradedComm_of_tmul_of, zero_mul, uzpow_zero, one_smul]\n\n"}
{"name":"TensorProduct.gradedComm_of_zero_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝⁷ : CommSemiring ι\ninst✝⁶ : Module ι (Additive (Units Int))\ninst✝⁵ : DecidableEq ι\n𝒜 : ι → Type u_3\nℬ : ι → Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : (i : ι) → AddCommGroup (𝒜 i)\ninst✝² : (i : ι) → AddCommGroup (ℬ i)\ninst✝¹ : (i : ι) → Module R (𝒜 i)\ninst✝ : (i : ι) → Module R (ℬ i)\na : 𝒜 0\nb : DirectSum ι fun i => ℬ i\n⊢ Eq ((TensorProduct.gradedComm R 𝒜 ℬ) (TensorProduct.tmul R ((DirectSum.lof R ι 𝒜 0) a) b)) (TensorProduct.tmul R b ((DirectSum.lof R ι 𝒜 0) a))","decl":"theorem gradedComm_of_zero_tmul (a : 𝒜 0) (b : ⨁ i, ℬ i) :\n    gradedComm R 𝒜 ℬ (lof R _ 𝒜 0 a ⊗ₜ b) = b ⊗ₜ lof R _ 𝒜 _ a := by\n  suffices\n    (gradedComm R 𝒜 ℬ).toLinearMap ∘ₗ (TensorProduct.mk R (⨁ i, 𝒜 i) (⨁ i, ℬ i)) (lof R _ 𝒜 0 a) =\n      (TensorProduct.mk R _ _).flip (lof R _ 𝒜 0 a) from\n    DFunLike.congr_fun this b\n  ext i b\n  dsimp\n  rw [gradedComm_of_tmul_of, mul_zero, uzpow_zero, one_smul]\n\n"}
{"name":"TensorProduct.gradedComm_tmul_one","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝⁸ : CommSemiring ι\ninst✝⁷ : Module ι (Additive (Units Int))\ninst✝⁶ : DecidableEq ι\n𝒜 : ι → Type u_3\nℬ : ι → Type u_4\ninst✝⁵ : CommRing R\ninst✝⁴ : (i : ι) → AddCommGroup (𝒜 i)\ninst✝³ : (i : ι) → AddCommGroup (ℬ i)\ninst✝² : (i : ι) → Module R (𝒜 i)\ninst✝¹ : (i : ι) → Module R (ℬ i)\ninst✝ : DirectSum.GRing ℬ\na : DirectSum ι fun i => 𝒜 i\n⊢ Eq ((TensorProduct.gradedComm R 𝒜 ℬ) (TensorProduct.tmul R a 1)) (TensorProduct.tmul R 1 a)","decl":"theorem gradedComm_tmul_one [DirectSum.GRing ℬ] (a : ⨁ i, 𝒜 i) :\n    gradedComm R 𝒜 ℬ (a ⊗ₜ 1) = 1 ⊗ₜ a :=\n  gradedComm_tmul_of_zero _ _ _ _ _\n\n"}
{"name":"TensorProduct.gradedComm_one_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝⁸ : CommSemiring ι\ninst✝⁷ : Module ι (Additive (Units Int))\ninst✝⁶ : DecidableEq ι\n𝒜 : ι → Type u_3\nℬ : ι → Type u_4\ninst✝⁵ : CommRing R\ninst✝⁴ : (i : ι) → AddCommGroup (𝒜 i)\ninst✝³ : (i : ι) → AddCommGroup (ℬ i)\ninst✝² : (i : ι) → Module R (𝒜 i)\ninst✝¹ : (i : ι) → Module R (ℬ i)\ninst✝ : DirectSum.GRing 𝒜\nb : DirectSum ι fun i => ℬ i\n⊢ Eq ((TensorProduct.gradedComm R 𝒜 ℬ) (TensorProduct.tmul R 1 b)) (TensorProduct.tmul R b 1)","decl":"theorem gradedComm_one_tmul [DirectSum.GRing 𝒜] (b : ⨁ i, ℬ i) :\n    gradedComm R 𝒜 ℬ (1 ⊗ₜ b) = b ⊗ₜ 1 :=\n  gradedComm_of_zero_tmul _ _ _ _ _\n\n"}
{"name":"TensorProduct.gradedComm_one","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝⁹ : CommSemiring ι\ninst✝⁸ : Module ι (Additive (Units Int))\ninst✝⁷ : DecidableEq ι\n𝒜 : ι → Type u_3\nℬ : ι → Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : (i : ι) → AddCommGroup (𝒜 i)\ninst✝⁴ : (i : ι) → AddCommGroup (ℬ i)\ninst✝³ : (i : ι) → Module R (𝒜 i)\ninst✝² : (i : ι) → Module R (ℬ i)\ninst✝¹ : DirectSum.GRing 𝒜\ninst✝ : DirectSum.GRing ℬ\n⊢ Eq ((TensorProduct.gradedComm R 𝒜 ℬ) 1) 1","decl":"@[simp, nolint simpNF] -- linter times out\ntheorem gradedComm_one [DirectSum.GRing 𝒜] [DirectSum.GRing ℬ] : gradedComm R 𝒜 ℬ 1 = 1 :=\n  gradedComm_one_tmul _ _ _ _\n\n"}
{"name":"TensorProduct.gradedComm_tmul_algebraMap","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝⁹ : CommSemiring ι\ninst✝⁸ : Module ι (Additive (Units Int))\ninst✝⁷ : DecidableEq ι\n𝒜 : ι → Type u_3\nℬ : ι → Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : (i : ι) → AddCommGroup (𝒜 i)\ninst✝⁴ : (i : ι) → AddCommGroup (ℬ i)\ninst✝³ : (i : ι) → Module R (𝒜 i)\ninst✝² : (i : ι) → Module R (ℬ i)\ninst✝¹ : DirectSum.GRing ℬ\ninst✝ : DirectSum.GAlgebra R ℬ\na : DirectSum ι fun i => 𝒜 i\nr : R\n⊢ Eq ((TensorProduct.gradedComm R 𝒜 ℬ) (TensorProduct.tmul R a ((algebraMap R (DirectSum ι fun i => ℬ i)) r))) (TensorProduct.tmul R ((algebraMap R (DirectSum ι fun i => ℬ i)) r) a)","decl":"theorem gradedComm_tmul_algebraMap [DirectSum.GRing ℬ] [DirectSum.GAlgebra R ℬ]\n    (a : ⨁ i, 𝒜 i) (r : R) :\n    gradedComm R 𝒜 ℬ (a ⊗ₜ algebraMap R _ r) = algebraMap R _ r ⊗ₜ a :=\n  gradedComm_tmul_of_zero _ _ _ _ _\n\n"}
{"name":"TensorProduct.gradedComm_algebraMap_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝⁹ : CommSemiring ι\ninst✝⁸ : Module ι (Additive (Units Int))\ninst✝⁷ : DecidableEq ι\n𝒜 : ι → Type u_3\nℬ : ι → Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : (i : ι) → AddCommGroup (𝒜 i)\ninst✝⁴ : (i : ι) → AddCommGroup (ℬ i)\ninst✝³ : (i : ι) → Module R (𝒜 i)\ninst✝² : (i : ι) → Module R (ℬ i)\ninst✝¹ : DirectSum.GRing 𝒜\ninst✝ : DirectSum.GAlgebra R 𝒜\nr : R\nb : DirectSum ι fun i => ℬ i\n⊢ Eq ((TensorProduct.gradedComm R 𝒜 ℬ) (TensorProduct.tmul R ((algebraMap R (DirectSum ι fun i => 𝒜 i)) r) b)) (TensorProduct.tmul R b ((algebraMap R (DirectSum ι fun i => 𝒜 i)) r))","decl":"theorem gradedComm_algebraMap_tmul [DirectSum.GRing 𝒜] [DirectSum.GAlgebra R 𝒜]\n    (r : R) (b : ⨁ i, ℬ i) :\n    gradedComm R 𝒜 ℬ (algebraMap R _ r ⊗ₜ b) = b ⊗ₜ algebraMap R _ r :=\n  gradedComm_of_zero_tmul _ _ _ _ _\n\n"}
{"name":"TensorProduct.gradedComm_algebraMap","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝¹¹ : CommSemiring ι\ninst✝¹⁰ : Module ι (Additive (Units Int))\ninst✝⁹ : DecidableEq ι\n𝒜 : ι → Type u_3\nℬ : ι → Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : (i : ι) → AddCommGroup (𝒜 i)\ninst✝⁶ : (i : ι) → AddCommGroup (ℬ i)\ninst✝⁵ : (i : ι) → Module R (𝒜 i)\ninst✝⁴ : (i : ι) → Module R (ℬ i)\ninst✝³ : DirectSum.GRing 𝒜\ninst✝² : DirectSum.GRing ℬ\ninst✝¹ : DirectSum.GAlgebra R 𝒜\ninst✝ : DirectSum.GAlgebra R ℬ\nr : R\n⊢ Eq ((TensorProduct.gradedComm R 𝒜 ℬ) ((algebraMap R (TensorProduct R (DirectSum ι fun i => 𝒜 i) (DirectSum ι fun i => ℬ i))) r)) ((algebraMap R (TensorProduct R (DirectSum ι fun i => ℬ i) (DirectSum ι fun i => 𝒜 i))) r)","decl":"theorem gradedComm_algebraMap [DirectSum.GRing 𝒜] [DirectSum.GRing ℬ]\n    [DirectSum.GAlgebra R 𝒜] [DirectSum.GAlgebra R ℬ] (r : R) :\n    gradedComm R 𝒜 ℬ (algebraMap R _ r) = algebraMap R _ r :=\n  (gradedComm_algebraMap_tmul R 𝒜 ℬ r 1).trans (Algebra.TensorProduct.algebraMap_apply' r).symm\n\n"}
{"name":"TensorProduct.gradedMul_def","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_5\nι : Type u_6\ninst✝¹¹ : CommSemiring ι\ninst✝¹⁰ : Module ι (Additive (Units Int))\ninst✝⁹ : DecidableEq ι\n𝒜 : ι → Type u_7\nℬ : ι → Type u_8\ninst✝⁸ : CommRing R\ninst✝⁷ : (i : ι) → AddCommGroup (𝒜 i)\ninst✝⁶ : (i : ι) → AddCommGroup (ℬ i)\ninst✝⁵ : (i : ι) → Module R (𝒜 i)\ninst✝⁴ : (i : ι) → Module R (ℬ i)\ninst✝³ : DirectSum.GRing 𝒜\ninst✝² : DirectSum.GRing ℬ\ninst✝¹ : DirectSum.GAlgebra R 𝒜\ninst✝ : DirectSum.GAlgebra R ℬ\n⊢ Eq (TensorProduct.gradedMul R 𝒜 ℬ) (TensorProduct.curry ((TensorProduct.map (LinearMap.mul' R (DirectSum ι fun i => 𝒜 i)) (LinearMap.mul' R (DirectSum ι fun i => ℬ i))).comp ((↑(TensorProduct.assoc R (DirectSum ι fun i => 𝒜 i) (DirectSum ι fun i => 𝒜 i) (TensorProduct R (DirectSum ι fun i => ℬ i) (DirectSum ι fun i => ℬ i))).symm).comp ((LinearMap.lTensor (DirectSum ι fun i => 𝒜 i) ((↑(TensorProduct.assoc R (DirectSum ι fun i => 𝒜 i) (DirectSum ι fun i => ℬ i) (DirectSum ι fun i => ℬ i))).comp ((LinearMap.rTensor (DirectSum ι fun i => ℬ i) ↑(TensorProduct.gradedComm R ℬ 𝒜)).comp ↑(TensorProduct.assoc R (DirectSum ι ℬ) (DirectSum ι 𝒜) (DirectSum ι ℬ)).symm))).comp ↑(TensorProduct.assoc R (DirectSum ι 𝒜) (DirectSum ι ℬ) (TensorProduct R (DirectSum ι 𝒜) (DirectSum ι ℬ)))))))","decl":"open TensorProduct (assoc map) in\n/-- The multiplication operation for tensor products of externally `ι`-graded algebras. -/\nnoncomputable irreducible_def gradedMul :\n    letI AB := DirectSum _ 𝒜 ⊗[R] DirectSum _ ℬ\n    letI : Module R AB := TensorProduct.leftModule\n    AB →ₗ[R] AB →ₗ[R] AB := by\n  refine TensorProduct.curry ?_\n  refine map (LinearMap.mul' R (⨁ i, 𝒜 i)) (LinearMap.mul' R (⨁ i, ℬ i)) ∘ₗ ?_\n  refine (assoc R _ _ _).symm.toLinearMap ∘ₗ .lTensor _ ?_ ∘ₗ (assoc R _ _ _).toLinearMap\n  refine (assoc R _ _ _).toLinearMap ∘ₗ .rTensor _ ?_ ∘ₗ (assoc R _ _ _).symm.toLinearMap\n  exact (gradedComm _ _ _).toLinearMap\n\n"}
{"name":"TensorProduct.tmul_of_gradedMul_of_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝¹¹ : CommSemiring ι\ninst✝¹⁰ : Module ι (Additive (Units Int))\ninst✝⁹ : DecidableEq ι\n𝒜 : ι → Type u_3\nℬ : ι → Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : (i : ι) → AddCommGroup (𝒜 i)\ninst✝⁶ : (i : ι) → AddCommGroup (ℬ i)\ninst✝⁵ : (i : ι) → Module R (𝒜 i)\ninst✝⁴ : (i : ι) → Module R (ℬ i)\ninst✝³ : DirectSum.GRing 𝒜\ninst✝² : DirectSum.GRing ℬ\ninst✝¹ : DirectSum.GAlgebra R 𝒜\ninst✝ : DirectSum.GAlgebra R ℬ\nj₁ i₂ : ι\na₁ : DirectSum ι fun i => 𝒜 i\nb₁ : ℬ j₁\na₂ : 𝒜 i₂\nb₂ : DirectSum ι fun i => ℬ i\n⊢ Eq (((TensorProduct.gradedMul R 𝒜 ℬ) (TensorProduct.tmul R a₁ ((DirectSum.lof R ι ℬ j₁) b₁))) (TensorProduct.tmul R ((DirectSum.lof R ι 𝒜 i₂) a₂) b₂)) (HSMul.hSMul (HPow.hPow (-1) (HMul.hMul j₁ i₂)) (TensorProduct.tmul R (HMul.hMul a₁ ((DirectSum.lof R ι 𝒜 i₂) a₂)) (HMul.hMul ((DirectSum.lof R ι ℬ j₁) b₁) b₂)))","decl":"theorem tmul_of_gradedMul_of_tmul (j₁ i₂ : ι)\n    (a₁ : ⨁ i, 𝒜 i) (b₁ : ℬ j₁) (a₂ : 𝒜 i₂) (b₂ : ⨁ i, ℬ i) :\n    gradedMul R 𝒜 ℬ (a₁ ⊗ₜ lof R _ ℬ j₁ b₁) (lof R _ 𝒜 i₂ a₂ ⊗ₜ b₂) =\n      (-1 : ℤˣ)^(j₁ * i₂) • ((a₁ * lof R _ 𝒜 _ a₂) ⊗ₜ (lof R _ ℬ _ b₁ * b₂)) := by\n  rw [gradedMul]\n  dsimp only [curry_apply, LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply, assoc_tmul,\n    map_tmul, LinearMap.id_coe, id_eq, assoc_symm_tmul, LinearMap.rTensor_tmul,\n    LinearMap.lTensor_tmul]\n  rw [mul_comm j₁ i₂, gradedComm_of_tmul_of]\n  -- the tower smul lemmas elaborate too slowly\n  rw [Units.smul_def, Units.smul_def, ← Int.cast_smul_eq_zsmul R, ← Int.cast_smul_eq_zsmul R]\n  -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 had to specialize `map_smul` to avoid timeouts.\n  rw [← smul_tmul', LinearEquiv.map_smul, tmul_smul, LinearEquiv.map_smul, LinearMap.map_smul]\n  dsimp\n\n"}
{"name":"TensorProduct.algebraMap_gradedMul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝¹¹ : CommSemiring ι\ninst✝¹⁰ : Module ι (Additive (Units Int))\ninst✝⁹ : DecidableEq ι\n𝒜 : ι → Type u_3\nℬ : ι → Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : (i : ι) → AddCommGroup (𝒜 i)\ninst✝⁶ : (i : ι) → AddCommGroup (ℬ i)\ninst✝⁵ : (i : ι) → Module R (𝒜 i)\ninst✝⁴ : (i : ι) → Module R (ℬ i)\ninst✝³ : DirectSum.GRing 𝒜\ninst✝² : DirectSum.GRing ℬ\ninst✝¹ : DirectSum.GAlgebra R 𝒜\ninst✝ : DirectSum.GAlgebra R ℬ\nr : R\nx : TensorProduct R (DirectSum ι fun i => 𝒜 i) (DirectSum ι fun i => ℬ i)\n⊢ Eq (((TensorProduct.gradedMul R 𝒜 ℬ) (TensorProduct.tmul R ((algebraMap R (DirectSum ι 𝒜)) r) 1)) x) (HSMul.hSMul r x)","decl":"theorem algebraMap_gradedMul (r : R) (x : (⨁ i, 𝒜 i) ⊗[R] (⨁ i, ℬ i)) :\n    gradedMul R 𝒜 ℬ (algebraMap R _ r ⊗ₜ 1) x = r • x := by\n  suffices gradedMul R 𝒜 ℬ (algebraMap R _ r ⊗ₜ 1) = DistribMulAction.toLinearMap R _ r by\n    exact DFunLike.congr_fun this x\n  ext ia a ib b\n  dsimp\n  erw [tmul_of_gradedMul_of_tmul]\n  rw [zero_mul, uzpow_zero, one_smul, smul_tmul']\n  erw [one_mul, _root_.Algebra.smul_def]\n\n"}
{"name":"TensorProduct.one_gradedMul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝¹¹ : CommSemiring ι\ninst✝¹⁰ : Module ι (Additive (Units Int))\ninst✝⁹ : DecidableEq ι\n𝒜 : ι → Type u_3\nℬ : ι → Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : (i : ι) → AddCommGroup (𝒜 i)\ninst✝⁶ : (i : ι) → AddCommGroup (ℬ i)\ninst✝⁵ : (i : ι) → Module R (𝒜 i)\ninst✝⁴ : (i : ι) → Module R (ℬ i)\ninst✝³ : DirectSum.GRing 𝒜\ninst✝² : DirectSum.GRing ℬ\ninst✝¹ : DirectSum.GAlgebra R 𝒜\ninst✝ : DirectSum.GAlgebra R ℬ\nx : TensorProduct R (DirectSum ι fun i => 𝒜 i) (DirectSum ι fun i => ℬ i)\n⊢ Eq (((TensorProduct.gradedMul R 𝒜 ℬ) 1) x) x","decl":"theorem one_gradedMul (x : (⨁ i, 𝒜 i) ⊗[R] (⨁ i, ℬ i)) :\n    gradedMul R 𝒜 ℬ 1 x = x := by\n  -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 had to specialize `map_one` to avoid timeouts.\n  simpa only [RingHom.map_one, one_smul] using algebraMap_gradedMul 𝒜 ℬ 1 x\n\n"}
{"name":"TensorProduct.gradedMul_algebraMap","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝¹¹ : CommSemiring ι\ninst✝¹⁰ : Module ι (Additive (Units Int))\ninst✝⁹ : DecidableEq ι\n𝒜 : ι → Type u_3\nℬ : ι → Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : (i : ι) → AddCommGroup (𝒜 i)\ninst✝⁶ : (i : ι) → AddCommGroup (ℬ i)\ninst✝⁵ : (i : ι) → Module R (𝒜 i)\ninst✝⁴ : (i : ι) → Module R (ℬ i)\ninst✝³ : DirectSum.GRing 𝒜\ninst✝² : DirectSum.GRing ℬ\ninst✝¹ : DirectSum.GAlgebra R 𝒜\ninst✝ : DirectSum.GAlgebra R ℬ\nx : TensorProduct R (DirectSum ι fun i => 𝒜 i) (DirectSum ι fun i => ℬ i)\nr : R\n⊢ Eq (((TensorProduct.gradedMul R 𝒜 ℬ) x) (TensorProduct.tmul R ((algebraMap R (DirectSum ι 𝒜)) r) 1)) (HSMul.hSMul r x)","decl":"theorem gradedMul_algebraMap (x : (⨁ i, 𝒜 i) ⊗[R] (⨁ i, ℬ i)) (r : R) :\n    gradedMul R 𝒜 ℬ x (algebraMap R _ r ⊗ₜ 1) = r • x := by\n  suffices (gradedMul R 𝒜 ℬ).flip (algebraMap R _ r ⊗ₜ 1) = DistribMulAction.toLinearMap R _ r by\n    exact DFunLike.congr_fun this x\n  ext\n  dsimp\n  erw [tmul_of_gradedMul_of_tmul]\n  rw [mul_zero, uzpow_zero, one_smul, smul_tmul',\n      mul_one, _root_.Algebra.smul_def, Algebra.commutes]\n  rfl\n\n"}
{"name":"TensorProduct.gradedMul_one","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝¹¹ : CommSemiring ι\ninst✝¹⁰ : Module ι (Additive (Units Int))\ninst✝⁹ : DecidableEq ι\n𝒜 : ι → Type u_3\nℬ : ι → Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : (i : ι) → AddCommGroup (𝒜 i)\ninst✝⁶ : (i : ι) → AddCommGroup (ℬ i)\ninst✝⁵ : (i : ι) → Module R (𝒜 i)\ninst✝⁴ : (i : ι) → Module R (ℬ i)\ninst✝³ : DirectSum.GRing 𝒜\ninst✝² : DirectSum.GRing ℬ\ninst✝¹ : DirectSum.GAlgebra R 𝒜\ninst✝ : DirectSum.GAlgebra R ℬ\nx : TensorProduct R (DirectSum ι fun i => 𝒜 i) (DirectSum ι fun i => ℬ i)\n⊢ Eq (((TensorProduct.gradedMul R 𝒜 ℬ) x) 1) x","decl":"theorem gradedMul_one (x : (⨁ i, 𝒜 i) ⊗[R] (⨁ i, ℬ i)) :\n    gradedMul R 𝒜 ℬ x 1 = x := by\n  -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 had to specialize `map_one` to avoid timeouts.\n  simpa only [RingHom.map_one, one_smul] using gradedMul_algebraMap 𝒜 ℬ x 1\n\n"}
{"name":"TensorProduct.gradedMul_assoc","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝¹¹ : CommSemiring ι\ninst✝¹⁰ : Module ι (Additive (Units Int))\ninst✝⁹ : DecidableEq ι\n𝒜 : ι → Type u_3\nℬ : ι → Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : (i : ι) → AddCommGroup (𝒜 i)\ninst✝⁶ : (i : ι) → AddCommGroup (ℬ i)\ninst✝⁵ : (i : ι) → Module R (𝒜 i)\ninst✝⁴ : (i : ι) → Module R (ℬ i)\ninst✝³ : DirectSum.GRing 𝒜\ninst✝² : DirectSum.GRing ℬ\ninst✝¹ : DirectSum.GAlgebra R 𝒜\ninst✝ : DirectSum.GAlgebra R ℬ\nx y z : TensorProduct R (DirectSum ι 𝒜) (DirectSum ι ℬ)\n⊢ Eq (((TensorProduct.gradedMul R 𝒜 ℬ) (((TensorProduct.gradedMul R 𝒜 ℬ) x) y)) z) (((TensorProduct.gradedMul R 𝒜 ℬ) x) (((TensorProduct.gradedMul R 𝒜 ℬ) y) z))","decl":"theorem gradedMul_assoc (x y z : DirectSum _ 𝒜 ⊗[R] DirectSum _ ℬ) :\n    gradedMul R 𝒜 ℬ (gradedMul R 𝒜 ℬ x y) z = gradedMul R 𝒜 ℬ x (gradedMul R 𝒜 ℬ y z) := by\n  let mA := gradedMul R 𝒜 ℬ\n    -- restate as an equality of morphisms so that we can use `ext`\n  suffices LinearMap.llcomp R _ _ _ mA ∘ₗ mA =\n      (LinearMap.llcomp R _ _ _ LinearMap.lflip <| LinearMap.llcomp R _ _ _ mA.flip ∘ₗ mA).flip by\n    exact DFunLike.congr_fun (DFunLike.congr_fun (DFunLike.congr_fun this x) y) z\n  ext ixa xa ixb xb iya ya iyb yb iza za izb zb\n  dsimp [mA]\n  simp_rw [tmul_of_gradedMul_of_tmul, Units.smul_def, ← Int.cast_smul_eq_zsmul R,\n    LinearMap.map_smul₂, LinearMap.map_smul, DirectSum.lof_eq_of, DirectSum.of_mul_of,\n    ← DirectSum.lof_eq_of R, tmul_of_gradedMul_of_tmul, DirectSum.lof_eq_of, ← DirectSum.of_mul_of,\n    ← DirectSum.lof_eq_of R, mul_assoc]\n  simp_rw [Int.cast_smul_eq_zsmul R, ← Units.smul_def, smul_smul, ← uzpow_add, add_mul, mul_add]\n  congr 2\n  abel\n\n"}
{"name":"TensorProduct.gradedComm_gradedMul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.External","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝¹¹ : CommSemiring ι\ninst✝¹⁰ : Module ι (Additive (Units Int))\ninst✝⁹ : DecidableEq ι\n𝒜 : ι → Type u_3\nℬ : ι → Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : (i : ι) → AddCommGroup (𝒜 i)\ninst✝⁶ : (i : ι) → AddCommGroup (ℬ i)\ninst✝⁵ : (i : ι) → Module R (𝒜 i)\ninst✝⁴ : (i : ι) → Module R (ℬ i)\ninst✝³ : DirectSum.GRing 𝒜\ninst✝² : DirectSum.GRing ℬ\ninst✝¹ : DirectSum.GAlgebra R 𝒜\ninst✝ : DirectSum.GAlgebra R ℬ\nx y : TensorProduct R (DirectSum ι 𝒜) (DirectSum ι ℬ)\n⊢ Eq ((TensorProduct.gradedComm R 𝒜 ℬ) (((TensorProduct.gradedMul R 𝒜 ℬ) x) y)) (((TensorProduct.gradedMul R ℬ 𝒜) ((TensorProduct.gradedComm R 𝒜 ℬ) x)) ((TensorProduct.gradedComm R 𝒜 ℬ) y))","decl":"theorem gradedComm_gradedMul (x y : DirectSum _ 𝒜 ⊗[R] DirectSum _ ℬ) :\n    gradedComm R 𝒜 ℬ (gradedMul R 𝒜 ℬ x y)\n      = gradedMul R ℬ 𝒜 (gradedComm R 𝒜 ℬ x) (gradedComm R 𝒜 ℬ y) := by\n  suffices (gradedMul R 𝒜 ℬ).compr₂ (gradedComm R 𝒜 ℬ).toLinearMap\n      = (gradedMul R ℬ 𝒜 ∘ₗ (gradedComm R 𝒜 ℬ).toLinearMap).compl₂\n        (gradedComm R 𝒜 ℬ).toLinearMap from\n    LinearMap.congr_fun₂ this x y\n  ext i₁ a₁ j₁ b₁ i₂ a₂ j₂ b₂\n  dsimp\n  rw [gradedComm_of_tmul_of, gradedComm_of_tmul_of, tmul_of_gradedMul_of_tmul]\n  -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 had to specialize `map_smul` to avoid timeouts.\n  simp_rw [Units.smul_def, ← Int.cast_smul_eq_zsmul R, LinearEquiv.map_smul, LinearMap.map_smul,\n    LinearMap.smul_apply]\n  simp_rw [Int.cast_smul_eq_zsmul R, ← Units.smul_def, DirectSum.lof_eq_of, DirectSum.of_mul_of,\n    ← DirectSum.lof_eq_of R, gradedComm_of_tmul_of, tmul_of_gradedMul_of_tmul, smul_smul,\n    DirectSum.lof_eq_of, ← DirectSum.of_mul_of, ← DirectSum.lof_eq_of R]\n  simp_rw [← uzpow_add, mul_add, add_mul, mul_comm i₁ j₂]\n  congr 1\n  abel_nf\n  rw [two_nsmul, uzpow_add, uzpow_add, Int.units_mul_self, one_mul]\n\n"}
