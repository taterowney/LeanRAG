{"name":"Subsingleton.aemeasurable","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\nf : Î± â†’ Î²\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : Subsingleton Î±\nâŠ¢ AEMeasurable f Î¼","decl":"@[nontriviality, measurability]\ntheorem Subsingleton.aemeasurable [Subsingleton Î±] : AEMeasurable f Î¼ :=\n  Subsingleton.measurable.aemeasurable\n\n"}
{"name":"aemeasurable_of_subsingleton_codomain","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\nf : Î± â†’ Î²\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : Subsingleton Î²\nâŠ¢ AEMeasurable f Î¼","decl":"@[nontriviality, measurability]\ntheorem aemeasurable_of_subsingleton_codomain [Subsingleton Î²] : AEMeasurable f Î¼ :=\n  (measurable_of_subsingleton_codomain f).aemeasurable\n\n"}
{"name":"aemeasurable_zero_measure","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœ : MeasurableSpace Î²\nf : Î± â†’ Î²\nâŠ¢ AEMeasurable f 0","decl":"@[simp, measurability]\ntheorem aemeasurable_zero_measure : AEMeasurable f (0 : Measure Î±) := by\n  nontriviality Î±; inhabit Î±\n  exact âŸ¨fun _ => f default, measurable_const, rflâŸ©\n\n"}
{"name":"aemeasurable_id''","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nm : MeasurableSpace Î±\nhm : LE.le m m0\nâŠ¢ AEMeasurable id Î¼","decl":"@[fun_prop]\ntheorem aemeasurable_id'' (Î¼ : Measure Î±) {m : MeasurableSpace Î±} (hm : m â‰¤ m0) :\n    @AEMeasurable Î± Î± m m0 id Î¼ :=\n  @Measurable.aemeasurable Î± Î± m0 m id Î¼ (measurable_id'' hm)\n\n"}
{"name":"aemeasurable_of_map_neZero","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Î²\nh : NeZero (MeasureTheory.Measure.map f Î¼)\nâŠ¢ AEMeasurable f Î¼","decl":"lemma aemeasurable_of_map_neZero {Î¼ : Measure Î±}\n    {f : Î± â†’ Î²} (h : NeZero (Î¼.map f)) :\n    AEMeasurable f Î¼ := by\n  by_contra h'\n  simp [h'] at h\n\n"}
{"name":"AEMeasurable.mono_ac","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœ : MeasurableSpace Î²\nf : Î± â†’ Î²\nÎ¼ Î½ : MeasureTheory.Measure Î±\nhf : AEMeasurable f Î½\nhÎ¼Î½ : Î¼.AbsolutelyContinuous Î½\nâŠ¢ AEMeasurable f Î¼","decl":"lemma mono_ac (hf : AEMeasurable f Î½) (hÎ¼Î½ : Î¼ â‰ª Î½) : AEMeasurable f Î¼ :=\n  âŸ¨hf.mk f, hf.measurable_mk, hÎ¼Î½.ae_le hf.ae_eq_mkâŸ©\n\n"}
{"name":"AEMeasurable.mono_measure","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœ : MeasurableSpace Î²\nf : Î± â†’ Î²\nÎ¼ Î½ : MeasureTheory.Measure Î±\nh : AEMeasurable f Î¼\nh' : LE.le Î½ Î¼\nâŠ¢ AEMeasurable f Î½","decl":"theorem mono_measure (h : AEMeasurable f Î¼) (h' : Î½ â‰¤ Î¼) : AEMeasurable f Î½ :=\n  mono_ac h h'.absolutelyContinuous\n\n"}
{"name":"AEMeasurable.mono_set","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœ : MeasurableSpace Î²\nf : Î± â†’ Î²\nÎ¼ : MeasureTheory.Measure Î±\ns t : Set Î±\nh : HasSubset.Subset s t\nht : AEMeasurable f (Î¼.restrict t)\nâŠ¢ AEMeasurable f (Î¼.restrict s)","decl":"theorem mono_set {s t} (h : s âŠ† t) (ht : AEMeasurable f (Î¼.restrict t)) :\n    AEMeasurable f (Î¼.restrict s) :=\n  ht.mono_measure (restrict_mono h le_rfl)\n\n"}
{"name":"AEMeasurable.mono'","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœ : MeasurableSpace Î²\nf : Î± â†’ Î²\nÎ¼ Î½ : MeasureTheory.Measure Î±\nh : AEMeasurable f Î¼\nh' : Î½.AbsolutelyContinuous Î¼\nâŠ¢ AEMeasurable f Î½","decl":"@[fun_prop]\nprotected theorem mono' (h : AEMeasurable f Î¼) (h' : Î½ â‰ª Î¼) : AEMeasurable f Î½ :=\n  âŸ¨h.mk f, h.measurable_mk, h' h.ae_eq_mkâŸ©\n\n"}
{"name":"AEMeasurable.ae_mem_imp_eq_mk","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœ : MeasurableSpace Î²\nf : Î± â†’ Î²\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nh : AEMeasurable f (Î¼.restrict s)\nâŠ¢ Filter.Eventually (fun x => Membership.mem s x â†’ Eq (f x) (AEMeasurable.mk f h x)) (MeasureTheory.ae Î¼)","decl":"theorem ae_mem_imp_eq_mk {s} (h : AEMeasurable f (Î¼.restrict s)) :\n    âˆ€áµ x âˆ‚Î¼, x âˆˆ s â†’ f x = h.mk f x :=\n  ae_imp_of_ae_restrict h.ae_eq_mk\n\n"}
{"name":"AEMeasurable.ae_inf_principal_eq_mk","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœ : MeasurableSpace Î²\nf : Î± â†’ Î²\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nh : AEMeasurable f (Î¼.restrict s)\nâŠ¢ (Min.min (MeasureTheory.ae Î¼) (Filter.principal s)).EventuallyEq f (AEMeasurable.mk f h)","decl":"theorem ae_inf_principal_eq_mk {s} (h : AEMeasurable f (Î¼.restrict s)) : f =á¶ [ae Î¼ âŠ“ ğ“Ÿ s] h.mk f :=\n  le_ae_restrict h.ae_eq_mk\n\n"}
{"name":"AEMeasurable.sum_measure","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\nf : Î± â†’ Î²\ninstâœ : Countable Î¹\nÎ¼ : Î¹ â†’ MeasureTheory.Measure Î±\nh : âˆ€ (i : Î¹), AEMeasurable f (Î¼ i)\nâŠ¢ AEMeasurable f (MeasureTheory.Measure.sum Î¼)","decl":"@[measurability]\ntheorem sum_measure [Countable Î¹] {Î¼ : Î¹ â†’ Measure Î±} (h : âˆ€ i, AEMeasurable f (Î¼ i)) :\n    AEMeasurable f (sum Î¼) := by\n  classical\n  nontriviality Î²\n  inhabit Î²\n  set s : Î¹ â†’ Set Î± := fun i => toMeasurable (Î¼ i) { x | f x â‰  (h i).mk f x }\n  have hsÎ¼ : âˆ€ i, Î¼ i (s i) = 0 := by\n    intro i\n    rw [measure_toMeasurable]\n    exact (h i).ae_eq_mk\n  have hsm : MeasurableSet (â‹‚ i, s i) :=\n    MeasurableSet.iInter fun i => measurableSet_toMeasurable _ _\n  have hs : âˆ€ i x, x âˆ‰ s i â†’ f x = (h i).mk f x := by\n    intro i x hx\n    contrapose! hx\n    exact subset_toMeasurable _ _ hx\n  set g : Î± â†’ Î² := (â‹‚ i, s i).piecewise (const Î± default) f\n  refine âŸ¨g, measurable_of_restrict_of_restrict_compl hsm ?_ ?_, ae_sum_iff.mpr fun i => ?_âŸ©\n  Â· rw [restrict_piecewise]\n    simp only [s, Set.restrict, const]\n    exact measurable_const\n  Â· rw [restrict_piecewise_compl, compl_iInter]\n    intro t ht\n    refine âŸ¨â‹ƒ i, (h i).mk f â»Â¹' t âˆ© (s i)á¶œ, MeasurableSet.iUnion fun i â†¦\n      (measurable_mk _ ht).inter (measurableSet_toMeasurable _ _).compl, ?_âŸ©\n    ext âŸ¨x, hxâŸ©\n    simp only [mem_preimage, mem_iUnion, Subtype.coe_mk, Set.restrict, mem_inter_iff,\n      mem_compl_iff] at hx âŠ¢\n    constructor\n    Â· rintro âŸ¨i, hxt, hxsâŸ©\n      rwa [hs _ _ hxs]\n    Â· rcases hx with âŸ¨i, hiâŸ©\n      rw [hs _ _ hi]\n      exact fun h => âŸ¨i, h, hiâŸ©\n  Â· refine measure_mono_null (fun x (hx : f x â‰  g x) => ?_) (hsÎ¼ i)\n    contrapose! hx\n    refine (piecewise_eq_of_not_mem _ _ _ ?_).symm\n    exact fun h => hx (mem_iInter.1 h i)\n\n"}
{"name":"aemeasurable_sum_measure_iff","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\nf : Î± â†’ Î²\ninstâœ : Countable Î¹\nÎ¼ : Î¹ â†’ MeasureTheory.Measure Î±\nâŠ¢ Iff (AEMeasurable f (MeasureTheory.Measure.sum Î¼)) (âˆ€ (i : Î¹), AEMeasurable f (Î¼ i))","decl":"@[simp]\ntheorem _root_.aemeasurable_sum_measure_iff [Countable Î¹] {Î¼ : Î¹ â†’ Measure Î±} :\n    AEMeasurable f (sum Î¼) â†” âˆ€ i, AEMeasurable f (Î¼ i) :=\n  âŸ¨fun h _ => h.mono_measure (le_sum _ _), sum_measureâŸ©\n\n"}
{"name":"aemeasurable_add_measure_iff","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœ : MeasurableSpace Î²\nf : Î± â†’ Î²\nÎ¼ Î½ : MeasureTheory.Measure Î±\nâŠ¢ Iff (AEMeasurable f (HAdd.hAdd Î¼ Î½)) (And (AEMeasurable f Î¼) (AEMeasurable f Î½))","decl":"@[simp]\ntheorem _root_.aemeasurable_add_measure_iff :\n    AEMeasurable f (Î¼ + Î½) â†” AEMeasurable f Î¼ âˆ§ AEMeasurable f Î½ := by\n  rw [â† sum_cond, aemeasurable_sum_measure_iff, Bool.forall_bool, and_comm]\n  rfl\n\n"}
{"name":"AEMeasurable.add_measure","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœ : MeasurableSpace Î²\nÎ¼ Î½ : MeasureTheory.Measure Î±\nf : Î± â†’ Î²\nhÎ¼ : AEMeasurable f Î¼\nhÎ½ : AEMeasurable f Î½\nâŠ¢ AEMeasurable f (HAdd.hAdd Î¼ Î½)","decl":"@[measurability]\ntheorem add_measure {f : Î± â†’ Î²} (hÎ¼ : AEMeasurable f Î¼) (hÎ½ : AEMeasurable f Î½) :\n    AEMeasurable f (Î¼ + Î½) :=\n  aemeasurable_add_measure_iff.2 âŸ¨hÎ¼, hÎ½âŸ©\n\n"}
{"name":"AEMeasurable.iUnion","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\nf : Î± â†’ Î²\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : Countable Î¹\ns : Î¹ â†’ Set Î±\nh : âˆ€ (i : Î¹), AEMeasurable f (Î¼.restrict (s i))\nâŠ¢ AEMeasurable f (Î¼.restrict (Set.iUnion fun i => s i))","decl":"@[measurability]\nprotected theorem iUnion [Countable Î¹] {s : Î¹ â†’ Set Î±}\n    (h : âˆ€ i, AEMeasurable f (Î¼.restrict (s i))) : AEMeasurable f (Î¼.restrict (â‹ƒ i, s i)) :=\n  (sum_measure h).mono_measure <| restrict_iUnion_le\n\n"}
{"name":"aemeasurable_iUnion_iff","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\nf : Î± â†’ Î²\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : Countable Î¹\ns : Î¹ â†’ Set Î±\nâŠ¢ Iff (AEMeasurable f (Î¼.restrict (Set.iUnion fun i => s i))) (âˆ€ (i : Î¹), AEMeasurable f (Î¼.restrict (s i)))","decl":"@[simp]\ntheorem _root_.aemeasurable_iUnion_iff [Countable Î¹] {s : Î¹ â†’ Set Î±} :\n    AEMeasurable f (Î¼.restrict (â‹ƒ i, s i)) â†” âˆ€ i, AEMeasurable f (Î¼.restrict (s i)) :=\n  âŸ¨fun h _ => h.mono_measure <| restrict_mono (subset_iUnion _ _) le_rfl, AEMeasurable.iUnionâŸ©\n\n"}
{"name":"aemeasurable_union_iff","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœ : MeasurableSpace Î²\nf : Î± â†’ Î²\nÎ¼ : MeasureTheory.Measure Î±\ns t : Set Î±\nâŠ¢ Iff (AEMeasurable f (Î¼.restrict (Union.union s t))) (And (AEMeasurable f (Î¼.restrict s)) (AEMeasurable f (Î¼.restrict t)))","decl":"@[simp]\ntheorem _root_.aemeasurable_union_iff {s t : Set Î±} :\n    AEMeasurable f (Î¼.restrict (s âˆª t)) â†”\n      AEMeasurable f (Î¼.restrict s) âˆ§ AEMeasurable f (Î¼.restrict t) := by\n  simp only [union_eq_iUnion, aemeasurable_iUnion_iff, Bool.forall_bool, cond, and_comm]\n\n"}
{"name":"AEMeasurable.smul_measure","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nR : Type u_6\nm0 : MeasurableSpace Î±\ninstâœÂ³ : MeasurableSpace Î²\nf : Î± â†’ Î²\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : Monoid R\ninstâœÂ¹ : DistribMulAction R ENNReal\ninstâœ : IsScalarTower R ENNReal ENNReal\nh : AEMeasurable f Î¼\nc : R\nâŠ¢ AEMeasurable f (HSMul.hSMul c Î¼)","decl":"@[measurability]\ntheorem smul_measure [Monoid R] [DistribMulAction R â„â‰¥0âˆ] [IsScalarTower R â„â‰¥0âˆ â„â‰¥0âˆ]\n    (h : AEMeasurable f Î¼) (c : R) : AEMeasurable f (c â€¢ Î¼) :=\n  âŸ¨h.mk f, h.measurable_mk, ae_smul_measure h.ae_eq_mk câŸ©\n\n"}
{"name":"AEMeasurable.comp_aemeasurable","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nÎ´ : Type u_5\nm0 : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\ninstâœ : MeasurableSpace Î´\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Î´\ng : Î´ â†’ Î²\nhg : AEMeasurable g (MeasureTheory.Measure.map f Î¼)\nhf : AEMeasurable f Î¼\nâŠ¢ AEMeasurable (Function.comp g f) Î¼","decl":"theorem comp_aemeasurable {f : Î± â†’ Î´} {g : Î´ â†’ Î²} (hg : AEMeasurable g (Î¼.map f))\n    (hf : AEMeasurable f Î¼) : AEMeasurable (g âˆ˜ f) Î¼ :=\n  âŸ¨hg.mk g âˆ˜ hf.mk f, hg.measurable_mk.comp hf.measurable_mk,\n    (ae_eq_comp hf hg.ae_eq_mk).trans (hf.ae_eq_mk.fun_comp (mk g hg))âŸ©\n\n"}
{"name":"AEMeasurable.comp_aemeasurable'","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nÎ´ : Type u_5\nm0 : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\ninstâœ : MeasurableSpace Î´\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Î´\ng : Î´ â†’ Î²\nhg : AEMeasurable g (MeasureTheory.Measure.map f Î¼)\nhf : AEMeasurable f Î¼\nâŠ¢ AEMeasurable (fun x => g (f x)) Î¼","decl":"@[fun_prop]\ntheorem comp_aemeasurable' {f : Î± â†’ Î´} {g : Î´ â†’ Î²} (hg : AEMeasurable g (Î¼.map f))\n    (hf : AEMeasurable f Î¼) : AEMeasurable (fun x â†¦ g (f x)) Î¼ := comp_aemeasurable hg hf\n\n"}
{"name":"AEMeasurable.comp_measurable","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nÎ´ : Type u_5\nm0 : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\ninstâœ : MeasurableSpace Î´\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Î´\ng : Î´ â†’ Î²\nhg : AEMeasurable g (MeasureTheory.Measure.map f Î¼)\nhf : Measurable f\nâŠ¢ AEMeasurable (Function.comp g f) Î¼","decl":"theorem comp_measurable {f : Î± â†’ Î´} {g : Î´ â†’ Î²} (hg : AEMeasurable g (Î¼.map f))\n    (hf : Measurable f) : AEMeasurable (g âˆ˜ f) Î¼ :=\n  hg.comp_aemeasurable hf.aemeasurable\n\n"}
{"name":"AEMeasurable.comp_quasiMeasurePreserving","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nÎ´ : Type u_5\nm0 : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\ninstâœ : MeasurableSpace Î´\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î´\nf : Î± â†’ Î´\ng : Î´ â†’ Î²\nhg : AEMeasurable g Î½\nhf : MeasureTheory.Measure.QuasiMeasurePreserving f Î¼ Î½\nâŠ¢ AEMeasurable (Function.comp g f) Î¼","decl":"theorem comp_quasiMeasurePreserving {Î½ : Measure Î´} {f : Î± â†’ Î´} {g : Î´ â†’ Î²} (hg : AEMeasurable g Î½)\n    (hf : QuasiMeasurePreserving f Î¼ Î½) : AEMeasurable (g âˆ˜ f) Î¼ :=\n  (hg.mono' hf.absolutelyContinuous).comp_measurable hf.measurable\n\n"}
{"name":"AEMeasurable.map_map_of_aemeasurable","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\nm0 : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\ninstâœ : MeasurableSpace Î³\nÎ¼ : MeasureTheory.Measure Î±\ng : Î² â†’ Î³\nf : Î± â†’ Î²\nhg : AEMeasurable g (MeasureTheory.Measure.map f Î¼)\nhf : AEMeasurable f Î¼\nâŠ¢ Eq (MeasureTheory.Measure.map g (MeasureTheory.Measure.map f Î¼)) (MeasureTheory.Measure.map (Function.comp g f) Î¼)","decl":"theorem map_map_of_aemeasurable {g : Î² â†’ Î³} {f : Î± â†’ Î²} (hg : AEMeasurable g (Measure.map f Î¼))\n    (hf : AEMeasurable f Î¼) : (Î¼.map f).map g = Î¼.map (g âˆ˜ f) := by\n  ext1 s hs\n  rw [map_apply_of_aemeasurable hg hs, map_applyâ‚€ hf (hg.nullMeasurable hs),\n    map_apply_of_aemeasurable (hg.comp_aemeasurable hf) hs, preimage_comp]\n\n"}
{"name":"AEMeasurable.prod_mk","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\nm0 : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\ninstâœ : MeasurableSpace Î³\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Î²\ng : Î± â†’ Î³\nhf : AEMeasurable f Î¼\nhg : AEMeasurable g Î¼\nâŠ¢ AEMeasurable (fun x => { fst := f x, snd := g x }) Î¼","decl":"@[fun_prop, measurability]\ntheorem prod_mk {f : Î± â†’ Î²} {g : Î± â†’ Î³} (hf : AEMeasurable f Î¼) (hg : AEMeasurable g Î¼) :\n    AEMeasurable (fun x => (f x, g x)) Î¼ :=\n  âŸ¨fun a => (hf.mk f a, hg.mk g a), hf.measurable_mk.prod_mk hg.measurable_mk,\n    EventuallyEq.prod_mk hf.ae_eq_mk hg.ae_eq_mkâŸ©\n\n"}
{"name":"AEMeasurable.exists_ae_eq_range_subset","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœ : MeasurableSpace Î²\nf : Î± â†’ Î²\nÎ¼ : MeasureTheory.Measure Î±\nH : AEMeasurable f Î¼\nt : Set Î²\nht : Filter.Eventually (fun x => Membership.mem t (f x)) (MeasureTheory.ae Î¼)\nhâ‚€ : t.Nonempty\nâŠ¢ Exists fun g => And (Measurable g) (And (HasSubset.Subset (Set.range g) t) ((MeasureTheory.ae Î¼).EventuallyEq f g))","decl":"theorem exists_ae_eq_range_subset (H : AEMeasurable f Î¼) {t : Set Î²} (ht : âˆ€áµ x âˆ‚Î¼, f x âˆˆ t)\n    (hâ‚€ : t.Nonempty) : âˆƒ g, Measurable g âˆ§ range g âŠ† t âˆ§ f =áµ[Î¼] g := by\n  classical\n  let s : Set Î± := toMeasurable Î¼ { x | f x = H.mk f x âˆ§ f x âˆˆ t }á¶œ\n  let g : Î± â†’ Î² := piecewise s (fun _ => hâ‚€.some) (H.mk f)\n  refine âŸ¨g, ?_, ?_, ?_âŸ©\n  Â· exact Measurable.piecewise (measurableSet_toMeasurable _ _) measurable_const H.measurable_mk\n  Â· rintro _ âŸ¨x, rflâŸ©\n    by_cases hx : x âˆˆ s\n    Â· simpa [g, hx] using hâ‚€.some_mem\n    Â· simp only [g, hx, piecewise_eq_of_not_mem, not_false_iff]\n      contrapose! hx\n      apply subset_toMeasurable\n      simp +contextual only [hx, mem_compl_iff, mem_setOf_eq, not_and,\n        not_false_iff, imp_true_iff]\n  Â· have A : Î¼ (toMeasurable Î¼ { x | f x = H.mk f x âˆ§ f x âˆˆ t }á¶œ) = 0 := by\n      rw [measure_toMeasurable, â† compl_mem_ae_iff, compl_compl]\n      exact H.ae_eq_mk.and ht\n    filter_upwards [compl_mem_ae_iff.2 A] with x hx\n    rw [mem_compl_iff] at hx\n    simp only [s, g, hx, piecewise_eq_of_not_mem, not_false_iff]\n    contrapose! hx\n    apply subset_toMeasurable\n    simp only [hx, mem_compl_iff, mem_setOf_eq, false_and, not_false_iff]\n\n"}
{"name":"AEMeasurable.exists_measurable_nonneg","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ² : Type u_7\ninstâœÂ¹ : Preorder Î²\ninstâœ : Zero Î²\nmÎ² : MeasurableSpace Î²\nf : Î± â†’ Î²\nhf : AEMeasurable f Î¼\nf_nn : Filter.Eventually (fun t => LE.le 0 (f t)) (MeasureTheory.ae Î¼)\nâŠ¢ Exists fun g => And (Measurable g) (And (LE.le 0 g) ((MeasureTheory.ae Î¼).EventuallyEq f g))","decl":"theorem exists_measurable_nonneg {Î²} [Preorder Î²] [Zero Î²] {mÎ² : MeasurableSpace Î²} {f : Î± â†’ Î²}\n    (hf : AEMeasurable f Î¼) (f_nn : âˆ€áµ t âˆ‚Î¼, 0 â‰¤ f t) : âˆƒ g, Measurable g âˆ§ 0 â‰¤ g âˆ§ f =áµ[Î¼] g := by\n  obtain âŸ¨G, hG_meas, hG_mem, hG_ae_eqâŸ© := hf.exists_ae_eq_range_subset f_nn âŸ¨0, le_rflâŸ©\n  exact âŸ¨G, hG_meas, fun x => hG_mem (mem_range_self x), hG_ae_eqâŸ©\n\n"}
{"name":"AEMeasurable.subtype_mk","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœ : MeasurableSpace Î²\nf : Î± â†’ Î²\nÎ¼ : MeasureTheory.Measure Î±\nh : AEMeasurable f Î¼\ns : Set Î²\nhfs : âˆ€ (x : Î±), Membership.mem s (f x)\nâŠ¢ AEMeasurable (Set.codRestrict f s hfs) Î¼","decl":"theorem subtype_mk (h : AEMeasurable f Î¼) {s : Set Î²} {hfs : âˆ€ x, f x âˆˆ s} :\n    AEMeasurable (codRestrict f s hfs) Î¼ := by\n  nontriviality Î±; inhabit Î±\n  obtain âŸ¨g, g_meas, hg, fgâŸ© : âˆƒ g : Î± â†’ Î², Measurable g âˆ§ range g âŠ† s âˆ§ f =áµ[Î¼] g :=\n    h.exists_ae_eq_range_subset (Eventually.of_forall hfs) âŸ¨_, hfs defaultâŸ©\n  refine âŸ¨codRestrict g s fun x => hg (mem_range_self _), Measurable.subtype_mk g_meas, ?_âŸ©\n  filter_upwards [fg] with x hx\n  simpa [Subtype.ext_iff]\n\n"}
{"name":"aemeasurable_const'","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœ : MeasurableSpace Î²\nf : Î± â†’ Î²\nÎ¼ : MeasureTheory.Measure Î±\nh : Filter.Eventually (fun x => Filter.Eventually (fun y => Eq (f x) (f y)) (MeasureTheory.ae Î¼)) (MeasureTheory.ae Î¼)\nâŠ¢ AEMeasurable f Î¼","decl":"theorem aemeasurable_const' (h : âˆ€áµ (x) (y) âˆ‚Î¼, f x = f y) : AEMeasurable f Î¼ := by\n  rcases eq_or_ne Î¼ 0 with (rfl | hÎ¼)\n  Â· exact aemeasurable_zero_measure\n  Â· haveI := ae_neBot.2 hÎ¼\n    rcases h.exists with âŸ¨x, hxâŸ©\n    exact âŸ¨const Î± (f x), measurable_const, EventuallyEq.symm hxâŸ©\n\n"}
{"name":"aemeasurable_uIoc_iff","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : LinearOrder Î±\nf : Î± â†’ Î²\na b : Î±\nâŠ¢ Iff (AEMeasurable f (Î¼.restrict (Set.uIoc a b))) (And (AEMeasurable f (Î¼.restrict (Set.Ioc a b))) (AEMeasurable f (Î¼.restrict (Set.Ioc b a))))","decl":"theorem aemeasurable_uIoc_iff [LinearOrder Î±] {f : Î± â†’ Î²} {a b : Î±} :\n    (AEMeasurable f <| Î¼.restrict <| Î™ a b) â†”\n      (AEMeasurable f <| Î¼.restrict <| Ioc a b) âˆ§ (AEMeasurable f <| Î¼.restrict <| Ioc b a) := by\n  rw [uIoc_eq_union, aemeasurable_union_iff]\n\n"}
{"name":"aemeasurable_iff_measurable","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\nf : Î± â†’ Î²\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : Î¼.IsComplete\nâŠ¢ Iff (AEMeasurable f Î¼) (Measurable f)","decl":"theorem aemeasurable_iff_measurable [Î¼.IsComplete] : AEMeasurable f Î¼ â†” Measurable f :=\n  âŸ¨fun h => h.nullMeasurable.measurable_of_complete, fun h => h.aemeasurableâŸ©\n\n"}
{"name":"MeasurableEmbedding.aemeasurable_map_iff","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\nm0 : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\ninstâœ : MeasurableSpace Î³\nf : Î± â†’ Î²\nÎ¼ : MeasureTheory.Measure Î±\ng : Î² â†’ Î³\nhf : MeasurableEmbedding f\nâŠ¢ Iff (AEMeasurable g (MeasureTheory.Measure.map f Î¼)) (AEMeasurable (Function.comp g f) Î¼)","decl":"theorem MeasurableEmbedding.aemeasurable_map_iff {g : Î² â†’ Î³} (hf : MeasurableEmbedding f) :\n    AEMeasurable g (Î¼.map f) â†” AEMeasurable (g âˆ˜ f) Î¼ := by\n  refine âŸ¨fun H => H.comp_measurable hf.measurable, ?_âŸ©\n  rintro âŸ¨gâ‚, hgmâ‚, heqâŸ©\n  rcases hf.exists_measurable_extend hgmâ‚ fun x => âŸ¨g xâŸ© with âŸ¨gâ‚‚, hgmâ‚‚, rflâŸ©\n  exact âŸ¨gâ‚‚, hgmâ‚‚, hf.ae_map_iff.2 heqâŸ©\n\n"}
{"name":"MeasurableEmbedding.aemeasurable_comp_iff","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\nm0 : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\ninstâœ : MeasurableSpace Î³\nf : Î± â†’ Î²\ng : Î² â†’ Î³\nhg : MeasurableEmbedding g\nÎ¼ : MeasureTheory.Measure Î±\nâŠ¢ Iff (AEMeasurable (Function.comp g f) Î¼) (AEMeasurable f Î¼)","decl":"theorem MeasurableEmbedding.aemeasurable_comp_iff {g : Î² â†’ Î³} (hg : MeasurableEmbedding g)\n    {Î¼ : Measure Î±} : AEMeasurable (g âˆ˜ f) Î¼ â†” AEMeasurable f Î¼ := by\n  refine âŸ¨fun H => ?_, hg.measurable.comp_aemeasurableâŸ©\n  suffices AEMeasurable ((rangeSplitting g âˆ˜ rangeFactorization g) âˆ˜ f) Î¼ by\n    rwa [(rightInverse_rangeSplitting hg.injective).comp_eq_id] at this\n  exact hg.measurable_rangeSplitting.comp_aemeasurable H.subtype_mk\n\n"}
{"name":"aemeasurable_restrict_iff_comap_subtype","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœ : MeasurableSpace Î²\ns : Set Î±\nhs : MeasurableSet s\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Î²\nâŠ¢ Iff (AEMeasurable f (Î¼.restrict s)) (AEMeasurable (Function.comp f Subtype.val) (MeasureTheory.Measure.comap Subtype.val Î¼))","decl":"theorem aemeasurable_restrict_iff_comap_subtype {s : Set Î±} (hs : MeasurableSet s) {Î¼ : Measure Î±}\n    {f : Î± â†’ Î²} : AEMeasurable f (Î¼.restrict s) â†” AEMeasurable (f âˆ˜ (â†‘) : s â†’ Î²) (comap (â†‘) Î¼) := by\n  rw [â† map_comap_subtype_coe hs, (MeasurableEmbedding.subtype_coe hs).aemeasurable_map_iff]\n\n"}
{"name":"aemeasurable_one","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : One Î²\nâŠ¢ AEMeasurable (fun x => 1) Î¼","decl":"@[to_additive]\ntheorem aemeasurable_one [One Î²] : AEMeasurable (fun _ : Î± => (1 : Î²)) Î¼ :=\n  measurable_one.aemeasurable\n\n"}
{"name":"aemeasurable_zero","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : Zero Î²\nâŠ¢ AEMeasurable (fun x => 0) Î¼","decl":"@[to_additive]\ntheorem aemeasurable_one [One Î²] : AEMeasurable (fun _ : Î± => (1 : Î²)) Î¼ :=\n  measurable_one.aemeasurable\n\n"}
{"name":"aemeasurable_smul_measure_iff","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœ : MeasurableSpace Î²\nf : Î± â†’ Î²\nÎ¼ : MeasureTheory.Measure Î±\nc : ENNReal\nhc : Ne c 0\nâŠ¢ Iff (AEMeasurable f (HSMul.hSMul c Î¼)) (AEMeasurable f Î¼)","decl":"@[simp]\ntheorem aemeasurable_smul_measure_iff {c : â„â‰¥0âˆ} (hc : c â‰  0) :\n    AEMeasurable f (c â€¢ Î¼) â†” AEMeasurable f Î¼ :=\n  âŸ¨fun h => âŸ¨h.mk f, h.measurable_mk, (ae_smul_measure_iff hc).1 h.ae_eq_mkâŸ©, fun h =>\n    âŸ¨h.mk f, h.measurable_mk, (ae_smul_measure_iff hc).2 h.ae_eq_mkâŸ©âŸ©\n\n"}
{"name":"aemeasurable_of_aemeasurable_trim","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î² : Type u_3\ninstâœ : MeasurableSpace Î²\nÎ± : Type u_7\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nhm : LE.le m m0\nf : Î± â†’ Î²\nhf : AEMeasurable f (Î¼.trim hm)\nâŠ¢ AEMeasurable f Î¼","decl":"theorem aemeasurable_of_aemeasurable_trim {Î±} {m m0 : MeasurableSpace Î±} {Î¼ : Measure Î±}\n    (hm : m â‰¤ m0) {f : Î± â†’ Î²} (hf : AEMeasurable f (Î¼.trim hm)) : AEMeasurable f Î¼ :=\n  âŸ¨hf.mk f, Measurable.mono hf.measurable_mk hm le_rfl, ae_eq_of_ae_eq_trim hf.ae_eq_mkâŸ©\n\n"}
{"name":"aemeasurable_restrict_of_measurable_subtype","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœ : MeasurableSpace Î²\nf : Î± â†’ Î²\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nhs : MeasurableSet s\nhf : Measurable fun x => f â†‘x\nâŠ¢ AEMeasurable f (Î¼.restrict s)","decl":"theorem aemeasurable_restrict_of_measurable_subtype {s : Set Î±} (hs : MeasurableSet s)\n    (hf : Measurable fun x : s => f x) : AEMeasurable f (Î¼.restrict s) :=\n  (aemeasurable_restrict_iff_comap_subtype hs).2 hf.aemeasurable\n\n"}
{"name":"aemeasurable_map_equiv_iff","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\nm0 : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\ninstâœ : MeasurableSpace Î³\nÎ¼ : MeasureTheory.Measure Î±\ne : MeasurableEquiv Î± Î²\nf : Î² â†’ Î³\nâŠ¢ Iff (AEMeasurable f (MeasureTheory.Measure.map (â‡‘e) Î¼)) (AEMeasurable (Function.comp f â‡‘e) Î¼)","decl":"theorem aemeasurable_map_equiv_iff (e : Î± â‰ƒáµ Î²) {f : Î² â†’ Î³} :\n    AEMeasurable f (Î¼.map e) â†” AEMeasurable (f âˆ˜ e) Î¼ :=\n  e.measurableEmbedding.aemeasurable_map_iff\n\n"}
{"name":"AEMeasurable.restrict","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœ : MeasurableSpace Î²\nf : Î± â†’ Î²\nÎ¼ : MeasureTheory.Measure Î±\nhfm : AEMeasurable f Î¼\ns : Set Î±\nâŠ¢ AEMeasurable f (Î¼.restrict s)","decl":"theorem AEMeasurable.restrict (hfm : AEMeasurable f Î¼) {s} : AEMeasurable f (Î¼.restrict s) :=\n  âŸ¨AEMeasurable.mk f hfm, hfm.measurable_mk, ae_restrict_of_ae hfm.ae_eq_mkâŸ©\n\n"}
{"name":"aemeasurable_Ioi_of_forall_Ioc","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ² : Type u_7\nmÎ² : MeasurableSpace Î²\ninstâœÂ¹ : LinearOrder Î±\ninstâœ : Filter.atTop.IsCountablyGenerated\nx : Î±\ng : Î± â†’ Î²\ng_meas : âˆ€ (t : Î±), GT.gt t x â†’ AEMeasurable g (Î¼.restrict (Set.Ioc x t))\nâŠ¢ AEMeasurable g (Î¼.restrict (Set.Ioi x))","decl":"theorem aemeasurable_Ioi_of_forall_Ioc {Î²} {mÎ² : MeasurableSpace Î²} [LinearOrder Î±]\n    [(atTop : Filter Î±).IsCountablyGenerated] {x : Î±} {g : Î± â†’ Î²}\n    (g_meas : âˆ€ t > x, AEMeasurable g (Î¼.restrict (Ioc x t))) :\n    AEMeasurable g (Î¼.restrict (Ioi x)) := by\n  haveI : Nonempty Î± := âŸ¨xâŸ©\n  obtain âŸ¨u, hu_tendstoâŸ© := exists_seq_tendsto (atTop : Filter Î±)\n  have Ioi_eq_iUnion : Ioi x = â‹ƒ n : â„•, Ioc x (u n) := by\n    rw [iUnion_Ioc_eq_Ioi_self_iff.mpr _]\n    exact fun y _ => (hu_tendsto.eventually (eventually_ge_atTop y)).exists\n  rw [Ioi_eq_iUnion, aemeasurable_iUnion_iff]\n  intro n\n  cases' lt_or_le x (u n) with h h\n  Â· exact g_meas (u n) h\n  Â· rw [Ioc_eq_empty (not_lt.mpr h), Measure.restrict_empty]\n    exact aemeasurable_zero_measure\n\n"}
{"name":"aemeasurable_indicator_iff","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\nf : Î± â†’ Î²\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : Zero Î²\ns : Set Î±\nhs : MeasurableSet s\nâŠ¢ Iff (AEMeasurable (s.indicator f) Î¼) (AEMeasurable f (Î¼.restrict s))","decl":"theorem aemeasurable_indicator_iff {s} (hs : MeasurableSet s) :\n    AEMeasurable (indicator s f) Î¼ â†” AEMeasurable f (Î¼.restrict s) := by\n  constructor\n  Â· intro h\n    exact (h.mono_measure Measure.restrict_le_self).congr (indicator_ae_eq_restrict hs)\n  Â· intro h\n    refine âŸ¨indicator s (h.mk f), h.measurable_mk.indicator hs, ?_âŸ©\n    have A : s.indicator f =áµ[Î¼.restrict s] s.indicator (AEMeasurable.mk f h) :=\n      (indicator_ae_eq_restrict hs).trans (h.ae_eq_mk.trans <| (indicator_ae_eq_restrict hs).symm)\n    have B : s.indicator f =áµ[Î¼.restrict sá¶œ] s.indicator (AEMeasurable.mk f h) :=\n      (indicator_ae_eq_restrict_compl hs).trans (indicator_ae_eq_restrict_compl hs).symm\n    exact ae_of_ae_restrict_of_ae_restrict_compl _ A B\n\n"}
{"name":"aemeasurable_indicator_iffâ‚€","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\nf : Î± â†’ Î²\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : Zero Î²\ns : Set Î±\nhs : MeasureTheory.NullMeasurableSet s Î¼\nâŠ¢ Iff (AEMeasurable (s.indicator f) Î¼) (AEMeasurable f (Î¼.restrict s))","decl":"theorem aemeasurable_indicator_iffâ‚€ {s} (hs : NullMeasurableSet s Î¼) :\n    AEMeasurable (indicator s f) Î¼ â†” AEMeasurable f (Î¼.restrict s) := by\n  rcases hs with âŸ¨t, ht, hstâŸ©\n  rw [â† aemeasurable_congr (indicator_ae_eq_of_ae_eq_set hst.symm), aemeasurable_indicator_iff ht,\n      restrict_congr_set hst]\n\n"}
{"name":"aemeasurable_indicator_const_iff","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœÂ³ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : Zero Î²\ns : Set Î±\ninstâœÂ¹ : MeasurableSingletonClass Î²\nb : Î²\ninstâœ : NeZero b\nâŠ¢ Iff (AEMeasurable (s.indicator fun x => b) Î¼) (MeasureTheory.NullMeasurableSet s Î¼)","decl":"/-- A characterization of the a.e.-measurability of the indicator function which takes a constant\nvalue `b` on a set `A` and `0` elsewhere. -/\nlemma aemeasurable_indicator_const_iff {s} [MeasurableSingletonClass Î²] (b : Î²) [NeZero b] :\n    AEMeasurable (s.indicator (fun _ â†¦ b)) Î¼ â†” NullMeasurableSet s Î¼ := by\n  classical\n  constructor <;> intro h\n  Â· convert h.nullMeasurable (MeasurableSet.singleton (0 : Î²)).compl\n    rw [indicator_const_preimage_eq_union s {0}á¶œ b]\n    simp [NeZero.ne b]\n  Â· exact (aemeasurable_indicator_iffâ‚€ h).mpr aemeasurable_const\n\n"}
{"name":"AEMeasurable.indicator","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\nf : Î± â†’ Î²\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : Zero Î²\nhfm : AEMeasurable f Î¼\ns : Set Î±\nhs : MeasurableSet s\nâŠ¢ AEMeasurable (s.indicator f) Î¼","decl":"@[measurability]\ntheorem AEMeasurable.indicator (hfm : AEMeasurable f Î¼) {s} (hs : MeasurableSet s) :\n    AEMeasurable (s.indicator f) Î¼ :=\n  (aemeasurable_indicator_iff hs).mpr hfm.restrict\n\n"}
{"name":"AEMeasurable.indicatorâ‚€","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\nf : Î± â†’ Î²\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : Zero Î²\nhfm : AEMeasurable f Î¼\ns : Set Î±\nhs : MeasureTheory.NullMeasurableSet s Î¼\nâŠ¢ AEMeasurable (s.indicator f) Î¼","decl":"theorem AEMeasurable.indicatorâ‚€ (hfm : AEMeasurable f Î¼) {s} (hs : NullMeasurableSet s Î¼) :\n    AEMeasurable (s.indicator f) Î¼ :=\n  (aemeasurable_indicator_iffâ‚€ hs).mpr hfm.restrict\n\n"}
{"name":"MeasureTheory.Measure.restrict_map_of_aemeasurable","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ´ : Type u_5\nm0 : MeasurableSpace Î±\ninstâœ : MeasurableSpace Î´\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Î´\nhf : AEMeasurable f Î¼\ns : Set Î´\nhs : MeasurableSet s\nâŠ¢ Eq ((MeasureTheory.Measure.map f Î¼).restrict s) (MeasureTheory.Measure.map f (Î¼.restrict (Set.preimage f s)))","decl":"theorem MeasureTheory.Measure.restrict_map_of_aemeasurable {f : Î± â†’ Î´} (hf : AEMeasurable f Î¼)\n    {s : Set Î´} (hs : MeasurableSet s) : (Î¼.map f).restrict s = (Î¼.restrict <| f â»Â¹' s).map f :=\n  calc\n    (Î¼.map f).restrict s = (Î¼.map (hf.mk f)).restrict s := by\n      congr 1\n      apply Measure.map_congr hf.ae_eq_mk\n    _ = (Î¼.restrict <| hf.mk f â»Â¹' s).map (hf.mk f) := Measure.restrict_map hf.measurable_mk hs\n    _ = (Î¼.restrict <| hf.mk f â»Â¹' s).map f :=\n      (Measure.map_congr (ae_restrict_of_ae hf.ae_eq_mk.symm))\n    _ = (Î¼.restrict <| f â»Â¹' s).map f := by\n      apply congr_arg\n      ext1 t ht\n      simp only [ht, Measure.restrict_apply]\n      apply measure_congr\n      apply (EventuallyEq.refl _ _).inter (hf.ae_eq_mk.symm.preimage s)\n\n"}
{"name":"MeasureTheory.Measure.map_mono_of_aemeasurable","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ´ : Type u_5\nm0 : MeasurableSpace Î±\ninstâœ : MeasurableSpace Î´\nÎ¼ Î½ : MeasureTheory.Measure Î±\nf : Î± â†’ Î´\nh : LE.le Î¼ Î½\nhf : AEMeasurable f Î½\nâŠ¢ LE.le (MeasureTheory.Measure.map f Î¼) (MeasureTheory.Measure.map f Î½)","decl":"theorem MeasureTheory.Measure.map_mono_of_aemeasurable {f : Î± â†’ Î´} (h : Î¼ â‰¤ Î½)\n    (hf : AEMeasurable f Î½) : Î¼.map f â‰¤ Î½.map f :=\n  le_iff.2 fun s hs â†¦ by simpa [hf, hs, hf.mono_measure h] using h (f â»Â¹' s)\n\n"}
{"name":"MeasureTheory.NullMeasurable.aemeasurable","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Î²\nhc : MeasurableSpace.CountablyGenerated Î²\nh : MeasureTheory.NullMeasurable f Î¼\nâŠ¢ AEMeasurable f Î¼","decl":"/-- If the `Ïƒ`-algebra of the codomain of a null measurable function is countably generated,\nthen the function is a.e.-measurable. -/\nlemma MeasureTheory.NullMeasurable.aemeasurable {f : Î± â†’ Î²}\n    [hc : MeasurableSpace.CountablyGenerated Î²] (h : NullMeasurable f Î¼) : AEMeasurable f Î¼ := by\n  classical\n  nontriviality Î²; inhabit Î²\n  rcases hc.1 with âŸ¨S, hSc, rflâŸ©\n  choose! T hTf hTm hTeq using fun s hs â†¦ (h <| .basic s hs).exists_measurable_subset_ae_eq\n  choose! U hUf hUm hUeq using fun s hs â†¦ (h <| .basic s hs).exists_measurable_superset_ae_eq\n  set v := â‹ƒ s âˆˆ S, U s \\ T s\n  have hvm : MeasurableSet v := .biUnion hSc fun s hs â†¦ (hUm s hs).diff (hTm s hs)\n  have hvÎ¼ : Î¼ v = 0 := (measure_biUnion_null_iff hSc).2 fun s hs â†¦ ae_le_set.1 <|\n    ((hUeq s hs).trans (hTeq s hs).symm).le\n  refine âŸ¨v.piecewise (fun _ â†¦ default) f, ?_, measure_mono_null (fun x â†¦\n    not_imp_comm.2 fun hxv â†¦ (piecewise_eq_of_not_mem _ _ _ hxv).symm) hvÎ¼âŸ©\n  refine measurable_of_restrict_of_restrict_compl hvm ?_ ?_\n  Â· rw [restrict_piecewise]\n    apply measurable_const\n  Â· rw [restrict_piecewise_compl, restrict_eq]\n    refine measurable_generateFrom fun s hs â†¦ .of_subtype_image ?_\n    rw [preimage_comp, Subtype.image_preimage_coe]\n    convert (hTm s hs).diff hvm using 1\n    rw [inter_comm]\n    refine Set.ext fun x â†¦ and_congr_left fun hxv â†¦ âŸ¨fun hx â†¦ ?_, fun hx â†¦ hTf s hs hxâŸ©\n    exact by_contra fun hx' â†¦ hxv <| mem_biUnion hs âŸ¨hUf s hs hx, hx'âŸ©\n\n"}
{"name":"MeasureTheory.NullMeasurable.aemeasurable_of_aerange","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Î²\nt : Set Î²\ninstâœ : MeasurableSpace.CountablyGenerated â†‘t\nh : MeasureTheory.NullMeasurable f Î¼\nhft : Filter.Eventually (fun x => Membership.mem t (f x)) (MeasureTheory.ae Î¼)\nâŠ¢ AEMeasurable f Î¼","decl":"/-- Let `f : Î± â†’ Î²` be a null measurable function\nsuch that a.e. all values of `f` belong to a set `t`\nsuch that the restriction of the `Ïƒ`-algebra in the codomain to `t` is countably generated,\nthen `f` is a.e.-measurable. -/\nlemma MeasureTheory.NullMeasurable.aemeasurable_of_aerange {f : Î± â†’ Î²} {t : Set Î²}\n    [MeasurableSpace.CountablyGenerated t] (h : NullMeasurable f Î¼) (hft : âˆ€áµ x âˆ‚Î¼, f x âˆˆ t) :\n    AEMeasurable f Î¼ := by\n  rcases eq_empty_or_nonempty t with rfl | hne\n  Â· obtain rfl : Î¼ = 0 := by simpa using hft\n    apply aemeasurable_zero_measure\n  Â· rw [â† Î¼.ae_completion] at hft\n    obtain âŸ¨f', hf'm, hf't, hff'âŸ© :\n        âˆƒ f' : Î± â†’ Î², NullMeasurable f' Î¼ âˆ§ range f' âŠ† t âˆ§ f =áµ[Î¼] f' :=\n      h.measurable'.aemeasurable.exists_ae_eq_range_subset hft hne\n    rw [range_subset_iff] at hf't\n    lift f' to Î± â†’ t using hf't\n    replace hf'm : NullMeasurable f' Î¼ := hf'm.measurable'.subtype_mk\n    exact (measurable_subtype_coe.comp_aemeasurable hf'm.aemeasurable).congr hff'.symm\n\n"}
{"name":"MeasureTheory.Measure.map_sum","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœ : MeasurableSpace Î²\nÎ¹ : Type u_7\nm : Î¹ â†’ MeasureTheory.Measure Î±\nf : Î± â†’ Î²\nhf : AEMeasurable f (MeasureTheory.Measure.sum m)\nâŠ¢ Eq (MeasureTheory.Measure.map f (MeasureTheory.Measure.sum m)) (MeasureTheory.Measure.sum fun i => MeasureTheory.Measure.map f (m i))","decl":"lemma map_sum {Î¹ : Type*} {m : Î¹ â†’ Measure Î±} {f : Î± â†’ Î²} (hf : AEMeasurable f (Measure.sum m)) :\n    Measure.map f (Measure.sum m) = Measure.sum (fun i â†¦ Measure.map f (m i)) := by\n  ext s hs\n  rw [map_apply_of_aemeasurable hf hs, sum_applyâ‚€ _ (hf.nullMeasurable hs), sum_apply _ hs]\n  have M i : AEMeasurable f (m i) := hf.mono_measure (le_sum m i)\n  simp_rw [map_apply_of_aemeasurable (M _) hs]\n\n"}
{"name":"MeasureTheory.Measure.instSFiniteMap","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nm0 : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Î²\ninstâœ : MeasureTheory.SFinite Î¼\nâŠ¢ MeasureTheory.SFinite (MeasureTheory.Measure.map f Î¼)","decl":"instance (Î¼ : Measure Î±) (f : Î± â†’ Î²) [SFinite Î¼] : SFinite (Î¼.map f) := by\n  by_cases H : AEMeasurable f Î¼\n  Â· rw [â† sum_sfiniteSeq Î¼] at H âŠ¢\n    rw [map_sum H]\n    infer_instance\n  Â· rw [map_of_not_aemeasurable H]\n    infer_instance\n\n"}
