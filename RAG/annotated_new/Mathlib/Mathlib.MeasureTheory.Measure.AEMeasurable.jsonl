{"name":"Subsingleton.aemeasurable","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure α\ninst✝ : Subsingleton α\n⊢ AEMeasurable f μ","decl":"@[nontriviality, measurability]\ntheorem Subsingleton.aemeasurable [Subsingleton α] : AEMeasurable f μ :=\n  Subsingleton.measurable.aemeasurable\n\n"}
{"name":"aemeasurable_of_subsingleton_codomain","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure α\ninst✝ : Subsingleton β\n⊢ AEMeasurable f μ","decl":"@[nontriviality, measurability]\ntheorem aemeasurable_of_subsingleton_codomain [Subsingleton β] : AEMeasurable f μ :=\n  (measurable_of_subsingleton_codomain f).aemeasurable\n\n"}
{"name":"aemeasurable_zero_measure","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\n⊢ AEMeasurable f 0","decl":"@[simp, measurability]\ntheorem aemeasurable_zero_measure : AEMeasurable f (0 : Measure α) := by\n  nontriviality α; inhabit α\n  exact ⟨fun _ => f default, measurable_const, rfl⟩\n\n"}
{"name":"aemeasurable_id''","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nm : MeasurableSpace α\nhm : LE.le m m0\n⊢ AEMeasurable id μ","decl":"@[fun_prop]\ntheorem aemeasurable_id'' (μ : Measure α) {m : MeasurableSpace α} (hm : m ≤ m0) :\n    @AEMeasurable α α m m0 id μ :=\n  @Measurable.aemeasurable α α m0 m id μ (measurable_id'' hm)\n\n"}
{"name":"aemeasurable_of_map_neZero","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : α → β\nh : NeZero (MeasureTheory.Measure.map f μ)\n⊢ AEMeasurable f μ","decl":"lemma aemeasurable_of_map_neZero {μ : Measure α}\n    {f : α → β} (h : NeZero (μ.map f)) :\n    AEMeasurable f μ := by\n  by_contra h'\n  simp [h'] at h\n\n"}
{"name":"AEMeasurable.mono_ac","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\nμ ν : MeasureTheory.Measure α\nhf : AEMeasurable f ν\nhμν : μ.AbsolutelyContinuous ν\n⊢ AEMeasurable f μ","decl":"lemma mono_ac (hf : AEMeasurable f ν) (hμν : μ ≪ ν) : AEMeasurable f μ :=\n  ⟨hf.mk f, hf.measurable_mk, hμν.ae_le hf.ae_eq_mk⟩\n\n"}
{"name":"AEMeasurable.mono_measure","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\nμ ν : MeasureTheory.Measure α\nh : AEMeasurable f μ\nh' : LE.le ν μ\n⊢ AEMeasurable f ν","decl":"theorem mono_measure (h : AEMeasurable f μ) (h' : ν ≤ μ) : AEMeasurable f ν :=\n  mono_ac h h'.absolutelyContinuous\n\n"}
{"name":"AEMeasurable.mono_set","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure α\ns t : Set α\nh : HasSubset.Subset s t\nht : AEMeasurable f (μ.restrict t)\n⊢ AEMeasurable f (μ.restrict s)","decl":"theorem mono_set {s t} (h : s ⊆ t) (ht : AEMeasurable f (μ.restrict t)) :\n    AEMeasurable f (μ.restrict s) :=\n  ht.mono_measure (restrict_mono h le_rfl)\n\n"}
{"name":"AEMeasurable.mono'","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\nμ ν : MeasureTheory.Measure α\nh : AEMeasurable f μ\nh' : ν.AbsolutelyContinuous μ\n⊢ AEMeasurable f ν","decl":"@[fun_prop]\nprotected theorem mono' (h : AEMeasurable f μ) (h' : ν ≪ μ) : AEMeasurable f ν :=\n  ⟨h.mk f, h.measurable_mk, h' h.ae_eq_mk⟩\n\n"}
{"name":"AEMeasurable.ae_mem_imp_eq_mk","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure α\ns : Set α\nh : AEMeasurable f (μ.restrict s)\n⊢ Filter.Eventually (fun x => Membership.mem s x → Eq (f x) (AEMeasurable.mk f h x)) (MeasureTheory.ae μ)","decl":"theorem ae_mem_imp_eq_mk {s} (h : AEMeasurable f (μ.restrict s)) :\n    ∀ᵐ x ∂μ, x ∈ s → f x = h.mk f x :=\n  ae_imp_of_ae_restrict h.ae_eq_mk\n\n"}
{"name":"AEMeasurable.ae_inf_principal_eq_mk","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure α\ns : Set α\nh : AEMeasurable f (μ.restrict s)\n⊢ (Min.min (MeasureTheory.ae μ) (Filter.principal s)).EventuallyEq f (AEMeasurable.mk f h)","decl":"theorem ae_inf_principal_eq_mk {s} (h : AEMeasurable f (μ.restrict s)) : f =ᶠ[ae μ ⊓ 𝓟 s] h.mk f :=\n  le_ae_restrict h.ae_eq_mk\n\n"}
{"name":"AEMeasurable.sum_measure","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nf : α → β\ninst✝ : Countable ι\nμ : ι → MeasureTheory.Measure α\nh : ∀ (i : ι), AEMeasurable f (μ i)\n⊢ AEMeasurable f (MeasureTheory.Measure.sum μ)","decl":"@[measurability]\ntheorem sum_measure [Countable ι] {μ : ι → Measure α} (h : ∀ i, AEMeasurable f (μ i)) :\n    AEMeasurable f (sum μ) := by\n  classical\n  nontriviality β\n  inhabit β\n  set s : ι → Set α := fun i => toMeasurable (μ i) { x | f x ≠ (h i).mk f x }\n  have hsμ : ∀ i, μ i (s i) = 0 := by\n    intro i\n    rw [measure_toMeasurable]\n    exact (h i).ae_eq_mk\n  have hsm : MeasurableSet (⋂ i, s i) :=\n    MeasurableSet.iInter fun i => measurableSet_toMeasurable _ _\n  have hs : ∀ i x, x ∉ s i → f x = (h i).mk f x := by\n    intro i x hx\n    contrapose! hx\n    exact subset_toMeasurable _ _ hx\n  set g : α → β := (⋂ i, s i).piecewise (const α default) f\n  refine ⟨g, measurable_of_restrict_of_restrict_compl hsm ?_ ?_, ae_sum_iff.mpr fun i => ?_⟩\n  · rw [restrict_piecewise]\n    simp only [s, Set.restrict, const]\n    exact measurable_const\n  · rw [restrict_piecewise_compl, compl_iInter]\n    intro t ht\n    refine ⟨⋃ i, (h i).mk f ⁻¹' t ∩ (s i)ᶜ, MeasurableSet.iUnion fun i ↦\n      (measurable_mk _ ht).inter (measurableSet_toMeasurable _ _).compl, ?_⟩\n    ext ⟨x, hx⟩\n    simp only [mem_preimage, mem_iUnion, Subtype.coe_mk, Set.restrict, mem_inter_iff,\n      mem_compl_iff] at hx ⊢\n    constructor\n    · rintro ⟨i, hxt, hxs⟩\n      rwa [hs _ _ hxs]\n    · rcases hx with ⟨i, hi⟩\n      rw [hs _ _ hi]\n      exact fun h => ⟨i, h, hi⟩\n  · refine measure_mono_null (fun x (hx : f x ≠ g x) => ?_) (hsμ i)\n    contrapose! hx\n    refine (piecewise_eq_of_not_mem _ _ _ ?_).symm\n    exact fun h => hx (mem_iInter.1 h i)\n\n"}
{"name":"aemeasurable_sum_measure_iff","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nf : α → β\ninst✝ : Countable ι\nμ : ι → MeasureTheory.Measure α\n⊢ Iff (AEMeasurable f (MeasureTheory.Measure.sum μ)) (∀ (i : ι), AEMeasurable f (μ i))","decl":"@[simp]\ntheorem _root_.aemeasurable_sum_measure_iff [Countable ι] {μ : ι → Measure α} :\n    AEMeasurable f (sum μ) ↔ ∀ i, AEMeasurable f (μ i) :=\n  ⟨fun h _ => h.mono_measure (le_sum _ _), sum_measure⟩\n\n"}
{"name":"aemeasurable_add_measure_iff","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\nμ ν : MeasureTheory.Measure α\n⊢ Iff (AEMeasurable f (HAdd.hAdd μ ν)) (And (AEMeasurable f μ) (AEMeasurable f ν))","decl":"@[simp]\ntheorem _root_.aemeasurable_add_measure_iff :\n    AEMeasurable f (μ + ν) ↔ AEMeasurable f μ ∧ AEMeasurable f ν := by\n  rw [← sum_cond, aemeasurable_sum_measure_iff, Bool.forall_bool, and_comm]\n  rfl\n\n"}
{"name":"AEMeasurable.add_measure","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμ ν : MeasureTheory.Measure α\nf : α → β\nhμ : AEMeasurable f μ\nhν : AEMeasurable f ν\n⊢ AEMeasurable f (HAdd.hAdd μ ν)","decl":"@[measurability]\ntheorem add_measure {f : α → β} (hμ : AEMeasurable f μ) (hν : AEMeasurable f ν) :\n    AEMeasurable f (μ + ν) :=\n  aemeasurable_add_measure_iff.2 ⟨hμ, hν⟩\n\n"}
{"name":"AEMeasurable.iUnion","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure α\ninst✝ : Countable ι\ns : ι → Set α\nh : ∀ (i : ι), AEMeasurable f (μ.restrict (s i))\n⊢ AEMeasurable f (μ.restrict (Set.iUnion fun i => s i))","decl":"@[measurability]\nprotected theorem iUnion [Countable ι] {s : ι → Set α}\n    (h : ∀ i, AEMeasurable f (μ.restrict (s i))) : AEMeasurable f (μ.restrict (⋃ i, s i)) :=\n  (sum_measure h).mono_measure <| restrict_iUnion_le\n\n"}
{"name":"aemeasurable_iUnion_iff","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure α\ninst✝ : Countable ι\ns : ι → Set α\n⊢ Iff (AEMeasurable f (μ.restrict (Set.iUnion fun i => s i))) (∀ (i : ι), AEMeasurable f (μ.restrict (s i)))","decl":"@[simp]\ntheorem _root_.aemeasurable_iUnion_iff [Countable ι] {s : ι → Set α} :\n    AEMeasurable f (μ.restrict (⋃ i, s i)) ↔ ∀ i, AEMeasurable f (μ.restrict (s i)) :=\n  ⟨fun h _ => h.mono_measure <| restrict_mono (subset_iUnion _ _) le_rfl, AEMeasurable.iUnion⟩\n\n"}
{"name":"aemeasurable_union_iff","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure α\ns t : Set α\n⊢ Iff (AEMeasurable f (μ.restrict (Union.union s t))) (And (AEMeasurable f (μ.restrict s)) (AEMeasurable f (μ.restrict t)))","decl":"@[simp]\ntheorem _root_.aemeasurable_union_iff {s t : Set α} :\n    AEMeasurable f (μ.restrict (s ∪ t)) ↔\n      AEMeasurable f (μ.restrict s) ∧ AEMeasurable f (μ.restrict t) := by\n  simp only [union_eq_iUnion, aemeasurable_iUnion_iff, Bool.forall_bool, cond, and_comm]\n\n"}
{"name":"AEMeasurable.smul_measure","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nR : Type u_6\nm0 : MeasurableSpace α\ninst✝³ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure α\ninst✝² : Monoid R\ninst✝¹ : DistribMulAction R ENNReal\ninst✝ : IsScalarTower R ENNReal ENNReal\nh : AEMeasurable f μ\nc : R\n⊢ AEMeasurable f (HSMul.hSMul c μ)","decl":"@[measurability]\ntheorem smul_measure [Monoid R] [DistribMulAction R ℝ≥0∞] [IsScalarTower R ℝ≥0∞ ℝ≥0∞]\n    (h : AEMeasurable f μ) (c : R) : AEMeasurable f (c • μ) :=\n  ⟨h.mk f, h.measurable_mk, ae_smul_measure h.ae_eq_mk c⟩\n\n"}
{"name":"AEMeasurable.comp_aemeasurable","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nδ : Type u_5\nm0 : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace δ\nμ : MeasureTheory.Measure α\nf : α → δ\ng : δ → β\nhg : AEMeasurable g (MeasureTheory.Measure.map f μ)\nhf : AEMeasurable f μ\n⊢ AEMeasurable (Function.comp g f) μ","decl":"theorem comp_aemeasurable {f : α → δ} {g : δ → β} (hg : AEMeasurable g (μ.map f))\n    (hf : AEMeasurable f μ) : AEMeasurable (g ∘ f) μ :=\n  ⟨hg.mk g ∘ hf.mk f, hg.measurable_mk.comp hf.measurable_mk,\n    (ae_eq_comp hf hg.ae_eq_mk).trans (hf.ae_eq_mk.fun_comp (mk g hg))⟩\n\n"}
{"name":"AEMeasurable.comp_aemeasurable'","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nδ : Type u_5\nm0 : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace δ\nμ : MeasureTheory.Measure α\nf : α → δ\ng : δ → β\nhg : AEMeasurable g (MeasureTheory.Measure.map f μ)\nhf : AEMeasurable f μ\n⊢ AEMeasurable (fun x => g (f x)) μ","decl":"@[fun_prop]\ntheorem comp_aemeasurable' {f : α → δ} {g : δ → β} (hg : AEMeasurable g (μ.map f))\n    (hf : AEMeasurable f μ) : AEMeasurable (fun x ↦ g (f x)) μ := comp_aemeasurable hg hf\n\n"}
{"name":"AEMeasurable.comp_measurable","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nδ : Type u_5\nm0 : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace δ\nμ : MeasureTheory.Measure α\nf : α → δ\ng : δ → β\nhg : AEMeasurable g (MeasureTheory.Measure.map f μ)\nhf : Measurable f\n⊢ AEMeasurable (Function.comp g f) μ","decl":"theorem comp_measurable {f : α → δ} {g : δ → β} (hg : AEMeasurable g (μ.map f))\n    (hf : Measurable f) : AEMeasurable (g ∘ f) μ :=\n  hg.comp_aemeasurable hf.aemeasurable\n\n"}
{"name":"AEMeasurable.comp_quasiMeasurePreserving","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nδ : Type u_5\nm0 : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace δ\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure δ\nf : α → δ\ng : δ → β\nhg : AEMeasurable g ν\nhf : MeasureTheory.Measure.QuasiMeasurePreserving f μ ν\n⊢ AEMeasurable (Function.comp g f) μ","decl":"theorem comp_quasiMeasurePreserving {ν : Measure δ} {f : α → δ} {g : δ → β} (hg : AEMeasurable g ν)\n    (hf : QuasiMeasurePreserving f μ ν) : AEMeasurable (g ∘ f) μ :=\n  (hg.mono' hf.absolutelyContinuous).comp_measurable hf.measurable\n\n"}
{"name":"AEMeasurable.map_map_of_aemeasurable","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\nm0 : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace γ\nμ : MeasureTheory.Measure α\ng : β → γ\nf : α → β\nhg : AEMeasurable g (MeasureTheory.Measure.map f μ)\nhf : AEMeasurable f μ\n⊢ Eq (MeasureTheory.Measure.map g (MeasureTheory.Measure.map f μ)) (MeasureTheory.Measure.map (Function.comp g f) μ)","decl":"theorem map_map_of_aemeasurable {g : β → γ} {f : α → β} (hg : AEMeasurable g (Measure.map f μ))\n    (hf : AEMeasurable f μ) : (μ.map f).map g = μ.map (g ∘ f) := by\n  ext1 s hs\n  rw [map_apply_of_aemeasurable hg hs, map_apply₀ hf (hg.nullMeasurable hs),\n    map_apply_of_aemeasurable (hg.comp_aemeasurable hf) hs, preimage_comp]\n\n"}
{"name":"AEMeasurable.prod_mk","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\nm0 : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace γ\nμ : MeasureTheory.Measure α\nf : α → β\ng : α → γ\nhf : AEMeasurable f μ\nhg : AEMeasurable g μ\n⊢ AEMeasurable (fun x => { fst := f x, snd := g x }) μ","decl":"@[fun_prop, measurability]\ntheorem prod_mk {f : α → β} {g : α → γ} (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    AEMeasurable (fun x => (f x, g x)) μ :=\n  ⟨fun a => (hf.mk f a, hg.mk g a), hf.measurable_mk.prod_mk hg.measurable_mk,\n    EventuallyEq.prod_mk hf.ae_eq_mk hg.ae_eq_mk⟩\n\n"}
{"name":"AEMeasurable.exists_ae_eq_range_subset","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure α\nH : AEMeasurable f μ\nt : Set β\nht : Filter.Eventually (fun x => Membership.mem t (f x)) (MeasureTheory.ae μ)\nh₀ : t.Nonempty\n⊢ Exists fun g => And (Measurable g) (And (HasSubset.Subset (Set.range g) t) ((MeasureTheory.ae μ).EventuallyEq f g))","decl":"theorem exists_ae_eq_range_subset (H : AEMeasurable f μ) {t : Set β} (ht : ∀ᵐ x ∂μ, f x ∈ t)\n    (h₀ : t.Nonempty) : ∃ g, Measurable g ∧ range g ⊆ t ∧ f =ᵐ[μ] g := by\n  classical\n  let s : Set α := toMeasurable μ { x | f x = H.mk f x ∧ f x ∈ t }ᶜ\n  let g : α → β := piecewise s (fun _ => h₀.some) (H.mk f)\n  refine ⟨g, ?_, ?_, ?_⟩\n  · exact Measurable.piecewise (measurableSet_toMeasurable _ _) measurable_const H.measurable_mk\n  · rintro _ ⟨x, rfl⟩\n    by_cases hx : x ∈ s\n    · simpa [g, hx] using h₀.some_mem\n    · simp only [g, hx, piecewise_eq_of_not_mem, not_false_iff]\n      contrapose! hx\n      apply subset_toMeasurable\n      simp +contextual only [hx, mem_compl_iff, mem_setOf_eq, not_and,\n        not_false_iff, imp_true_iff]\n  · have A : μ (toMeasurable μ { x | f x = H.mk f x ∧ f x ∈ t }ᶜ) = 0 := by\n      rw [measure_toMeasurable, ← compl_mem_ae_iff, compl_compl]\n      exact H.ae_eq_mk.and ht\n    filter_upwards [compl_mem_ae_iff.2 A] with x hx\n    rw [mem_compl_iff] at hx\n    simp only [s, g, hx, piecewise_eq_of_not_mem, not_false_iff]\n    contrapose! hx\n    apply subset_toMeasurable\n    simp only [hx, mem_compl_iff, mem_setOf_eq, false_and, not_false_iff]\n\n"}
{"name":"AEMeasurable.exists_measurable_nonneg","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nβ : Type u_7\ninst✝¹ : Preorder β\ninst✝ : Zero β\nmβ : MeasurableSpace β\nf : α → β\nhf : AEMeasurable f μ\nf_nn : Filter.Eventually (fun t => LE.le 0 (f t)) (MeasureTheory.ae μ)\n⊢ Exists fun g => And (Measurable g) (And (LE.le 0 g) ((MeasureTheory.ae μ).EventuallyEq f g))","decl":"theorem exists_measurable_nonneg {β} [Preorder β] [Zero β] {mβ : MeasurableSpace β} {f : α → β}\n    (hf : AEMeasurable f μ) (f_nn : ∀ᵐ t ∂μ, 0 ≤ f t) : ∃ g, Measurable g ∧ 0 ≤ g ∧ f =ᵐ[μ] g := by\n  obtain ⟨G, hG_meas, hG_mem, hG_ae_eq⟩ := hf.exists_ae_eq_range_subset f_nn ⟨0, le_rfl⟩\n  exact ⟨G, hG_meas, fun x => hG_mem (mem_range_self x), hG_ae_eq⟩\n\n"}
{"name":"AEMeasurable.subtype_mk","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure α\nh : AEMeasurable f μ\ns : Set β\nhfs : ∀ (x : α), Membership.mem s (f x)\n⊢ AEMeasurable (Set.codRestrict f s hfs) μ","decl":"theorem subtype_mk (h : AEMeasurable f μ) {s : Set β} {hfs : ∀ x, f x ∈ s} :\n    AEMeasurable (codRestrict f s hfs) μ := by\n  nontriviality α; inhabit α\n  obtain ⟨g, g_meas, hg, fg⟩ : ∃ g : α → β, Measurable g ∧ range g ⊆ s ∧ f =ᵐ[μ] g :=\n    h.exists_ae_eq_range_subset (Eventually.of_forall hfs) ⟨_, hfs default⟩\n  refine ⟨codRestrict g s fun x => hg (mem_range_self _), Measurable.subtype_mk g_meas, ?_⟩\n  filter_upwards [fg] with x hx\n  simpa [Subtype.ext_iff]\n\n"}
{"name":"aemeasurable_const'","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure α\nh : Filter.Eventually (fun x => Filter.Eventually (fun y => Eq (f x) (f y)) (MeasureTheory.ae μ)) (MeasureTheory.ae μ)\n⊢ AEMeasurable f μ","decl":"theorem aemeasurable_const' (h : ∀ᵐ (x) (y) ∂μ, f x = f y) : AEMeasurable f μ := by\n  rcases eq_or_ne μ 0 with (rfl | hμ)\n  · exact aemeasurable_zero_measure\n  · haveI := ae_neBot.2 hμ\n    rcases h.exists with ⟨x, hx⟩\n    exact ⟨const α (f x), measurable_const, EventuallyEq.symm hx⟩\n\n"}
{"name":"aemeasurable_uIoc_iff","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\ninst✝ : LinearOrder α\nf : α → β\na b : α\n⊢ Iff (AEMeasurable f (μ.restrict (Set.uIoc a b))) (And (AEMeasurable f (μ.restrict (Set.Ioc a b))) (AEMeasurable f (μ.restrict (Set.Ioc b a))))","decl":"theorem aemeasurable_uIoc_iff [LinearOrder α] {f : α → β} {a b : α} :\n    (AEMeasurable f <| μ.restrict <| Ι a b) ↔\n      (AEMeasurable f <| μ.restrict <| Ioc a b) ∧ (AEMeasurable f <| μ.restrict <| Ioc b a) := by\n  rw [uIoc_eq_union, aemeasurable_union_iff]\n\n"}
{"name":"aemeasurable_iff_measurable","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure α\ninst✝ : μ.IsComplete\n⊢ Iff (AEMeasurable f μ) (Measurable f)","decl":"theorem aemeasurable_iff_measurable [μ.IsComplete] : AEMeasurable f μ ↔ Measurable f :=\n  ⟨fun h => h.nullMeasurable.measurable_of_complete, fun h => h.aemeasurable⟩\n\n"}
{"name":"MeasurableEmbedding.aemeasurable_map_iff","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\nm0 : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace γ\nf : α → β\nμ : MeasureTheory.Measure α\ng : β → γ\nhf : MeasurableEmbedding f\n⊢ Iff (AEMeasurable g (MeasureTheory.Measure.map f μ)) (AEMeasurable (Function.comp g f) μ)","decl":"theorem MeasurableEmbedding.aemeasurable_map_iff {g : β → γ} (hf : MeasurableEmbedding f) :\n    AEMeasurable g (μ.map f) ↔ AEMeasurable (g ∘ f) μ := by\n  refine ⟨fun H => H.comp_measurable hf.measurable, ?_⟩\n  rintro ⟨g₁, hgm₁, heq⟩\n  rcases hf.exists_measurable_extend hgm₁ fun x => ⟨g x⟩ with ⟨g₂, hgm₂, rfl⟩\n  exact ⟨g₂, hgm₂, hf.ae_map_iff.2 heq⟩\n\n"}
{"name":"MeasurableEmbedding.aemeasurable_comp_iff","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\nm0 : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace γ\nf : α → β\ng : β → γ\nhg : MeasurableEmbedding g\nμ : MeasureTheory.Measure α\n⊢ Iff (AEMeasurable (Function.comp g f) μ) (AEMeasurable f μ)","decl":"theorem MeasurableEmbedding.aemeasurable_comp_iff {g : β → γ} (hg : MeasurableEmbedding g)\n    {μ : Measure α} : AEMeasurable (g ∘ f) μ ↔ AEMeasurable f μ := by\n  refine ⟨fun H => ?_, hg.measurable.comp_aemeasurable⟩\n  suffices AEMeasurable ((rangeSplitting g ∘ rangeFactorization g) ∘ f) μ by\n    rwa [(rightInverse_rangeSplitting hg.injective).comp_eq_id] at this\n  exact hg.measurable_rangeSplitting.comp_aemeasurable H.subtype_mk\n\n"}
{"name":"aemeasurable_restrict_iff_comap_subtype","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝ : MeasurableSpace β\ns : Set α\nhs : MeasurableSet s\nμ : MeasureTheory.Measure α\nf : α → β\n⊢ Iff (AEMeasurable f (μ.restrict s)) (AEMeasurable (Function.comp f Subtype.val) (MeasureTheory.Measure.comap Subtype.val μ))","decl":"theorem aemeasurable_restrict_iff_comap_subtype {s : Set α} (hs : MeasurableSet s) {μ : Measure α}\n    {f : α → β} : AEMeasurable f (μ.restrict s) ↔ AEMeasurable (f ∘ (↑) : s → β) (comap (↑) μ) := by\n  rw [← map_comap_subtype_coe hs, (MeasurableEmbedding.subtype_coe hs).aemeasurable_map_iff]\n\n"}
{"name":"aemeasurable_one","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\ninst✝ : One β\n⊢ AEMeasurable (fun x => 1) μ","decl":"@[to_additive]\ntheorem aemeasurable_one [One β] : AEMeasurable (fun _ : α => (1 : β)) μ :=\n  measurable_one.aemeasurable\n\n"}
{"name":"aemeasurable_zero","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\ninst✝ : Zero β\n⊢ AEMeasurable (fun x => 0) μ","decl":"@[to_additive]\ntheorem aemeasurable_one [One β] : AEMeasurable (fun _ : α => (1 : β)) μ :=\n  measurable_one.aemeasurable\n\n"}
{"name":"aemeasurable_smul_measure_iff","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure α\nc : ENNReal\nhc : Ne c 0\n⊢ Iff (AEMeasurable f (HSMul.hSMul c μ)) (AEMeasurable f μ)","decl":"@[simp]\ntheorem aemeasurable_smul_measure_iff {c : ℝ≥0∞} (hc : c ≠ 0) :\n    AEMeasurable f (c • μ) ↔ AEMeasurable f μ :=\n  ⟨fun h => ⟨h.mk f, h.measurable_mk, (ae_smul_measure_iff hc).1 h.ae_eq_mk⟩, fun h =>\n    ⟨h.mk f, h.measurable_mk, (ae_smul_measure_iff hc).2 h.ae_eq_mk⟩⟩\n\n"}
{"name":"aemeasurable_of_aemeasurable_trim","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"β : Type u_3\ninst✝ : MeasurableSpace β\nα : Type u_7\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nhm : LE.le m m0\nf : α → β\nhf : AEMeasurable f (μ.trim hm)\n⊢ AEMeasurable f μ","decl":"theorem aemeasurable_of_aemeasurable_trim {α} {m m0 : MeasurableSpace α} {μ : Measure α}\n    (hm : m ≤ m0) {f : α → β} (hf : AEMeasurable f (μ.trim hm)) : AEMeasurable f μ :=\n  ⟨hf.mk f, Measurable.mono hf.measurable_mk hm le_rfl, ae_eq_of_ae_eq_trim hf.ae_eq_mk⟩\n\n"}
{"name":"aemeasurable_restrict_of_measurable_subtype","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\nhf : Measurable fun x => f ↑x\n⊢ AEMeasurable f (μ.restrict s)","decl":"theorem aemeasurable_restrict_of_measurable_subtype {s : Set α} (hs : MeasurableSet s)\n    (hf : Measurable fun x : s => f x) : AEMeasurable f (μ.restrict s) :=\n  (aemeasurable_restrict_iff_comap_subtype hs).2 hf.aemeasurable\n\n"}
{"name":"aemeasurable_map_equiv_iff","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\nm0 : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace γ\nμ : MeasureTheory.Measure α\ne : MeasurableEquiv α β\nf : β → γ\n⊢ Iff (AEMeasurable f (MeasureTheory.Measure.map (⇑e) μ)) (AEMeasurable (Function.comp f ⇑e) μ)","decl":"theorem aemeasurable_map_equiv_iff (e : α ≃ᵐ β) {f : β → γ} :\n    AEMeasurable f (μ.map e) ↔ AEMeasurable (f ∘ e) μ :=\n  e.measurableEmbedding.aemeasurable_map_iff\n\n"}
{"name":"AEMeasurable.restrict","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure α\nhfm : AEMeasurable f μ\ns : Set α\n⊢ AEMeasurable f (μ.restrict s)","decl":"theorem AEMeasurable.restrict (hfm : AEMeasurable f μ) {s} : AEMeasurable f (μ.restrict s) :=\n  ⟨AEMeasurable.mk f hfm, hfm.measurable_mk, ae_restrict_of_ae hfm.ae_eq_mk⟩\n\n"}
{"name":"aemeasurable_Ioi_of_forall_Ioc","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nβ : Type u_7\nmβ : MeasurableSpace β\ninst✝¹ : LinearOrder α\ninst✝ : Filter.atTop.IsCountablyGenerated\nx : α\ng : α → β\ng_meas : ∀ (t : α), GT.gt t x → AEMeasurable g (μ.restrict (Set.Ioc x t))\n⊢ AEMeasurable g (μ.restrict (Set.Ioi x))","decl":"theorem aemeasurable_Ioi_of_forall_Ioc {β} {mβ : MeasurableSpace β} [LinearOrder α]\n    [(atTop : Filter α).IsCountablyGenerated] {x : α} {g : α → β}\n    (g_meas : ∀ t > x, AEMeasurable g (μ.restrict (Ioc x t))) :\n    AEMeasurable g (μ.restrict (Ioi x)) := by\n  haveI : Nonempty α := ⟨x⟩\n  obtain ⟨u, hu_tendsto⟩ := exists_seq_tendsto (atTop : Filter α)\n  have Ioi_eq_iUnion : Ioi x = ⋃ n : ℕ, Ioc x (u n) := by\n    rw [iUnion_Ioc_eq_Ioi_self_iff.mpr _]\n    exact fun y _ => (hu_tendsto.eventually (eventually_ge_atTop y)).exists\n  rw [Ioi_eq_iUnion, aemeasurable_iUnion_iff]\n  intro n\n  cases' lt_or_le x (u n) with h h\n  · exact g_meas (u n) h\n  · rw [Ioc_eq_empty (not_lt.mpr h), Measure.restrict_empty]\n    exact aemeasurable_zero_measure\n\n"}
{"name":"aemeasurable_indicator_iff","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure α\ninst✝ : Zero β\ns : Set α\nhs : MeasurableSet s\n⊢ Iff (AEMeasurable (s.indicator f) μ) (AEMeasurable f (μ.restrict s))","decl":"theorem aemeasurable_indicator_iff {s} (hs : MeasurableSet s) :\n    AEMeasurable (indicator s f) μ ↔ AEMeasurable f (μ.restrict s) := by\n  constructor\n  · intro h\n    exact (h.mono_measure Measure.restrict_le_self).congr (indicator_ae_eq_restrict hs)\n  · intro h\n    refine ⟨indicator s (h.mk f), h.measurable_mk.indicator hs, ?_⟩\n    have A : s.indicator f =ᵐ[μ.restrict s] s.indicator (AEMeasurable.mk f h) :=\n      (indicator_ae_eq_restrict hs).trans (h.ae_eq_mk.trans <| (indicator_ae_eq_restrict hs).symm)\n    have B : s.indicator f =ᵐ[μ.restrict sᶜ] s.indicator (AEMeasurable.mk f h) :=\n      (indicator_ae_eq_restrict_compl hs).trans (indicator_ae_eq_restrict_compl hs).symm\n    exact ae_of_ae_restrict_of_ae_restrict_compl _ A B\n\n"}
{"name":"aemeasurable_indicator_iff₀","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure α\ninst✝ : Zero β\ns : Set α\nhs : MeasureTheory.NullMeasurableSet s μ\n⊢ Iff (AEMeasurable (s.indicator f) μ) (AEMeasurable f (μ.restrict s))","decl":"theorem aemeasurable_indicator_iff₀ {s} (hs : NullMeasurableSet s μ) :\n    AEMeasurable (indicator s f) μ ↔ AEMeasurable f (μ.restrict s) := by\n  rcases hs with ⟨t, ht, hst⟩\n  rw [← aemeasurable_congr (indicator_ae_eq_of_ae_eq_set hst.symm), aemeasurable_indicator_iff ht,\n      restrict_congr_set hst]\n\n"}
{"name":"aemeasurable_indicator_const_iff","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝³ : MeasurableSpace β\nμ : MeasureTheory.Measure α\ninst✝² : Zero β\ns : Set α\ninst✝¹ : MeasurableSingletonClass β\nb : β\ninst✝ : NeZero b\n⊢ Iff (AEMeasurable (s.indicator fun x => b) μ) (MeasureTheory.NullMeasurableSet s μ)","decl":"/-- A characterization of the a.e.-measurability of the indicator function which takes a constant\nvalue `b` on a set `A` and `0` elsewhere. -/\nlemma aemeasurable_indicator_const_iff {s} [MeasurableSingletonClass β] (b : β) [NeZero b] :\n    AEMeasurable (s.indicator (fun _ ↦ b)) μ ↔ NullMeasurableSet s μ := by\n  classical\n  constructor <;> intro h\n  · convert h.nullMeasurable (MeasurableSet.singleton (0 : β)).compl\n    rw [indicator_const_preimage_eq_union s {0}ᶜ b]\n    simp [NeZero.ne b]\n  · exact (aemeasurable_indicator_iff₀ h).mpr aemeasurable_const\n\n"}
{"name":"AEMeasurable.indicator","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure α\ninst✝ : Zero β\nhfm : AEMeasurable f μ\ns : Set α\nhs : MeasurableSet s\n⊢ AEMeasurable (s.indicator f) μ","decl":"@[measurability]\ntheorem AEMeasurable.indicator (hfm : AEMeasurable f μ) {s} (hs : MeasurableSet s) :\n    AEMeasurable (s.indicator f) μ :=\n  (aemeasurable_indicator_iff hs).mpr hfm.restrict\n\n"}
{"name":"AEMeasurable.indicator₀","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure α\ninst✝ : Zero β\nhfm : AEMeasurable f μ\ns : Set α\nhs : MeasureTheory.NullMeasurableSet s μ\n⊢ AEMeasurable (s.indicator f) μ","decl":"theorem AEMeasurable.indicator₀ (hfm : AEMeasurable f μ) {s} (hs : NullMeasurableSet s μ) :\n    AEMeasurable (s.indicator f) μ :=\n  (aemeasurable_indicator_iff₀ hs).mpr hfm.restrict\n\n"}
{"name":"MeasureTheory.Measure.restrict_map_of_aemeasurable","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nδ : Type u_5\nm0 : MeasurableSpace α\ninst✝ : MeasurableSpace δ\nμ : MeasureTheory.Measure α\nf : α → δ\nhf : AEMeasurable f μ\ns : Set δ\nhs : MeasurableSet s\n⊢ Eq ((MeasureTheory.Measure.map f μ).restrict s) (MeasureTheory.Measure.map f (μ.restrict (Set.preimage f s)))","decl":"theorem MeasureTheory.Measure.restrict_map_of_aemeasurable {f : α → δ} (hf : AEMeasurable f μ)\n    {s : Set δ} (hs : MeasurableSet s) : (μ.map f).restrict s = (μ.restrict <| f ⁻¹' s).map f :=\n  calc\n    (μ.map f).restrict s = (μ.map (hf.mk f)).restrict s := by\n      congr 1\n      apply Measure.map_congr hf.ae_eq_mk\n    _ = (μ.restrict <| hf.mk f ⁻¹' s).map (hf.mk f) := Measure.restrict_map hf.measurable_mk hs\n    _ = (μ.restrict <| hf.mk f ⁻¹' s).map f :=\n      (Measure.map_congr (ae_restrict_of_ae hf.ae_eq_mk.symm))\n    _ = (μ.restrict <| f ⁻¹' s).map f := by\n      apply congr_arg\n      ext1 t ht\n      simp only [ht, Measure.restrict_apply]\n      apply measure_congr\n      apply (EventuallyEq.refl _ _).inter (hf.ae_eq_mk.symm.preimage s)\n\n"}
{"name":"MeasureTheory.Measure.map_mono_of_aemeasurable","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nδ : Type u_5\nm0 : MeasurableSpace α\ninst✝ : MeasurableSpace δ\nμ ν : MeasureTheory.Measure α\nf : α → δ\nh : LE.le μ ν\nhf : AEMeasurable f ν\n⊢ LE.le (MeasureTheory.Measure.map f μ) (MeasureTheory.Measure.map f ν)","decl":"theorem MeasureTheory.Measure.map_mono_of_aemeasurable {f : α → δ} (h : μ ≤ ν)\n    (hf : AEMeasurable f ν) : μ.map f ≤ ν.map f :=\n  le_iff.2 fun s hs ↦ by simpa [hf, hs, hf.mono_measure h] using h (f ⁻¹' s)\n\n"}
{"name":"MeasureTheory.NullMeasurable.aemeasurable","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : α → β\nhc : MeasurableSpace.CountablyGenerated β\nh : MeasureTheory.NullMeasurable f μ\n⊢ AEMeasurable f μ","decl":"/-- If the `σ`-algebra of the codomain of a null measurable function is countably generated,\nthen the function is a.e.-measurable. -/\nlemma MeasureTheory.NullMeasurable.aemeasurable {f : α → β}\n    [hc : MeasurableSpace.CountablyGenerated β] (h : NullMeasurable f μ) : AEMeasurable f μ := by\n  classical\n  nontriviality β; inhabit β\n  rcases hc.1 with ⟨S, hSc, rfl⟩\n  choose! T hTf hTm hTeq using fun s hs ↦ (h <| .basic s hs).exists_measurable_subset_ae_eq\n  choose! U hUf hUm hUeq using fun s hs ↦ (h <| .basic s hs).exists_measurable_superset_ae_eq\n  set v := ⋃ s ∈ S, U s \\ T s\n  have hvm : MeasurableSet v := .biUnion hSc fun s hs ↦ (hUm s hs).diff (hTm s hs)\n  have hvμ : μ v = 0 := (measure_biUnion_null_iff hSc).2 fun s hs ↦ ae_le_set.1 <|\n    ((hUeq s hs).trans (hTeq s hs).symm).le\n  refine ⟨v.piecewise (fun _ ↦ default) f, ?_, measure_mono_null (fun x ↦\n    not_imp_comm.2 fun hxv ↦ (piecewise_eq_of_not_mem _ _ _ hxv).symm) hvμ⟩\n  refine measurable_of_restrict_of_restrict_compl hvm ?_ ?_\n  · rw [restrict_piecewise]\n    apply measurable_const\n  · rw [restrict_piecewise_compl, restrict_eq]\n    refine measurable_generateFrom fun s hs ↦ .of_subtype_image ?_\n    rw [preimage_comp, Subtype.image_preimage_coe]\n    convert (hTm s hs).diff hvm using 1\n    rw [inter_comm]\n    refine Set.ext fun x ↦ and_congr_left fun hxv ↦ ⟨fun hx ↦ ?_, fun hx ↦ hTf s hs hx⟩\n    exact by_contra fun hx' ↦ hxv <| mem_biUnion hs ⟨hUf s hs hx, hx'⟩\n\n"}
{"name":"MeasureTheory.NullMeasurable.aemeasurable_of_aerange","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : α → β\nt : Set β\ninst✝ : MeasurableSpace.CountablyGenerated ↑t\nh : MeasureTheory.NullMeasurable f μ\nhft : Filter.Eventually (fun x => Membership.mem t (f x)) (MeasureTheory.ae μ)\n⊢ AEMeasurable f μ","decl":"/-- Let `f : α → β` be a null measurable function\nsuch that a.e. all values of `f` belong to a set `t`\nsuch that the restriction of the `σ`-algebra in the codomain to `t` is countably generated,\nthen `f` is a.e.-measurable. -/\nlemma MeasureTheory.NullMeasurable.aemeasurable_of_aerange {f : α → β} {t : Set β}\n    [MeasurableSpace.CountablyGenerated t] (h : NullMeasurable f μ) (hft : ∀ᵐ x ∂μ, f x ∈ t) :\n    AEMeasurable f μ := by\n  rcases eq_empty_or_nonempty t with rfl | hne\n  · obtain rfl : μ = 0 := by simpa using hft\n    apply aemeasurable_zero_measure\n  · rw [← μ.ae_completion] at hft\n    obtain ⟨f', hf'm, hf't, hff'⟩ :\n        ∃ f' : α → β, NullMeasurable f' μ ∧ range f' ⊆ t ∧ f =ᵐ[μ] f' :=\n      h.measurable'.aemeasurable.exists_ae_eq_range_subset hft hne\n    rw [range_subset_iff] at hf't\n    lift f' to α → t using hf't\n    replace hf'm : NullMeasurable f' μ := hf'm.measurable'.subtype_mk\n    exact (measurable_subtype_coe.comp_aemeasurable hf'm.aemeasurable).congr hff'.symm\n\n"}
{"name":"MeasureTheory.Measure.map_sum","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝ : MeasurableSpace β\nι : Type u_7\nm : ι → MeasureTheory.Measure α\nf : α → β\nhf : AEMeasurable f (MeasureTheory.Measure.sum m)\n⊢ Eq (MeasureTheory.Measure.map f (MeasureTheory.Measure.sum m)) (MeasureTheory.Measure.sum fun i => MeasureTheory.Measure.map f (m i))","decl":"lemma map_sum {ι : Type*} {m : ι → Measure α} {f : α → β} (hf : AEMeasurable f (Measure.sum m)) :\n    Measure.map f (Measure.sum m) = Measure.sum (fun i ↦ Measure.map f (m i)) := by\n  ext s hs\n  rw [map_apply_of_aemeasurable hf hs, sum_apply₀ _ (hf.nullMeasurable hs), sum_apply _ hs]\n  have M i : AEMeasurable f (m i) := hf.mono_measure (le_sum m i)\n  simp_rw [map_apply_of_aemeasurable (M _) hs]\n\n"}
{"name":"MeasureTheory.Measure.instSFiniteMap","module":"Mathlib.MeasureTheory.Measure.AEMeasurable","initialProofState":"α : Type u_2\nβ : Type u_3\nm0 : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : α → β\ninst✝ : MeasureTheory.SFinite μ\n⊢ MeasureTheory.SFinite (MeasureTheory.Measure.map f μ)","decl":"instance (μ : Measure α) (f : α → β) [SFinite μ] : SFinite (μ.map f) := by\n  by_cases H : AEMeasurable f μ\n  · rw [← sum_sfiniteSeq μ] at H ⊢\n    rw [map_sum H]\n    infer_instance\n  · rw [map_of_not_aemeasurable H]\n    infer_instance\n\n"}
