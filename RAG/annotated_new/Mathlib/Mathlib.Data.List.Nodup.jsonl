{"name":"List.Pairwise.nodup","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl : List α\nr : α → α → Prop\ninst✝ : IsIrrefl α r\nh : List.Pairwise r l\n⊢ l.Nodup","decl":"protected theorem Pairwise.nodup {l : List α} {r : α → α → Prop} [IsIrrefl α r] (h : Pairwise r l) :\n    Nodup l :=\n  h.imp ne_of_irrefl\n\n"}
{"name":"List.rel_nodup","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nβ : Type v\nr : α → β → Prop\nhr : Relator.BiUnique r\n⊢ Relator.LiftFun (List.Forall₂ r) (fun x1 x2 => Iff x1 x2) List.Nodup List.Nodup","decl":"theorem rel_nodup {r : α → β → Prop} (hr : Relator.BiUnique r) : (Forall₂ r ⇒ (· ↔ ·)) Nodup Nodup\n  | _, _, Forall₂.nil => by simp only [nodup_nil]\n  | _, _, Forall₂.cons hab h => by\n    simpa only [nodup_cons] using\n      Relator.rel_and (Relator.rel_not (rel_mem hr hab h)) (rel_nodup hr h)\n\n"}
{"name":"List.Nodup.cons","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl : List α\na : α\nha : Not (Membership.mem l a)\nhl : l.Nodup\n⊢ (List.cons a l).Nodup","decl":"protected theorem Nodup.cons (ha : a ∉ l) (hl : Nodup l) : Nodup (a :: l) :=\n  nodup_cons.2 ⟨ha, hl⟩\n\n"}
{"name":"List.nodup_singleton","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\na : α\n⊢ (List.cons a List.nil).Nodup","decl":"theorem nodup_singleton (a : α) : Nodup [a] :=\n  pairwise_singleton _ _\n\n"}
{"name":"List.Nodup.of_cons","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl : List α\na : α\nh : (List.cons a l).Nodup\n⊢ l.Nodup","decl":"theorem Nodup.of_cons (h : Nodup (a :: l)) : Nodup l :=\n  (nodup_cons.1 h).2\n\n"}
{"name":"List.Nodup.not_mem","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl : List α\na : α\nh : (List.cons a l).Nodup\n⊢ Not (Membership.mem l a)","decl":"theorem Nodup.not_mem (h : (a :: l).Nodup) : a ∉ l :=\n  (nodup_cons.1 h).1\n\n"}
{"name":"List.not_nodup_cons_of_mem","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl : List α\na : α\na✝ : Membership.mem l a\n⊢ Not (List.cons a l).Nodup","decl":"theorem not_nodup_cons_of_mem : a ∈ l → ¬Nodup (a :: l) :=\n  imp_not_comm.1 Nodup.not_mem\n\n\n"}
{"name":"List.not_nodup_pair","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\na : α\n⊢ Not (List.cons a (List.cons a List.nil)).Nodup","decl":"theorem not_nodup_pair (a : α) : ¬Nodup [a, a] :=\n  not_nodup_cons_of_mem <| mem_singleton_self _\n\n"}
{"name":"List.nodup_iff_sublist","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl : List α\n⊢ Iff l.Nodup (∀ (a : α), Not ((List.cons a (List.cons a List.nil)).Sublist l))","decl":"theorem nodup_iff_sublist {l : List α} : Nodup l ↔ ∀ a, ¬[a, a] <+ l :=\n  ⟨fun d a h => not_nodup_pair a (d.sublist h),\n    by\n      induction' l with a l IH <;> intro h; · exact nodup_nil\n      exact (IH fun a s => h a <| sublist_cons_of_sublist _ s).cons fun al =>\n        h a <| (singleton_sublist.2 al).cons_cons _⟩\n\n"}
{"name":"List.nodup_iff_injective_getElem","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl : List α\n⊢ Iff l.Nodup (Function.Injective fun i => GetElem.getElem l ↑i ⋯)","decl":"theorem nodup_iff_injective_getElem {l : List α} :\n    Nodup l ↔ Function.Injective (fun i : Fin l.length => l[i.1]) :=\n  pairwise_iff_getElem.trans\n    ⟨fun h i j hg => by\n      cases' i with i hi; cases' j with j hj\n      rcases lt_trichotomy i j with (hij | rfl | hji)\n      · exact (h i j hi hj hij hg).elim\n      · rfl\n      · exact (h j i hj hi hji hg.symm).elim,\n      fun hinj i j hi hj hij h => Nat.ne_of_lt hij (Fin.val_eq_of_eq (@hinj ⟨i, hi⟩ ⟨j, hj⟩ h))⟩\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10756): new theorem\n"}
{"name":"List.nodup_iff_injective_get","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl : List α\n⊢ Iff l.Nodup (Function.Injective l.get)","decl":"theorem nodup_iff_injective_get {l : List α} :\n    Nodup l ↔ Function.Injective l.get := by\n  rw [nodup_iff_injective_getElem]\n  change _ ↔ Injective (fun i => l.get i)\n  simp\n\n"}
{"name":"List.Nodup.get_inj_iff","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl : List α\nh : l.Nodup\ni j : Fin l.length\n⊢ Iff (Eq (l.get i) (l.get j)) (Eq i j)","decl":"theorem Nodup.get_inj_iff {l : List α} (h : Nodup l) {i j : Fin l.length} :\n    l.get i = l.get j ↔ i = j :=\n  (nodup_iff_injective_get.1 h).eq_iff\n\n"}
{"name":"List.Nodup.getElem_inj_iff","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl : List α\nh : l.Nodup\ni : Nat\nhi : LT.lt i l.length\nj : Nat\nhj : LT.lt j l.length\n⊢ Iff (Eq (GetElem.getElem l i ⋯) (GetElem.getElem l j ⋯)) (Eq i j)","decl":"theorem Nodup.getElem_inj_iff {l : List α} (h : Nodup l)\n    {i : Nat} {hi : i < l.length} {j : Nat} {hj : j < l.length} :\n    l[i] = l[j] ↔ i = j := by\n  have := @Nodup.get_inj_iff _ _ h ⟨i, hi⟩ ⟨j, hj⟩\n  simpa\n\n"}
{"name":"List.nodup_iff_getElem?_ne_getElem?","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl : List α\n⊢ Iff l.Nodup (∀ (i j : Nat), LT.lt i j → LT.lt j l.length → Ne (GetElem?.getElem? l i) (GetElem?.getElem? l j))","decl":"theorem nodup_iff_getElem?_ne_getElem? {l : List α} :\n    l.Nodup ↔ ∀ i j : ℕ, i < j → j < l.length → l[i]? ≠ l[j]? := by\n  rw [Nodup, pairwise_iff_getElem]\n  constructor\n  · intro h i j hij hj\n    rw [getElem?_eq_getElem (lt_trans hij hj), getElem?_eq_getElem hj, Ne, Option.some_inj]\n    exact h _ _ (by omega) hj hij\n  · intro h i j hi hj hij\n    rw [Ne, ← Option.some_inj, ← getElem?_eq_getElem, ← getElem?_eq_getElem]\n    exact h i j hij hj\n\n"}
{"name":"List.nodup_iff_get?_ne_get?","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl : List α\n⊢ Iff l.Nodup (∀ (i j : Nat), LT.lt i j → LT.lt j l.length → Ne (l.get? i) (l.get? j))","decl":"theorem nodup_iff_get?_ne_get? {l : List α} :\n    l.Nodup ↔ ∀ i j : ℕ, i < j → j < l.length → l.get? i ≠ l.get? j := by\n  simp [nodup_iff_getElem?_ne_getElem?]\n\n"}
{"name":"List.Nodup.ne_singleton_iff","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl : List α\nh : l.Nodup\nx : α\n⊢ Iff (Ne l (List.cons x List.nil)) (Or (Eq l List.nil) (Exists fun y => And (Membership.mem l y) (Ne y x)))","decl":"theorem Nodup.ne_singleton_iff {l : List α} (h : Nodup l) (x : α) :\n    l ≠ [x] ↔ l = [] ∨ ∃ y ∈ l, y ≠ x := by\n  induction' l with hd tl hl\n  · simp\n  · specialize hl h.of_cons\n    by_cases hx : tl = [x]\n    · simpa [hx, and_comm, and_or_left] using h\n    · rw [← Ne, hl] at hx\n      rcases hx with (rfl | ⟨y, hy, hx⟩)\n      · simp\n      · suffices ∃ y ∈ hd :: tl, y ≠ x by simpa [ne_nil_of_mem hy]\n        exact ⟨y, mem_cons_of_mem _ hy, hx⟩\n\n"}
{"name":"List.not_nodup_of_get_eq_of_ne","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nxs : List α\nn m : Fin xs.length\nh : Eq (xs.get n) (xs.get m)\nhne : Ne n m\n⊢ Not xs.Nodup","decl":"theorem not_nodup_of_get_eq_of_ne (xs : List α) (n m : Fin xs.length)\n    (h : xs.get n = xs.get m) (hne : n ≠ m) : ¬Nodup xs := by\n  rw [nodup_iff_injective_get]\n  exact fun hinj => hne (hinj h)\n\n"}
{"name":"List.indexOf_getElem","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\ninst✝ : DecidableEq α\nl : List α\nH : l.Nodup\ni : Nat\nh : LT.lt i l.length\n⊢ Eq (List.indexOf (GetElem.getElem l i ⋯) l) i","decl":"theorem indexOf_getElem [DecidableEq α] {l : List α} (H : Nodup l) (i : Nat) (h : i < l.length) :\n    indexOf l[i] l = i :=\n  suffices (⟨indexOf l[i] l, indexOf_lt_length_iff.2 (getElem_mem _)⟩ : Fin l.length) = ⟨i, h⟩\n    from Fin.val_eq_of_eq this\n  nodup_iff_injective_get.1 H (by simp)\n\n-- This is incorrectly named and should be `indexOf_get`;\n-- this already exists, so will require a deprecation dance.\n"}
{"name":"List.get_indexOf","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\ninst✝ : DecidableEq α\nl : List α\nH : l.Nodup\ni : Fin l.length\n⊢ Eq (List.indexOf (l.get i) l) ↑i","decl":"theorem get_indexOf [DecidableEq α] {l : List α} (H : Nodup l) (i : Fin l.length) :\n    indexOf (get l i) l = i := by\n  simp [indexOf_getElem, H]\n\n"}
{"name":"List.nodup_iff_count_le_one","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\ninst✝ : DecidableEq α\nl : List α\n⊢ Iff l.Nodup (∀ (a : α), LE.le (List.count a l) 1)","decl":"theorem nodup_iff_count_le_one [DecidableEq α] {l : List α} : Nodup l ↔ ∀ a, count a l ≤ 1 :=\n  nodup_iff_sublist.trans <|\n    forall_congr' fun a =>\n      have : replicate 2 a <+ l ↔ 1 < count a l := (le_count_iff_replicate_sublist ..).symm\n      (not_congr this).trans not_lt\n\n"}
{"name":"List.nodup_iff_count_eq_one","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl : List α\ninst✝ : DecidableEq α\n⊢ Iff l.Nodup (∀ (a : α), Membership.mem l a → Eq (List.count a l) 1)","decl":"theorem nodup_iff_count_eq_one [DecidableEq α] : Nodup l ↔ ∀ a ∈ l, count a l = 1 :=\n  nodup_iff_count_le_one.trans <| forall_congr' fun _ =>\n    ⟨fun H h => H.antisymm (count_pos_iff.mpr h),\n     fun H => if h : _ then (H h).le else (count_eq_zero.mpr h).trans_le (Nat.zero_le 1)⟩\n\n\n"}
{"name":"List.count_eq_one_of_mem","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\ninst✝ : DecidableEq α\na : α\nl : List α\nd : l.Nodup\nh : Membership.mem l a\n⊢ Eq (List.count a l) 1","decl":"@[simp]\ntheorem count_eq_one_of_mem [DecidableEq α] {a : α} {l : List α} (d : Nodup l) (h : a ∈ l) :\n    count a l = 1 :=\n  _root_.le_antisymm (nodup_iff_count_le_one.1 d a) (Nat.succ_le_of_lt (count_pos_iff.2 h))\n\n"}
{"name":"List.count_eq_of_nodup","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\ninst✝ : DecidableEq α\na : α\nl : List α\nd : l.Nodup\n⊢ Eq (List.count a l) (ite (Membership.mem l a) 1 0)","decl":"theorem count_eq_of_nodup [DecidableEq α] {a : α} {l : List α} (d : Nodup l) :\n    count a l = if a ∈ l then 1 else 0 := by\n  split_ifs with h\n  · exact count_eq_one_of_mem d h\n  · exact count_eq_zero_of_not_mem h\n\n"}
{"name":"List.Nodup.of_append_left","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl₁ l₂ : List α\na✝ : (HAppend.hAppend l₁ l₂).Nodup\n⊢ l₁.Nodup","decl":"theorem Nodup.of_append_left : Nodup (l₁ ++ l₂) → Nodup l₁ :=\n  Nodup.sublist (sublist_append_left l₁ l₂)\n\n"}
{"name":"List.Nodup.of_append_right","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl₁ l₂ : List α\na✝ : (HAppend.hAppend l₁ l₂).Nodup\n⊢ l₂.Nodup","decl":"theorem Nodup.of_append_right : Nodup (l₁ ++ l₂) → Nodup l₂ :=\n  Nodup.sublist (sublist_append_right l₁ l₂)\n\n"}
{"name":"List.nodup_append","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl₁ l₂ : List α\n⊢ Iff (HAppend.hAppend l₁ l₂).Nodup (And l₁.Nodup (And l₂.Nodup (l₁.Disjoint l₂)))","decl":"theorem nodup_append {l₁ l₂ : List α} :\n    Nodup (l₁ ++ l₂) ↔ Nodup l₁ ∧ Nodup l₂ ∧ Disjoint l₁ l₂ := by\n  simp only [Nodup, pairwise_append, disjoint_iff_ne]\n\n"}
{"name":"List.disjoint_of_nodup_append","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl₁ l₂ : List α\nd : (HAppend.hAppend l₁ l₂).Nodup\n⊢ l₁.Disjoint l₂","decl":"theorem disjoint_of_nodup_append {l₁ l₂ : List α} (d : Nodup (l₁ ++ l₂)) : Disjoint l₁ l₂ :=\n  (nodup_append.1 d).2.2\n\n"}
{"name":"List.Nodup.append","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl₁ l₂ : List α\nd₁ : l₁.Nodup\nd₂ : l₂.Nodup\ndj : l₁.Disjoint l₂\n⊢ (HAppend.hAppend l₁ l₂).Nodup","decl":"theorem Nodup.append (d₁ : Nodup l₁) (d₂ : Nodup l₂) (dj : Disjoint l₁ l₂) : Nodup (l₁ ++ l₂) :=\n  nodup_append.2 ⟨d₁, d₂, dj⟩\n\n"}
{"name":"List.nodup_append_comm","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl₁ l₂ : List α\n⊢ Iff (HAppend.hAppend l₁ l₂).Nodup (HAppend.hAppend l₂ l₁).Nodup","decl":"theorem nodup_append_comm {l₁ l₂ : List α} : Nodup (l₁ ++ l₂) ↔ Nodup (l₂ ++ l₁) := by\n  simp only [nodup_append, and_left_comm, disjoint_comm]\n\n"}
{"name":"List.nodup_middle","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\na : α\nl₁ l₂ : List α\n⊢ Iff (HAppend.hAppend l₁ (List.cons a l₂)).Nodup (List.cons a (HAppend.hAppend l₁ l₂)).Nodup","decl":"theorem nodup_middle {a : α} {l₁ l₂ : List α} :\n    Nodup (l₁ ++ a :: l₂) ↔ Nodup (a :: (l₁ ++ l₂)) := by\n  simp only [nodup_append, not_or, and_left_comm, and_assoc, nodup_cons, mem_append,\n    disjoint_cons_right]\n\n"}
{"name":"List.Nodup.of_map","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nl : List α\na✝ : (List.map f l).Nodup\n⊢ l.Nodup","decl":"theorem Nodup.of_map (f : α → β) {l : List α} : Nodup (map f l) → Nodup l :=\n  (Pairwise.of_map f) fun _ _ => mt <| congr_arg f\n\n"}
{"name":"List.Nodup.map_on","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nβ : Type v\nl : List α\nf : α → β\nH : ∀ (x : α), Membership.mem l x → ∀ (y : α), Membership.mem l y → Eq (f x) (f y) → Eq x y\nd : l.Nodup\n⊢ (List.map f l).Nodup","decl":"theorem Nodup.map_on {f : α → β} (H : ∀ x ∈ l, ∀ y ∈ l, f x = f y → x = y) (d : Nodup l) :\n    (map f l).Nodup :=\n  Pairwise.map _ (fun a b ⟨ma, mb, n⟩ e => n (H a ma b mb e)) (Pairwise.and_mem.1 d)\n\n"}
{"name":"List.inj_on_of_nodup_map","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nl : List α\nd : (List.map f l).Nodup\nx : α\na✝² : Membership.mem l x\ny : α\na✝¹ : Membership.mem l y\na✝ : Eq (f x) (f y)\n⊢ Eq x y","decl":"theorem inj_on_of_nodup_map {f : α → β} {l : List α} (d : Nodup (map f l)) :\n    ∀ ⦃x⦄, x ∈ l → ∀ ⦃y⦄, y ∈ l → f x = f y → x = y := by\n  induction' l with hd tl ih\n  · simp\n  · simp only [map, nodup_cons, mem_map, not_exists, not_and, ← Ne.eq_def] at d\n    simp only [mem_cons]\n    rintro _ (rfl | h₁) _ (rfl | h₂) h₃\n    · rfl\n    · apply (d.1 _ h₂ h₃.symm).elim\n    · apply (d.1 _ h₁ h₃).elim\n    · apply ih d.2 h₁ h₂ h₃\n\n"}
{"name":"List.nodup_map_iff_inj_on","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nl : List α\nd : l.Nodup\n⊢ Iff (List.map f l).Nodup (∀ (x : α), Membership.mem l x → ∀ (y : α), Membership.mem l y → Eq (f x) (f y) → Eq x y)","decl":"theorem nodup_map_iff_inj_on {f : α → β} {l : List α} (d : Nodup l) :\n    Nodup (map f l) ↔ ∀ x ∈ l, ∀ y ∈ l, f x = f y → x = y :=\n  ⟨inj_on_of_nodup_map, fun h => d.map_on h⟩\n\n"}
{"name":"List.Nodup.map","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nβ : Type v\nl : List α\nf : α → β\nhf : Function.Injective f\na✝ : l.Nodup\n⊢ (List.map f l).Nodup","decl":"protected theorem Nodup.map {f : α → β} (hf : Injective f) : Nodup l → Nodup (map f l) :=\n  Nodup.map_on fun _ _ _ _ h => hf h\n\n"}
{"name":"List.nodup_map_iff","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nl : List α\nhf : Function.Injective f\n⊢ Iff (List.map f l).Nodup l.Nodup","decl":"theorem nodup_map_iff {f : α → β} {l : List α} (hf : Injective f) : Nodup (map f l) ↔ Nodup l :=\n  ⟨Nodup.of_map _, Nodup.map hf⟩\n\n"}
{"name":"List.nodup_attach","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl : List α\n⊢ Iff l.attach.Nodup l.Nodup","decl":"@[simp]\ntheorem nodup_attach {l : List α} : Nodup (attach l) ↔ Nodup l :=\n  ⟨fun h => attach_map_subtype_val l ▸ h.map fun _ _ => Subtype.eq, fun h =>\n    Nodup.of_map Subtype.val ((attach_map_subtype_val l).symm ▸ h)⟩\n\n"}
{"name":"List.Nodup.attach","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl : List α\na✝ : l.Nodup\n⊢ l.attach.Nodup","decl":"protected alias ⟨Nodup.of_attach, Nodup.attach⟩ := nodup_attach\n\n"}
{"name":"List.Nodup.of_attach","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl : List α\na✝ : l.attach.Nodup\n⊢ l.Nodup","decl":"protected alias ⟨Nodup.of_attach, Nodup.attach⟩ := nodup_attach\n\n"}
{"name":"List.Nodup.pmap","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nβ : Type v\np : α → Prop\nf : (a : α) → p a → β\nl : List α\nH : ∀ (a : α), Membership.mem l a → p a\nhf : ∀ (a : α) (ha : p a) (b : α) (hb : p b), Eq (f a ha) (f b hb) → Eq a b\nh : l.Nodup\n⊢ (List.pmap f l H).Nodup","decl":"theorem Nodup.pmap {p : α → Prop} {f : ∀ a, p a → β} {l : List α} {H}\n    (hf : ∀ a ha b hb, f a ha = f b hb → a = b) (h : Nodup l) : Nodup (pmap f l H) := by\n  rw [pmap_eq_map_attach]\n  exact h.attach.map fun ⟨a, ha⟩ ⟨b, hb⟩ h => by congr; exact hf a (H _ ha) b (H _ hb) h\n\n"}
{"name":"List.Nodup.filter","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\np : α → Bool\nl : List α\na✝ : l.Nodup\n⊢ (List.filter p l).Nodup","decl":"theorem Nodup.filter (p : α → Bool) {l} : Nodup l → Nodup (filter p l) := by\n  simpa using Pairwise.filter p\n\n"}
{"name":"List.nodup_reverse","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl : List α\n⊢ Iff l.reverse.Nodup l.Nodup","decl":"@[simp]\ntheorem nodup_reverse {l : List α} : Nodup (reverse l) ↔ Nodup l :=\n  pairwise_reverse.trans <| by simp only [Nodup, Ne, eq_comm]\n\n"}
{"name":"List.nodup_tail_reverse","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl : List α\nh : Eq (GetElem?.getElem? l 0) l.getLast?\n⊢ Iff l.reverse.tail.Nodup l.tail.Nodup","decl":"lemma nodup_tail_reverse (l : List α) (h : l[0]? = l.getLast?) :\n    Nodup l.reverse.tail ↔ Nodup l.tail := by\n  induction l with\n  | nil => simp\n  | cons a l ih =>\n    by_cases hl : l = []\n    · aesop\n    · simp_all only [List.get?_eq_getElem?, List.tail_reverse, List.nodup_reverse,\n        List.dropLast_cons_of_ne_nil hl, List.tail_cons]\n      simp only [length_cons, Nat.zero_lt_succ, getElem?_eq_getElem, getElem_cons_zero,\n        Nat.add_one_sub_one, Nat.lt_add_one, Option.some.injEq, List.getElem_cons,\n        show l.length ≠ 0 by aesop, ↓reduceDIte, getLast?_eq_getElem?] at h\n      rw [h,\n        show l.Nodup = (l.dropLast ++ [l.getLast hl]).Nodup by\n          simp [List.dropLast_eq_take, ← List.drop_length_sub_one],\n        List.nodup_append_comm]\n      simp [List.getLast_eq_getElem]\n\n"}
{"name":"List.Nodup.erase_getElem","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\ninst✝ : DecidableEq α\nl : List α\nhl : l.Nodup\ni : Nat\nh : LT.lt i l.length\n⊢ Eq (l.erase (GetElem.getElem l i ⋯)) (l.eraseIdx i)","decl":"theorem Nodup.erase_getElem [DecidableEq α] {l : List α} (hl : l.Nodup)\n    (i : Nat) (h : i < l.length) : l.erase l[i] = l.eraseIdx ↑i := by\n  induction l generalizing i with\n  | nil => simp\n  | cons a l IH =>\n    cases i with\n    | zero => simp\n    | succ i =>\n      rw [nodup_cons] at hl\n      rw [erase_cons_tail]\n      · simp [IH hl.2]\n      · rw [beq_iff_eq]\n        simp only [getElem_cons_succ]\n        simp only [length_cons, Nat.succ_eq_add_one, Nat.add_lt_add_iff_right] at h\n        exact mt (· ▸ getElem_mem h) hl.1\n\n"}
{"name":"List.Nodup.erase_get","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\ninst✝ : DecidableEq α\nl : List α\nhl : l.Nodup\ni : Fin l.length\n⊢ Eq (l.erase (l.get i)) (l.eraseIdx ↑i)","decl":"theorem Nodup.erase_get [DecidableEq α] {l : List α} (hl : l.Nodup) (i : Fin l.length) :\n    l.erase (l.get i) = l.eraseIdx ↑i := by\n  simp [erase_getElem, hl]\n\n"}
{"name":"List.Nodup.diff","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl₁ l₂ : List α\ninst✝ : DecidableEq α\na✝ : l₁.Nodup\n⊢ (l₁.diff l₂).Nodup","decl":"theorem Nodup.diff [DecidableEq α] : l₁.Nodup → (l₁.diff l₂).Nodup :=\n  Nodup.sublist <| diff_sublist _ _\n\n"}
{"name":"List.nodup_flatten","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nL : List (List α)\n⊢ Iff L.flatten.Nodup (And (∀ (l : List α), Membership.mem L l → l.Nodup) (List.Pairwise List.Disjoint L))","decl":"theorem nodup_flatten {L : List (List α)} :\n    Nodup (flatten L) ↔ (∀ l ∈ L, Nodup l) ∧ Pairwise Disjoint L := by\n  simp only [Nodup, pairwise_flatten, disjoint_left.symm, forall_mem_ne]\n\n"}
{"name":"List.nodup_join","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nL : List (List α)\n⊢ Iff L.flatten.Nodup (And (∀ (l : List α), Membership.mem L l → l.Nodup) (List.Pairwise List.Disjoint L))","decl":"@[deprecated (since := \"2025-10-15\")] alias nodup_join := nodup_flatten\n\n"}
{"name":"List.nodup_flatMap","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nβ : Type v\nl₁ : List α\nf : α → List β\n⊢ Iff (l₁.flatMap f).Nodup (And (∀ (x : α), Membership.mem l₁ x → (f x).Nodup) (List.Pairwise (Function.onFun List.Disjoint f) l₁))","decl":"theorem nodup_flatMap {l₁ : List α} {f : α → List β} :\n    Nodup (l₁.flatMap f) ↔\n      (∀ x ∈ l₁, Nodup (f x)) ∧ Pairwise (Disjoint on f) l₁ := by\n  simp only [List.flatMap, nodup_flatten, pairwise_map, and_comm, and_left_comm, mem_map,\n    exists_imp, and_imp]\n  rw [show (∀ (l : List β) (x : α), f x = l → x ∈ l₁ → Nodup l) ↔ ∀ x : α, x ∈ l₁ → Nodup (f x)\n      from forall_swap.trans <| forall_congr' fun _ => forall_eq']\n\n"}
{"name":"List.nodup_bind","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nβ : Type v\nl₁ : List α\nf : α → List β\n⊢ Iff (l₁.flatMap f).Nodup (And (∀ (x : α), Membership.mem l₁ x → (f x).Nodup) (List.Pairwise (Function.onFun List.Disjoint f) l₁))","decl":"@[deprecated (since := \"2025-10-16\")] alias nodup_bind := nodup_flatMap\n\n"}
{"name":"List.Nodup.product","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nβ : Type v\nl₁ : List α\nl₂ : List β\nd₁ : l₁.Nodup\nd₂ : l₂.Nodup\n⊢ (SProd.sprod l₁ l₂).Nodup","decl":"protected theorem Nodup.product {l₂ : List β} (d₁ : l₁.Nodup) (d₂ : l₂.Nodup) :\n    (l₁ ×ˢ l₂).Nodup :=\n  nodup_flatMap.2\n    ⟨fun a _ => d₂.map <| LeftInverse.injective fun b => (rfl : (a, b).2 = b),\n      d₁.imp fun {a₁ a₂} n x h₁ h₂ => by\n        rcases mem_map.1 h₁ with ⟨b₁, _, rfl⟩\n        rcases mem_map.1 h₂ with ⟨b₂, mb₂, ⟨⟩⟩\n        exact n rfl⟩\n\n"}
{"name":"List.Nodup.sigma","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl₁ : List α\nσ : α → Type u_1\nl₂ : (a : α) → List (σ a)\nd₁ : l₁.Nodup\nd₂ : ∀ (a : α), (l₂ a).Nodup\n⊢ (l₁.sigma l₂).Nodup","decl":"theorem Nodup.sigma {σ : α → Type*} {l₂ : ∀ a , List (σ a)} (d₁ : Nodup l₁)\n    (d₂ : ∀ a , Nodup (l₂ a)) : (l₁.sigma l₂).Nodup :=\n  nodup_flatMap.2\n    ⟨fun a _ => (d₂ a).map fun b b' h => by injection h with _ h,\n      d₁.imp fun {a₁ a₂} n x h₁ h₂ => by\n        rcases mem_map.1 h₁ with ⟨b₁, _, rfl⟩\n        rcases mem_map.1 h₂ with ⟨b₂, mb₂, ⟨⟩⟩\n        exact n rfl⟩\n\n"}
{"name":"List.Nodup.filterMap","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nβ : Type v\nl : List α\nf : α → Option β\nh : ∀ (a a' : α) (b : β), Membership.mem (f a) b → Membership.mem (f a') b → Eq a a'\na✝ : l.Nodup\n⊢ (List.filterMap f l).Nodup","decl":"protected theorem Nodup.filterMap {f : α → Option β} (h : ∀ a a' b, b ∈ f a → b ∈ f a' → a = a') :\n    Nodup l → Nodup (filterMap f l) :=\n  (Pairwise.filterMap f) @fun a a' n b bm b' bm' e => n <| h a a' b' (by rw [← e]; exact bm) bm'\n\n"}
{"name":"List.Nodup.concat","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl : List α\na : α\nh : Not (Membership.mem l a)\nh' : l.Nodup\n⊢ (l.concat a).Nodup","decl":"protected theorem Nodup.concat (h : a ∉ l) (h' : l.Nodup) : (l.concat a).Nodup := by\n  rw [concat_eq_append]; exact h'.append (nodup_singleton _) (disjoint_singleton.2 h)\n\n"}
{"name":"List.Nodup.insert","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl : List α\na : α\ninst✝ : DecidableEq α\nh : l.Nodup\n⊢ (List.insert a l).Nodup","decl":"protected theorem Nodup.insert [DecidableEq α] (h : l.Nodup) : (l.insert a).Nodup :=\n  if h' : a ∈ l then by rw [insert_of_mem h']; exact h\n  else by rw [insert_of_not_mem h', nodup_cons]; constructor <;> assumption\n\n"}
{"name":"List.Nodup.union","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl₂ : List α\ninst✝ : DecidableEq α\nl₁ : List α\nh : l₂.Nodup\n⊢ (Union.union l₁ l₂).Nodup","decl":"theorem Nodup.union [DecidableEq α] (l₁ : List α) (h : Nodup l₂) : (l₁ ∪ l₂).Nodup := by\n  induction' l₁ with a l₁ ih generalizing l₂\n  · exact h\n  · exact (ih h).insert\n\n"}
{"name":"List.Nodup.inter","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl₁ : List α\ninst✝ : DecidableEq α\nl₂ : List α\na✝ : l₁.Nodup\n⊢ (Inter.inter l₁ l₂).Nodup","decl":"theorem Nodup.inter [DecidableEq α] (l₂ : List α) : Nodup l₁ → Nodup (l₁ ∩ l₂) :=\n  Nodup.filter _\n\n"}
{"name":"List.Nodup.diff_eq_filter","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\ninst✝¹ : BEq α\ninst✝ : LawfulBEq α\nl₁ l₂ : List α\nx✝ : l₁.Nodup\n⊢ Eq (l₁.diff l₂) (List.filter (fun x => Decidable.decide (Not (Membership.mem l₂ x))) l₁)","decl":"theorem Nodup.diff_eq_filter [BEq α] [LawfulBEq α] :\n    ∀ {l₁ l₂ : List α} (_ : l₁.Nodup), l₁.diff l₂ = l₁.filter (· ∉ l₂)\n  | l₁, [], _ => by simp\n  | l₁, a :: l₂, hl₁ => by\n    rw [diff_cons, (hl₁.erase _).diff_eq_filter, hl₁.erase_eq_filter, filter_filter]\n    simp only [decide_not, bne, Bool.and_comm, mem_cons, not_or, decide_mem_cons, Bool.not_or]\n\n"}
{"name":"List.Nodup.mem_diff_iff","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl₁ l₂ : List α\na : α\ninst✝ : DecidableEq α\nhl₁ : l₁.Nodup\n⊢ Iff (Membership.mem (l₁.diff l₂) a) (And (Membership.mem l₁ a) (Not (Membership.mem l₂ a)))","decl":"theorem Nodup.mem_diff_iff [DecidableEq α] (hl₁ : l₁.Nodup) : a ∈ l₁.diff l₂ ↔ a ∈ l₁ ∧ a ∉ l₂ := by\n  rw [hl₁.diff_eq_filter, mem_filter, decide_eq_true_iff]\n\n"}
{"name":"List.Nodup.set","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl : List α\nn : Nat\na : α\nx✝¹ : l.Nodup\nx✝ : Not (Membership.mem l a)\n⊢ (l.set n a).Nodup","decl":"protected theorem Nodup.set :\n    ∀ {l : List α} {n : ℕ} {a : α} (_ : l.Nodup) (_ : a ∉ l), (l.set n a).Nodup\n  | [], _, _, _, _ => nodup_nil\n  | _ :: _, 0, _, hl, ha => nodup_cons.2 ⟨mt (mem_cons_of_mem _) ha, (nodup_cons.1 hl).2⟩\n  | _ :: _, _ + 1, _, hl, ha =>\n    nodup_cons.2\n      ⟨fun h =>\n        (mem_or_eq_of_mem_set h).elim (nodup_cons.1 hl).1 fun hba => ha (hba ▸ mem_cons_self _ _),\n        hl.of_cons.set (mt (mem_cons_of_mem _) ha)⟩\n\n"}
{"name":"List.Nodup.map_update","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nβ : Type v\ninst✝ : DecidableEq α\nl : List α\nhl : l.Nodup\nf : α → β\nx : α\ny : β\n⊢ Eq (List.map (Function.update f x y) l) (ite (Membership.mem l x) ((List.map f l).set (List.indexOf x l) y) (List.map f l))","decl":"theorem Nodup.map_update [DecidableEq α] {l : List α} (hl : l.Nodup) (f : α → β) (x : α) (y : β) :\n    l.map (Function.update f x y) =\n      if x ∈ l then (l.map f).set (l.indexOf x) y else l.map f := by\n  induction' l with hd tl ihl; · simp\n  rw [nodup_cons] at hl\n  simp only [mem_cons, map, ihl hl.2]\n  by_cases H : hd = x\n  · subst hd\n    simp [set, hl.1]\n  · simp [Ne.symm H, H, set, ← apply_ite (cons (f hd))]\n\n"}
{"name":"List.Nodup.pairwise_of_forall_ne","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl : List α\nr : α → α → Prop\nhl : l.Nodup\nh : ∀ (a : α), Membership.mem l a → ∀ (b : α), Membership.mem l b → Ne a b → r a b\n⊢ List.Pairwise r l","decl":"theorem Nodup.pairwise_of_forall_ne {l : List α} {r : α → α → Prop} (hl : l.Nodup)\n    (h : ∀ a ∈ l, ∀ b ∈ l, a ≠ b → r a b) : l.Pairwise r := by\n  rw [pairwise_iff_forall_sublist]\n  intro a b hab\n  if heq : a = b then\n    cases heq; have := nodup_iff_sublist.mp hl _ hab; contradiction\n  else\n    apply h <;> try (apply hab.subset; simp)\n    exact heq\n\n"}
{"name":"List.Nodup.pairwise_of_set_pairwise","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl : List α\nr : α → α → Prop\nhl : l.Nodup\nh : (setOf fun x => Membership.mem l x).Pairwise r\n⊢ List.Pairwise r l","decl":"theorem Nodup.pairwise_of_set_pairwise {l : List α} {r : α → α → Prop} (hl : l.Nodup)\n    (h : { x | x ∈ l }.Pairwise r) : l.Pairwise r :=\n  hl.pairwise_of_forall_ne h\n\n"}
{"name":"List.Nodup.pairwise_coe","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\nl : List α\nr : α → α → Prop\ninst✝ : IsSymm α r\nhl : l.Nodup\n⊢ Iff ((setOf fun a => Membership.mem l a).Pairwise r) (List.Pairwise r l)","decl":"@[simp]\ntheorem Nodup.pairwise_coe [IsSymm α r] (hl : l.Nodup) :\n    { a | a ∈ l }.Pairwise r ↔ l.Pairwise r := by\n  induction' l with a l ih\n  · simp\n  rw [List.nodup_cons] at hl\n  have : ∀ b ∈ l, ¬a = b → r a b ↔ r a b := fun b hb =>\n    imp_iff_right (ne_of_mem_of_not_mem hb hl.1).symm\n  simp [Set.setOf_or, Set.pairwise_insert_of_symmetric fun _ _ ↦ symm_of r, ih hl.2, and_comm,\n    forall₂_congr this]\n\n"}
{"name":"List.Nodup.take_eq_filter_mem","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\ninst✝ : DecidableEq α\nl : List α\nn : Nat\nx✝ : l.Nodup\n⊢ Eq (List.take n l) (List.filter (fun a => List.elem a (List.take n l)) l)","decl":"theorem Nodup.take_eq_filter_mem [DecidableEq α] :\n    ∀ {l : List α} {n : ℕ} (_ : l.Nodup), l.take n = l.filter (l.take n).elem\n  | [], n, _ => by simp\n  | b::l, 0, _ => by simp\n  | b::l, n+1, hl => by\n    rw [take_succ_cons, Nodup.take_eq_filter_mem (Nodup.of_cons hl), filter_cons_of_pos (by simp)]\n    congr 1\n    refine List.filter_congr ?_\n    intro x hx\n    have : x ≠ b := fun h => (nodup_cons.1 hl).1 (h ▸ hx)\n    simp (config := {contextual := true}) [List.mem_filter, this, hx]\n"}
{"name":"Option.toList_nodup","module":"Mathlib.Data.List.Nodup","initialProofState":"α : Type u\no : Option α\n⊢ o.toList.Nodup","decl":"theorem Option.toList_nodup : ∀ o : Option α, o.toList.Nodup\n  | none => List.nodup_nil\n  | some x => List.nodup_singleton x\n"}
