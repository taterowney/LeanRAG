{"name":"strictMono_mersenne","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"⊢ StrictMono mersenne","decl":"theorem strictMono_mersenne : StrictMono mersenne := fun m n h ↦\n  (Nat.sub_lt_sub_iff_right <| Nat.one_le_pow _ _ two_pos).2 <| by gcongr; norm_num1\n\n"}
{"name":"mersenne_lt_mersenne","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"p q : Nat\n⊢ Iff (LT.lt (mersenne p) (mersenne q)) (LT.lt p q)","decl":"@[simp]\ntheorem mersenne_lt_mersenne {p q : ℕ} : mersenne p < mersenne q ↔ p < q :=\n  strictMono_mersenne.lt_iff_lt\n\n"}
{"name":"GCongr.mersenne_lt_mersenne","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"p q : Nat\na✝ : LT.lt p q\n⊢ LT.lt (mersenne p) (mersenne q)","decl":"@[gcongr] protected alias ⟨_, GCongr.mersenne_lt_mersenne⟩ := mersenne_lt_mersenne\n\n"}
{"name":"mersenne_le_mersenne","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"p q : Nat\n⊢ Iff (LE.le (mersenne p) (mersenne q)) (LE.le p q)","decl":"@[simp]\ntheorem mersenne_le_mersenne {p q : ℕ} : mersenne p ≤ mersenne q ↔ p ≤ q :=\n  strictMono_mersenne.le_iff_le\n\n"}
{"name":"GCongr.mersenne_le_mersenne","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"p q : Nat\na✝ : LE.le p q\n⊢ LE.le (mersenne p) (mersenne q)","decl":"@[gcongr] protected alias ⟨_, GCongr.mersenne_le_mersenne⟩ := mersenne_le_mersenne\n\n"}
{"name":"mersenne_zero","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"⊢ Eq (mersenne 0) 0","decl":"@[simp] theorem mersenne_zero : mersenne 0 = 0 := rfl\n\n"}
{"name":"mersenne_odd","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"p : Nat\n⊢ Iff (Odd (mersenne p)) (Ne p 0)","decl":"@[simp] lemma mersenne_odd : ∀ {p : ℕ}, Odd (mersenne p) ↔ p ≠ 0\n  | 0 => by simp\n  | p + 1 => by\n    simpa using Nat.Even.sub_odd (one_le_pow₀ one_le_two)\n      (even_two.pow_of_ne_zero p.succ_ne_zero) odd_one\n\n"}
{"name":"mersenne_pos","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"p : Nat\n⊢ Iff (LT.lt 0 (mersenne p)) (LT.lt 0 p)","decl":"@[simp] theorem mersenne_pos {p : ℕ} : 0 < mersenne p ↔ 0 < p := mersenne_lt_mersenne (p := 0)\n\n"}
{"name":"Mathlib.Meta.Positivity.mersenne_pos_of_pos","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"p : Nat\na✝ : LT.lt 0 p\n⊢ LT.lt 0 (mersenne p)","decl":"alias ⟨_, mersenne_pos_of_pos⟩ := mersenne_pos\n\n"}
{"name":"one_lt_mersenne","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"p : Nat\n⊢ Iff (LT.lt 1 (mersenne p)) (LT.lt 1 p)","decl":"@[simp]\ntheorem one_lt_mersenne {p : ℕ} : 1 < mersenne p ↔ 1 < p :=\n  mersenne_lt_mersenne (p := 1)\n\n"}
{"name":"succ_mersenne","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"k : Nat\n⊢ Eq (HAdd.hAdd (mersenne k) 1) (HPow.hPow 2 k)","decl":"@[simp]\ntheorem succ_mersenne (k : ℕ) : mersenne k + 1 = 2 ^ k := by\n  rw [mersenne, tsub_add_cancel_of_le]\n  exact one_le_pow₀ (by norm_num)\n\n"}
{"name":"LucasLehmer.mersenne_int_pos","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"p : Nat\nhp : Ne p 0\n⊢ LT.lt 0 (HSub.hSub (HPow.hPow 2 p) 1)","decl":"theorem mersenne_int_pos {p : ℕ} (hp : p ≠ 0) : (0 : ℤ) < 2 ^ p - 1 :=\n  sub_pos.2 <| mod_cast Nat.one_lt_two_pow hp\n\n"}
{"name":"LucasLehmer.mersenne_int_ne_zero","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"p : Nat\nhp : Ne p 0\n⊢ Ne (HSub.hSub (HPow.hPow 2 p) 1) 0","decl":"theorem mersenne_int_ne_zero (p : ℕ) (hp : p ≠ 0) : (2 ^ p - 1 : ℤ) ≠ 0 :=\n  (mersenne_int_pos hp).ne'\n\n"}
{"name":"LucasLehmer.sMod_nonneg","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"p : Nat\nhp : Ne p 0\ni : Nat\n⊢ LE.le 0 (LucasLehmer.sMod p i)","decl":"theorem sMod_nonneg (p : ℕ) (hp : p ≠ 0) (i : ℕ) : 0 ≤ sMod p i := by\n  cases i <;> dsimp [sMod]\n  · exact sup_eq_right.mp rfl\n  · apply Int.emod_nonneg\n    exact mersenne_int_ne_zero p hp\n\n"}
{"name":"LucasLehmer.sMod_mod","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"p i : Nat\n⊢ Eq (HMod.hMod (LucasLehmer.sMod p i) (HSub.hSub (HPow.hPow 2 p) 1)) (LucasLehmer.sMod p i)","decl":"theorem sMod_mod (p i : ℕ) : sMod p i % (2 ^ p - 1) = sMod p i := by cases i <;> simp [sMod]\n\n"}
{"name":"LucasLehmer.sMod_lt","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"p : Nat\nhp : Ne p 0\ni : Nat\n⊢ LT.lt (LucasLehmer.sMod p i) (HSub.hSub (HPow.hPow 2 p) 1)","decl":"theorem sMod_lt (p : ℕ) (hp : p ≠ 0) (i : ℕ) : sMod p i < 2 ^ p - 1 := by\n  rw [← sMod_mod]\n  refine (Int.emod_lt _ (mersenne_int_ne_zero p hp)).trans_eq ?_\n  exact abs_of_nonneg (mersenne_int_pos hp).le\n\n"}
{"name":"LucasLehmer.sZMod_eq_s","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"p' i : Nat\n⊢ Eq (LucasLehmer.sZMod (HAdd.hAdd p' 2) i) ↑(LucasLehmer.s i)","decl":"theorem sZMod_eq_s (p' : ℕ) (i : ℕ) : sZMod (p' + 2) i = (s i : ZMod (2 ^ (p' + 2) - 1)) := by\n  induction' i with i ih\n  · dsimp [s, sZMod]\n    norm_num\n  · push_cast [s, sZMod, ih]; rfl\n\n-- These next two don't make good `norm_cast` lemmas.\n"}
{"name":"LucasLehmer.Int.natCast_pow_pred","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"b p : Nat\nw : LT.lt 0 b\n⊢ Eq (↑(HSub.hSub (HPow.hPow b p) 1)) (HSub.hSub (HPow.hPow (↑b) p) 1)","decl":"theorem Int.natCast_pow_pred (b p : ℕ) (w : 0 < b) : ((b ^ p - 1 : ℕ) : ℤ) = (b : ℤ) ^ p - 1 := by\n  have : 1 ≤ b ^ p := Nat.one_le_pow p b w\n  norm_cast\n\n"}
{"name":"LucasLehmer.Int.coe_nat_two_pow_pred","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"p : Nat\n⊢ Eq (↑(HSub.hSub (HPow.hPow 2 p) 1)) (HSub.hSub (HPow.hPow 2 p) 1)","decl":"theorem Int.coe_nat_two_pow_pred (p : ℕ) : ((2 ^ p - 1 : ℕ) : ℤ) = (2 ^ p - 1 : ℤ) :=\n  Int.natCast_pow_pred 2 p (by decide)\n\n"}
{"name":"LucasLehmer.sZMod_eq_sMod","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"p i : Nat\n⊢ Eq (LucasLehmer.sZMod p i) ↑(LucasLehmer.sMod p i)","decl":"theorem sZMod_eq_sMod (p : ℕ) (i : ℕ) : sZMod p i = (sMod p i : ZMod (2 ^ p - 1)) := by\n  induction i <;> push_cast [← Int.coe_nat_two_pow_pred p, sMod, sZMod, *] <;> rfl\n\n"}
{"name":"LucasLehmer.residue_eq_zero_iff_sMod_eq_zero","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"p : Nat\nw : LT.lt 1 p\n⊢ Iff (Eq (LucasLehmer.lucasLehmerResidue p) 0) (Eq (LucasLehmer.sMod p (HSub.hSub p 2)) 0)","decl":"theorem residue_eq_zero_iff_sMod_eq_zero (p : ℕ) (w : 1 < p) :\n    lucasLehmerResidue p = 0 ↔ sMod p (p - 2) = 0 := by\n  dsimp [lucasLehmerResidue]\n  rw [sZMod_eq_sMod p]\n  constructor\n  · -- We want to use that fact that `0 ≤ s_mod p (p-2) < 2^p - 1`\n    -- and `lucas_lehmer_residue p = 0 → 2^p - 1 ∣ s_mod p (p-2)`.\n    intro h\n    simp? [ZMod.intCast_zmod_eq_zero_iff_dvd] at h says\n      simp only [ZMod.intCast_zmod_eq_zero_iff_dvd, ofNat_pos, pow_pos, cast_pred,\n        cast_pow, cast_ofNat] at h\n    apply Int.eq_zero_of_dvd_of_nonneg_of_lt _ _ h <;> clear h\n    · exact sMod_nonneg _ (by positivity) _\n    · exact sMod_lt _ (by positivity) _\n  · intro h\n    rw [h]\n    simp\n\n"}
{"name":"LucasLehmer.X.ext","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"q : PNat\nx y : LucasLehmer.X q\nh₁ : Eq x.1 y.1\nh₂ : Eq x.2 y.2\n⊢ Eq x y","decl":"@[ext]\ntheorem ext {x y : X q} (h₁ : x.1 = y.1) (h₂ : x.2 = y.2) : x = y := by\n  cases x; cases y; congr\n\n"}
{"name":"LucasLehmer.X.ext_iff","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"q : PNat\nx y : LucasLehmer.X q\n⊢ Iff (Eq x y) (And (Eq x.1 y.1) (Eq x.2 y.2))","decl":"@[ext]\ntheorem ext {x y : X q} (h₁ : x.1 = y.1) (h₂ : x.2 = y.2) : x = y := by\n  cases x; cases y; congr\n\n"}
{"name":"LucasLehmer.X.zero_fst","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"q : PNat\n⊢ Eq 0.1 0","decl":"@[simp] theorem zero_fst : (0 : X q).1 = 0 := rfl\n"}
{"name":"LucasLehmer.X.zero_snd","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"q : PNat\n⊢ Eq 0.2 0","decl":"@[simp] theorem zero_snd : (0 : X q).2 = 0 := rfl\n\n"}
{"name":"LucasLehmer.X.add_fst","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"q : PNat\nx y : LucasLehmer.X q\n⊢ Eq (HAdd.hAdd x y).1 (HAdd.hAdd x.1 y.1)","decl":"@[simp]\ntheorem add_fst (x y : X q) : (x + y).1 = x.1 + y.1 :=\n  rfl\n\n"}
{"name":"LucasLehmer.X.add_snd","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"q : PNat\nx y : LucasLehmer.X q\n⊢ Eq (HAdd.hAdd x y).2 (HAdd.hAdd x.2 y.2)","decl":"@[simp]\ntheorem add_snd (x y : X q) : (x + y).2 = x.2 + y.2 :=\n  rfl\n\n"}
{"name":"LucasLehmer.X.neg_fst","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"q : PNat\nx : LucasLehmer.X q\n⊢ Eq (Neg.neg x).1 (Neg.neg x.1)","decl":"@[simp]\ntheorem neg_fst (x : X q) : (-x).1 = -x.1 :=\n  rfl\n\n"}
{"name":"LucasLehmer.X.neg_snd","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"q : PNat\nx : LucasLehmer.X q\n⊢ Eq (Neg.neg x).2 (Neg.neg x.2)","decl":"@[simp]\ntheorem neg_snd (x : X q) : (-x).2 = -x.2 :=\n  rfl\n\n"}
{"name":"LucasLehmer.X.mul_fst","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"q : PNat\nx y : LucasLehmer.X q\n⊢ Eq (HMul.hMul x y).1 (HAdd.hAdd (HMul.hMul x.1 y.1) (HMul.hMul (HMul.hMul 3 x.2) y.2))","decl":"@[simp]\ntheorem mul_fst (x y : X q) : (x * y).1 = x.1 * y.1 + 3 * x.2 * y.2 :=\n  rfl\n\n"}
{"name":"LucasLehmer.X.mul_snd","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"q : PNat\nx y : LucasLehmer.X q\n⊢ Eq (HMul.hMul x y).2 (HAdd.hAdd (HMul.hMul x.1 y.2) (HMul.hMul x.2 y.1))","decl":"@[simp]\ntheorem mul_snd (x y : X q) : (x * y).2 = x.1 * y.2 + x.2 * y.1 :=\n  rfl\n\n"}
{"name":"LucasLehmer.X.one_fst","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"q : PNat\n⊢ Eq 1.1 1","decl":"@[simp]\ntheorem one_fst : (1 : X q).1 = 1 :=\n  rfl\n\n"}
{"name":"LucasLehmer.X.one_snd","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"q : PNat\n⊢ Eq 1.2 0","decl":"@[simp]\ntheorem one_snd : (1 : X q).2 = 0 :=\n  rfl\n\n"}
{"name":"LucasLehmer.X.fst_natCast","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"q : PNat\nn : Nat\n⊢ Eq (↑n).1 ↑n","decl":"@[simp] theorem fst_natCast (n : ℕ) : (n : X q).fst = (n : ZMod q) := rfl\n\n"}
{"name":"LucasLehmer.X.snd_natCast","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"q : PNat\nn : Nat\n⊢ Eq (↑n).2 0","decl":"@[simp] theorem snd_natCast (n : ℕ) : (n : X q).snd = (0 : ZMod q) := rfl\n\n"}
{"name":"LucasLehmer.X.ofNat_fst","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"q : PNat\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (OfNat.ofNat n).1 (OfNat.ofNat n)","decl":"@[simp] theorem ofNat_fst (n : ℕ) [n.AtLeastTwo] :\n    (ofNat(n) : X q).fst = OfNat.ofNat n :=\n  rfl\n\n"}
{"name":"LucasLehmer.X.ofNat_snd","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"q : PNat\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (OfNat.ofNat n).2 0","decl":"@[simp] theorem ofNat_snd (n : ℕ) [n.AtLeastTwo] :\n    (ofNat(n) : X q).snd = 0 :=\n  rfl\n\n"}
{"name":"LucasLehmer.X.left_distrib","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"q : PNat\nx y z : LucasLehmer.X q\n⊢ Eq (HMul.hMul x (HAdd.hAdd y z)) (HAdd.hAdd (HMul.hMul x y) (HMul.hMul x z))","decl":"theorem left_distrib (x y z : X q) : x * (y + z) = x * y + x * z := by\n  ext <;> dsimp <;> ring\n\n"}
{"name":"LucasLehmer.X.right_distrib","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"q : PNat\nx y z : LucasLehmer.X q\n⊢ Eq (HMul.hMul (HAdd.hAdd x y) z) (HAdd.hAdd (HMul.hMul x z) (HMul.hMul y z))","decl":"theorem right_distrib (x y z : X q) : (x + y) * z = x * z + y * z := by\n  ext <;> dsimp <;> ring\n\n"}
{"name":"LucasLehmer.X.instNontrivialOfFactLtNatOfNatVal","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"q : PNat\ninst✝ : Fact (LT.lt 1 ↑q)\n⊢ Nontrivial (LucasLehmer.X q)","decl":"instance [Fact (1 < (q : ℕ))] : Nontrivial (X q) :=\n  ⟨⟨0, 1, ne_of_apply_ne Prod.fst zero_ne_one⟩⟩\n\n"}
{"name":"LucasLehmer.X.fst_intCast","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"q : PNat\nn : Int\n⊢ Eq (↑n).1 ↑n","decl":"@[simp]\ntheorem fst_intCast (n : ℤ) : (n : X q).fst = (n : ZMod q) :=\n  rfl\n\n"}
{"name":"LucasLehmer.X.snd_intCast","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"q : PNat\nn : Int\n⊢ Eq (↑n).2 0","decl":"@[simp]\ntheorem snd_intCast (n : ℤ) : (n : X q).snd = (0 : ZMod q) :=\n  rfl\n\n"}
{"name":"LucasLehmer.X.coe_mul","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"q : PNat\nn m : Int\n⊢ Eq (↑(HMul.hMul n m)) (HMul.hMul ↑n ↑m)","decl":"@[norm_cast]\ntheorem coe_mul (n m : ℤ) : ((n * m : ℤ) : X q) = (n : X q) * (m : X q) := by ext <;> simp\n\n"}
{"name":"LucasLehmer.X.coe_natCast","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"q : PNat\nn : Nat\n⊢ Eq ↑↑n ↑n","decl":"@[norm_cast]\ntheorem coe_natCast (n : ℕ) : ((n : ℤ) : X q) = (n : X q) := by ext <;> simp\n\n"}
{"name":"LucasLehmer.X.card_eq","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"q : PNat\n⊢ Eq (Fintype.card (LucasLehmer.X q)) (HPow.hPow (↑q) 2)","decl":"/-- The cardinality of `X` is `q^2`. -/\ntheorem card_eq : Fintype.card (X q) = q ^ 2 := by\n  dsimp [X]\n  rw [Fintype.card_prod, ZMod.card q, sq]\n\n"}
{"name":"LucasLehmer.X.card_units_lt","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"q : PNat\nw : LT.lt 1 q\n⊢ LT.lt (Fintype.card (Units (LucasLehmer.X q))) (HPow.hPow (↑q) 2)","decl":"/-- There are strictly fewer than `q^2` units, since `0` is not a unit. -/\nnonrec theorem card_units_lt (w : 1 < q) : Fintype.card (X q)ˣ < q ^ 2 := by\n  have : Fact (1 < (q : ℕ)) := ⟨w⟩\n  convert card_units_lt (X q)\n  rw [card_eq]\n\n"}
{"name":"LucasLehmer.X.ω_mul_ωb","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"q : PNat\n⊢ Eq (HMul.hMul LucasLehmer.X.ω LucasLehmer.X.ωb) 1","decl":"theorem ω_mul_ωb (q : ℕ+) : (ω : X q) * ωb = 1 := by\n  dsimp [ω, ωb]\n  ext <;> simp; ring\n\n"}
{"name":"LucasLehmer.X.ωb_mul_ω","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"q : PNat\n⊢ Eq (HMul.hMul LucasLehmer.X.ωb LucasLehmer.X.ω) 1","decl":"theorem ωb_mul_ω (q : ℕ+) : (ωb : X q) * ω = 1 := by\n  rw [mul_comm, ω_mul_ωb]\n\n"}
{"name":"LucasLehmer.X.closed_form","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"q : PNat\ni : Nat\n⊢ Eq (↑(LucasLehmer.s i)) (HAdd.hAdd (HPow.hPow LucasLehmer.X.ω (HPow.hPow 2 i)) (HPow.hPow LucasLehmer.X.ωb (HPow.hPow 2 i)))","decl":"/-- A closed form for the recurrence relation. -/\ntheorem closed_form (i : ℕ) : (s i : X q) = (ω : X q) ^ 2 ^ i + (ωb : X q) ^ 2 ^ i := by\n  induction' i with i ih\n  · dsimp [s, ω, ωb]\n    ext <;> norm_num\n  · calc\n      (s (i + 1) : X q) = (s i ^ 2 - 2 : ℤ) := rfl\n      _ = (s i : X q) ^ 2 - 2 := by push_cast; rfl\n      _ = (ω ^ 2 ^ i + ωb ^ 2 ^ i) ^ 2 - 2 := by rw [ih]\n      _ = (ω ^ 2 ^ i) ^ 2 + (ωb ^ 2 ^ i) ^ 2 + 2 * (ωb ^ 2 ^ i * ω ^ 2 ^ i) - 2 := by ring\n      _ = (ω ^ 2 ^ i) ^ 2 + (ωb ^ 2 ^ i) ^ 2 := by\n        rw [← mul_pow ωb ω, ωb_mul_ω, one_pow, mul_one, add_sub_cancel_right]\n      _ = ω ^ 2 ^ (i + 1) + ωb ^ 2 ^ (i + 1) := by rw [← pow_mul, ← pow_mul, _root_.pow_succ]\n\n"}
{"name":"LucasLehmer.two_lt_q","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"p' : Nat\n⊢ LT.lt 2 (LucasLehmer.q (HAdd.hAdd p' 2))","decl":"/-- If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. -/\ntheorem two_lt_q (p' : ℕ) : 2 < q (p' + 2) := by\n  refine (minFac_prime (one_lt_mersenne.2 ?_).ne').two_le.lt_of_ne' ?_\n  · exact le_add_left _ _\n  · rw [Ne, minFac_eq_two_iff, mersenne, Nat.pow_succ']\n    exact Nat.two_not_dvd_two_mul_sub_one Nat.one_le_two_pow\n\n"}
{"name":"LucasLehmer.ω_pow_formula","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"p' : Nat\nh : Eq (LucasLehmer.lucasLehmerResidue (HAdd.hAdd p' 2)) 0\n⊢ Exists fun k => Eq (HPow.hPow LucasLehmer.X.ω (HPow.hPow 2 (HAdd.hAdd p' 1))) (HSub.hSub (HMul.hMul (HMul.hMul ↑k ↑(mersenne (HAdd.hAdd p' 2))) (HPow.hPow LucasLehmer.X.ω (HPow.hPow 2 p'))) 1)","decl":"theorem ω_pow_formula (p' : ℕ) (h : lucasLehmerResidue (p' + 2) = 0) :\n    ∃ k : ℤ,\n      (ω : X (q (p' + 2))) ^ 2 ^ (p' + 1) =\n        k * mersenne (p' + 2) * (ω : X (q (p' + 2))) ^ 2 ^ p' - 1 := by\n  dsimp [lucasLehmerResidue] at h\n  rw [sZMod_eq_s p'] at h\n  simp? [ZMod.intCast_zmod_eq_zero_iff_dvd] at h says\n    simp only [add_tsub_cancel_right, ZMod.intCast_zmod_eq_zero_iff_dvd, ofNat_pos,\n      pow_pos, cast_pred, cast_pow, cast_ofNat] at h\n  cases' h with k h\n  use k\n  replace h := congr_arg (fun n : ℤ => (n : X (q (p' + 2)))) h\n  -- coercion from ℤ to X q\n  dsimp at h\n  rw [closed_form] at h\n  replace h := congr_arg (fun x => ω ^ 2 ^ p' * x) h\n  dsimp at h\n  have t : 2 ^ p' + 2 ^ p' = 2 ^ (p' + 1) := by ring\n  rw [mul_add, ← pow_add ω, t, ← mul_pow ω ωb (2 ^ p'), ω_mul_ωb, one_pow] at h\n  rw [mul_comm, coe_mul] at h\n  rw [mul_comm _ (k : X (q (p' + 2)))] at h\n  replace h := eq_sub_of_add_eq h\n  have : 1 ≤ 2 ^ (p' + 2) := Nat.one_le_pow _ _ (by decide)\n  exact mod_cast h\n\n"}
{"name":"LucasLehmer.mersenne_coe_X","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"p : Nat\n⊢ Eq (↑(mersenne p)) 0","decl":"/-- `q` is the minimum factor of `mersenne p`, so `M p = 0` in `X q`. -/\ntheorem mersenne_coe_X (p : ℕ) : (mersenne p : X (q p)) = 0 := by\n  ext <;> simp [mersenne, q, ZMod.natCast_zmod_eq_zero_iff_dvd, -pow_pos]\n  apply Nat.minFac_dvd\n\n"}
{"name":"LucasLehmer.ω_pow_eq_neg_one","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"p' : Nat\nh : Eq (LucasLehmer.lucasLehmerResidue (HAdd.hAdd p' 2)) 0\n⊢ Eq (HPow.hPow LucasLehmer.X.ω (HPow.hPow 2 (HAdd.hAdd p' 1))) (-1)","decl":"theorem ω_pow_eq_neg_one (p' : ℕ) (h : lucasLehmerResidue (p' + 2) = 0) :\n    (ω : X (q (p' + 2))) ^ 2 ^ (p' + 1) = -1 := by\n  cases' ω_pow_formula p' h with k w\n  rw [mersenne_coe_X] at w\n  simpa using w\n\n"}
{"name":"LucasLehmer.ω_pow_eq_one","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"p' : Nat\nh : Eq (LucasLehmer.lucasLehmerResidue (HAdd.hAdd p' 2)) 0\n⊢ Eq (HPow.hPow LucasLehmer.X.ω (HPow.hPow 2 (HAdd.hAdd p' 2))) 1","decl":"theorem ω_pow_eq_one (p' : ℕ) (h : lucasLehmerResidue (p' + 2) = 0) :\n    (ω : X (q (p' + 2))) ^ 2 ^ (p' + 2) = 1 :=\n  calc\n    (ω : X (q (p' + 2))) ^ 2 ^ (p' + 2) = (ω ^ 2 ^ (p' + 1)) ^ 2 := by\n      rw [← pow_mul, ← Nat.pow_succ]\n    _ = (-1) ^ 2 := by rw [ω_pow_eq_neg_one p' h]\n    _ = 1 := by simp\n\n"}
{"name":"LucasLehmer.ωUnit_coe","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"p : Nat\n⊢ Eq (↑(LucasLehmer.ωUnit p)) LucasLehmer.X.ω","decl":"@[simp]\ntheorem ωUnit_coe (p : ℕ) : (ωUnit p : X (q p)) = ω :=\n  rfl\n\n"}
{"name":"LucasLehmer.order_ω","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"p' : Nat\nh : Eq (LucasLehmer.lucasLehmerResidue (HAdd.hAdd p' 2)) 0\n⊢ Eq (orderOf (LucasLehmer.ωUnit (HAdd.hAdd p' 2))) (HPow.hPow 2 (HAdd.hAdd p' 2))","decl":"/-- The order of `ω` in the unit group is exactly `2^p`. -/\ntheorem order_ω (p' : ℕ) (h : lucasLehmerResidue (p' + 2) = 0) :\n    orderOf (ωUnit (p' + 2)) = 2 ^ (p' + 2) := by\n  apply Nat.eq_prime_pow_of_dvd_least_prime_pow\n  -- the order of ω divides 2^p\n  · exact Nat.prime_two\n  · intro o\n    have ω_pow := orderOf_dvd_iff_pow_eq_one.1 o\n    replace ω_pow :=\n      congr_arg (Units.coeHom (X (q (p' + 2))) : Units (X (q (p' + 2))) → X (q (p' + 2))) ω_pow\n    simp? at ω_pow says\n      simp only [Units.coeHom_apply, Units.val_pow_eq_pow_val, ωUnit_coe, Units.val_one] at ω_pow\n    have h : (1 : ZMod (q (p' + 2))) = -1 :=\n      congr_arg Prod.fst (ω_pow.symm.trans (ω_pow_eq_neg_one p' h))\n    haveI : Fact (2 < (q (p' + 2) : ℕ)) := ⟨two_lt_q _⟩\n    apply ZMod.neg_one_ne_one h.symm\n  · apply orderOf_dvd_iff_pow_eq_one.2\n    apply Units.ext\n    push_cast\n    exact ω_pow_eq_one p' h\n\n"}
{"name":"LucasLehmer.order_ineq","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"p' : Nat\nh : Eq (LucasLehmer.lucasLehmerResidue (HAdd.hAdd p' 2)) 0\n⊢ LT.lt (HPow.hPow 2 (HAdd.hAdd p' 2)) (HPow.hPow (↑(LucasLehmer.q (HAdd.hAdd p' 2))) 2)","decl":"theorem order_ineq (p' : ℕ) (h : lucasLehmerResidue (p' + 2) = 0) :\n    2 ^ (p' + 2) < (q (p' + 2) : ℕ) ^ 2 :=\n  calc\n    2 ^ (p' + 2) = orderOf (ωUnit (p' + 2)) := (order_ω p' h).symm\n    _ ≤ Fintype.card (X (q (p' + 2)))ˣ := orderOf_le_card_univ\n    _ < (q (p' + 2) : ℕ) ^ 2 := card_units_lt (Nat.lt_of_succ_lt (two_lt_q _))\n\n"}
{"name":"lucas_lehmer_sufficiency","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"p : Nat\nw : LT.lt 1 p\na✝ : LucasLehmer.LucasLehmerTest p\n⊢ Nat.Prime (mersenne p)","decl":"theorem lucas_lehmer_sufficiency (p : ℕ) (w : 1 < p) : LucasLehmerTest p → (mersenne p).Prime := by\n  let p' := p - 2\n  have z : p = p' + 2 := (tsub_eq_iff_eq_add_of_le w.nat_succ_le).mp rfl\n  have w : 1 < p' + 2 := Nat.lt_of_sub_eq_succ rfl\n  contrapose\n  intro a t\n  rw [z] at a\n  rw [z] at t\n  have h₁ := order_ineq p' t\n  have h₂ := Nat.minFac_sq_le_self (mersenne_pos.2 (Nat.lt_of_succ_lt w)) a\n  have h := lt_of_lt_of_le h₁ h₂\n  exact not_lt_of_ge (Nat.sub_le _ _) h\n\n"}
{"name":"LucasLehmer.norm_num_ext.sModNat_eq_sMod","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"p k : Nat\nhp : LE.le 2 p\n⊢ Eq (↑(LucasLehmer.norm_num_ext.sModNat (HSub.hSub (HPow.hPow 2 p) 1) k)) (LucasLehmer.sMod p k)","decl":"theorem sModNat_eq_sMod (p k : ℕ) (hp : 2 ≤ p) : (sModNat (2 ^ p - 1) k : ℤ) = sMod p k := by\n  have h1 := calc\n    4 = 2 ^ 2 := by norm_num\n    _ ≤ 2 ^ p := Nat.pow_le_pow_of_le_right (by norm_num) hp\n  have h2 : 1 ≤ 2 ^ p := by omega\n  induction k with\n  | zero =>\n    rw [sModNat, sMod, Int.ofNat_emod]\n    simp [h2]\n  | succ k ih =>\n    rw [sModNat, sMod, ← ih]\n    have h3 : 2 ≤ 2 ^ p - 1 := by\n      zify [h2]\n      calc\n        (2 : Int) ≤ 4 - 1 := by norm_num\n        _         ≤ 2 ^ p - 1 := by zify at h1; exact Int.sub_le_sub_right h1 _\n    zify [h2, h3]\n    rw [← add_sub_assoc, sub_eq_add_neg, add_assoc, add_comm _ (-2), ← add_assoc,\n      Int.add_emod_self, ← sub_eq_add_neg]\n\n"}
{"name":"LucasLehmer.norm_num_ext.sModNat_aux_eq","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"q k : Nat\n⊢ Eq (LucasLehmer.norm_num_ext.sModNat_aux (HMod.hMod 4 q) q k) (LucasLehmer.norm_num_ext.sModNat q k)","decl":"theorem sModNat_aux_eq (q k : ℕ) : sModNat_aux (4 % q) q k = sModNat q k := by\n  induction k with\n  | zero => rfl\n  | succ k ih => rw [sModNat_aux, ih, sModNat, ← ih]\n\n"}
{"name":"LucasLehmer.norm_num_ext.sModNatTR_eq_sModNat","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"q i : Nat\n⊢ Eq (LucasLehmer.norm_num_ext.sModNatTR q i) (LucasLehmer.norm_num_ext.sModNat q i)","decl":"theorem sModNatTR_eq_sModNat (q : ℕ) (i : ℕ) : sModNatTR q i = sModNat q i := by\n  rw [sModNatTR, helper, sModNat_aux_eq]\nwhere\n  helper b q k : sModNatTR.go q k b = sModNat_aux b q k := by\n    induction k generalizing b with\n    | zero => rfl\n    | succ k ih =>\n      rw [sModNatTR.go, ih, sModNat_aux]\n      clear ih\n      induction k with\n      | zero => rfl\n      | succ k ih =>\n        rw [sModNat_aux, ih, sModNat_aux]\n\n"}
{"name":"LucasLehmer.norm_num_ext.sModNatTR_eq_sModNat.helper","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"b q k : Nat\n⊢ Eq (LucasLehmer.norm_num_ext.sModNatTR.go q k b) (LucasLehmer.norm_num_ext.sModNat_aux b q k)","decl":"theorem sModNatTR_eq_sModNat (q : ℕ) (i : ℕ) : sModNatTR q i = sModNat q i := by\n  rw [sModNatTR, helper, sModNat_aux_eq]\nwhere\n  helper b q k : sModNatTR.go q k b = sModNat_aux b q k := by\n    induction k generalizing b with\n    | zero => rfl\n    | succ k ih =>\n      rw [sModNatTR.go, ih, sModNat_aux]\n      clear ih\n      induction k with\n      | zero => rfl\n      | succ k ih =>\n        rw [sModNat_aux, ih, sModNat_aux]\n\n"}
{"name":"LucasLehmer.norm_num_ext.testTrueHelper","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"p : Nat\nhp : Eq (Nat.blt 1 p) Bool.true\nh : Eq (LucasLehmer.norm_num_ext.sModNatTR (HSub.hSub (HPow.hPow 2 p) 1) (HSub.hSub p 2)) 0\n⊢ LucasLehmer.LucasLehmerTest p","decl":"lemma testTrueHelper (p : ℕ) (hp : Nat.blt 1 p = true) (h : sModNatTR (2 ^ p - 1) (p - 2) = 0) :\n    LucasLehmerTest p := by\n  rw [Nat.blt_eq] at hp\n  rw [LucasLehmerTest, LucasLehmer.residue_eq_zero_iff_sMod_eq_zero p hp, ← sModNat_eq_sMod p _ hp,\n    ← sModNatTR_eq_sModNat, h]\n  rfl\n\n"}
{"name":"LucasLehmer.norm_num_ext.testFalseHelper","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"p : Nat\nhp : Eq (Nat.blt 1 p) Bool.true\nh : Eq (Nat.ble 1 (LucasLehmer.norm_num_ext.sModNatTR (HSub.hSub (HPow.hPow 2 p) 1) (HSub.hSub p 2))) Bool.true\n⊢ Not (LucasLehmer.LucasLehmerTest p)","decl":"lemma testFalseHelper (p : ℕ) (hp : Nat.blt 1 p = true)\n    (h : Nat.ble 1 (sModNatTR (2 ^ p - 1) (p - 2))) : ¬ LucasLehmerTest p := by\n  rw [Nat.blt_eq] at hp\n  rw [Nat.ble_eq, Nat.succ_le, Nat.pos_iff_ne_zero] at h\n  rw [LucasLehmerTest, LucasLehmer.residue_eq_zero_iff_sMod_eq_zero p hp, ← sModNat_eq_sMod p _ hp,\n    ← sModNatTR_eq_sModNat]\n  simpa using h\n\n"}
{"name":"LucasLehmer.norm_num_ext.isNat_lucasLehmerTest","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"p np : Nat\na✝¹ : Mathlib.Meta.NormNum.IsNat p np\na✝ : LucasLehmer.LucasLehmerTest np\n⊢ LucasLehmer.LucasLehmerTest p","decl":"theorem isNat_lucasLehmerTest : {p np : ℕ} →\n    IsNat p np → LucasLehmerTest np → LucasLehmerTest p\n  | _, _, ⟨rfl⟩, h => h\n\n"}
{"name":"LucasLehmer.norm_num_ext.isNat_not_lucasLehmerTest","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"p np : Nat\na✝¹ : Mathlib.Meta.NormNum.IsNat p np\na✝ : Not (LucasLehmer.LucasLehmerTest np)\n⊢ Not (LucasLehmer.LucasLehmerTest p)","decl":"theorem isNat_not_lucasLehmerTest : {p np : ℕ} →\n    IsNat p np → ¬ LucasLehmerTest np → ¬ LucasLehmerTest p\n  | _, _, ⟨rfl⟩, h => h\n\n"}
{"name":"modEq_mersenne","module":"Mathlib.NumberTheory.LucasLehmer","initialProofState":"n k : Nat\n⊢ (HSub.hSub (HPow.hPow 2 n) 1).ModEq k (HAdd.hAdd (HDiv.hDiv k (HPow.hPow 2 n)) (HMod.hMod k (HPow.hPow 2 n)))","decl":"theorem modEq_mersenne (n k : ℕ) : k ≡ k / 2 ^ n + k % 2 ^ n [MOD 2 ^ n - 1] :=\n  -- See https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/help.20finding.20a.20lemma/near/177698446\n  calc\n    k = 2 ^ n * (k / 2 ^ n) + k % 2 ^ n := (Nat.div_add_mod k (2 ^ n)).symm\n    _ ≡ 1 * (k / 2 ^ n) + k % 2 ^ n [MOD 2 ^ n - 1] :=\n      ((Nat.modEq_sub <| Nat.succ_le_of_lt <| pow_pos zero_lt_two _).mul_right _).add_right _\n    _ = k / 2 ^ n + k % 2 ^ n := by rw [one_mul]\n\n-- It's hard to know what the limiting factor for large Mersenne primes would be.\n-- In the purely computational world, I think it's the squaring operation in `s`.\n"}
