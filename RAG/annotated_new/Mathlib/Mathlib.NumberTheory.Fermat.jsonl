{"name":"Nat.fermatNumber_zero","module":"Mathlib.NumberTheory.Fermat","initialProofState":"⊢ Eq (Nat.fermatNumber 0) 3","decl":"@[simp] theorem fermatNumber_zero : fermatNumber 0 = 3 := rfl\n"}
{"name":"Nat.fermatNumber_one","module":"Mathlib.NumberTheory.Fermat","initialProofState":"⊢ Eq (Nat.fermatNumber 1) 5","decl":"@[simp] theorem fermatNumber_one : fermatNumber 1 = 5 := rfl\n"}
{"name":"Nat.fermatNumber_two","module":"Mathlib.NumberTheory.Fermat","initialProofState":"⊢ Eq (Nat.fermatNumber 2) 17","decl":"@[simp] theorem fermatNumber_two : fermatNumber 2 = 17 := rfl\n\n"}
{"name":"Nat.fermatNumber_strictMono","module":"Mathlib.NumberTheory.Fermat","initialProofState":"⊢ StrictMono Nat.fermatNumber","decl":"theorem fermatNumber_strictMono : StrictMono fermatNumber := by\n  intro m n\n  simp only [fermatNumber, add_lt_add_iff_right, Nat.pow_lt_pow_iff_right (one_lt_two : 1 < 2),\n    imp_self]\n\n"}
{"name":"Nat.strictMono_fermatNumber","module":"Mathlib.NumberTheory.Fermat","initialProofState":"⊢ StrictMono Nat.fermatNumber","decl":"@[deprecated (since := \"2024-11-25\")] alias strictMono_fermatNumber := fermatNumber_strictMono\n\n"}
{"name":"Nat.fermatNumber_mono","module":"Mathlib.NumberTheory.Fermat","initialProofState":"⊢ Monotone Nat.fermatNumber","decl":"lemma fermatNumber_mono : Monotone fermatNumber := fermatNumber_strictMono.monotone\n"}
{"name":"Nat.fermatNumber_injective","module":"Mathlib.NumberTheory.Fermat","initialProofState":"⊢ Function.Injective Nat.fermatNumber","decl":"lemma fermatNumber_injective : Injective fermatNumber := fermatNumber_strictMono.injective\n\n"}
{"name":"Nat.three_le_fermatNumber","module":"Mathlib.NumberTheory.Fermat","initialProofState":"n : Nat\n⊢ LE.le 3 n.fermatNumber","decl":"lemma three_le_fermatNumber (n : ℕ) : 3 ≤ fermatNumber n := fermatNumber_mono n.zero_le\n"}
{"name":"Nat.two_lt_fermatNumber","module":"Mathlib.NumberTheory.Fermat","initialProofState":"n : Nat\n⊢ LT.lt 2 n.fermatNumber","decl":"lemma two_lt_fermatNumber (n : ℕ) : 2 < fermatNumber n := three_le_fermatNumber _\n\n"}
{"name":"Nat.fermatNumber_ne_one","module":"Mathlib.NumberTheory.Fermat","initialProofState":"n : Nat\n⊢ Ne n.fermatNumber 1","decl":"lemma fermatNumber_ne_one (n : ℕ) : fermatNumber n ≠ 1 := by have := three_le_fermatNumber n; omega\n\n"}
{"name":"Nat.odd_fermatNumber","module":"Mathlib.NumberTheory.Fermat","initialProofState":"n : Nat\n⊢ Odd n.fermatNumber","decl":"theorem odd_fermatNumber (n : ℕ) : Odd (fermatNumber n) :=\n  (even_pow.mpr ⟨even_two, (pow_pos two_pos n).ne'⟩).add_one\n\n"}
{"name":"Nat.prod_fermatNumber","module":"Mathlib.NumberTheory.Fermat","initialProofState":"n : Nat\n⊢ Eq ((Finset.range n).prod fun k => k.fermatNumber) (HSub.hSub n.fermatNumber 2)","decl":"theorem prod_fermatNumber (n : ℕ) : ∏ k ∈ range n, fermatNumber k = fermatNumber n - 2 := by\n  induction' n with n hn\n  · rfl\n  rw [prod_range_succ, hn, fermatNumber, fermatNumber, mul_comm,\n    (show 2 ^ 2 ^ n + 1 - 2 = 2 ^ 2 ^ n - 1 by omega), ← sq_sub_sq]\n  ring_nf\n  omega\n\n"}
{"name":"Nat.fermatNumber_product","module":"Mathlib.NumberTheory.Fermat","initialProofState":"n : Nat\n⊢ Eq ((Finset.range n).prod fun k => k.fermatNumber) (HSub.hSub n.fermatNumber 2)","decl":"@[deprecated (since := \"2024-11-25\")] alias fermatNumber_product := prod_fermatNumber\n\n"}
{"name":"Nat.fermatNumber_eq_prod_add_two","module":"Mathlib.NumberTheory.Fermat","initialProofState":"n : Nat\n⊢ Eq n.fermatNumber (HAdd.hAdd ((Finset.range n).prod fun k => k.fermatNumber) 2)","decl":"theorem fermatNumber_eq_prod_add_two (n : ℕ) :\n    fermatNumber n = ∏ k ∈ range n, fermatNumber k + 2 := by\n  rw [prod_fermatNumber, Nat.sub_add_cancel]\n  exact le_of_lt <| two_lt_fermatNumber _\n\n"}
{"name":"Nat.fermatNumber_succ","module":"Mathlib.NumberTheory.Fermat","initialProofState":"n : Nat\n⊢ Eq (HAdd.hAdd n 1).fermatNumber (HAdd.hAdd (HPow.hPow (HSub.hSub n.fermatNumber 1) 2) 1)","decl":"theorem fermatNumber_succ (n : ℕ) : fermatNumber (n + 1) = (fermatNumber n - 1) ^ 2 + 1 := by\n  rw [fermatNumber, pow_succ, mul_comm, pow_mul']\n  rfl\n\n"}
{"name":"Nat.two_mul_fermatNumber_sub_one_sq_le_fermatNumber_sq","module":"Mathlib.NumberTheory.Fermat","initialProofState":"n : Nat\n⊢ LE.le (HMul.hMul 2 (HPow.hPow (HSub.hSub n.fermatNumber 1) 2)) (HPow.hPow (HAdd.hAdd n 1).fermatNumber 2)","decl":"theorem two_mul_fermatNumber_sub_one_sq_le_fermatNumber_sq (n : ℕ) :\n    2 * (fermatNumber n - 1) ^ 2 ≤ (fermatNumber (n + 1)) ^ 2 := by\n  simp only [fermatNumber, add_tsub_cancel_right]\n  have : 0 ≤ 1 + 2 ^ (2 ^ n * 4) := le_add_left _ _\n  ring_nf\n  omega\n\n"}
{"name":"Nat.fermatNumber_eq_fermatNumber_sq_sub_two_mul_fermatNumber_sub_one_sq","module":"Mathlib.NumberTheory.Fermat","initialProofState":"n : Nat\n⊢ Eq (HAdd.hAdd n 2).fermatNumber (HSub.hSub (HPow.hPow (HAdd.hAdd n 1).fermatNumber 2) (HMul.hMul 2 (HPow.hPow (HSub.hSub n.fermatNumber 1) 2)))","decl":"theorem fermatNumber_eq_fermatNumber_sq_sub_two_mul_fermatNumber_sub_one_sq (n : ℕ) :\n    fermatNumber (n + 2) = (fermatNumber (n + 1)) ^ 2 - 2 * (fermatNumber n - 1) ^ 2 := by\n  simp only [fermatNumber, add_sub_self_right]\n  rw [← add_sub_self_right (2 ^ 2 ^ (n + 2) + 1) <| 2 * 2 ^ 2 ^ (n + 1)]\n  ring_nf\n\n"}
{"name":"Int.fermatNumber_eq_fermatNumber_sq_sub_two_mul_fermatNumber_sub_one_sq","module":"Mathlib.NumberTheory.Fermat","initialProofState":"n : Nat\n⊢ Eq (↑(HAdd.hAdd n 2).fermatNumber) (HSub.hSub (HPow.hPow (↑(HAdd.hAdd n 1).fermatNumber) 2) (HMul.hMul 2 (HPow.hPow (HSub.hSub (↑n.fermatNumber) 1) 2)))","decl":"theorem Int.fermatNumber_eq_fermatNumber_sq_sub_two_mul_fermatNumber_sub_one_sq (n : ℕ) :\n    (fermatNumber (n + 2) : ℤ)  = (fermatNumber (n + 1)) ^ 2 - 2 * (fermatNumber n - 1) ^ 2 := by\n  rw [Nat.fermatNumber_eq_fermatNumber_sq_sub_two_mul_fermatNumber_sub_one_sq,\n    Nat.cast_sub <| two_mul_fermatNumber_sub_one_sq_le_fermatNumber_sq n]\n  simp only [fermatNumber, push_cast, add_tsub_cancel_right]\n\n"}
{"name":"Nat.coprime_fermatNumber_fermatNumber","module":"Mathlib.NumberTheory.Fermat","initialProofState":"m n : Nat\nhmn : Ne m n\n⊢ m.fermatNumber.Coprime n.fermatNumber","decl":"/--\n**Goldbach's theorem** : no two distinct Fermat numbers share a common factor greater than one.\n\nFrom a letter to Euler, see page 37 in [juskevic2022].\n-/\ntheorem coprime_fermatNumber_fermatNumber {m n : ℕ} (hmn : m ≠ n) :\n    Coprime (fermatNumber m) (fermatNumber n) := by\n  wlog hmn' : m < n\n  · simpa only [coprime_comm] using this hmn.symm (by omega)\n  let d := (fermatNumber m).gcd (fermatNumber n)\n  have h_n : d ∣ fermatNumber n := gcd_dvd_right ..\n  have h_m : d ∣ 2 := (Nat.dvd_add_right <| (gcd_dvd_left _ _).trans <| dvd_prod_of_mem _\n    <| mem_range.mpr hmn').mp <| fermatNumber_eq_prod_add_two _ ▸ h_n\n  refine ((dvd_prime prime_two).mp h_m).resolve_right fun h_two ↦ ?_\n  exact (odd_fermatNumber _).not_two_dvd_nat (h_two ▸ h_n)\n\n"}
{"name":"Nat.pairwise_coprime_fermatNumber","module":"Mathlib.NumberTheory.Fermat","initialProofState":"⊢ Pairwise fun m n => m.fermatNumber.Coprime n.fermatNumber","decl":"lemma pairwise_coprime_fermatNumber :\n    Pairwise fun m n ↦ Coprime (fermatNumber m) (fermatNumber n) :=\n  fun _m _n ↦ coprime_fermatNumber_fermatNumber\n\n"}
{"name":"Nat.pow_of_pow_add_prime","module":"Mathlib.NumberTheory.Fermat","initialProofState":"a n : Nat\nha : LT.lt 1 a\nhn : Ne n 0\nhP : Nat.Prime (HAdd.hAdd (HPow.hPow a n) 1)\n⊢ Exists fun m => Eq n (HPow.hPow 2 m)","decl":"/-- Prime `a ^ n + 1` implies `n` is a power of two (**Fermat primes**). -/\ntheorem pow_of_pow_add_prime {a n : ℕ} (ha : 1 < a) (hn : n ≠ 0) (hP : (a ^ n + 1).Prime) :\n    ∃ m : ℕ, n = 2 ^ m := by\n  obtain ⟨k, m, hm, rfl⟩ := exists_eq_two_pow_mul_odd hn\n  rw [pow_mul] at hP\n  use k\n  replace ha : 1 < a ^ 2 ^ k := one_lt_pow (pow_ne_zero k two_ne_zero) ha\n  let h := hm.nat_add_dvd_pow_add_pow (a ^ 2 ^ k) 1\n  rw [one_pow, hP.dvd_iff_eq (Nat.lt_add_right 1 ha).ne', add_left_inj, pow_eq_self_iff ha] at h\n  rw [h, mul_one]\n\n"}
{"name":"Nat.pepin_primality","module":"Mathlib.NumberTheory.Fermat","initialProofState":"n : Nat\nh : Eq (HPow.hPow 3 (HPow.hPow 2 (HSub.hSub (HPow.hPow 2 n) 1))) (-1)\n⊢ Nat.Prime n.fermatNumber","decl":"/-- `Fₙ = 2^(2^n)+1` is prime if `3^(2^(2^n-1)) = -1 mod Fₙ` (**Pépin's test**). -/\nlemma pepin_primality (n : ℕ) (h : 3 ^ (2 ^ (2 ^ n - 1)) = (-1 : ZMod (fermatNumber n))) :\n    (fermatNumber n).Prime := by\n  have := Fact.mk (two_lt_fermatNumber n)\n  have key : 2 ^ n = 2 ^ n - 1 + 1 := (Nat.sub_add_cancel Nat.one_le_two_pow).symm\n  apply lucas_primality (p := 2 ^ (2 ^ n) + 1) (a := 3)\n  · rw [Nat.add_sub_cancel, key, pow_succ, pow_mul, ← pow_succ, ← key, h, neg_one_sq]\n  · intro p hp1 hp2\n    rw [Nat.add_sub_cancel, (Nat.prime_dvd_prime_iff_eq hp1 prime_two).mp (hp1.dvd_of_dvd_pow hp2),\n        key, pow_succ, Nat.mul_div_cancel _ two_pos, ← pow_succ, ← key, h]\n    exact neg_one_ne_one\n\n"}
{"name":"Nat.pepin_primality'","module":"Mathlib.NumberTheory.Fermat","initialProofState":"n : Nat\nh : Eq (HPow.hPow 3 (HDiv.hDiv (HSub.hSub n.fermatNumber 1) 2)) (-1)\n⊢ Nat.Prime n.fermatNumber","decl":"/-- `Fₙ = 2^(2^n)+1` is prime if `3^((Fₙ - 1)/2) = -1 mod Fₙ` (**Pépin's test**). -/\nlemma pepin_primality' (n : ℕ) (h : 3 ^ ((fermatNumber n - 1) / 2) = (-1 : ZMod (fermatNumber n))) :\n    (fermatNumber n).Prime := by\n  apply pepin_primality\n  rw [← h]\n  congr\n  rw [fermatNumber, add_tsub_cancel_right, Nat.pow_div Nat.one_le_two_pow Nat.zero_lt_two]\n\n\n"}
{"name":"Nat.pow_pow_add_primeFactors_one_lt","module":"Mathlib.NumberTheory.Fermat","initialProofState":"a n p : Nat\nhp : Nat.Prime p\nhp2 : Ne p 2\nhpdvd : Dvd.dvd p (HAdd.hAdd (HPow.hPow a (HPow.hPow 2 n)) 1)\n⊢ Exists fun k => Eq p (HAdd.hAdd (HMul.hMul k (HPow.hPow 2 (HAdd.hAdd n 1))) 1)","decl":"/-- Prime factors of `a ^ (2 ^ n) + 1` are of form `k * 2 ^ (n + 1) + 1`. -/\nlemma pow_pow_add_primeFactors_one_lt {a n p : ℕ} (hp : p.Prime) (hp2 : p ≠ 2)\n    (hpdvd : p ∣ a ^ (2 ^ n) + 1) :\n    ∃ k, p = k * 2 ^ (n + 1) + 1 := by\n  have : Fact (2 < p) := Fact.mk (lt_of_le_of_ne hp.two_le hp2.symm)\n  have : Fact p.Prime := Fact.mk hp\n  have ha1 : (a : ZMod p) ^ (2 ^ n) = -1 := by\n    rw [eq_neg_iff_add_eq_zero]\n    exact_mod_cast (natCast_zmod_eq_zero_iff_dvd (a ^ (2 ^ n) + 1) p).mpr hpdvd\n  have ha0 : (a : ZMod p) ≠ 0 := by\n    intro h\n    rw [h, zero_pow (pow_ne_zero n two_ne_zero), zero_eq_neg] at ha1\n    exact one_ne_zero ha1\n  have ha : orderOf (a : ZMod p) = 2 ^ (n + 1) := by\n    apply orderOf_eq_prime_pow\n    · rw [ha1]\n      exact neg_one_ne_one\n    · rw [pow_succ, pow_mul, ha1, neg_one_sq]\n  simpa [ha, dvd_def, Nat.sub_eq_iff_eq_add hp.one_le, mul_comm] using orderOf_dvd_card_sub_one ha0\n\n-- Prime factors of `Fₙ = 2 ^ (2 ^ n) + 1`, `1 < n`, are of form `k * 2 ^ (n + 2) + 1`. -/\n"}
{"name":"Nat.fermat_primeFactors_one_lt","module":"Mathlib.NumberTheory.Fermat","initialProofState":"n p : Nat\nhn : LT.lt 1 n\nhp : Nat.Prime p\nhpdvd : Dvd.dvd p n.fermatNumber\n⊢ Exists fun k => Eq p (HAdd.hAdd (HMul.hMul k (HPow.hPow 2 (HAdd.hAdd n 2))) 1)","decl":"lemma fermat_primeFactors_one_lt (n p : ℕ) (hn : 1 < n) (hp : p.Prime)\n    (hpdvd : p ∣ fermatNumber n) :\n    ∃ k, p = k * 2 ^ (n + 2) + 1 := by\n  have : Fact p.Prime := Fact.mk hp\n  have hp2 : p ≠ 2 := by\n    exact ((even_pow.mpr ⟨even_two, pow_ne_zero n two_ne_zero⟩).add_one).ne_two_of_dvd_nat hpdvd\n  have hp8 : p % 8 = 1 := by\n    obtain ⟨k, rfl⟩ := pow_pow_add_primeFactors_one_lt hp hp2 hpdvd\n    obtain ⟨n, rfl⟩ := Nat.exists_eq_add_of_le' hn\n    rw [add_assoc, pow_add, ← mul_assoc, ← mod_add_mod, mul_mod]\n    norm_num\n  obtain ⟨a, ha⟩ := (exists_sq_eq_two_iff hp2).mpr (Or.inl hp8)\n  suffices h : p ∣ a.val ^ (2 ^ (n + 1)) + 1 by\n    exact pow_pow_add_primeFactors_one_lt hp hp2 h\n  rw [fermatNumber] at hpdvd\n  rw [← natCast_zmod_eq_zero_iff_dvd, Nat.cast_add _ 1, Nat.cast_one, Nat.cast_pow] at hpdvd ⊢\n  rwa [natCast_val, ZMod.cast_id, pow_succ', pow_mul, sq, ← ha]\n\n\n-- TODO: move to NumberTheory.Mersenne, once we have that.\n"}
{"name":"Nat.prime_of_pow_sub_one_prime","module":"Mathlib.NumberTheory.Fermat","initialProofState":"a n : Nat\nhn1 : Ne n 1\nhP : Nat.Prime (HSub.hSub (HPow.hPow a n) 1)\n⊢ And (Eq a 2) (Nat.Prime n)","decl":"/-- Prime `a ^ n - 1` implies `a = 2` and prime `n`. -/\ntheorem prime_of_pow_sub_one_prime {a n : ℕ} (hn1 : n ≠ 1) (hP : (a ^ n - 1).Prime) :\n    a = 2 ∧ n.Prime := by\n  have han1 : 1 < a ^ n := tsub_pos_iff_lt.mp hP.pos\n  have hn0 : n ≠ 0 := fun h ↦ (h ▸ han1).ne' rfl\n  have ha1 : 1 < a := (Nat.one_lt_pow_iff hn0).mp han1\n  have ha0 : 0 < a := one_pos.trans ha1\n  have ha2 : a = 2 := by\n    contrapose! hn1\n    let h := nat_sub_dvd_pow_sub_pow a 1 n\n    rw [one_pow, hP.dvd_iff_eq (mt (Nat.sub_eq_iff_eq_add ha1.le).mp hn1), eq_comm] at h\n    exact (pow_eq_self_iff ha1).mp (Nat.sub_one_cancel ha0 (pow_pos ha0 n) h).symm\n  subst ha2\n  refine ⟨rfl, Nat.prime_def.mpr ⟨(two_le_iff n).mpr ⟨hn0, hn1⟩, fun d hdn ↦ ?_⟩⟩\n  have hinj : ∀ x y, 2 ^ x - 1 = 2 ^ y - 1 → x = y :=\n    fun x y h ↦ Nat.pow_right_injective le_rfl (sub_one_cancel (pow_pos ha0 x) (pow_pos ha0 y) h)\n  let h := nat_sub_dvd_pow_sub_pow (2 ^ d) 1 (n / d)\n  rw [one_pow, ← pow_mul, Nat.mul_div_cancel' hdn] at h\n  exact (hP.eq_one_or_self_of_dvd (2 ^ d - 1) h).imp (hinj d 1) (hinj d n)\n\n"}
