{"name":"List.getD_eq_getElem","module":"Mathlib.Data.List.GetD","initialProofState":"α : Type u\nl : List α\nd : α\nn : Nat\nhn : LT.lt n l.length\n⊢ Eq (l.getD n d) (GetElem.getElem l n ⋯)","decl":"theorem getD_eq_getElem {n : ℕ} (hn : n < l.length) : l.getD n d = l[n] := by\n  induction l generalizing n with\n  | nil => simp at hn\n  | cons head tail ih =>\n    cases n\n    · exact getD_cons_zero\n    · exact ih _\n\n"}
{"name":"List.getD_eq_get","module":"Mathlib.Data.List.GetD","initialProofState":"α : Type u\nl : List α\nd : α\nn : Nat\nhn : LT.lt n l.length\n⊢ Eq (l.getD n d) (l.get ⟨n, hn⟩)","decl":"@[deprecated getD_eq_getElem (since := \"2024-08-02\")]\ntheorem getD_eq_get {n : ℕ} (hn : n < l.length) : l.getD n d = l.get ⟨n, hn⟩ :=\n  getD_eq_getElem l d hn\n\n"}
{"name":"List.getD_map","module":"Mathlib.Data.List.GetD","initialProofState":"α : Type u\nβ : Type v\nl : List α\nd : α\nn : Nat\nf : α → β\n⊢ Eq ((List.map f l).getD n (f d)) (f (l.getD n d))","decl":"theorem getD_map {n : ℕ} (f : α → β) : (map f l).getD n (f d) = f (l.getD n d) := by simp\n\n"}
{"name":"List.getD_eq_default","module":"Mathlib.Data.List.GetD","initialProofState":"α : Type u\nl : List α\nd : α\nn : Nat\nhn : LE.le l.length n\n⊢ Eq (l.getD n d) d","decl":"theorem getD_eq_default {n : ℕ} (hn : l.length ≤ n) : l.getD n d = d := by\n  induction l generalizing n with\n  | nil => exact getD_nil\n  | cons head tail ih =>\n    cases n\n    · simp at hn\n    · exact ih (Nat.le_of_succ_le_succ hn)\n\n"}
{"name":"List.getD_reverse","module":"Mathlib.Data.List.GetD","initialProofState":"α : Type u\nl : List α\ni : Nat\nh : LT.lt i l.length\n⊢ Eq (l.reverse.getD i) (l.getD (HSub.hSub (HSub.hSub l.length 1) i))","decl":"theorem getD_reverse {l : List α} (i) (h : i < length l) :\n    getD l.reverse i = getD l (l.length - 1 - i) := by\n  funext a\n  rwa [List.getD_eq_getElem?_getD, List.getElem?_reverse, ← List.getD_eq_getElem?_getD]\n\n"}
{"name":"List.getElem?_getD_singleton_default_eq","module":"Mathlib.Data.List.GetD","initialProofState":"α : Type u\nd : α\nn : Nat\n⊢ Eq ((GetElem?.getElem? (List.cons d List.nil) n).getD d) d","decl":"@[simp]\ntheorem getElem?_getD_singleton_default_eq (n : ℕ) : [d][n]?.getD d = d := by cases n <;> simp\n\n"}
{"name":"List.getElem?_getD_replicate_default_eq","module":"Mathlib.Data.List.GetD","initialProofState":"α : Type u\nd : α\nr n : Nat\n⊢ Eq ((GetElem?.getElem? (List.replicate r d) n).getD d) d","decl":"@[simp]\ntheorem getElem?_getD_replicate_default_eq (r n : ℕ) : (replicate r d)[n]?.getD d = d := by\n  induction r generalizing n with\n  | zero => simp\n  | succ n ih => simp at ih; cases n <;> simp [ih, replicate_succ]\n\n"}
{"name":"List.getD_replicate","module":"Mathlib.Data.List.GetD","initialProofState":"α : Type u\nx y : α\ni n : Nat\nh : LT.lt i n\n⊢ Eq ((List.replicate n x).getD i y) x","decl":"theorem getD_replicate {y i n} (h : i < n) :\n    getD (replicate n x) i y = x := by\n  rw [getD_eq_getElem,  getElem_replicate]\n  rwa [length_replicate]\n\n"}
{"name":"List.getD_append","module":"Mathlib.Data.List.GetD","initialProofState":"α : Type u\nl l' : List α\nd : α\nn : Nat\nh : LT.lt n l.length\n⊢ Eq ((HAppend.hAppend l l').getD n d) (l.getD n d)","decl":"theorem getD_append (l l' : List α) (d : α) (n : ℕ) (h : n < l.length) :\n    (l ++ l').getD n d = l.getD n d := by\n  rw [getD_eq_getElem _ _ (Nat.lt_of_lt_of_le h (length_append _ _ ▸ Nat.le_add_right _ _)),\n    getElem_append_left h, getD_eq_getElem]\n\n"}
{"name":"List.getD_append_right","module":"Mathlib.Data.List.GetD","initialProofState":"α : Type u\nl l' : List α\nd : α\nn : Nat\nh : LE.le l.length n\n⊢ Eq ((HAppend.hAppend l l').getD n d) (l'.getD (HSub.hSub n l.length) d)","decl":"theorem getD_append_right (l l' : List α) (d : α) (n : ℕ) (h : l.length ≤ n) :\n    (l ++ l').getD n d = l'.getD (n - l.length) d := by\n  cases Nat.lt_or_ge n (l ++ l').length with\n  | inl h' =>\n    rw [getD_eq_getElem (l ++ l') d h', getElem_append_right h, getD_eq_getElem]\n  | inr h' =>\n    rw [getD_eq_default _ _ h', getD_eq_default]\n    rwa [Nat.le_sub_iff_add_le' h, ← length_append]\n\n"}
{"name":"List.getD_eq_getD_get?","module":"Mathlib.Data.List.GetD","initialProofState":"α : Type u\nl : List α\nd : α\nn : Nat\n⊢ Eq (l.getD n d) ((l.get? n).getD d)","decl":"theorem getD_eq_getD_get? (n : ℕ) : l.getD n d = (l.get? n).getD d := by\n  cases Nat.lt_or_ge n l.length with\n  | inl h => rw [getD_eq_getElem _ _ h, get?_eq_get h, get_eq_getElem, Option.getD_some]\n  | inr h => rw [getD_eq_default _ _ h, get?_eq_none_iff.mpr h, Option.getD_none]\n\n"}
{"name":"List.getI_nil","module":"Mathlib.Data.List.GetD","initialProofState":"α : Type u\nn : Nat\ninst✝ : Inhabited α\n⊢ Eq (List.nil.getI n) Inhabited.default","decl":"@[simp]\ntheorem getI_nil : getI ([] : List α) n = default :=\n  rfl\n\n"}
{"name":"List.getI_cons_zero","module":"Mathlib.Data.List.GetD","initialProofState":"α : Type u\nx : α\nxs : List α\ninst✝ : Inhabited α\n⊢ Eq ((List.cons x xs).getI 0) x","decl":"@[simp]\ntheorem getI_cons_zero : getI (x :: xs) 0 = x :=\n  rfl\n\n"}
{"name":"List.getI_cons_succ","module":"Mathlib.Data.List.GetD","initialProofState":"α : Type u\nx : α\nxs : List α\nn : Nat\ninst✝ : Inhabited α\n⊢ Eq ((List.cons x xs).getI (HAdd.hAdd n 1)) (xs.getI n)","decl":"@[simp]\ntheorem getI_cons_succ : getI (x :: xs) (n + 1) = getI xs n :=\n  rfl\n\n"}
{"name":"List.getI_eq_getElem","module":"Mathlib.Data.List.GetD","initialProofState":"α : Type u\nl : List α\ninst✝ : Inhabited α\nn : Nat\nhn : LT.lt n l.length\n⊢ Eq (l.getI n) (GetElem.getElem l n ⋯)","decl":"theorem getI_eq_getElem {n : ℕ} (hn : n < l.length) : l.getI n = l[n] :=\n  getD_eq_getElem l default hn\n\n"}
{"name":"List.getI_eq_get","module":"Mathlib.Data.List.GetD","initialProofState":"α : Type u\nl : List α\ninst✝ : Inhabited α\nn : Nat\nhn : LT.lt n l.length\n⊢ Eq (l.getI n) (l.get ⟨n, hn⟩)","decl":"@[deprecated getI_eq_getElem (since := \"2024-08-02\")]\ntheorem getI_eq_get {n : ℕ} (hn : n < l.length) : l.getI n = l.get ⟨n, hn⟩ :=\n  getD_eq_getElem l default hn\n\n"}
{"name":"List.getI_eq_default","module":"Mathlib.Data.List.GetD","initialProofState":"α : Type u\nl : List α\ninst✝ : Inhabited α\nn : Nat\nhn : LE.le l.length n\n⊢ Eq (l.getI n) Inhabited.default","decl":"theorem getI_eq_default {n : ℕ} (hn : l.length ≤ n) : l.getI n = default :=\n  getD_eq_default _ _ hn\n\n"}
{"name":"List.getD_default_eq_getI","module":"Mathlib.Data.List.GetD","initialProofState":"α : Type u\nl : List α\ninst✝ : Inhabited α\nn : Nat\n⊢ Eq (l.getD n Inhabited.default) (l.getI n)","decl":"theorem getD_default_eq_getI {n : ℕ} : l.getD n default = l.getI n :=\n  rfl\n\n"}
{"name":"List.getI_append","module":"Mathlib.Data.List.GetD","initialProofState":"α : Type u\ninst✝ : Inhabited α\nl l' : List α\nn : Nat\nh : LT.lt n l.length\n⊢ Eq ((HAppend.hAppend l l').getI n) (l.getI n)","decl":"theorem getI_append (l l' : List α) (n : ℕ) (h : n < l.length) :\n    (l ++ l').getI n = l.getI n := getD_append _ _ _ _ h\n\n"}
{"name":"List.getI_append_right","module":"Mathlib.Data.List.GetD","initialProofState":"α : Type u\ninst✝ : Inhabited α\nl l' : List α\nn : Nat\nh : LE.le l.length n\n⊢ Eq ((HAppend.hAppend l l').getI n) (l'.getI (HSub.hSub n l.length))","decl":"theorem getI_append_right (l l' : List α) (n : ℕ) (h : l.length ≤ n) :\n    (l ++ l').getI n = l'.getI (n - l.length) :=\n  getD_append_right _ _ _ _ h\n\n"}
{"name":"List.getI_eq_iget_get?","module":"Mathlib.Data.List.GetD","initialProofState":"α : Type u\nl : List α\ninst✝ : Inhabited α\nn : Nat\n⊢ Eq (l.getI n) (l.get? n).iget","decl":"theorem getI_eq_iget_get? (n : ℕ) : l.getI n = (l.get? n).iget := by\n  rw [← getD_default_eq_getI, getD_eq_getD_get?, Option.getD_default_eq_iget]\n\n"}
{"name":"List.getI_eq_iget_getElem?","module":"Mathlib.Data.List.GetD","initialProofState":"α : Type u\nl : List α\ninst✝ : Inhabited α\nn : Nat\n⊢ Eq (l.getI n) (GetElem?.getElem? l n).iget","decl":"theorem getI_eq_iget_getElem? (n : ℕ) : l.getI n = l[n]?.iget := by\n  rw [← getD_default_eq_getI, getD_eq_getElem?_getD, Option.getD_default_eq_iget]\n\n"}
{"name":"List.getI_zero_eq_headI","module":"Mathlib.Data.List.GetD","initialProofState":"α : Type u\nl : List α\ninst✝ : Inhabited α\n⊢ Eq (l.getI 0) l.headI","decl":"theorem getI_zero_eq_headI : l.getI 0 = l.headI := by cases l <;> rfl\n\n"}
