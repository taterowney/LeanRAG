{"name":"MonomialOrder.mk.sizeOf_spec","module":"Mathlib.Data.Finsupp.MonomialOrder","initialProofState":"σ : Type u_1\ninst✝ : SizeOf σ\nsyn : Type u_2\nlocacm : autoParam (LinearOrderedCancelAddCommMonoid syn) _auto✝\ntoSyn : AddEquiv (Finsupp σ Nat) syn\ntoSyn_monotone : Monotone ⇑toSyn\nwf : autoParam (WellFoundedLT syn) _auto✝\n⊢ Eq (SizeOf.sizeOf { syn := syn, locacm := locacm, toSyn := toSyn, toSyn_monotone := toSyn_monotone, wf := wf }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf syn)) (SizeOf.sizeOf locacm)) (SizeOf.sizeOf toSyn)) (SizeOf.sizeOf wf))","decl":"/-- Monomial orders : equivalence of `σ →₀ ℕ` with a well ordered type -/\nstructure MonomialOrder (σ : Type*) where\n  /-- The synonym type -/\n  syn : Type*\n  /-- `syn` is a linearly ordered cancellative additive commutative monoid -/\n  locacm : LinearOrderedCancelAddCommMonoid syn := by infer_instance\n  /-- the additive equivalence from `σ →₀ ℕ` to `syn` -/\n  toSyn : (σ →₀ ℕ) ≃+ syn\n  /-- `toSyn` is monotone -/\n  toSyn_monotone : Monotone toSyn\n  /-- `syn` is a well ordering -/\n  wf : WellFoundedLT syn := by infer_instance\n\n"}
{"name":"MonomialOrder.toSyn_monotone","module":"Mathlib.Data.Finsupp.MonomialOrder","initialProofState":"σ : Type u_1\nself : MonomialOrder σ\n⊢ Monotone ⇑self.toSyn","decl":"/-- Monomial orders : equivalence of `σ →₀ ℕ` with a well ordered type -/\nstructure MonomialOrder (σ : Type*) where\n  /-- The synonym type -/\n  syn : Type*\n  /-- `syn` is a linearly ordered cancellative additive commutative monoid -/\n  locacm : LinearOrderedCancelAddCommMonoid syn := by infer_instance\n  /-- the additive equivalence from `σ →₀ ℕ` to `syn` -/\n  toSyn : (σ →₀ ℕ) ≃+ syn\n  /-- `toSyn` is monotone -/\n  toSyn_monotone : Monotone toSyn\n  /-- `syn` is a well ordering -/\n  wf : WellFoundedLT syn := by infer_instance\n\n"}
{"name":"MonomialOrder.wf","module":"Mathlib.Data.Finsupp.MonomialOrder","initialProofState":"σ : Type u_1\nself : MonomialOrder σ\n⊢ WellFoundedLT self.syn","decl":"/-- Monomial orders : equivalence of `σ →₀ ℕ` with a well ordered type -/\nstructure MonomialOrder (σ : Type*) where\n  /-- The synonym type -/\n  syn : Type*\n  /-- `syn` is a linearly ordered cancellative additive commutative monoid -/\n  locacm : LinearOrderedCancelAddCommMonoid syn := by infer_instance\n  /-- the additive equivalence from `σ →₀ ℕ` to `syn` -/\n  toSyn : (σ →₀ ℕ) ≃+ syn\n  /-- `toSyn` is monotone -/\n  toSyn_monotone : Monotone toSyn\n  /-- `syn` is a well ordering -/\n  wf : WellFoundedLT syn := by infer_instance\n\n"}
{"name":"MonomialOrder.mk.injEq","module":"Mathlib.Data.Finsupp.MonomialOrder","initialProofState":"σ : Type u_1\nsyn✝ : Type u_2\nlocacm✝ : autoParam (LinearOrderedCancelAddCommMonoid syn✝) _auto✝\ntoSyn✝ : AddEquiv (Finsupp σ Nat) syn✝\ntoSyn_monotone✝ : Monotone ⇑toSyn✝\nwf✝ : autoParam (WellFoundedLT syn✝) _auto✝\nsyn : Type u_2\nlocacm : autoParam (LinearOrderedCancelAddCommMonoid syn) _auto✝\ntoSyn : AddEquiv (Finsupp σ Nat) syn\ntoSyn_monotone : Monotone ⇑toSyn\nwf : autoParam (WellFoundedLT syn) _auto✝\n⊢ Eq (Eq { syn := syn✝, locacm := locacm✝, toSyn := toSyn✝, toSyn_monotone := toSyn_monotone✝, wf := wf✝ } { syn := syn, locacm := locacm, toSyn := toSyn, toSyn_monotone := toSyn_monotone, wf := wf }) (And (Eq syn✝ syn) (And (HEq locacm✝ locacm) (HEq toSyn✝ toSyn)))","decl":"/-- Monomial orders : equivalence of `σ →₀ ℕ` with a well ordered type -/\nstructure MonomialOrder (σ : Type*) where\n  /-- The synonym type -/\n  syn : Type*\n  /-- `syn` is a linearly ordered cancellative additive commutative monoid -/\n  locacm : LinearOrderedCancelAddCommMonoid syn := by infer_instance\n  /-- the additive equivalence from `σ →₀ ℕ` to `syn` -/\n  toSyn : (σ →₀ ℕ) ≃+ syn\n  /-- `toSyn` is monotone -/\n  toSyn_monotone : Monotone toSyn\n  /-- `syn` is a well ordering -/\n  wf : WellFoundedLT syn := by infer_instance\n\n"}
{"name":"MonomialOrder.mk.inj","module":"Mathlib.Data.Finsupp.MonomialOrder","initialProofState":"σ : Type u_1\nsyn✝ : Type u_2\nlocacm✝ : autoParam (LinearOrderedCancelAddCommMonoid syn✝) _auto✝\ntoSyn✝ : AddEquiv (Finsupp σ Nat) syn✝\ntoSyn_monotone✝ : Monotone ⇑toSyn✝\nwf✝ : autoParam (WellFoundedLT syn✝) _auto✝\nsyn : Type u_2\nlocacm : autoParam (LinearOrderedCancelAddCommMonoid syn) _auto✝\ntoSyn : AddEquiv (Finsupp σ Nat) syn\ntoSyn_monotone : Monotone ⇑toSyn\nwf : autoParam (WellFoundedLT syn) _auto✝\nx✝ : Eq { syn := syn✝, locacm := locacm✝, toSyn := toSyn✝, toSyn_monotone := toSyn_monotone✝, wf := wf✝ } { syn := syn, locacm := locacm, toSyn := toSyn, toSyn_monotone := toSyn_monotone, wf := wf }\n⊢ And (Eq syn✝ syn) (And (HEq locacm✝ locacm) (HEq toSyn✝ toSyn))","decl":"/-- Monomial orders : equivalence of `σ →₀ ℕ` with a well ordered type -/\nstructure MonomialOrder (σ : Type*) where\n  /-- The synonym type -/\n  syn : Type*\n  /-- `syn` is a linearly ordered cancellative additive commutative monoid -/\n  locacm : LinearOrderedCancelAddCommMonoid syn := by infer_instance\n  /-- the additive equivalence from `σ →₀ ℕ` to `syn` -/\n  toSyn : (σ →₀ ℕ) ≃+ syn\n  /-- `toSyn` is monotone -/\n  toSyn_monotone : Monotone toSyn\n  /-- `syn` is a well ordering -/\n  wf : WellFoundedLT syn := by infer_instance\n\n"}
{"name":"MonomialOrder.le_add_right","module":"Mathlib.Data.Finsupp.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\na b : Finsupp σ Nat\n⊢ LE.le (m.toSyn a) (HAdd.hAdd (m.toSyn a) (m.toSyn b))","decl":"lemma le_add_right (a b : σ →₀ ℕ) :\n    m.toSyn a ≤ m.toSyn a + m.toSyn b := by\n  rw [← map_add]\n  exact m.toSyn_monotone le_self_add\n\n"}
{"name":"MonomialOrder.bot_eq_zero","module":"Mathlib.Data.Finsupp.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\n⊢ Eq Bot.bot 0","decl":"@[simp]\ntheorem bot_eq_zero : (⊥ : m.syn) = 0 := rfl\n\n"}
{"name":"MonomialOrder.eq_zero_iff","module":"Mathlib.Data.Finsupp.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\na : m.syn\n⊢ Iff (Eq a 0) (LE.le a 0)","decl":"theorem eq_zero_iff {a : m.syn} : a = 0 ↔ a ≤ 0 := eq_bot_iff\n\n"}
{"name":"MonomialOrder.toSyn_strictMono","module":"Mathlib.Data.Finsupp.MonomialOrder","initialProofState":"σ : Type u_1\nm : MonomialOrder σ\n⊢ StrictMono ⇑m.toSyn","decl":"lemma toSyn_strictMono : StrictMono (m.toSyn) := by\n  apply m.toSyn_monotone.strictMono_of_injective m.toSyn.injective\n\n"}
{"name":"MonomialOrder.lex_le_iff","module":"Mathlib.Data.Finsupp.MonomialOrder","initialProofState":"σ : Type u_1\ninst✝¹ : LinearOrder σ\ninst✝ : WellFoundedGT σ\nc d : Finsupp σ Nat\n⊢ Iff (LE.le (MonomialOrder.lex.toSyn c) (MonomialOrder.lex.toSyn d)) (LE.le (toLex c) (toLex d))","decl":"theorem MonomialOrder.lex_le_iff [WellFoundedGT σ] {c d : σ →₀ ℕ} :\n    c ≼[lex] d ↔ toLex c ≤ toLex d := Iff.rfl\n\n"}
{"name":"MonomialOrder.lex_lt_iff","module":"Mathlib.Data.Finsupp.MonomialOrder","initialProofState":"σ : Type u_1\ninst✝¹ : LinearOrder σ\ninst✝ : WellFoundedGT σ\nc d : Finsupp σ Nat\n⊢ Iff (LT.lt (MonomialOrder.lex.toSyn c) (MonomialOrder.lex.toSyn d)) (LT.lt (toLex c) (toLex d))","decl":"theorem MonomialOrder.lex_lt_iff [WellFoundedGT σ] {c d : σ →₀ ℕ} :\n    c ≺[lex] d ↔ toLex c < toLex d := Iff.rfl\n\n"}
{"name":"MonomialOrder.lex_lt_iff_of_unique","module":"Mathlib.Data.Finsupp.MonomialOrder","initialProofState":"σ : Type u_1\ninst✝¹ : LinearOrder σ\ninst✝ : Unique σ\nc d : Finsupp σ Nat\n⊢ Iff (LT.lt (MonomialOrder.lex.toSyn c) (MonomialOrder.lex.toSyn d)) (LT.lt (c Inhabited.default) (d Inhabited.default))","decl":"theorem MonomialOrder.lex_lt_iff_of_unique [Unique σ] {c d : σ →₀ ℕ} :\n    c ≺[lex] d ↔ c default < d default := by\n  simp only [MonomialOrder.lex_lt_iff, Finsupp.lex_lt_iff_of_unique, ofLex_toLex]\n\n"}
{"name":"MonomialOrder.lex_le_iff_of_unique","module":"Mathlib.Data.Finsupp.MonomialOrder","initialProofState":"σ : Type u_1\ninst✝¹ : LinearOrder σ\ninst✝ : Unique σ\nc d : Finsupp σ Nat\n⊢ Iff (LE.le (MonomialOrder.lex.toSyn c) (MonomialOrder.lex.toSyn d)) (LE.le (c Inhabited.default) (d Inhabited.default))","decl":"theorem MonomialOrder.lex_le_iff_of_unique [Unique σ] {c d : σ →₀ ℕ} :\n    c ≼[lex] d ↔ c default ≤ d default := by\n  simp only [MonomialOrder.lex_le_iff, Finsupp.lex_le_iff_of_unique, ofLex_toLex]\n\n"}
