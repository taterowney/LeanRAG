{"name":"Matrix.dotProduct_block","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_12\ninst✝³ : Fintype m\ninst✝² : Fintype n\ninst✝¹ : Mul α\ninst✝ : AddCommMonoid α\nv w : Sum m n → α\n⊢ Eq (dotProduct v w) (HAdd.hAdd (dotProduct (Function.comp v Sum.inl) (Function.comp w Sum.inl)) (dotProduct (Function.comp v Sum.inr) (Function.comp w Sum.inr)))","decl":"theorem dotProduct_block [Fintype m] [Fintype n] [Mul α] [AddCommMonoid α] (v w : m ⊕ n → α) :\n    v ⬝ᵥ w = v ∘ Sum.inl ⬝ᵥ w ∘ Sum.inl + v ∘ Sum.inr ⬝ᵥ w ∘ Sum.inr :=\n  Fintype.sum_sum_type _\n\n"}
{"name":"Matrix.fromBlocks_apply₁₁","module":"Mathlib.Data.Matrix.Block","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\nA : Matrix n l α\nB : Matrix n m α\nC : Matrix o l α\nD : Matrix o m α\ni : n\nj : l\n⊢ Eq (Matrix.fromBlocks A B C D (Sum.inl i) (Sum.inl j)) (A i j)","decl":"@[simp]\ntheorem fromBlocks_apply₁₁ (A : Matrix n l α) (B : Matrix n m α) (C : Matrix o l α)\n    (D : Matrix o m α) (i : n) (j : l) : fromBlocks A B C D (Sum.inl i) (Sum.inl j) = A i j :=\n  rfl\n\n"}
{"name":"Matrix.fromBlocks_apply₁₂","module":"Mathlib.Data.Matrix.Block","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\nA : Matrix n l α\nB : Matrix n m α\nC : Matrix o l α\nD : Matrix o m α\ni : n\nj : m\n⊢ Eq (Matrix.fromBlocks A B C D (Sum.inl i) (Sum.inr j)) (B i j)","decl":"@[simp]\ntheorem fromBlocks_apply₁₂ (A : Matrix n l α) (B : Matrix n m α) (C : Matrix o l α)\n    (D : Matrix o m α) (i : n) (j : m) : fromBlocks A B C D (Sum.inl i) (Sum.inr j) = B i j :=\n  rfl\n\n"}
{"name":"Matrix.fromBlocks_apply₂₁","module":"Mathlib.Data.Matrix.Block","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\nA : Matrix n l α\nB : Matrix n m α\nC : Matrix o l α\nD : Matrix o m α\ni : o\nj : l\n⊢ Eq (Matrix.fromBlocks A B C D (Sum.inr i) (Sum.inl j)) (C i j)","decl":"@[simp]\ntheorem fromBlocks_apply₂₁ (A : Matrix n l α) (B : Matrix n m α) (C : Matrix o l α)\n    (D : Matrix o m α) (i : o) (j : l) : fromBlocks A B C D (Sum.inr i) (Sum.inl j) = C i j :=\n  rfl\n\n"}
{"name":"Matrix.fromBlocks_apply₂₂","module":"Mathlib.Data.Matrix.Block","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\nA : Matrix n l α\nB : Matrix n m α\nC : Matrix o l α\nD : Matrix o m α\ni : o\nj : m\n⊢ Eq (Matrix.fromBlocks A B C D (Sum.inr i) (Sum.inr j)) (D i j)","decl":"@[simp]\ntheorem fromBlocks_apply₂₂ (A : Matrix n l α) (B : Matrix n m α) (C : Matrix o l α)\n    (D : Matrix o m α) (i : o) (j : m) : fromBlocks A B C D (Sum.inr i) (Sum.inr j) = D i j :=\n  rfl\n\n"}
{"name":"Matrix.fromBlocks_toBlocks","module":"Mathlib.Data.Matrix.Block","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\nM : Matrix (Sum n o) (Sum l m) α\n⊢ Eq (Matrix.fromBlocks M.toBlocks₁₁ M.toBlocks₁₂ M.toBlocks₂₁ M.toBlocks₂₂) M","decl":"theorem fromBlocks_toBlocks (M : Matrix (n ⊕ o) (l ⊕ m) α) :\n    fromBlocks M.toBlocks₁₁ M.toBlocks₁₂ M.toBlocks₂₁ M.toBlocks₂₂ = M := by\n  ext i j\n  rcases i with ⟨⟩ <;> rcases j with ⟨⟩ <;> rfl\n\n"}
{"name":"Matrix.toBlocks_fromBlocks₁₁","module":"Mathlib.Data.Matrix.Block","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\nA : Matrix n l α\nB : Matrix n m α\nC : Matrix o l α\nD : Matrix o m α\n⊢ Eq (Matrix.fromBlocks A B C D).toBlocks₁₁ A","decl":"@[simp]\ntheorem toBlocks_fromBlocks₁₁ (A : Matrix n l α) (B : Matrix n m α) (C : Matrix o l α)\n    (D : Matrix o m α) : (fromBlocks A B C D).toBlocks₁₁ = A :=\n  rfl\n\n"}
{"name":"Matrix.toBlocks_fromBlocks₁₂","module":"Mathlib.Data.Matrix.Block","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\nA : Matrix n l α\nB : Matrix n m α\nC : Matrix o l α\nD : Matrix o m α\n⊢ Eq (Matrix.fromBlocks A B C D).toBlocks₁₂ B","decl":"@[simp]\ntheorem toBlocks_fromBlocks₁₂ (A : Matrix n l α) (B : Matrix n m α) (C : Matrix o l α)\n    (D : Matrix o m α) : (fromBlocks A B C D).toBlocks₁₂ = B :=\n  rfl\n\n"}
{"name":"Matrix.toBlocks_fromBlocks₂₁","module":"Mathlib.Data.Matrix.Block","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\nA : Matrix n l α\nB : Matrix n m α\nC : Matrix o l α\nD : Matrix o m α\n⊢ Eq (Matrix.fromBlocks A B C D).toBlocks₂₁ C","decl":"@[simp]\ntheorem toBlocks_fromBlocks₂₁ (A : Matrix n l α) (B : Matrix n m α) (C : Matrix o l α)\n    (D : Matrix o m α) : (fromBlocks A B C D).toBlocks₂₁ = C :=\n  rfl\n\n"}
{"name":"Matrix.toBlocks_fromBlocks₂₂","module":"Mathlib.Data.Matrix.Block","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\nA : Matrix n l α\nB : Matrix n m α\nC : Matrix o l α\nD : Matrix o m α\n⊢ Eq (Matrix.fromBlocks A B C D).toBlocks₂₂ D","decl":"@[simp]\ntheorem toBlocks_fromBlocks₂₂ (A : Matrix n l α) (B : Matrix n m α) (C : Matrix o l α)\n    (D : Matrix o m α) : (fromBlocks A B C D).toBlocks₂₂ = D :=\n  rfl\n\n"}
{"name":"Matrix.ext_iff_blocks","module":"Mathlib.Data.Matrix.Block","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\nA B : Matrix (Sum n o) (Sum l m) α\n⊢ Iff (Eq A B) (And (Eq A.toBlocks₁₁ B.toBlocks₁₁) (And (Eq A.toBlocks₁₂ B.toBlocks₁₂) (And (Eq A.toBlocks₂₁ B.toBlocks₂₁) (Eq A.toBlocks₂₂ B.toBlocks₂₂))))","decl":"/-- Two block matrices are equal if their blocks are equal. -/\ntheorem ext_iff_blocks {A B : Matrix (n ⊕ o) (l ⊕ m) α} :\n    A = B ↔\n      A.toBlocks₁₁ = B.toBlocks₁₁ ∧\n        A.toBlocks₁₂ = B.toBlocks₁₂ ∧ A.toBlocks₂₁ = B.toBlocks₂₁ ∧ A.toBlocks₂₂ = B.toBlocks₂₂ :=\n  ⟨fun h => h ▸ ⟨rfl, rfl, rfl, rfl⟩, fun ⟨h₁₁, h₁₂, h₂₁, h₂₂⟩ => by\n    rw [← fromBlocks_toBlocks A, ← fromBlocks_toBlocks B, h₁₁, h₁₂, h₂₁, h₂₂]⟩\n\n"}
{"name":"Matrix.fromBlocks_inj","module":"Mathlib.Data.Matrix.Block","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\nA : Matrix n l α\nB : Matrix n m α\nC : Matrix o l α\nD : Matrix o m α\nA' : Matrix n l α\nB' : Matrix n m α\nC' : Matrix o l α\nD' : Matrix o m α\n⊢ Iff (Eq (Matrix.fromBlocks A B C D) (Matrix.fromBlocks A' B' C' D')) (And (Eq A A') (And (Eq B B') (And (Eq C C') (Eq D D'))))","decl":"@[simp]\ntheorem fromBlocks_inj {A : Matrix n l α} {B : Matrix n m α} {C : Matrix o l α} {D : Matrix o m α}\n    {A' : Matrix n l α} {B' : Matrix n m α} {C' : Matrix o l α} {D' : Matrix o m α} :\n    fromBlocks A B C D = fromBlocks A' B' C' D' ↔ A = A' ∧ B = B' ∧ C = C' ∧ D = D' :=\n  ext_iff_blocks\n\n"}
{"name":"Matrix.fromBlocks_map","module":"Mathlib.Data.Matrix.Block","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\nβ : Type u_13\nA : Matrix n l α\nB : Matrix n m α\nC : Matrix o l α\nD : Matrix o m α\nf : α → β\n⊢ Eq ((Matrix.fromBlocks A B C D).map f) (Matrix.fromBlocks (A.map f) (B.map f) (C.map f) (D.map f))","decl":"theorem fromBlocks_map (A : Matrix n l α) (B : Matrix n m α) (C : Matrix o l α) (D : Matrix o m α)\n    (f : α → β) : (fromBlocks A B C D).map f =\n      fromBlocks (A.map f) (B.map f) (C.map f) (D.map f) := by\n  ext i j; rcases i with ⟨⟩ <;> rcases j with ⟨⟩ <;> simp [fromBlocks]\n\n"}
{"name":"Matrix.fromBlocks_transpose","module":"Mathlib.Data.Matrix.Block","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\nA : Matrix n l α\nB : Matrix n m α\nC : Matrix o l α\nD : Matrix o m α\n⊢ Eq (Matrix.fromBlocks A B C D).transpose (Matrix.fromBlocks A.transpose C.transpose B.transpose D.transpose)","decl":"theorem fromBlocks_transpose (A : Matrix n l α) (B : Matrix n m α) (C : Matrix o l α)\n    (D : Matrix o m α) : (fromBlocks A B C D)ᵀ = fromBlocks Aᵀ Cᵀ Bᵀ Dᵀ := by\n  ext i j\n  rcases i with ⟨⟩ <;> rcases j with ⟨⟩ <;> simp [fromBlocks]\n\n"}
{"name":"Matrix.fromBlocks_conjTranspose","module":"Mathlib.Data.Matrix.Block","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\ninst✝ : Star α\nA : Matrix n l α\nB : Matrix n m α\nC : Matrix o l α\nD : Matrix o m α\n⊢ Eq (Matrix.fromBlocks A B C D).conjTranspose (Matrix.fromBlocks A.conjTranspose C.conjTranspose B.conjTranspose D.conjTranspose)","decl":"theorem fromBlocks_conjTranspose [Star α] (A : Matrix n l α) (B : Matrix n m α) (C : Matrix o l α)\n    (D : Matrix o m α) : (fromBlocks A B C D)ᴴ = fromBlocks Aᴴ Cᴴ Bᴴ Dᴴ := by\n  simp only [conjTranspose, fromBlocks_transpose, fromBlocks_map]\n\n"}
{"name":"Matrix.fromBlocks_submatrix_sum_swap_left","module":"Mathlib.Data.Matrix.Block","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\np : Type u_5\nα : Type u_12\nA : Matrix n l α\nB : Matrix n m α\nC : Matrix o l α\nD : Matrix o m α\nf : p → Sum l m\n⊢ Eq ((Matrix.fromBlocks A B C D).submatrix Sum.swap f) ((Matrix.fromBlocks C D A B).submatrix id f)","decl":"@[simp]\ntheorem fromBlocks_submatrix_sum_swap_left (A : Matrix n l α) (B : Matrix n m α) (C : Matrix o l α)\n    (D : Matrix o m α) (f : p → l ⊕ m) :\n    (fromBlocks A B C D).submatrix Sum.swap f = (fromBlocks C D A B).submatrix id f := by\n  ext i j\n  cases i <;> dsimp <;> cases f j <;> rfl\n\n"}
{"name":"Matrix.fromBlocks_submatrix_sum_swap_right","module":"Mathlib.Data.Matrix.Block","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\np : Type u_5\nα : Type u_12\nA : Matrix n l α\nB : Matrix n m α\nC : Matrix o l α\nD : Matrix o m α\nf : p → Sum n o\n⊢ Eq ((Matrix.fromBlocks A B C D).submatrix f Sum.swap) ((Matrix.fromBlocks B A D C).submatrix f id)","decl":"@[simp]\ntheorem fromBlocks_submatrix_sum_swap_right (A : Matrix n l α) (B : Matrix n m α) (C : Matrix o l α)\n    (D : Matrix o m α) (f : p → n ⊕ o) :\n    (fromBlocks A B C D).submatrix f Sum.swap = (fromBlocks B A D C).submatrix f id := by\n  ext i j\n  cases j <;> dsimp <;> cases f i <;> rfl\n\n"}
{"name":"Matrix.fromBlocks_submatrix_sum_swap_sum_swap","module":"Mathlib.Data.Matrix.Block","initialProofState":"l : Type u_14\nm : Type u_15\nn : Type u_16\no : Type u_17\nα : Type u_18\nA : Matrix n l α\nB : Matrix n m α\nC : Matrix o l α\nD : Matrix o m α\n⊢ Eq ((Matrix.fromBlocks A B C D).submatrix Sum.swap Sum.swap) (Matrix.fromBlocks D C B A)","decl":"theorem fromBlocks_submatrix_sum_swap_sum_swap {l m n o α : Type*} (A : Matrix n l α)\n    (B : Matrix n m α) (C : Matrix o l α) (D : Matrix o m α) :\n    (fromBlocks A B C D).submatrix Sum.swap Sum.swap = fromBlocks D C B A := by simp\n\n"}
{"name":"Matrix.toBlock_apply","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type u_12\nM : Matrix m n α\np : m → Prop\nq : n → Prop\ni : Subtype fun a => p a\nj : Subtype fun a => q a\n⊢ Eq (M.toBlock p q i j) (M ↑i ↑j)","decl":"@[simp]\ntheorem toBlock_apply (M : Matrix m n α) (p : m → Prop) (q : n → Prop) (i : { a // p a })\n    (j : { a // q a }) : toBlock M p q i j = M ↑i ↑j :=\n  rfl\n\n"}
{"name":"Matrix.toSquareBlockProp_def","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nα : Type u_12\nM : Matrix m m α\np : m → Prop\n⊢ Eq (M.toSquareBlockProp p) (Matrix.of fun i j => M ↑i ↑j)","decl":"theorem toSquareBlockProp_def (M : Matrix m m α) (p : m → Prop) :\n    -- Porting note: added missing `of`\n    toSquareBlockProp M p = of (fun i j : { a // p a } => M ↑i ↑j) :=\n  rfl\n\n"}
{"name":"Matrix.toSquareBlock_def","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nα : Type u_12\nβ : Type u_13\nM : Matrix m m α\nb : m → β\nk : β\n⊢ Eq (M.toSquareBlock b k) (Matrix.of fun i j => M ↑i ↑j)","decl":"theorem toSquareBlock_def (M : Matrix m m α) (b : m → β) (k : β) :\n    -- Porting note: added missing `of`\n    toSquareBlock M b k = of (fun i j : { a // b a = k } => M ↑i ↑j) :=\n  rfl\n\n"}
{"name":"Matrix.fromBlocks_smul","module":"Mathlib.Data.Matrix.Block","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nR : Type u_10\nα : Type u_12\ninst✝ : SMul R α\nx : R\nA : Matrix n l α\nB : Matrix n m α\nC : Matrix o l α\nD : Matrix o m α\n⊢ Eq (HSMul.hSMul x (Matrix.fromBlocks A B C D)) (Matrix.fromBlocks (HSMul.hSMul x A) (HSMul.hSMul x B) (HSMul.hSMul x C) (HSMul.hSMul x D))","decl":"theorem fromBlocks_smul [SMul R α] (x : R) (A : Matrix n l α) (B : Matrix n m α) (C : Matrix o l α)\n    (D : Matrix o m α) : x • fromBlocks A B C D = fromBlocks (x • A) (x • B) (x • C) (x • D) := by\n  ext i j; rcases i with ⟨⟩ <;> rcases j with ⟨⟩ <;> simp [fromBlocks]\n\n"}
{"name":"Matrix.fromBlocks_neg","module":"Mathlib.Data.Matrix.Block","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nR : Type u_10\ninst✝ : Neg R\nA : Matrix n l R\nB : Matrix n m R\nC : Matrix o l R\nD : Matrix o m R\n⊢ Eq (Neg.neg (Matrix.fromBlocks A B C D)) (Matrix.fromBlocks (Neg.neg A) (Neg.neg B) (Neg.neg C) (Neg.neg D))","decl":"theorem fromBlocks_neg [Neg R] (A : Matrix n l R) (B : Matrix n m R) (C : Matrix o l R)\n    (D : Matrix o m R) : -fromBlocks A B C D = fromBlocks (-A) (-B) (-C) (-D) := by\n  ext i j\n  cases i <;> cases j <;> simp [fromBlocks]\n\n"}
{"name":"Matrix.fromBlocks_zero","module":"Mathlib.Data.Matrix.Block","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\ninst✝ : Zero α\n⊢ Eq (Matrix.fromBlocks 0 0 0 0) 0","decl":"@[simp]\ntheorem fromBlocks_zero [Zero α] : fromBlocks (0 : Matrix n l α) 0 0 (0 : Matrix o m α) = 0 := by\n  ext i j\n  rcases i with ⟨⟩ <;> rcases j with ⟨⟩ <;> rfl\n\n"}
{"name":"Matrix.fromBlocks_add","module":"Mathlib.Data.Matrix.Block","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\ninst✝ : Add α\nA : Matrix n l α\nB : Matrix n m α\nC : Matrix o l α\nD : Matrix o m α\nA' : Matrix n l α\nB' : Matrix n m α\nC' : Matrix o l α\nD' : Matrix o m α\n⊢ Eq (HAdd.hAdd (Matrix.fromBlocks A B C D) (Matrix.fromBlocks A' B' C' D')) (Matrix.fromBlocks (HAdd.hAdd A A') (HAdd.hAdd B B') (HAdd.hAdd C C') (HAdd.hAdd D D'))","decl":"theorem fromBlocks_add [Add α] (A : Matrix n l α) (B : Matrix n m α) (C : Matrix o l α)\n    (D : Matrix o m α) (A' : Matrix n l α) (B' : Matrix n m α) (C' : Matrix o l α)\n    (D' : Matrix o m α) : fromBlocks A B C D + fromBlocks A' B' C' D' =\n      fromBlocks (A + A') (B + B') (C + C') (D + D') := by\n  ext i j; rcases i with ⟨⟩ <;> rcases j with ⟨⟩ <;> rfl\n\n"}
{"name":"Matrix.fromBlocks_multiply","module":"Mathlib.Data.Matrix.Block","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\np : Type u_5\nq : Type u_6\nα : Type u_12\ninst✝² : Fintype l\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocSemiring α\nA : Matrix n l α\nB : Matrix n m α\nC : Matrix o l α\nD : Matrix o m α\nA' : Matrix l p α\nB' : Matrix l q α\nC' : Matrix m p α\nD' : Matrix m q α\n⊢ Eq (HMul.hMul (Matrix.fromBlocks A B C D) (Matrix.fromBlocks A' B' C' D')) (Matrix.fromBlocks (HAdd.hAdd (HMul.hMul A A') (HMul.hMul B C')) (HAdd.hAdd (HMul.hMul A B') (HMul.hMul B D')) (HAdd.hAdd (HMul.hMul C A') (HMul.hMul D C')) (HAdd.hAdd (HMul.hMul C B') (HMul.hMul D D')))","decl":"theorem fromBlocks_multiply [Fintype l] [Fintype m] [NonUnitalNonAssocSemiring α] (A : Matrix n l α)\n    (B : Matrix n m α) (C : Matrix o l α) (D : Matrix o m α) (A' : Matrix l p α) (B' : Matrix l q α)\n    (C' : Matrix m p α) (D' : Matrix m q α) :\n    fromBlocks A B C D * fromBlocks A' B' C' D' =\n      fromBlocks (A * A' + B * C') (A * B' + B * D') (C * A' + D * C') (C * B' + D * D') := by\n  ext i j\n  rcases i with ⟨⟩ <;> rcases j with ⟨⟩ <;> simp only [fromBlocks, mul_apply, of_apply,\n      Sum.elim_inr, Fintype.sum_sum_type, Sum.elim_inl, add_apply]\n\n"}
{"name":"Matrix.fromBlocks_mulVec","module":"Mathlib.Data.Matrix.Block","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\ninst✝² : Fintype l\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocSemiring α\nA : Matrix n l α\nB : Matrix n m α\nC : Matrix o l α\nD : Matrix o m α\nx : Sum l m → α\n⊢ Eq ((Matrix.fromBlocks A B C D).mulVec x) (Sum.elim (HAdd.hAdd (A.mulVec (Function.comp x Sum.inl)) (B.mulVec (Function.comp x Sum.inr))) (HAdd.hAdd (C.mulVec (Function.comp x Sum.inl)) (D.mulVec (Function.comp x Sum.inr))))","decl":"theorem fromBlocks_mulVec [Fintype l] [Fintype m] [NonUnitalNonAssocSemiring α] (A : Matrix n l α)\n    (B : Matrix n m α) (C : Matrix o l α) (D : Matrix o m α) (x : l ⊕ m → α) :\n    (fromBlocks A B C D) *ᵥ x =\n      Sum.elim (A *ᵥ (x ∘ Sum.inl) + B *ᵥ (x ∘ Sum.inr))\n        (C *ᵥ (x ∘ Sum.inl) + D *ᵥ (x ∘ Sum.inr)) := by\n  ext i\n  cases i <;> simp [mulVec, dotProduct]\n\n"}
{"name":"Matrix.vecMul_fromBlocks","module":"Mathlib.Data.Matrix.Block","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\ninst✝² : Fintype n\ninst✝¹ : Fintype o\ninst✝ : NonUnitalNonAssocSemiring α\nA : Matrix n l α\nB : Matrix n m α\nC : Matrix o l α\nD : Matrix o m α\nx : Sum n o → α\n⊢ Eq (Matrix.vecMul x (Matrix.fromBlocks A B C D)) (Sum.elim (HAdd.hAdd (Matrix.vecMul (Function.comp x Sum.inl) A) (Matrix.vecMul (Function.comp x Sum.inr) C)) (HAdd.hAdd (Matrix.vecMul (Function.comp x Sum.inl) B) (Matrix.vecMul (Function.comp x Sum.inr) D)))","decl":"theorem vecMul_fromBlocks [Fintype n] [Fintype o] [NonUnitalNonAssocSemiring α] (A : Matrix n l α)\n    (B : Matrix n m α) (C : Matrix o l α) (D : Matrix o m α) (x : n ⊕ o → α) :\n    x ᵥ* fromBlocks A B C D =\n      Sum.elim ((x ∘ Sum.inl) ᵥ* A + (x ∘ Sum.inr) ᵥ* C)\n        ((x ∘ Sum.inl) ᵥ* B + (x ∘ Sum.inr) ᵥ* D) := by\n  ext i\n  cases i <;> simp [vecMul, dotProduct]\n\n"}
{"name":"Matrix.toBlock_diagonal_self","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nα : Type u_12\ninst✝¹ : DecidableEq m\ninst✝ : Zero α\nd : m → α\np : m → Prop\n⊢ Eq ((Matrix.diagonal d).toBlock p p) (Matrix.diagonal fun i => d ↑i)","decl":"theorem toBlock_diagonal_self (d : m → α) (p : m → Prop) :\n    Matrix.toBlock (diagonal d) p p = diagonal fun i : Subtype p => d ↑i := by\n  ext i j\n  by_cases h : i = j\n  · simp [h]\n  · simp [One.one, h, Subtype.val_injective.ne h]\n\n"}
{"name":"Matrix.toBlock_diagonal_disjoint","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nα : Type u_12\ninst✝¹ : DecidableEq m\ninst✝ : Zero α\nd : m → α\np q : m → Prop\nhpq : Disjoint p q\n⊢ Eq ((Matrix.diagonal d).toBlock p q) 0","decl":"theorem toBlock_diagonal_disjoint (d : m → α) {p q : m → Prop} (hpq : Disjoint p q) :\n    Matrix.toBlock (diagonal d) p q = 0 := by\n  ext ⟨i, hi⟩ ⟨j, hj⟩\n  have : i ≠ j := fun heq => hpq.le_bot i ⟨hi, heq.symm ▸ hj⟩\n  simp [diagonal_apply_ne d this]\n\n"}
{"name":"Matrix.fromBlocks_diagonal","module":"Mathlib.Data.Matrix.Block","initialProofState":"l : Type u_1\nm : Type u_2\nα : Type u_12\ninst✝² : DecidableEq l\ninst✝¹ : DecidableEq m\ninst✝ : Zero α\nd₁ : l → α\nd₂ : m → α\n⊢ Eq (Matrix.fromBlocks (Matrix.diagonal d₁) 0 0 (Matrix.diagonal d₂)) (Matrix.diagonal (Sum.elim d₁ d₂))","decl":"@[simp]\ntheorem fromBlocks_diagonal (d₁ : l → α) (d₂ : m → α) :\n    fromBlocks (diagonal d₁) 0 0 (diagonal d₂) = diagonal (Sum.elim d₁ d₂) := by\n  ext i j\n  rcases i with ⟨⟩ <;> rcases j with ⟨⟩ <;> simp [diagonal]\n\n"}
{"name":"Matrix.toBlocks₁₁_diagonal","module":"Mathlib.Data.Matrix.Block","initialProofState":"l : Type u_1\nm : Type u_2\nα : Type u_12\ninst✝² : DecidableEq l\ninst✝¹ : DecidableEq m\ninst✝ : Zero α\nv : Sum l m → α\n⊢ Eq (Matrix.diagonal v).toBlocks₁₁ (Matrix.diagonal fun i => v (Sum.inl i))","decl":"@[simp]\nlemma toBlocks₁₁_diagonal (v : l ⊕ m → α) :\n    toBlocks₁₁ (diagonal v) = diagonal (fun i => v (Sum.inl i)) := by\n  unfold toBlocks₁₁\n  funext i j\n  simp only [ne_eq, Sum.inl.injEq, of_apply, diagonal_apply]\n\n"}
{"name":"Matrix.toBlocks₂₂_diagonal","module":"Mathlib.Data.Matrix.Block","initialProofState":"l : Type u_1\nm : Type u_2\nα : Type u_12\ninst✝² : DecidableEq l\ninst✝¹ : DecidableEq m\ninst✝ : Zero α\nv : Sum l m → α\n⊢ Eq (Matrix.diagonal v).toBlocks₂₂ (Matrix.diagonal fun i => v (Sum.inr i))","decl":"@[simp]\nlemma toBlocks₂₂_diagonal (v : l ⊕ m → α) :\n    toBlocks₂₂ (diagonal v) = diagonal (fun i => v (Sum.inr i)) := by\n  unfold toBlocks₂₂\n  funext i j\n  simp only [ne_eq, Sum.inr.injEq, of_apply, diagonal_apply]\n\n"}
{"name":"Matrix.toBlocks₁₂_diagonal","module":"Mathlib.Data.Matrix.Block","initialProofState":"l : Type u_1\nm : Type u_2\nα : Type u_12\ninst✝² : DecidableEq l\ninst✝¹ : DecidableEq m\ninst✝ : Zero α\nv : Sum l m → α\n⊢ Eq (Matrix.diagonal v).toBlocks₁₂ 0","decl":"@[simp]\nlemma toBlocks₁₂_diagonal (v : l ⊕ m → α) : toBlocks₁₂ (diagonal v) = 0 := rfl\n\n"}
{"name":"Matrix.toBlocks₂₁_diagonal","module":"Mathlib.Data.Matrix.Block","initialProofState":"l : Type u_1\nm : Type u_2\nα : Type u_12\ninst✝² : DecidableEq l\ninst✝¹ : DecidableEq m\ninst✝ : Zero α\nv : Sum l m → α\n⊢ Eq (Matrix.diagonal v).toBlocks₂₁ 0","decl":"@[simp]\nlemma toBlocks₂₁_diagonal (v : l ⊕ m → α) : toBlocks₂₁ (diagonal v) = 0 := rfl\n\n"}
{"name":"Matrix.fromBlocks_one","module":"Mathlib.Data.Matrix.Block","initialProofState":"l : Type u_1\nm : Type u_2\nα : Type u_12\ninst✝³ : DecidableEq l\ninst✝² : DecidableEq m\ninst✝¹ : Zero α\ninst✝ : One α\n⊢ Eq (Matrix.fromBlocks 1 0 0 1) 1","decl":"@[simp]\ntheorem fromBlocks_one : fromBlocks (1 : Matrix l l α) 0 0 (1 : Matrix m m α) = 1 := by\n  ext i j\n  rcases i with ⟨⟩ <;> rcases j with ⟨⟩ <;> simp [one_apply]\n\n"}
{"name":"Matrix.toBlock_one_self","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nα : Type u_12\ninst✝² : DecidableEq m\ninst✝¹ : Zero α\ninst✝ : One α\np : m → Prop\n⊢ Eq (Matrix.toBlock 1 p p) 1","decl":"@[simp]\ntheorem toBlock_one_self (p : m → Prop) : Matrix.toBlock (1 : Matrix m m α) p p = 1 :=\n  toBlock_diagonal_self _ p\n\n"}
{"name":"Matrix.toBlock_one_disjoint","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nα : Type u_12\ninst✝² : DecidableEq m\ninst✝¹ : Zero α\ninst✝ : One α\np q : m → Prop\nhpq : Disjoint p q\n⊢ Eq (Matrix.toBlock 1 p q) 0","decl":"theorem toBlock_one_disjoint {p q : m → Prop} (hpq : Disjoint p q) :\n    Matrix.toBlock (1 : Matrix m m α) p q = 0 :=\n  toBlock_diagonal_disjoint _ hpq\n\n"}
{"name":"Matrix.blockDiagonal_apply'","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\ninst✝¹ : DecidableEq o\ninst✝ : Zero α\nM : o → Matrix m n α\ni : m\nk : o\nj : n\nk' : o\n⊢ Eq (Matrix.blockDiagonal M { fst := i, snd := k } { fst := j, snd := k' }) (ite (Eq k k') (M k i j) 0)","decl":"theorem blockDiagonal_apply' (M : o → Matrix m n α) (i k j k') :\n    blockDiagonal M ⟨i, k⟩ ⟨j, k'⟩ = if k = k' then M k i j else 0 :=\n  rfl\n\n"}
{"name":"Matrix.blockDiagonal_apply","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\ninst✝¹ : DecidableEq o\ninst✝ : Zero α\nM : o → Matrix m n α\nik : Prod m o\njk : Prod n o\n⊢ Eq (Matrix.blockDiagonal M ik jk) (ite (Eq ik.2 jk.2) (M ik.2 ik.1 jk.1) 0)","decl":"theorem blockDiagonal_apply (M : o → Matrix m n α) (ik jk) :\n    blockDiagonal M ik jk = if ik.2 = jk.2 then M ik.2 ik.1 jk.1 else 0 := by\n  cases ik\n  cases jk\n  rfl\n\n"}
{"name":"Matrix.blockDiagonal_apply_eq","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\ninst✝¹ : DecidableEq o\ninst✝ : Zero α\nM : o → Matrix m n α\ni : m\nj : n\nk : o\n⊢ Eq (Matrix.blockDiagonal M { fst := i, snd := k } { fst := j, snd := k }) (M k i j)","decl":"@[simp]\ntheorem blockDiagonal_apply_eq (M : o → Matrix m n α) (i j k) :\n    blockDiagonal M (i, k) (j, k) = M k i j :=\n  if_pos rfl\n\n"}
{"name":"Matrix.blockDiagonal_apply_ne","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\ninst✝¹ : DecidableEq o\ninst✝ : Zero α\nM : o → Matrix m n α\ni : m\nj : n\nk k' : o\nh : Ne k k'\n⊢ Eq (Matrix.blockDiagonal M { fst := i, snd := k } { fst := j, snd := k' }) 0","decl":"theorem blockDiagonal_apply_ne (M : o → Matrix m n α) (i j) {k k'} (h : k ≠ k') :\n    blockDiagonal M (i, k) (j, k') = 0 :=\n  if_neg h\n\n"}
{"name":"Matrix.blockDiagonal_map","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\nβ : Type u_13\ninst✝² : DecidableEq o\ninst✝¹ : Zero α\ninst✝ : Zero β\nM : o → Matrix m n α\nf : α → β\nhf : Eq (f 0) 0\n⊢ Eq ((Matrix.blockDiagonal M).map f) (Matrix.blockDiagonal fun k => (M k).map f)","decl":"theorem blockDiagonal_map (M : o → Matrix m n α) (f : α → β) (hf : f 0 = 0) :\n    (blockDiagonal M).map f = blockDiagonal fun k => (M k).map f := by\n  ext\n  simp only [map_apply, blockDiagonal_apply, eq_comm]\n  rw [apply_ite f, hf]\n\n"}
{"name":"Matrix.blockDiagonal_transpose","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\ninst✝¹ : DecidableEq o\ninst✝ : Zero α\nM : o → Matrix m n α\n⊢ Eq (Matrix.blockDiagonal M).transpose (Matrix.blockDiagonal fun k => (M k).transpose)","decl":"@[simp]\ntheorem blockDiagonal_transpose (M : o → Matrix m n α) :\n    (blockDiagonal M)ᵀ = blockDiagonal fun k => (M k)ᵀ := by\n  ext\n  simp only [transpose_apply, blockDiagonal_apply, eq_comm]\n  split_ifs with h\n  · rw [h]\n  · rfl\n\n"}
{"name":"Matrix.blockDiagonal_conjTranspose","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\ninst✝² : DecidableEq o\nα : Type u_14\ninst✝¹ : AddMonoid α\ninst✝ : StarAddMonoid α\nM : o → Matrix m n α\n⊢ Eq (Matrix.blockDiagonal M).conjTranspose (Matrix.blockDiagonal fun k => (M k).conjTranspose)","decl":"@[simp]\ntheorem blockDiagonal_conjTranspose {α : Type*} [AddMonoid α] [StarAddMonoid α]\n    (M : o → Matrix m n α) : (blockDiagonal M)ᴴ = blockDiagonal fun k => (M k)ᴴ := by\n  simp only [conjTranspose, blockDiagonal_transpose]\n  rw [blockDiagonal_map _ star (star_zero α)]\n\n"}
{"name":"Matrix.blockDiagonal_zero","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\ninst✝¹ : DecidableEq o\ninst✝ : Zero α\n⊢ Eq (Matrix.blockDiagonal 0) 0","decl":"@[simp]\ntheorem blockDiagonal_zero : blockDiagonal (0 : o → Matrix m n α) = 0 := by\n  ext\n  simp [blockDiagonal_apply]\n\n"}
{"name":"Matrix.blockDiagonal_diagonal","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\no : Type u_4\nα : Type u_12\ninst✝² : DecidableEq o\ninst✝¹ : Zero α\ninst✝ : DecidableEq m\nd : o → m → α\n⊢ Eq (Matrix.blockDiagonal fun k => Matrix.diagonal (d k)) (Matrix.diagonal fun ik => d ik.2 ik.1)","decl":"@[simp]\ntheorem blockDiagonal_diagonal [DecidableEq m] (d : o → m → α) :\n    (blockDiagonal fun k => diagonal (d k)) = diagonal fun ik => d ik.2 ik.1 := by\n  ext ⟨i, k⟩ ⟨j, k'⟩\n  simp only [blockDiagonal_apply, diagonal_apply, Prod.mk.inj_iff, ← ite_and]\n  congr 1\n  rw [and_comm]\n\n"}
{"name":"Matrix.blockDiagonal_one","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\no : Type u_4\nα : Type u_12\ninst✝³ : DecidableEq o\ninst✝² : Zero α\ninst✝¹ : DecidableEq m\ninst✝ : One α\n⊢ Eq (Matrix.blockDiagonal 1) 1","decl":"@[simp]\ntheorem blockDiagonal_one [DecidableEq m] [One α] : blockDiagonal (1 : o → Matrix m m α) = 1 :=\n  show (blockDiagonal fun _ : o => diagonal fun _ : m => (1 : α)) = diagonal fun _ => 1 by\n    rw [blockDiagonal_diagonal]\n\n"}
{"name":"Matrix.blockDiagonal_add","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\ninst✝¹ : DecidableEq o\ninst✝ : AddZeroClass α\nM N : o → Matrix m n α\n⊢ Eq (Matrix.blockDiagonal (HAdd.hAdd M N)) (HAdd.hAdd (Matrix.blockDiagonal M) (Matrix.blockDiagonal N))","decl":"@[simp]\ntheorem blockDiagonal_add [AddZeroClass α] (M N : o → Matrix m n α) :\n    blockDiagonal (M + N) = blockDiagonal M + blockDiagonal N := by\n  ext\n  simp only [blockDiagonal_apply, Pi.add_apply, add_apply]\n  split_ifs <;> simp\n\n"}
{"name":"Matrix.blockDiagonalAddMonoidHom_apply","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\ninst✝¹ : DecidableEq o\ninst✝ : AddZeroClass α\nM : o → Matrix m n α\n⊢ Eq ((Matrix.blockDiagonalAddMonoidHom m n o α) M) (Matrix.blockDiagonal M)","decl":"/-- `Matrix.blockDiagonal` as an `AddMonoidHom`. -/\n@[simps]\ndef blockDiagonalAddMonoidHom [AddZeroClass α] :\n    (o → Matrix m n α) →+ Matrix (m × o) (n × o) α where\n  toFun := blockDiagonal\n  map_zero' := blockDiagonal_zero\n  map_add' := blockDiagonal_add\n\n"}
{"name":"Matrix.blockDiagonal_neg","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\ninst✝¹ : DecidableEq o\ninst✝ : AddGroup α\nM : o → Matrix m n α\n⊢ Eq (Matrix.blockDiagonal (Neg.neg M)) (Neg.neg (Matrix.blockDiagonal M))","decl":"@[simp]\ntheorem blockDiagonal_neg [AddGroup α] (M : o → Matrix m n α) :\n    blockDiagonal (-M) = -blockDiagonal M :=\n  map_neg (blockDiagonalAddMonoidHom m n o α) M\n\n"}
{"name":"Matrix.blockDiagonal_sub","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\ninst✝¹ : DecidableEq o\ninst✝ : AddGroup α\nM N : o → Matrix m n α\n⊢ Eq (Matrix.blockDiagonal (HSub.hSub M N)) (HSub.hSub (Matrix.blockDiagonal M) (Matrix.blockDiagonal N))","decl":"@[simp]\ntheorem blockDiagonal_sub [AddGroup α] (M N : o → Matrix m n α) :\n    blockDiagonal (M - N) = blockDiagonal M - blockDiagonal N :=\n  map_sub (blockDiagonalAddMonoidHom m n o α) M N\n\n"}
{"name":"Matrix.blockDiagonal_mul","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\np : Type u_5\nα : Type u_12\ninst✝³ : DecidableEq o\ninst✝² : Fintype n\ninst✝¹ : Fintype o\ninst✝ : NonUnitalNonAssocSemiring α\nM : o → Matrix m n α\nN : o → Matrix n p α\n⊢ Eq (Matrix.blockDiagonal fun k => HMul.hMul (M k) (N k)) (HMul.hMul (Matrix.blockDiagonal M) (Matrix.blockDiagonal N))","decl":"@[simp]\ntheorem blockDiagonal_mul [Fintype n] [Fintype o] [NonUnitalNonAssocSemiring α]\n    (M : o → Matrix m n α) (N : o → Matrix n p α) :\n    (blockDiagonal fun k => M k * N k) = blockDiagonal M * blockDiagonal N := by\n  ext ⟨i, k⟩ ⟨j, k'⟩\n  simp only [blockDiagonal_apply, mul_apply, ← Finset.univ_product_univ, Finset.sum_product]\n  split_ifs with h <;> simp [h]\n\n"}
{"name":"Matrix.blockDiagonalRingHom_apply","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\no : Type u_4\nα : Type u_12\ninst✝⁴ : DecidableEq o\ninst✝³ : DecidableEq m\ninst✝² : Fintype o\ninst✝¹ : Fintype m\ninst✝ : NonAssocSemiring α\nM : o → Matrix m m α\n⊢ Eq ((Matrix.blockDiagonalRingHom m o α) M) (Matrix.blockDiagonal M)","decl":"/-- `Matrix.blockDiagonal` as a `RingHom`. -/\n@[simps]\ndef blockDiagonalRingHom [DecidableEq m] [Fintype o] [Fintype m] [NonAssocSemiring α] :\n    (o → Matrix m m α) →+* Matrix (m × o) (m × o) α :=\n  { blockDiagonalAddMonoidHom m m o α with\n    toFun := blockDiagonal\n    map_one' := blockDiagonal_one\n    map_mul' := blockDiagonal_mul }\n\n"}
{"name":"Matrix.blockDiagonal_pow","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\no : Type u_4\nα : Type u_12\ninst✝⁴ : DecidableEq o\ninst✝³ : DecidableEq m\ninst✝² : Fintype o\ninst✝¹ : Fintype m\ninst✝ : Semiring α\nM : o → Matrix m m α\nn : Nat\n⊢ Eq (Matrix.blockDiagonal (HPow.hPow M n)) (HPow.hPow (Matrix.blockDiagonal M) n)","decl":"@[simp]\ntheorem blockDiagonal_pow [DecidableEq m] [Fintype o] [Fintype m] [Semiring α]\n    (M : o → Matrix m m α) (n : ℕ) : blockDiagonal (M ^ n) = blockDiagonal M ^ n :=\n  map_pow (blockDiagonalRingHom m o α) M n\n\n"}
{"name":"Matrix.blockDiagonal_smul","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\ninst✝³ : DecidableEq o\nR : Type u_14\ninst✝² : Monoid R\ninst✝¹ : AddMonoid α\ninst✝ : DistribMulAction R α\nx : R\nM : o → Matrix m n α\n⊢ Eq (Matrix.blockDiagonal (HSMul.hSMul x M)) (HSMul.hSMul x (Matrix.blockDiagonal M))","decl":"@[simp]\ntheorem blockDiagonal_smul {R : Type*} [Monoid R] [AddMonoid α] [DistribMulAction R α] (x : R)\n    (M : o → Matrix m n α) : blockDiagonal (x • M) = x • blockDiagonal M := by\n  ext\n  simp only [blockDiagonal_apply, Pi.smul_apply, smul_apply]\n  split_ifs <;> simp\n\n"}
{"name":"Matrix.blockDiag_apply","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\nM : Matrix (Prod m o) (Prod n o) α\nk : o\ni : m\nj : n\n⊢ Eq (M.blockDiag k i j) (M { fst := i, snd := k } { fst := j, snd := k })","decl":"theorem blockDiag_apply (M : Matrix (m × o) (n × o) α) (k : o) (i j) :\n    blockDiag M k i j = M (i, k) (j, k) :=\n  rfl\n\n"}
{"name":"Matrix.blockDiag_map","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\nβ : Type u_13\nM : Matrix (Prod m o) (Prod n o) α\nf : α → β\n⊢ Eq (M.map f).blockDiag fun k => (M.blockDiag k).map f","decl":"theorem blockDiag_map (M : Matrix (m × o) (n × o) α) (f : α → β) :\n    blockDiag (M.map f) = fun k => (blockDiag M k).map f :=\n  rfl\n\n"}
{"name":"Matrix.blockDiag_transpose","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\nM : Matrix (Prod m o) (Prod n o) α\nk : o\n⊢ Eq (M.transpose.blockDiag k) (M.blockDiag k).transpose","decl":"@[simp]\ntheorem blockDiag_transpose (M : Matrix (m × o) (n × o) α) (k : o) :\n    blockDiag Mᵀ k = (blockDiag M k)ᵀ :=\n  ext fun _ _ => rfl\n\n"}
{"name":"Matrix.blockDiag_conjTranspose","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_14\ninst✝¹ : AddMonoid α\ninst✝ : StarAddMonoid α\nM : Matrix (Prod m o) (Prod n o) α\nk : o\n⊢ Eq (M.conjTranspose.blockDiag k) (M.blockDiag k).conjTranspose","decl":"@[simp]\ntheorem blockDiag_conjTranspose {α : Type*} [AddMonoid α] [StarAddMonoid α]\n    (M : Matrix (m × o) (n × o) α) (k : o) : blockDiag Mᴴ k = (blockDiag M k)ᴴ :=\n  ext fun _ _ => rfl\n\n"}
{"name":"Matrix.blockDiag_zero","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\ninst✝ : Zero α\n⊢ Eq (Matrix.blockDiag 0) 0","decl":"@[simp]\ntheorem blockDiag_zero : blockDiag (0 : Matrix (m × o) (n × o) α) = 0 :=\n  rfl\n\n"}
{"name":"Matrix.blockDiag_diagonal","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\no : Type u_4\nα : Type u_12\ninst✝² : Zero α\ninst✝¹ : DecidableEq o\ninst✝ : DecidableEq m\nd : Prod m o → α\nk : o\n⊢ Eq ((Matrix.diagonal d).blockDiag k) (Matrix.diagonal fun i => d { fst := i, snd := k })","decl":"@[simp]\ntheorem blockDiag_diagonal [DecidableEq o] [DecidableEq m] (d : m × o → α) (k : o) :\n    blockDiag (diagonal d) k = diagonal fun i => d (i, k) :=\n  ext fun i j => by\n    obtain rfl | hij := Decidable.eq_or_ne i j\n    · rw [blockDiag_apply, diagonal_apply_eq, diagonal_apply_eq]\n    · rw [blockDiag_apply, diagonal_apply_ne _ hij, diagonal_apply_ne _ (mt _ hij)]\n      exact Prod.fst_eq_iff.mpr\n\n"}
{"name":"Matrix.blockDiag_blockDiagonal","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\ninst✝¹ : Zero α\ninst✝ : DecidableEq o\nM : o → Matrix m n α\n⊢ Eq (Matrix.blockDiagonal M).blockDiag M","decl":"@[simp]\ntheorem blockDiag_blockDiagonal [DecidableEq o] (M : o → Matrix m n α) :\n    blockDiag (blockDiagonal M) = M :=\n  funext fun _ => ext fun i j => blockDiagonal_apply_eq M i j _\n\n"}
{"name":"Matrix.blockDiagonal_injective","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\ninst✝¹ : Zero α\ninst✝ : DecidableEq o\n⊢ Function.Injective Matrix.blockDiagonal","decl":"theorem blockDiagonal_injective [DecidableEq o] :\n    Function.Injective (blockDiagonal : (o → Matrix m n α) → Matrix _ _ α) :=\n  Function.LeftInverse.injective blockDiag_blockDiagonal\n\n"}
{"name":"Matrix.blockDiagonal_inj","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\ninst✝¹ : Zero α\ninst✝ : DecidableEq o\nM N : o → Matrix m n α\n⊢ Iff (Eq (Matrix.blockDiagonal M) (Matrix.blockDiagonal N)) (Eq M N)","decl":"@[simp]\ntheorem blockDiagonal_inj [DecidableEq o] {M N : o → Matrix m n α} :\n    blockDiagonal M = blockDiagonal N ↔ M = N :=\n  blockDiagonal_injective.eq_iff\n\n"}
{"name":"Matrix.blockDiag_one","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\no : Type u_4\nα : Type u_12\ninst✝³ : Zero α\ninst✝² : DecidableEq o\ninst✝¹ : DecidableEq m\ninst✝ : One α\n⊢ Eq (Matrix.blockDiag 1) 1","decl":"@[simp]\ntheorem blockDiag_one [DecidableEq o] [DecidableEq m] [One α] :\n    blockDiag (1 : Matrix (m × o) (m × o) α) = 1 :=\n  funext <| blockDiag_diagonal _\n\n"}
{"name":"Matrix.blockDiag_add","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\ninst✝ : AddZeroClass α\nM N : Matrix (Prod m o) (Prod n o) α\n⊢ Eq (HAdd.hAdd M N).blockDiag (HAdd.hAdd M.blockDiag N.blockDiag)","decl":"@[simp]\ntheorem blockDiag_add [AddZeroClass α] (M N : Matrix (m × o) (n × o) α) :\n    blockDiag (M + N) = blockDiag M + blockDiag N :=\n  rfl\n\n"}
{"name":"Matrix.blockDiagAddMonoidHom_apply","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\ninst✝ : AddZeroClass α\nM : Matrix (Prod m o) (Prod n o) α\nk : o\n⊢ Eq ((Matrix.blockDiagAddMonoidHom m n o α) M k) (M.blockDiag k)","decl":"/-- `Matrix.blockDiag` as an `AddMonoidHom`. -/\n@[simps]\ndef blockDiagAddMonoidHom [AddZeroClass α] : Matrix (m × o) (n × o) α →+ o → Matrix m n α where\n  toFun := blockDiag\n  map_zero' := blockDiag_zero\n  map_add' := blockDiag_add\n\n"}
{"name":"Matrix.blockDiag_neg","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\ninst✝ : AddGroup α\nM : Matrix (Prod m o) (Prod n o) α\n⊢ Eq (Neg.neg M).blockDiag (Neg.neg M.blockDiag)","decl":"@[simp]\ntheorem blockDiag_neg [AddGroup α] (M : Matrix (m × o) (n × o) α) : blockDiag (-M) = -blockDiag M :=\n  map_neg (blockDiagAddMonoidHom m n o α) M\n\n"}
{"name":"Matrix.blockDiag_sub","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\ninst✝ : AddGroup α\nM N : Matrix (Prod m o) (Prod n o) α\n⊢ Eq (HSub.hSub M N).blockDiag (HSub.hSub M.blockDiag N.blockDiag)","decl":"@[simp]\ntheorem blockDiag_sub [AddGroup α] (M N : Matrix (m × o) (n × o) α) :\n    blockDiag (M - N) = blockDiag M - blockDiag N :=\n  map_sub (blockDiagAddMonoidHom m n o α) M N\n\n"}
{"name":"Matrix.blockDiag_smul","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\nR : Type u_14\ninst✝² : Monoid R\ninst✝¹ : AddMonoid α\ninst✝ : DistribMulAction R α\nx : R\nM : Matrix (Prod m o) (Prod n o) α\n⊢ Eq (HSMul.hSMul x M).blockDiag (HSMul.hSMul x M.blockDiag)","decl":"@[simp]\ntheorem blockDiag_smul {R : Type*} [Monoid R] [AddMonoid α] [DistribMulAction R α] (x : R)\n    (M : Matrix (m × o) (n × o) α) : blockDiag (x • M) = x • blockDiag M :=\n  rfl\n\n"}
{"name":"Matrix.blockDiagonal'_apply'","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nn' : o → Type u_8\nα : Type u_12\ninst✝¹ : DecidableEq o\ninst✝ : Zero α\nM : (i : o) → Matrix (m' i) (n' i) α\nk : o\ni : m' k\nk' : o\nj : n' k'\n⊢ Eq (Matrix.blockDiagonal' M ⟨k, i⟩ ⟨k', j⟩) (dite (Eq k k') (fun h => M k i (cast ⋯ j)) fun h => 0)","decl":"theorem blockDiagonal'_apply' (M : ∀ i, Matrix (m' i) (n' i) α) (k i k' j) :\n    blockDiagonal' M ⟨k, i⟩ ⟨k', j⟩ =\n      if h : k = k' then M k i (cast (congr_arg n' h.symm) j) else 0 :=\n  rfl\n\n"}
{"name":"Matrix.blockDiagonal'_eq_blockDiagonal","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\ninst✝¹ : DecidableEq o\ninst✝ : Zero α\nM : o → Matrix m n α\nk k' : o\ni : m\nj : n\n⊢ Eq (Matrix.blockDiagonal M { fst := i, snd := k } { fst := j, snd := k' }) (Matrix.blockDiagonal' M ⟨k, i⟩ ⟨k', j⟩)","decl":"theorem blockDiagonal'_eq_blockDiagonal (M : o → Matrix m n α) {k k'} (i j) :\n    blockDiagonal M (i, k) (j, k') = blockDiagonal' M ⟨k, i⟩ ⟨k', j⟩ :=\n  rfl\n\n"}
{"name":"Matrix.blockDiagonal'_submatrix_eq_blockDiagonal","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type u_12\ninst✝¹ : DecidableEq o\ninst✝ : Zero α\nM : o → Matrix m n α\n⊢ Eq ((Matrix.blockDiagonal' M).submatrix (Function.comp Prod.toSigma Prod.swap) (Function.comp Prod.toSigma Prod.swap)) (Matrix.blockDiagonal M)","decl":"theorem blockDiagonal'_submatrix_eq_blockDiagonal (M : o → Matrix m n α) :\n    (blockDiagonal' M).submatrix (Prod.toSigma ∘ Prod.swap) (Prod.toSigma ∘ Prod.swap) =\n      blockDiagonal M :=\n  Matrix.ext fun ⟨_, _⟩ ⟨_, _⟩ => rfl\n\n"}
{"name":"Matrix.blockDiagonal'_apply","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nn' : o → Type u_8\nα : Type u_12\ninst✝¹ : DecidableEq o\ninst✝ : Zero α\nM : (i : o) → Matrix (m' i) (n' i) α\nik : Sigma fun i => m' i\njk : Sigma fun i => n' i\n⊢ Eq (Matrix.blockDiagonal' M ik jk) (dite (Eq ik.fst jk.fst) (fun h => M ik.fst ik.snd (cast ⋯ jk.snd)) fun h => 0)","decl":"theorem blockDiagonal'_apply (M : ∀ i, Matrix (m' i) (n' i) α) (ik jk) :\n    blockDiagonal' M ik jk =\n      if h : ik.1 = jk.1 then M ik.1 ik.2 (cast (congr_arg n' h.symm) jk.2) else 0 := by\n  cases ik\n  cases jk\n  rfl\n\n"}
{"name":"Matrix.blockDiagonal'_apply_eq","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nn' : o → Type u_8\nα : Type u_12\ninst✝¹ : DecidableEq o\ninst✝ : Zero α\nM : (i : o) → Matrix (m' i) (n' i) α\nk : o\ni : m' k\nj : n' k\n⊢ Eq (Matrix.blockDiagonal' M ⟨k, i⟩ ⟨k, j⟩) (M k i j)","decl":"@[simp]\ntheorem blockDiagonal'_apply_eq (M : ∀ i, Matrix (m' i) (n' i) α) (k i j) :\n    blockDiagonal' M ⟨k, i⟩ ⟨k, j⟩ = M k i j :=\n  dif_pos rfl\n\n"}
{"name":"Matrix.blockDiagonal'_apply_ne","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nn' : o → Type u_8\nα : Type u_12\ninst✝¹ : DecidableEq o\ninst✝ : Zero α\nM : (i : o) → Matrix (m' i) (n' i) α\nk k' : o\ni : m' k\nj : n' k'\nh : Ne k k'\n⊢ Eq (Matrix.blockDiagonal' M ⟨k, i⟩ ⟨k', j⟩) 0","decl":"theorem blockDiagonal'_apply_ne (M : ∀ i, Matrix (m' i) (n' i) α) {k k'} (i j) (h : k ≠ k') :\n    blockDiagonal' M ⟨k, i⟩ ⟨k', j⟩ = 0 :=\n  dif_neg h\n\n"}
{"name":"Matrix.blockDiagonal'_map","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nn' : o → Type u_8\nα : Type u_12\nβ : Type u_13\ninst✝² : DecidableEq o\ninst✝¹ : Zero α\ninst✝ : Zero β\nM : (i : o) → Matrix (m' i) (n' i) α\nf : α → β\nhf : Eq (f 0) 0\n⊢ Eq ((Matrix.blockDiagonal' M).map f) (Matrix.blockDiagonal' fun k => (M k).map f)","decl":"theorem blockDiagonal'_map (M : ∀ i, Matrix (m' i) (n' i) α) (f : α → β) (hf : f 0 = 0) :\n    (blockDiagonal' M).map f = blockDiagonal' fun k => (M k).map f := by\n  ext\n  simp only [map_apply, blockDiagonal'_apply, eq_comm]\n  rw [apply_dite f, hf]\n\n"}
{"name":"Matrix.blockDiagonal'_transpose","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nn' : o → Type u_8\nα : Type u_12\ninst✝¹ : DecidableEq o\ninst✝ : Zero α\nM : (i : o) → Matrix (m' i) (n' i) α\n⊢ Eq (Matrix.blockDiagonal' M).transpose (Matrix.blockDiagonal' fun k => (M k).transpose)","decl":"@[simp]\ntheorem blockDiagonal'_transpose (M : ∀ i, Matrix (m' i) (n' i) α) :\n    (blockDiagonal' M)ᵀ = blockDiagonal' fun k => (M k)ᵀ := by\n  ext ⟨ii, ix⟩ ⟨ji, jx⟩\n  simp only [transpose_apply, blockDiagonal'_apply]\n  split_ifs <;> cc\n\n"}
{"name":"Matrix.blockDiagonal'_conjTranspose","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nn' : o → Type u_8\ninst✝² : DecidableEq o\nα : Type u_14\ninst✝¹ : AddMonoid α\ninst✝ : StarAddMonoid α\nM : (i : o) → Matrix (m' i) (n' i) α\n⊢ Eq (Matrix.blockDiagonal' M).conjTranspose (Matrix.blockDiagonal' fun k => (M k).conjTranspose)","decl":"@[simp]\ntheorem blockDiagonal'_conjTranspose {α} [AddMonoid α] [StarAddMonoid α]\n    (M : ∀ i, Matrix (m' i) (n' i) α) : (blockDiagonal' M)ᴴ = blockDiagonal' fun k => (M k)ᴴ := by\n  simp only [conjTranspose, blockDiagonal'_transpose]\n  exact blockDiagonal'_map _ star (star_zero α)\n\n"}
{"name":"Matrix.blockDiagonal'_zero","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nn' : o → Type u_8\nα : Type u_12\ninst✝¹ : DecidableEq o\ninst✝ : Zero α\n⊢ Eq (Matrix.blockDiagonal' 0) 0","decl":"@[simp]\ntheorem blockDiagonal'_zero : blockDiagonal' (0 : ∀ i, Matrix (m' i) (n' i) α) = 0 := by\n  ext\n  simp [blockDiagonal'_apply]\n\n"}
{"name":"Matrix.blockDiagonal'_diagonal","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nα : Type u_12\ninst✝² : DecidableEq o\ninst✝¹ : Zero α\ninst✝ : (i : o) → DecidableEq (m' i)\nd : (i : o) → m' i → α\n⊢ Eq (Matrix.blockDiagonal' fun k => Matrix.diagonal (d k)) (Matrix.diagonal fun ik => d ik.fst ik.snd)","decl":"@[simp]\ntheorem blockDiagonal'_diagonal [∀ i, DecidableEq (m' i)] (d : ∀ i, m' i → α) :\n    (blockDiagonal' fun k => diagonal (d k)) = diagonal fun ik => d ik.1 ik.2 := by\n  ext ⟨i, k⟩ ⟨j, k'⟩\n  simp only [blockDiagonal'_apply, diagonal]\n  obtain rfl | hij := Decidable.eq_or_ne i j\n  · simp\n  · simp [hij]\n\n"}
{"name":"Matrix.blockDiagonal'_one","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nα : Type u_12\ninst✝³ : DecidableEq o\ninst✝² : Zero α\ninst✝¹ : (i : o) → DecidableEq (m' i)\ninst✝ : One α\n⊢ Eq (Matrix.blockDiagonal' 1) 1","decl":"@[simp]\ntheorem blockDiagonal'_one [∀ i, DecidableEq (m' i)] [One α] :\n    blockDiagonal' (1 : ∀ i, Matrix (m' i) (m' i) α) = 1 :=\n  show (blockDiagonal' fun i : o => diagonal fun _ : m' i => (1 : α)) = diagonal fun _ => 1 by\n    rw [blockDiagonal'_diagonal]\n\n"}
{"name":"Matrix.blockDiagonal'_add","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nn' : o → Type u_8\nα : Type u_12\ninst✝¹ : DecidableEq o\ninst✝ : AddZeroClass α\nM N : (i : o) → Matrix (m' i) (n' i) α\n⊢ Eq (Matrix.blockDiagonal' (HAdd.hAdd M N)) (HAdd.hAdd (Matrix.blockDiagonal' M) (Matrix.blockDiagonal' N))","decl":"@[simp]\ntheorem blockDiagonal'_add [AddZeroClass α] (M N : ∀ i, Matrix (m' i) (n' i) α) :\n    blockDiagonal' (M + N) = blockDiagonal' M + blockDiagonal' N := by\n  ext\n  simp only [blockDiagonal'_apply, Pi.add_apply, add_apply]\n  split_ifs <;> simp\n\n"}
{"name":"Matrix.blockDiagonal'AddMonoidHom_apply","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nn' : o → Type u_8\nα : Type u_12\ninst✝¹ : DecidableEq o\ninst✝ : AddZeroClass α\nM : (i : o) → Matrix (m' i) (n' i) α\n⊢ Eq ((Matrix.blockDiagonal'AddMonoidHom m' n' α) M) (Matrix.blockDiagonal' M)","decl":"/-- `Matrix.blockDiagonal'` as an `AddMonoidHom`. -/\n@[simps]\ndef blockDiagonal'AddMonoidHom [AddZeroClass α] :\n    (∀ i, Matrix (m' i) (n' i) α) →+ Matrix (Σi, m' i) (Σi, n' i) α where\n  toFun := blockDiagonal'\n  map_zero' := blockDiagonal'_zero\n  map_add' := blockDiagonal'_add\n\n"}
{"name":"Matrix.blockDiagonal'_neg","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nn' : o → Type u_8\nα : Type u_12\ninst✝¹ : DecidableEq o\ninst✝ : AddGroup α\nM : (i : o) → Matrix (m' i) (n' i) α\n⊢ Eq (Matrix.blockDiagonal' (Neg.neg M)) (Neg.neg (Matrix.blockDiagonal' M))","decl":"@[simp]\ntheorem blockDiagonal'_neg [AddGroup α] (M : ∀ i, Matrix (m' i) (n' i) α) :\n    blockDiagonal' (-M) = -blockDiagonal' M :=\n  map_neg (blockDiagonal'AddMonoidHom m' n' α) M\n\n"}
{"name":"Matrix.blockDiagonal'_sub","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nn' : o → Type u_8\nα : Type u_12\ninst✝¹ : DecidableEq o\ninst✝ : AddGroup α\nM N : (i : o) → Matrix (m' i) (n' i) α\n⊢ Eq (Matrix.blockDiagonal' (HSub.hSub M N)) (HSub.hSub (Matrix.blockDiagonal' M) (Matrix.blockDiagonal' N))","decl":"@[simp]\ntheorem blockDiagonal'_sub [AddGroup α] (M N : ∀ i, Matrix (m' i) (n' i) α) :\n    blockDiagonal' (M - N) = blockDiagonal' M - blockDiagonal' N :=\n  map_sub (blockDiagonal'AddMonoidHom m' n' α) M N\n\n"}
{"name":"Matrix.blockDiagonal'_mul","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nn' : o → Type u_8\np' : o → Type u_9\nα : Type u_12\ninst✝³ : DecidableEq o\ninst✝² : NonUnitalNonAssocSemiring α\ninst✝¹ : (i : o) → Fintype (n' i)\ninst✝ : Fintype o\nM : (i : o) → Matrix (m' i) (n' i) α\nN : (i : o) → Matrix (n' i) (p' i) α\n⊢ Eq (Matrix.blockDiagonal' fun k => HMul.hMul (M k) (N k)) (HMul.hMul (Matrix.blockDiagonal' M) (Matrix.blockDiagonal' N))","decl":"@[simp]\ntheorem blockDiagonal'_mul [NonUnitalNonAssocSemiring α] [∀ i, Fintype (n' i)] [Fintype o]\n    (M : ∀ i, Matrix (m' i) (n' i) α) (N : ∀ i, Matrix (n' i) (p' i) α) :\n    (blockDiagonal' fun k => M k * N k) = blockDiagonal' M * blockDiagonal' N := by\n  ext ⟨k, i⟩ ⟨k', j⟩\n  simp only [blockDiagonal'_apply, mul_apply, ← Finset.univ_sigma_univ, Finset.sum_sigma]\n  rw [Fintype.sum_eq_single k]\n  · simp only [if_pos, dif_pos] -- Porting note: added\n    split_ifs <;> simp\n  · intro j' hj'\n    exact Finset.sum_eq_zero fun _ _ => by rw [dif_neg hj'.symm, zero_mul]\n\n"}
{"name":"Matrix.blockDiagonal'RingHom_apply","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nα : Type u_12\ninst✝⁴ : DecidableEq o\ninst✝³ : (i : o) → DecidableEq (m' i)\ninst✝² : Fintype o\ninst✝¹ : (i : o) → Fintype (m' i)\ninst✝ : NonAssocSemiring α\nM : (i : o) → Matrix (m' i) (m' i) α\n⊢ Eq ((Matrix.blockDiagonal'RingHom m' α) M) (Matrix.blockDiagonal' M)","decl":"/-- `Matrix.blockDiagonal'` as a `RingHom`. -/\n@[simps]\ndef blockDiagonal'RingHom [∀ i, DecidableEq (m' i)] [Fintype o] [∀ i, Fintype (m' i)]\n    [NonAssocSemiring α] : (∀ i, Matrix (m' i) (m' i) α) →+* Matrix (Σi, m' i) (Σi, m' i) α :=\n  { blockDiagonal'AddMonoidHom m' m' α with\n    toFun := blockDiagonal'\n    map_one' := blockDiagonal'_one\n    map_mul' := blockDiagonal'_mul }\n\n"}
{"name":"Matrix.blockDiagonal'_pow","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nα : Type u_12\ninst✝⁴ : DecidableEq o\ninst✝³ : (i : o) → DecidableEq (m' i)\ninst✝² : Fintype o\ninst✝¹ : (i : o) → Fintype (m' i)\ninst✝ : Semiring α\nM : (i : o) → Matrix (m' i) (m' i) α\nn : Nat\n⊢ Eq (Matrix.blockDiagonal' (HPow.hPow M n)) (HPow.hPow (Matrix.blockDiagonal' M) n)","decl":"@[simp]\ntheorem blockDiagonal'_pow [∀ i, DecidableEq (m' i)] [Fintype o] [∀ i, Fintype (m' i)] [Semiring α]\n    (M : ∀ i, Matrix (m' i) (m' i) α) (n : ℕ) : blockDiagonal' (M ^ n) = blockDiagonal' M ^ n :=\n  map_pow (blockDiagonal'RingHom m' α) M n\n\n"}
{"name":"Matrix.blockDiagonal'_smul","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nn' : o → Type u_8\nα : Type u_12\ninst✝³ : DecidableEq o\nR : Type u_14\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid α\ninst✝ : Module R α\nx : R\nM : (i : o) → Matrix (m' i) (n' i) α\n⊢ Eq (Matrix.blockDiagonal' (HSMul.hSMul x M)) (HSMul.hSMul x (Matrix.blockDiagonal' M))","decl":"@[simp]\ntheorem blockDiagonal'_smul {R : Type*} [Semiring R] [AddCommMonoid α] [Module R α] (x : R)\n    (M : ∀ i, Matrix (m' i) (n' i) α) : blockDiagonal' (x • M) = x • blockDiagonal' M := by\n  ext\n  simp only [blockDiagonal'_apply, Pi.smul_apply, smul_apply]\n  split_ifs <;> simp\n\n"}
{"name":"Matrix.blockDiag'_apply","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nn' : o → Type u_8\nα : Type u_12\nM : Matrix (Sigma fun i => m' i) (Sigma fun i => n' i) α\nk : o\ni : m' k\nj : n' k\n⊢ Eq (M.blockDiag' k i j) (M ⟨k, i⟩ ⟨k, j⟩)","decl":"theorem blockDiag'_apply (M : Matrix (Σi, m' i) (Σi, n' i) α) (k : o) (i j) :\n    blockDiag' M k i j = M ⟨k, i⟩ ⟨k, j⟩ :=\n  rfl\n\n"}
{"name":"Matrix.blockDiag'_map","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nn' : o → Type u_8\nα : Type u_12\nβ : Type u_13\nM : Matrix (Sigma fun i => m' i) (Sigma fun i => n' i) α\nf : α → β\n⊢ Eq (M.map f).blockDiag' fun k => (M.blockDiag' k).map f","decl":"theorem blockDiag'_map (M : Matrix (Σi, m' i) (Σi, n' i) α) (f : α → β) :\n    blockDiag' (M.map f) = fun k => (blockDiag' M k).map f :=\n  rfl\n\n"}
{"name":"Matrix.blockDiag'_transpose","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nn' : o → Type u_8\nα : Type u_12\nM : Matrix (Sigma fun i => m' i) (Sigma fun i => n' i) α\nk : o\n⊢ Eq (M.transpose.blockDiag' k) (M.blockDiag' k).transpose","decl":"@[simp]\ntheorem blockDiag'_transpose (M : Matrix (Σi, m' i) (Σi, n' i) α) (k : o) :\n    blockDiag' Mᵀ k = (blockDiag' M k)ᵀ :=\n  ext fun _ _ => rfl\n\n"}
{"name":"Matrix.blockDiag'_conjTranspose","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nn' : o → Type u_8\nα : Type u_14\ninst✝¹ : AddMonoid α\ninst✝ : StarAddMonoid α\nM : Matrix (Sigma fun i => m' i) (Sigma fun i => n' i) α\nk : o\n⊢ Eq (M.conjTranspose.blockDiag' k) (M.blockDiag' k).conjTranspose","decl":"@[simp]\ntheorem blockDiag'_conjTranspose {α : Type*} [AddMonoid α] [StarAddMonoid α]\n    (M : Matrix (Σi, m' i) (Σi, n' i) α) (k : o) : blockDiag' Mᴴ k = (blockDiag' M k)ᴴ :=\n  ext fun _ _ => rfl\n\n"}
{"name":"Matrix.blockDiag'_zero","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nn' : o → Type u_8\nα : Type u_12\ninst✝ : Zero α\n⊢ Eq (Matrix.blockDiag' 0) 0","decl":"@[simp]\ntheorem blockDiag'_zero : blockDiag' (0 : Matrix (Σi, m' i) (Σi, n' i) α) = 0 :=\n  rfl\n\n"}
{"name":"Matrix.blockDiag'_diagonal","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nα : Type u_12\ninst✝² : Zero α\ninst✝¹ : DecidableEq o\ninst✝ : (i : o) → DecidableEq (m' i)\nd : (Sigma fun i => m' i) → α\nk : o\n⊢ Eq ((Matrix.diagonal d).blockDiag' k) (Matrix.diagonal fun i => d ⟨k, i⟩)","decl":"@[simp]\ntheorem blockDiag'_diagonal [DecidableEq o] [∀ i, DecidableEq (m' i)] (d : (Σi, m' i) → α) (k : o) :\n    blockDiag' (diagonal d) k = diagonal fun i => d ⟨k, i⟩ :=\n  ext fun i j => by\n    obtain rfl | hij := Decidable.eq_or_ne i j\n    · rw [blockDiag'_apply, diagonal_apply_eq, diagonal_apply_eq]\n    · rw [blockDiag'_apply, diagonal_apply_ne _ hij, diagonal_apply_ne _ (mt (fun h => ?_) hij)]\n      cases h\n      rfl\n\n"}
{"name":"Matrix.blockDiag'_blockDiagonal'","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nn' : o → Type u_8\nα : Type u_12\ninst✝¹ : Zero α\ninst✝ : DecidableEq o\nM : (i : o) → Matrix (m' i) (n' i) α\n⊢ Eq (Matrix.blockDiagonal' M).blockDiag' M","decl":"@[simp]\ntheorem blockDiag'_blockDiagonal' [DecidableEq o] (M : ∀ i, Matrix (m' i) (n' i) α) :\n    blockDiag' (blockDiagonal' M) = M :=\n  funext fun _ => ext fun _ _ => blockDiagonal'_apply_eq M _ _ _\n\n"}
{"name":"Matrix.blockDiagonal'_injective","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nn' : o → Type u_8\nα : Type u_12\ninst✝¹ : Zero α\ninst✝ : DecidableEq o\n⊢ Function.Injective Matrix.blockDiagonal'","decl":"theorem blockDiagonal'_injective [DecidableEq o] :\n    Function.Injective (blockDiagonal' : (∀ i, Matrix (m' i) (n' i) α) → Matrix _ _ α) :=\n  Function.LeftInverse.injective blockDiag'_blockDiagonal'\n\n"}
{"name":"Matrix.blockDiagonal'_inj","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nn' : o → Type u_8\nα : Type u_12\ninst✝¹ : Zero α\ninst✝ : DecidableEq o\nM N : (i : o) → Matrix (m' i) (n' i) α\n⊢ Iff (Eq (Matrix.blockDiagonal' M) (Matrix.blockDiagonal' N)) (Eq M N)","decl":"@[simp]\ntheorem blockDiagonal'_inj [DecidableEq o] {M N : ∀ i, Matrix (m' i) (n' i) α} :\n    blockDiagonal' M = blockDiagonal' N ↔ M = N :=\n  blockDiagonal'_injective.eq_iff\n\n"}
{"name":"Matrix.blockDiag'_one","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nα : Type u_12\ninst✝³ : Zero α\ninst✝² : DecidableEq o\ninst✝¹ : (i : o) → DecidableEq (m' i)\ninst✝ : One α\n⊢ Eq (Matrix.blockDiag' 1) 1","decl":"@[simp]\ntheorem blockDiag'_one [DecidableEq o] [∀ i, DecidableEq (m' i)] [One α] :\n    blockDiag' (1 : Matrix (Σi, m' i) (Σi, m' i) α) = 1 :=\n  funext <| blockDiag'_diagonal _\n\n"}
{"name":"Matrix.blockDiag'_add","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nn' : o → Type u_8\nα : Type u_12\ninst✝ : AddZeroClass α\nM N : Matrix (Sigma fun i => m' i) (Sigma fun i => n' i) α\n⊢ Eq (HAdd.hAdd M N).blockDiag' (HAdd.hAdd M.blockDiag' N.blockDiag')","decl":"@[simp]\ntheorem blockDiag'_add [AddZeroClass α] (M N : Matrix (Σi, m' i) (Σi, n' i) α) :\n    blockDiag' (M + N) = blockDiag' M + blockDiag' N :=\n  rfl\n\n"}
{"name":"Matrix.blockDiag'AddMonoidHom_apply","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nn' : o → Type u_8\nα : Type u_12\ninst✝ : AddZeroClass α\nM : Matrix (Sigma fun i => m' i) (Sigma fun i => n' i) α\nk : o\n⊢ Eq ((Matrix.blockDiag'AddMonoidHom m' n' α) M k) (M.blockDiag' k)","decl":"/-- `Matrix.blockDiag'` as an `AddMonoidHom`. -/\n@[simps]\ndef blockDiag'AddMonoidHom [AddZeroClass α] :\n    Matrix (Σi, m' i) (Σi, n' i) α →+ ∀ i, Matrix (m' i) (n' i) α where\n  toFun := blockDiag'\n  map_zero' := blockDiag'_zero\n  map_add' := blockDiag'_add\n\n"}
{"name":"Matrix.blockDiag'_neg","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nn' : o → Type u_8\nα : Type u_12\ninst✝ : AddGroup α\nM : Matrix (Sigma fun i => m' i) (Sigma fun i => n' i) α\n⊢ Eq (Neg.neg M).blockDiag' (Neg.neg M.blockDiag')","decl":"@[simp]\ntheorem blockDiag'_neg [AddGroup α] (M : Matrix (Σi, m' i) (Σi, n' i) α) :\n    blockDiag' (-M) = -blockDiag' M :=\n  map_neg (blockDiag'AddMonoidHom m' n' α) M\n\n"}
{"name":"Matrix.blockDiag'_sub","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nn' : o → Type u_8\nα : Type u_12\ninst✝ : AddGroup α\nM N : Matrix (Sigma fun i => m' i) (Sigma fun i => n' i) α\n⊢ Eq (HSub.hSub M N).blockDiag' (HSub.hSub M.blockDiag' N.blockDiag')","decl":"@[simp]\ntheorem blockDiag'_sub [AddGroup α] (M N : Matrix (Σi, m' i) (Σi, n' i) α) :\n    blockDiag' (M - N) = blockDiag' M - blockDiag' N :=\n  map_sub (blockDiag'AddMonoidHom m' n' α) M N\n\n"}
{"name":"Matrix.blockDiag'_smul","module":"Mathlib.Data.Matrix.Block","initialProofState":"o : Type u_4\nm' : o → Type u_7\nn' : o → Type u_8\nα : Type u_12\nR : Type u_14\ninst✝² : Monoid R\ninst✝¹ : AddMonoid α\ninst✝ : DistribMulAction R α\nx : R\nM : Matrix (Sigma fun i => m' i) (Sigma fun i => n' i) α\n⊢ Eq (HSMul.hSMul x M).blockDiag' (HSMul.hSMul x M.blockDiag')","decl":"@[simp]\ntheorem blockDiag'_smul {R : Type*} [Monoid R] [AddMonoid α] [DistribMulAction R α] (x : R)\n    (M : Matrix (Σi, m' i) (Σi, n' i) α) : blockDiag' (x • M) = x • blockDiag' M :=\n  rfl\n\n"}
{"name":"Matrix.toBlock_mul_eq_mul","module":"Mathlib.Data.Matrix.Block","initialProofState":"R : Type u_10\ninst✝¹ : CommRing R\nm : Type u_14\nn : Type u_15\nk : Type u_16\ninst✝ : Fintype n\np : m → Prop\nq : k → Prop\nA : Matrix m n R\nB : Matrix n k R\n⊢ Eq ((HMul.hMul A B).toBlock p q) (HMul.hMul (A.toBlock p Top.top) (B.toBlock Top.top q))","decl":"theorem toBlock_mul_eq_mul {m n k : Type*} [Fintype n] (p : m → Prop) (q : k → Prop)\n    (A : Matrix m n R) (B : Matrix n k R) :\n    (A * B).toBlock p q = A.toBlock p ⊤ * B.toBlock ⊤ q := by\n  ext i k\n  simp only [toBlock_apply, mul_apply]\n  rw [Finset.sum_subtype]\n  simp [Pi.top_apply, Prop.top_eq_true]\n\n"}
{"name":"Matrix.toBlock_mul_eq_add","module":"Mathlib.Data.Matrix.Block","initialProofState":"R : Type u_10\ninst✝² : CommRing R\nm : Type u_14\nn : Type u_15\nk : Type u_16\ninst✝¹ : Fintype n\np : m → Prop\nq : n → Prop\ninst✝ : DecidablePred q\nr : k → Prop\nA : Matrix m n R\nB : Matrix n k R\n⊢ Eq ((HMul.hMul A B).toBlock p r) (HAdd.hAdd (HMul.hMul (A.toBlock p q) (B.toBlock q r)) (HMul.hMul (A.toBlock p fun i => Not (q i)) (B.toBlock (fun i => Not (q i)) r)))","decl":"theorem toBlock_mul_eq_add {m n k : Type*} [Fintype n] (p : m → Prop) (q : n → Prop)\n    [DecidablePred q] (r : k → Prop) (A : Matrix m n R) (B : Matrix n k R) : (A * B).toBlock p r =\n    A.toBlock p q * B.toBlock q r + (A.toBlock p fun i => ¬q i) * B.toBlock (fun i => ¬q i) r := by\n  classical\n    ext i k\n    simp only [toBlock_apply, mul_apply, Pi.add_apply]\n    exact (Fintype.sum_subtype_add_sum_subtype q fun x => A (↑i) x * B x ↑k).symm\n\n"}
{"name":"Matrix.map_toSquareBlock","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nα : Type u_15\nβ : Type u_16\nf : α → β\nM : Matrix m m α\nι : Type u_18\nb : m → ι\ni : ι\n⊢ Eq ((M.map f).toSquareBlock b i) ((M.toSquareBlock b i).map f)","decl":"lemma Matrix.map_toSquareBlock\n    (f : α → β) {M : Matrix m m α} {ι} {b : m → ι} {i : ι} :\n    (M.map f).toSquareBlock b i = (M.toSquareBlock b i).map f :=\n  submatrix_map _ _ _ _\n\n"}
{"name":"Matrix.comp_toSquareBlock","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_14\nα : Type u_15\nb : m → α\nM : Matrix m m (Matrix n n R)\na : α\n⊢ Eq (((Matrix.comp m m n n R) M).toSquareBlock (fun i => b i.1) a) ((Matrix.reindex Equiv.prodSubtypeFstEquivSubtypeProd.symm Equiv.prodSubtypeFstEquivSubtypeProd.symm) ((Matrix.comp (Subtype fun a_1 => Eq (b a_1) a) (Subtype fun a_1 => Eq (b a_1) a) n n R) (M.toSquareBlock b a)))","decl":"lemma Matrix.comp_toSquareBlock {b : m → α}\n    (M : Matrix m m (Matrix n n R)) (a : α) :\n    letI equiv := Equiv.prodSubtypeFstEquivSubtypeProd.symm\n    (M.comp m m n n R).toSquareBlock (fun i ↦ b i.1) a =\n      ((M.toSquareBlock b a).comp _ _ n n R).reindex equiv equiv :=\n  rfl\n\n"}
{"name":"Matrix.comp_diagonal","module":"Mathlib.Data.Matrix.Block","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_14\ninst✝¹ : Zero R\ninst✝ : DecidableEq m\nd : m → Matrix n n R\n⊢ Eq ((Matrix.comp m m n n R) (Matrix.diagonal d)) ((Matrix.reindex (Equiv.prodComm n m) (Equiv.prodComm n m)) (Matrix.blockDiagonal d))","decl":"lemma Matrix.comp_diagonal (d) :\n    comp m m n n R (diagonal d) =\n      (blockDiagonal d).reindex (.prodComm ..) (.prodComm ..) := by\n  ext\n  simp [diagonal, blockDiagonal, Matrix.ite_apply]\n\n"}
