{"name":"mem_perfectClosure_iff","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nx : E\n⊢ Iff (Membership.mem (perfectClosure F E) x) (Exists fun n => Membership.mem (algebraMap F E).range (HPow.hPow x (HPow.hPow (ringExpChar F) n)))","decl":"theorem mem_perfectClosure_iff {x : E} :\n    x ∈ perfectClosure F E ↔ ∃ n : ℕ, x ^ (ringExpChar F) ^ n ∈ (algebraMap F E).range := Iff.rfl\n\n"}
{"name":"mem_perfectClosure_iff_pow_mem","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\nq : Nat\ninst✝ : ExpChar F q\nx : E\n⊢ Iff (Membership.mem (perfectClosure F E) x) (Exists fun n => Membership.mem (algebraMap F E).range (HPow.hPow x (HPow.hPow q n)))","decl":"theorem mem_perfectClosure_iff_pow_mem (q : ℕ) [ExpChar F q] {x : E} :\n    x ∈ perfectClosure F E ↔ ∃ n : ℕ, x ^ q ^ n ∈ (algebraMap F E).range := by\n  rw [mem_perfectClosure_iff, ringExpChar.eq F q]\n\n"}
{"name":"mem_perfectClosure_iff_natSepDegree_eq_one","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nx : E\n⊢ Iff (Membership.mem (perfectClosure F E) x) (Eq (minpoly F x).natSepDegree 1)","decl":"/-- An element is contained in the relative perfect closure if and only if its minimal polynomial\nhas separable degree one. -/\ntheorem mem_perfectClosure_iff_natSepDegree_eq_one {x : E} :\n    x ∈ perfectClosure F E ↔ (minpoly F x).natSepDegree = 1 := by\n  rw [mem_perfectClosure_iff, minpoly.natSepDegree_eq_one_iff_pow_mem (ringExpChar F)]\n\n"}
{"name":"isPurelyInseparable_iff_perfectClosure_eq_top","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Iff (IsPurelyInseparable F E) (Eq (perfectClosure F E) Top.top)","decl":"/-- A field extension `E / F` is purely inseparable if and only if the relative perfect closure of\n`F` in `E` is equal to `E`. -/\ntheorem isPurelyInseparable_iff_perfectClosure_eq_top :\n    IsPurelyInseparable F E ↔ perfectClosure F E = ⊤ := by\n  rw [isPurelyInseparable_iff_pow_mem F (ringExpChar F)]\n  exact ⟨fun H ↦ top_unique fun x _ ↦ H x, fun H _ ↦ H.ge trivial⟩\n\n"}
{"name":"perfectClosure.isPurelyInseparable","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ IsPurelyInseparable F (Subtype fun x => Membership.mem (perfectClosure F E) x)","decl":"/-- The relative perfect closure of `F` in `E` is purely inseparable over `F`. -/\ninstance perfectClosure.isPurelyInseparable : IsPurelyInseparable F (perfectClosure F E) := by\n  rw [isPurelyInseparable_iff_pow_mem F (ringExpChar F)]\n  exact fun ⟨_, n, y, h⟩ ↦ ⟨n, y, (algebraMap _ E).injective h⟩\n\n"}
{"name":"perfectClosure.isAlgebraic","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Algebra.IsAlgebraic F (Subtype fun x => Membership.mem (perfectClosure F E) x)","decl":"/-- The relative perfect closure of `F` in `E` is algebraic over `F`. -/\ninstance perfectClosure.isAlgebraic : Algebra.IsAlgebraic F (perfectClosure F E) :=\n  IsPurelyInseparable.isAlgebraic F _\n\n"}
{"name":"perfectClosure.eq_bot_of_isSeparable","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Algebra.IsSeparable F E\n⊢ Eq (perfectClosure F E) Bot.bot","decl":"/-- If `E / F` is separable, then the perfect closure of `F` in `E` is equal to `F`. Note that\n  the converse is not necessarily true (see https://math.stackexchange.com/a/3009197)\n  even when `E / F` is algebraic. -/\ntheorem perfectClosure.eq_bot_of_isSeparable [Algebra.IsSeparable F E] : perfectClosure F E = ⊥ :=\n  haveI := Algebra.isSeparable_tower_bot_of_isSeparable F (perfectClosure F E) E\n  eq_bot_of_isPurelyInseparable_of_isSeparable _\n\n"}
{"name":"le_perfectClosure","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nL : IntermediateField F E\nh : IsPurelyInseparable F (Subtype fun x => Membership.mem L x)\n⊢ LE.le L (perfectClosure F E)","decl":"/-- An intermediate field of `E / F` is contained in the relative perfect closure of `F` in `E`\nif it is purely inseparable over `F`. -/\ntheorem le_perfectClosure (L : IntermediateField F E) [h : IsPurelyInseparable F L] :\n    L ≤ perfectClosure F E := by\n  rw [isPurelyInseparable_iff_pow_mem F (ringExpChar F)] at h\n  intro x hx\n  obtain ⟨n, y, hy⟩ := h ⟨x, hx⟩\n  exact ⟨n, y, congr_arg (algebraMap L E) hy⟩\n\n"}
{"name":"le_perfectClosure_iff","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nL : IntermediateField F E\n⊢ Iff (LE.le L (perfectClosure F E)) (IsPurelyInseparable F (Subtype fun x => Membership.mem L x))","decl":"/-- An intermediate field of `E / F` is contained in the relative perfect closure of `F` in `E`\nif and only if it is purely inseparable over `F`. -/\ntheorem le_perfectClosure_iff (L : IntermediateField F E) :\n    L ≤ perfectClosure F E ↔ IsPurelyInseparable F L := by\n  refine ⟨fun h ↦ (isPurelyInseparable_iff_pow_mem F (ringExpChar F)).2 fun x ↦ ?_,\n    fun _ ↦ le_perfectClosure F E L⟩\n  obtain ⟨n, y, hy⟩ := h x.2\n  exact ⟨n, y, (algebraMap L E).injective hy⟩\n\n"}
{"name":"separableClosure_inf_perfectClosure","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Eq (Min.min (separableClosure F E) (perfectClosure F E)) Bot.bot","decl":"theorem separableClosure_inf_perfectClosure : separableClosure F E ⊓ perfectClosure F E = ⊥ :=\n  haveI := (le_separableClosure_iff F E _).mp (inf_le_left (b := perfectClosure F E))\n  haveI := (le_perfectClosure_iff F E _).mp (inf_le_right (a := separableClosure F E))\n  eq_bot_of_isPurelyInseparable_of_isSeparable _\n\n"}
{"name":"map_mem_perfectClosure_iff","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\nK : Type w\ninst✝¹ : Field K\ninst✝ : Algebra F K\ni : AlgHom F E K\nx : E\n⊢ Iff (Membership.mem (perfectClosure F K) (i x)) (Membership.mem (perfectClosure F E) x)","decl":"/-- If `i` is an `F`-algebra homomorphism from `E` to `K`, then `i x` is contained in\n`perfectClosure F K` if and only if `x` is contained in `perfectClosure F E`. -/\ntheorem map_mem_perfectClosure_iff (i : E →ₐ[F] K) {x : E} :\n    i x ∈ perfectClosure F K ↔ x ∈ perfectClosure F E := by\n  simp_rw [mem_perfectClosure_iff]\n  refine ⟨fun ⟨n, y, h⟩ ↦ ⟨n, y, ?_⟩, fun ⟨n, y, h⟩ ↦ ⟨n, y, ?_⟩⟩\n  · apply_fun i using i.injective\n    rwa [AlgHom.commutes, map_pow]\n  simpa only [AlgHom.commutes, map_pow] using congr_arg i h\n\n"}
{"name":"perfectClosure.comap_eq_of_algHom","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\nK : Type w\ninst✝¹ : Field K\ninst✝ : Algebra F K\ni : AlgHom F E K\n⊢ Eq (IntermediateField.comap i (perfectClosure F K)) (perfectClosure F E)","decl":"/-- If `i` is an `F`-algebra homomorphism from `E` to `K`, then the preimage of `perfectClosure F K`\nunder the map `i` is equal to `perfectClosure F E`. -/\ntheorem perfectClosure.comap_eq_of_algHom (i : E →ₐ[F] K) :\n    (perfectClosure F K).comap i = perfectClosure F E := by\n  ext x\n  exact map_mem_perfectClosure_iff i\n\n"}
{"name":"perfectClosure.map_le_of_algHom","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\nK : Type w\ninst✝¹ : Field K\ninst✝ : Algebra F K\ni : AlgHom F E K\n⊢ LE.le (IntermediateField.map i (perfectClosure F E)) (perfectClosure F K)","decl":"/-- If `i` is an `F`-algebra homomorphism from `E` to `K`, then the image of `perfectClosure F E`\nunder the map `i` is contained in `perfectClosure F K`. -/\ntheorem perfectClosure.map_le_of_algHom (i : E →ₐ[F] K) :\n    (perfectClosure F E).map i ≤ perfectClosure F K :=\n  map_le_iff_le_comap.mpr (perfectClosure.comap_eq_of_algHom i).ge\n\n"}
{"name":"perfectClosure.map_eq_of_algEquiv","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\nK : Type w\ninst✝¹ : Field K\ninst✝ : Algebra F K\ni : AlgEquiv F E K\n⊢ Eq (IntermediateField.map (↑i) (perfectClosure F E)) (perfectClosure F K)","decl":"/-- If `i` is an `F`-algebra isomorphism of `E` and `K`, then the image of `perfectClosure F E`\nunder the map `i` is equal to in `perfectClosure F K`. -/\ntheorem perfectClosure.map_eq_of_algEquiv (i : E ≃ₐ[F] K) :\n    (perfectClosure F E).map i.toAlgHom = perfectClosure F K :=\n  (map_le_of_algHom i.toAlgHom).antisymm (fun x hx ↦ ⟨i.symm x,\n    (map_mem_perfectClosure_iff i.symm.toAlgHom).2 hx, i.right_inv x⟩)\n\n"}
{"name":"perfectClosure.perfectRing","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\np : Nat\ninst✝¹ : ExpChar E p\ninst✝ : PerfectRing E p\n⊢ PerfectRing (Subtype fun x => Membership.mem (perfectClosure F E) x) p","decl":"/-- If `E` is a perfect field of exponential characteristic `p`, then the (relative) perfect closure\n`perfectClosure F E` is perfect. -/\ninstance perfectClosure.perfectRing (p : ℕ) [ExpChar E p]\n    [PerfectRing E p] : PerfectRing (perfectClosure F E) p := .ofSurjective _ p fun x ↦ by\n  haveI := RingHom.expChar _ (algebraMap F E).injective p\n  obtain ⟨x', hx⟩ := surjective_frobenius E p x.1\n  obtain ⟨n, y, hy⟩ := (mem_perfectClosure_iff_pow_mem p).1 x.2\n  rw [frobenius_def] at hx\n  rw [← hx, ← pow_mul, ← pow_succ'] at hy\n  exact ⟨⟨x', (mem_perfectClosure_iff_pow_mem p).2 ⟨n + 1, y, hy⟩⟩, by\n    simp_rw [frobenius_def, SubmonoidClass.mk_pow, hx]⟩\n\n"}
{"name":"perfectClosure.perfectField","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : PerfectField E\n⊢ PerfectField (Subtype fun x => Membership.mem (perfectClosure F E) x)","decl":"/-- If `E` is a perfect field, then the (relative) perfect closure\n`perfectClosure F E` is perfect. -/\ninstance perfectClosure.perfectField [PerfectField E] : PerfectField (perfectClosure F E) :=\n  PerfectRing.toPerfectField _ (ringExpChar E)\n\n"}
{"name":"IntermediateField.isPurelyInseparable_adjoin_simple_iff_natSepDegree_eq_one","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nx : E\n⊢ Iff (IsPurelyInseparable F (Subtype fun x_1 => Membership.mem (IntermediateField.adjoin F (Singleton.singleton x)) x_1)) (Eq (minpoly F x).natSepDegree 1)","decl":"/-- `F⟮x⟯ / F` is a purely inseparable extension if and only if the minimal polynomial of `x`\nhas separable degree one. -/\ntheorem isPurelyInseparable_adjoin_simple_iff_natSepDegree_eq_one {x : E} :\n    IsPurelyInseparable F F⟮x⟯ ↔ (minpoly F x).natSepDegree = 1 := by\n  rw [← le_perfectClosure_iff, adjoin_simple_le_iff, mem_perfectClosure_iff_natSepDegree_eq_one]\n\n"}
{"name":"IntermediateField.isPurelyInseparable_adjoin_simple_iff_pow_mem","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nq : Nat\nhF : ExpChar F q\nx : E\n⊢ Iff (IsPurelyInseparable F (Subtype fun x_1 => Membership.mem (IntermediateField.adjoin F (Singleton.singleton x)) x_1)) (Exists fun n => Membership.mem (algebraMap F E).range (HPow.hPow x (HPow.hPow q n)))","decl":"/-- If `F` is of exponential characteristic `q`, then `F⟮x⟯ / F` is a purely inseparable extension\nif and only if `x ^ (q ^ n)` is contained in `F` for some `n : ℕ`. -/\ntheorem isPurelyInseparable_adjoin_simple_iff_pow_mem (q : ℕ) [hF : ExpChar F q] {x : E} :\n    IsPurelyInseparable F F⟮x⟯ ↔ ∃ n : ℕ, x ^ q ^ n ∈ (algebraMap F E).range := by\n  rw [← le_perfectClosure_iff, adjoin_simple_le_iff, mem_perfectClosure_iff_pow_mem q]\n\n"}
{"name":"IntermediateField.isPurelyInseparable_adjoin_iff_pow_mem","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nq : Nat\nhF : ExpChar F q\nS : Set E\n⊢ Iff (IsPurelyInseparable F (Subtype fun x => Membership.mem (IntermediateField.adjoin F S) x)) (∀ (x : E), Membership.mem S x → Exists fun n => Membership.mem (algebraMap F E).range (HPow.hPow x (HPow.hPow q n)))","decl":"/-- If `F` is of exponential characteristic `q`, then `F(S) / F` is a purely inseparable extension\nif and only if for any `x ∈ S`, `x ^ (q ^ n)` is contained in `F` for some `n : ℕ`. -/\ntheorem isPurelyInseparable_adjoin_iff_pow_mem (q : ℕ) [hF : ExpChar F q] {S : Set E} :\n    IsPurelyInseparable F (adjoin F S) ↔ ∀ x ∈ S, ∃ n : ℕ, x ^ q ^ n ∈ (algebraMap F E).range := by\n  simp_rw [← le_perfectClosure_iff, adjoin_le_iff, ← mem_perfectClosure_iff_pow_mem q,\n    Set.subset_def, SetLike.mem_coe]\n\n"}
{"name":"IntermediateField.isPurelyInseparable_sup","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nL1 L2 : IntermediateField F E\nh1 : IsPurelyInseparable F (Subtype fun x => Membership.mem L1 x)\nh2 : IsPurelyInseparable F (Subtype fun x => Membership.mem L2 x)\n⊢ IsPurelyInseparable F (Subtype fun x => Membership.mem (Max.max L1 L2) x)","decl":"/-- A compositum of two purely inseparable extensions is purely inseparable. -/\ninstance isPurelyInseparable_sup (L1 L2 : IntermediateField F E)\n    [h1 : IsPurelyInseparable F L1] [h2 : IsPurelyInseparable F L2] :\n    IsPurelyInseparable F (L1 ⊔ L2 : IntermediateField F E) := by\n  rw [← le_perfectClosure_iff] at h1 h2 ⊢\n  exact sup_le h1 h2\n\n"}
{"name":"IntermediateField.isPurelyInseparable_iSup","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nι : Sort u_1\nt : ι → IntermediateField F E\nh : ∀ (i : ι), IsPurelyInseparable F (Subtype fun x => Membership.mem (t i) x)\n⊢ IsPurelyInseparable F (Subtype fun x => Membership.mem (iSup fun i => t i) x)","decl":"/-- A compositum of purely inseparable extensions is purely inseparable. -/\ninstance isPurelyInseparable_iSup {ι : Sort*} {t : ι → IntermediateField F E}\n    [h : ∀ i, IsPurelyInseparable F (t i)] :\n    IsPurelyInseparable F (⨆ i, t i : IntermediateField F E) := by\n  simp_rw [← le_perfectClosure_iff] at h ⊢\n  exact iSup_le h\n\n"}
{"name":"IntermediateField.adjoin_eq_adjoin_pow_expChar_pow_of_isSeparable","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\nS : Set E\ninst✝¹ : Algebra.IsSeparable F (Subtype fun x => Membership.mem (IntermediateField.adjoin F S) x)\nq : Nat\ninst✝ : ExpChar F q\nn : Nat\n⊢ Eq (IntermediateField.adjoin F S) (IntermediateField.adjoin F (Set.image (fun x => HPow.hPow x (HPow.hPow q n)) S))","decl":"/-- If `F` is a field of exponential characteristic `q`, `F(S) / F` is separable, then\n`F(S) = F(S ^ (q ^ n))` for any natural number `n`. -/\ntheorem adjoin_eq_adjoin_pow_expChar_pow_of_isSeparable (S : Set E)\n    [Algebra.IsSeparable F (adjoin F S)] (q : ℕ) [ExpChar F q] (n : ℕ) :\n    adjoin F S = adjoin F ((· ^ q ^ n) '' S) := by\n  set L := adjoin F S\n  set M := adjoin F ((· ^ q ^ n) '' S)\n  have hi : M ≤ L := by\n    rw [adjoin_le_iff]\n    rintro _ ⟨y, hy, rfl⟩\n    exact pow_mem (subset_adjoin F S hy) _\n  letI := (inclusion hi).toAlgebra\n  haveI : Algebra.IsSeparable M (extendScalars hi) :=\n    Algebra.isSeparable_tower_top_of_isSeparable F M L\n  haveI : IsPurelyInseparable M (extendScalars hi) := by\n    haveI := expChar_of_injective_algebraMap (algebraMap F M).injective q\n    rw [extendScalars_adjoin hi, isPurelyInseparable_adjoin_iff_pow_mem M _ q]\n    exact fun x hx ↦ ⟨n, ⟨x ^ q ^ n, subset_adjoin F _ ⟨x, hx, rfl⟩⟩, rfl⟩\n  simpa only [extendScalars_restrictScalars, restrictScalars_bot_eq_self] using congr_arg\n    (restrictScalars F) (extendScalars hi).eq_bot_of_isPurelyInseparable_of_isSeparable\n\n"}
{"name":"IntermediateField.adjoin_eq_adjoin_pow_expChar_pow_of_isSeparable'","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\ninst✝¹ : Algebra.IsSeparable F E\nS : Set E\nq : Nat\ninst✝ : ExpChar F q\nn : Nat\n⊢ Eq (IntermediateField.adjoin F S) (IntermediateField.adjoin F (Set.image (fun x => HPow.hPow x (HPow.hPow q n)) S))","decl":"/-- If `E / F` is a separable field extension of exponential characteristic `q`, then\n`F(S) = F(S ^ (q ^ n))` for any subset `S` of `E` and any natural number `n`. -/\ntheorem adjoin_eq_adjoin_pow_expChar_pow_of_isSeparable' [Algebra.IsSeparable F E] (S : Set E)\n    (q : ℕ) [ExpChar F q] (n : ℕ) : adjoin F S = adjoin F ((· ^ q ^ n) '' S) :=\n  haveI := Algebra.isSeparable_tower_bot_of_isSeparable F (adjoin F S) E\n  adjoin_eq_adjoin_pow_expChar_pow_of_isSeparable F E S q n\n\n-- TODO: prove the converse when `F(S) / F` is finite\n"}
{"name":"IntermediateField.adjoin_eq_adjoin_pow_expChar_of_isSeparable","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\nS : Set E\ninst✝¹ : Algebra.IsSeparable F (Subtype fun x => Membership.mem (IntermediateField.adjoin F S) x)\nq : Nat\ninst✝ : ExpChar F q\n⊢ Eq (IntermediateField.adjoin F S) (IntermediateField.adjoin F (Set.image (fun x => HPow.hPow x q) S))","decl":"/-- If `F` is a field of exponential characteristic `q`, `F(S) / F` is separable, then\n`F(S) = F(S ^ q)`. -/\ntheorem adjoin_eq_adjoin_pow_expChar_of_isSeparable (S : Set E) [Algebra.IsSeparable F (adjoin F S)]\n    (q : ℕ) [ExpChar F q] : adjoin F S = adjoin F ((· ^ q) '' S) :=\n  pow_one q ▸ adjoin_eq_adjoin_pow_expChar_pow_of_isSeparable F E S q 1\n\n"}
{"name":"IntermediateField.adjoin_eq_adjoin_pow_expChar_of_isSeparable'","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\ninst✝¹ : Algebra.IsSeparable F E\nS : Set E\nq : Nat\ninst✝ : ExpChar F q\n⊢ Eq (IntermediateField.adjoin F S) (IntermediateField.adjoin F (Set.image (fun x => HPow.hPow x q) S))","decl":"/-- If `E / F` is a separable field extension of exponential characteristic `q`, then\n`F(S) = F(S ^ q)` for any subset `S` of `E`. -/\ntheorem adjoin_eq_adjoin_pow_expChar_of_isSeparable' [Algebra.IsSeparable F E] (S : Set E)\n    (q : ℕ) [ExpChar F q] : adjoin F S = adjoin F ((· ^ q) '' S) :=\n  pow_one q ▸ adjoin_eq_adjoin_pow_expChar_pow_of_isSeparable' F E S q 1\n\n-- Special cases for simple adjoin\n\n"}
{"name":"IntermediateField.adjoin_simple_eq_adjoin_pow_expChar_pow_of_isSeparable","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\na : E\nha : IsSeparable F a\nq : Nat\ninst✝ : ExpChar F q\nn : Nat\n⊢ Eq (IntermediateField.adjoin F (Singleton.singleton a)) (IntermediateField.adjoin F (Singleton.singleton (HPow.hPow a (HPow.hPow q n))))","decl":"/-- If `F` is a field of exponential characteristic `q`, `a : E` is separable over `F`, then\n`F⟮a⟯ = F⟮a ^ q ^ n⟯` for any natural number `n`. -/\ntheorem adjoin_simple_eq_adjoin_pow_expChar_pow_of_isSeparable {a : E} (ha : IsSeparable F a)\n    (q : ℕ) [ExpChar F q] (n : ℕ) : F⟮a⟯ = F⟮a ^ q ^ n⟯ := by\n  haveI := (isSeparable_adjoin_simple_iff_isSeparable F E).mpr ha\n  simpa using adjoin_eq_adjoin_pow_expChar_pow_of_isSeparable F E {a} q n\n\n"}
{"name":"IntermediateField.adjoin_simple_eq_adjoin_pow_expChar_pow_of_isSeparable'","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\ninst✝¹ : Algebra.IsSeparable F E\na : E\nq : Nat\ninst✝ : ExpChar F q\nn : Nat\n⊢ Eq (IntermediateField.adjoin F (Singleton.singleton a)) (IntermediateField.adjoin F (Singleton.singleton (HPow.hPow a (HPow.hPow q n))))","decl":"/-- If `E / F` is a separable field extension of exponential characteristic `q`, then\n`F⟮a⟯ = F⟮a ^ q ^ n⟯` for any subset `a : E` and any natural number `n`. -/\ntheorem adjoin_simple_eq_adjoin_pow_expChar_pow_of_isSeparable' [Algebra.IsSeparable F E] (a : E)\n    (q : ℕ) [ExpChar F q] (n : ℕ) : F⟮a⟯ = F⟮a ^ q ^ n⟯ := by\n  haveI := Algebra.isSeparable_tower_bot_of_isSeparable F F⟮a⟯ E\n  simpa using adjoin_eq_adjoin_pow_expChar_pow_of_isSeparable F E {a} q n\n\n"}
{"name":"IntermediateField.adjoin_simple_eq_adjoin_pow_expChar_of_isSeparable","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\na : E\nha : IsSeparable F a\nq : Nat\ninst✝ : ExpChar F q\n⊢ Eq (IntermediateField.adjoin F (Singleton.singleton a)) (IntermediateField.adjoin F (Singleton.singleton (HPow.hPow a q)))","decl":"/-- If `F` is a field of exponential characteristic `q`, `a : E` is separable over `F`, then\n`F⟮a⟯ = F⟮a ^ q⟯`. -/\ntheorem adjoin_simple_eq_adjoin_pow_expChar_of_isSeparable {a : E} (ha : IsSeparable F a)\n    (q : ℕ) [ExpChar F q] : F⟮a⟯ = F⟮a ^ q⟯ :=\n  pow_one q ▸ adjoin_simple_eq_adjoin_pow_expChar_pow_of_isSeparable F E ha q 1\n\n"}
{"name":"IntermediateField.adjoin_simple_eq_adjoin_pow_expChar_of_isSeparable'","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\ninst✝¹ : Algebra.IsSeparable F E\na : E\nq : Nat\ninst✝ : ExpChar F q\n⊢ Eq (IntermediateField.adjoin F (Singleton.singleton a)) (IntermediateField.adjoin F (Singleton.singleton (HPow.hPow a q)))","decl":"/-- If `E / F` is a separable field extension of exponential characteristic `q`, then\n`F⟮a⟯ = F⟮a ^ q⟯` for any `a : E`. -/\ntheorem adjoin_simple_eq_adjoin_pow_expChar_of_isSeparable' [Algebra.IsSeparable F E] (a : E)\n    (q : ℕ) [ExpChar F q] : F⟮a⟯ = F⟮a ^ q⟯ :=\n  pow_one q ▸ adjoin_simple_eq_adjoin_pow_expChar_pow_of_isSeparable' F E a q 1\n\n"}
{"name":"Field.span_map_pow_expChar_pow_eq_top_of_isSeparable","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\nq n : Nat\nhF : ExpChar F q\nι : Type u_1\nv : ι → E\ninst✝ : Algebra.IsSeparable F E\nh : Eq (Submodule.span F (Set.range v)) Top.top\n⊢ Eq (Submodule.span F (Set.range fun x => HPow.hPow (v x) (HPow.hPow q n))) Top.top","decl":"/-- If `E / F` is a separable extension of exponential characteristic `q`, if `{ u_i }` is a family\nof elements of `E` which `F`-linearly spans `E`, then `{ u_i ^ (q ^ n) }` also `F`-linearly spans\n`E` for any natural number `n`. -/\ntheorem Field.span_map_pow_expChar_pow_eq_top_of_isSeparable [Algebra.IsSeparable F E]\n    (h : Submodule.span F (Set.range v) = ⊤) :\n    Submodule.span F (Set.range (v · ^ q ^ n)) = ⊤ := by\n  erw [← Algebra.top_toSubmodule, ← top_toSubalgebra, ← adjoin_univ,\n    adjoin_eq_adjoin_pow_expChar_pow_of_isSeparable' F E _ q n,\n    adjoin_algebraic_toSubalgebra fun x _ ↦ Algebra.IsAlgebraic.isAlgebraic x,\n    Set.image_univ, Algebra.adjoin_eq_span, (powMonoidHom _).mrange.closure_eq]\n  refine (Submodule.span_mono <| Set.range_comp_subset_range _ _).antisymm (Submodule.span_le.2 ?_)\n  rw [Set.range_comp, ← Set.image_univ]\n  haveI := expChar_of_injective_algebraMap (algebraMap F E).injective q\n  apply h ▸ Submodule.image_span_subset_span (LinearMap.iterateFrobenius F E q n) _\n\n"}
{"name":"LinearIndependent.map_pow_expChar_pow_of_isSeparable","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\nq n : Nat\nhF : ExpChar F q\nι : Type u_1\nv : ι → E\ninst✝ : Algebra.IsSeparable F E\nh : LinearIndependent F v\n⊢ LinearIndependent F fun x => HPow.hPow (v x) (HPow.hPow q n)","decl":"/-- If `E / F` is a separable extension of exponential characteristic `q`, if `{ u_i }` is a\nfamily of elements of `E` which is `F`-linearly independent, then `{ u_i ^ (q ^ n) }` is also\n`F`-linearly independent for any natural number `n`. -/\ntheorem LinearIndependent.map_pow_expChar_pow_of_isSeparable [Algebra.IsSeparable F E]\n    (h : LinearIndependent F v) : LinearIndependent F (v · ^ q ^ n) := by\n  classical\n  have halg := Algebra.IsSeparable.isAlgebraic F E\n  rw [linearIndependent_iff_finset_linearIndependent] at h ⊢\n  intro s\n  let E' := adjoin F (s.image v : Set E)\n  haveI : FiniteDimensional F E' := finiteDimensional_adjoin\n    fun x _ ↦ Algebra.IsIntegral.isIntegral x\n  haveI : Algebra.IsSeparable F E' := Algebra.isSeparable_tower_bot_of_isSeparable F E' E\n  let v' (i : s) : E' := ⟨v i.1, subset_adjoin F _ (Finset.mem_image.2 ⟨i.1, i.2, rfl⟩)⟩\n  have h' : LinearIndependent F v' := (h s).of_comp E'.val.toLinearMap\n  exact (h'.map_pow_expChar_pow_of_fd_isSeparable q n).map'\n    E'.val.toLinearMap (LinearMap.ker_eq_bot_of_injective E'.val.injective)\n\n"}
{"name":"LinearIndependent.map_pow_expChar_pow_of_isSeparable'","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nq n : Nat\nhF : ExpChar F q\nι : Type u_1\nv : ι → E\nhsep : ∀ (i : ι), IsSeparable F (v i)\nh : LinearIndependent F v\n⊢ LinearIndependent F fun x => HPow.hPow (v x) (HPow.hPow q n)","decl":"/-- If `E / F` is a field extension of exponential characteristic `q`, if `{ u_i }` is a\nfamily of separable elements of `E` which is `F`-linearly independent, then `{ u_i ^ (q ^ n) }`\nis also `F`-linearly independent for any natural number `n`. -/\ntheorem LinearIndependent.map_pow_expChar_pow_of_isSeparable'\n    (hsep : ∀ i : ι, IsSeparable F (v i))\n    (h : LinearIndependent F v) : LinearIndependent F (v · ^ q ^ n) := by\n  let E' := adjoin F (Set.range v)\n  haveI : Algebra.IsSeparable F E' := (isSeparable_adjoin_iff_isSeparable F _).2 <| by\n    rintro _ ⟨y, rfl⟩; exact hsep y\n  let v' (i : ι) : E' := ⟨v i, subset_adjoin F _ ⟨i, rfl⟩⟩\n  have h' : LinearIndependent F v' := h.of_comp E'.val.toLinearMap\n  exact (h'.map_pow_expChar_pow_of_isSeparable q n).map'\n    E'.val.toLinearMap (LinearMap.ker_eq_bot_of_injective E'.val.injective)\n\n"}
{"name":"perfectField_of_perfectClosure_eq_bot","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nh : PerfectField E\neq : Eq (perfectClosure F E) Bot.bot\n⊢ PerfectField F","decl":"theorem perfectField_of_perfectClosure_eq_bot [h : PerfectField E] (eq : perfectClosure F E = ⊥) :\n    PerfectField F := by\n  let p := ringExpChar F\n  haveI := expChar_of_injective_algebraMap (algebraMap F E).injective p\n  haveI := PerfectRing.ofSurjective F p fun x ↦ by\n    obtain ⟨y, h⟩ := surjective_frobenius E p (algebraMap F E x)\n    have : y ∈ perfectClosure F E := ⟨1, x, by rw [← h, pow_one, frobenius_def, ringExpChar.eq F p]⟩\n    obtain ⟨z, rfl⟩ := eq ▸ this\n    exact ⟨z, (algebraMap F E).injective (by erw [RingHom.map_frobenius, h])⟩\n  exact PerfectRing.toPerfectField F p\n\n"}
{"name":"perfectField_of_isSeparable_of_perfectField_top","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\ninst✝¹ : Algebra.IsSeparable F E\ninst✝ : PerfectField E\n⊢ PerfectField F","decl":"/-- If `E / F` is a separable extension, `E` is perfect, then `F` is also prefect. -/\ntheorem perfectField_of_isSeparable_of_perfectField_top [Algebra.IsSeparable F E] [PerfectField E] :\n    PerfectField F :=\n  perfectField_of_perfectClosure_eq_bot F E (perfectClosure.eq_bot_of_isSeparable F E)\n\n"}
{"name":"perfectField_iff_isSeparable_algebraicClosure","module":"Mathlib.FieldTheory.PurelyInseparable.PerfectClosure","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : IsAlgClosure F E\n⊢ Iff (PerfectField F) (Algebra.IsSeparable F E)","decl":"/-- If `E` is an algebraic closure of `F`, then `F` is perfect if and only if `E / F` is\nseparable. -/\ntheorem perfectField_iff_isSeparable_algebraicClosure [IsAlgClosure F E] :\n    PerfectField F ↔ Algebra.IsSeparable F E :=\n  ⟨fun _ ↦ IsSepClosure.separable, fun _ ↦ haveI : IsAlgClosed E := IsAlgClosure.isAlgClosed F\n    perfectField_of_isSeparable_of_perfectField_top F E⟩\n"}
