{"name":"Turing.FinTM2.mk.inj","module":"Mathlib.Computability.TMComputable","initialProofState":"K✝ : Type\nkDecidableEq✝ : DecidableEq K✝\nkFin✝ : Fintype K✝\nk₀✝ k₁✝ : K✝\nΓ✝ : K✝ → Type\nΛ✝ : Type\nmain✝ : Λ✝\nΛFin✝ : Fintype Λ✝\nσ✝ : Type\ninitialState✝ : σ✝\nσFin✝ : Fintype σ✝\nΓk₀Fin✝ : Fintype (Γ✝ k₀✝)\nm✝ : Λ✝ → Turing.TM2.Stmt Γ✝ Λ✝ σ✝\nK : Type\nkDecidableEq : DecidableEq K\nkFin : Fintype K\nk₀ k₁ : K\nΓ : K → Type\nΛ : Type\nmain : Λ\nΛFin : Fintype Λ\nσ : Type\ninitialState : σ\nσFin : Fintype σ\nΓk₀Fin : Fintype (Γ k₀)\nm : Λ → Turing.TM2.Stmt Γ Λ σ\nx✝ : Eq (Turing.FinTM2.mk k₀✝ k₁✝ Γ✝ Λ✝ main✝ σ✝ initialState✝ m✝) (Turing.FinTM2.mk k₀ k₁ Γ Λ main σ initialState m)\n⊢ And (Eq K✝ K) (And (HEq kDecidableEq✝ kDecidableEq) (And (HEq kFin✝ kFin) (And (HEq k₀✝ k₀) (And (HEq k₁✝ k₁) (And (HEq Γ✝ Γ) (And (Eq Λ✝ Λ) (And (HEq main✝ main) (And (HEq ΛFin✝ ΛFin) (And (Eq σ✝ σ) (And (HEq initialState✝ initialState) (And (HEq σFin✝ σFin) (And (HEq Γk₀Fin✝ Γk₀Fin) (HEq m✝ m)))))))))))))","decl":"/-- A bundled TM2 (an equivalent of the classical Turing machine, defined starting from\nthe namespace `Turing.TM2` in `TuringMachine.lean`), with an input and output stack,\na main function, an initial state and some finiteness guarantees. -/\nstructure FinTM2 where\n  /-- index type of stacks -/\n  {K : Type} [kDecidableEq : DecidableEq K]\n  /-- A TM2 machine has finitely many stacks. -/\n  [kFin : Fintype K]\n  /-- input resp. output stack -/\n  (k₀ k₁ : K)\n  /-- type of stack elements -/\n  (Γ : K → Type)\n  /-- type of function labels -/\n  (Λ : Type)\n  /-- a main function: the initial function that is executed, given by its label -/\n  (main : Λ)\n  /-- A TM2 machine has finitely many function labels. -/\n  [ΛFin : Fintype Λ]\n  /-- type of states of the machine -/\n  (σ : Type)\n  /-- the initial state of the machine -/\n  (initialState : σ)\n  /-- a TM2 machine has finitely many internal states. -/\n  [σFin : Fintype σ]\n  /-- Each internal stack is finite. -/\n  [Γk₀Fin : Fintype (Γ k₀)]\n  /-- the program itself, i.e. one function for every function label -/\n  (m : Λ → Turing.TM2.Stmt Γ Λ σ)\n\n"}
{"name":"Turing.FinTM2.mk.injEq","module":"Mathlib.Computability.TMComputable","initialProofState":"K✝ : Type\nkDecidableEq✝ : DecidableEq K✝\nkFin✝ : Fintype K✝\nk₀✝ k₁✝ : K✝\nΓ✝ : K✝ → Type\nΛ✝ : Type\nmain✝ : Λ✝\nΛFin✝ : Fintype Λ✝\nσ✝ : Type\ninitialState✝ : σ✝\nσFin✝ : Fintype σ✝\nΓk₀Fin✝ : Fintype (Γ✝ k₀✝)\nm✝ : Λ✝ → Turing.TM2.Stmt Γ✝ Λ✝ σ✝\nK : Type\nkDecidableEq : DecidableEq K\nkFin : Fintype K\nk₀ k₁ : K\nΓ : K → Type\nΛ : Type\nmain : Λ\nΛFin : Fintype Λ\nσ : Type\ninitialState : σ\nσFin : Fintype σ\nΓk₀Fin : Fintype (Γ k₀)\nm : Λ → Turing.TM2.Stmt Γ Λ σ\n⊢ Eq (Eq (Turing.FinTM2.mk k₀✝ k₁✝ Γ✝ Λ✝ main✝ σ✝ initialState✝ m✝) (Turing.FinTM2.mk k₀ k₁ Γ Λ main σ initialState m)) (And (Eq K✝ K) (And (HEq kDecidableEq✝ kDecidableEq) (And (HEq kFin✝ kFin) (And (HEq k₀✝ k₀) (And (HEq k₁✝ k₁) (And (HEq Γ✝ Γ) (And (Eq Λ✝ Λ) (And (HEq main✝ main) (And (HEq ΛFin✝ ΛFin) (And (Eq σ✝ σ) (And (HEq initialState✝ initialState) (And (HEq σFin✝ σFin) (And (HEq Γk₀Fin✝ Γk₀Fin) (HEq m✝ m))))))))))))))","decl":"/-- A bundled TM2 (an equivalent of the classical Turing machine, defined starting from\nthe namespace `Turing.TM2` in `TuringMachine.lean`), with an input and output stack,\na main function, an initial state and some finiteness guarantees. -/\nstructure FinTM2 where\n  /-- index type of stacks -/\n  {K : Type} [kDecidableEq : DecidableEq K]\n  /-- A TM2 machine has finitely many stacks. -/\n  [kFin : Fintype K]\n  /-- input resp. output stack -/\n  (k₀ k₁ : K)\n  /-- type of stack elements -/\n  (Γ : K → Type)\n  /-- type of function labels -/\n  (Λ : Type)\n  /-- a main function: the initial function that is executed, given by its label -/\n  (main : Λ)\n  /-- A TM2 machine has finitely many function labels. -/\n  [ΛFin : Fintype Λ]\n  /-- type of states of the machine -/\n  (σ : Type)\n  /-- the initial state of the machine -/\n  (initialState : σ)\n  /-- a TM2 machine has finitely many internal states. -/\n  [σFin : Fintype σ]\n  /-- Each internal stack is finite. -/\n  [Γk₀Fin : Fintype (Γ k₀)]\n  /-- the program itself, i.e. one function for every function label -/\n  (m : Λ → Turing.TM2.Stmt Γ Λ σ)\n\n"}
{"name":"Turing.FinTM2.mk.sizeOf_spec","module":"Mathlib.Computability.TMComputable","initialProofState":"K : Type\nkDecidableEq : DecidableEq K\nkFin : Fintype K\nk₀ k₁ : K\nΓ : K → Type\nΛ : Type\nmain : Λ\nΛFin : Fintype Λ\nσ : Type\ninitialState : σ\nσFin : Fintype σ\nΓk₀Fin : Fintype (Γ k₀)\nm : Λ → Turing.TM2.Stmt Γ Λ σ\n⊢ Eq (SizeOf.sizeOf (Turing.FinTM2.mk k₀ k₁ Γ Λ main σ initialState m)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf K)) (SizeOf.sizeOf kFin)) (SizeOf.sizeOf k₀)) (SizeOf.sizeOf k₁)) (SizeOf.sizeOf Λ)) (SizeOf.sizeOf main)) (SizeOf.sizeOf ΛFin)) (SizeOf.sizeOf σ)) (SizeOf.sizeOf initialState)) (SizeOf.sizeOf σFin)) (SizeOf.sizeOf Γk₀Fin))","decl":"/-- A bundled TM2 (an equivalent of the classical Turing machine, defined starting from\nthe namespace `Turing.TM2` in `TuringMachine.lean`), with an input and output stack,\na main function, an initial state and some finiteness guarantees. -/\nstructure FinTM2 where\n  /-- index type of stacks -/\n  {K : Type} [kDecidableEq : DecidableEq K]\n  /-- A TM2 machine has finitely many stacks. -/\n  [kFin : Fintype K]\n  /-- input resp. output stack -/\n  (k₀ k₁ : K)\n  /-- type of stack elements -/\n  (Γ : K → Type)\n  /-- type of function labels -/\n  (Λ : Type)\n  /-- a main function: the initial function that is executed, given by its label -/\n  (main : Λ)\n  /-- A TM2 machine has finitely many function labels. -/\n  [ΛFin : Fintype Λ]\n  /-- type of states of the machine -/\n  (σ : Type)\n  /-- the initial state of the machine -/\n  (initialState : σ)\n  /-- a TM2 machine has finitely many internal states. -/\n  [σFin : Fintype σ]\n  /-- Each internal stack is finite. -/\n  [Γk₀Fin : Fintype (Γ k₀)]\n  /-- the program itself, i.e. one function for every function label -/\n  (m : Λ → Turing.TM2.Stmt Γ Λ σ)\n\n"}
{"name":"Turing.EvalsTo.evals_in_steps","module":"Mathlib.Computability.TMComputable","initialProofState":"σ : Type u_1\nf : σ → Option σ\na : σ\nb : Option σ\nself : Turing.EvalsTo f a b\n⊢ Eq (Nat.iterate (flip Bind.bind f) self.steps (Option.some a)) b","decl":"/-- A \"proof\" of the fact that `f` eventually reaches `b` when repeatedly evaluated on `a`,\nremembering the number of steps it takes. -/\nstructure EvalsTo {σ : Type*} (f : σ → Option σ) (a : σ) (b : Option σ) where\n  /-- number of steps taken -/\n  steps : ℕ\n  evals_in_steps : (flip bind f)^[steps] a = b\n\n-- note: this cannot currently be used in `calc`, as the last two arguments must be `a` and `b`.\n-- If this is desired, this argument order can be changed, but this spelling is I think the most\n-- natural, so there is a trade-off that needs to be made here. A notation can get around this.\n"}
{"name":"Turing.EvalsTo.mk.inj","module":"Mathlib.Computability.TMComputable","initialProofState":"σ : Type u_1\nf : σ → Option σ\na : σ\nb : Option σ\nsteps✝ : Nat\nevals_in_steps✝ : Eq (Nat.iterate (flip Bind.bind f) steps✝ (Option.some a)) b\nsteps : Nat\nevals_in_steps : Eq (Nat.iterate (flip Bind.bind f) steps (Option.some a)) b\nx✝ : Eq { steps := steps✝, evals_in_steps := evals_in_steps✝ } { steps := steps, evals_in_steps := evals_in_steps }\n⊢ Eq steps✝ steps","decl":"/-- A \"proof\" of the fact that `f` eventually reaches `b` when repeatedly evaluated on `a`,\nremembering the number of steps it takes. -/\nstructure EvalsTo {σ : Type*} (f : σ → Option σ) (a : σ) (b : Option σ) where\n  /-- number of steps taken -/\n  steps : ℕ\n  evals_in_steps : (flip bind f)^[steps] a = b\n\n-- note: this cannot currently be used in `calc`, as the last two arguments must be `a` and `b`.\n-- If this is desired, this argument order can be changed, but this spelling is I think the most\n-- natural, so there is a trade-off that needs to be made here. A notation can get around this.\n"}
{"name":"Turing.EvalsTo.mk.sizeOf_spec","module":"Mathlib.Computability.TMComputable","initialProofState":"σ : Type u_1\nf : σ → Option σ\na : σ\nb : Option σ\ninst✝ : SizeOf σ\nsteps : Nat\nevals_in_steps : Eq (Nat.iterate (flip Bind.bind f) steps (Option.some a)) b\n⊢ Eq (SizeOf.sizeOf { steps := steps, evals_in_steps := evals_in_steps }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf steps)) (SizeOf.sizeOf evals_in_steps))","decl":"/-- A \"proof\" of the fact that `f` eventually reaches `b` when repeatedly evaluated on `a`,\nremembering the number of steps it takes. -/\nstructure EvalsTo {σ : Type*} (f : σ → Option σ) (a : σ) (b : Option σ) where\n  /-- number of steps taken -/\n  steps : ℕ\n  evals_in_steps : (flip bind f)^[steps] a = b\n\n-- note: this cannot currently be used in `calc`, as the last two arguments must be `a` and `b`.\n-- If this is desired, this argument order can be changed, but this spelling is I think the most\n-- natural, so there is a trade-off that needs to be made here. A notation can get around this.\n"}
{"name":"Turing.EvalsTo.mk.injEq","module":"Mathlib.Computability.TMComputable","initialProofState":"σ : Type u_1\nf : σ → Option σ\na : σ\nb : Option σ\nsteps✝ : Nat\nevals_in_steps✝ : Eq (Nat.iterate (flip Bind.bind f) steps✝ (Option.some a)) b\nsteps : Nat\nevals_in_steps : Eq (Nat.iterate (flip Bind.bind f) steps (Option.some a)) b\n⊢ Eq (Eq { steps := steps✝, evals_in_steps := evals_in_steps✝ } { steps := steps, evals_in_steps := evals_in_steps }) (Eq steps✝ steps)","decl":"/-- A \"proof\" of the fact that `f` eventually reaches `b` when repeatedly evaluated on `a`,\nremembering the number of steps it takes. -/\nstructure EvalsTo {σ : Type*} (f : σ → Option σ) (a : σ) (b : Option σ) where\n  /-- number of steps taken -/\n  steps : ℕ\n  evals_in_steps : (flip bind f)^[steps] a = b\n\n-- note: this cannot currently be used in `calc`, as the last two arguments must be `a` and `b`.\n-- If this is desired, this argument order can be changed, but this spelling is I think the most\n-- natural, so there is a trade-off that needs to be made here. A notation can get around this.\n"}
{"name":"Turing.EvalsToInTime.mk.inj","module":"Mathlib.Computability.TMComputable","initialProofState":"σ : Type u_1\nf : σ → Option σ\na : σ\nb : Option σ\nm : Nat\ntoEvalsTo✝ : Turing.EvalsTo f a b\nsteps_le_m✝ : LE.le toEvalsTo✝.steps m\ntoEvalsTo : Turing.EvalsTo f a b\nsteps_le_m : LE.le toEvalsTo.steps m\nx✝ : Eq { toEvalsTo := toEvalsTo✝, steps_le_m := steps_le_m✝ } { toEvalsTo := toEvalsTo, steps_le_m := steps_le_m }\n⊢ Eq toEvalsTo✝ toEvalsTo","decl":"/-- A \"proof\" of the fact that `f` eventually reaches `b` in at most `m` steps when repeatedly\nevaluated on `a`, remembering the number of steps it takes. -/\nstructure EvalsToInTime {σ : Type*} (f : σ → Option σ) (a : σ) (b : Option σ) (m : ℕ) extends\n  EvalsTo f a b where\n  steps_le_m : steps ≤ m\n\n"}
{"name":"Turing.EvalsToInTime.mk.injEq","module":"Mathlib.Computability.TMComputable","initialProofState":"σ : Type u_1\nf : σ → Option σ\na : σ\nb : Option σ\nm : Nat\ntoEvalsTo✝ : Turing.EvalsTo f a b\nsteps_le_m✝ : LE.le toEvalsTo✝.steps m\ntoEvalsTo : Turing.EvalsTo f a b\nsteps_le_m : LE.le toEvalsTo.steps m\n⊢ Eq (Eq { toEvalsTo := toEvalsTo✝, steps_le_m := steps_le_m✝ } { toEvalsTo := toEvalsTo, steps_le_m := steps_le_m }) (Eq toEvalsTo✝ toEvalsTo)","decl":"/-- A \"proof\" of the fact that `f` eventually reaches `b` in at most `m` steps when repeatedly\nevaluated on `a`, remembering the number of steps it takes. -/\nstructure EvalsToInTime {σ : Type*} (f : σ → Option σ) (a : σ) (b : Option σ) (m : ℕ) extends\n  EvalsTo f a b where\n  steps_le_m : steps ≤ m\n\n"}
{"name":"Turing.EvalsToInTime.mk.sizeOf_spec","module":"Mathlib.Computability.TMComputable","initialProofState":"σ : Type u_1\nf : σ → Option σ\na : σ\nb : Option σ\nm : Nat\ninst✝ : SizeOf σ\ntoEvalsTo : Turing.EvalsTo f a b\nsteps_le_m : LE.le toEvalsTo.steps m\n⊢ Eq (SizeOf.sizeOf { toEvalsTo := toEvalsTo, steps_le_m := steps_le_m }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toEvalsTo)) (SizeOf.sizeOf steps_le_m))","decl":"/-- A \"proof\" of the fact that `f` eventually reaches `b` in at most `m` steps when repeatedly\nevaluated on `a`, remembering the number of steps it takes. -/\nstructure EvalsToInTime {σ : Type*} (f : σ → Option σ) (a : σ) (b : Option σ) (m : ℕ) extends\n  EvalsTo f a b where\n  steps_le_m : steps ≤ m\n\n"}
{"name":"Turing.EvalsToInTime.steps_le_m","module":"Mathlib.Computability.TMComputable","initialProofState":"σ : Type u_1\nf : σ → Option σ\na : σ\nb : Option σ\nm : Nat\nself : Turing.EvalsToInTime f a b m\n⊢ LE.le self.steps m","decl":"/-- A \"proof\" of the fact that `f` eventually reaches `b` in at most `m` steps when repeatedly\nevaluated on `a`, remembering the number of steps it takes. -/\nstructure EvalsToInTime {σ : Type*} (f : σ → Option σ) (a : σ) (b : Option σ) (m : ℕ) extends\n  EvalsTo f a b where\n  steps_le_m : steps ≤ m\n\n"}
{"name":"Turing.TM2ComputableAux.mk.injEq","module":"Mathlib.Computability.TMComputable","initialProofState":"Γ₀ Γ₁ : Type\ntm✝ : Turing.FinTM2\ninputAlphabet✝ : Equiv (tm✝.Γ tm✝.k₀) Γ₀\noutputAlphabet✝ : Equiv (tm✝.Γ tm✝.k₁) Γ₁\ntm : Turing.FinTM2\ninputAlphabet : Equiv (tm.Γ tm.k₀) Γ₀\noutputAlphabet : Equiv (tm.Γ tm.k₁) Γ₁\n⊢ Eq (Eq { tm := tm✝, inputAlphabet := inputAlphabet✝, outputAlphabet := outputAlphabet✝ } { tm := tm, inputAlphabet := inputAlphabet, outputAlphabet := outputAlphabet }) (And (Eq tm✝ tm) (And (HEq inputAlphabet✝ inputAlphabet) (HEq outputAlphabet✝ outputAlphabet)))","decl":"/-- A (bundled TM2) Turing machine\nwith input alphabet equivalent to `Γ₀` and output alphabet equivalent to `Γ₁`. -/\nstructure TM2ComputableAux (Γ₀ Γ₁ : Type) where\n  /-- the underlying bundled TM2 -/\n  tm : FinTM2\n  /-- the input alphabet is equivalent to `Γ₀` -/\n  inputAlphabet : tm.Γ tm.k₀ ≃ Γ₀\n  /-- the output alphabet is equivalent to `Γ₁` -/\n  outputAlphabet : tm.Γ tm.k₁ ≃ Γ₁\n\n"}
{"name":"Turing.TM2ComputableAux.mk.sizeOf_spec","module":"Mathlib.Computability.TMComputable","initialProofState":"Γ₀ Γ₁ : Type\ninst✝¹ : SizeOf Γ₀\ninst✝ : SizeOf Γ₁\ntm : Turing.FinTM2\ninputAlphabet : Equiv (tm.Γ tm.k₀) Γ₀\noutputAlphabet : Equiv (tm.Γ tm.k₁) Γ₁\n⊢ Eq (SizeOf.sizeOf { tm := tm, inputAlphabet := inputAlphabet, outputAlphabet := outputAlphabet }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf tm)) (SizeOf.sizeOf inputAlphabet)) (SizeOf.sizeOf outputAlphabet))","decl":"/-- A (bundled TM2) Turing machine\nwith input alphabet equivalent to `Γ₀` and output alphabet equivalent to `Γ₁`. -/\nstructure TM2ComputableAux (Γ₀ Γ₁ : Type) where\n  /-- the underlying bundled TM2 -/\n  tm : FinTM2\n  /-- the input alphabet is equivalent to `Γ₀` -/\n  inputAlphabet : tm.Γ tm.k₀ ≃ Γ₀\n  /-- the output alphabet is equivalent to `Γ₁` -/\n  outputAlphabet : tm.Γ tm.k₁ ≃ Γ₁\n\n"}
{"name":"Turing.TM2ComputableAux.mk.inj","module":"Mathlib.Computability.TMComputable","initialProofState":"Γ₀ Γ₁ : Type\ntm✝ : Turing.FinTM2\ninputAlphabet✝ : Equiv (tm✝.Γ tm✝.k₀) Γ₀\noutputAlphabet✝ : Equiv (tm✝.Γ tm✝.k₁) Γ₁\ntm : Turing.FinTM2\ninputAlphabet : Equiv (tm.Γ tm.k₀) Γ₀\noutputAlphabet : Equiv (tm.Γ tm.k₁) Γ₁\nx✝ : Eq { tm := tm✝, inputAlphabet := inputAlphabet✝, outputAlphabet := outputAlphabet✝ } { tm := tm, inputAlphabet := inputAlphabet, outputAlphabet := outputAlphabet }\n⊢ And (Eq tm✝ tm) (And (HEq inputAlphabet✝ inputAlphabet) (HEq outputAlphabet✝ outputAlphabet))","decl":"/-- A (bundled TM2) Turing machine\nwith input alphabet equivalent to `Γ₀` and output alphabet equivalent to `Γ₁`. -/\nstructure TM2ComputableAux (Γ₀ Γ₁ : Type) where\n  /-- the underlying bundled TM2 -/\n  tm : FinTM2\n  /-- the input alphabet is equivalent to `Γ₀` -/\n  inputAlphabet : tm.Γ tm.k₀ ≃ Γ₀\n  /-- the output alphabet is equivalent to `Γ₁` -/\n  outputAlphabet : tm.Γ tm.k₁ ≃ Γ₁\n\n"}
{"name":"Turing.TM2Computable.mk.sizeOf_spec","module":"Mathlib.Computability.TMComputable","initialProofState":"α β : Type\nea : Computability.FinEncoding α\neb : Computability.FinEncoding β\nf : α → β\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\ntoTM2ComputableAux : Turing.TM2ComputableAux ea.Γ eb.Γ\noutputsFun : (a : α) → Turing.TM2Outputs toTM2ComputableAux.tm (List.map toTM2ComputableAux.inputAlphabet.invFun (ea.encode a)) (Option.some (List.map toTM2ComputableAux.outputAlphabet.invFun (eb.encode (f a))))\n⊢ Eq (SizeOf.sizeOf { toTM2ComputableAux := toTM2ComputableAux, outputsFun := outputsFun }) (HAdd.hAdd 1 (SizeOf.sizeOf toTM2ComputableAux))","decl":"/-- A Turing machine + a proof it outputs `f`. -/\nstructure TM2Computable {α β : Type} (ea : FinEncoding α) (eb : FinEncoding β) (f : α → β) extends\n  TM2ComputableAux ea.Γ eb.Γ where\n  /-- a proof this machine outputs `f` -/\n  outputsFun :\n    ∀ a,\n      TM2Outputs tm (List.map inputAlphabet.invFun (ea.encode a))\n        (Option.some ((List.map outputAlphabet.invFun) (eb.encode (f a))))\n\n"}
{"name":"Turing.TM2Computable.mk.injEq","module":"Mathlib.Computability.TMComputable","initialProofState":"α β : Type\nea : Computability.FinEncoding α\neb : Computability.FinEncoding β\nf : α → β\ntoTM2ComputableAux✝ : Turing.TM2ComputableAux ea.Γ eb.Γ\noutputsFun✝ : (a : α) → Turing.TM2Outputs toTM2ComputableAux✝.tm (List.map toTM2ComputableAux✝.inputAlphabet.invFun (ea.encode a)) (Option.some (List.map toTM2ComputableAux✝.outputAlphabet.invFun (eb.encode (f a))))\ntoTM2ComputableAux : Turing.TM2ComputableAux ea.Γ eb.Γ\noutputsFun : (a : α) → Turing.TM2Outputs toTM2ComputableAux.tm (List.map toTM2ComputableAux.inputAlphabet.invFun (ea.encode a)) (Option.some (List.map toTM2ComputableAux.outputAlphabet.invFun (eb.encode (f a))))\n⊢ Eq (Eq { toTM2ComputableAux := toTM2ComputableAux✝, outputsFun := outputsFun✝ } { toTM2ComputableAux := toTM2ComputableAux, outputsFun := outputsFun }) (And (Eq toTM2ComputableAux✝ toTM2ComputableAux) (HEq outputsFun✝ outputsFun))","decl":"/-- A Turing machine + a proof it outputs `f`. -/\nstructure TM2Computable {α β : Type} (ea : FinEncoding α) (eb : FinEncoding β) (f : α → β) extends\n  TM2ComputableAux ea.Γ eb.Γ where\n  /-- a proof this machine outputs `f` -/\n  outputsFun :\n    ∀ a,\n      TM2Outputs tm (List.map inputAlphabet.invFun (ea.encode a))\n        (Option.some ((List.map outputAlphabet.invFun) (eb.encode (f a))))\n\n"}
{"name":"Turing.TM2Computable.mk.inj","module":"Mathlib.Computability.TMComputable","initialProofState":"α β : Type\nea : Computability.FinEncoding α\neb : Computability.FinEncoding β\nf : α → β\ntoTM2ComputableAux✝ : Turing.TM2ComputableAux ea.Γ eb.Γ\noutputsFun✝ : (a : α) → Turing.TM2Outputs toTM2ComputableAux✝.tm (List.map toTM2ComputableAux✝.inputAlphabet.invFun (ea.encode a)) (Option.some (List.map toTM2ComputableAux✝.outputAlphabet.invFun (eb.encode (f a))))\ntoTM2ComputableAux : Turing.TM2ComputableAux ea.Γ eb.Γ\noutputsFun : (a : α) → Turing.TM2Outputs toTM2ComputableAux.tm (List.map toTM2ComputableAux.inputAlphabet.invFun (ea.encode a)) (Option.some (List.map toTM2ComputableAux.outputAlphabet.invFun (eb.encode (f a))))\nx✝ : Eq { toTM2ComputableAux := toTM2ComputableAux✝, outputsFun := outputsFun✝ } { toTM2ComputableAux := toTM2ComputableAux, outputsFun := outputsFun }\n⊢ And (Eq toTM2ComputableAux✝ toTM2ComputableAux) (HEq outputsFun✝ outputsFun)","decl":"/-- A Turing machine + a proof it outputs `f`. -/\nstructure TM2Computable {α β : Type} (ea : FinEncoding α) (eb : FinEncoding β) (f : α → β) extends\n  TM2ComputableAux ea.Γ eb.Γ where\n  /-- a proof this machine outputs `f` -/\n  outputsFun :\n    ∀ a,\n      TM2Outputs tm (List.map inputAlphabet.invFun (ea.encode a))\n        (Option.some ((List.map outputAlphabet.invFun) (eb.encode (f a))))\n\n"}
{"name":"Turing.TM2ComputableInTime.mk.inj","module":"Mathlib.Computability.TMComputable","initialProofState":"α β : Type\nea : Computability.FinEncoding α\neb : Computability.FinEncoding β\nf : α → β\ntoTM2ComputableAux✝ : Turing.TM2ComputableAux ea.Γ eb.Γ\ntime✝ : Nat → Nat\noutputsFun✝ : (a : α) → Turing.TM2OutputsInTime toTM2ComputableAux✝.tm (List.map toTM2ComputableAux✝.inputAlphabet.invFun (ea.encode a)) (Option.some (List.map toTM2ComputableAux✝.outputAlphabet.invFun (eb.encode (f a)))) (time✝ (ea.encode a).length)\ntoTM2ComputableAux : Turing.TM2ComputableAux ea.Γ eb.Γ\ntime : Nat → Nat\noutputsFun : (a : α) → Turing.TM2OutputsInTime toTM2ComputableAux.tm (List.map toTM2ComputableAux.inputAlphabet.invFun (ea.encode a)) (Option.some (List.map toTM2ComputableAux.outputAlphabet.invFun (eb.encode (f a)))) (time (ea.encode a).length)\nx✝ : Eq { toTM2ComputableAux := toTM2ComputableAux✝, time := time✝, outputsFun := outputsFun✝ } { toTM2ComputableAux := toTM2ComputableAux, time := time, outputsFun := outputsFun }\n⊢ And (Eq toTM2ComputableAux✝ toTM2ComputableAux) (And (Eq time✝ time) (HEq outputsFun✝ outputsFun))","decl":"/-- A Turing machine + a time function +\na proof it outputs `f` in at most `time(input.length)` steps. -/\nstructure TM2ComputableInTime {α β : Type} (ea : FinEncoding α) (eb : FinEncoding β)\n  (f : α → β) extends TM2ComputableAux ea.Γ eb.Γ where\n  /-- a time function -/\n  time : ℕ → ℕ\n  /-- proof this machine outputs `f` in at most `time(input.length)` steps -/\n  outputsFun :\n    ∀ a,\n      TM2OutputsInTime tm (List.map inputAlphabet.invFun (ea.encode a))\n        (Option.some ((List.map outputAlphabet.invFun) (eb.encode (f a))))\n        (time (ea.encode a).length)\n\n"}
{"name":"Turing.TM2ComputableInTime.mk.injEq","module":"Mathlib.Computability.TMComputable","initialProofState":"α β : Type\nea : Computability.FinEncoding α\neb : Computability.FinEncoding β\nf : α → β\ntoTM2ComputableAux✝ : Turing.TM2ComputableAux ea.Γ eb.Γ\ntime✝ : Nat → Nat\noutputsFun✝ : (a : α) → Turing.TM2OutputsInTime toTM2ComputableAux✝.tm (List.map toTM2ComputableAux✝.inputAlphabet.invFun (ea.encode a)) (Option.some (List.map toTM2ComputableAux✝.outputAlphabet.invFun (eb.encode (f a)))) (time✝ (ea.encode a).length)\ntoTM2ComputableAux : Turing.TM2ComputableAux ea.Γ eb.Γ\ntime : Nat → Nat\noutputsFun : (a : α) → Turing.TM2OutputsInTime toTM2ComputableAux.tm (List.map toTM2ComputableAux.inputAlphabet.invFun (ea.encode a)) (Option.some (List.map toTM2ComputableAux.outputAlphabet.invFun (eb.encode (f a)))) (time (ea.encode a).length)\n⊢ Eq (Eq { toTM2ComputableAux := toTM2ComputableAux✝, time := time✝, outputsFun := outputsFun✝ } { toTM2ComputableAux := toTM2ComputableAux, time := time, outputsFun := outputsFun }) (And (Eq toTM2ComputableAux✝ toTM2ComputableAux) (And (Eq time✝ time) (HEq outputsFun✝ outputsFun)))","decl":"/-- A Turing machine + a time function +\na proof it outputs `f` in at most `time(input.length)` steps. -/\nstructure TM2ComputableInTime {α β : Type} (ea : FinEncoding α) (eb : FinEncoding β)\n  (f : α → β) extends TM2ComputableAux ea.Γ eb.Γ where\n  /-- a time function -/\n  time : ℕ → ℕ\n  /-- proof this machine outputs `f` in at most `time(input.length)` steps -/\n  outputsFun :\n    ∀ a,\n      TM2OutputsInTime tm (List.map inputAlphabet.invFun (ea.encode a))\n        (Option.some ((List.map outputAlphabet.invFun) (eb.encode (f a))))\n        (time (ea.encode a).length)\n\n"}
{"name":"Turing.TM2ComputableInTime.mk.sizeOf_spec","module":"Mathlib.Computability.TMComputable","initialProofState":"α β : Type\nea : Computability.FinEncoding α\neb : Computability.FinEncoding β\nf : α → β\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\ntoTM2ComputableAux : Turing.TM2ComputableAux ea.Γ eb.Γ\ntime : Nat → Nat\noutputsFun : (a : α) → Turing.TM2OutputsInTime toTM2ComputableAux.tm (List.map toTM2ComputableAux.inputAlphabet.invFun (ea.encode a)) (Option.some (List.map toTM2ComputableAux.outputAlphabet.invFun (eb.encode (f a)))) (time (ea.encode a).length)\n⊢ Eq (SizeOf.sizeOf { toTM2ComputableAux := toTM2ComputableAux, time := time, outputsFun := outputsFun }) (HAdd.hAdd 1 (SizeOf.sizeOf toTM2ComputableAux))","decl":"/-- A Turing machine + a time function +\na proof it outputs `f` in at most `time(input.length)` steps. -/\nstructure TM2ComputableInTime {α β : Type} (ea : FinEncoding α) (eb : FinEncoding β)\n  (f : α → β) extends TM2ComputableAux ea.Γ eb.Γ where\n  /-- a time function -/\n  time : ℕ → ℕ\n  /-- proof this machine outputs `f` in at most `time(input.length)` steps -/\n  outputsFun :\n    ∀ a,\n      TM2OutputsInTime tm (List.map inputAlphabet.invFun (ea.encode a))\n        (Option.some ((List.map outputAlphabet.invFun) (eb.encode (f a))))\n        (time (ea.encode a).length)\n\n"}
{"name":"Turing.TM2ComputableInPolyTime.mk.inj","module":"Mathlib.Computability.TMComputable","initialProofState":"α β : Type\nea : Computability.FinEncoding α\neb : Computability.FinEncoding β\nf : α → β\ntoTM2ComputableAux✝ : Turing.TM2ComputableAux ea.Γ eb.Γ\ntime✝ : Polynomial Nat\noutputsFun✝ : (a : α) → Turing.TM2OutputsInTime toTM2ComputableAux✝.tm (List.map toTM2ComputableAux✝.inputAlphabet.invFun (ea.encode a)) (Option.some (List.map toTM2ComputableAux✝.outputAlphabet.invFun (eb.encode (f a)))) (Polynomial.eval (ea.encode a).length time✝)\ntoTM2ComputableAux : Turing.TM2ComputableAux ea.Γ eb.Γ\ntime : Polynomial Nat\noutputsFun : (a : α) → Turing.TM2OutputsInTime toTM2ComputableAux.tm (List.map toTM2ComputableAux.inputAlphabet.invFun (ea.encode a)) (Option.some (List.map toTM2ComputableAux.outputAlphabet.invFun (eb.encode (f a)))) (Polynomial.eval (ea.encode a).length time)\nx✝ : Eq { toTM2ComputableAux := toTM2ComputableAux✝, time := time✝, outputsFun := outputsFun✝ } { toTM2ComputableAux := toTM2ComputableAux, time := time, outputsFun := outputsFun }\n⊢ And (Eq toTM2ComputableAux✝ toTM2ComputableAux) (And (Eq time✝ time) (HEq outputsFun✝ outputsFun))","decl":"/-- A Turing machine + a polynomial time function +\na proof it outputs `f` in at most `time(input.length)` steps. -/\nstructure TM2ComputableInPolyTime {α β : Type} (ea : FinEncoding α) (eb : FinEncoding β)\n  (f : α → β) extends TM2ComputableAux ea.Γ eb.Γ where\n  /-- a polynomial time function -/\n  time : Polynomial ℕ\n  /-- proof that this machine outputs `f` in at most `time(input.length)` steps -/\n  outputsFun :\n    ∀ a,\n      TM2OutputsInTime tm (List.map inputAlphabet.invFun (ea.encode a))\n        (Option.some ((List.map outputAlphabet.invFun) (eb.encode (f a))))\n        (time.eval (ea.encode a).length)\n\n"}
{"name":"Turing.TM2ComputableInPolyTime.mk.sizeOf_spec","module":"Mathlib.Computability.TMComputable","initialProofState":"α β : Type\nea : Computability.FinEncoding α\neb : Computability.FinEncoding β\nf : α → β\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\ntoTM2ComputableAux : Turing.TM2ComputableAux ea.Γ eb.Γ\ntime : Polynomial Nat\noutputsFun : (a : α) → Turing.TM2OutputsInTime toTM2ComputableAux.tm (List.map toTM2ComputableAux.inputAlphabet.invFun (ea.encode a)) (Option.some (List.map toTM2ComputableAux.outputAlphabet.invFun (eb.encode (f a)))) (Polynomial.eval (ea.encode a).length time)\n⊢ Eq (SizeOf.sizeOf { toTM2ComputableAux := toTM2ComputableAux, time := time, outputsFun := outputsFun }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toTM2ComputableAux)) (SizeOf.sizeOf time))","decl":"/-- A Turing machine + a polynomial time function +\na proof it outputs `f` in at most `time(input.length)` steps. -/\nstructure TM2ComputableInPolyTime {α β : Type} (ea : FinEncoding α) (eb : FinEncoding β)\n  (f : α → β) extends TM2ComputableAux ea.Γ eb.Γ where\n  /-- a polynomial time function -/\n  time : Polynomial ℕ\n  /-- proof that this machine outputs `f` in at most `time(input.length)` steps -/\n  outputsFun :\n    ∀ a,\n      TM2OutputsInTime tm (List.map inputAlphabet.invFun (ea.encode a))\n        (Option.some ((List.map outputAlphabet.invFun) (eb.encode (f a))))\n        (time.eval (ea.encode a).length)\n\n"}
{"name":"Turing.TM2ComputableInPolyTime.mk.injEq","module":"Mathlib.Computability.TMComputable","initialProofState":"α β : Type\nea : Computability.FinEncoding α\neb : Computability.FinEncoding β\nf : α → β\ntoTM2ComputableAux✝ : Turing.TM2ComputableAux ea.Γ eb.Γ\ntime✝ : Polynomial Nat\noutputsFun✝ : (a : α) → Turing.TM2OutputsInTime toTM2ComputableAux✝.tm (List.map toTM2ComputableAux✝.inputAlphabet.invFun (ea.encode a)) (Option.some (List.map toTM2ComputableAux✝.outputAlphabet.invFun (eb.encode (f a)))) (Polynomial.eval (ea.encode a).length time✝)\ntoTM2ComputableAux : Turing.TM2ComputableAux ea.Γ eb.Γ\ntime : Polynomial Nat\noutputsFun : (a : α) → Turing.TM2OutputsInTime toTM2ComputableAux.tm (List.map toTM2ComputableAux.inputAlphabet.invFun (ea.encode a)) (Option.some (List.map toTM2ComputableAux.outputAlphabet.invFun (eb.encode (f a)))) (Polynomial.eval (ea.encode a).length time)\n⊢ Eq (Eq { toTM2ComputableAux := toTM2ComputableAux✝, time := time✝, outputsFun := outputsFun✝ } { toTM2ComputableAux := toTM2ComputableAux, time := time, outputsFun := outputsFun }) (And (Eq toTM2ComputableAux✝ toTM2ComputableAux) (And (Eq time✝ time) (HEq outputsFun✝ outputsFun)))","decl":"/-- A Turing machine + a polynomial time function +\na proof it outputs `f` in at most `time(input.length)` steps. -/\nstructure TM2ComputableInPolyTime {α β : Type} (ea : FinEncoding α) (eb : FinEncoding β)\n  (f : α → β) extends TM2ComputableAux ea.Γ eb.Γ where\n  /-- a polynomial time function -/\n  time : Polynomial ℕ\n  /-- proof that this machine outputs `f` in at most `time(input.length)` steps -/\n  outputsFun :\n    ∀ a,\n      TM2OutputsInTime tm (List.map inputAlphabet.invFun (ea.encode a))\n        (Option.some ((List.map outputAlphabet.invFun) (eb.encode (f a))))\n        (time.eval (ea.encode a).length)\n\n"}
