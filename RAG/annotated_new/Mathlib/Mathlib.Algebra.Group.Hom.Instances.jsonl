{"name":"AddMonoid.End.zero_apply","module":"Mathlib.Algebra.Group.Hom.Instances","initialProofState":"M : Type uM\ninst✝ : AddCommMonoid M\nm : M\n⊢ Eq (0 m) 0","decl":"@[simp]\ntheorem AddMonoid.End.zero_apply [AddCommMonoid M] (m : M) : (0 : AddMonoid.End M) m = 0 :=\n  rfl\n\n-- Note: `@[simp]` omitted because `(1 : AddMonoid.End M) = id` by `AddMonoid.End.coe_one`\n"}
{"name":"AddMonoid.End.one_apply","module":"Mathlib.Algebra.Group.Hom.Instances","initialProofState":"M : Type uM\ninst✝ : AddCommMonoid M\nm : M\n⊢ Eq (1 m) m","decl":"theorem AddMonoid.End.one_apply [AddCommMonoid M] (m : M) : (1 : AddMonoid.End M) m = m :=\n  rfl\n\n"}
{"name":"AddMonoid.End.intCast_apply","module":"Mathlib.Algebra.Group.Hom.Instances","initialProofState":"M : Type uM\ninst✝ : AddCommGroup M\nz : Int\nm : M\n⊢ Eq (↑z m) (HSMul.hSMul z m)","decl":"/-- See also `AddMonoid.End.intCast_def`. -/\n@[simp]\ntheorem AddMonoid.End.intCast_apply [AddCommGroup M] (z : ℤ) (m : M) :\n    (↑z : AddMonoid.End M) m = z • m :=\n  rfl\n\n"}
{"name":"AddMonoidHom.nsmul_apply","module":"Mathlib.Algebra.Group.Hom.Instances","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddCommMonoid N\nf : AddMonoidHom M N\nn : Nat\nx : M\n⊢ Eq ((HSMul.hSMul n f) x) (HSMul.hSMul n (f x))","decl":"@[to_additive (attr := simp)] lemma MonoidHom.pow_apply {M N : Type*} [MulOneClass M]\n    [CommMonoid N] (f : M →* N) (n : ℕ) (x : M) :\n    (f ^ n) x = (f x) ^ n :=\n  rfl\n\n"}
{"name":"MonoidHom.pow_apply","module":"Mathlib.Algebra.Group.Hom.Instances","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : CommMonoid N\nf : MonoidHom M N\nn : Nat\nx : M\n⊢ Eq ((HPow.hPow f n) x) (HPow.hPow (f x) n)","decl":"@[to_additive (attr := simp)] lemma MonoidHom.pow_apply {M N : Type*} [MulOneClass M]\n    [CommMonoid N] (f : M →* N) (n : ℕ) (x : M) :\n    (f ^ n) x = (f x) ^ n :=\n  rfl\n\n"}
{"name":"MonoidHom.ext_iff₂","module":"Mathlib.Algebra.Group.Hom.Instances","initialProofState":"M : Type uM\nN : Type uN\nP : Type uP\nx✝² : MulOneClass M\nx✝¹ : MulOneClass N\nx✝ : CommMonoid P\nf g : MonoidHom M (MonoidHom N P)\n⊢ Iff (Eq f g) (∀ (x : M) (y : N), Eq ((f x) y) ((g x) y))","decl":"@[to_additive]\ntheorem ext_iff₂ {_ : MulOneClass M} {_ : MulOneClass N} {_ : CommMonoid P} {f g : M →* N →* P} :\n    f = g ↔ ∀ x y, f x y = g x y :=\n  DFunLike.ext_iff.trans <| forall_congr' fun _ => DFunLike.ext_iff\n\n"}
{"name":"AddMonoidHom.ext_iff₂","module":"Mathlib.Algebra.Group.Hom.Instances","initialProofState":"M : Type uM\nN : Type uN\nP : Type uP\nx✝² : AddZeroClass M\nx✝¹ : AddZeroClass N\nx✝ : AddCommMonoid P\nf g : AddMonoidHom M (AddMonoidHom N P)\n⊢ Iff (Eq f g) (∀ (x : M) (y : N), Eq ((f x) y) ((g x) y))","decl":"@[to_additive]\ntheorem ext_iff₂ {_ : MulOneClass M} {_ : MulOneClass N} {_ : CommMonoid P} {f g : M →* N →* P} :\n    f = g ↔ ∀ x y, f x y = g x y :=\n  DFunLike.ext_iff.trans <| forall_congr' fun _ => DFunLike.ext_iff\n\n"}
{"name":"AddMonoidHom.flip_apply","module":"Mathlib.Algebra.Group.Hom.Instances","initialProofState":"M : Type uM\nN : Type uN\nP : Type uP\nx✝² : AddZeroClass M\nx✝¹ : AddZeroClass N\nx✝ : AddCommMonoid P\nf : AddMonoidHom M (AddMonoidHom N P)\nx : M\ny : N\n⊢ Eq ((f.flip y) x) ((f x) y)","decl":"@[to_additive (attr := simp)]\ntheorem flip_apply {_ : MulOneClass M} {_ : MulOneClass N} {_ : CommMonoid P} (f : M →* N →* P)\n    (x : M) (y : N) : f.flip y x = f x y :=\n  rfl\n\n"}
{"name":"MonoidHom.flip_apply","module":"Mathlib.Algebra.Group.Hom.Instances","initialProofState":"M : Type uM\nN : Type uN\nP : Type uP\nx✝² : MulOneClass M\nx✝¹ : MulOneClass N\nx✝ : CommMonoid P\nf : MonoidHom M (MonoidHom N P)\nx : M\ny : N\n⊢ Eq ((f.flip y) x) ((f x) y)","decl":"@[to_additive (attr := simp)]\ntheorem flip_apply {_ : MulOneClass M} {_ : MulOneClass N} {_ : CommMonoid P} (f : M →* N →* P)\n    (x : M) (y : N) : f.flip y x = f x y :=\n  rfl\n\n"}
{"name":"AddMonoidHom.map_one₂","module":"Mathlib.Algebra.Group.Hom.Instances","initialProofState":"M : Type uM\nN : Type uN\nP : Type uP\nx✝² : AddZeroClass M\nx✝¹ : AddZeroClass N\nx✝ : AddCommMonoid P\nf : AddMonoidHom M (AddMonoidHom N P)\nn : N\n⊢ Eq ((f 0) n) 0","decl":"@[to_additive]\ntheorem map_one₂ {_ : MulOneClass M} {_ : MulOneClass N} {_ : CommMonoid P} (f : M →* N →* P)\n    (n : N) : f 1 n = 1 :=\n  (flip f n).map_one\n\n"}
{"name":"MonoidHom.map_one₂","module":"Mathlib.Algebra.Group.Hom.Instances","initialProofState":"M : Type uM\nN : Type uN\nP : Type uP\nx✝² : MulOneClass M\nx✝¹ : MulOneClass N\nx✝ : CommMonoid P\nf : MonoidHom M (MonoidHom N P)\nn : N\n⊢ Eq ((f 1) n) 1","decl":"@[to_additive]\ntheorem map_one₂ {_ : MulOneClass M} {_ : MulOneClass N} {_ : CommMonoid P} (f : M →* N →* P)\n    (n : N) : f 1 n = 1 :=\n  (flip f n).map_one\n\n"}
{"name":"MonoidHom.map_mul₂","module":"Mathlib.Algebra.Group.Hom.Instances","initialProofState":"M : Type uM\nN : Type uN\nP : Type uP\nx✝² : MulOneClass M\nx✝¹ : MulOneClass N\nx✝ : CommMonoid P\nf : MonoidHom M (MonoidHom N P)\nm₁ m₂ : M\nn : N\n⊢ Eq ((f (HMul.hMul m₁ m₂)) n) (HMul.hMul ((f m₁) n) ((f m₂) n))","decl":"@[to_additive]\ntheorem map_mul₂ {_ : MulOneClass M} {_ : MulOneClass N} {_ : CommMonoid P} (f : M →* N →* P)\n    (m₁ m₂ : M) (n : N) : f (m₁ * m₂) n = f m₁ n * f m₂ n :=\n  (flip f n).map_mul _ _\n\n"}
{"name":"AddMonoidHom.map_mul₂","module":"Mathlib.Algebra.Group.Hom.Instances","initialProofState":"M : Type uM\nN : Type uN\nP : Type uP\nx✝² : AddZeroClass M\nx✝¹ : AddZeroClass N\nx✝ : AddCommMonoid P\nf : AddMonoidHom M (AddMonoidHom N P)\nm₁ m₂ : M\nn : N\n⊢ Eq ((f (HAdd.hAdd m₁ m₂)) n) (HAdd.hAdd ((f m₁) n) ((f m₂) n))","decl":"@[to_additive]\ntheorem map_mul₂ {_ : MulOneClass M} {_ : MulOneClass N} {_ : CommMonoid P} (f : M →* N →* P)\n    (m₁ m₂ : M) (n : N) : f (m₁ * m₂) n = f m₁ n * f m₂ n :=\n  (flip f n).map_mul _ _\n\n"}
{"name":"AddMonoidHom.map_inv₂","module":"Mathlib.Algebra.Group.Hom.Instances","initialProofState":"M : Type uM\nN : Type uN\nP : Type uP\nx✝² : AddGroup M\nx✝¹ : AddZeroClass N\nx✝ : AddCommGroup P\nf : AddMonoidHom M (AddMonoidHom N P)\nm : M\nn : N\n⊢ Eq ((f (Neg.neg m)) n) (Neg.neg ((f m) n))","decl":"@[to_additive]\ntheorem map_inv₂ {_ : Group M} {_ : MulOneClass N} {_ : CommGroup P} (f : M →* N →* P) (m : M)\n    (n : N) : f m⁻¹ n = (f m n)⁻¹ :=\n  (flip f n).map_inv _\n\n"}
{"name":"MonoidHom.map_inv₂","module":"Mathlib.Algebra.Group.Hom.Instances","initialProofState":"M : Type uM\nN : Type uN\nP : Type uP\nx✝² : Group M\nx✝¹ : MulOneClass N\nx✝ : CommGroup P\nf : MonoidHom M (MonoidHom N P)\nm : M\nn : N\n⊢ Eq ((f (Inv.inv m)) n) (Inv.inv ((f m) n))","decl":"@[to_additive]\ntheorem map_inv₂ {_ : Group M} {_ : MulOneClass N} {_ : CommGroup P} (f : M →* N →* P) (m : M)\n    (n : N) : f m⁻¹ n = (f m n)⁻¹ :=\n  (flip f n).map_inv _\n\n"}
{"name":"AddMonoidHom.map_div₂","module":"Mathlib.Algebra.Group.Hom.Instances","initialProofState":"M : Type uM\nN : Type uN\nP : Type uP\nx✝² : AddGroup M\nx✝¹ : AddZeroClass N\nx✝ : AddCommGroup P\nf : AddMonoidHom M (AddMonoidHom N P)\nm₁ m₂ : M\nn : N\n⊢ Eq ((f (HSub.hSub m₁ m₂)) n) (HSub.hSub ((f m₁) n) ((f m₂) n))","decl":"@[to_additive]\ntheorem map_div₂ {_ : Group M} {_ : MulOneClass N} {_ : CommGroup P} (f : M →* N →* P)\n    (m₁ m₂ : M) (n : N) : f (m₁ / m₂) n = f m₁ n / f m₂ n :=\n  (flip f n).map_div _ _\n\n"}
{"name":"MonoidHom.map_div₂","module":"Mathlib.Algebra.Group.Hom.Instances","initialProofState":"M : Type uM\nN : Type uN\nP : Type uP\nx✝² : Group M\nx✝¹ : MulOneClass N\nx✝ : CommGroup P\nf : MonoidHom M (MonoidHom N P)\nm₁ m₂ : M\nn : N\n⊢ Eq ((f (HDiv.hDiv m₁ m₂)) n) (HDiv.hDiv ((f m₁) n) ((f m₂) n))","decl":"@[to_additive]\ntheorem map_div₂ {_ : Group M} {_ : MulOneClass N} {_ : CommGroup P} (f : M →* N →* P)\n    (m₁ m₂ : M) (n : N) : f (m₁ / m₂) n = f m₁ n / f m₂ n :=\n  (flip f n).map_div _ _\n\n"}
{"name":"AddMonoidHom.eval_apply_apply","module":"Mathlib.Algebra.Group.Hom.Instances","initialProofState":"M : Type uM\nN : Type uN\ninst✝¹ : AddZeroClass M\ninst✝ : AddCommMonoid N\ny : M\nx : AddMonoidHom M N\n⊢ Eq ((AddMonoidHom.eval y) x) (x y)","decl":"/-- Evaluation of a `MonoidHom` at a point as a monoid homomorphism. See also `MonoidHom.apply`\nfor the evaluation of any function at a point. -/\n@[to_additive (attr := simps!)\n      \"Evaluation of an `AddMonoidHom` at a point as an additive monoid homomorphism.\n      See also `AddMonoidHom.apply` for the evaluation of any function at a point.\"]\ndef eval [MulOneClass M] [CommMonoid N] : M →* (M →* N) →* N :=\n  (MonoidHom.id (M →* N)).flip\n\n"}
{"name":"MonoidHom.eval_apply_apply","module":"Mathlib.Algebra.Group.Hom.Instances","initialProofState":"M : Type uM\nN : Type uN\ninst✝¹ : MulOneClass M\ninst✝ : CommMonoid N\ny : M\nx : MonoidHom M N\n⊢ Eq ((MonoidHom.eval y) x) (x y)","decl":"/-- Evaluation of a `MonoidHom` at a point as a monoid homomorphism. See also `MonoidHom.apply`\nfor the evaluation of any function at a point. -/\n@[to_additive (attr := simps!)\n      \"Evaluation of an `AddMonoidHom` at a point as an additive monoid homomorphism.\n      See also `AddMonoidHom.apply` for the evaluation of any function at a point.\"]\ndef eval [MulOneClass M] [CommMonoid N] : M →* (M →* N) →* N :=\n  (MonoidHom.id (M →* N)).flip\n\n"}
{"name":"AddMonoidHom.compHom'_apply_apply","module":"Mathlib.Algebra.Group.Hom.Instances","initialProofState":"M : Type uM\nN : Type uN\nP : Type uP\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddCommMonoid P\nf : AddMonoidHom M N\ny : AddMonoidHom N P\nx : M\n⊢ Eq ((f.compHom' y) x) (y (f x))","decl":"/-- The expression `fun g m ↦ g (f m)` as a `MonoidHom`.\nEquivalently, `(fun g ↦ MonoidHom.comp g f)` as a `MonoidHom`. -/\n@[to_additive (attr := simps!)\n      \"The expression `fun g m ↦ g (f m)` as an `AddMonoidHom`.\n      Equivalently, `(fun g ↦ AddMonoidHom.comp g f)` as an `AddMonoidHom`.\n\n      This also exists in a `LinearMap` version, `LinearMap.lcomp`.\"]\ndef compHom' [MulOneClass M] [MulOneClass N] [CommMonoid P] (f : M →* N) : (N →* P) →* M →* P :=\n  flip <| eval.comp f\n\n"}
{"name":"MonoidHom.compHom'_apply_apply","module":"Mathlib.Algebra.Group.Hom.Instances","initialProofState":"M : Type uM\nN : Type uN\nP : Type uP\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : CommMonoid P\nf : MonoidHom M N\ny : MonoidHom N P\nx : M\n⊢ Eq ((f.compHom' y) x) (y (f x))","decl":"/-- The expression `fun g m ↦ g (f m)` as a `MonoidHom`.\nEquivalently, `(fun g ↦ MonoidHom.comp g f)` as a `MonoidHom`. -/\n@[to_additive (attr := simps!)\n      \"The expression `fun g m ↦ g (f m)` as an `AddMonoidHom`.\n      Equivalently, `(fun g ↦ AddMonoidHom.comp g f)` as an `AddMonoidHom`.\n\n      This also exists in a `LinearMap` version, `LinearMap.lcomp`.\"]\ndef compHom' [MulOneClass M] [MulOneClass N] [CommMonoid P] (f : M →* N) : (N →* P) →* M →* P :=\n  flip <| eval.comp f\n\n"}
{"name":"MonoidHom.compHom_apply_apply","module":"Mathlib.Algebra.Group.Hom.Instances","initialProofState":"M : Type uM\nN : Type uN\nP : Type uP\ninst✝² : MulOneClass M\ninst✝¹ : CommMonoid N\ninst✝ : CommMonoid P\ng : MonoidHom N P\nhmn : MonoidHom M N\n⊢ Eq ((MonoidHom.compHom g) hmn) (g.comp hmn)","decl":"/-- Composition of monoid morphisms (`MonoidHom.comp`) as a monoid morphism.\n\nNote that unlike `MonoidHom.comp_hom'` this requires commutativity of `N`. -/\n@[to_additive (attr := simps)\n      \"Composition of additive monoid morphisms (`AddMonoidHom.comp`) as an additive\n      monoid morphism.\n\n      Note that unlike `AddMonoidHom.comp_hom'` this requires commutativity of `N`.\n\n      This also exists in a `LinearMap` version, `LinearMap.llcomp`.\"]\ndef compHom [MulOneClass M] [CommMonoid N] [CommMonoid P] :\n    (N →* P) →* (M →* N) →* M →* P where\n  toFun g := { toFun := g.comp, map_one' := comp_one g, map_mul' := comp_mul g }\n  map_one' := by\n    ext1 f\n    exact one_comp f\n  map_mul' g₁ g₂ := by\n    ext1 f\n    exact mul_comp g₁ g₂ f\n\n"}
{"name":"AddMonoidHom.compHom_apply_apply","module":"Mathlib.Algebra.Group.Hom.Instances","initialProofState":"M : Type uM\nN : Type uN\nP : Type uP\ninst✝² : AddZeroClass M\ninst✝¹ : AddCommMonoid N\ninst✝ : AddCommMonoid P\ng : AddMonoidHom N P\nhmn : AddMonoidHom M N\n⊢ Eq ((AddMonoidHom.compHom g) hmn) (g.comp hmn)","decl":"/-- Composition of monoid morphisms (`MonoidHom.comp`) as a monoid morphism.\n\nNote that unlike `MonoidHom.comp_hom'` this requires commutativity of `N`. -/\n@[to_additive (attr := simps)\n      \"Composition of additive monoid morphisms (`AddMonoidHom.comp`) as an additive\n      monoid morphism.\n\n      Note that unlike `AddMonoidHom.comp_hom'` this requires commutativity of `N`.\n\n      This also exists in a `LinearMap` version, `LinearMap.llcomp`.\"]\ndef compHom [MulOneClass M] [CommMonoid N] [CommMonoid P] :\n    (N →* P) →* (M →* N) →* M →* P where\n  toFun g := { toFun := g.comp, map_one' := comp_one g, map_mul' := comp_mul g }\n  map_one' := by\n    ext1 f\n    exact one_comp f\n  map_mul' g₁ g₂ := by\n    ext1 f\n    exact mul_comp g₁ g₂ f\n\n"}
{"name":"MonoidHom.flipHom_apply","module":"Mathlib.Algebra.Group.Hom.Instances","initialProofState":"M : Type uM\nN : Type uN\nP : Type uP\nx✝² : MulOneClass M\nx✝¹ : MulOneClass N\nx✝ : CommMonoid P\nf : MonoidHom M (MonoidHom N P)\n⊢ Eq (MonoidHom.flipHom f) f.flip","decl":"/-- Flipping arguments of monoid morphisms (`MonoidHom.flip`) as a monoid morphism. -/\n@[to_additive (attr := simps)\n      \"Flipping arguments of additive monoid morphisms (`AddMonoidHom.flip`)\n      as an additive monoid morphism.\"]\ndef flipHom {_ : MulOneClass M} {_ : MulOneClass N} {_ : CommMonoid P} :\n    (M →* N →* P) →* N →* M →* P where\n  toFun := MonoidHom.flip\n  map_one' := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"AddMonoidHom.flipHom_apply","module":"Mathlib.Algebra.Group.Hom.Instances","initialProofState":"M : Type uM\nN : Type uN\nP : Type uP\nx✝² : AddZeroClass M\nx✝¹ : AddZeroClass N\nx✝ : AddCommMonoid P\nf : AddMonoidHom M (AddMonoidHom N P)\n⊢ Eq (AddMonoidHom.flipHom f) f.flip","decl":"/-- Flipping arguments of monoid morphisms (`MonoidHom.flip`) as a monoid morphism. -/\n@[to_additive (attr := simps)\n      \"Flipping arguments of additive monoid morphisms (`AddMonoidHom.flip`)\n      as an additive monoid morphism.\"]\ndef flipHom {_ : MulOneClass M} {_ : MulOneClass N} {_ : CommMonoid P} :\n    (M →* N →* P) →* N →* M →* P where\n  toFun := MonoidHom.flip\n  map_one' := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"MonoidHom.compl₂_apply","module":"Mathlib.Algebra.Group.Hom.Instances","initialProofState":"M : Type uM\nN : Type uN\nP : Type uP\nQ : Type uQ\ninst✝³ : MulOneClass M\ninst✝² : MulOneClass N\ninst✝¹ : CommMonoid P\ninst✝ : MulOneClass Q\nf : MonoidHom M (MonoidHom N P)\ng : MonoidHom Q N\nm : M\nq : Q\n⊢ Eq (((f.compl₂ g) m) q) ((f m) (g q))","decl":"@[to_additive (attr := simp)]\ntheorem compl₂_apply [MulOneClass M] [MulOneClass N] [CommMonoid P] [MulOneClass Q]\n    (f : M →* N →* P) (g : Q →* N) (m : M) (q : Q) : (compl₂ f g) m q = f m (g q) :=\n  rfl\n\n"}
{"name":"AddMonoidHom.compl₂_apply","module":"Mathlib.Algebra.Group.Hom.Instances","initialProofState":"M : Type uM\nN : Type uN\nP : Type uP\nQ : Type uQ\ninst✝³ : AddZeroClass M\ninst✝² : AddZeroClass N\ninst✝¹ : AddCommMonoid P\ninst✝ : AddZeroClass Q\nf : AddMonoidHom M (AddMonoidHom N P)\ng : AddMonoidHom Q N\nm : M\nq : Q\n⊢ Eq (((f.compl₂ g) m) q) ((f m) (g q))","decl":"@[to_additive (attr := simp)]\ntheorem compl₂_apply [MulOneClass M] [MulOneClass N] [CommMonoid P] [MulOneClass Q]\n    (f : M →* N →* P) (g : Q →* N) (m : M) (q : Q) : (compl₂ f g) m q = f m (g q) :=\n  rfl\n\n"}
{"name":"MonoidHom.compr₂_apply","module":"Mathlib.Algebra.Group.Hom.Instances","initialProofState":"M : Type uM\nN : Type uN\nP : Type uP\nQ : Type uQ\ninst✝³ : MulOneClass M\ninst✝² : MulOneClass N\ninst✝¹ : CommMonoid P\ninst✝ : CommMonoid Q\nf : MonoidHom M (MonoidHom N P)\ng : MonoidHom P Q\nm : M\nn : N\n⊢ Eq (((f.compr₂ g) m) n) (g ((f m) n))","decl":"@[to_additive (attr := simp)]\ntheorem compr₂_apply [MulOneClass M] [MulOneClass N] [CommMonoid P] [CommMonoid Q] (f : M →* N →* P)\n    (g : P →* Q) (m : M) (n : N) : (compr₂ f g) m n = g (f m n) :=\n  rfl\n\n"}
{"name":"AddMonoidHom.compr₂_apply","module":"Mathlib.Algebra.Group.Hom.Instances","initialProofState":"M : Type uM\nN : Type uN\nP : Type uP\nQ : Type uQ\ninst✝³ : AddZeroClass M\ninst✝² : AddZeroClass N\ninst✝¹ : AddCommMonoid P\ninst✝ : AddCommMonoid Q\nf : AddMonoidHom M (AddMonoidHom N P)\ng : AddMonoidHom P Q\nm : M\nn : N\n⊢ Eq (((f.compr₂ g) m) n) (g ((f m) n))","decl":"@[to_additive (attr := simp)]\ntheorem compr₂_apply [MulOneClass M] [MulOneClass N] [CommMonoid P] [CommMonoid Q] (f : M →* N →* P)\n    (g : P →* Q) (m : M) (n : N) : (compr₂ f g) m n = g (f m n) :=\n  rfl\n\n"}
