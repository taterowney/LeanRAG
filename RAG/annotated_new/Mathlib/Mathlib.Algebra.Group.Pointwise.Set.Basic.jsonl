{"name":"Set.singleton_zero","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Zero α\n⊢ Eq (Singleton.singleton 0) 0","decl":"@[to_additive]\ntheorem singleton_one : ({1} : Set α) = 1 :=\n  rfl\n\n"}
{"name":"Set.singleton_one","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : One α\n⊢ Eq (Singleton.singleton 1) 1","decl":"@[to_additive]\ntheorem singleton_one : ({1} : Set α) = 1 :=\n  rfl\n\n"}
{"name":"Set.mem_zero","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Zero α\na : α\n⊢ Iff (Membership.mem 0 a) (Eq a 0)","decl":"@[to_additive (attr := simp)]\ntheorem mem_one : a ∈ (1 : Set α) ↔ a = 1 :=\n  Iff.rfl\n\n"}
{"name":"Set.mem_one","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : One α\na : α\n⊢ Iff (Membership.mem 1 a) (Eq a 1)","decl":"@[to_additive (attr := simp)]\ntheorem mem_one : a ∈ (1 : Set α) ↔ a = 1 :=\n  Iff.rfl\n\n"}
{"name":"Set.one_mem_one","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : One α\n⊢ Membership.mem 1 1","decl":"@[to_additive]\ntheorem one_mem_one : (1 : α) ∈ (1 : Set α) :=\n  Eq.refl _\n\n"}
{"name":"Set.zero_mem_zero","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Zero α\n⊢ Membership.mem 0 0","decl":"@[to_additive]\ntheorem one_mem_one : (1 : α) ∈ (1 : Set α) :=\n  Eq.refl _\n\n"}
{"name":"Set.zero_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Zero α\ns : Set α\n⊢ Iff (HasSubset.Subset 0 s) (Membership.mem s 0)","decl":"@[to_additive (attr := simp)]\ntheorem one_subset : 1 ⊆ s ↔ (1 : α) ∈ s :=\n  singleton_subset_iff\n\n"}
{"name":"Set.one_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : One α\ns : Set α\n⊢ Iff (HasSubset.Subset 1 s) (Membership.mem s 1)","decl":"@[to_additive (attr := simp)]\ntheorem one_subset : 1 ⊆ s ↔ (1 : α) ∈ s :=\n  singleton_subset_iff\n\n"}
{"name":"Set.zero_nonempty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Zero α\n⊢ Set.Nonempty 0","decl":"@[to_additive (attr := simp)]\ntheorem one_nonempty : (1 : Set α).Nonempty :=\n  ⟨1, rfl⟩\n\n"}
{"name":"Set.one_nonempty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : One α\n⊢ Set.Nonempty 1","decl":"@[to_additive (attr := simp)]\ntheorem one_nonempty : (1 : Set α).Nonempty :=\n  ⟨1, rfl⟩\n\n"}
{"name":"Set.image_one","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : One α\nf : α → β\n⊢ Eq (Set.image f 1) (Singleton.singleton (f 1))","decl":"@[to_additive (attr := simp)]\ntheorem image_one {f : α → β} : f '' 1 = {f 1} :=\n  image_singleton\n\n"}
{"name":"Set.image_zero","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : Zero α\nf : α → β\n⊢ Eq (Set.image f 0) (Singleton.singleton (f 0))","decl":"@[to_additive (attr := simp)]\ntheorem image_one {f : α → β} : f '' 1 = {f 1} :=\n  image_singleton\n\n"}
{"name":"Set.subset_zero_iff_eq","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Zero α\ns : Set α\n⊢ Iff (HasSubset.Subset s 0) (Or (Eq s EmptyCollection.emptyCollection) (Eq s 0))","decl":"@[to_additive]\ntheorem subset_one_iff_eq : s ⊆ 1 ↔ s = ∅ ∨ s = 1 :=\n  subset_singleton_iff_eq\n\n"}
{"name":"Set.subset_one_iff_eq","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : One α\ns : Set α\n⊢ Iff (HasSubset.Subset s 1) (Or (Eq s EmptyCollection.emptyCollection) (Eq s 1))","decl":"@[to_additive]\ntheorem subset_one_iff_eq : s ⊆ 1 ↔ s = ∅ ∨ s = 1 :=\n  subset_singleton_iff_eq\n\n"}
{"name":"Set.Nonempty.subset_one_iff","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : One α\ns : Set α\nh : s.Nonempty\n⊢ Iff (HasSubset.Subset s 1) (Eq s 1)","decl":"@[to_additive]\ntheorem Nonempty.subset_one_iff (h : s.Nonempty) : s ⊆ 1 ↔ s = 1 :=\n  h.subset_singleton_iff\n\n"}
{"name":"Set.Nonempty.subset_zero_iff","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Zero α\ns : Set α\nh : s.Nonempty\n⊢ Iff (HasSubset.Subset s 0) (Eq s 0)","decl":"@[to_additive]\ntheorem Nonempty.subset_one_iff (h : s.Nonempty) : s ⊆ 1 ↔ s = 1 :=\n  h.subset_singleton_iff\n\n"}
{"name":"Set.coe_singletonZeroHom","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Zero α\n⊢ Eq (⇑Set.singletonZeroHom) Singleton.singleton","decl":"@[to_additive (attr := simp)]\ntheorem coe_singletonOneHom : (singletonOneHom : α → Set α) = singleton :=\n  rfl\n\n"}
{"name":"Set.coe_singletonOneHom","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : One α\n⊢ Eq (⇑Set.singletonOneHom) Singleton.singleton","decl":"@[to_additive (attr := simp)]\ntheorem coe_singletonOneHom : (singletonOneHom : α → Set α) = singleton :=\n  rfl\n\n"}
{"name":"Set.image_op_zero","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Zero α\n⊢ Eq (Set.image AddOpposite.op 0) 0","decl":"@[to_additive] lemma image_op_one : (1 : Set α).image op = 1 := image_singleton\n\n"}
{"name":"Set.image_op_one","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : One α\n⊢ Eq (Set.image MulOpposite.op 1) 1","decl":"@[to_additive] lemma image_op_one : (1 : Set α).image op = 1 := image_singleton\n\n"}
{"name":"Set.zero_sum_zero","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Zero α\ninst✝ : Zero β\n⊢ Eq (SProd.sprod 0 0) 0","decl":"@[to_additive (attr := simp)]\nlemma one_prod_one [One β] : (1 ×ˢ 1 : Set (α × β)) = 1 := by ext; simp [Prod.ext_iff]\n\n"}
{"name":"Set.one_prod_one","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : One α\ninst✝ : One β\n⊢ Eq (SProd.sprod 1 1) 1","decl":"@[to_additive (attr := simp)]\nlemma one_prod_one [One β] : (1 ×ˢ 1 : Set (α × β)) = 1 := by ext; simp [Prod.ext_iff]\n\n"}
{"name":"Set.mem_inv","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Inv α\ns : Set α\na : α\n⊢ Iff (Membership.mem (Inv.inv s) a) (Membership.mem s (Inv.inv a))","decl":"@[to_additive (attr := simp)]\ntheorem mem_inv : a ∈ s⁻¹ ↔ a⁻¹ ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Set.mem_neg","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Neg α\ns : Set α\na : α\n⊢ Iff (Membership.mem (Neg.neg s) a) (Membership.mem s (Neg.neg a))","decl":"@[to_additive (attr := simp)]\ntheorem mem_inv : a ∈ s⁻¹ ↔ a⁻¹ ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Set.inv_preimage","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Inv α\ns : Set α\n⊢ Eq (Set.preimage Inv.inv s) (Inv.inv s)","decl":"@[to_additive (attr := simp)]\ntheorem inv_preimage : Inv.inv ⁻¹' s = s⁻¹ :=\n  rfl\n\n"}
{"name":"Set.neg_preimage","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Neg α\ns : Set α\n⊢ Eq (Set.preimage Neg.neg s) (Neg.neg s)","decl":"@[to_additive (attr := simp)]\ntheorem inv_preimage : Inv.inv ⁻¹' s = s⁻¹ :=\n  rfl\n\n"}
{"name":"Set.neg_empty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Neg α\n⊢ Eq (Neg.neg EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)]\ntheorem inv_empty : (∅ : Set α)⁻¹ = ∅ :=\n  rfl\n\n"}
{"name":"Set.inv_empty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Inv α\n⊢ Eq (Inv.inv EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)]\ntheorem inv_empty : (∅ : Set α)⁻¹ = ∅ :=\n  rfl\n\n"}
{"name":"Set.neg_univ","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Neg α\n⊢ Eq (Neg.neg Set.univ) Set.univ","decl":"@[to_additive (attr := simp)]\ntheorem inv_univ : (univ : Set α)⁻¹ = univ :=\n  rfl\n\n"}
{"name":"Set.inv_univ","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Inv α\n⊢ Eq (Inv.inv Set.univ) Set.univ","decl":"@[to_additive (attr := simp)]\ntheorem inv_univ : (univ : Set α)⁻¹ = univ :=\n  rfl\n\n"}
{"name":"Set.inter_neg","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Neg α\ns t : Set α\n⊢ Eq (Neg.neg (Inter.inter s t)) (Inter.inter (Neg.neg s) (Neg.neg t))","decl":"@[to_additive (attr := simp)]\ntheorem inter_inv : (s ∩ t)⁻¹ = s⁻¹ ∩ t⁻¹ :=\n  preimage_inter\n\n"}
{"name":"Set.inter_inv","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Inv α\ns t : Set α\n⊢ Eq (Inv.inv (Inter.inter s t)) (Inter.inter (Inv.inv s) (Inv.inv t))","decl":"@[to_additive (attr := simp)]\ntheorem inter_inv : (s ∩ t)⁻¹ = s⁻¹ ∩ t⁻¹ :=\n  preimage_inter\n\n"}
{"name":"Set.union_inv","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Inv α\ns t : Set α\n⊢ Eq (Inv.inv (Union.union s t)) (Union.union (Inv.inv s) (Inv.inv t))","decl":"@[to_additive (attr := simp)]\ntheorem union_inv : (s ∪ t)⁻¹ = s⁻¹ ∪ t⁻¹ :=\n  preimage_union\n\n"}
{"name":"Set.union_neg","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Neg α\ns t : Set α\n⊢ Eq (Neg.neg (Union.union s t)) (Union.union (Neg.neg s) (Neg.neg t))","decl":"@[to_additive (attr := simp)]\ntheorem union_inv : (s ∪ t)⁻¹ = s⁻¹ ∪ t⁻¹ :=\n  preimage_union\n\n"}
{"name":"Set.iInter_neg","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\ninst✝ : Neg α\ns : ι → Set α\n⊢ Eq (Neg.neg (Set.iInter fun i => s i)) (Set.iInter fun i => Neg.neg (s i))","decl":"@[to_additive (attr := simp)]\ntheorem iInter_inv (s : ι → Set α) : (⋂ i, s i)⁻¹ = ⋂ i, (s i)⁻¹ :=\n  preimage_iInter\n\n"}
{"name":"Set.iInter_inv","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\ninst✝ : Inv α\ns : ι → Set α\n⊢ Eq (Inv.inv (Set.iInter fun i => s i)) (Set.iInter fun i => Inv.inv (s i))","decl":"@[to_additive (attr := simp)]\ntheorem iInter_inv (s : ι → Set α) : (⋂ i, s i)⁻¹ = ⋂ i, (s i)⁻¹ :=\n  preimage_iInter\n\n"}
{"name":"Set.sInter_neg","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Neg α\nS : Set (Set α)\n⊢ Eq (Neg.neg S.sInter) (Set.iInter fun s => Set.iInter fun h => Neg.neg s)","decl":"@[to_additive (attr := simp)]\ntheorem sInter_inv (S : Set (Set α)) : (⋂₀ S)⁻¹ = ⋂ s ∈ S, s⁻¹ :=\n  preimage_sInter\n\n"}
{"name":"Set.sInter_inv","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Inv α\nS : Set (Set α)\n⊢ Eq (Inv.inv S.sInter) (Set.iInter fun s => Set.iInter fun h => Inv.inv s)","decl":"@[to_additive (attr := simp)]\ntheorem sInter_inv (S : Set (Set α)) : (⋂₀ S)⁻¹ = ⋂ s ∈ S, s⁻¹ :=\n  preimage_sInter\n\n"}
{"name":"Set.iUnion_neg","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\ninst✝ : Neg α\ns : ι → Set α\n⊢ Eq (Neg.neg (Set.iUnion fun i => s i)) (Set.iUnion fun i => Neg.neg (s i))","decl":"@[to_additive (attr := simp)]\ntheorem iUnion_inv (s : ι → Set α) : (⋃ i, s i)⁻¹ = ⋃ i, (s i)⁻¹ :=\n  preimage_iUnion\n\n"}
{"name":"Set.iUnion_inv","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\ninst✝ : Inv α\ns : ι → Set α\n⊢ Eq (Inv.inv (Set.iUnion fun i => s i)) (Set.iUnion fun i => Inv.inv (s i))","decl":"@[to_additive (attr := simp)]\ntheorem iUnion_inv (s : ι → Set α) : (⋃ i, s i)⁻¹ = ⋃ i, (s i)⁻¹ :=\n  preimage_iUnion\n\n"}
{"name":"Set.sUnion_neg","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Neg α\nS : Set (Set α)\n⊢ Eq (Neg.neg S.sUnion) (Set.iUnion fun s => Set.iUnion fun h => Neg.neg s)","decl":"@[to_additive (attr := simp)]\ntheorem sUnion_inv (S : Set (Set α)) : (⋃₀ S)⁻¹ = ⋃ s ∈ S, s⁻¹ :=\n  preimage_sUnion\n\n"}
{"name":"Set.sUnion_inv","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Inv α\nS : Set (Set α)\n⊢ Eq (Inv.inv S.sUnion) (Set.iUnion fun s => Set.iUnion fun h => Inv.inv s)","decl":"@[to_additive (attr := simp)]\ntheorem sUnion_inv (S : Set (Set α)) : (⋃₀ S)⁻¹ = ⋃ s ∈ S, s⁻¹ :=\n  preimage_sUnion\n\n"}
{"name":"Set.compl_inv","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Inv α\ns : Set α\n⊢ Eq (Inv.inv (HasCompl.compl s)) (HasCompl.compl (Inv.inv s))","decl":"@[to_additive (attr := simp)]\ntheorem compl_inv : sᶜ⁻¹ = s⁻¹ᶜ :=\n  preimage_compl\n\n"}
{"name":"Set.compl_neg","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Neg α\ns : Set α\n⊢ Eq (Neg.neg (HasCompl.compl s)) (HasCompl.compl (Neg.neg s))","decl":"@[to_additive (attr := simp)]\ntheorem compl_inv : sᶜ⁻¹ = s⁻¹ᶜ :=\n  preimage_compl\n\n"}
{"name":"Set.inv_prod","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Inv α\ninst✝ : Inv β\ns : Set α\nt : Set β\n⊢ Eq (Inv.inv (SProd.sprod s t)) (SProd.sprod (Inv.inv s) (Inv.inv t))","decl":"@[to_additive (attr := simp)]\nlemma inv_prod [Inv β] (s : Set α) (t : Set β) : (s ×ˢ t)⁻¹ = s⁻¹ ×ˢ t⁻¹ := rfl\n\n"}
{"name":"Set.neg_sum","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Neg α\ninst✝ : Neg β\ns : Set α\nt : Set β\n⊢ Eq (Neg.neg (SProd.sprod s t)) (SProd.sprod (Neg.neg s) (Neg.neg t))","decl":"@[to_additive (attr := simp)]\nlemma inv_prod [Inv β] (s : Set α) (t : Set β) : (s ×ˢ t)⁻¹ = s⁻¹ ×ˢ t⁻¹ := rfl\n\n"}
{"name":"Set.neg_mem_neg","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : InvolutiveNeg α\ns : Set α\na : α\n⊢ Iff (Membership.mem (Neg.neg s) (Neg.neg a)) (Membership.mem s a)","decl":"@[to_additive]\ntheorem inv_mem_inv : a⁻¹ ∈ s⁻¹ ↔ a ∈ s := by simp only [mem_inv, inv_inv]\n\n"}
{"name":"Set.inv_mem_inv","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : InvolutiveInv α\ns : Set α\na : α\n⊢ Iff (Membership.mem (Inv.inv s) (Inv.inv a)) (Membership.mem s a)","decl":"@[to_additive]\ntheorem inv_mem_inv : a⁻¹ ∈ s⁻¹ ↔ a ∈ s := by simp only [mem_inv, inv_inv]\n\n"}
{"name":"Set.nonempty_inv","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : InvolutiveInv α\ns : Set α\n⊢ Iff (Inv.inv s).Nonempty s.Nonempty","decl":"@[to_additive (attr := simp)]\ntheorem nonempty_inv : s⁻¹.Nonempty ↔ s.Nonempty :=\n  inv_involutive.surjective.nonempty_preimage\n\n"}
{"name":"Set.nonempty_neg","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : InvolutiveNeg α\ns : Set α\n⊢ Iff (Neg.neg s).Nonempty s.Nonempty","decl":"@[to_additive (attr := simp)]\ntheorem nonempty_inv : s⁻¹.Nonempty ↔ s.Nonempty :=\n  inv_involutive.surjective.nonempty_preimage\n\n"}
{"name":"Set.Nonempty.inv","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : InvolutiveInv α\ns : Set α\nh : s.Nonempty\n⊢ (Inv.inv s).Nonempty","decl":"@[to_additive]\ntheorem Nonempty.inv (h : s.Nonempty) : s⁻¹.Nonempty :=\n  nonempty_inv.2 h\n\n"}
{"name":"Set.Nonempty.neg","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : InvolutiveNeg α\ns : Set α\nh : s.Nonempty\n⊢ (Neg.neg s).Nonempty","decl":"@[to_additive]\ntheorem Nonempty.inv (h : s.Nonempty) : s⁻¹.Nonempty :=\n  nonempty_inv.2 h\n\n"}
{"name":"Set.image_inv_eq_inv","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : InvolutiveInv α\ns : Set α\n⊢ Eq (Set.image (fun x => Inv.inv x) s) (Inv.inv s)","decl":"@[to_additive (attr := simp)]\ntheorem image_inv_eq_inv : (·⁻¹) '' s = s⁻¹ :=\n  congr_fun (image_eq_preimage_of_inverse inv_involutive.leftInverse inv_involutive.rightInverse) _\n\n"}
{"name":"Set.image_neg_eq_neg","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : InvolutiveNeg α\ns : Set α\n⊢ Eq (Set.image (fun x => Neg.neg x) s) (Neg.neg s)","decl":"@[to_additive (attr := simp)]\ntheorem image_inv_eq_inv : (·⁻¹) '' s = s⁻¹ :=\n  congr_fun (image_eq_preimage_of_inverse inv_involutive.leftInverse inv_involutive.rightInverse) _\n\n"}
{"name":"Set.inv_eq_empty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : InvolutiveInv α\ns : Set α\n⊢ Iff (Eq (Inv.inv s) EmptyCollection.emptyCollection) (Eq s EmptyCollection.emptyCollection)","decl":"@[to_additive (attr := simp)]\ntheorem inv_eq_empty : s⁻¹ = ∅ ↔ s = ∅ := by\n  rw [← image_inv_eq_inv, image_eq_empty]\n\n"}
{"name":"Set.neg_eq_empty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : InvolutiveNeg α\ns : Set α\n⊢ Iff (Eq (Neg.neg s) EmptyCollection.emptyCollection) (Eq s EmptyCollection.emptyCollection)","decl":"@[to_additive (attr := simp)]\ntheorem inv_eq_empty : s⁻¹ = ∅ ↔ s = ∅ := by\n  rw [← image_inv_eq_inv, image_eq_empty]\n\n"}
{"name":"Set.inv_subset_inv","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : InvolutiveInv α\ns t : Set α\n⊢ Iff (HasSubset.Subset (Inv.inv s) (Inv.inv t)) (HasSubset.Subset s t)","decl":"@[to_additive (attr := simp)]\ntheorem inv_subset_inv : s⁻¹ ⊆ t⁻¹ ↔ s ⊆ t :=\n  (Equiv.inv α).surjective.preimage_subset_preimage_iff\n\n"}
{"name":"Set.neg_subset_neg","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : InvolutiveNeg α\ns t : Set α\n⊢ Iff (HasSubset.Subset (Neg.neg s) (Neg.neg t)) (HasSubset.Subset s t)","decl":"@[to_additive (attr := simp)]\ntheorem inv_subset_inv : s⁻¹ ⊆ t⁻¹ ↔ s ⊆ t :=\n  (Equiv.inv α).surjective.preimage_subset_preimage_iff\n\n"}
{"name":"Set.inv_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : InvolutiveInv α\ns t : Set α\n⊢ Iff (HasSubset.Subset (Inv.inv s) t) (HasSubset.Subset s (Inv.inv t))","decl":"@[to_additive]\ntheorem inv_subset : s⁻¹ ⊆ t ↔ s ⊆ t⁻¹ := by rw [← inv_subset_inv, inv_inv]\n\n"}
{"name":"Set.neg_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : InvolutiveNeg α\ns t : Set α\n⊢ Iff (HasSubset.Subset (Neg.neg s) t) (HasSubset.Subset s (Neg.neg t))","decl":"@[to_additive]\ntheorem inv_subset : s⁻¹ ⊆ t ↔ s ⊆ t⁻¹ := by rw [← inv_subset_inv, inv_inv]\n\n"}
{"name":"Set.inv_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : InvolutiveInv α\na : α\n⊢ Eq (Inv.inv (Singleton.singleton a)) (Singleton.singleton (Inv.inv a))","decl":"@[to_additive (attr := simp)]\ntheorem inv_singleton (a : α) : ({a} : Set α)⁻¹ = {a⁻¹} := by\n  rw [← image_inv_eq_inv, image_singleton]\n\n"}
{"name":"Set.neg_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : InvolutiveNeg α\na : α\n⊢ Eq (Neg.neg (Singleton.singleton a)) (Singleton.singleton (Neg.neg a))","decl":"@[to_additive (attr := simp)]\ntheorem inv_singleton (a : α) : ({a} : Set α)⁻¹ = {a⁻¹} := by\n  rw [← image_inv_eq_inv, image_singleton]\n\n"}
{"name":"Set.inv_insert","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : InvolutiveInv α\na : α\ns : Set α\n⊢ Eq (Inv.inv (Insert.insert a s)) (Insert.insert (Inv.inv a) (Inv.inv s))","decl":"@[to_additive (attr := simp)]\ntheorem inv_insert (a : α) (s : Set α) : (insert a s)⁻¹ = insert a⁻¹ s⁻¹ := by\n  rw [insert_eq, union_inv, inv_singleton, insert_eq]\n\n"}
{"name":"Set.neg_insert","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : InvolutiveNeg α\na : α\ns : Set α\n⊢ Eq (Neg.neg (Insert.insert a s)) (Insert.insert (Neg.neg a) (Neg.neg s))","decl":"@[to_additive (attr := simp)]\ntheorem inv_insert (a : α) (s : Set α) : (insert a s)⁻¹ = insert a⁻¹ s⁻¹ := by\n  rw [insert_eq, union_inv, inv_singleton, insert_eq]\n\n"}
{"name":"Set.neg_range","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : InvolutiveNeg α\nι : Sort u_5\nf : ι → α\n⊢ Eq (Neg.neg (Set.range f)) (Set.range fun i => Neg.neg (f i))","decl":"@[to_additive]\ntheorem inv_range {ι : Sort*} {f : ι → α} : (range f)⁻¹ = range fun i => (f i)⁻¹ := by\n  rw [← image_inv_eq_inv]\n  exact (range_comp ..).symm\n\n"}
{"name":"Set.inv_range","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : InvolutiveInv α\nι : Sort u_5\nf : ι → α\n⊢ Eq (Inv.inv (Set.range f)) (Set.range fun i => Inv.inv (f i))","decl":"@[to_additive]\ntheorem inv_range {ι : Sort*} {f : ι → α} : (range f)⁻¹ = range fun i => (f i)⁻¹ := by\n  rw [← image_inv_eq_inv]\n  exact (range_comp ..).symm\n\n"}
{"name":"Set.image_op_inv","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : InvolutiveInv α\ns : Set α\n⊢ Eq (Set.image MulOpposite.op (Inv.inv s)) (Inv.inv (Set.image MulOpposite.op s))","decl":"@[to_additive]\ntheorem image_op_inv : op '' s⁻¹ = (op '' s)⁻¹ := by\n  simp_rw [← image_inv_eq_inv, Function.Semiconj.set_image op_inv s]\n\n"}
{"name":"Set.image_op_neg","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : InvolutiveNeg α\ns : Set α\n⊢ Eq (Set.image AddOpposite.op (Neg.neg s)) (Neg.neg (Set.image AddOpposite.op s))","decl":"@[to_additive]\ntheorem image_op_inv : op '' s⁻¹ = (op '' s)⁻¹ := by\n  simp_rw [← image_inv_eq_inv, Function.Semiconj.set_image op_inv s]\n\n"}
{"name":"Set.image2_mul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns t : Set α\n⊢ Eq (Set.image2 (fun x1 x2 => HMul.hMul x1 x2) s t) (HMul.hMul s t)","decl":"@[to_additive (attr := simp)]\ntheorem image2_mul : image2 (· * ·) s t = s * t :=\n  rfl\n\n"}
{"name":"Set.image2_add","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\ns t : Set α\n⊢ Eq (Set.image2 (fun x1 x2 => HAdd.hAdd x1 x2) s t) (HAdd.hAdd s t)","decl":"@[to_additive (attr := simp)]\ntheorem image2_mul : image2 (· * ·) s t = s * t :=\n  rfl\n\n"}
{"name":"Set.mem_mul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns t : Set α\na : α\n⊢ Iff (Membership.mem (HMul.hMul s t) a) (Exists fun x => And (Membership.mem s x) (Exists fun y => And (Membership.mem t y) (Eq (HMul.hMul x y) a)))","decl":"@[to_additive]\ntheorem mem_mul : a ∈ s * t ↔ ∃ x ∈ s, ∃ y ∈ t, x * y = a :=\n  Iff.rfl\n\n"}
{"name":"Set.mem_add","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\ns t : Set α\na : α\n⊢ Iff (Membership.mem (HAdd.hAdd s t) a) (Exists fun x => And (Membership.mem s x) (Exists fun y => And (Membership.mem t y) (Eq (HAdd.hAdd x y) a)))","decl":"@[to_additive]\ntheorem mem_mul : a ∈ s * t ↔ ∃ x ∈ s, ∃ y ∈ t, x * y = a :=\n  Iff.rfl\n\n"}
{"name":"Set.mul_mem_mul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns t : Set α\na b : α\na✝¹ : Membership.mem s a\na✝ : Membership.mem t b\n⊢ Membership.mem (HMul.hMul s t) (HMul.hMul a b)","decl":"@[to_additive]\ntheorem mul_mem_mul : a ∈ s → b ∈ t → a * b ∈ s * t :=\n  mem_image2_of_mem\n\n"}
{"name":"Set.add_mem_add","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\ns t : Set α\na b : α\na✝¹ : Membership.mem s a\na✝ : Membership.mem t b\n⊢ Membership.mem (HAdd.hAdd s t) (HAdd.hAdd a b)","decl":"@[to_additive]\ntheorem mul_mem_mul : a ∈ s → b ∈ t → a * b ∈ s * t :=\n  mem_image2_of_mem\n\n"}
{"name":"Set.image_mul_prod","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns t : Set α\n⊢ Eq (Set.image (fun x => HMul.hMul x.1 x.2) (SProd.sprod s t)) (HMul.hMul s t)","decl":"@[to_additive add_image_prod]\ntheorem image_mul_prod : (fun x : α × α => x.fst * x.snd) '' s ×ˢ t = s * t :=\n  image_prod _\n\n"}
{"name":"Set.add_image_prod","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\ns t : Set α\n⊢ Eq (Set.image (fun x => HAdd.hAdd x.1 x.2) (SProd.sprod s t)) (HAdd.hAdd s t)","decl":"@[to_additive add_image_prod]\ntheorem image_mul_prod : (fun x : α × α => x.fst * x.snd) '' s ×ˢ t = s * t :=\n  image_prod _\n\n"}
{"name":"Set.empty_add","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\ns : Set α\n⊢ Eq (HAdd.hAdd EmptyCollection.emptyCollection s) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)]\ntheorem empty_mul : ∅ * s = ∅ :=\n  image2_empty_left\n\n"}
{"name":"Set.empty_mul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns : Set α\n⊢ Eq (HMul.hMul EmptyCollection.emptyCollection s) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)]\ntheorem empty_mul : ∅ * s = ∅ :=\n  image2_empty_left\n\n"}
{"name":"Set.mul_empty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns : Set α\n⊢ Eq (HMul.hMul s EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)]\ntheorem mul_empty : s * ∅ = ∅ :=\n  image2_empty_right\n\n"}
{"name":"Set.add_empty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\ns : Set α\n⊢ Eq (HAdd.hAdd s EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)]\ntheorem mul_empty : s * ∅ = ∅ :=\n  image2_empty_right\n\n"}
{"name":"Set.add_eq_empty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\ns t : Set α\n⊢ Iff (Eq (HAdd.hAdd s t) EmptyCollection.emptyCollection) (Or (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection))","decl":"@[to_additive (attr := simp)]\ntheorem mul_eq_empty : s * t = ∅ ↔ s = ∅ ∨ t = ∅ :=\n  image2_eq_empty_iff\n\n"}
{"name":"Set.mul_eq_empty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns t : Set α\n⊢ Iff (Eq (HMul.hMul s t) EmptyCollection.emptyCollection) (Or (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection))","decl":"@[to_additive (attr := simp)]\ntheorem mul_eq_empty : s * t = ∅ ↔ s = ∅ ∨ t = ∅ :=\n  image2_eq_empty_iff\n\n"}
{"name":"Set.add_nonempty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\ns t : Set α\n⊢ Iff (HAdd.hAdd s t).Nonempty (And s.Nonempty t.Nonempty)","decl":"@[to_additive (attr := simp)]\ntheorem mul_nonempty : (s * t).Nonempty ↔ s.Nonempty ∧ t.Nonempty :=\n  image2_nonempty_iff\n\n"}
{"name":"Set.mul_nonempty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns t : Set α\n⊢ Iff (HMul.hMul s t).Nonempty (And s.Nonempty t.Nonempty)","decl":"@[to_additive (attr := simp)]\ntheorem mul_nonempty : (s * t).Nonempty ↔ s.Nonempty ∧ t.Nonempty :=\n  image2_nonempty_iff\n\n"}
{"name":"Set.Nonempty.mul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns t : Set α\na✝¹ : s.Nonempty\na✝ : t.Nonempty\n⊢ (HMul.hMul s t).Nonempty","decl":"@[to_additive]\ntheorem Nonempty.mul : s.Nonempty → t.Nonempty → (s * t).Nonempty :=\n  Nonempty.image2\n\n"}
{"name":"Set.Nonempty.add","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\ns t : Set α\na✝¹ : s.Nonempty\na✝ : t.Nonempty\n⊢ (HAdd.hAdd s t).Nonempty","decl":"@[to_additive]\ntheorem Nonempty.mul : s.Nonempty → t.Nonempty → (s * t).Nonempty :=\n  Nonempty.image2\n\n"}
{"name":"Set.Nonempty.of_add_left","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\ns t : Set α\na✝ : (HAdd.hAdd s t).Nonempty\n⊢ s.Nonempty","decl":"@[to_additive]\ntheorem Nonempty.of_mul_left : (s * t).Nonempty → s.Nonempty :=\n  Nonempty.of_image2_left\n\n"}
{"name":"Set.Nonempty.of_mul_left","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns t : Set α\na✝ : (HMul.hMul s t).Nonempty\n⊢ s.Nonempty","decl":"@[to_additive]\ntheorem Nonempty.of_mul_left : (s * t).Nonempty → s.Nonempty :=\n  Nonempty.of_image2_left\n\n"}
{"name":"Set.Nonempty.of_mul_right","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns t : Set α\na✝ : (HMul.hMul s t).Nonempty\n⊢ t.Nonempty","decl":"@[to_additive]\ntheorem Nonempty.of_mul_right : (s * t).Nonempty → t.Nonempty :=\n  Nonempty.of_image2_right\n\n"}
{"name":"Set.Nonempty.of_add_right","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\ns t : Set α\na✝ : (HAdd.hAdd s t).Nonempty\n⊢ t.Nonempty","decl":"@[to_additive]\ntheorem Nonempty.of_mul_right : (s * t).Nonempty → t.Nonempty :=\n  Nonempty.of_image2_right\n\n"}
{"name":"Set.mul_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns : Set α\nb : α\n⊢ Eq (HMul.hMul s (Singleton.singleton b)) (Set.image (fun x => HMul.hMul x b) s)","decl":"@[to_additive (attr := simp)]\ntheorem mul_singleton : s * {b} = (· * b) '' s :=\n  image2_singleton_right\n\n"}
{"name":"Set.add_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\ns : Set α\nb : α\n⊢ Eq (HAdd.hAdd s (Singleton.singleton b)) (Set.image (fun x => HAdd.hAdd x b) s)","decl":"@[to_additive (attr := simp)]\ntheorem mul_singleton : s * {b} = (· * b) '' s :=\n  image2_singleton_right\n\n"}
{"name":"Set.singleton_add","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\nt : Set α\na : α\n⊢ Eq (HAdd.hAdd (Singleton.singleton a) t) (Set.image (fun x => HAdd.hAdd a x) t)","decl":"@[to_additive (attr := simp)]\ntheorem singleton_mul : {a} * t = (a * ·) '' t :=\n  image2_singleton_left\n\n"}
{"name":"Set.singleton_mul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\nt : Set α\na : α\n⊢ Eq (HMul.hMul (Singleton.singleton a) t) (Set.image (fun x => HMul.hMul a x) t)","decl":"@[to_additive (attr := simp)]\ntheorem singleton_mul : {a} * t = (a * ·) '' t :=\n  image2_singleton_left\n\n"}
{"name":"Set.singleton_add_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\na b : α\n⊢ Eq (HAdd.hAdd (Singleton.singleton a) (Singleton.singleton b)) (Singleton.singleton (HAdd.hAdd a b))","decl":"@[to_additive]\ntheorem singleton_mul_singleton : ({a} : Set α) * {b} = {a * b} :=\n  image2_singleton\n\n"}
{"name":"Set.singleton_mul_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\na b : α\n⊢ Eq (HMul.hMul (Singleton.singleton a) (Singleton.singleton b)) (Singleton.singleton (HMul.hMul a b))","decl":"@[to_additive]\ntheorem singleton_mul_singleton : ({a} : Set α) * {b} = {a * b} :=\n  image2_singleton\n\n"}
{"name":"Set.mul_subset_mul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns₁ s₂ t₁ t₂ : Set α\na✝¹ : HasSubset.Subset s₁ t₁\na✝ : HasSubset.Subset s₂ t₂\n⊢ HasSubset.Subset (HMul.hMul s₁ s₂) (HMul.hMul t₁ t₂)","decl":"@[to_additive (attr := mono, gcongr)]\ntheorem mul_subset_mul : s₁ ⊆ t₁ → s₂ ⊆ t₂ → s₁ * s₂ ⊆ t₁ * t₂ :=\n  image2_subset\n\n"}
{"name":"Set.add_subset_add","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\ns₁ s₂ t₁ t₂ : Set α\na✝¹ : HasSubset.Subset s₁ t₁\na✝ : HasSubset.Subset s₂ t₂\n⊢ HasSubset.Subset (HAdd.hAdd s₁ s₂) (HAdd.hAdd t₁ t₂)","decl":"@[to_additive (attr := mono, gcongr)]\ntheorem mul_subset_mul : s₁ ⊆ t₁ → s₂ ⊆ t₂ → s₁ * s₂ ⊆ t₁ * t₂ :=\n  image2_subset\n\n"}
{"name":"Set.add_subset_add_left","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\ns t₁ t₂ : Set α\na✝ : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (HAdd.hAdd s t₁) (HAdd.hAdd s t₂)","decl":"@[to_additive (attr := gcongr)]\ntheorem mul_subset_mul_left : t₁ ⊆ t₂ → s * t₁ ⊆ s * t₂ :=\n  image2_subset_left\n\n"}
{"name":"Set.mul_subset_mul_left","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns t₁ t₂ : Set α\na✝ : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (HMul.hMul s t₁) (HMul.hMul s t₂)","decl":"@[to_additive (attr := gcongr)]\ntheorem mul_subset_mul_left : t₁ ⊆ t₂ → s * t₁ ⊆ s * t₂ :=\n  image2_subset_left\n\n"}
{"name":"Set.add_subset_add_right","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\ns₁ s₂ t : Set α\na✝ : HasSubset.Subset s₁ s₂\n⊢ HasSubset.Subset (HAdd.hAdd s₁ t) (HAdd.hAdd s₂ t)","decl":"@[to_additive (attr := gcongr)]\ntheorem mul_subset_mul_right : s₁ ⊆ s₂ → s₁ * t ⊆ s₂ * t :=\n  image2_subset_right\n\n"}
{"name":"Set.mul_subset_mul_right","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns₁ s₂ t : Set α\na✝ : HasSubset.Subset s₁ s₂\n⊢ HasSubset.Subset (HMul.hMul s₁ t) (HMul.hMul s₂ t)","decl":"@[to_additive (attr := gcongr)]\ntheorem mul_subset_mul_right : s₁ ⊆ s₂ → s₁ * t ⊆ s₂ * t :=\n  image2_subset_right\n\n"}
{"name":"Set.instMulLeftMono","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\n⊢ MulLeftMono (Set α)","decl":"@[to_additive] instance : MulLeftMono (Set α) where elim _s _t₁ _t₂ := mul_subset_mul_left\n"}
{"name":"Set.instAddLeftMono","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\n⊢ AddLeftMono (Set α)","decl":"@[to_additive] instance : MulLeftMono (Set α) where elim _s _t₁ _t₂ := mul_subset_mul_left\n"}
{"name":"Set.instAddRightMono","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\n⊢ AddRightMono (Set α)","decl":"@[to_additive] instance : MulRightMono (Set α) where elim _t _s₁ _s₂ := mul_subset_mul_right\n\n"}
{"name":"Set.instMulRightMono","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\n⊢ MulRightMono (Set α)","decl":"@[to_additive] instance : MulRightMono (Set α) where elim _t _s₁ _s₂ := mul_subset_mul_right\n\n"}
{"name":"Set.add_subset_iff","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\ns t u : Set α\n⊢ Iff (HasSubset.Subset (HAdd.hAdd s t) u) (∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem t y → Membership.mem u (HAdd.hAdd x y))","decl":"@[to_additive]\ntheorem mul_subset_iff : s * t ⊆ u ↔ ∀ x ∈ s, ∀ y ∈ t, x * y ∈ u :=\n  image2_subset_iff\n\n"}
{"name":"Set.mul_subset_iff","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns t u : Set α\n⊢ Iff (HasSubset.Subset (HMul.hMul s t) u) (∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem t y → Membership.mem u (HMul.hMul x y))","decl":"@[to_additive]\ntheorem mul_subset_iff : s * t ⊆ u ↔ ∀ x ∈ s, ∀ y ∈ t, x * y ∈ u :=\n  image2_subset_iff\n\n"}
{"name":"Set.union_add","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\ns₁ s₂ t : Set α\n⊢ Eq (HAdd.hAdd (Union.union s₁ s₂) t) (Union.union (HAdd.hAdd s₁ t) (HAdd.hAdd s₂ t))","decl":"@[to_additive]\ntheorem union_mul : (s₁ ∪ s₂) * t = s₁ * t ∪ s₂ * t :=\n  image2_union_left\n\n"}
{"name":"Set.union_mul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns₁ s₂ t : Set α\n⊢ Eq (HMul.hMul (Union.union s₁ s₂) t) (Union.union (HMul.hMul s₁ t) (HMul.hMul s₂ t))","decl":"@[to_additive]\ntheorem union_mul : (s₁ ∪ s₂) * t = s₁ * t ∪ s₂ * t :=\n  image2_union_left\n\n"}
{"name":"Set.add_union","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\ns t₁ t₂ : Set α\n⊢ Eq (HAdd.hAdd s (Union.union t₁ t₂)) (Union.union (HAdd.hAdd s t₁) (HAdd.hAdd s t₂))","decl":"@[to_additive]\ntheorem mul_union : s * (t₁ ∪ t₂) = s * t₁ ∪ s * t₂ :=\n  image2_union_right\n\n"}
{"name":"Set.mul_union","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns t₁ t₂ : Set α\n⊢ Eq (HMul.hMul s (Union.union t₁ t₂)) (Union.union (HMul.hMul s t₁) (HMul.hMul s t₂))","decl":"@[to_additive]\ntheorem mul_union : s * (t₁ ∪ t₂) = s * t₁ ∪ s * t₂ :=\n  image2_union_right\n\n"}
{"name":"Set.inter_mul_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns₁ s₂ t : Set α\n⊢ HasSubset.Subset (HMul.hMul (Inter.inter s₁ s₂) t) (Inter.inter (HMul.hMul s₁ t) (HMul.hMul s₂ t))","decl":"@[to_additive]\ntheorem inter_mul_subset : s₁ ∩ s₂ * t ⊆ s₁ * t ∩ (s₂ * t) :=\n  image2_inter_subset_left\n\n"}
{"name":"Set.inter_add_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\ns₁ s₂ t : Set α\n⊢ HasSubset.Subset (HAdd.hAdd (Inter.inter s₁ s₂) t) (Inter.inter (HAdd.hAdd s₁ t) (HAdd.hAdd s₂ t))","decl":"@[to_additive]\ntheorem inter_mul_subset : s₁ ∩ s₂ * t ⊆ s₁ * t ∩ (s₂ * t) :=\n  image2_inter_subset_left\n\n"}
{"name":"Set.add_inter_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\ns t₁ t₂ : Set α\n⊢ HasSubset.Subset (HAdd.hAdd s (Inter.inter t₁ t₂)) (Inter.inter (HAdd.hAdd s t₁) (HAdd.hAdd s t₂))","decl":"@[to_additive]\ntheorem mul_inter_subset : s * (t₁ ∩ t₂) ⊆ s * t₁ ∩ (s * t₂) :=\n  image2_inter_subset_right\n\n"}
{"name":"Set.mul_inter_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns t₁ t₂ : Set α\n⊢ HasSubset.Subset (HMul.hMul s (Inter.inter t₁ t₂)) (Inter.inter (HMul.hMul s t₁) (HMul.hMul s t₂))","decl":"@[to_additive]\ntheorem mul_inter_subset : s * (t₁ ∩ t₂) ⊆ s * t₁ ∩ (s * t₂) :=\n  image2_inter_subset_right\n\n"}
{"name":"Set.inter_add_union_subset_union","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\ns₁ s₂ t₁ t₂ : Set α\n⊢ HasSubset.Subset (HAdd.hAdd (Inter.inter s₁ s₂) (Union.union t₁ t₂)) (Union.union (HAdd.hAdd s₁ t₁) (HAdd.hAdd s₂ t₂))","decl":"@[to_additive]\ntheorem inter_mul_union_subset_union : s₁ ∩ s₂ * (t₁ ∪ t₂) ⊆ s₁ * t₁ ∪ s₂ * t₂ :=\n  image2_inter_union_subset_union\n\n"}
{"name":"Set.inter_mul_union_subset_union","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns₁ s₂ t₁ t₂ : Set α\n⊢ HasSubset.Subset (HMul.hMul (Inter.inter s₁ s₂) (Union.union t₁ t₂)) (Union.union (HMul.hMul s₁ t₁) (HMul.hMul s₂ t₂))","decl":"@[to_additive]\ntheorem inter_mul_union_subset_union : s₁ ∩ s₂ * (t₁ ∪ t₂) ⊆ s₁ * t₁ ∪ s₂ * t₂ :=\n  image2_inter_union_subset_union\n\n"}
{"name":"Set.union_mul_inter_subset_union","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns₁ s₂ t₁ t₂ : Set α\n⊢ HasSubset.Subset (HMul.hMul (Union.union s₁ s₂) (Inter.inter t₁ t₂)) (Union.union (HMul.hMul s₁ t₁) (HMul.hMul s₂ t₂))","decl":"@[to_additive]\ntheorem union_mul_inter_subset_union : (s₁ ∪ s₂) * (t₁ ∩ t₂) ⊆ s₁ * t₁ ∪ s₂ * t₂ :=\n  image2_union_inter_subset_union\n\n"}
{"name":"Set.union_add_inter_subset_union","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\ns₁ s₂ t₁ t₂ : Set α\n⊢ HasSubset.Subset (HAdd.hAdd (Union.union s₁ s₂) (Inter.inter t₁ t₂)) (Union.union (HAdd.hAdd s₁ t₁) (HAdd.hAdd s₂ t₂))","decl":"@[to_additive]\ntheorem union_mul_inter_subset_union : (s₁ ∪ s₂) * (t₁ ∩ t₂) ⊆ s₁ * t₁ ∪ s₂ * t₂ :=\n  image2_union_inter_subset_union\n\n"}
{"name":"Set.iUnion_add_left_image","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\ns t : Set α\n⊢ Eq (Set.iUnion fun a => Set.iUnion fun h => Set.image (fun x => HAdd.hAdd a x) t) (HAdd.hAdd s t)","decl":"@[to_additive]\ntheorem iUnion_mul_left_image : ⋃ a ∈ s, (a * ·) '' t = s * t :=\n  iUnion_image_left _\n\n"}
{"name":"Set.iUnion_mul_left_image","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns t : Set α\n⊢ Eq (Set.iUnion fun a => Set.iUnion fun h => Set.image (fun x => HMul.hMul a x) t) (HMul.hMul s t)","decl":"@[to_additive]\ntheorem iUnion_mul_left_image : ⋃ a ∈ s, (a * ·) '' t = s * t :=\n  iUnion_image_left _\n\n"}
{"name":"Set.iUnion_mul_right_image","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns t : Set α\n⊢ Eq (Set.iUnion fun a => Set.iUnion fun h => Set.image (fun x => HMul.hMul x a) s) (HMul.hMul s t)","decl":"@[to_additive]\ntheorem iUnion_mul_right_image : ⋃ a ∈ t, (· * a) '' s = s * t :=\n  iUnion_image_right _\n\n"}
{"name":"Set.iUnion_add_right_image","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\ns t : Set α\n⊢ Eq (Set.iUnion fun a => Set.iUnion fun h => Set.image (fun x => HAdd.hAdd x a) s) (HAdd.hAdd s t)","decl":"@[to_additive]\ntheorem iUnion_mul_right_image : ⋃ a ∈ t, (· * a) '' s = s * t :=\n  iUnion_image_right _\n\n"}
{"name":"Set.iUnion_mul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\ninst✝ : Mul α\ns : ι → Set α\nt : Set α\n⊢ Eq (HMul.hMul (Set.iUnion fun i => s i) t) (Set.iUnion fun i => HMul.hMul (s i) t)","decl":"@[to_additive]\ntheorem iUnion_mul (s : ι → Set α) (t : Set α) : (⋃ i, s i) * t = ⋃ i, s i * t :=\n  image2_iUnion_left ..\n\n"}
{"name":"Set.iUnion_add","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\ninst✝ : Add α\ns : ι → Set α\nt : Set α\n⊢ Eq (HAdd.hAdd (Set.iUnion fun i => s i) t) (Set.iUnion fun i => HAdd.hAdd (s i) t)","decl":"@[to_additive]\ntheorem iUnion_mul (s : ι → Set α) (t : Set α) : (⋃ i, s i) * t = ⋃ i, s i * t :=\n  image2_iUnion_left ..\n\n"}
{"name":"Set.add_iUnion","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\ninst✝ : Add α\ns : Set α\nt : ι → Set α\n⊢ Eq (HAdd.hAdd s (Set.iUnion fun i => t i)) (Set.iUnion fun i => HAdd.hAdd s (t i))","decl":"@[to_additive]\ntheorem mul_iUnion (s : Set α) (t : ι → Set α) : (s * ⋃ i, t i) = ⋃ i, s * t i :=\n  image2_iUnion_right ..\n\n"}
{"name":"Set.mul_iUnion","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\ninst✝ : Mul α\ns : Set α\nt : ι → Set α\n⊢ Eq (HMul.hMul s (Set.iUnion fun i => t i)) (Set.iUnion fun i => HMul.hMul s (t i))","decl":"@[to_additive]\ntheorem mul_iUnion (s : Set α) (t : ι → Set α) : (s * ⋃ i, t i) = ⋃ i, s * t i :=\n  image2_iUnion_right ..\n\n"}
{"name":"Set.sUnion_add","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\nS : Set (Set α)\nt : Set α\n⊢ Eq (HAdd.hAdd S.sUnion t) (Set.iUnion fun s => Set.iUnion fun h => HAdd.hAdd s t)","decl":"@[to_additive]\ntheorem sUnion_mul (S : Set (Set α)) (t : Set α) : ⋃₀ S * t = ⋃ s ∈ S, s * t :=\n  image2_sUnion_left ..\n\n"}
{"name":"Set.sUnion_mul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\nS : Set (Set α)\nt : Set α\n⊢ Eq (HMul.hMul S.sUnion t) (Set.iUnion fun s => Set.iUnion fun h => HMul.hMul s t)","decl":"@[to_additive]\ntheorem sUnion_mul (S : Set (Set α)) (t : Set α) : ⋃₀ S * t = ⋃ s ∈ S, s * t :=\n  image2_sUnion_left ..\n\n"}
{"name":"Set.mul_sUnion","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns : Set α\nT : Set (Set α)\n⊢ Eq (HMul.hMul s T.sUnion) (Set.iUnion fun t => Set.iUnion fun h => HMul.hMul s t)","decl":"@[to_additive]\ntheorem mul_sUnion (s : Set α) (T : Set (Set α)) : s * ⋃₀ T = ⋃ t ∈ T, s * t :=\n  image2_sUnion_right ..\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.add_sUnion","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\ns : Set α\nT : Set (Set α)\n⊢ Eq (HAdd.hAdd s T.sUnion) (Set.iUnion fun t => Set.iUnion fun h => HAdd.hAdd s t)","decl":"@[to_additive]\ntheorem mul_sUnion (s : Set α) (T : Set (Set α)) : s * ⋃₀ T = ⋃ t ∈ T, s * t :=\n  image2_sUnion_right ..\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.iUnion₂_mul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\nκ : ι → Sort u_6\ninst✝ : Mul α\ns : (i : ι) → κ i → Set α\nt : Set α\n⊢ Eq (HMul.hMul (Set.iUnion fun i => Set.iUnion fun j => s i j) t) (Set.iUnion fun i => Set.iUnion fun j => HMul.hMul (s i j) t)","decl":"@[to_additive]\ntheorem iUnion₂_mul (s : ∀ i, κ i → Set α) (t : Set α) :\n    (⋃ (i) (j), s i j) * t = ⋃ (i) (j), s i j * t :=\n  image2_iUnion₂_left ..\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.iUnion₂_add","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\nκ : ι → Sort u_6\ninst✝ : Add α\ns : (i : ι) → κ i → Set α\nt : Set α\n⊢ Eq (HAdd.hAdd (Set.iUnion fun i => Set.iUnion fun j => s i j) t) (Set.iUnion fun i => Set.iUnion fun j => HAdd.hAdd (s i j) t)","decl":"@[to_additive]\ntheorem iUnion₂_mul (s : ∀ i, κ i → Set α) (t : Set α) :\n    (⋃ (i) (j), s i j) * t = ⋃ (i) (j), s i j * t :=\n  image2_iUnion₂_left ..\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.add_iUnion₂","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\nκ : ι → Sort u_6\ninst✝ : Add α\ns : Set α\nt : (i : ι) → κ i → Set α\n⊢ Eq (HAdd.hAdd s (Set.iUnion fun i => Set.iUnion fun j => t i j)) (Set.iUnion fun i => Set.iUnion fun j => HAdd.hAdd s (t i j))","decl":"@[to_additive]\ntheorem mul_iUnion₂ (s : Set α) (t : ∀ i, κ i → Set α) :\n    (s * ⋃ (i) (j), t i j) = ⋃ (i) (j), s * t i j :=\n  image2_iUnion₂_right ..\n\n"}
{"name":"Set.mul_iUnion₂","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\nκ : ι → Sort u_6\ninst✝ : Mul α\ns : Set α\nt : (i : ι) → κ i → Set α\n⊢ Eq (HMul.hMul s (Set.iUnion fun i => Set.iUnion fun j => t i j)) (Set.iUnion fun i => Set.iUnion fun j => HMul.hMul s (t i j))","decl":"@[to_additive]\ntheorem mul_iUnion₂ (s : Set α) (t : ∀ i, κ i → Set α) :\n    (s * ⋃ (i) (j), t i j) = ⋃ (i) (j), s * t i j :=\n  image2_iUnion₂_right ..\n\n"}
{"name":"Set.iInter_add_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\ninst✝ : Add α\ns : ι → Set α\nt : Set α\n⊢ HasSubset.Subset (HAdd.hAdd (Set.iInter fun i => s i) t) (Set.iInter fun i => HAdd.hAdd (s i) t)","decl":"@[to_additive]\ntheorem iInter_mul_subset (s : ι → Set α) (t : Set α) : (⋂ i, s i) * t ⊆ ⋂ i, s i * t :=\n  Set.image2_iInter_subset_left ..\n\n"}
{"name":"Set.iInter_mul_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\ninst✝ : Mul α\ns : ι → Set α\nt : Set α\n⊢ HasSubset.Subset (HMul.hMul (Set.iInter fun i => s i) t) (Set.iInter fun i => HMul.hMul (s i) t)","decl":"@[to_additive]\ntheorem iInter_mul_subset (s : ι → Set α) (t : Set α) : (⋂ i, s i) * t ⊆ ⋂ i, s i * t :=\n  Set.image2_iInter_subset_left ..\n\n"}
{"name":"Set.mul_iInter_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\ninst✝ : Mul α\ns : Set α\nt : ι → Set α\n⊢ HasSubset.Subset (HMul.hMul s (Set.iInter fun i => t i)) (Set.iInter fun i => HMul.hMul s (t i))","decl":"@[to_additive]\ntheorem mul_iInter_subset (s : Set α) (t : ι → Set α) : (s * ⋂ i, t i) ⊆ ⋂ i, s * t i :=\n  image2_iInter_subset_right ..\n\n"}
{"name":"Set.add_iInter_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\ninst✝ : Add α\ns : Set α\nt : ι → Set α\n⊢ HasSubset.Subset (HAdd.hAdd s (Set.iInter fun i => t i)) (Set.iInter fun i => HAdd.hAdd s (t i))","decl":"@[to_additive]\ntheorem mul_iInter_subset (s : Set α) (t : ι → Set α) : (s * ⋂ i, t i) ⊆ ⋂ i, s * t i :=\n  image2_iInter_subset_right ..\n\n"}
{"name":"Set.add_sInter_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\ns : Set α\nT : Set (Set α)\n⊢ HasSubset.Subset (HAdd.hAdd s T.sInter) (Set.iInter fun t => Set.iInter fun h => HAdd.hAdd s t)","decl":"@[to_additive]\nlemma mul_sInter_subset (s : Set α) (T : Set (Set α)) :\n    s * ⋂₀ T ⊆ ⋂ t ∈ T, s * t := image2_sInter_right_subset s T (fun a b => a * b)\n\n"}
{"name":"Set.mul_sInter_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns : Set α\nT : Set (Set α)\n⊢ HasSubset.Subset (HMul.hMul s T.sInter) (Set.iInter fun t => Set.iInter fun h => HMul.hMul s t)","decl":"@[to_additive]\nlemma mul_sInter_subset (s : Set α) (T : Set (Set α)) :\n    s * ⋂₀ T ⊆ ⋂ t ∈ T, s * t := image2_sInter_right_subset s T (fun a b => a * b)\n\n"}
{"name":"Set.sInter_add_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\nS : Set (Set α)\nt : Set α\n⊢ HasSubset.Subset (HAdd.hAdd S.sInter t) (Set.iInter fun s => Set.iInter fun h => HAdd.hAdd s t)","decl":"@[to_additive]\nlemma sInter_mul_subset (S : Set (Set α)) (t : Set α) :\n    ⋂₀ S * t ⊆ ⋂ s ∈ S, s * t := image2_sInter_left_subset S t (fun a b => a * b)\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.sInter_mul_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\nS : Set (Set α)\nt : Set α\n⊢ HasSubset.Subset (HMul.hMul S.sInter t) (Set.iInter fun s => Set.iInter fun h => HMul.hMul s t)","decl":"@[to_additive]\nlemma sInter_mul_subset (S : Set (Set α)) (t : Set α) :\n    ⋂₀ S * t ⊆ ⋂ s ∈ S, s * t := image2_sInter_left_subset S t (fun a b => a * b)\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.iInter₂_mul_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\nκ : ι → Sort u_6\ninst✝ : Mul α\ns : (i : ι) → κ i → Set α\nt : Set α\n⊢ HasSubset.Subset (HMul.hMul (Set.iInter fun i => Set.iInter fun j => s i j) t) (Set.iInter fun i => Set.iInter fun j => HMul.hMul (s i j) t)","decl":"@[to_additive]\ntheorem iInter₂_mul_subset (s : ∀ i, κ i → Set α) (t : Set α) :\n    (⋂ (i) (j), s i j) * t ⊆ ⋂ (i) (j), s i j * t :=\n  image2_iInter₂_subset_left ..\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.iInter₂_add_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\nκ : ι → Sort u_6\ninst✝ : Add α\ns : (i : ι) → κ i → Set α\nt : Set α\n⊢ HasSubset.Subset (HAdd.hAdd (Set.iInter fun i => Set.iInter fun j => s i j) t) (Set.iInter fun i => Set.iInter fun j => HAdd.hAdd (s i j) t)","decl":"@[to_additive]\ntheorem iInter₂_mul_subset (s : ∀ i, κ i → Set α) (t : Set α) :\n    (⋂ (i) (j), s i j) * t ⊆ ⋂ (i) (j), s i j * t :=\n  image2_iInter₂_subset_left ..\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.add_iInter₂_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\nκ : ι → Sort u_6\ninst✝ : Add α\ns : Set α\nt : (i : ι) → κ i → Set α\n⊢ HasSubset.Subset (HAdd.hAdd s (Set.iInter fun i => Set.iInter fun j => t i j)) (Set.iInter fun i => Set.iInter fun j => HAdd.hAdd s (t i j))","decl":"@[to_additive]\ntheorem mul_iInter₂_subset (s : Set α) (t : ∀ i, κ i → Set α) :\n    (s * ⋂ (i) (j), t i j) ⊆ ⋂ (i) (j), s * t i j :=\n  image2_iInter₂_subset_right ..\n\n"}
{"name":"Set.mul_iInter₂_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\nκ : ι → Sort u_6\ninst✝ : Mul α\ns : Set α\nt : (i : ι) → κ i → Set α\n⊢ HasSubset.Subset (HMul.hMul s (Set.iInter fun i => Set.iInter fun j => t i j)) (Set.iInter fun i => Set.iInter fun j => HMul.hMul s (t i j))","decl":"@[to_additive]\ntheorem mul_iInter₂_subset (s : Set α) (t : ∀ i, κ i → Set α) :\n    (s * ⋂ (i) (j), t i j) ⊆ ⋂ (i) (j), s * t i j :=\n  image2_iInter₂_subset_right ..\n\n"}
{"name":"Set.coe_singletonMulHom","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\n⊢ Eq (⇑Set.singletonMulHom) Singleton.singleton","decl":"@[to_additive (attr := simp)]\ntheorem coe_singletonMulHom : (singletonMulHom : α → Set α) = singleton :=\n  rfl\n\n"}
{"name":"Set.coe_singletonAddHom","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\n⊢ Eq (⇑Set.singletonAddHom) Singleton.singleton","decl":"@[to_additive (attr := simp)]\ntheorem coe_singletonMulHom : (singletonMulHom : α → Set α) = singleton :=\n  rfl\n\n"}
{"name":"Set.singletonAddHom_apply","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\na : α\n⊢ Eq (Set.singletonAddHom a) (Singleton.singleton a)","decl":"@[to_additive (attr := simp)]\ntheorem singletonMulHom_apply (a : α) : singletonMulHom a = {a} :=\n  rfl\n\n"}
{"name":"Set.singletonMulHom_apply","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\na : α\n⊢ Eq (Set.singletonMulHom a) (Singleton.singleton a)","decl":"@[to_additive (attr := simp)]\ntheorem singletonMulHom_apply (a : α) : singletonMulHom a = {a} :=\n  rfl\n\n"}
{"name":"Set.image_op_add","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Add α\ns t : Set α\n⊢ Eq (Set.image AddOpposite.op (HAdd.hAdd s t)) (HAdd.hAdd (Set.image AddOpposite.op t) (Set.image AddOpposite.op s))","decl":"@[to_additive (attr := simp)]\ntheorem image_op_mul : op '' (s * t) = op '' t * op '' s :=\n  image_image2_antidistrib op_mul\n\n"}
{"name":"Set.image_op_mul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns t : Set α\n⊢ Eq (Set.image MulOpposite.op (HMul.hMul s t)) (HMul.hMul (Set.image MulOpposite.op t) (Set.image MulOpposite.op s))","decl":"@[to_additive (attr := simp)]\ntheorem image_op_mul : op '' (s * t) = op '' t * op '' s :=\n  image_image2_antidistrib op_mul\n\n"}
{"name":"Set.prod_mul_prod_comm","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Mul α\ninst✝ : Mul β\ns₁ s₂ : Set α\nt₁ t₂ : Set β\n⊢ Eq (HMul.hMul (SProd.sprod s₁ t₁) (SProd.sprod s₂ t₂)) (SProd.sprod (HMul.hMul s₁ s₂) (HMul.hMul t₁ t₂))","decl":"@[to_additive (attr := simp)]\nlemma prod_mul_prod_comm [Mul β] (s₁ s₂: Set α) (t₁ t₂ : Set β) :\n   (s₁ ×ˢ t₁) * (s₂ ×ˢ t₂) = (s₁ * s₂) ×ˢ (t₁ * t₂) := by ext; simp [mem_mul]; aesop\n\n"}
{"name":"Set.sum_add_sum_comm","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Add α\ninst✝ : Add β\ns₁ s₂ : Set α\nt₁ t₂ : Set β\n⊢ Eq (HAdd.hAdd (SProd.sprod s₁ t₁) (SProd.sprod s₂ t₂)) (SProd.sprod (HAdd.hAdd s₁ s₂) (HAdd.hAdd t₁ t₂))","decl":"@[to_additive (attr := simp)]\nlemma prod_mul_prod_comm [Mul β] (s₁ s₂: Set α) (t₁ t₂ : Set β) :\n   (s₁ ×ˢ t₁) * (s₂ ×ˢ t₂) = (s₁ * s₂) ×ˢ (t₁ * t₂) := by ext; simp [mem_mul]; aesop\n\n"}
{"name":"Set.image2_sub","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Sub α\ns t : Set α\n⊢ Eq (Set.image2 Sub.sub s t) (HSub.hSub s t)","decl":"@[to_additive (attr := simp)]\ntheorem image2_div : image2 Div.div s t = s / t :=\n  rfl\n\n"}
{"name":"Set.image2_div","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Div α\ns t : Set α\n⊢ Eq (Set.image2 Div.div s t) (HDiv.hDiv s t)","decl":"@[to_additive (attr := simp)]\ntheorem image2_div : image2 Div.div s t = s / t :=\n  rfl\n\n"}
{"name":"Set.mem_sub","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Sub α\ns t : Set α\na : α\n⊢ Iff (Membership.mem (HSub.hSub s t) a) (Exists fun x => And (Membership.mem s x) (Exists fun y => And (Membership.mem t y) (Eq (HSub.hSub x y) a)))","decl":"@[to_additive]\ntheorem mem_div : a ∈ s / t ↔ ∃ x ∈ s, ∃ y ∈ t, x / y = a :=\n  Iff.rfl\n\n"}
{"name":"Set.mem_div","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Div α\ns t : Set α\na : α\n⊢ Iff (Membership.mem (HDiv.hDiv s t) a) (Exists fun x => And (Membership.mem s x) (Exists fun y => And (Membership.mem t y) (Eq (HDiv.hDiv x y) a)))","decl":"@[to_additive]\ntheorem mem_div : a ∈ s / t ↔ ∃ x ∈ s, ∃ y ∈ t, x / y = a :=\n  Iff.rfl\n\n"}
{"name":"Set.div_mem_div","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Div α\ns t : Set α\na b : α\na✝¹ : Membership.mem s a\na✝ : Membership.mem t b\n⊢ Membership.mem (HDiv.hDiv s t) (HDiv.hDiv a b)","decl":"@[to_additive]\ntheorem div_mem_div : a ∈ s → b ∈ t → a / b ∈ s / t :=\n  mem_image2_of_mem\n\n"}
{"name":"Set.sub_mem_sub","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Sub α\ns t : Set α\na b : α\na✝¹ : Membership.mem s a\na✝ : Membership.mem t b\n⊢ Membership.mem (HSub.hSub s t) (HSub.hSub a b)","decl":"@[to_additive]\ntheorem div_mem_div : a ∈ s → b ∈ t → a / b ∈ s / t :=\n  mem_image2_of_mem\n\n"}
{"name":"Set.image_div_prod","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Div α\ns t : Set α\n⊢ Eq (Set.image (fun x => HDiv.hDiv x.1 x.2) (SProd.sprod s t)) (HDiv.hDiv s t)","decl":"@[to_additive sub_image_prod]\ntheorem image_div_prod : (fun x : α × α => x.fst / x.snd) '' s ×ˢ t = s / t :=\n  image_prod _\n\n"}
{"name":"Set.sub_image_prod","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Sub α\ns t : Set α\n⊢ Eq (Set.image (fun x => HSub.hSub x.1 x.2) (SProd.sprod s t)) (HSub.hSub s t)","decl":"@[to_additive sub_image_prod]\ntheorem image_div_prod : (fun x : α × α => x.fst / x.snd) '' s ×ˢ t = s / t :=\n  image_prod _\n\n"}
{"name":"Set.empty_div","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Div α\ns : Set α\n⊢ Eq (HDiv.hDiv EmptyCollection.emptyCollection s) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)]\ntheorem empty_div : ∅ / s = ∅ :=\n  image2_empty_left\n\n"}
{"name":"Set.empty_sub","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Sub α\ns : Set α\n⊢ Eq (HSub.hSub EmptyCollection.emptyCollection s) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)]\ntheorem empty_div : ∅ / s = ∅ :=\n  image2_empty_left\n\n"}
{"name":"Set.sub_empty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Sub α\ns : Set α\n⊢ Eq (HSub.hSub s EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)]\ntheorem div_empty : s / ∅ = ∅ :=\n  image2_empty_right\n\n"}
{"name":"Set.div_empty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Div α\ns : Set α\n⊢ Eq (HDiv.hDiv s EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)]\ntheorem div_empty : s / ∅ = ∅ :=\n  image2_empty_right\n\n"}
{"name":"Set.sub_eq_empty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Sub α\ns t : Set α\n⊢ Iff (Eq (HSub.hSub s t) EmptyCollection.emptyCollection) (Or (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection))","decl":"@[to_additive (attr := simp)]\ntheorem div_eq_empty : s / t = ∅ ↔ s = ∅ ∨ t = ∅ :=\n  image2_eq_empty_iff\n\n"}
{"name":"Set.div_eq_empty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Div α\ns t : Set α\n⊢ Iff (Eq (HDiv.hDiv s t) EmptyCollection.emptyCollection) (Or (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection))","decl":"@[to_additive (attr := simp)]\ntheorem div_eq_empty : s / t = ∅ ↔ s = ∅ ∨ t = ∅ :=\n  image2_eq_empty_iff\n\n"}
{"name":"Set.div_nonempty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Div α\ns t : Set α\n⊢ Iff (HDiv.hDiv s t).Nonempty (And s.Nonempty t.Nonempty)","decl":"@[to_additive (attr := simp)]\ntheorem div_nonempty : (s / t).Nonempty ↔ s.Nonempty ∧ t.Nonempty :=\n  image2_nonempty_iff\n\n"}
{"name":"Set.sub_nonempty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Sub α\ns t : Set α\n⊢ Iff (HSub.hSub s t).Nonempty (And s.Nonempty t.Nonempty)","decl":"@[to_additive (attr := simp)]\ntheorem div_nonempty : (s / t).Nonempty ↔ s.Nonempty ∧ t.Nonempty :=\n  image2_nonempty_iff\n\n"}
{"name":"Set.Nonempty.sub","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Sub α\ns t : Set α\na✝¹ : s.Nonempty\na✝ : t.Nonempty\n⊢ (HSub.hSub s t).Nonempty","decl":"@[to_additive]\ntheorem Nonempty.div : s.Nonempty → t.Nonempty → (s / t).Nonempty :=\n  Nonempty.image2\n\n"}
{"name":"Set.Nonempty.div","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Div α\ns t : Set α\na✝¹ : s.Nonempty\na✝ : t.Nonempty\n⊢ (HDiv.hDiv s t).Nonempty","decl":"@[to_additive]\ntheorem Nonempty.div : s.Nonempty → t.Nonempty → (s / t).Nonempty :=\n  Nonempty.image2\n\n"}
{"name":"Set.Nonempty.of_div_left","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Div α\ns t : Set α\na✝ : (HDiv.hDiv s t).Nonempty\n⊢ s.Nonempty","decl":"@[to_additive]\ntheorem Nonempty.of_div_left : (s / t).Nonempty → s.Nonempty :=\n  Nonempty.of_image2_left\n\n"}
{"name":"Set.Nonempty.of_sub_left","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Sub α\ns t : Set α\na✝ : (HSub.hSub s t).Nonempty\n⊢ s.Nonempty","decl":"@[to_additive]\ntheorem Nonempty.of_div_left : (s / t).Nonempty → s.Nonempty :=\n  Nonempty.of_image2_left\n\n"}
{"name":"Set.Nonempty.of_sub_right","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Sub α\ns t : Set α\na✝ : (HSub.hSub s t).Nonempty\n⊢ t.Nonempty","decl":"@[to_additive]\ntheorem Nonempty.of_div_right : (s / t).Nonempty → t.Nonempty :=\n  Nonempty.of_image2_right\n\n"}
{"name":"Set.Nonempty.of_div_right","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Div α\ns t : Set α\na✝ : (HDiv.hDiv s t).Nonempty\n⊢ t.Nonempty","decl":"@[to_additive]\ntheorem Nonempty.of_div_right : (s / t).Nonempty → t.Nonempty :=\n  Nonempty.of_image2_right\n\n"}
{"name":"Set.div_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Div α\ns : Set α\nb : α\n⊢ Eq (HDiv.hDiv s (Singleton.singleton b)) (Set.image (fun x => HDiv.hDiv x b) s)","decl":"@[to_additive (attr := simp)]\ntheorem div_singleton : s / {b} = (· / b) '' s :=\n  image2_singleton_right\n\n"}
{"name":"Set.sub_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Sub α\ns : Set α\nb : α\n⊢ Eq (HSub.hSub s (Singleton.singleton b)) (Set.image (fun x => HSub.hSub x b) s)","decl":"@[to_additive (attr := simp)]\ntheorem div_singleton : s / {b} = (· / b) '' s :=\n  image2_singleton_right\n\n"}
{"name":"Set.singleton_sub","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Sub α\nt : Set α\na : α\n⊢ Eq (HSub.hSub (Singleton.singleton a) t) (Set.image ((fun x1 x2 => HSub.hSub x1 x2) a) t)","decl":"@[to_additive (attr := simp)]\ntheorem singleton_div : {a} / t = (· / ·) a '' t :=\n  image2_singleton_left\n\n"}
{"name":"Set.singleton_div","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Div α\nt : Set α\na : α\n⊢ Eq (HDiv.hDiv (Singleton.singleton a) t) (Set.image ((fun x1 x2 => HDiv.hDiv x1 x2) a) t)","decl":"@[to_additive (attr := simp)]\ntheorem singleton_div : {a} / t = (· / ·) a '' t :=\n  image2_singleton_left\n\n"}
{"name":"Set.singleton_div_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Div α\na b : α\n⊢ Eq (HDiv.hDiv (Singleton.singleton a) (Singleton.singleton b)) (Singleton.singleton (HDiv.hDiv a b))","decl":"@[to_additive]\ntheorem singleton_div_singleton : ({a} : Set α) / {b} = {a / b} :=\n  image2_singleton\n\n"}
{"name":"Set.singleton_sub_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Sub α\na b : α\n⊢ Eq (HSub.hSub (Singleton.singleton a) (Singleton.singleton b)) (Singleton.singleton (HSub.hSub a b))","decl":"@[to_additive]\ntheorem singleton_div_singleton : ({a} : Set α) / {b} = {a / b} :=\n  image2_singleton\n\n"}
{"name":"Set.sub_subset_sub","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Sub α\ns₁ s₂ t₁ t₂ : Set α\na✝¹ : HasSubset.Subset s₁ t₁\na✝ : HasSubset.Subset s₂ t₂\n⊢ HasSubset.Subset (HSub.hSub s₁ s₂) (HSub.hSub t₁ t₂)","decl":"@[to_additive (attr := mono, gcongr)]\ntheorem div_subset_div : s₁ ⊆ t₁ → s₂ ⊆ t₂ → s₁ / s₂ ⊆ t₁ / t₂ :=\n  image2_subset\n\n"}
{"name":"Set.div_subset_div","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Div α\ns₁ s₂ t₁ t₂ : Set α\na✝¹ : HasSubset.Subset s₁ t₁\na✝ : HasSubset.Subset s₂ t₂\n⊢ HasSubset.Subset (HDiv.hDiv s₁ s₂) (HDiv.hDiv t₁ t₂)","decl":"@[to_additive (attr := mono, gcongr)]\ntheorem div_subset_div : s₁ ⊆ t₁ → s₂ ⊆ t₂ → s₁ / s₂ ⊆ t₁ / t₂ :=\n  image2_subset\n\n"}
{"name":"Set.div_subset_div_left","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Div α\ns t₁ t₂ : Set α\na✝ : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (HDiv.hDiv s t₁) (HDiv.hDiv s t₂)","decl":"@[to_additive (attr := gcongr)]\ntheorem div_subset_div_left : t₁ ⊆ t₂ → s / t₁ ⊆ s / t₂ :=\n  image2_subset_left\n\n"}
{"name":"Set.sub_subset_sub_left","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Sub α\ns t₁ t₂ : Set α\na✝ : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (HSub.hSub s t₁) (HSub.hSub s t₂)","decl":"@[to_additive (attr := gcongr)]\ntheorem div_subset_div_left : t₁ ⊆ t₂ → s / t₁ ⊆ s / t₂ :=\n  image2_subset_left\n\n"}
{"name":"Set.sub_subset_sub_right","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Sub α\ns₁ s₂ t : Set α\na✝ : HasSubset.Subset s₁ s₂\n⊢ HasSubset.Subset (HSub.hSub s₁ t) (HSub.hSub s₂ t)","decl":"@[to_additive (attr := gcongr)]\ntheorem div_subset_div_right : s₁ ⊆ s₂ → s₁ / t ⊆ s₂ / t :=\n  image2_subset_right\n\n"}
{"name":"Set.div_subset_div_right","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Div α\ns₁ s₂ t : Set α\na✝ : HasSubset.Subset s₁ s₂\n⊢ HasSubset.Subset (HDiv.hDiv s₁ t) (HDiv.hDiv s₂ t)","decl":"@[to_additive (attr := gcongr)]\ntheorem div_subset_div_right : s₁ ⊆ s₂ → s₁ / t ⊆ s₂ / t :=\n  image2_subset_right\n\n"}
{"name":"Set.div_subset_iff","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Div α\ns t u : Set α\n⊢ Iff (HasSubset.Subset (HDiv.hDiv s t) u) (∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem t y → Membership.mem u (HDiv.hDiv x y))","decl":"@[to_additive]\ntheorem div_subset_iff : s / t ⊆ u ↔ ∀ x ∈ s, ∀ y ∈ t, x / y ∈ u :=\n  image2_subset_iff\n\n"}
{"name":"Set.sub_subset_iff","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Sub α\ns t u : Set α\n⊢ Iff (HasSubset.Subset (HSub.hSub s t) u) (∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem t y → Membership.mem u (HSub.hSub x y))","decl":"@[to_additive]\ntheorem div_subset_iff : s / t ⊆ u ↔ ∀ x ∈ s, ∀ y ∈ t, x / y ∈ u :=\n  image2_subset_iff\n\n"}
{"name":"Set.union_sub","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Sub α\ns₁ s₂ t : Set α\n⊢ Eq (HSub.hSub (Union.union s₁ s₂) t) (Union.union (HSub.hSub s₁ t) (HSub.hSub s₂ t))","decl":"@[to_additive]\ntheorem union_div : (s₁ ∪ s₂) / t = s₁ / t ∪ s₂ / t :=\n  image2_union_left\n\n"}
{"name":"Set.union_div","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Div α\ns₁ s₂ t : Set α\n⊢ Eq (HDiv.hDiv (Union.union s₁ s₂) t) (Union.union (HDiv.hDiv s₁ t) (HDiv.hDiv s₂ t))","decl":"@[to_additive]\ntheorem union_div : (s₁ ∪ s₂) / t = s₁ / t ∪ s₂ / t :=\n  image2_union_left\n\n"}
{"name":"Set.sub_union","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Sub α\ns t₁ t₂ : Set α\n⊢ Eq (HSub.hSub s (Union.union t₁ t₂)) (Union.union (HSub.hSub s t₁) (HSub.hSub s t₂))","decl":"@[to_additive]\ntheorem div_union : s / (t₁ ∪ t₂) = s / t₁ ∪ s / t₂ :=\n  image2_union_right\n\n"}
{"name":"Set.div_union","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Div α\ns t₁ t₂ : Set α\n⊢ Eq (HDiv.hDiv s (Union.union t₁ t₂)) (Union.union (HDiv.hDiv s t₁) (HDiv.hDiv s t₂))","decl":"@[to_additive]\ntheorem div_union : s / (t₁ ∪ t₂) = s / t₁ ∪ s / t₂ :=\n  image2_union_right\n\n"}
{"name":"Set.inter_div_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Div α\ns₁ s₂ t : Set α\n⊢ HasSubset.Subset (HDiv.hDiv (Inter.inter s₁ s₂) t) (Inter.inter (HDiv.hDiv s₁ t) (HDiv.hDiv s₂ t))","decl":"@[to_additive]\ntheorem inter_div_subset : s₁ ∩ s₂ / t ⊆ s₁ / t ∩ (s₂ / t) :=\n  image2_inter_subset_left\n\n"}
{"name":"Set.inter_sub_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Sub α\ns₁ s₂ t : Set α\n⊢ HasSubset.Subset (HSub.hSub (Inter.inter s₁ s₂) t) (Inter.inter (HSub.hSub s₁ t) (HSub.hSub s₂ t))","decl":"@[to_additive]\ntheorem inter_div_subset : s₁ ∩ s₂ / t ⊆ s₁ / t ∩ (s₂ / t) :=\n  image2_inter_subset_left\n\n"}
{"name":"Set.div_inter_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Div α\ns t₁ t₂ : Set α\n⊢ HasSubset.Subset (HDiv.hDiv s (Inter.inter t₁ t₂)) (Inter.inter (HDiv.hDiv s t₁) (HDiv.hDiv s t₂))","decl":"@[to_additive]\ntheorem div_inter_subset : s / (t₁ ∩ t₂) ⊆ s / t₁ ∩ (s / t₂) :=\n  image2_inter_subset_right\n\n"}
{"name":"Set.sub_inter_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Sub α\ns t₁ t₂ : Set α\n⊢ HasSubset.Subset (HSub.hSub s (Inter.inter t₁ t₂)) (Inter.inter (HSub.hSub s t₁) (HSub.hSub s t₂))","decl":"@[to_additive]\ntheorem div_inter_subset : s / (t₁ ∩ t₂) ⊆ s / t₁ ∩ (s / t₂) :=\n  image2_inter_subset_right\n\n"}
{"name":"Set.inter_div_union_subset_union","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Div α\ns₁ s₂ t₁ t₂ : Set α\n⊢ HasSubset.Subset (HDiv.hDiv (Inter.inter s₁ s₂) (Union.union t₁ t₂)) (Union.union (HDiv.hDiv s₁ t₁) (HDiv.hDiv s₂ t₂))","decl":"@[to_additive]\ntheorem inter_div_union_subset_union : s₁ ∩ s₂ / (t₁ ∪ t₂) ⊆ s₁ / t₁ ∪ s₂ / t₂ :=\n  image2_inter_union_subset_union\n\n"}
{"name":"Set.inter_sub_union_subset_union","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Sub α\ns₁ s₂ t₁ t₂ : Set α\n⊢ HasSubset.Subset (HSub.hSub (Inter.inter s₁ s₂) (Union.union t₁ t₂)) (Union.union (HSub.hSub s₁ t₁) (HSub.hSub s₂ t₂))","decl":"@[to_additive]\ntheorem inter_div_union_subset_union : s₁ ∩ s₂ / (t₁ ∪ t₂) ⊆ s₁ / t₁ ∪ s₂ / t₂ :=\n  image2_inter_union_subset_union\n\n"}
{"name":"Set.union_div_inter_subset_union","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Div α\ns₁ s₂ t₁ t₂ : Set α\n⊢ HasSubset.Subset (HDiv.hDiv (Union.union s₁ s₂) (Inter.inter t₁ t₂)) (Union.union (HDiv.hDiv s₁ t₁) (HDiv.hDiv s₂ t₂))","decl":"@[to_additive]\ntheorem union_div_inter_subset_union : (s₁ ∪ s₂) / (t₁ ∩ t₂) ⊆ s₁ / t₁ ∪ s₂ / t₂ :=\n  image2_union_inter_subset_union\n\n"}
{"name":"Set.union_sub_inter_subset_union","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Sub α\ns₁ s₂ t₁ t₂ : Set α\n⊢ HasSubset.Subset (HSub.hSub (Union.union s₁ s₂) (Inter.inter t₁ t₂)) (Union.union (HSub.hSub s₁ t₁) (HSub.hSub s₂ t₂))","decl":"@[to_additive]\ntheorem union_div_inter_subset_union : (s₁ ∪ s₂) / (t₁ ∩ t₂) ⊆ s₁ / t₁ ∪ s₂ / t₂ :=\n  image2_union_inter_subset_union\n\n"}
{"name":"Set.iUnion_sub_left_image","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Sub α\ns t : Set α\n⊢ Eq (Set.iUnion fun a => Set.iUnion fun h => Set.image (fun x => HSub.hSub a x) t) (HSub.hSub s t)","decl":"@[to_additive]\ntheorem iUnion_div_left_image : ⋃ a ∈ s, (a / ·) '' t = s / t :=\n  iUnion_image_left _\n\n"}
{"name":"Set.iUnion_div_left_image","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Div α\ns t : Set α\n⊢ Eq (Set.iUnion fun a => Set.iUnion fun h => Set.image (fun x => HDiv.hDiv a x) t) (HDiv.hDiv s t)","decl":"@[to_additive]\ntheorem iUnion_div_left_image : ⋃ a ∈ s, (a / ·) '' t = s / t :=\n  iUnion_image_left _\n\n"}
{"name":"Set.iUnion_sub_right_image","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Sub α\ns t : Set α\n⊢ Eq (Set.iUnion fun a => Set.iUnion fun h => Set.image (fun x => HSub.hSub x a) s) (HSub.hSub s t)","decl":"@[to_additive]\ntheorem iUnion_div_right_image : ⋃ a ∈ t, (· / a) '' s = s / t :=\n  iUnion_image_right _\n\n"}
{"name":"Set.iUnion_div_right_image","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Div α\ns t : Set α\n⊢ Eq (Set.iUnion fun a => Set.iUnion fun h => Set.image (fun x => HDiv.hDiv x a) s) (HDiv.hDiv s t)","decl":"@[to_additive]\ntheorem iUnion_div_right_image : ⋃ a ∈ t, (· / a) '' s = s / t :=\n  iUnion_image_right _\n\n"}
{"name":"Set.iUnion_div","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\ninst✝ : Div α\ns : ι → Set α\nt : Set α\n⊢ Eq (HDiv.hDiv (Set.iUnion fun i => s i) t) (Set.iUnion fun i => HDiv.hDiv (s i) t)","decl":"@[to_additive]\ntheorem iUnion_div (s : ι → Set α) (t : Set α) : (⋃ i, s i) / t = ⋃ i, s i / t :=\n  image2_iUnion_left ..\n\n"}
{"name":"Set.iUnion_sub","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\ninst✝ : Sub α\ns : ι → Set α\nt : Set α\n⊢ Eq (HSub.hSub (Set.iUnion fun i => s i) t) (Set.iUnion fun i => HSub.hSub (s i) t)","decl":"@[to_additive]\ntheorem iUnion_div (s : ι → Set α) (t : Set α) : (⋃ i, s i) / t = ⋃ i, s i / t :=\n  image2_iUnion_left ..\n\n"}
{"name":"Set.div_iUnion","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\ninst✝ : Div α\ns : Set α\nt : ι → Set α\n⊢ Eq (HDiv.hDiv s (Set.iUnion fun i => t i)) (Set.iUnion fun i => HDiv.hDiv s (t i))","decl":"@[to_additive]\ntheorem div_iUnion (s : Set α) (t : ι → Set α) : (s / ⋃ i, t i) = ⋃ i, s / t i :=\n  image2_iUnion_right ..\n\n"}
{"name":"Set.sub_iUnion","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\ninst✝ : Sub α\ns : Set α\nt : ι → Set α\n⊢ Eq (HSub.hSub s (Set.iUnion fun i => t i)) (Set.iUnion fun i => HSub.hSub s (t i))","decl":"@[to_additive]\ntheorem div_iUnion (s : Set α) (t : ι → Set α) : (s / ⋃ i, t i) = ⋃ i, s / t i :=\n  image2_iUnion_right ..\n\n"}
{"name":"Set.sUnion_sub","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Sub α\nS : Set (Set α)\nt : Set α\n⊢ Eq (HSub.hSub S.sUnion t) (Set.iUnion fun s => Set.iUnion fun h => HSub.hSub s t)","decl":"@[to_additive]\ntheorem sUnion_div (S : Set (Set α)) (t : Set α) : ⋃₀ S / t = ⋃ s ∈ S, s / t :=\n  image2_sUnion_left ..\n\n"}
{"name":"Set.sUnion_div","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Div α\nS : Set (Set α)\nt : Set α\n⊢ Eq (HDiv.hDiv S.sUnion t) (Set.iUnion fun s => Set.iUnion fun h => HDiv.hDiv s t)","decl":"@[to_additive]\ntheorem sUnion_div (S : Set (Set α)) (t : Set α) : ⋃₀ S / t = ⋃ s ∈ S, s / t :=\n  image2_sUnion_left ..\n\n"}
{"name":"Set.sub_sUnion","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Sub α\ns : Set α\nT : Set (Set α)\n⊢ Eq (HSub.hSub s T.sUnion) (Set.iUnion fun t => Set.iUnion fun h => HSub.hSub s t)","decl":"@[to_additive]\ntheorem div_sUnion (s : Set α) (T : Set (Set α)) : s / ⋃₀ T = ⋃ t ∈ T, s / t :=\n  image2_sUnion_right ..\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.div_sUnion","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Div α\ns : Set α\nT : Set (Set α)\n⊢ Eq (HDiv.hDiv s T.sUnion) (Set.iUnion fun t => Set.iUnion fun h => HDiv.hDiv s t)","decl":"@[to_additive]\ntheorem div_sUnion (s : Set α) (T : Set (Set α)) : s / ⋃₀ T = ⋃ t ∈ T, s / t :=\n  image2_sUnion_right ..\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.iUnion₂_sub","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\nκ : ι → Sort u_6\ninst✝ : Sub α\ns : (i : ι) → κ i → Set α\nt : Set α\n⊢ Eq (HSub.hSub (Set.iUnion fun i => Set.iUnion fun j => s i j) t) (Set.iUnion fun i => Set.iUnion fun j => HSub.hSub (s i j) t)","decl":"@[to_additive]\ntheorem iUnion₂_div (s : ∀ i, κ i → Set α) (t : Set α) :\n    (⋃ (i) (j), s i j) / t = ⋃ (i) (j), s i j / t :=\n  image2_iUnion₂_left ..\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.iUnion₂_div","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\nκ : ι → Sort u_6\ninst✝ : Div α\ns : (i : ι) → κ i → Set α\nt : Set α\n⊢ Eq (HDiv.hDiv (Set.iUnion fun i => Set.iUnion fun j => s i j) t) (Set.iUnion fun i => Set.iUnion fun j => HDiv.hDiv (s i j) t)","decl":"@[to_additive]\ntheorem iUnion₂_div (s : ∀ i, κ i → Set α) (t : Set α) :\n    (⋃ (i) (j), s i j) / t = ⋃ (i) (j), s i j / t :=\n  image2_iUnion₂_left ..\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.div_iUnion₂","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\nκ : ι → Sort u_6\ninst✝ : Div α\ns : Set α\nt : (i : ι) → κ i → Set α\n⊢ Eq (HDiv.hDiv s (Set.iUnion fun i => Set.iUnion fun j => t i j)) (Set.iUnion fun i => Set.iUnion fun j => HDiv.hDiv s (t i j))","decl":"@[to_additive]\ntheorem div_iUnion₂ (s : Set α) (t : ∀ i, κ i → Set α) :\n    (s / ⋃ (i) (j), t i j) = ⋃ (i) (j), s / t i j :=\n  image2_iUnion₂_right ..\n\n"}
{"name":"Set.sub_iUnion₂","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\nκ : ι → Sort u_6\ninst✝ : Sub α\ns : Set α\nt : (i : ι) → κ i → Set α\n⊢ Eq (HSub.hSub s (Set.iUnion fun i => Set.iUnion fun j => t i j)) (Set.iUnion fun i => Set.iUnion fun j => HSub.hSub s (t i j))","decl":"@[to_additive]\ntheorem div_iUnion₂ (s : Set α) (t : ∀ i, κ i → Set α) :\n    (s / ⋃ (i) (j), t i j) = ⋃ (i) (j), s / t i j :=\n  image2_iUnion₂_right ..\n\n"}
{"name":"Set.iInter_sub_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\ninst✝ : Sub α\ns : ι → Set α\nt : Set α\n⊢ HasSubset.Subset (HSub.hSub (Set.iInter fun i => s i) t) (Set.iInter fun i => HSub.hSub (s i) t)","decl":"@[to_additive]\ntheorem iInter_div_subset (s : ι → Set α) (t : Set α) : (⋂ i, s i) / t ⊆ ⋂ i, s i / t :=\n  image2_iInter_subset_left ..\n\n"}
{"name":"Set.iInter_div_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\ninst✝ : Div α\ns : ι → Set α\nt : Set α\n⊢ HasSubset.Subset (HDiv.hDiv (Set.iInter fun i => s i) t) (Set.iInter fun i => HDiv.hDiv (s i) t)","decl":"@[to_additive]\ntheorem iInter_div_subset (s : ι → Set α) (t : Set α) : (⋂ i, s i) / t ⊆ ⋂ i, s i / t :=\n  image2_iInter_subset_left ..\n\n"}
{"name":"Set.div_iInter_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\ninst✝ : Div α\ns : Set α\nt : ι → Set α\n⊢ HasSubset.Subset (HDiv.hDiv s (Set.iInter fun i => t i)) (Set.iInter fun i => HDiv.hDiv s (t i))","decl":"@[to_additive]\ntheorem div_iInter_subset (s : Set α) (t : ι → Set α) : (s / ⋂ i, t i) ⊆ ⋂ i, s / t i :=\n  image2_iInter_subset_right ..\n\n"}
{"name":"Set.sub_iInter_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\ninst✝ : Sub α\ns : Set α\nt : ι → Set α\n⊢ HasSubset.Subset (HSub.hSub s (Set.iInter fun i => t i)) (Set.iInter fun i => HSub.hSub s (t i))","decl":"@[to_additive]\ntheorem div_iInter_subset (s : Set α) (t : ι → Set α) : (s / ⋂ i, t i) ⊆ ⋂ i, s / t i :=\n  image2_iInter_subset_right ..\n\n"}
{"name":"Set.sInter_div_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Div α\nS : Set (Set α)\nt : Set α\n⊢ HasSubset.Subset (HDiv.hDiv S.sInter t) (Set.iInter fun s => Set.iInter fun h => HDiv.hDiv s t)","decl":"@[to_additive]\ntheorem sInter_div_subset (S : Set (Set α)) (t : Set α) : ⋂₀ S / t ⊆ ⋂ s ∈ S, s / t :=\n  image2_sInter_subset_left ..\n\n"}
{"name":"Set.sInter_sub_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Sub α\nS : Set (Set α)\nt : Set α\n⊢ HasSubset.Subset (HSub.hSub S.sInter t) (Set.iInter fun s => Set.iInter fun h => HSub.hSub s t)","decl":"@[to_additive]\ntheorem sInter_div_subset (S : Set (Set α)) (t : Set α) : ⋂₀ S / t ⊆ ⋂ s ∈ S, s / t :=\n  image2_sInter_subset_left ..\n\n"}
{"name":"Set.div_sInter_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Div α\ns : Set α\nT : Set (Set α)\n⊢ HasSubset.Subset (HDiv.hDiv s T.sInter) (Set.iInter fun t => Set.iInter fun h => HDiv.hDiv s t)","decl":"@[to_additive]\ntheorem div_sInter_subset (s : Set α) (T : Set (Set α)) : s / ⋂₀ T ⊆ ⋂ t ∈ T, s / t :=\n  image2_sInter_subset_right ..\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.sub_sInter_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Sub α\ns : Set α\nT : Set (Set α)\n⊢ HasSubset.Subset (HSub.hSub s T.sInter) (Set.iInter fun t => Set.iInter fun h => HSub.hSub s t)","decl":"@[to_additive]\ntheorem div_sInter_subset (s : Set α) (T : Set (Set α)) : s / ⋂₀ T ⊆ ⋂ t ∈ T, s / t :=\n  image2_sInter_subset_right ..\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.iInter₂_sub_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\nκ : ι → Sort u_6\ninst✝ : Sub α\ns : (i : ι) → κ i → Set α\nt : Set α\n⊢ HasSubset.Subset (HSub.hSub (Set.iInter fun i => Set.iInter fun j => s i j) t) (Set.iInter fun i => Set.iInter fun j => HSub.hSub (s i j) t)","decl":"@[to_additive]\ntheorem iInter₂_div_subset (s : ∀ i, κ i → Set α) (t : Set α) :\n    (⋂ (i) (j), s i j) / t ⊆ ⋂ (i) (j), s i j / t :=\n  image2_iInter₂_subset_left ..\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.iInter₂_div_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\nκ : ι → Sort u_6\ninst✝ : Div α\ns : (i : ι) → κ i → Set α\nt : Set α\n⊢ HasSubset.Subset (HDiv.hDiv (Set.iInter fun i => Set.iInter fun j => s i j) t) (Set.iInter fun i => Set.iInter fun j => HDiv.hDiv (s i j) t)","decl":"@[to_additive]\ntheorem iInter₂_div_subset (s : ∀ i, κ i → Set α) (t : Set α) :\n    (⋂ (i) (j), s i j) / t ⊆ ⋂ (i) (j), s i j / t :=\n  image2_iInter₂_subset_left ..\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.div_iInter₂_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\nκ : ι → Sort u_6\ninst✝ : Div α\ns : Set α\nt : (i : ι) → κ i → Set α\n⊢ HasSubset.Subset (HDiv.hDiv s (Set.iInter fun i => Set.iInter fun j => t i j)) (Set.iInter fun i => Set.iInter fun j => HDiv.hDiv s (t i j))","decl":"@[to_additive]\ntheorem div_iInter₂_subset (s : Set α) (t : ∀ i, κ i → Set α) :\n    (s / ⋂ (i) (j), t i j) ⊆ ⋂ (i) (j), s / t i j :=\n  image2_iInter₂_subset_right ..\n\n"}
{"name":"Set.sub_iInter₂_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nι : Sort u_5\nκ : ι → Sort u_6\ninst✝ : Sub α\ns : Set α\nt : (i : ι) → κ i → Set α\n⊢ HasSubset.Subset (HSub.hSub s (Set.iInter fun i => Set.iInter fun j => t i j)) (Set.iInter fun i => Set.iInter fun j => HSub.hSub s (t i j))","decl":"@[to_additive]\ntheorem div_iInter₂_subset (s : Set α) (t : ∀ i, κ i → Set α) :\n    (s / ⋂ (i) (j), t i j) ⊆ ⋂ (i) (j), s / t i j :=\n  image2_iInter₂_subset_right ..\n\n"}
{"name":"Set.image2_smul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns : Set α\nt : Set β\n⊢ Eq (Set.image2 SMul.smul s t) (HSMul.hSMul s t)","decl":"@[to_additive (attr := simp)] lemma image2_smul : image2 SMul.smul s t = s • t := rfl\n\n"}
{"name":"Set.image2_vadd","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns : Set α\nt : Set β\n⊢ Eq (Set.image2 VAdd.vadd s t) (HVAdd.hVAdd s t)","decl":"@[to_additive (attr := simp)] lemma image2_smul : image2 SMul.smul s t = s • t := rfl\n\n"}
{"name":"Set.image_smul_prod","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns : Set α\nt : Set β\n⊢ Eq (Set.image (fun x => HSMul.hSMul x.1 x.2) (SProd.sprod s t)) (HSMul.hSMul s t)","decl":"@[to_additive vadd_image_prod]\nlemma image_smul_prod : (fun x : α × β ↦ x.fst • x.snd) '' s ×ˢ t = s • t := image_prod _\n\n"}
{"name":"Set.vadd_image_prod","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns : Set α\nt : Set β\n⊢ Eq (Set.image (fun x => HVAdd.hVAdd x.1 x.2) (SProd.sprod s t)) (HVAdd.hVAdd s t)","decl":"@[to_additive vadd_image_prod]\nlemma image_smul_prod : (fun x : α × β ↦ x.fst • x.snd) '' s ×ˢ t = s • t := image_prod _\n\n"}
{"name":"Set.mem_smul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns : Set α\nt : Set β\nb : β\n⊢ Iff (Membership.mem (HSMul.hSMul s t) b) (Exists fun x => And (Membership.mem s x) (Exists fun y => And (Membership.mem t y) (Eq (HSMul.hSMul x y) b)))","decl":"@[to_additive] lemma mem_smul : b ∈ s • t ↔ ∃ x ∈ s, ∃ y ∈ t, x • y = b := Iff.rfl\n\n"}
{"name":"Set.mem_vadd","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns : Set α\nt : Set β\nb : β\n⊢ Iff (Membership.mem (HVAdd.hVAdd s t) b) (Exists fun x => And (Membership.mem s x) (Exists fun y => And (Membership.mem t y) (Eq (HVAdd.hVAdd x y) b)))","decl":"@[to_additive] lemma mem_smul : b ∈ s • t ↔ ∃ x ∈ s, ∃ y ∈ t, x • y = b := Iff.rfl\n\n"}
{"name":"Set.vadd_mem_vadd","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns : Set α\nt : Set β\na : α\nb : β\na✝¹ : Membership.mem s a\na✝ : Membership.mem t b\n⊢ Membership.mem (HVAdd.hVAdd s t) (HVAdd.hVAdd a b)","decl":"@[to_additive] lemma smul_mem_smul : a ∈ s → b ∈ t → a • b ∈ s • t := mem_image2_of_mem\n\n"}
{"name":"Set.smul_mem_smul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns : Set α\nt : Set β\na : α\nb : β\na✝¹ : Membership.mem s a\na✝ : Membership.mem t b\n⊢ Membership.mem (HSMul.hSMul s t) (HSMul.hSMul a b)","decl":"@[to_additive] lemma smul_mem_smul : a ∈ s → b ∈ t → a • b ∈ s • t := mem_image2_of_mem\n\n"}
{"name":"Set.empty_vadd","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nt : Set β\n⊢ Eq (HVAdd.hVAdd EmptyCollection.emptyCollection t) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)] lemma empty_smul : (∅ : Set α) • t = ∅ := image2_empty_left\n"}
{"name":"Set.empty_smul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nt : Set β\n⊢ Eq (HSMul.hSMul EmptyCollection.emptyCollection t) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)] lemma empty_smul : (∅ : Set α) • t = ∅ := image2_empty_left\n"}
{"name":"Set.vadd_empty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns : Set α\n⊢ Eq (HVAdd.hVAdd s EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)] lemma smul_empty : s • (∅ : Set β) = ∅ := image2_empty_right\n\n"}
{"name":"Set.smul_empty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns : Set α\n⊢ Eq (HSMul.hSMul s EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)] lemma smul_empty : s • (∅ : Set β) = ∅ := image2_empty_right\n\n"}
{"name":"Set.smul_eq_empty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns : Set α\nt : Set β\n⊢ Iff (Eq (HSMul.hSMul s t) EmptyCollection.emptyCollection) (Or (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection))","decl":"@[to_additive (attr := simp)] lemma smul_eq_empty : s • t = ∅ ↔ s = ∅ ∨ t = ∅ := image2_eq_empty_iff\n\n"}
{"name":"Set.vadd_eq_empty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns : Set α\nt : Set β\n⊢ Iff (Eq (HVAdd.hVAdd s t) EmptyCollection.emptyCollection) (Or (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection))","decl":"@[to_additive (attr := simp)] lemma smul_eq_empty : s • t = ∅ ↔ s = ∅ ∨ t = ∅ := image2_eq_empty_iff\n\n"}
{"name":"Set.vadd_nonempty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns : Set α\nt : Set β\n⊢ Iff (HVAdd.hVAdd s t).Nonempty (And s.Nonempty t.Nonempty)","decl":"@[to_additive (attr := simp)]\nlemma smul_nonempty : (s • t).Nonempty ↔ s.Nonempty ∧ t.Nonempty := image2_nonempty_iff\n\n"}
{"name":"Set.smul_nonempty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns : Set α\nt : Set β\n⊢ Iff (HSMul.hSMul s t).Nonempty (And s.Nonempty t.Nonempty)","decl":"@[to_additive (attr := simp)]\nlemma smul_nonempty : (s • t).Nonempty ↔ s.Nonempty ∧ t.Nonempty := image2_nonempty_iff\n\n"}
{"name":"Set.Nonempty.smul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns : Set α\nt : Set β\na✝¹ : s.Nonempty\na✝ : t.Nonempty\n⊢ (HSMul.hSMul s t).Nonempty","decl":"@[to_additive] lemma Nonempty.smul : s.Nonempty → t.Nonempty → (s • t).Nonempty := .image2\n"}
{"name":"Set.Nonempty.vadd","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns : Set α\nt : Set β\na✝¹ : s.Nonempty\na✝ : t.Nonempty\n⊢ (HVAdd.hVAdd s t).Nonempty","decl":"@[to_additive] lemma Nonempty.smul : s.Nonempty → t.Nonempty → (s • t).Nonempty := .image2\n"}
{"name":"Set.Nonempty.of_vadd_left","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns : Set α\nt : Set β\na✝ : (HVAdd.hVAdd s t).Nonempty\n⊢ s.Nonempty","decl":"@[to_additive] lemma Nonempty.of_smul_left : (s • t).Nonempty → s.Nonempty := .of_image2_left\n"}
{"name":"Set.Nonempty.of_smul_left","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns : Set α\nt : Set β\na✝ : (HSMul.hSMul s t).Nonempty\n⊢ s.Nonempty","decl":"@[to_additive] lemma Nonempty.of_smul_left : (s • t).Nonempty → s.Nonempty := .of_image2_left\n"}
{"name":"Set.Nonempty.of_smul_right","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns : Set α\nt : Set β\na✝ : (HSMul.hSMul s t).Nonempty\n⊢ t.Nonempty","decl":"@[to_additive] lemma Nonempty.of_smul_right : (s • t).Nonempty → t.Nonempty := .of_image2_right\n\n"}
{"name":"Set.Nonempty.of_vadd_right","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns : Set α\nt : Set β\na✝ : (HVAdd.hVAdd s t).Nonempty\n⊢ t.Nonempty","decl":"@[to_additive] lemma Nonempty.of_smul_right : (s • t).Nonempty → t.Nonempty := .of_image2_right\n\n"}
{"name":"Set.vadd_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns : Set α\nb : β\n⊢ Eq (HVAdd.hVAdd s (Singleton.singleton b)) (Set.image (fun x => HVAdd.hVAdd x b) s)","decl":"@[to_additive (attr := simp low+1)]\nlemma smul_singleton : s • ({b} : Set β) = (· • b) '' s := image2_singleton_right\n\n"}
{"name":"Set.smul_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns : Set α\nb : β\n⊢ Eq (HSMul.hSMul s (Singleton.singleton b)) (Set.image (fun x => HSMul.hSMul x b) s)","decl":"@[to_additive (attr := simp low+1)]\nlemma smul_singleton : s • ({b} : Set β) = (· • b) '' s := image2_singleton_right\n\n"}
{"name":"Set.singleton_smul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nt : Set β\na : α\n⊢ Eq (HSMul.hSMul (Singleton.singleton a) t) (HSMul.hSMul a t)","decl":"@[to_additive (attr := simp low+1)]\nlemma singleton_smul : ({a} : Set α) • t = a • t := image2_singleton_left\n\n"}
{"name":"Set.singleton_vadd","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nt : Set β\na : α\n⊢ Eq (HVAdd.hVAdd (Singleton.singleton a) t) (HVAdd.hVAdd a t)","decl":"@[to_additive (attr := simp low+1)]\nlemma singleton_smul : ({a} : Set α) • t = a • t := image2_singleton_left\n\n"}
{"name":"Set.singleton_vadd_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\na : α\nb : β\n⊢ Eq (HVAdd.hVAdd (Singleton.singleton a) (Singleton.singleton b)) (Singleton.singleton (HVAdd.hVAdd a b))","decl":"@[to_additive (attr := simp high)]\nlemma singleton_smul_singleton : ({a} : Set α) • ({b} : Set β) = {a • b} := image2_singleton\n\n"}
{"name":"Set.singleton_smul_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\na : α\nb : β\n⊢ Eq (HSMul.hSMul (Singleton.singleton a) (Singleton.singleton b)) (Singleton.singleton (HSMul.hSMul a b))","decl":"@[to_additive (attr := simp high)]\nlemma singleton_smul_singleton : ({a} : Set α) • ({b} : Set β) = {a • b} := image2_singleton\n\n"}
{"name":"Set.smul_subset_smul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns₁ s₂ : Set α\nt₁ t₂ : Set β\na✝¹ : HasSubset.Subset s₁ s₂\na✝ : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (HSMul.hSMul s₁ t₁) (HSMul.hSMul s₂ t₂)","decl":"@[to_additive (attr := mono, gcongr)]\nlemma smul_subset_smul : s₁ ⊆ s₂ → t₁ ⊆ t₂ → s₁ • t₁ ⊆ s₂ • t₂ := image2_subset\n\n"}
{"name":"Set.vadd_subset_vadd","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns₁ s₂ : Set α\nt₁ t₂ : Set β\na✝¹ : HasSubset.Subset s₁ s₂\na✝ : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (HVAdd.hVAdd s₁ t₁) (HVAdd.hVAdd s₂ t₂)","decl":"@[to_additive (attr := mono, gcongr)]\nlemma smul_subset_smul : s₁ ⊆ s₂ → t₁ ⊆ t₂ → s₁ • t₁ ⊆ s₂ • t₂ := image2_subset\n\n"}
{"name":"Set.smul_subset_smul_left","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns : Set α\nt₁ t₂ : Set β\na✝ : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (HSMul.hSMul s t₁) (HSMul.hSMul s t₂)","decl":"@[to_additive (attr := gcongr)]\nlemma smul_subset_smul_left : t₁ ⊆ t₂ → s • t₁ ⊆ s • t₂ := image2_subset_left\n\n"}
{"name":"Set.vadd_subset_vadd_left","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns : Set α\nt₁ t₂ : Set β\na✝ : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (HVAdd.hVAdd s t₁) (HVAdd.hVAdd s t₂)","decl":"@[to_additive (attr := gcongr)]\nlemma smul_subset_smul_left : t₁ ⊆ t₂ → s • t₁ ⊆ s • t₂ := image2_subset_left\n\n"}
{"name":"Set.vadd_subset_vadd_right","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns₁ s₂ : Set α\nt : Set β\na✝ : HasSubset.Subset s₁ s₂\n⊢ HasSubset.Subset (HVAdd.hVAdd s₁ t) (HVAdd.hVAdd s₂ t)","decl":"@[to_additive (attr := gcongr)]\nlemma smul_subset_smul_right : s₁ ⊆ s₂ → s₁ • t ⊆ s₂ • t := image2_subset_right\n\n"}
{"name":"Set.smul_subset_smul_right","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns₁ s₂ : Set α\nt : Set β\na✝ : HasSubset.Subset s₁ s₂\n⊢ HasSubset.Subset (HSMul.hSMul s₁ t) (HSMul.hSMul s₂ t)","decl":"@[to_additive (attr := gcongr)]\nlemma smul_subset_smul_right : s₁ ⊆ s₂ → s₁ • t ⊆ s₂ • t := image2_subset_right\n\n"}
{"name":"Set.vadd_subset_iff","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns : Set α\nt u : Set β\n⊢ Iff (HasSubset.Subset (HVAdd.hVAdd s t) u) (∀ (a : α), Membership.mem s a → ∀ (b : β), Membership.mem t b → Membership.mem u (HVAdd.hVAdd a b))","decl":"@[to_additive] lemma smul_subset_iff : s • t ⊆ u ↔ ∀ a ∈ s, ∀ b ∈ t, a • b ∈ u := image2_subset_iff\n\n"}
{"name":"Set.smul_subset_iff","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns : Set α\nt u : Set β\n⊢ Iff (HasSubset.Subset (HSMul.hSMul s t) u) (∀ (a : α), Membership.mem s a → ∀ (b : β), Membership.mem t b → Membership.mem u (HSMul.hSMul a b))","decl":"@[to_additive] lemma smul_subset_iff : s • t ⊆ u ↔ ∀ a ∈ s, ∀ b ∈ t, a • b ∈ u := image2_subset_iff\n\n"}
{"name":"Set.union_vadd","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns₁ s₂ : Set α\nt : Set β\n⊢ Eq (HVAdd.hVAdd (Union.union s₁ s₂) t) (Union.union (HVAdd.hVAdd s₁ t) (HVAdd.hVAdd s₂ t))","decl":"@[to_additive] lemma union_smul : (s₁ ∪ s₂) • t = s₁ • t ∪ s₂ • t := image2_union_left\n"}
{"name":"Set.union_smul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns₁ s₂ : Set α\nt : Set β\n⊢ Eq (HSMul.hSMul (Union.union s₁ s₂) t) (Union.union (HSMul.hSMul s₁ t) (HSMul.hSMul s₂ t))","decl":"@[to_additive] lemma union_smul : (s₁ ∪ s₂) • t = s₁ • t ∪ s₂ • t := image2_union_left\n"}
{"name":"Set.vadd_union","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns : Set α\nt₁ t₂ : Set β\n⊢ Eq (HVAdd.hVAdd s (Union.union t₁ t₂)) (Union.union (HVAdd.hVAdd s t₁) (HVAdd.hVAdd s t₂))","decl":"@[to_additive] lemma smul_union : s • (t₁ ∪ t₂) = s • t₁ ∪ s • t₂ := image2_union_right\n\n"}
{"name":"Set.smul_union","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns : Set α\nt₁ t₂ : Set β\n⊢ Eq (HSMul.hSMul s (Union.union t₁ t₂)) (Union.union (HSMul.hSMul s t₁) (HSMul.hSMul s t₂))","decl":"@[to_additive] lemma smul_union : s • (t₁ ∪ t₂) = s • t₁ ∪ s • t₂ := image2_union_right\n\n"}
{"name":"Set.inter_smul_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns₁ s₂ : Set α\nt : Set β\n⊢ HasSubset.Subset (HSMul.hSMul (Inter.inter s₁ s₂) t) (Inter.inter (HSMul.hSMul s₁ t) (HSMul.hSMul s₂ t))","decl":"@[to_additive]\nlemma inter_smul_subset : (s₁ ∩ s₂) • t ⊆ s₁ • t ∩ s₂ • t := image2_inter_subset_left\n\n"}
{"name":"Set.inter_vadd_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns₁ s₂ : Set α\nt : Set β\n⊢ HasSubset.Subset (HVAdd.hVAdd (Inter.inter s₁ s₂) t) (Inter.inter (HVAdd.hVAdd s₁ t) (HVAdd.hVAdd s₂ t))","decl":"@[to_additive]\nlemma inter_smul_subset : (s₁ ∩ s₂) • t ⊆ s₁ • t ∩ s₂ • t := image2_inter_subset_left\n\n"}
{"name":"Set.smul_inter_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns : Set α\nt₁ t₂ : Set β\n⊢ HasSubset.Subset (HSMul.hSMul s (Inter.inter t₁ t₂)) (Inter.inter (HSMul.hSMul s t₁) (HSMul.hSMul s t₂))","decl":"@[to_additive]\nlemma smul_inter_subset : s • (t₁ ∩ t₂) ⊆ s • t₁ ∩ s • t₂ := image2_inter_subset_right\n\n"}
{"name":"Set.vadd_inter_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns : Set α\nt₁ t₂ : Set β\n⊢ HasSubset.Subset (HVAdd.hVAdd s (Inter.inter t₁ t₂)) (Inter.inter (HVAdd.hVAdd s t₁) (HVAdd.hVAdd s t₂))","decl":"@[to_additive]\nlemma smul_inter_subset : s • (t₁ ∩ t₂) ⊆ s • t₁ ∩ s • t₂ := image2_inter_subset_right\n\n"}
{"name":"Set.inter_smul_union_subset_union","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns₁ s₂ : Set α\nt₁ t₂ : Set β\n⊢ HasSubset.Subset (HSMul.hSMul (Inter.inter s₁ s₂) (Union.union t₁ t₂)) (Union.union (HSMul.hSMul s₁ t₁) (HSMul.hSMul s₂ t₂))","decl":"@[to_additive]\nlemma inter_smul_union_subset_union : (s₁ ∩ s₂) • (t₁ ∪ t₂) ⊆ s₁ • t₁ ∪ s₂ • t₂ :=\n  image2_inter_union_subset_union\n\n"}
{"name":"Set.inter_vadd_union_subset_union","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns₁ s₂ : Set α\nt₁ t₂ : Set β\n⊢ HasSubset.Subset (HVAdd.hVAdd (Inter.inter s₁ s₂) (Union.union t₁ t₂)) (Union.union (HVAdd.hVAdd s₁ t₁) (HVAdd.hVAdd s₂ t₂))","decl":"@[to_additive]\nlemma inter_smul_union_subset_union : (s₁ ∩ s₂) • (t₁ ∪ t₂) ⊆ s₁ • t₁ ∪ s₂ • t₂ :=\n  image2_inter_union_subset_union\n\n"}
{"name":"Set.union_smul_inter_subset_union","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns₁ s₂ : Set α\nt₁ t₂ : Set β\n⊢ HasSubset.Subset (HSMul.hSMul (Union.union s₁ s₂) (Inter.inter t₁ t₂)) (Union.union (HSMul.hSMul s₁ t₁) (HSMul.hSMul s₂ t₂))","decl":"@[to_additive]\nlemma union_smul_inter_subset_union : (s₁ ∪ s₂) • (t₁ ∩ t₂) ⊆ s₁ • t₁ ∪ s₂ • t₂ :=\n  image2_union_inter_subset_union\n\n"}
{"name":"Set.union_vadd_inter_subset_union","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns₁ s₂ : Set α\nt₁ t₂ : Set β\n⊢ HasSubset.Subset (HVAdd.hVAdd (Union.union s₁ s₂) (Inter.inter t₁ t₂)) (Union.union (HVAdd.hVAdd s₁ t₁) (HVAdd.hVAdd s₂ t₂))","decl":"@[to_additive]\nlemma union_smul_inter_subset_union : (s₁ ∪ s₂) • (t₁ ∩ t₂) ⊆ s₁ • t₁ ∪ s₂ • t₂ :=\n  image2_union_inter_subset_union\n\n"}
{"name":"Set.iUnion_vadd_left_image","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns : Set α\nt : Set β\n⊢ Eq (Set.iUnion fun a => Set.iUnion fun h => HVAdd.hVAdd a t) (HVAdd.hVAdd s t)","decl":"@[to_additive] lemma iUnion_smul_left_image : ⋃ a ∈ s, a • t = s • t := iUnion_image_left _\n\n"}
{"name":"Set.iUnion_smul_left_image","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns : Set α\nt : Set β\n⊢ Eq (Set.iUnion fun a => Set.iUnion fun h => HSMul.hSMul a t) (HSMul.hSMul s t)","decl":"@[to_additive] lemma iUnion_smul_left_image : ⋃ a ∈ s, a • t = s • t := iUnion_image_left _\n\n"}
{"name":"Set.iUnion_smul_right_image","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns : Set α\nt : Set β\n⊢ Eq (Set.iUnion fun a => Set.iUnion fun h => Set.image (fun x => HSMul.hSMul x a) s) (HSMul.hSMul s t)","decl":"@[to_additive]\nlemma iUnion_smul_right_image : ⋃ a ∈ t, (· • a) '' s = s • t := iUnion_image_right _\n\n"}
{"name":"Set.iUnion_vadd_right_image","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns : Set α\nt : Set β\n⊢ Eq (Set.iUnion fun a => Set.iUnion fun h => Set.image (fun x => HVAdd.hVAdd x a) s) (HVAdd.hVAdd s t)","decl":"@[to_additive]\nlemma iUnion_smul_right_image : ⋃ a ∈ t, (· • a) '' s = s • t := iUnion_image_right _\n\n"}
{"name":"Set.iUnion_vadd","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Sort u_5\ninst✝ : VAdd α β\ns : ι → Set α\nt : Set β\n⊢ Eq (HVAdd.hVAdd (Set.iUnion fun i => s i) t) (Set.iUnion fun i => HVAdd.hVAdd (s i) t)","decl":"@[to_additive]\nlemma iUnion_smul (s : ι → Set α) (t : Set β) : (⋃ i, s i) • t = ⋃ i, s i • t :=\n  image2_iUnion_left ..\n\n"}
{"name":"Set.iUnion_smul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Sort u_5\ninst✝ : SMul α β\ns : ι → Set α\nt : Set β\n⊢ Eq (HSMul.hSMul (Set.iUnion fun i => s i) t) (Set.iUnion fun i => HSMul.hSMul (s i) t)","decl":"@[to_additive]\nlemma iUnion_smul (s : ι → Set α) (t : Set β) : (⋃ i, s i) • t = ⋃ i, s i • t :=\n  image2_iUnion_left ..\n\n"}
{"name":"Set.vadd_iUnion","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Sort u_5\ninst✝ : VAdd α β\ns : Set α\nt : ι → Set β\n⊢ Eq (HVAdd.hVAdd s (Set.iUnion fun i => t i)) (Set.iUnion fun i => HVAdd.hVAdd s (t i))","decl":"@[to_additive]\nlemma smul_iUnion (s : Set α) (t : ι → Set β) : (s • ⋃ i, t i) = ⋃ i, s • t i :=\n  image2_iUnion_right ..\n\n"}
{"name":"Set.smul_iUnion","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Sort u_5\ninst✝ : SMul α β\ns : Set α\nt : ι → Set β\n⊢ Eq (HSMul.hSMul s (Set.iUnion fun i => t i)) (Set.iUnion fun i => HSMul.hSMul s (t i))","decl":"@[to_additive]\nlemma smul_iUnion (s : Set α) (t : ι → Set β) : (s • ⋃ i, t i) = ⋃ i, s • t i :=\n  image2_iUnion_right ..\n\n"}
{"name":"Set.sUnion_vadd","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nS : Set (Set α)\nt : Set β\n⊢ Eq (HVAdd.hVAdd S.sUnion t) (Set.iUnion fun s => Set.iUnion fun h => HVAdd.hVAdd s t)","decl":"@[to_additive]\nlemma sUnion_smul (S : Set (Set α)) (t : Set β) : ⋃₀ S • t = ⋃ s ∈ S, s • t :=\n  image2_sUnion_left ..\n\n"}
{"name":"Set.sUnion_smul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nS : Set (Set α)\nt : Set β\n⊢ Eq (HSMul.hSMul S.sUnion t) (Set.iUnion fun s => Set.iUnion fun h => HSMul.hSMul s t)","decl":"@[to_additive]\nlemma sUnion_smul (S : Set (Set α)) (t : Set β) : ⋃₀ S • t = ⋃ s ∈ S, s • t :=\n  image2_sUnion_left ..\n\n"}
{"name":"Set.vadd_sUnion","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns : Set α\nT : Set (Set β)\n⊢ Eq (HVAdd.hVAdd s T.sUnion) (Set.iUnion fun t => Set.iUnion fun h => HVAdd.hVAdd s t)","decl":"@[to_additive]\nlemma smul_sUnion (s : Set α) (T : Set (Set β)) : s • ⋃₀ T = ⋃ t ∈ T, s • t :=\n  image2_sUnion_right ..\n\n"}
{"name":"Set.smul_sUnion","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns : Set α\nT : Set (Set β)\n⊢ Eq (HSMul.hSMul s T.sUnion) (Set.iUnion fun t => Set.iUnion fun h => HSMul.hSMul s t)","decl":"@[to_additive]\nlemma smul_sUnion (s : Set α) (T : Set (Set β)) : s • ⋃₀ T = ⋃ t ∈ T, s • t :=\n  image2_sUnion_right ..\n\n"}
{"name":"Set.iUnion₂_vadd","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Sort u_5\nκ : ι → Sort u_6\ninst✝ : VAdd α β\ns : (i : ι) → κ i → Set α\nt : Set β\n⊢ Eq (HVAdd.hVAdd (Set.iUnion fun i => Set.iUnion fun j => s i j) t) (Set.iUnion fun i => Set.iUnion fun j => HVAdd.hVAdd (s i j) t)","decl":"@[to_additive]\nlemma iUnion₂_smul (s : ∀ i, κ i → Set α) (t : Set β) :\n    (⋃ i, ⋃ j, s i j) • t = ⋃ i, ⋃ j, s i j • t := image2_iUnion₂_left ..\n\n"}
{"name":"Set.iUnion₂_smul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Sort u_5\nκ : ι → Sort u_6\ninst✝ : SMul α β\ns : (i : ι) → κ i → Set α\nt : Set β\n⊢ Eq (HSMul.hSMul (Set.iUnion fun i => Set.iUnion fun j => s i j) t) (Set.iUnion fun i => Set.iUnion fun j => HSMul.hSMul (s i j) t)","decl":"@[to_additive]\nlemma iUnion₂_smul (s : ∀ i, κ i → Set α) (t : Set β) :\n    (⋃ i, ⋃ j, s i j) • t = ⋃ i, ⋃ j, s i j • t := image2_iUnion₂_left ..\n\n"}
{"name":"Set.vadd_iUnion₂","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Sort u_5\nκ : ι → Sort u_6\ninst✝ : VAdd α β\ns : Set α\nt : (i : ι) → κ i → Set β\n⊢ Eq (HVAdd.hVAdd s (Set.iUnion fun i => Set.iUnion fun j => t i j)) (Set.iUnion fun i => Set.iUnion fun j => HVAdd.hVAdd s (t i j))","decl":"@[to_additive]\nlemma smul_iUnion₂ (s : Set α) (t : ∀ i, κ i → Set β) :\n    (s • ⋃ i, ⋃ j, t i j) = ⋃ i, ⋃ j, s • t i j := image2_iUnion₂_right ..\n\n"}
{"name":"Set.smul_iUnion₂","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Sort u_5\nκ : ι → Sort u_6\ninst✝ : SMul α β\ns : Set α\nt : (i : ι) → κ i → Set β\n⊢ Eq (HSMul.hSMul s (Set.iUnion fun i => Set.iUnion fun j => t i j)) (Set.iUnion fun i => Set.iUnion fun j => HSMul.hSMul s (t i j))","decl":"@[to_additive]\nlemma smul_iUnion₂ (s : Set α) (t : ∀ i, κ i → Set β) :\n    (s • ⋃ i, ⋃ j, t i j) = ⋃ i, ⋃ j, s • t i j := image2_iUnion₂_right ..\n\n"}
{"name":"Set.iInter_smul_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Sort u_5\ninst✝ : SMul α β\ns : ι → Set α\nt : Set β\n⊢ HasSubset.Subset (HSMul.hSMul (Set.iInter fun i => s i) t) (Set.iInter fun i => HSMul.hSMul (s i) t)","decl":"@[to_additive]\nlemma iInter_smul_subset (s : ι → Set α) (t : Set β) : (⋂ i, s i) • t ⊆ ⋂ i, s i • t :=\n  image2_iInter_subset_left ..\n\n"}
{"name":"Set.iInter_vadd_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Sort u_5\ninst✝ : VAdd α β\ns : ι → Set α\nt : Set β\n⊢ HasSubset.Subset (HVAdd.hVAdd (Set.iInter fun i => s i) t) (Set.iInter fun i => HVAdd.hVAdd (s i) t)","decl":"@[to_additive]\nlemma iInter_smul_subset (s : ι → Set α) (t : Set β) : (⋂ i, s i) • t ⊆ ⋂ i, s i • t :=\n  image2_iInter_subset_left ..\n\n"}
{"name":"Set.smul_iInter_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Sort u_5\ninst✝ : SMul α β\ns : Set α\nt : ι → Set β\n⊢ HasSubset.Subset (HSMul.hSMul s (Set.iInter fun i => t i)) (Set.iInter fun i => HSMul.hSMul s (t i))","decl":"@[to_additive]\nlemma smul_iInter_subset (s : Set α) (t : ι → Set β) : (s • ⋂ i, t i) ⊆ ⋂ i, s • t i :=\n  image2_iInter_subset_right ..\n\n"}
{"name":"Set.vadd_iInter_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Sort u_5\ninst✝ : VAdd α β\ns : Set α\nt : ι → Set β\n⊢ HasSubset.Subset (HVAdd.hVAdd s (Set.iInter fun i => t i)) (Set.iInter fun i => HVAdd.hVAdd s (t i))","decl":"@[to_additive]\nlemma smul_iInter_subset (s : Set α) (t : ι → Set β) : (s • ⋂ i, t i) ⊆ ⋂ i, s • t i :=\n  image2_iInter_subset_right ..\n\n"}
{"name":"Set.sInter_vadd_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nS : Set (Set α)\nt : Set β\n⊢ HasSubset.Subset (HVAdd.hVAdd S.sInter t) (Set.iInter fun s => Set.iInter fun h => HVAdd.hVAdd s t)","decl":"@[to_additive]\nlemma sInter_smul_subset (S : Set (Set α)) (t : Set β) : ⋂₀ S • t ⊆ ⋂ s ∈ S, s • t :=\n  image2_sInter_left_subset S t (fun a x => a • x)\n\n"}
{"name":"Set.sInter_smul_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nS : Set (Set α)\nt : Set β\n⊢ HasSubset.Subset (HSMul.hSMul S.sInter t) (Set.iInter fun s => Set.iInter fun h => HSMul.hSMul s t)","decl":"@[to_additive]\nlemma sInter_smul_subset (S : Set (Set α)) (t : Set β) : ⋂₀ S • t ⊆ ⋂ s ∈ S, s • t :=\n  image2_sInter_left_subset S t (fun a x => a • x)\n\n"}
{"name":"Set.vadd_sInter_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns : Set α\nT : Set (Set β)\n⊢ HasSubset.Subset (HVAdd.hVAdd s T.sInter) (Set.iInter fun t => Set.iInter fun h => HVAdd.hVAdd s t)","decl":"@[to_additive]\nlemma smul_sInter_subset (s : Set α) (T : Set (Set β)) : s • ⋂₀ T ⊆ ⋂ t ∈ T, s • t :=\n  image2_sInter_right_subset s T (fun a x => a • x)\n\n"}
{"name":"Set.smul_sInter_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns : Set α\nT : Set (Set β)\n⊢ HasSubset.Subset (HSMul.hSMul s T.sInter) (Set.iInter fun t => Set.iInter fun h => HSMul.hSMul s t)","decl":"@[to_additive]\nlemma smul_sInter_subset (s : Set α) (T : Set (Set β)) : s • ⋂₀ T ⊆ ⋂ t ∈ T, s • t :=\n  image2_sInter_right_subset s T (fun a x => a • x)\n\n"}
{"name":"Set.iInter₂_vadd_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Sort u_5\nκ : ι → Sort u_6\ninst✝ : VAdd α β\ns : (i : ι) → κ i → Set α\nt : Set β\n⊢ HasSubset.Subset (HVAdd.hVAdd (Set.iInter fun i => Set.iInter fun j => s i j) t) (Set.iInter fun i => Set.iInter fun j => HVAdd.hVAdd (s i j) t)","decl":"@[to_additive]\nlemma iInter₂_smul_subset (s : ∀ i, κ i → Set α) (t : Set β) :\n    (⋂ i, ⋂ j, s i j) • t ⊆ ⋂ i, ⋂ j, s i j • t := image2_iInter₂_subset_left ..\n\n"}
{"name":"Set.iInter₂_smul_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Sort u_5\nκ : ι → Sort u_6\ninst✝ : SMul α β\ns : (i : ι) → κ i → Set α\nt : Set β\n⊢ HasSubset.Subset (HSMul.hSMul (Set.iInter fun i => Set.iInter fun j => s i j) t) (Set.iInter fun i => Set.iInter fun j => HSMul.hSMul (s i j) t)","decl":"@[to_additive]\nlemma iInter₂_smul_subset (s : ∀ i, κ i → Set α) (t : Set β) :\n    (⋂ i, ⋂ j, s i j) • t ⊆ ⋂ i, ⋂ j, s i j • t := image2_iInter₂_subset_left ..\n\n"}
{"name":"Set.vadd_iInter₂_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Sort u_5\nκ : ι → Sort u_6\ninst✝ : VAdd α β\ns : Set α\nt : (i : ι) → κ i → Set β\n⊢ HasSubset.Subset (HVAdd.hVAdd s (Set.iInter fun i => Set.iInter fun j => t i j)) (Set.iInter fun i => Set.iInter fun j => HVAdd.hVAdd s (t i j))","decl":"@[to_additive]\nlemma smul_iInter₂_subset (s : Set α) (t : ∀ i, κ i → Set β) :\n    (s • ⋂ i, ⋂ j, t i j) ⊆ ⋂ i, ⋂ j, s • t i j := image2_iInter₂_subset_right ..\n\n"}
{"name":"Set.smul_iInter₂_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Sort u_5\nκ : ι → Sort u_6\ninst✝ : SMul α β\ns : Set α\nt : (i : ι) → κ i → Set β\n⊢ HasSubset.Subset (HSMul.hSMul s (Set.iInter fun i => Set.iInter fun j => t i j)) (Set.iInter fun i => Set.iInter fun j => HSMul.hSMul s (t i j))","decl":"@[to_additive]\nlemma smul_iInter₂_subset (s : Set α) (t : ∀ i, κ i → Set β) :\n    (s • ⋂ i, ⋂ j, t i j) ⊆ ⋂ i, ⋂ j, s • t i j := image2_iInter₂_subset_right ..\n\n"}
{"name":"Set.smul_set_subset_smul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nt : Set β\na : α\ns : Set α\na✝ : Membership.mem s a\n⊢ HasSubset.Subset (HSMul.hSMul a t) (HSMul.hSMul s t)","decl":"@[to_additive]\nlemma smul_set_subset_smul {s : Set α} : a ∈ s → a • t ⊆ s • t := image_subset_image2_right\n\n"}
{"name":"Set.vadd_set_subset_vadd","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nt : Set β\na : α\ns : Set α\na✝ : Membership.mem s a\n⊢ HasSubset.Subset (HVAdd.hVAdd a t) (HVAdd.hVAdd s t)","decl":"@[to_additive]\nlemma smul_set_subset_smul {s : Set α} : a ∈ s → a • t ⊆ s • t := image_subset_image2_right\n\n"}
{"name":"Set.iUnion_smul_set","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns : Set α\nt : Set β\n⊢ Eq (Set.iUnion fun a => Set.iUnion fun h => HSMul.hSMul a t) (HSMul.hSMul s t)","decl":"@[to_additive (attr := simp)]\nlemma iUnion_smul_set (s : Set α) (t : Set β) : ⋃ a ∈ s, a • t = s • t := iUnion_image_left _\n\n"}
{"name":"Set.iUnion_vadd_set","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns : Set α\nt : Set β\n⊢ Eq (Set.iUnion fun a => Set.iUnion fun h => HVAdd.hVAdd a t) (HVAdd.hVAdd s t)","decl":"@[to_additive (attr := simp)]\nlemma iUnion_smul_set (s : Set α) (t : Set β) : ⋃ a ∈ s, a • t = s • t := iUnion_image_left _\n\n"}
{"name":"Set.image_vadd","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nt : Set β\na : α\n⊢ Eq (Set.image (fun x => HVAdd.hVAdd a x) t) (HVAdd.hVAdd a t)","decl":"@[to_additive] lemma image_smul : (fun x ↦ a • x) '' t = a • t := rfl\n\n"}
{"name":"Set.image_smul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nt : Set β\na : α\n⊢ Eq (Set.image (fun x => HSMul.hSMul a x) t) (HSMul.hSMul a t)","decl":"@[to_additive] lemma image_smul : (fun x ↦ a • x) '' t = a • t := rfl\n\n"}
{"name":"Set.mem_smul_set","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nt : Set β\na : α\nx : β\n⊢ Iff (Membership.mem (HSMul.hSMul a t) x) (Exists fun y => And (Membership.mem t y) (Eq (HSMul.hSMul a y) x))","decl":"@[to_additive] lemma mem_smul_set : x ∈ a • t ↔ ∃ y, y ∈ t ∧ a • y = x := Iff.rfl\n\n"}
{"name":"Set.mem_vadd_set","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nt : Set β\na : α\nx : β\n⊢ Iff (Membership.mem (HVAdd.hVAdd a t) x) (Exists fun y => And (Membership.mem t y) (Eq (HVAdd.hVAdd a y) x))","decl":"@[to_additive] lemma mem_smul_set : x ∈ a • t ↔ ∃ y, y ∈ t ∧ a • y = x := Iff.rfl\n\n"}
{"name":"Set.vadd_mem_vadd_set","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns : Set β\na : α\nb : β\na✝ : Membership.mem s b\n⊢ Membership.mem (HVAdd.hVAdd a s) (HVAdd.hVAdd a b)","decl":"@[to_additive] lemma smul_mem_smul_set : b ∈ s → a • b ∈ a • s := mem_image_of_mem _\n\n"}
{"name":"Set.smul_mem_smul_set","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns : Set β\na : α\nb : β\na✝ : Membership.mem s b\n⊢ Membership.mem (HSMul.hSMul a s) (HSMul.hSMul a b)","decl":"@[to_additive] lemma smul_mem_smul_set : b ∈ s → a • b ∈ a • s := mem_image_of_mem _\n\n"}
{"name":"Set.smul_set_empty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\na : α\n⊢ Eq (HSMul.hSMul a EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)] lemma smul_set_empty : a • (∅ : Set β) = ∅ := image_empty _\n"}
{"name":"Set.vadd_set_empty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\na : α\n⊢ Eq (HVAdd.hVAdd a EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)] lemma smul_set_empty : a • (∅ : Set β) = ∅ := image_empty _\n"}
{"name":"Set.smul_set_eq_empty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns : Set β\na : α\n⊢ Iff (Eq (HSMul.hSMul a s) EmptyCollection.emptyCollection) (Eq s EmptyCollection.emptyCollection)","decl":"@[to_additive (attr := simp)] lemma smul_set_eq_empty : a • s = ∅ ↔ s = ∅ := image_eq_empty\n\n"}
{"name":"Set.vadd_set_eq_empty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns : Set β\na : α\n⊢ Iff (Eq (HVAdd.hVAdd a s) EmptyCollection.emptyCollection) (Eq s EmptyCollection.emptyCollection)","decl":"@[to_additive (attr := simp)] lemma smul_set_eq_empty : a • s = ∅ ↔ s = ∅ := image_eq_empty\n\n"}
{"name":"Set.smul_set_nonempty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns : Set β\na : α\n⊢ Iff (HSMul.hSMul a s).Nonempty s.Nonempty","decl":"@[to_additive (attr := simp)]\nlemma smul_set_nonempty : (a • s).Nonempty ↔ s.Nonempty := image_nonempty\n\n"}
{"name":"Set.vadd_set_nonempty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns : Set β\na : α\n⊢ Iff (HVAdd.hVAdd a s).Nonempty s.Nonempty","decl":"@[to_additive (attr := simp)]\nlemma smul_set_nonempty : (a • s).Nonempty ↔ s.Nonempty := image_nonempty\n\n"}
{"name":"Set.vadd_set_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\na : α\nb : β\n⊢ Eq (HVAdd.hVAdd a (Singleton.singleton b)) (Singleton.singleton (HVAdd.hVAdd a b))","decl":"@[to_additive (attr := simp)]\nlemma smul_set_singleton : a • ({b} : Set β) = {a • b} := image_singleton\n\n"}
{"name":"Set.smul_set_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\na : α\nb : β\n⊢ Eq (HSMul.hSMul a (Singleton.singleton b)) (Singleton.singleton (HSMul.hSMul a b))","decl":"@[to_additive (attr := simp)]\nlemma smul_set_singleton : a • ({b} : Set β) = {a • b} := image_singleton\n\n"}
{"name":"Set.vadd_set_mono","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns t : Set β\na : α\na✝ : HasSubset.Subset s t\n⊢ HasSubset.Subset (HVAdd.hVAdd a s) (HVAdd.hVAdd a t)","decl":"@[to_additive (attr := gcongr)] lemma smul_set_mono : s ⊆ t → a • s ⊆ a • t := image_subset _\n\n"}
{"name":"Set.smul_set_mono","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns t : Set β\na : α\na✝ : HasSubset.Subset s t\n⊢ HasSubset.Subset (HSMul.hSMul a s) (HSMul.hSMul a t)","decl":"@[to_additive (attr := gcongr)] lemma smul_set_mono : s ⊆ t → a • s ⊆ a • t := image_subset _\n\n"}
{"name":"Set.vadd_set_subset_iff","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns t : Set β\na : α\n⊢ Iff (HasSubset.Subset (HVAdd.hVAdd a s) t) (∀ ⦃b : β⦄, Membership.mem s b → Membership.mem t (HVAdd.hVAdd a b))","decl":"@[to_additive]\nlemma smul_set_subset_iff : a • s ⊆ t ↔ ∀ ⦃b⦄, b ∈ s → a • b ∈ t :=\n  image_subset_iff\n\n"}
{"name":"Set.smul_set_subset_iff","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns t : Set β\na : α\n⊢ Iff (HasSubset.Subset (HSMul.hSMul a s) t) (∀ ⦃b : β⦄, Membership.mem s b → Membership.mem t (HSMul.hSMul a b))","decl":"@[to_additive]\nlemma smul_set_subset_iff : a • s ⊆ t ↔ ∀ ⦃b⦄, b ∈ s → a • b ∈ t :=\n  image_subset_iff\n\n"}
{"name":"Set.smul_set_union","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nt₁ t₂ : Set β\na : α\n⊢ Eq (HSMul.hSMul a (Union.union t₁ t₂)) (Union.union (HSMul.hSMul a t₁) (HSMul.hSMul a t₂))","decl":"@[to_additive]\nlemma smul_set_union : a • (t₁ ∪ t₂) = a • t₁ ∪ a • t₂ :=\n  image_union ..\n\n"}
{"name":"Set.vadd_set_union","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nt₁ t₂ : Set β\na : α\n⊢ Eq (HVAdd.hVAdd a (Union.union t₁ t₂)) (Union.union (HVAdd.hVAdd a t₁) (HVAdd.hVAdd a t₂))","decl":"@[to_additive]\nlemma smul_set_union : a • (t₁ ∪ t₂) = a • t₁ ∪ a • t₂ :=\n  image_union ..\n\n"}
{"name":"Set.vadd_set_insert","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\na : α\nb : β\ns : Set β\n⊢ Eq (HVAdd.hVAdd a (Insert.insert b s)) (Insert.insert (HVAdd.hVAdd a b) (HVAdd.hVAdd a s))","decl":"@[to_additive]\nlemma smul_set_insert (a : α) (b : β) (s : Set β) : a • insert b s = insert (a • b) (a • s) :=\n  image_insert_eq ..\n\n"}
{"name":"Set.smul_set_insert","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\na : α\nb : β\ns : Set β\n⊢ Eq (HSMul.hSMul a (Insert.insert b s)) (Insert.insert (HSMul.hSMul a b) (HSMul.hSMul a s))","decl":"@[to_additive]\nlemma smul_set_insert (a : α) (b : β) (s : Set β) : a • insert b s = insert (a • b) (a • s) :=\n  image_insert_eq ..\n\n"}
{"name":"Set.smul_set_inter_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nt₁ t₂ : Set β\na : α\n⊢ HasSubset.Subset (HSMul.hSMul a (Inter.inter t₁ t₂)) (Inter.inter (HSMul.hSMul a t₁) (HSMul.hSMul a t₂))","decl":"@[to_additive]\nlemma smul_set_inter_subset : a • (t₁ ∩ t₂) ⊆ a • t₁ ∩ a • t₂ :=\n  image_inter_subset ..\n\n"}
{"name":"Set.vadd_set_inter_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nt₁ t₂ : Set β\na : α\n⊢ HasSubset.Subset (HVAdd.hVAdd a (Inter.inter t₁ t₂)) (Inter.inter (HVAdd.hVAdd a t₁) (HVAdd.hVAdd a t₂))","decl":"@[to_additive]\nlemma smul_set_inter_subset : a • (t₁ ∩ t₂) ⊆ a • t₁ ∩ a • t₂ :=\n  image_inter_subset ..\n\n"}
{"name":"Set.smul_set_iUnion","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Sort u_5\ninst✝ : SMul α β\na : α\ns : ι → Set β\n⊢ Eq (HSMul.hSMul a (Set.iUnion fun i => s i)) (Set.iUnion fun i => HSMul.hSMul a (s i))","decl":"@[to_additive]\nlemma smul_set_iUnion (a : α) (s : ι → Set β) : a • ⋃ i, s i = ⋃ i, a • s i :=\n  image_iUnion\n\n"}
{"name":"Set.vadd_set_iUnion","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Sort u_5\ninst✝ : VAdd α β\na : α\ns : ι → Set β\n⊢ Eq (HVAdd.hVAdd a (Set.iUnion fun i => s i)) (Set.iUnion fun i => HVAdd.hVAdd a (s i))","decl":"@[to_additive]\nlemma smul_set_iUnion (a : α) (s : ι → Set β) : a • ⋃ i, s i = ⋃ i, a • s i :=\n  image_iUnion\n\n"}
{"name":"Set.vadd_set_iUnion₂","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Sort u_5\nκ : ι → Sort u_6\ninst✝ : VAdd α β\na : α\ns : (i : ι) → κ i → Set β\n⊢ Eq (HVAdd.hVAdd a (Set.iUnion fun i => Set.iUnion fun j => s i j)) (Set.iUnion fun i => Set.iUnion fun j => HVAdd.hVAdd a (s i j))","decl":"@[to_additive]\nlemma smul_set_iUnion₂ (a : α) (s : ∀ i, κ i → Set β) :\n    a • ⋃ i, ⋃ j, s i j = ⋃ i, ⋃ j, a • s i j := image_iUnion₂ ..\n\n"}
{"name":"Set.smul_set_iUnion₂","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Sort u_5\nκ : ι → Sort u_6\ninst✝ : SMul α β\na : α\ns : (i : ι) → κ i → Set β\n⊢ Eq (HSMul.hSMul a (Set.iUnion fun i => Set.iUnion fun j => s i j)) (Set.iUnion fun i => Set.iUnion fun j => HSMul.hSMul a (s i j))","decl":"@[to_additive]\nlemma smul_set_iUnion₂ (a : α) (s : ∀ i, κ i → Set β) :\n    a • ⋃ i, ⋃ j, s i j = ⋃ i, ⋃ j, a • s i j := image_iUnion₂ ..\n\n"}
{"name":"Set.vadd_set_sUnion","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\na : α\nS : Set (Set β)\n⊢ Eq (HVAdd.hVAdd a S.sUnion) (Set.iUnion fun s => Set.iUnion fun h => HVAdd.hVAdd a s)","decl":"@[to_additive]\nlemma smul_set_sUnion (a : α) (S : Set (Set β)) : a • ⋃₀ S = ⋃ s ∈ S, a • s := by\n  rw [sUnion_eq_biUnion, smul_set_iUnion₂]\n\n"}
{"name":"Set.smul_set_sUnion","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\na : α\nS : Set (Set β)\n⊢ Eq (HSMul.hSMul a S.sUnion) (Set.iUnion fun s => Set.iUnion fun h => HSMul.hSMul a s)","decl":"@[to_additive]\nlemma smul_set_sUnion (a : α) (S : Set (Set β)) : a • ⋃₀ S = ⋃ s ∈ S, a • s := by\n  rw [sUnion_eq_biUnion, smul_set_iUnion₂]\n\n"}
{"name":"Set.smul_set_iInter_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Sort u_5\ninst✝ : SMul α β\na : α\nt : ι → Set β\n⊢ HasSubset.Subset (HSMul.hSMul a (Set.iInter fun i => t i)) (Set.iInter fun i => HSMul.hSMul a (t i))","decl":"@[to_additive]\nlemma smul_set_iInter_subset (a : α) (t : ι → Set β) : a • ⋂ i, t i ⊆ ⋂ i, a • t i :=\n  image_iInter_subset ..\n\n"}
{"name":"Set.vadd_set_iInter_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Sort u_5\ninst✝ : VAdd α β\na : α\nt : ι → Set β\n⊢ HasSubset.Subset (HVAdd.hVAdd a (Set.iInter fun i => t i)) (Set.iInter fun i => HVAdd.hVAdd a (t i))","decl":"@[to_additive]\nlemma smul_set_iInter_subset (a : α) (t : ι → Set β) : a • ⋂ i, t i ⊆ ⋂ i, a • t i :=\n  image_iInter_subset ..\n\n"}
{"name":"Set.smul_set_sInter_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\na : α\nS : Set (Set β)\n⊢ HasSubset.Subset (HSMul.hSMul a S.sInter) (Set.iInter fun s => Set.iInter fun h => HSMul.hSMul a s)","decl":"@[to_additive]\nlemma smul_set_sInter_subset (a : α) (S : Set (Set β)) :\n    a • ⋂₀ S ⊆ ⋂ s ∈ S, a • s := image_sInter_subset ..\n\n"}
{"name":"Set.vadd_set_sInter_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\na : α\nS : Set (Set β)\n⊢ HasSubset.Subset (HVAdd.hVAdd a S.sInter) (Set.iInter fun s => Set.iInter fun h => HVAdd.hVAdd a s)","decl":"@[to_additive]\nlemma smul_set_sInter_subset (a : α) (S : Set (Set β)) :\n    a • ⋂₀ S ⊆ ⋂ s ∈ S, a • s := image_sInter_subset ..\n\n"}
{"name":"Set.smul_set_iInter₂_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Sort u_5\nκ : ι → Sort u_6\ninst✝ : SMul α β\na : α\nt : (i : ι) → κ i → Set β\n⊢ HasSubset.Subset (HSMul.hSMul a (Set.iInter fun i => Set.iInter fun j => t i j)) (Set.iInter fun i => Set.iInter fun j => HSMul.hSMul a (t i j))","decl":"@[to_additive]\nlemma smul_set_iInter₂_subset (a : α) (t : ∀ i, κ i → Set β) :\n    a • ⋂ i, ⋂ j, t i j ⊆ ⋂ i, ⋂ j, a • t i j := image_iInter₂_subset ..\n\n"}
{"name":"Set.vadd_set_iInter₂_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Sort u_5\nκ : ι → Sort u_6\ninst✝ : VAdd α β\na : α\nt : (i : ι) → κ i → Set β\n⊢ HasSubset.Subset (HVAdd.hVAdd a (Set.iInter fun i => Set.iInter fun j => t i j)) (Set.iInter fun i => Set.iInter fun j => HVAdd.hVAdd a (t i j))","decl":"@[to_additive]\nlemma smul_set_iInter₂_subset (a : α) (t : ∀ i, κ i → Set β) :\n    a • ⋂ i, ⋂ j, t i j ⊆ ⋂ i, ⋂ j, a • t i j := image_iInter₂_subset ..\n\n"}
{"name":"Set.Nonempty.vadd_set","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns : Set β\na : α\na✝ : s.Nonempty\n⊢ (HVAdd.hVAdd a s).Nonempty","decl":"@[to_additive] lemma Nonempty.smul_set : s.Nonempty → (a • s).Nonempty := Nonempty.image _\n\n"}
{"name":"Set.Nonempty.smul_set","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns : Set β\na : α\na✝ : s.Nonempty\n⊢ (HSMul.hSMul a s).Nonempty","decl":"@[to_additive] lemma Nonempty.smul_set : s.Nonempty → (a • s).Nonempty := Nonempty.image _\n\n"}
{"name":"Set.range_smul_range","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Type u_5\nκ : Type u_6\ninst✝ : SMul α β\nb : ι → α\nc : κ → β\n⊢ Eq (HSMul.hSMul (Set.range b) (Set.range c)) (Set.range fun p => HSMul.hSMul (b p.1) (c p.2))","decl":"@[to_additive]\nlemma range_smul_range {ι κ : Type*} [SMul α β] (b : ι → α) (c : κ → β) :\n    range b • range c = range fun p : ι × κ ↦ b p.1 • c p.2 :=\n  image2_range ..\n\n"}
{"name":"Set.range_vadd_range","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Type u_5\nκ : Type u_6\ninst✝ : VAdd α β\nb : ι → α\nc : κ → β\n⊢ Eq (HVAdd.hVAdd (Set.range b) (Set.range c)) (Set.range fun p => HVAdd.hVAdd (b p.1) (c p.2))","decl":"@[to_additive]\nlemma range_smul_range {ι κ : Type*} [SMul α β] (b : ι → α) (c : κ → β) :\n    range b • range c = range fun p : ι × κ ↦ b p.1 • c p.2 :=\n  image2_range ..\n\n"}
{"name":"Set.vadd_set_range","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nι : Sort u_5\na : α\nf : ι → β\n⊢ Eq (HVAdd.hVAdd a (Set.range f)) (Set.range fun i => HVAdd.hVAdd a (f i))","decl":"@[to_additive]\nlemma smul_set_range [SMul α β] {ι : Sort*} (a : α) (f : ι → β) :\n    a • range f = range fun i ↦ a • f i :=\n  (range_comp ..).symm\n\n"}
{"name":"Set.smul_set_range","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nι : Sort u_5\na : α\nf : ι → β\n⊢ Eq (HSMul.hSMul a (Set.range f)) (Set.range fun i => HSMul.hSMul a (f i))","decl":"@[to_additive]\nlemma smul_set_range [SMul α β] {ι : Sort*} (a : α) (f : ι → β) :\n    a • range f = range fun i ↦ a • f i :=\n  (range_comp ..).symm\n\n"}
{"name":"Set.range_vadd","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\nι : Sort u_5\na : α\nf : ι → β\n⊢ Eq (Set.range fun i => HVAdd.hVAdd a (f i)) (HVAdd.hVAdd a (Set.range f))","decl":"@[to_additive] lemma range_smul [SMul α β] {ι : Sort*} (a : α) (f : ι → β) :\n    range (fun i ↦ a • f i) = a • range f := (smul_set_range ..).symm\n\n"}
{"name":"Set.range_smul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\nι : Sort u_5\na : α\nf : ι → β\n⊢ Eq (Set.range fun i => HSMul.hSMul a (f i)) (HSMul.hSMul a (Set.range f))","decl":"@[to_additive] lemma range_smul [SMul α β] {ι : Sort*} (a : α) (f : ι → β) :\n    range (fun i ↦ a • f i) = a • range f := (smul_set_range ..).symm\n\n"}
{"name":"Set.image2_vsub","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\ns t : Set β\n⊢ Eq (Set.image2 VSub.vsub s t) (VSub.vsub s t)","decl":"@[simp] lemma image2_vsub : (image2 VSub.vsub s t : Set α) = s -ᵥ t := rfl\n\n"}
{"name":"Set.image_vsub_prod","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\ns t : Set β\n⊢ Eq (Set.image (fun x => VSub.vsub x.1 x.2) (SProd.sprod s t)) (VSub.vsub s t)","decl":"lemma image_vsub_prod : (fun x : β × β ↦ x.fst -ᵥ x.snd) '' s ×ˢ t = s -ᵥ t := image_prod _\n\n"}
{"name":"Set.mem_vsub","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\ns t : Set β\na : α\n⊢ Iff (Membership.mem (VSub.vsub s t) a) (Exists fun x => And (Membership.mem s x) (Exists fun y => And (Membership.mem t y) (Eq (VSub.vsub x y) a)))","decl":"lemma mem_vsub : a ∈ s -ᵥ t ↔ ∃ x ∈ s, ∃ y ∈ t, x -ᵥ y = a := Iff.rfl\n\n"}
{"name":"Set.vsub_mem_vsub","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\ns t : Set β\nb c : β\nhb : Membership.mem s b\nhc : Membership.mem t c\n⊢ Membership.mem (VSub.vsub s t) (VSub.vsub b c)","decl":"lemma vsub_mem_vsub (hb : b ∈ s) (hc : c ∈ t) : b -ᵥ c ∈ s -ᵥ t := mem_image2_of_mem hb hc\n\n"}
{"name":"Set.empty_vsub","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\nt : Set β\n⊢ Eq (VSub.vsub EmptyCollection.emptyCollection t) EmptyCollection.emptyCollection","decl":"@[simp] lemma empty_vsub (t : Set β) : ∅ -ᵥ t = ∅ := image2_empty_left\n"}
{"name":"Set.vsub_empty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\ns : Set β\n⊢ Eq (VSub.vsub s EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp] lemma vsub_empty (s : Set β) : s -ᵥ ∅ = ∅ := image2_empty_right\n\n"}
{"name":"Set.vsub_eq_empty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\ns t : Set β\n⊢ Iff (Eq (VSub.vsub s t) EmptyCollection.emptyCollection) (Or (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection))","decl":"@[simp] lemma vsub_eq_empty : s -ᵥ t = ∅ ↔ s = ∅ ∨ t = ∅ := image2_eq_empty_iff\n\n"}
{"name":"Set.vsub_nonempty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\ns t : Set β\n⊢ Iff (VSub.vsub s t).Nonempty (And s.Nonempty t.Nonempty)","decl":"@[simp]\nlemma vsub_nonempty : (s -ᵥ t : Set α).Nonempty ↔ s.Nonempty ∧ t.Nonempty := image2_nonempty_iff\n\n"}
{"name":"Set.Nonempty.vsub","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\ns t : Set β\na✝¹ : s.Nonempty\na✝ : t.Nonempty\n⊢ (VSub.vsub s t).Nonempty","decl":"lemma Nonempty.vsub : s.Nonempty → t.Nonempty → (s -ᵥ t : Set α).Nonempty := .image2\n"}
{"name":"Set.Nonempty.of_vsub_left","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\ns t : Set β\na✝ : (VSub.vsub s t).Nonempty\n⊢ s.Nonempty","decl":"lemma Nonempty.of_vsub_left : (s -ᵥ t : Set α).Nonempty → s.Nonempty := .of_image2_left\n"}
{"name":"Set.Nonempty.of_vsub_right","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\ns t : Set β\na✝ : (VSub.vsub s t).Nonempty\n⊢ t.Nonempty","decl":"lemma Nonempty.of_vsub_right : (s -ᵥ t : Set α).Nonempty → t.Nonempty := .of_image2_right\n\n"}
{"name":"Set.vsub_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\ns : Set β\nb : β\n⊢ Eq (VSub.vsub s (Singleton.singleton b)) (Set.image (fun x => VSub.vsub x b) s)","decl":"@[simp low+1]\nlemma vsub_singleton (s : Set β) (b : β) : s -ᵥ {b} = (· -ᵥ b) '' s := image2_singleton_right\n\n"}
{"name":"Set.singleton_vsub","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\nt : Set β\nb : β\n⊢ Eq (VSub.vsub (Singleton.singleton b) t) (Set.image (fun x => VSub.vsub b x) t)","decl":"@[simp low+1]\nlemma singleton_vsub (t : Set β) (b : β) : {b} -ᵥ t = (b -ᵥ ·) '' t := image2_singleton_left\n\n"}
{"name":"Set.singleton_vsub_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\nb c : β\n⊢ Eq (VSub.vsub (Singleton.singleton b) (Singleton.singleton c)) (Singleton.singleton (VSub.vsub b c))","decl":"@[simp high] lemma singleton_vsub_singleton : ({b} : Set β) -ᵥ {c} = {b -ᵥ c} := image2_singleton\n\n"}
{"name":"Set.vsub_subset_vsub","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\ns₁ s₂ t₁ t₂ : Set β\na✝¹ : HasSubset.Subset s₁ s₂\na✝ : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (VSub.vsub s₁ t₁) (VSub.vsub s₂ t₂)","decl":"@[mono, gcongr] lemma vsub_subset_vsub : s₁ ⊆ s₂ → t₁ ⊆ t₂ → s₁ -ᵥ t₁ ⊆ s₂ -ᵥ t₂ := image2_subset\n\n"}
{"name":"Set.vsub_subset_vsub_left","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\ns t₁ t₂ : Set β\na✝ : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (VSub.vsub s t₁) (VSub.vsub s t₂)","decl":"@[gcongr] lemma vsub_subset_vsub_left : t₁ ⊆ t₂ → s -ᵥ t₁ ⊆ s -ᵥ t₂ := image2_subset_left\n"}
{"name":"Set.vsub_subset_vsub_right","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\ns₁ s₂ t : Set β\na✝ : HasSubset.Subset s₁ s₂\n⊢ HasSubset.Subset (VSub.vsub s₁ t) (VSub.vsub s₂ t)","decl":"@[gcongr] lemma vsub_subset_vsub_right : s₁ ⊆ s₂ → s₁ -ᵥ t ⊆ s₂ -ᵥ t := image2_subset_right\n\n"}
{"name":"Set.vsub_subset_iff","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\ns t : Set β\nu : Set α\n⊢ Iff (HasSubset.Subset (VSub.vsub s t) u) (∀ (x : β), Membership.mem s x → ∀ (y : β), Membership.mem t y → Membership.mem u (VSub.vsub x y))","decl":"lemma vsub_subset_iff : s -ᵥ t ⊆ u ↔ ∀ x ∈ s, ∀ y ∈ t, x -ᵥ y ∈ u := image2_subset_iff\n\n"}
{"name":"Set.vsub_self_mono","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\ns t : Set β\nh : HasSubset.Subset s t\n⊢ HasSubset.Subset (VSub.vsub s s) (VSub.vsub t t)","decl":"lemma vsub_self_mono (h : s ⊆ t) : s -ᵥ s ⊆ t -ᵥ t := vsub_subset_vsub h h\n\n"}
{"name":"Set.union_vsub","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\ns₁ s₂ t : Set β\n⊢ Eq (VSub.vsub (Union.union s₁ s₂) t) (Union.union (VSub.vsub s₁ t) (VSub.vsub s₂ t))","decl":"lemma union_vsub : s₁ ∪ s₂ -ᵥ t = s₁ -ᵥ t ∪ (s₂ -ᵥ t) := image2_union_left\n"}
{"name":"Set.vsub_union","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\ns t₁ t₂ : Set β\n⊢ Eq (VSub.vsub s (Union.union t₁ t₂)) (Union.union (VSub.vsub s t₁) (VSub.vsub s t₂))","decl":"lemma vsub_union : s -ᵥ (t₁ ∪ t₂) = s -ᵥ t₁ ∪ (s -ᵥ t₂) := image2_union_right\n\n"}
{"name":"Set.inter_vsub_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\ns₁ s₂ t : Set β\n⊢ HasSubset.Subset (VSub.vsub (Inter.inter s₁ s₂) t) (Inter.inter (VSub.vsub s₁ t) (VSub.vsub s₂ t))","decl":"lemma inter_vsub_subset : s₁ ∩ s₂ -ᵥ t ⊆ (s₁ -ᵥ t) ∩ (s₂ -ᵥ t) := image2_inter_subset_left\n"}
{"name":"Set.vsub_inter_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\ns t₁ t₂ : Set β\n⊢ HasSubset.Subset (VSub.vsub s (Inter.inter t₁ t₂)) (Inter.inter (VSub.vsub s t₁) (VSub.vsub s t₂))","decl":"lemma vsub_inter_subset : s -ᵥ t₁ ∩ t₂ ⊆ (s -ᵥ t₁) ∩ (s -ᵥ t₂) := image2_inter_subset_right\n\n"}
{"name":"Set.inter_vsub_union_subset_union","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\ns₁ s₂ t₁ t₂ : Set β\n⊢ HasSubset.Subset (VSub.vsub (Inter.inter s₁ s₂) (Union.union t₁ t₂)) (Union.union (VSub.vsub s₁ t₁) (VSub.vsub s₂ t₂))","decl":"lemma inter_vsub_union_subset_union : s₁ ∩ s₂ -ᵥ (t₁ ∪ t₂) ⊆ s₁ -ᵥ t₁ ∪ (s₂ -ᵥ t₂) :=\n  image2_inter_union_subset_union\n\n"}
{"name":"Set.union_vsub_inter_subset_union","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\ns₁ s₂ t₁ t₂ : Set β\n⊢ HasSubset.Subset (VSub.vsub (Union.union s₁ s₂) (Inter.inter t₁ t₂)) (Union.union (VSub.vsub s₁ t₁) (VSub.vsub s₂ t₂))","decl":"lemma union_vsub_inter_subset_union : s₁ ∪ s₂ -ᵥ t₁ ∩ t₂ ⊆ s₁ -ᵥ t₁ ∪ (s₂ -ᵥ t₂) :=\n  image2_union_inter_subset_union\n\n"}
{"name":"Set.iUnion_vsub_left_image","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\ns t : Set β\n⊢ Eq (Set.iUnion fun a => Set.iUnion fun h => Set.image (fun x => VSub.vsub a x) t) (VSub.vsub s t)","decl":"lemma iUnion_vsub_left_image : ⋃ a ∈ s, (a -ᵥ ·) '' t = s -ᵥ t := iUnion_image_left _\n"}
{"name":"Set.iUnion_vsub_right_image","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\ns t : Set β\n⊢ Eq (Set.iUnion fun a => Set.iUnion fun h => Set.image (fun x => VSub.vsub x a) s) (VSub.vsub s t)","decl":"lemma iUnion_vsub_right_image : ⋃ a ∈ t, (· -ᵥ a) '' s = s -ᵥ t := iUnion_image_right _\n\n"}
{"name":"Set.iUnion_vsub","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Sort u_5\ninst✝ : VSub α β\ns : ι → Set β\nt : Set β\n⊢ Eq (VSub.vsub (Set.iUnion fun i => s i) t) (Set.iUnion fun i => VSub.vsub (s i) t)","decl":"lemma iUnion_vsub (s : ι → Set β) (t : Set β) : (⋃ i, s i) -ᵥ t = ⋃ i, s i -ᵥ t :=\n  image2_iUnion_left ..\n\n"}
{"name":"Set.vsub_iUnion","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Sort u_5\ninst✝ : VSub α β\ns : Set β\nt : ι → Set β\n⊢ Eq (VSub.vsub s (Set.iUnion fun i => t i)) (Set.iUnion fun i => VSub.vsub s (t i))","decl":"lemma vsub_iUnion (s : Set β) (t : ι → Set β) : (s -ᵥ ⋃ i, t i) = ⋃ i, s -ᵥ t i :=\n  image2_iUnion_right ..\n\n"}
{"name":"Set.sUnion_vsub","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\nS : Set (Set β)\nt : Set β\n⊢ Eq (VSub.vsub S.sUnion t) (Set.iUnion fun s => Set.iUnion fun h => VSub.vsub s t)","decl":"lemma sUnion_vsub (S : Set (Set β)) (t : Set β) : ⋃₀ S -ᵥ t = ⋃ s ∈ S, s -ᵥ t :=\n  image2_sUnion_left ..\n\n"}
{"name":"Set.vsub_sUnion","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\ns : Set β\nT : Set (Set β)\n⊢ Eq (VSub.vsub s T.sUnion) (Set.iUnion fun t => Set.iUnion fun h => VSub.vsub s t)","decl":"lemma vsub_sUnion (s : Set β) (T : Set (Set β)) : s -ᵥ ⋃₀ T = ⋃ t ∈ T, s -ᵥ t :=\n  image2_sUnion_right ..\n\n"}
{"name":"Set.iUnion₂_vsub","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Sort u_5\nκ : ι → Sort u_6\ninst✝ : VSub α β\ns : (i : ι) → κ i → Set β\nt : Set β\n⊢ Eq (VSub.vsub (Set.iUnion fun i => Set.iUnion fun j => s i j) t) (Set.iUnion fun i => Set.iUnion fun j => VSub.vsub (s i j) t)","decl":"lemma iUnion₂_vsub (s : ∀ i, κ i → Set β) (t : Set β) :\n    (⋃ i, ⋃ j, s i j) -ᵥ t = ⋃ i, ⋃ j, s i j -ᵥ t := image2_iUnion₂_left ..\n\n"}
{"name":"Set.vsub_iUnion₂","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Sort u_5\nκ : ι → Sort u_6\ninst✝ : VSub α β\ns : Set β\nt : (i : ι) → κ i → Set β\n⊢ Eq (VSub.vsub s (Set.iUnion fun i => Set.iUnion fun j => t i j)) (Set.iUnion fun i => Set.iUnion fun j => VSub.vsub s (t i j))","decl":"lemma vsub_iUnion₂ (s : Set β) (t : ∀ i, κ i → Set β) :\n    (s -ᵥ ⋃ i, ⋃ j, t i j) = ⋃ i, ⋃ j, s -ᵥ t i j := image2_iUnion₂_right ..\n\n"}
{"name":"Set.iInter_vsub_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Sort u_5\ninst✝ : VSub α β\ns : ι → Set β\nt : Set β\n⊢ HasSubset.Subset (VSub.vsub (Set.iInter fun i => s i) t) (Set.iInter fun i => VSub.vsub (s i) t)","decl":"lemma iInter_vsub_subset (s : ι → Set β) (t : Set β) : (⋂ i, s i) -ᵥ t ⊆ ⋂ i, s i -ᵥ t :=\n  image2_iInter_subset_left ..\n\n"}
{"name":"Set.vsub_iInter_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Sort u_5\ninst✝ : VSub α β\ns : Set β\nt : ι → Set β\n⊢ HasSubset.Subset (VSub.vsub s (Set.iInter fun i => t i)) (Set.iInter fun i => VSub.vsub s (t i))","decl":"lemma vsub_iInter_subset (s : Set β) (t : ι → Set β) : (s -ᵥ ⋂ i, t i) ⊆ ⋂ i, s -ᵥ t i :=\n  image2_iInter_subset_right ..\n\n"}
{"name":"Set.sInter_vsub_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\nS : Set (Set β)\nt : Set β\n⊢ HasSubset.Subset (VSub.vsub S.sInter t) (Set.iInter fun s => Set.iInter fun h => VSub.vsub s t)","decl":"lemma sInter_vsub_subset (S : Set (Set β)) (t : Set β) : ⋂₀ S -ᵥ t ⊆ ⋂ s ∈ S, s -ᵥ t :=\n  image2_sInter_subset_left ..\n\n"}
{"name":"Set.vsub_sInter_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\ns : Set β\nT : Set (Set β)\n⊢ HasSubset.Subset (VSub.vsub s T.sInter) (Set.iInter fun t => Set.iInter fun h => VSub.vsub s t)","decl":"lemma vsub_sInter_subset (s : Set β) (T : Set (Set β)) : s -ᵥ ⋂₀ T ⊆ ⋂ t ∈ T, s -ᵥ t :=\n  image2_sInter_subset_right ..\n\n"}
{"name":"Set.iInter₂_vsub_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Sort u_5\nκ : ι → Sort u_6\ninst✝ : VSub α β\ns : (i : ι) → κ i → Set β\nt : Set β\n⊢ HasSubset.Subset (VSub.vsub (Set.iInter fun i => Set.iInter fun j => s i j) t) (Set.iInter fun i => Set.iInter fun j => VSub.vsub (s i j) t)","decl":"lemma iInter₂_vsub_subset (s : ∀ i, κ i → Set β) (t : Set β) :\n    (⋂ i, ⋂ j, s i j) -ᵥ t ⊆ ⋂ i, ⋂ j, s i j -ᵥ t := image2_iInter₂_subset_left ..\n\n"}
{"name":"Set.vsub_iInter₂_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nι : Sort u_5\nκ : ι → Sort u_6\ninst✝ : VSub α β\ns : Set β\nt : (i : ι) → κ i → Set β\n⊢ HasSubset.Subset (VSub.vsub s (Set.iInter fun i => Set.iInter fun j => t i j)) (Set.iInter fun i => Set.iInter fun j => VSub.vsub s (t i j))","decl":"lemma vsub_iInter₂_subset (s : Set β) (t : ∀ i, κ i → Set β) :\n    s -ᵥ ⋂ i, ⋂ j, t i j ⊆ ⋂ i, ⋂ j, s -ᵥ t i j := image2_iInter₂_subset_right ..\n\n"}
{"name":"Set.image_vadd_comm","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝¹ : VAdd α β\ninst✝ : VAdd α γ\nf : β → γ\na : α\ns : Set β\na✝ : ∀ (b : β), Eq (f (HVAdd.hVAdd a b)) (HVAdd.hVAdd a (f b))\n⊢ Eq (Set.image f (HVAdd.hVAdd a s)) (HVAdd.hVAdd a (Set.image f s))","decl":"@[to_additive]\nlemma image_smul_comm [SMul α β] [SMul α γ] (f : β → γ) (a : α) (s : Set β) :\n    (∀ b, f (a • b) = a • f b) → f '' (a • s) = a • f '' s := image_comm\n\n"}
{"name":"Set.image_smul_comm","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝¹ : SMul α β\ninst✝ : SMul α γ\nf : β → γ\na : α\ns : Set β\na✝ : ∀ (b : β), Eq (f (HSMul.hSMul a b)) (HSMul.hSMul a (f b))\n⊢ Eq (Set.image f (HSMul.hSMul a s)) (HSMul.hSMul a (Set.image f s))","decl":"@[to_additive]\nlemma image_smul_comm [SMul α β] [SMul α γ] (f : β → γ) (a : α) (s : Set β) :\n    (∀ b, f (a • b) = a • f b) → f '' (a • s) = a • f '' s := image_comm\n\n"}
{"name":"Set.inter_add_union_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddCommSemigroup α\ns t : Set α\n⊢ HasSubset.Subset (HAdd.hAdd (Inter.inter s t) (Union.union s t)) (HAdd.hAdd s t)","decl":"@[to_additive]\ntheorem inter_mul_union_subset : s ∩ t * (s ∪ t) ⊆ s * t :=\n  image2_inter_union_subset mul_comm\n\n"}
{"name":"Set.inter_mul_union_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : CommSemigroup α\ns t : Set α\n⊢ HasSubset.Subset (HMul.hMul (Inter.inter s t) (Union.union s t)) (HMul.hMul s t)","decl":"@[to_additive]\ntheorem inter_mul_union_subset : s ∩ t * (s ∪ t) ⊆ s * t :=\n  image2_inter_union_subset mul_comm\n\n"}
{"name":"Set.union_mul_inter_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : CommSemigroup α\ns t : Set α\n⊢ HasSubset.Subset (HMul.hMul (Union.union s t) (Inter.inter s t)) (HMul.hMul s t)","decl":"@[to_additive]\ntheorem union_mul_inter_subset : (s ∪ t) * (s ∩ t) ⊆ s * t :=\n  image2_union_inter_subset mul_comm\n\n"}
{"name":"Set.union_add_inter_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddCommSemigroup α\ns t : Set α\n⊢ HasSubset.Subset (HAdd.hAdd (Union.union s t) (Inter.inter s t)) (HAdd.hAdd s t)","decl":"@[to_additive]\ntheorem union_mul_inter_subset : (s ∪ t) * (s ∩ t) ⊆ s * t :=\n  image2_union_inter_subset mul_comm\n\n"}
{"name":"Set.subset_mul_left","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : MulOneClass α\ns t : Set α\nht : Membership.mem t 1\n⊢ HasSubset.Subset s (HMul.hMul s t)","decl":"@[to_additive]\ntheorem subset_mul_left (s : Set α) {t : Set α} (ht : (1 : α) ∈ t) : s ⊆ s * t := fun x hx =>\n  ⟨x, hx, 1, ht, mul_one _⟩\n\n"}
{"name":"Set.subset_add_left","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddZeroClass α\ns t : Set α\nht : Membership.mem t 0\n⊢ HasSubset.Subset s (HAdd.hAdd s t)","decl":"@[to_additive]\ntheorem subset_mul_left (s : Set α) {t : Set α} (ht : (1 : α) ∈ t) : s ⊆ s * t := fun x hx =>\n  ⟨x, hx, 1, ht, mul_one _⟩\n\n"}
{"name":"Set.subset_add_right","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddZeroClass α\ns t : Set α\nhs : Membership.mem s 0\n⊢ HasSubset.Subset t (HAdd.hAdd s t)","decl":"@[to_additive]\ntheorem subset_mul_right {s : Set α} (t : Set α) (hs : (1 : α) ∈ s) : t ⊆ s * t := fun x hx =>\n  ⟨1, hs, x, hx, one_mul _⟩\n\n"}
{"name":"Set.subset_mul_right","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : MulOneClass α\ns t : Set α\nhs : Membership.mem s 1\n⊢ HasSubset.Subset t (HMul.hMul s t)","decl":"@[to_additive]\ntheorem subset_mul_right {s : Set α} (t : Set α) (hs : (1 : α) ∈ s) : t ⊆ s * t := fun x hx =>\n  ⟨1, hs, x, hx, one_mul _⟩\n\n"}
{"name":"Set.coe_singletonAddMonoidHom","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddZeroClass α\n⊢ Eq (⇑Set.singletonAddMonoidHom) Singleton.singleton","decl":"@[to_additive (attr := simp)]\ntheorem coe_singletonMonoidHom : (singletonMonoidHom : α → Set α) = singleton :=\n  rfl\n\n"}
{"name":"Set.coe_singletonMonoidHom","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : MulOneClass α\n⊢ Eq (⇑Set.singletonMonoidHom) Singleton.singleton","decl":"@[to_additive (attr := simp)]\ntheorem coe_singletonMonoidHom : (singletonMonoidHom : α → Set α) = singleton :=\n  rfl\n\n"}
{"name":"Set.singletonMonoidHom_apply","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : MulOneClass α\na : α\n⊢ Eq (Set.singletonMonoidHom a) (Singleton.singleton a)","decl":"@[to_additive (attr := simp)]\ntheorem singletonMonoidHom_apply (a : α) : singletonMonoidHom a = {a} :=\n  rfl\n\n"}
{"name":"Set.singletonAddMonoidHom_apply","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddZeroClass α\na : α\n⊢ Eq (Set.singletonAddMonoidHom a) (Singleton.singleton a)","decl":"@[to_additive (attr := simp)]\ntheorem singletonMonoidHom_apply (a : α) : singletonMonoidHom a = {a} :=\n  rfl\n\n"}
{"name":"Set.pow_right_monotone","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Monoid α\ns : Set α\nhs : Membership.mem s 1\n⊢ Monotone fun x => HPow.hPow s x","decl":"@[to_additive]\nprotected lemma pow_right_monotone (hs : 1 ∈ s) : Monotone (s ^ ·) :=\n  pow_right_monotone <| one_subset.2 hs\n\n"}
{"name":"Set.nsmul_right_monotone","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddMonoid α\ns : Set α\nhs : Membership.mem s 0\n⊢ Monotone fun x => HSMul.hSMul x s","decl":"@[to_additive]\nprotected lemma pow_right_monotone (hs : 1 ∈ s) : Monotone (s ^ ·) :=\n  pow_right_monotone <| one_subset.2 hs\n\n"}
{"name":"Set.nsmul_subset_nsmul_left","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddMonoid α\ns t : Set α\nn : Nat\nhst : HasSubset.Subset s t\n⊢ HasSubset.Subset (HSMul.hSMul n s) (HSMul.hSMul n t)","decl":"@[to_additive (attr := gcongr)]\nlemma pow_subset_pow_left (hst : s ⊆ t) : s ^ n ⊆ t ^ n := pow_left_mono _ hst\n\n"}
{"name":"Set.pow_subset_pow_left","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Monoid α\ns t : Set α\nn : Nat\nhst : HasSubset.Subset s t\n⊢ HasSubset.Subset (HPow.hPow s n) (HPow.hPow t n)","decl":"@[to_additive (attr := gcongr)]\nlemma pow_subset_pow_left (hst : s ⊆ t) : s ^ n ⊆ t ^ n := pow_left_mono _ hst\n\n"}
{"name":"Set.pow_subset_pow_right","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Monoid α\ns : Set α\nm n : Nat\nhs : Membership.mem s 1\nhmn : LE.le m n\n⊢ HasSubset.Subset (HPow.hPow s m) (HPow.hPow s n)","decl":"@[to_additive (attr := gcongr)]\nlemma pow_subset_pow_right (hs : 1 ∈ s) (hmn : m ≤ n) : s ^ m ⊆ s ^ n :=\n  Set.pow_right_monotone hs hmn\n\n"}
{"name":"Set.nsmul_subset_nsmul_right","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddMonoid α\ns : Set α\nm n : Nat\nhs : Membership.mem s 0\nhmn : LE.le m n\n⊢ HasSubset.Subset (HSMul.hSMul m s) (HSMul.hSMul n s)","decl":"@[to_additive (attr := gcongr)]\nlemma pow_subset_pow_right (hs : 1 ∈ s) (hmn : m ≤ n) : s ^ m ⊆ s ^ n :=\n  Set.pow_right_monotone hs hmn\n\n"}
{"name":"Set.pow_subset_pow","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Monoid α\ns t : Set α\nm n : Nat\nhst : HasSubset.Subset s t\nht : Membership.mem t 1\nhmn : LE.le m n\n⊢ HasSubset.Subset (HPow.hPow s m) (HPow.hPow t n)","decl":"@[to_additive (attr := gcongr)]\nlemma pow_subset_pow (hst : s ⊆ t) (ht : 1 ∈ t) (hmn : m ≤ n) : s ^ m ⊆ t ^ n :=\n  (pow_subset_pow_left hst).trans (pow_subset_pow_right ht hmn)\n\n"}
{"name":"Set.nsmul_subset_nsmul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddMonoid α\ns t : Set α\nm n : Nat\nhst : HasSubset.Subset s t\nht : Membership.mem t 0\nhmn : LE.le m n\n⊢ HasSubset.Subset (HSMul.hSMul m s) (HSMul.hSMul n t)","decl":"@[to_additive (attr := gcongr)]\nlemma pow_subset_pow (hst : s ⊆ t) (ht : 1 ∈ t) (hmn : m ≤ n) : s ^ m ⊆ t ^ n :=\n  (pow_subset_pow_left hst).trans (pow_subset_pow_right ht hmn)\n\n"}
{"name":"Set.subset_nsmul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddMonoid α\ns : Set α\nn : Nat\nhs : Membership.mem s 0\nhn : Ne n 0\n⊢ HasSubset.Subset s (HSMul.hSMul n s)","decl":"@[to_additive]\nlemma subset_pow (hs : 1 ∈ s) (hn : n ≠ 0) : s ⊆ s ^ n := by\n  simpa using pow_subset_pow_right hs <| Nat.one_le_iff_ne_zero.2 hn\n\n"}
{"name":"Set.subset_pow","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Monoid α\ns : Set α\nn : Nat\nhs : Membership.mem s 1\nhn : Ne n 0\n⊢ HasSubset.Subset s (HPow.hPow s n)","decl":"@[to_additive]\nlemma subset_pow (hs : 1 ∈ s) (hn : n ≠ 0) : s ⊆ s ^ n := by\n  simpa using pow_subset_pow_right hs <| Nat.one_le_iff_ne_zero.2 hn\n\n"}
{"name":"Set.pow_subset_pow_of_one_mem","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Monoid α\ns : Set α\nm n : Nat\nhs : Membership.mem s 1\nhmn : LE.le m n\n⊢ HasSubset.Subset (HPow.hPow s m) (HPow.hPow s n)","decl":"@[deprecated (since := \"2024-11-19\")] alias pow_subset_pow_of_one_mem := pow_subset_pow_right\n\n"}
{"name":"Set.nsmul_subset_nsmul_of_zero_mem","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddMonoid α\ns : Set α\nm n : Nat\nhs : Membership.mem s 0\nhmn : LE.le m n\n⊢ HasSubset.Subset (HSMul.hSMul m s) (HSMul.hSMul n s)","decl":"@[deprecated (since := \"2024-11-19\")]\nalias nsmul_subset_nsmul_of_zero_mem := nsmul_subset_nsmul_right\n\n"}
{"name":"Set.nsmul_subset_nsmul_add_of_sq_subset_add","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddMonoid α\ns t : Set α\nn : Nat\nhst : HasSubset.Subset (HSMul.hSMul 2 s) (HAdd.hAdd t s)\nhn : Ne n 0\n⊢ HasSubset.Subset (HSMul.hSMul n s) (HAdd.hAdd (HSMul.hSMul (HSub.hSub n 1) t) s)","decl":"@[to_additive]\nlemma pow_subset_pow_mul_of_sq_subset_mul (hst : s ^ 2 ⊆ t * s) (hn : n ≠ 0) :\n    s ^ n ⊆ t ^ (n - 1) * s := pow_le_pow_mul_of_sq_le_mul hst hn\n\n"}
{"name":"Set.pow_subset_pow_mul_of_sq_subset_mul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Monoid α\ns t : Set α\nn : Nat\nhst : HasSubset.Subset (HPow.hPow s 2) (HMul.hMul t s)\nhn : Ne n 0\n⊢ HasSubset.Subset (HPow.hPow s n) (HMul.hMul (HPow.hPow t (HSub.hSub n 1)) s)","decl":"@[to_additive]\nlemma pow_subset_pow_mul_of_sq_subset_mul (hst : s ^ 2 ⊆ t * s) (hn : n ≠ 0) :\n    s ^ n ⊆ t ^ (n - 1) * s := pow_le_pow_mul_of_sq_le_mul hst hn\n\n"}
{"name":"Set.nsmul_empty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddMonoid α\nn : Nat\nhn : Ne n 0\n⊢ Eq (HSMul.hSMul n EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp) nsmul_empty]\nlemma empty_pow (hn : n ≠ 0) : (∅ : Set α) ^ n = ∅ := match n with | n + 1 => by simp [pow_succ]\n\n"}
{"name":"Set.empty_pow","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Monoid α\nn : Nat\nhn : Ne n 0\n⊢ Eq (HPow.hPow EmptyCollection.emptyCollection n) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp) nsmul_empty]\nlemma empty_pow (hn : n ≠ 0) : (∅ : Set α) ^ n = ∅ := match n with | n + 1 => by simp [pow_succ]\n\n"}
{"name":"Set.empty_nsmul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddMonoid α\nn : Nat\nhn : Ne n 0\n⊢ Eq (HSMul.hSMul n EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[deprecated (since := \"2024-10-21\")] alias empty_nsmul := nsmul_empty\n\n"}
{"name":"Set.Nonempty.pow","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Monoid α\ns : Set α\nhs : s.Nonempty\nn : Nat\n⊢ (HPow.hPow s n).Nonempty","decl":"@[to_additive]\nlemma Nonempty.pow (hs : s.Nonempty) : ∀ {n}, (s ^ n).Nonempty\n  | 0 => by simp\n  | n + 1 => by rw [pow_succ]; exact hs.pow.mul hs\n\n"}
{"name":"Set.Nonempty.nsmul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddMonoid α\ns : Set α\nhs : s.Nonempty\nn : Nat\n⊢ (HSMul.hSMul n s).Nonempty","decl":"@[to_additive]\nlemma Nonempty.pow (hs : s.Nonempty) : ∀ {n}, (s ^ n).Nonempty\n  | 0 => by simp\n  | n + 1 => by rw [pow_succ]; exact hs.pow.mul hs\n\n"}
{"name":"Set.nsmul_eq_empty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddMonoid α\ns : Set α\nn : Nat\n⊢ Iff (Eq (HSMul.hSMul n s) EmptyCollection.emptyCollection) (And (Eq s EmptyCollection.emptyCollection) (Ne n 0))","decl":"set_option push_neg.use_distrib true in\n@[to_additive (attr := simp)] lemma pow_eq_empty : s ^ n = ∅ ↔ s = ∅ ∧ n ≠ 0 := by\n  constructor\n  · contrapose!\n    rintro (hs | rfl)\n    · exact hs.pow\n    · simp\n  · rintro ⟨rfl, hn⟩\n    exact empty_pow hn\n\n"}
{"name":"Set.pow_eq_empty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Monoid α\ns : Set α\nn : Nat\n⊢ Iff (Eq (HPow.hPow s n) EmptyCollection.emptyCollection) (And (Eq s EmptyCollection.emptyCollection) (Ne n 0))","decl":"set_option push_neg.use_distrib true in\n@[to_additive (attr := simp)] lemma pow_eq_empty : s ^ n = ∅ ↔ s = ∅ ∧ n ≠ 0 := by\n  constructor\n  · contrapose!\n    rintro (hs | rfl)\n    · exact hs.pow\n    · simp\n  · rintro ⟨rfl, hn⟩\n    exact empty_pow hn\n\n"}
{"name":"Set.nsmul_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddMonoid α\na : α\nn : Nat\n⊢ Eq (HSMul.hSMul n (Singleton.singleton a)) (Singleton.singleton (HSMul.hSMul n a))","decl":"@[to_additive (attr := simp) nsmul_singleton]\nlemma singleton_pow (a : α) : ∀ n, ({a} : Set α) ^ n = {a ^ n}\n  | 0 => by simp [singleton_one]\n  | n + 1 => by simp [pow_succ, singleton_pow _ n]\n\n"}
{"name":"Set.singleton_pow","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Monoid α\na : α\nn : Nat\n⊢ Eq (HPow.hPow (Singleton.singleton a) n) (Singleton.singleton (HPow.hPow a n))","decl":"@[to_additive (attr := simp) nsmul_singleton]\nlemma singleton_pow (a : α) : ∀ n, ({a} : Set α) ^ n = {a ^ n}\n  | 0 => by simp [singleton_one]\n  | n + 1 => by simp [pow_succ, singleton_pow _ n]\n\n"}
{"name":"Set.nsmul_mem_nsmul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddMonoid α\ns : Set α\na : α\nn : Nat\nha : Membership.mem s a\n⊢ Membership.mem (HSMul.hSMul n s) (HSMul.hSMul n a)","decl":"@[to_additive] lemma pow_mem_pow (ha : a ∈ s) : a ^ n ∈ s ^ n := by\n  simpa using pow_subset_pow_left (singleton_subset_iff.2 ha)\n\n"}
{"name":"Set.pow_mem_pow","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Monoid α\ns : Set α\na : α\nn : Nat\nha : Membership.mem s a\n⊢ Membership.mem (HPow.hPow s n) (HPow.hPow a n)","decl":"@[to_additive] lemma pow_mem_pow (ha : a ∈ s) : a ^ n ∈ s ^ n := by\n  simpa using pow_subset_pow_left (singleton_subset_iff.2 ha)\n\n"}
{"name":"Set.zero_mem_nsmul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddMonoid α\ns : Set α\nn : Nat\nhs : Membership.mem s 0\n⊢ Membership.mem (HSMul.hSMul n s) 0","decl":"@[to_additive] lemma one_mem_pow (hs : 1 ∈ s) : 1 ∈ s ^ n := by simpa using pow_mem_pow hs\n\n"}
{"name":"Set.one_mem_pow","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Monoid α\ns : Set α\nn : Nat\nhs : Membership.mem s 1\n⊢ Membership.mem (HPow.hPow s n) 1","decl":"@[to_additive] lemma one_mem_pow (hs : 1 ∈ s) : 1 ∈ s ^ n := by simpa using pow_mem_pow hs\n\n"}
{"name":"Set.inter_pow_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Monoid α\ns t : Set α\nn : Nat\n⊢ HasSubset.Subset (HPow.hPow (Inter.inter s t) n) (Inter.inter (HPow.hPow s n) (HPow.hPow t n))","decl":"@[to_additive]\nlemma inter_pow_subset : (s ∩ t) ^ n ⊆ s ^ n ∩ t ^ n := by apply subset_inter <;> gcongr <;> simp\n\n"}
{"name":"Set.inter_nsmul_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddMonoid α\ns t : Set α\nn : Nat\n⊢ HasSubset.Subset (HSMul.hSMul n (Inter.inter s t)) (Inter.inter (HSMul.hSMul n s) (HSMul.hSMul n t))","decl":"@[to_additive]\nlemma inter_pow_subset : (s ∩ t) ^ n ⊆ s ^ n ∩ t ^ n := by apply subset_inter <;> gcongr <;> simp\n\n"}
{"name":"Set.mul_univ_of_one_mem","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Monoid α\ns : Set α\nhs : Membership.mem s 1\n⊢ Eq (HMul.hMul s Set.univ) Set.univ","decl":"@[to_additive]\ntheorem mul_univ_of_one_mem (hs : (1 : α) ∈ s) : s * univ = univ :=\n  eq_univ_iff_forall.2 fun _ => mem_mul.2 ⟨_, hs, _, mem_univ _, one_mul _⟩\n\n"}
{"name":"Set.add_univ_of_zero_mem","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddMonoid α\ns : Set α\nhs : Membership.mem s 0\n⊢ Eq (HAdd.hAdd s Set.univ) Set.univ","decl":"@[to_additive]\ntheorem mul_univ_of_one_mem (hs : (1 : α) ∈ s) : s * univ = univ :=\n  eq_univ_iff_forall.2 fun _ => mem_mul.2 ⟨_, hs, _, mem_univ _, one_mul _⟩\n\n"}
{"name":"Set.univ_mul_of_one_mem","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Monoid α\nt : Set α\nht : Membership.mem t 1\n⊢ Eq (HMul.hMul Set.univ t) Set.univ","decl":"@[to_additive]\ntheorem univ_mul_of_one_mem (ht : (1 : α) ∈ t) : univ * t = univ :=\n  eq_univ_iff_forall.2 fun _ => mem_mul.2 ⟨_, mem_univ _, _, ht, mul_one _⟩\n\n"}
{"name":"Set.univ_add_of_zero_mem","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddMonoid α\nt : Set α\nht : Membership.mem t 0\n⊢ Eq (HAdd.hAdd Set.univ t) Set.univ","decl":"@[to_additive]\ntheorem univ_mul_of_one_mem (ht : (1 : α) ∈ t) : univ * t = univ :=\n  eq_univ_iff_forall.2 fun _ => mem_mul.2 ⟨_, mem_univ _, _, ht, mul_one _⟩\n\n"}
{"name":"Set.univ_mul_univ","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Monoid α\n⊢ Eq (HMul.hMul Set.univ Set.univ) Set.univ","decl":"@[to_additive (attr := simp)]\ntheorem univ_mul_univ : (univ : Set α) * univ = univ :=\n  mul_univ_of_one_mem <| mem_univ _\n\n"}
{"name":"Set.univ_add_univ","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddMonoid α\n⊢ Eq (HAdd.hAdd Set.univ Set.univ) Set.univ","decl":"@[to_additive (attr := simp)]\ntheorem univ_mul_univ : (univ : Set α) * univ = univ :=\n  mul_univ_of_one_mem <| mem_univ _\n\n"}
{"name":"Set.univ_pow","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Monoid α\nn : Nat\na✝ : Ne n 0\n⊢ Eq (HPow.hPow Set.univ n) Set.univ","decl":"@[to_additive (attr := simp) nsmul_univ]\ntheorem univ_pow : ∀ {n : ℕ}, n ≠ 0 → (univ : Set α) ^ n = univ\n  | 0 => fun h => (h rfl).elim\n  | 1 => fun _ => pow_one _\n  | n + 2 => fun _ => by rw [pow_succ, univ_pow n.succ_ne_zero, univ_mul_univ]\n\n"}
{"name":"Set.nsmul_univ","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddMonoid α\nn : Nat\na✝ : Ne n 0\n⊢ Eq (HSMul.hSMul n Set.univ) Set.univ","decl":"@[to_additive (attr := simp) nsmul_univ]\ntheorem univ_pow : ∀ {n : ℕ}, n ≠ 0 → (univ : Set α) ^ n = univ\n  | 0 => fun h => (h rfl).elim\n  | 1 => fun _ => pow_one _\n  | n + 2 => fun _ => by rw [pow_succ, univ_pow n.succ_ne_zero, univ_mul_univ]\n\n"}
{"name":"IsAddUnit.set","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddMonoid α\na : α\na✝ : IsAddUnit a\n⊢ IsAddUnit (Singleton.singleton a)","decl":"@[to_additive]\nprotected theorem _root_.IsUnit.set : IsUnit a → IsUnit ({a} : Set α) :=\n  IsUnit.map (singletonMonoidHom : α →* Set α)\n\n"}
{"name":"IsUnit.set","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Monoid α\na : α\na✝ : IsUnit a\n⊢ IsUnit (Singleton.singleton a)","decl":"@[to_additive]\nprotected theorem _root_.IsUnit.set : IsUnit a → IsUnit ({a} : Set α) :=\n  IsUnit.map (singletonMonoidHom : α →* Set α)\n\n"}
{"name":"Set.sum_nsmul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddMonoid α\ninst✝ : AddMonoid β\ns : Set α\nt : Set β\nn : Nat\n⊢ Eq (HSMul.hSMul n (SProd.sprod s t)) (SProd.sprod (HSMul.hSMul n s) (HSMul.hSMul n t))","decl":"@[to_additive]\nlemma prod_pow [Monoid β] (s : Set α) (t : Set β) : ∀ n, (s ×ˢ t) ^ n = (s ^ n) ×ˢ (t ^ n)\n  | 0 => by simp\n  | n + 1 => by simp [pow_succ, prod_pow _ _ n]\n\n"}
{"name":"Set.prod_pow","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Monoid α\ninst✝ : Monoid β\ns : Set α\nt : Set β\nn : Nat\n⊢ Eq (HPow.hPow (SProd.sprod s t) n) (SProd.sprod (HPow.hPow s n) (HPow.hPow t n))","decl":"@[to_additive]\nlemma prod_pow [Monoid β] (s : Set α) (t : Set β) : ∀ n, (s ×ˢ t) ^ n = (s ^ n) ×ˢ (t ^ n)\n  | 0 => by simp\n  | n + 1 => by simp [pow_succ, prod_pow _ _ n]\n\n"}
{"name":"Set.Nontrivial.add_left","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Add α\ninst✝ : IsLeftCancelAdd α\ns t : Set α\na✝¹ : t.Nontrivial\na✝ : s.Nonempty\n⊢ (HAdd.hAdd s t).Nontrivial","decl":"@[to_additive]\nlemma Nontrivial.mul_left : t.Nontrivial → s.Nonempty → (s * t).Nontrivial := by\n  rintro ⟨a, ha, b, hb, hab⟩ ⟨c, hc⟩\n  exact ⟨c * a, mul_mem_mul hc ha, c * b, mul_mem_mul hc hb, by simpa⟩\n\n"}
{"name":"Set.Nontrivial.mul_left","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Mul α\ninst✝ : IsLeftCancelMul α\ns t : Set α\na✝¹ : t.Nontrivial\na✝ : s.Nonempty\n⊢ (HMul.hMul s t).Nontrivial","decl":"@[to_additive]\nlemma Nontrivial.mul_left : t.Nontrivial → s.Nonempty → (s * t).Nontrivial := by\n  rintro ⟨a, ha, b, hb, hab⟩ ⟨c, hc⟩\n  exact ⟨c * a, mul_mem_mul hc ha, c * b, mul_mem_mul hc hb, by simpa⟩\n\n"}
{"name":"Set.Nontrivial.mul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Mul α\ninst✝ : IsLeftCancelMul α\ns t : Set α\nhs : s.Nontrivial\nht : t.Nontrivial\n⊢ (HMul.hMul s t).Nontrivial","decl":"@[to_additive]\nlemma Nontrivial.mul (hs : s.Nontrivial) (ht : t.Nontrivial) : (s * t).Nontrivial :=\n  ht.mul_left hs.nonempty\n\n"}
{"name":"Set.Nontrivial.add","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Add α\ninst✝ : IsLeftCancelAdd α\ns t : Set α\nhs : s.Nontrivial\nht : t.Nontrivial\n⊢ (HAdd.hAdd s t).Nontrivial","decl":"@[to_additive]\nlemma Nontrivial.mul (hs : s.Nontrivial) (ht : t.Nontrivial) : (s * t).Nontrivial :=\n  ht.mul_left hs.nonempty\n\n"}
{"name":"Set.Nontrivial.add_right","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Add α\ninst✝ : IsRightCancelAdd α\ns t : Set α\na✝¹ : s.Nontrivial\na✝ : t.Nonempty\n⊢ (HAdd.hAdd s t).Nontrivial","decl":"@[to_additive]\nlemma Nontrivial.mul_right : s.Nontrivial → t.Nonempty → (s * t).Nontrivial := by\n  rintro ⟨a, ha, b, hb, hab⟩ ⟨c, hc⟩\n  exact ⟨a * c, mul_mem_mul ha hc, b * c, mul_mem_mul hb hc, by simpa⟩\n\n"}
{"name":"Set.Nontrivial.mul_right","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Mul α\ninst✝ : IsRightCancelMul α\ns t : Set α\na✝¹ : s.Nontrivial\na✝ : t.Nonempty\n⊢ (HMul.hMul s t).Nontrivial","decl":"@[to_additive]\nlemma Nontrivial.mul_right : s.Nontrivial → t.Nonempty → (s * t).Nontrivial := by\n  rintro ⟨a, ha, b, hb, hab⟩ ⟨c, hc⟩\n  exact ⟨a * c, mul_mem_mul ha hc, b * c, mul_mem_mul hb hc, by simpa⟩\n\n"}
{"name":"Set.Nontrivial.pow","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : CancelMonoid α\ns : Set α\nhs : s.Nontrivial\nn : Nat\na✝ : Ne n 0\n⊢ (HPow.hPow s n).Nontrivial","decl":"@[to_additive]\nlemma Nontrivial.pow (hs : s.Nontrivial) : ∀ {n}, n ≠ 0 → (s ^ n).Nontrivial\n  | 1, _ => by simpa\n  | n + 2, _ => by simpa [pow_succ] using (hs.pow n.succ_ne_zero).mul hs\n\n"}
{"name":"Set.Nontrivial.nsmul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddCancelMonoid α\ns : Set α\nhs : s.Nontrivial\nn : Nat\na✝ : Ne n 0\n⊢ (HSMul.hSMul n s).Nontrivial","decl":"@[to_additive]\nlemma Nontrivial.pow (hs : s.Nontrivial) : ∀ {n}, n ≠ 0 → (s ^ n).Nontrivial\n  | 1, _ => by simpa\n  | n + 2, _ => by simpa [pow_succ] using (hs.pow n.succ_ne_zero).mul hs\n\n"}
{"name":"Set.mul_eq_one_iff","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : DivisionMonoid α\ns t : Set α\n⊢ Iff (Eq (HMul.hMul s t) 1) (Exists fun a => Exists fun b => And (Eq s (Singleton.singleton a)) (And (Eq t (Singleton.singleton b)) (Eq (HMul.hMul a b) 1)))","decl":"@[to_additive]\nprotected theorem mul_eq_one_iff : s * t = 1 ↔ ∃ a b, s = {a} ∧ t = {b} ∧ a * b = 1 := by\n  refine ⟨fun h => ?_, ?_⟩\n  · have hst : (s * t).Nonempty := h.symm.subst one_nonempty\n    obtain ⟨a, ha⟩ := hst.of_image2_left\n    obtain ⟨b, hb⟩ := hst.of_image2_right\n    have H : ∀ {a b}, a ∈ s → b ∈ t → a * b = (1 : α) := fun {a b} ha hb =>\n      h.subset <| mem_image2_of_mem ha hb\n    refine ⟨a, b, ?_, ?_, H ha hb⟩ <;> refine eq_singleton_iff_unique_mem.2 ⟨‹_›, fun x hx => ?_⟩\n    · exact (eq_inv_of_mul_eq_one_left <| H hx hb).trans (inv_eq_of_mul_eq_one_left <| H ha hb)\n    · exact (eq_inv_of_mul_eq_one_right <| H ha hx).trans (inv_eq_of_mul_eq_one_right <| H ha hb)\n  · rintro ⟨b, c, rfl, rfl, h⟩\n    rw [singleton_mul_singleton, h, singleton_one]\n\n"}
{"name":"Set.add_eq_zero_iff","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : SubtractionMonoid α\ns t : Set α\n⊢ Iff (Eq (HAdd.hAdd s t) 0) (Exists fun a => Exists fun b => And (Eq s (Singleton.singleton a)) (And (Eq t (Singleton.singleton b)) (Eq (HAdd.hAdd a b) 0)))","decl":"@[to_additive]\nprotected theorem mul_eq_one_iff : s * t = 1 ↔ ∃ a b, s = {a} ∧ t = {b} ∧ a * b = 1 := by\n  refine ⟨fun h => ?_, ?_⟩\n  · have hst : (s * t).Nonempty := h.symm.subst one_nonempty\n    obtain ⟨a, ha⟩ := hst.of_image2_left\n    obtain ⟨b, hb⟩ := hst.of_image2_right\n    have H : ∀ {a b}, a ∈ s → b ∈ t → a * b = (1 : α) := fun {a b} ha hb =>\n      h.subset <| mem_image2_of_mem ha hb\n    refine ⟨a, b, ?_, ?_, H ha hb⟩ <;> refine eq_singleton_iff_unique_mem.2 ⟨‹_›, fun x hx => ?_⟩\n    · exact (eq_inv_of_mul_eq_one_left <| H hx hb).trans (inv_eq_of_mul_eq_one_left <| H ha hb)\n    · exact (eq_inv_of_mul_eq_one_right <| H ha hx).trans (inv_eq_of_mul_eq_one_right <| H ha hb)\n  · rintro ⟨b, c, rfl, rfl, h⟩\n    rw [singleton_mul_singleton, h, singleton_one]\n\n"}
{"name":"Set.isAddUnit_iff","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : SubtractionMonoid α\ns : Set α\n⊢ Iff (IsAddUnit s) (Exists fun a => And (Eq s (Singleton.singleton a)) (IsAddUnit a))","decl":"@[to_additive (attr := simp 500)]\ntheorem isUnit_iff : IsUnit s ↔ ∃ a, s = {a} ∧ IsUnit a := by\n  constructor\n  · rintro ⟨u, rfl⟩\n    obtain ⟨a, b, ha, hb, h⟩ := Set.mul_eq_one_iff.1 u.mul_inv\n    refine ⟨a, ha, ⟨a, b, h, singleton_injective ?_⟩, rfl⟩\n    rw [← singleton_mul_singleton, ← ha, ← hb]\n    exact u.inv_mul\n  · rintro ⟨a, rfl, ha⟩\n    exact ha.set\n\n"}
{"name":"Set.isUnit_iff","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : DivisionMonoid α\ns : Set α\n⊢ Iff (IsUnit s) (Exists fun a => And (Eq s (Singleton.singleton a)) (IsUnit a))","decl":"@[to_additive (attr := simp 500)]\ntheorem isUnit_iff : IsUnit s ↔ ∃ a, s = {a} ∧ IsUnit a := by\n  constructor\n  · rintro ⟨u, rfl⟩\n    obtain ⟨a, b, ha, hb, h⟩ := Set.mul_eq_one_iff.1 u.mul_inv\n    refine ⟨a, ha, ⟨a, b, h, singleton_injective ?_⟩, rfl⟩\n    rw [← singleton_mul_singleton, ← ha, ← hb]\n    exact u.inv_mul\n  · rintro ⟨a, rfl, ha⟩\n    exact ha.set\n\n"}
{"name":"Set.univ_div_univ","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : DivisionMonoid α\n⊢ Eq (HDiv.hDiv Set.univ Set.univ) Set.univ","decl":"@[to_additive (attr := simp)]\nlemma univ_div_univ : (univ / univ : Set α) = univ := by simp [div_eq_mul_inv]\n\n"}
{"name":"Set.univ_sub_univ","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : SubtractionMonoid α\n⊢ Eq (HSub.hSub Set.univ Set.univ) Set.univ","decl":"@[to_additive (attr := simp)]\nlemma univ_div_univ : (univ / univ : Set α) = univ := by simp [div_eq_mul_inv]\n\n"}
{"name":"Set.subset_sub_left","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : SubtractionMonoid α\ns t : Set α\nht : Membership.mem t 0\n⊢ HasSubset.Subset s (HSub.hSub s t)","decl":"@[to_additive] lemma subset_div_left (ht : 1 ∈ t) : s ⊆ s / t := by\n  rw [div_eq_mul_inv]; exact subset_mul_left _ <| by simpa\n\n"}
{"name":"Set.subset_div_left","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : DivisionMonoid α\ns t : Set α\nht : Membership.mem t 1\n⊢ HasSubset.Subset s (HDiv.hDiv s t)","decl":"@[to_additive] lemma subset_div_left (ht : 1 ∈ t) : s ⊆ s / t := by\n  rw [div_eq_mul_inv]; exact subset_mul_left _ <| by simpa\n\n"}
{"name":"Set.neg_subset_sub_right","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : SubtractionMonoid α\ns t : Set α\nhs : Membership.mem s 0\n⊢ HasSubset.Subset (Neg.neg t) (HSub.hSub s t)","decl":"@[to_additive] lemma inv_subset_div_right (hs : 1 ∈ s) : t⁻¹ ⊆ s / t := by\n  rw [div_eq_mul_inv]; exact subset_mul_right _ hs\n\n"}
{"name":"Set.inv_subset_div_right","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : DivisionMonoid α\ns t : Set α\nhs : Membership.mem s 1\n⊢ HasSubset.Subset (Inv.inv t) (HDiv.hDiv s t)","decl":"@[to_additive] lemma inv_subset_div_right (hs : 1 ∈ s) : t⁻¹ ⊆ s / t := by\n  rw [div_eq_mul_inv]; exact subset_mul_right _ hs\n\n"}
{"name":"Set.zsmul_empty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : SubtractionMonoid α\nn : Int\nhn : Ne n 0\n⊢ Eq (HSMul.hSMul n EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp) zsmul_empty]\nlemma empty_zpow (hn : n ≠ 0) : (∅ : Set α) ^ n = ∅ := by cases n <;> aesop\n\n"}
{"name":"Set.empty_zpow","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : DivisionMonoid α\nn : Int\nhn : Ne n 0\n⊢ Eq (HPow.hPow EmptyCollection.emptyCollection n) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp) zsmul_empty]\nlemma empty_zpow (hn : n ≠ 0) : (∅ : Set α) ^ n = ∅ := by cases n <;> aesop\n\n"}
{"name":"Set.Nonempty.zpow","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : DivisionMonoid α\ns : Set α\nhs : s.Nonempty\nn : Int\n⊢ (HPow.hPow s n).Nonempty","decl":"@[to_additive]\nlemma Nonempty.zpow (hs : s.Nonempty) : ∀ {n : ℤ}, (s ^ n).Nonempty\n  | (n : ℕ) => hs.pow\n  | .negSucc n => by simpa using hs.pow\n\n"}
{"name":"Set.Nonempty.zsmul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : SubtractionMonoid α\ns : Set α\nhs : s.Nonempty\nn : Int\n⊢ (HSMul.hSMul n s).Nonempty","decl":"@[to_additive]\nlemma Nonempty.zpow (hs : s.Nonempty) : ∀ {n : ℤ}, (s ^ n).Nonempty\n  | (n : ℕ) => hs.pow\n  | .negSucc n => by simpa using hs.pow\n\n"}
{"name":"Set.zsmul_eq_empty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : SubtractionMonoid α\ns : Set α\nn : Int\n⊢ Iff (Eq (HSMul.hSMul n s) EmptyCollection.emptyCollection) (And (Eq s EmptyCollection.emptyCollection) (Ne n 0))","decl":"set_option push_neg.use_distrib true in\n@[to_additive (attr := simp)] lemma zpow_eq_empty : s ^ n = ∅ ↔ s = ∅ ∧ n ≠ 0 := by\n  constructor\n  · contrapose!\n    rintro (hs | rfl)\n    · exact hs.zpow\n    · simp\n  · rintro ⟨rfl, hn⟩\n    exact empty_zpow hn\n\n"}
{"name":"Set.zpow_eq_empty","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : DivisionMonoid α\ns : Set α\nn : Int\n⊢ Iff (Eq (HPow.hPow s n) EmptyCollection.emptyCollection) (And (Eq s EmptyCollection.emptyCollection) (Ne n 0))","decl":"set_option push_neg.use_distrib true in\n@[to_additive (attr := simp)] lemma zpow_eq_empty : s ^ n = ∅ ↔ s = ∅ ∧ n ≠ 0 := by\n  constructor\n  · contrapose!\n    rintro (hs | rfl)\n    · exact hs.zpow\n    · simp\n  · rintro ⟨rfl, hn⟩\n    exact empty_zpow hn\n\n"}
{"name":"Set.zsmul_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : SubtractionMonoid α\na : α\nn : Int\n⊢ Eq (HSMul.hSMul n (Singleton.singleton a)) (Singleton.singleton (HSMul.hSMul n a))","decl":"@[to_additive (attr := simp) zsmul_singleton]\nlemma singleton_zpow (a : α) (n : ℤ) : ({a} : Set α) ^ n = {a ^ n} := by cases n <;> simp\n\n"}
{"name":"Set.singleton_zpow","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : DivisionMonoid α\na : α\nn : Int\n⊢ Eq (HPow.hPow (Singleton.singleton a) n) (Singleton.singleton (HPow.hPow a n))","decl":"@[to_additive (attr := simp) zsmul_singleton]\nlemma singleton_zpow (a : α) (n : ℤ) : ({a} : Set α) ^ n = {a ^ n} := by cases n <;> simp\n\n"}
{"name":"Set.zero_mem_sub_iff","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\ns t : Set α\n⊢ Iff (Membership.mem (HSub.hSub s t) 0) (Not (Disjoint s t))","decl":"@[to_additive (attr := simp)]\ntheorem one_mem_div_iff : (1 : α) ∈ s / t ↔ ¬Disjoint s t := by\n  simp [not_disjoint_iff_nonempty_inter, mem_div, div_eq_one, Set.Nonempty]\n\n"}
{"name":"Set.one_mem_div_iff","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Group α\ns t : Set α\n⊢ Iff (Membership.mem (HDiv.hDiv s t) 1) (Not (Disjoint s t))","decl":"@[to_additive (attr := simp)]\ntheorem one_mem_div_iff : (1 : α) ∈ s / t ↔ ¬Disjoint s t := by\n  simp [not_disjoint_iff_nonempty_inter, mem_div, div_eq_one, Set.Nonempty]\n\n"}
{"name":"Set.zero_mem_neg_add_iff","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\ns t : Set α\n⊢ Iff (Membership.mem (HAdd.hAdd (Neg.neg t) s) 0) (Not (Disjoint s t))","decl":"@[to_additive (attr := simp)]\nlemma one_mem_inv_mul_iff : (1 : α) ∈ t⁻¹ * s ↔ ¬Disjoint s t := by\n  aesop (add simp [not_disjoint_iff_nonempty_inter, mem_mul, mul_eq_one_iff_eq_inv, Set.Nonempty])\n\n"}
{"name":"Set.one_mem_inv_mul_iff","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Group α\ns t : Set α\n⊢ Iff (Membership.mem (HMul.hMul (Inv.inv t) s) 1) (Not (Disjoint s t))","decl":"@[to_additive (attr := simp)]\nlemma one_mem_inv_mul_iff : (1 : α) ∈ t⁻¹ * s ↔ ¬Disjoint s t := by\n  aesop (add simp [not_disjoint_iff_nonempty_inter, mem_mul, mul_eq_one_iff_eq_inv, Set.Nonempty])\n\n"}
{"name":"Set.not_one_mem_div_iff","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Group α\ns t : Set α\n⊢ Iff (Not (Membership.mem (HDiv.hDiv s t) 1)) (Disjoint s t)","decl":"@[to_additive]\ntheorem not_one_mem_div_iff : (1 : α) ∉ s / t ↔ Disjoint s t :=\n  one_mem_div_iff.not_left\n\n"}
{"name":"Set.not_zero_mem_sub_iff","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\ns t : Set α\n⊢ Iff (Not (Membership.mem (HSub.hSub s t) 0)) (Disjoint s t)","decl":"@[to_additive]\ntheorem not_one_mem_div_iff : (1 : α) ∉ s / t ↔ Disjoint s t :=\n  one_mem_div_iff.not_left\n\n"}
{"name":"Set.not_one_mem_inv_mul_iff","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Group α\ns t : Set α\n⊢ Iff (Not (Membership.mem (HMul.hMul (Inv.inv t) s) 1)) (Disjoint s t)","decl":"@[to_additive]\nlemma not_one_mem_inv_mul_iff : (1 : α) ∉ t⁻¹ * s ↔ Disjoint s t := one_mem_inv_mul_iff.not_left\n\n"}
{"name":"Set.not_zero_mem_neg_add_iff","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\ns t : Set α\n⊢ Iff (Not (Membership.mem (HAdd.hAdd (Neg.neg t) s) 0)) (Disjoint s t)","decl":"@[to_additive]\nlemma not_one_mem_inv_mul_iff : (1 : α) ∉ t⁻¹ * s ↔ Disjoint s t := one_mem_inv_mul_iff.not_left\n\n"}
{"name":"Disjoint.one_not_mem_div_set","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Group α\ns t : Set α\na✝ : Disjoint s t\n⊢ Not (Membership.mem (HDiv.hDiv s t) 1)","decl":"alias ⟨_, _root_.Disjoint.one_not_mem_div_set⟩ := not_one_mem_div_iff\n\n"}
{"name":"Disjoint.zero_not_mem_sub_set","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\ns t : Set α\na✝ : Disjoint s t\n⊢ Not (Membership.mem (HSub.hSub s t) 0)","decl":"attribute [to_additive] Disjoint.one_not_mem_div_set\n\n"}
{"name":"Set.Nonempty.zero_mem_sub","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\ns : Set α\nh : s.Nonempty\n⊢ Membership.mem (HSub.hSub s s) 0","decl":"@[to_additive]\ntheorem Nonempty.one_mem_div (h : s.Nonempty) : (1 : α) ∈ s / s :=\n  let ⟨a, ha⟩ := h\n  mem_div.2 ⟨a, ha, a, ha, div_self' _⟩\n\n"}
{"name":"Set.Nonempty.one_mem_div","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Group α\ns : Set α\nh : s.Nonempty\n⊢ Membership.mem (HDiv.hDiv s s) 1","decl":"@[to_additive]\ntheorem Nonempty.one_mem_div (h : s.Nonempty) : (1 : α) ∈ s / s :=\n  let ⟨a, ha⟩ := h\n  mem_div.2 ⟨a, ha, a, ha, div_self' _⟩\n\n"}
{"name":"Set.isUnit_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Group α\na : α\n⊢ IsUnit (Singleton.singleton a)","decl":"@[to_additive]\ntheorem isUnit_singleton (a : α) : IsUnit ({a} : Set α) :=\n  (Group.isUnit a).set\n\n"}
{"name":"Set.isAddUnit_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\na : α\n⊢ IsAddUnit (Singleton.singleton a)","decl":"@[to_additive]\ntheorem isUnit_singleton (a : α) : IsUnit ({a} : Set α) :=\n  (Group.isUnit a).set\n\n"}
{"name":"Set.isAddUnit_iff_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\ns : Set α\n⊢ Iff (IsAddUnit s) (Exists fun a => Eq s (Singleton.singleton a))","decl":"@[to_additive (attr := simp)]\ntheorem isUnit_iff_singleton : IsUnit s ↔ ∃ a, s = {a} := by\n  simp only [isUnit_iff, Group.isUnit, and_true]\n\n"}
{"name":"Set.isUnit_iff_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Group α\ns : Set α\n⊢ Iff (IsUnit s) (Exists fun a => Eq s (Singleton.singleton a))","decl":"@[to_additive (attr := simp)]\ntheorem isUnit_iff_singleton : IsUnit s ↔ ∃ a, s = {a} := by\n  simp only [isUnit_iff, Group.isUnit, and_true]\n\n"}
{"name":"Set.image_add_left","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\nt : Set α\na : α\n⊢ Eq (Set.image (fun x => HAdd.hAdd a x) t) (Set.preimage (fun x => HAdd.hAdd (Neg.neg a) x) t)","decl":"@[to_additive (attr := simp)]\ntheorem image_mul_left : (a * ·) '' t = (a⁻¹ * ·) ⁻¹' t := by\n  rw [image_eq_preimage_of_inverse] <;> intro c <;> simp\n\n"}
{"name":"Set.image_mul_left","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Group α\nt : Set α\na : α\n⊢ Eq (Set.image (fun x => HMul.hMul a x) t) (Set.preimage (fun x => HMul.hMul (Inv.inv a) x) t)","decl":"@[to_additive (attr := simp)]\ntheorem image_mul_left : (a * ·) '' t = (a⁻¹ * ·) ⁻¹' t := by\n  rw [image_eq_preimage_of_inverse] <;> intro c <;> simp\n\n"}
{"name":"Set.image_add_right","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\nt : Set α\nb : α\n⊢ Eq (Set.image (fun x => HAdd.hAdd x b) t) (Set.preimage (fun x => HAdd.hAdd x (Neg.neg b)) t)","decl":"@[to_additive (attr := simp)]\ntheorem image_mul_right : (· * b) '' t = (· * b⁻¹) ⁻¹' t := by\n  rw [image_eq_preimage_of_inverse] <;> intro c <;> simp\n\n"}
{"name":"Set.image_mul_right","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Group α\nt : Set α\nb : α\n⊢ Eq (Set.image (fun x => HMul.hMul x b) t) (Set.preimage (fun x => HMul.hMul x (Inv.inv b)) t)","decl":"@[to_additive (attr := simp)]\ntheorem image_mul_right : (· * b) '' t = (· * b⁻¹) ⁻¹' t := by\n  rw [image_eq_preimage_of_inverse] <;> intro c <;> simp\n\n"}
{"name":"Set.image_add_left'","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\nt : Set α\na : α\n⊢ Eq (Set.image (fun x => HAdd.hAdd (Neg.neg a) x) t) (Set.preimage (fun x => HAdd.hAdd a x) t)","decl":"@[to_additive]\ntheorem image_mul_left' : (a⁻¹ * ·) '' t = (a * ·) ⁻¹' t := by simp\n\n"}
{"name":"Set.image_mul_left'","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Group α\nt : Set α\na : α\n⊢ Eq (Set.image (fun x => HMul.hMul (Inv.inv a) x) t) (Set.preimage (fun x => HMul.hMul a x) t)","decl":"@[to_additive]\ntheorem image_mul_left' : (a⁻¹ * ·) '' t = (a * ·) ⁻¹' t := by simp\n\n"}
{"name":"Set.image_mul_right'","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Group α\nt : Set α\nb : α\n⊢ Eq (Set.image (fun x => HMul.hMul x (Inv.inv b)) t) (Set.preimage (fun x => HMul.hMul x b) t)","decl":"@[to_additive]\ntheorem image_mul_right' : (· * b⁻¹) '' t = (· * b) ⁻¹' t := by simp\n\n"}
{"name":"Set.image_add_right'","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\nt : Set α\nb : α\n⊢ Eq (Set.image (fun x => HAdd.hAdd x (Neg.neg b)) t) (Set.preimage (fun x => HAdd.hAdd x b) t)","decl":"@[to_additive]\ntheorem image_mul_right' : (· * b⁻¹) '' t = (· * b) ⁻¹' t := by simp\n\n"}
{"name":"Set.preimage_mul_left_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Group α\na b : α\n⊢ Eq (Set.preimage (fun x => HMul.hMul a x) (Singleton.singleton b)) (Singleton.singleton (HMul.hMul (Inv.inv a) b))","decl":"@[to_additive (attr := simp)]\ntheorem preimage_mul_left_singleton : (a * ·) ⁻¹' {b} = {a⁻¹ * b} := by\n  rw [← image_mul_left', image_singleton]\n\n"}
{"name":"Set.preimage_add_left_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\na b : α\n⊢ Eq (Set.preimage (fun x => HAdd.hAdd a x) (Singleton.singleton b)) (Singleton.singleton (HAdd.hAdd (Neg.neg a) b))","decl":"@[to_additive (attr := simp)]\ntheorem preimage_mul_left_singleton : (a * ·) ⁻¹' {b} = {a⁻¹ * b} := by\n  rw [← image_mul_left', image_singleton]\n\n"}
{"name":"Set.preimage_add_right_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\na b : α\n⊢ Eq (Set.preimage (fun x => HAdd.hAdd x a) (Singleton.singleton b)) (Singleton.singleton (HAdd.hAdd b (Neg.neg a)))","decl":"@[to_additive (attr := simp)]\ntheorem preimage_mul_right_singleton : (· * a) ⁻¹' {b} = {b * a⁻¹} := by\n  rw [← image_mul_right', image_singleton]\n\n"}
{"name":"Set.preimage_mul_right_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Group α\na b : α\n⊢ Eq (Set.preimage (fun x => HMul.hMul x a) (Singleton.singleton b)) (Singleton.singleton (HMul.hMul b (Inv.inv a)))","decl":"@[to_additive (attr := simp)]\ntheorem preimage_mul_right_singleton : (· * a) ⁻¹' {b} = {b * a⁻¹} := by\n  rw [← image_mul_right', image_singleton]\n\n"}
{"name":"Set.preimage_mul_left_one","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Group α\na : α\n⊢ Eq (Set.preimage (fun x => HMul.hMul a x) 1) (Singleton.singleton (Inv.inv a))","decl":"@[to_additive (attr := simp)]\ntheorem preimage_mul_left_one : (a * ·) ⁻¹' 1 = {a⁻¹} := by\n  rw [← image_mul_left', image_one, mul_one]\n\n"}
{"name":"Set.preimage_add_left_zero","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\na : α\n⊢ Eq (Set.preimage (fun x => HAdd.hAdd a x) 0) (Singleton.singleton (Neg.neg a))","decl":"@[to_additive (attr := simp)]\ntheorem preimage_mul_left_one : (a * ·) ⁻¹' 1 = {a⁻¹} := by\n  rw [← image_mul_left', image_one, mul_one]\n\n"}
{"name":"Set.preimage_mul_right_one","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Group α\nb : α\n⊢ Eq (Set.preimage (fun x => HMul.hMul x b) 1) (Singleton.singleton (Inv.inv b))","decl":"@[to_additive (attr := simp)]\ntheorem preimage_mul_right_one : (· * b) ⁻¹' 1 = {b⁻¹} := by\n  rw [← image_mul_right', image_one, one_mul]\n\n"}
{"name":"Set.preimage_add_right_zero","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\nb : α\n⊢ Eq (Set.preimage (fun x => HAdd.hAdd x b) 0) (Singleton.singleton (Neg.neg b))","decl":"@[to_additive (attr := simp)]\ntheorem preimage_mul_right_one : (· * b) ⁻¹' 1 = {b⁻¹} := by\n  rw [← image_mul_right', image_one, one_mul]\n\n"}
{"name":"Set.preimage_add_left_zero'","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\na : α\n⊢ Eq (Set.preimage (fun x => HAdd.hAdd (Neg.neg a) x) 0) (Singleton.singleton a)","decl":"@[to_additive]\ntheorem preimage_mul_left_one' : (a⁻¹ * ·) ⁻¹' 1 = {a} := by simp\n\n"}
{"name":"Set.preimage_mul_left_one'","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Group α\na : α\n⊢ Eq (Set.preimage (fun x => HMul.hMul (Inv.inv a) x) 1) (Singleton.singleton a)","decl":"@[to_additive]\ntheorem preimage_mul_left_one' : (a⁻¹ * ·) ⁻¹' 1 = {a} := by simp\n\n"}
{"name":"Set.preimage_add_right_zero'","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\nb : α\n⊢ Eq (Set.preimage (fun x => HAdd.hAdd x (Neg.neg b)) 0) (Singleton.singleton b)","decl":"@[to_additive]\ntheorem preimage_mul_right_one' : (· * b⁻¹) ⁻¹' 1 = {b} := by simp\n\n"}
{"name":"Set.preimage_mul_right_one'","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Group α\nb : α\n⊢ Eq (Set.preimage (fun x => HMul.hMul x (Inv.inv b)) 1) (Singleton.singleton b)","decl":"@[to_additive]\ntheorem preimage_mul_right_one' : (· * b⁻¹) ⁻¹' 1 = {b} := by simp\n\n"}
{"name":"Set.add_univ","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\ns : Set α\nhs : s.Nonempty\n⊢ Eq (HAdd.hAdd s Set.univ) Set.univ","decl":"@[to_additive (attr := simp)]\ntheorem mul_univ (hs : s.Nonempty) : s * (univ : Set α) = univ :=\n  let ⟨a, ha⟩ := hs\n  eq_univ_of_forall fun b => ⟨a, ha, a⁻¹ * b, trivial, mul_inv_cancel_left ..⟩\n\n"}
{"name":"Set.mul_univ","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Group α\ns : Set α\nhs : s.Nonempty\n⊢ Eq (HMul.hMul s Set.univ) Set.univ","decl":"@[to_additive (attr := simp)]\ntheorem mul_univ (hs : s.Nonempty) : s * (univ : Set α) = univ :=\n  let ⟨a, ha⟩ := hs\n  eq_univ_of_forall fun b => ⟨a, ha, a⁻¹ * b, trivial, mul_inv_cancel_left ..⟩\n\n"}
{"name":"Set.univ_mul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : Group α\nt : Set α\nht : t.Nonempty\n⊢ Eq (HMul.hMul Set.univ t) Set.univ","decl":"@[to_additive (attr := simp)]\ntheorem univ_mul (ht : t.Nonempty) : (univ : Set α) * t = univ :=\n  let ⟨a, ha⟩ := ht\n  eq_univ_of_forall fun b => ⟨b * a⁻¹, trivial, a, ha, inv_mul_cancel_right ..⟩\n\n"}
{"name":"Set.univ_add","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\nt : Set α\nht : t.Nonempty\n⊢ Eq (HAdd.hAdd Set.univ t) Set.univ","decl":"@[to_additive (attr := simp)]\ntheorem univ_mul (ht : t.Nonempty) : (univ : Set α) * t = univ :=\n  let ⟨a, ha⟩ := ht\n  eq_univ_of_forall fun b => ⟨b * a⁻¹, trivial, a, ha, inv_mul_cancel_right ..⟩\n\n"}
{"name":"Set.image_neg","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : AddGroup α\ninst✝² : SubtractionMonoid β\ninst✝¹ : FunLike F α β\ninst✝ : AddMonoidHomClass F α β\nf : F\ns : Set α\n⊢ Eq (Set.image (⇑f) (Neg.neg s)) (Neg.neg (Set.image (⇑f) s))","decl":"@[to_additive]\nlemma image_inv [DivisionMonoid β] [FunLike F α β] [MonoidHomClass F α β] (f : F) (s : Set α) :\n    f '' s⁻¹ = (f '' s)⁻¹ := by\n  rw [← image_inv_eq_inv, ← image_inv_eq_inv]; exact image_comm (map_inv _)\n\n"}
{"name":"Set.image_inv","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Group α\ninst✝² : DivisionMonoid β\ninst✝¹ : FunLike F α β\ninst✝ : MonoidHomClass F α β\nf : F\ns : Set α\n⊢ Eq (Set.image (⇑f) (Inv.inv s)) (Inv.inv (Set.image (⇑f) s))","decl":"@[to_additive]\nlemma image_inv [DivisionMonoid β] [FunLike F α β] [MonoidHomClass F α β] (f : F) (s : Set α) :\n    f '' s⁻¹ = (f '' s)⁻¹ := by\n  rw [← image_inv_eq_inv, ← image_inv_eq_inv]; exact image_comm (map_inv _)\n\n"}
{"name":"Set.image_mul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Mul α\ninst✝² : Mul β\ninst✝¹ : FunLike F α β\ninst✝ : MulHomClass F α β\nm : F\ns t : Set α\n⊢ Eq (Set.image (⇑m) (HMul.hMul s t)) (HMul.hMul (Set.image (⇑m) s) (Set.image (⇑m) t))","decl":"@[to_additive]\ntheorem image_mul : m '' (s * t) = m '' s * m '' t :=\n  image_image2_distrib <| map_mul m\n\n"}
{"name":"Set.image_add","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Add α\ninst✝² : Add β\ninst✝¹ : FunLike F α β\ninst✝ : AddHomClass F α β\nm : F\ns t : Set α\n⊢ Eq (Set.image (⇑m) (HAdd.hAdd s t)) (HAdd.hAdd (Set.image (⇑m) s) (Set.image (⇑m) t))","decl":"@[to_additive]\ntheorem image_mul : m '' (s * t) = m '' s * m '' t :=\n  image_image2_distrib <| map_mul m\n\n"}
{"name":"Set.mul_subset_range","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Mul α\ninst✝² : Mul β\ninst✝¹ : FunLike F α β\ninst✝ : MulHomClass F α β\nm : F\ns t : Set β\nhs : HasSubset.Subset s (Set.range ⇑m)\nht : HasSubset.Subset t (Set.range ⇑m)\n⊢ HasSubset.Subset (HMul.hMul s t) (Set.range ⇑m)","decl":"@[to_additive]\nlemma mul_subset_range {s t : Set β} (hs : s ⊆ range m) (ht : t ⊆ range m) : s * t ⊆ range m := by\n  rintro _ ⟨a, ha, b, hb, rfl⟩\n  obtain ⟨a, rfl⟩ := hs ha\n  obtain ⟨b, rfl⟩ := ht hb\n  exact ⟨a * b, map_mul ..⟩\n\n"}
{"name":"Set.add_subset_range","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Add α\ninst✝² : Add β\ninst✝¹ : FunLike F α β\ninst✝ : AddHomClass F α β\nm : F\ns t : Set β\nhs : HasSubset.Subset s (Set.range ⇑m)\nht : HasSubset.Subset t (Set.range ⇑m)\n⊢ HasSubset.Subset (HAdd.hAdd s t) (Set.range ⇑m)","decl":"@[to_additive]\nlemma mul_subset_range {s t : Set β} (hs : s ⊆ range m) (ht : t ⊆ range m) : s * t ⊆ range m := by\n  rintro _ ⟨a, ha, b, hb, rfl⟩\n  obtain ⟨a, rfl⟩ := hs ha\n  obtain ⟨b, rfl⟩ := ht hb\n  exact ⟨a * b, map_mul ..⟩\n\n"}
{"name":"Set.preimage_mul_preimage_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Mul α\ninst✝² : Mul β\ninst✝¹ : FunLike F α β\ninst✝ : MulHomClass F α β\nm : F\ns t : Set β\n⊢ HasSubset.Subset (HMul.hMul (Set.preimage (⇑m) s) (Set.preimage (⇑m) t)) (Set.preimage (⇑m) (HMul.hMul s t))","decl":"@[to_additive]\ntheorem preimage_mul_preimage_subset {s t : Set β} : m ⁻¹' s * m ⁻¹' t ⊆ m ⁻¹' (s * t) := by\n  rintro _ ⟨_, _, _, _, rfl⟩\n  exact ⟨_, ‹_›, _, ‹_›, (map_mul m ..).symm⟩\n\n"}
{"name":"Set.preimage_add_preimage_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Add α\ninst✝² : Add β\ninst✝¹ : FunLike F α β\ninst✝ : AddHomClass F α β\nm : F\ns t : Set β\n⊢ HasSubset.Subset (HAdd.hAdd (Set.preimage (⇑m) s) (Set.preimage (⇑m) t)) (Set.preimage (⇑m) (HAdd.hAdd s t))","decl":"@[to_additive]\ntheorem preimage_mul_preimage_subset {s t : Set β} : m ⁻¹' s * m ⁻¹' t ⊆ m ⁻¹' (s * t) := by\n  rintro _ ⟨_, _, _, _, rfl⟩\n  exact ⟨_, ‹_›, _, ‹_›, (map_mul m ..).symm⟩\n\n"}
{"name":"Set.preimage_add","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Add α\ninst✝² : Add β\ninst✝¹ : FunLike F α β\ninst✝ : AddHomClass F α β\nm : F\nhm : Function.Injective ⇑m\ns t : Set β\nhs : HasSubset.Subset s (Set.range ⇑m)\nht : HasSubset.Subset t (Set.range ⇑m)\n⊢ Eq (Set.preimage (⇑m) (HAdd.hAdd s t)) (HAdd.hAdd (Set.preimage (⇑m) s) (Set.preimage (⇑m) t))","decl":"@[to_additive]\nlemma preimage_mul (hm : Injective m) {s t : Set β} (hs : s ⊆ range m) (ht : t ⊆ range m) :\n    m ⁻¹' (s * t) = m ⁻¹' s * m ⁻¹' t :=\n  hm.image_injective <| by\n    rw [image_mul, image_preimage_eq_iff.2 hs, image_preimage_eq_iff.2 ht,\n      image_preimage_eq_iff.2 (mul_subset_range m hs ht)]\n\n"}
{"name":"Set.preimage_mul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Mul α\ninst✝² : Mul β\ninst✝¹ : FunLike F α β\ninst✝ : MulHomClass F α β\nm : F\nhm : Function.Injective ⇑m\ns t : Set β\nhs : HasSubset.Subset s (Set.range ⇑m)\nht : HasSubset.Subset t (Set.range ⇑m)\n⊢ Eq (Set.preimage (⇑m) (HMul.hMul s t)) (HMul.hMul (Set.preimage (⇑m) s) (Set.preimage (⇑m) t))","decl":"@[to_additive]\nlemma preimage_mul (hm : Injective m) {s t : Set β} (hs : s ⊆ range m) (ht : t ⊆ range m) :\n    m ⁻¹' (s * t) = m ⁻¹' s * m ⁻¹' t :=\n  hm.image_injective <| by\n    rw [image_mul, image_preimage_eq_iff.2 hs, image_preimage_eq_iff.2 ht,\n      image_preimage_eq_iff.2 (mul_subset_range m hs ht)]\n\n"}
{"name":"Set.image_nsmul_of_ne_zero","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : AddMonoid α\ninst✝² : AddMonoid β\ninst✝¹ : FunLike F α β\ninst✝ : AddHomClass F α β\nn : Nat\na✝ : Ne n 0\nf : F\ns : Set α\n⊢ Eq (Set.image (⇑f) (HSMul.hSMul n s)) (HSMul.hSMul n (Set.image (⇑f) s))","decl":"@[to_additive]\nlemma image_pow_of_ne_zero [MulHomClass F α β] :\n    ∀ {n}, n ≠ 0 → ∀ (f : F) (s : Set α), f '' (s ^ n) = (f '' s) ^ n\n  | 1, _ => by simp\n  | n + 2, _ => by simp [image_mul, pow_succ _ n.succ, image_pow_of_ne_zero]\n\n"}
{"name":"Set.image_pow_of_ne_zero","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Monoid α\ninst✝² : Monoid β\ninst✝¹ : FunLike F α β\ninst✝ : MulHomClass F α β\nn : Nat\na✝ : Ne n 0\nf : F\ns : Set α\n⊢ Eq (Set.image (⇑f) (HPow.hPow s n)) (HPow.hPow (Set.image (⇑f) s) n)","decl":"@[to_additive]\nlemma image_pow_of_ne_zero [MulHomClass F α β] :\n    ∀ {n}, n ≠ 0 → ∀ (f : F) (s : Set α), f '' (s ^ n) = (f '' s) ^ n\n  | 1, _ => by simp\n  | n + 2, _ => by simp [image_mul, pow_succ _ n.succ, image_pow_of_ne_zero]\n\n"}
{"name":"Set.image_pow","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Monoid α\ninst✝² : Monoid β\ninst✝¹ : FunLike F α β\ninst✝ : MonoidHomClass F α β\nf : F\ns : Set α\nn : Nat\n⊢ Eq (Set.image (⇑f) (HPow.hPow s n)) (HPow.hPow (Set.image (⇑f) s) n)","decl":"@[to_additive]\nlemma image_pow [MonoidHomClass F α β] (f : F) (s : Set α) : ∀ n, f '' (s ^ n) = (f '' s) ^ n\n  | 0 => by simp [singleton_one]\n  | n + 1 => image_pow_of_ne_zero n.succ_ne_zero ..\n\n"}
{"name":"Set.image_nsmul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : AddMonoid α\ninst✝² : AddMonoid β\ninst✝¹ : FunLike F α β\ninst✝ : AddMonoidHomClass F α β\nf : F\ns : Set α\nn : Nat\n⊢ Eq (Set.image (⇑f) (HSMul.hSMul n s)) (HSMul.hSMul n (Set.image (⇑f) s))","decl":"@[to_additive]\nlemma image_pow [MonoidHomClass F α β] (f : F) (s : Set α) : ∀ n, f '' (s ^ n) = (f '' s) ^ n\n  | 0 => by simp [singleton_one]\n  | n + 1 => image_pow_of_ne_zero n.succ_ne_zero ..\n\n"}
{"name":"Set.image_div","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Group α\ninst✝² : DivisionMonoid β\ninst✝¹ : FunLike F α β\ninst✝ : MonoidHomClass F α β\nm : F\ns t : Set α\n⊢ Eq (Set.image (⇑m) (HDiv.hDiv s t)) (HDiv.hDiv (Set.image (⇑m) s) (Set.image (⇑m) t))","decl":"@[to_additive]\ntheorem image_div : m '' (s / t) = m '' s / m '' t :=\n  image_image2_distrib <| map_div m\n\n"}
{"name":"Set.image_sub","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : AddGroup α\ninst✝² : SubtractionMonoid β\ninst✝¹ : FunLike F α β\ninst✝ : AddMonoidHomClass F α β\nm : F\ns t : Set α\n⊢ Eq (Set.image (⇑m) (HSub.hSub s t)) (HSub.hSub (Set.image (⇑m) s) (Set.image (⇑m) t))","decl":"@[to_additive]\ntheorem image_div : m '' (s / t) = m '' s / m '' t :=\n  image_image2_distrib <| map_div m\n\n"}
{"name":"Set.div_subset_range","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Group α\ninst✝² : DivisionMonoid β\ninst✝¹ : FunLike F α β\ninst✝ : MonoidHomClass F α β\nm : F\ns t : Set β\nhs : HasSubset.Subset s (Set.range ⇑m)\nht : HasSubset.Subset t (Set.range ⇑m)\n⊢ HasSubset.Subset (HDiv.hDiv s t) (Set.range ⇑m)","decl":"@[to_additive]\nlemma div_subset_range {s t : Set β} (hs : s ⊆ range m) (ht : t ⊆ range m) : s / t ⊆ range m := by\n  rintro _ ⟨a, ha, b, hb, rfl⟩\n  obtain ⟨a, rfl⟩ := hs ha\n  obtain ⟨b, rfl⟩ := ht hb\n  exact ⟨a / b, map_div ..⟩\n\n"}
{"name":"Set.sub_subset_range","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : AddGroup α\ninst✝² : SubtractionMonoid β\ninst✝¹ : FunLike F α β\ninst✝ : AddMonoidHomClass F α β\nm : F\ns t : Set β\nhs : HasSubset.Subset s (Set.range ⇑m)\nht : HasSubset.Subset t (Set.range ⇑m)\n⊢ HasSubset.Subset (HSub.hSub s t) (Set.range ⇑m)","decl":"@[to_additive]\nlemma div_subset_range {s t : Set β} (hs : s ⊆ range m) (ht : t ⊆ range m) : s / t ⊆ range m := by\n  rintro _ ⟨a, ha, b, hb, rfl⟩\n  obtain ⟨a, rfl⟩ := hs ha\n  obtain ⟨b, rfl⟩ := ht hb\n  exact ⟨a / b, map_div ..⟩\n\n"}
{"name":"Set.preimage_sub_preimage_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : AddGroup α\ninst✝² : SubtractionMonoid β\ninst✝¹ : FunLike F α β\ninst✝ : AddMonoidHomClass F α β\nm : F\ns t : Set β\n⊢ HasSubset.Subset (HSub.hSub (Set.preimage (⇑m) s) (Set.preimage (⇑m) t)) (Set.preimage (⇑m) (HSub.hSub s t))","decl":"@[to_additive]\ntheorem preimage_div_preimage_subset {s t : Set β} : m ⁻¹' s / m ⁻¹' t ⊆ m ⁻¹' (s / t) := by\n  rintro _ ⟨_, _, _, _, rfl⟩\n  exact ⟨_, ‹_›, _, ‹_›, (map_div m ..).symm⟩\n\n"}
{"name":"Set.preimage_div_preimage_subset","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Group α\ninst✝² : DivisionMonoid β\ninst✝¹ : FunLike F α β\ninst✝ : MonoidHomClass F α β\nm : F\ns t : Set β\n⊢ HasSubset.Subset (HDiv.hDiv (Set.preimage (⇑m) s) (Set.preimage (⇑m) t)) (Set.preimage (⇑m) (HDiv.hDiv s t))","decl":"@[to_additive]\ntheorem preimage_div_preimage_subset {s t : Set β} : m ⁻¹' s / m ⁻¹' t ⊆ m ⁻¹' (s / t) := by\n  rintro _ ⟨_, _, _, _, rfl⟩\n  exact ⟨_, ‹_›, _, ‹_›, (map_div m ..).symm⟩\n\n"}
{"name":"Set.preimage_sub","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : AddGroup α\ninst✝² : SubtractionMonoid β\ninst✝¹ : FunLike F α β\ninst✝ : AddMonoidHomClass F α β\nm : F\nhm : Function.Injective ⇑m\ns t : Set β\nhs : HasSubset.Subset s (Set.range ⇑m)\nht : HasSubset.Subset t (Set.range ⇑m)\n⊢ Eq (Set.preimage (⇑m) (HSub.hSub s t)) (HSub.hSub (Set.preimage (⇑m) s) (Set.preimage (⇑m) t))","decl":"@[to_additive]\nlemma preimage_div (hm : Injective m) {s t : Set β} (hs : s ⊆ range m) (ht : t ⊆ range m) :\n    m ⁻¹' (s / t) = m ⁻¹' s / m ⁻¹' t :=\n  hm.image_injective <| by\n    rw [image_div, image_preimage_eq_iff.2 hs, image_preimage_eq_iff.2 ht,\n      image_preimage_eq_iff.2 (div_subset_range m hs ht)]\n\n"}
{"name":"Set.preimage_div","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Group α\ninst✝² : DivisionMonoid β\ninst✝¹ : FunLike F α β\ninst✝ : MonoidHomClass F α β\nm : F\nhm : Function.Injective ⇑m\ns t : Set β\nhs : HasSubset.Subset s (Set.range ⇑m)\nht : HasSubset.Subset t (Set.range ⇑m)\n⊢ Eq (Set.preimage (⇑m) (HDiv.hDiv s t)) (HDiv.hDiv (Set.preimage (⇑m) s) (Set.preimage (⇑m) t))","decl":"@[to_additive]\nlemma preimage_div (hm : Injective m) {s t : Set β} (hs : s ⊆ range m) (ht : t ⊆ range m) :\n    m ⁻¹' (s / t) = m ⁻¹' s / m ⁻¹' t :=\n  hm.image_injective <| by\n    rw [image_div, image_preimage_eq_iff.2 hs, image_preimage_eq_iff.2 ht,\n      image_preimage_eq_iff.2 (div_subset_range m hs ht)]\n\n"}
{"name":"Set.neg_pi","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"ι : Type u_5\nα : ι → Type u_6\ninst✝ : (i : ι) → Neg (α i)\ns : Set ι\nt : (i : ι) → Set (α i)\n⊢ Eq (Neg.neg (s.pi t)) (s.pi fun i => Neg.neg (t i))","decl":"@[to_additive (attr := simp)]\nlemma inv_pi (s : Set ι) (t : ∀ i, Set (α i)) : (s.pi t)⁻¹ = s.pi fun i ↦ (t i)⁻¹ := by ext x; simp\n\n"}
{"name":"Set.inv_pi","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"ι : Type u_5\nα : ι → Type u_6\ninst✝ : (i : ι) → Inv (α i)\ns : Set ι\nt : (i : ι) → Set (α i)\n⊢ Eq (Inv.inv (s.pi t)) (s.pi fun i => Inv.inv (t i))","decl":"@[to_additive (attr := simp)]\nlemma inv_pi (s : Set ι) (t : ∀ i, Set (α i)) : (s.pi t)⁻¹ = s.pi fun i ↦ (t i)⁻¹ := by ext x; simp\n\n"}
{"name":"Set.MapsTo.add","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : Add β\nA : Set α\nB₁ B₂ : Set β\nf₁ f₂ : α → β\nh₁ : Set.MapsTo f₁ A B₁\nh₂ : Set.MapsTo f₂ A B₂\n⊢ Set.MapsTo (HAdd.hAdd f₁ f₂) A (HAdd.hAdd B₁ B₂)","decl":"@[to_additive]\nlemma MapsTo.mul [Mul β] {A : Set α} {B₁ B₂ : Set β} {f₁ f₂ : α → β}\n    (h₁ : MapsTo f₁ A B₁) (h₂ : MapsTo f₂ A B₂) : MapsTo (f₁ * f₂) A (B₁ * B₂) :=\n  fun _ h => mul_mem_mul (h₁ h) (h₂ h)\n\n"}
{"name":"Set.MapsTo.mul","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : Mul β\nA : Set α\nB₁ B₂ : Set β\nf₁ f₂ : α → β\nh₁ : Set.MapsTo f₁ A B₁\nh₂ : Set.MapsTo f₂ A B₂\n⊢ Set.MapsTo (HMul.hMul f₁ f₂) A (HMul.hMul B₁ B₂)","decl":"@[to_additive]\nlemma MapsTo.mul [Mul β] {A : Set α} {B₁ B₂ : Set β} {f₁ f₂ : α → β}\n    (h₁ : MapsTo f₁ A B₁) (h₂ : MapsTo f₂ A B₂) : MapsTo (f₁ * f₂) A (B₁ * B₂) :=\n  fun _ h => mul_mem_mul (h₁ h) (h₂ h)\n\n"}
{"name":"Set.MapsTo.neg","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SubtractionCommMonoid β\nA : Set α\nB : Set β\nf : α → β\nh : Set.MapsTo f A B\n⊢ Set.MapsTo (Neg.neg f) A (Neg.neg B)","decl":"@[to_additive]\nlemma MapsTo.inv [DivisionCommMonoid β] {A : Set α} {B : Set β} {f : α → β} (h : MapsTo f A B) :\n    MapsTo (f⁻¹) A (B⁻¹) :=\n  fun _ ha => inv_mem_inv.2 (h ha)\n\n\n"}
{"name":"Set.MapsTo.inv","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : DivisionCommMonoid β\nA : Set α\nB : Set β\nf : α → β\nh : Set.MapsTo f A B\n⊢ Set.MapsTo (Inv.inv f) A (Inv.inv B)","decl":"@[to_additive]\nlemma MapsTo.inv [DivisionCommMonoid β] {A : Set α} {B : Set β} {f : α → β} (h : MapsTo f A B) :\n    MapsTo (f⁻¹) A (B⁻¹) :=\n  fun _ ha => inv_mem_inv.2 (h ha)\n\n\n"}
{"name":"Set.MapsTo.div","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : DivisionCommMonoid β\nA : Set α\nB₁ B₂ : Set β\nf₁ f₂ : α → β\nh₁ : Set.MapsTo f₁ A B₁\nh₂ : Set.MapsTo f₂ A B₂\n⊢ Set.MapsTo (HDiv.hDiv f₁ f₂) A (HDiv.hDiv B₁ B₂)","decl":"@[to_additive]\nlemma MapsTo.div [DivisionCommMonoid β] {A : Set α} {B₁ B₂ : Set β} {f₁ f₂ : α → β}\n    (h₁ : MapsTo f₁ A B₁) (h₂ : MapsTo f₂ A B₂) : MapsTo (f₁ / f₂) A (B₁ / B₂) :=\n  fun _ ha => div_mem_div (h₁ ha) (h₂ ha)\n\n"}
{"name":"Set.MapsTo.sub","module":"Mathlib.Algebra.Group.Pointwise.Set.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SubtractionCommMonoid β\nA : Set α\nB₁ B₂ : Set β\nf₁ f₂ : α → β\nh₁ : Set.MapsTo f₁ A B₁\nh₂ : Set.MapsTo f₂ A B₂\n⊢ Set.MapsTo (HSub.hSub f₁ f₂) A (HSub.hSub B₁ B₂)","decl":"@[to_additive]\nlemma MapsTo.div [DivisionCommMonoid β] {A : Set α} {B₁ B₂ : Set β} {f₁ f₂ : α → β}\n    (h₁ : MapsTo f₁ A B₁) (h₂ : MapsTo f₂ A B₂) : MapsTo (f₁ / f₂) A (B₁ / B₂) :=\n  fun _ ha => div_mem_div (h₁ ha) (h₂ ha)\n\n"}
