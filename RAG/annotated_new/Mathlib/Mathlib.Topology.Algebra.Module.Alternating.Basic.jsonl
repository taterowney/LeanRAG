{"name":"ContinuousAlternatingMap.map_eq_zero_of_eq'","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nι : Type u_4\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : TopologicalSpace N\nself : ContinuousAlternatingMap R M N ι\nv : ι → M\ni j : ι\na✝¹ : Eq (v i) (v j)\na✝ : Ne i j\n⊢ Eq (self.toFun v) 0","decl":"/-- A continuous alternating map from `ι → M` to `N`, denoted `M [⋀^ι]→L[R] N`,\nis a continuous map that is\n\n- multilinear : `f (update m i (c • x)) = c • f (update m i x)` and\n  `f (update m i (x + y)) = f (update m i x) + f (update m i y)`;\n- alternating : `f v = 0` whenever `v` has two equal coordinates.\n-/\nstructure ContinuousAlternatingMap (R M N ι : Type*) [Semiring R] [AddCommMonoid M] [Module R M]\n    [TopologicalSpace M] [AddCommMonoid N] [Module R N] [TopologicalSpace N] extends\n    ContinuousMultilinearMap R (fun _ : ι => M) N, M [⋀^ι]→ₗ[R] N where\n\n"}
{"name":"ContinuousAlternatingMap.mk.inj","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nι : Type u_4\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : TopologicalSpace N\ntoContinuousMultilinearMap✝ : ContinuousMultilinearMap R (fun x => M) N\nmap_eq_zero_of_eq'✝ : ∀ (v : ι → M) (i j : ι), Eq (v i) (v j) → Ne i j → Eq (toContinuousMultilinearMap✝.toFun v) 0\ntoContinuousMultilinearMap : ContinuousMultilinearMap R (fun x => M) N\nmap_eq_zero_of_eq' : ∀ (v : ι → M) (i j : ι), Eq (v i) (v j) → Ne i j → Eq (toContinuousMultilinearMap.toFun v) 0\nx✝ : Eq { toContinuousMultilinearMap := toContinuousMultilinearMap✝, map_eq_zero_of_eq' := map_eq_zero_of_eq'✝ } { toContinuousMultilinearMap := toContinuousMultilinearMap, map_eq_zero_of_eq' := map_eq_zero_of_eq' }\n⊢ Eq toContinuousMultilinearMap✝ toContinuousMultilinearMap","decl":"/-- A continuous alternating map from `ι → M` to `N`, denoted `M [⋀^ι]→L[R] N`,\nis a continuous map that is\n\n- multilinear : `f (update m i (c • x)) = c • f (update m i x)` and\n  `f (update m i (x + y)) = f (update m i x) + f (update m i y)`;\n- alternating : `f v = 0` whenever `v` has two equal coordinates.\n-/\nstructure ContinuousAlternatingMap (R M N ι : Type*) [Semiring R] [AddCommMonoid M] [Module R M]\n    [TopologicalSpace M] [AddCommMonoid N] [Module R N] [TopologicalSpace N] extends\n    ContinuousMultilinearMap R (fun _ : ι => M) N, M [⋀^ι]→ₗ[R] N where\n\n"}
{"name":"ContinuousAlternatingMap.mk.injEq","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nι : Type u_4\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : TopologicalSpace N\ntoContinuousMultilinearMap✝ : ContinuousMultilinearMap R (fun x => M) N\nmap_eq_zero_of_eq'✝ : ∀ (v : ι → M) (i j : ι), Eq (v i) (v j) → Ne i j → Eq (toContinuousMultilinearMap✝.toFun v) 0\ntoContinuousMultilinearMap : ContinuousMultilinearMap R (fun x => M) N\nmap_eq_zero_of_eq' : ∀ (v : ι → M) (i j : ι), Eq (v i) (v j) → Ne i j → Eq (toContinuousMultilinearMap.toFun v) 0\n⊢ Eq (Eq { toContinuousMultilinearMap := toContinuousMultilinearMap✝, map_eq_zero_of_eq' := map_eq_zero_of_eq'✝ } { toContinuousMultilinearMap := toContinuousMultilinearMap, map_eq_zero_of_eq' := map_eq_zero_of_eq' }) (Eq toContinuousMultilinearMap✝ toContinuousMultilinearMap)","decl":"/-- A continuous alternating map from `ι → M` to `N`, denoted `M [⋀^ι]→L[R] N`,\nis a continuous map that is\n\n- multilinear : `f (update m i (c • x)) = c • f (update m i x)` and\n  `f (update m i (x + y)) = f (update m i x) + f (update m i y)`;\n- alternating : `f v = 0` whenever `v` has two equal coordinates.\n-/\nstructure ContinuousAlternatingMap (R M N ι : Type*) [Semiring R] [AddCommMonoid M] [Module R M]\n    [TopologicalSpace M] [AddCommMonoid N] [Module R N] [TopologicalSpace N] extends\n    ContinuousMultilinearMap R (fun _ : ι => M) N, M [⋀^ι]→ₗ[R] N where\n\n"}
{"name":"ContinuousAlternatingMap.mk.sizeOf_spec","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nι : Type u_4\ninst✝¹⁰ : Semiring R\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\ninst✝⁷ : TopologicalSpace M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : Module R N\ninst✝⁴ : TopologicalSpace N\ninst✝³ : SizeOf R\ninst✝² : SizeOf M\ninst✝¹ : SizeOf N\ninst✝ : SizeOf ι\ntoContinuousMultilinearMap : ContinuousMultilinearMap R (fun x => M) N\nmap_eq_zero_of_eq' : ∀ (v : ι → M) (i j : ι), Eq (v i) (v j) → Ne i j → Eq (toContinuousMultilinearMap.toFun v) 0\n⊢ Eq (SizeOf.sizeOf { toContinuousMultilinearMap := toContinuousMultilinearMap, map_eq_zero_of_eq' := map_eq_zero_of_eq' }) (HAdd.hAdd 1 (SizeOf.sizeOf toContinuousMultilinearMap))","decl":"/-- A continuous alternating map from `ι → M` to `N`, denoted `M [⋀^ι]→L[R] N`,\nis a continuous map that is\n\n- multilinear : `f (update m i (c • x)) = c • f (update m i x)` and\n  `f (update m i (x + y)) = f (update m i x) + f (update m i y)`;\n- alternating : `f v = 0` whenever `v` has two equal coordinates.\n-/\nstructure ContinuousAlternatingMap (R M N ι : Type*) [Semiring R] [AddCommMonoid M] [Module R M]\n    [TopologicalSpace M] [AddCommMonoid N] [Module R N] [TopologicalSpace N] extends\n    ContinuousMultilinearMap R (fun _ : ι => M) N, M [⋀^ι]→ₗ[R] N where\n\n"}
{"name":"ContinuousAlternatingMap.toContinuousMultilinearMap_injective","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : TopologicalSpace N\n⊢ Function.Injective ContinuousAlternatingMap.toContinuousMultilinearMap","decl":"theorem toContinuousMultilinearMap_injective :\n    Injective (ContinuousAlternatingMap.toContinuousMultilinearMap :\n      M [⋀^ι]→L[R] N → ContinuousMultilinearMap R (fun _ : ι => M) N)\n  | ⟨_, _⟩, ⟨_, _⟩, rfl => rfl\n\n"}
{"name":"ContinuousAlternatingMap.range_toContinuousMultilinearMap","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : TopologicalSpace N\n⊢ Eq (Set.range ContinuousAlternatingMap.toContinuousMultilinearMap) (setOf fun f => ∀ (v : ι → M) (i j : ι), Eq (v i) (v j) → Ne i j → Eq (f v) 0)","decl":"theorem range_toContinuousMultilinearMap :\n    Set.range\n        (toContinuousMultilinearMap :\n          M [⋀^ι]→L[R] N → ContinuousMultilinearMap R (fun _ : ι => M) N) =\n      {f | ∀ (v : ι → M) (i j : ι), v i = v j → i ≠ j → f v = 0} :=\n  Set.ext fun f => ⟨fun ⟨g, hg⟩ => hg ▸ g.2, fun h => ⟨⟨f, h⟩, rfl⟩⟩\n\n"}
{"name":"ContinuousAlternatingMap.continuousMapClass","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : TopologicalSpace N\n⊢ ContinuousMapClass (ContinuousAlternatingMap R M N ι) (ι → M) N","decl":"instance continuousMapClass : ContinuousMapClass (M [⋀^ι]→L[R] N) (ι → M) N where\n  map_continuous f := f.cont\n\n"}
{"name":"ContinuousAlternatingMap.coe_continuous","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : TopologicalSpace N\nf : ContinuousAlternatingMap R M N ι\n⊢ Continuous ⇑f","decl":"@[continuity]\ntheorem coe_continuous : Continuous f := f.cont\n\n"}
{"name":"ContinuousAlternatingMap.coe_toContinuousMultilinearMap","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : TopologicalSpace N\nf : ContinuousAlternatingMap R M N ι\n⊢ Eq ⇑f.toContinuousMultilinearMap ⇑f","decl":"@[simp]\ntheorem coe_toContinuousMultilinearMap : ⇑f.toContinuousMultilinearMap = f :=\n  rfl\n\n"}
{"name":"ContinuousAlternatingMap.coe_mk","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : TopologicalSpace N\nf : ContinuousMultilinearMap R (fun x => M) N\nh : ∀ (v : ι → M) (i j : ι), Eq (v i) (v j) → Ne i j → Eq (f.toFun v) 0\n⊢ Eq ⇑{ toContinuousMultilinearMap := f, map_eq_zero_of_eq' := h } ⇑f","decl":"@[simp]\ntheorem coe_mk (f : ContinuousMultilinearMap R (fun _ : ι => M) N) (h) : ⇑(mk f h) = f :=\n  rfl\n\n-- not a `simp` lemma because this projection is a reducible call to `mk`, so `simp` can prove\n-- this lemma\n"}
{"name":"ContinuousAlternatingMap.coe_toAlternatingMap","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : TopologicalSpace N\nf : ContinuousAlternatingMap R M N ι\n⊢ Eq ⇑f.toAlternatingMap ⇑f","decl":"theorem coe_toAlternatingMap : ⇑f.toAlternatingMap = f := rfl\n\n"}
{"name":"ContinuousAlternatingMap.ext_iff","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : TopologicalSpace N\nf g : ContinuousAlternatingMap R M N ι\n⊢ Iff (Eq f g) (∀ (x : ι → M), Eq (f x) (g x))","decl":"@[ext]\ntheorem ext {f g : M [⋀^ι]→L[R] N} (H : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ H\n\n"}
{"name":"ContinuousAlternatingMap.ext","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : TopologicalSpace N\nf g : ContinuousAlternatingMap R M N ι\nH : ∀ (x : ι → M), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {f g : M [⋀^ι]→L[R] N} (H : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ H\n\n"}
{"name":"ContinuousAlternatingMap.toAlternatingMap_injective","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : TopologicalSpace N\n⊢ Function.Injective ContinuousAlternatingMap.toAlternatingMap","decl":"theorem toAlternatingMap_injective :\n    Injective (toAlternatingMap : (M [⋀^ι]→L[R] N) → (M [⋀^ι]→ₗ[R] N)) := fun f g h =>\n  DFunLike.ext' <| by convert DFunLike.ext'_iff.1 h\n\n"}
{"name":"ContinuousAlternatingMap.range_toAlternatingMap","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : TopologicalSpace N\n⊢ Eq (Set.range ContinuousAlternatingMap.toAlternatingMap) (setOf fun f => Continuous ⇑f)","decl":"@[simp]\ntheorem range_toAlternatingMap :\n    Set.range (toAlternatingMap : M [⋀^ι]→L[R] N → (M [⋀^ι]→ₗ[R] N)) =\n      {f : M [⋀^ι]→ₗ[R] N | Continuous f} :=\n  Set.ext fun f => ⟨fun ⟨g, hg⟩ => hg ▸ g.cont, fun h => ⟨{ f with cont := h }, DFunLike.ext' rfl⟩⟩\n\n"}
{"name":"ContinuousAlternatingMap.map_update_add","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : TopologicalSpace N\nf : ContinuousAlternatingMap R M N ι\ninst✝ : DecidableEq ι\nm : ι → M\ni : ι\nx y : M\n⊢ Eq (f (Function.update m i (HAdd.hAdd x y))) (HAdd.hAdd (f (Function.update m i x)) (f (Function.update m i y)))","decl":"@[simp]\ntheorem map_update_add [DecidableEq ι] (m : ι → M) (i : ι) (x y : M) :\n    f (update m i (x + y)) = f (update m i x) + f (update m i y) :=\n  f.map_update_add' m i x y\n\n"}
{"name":"ContinuousAlternatingMap.map_add","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : TopologicalSpace N\nf : ContinuousAlternatingMap R M N ι\ninst✝ : DecidableEq ι\nm : ι → M\ni : ι\nx y : M\n⊢ Eq (f (Function.update m i (HAdd.hAdd x y))) (HAdd.hAdd (f (Function.update m i x)) (f (Function.update m i y)))","decl":"@[deprecated (since := \"2024-11-03\")] protected alias map_add := map_update_add\n\n"}
{"name":"ContinuousAlternatingMap.map_update_smul","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : TopologicalSpace N\nf : ContinuousAlternatingMap R M N ι\ninst✝ : DecidableEq ι\nm : ι → M\ni : ι\nc : R\nx : M\n⊢ Eq (f (Function.update m i (HSMul.hSMul c x))) (HSMul.hSMul c (f (Function.update m i x)))","decl":"@[simp]\ntheorem map_update_smul [DecidableEq ι] (m : ι → M) (i : ι) (c : R) (x : M) :\n    f (update m i (c • x)) = c • f (update m i x) :=\n  f.map_update_smul' m i c x\n\n"}
{"name":"ContinuousAlternatingMap.map_smul","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : TopologicalSpace N\nf : ContinuousAlternatingMap R M N ι\ninst✝ : DecidableEq ι\nm : ι → M\ni : ι\nc : R\nx : M\n⊢ Eq (f (Function.update m i (HSMul.hSMul c x))) (HSMul.hSMul c (f (Function.update m i x)))","decl":"@[deprecated (since := \"2024-11-03\")] protected alias map_smul := map_update_smul\n\n"}
{"name":"ContinuousAlternatingMap.map_coord_zero","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : TopologicalSpace N\nf : ContinuousAlternatingMap R M N ι\nm : ι → M\ni : ι\nh : Eq (m i) 0\n⊢ Eq (f m) 0","decl":"theorem map_coord_zero {m : ι → M} (i : ι) (h : m i = 0) : f m = 0 :=\n  f.toMultilinearMap.map_coord_zero i h\n\n"}
{"name":"ContinuousAlternatingMap.map_update_zero","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : TopologicalSpace N\nf : ContinuousAlternatingMap R M N ι\ninst✝ : DecidableEq ι\nm : ι → M\ni : ι\n⊢ Eq (f (Function.update m i 0)) 0","decl":"@[simp]\ntheorem map_update_zero [DecidableEq ι] (m : ι → M) (i : ι) : f (update m i 0) = 0 :=\n  f.toMultilinearMap.map_update_zero m i\n\n"}
{"name":"ContinuousAlternatingMap.map_zero","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : TopologicalSpace N\nf : ContinuousAlternatingMap R M N ι\ninst✝ : Nonempty ι\n⊢ Eq (f 0) 0","decl":"@[simp]\ntheorem map_zero [Nonempty ι] : f 0 = 0 :=\n  f.toMultilinearMap.map_zero\n\n"}
{"name":"ContinuousAlternatingMap.map_eq_zero_of_eq","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : TopologicalSpace N\nf : ContinuousAlternatingMap R M N ι\nv : ι → M\ni j : ι\nh : Eq (v i) (v j)\nhij : Ne i j\n⊢ Eq (f v) 0","decl":"theorem map_eq_zero_of_eq (v : ι → M) {i j : ι} (h : v i = v j) (hij : i ≠ j) : f v = 0 :=\n  f.map_eq_zero_of_eq' v i j h hij\n\n"}
{"name":"ContinuousAlternatingMap.map_eq_zero_of_not_injective","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : TopologicalSpace N\nf : ContinuousAlternatingMap R M N ι\nv : ι → M\nhv : Not (Function.Injective v)\n⊢ Eq (f v) 0","decl":"theorem map_eq_zero_of_not_injective (v : ι → M) (hv : ¬Function.Injective v) : f v = 0 :=\n  f.toAlternatingMap.map_eq_zero_of_not_injective v hv\n\n"}
{"name":"ContinuousAlternatingMap.codRestrict_apply_coe","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : TopologicalSpace N\nf : ContinuousAlternatingMap R M N ι\np : Submodule R N\nh : ∀ (v : ι → M), Membership.mem p (f v)\nv : (i : ι) → (fun x => M) i\n⊢ Eq (↑((f.codRestrict p h) v)) (f v)","decl":"/-- Restrict the codomain of a continuous alternating map to a submodule. -/\n@[simps!]\ndef codRestrict (f : M [⋀^ι]→L[R] N) (p : Submodule R N) (h : ∀ v, f v ∈ p) : M [⋀^ι]→L[R] p :=\n  { f.toAlternatingMap.codRestrict p h with toContinuousMultilinearMap := f.1.codRestrict p h }\n\n"}
{"name":"ContinuousAlternatingMap.coe_zero","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : TopologicalSpace N\n⊢ Eq (⇑0) 0","decl":"@[simp]\ntheorem coe_zero : ⇑(0 : M [⋀^ι]→L[R] N) = 0 :=\n  rfl\n\n"}
{"name":"ContinuousAlternatingMap.toContinuousMultilinearMap_zero","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : TopologicalSpace N\n⊢ Eq (ContinuousAlternatingMap.toContinuousMultilinearMap 0) 0","decl":"@[simp]\ntheorem toContinuousMultilinearMap_zero : (0 : M [⋀^ι]→L[R] N).toContinuousMultilinearMap = 0 :=\n  rfl\n\n"}
{"name":"ContinuousAlternatingMap.toAlternatingMap_zero","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : TopologicalSpace N\n⊢ Eq (ContinuousAlternatingMap.toAlternatingMap 0) 0","decl":"@[simp]\ntheorem toAlternatingMap_zero : (0 : M [⋀^ι]→L[R] N).toAlternatingMap = 0 :=\n  rfl\n\n"}
{"name":"ContinuousAlternatingMap.coe_smul","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"M : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝¹⁰ : AddCommMonoid M\ninst✝⁹ : TopologicalSpace M\ninst✝⁸ : AddCommMonoid N\ninst✝⁷ : TopologicalSpace N\nR' : Type u_7\nA : Type u_9\ninst✝⁶ : Monoid R'\ninst✝⁵ : Semiring A\ninst✝⁴ : Module A M\ninst✝³ : Module A N\ninst✝² : DistribMulAction R' N\ninst✝¹ : ContinuousConstSMul R' N\ninst✝ : SMulCommClass A R' N\nf : ContinuousAlternatingMap A M N ι\nc : R'\n⊢ Eq (⇑(HSMul.hSMul c f)) (HSMul.hSMul c ⇑f)","decl":"@[simp]\ntheorem coe_smul (f : M [⋀^ι]→L[A] N) (c : R') : ⇑(c • f) = c • ⇑f :=\n  rfl\n\n"}
{"name":"ContinuousAlternatingMap.smul_apply","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"M : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝¹⁰ : AddCommMonoid M\ninst✝⁹ : TopologicalSpace M\ninst✝⁸ : AddCommMonoid N\ninst✝⁷ : TopologicalSpace N\nR' : Type u_7\nA : Type u_9\ninst✝⁶ : Monoid R'\ninst✝⁵ : Semiring A\ninst✝⁴ : Module A M\ninst✝³ : Module A N\ninst✝² : DistribMulAction R' N\ninst✝¹ : ContinuousConstSMul R' N\ninst✝ : SMulCommClass A R' N\nf : ContinuousAlternatingMap A M N ι\nc : R'\nv : ι → M\n⊢ Eq ((HSMul.hSMul c f) v) (HSMul.hSMul c (f v))","decl":"theorem smul_apply (f : M [⋀^ι]→L[A] N) (c : R') (v : ι → M) : (c • f) v = c • f v :=\n  rfl\n\n"}
{"name":"ContinuousAlternatingMap.toContinuousMultilinearMap_smul","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"M : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝¹⁰ : AddCommMonoid M\ninst✝⁹ : TopologicalSpace M\ninst✝⁸ : AddCommMonoid N\ninst✝⁷ : TopologicalSpace N\nR' : Type u_7\nA : Type u_9\ninst✝⁶ : Monoid R'\ninst✝⁵ : Semiring A\ninst✝⁴ : Module A M\ninst✝³ : Module A N\ninst✝² : DistribMulAction R' N\ninst✝¹ : ContinuousConstSMul R' N\ninst✝ : SMulCommClass A R' N\nc : R'\nf : ContinuousAlternatingMap A M N ι\n⊢ Eq (HSMul.hSMul c f).toContinuousMultilinearMap (HSMul.hSMul c f.toContinuousMultilinearMap)","decl":"@[simp]\ntheorem toContinuousMultilinearMap_smul (c : R') (f : M [⋀^ι]→L[A] N) :\n    (c • f).toContinuousMultilinearMap = c • f.toContinuousMultilinearMap :=\n  rfl\n\n"}
{"name":"ContinuousAlternatingMap.toAlternatingMap_smul","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"M : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝¹⁰ : AddCommMonoid M\ninst✝⁹ : TopologicalSpace M\ninst✝⁸ : AddCommMonoid N\ninst✝⁷ : TopologicalSpace N\nR' : Type u_7\nA : Type u_9\ninst✝⁶ : Monoid R'\ninst✝⁵ : Semiring A\ninst✝⁴ : Module A M\ninst✝³ : Module A N\ninst✝² : DistribMulAction R' N\ninst✝¹ : ContinuousConstSMul R' N\ninst✝ : SMulCommClass A R' N\nc : R'\nf : ContinuousAlternatingMap A M N ι\n⊢ Eq (HSMul.hSMul c f).toAlternatingMap (HSMul.hSMul c f.toAlternatingMap)","decl":"@[simp]\ntheorem toAlternatingMap_smul (c : R') (f : M [⋀^ι]→L[A] N) :\n    (c • f).toAlternatingMap = c • f.toAlternatingMap :=\n  rfl\n\n"}
{"name":"ContinuousAlternatingMap.instSMulCommClass","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"M : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝¹⁵ : AddCommMonoid M\ninst✝¹⁴ : TopologicalSpace M\ninst✝¹³ : AddCommMonoid N\ninst✝¹² : TopologicalSpace N\nR' : Type u_7\nR'' : Type u_8\nA : Type u_9\ninst✝¹¹ : Monoid R'\ninst✝¹⁰ : Monoid R''\ninst✝⁹ : Semiring A\ninst✝⁸ : Module A M\ninst✝⁷ : Module A N\ninst✝⁶ : DistribMulAction R' N\ninst✝⁵ : ContinuousConstSMul R' N\ninst✝⁴ : SMulCommClass A R' N\ninst✝³ : DistribMulAction R'' N\ninst✝² : ContinuousConstSMul R'' N\ninst✝¹ : SMulCommClass A R'' N\ninst✝ : SMulCommClass R' R'' N\n⊢ SMulCommClass R' R'' (ContinuousAlternatingMap A M N ι)","decl":"instance [SMulCommClass R' R'' N] : SMulCommClass R' R'' (M [⋀^ι]→L[A] N) :=\n  ⟨fun _ _ _ => ext fun _ => smul_comm _ _ _⟩\n\n"}
{"name":"ContinuousAlternatingMap.instIsScalarTower","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"M : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝¹⁶ : AddCommMonoid M\ninst✝¹⁵ : TopologicalSpace M\ninst✝¹⁴ : AddCommMonoid N\ninst✝¹³ : TopologicalSpace N\nR' : Type u_7\nR'' : Type u_8\nA : Type u_9\ninst✝¹² : Monoid R'\ninst✝¹¹ : Monoid R''\ninst✝¹⁰ : Semiring A\ninst✝⁹ : Module A M\ninst✝⁸ : Module A N\ninst✝⁷ : DistribMulAction R' N\ninst✝⁶ : ContinuousConstSMul R' N\ninst✝⁵ : SMulCommClass A R' N\ninst✝⁴ : DistribMulAction R'' N\ninst✝³ : ContinuousConstSMul R'' N\ninst✝² : SMulCommClass A R'' N\ninst✝¹ : SMul R' R''\ninst✝ : IsScalarTower R' R'' N\n⊢ IsScalarTower R' R'' (ContinuousAlternatingMap A M N ι)","decl":"instance [SMul R' R''] [IsScalarTower R' R'' N] : IsScalarTower R' R'' (M [⋀^ι]→L[A] N) :=\n  ⟨fun _ _ _ => ext fun _ => smul_assoc _ _ _⟩\n\n"}
{"name":"ContinuousAlternatingMap.instIsCentralScalar","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"M : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝¹² : AddCommMonoid M\ninst✝¹¹ : TopologicalSpace M\ninst✝¹⁰ : AddCommMonoid N\ninst✝⁹ : TopologicalSpace N\nR' : Type u_7\nA : Type u_9\ninst✝⁸ : Monoid R'\ninst✝⁷ : Semiring A\ninst✝⁶ : Module A M\ninst✝⁵ : Module A N\ninst✝⁴ : DistribMulAction R' N\ninst✝³ : ContinuousConstSMul R' N\ninst✝² : SMulCommClass A R' N\ninst✝¹ : DistribMulAction (MulOpposite R') N\ninst✝ : IsCentralScalar R' N\n⊢ IsCentralScalar R' (ContinuousAlternatingMap A M N ι)","decl":"instance [DistribMulAction R'ᵐᵒᵖ N] [IsCentralScalar R' N] : IsCentralScalar R' (M [⋀^ι]→L[A] N) :=\n  ⟨fun _ _ => ext fun _ => op_smul_eq_smul _ _⟩\n\n"}
{"name":"ContinuousAlternatingMap.coe_add","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : TopologicalSpace N\nf g : ContinuousAlternatingMap R M N ι\ninst✝ : ContinuousAdd N\n⊢ Eq (⇑(HAdd.hAdd f g)) (HAdd.hAdd ⇑f ⇑g)","decl":"@[simp]\ntheorem coe_add : ⇑(f + g) = ⇑f + ⇑g :=\n  rfl\n\n"}
{"name":"ContinuousAlternatingMap.add_apply","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : TopologicalSpace N\nf g : ContinuousAlternatingMap R M N ι\ninst✝ : ContinuousAdd N\nv : ι → M\n⊢ Eq ((HAdd.hAdd f g) v) (HAdd.hAdd (f v) (g v))","decl":"@[simp]\ntheorem add_apply (v : ι → M) : (f + g) v = f v + g v :=\n  rfl\n\n"}
{"name":"ContinuousAlternatingMap.toContinuousMultilinearMap_add","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : TopologicalSpace N\ninst✝ : ContinuousAdd N\nf g : ContinuousAlternatingMap R M N ι\n⊢ Eq (HAdd.hAdd f g).toContinuousMultilinearMap (HAdd.hAdd f.toContinuousMultilinearMap g.toContinuousMultilinearMap)","decl":"@[simp]\ntheorem toContinuousMultilinearMap_add (f g : M [⋀^ι]→L[R] N) : (f + g).1 = f.1 + g.1 :=\n  rfl\n\n"}
{"name":"ContinuousAlternatingMap.toAlternatingMap_add","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : TopologicalSpace N\ninst✝ : ContinuousAdd N\nf g : ContinuousAlternatingMap R M N ι\n⊢ Eq (HAdd.hAdd f g).toAlternatingMap (HAdd.hAdd f.toAlternatingMap g.toAlternatingMap)","decl":"@[simp]\ntheorem toAlternatingMap_add (f g : M [⋀^ι]→L[R] N) :\n    (f + g).toAlternatingMap = f.toAlternatingMap + g.toAlternatingMap :=\n  rfl\n\n"}
{"name":"ContinuousAlternatingMap.sum_apply","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : TopologicalSpace N\ninst✝ : ContinuousAdd N\nα : Type u_7\nf : α → ContinuousAlternatingMap R M N ι\nm : ι → M\ns : Finset α\n⊢ Eq ((s.sum fun a => f a) m) (s.sum fun a => (f a) m)","decl":"@[simp]\ntheorem sum_apply {α : Type*} (f : α → M [⋀^ι]→L[R] N) (m : ι → M) {s : Finset α} :\n    (∑ a ∈ s, f a) m = ∑ a ∈ s, f a m :=\n  map_sum (applyAddHom m) f s\n\n"}
{"name":"ContinuousAlternatingMap.toMultilinearAddHom_apply","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : TopologicalSpace N\ninst✝ : ContinuousAdd N\nf : ContinuousAlternatingMap R M N ι\n⊢ Eq (ContinuousAlternatingMap.toMultilinearAddHom f) f.toContinuousMultilinearMap","decl":"/-- Projection to `ContinuousMultilinearMap`s as a bundled `AddMonoidHom`. -/\n@[simps]\ndef toMultilinearAddHom : M [⋀^ι]→L[R] N →+ ContinuousMultilinearMap R (fun _ : ι => M) N :=\n  ⟨⟨fun f => f.1, rfl⟩, fun _ _ => rfl⟩\n\n"}
{"name":"ContinuousAlternatingMap.toContinuousLinearMap_apply","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : TopologicalSpace N\nf : ContinuousAlternatingMap R M N ι\ninst✝ : DecidableEq ι\nm : ι → M\ni : ι\nx : M\n⊢ Eq ((f.toContinuousLinearMap m i) x) (f (Function.update m i x))","decl":"/-- If `f` is a continuous alternating map, then `f.toContinuousLinearMap m i` is the continuous\nlinear map obtained by fixing all coordinates but `i` equal to those of `m`, and varying the\n`i`-th coordinate. -/\n@[simps! apply]\ndef toContinuousLinearMap [DecidableEq ι] (m : ι → M) (i : ι) : M →L[R] N :=\n  f.1.toContinuousLinearMap m i\n\n"}
{"name":"ContinuousAlternatingMap.prod_apply","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nN' : Type u_5\nι : Type u_6\ninst✝⁹ : Semiring R\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : Module R M\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R N\ninst✝³ : TopologicalSpace N\ninst✝² : AddCommMonoid N'\ninst✝¹ : Module R N'\ninst✝ : TopologicalSpace N'\nf : ContinuousAlternatingMap R M N ι\ng : ContinuousAlternatingMap R M N' ι\nm : (i : ι) → (fun x => M) i\n⊢ Eq ((f.prod g) m) { fst := f m, snd := g m }","decl":"/-- The cartesian product of two continuous alternating maps, as a continuous alternating map. -/\n@[simps!]\ndef prod (f : M [⋀^ι]→L[R] N) (g : M [⋀^ι]→L[R] N') : M [⋀^ι]→L[R] (N × N') :=\n  ⟨f.1.prod g.1, (f.toAlternatingMap.prod g.toAlternatingMap).map_eq_zero_of_eq⟩\n\n"}
{"name":"ContinuousAlternatingMap.coe_pi","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nι : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace M\nι' : Type u_7\nM' : ι' → Type u_8\ninst✝² : (i : ι') → AddCommMonoid (M' i)\ninst✝¹ : (i : ι') → TopologicalSpace (M' i)\ninst✝ : (i : ι') → Module R (M' i)\nf : (i : ι') → ContinuousAlternatingMap R M (M' i) ι\n⊢ Eq ⇑(ContinuousAlternatingMap.pi f) fun m j => (f j) m","decl":"@[simp]\ntheorem coe_pi {ι' : Type*} {M' : ι' → Type*} [∀ i, AddCommMonoid (M' i)]\n    [∀ i, TopologicalSpace (M' i)] [∀ i, Module R (M' i)] (f : ∀ i, M [⋀^ι]→L[R] M' i) :\n    ⇑(pi f) = fun m j => f j m :=\n  rfl\n\n"}
{"name":"ContinuousAlternatingMap.pi_apply","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nι : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace M\nι' : Type u_7\nM' : ι' → Type u_8\ninst✝² : (i : ι') → AddCommMonoid (M' i)\ninst✝¹ : (i : ι') → TopologicalSpace (M' i)\ninst✝ : (i : ι') → Module R (M' i)\nf : (i : ι') → ContinuousAlternatingMap R M (M' i) ι\nm : ι → M\nj : ι'\n⊢ Eq ((ContinuousAlternatingMap.pi f) m j) ((f j) m)","decl":"theorem pi_apply {ι' : Type*} {M' : ι' → Type*} [∀ i, AddCommMonoid (M' i)]\n    [∀ i, TopologicalSpace (M' i)] [∀ i, Module R (M' i)] (f : ∀ i, M [⋀^ι]→L[R] M' i) (m : ι → M)\n    (j : ι') : pi f m j = f j m :=\n  rfl\n\n"}
{"name":"ContinuousAlternatingMap.ofSubsingleton_apply_toContinuousMultilinearMap","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : TopologicalSpace N\ninst✝ : Subsingleton ι\ni : ι\nf : ContinuousLinearMap (RingHom.id R) M N\n⊢ Eq ((ContinuousAlternatingMap.ofSubsingleton R M N i) f).toContinuousMultilinearMap ((ContinuousMultilinearMap.ofSubsingleton R M N i) f)","decl":"/-- The natural equivalence between continuous linear maps from `M` to `N`\nand continuous 1-multilinear alternating maps from `M` to `N`. -/\n@[simps! apply_apply symm_apply_apply apply_toContinuousMultilinearMap]\ndef ofSubsingleton [Subsingleton ι] (i : ι) :\n    (M →L[R] N) ≃ M [⋀^ι]→L[R] N where\n  toFun f :=\n    { AlternatingMap.ofSubsingleton R M N i f with\n      toContinuousMultilinearMap := ContinuousMultilinearMap.ofSubsingleton R M N i f }\n  invFun f := (ContinuousMultilinearMap.ofSubsingleton R M N i).symm f.1\n  left_inv _ := rfl\n  right_inv _ := toContinuousMultilinearMap_injective <|\n    (ContinuousMultilinearMap.ofSubsingleton R M N i).apply_symm_apply _\n\n"}
{"name":"ContinuousAlternatingMap.ofSubsingleton_apply_apply","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : TopologicalSpace N\ninst✝ : Subsingleton ι\ni : ι\nf : ContinuousLinearMap (RingHom.id R) M N\nx : ι → M\n⊢ Eq (((ContinuousAlternatingMap.ofSubsingleton R M N i) f) x) (f (x i))","decl":"/-- The natural equivalence between continuous linear maps from `M` to `N`\nand continuous 1-multilinear alternating maps from `M` to `N`. -/\n@[simps! apply_apply symm_apply_apply apply_toContinuousMultilinearMap]\ndef ofSubsingleton [Subsingleton ι] (i : ι) :\n    (M →L[R] N) ≃ M [⋀^ι]→L[R] N where\n  toFun f :=\n    { AlternatingMap.ofSubsingleton R M N i f with\n      toContinuousMultilinearMap := ContinuousMultilinearMap.ofSubsingleton R M N i f }\n  invFun f := (ContinuousMultilinearMap.ofSubsingleton R M N i).symm f.1\n  left_inv _ := rfl\n  right_inv _ := toContinuousMultilinearMap_injective <|\n    (ContinuousMultilinearMap.ofSubsingleton R M N i).apply_symm_apply _\n\n"}
{"name":"ContinuousAlternatingMap.ofSubsingleton_symm_apply_apply","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : TopologicalSpace N\ninst✝ : Subsingleton ι\ni : ι\nf : ContinuousAlternatingMap R M N ι\nx : M\n⊢ Eq (((ContinuousAlternatingMap.ofSubsingleton R M N i).symm f) x) (f fun x_1 => x)","decl":"/-- The natural equivalence between continuous linear maps from `M` to `N`\nand continuous 1-multilinear alternating maps from `M` to `N`. -/\n@[simps! apply_apply symm_apply_apply apply_toContinuousMultilinearMap]\ndef ofSubsingleton [Subsingleton ι] (i : ι) :\n    (M →L[R] N) ≃ M [⋀^ι]→L[R] N where\n  toFun f :=\n    { AlternatingMap.ofSubsingleton R M N i f with\n      toContinuousMultilinearMap := ContinuousMultilinearMap.ofSubsingleton R M N i f }\n  invFun f := (ContinuousMultilinearMap.ofSubsingleton R M N i).symm f.1\n  left_inv _ := rfl\n  right_inv _ := toContinuousMultilinearMap_injective <|\n    (ContinuousMultilinearMap.ofSubsingleton R M N i).apply_symm_apply _\n\n"}
{"name":"ContinuousAlternatingMap.ofSubsingleton_toAlternatingMap","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : TopologicalSpace N\ninst✝ : Subsingleton ι\ni : ι\nf : ContinuousLinearMap (RingHom.id R) M N\n⊢ Eq ((ContinuousAlternatingMap.ofSubsingleton R M N i) f).toAlternatingMap ((AlternatingMap.ofSubsingleton R M N i) ↑f)","decl":"@[simp]\ntheorem ofSubsingleton_toAlternatingMap [Subsingleton ι] (i : ι) (f : M →L[R] N) :\n    (ofSubsingleton R M N i f).toAlternatingMap = AlternatingMap.ofSubsingleton R M N i f :=\n  rfl\n\n"}
{"name":"ContinuousAlternatingMap.constOfIsEmpty_apply","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : TopologicalSpace N\ninst✝ : IsEmpty ι\nm : N\na✝ : (i : ι) → (fun x => M) i\n⊢ Eq ((ContinuousAlternatingMap.constOfIsEmpty R M ι m) a✝) m","decl":"/-- The constant map is alternating when `ι` is empty. -/\n@[simps! toContinuousMultilinearMap apply]\ndef constOfIsEmpty [IsEmpty ι] (m : N) : M [⋀^ι]→L[R] N :=\n  { AlternatingMap.constOfIsEmpty R M ι m with\n    toContinuousMultilinearMap := ContinuousMultilinearMap.constOfIsEmpty R (fun _ => M) m }\n\n"}
{"name":"ContinuousAlternatingMap.constOfIsEmpty_toContinuousMultilinearMap","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : TopologicalSpace N\ninst✝ : IsEmpty ι\nm : N\n⊢ Eq (ContinuousAlternatingMap.constOfIsEmpty R M ι m).toContinuousMultilinearMap (ContinuousMultilinearMap.constOfIsEmpty R (fun x => M) m)","decl":"/-- The constant map is alternating when `ι` is empty. -/\n@[simps! toContinuousMultilinearMap apply]\ndef constOfIsEmpty [IsEmpty ι] (m : N) : M [⋀^ι]→L[R] N :=\n  { AlternatingMap.constOfIsEmpty R M ι m with\n    toContinuousMultilinearMap := ContinuousMultilinearMap.constOfIsEmpty R (fun _ => M) m }\n\n"}
{"name":"ContinuousAlternatingMap.constOfIsEmpty_toAlternatingMap","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : TopologicalSpace N\ninst✝ : IsEmpty ι\nm : N\n⊢ Eq (ContinuousAlternatingMap.constOfIsEmpty R M ι m).toAlternatingMap (AlternatingMap.constOfIsEmpty R M ι m)","decl":"@[simp]\ntheorem constOfIsEmpty_toAlternatingMap [IsEmpty ι] (m : N) :\n    (constOfIsEmpty R M ι m).toAlternatingMap = AlternatingMap.constOfIsEmpty R M ι m :=\n  rfl\n\n"}
{"name":"ContinuousAlternatingMap.compContinuousLinearMap_apply","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nM' : Type u_3\nN : Type u_4\nι : Type u_6\ninst✝⁹ : Semiring R\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : Module R M\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : AddCommMonoid M'\ninst✝⁴ : Module R M'\ninst✝³ : TopologicalSpace M'\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : TopologicalSpace N\ng : ContinuousAlternatingMap R M N ι\nf : ContinuousLinearMap (RingHom.id R) M' M\nm : ι → M'\n⊢ Eq ((g.compContinuousLinearMap f) m) (g (Function.comp (⇑f) m))","decl":"@[simp]\ntheorem compContinuousLinearMap_apply (g : M [⋀^ι]→L[R] N) (f : M' →L[R] M) (m : ι → M') :\n    g.compContinuousLinearMap f m = g (f ∘ m) :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.compContinuousAlternatingMap_coe","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nN' : Type u_5\nι : Type u_6\ninst✝⁹ : Semiring R\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : Module R M\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R N\ninst✝³ : TopologicalSpace N\ninst✝² : AddCommMonoid N'\ninst✝¹ : Module R N'\ninst✝ : TopologicalSpace N'\ng : ContinuousLinearMap (RingHom.id R) N N'\nf : ContinuousAlternatingMap R M N ι\n⊢ Eq (⇑(g.compContinuousAlternatingMap f)) (Function.comp ⇑g ⇑f)","decl":"@[simp]\ntheorem _root_.ContinuousLinearMap.compContinuousAlternatingMap_coe (g : N →L[R] N')\n    (f : M [⋀^ι]→L[R] N) : ⇑(g.compContinuousAlternatingMap f) = g ∘ f :=\n  rfl\n\n"}
{"name":"ContinuousLinearEquiv.compContinuousAlternatingMap_coe","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nN' : Type u_5\nι : Type u_6\ninst✝⁹ : Semiring R\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : Module R M\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R N\ninst✝³ : TopologicalSpace N\ninst✝² : AddCommMonoid N'\ninst✝¹ : Module R N'\ninst✝ : TopologicalSpace N'\ne : ContinuousLinearEquiv (RingHom.id R) N N'\nf : ContinuousAlternatingMap R M N ι\n⊢ Eq (⇑(e.compContinuousAlternatingMap f)) (Function.comp ⇑e ⇑f)","decl":"@[simp]\ntheorem _root_.ContinuousLinearEquiv.compContinuousAlternatingMap_coe\n    (e : N ≃L[R] N') (f : M [⋀^ι]→L[R] N) : ⇑(e.compContinuousAlternatingMap f) = e ∘ f :=\n  rfl\n\n"}
{"name":"ContinuousAlternatingMap.piEquiv_symm_apply","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nι : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace M\nι' : Type u_7\nN : ι' → Type u_8\ninst✝² : (i : ι') → AddCommMonoid (N i)\ninst✝¹ : (i : ι') → TopologicalSpace (N i)\ninst✝ : (i : ι') → Module R (N i)\nf : ContinuousAlternatingMap R M ((i : ι') → N i) ι\ni : ι'\n⊢ Eq (ContinuousAlternatingMap.piEquiv.symm f i) ((ContinuousLinearMap.proj i).compContinuousAlternatingMap f)","decl":"/-- `ContinuousAlternatingMap.pi` as an `Equiv`. -/\n@[simps]\ndef piEquiv {ι' : Type*} {N : ι' → Type*} [∀ i, AddCommMonoid (N i)] [∀ i, TopologicalSpace (N i)]\n    [∀ i, Module R (N i)] : (∀ i, M [⋀^ι]→L[R] N i) ≃ M [⋀^ι]→L[R] ∀ i, N i where\n  toFun := pi\n  invFun f i := (ContinuousLinearMap.proj i : _ →L[R] N i).compContinuousAlternatingMap f\n  left_inv f := by ext; rfl\n  right_inv f := by ext; rfl\n\n"}
{"name":"ContinuousAlternatingMap.piEquiv_apply","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nι : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace M\nι' : Type u_7\nN : ι' → Type u_8\ninst✝² : (i : ι') → AddCommMonoid (N i)\ninst✝¹ : (i : ι') → TopologicalSpace (N i)\ninst✝ : (i : ι') → Module R (N i)\nf : (i : ι') → ContinuousAlternatingMap R M (N i) ι\n⊢ Eq (ContinuousAlternatingMap.piEquiv f) (ContinuousAlternatingMap.pi f)","decl":"/-- `ContinuousAlternatingMap.pi` as an `Equiv`. -/\n@[simps]\ndef piEquiv {ι' : Type*} {N : ι' → Type*} [∀ i, AddCommMonoid (N i)] [∀ i, TopologicalSpace (N i)]\n    [∀ i, Module R (N i)] : (∀ i, M [⋀^ι]→L[R] N i) ≃ M [⋀^ι]→L[R] ∀ i, N i where\n  toFun := pi\n  invFun f i := (ContinuousLinearMap.proj i : _ →L[R] N i).compContinuousAlternatingMap f\n  left_inv f := by ext; rfl\n  right_inv f := by ext; rfl\n\n"}
{"name":"ContinuousAlternatingMap.cons_add","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : TopologicalSpace N\nn : Nat\nf : ContinuousAlternatingMap R M N (Fin (HAdd.hAdd n 1))\nm : Fin n → M\nx y : M\n⊢ Eq (f (Fin.cons (HAdd.hAdd x y) m)) (HAdd.hAdd (f (Fin.cons x m)) (f (Fin.cons y m)))","decl":"/-- In the specific case of continuous alternating maps on spaces indexed by `Fin (n+1)`, where one\ncan build an element of `Π(i : Fin (n+1)), M i` using `cons`, one can express directly the\nadditivity of an alternating map along the first variable. -/\ntheorem cons_add (f : ContinuousAlternatingMap R M N (Fin (n + 1))) (m : Fin n → M) (x y : M) :\n    f (Fin.cons (x + y) m) = f (Fin.cons x m) + f (Fin.cons y m) :=\n  f.toMultilinearMap.cons_add m x y\n\n"}
{"name":"ContinuousAlternatingMap.vecCons_add","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : TopologicalSpace N\nn : Nat\nf : ContinuousAlternatingMap R M N (Fin (HAdd.hAdd n 1))\nm : Fin n → M\nx y : M\n⊢ Eq (f (Matrix.vecCons (HAdd.hAdd x y) m)) (HAdd.hAdd (f (Matrix.vecCons x m)) (f (Matrix.vecCons y m)))","decl":"/-- In the specific case of continuous alternating maps on spaces indexed by `Fin (n+1)`, where one\ncan build an element of `Π(i : Fin (n+1)), M i` using `cons`, one can express directly the\nadditivity of an alternating map along the first variable. -/\ntheorem vecCons_add (f : ContinuousAlternatingMap R M N (Fin (n + 1))) (m : Fin n → M) (x y : M) :\n    f (vecCons (x + y) m) = f (vecCons x m) + f (vecCons y m) :=\n  f.toMultilinearMap.cons_add m x y\n\n"}
{"name":"ContinuousAlternatingMap.cons_smul","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : TopologicalSpace N\nn : Nat\nf : ContinuousAlternatingMap R M N (Fin (HAdd.hAdd n 1))\nm : Fin n → M\nc : R\nx : M\n⊢ Eq (f (Fin.cons (HSMul.hSMul c x) m)) (HSMul.hSMul c (f (Fin.cons x m)))","decl":"/-- In the specific case of continuous alternating maps on spaces indexed by `Fin (n+1)`, where one\ncan build an element of `Π(i : Fin (n+1)), M i` using `cons`, one can express directly the\nmultiplicativity of an alternating map along the first variable. -/\ntheorem cons_smul (f : ContinuousAlternatingMap R M N (Fin (n + 1))) (m : Fin n → M) (c : R)\n    (x : M) : f (Fin.cons (c • x) m) = c • f (Fin.cons x m) :=\n  f.toMultilinearMap.cons_smul m c x\n\n"}
{"name":"ContinuousAlternatingMap.vecCons_smul","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : TopologicalSpace N\nn : Nat\nf : ContinuousAlternatingMap R M N (Fin (HAdd.hAdd n 1))\nm : Fin n → M\nc : R\nx : M\n⊢ Eq (f (Matrix.vecCons (HSMul.hSMul c x) m)) (HSMul.hSMul c (f (Matrix.vecCons x m)))","decl":"/-- In the specific case of continuous alternating maps on spaces indexed by `Fin (n+1)`, where one\ncan build an element of `Π(i : Fin (n+1)), M i` using `cons`, one can express directly the\nmultiplicativity of an alternating map along the first variable. -/\ntheorem vecCons_smul (f : ContinuousAlternatingMap R M N (Fin (n + 1))) (m : Fin n → M) (c : R)\n    (x : M) : f (vecCons (c • x) m) = c • f (vecCons x m) :=\n  f.toMultilinearMap.cons_smul m c x\n\n"}
{"name":"ContinuousAlternatingMap.map_piecewise_add","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : TopologicalSpace N\nf : ContinuousAlternatingMap R M N ι\ninst✝ : DecidableEq ι\nm m' : ι → M\nt : Finset ι\n⊢ Eq (f (t.piecewise (HAdd.hAdd m m') m')) (t.powerset.sum fun s => f (s.piecewise m m'))","decl":"theorem map_piecewise_add [DecidableEq ι] (m m' : ι → M) (t : Finset ι) :\n    f (t.piecewise (m + m') m') = ∑ s ∈ t.powerset, f (s.piecewise m m') :=\n  f.toMultilinearMap.map_piecewise_add _ _ _\n\n"}
{"name":"ContinuousAlternatingMap.map_add_univ","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R N\ninst✝² : TopologicalSpace N\nf : ContinuousAlternatingMap R M N ι\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nm m' : ι → M\n⊢ Eq (f (HAdd.hAdd m m')) (Finset.univ.sum fun s => f (s.piecewise m m'))","decl":"/-- Additivity of a continuous alternating map along all coordinates at the same time,\nwriting `f (m + m')` as the sum of `f (s.piecewise m m')` over all sets `s`. -/\ntheorem map_add_univ [DecidableEq ι] [Fintype ι] (m m' : ι → M) :\n    f (m + m') = ∑ s : Finset ι, f (s.piecewise m m') :=\n  f.toMultilinearMap.map_add_univ _ _\n\n"}
{"name":"ContinuousAlternatingMap.map_sum_finset","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R N\ninst✝² : TopologicalSpace N\nf : ContinuousAlternatingMap R M N ι\nα : ι → Type u_7\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\ng' : (i : ι) → α i → M\nA : (i : ι) → Finset (α i)\n⊢ Eq (f fun i => (A i).sum fun j => g' i j) ((Fintype.piFinset A).sum fun r => f fun i => g' i (r i))","decl":"/-- If `f` is continuous alternating, then `f (Σ_{j₁ ∈ A₁} g₁ j₁, ..., Σ_{jₙ ∈ Aₙ} gₙ jₙ)` is the\nsum of `f (g₁ (r 1), ..., gₙ (r n))` where `r` ranges over all functions with `r 1 ∈ A₁`, ...,\n`r n ∈ Aₙ`. This follows from multilinearity by expanding successively with respect to each\ncoordinate. -/\ntheorem map_sum_finset :\n    (f fun i => ∑ j ∈ A i, g' i j) = ∑ r ∈ piFinset A, f fun i => g' i (r i) :=\n  f.toMultilinearMap.map_sum_finset _ _\n\n"}
{"name":"ContinuousAlternatingMap.map_sum","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝⁹ : Semiring R\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : Module R M\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R N\ninst✝³ : TopologicalSpace N\nf : ContinuousAlternatingMap R M N ι\nα : ι → Type u_7\ninst✝² : Fintype ι\ninst✝¹ : DecidableEq ι\ng' : (i : ι) → α i → M\ninst✝ : (i : ι) → Fintype (α i)\n⊢ Eq (f fun i => Finset.univ.sum fun j => g' i j) (Finset.univ.sum fun r => f fun i => g' i (r i))","decl":"/-- If `f` is continuous alternating, then `f (Σ_{j₁} g₁ j₁, ..., Σ_{jₙ} gₙ jₙ)` is the sum of\n`f (g₁ (r 1), ..., gₙ (r n))` where `r` ranges over all functions `r`. This follows from\nmultilinearity by expanding successively with respect to each coordinate. -/\ntheorem map_sum [∀ i, Fintype (α i)] :\n    (f fun i => ∑ j, g' i j) = ∑ r : ∀ i, α i, f fun i => g' i (r i) :=\n  f.toMultilinearMap.map_sum _\n\n"}
{"name":"ContinuousAlternatingMap.coe_restrictScalars","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nι : Type u_6\ninst✝¹² : Semiring R\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : Module R M\ninst✝⁹ : TopologicalSpace M\ninst✝⁸ : AddCommMonoid N\ninst✝⁷ : Module R N\ninst✝⁶ : TopologicalSpace N\nA : Type u_7\ninst✝⁵ : Semiring A\ninst✝⁴ : SMul R A\ninst✝³ : Module A M\ninst✝² : Module A N\ninst✝¹ : IsScalarTower R A M\ninst✝ : IsScalarTower R A N\nf : ContinuousAlternatingMap A M N ι\n⊢ Eq ⇑(ContinuousAlternatingMap.restrictScalars R f) ⇑f","decl":"@[simp]\ntheorem coe_restrictScalars (f : M [⋀^ι]→L[A] N) : ⇑(f.restrictScalars R) = f :=\n  rfl\n\n"}
{"name":"ContinuousAlternatingMap.map_update_sub","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nι : Type u_4\ninst✝⁷ : Ring R\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : TopologicalSpace N\nf : ContinuousAlternatingMap R M N ι\ninst✝ : DecidableEq ι\nm : ι → M\ni : ι\nx y : M\n⊢ Eq (f (Function.update m i (HSub.hSub x y))) (HSub.hSub (f (Function.update m i x)) (f (Function.update m i y)))","decl":"@[simp]\ntheorem map_update_sub [DecidableEq ι] (m : ι → M) (i : ι) (x y : M) :\n    f (update m i (x - y)) = f (update m i x) - f (update m i y) :=\n  f.toMultilinearMap.map_update_sub _ _ _ _\n\n"}
{"name":"ContinuousAlternatingMap.map_sub","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nι : Type u_4\ninst✝⁷ : Ring R\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : TopologicalSpace N\nf : ContinuousAlternatingMap R M N ι\ninst✝ : DecidableEq ι\nm : ι → M\ni : ι\nx y : M\n⊢ Eq (f (Function.update m i (HSub.hSub x y))) (HSub.hSub (f (Function.update m i x)) (f (Function.update m i y)))","decl":"@[deprecated (since := \"2024-11-03\")] protected alias map_sub := map_update_sub\n\n"}
{"name":"ContinuousAlternatingMap.coe_neg","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nι : Type u_4\ninst✝⁷ : Ring R\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : TopologicalSpace N\nf : ContinuousAlternatingMap R M N ι\ninst✝ : TopologicalAddGroup N\n⊢ Eq (⇑(Neg.neg f)) (Neg.neg ⇑f)","decl":"@[simp]\ntheorem coe_neg : ⇑(-f) = -f :=\n  rfl\n\n"}
{"name":"ContinuousAlternatingMap.neg_apply","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nι : Type u_4\ninst✝⁷ : Ring R\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : TopologicalSpace N\nf : ContinuousAlternatingMap R M N ι\ninst✝ : TopologicalAddGroup N\nm : ι → M\n⊢ Eq ((Neg.neg f) m) (Neg.neg (f m))","decl":"theorem neg_apply (m : ι → M) : (-f) m = -f m :=\n  rfl\n\n"}
{"name":"ContinuousAlternatingMap.coe_sub","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nι : Type u_4\ninst✝⁷ : Ring R\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : TopologicalSpace N\nf g : ContinuousAlternatingMap R M N ι\ninst✝ : TopologicalAddGroup N\n⊢ Eq (⇑(HSub.hSub f g)) (HSub.hSub ⇑f ⇑g)","decl":"@[simp] theorem coe_sub : ⇑(f - g) = ⇑f - ⇑g := rfl\n\n"}
{"name":"ContinuousAlternatingMap.sub_apply","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nι : Type u_4\ninst✝⁷ : Ring R\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : TopologicalSpace N\nf g : ContinuousAlternatingMap R M N ι\ninst✝ : TopologicalAddGroup N\nm : ι → M\n⊢ Eq ((HSub.hSub f g) m) (HSub.hSub (f m) (g m))","decl":"theorem sub_apply (m : ι → M) : (f - g) m = f m - g m := rfl\n\n"}
{"name":"ContinuousAlternatingMap.map_piecewise_smul","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nι : Type u_4\ninst✝⁷ : CommSemiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : TopologicalSpace N\nf : ContinuousAlternatingMap R M N ι\ninst✝ : DecidableEq ι\nc : ι → R\nm : ι → M\ns : Finset ι\n⊢ Eq (f (s.piecewise (fun i => HSMul.hSMul (c i) (m i)) m)) (HSMul.hSMul (s.prod fun i => c i) (f m))","decl":"theorem map_piecewise_smul [DecidableEq ι] (c : ι → R) (m : ι → M) (s : Finset ι) :\n    f (s.piecewise (fun i => c i • m i) m) = (∏ i ∈ s, c i) • f m :=\n  f.toMultilinearMap.map_piecewise_smul _ _ _\n\n"}
{"name":"ContinuousAlternatingMap.map_smul_univ","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nι : Type u_4\ninst✝⁷ : CommSemiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : TopologicalSpace M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : TopologicalSpace N\nf : ContinuousAlternatingMap R M N ι\ninst✝ : Fintype ι\nc : ι → R\nm : ι → M\n⊢ Eq (f fun i => HSMul.hSMul (c i) (m i)) (HSMul.hSMul (Finset.univ.prod fun i => c i) (f m))","decl":"/-- Multiplicativity of a continuous alternating map along all coordinates at the same time,\nwriting `f (fun i ↦ c i • m i)` as `(∏ i, c i) • f m`. -/\ntheorem map_smul_univ [Fintype ι] (c : ι → R) (m : ι → M) :\n    (f fun i => c i • m i) = (∏ i, c i) • f m :=\n  f.toMultilinearMap.map_smul_univ _ _\n\n"}
{"name":"ContinuousAlternatingMap.toContinuousMultilinearMapLinear_apply","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_3\nN : Type u_4\nι : Type u_5\ninst✝¹¹ : Semiring R\ninst✝¹⁰ : Semiring A\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid N\ninst✝⁷ : TopologicalSpace M\ninst✝⁶ : TopologicalSpace N\ninst✝⁵ : ContinuousAdd N\ninst✝⁴ : Module A M\ninst✝³ : Module A N\ninst✝² : Module R N\ninst✝¹ : ContinuousConstSMul R N\ninst✝ : SMulCommClass A R N\nself : ContinuousAlternatingMap A M N ι\n⊢ Eq (ContinuousAlternatingMap.toContinuousMultilinearMapLinear self) self.toContinuousMultilinearMap","decl":"/-- Linear map version of the map `toMultilinearMap` associating to a continuous alternating map\nthe corresponding multilinear map. -/\n@[simps]\ndef toContinuousMultilinearMapLinear :\n    M [⋀^ι]→L[A] N →ₗ[R] ContinuousMultilinearMap A (fun _ : ι => M) N where\n  toFun := toContinuousMultilinearMap\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n\n"}
{"name":"ContinuousAlternatingMap.toAlternatingMapLinear_apply","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_3\nN : Type u_4\nι : Type u_5\ninst✝¹¹ : Semiring R\ninst✝¹⁰ : Semiring A\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid N\ninst✝⁷ : TopologicalSpace M\ninst✝⁶ : TopologicalSpace N\ninst✝⁵ : ContinuousAdd N\ninst✝⁴ : Module A M\ninst✝³ : Module A N\ninst✝² : Module R N\ninst✝¹ : ContinuousConstSMul R N\ninst✝ : SMulCommClass A R N\n⊢ Eq (⇑ContinuousAlternatingMap.toAlternatingMapLinear) ContinuousAlternatingMap.toAlternatingMap","decl":"/-- Linear map version of the map `toAlternatingMap`\nassociating to a continuous alternating map the corresponding alternating map. -/\n@[simps (config := .asFn) apply]\ndef toAlternatingMapLinear : (M [⋀^ι]→L[A] N) →ₗ[R] (M [⋀^ι]→ₗ[A] N) where\n  toFun := toAlternatingMap\n  map_add' := by simp\n  map_smul' := by simp\n\n"}
{"name":"ContinuousAlternatingMap.piLinearEquiv_apply","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_3\nι : Type u_5\ninst✝¹¹ : Semiring R\ninst✝¹⁰ : Semiring A\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : TopologicalSpace M\ninst✝⁷ : Module A M\nι' : Type u_6\nM' : ι' → Type u_7\ninst✝⁶ : (i : ι') → AddCommMonoid (M' i)\ninst✝⁵ : (i : ι') → TopologicalSpace (M' i)\ninst✝⁴ : ∀ (i : ι'), ContinuousAdd (M' i)\ninst✝³ : (i : ι') → Module R (M' i)\ninst✝² : (i : ι') → Module A (M' i)\ninst✝¹ : ∀ (i : ι'), SMulCommClass A R (M' i)\ninst✝ : ∀ (i : ι'), ContinuousConstSMul R (M' i)\na✝ : (i : ι') → ContinuousAlternatingMap A M (M' i) ι\n⊢ Eq (ContinuousAlternatingMap.piLinearEquiv a✝) (ContinuousAlternatingMap.pi a✝)","decl":"/-- `ContinuousAlternatingMap.pi` as a `LinearEquiv`. -/\n@[simps (config := { simpRhs := true })]\ndef piLinearEquiv {ι' : Type*} {M' : ι' → Type*} [∀ i, AddCommMonoid (M' i)]\n    [∀ i, TopologicalSpace (M' i)] [∀ i, ContinuousAdd (M' i)] [∀ i, Module R (M' i)]\n    [∀ i, Module A (M' i)] [∀ i, SMulCommClass A R (M' i)] [∀ i, ContinuousConstSMul R (M' i)] :\n    (∀ i, M [⋀^ι]→L[A] M' i) ≃ₗ[R] M [⋀^ι]→L[A] ∀ i, M' i :=\n  { piEquiv with\n    map_add' := fun _ _ => rfl\n    map_smul' := fun _ _ => rfl }\n\n"}
{"name":"ContinuousAlternatingMap.piLinearEquiv_symm_apply","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_3\nι : Type u_5\ninst✝¹¹ : Semiring R\ninst✝¹⁰ : Semiring A\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : TopologicalSpace M\ninst✝⁷ : Module A M\nι' : Type u_6\nM' : ι' → Type u_7\ninst✝⁶ : (i : ι') → AddCommMonoid (M' i)\ninst✝⁵ : (i : ι') → TopologicalSpace (M' i)\ninst✝⁴ : ∀ (i : ι'), ContinuousAdd (M' i)\ninst✝³ : (i : ι') → Module R (M' i)\ninst✝² : (i : ι') → Module A (M' i)\ninst✝¹ : ∀ (i : ι'), SMulCommClass A R (M' i)\ninst✝ : ∀ (i : ι'), ContinuousConstSMul R (M' i)\na✝ : ContinuousAlternatingMap A M ((i : ι') → M' i) ι\ni : ι'\n⊢ Eq (ContinuousAlternatingMap.piLinearEquiv.symm a✝ i) ((ContinuousLinearMap.proj i).compContinuousAlternatingMap a✝)","decl":"/-- `ContinuousAlternatingMap.pi` as a `LinearEquiv`. -/\n@[simps (config := { simpRhs := true })]\ndef piLinearEquiv {ι' : Type*} {M' : ι' → Type*} [∀ i, AddCommMonoid (M' i)]\n    [∀ i, TopologicalSpace (M' i)] [∀ i, ContinuousAdd (M' i)] [∀ i, Module R (M' i)]\n    [∀ i, Module A (M' i)] [∀ i, SMulCommClass A R (M' i)] [∀ i, ContinuousConstSMul R (M' i)] :\n    (∀ i, M [⋀^ι]→L[A] M' i) ≃ₗ[R] M [⋀^ι]→L[A] ∀ i, M' i :=\n  { piEquiv with\n    map_add' := fun _ _ => rfl\n    map_smul' := fun _ _ => rfl }\n\n"}
{"name":"ContinuousAlternatingMap.smulRight_toContinuousMultilinearMap","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nι : Type u_4\ninst✝⁸ : CommSemiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : Module R M\ninst✝⁴ : Module R N\ninst✝³ : TopologicalSpace R\ninst✝² : TopologicalSpace M\ninst✝¹ : TopologicalSpace N\ninst✝ : ContinuousSMul R N\nf : ContinuousAlternatingMap R M R ι\nz : N\n⊢ Eq (f.smulRight z).toContinuousMultilinearMap (f.smulRight z)","decl":"/-- Given a continuous `R`-alternating map `f` taking values in `R`, `f.smulRight z` is the\ncontinuous alternating map sending `m` to `f m • z`. -/\n@[simps! toContinuousMultilinearMap apply]\ndef smulRight : M [⋀^ι]→L[R] N :=\n  { f.toAlternatingMap.smulRight z with toContinuousMultilinearMap := f.1.smulRight z }\n\n"}
{"name":"ContinuousAlternatingMap.smulRight_apply","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nι : Type u_4\ninst✝⁸ : CommSemiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : Module R M\ninst✝⁴ : Module R N\ninst✝³ : TopologicalSpace R\ninst✝² : TopologicalSpace M\ninst✝¹ : TopologicalSpace N\ninst✝ : ContinuousSMul R N\nf : ContinuousAlternatingMap R M R ι\nz : N\na✝ : (i : ι) → (fun x => M) i\n⊢ Eq ((f.smulRight z) a✝) (HSMul.hSMul (f a✝) z)","decl":"/-- Given a continuous `R`-alternating map `f` taking values in `R`, `f.smulRight z` is the\ncontinuous alternating map sending `m` to `f m • z`. -/\n@[simps! toContinuousMultilinearMap apply]\ndef smulRight : M [⋀^ι]→L[R] N :=\n  { f.toAlternatingMap.smulRight z with toContinuousMultilinearMap := f.1.smulRight z }\n\n"}
{"name":"ContinuousAlternatingMap.compContinuousLinearMapₗ_apply","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nM' : Type u_3\nN : Type u_4\nι : Type u_6\ninst✝¹¹ : CommSemiring R\ninst✝¹⁰ : AddCommMonoid M\ninst✝⁹ : Module R M\ninst✝⁸ : TopologicalSpace M\ninst✝⁷ : AddCommMonoid M'\ninst✝⁶ : Module R M'\ninst✝⁵ : TopologicalSpace M'\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R N\ninst✝² : TopologicalSpace N\ninst✝¹ : ContinuousAdd N\ninst✝ : ContinuousConstSMul R N\nf : ContinuousLinearMap (RingHom.id R) M M'\ng : ContinuousAlternatingMap R M' N ι\n⊢ Eq ((ContinuousAlternatingMap.compContinuousLinearMapₗ f) g) (g.compContinuousLinearMap f)","decl":"/-- `ContinuousAlternatingMap.compContinuousLinearMap` as a bundled `LinearMap`. -/\n@[simps]\ndef compContinuousLinearMapₗ (f : M →L[R] M') : (M' [⋀^ι]→L[R] N) →ₗ[R] (M [⋀^ι]→L[R] N) where\n  toFun g := g.compContinuousLinearMap f\n  map_add' g g' := by ext; simp\n  map_smul' c g := by ext; simp\n\n"}
{"name":"ContinuousMultilinearMap.alternatization_apply_toContinuousMultilinearMap","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nι : Type u_4\ninst✝⁹ : Semiring R\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : Module R M\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\ninst✝³ : TopologicalSpace N\ninst✝² : TopologicalAddGroup N\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nf : ContinuousMultilinearMap R (fun x => M) N\n⊢ Eq (ContinuousMultilinearMap.alternatization f).toContinuousMultilinearMap (Finset.univ.sum fun σ => HSMul.hSMul (Equiv.Perm.sign σ) (ContinuousMultilinearMap.domDomCongr σ f))","decl":"/-- Alternatization of a continuous multilinear map. -/\n@[simps (config := .lemmasOnly) apply_toContinuousMultilinearMap]\ndef alternatization : ContinuousMultilinearMap R (fun _ : ι => M) N →+ M [⋀^ι]→L[R] N where\n  toFun f :=\n    { toContinuousMultilinearMap := ∑ σ : Equiv.Perm ι, Equiv.Perm.sign σ • f.domDomCongr σ\n      map_eq_zero_of_eq' := fun v i j hv hne => by\n        simpa [MultilinearMap.alternatization_apply]\n          using f.1.alternatization.map_eq_zero_of_eq' v i j hv hne }\n  map_zero' := by ext; simp\n  map_add' _ _ := by ext; simp [Finset.sum_add_distrib]\n\n"}
{"name":"ContinuousMultilinearMap.alternatization_apply_apply","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nι : Type u_4\ninst✝⁹ : Semiring R\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : Module R M\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\ninst✝³ : TopologicalSpace N\ninst✝² : TopologicalAddGroup N\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nf : ContinuousMultilinearMap R (fun x => M) N\nv : ι → M\n⊢ Eq ((ContinuousMultilinearMap.alternatization f) v) (Finset.univ.sum fun σ => HSMul.hSMul (Equiv.Perm.sign σ) (f (Function.comp v ⇑σ)))","decl":"theorem alternatization_apply_apply (v : ι → M) :\n    alternatization f v = ∑ σ : Equiv.Perm ι, Equiv.Perm.sign σ • f (v ∘ σ) := by\n  simp [alternatization, Function.comp_def]\n\n"}
{"name":"ContinuousMultilinearMap.alternatization_apply_toAlternatingMap","module":"Mathlib.Topology.Algebra.Module.Alternating.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nι : Type u_4\ninst✝⁹ : Semiring R\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : Module R M\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\ninst✝³ : TopologicalSpace N\ninst✝² : TopologicalAddGroup N\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nf : ContinuousMultilinearMap R (fun x => M) N\n⊢ Eq (ContinuousMultilinearMap.alternatization f).toAlternatingMap (MultilinearMap.alternatization f.toMultilinearMap)","decl":"@[simp]\ntheorem alternatization_apply_toAlternatingMap :\n    (alternatization f).toAlternatingMap = MultilinearMap.alternatization f.1 := by\n  ext v\n  simp [alternatization_apply_apply, MultilinearMap.alternatization_apply, Function.comp_def]\n\n"}
