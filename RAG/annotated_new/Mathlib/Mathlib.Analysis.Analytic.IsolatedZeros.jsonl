{"name":"HasSum.hasSum_at_zero","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\na : Nat → E\n⊢ HasSum (fun n => HSMul.hSMul (HPow.hPow 0 n) (a n)) (a 0)","decl":"theorem hasSum_at_zero (a : ℕ → E) : HasSum (fun n => (0 : 𝕜) ^ n • a n) (a 0) := by\n  convert hasSum_single (α := E) 0 fun b h ↦ _ <;> simp [*]\n\n"}
{"name":"HasSum.exists_hasSum_smul_of_apply_eq_zero","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\ns : E\nn : Nat\nz : 𝕜\na : Nat → E\nhs : HasSum (fun m => HSMul.hSMul (HPow.hPow z m) (a m)) s\nha : ∀ (k : Nat), LT.lt k n → Eq (a k) 0\n⊢ Exists fun t => And (Eq (HSMul.hSMul (HPow.hPow z n) t) s) (HasSum (fun m => HSMul.hSMul (HPow.hPow z m) (a (HAdd.hAdd m n))) t)","decl":"theorem exists_hasSum_smul_of_apply_eq_zero (hs : HasSum (fun m => z ^ m • a m) s)\n    (ha : ∀ k < n, a k = 0) : ∃ t : E, z ^ n • t = s ∧ HasSum (fun m => z ^ m • a (m + n)) t := by\n  obtain rfl | hn := n.eq_zero_or_pos\n  · simpa\n  by_cases h : z = 0\n  · have : s = 0 := hs.unique (by simpa [ha 0 hn, h] using hasSum_at_zero a)\n    exact ⟨a n, by simp [h, hn.ne', this], by simpa [h] using hasSum_at_zero fun m => a (m + n)⟩\n  · refine ⟨(z ^ n)⁻¹ • s, by field_simp [smul_smul], ?_⟩\n    have h1 : ∑ i ∈ Finset.range n, z ^ i • a i = 0 :=\n      Finset.sum_eq_zero fun k hk => by simp [ha k (Finset.mem_range.mp hk)]\n    have h2 : HasSum (fun m => z ^ (m + n) • a (m + n)) s := by\n      simpa [h1] using (hasSum_nat_add_iff' n).mpr hs\n    convert h2.const_smul (z⁻¹ ^ n) using 1\n    · field_simp [pow_add, smul_smul]\n    · simp only [inv_pow]\n\n"}
{"name":"HasFPowerSeriesAt.has_fpower_series_dslope_fslope","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\np : FormalMultilinearSeries 𝕜 𝕜 E\nf : 𝕜 → E\nz₀ : 𝕜\nhp : HasFPowerSeriesAt f p z₀\n⊢ HasFPowerSeriesAt (dslope f z₀) p.fslope z₀","decl":"theorem has_fpower_series_dslope_fslope (hp : HasFPowerSeriesAt f p z₀) :\n    HasFPowerSeriesAt (dslope f z₀) p.fslope z₀ := by\n  have hpd : deriv f z₀ = p.coeff 1 := hp.deriv\n  have hp0 : p.coeff 0 = f z₀ := hp.coeff_zero 1\n  simp only [hasFPowerSeriesAt_iff, apply_eq_pow_smul_coeff, coeff_fslope] at hp ⊢\n  refine hp.mono fun x hx => ?_\n  by_cases h : x = 0\n  · convert hasSum_single (α := E) 0 _ <;> intros <;> simp [*]\n  · have hxx : ∀ n : ℕ, x⁻¹ * x ^ (n + 1) = x ^ n := fun n => by field_simp [h, _root_.pow_succ]\n    suffices HasSum (fun n => x⁻¹ • x ^ (n + 1) • p.coeff (n + 1)) (x⁻¹ • (f (z₀ + x) - f z₀)) by\n      simpa [dslope, slope, h, smul_smul, hxx] using this\n    simpa [hp0] using ((hasSum_nat_add_iff' 1).mpr hx).const_smul x⁻¹\n\n"}
{"name":"HasFPowerSeriesAt.has_fpower_series_iterate_dslope_fslope","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\np : FormalMultilinearSeries 𝕜 𝕜 E\nf : 𝕜 → E\nz₀ : 𝕜\nn : Nat\nhp : HasFPowerSeriesAt f p z₀\n⊢ HasFPowerSeriesAt (Nat.iterate (Function.swap dslope z₀) n f) (Nat.iterate FormalMultilinearSeries.fslope n p) z₀","decl":"theorem has_fpower_series_iterate_dslope_fslope (n : ℕ) (hp : HasFPowerSeriesAt f p z₀) :\n    HasFPowerSeriesAt ((swap dslope z₀)^[n] f) (fslope^[n] p) z₀ := by\n  induction n generalizing f p with\n  | zero => exact hp\n  | succ n ih => simpa using ih (has_fpower_series_dslope_fslope hp)\n\n"}
{"name":"HasFPowerSeriesAt.iterate_dslope_fslope_ne_zero","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\np : FormalMultilinearSeries 𝕜 𝕜 E\nf : 𝕜 → E\nz₀ : 𝕜\nhp : HasFPowerSeriesAt f p z₀\nh : Ne p 0\n⊢ Ne (Nat.iterate (Function.swap dslope z₀) p.order f z₀) 0","decl":"theorem iterate_dslope_fslope_ne_zero (hp : HasFPowerSeriesAt f p z₀) (h : p ≠ 0) :\n    (swap dslope z₀)^[p.order] f z₀ ≠ 0 := by\n  rw [← coeff_zero (has_fpower_series_iterate_dslope_fslope p.order hp) 1]\n  simpa [coeff_eq_zero] using apply_order_ne_zero h\n\n"}
{"name":"HasFPowerSeriesAt.eq_pow_order_mul_iterate_dslope","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\np : FormalMultilinearSeries 𝕜 𝕜 E\nf : 𝕜 → E\nz₀ : 𝕜\nhp : HasFPowerSeriesAt f p z₀\n⊢ Filter.Eventually (fun z => Eq (f z) (HSMul.hSMul (HPow.hPow (HSub.hSub z z₀) p.order) (Nat.iterate (Function.swap dslope z₀) p.order f z))) (nhds z₀)","decl":"theorem eq_pow_order_mul_iterate_dslope (hp : HasFPowerSeriesAt f p z₀) :\n    ∀ᶠ z in 𝓝 z₀, f z = (z - z₀) ^ p.order • (swap dslope z₀)^[p.order] f z := by\n  have hq := hasFPowerSeriesAt_iff'.mp (has_fpower_series_iterate_dslope_fslope p.order hp)\n  filter_upwards [hq, hasFPowerSeriesAt_iff'.mp hp] with x hx1 hx2\n  have : ∀ k < p.order, p.coeff k = 0 := fun k hk => by\n    simpa [coeff_eq_zero] using apply_eq_zero_of_lt_order hk\n  obtain ⟨s, hs1, hs2⟩ := HasSum.exists_hasSum_smul_of_apply_eq_zero hx2 this\n  convert hs1.symm\n  simp only [coeff_iterate_fslope] at hx1\n  exact hx1.unique hs2\n\n"}
{"name":"HasFPowerSeriesAt.locally_ne_zero","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\np : FormalMultilinearSeries 𝕜 𝕜 E\nf : 𝕜 → E\nz₀ : 𝕜\nhp : HasFPowerSeriesAt f p z₀\nh : Ne p 0\n⊢ Filter.Eventually (fun z => Ne (f z) 0) (nhdsWithin z₀ (HasCompl.compl (Singleton.singleton z₀)))","decl":"theorem locally_ne_zero (hp : HasFPowerSeriesAt f p z₀) (h : p ≠ 0) : ∀ᶠ z in 𝓝[≠] z₀, f z ≠ 0 := by\n  rw [eventually_nhdsWithin_iff]\n  have h2 := (has_fpower_series_iterate_dslope_fslope p.order hp).continuousAt\n  have h3 := h2.eventually_ne (iterate_dslope_fslope_ne_zero hp h)\n  filter_upwards [eq_pow_order_mul_iterate_dslope hp, h3] with z e1 e2 e3\n  simpa [e1, e2, e3] using pow_ne_zero p.order (sub_ne_zero.mpr e3)\n\n"}
{"name":"HasFPowerSeriesAt.locally_zero_iff","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\np : FormalMultilinearSeries 𝕜 𝕜 E\nf : 𝕜 → E\nz₀ : 𝕜\nhp : HasFPowerSeriesAt f p z₀\n⊢ Iff (Filter.Eventually (fun z => Eq (f z) 0) (nhds z₀)) (Eq p 0)","decl":"theorem locally_zero_iff (hp : HasFPowerSeriesAt f p z₀) : (∀ᶠ z in 𝓝 z₀, f z = 0) ↔ p = 0 :=\n  ⟨fun hf => hp.eq_zero_of_eventually hf, fun h => eventually_eq_zero (𝕜 := 𝕜) (by rwa [h] at hp)⟩\n\n"}
{"name":"AnalyticAt.eventually_eq_zero_or_eventually_ne_zero","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → E\nz₀ : 𝕜\nhf : AnalyticAt 𝕜 f z₀\n⊢ Or (Filter.Eventually (fun z => Eq (f z) 0) (nhds z₀)) (Filter.Eventually (fun z => Ne (f z) 0) (nhdsWithin z₀ (HasCompl.compl (Singleton.singleton z₀))))","decl":"/-- The *principle of isolated zeros* for an analytic function, local version: if a function is\nanalytic at `z₀`, then either it is identically zero in a neighborhood of `z₀`, or it does not\nvanish in a punctured neighborhood of `z₀`. -/\ntheorem eventually_eq_zero_or_eventually_ne_zero (hf : AnalyticAt 𝕜 f z₀) :\n    (∀ᶠ z in 𝓝 z₀, f z = 0) ∨ ∀ᶠ z in 𝓝[≠] z₀, f z ≠ 0 := by\n  rcases hf with ⟨p, hp⟩\n  by_cases h : p = 0\n  · exact Or.inl (HasFPowerSeriesAt.eventually_eq_zero (by rwa [h] at hp))\n  · exact Or.inr (hp.locally_ne_zero h)\n\n"}
{"name":"AnalyticAt.eventually_eq_or_eventually_ne","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf g : 𝕜 → E\nz₀ : 𝕜\nhf : AnalyticAt 𝕜 f z₀\nhg : AnalyticAt 𝕜 g z₀\n⊢ Or (Filter.Eventually (fun z => Eq (f z) (g z)) (nhds z₀)) (Filter.Eventually (fun z => Ne (f z) (g z)) (nhdsWithin z₀ (HasCompl.compl (Singleton.singleton z₀))))","decl":"theorem eventually_eq_or_eventually_ne (hf : AnalyticAt 𝕜 f z₀) (hg : AnalyticAt 𝕜 g z₀) :\n    (∀ᶠ z in 𝓝 z₀, f z = g z) ∨ ∀ᶠ z in 𝓝[≠] z₀, f z ≠ g z := by\n  simpa [sub_eq_zero] using (hf.sub hg).eventually_eq_zero_or_eventually_ne_zero\n\n"}
{"name":"AnalyticAt.frequently_zero_iff_eventually_zero","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → E\nw : 𝕜\nhf : AnalyticAt 𝕜 f w\n⊢ Iff (Filter.Frequently (fun z => Eq (f z) 0) (nhdsWithin w (HasCompl.compl (Singleton.singleton w)))) (Filter.Eventually (fun z => Eq (f z) 0) (nhds w))","decl":"theorem frequently_zero_iff_eventually_zero {f : 𝕜 → E} {w : 𝕜} (hf : AnalyticAt 𝕜 f w) :\n    (∃ᶠ z in 𝓝[≠] w, f z = 0) ↔ ∀ᶠ z in 𝓝 w, f z = 0 :=\n  ⟨hf.eventually_eq_zero_or_eventually_ne_zero.resolve_right, fun h =>\n    (h.filter_mono nhdsWithin_le_nhds).frequently⟩\n\n"}
{"name":"AnalyticAt.frequently_eq_iff_eventually_eq","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf g : 𝕜 → E\nz₀ : 𝕜\nhf : AnalyticAt 𝕜 f z₀\nhg : AnalyticAt 𝕜 g z₀\n⊢ Iff (Filter.Frequently (fun z => Eq (f z) (g z)) (nhdsWithin z₀ (HasCompl.compl (Singleton.singleton z₀)))) (Filter.Eventually (fun z => Eq (f z) (g z)) (nhds z₀))","decl":"theorem frequently_eq_iff_eventually_eq (hf : AnalyticAt 𝕜 f z₀) (hg : AnalyticAt 𝕜 g z₀) :\n    (∃ᶠ z in 𝓝[≠] z₀, f z = g z) ↔ ∀ᶠ z in 𝓝 z₀, f z = g z := by\n  simpa [sub_eq_zero] using frequently_zero_iff_eventually_zero (hf.sub hg)\n\n"}
{"name":"AnalyticAt.unique_eventuallyEq_zpow_smul_nonzero","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → E\nz₀ : 𝕜\nm n : Int\nhm : Exists fun g => And (AnalyticAt 𝕜 g z₀) (And (Ne (g z₀) 0) (Filter.Eventually (fun z => Eq (f z) (HSMul.hSMul (HPow.hPow (HSub.hSub z z₀) m) (g z))) (nhdsWithin z₀ (HasCompl.compl (Singleton.singleton z₀)))))\nhn : Exists fun g => And (AnalyticAt 𝕜 g z₀) (And (Ne (g z₀) 0) (Filter.Eventually (fun z => Eq (f z) (HSMul.hSMul (HPow.hPow (HSub.hSub z z₀) n) (g z))) (nhdsWithin z₀ (HasCompl.compl (Singleton.singleton z₀)))))\n⊢ Eq m n","decl":"/-- For a function `f` on `𝕜`, and `z₀ ∈ 𝕜`, there exists at most one `n` such that on a punctured\nneighbourhood of `z₀` we have `f z = (z - z₀) ^ n • g z`, with `g` analytic and nonvanishing at\n`z₀`. We formulate this with `n : ℤ`, and deduce the case `n : ℕ` later, for applications to\nmeromorphic functions. -/\nlemma unique_eventuallyEq_zpow_smul_nonzero {m n : ℤ}\n    (hm : ∃ g, AnalyticAt 𝕜 g z₀ ∧ g z₀ ≠ 0 ∧ ∀ᶠ z in 𝓝[≠] z₀, f z = (z - z₀) ^ m • g z)\n    (hn : ∃ g, AnalyticAt 𝕜 g z₀ ∧ g z₀ ≠ 0 ∧ ∀ᶠ z in 𝓝[≠] z₀, f z = (z - z₀) ^ n • g z) :\n    m = n := by\n  wlog h_le : n ≤ m generalizing m n\n  · exact ((this hn hm) (not_le.mp h_le).le).symm\n  let ⟨g, hg_an, _, hg_eq⟩ := hm\n  let ⟨j, hj_an, hj_ne, hj_eq⟩ := hn\n  contrapose! hj_ne\n  have : ∃ᶠ z in 𝓝[≠] z₀, j z = (z - z₀) ^ (m - n) • g z := by\n    apply Filter.Eventually.frequently\n    rw [eventually_nhdsWithin_iff] at hg_eq hj_eq ⊢\n    filter_upwards [hg_eq, hj_eq] with z hfz hfz' hz\n    rw [← add_sub_cancel_left n m, add_sub_assoc, zpow_add₀ <| sub_ne_zero.mpr hz, mul_smul,\n      hfz' hz, smul_right_inj <| zpow_ne_zero _ <| sub_ne_zero.mpr hz] at hfz\n    exact hfz hz\n  rw [frequently_eq_iff_eventually_eq hj_an] at this\n  · rw [EventuallyEq.eq_of_nhds this, sub_self, zero_zpow _ (sub_ne_zero.mpr hj_ne), zero_smul]\n  conv => enter [2, z, 1]; rw [← Int.toNat_sub_of_le h_le, zpow_natCast]\n  exact ((analyticAt_id.sub analyticAt_const).pow _).smul hg_an\n\n"}
{"name":"AnalyticAt.unique_eventuallyEq_pow_smul_nonzero","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → E\nz₀ : 𝕜\nm n : Nat\nhm : Exists fun g => And (AnalyticAt 𝕜 g z₀) (And (Ne (g z₀) 0) (Filter.Eventually (fun z => Eq (f z) (HSMul.hSMul (HPow.hPow (HSub.hSub z z₀) m) (g z))) (nhds z₀)))\nhn : Exists fun g => And (AnalyticAt 𝕜 g z₀) (And (Ne (g z₀) 0) (Filter.Eventually (fun z => Eq (f z) (HSMul.hSMul (HPow.hPow (HSub.hSub z z₀) n) (g z))) (nhds z₀)))\n⊢ Eq m n","decl":"/-- For a function `f` on `𝕜`, and `z₀ ∈ 𝕜`, there exists at most one `n` such that on a\nneighbourhood of `z₀` we have `f z = (z - z₀) ^ n • g z`, with `g` analytic and nonvanishing at\n`z₀`. -/\nlemma unique_eventuallyEq_pow_smul_nonzero {m n : ℕ}\n    (hm : ∃ g, AnalyticAt 𝕜 g z₀ ∧ g z₀ ≠ 0 ∧ ∀ᶠ z in 𝓝 z₀, f z = (z - z₀) ^ m • g z)\n    (hn : ∃ g, AnalyticAt 𝕜 g z₀ ∧ g z₀ ≠ 0 ∧ ∀ᶠ z in 𝓝 z₀, f z = (z - z₀) ^ n • g z) :\n    m = n := by\n  simp_rw [← zpow_natCast] at hm hn\n  exact Int.ofNat_inj.mp <| unique_eventuallyEq_zpow_smul_nonzero\n    (let ⟨g, h₁, h₂, h₃⟩ := hm; ⟨g, h₁, h₂, h₃.filter_mono nhdsWithin_le_nhds⟩)\n    (let ⟨g, h₁, h₂, h₃⟩ := hn; ⟨g, h₁, h₂, h₃.filter_mono nhdsWithin_le_nhds⟩)\n\n"}
{"name":"AnalyticAt.exists_eventuallyEq_pow_smul_nonzero_iff","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → E\nz₀ : 𝕜\nhf : AnalyticAt 𝕜 f z₀\n⊢ Iff (Exists fun n => Exists fun g => And (AnalyticAt 𝕜 g z₀) (And (Ne (g z₀) 0) (Filter.Eventually (fun z => Eq (f z) (HSMul.hSMul (HPow.hPow (HSub.hSub z z₀) n) (g z))) (nhds z₀)))) (Not (Filter.Eventually (fun z => Eq (f z) 0) (nhds z₀)))","decl":"/-- If `f` is analytic at `z₀`, then exactly one of the following two possibilities occurs: either\n`f` vanishes identically near `z₀`, or locally around `z₀` it has the form `z ↦ (z - z₀) ^ n • g z`\nfor some `n` and some `g` which is analytic and non-vanishing at `z₀`. -/\ntheorem exists_eventuallyEq_pow_smul_nonzero_iff (hf : AnalyticAt 𝕜 f z₀) :\n    (∃ (n : ℕ), ∃ (g : 𝕜 → E), AnalyticAt 𝕜 g z₀ ∧ g z₀ ≠ 0 ∧\n    ∀ᶠ z in 𝓝 z₀, f z = (z - z₀) ^ n • g z) ↔ (¬∀ᶠ z in 𝓝 z₀, f z = 0) := by\n  constructor\n  · rintro ⟨n, g, hg_an, hg_ne, hg_eq⟩\n    contrapose! hg_ne\n    apply EventuallyEq.eq_of_nhds\n    rw [EventuallyEq, ← AnalyticAt.frequently_eq_iff_eventually_eq hg_an analyticAt_const]\n    refine (eventually_nhdsWithin_iff.mpr ?_).frequently\n    filter_upwards [hg_eq, hg_ne] with z hf_eq hf0 hz\n    rwa [hf0, eq_comm, smul_eq_zero_iff_right] at hf_eq\n    exact pow_ne_zero _ (sub_ne_zero.mpr hz)\n  · intro hf_ne\n    rcases hf with ⟨p, hp⟩\n    exact ⟨p.order, _, ⟨_, hp.has_fpower_series_iterate_dslope_fslope p.order⟩,\n      hp.iterate_dslope_fslope_ne_zero (hf_ne.imp hp.locally_zero_iff.mpr),\n      hp.eq_pow_order_mul_iterate_dslope⟩\n\n"}
{"name":"AnalyticAt.order_eq_top_iff","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → E\nz₀ : 𝕜\nhf : AnalyticAt 𝕜 f z₀\n⊢ Iff (Eq hf.order Top.top) (Filter.Eventually (fun z => Eq (f z) 0) (nhds z₀))","decl":"lemma order_eq_top_iff (hf : AnalyticAt 𝕜 f z₀) : hf.order = ⊤ ↔ ∀ᶠ z in 𝓝 z₀, f z = 0 := by\n  unfold order\n  split_ifs with h\n  · rwa [eq_self, true_iff]\n  · simpa only [ne_eq, ENat.coe_ne_top, false_iff] using h\n\n"}
{"name":"AnalyticAt.order_eq_nat_iff","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → E\nz₀ : 𝕜\nhf : AnalyticAt 𝕜 f z₀\nn : Nat\n⊢ Iff (Eq hf.order ↑n) (Exists fun g => And (AnalyticAt 𝕜 g z₀) (And (Ne (g z₀) 0) (Filter.Eventually (fun z => Eq (f z) (HSMul.hSMul (HPow.hPow (HSub.hSub z z₀) n) (g z))) (nhds z₀))))","decl":"lemma order_eq_nat_iff (hf : AnalyticAt 𝕜 f z₀) (n : ℕ) : hf.order = ↑n ↔\n    ∃ (g : 𝕜 → E), AnalyticAt 𝕜 g z₀ ∧ g z₀ ≠ 0 ∧ ∀ᶠ z in 𝓝 z₀, f z = (z - z₀) ^ n • g z := by\n  unfold order\n  split_ifs with h\n  · simp only [ENat.top_ne_coe, false_iff]\n    contrapose! h\n    rw [← hf.exists_eventuallyEq_pow_smul_nonzero_iff]\n    exact ⟨n, h⟩\n  · rw [← hf.exists_eventuallyEq_pow_smul_nonzero_iff] at h\n    refine ⟨fun hn ↦ (WithTop.coe_inj.mp hn : h.choose = n) ▸ h.choose_spec, fun h' ↦ ?_⟩\n    rw [unique_eventuallyEq_pow_smul_nonzero h.choose_spec h']\n\n/- An analytic function `f` has finite order at a point `z₀` iff it locally looks\n  like `(z - z₀) ^ order • g`, where `g` is analytic and does not vanish at\n  `z₀`. -/\n"}
{"name":"AnalyticAt.order_neq_top_iff","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → E\nz₀ : 𝕜\nhf : AnalyticAt 𝕜 f z₀\n⊢ Iff (Ne hf.order Top.top) (Exists fun g => And (AnalyticAt 𝕜 g z₀) (And (Ne (g z₀) 0) ((nhds z₀).EventuallyEq f fun z => HSMul.hSMul (HPow.hPow (HSub.hSub z z₀) hf.order.toNat) (g z))))","decl":"lemma order_neq_top_iff (hf : AnalyticAt 𝕜 f z₀) :\n    hf.order ≠ ⊤ ↔ ∃ (g : 𝕜 → E), AnalyticAt 𝕜 g z₀ ∧ g z₀ ≠ 0\n      ∧ f =ᶠ[𝓝 z₀] fun z ↦ (z - z₀) ^ (hf.order.toNat) • g z := by\n  simp only [← ENat.coe_toNat_eq_self, Eq.comm, EventuallyEq, ← hf.order_eq_nat_iff]\n\n/- An analytic function has order zero at a point iff it does not vanish there. -/\n"}
{"name":"AnalyticAt.order_eq_zero_iff","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → E\nz₀ : 𝕜\nhf : AnalyticAt 𝕜 f z₀\n⊢ Iff (Eq hf.order 0) (Ne (f z₀) 0)","decl":"lemma order_eq_zero_iff (hf : AnalyticAt 𝕜 f z₀) :\n    hf.order = 0 ↔ f z₀ ≠ 0 := by\n  rw [← ENat.coe_zero, order_eq_nat_iff hf 0]\n  constructor\n  · intro ⟨g, _, _, hg⟩\n    simpa [hg.self_of_nhds]\n  · exact fun hz ↦ ⟨f, hf, hz, by simp⟩\n\n/- An analytic function vanishes at a point if its order is nonzero when converted to ℕ. -/\n"}
{"name":"AnalyticAt.apply_eq_zero_of_order_toNat_ne_zero","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → E\nz₀ : 𝕜\nhf : AnalyticAt 𝕜 f z₀\na✝ : Ne hf.order.toNat 0\n⊢ Eq (f z₀) 0","decl":"lemma apply_eq_zero_of_order_toNat_ne_zero (hf : AnalyticAt 𝕜 f z₀) :\n    hf.order.toNat ≠ 0 → f z₀ = 0 := by\n  simp [hf.order_eq_zero_iff]\n  tauto\n\n/- Helper lemma for `AnalyticAt.order_mul` -/\n"}
{"name":"AnalyticAt.order_mul_of_order_eq_top","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\nz₀ : 𝕜\nf g : 𝕜 → 𝕜\nhf : AnalyticAt 𝕜 f z₀\nhg : AnalyticAt 𝕜 g z₀\nh'f : Eq hf.order Top.top\n⊢ Eq ⋯.order Top.top","decl":"lemma order_mul_of_order_eq_top {f g : 𝕜 → 𝕜} (hf : AnalyticAt 𝕜 f z₀)\n    (hg : AnalyticAt 𝕜 g z₀) (h'f : hf.order = ⊤) :\n    (hf.mul hg).order = ⊤ := by\n  rw [AnalyticAt.order_eq_top_iff, eventually_nhds_iff] at *\n  obtain ⟨t, h₁t, h₂t, h₃t⟩ := h'f\n  exact ⟨t, fun y hy ↦ (by simp [h₁t y hy]), h₂t, h₃t⟩\n\n"}
{"name":"AnalyticAt.order_mul","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\nz₀ : 𝕜\nf g : 𝕜 → 𝕜\nhf : AnalyticAt 𝕜 f z₀\nhg : AnalyticAt 𝕜 g z₀\n⊢ Eq ⋯.order (HAdd.hAdd hf.order hg.order)","decl":"/-- The order is additive when multiplying analytic functions. -/\ntheorem order_mul {f g : 𝕜 → 𝕜} (hf : AnalyticAt 𝕜 f z₀) (hg : AnalyticAt 𝕜 g z₀) :\n    (hf.mul hg).order = hf.order + hg.order := by\n  -- Trivial cases: one of the functions vanishes around z₀\n  by_cases h₂f : hf.order = ⊤\n  · simp [hf.order_mul_of_order_eq_top hg h₂f, h₂f]\n  by_cases h₂g : hg.order = ⊤\n  · simp [mul_comm f g, hg.order_mul_of_order_eq_top hf h₂g, h₂g]\n  -- Non-trivial case: both functions do not vanish around z₀\n  obtain ⟨g₁, h₁g₁, h₂g₁, h₃g₁⟩ := hf.order_neq_top_iff.1 h₂f\n  obtain ⟨g₂, h₁g₂, h₂g₂, h₃g₂⟩ := hg.order_neq_top_iff.1 h₂g\n  rw [← ENat.coe_toNat h₂f, ← ENat.coe_toNat h₂g, ← ENat.coe_add, (hf.mul hg).order_eq_nat_iff]\n  use g₁ * g₂, by exact h₁g₁.mul h₁g₂\n  constructor\n  · simp\n    tauto\n  · obtain ⟨t, h₁t, h₂t, h₃t⟩ := eventually_nhds_iff.1 h₃g₁\n    obtain ⟨s, h₁s, h₂s, h₃s⟩ := eventually_nhds_iff.1 h₃g₂\n    exact eventually_nhds_iff.2\n      ⟨t ∩ s, fun y hy ↦ (by simp [h₁t y hy.1, h₁s y hy.2]; ring), h₂t.inter h₂s, h₃t, h₃s⟩\n\n"}
{"name":"AnalyticAt.order_pow","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\nz₀ : 𝕜\nf : 𝕜 → 𝕜\nhf : AnalyticAt 𝕜 f z₀\nn : Nat\n⊢ Eq ⋯.order (HSMul.hSMul n hf.order)","decl":"/-- The order multiplies by `n` when taking an analytic function to its `n`th power. -/\ntheorem order_pow {f : 𝕜 → 𝕜} (hf : AnalyticAt 𝕜 f z₀) {n : ℕ} :\n    (hf.pow n).order = n • hf.order := by\n  induction n\n  case zero =>\n    simp [AnalyticAt.order_eq_zero_iff]\n  case succ n hn =>\n    simp [add_mul, pow_add, (hf.pow n).order_mul hf, hn]\n\n"}
{"name":"AnalyticOnNhd.eqOn_zero_of_preconnected_of_frequently_eq_zero","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → E\nz₀ : 𝕜\nU : Set 𝕜\nhf : AnalyticOnNhd 𝕜 f U\nhU : IsPreconnected U\nh₀ : Membership.mem U z₀\nhfw : Filter.Frequently (fun z => Eq (f z) 0) (nhdsWithin z₀ (HasCompl.compl (Singleton.singleton z₀)))\n⊢ Set.EqOn f 0 U","decl":"/-- The *principle of isolated zeros* for an analytic function, global version: if a function is\nanalytic on a connected set `U` and vanishes in arbitrary neighborhoods of a point `z₀ ∈ U`, then\nit is identically zero in `U`.\nFor higher-dimensional versions requiring that the function vanishes in a neighborhood of `z₀`,\nsee `AnalyticOnNhd.eqOn_zero_of_preconnected_of_eventuallyEq_zero`. -/\ntheorem eqOn_zero_of_preconnected_of_frequently_eq_zero (hf : AnalyticOnNhd 𝕜 f U)\n    (hU : IsPreconnected U) (h₀ : z₀ ∈ U) (hfw : ∃ᶠ z in 𝓝[≠] z₀, f z = 0) : EqOn f 0 U :=\n  hf.eqOn_zero_of_preconnected_of_eventuallyEq_zero hU h₀\n    ((hf z₀ h₀).frequently_zero_iff_eventually_zero.1 hfw)\n\n"}
{"name":"AnalyticOnNhd.eqOn_zero_or_eventually_ne_zero_of_preconnected","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → E\nU : Set 𝕜\nhf : AnalyticOnNhd 𝕜 f U\nhU : IsPreconnected U\n⊢ Or (Set.EqOn f 0 U) (Filter.Eventually (fun x => Ne (f x) 0) (Filter.codiscreteWithin U))","decl":"theorem eqOn_zero_or_eventually_ne_zero_of_preconnected (hf : AnalyticOnNhd 𝕜 f U)\n    (hU : IsPreconnected U) : EqOn f 0 U ∨ ∀ᶠ x in codiscreteWithin U, f x ≠ 0 := by\n  simp only [or_iff_not_imp_right, ne_eq, eventually_iff, mem_codiscreteWithin,\n    disjoint_principal_right, not_forall]\n  rintro ⟨x, hx, hx2⟩\n  refine hf.eqOn_zero_of_preconnected_of_frequently_eq_zero hU hx fun nh ↦ hx2 ?_\n  filter_upwards [nh] with a ha\n  simp_all\n\n"}
{"name":"AnalyticOnNhd.eqOn_zero_of_preconnected_of_mem_closure","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → E\nz₀ : 𝕜\nU : Set 𝕜\nhf : AnalyticOnNhd 𝕜 f U\nhU : IsPreconnected U\nh₀ : Membership.mem U z₀\nhfz₀ : Membership.mem (closure (SDiff.sdiff (setOf fun z => Eq (f z) 0) (Singleton.singleton z₀))) z₀\n⊢ Set.EqOn f 0 U","decl":"theorem eqOn_zero_of_preconnected_of_mem_closure (hf : AnalyticOnNhd 𝕜 f U) (hU : IsPreconnected U)\n    (h₀ : z₀ ∈ U) (hfz₀ : z₀ ∈ closure ({z | f z = 0} \\ {z₀})) : EqOn f 0 U :=\n  hf.eqOn_zero_of_preconnected_of_frequently_eq_zero hU h₀\n    (mem_closure_ne_iff_frequently_within.mp hfz₀)\n\n"}
{"name":"AnalyticOnNhd.eqOn_of_preconnected_of_frequently_eq","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf g : 𝕜 → E\nz₀ : 𝕜\nU : Set 𝕜\nhf : AnalyticOnNhd 𝕜 f U\nhg : AnalyticOnNhd 𝕜 g U\nhU : IsPreconnected U\nh₀ : Membership.mem U z₀\nhfg : Filter.Frequently (fun z => Eq (f z) (g z)) (nhdsWithin z₀ (HasCompl.compl (Singleton.singleton z₀)))\n⊢ Set.EqOn f g U","decl":"/-- The *identity principle* for analytic functions, global version: if two functions are\nanalytic on a connected set `U` and coincide at points which accumulate to a point `z₀ ∈ U`, then\nthey coincide globally in `U`.\nFor higher-dimensional versions requiring that the functions coincide in a neighborhood of `z₀`,\nsee `AnalyticOnNhd.eqOn_of_preconnected_of_eventuallyEq`. -/\ntheorem eqOn_of_preconnected_of_frequently_eq (hf : AnalyticOnNhd 𝕜 f U) (hg : AnalyticOnNhd 𝕜 g U)\n    (hU : IsPreconnected U) (h₀ : z₀ ∈ U) (hfg : ∃ᶠ z in 𝓝[≠] z₀, f z = g z) : EqOn f g U := by\n  have hfg' : ∃ᶠ z in 𝓝[≠] z₀, (f - g) z = 0 :=\n    hfg.mono fun z h => by rw [Pi.sub_apply, h, sub_self]\n  simpa [sub_eq_zero] using fun z hz =>\n    (hf.sub hg).eqOn_zero_of_preconnected_of_frequently_eq_zero hU h₀ hfg' hz\n\n"}
{"name":"AnalyticOnNhd.eqOn_or_eventually_ne_of_preconnected","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf g : 𝕜 → E\nU : Set 𝕜\nhf : AnalyticOnNhd 𝕜 f U\nhg : AnalyticOnNhd 𝕜 g U\nhU : IsPreconnected U\n⊢ Or (Set.EqOn f g U) (Filter.Eventually (fun x => Ne (f x) (g x)) (Filter.codiscreteWithin U))","decl":"theorem eqOn_or_eventually_ne_of_preconnected (hf : AnalyticOnNhd 𝕜 f U) (hg : AnalyticOnNhd 𝕜 g U)\n    (hU : IsPreconnected U) : EqOn f g U ∨ ∀ᶠ x in codiscreteWithin U, f x ≠ g x :=\n  (eqOn_zero_or_eventually_ne_zero_of_preconnected (hf.sub hg) hU).imp\n    (fun h _ hx ↦ eq_of_sub_eq_zero (h hx))\n    (by simp only [Pi.sub_apply, ne_eq, sub_eq_zero, imp_self])\n\n"}
{"name":"AnalyticOnNhd.eqOn_of_preconnected_of_mem_closure","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf g : 𝕜 → E\nz₀ : 𝕜\nU : Set 𝕜\nhf : AnalyticOnNhd 𝕜 f U\nhg : AnalyticOnNhd 𝕜 g U\nhU : IsPreconnected U\nh₀ : Membership.mem U z₀\nhfg : Membership.mem (closure (SDiff.sdiff (setOf fun z => Eq (f z) (g z)) (Singleton.singleton z₀))) z₀\n⊢ Set.EqOn f g U","decl":"theorem eqOn_of_preconnected_of_mem_closure (hf : AnalyticOnNhd 𝕜 f U) (hg : AnalyticOnNhd 𝕜 g U)\n    (hU : IsPreconnected U) (h₀ : z₀ ∈ U) (hfg : z₀ ∈ closure ({z | f z = g z} \\ {z₀})) :\n    EqOn f g U :=\n  hf.eqOn_of_preconnected_of_frequently_eq hg hU h₀ (mem_closure_ne_iff_frequently_within.mp hfg)\n\n"}
{"name":"AnalyticOnNhd.eq_of_frequently_eq","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nf g : 𝕜 → E\nz₀ : 𝕜\ninst✝ : ConnectedSpace 𝕜\nhf : AnalyticOnNhd 𝕜 f Set.univ\nhg : AnalyticOnNhd 𝕜 g Set.univ\nhfg : Filter.Frequently (fun z => Eq (f z) (g z)) (nhdsWithin z₀ (HasCompl.compl (Singleton.singleton z₀)))\n⊢ Eq f g","decl":"/-- The *identity principle* for analytic functions, global version: if two functions on a normed\nfield `𝕜` are analytic everywhere and coincide at points which accumulate to a point `z₀`, then\nthey coincide globally.\nFor higher-dimensional versions requiring that the functions coincide in a neighborhood of `z₀`,\nsee `AnalyticOnNhd.eq_of_eventuallyEq`. -/\ntheorem eq_of_frequently_eq [ConnectedSpace 𝕜] (hf : AnalyticOnNhd 𝕜 f univ)\n    (hg : AnalyticOnNhd 𝕜 g univ) (hfg : ∃ᶠ z in 𝓝[≠] z₀, f z = g z) : f = g :=\n  funext fun x =>\n    eqOn_of_preconnected_of_frequently_eq hf hg isPreconnected_univ (mem_univ z₀) hfg (mem_univ x)\n\n"}
{"name":"AnalyticOn.eq_of_frequently_eq","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nf g : 𝕜 → E\nz₀ : 𝕜\ninst✝ : ConnectedSpace 𝕜\nhf : AnalyticOnNhd 𝕜 f Set.univ\nhg : AnalyticOnNhd 𝕜 g Set.univ\nhfg : Filter.Frequently (fun z => Eq (f z) (g z)) (nhdsWithin z₀ (HasCompl.compl (Singleton.singleton z₀)))\n⊢ Eq f g","decl":"@[deprecated (since := \"2024-09-26\")]\nalias _root_.AnalyticOn.eq_of_frequently_eq := eq_of_frequently_eq\n\n"}
{"name":"AnalyticOnNhd.isClopen_setOf_order_eq_top","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → E\nU : Set 𝕜\nh₁f : AnalyticOnNhd 𝕜 f U\n⊢ IsClopen (setOf fun u => Eq ⋯.order Top.top)","decl":"/-- The set where an analytic function has infinite order is clopen in its domain of analyticity. -/\ntheorem isClopen_setOf_order_eq_top (h₁f : AnalyticOnNhd 𝕜 f U) :\n    IsClopen { u : U | (h₁f u.1 u.2).order = ⊤ } := by\n  constructor\n  · rw [← isOpen_compl_iff, isOpen_iff_forall_mem_open]\n    intro z hz\n    rcases (h₁f z.1 z.2).eventually_eq_zero_or_eventually_ne_zero with h | h\n    · -- Case: f is locally zero in a punctured neighborhood of z\n      rw [← (h₁f z.1 z.2).order_eq_top_iff] at h\n      tauto\n    · -- Case: f is locally nonzero in a punctured neighborhood of z\n      obtain ⟨t', h₁t', h₂t', h₃t'⟩ := eventually_nhds_iff.1 (eventually_nhdsWithin_iff.1 h)\n      use Subtype.val ⁻¹' t'\n      constructor\n      · intro w hw\n        simp only [mem_compl_iff, mem_setOf_eq]\n        by_cases h₁w : w = z\n        · rwa [h₁w]\n        · rw [(h₁f _ w.2).order_eq_zero_iff.2 ((h₁t' w hw) (Subtype.coe_ne_coe.mpr h₁w))]\n          exact ENat.zero_ne_top\n      · exact ⟨isOpen_induced h₂t', h₃t'⟩\n  · apply isOpen_iff_forall_mem_open.mpr\n    intro z hz\n    conv =>\n      arg 1; intro; left; right; arg 1; intro\n      rw [AnalyticAt.order_eq_top_iff, eventually_nhds_iff]\n    simp only [Set.mem_setOf_eq] at hz\n    rw [AnalyticAt.order_eq_top_iff, eventually_nhds_iff] at hz\n    obtain ⟨t', h₁t', h₂t', h₃t'⟩ := hz\n    use Subtype.val ⁻¹' t'\n    simp only [Set.mem_compl_iff, Set.mem_singleton_iff, isOpen_induced h₂t', Set.mem_preimage,\n      h₃t', and_self, and_true]\n    intro w hw\n    simp only [mem_setOf_eq]\n    -- Trivial case: w = z\n    by_cases h₁w : w = z\n    · rw [h₁w]\n      tauto\n    -- Nontrivial case: w ≠ z\n    use t' \\ {z.1}, fun y h₁y ↦ h₁t' y h₁y.1, h₂t'.sdiff isClosed_singleton\n    apply (Set.mem_diff w).1\n    exact ⟨hw, Set.mem_singleton_iff.not.1 (Subtype.coe_ne_coe.2 h₁w)⟩\n\n"}
{"name":"AnalyticOnNhd.eq_zero_or_eq_zero_of_smul_eq_zero","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nU : Set 𝕜\nA : Type u_3\ninst✝⁵ : NormedRing A\ninst✝⁴ : NormedAlgebra 𝕜 A\nB : Type u_4\ninst✝³ : NormedAddCommGroup B\ninst✝² : NormedSpace 𝕜 B\ninst✝¹ : Module A B\ninst✝ : NoZeroSMulDivisors A B\nf : 𝕜 → A\ng : 𝕜 → B\nhf : AnalyticOnNhd 𝕜 f U\nhg : AnalyticOnNhd 𝕜 g U\nhfg : ∀ (z : 𝕜), Membership.mem U z → Eq (HSMul.hSMul (f z) (g z)) 0\nhU : IsPreconnected U\n⊢ Or (∀ (z : 𝕜), Membership.mem U z → Eq (f z) 0) (∀ (z : 𝕜), Membership.mem U z → Eq (g z) 0)","decl":"/-- If `f, g` are analytic on a neighbourhood of the preconnected open set `U`, and `f • g = 0`\non `U`, then either `f = 0` on `U` or `g = 0` on `U`. -/\nlemma eq_zero_or_eq_zero_of_smul_eq_zero [NoZeroSMulDivisors A B]\n    {f : 𝕜 → A} {g : 𝕜 → B} (hf : AnalyticOnNhd 𝕜 f U) (hg : AnalyticOnNhd 𝕜 g U)\n    (hfg : ∀ z ∈ U, f z • g z = 0) (hU : IsPreconnected U) :\n    (∀ z ∈ U, f z = 0) ∨ (∀ z ∈ U, g z = 0) := by\n  -- We want to apply `IsPreconnected.preperfect_of_nontrivial` which requires `U` to have at least\n  -- two elements. So we need to dispose of the cases `#U = 0` and `#U = 1` first.\n  by_cases hU' : U = ∅\n  · simp [hU']\n  obtain ⟨z, hz⟩ : ∃ z, z ∈ U := nonempty_iff_ne_empty.mpr hU'\n  by_cases hU'' : U = {z}\n  · simpa [hU''] using hfg z hz\n  apply (nontrivial_iff_ne_singleton hz).mpr at hU''\n  -- Now connectedness implies that `z` is an accumulation point of `U`, so at least one of\n  -- `f` and `g` must vanish frequently in a neighbourhood of `z`.\n  have : ∃ᶠ w in 𝓝[≠] z, w ∈ U :=\n    frequently_mem_iff_neBot.mpr <| hU.preperfect_of_nontrivial hU'' z hz\n  have : ∃ᶠ w in 𝓝[≠] z, f w = 0 ∨ g w = 0 :=\n    this.mp <| by filter_upwards with w hw using smul_eq_zero.mp (hfg w hw)\n  cases frequently_or_distrib.mp this with\n  | inl h => exact Or.inl <| hf.eqOn_zero_of_preconnected_of_frequently_eq_zero hU hz h\n  | inr h => exact Or.inr <| hg.eqOn_zero_of_preconnected_of_frequently_eq_zero hU hz h\n\n"}
{"name":"AnalyticOnNhd.eq_zero_or_eq_zero_of_mul_eq_zero","module":"Mathlib.Analysis.Analytic.IsolatedZeros","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nU : Set 𝕜\nA : Type u_3\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra 𝕜 A\ninst✝ : NoZeroDivisors A\nf g : 𝕜 → A\nhf : AnalyticOnNhd 𝕜 f U\nhg : AnalyticOnNhd 𝕜 g U\nhfg : ∀ (z : 𝕜), Membership.mem U z → Eq (HMul.hMul (f z) (g z)) 0\nhU : IsPreconnected U\n⊢ Or (∀ (z : 𝕜), Membership.mem U z → Eq (f z) 0) (∀ (z : 𝕜), Membership.mem U z → Eq (g z) 0)","decl":"/-- If `f, g` are analytic on a neighbourhood of the preconnected open set `U`, and `f * g = 0`\non `U`, then either `f = 0` on `U` or `g = 0` on `U`. -/\nlemma eq_zero_or_eq_zero_of_mul_eq_zero [NoZeroDivisors A]\n    {f g : 𝕜 → A} (hf : AnalyticOnNhd 𝕜 f U) (hg : AnalyticOnNhd 𝕜 g U)\n    (hfg : ∀ z ∈ U, f z * g z = 0) (hU : IsPreconnected U) :\n    (∀ z ∈ U, f z = 0) ∨ (∀ z ∈ U, g z = 0) :=\n  eq_zero_or_eq_zero_of_smul_eq_zero hf hg hfg hU\n\n"}
