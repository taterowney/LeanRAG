{"name":"Finset.mem_sumLift₂","module":"Mathlib.Data.Sum.Interval","initialProofState":"α₁ : Type u_1\nα₂ : Type u_2\nβ₁ : Type u_3\nβ₂ : Type u_4\nγ₁ : Type u_5\nγ₂ : Type u_6\nf : α₁ → β₁ → Finset γ₁\ng : α₂ → β₂ → Finset γ₂\na : Sum α₁ α₂\nb : Sum β₁ β₂\nc : Sum γ₁ γ₂\n⊢ Iff (Membership.mem (Finset.sumLift₂ f g a b) c) (Or (Exists fun a₁ => Exists fun b₁ => Exists fun c₁ => And (Eq a (Sum.inl a₁)) (And (Eq b (Sum.inl b₁)) (And (Eq c (Sum.inl c₁)) (Membership.mem (f a₁ b₁) c₁)))) (Exists fun a₂ => Exists fun b₂ => Exists fun c₂ => And (Eq a (Sum.inr a₂)) (And (Eq b (Sum.inr b₂)) (And (Eq c (Sum.inr c₂)) (Membership.mem (g a₂ b₂) c₂)))))","decl":"theorem mem_sumLift₂ :\n    c ∈ sumLift₂ f g a b ↔\n      (∃ a₁ b₁ c₁, a = inl a₁ ∧ b = inl b₁ ∧ c = inl c₁ ∧ c₁ ∈ f a₁ b₁) ∨\n        ∃ a₂ b₂ c₂, a = inr a₂ ∧ b = inr b₂ ∧ c = inr c₂ ∧ c₂ ∈ g a₂ b₂ := by\n  constructor\n  · cases' a with a a <;> cases' b with b b\n    · rw [sumLift₂, mem_map]\n      rintro ⟨c, hc, rfl⟩\n      exact Or.inl ⟨a, b, c, rfl, rfl, rfl, hc⟩\n    · refine fun h ↦ (not_mem_empty _ h).elim\n    · refine fun h ↦ (not_mem_empty _ h).elim\n    · rw [sumLift₂, mem_map]\n      rintro ⟨c, hc, rfl⟩\n      exact Or.inr ⟨a, b, c, rfl, rfl, rfl, hc⟩\n  · rintro (⟨a, b, c, rfl, rfl, rfl, h⟩ | ⟨a, b, c, rfl, rfl, rfl, h⟩) <;> exact mem_map_of_mem _ h\n\n"}
{"name":"Finset.inl_mem_sumLift₂","module":"Mathlib.Data.Sum.Interval","initialProofState":"α₁ : Type u_1\nα₂ : Type u_2\nβ₁ : Type u_3\nβ₂ : Type u_4\nγ₁ : Type u_5\nγ₂ : Type u_6\nf : α₁ → β₁ → Finset γ₁\ng : α₂ → β₂ → Finset γ₂\na : Sum α₁ α₂\nb : Sum β₁ β₂\nc₁ : γ₁\n⊢ Iff (Membership.mem (Finset.sumLift₂ f g a b) (Sum.inl c₁)) (Exists fun a₁ => Exists fun b₁ => And (Eq a (Sum.inl a₁)) (And (Eq b (Sum.inl b₁)) (Membership.mem (f a₁ b₁) c₁)))","decl":"theorem inl_mem_sumLift₂ {c₁ : γ₁} :\n    inl c₁ ∈ sumLift₂ f g a b ↔ ∃ a₁ b₁, a = inl a₁ ∧ b = inl b₁ ∧ c₁ ∈ f a₁ b₁ := by\n  rw [mem_sumLift₂, or_iff_left]\n  · simp only [inl.injEq, exists_and_left, exists_eq_left']\n  rintro ⟨_, _, c₂, _, _, h, _⟩\n  exact inl_ne_inr h\n\n"}
{"name":"Finset.inr_mem_sumLift₂","module":"Mathlib.Data.Sum.Interval","initialProofState":"α₁ : Type u_1\nα₂ : Type u_2\nβ₁ : Type u_3\nβ₂ : Type u_4\nγ₁ : Type u_5\nγ₂ : Type u_6\nf : α₁ → β₁ → Finset γ₁\ng : α₂ → β₂ → Finset γ₂\na : Sum α₁ α₂\nb : Sum β₁ β₂\nc₂ : γ₂\n⊢ Iff (Membership.mem (Finset.sumLift₂ f g a b) (Sum.inr c₂)) (Exists fun a₂ => Exists fun b₂ => And (Eq a (Sum.inr a₂)) (And (Eq b (Sum.inr b₂)) (Membership.mem (g a₂ b₂) c₂)))","decl":"theorem inr_mem_sumLift₂ {c₂ : γ₂} :\n    inr c₂ ∈ sumLift₂ f g a b ↔ ∃ a₂ b₂, a = inr a₂ ∧ b = inr b₂ ∧ c₂ ∈ g a₂ b₂ := by\n  rw [mem_sumLift₂, or_iff_right]\n  · simp only [inr.injEq, exists_and_left, exists_eq_left']\n  rintro ⟨_, _, c₂, _, _, h, _⟩\n  exact inr_ne_inl h\n\n"}
{"name":"Finset.sumLift₂_eq_empty","module":"Mathlib.Data.Sum.Interval","initialProofState":"α₁ : Type u_1\nα₂ : Type u_2\nβ₁ : Type u_3\nβ₂ : Type u_4\nγ₁ : Type u_5\nγ₂ : Type u_6\nf : α₁ → β₁ → Finset γ₁\ng : α₂ → β₂ → Finset γ₂\na : Sum α₁ α₂\nb : Sum β₁ β₂\n⊢ Iff (Eq (Finset.sumLift₂ f g a b) EmptyCollection.emptyCollection) (And (∀ (a₁ : α₁) (b₁ : β₁), Eq a (Sum.inl a₁) → Eq b (Sum.inl b₁) → Eq (f a₁ b₁) EmptyCollection.emptyCollection) (∀ (a₂ : α₂) (b₂ : β₂), Eq a (Sum.inr a₂) → Eq b (Sum.inr b₂) → Eq (g a₂ b₂) EmptyCollection.emptyCollection))","decl":"theorem sumLift₂_eq_empty :\n    sumLift₂ f g a b = ∅ ↔\n      (∀ a₁ b₁, a = inl a₁ → b = inl b₁ → f a₁ b₁ = ∅) ∧\n        ∀ a₂ b₂, a = inr a₂ → b = inr b₂ → g a₂ b₂ = ∅ := by\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · constructor <;>\n    · rintro a b rfl rfl\n      exact map_eq_empty.1 h\n  cases a <;> cases b\n  · exact map_eq_empty.2 (h.1 _ _ rfl rfl)\n  · rfl\n  · rfl\n  · exact map_eq_empty.2 (h.2 _ _ rfl rfl)\n\n"}
{"name":"Finset.sumLift₂_nonempty","module":"Mathlib.Data.Sum.Interval","initialProofState":"α₁ : Type u_1\nα₂ : Type u_2\nβ₁ : Type u_3\nβ₂ : Type u_4\nγ₁ : Type u_5\nγ₂ : Type u_6\nf : α₁ → β₁ → Finset γ₁\ng : α₂ → β₂ → Finset γ₂\na : Sum α₁ α₂\nb : Sum β₁ β₂\n⊢ Iff (Finset.sumLift₂ f g a b).Nonempty (Or (Exists fun a₁ => Exists fun b₁ => And (Eq a (Sum.inl a₁)) (And (Eq b (Sum.inl b₁)) (f a₁ b₁).Nonempty)) (Exists fun a₂ => Exists fun b₂ => And (Eq a (Sum.inr a₂)) (And (Eq b (Sum.inr b₂)) (g a₂ b₂).Nonempty)))","decl":"theorem sumLift₂_nonempty :\n    (sumLift₂ f g a b).Nonempty ↔\n      (∃ a₁ b₁, a = inl a₁ ∧ b = inl b₁ ∧ (f a₁ b₁).Nonempty) ∨\n        ∃ a₂ b₂, a = inr a₂ ∧ b = inr b₂ ∧ (g a₂ b₂).Nonempty := by\n  simp only [nonempty_iff_ne_empty, Ne, sumLift₂_eq_empty, not_and_or, not_forall, exists_prop]\n\n"}
{"name":"Finset.sumLift₂_mono","module":"Mathlib.Data.Sum.Interval","initialProofState":"α₁ : Type u_1\nα₂ : Type u_2\nβ₁ : Type u_3\nβ₂ : Type u_4\nγ₁ : Type u_5\nγ₂ : Type u_6\nf₁ g₁ : α₁ → β₁ → Finset γ₁\nf₂ g₂ : α₂ → β₂ → Finset γ₂\nh₁ : ∀ (a : α₁) (b : β₁), HasSubset.Subset (f₁ a b) (g₁ a b)\nh₂ : ∀ (a : α₂) (b : β₂), HasSubset.Subset (f₂ a b) (g₂ a b)\na : Sum α₁ α₂\nb : Sum β₁ β₂\n⊢ HasSubset.Subset (Finset.sumLift₂ f₁ f₂ a b) (Finset.sumLift₂ g₁ g₂ a b)","decl":"theorem sumLift₂_mono (h₁ : ∀ a b, f₁ a b ⊆ g₁ a b) (h₂ : ∀ a b, f₂ a b ⊆ g₂ a b) :\n    ∀ a b, sumLift₂ f₁ f₂ a b ⊆ sumLift₂ g₁ g₂ a b\n  | inl _, inl _ => map_subset_map.2 (h₁ _ _)\n  | inl _, inr _ => Subset.rfl\n  | inr _, inl _ => Subset.rfl\n  | inr _, inr _ => map_subset_map.2 (h₂ _ _)\n\n"}
{"name":"Finset.sumLexLift_inl_inl","module":"Mathlib.Data.Sum.Interval","initialProofState":"α₁ : Type u_1\nα₂ : Type u_2\nβ₁ : Type u_3\nβ₂ : Type u_4\nγ₁ : Type u_5\nγ₂ : Type u_6\nf₁ : α₁ → β₁ → Finset γ₁\nf₂ : α₂ → β₂ → Finset γ₂\ng₁ : α₁ → β₂ → Finset γ₁\ng₂ : α₁ → β₂ → Finset γ₂\na : α₁\nb : β₁\n⊢ Eq (Finset.sumLexLift f₁ f₂ g₁ g₂ (Sum.inl a) (Sum.inl b)) (Finset.map Function.Embedding.inl (f₁ a b))","decl":"@[simp]\nlemma sumLexLift_inl_inl (a : α₁) (b : β₁) :\n    sumLexLift f₁ f₂ g₁ g₂ (inl a) (inl b) = (f₁ a b).map Embedding.inl := rfl\n\n"}
{"name":"Finset.sumLexLift_inl_inr","module":"Mathlib.Data.Sum.Interval","initialProofState":"α₁ : Type u_1\nα₂ : Type u_2\nβ₁ : Type u_3\nβ₂ : Type u_4\nγ₁ : Type u_5\nγ₂ : Type u_6\nf₁ : α₁ → β₁ → Finset γ₁\nf₂ : α₂ → β₂ → Finset γ₂\ng₁ : α₁ → β₂ → Finset γ₁\ng₂ : α₁ → β₂ → Finset γ₂\na : α₁\nb : β₂\n⊢ Eq (Finset.sumLexLift f₁ f₂ g₁ g₂ (Sum.inl a) (Sum.inr b)) ((g₁ a b).disjSum (g₂ a b))","decl":"@[simp]\nlemma sumLexLift_inl_inr (a : α₁) (b : β₂) :\n    sumLexLift f₁ f₂ g₁ g₂ (inl a) (inr b) = (g₁ a b).disjSum (g₂ a b) := rfl\n\n"}
{"name":"Finset.sumLexLift_inr_inl","module":"Mathlib.Data.Sum.Interval","initialProofState":"α₁ : Type u_1\nα₂ : Type u_2\nβ₁ : Type u_3\nβ₂ : Type u_4\nγ₁ : Type u_5\nγ₂ : Type u_6\nf₁ : α₁ → β₁ → Finset γ₁\nf₂ : α₂ → β₂ → Finset γ₂\ng₁ : α₁ → β₂ → Finset γ₁\ng₂ : α₁ → β₂ → Finset γ₂\na : α₂\nb : β₁\n⊢ Eq (Finset.sumLexLift f₁ f₂ g₁ g₂ (Sum.inr a) (Sum.inl b)) EmptyCollection.emptyCollection","decl":"@[simp]\nlemma sumLexLift_inr_inl (a : α₂) (b : β₁) : sumLexLift f₁ f₂ g₁ g₂ (inr a) (inl b) = ∅ := rfl\n\n"}
{"name":"Finset.sumLexLift_inr_inr","module":"Mathlib.Data.Sum.Interval","initialProofState":"α₁ : Type u_1\nα₂ : Type u_2\nβ₁ : Type u_3\nβ₂ : Type u_4\nγ₁ : Type u_5\nγ₂ : Type u_6\nf₁ : α₁ → β₁ → Finset γ₁\nf₂ : α₂ → β₂ → Finset γ₂\ng₁ : α₁ → β₂ → Finset γ₁\ng₂ : α₁ → β₂ → Finset γ₂\na : α₂\nb : β₂\n⊢ Eq (Finset.sumLexLift f₁ f₂ g₁ g₂ (Sum.inr a) (Sum.inr b)) (Finset.map { toFun := Sum.inr, inj' := ⋯ } (f₂ a b))","decl":"@[simp]\nlemma sumLexLift_inr_inr (a : α₂) (b : β₂) :\n    sumLexLift f₁ f₂ g₁ g₂ (inr a) (inr b) = (f₂ a b).map ⟨_, inr_injective⟩ := rfl\n\n"}
{"name":"Finset.mem_sumLexLift","module":"Mathlib.Data.Sum.Interval","initialProofState":"α₁ : Type u_1\nα₂ : Type u_2\nβ₁ : Type u_3\nβ₂ : Type u_4\nγ₁ : Type u_5\nγ₂ : Type u_6\nf₁ : α₁ → β₁ → Finset γ₁\nf₂ : α₂ → β₂ → Finset γ₂\ng₁ : α₁ → β₂ → Finset γ₁\ng₂ : α₁ → β₂ → Finset γ₂\na : Sum α₁ α₂\nb : Sum β₁ β₂\nc : Sum γ₁ γ₂\n⊢ Iff (Membership.mem (Finset.sumLexLift f₁ f₂ g₁ g₂ a b) c) (Or (Exists fun a₁ => Exists fun b₁ => Exists fun c₁ => And (Eq a (Sum.inl a₁)) (And (Eq b (Sum.inl b₁)) (And (Eq c (Sum.inl c₁)) (Membership.mem (f₁ a₁ b₁) c₁)))) (Or (Exists fun a₁ => Exists fun b₂ => Exists fun c₁ => And (Eq a (Sum.inl a₁)) (And (Eq b (Sum.inr b₂)) (And (Eq c (Sum.inl c₁)) (Membership.mem (g₁ a₁ b₂) c₁)))) (Or (Exists fun a₁ => Exists fun b₂ => Exists fun c₂ => And (Eq a (Sum.inl a₁)) (And (Eq b (Sum.inr b₂)) (And (Eq c (Sum.inr c₂)) (Membership.mem (g₂ a₁ b₂) c₂)))) (Exists fun a₂ => Exists fun b₂ => Exists fun c₂ => And (Eq a (Sum.inr a₂)) (And (Eq b (Sum.inr b₂)) (And (Eq c (Sum.inr c₂)) (Membership.mem (f₂ a₂ b₂) c₂)))))))","decl":"lemma mem_sumLexLift :\n    c ∈ sumLexLift f₁ f₂ g₁ g₂ a b ↔\n      (∃ a₁ b₁ c₁, a = inl a₁ ∧ b = inl b₁ ∧ c = inl c₁ ∧ c₁ ∈ f₁ a₁ b₁) ∨\n        (∃ a₁ b₂ c₁, a = inl a₁ ∧ b = inr b₂ ∧ c = inl c₁ ∧ c₁ ∈ g₁ a₁ b₂) ∨\n          (∃ a₁ b₂ c₂, a = inl a₁ ∧ b = inr b₂ ∧ c = inr c₂ ∧ c₂ ∈ g₂ a₁ b₂) ∨\n            ∃ a₂ b₂ c₂, a = inr a₂ ∧ b = inr b₂ ∧ c = inr c₂ ∧ c₂ ∈ f₂ a₂ b₂ := by\n  constructor\n  · obtain a | a := a <;> obtain b | b := b\n    · rw [sumLexLift, mem_map]\n      rintro ⟨c, hc, rfl⟩\n      exact Or.inl ⟨a, b, c, rfl, rfl, rfl, hc⟩\n    · refine fun h ↦ (mem_disjSum.1 h).elim ?_ ?_\n      · rintro ⟨c, hc, rfl⟩\n        exact Or.inr (Or.inl ⟨a, b, c, rfl, rfl, rfl, hc⟩)\n      · rintro ⟨c, hc, rfl⟩\n        exact Or.inr (Or.inr <| Or.inl ⟨a, b, c, rfl, rfl, rfl, hc⟩)\n    · exact fun h ↦ (not_mem_empty _ h).elim\n    · rw [sumLexLift, mem_map]\n      rintro ⟨c, hc, rfl⟩\n      exact Or.inr (Or.inr <| Or.inr <| ⟨a, b, c, rfl, rfl, rfl, hc⟩)\n  · rintro (⟨a, b, c, rfl, rfl, rfl, hc⟩ | ⟨a, b, c, rfl, rfl, rfl, hc⟩ |\n      ⟨a, b, c, rfl, rfl, rfl, hc⟩ | ⟨a, b, c, rfl, rfl, rfl, hc⟩)\n    · exact mem_map_of_mem _ hc\n    · exact inl_mem_disjSum.2 hc\n    · exact inr_mem_disjSum.2 hc\n    · exact mem_map_of_mem _ hc\n\n"}
{"name":"Finset.inl_mem_sumLexLift","module":"Mathlib.Data.Sum.Interval","initialProofState":"α₁ : Type u_1\nα₂ : Type u_2\nβ₁ : Type u_3\nβ₂ : Type u_4\nγ₁ : Type u_5\nγ₂ : Type u_6\nf₁ : α₁ → β₁ → Finset γ₁\nf₂ : α₂ → β₂ → Finset γ₂\ng₁ : α₁ → β₂ → Finset γ₁\ng₂ : α₁ → β₂ → Finset γ₂\na : Sum α₁ α₂\nb : Sum β₁ β₂\nc₁ : γ₁\n⊢ Iff (Membership.mem (Finset.sumLexLift f₁ f₂ g₁ g₂ a b) (Sum.inl c₁)) (Or (Exists fun a₁ => Exists fun b₁ => And (Eq a (Sum.inl a₁)) (And (Eq b (Sum.inl b₁)) (Membership.mem (f₁ a₁ b₁) c₁))) (Exists fun a₁ => Exists fun b₂ => And (Eq a (Sum.inl a₁)) (And (Eq b (Sum.inr b₂)) (Membership.mem (g₁ a₁ b₂) c₁))))","decl":"lemma inl_mem_sumLexLift {c₁ : γ₁} :\n    inl c₁ ∈ sumLexLift f₁ f₂ g₁ g₂ a b ↔\n      (∃ a₁ b₁, a = inl a₁ ∧ b = inl b₁ ∧ c₁ ∈ f₁ a₁ b₁) ∨\n        ∃ a₁ b₂, a = inl a₁ ∧ b = inr b₂ ∧ c₁ ∈ g₁ a₁ b₂ := by\n  simp [mem_sumLexLift]\n\n"}
{"name":"Finset.inr_mem_sumLexLift","module":"Mathlib.Data.Sum.Interval","initialProofState":"α₁ : Type u_1\nα₂ : Type u_2\nβ₁ : Type u_3\nβ₂ : Type u_4\nγ₁ : Type u_5\nγ₂ : Type u_6\nf₁ : α₁ → β₁ → Finset γ₁\nf₂ : α₂ → β₂ → Finset γ₂\ng₁ : α₁ → β₂ → Finset γ₁\ng₂ : α₁ → β₂ → Finset γ₂\na : Sum α₁ α₂\nb : Sum β₁ β₂\nc₂ : γ₂\n⊢ Iff (Membership.mem (Finset.sumLexLift f₁ f₂ g₁ g₂ a b) (Sum.inr c₂)) (Or (Exists fun a₁ => Exists fun b₂ => And (Eq a (Sum.inl a₁)) (And (Eq b (Sum.inr b₂)) (Membership.mem (g₂ a₁ b₂) c₂))) (Exists fun a₂ => Exists fun b₂ => And (Eq a (Sum.inr a₂)) (And (Eq b (Sum.inr b₂)) (Membership.mem (f₂ a₂ b₂) c₂))))","decl":"lemma inr_mem_sumLexLift {c₂ : γ₂} :\n    inr c₂ ∈ sumLexLift f₁ f₂ g₁ g₂ a b ↔\n      (∃ a₁ b₂, a = inl a₁ ∧ b = inr b₂ ∧ c₂ ∈ g₂ a₁ b₂) ∨\n        ∃ a₂ b₂, a = inr a₂ ∧ b = inr b₂ ∧ c₂ ∈ f₂ a₂ b₂ := by\n  simp [mem_sumLexLift]\n\n"}
{"name":"Finset.sumLexLift_mono","module":"Mathlib.Data.Sum.Interval","initialProofState":"α₁ : Type u_1\nα₂ : Type u_2\nβ₁ : Type u_3\nβ₂ : Type u_4\nγ₁ : Type u_5\nγ₂ : Type u_6\nf₁ f₁' : α₁ → β₁ → Finset γ₁\nf₂ f₂' : α₂ → β₂ → Finset γ₂\ng₁ g₁' : α₁ → β₂ → Finset γ₁\ng₂ g₂' : α₁ → β₂ → Finset γ₂\nhf₁ : ∀ (a : α₁) (b : β₁), HasSubset.Subset (f₁ a b) (f₁' a b)\nhf₂ : ∀ (a : α₂) (b : β₂), HasSubset.Subset (f₂ a b) (f₂' a b)\nhg₁ : ∀ (a : α₁) (b : β₂), HasSubset.Subset (g₁ a b) (g₁' a b)\nhg₂ : ∀ (a : α₁) (b : β₂), HasSubset.Subset (g₂ a b) (g₂' a b)\na : Sum α₁ α₂\nb : Sum β₁ β₂\n⊢ HasSubset.Subset (Finset.sumLexLift f₁ f₂ g₁ g₂ a b) (Finset.sumLexLift f₁' f₂' g₁' g₂' a b)","decl":"lemma sumLexLift_mono (hf₁ : ∀ a b, f₁ a b ⊆ f₁' a b) (hf₂ : ∀ a b, f₂ a b ⊆ f₂' a b)\n    (hg₁ : ∀ a b, g₁ a b ⊆ g₁' a b) (hg₂ : ∀ a b, g₂ a b ⊆ g₂' a b) (a : α₁ ⊕ α₂)\n    (b : β₁ ⊕ β₂) : sumLexLift f₁ f₂ g₁ g₂ a b ⊆ sumLexLift f₁' f₂' g₁' g₂' a b := by\n  cases a <;> cases b\n  exacts [map_subset_map.2 (hf₁ _ _), disjSum_mono (hg₁ _ _) (hg₂ _ _), Subset.rfl,\n    map_subset_map.2 (hf₂ _ _)]\n\n"}
{"name":"Finset.sumLexLift_eq_empty","module":"Mathlib.Data.Sum.Interval","initialProofState":"α₁ : Type u_1\nα₂ : Type u_2\nβ₁ : Type u_3\nβ₂ : Type u_4\nγ₁ : Type u_5\nγ₂ : Type u_6\nf₁ : α₁ → β₁ → Finset γ₁\nf₂ : α₂ → β₂ → Finset γ₂\ng₁ : α₁ → β₂ → Finset γ₁\ng₂ : α₁ → β₂ → Finset γ₂\na : Sum α₁ α₂\nb : Sum β₁ β₂\n⊢ Iff (Eq (Finset.sumLexLift f₁ f₂ g₁ g₂ a b) EmptyCollection.emptyCollection) (And (∀ (a₁ : α₁) (b₁ : β₁), Eq a (Sum.inl a₁) → Eq b (Sum.inl b₁) → Eq (f₁ a₁ b₁) EmptyCollection.emptyCollection) (And (∀ (a₁ : α₁) (b₂ : β₂), Eq a (Sum.inl a₁) → Eq b (Sum.inr b₂) → And (Eq (g₁ a₁ b₂) EmptyCollection.emptyCollection) (Eq (g₂ a₁ b₂) EmptyCollection.emptyCollection)) (∀ (a₂ : α₂) (b₂ : β₂), Eq a (Sum.inr a₂) → Eq b (Sum.inr b₂) → Eq (f₂ a₂ b₂) EmptyCollection.emptyCollection)))","decl":"lemma sumLexLift_eq_empty :\n    sumLexLift f₁ f₂ g₁ g₂ a b = ∅ ↔\n      (∀ a₁ b₁, a = inl a₁ → b = inl b₁ → f₁ a₁ b₁ = ∅) ∧\n        (∀ a₁ b₂, a = inl a₁ → b = inr b₂ → g₁ a₁ b₂ = ∅ ∧ g₂ a₁ b₂ = ∅) ∧\n          ∀ a₂ b₂, a = inr a₂ → b = inr b₂ → f₂ a₂ b₂ = ∅ := by\n  refine ⟨fun h ↦ ⟨?_, ?_, ?_⟩, fun h ↦ ?_⟩\n  any_goals rintro a b rfl rfl; exact map_eq_empty.1 h\n  · rintro a b rfl rfl; exact disjSum_eq_empty.1 h\n  cases a <;> cases b\n  · exact map_eq_empty.2 (h.1 _ _ rfl rfl)\n  · simp [h.2.1 _ _ rfl rfl]\n  · rfl\n  · exact map_eq_empty.2 (h.2.2 _ _ rfl rfl)\n\n"}
{"name":"Finset.sumLexLift_nonempty","module":"Mathlib.Data.Sum.Interval","initialProofState":"α₁ : Type u_1\nα₂ : Type u_2\nβ₁ : Type u_3\nβ₂ : Type u_4\nγ₁ : Type u_5\nγ₂ : Type u_6\nf₁ : α₁ → β₁ → Finset γ₁\nf₂ : α₂ → β₂ → Finset γ₂\ng₁ : α₁ → β₂ → Finset γ₁\ng₂ : α₁ → β₂ → Finset γ₂\na : Sum α₁ α₂\nb : Sum β₁ β₂\n⊢ Iff (Finset.sumLexLift f₁ f₂ g₁ g₂ a b).Nonempty (Or (Exists fun a₁ => Exists fun b₁ => And (Eq a (Sum.inl a₁)) (And (Eq b (Sum.inl b₁)) (f₁ a₁ b₁).Nonempty)) (Or (Exists fun a₁ => Exists fun b₂ => And (Eq a (Sum.inl a₁)) (And (Eq b (Sum.inr b₂)) (Or (g₁ a₁ b₂).Nonempty (g₂ a₁ b₂).Nonempty))) (Exists fun a₂ => Exists fun b₂ => And (Eq a (Sum.inr a₂)) (And (Eq b (Sum.inr b₂)) (f₂ a₂ b₂).Nonempty))))","decl":"lemma sumLexLift_nonempty :\n    (sumLexLift f₁ f₂ g₁ g₂ a b).Nonempty ↔\n      (∃ a₁ b₁, a = inl a₁ ∧ b = inl b₁ ∧ (f₁ a₁ b₁).Nonempty) ∨\n        (∃ a₁ b₂, a = inl a₁ ∧ b = inr b₂ ∧ ((g₁ a₁ b₂).Nonempty ∨ (g₂ a₁ b₂).Nonempty)) ∨\n          ∃ a₂ b₂, a = inr a₂ ∧ b = inr b₂ ∧ (f₂ a₂ b₂).Nonempty := by\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10745): was `simp [nonempty_iff_ne_empty, sumLexLift_eq_empty, not_and_or]`.\n  -- Could add `-exists_and_left, -not_and, -exists_and_right` but easier to squeeze.\n  simp only [nonempty_iff_ne_empty, Ne, sumLexLift_eq_empty, not_and_or, exists_prop,\n    not_forall]\n\n"}
{"name":"Sum.Icc_inl_inl","module":"Mathlib.Data.Sum.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : LocallyFiniteOrder β\na₁ a₂ : α\n⊢ Eq (Finset.Icc (Sum.inl a₁) (Sum.inl a₂)) (Finset.map Function.Embedding.inl (Finset.Icc a₁ a₂))","decl":"theorem Icc_inl_inl : Icc (inl a₁ : α ⊕ β) (inl a₂) = (Icc a₁ a₂).map Embedding.inl :=\n  rfl\n\n"}
{"name":"Sum.Ico_inl_inl","module":"Mathlib.Data.Sum.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : LocallyFiniteOrder β\na₁ a₂ : α\n⊢ Eq (Finset.Ico (Sum.inl a₁) (Sum.inl a₂)) (Finset.map Function.Embedding.inl (Finset.Ico a₁ a₂))","decl":"theorem Ico_inl_inl : Ico (inl a₁ : α ⊕ β) (inl a₂) = (Ico a₁ a₂).map Embedding.inl :=\n  rfl\n\n"}
{"name":"Sum.Ioc_inl_inl","module":"Mathlib.Data.Sum.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : LocallyFiniteOrder β\na₁ a₂ : α\n⊢ Eq (Finset.Ioc (Sum.inl a₁) (Sum.inl a₂)) (Finset.map Function.Embedding.inl (Finset.Ioc a₁ a₂))","decl":"theorem Ioc_inl_inl : Ioc (inl a₁ : α ⊕ β) (inl a₂) = (Ioc a₁ a₂).map Embedding.inl :=\n  rfl\n\n"}
{"name":"Sum.Ioo_inl_inl","module":"Mathlib.Data.Sum.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : LocallyFiniteOrder β\na₁ a₂ : α\n⊢ Eq (Finset.Ioo (Sum.inl a₁) (Sum.inl a₂)) (Finset.map Function.Embedding.inl (Finset.Ioo a₁ a₂))","decl":"theorem Ioo_inl_inl : Ioo (inl a₁ : α ⊕ β) (inl a₂) = (Ioo a₁ a₂).map Embedding.inl :=\n  rfl\n\n"}
{"name":"Sum.Icc_inl_inr","module":"Mathlib.Data.Sum.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : LocallyFiniteOrder β\na₁ : α\nb₂ : β\n⊢ Eq (Finset.Icc (Sum.inl a₁) (Sum.inr b₂)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem Icc_inl_inr : Icc (inl a₁) (inr b₂) = ∅ :=\n  rfl\n\n"}
{"name":"Sum.Ico_inl_inr","module":"Mathlib.Data.Sum.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : LocallyFiniteOrder β\na₁ : α\nb₂ : β\n⊢ Eq (Finset.Ico (Sum.inl a₁) (Sum.inr b₂)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem Ico_inl_inr : Ico (inl a₁) (inr b₂) = ∅ :=\n  rfl\n\n"}
{"name":"Sum.Ioc_inl_inr","module":"Mathlib.Data.Sum.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : LocallyFiniteOrder β\na₁ : α\nb₂ : β\n⊢ Eq (Finset.Ioc (Sum.inl a₁) (Sum.inr b₂)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem Ioc_inl_inr : Ioc (inl a₁) (inr b₂) = ∅ :=\n  rfl\n\n"}
{"name":"Sum.Ioo_inl_inr","module":"Mathlib.Data.Sum.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : LocallyFiniteOrder β\na₁ : α\nb₂ : β\n⊢ Eq (Finset.Ioo (Sum.inl a₁) (Sum.inr b₂)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem Ioo_inl_inr : Ioo (inl a₁) (inr b₂) = ∅ := by\n  rfl\n\n"}
{"name":"Sum.Icc_inr_inl","module":"Mathlib.Data.Sum.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : LocallyFiniteOrder β\na₂ : α\nb₁ : β\n⊢ Eq (Finset.Icc (Sum.inr b₁) (Sum.inl a₂)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem Icc_inr_inl : Icc (inr b₁) (inl a₂) = ∅ :=\n  rfl\n\n"}
{"name":"Sum.Ico_inr_inl","module":"Mathlib.Data.Sum.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : LocallyFiniteOrder β\na₂ : α\nb₁ : β\n⊢ Eq (Finset.Ico (Sum.inr b₁) (Sum.inl a₂)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem Ico_inr_inl : Ico (inr b₁) (inl a₂) = ∅ :=\n  rfl\n\n"}
{"name":"Sum.Ioc_inr_inl","module":"Mathlib.Data.Sum.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : LocallyFiniteOrder β\na₂ : α\nb₁ : β\n⊢ Eq (Finset.Ioc (Sum.inr b₁) (Sum.inl a₂)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem Ioc_inr_inl : Ioc (inr b₁) (inl a₂) = ∅ :=\n  rfl\n\n"}
{"name":"Sum.Ioo_inr_inl","module":"Mathlib.Data.Sum.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : LocallyFiniteOrder β\na₂ : α\nb₁ : β\n⊢ Eq (Finset.Ioo (Sum.inr b₁) (Sum.inl a₂)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem Ioo_inr_inl : Ioo (inr b₁) (inl a₂) = ∅ := by\n  rfl\n\n"}
{"name":"Sum.Icc_inr_inr","module":"Mathlib.Data.Sum.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : LocallyFiniteOrder β\nb₁ b₂ : β\n⊢ Eq (Finset.Icc (Sum.inr b₁) (Sum.inr b₂)) (Finset.map Function.Embedding.inr (Finset.Icc b₁ b₂))","decl":"theorem Icc_inr_inr : Icc (inr b₁ : α ⊕ β) (inr b₂) = (Icc b₁ b₂).map Embedding.inr :=\n  rfl\n\n"}
{"name":"Sum.Ico_inr_inr","module":"Mathlib.Data.Sum.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : LocallyFiniteOrder β\nb₁ b₂ : β\n⊢ Eq (Finset.Ico (Sum.inr b₁) (Sum.inr b₂)) (Finset.map Function.Embedding.inr (Finset.Ico b₁ b₂))","decl":"theorem Ico_inr_inr : Ico (inr b₁ : α ⊕ β) (inr b₂) = (Ico b₁ b₂).map Embedding.inr :=\n  rfl\n\n"}
{"name":"Sum.Ioc_inr_inr","module":"Mathlib.Data.Sum.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : LocallyFiniteOrder β\nb₁ b₂ : β\n⊢ Eq (Finset.Ioc (Sum.inr b₁) (Sum.inr b₂)) (Finset.map Function.Embedding.inr (Finset.Ioc b₁ b₂))","decl":"theorem Ioc_inr_inr : Ioc (inr b₁ : α ⊕ β) (inr b₂) = (Ioc b₁ b₂).map Embedding.inr :=\n  rfl\n\n"}
{"name":"Sum.Ioo_inr_inr","module":"Mathlib.Data.Sum.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : LocallyFiniteOrder β\nb₁ b₂ : β\n⊢ Eq (Finset.Ioo (Sum.inr b₁) (Sum.inr b₂)) (Finset.map Function.Embedding.inr (Finset.Ioo b₁ b₂))","decl":"theorem Ioo_inr_inr : Ioo (inr b₁ : α ⊕ β) (inr b₂) = (Ioo b₁ b₂).map Embedding.inr :=\n  rfl\n\n"}
{"name":"Sum.Lex.Icc_inl_inl","module":"Mathlib.Data.Sum.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : OrderTop α\ninst✝² : OrderBot β\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : LocallyFiniteOrder β\na₁ a₂ : α\n⊢ Eq (Finset.Icc (Sum.inlₗ a₁) (Sum.inlₗ a₂)) (Finset.map (Function.Embedding.inl.trans toLex.toEmbedding) (Finset.Icc a₁ a₂))","decl":"lemma Icc_inl_inl :\n    Icc (inlₗ a₁ : α ⊕ₗ β) (inlₗ a₂) = (Icc a₁ a₂).map (Embedding.inl.trans toLex.toEmbedding) := by\n  rw [← Finset.map_map]; rfl\n\n"}
{"name":"Sum.Lex.Ico_inl_inl","module":"Mathlib.Data.Sum.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : OrderTop α\ninst✝² : OrderBot β\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : LocallyFiniteOrder β\na₁ a₂ : α\n⊢ Eq (Finset.Ico (Sum.inlₗ a₁) (Sum.inlₗ a₂)) (Finset.map (Function.Embedding.inl.trans toLex.toEmbedding) (Finset.Ico a₁ a₂))","decl":"lemma Ico_inl_inl :\n    Ico (inlₗ a₁ : α ⊕ₗ β) (inlₗ a₂) = (Ico a₁ a₂).map (Embedding.inl.trans toLex.toEmbedding) := by\n  rw [← Finset.map_map]; rfl\n\n"}
{"name":"Sum.Lex.Ioc_inl_inl","module":"Mathlib.Data.Sum.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : OrderTop α\ninst✝² : OrderBot β\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : LocallyFiniteOrder β\na₁ a₂ : α\n⊢ Eq (Finset.Ioc (Sum.inlₗ a₁) (Sum.inlₗ a₂)) (Finset.map (Function.Embedding.inl.trans toLex.toEmbedding) (Finset.Ioc a₁ a₂))","decl":"lemma Ioc_inl_inl :\n    Ioc (inlₗ a₁ : α ⊕ₗ β) (inlₗ a₂) = (Ioc a₁ a₂).map (Embedding.inl.trans toLex.toEmbedding) := by\n  rw [← Finset.map_map]; rfl\n\n"}
{"name":"Sum.Lex.Ioo_inl_inl","module":"Mathlib.Data.Sum.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : OrderTop α\ninst✝² : OrderBot β\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : LocallyFiniteOrder β\na₁ a₂ : α\n⊢ Eq (Finset.Ioo (Sum.inlₗ a₁) (Sum.inlₗ a₂)) (Finset.map (Function.Embedding.inl.trans toLex.toEmbedding) (Finset.Ioo a₁ a₂))","decl":"lemma Ioo_inl_inl :\n    Ioo (inlₗ a₁ : α ⊕ₗ β) (inlₗ a₂) = (Ioo a₁ a₂).map (Embedding.inl.trans toLex.toEmbedding) := by\n  rw [← Finset.map_map]; rfl\n\n"}
{"name":"Sum.Lex.Icc_inl_inr","module":"Mathlib.Data.Sum.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : OrderTop α\ninst✝² : OrderBot β\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : LocallyFiniteOrder β\na : α\nb : β\n⊢ Eq (Finset.Icc (Sum.inlₗ a) (Sum.inrₗ b)) (Finset.map toLex.toEmbedding ((Finset.Ici a).disjSum (Finset.Iic b)))","decl":"@[simp]\nlemma Icc_inl_inr : Icc (inlₗ a) (inrₗ b) = ((Ici a).disjSum (Iic b)).map toLex.toEmbedding := rfl\n\n"}
{"name":"Sum.Lex.Ico_inl_inr","module":"Mathlib.Data.Sum.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : OrderTop α\ninst✝² : OrderBot β\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : LocallyFiniteOrder β\na : α\nb : β\n⊢ Eq (Finset.Ico (Sum.inlₗ a) (Sum.inrₗ b)) (Finset.map toLex.toEmbedding ((Finset.Ici a).disjSum (Finset.Iio b)))","decl":"@[simp]\nlemma Ico_inl_inr : Ico (inlₗ a) (inrₗ b) = ((Ici a).disjSum (Iio b)).map toLex.toEmbedding := rfl\n\n"}
{"name":"Sum.Lex.Ioc_inl_inr","module":"Mathlib.Data.Sum.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : OrderTop α\ninst✝² : OrderBot β\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : LocallyFiniteOrder β\na : α\nb : β\n⊢ Eq (Finset.Ioc (Sum.inlₗ a) (Sum.inrₗ b)) (Finset.map toLex.toEmbedding ((Finset.Ioi a).disjSum (Finset.Iic b)))","decl":"@[simp]\nlemma Ioc_inl_inr : Ioc (inlₗ a) (inrₗ b) = ((Ioi a).disjSum (Iic b)).map toLex.toEmbedding := rfl\n\n"}
{"name":"Sum.Lex.Ioo_inl_inr","module":"Mathlib.Data.Sum.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : OrderTop α\ninst✝² : OrderBot β\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : LocallyFiniteOrder β\na : α\nb : β\n⊢ Eq (Finset.Ioo (Sum.inlₗ a) (Sum.inrₗ b)) (Finset.map toLex.toEmbedding ((Finset.Ioi a).disjSum (Finset.Iio b)))","decl":"@[simp]\nlemma Ioo_inl_inr : Ioo (inlₗ a) (inrₗ b) = ((Ioi a).disjSum (Iio b)).map toLex.toEmbedding := rfl\n\n"}
{"name":"Sum.Lex.Icc_inr_inl","module":"Mathlib.Data.Sum.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : OrderTop α\ninst✝² : OrderBot β\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : LocallyFiniteOrder β\na : α\nb : β\n⊢ Eq (Finset.Icc (Sum.inrₗ b) (Sum.inlₗ a)) EmptyCollection.emptyCollection","decl":"@[simp]\nlemma Icc_inr_inl : Icc (inrₗ b) (inlₗ a) = ∅ := rfl\n\n"}
{"name":"Sum.Lex.Ico_inr_inl","module":"Mathlib.Data.Sum.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : OrderTop α\ninst✝² : OrderBot β\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : LocallyFiniteOrder β\na : α\nb : β\n⊢ Eq (Finset.Ico (Sum.inrₗ b) (Sum.inlₗ a)) EmptyCollection.emptyCollection","decl":"@[simp]\nlemma Ico_inr_inl : Ico (inrₗ b) (inlₗ a) = ∅ := rfl\n\n"}
{"name":"Sum.Lex.Ioc_inr_inl","module":"Mathlib.Data.Sum.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : OrderTop α\ninst✝² : OrderBot β\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : LocallyFiniteOrder β\na : α\nb : β\n⊢ Eq (Finset.Ioc (Sum.inrₗ b) (Sum.inlₗ a)) EmptyCollection.emptyCollection","decl":"@[simp]\nlemma Ioc_inr_inl : Ioc (inrₗ b) (inlₗ a) = ∅ := rfl\n\n"}
{"name":"Sum.Lex.Ioo_inr_inl","module":"Mathlib.Data.Sum.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : OrderTop α\ninst✝² : OrderBot β\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : LocallyFiniteOrder β\na : α\nb : β\n⊢ Eq (Finset.Ioo (Sum.inrₗ b) (Sum.inlₗ a)) EmptyCollection.emptyCollection","decl":"@[simp]\nlemma Ioo_inr_inl : Ioo (inrₗ b) (inlₗ a) = ∅ := rfl\n\n"}
{"name":"Sum.Lex.Icc_inr_inr","module":"Mathlib.Data.Sum.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : OrderTop α\ninst✝² : OrderBot β\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : LocallyFiniteOrder β\nb₁ b₂ : β\n⊢ Eq (Finset.Icc (Sum.inrₗ b₁) (Sum.inrₗ b₂)) (Finset.map (Function.Embedding.inr.trans toLex.toEmbedding) (Finset.Icc b₁ b₂))","decl":"lemma Icc_inr_inr :\n    Icc (inrₗ b₁ : α ⊕ₗ β) (inrₗ b₂) = (Icc b₁ b₂).map (Embedding.inr.trans toLex.toEmbedding) := by\n  rw [← Finset.map_map]; rfl\n\n"}
{"name":"Sum.Lex.Ico_inr_inr","module":"Mathlib.Data.Sum.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : OrderTop α\ninst✝² : OrderBot β\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : LocallyFiniteOrder β\nb₁ b₂ : β\n⊢ Eq (Finset.Ico (Sum.inrₗ b₁) (Sum.inrₗ b₂)) (Finset.map (Function.Embedding.inr.trans toLex.toEmbedding) (Finset.Ico b₁ b₂))","decl":"lemma Ico_inr_inr :\n    Ico (inrₗ b₁ : α ⊕ₗ β) (inrₗ b₂) = (Ico b₁ b₂).map (Embedding.inr.trans toLex.toEmbedding) := by\n  rw [← Finset.map_map]; rfl\n\n"}
{"name":"Sum.Lex.Ioc_inr_inr","module":"Mathlib.Data.Sum.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : OrderTop α\ninst✝² : OrderBot β\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : LocallyFiniteOrder β\nb₁ b₂ : β\n⊢ Eq (Finset.Ioc (Sum.inrₗ b₁) (Sum.inrₗ b₂)) (Finset.map (Function.Embedding.inr.trans toLex.toEmbedding) (Finset.Ioc b₁ b₂))","decl":"lemma Ioc_inr_inr :\n    Ioc (inrₗ b₁ : α ⊕ₗ β) (inrₗ b₂) = (Ioc b₁ b₂).map (Embedding.inr.trans toLex.toEmbedding) := by\n  rw [← Finset.map_map]; rfl\n\n"}
{"name":"Sum.Lex.Ioo_inr_inr","module":"Mathlib.Data.Sum.Interval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : OrderTop α\ninst✝² : OrderBot β\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : LocallyFiniteOrder β\nb₁ b₂ : β\n⊢ Eq (Finset.Ioo (Sum.inrₗ b₁) (Sum.inrₗ b₂)) (Finset.map (Function.Embedding.inr.trans toLex.toEmbedding) (Finset.Ioo b₁ b₂))","decl":"lemma Ioo_inr_inr :\n    Ioo (inrₗ b₁ : α ⊕ₗ β) (inrₗ b₂) = (Ioo b₁ b₂).map (Embedding.inr.trans toLex.toEmbedding) := by\n  rw [← Finset.map_map]; rfl\n\n"}
