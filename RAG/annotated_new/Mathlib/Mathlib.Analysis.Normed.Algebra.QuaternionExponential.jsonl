{"name":"Quaternion.exp_coe","module":"Mathlib.Analysis.Normed.Algebra.QuaternionExponential","initialProofState":"r : Real\n⊢ Eq (NormedSpace.exp Real ↑r) ↑(NormedSpace.exp Real r)","decl":"@[simp, norm_cast]\ntheorem exp_coe (r : ℝ) : exp ℝ (r : ℍ[ℝ]) = ↑(exp ℝ r) :=\n  (map_exp ℝ (algebraMap ℝ ℍ[ℝ]) (continuous_algebraMap _ _) _).symm\n\n"}
{"name":"Quaternion.expSeries_even_of_imaginary","module":"Mathlib.Analysis.Normed.Algebra.QuaternionExponential","initialProofState":"q : Quaternion Real\nhq : Eq q.re 0\nn : Nat\n⊢ Eq ((NormedSpace.expSeries Real (Quaternion Real) (HMul.hMul 2 n)) fun x => q) ↑(HDiv.hDiv (HMul.hMul (HPow.hPow (-1) n) (HPow.hPow (Norm.norm q) (HMul.hMul 2 n))) ↑(HMul.hMul 2 n).factorial)","decl":"/-- The even terms of `expSeries` are real, and correspond to the series for $\\cos ‖q‖$. -/\ntheorem expSeries_even_of_imaginary {q : Quaternion ℝ} (hq : q.re = 0) (n : ℕ) :\n    expSeries ℝ (Quaternion ℝ) (2 * n) (fun _ => q) =\n      ↑((-1 : ℝ) ^ n * ‖q‖ ^ (2 * n) / (2 * n)!) := by\n  rw [expSeries_apply_eq]\n  have hq2 : q ^ 2 = -normSq q := sq_eq_neg_normSq.mpr hq\n  letI k : ℝ := ↑(2 * n)!\n  calc\n    k⁻¹ • q ^ (2 * n) = k⁻¹ • (-normSq q) ^ n := by rw [pow_mul, hq2]\n    _ = k⁻¹ • ↑((-1 : ℝ) ^ n * ‖q‖ ^ (2 * n)) := ?_\n    _ = ↑((-1 : ℝ) ^ n * ‖q‖ ^ (2 * n) / k) := ?_\n  · congr 1\n    rw [neg_pow, normSq_eq_norm_mul_self, pow_mul, sq]\n    push_cast\n    rfl\n  · rw [← coe_mul_eq_smul, div_eq_mul_inv]\n    norm_cast\n    ring_nf\n\n"}
{"name":"Quaternion.expSeries_odd_of_imaginary","module":"Mathlib.Analysis.Normed.Algebra.QuaternionExponential","initialProofState":"q : Quaternion Real\nhq : Eq q.re 0\nn : Nat\n⊢ Eq ((NormedSpace.expSeries Real (Quaternion Real) (HAdd.hAdd (HMul.hMul 2 n) 1)) fun x => q) (HSMul.hSMul (HDiv.hDiv (HDiv.hDiv (HMul.hMul (HPow.hPow (-1) n) (HPow.hPow (Norm.norm q) (HAdd.hAdd (HMul.hMul 2 n) 1))) ↑(HAdd.hAdd (HMul.hMul 2 n) 1).factorial) (Norm.norm q)) q)","decl":"/-- The odd terms of `expSeries` are real, and correspond to the series for\n$\\frac{q}{‖q‖} \\sin ‖q‖$. -/\ntheorem expSeries_odd_of_imaginary {q : Quaternion ℝ} (hq : q.re = 0) (n : ℕ) :\n    expSeries ℝ (Quaternion ℝ) (2 * n + 1) (fun _ => q) =\n      (((-1 : ℝ) ^ n * ‖q‖ ^ (2 * n + 1) / (2 * n + 1)!) / ‖q‖) • q := by\n  rw [expSeries_apply_eq]\n  obtain rfl | hq0 := eq_or_ne q 0\n  · simp\n  have hq2 : q ^ 2 = -normSq q := sq_eq_neg_normSq.mpr hq\n  have hqn := norm_ne_zero_iff.mpr hq0\n  let k : ℝ := ↑(2 * n + 1)!\n  calc\n    k⁻¹ • q ^ (2 * n + 1) = k⁻¹ • ((-normSq q) ^ n * q) := by rw [pow_succ, pow_mul, hq2]\n    _ = k⁻¹ • ((-1 : ℝ) ^ n * ‖q‖ ^ (2 * n)) • q := ?_\n    _ = ((-1 : ℝ) ^ n * ‖q‖ ^ (2 * n + 1) / k / ‖q‖) • q := ?_\n  · congr 1\n    rw [neg_pow, normSq_eq_norm_mul_self, pow_mul, sq, ← coe_mul_eq_smul]\n    norm_cast\n  · rw [smul_smul]\n    congr 1\n    simp_rw [pow_succ, mul_div_assoc, div_div_cancel_left' hqn]\n    ring\n\n"}
{"name":"Quaternion.hasSum_expSeries_of_imaginary","module":"Mathlib.Analysis.Normed.Algebra.QuaternionExponential","initialProofState":"q : Quaternion Real\nhq : Eq q.re 0\nc s : Real\nhc : HasSum (fun n => HDiv.hDiv (HMul.hMul (HPow.hPow (-1) n) (HPow.hPow (Norm.norm q) (HMul.hMul 2 n))) ↑(HMul.hMul 2 n).factorial) c\nhs : HasSum (fun n => HDiv.hDiv (HMul.hMul (HPow.hPow (-1) n) (HPow.hPow (Norm.norm q) (HAdd.hAdd (HMul.hMul 2 n) 1))) ↑(HAdd.hAdd (HMul.hMul 2 n) 1).factorial) s\n⊢ HasSum (fun n => (NormedSpace.expSeries Real (Quaternion Real) n) fun x => q) (HAdd.hAdd (↑c) (HSMul.hSMul (HDiv.hDiv s (Norm.norm q)) q))","decl":"/-- Auxiliary result; if the power series corresponding to `Real.cos` and `Real.sin` evaluated\nat `‖q‖` tend to `c` and `s`, then the exponential series tends to `c + (s / ‖q‖)`. -/\ntheorem hasSum_expSeries_of_imaginary {q : Quaternion ℝ} (hq : q.re = 0) {c s : ℝ}\n    (hc : HasSum (fun n => (-1 : ℝ) ^ n * ‖q‖ ^ (2 * n) / (2 * n)!) c)\n    (hs : HasSum (fun n => (-1 : ℝ) ^ n * ‖q‖ ^ (2 * n + 1) / (2 * n + 1)!) s) :\n    HasSum (fun n => expSeries ℝ (Quaternion ℝ) n fun _ => q) (↑c + (s / ‖q‖) • q) := by\n  replace hc := hasSum_coe.mpr hc\n  replace hs := (hs.div_const ‖q‖).smul_const q\n  refine HasSum.even_add_odd ?_ ?_\n  · convert hc using 1\n    ext n : 1\n    rw [expSeries_even_of_imaginary hq]\n  · convert hs using 1\n    ext n : 1\n    rw [expSeries_odd_of_imaginary hq]\n\n"}
{"name":"Quaternion.exp_of_re_eq_zero","module":"Mathlib.Analysis.Normed.Algebra.QuaternionExponential","initialProofState":"q : Quaternion Real\nhq : Eq q.re 0\n⊢ Eq (NormedSpace.exp Real q) (HAdd.hAdd (↑(Real.cos (Norm.norm q))) (HSMul.hSMul (HDiv.hDiv (Real.sin (Norm.norm q)) (Norm.norm q)) q))","decl":"/-- The closed form for the quaternion exponential on imaginary quaternions. -/\ntheorem exp_of_re_eq_zero (q : Quaternion ℝ) (hq : q.re = 0) :\n    exp ℝ q = ↑(Real.cos ‖q‖) + (Real.sin ‖q‖ / ‖q‖) • q := by\n  rw [exp_eq_tsum]\n  refine HasSum.tsum_eq ?_\n  simp_rw [← expSeries_apply_eq]\n  exact hasSum_expSeries_of_imaginary hq (Real.hasSum_cos _) (Real.hasSum_sin _)\n\n"}
{"name":"Quaternion.exp_eq","module":"Mathlib.Analysis.Normed.Algebra.QuaternionExponential","initialProofState":"q : Quaternion Real\n⊢ Eq (NormedSpace.exp Real q) (HSMul.hSMul (NormedSpace.exp Real q.re) (HAdd.hAdd (↑(Real.cos (Norm.norm q.im))) (HSMul.hSMul (HDiv.hDiv (Real.sin (Norm.norm q.im)) (Norm.norm q.im)) q.im)))","decl":"/-- The closed form for the quaternion exponential on arbitrary quaternions. -/\ntheorem exp_eq (q : Quaternion ℝ) :\n    exp ℝ q = exp ℝ q.re • (↑(Real.cos ‖q.im‖) + (Real.sin ‖q.im‖ / ‖q.im‖) • q.im) := by\n  rw [← exp_of_re_eq_zero q.im q.im_re, ← coe_mul_eq_smul, ← exp_coe, ← exp_add_of_commute,\n    re_add_im]\n  exact Algebra.commutes q.re (_ : ℍ[ℝ])\n\n"}
{"name":"Quaternion.re_exp","module":"Mathlib.Analysis.Normed.Algebra.QuaternionExponential","initialProofState":"q : Quaternion Real\n⊢ Eq (NormedSpace.exp Real q).re (HMul.hMul (NormedSpace.exp Real q.re) (Real.cos (Norm.norm (HSub.hSub q ↑q.re))))","decl":"theorem re_exp (q : ℍ[ℝ]) : (exp ℝ q).re = exp ℝ q.re * Real.cos ‖q - q.re‖ := by simp [exp_eq]\n\n"}
{"name":"Quaternion.im_exp","module":"Mathlib.Analysis.Normed.Algebra.QuaternionExponential","initialProofState":"q : Quaternion Real\n⊢ Eq (NormedSpace.exp Real q).im (HSMul.hSMul (HMul.hMul (NormedSpace.exp Real q.re) (HDiv.hDiv (Real.sin (Norm.norm q.im)) (Norm.norm q.im))) q.im)","decl":"theorem im_exp (q : ℍ[ℝ]) : (exp ℝ q).im = (exp ℝ q.re * (Real.sin ‖q.im‖ / ‖q.im‖)) • q.im := by\n  simp [exp_eq, smul_smul]\n\n"}
{"name":"Quaternion.normSq_exp","module":"Mathlib.Analysis.Normed.Algebra.QuaternionExponential","initialProofState":"q : Quaternion Real\n⊢ Eq (Quaternion.normSq (NormedSpace.exp Real q)) (HPow.hPow (NormedSpace.exp Real q.re) 2)","decl":"theorem normSq_exp (q : ℍ[ℝ]) : normSq (exp ℝ q) = exp ℝ q.re ^ 2 :=\n  calc\n    normSq (exp ℝ q) =\n        normSq (exp ℝ q.re • (↑(Real.cos ‖q.im‖) + (Real.sin ‖q.im‖ / ‖q.im‖) • q.im)) := by\n      rw [exp_eq]\n    _ = exp ℝ q.re ^ 2 * normSq (↑(Real.cos ‖q.im‖) + (Real.sin ‖q.im‖ / ‖q.im‖) • q.im) := by\n      rw [normSq_smul]\n    _ = exp ℝ q.re ^ 2 * (Real.cos ‖q.im‖ ^ 2 + Real.sin ‖q.im‖ ^ 2) := by\n      congr 1\n      obtain hv | hv := eq_or_ne ‖q.im‖ 0\n      · simp [hv]\n      rw [normSq_add, normSq_smul, star_smul, coe_mul_eq_smul, smul_re, smul_re, star_re, im_re,\n        smul_zero, smul_zero, mul_zero, add_zero, div_pow, normSq_coe,\n        normSq_eq_norm_mul_self, ← sq, div_mul_cancel₀ _ (pow_ne_zero _ hv)]\n    _ = exp ℝ q.re ^ 2 := by rw [Real.cos_sq_add_sin_sq, mul_one]\n\n"}
{"name":"Quaternion.norm_exp","module":"Mathlib.Analysis.Normed.Algebra.QuaternionExponential","initialProofState":"q : Quaternion Real\n⊢ Eq (Norm.norm (NormedSpace.exp Real q)) (Norm.norm (NormedSpace.exp Real q.re))","decl":"/-- Note that this implies that exponentials of pure imaginary quaternions are unit quaternions\nsince in that case the RHS is `1` via `NormedSpace.exp_zero` and `norm_one`. -/\n@[simp]\ntheorem norm_exp (q : ℍ[ℝ]) : ‖exp ℝ q‖ = ‖exp ℝ q.re‖ := by\n  rw [norm_eq_sqrt_real_inner (exp ℝ q), inner_self, normSq_exp, Real.sqrt_sq_eq_abs,\n    Real.norm_eq_abs]\n\n"}
