{"name":"UpperHalfPlane.isOpenEmbedding_coe","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Topology","initialProofState":"⊢ Topology.IsOpenEmbedding UpperHalfPlane.coe","decl":"theorem isOpenEmbedding_coe : IsOpenEmbedding ((↑) : ℍ → ℂ) :=\n  IsOpen.isOpenEmbedding_subtypeVal <| isOpen_lt continuous_const Complex.continuous_im\n\n"}
{"name":"UpperHalfPlane.openEmbedding_coe","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Topology","initialProofState":"⊢ Topology.IsOpenEmbedding UpperHalfPlane.coe","decl":"@[deprecated (since := \"2024-10-18\")]\nalias openEmbedding_coe := isOpenEmbedding_coe\n\n"}
{"name":"UpperHalfPlane.isEmbedding_coe","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Topology","initialProofState":"⊢ Topology.IsEmbedding UpperHalfPlane.coe","decl":"theorem isEmbedding_coe : IsEmbedding ((↑) : ℍ → ℂ) :=\n  IsEmbedding.subtypeVal\n\n"}
{"name":"UpperHalfPlane.embedding_coe","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Topology","initialProofState":"⊢ Topology.IsEmbedding UpperHalfPlane.coe","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_coe := isEmbedding_coe\n\n"}
{"name":"UpperHalfPlane.continuous_coe","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Topology","initialProofState":"⊢ Continuous UpperHalfPlane.coe","decl":"theorem continuous_coe : Continuous ((↑) : ℍ → ℂ) :=\n  isEmbedding_coe.continuous\n\n"}
{"name":"UpperHalfPlane.continuous_re","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Topology","initialProofState":"⊢ Continuous UpperHalfPlane.re","decl":"theorem continuous_re : Continuous re :=\n  Complex.continuous_re.comp continuous_coe\n\n"}
{"name":"UpperHalfPlane.continuous_im","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Topology","initialProofState":"⊢ Continuous UpperHalfPlane.im","decl":"theorem continuous_im : Continuous im :=\n  Complex.continuous_im.comp continuous_coe\n\n"}
{"name":"UpperHalfPlane.instSecondCountableTopology","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Topology","initialProofState":"⊢ SecondCountableTopology UpperHalfPlane","decl":"instance : SecondCountableTopology ℍ :=\n  TopologicalSpace.Subtype.secondCountableTopology _\n\n"}
{"name":"UpperHalfPlane.instT3Space","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Topology","initialProofState":"⊢ T3Space UpperHalfPlane","decl":"instance : T3Space ℍ := Subtype.t3Space\n\n"}
{"name":"UpperHalfPlane.instT4Space","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Topology","initialProofState":"⊢ T4Space UpperHalfPlane","decl":"instance : T4Space ℍ := inferInstance\n\n"}
{"name":"UpperHalfPlane.instContractibleSpace","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Topology","initialProofState":"⊢ ContractibleSpace UpperHalfPlane","decl":"instance : ContractibleSpace ℍ :=\n  (convex_halfSpace_im_gt 0).contractibleSpace ⟨I, one_pos.trans_eq I_im.symm⟩\n\n"}
{"name":"UpperHalfPlane.instLocPathConnectedSpace","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Topology","initialProofState":"⊢ LocPathConnectedSpace UpperHalfPlane","decl":"instance : LocPathConnectedSpace ℍ := isOpenEmbedding_coe.locPathConnectedSpace\n\n"}
{"name":"UpperHalfPlane.instNoncompactSpace","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Topology","initialProofState":"⊢ NoncompactSpace UpperHalfPlane","decl":"instance : NoncompactSpace ℍ := by\n  refine ⟨fun h => ?_⟩\n  have : IsCompact (Complex.im ⁻¹' Ioi 0) := isCompact_iff_isCompact_univ.2 h\n  replace := this.isClosed.closure_eq\n  rw [closure_preimage_im, closure_Ioi, Set.ext_iff] at this\n  exact absurd ((this 0).1 (@left_mem_Ici ℝ _ 0)) (@lt_irrefl ℝ _ 0)\n\n"}
{"name":"UpperHalfPlane.instLocallyCompactSpace","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Topology","initialProofState":"⊢ LocallyCompactSpace UpperHalfPlane","decl":"instance : LocallyCompactSpace ℍ :=\n  isOpenEmbedding_coe.locallyCompactSpace\n\n"}
{"name":"UpperHalfPlane.mem_verticalStrip_iff","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Topology","initialProofState":"A B : Real\nz : UpperHalfPlane\n⊢ Iff (Membership.mem (UpperHalfPlane.verticalStrip A B) z) (And (LE.le (abs z.re) A) (LE.le B z.im))","decl":"theorem mem_verticalStrip_iff (A B : ℝ) (z : ℍ) : z ∈ verticalStrip A B ↔ |z.re| ≤ A ∧ B ≤ z.im :=\n  Iff.rfl\n\n"}
{"name":"UpperHalfPlane.verticalStrip_mono","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Topology","initialProofState":"A B A' B' : Real\nhA : LE.le A A'\nhB : LE.le B' B\n⊢ HasSubset.Subset (UpperHalfPlane.verticalStrip A B) (UpperHalfPlane.verticalStrip A' B')","decl":"@[gcongr]\nlemma verticalStrip_mono {A B A' B' : ℝ} (hA : A ≤ A') (hB : B' ≤ B) :\n    verticalStrip A B ⊆ verticalStrip A' B' := by\n  rintro z ⟨hzre, hzim⟩\n  exact ⟨hzre.trans hA, hB.trans hzim⟩\n\n"}
{"name":"UpperHalfPlane.verticalStrip_mono_left","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Topology","initialProofState":"A A' : Real\nh : LE.le A A'\nB : Real\n⊢ HasSubset.Subset (UpperHalfPlane.verticalStrip A B) (UpperHalfPlane.verticalStrip A' B)","decl":"@[gcongr]\nlemma verticalStrip_mono_left {A A'} (h : A ≤ A') (B) : verticalStrip A B ⊆ verticalStrip A' B :=\n  verticalStrip_mono h le_rfl\n\n"}
{"name":"UpperHalfPlane.verticalStrip_anti_right","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Topology","initialProofState":"A B B' : Real\nh : LE.le B' B\n⊢ HasSubset.Subset (UpperHalfPlane.verticalStrip A B) (UpperHalfPlane.verticalStrip A B')","decl":"@[gcongr]\nlemma verticalStrip_anti_right (A) {B B'} (h : B' ≤ B) : verticalStrip A B ⊆ verticalStrip A B' :=\n  verticalStrip_mono le_rfl h\n\n"}
{"name":"UpperHalfPlane.subset_verticalStrip_of_isCompact","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Topology","initialProofState":"K : Set UpperHalfPlane\nhK : IsCompact K\n⊢ Exists fun A => Exists fun B => And (LT.lt 0 B) (HasSubset.Subset K (UpperHalfPlane.verticalStrip A B))","decl":"lemma subset_verticalStrip_of_isCompact {K : Set ℍ} (hK : IsCompact K) :\n    ∃ A B : ℝ, 0 < B ∧ K ⊆ verticalStrip A B := by\n  rcases K.eq_empty_or_nonempty with rfl | hne\n  · exact ⟨1, 1, Real.zero_lt_one, empty_subset _⟩\n  obtain ⟨u, _, hu⟩ := hK.exists_isMaxOn hne (_root_.continuous_abs.comp continuous_re).continuousOn\n  obtain ⟨v, _, hv⟩ := hK.exists_isMinOn hne continuous_im.continuousOn\n  exact ⟨|re u|, im v, v.im_pos, fun k hk ↦ ⟨isMaxOn_iff.mp hu _ hk, isMinOn_iff.mp hv _ hk⟩⟩\n\n"}
{"name":"UpperHalfPlane.ModularGroup_T_zpow_mem_verticalStrip","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Topology","initialProofState":"z : UpperHalfPlane\nN : Nat\nhn : LT.lt 0 N\n⊢ Exists fun n => Membership.mem (UpperHalfPlane.verticalStrip (↑N) z.im) (HSMul.hSMul (HPow.hPow ModularGroup.T (HMul.hMul (↑N) n)) z)","decl":"theorem ModularGroup_T_zpow_mem_verticalStrip (z : ℍ) {N : ℕ} (hn : 0 < N) :\n    ∃ n : ℤ, ModularGroup.T ^ (N * n) • z ∈ verticalStrip N z.im := by\n  let n := Int.floor (z.re/N)\n  use -n\n  rw [modular_T_zpow_smul z (N * -n)]\n  refine ⟨?_, (by simp only [mul_neg, Int.cast_neg, Int.cast_mul, Int.cast_natCast, vadd_im,\n    le_refl])⟩\n  have h : (N * (-n : ℝ) +ᵥ z).re = -N * Int.floor (z.re / N) + z.re := by\n    simp only [n, Int.cast_natCast, mul_neg, vadd_re, neg_mul]\n  norm_cast at *\n  rw [h, add_comm]\n  simp only [neg_mul, Int.cast_neg, Int.cast_mul, Int.cast_natCast]\n  have hnn : (0 : ℝ) < (N : ℝ) := by norm_cast at *\n  have h2 : z.re + -(N * n) =  z.re - n * N := by ring\n  rw [h2, abs_eq_self.2 (Int.sub_floor_div_mul_nonneg (z.re : ℝ) hnn)]\n  apply (Int.sub_floor_div_mul_lt (z.re : ℝ) hnn).le\n\n"}
{"name":"UpperHalfPlane.ofComplex_apply","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Topology","initialProofState":"z : UpperHalfPlane\n⊢ Eq (↑UpperHalfPlane.ofComplex ↑z) z","decl":"@[simp]\nlemma ofComplex_apply (z : ℍ) : ofComplex (z : ℂ) = z :=\n  IsOpenEmbedding.toPartialHomeomorph_left_inv ..\n\n"}
{"name":"UpperHalfPlane.ofComplex_apply_eq_ite","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Topology","initialProofState":"w : Complex\n⊢ Eq (↑UpperHalfPlane.ofComplex w) (dite (LT.lt 0 w.im) (fun hw => ⟨w, hw⟩) fun hw => Classical.choice ⋯)","decl":"lemma ofComplex_apply_eq_ite (w : ℂ) :\n    ofComplex w = if hw : 0 < w.im then ⟨w, hw⟩ else Classical.choice inferInstance := by\n  split_ifs with hw\n  · exact ofComplex_apply ⟨w, hw⟩\n  · change (Function.invFunOn UpperHalfPlane.coe Set.univ w) = _\n    simp only [invFunOn, dite_eq_right_iff, mem_univ, true_and]\n    rintro ⟨a, rfl⟩\n    exact (a.prop.not_le (by simpa using hw)).elim\n\n"}
{"name":"UpperHalfPlane.ofComplex_apply_of_im_pos","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Topology","initialProofState":"z : Complex\nhz : LT.lt 0 z.im\n⊢ Eq (↑UpperHalfPlane.ofComplex z) ⟨z, hz⟩","decl":"lemma ofComplex_apply_of_im_pos {z : ℂ} (hz : 0 < z.im) :\n    ofComplex z = ⟨z, hz⟩ := by\n  simpa only [coe_mk_subtype] using ofComplex_apply ⟨z, hz⟩\n\n"}
{"name":"UpperHalfPlane.ofComplex_apply_of_im_nonpos","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Topology","initialProofState":"w : Complex\nhw : LE.le w.im 0\n⊢ Eq (↑UpperHalfPlane.ofComplex w) (Classical.choice ⋯)","decl":"lemma ofComplex_apply_of_im_nonpos {w : ℂ} (hw : w.im ≤ 0) :\n    ofComplex w = Classical.choice inferInstance := by\n  simp [ofComplex_apply_eq_ite w, hw]\n\n"}
{"name":"UpperHalfPlane.ofComplex_apply_eq_of_im_nonpos","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Topology","initialProofState":"w w' : Complex\nhw : LE.le w.im 0\nhw' : LE.le w'.im 0\n⊢ Eq (↑UpperHalfPlane.ofComplex w) (↑UpperHalfPlane.ofComplex w')","decl":"lemma ofComplex_apply_eq_of_im_nonpos {w w' : ℂ} (hw : w.im ≤ 0) (hw' : w'.im ≤ 0) :\n    ofComplex w = ofComplex w' := by\n  simp [ofComplex_apply_of_im_nonpos, hw, hw']\n\n"}
{"name":"UpperHalfPlane.comp_ofComplex","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Topology","initialProofState":"f : UpperHalfPlane → Complex\nz : UpperHalfPlane\n⊢ Eq (Function.comp f ↑UpperHalfPlane.ofComplex ↑z) (f z)","decl":"lemma comp_ofComplex (f : ℍ → ℂ) (z : ℍ) : (↑ₕ f) z = f z :=\n  congrArg _ <| ofComplex_apply z\n\n"}
{"name":"UpperHalfPlane.comp_ofComplex_of_im_pos","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Topology","initialProofState":"f : UpperHalfPlane → Complex\nz : Complex\nhz : LT.lt 0 z.im\n⊢ Eq (Function.comp f (↑UpperHalfPlane.ofComplex) z) (f ⟨z, hz⟩)","decl":"lemma comp_ofComplex_of_im_pos (f : ℍ → ℂ) (z : ℂ) (hz : 0 < z.im) : (↑ₕ f) z = f ⟨z, hz⟩ :=\n  congrArg _ <| ofComplex_apply ⟨z, hz⟩\n\n"}
{"name":"UpperHalfPlane.comp_ofComplex_of_im_le_zero","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Topology","initialProofState":"f : UpperHalfPlane → Complex\nz z' : Complex\nhz : LE.le z.im 0\nhz' : LE.le z'.im 0\n⊢ Eq (Function.comp f (↑UpperHalfPlane.ofComplex) z) (Function.comp f (↑UpperHalfPlane.ofComplex) z')","decl":"lemma comp_ofComplex_of_im_le_zero (f : ℍ → ℂ) (z z' : ℂ) (hz : z.im ≤ 0) (hz' : z'.im ≤ 0)  :\n    (↑ₕ f) z = (↑ₕ f) z' := by\n  simp [ofComplex_apply_of_im_nonpos, hz, hz']\n\n"}
{"name":"UpperHalfPlane.eventuallyEq_coe_comp_ofComplex","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Topology","initialProofState":"z : Complex\nhz : LT.lt 0 z.im\n⊢ (nhds z).EventuallyEq (Function.comp UpperHalfPlane.coe ↑UpperHalfPlane.ofComplex) id","decl":"lemma eventuallyEq_coe_comp_ofComplex {z : ℂ} (hz : 0 < z.im) :\n    UpperHalfPlane.coe ∘ ofComplex =ᶠ[𝓝 z] id := by\n  filter_upwards [(Complex.continuous_im.isOpen_preimage _ isOpen_Ioi).mem_nhds hz] with x hx\n  simp only [Function.comp_apply, ofComplex_apply_of_im_pos hx, id_eq, coe_mk_subtype]\n\n"}
