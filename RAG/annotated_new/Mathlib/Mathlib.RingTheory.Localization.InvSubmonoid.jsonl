{"name":"IsLocalization.submonoid_map_le_is_unit","module":"Mathlib.RingTheory.Localization.InvSubmonoid","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\n⊢ LE.le (Submonoid.map (algebraMap R S) M) (IsUnit.submonoid S)","decl":"theorem submonoid_map_le_is_unit : M.map (algebraMap R S) ≤ IsUnit.submonoid S := by\n  rintro _ ⟨a, ha, rfl⟩\n  exact IsLocalization.map_units S ⟨_, ha⟩\n\n"}
{"name":"IsLocalization.toInvSubmonoid_surjective","module":"Mathlib.RingTheory.Localization.InvSubmonoid","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\n⊢ Function.Surjective ⇑(IsLocalization.toInvSubmonoid M S)","decl":"theorem toInvSubmonoid_surjective : Function.Surjective (toInvSubmonoid M S) :=\n  Function.Surjective.comp (β := M.map (algebraMap R S))\n    (Equiv.surjective (equivInvSubmonoid _ _).toEquiv) (MonoidHom.submonoidMap_surjective _ _)\n\n"}
{"name":"IsLocalization.toInvSubmonoid_mul","module":"Mathlib.RingTheory.Localization.InvSubmonoid","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nm : Subtype fun x => Membership.mem M x\n⊢ Eq (HMul.hMul (↑((IsLocalization.toInvSubmonoid M S) m)) ((algebraMap R S) ↑m)) 1","decl":"@[simp]\ntheorem toInvSubmonoid_mul (m : M) : (toInvSubmonoid M S m : S) * algebraMap R S m = 1 :=\n  Submonoid.leftInvEquiv_symm_mul _ (submonoid_map_le_is_unit _ _) _\n\n"}
{"name":"IsLocalization.mul_toInvSubmonoid","module":"Mathlib.RingTheory.Localization.InvSubmonoid","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nm : Subtype fun x => Membership.mem M x\n⊢ Eq (HMul.hMul ((algebraMap R S) ↑m) ↑((IsLocalization.toInvSubmonoid M S) m)) 1","decl":"@[simp]\ntheorem mul_toInvSubmonoid (m : M) : algebraMap R S m * (toInvSubmonoid M S m : S) = 1 :=\n  Submonoid.mul_leftInvEquiv_symm _ (submonoid_map_le_is_unit _ _) ⟨_, _⟩\n\n"}
{"name":"IsLocalization.smul_toInvSubmonoid","module":"Mathlib.RingTheory.Localization.InvSubmonoid","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nm : Subtype fun x => Membership.mem M x\n⊢ Eq (HSMul.hSMul m ↑((IsLocalization.toInvSubmonoid M S) m)) 1","decl":"@[simp]\ntheorem smul_toInvSubmonoid (m : M) : m • (toInvSubmonoid M S m : S) = 1 := by\n  convert mul_toInvSubmonoid M S m\n  ext\n  rw [← Algebra.smul_def]\n  rfl\n\n"}
{"name":"IsLocalization.surj''","module":"Mathlib.RingTheory.Localization.InvSubmonoid","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nz : S\n⊢ Exists fun r => Exists fun m => Eq z (HSMul.hSMul r ↑((IsLocalization.toInvSubmonoid M S) m))","decl":"theorem surj'' (z : S) : ∃ (r : R) (m : M), z = r • (toInvSubmonoid M S m : S) := by\n  rcases IsLocalization.surj M z with ⟨⟨r, m⟩, e : z * _ = algebraMap R S r⟩\n  refine ⟨r, m, ?_⟩\n  rw [Algebra.smul_def, ← e, mul_assoc]\n  simp\n\n"}
{"name":"IsLocalization.toInvSubmonoid_eq_mk'","module":"Mathlib.RingTheory.Localization.InvSubmonoid","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx : Subtype fun x => Membership.mem M x\n⊢ Eq (↑((IsLocalization.toInvSubmonoid M S) x)) (IsLocalization.mk' S 1 x)","decl":"theorem toInvSubmonoid_eq_mk' (x : M) : (toInvSubmonoid M S x : S) = mk' S 1 x := by\n  rw [← (IsLocalization.map_units S x).mul_left_inj]\n  simp\n\n"}
{"name":"IsLocalization.mem_invSubmonoid_iff_exists_mk'","module":"Mathlib.RingTheory.Localization.InvSubmonoid","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx : S\n⊢ Iff (Membership.mem (IsLocalization.invSubmonoid M S) x) (Exists fun m => Eq (IsLocalization.mk' S 1 m) x)","decl":"theorem mem_invSubmonoid_iff_exists_mk' (x : S) :\n    x ∈ invSubmonoid M S ↔ ∃ m : M, mk' S 1 m = x := by\n  simp_rw [← toInvSubmonoid_eq_mk']\n  exact ⟨fun h => ⟨_, congr_arg Subtype.val (toInvSubmonoid_surjective M S ⟨x, h⟩).choose_spec⟩,\n    fun h => h.choose_spec ▸ (toInvSubmonoid M S h.choose).prop⟩\n\n"}
{"name":"IsLocalization.span_invSubmonoid","module":"Mathlib.RingTheory.Localization.InvSubmonoid","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\n⊢ Eq (Submodule.span R ↑(IsLocalization.invSubmonoid M S)) Top.top","decl":"theorem span_invSubmonoid : Submodule.span R (invSubmonoid M S : Set S) = ⊤ := by\n  rw [eq_top_iff]\n  rintro x -\n  rcases IsLocalization.surj'' M x with ⟨r, m, rfl⟩\n  exact Submodule.smul_mem _ _ (Submodule.subset_span (toInvSubmonoid M S m).prop)\n\n"}
{"name":"IsLocalization.finiteType_of_monoid_fg","module":"Mathlib.RingTheory.Localization.InvSubmonoid","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝³ : CommRing S\ninst✝² : Algebra R S\ninst✝¹ : IsLocalization M S\ninst✝ : Monoid.FG (Subtype fun x => Membership.mem M x)\n⊢ Algebra.FiniteType R S","decl":"theorem finiteType_of_monoid_fg [Monoid.FG M] : Algebra.FiniteType R S := by\n  have := Monoid.fg_of_surjective _ (toInvSubmonoid_surjective M S)\n  rw [Monoid.fg_iff_submonoid_fg] at this\n  rcases this with ⟨s, hs⟩\n  refine ⟨⟨s, ?_⟩⟩\n  rw [eq_top_iff]\n  rintro x -\n  change x ∈ (Subalgebra.toSubmodule (Algebra.adjoin R _ : Subalgebra R S) : Set S)\n  rw [Algebra.adjoin_eq_span, hs, span_invSubmonoid]\n  trivial\n\n"}
