{"name":"Complex.le_def","module":"Mathlib.Data.Complex.Order","initialProofState":"z w : Complex\n⊢ Iff (LE.le z w) (And (LE.le z.re w.re) (Eq z.im w.im))","decl":"theorem le_def {z w : ℂ} : z ≤ w ↔ z.re ≤ w.re ∧ z.im = w.im :=\n  Iff.rfl\n\n"}
{"name":"Complex.lt_def","module":"Mathlib.Data.Complex.Order","initialProofState":"z w : Complex\n⊢ Iff (LT.lt z w) (And (LT.lt z.re w.re) (Eq z.im w.im))","decl":"theorem lt_def {z w : ℂ} : z < w ↔ z.re < w.re ∧ z.im = w.im :=\n  Iff.rfl\n\n"}
{"name":"Complex.nonneg_iff","module":"Mathlib.Data.Complex.Order","initialProofState":"z : Complex\n⊢ Iff (LE.le 0 z) (And (LE.le 0 z.re) (Eq 0 z.im))","decl":"theorem nonneg_iff {z : ℂ} : 0 ≤ z ↔ 0 ≤ z.re ∧ 0 = z.im :=\n  le_def\n\n"}
{"name":"Complex.pos_iff","module":"Mathlib.Data.Complex.Order","initialProofState":"z : Complex\n⊢ Iff (LT.lt 0 z) (And (LT.lt 0 z.re) (Eq 0 z.im))","decl":"theorem pos_iff {z : ℂ} : 0 < z ↔ 0 < z.re ∧ 0 = z.im :=\n  lt_def\n\n"}
{"name":"Complex.nonpos_iff","module":"Mathlib.Data.Complex.Order","initialProofState":"z : Complex\n⊢ Iff (LE.le z 0) (And (LE.le z.re 0) (Eq z.im 0))","decl":"theorem nonpos_iff {z : ℂ} : z ≤ 0 ↔ z.re ≤ 0 ∧ z.im = 0 :=\n  le_def\n\n"}
{"name":"Complex.neg_iff","module":"Mathlib.Data.Complex.Order","initialProofState":"z : Complex\n⊢ Iff (LT.lt z 0) (And (LT.lt z.re 0) (Eq z.im 0))","decl":"theorem neg_iff {z : ℂ} : z < 0 ↔ z.re < 0 ∧ z.im = 0 :=\n  lt_def\n\n"}
{"name":"Complex.real_le_real","module":"Mathlib.Data.Complex.Order","initialProofState":"x y : Real\n⊢ Iff (LE.le ↑x ↑y) (LE.le x y)","decl":"@[simp, norm_cast]\ntheorem real_le_real {x y : ℝ} : (x : ℂ) ≤ (y : ℂ) ↔ x ≤ y := by simp [le_def, ofReal]\n\n"}
{"name":"Complex.real_lt_real","module":"Mathlib.Data.Complex.Order","initialProofState":"x y : Real\n⊢ Iff (LT.lt ↑x ↑y) (LT.lt x y)","decl":"@[simp, norm_cast]\ntheorem real_lt_real {x y : ℝ} : (x : ℂ) < (y : ℂ) ↔ x < y := by simp [lt_def, ofReal]\n\n"}
{"name":"Complex.zero_le_real","module":"Mathlib.Data.Complex.Order","initialProofState":"x : Real\n⊢ Iff (LE.le 0 ↑x) (LE.le 0 x)","decl":"@[simp, norm_cast]\ntheorem zero_le_real {x : ℝ} : (0 : ℂ) ≤ (x : ℂ) ↔ 0 ≤ x :=\n  real_le_real\n\n"}
{"name":"Complex.zero_lt_real","module":"Mathlib.Data.Complex.Order","initialProofState":"x : Real\n⊢ Iff (LT.lt 0 ↑x) (LT.lt 0 x)","decl":"@[simp, norm_cast]\ntheorem zero_lt_real {x : ℝ} : (0 : ℂ) < (x : ℂ) ↔ 0 < x :=\n  real_lt_real\n\n"}
{"name":"Complex.not_le_iff","module":"Mathlib.Data.Complex.Order","initialProofState":"z w : Complex\n⊢ Iff (Not (LE.le z w)) (Or (LT.lt w.re z.re) (Ne z.im w.im))","decl":"theorem not_le_iff {z w : ℂ} : ¬z ≤ w ↔ w.re < z.re ∨ z.im ≠ w.im := by\n  rw [le_def, not_and_or, not_le]\n\n"}
{"name":"Complex.not_lt_iff","module":"Mathlib.Data.Complex.Order","initialProofState":"z w : Complex\n⊢ Iff (Not (LT.lt z w)) (Or (LE.le w.re z.re) (Ne z.im w.im))","decl":"theorem not_lt_iff {z w : ℂ} : ¬z < w ↔ w.re ≤ z.re ∨ z.im ≠ w.im := by\n  rw [lt_def, not_and_or, not_lt]\n\n"}
{"name":"Complex.not_le_zero_iff","module":"Mathlib.Data.Complex.Order","initialProofState":"z : Complex\n⊢ Iff (Not (LE.le z 0)) (Or (LT.lt 0 z.re) (Ne z.im 0))","decl":"theorem not_le_zero_iff {z : ℂ} : ¬z ≤ 0 ↔ 0 < z.re ∨ z.im ≠ 0 :=\n  not_le_iff\n\n"}
{"name":"Complex.not_lt_zero_iff","module":"Mathlib.Data.Complex.Order","initialProofState":"z : Complex\n⊢ Iff (Not (LT.lt z 0)) (Or (LE.le 0 z.re) (Ne z.im 0))","decl":"theorem not_lt_zero_iff {z : ℂ} : ¬z < 0 ↔ 0 ≤ z.re ∨ z.im ≠ 0 :=\n  not_lt_iff\n\n"}
{"name":"Complex.eq_re_of_ofReal_le","module":"Mathlib.Data.Complex.Order","initialProofState":"r : Real\nz : Complex\nhz : LE.le (↑r) z\n⊢ Eq z ↑z.re","decl":"theorem eq_re_of_ofReal_le {r : ℝ} {z : ℂ} (hz : (r : ℂ) ≤ z) : z = z.re := by\n  rw [eq_comm, ← conj_eq_iff_re, conj_eq_iff_im, ← (Complex.le_def.1 hz).2, Complex.ofReal_im]\n\n"}
{"name":"Complex.re_eq_abs","module":"Mathlib.Data.Complex.Order","initialProofState":"z : Complex\n⊢ Iff (Eq z.re (Complex.abs z)) (LE.le 0 z)","decl":"@[simp]\nlemma re_eq_abs {z : ℂ} : z.re = abs z ↔ 0 ≤ z :=\n  have : 0 ≤ abs z := apply_nonneg abs z\n  ⟨fun h ↦ ⟨h.symm ▸ this, (abs_re_eq_abs.1 <| h.symm ▸ _root_.abs_of_nonneg this).symm⟩,\n    fun ⟨h₁, h₂⟩ ↦ by rw [← abs_re_eq_abs.2 h₂.symm, _root_.abs_of_nonneg h₁]⟩\n\n"}
{"name":"Complex.neg_re_eq_abs","module":"Mathlib.Data.Complex.Order","initialProofState":"z : Complex\n⊢ Iff (Eq (Neg.neg z.re) (Complex.abs z)) (LE.le z 0)","decl":"@[simp]\nlemma neg_re_eq_abs {z : ℂ} : -z.re = abs z ↔ z ≤ 0 := by\n  rw [← neg_re, ← abs.map_neg, re_eq_abs]\n  exact neg_nonneg.and <| eq_comm.trans neg_eq_zero\n\n"}
{"name":"Complex.re_eq_neg_abs","module":"Mathlib.Data.Complex.Order","initialProofState":"z : Complex\n⊢ Iff (Eq z.re (Neg.neg (Complex.abs z))) (LE.le z 0)","decl":"@[simp]\nlemma re_eq_neg_abs {z : ℂ} : z.re = -abs z ↔ z ≤ 0 := by rw [← neg_eq_iff_eq_neg, neg_re_eq_abs]\n\n"}
{"name":"Complex.monotone_ofReal","module":"Mathlib.Data.Complex.Order","initialProofState":"⊢ Monotone Complex.ofReal","decl":"lemma monotone_ofReal : Monotone ofReal := by\n  intro x y hxy\n  simp only [ofRealHom_eq_coe, real_le_real, hxy]\n\n"}
