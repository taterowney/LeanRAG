{"name":"NumberField.Units.dirichletUnitTheorem.logEmbedding_component","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : Units (NumberField.RingOfIntegers K)\nw : Subtype fun w => Ne w NumberField.Units.dirichletUnitTheorem.wâ‚€\nâŠ¢ Eq ((NumberField.Units.logEmbedding K) (Additive.ofMul x) w) (HMul.hMul (â†‘(â†‘w).mult) (Real.log (â†‘w ((algebraMap (NumberField.RingOfIntegers K) K) â†‘x))))","decl":"@[simp]\ntheorem logEmbedding_component (x : (ğ“ K)Ë£) (w : {w : InfinitePlace K // w â‰  wâ‚€}) :\n    (logEmbedding K (Additive.ofMul x)) w = mult w.val * Real.log (w.val x) := rfl\n\n"}
{"name":"NumberField.Units.dirichletUnitTheorem.sum_logEmbedding_component","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : Units (NumberField.RingOfIntegers K)\nâŠ¢ Eq (Finset.univ.sum fun w => (NumberField.Units.logEmbedding K) (Additive.ofMul x) w) (HMul.hMul (Neg.neg â†‘NumberField.Units.dirichletUnitTheorem.wâ‚€.mult) (Real.log (NumberField.Units.dirichletUnitTheorem.wâ‚€ ((algebraMap (NumberField.RingOfIntegers K) K) â†‘x))))","decl":"open scoped Classical in\ntheorem sum_logEmbedding_component (x : (ğ“ K)Ë£) :\n    âˆ‘ w, logEmbedding K (Additive.ofMul x) w =\n      - mult (wâ‚€ : InfinitePlace K) * Real.log (wâ‚€ (x : K)) := by\n  have h := congr_arg Real.log (prod_eq_abs_norm (x : K))\n  rw [Units.norm, Rat.cast_one, Real.log_one, Real.log_prod] at h\n  Â· simp_rw [Real.log_pow] at h\n    rw [â† insert_erase (mem_univ wâ‚€), sum_insert (not_mem_erase wâ‚€ univ), add_comm,\n      add_eq_zero_iff_eq_neg] at h\n    convert h using 1\n    Â· refine (sum_subtype _ (fun w => ?_) (fun w => (mult w) * (Real.log (w (x : K))))).symm\n      exact âŸ¨ne_of_mem_erase, fun h => mem_erase_of_ne_of_mem h (mem_univ w)âŸ©\n    Â· norm_num\n  Â· exact fun w _ => pow_ne_zero _ (AbsoluteValue.ne_zero _ (coe_ne_zero x))\n\n"}
{"name":"NumberField.Units.dirichletUnitTheorem.mult_log_place_eq_zero","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninstâœ : Field K\nx : Units (NumberField.RingOfIntegers K)\nw : NumberField.InfinitePlace K\nâŠ¢ Iff (Eq (HMul.hMul (â†‘w.mult) (Real.log (w ((algebraMap (NumberField.RingOfIntegers K) K) â†‘x)))) 0) (Eq (w ((algebraMap (NumberField.RingOfIntegers K) K) â†‘x)) 1)","decl":"theorem mult_log_place_eq_zero {x : (ğ“ K)Ë£} {w : InfinitePlace K} :\n    mult w * Real.log (w x) = 0 â†” w x = 1 := by\n  rw [mul_eq_zero, or_iff_right, Real.log_eq_zero, or_iff_right, or_iff_left]\n  Â· linarith [(apply_nonneg _ _ : 0 â‰¤ w x)]\n  Â· simp only [ne_eq, map_eq_zero, coe_ne_zero x, not_false_eq_true]\n  Â· refine (ne_of_gt ?_)\n    rw [mult]; split_ifs <;> norm_num\n\n"}
{"name":"NumberField.Units.dirichletUnitTheorem.logEmbedding_eq_zero_iff","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : Units (NumberField.RingOfIntegers K)\nâŠ¢ Iff (Eq ((NumberField.Units.logEmbedding K) (Additive.ofMul x)) 0) (Membership.mem (NumberField.Units.torsion K) x)","decl":"theorem logEmbedding_eq_zero_iff {x : (ğ“ K)Ë£} :\n    logEmbedding K (Additive.ofMul x) = 0 â†” x âˆˆ torsion K := by\n  rw [mem_torsion]\n  refine âŸ¨fun h w => ?_, fun h => ?_âŸ©\n  Â· by_cases hw : w = wâ‚€\n    Â· suffices -mult wâ‚€ * Real.log (wâ‚€ (x : K)) = 0 by\n        rw [neg_mul, neg_eq_zero, â† hw] at this\n        exact mult_log_place_eq_zero.mp this\n      rw [â† sum_logEmbedding_component, sum_eq_zero]\n      exact fun w _ => congrFun h w\n    Â· exact mult_log_place_eq_zero.mp (congrFun h âŸ¨w, hwâŸ©)\n  Â· ext w\n    rw [logEmbedding_component, h w.val, Real.log_one, mul_zero, Pi.zero_apply]\n\n"}
{"name":"NumberField.Units.dirichletUnitTheorem.logEmbedding_component_le","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nr : Real\nx : Units (NumberField.RingOfIntegers K)\nhr : LE.le 0 r\nh : LE.le (Norm.norm ((NumberField.Units.logEmbedding K) x)) r\nw : Subtype fun w => Ne w NumberField.Units.dirichletUnitTheorem.wâ‚€\nâŠ¢ LE.le (abs ((NumberField.Units.logEmbedding K) (Additive.ofMul x) w)) r","decl":"open scoped Classical in\ntheorem logEmbedding_component_le {r : â„} {x : (ğ“ K)Ë£} (hr : 0 â‰¤ r) (h : â€–logEmbedding K xâ€– â‰¤ r)\n    (w : {w : InfinitePlace K // w â‰  wâ‚€}) : |logEmbedding K (Additive.ofMul x) w| â‰¤ r := by\n  lift r to NNReal using hr\n  simp_rw [Pi.norm_def, NNReal.coe_le_coe, Finset.sup_le_iff, â† NNReal.coe_le_coe] at h\n  exact h w (mem_univ _)\n\n"}
{"name":"NumberField.Units.dirichletUnitTheorem.log_le_of_logEmbedding_le","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nr : Real\nx : Units (NumberField.RingOfIntegers K)\nhr : LE.le 0 r\nh : LE.le (Norm.norm ((NumberField.Units.logEmbedding K) (Additive.ofMul x))) r\nw : NumberField.InfinitePlace K\nâŠ¢ LE.le (abs (Real.log (w ((algebraMap (NumberField.RingOfIntegers K) K) â†‘x)))) (HMul.hMul (â†‘(Fintype.card (NumberField.InfinitePlace K))) r)","decl":"open scoped Classical in\ntheorem log_le_of_logEmbedding_le {r : â„} {x : (ğ“ K)Ë£} (hr : 0 â‰¤ r)\n    (h : â€–logEmbedding K (Additive.ofMul x)â€– â‰¤ r) (w : InfinitePlace K) :\n    |Real.log (w x)| â‰¤ (Fintype.card (InfinitePlace K)) * r := by\n  have tool : âˆ€ x : â„, 0 â‰¤ x â†’ x â‰¤ mult w * x := fun x hx => by\n    nth_rw 1 [â† one_mul x]\n    refine mul_le_mul ?_ le_rfl hx ?_\n    all_goals { rw [mult]; split_ifs <;> norm_num }\n  by_cases hw : w = wâ‚€\n  Â· have hyp := congr_arg (â€–Â·â€–) (sum_logEmbedding_component x).symm\n    replace hyp := (le_of_eq hyp).trans (norm_sum_le _ _)\n    simp_rw [norm_mul, norm_neg, Real.norm_eq_abs, Nat.abs_cast] at hyp\n    refine (le_trans ?_ hyp).trans ?_\n    Â· rw [â† hw]\n      exact tool _ (abs_nonneg _)\n    Â· refine (sum_le_card_nsmul univ _ _\n        (fun w _ => logEmbedding_component_le hr h w)).trans ?_\n      rw [nsmul_eq_mul]\n      refine mul_le_mul ?_ le_rfl hr (Fintype.card (InfinitePlace K)).cast_nonneg\n      simp [card_univ]\n  Â· have hyp := logEmbedding_component_le hr h âŸ¨w, hwâŸ©\n    rw [logEmbedding_component, abs_mul, Nat.abs_cast] at hyp\n    refine (le_trans ?_ hyp).trans ?_\n    Â· exact tool _ (abs_nonneg _)\n    Â· nth_rw 1 [â† one_mul r]\n      exact mul_le_mul (Nat.one_le_cast.mpr Fintype.card_pos) (le_of_eq rfl) hr (Nat.cast_nonneg _)\n\n"}
{"name":"NumberField.Units.dirichletUnitTheorem.unitLattice_inter_ball_finite","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nr : Real\nâŠ¢ (Inter.inter (â†‘(NumberField.Units.unitLattice K)) (Metric.closedBall 0 r)).Finite","decl":"open scoped Classical in\ntheorem unitLattice_inter_ball_finite (r : â„) :\n    ((unitLattice K : Set ({ w : InfinitePlace K // w â‰  wâ‚€} â†’ â„)) âˆ©\n      Metric.closedBall 0 r).Finite := by\n  obtain hr | hr := lt_or_le r 0\n  Â· convert Set.finite_empty\n    rw [Metric.closedBall_eq_empty.mpr hr]\n    exact Set.inter_empty _\n  Â· suffices {x : (ğ“ K)Ë£ | IsIntegral â„¤ (x : K) âˆ§\n        âˆ€ (Ï† : K â†’+* â„‚), â€–Ï† xâ€– â‰¤ Real.exp ((Fintype.card (InfinitePlace K)) * r)}.Finite by\n      refine (Set.Finite.image (logEmbedding K) this).subset ?_\n      rintro _ âŸ¨âŸ¨x, âŸ¨_, rflâŸ©âŸ©, hxâŸ©\n      refine âŸ¨x, âŸ¨x.val.prop, (le_iff_le _ _).mp (fun w => (Real.log_le_iff_le_exp ?_).mp ?_)âŸ©, rflâŸ©\n      Â· exact pos_iff.mpr (coe_ne_zero x)\n      Â· rw [mem_closedBall_zero_iff] at hx\n        exact (le_abs_self _).trans (log_le_of_logEmbedding_le hr hx w)\n    refine Set.Finite.of_finite_image ?_ (coe_injective K).injOn\n    refine (Embeddings.finite_of_norm_le K â„‚\n        (Real.exp ((Fintype.card (InfinitePlace K)) * r))).subset ?_\n    rintro _ âŸ¨x, âŸ¨âŸ¨h_int, h_leâŸ©, rflâŸ©âŸ©\n    exact âŸ¨h_int, h_leâŸ©\n\n"}
{"name":"NumberField.Units.dirichletUnitTheorem.seq_next","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nwâ‚ : NumberField.InfinitePlace K\nB : Nat\nhB : LT.lt (NumberField.mixedEmbedding.minkowskiBound K 1) (HMul.hMul â†‘(NumberField.mixedEmbedding.convexBodyLTFactor K) â†‘B)\nx : NumberField.RingOfIntegers K\nhx : Ne x 0\nâŠ¢ Exists fun y => And (Ne y 0) (And (âˆ€ (w : NumberField.InfinitePlace K), Ne w wâ‚ â†’ LT.lt (w â†‘y) (w â†‘x)) (LE.le (abs ((Algebra.norm Rat) â†‘y)) â†‘B))","decl":"include hB in\n/-- This result shows that there always exists a next term in the sequence. -/\ntheorem seq_next {x : ğ“ K} (hx : x â‰  0) :\n    âˆƒ y : ğ“ K, y â‰  0 âˆ§\n      (âˆ€ w, w â‰  wâ‚ â†’ w y < w x) âˆ§\n      |Algebra.norm â„š (y : K)| â‰¤ B := by\n  have hx' := RingOfIntegers.coe_ne_zero_iff.mpr hx\n  let f : InfinitePlace K â†’ â„â‰¥0 :=\n    fun w => âŸ¨(w x) / 2, div_nonneg (AbsoluteValue.nonneg _ _) (by norm_num)âŸ©\n  suffices âˆ€ w, w â‰  wâ‚ â†’ f w â‰  0 by\n    obtain âŸ¨g, h_geqf, h_gprodâŸ© := adjust_f K B this\n    obtain âŸ¨y, h_ynz, h_yleâŸ© := exists_ne_zero_mem_ringOfIntegers_lt K (f := g)\n      (by rw [convexBodyLT_volume]; convert hB; exact congr_arg ((â†‘) : NNReal â†’ ENNReal) h_gprod)\n    refine âŸ¨y, h_ynz, fun w hw => (h_geqf w hw â–¸ h_yle w).trans ?_, ?_âŸ©\n    Â· rw [â† Rat.cast_le (K := â„), Rat.cast_natCast]\n      calc\n        _ = âˆ w : InfinitePlace K, w (algebraMap _ K y) ^ mult w :=\n          (prod_eq_abs_norm (algebraMap _ K y)).symm\n        _ â‰¤ âˆ w : InfinitePlace K, (g w : â„) ^ mult w := by gcongr with w; exact (h_yle w).le\n        _ â‰¤ (B : â„) := by\n          simp_rw [â† NNReal.coe_pow, â† NNReal.coe_prod]\n          exact le_of_eq (congr_arg toReal h_gprod)\n    Â· refine div_lt_self ?_ (by norm_num)\n      exact pos_iff.mpr hx'\n  intro _ _\n  rw [ne_eq, Nonneg.mk_eq_zero, div_eq_zero_iff, map_eq_zero, not_or]\n  exact âŸ¨hx', by norm_numâŸ©\n\n"}
{"name":"NumberField.Units.dirichletUnitTheorem.seq_ne_zero","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nwâ‚ : NumberField.InfinitePlace K\nB : Nat\nhB : LT.lt (NumberField.mixedEmbedding.minkowskiBound K 1) (HMul.hMul â†‘(NumberField.mixedEmbedding.convexBodyLTFactor K) â†‘B)\nn : Nat\nâŠ¢ Ne ((algebraMap (NumberField.RingOfIntegers K) K) â†‘(NumberField.Units.dirichletUnitTheorem.seq K wâ‚ hB n)) 0","decl":"/-- The terms of the sequence are nonzero. -/\ntheorem seq_ne_zero (n : â„•) : algebraMap (ğ“ K) K (seq K wâ‚ hB n) â‰  0 :=\n  RingOfIntegers.coe_ne_zero_iff.mpr (seq K wâ‚ hB n).prop\n\n"}
{"name":"NumberField.Units.dirichletUnitTheorem.seq_decreasing","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nwâ‚ : NumberField.InfinitePlace K\nB : Nat\nhB : LT.lt (NumberField.mixedEmbedding.minkowskiBound K 1) (HMul.hMul â†‘(NumberField.mixedEmbedding.convexBodyLTFactor K) â†‘B)\nn m : Nat\nh : LT.lt n m\nw : NumberField.InfinitePlace K\nhw : Ne w wâ‚\nâŠ¢ LT.lt (w ((algebraMap (NumberField.RingOfIntegers K) K) â†‘(NumberField.Units.dirichletUnitTheorem.seq K wâ‚ hB m))) (w ((algebraMap (NumberField.RingOfIntegers K) K) â†‘(NumberField.Units.dirichletUnitTheorem.seq K wâ‚ hB n)))","decl":"/-- The sequence is strictly decreasing at infinite places distinct from `wâ‚`. -/\ntheorem seq_decreasing {n m : â„•} (h : n < m) (w : InfinitePlace K) (hw : w â‰  wâ‚) :\n    w (algebraMap (ğ“ K) K (seq K wâ‚ hB m)) < w (algebraMap (ğ“ K) K (seq K wâ‚ hB n)) := by\n  induction m with\n  | zero =>\n      exfalso\n      exact Nat.not_succ_le_zero n h\n  | succ m m_ih =>\n      cases eq_or_lt_of_le (Nat.le_of_lt_succ h) with\n      | inl hr =>\n          rw [hr]\n          exact (seq_next K wâ‚ hB (seq K wâ‚ hB m).prop).choose_spec.2.1 w hw\n      | inr hr =>\n          refine lt_trans ?_ (m_ih hr)\n          exact (seq_next K wâ‚ hB (seq K wâ‚ hB m).prop).choose_spec.2.1 w hw\n\n"}
{"name":"NumberField.Units.dirichletUnitTheorem.seq_norm_le","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nwâ‚ : NumberField.InfinitePlace K\nB : Nat\nhB : LT.lt (NumberField.mixedEmbedding.minkowskiBound K 1) (HMul.hMul â†‘(NumberField.mixedEmbedding.convexBodyLTFactor K) â†‘B)\nn : Nat\nâŠ¢ LE.le ((Algebra.norm Int) â†‘(NumberField.Units.dirichletUnitTheorem.seq K wâ‚ hB n)).natAbs B","decl":"/-- The terms of the sequence have norm bounded by `B`. -/\ntheorem seq_norm_le (n : â„•) :\n    Int.natAbs (Algebra.norm â„¤ (seq K wâ‚ hB n : ğ“ K)) â‰¤ B := by\n  cases n with\n  | zero =>\n      have : 1 â‰¤ B := by\n        contrapose! hB\n        simp only [Nat.lt_one_iff.mp hB, CharP.cast_eq_zero, mul_zero, zero_le]\n      simp only [ne_eq, seq, map_one, Int.natAbs_one, this]\n  | succ n =>\n      rw [â† Nat.cast_le (Î± := â„š), Int.cast_natAbs, Int.cast_abs, Algebra.coe_norm_int]\n      exact (seq_next K wâ‚ hB (seq K wâ‚ hB n).prop).choose_spec.2.2\n\n"}
{"name":"NumberField.Units.dirichletUnitTheorem.exists_unit","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nwâ‚ : NumberField.InfinitePlace K\nâŠ¢ Exists fun u => âˆ€ (w : NumberField.InfinitePlace K), Ne w wâ‚ â†’ LT.lt (Real.log (w ((algebraMap (NumberField.RingOfIntegers K) K) â†‘u))) 0","decl":"/-- Construct a unit associated to the place `wâ‚`. The family, for `wâ‚ â‰  wâ‚€`, formed by the\nimage by the `logEmbedding` of these units is `â„`-linearly independent, see\n`unitLattice_span_eq_top`. -/\ntheorem exists_unit (wâ‚ : InfinitePlace K) :\n    âˆƒ u : (ğ“ K)Ë£, âˆ€ w : InfinitePlace K, w â‰  wâ‚ â†’ Real.log (w u) < 0 := by\n  obtain âŸ¨B, hBâŸ© : âˆƒ B : â„•, minkowskiBound K 1 < (convexBodyLTFactor K) * B := by\n    conv => congr; ext; rw [mul_comm]\n    exact ENNReal.exists_nat_mul_gt (ENNReal.coe_ne_zero.mpr (convexBodyLTFactor_ne_zero K))\n      (ne_of_lt (minkowskiBound_lt_top K 1))\n  rsuffices âŸ¨n, m, hnm, hâŸ© : âˆƒ n m, n < m âˆ§\n      (Ideal.span ({ (seq K wâ‚ hB n : ğ“ K) }) = Ideal.span ({ (seq K wâ‚ hB m : ğ“ K) }))\n  Â· have hu := Ideal.span_singleton_eq_span_singleton.mp h\n    refine âŸ¨hu.choose, fun w hw => Real.log_neg ?_ ?_âŸ©\n    Â· exact pos_iff.mpr (coe_ne_zero _)\n    Â· calc\n        _ = w (algebraMap (ğ“ K) K (seq K wâ‚ hB m) * (algebraMap (ğ“ K) K (seq K wâ‚ hB n))â»Â¹) := by\n          rw [â† congr_arg (algebraMap (ğ“ K) K) hu.choose_spec, mul_comm, map_mul (algebraMap _ _),\n          â† mul_assoc, inv_mul_cancelâ‚€ (seq_ne_zero K wâ‚ hB n), one_mul]\n      _ = w (algebraMap (ğ“ K) K (seq K wâ‚ hB m)) * w (algebraMap (ğ“ K) K (seq K wâ‚ hB n))â»Â¹ :=\n        _root_.map_mul _ _ _\n      _ < 1 := by\n        rw [map_invâ‚€, mul_inv_lt_iffâ‚€' (pos_iff.mpr (seq_ne_zero K wâ‚ hB n)), mul_one]\n        exact seq_decreasing K wâ‚ hB hnm w hw\n  refine Set.Finite.exists_lt_map_eq_of_forall_mem (t := {I : Ideal (ğ“ K) | Ideal.absNorm I â‰¤ B})\n    (fun n â†¦ ?_) (Ideal.finite_setOf_absNorm_le B)\n  rw [Set.mem_setOf_eq, Ideal.absNorm_span_singleton]\n  exact seq_norm_le K wâ‚ hB n\n\n"}
{"name":"NumberField.Units.dirichletUnitTheorem.unitLattice_span_eq_top","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nâŠ¢ Eq (Submodule.span Real â†‘(NumberField.Units.unitLattice K)) Top.top","decl":"theorem unitLattice_span_eq_top :\n    Submodule.span â„ (unitLattice K : Set ({w : InfinitePlace K // w â‰  wâ‚€} â†’ â„)) = âŠ¤ := by\n  classical\n  refine le_antisymm le_top ?_\n  -- The standard basis\n  let B := Pi.basisFun â„ {w : InfinitePlace K // w â‰  wâ‚€}\n  -- The image by log_embedding of the family of units constructed above\n  let v := fun w : { w : InfinitePlace K // w â‰  wâ‚€ } =>\n    logEmbedding K (Additive.ofMul (exists_unit K w).choose)\n  -- To prove the result, it is enough to prove that the family `v` is linearly independent\n  suffices B.det v â‰  0 by\n    rw [â† isUnit_iff_ne_zero, â† is_basis_iff_det] at this\n    rw [â† this.2]\n    refine  Submodule.span_monotone fun _ âŸ¨w, hwâŸ© â†¦ âŸ¨(exists_unit K w).choose, trivial, hwâŸ©\n  rw [Basis.det_apply]\n  -- We use a specific lemma to prove that this determinant is nonzero\n  refine det_ne_zero_of_sum_col_lt_diag (fun w => ?_)\n  simp_rw [Real.norm_eq_abs, B, Basis.coePiBasisFun.toMatrix_eq_transpose, Matrix.transpose_apply]\n  rw [â† sub_pos, sum_congr rfl (fun x hx => abs_of_neg ?_), sum_neg_distrib, sub_neg_eq_add,\n    sum_erase_eq_sub (mem_univ _), â† add_comm_sub]\n  Â· refine add_pos_of_nonneg_of_pos ?_ ?_\n    Â· rw [sub_nonneg]\n      exact le_abs_self _\n    Â· rw [sum_logEmbedding_component (exists_unit K w).choose]\n      refine mul_pos_of_neg_of_neg ?_ ((exists_unit K w).choose_spec _ w.prop.symm)\n      rw [mult]; split_ifs <;> norm_num\n  Â· refine mul_neg_of_pos_of_neg ?_ ((exists_unit K w).choose_spec x ?_)\n    Â· rw [mult]; split_ifs <;> norm_num\n    Â· exact Subtype.ext_iff_val.not.mp (ne_of_mem_erase hx)\n\n"}
{"name":"NumberField.Units.instDiscrete_unitLattice","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nâŠ¢ DiscreteTopology (Subtype fun x => Membership.mem (NumberField.Units.unitLattice K) x)","decl":"instance instDiscrete_unitLattice : DiscreteTopology (unitLattice K) := by\n  classical\n  refine discreteTopology_of_isOpen_singleton_zero ?_\n  refine isOpen_singleton_of_finite_mem_nhds 0 (s := Metric.closedBall 0 1) ?_ ?_\n  Â· exact Metric.closedBall_mem_nhds _ (by norm_num)\n  Â· refine Set.Finite.of_finite_image ?_ (Set.injOn_of_injective Subtype.val_injective)\n    convert unitLattice_inter_ball_finite K 1\n    ext x\n    refine âŸ¨?_, fun âŸ¨hx1, hx2âŸ© => âŸ¨âŸ¨x, hx1âŸ©, hx2, rflâŸ©âŸ©\n    rintro âŸ¨x, hx, rflâŸ©\n    exact âŸ¨Subtype.mem x, hxâŸ©\n\n"}
{"name":"NumberField.Units.instZLattice_unitLattice","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nâŠ¢ IsZLattice Real (NumberField.Units.unitLattice K)","decl":"open scoped Classical in\ninstance instZLattice_unitLattice : IsZLattice â„ (unitLattice K) where\n  span_top := unitLattice_span_eq_top K\n\n"}
{"name":"NumberField.Units.finrank_eq_rank","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nâŠ¢ Eq (Module.finrank Real ((Subtype fun w => Ne w NumberField.Units.dirichletUnitTheorem.wâ‚€) â†’ Real)) (NumberField.Units.rank K)","decl":"protected theorem finrank_eq_rank :\n    finrank â„ ({w : InfinitePlace K // w â‰  wâ‚€} â†’ â„) = Units.rank K := by\n  classical\n  simp only [finrank_fintype_fun_eq_card, Fintype.card_subtype_compl,\n    Fintype.card_ofSubsingleton, rank]\n\n"}
{"name":"NumberField.Units.unitLattice_rank","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nâŠ¢ Eq (Module.finrank Int (Subtype fun x => Membership.mem (NumberField.Units.unitLattice K) x)) (NumberField.Units.rank K)","decl":"@[simp]\ntheorem unitLattice_rank :\n    finrank â„¤ (unitLattice K) = Units.rank K := by\n  classical\n  rw [â† Units.finrank_eq_rank, ZLattice.rank â„]\n\n"}
{"name":"NumberField.Units.logEmbeddingQuot_apply","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : Units (NumberField.RingOfIntegers K)\nâŠ¢ Eq ((NumberField.Units.logEmbeddingQuot K) (Additive.ofMul â†‘x)) ((NumberField.Units.logEmbedding K) (Additive.ofMul x))","decl":"@[simp]\ntheorem logEmbeddingQuot_apply (x : (ğ“ K)Ë£) :\n    logEmbeddingQuot K (Additive.ofMul (QuotientGroup.mk x)) =\n      logEmbedding K (Additive.ofMul x) := rfl\n\n"}
{"name":"NumberField.Units.logEmbeddingQuot_injective","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nâŠ¢ Function.Injective â‡‘(NumberField.Units.logEmbeddingQuot K)","decl":"theorem logEmbeddingQuot_injective :\n    Function.Injective (logEmbeddingQuot K) := by\n  unfold logEmbeddingQuot\n  intro _ _ h\n  simp_rw [MonoidHom.toAdditive'_apply_apply, MonoidHom.coe_comp, MulEquiv.coe_toMonoidHom,\n    Function.comp_apply, EmbeddingLike.apply_eq_iff_eq] at h\n  exact (EmbeddingLike.apply_eq_iff_eq _).mp <| (QuotientGroup.kerLift_injective _).eq_iff.mp h\n\n"}
{"name":"NumberField.Units.logEmbeddingEquiv_apply","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : Units (NumberField.RingOfIntegers K)\nâŠ¢ Eq (â†‘((NumberField.Units.logEmbeddingEquiv K) (Additive.ofMul â†‘x))) ((NumberField.Units.logEmbedding K) (Additive.ofMul x))","decl":"@[simp]\ntheorem logEmbeddingEquiv_apply (x : (ğ“ K)Ë£) :\n    logEmbeddingEquiv K (Additive.ofMul (QuotientGroup.mk x)) =\n      logEmbedding K (Additive.ofMul x) := rfl\n\n"}
{"name":"NumberField.Units.instFreeIntAdditiveQuotientUnitsRingOfIntegersSubgroupTorsion","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninstâœ : Field K\nâŠ¢ Module.Free Int (Additive (HasQuotient.Quotient (Units (NumberField.RingOfIntegers K)) (NumberField.Units.torsion K)))","decl":"instance : Module.Free â„¤ (Additive ((ğ“ K)Ë£ â§¸ (torsion K))) := by\n  classical exact Module.Free.of_equiv (logEmbeddingEquiv K).symm\n\n"}
{"name":"NumberField.Units.instFiniteIntAdditiveQuotientUnitsRingOfIntegersSubgroupTorsion","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninstâœ : Field K\nâŠ¢ Module.Finite Int (Additive (HasQuotient.Quotient (Units (NumberField.RingOfIntegers K)) (NumberField.Units.torsion K)))","decl":"instance : Module.Finite â„¤ (Additive ((ğ“ K)Ë£ â§¸ (torsion K))) := by\n  classical exact Module.Finite.equiv (logEmbeddingEquiv K).symm\n\n-- Note that we prove this instance first and then deduce from it the instance\n-- `Monoid.FG (ğ“ K)Ë£`, and not the other way around, due to no `Subgroup` version\n-- of `Submodule.fg_of_fg_map_of_fg_inf_ker` existing.\n"}
{"name":"NumberField.Units.instFiniteIntAdditiveUnitsRingOfIntegers","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninstâœ : Field K\nâŠ¢ Module.Finite Int (Additive (Units (NumberField.RingOfIntegers K)))","decl":"instance : Module.Finite â„¤ (Additive (ğ“ K)Ë£) := by\n  rw [Module.finite_def]\n  refine Submodule.fg_of_fg_map_of_fg_inf_ker\n    (MonoidHom.toAdditive (QuotientGroup.mk' (torsion K))).toIntLinearMap ?_ ?_\n  Â· rw [Submodule.map_top, LinearMap.range_eq_top.mpr\n      (by exact QuotientGroup.mk'_surjective (torsion K)), â† Module.finite_def]\n    infer_instance\n  Â· rw [inf_of_le_right le_top, AddMonoidHom.coe_toIntLinearMap_ker, MonoidHom.coe_toAdditive_ker,\n      QuotientGroup.ker_mk', Submodule.fg_iff_add_subgroup_fg,\n      AddSubgroup.toIntSubmodule_toAddSubgroup, â† AddGroup.fg_iff_addSubgroup_fg]\n    have : Finite (Subgroup.toAddSubgroup (torsion K)) := (inferInstance : Finite (torsion K))\n    exact AddGroup.fg_of_finite\n\n"}
{"name":"NumberField.Units.instFGUnitsRingOfIntegers","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninstâœ : Field K\nâŠ¢ Monoid.FG (Units (NumberField.RingOfIntegers K))","decl":"instance : Monoid.FG (ğ“ K)Ë£ := by\n  rw [Monoid.fg_iff_add_fg, â† AddGroup.fg_iff_addMonoid_fg, â† Module.Finite.iff_addGroup_fg]\n  infer_instance\n\n"}
{"name":"NumberField.Units.rank_modTorsion","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nâŠ¢ Eq (Module.finrank Int (Additive (HasQuotient.Quotient (Units (NumberField.RingOfIntegers K)) (NumberField.Units.torsion K)))) (NumberField.Units.rank K)","decl":"theorem rank_modTorsion :\n    Module.finrank â„¤ (Additive ((ğ“ K)Ë£ â§¸ (torsion K))) = rank K := by\n  rw [â† LinearEquiv.finrank_eq (logEmbeddingEquiv K).symm, unitLattice_rank]\n\n"}
{"name":"NumberField.Units.fundSystem_mk","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\ni : Fin (NumberField.Units.rank K)\nâŠ¢ Eq (Additive.ofMul â†‘(NumberField.Units.fundSystem K i)) ((NumberField.Units.basisModTorsion K) i)","decl":"theorem fundSystem_mk (i : Fin (rank K)) :\n    Additive.ofMul (QuotientGroup.mk (fundSystem K i)) = (basisModTorsion K i) := by\n  simp_rw [fundSystem, Equiv.apply_eq_iff_eq_symm_apply, Additive.ofMul_symm_eq, Quotient.out_eq']\n\n"}
{"name":"NumberField.Units.logEmbedding_fundSystem","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\ni : Fin (NumberField.Units.rank K)\nâŠ¢ Eq ((NumberField.Units.logEmbedding K) (Additive.ofMul (NumberField.Units.fundSystem K i))) â†‘((NumberField.Units.basisUnitLattice K) i)","decl":"theorem logEmbedding_fundSystem (i : Fin (rank K)) :\n    logEmbedding K (Additive.ofMul (fundSystem K i)) = basisUnitLattice K i := by\n  rw [basisUnitLattice, Basis.map_apply, â† fundSystem_mk, logEmbeddingEquiv_apply]\n\n"}
{"name":"NumberField.Units.fun_eq_repr","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx Î¶ : Units (NumberField.RingOfIntegers K)\nf : Fin (NumberField.Units.rank K) â†’ Int\nhÎ¶ : Membership.mem (NumberField.Units.torsion K) Î¶\nh : Eq x (HMul.hMul Î¶ (Finset.univ.prod fun i => HPow.hPow (NumberField.Units.fundSystem K i) (f i)))\nâŠ¢ Eq f â‡‘((NumberField.Units.basisModTorsion K).repr (Additive.ofMul â†‘x))","decl":"/-- The exponents that appear in the unique decomposition of a unit as the product of\na root of unity and powers of the units of the fundamental system `fundSystem` (see\n`exist_unique_eq_mul_prod`) are given by the representation of the unit on `basisModTorsion`. -/\ntheorem fun_eq_repr {x Î¶ : (ğ“ K)Ë£} {f : Fin (rank K) â†’ â„¤} (hÎ¶ : Î¶ âˆˆ torsion K)\n    (h : x = Î¶ * âˆ i, (fundSystem K i) ^ (f i)) :\n    f = (basisModTorsion K).repr (Additive.ofMul â†‘x) := by\n  suffices Additive.ofMul â†‘x = âˆ‘ i, (f i) â€¢ (basisModTorsion K i) by\n    rw [â† (basisModTorsion K).repr_sum_self f, â† this]\n  calc\n    Additive.ofMul â†‘x\n    _ = âˆ‘ i, (f i) â€¢ Additive.ofMul â†‘(fundSystem K i) := by\n          rw [h, QuotientGroup.mk_mul, (QuotientGroup.eq_one_iff _).mpr hÎ¶, one_mul,\n            QuotientGroup.mk_prod, ofMul_prod]; rfl\n    _ = âˆ‘ i, (f i) â€¢ (basisModTorsion K i) := by\n          simp_rw [fundSystem, QuotientGroup.out_eq', ofMul_toMul]\n\n"}
{"name":"NumberField.Units.exist_unique_eq_mul_prod","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : Units (NumberField.RingOfIntegers K)\nâŠ¢ ExistsUnique fun Î¶e => Eq x (HMul.hMul (â†‘Î¶e.1) (Finset.univ.prod fun i => HPow.hPow (NumberField.Units.fundSystem K i) (Î¶e.2 i)))","decl":"/-- **Dirichlet Unit Theorem**. Any unit `x` of `ğ“ K` can be written uniquely as the product of\na root of unity and powers of the units of the fundamental system `fundSystem`. -/\ntheorem exist_unique_eq_mul_prod (x : (ğ“ K)Ë£) : âˆƒ! Î¶e : torsion K Ã— (Fin (rank K) â†’ â„¤),\n    x = Î¶e.1 * âˆ i, (fundSystem K i) ^ (Î¶e.2 i) := by\n  let Î¶ := x * (âˆ i, (fundSystem K i) ^ ((basisModTorsion K).repr (Additive.ofMul â†‘x) i))â»Â¹\n  have h_tors : Î¶ âˆˆ torsion K := by\n    rw [â† QuotientGroup.eq_one_iff, QuotientGroup.mk_mul, QuotientGroup.mk_inv, â† ofMul_eq_zero,\n      ofMul_mul, ofMul_inv, QuotientGroup.mk_prod, ofMul_prod]\n    simp_rw [QuotientGroup.mk_zpow, ofMul_zpow, fundSystem, QuotientGroup.out_eq']\n    rw [add_eq_zero_iff_eq_neg, neg_neg]\n    exact ((basisModTorsion K).sum_repr (Additive.ofMul â†‘x)).symm\n  refine âŸ¨âŸ¨âŸ¨Î¶, h_torsâŸ©, ((basisModTorsion K).repr (Additive.ofMul â†‘x) : Fin (rank K) â†’ â„¤)âŸ©, ?_, ?_âŸ©\n  Â· simp only [Î¶, _root_.inv_mul_cancel_right]\n  Â· rintro âŸ¨âŸ¨Î¶', h_tors'âŸ©, Î·âŸ© hf\n    simp only [Î¶, â† fun_eq_repr K h_tors' hf, Prod.mk.injEq, Subtype.mk.injEq, and_true]\n    nth_rewrite 1 [hf]\n    rw [_root_.mul_inv_cancel_right]\n\n"}
