{"name":"NumberField.Units.dirichletUnitTheorem.logEmbedding_component","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nx : Units (NumberField.RingOfIntegers K)\nw : Subtype fun w => Ne w NumberField.Units.dirichletUnitTheorem.w₀\n⊢ Eq ((NumberField.Units.logEmbedding K) (Additive.ofMul x) w) (HMul.hMul (↑(↑w).mult) (Real.log (↑w ((algebraMap (NumberField.RingOfIntegers K) K) ↑x))))","decl":"@[simp]\ntheorem logEmbedding_component (x : (𝓞 K)ˣ) (w : {w : InfinitePlace K // w ≠ w₀}) :\n    (logEmbedding K (Additive.ofMul x)) w = mult w.val * Real.log (w.val x) := rfl\n\n"}
{"name":"NumberField.Units.dirichletUnitTheorem.sum_logEmbedding_component","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nx : Units (NumberField.RingOfIntegers K)\n⊢ Eq (Finset.univ.sum fun w => (NumberField.Units.logEmbedding K) (Additive.ofMul x) w) (HMul.hMul (Neg.neg ↑NumberField.Units.dirichletUnitTheorem.w₀.mult) (Real.log (NumberField.Units.dirichletUnitTheorem.w₀ ((algebraMap (NumberField.RingOfIntegers K) K) ↑x))))","decl":"open scoped Classical in\ntheorem sum_logEmbedding_component (x : (𝓞 K)ˣ) :\n    ∑ w, logEmbedding K (Additive.ofMul x) w =\n      - mult (w₀ : InfinitePlace K) * Real.log (w₀ (x : K)) := by\n  have h := congr_arg Real.log (prod_eq_abs_norm (x : K))\n  rw [Units.norm, Rat.cast_one, Real.log_one, Real.log_prod] at h\n  · simp_rw [Real.log_pow] at h\n    rw [← insert_erase (mem_univ w₀), sum_insert (not_mem_erase w₀ univ), add_comm,\n      add_eq_zero_iff_eq_neg] at h\n    convert h using 1\n    · refine (sum_subtype _ (fun w => ?_) (fun w => (mult w) * (Real.log (w (x : K))))).symm\n      exact ⟨ne_of_mem_erase, fun h => mem_erase_of_ne_of_mem h (mem_univ w)⟩\n    · norm_num\n  · exact fun w _ => pow_ne_zero _ (AbsoluteValue.ne_zero _ (coe_ne_zero x))\n\n"}
{"name":"NumberField.Units.dirichletUnitTheorem.mult_log_place_eq_zero","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninst✝ : Field K\nx : Units (NumberField.RingOfIntegers K)\nw : NumberField.InfinitePlace K\n⊢ Iff (Eq (HMul.hMul (↑w.mult) (Real.log (w ((algebraMap (NumberField.RingOfIntegers K) K) ↑x)))) 0) (Eq (w ((algebraMap (NumberField.RingOfIntegers K) K) ↑x)) 1)","decl":"theorem mult_log_place_eq_zero {x : (𝓞 K)ˣ} {w : InfinitePlace K} :\n    mult w * Real.log (w x) = 0 ↔ w x = 1 := by\n  rw [mul_eq_zero, or_iff_right, Real.log_eq_zero, or_iff_right, or_iff_left]\n  · linarith [(apply_nonneg _ _ : 0 ≤ w x)]\n  · simp only [ne_eq, map_eq_zero, coe_ne_zero x, not_false_eq_true]\n  · refine (ne_of_gt ?_)\n    rw [mult]; split_ifs <;> norm_num\n\n"}
{"name":"NumberField.Units.dirichletUnitTheorem.logEmbedding_eq_zero_iff","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nx : Units (NumberField.RingOfIntegers K)\n⊢ Iff (Eq ((NumberField.Units.logEmbedding K) (Additive.ofMul x)) 0) (Membership.mem (NumberField.Units.torsion K) x)","decl":"theorem logEmbedding_eq_zero_iff {x : (𝓞 K)ˣ} :\n    logEmbedding K (Additive.ofMul x) = 0 ↔ x ∈ torsion K := by\n  rw [mem_torsion]\n  refine ⟨fun h w => ?_, fun h => ?_⟩\n  · by_cases hw : w = w₀\n    · suffices -mult w₀ * Real.log (w₀ (x : K)) = 0 by\n        rw [neg_mul, neg_eq_zero, ← hw] at this\n        exact mult_log_place_eq_zero.mp this\n      rw [← sum_logEmbedding_component, sum_eq_zero]\n      exact fun w _ => congrFun h w\n    · exact mult_log_place_eq_zero.mp (congrFun h ⟨w, hw⟩)\n  · ext w\n    rw [logEmbedding_component, h w.val, Real.log_one, mul_zero, Pi.zero_apply]\n\n"}
{"name":"NumberField.Units.dirichletUnitTheorem.logEmbedding_component_le","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nr : Real\nx : Units (NumberField.RingOfIntegers K)\nhr : LE.le 0 r\nh : LE.le (Norm.norm ((NumberField.Units.logEmbedding K) x)) r\nw : Subtype fun w => Ne w NumberField.Units.dirichletUnitTheorem.w₀\n⊢ LE.le (abs ((NumberField.Units.logEmbedding K) (Additive.ofMul x) w)) r","decl":"open scoped Classical in\ntheorem logEmbedding_component_le {r : ℝ} {x : (𝓞 K)ˣ} (hr : 0 ≤ r) (h : ‖logEmbedding K x‖ ≤ r)\n    (w : {w : InfinitePlace K // w ≠ w₀}) : |logEmbedding K (Additive.ofMul x) w| ≤ r := by\n  lift r to NNReal using hr\n  simp_rw [Pi.norm_def, NNReal.coe_le_coe, Finset.sup_le_iff, ← NNReal.coe_le_coe] at h\n  exact h w (mem_univ _)\n\n"}
{"name":"NumberField.Units.dirichletUnitTheorem.log_le_of_logEmbedding_le","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nr : Real\nx : Units (NumberField.RingOfIntegers K)\nhr : LE.le 0 r\nh : LE.le (Norm.norm ((NumberField.Units.logEmbedding K) (Additive.ofMul x))) r\nw : NumberField.InfinitePlace K\n⊢ LE.le (abs (Real.log (w ((algebraMap (NumberField.RingOfIntegers K) K) ↑x)))) (HMul.hMul (↑(Fintype.card (NumberField.InfinitePlace K))) r)","decl":"open scoped Classical in\ntheorem log_le_of_logEmbedding_le {r : ℝ} {x : (𝓞 K)ˣ} (hr : 0 ≤ r)\n    (h : ‖logEmbedding K (Additive.ofMul x)‖ ≤ r) (w : InfinitePlace K) :\n    |Real.log (w x)| ≤ (Fintype.card (InfinitePlace K)) * r := by\n  have tool : ∀ x : ℝ, 0 ≤ x → x ≤ mult w * x := fun x hx => by\n    nth_rw 1 [← one_mul x]\n    refine mul_le_mul ?_ le_rfl hx ?_\n    all_goals { rw [mult]; split_ifs <;> norm_num }\n  by_cases hw : w = w₀\n  · have hyp := congr_arg (‖·‖) (sum_logEmbedding_component x).symm\n    replace hyp := (le_of_eq hyp).trans (norm_sum_le _ _)\n    simp_rw [norm_mul, norm_neg, Real.norm_eq_abs, Nat.abs_cast] at hyp\n    refine (le_trans ?_ hyp).trans ?_\n    · rw [← hw]\n      exact tool _ (abs_nonneg _)\n    · refine (sum_le_card_nsmul univ _ _\n        (fun w _ => logEmbedding_component_le hr h w)).trans ?_\n      rw [nsmul_eq_mul]\n      refine mul_le_mul ?_ le_rfl hr (Fintype.card (InfinitePlace K)).cast_nonneg\n      simp [card_univ]\n  · have hyp := logEmbedding_component_le hr h ⟨w, hw⟩\n    rw [logEmbedding_component, abs_mul, Nat.abs_cast] at hyp\n    refine (le_trans ?_ hyp).trans ?_\n    · exact tool _ (abs_nonneg _)\n    · nth_rw 1 [← one_mul r]\n      exact mul_le_mul (Nat.one_le_cast.mpr Fintype.card_pos) (le_of_eq rfl) hr (Nat.cast_nonneg _)\n\n"}
{"name":"NumberField.Units.dirichletUnitTheorem.unitLattice_inter_ball_finite","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nr : Real\n⊢ (Inter.inter (↑(NumberField.Units.unitLattice K)) (Metric.closedBall 0 r)).Finite","decl":"open scoped Classical in\ntheorem unitLattice_inter_ball_finite (r : ℝ) :\n    ((unitLattice K : Set ({ w : InfinitePlace K // w ≠ w₀} → ℝ)) ∩\n      Metric.closedBall 0 r).Finite := by\n  obtain hr | hr := lt_or_le r 0\n  · convert Set.finite_empty\n    rw [Metric.closedBall_eq_empty.mpr hr]\n    exact Set.inter_empty _\n  · suffices {x : (𝓞 K)ˣ | IsIntegral ℤ (x : K) ∧\n        ∀ (φ : K →+* ℂ), ‖φ x‖ ≤ Real.exp ((Fintype.card (InfinitePlace K)) * r)}.Finite by\n      refine (Set.Finite.image (logEmbedding K) this).subset ?_\n      rintro _ ⟨⟨x, ⟨_, rfl⟩⟩, hx⟩\n      refine ⟨x, ⟨x.val.prop, (le_iff_le _ _).mp (fun w => (Real.log_le_iff_le_exp ?_).mp ?_)⟩, rfl⟩\n      · exact pos_iff.mpr (coe_ne_zero x)\n      · rw [mem_closedBall_zero_iff] at hx\n        exact (le_abs_self _).trans (log_le_of_logEmbedding_le hr hx w)\n    refine Set.Finite.of_finite_image ?_ (coe_injective K).injOn\n    refine (Embeddings.finite_of_norm_le K ℂ\n        (Real.exp ((Fintype.card (InfinitePlace K)) * r))).subset ?_\n    rintro _ ⟨x, ⟨⟨h_int, h_le⟩, rfl⟩⟩\n    exact ⟨h_int, h_le⟩\n\n"}
{"name":"NumberField.Units.dirichletUnitTheorem.seq_next","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nw₁ : NumberField.InfinitePlace K\nB : Nat\nhB : LT.lt (NumberField.mixedEmbedding.minkowskiBound K 1) (HMul.hMul ↑(NumberField.mixedEmbedding.convexBodyLTFactor K) ↑B)\nx : NumberField.RingOfIntegers K\nhx : Ne x 0\n⊢ Exists fun y => And (Ne y 0) (And (∀ (w : NumberField.InfinitePlace K), Ne w w₁ → LT.lt (w ↑y) (w ↑x)) (LE.le (abs ((Algebra.norm Rat) ↑y)) ↑B))","decl":"include hB in\n/-- This result shows that there always exists a next term in the sequence. -/\ntheorem seq_next {x : 𝓞 K} (hx : x ≠ 0) :\n    ∃ y : 𝓞 K, y ≠ 0 ∧\n      (∀ w, w ≠ w₁ → w y < w x) ∧\n      |Algebra.norm ℚ (y : K)| ≤ B := by\n  have hx' := RingOfIntegers.coe_ne_zero_iff.mpr hx\n  let f : InfinitePlace K → ℝ≥0 :=\n    fun w => ⟨(w x) / 2, div_nonneg (AbsoluteValue.nonneg _ _) (by norm_num)⟩\n  suffices ∀ w, w ≠ w₁ → f w ≠ 0 by\n    obtain ⟨g, h_geqf, h_gprod⟩ := adjust_f K B this\n    obtain ⟨y, h_ynz, h_yle⟩ := exists_ne_zero_mem_ringOfIntegers_lt K (f := g)\n      (by rw [convexBodyLT_volume]; convert hB; exact congr_arg ((↑) : NNReal → ENNReal) h_gprod)\n    refine ⟨y, h_ynz, fun w hw => (h_geqf w hw ▸ h_yle w).trans ?_, ?_⟩\n    · rw [← Rat.cast_le (K := ℝ), Rat.cast_natCast]\n      calc\n        _ = ∏ w : InfinitePlace K, w (algebraMap _ K y) ^ mult w :=\n          (prod_eq_abs_norm (algebraMap _ K y)).symm\n        _ ≤ ∏ w : InfinitePlace K, (g w : ℝ) ^ mult w := by gcongr with w; exact (h_yle w).le\n        _ ≤ (B : ℝ) := by\n          simp_rw [← NNReal.coe_pow, ← NNReal.coe_prod]\n          exact le_of_eq (congr_arg toReal h_gprod)\n    · refine div_lt_self ?_ (by norm_num)\n      exact pos_iff.mpr hx'\n  intro _ _\n  rw [ne_eq, Nonneg.mk_eq_zero, div_eq_zero_iff, map_eq_zero, not_or]\n  exact ⟨hx', by norm_num⟩\n\n"}
{"name":"NumberField.Units.dirichletUnitTheorem.seq_ne_zero","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nw₁ : NumberField.InfinitePlace K\nB : Nat\nhB : LT.lt (NumberField.mixedEmbedding.minkowskiBound K 1) (HMul.hMul ↑(NumberField.mixedEmbedding.convexBodyLTFactor K) ↑B)\nn : Nat\n⊢ Ne ((algebraMap (NumberField.RingOfIntegers K) K) ↑(NumberField.Units.dirichletUnitTheorem.seq K w₁ hB n)) 0","decl":"/-- The terms of the sequence are nonzero. -/\ntheorem seq_ne_zero (n : ℕ) : algebraMap (𝓞 K) K (seq K w₁ hB n) ≠ 0 :=\n  RingOfIntegers.coe_ne_zero_iff.mpr (seq K w₁ hB n).prop\n\n"}
{"name":"NumberField.Units.dirichletUnitTheorem.seq_decreasing","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nw₁ : NumberField.InfinitePlace K\nB : Nat\nhB : LT.lt (NumberField.mixedEmbedding.minkowskiBound K 1) (HMul.hMul ↑(NumberField.mixedEmbedding.convexBodyLTFactor K) ↑B)\nn m : Nat\nh : LT.lt n m\nw : NumberField.InfinitePlace K\nhw : Ne w w₁\n⊢ LT.lt (w ((algebraMap (NumberField.RingOfIntegers K) K) ↑(NumberField.Units.dirichletUnitTheorem.seq K w₁ hB m))) (w ((algebraMap (NumberField.RingOfIntegers K) K) ↑(NumberField.Units.dirichletUnitTheorem.seq K w₁ hB n)))","decl":"/-- The sequence is strictly decreasing at infinite places distinct from `w₁`. -/\ntheorem seq_decreasing {n m : ℕ} (h : n < m) (w : InfinitePlace K) (hw : w ≠ w₁) :\n    w (algebraMap (𝓞 K) K (seq K w₁ hB m)) < w (algebraMap (𝓞 K) K (seq K w₁ hB n)) := by\n  induction m with\n  | zero =>\n      exfalso\n      exact Nat.not_succ_le_zero n h\n  | succ m m_ih =>\n      cases eq_or_lt_of_le (Nat.le_of_lt_succ h) with\n      | inl hr =>\n          rw [hr]\n          exact (seq_next K w₁ hB (seq K w₁ hB m).prop).choose_spec.2.1 w hw\n      | inr hr =>\n          refine lt_trans ?_ (m_ih hr)\n          exact (seq_next K w₁ hB (seq K w₁ hB m).prop).choose_spec.2.1 w hw\n\n"}
{"name":"NumberField.Units.dirichletUnitTheorem.seq_norm_le","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nw₁ : NumberField.InfinitePlace K\nB : Nat\nhB : LT.lt (NumberField.mixedEmbedding.minkowskiBound K 1) (HMul.hMul ↑(NumberField.mixedEmbedding.convexBodyLTFactor K) ↑B)\nn : Nat\n⊢ LE.le ((Algebra.norm Int) ↑(NumberField.Units.dirichletUnitTheorem.seq K w₁ hB n)).natAbs B","decl":"/-- The terms of the sequence have norm bounded by `B`. -/\ntheorem seq_norm_le (n : ℕ) :\n    Int.natAbs (Algebra.norm ℤ (seq K w₁ hB n : 𝓞 K)) ≤ B := by\n  cases n with\n  | zero =>\n      have : 1 ≤ B := by\n        contrapose! hB\n        simp only [Nat.lt_one_iff.mp hB, CharP.cast_eq_zero, mul_zero, zero_le]\n      simp only [ne_eq, seq, map_one, Int.natAbs_one, this]\n  | succ n =>\n      rw [← Nat.cast_le (α := ℚ), Int.cast_natAbs, Int.cast_abs, Algebra.coe_norm_int]\n      exact (seq_next K w₁ hB (seq K w₁ hB n).prop).choose_spec.2.2\n\n"}
{"name":"NumberField.Units.dirichletUnitTheorem.exists_unit","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nw₁ : NumberField.InfinitePlace K\n⊢ Exists fun u => ∀ (w : NumberField.InfinitePlace K), Ne w w₁ → LT.lt (Real.log (w ((algebraMap (NumberField.RingOfIntegers K) K) ↑u))) 0","decl":"/-- Construct a unit associated to the place `w₁`. The family, for `w₁ ≠ w₀`, formed by the\nimage by the `logEmbedding` of these units is `ℝ`-linearly independent, see\n`unitLattice_span_eq_top`. -/\ntheorem exists_unit (w₁ : InfinitePlace K) :\n    ∃ u : (𝓞 K)ˣ, ∀ w : InfinitePlace K, w ≠ w₁ → Real.log (w u) < 0 := by\n  obtain ⟨B, hB⟩ : ∃ B : ℕ, minkowskiBound K 1 < (convexBodyLTFactor K) * B := by\n    conv => congr; ext; rw [mul_comm]\n    exact ENNReal.exists_nat_mul_gt (ENNReal.coe_ne_zero.mpr (convexBodyLTFactor_ne_zero K))\n      (ne_of_lt (minkowskiBound_lt_top K 1))\n  rsuffices ⟨n, m, hnm, h⟩ : ∃ n m, n < m ∧\n      (Ideal.span ({ (seq K w₁ hB n : 𝓞 K) }) = Ideal.span ({ (seq K w₁ hB m : 𝓞 K) }))\n  · have hu := Ideal.span_singleton_eq_span_singleton.mp h\n    refine ⟨hu.choose, fun w hw => Real.log_neg ?_ ?_⟩\n    · exact pos_iff.mpr (coe_ne_zero _)\n    · calc\n        _ = w (algebraMap (𝓞 K) K (seq K w₁ hB m) * (algebraMap (𝓞 K) K (seq K w₁ hB n))⁻¹) := by\n          rw [← congr_arg (algebraMap (𝓞 K) K) hu.choose_spec, mul_comm, map_mul (algebraMap _ _),\n          ← mul_assoc, inv_mul_cancel₀ (seq_ne_zero K w₁ hB n), one_mul]\n      _ = w (algebraMap (𝓞 K) K (seq K w₁ hB m)) * w (algebraMap (𝓞 K) K (seq K w₁ hB n))⁻¹ :=\n        _root_.map_mul _ _ _\n      _ < 1 := by\n        rw [map_inv₀, mul_inv_lt_iff₀' (pos_iff.mpr (seq_ne_zero K w₁ hB n)), mul_one]\n        exact seq_decreasing K w₁ hB hnm w hw\n  refine Set.Finite.exists_lt_map_eq_of_forall_mem (t := {I : Ideal (𝓞 K) | Ideal.absNorm I ≤ B})\n    (fun n ↦ ?_) (Ideal.finite_setOf_absNorm_le B)\n  rw [Set.mem_setOf_eq, Ideal.absNorm_span_singleton]\n  exact seq_norm_le K w₁ hB n\n\n"}
{"name":"NumberField.Units.dirichletUnitTheorem.unitLattice_span_eq_top","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\n⊢ Eq (Submodule.span Real ↑(NumberField.Units.unitLattice K)) Top.top","decl":"theorem unitLattice_span_eq_top :\n    Submodule.span ℝ (unitLattice K : Set ({w : InfinitePlace K // w ≠ w₀} → ℝ)) = ⊤ := by\n  classical\n  refine le_antisymm le_top ?_\n  -- The standard basis\n  let B := Pi.basisFun ℝ {w : InfinitePlace K // w ≠ w₀}\n  -- The image by log_embedding of the family of units constructed above\n  let v := fun w : { w : InfinitePlace K // w ≠ w₀ } =>\n    logEmbedding K (Additive.ofMul (exists_unit K w).choose)\n  -- To prove the result, it is enough to prove that the family `v` is linearly independent\n  suffices B.det v ≠ 0 by\n    rw [← isUnit_iff_ne_zero, ← is_basis_iff_det] at this\n    rw [← this.2]\n    refine  Submodule.span_monotone fun _ ⟨w, hw⟩ ↦ ⟨(exists_unit K w).choose, trivial, hw⟩\n  rw [Basis.det_apply]\n  -- We use a specific lemma to prove that this determinant is nonzero\n  refine det_ne_zero_of_sum_col_lt_diag (fun w => ?_)\n  simp_rw [Real.norm_eq_abs, B, Basis.coePiBasisFun.toMatrix_eq_transpose, Matrix.transpose_apply]\n  rw [← sub_pos, sum_congr rfl (fun x hx => abs_of_neg ?_), sum_neg_distrib, sub_neg_eq_add,\n    sum_erase_eq_sub (mem_univ _), ← add_comm_sub]\n  · refine add_pos_of_nonneg_of_pos ?_ ?_\n    · rw [sub_nonneg]\n      exact le_abs_self _\n    · rw [sum_logEmbedding_component (exists_unit K w).choose]\n      refine mul_pos_of_neg_of_neg ?_ ((exists_unit K w).choose_spec _ w.prop.symm)\n      rw [mult]; split_ifs <;> norm_num\n  · refine mul_neg_of_pos_of_neg ?_ ((exists_unit K w).choose_spec x ?_)\n    · rw [mult]; split_ifs <;> norm_num\n    · exact Subtype.ext_iff_val.not.mp (ne_of_mem_erase hx)\n\n"}
{"name":"NumberField.Units.instDiscrete_unitLattice","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\n⊢ DiscreteTopology (Subtype fun x => Membership.mem (NumberField.Units.unitLattice K) x)","decl":"instance instDiscrete_unitLattice : DiscreteTopology (unitLattice K) := by\n  classical\n  refine discreteTopology_of_isOpen_singleton_zero ?_\n  refine isOpen_singleton_of_finite_mem_nhds 0 (s := Metric.closedBall 0 1) ?_ ?_\n  · exact Metric.closedBall_mem_nhds _ (by norm_num)\n  · refine Set.Finite.of_finite_image ?_ (Set.injOn_of_injective Subtype.val_injective)\n    convert unitLattice_inter_ball_finite K 1\n    ext x\n    refine ⟨?_, fun ⟨hx1, hx2⟩ => ⟨⟨x, hx1⟩, hx2, rfl⟩⟩\n    rintro ⟨x, hx, rfl⟩\n    exact ⟨Subtype.mem x, hx⟩\n\n"}
{"name":"NumberField.Units.instZLattice_unitLattice","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\n⊢ IsZLattice Real (NumberField.Units.unitLattice K)","decl":"open scoped Classical in\ninstance instZLattice_unitLattice : IsZLattice ℝ (unitLattice K) where\n  span_top := unitLattice_span_eq_top K\n\n"}
{"name":"NumberField.Units.finrank_eq_rank","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\n⊢ Eq (Module.finrank Real ((Subtype fun w => Ne w NumberField.Units.dirichletUnitTheorem.w₀) → Real)) (NumberField.Units.rank K)","decl":"protected theorem finrank_eq_rank :\n    finrank ℝ ({w : InfinitePlace K // w ≠ w₀} → ℝ) = Units.rank K := by\n  classical\n  simp only [finrank_fintype_fun_eq_card, Fintype.card_subtype_compl,\n    Fintype.card_ofSubsingleton, rank]\n\n"}
{"name":"NumberField.Units.unitLattice_rank","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\n⊢ Eq (Module.finrank Int (Subtype fun x => Membership.mem (NumberField.Units.unitLattice K) x)) (NumberField.Units.rank K)","decl":"@[simp]\ntheorem unitLattice_rank :\n    finrank ℤ (unitLattice K) = Units.rank K := by\n  classical\n  rw [← Units.finrank_eq_rank, ZLattice.rank ℝ]\n\n"}
{"name":"NumberField.Units.logEmbeddingQuot_apply","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nx : Units (NumberField.RingOfIntegers K)\n⊢ Eq ((NumberField.Units.logEmbeddingQuot K) (Additive.ofMul ↑x)) ((NumberField.Units.logEmbedding K) (Additive.ofMul x))","decl":"@[simp]\ntheorem logEmbeddingQuot_apply (x : (𝓞 K)ˣ) :\n    logEmbeddingQuot K (Additive.ofMul (QuotientGroup.mk x)) =\n      logEmbedding K (Additive.ofMul x) := rfl\n\n"}
{"name":"NumberField.Units.logEmbeddingQuot_injective","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\n⊢ Function.Injective ⇑(NumberField.Units.logEmbeddingQuot K)","decl":"theorem logEmbeddingQuot_injective :\n    Function.Injective (logEmbeddingQuot K) := by\n  unfold logEmbeddingQuot\n  intro _ _ h\n  simp_rw [MonoidHom.toAdditive'_apply_apply, MonoidHom.coe_comp, MulEquiv.coe_toMonoidHom,\n    Function.comp_apply, EmbeddingLike.apply_eq_iff_eq] at h\n  exact (EmbeddingLike.apply_eq_iff_eq _).mp <| (QuotientGroup.kerLift_injective _).eq_iff.mp h\n\n"}
{"name":"NumberField.Units.logEmbeddingEquiv_apply","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nx : Units (NumberField.RingOfIntegers K)\n⊢ Eq (↑((NumberField.Units.logEmbeddingEquiv K) (Additive.ofMul ↑x))) ((NumberField.Units.logEmbedding K) (Additive.ofMul x))","decl":"@[simp]\ntheorem logEmbeddingEquiv_apply (x : (𝓞 K)ˣ) :\n    logEmbeddingEquiv K (Additive.ofMul (QuotientGroup.mk x)) =\n      logEmbedding K (Additive.ofMul x) := rfl\n\n"}
{"name":"NumberField.Units.instFreeIntAdditiveQuotientUnitsRingOfIntegersSubgroupTorsion","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninst✝ : Field K\n⊢ Module.Free Int (Additive (HasQuotient.Quotient (Units (NumberField.RingOfIntegers K)) (NumberField.Units.torsion K)))","decl":"instance : Module.Free ℤ (Additive ((𝓞 K)ˣ ⧸ (torsion K))) := by\n  classical exact Module.Free.of_equiv (logEmbeddingEquiv K).symm\n\n"}
{"name":"NumberField.Units.instFiniteIntAdditiveQuotientUnitsRingOfIntegersSubgroupTorsion","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninst✝ : Field K\n⊢ Module.Finite Int (Additive (HasQuotient.Quotient (Units (NumberField.RingOfIntegers K)) (NumberField.Units.torsion K)))","decl":"instance : Module.Finite ℤ (Additive ((𝓞 K)ˣ ⧸ (torsion K))) := by\n  classical exact Module.Finite.equiv (logEmbeddingEquiv K).symm\n\n-- Note that we prove this instance first and then deduce from it the instance\n-- `Monoid.FG (𝓞 K)ˣ`, and not the other way around, due to no `Subgroup` version\n-- of `Submodule.fg_of_fg_map_of_fg_inf_ker` existing.\n"}
{"name":"NumberField.Units.instFiniteIntAdditiveUnitsRingOfIntegers","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninst✝ : Field K\n⊢ Module.Finite Int (Additive (Units (NumberField.RingOfIntegers K)))","decl":"instance : Module.Finite ℤ (Additive (𝓞 K)ˣ) := by\n  rw [Module.finite_def]\n  refine Submodule.fg_of_fg_map_of_fg_inf_ker\n    (MonoidHom.toAdditive (QuotientGroup.mk' (torsion K))).toIntLinearMap ?_ ?_\n  · rw [Submodule.map_top, LinearMap.range_eq_top.mpr\n      (by exact QuotientGroup.mk'_surjective (torsion K)), ← Module.finite_def]\n    infer_instance\n  · rw [inf_of_le_right le_top, AddMonoidHom.coe_toIntLinearMap_ker, MonoidHom.coe_toAdditive_ker,\n      QuotientGroup.ker_mk', Submodule.fg_iff_add_subgroup_fg,\n      AddSubgroup.toIntSubmodule_toAddSubgroup, ← AddGroup.fg_iff_addSubgroup_fg]\n    have : Finite (Subgroup.toAddSubgroup (torsion K)) := (inferInstance : Finite (torsion K))\n    exact AddGroup.fg_of_finite\n\n"}
{"name":"NumberField.Units.instFGUnitsRingOfIntegers","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninst✝ : Field K\n⊢ Monoid.FG (Units (NumberField.RingOfIntegers K))","decl":"instance : Monoid.FG (𝓞 K)ˣ := by\n  rw [Monoid.fg_iff_add_fg, ← AddGroup.fg_iff_addMonoid_fg, ← Module.Finite.iff_addGroup_fg]\n  infer_instance\n\n"}
{"name":"NumberField.Units.rank_modTorsion","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\n⊢ Eq (Module.finrank Int (Additive (HasQuotient.Quotient (Units (NumberField.RingOfIntegers K)) (NumberField.Units.torsion K)))) (NumberField.Units.rank K)","decl":"theorem rank_modTorsion :\n    Module.finrank ℤ (Additive ((𝓞 K)ˣ ⧸ (torsion K))) = rank K := by\n  rw [← LinearEquiv.finrank_eq (logEmbeddingEquiv K).symm, unitLattice_rank]\n\n"}
{"name":"NumberField.Units.fundSystem_mk","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\ni : Fin (NumberField.Units.rank K)\n⊢ Eq (Additive.ofMul ↑(NumberField.Units.fundSystem K i)) ((NumberField.Units.basisModTorsion K) i)","decl":"theorem fundSystem_mk (i : Fin (rank K)) :\n    Additive.ofMul (QuotientGroup.mk (fundSystem K i)) = (basisModTorsion K i) := by\n  simp_rw [fundSystem, Equiv.apply_eq_iff_eq_symm_apply, Additive.ofMul_symm_eq, Quotient.out_eq']\n\n"}
{"name":"NumberField.Units.logEmbedding_fundSystem","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\ni : Fin (NumberField.Units.rank K)\n⊢ Eq ((NumberField.Units.logEmbedding K) (Additive.ofMul (NumberField.Units.fundSystem K i))) ↑((NumberField.Units.basisUnitLattice K) i)","decl":"theorem logEmbedding_fundSystem (i : Fin (rank K)) :\n    logEmbedding K (Additive.ofMul (fundSystem K i)) = basisUnitLattice K i := by\n  rw [basisUnitLattice, Basis.map_apply, ← fundSystem_mk, logEmbeddingEquiv_apply]\n\n"}
{"name":"NumberField.Units.fun_eq_repr","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nx ζ : Units (NumberField.RingOfIntegers K)\nf : Fin (NumberField.Units.rank K) → Int\nhζ : Membership.mem (NumberField.Units.torsion K) ζ\nh : Eq x (HMul.hMul ζ (Finset.univ.prod fun i => HPow.hPow (NumberField.Units.fundSystem K i) (f i)))\n⊢ Eq f ⇑((NumberField.Units.basisModTorsion K).repr (Additive.ofMul ↑x))","decl":"/-- The exponents that appear in the unique decomposition of a unit as the product of\na root of unity and powers of the units of the fundamental system `fundSystem` (see\n`exist_unique_eq_mul_prod`) are given by the representation of the unit on `basisModTorsion`. -/\ntheorem fun_eq_repr {x ζ : (𝓞 K)ˣ} {f : Fin (rank K) → ℤ} (hζ : ζ ∈ torsion K)\n    (h : x = ζ * ∏ i, (fundSystem K i) ^ (f i)) :\n    f = (basisModTorsion K).repr (Additive.ofMul ↑x) := by\n  suffices Additive.ofMul ↑x = ∑ i, (f i) • (basisModTorsion K i) by\n    rw [← (basisModTorsion K).repr_sum_self f, ← this]\n  calc\n    Additive.ofMul ↑x\n    _ = ∑ i, (f i) • Additive.ofMul ↑(fundSystem K i) := by\n          rw [h, QuotientGroup.mk_mul, (QuotientGroup.eq_one_iff _).mpr hζ, one_mul,\n            QuotientGroup.mk_prod, ofMul_prod]; rfl\n    _ = ∑ i, (f i) • (basisModTorsion K i) := by\n          simp_rw [fundSystem, QuotientGroup.out_eq', ofMul_toMul]\n\n"}
{"name":"NumberField.Units.exist_unique_eq_mul_prod","module":"Mathlib.NumberTheory.NumberField.Units.DirichletTheorem","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nx : Units (NumberField.RingOfIntegers K)\n⊢ ExistsUnique fun ζe => Eq x (HMul.hMul (↑ζe.1) (Finset.univ.prod fun i => HPow.hPow (NumberField.Units.fundSystem K i) (ζe.2 i)))","decl":"/-- **Dirichlet Unit Theorem**. Any unit `x` of `𝓞 K` can be written uniquely as the product of\na root of unity and powers of the units of the fundamental system `fundSystem`. -/\ntheorem exist_unique_eq_mul_prod (x : (𝓞 K)ˣ) : ∃! ζe : torsion K × (Fin (rank K) → ℤ),\n    x = ζe.1 * ∏ i, (fundSystem K i) ^ (ζe.2 i) := by\n  let ζ := x * (∏ i, (fundSystem K i) ^ ((basisModTorsion K).repr (Additive.ofMul ↑x) i))⁻¹\n  have h_tors : ζ ∈ torsion K := by\n    rw [← QuotientGroup.eq_one_iff, QuotientGroup.mk_mul, QuotientGroup.mk_inv, ← ofMul_eq_zero,\n      ofMul_mul, ofMul_inv, QuotientGroup.mk_prod, ofMul_prod]\n    simp_rw [QuotientGroup.mk_zpow, ofMul_zpow, fundSystem, QuotientGroup.out_eq']\n    rw [add_eq_zero_iff_eq_neg, neg_neg]\n    exact ((basisModTorsion K).sum_repr (Additive.ofMul ↑x)).symm\n  refine ⟨⟨⟨ζ, h_tors⟩, ((basisModTorsion K).repr (Additive.ofMul ↑x) : Fin (rank K) → ℤ)⟩, ?_, ?_⟩\n  · simp only [ζ, _root_.inv_mul_cancel_right]\n  · rintro ⟨⟨ζ', h_tors'⟩, η⟩ hf\n    simp only [ζ, ← fun_eq_repr K h_tors' hf, Prod.mk.injEq, Subtype.mk.injEq, and_true]\n    nth_rewrite 1 [hf]\n    rw [_root_.mul_inv_cancel_right]\n\n"}
