{"name":"Complex.circleTransformDeriv_periodic","module":"Mathlib.MeasureTheory.Integral.CircleTransform","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nR : Real\nz w : Complex\nf : Complex → E\n⊢ Function.Periodic (Complex.circleTransformDeriv R z w f) (HMul.hMul 2 Real.pi)","decl":"theorem circleTransformDeriv_periodic (f : ℂ → E) :\n    Periodic (circleTransformDeriv R z w f) (2 * π) := by\n  have := periodic_circleMap\n  simp_rw [Periodic] at *\n  intro x\n  simp_rw [circleTransformDeriv, this]\n  congr 2\n  simp [this]\n\n"}
{"name":"Complex.circleTransformDeriv_eq","module":"Mathlib.MeasureTheory.Integral.CircleTransform","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nR : Real\nz w : Complex\nf : Complex → E\n⊢ Eq (Complex.circleTransformDeriv R z w f) fun θ => HSMul.hSMul (Inv.inv (HSub.hSub (circleMap z R θ) w)) (Complex.circleTransform R z w f θ)","decl":"theorem circleTransformDeriv_eq (f : ℂ → E) : circleTransformDeriv R z w f =\n    fun θ => (circleMap z R θ - w)⁻¹ • circleTransform R z w f θ := by\n  ext\n  simp_rw [circleTransformDeriv, circleTransform, ← mul_smul, ← mul_assoc]\n  ring_nf\n  rw [inv_pow]\n  congr\n  ring\n\n"}
{"name":"Complex.integral_circleTransform","module":"Mathlib.MeasureTheory.Integral.CircleTransform","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nR : Real\nz w : Complex\nf : Complex → E\n⊢ Eq (intervalIntegral (fun θ => Complex.circleTransform R z w f θ) 0 (HMul.hMul 2 Real.pi) MeasureTheory.MeasureSpace.volume) (HSMul.hSMul (Inv.inv (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I)) (circleIntegral (fun z => HSMul.hSMul (Inv.inv (HSub.hSub z w)) (f z)) z R))","decl":"theorem integral_circleTransform (f : ℂ → E) :\n    (∫ θ : ℝ in (0)..2 * π, circleTransform R z w f θ) =\n      (2 * ↑π * I)⁻¹ • ∮ z in C(z, R), (z - w)⁻¹ • f z := by\n  simp_rw [circleTransform, circleIntegral, deriv_circleMap, circleMap]\n  simp\n\n"}
{"name":"Complex.continuous_circleTransform","module":"Mathlib.MeasureTheory.Integral.CircleTransform","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nR : Real\nhR : LT.lt 0 R\nf : Complex → E\nz w : Complex\nhf : ContinuousOn f (Metric.sphere z R)\nhw : Membership.mem (Metric.ball z R) w\n⊢ Continuous (Complex.circleTransform R z w f)","decl":"theorem continuous_circleTransform {R : ℝ} (hR : 0 < R) {f : ℂ → E} {z w : ℂ}\n    (hf : ContinuousOn f <| sphere z R) (hw : w ∈ ball z R) :\n    Continuous (circleTransform R z w f) := by\n  apply_rules [Continuous.smul, continuous_const]\n  · rw [funext <| deriv_circleMap _ _]\n    apply_rules [Continuous.mul, continuous_circleMap 0 R, continuous_const]\n  · exact continuous_circleMap_inv hw\n  · apply ContinuousOn.comp_continuous hf (continuous_circleMap z R)\n    exact fun _ => (circleMap_mem_sphere _ hR.le) _\n\n"}
{"name":"Complex.continuous_circleTransformDeriv","module":"Mathlib.MeasureTheory.Integral.CircleTransform","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nR : Real\nhR : LT.lt 0 R\nf : Complex → E\nz w : Complex\nhf : ContinuousOn f (Metric.sphere z R)\nhw : Membership.mem (Metric.ball z R) w\n⊢ Continuous (Complex.circleTransformDeriv R z w f)","decl":"theorem continuous_circleTransformDeriv {R : ℝ} (hR : 0 < R) {f : ℂ → E} {z w : ℂ}\n    (hf : ContinuousOn f (sphere z R)) (hw : w ∈ ball z R) :\n    Continuous (circleTransformDeriv R z w f) := by\n  rw [circleTransformDeriv_eq]\n  exact (continuous_circleMap_inv hw).smul (continuous_circleTransform hR hf hw)\n\n"}
{"name":"Complex.continuousOn_prod_circle_transform_function","module":"Mathlib.MeasureTheory.Integral.CircleTransform","initialProofState":"R r : Real\nhr : LT.lt r R\nz : Complex\n⊢ ContinuousOn (fun w => HPow.hPow (Inv.inv (HSub.hSub (circleMap z R w.2) w.1)) 2) (SProd.sprod (Metric.closedBall z r) Set.univ)","decl":"theorem continuousOn_prod_circle_transform_function {R r : ℝ} (hr : r < R) {z : ℂ} :\n    ContinuousOn (fun w : ℂ × ℝ => (circleMap z R w.snd - w.fst)⁻¹ ^ 2)\n      (closedBall z r ×ˢ univ) := by\n  simp_rw [← one_div]\n  apply_rules [ContinuousOn.pow, ContinuousOn.div, continuousOn_const]\n  · exact ((continuous_circleMap z R).comp_continuousOn continuousOn_snd).sub continuousOn_fst\n  · rintro ⟨a, b⟩ ⟨ha, -⟩\n    have ha2 : a ∈ ball z R := closedBall_subset_ball hr ha\n    exact sub_ne_zero.2 (circleMap_ne_mem_ball ha2 b)\n\n"}
{"name":"Complex.continuousOn_abs_circleTransformBoundingFunction","module":"Mathlib.MeasureTheory.Integral.CircleTransform","initialProofState":"R r : Real\nhr : LT.lt r R\nz : Complex\n⊢ ContinuousOn (Function.comp (⇑Complex.abs) (Complex.circleTransformBoundingFunction R z)) (SProd.sprod (Metric.closedBall z r) Set.univ)","decl":"theorem continuousOn_abs_circleTransformBoundingFunction {R r : ℝ} (hr : r < R) (z : ℂ) :\n    ContinuousOn (abs ∘ circleTransformBoundingFunction R z) (closedBall z r ×ˢ univ) := by\n  have : ContinuousOn (circleTransformBoundingFunction R z) (closedBall z r ×ˢ univ) := by\n    apply_rules [ContinuousOn.smul, continuousOn_const]\n    · simp only [deriv_circleMap]\n      apply_rules [ContinuousOn.mul, (continuous_circleMap 0 R).comp_continuousOn continuousOn_snd,\n        continuousOn_const]\n    · simpa only [inv_pow] using continuousOn_prod_circle_transform_function hr\n  exact this.norm\n\n"}
{"name":"Complex.abs_circleTransformBoundingFunction_le","module":"Mathlib.MeasureTheory.Integral.CircleTransform","initialProofState":"R r : Real\nhr : LT.lt r R\nhr' : LE.le 0 r\nz : Complex\n⊢ Exists fun x => ∀ (y : ↑(SProd.sprod (Metric.closedBall z r) (Set.uIcc 0 (HMul.hMul 2 Real.pi)))), LE.le (Complex.abs (Complex.circleTransformBoundingFunction R z ↑y)) (Complex.abs (Complex.circleTransformBoundingFunction R z ↑x))","decl":"theorem abs_circleTransformBoundingFunction_le {R r : ℝ} (hr : r < R) (hr' : 0 ≤ r) (z : ℂ) :\n    ∃ x : closedBall z r ×ˢ [[0, 2 * π]], ∀ y : closedBall z r ×ˢ [[0, 2 * π]],\n    abs (circleTransformBoundingFunction R z y) ≤ abs (circleTransformBoundingFunction R z x) := by\n  have cts := continuousOn_abs_circleTransformBoundingFunction hr z\n  have comp : IsCompact (closedBall z r ×ˢ [[0, 2 * π]]) := by\n    apply_rules [IsCompact.prod, ProperSpace.isCompact_closedBall z r, isCompact_uIcc]\n  have none : (closedBall z r ×ˢ [[0, 2 * π]]).Nonempty :=\n    (nonempty_closedBall.2 hr').prod nonempty_uIcc\n  have := IsCompact.exists_isMaxOn comp none (cts.mono <| prod_mono_right (subset_univ _))\n  simpa [isMaxOn_iff] using this\n\n"}
{"name":"Complex.circleTransformDeriv_bound","module":"Mathlib.MeasureTheory.Integral.CircleTransform","initialProofState":"R : Real\nhR : LT.lt 0 R\nz x : Complex\nf : Complex → Complex\nhx : Membership.mem (Metric.ball z R) x\nhf : ContinuousOn f (Metric.sphere z R)\n⊢ Exists fun B => Exists fun ε => And (LT.lt 0 ε) (And (HasSubset.Subset (Metric.ball x ε) (Metric.ball z R)) (∀ (t : Real) (y : Complex), Membership.mem (Metric.ball x ε) y → LE.le (Norm.norm (Complex.circleTransformDeriv R z y f t)) B))","decl":"/-- The derivative of a `circleTransform` is locally bounded. -/\ntheorem circleTransformDeriv_bound {R : ℝ} (hR : 0 < R) {z x : ℂ} {f : ℂ → ℂ} (hx : x ∈ ball z R)\n    (hf : ContinuousOn f (sphere z R)) : ∃ B ε : ℝ, 0 < ε ∧\n      ball x ε ⊆ ball z R ∧ ∀ (t : ℝ), ∀ y ∈ ball x ε, ‖circleTransformDeriv R z y f t‖ ≤ B := by\n  obtain ⟨r, hr, hrx⟩ := exists_lt_mem_ball_of_mem_ball hx\n  obtain ⟨ε', hε', H⟩ := exists_ball_subset_ball hrx\n  obtain ⟨⟨⟨a, b⟩, ⟨ha, hb⟩⟩, hab⟩ :=\n    abs_circleTransformBoundingFunction_le hr (pos_of_mem_ball hrx).le z\n  let V : ℝ → ℂ → ℂ := fun θ w => circleTransformDeriv R z w (fun _ => 1) θ\n  obtain ⟨X, -, HX2⟩ := (isCompact_sphere z R).exists_isMaxOn\n    (NormedSpace.sphere_nonempty.2 hR.le) hf.norm\n  refine ⟨abs (V b a) * abs (f X), ε', hε', H.trans (ball_subset_ball hr.le), fun y v hv ↦ ?_⟩\n  obtain ⟨y1, hy1, hfun⟩ :=\n    Periodic.exists_mem_Ico₀ (circleTransformDeriv_periodic R z v f) Real.two_pi_pos y\n  have hy2 : y1 ∈ [[0, 2 * π]] := Icc_subset_uIcc <| Ico_subset_Icc_self hy1\n  simp only [isMaxOn_iff, mem_sphere_iff_norm, norm_eq_abs] at HX2\n  have := mul_le_mul (hab ⟨⟨v, y1⟩, ⟨ball_subset_closedBall (H hv), hy2⟩⟩)\n    (HX2 (circleMap z R y1) (circleMap_mem_sphere z hR.le y1)) (Complex.abs.nonneg _)\n    (Complex.abs.nonneg _)\n  rw [hfun]\n  simpa [V, circleTransformBoundingFunction, circleTransformDeriv, mul_assoc] using this\n\n"}
