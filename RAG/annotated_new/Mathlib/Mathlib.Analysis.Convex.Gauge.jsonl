{"name":"gauge_def","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\ns : Set E\nx : E\n⊢ Eq (gauge s x) (InfSet.sInf (setOf fun r => And (Membership.mem (Set.Ioi 0) r) (Membership.mem (HSMul.hSMul r s) x)))","decl":"theorem gauge_def : gauge s x = sInf ({ r ∈ Set.Ioi (0 : ℝ) | x ∈ r • s }) :=\n  rfl\n\n"}
{"name":"gauge_def'","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\ns : Set E\nx : E\n⊢ Eq (gauge s x) (InfSet.sInf (setOf fun r => And (Membership.mem (Set.Ioi 0) r) (Membership.mem s (HSMul.hSMul (Inv.inv r) x))))","decl":"/-- An alternative definition of the gauge using scalar multiplication on the element rather than on\nthe set. -/\ntheorem gauge_def' : gauge s x = sInf {r ∈ Set.Ioi (0 : ℝ) | r⁻¹ • x ∈ s} := by\n  congrm sInf {r | ?_}\n  exact and_congr_right fun hr => mem_smul_set_iff_inv_smul_mem₀ hr.ne' _ _\n\n"}
{"name":"Absorbent.gauge_set_nonempty","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\ns : Set E\nx : E\nabsorbs : Absorbent Real s\n⊢ (setOf fun r => And (LT.lt 0 r) (Membership.mem (HSMul.hSMul r s) x)).Nonempty","decl":"/-- If the given subset is `Absorbent` then the set we take an infimum over in `gauge` is nonempty,\nwhich is useful for proving many properties about the gauge. -/\ntheorem Absorbent.gauge_set_nonempty (absorbs : Absorbent ℝ s) :\n    { r : ℝ | 0 < r ∧ x ∈ r • s }.Nonempty :=\n  let ⟨r, hr₁, hr₂⟩ := (absorbs x).exists_pos\n  ⟨r, hr₁, hr₂ r (Real.norm_of_nonneg hr₁.le).ge rfl⟩\n\n"}
{"name":"gauge_mono","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\ns t : Set E\nhs : Absorbent Real s\nh : HasSubset.Subset s t\n⊢ LE.le (gauge t) (gauge s)","decl":"theorem gauge_mono (hs : Absorbent ℝ s) (h : s ⊆ t) : gauge t ≤ gauge s := fun _ =>\n  csInf_le_csInf gauge_set_bddBelow hs.gauge_set_nonempty fun _ hr => ⟨hr.1, smul_set_mono h hr.2⟩\n\n"}
{"name":"exists_lt_of_gauge_lt","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\ns : Set E\nx : E\na : Real\nabsorbs : Absorbent Real s\nh : LT.lt (gauge s x) a\n⊢ Exists fun b => And (LT.lt 0 b) (And (LT.lt b a) (Membership.mem (HSMul.hSMul b s) x))","decl":"theorem exists_lt_of_gauge_lt (absorbs : Absorbent ℝ s) (h : gauge s x < a) :\n    ∃ b, 0 < b ∧ b < a ∧ x ∈ b • s := by\n  obtain ⟨b, ⟨hb, hx⟩, hba⟩ := exists_lt_of_csInf_lt absorbs.gauge_set_nonempty h\n  exact ⟨b, hb, hba, hx⟩\n\n"}
{"name":"gauge_zero","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\ns : Set E\n⊢ Eq (gauge s 0) 0","decl":"/-- The gauge evaluated at `0` is always zero (mathematically this requires `0` to be in the set `s`\nbut, the real infimum of the empty set in Lean being defined as `0`, it holds unconditionally). -/\n@[simp]\ntheorem gauge_zero : gauge s 0 = 0 := by\n  rw [gauge_def']\n  by_cases h : (0 : E) ∈ s\n  · simp only [smul_zero, sep_true, h, csInf_Ioi]\n  · simp only [smul_zero, sep_false, h, Real.sInf_empty]\n\n"}
{"name":"gauge_zero'","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\n⊢ Eq (gauge 0) 0","decl":"@[simp]\ntheorem gauge_zero' : gauge (0 : Set E) = 0 := by\n  ext x\n  rw [gauge_def']\n  obtain rfl | hx := eq_or_ne x 0\n  · simp only [csInf_Ioi, mem_zero, Pi.zero_apply, eq_self_iff_true, sep_true, smul_zero]\n  · simp only [mem_zero, Pi.zero_apply, inv_eq_zero, smul_eq_zero]\n    convert Real.sInf_empty\n    exact eq_empty_iff_forall_not_mem.2 fun r hr => hr.2.elim (ne_of_gt hr.1) hx\n\n"}
{"name":"gauge_empty","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\n⊢ Eq (gauge EmptyCollection.emptyCollection) 0","decl":"@[simp]\ntheorem gauge_empty : gauge (∅ : Set E) = 0 := by\n  ext\n  simp only [gauge_def', Real.sInf_empty, mem_empty_iff_false, Pi.zero_apply, sep_false]\n\n"}
{"name":"gauge_of_subset_zero","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\ns : Set E\nh : HasSubset.Subset s 0\n⊢ Eq (gauge s) 0","decl":"theorem gauge_of_subset_zero (h : s ⊆ 0) : gauge s = 0 := by\n  obtain rfl | rfl := subset_singleton_iff_eq.1 h\n  exacts [gauge_empty, gauge_zero']\n\n"}
{"name":"gauge_nonneg","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\ns : Set E\nx : E\n⊢ LE.le 0 (gauge s x)","decl":"/-- The gauge is always nonnegative. -/\ntheorem gauge_nonneg (x : E) : 0 ≤ gauge s x :=\n  Real.sInf_nonneg fun _ hx => hx.1.le\n\n"}
{"name":"gauge_neg","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\ns : Set E\nsymmetric : ∀ (x : E), Membership.mem s x → Membership.mem s (Neg.neg x)\nx : E\n⊢ Eq (gauge s (Neg.neg x)) (gauge s x)","decl":"theorem gauge_neg (symmetric : ∀ x ∈ s, -x ∈ s) (x : E) : gauge s (-x) = gauge s x := by\n  have : ∀ x, -x ∈ s ↔ x ∈ s := fun x => ⟨fun h => by simpa using symmetric _ h, symmetric x⟩\n  simp_rw [gauge_def', smul_neg, this]\n\n"}
{"name":"gauge_neg_set_neg","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\ns : Set E\nx : E\n⊢ Eq (gauge (Neg.neg s) (Neg.neg x)) (gauge s x)","decl":"theorem gauge_neg_set_neg (x : E) : gauge (-s) (-x) = gauge s x := by\n  simp_rw [gauge_def', smul_neg, neg_mem_neg]\n\n"}
{"name":"gauge_neg_set_eq_gauge_neg","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\ns : Set E\nx : E\n⊢ Eq (gauge (Neg.neg s) x) (gauge s (Neg.neg x))","decl":"theorem gauge_neg_set_eq_gauge_neg (x : E) : gauge (-s) x = gauge s (-x) := by\n  rw [← gauge_neg_set_neg, neg_neg]\n\n"}
{"name":"gauge_le_of_mem","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\ns : Set E\nx : E\na : Real\nha : LE.le 0 a\nhx : Membership.mem (HSMul.hSMul a s) x\n⊢ LE.le (gauge s x) a","decl":"theorem gauge_le_of_mem (ha : 0 ≤ a) (hx : x ∈ a • s) : gauge s x ≤ a := by\n  obtain rfl | ha' := ha.eq_or_lt\n  · rw [mem_singleton_iff.1 (zero_smul_set_subset _ hx), gauge_zero]\n  · exact csInf_le gauge_set_bddBelow ⟨ha', hx⟩\n\n"}
{"name":"gauge_le_eq","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\ns : Set E\na : Real\nhs₁ : Convex Real s\nhs₀ : Membership.mem s 0\nhs₂ : Absorbent Real s\nha : LE.le 0 a\n⊢ Eq (setOf fun x => LE.le (gauge s x) a) (Set.iInter fun r => Set.iInter fun x => HSMul.hSMul r s)","decl":"theorem gauge_le_eq (hs₁ : Convex ℝ s) (hs₀ : (0 : E) ∈ s) (hs₂ : Absorbent ℝ s) (ha : 0 ≤ a) :\n    { x | gauge s x ≤ a } = ⋂ (r : ℝ) (_ : a < r), r • s := by\n  ext x\n  simp_rw [Set.mem_iInter, Set.mem_setOf_eq]\n  refine ⟨fun h r hr => ?_, fun h => le_of_forall_pos_lt_add fun ε hε => ?_⟩\n  · have hr' := ha.trans_lt hr\n    rw [mem_smul_set_iff_inv_smul_mem₀ hr'.ne']\n    obtain ⟨δ, δ_pos, hδr, hδ⟩ := exists_lt_of_gauge_lt hs₂ (h.trans_lt hr)\n    suffices (r⁻¹ * δ) • δ⁻¹ • x ∈ s by rwa [smul_smul, mul_inv_cancel_right₀ δ_pos.ne'] at this\n    rw [mem_smul_set_iff_inv_smul_mem₀ δ_pos.ne'] at hδ\n    refine hs₁.smul_mem_of_zero_mem hs₀ hδ ⟨by positivity, ?_⟩\n    rw [inv_mul_le_iff₀ hr', mul_one]\n    exact hδr.le\n  · have hε' := (lt_add_iff_pos_right a).2 (half_pos hε)\n    exact\n      (gauge_le_of_mem (ha.trans hε'.le) <| h _ hε').trans_lt (add_lt_add_left (half_lt_self hε) _)\n\n"}
{"name":"gauge_lt_eq'","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\ns : Set E\nabsorbs : Absorbent Real s\na : Real\n⊢ Eq (setOf fun x => LT.lt (gauge s x) a) (Set.iUnion fun r => Set.iUnion fun x => Set.iUnion fun x => HSMul.hSMul r s)","decl":"theorem gauge_lt_eq' (absorbs : Absorbent ℝ s) (a : ℝ) :\n    { x | gauge s x < a } = ⋃ (r : ℝ) (_ : 0 < r) (_ : r < a), r • s := by\n  ext\n  simp_rw [mem_setOf, mem_iUnion, exists_prop]\n  exact\n    ⟨exists_lt_of_gauge_lt absorbs, fun ⟨r, hr₀, hr₁, hx⟩ =>\n      (gauge_le_of_mem hr₀.le hx).trans_lt hr₁⟩\n\n"}
{"name":"gauge_lt_eq","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\ns : Set E\nabsorbs : Absorbent Real s\na : Real\n⊢ Eq (setOf fun x => LT.lt (gauge s x) a) (Set.iUnion fun r => Set.iUnion fun h => HSMul.hSMul r s)","decl":"theorem gauge_lt_eq (absorbs : Absorbent ℝ s) (a : ℝ) :\n    { x | gauge s x < a } = ⋃ r ∈ Set.Ioo 0 (a : ℝ), r • s := by\n  ext\n  simp_rw [mem_setOf, mem_iUnion, exists_prop, mem_Ioo, and_assoc]\n  exact\n    ⟨exists_lt_of_gauge_lt absorbs, fun ⟨r, hr₀, hr₁, hx⟩ =>\n      (gauge_le_of_mem hr₀.le hx).trans_lt hr₁⟩\n\n"}
{"name":"mem_openSegment_of_gauge_lt_one","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\ns : Set E\nx : E\nabsorbs : Absorbent Real s\nhgauge : LT.lt (gauge s x) 1\n⊢ Exists fun y => And (Membership.mem s y) (Membership.mem (openSegment Real 0 y) x)","decl":"theorem mem_openSegment_of_gauge_lt_one (absorbs : Absorbent ℝ s) (hgauge : gauge s x < 1) :\n    ∃ y ∈ s, x ∈ openSegment ℝ 0 y := by\n  rcases exists_lt_of_gauge_lt absorbs hgauge with ⟨r, hr₀, hr₁, y, hy, rfl⟩\n  refine ⟨y, hy, 1 - r, r, ?_⟩\n  simp [*]\n\n"}
{"name":"gauge_lt_one_subset_self","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\ns : Set E\nhs : Convex Real s\nh₀ : Membership.mem s 0\nabsorbs : Absorbent Real s\n⊢ HasSubset.Subset (setOf fun x => LT.lt (gauge s x) 1) s","decl":"theorem gauge_lt_one_subset_self (hs : Convex ℝ s) (h₀ : (0 : E) ∈ s) (absorbs : Absorbent ℝ s) :\n    { x | gauge s x < 1 } ⊆ s := fun _x hx ↦\n  let ⟨_y, hys, hx⟩ := mem_openSegment_of_gauge_lt_one absorbs hx\n  hs.openSegment_subset h₀ hys hx\n\n"}
{"name":"gauge_le_one_of_mem","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\ns : Set E\nx : E\nhx : Membership.mem s x\n⊢ LE.le (gauge s x) 1","decl":"theorem gauge_le_one_of_mem {x : E} (hx : x ∈ s) : gauge s x ≤ 1 :=\n  gauge_le_of_mem zero_le_one <| by rwa [one_smul]\n\n"}
{"name":"gauge_add_le","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\ns : Set E\nhs : Convex Real s\nabsorbs : Absorbent Real s\nx y : E\n⊢ LE.le (gauge s (HAdd.hAdd x y)) (HAdd.hAdd (gauge s x) (gauge s y))","decl":"/-- Gauge is subadditive. -/\ntheorem gauge_add_le (hs : Convex ℝ s) (absorbs : Absorbent ℝ s) (x y : E) :\n    gauge s (x + y) ≤ gauge s x + gauge s y := by\n  refine le_of_forall_pos_lt_add fun ε hε => ?_\n  obtain ⟨a, ha, ha', x, hx, rfl⟩ :=\n    exists_lt_of_gauge_lt absorbs (lt_add_of_pos_right (gauge s x) (half_pos hε))\n  obtain ⟨b, hb, hb', y, hy, rfl⟩ :=\n    exists_lt_of_gauge_lt absorbs (lt_add_of_pos_right (gauge s y) (half_pos hε))\n  calc\n    gauge s (a • x + b • y) ≤ a + b := gauge_le_of_mem (by positivity) <| by\n      rw [hs.add_smul ha.le hb.le]\n      exact add_mem_add (smul_mem_smul_set hx) (smul_mem_smul_set hy)\n    _ < gauge s (a • x) + gauge s (b • y) + ε := by linarith\n\n"}
{"name":"self_subset_gauge_le_one","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\ns : Set E\n⊢ HasSubset.Subset s (setOf fun x => LE.le (gauge s x) 1)","decl":"theorem self_subset_gauge_le_one : s ⊆ { x | gauge s x ≤ 1 } := fun _ => gauge_le_one_of_mem\n\n"}
{"name":"Convex.gauge_le","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\ns : Set E\nhs : Convex Real s\nh₀ : Membership.mem s 0\nabsorbs : Absorbent Real s\na : Real\n⊢ Convex Real (setOf fun x => LE.le (gauge s x) a)","decl":"theorem Convex.gauge_le (hs : Convex ℝ s) (h₀ : (0 : E) ∈ s) (absorbs : Absorbent ℝ s) (a : ℝ) :\n    Convex ℝ { x | gauge s x ≤ a } := by\n  by_cases ha : 0 ≤ a\n  · rw [gauge_le_eq hs h₀ absorbs ha]\n    exact convex_iInter fun i => convex_iInter fun _ => hs.smul _\n  · -- Porting note: `convert` needed help\n    convert convex_empty (𝕜 := ℝ) (E := E)\n    exact eq_empty_iff_forall_not_mem.2 fun x hx => ha <| (gauge_nonneg _).trans hx\n\n"}
{"name":"Balanced.starConvex","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\ns : Set E\nhs : Balanced Real s\n⊢ StarConvex Real 0 s","decl":"theorem Balanced.starConvex (hs : Balanced ℝ s) : StarConvex ℝ 0 s :=\n  starConvex_zero_iff.2 fun _ hx a ha₀ ha₁ =>\n    hs _ (by rwa [Real.norm_of_nonneg ha₀]) (smul_mem_smul_set hx)\n\n"}
{"name":"le_gauge_of_not_mem","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\ns : Set E\nx : E\na : Real\nhs₀ : StarConvex Real 0 s\nhs₂ : Absorbs Real s (Singleton.singleton x)\nhx : Not (Membership.mem (HSMul.hSMul a s) x)\n⊢ LE.le a (gauge s x)","decl":"theorem le_gauge_of_not_mem (hs₀ : StarConvex ℝ 0 s) (hs₂ : Absorbs ℝ s {x}) (hx : x ∉ a • s) :\n    a ≤ gauge s x := by\n  rw [starConvex_zero_iff] at hs₀\n  obtain ⟨r, hr, h⟩ := hs₂.exists_pos\n  refine le_csInf ⟨r, hr, singleton_subset_iff.1 <| h _ (Real.norm_of_nonneg hr.le).ge⟩ ?_\n  rintro b ⟨hb, x, hx', rfl⟩\n  refine not_lt.1 fun hba => hx ?_\n  have ha := hb.trans hba\n  refine ⟨(a⁻¹ * b) • x, hs₀ hx' (by positivity) ?_, ?_⟩\n  · rw [← div_eq_inv_mul]\n    exact div_le_one_of_le₀ hba.le ha.le\n  · dsimp only\n    rw [← mul_smul, mul_inv_cancel_left₀ ha.ne']\n\n"}
{"name":"one_le_gauge_of_not_mem","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\ns : Set E\nx : E\nhs₁ : StarConvex Real 0 s\nhs₂ : Absorbs Real s (Singleton.singleton x)\nhx : Not (Membership.mem s x)\n⊢ LE.le 1 (gauge s x)","decl":"theorem one_le_gauge_of_not_mem (hs₁ : StarConvex ℝ 0 s) (hs₂ : Absorbs ℝ s {x}) (hx : x ∉ s) :\n    1 ≤ gauge s x :=\n  le_gauge_of_not_mem hs₁ hs₂ <| by rwa [one_smul]\n\n"}
{"name":"gauge_smul_of_nonneg","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝⁶ : AddCommGroup E\ninst✝⁵ : Module Real E\nα : Type u_3\ninst✝⁴ : LinearOrderedField α\ninst✝³ : MulActionWithZero α Real\ninst✝² : OrderedSMul α Real\ninst✝¹ : MulActionWithZero α E\ninst✝ : IsScalarTower α Real (Set E)\ns : Set E\na : α\nha : LE.le 0 a\nx : E\n⊢ Eq (gauge s (HSMul.hSMul a x)) (HSMul.hSMul a (gauge s x))","decl":"theorem gauge_smul_of_nonneg [MulActionWithZero α E] [IsScalarTower α ℝ (Set E)] {s : Set E} {a : α}\n    (ha : 0 ≤ a) (x : E) : gauge s (a • x) = a • gauge s x := by\n  obtain rfl | ha' := ha.eq_or_lt\n  · rw [zero_smul, gauge_zero, zero_smul]\n  rw [gauge_def', gauge_def', ← Real.sInf_smul_of_nonneg ha]\n  congr 1\n  ext r\n  simp_rw [Set.mem_smul_set, Set.mem_sep_iff]\n  constructor\n  · rintro ⟨hr, hx⟩\n    simp_rw [mem_Ioi] at hr ⊢\n    rw [← mem_smul_set_iff_inv_smul_mem₀ hr.ne'] at hx\n    have := smul_pos (inv_pos.2 ha') hr\n    refine ⟨a⁻¹ • r, ⟨this, ?_⟩, smul_inv_smul₀ ha'.ne' _⟩\n    rwa [← mem_smul_set_iff_inv_smul_mem₀ this.ne', smul_assoc,\n      mem_smul_set_iff_inv_smul_mem₀ (inv_ne_zero ha'.ne'), inv_inv]\n  · rintro ⟨r, ⟨hr, hx⟩, rfl⟩\n    rw [mem_Ioi] at hr ⊢\n    rw [← mem_smul_set_iff_inv_smul_mem₀ hr.ne'] at hx\n    have := smul_pos ha' hr\n    refine ⟨this, ?_⟩\n    rw [← mem_smul_set_iff_inv_smul_mem₀ this.ne', smul_assoc]\n    exact smul_mem_smul_set hx\n\n"}
{"name":"gauge_smul_left_of_nonneg","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝⁸ : AddCommGroup E\ninst✝⁷ : Module Real E\nα : Type u_3\ninst✝⁶ : LinearOrderedField α\ninst✝⁵ : MulActionWithZero α Real\ninst✝⁴ : OrderedSMul α Real\ninst✝³ : MulActionWithZero α E\ninst✝² : SMulCommClass α Real Real\ninst✝¹ : IsScalarTower α Real Real\ninst✝ : IsScalarTower α Real E\ns : Set E\na : α\nha : LE.le 0 a\n⊢ Eq (gauge (HSMul.hSMul a s)) (HSMul.hSMul (Inv.inv a) (gauge s))","decl":"theorem gauge_smul_left_of_nonneg [MulActionWithZero α E] [SMulCommClass α ℝ ℝ]\n    [IsScalarTower α ℝ ℝ] [IsScalarTower α ℝ E] {s : Set E} {a : α} (ha : 0 ≤ a) :\n    gauge (a • s) = a⁻¹ • gauge s := by\n  obtain rfl | ha' := ha.eq_or_lt\n  · rw [inv_zero, zero_smul, gauge_of_subset_zero (zero_smul_set_subset _)]\n  ext x\n  rw [gauge_def', Pi.smul_apply, gauge_def', ← Real.sInf_smul_of_nonneg (inv_nonneg.2 ha)]\n  congr 1\n  ext r\n  simp_rw [Set.mem_smul_set, Set.mem_sep_iff]\n  constructor\n  · rintro ⟨hr, y, hy, h⟩\n    simp_rw [mem_Ioi] at hr ⊢\n    refine ⟨a • r, ⟨smul_pos ha' hr, ?_⟩, inv_smul_smul₀ ha'.ne' _⟩\n    rwa [smul_inv₀, smul_assoc, ← h, inv_smul_smul₀ ha'.ne']\n  · rintro ⟨r, ⟨hr, hx⟩, rfl⟩\n    rw [mem_Ioi] at hr ⊢\n    refine ⟨smul_pos (inv_pos.2 ha') hr, r⁻¹ • x, hx, ?_⟩\n    rw [smul_inv₀, smul_assoc, inv_inv]\n\n"}
{"name":"gauge_smul_left","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝⁸ : AddCommGroup E\ninst✝⁷ : Module Real E\nα : Type u_3\ninst✝⁶ : LinearOrderedField α\ninst✝⁵ : MulActionWithZero α Real\ninst✝⁴ : OrderedSMul α Real\ninst✝³ : Module α E\ninst✝² : SMulCommClass α Real Real\ninst✝¹ : IsScalarTower α Real Real\ninst✝ : IsScalarTower α Real E\ns : Set E\nsymmetric : ∀ (x : E), Membership.mem s x → Membership.mem s (Neg.neg x)\na : α\n⊢ Eq (gauge (HSMul.hSMul a s)) (HSMul.hSMul (Inv.inv (abs a)) (gauge s))","decl":"theorem gauge_smul_left [Module α E] [SMulCommClass α ℝ ℝ] [IsScalarTower α ℝ ℝ]\n    [IsScalarTower α ℝ E] {s : Set E} (symmetric : ∀ x ∈ s, -x ∈ s) (a : α) :\n    gauge (a • s) = |a|⁻¹ • gauge s := by\n  rw [← gauge_smul_left_of_nonneg (abs_nonneg a)]\n  obtain h | h := abs_choice a\n  · rw [h]\n  · rw [h, Set.neg_smul_set, ← Set.smul_set_neg]\n    -- Porting note: was congr\n    apply congr_arg\n    apply congr_arg\n    ext y\n    refine ⟨symmetric _, fun hy => ?_⟩\n    rw [← neg_neg y]\n    exact symmetric _ hy\n\n"}
{"name":"gauge_norm_smul","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module Real E\ns : Set E\ninst✝² : RCLike 𝕜\ninst✝¹ : Module 𝕜 E\ninst✝ : IsScalarTower Real 𝕜 E\nhs : Balanced 𝕜 s\nr : 𝕜\nx : E\n⊢ Eq (gauge s (HSMul.hSMul (Norm.norm r) x)) (gauge s (HSMul.hSMul r x))","decl":"theorem gauge_norm_smul (hs : Balanced 𝕜 s) (r : 𝕜) (x : E) :\n    gauge s (‖r‖ • x) = gauge s (r • x) := by\n  unfold gauge\n  congr with θ\n  rw [@RCLike.real_smul_eq_coe_smul 𝕜]\n  refine and_congr_right fun hθ => (hs.smul _).smul_mem_iff ?_\n  rw [RCLike.norm_ofReal, abs_norm]\n\n"}
{"name":"gauge_smul","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module Real E\ns : Set E\ninst✝² : RCLike 𝕜\ninst✝¹ : Module 𝕜 E\ninst✝ : IsScalarTower Real 𝕜 E\nhs : Balanced 𝕜 s\nr : 𝕜\nx : E\n⊢ Eq (gauge s (HSMul.hSMul r x)) (HMul.hMul (Norm.norm r) (gauge s x))","decl":"/-- If `s` is balanced, then the Minkowski functional is ℂ-homogeneous. -/\ntheorem gauge_smul (hs : Balanced 𝕜 s) (r : 𝕜) (x : E) : gauge s (r • x) = ‖r‖ * gauge s x := by\n  rw [← smul_eq_mul, ← gauge_smul_of_nonneg (norm_nonneg r), gauge_norm_smul hs]\n\n"}
{"name":"comap_gauge_nhds_zero_le","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝² : AddCommGroup E\ninst✝¹ : Module Real E\ns : Set E\ninst✝ : TopologicalSpace E\nha : Absorbent Real s\nhb : Bornology.IsVonNBounded Real s\n⊢ LE.le (Filter.comap (gauge s) (nhds 0)) (nhds 0)","decl":"theorem comap_gauge_nhds_zero_le (ha : Absorbent ℝ s) (hb : Bornology.IsVonNBounded ℝ s) :\n    comap (gauge s) (𝓝 0) ≤ 𝓝 0 := fun u hu ↦ by\n  rcases (hb hu).exists_pos with ⟨r, hr₀, hr⟩\n  filter_upwards [preimage_mem_comap (gt_mem_nhds (inv_pos.2 hr₀))] with x (hx : gauge s x < r⁻¹)\n  rcases exists_lt_of_gauge_lt ha hx with ⟨c, hc₀, hcr, y, hy, rfl⟩\n  have hrc := (lt_inv_comm₀ hr₀ hc₀).2 hcr\n  rcases hr c⁻¹ (hrc.le.trans (le_abs_self _)) hy with ⟨z, hz, rfl⟩\n  simpa only [smul_inv_smul₀ hc₀.ne']\n\n"}
{"name":"gauge_eq_zero","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module Real E\ns : Set E\nx : E\ninst✝¹ : TopologicalSpace E\ninst✝ : T1Space E\nhs : Absorbent Real s\nhb : Bornology.IsVonNBounded Real s\n⊢ Iff (Eq (gauge s x) 0) (Eq x 0)","decl":"theorem gauge_eq_zero (hs : Absorbent ℝ s) (hb : Bornology.IsVonNBounded ℝ s) :\n    gauge s x = 0 ↔ x = 0 := by\n  refine ⟨fun h₀ ↦ by_contra fun (hne : x ≠ 0) ↦ ?_, fun h ↦ h.symm ▸ gauge_zero⟩\n  have : {x}ᶜ ∈ comap (gauge s) (𝓝 0) :=\n    comap_gauge_nhds_zero_le hs hb (isOpen_compl_singleton.mem_nhds hne.symm)\n  rcases ((nhds_basis_zero_abs_sub_lt _).comap _).mem_iff.1 this with ⟨r, hr₀, hr⟩\n  exact hr (by simpa [h₀]) rfl\n\n"}
{"name":"gauge_pos","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module Real E\ns : Set E\nx : E\ninst✝¹ : TopologicalSpace E\ninst✝ : T1Space E\nhs : Absorbent Real s\nhb : Bornology.IsVonNBounded Real s\n⊢ Iff (LT.lt 0 (gauge s x)) (Ne x 0)","decl":"theorem gauge_pos (hs : Absorbent ℝ s) (hb : Bornology.IsVonNBounded ℝ s) :\n    0 < gauge s x ↔ x ≠ 0 := by\n  simp only [(gauge_nonneg _).gt_iff_ne, Ne, gauge_eq_zero hs hb]\n\n"}
{"name":"interior_subset_gauge_lt_one","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module Real E\ninst✝¹ : TopologicalSpace E\ninst✝ : ContinuousSMul Real E\ns : Set E\n⊢ HasSubset.Subset (interior s) (setOf fun x => LT.lt (gauge s x) 1)","decl":"open Filter in\ntheorem interior_subset_gauge_lt_one (s : Set E) : interior s ⊆ { x | gauge s x < 1 } := by\n  intro x hx\n  have H₁ : Tendsto (fun r : ℝ ↦ r⁻¹ • x) (𝓝[<] 1) (𝓝 ((1 : ℝ)⁻¹ • x)) :=\n    ((tendsto_id.inv₀ one_ne_zero).smul tendsto_const_nhds).mono_left inf_le_left\n  rw [inv_one, one_smul] at H₁\n  have H₂ : ∀ᶠ r in 𝓝[<] (1 : ℝ), x ∈ r • s ∧ 0 < r ∧ r < 1 := by\n    filter_upwards [H₁ (mem_interior_iff_mem_nhds.1 hx), Ioo_mem_nhdsLT one_pos] with r h₁ h₂\n    exact ⟨(mem_smul_set_iff_inv_smul_mem₀ h₂.1.ne' _ _).2 h₁, h₂⟩\n  rcases H₂.exists with ⟨r, hxr, hr₀, hr₁⟩\n  exact (gauge_le_of_mem hr₀.le hxr).trans_lt hr₁\n\n"}
{"name":"gauge_lt_one_eq_self_of_isOpen","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module Real E\ns : Set E\ninst✝¹ : TopologicalSpace E\ninst✝ : ContinuousSMul Real E\nhs₁ : Convex Real s\nhs₀ : Membership.mem s 0\nhs₂ : IsOpen s\n⊢ Eq (setOf fun x => LT.lt (gauge s x) 1) s","decl":"theorem gauge_lt_one_eq_self_of_isOpen (hs₁ : Convex ℝ s) (hs₀ : (0 : E) ∈ s) (hs₂ : IsOpen s) :\n    { x | gauge s x < 1 } = s := by\n  refine (gauge_lt_one_subset_self hs₁ ‹_› <| absorbent_nhds_zero <| hs₂.mem_nhds hs₀).antisymm ?_\n  convert interior_subset_gauge_lt_one s\n  exact hs₂.interior_eq.symm\n\n"}
{"name":"gauge_lt_one_of_mem_of_isOpen","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module Real E\ns : Set E\ninst✝¹ : TopologicalSpace E\ninst✝ : ContinuousSMul Real E\nhs₂ : IsOpen s\nx : E\nhx : Membership.mem s x\n⊢ LT.lt (gauge s x) 1","decl":"theorem gauge_lt_one_of_mem_of_isOpen (hs₂ : IsOpen s) {x : E} (hx : x ∈ s) :\n    gauge s x < 1 :=\n  interior_subset_gauge_lt_one s <| by rwa [hs₂.interior_eq]\n\n"}
{"name":"gauge_lt_of_mem_smul","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module Real E\ns : Set E\ninst✝¹ : TopologicalSpace E\ninst✝ : ContinuousSMul Real E\nx : E\nε : Real\nhε : LT.lt 0 ε\nhs₂ : IsOpen s\nhx : Membership.mem (HSMul.hSMul ε s) x\n⊢ LT.lt (gauge s x) ε","decl":"theorem gauge_lt_of_mem_smul (x : E) (ε : ℝ) (hε : 0 < ε) (hs₂ : IsOpen s) (hx : x ∈ ε • s) :\n    gauge s x < ε := by\n  have : ε⁻¹ • x ∈ s := by rwa [← mem_smul_set_iff_inv_smul_mem₀ hε.ne']\n  have h_gauge_lt := gauge_lt_one_of_mem_of_isOpen hs₂ this\n  rwa [gauge_smul_of_nonneg (inv_nonneg.2 hε.le), smul_eq_mul, inv_mul_lt_iff₀ hε, mul_one]\n    at h_gauge_lt\n\n"}
{"name":"mem_closure_of_gauge_le_one","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module Real E\ns : Set E\nx : E\ninst✝¹ : TopologicalSpace E\ninst✝ : ContinuousSMul Real E\nhc : Convex Real s\nhs₀ : Membership.mem s 0\nha : Absorbent Real s\nh : LE.le (gauge s x) 1\n⊢ Membership.mem (closure s) x","decl":"theorem mem_closure_of_gauge_le_one (hc : Convex ℝ s) (hs₀ : 0 ∈ s) (ha : Absorbent ℝ s)\n    (h : gauge s x ≤ 1) : x ∈ closure s := by\n  have : ∀ᶠ r : ℝ in 𝓝[<] 1, r • x ∈ s := by\n    filter_upwards [Ico_mem_nhdsLT one_pos] with r ⟨hr₀, hr₁⟩\n    apply gauge_lt_one_subset_self hc hs₀ ha\n    rw [mem_setOf_eq, gauge_smul_of_nonneg hr₀]\n    exact mul_lt_one_of_nonneg_of_lt_one_left hr₀ hr₁ h\n  refine mem_closure_of_tendsto ?_ this\n  exact Filter.Tendsto.mono_left (Continuous.tendsto' (by fun_prop) _ _ (one_smul _ _))\n    inf_le_left\n\n"}
{"name":"mem_frontier_of_gauge_eq_one","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module Real E\ns : Set E\nx : E\ninst✝¹ : TopologicalSpace E\ninst✝ : ContinuousSMul Real E\nhc : Convex Real s\nhs₀ : Membership.mem s 0\nha : Absorbent Real s\nh : Eq (gauge s x) 1\n⊢ Membership.mem (frontier s) x","decl":"theorem mem_frontier_of_gauge_eq_one (hc : Convex ℝ s) (hs₀ : 0 ∈ s) (ha : Absorbent ℝ s)\n    (h : gauge s x = 1) : x ∈ frontier s :=\n  ⟨mem_closure_of_gauge_le_one hc hs₀ ha h.le, fun h' ↦\n    (interior_subset_gauge_lt_one s h').out.ne h⟩\n\n"}
{"name":"tendsto_gauge_nhds_zero'","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module Real E\ns : Set E\ninst✝¹ : TopologicalSpace E\ninst✝ : ContinuousSMul Real E\nhs : Membership.mem (nhds 0) s\n⊢ Filter.Tendsto (gauge s) (nhds 0) (nhdsWithin 0 (Set.Ici 0))","decl":"theorem tendsto_gauge_nhds_zero' (hs : s ∈ 𝓝 0) : Tendsto (gauge s) (𝓝 0) (𝓝[≥] 0) := by\n  refine nhdsGE_basis_Icc.tendsto_right_iff.2 fun ε hε ↦ ?_\n  rw [← set_smul_mem_nhds_zero_iff hε.ne'] at hs\n  filter_upwards [hs] with x hx\n  exact ⟨gauge_nonneg _, gauge_le_of_mem hε.le hx⟩\n\n"}
{"name":"tendsto_gauge_nhds_zero","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module Real E\ns : Set E\ninst✝¹ : TopologicalSpace E\ninst✝ : ContinuousSMul Real E\nhs : Membership.mem (nhds 0) s\n⊢ Filter.Tendsto (gauge s) (nhds 0) (nhds 0)","decl":"theorem tendsto_gauge_nhds_zero (hs : s ∈ 𝓝 0) : Tendsto (gauge s) (𝓝 0) (𝓝 0) :=\n  (tendsto_gauge_nhds_zero' hs).mono_right inf_le_left\n\n"}
{"name":"continuousAt_gauge_zero","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module Real E\ns : Set E\ninst✝¹ : TopologicalSpace E\ninst✝ : ContinuousSMul Real E\nhs : Membership.mem (nhds 0) s\n⊢ ContinuousAt (gauge s) 0","decl":"/-- If `s` is a neighborhood of the origin, then `gauge s` is continuous at the origin.\nSee also `continuousAt_gauge`. -/\ntheorem continuousAt_gauge_zero (hs : s ∈ 𝓝 0) : ContinuousAt (gauge s) 0 := by\n  rw [ContinuousAt, gauge_zero]\n  exact tendsto_gauge_nhds_zero hs\n\n"}
{"name":"comap_gauge_nhds_zero","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝³ : AddCommGroup E\ninst✝² : Module Real E\ns : Set E\ninst✝¹ : TopologicalSpace E\ninst✝ : ContinuousSMul Real E\nhb : Bornology.IsVonNBounded Real s\nh₀ : Membership.mem (nhds 0) s\n⊢ Eq (Filter.comap (gauge s) (nhds 0)) (nhds 0)","decl":"theorem comap_gauge_nhds_zero (hb : Bornology.IsVonNBounded ℝ s) (h₀ : s ∈ 𝓝 0) :\n    comap (gauge s) (𝓝 0) = 𝓝 0 :=\n  (comap_gauge_nhds_zero_le (absorbent_nhds_zero h₀) hb).antisymm\n    (tendsto_gauge_nhds_zero h₀).le_comap\n\n"}
{"name":"continuousAt_gauge","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module Real E\ns : Set E\nx : E\ninst✝² : TopologicalSpace E\ninst✝¹ : TopologicalAddGroup E\ninst✝ : ContinuousSMul Real E\nhc : Convex Real s\nhs₀ : Membership.mem (nhds 0) s\n⊢ ContinuousAt (gauge s) x","decl":"/-- If `s` is a convex neighborhood of the origin in a topological real vector space, then `gauge s`\nis continuous. If the ambient space is a normed space, then `gauge s` is Lipschitz continuous, see\n`Convex.lipschitz_gauge`. -/\ntheorem continuousAt_gauge (hc : Convex ℝ s) (hs₀ : s ∈ 𝓝 0) : ContinuousAt (gauge s) x := by\n  have ha : Absorbent ℝ s := absorbent_nhds_zero hs₀\n  refine (nhds_basis_Icc_pos _).tendsto_right_iff.2 fun ε hε₀ ↦ ?_\n  rw [← map_add_left_nhds_zero, eventually_map]\n  have : ε • s ∩ -(ε • s) ∈ 𝓝 0 :=\n    inter_mem ((set_smul_mem_nhds_zero_iff hε₀.ne').2 hs₀)\n      (neg_mem_nhds_zero _ ((set_smul_mem_nhds_zero_iff hε₀.ne').2 hs₀))\n  filter_upwards [this] with y hy\n  constructor\n  · rw [sub_le_iff_le_add]\n    calc\n      gauge s x = gauge s (x + y + (-y)) := by simp\n      _ ≤ gauge s (x + y) + gauge s (-y) := gauge_add_le hc ha _ _\n      _ ≤ gauge s (x + y) + ε := add_le_add_left (gauge_le_of_mem hε₀.le (mem_neg.1 hy.2)) _\n  · calc\n      gauge s (x + y) ≤ gauge s x + gauge s y := gauge_add_le hc ha _ _\n      _ ≤ gauge s x + ε := add_le_add_left (gauge_le_of_mem hε₀.le hy.1) _\n\n"}
{"name":"continuous_gauge","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module Real E\ns : Set E\ninst✝² : TopologicalSpace E\ninst✝¹ : TopologicalAddGroup E\ninst✝ : ContinuousSMul Real E\nhc : Convex Real s\nhs₀ : Membership.mem (nhds 0) s\n⊢ Continuous (gauge s)","decl":"/-- If `s` is a convex neighborhood of the origin in a topological real vector space, then `gauge s`\nis continuous. If the ambient space is a normed space, then `gauge s` is Lipschitz continuous, see\n`Convex.lipschitz_gauge`. -/\n@[continuity]\ntheorem continuous_gauge (hc : Convex ℝ s) (hs₀ : s ∈ 𝓝 0) : Continuous (gauge s) :=\n  continuous_iff_continuousAt.2 fun _ ↦ continuousAt_gauge hc hs₀\n\n"}
{"name":"gauge_lt_one_eq_interior","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module Real E\ns : Set E\ninst✝² : TopologicalSpace E\ninst✝¹ : TopologicalAddGroup E\ninst✝ : ContinuousSMul Real E\nhc : Convex Real s\nhs₀ : Membership.mem (nhds 0) s\n⊢ Eq (setOf fun x => LT.lt (gauge s x) 1) (interior s)","decl":"theorem gauge_lt_one_eq_interior (hc : Convex ℝ s) (hs₀ : s ∈ 𝓝 0) :\n    { x | gauge s x < 1 } = interior s := by\n  refine Subset.antisymm (fun x hx ↦ ?_) (interior_subset_gauge_lt_one s)\n  rcases mem_openSegment_of_gauge_lt_one (absorbent_nhds_zero hs₀) hx with ⟨y, hys, hxy⟩\n  exact hc.openSegment_interior_self_subset_interior (mem_interior_iff_mem_nhds.2 hs₀) hys hxy\n\n"}
{"name":"gauge_lt_one_iff_mem_interior","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module Real E\ns : Set E\nx : E\ninst✝² : TopologicalSpace E\ninst✝¹ : TopologicalAddGroup E\ninst✝ : ContinuousSMul Real E\nhc : Convex Real s\nhs₀ : Membership.mem (nhds 0) s\n⊢ Iff (LT.lt (gauge s x) 1) (Membership.mem (interior s) x)","decl":"theorem gauge_lt_one_iff_mem_interior (hc : Convex ℝ s) (hs₀ : s ∈ 𝓝 0) :\n    gauge s x < 1 ↔ x ∈ interior s :=\n  Set.ext_iff.1 (gauge_lt_one_eq_interior hc hs₀) _\n\n"}
{"name":"gauge_le_one_iff_mem_closure","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module Real E\ns : Set E\nx : E\ninst✝² : TopologicalSpace E\ninst✝¹ : TopologicalAddGroup E\ninst✝ : ContinuousSMul Real E\nhc : Convex Real s\nhs₀ : Membership.mem (nhds 0) s\n⊢ Iff (LE.le (gauge s x) 1) (Membership.mem (closure s) x)","decl":"theorem gauge_le_one_iff_mem_closure (hc : Convex ℝ s) (hs₀ : s ∈ 𝓝 0) :\n    gauge s x ≤ 1 ↔ x ∈ closure s :=\n  ⟨mem_closure_of_gauge_le_one hc (mem_of_mem_nhds hs₀) (absorbent_nhds_zero hs₀), fun h ↦\n    le_on_closure (fun _ ↦ gauge_le_one_of_mem) (continuous_gauge hc hs₀).continuousOn\n      continuousOn_const h⟩\n\n"}
{"name":"gauge_eq_one_iff_mem_frontier","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module Real E\ns : Set E\nx : E\ninst✝² : TopologicalSpace E\ninst✝¹ : TopologicalAddGroup E\ninst✝ : ContinuousSMul Real E\nhc : Convex Real s\nhs₀ : Membership.mem (nhds 0) s\n⊢ Iff (Eq (gauge s x) 1) (Membership.mem (frontier s) x)","decl":"theorem gauge_eq_one_iff_mem_frontier (hc : Convex ℝ s) (hs₀ : s ∈ 𝓝 0) :\n    gauge s x = 1 ↔ x ∈ frontier s := by\n  rw [eq_iff_le_not_lt, gauge_le_one_iff_mem_closure hc hs₀, gauge_lt_one_iff_mem_interior hc hs₀]\n  rfl\n\n"}
{"name":"gaugeSeminorm_toFun","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module Real E\ns : Set E\ninst✝² : RCLike 𝕜\ninst✝¹ : Module 𝕜 E\ninst✝ : IsScalarTower Real 𝕜 E\nhs₀ : Balanced 𝕜 s\nhs₁ : Convex Real s\nhs₂ : Absorbent Real s\nx : E\n⊢ Eq ((gaugeSeminorm hs₀ hs₁ hs₂) x) (gauge s x)","decl":"/-- `gauge s` as a seminorm when `s` is balanced, convex and absorbent. -/\n@[simps!]\ndef gaugeSeminorm (hs₀ : Balanced 𝕜 s) (hs₁ : Convex ℝ s) (hs₂ : Absorbent ℝ s) : Seminorm 𝕜 E :=\n  Seminorm.of (gauge s) (gauge_add_le hs₁ hs₂) (gauge_smul hs₀)\n\n"}
{"name":"gaugeSeminorm_lt_one_of_isOpen","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁶ : AddCommGroup E\ninst✝⁵ : Module Real E\ns : Set E\ninst✝⁴ : RCLike 𝕜\ninst✝³ : Module 𝕜 E\ninst✝² : IsScalarTower Real 𝕜 E\nhs₀ : Balanced 𝕜 s\nhs₁ : Convex Real s\nhs₂ : Absorbent Real s\ninst✝¹ : TopologicalSpace E\ninst✝ : ContinuousSMul Real E\nhs : IsOpen s\nx : E\nhx : Membership.mem s x\n⊢ LT.lt ((gaugeSeminorm hs₀ hs₁ hs₂) x) 1","decl":"theorem gaugeSeminorm_lt_one_of_isOpen (hs : IsOpen s) {x : E} (hx : x ∈ s) :\n    gaugeSeminorm hs₀ hs₁ hs₂ x < 1 :=\n  gauge_lt_one_of_mem_of_isOpen hs hx\n\n"}
{"name":"gaugeSeminorm_ball_one","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁶ : AddCommGroup E\ninst✝⁵ : Module Real E\ns : Set E\ninst✝⁴ : RCLike 𝕜\ninst✝³ : Module 𝕜 E\ninst✝² : IsScalarTower Real 𝕜 E\nhs₀ : Balanced 𝕜 s\nhs₁ : Convex Real s\nhs₂ : Absorbent Real s\ninst✝¹ : TopologicalSpace E\ninst✝ : ContinuousSMul Real E\nhs : IsOpen s\n⊢ Eq ((gaugeSeminorm hs₀ hs₁ hs₂).ball 0 1) s","decl":"theorem gaugeSeminorm_ball_one (hs : IsOpen s) : (gaugeSeminorm hs₀ hs₁ hs₂).ball 0 1 = s := by\n  rw [Seminorm.ball_zero_eq]\n  exact gauge_lt_one_eq_self_of_isOpen hs₁ hs₂.zero_mem hs\n\n"}
{"name":"Seminorm.gauge_ball","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\np : Seminorm Real E\n⊢ Eq (gauge (p.ball 0 1)) ⇑p","decl":"/-- Any seminorm arises as the gauge of its unit ball. -/\n@[simp]\nprotected theorem Seminorm.gauge_ball (p : Seminorm ℝ E) : gauge (p.ball 0 1) = p := by\n  ext x\n  obtain hp | hp := { r : ℝ | 0 < r ∧ x ∈ r • p.ball 0 1 }.eq_empty_or_nonempty\n  · rw [gauge, hp, Real.sInf_empty]\n    by_contra h\n    have hpx : 0 < p x := (apply_nonneg _ _).lt_of_ne h\n    have hpx₂ : 0 < 2 * p x := mul_pos zero_lt_two hpx\n    refine hp.subset ⟨hpx₂, (2 * p x)⁻¹ • x, ?_, smul_inv_smul₀ hpx₂.ne' _⟩\n    rw [p.mem_ball_zero, map_smul_eq_mul, Real.norm_eq_abs, abs_of_pos (inv_pos.2 hpx₂),\n      inv_mul_lt_iff₀ hpx₂, mul_one]\n    exact lt_mul_of_one_lt_left hpx one_lt_two\n  refine IsGLB.csInf_eq ⟨fun r => ?_, fun r hr => le_of_forall_pos_le_add fun ε hε => ?_⟩ hp\n  · rintro ⟨hr, y, hy, rfl⟩\n    rw [p.mem_ball_zero] at hy\n    rw [map_smul_eq_mul, Real.norm_eq_abs, abs_of_pos hr]\n    exact mul_le_of_le_one_right hr.le hy.le\n  · have hpε : 0 < p x + ε :=\n      -- Porting note: was `by positivity`\n      add_pos_of_nonneg_of_pos (apply_nonneg _ _) hε\n    refine hr ⟨hpε, (p x + ε)⁻¹ • x, ?_, smul_inv_smul₀ hpε.ne' _⟩\n    rw [p.mem_ball_zero, map_smul_eq_mul, Real.norm_eq_abs, abs_of_pos (inv_pos.2 hpε),\n      inv_mul_lt_iff₀ hpε, mul_one]\n    exact lt_add_of_pos_right _ hε\n\n"}
{"name":"Seminorm.gaugeSeminorm_ball","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\np : Seminorm Real E\n⊢ Eq (gaugeSeminorm ⋯ ⋯ ⋯) p","decl":"theorem Seminorm.gaugeSeminorm_ball (p : Seminorm ℝ E) :\n    gaugeSeminorm (p.balanced_ball_zero 1) (p.convex_ball 0 1) (p.absorbent_ball_zero zero_lt_one) =\n      p :=\n  DFunLike.coe_injective p.gauge_ball\n\n"}
{"name":"gauge_unit_ball","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace Real E\nx : E\n⊢ Eq (gauge (Metric.ball 0 1) x) (Norm.norm x)","decl":"theorem gauge_unit_ball (x : E) : gauge (ball (0 : E) 1) x = ‖x‖ := by\n  rw [← ball_normSeminorm ℝ, Seminorm.gauge_ball, coe_normSeminorm]\n\n"}
{"name":"gauge_ball","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace Real E\nr : Real\nhr : LE.le 0 r\nx : E\n⊢ Eq (gauge (Metric.ball 0 r) x) (HDiv.hDiv (Norm.norm x) r)","decl":"theorem gauge_ball (hr : 0 ≤ r) (x : E) : gauge (ball (0 : E) r) x = ‖x‖ / r := by\n  rcases hr.eq_or_lt with rfl | hr\n  · simp\n  · rw [← smul_unitBall_of_pos hr, gauge_smul_left, Pi.smul_apply, gauge_unit_ball, smul_eq_mul,\n    abs_of_nonneg hr.le, div_eq_inv_mul]\n    simp_rw [mem_ball_zero_iff, norm_neg]\n    exact fun _ => id\n\n"}
{"name":"gauge_closure_zero","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace Real E\n⊢ Eq (gauge (closure 0)) 0","decl":"@[simp]\ntheorem gauge_closure_zero : gauge (closure (0 : Set E)) = 0 := funext fun x ↦ by\n  simp only [← singleton_zero, gauge_def', mem_closure_zero_iff_norm, norm_smul, mul_eq_zero,\n    norm_eq_zero, inv_eq_zero]\n  rcases (norm_nonneg x).eq_or_gt with hx | hx\n  · convert csInf_Ioi (a := (0 : ℝ))\n    exact Set.ext fun r ↦ and_iff_left (.inr hx)\n  · convert Real.sInf_empty\n    exact eq_empty_of_forall_not_mem fun r ⟨hr₀, hr⟩ ↦ hx.ne' <| hr.resolve_left hr₀.out.ne'\n\n"}
{"name":"gauge_closedBall","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace Real E\nr : Real\nhr : LE.le 0 r\nx : E\n⊢ Eq (gauge (Metric.closedBall 0 r) x) (HDiv.hDiv (Norm.norm x) r)","decl":"@[simp]\ntheorem gauge_closedBall (hr : 0 ≤ r) (x : E) : gauge (closedBall (0 : E) r) x = ‖x‖ / r := by\n  rcases hr.eq_or_lt with rfl | hr'\n  · rw [div_zero, closedBall_zero', singleton_zero, gauge_closure_zero]; rfl\n  · apply le_antisymm\n    · rw [← gauge_ball hr]\n      exact gauge_mono (absorbent_ball_zero hr') ball_subset_closedBall x\n    · suffices ∀ᶠ R in 𝓝[>] r, ‖x‖ / R ≤ gauge (closedBall 0 r) x by\n        refine le_of_tendsto ?_ this\n        exact tendsto_const_nhds.div inf_le_left hr'.ne'\n      filter_upwards [self_mem_nhdsWithin] with R hR\n      rw [← gauge_ball (hr.trans hR.out.le)]\n      refine gauge_mono ?_ (closedBall_subset_ball hR) _\n      exact (absorbent_ball_zero hr').mono ball_subset_closedBall\n\n"}
{"name":"mul_gauge_le_norm","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace Real E\ns : Set E\nr : Real\nx : E\nhs : HasSubset.Subset (Metric.ball 0 r) s\n⊢ LE.le (HMul.hMul r (gauge s x)) (Norm.norm x)","decl":"theorem mul_gauge_le_norm (hs : Metric.ball (0 : E) r ⊆ s) : r * gauge s x ≤ ‖x‖ := by\n  obtain hr | hr := le_or_lt r 0\n  · exact (mul_nonpos_of_nonpos_of_nonneg hr <| gauge_nonneg _).trans (norm_nonneg _)\n  rw [mul_comm, ← le_div_iff₀ hr, ← gauge_ball hr.le]\n  exact gauge_mono (absorbent_ball_zero hr) hs x\n\n"}
{"name":"Convex.lipschitzWith_gauge","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace Real E\ns : Set E\nr : NNReal\nhc : Convex Real s\nhr : LT.lt 0 r\nhs : HasSubset.Subset (Metric.ball 0 ↑r) s\n⊢ LipschitzWith (Inv.inv r) (gauge s)","decl":"theorem Convex.lipschitzWith_gauge {r : ℝ≥0} (hc : Convex ℝ s) (hr : 0 < r)\n    (hs : Metric.ball (0 : E) r ⊆ s) : LipschitzWith r⁻¹ (gauge s) :=\n  have : Absorbent ℝ (Metric.ball (0 : E) r) := absorbent_ball_zero hr\n  LipschitzWith.of_le_add_mul _ fun x y =>\n    calc\n      gauge s x = gauge s (y + (x - y)) := by simp\n      _ ≤ gauge s y + gauge s (x - y) := gauge_add_le hc (this.mono hs) _ _\n      _ ≤ gauge s y + ‖x - y‖ / r :=\n        add_le_add_left ((gauge_mono this hs (x - y)).trans_eq (gauge_ball hr.le _)) _\n      _ = gauge s y + r⁻¹ * dist x y := by rw [dist_eq_norm, div_eq_inv_mul, NNReal.coe_inv]\n\n"}
{"name":"Convex.lipschitz_gauge","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace Real E\ns : Set E\nhc : Convex Real s\nh₀ : Membership.mem (nhds 0) s\n⊢ Exists fun K => LipschitzWith K (gauge s)","decl":"theorem Convex.lipschitz_gauge (hc : Convex ℝ s) (h₀ : s ∈ 𝓝 (0 : E)) :\n    ∃ K, LipschitzWith K (gauge s) :=\n  let ⟨r, hr₀, hr⟩ := Metric.mem_nhds_iff.1 h₀\n  ⟨(⟨r, hr₀.le⟩ : ℝ≥0)⁻¹, hc.lipschitzWith_gauge hr₀ hr⟩\n\n"}
{"name":"Convex.uniformContinuous_gauge","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace Real E\ns : Set E\nhc : Convex Real s\nh₀ : Membership.mem (nhds 0) s\n⊢ UniformContinuous (gauge s)","decl":"theorem Convex.uniformContinuous_gauge (hc : Convex ℝ s) (h₀ : s ∈ 𝓝 (0 : E)) :\n    UniformContinuous (gauge s) :=\n  let ⟨_K, hK⟩ := hc.lipschitz_gauge h₀; hK.uniformContinuous\n\n"}
{"name":"le_gauge_of_subset_closedBall","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\ns : Set E\nr : Real\nx : E\nhs : Absorbent Real s\nhr : LE.le 0 r\nhsr : HasSubset.Subset s (Metric.closedBall 0 r)\n⊢ LE.le (HDiv.hDiv (Norm.norm x) r) (gauge s x)","decl":"theorem le_gauge_of_subset_closedBall (hs : Absorbent ℝ s) (hr : 0 ≤ r) (hsr : s ⊆ closedBall 0 r) :\n    ‖x‖ / r ≤ gauge s x := by\n  rw [← gauge_closedBall hr]\n  exact gauge_mono hs hsr _\n\n"}
