{"name":"gauge_def","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Real E\ns : Set E\nx : E\nâŠ¢ Eq (gauge s x) (InfSet.sInf (setOf fun r => And (Membership.mem (Set.Ioi 0) r) (Membership.mem (HSMul.hSMul r s) x)))","decl":"theorem gauge_def : gauge s x = sInf ({ r âˆˆ Set.Ioi (0 : â„) | x âˆˆ r â€¢ s }) :=\n  rfl\n\n"}
{"name":"gauge_def'","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Real E\ns : Set E\nx : E\nâŠ¢ Eq (gauge s x) (InfSet.sInf (setOf fun r => And (Membership.mem (Set.Ioi 0) r) (Membership.mem s (HSMul.hSMul (Inv.inv r) x))))","decl":"/-- An alternative definition of the gauge using scalar multiplication on the element rather than on\nthe set. -/\ntheorem gauge_def' : gauge s x = sInf {r âˆˆ Set.Ioi (0 : â„) | râ»Â¹ â€¢ x âˆˆ s} := by\n  congrm sInf {r | ?_}\n  exact and_congr_right fun hr => mem_smul_set_iff_inv_smul_memâ‚€ hr.ne' _ _\n\n"}
{"name":"Absorbent.gauge_set_nonempty","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Real E\ns : Set E\nx : E\nabsorbs : Absorbent Real s\nâŠ¢ (setOf fun r => And (LT.lt 0 r) (Membership.mem (HSMul.hSMul r s) x)).Nonempty","decl":"/-- If the given subset is `Absorbent` then the set we take an infimum over in `gauge` is nonempty,\nwhich is useful for proving many properties about the gauge. -/\ntheorem Absorbent.gauge_set_nonempty (absorbs : Absorbent â„ s) :\n    { r : â„ | 0 < r âˆ§ x âˆˆ r â€¢ s }.Nonempty :=\n  let âŸ¨r, hrâ‚, hrâ‚‚âŸ© := (absorbs x).exists_pos\n  âŸ¨r, hrâ‚, hrâ‚‚ r (Real.norm_of_nonneg hrâ‚.le).ge rflâŸ©\n\n"}
{"name":"gauge_mono","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Real E\ns t : Set E\nhs : Absorbent Real s\nh : HasSubset.Subset s t\nâŠ¢ LE.le (gauge t) (gauge s)","decl":"theorem gauge_mono (hs : Absorbent â„ s) (h : s âŠ† t) : gauge t â‰¤ gauge s := fun _ =>\n  csInf_le_csInf gauge_set_bddBelow hs.gauge_set_nonempty fun _ hr => âŸ¨hr.1, smul_set_mono h hr.2âŸ©\n\n"}
{"name":"exists_lt_of_gauge_lt","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Real E\ns : Set E\nx : E\na : Real\nabsorbs : Absorbent Real s\nh : LT.lt (gauge s x) a\nâŠ¢ Exists fun b => And (LT.lt 0 b) (And (LT.lt b a) (Membership.mem (HSMul.hSMul b s) x))","decl":"theorem exists_lt_of_gauge_lt (absorbs : Absorbent â„ s) (h : gauge s x < a) :\n    âˆƒ b, 0 < b âˆ§ b < a âˆ§ x âˆˆ b â€¢ s := by\n  obtain âŸ¨b, âŸ¨hb, hxâŸ©, hbaâŸ© := exists_lt_of_csInf_lt absorbs.gauge_set_nonempty h\n  exact âŸ¨b, hb, hba, hxâŸ©\n\n"}
{"name":"gauge_zero","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Real E\ns : Set E\nâŠ¢ Eq (gauge s 0) 0","decl":"/-- The gauge evaluated at `0` is always zero (mathematically this requires `0` to be in the set `s`\nbut, the real infimum of the empty set in Lean being defined as `0`, it holds unconditionally). -/\n@[simp]\ntheorem gauge_zero : gauge s 0 = 0 := by\n  rw [gauge_def']\n  by_cases h : (0 : E) âˆˆ s\n  Â· simp only [smul_zero, sep_true, h, csInf_Ioi]\n  Â· simp only [smul_zero, sep_false, h, Real.sInf_empty]\n\n"}
{"name":"gauge_zero'","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Real E\nâŠ¢ Eq (gauge 0) 0","decl":"@[simp]\ntheorem gauge_zero' : gauge (0 : Set E) = 0 := by\n  ext x\n  rw [gauge_def']\n  obtain rfl | hx := eq_or_ne x 0\n  Â· simp only [csInf_Ioi, mem_zero, Pi.zero_apply, eq_self_iff_true, sep_true, smul_zero]\n  Â· simp only [mem_zero, Pi.zero_apply, inv_eq_zero, smul_eq_zero]\n    convert Real.sInf_empty\n    exact eq_empty_iff_forall_not_mem.2 fun r hr => hr.2.elim (ne_of_gt hr.1) hx\n\n"}
{"name":"gauge_empty","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Real E\nâŠ¢ Eq (gauge EmptyCollection.emptyCollection) 0","decl":"@[simp]\ntheorem gauge_empty : gauge (âˆ… : Set E) = 0 := by\n  ext\n  simp only [gauge_def', Real.sInf_empty, mem_empty_iff_false, Pi.zero_apply, sep_false]\n\n"}
{"name":"gauge_of_subset_zero","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Real E\ns : Set E\nh : HasSubset.Subset s 0\nâŠ¢ Eq (gauge s) 0","decl":"theorem gauge_of_subset_zero (h : s âŠ† 0) : gauge s = 0 := by\n  obtain rfl | rfl := subset_singleton_iff_eq.1 h\n  exacts [gauge_empty, gauge_zero']\n\n"}
{"name":"gauge_nonneg","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Real E\ns : Set E\nx : E\nâŠ¢ LE.le 0 (gauge s x)","decl":"/-- The gauge is always nonnegative. -/\ntheorem gauge_nonneg (x : E) : 0 â‰¤ gauge s x :=\n  Real.sInf_nonneg fun _ hx => hx.1.le\n\n"}
{"name":"gauge_neg","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Real E\ns : Set E\nsymmetric : âˆ€ (x : E), Membership.mem s x â†’ Membership.mem s (Neg.neg x)\nx : E\nâŠ¢ Eq (gauge s (Neg.neg x)) (gauge s x)","decl":"theorem gauge_neg (symmetric : âˆ€ x âˆˆ s, -x âˆˆ s) (x : E) : gauge s (-x) = gauge s x := by\n  have : âˆ€ x, -x âˆˆ s â†” x âˆˆ s := fun x => âŸ¨fun h => by simpa using symmetric _ h, symmetric xâŸ©\n  simp_rw [gauge_def', smul_neg, this]\n\n"}
{"name":"gauge_neg_set_neg","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Real E\ns : Set E\nx : E\nâŠ¢ Eq (gauge (Neg.neg s) (Neg.neg x)) (gauge s x)","decl":"theorem gauge_neg_set_neg (x : E) : gauge (-s) (-x) = gauge s x := by\n  simp_rw [gauge_def', smul_neg, neg_mem_neg]\n\n"}
{"name":"gauge_neg_set_eq_gauge_neg","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Real E\ns : Set E\nx : E\nâŠ¢ Eq (gauge (Neg.neg s) x) (gauge s (Neg.neg x))","decl":"theorem gauge_neg_set_eq_gauge_neg (x : E) : gauge (-s) x = gauge s (-x) := by\n  rw [â† gauge_neg_set_neg, neg_neg]\n\n"}
{"name":"gauge_le_of_mem","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Real E\ns : Set E\nx : E\na : Real\nha : LE.le 0 a\nhx : Membership.mem (HSMul.hSMul a s) x\nâŠ¢ LE.le (gauge s x) a","decl":"theorem gauge_le_of_mem (ha : 0 â‰¤ a) (hx : x âˆˆ a â€¢ s) : gauge s x â‰¤ a := by\n  obtain rfl | ha' := ha.eq_or_lt\n  Â· rw [mem_singleton_iff.1 (zero_smul_set_subset _ hx), gauge_zero]\n  Â· exact csInf_le gauge_set_bddBelow âŸ¨ha', hxâŸ©\n\n"}
{"name":"gauge_le_eq","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Real E\ns : Set E\na : Real\nhsâ‚ : Convex Real s\nhsâ‚€ : Membership.mem s 0\nhsâ‚‚ : Absorbent Real s\nha : LE.le 0 a\nâŠ¢ Eq (setOf fun x => LE.le (gauge s x) a) (Set.iInter fun r => Set.iInter fun x => HSMul.hSMul r s)","decl":"theorem gauge_le_eq (hsâ‚ : Convex â„ s) (hsâ‚€ : (0 : E) âˆˆ s) (hsâ‚‚ : Absorbent â„ s) (ha : 0 â‰¤ a) :\n    { x | gauge s x â‰¤ a } = â‹‚ (r : â„) (_ : a < r), r â€¢ s := by\n  ext x\n  simp_rw [Set.mem_iInter, Set.mem_setOf_eq]\n  refine âŸ¨fun h r hr => ?_, fun h => le_of_forall_pos_lt_add fun Îµ hÎµ => ?_âŸ©\n  Â· have hr' := ha.trans_lt hr\n    rw [mem_smul_set_iff_inv_smul_memâ‚€ hr'.ne']\n    obtain âŸ¨Î´, Î´_pos, hÎ´r, hÎ´âŸ© := exists_lt_of_gauge_lt hsâ‚‚ (h.trans_lt hr)\n    suffices (râ»Â¹ * Î´) â€¢ Î´â»Â¹ â€¢ x âˆˆ s by rwa [smul_smul, mul_inv_cancel_rightâ‚€ Î´_pos.ne'] at this\n    rw [mem_smul_set_iff_inv_smul_memâ‚€ Î´_pos.ne'] at hÎ´\n    refine hsâ‚.smul_mem_of_zero_mem hsâ‚€ hÎ´ âŸ¨by positivity, ?_âŸ©\n    rw [inv_mul_le_iffâ‚€ hr', mul_one]\n    exact hÎ´r.le\n  Â· have hÎµ' := (lt_add_iff_pos_right a).2 (half_pos hÎµ)\n    exact\n      (gauge_le_of_mem (ha.trans hÎµ'.le) <| h _ hÎµ').trans_lt (add_lt_add_left (half_lt_self hÎµ) _)\n\n"}
{"name":"gauge_lt_eq'","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Real E\ns : Set E\nabsorbs : Absorbent Real s\na : Real\nâŠ¢ Eq (setOf fun x => LT.lt (gauge s x) a) (Set.iUnion fun r => Set.iUnion fun x => Set.iUnion fun x => HSMul.hSMul r s)","decl":"theorem gauge_lt_eq' (absorbs : Absorbent â„ s) (a : â„) :\n    { x | gauge s x < a } = â‹ƒ (r : â„) (_ : 0 < r) (_ : r < a), r â€¢ s := by\n  ext\n  simp_rw [mem_setOf, mem_iUnion, exists_prop]\n  exact\n    âŸ¨exists_lt_of_gauge_lt absorbs, fun âŸ¨r, hrâ‚€, hrâ‚, hxâŸ© =>\n      (gauge_le_of_mem hrâ‚€.le hx).trans_lt hrâ‚âŸ©\n\n"}
{"name":"gauge_lt_eq","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Real E\ns : Set E\nabsorbs : Absorbent Real s\na : Real\nâŠ¢ Eq (setOf fun x => LT.lt (gauge s x) a) (Set.iUnion fun r => Set.iUnion fun h => HSMul.hSMul r s)","decl":"theorem gauge_lt_eq (absorbs : Absorbent â„ s) (a : â„) :\n    { x | gauge s x < a } = â‹ƒ r âˆˆ Set.Ioo 0 (a : â„), r â€¢ s := by\n  ext\n  simp_rw [mem_setOf, mem_iUnion, exists_prop, mem_Ioo, and_assoc]\n  exact\n    âŸ¨exists_lt_of_gauge_lt absorbs, fun âŸ¨r, hrâ‚€, hrâ‚, hxâŸ© =>\n      (gauge_le_of_mem hrâ‚€.le hx).trans_lt hrâ‚âŸ©\n\n"}
{"name":"mem_openSegment_of_gauge_lt_one","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Real E\ns : Set E\nx : E\nabsorbs : Absorbent Real s\nhgauge : LT.lt (gauge s x) 1\nâŠ¢ Exists fun y => And (Membership.mem s y) (Membership.mem (openSegment Real 0 y) x)","decl":"theorem mem_openSegment_of_gauge_lt_one (absorbs : Absorbent â„ s) (hgauge : gauge s x < 1) :\n    âˆƒ y âˆˆ s, x âˆˆ openSegment â„ 0 y := by\n  rcases exists_lt_of_gauge_lt absorbs hgauge with âŸ¨r, hrâ‚€, hrâ‚, y, hy, rflâŸ©\n  refine âŸ¨y, hy, 1 - r, r, ?_âŸ©\n  simp [*]\n\n"}
{"name":"gauge_lt_one_subset_self","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Real E\ns : Set E\nhs : Convex Real s\nhâ‚€ : Membership.mem s 0\nabsorbs : Absorbent Real s\nâŠ¢ HasSubset.Subset (setOf fun x => LT.lt (gauge s x) 1) s","decl":"theorem gauge_lt_one_subset_self (hs : Convex â„ s) (hâ‚€ : (0 : E) âˆˆ s) (absorbs : Absorbent â„ s) :\n    { x | gauge s x < 1 } âŠ† s := fun _x hx â†¦\n  let âŸ¨_y, hys, hxâŸ© := mem_openSegment_of_gauge_lt_one absorbs hx\n  hs.openSegment_subset hâ‚€ hys hx\n\n"}
{"name":"gauge_le_one_of_mem","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Real E\ns : Set E\nx : E\nhx : Membership.mem s x\nâŠ¢ LE.le (gauge s x) 1","decl":"theorem gauge_le_one_of_mem {x : E} (hx : x âˆˆ s) : gauge s x â‰¤ 1 :=\n  gauge_le_of_mem zero_le_one <| by rwa [one_smul]\n\n"}
{"name":"gauge_add_le","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Real E\ns : Set E\nhs : Convex Real s\nabsorbs : Absorbent Real s\nx y : E\nâŠ¢ LE.le (gauge s (HAdd.hAdd x y)) (HAdd.hAdd (gauge s x) (gauge s y))","decl":"/-- Gauge is subadditive. -/\ntheorem gauge_add_le (hs : Convex â„ s) (absorbs : Absorbent â„ s) (x y : E) :\n    gauge s (x + y) â‰¤ gauge s x + gauge s y := by\n  refine le_of_forall_pos_lt_add fun Îµ hÎµ => ?_\n  obtain âŸ¨a, ha, ha', x, hx, rflâŸ© :=\n    exists_lt_of_gauge_lt absorbs (lt_add_of_pos_right (gauge s x) (half_pos hÎµ))\n  obtain âŸ¨b, hb, hb', y, hy, rflâŸ© :=\n    exists_lt_of_gauge_lt absorbs (lt_add_of_pos_right (gauge s y) (half_pos hÎµ))\n  calc\n    gauge s (a â€¢ x + b â€¢ y) â‰¤ a + b := gauge_le_of_mem (by positivity) <| by\n      rw [hs.add_smul ha.le hb.le]\n      exact add_mem_add (smul_mem_smul_set hx) (smul_mem_smul_set hy)\n    _ < gauge s (a â€¢ x) + gauge s (b â€¢ y) + Îµ := by linarith\n\n"}
{"name":"self_subset_gauge_le_one","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Real E\ns : Set E\nâŠ¢ HasSubset.Subset s (setOf fun x => LE.le (gauge s x) 1)","decl":"theorem self_subset_gauge_le_one : s âŠ† { x | gauge s x â‰¤ 1 } := fun _ => gauge_le_one_of_mem\n\n"}
{"name":"Convex.gauge_le","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Real E\ns : Set E\nhs : Convex Real s\nhâ‚€ : Membership.mem s 0\nabsorbs : Absorbent Real s\na : Real\nâŠ¢ Convex Real (setOf fun x => LE.le (gauge s x) a)","decl":"theorem Convex.gauge_le (hs : Convex â„ s) (hâ‚€ : (0 : E) âˆˆ s) (absorbs : Absorbent â„ s) (a : â„) :\n    Convex â„ { x | gauge s x â‰¤ a } := by\n  by_cases ha : 0 â‰¤ a\n  Â· rw [gauge_le_eq hs hâ‚€ absorbs ha]\n    exact convex_iInter fun i => convex_iInter fun _ => hs.smul _\n  Â· -- Porting note: `convert` needed help\n    convert convex_empty (ğ•œ := â„) (E := E)\n    exact eq_empty_iff_forall_not_mem.2 fun x hx => ha <| (gauge_nonneg _).trans hx\n\n"}
{"name":"Balanced.starConvex","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Real E\ns : Set E\nhs : Balanced Real s\nâŠ¢ StarConvex Real 0 s","decl":"theorem Balanced.starConvex (hs : Balanced â„ s) : StarConvex â„ 0 s :=\n  starConvex_zero_iff.2 fun _ hx a haâ‚€ haâ‚ =>\n    hs _ (by rwa [Real.norm_of_nonneg haâ‚€]) (smul_mem_smul_set hx)\n\n"}
{"name":"le_gauge_of_not_mem","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Real E\ns : Set E\nx : E\na : Real\nhsâ‚€ : StarConvex Real 0 s\nhsâ‚‚ : Absorbs Real s (Singleton.singleton x)\nhx : Not (Membership.mem (HSMul.hSMul a s) x)\nâŠ¢ LE.le a (gauge s x)","decl":"theorem le_gauge_of_not_mem (hsâ‚€ : StarConvex â„ 0 s) (hsâ‚‚ : Absorbs â„ s {x}) (hx : x âˆ‰ a â€¢ s) :\n    a â‰¤ gauge s x := by\n  rw [starConvex_zero_iff] at hsâ‚€\n  obtain âŸ¨r, hr, hâŸ© := hsâ‚‚.exists_pos\n  refine le_csInf âŸ¨r, hr, singleton_subset_iff.1 <| h _ (Real.norm_of_nonneg hr.le).geâŸ© ?_\n  rintro b âŸ¨hb, x, hx', rflâŸ©\n  refine not_lt.1 fun hba => hx ?_\n  have ha := hb.trans hba\n  refine âŸ¨(aâ»Â¹ * b) â€¢ x, hsâ‚€ hx' (by positivity) ?_, ?_âŸ©\n  Â· rw [â† div_eq_inv_mul]\n    exact div_le_one_of_leâ‚€ hba.le ha.le\n  Â· dsimp only\n    rw [â† mul_smul, mul_inv_cancel_leftâ‚€ ha.ne']\n\n"}
{"name":"one_le_gauge_of_not_mem","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Real E\ns : Set E\nx : E\nhsâ‚ : StarConvex Real 0 s\nhsâ‚‚ : Absorbs Real s (Singleton.singleton x)\nhx : Not (Membership.mem s x)\nâŠ¢ LE.le 1 (gauge s x)","decl":"theorem one_le_gauge_of_not_mem (hsâ‚ : StarConvex â„ 0 s) (hsâ‚‚ : Absorbs â„ s {x}) (hx : x âˆ‰ s) :\n    1 â‰¤ gauge s x :=\n  le_gauge_of_not_mem hsâ‚ hsâ‚‚ <| by rwa [one_smul]\n\n"}
{"name":"gauge_smul_of_nonneg","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module Real E\nÎ± : Type u_3\ninstâœâ´ : LinearOrderedField Î±\ninstâœÂ³ : MulActionWithZero Î± Real\ninstâœÂ² : OrderedSMul Î± Real\ninstâœÂ¹ : MulActionWithZero Î± E\ninstâœ : IsScalarTower Î± Real (Set E)\ns : Set E\na : Î±\nha : LE.le 0 a\nx : E\nâŠ¢ Eq (gauge s (HSMul.hSMul a x)) (HSMul.hSMul a (gauge s x))","decl":"theorem gauge_smul_of_nonneg [MulActionWithZero Î± E] [IsScalarTower Î± â„ (Set E)] {s : Set E} {a : Î±}\n    (ha : 0 â‰¤ a) (x : E) : gauge s (a â€¢ x) = a â€¢ gauge s x := by\n  obtain rfl | ha' := ha.eq_or_lt\n  Â· rw [zero_smul, gauge_zero, zero_smul]\n  rw [gauge_def', gauge_def', â† Real.sInf_smul_of_nonneg ha]\n  congr 1\n  ext r\n  simp_rw [Set.mem_smul_set, Set.mem_sep_iff]\n  constructor\n  Â· rintro âŸ¨hr, hxâŸ©\n    simp_rw [mem_Ioi] at hr âŠ¢\n    rw [â† mem_smul_set_iff_inv_smul_memâ‚€ hr.ne'] at hx\n    have := smul_pos (inv_pos.2 ha') hr\n    refine âŸ¨aâ»Â¹ â€¢ r, âŸ¨this, ?_âŸ©, smul_inv_smulâ‚€ ha'.ne' _âŸ©\n    rwa [â† mem_smul_set_iff_inv_smul_memâ‚€ this.ne', smul_assoc,\n      mem_smul_set_iff_inv_smul_memâ‚€ (inv_ne_zero ha'.ne'), inv_inv]\n  Â· rintro âŸ¨r, âŸ¨hr, hxâŸ©, rflâŸ©\n    rw [mem_Ioi] at hr âŠ¢\n    rw [â† mem_smul_set_iff_inv_smul_memâ‚€ hr.ne'] at hx\n    have := smul_pos ha' hr\n    refine âŸ¨this, ?_âŸ©\n    rw [â† mem_smul_set_iff_inv_smul_memâ‚€ this.ne', smul_assoc]\n    exact smul_mem_smul_set hx\n\n"}
{"name":"gauge_smul_left_of_nonneg","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœâ¸ : AddCommGroup E\ninstâœâ· : Module Real E\nÎ± : Type u_3\ninstâœâ¶ : LinearOrderedField Î±\ninstâœâµ : MulActionWithZero Î± Real\ninstâœâ´ : OrderedSMul Î± Real\ninstâœÂ³ : MulActionWithZero Î± E\ninstâœÂ² : SMulCommClass Î± Real Real\ninstâœÂ¹ : IsScalarTower Î± Real Real\ninstâœ : IsScalarTower Î± Real E\ns : Set E\na : Î±\nha : LE.le 0 a\nâŠ¢ Eq (gauge (HSMul.hSMul a s)) (HSMul.hSMul (Inv.inv a) (gauge s))","decl":"theorem gauge_smul_left_of_nonneg [MulActionWithZero Î± E] [SMulCommClass Î± â„ â„]\n    [IsScalarTower Î± â„ â„] [IsScalarTower Î± â„ E] {s : Set E} {a : Î±} (ha : 0 â‰¤ a) :\n    gauge (a â€¢ s) = aâ»Â¹ â€¢ gauge s := by\n  obtain rfl | ha' := ha.eq_or_lt\n  Â· rw [inv_zero, zero_smul, gauge_of_subset_zero (zero_smul_set_subset _)]\n  ext x\n  rw [gauge_def', Pi.smul_apply, gauge_def', â† Real.sInf_smul_of_nonneg (inv_nonneg.2 ha)]\n  congr 1\n  ext r\n  simp_rw [Set.mem_smul_set, Set.mem_sep_iff]\n  constructor\n  Â· rintro âŸ¨hr, y, hy, hâŸ©\n    simp_rw [mem_Ioi] at hr âŠ¢\n    refine âŸ¨a â€¢ r, âŸ¨smul_pos ha' hr, ?_âŸ©, inv_smul_smulâ‚€ ha'.ne' _âŸ©\n    rwa [smul_invâ‚€, smul_assoc, â† h, inv_smul_smulâ‚€ ha'.ne']\n  Â· rintro âŸ¨r, âŸ¨hr, hxâŸ©, rflâŸ©\n    rw [mem_Ioi] at hr âŠ¢\n    refine âŸ¨smul_pos (inv_pos.2 ha') hr, râ»Â¹ â€¢ x, hx, ?_âŸ©\n    rw [smul_invâ‚€, smul_assoc, inv_inv]\n\n"}
{"name":"gauge_smul_left","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœâ¸ : AddCommGroup E\ninstâœâ· : Module Real E\nÎ± : Type u_3\ninstâœâ¶ : LinearOrderedField Î±\ninstâœâµ : MulActionWithZero Î± Real\ninstâœâ´ : OrderedSMul Î± Real\ninstâœÂ³ : Module Î± E\ninstâœÂ² : SMulCommClass Î± Real Real\ninstâœÂ¹ : IsScalarTower Î± Real Real\ninstâœ : IsScalarTower Î± Real E\ns : Set E\nsymmetric : âˆ€ (x : E), Membership.mem s x â†’ Membership.mem s (Neg.neg x)\na : Î±\nâŠ¢ Eq (gauge (HSMul.hSMul a s)) (HSMul.hSMul (Inv.inv (abs a)) (gauge s))","decl":"theorem gauge_smul_left [Module Î± E] [SMulCommClass Î± â„ â„] [IsScalarTower Î± â„ â„]\n    [IsScalarTower Î± â„ E] {s : Set E} (symmetric : âˆ€ x âˆˆ s, -x âˆˆ s) (a : Î±) :\n    gauge (a â€¢ s) = |a|â»Â¹ â€¢ gauge s := by\n  rw [â† gauge_smul_left_of_nonneg (abs_nonneg a)]\n  obtain h | h := abs_choice a\n  Â· rw [h]\n  Â· rw [h, Set.neg_smul_set, â† Set.smul_set_neg]\n    -- Porting note: was congr\n    apply congr_arg\n    apply congr_arg\n    ext y\n    refine âŸ¨symmetric _, fun hy => ?_âŸ©\n    rw [â† neg_neg y]\n    exact symmetric _ hy\n\n"}
{"name":"gauge_norm_smul","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module Real E\ns : Set E\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : IsScalarTower Real ğ•œ E\nhs : Balanced ğ•œ s\nr : ğ•œ\nx : E\nâŠ¢ Eq (gauge s (HSMul.hSMul (Norm.norm r) x)) (gauge s (HSMul.hSMul r x))","decl":"theorem gauge_norm_smul (hs : Balanced ğ•œ s) (r : ğ•œ) (x : E) :\n    gauge s (â€–râ€– â€¢ x) = gauge s (r â€¢ x) := by\n  unfold gauge\n  congr with Î¸\n  rw [@RCLike.real_smul_eq_coe_smul ğ•œ]\n  refine and_congr_right fun hÎ¸ => (hs.smul _).smul_mem_iff ?_\n  rw [RCLike.norm_ofReal, abs_norm]\n\n"}
{"name":"gauge_smul","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module Real E\ns : Set E\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : IsScalarTower Real ğ•œ E\nhs : Balanced ğ•œ s\nr : ğ•œ\nx : E\nâŠ¢ Eq (gauge s (HSMul.hSMul r x)) (HMul.hMul (Norm.norm r) (gauge s x))","decl":"/-- If `s` is balanced, then the Minkowski functional is â„‚-homogeneous. -/\ntheorem gauge_smul (hs : Balanced ğ•œ s) (r : ğ•œ) (x : E) : gauge s (r â€¢ x) = â€–râ€– * gauge s x := by\n  rw [â† smul_eq_mul, â† gauge_smul_of_nonneg (norm_nonneg r), gauge_norm_smul hs]\n\n"}
{"name":"comap_gauge_nhds_zero_le","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module Real E\ns : Set E\ninstâœ : TopologicalSpace E\nha : Absorbent Real s\nhb : Bornology.IsVonNBounded Real s\nâŠ¢ LE.le (Filter.comap (gauge s) (nhds 0)) (nhds 0)","decl":"theorem comap_gauge_nhds_zero_le (ha : Absorbent â„ s) (hb : Bornology.IsVonNBounded â„ s) :\n    comap (gauge s) (ğ“ 0) â‰¤ ğ“ 0 := fun u hu â†¦ by\n  rcases (hb hu).exists_pos with âŸ¨r, hrâ‚€, hrâŸ©\n  filter_upwards [preimage_mem_comap (gt_mem_nhds (inv_pos.2 hrâ‚€))] with x (hx : gauge s x < râ»Â¹)\n  rcases exists_lt_of_gauge_lt ha hx with âŸ¨c, hcâ‚€, hcr, y, hy, rflâŸ©\n  have hrc := (lt_inv_commâ‚€ hrâ‚€ hcâ‚€).2 hcr\n  rcases hr câ»Â¹ (hrc.le.trans (le_abs_self _)) hy with âŸ¨z, hz, rflâŸ©\n  simpa only [smul_inv_smulâ‚€ hcâ‚€.ne']\n\n"}
{"name":"gauge_eq_zero","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module Real E\ns : Set E\nx : E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : T1Space E\nhs : Absorbent Real s\nhb : Bornology.IsVonNBounded Real s\nâŠ¢ Iff (Eq (gauge s x) 0) (Eq x 0)","decl":"theorem gauge_eq_zero (hs : Absorbent â„ s) (hb : Bornology.IsVonNBounded â„ s) :\n    gauge s x = 0 â†” x = 0 := by\n  refine âŸ¨fun hâ‚€ â†¦ by_contra fun (hne : x â‰  0) â†¦ ?_, fun h â†¦ h.symm â–¸ gauge_zeroâŸ©\n  have : {x}á¶œ âˆˆ comap (gauge s) (ğ“ 0) :=\n    comap_gauge_nhds_zero_le hs hb (isOpen_compl_singleton.mem_nhds hne.symm)\n  rcases ((nhds_basis_zero_abs_sub_lt _).comap _).mem_iff.1 this with âŸ¨r, hrâ‚€, hrâŸ©\n  exact hr (by simpa [hâ‚€]) rfl\n\n"}
{"name":"gauge_pos","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module Real E\ns : Set E\nx : E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : T1Space E\nhs : Absorbent Real s\nhb : Bornology.IsVonNBounded Real s\nâŠ¢ Iff (LT.lt 0 (gauge s x)) (Ne x 0)","decl":"theorem gauge_pos (hs : Absorbent â„ s) (hb : Bornology.IsVonNBounded â„ s) :\n    0 < gauge s x â†” x â‰  0 := by\n  simp only [(gauge_nonneg _).gt_iff_ne, Ne, gauge_eq_zero hs hb]\n\n"}
{"name":"interior_subset_gauge_lt_one","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module Real E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : ContinuousSMul Real E\ns : Set E\nâŠ¢ HasSubset.Subset (interior s) (setOf fun x => LT.lt (gauge s x) 1)","decl":"open Filter in\ntheorem interior_subset_gauge_lt_one (s : Set E) : interior s âŠ† { x | gauge s x < 1 } := by\n  intro x hx\n  have Hâ‚ : Tendsto (fun r : â„ â†¦ râ»Â¹ â€¢ x) (ğ“[<] 1) (ğ“ ((1 : â„)â»Â¹ â€¢ x)) :=\n    ((tendsto_id.invâ‚€ one_ne_zero).smul tendsto_const_nhds).mono_left inf_le_left\n  rw [inv_one, one_smul] at Hâ‚\n  have Hâ‚‚ : âˆ€á¶  r in ğ“[<] (1 : â„), x âˆˆ r â€¢ s âˆ§ 0 < r âˆ§ r < 1 := by\n    filter_upwards [Hâ‚ (mem_interior_iff_mem_nhds.1 hx), Ioo_mem_nhdsLT one_pos] with r hâ‚ hâ‚‚\n    exact âŸ¨(mem_smul_set_iff_inv_smul_memâ‚€ hâ‚‚.1.ne' _ _).2 hâ‚, hâ‚‚âŸ©\n  rcases Hâ‚‚.exists with âŸ¨r, hxr, hrâ‚€, hrâ‚âŸ©\n  exact (gauge_le_of_mem hrâ‚€.le hxr).trans_lt hrâ‚\n\n"}
{"name":"gauge_lt_one_eq_self_of_isOpen","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module Real E\ns : Set E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : ContinuousSMul Real E\nhsâ‚ : Convex Real s\nhsâ‚€ : Membership.mem s 0\nhsâ‚‚ : IsOpen s\nâŠ¢ Eq (setOf fun x => LT.lt (gauge s x) 1) s","decl":"theorem gauge_lt_one_eq_self_of_isOpen (hsâ‚ : Convex â„ s) (hsâ‚€ : (0 : E) âˆˆ s) (hsâ‚‚ : IsOpen s) :\n    { x | gauge s x < 1 } = s := by\n  refine (gauge_lt_one_subset_self hsâ‚ â€¹_â€º <| absorbent_nhds_zero <| hsâ‚‚.mem_nhds hsâ‚€).antisymm ?_\n  convert interior_subset_gauge_lt_one s\n  exact hsâ‚‚.interior_eq.symm\n\n"}
{"name":"gauge_lt_one_of_mem_of_isOpen","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module Real E\ns : Set E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : ContinuousSMul Real E\nhsâ‚‚ : IsOpen s\nx : E\nhx : Membership.mem s x\nâŠ¢ LT.lt (gauge s x) 1","decl":"theorem gauge_lt_one_of_mem_of_isOpen (hsâ‚‚ : IsOpen s) {x : E} (hx : x âˆˆ s) :\n    gauge s x < 1 :=\n  interior_subset_gauge_lt_one s <| by rwa [hsâ‚‚.interior_eq]\n\n"}
{"name":"gauge_lt_of_mem_smul","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module Real E\ns : Set E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : ContinuousSMul Real E\nx : E\nÎµ : Real\nhÎµ : LT.lt 0 Îµ\nhsâ‚‚ : IsOpen s\nhx : Membership.mem (HSMul.hSMul Îµ s) x\nâŠ¢ LT.lt (gauge s x) Îµ","decl":"theorem gauge_lt_of_mem_smul (x : E) (Îµ : â„) (hÎµ : 0 < Îµ) (hsâ‚‚ : IsOpen s) (hx : x âˆˆ Îµ â€¢ s) :\n    gauge s x < Îµ := by\n  have : Îµâ»Â¹ â€¢ x âˆˆ s := by rwa [â† mem_smul_set_iff_inv_smul_memâ‚€ hÎµ.ne']\n  have h_gauge_lt := gauge_lt_one_of_mem_of_isOpen hsâ‚‚ this\n  rwa [gauge_smul_of_nonneg (inv_nonneg.2 hÎµ.le), smul_eq_mul, inv_mul_lt_iffâ‚€ hÎµ, mul_one]\n    at h_gauge_lt\n\n"}
{"name":"mem_closure_of_gauge_le_one","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module Real E\ns : Set E\nx : E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : ContinuousSMul Real E\nhc : Convex Real s\nhsâ‚€ : Membership.mem s 0\nha : Absorbent Real s\nh : LE.le (gauge s x) 1\nâŠ¢ Membership.mem (closure s) x","decl":"theorem mem_closure_of_gauge_le_one (hc : Convex â„ s) (hsâ‚€ : 0 âˆˆ s) (ha : Absorbent â„ s)\n    (h : gauge s x â‰¤ 1) : x âˆˆ closure s := by\n  have : âˆ€á¶  r : â„ in ğ“[<] 1, r â€¢ x âˆˆ s := by\n    filter_upwards [Ico_mem_nhdsLT one_pos] with r âŸ¨hrâ‚€, hrâ‚âŸ©\n    apply gauge_lt_one_subset_self hc hsâ‚€ ha\n    rw [mem_setOf_eq, gauge_smul_of_nonneg hrâ‚€]\n    exact mul_lt_one_of_nonneg_of_lt_one_left hrâ‚€ hrâ‚ h\n  refine mem_closure_of_tendsto ?_ this\n  exact Filter.Tendsto.mono_left (Continuous.tendsto' (by fun_prop) _ _ (one_smul _ _))\n    inf_le_left\n\n"}
{"name":"mem_frontier_of_gauge_eq_one","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module Real E\ns : Set E\nx : E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : ContinuousSMul Real E\nhc : Convex Real s\nhsâ‚€ : Membership.mem s 0\nha : Absorbent Real s\nh : Eq (gauge s x) 1\nâŠ¢ Membership.mem (frontier s) x","decl":"theorem mem_frontier_of_gauge_eq_one (hc : Convex â„ s) (hsâ‚€ : 0 âˆˆ s) (ha : Absorbent â„ s)\n    (h : gauge s x = 1) : x âˆˆ frontier s :=\n  âŸ¨mem_closure_of_gauge_le_one hc hsâ‚€ ha h.le, fun h' â†¦\n    (interior_subset_gauge_lt_one s h').out.ne hâŸ©\n\n"}
{"name":"tendsto_gauge_nhds_zero'","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module Real E\ns : Set E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : ContinuousSMul Real E\nhs : Membership.mem (nhds 0) s\nâŠ¢ Filter.Tendsto (gauge s) (nhds 0) (nhdsWithin 0 (Set.Ici 0))","decl":"theorem tendsto_gauge_nhds_zero' (hs : s âˆˆ ğ“ 0) : Tendsto (gauge s) (ğ“ 0) (ğ“[â‰¥] 0) := by\n  refine nhdsGE_basis_Icc.tendsto_right_iff.2 fun Îµ hÎµ â†¦ ?_\n  rw [â† set_smul_mem_nhds_zero_iff hÎµ.ne'] at hs\n  filter_upwards [hs] with x hx\n  exact âŸ¨gauge_nonneg _, gauge_le_of_mem hÎµ.le hxâŸ©\n\n"}
{"name":"tendsto_gauge_nhds_zero","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module Real E\ns : Set E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : ContinuousSMul Real E\nhs : Membership.mem (nhds 0) s\nâŠ¢ Filter.Tendsto (gauge s) (nhds 0) (nhds 0)","decl":"theorem tendsto_gauge_nhds_zero (hs : s âˆˆ ğ“ 0) : Tendsto (gauge s) (ğ“ 0) (ğ“ 0) :=\n  (tendsto_gauge_nhds_zero' hs).mono_right inf_le_left\n\n"}
{"name":"continuousAt_gauge_zero","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module Real E\ns : Set E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : ContinuousSMul Real E\nhs : Membership.mem (nhds 0) s\nâŠ¢ ContinuousAt (gauge s) 0","decl":"/-- If `s` is a neighborhood of the origin, then `gauge s` is continuous at the origin.\nSee also `continuousAt_gauge`. -/\ntheorem continuousAt_gauge_zero (hs : s âˆˆ ğ“ 0) : ContinuousAt (gauge s) 0 := by\n  rw [ContinuousAt, gauge_zero]\n  exact tendsto_gauge_nhds_zero hs\n\n"}
{"name":"comap_gauge_nhds_zero","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module Real E\ns : Set E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : ContinuousSMul Real E\nhb : Bornology.IsVonNBounded Real s\nhâ‚€ : Membership.mem (nhds 0) s\nâŠ¢ Eq (Filter.comap (gauge s) (nhds 0)) (nhds 0)","decl":"theorem comap_gauge_nhds_zero (hb : Bornology.IsVonNBounded â„ s) (hâ‚€ : s âˆˆ ğ“ 0) :\n    comap (gauge s) (ğ“ 0) = ğ“ 0 :=\n  (comap_gauge_nhds_zero_le (absorbent_nhds_zero hâ‚€) hb).antisymm\n    (tendsto_gauge_nhds_zero hâ‚€).le_comap\n\n"}
{"name":"continuousAt_gauge","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module Real E\ns : Set E\nx : E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalAddGroup E\ninstâœ : ContinuousSMul Real E\nhc : Convex Real s\nhsâ‚€ : Membership.mem (nhds 0) s\nâŠ¢ ContinuousAt (gauge s) x","decl":"/-- If `s` is a convex neighborhood of the origin in a topological real vector space, then `gauge s`\nis continuous. If the ambient space is a normed space, then `gauge s` is Lipschitz continuous, see\n`Convex.lipschitz_gauge`. -/\ntheorem continuousAt_gauge (hc : Convex â„ s) (hsâ‚€ : s âˆˆ ğ“ 0) : ContinuousAt (gauge s) x := by\n  have ha : Absorbent â„ s := absorbent_nhds_zero hsâ‚€\n  refine (nhds_basis_Icc_pos _).tendsto_right_iff.2 fun Îµ hÎµâ‚€ â†¦ ?_\n  rw [â† map_add_left_nhds_zero, eventually_map]\n  have : Îµ â€¢ s âˆ© -(Îµ â€¢ s) âˆˆ ğ“ 0 :=\n    inter_mem ((set_smul_mem_nhds_zero_iff hÎµâ‚€.ne').2 hsâ‚€)\n      (neg_mem_nhds_zero _ ((set_smul_mem_nhds_zero_iff hÎµâ‚€.ne').2 hsâ‚€))\n  filter_upwards [this] with y hy\n  constructor\n  Â· rw [sub_le_iff_le_add]\n    calc\n      gauge s x = gauge s (x + y + (-y)) := by simp\n      _ â‰¤ gauge s (x + y) + gauge s (-y) := gauge_add_le hc ha _ _\n      _ â‰¤ gauge s (x + y) + Îµ := add_le_add_left (gauge_le_of_mem hÎµâ‚€.le (mem_neg.1 hy.2)) _\n  Â· calc\n      gauge s (x + y) â‰¤ gauge s x + gauge s y := gauge_add_le hc ha _ _\n      _ â‰¤ gauge s x + Îµ := add_le_add_left (gauge_le_of_mem hÎµâ‚€.le hy.1) _\n\n"}
{"name":"continuous_gauge","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module Real E\ns : Set E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalAddGroup E\ninstâœ : ContinuousSMul Real E\nhc : Convex Real s\nhsâ‚€ : Membership.mem (nhds 0) s\nâŠ¢ Continuous (gauge s)","decl":"/-- If `s` is a convex neighborhood of the origin in a topological real vector space, then `gauge s`\nis continuous. If the ambient space is a normed space, then `gauge s` is Lipschitz continuous, see\n`Convex.lipschitz_gauge`. -/\n@[continuity]\ntheorem continuous_gauge (hc : Convex â„ s) (hsâ‚€ : s âˆˆ ğ“ 0) : Continuous (gauge s) :=\n  continuous_iff_continuousAt.2 fun _ â†¦ continuousAt_gauge hc hsâ‚€\n\n"}
{"name":"gauge_lt_one_eq_interior","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module Real E\ns : Set E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalAddGroup E\ninstâœ : ContinuousSMul Real E\nhc : Convex Real s\nhsâ‚€ : Membership.mem (nhds 0) s\nâŠ¢ Eq (setOf fun x => LT.lt (gauge s x) 1) (interior s)","decl":"theorem gauge_lt_one_eq_interior (hc : Convex â„ s) (hsâ‚€ : s âˆˆ ğ“ 0) :\n    { x | gauge s x < 1 } = interior s := by\n  refine Subset.antisymm (fun x hx â†¦ ?_) (interior_subset_gauge_lt_one s)\n  rcases mem_openSegment_of_gauge_lt_one (absorbent_nhds_zero hsâ‚€) hx with âŸ¨y, hys, hxyâŸ©\n  exact hc.openSegment_interior_self_subset_interior (mem_interior_iff_mem_nhds.2 hsâ‚€) hys hxy\n\n"}
{"name":"gauge_lt_one_iff_mem_interior","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module Real E\ns : Set E\nx : E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalAddGroup E\ninstâœ : ContinuousSMul Real E\nhc : Convex Real s\nhsâ‚€ : Membership.mem (nhds 0) s\nâŠ¢ Iff (LT.lt (gauge s x) 1) (Membership.mem (interior s) x)","decl":"theorem gauge_lt_one_iff_mem_interior (hc : Convex â„ s) (hsâ‚€ : s âˆˆ ğ“ 0) :\n    gauge s x < 1 â†” x âˆˆ interior s :=\n  Set.ext_iff.1 (gauge_lt_one_eq_interior hc hsâ‚€) _\n\n"}
{"name":"gauge_le_one_iff_mem_closure","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module Real E\ns : Set E\nx : E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalAddGroup E\ninstâœ : ContinuousSMul Real E\nhc : Convex Real s\nhsâ‚€ : Membership.mem (nhds 0) s\nâŠ¢ Iff (LE.le (gauge s x) 1) (Membership.mem (closure s) x)","decl":"theorem gauge_le_one_iff_mem_closure (hc : Convex â„ s) (hsâ‚€ : s âˆˆ ğ“ 0) :\n    gauge s x â‰¤ 1 â†” x âˆˆ closure s :=\n  âŸ¨mem_closure_of_gauge_le_one hc (mem_of_mem_nhds hsâ‚€) (absorbent_nhds_zero hsâ‚€), fun h â†¦\n    le_on_closure (fun _ â†¦ gauge_le_one_of_mem) (continuous_gauge hc hsâ‚€).continuousOn\n      continuousOn_const hâŸ©\n\n"}
{"name":"gauge_eq_one_iff_mem_frontier","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module Real E\ns : Set E\nx : E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalAddGroup E\ninstâœ : ContinuousSMul Real E\nhc : Convex Real s\nhsâ‚€ : Membership.mem (nhds 0) s\nâŠ¢ Iff (Eq (gauge s x) 1) (Membership.mem (frontier s) x)","decl":"theorem gauge_eq_one_iff_mem_frontier (hc : Convex â„ s) (hsâ‚€ : s âˆˆ ğ“ 0) :\n    gauge s x = 1 â†” x âˆˆ frontier s := by\n  rw [eq_iff_le_not_lt, gauge_le_one_iff_mem_closure hc hsâ‚€, gauge_lt_one_iff_mem_interior hc hsâ‚€]\n  rfl\n\n"}
{"name":"gaugeSeminorm_toFun","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module Real E\ns : Set E\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : IsScalarTower Real ğ•œ E\nhsâ‚€ : Balanced ğ•œ s\nhsâ‚ : Convex Real s\nhsâ‚‚ : Absorbent Real s\nx : E\nâŠ¢ Eq ((gaugeSeminorm hsâ‚€ hsâ‚ hsâ‚‚) x) (gauge s x)","decl":"/-- `gauge s` as a seminorm when `s` is balanced, convex and absorbent. -/\n@[simps!]\ndef gaugeSeminorm (hsâ‚€ : Balanced ğ•œ s) (hsâ‚ : Convex â„ s) (hsâ‚‚ : Absorbent â„ s) : Seminorm ğ•œ E :=\n  Seminorm.of (gauge s) (gauge_add_le hsâ‚ hsâ‚‚) (gauge_smul hsâ‚€)\n\n"}
{"name":"gaugeSeminorm_lt_one_of_isOpen","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module Real E\ns : Set E\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : IsScalarTower Real ğ•œ E\nhsâ‚€ : Balanced ğ•œ s\nhsâ‚ : Convex Real s\nhsâ‚‚ : Absorbent Real s\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : ContinuousSMul Real E\nhs : IsOpen s\nx : E\nhx : Membership.mem s x\nâŠ¢ LT.lt ((gaugeSeminorm hsâ‚€ hsâ‚ hsâ‚‚) x) 1","decl":"theorem gaugeSeminorm_lt_one_of_isOpen (hs : IsOpen s) {x : E} (hx : x âˆˆ s) :\n    gaugeSeminorm hsâ‚€ hsâ‚ hsâ‚‚ x < 1 :=\n  gauge_lt_one_of_mem_of_isOpen hs hx\n\n"}
{"name":"gaugeSeminorm_ball_one","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module Real E\ns : Set E\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : IsScalarTower Real ğ•œ E\nhsâ‚€ : Balanced ğ•œ s\nhsâ‚ : Convex Real s\nhsâ‚‚ : Absorbent Real s\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : ContinuousSMul Real E\nhs : IsOpen s\nâŠ¢ Eq ((gaugeSeminorm hsâ‚€ hsâ‚ hsâ‚‚).ball 0 1) s","decl":"theorem gaugeSeminorm_ball_one (hs : IsOpen s) : (gaugeSeminorm hsâ‚€ hsâ‚ hsâ‚‚).ball 0 1 = s := by\n  rw [Seminorm.ball_zero_eq]\n  exact gauge_lt_one_eq_self_of_isOpen hsâ‚ hsâ‚‚.zero_mem hs\n\n"}
{"name":"Seminorm.gauge_ball","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Real E\np : Seminorm Real E\nâŠ¢ Eq (gauge (p.ball 0 1)) â‡‘p","decl":"/-- Any seminorm arises as the gauge of its unit ball. -/\n@[simp]\nprotected theorem Seminorm.gauge_ball (p : Seminorm â„ E) : gauge (p.ball 0 1) = p := by\n  ext x\n  obtain hp | hp := { r : â„ | 0 < r âˆ§ x âˆˆ r â€¢ p.ball 0 1 }.eq_empty_or_nonempty\n  Â· rw [gauge, hp, Real.sInf_empty]\n    by_contra h\n    have hpx : 0 < p x := (apply_nonneg _ _).lt_of_ne h\n    have hpxâ‚‚ : 0 < 2 * p x := mul_pos zero_lt_two hpx\n    refine hp.subset âŸ¨hpxâ‚‚, (2 * p x)â»Â¹ â€¢ x, ?_, smul_inv_smulâ‚€ hpxâ‚‚.ne' _âŸ©\n    rw [p.mem_ball_zero, map_smul_eq_mul, Real.norm_eq_abs, abs_of_pos (inv_pos.2 hpxâ‚‚),\n      inv_mul_lt_iffâ‚€ hpxâ‚‚, mul_one]\n    exact lt_mul_of_one_lt_left hpx one_lt_two\n  refine IsGLB.csInf_eq âŸ¨fun r => ?_, fun r hr => le_of_forall_pos_le_add fun Îµ hÎµ => ?_âŸ© hp\n  Â· rintro âŸ¨hr, y, hy, rflâŸ©\n    rw [p.mem_ball_zero] at hy\n    rw [map_smul_eq_mul, Real.norm_eq_abs, abs_of_pos hr]\n    exact mul_le_of_le_one_right hr.le hy.le\n  Â· have hpÎµ : 0 < p x + Îµ :=\n      -- Porting note: was `by positivity`\n      add_pos_of_nonneg_of_pos (apply_nonneg _ _) hÎµ\n    refine hr âŸ¨hpÎµ, (p x + Îµ)â»Â¹ â€¢ x, ?_, smul_inv_smulâ‚€ hpÎµ.ne' _âŸ©\n    rw [p.mem_ball_zero, map_smul_eq_mul, Real.norm_eq_abs, abs_of_pos (inv_pos.2 hpÎµ),\n      inv_mul_lt_iffâ‚€ hpÎµ, mul_one]\n    exact lt_add_of_pos_right _ hÎµ\n\n"}
{"name":"Seminorm.gaugeSeminorm_ball","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Real E\np : Seminorm Real E\nâŠ¢ Eq (gaugeSeminorm â‹¯ â‹¯ â‹¯) p","decl":"theorem Seminorm.gaugeSeminorm_ball (p : Seminorm â„ E) :\n    gaugeSeminorm (p.balanced_ball_zero 1) (p.convex_ball 0 1) (p.absorbent_ball_zero zero_lt_one) =\n      p :=\n  DFunLike.coe_injective p.gauge_ball\n\n"}
{"name":"gauge_unit_ball","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\nx : E\nâŠ¢ Eq (gauge (Metric.ball 0 1) x) (Norm.norm x)","decl":"theorem gauge_unit_ball (x : E) : gauge (ball (0 : E) 1) x = â€–xâ€– := by\n  rw [â† ball_normSeminorm â„, Seminorm.gauge_ball, coe_normSeminorm]\n\n"}
{"name":"gauge_ball","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\nr : Real\nhr : LE.le 0 r\nx : E\nâŠ¢ Eq (gauge (Metric.ball 0 r) x) (HDiv.hDiv (Norm.norm x) r)","decl":"theorem gauge_ball (hr : 0 â‰¤ r) (x : E) : gauge (ball (0 : E) r) x = â€–xâ€– / r := by\n  rcases hr.eq_or_lt with rfl | hr\n  Â· simp\n  Â· rw [â† smul_unitBall_of_pos hr, gauge_smul_left, Pi.smul_apply, gauge_unit_ball, smul_eq_mul,\n    abs_of_nonneg hr.le, div_eq_inv_mul]\n    simp_rw [mem_ball_zero_iff, norm_neg]\n    exact fun _ => id\n\n"}
{"name":"gauge_closure_zero","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\nâŠ¢ Eq (gauge (closure 0)) 0","decl":"@[simp]\ntheorem gauge_closure_zero : gauge (closure (0 : Set E)) = 0 := funext fun x â†¦ by\n  simp only [â† singleton_zero, gauge_def', mem_closure_zero_iff_norm, norm_smul, mul_eq_zero,\n    norm_eq_zero, inv_eq_zero]\n  rcases (norm_nonneg x).eq_or_gt with hx | hx\n  Â· convert csInf_Ioi (a := (0 : â„))\n    exact Set.ext fun r â†¦ and_iff_left (.inr hx)\n  Â· convert Real.sInf_empty\n    exact eq_empty_of_forall_not_mem fun r âŸ¨hrâ‚€, hrâŸ© â†¦ hx.ne' <| hr.resolve_left hrâ‚€.out.ne'\n\n"}
{"name":"gauge_closedBall","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\nr : Real\nhr : LE.le 0 r\nx : E\nâŠ¢ Eq (gauge (Metric.closedBall 0 r) x) (HDiv.hDiv (Norm.norm x) r)","decl":"@[simp]\ntheorem gauge_closedBall (hr : 0 â‰¤ r) (x : E) : gauge (closedBall (0 : E) r) x = â€–xâ€– / r := by\n  rcases hr.eq_or_lt with rfl | hr'\n  Â· rw [div_zero, closedBall_zero', singleton_zero, gauge_closure_zero]; rfl\n  Â· apply le_antisymm\n    Â· rw [â† gauge_ball hr]\n      exact gauge_mono (absorbent_ball_zero hr') ball_subset_closedBall x\n    Â· suffices âˆ€á¶  R in ğ“[>] r, â€–xâ€– / R â‰¤ gauge (closedBall 0 r) x by\n        refine le_of_tendsto ?_ this\n        exact tendsto_const_nhds.div inf_le_left hr'.ne'\n      filter_upwards [self_mem_nhdsWithin] with R hR\n      rw [â† gauge_ball (hr.trans hR.out.le)]\n      refine gauge_mono ?_ (closedBall_subset_ball hR) _\n      exact (absorbent_ball_zero hr').mono ball_subset_closedBall\n\n"}
{"name":"mul_gauge_le_norm","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\ns : Set E\nr : Real\nx : E\nhs : HasSubset.Subset (Metric.ball 0 r) s\nâŠ¢ LE.le (HMul.hMul r (gauge s x)) (Norm.norm x)","decl":"theorem mul_gauge_le_norm (hs : Metric.ball (0 : E) r âŠ† s) : r * gauge s x â‰¤ â€–xâ€– := by\n  obtain hr | hr := le_or_lt r 0\n  Â· exact (mul_nonpos_of_nonpos_of_nonneg hr <| gauge_nonneg _).trans (norm_nonneg _)\n  rw [mul_comm, â† le_div_iffâ‚€ hr, â† gauge_ball hr.le]\n  exact gauge_mono (absorbent_ball_zero hr) hs x\n\n"}
{"name":"Convex.lipschitzWith_gauge","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\ns : Set E\nr : NNReal\nhc : Convex Real s\nhr : LT.lt 0 r\nhs : HasSubset.Subset (Metric.ball 0 â†‘r) s\nâŠ¢ LipschitzWith (Inv.inv r) (gauge s)","decl":"theorem Convex.lipschitzWith_gauge {r : â„â‰¥0} (hc : Convex â„ s) (hr : 0 < r)\n    (hs : Metric.ball (0 : E) r âŠ† s) : LipschitzWith râ»Â¹ (gauge s) :=\n  have : Absorbent â„ (Metric.ball (0 : E) r) := absorbent_ball_zero hr\n  LipschitzWith.of_le_add_mul _ fun x y =>\n    calc\n      gauge s x = gauge s (y + (x - y)) := by simp\n      _ â‰¤ gauge s y + gauge s (x - y) := gauge_add_le hc (this.mono hs) _ _\n      _ â‰¤ gauge s y + â€–x - yâ€– / r :=\n        add_le_add_left ((gauge_mono this hs (x - y)).trans_eq (gauge_ball hr.le _)) _\n      _ = gauge s y + râ»Â¹ * dist x y := by rw [dist_eq_norm, div_eq_inv_mul, NNReal.coe_inv]\n\n"}
{"name":"Convex.lipschitz_gauge","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\ns : Set E\nhc : Convex Real s\nhâ‚€ : Membership.mem (nhds 0) s\nâŠ¢ Exists fun K => LipschitzWith K (gauge s)","decl":"theorem Convex.lipschitz_gauge (hc : Convex â„ s) (hâ‚€ : s âˆˆ ğ“ (0 : E)) :\n    âˆƒ K, LipschitzWith K (gauge s) :=\n  let âŸ¨r, hrâ‚€, hrâŸ© := Metric.mem_nhds_iff.1 hâ‚€\n  âŸ¨(âŸ¨r, hrâ‚€.leâŸ© : â„â‰¥0)â»Â¹, hc.lipschitzWith_gauge hrâ‚€ hrâŸ©\n\n"}
{"name":"Convex.uniformContinuous_gauge","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace Real E\ns : Set E\nhc : Convex Real s\nhâ‚€ : Membership.mem (nhds 0) s\nâŠ¢ UniformContinuous (gauge s)","decl":"theorem Convex.uniformContinuous_gauge (hc : Convex â„ s) (hâ‚€ : s âˆˆ ğ“ (0 : E)) :\n    UniformContinuous (gauge s) :=\n  let âŸ¨_K, hKâŸ© := hc.lipschitz_gauge hâ‚€; hK.uniformContinuous\n\n"}
{"name":"le_gauge_of_subset_closedBall","module":"Mathlib.Analysis.Convex.Gauge","initialProofState":"E : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\ns : Set E\nr : Real\nx : E\nhs : Absorbent Real s\nhr : LE.le 0 r\nhsr : HasSubset.Subset s (Metric.closedBall 0 r)\nâŠ¢ LE.le (HDiv.hDiv (Norm.norm x) r) (gauge s x)","decl":"theorem le_gauge_of_subset_closedBall (hs : Absorbent â„ s) (hr : 0 â‰¤ r) (hsr : s âŠ† closedBall 0 r) :\n    â€–xâ€– / r â‰¤ gauge s x := by\n  rw [â† gauge_closedBall hr]\n  exact gauge_mono hs hsr _\n\n"}
