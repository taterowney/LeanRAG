{"name":"CategoryTheory.CommSq.w","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\nself : CategoryTheory.CommSq f g h i\n⊢ Eq (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g i)","decl":"/-- The proposition that a square\n```\n  W ---f---> X\n  |          |\n  g          h\n  |          |\n  v          v\n  Y ---i---> Z\n\n```\nis a commuting square.\n-/\nstructure CommSq {W X Y Z : C} (f : W ⟶ X) (g : W ⟶ Y) (h : X ⟶ Z) (i : Y ⟶ Z) : Prop where\n  /-- The square commutes. -/\n  w : f ≫ h = g ≫ i\n\n"}
{"name":"CategoryTheory.CommSq.w_assoc","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW X Y Z✝ : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh✝ : Quiver.Hom X Z✝\ni : Quiver.Hom Y Z✝\nself : CategoryTheory.CommSq f g h✝ i\nZ : C\nh : Quiver.Hom Z✝ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp h✝ h)) (CategoryTheory.CategoryStruct.comp g (CategoryTheory.CategoryStruct.comp i h))","decl":"attribute [reassoc] CommSq.w\n\n"}
{"name":"CategoryTheory.CommSq.flip","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\np : CategoryTheory.CommSq f g h i\n⊢ CategoryTheory.CommSq g f i h","decl":"theorem flip (p : CommSq f g h i) : CommSq g f i h :=\n  ⟨p.w.symm⟩\n\n"}
{"name":"CategoryTheory.CommSq.of_arrow","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.Arrow C\nh : Quiver.Hom f g\n⊢ CategoryTheory.CommSq f.hom h.left h.right g.hom","decl":"theorem of_arrow {f g : Arrow C} (h : f ⟶ g) : CommSq f.hom h.left h.right g.hom :=\n  ⟨h.w.symm⟩\n\n"}
{"name":"CategoryTheory.CommSq.op","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\np : CategoryTheory.CommSq f g h i\n⊢ CategoryTheory.CommSq i.op h.op g.op f.op","decl":"/-- The commutative square in the opposite category associated to a commutative square. -/\ntheorem op (p : CommSq f g h i) : CommSq i.op h.op g.op f.op :=\n  ⟨by simp only [← op_comp, p.w]⟩\n\n"}
{"name":"CategoryTheory.CommSq.unop","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW X Y Z : Opposite C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\np : CategoryTheory.CommSq f g h i\n⊢ CategoryTheory.CommSq i.unop h.unop g.unop f.unop","decl":"/-- The commutative square associated to a commutative square in the opposite category. -/\ntheorem unop {W X Y Z : Cᵒᵖ} {f : W ⟶ X} {g : W ⟶ Y} {h : X ⟶ Z} {i : Y ⟶ Z} (p : CommSq f g h i) :\n    CommSq i.unop h.unop g.unop f.unop :=\n  ⟨by simp only [← unop_comp, p.w]⟩\n\n"}
{"name":"CategoryTheory.CommSq.vert_inv","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW X Y Z : C\nf : Quiver.Hom W X\ni : Quiver.Hom Y Z\ng : CategoryTheory.Iso W Y\nh : CategoryTheory.Iso X Z\np : CategoryTheory.CommSq f g.hom h.hom i\n⊢ CategoryTheory.CommSq i g.inv h.inv f","decl":"theorem vert_inv {g : W ≅ Y} {h : X ≅ Z} (p : CommSq f g.hom h.hom i) :\n    CommSq i g.inv h.inv f :=\n  ⟨by rw [Iso.comp_inv_eq, Category.assoc, Iso.eq_inv_comp, p.w]⟩\n\n"}
{"name":"CategoryTheory.CommSq.horiz_inv","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW X Y Z : C\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\nf : CategoryTheory.Iso W X\ni : CategoryTheory.Iso Y Z\np : CategoryTheory.CommSq f.hom g h i.hom\n⊢ CategoryTheory.CommSq f.inv h g i.inv","decl":"theorem horiz_inv {f : W ≅ X} {i : Y ≅ Z} (p : CommSq f.hom g h i.hom) :\n    CommSq f.inv h g i.inv :=\n  flip (vert_inv (flip p))\n\n"}
{"name":"CategoryTheory.CommSq.horiz_comp","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW X X' Y Z Z' : C\nf : Quiver.Hom W X\nf' : Quiver.Hom X X'\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\nh' : Quiver.Hom X' Z'\ni : Quiver.Hom Y Z\ni' : Quiver.Hom Z Z'\nhsq₁ : CategoryTheory.CommSq f g h i\nhsq₂ : CategoryTheory.CommSq f' h h' i'\n⊢ CategoryTheory.CommSq (CategoryTheory.CategoryStruct.comp f f') g h' (CategoryTheory.CategoryStruct.comp i i')","decl":"/-- The horizontal composition of two commutative squares as below is a commutative square.\n```\n  W ---f---> X ---f'--> X'\n  |          |          |\n  g          h          h'\n  |          |          |\n  v          v          v\n  Y ---i---> Z ---i'--> Z'\n\n```\n-/\nlemma horiz_comp {W X X' Y Z Z' : C} {f : W ⟶ X} {f' : X ⟶ X'} {g : W ⟶ Y} {h : X ⟶ Z}\n    {h' : X' ⟶ Z'} {i : Y ⟶ Z} {i' : Z ⟶ Z'} (hsq₁ : CommSq f g h i) (hsq₂ : CommSq f' h h' i') :\n    CommSq (f ≫ f') g h' (i ≫ i') :=\n  ⟨by rw [← Category.assoc, Category.assoc, ← hsq₁.w, hsq₂.w, Category.assoc]⟩\n\n"}
{"name":"CategoryTheory.CommSq.vert_comp","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW X Y Y' Z Z' : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\ng' : Quiver.Hom Y Y'\nh : Quiver.Hom X Z\nh' : Quiver.Hom Z Z'\ni : Quiver.Hom Y Z\ni' : Quiver.Hom Y' Z'\nhsq₁ : CategoryTheory.CommSq f g h i\nhsq₂ : CategoryTheory.CommSq i g' h' i'\n⊢ CategoryTheory.CommSq f (CategoryTheory.CategoryStruct.comp g g') (CategoryTheory.CategoryStruct.comp h h') i'","decl":"/-- The vertical composition of two commutative squares as below is a commutative square.\n```\n  W ---f---> X\n  |          |\n  g          h\n  |          |\n  v          v\n  Y ---i---> Z\n  |          |\n  g'         h'\n  |          |\n  v          v\n  Y'---i'--> Z'\n\n```\n-/\nlemma vert_comp {W X Y Y' Z Z' : C} {f : W ⟶ X} {g : W ⟶ Y} {g' : Y ⟶ Y'} {h : X ⟶ Z}\n    {h' : Z ⟶ Z'} {i : Y ⟶ Z} {i' : Y' ⟶ Z'} (hsq₁ : CommSq f g h i) (hsq₂ : CommSq i g' h' i') :\n    CommSq f (g ≫ g') (h ≫ h') i' :=\n  flip (horiz_comp (flip hsq₁) (flip hsq₂))\n\n\n"}
{"name":"CategoryTheory.CommSq.eq_of_mono","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nW X Y : C\nf g : Quiver.Hom W X\ni : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono i\nsq : CategoryTheory.CommSq f g i i\n⊢ Eq f g","decl":"theorem eq_of_mono {f : W ⟶ X} {g : W ⟶ X} {i : X ⟶ Y} [Mono i] (sq : CommSq f g i i) : f = g :=\n  (cancel_mono i).1 sq.w\n\n"}
{"name":"CategoryTheory.CommSq.eq_of_epi","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nW X Y : C\nf : Quiver.Hom W X\nh i : Quiver.Hom X Y\ninst✝ : CategoryTheory.Epi f\nsq : CategoryTheory.CommSq f f h i\n⊢ Eq h i","decl":"theorem eq_of_epi {f : W ⟶ X} {h : X ⟶ Y} {i : X ⟶ Y} [Epi f] (sq : CommSq f f h i) : h = i :=\n  (cancel_epi f).1 sq.w\n\n"}
{"name":"CategoryTheory.Functor.map_commSq","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst✝ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ns : CategoryTheory.CommSq f g h i\n⊢ CategoryTheory.CommSq (F.map f) (F.map g) (F.map h) (F.map i)","decl":"theorem map_commSq (s : CommSq f g h i) : CommSq (F.map f) (F.map g) (F.map h) (F.map i) :=\n  ⟨by simpa using congr_arg (fun k : W ⟶ Z => F.map k) s.w⟩\n\n"}
{"name":"CategoryTheory.CommSq.map","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst✝ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nh : Quiver.Hom X Z\ni : Quiver.Hom Y Z\ns : CategoryTheory.CommSq f g h i\n⊢ CategoryTheory.CommSq (F.map f) (F.map g) (F.map h) (F.map i)","decl":"alias CommSq.map := Functor.map_commSq\n\n"}
{"name":"CategoryTheory.CommSq.LiftStruct.mk.injEq","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nA B X Y : C\nf : Quiver.Hom A X\ni : Quiver.Hom A B\np : Quiver.Hom X Y\ng : Quiver.Hom B Y\nsq : CategoryTheory.CommSq f i p g\nl✝ : Quiver.Hom B X\nfac_left✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp i l✝) f) _auto✝\nfac_right✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp l✝ p) g) _auto✝\nl : Quiver.Hom B X\nfac_left : autoParam (Eq (CategoryTheory.CategoryStruct.comp i l) f) _auto✝\nfac_right : autoParam (Eq (CategoryTheory.CategoryStruct.comp l p) g) _auto✝\n⊢ Eq (Eq { l := l✝, fac_left := fac_left✝, fac_right := fac_right✝ } { l := l, fac_left := fac_left, fac_right := fac_right }) (Eq l✝ l)","decl":"/-- Now we consider a square:\n```\n  A ---f---> X\n  |          |\n  i          p\n  |          |\n  v          v\n  B ---g---> Y\n```\n\nThe datum of a lift in a commutative square, i.e. an up-right-diagonal\nmorphism which makes both triangles commute. -/\n@[ext]\nstructure LiftStruct (sq : CommSq f i p g) where\n  /-- The lift. -/\n  l : B ⟶ X\n  /-- The upper left triangle commutes. -/\n  fac_left : i ≫ l = f := by aesop_cat\n  /-- The lower right triangle commutes. -/\n  fac_right : l ≫ p = g := by aesop_cat\n\n"}
{"name":"CategoryTheory.CommSq.LiftStruct.fac_right","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nA B X Y : C\nf : Quiver.Hom A X\ni : Quiver.Hom A B\np : Quiver.Hom X Y\ng : Quiver.Hom B Y\nsq : CategoryTheory.CommSq f i p g\nself : sq.LiftStruct\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.l p) g","decl":"/-- Now we consider a square:\n```\n  A ---f---> X\n  |          |\n  i          p\n  |          |\n  v          v\n  B ---g---> Y\n```\n\nThe datum of a lift in a commutative square, i.e. an up-right-diagonal\nmorphism which makes both triangles commute. -/\n@[ext]\nstructure LiftStruct (sq : CommSq f i p g) where\n  /-- The lift. -/\n  l : B ⟶ X\n  /-- The upper left triangle commutes. -/\n  fac_left : i ≫ l = f := by aesop_cat\n  /-- The lower right triangle commutes. -/\n  fac_right : l ≫ p = g := by aesop_cat\n\n"}
{"name":"CategoryTheory.CommSq.LiftStruct.mk.inj","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nA B X Y : C\nf : Quiver.Hom A X\ni : Quiver.Hom A B\np : Quiver.Hom X Y\ng : Quiver.Hom B Y\nsq : CategoryTheory.CommSq f i p g\nl✝ : Quiver.Hom B X\nfac_left✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp i l✝) f) _auto✝\nfac_right✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp l✝ p) g) _auto✝\nl : Quiver.Hom B X\nfac_left : autoParam (Eq (CategoryTheory.CategoryStruct.comp i l) f) _auto✝\nfac_right : autoParam (Eq (CategoryTheory.CategoryStruct.comp l p) g) _auto✝\nx✝ : Eq { l := l✝, fac_left := fac_left✝, fac_right := fac_right✝ } { l := l, fac_left := fac_left, fac_right := fac_right }\n⊢ Eq l✝ l","decl":"/-- Now we consider a square:\n```\n  A ---f---> X\n  |          |\n  i          p\n  |          |\n  v          v\n  B ---g---> Y\n```\n\nThe datum of a lift in a commutative square, i.e. an up-right-diagonal\nmorphism which makes both triangles commute. -/\n@[ext]\nstructure LiftStruct (sq : CommSq f i p g) where\n  /-- The lift. -/\n  l : B ⟶ X\n  /-- The upper left triangle commutes. -/\n  fac_left : i ≫ l = f := by aesop_cat\n  /-- The lower right triangle commutes. -/\n  fac_right : l ≫ p = g := by aesop_cat\n\n"}
{"name":"CategoryTheory.CommSq.LiftStruct.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nA B X Y : C\nf : Quiver.Hom A X\ni : Quiver.Hom A B\np : Quiver.Hom X Y\ng : Quiver.Hom B Y\nsq : CategoryTheory.CommSq f i p g\ninst✝ : SizeOf C\nl : Quiver.Hom B X\nfac_left : autoParam (Eq (CategoryTheory.CategoryStruct.comp i l) f) _auto✝\nfac_right : autoParam (Eq (CategoryTheory.CategoryStruct.comp l p) g) _auto✝\n⊢ Eq (SizeOf.sizeOf { l := l, fac_left := fac_left, fac_right := fac_right }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf l)) (SizeOf.sizeOf fac_left)) (SizeOf.sizeOf fac_right))","decl":"/-- Now we consider a square:\n```\n  A ---f---> X\n  |          |\n  i          p\n  |          |\n  v          v\n  B ---g---> Y\n```\n\nThe datum of a lift in a commutative square, i.e. an up-right-diagonal\nmorphism which makes both triangles commute. -/\n@[ext]\nstructure LiftStruct (sq : CommSq f i p g) where\n  /-- The lift. -/\n  l : B ⟶ X\n  /-- The upper left triangle commutes. -/\n  fac_left : i ≫ l = f := by aesop_cat\n  /-- The lower right triangle commutes. -/\n  fac_right : l ≫ p = g := by aesop_cat\n\n"}
{"name":"CategoryTheory.CommSq.LiftStruct.fac_left","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nA B X Y : C\nf : Quiver.Hom A X\ni : Quiver.Hom A B\np : Quiver.Hom X Y\ng : Quiver.Hom B Y\nsq : CategoryTheory.CommSq f i p g\nself : sq.LiftStruct\n⊢ Eq (CategoryTheory.CategoryStruct.comp i self.l) f","decl":"/-- Now we consider a square:\n```\n  A ---f---> X\n  |          |\n  i          p\n  |          |\n  v          v\n  B ---g---> Y\n```\n\nThe datum of a lift in a commutative square, i.e. an up-right-diagonal\nmorphism which makes both triangles commute. -/\n@[ext]\nstructure LiftStruct (sq : CommSq f i p g) where\n  /-- The lift. -/\n  l : B ⟶ X\n  /-- The upper left triangle commutes. -/\n  fac_left : i ≫ l = f := by aesop_cat\n  /-- The lower right triangle commutes. -/\n  fac_right : l ≫ p = g := by aesop_cat\n\n"}
{"name":"CategoryTheory.CommSq.LiftStruct.ext_iff","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nA B X Y : C\nf : Quiver.Hom A X\ni : Quiver.Hom A B\np : Quiver.Hom X Y\ng : Quiver.Hom B Y\nsq : CategoryTheory.CommSq f i p g\nx y : sq.LiftStruct\n⊢ Iff (Eq x y) (Eq x.l y.l)","decl":"/-- Now we consider a square:\n```\n  A ---f---> X\n  |          |\n  i          p\n  |          |\n  v          v\n  B ---g---> Y\n```\n\nThe datum of a lift in a commutative square, i.e. an up-right-diagonal\nmorphism which makes both triangles commute. -/\n@[ext]\nstructure LiftStruct (sq : CommSq f i p g) where\n  /-- The lift. -/\n  l : B ⟶ X\n  /-- The upper left triangle commutes. -/\n  fac_left : i ≫ l = f := by aesop_cat\n  /-- The lower right triangle commutes. -/\n  fac_right : l ≫ p = g := by aesop_cat\n\n"}
{"name":"CategoryTheory.CommSq.LiftStruct.ext","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nA B X Y : C\nf : Quiver.Hom A X\ni : Quiver.Hom A B\np : Quiver.Hom X Y\ng : Quiver.Hom B Y\nsq : CategoryTheory.CommSq f i p g\nx y : sq.LiftStruct\nl : Eq x.l y.l\n⊢ Eq x y","decl":"/-- Now we consider a square:\n```\n  A ---f---> X\n  |          |\n  i          p\n  |          |\n  v          v\n  B ---g---> Y\n```\n\nThe datum of a lift in a commutative square, i.e. an up-right-diagonal\nmorphism which makes both triangles commute. -/\n@[ext]\nstructure LiftStruct (sq : CommSq f i p g) where\n  /-- The lift. -/\n  l : B ⟶ X\n  /-- The upper left triangle commutes. -/\n  fac_left : i ≫ l = f := by aesop_cat\n  /-- The lower right triangle commutes. -/\n  fac_right : l ≫ p = g := by aesop_cat\n\n"}
{"name":"CategoryTheory.CommSq.LiftStruct.op_l","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nA B X Y : C\nf : Quiver.Hom A X\ni : Quiver.Hom A B\np : Quiver.Hom X Y\ng : Quiver.Hom B Y\nsq : CategoryTheory.CommSq f i p g\nl : sq.LiftStruct\n⊢ Eq l.op.l l.l.op","decl":"/-- A `LiftStruct` for a commutative square gives a `LiftStruct` for the\ncorresponding square in the opposite category. -/\n@[simps]\ndef op {sq : CommSq f i p g} (l : LiftStruct sq) : LiftStruct sq.op where\n  l := l.l.op\n  fac_left := by rw [← op_comp, l.fac_right]\n  fac_right := by rw [← op_comp, l.fac_left]\n\n"}
{"name":"CategoryTheory.CommSq.LiftStruct.unop_l","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nA B X Y : Opposite C\nf : Quiver.Hom A X\ni : Quiver.Hom A B\np : Quiver.Hom X Y\ng : Quiver.Hom B Y\nsq : CategoryTheory.CommSq f i p g\nl : sq.LiftStruct\n⊢ Eq l.unop.l l.l.unop","decl":"/-- A `LiftStruct` for a commutative square in the opposite category\ngives a `LiftStruct` for the corresponding square in the original category. -/\n@[simps]\ndef unop {A B X Y : Cᵒᵖ} {f : A ⟶ X} {i : A ⟶ B} {p : X ⟶ Y} {g : B ⟶ Y} {sq : CommSq f i p g}\n    (l : LiftStruct sq) : LiftStruct sq.unop where\n  l := l.l.unop\n  fac_left := by rw [← unop_comp, l.fac_right]\n  fac_right := by rw [← unop_comp, l.fac_left]\n\n"}
{"name":"CategoryTheory.CommSq.LiftStruct.opEquiv_symm_apply","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nA B X Y : C\nf : Quiver.Hom A X\ni : Quiver.Hom A B\np : Quiver.Hom X Y\ng : Quiver.Hom B Y\nsq : CategoryTheory.CommSq f i p g\nl : ⋯.LiftStruct\n⊢ Eq ((CategoryTheory.CommSq.LiftStruct.opEquiv sq).symm l) l.unop","decl":"/-- Equivalences of `LiftStruct` for a square and the corresponding square\nin the opposite category. -/\n@[simps]\ndef opEquiv (sq : CommSq f i p g) : LiftStruct sq ≃ LiftStruct sq.op where\n  toFun := op\n  invFun := unop\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.CommSq.LiftStruct.opEquiv_apply","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nA B X Y : C\nf : Quiver.Hom A X\ni : Quiver.Hom A B\np : Quiver.Hom X Y\ng : Quiver.Hom B Y\nsq : CategoryTheory.CommSq f i p g\nl : sq.LiftStruct\n⊢ Eq ((CategoryTheory.CommSq.LiftStruct.opEquiv sq) l) l.op","decl":"/-- Equivalences of `LiftStruct` for a square and the corresponding square\nin the opposite category. -/\n@[simps]\ndef opEquiv (sq : CommSq f i p g) : LiftStruct sq ≃ LiftStruct sq.op where\n  toFun := op\n  invFun := unop\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.CommSq.subsingleton_liftStruct_of_epi","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nA B X Y : C\nf : Quiver.Hom A X\ni : Quiver.Hom A B\np : Quiver.Hom X Y\ng : Quiver.Hom B Y\nsq : CategoryTheory.CommSq f i p g\ninst✝ : CategoryTheory.Epi i\n⊢ Subsingleton sq.LiftStruct","decl":"instance subsingleton_liftStruct_of_epi (sq : CommSq f i p g) [Epi i] :\n    Subsingleton (LiftStruct sq) :=\n  ⟨fun l₁ l₂ => by\n    ext\n    rw [← cancel_epi i]\n    simp only [LiftStruct.fac_left]⟩\n\n"}
{"name":"CategoryTheory.CommSq.subsingleton_liftStruct_of_mono","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nA B X Y : C\nf : Quiver.Hom A X\ni : Quiver.Hom A B\np : Quiver.Hom X Y\ng : Quiver.Hom B Y\nsq : CategoryTheory.CommSq f i p g\ninst✝ : CategoryTheory.Mono p\n⊢ Subsingleton sq.LiftStruct","decl":"instance subsingleton_liftStruct_of_mono (sq : CommSq f i p g) [Mono p] :\n    Subsingleton (LiftStruct sq) :=\n  ⟨fun l₁ l₂ => by\n    ext\n    rw [← cancel_mono p]\n    simp only [LiftStruct.fac_right]⟩\n\n"}
{"name":"CategoryTheory.CommSq.HasLift.exists_lift","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nA B X Y : C\nf : Quiver.Hom A X\ni : Quiver.Hom A B\np : Quiver.Hom X Y\ng : Quiver.Hom B Y\nsq : CategoryTheory.CommSq f i p g\nself : sq.HasLift\n⊢ Nonempty sq.LiftStruct","decl":"/-- The assertion that a square has a `LiftStruct`. -/\nclass HasLift : Prop where\n  /-- Square has a `LiftStruct`. -/\n  exists_lift : Nonempty sq.LiftStruct\n\n"}
{"name":"CategoryTheory.CommSq.HasLift.mk'","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nA B X Y : C\nf : Quiver.Hom A X\ni : Quiver.Hom A B\np : Quiver.Hom X Y\ng : Quiver.Hom B Y\nsq : CategoryTheory.CommSq f i p g\nl : sq.LiftStruct\n⊢ sq.HasLift","decl":"theorem mk' (l : sq.LiftStruct) : HasLift sq :=\n  ⟨Nonempty.intro l⟩\n\n"}
{"name":"CategoryTheory.CommSq.HasLift.iff","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nA B X Y : C\nf : Quiver.Hom A X\ni : Quiver.Hom A B\np : Quiver.Hom X Y\ng : Quiver.Hom B Y\nsq : CategoryTheory.CommSq f i p g\n⊢ Iff sq.HasLift (Nonempty sq.LiftStruct)","decl":"theorem iff : HasLift sq ↔ Nonempty sq.LiftStruct := by\n  constructor\n  exacts [fun h => h.exists_lift, fun h => mk h]\n\n"}
{"name":"CategoryTheory.CommSq.HasLift.iff_op","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nA B X Y : C\nf : Quiver.Hom A X\ni : Quiver.Hom A B\np : Quiver.Hom X Y\ng : Quiver.Hom B Y\nsq : CategoryTheory.CommSq f i p g\n⊢ Iff sq.HasLift ⋯.HasLift","decl":"theorem iff_op : HasLift sq ↔ HasLift sq.op := by\n  rw [iff, iff]\n  exact Nonempty.congr (LiftStruct.opEquiv sq).toFun (LiftStruct.opEquiv sq).invFun\n\n"}
{"name":"CategoryTheory.CommSq.HasLift.iff_unop","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nA B X Y : Opposite C\nf : Quiver.Hom A X\ni : Quiver.Hom A B\np : Quiver.Hom X Y\ng : Quiver.Hom B Y\nsq : CategoryTheory.CommSq f i p g\n⊢ Iff sq.HasLift ⋯.HasLift","decl":"theorem iff_unop {A B X Y : Cᵒᵖ} {f : A ⟶ X} {i : A ⟶ B} {p : X ⟶ Y} {g : B ⟶ Y}\n    (sq : CommSq f i p g) : HasLift sq ↔ HasLift sq.unop := by\n  rw [iff, iff]\n  exact Nonempty.congr (LiftStruct.unopEquiv sq).toFun (LiftStruct.unopEquiv sq).invFun\n\n"}
{"name":"CategoryTheory.CommSq.fac_left","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nA B X Y : C\nf : Quiver.Hom A X\ni : Quiver.Hom A B\np : Quiver.Hom X Y\ng : Quiver.Hom B Y\nsq : CategoryTheory.CommSq f i p g\nhsq : sq.HasLift\n⊢ Eq (CategoryTheory.CategoryStruct.comp i sq.lift) f","decl":"@[reassoc (attr := simp)]\ntheorem fac_left [hsq : HasLift sq] : i ≫ sq.lift = f :=\n  hsq.exists_lift.some.fac_left\n\n"}
{"name":"CategoryTheory.CommSq.fac_left_assoc","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nA B X Y : C\nf : Quiver.Hom A X\ni : Quiver.Hom A B\np : Quiver.Hom X Y\ng : Quiver.Hom B Y\nsq : CategoryTheory.CommSq f i p g\nhsq : sq.HasLift\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp i (CategoryTheory.CategoryStruct.comp sq.lift h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc (attr := simp)]\ntheorem fac_left [hsq : HasLift sq] : i ≫ sq.lift = f :=\n  hsq.exists_lift.some.fac_left\n\n"}
{"name":"CategoryTheory.CommSq.fac_right_assoc","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nA B X Y : C\nf : Quiver.Hom A X\ni : Quiver.Hom A B\np : Quiver.Hom X Y\ng : Quiver.Hom B Y\nsq : CategoryTheory.CommSq f i p g\nhsq : sq.HasLift\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp sq.lift (CategoryTheory.CategoryStruct.comp p h)) (CategoryTheory.CategoryStruct.comp g h)","decl":"@[reassoc (attr := simp)]\ntheorem fac_right [hsq : HasLift sq] : sq.lift ≫ p = g :=\n  hsq.exists_lift.some.fac_right\n\n"}
{"name":"CategoryTheory.CommSq.fac_right","module":"Mathlib.CategoryTheory.CommSq","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nA B X Y : C\nf : Quiver.Hom A X\ni : Quiver.Hom A B\np : Quiver.Hom X Y\ng : Quiver.Hom B Y\nsq : CategoryTheory.CommSq f i p g\nhsq : sq.HasLift\n⊢ Eq (CategoryTheory.CategoryStruct.comp sq.lift p) g","decl":"@[reassoc (attr := simp)]\ntheorem fac_right [hsq : HasLift sq] : sq.lift ≫ p = g :=\n  hsq.exists_lift.some.fac_right\n\n"}
