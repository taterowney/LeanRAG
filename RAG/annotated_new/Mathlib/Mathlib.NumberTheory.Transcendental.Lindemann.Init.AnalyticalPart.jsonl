{"name":"LindemannWeierstrass.hasDerivAt_cexp_mul_sumIDeriv","module":"Mathlib.NumberTheory.Transcendental.Lindemann.Init.AnalyticalPart","initialProofState":"p : Polynomial Complex\ns : Complex\nx : Real\n⊢ HasDerivAt (fun x => Neg.neg (HMul.hMul (Complex.exp (Neg.neg (HSMul.hSMul x s))) (Polynomial.eval (HSMul.hSMul x s) (Polynomial.sumIDeriv p)))) (HMul.hMul s (HMul.hMul (Complex.exp (Neg.neg (HSMul.hSMul x s))) (Polynomial.eval (HSMul.hSMul x s) p))) x","decl":"theorem hasDerivAt_cexp_mul_sumIDeriv (p : ℂ[X]) (s : ℂ) (x : ℝ) :\n    HasDerivAt (fun x : ℝ ↦ -(cexp (-(x • s)) * p.sumIDeriv.eval (x • s)))\n      (s * (cexp (-(x • s)) * p.eval (x • s))) x := by\n  have h₀ := (hasDerivAt_id' x).smul_const s\n  have h₁ := h₀.neg.cexp\n  have h₂ := ((sumIDeriv p).hasDerivAt (x • s)).comp x h₀\n  convert (h₁.mul h₂).neg using 1\n  nth_rw 1 [sumIDeriv_eq_self_add p]\n  simp only [one_smul, eval_add, Function.comp_apply]\n  ring\n\n"}
{"name":"LindemannWeierstrass.integral_exp_mul_eval","module":"Mathlib.NumberTheory.Transcendental.Lindemann.Init.AnalyticalPart","initialProofState":"p : Polynomial Complex\ns : Complex\n⊢ Eq (HMul.hMul s (intervalIntegral (fun x => HMul.hMul (Complex.exp (Neg.neg (HSMul.hSMul x s))) (Polynomial.eval (HSMul.hSMul x s) p)) 0 1 MeasureTheory.MeasureSpace.volume)) (HAdd.hAdd (Neg.neg (HMul.hMul (Complex.exp (Neg.neg s)) (Polynomial.eval s (Polynomial.sumIDeriv p)))) (Polynomial.eval 0 (Polynomial.sumIDeriv p)))","decl":"theorem integral_exp_mul_eval (p : ℂ[X]) (s : ℂ) :\n    s * ∫ x in (0)..1, exp (-(x • s)) * p.eval (x • s) =\n      -(exp (-s) * p.sumIDeriv.eval s) + p.sumIDeriv.eval 0 := by\n  rw [← intervalIntegral.integral_const_mul,\n    intervalIntegral.integral_eq_sub_of_hasDerivAt\n      (fun x hx => hasDerivAt_cexp_mul_sumIDeriv p s x)\n      (ContinuousOn.intervalIntegrable (by fun_prop))]\n  simp\n\n"}
{"name":"LindemannWeierstrass.exp_polynomial_approx","module":"Mathlib.NumberTheory.Transcendental.Lindemann.Init.AnalyticalPart","initialProofState":"f : Polynomial Int\nhf : Ne (Polynomial.eval 0 f) 0\n⊢ Exists fun c => ∀ (p : Nat), GT.gt p (Polynomial.eval 0 f).natAbs → Nat.Prime p → Exists fun n => And (Not (Dvd.dvd (↑p) n)) (Exists fun gp => And (LE.le gp.natDegree (HSub.hSub (HMul.hMul p f.natDegree) 1)) (∀ {r : Complex}, Membership.mem (f.aroots Complex) r → LE.le (Complex.abs (HSub.hSub (HSMul.hSMul n (Complex.exp r)) (HSMul.hSMul p ((Polynomial.aeval r) gp)))) (HDiv.hDiv (HPow.hPow c p) ↑(HSub.hSub p 1).factorial)))","decl":"/--\nSee equation (68), page 285 of [Jacobson, *Basic Algebra I, 4.12*][jacobson1974].\n\nGiven a polynomial `f` with integer coefficients, we can find a constant `c : ℝ` and for each prime\n`p > |f₀|`, `nₚ : ℤ` and `gₚ : ℤ[X]` such that\n\n* `p` does not divide `nₚ`\n* `deg(gₚ) < p * deg(f)`\n* all complex roots `r` of `f` satisfy `|nₚ * e ^ r - p * gₚ(r)| ≤ c ^ p / (p - 1)!`\n\nIn the proof of Lindemann-Weierstrass, we will take `f` to be a polynomial whose complex roots\nare the algebraic numbers whose exponentials we want to prove to be linearly independent.\n\nNote: Jacobson writes `Nₚ` for our `nₚ` and `M` for our `c` (modulo a constant factor).\n-/\ntheorem exp_polynomial_approx (f : ℤ[X]) (hf : f.eval 0 ≠ 0) :\n    ∃ c,\n      ∀ p > (eval 0 f).natAbs, p.Prime →\n        ∃ n : ℤ, ¬ ↑p ∣ n ∧ ∃ gp : ℤ[X], gp.natDegree ≤ p * f.natDegree - 1 ∧\n          ∀ {r : ℂ}, r ∈ f.aroots ℂ →\n            Complex.abs (n • exp r - p • aeval r gp : ℂ) ≤ c ^ p / (p - 1)! := by\n  simp_rw [nsmul_eq_mul, zsmul_eq_mul]\n  choose c' c'0 Pp'_le using exp_polynomial_approx_aux f\n  use\n    if h : ((f.aroots ℂ).map c').toFinset.Nonempty then ((f.aroots ℂ).map c').toFinset.max' h else 0\n  intro p p_gt prime_p\n  obtain ⟨gp', -, h'⟩ := eval_sumIDeriv_of_pos (X ^ (p - 1) * f ^ p) prime_p.pos\n  specialize h' 0 (by rw [C_0, sub_zero])\n  use f.eval 0 ^ p + p * gp'.eval 0\n  constructor\n  · rw [dvd_add_left (dvd_mul_right _ _)]\n    contrapose! p_gt with h\n    exact Nat.le_of_dvd (Int.natAbs_pos.mpr hf) (Int.natCast_dvd.mp (Int.Prime.dvd_pow' prime_p h))\n  obtain ⟨gp, gp'_le, h⟩ := aeval_sumIDeriv ℂ (X ^ (p - 1) * f ^ p) p\n  refine ⟨gp, ?_, ?_⟩\n  · refine gp'_le.trans ((tsub_le_tsub_right natDegree_mul_le p).trans ?_)\n    rw [natDegree_X_pow, natDegree_pow, tsub_add_eq_add_tsub prime_p.one_le, tsub_right_comm,\n      add_tsub_cancel_left]\n  intro r hr\n  specialize h r _\n  · rw [mem_roots'] at hr\n    rw [Polynomial.map_mul, f.map_pow]\n    exact dvd_mul_of_dvd_right (pow_dvd_pow_of_dvd (dvd_iff_isRoot.mpr hr.2) _) _\n  rw [nsmul_eq_mul] at h\n  have :\n      (↑(eval 0 f ^ p + p * eval 0 gp') * cexp r - p * (aeval r) gp) * (p - 1)! =\n      ((eval 0 f ^ p * cexp r) * (p - 1)! +\n        ↑(p * (p - 1)!) * (eval 0 gp' * cexp r - (aeval r) gp)) := by\n    push_cast; ring\n  rw [le_div_iff₀ (Nat.cast_pos.mpr (Nat.factorial_pos _) : (0 : ℝ) < _), ← abs_natCast, ← map_mul,\n    this, Nat.mul_factorial_pred prime_p.pos, mul_sub, ← h]\n  have :\n      ↑(eval 0 f) ^ p * cexp r * ↑(p - 1)! +\n        (↑p ! * (↑(eval 0 gp') * cexp r) - (aeval r) (sumIDeriv (X ^ (p - 1) * f ^ p))) =\n      ((p - 1)! • ↑(eval 0 (f ^ p)) + p ! • ↑(eval 0 gp') : ℤ) * cexp r -\n        (aeval r) (sumIDeriv (X ^ (p - 1) * f ^ p)) := by\n    simp; ring\n  rw [this, ← h', mul_comm, ← eq_intCast (algebraMap ℤ ℂ),\n    ← aeval_algebraMap_apply_eq_algebraMap_eval, map_zero,\n    aeval_sumIDeriv_eq_eval, aeval_sumIDeriv_eq_eval, ← P]\n  refine (Pp'_le r p prime_p.ne_zero).trans (pow_le_pow_left₀ (c'0 r) ?_ _)\n  have aux : c' r ∈ (Multiset.map c' (f.aroots ℂ)).toFinset := by\n    simpa only [Multiset.mem_toFinset] using Multiset.mem_map_of_mem _ hr\n  have h : ((f.aroots ℂ).map c').toFinset.Nonempty := ⟨c' r, aux⟩\n  simpa only [h, ↓reduceDIte] using Finset.le_max' _ _ aux\n\n"}
