{"name":"EquivLike.left_inv","module":"Mathlib.Data.FunLike.Equiv","initialProofState":"E : Sort u_1\nα : outParam (Sort u_2)\nβ : outParam (Sort u_3)\nself : EquivLike E α β\ne : E\n⊢ Function.LeftInverse (EquivLike.inv e) (EquivLike.coe e)","decl":"/-- The class `EquivLike E α β` expresses that terms of type `E` have an\ninjective coercion to bijections between `α` and `β`.\n\nNote that this does not directly extend `FunLike`, nor take `FunLike` as a parameter,\nso we can state `coe_injective'` in a nicer way.\n\nThis typeclass is used in the definition of the isomorphism (or equivalence) typeclasses,\nsuch as `ZeroEquivClass`, `MulEquivClass`, `MonoidEquivClass`, ....\n-/\nclass EquivLike (E : Sort*) (α β : outParam (Sort*)) where\n  /-- The coercion to a function in the forward direction. -/\n  coe : E → α → β\n  /-- The coercion to a function in the backwards direction. -/\n  inv : E → β → α\n  /-- The coercions are left inverses. -/\n  left_inv : ∀ e, Function.LeftInverse (inv e) (coe e)\n  /-- The coercions are right inverses. -/\n  right_inv : ∀ e, Function.RightInverse (inv e) (coe e)\n  /-- The two coercions to functions are jointly injective. -/\n  coe_injective' : ∀ e g, coe e = coe g → inv e = inv g → e = g\n  -- This is mathematically equivalent to either of the coercions to functions being injective, but\n  -- the `inv` hypothesis makes this easier to prove with `congr'`\n\n"}
{"name":"EquivLike.coe_injective'","module":"Mathlib.Data.FunLike.Equiv","initialProofState":"E : Sort u_1\nα : outParam (Sort u_2)\nβ : outParam (Sort u_3)\nself : EquivLike E α β\ne g : E\na✝¹ : Eq (EquivLike.coe e) (EquivLike.coe g)\na✝ : Eq (EquivLike.inv e) (EquivLike.inv g)\n⊢ Eq e g","decl":"/-- The class `EquivLike E α β` expresses that terms of type `E` have an\ninjective coercion to bijections between `α` and `β`.\n\nNote that this does not directly extend `FunLike`, nor take `FunLike` as a parameter,\nso we can state `coe_injective'` in a nicer way.\n\nThis typeclass is used in the definition of the isomorphism (or equivalence) typeclasses,\nsuch as `ZeroEquivClass`, `MulEquivClass`, `MonoidEquivClass`, ....\n-/\nclass EquivLike (E : Sort*) (α β : outParam (Sort*)) where\n  /-- The coercion to a function in the forward direction. -/\n  coe : E → α → β\n  /-- The coercion to a function in the backwards direction. -/\n  inv : E → β → α\n  /-- The coercions are left inverses. -/\n  left_inv : ∀ e, Function.LeftInverse (inv e) (coe e)\n  /-- The coercions are right inverses. -/\n  right_inv : ∀ e, Function.RightInverse (inv e) (coe e)\n  /-- The two coercions to functions are jointly injective. -/\n  coe_injective' : ∀ e g, coe e = coe g → inv e = inv g → e = g\n  -- This is mathematically equivalent to either of the coercions to functions being injective, but\n  -- the `inv` hypothesis makes this easier to prove with `congr'`\n\n"}
{"name":"EquivLike.right_inv","module":"Mathlib.Data.FunLike.Equiv","initialProofState":"E : Sort u_1\nα : outParam (Sort u_2)\nβ : outParam (Sort u_3)\nself : EquivLike E α β\ne : E\n⊢ Function.RightInverse (EquivLike.inv e) (EquivLike.coe e)","decl":"/-- The class `EquivLike E α β` expresses that terms of type `E` have an\ninjective coercion to bijections between `α` and `β`.\n\nNote that this does not directly extend `FunLike`, nor take `FunLike` as a parameter,\nso we can state `coe_injective'` in a nicer way.\n\nThis typeclass is used in the definition of the isomorphism (or equivalence) typeclasses,\nsuch as `ZeroEquivClass`, `MulEquivClass`, `MonoidEquivClass`, ....\n-/\nclass EquivLike (E : Sort*) (α β : outParam (Sort*)) where\n  /-- The coercion to a function in the forward direction. -/\n  coe : E → α → β\n  /-- The coercion to a function in the backwards direction. -/\n  inv : E → β → α\n  /-- The coercions are left inverses. -/\n  left_inv : ∀ e, Function.LeftInverse (inv e) (coe e)\n  /-- The coercions are right inverses. -/\n  right_inv : ∀ e, Function.RightInverse (inv e) (coe e)\n  /-- The two coercions to functions are jointly injective. -/\n  coe_injective' : ∀ e g, coe e = coe g → inv e = inv g → e = g\n  -- This is mathematically equivalent to either of the coercions to functions being injective, but\n  -- the `inv` hypothesis makes this easier to prove with `congr'`\n\n"}
{"name":"EquivLike.inv_injective","module":"Mathlib.Data.FunLike.Equiv","initialProofState":"E : Sort u_1\nα : Sort u_3\nβ : Sort u_4\ninst✝ : EquivLike E α β\n⊢ Function.Injective EquivLike.inv","decl":"theorem inv_injective : Function.Injective (EquivLike.inv : E → β → α) := fun e g h ↦\n  coe_injective' e g ((right_inv e).eq_rightInverse (h.symm ▸ left_inv g)) h\n\n"}
{"name":"EquivLike.toEmbeddingLike","module":"Mathlib.Data.FunLike.Equiv","initialProofState":"E : Sort u_1\nα : Sort u_3\nβ : Sort u_4\ninst✝ : EquivLike E α β\n⊢ EmbeddingLike E α β","decl":"instance (priority := 100) toEmbeddingLike : EmbeddingLike E α β where\n  injective' e := (left_inv e).injective\n\n"}
{"name":"EquivLike.injective","module":"Mathlib.Data.FunLike.Equiv","initialProofState":"E : Sort u_1\nα : Sort u_3\nβ : Sort u_4\ninst✝ : EquivLike E α β\ne : E\n⊢ Function.Injective ⇑e","decl":"protected theorem injective (e : E) : Function.Injective e :=\n  EmbeddingLike.injective e\n\n"}
{"name":"EquivLike.surjective","module":"Mathlib.Data.FunLike.Equiv","initialProofState":"E : Sort u_1\nα : Sort u_3\nβ : Sort u_4\ninst✝ : EquivLike E α β\ne : E\n⊢ Function.Surjective ⇑e","decl":"protected theorem surjective (e : E) : Function.Surjective e :=\n  (right_inv e).surjective\n\n"}
{"name":"EquivLike.bijective","module":"Mathlib.Data.FunLike.Equiv","initialProofState":"E : Sort u_1\nα : Sort u_3\nβ : Sort u_4\ninst✝ : EquivLike E α β\ne : E\n⊢ Function.Bijective ⇑e","decl":"protected theorem bijective (e : E) : Function.Bijective (e : α → β) :=\n  ⟨EquivLike.injective e, EquivLike.surjective e⟩\n\n"}
{"name":"EquivLike.apply_eq_iff_eq","module":"Mathlib.Data.FunLike.Equiv","initialProofState":"E : Sort u_1\nα : Sort u_3\nβ : Sort u_4\ninst✝ : EquivLike E α β\nf : E\nx y : α\n⊢ Iff (Eq (f x) (f y)) (Eq x y)","decl":"theorem apply_eq_iff_eq (f : E) {x y : α} : f x = f y ↔ x = y :=\n  EmbeddingLike.apply_eq_iff_eq f\n\n"}
{"name":"EquivLike.injective_comp","module":"Mathlib.Data.FunLike.Equiv","initialProofState":"E : Sort u_1\nα : Sort u_3\nβ : Sort u_4\nγ : Sort u_5\ninst✝ : EquivLike E α β\ne : E\nf : β → γ\n⊢ Iff (Function.Injective (Function.comp f ⇑e)) (Function.Injective f)","decl":"@[simp]\ntheorem injective_comp (e : E) (f : β → γ) : Function.Injective (f ∘ e) ↔ Function.Injective f :=\n  Function.Injective.of_comp_iff' f (EquivLike.bijective e)\n\n"}
{"name":"EquivLike.surjective_comp","module":"Mathlib.Data.FunLike.Equiv","initialProofState":"E : Sort u_1\nα : Sort u_3\nβ : Sort u_4\nγ : Sort u_5\ninst✝ : EquivLike E α β\ne : E\nf : β → γ\n⊢ Iff (Function.Surjective (Function.comp f ⇑e)) (Function.Surjective f)","decl":"@[simp]\ntheorem surjective_comp (e : E) (f : β → γ) : Function.Surjective (f ∘ e) ↔ Function.Surjective f :=\n  (EquivLike.surjective e).of_comp_iff f\n\n"}
{"name":"EquivLike.bijective_comp","module":"Mathlib.Data.FunLike.Equiv","initialProofState":"E : Sort u_1\nα : Sort u_3\nβ : Sort u_4\nγ : Sort u_5\ninst✝ : EquivLike E α β\ne : E\nf : β → γ\n⊢ Iff (Function.Bijective (Function.comp f ⇑e)) (Function.Bijective f)","decl":"@[simp]\ntheorem bijective_comp (e : E) (f : β → γ) : Function.Bijective (f ∘ e) ↔ Function.Bijective f :=\n  (EquivLike.bijective e).of_comp_iff f\n\n"}
{"name":"EquivLike.inv_apply_apply","module":"Mathlib.Data.FunLike.Equiv","initialProofState":"E : Sort u_1\nα : Sort u_3\nβ : Sort u_4\ninst✝ : EquivLike E α β\ne : E\na : α\n⊢ Eq (EquivLike.inv e (e a)) a","decl":"/-- This lemma is only supposed to be used in the generic context, when working with instances\nof classes extending `EquivLike`.\nFor concrete isomorphism types such as `Equiv`, you should use `Equiv.symm_apply_apply`\nor its equivalent.\n\nTODO: define a generic form of `Equiv.symm`. -/\n@[simp]\ntheorem inv_apply_apply (e : E) (a : α) : EquivLike.inv e (e a) = a :=\n  left_inv _ _\n\n"}
{"name":"EquivLike.apply_inv_apply","module":"Mathlib.Data.FunLike.Equiv","initialProofState":"E : Sort u_1\nα : Sort u_3\nβ : Sort u_4\ninst✝ : EquivLike E α β\ne : E\nb : β\n⊢ Eq (e (EquivLike.inv e b)) b","decl":"/-- This lemma is only supposed to be used in the generic context, when working with instances\nof classes extending `EquivLike`.\nFor concrete isomorphism types such as `Equiv`, you should use `Equiv.apply_symm_apply`\nor its equivalent.\n\nTODO: define a generic form of `Equiv.symm`. -/\n@[simp]\ntheorem apply_inv_apply (e : E) (b : β) : e (EquivLike.inv e b) = b :=\n  right_inv _ _\n\n"}
{"name":"EquivLike.inv_apply_eq_iff_eq_apply","module":"Mathlib.Data.FunLike.Equiv","initialProofState":"E : Sort u_1\nα : Sort u_3\nβ : Sort u_4\ninst✝ : EquivLike E α β\ne : E\nb : β\na : α\n⊢ Iff (Eq (EquivLike.inv e b) a) (Eq b (e a))","decl":"lemma inv_apply_eq_iff_eq_apply {e : E} {b : β} {a : α} : (EquivLike.inv e b) = a ↔ b = e a := by\n  constructor <;> rintro ⟨_, rfl⟩ <;> simp\n\n"}
{"name":"EquivLike.comp_injective","module":"Mathlib.Data.FunLike.Equiv","initialProofState":"F : Sort u_2\nα : Sort u_3\nβ : Sort u_4\nγ : Sort u_5\ninst✝ : EquivLike F β γ\nf : α → β\ne : F\n⊢ Iff (Function.Injective (Function.comp (⇑e) f)) (Function.Injective f)","decl":"theorem comp_injective (f : α → β) (e : F) : Function.Injective (e ∘ f) ↔ Function.Injective f :=\n  EmbeddingLike.comp_injective f e\n\n"}
{"name":"EquivLike.comp_surjective","module":"Mathlib.Data.FunLike.Equiv","initialProofState":"F : Sort u_2\nα : Sort u_3\nβ : Sort u_4\nγ : Sort u_5\ninst✝ : EquivLike F β γ\nf : α → β\ne : F\n⊢ Iff (Function.Surjective (Function.comp (⇑e) f)) (Function.Surjective f)","decl":"@[simp]\ntheorem comp_surjective (f : α → β) (e : F) : Function.Surjective (e ∘ f) ↔ Function.Surjective f :=\n  Function.Surjective.of_comp_iff' (EquivLike.bijective e) f\n\n"}
{"name":"EquivLike.comp_bijective","module":"Mathlib.Data.FunLike.Equiv","initialProofState":"F : Sort u_2\nα : Sort u_3\nβ : Sort u_4\nγ : Sort u_5\ninst✝ : EquivLike F β γ\nf : α → β\ne : F\n⊢ Iff (Function.Bijective (Function.comp (⇑e) f)) (Function.Bijective f)","decl":"@[simp]\ntheorem comp_bijective (f : α → β) (e : F) : Function.Bijective (e ∘ f) ↔ Function.Bijective f :=\n  (EquivLike.bijective e).of_comp_iff' f\n\n"}
{"name":"EquivLike.subsingleton_dom","module":"Mathlib.Data.FunLike.Equiv","initialProofState":"F : Sort u_2\nβ : Sort u_4\nγ : Sort u_5\ninst✝² : EquivLike F β γ\ninst✝¹ : FunLike F β γ\ninst✝ : Subsingleton β\n⊢ Subsingleton F","decl":"/-- This is not an instance to avoid slowing down every single `Subsingleton` typeclass search. -/\nlemma subsingleton_dom [FunLike F β γ] [Subsingleton β] : Subsingleton F :=\n  ⟨fun f g ↦ DFunLike.ext f g fun _ ↦ (right_inv f).injective <| Subsingleton.elim _ _⟩\n\n"}
