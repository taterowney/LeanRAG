{"name":"AlgebraicGeometry.RingedSpace.res_zero","module":"Mathlib.Geometry.RingedSpace.Basic","initialProofState":"X : AlgebraicGeometry.RingedSpace\nU V : TopologicalSpace.Opens ↑↑X.toPresheafedSpace\nhUV : LE.le U V\n⊢ Eq (TopCat.Presheaf.restrictOpen 0 U ⋯) 0","decl":"@[simp]\nlemma res_zero {X : RingedSpace.{u}} {U V : TopologicalSpace.Opens X}\n    (hUV : U ≤ V) : (0 : X.presheaf.obj (op V)) |_ U =\n      (0 : (CategoryTheory.forget CommRingCat).obj (X.presheaf.obj (op U))) :=\n  RingHom.map_zero _\n\n"}
{"name":"AlgebraicGeometry.RingedSpace.exists_res_eq_zero_of_germ_eq_zero","module":"Mathlib.Geometry.RingedSpace.Basic","initialProofState":"X : AlgebraicGeometry.RingedSpace\nU : TopologicalSpace.Opens ↑↑X.toPresheafedSpace\nf : ↑(X.presheaf.obj { unop := U })\nx : Subtype fun x => Membership.mem U x\nh : Eq ((CategoryTheory.ConcreteCategory.hom (X.presheaf.germ U ↑x ⋯)) f) 0\n⊢ Exists fun V => Exists fun i => Exists fun x => Eq ((CategoryTheory.ConcreteCategory.hom (X.presheaf.map i.op)) f) 0","decl":"/-- If the germ of a section `f` is zero in the stalk at `x`, then `f` is zero on some neighbourhood\naround `x`. -/\nlemma exists_res_eq_zero_of_germ_eq_zero (U : Opens X) (f : X.presheaf.obj (op U)) (x : U)\n    (h : X.presheaf.germ U x.val x.property f = 0) :\n    ∃ (V : Opens X) (i : V ⟶ U) (_ : x.1 ∈ V), X.presheaf.map i.op f = 0 := by\n  have h1 : X.presheaf.germ U x.val x.property f = X.presheaf.germ U x.val x.property 0 := by simpa\n  obtain ⟨V, hv, i, _, (hv4 : (X.presheaf.map i.op) f = (X.presheaf.map _) 0)⟩ :=\n    TopCat.Presheaf.germ_eq X.presheaf x.1 x.2 x.2 f 0 h1\n  use V, i, hv\n  simpa using hv4\n\n"}
{"name":"AlgebraicGeometry.RingedSpace.isUnit_res_of_isUnit_germ","module":"Mathlib.Geometry.RingedSpace.Basic","initialProofState":"X : AlgebraicGeometry.RingedSpace\nU : TopologicalSpace.Opens ↑↑X.toPresheafedSpace\nf : ↑(X.presheaf.obj { unop := U })\nx : ↑↑X.toPresheafedSpace\nhx : Membership.mem U x\nh : IsUnit ((CategoryTheory.ConcreteCategory.hom (X.presheaf.germ U x hx)) f)\n⊢ Exists fun V => Exists fun i => Exists fun x => IsUnit ((CategoryTheory.ConcreteCategory.hom (X.presheaf.map i.op)) f)","decl":"/--\nIf the germ of a section `f` is a unit in the stalk at `x`, then `f` must be a unit on some small\nneighborhood around `x`.\n-/\ntheorem isUnit_res_of_isUnit_germ (U : Opens X) (f : X.presheaf.obj (op U)) (x : X) (hx : x ∈ U)\n    (h : IsUnit (X.presheaf.germ U x hx f)) :\n    ∃ (V : Opens X) (i : V ⟶ U) (_ : x ∈ V), IsUnit (X.presheaf.map i.op f) := by\n  obtain ⟨g', heq⟩ := h.exists_right_inv\n  obtain ⟨V, hxV, g, rfl⟩ := X.presheaf.germ_exist x g'\n  let W := U ⊓ V\n  have hxW : x ∈ W := ⟨hx, hxV⟩\n  -- Porting note: `erw` can't write into `HEq`, so this is replaced with another `HEq` in the\n  -- desired form\n  replace heq : (X.presheaf.germ _ x hxW) ((X.presheaf.map (U.infLELeft V).op) f *\n      (X.presheaf.map (U.infLERight V).op) g) = (X.presheaf.germ _ x hxW) 1 := by\n    dsimp [germ]\n    erw [map_mul, map_one, show X.presheaf.germ _ x hxW ((X.presheaf.map (U.infLELeft V).op) f) =\n      X.presheaf.germ U x hx f from X.presheaf.germ_res_apply (Opens.infLELeft U V) x hxW f,\n      show X.presheaf.germ _ x hxW (X.presheaf.map (U.infLERight V).op g) =\n      X.presheaf.germ _ x hxV g from X.presheaf.germ_res_apply (Opens.infLERight U V) x hxW g]\n    exact heq\n  -- note: we have to force lean to resynthesize this as <...>.hom _ = <...>.hom _\n  obtain ⟨W', hxW', i₁, i₂, (heq' : (X.presheaf.map i₁.op) _ = (X.presheaf.map i₂.op) 1)⟩ :=\n    X.presheaf.germ_eq x hxW hxW _ _ heq\n  use W', i₁ ≫ Opens.infLELeft U V, hxW'\n  simp only [map_mul, map_one] at heq'\n  simpa using isUnit_of_mul_eq_one _ _ heq'\n\n"}
{"name":"CommRingCat.germ_res_apply","module":"Mathlib.Geometry.RingedSpace.Basic","initialProofState":"X : TopCat\nF : TopCat.Presheaf CommRingCat X\nU V : TopologicalSpace.Opens ↑X\ni : Quiver.Hom U V\nx : ↑X\nhx : Membership.mem U x\ns : ↑(F.obj { unop := V })\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (F.germ U x hx)) ((CategoryTheory.ConcreteCategory.hom (F.map i.op)) s)) ((CategoryTheory.ConcreteCategory.hom (F.germ V x ⋯)) s)","decl":"/-- Specialize `TopCat.Presheaf.germ_res_apply` to sheaves of rings.\n\nThis is unfortunately needed because the results on presheaves are stated using the\n`HasForget.instFunLike` instance, which is not reducibly equal to the actual coercion of\nmorphisms in `CommRingCat` to functions.\n-/\nlemma _root_.CommRingCat.germ_res_apply\n    {X : TopCat} (F : Presheaf CommRingCat X)\n    {U V : Opens X} (i : U ⟶ V) (x : X) (hx : x ∈ U) (s) :\n    F.germ U x hx (F.map i.op s) = F.germ V x (i.le hx) s :=\n  F.germ_res_apply _ _ _ _\n\n"}
{"name":"CommRingCat.germ_res_apply'","module":"Mathlib.Geometry.RingedSpace.Basic","initialProofState":"X : TopCat\nF : TopCat.Presheaf CommRingCat X\nU V : TopologicalSpace.Opens ↑X\ni : Quiver.Hom { unop := V } { unop := U }\nx : ↑X\nhx : Membership.mem U x\ns : ↑(F.obj { unop := V })\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (F.germ U x hx)) ((CategoryTheory.ConcreteCategory.hom (F.map i)) s)) ((CategoryTheory.ConcreteCategory.hom (F.germ V x ⋯)) s)","decl":"/-- Specialize `TopCat.Presheaf.germ_res_apply'` to sheaves of rings.\n\nThis is unfortunately needed because the results on presheaves are stated using the\n`HasForget.instFunLike` instance, which is not reducibly equal to the actual coercion of\nmorphisms in `CommRingCat` to functions.\n-/\nlemma _root_.CommRingCat.germ_res_apply'\n    {X : TopCat} (F : Presheaf CommRingCat X)\n    {U V : Opens X} (i : op V ⟶ op U) (x : X) (hx : x ∈ U) (s) :\n    F.germ U x hx (F.map i s) = F.germ V x (i.unop.le hx) s :=\n  F.germ_res_apply' _ _ _ _\n\n"}
{"name":"AlgebraicGeometry.RingedSpace.isUnit_of_isUnit_germ","module":"Mathlib.Geometry.RingedSpace.Basic","initialProofState":"X : AlgebraicGeometry.RingedSpace\nU : TopologicalSpace.Opens ↑↑X.toPresheafedSpace\nf : ↑(X.presheaf.obj { unop := U })\nh : ∀ (x : ↑↑X.toPresheafedSpace) (hx : Membership.mem U x), IsUnit ((CategoryTheory.ConcreteCategory.hom (X.presheaf.germ U x hx)) f)\n⊢ IsUnit f","decl":"/-- If a section `f` is a unit in each stalk, `f` must be a unit. -/\ntheorem isUnit_of_isUnit_germ (U : Opens X) (f : X.presheaf.obj (op U))\n    (h : ∀ (x) (hx : x ∈ U), IsUnit (X.presheaf.germ U x hx f)) : IsUnit f := by\n  -- We pick a cover of `U` by open sets `V x`, such that `f` is a unit on each `V x`.\n  choose V iVU m h_unit using fun x : U => X.isUnit_res_of_isUnit_germ U f x x.2 (h x.1 x.2)\n  have hcover : U ≤ iSup V := by\n    intro x hxU\n    -- Porting note: in Lean3 `rw` is sufficient\n    erw [Opens.mem_iSup]\n    exact ⟨⟨x, hxU⟩, m ⟨x, hxU⟩⟩\n  -- Let `g x` denote the inverse of `f` in `U x`.\n  choose g hg using fun x : U => IsUnit.exists_right_inv (h_unit x)\n  have ic : IsCompatible (sheaf X).val V g := by\n    intro x y\n    apply section_ext X.sheaf (V x ⊓ V y)\n    rintro z ⟨hzVx, hzVy⟩\n    rw [germ_res_apply, germ_res_apply]\n    apply (h z ((iVU x).le hzVx)).mul_right_inj.mp\n    -- Porting note: now need explicitly typing the rewrites\n    -- note: this is bad, I think we should replace the `FunLike` on\n    -- concrete category with `CoeFun`\n    rw [← CommRingCat.germ_res_apply X.presheaf (iVU x) z hzVx f]\n    -- Porting note: change was not necessary in Lean3\n    change X.presheaf.germ _ z hzVx _ * (X.presheaf.germ _ z hzVx _) =\n      X.presheaf.germ _ z hzVx _ * X.presheaf.germ _ z hzVy (g y)\n    rw [← RingHom.map_mul,\n      congr_arg (X.presheaf.germ (V x) z hzVx) (hg x),\n      CommRingCat.germ_res_apply X.presheaf _ _ _ f,\n      ← CommRingCat.germ_res_apply X.presheaf (iVU y) z hzVy f,\n      ← RingHom.map_mul,\n      congr_arg (X.presheaf.germ (V y) z hzVy) (hg y), RingHom.map_one, RingHom.map_one]\n  -- We claim that these local inverses glue together to a global inverse of `f`.\n  obtain ⟨gl, gl_spec, -⟩ :\n    -- We need to rephrase the result from `HasForget` to `CommRingCat`.\n    ∃ gl : X.presheaf.obj (op U), (∀ i, ((sheaf X).val.map (iVU i).op) gl = g i) ∧ _ :=\n    X.sheaf.existsUnique_gluing' V U iVU hcover g ic\n  apply isUnit_of_mul_eq_one f gl\n  apply X.sheaf.eq_of_locally_eq' V U iVU hcover\n  intro i\n  -- We need to rephrase the goal from `HasForget` to `CommRingCat`.\n  show ((sheaf X).val.map (iVU i).op).hom (f * gl) = ((sheaf X).val.map (iVU i).op) 1\n  rw [RingHom.map_one, RingHom.map_mul, gl_spec]\n  exact hg i\n\n"}
{"name":"AlgebraicGeometry.RingedSpace.mem_basicOpen","module":"Mathlib.Geometry.RingedSpace.Basic","initialProofState":"X : AlgebraicGeometry.RingedSpace\nU : TopologicalSpace.Opens ↑↑X.toPresheafedSpace\nf : ↑(X.presheaf.obj { unop := U })\nx : ↑↑X.toPresheafedSpace\nhx : Membership.mem U x\n⊢ Iff (Membership.mem (X.basicOpen f) x) (IsUnit ((CategoryTheory.ConcreteCategory.hom (X.presheaf.germ U x hx)) f))","decl":"theorem mem_basicOpen {U : Opens X} (f : X.presheaf.obj (op U)) (x : X) (hx : x ∈ U) :\n    x ∈ X.basicOpen f ↔ IsUnit (X.presheaf.germ U x hx f) :=\n  ⟨Exists.choose_spec, (⟨hx, ·⟩)⟩\n\n"}
{"name":"AlgebraicGeometry.RingedSpace.mem_basicOpen'","module":"Mathlib.Geometry.RingedSpace.Basic","initialProofState":"X : AlgebraicGeometry.RingedSpace\nU : TopologicalSpace.Opens ↑↑X.toPresheafedSpace\nf : ↑(X.presheaf.obj { unop := U })\nx : Subtype fun x => Membership.mem U x\n⊢ Iff (Membership.mem (X.basicOpen f) ↑x) (IsUnit ((CategoryTheory.ConcreteCategory.hom (X.presheaf.germ U ↑x ⋯)) f))","decl":"/-- A variant of `mem_basicOpen` with bundled `x : U`. -/\n@[simp]\ntheorem mem_basicOpen' {U : Opens X} (f : X.presheaf.obj (op U)) (x : U) :\n    ↑x ∈ X.basicOpen f ↔ IsUnit (X.presheaf.germ U x.1 x.2 f) :=\n  mem_basicOpen X f x.1 x.2\n\n"}
{"name":"AlgebraicGeometry.RingedSpace.mem_top_basicOpen","module":"Mathlib.Geometry.RingedSpace.Basic","initialProofState":"X : AlgebraicGeometry.RingedSpace\nf : ↑(X.presheaf.obj { unop := Top.top })\nx : ↑↑X.toPresheafedSpace\n⊢ Iff (Membership.mem (X.basicOpen f) x) (IsUnit ((CategoryTheory.ConcreteCategory.hom (X.presheaf.Γgerm x)) f))","decl":"@[simp]\ntheorem mem_top_basicOpen (f : X.presheaf.obj (op ⊤)) (x : X) :\n    x ∈ X.basicOpen f ↔ IsUnit (X.presheaf.Γgerm x f) :=\n  mem_basicOpen X f x .intro\n\n"}
{"name":"AlgebraicGeometry.RingedSpace.basicOpen_le","module":"Mathlib.Geometry.RingedSpace.Basic","initialProofState":"X : AlgebraicGeometry.RingedSpace\nU : TopologicalSpace.Opens ↑↑X.toPresheafedSpace\nf : ↑(X.presheaf.obj { unop := U })\n⊢ LE.le (X.basicOpen f) U","decl":"theorem basicOpen_le {U : Opens X} (f : X.presheaf.obj (op U)) : X.basicOpen f ≤ U := by\n  rintro x ⟨h, _⟩; exact h\n\n"}
{"name":"AlgebraicGeometry.RingedSpace.isUnit_res_basicOpen","module":"Mathlib.Geometry.RingedSpace.Basic","initialProofState":"X : AlgebraicGeometry.RingedSpace\nU : TopologicalSpace.Opens ↑↑X.toPresheafedSpace\nf : ↑(X.presheaf.obj { unop := U })\n⊢ IsUnit ((CategoryTheory.ConcreteCategory.hom (X.presheaf.map (CategoryTheory.homOfLE ⋯).op)) f)","decl":"/-- The restriction of a section `f` to the basic open of `f` is a unit. -/\ntheorem isUnit_res_basicOpen {U : Opens X} (f : X.presheaf.obj (op U)) :\n    IsUnit (X.presheaf.map (@homOfLE (Opens X) _ _ _ (X.basicOpen_le f)).op f) := by\n  apply isUnit_of_isUnit_germ\n  rintro x ⟨hxU, hx⟩\n  convert hx\n  exact X.presheaf.germ_res_apply _ _ _ _\n\n"}
{"name":"AlgebraicGeometry.RingedSpace.basicOpen_res","module":"Mathlib.Geometry.RingedSpace.Basic","initialProofState":"X : AlgebraicGeometry.RingedSpace\nU V : Opposite (TopologicalSpace.Opens ↑↑X.toPresheafedSpace)\ni : Quiver.Hom U V\nf : ↑(X.presheaf.obj U)\n⊢ Eq (X.basicOpen ((CategoryTheory.ConcreteCategory.hom (X.presheaf.map i)) f)) (Min.min (Opposite.unop V) (X.basicOpen f))","decl":"@[simp]\ntheorem basicOpen_res {U V : (Opens X)ᵒᵖ} (i : U ⟶ V) (f : X.presheaf.obj U) :\n    @basicOpen X (unop V) (X.presheaf.map i f) = unop V ⊓ @basicOpen X (unop U) f := by\n  ext x; constructor\n  · rintro ⟨hxV, hx⟩\n    rw [CommRingCat.germ_res_apply' X.presheaf] at hx\n    exact ⟨hxV, i.unop.le hxV, hx⟩\n  · rintro ⟨hxV, _, hx⟩\n    refine ⟨hxV, ?_⟩\n    rw [CommRingCat.germ_res_apply' X.presheaf]\n    exact hx\n\n-- This should fire before `basicOpen_res`.\n-- Porting note: this lemma is not in simple normal form because of `basicOpen_res`, as in Lean3\n-- it is specifically said \"This should fire before `basic_open_res`\", this lemma is marked with\n-- high priority\n"}
{"name":"AlgebraicGeometry.RingedSpace.basicOpen_res_eq","module":"Mathlib.Geometry.RingedSpace.Basic","initialProofState":"X : AlgebraicGeometry.RingedSpace\nU V : Opposite (TopologicalSpace.Opens ↑↑X.toPresheafedSpace)\ni : Quiver.Hom U V\ninst✝ : CategoryTheory.IsIso i\nf : ↑(X.presheaf.obj U)\n⊢ Eq (X.basicOpen ((CategoryTheory.ConcreteCategory.hom (X.presheaf.map i)) f)) (X.basicOpen f)","decl":"@[simp (high)]\ntheorem basicOpen_res_eq {U V : (Opens X)ᵒᵖ} (i : U ⟶ V) [IsIso i] (f : X.presheaf.obj U) :\n    @basicOpen X (unop V) (X.presheaf.map i f) = @RingedSpace.basicOpen X (unop U) f := by\n  apply le_antisymm\n  · rw [X.basicOpen_res i f]; exact inf_le_right\n  · have := X.basicOpen_res (inv i) (X.presheaf.map i f)\n    rw [← CommRingCat.comp_apply, ← X.presheaf.map_comp, IsIso.hom_inv_id, X.presheaf.map_id,\n        CommRingCat.id_apply] at this\n    rw [this]\n    exact inf_le_right\n\n"}
{"name":"AlgebraicGeometry.RingedSpace.basicOpen_mul","module":"Mathlib.Geometry.RingedSpace.Basic","initialProofState":"X : AlgebraicGeometry.RingedSpace\nU : TopologicalSpace.Opens ↑↑X.toPresheafedSpace\nf g : ↑(X.presheaf.obj { unop := U })\n⊢ Eq (X.basicOpen (HMul.hMul f g)) (Min.min (X.basicOpen f) (X.basicOpen g))","decl":"@[simp]\ntheorem basicOpen_mul {U : Opens X} (f g : X.presheaf.obj (op U)) :\n    X.basicOpen (f * g) = X.basicOpen f ⊓ X.basicOpen g := by\n  ext x\n  by_cases hx : x ∈ U\n  · simp [mem_basicOpen (hx := hx)]\n  · simp [mt (basicOpen_le X _ ·) hx]\n\n"}
{"name":"AlgebraicGeometry.RingedSpace.basicOpen_pow","module":"Mathlib.Geometry.RingedSpace.Basic","initialProofState":"X : AlgebraicGeometry.RingedSpace\nU : TopologicalSpace.Opens ↑↑X.toPresheafedSpace\nf : ↑(X.presheaf.obj { unop := U })\nn : Nat\nh : LT.lt 0 n\n⊢ Eq (X.basicOpen (HPow.hPow f n)) (X.basicOpen f)","decl":"@[simp]\nlemma basicOpen_pow {U : Opens X} (f : X.presheaf.obj (op U)) (n : ℕ) (h : 0 < n) :\n    X.basicOpen (f ^ n) = X.basicOpen f := by\n  obtain ⟨k, rfl⟩ := Nat.exists_eq_add_of_le' h\n  induction k with\n  | zero => simp\n  | succ n hn => rw [pow_add]; simp_all\n\n"}
{"name":"AlgebraicGeometry.RingedSpace.basicOpen_of_isUnit","module":"Mathlib.Geometry.RingedSpace.Basic","initialProofState":"X : AlgebraicGeometry.RingedSpace\nU : TopologicalSpace.Opens ↑↑X.toPresheafedSpace\nf : ↑(X.presheaf.obj { unop := U })\nhf : IsUnit f\n⊢ Eq (X.basicOpen f) U","decl":"theorem basicOpen_of_isUnit {U : Opens X} {f : X.presheaf.obj (op U)} (hf : IsUnit f) :\n    X.basicOpen f = U := by\n  apply le_antisymm\n  · exact X.basicOpen_le f\n  intro x hx\n  rw [SetLike.mem_coe, X.mem_basicOpen f x hx]\n  exact RingHom.isUnit_map _ hf\n\n"}
{"name":"AlgebraicGeometry.RingedSpace.zeroLocus_isClosed","module":"Mathlib.Geometry.RingedSpace.Basic","initialProofState":"X : AlgebraicGeometry.RingedSpace\nU : TopologicalSpace.Opens ↑↑X.toPresheafedSpace\ns : Set ↑(X.presheaf.obj { unop := U })\n⊢ IsClosed (X.zeroLocus s)","decl":"lemma zeroLocus_isClosed {U : Opens X} (s : Set (X.presheaf.obj (op U))) :\n    IsClosed (X.zeroLocus s) := by\n  apply isClosed_biInter\n  intro i _\n  simp only [isClosed_compl_iff]\n  exact Opens.isOpen (X.basicOpen i)\n\n"}
{"name":"AlgebraicGeometry.RingedSpace.zeroLocus_singleton","module":"Mathlib.Geometry.RingedSpace.Basic","initialProofState":"X : AlgebraicGeometry.RingedSpace\nU : TopologicalSpace.Opens ↑↑X.toPresheafedSpace\nf : ↑(X.presheaf.obj { unop := U })\n⊢ Eq (X.zeroLocus (Singleton.singleton f)) (HasCompl.compl (X.basicOpen f).carrier)","decl":"lemma zeroLocus_singleton {U : Opens X} (f : X.presheaf.obj (op U)) :\n    X.zeroLocus {f} = (X.basicOpen f).carrierᶜ := by\n  simp [zeroLocus]\n\n"}
{"name":"AlgebraicGeometry.RingedSpace.zeroLocus_empty_eq_univ","module":"Mathlib.Geometry.RingedSpace.Basic","initialProofState":"X : AlgebraicGeometry.RingedSpace\nU : TopologicalSpace.Opens ↑↑X.toPresheafedSpace\n⊢ Eq (X.zeroLocus EmptyCollection.emptyCollection) Set.univ","decl":"@[simp]\nlemma zeroLocus_empty_eq_univ {U : Opens X} :\n    X.zeroLocus (∅ : Set (X.presheaf.obj (op U))) = Set.univ := by\n  simp [zeroLocus]\n\n"}
{"name":"AlgebraicGeometry.RingedSpace.mem_zeroLocus_iff","module":"Mathlib.Geometry.RingedSpace.Basic","initialProofState":"X : AlgebraicGeometry.RingedSpace\nU : TopologicalSpace.Opens ↑↑X.toPresheafedSpace\ns : Set ↑(X.presheaf.obj { unop := U })\nx : ↑↑X.toPresheafedSpace\n⊢ Iff (Membership.mem (X.zeroLocus s) x) (∀ (f : ↑(X.presheaf.obj { unop := U })), Membership.mem s f → Not (Membership.mem (X.basicOpen f) x))","decl":"@[simp]\nlemma mem_zeroLocus_iff {U : Opens X} (s : Set (X.presheaf.obj (op U))) (x : X) :\n    x ∈ X.zeroLocus s ↔ ∀ f ∈ s, x ∉ X.basicOpen f := by\n  simp [zeroLocus]\n\n"}
