{"name":"CategoryTheory.Sheaf.isPullback_square_op_map_yoneda_presheafToSheaf_yoneda_iff","module":"Mathlib.CategoryTheory.Sites.MayerVietorisSquare","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst✝ : CategoryTheory.HasWeakSheafify J (Type v)\nF : CategoryTheory.Sheaf J (Type v)\nsq : CategoryTheory.Square C\n⊢ Iff (sq.op.map ((CategoryTheory.yoneda.comp (CategoryTheory.presheafToSheaf J (Type v))).op.comp (CategoryTheory.yoneda.obj F))).IsPullback (sq.op.map F.val).IsPullback","decl":"lemma Sheaf.isPullback_square_op_map_yoneda_presheafToSheaf_yoneda_iff\n    [HasWeakSheafify J (Type v)]\n    (F : Sheaf J (Type v)) (sq : Square C) :\n    (sq.op.map ((yoneda ⋙ presheafToSheaf J _).op ⋙ yoneda.obj F)).IsPullback ↔\n      (sq.op.map F.val).IsPullback := by\n  refine Square.IsPullback.iff_of_equiv _ _\n    (((sheafificationAdjunction J (Type v)).homEquiv _ _).trans yonedaEquiv)\n    (((sheafificationAdjunction J (Type v)).homEquiv _ _).trans yonedaEquiv)\n    (((sheafificationAdjunction J (Type v)).homEquiv _ _).trans yonedaEquiv)\n    (((sheafificationAdjunction J (Type v)).homEquiv _ _).trans yonedaEquiv) ?_ ?_ ?_ ?_\n  all_goals\n    ext x\n    dsimp\n    rw [yonedaEquiv_naturality]\n    erw [Adjunction.homEquiv_naturality_left]\n    rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.MayerVietorisSquare.isPushout","module":"Mathlib.CategoryTheory.Sites.MayerVietorisSquare","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst✝ : CategoryTheory.HasWeakSheafify J (Type v)\nself : J.MayerVietorisSquare\n⊢ (self.map (CategoryTheory.yoneda.comp (CategoryTheory.presheafToSheaf J (Type v)))).IsPushout","decl":"/-- A Mayer-Vietoris square in a category `C` equipped with a Grothendieck\ntopology consists of a commutative square `f₁₂ ≫ f₂₄ = f₁₃ ≫ f₃₄` in `C`\nsuch that `f₁₃` is a monomorphism and that the square becomes a\npushout square in the category of sheaves of sets. -/\nstructure MayerVietorisSquare [HasWeakSheafify J (Type v)] extends Square C where\n  mono_f₁₃ : Mono toSquare.f₁₃ := by infer_instance\n  /-- the square becomes a pushout square in the category of sheaves of types -/\n  isPushout : (toSquare.map (yoneda ⋙ presheafToSheaf J _)).IsPushout\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.MayerVietorisSquare.mk.injEq","module":"Mathlib.CategoryTheory.Sites.MayerVietorisSquare","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst✝ : CategoryTheory.HasWeakSheafify J (Type v)\ntoSquare✝ : CategoryTheory.Square C\nmono_f₁₃✝ : autoParam (CategoryTheory.Mono toSquare✝.f₁₃) _auto✝\nisPushout✝ : (toSquare✝.map (CategoryTheory.yoneda.comp (CategoryTheory.presheafToSheaf J (Type v)))).IsPushout\ntoSquare : CategoryTheory.Square C\nmono_f₁₃ : autoParam (CategoryTheory.Mono toSquare.f₁₃) _auto✝\nisPushout : (toSquare.map (CategoryTheory.yoneda.comp (CategoryTheory.presheafToSheaf J (Type v)))).IsPushout\n⊢ Eq (Eq { toSquare := toSquare✝, mono_f₁₃ := mono_f₁₃✝, isPushout := isPushout✝ } { toSquare := toSquare, mono_f₁₃ := mono_f₁₃, isPushout := isPushout }) (Eq toSquare✝ toSquare)","decl":"/-- A Mayer-Vietoris square in a category `C` equipped with a Grothendieck\ntopology consists of a commutative square `f₁₂ ≫ f₂₄ = f₁₃ ≫ f₃₄` in `C`\nsuch that `f₁₃` is a monomorphism and that the square becomes a\npushout square in the category of sheaves of sets. -/\nstructure MayerVietorisSquare [HasWeakSheafify J (Type v)] extends Square C where\n  mono_f₁₃ : Mono toSquare.f₁₃ := by infer_instance\n  /-- the square becomes a pushout square in the category of sheaves of types -/\n  isPushout : (toSquare.map (yoneda ⋙ presheafToSheaf J _)).IsPushout\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.MayerVietorisSquare.mono_f₁₃","module":"Mathlib.CategoryTheory.Sites.MayerVietorisSquare","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst✝ : CategoryTheory.HasWeakSheafify J (Type v)\nself : J.MayerVietorisSquare\n⊢ CategoryTheory.Mono self.f₁₃","decl":"/-- A Mayer-Vietoris square in a category `C` equipped with a Grothendieck\ntopology consists of a commutative square `f₁₂ ≫ f₂₄ = f₁₃ ≫ f₃₄` in `C`\nsuch that `f₁₃` is a monomorphism and that the square becomes a\npushout square in the category of sheaves of sets. -/\nstructure MayerVietorisSquare [HasWeakSheafify J (Type v)] extends Square C where\n  mono_f₁₃ : Mono toSquare.f₁₃ := by infer_instance\n  /-- the square becomes a pushout square in the category of sheaves of types -/\n  isPushout : (toSquare.map (yoneda ⋙ presheafToSheaf J _)).IsPushout\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.MayerVietorisSquare.mk.inj","module":"Mathlib.CategoryTheory.Sites.MayerVietorisSquare","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst✝ : CategoryTheory.HasWeakSheafify J (Type v)\ntoSquare✝ : CategoryTheory.Square C\nmono_f₁₃✝ : autoParam (CategoryTheory.Mono toSquare✝.f₁₃) _auto✝\nisPushout✝ : (toSquare✝.map (CategoryTheory.yoneda.comp (CategoryTheory.presheafToSheaf J (Type v)))).IsPushout\ntoSquare : CategoryTheory.Square C\nmono_f₁₃ : autoParam (CategoryTheory.Mono toSquare.f₁₃) _auto✝\nisPushout : (toSquare.map (CategoryTheory.yoneda.comp (CategoryTheory.presheafToSheaf J (Type v)))).IsPushout\nx✝ : Eq { toSquare := toSquare✝, mono_f₁₃ := mono_f₁₃✝, isPushout := isPushout✝ } { toSquare := toSquare, mono_f₁₃ := mono_f₁₃, isPushout := isPushout }\n⊢ Eq toSquare✝ toSquare","decl":"/-- A Mayer-Vietoris square in a category `C` equipped with a Grothendieck\ntopology consists of a commutative square `f₁₂ ≫ f₂₄ = f₁₃ ≫ f₃₄` in `C`\nsuch that `f₁₃` is a monomorphism and that the square becomes a\npushout square in the category of sheaves of sets. -/\nstructure MayerVietorisSquare [HasWeakSheafify J (Type v)] extends Square C where\n  mono_f₁₃ : Mono toSquare.f₁₃ := by infer_instance\n  /-- the square becomes a pushout square in the category of sheaves of types -/\n  isPushout : (toSquare.map (yoneda ⋙ presheafToSheaf J _)).IsPushout\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.MayerVietorisSquare.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Sites.MayerVietorisSquare","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst✝¹ : CategoryTheory.HasWeakSheafify J (Type v)\ninst✝ : SizeOf C\ntoSquare : CategoryTheory.Square C\nmono_f₁₃ : autoParam (CategoryTheory.Mono toSquare.f₁₃) _auto✝\nisPushout : (toSquare.map (CategoryTheory.yoneda.comp (CategoryTheory.presheafToSheaf J (Type v)))).IsPushout\n⊢ Eq (SizeOf.sizeOf { toSquare := toSquare, mono_f₁₃ := mono_f₁₃, isPushout := isPushout }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toSquare)) (SizeOf.sizeOf mono_f₁₃)) (SizeOf.sizeOf isPushout))","decl":"/-- A Mayer-Vietoris square in a category `C` equipped with a Grothendieck\ntopology consists of a commutative square `f₁₂ ≫ f₂₄ = f₁₃ ≫ f₃₄` in `C`\nsuch that `f₁₃` is a monomorphism and that the square becomes a\npushout square in the category of sheaves of sets. -/\nstructure MayerVietorisSquare [HasWeakSheafify J (Type v)] extends Square C where\n  mono_f₁₃ : Mono toSquare.f₁₃ := by infer_instance\n  /-- the square becomes a pushout square in the category of sheaves of types -/\n  isPushout : (toSquare.map (yoneda ⋙ presheafToSheaf J _)).IsPushout\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.MayerVietorisSquare.mk'_toSquare","module":"Mathlib.CategoryTheory.Sites.MayerVietorisSquare","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst✝¹ : CategoryTheory.HasWeakSheafify J (Type v)\nsq : CategoryTheory.Square C\ninst✝ : CategoryTheory.Mono sq.f₁₃\nH : ∀ (F : CategoryTheory.Sheaf J (Type v)), (sq.op.map F.val).IsPullback\n⊢ Eq (CategoryTheory.GrothendieckTopology.MayerVietorisSquare.mk' sq H).toSquare sq","decl":"/-- Constructor for Mayer-Vietoris squares taking as an input\na square `sq` such that `sq.f₁₃` is a mono and that for every\nsheaf of types `F`, the square `sq.op.map F.val` is a pullback square. -/\n@[simps toSquare]\nnoncomputable def mk' (sq : Square C) [Mono sq.f₁₃]\n    (H : ∀ (F : Sheaf J (Type v)), (sq.op.map F.val).IsPullback) :\n    J.MayerVietorisSquare where\n  toSquare := sq\n  isPushout := by\n    rw [Square.isPushout_iff_op_map_yoneda_isPullback]\n    intro F\n    exact (F.isPullback_square_op_map_yoneda_presheafToSheaf_yoneda_iff sq).2 (H F)\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.MayerVietorisSquare.mk_of_isPullback_toSquare","module":"Mathlib.CategoryTheory.Sites.MayerVietorisSquare","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst✝² : CategoryTheory.HasWeakSheafify J (Type v)\nsq : CategoryTheory.Square C\ninst✝¹ : CategoryTheory.Mono sq.f₂₄\ninst✝ : CategoryTheory.Mono sq.f₃₄\nh₁ : sq.IsPullback\nh₂ : Membership.mem (J sq.X₄) (CategoryTheory.Sieve.ofTwoArrows sq.f₂₄ sq.f₃₄)\n⊢ Eq (CategoryTheory.GrothendieckTopology.MayerVietorisSquare.mk_of_isPullback sq h₁ h₂).toSquare sq","decl":"/-- Constructor for Mayer-Vietoris squares taking as an input\na pullback square `sq` such that `sq.f₂₄` and `sq.f₃₄` are two monomorphisms\nwhich form a covering of `S.X₄`. -/\n@[simps! toSquare]\nnoncomputable def mk_of_isPullback (sq : Square C) [Mono sq.f₂₄] [Mono sq.f₃₄]\n    (h₁ : sq.IsPullback) (h₂ : Sieve.ofTwoArrows sq.f₂₄ sq.f₃₄ ∈ J sq.X₄) :\n    J.MayerVietorisSquare :=\n  have : Mono sq.f₁₃ := h₁.mono_f₁₃\n  mk' sq (fun F ↦ by\n    apply Square.IsPullback.mk\n    refine PullbackCone.IsLimit.mk _\n      (fun s ↦ F.2.amalgamateOfArrows _ h₂\n        (fun j ↦ WalkingPair.casesOn j s.fst s.snd)\n        (fun W ↦ by\n          rintro (_|_) (_|_) a b fac\n          · obtain rfl : a = b := by simpa only [← cancel_mono sq.f₂₄] using fac\n            rfl\n          · obtain ⟨φ, rfl, rfl⟩ := PullbackCone.IsLimit.lift' h₁.isLimit _ _ fac\n            simpa using s.condition =≫ F.val.map φ.op\n          · obtain ⟨φ, rfl, rfl⟩ := PullbackCone.IsLimit.lift' h₁.isLimit _ _ fac.symm\n            simpa using s.condition.symm =≫ F.val.map φ.op\n          · obtain rfl : a = b := by simpa only [← cancel_mono sq.f₃₄] using fac\n            rfl)) (fun _ ↦ ?_) (fun _ ↦ ?_) (fun s m hm₁ hm₂ ↦ ?_)\n    · exact F.2.amalgamateOfArrows_map _ _ _ _ WalkingPair.left\n    · exact F.2.amalgamateOfArrows_map _ _ _ _ WalkingPair.right\n    · apply F.2.hom_ext_ofArrows _ h₂\n      rintro (_|_)\n      · rw [F.2.amalgamateOfArrows_map _ _ _ _ WalkingPair.left]\n        exact hm₁\n      · rw [F.2.amalgamateOfArrows_map _ _ _ _ WalkingPair.right]\n        exact hm₂)\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.MayerVietorisSquare.isPushoutAddCommGrpFreeSheaf","module":"Mathlib.CategoryTheory.Sites.MayerVietorisSquare","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst✝¹ : CategoryTheory.HasWeakSheafify J (Type v)\nS : J.MayerVietorisSquare\ninst✝ : CategoryTheory.HasWeakSheafify J AddCommGrp\n⊢ (S.map (CategoryTheory.yoneda.comp (((CategoryTheory.whiskeringRight (Opposite C) (Type v) AddCommGrp).obj AddCommGrp.free).comp (CategoryTheory.presheafToSheaf J AddCommGrp)))).IsPushout","decl":"lemma isPushoutAddCommGrpFreeSheaf [HasWeakSheafify J AddCommGrp.{v}] :\n    (S.map (yoneda ⋙ (whiskeringRight _ _ _).obj AddCommGrp.free ⋙\n      presheafToSheaf J _)).IsPushout :=\n  (S.isPushout.map (Sheaf.composeAndSheafify J AddCommGrp.free)).of_iso\n    ((Square.mapFunctor.mapIso\n      (presheafToSheafCompComposeAndSheafifyIso J AddCommGrp.free)).app\n        (S.map yoneda))\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.MayerVietorisSquare.sheafCondition_iff_comp_coyoneda","module":"Mathlib.CategoryTheory.Sites.MayerVietorisSquare","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst✝¹ : CategoryTheory.HasWeakSheafify J (Type v)\nS : J.MayerVietorisSquare\nA : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} A\nP : CategoryTheory.Functor (Opposite C) A\n⊢ Iff (S.SheafCondition P) (∀ (X : Opposite A), S.SheafCondition (P.comp (CategoryTheory.coyoneda.obj X)))","decl":"lemma sheafCondition_iff_comp_coyoneda {A : Type u'} [Category.{v'} A] (P : Cᵒᵖ ⥤ A) :\n    S.SheafCondition P ↔ ∀ (X : Aᵒᵖ), S.SheafCondition (P ⋙ coyoneda.obj X) :=\n  Square.isPullback_iff_map_coyoneda_isPullback (S.op.map P)\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.MayerVietorisSquare.sheafCondition_iff_bijective_toPullbackObj","module":"Mathlib.CategoryTheory.Sites.MayerVietorisSquare","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst✝ : CategoryTheory.HasWeakSheafify J (Type v)\nS : J.MayerVietorisSquare\nP : CategoryTheory.Functor (Opposite C) (Type v')\n⊢ Iff (S.SheafCondition P) (Function.Bijective (S.toPullbackObj P))","decl":"lemma sheafCondition_iff_bijective_toPullbackObj (P : Cᵒᵖ ⥤ Type v') :\n    S.SheafCondition P ↔ Function.Bijective (S.toPullbackObj P) := by\n  have := (S.toSquare.op.map P).pullbackCone.isLimitEquivBijective\n  exact ⟨fun h ↦ this h.isLimit, fun h ↦ Square.IsPullback.mk _ (this.symm h)⟩\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.MayerVietorisSquare.SheafCondition.bijective_toPullbackObj","module":"Mathlib.CategoryTheory.Sites.MayerVietorisSquare","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst✝ : CategoryTheory.HasWeakSheafify J (Type v)\nS : J.MayerVietorisSquare\nP : CategoryTheory.Functor (Opposite C) (Type v')\nh : S.SheafCondition P\n⊢ Function.Bijective (S.toPullbackObj P)","decl":"lemma bijective_toPullbackObj : Function.Bijective (S.toPullbackObj P) := by\n  rwa [← sheafCondition_iff_bijective_toPullbackObj]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.MayerVietorisSquare.SheafCondition.ext","module":"Mathlib.CategoryTheory.Sites.MayerVietorisSquare","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst✝ : CategoryTheory.HasWeakSheafify J (Type v)\nS : J.MayerVietorisSquare\nP : CategoryTheory.Functor (Opposite C) (Type v')\nh : S.SheafCondition P\nx y : P.obj { unop := S.X₄ }\nh₁ : Eq (P.map S.f₂₄.op x) (P.map S.f₂₄.op y)\nh₂ : Eq (P.map S.f₃₄.op x) (P.map S.f₃₄.op y)\n⊢ Eq x y","decl":"lemma ext {x y : P.obj (op S.X₄)}\n    (h₁ : P.map S.f₂₄.op x = P.map S.f₂₄.op y)\n    (h₂ : P.map S.f₃₄.op x = P.map S.f₃₄.op y) : x = y :=\n  h.bijective_toPullbackObj.injective (by ext <;> assumption)\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.MayerVietorisSquare.SheafCondition.map_f₂₄_op_glue","module":"Mathlib.CategoryTheory.Sites.MayerVietorisSquare","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst✝ : CategoryTheory.HasWeakSheafify J (Type v)\nS : J.MayerVietorisSquare\nP : CategoryTheory.Functor (Opposite C) (Type v')\nh : S.SheafCondition P\nu : P.obj { unop := S.X₂ }\nv : P.obj { unop := S.X₃ }\nhuv : Eq (P.map S.f₁₂.op u) (P.map S.f₁₃.op v)\n⊢ Eq (P.map S.f₂₄.op (h.glue u v huv)) u","decl":"@[simp]\nlemma map_f₂₄_op_glue : P.map S.f₂₄.op (h.glue u v huv) = u :=\n  PullbackCone.IsLimit.equivPullbackObj_symm_apply_fst h.isLimit _\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.MayerVietorisSquare.SheafCondition.map_f₃₄_op_glue","module":"Mathlib.CategoryTheory.Sites.MayerVietorisSquare","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst✝ : CategoryTheory.HasWeakSheafify J (Type v)\nS : J.MayerVietorisSquare\nP : CategoryTheory.Functor (Opposite C) (Type v')\nh : S.SheafCondition P\nu : P.obj { unop := S.X₂ }\nv : P.obj { unop := S.X₃ }\nhuv : Eq (P.map S.f₁₂.op u) (P.map S.f₁₃.op v)\n⊢ Eq (P.map S.f₃₄.op (h.glue u v huv)) v","decl":"@[simp]\nlemma map_f₃₄_op_glue : P.map S.f₃₄.op (h.glue u v huv) = v :=\n  PullbackCone.IsLimit.equivPullbackObj_symm_apply_snd h.isLimit _\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.MayerVietorisSquare.sheafCondition_of_sheaf","module":"Mathlib.CategoryTheory.Sites.MayerVietorisSquare","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst✝¹ : CategoryTheory.HasWeakSheafify J (Type v)\nS : J.MayerVietorisSquare\nA : Type u'\ninst✝ : CategoryTheory.Category.{v, u'} A\nF : CategoryTheory.Sheaf J A\n⊢ S.SheafCondition F.val","decl":"lemma sheafCondition_of_sheaf {A : Type u'} [Category.{v} A]\n    (F : Sheaf J A) : S.SheafCondition F.val := by\n  rw [sheafCondition_iff_comp_coyoneda]\n  intro X\n  exact (Sheaf.isPullback_square_op_map_yoneda_presheafToSheaf_yoneda_iff _ S.toSquare).1\n    (S.isPushout.op.map\n      (yoneda.obj ⟨_, (isSheaf_iff_isSheaf_of_type _ _).2 (F.cond X.unop)⟩))\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.MayerVietorisSquare.shortComplex_X₂","module":"Mathlib.CategoryTheory.Sites.MayerVietorisSquare","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst✝¹ : CategoryTheory.HasWeakSheafify J (Type v)\ninst✝ : CategoryTheory.HasSheafify J AddCommGrp\nS : J.MayerVietorisSquare\n⊢ Eq S.shortComplex.X₂ (CategoryTheory.Limits.biprod ((CategoryTheory.presheafToSheaf J AddCommGrp).obj ((CategoryTheory.yoneda.obj S.X₂).comp AddCommGrp.free)) ((CategoryTheory.presheafToSheaf J AddCommGrp).obj ((CategoryTheory.yoneda.obj S.X₃).comp AddCommGrp.free)))","decl":"/-- The short complex of abelian sheaves\n`ℤ[S.X₁] ⟶ ℤ[S.X₂] ⊞ ℤ[S.X₃] ⟶ ℤ[S.X₄]`\nwhere the left map is a difference and the right map a sum. -/\n@[simps]\nnoncomputable def shortComplex :\n    ShortComplex (Sheaf J AddCommGrp.{v}) where\n  X₁ := (presheafToSheaf J _).obj (yoneda.obj S.X₁ ⋙ AddCommGrp.free)\n  X₂ := (presheafToSheaf J _).obj (yoneda.obj S.X₂ ⋙ AddCommGrp.free) ⊞\n    (presheafToSheaf J _).obj (yoneda.obj S.X₃ ⋙ AddCommGrp.free)\n  X₃ := (presheafToSheaf J _).obj (yoneda.obj S.X₄ ⋙ AddCommGrp.free)\n  f :=\n    biprod.lift\n      ((presheafToSheaf J _).map (whiskerRight (yoneda.map S.f₁₂) _))\n      (-(presheafToSheaf J _).map (whiskerRight (yoneda.map S.f₁₃) _))\n  g :=\n    biprod.desc\n      ((presheafToSheaf J _).map (whiskerRight (yoneda.map S.f₂₄) _))\n      ((presheafToSheaf J _).map (whiskerRight (yoneda.map S.f₃₄) _))\n  zero := (S.map (yoneda ⋙ (whiskeringRight _ _ _).obj AddCommGrp.free ⋙\n      presheafToSheaf J _)).cokernelCofork.condition\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.MayerVietorisSquare.shortComplex_X₃","module":"Mathlib.CategoryTheory.Sites.MayerVietorisSquare","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst✝¹ : CategoryTheory.HasWeakSheafify J (Type v)\ninst✝ : CategoryTheory.HasSheafify J AddCommGrp\nS : J.MayerVietorisSquare\n⊢ Eq S.shortComplex.X₃ ((CategoryTheory.presheafToSheaf J AddCommGrp).obj ((CategoryTheory.yoneda.obj S.X₄).comp AddCommGrp.free))","decl":"/-- The short complex of abelian sheaves\n`ℤ[S.X₁] ⟶ ℤ[S.X₂] ⊞ ℤ[S.X₃] ⟶ ℤ[S.X₄]`\nwhere the left map is a difference and the right map a sum. -/\n@[simps]\nnoncomputable def shortComplex :\n    ShortComplex (Sheaf J AddCommGrp.{v}) where\n  X₁ := (presheafToSheaf J _).obj (yoneda.obj S.X₁ ⋙ AddCommGrp.free)\n  X₂ := (presheafToSheaf J _).obj (yoneda.obj S.X₂ ⋙ AddCommGrp.free) ⊞\n    (presheafToSheaf J _).obj (yoneda.obj S.X₃ ⋙ AddCommGrp.free)\n  X₃ := (presheafToSheaf J _).obj (yoneda.obj S.X₄ ⋙ AddCommGrp.free)\n  f :=\n    biprod.lift\n      ((presheafToSheaf J _).map (whiskerRight (yoneda.map S.f₁₂) _))\n      (-(presheafToSheaf J _).map (whiskerRight (yoneda.map S.f₁₃) _))\n  g :=\n    biprod.desc\n      ((presheafToSheaf J _).map (whiskerRight (yoneda.map S.f₂₄) _))\n      ((presheafToSheaf J _).map (whiskerRight (yoneda.map S.f₃₄) _))\n  zero := (S.map (yoneda ⋙ (whiskeringRight _ _ _).obj AddCommGrp.free ⋙\n      presheafToSheaf J _)).cokernelCofork.condition\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.MayerVietorisSquare.shortComplex_g","module":"Mathlib.CategoryTheory.Sites.MayerVietorisSquare","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst✝¹ : CategoryTheory.HasWeakSheafify J (Type v)\ninst✝ : CategoryTheory.HasSheafify J AddCommGrp\nS : J.MayerVietorisSquare\n⊢ Eq S.shortComplex.g (CategoryTheory.Limits.biprod.desc ((CategoryTheory.presheafToSheaf J AddCommGrp).map (CategoryTheory.whiskerRight (CategoryTheory.yoneda.map S.f₂₄) AddCommGrp.free)) ((CategoryTheory.presheafToSheaf J AddCommGrp).map (CategoryTheory.whiskerRight (CategoryTheory.yoneda.map S.f₃₄) AddCommGrp.free)))","decl":"/-- The short complex of abelian sheaves\n`ℤ[S.X₁] ⟶ ℤ[S.X₂] ⊞ ℤ[S.X₃] ⟶ ℤ[S.X₄]`\nwhere the left map is a difference and the right map a sum. -/\n@[simps]\nnoncomputable def shortComplex :\n    ShortComplex (Sheaf J AddCommGrp.{v}) where\n  X₁ := (presheafToSheaf J _).obj (yoneda.obj S.X₁ ⋙ AddCommGrp.free)\n  X₂ := (presheafToSheaf J _).obj (yoneda.obj S.X₂ ⋙ AddCommGrp.free) ⊞\n    (presheafToSheaf J _).obj (yoneda.obj S.X₃ ⋙ AddCommGrp.free)\n  X₃ := (presheafToSheaf J _).obj (yoneda.obj S.X₄ ⋙ AddCommGrp.free)\n  f :=\n    biprod.lift\n      ((presheafToSheaf J _).map (whiskerRight (yoneda.map S.f₁₂) _))\n      (-(presheafToSheaf J _).map (whiskerRight (yoneda.map S.f₁₃) _))\n  g :=\n    biprod.desc\n      ((presheafToSheaf J _).map (whiskerRight (yoneda.map S.f₂₄) _))\n      ((presheafToSheaf J _).map (whiskerRight (yoneda.map S.f₃₄) _))\n  zero := (S.map (yoneda ⋙ (whiskeringRight _ _ _).obj AddCommGrp.free ⋙\n      presheafToSheaf J _)).cokernelCofork.condition\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.MayerVietorisSquare.shortComplex_X₁","module":"Mathlib.CategoryTheory.Sites.MayerVietorisSquare","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst✝¹ : CategoryTheory.HasWeakSheafify J (Type v)\ninst✝ : CategoryTheory.HasSheafify J AddCommGrp\nS : J.MayerVietorisSquare\n⊢ Eq S.shortComplex.X₁ ((CategoryTheory.presheafToSheaf J AddCommGrp).obj ((CategoryTheory.yoneda.obj S.X₁).comp AddCommGrp.free))","decl":"/-- The short complex of abelian sheaves\n`ℤ[S.X₁] ⟶ ℤ[S.X₂] ⊞ ℤ[S.X₃] ⟶ ℤ[S.X₄]`\nwhere the left map is a difference and the right map a sum. -/\n@[simps]\nnoncomputable def shortComplex :\n    ShortComplex (Sheaf J AddCommGrp.{v}) where\n  X₁ := (presheafToSheaf J _).obj (yoneda.obj S.X₁ ⋙ AddCommGrp.free)\n  X₂ := (presheafToSheaf J _).obj (yoneda.obj S.X₂ ⋙ AddCommGrp.free) ⊞\n    (presheafToSheaf J _).obj (yoneda.obj S.X₃ ⋙ AddCommGrp.free)\n  X₃ := (presheafToSheaf J _).obj (yoneda.obj S.X₄ ⋙ AddCommGrp.free)\n  f :=\n    biprod.lift\n      ((presheafToSheaf J _).map (whiskerRight (yoneda.map S.f₁₂) _))\n      (-(presheafToSheaf J _).map (whiskerRight (yoneda.map S.f₁₃) _))\n  g :=\n    biprod.desc\n      ((presheafToSheaf J _).map (whiskerRight (yoneda.map S.f₂₄) _))\n      ((presheafToSheaf J _).map (whiskerRight (yoneda.map S.f₃₄) _))\n  zero := (S.map (yoneda ⋙ (whiskeringRight _ _ _).obj AddCommGrp.free ⋙\n      presheafToSheaf J _)).cokernelCofork.condition\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.MayerVietorisSquare.shortComplex_f","module":"Mathlib.CategoryTheory.Sites.MayerVietorisSquare","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst✝¹ : CategoryTheory.HasWeakSheafify J (Type v)\ninst✝ : CategoryTheory.HasSheafify J AddCommGrp\nS : J.MayerVietorisSquare\n⊢ Eq S.shortComplex.f (CategoryTheory.Limits.biprod.lift ((CategoryTheory.presheafToSheaf J AddCommGrp).map (CategoryTheory.whiskerRight (CategoryTheory.yoneda.map S.f₁₂) AddCommGrp.free)) (Neg.neg ((CategoryTheory.presheafToSheaf J AddCommGrp).map (CategoryTheory.whiskerRight (CategoryTheory.yoneda.map S.f₁₃) AddCommGrp.free))))","decl":"/-- The short complex of abelian sheaves\n`ℤ[S.X₁] ⟶ ℤ[S.X₂] ⊞ ℤ[S.X₃] ⟶ ℤ[S.X₄]`\nwhere the left map is a difference and the right map a sum. -/\n@[simps]\nnoncomputable def shortComplex :\n    ShortComplex (Sheaf J AddCommGrp.{v}) where\n  X₁ := (presheafToSheaf J _).obj (yoneda.obj S.X₁ ⋙ AddCommGrp.free)\n  X₂ := (presheafToSheaf J _).obj (yoneda.obj S.X₂ ⋙ AddCommGrp.free) ⊞\n    (presheafToSheaf J _).obj (yoneda.obj S.X₃ ⋙ AddCommGrp.free)\n  X₃ := (presheafToSheaf J _).obj (yoneda.obj S.X₄ ⋙ AddCommGrp.free)\n  f :=\n    biprod.lift\n      ((presheafToSheaf J _).map (whiskerRight (yoneda.map S.f₁₂) _))\n      (-(presheafToSheaf J _).map (whiskerRight (yoneda.map S.f₁₃) _))\n  g :=\n    biprod.desc\n      ((presheafToSheaf J _).map (whiskerRight (yoneda.map S.f₂₄) _))\n      ((presheafToSheaf J _).map (whiskerRight (yoneda.map S.f₃₄) _))\n  zero := (S.map (yoneda ⋙ (whiskeringRight _ _ _).obj AddCommGrp.free ⋙\n      presheafToSheaf J _)).cokernelCofork.condition\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.MayerVietorisSquare.instMonoSheafAddCommGrpFShortComplex","module":"Mathlib.CategoryTheory.Sites.MayerVietorisSquare","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst✝¹ : CategoryTheory.HasWeakSheafify J (Type v)\ninst✝ : CategoryTheory.HasSheafify J AddCommGrp\nS : J.MayerVietorisSquare\n⊢ CategoryTheory.Mono S.shortComplex.f","decl":"instance : Mono S.shortComplex.f := by\n  have : Mono (S.shortComplex.f ≫ biprod.snd) := by\n    dsimp\n    simp only [biprod.lift_snd]\n    infer_instance\n  exact mono_of_mono _ biprod.snd\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.MayerVietorisSquare.instEpiSheafAddCommGrpGShortComplex","module":"Mathlib.CategoryTheory.Sites.MayerVietorisSquare","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst✝¹ : CategoryTheory.HasWeakSheafify J (Type v)\ninst✝ : CategoryTheory.HasSheafify J AddCommGrp\nS : J.MayerVietorisSquare\n⊢ CategoryTheory.Epi S.shortComplex.g","decl":"instance : Epi S.shortComplex.g :=\n  (S.shortComplex.exact_and_epi_g_iff_g_is_cokernel.2\n    ⟨S.isPushoutAddCommGrpFreeSheaf.isColimitCokernelCofork⟩).2\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.MayerVietorisSquare.shortComplex_exact","module":"Mathlib.CategoryTheory.Sites.MayerVietorisSquare","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst✝¹ : CategoryTheory.HasWeakSheafify J (Type v)\ninst✝ : CategoryTheory.HasSheafify J AddCommGrp\nS : J.MayerVietorisSquare\n⊢ S.shortComplex.Exact","decl":"lemma shortComplex_exact : S.shortComplex.Exact :=\n  ShortComplex.exact_of_g_is_cokernel _\n    S.isPushoutAddCommGrpFreeSheaf.isColimitCokernelCofork\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.MayerVietorisSquare.shortComplex_shortExact","module":"Mathlib.CategoryTheory.Sites.MayerVietorisSquare","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst✝¹ : CategoryTheory.HasWeakSheafify J (Type v)\ninst✝ : CategoryTheory.HasSheafify J AddCommGrp\nS : J.MayerVietorisSquare\n⊢ S.shortComplex.ShortExact","decl":"lemma shortComplex_shortExact : S.shortComplex.ShortExact where\n  exact := S.shortComplex_exact\n\n"}
