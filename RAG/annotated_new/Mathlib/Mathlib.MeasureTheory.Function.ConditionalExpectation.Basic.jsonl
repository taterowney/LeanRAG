{"name":"MeasureTheory.condExp_def","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_5\nE : Type u_6\nm mâ‚€ : MeasurableSpace Î±\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\nâŠ¢ Eq (MeasureTheory.condExp m Î¼ f) (dite (LE.le m mâ‚€) (fun hm => dite (And (MeasureTheory.SigmaFinite (Î¼.trim hm)) (MeasureTheory.Integrable f Î¼)) (fun h => ite (MeasureTheory.StronglyMeasurable f) f (letFun â‹¯ fun this => MeasureTheory.AEStronglyMeasurable.mk â†‘â†‘(MeasureTheory.condExpL1 hm Î¼ f) â‹¯)) fun h => 0) fun hm => 0)","decl":"open scoped Classical in\nvariable (m) in\n/-- Conditional expectation of a function. It is defined as 0 if any one of the following conditions\nis true:\n- `m` is not a sub-Ïƒ-algebra of `mâ‚€`,\n- `Î¼` is not Ïƒ-finite with respect to `m`,\n- `f` is not integrable. -/\nnoncomputable irreducible_def condExp (Î¼ : Measure[mâ‚€] Î±) (f : Î± â†’ E) : Î± â†’ E :=\n  if hm : m â‰¤ mâ‚€ then\n    if h : SigmaFinite (Î¼.trim hm) âˆ§ Integrable f Î¼ then\n      if StronglyMeasurable[m] f then f\n      else have := h.1; aestronglyMeasurable_condExpL1.mk (condExpL1 hm Î¼ f)\n    else 0\n  else 0\n\n"}
{"name":"MeasureTheory.condExp_of_not_le","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhm_not : Not (LE.le m mâ‚€)\nâŠ¢ Eq (MeasureTheory.condExp m Î¼ f) 0","decl":"theorem condExp_of_not_le (hm_not : Â¬m â‰¤ mâ‚€) : Î¼[f|m] = 0 := by rw [condExp, dif_neg hm_not]\n\n"}
{"name":"MeasureTheory.condexp_of_not_le","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhm_not : Not (LE.le m mâ‚€)\nâŠ¢ Eq (MeasureTheory.condExp m Î¼ f) 0","decl":"@[deprecated (since := \"2025-01-21\")] alias condexp_of_not_le := condExp_of_not_le\n\n"}
{"name":"MeasureTheory.condExp_of_not_sigmaFinite","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhm : LE.le m mâ‚€\nhÎ¼m_not : Not (MeasureTheory.SigmaFinite (Î¼.trim hm))\nâŠ¢ Eq (MeasureTheory.condExp m Î¼ f) 0","decl":"theorem condExp_of_not_sigmaFinite (hm : m â‰¤ mâ‚€) (hÎ¼m_not : Â¬SigmaFinite (Î¼.trim hm)) :\n    Î¼[f|m] = 0 := by rw [condExp, dif_pos hm, dif_neg]; push_neg; exact fun h => absurd h hÎ¼m_not\n\n"}
{"name":"MeasureTheory.condexp_of_not_sigmaFinite","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhm : LE.le m mâ‚€\nhÎ¼m_not : Not (MeasureTheory.SigmaFinite (Î¼.trim hm))\nâŠ¢ Eq (MeasureTheory.condExp m Î¼ f) 0","decl":"@[deprecated (since := \"2025-01-21\")] alias condexp_of_not_sigmaFinite := condExp_of_not_sigmaFinite\n\n"}
{"name":"MeasureTheory.condExp_of_sigmaFinite","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhm : LE.le m mâ‚€\nhÎ¼m : MeasureTheory.SigmaFinite (Î¼.trim hm)\nâŠ¢ Eq (MeasureTheory.condExp m Î¼ f) (ite (MeasureTheory.Integrable f Î¼) (ite (MeasureTheory.StronglyMeasurable f) f (MeasureTheory.AEStronglyMeasurable.mk â†‘â†‘(MeasureTheory.condExpL1 hm Î¼ f) â‹¯)) 0)","decl":"open scoped Classical in\ntheorem condExp_of_sigmaFinite (hm : m â‰¤ mâ‚€) [hÎ¼m : SigmaFinite (Î¼.trim hm)] :\n    Î¼[f|m] =\n      if Integrable f Î¼ then\n        if StronglyMeasurable[m] f then f\n        else aestronglyMeasurable_condExpL1.mk (condExpL1 hm Î¼ f)\n      else 0 := by\n  rw [condExp, dif_pos hm]\n  simp only [hÎ¼m, Ne, true_and]\n  by_cases hf : Integrable f Î¼\n  Â· rw [dif_pos hf, if_pos hf]\n  Â· rw [dif_neg hf, if_neg hf]\n\n"}
{"name":"MeasureTheory.condexp_of_sigmaFinite","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhm : LE.le m mâ‚€\nhÎ¼m : MeasureTheory.SigmaFinite (Î¼.trim hm)\nâŠ¢ Eq (MeasureTheory.condExp m Î¼ f) (ite (MeasureTheory.Integrable f Î¼) (ite (MeasureTheory.StronglyMeasurable f) f (MeasureTheory.AEStronglyMeasurable.mk â†‘â†‘(MeasureTheory.condExpL1 hm Î¼ f) â‹¯)) 0)","decl":"@[deprecated (since := \"2025-01-21\")] alias condexp_of_sigmaFinite := condExp_of_sigmaFinite\n\n"}
{"name":"MeasureTheory.condExp_of_stronglyMeasurable","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhm : LE.le m mâ‚€\nhÎ¼m : MeasureTheory.SigmaFinite (Î¼.trim hm)\nf : Î± â†’ E\nhf : MeasureTheory.StronglyMeasurable f\nhfi : MeasureTheory.Integrable f Î¼\nâŠ¢ Eq (MeasureTheory.condExp m Î¼ f) f","decl":"theorem condExp_of_stronglyMeasurable (hm : m â‰¤ mâ‚€) [hÎ¼m : SigmaFinite (Î¼.trim hm)] {f : Î± â†’ E}\n    (hf : StronglyMeasurable[m] f) (hfi : Integrable f Î¼) : Î¼[f|m] = f := by\n  rw [condExp_of_sigmaFinite hm, if_pos hfi, if_pos hf]\n\n"}
{"name":"MeasureTheory.condexp_of_stronglyMeasurable","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhm : LE.le m mâ‚€\nhÎ¼m : MeasureTheory.SigmaFinite (Î¼.trim hm)\nf : Î± â†’ E\nhf : MeasureTheory.StronglyMeasurable f\nhfi : MeasureTheory.Integrable f Î¼\nâŠ¢ Eq (MeasureTheory.condExp m Î¼ f) f","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexp_of_stronglyMeasurable := condExp_of_stronglyMeasurable\n\n"}
{"name":"MeasureTheory.condExp_const","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : CompleteSpace E\nhm : LE.le m mâ‚€\nc : E\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nâŠ¢ Eq (MeasureTheory.condExp m Î¼ fun x => c) fun x => c","decl":"@[simp]\ntheorem condExp_const (hm : m â‰¤ mâ‚€) (c : E) [IsFiniteMeasure Î¼] : Î¼[fun _ : Î± â†¦ c|m] = fun _ â†¦ c :=\n  condExp_of_stronglyMeasurable hm stronglyMeasurable_const (integrable_const c)\n\n"}
{"name":"MeasureTheory.condexp_const","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : CompleteSpace E\nhm : LE.le m mâ‚€\nc : E\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nâŠ¢ Eq (MeasureTheory.condExp m Î¼ fun x => c) fun x => c","decl":"@[deprecated (since := \"2025-01-21\")] alias condexp_const := condExp_const\n\n"}
{"name":"MeasureTheory.condExp_ae_eq_condExpL1","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhm : LE.le m mâ‚€\nhÎ¼m : MeasureTheory.SigmaFinite (Î¼.trim hm)\nf : Î± â†’ E\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ f) â†‘â†‘(MeasureTheory.condExpL1 hm Î¼ f)","decl":"theorem condExp_ae_eq_condExpL1 (hm : m â‰¤ mâ‚€) [hÎ¼m : SigmaFinite (Î¼.trim hm)] (f : Î± â†’ E) :\n    Î¼[f|m] =áµ[Î¼] condExpL1 hm Î¼ f := by\n  rw [condExp_of_sigmaFinite hm]\n  by_cases hfi : Integrable f Î¼\n  Â· rw [if_pos hfi]\n    by_cases hfm : StronglyMeasurable[m] f\n    Â· rw [if_pos hfm]\n      exact (condExpL1_of_aestronglyMeasurable' hfm.aestronglyMeasurable hfi).symm\n    Â· rw [if_neg hfm]\n      exact aestronglyMeasurable_condExpL1.ae_eq_mk.symm\n  rw [if_neg hfi, condExpL1_undef hfi]\n  exact (coeFn_zero _ _ _).symm\n\n"}
{"name":"MeasureTheory.condexp_ae_eq_condexpL1","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhm : LE.le m mâ‚€\nhÎ¼m : MeasureTheory.SigmaFinite (Î¼.trim hm)\nf : Î± â†’ E\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ f) â†‘â†‘(MeasureTheory.condExpL1 hm Î¼ f)","decl":"@[deprecated (since := \"2025-01-21\")] alias condexp_ae_eq_condexpL1 := condExp_ae_eq_condExpL1\n\n"}
{"name":"MeasureTheory.condExp_ae_eq_condExpL1CLM","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : CompleteSpace E\nhm : LE.le m mâ‚€\ninstâœ : MeasureTheory.SigmaFinite (Î¼.trim hm)\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ f) â†‘â†‘((MeasureTheory.condExpL1CLM E hm Î¼) (MeasureTheory.Integrable.toL1 f hf))","decl":"theorem condExp_ae_eq_condExpL1CLM (hm : m â‰¤ mâ‚€) [SigmaFinite (Î¼.trim hm)] (hf : Integrable f Î¼) :\n    Î¼[f|m] =áµ[Î¼] condExpL1CLM E hm Î¼ (hf.toL1 f) := by\n  refine (condExp_ae_eq_condExpL1 hm f).trans (Eventually.of_forall fun x => ?_)\n  rw [condExpL1_eq hf]\n\n"}
{"name":"MeasureTheory.condexp_ae_eq_condexpL1CLM","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : CompleteSpace E\nhm : LE.le m mâ‚€\ninstâœ : MeasureTheory.SigmaFinite (Î¼.trim hm)\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ f) â†‘â†‘((MeasureTheory.condExpL1CLM E hm Î¼) (MeasureTheory.Integrable.toL1 f hf))","decl":"@[deprecated (since := \"2025-01-21\")] alias condexp_ae_eq_condexpL1CLM := condExp_ae_eq_condExpL1CLM\n\n"}
{"name":"MeasureTheory.condExp_of_not_integrable","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhf : Not (MeasureTheory.Integrable f Î¼)\nâŠ¢ Eq (MeasureTheory.condExp m Î¼ f) 0","decl":"theorem condExp_of_not_integrable (hf : Â¬Integrable f Î¼) : Î¼[f|m] = 0 := by\n  by_cases hm : m â‰¤ mâ‚€\n  swap; Â· rw [condExp_of_not_le hm]\n  by_cases hÎ¼m : SigmaFinite (Î¼.trim hm)\n  swap; Â· rw [condExp_of_not_sigmaFinite hm hÎ¼m]\n  rw [condExp_of_sigmaFinite, if_neg hf]\n\n"}
{"name":"MeasureTheory.condexp_undef","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhf : Not (MeasureTheory.Integrable f Î¼)\nâŠ¢ Eq (MeasureTheory.condExp m Î¼ f) 0","decl":"@[deprecated (since := \"2025-01-21\")] alias condexp_undef := condExp_of_not_integrable\n"}
{"name":"MeasureTheory.condExp_undef","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhf : Not (MeasureTheory.Integrable f Î¼)\nâŠ¢ Eq (MeasureTheory.condExp m Î¼ f) 0","decl":"@[deprecated (since := \"2025-01-21\")] alias condExp_undef := condExp_of_not_integrable\n\n"}
{"name":"MeasureTheory.condExp_zero","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nâŠ¢ Eq (MeasureTheory.condExp m Î¼ 0) 0","decl":"@[simp]\ntheorem condExp_zero : Î¼[(0 : Î± â†’ E)|m] = 0 := by\n  by_cases hm : m â‰¤ mâ‚€\n  swap; Â· rw [condExp_of_not_le hm]\n  by_cases hÎ¼m : SigmaFinite (Î¼.trim hm)\n  swap; Â· rw [condExp_of_not_sigmaFinite hm hÎ¼m]\n  exact condExp_of_stronglyMeasurable hm stronglyMeasurable_zero (integrable_zero _ _ _)\n\n"}
{"name":"MeasureTheory.condexp_zero","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nâŠ¢ Eq (MeasureTheory.condExp m Î¼ 0) 0","decl":"@[deprecated (since := \"2025-01-21\")] alias condexp_zero := condExp_zero\n\n"}
{"name":"MeasureTheory.stronglyMeasurable_condExp","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nâŠ¢ MeasureTheory.StronglyMeasurable (MeasureTheory.condExp m Î¼ f)","decl":"theorem stronglyMeasurable_condExp : StronglyMeasurable[m] (Î¼[f|m]) := by\n  by_cases hm : m â‰¤ mâ‚€\n  swap; Â· rw [condExp_of_not_le hm]; exact stronglyMeasurable_zero\n  by_cases hÎ¼m : SigmaFinite (Î¼.trim hm)\n  swap; Â· rw [condExp_of_not_sigmaFinite hm hÎ¼m]; exact stronglyMeasurable_zero\n  rw [condExp_of_sigmaFinite hm]\n  split_ifs with hfi hfm\n  Â· exact hfm\n  Â· exact aestronglyMeasurable_condExpL1.stronglyMeasurable_mk\n  Â· exact stronglyMeasurable_zero\n\n"}
{"name":"MeasureTheory.stronglyMeasurable_condexp","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nâŠ¢ MeasureTheory.StronglyMeasurable (MeasureTheory.condExp m Î¼ f)","decl":"@[deprecated (since := \"2025-01-21\")] alias stronglyMeasurable_condexp := stronglyMeasurable_condExp\n\n"}
{"name":"MeasureTheory.condExp_congr_ae","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ E\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nh : (MeasureTheory.ae Î¼).EventuallyEq f g\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ f) (MeasureTheory.condExp m Î¼ g)","decl":"theorem condExp_congr_ae (h : f =áµ[Î¼] g) : Î¼[f|m] =áµ[Î¼] Î¼[g|m] := by\n  by_cases hm : m â‰¤ mâ‚€\n  swap; Â· simp_rw [condExp_of_not_le hm]; rfl\n  by_cases hÎ¼m : SigmaFinite (Î¼.trim hm)\n  swap; Â· simp_rw [condExp_of_not_sigmaFinite hm hÎ¼m]; rfl\n  exact (condExp_ae_eq_condExpL1 hm f).trans\n    (Filter.EventuallyEq.trans (by rw [condExpL1_congr_ae hm h])\n      (condExp_ae_eq_condExpL1 hm g).symm)\n\n"}
{"name":"MeasureTheory.condexp_congr_ae","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ E\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nh : (MeasureTheory.ae Î¼).EventuallyEq f g\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ f) (MeasureTheory.condExp m Î¼ g)","decl":"@[deprecated (since := \"2025-01-21\")] alias condexp_congr_ae := condExp_congr_ae\n\n"}
{"name":"MeasureTheory.condExp_of_aestronglyMeasurable'","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhm : LE.le m mâ‚€\nhÎ¼m : MeasureTheory.SigmaFinite (Î¼.trim hm)\nf : Î± â†’ E\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\nhfi : MeasureTheory.Integrable f Î¼\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ f) f","decl":"theorem condExp_of_aestronglyMeasurable' (hm : m â‰¤ mâ‚€) [hÎ¼m : SigmaFinite (Î¼.trim hm)] {f : Î± â†’ E}\n    (hf : AEStronglyMeasurable[m] f Î¼) (hfi : Integrable f Î¼) : Î¼[f|m] =áµ[Î¼] f := by\n  refine ((condExp_congr_ae hf.ae_eq_mk).trans ?_).trans hf.ae_eq_mk.symm\n  rw [condExp_of_stronglyMeasurable hm hf.stronglyMeasurable_mk\n    ((integrable_congr hf.ae_eq_mk).mp hfi)]\n\n"}
{"name":"MeasureTheory.condexp_of_aestronglyMeasurable'","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhm : LE.le m mâ‚€\nhÎ¼m : MeasureTheory.SigmaFinite (Î¼.trim hm)\nf : Î± â†’ E\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\nhfi : MeasureTheory.Integrable f Î¼\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ f) f","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexp_of_aestronglyMeasurable' := condExp_of_aestronglyMeasurable'\n\n"}
{"name":"MeasureTheory.integrable_condExp","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nâŠ¢ MeasureTheory.Integrable (MeasureTheory.condExp m Î¼ f) Î¼","decl":"@[fun_prop]\ntheorem integrable_condExp : Integrable (Î¼[f|m]) Î¼ := by\n  by_cases hm : m â‰¤ mâ‚€\n  swap; Â· rw [condExp_of_not_le hm]; exact integrable_zero _ _ _\n  by_cases hÎ¼m : SigmaFinite (Î¼.trim hm)\n  swap; Â· rw [condExp_of_not_sigmaFinite hm hÎ¼m]; exact integrable_zero _ _ _\n  exact (integrable_condExpL1 f).congr (condExp_ae_eq_condExpL1 hm f).symm\n\n"}
{"name":"MeasureTheory.integrable_condexp","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nâŠ¢ MeasureTheory.Integrable (MeasureTheory.condExp m Î¼ f) Î¼","decl":"@[deprecated (since := \"2025-01-21\")] alias integrable_condexp := integrable_condExp\n\n"}
{"name":"MeasureTheory.setIntegral_condExp","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\ns : Set Î±\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : CompleteSpace E\nhm : LE.le m mâ‚€\ninstâœ : MeasureTheory.SigmaFinite (Î¼.trim hm)\nhf : MeasureTheory.Integrable f Î¼\nhs : MeasurableSet s\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => MeasureTheory.condExp m Î¼ f x) (MeasureTheory.integral (Î¼.restrict s) fun x => f x)","decl":"/-- The integral of the conditional expectation `Î¼[f|hm]` over an `m`-measurable set is equal to\nthe integral of `f` on that set. -/\ntheorem setIntegral_condExp (hm : m â‰¤ mâ‚€) [SigmaFinite (Î¼.trim hm)] (hf : Integrable f Î¼)\n    (hs : MeasurableSet[m] s) : âˆ« x in s, (Î¼[f|m]) x âˆ‚Î¼ = âˆ« x in s, f x âˆ‚Î¼ := by\n  rw [setIntegral_congr_ae (hm s hs) ((condExp_ae_eq_condExpL1 hm f).mono fun x hx _ => hx)]\n  exact setIntegral_condExpL1 hf hs\n\n"}
{"name":"MeasureTheory.setIntegral_condexp","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\ns : Set Î±\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : CompleteSpace E\nhm : LE.le m mâ‚€\ninstâœ : MeasureTheory.SigmaFinite (Î¼.trim hm)\nhf : MeasureTheory.Integrable f Î¼\nhs : MeasurableSet s\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => MeasureTheory.condExp m Î¼ f x) (MeasureTheory.integral (Î¼.restrict s) fun x => f x)","decl":"@[deprecated (since := \"2025-01-21\")] alias setIntegral_condexp := setIntegral_condExp\n\n"}
{"name":"MeasureTheory.integral_condExp","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhm : LE.le m mâ‚€\nhÎ¼m : MeasureTheory.SigmaFinite (Î¼.trim hm)\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => MeasureTheory.condExp m Î¼ f x) (MeasureTheory.integral Î¼ fun x => f x)","decl":"theorem integral_condExp (hm : m â‰¤ mâ‚€) [hÎ¼m : SigmaFinite (Î¼.trim hm)] :\n    âˆ« x, (Î¼[f|m]) x âˆ‚Î¼ = âˆ« x, f x âˆ‚Î¼ := by\n  by_cases hf : Integrable f Î¼\n  Â· suffices âˆ« x in Set.univ, (Î¼[f|m]) x âˆ‚Î¼ = âˆ« x in Set.univ, f x âˆ‚Î¼ by\n      simp_rw [setIntegral_univ] at this; exact this\n    exact setIntegral_condExp hm hf .univ\n  simp only [condExp_of_not_integrable hf, Pi.zero_apply, integral_zero, integral_undef hf]\n\n"}
{"name":"MeasureTheory.integral_condexp","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhm : LE.le m mâ‚€\nhÎ¼m : MeasureTheory.SigmaFinite (Î¼.trim hm)\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => MeasureTheory.condExp m Î¼ f x) (MeasureTheory.integral Î¼ fun x => f x)","decl":"@[deprecated (since := \"2025-01-21\")] alias integral_condexp := integral_condExp\n\n"}
{"name":"MeasureTheory.integral_condExp_indicator","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nmâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nmÎ² : MeasurableSpace Î²\nY : Î± â†’ Î²\nhY : Measurable Y\ninstâœ : MeasureTheory.SigmaFinite (Î¼.trim â‹¯)\nA : Set Î±\nhA : MeasurableSet A\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => MeasureTheory.condExp (MeasurableSpace.comap Y mÎ²) Î¼ (A.indicator fun x => 1) x) (Î¼ A).toReal","decl":"/-- **Law of total probability** using `condExp` as conditional probability. -/\ntheorem integral_condExp_indicator [mÎ² : MeasurableSpace Î²] {Y : Î± â†’ Î²} (hY : Measurable Y)\n    [SigmaFinite (Î¼.trim hY.comap_le)] {A : Set Î±} (hA : MeasurableSet A) :\n    âˆ« x, (Î¼[(A.indicator fun _ â†¦ (1 : â„)) | mÎ².comap Y]) x âˆ‚Î¼ = (Î¼ A).toReal := by\n  rw [integral_condExp, integral_indicator hA, setIntegral_const, smul_eq_mul, mul_one]\n\n"}
{"name":"MeasureTheory.integral_condexp_indicator","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nmâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nmÎ² : MeasurableSpace Î²\nY : Î± â†’ Î²\nhY : Measurable Y\ninstâœ : MeasureTheory.SigmaFinite (Î¼.trim â‹¯)\nA : Set Î±\nhA : MeasurableSet A\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => MeasureTheory.condExp (MeasurableSpace.comap Y mÎ²) Î¼ (A.indicator fun x => 1) x) (Î¼ A).toReal","decl":"@[deprecated (since := \"2025-01-21\")] alias integral_condexp_indicator := integral_condExp_indicator\n\n"}
{"name":"MeasureTheory.ae_eq_condExp_of_forall_setIntegral_eq","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : CompleteSpace E\nhm : LE.le m mâ‚€\ninstâœ : MeasureTheory.SigmaFinite (Î¼.trim hm)\nf g : Î± â†’ E\nhf : MeasureTheory.Integrable f Î¼\nhg_int_finite : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ MeasureTheory.IntegrableOn g s Î¼\nhg_eq : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => g x) (MeasureTheory.integral (Î¼.restrict s) fun x => f x)\nhgm : MeasureTheory.AEStronglyMeasurable g Î¼\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq g (MeasureTheory.condExp m Î¼ f)","decl":"/-- **Uniqueness of the conditional expectation**\nIf a function is a.e. `m`-measurable, verifies an integrability condition and has same integral\nas `f` on all `m`-measurable sets, then it is a.e. equal to `Î¼[f|hm]`. -/\ntheorem ae_eq_condExp_of_forall_setIntegral_eq (hm : m â‰¤ mâ‚€) [SigmaFinite (Î¼.trim hm)]\n    {f g : Î± â†’ E} (hf : Integrable f Î¼)\n    (hg_int_finite : âˆ€ s, MeasurableSet[m] s â†’ Î¼ s < âˆ â†’ IntegrableOn g s Î¼)\n    (hg_eq : âˆ€ s : Set Î±, MeasurableSet[m] s â†’ Î¼ s < âˆ â†’ âˆ« x in s, g x âˆ‚Î¼ = âˆ« x in s, f x âˆ‚Î¼)\n    (hgm : AEStronglyMeasurable[m] g Î¼) : g =áµ[Î¼] Î¼[f|m] := by\n  refine ae_eq_of_forall_setIntegral_eq_of_sigmaFinite' hm hg_int_finite\n    (fun s _ _ => integrable_condExp.integrableOn) (fun s hs hÎ¼s => ?_) hgm\n    (StronglyMeasurable.aestronglyMeasurable stronglyMeasurable_condExp)\n  rw [hg_eq s hs hÎ¼s, setIntegral_condExp hm hf hs]\n\n"}
{"name":"MeasureTheory.ae_eq_condexp_of_forall_setIntegral_eq","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : CompleteSpace E\nhm : LE.le m mâ‚€\ninstâœ : MeasureTheory.SigmaFinite (Î¼.trim hm)\nf g : Î± â†’ E\nhf : MeasureTheory.Integrable f Î¼\nhg_int_finite : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ MeasureTheory.IntegrableOn g s Î¼\nhg_eq : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => g x) (MeasureTheory.integral (Î¼.restrict s) fun x => f x)\nhgm : MeasureTheory.AEStronglyMeasurable g Î¼\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq g (MeasureTheory.condExp m Î¼ f)","decl":"@[deprecated (since := \"2025-01-21\")]\nalias ae_eq_condexp_of_forall_setIntegral_eq := ae_eq_condExp_of_forall_setIntegral_eq\n\n"}
{"name":"MeasureTheory.condExp_bot'","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nmâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhÎ¼ : NeZero Î¼\nf : Î± â†’ E\nâŠ¢ Eq (MeasureTheory.condExp Bot.bot Î¼ f) fun x => HSMul.hSMul (Inv.inv (Î¼ Set.univ).toReal) (MeasureTheory.integral Î¼ fun x => f x)","decl":"theorem condExp_bot' [hÎ¼ : NeZero Î¼] (f : Î± â†’ E) :\n    Î¼[f|âŠ¥] = fun _ => (Î¼ Set.univ).toRealâ»Â¹ â€¢ âˆ« x, f x âˆ‚Î¼ := by\n  by_cases hÎ¼_finite : IsFiniteMeasure Î¼\n  swap\n  Â· have h : Â¬SigmaFinite (Î¼.trim bot_le) := by rwa [sigmaFinite_trim_bot_iff]\n    rw [not_isFiniteMeasure_iff] at hÎ¼_finite\n    rw [condExp_of_not_sigmaFinite bot_le h]\n    simp only [hÎ¼_finite, ENNReal.top_toReal, inv_zero, zero_smul]\n    rfl\n  have h_meas : StronglyMeasurable[âŠ¥] (Î¼[f|âŠ¥]) := stronglyMeasurable_condExp\n  obtain âŸ¨c, h_eqâŸ© := stronglyMeasurable_bot_iff.mp h_meas\n  rw [h_eq]\n  have h_integral : âˆ« x, (Î¼[f|âŠ¥]) x âˆ‚Î¼ = âˆ« x, f x âˆ‚Î¼ := integral_condExp bot_le\n  simp_rw [h_eq, integral_const] at h_integral\n  rw [â† h_integral, â† smul_assoc, smul_eq_mul, inv_mul_cancelâ‚€, one_smul]\n  rw [Ne, ENNReal.toReal_eq_zero_iff, not_or]\n  exact âŸ¨NeZero.ne _, measure_ne_top Î¼ Set.univâŸ©\n\n"}
{"name":"MeasureTheory.condexp_bot'","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nmâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhÎ¼ : NeZero Î¼\nf : Î± â†’ E\nâŠ¢ Eq (MeasureTheory.condExp Bot.bot Î¼ f) fun x => HSMul.hSMul (Inv.inv (Î¼ Set.univ).toReal) (MeasureTheory.integral Î¼ fun x => f x)","decl":"@[deprecated (since := \"2025-01-21\")] alias condexp_bot' := condExp_bot'\n\n"}
{"name":"MeasureTheory.condExp_bot_ae_eq","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nmâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nf : Î± â†’ E\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp Bot.bot Î¼ f) fun x => HSMul.hSMul (Inv.inv (Î¼ Set.univ).toReal) (MeasureTheory.integral Î¼ fun x => f x)","decl":"theorem condExp_bot_ae_eq (f : Î± â†’ E) :\n    Î¼[f|âŠ¥] =áµ[Î¼] fun _ => (Î¼ Set.univ).toRealâ»Â¹ â€¢ âˆ« x, f x âˆ‚Î¼ := by\n  rcases eq_zero_or_neZero Î¼ with rfl | hÎ¼\n  Â· rw [ae_zero]; exact eventually_bot\n  Â· exact Eventually.of_forall <| congr_fun (condExp_bot' f)\n\n"}
{"name":"MeasureTheory.condexp_bot_ae_eq","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nmâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nf : Î± â†’ E\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp Bot.bot Î¼ f) fun x => HSMul.hSMul (Inv.inv (Î¼ Set.univ).toReal) (MeasureTheory.integral Î¼ fun x => f x)","decl":"@[deprecated (since := \"2025-01-21\")] alias condexp_bot_ae_eq := condExp_bot_ae_eq\n\n"}
{"name":"MeasureTheory.condExp_bot","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nmâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : CompleteSpace E\ninstâœ : MeasureTheory.IsProbabilityMeasure Î¼\nf : Î± â†’ E\nâŠ¢ Eq (MeasureTheory.condExp Bot.bot Î¼ f) fun x => MeasureTheory.integral Î¼ fun x => f x","decl":"theorem condExp_bot [IsProbabilityMeasure Î¼] (f : Î± â†’ E) : Î¼[f|âŠ¥] = fun _ => âˆ« x, f x âˆ‚Î¼ := by\n  refine (condExp_bot' f).trans ?_; rw [measure_univ, ENNReal.one_toReal, inv_one, one_smul]\n\n"}
{"name":"MeasureTheory.condexp_bot","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nmâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : CompleteSpace E\ninstâœ : MeasureTheory.IsProbabilityMeasure Î¼\nf : Î± â†’ E\nâŠ¢ Eq (MeasureTheory.condExp Bot.bot Î¼ f) fun x => MeasureTheory.integral Î¼ fun x => f x","decl":"@[deprecated (since := \"2025-01-21\")] alias condexp_bot := condExp_bot\n\n"}
{"name":"MeasureTheory.condExp_add","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nmâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ E\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î¼\nm : MeasurableSpace Î±\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ (HAdd.hAdd f g)) (HAdd.hAdd (MeasureTheory.condExp m Î¼ f) (MeasureTheory.condExp m Î¼ g))","decl":"theorem condExp_add (hf : Integrable f Î¼) (hg : Integrable g Î¼) (m : MeasurableSpace Î±) :\n    Î¼[f + g|m] =áµ[Î¼] Î¼[f|m] + Î¼[g|m] := by\n  by_cases hm : m â‰¤ mâ‚€\n  swap; Â· simp_rw [condExp_of_not_le hm]; simp\n  by_cases hÎ¼m : SigmaFinite (Î¼.trim hm)\n  swap; Â· simp_rw [condExp_of_not_sigmaFinite hm hÎ¼m]; simp\n  refine (condExp_ae_eq_condExpL1 hm _).trans ?_\n  rw [condExpL1_add hf hg]\n  exact (coeFn_add _ _).trans\n    ((condExp_ae_eq_condExpL1 hm _).symm.add (condExp_ae_eq_condExpL1 hm _).symm)\n\n"}
{"name":"MeasureTheory.condexp_add","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nmâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ E\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î¼\nm : MeasurableSpace Î±\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ (HAdd.hAdd f g)) (HAdd.hAdd (MeasureTheory.condExp m Î¼ f) (MeasureTheory.condExp m Î¼ g))","decl":"@[deprecated (since := \"2025-01-21\")] alias condexp_add := condExp_add\n\n"}
{"name":"MeasureTheory.condExp_finset_sum","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nmâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nÎ¹ : Type u_5\ns : Finset Î¹\nf : Î¹ â†’ Î± â†’ E\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ MeasureTheory.Integrable (f i) Î¼\nm : MeasurableSpace Î±\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ (s.sum fun i => f i)) (s.sum fun i => MeasureTheory.condExp m Î¼ (f i))","decl":"theorem condExp_finset_sum {Î¹ : Type*} {s : Finset Î¹} {f : Î¹ â†’ Î± â†’ E}\n    (hf : âˆ€ i âˆˆ s, Integrable (f i) Î¼) (m : MeasurableSpace Î±) :\n    Î¼[âˆ‘ i âˆˆ s, f i|m] =áµ[Î¼] âˆ‘ i âˆˆ s, Î¼[f i|m] := by\n  classical\n  induction' s using Finset.induction_on with i s his heq hf\n  Â· rw [Finset.sum_empty, Finset.sum_empty, condExp_zero]\n  Â· rw [Finset.sum_insert his, Finset.sum_insert his]\n    exact (condExp_add (hf i <| Finset.mem_insert_self i s)\n      (integrable_finset_sum' _ <| Finset.forall_of_forall_insert hf) _).trans\n        ((EventuallyEq.refl _ _).add <| heq <| Finset.forall_of_forall_insert hf)\n\n"}
{"name":"MeasureTheory.condexp_finset_sum","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nmâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nÎ¹ : Type u_5\ns : Finset Î¹\nf : Î¹ â†’ Î± â†’ E\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ MeasureTheory.Integrable (f i) Î¼\nm : MeasurableSpace Î±\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ (s.sum fun i => f i)) (s.sum fun i => MeasureTheory.condExp m Î¼ (f i))","decl":"@[deprecated (since := \"2025-01-21\")] alias condexp_finset_sum := condExp_finset_sum\n\n"}
{"name":"MeasureTheory.condExp_smul","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nğ•œ : Type u_4\ninstâœâ´ : RCLike ğ•œ\nmâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : CompleteSpace E\ninstâœ : NormedSpace ğ•œ E\nc : ğ•œ\nf : Î± â†’ E\nm : MeasurableSpace Î±\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ (HSMul.hSMul c f)) (HSMul.hSMul c (MeasureTheory.condExp m Î¼ f))","decl":"theorem condExp_smul [NormedSpace ğ•œ E] (c : ğ•œ) (f : Î± â†’ E) (m : MeasurableSpace Î±) :\n    Î¼[c â€¢ f|m] =áµ[Î¼] c â€¢ Î¼[f|m] := by\n  by_cases hm : m â‰¤ mâ‚€\n  swap; Â· simp_rw [condExp_of_not_le hm]; simp\n  by_cases hÎ¼m : SigmaFinite (Î¼.trim hm)\n  swap; Â· simp_rw [condExp_of_not_sigmaFinite hm hÎ¼m]; simp\n  refine (condExp_ae_eq_condExpL1 hm _).trans ?_\n  rw [condExpL1_smul c f]\n  refine (condExp_ae_eq_condExpL1 hm f).mp ?_\n  refine (coeFn_smul c (condExpL1 hm Î¼ f)).mono fun x hx1 hx2 => ?_\n  simp only [hx1, hx2, Pi.smul_apply]\n\n"}
{"name":"MeasureTheory.condexp_smul","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nğ•œ : Type u_4\ninstâœâ´ : RCLike ğ•œ\nmâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : CompleteSpace E\ninstâœ : NormedSpace ğ•œ E\nc : ğ•œ\nf : Î± â†’ E\nm : MeasurableSpace Î±\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ (HSMul.hSMul c f)) (HSMul.hSMul c (MeasureTheory.condExp m Î¼ f))","decl":"@[deprecated (since := \"2025-01-21\")] alias condexp_smul := condExp_smul\n\n"}
{"name":"MeasureTheory.condExp_neg","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nmâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nf : Î± â†’ E\nm : MeasurableSpace Î±\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ (Neg.neg f)) (Neg.neg (MeasureTheory.condExp m Î¼ f))","decl":"theorem condExp_neg (f : Î± â†’ E) (m : MeasurableSpace Î±) : Î¼[-f|m] =áµ[Î¼] -Î¼[f|m] := by\n  calc\n    Î¼[-f|m] = Î¼[(-1 : â„) â€¢ f|m] := by rw [neg_one_smul â„ f]\n    _ =áµ[Î¼] (-1 : â„) â€¢ Î¼[f|m] := condExp_smul ..\n    _ = -Î¼[f|m] := neg_one_smul â„ (Î¼[f|m])\n\n"}
{"name":"MeasureTheory.condexp_neg","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nmâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nf : Î± â†’ E\nm : MeasurableSpace Î±\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ (Neg.neg f)) (Neg.neg (MeasureTheory.condExp m Î¼ f))","decl":"@[deprecated (since := \"2025-01-21\")] alias condexp_neg := condExp_neg\n\n"}
{"name":"MeasureTheory.condExp_sub","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nmâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ E\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î¼\nm : MeasurableSpace Î±\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ (HSub.hSub f g)) (HSub.hSub (MeasureTheory.condExp m Î¼ f) (MeasureTheory.condExp m Î¼ g))","decl":"theorem condExp_sub (hf : Integrable f Î¼) (hg : Integrable g Î¼) (m : MeasurableSpace Î±) :\n    Î¼[f - g|m] =áµ[Î¼] Î¼[f|m] - Î¼[g|m] := by\n  simp_rw [sub_eq_add_neg]\n  exact (condExp_add hf hg.neg _).trans (EventuallyEq.rfl.add (condExp_neg ..))\n\n"}
{"name":"MeasureTheory.condexp_sub","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nmâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ E\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î¼\nm : MeasurableSpace Î±\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ (HSub.hSub f g)) (HSub.hSub (MeasureTheory.condExp m Î¼ f) (MeasureTheory.condExp m Î¼ g))","decl":"@[deprecated (since := \"2025-01-21\")] alias condexp_sub := condExp_sub\n\n"}
{"name":"MeasureTheory.condExp_condExp_of_le","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nf : Î± â†’ E\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : CompleteSpace E\nmâ‚ mâ‚‚ mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nhmâ‚â‚‚ : LE.le mâ‚ mâ‚‚\nhmâ‚‚ : LE.le mâ‚‚ mâ‚€\ninstâœ : MeasureTheory.SigmaFinite (Î¼.trim hmâ‚‚)\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp mâ‚ Î¼ (MeasureTheory.condExp mâ‚‚ Î¼ f)) (MeasureTheory.condExp mâ‚ Î¼ f)","decl":"/-- **Tower property of the conditional expectation**.\n\nTaking the `mâ‚‚`-conditional expectation then the `mâ‚`-conditional expectation, where `mâ‚` is a\nsmaller Ïƒ-algebra, is the same as taking the `mâ‚`-conditional expectation directly. -/\ntheorem condExp_condExp_of_le {mâ‚ mâ‚‚ mâ‚€ : MeasurableSpace Î±} {Î¼ : Measure Î±} (hmâ‚â‚‚ : mâ‚ â‰¤ mâ‚‚)\n    (hmâ‚‚ : mâ‚‚ â‰¤ mâ‚€) [SigmaFinite (Î¼.trim hmâ‚‚)] : Î¼[Î¼[f|mâ‚‚]|mâ‚] =áµ[Î¼] Î¼[f|mâ‚] := by\n  by_cases hÎ¼mâ‚ : SigmaFinite (Î¼.trim (hmâ‚â‚‚.trans hmâ‚‚))\n  swap; Â· simp_rw [condExp_of_not_sigmaFinite (hmâ‚â‚‚.trans hmâ‚‚) hÎ¼mâ‚]; rfl\n  by_cases hf : Integrable f Î¼\n  swap; Â· simp_rw [condExp_of_not_integrable hf, condExp_zero]; rfl\n  refine ae_eq_of_forall_setIntegral_eq_of_sigmaFinite' (hmâ‚â‚‚.trans hmâ‚‚)\n    (fun s _ _ => integrable_condExp.integrableOn) (fun s _ _ => integrable_condExp.integrableOn) ?_\n    stronglyMeasurable_condExp.aestronglyMeasurable\n    stronglyMeasurable_condExp.aestronglyMeasurable\n  intro s hs _\n  rw [setIntegral_condExp (hmâ‚â‚‚.trans hmâ‚‚) integrable_condExp hs]\n  rw [setIntegral_condExp (hmâ‚â‚‚.trans hmâ‚‚) hf hs, setIntegral_condExp hmâ‚‚ hf (hmâ‚â‚‚ s hs)]\n\n"}
{"name":"MeasureTheory.condexp_condexp_of_le","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nf : Î± â†’ E\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : CompleteSpace E\nmâ‚ mâ‚‚ mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nhmâ‚â‚‚ : LE.le mâ‚ mâ‚‚\nhmâ‚‚ : LE.le mâ‚‚ mâ‚€\ninstâœ : MeasureTheory.SigmaFinite (Î¼.trim hmâ‚‚)\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp mâ‚ Î¼ (MeasureTheory.condExp mâ‚‚ Î¼ f)) (MeasureTheory.condExp mâ‚ Î¼ f)","decl":"@[deprecated (since := \"2025-01-21\")] alias condexp_condexp_of_le := condExp_condExp_of_le\n\n"}
{"name":"MeasureTheory.Memâ„’p.condExpL2_ae_eq_condExp'","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nğ•œ : Type u_4\ninstâœâµ : RCLike ğ•œ\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : CompleteSpace E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nhm : LE.le m mâ‚€\nhf1 : MeasureTheory.Integrable f Î¼\nhf2 : MeasureTheory.Memâ„’p f 2 Î¼\ninstâœ : MeasureTheory.SigmaFinite (Î¼.trim hm)\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (â†‘â†‘â†‘((MeasureTheory.condExpL2 E ğ•œ hm) (MeasureTheory.Memâ„’p.toLp f hf2))) (MeasureTheory.condExp m Î¼ f)","decl":"lemma Memâ„’p.condExpL2_ae_eq_condExp' (hm : m â‰¤ mâ‚€) (hf1 : Integrable f Î¼) (hf2 : Memâ„’p f 2 Î¼)\n    [SigmaFinite (Î¼.trim hm)] : condExpL2 E ğ•œ hm hf2.toLp =áµ[Î¼] Î¼[f | m] := by\n  refine ae_eq_condExp_of_forall_setIntegral_eq hm hf1\n    (fun s hs htop â†¦ integrableOn_condExpL2_of_measure_ne_top hm htop.ne _) (fun s hs htop â†¦ ?_)\n    (aestronglyMeasurable_condExpL2 hm _)\n  rw [integral_condExpL2_eq hm (hf2.toLp _) hs htop.ne]\n  refine setIntegral_congr_ae (hm _ hs) ?_\n  filter_upwards [hf2.coeFn_toLp] with Ï‰ hÏ‰ _ using hÏ‰\n\n"}
{"name":"MeasureTheory.Memâ„’p.condExpL2_ae_eq_condExp","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nğ•œ : Type u_4\ninstâœâµ : RCLike ğ•œ\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : CompleteSpace E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nhm : LE.le m mâ‚€\nhf : MeasureTheory.Memâ„’p f 2 Î¼\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (â†‘â†‘â†‘((MeasureTheory.condExpL2 E ğ•œ hm) (MeasureTheory.Memâ„’p.toLp f hf))) (MeasureTheory.condExp m Î¼ f)","decl":"lemma Memâ„’p.condExpL2_ae_eq_condExp (hm : m â‰¤ mâ‚€) (hf : Memâ„’p f 2 Î¼) [IsFiniteMeasure Î¼] :\n    condExpL2 E ğ•œ hm hf.toLp =áµ[Î¼] Î¼[f | m] :=\n  hf.condExpL2_ae_eq_condExp' hm (memâ„’p_one_iff_integrable.1 <| hf.mono_exponent one_le_two)\n\n"}
{"name":"MeasureTheory.eLpNorm_condExp_le","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : CompleteSpace E\ninstâœ : InnerProductSpace Real E\nâŠ¢ LE.le (MeasureTheory.eLpNorm (MeasureTheory.condExp m Î¼ f) 2 Î¼) (MeasureTheory.eLpNorm f 2 Î¼)","decl":"lemma eLpNorm_condExp_le : eLpNorm (Î¼[f | m]) 2 Î¼ â‰¤ eLpNorm f 2 Î¼ := by\n  by_cases hm : m â‰¤ mâ‚€; swap\n  Â· simp [condExp_of_not_le hm]\n  by_cases hfÎ¼ : SigmaFinite (Î¼.trim hm); swap\n  Â· rw [condExp_of_not_sigmaFinite hm hfÎ¼]\n    simp\n  by_cases hfi : Integrable f Î¼; swap\n  Â· rw [condExp_of_not_integrable hfi]\n    simp\n  obtain hf | hf := eq_or_ne (eLpNorm f 2 Î¼) âˆ\n  Â· simp [hf]\n  replace hf : Memâ„’p f 2 Î¼ := âŸ¨hfi.1, Ne.lt_top' fun a â†¦ hf (id (Eq.symm a))âŸ©\n  rw [â† eLpNorm_congr_ae (hf.condExpL2_ae_eq_condExp' (ğ•œ := â„) hm hfi)]\n  refine le_trans (eLpNorm_condExpL2_le hm _) ?_\n  rw [eLpNorm_congr_ae hf.coeFn_toLp]\n\n"}
{"name":"MeasureTheory.Memâ„’p.condExp","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : CompleteSpace E\ninstâœ : InnerProductSpace Real E\nhf : MeasureTheory.Memâ„’p f 2 Î¼\nâŠ¢ MeasureTheory.Memâ„’p (MeasureTheory.condExp m Î¼ f) 2 Î¼","decl":"protected lemma Memâ„’p.condExp (hf : Memâ„’p f 2 Î¼) : Memâ„’p (Î¼[f | m]) 2 Î¼ := by\n  by_cases hm : m â‰¤ mâ‚€\n  Â· exact âŸ¨(stronglyMeasurable_condExp.mono hm).aestronglyMeasurable,\n      eLpNorm_condExp_le.trans_lt hf.eLpNorm_lt_topâŸ©\n  Â· simp [condExp_of_not_le hm]\n\n"}
{"name":"MeasureTheory.condExp_ofNat","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nR : Type u_5\ninstâœÂ³ : NormedRing R\ninstâœÂ² : NormedSpace Real R\ninstâœÂ¹ : CompleteSpace R\nn : Nat\ninstâœ : n.AtLeastTwo\nf : Î± â†’ R\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ (HMul.hMul (OfNat.ofNat n) f)) (HMul.hMul (OfNat.ofNat n) (MeasureTheory.condExp m Î¼ f))","decl":"@[simp]\nlemma condExp_ofNat (n : â„•) [n.AtLeastTwo] (f : Î± â†’ R) :\n    Î¼[ofNat(n) * f|m] =áµ[Î¼] ofNat(n) * Î¼[f|m] := by\n  simpa [Nat.cast_smul_eq_nsmul] using condExp_smul (Î¼ := Î¼) (m := m) (n : â„) f\n\n"}
{"name":"MeasureTheory.tendsto_condExpL1_of_dominated_convergence","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : NormedLatticeAddCommGroup E\ninstâœÂ² : CompleteSpace E\ninstâœÂ¹ : NormedSpace Real E\nhm : LE.le m mâ‚€\ninstâœ : MeasureTheory.SigmaFinite (Î¼.trim hm)\nfs : Nat â†’ Î± â†’ E\nf : Î± â†’ E\nbound_fs : Î± â†’ Real\nhfs_meas : âˆ€ (n : Nat), MeasureTheory.AEStronglyMeasurable (fs n) Î¼\nh_int_bound_fs : MeasureTheory.Integrable bound_fs Î¼\nhfs_bound : âˆ€ (n : Nat), Filter.Eventually (fun x => LE.le (Norm.norm (fs n x)) (bound_fs x)) (MeasureTheory.ae Î¼)\nhfs : Filter.Eventually (fun x => Filter.Tendsto (fun n => fs n x) Filter.atTop (nhds (f x))) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Tendsto (fun n => MeasureTheory.condExpL1 hm Î¼ (fs n)) Filter.atTop (nhds (MeasureTheory.condExpL1 hm Î¼ f))","decl":"/-- **Lebesgue dominated convergence theorem**: sufficient conditions under which almost\n  everywhere convergence of a sequence of functions implies the convergence of their image by\n  `condExpL1`. -/\ntheorem tendsto_condExpL1_of_dominated_convergence (hm : m â‰¤ mâ‚€) [SigmaFinite (Î¼.trim hm)]\n    {fs : â„• â†’ Î± â†’ E} {f : Î± â†’ E} (bound_fs : Î± â†’ â„)\n    (hfs_meas : âˆ€ n, AEStronglyMeasurable (fs n) Î¼) (h_int_bound_fs : Integrable bound_fs Î¼)\n    (hfs_bound : âˆ€ n, âˆ€áµ x âˆ‚Î¼, â€–fs n xâ€– â‰¤ bound_fs x)\n    (hfs : âˆ€áµ x âˆ‚Î¼, Tendsto (fun n => fs n x) atTop (ğ“ (f x))) :\n    Tendsto (fun n => condExpL1 hm Î¼ (fs n)) atTop (ğ“ (condExpL1 hm Î¼ f)) :=\n  tendsto_setToFun_of_dominated_convergence _ bound_fs hfs_meas h_int_bound_fs hfs_bound hfs\n\n"}
{"name":"MeasureTheory.tendsto_condexpL1_of_dominated_convergence","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : NormedLatticeAddCommGroup E\ninstâœÂ² : CompleteSpace E\ninstâœÂ¹ : NormedSpace Real E\nhm : LE.le m mâ‚€\ninstâœ : MeasureTheory.SigmaFinite (Î¼.trim hm)\nfs : Nat â†’ Î± â†’ E\nf : Î± â†’ E\nbound_fs : Î± â†’ Real\nhfs_meas : âˆ€ (n : Nat), MeasureTheory.AEStronglyMeasurable (fs n) Î¼\nh_int_bound_fs : MeasureTheory.Integrable bound_fs Î¼\nhfs_bound : âˆ€ (n : Nat), Filter.Eventually (fun x => LE.le (Norm.norm (fs n x)) (bound_fs x)) (MeasureTheory.ae Î¼)\nhfs : Filter.Eventually (fun x => Filter.Tendsto (fun n => fs n x) Filter.atTop (nhds (f x))) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Tendsto (fun n => MeasureTheory.condExpL1 hm Î¼ (fs n)) Filter.atTop (nhds (MeasureTheory.condExpL1 hm Î¼ f))","decl":"@[deprecated (since := \"2025-01-21\")]\nalias tendsto_condexpL1_of_dominated_convergence := tendsto_condExpL1_of_dominated_convergence\n\n"}
{"name":"MeasureTheory.tendsto_condExp_unique","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedLatticeAddCommGroup E\ninstâœÂ¹ : CompleteSpace E\ninstâœ : NormedSpace Real E\nfs gs : Nat â†’ Î± â†’ E\nf g : Î± â†’ E\nhfs_int : âˆ€ (n : Nat), MeasureTheory.Integrable (fs n) Î¼\nhgs_int : âˆ€ (n : Nat), MeasureTheory.Integrable (gs n) Î¼\nhfs : Filter.Eventually (fun x => Filter.Tendsto (fun n => fs n x) Filter.atTop (nhds (f x))) (MeasureTheory.ae Î¼)\nhgs : Filter.Eventually (fun x => Filter.Tendsto (fun n => gs n x) Filter.atTop (nhds (g x))) (MeasureTheory.ae Î¼)\nbound_fs : Î± â†’ Real\nh_int_bound_fs : MeasureTheory.Integrable bound_fs Î¼\nbound_gs : Î± â†’ Real\nh_int_bound_gs : MeasureTheory.Integrable bound_gs Î¼\nhfs_bound : âˆ€ (n : Nat), Filter.Eventually (fun x => LE.le (Norm.norm (fs n x)) (bound_fs x)) (MeasureTheory.ae Î¼)\nhgs_bound : âˆ€ (n : Nat), Filter.Eventually (fun x => LE.le (Norm.norm (gs n x)) (bound_gs x)) (MeasureTheory.ae Î¼)\nhfg : âˆ€ (n : Nat), (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ (fs n)) (MeasureTheory.condExp m Î¼ (gs n))\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ f) (MeasureTheory.condExp m Î¼ g)","decl":"/-- If two sequences of functions have a.e. equal conditional expectations at each step, converge\nand verify dominated convergence hypotheses, then the conditional expectations of their limits are\na.e. equal. -/\ntheorem tendsto_condExp_unique (fs gs : â„• â†’ Î± â†’ E) (f g : Î± â†’ E)\n    (hfs_int : âˆ€ n, Integrable (fs n) Î¼) (hgs_int : âˆ€ n, Integrable (gs n) Î¼)\n    (hfs : âˆ€áµ x âˆ‚Î¼, Tendsto (fun n => fs n x) atTop (ğ“ (f x)))\n    (hgs : âˆ€áµ x âˆ‚Î¼, Tendsto (fun n => gs n x) atTop (ğ“ (g x))) (bound_fs : Î± â†’ â„)\n    (h_int_bound_fs : Integrable bound_fs Î¼) (bound_gs : Î± â†’ â„)\n    (h_int_bound_gs : Integrable bound_gs Î¼) (hfs_bound : âˆ€ n, âˆ€áµ x âˆ‚Î¼, â€–fs n xâ€– â‰¤ bound_fs x)\n    (hgs_bound : âˆ€ n, âˆ€áµ x âˆ‚Î¼, â€–gs n xâ€– â‰¤ bound_gs x) (hfg : âˆ€ n, Î¼[fs n|m] =áµ[Î¼] Î¼[gs n|m]) :\n    Î¼[f|m] =áµ[Î¼] Î¼[g|m] := by\n  by_cases hm : m â‰¤ mâ‚€; swap; Â· simp_rw [condExp_of_not_le hm]; rfl\n  by_cases hÎ¼m : SigmaFinite (Î¼.trim hm); swap; Â· simp_rw [condExp_of_not_sigmaFinite hm hÎ¼m]; rfl\n  refine (condExp_ae_eq_condExpL1 hm f).trans ((condExp_ae_eq_condExpL1 hm g).trans ?_).symm\n  rw [â† Lp.ext_iff]\n  have hn_eq : âˆ€ n, condExpL1 hm Î¼ (gs n) = condExpL1 hm Î¼ (fs n) := by\n    intro n\n    ext1\n    refine (condExp_ae_eq_condExpL1 hm (gs n)).symm.trans ((hfg n).symm.trans ?_)\n    exact condExp_ae_eq_condExpL1 hm (fs n)\n  have hcond_fs : Tendsto (fun n => condExpL1 hm Î¼ (fs n)) atTop (ğ“ (condExpL1 hm Î¼ f)) :=\n    tendsto_condExpL1_of_dominated_convergence hm _ (fun n => (hfs_int n).1) h_int_bound_fs\n      hfs_bound hfs\n  have hcond_gs : Tendsto (fun n => condExpL1 hm Î¼ (gs n)) atTop (ğ“ (condExpL1 hm Î¼ g)) :=\n    tendsto_condExpL1_of_dominated_convergence hm _ (fun n => (hgs_int n).1) h_int_bound_gs\n      hgs_bound hgs\n  exact tendsto_nhds_unique_of_eventuallyEq hcond_gs hcond_fs (Eventually.of_forall hn_eq)\n\n"}
{"name":"MeasureTheory.tendsto_condexp_unique","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedLatticeAddCommGroup E\ninstâœÂ¹ : CompleteSpace E\ninstâœ : NormedSpace Real E\nfs gs : Nat â†’ Î± â†’ E\nf g : Î± â†’ E\nhfs_int : âˆ€ (n : Nat), MeasureTheory.Integrable (fs n) Î¼\nhgs_int : âˆ€ (n : Nat), MeasureTheory.Integrable (gs n) Î¼\nhfs : Filter.Eventually (fun x => Filter.Tendsto (fun n => fs n x) Filter.atTop (nhds (f x))) (MeasureTheory.ae Î¼)\nhgs : Filter.Eventually (fun x => Filter.Tendsto (fun n => gs n x) Filter.atTop (nhds (g x))) (MeasureTheory.ae Î¼)\nbound_fs : Î± â†’ Real\nh_int_bound_fs : MeasureTheory.Integrable bound_fs Î¼\nbound_gs : Î± â†’ Real\nh_int_bound_gs : MeasureTheory.Integrable bound_gs Î¼\nhfs_bound : âˆ€ (n : Nat), Filter.Eventually (fun x => LE.le (Norm.norm (fs n x)) (bound_fs x)) (MeasureTheory.ae Î¼)\nhgs_bound : âˆ€ (n : Nat), Filter.Eventually (fun x => LE.le (Norm.norm (gs n x)) (bound_gs x)) (MeasureTheory.ae Î¼)\nhfg : âˆ€ (n : Nat), (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ (fs n)) (MeasureTheory.condExp m Î¼ (gs n))\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp m Î¼ f) (MeasureTheory.condExp m Î¼ g)","decl":"@[deprecated (since := \"2025-01-21\")] alias tendsto_condexp_unique := tendsto_condExp_unique\n\n"}
{"name":"MeasureTheory.condExp_mono","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ E\ninstâœÂ³ : NormedLatticeAddCommGroup E\ninstâœÂ² : CompleteSpace E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : OrderedSMul Real E\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î¼\nhfg : (MeasureTheory.ae Î¼).EventuallyLE f g\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyLE (MeasureTheory.condExp m Î¼ f) (MeasureTheory.condExp m Î¼ g)","decl":"lemma condExp_mono (hf : Integrable f Î¼) (hg : Integrable g Î¼) (hfg : f â‰¤áµ[Î¼] g) :\n    Î¼[f|m] â‰¤áµ[Î¼] Î¼[g|m] := by\n  by_cases hm : m â‰¤ mâ‚€\n  swap; Â· simp_rw [condExp_of_not_le hm]; rfl\n  by_cases hÎ¼m : SigmaFinite (Î¼.trim hm)\n  swap; Â· simp_rw [condExp_of_not_sigmaFinite hm hÎ¼m]; rfl\n  exact (condExp_ae_eq_condExpL1 hm _).trans_le\n    ((condExpL1_mono hf hg hfg).trans_eq (condExp_ae_eq_condExpL1 hm _).symm)\n\n"}
{"name":"MeasureTheory.condExp_nonneg","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\ninstâœÂ³ : NormedLatticeAddCommGroup E\ninstâœÂ² : CompleteSpace E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : OrderedSMul Real E\nhf : (MeasureTheory.ae Î¼).EventuallyLE 0 f\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyLE 0 (MeasureTheory.condExp m Î¼ f)","decl":"lemma condExp_nonneg (hf : 0 â‰¤áµ[Î¼] f) : 0 â‰¤áµ[Î¼] Î¼[f|m] := by\n  by_cases hfint : Integrable f Î¼\n  Â· rw [(condExp_zero.symm : (0 : Î± â†’ E) = Î¼[0|m])]\n    exact condExp_mono (integrable_zero _ _ _) hfint hf\n  Â· rw [condExp_of_not_integrable hfint]\n\n"}
{"name":"MeasureTheory.condExp_nonpos","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\ninstâœÂ³ : NormedLatticeAddCommGroup E\ninstâœÂ² : CompleteSpace E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : OrderedSMul Real E\nhf : (MeasureTheory.ae Î¼).EventuallyLE f 0\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyLE (MeasureTheory.condExp m Î¼ f) 0","decl":"lemma condExp_nonpos (hf : f â‰¤áµ[Î¼] 0) : Î¼[f|m] â‰¤áµ[Î¼] 0 := by\n  by_cases hfint : Integrable f Î¼\n  Â· rw [(condExp_zero.symm : (0 : Î± â†’ E) = Î¼[0|m])]\n    exact condExp_mono hfint (integrable_zero _ _ _) hf\n  Â· rw [condExp_of_not_integrable hfint]\n\n"}
{"name":"MeasureTheory.condexp_mono","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ E\ninstâœÂ³ : NormedLatticeAddCommGroup E\ninstâœÂ² : CompleteSpace E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : OrderedSMul Real E\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î¼\nhfg : (MeasureTheory.ae Î¼).EventuallyLE f g\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyLE (MeasureTheory.condExp m Î¼ f) (MeasureTheory.condExp m Î¼ g)","decl":"@[deprecated (since := \"2025-01-21\")] alias condexp_mono := condExp_mono\n"}
{"name":"MeasureTheory.condexp_nonneg","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\ninstâœÂ³ : NormedLatticeAddCommGroup E\ninstâœÂ² : CompleteSpace E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : OrderedSMul Real E\nhf : (MeasureTheory.ae Î¼).EventuallyLE 0 f\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyLE 0 (MeasureTheory.condExp m Î¼ f)","decl":"@[deprecated (since := \"2025-01-21\")] alias condexp_nonneg := condExp_nonneg\n"}
{"name":"MeasureTheory.condexp_nonpos","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic","initialProofState":"Î± : Type u_1\nE : Type u_3\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\ninstâœÂ³ : NormedLatticeAddCommGroup E\ninstâœÂ² : CompleteSpace E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : OrderedSMul Real E\nhf : (MeasureTheory.ae Î¼).EventuallyLE f 0\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyLE (MeasureTheory.condExp m Î¼ f) 0","decl":"@[deprecated (since := \"2025-01-21\")] alias condexp_nonpos := condExp_nonpos\n\n"}
