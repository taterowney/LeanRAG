{"name":"IsLeftCancelMul.mul_left_cancel","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\ninst✝ : Mul G\nself : IsLeftCancelMul G\na b c : G\na✝ : Eq (HMul.hMul a b) (HMul.hMul a c)\n⊢ Eq b c","decl":"/-- A mixin for left cancellative multiplication. -/\nclass IsLeftCancelMul (G : Type u) [Mul G] : Prop where\n  /-- Multiplication is left cancellative. -/\n  protected mul_left_cancel : ∀ a b c : G, a * b = a * c → b = c\n"}
{"name":"IsRightCancelMul.mul_right_cancel","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\ninst✝ : Mul G\nself : IsRightCancelMul G\na b c : G\na✝ : Eq (HMul.hMul a b) (HMul.hMul c b)\n⊢ Eq a c","decl":"/-- A mixin for right cancellative multiplication. -/\nclass IsRightCancelMul (G : Type u) [Mul G] : Prop where\n  /-- Multiplication is right cancellative. -/\n  protected mul_right_cancel : ∀ a b c : G, a * b = c * b → a = c\n"}
{"name":"IsCancelMul.toIsRightCancelMul","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\ninst✝ : Mul G\nself : IsCancelMul G\n⊢ IsRightCancelMul G","decl":"/-- A mixin for cancellative multiplication. -/\nclass IsCancelMul (G : Type u) [Mul G] extends IsLeftCancelMul G, IsRightCancelMul G : Prop\n\n"}
{"name":"IsCancelMul.toIsLeftCancelMul","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\ninst✝ : Mul G\nself : IsCancelMul G\n⊢ IsLeftCancelMul G","decl":"/-- A mixin for cancellative multiplication. -/\nclass IsCancelMul (G : Type u) [Mul G] extends IsLeftCancelMul G, IsRightCancelMul G : Prop\n\n"}
{"name":"IsLeftCancelAdd.add_left_cancel","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\ninst✝ : Add G\nself : IsLeftCancelAdd G\na b c : G\na✝ : Eq (HAdd.hAdd a b) (HAdd.hAdd a c)\n⊢ Eq b c","decl":"/-- A mixin for left cancellative addition. -/\nclass IsLeftCancelAdd (G : Type u) [Add G] : Prop where\n  /-- Addition is left cancellative. -/\n  protected add_left_cancel : ∀ a b c : G, a + b = a + c → b = c\n\n"}
{"name":"IsRightCancelAdd.add_right_cancel","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\ninst✝ : Add G\nself : IsRightCancelAdd G\na b c : G\na✝ : Eq (HAdd.hAdd a b) (HAdd.hAdd c b)\n⊢ Eq a c","decl":"/-- A mixin for right cancellative addition. -/\nclass IsRightCancelAdd (G : Type u) [Add G] : Prop where\n  /-- Addition is right cancellative. -/\n  protected add_right_cancel : ∀ a b c : G, a + b = c + b → a = c\n\n"}
{"name":"IsCancelAdd.toIsRightCancelAdd","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\ninst✝ : Add G\nself : IsCancelAdd G\n⊢ IsRightCancelAdd G","decl":"/-- A mixin for cancellative addition. -/\nclass IsCancelAdd (G : Type u) [Add G] extends IsLeftCancelAdd G, IsRightCancelAdd G : Prop\n\n"}
{"name":"IsCancelAdd.toIsLeftCancelAdd","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\ninst✝ : Add G\nself : IsCancelAdd G\n⊢ IsLeftCancelAdd G","decl":"/-- A mixin for cancellative addition. -/\nclass IsCancelAdd (G : Type u) [Add G] extends IsLeftCancelAdd G, IsRightCancelAdd G : Prop\n\n"}
{"name":"add_left_cancel","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝¹ : Add G\ninst✝ : IsLeftCancelAdd G\na b c : G\na✝ : Eq (HAdd.hAdd a b) (HAdd.hAdd a c)\n⊢ Eq b c","decl":"@[to_additive]\ntheorem mul_left_cancel : a * b = a * c → b = c :=\n  IsLeftCancelMul.mul_left_cancel a b c\n\n"}
{"name":"mul_left_cancel","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝¹ : Mul G\ninst✝ : IsLeftCancelMul G\na b c : G\na✝ : Eq (HMul.hMul a b) (HMul.hMul a c)\n⊢ Eq b c","decl":"@[to_additive]\ntheorem mul_left_cancel : a * b = a * c → b = c :=\n  IsLeftCancelMul.mul_left_cancel a b c\n\n"}
{"name":"mul_left_cancel_iff","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝¹ : Mul G\ninst✝ : IsLeftCancelMul G\na b c : G\n⊢ Iff (Eq (HMul.hMul a b) (HMul.hMul a c)) (Eq b c)","decl":"@[to_additive]\ntheorem mul_left_cancel_iff : a * b = a * c ↔ b = c :=\n  ⟨mul_left_cancel, congrArg _⟩\n\n"}
{"name":"add_left_cancel_iff","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝¹ : Add G\ninst✝ : IsLeftCancelAdd G\na b c : G\n⊢ Iff (Eq (HAdd.hAdd a b) (HAdd.hAdd a c)) (Eq b c)","decl":"@[to_additive]\ntheorem mul_left_cancel_iff : a * b = a * c ↔ b = c :=\n  ⟨mul_left_cancel, congrArg _⟩\n\n"}
{"name":"mul_right_cancel","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝¹ : Mul G\ninst✝ : IsRightCancelMul G\na b c : G\na✝ : Eq (HMul.hMul a b) (HMul.hMul c b)\n⊢ Eq a c","decl":"@[to_additive]\ntheorem mul_right_cancel : a * b = c * b → a = c :=\n  IsRightCancelMul.mul_right_cancel a b c\n\n"}
{"name":"add_right_cancel","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝¹ : Add G\ninst✝ : IsRightCancelAdd G\na b c : G\na✝ : Eq (HAdd.hAdd a b) (HAdd.hAdd c b)\n⊢ Eq a c","decl":"@[to_additive]\ntheorem mul_right_cancel : a * b = c * b → a = c :=\n  IsRightCancelMul.mul_right_cancel a b c\n\n"}
{"name":"mul_right_cancel_iff","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝¹ : Mul G\ninst✝ : IsRightCancelMul G\na b c : G\n⊢ Iff (Eq (HMul.hMul b a) (HMul.hMul c a)) (Eq b c)","decl":"@[to_additive]\ntheorem mul_right_cancel_iff : b * a = c * a ↔ b = c :=\n  ⟨mul_right_cancel, congrArg (· * a)⟩\n\n"}
{"name":"add_right_cancel_iff","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝¹ : Add G\ninst✝ : IsRightCancelAdd G\na b c : G\n⊢ Iff (Eq (HAdd.hAdd b a) (HAdd.hAdd c a)) (Eq b c)","decl":"@[to_additive]\ntheorem mul_right_cancel_iff : b * a = c * a ↔ b = c :=\n  ⟨mul_right_cancel, congrArg (· * a)⟩\n\n"}
{"name":"Semigroup.mul_assoc","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nself : Semigroup G\na b c : G\n⊢ Eq (HMul.hMul (HMul.hMul a b) c) (HMul.hMul a (HMul.hMul b c))","decl":"/-- A semigroup is a type with an associative `(*)`. -/\n@[ext]\nclass Semigroup (G : Type u) extends Mul G where\n  /-- Multiplication is associative -/\n  protected mul_assoc : ∀ a b c : G, a * b * c = a * (b * c)\n\n"}
{"name":"Semigroup.ext","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nx y : Semigroup G\nmul : Eq Mul.mul Mul.mul\n⊢ Eq x y","decl":"/-- A semigroup is a type with an associative `(*)`. -/\n@[ext]\nclass Semigroup (G : Type u) extends Mul G where\n  /-- Multiplication is associative -/\n  protected mul_assoc : ∀ a b c : G, a * b * c = a * (b * c)\n\n"}
{"name":"Semigroup.ext_iff","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nx y : Semigroup G\n⊢ Iff (Eq x y) (Eq Mul.mul Mul.mul)","decl":"/-- A semigroup is a type with an associative `(*)`. -/\n@[ext]\nclass Semigroup (G : Type u) extends Mul G where\n  /-- Multiplication is associative -/\n  protected mul_assoc : ∀ a b c : G, a * b * c = a * (b * c)\n\n"}
{"name":"AddSemigroup.ext_iff","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nx y : AddSemigroup G\n⊢ Iff (Eq x y) (Eq Add.add Add.add)","decl":"/-- An additive semigroup is a type with an associative `(+)`. -/\n@[ext]\nclass AddSemigroup (G : Type u) extends Add G where\n  /-- Addition is associative -/\n  protected add_assoc : ∀ a b c : G, a + b + c = a + (b + c)\n\n"}
{"name":"AddSemigroup.add_assoc","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nself : AddSemigroup G\na b c : G\n⊢ Eq (HAdd.hAdd (HAdd.hAdd a b) c) (HAdd.hAdd a (HAdd.hAdd b c))","decl":"/-- An additive semigroup is a type with an associative `(+)`. -/\n@[ext]\nclass AddSemigroup (G : Type u) extends Add G where\n  /-- Addition is associative -/\n  protected add_assoc : ∀ a b c : G, a + b + c = a + (b + c)\n\n"}
{"name":"AddSemigroup.ext","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nx y : AddSemigroup G\nadd : Eq Add.add Add.add\n⊢ Eq x y","decl":"/-- An additive semigroup is a type with an associative `(+)`. -/\n@[ext]\nclass AddSemigroup (G : Type u) extends Add G where\n  /-- Addition is associative -/\n  protected add_assoc : ∀ a b c : G, a + b + c = a + (b + c)\n\n"}
{"name":"mul_assoc","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : Semigroup G\na b c : G\n⊢ Eq (HMul.hMul (HMul.hMul a b) c) (HMul.hMul a (HMul.hMul b c))","decl":"@[to_additive]\ntheorem mul_assoc : ∀ a b c : G, a * b * c = a * (b * c) :=\n  Semigroup.mul_assoc\n\n"}
{"name":"add_assoc","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : AddSemigroup G\na b c : G\n⊢ Eq (HAdd.hAdd (HAdd.hAdd a b) c) (HAdd.hAdd a (HAdd.hAdd b c))","decl":"@[to_additive]\ntheorem mul_assoc : ∀ a b c : G, a * b * c = a * (b * c) :=\n  Semigroup.mul_assoc\n\n"}
{"name":"AddCommMagma.ext_iff","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nx y : AddCommMagma G\n⊢ Iff (Eq x y) (Eq Add.add Add.add)","decl":"/-- A commutative additive magma is a type with an addition which commutes. -/\n@[ext]\nclass AddCommMagma (G : Type u) extends Add G where\n  /-- Addition is commutative in an commutative additive magma. -/\n  protected add_comm : ∀ a b : G, a + b = b + a\n\n"}
{"name":"AddCommMagma.ext","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nx y : AddCommMagma G\nadd : Eq Add.add Add.add\n⊢ Eq x y","decl":"/-- A commutative additive magma is a type with an addition which commutes. -/\n@[ext]\nclass AddCommMagma (G : Type u) extends Add G where\n  /-- Addition is commutative in an commutative additive magma. -/\n  protected add_comm : ∀ a b : G, a + b = b + a\n\n"}
{"name":"AddCommMagma.add_comm","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nself : AddCommMagma G\na b : G\n⊢ Eq (HAdd.hAdd a b) (HAdd.hAdd b a)","decl":"/-- A commutative additive magma is a type with an addition which commutes. -/\n@[ext]\nclass AddCommMagma (G : Type u) extends Add G where\n  /-- Addition is commutative in an commutative additive magma. -/\n  protected add_comm : ∀ a b : G, a + b = b + a\n\n"}
{"name":"CommMagma.mul_comm","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nself : CommMagma G\na b : G\n⊢ Eq (HMul.hMul a b) (HMul.hMul b a)","decl":"/-- A commutative multiplicative magma is a type with a multiplication which commutes. -/\n@[ext]\nclass CommMagma (G : Type u) extends Mul G where\n  /-- Multiplication is commutative in a commutative multiplicative magma. -/\n  protected mul_comm : ∀ a b : G, a * b = b * a\n\n"}
{"name":"CommMagma.ext_iff","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nx y : CommMagma G\n⊢ Iff (Eq x y) (Eq Mul.mul Mul.mul)","decl":"/-- A commutative multiplicative magma is a type with a multiplication which commutes. -/\n@[ext]\nclass CommMagma (G : Type u) extends Mul G where\n  /-- Multiplication is commutative in a commutative multiplicative magma. -/\n  protected mul_comm : ∀ a b : G, a * b = b * a\n\n"}
{"name":"CommMagma.ext","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nx y : CommMagma G\nmul : Eq Mul.mul Mul.mul\n⊢ Eq x y","decl":"/-- A commutative multiplicative magma is a type with a multiplication which commutes. -/\n@[ext]\nclass CommMagma (G : Type u) extends Mul G where\n  /-- Multiplication is commutative in a commutative multiplicative magma. -/\n  protected mul_comm : ∀ a b : G, a * b = b * a\n\n"}
{"name":"CommSemigroup.ext_iff","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nx y : CommSemigroup G\n⊢ Iff (Eq x y) (Eq Mul.mul Mul.mul)","decl":"/-- A commutative semigroup is a type with an associative commutative `(*)`. -/\n@[ext]\nclass CommSemigroup (G : Type u) extends Semigroup G, CommMagma G where\n\n"}
{"name":"CommSemigroup.mul_comm","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nself : CommSemigroup G\na b : G\n⊢ Eq (HMul.hMul a b) (HMul.hMul b a)","decl":"/-- A commutative semigroup is a type with an associative commutative `(*)`. -/\n@[ext]\nclass CommSemigroup (G : Type u) extends Semigroup G, CommMagma G where\n\n"}
{"name":"CommSemigroup.ext","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nx y : CommSemigroup G\nmul : Eq Mul.mul Mul.mul\n⊢ Eq x y","decl":"/-- A commutative semigroup is a type with an associative commutative `(*)`. -/\n@[ext]\nclass CommSemigroup (G : Type u) extends Semigroup G, CommMagma G where\n\n"}
{"name":"AddCommSemigroup.ext","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nx y : AddCommSemigroup G\nadd : Eq Add.add Add.add\n⊢ Eq x y","decl":"/-- A commutative additive semigroup is a type with an associative commutative `(+)`. -/\n@[ext]\nclass AddCommSemigroup (G : Type u) extends AddSemigroup G, AddCommMagma G where\n\n"}
{"name":"AddCommSemigroup.add_comm","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nself : AddCommSemigroup G\na b : G\n⊢ Eq (HAdd.hAdd a b) (HAdd.hAdd b a)","decl":"/-- A commutative additive semigroup is a type with an associative commutative `(+)`. -/\n@[ext]\nclass AddCommSemigroup (G : Type u) extends AddSemigroup G, AddCommMagma G where\n\n"}
{"name":"AddCommSemigroup.ext_iff","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nx y : AddCommSemigroup G\n⊢ Iff (Eq x y) (Eq Add.add Add.add)","decl":"/-- A commutative additive semigroup is a type with an associative commutative `(+)`. -/\n@[ext]\nclass AddCommSemigroup (G : Type u) extends AddSemigroup G, AddCommMagma G where\n\n"}
{"name":"mul_comm","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : CommMagma G\na b : G\n⊢ Eq (HMul.hMul a b) (HMul.hMul b a)","decl":"@[to_additive]\ntheorem mul_comm : ∀ a b : G, a * b = b * a := CommMagma.mul_comm\n\n"}
{"name":"add_comm","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : AddCommMagma G\na b : G\n⊢ Eq (HAdd.hAdd a b) (HAdd.hAdd b a)","decl":"@[to_additive]\ntheorem mul_comm : ∀ a b : G, a * b = b * a := CommMagma.mul_comm\n\n"}
{"name":"CommMagma.IsRightCancelMul.toIsLeftCancelMul","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\ninst✝¹ : CommMagma G\ninst✝ : IsRightCancelMul G\n⊢ IsLeftCancelMul G","decl":"/-- Any `CommMagma G` that satisfies `IsRightCancelMul G` also satisfies `IsLeftCancelMul G`. -/\n@[to_additive AddCommMagma.IsRightCancelAdd.toIsLeftCancelAdd \"Any `AddCommMagma G` that satisfies\n`IsRightCancelAdd G` also satisfies `IsLeftCancelAdd G`.\"]\nlemma CommMagma.IsRightCancelMul.toIsLeftCancelMul (G : Type u) [CommMagma G] [IsRightCancelMul G] :\n    IsLeftCancelMul G :=\n  ⟨fun _ _ _ h => mul_right_cancel <| (mul_comm _ _).trans (h.trans (mul_comm _ _))⟩\n\n"}
{"name":"AddCommMagma.IsRightCancelAdd.toIsLeftCancelAdd","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\ninst✝¹ : AddCommMagma G\ninst✝ : IsRightCancelAdd G\n⊢ IsLeftCancelAdd G","decl":"/-- Any `CommMagma G` that satisfies `IsRightCancelMul G` also satisfies `IsLeftCancelMul G`. -/\n@[to_additive AddCommMagma.IsRightCancelAdd.toIsLeftCancelAdd \"Any `AddCommMagma G` that satisfies\n`IsRightCancelAdd G` also satisfies `IsLeftCancelAdd G`.\"]\nlemma CommMagma.IsRightCancelMul.toIsLeftCancelMul (G : Type u) [CommMagma G] [IsRightCancelMul G] :\n    IsLeftCancelMul G :=\n  ⟨fun _ _ _ h => mul_right_cancel <| (mul_comm _ _).trans (h.trans (mul_comm _ _))⟩\n\n"}
{"name":"CommMagma.IsLeftCancelMul.toIsRightCancelMul","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\ninst✝¹ : CommMagma G\ninst✝ : IsLeftCancelMul G\n⊢ IsRightCancelMul G","decl":"/-- Any `CommMagma G` that satisfies `IsLeftCancelMul G` also satisfies `IsRightCancelMul G`. -/\n@[to_additive AddCommMagma.IsLeftCancelAdd.toIsRightCancelAdd \"Any `AddCommMagma G` that satisfies\n`IsLeftCancelAdd G` also satisfies `IsRightCancelAdd G`.\"]\nlemma CommMagma.IsLeftCancelMul.toIsRightCancelMul (G : Type u) [CommMagma G] [IsLeftCancelMul G] :\n    IsRightCancelMul G :=\n  ⟨fun _ _ _ h => mul_left_cancel <| (mul_comm _ _).trans (h.trans (mul_comm _ _))⟩\n\n"}
{"name":"AddCommMagma.IsLeftCancelAdd.toIsRightCancelAdd","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\ninst✝¹ : AddCommMagma G\ninst✝ : IsLeftCancelAdd G\n⊢ IsRightCancelAdd G","decl":"/-- Any `CommMagma G` that satisfies `IsLeftCancelMul G` also satisfies `IsRightCancelMul G`. -/\n@[to_additive AddCommMagma.IsLeftCancelAdd.toIsRightCancelAdd \"Any `AddCommMagma G` that satisfies\n`IsLeftCancelAdd G` also satisfies `IsRightCancelAdd G`.\"]\nlemma CommMagma.IsLeftCancelMul.toIsRightCancelMul (G : Type u) [CommMagma G] [IsLeftCancelMul G] :\n    IsRightCancelMul G :=\n  ⟨fun _ _ _ h => mul_left_cancel <| (mul_comm _ _).trans (h.trans (mul_comm _ _))⟩\n\n"}
{"name":"AddCommMagma.IsLeftCancelAdd.toIsCancelAdd","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\ninst✝¹ : AddCommMagma G\ninst✝ : IsLeftCancelAdd G\n⊢ IsCancelAdd G","decl":"/-- Any `CommMagma G` that satisfies `IsLeftCancelMul G` also satisfies `IsCancelMul G`. -/\n@[to_additive AddCommMagma.IsLeftCancelAdd.toIsCancelAdd \"Any `AddCommMagma G` that satisfies\n`IsLeftCancelAdd G` also satisfies `IsCancelAdd G`.\"]\nlemma CommMagma.IsLeftCancelMul.toIsCancelMul (G : Type u) [CommMagma G] [IsLeftCancelMul G] :\n    IsCancelMul G := { CommMagma.IsLeftCancelMul.toIsRightCancelMul G with }\n\n"}
{"name":"CommMagma.IsLeftCancelMul.toIsCancelMul","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\ninst✝¹ : CommMagma G\ninst✝ : IsLeftCancelMul G\n⊢ IsCancelMul G","decl":"/-- Any `CommMagma G` that satisfies `IsLeftCancelMul G` also satisfies `IsCancelMul G`. -/\n@[to_additive AddCommMagma.IsLeftCancelAdd.toIsCancelAdd \"Any `AddCommMagma G` that satisfies\n`IsLeftCancelAdd G` also satisfies `IsCancelAdd G`.\"]\nlemma CommMagma.IsLeftCancelMul.toIsCancelMul (G : Type u) [CommMagma G] [IsLeftCancelMul G] :\n    IsCancelMul G := { CommMagma.IsLeftCancelMul.toIsRightCancelMul G with }\n\n"}
{"name":"AddCommMagma.IsRightCancelAdd.toIsCancelAdd","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\ninst✝¹ : AddCommMagma G\ninst✝ : IsRightCancelAdd G\n⊢ IsCancelAdd G","decl":"/-- Any `CommMagma G` that satisfies `IsRightCancelMul G` also satisfies `IsCancelMul G`. -/\n@[to_additive AddCommMagma.IsRightCancelAdd.toIsCancelAdd \"Any `AddCommMagma G` that satisfies\n`IsRightCancelAdd G` also satisfies `IsCancelAdd G`.\"]\nlemma CommMagma.IsRightCancelMul.toIsCancelMul (G : Type u) [CommMagma G] [IsRightCancelMul G] :\n    IsCancelMul G := { CommMagma.IsRightCancelMul.toIsLeftCancelMul G with }\n\n"}
{"name":"CommMagma.IsRightCancelMul.toIsCancelMul","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\ninst✝¹ : CommMagma G\ninst✝ : IsRightCancelMul G\n⊢ IsCancelMul G","decl":"/-- Any `CommMagma G` that satisfies `IsRightCancelMul G` also satisfies `IsCancelMul G`. -/\n@[to_additive AddCommMagma.IsRightCancelAdd.toIsCancelAdd \"Any `AddCommMagma G` that satisfies\n`IsRightCancelAdd G` also satisfies `IsCancelAdd G`.\"]\nlemma CommMagma.IsRightCancelMul.toIsCancelMul (G : Type u) [CommMagma G] [IsRightCancelMul G] :\n    IsCancelMul G := { CommMagma.IsRightCancelMul.toIsLeftCancelMul G with }\n\n"}
{"name":"LeftCancelSemigroup.ext","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nx y : LeftCancelSemigroup G\nmul : Eq Mul.mul Mul.mul\n⊢ Eq x y","decl":"/-- A `LeftCancelSemigroup` is a semigroup such that `a * b = a * c` implies `b = c`. -/\n@[ext]\nclass LeftCancelSemigroup (G : Type u) extends Semigroup G where\n  protected mul_left_cancel : ∀ a b c : G, a * b = a * c → b = c\n\n"}
{"name":"LeftCancelSemigroup.ext_iff","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nx y : LeftCancelSemigroup G\n⊢ Iff (Eq x y) (Eq Mul.mul Mul.mul)","decl":"/-- A `LeftCancelSemigroup` is a semigroup such that `a * b = a * c` implies `b = c`. -/\n@[ext]\nclass LeftCancelSemigroup (G : Type u) extends Semigroup G where\n  protected mul_left_cancel : ∀ a b c : G, a * b = a * c → b = c\n\n"}
{"name":"LeftCancelSemigroup.mul_left_cancel","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nself : LeftCancelSemigroup G\na b c : G\na✝ : Eq (HMul.hMul a b) (HMul.hMul a c)\n⊢ Eq b c","decl":"/-- A `LeftCancelSemigroup` is a semigroup such that `a * b = a * c` implies `b = c`. -/\n@[ext]\nclass LeftCancelSemigroup (G : Type u) extends Semigroup G where\n  protected mul_left_cancel : ∀ a b c : G, a * b = a * c → b = c\n\n"}
{"name":"AddLeftCancelSemigroup.ext_iff","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nx y : AddLeftCancelSemigroup G\n⊢ Iff (Eq x y) (Eq Add.add Add.add)","decl":"/-- An `AddLeftCancelSemigroup` is an additive semigroup such that\n`a + b = a + c` implies `b = c`. -/\n@[ext]\nclass AddLeftCancelSemigroup (G : Type u) extends AddSemigroup G where\n  protected add_left_cancel : ∀ a b c : G, a + b = a + c → b = c\n\n"}
{"name":"AddLeftCancelSemigroup.ext","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nx y : AddLeftCancelSemigroup G\nadd : Eq Add.add Add.add\n⊢ Eq x y","decl":"/-- An `AddLeftCancelSemigroup` is an additive semigroup such that\n`a + b = a + c` implies `b = c`. -/\n@[ext]\nclass AddLeftCancelSemigroup (G : Type u) extends AddSemigroup G where\n  protected add_left_cancel : ∀ a b c : G, a + b = a + c → b = c\n\n"}
{"name":"AddLeftCancelSemigroup.add_left_cancel","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nself : AddLeftCancelSemigroup G\na b c : G\na✝ : Eq (HAdd.hAdd a b) (HAdd.hAdd a c)\n⊢ Eq b c","decl":"/-- An `AddLeftCancelSemigroup` is an additive semigroup such that\n`a + b = a + c` implies `b = c`. -/\n@[ext]\nclass AddLeftCancelSemigroup (G : Type u) extends AddSemigroup G where\n  protected add_left_cancel : ∀ a b c : G, a + b = a + c → b = c\n\n"}
{"name":"AddLeftCancelSemigroup.toIsLeftCancelAdd","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\ninst✝ : AddLeftCancelSemigroup G\n⊢ IsLeftCancelAdd G","decl":"/-- Any `LeftCancelSemigroup` satisfies `IsLeftCancelMul`. -/\n@[to_additive AddLeftCancelSemigroup.toIsLeftCancelAdd \"Any `AddLeftCancelSemigroup` satisfies\n`IsLeftCancelAdd`.\"]\ninstance (priority := 100) LeftCancelSemigroup.toIsLeftCancelMul (G : Type u)\n    [LeftCancelSemigroup G] : IsLeftCancelMul G :=\n  { mul_left_cancel := LeftCancelSemigroup.mul_left_cancel }\n\n"}
{"name":"LeftCancelSemigroup.toIsLeftCancelMul","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\ninst✝ : LeftCancelSemigroup G\n⊢ IsLeftCancelMul G","decl":"/-- Any `LeftCancelSemigroup` satisfies `IsLeftCancelMul`. -/\n@[to_additive AddLeftCancelSemigroup.toIsLeftCancelAdd \"Any `AddLeftCancelSemigroup` satisfies\n`IsLeftCancelAdd`.\"]\ninstance (priority := 100) LeftCancelSemigroup.toIsLeftCancelMul (G : Type u)\n    [LeftCancelSemigroup G] : IsLeftCancelMul G :=\n  { mul_left_cancel := LeftCancelSemigroup.mul_left_cancel }\n\n"}
{"name":"RightCancelSemigroup.mul_right_cancel","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nself : RightCancelSemigroup G\na b c : G\na✝ : Eq (HMul.hMul a b) (HMul.hMul c b)\n⊢ Eq a c","decl":"/-- A `RightCancelSemigroup` is a semigroup such that `a * b = c * b` implies `a = c`. -/\n@[ext]\nclass RightCancelSemigroup (G : Type u) extends Semigroup G where\n  protected mul_right_cancel : ∀ a b c : G, a * b = c * b → a = c\n\n"}
{"name":"RightCancelSemigroup.ext_iff","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nx y : RightCancelSemigroup G\n⊢ Iff (Eq x y) (Eq Mul.mul Mul.mul)","decl":"/-- A `RightCancelSemigroup` is a semigroup such that `a * b = c * b` implies `a = c`. -/\n@[ext]\nclass RightCancelSemigroup (G : Type u) extends Semigroup G where\n  protected mul_right_cancel : ∀ a b c : G, a * b = c * b → a = c\n\n"}
{"name":"RightCancelSemigroup.ext","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nx y : RightCancelSemigroup G\nmul : Eq Mul.mul Mul.mul\n⊢ Eq x y","decl":"/-- A `RightCancelSemigroup` is a semigroup such that `a * b = c * b` implies `a = c`. -/\n@[ext]\nclass RightCancelSemigroup (G : Type u) extends Semigroup G where\n  protected mul_right_cancel : ∀ a b c : G, a * b = c * b → a = c\n\n"}
{"name":"AddRightCancelSemigroup.ext","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nx y : AddRightCancelSemigroup G\nadd : Eq Add.add Add.add\n⊢ Eq x y","decl":"/-- An `AddRightCancelSemigroup` is an additive semigroup such that\n`a + b = c + b` implies `a = c`. -/\n@[ext]\nclass AddRightCancelSemigroup (G : Type u) extends AddSemigroup G where\n  protected add_right_cancel : ∀ a b c : G, a + b = c + b → a = c\n\n"}
{"name":"AddRightCancelSemigroup.add_right_cancel","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nself : AddRightCancelSemigroup G\na b c : G\na✝ : Eq (HAdd.hAdd a b) (HAdd.hAdd c b)\n⊢ Eq a c","decl":"/-- An `AddRightCancelSemigroup` is an additive semigroup such that\n`a + b = c + b` implies `a = c`. -/\n@[ext]\nclass AddRightCancelSemigroup (G : Type u) extends AddSemigroup G where\n  protected add_right_cancel : ∀ a b c : G, a + b = c + b → a = c\n\n"}
{"name":"AddRightCancelSemigroup.ext_iff","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nx y : AddRightCancelSemigroup G\n⊢ Iff (Eq x y) (Eq Add.add Add.add)","decl":"/-- An `AddRightCancelSemigroup` is an additive semigroup such that\n`a + b = c + b` implies `a = c`. -/\n@[ext]\nclass AddRightCancelSemigroup (G : Type u) extends AddSemigroup G where\n  protected add_right_cancel : ∀ a b c : G, a + b = c + b → a = c\n\n"}
{"name":"AddRightCancelSemigroup.toIsRightCancelAdd","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\ninst✝ : AddRightCancelSemigroup G\n⊢ IsRightCancelAdd G","decl":"/-- Any `RightCancelSemigroup` satisfies `IsRightCancelMul`. -/\n@[to_additive AddRightCancelSemigroup.toIsRightCancelAdd \"Any `AddRightCancelSemigroup` satisfies\n`IsRightCancelAdd`.\"]\ninstance (priority := 100) RightCancelSemigroup.toIsRightCancelMul (G : Type u)\n    [RightCancelSemigroup G] : IsRightCancelMul G :=\n  { mul_right_cancel := RightCancelSemigroup.mul_right_cancel }\n\n"}
{"name":"RightCancelSemigroup.toIsRightCancelMul","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\ninst✝ : RightCancelSemigroup G\n⊢ IsRightCancelMul G","decl":"/-- Any `RightCancelSemigroup` satisfies `IsRightCancelMul`. -/\n@[to_additive AddRightCancelSemigroup.toIsRightCancelAdd \"Any `AddRightCancelSemigroup` satisfies\n`IsRightCancelAdd`.\"]\ninstance (priority := 100) RightCancelSemigroup.toIsRightCancelMul (G : Type u)\n    [RightCancelSemigroup G] : IsRightCancelMul G :=\n  { mul_right_cancel := RightCancelSemigroup.mul_right_cancel }\n\n"}
{"name":"MulOneClass.one_mul","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\nself : MulOneClass M\na : M\n⊢ Eq (HMul.hMul 1 a) a","decl":"/-- Typeclass for expressing that a type `M` with multiplication and a one satisfies\n`1 * a = a` and `a * 1 = a` for all `a : M`. -/\nclass MulOneClass (M : Type u) extends One M, Mul M where\n  /-- One is a left neutral element for multiplication -/\n  protected one_mul : ∀ a : M, 1 * a = a\n  /-- One is a right neutral element for multiplication -/\n  protected mul_one : ∀ a : M, a * 1 = a\n\n"}
{"name":"MulOneClass.mul_one","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\nself : MulOneClass M\na : M\n⊢ Eq (HMul.hMul a 1) a","decl":"/-- Typeclass for expressing that a type `M` with multiplication and a one satisfies\n`1 * a = a` and `a * 1 = a` for all `a : M`. -/\nclass MulOneClass (M : Type u) extends One M, Mul M where\n  /-- One is a left neutral element for multiplication -/\n  protected one_mul : ∀ a : M, 1 * a = a\n  /-- One is a right neutral element for multiplication -/\n  protected mul_one : ∀ a : M, a * 1 = a\n\n"}
{"name":"AddZeroClass.add_zero","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\nself : AddZeroClass M\na : M\n⊢ Eq (HAdd.hAdd a 0) a","decl":"/-- Typeclass for expressing that a type `M` with addition and a zero satisfies\n`0 + a = a` and `a + 0 = a` for all `a : M`. -/\nclass AddZeroClass (M : Type u) extends Zero M, Add M where\n  /-- Zero is a left neutral element for addition -/\n  protected zero_add : ∀ a : M, 0 + a = a\n  /-- Zero is a right neutral element for addition -/\n  protected add_zero : ∀ a : M, a + 0 = a\n\n"}
{"name":"AddZeroClass.zero_add","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\nself : AddZeroClass M\na : M\n⊢ Eq (HAdd.hAdd 0 a) a","decl":"/-- Typeclass for expressing that a type `M` with addition and a zero satisfies\n`0 + a = a` and `a + 0 = a` for all `a : M`. -/\nclass AddZeroClass (M : Type u) extends Zero M, Add M where\n  /-- Zero is a left neutral element for addition -/\n  protected zero_add : ∀ a : M, 0 + a = a\n  /-- Zero is a right neutral element for addition -/\n  protected add_zero : ∀ a : M, a + 0 = a\n\n"}
{"name":"MulOneClass.ext","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\nm₁ m₂ : MulOneClass M\na✝ : Eq Mul.mul Mul.mul\n⊢ Eq m₁ m₂","decl":"@[to_additive (attr := ext)]\ntheorem MulOneClass.ext {M : Type u} : ∀ ⦃m₁ m₂ : MulOneClass M⦄, m₁.mul = m₂.mul → m₁ = m₂ := by\n  rintro @⟨⟨one₁⟩, ⟨mul₁⟩, one_mul₁, mul_one₁⟩ @⟨⟨one₂⟩, ⟨mul₂⟩, one_mul₂, mul_one₂⟩ ⟨rfl⟩\n  -- FIXME (See https://github.com/leanprover/lean4/issues/1711)\n  -- congr\n  suffices one₁ = one₂ by cases this; rfl\n  exact (one_mul₂ one₁).symm.trans (mul_one₁ one₂)\n\n"}
{"name":"AddZeroClass.ext","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\nm₁ m₂ : AddZeroClass M\na✝ : Eq Add.add Add.add\n⊢ Eq m₁ m₂","decl":"@[to_additive (attr := ext)]\ntheorem MulOneClass.ext {M : Type u} : ∀ ⦃m₁ m₂ : MulOneClass M⦄, m₁.mul = m₂.mul → m₁ = m₂ := by\n  rintro @⟨⟨one₁⟩, ⟨mul₁⟩, one_mul₁, mul_one₁⟩ @⟨⟨one₂⟩, ⟨mul₂⟩, one_mul₂, mul_one₂⟩ ⟨rfl⟩\n  -- FIXME (See https://github.com/leanprover/lean4/issues/1711)\n  -- congr\n  suffices one₁ = one₂ by cases this; rfl\n  exact (one_mul₂ one₁).symm.trans (mul_one₁ one₂)\n\n"}
{"name":"MulOneClass.ext_iff","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\nm₁ m₂ : MulOneClass M\n⊢ Iff (Eq m₁ m₂) (Eq Mul.mul Mul.mul)","decl":"@[to_additive (attr := ext)]\ntheorem MulOneClass.ext {M : Type u} : ∀ ⦃m₁ m₂ : MulOneClass M⦄, m₁.mul = m₂.mul → m₁ = m₂ := by\n  rintro @⟨⟨one₁⟩, ⟨mul₁⟩, one_mul₁, mul_one₁⟩ @⟨⟨one₂⟩, ⟨mul₂⟩, one_mul₂, mul_one₂⟩ ⟨rfl⟩\n  -- FIXME (See https://github.com/leanprover/lean4/issues/1711)\n  -- congr\n  suffices one₁ = one₂ by cases this; rfl\n  exact (one_mul₂ one₁).symm.trans (mul_one₁ one₂)\n\n"}
{"name":"AddZeroClass.ext_iff","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\nm₁ m₂ : AddZeroClass M\n⊢ Iff (Eq m₁ m₂) (Eq Add.add Add.add)","decl":"@[to_additive (attr := ext)]\ntheorem MulOneClass.ext {M : Type u} : ∀ ⦃m₁ m₂ : MulOneClass M⦄, m₁.mul = m₂.mul → m₁ = m₂ := by\n  rintro @⟨⟨one₁⟩, ⟨mul₁⟩, one_mul₁, mul_one₁⟩ @⟨⟨one₂⟩, ⟨mul₂⟩, one_mul₂, mul_one₂⟩ ⟨rfl⟩\n  -- FIXME (See https://github.com/leanprover/lean4/issues/1711)\n  -- congr\n  suffices one₁ = one₂ by cases this; rfl\n  exact (one_mul₂ one₁).symm.trans (mul_one₁ one₂)\n\n"}
{"name":"one_mul","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\ninst✝ : MulOneClass M\na : M\n⊢ Eq (HMul.hMul 1 a) a","decl":"@[to_additive (attr := simp)]\ntheorem one_mul : ∀ a : M, 1 * a = a :=\n  MulOneClass.one_mul\n\n"}
{"name":"zero_add","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\ninst✝ : AddZeroClass M\na : M\n⊢ Eq (HAdd.hAdd 0 a) a","decl":"@[to_additive (attr := simp)]\ntheorem one_mul : ∀ a : M, 1 * a = a :=\n  MulOneClass.one_mul\n\n"}
{"name":"add_zero","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\ninst✝ : AddZeroClass M\na : M\n⊢ Eq (HAdd.hAdd a 0) a","decl":"@[to_additive (attr := simp)]\ntheorem mul_one : ∀ a : M, a * 1 = a :=\n  MulOneClass.mul_one\n\n"}
{"name":"mul_one","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\ninst✝ : MulOneClass M\na : M\n⊢ Eq (HMul.hMul a 1) a","decl":"@[to_additive (attr := simp)]\ntheorem mul_one : ∀ a : M, a * 1 = a :=\n  MulOneClass.mul_one\n\n"}
{"name":"nsmulRec_add","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\ninst✝¹ : Zero M\ninst✝ : AddSemigroup M\nm n : Nat\nhn : Ne n 0\na : M\nha : Eq (HAdd.hAdd 0 a) a\n⊢ Eq (nsmulRec (HAdd.hAdd m n) a) (HAdd.hAdd (nsmulRec m a) (nsmulRec n a))","decl":"@[to_additive] theorem npowRec_add : npowRec (m + n) a = npowRec m a * npowRec n a := by\n  obtain _ | n := n; · exact (hn rfl).elim\n  induction n with\n  | zero => simp only [Nat.zero_add, npowRec, ha]\n  | succ n ih => rw [← Nat.add_assoc, npowRec, ih n.succ_ne_zero]; simp only [npowRec, mul_assoc]\n\n"}
{"name":"npowRec_add","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\ninst✝¹ : One M\ninst✝ : Semigroup M\nm n : Nat\nhn : Ne n 0\na : M\nha : Eq (HMul.hMul 1 a) a\n⊢ Eq (npowRec (HAdd.hAdd m n) a) (HMul.hMul (npowRec m a) (npowRec n a))","decl":"@[to_additive] theorem npowRec_add : npowRec (m + n) a = npowRec m a * npowRec n a := by\n  obtain _ | n := n; · exact (hn rfl).elim\n  induction n with\n  | zero => simp only [Nat.zero_add, npowRec, ha]\n  | succ n ih => rw [← Nat.add_assoc, npowRec, ih n.succ_ne_zero]; simp only [npowRec, mul_assoc]\n\n"}
{"name":"nsmulRec_succ","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\ninst✝¹ : Zero M\ninst✝ : AddSemigroup M\nn : Nat\nhn : Ne n 0\na : M\nha : Eq (HAdd.hAdd 0 a) a\n⊢ Eq (nsmulRec (HAdd.hAdd n 1) a) (HAdd.hAdd a (nsmulRec n a))","decl":"@[to_additive] theorem npowRec_succ : npowRec (n + 1) a = a * npowRec n a := by\n  rw [Nat.add_comm, npowRec_add 1 n hn a ha, npowRec, npowRec, ha]\n\n"}
{"name":"npowRec_succ","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\ninst✝¹ : One M\ninst✝ : Semigroup M\nn : Nat\nhn : Ne n 0\na : M\nha : Eq (HMul.hMul 1 a) a\n⊢ Eq (npowRec (HAdd.hAdd n 1) a) (HMul.hMul a (npowRec n a))","decl":"@[to_additive] theorem npowRec_succ : npowRec (n + 1) a = a * npowRec n a := by\n  rw [Nat.add_comm, npowRec_add 1 n hn a ha, npowRec, npowRec, ha]\n\n"}
{"name":"npowRec'_succ","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝¹ : Semigroup M\ninst✝ : One M\nk : Nat\nx✝ : Ne k 0\nm : M\n⊢ Eq (npowRec' (HAdd.hAdd k 1) m) (HMul.hMul (npowRec' k m) m)","decl":"@[to_additive]\ntheorem npowRec'_succ {M : Type*} [Semigroup M] [One M] {k : ℕ} (_ : k ≠ 0) (m : M) :\n    npowRec' (k + 1) m = npowRec' k m * m :=\n  match k with\n  | _ + 1 => rfl\n\n"}
{"name":"nsmulRec'_succ","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝¹ : AddSemigroup M\ninst✝ : Zero M\nk : Nat\nx✝ : Ne k 0\nm : M\n⊢ Eq (nsmulRec' (HAdd.hAdd k 1) m) (HAdd.hAdd (nsmulRec' k m) m)","decl":"@[to_additive]\ntheorem npowRec'_succ {M : Type*} [Semigroup M] [One M] {k : ℕ} (_ : k ≠ 0) (m : M) :\n    npowRec' (k + 1) m = npowRec' k m * m :=\n  match k with\n  | _ + 1 => rfl\n\n"}
{"name":"nsmulRec'_two_add","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝¹ : AddSemigroup M\ninst✝ : Zero M\nk : Nat\nm : M\n⊢ Eq (nsmulRec' (HMul.hMul 2 k) m) (nsmulRec' k (HAdd.hAdd m m))","decl":"@[to_additive]\ntheorem npowRec'_two_mul {M : Type*} [Semigroup M] [One M] (k : ℕ) (m : M) :\n    npowRec' (2 * k) m = npowRec' k (m * m) := by\n  induction k using Nat.strongRecOn with\n  | ind k' ih =>\n    match k' with\n    | 0 => rfl\n    | 1 => simp [npowRec']\n    | k + 2 => simp [npowRec', ← mul_assoc, Nat.mul_add, ← ih]\n\n"}
{"name":"npowRec'_two_mul","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝¹ : Semigroup M\ninst✝ : One M\nk : Nat\nm : M\n⊢ Eq (npowRec' (HMul.hMul 2 k) m) (npowRec' k (HMul.hMul m m))","decl":"@[to_additive]\ntheorem npowRec'_two_mul {M : Type*} [Semigroup M] [One M] (k : ℕ) (m : M) :\n    npowRec' (2 * k) m = npowRec' k (m * m) := by\n  induction k using Nat.strongRecOn with\n  | ind k' ih =>\n    match k' with\n    | 0 => rfl\n    | 1 => simp [npowRec']\n    | k + 2 => simp [npowRec', ← mul_assoc, Nat.mul_add, ← ih]\n\n"}
{"name":"nsmulRec'_add_comm","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝¹ : AddSemigroup M\ninst✝ : Zero M\nk : Nat\nk0 : Ne k 0\nm : M\n⊢ Eq (HAdd.hAdd m (nsmulRec' k m)) (HAdd.hAdd (nsmulRec' k m) m)","decl":"@[to_additive]\ntheorem npowRec'_mul_comm {M : Type*} [Semigroup M] [One M] {k : ℕ} (k0 : k ≠ 0) (m : M) :\n    m * npowRec' k m = npowRec' k m * m := by\n  induction k using Nat.strongRecOn with\n  | ind k' ih =>\n    match k' with\n    | 1 => simp [npowRec', mul_assoc]\n    | k + 2 => simp [npowRec', ← mul_assoc, ih]\n\n"}
{"name":"npowRec'_mul_comm","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝¹ : Semigroup M\ninst✝ : One M\nk : Nat\nk0 : Ne k 0\nm : M\n⊢ Eq (HMul.hMul m (npowRec' k m)) (HMul.hMul (npowRec' k m) m)","decl":"@[to_additive]\ntheorem npowRec'_mul_comm {M : Type*} [Semigroup M] [One M] {k : ℕ} (k0 : k ≠ 0) (m : M) :\n    m * npowRec' k m = npowRec' k m * m := by\n  induction k using Nat.strongRecOn with\n  | ind k' ih =>\n    match k' with\n    | 1 => simp [npowRec', mul_assoc]\n    | k + 2 => simp [npowRec', ← mul_assoc, ih]\n\n"}
{"name":"nsmulRec_eq","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝¹ : AddSemigroup M\ninst✝ : Zero M\nk : Nat\nm : M\n⊢ Eq (nsmulRec (HAdd.hAdd k 1) m) (HAdd.hAdd 0 (nsmulRec' (HAdd.hAdd k 1) m))","decl":"@[to_additive]\ntheorem npowRec_eq {M : Type*} [Semigroup M] [One M] (k : ℕ) (m : M) :\n    npowRec (k + 1) m = 1 * npowRec' (k + 1) m := by\n  induction k using Nat.strongRecOn with\n  | ind k' ih =>\n    match k' with\n    | 0 => rfl\n    | k + 1 =>\n      rw [npowRec, npowRec'_succ k.succ_ne_zero, ← mul_assoc]\n      congr\n      simp [ih]\n\n"}
{"name":"npowRec_eq","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝¹ : Semigroup M\ninst✝ : One M\nk : Nat\nm : M\n⊢ Eq (npowRec (HAdd.hAdd k 1) m) (HMul.hMul 1 (npowRec' (HAdd.hAdd k 1) m))","decl":"@[to_additive]\ntheorem npowRec_eq {M : Type*} [Semigroup M] [One M] (k : ℕ) (m : M) :\n    npowRec (k + 1) m = 1 * npowRec' (k + 1) m := by\n  induction k using Nat.strongRecOn with\n  | ind k' ih =>\n    match k' with\n    | 0 => rfl\n    | k + 1 =>\n      rw [npowRec, npowRec'_succ k.succ_ne_zero, ← mul_assoc]\n      congr\n      simp [ih]\n\n"}
{"name":"npowBinRec.go_spec","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝¹ : Semigroup M\ninst✝ : One M\nk : Nat\nm n : M\n⊢ Eq (npowBinRec.go (HAdd.hAdd k 1) m n) (HMul.hMul m (npowRec' (HAdd.hAdd k 1) n))","decl":"@[to_additive]\ntheorem npowBinRec.go_spec {M : Type*} [Semigroup M] [One M] (k : ℕ) (m n : M) :\n    npowBinRec.go (k + 1) m n = m * npowRec' (k + 1) n := by\n  unfold go\n  generalize hk : k + 1 = k'\n  replace hk : k' ≠ 0 := by omega\n  induction k' using Nat.binaryRecFromOne generalizing n m with\n  | z₀ => simp at hk\n  | z₁ => simp [npowRec']\n  | f b k' k'0 ih =>\n    rw [Nat.binaryRec_eq _ _ (Or.inl rfl), ih _ _ k'0]\n    cases b <;> simp only [Nat.bit, cond_false, cond_true, ← Nat.two_mul, npowRec'_two_mul]\n    rw [npowRec'_succ (by omega), npowRec'_two_mul, ← npowRec'_two_mul,\n      ← npowRec'_mul_comm (by omega), mul_assoc]\n\n"}
{"name":"nsmulBinRec.go_spec","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝¹ : AddSemigroup M\ninst✝ : Zero M\nk : Nat\nm n : M\n⊢ Eq (nsmulBinRec.go (HAdd.hAdd k 1) m n) (HAdd.hAdd m (nsmulRec' (HAdd.hAdd k 1) n))","decl":"@[to_additive]\ntheorem npowBinRec.go_spec {M : Type*} [Semigroup M] [One M] (k : ℕ) (m n : M) :\n    npowBinRec.go (k + 1) m n = m * npowRec' (k + 1) n := by\n  unfold go\n  generalize hk : k + 1 = k'\n  replace hk : k' ≠ 0 := by omega\n  induction k' using Nat.binaryRecFromOne generalizing n m with\n  | z₀ => simp at hk\n  | z₁ => simp [npowRec']\n  | f b k' k'0 ih =>\n    rw [Nat.binaryRec_eq _ _ (Or.inl rfl), ih _ _ k'0]\n    cases b <;> simp only [Nat.bit, cond_false, cond_true, ← Nat.two_mul, npowRec'_two_mul]\n    rw [npowRec'_succ (by omega), npowRec'_two_mul, ← npowRec'_two_mul,\n      ← npowRec'_mul_comm (by omega), mul_assoc]\n\n"}
{"name":"npowRec_eq_npowBinRec","module":"Mathlib.Algebra.Group.Defs","initialProofState":"⊢ Eq @npowRecAuto @npowBinRecAuto","decl":"@[to_additive (attr := csimp)]\ntheorem npowRec_eq_npowBinRec : @npowRecAuto = @npowBinRecAuto := by\n  funext M _ _ k m\n  rw [npowBinRecAuto, npowRecAuto, npowBinRec]\n  match k with\n  | 0 => rw [npowRec, npowBinRec.go, Nat.binaryRec_zero]\n  | k + 1 => rw [npowBinRec.go_spec, npowRec_eq]\n\n"}
{"name":"nsmulRec_eq_nsmulBinRec","module":"Mathlib.Algebra.Group.Defs","initialProofState":"⊢ Eq @nsmulRecAuto @nsmulBinRecAuto","decl":"@[to_additive (attr := csimp)]\ntheorem npowRec_eq_npowBinRec : @npowRecAuto = @npowBinRecAuto := by\n  funext M _ _ k m\n  rw [npowBinRecAuto, npowRecAuto, npowBinRec]\n  match k with\n  | 0 => rw [npowRec, npowBinRec.go, Nat.binaryRec_zero]\n  | k + 1 => rw [npowBinRec.go_spec, npowRec_eq]\n\n"}
{"name":"AddMonoid.zero_add","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\nself : AddMonoid M\na : M\n⊢ Eq (HAdd.hAdd 0 a) a","decl":"/-- An `AddMonoid` is an `AddSemigroup` with an element `0` such that `0 + a = a + 0 = a`. -/\nclass AddMonoid (M : Type u) extends AddSemigroup M, AddZeroClass M where\n  /-- Multiplication by a natural number.\n  Set this to `nsmulRec` unless `Module` diamonds are possible. -/\n  protected nsmul : ℕ → M → M\n  /-- Multiplication by `(0 : ℕ)` gives `0`. -/\n  protected nsmul_zero : ∀ x, nsmul 0 x = 0 := by intros; rfl\n  /-- Multiplication by `(n + 1 : ℕ)` behaves as expected. -/\n  protected nsmul_succ : ∀ (n : ℕ) (x), nsmul (n + 1) x = nsmul n x + x := by intros; rfl\n\n"}
{"name":"AddMonoid.nsmul_succ","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\nself : AddMonoid M\nn : Nat\nx : M\n⊢ Eq (AddMonoid.nsmul (HAdd.hAdd n 1) x) (HAdd.hAdd (AddMonoid.nsmul n x) x)","decl":"/-- An `AddMonoid` is an `AddSemigroup` with an element `0` such that `0 + a = a + 0 = a`. -/\nclass AddMonoid (M : Type u) extends AddSemigroup M, AddZeroClass M where\n  /-- Multiplication by a natural number.\n  Set this to `nsmulRec` unless `Module` diamonds are possible. -/\n  protected nsmul : ℕ → M → M\n  /-- Multiplication by `(0 : ℕ)` gives `0`. -/\n  protected nsmul_zero : ∀ x, nsmul 0 x = 0 := by intros; rfl\n  /-- Multiplication by `(n + 1 : ℕ)` behaves as expected. -/\n  protected nsmul_succ : ∀ (n : ℕ) (x), nsmul (n + 1) x = nsmul n x + x := by intros; rfl\n\n"}
{"name":"AddMonoid.nsmul_zero","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\nself : AddMonoid M\nx : M\n⊢ Eq (AddMonoid.nsmul 0 x) 0","decl":"/-- An `AddMonoid` is an `AddSemigroup` with an element `0` such that `0 + a = a + 0 = a`. -/\nclass AddMonoid (M : Type u) extends AddSemigroup M, AddZeroClass M where\n  /-- Multiplication by a natural number.\n  Set this to `nsmulRec` unless `Module` diamonds are possible. -/\n  protected nsmul : ℕ → M → M\n  /-- Multiplication by `(0 : ℕ)` gives `0`. -/\n  protected nsmul_zero : ∀ x, nsmul 0 x = 0 := by intros; rfl\n  /-- Multiplication by `(n + 1 : ℕ)` behaves as expected. -/\n  protected nsmul_succ : ∀ (n : ℕ) (x), nsmul (n + 1) x = nsmul n x + x := by intros; rfl\n\n"}
{"name":"AddMonoid.add_zero","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\nself : AddMonoid M\na : M\n⊢ Eq (HAdd.hAdd a 0) a","decl":"/-- An `AddMonoid` is an `AddSemigroup` with an element `0` such that `0 + a = a + 0 = a`. -/\nclass AddMonoid (M : Type u) extends AddSemigroup M, AddZeroClass M where\n  /-- Multiplication by a natural number.\n  Set this to `nsmulRec` unless `Module` diamonds are possible. -/\n  protected nsmul : ℕ → M → M\n  /-- Multiplication by `(0 : ℕ)` gives `0`. -/\n  protected nsmul_zero : ∀ x, nsmul 0 x = 0 := by intros; rfl\n  /-- Multiplication by `(n + 1 : ℕ)` behaves as expected. -/\n  protected nsmul_succ : ∀ (n : ℕ) (x), nsmul (n + 1) x = nsmul n x + x := by intros; rfl\n\n"}
{"name":"Monoid.mul_one","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\nself : Monoid M\na : M\n⊢ Eq (HMul.hMul a 1) a","decl":"/-- A `Monoid` is a `Semigroup` with an element `1` such that `1 * a = a * 1 = a`. -/\n@[to_additive]\nclass Monoid (M : Type u) extends Semigroup M, MulOneClass M where\n  /-- Raising to the power of a natural number. -/\n  protected npow : ℕ → M → M := npowRecAuto\n  /-- Raising to the power `(0 : ℕ)` gives `1`. -/\n  protected npow_zero : ∀ x, npow 0 x = 1 := by intros; rfl\n  /-- Raising to the power `(n + 1 : ℕ)` behaves as expected. -/\n  protected npow_succ : ∀ (n : ℕ) (x), npow (n + 1) x = npow n x * x := by intros; rfl\n\n"}
{"name":"Monoid.npow_succ","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\nself : Monoid M\nn : Nat\nx : M\n⊢ Eq (Monoid.npow (HAdd.hAdd n 1) x) (HMul.hMul (Monoid.npow n x) x)","decl":"/-- A `Monoid` is a `Semigroup` with an element `1` such that `1 * a = a * 1 = a`. -/\n@[to_additive]\nclass Monoid (M : Type u) extends Semigroup M, MulOneClass M where\n  /-- Raising to the power of a natural number. -/\n  protected npow : ℕ → M → M := npowRecAuto\n  /-- Raising to the power `(0 : ℕ)` gives `1`. -/\n  protected npow_zero : ∀ x, npow 0 x = 1 := by intros; rfl\n  /-- Raising to the power `(n + 1 : ℕ)` behaves as expected. -/\n  protected npow_succ : ∀ (n : ℕ) (x), npow (n + 1) x = npow n x * x := by intros; rfl\n\n"}
{"name":"Monoid.npow_zero","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\nself : Monoid M\nx : M\n⊢ Eq (Monoid.npow 0 x) 1","decl":"/-- A `Monoid` is a `Semigroup` with an element `1` such that `1 * a = a * 1 = a`. -/\n@[to_additive]\nclass Monoid (M : Type u) extends Semigroup M, MulOneClass M where\n  /-- Raising to the power of a natural number. -/\n  protected npow : ℕ → M → M := npowRecAuto\n  /-- Raising to the power `(0 : ℕ)` gives `1`. -/\n  protected npow_zero : ∀ x, npow 0 x = 1 := by intros; rfl\n  /-- Raising to the power `(n + 1 : ℕ)` behaves as expected. -/\n  protected npow_succ : ∀ (n : ℕ) (x), npow (n + 1) x = npow n x * x := by intros; rfl\n\n"}
{"name":"Monoid.one_mul","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\nself : Monoid M\na : M\n⊢ Eq (HMul.hMul 1 a) a","decl":"/-- A `Monoid` is a `Semigroup` with an element `1` such that `1 * a = a * 1 = a`. -/\n@[to_additive]\nclass Monoid (M : Type u) extends Semigroup M, MulOneClass M where\n  /-- Raising to the power of a natural number. -/\n  protected npow : ℕ → M → M := npowRecAuto\n  /-- Raising to the power `(0 : ℕ)` gives `1`. -/\n  protected npow_zero : ∀ x, npow 0 x = 1 := by intros; rfl\n  /-- Raising to the power `(n + 1 : ℕ)` behaves as expected. -/\n  protected npow_succ : ∀ (n : ℕ) (x), npow (n + 1) x = npow n x * x := by intros; rfl\n\n"}
{"name":"nsmul_eq_smul","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : AddMonoid M\nn : Nat\nx : M\n⊢ Eq (AddMonoid.nsmul n x) (HSMul.hSMul n x)","decl":"@[to_additive (attr := simp) nsmul_eq_smul]\ntheorem npow_eq_pow (n : ℕ) (x : M) : Monoid.npow n x = x ^ n :=\n  rfl\n\n"}
{"name":"npow_eq_pow","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : Monoid M\nn : Nat\nx : M\n⊢ Eq (Monoid.npow n x) (HPow.hPow x n)","decl":"@[to_additive (attr := simp) nsmul_eq_smul]\ntheorem npow_eq_pow (n : ℕ) (x : M) : Monoid.npow n x = x ^ n :=\n  rfl\n\n"}
{"name":"left_neg_eq_right_neg","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : AddMonoid M\na b c : M\nhba : Eq (HAdd.hAdd b a) 0\nhac : Eq (HAdd.hAdd a c) 0\n⊢ Eq b c","decl":"@[to_additive] lemma left_inv_eq_right_inv (hba : b * a = 1) (hac : a * c = 1) : b = c := by\n  rw [← one_mul c, ← hba, mul_assoc, hac, mul_one b]\n\n-- the attributes are intentionally out of order. `zero_smul` proves `zero_nsmul`.\n"}
{"name":"left_inv_eq_right_inv","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : Monoid M\na b c : M\nhba : Eq (HMul.hMul b a) 1\nhac : Eq (HMul.hMul a c) 1\n⊢ Eq b c","decl":"@[to_additive] lemma left_inv_eq_right_inv (hba : b * a = 1) (hac : a * c = 1) : b = c := by\n  rw [← one_mul c, ← hba, mul_assoc, hac, mul_one b]\n\n-- the attributes are intentionally out of order. `zero_smul` proves `zero_nsmul`.\n"}
{"name":"zero_nsmul","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : AddMonoid M\na : M\n⊢ Eq (HSMul.hSMul 0 a) 0","decl":"@[to_additive zero_nsmul, simp]\ntheorem pow_zero (a : M) : a ^ 0 = 1 :=\n  Monoid.npow_zero _\n\n"}
{"name":"pow_zero","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : Monoid M\na : M\n⊢ Eq (HPow.hPow a 0) 1","decl":"@[to_additive zero_nsmul, simp]\ntheorem pow_zero (a : M) : a ^ 0 = 1 :=\n  Monoid.npow_zero _\n\n"}
{"name":"pow_succ","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : Monoid M\na : M\nn : Nat\n⊢ Eq (HPow.hPow a (HAdd.hAdd n 1)) (HMul.hMul (HPow.hPow a n) a)","decl":"@[to_additive succ_nsmul]\ntheorem pow_succ (a : M) (n : ℕ) : a ^ (n + 1) = a ^ n * a :=\n  Monoid.npow_succ n a\n\n"}
{"name":"succ_nsmul","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : AddMonoid M\na : M\nn : Nat\n⊢ Eq (HSMul.hSMul (HAdd.hAdd n 1) a) (HAdd.hAdd (HSMul.hSMul n a) a)","decl":"@[to_additive succ_nsmul]\ntheorem pow_succ (a : M) (n : ℕ) : a ^ (n + 1) = a ^ n * a :=\n  Monoid.npow_succ n a\n\n"}
{"name":"pow_one","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : Monoid M\na : M\n⊢ Eq (HPow.hPow a 1) a","decl":"@[to_additive (attr := simp) one_nsmul]\nlemma pow_one (a : M) : a ^ 1 = a := by rw [pow_succ, pow_zero, one_mul]\n\n"}
{"name":"one_nsmul","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : AddMonoid M\na : M\n⊢ Eq (HSMul.hSMul 1 a) a","decl":"@[to_additive (attr := simp) one_nsmul]\nlemma pow_one (a : M) : a ^ 1 = a := by rw [pow_succ, pow_zero, one_mul]\n\n"}
{"name":"pow_succ'","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : Monoid M\na : M\nn : Nat\n⊢ Eq (HPow.hPow a (HAdd.hAdd n 1)) (HMul.hMul a (HPow.hPow a n))","decl":"@[to_additive succ_nsmul'] lemma pow_succ' (a : M) : ∀ n, a ^ (n + 1) = a * a ^ n\n  | 0 => by simp\n  | n + 1 => by rw [pow_succ _ n, pow_succ, pow_succ', mul_assoc]\n\n"}
{"name":"succ_nsmul'","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : AddMonoid M\na : M\nn : Nat\n⊢ Eq (HSMul.hSMul (HAdd.hAdd n 1) a) (HAdd.hAdd a (HSMul.hSMul n a))","decl":"@[to_additive succ_nsmul'] lemma pow_succ' (a : M) : ∀ n, a ^ (n + 1) = a * a ^ n\n  | 0 => by simp\n  | n + 1 => by rw [pow_succ _ n, pow_succ, pow_succ', mul_assoc]\n\n"}
{"name":"pow_mul_comm'","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : Monoid M\na : M\nn : Nat\n⊢ Eq (HMul.hMul (HPow.hPow a n) a) (HMul.hMul a (HPow.hPow a n))","decl":"@[to_additive]\nlemma pow_mul_comm' (a : M) (n : ℕ) : a ^ n * a = a * a ^ n := by rw [← pow_succ, pow_succ']\n\n"}
{"name":"nsmul_add_comm'","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : AddMonoid M\na : M\nn : Nat\n⊢ Eq (HAdd.hAdd (HSMul.hSMul n a) a) (HAdd.hAdd a (HSMul.hSMul n a))","decl":"@[to_additive]\nlemma pow_mul_comm' (a : M) (n : ℕ) : a ^ n * a = a * a ^ n := by rw [← pow_succ, pow_succ']\n\n"}
{"name":"two_nsmul","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : AddMonoid M\na : M\n⊢ Eq (HSMul.hSMul 2 a) (HAdd.hAdd a a)","decl":"/-- Note that most of the lemmas about powers of two refer to it as `sq`. -/\n@[to_additive two_nsmul] lemma pow_two (a : M) : a ^ 2 = a * a := by rw [pow_succ, pow_one]\n\n-- TODO: Should `alias` automatically transfer `to_additive` statements?\n"}
{"name":"pow_two","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : Monoid M\na : M\n⊢ Eq (HPow.hPow a 2) (HMul.hMul a a)","decl":"/-- Note that most of the lemmas about powers of two refer to it as `sq`. -/\n@[to_additive two_nsmul] lemma pow_two (a : M) : a ^ 2 = a * a := by rw [pow_succ, pow_one]\n\n-- TODO: Should `alias` automatically transfer `to_additive` statements?\n"}
{"name":"sq","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : Monoid M\na : M\n⊢ Eq (HPow.hPow a 2) (HMul.hMul a a)","decl":"@[to_additive existing two_nsmul] alias sq := pow_two\n\n"}
{"name":"pow_three'","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : Monoid M\na : M\n⊢ Eq (HPow.hPow a 3) (HMul.hMul (HMul.hMul a a) a)","decl":"@[to_additive three'_nsmul]\nlemma pow_three' (a : M) : a ^ 3 = a * a * a := by rw [pow_succ, pow_two]\n\n"}
{"name":"three'_nsmul","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : AddMonoid M\na : M\n⊢ Eq (HSMul.hSMul 3 a) (HAdd.hAdd (HAdd.hAdd a a) a)","decl":"@[to_additive three'_nsmul]\nlemma pow_three' (a : M) : a ^ 3 = a * a * a := by rw [pow_succ, pow_two]\n\n"}
{"name":"pow_three","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : Monoid M\na : M\n⊢ Eq (HPow.hPow a 3) (HMul.hMul a (HMul.hMul a a))","decl":"@[to_additive three_nsmul]\nlemma pow_three (a : M) : a ^ 3 = a * (a * a) := by rw [pow_succ', pow_two]\n\n-- the attributes are intentionally out of order.\n"}
{"name":"three_nsmul","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : AddMonoid M\na : M\n⊢ Eq (HSMul.hSMul 3 a) (HAdd.hAdd a (HAdd.hAdd a a))","decl":"@[to_additive three_nsmul]\nlemma pow_three (a : M) : a ^ 3 = a * (a * a) := by rw [pow_succ', pow_two]\n\n-- the attributes are intentionally out of order.\n"}
{"name":"nsmul_zero","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : AddMonoid M\nn : Nat\n⊢ Eq (HSMul.hSMul n 0) 0","decl":"@[to_additive nsmul_zero, simp] lemma one_pow : ∀ n, (1 : M) ^ n = 1\n  | 0 => pow_zero _\n  | n + 1 => by rw [pow_succ, one_pow, one_mul]\n\n"}
{"name":"one_pow","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : Monoid M\nn : Nat\n⊢ Eq (HPow.hPow 1 n) 1","decl":"@[to_additive nsmul_zero, simp] lemma one_pow : ∀ n, (1 : M) ^ n = 1\n  | 0 => pow_zero _\n  | n + 1 => by rw [pow_succ, one_pow, one_mul]\n\n"}
{"name":"add_nsmul","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : AddMonoid M\na : M\nm n : Nat\n⊢ Eq (HSMul.hSMul (HAdd.hAdd m n) a) (HAdd.hAdd (HSMul.hSMul m a) (HSMul.hSMul n a))","decl":"@[to_additive add_nsmul]\nlemma pow_add (a : M) (m : ℕ) : ∀ n, a ^ (m + n) = a ^ m * a ^ n\n  | 0 => by rw [Nat.add_zero, pow_zero, mul_one]\n  | n + 1 => by rw [pow_succ, ← mul_assoc, ← pow_add, ← pow_succ, Nat.add_assoc]\n\n"}
{"name":"pow_add","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : Monoid M\na : M\nm n : Nat\n⊢ Eq (HPow.hPow a (HAdd.hAdd m n)) (HMul.hMul (HPow.hPow a m) (HPow.hPow a n))","decl":"@[to_additive add_nsmul]\nlemma pow_add (a : M) (m : ℕ) : ∀ n, a ^ (m + n) = a ^ m * a ^ n\n  | 0 => by rw [Nat.add_zero, pow_zero, mul_one]\n  | n + 1 => by rw [pow_succ, ← mul_assoc, ← pow_add, ← pow_succ, Nat.add_assoc]\n\n"}
{"name":"pow_mul_comm","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : Monoid M\na : M\nm n : Nat\n⊢ Eq (HMul.hMul (HPow.hPow a m) (HPow.hPow a n)) (HMul.hMul (HPow.hPow a n) (HPow.hPow a m))","decl":"@[to_additive] lemma pow_mul_comm (a : M) (m n : ℕ) : a ^ m * a ^ n = a ^ n * a ^ m := by\n  rw [← pow_add, ← pow_add, Nat.add_comm]\n\n"}
{"name":"nsmul_add_comm","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : AddMonoid M\na : M\nm n : Nat\n⊢ Eq (HAdd.hAdd (HSMul.hSMul m a) (HSMul.hSMul n a)) (HAdd.hAdd (HSMul.hSMul n a) (HSMul.hSMul m a))","decl":"@[to_additive] lemma pow_mul_comm (a : M) (m n : ℕ) : a ^ m * a ^ n = a ^ n * a ^ m := by\n  rw [← pow_add, ← pow_add, Nat.add_comm]\n\n"}
{"name":"mul_nsmul","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : AddMonoid M\na : M\nm n : Nat\n⊢ Eq (HSMul.hSMul (HMul.hMul m n) a) (HSMul.hSMul n (HSMul.hSMul m a))","decl":"@[to_additive mul_nsmul] lemma pow_mul (a : M) (m : ℕ) : ∀ n, a ^ (m * n) = (a ^ m) ^ n\n  | 0 => by rw [Nat.mul_zero, pow_zero, pow_zero]\n  | n + 1 => by rw [Nat.mul_succ, pow_add, pow_succ, pow_mul]\n\n"}
{"name":"pow_mul","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : Monoid M\na : M\nm n : Nat\n⊢ Eq (HPow.hPow a (HMul.hMul m n)) (HPow.hPow (HPow.hPow a m) n)","decl":"@[to_additive mul_nsmul] lemma pow_mul (a : M) (m : ℕ) : ∀ n, a ^ (m * n) = (a ^ m) ^ n\n  | 0 => by rw [Nat.mul_zero, pow_zero, pow_zero]\n  | n + 1 => by rw [Nat.mul_succ, pow_add, pow_succ, pow_mul]\n\n"}
{"name":"mul_nsmul'","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : AddMonoid M\na : M\nm n : Nat\n⊢ Eq (HSMul.hSMul (HMul.hMul m n) a) (HSMul.hSMul m (HSMul.hSMul n a))","decl":"@[to_additive mul_nsmul']\nlemma pow_mul' (a : M) (m n : ℕ) : a ^ (m * n) = (a ^ n) ^ m := by rw [Nat.mul_comm, pow_mul]\n\n"}
{"name":"pow_mul'","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : Monoid M\na : M\nm n : Nat\n⊢ Eq (HPow.hPow a (HMul.hMul m n)) (HPow.hPow (HPow.hPow a n) m)","decl":"@[to_additive mul_nsmul']\nlemma pow_mul' (a : M) (m n : ℕ) : a ^ (m * n) = (a ^ n) ^ m := by rw [Nat.mul_comm, pow_mul]\n\n"}
{"name":"pow_right_comm","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : Monoid M\na : M\nm n : Nat\n⊢ Eq (HPow.hPow (HPow.hPow a m) n) (HPow.hPow (HPow.hPow a n) m)","decl":"@[to_additive nsmul_left_comm]\nlemma pow_right_comm (a : M) (m n : ℕ) : (a ^ m) ^ n = (a ^ n) ^ m := by\n  rw [← pow_mul, Nat.mul_comm, pow_mul]\n\n"}
{"name":"nsmul_left_comm","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u_2\ninst✝ : AddMonoid M\na : M\nm n : Nat\n⊢ Eq (HSMul.hSMul n (HSMul.hSMul m a)) (HSMul.hSMul m (HSMul.hSMul n a))","decl":"@[to_additive nsmul_left_comm]\nlemma pow_right_comm (a : M) (m n : ℕ) : (a ^ m) ^ n = (a ^ n) ^ m := by\n  rw [← pow_mul, Nat.mul_comm, pow_mul]\n\n"}
{"name":"AddCommMonoid.add_comm","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\nself : AddCommMonoid M\na b : M\n⊢ Eq (HAdd.hAdd a b) (HAdd.hAdd b a)","decl":"/-- An additive commutative monoid is an additive monoid with commutative `(+)`. -/\nclass AddCommMonoid (M : Type u) extends AddMonoid M, AddCommSemigroup M\n\n"}
{"name":"CommMonoid.mul_comm","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\nself : CommMonoid M\na b : M\n⊢ Eq (HMul.hMul a b) (HMul.hMul b a)","decl":"/-- A commutative monoid is a monoid with commutative `(*)`. -/\n@[to_additive]\nclass CommMonoid (M : Type u) extends Monoid M, CommSemigroup M\n\n"}
{"name":"AddLeftCancelMonoid.add_left_cancel","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\nself : AddLeftCancelMonoid M\na b c : M\na✝ : Eq (HAdd.hAdd a b) (HAdd.hAdd a c)\n⊢ Eq b c","decl":"/-- An additive monoid in which addition is left-cancellative.\nMain examples are `ℕ` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `AddLeftCancelSemigroup` is not enough. -/\nclass AddLeftCancelMonoid (M : Type u) extends AddMonoid M, AddLeftCancelSemigroup M\n\n"}
{"name":"LeftCancelMonoid.mul_left_cancel","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\nself : LeftCancelMonoid M\na b c : M\na✝ : Eq (HMul.hMul a b) (HMul.hMul a c)\n⊢ Eq b c","decl":"/-- A monoid in which multiplication is left-cancellative. -/\n@[to_additive]\nclass LeftCancelMonoid (M : Type u) extends Monoid M, LeftCancelSemigroup M\n\n"}
{"name":"AddRightCancelMonoid.add_right_cancel","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\nself : AddRightCancelMonoid M\na b c : M\na✝ : Eq (HAdd.hAdd a b) (HAdd.hAdd c b)\n⊢ Eq a c","decl":"/-- An additive monoid in which addition is right-cancellative.\nMain examples are `ℕ` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `AddRightCancelSemigroup` is not enough. -/\nclass AddRightCancelMonoid (M : Type u) extends AddMonoid M, AddRightCancelSemigroup M\n\n"}
{"name":"RightCancelMonoid.mul_right_cancel","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\nself : RightCancelMonoid M\na b c : M\na✝ : Eq (HMul.hMul a b) (HMul.hMul c b)\n⊢ Eq a c","decl":"/-- A monoid in which multiplication is right-cancellative. -/\n@[to_additive]\nclass RightCancelMonoid (M : Type u) extends Monoid M, RightCancelSemigroup M\n\n"}
{"name":"AddCancelMonoid.add_right_cancel","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\nself : AddCancelMonoid M\na b c : M\na✝ : Eq (HAdd.hAdd a b) (HAdd.hAdd c b)\n⊢ Eq a c","decl":"/-- An additive monoid in which addition is cancellative on both sides.\nMain examples are `ℕ` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `AddRightCancelMonoid` is not enough. -/\nclass AddCancelMonoid (M : Type u) extends AddLeftCancelMonoid M, AddRightCancelMonoid M\n\n"}
{"name":"CancelMonoid.mul_right_cancel","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\nself : CancelMonoid M\na b c : M\na✝ : Eq (HMul.hMul a b) (HMul.hMul c b)\n⊢ Eq a c","decl":"/-- A monoid in which multiplication is cancellative. -/\n@[to_additive]\nclass CancelMonoid (M : Type u) extends LeftCancelMonoid M, RightCancelMonoid M\n\n"}
{"name":"AddCancelCommMonoid.add_left_cancel","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\nself : AddCancelCommMonoid M\na b c : M\na✝ : Eq (HAdd.hAdd a b) (HAdd.hAdd a c)\n⊢ Eq b c","decl":"/-- Commutative version of `AddCancelMonoid`. -/\nclass AddCancelCommMonoid (M : Type u) extends AddCommMonoid M, AddLeftCancelMonoid M\n\n"}
{"name":"CancelCommMonoid.mul_left_cancel","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\nself : CancelCommMonoid M\na b c : M\na✝ : Eq (HMul.hMul a b) (HMul.hMul a c)\n⊢ Eq b c","decl":"/-- Commutative version of `CancelMonoid`. -/\n@[to_additive]\nclass CancelCommMonoid (M : Type u) extends CommMonoid M, LeftCancelMonoid M\n\n"}
{"name":"AddCancelMonoid.toIsCancelAdd","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\ninst✝ : AddCancelMonoid M\n⊢ IsCancelAdd M","decl":"/-- Any `CancelMonoid G` satisfies `IsCancelMul G`. -/\n@[to_additive toIsCancelAdd \"Any `AddCancelMonoid G` satisfies `IsCancelAdd G`.\"]\ninstance (priority := 100) CancelMonoid.toIsCancelMul (M : Type u) [CancelMonoid M] :\n    IsCancelMul M :=\n  { mul_left_cancel := LeftCancelSemigroup.mul_left_cancel\n    mul_right_cancel := RightCancelSemigroup.mul_right_cancel }\n\n"}
{"name":"CancelMonoid.toIsCancelMul","module":"Mathlib.Algebra.Group.Defs","initialProofState":"M : Type u\ninst✝ : CancelMonoid M\n⊢ IsCancelMul M","decl":"/-- Any `CancelMonoid G` satisfies `IsCancelMul G`. -/\n@[to_additive toIsCancelAdd \"Any `AddCancelMonoid G` satisfies `IsCancelAdd G`.\"]\ninstance (priority := 100) CancelMonoid.toIsCancelMul (M : Type u) [CancelMonoid M] :\n    IsCancelMul M :=\n  { mul_left_cancel := LeftCancelSemigroup.mul_left_cancel\n    mul_right_cancel := RightCancelSemigroup.mul_right_cancel }\n\n"}
{"name":"InvolutiveNeg.neg_neg","module":"Mathlib.Algebra.Group.Defs","initialProofState":"A : Type u_2\nself : InvolutiveNeg A\nx : A\n⊢ Eq (Neg.neg (Neg.neg x)) x","decl":"/-- Auxiliary typeclass for types with an involutive `Neg`. -/\nclass InvolutiveNeg (A : Type*) extends Neg A where\n  protected neg_neg : ∀ x : A, - -x = x\n\n"}
{"name":"InvolutiveInv.inv_inv","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_2\nself : InvolutiveInv G\nx : G\n⊢ Eq (Inv.inv (Inv.inv x)) x","decl":"/-- Auxiliary typeclass for types with an involutive `Inv`. -/\n@[to_additive]\nclass InvolutiveInv (G : Type*) extends Inv G where\n  protected inv_inv : ∀ x : G, x⁻¹⁻¹ = x\n\n"}
{"name":"inv_inv","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : InvolutiveInv G\na : G\n⊢ Eq (Inv.inv (Inv.inv a)) a","decl":"@[to_additive (attr := simp)]\ntheorem inv_inv (a : G) : a⁻¹⁻¹ = a :=\n  InvolutiveInv.inv_inv _\n\n"}
{"name":"neg_neg","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : InvolutiveNeg G\na : G\n⊢ Eq (Neg.neg (Neg.neg a)) a","decl":"@[to_additive (attr := simp)]\ntheorem inv_inv (a : G) : a⁻¹⁻¹ = a :=\n  InvolutiveInv.inv_inv _\n\n"}
{"name":"DivInvMonoid.div_eq_mul_inv","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nself : DivInvMonoid G\na b : G\n⊢ Eq (HDiv.hDiv a b) (HMul.hMul a (Inv.inv b))","decl":"/-- A `DivInvMonoid` is a `Monoid` with operations `/` and `⁻¹` satisfying\n`div_eq_mul_inv : ∀ a b, a / b = a * b⁻¹`.\n\nThis deduplicates the name `div_eq_mul_inv`.\nThe default for `div` is such that `a / b = a * b⁻¹` holds by definition.\n\nAdding `div` as a field rather than defining `a / b := a * b⁻¹` allows us to\navoid certain classes of unification failures, for example:\nLet `Foo X` be a type with a `∀ X, Div (Foo X)` instance but no\n`∀ X, Inv (Foo X)`, e.g. when `Foo X` is a `EuclideanDomain`. Suppose we\nalso have an instance `∀ X [Cromulent X], GroupWithZero (Foo X)`. Then the\n`(/)` coming from `GroupWithZero.div` cannot be definitionally equal to\nthe `(/)` coming from `Foo.Div`.\n\nIn the same way, adding a `zpow` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `Monoid` and Note [forgetful inheritance] for more\nexplanations on this.\n-/\nclass DivInvMonoid (G : Type u) extends Monoid G, Inv G, Div G where\n  protected div := DivInvMonoid.div'\n  /-- `a / b := a * b⁻¹` -/\n  protected div_eq_mul_inv : ∀ a b : G, a / b = a * b⁻¹ := by intros; rfl\n  /-- The power operation: `a ^ n = a * ··· * a`; `a ^ (-n) = a⁻¹ * ··· a⁻¹` (`n` times) -/\n  protected zpow : ℤ → G → G := zpowRec npowRec\n  /-- `a ^ 0 = 1` -/\n  protected zpow_zero' : ∀ a : G, zpow 0 a = 1 := by intros; rfl\n  /-- `a ^ (n + 1) = a ^ n * a` -/\n  protected zpow_succ' (n : ℕ) (a : G) : zpow n.succ a = zpow n a * a := by\n    intros; rfl\n  /-- `a ^ -(n + 1) = (a ^ (n + 1))⁻¹` -/\n  protected zpow_neg' (n : ℕ) (a : G) : zpow (Int.negSucc n) a = (zpow n.succ a)⁻¹ := by intros; rfl\n\n"}
{"name":"DivInvMonoid.zpow_neg'","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nself : DivInvMonoid G\nn : Nat\na : G\n⊢ Eq (DivInvMonoid.zpow (Int.negSucc n) a) (Inv.inv (DivInvMonoid.zpow (↑n.succ) a))","decl":"/-- A `DivInvMonoid` is a `Monoid` with operations `/` and `⁻¹` satisfying\n`div_eq_mul_inv : ∀ a b, a / b = a * b⁻¹`.\n\nThis deduplicates the name `div_eq_mul_inv`.\nThe default for `div` is such that `a / b = a * b⁻¹` holds by definition.\n\nAdding `div` as a field rather than defining `a / b := a * b⁻¹` allows us to\navoid certain classes of unification failures, for example:\nLet `Foo X` be a type with a `∀ X, Div (Foo X)` instance but no\n`∀ X, Inv (Foo X)`, e.g. when `Foo X` is a `EuclideanDomain`. Suppose we\nalso have an instance `∀ X [Cromulent X], GroupWithZero (Foo X)`. Then the\n`(/)` coming from `GroupWithZero.div` cannot be definitionally equal to\nthe `(/)` coming from `Foo.Div`.\n\nIn the same way, adding a `zpow` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `Monoid` and Note [forgetful inheritance] for more\nexplanations on this.\n-/\nclass DivInvMonoid (G : Type u) extends Monoid G, Inv G, Div G where\n  protected div := DivInvMonoid.div'\n  /-- `a / b := a * b⁻¹` -/\n  protected div_eq_mul_inv : ∀ a b : G, a / b = a * b⁻¹ := by intros; rfl\n  /-- The power operation: `a ^ n = a * ··· * a`; `a ^ (-n) = a⁻¹ * ··· a⁻¹` (`n` times) -/\n  protected zpow : ℤ → G → G := zpowRec npowRec\n  /-- `a ^ 0 = 1` -/\n  protected zpow_zero' : ∀ a : G, zpow 0 a = 1 := by intros; rfl\n  /-- `a ^ (n + 1) = a ^ n * a` -/\n  protected zpow_succ' (n : ℕ) (a : G) : zpow n.succ a = zpow n a * a := by\n    intros; rfl\n  /-- `a ^ -(n + 1) = (a ^ (n + 1))⁻¹` -/\n  protected zpow_neg' (n : ℕ) (a : G) : zpow (Int.negSucc n) a = (zpow n.succ a)⁻¹ := by intros; rfl\n\n"}
{"name":"DivInvMonoid.zpow_zero'","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nself : DivInvMonoid G\na : G\n⊢ Eq (DivInvMonoid.zpow 0 a) 1","decl":"/-- A `DivInvMonoid` is a `Monoid` with operations `/` and `⁻¹` satisfying\n`div_eq_mul_inv : ∀ a b, a / b = a * b⁻¹`.\n\nThis deduplicates the name `div_eq_mul_inv`.\nThe default for `div` is such that `a / b = a * b⁻¹` holds by definition.\n\nAdding `div` as a field rather than defining `a / b := a * b⁻¹` allows us to\navoid certain classes of unification failures, for example:\nLet `Foo X` be a type with a `∀ X, Div (Foo X)` instance but no\n`∀ X, Inv (Foo X)`, e.g. when `Foo X` is a `EuclideanDomain`. Suppose we\nalso have an instance `∀ X [Cromulent X], GroupWithZero (Foo X)`. Then the\n`(/)` coming from `GroupWithZero.div` cannot be definitionally equal to\nthe `(/)` coming from `Foo.Div`.\n\nIn the same way, adding a `zpow` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `Monoid` and Note [forgetful inheritance] for more\nexplanations on this.\n-/\nclass DivInvMonoid (G : Type u) extends Monoid G, Inv G, Div G where\n  protected div := DivInvMonoid.div'\n  /-- `a / b := a * b⁻¹` -/\n  protected div_eq_mul_inv : ∀ a b : G, a / b = a * b⁻¹ := by intros; rfl\n  /-- The power operation: `a ^ n = a * ··· * a`; `a ^ (-n) = a⁻¹ * ··· a⁻¹` (`n` times) -/\n  protected zpow : ℤ → G → G := zpowRec npowRec\n  /-- `a ^ 0 = 1` -/\n  protected zpow_zero' : ∀ a : G, zpow 0 a = 1 := by intros; rfl\n  /-- `a ^ (n + 1) = a ^ n * a` -/\n  protected zpow_succ' (n : ℕ) (a : G) : zpow n.succ a = zpow n a * a := by\n    intros; rfl\n  /-- `a ^ -(n + 1) = (a ^ (n + 1))⁻¹` -/\n  protected zpow_neg' (n : ℕ) (a : G) : zpow (Int.negSucc n) a = (zpow n.succ a)⁻¹ := by intros; rfl\n\n"}
{"name":"DivInvMonoid.zpow_succ'","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nself : DivInvMonoid G\nn : Nat\na : G\n⊢ Eq (DivInvMonoid.zpow (↑n.succ) a) (HMul.hMul (DivInvMonoid.zpow (↑n) a) a)","decl":"/-- A `DivInvMonoid` is a `Monoid` with operations `/` and `⁻¹` satisfying\n`div_eq_mul_inv : ∀ a b, a / b = a * b⁻¹`.\n\nThis deduplicates the name `div_eq_mul_inv`.\nThe default for `div` is such that `a / b = a * b⁻¹` holds by definition.\n\nAdding `div` as a field rather than defining `a / b := a * b⁻¹` allows us to\navoid certain classes of unification failures, for example:\nLet `Foo X` be a type with a `∀ X, Div (Foo X)` instance but no\n`∀ X, Inv (Foo X)`, e.g. when `Foo X` is a `EuclideanDomain`. Suppose we\nalso have an instance `∀ X [Cromulent X], GroupWithZero (Foo X)`. Then the\n`(/)` coming from `GroupWithZero.div` cannot be definitionally equal to\nthe `(/)` coming from `Foo.Div`.\n\nIn the same way, adding a `zpow` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `Monoid` and Note [forgetful inheritance] for more\nexplanations on this.\n-/\nclass DivInvMonoid (G : Type u) extends Monoid G, Inv G, Div G where\n  protected div := DivInvMonoid.div'\n  /-- `a / b := a * b⁻¹` -/\n  protected div_eq_mul_inv : ∀ a b : G, a / b = a * b⁻¹ := by intros; rfl\n  /-- The power operation: `a ^ n = a * ··· * a`; `a ^ (-n) = a⁻¹ * ··· a⁻¹` (`n` times) -/\n  protected zpow : ℤ → G → G := zpowRec npowRec\n  /-- `a ^ 0 = 1` -/\n  protected zpow_zero' : ∀ a : G, zpow 0 a = 1 := by intros; rfl\n  /-- `a ^ (n + 1) = a ^ n * a` -/\n  protected zpow_succ' (n : ℕ) (a : G) : zpow n.succ a = zpow n a * a := by\n    intros; rfl\n  /-- `a ^ -(n + 1) = (a ^ (n + 1))⁻¹` -/\n  protected zpow_neg' (n : ℕ) (a : G) : zpow (Int.negSucc n) a = (zpow n.succ a)⁻¹ := by intros; rfl\n\n"}
{"name":"SubNegMonoid.zsmul_zero'","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nself : SubNegMonoid G\na : G\n⊢ Eq (SubNegMonoid.zsmul 0 a) 0","decl":"/-- A `SubNegMonoid` is an `AddMonoid` with unary `-` and binary `-` operations\nsatisfying `sub_eq_add_neg : ∀ a b, a - b = a + -b`.\n\nThe default for `sub` is such that `a - b = a + -b` holds by definition.\n\nAdding `sub` as a field rather than defining `a - b := a + -b` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `∀ X, Sub (Foo X)` instance but no\n`∀ X, Neg (Foo X)`. Suppose we also have an instance\n`∀ X [Cromulent X], AddGroup (Foo X)`. Then the `(-)` coming from\n`AddGroup.sub` cannot be definitionally equal to the `(-)` coming from\n`Foo.Sub`.\n\nIn the same way, adding a `zsmul` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `AddMonoid` and Note [forgetful inheritance] for more\nexplanations on this.\n-/\nclass SubNegMonoid (G : Type u) extends AddMonoid G, Neg G, Sub G where\n  protected sub := SubNegMonoid.sub'\n  protected sub_eq_add_neg : ∀ a b : G, a - b = a + -b := by intros; rfl\n  /-- Multiplication by an integer.\n  Set this to `zsmulRec` unless `Module` diamonds are possible. -/\n  protected zsmul : ℤ → G → G\n  protected zsmul_zero' : ∀ a : G, zsmul 0 a = 0 := by intros; rfl\n  protected zsmul_succ' (n : ℕ) (a : G) :\n      zsmul n.succ a = zsmul n a + a := by\n    intros; rfl\n  protected zsmul_neg' (n : ℕ) (a : G) : zsmul (Int.negSucc n) a = -zsmul n.succ a := by\n    intros; rfl\n\n"}
{"name":"SubNegMonoid.zsmul_succ'","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nself : SubNegMonoid G\nn : Nat\na : G\n⊢ Eq (SubNegMonoid.zsmul (↑n.succ) a) (HAdd.hAdd (SubNegMonoid.zsmul (↑n) a) a)","decl":"/-- A `SubNegMonoid` is an `AddMonoid` with unary `-` and binary `-` operations\nsatisfying `sub_eq_add_neg : ∀ a b, a - b = a + -b`.\n\nThe default for `sub` is such that `a - b = a + -b` holds by definition.\n\nAdding `sub` as a field rather than defining `a - b := a + -b` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `∀ X, Sub (Foo X)` instance but no\n`∀ X, Neg (Foo X)`. Suppose we also have an instance\n`∀ X [Cromulent X], AddGroup (Foo X)`. Then the `(-)` coming from\n`AddGroup.sub` cannot be definitionally equal to the `(-)` coming from\n`Foo.Sub`.\n\nIn the same way, adding a `zsmul` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `AddMonoid` and Note [forgetful inheritance] for more\nexplanations on this.\n-/\nclass SubNegMonoid (G : Type u) extends AddMonoid G, Neg G, Sub G where\n  protected sub := SubNegMonoid.sub'\n  protected sub_eq_add_neg : ∀ a b : G, a - b = a + -b := by intros; rfl\n  /-- Multiplication by an integer.\n  Set this to `zsmulRec` unless `Module` diamonds are possible. -/\n  protected zsmul : ℤ → G → G\n  protected zsmul_zero' : ∀ a : G, zsmul 0 a = 0 := by intros; rfl\n  protected zsmul_succ' (n : ℕ) (a : G) :\n      zsmul n.succ a = zsmul n a + a := by\n    intros; rfl\n  protected zsmul_neg' (n : ℕ) (a : G) : zsmul (Int.negSucc n) a = -zsmul n.succ a := by\n    intros; rfl\n\n"}
{"name":"SubNegMonoid.sub_eq_add_neg","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nself : SubNegMonoid G\na b : G\n⊢ Eq (HSub.hSub a b) (HAdd.hAdd a (Neg.neg b))","decl":"/-- A `SubNegMonoid` is an `AddMonoid` with unary `-` and binary `-` operations\nsatisfying `sub_eq_add_neg : ∀ a b, a - b = a + -b`.\n\nThe default for `sub` is such that `a - b = a + -b` holds by definition.\n\nAdding `sub` as a field rather than defining `a - b := a + -b` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `∀ X, Sub (Foo X)` instance but no\n`∀ X, Neg (Foo X)`. Suppose we also have an instance\n`∀ X [Cromulent X], AddGroup (Foo X)`. Then the `(-)` coming from\n`AddGroup.sub` cannot be definitionally equal to the `(-)` coming from\n`Foo.Sub`.\n\nIn the same way, adding a `zsmul` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `AddMonoid` and Note [forgetful inheritance] for more\nexplanations on this.\n-/\nclass SubNegMonoid (G : Type u) extends AddMonoid G, Neg G, Sub G where\n  protected sub := SubNegMonoid.sub'\n  protected sub_eq_add_neg : ∀ a b : G, a - b = a + -b := by intros; rfl\n  /-- Multiplication by an integer.\n  Set this to `zsmulRec` unless `Module` diamonds are possible. -/\n  protected zsmul : ℤ → G → G\n  protected zsmul_zero' : ∀ a : G, zsmul 0 a = 0 := by intros; rfl\n  protected zsmul_succ' (n : ℕ) (a : G) :\n      zsmul n.succ a = zsmul n a + a := by\n    intros; rfl\n  protected zsmul_neg' (n : ℕ) (a : G) : zsmul (Int.negSucc n) a = -zsmul n.succ a := by\n    intros; rfl\n\n"}
{"name":"SubNegMonoid.zsmul_neg'","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nself : SubNegMonoid G\nn : Nat\na : G\n⊢ Eq (SubNegMonoid.zsmul (Int.negSucc n) a) (Neg.neg (SubNegMonoid.zsmul (↑n.succ) a))","decl":"/-- A `SubNegMonoid` is an `AddMonoid` with unary `-` and binary `-` operations\nsatisfying `sub_eq_add_neg : ∀ a b, a - b = a + -b`.\n\nThe default for `sub` is such that `a - b = a + -b` holds by definition.\n\nAdding `sub` as a field rather than defining `a - b := a + -b` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `∀ X, Sub (Foo X)` instance but no\n`∀ X, Neg (Foo X)`. Suppose we also have an instance\n`∀ X [Cromulent X], AddGroup (Foo X)`. Then the `(-)` coming from\n`AddGroup.sub` cannot be definitionally equal to the `(-)` coming from\n`Foo.Sub`.\n\nIn the same way, adding a `zsmul` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `AddMonoid` and Note [forgetful inheritance] for more\nexplanations on this.\n-/\nclass SubNegMonoid (G : Type u) extends AddMonoid G, Neg G, Sub G where\n  protected sub := SubNegMonoid.sub'\n  protected sub_eq_add_neg : ∀ a b : G, a - b = a + -b := by intros; rfl\n  /-- Multiplication by an integer.\n  Set this to `zsmulRec` unless `Module` diamonds are possible. -/\n  protected zsmul : ℤ → G → G\n  protected zsmul_zero' : ∀ a : G, zsmul 0 a = 0 := by intros; rfl\n  protected zsmul_succ' (n : ℕ) (a : G) :\n      zsmul n.succ a = zsmul n a + a := by\n    intros; rfl\n  protected zsmul_neg' (n : ℕ) (a : G) : zsmul (Int.negSucc n) a = -zsmul n.succ a := by\n    intros; rfl\n\n"}
{"name":"IsAddCyclic.exists_zsmul_surjective","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\ninst✝ : SMul Int G\nself : IsAddCyclic G\n⊢ Exists fun g => Function.Surjective fun x => HSMul.hSMul x g","decl":"/-- A group is called *cyclic* if it is generated by a single element. -/\nclass IsAddCyclic (G : Type u) [SMul ℤ G] : Prop where\n  protected exists_zsmul_surjective : ∃ g : G, Function.Surjective (· • g : ℤ → G)\n\n"}
{"name":"IsCyclic.exists_zpow_surjective","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\ninst✝ : Pow G Int\nself : IsCyclic G\n⊢ Exists fun g => Function.Surjective fun x => HPow.hPow g x","decl":"/-- A group is called *cyclic* if it is generated by a single element. -/\n@[to_additive]\nclass IsCyclic (G : Type u) [Pow G ℤ] : Prop where\n  protected exists_zpow_surjective : ∃ g : G, Function.Surjective (g ^ · : ℤ → G)\n\n"}
{"name":"exists_zpow_surjective","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_2\ninst✝¹ : Pow G Int\ninst✝ : IsCyclic G\n⊢ Exists fun g => Function.Surjective fun x => HPow.hPow g x","decl":"@[to_additive]\ntheorem exists_zpow_surjective (G : Type*) [Pow G ℤ] [IsCyclic G] :\n    ∃ g : G, Function.Surjective (g ^ · : ℤ → G) :=\n  IsCyclic.exists_zpow_surjective\n\n"}
{"name":"exists_zsmul_surjective","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_2\ninst✝¹ : SMul Int G\ninst✝ : IsAddCyclic G\n⊢ Exists fun g => Function.Surjective fun x => HSMul.hSMul x g","decl":"@[to_additive]\ntheorem exists_zpow_surjective (G : Type*) [Pow G ℤ] [IsCyclic G] :\n    ∃ g : G, Function.Surjective (g ^ · : ℤ → G) :=\n  IsCyclic.exists_zpow_surjective\n\n"}
{"name":"zpow_eq_pow","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : DivInvMonoid G\nn : Int\nx : G\n⊢ Eq (DivInvMonoid.zpow n x) (HPow.hPow x n)","decl":"@[to_additive (attr := simp) zsmul_eq_smul] theorem zpow_eq_pow (n : ℤ) (x : G) :\n    DivInvMonoid.zpow n x = x ^ n :=\n  rfl\n\n"}
{"name":"zsmul_eq_smul","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : SubNegMonoid G\nn : Int\nx : G\n⊢ Eq (SubNegMonoid.zsmul n x) (HSMul.hSMul n x)","decl":"@[to_additive (attr := simp) zsmul_eq_smul] theorem zpow_eq_pow (n : ℤ) (x : G) :\n    DivInvMonoid.zpow n x = x ^ n :=\n  rfl\n\n"}
{"name":"zpow_zero","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : DivInvMonoid G\na : G\n⊢ Eq (HPow.hPow a 0) 1","decl":"@[to_additive (attr := simp) zero_zsmul] theorem zpow_zero (a : G) : a ^ (0 : ℤ) = 1 :=\n  DivInvMonoid.zpow_zero' a\n\n"}
{"name":"zero_zsmul","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : SubNegMonoid G\na : G\n⊢ Eq (HSMul.hSMul 0 a) 0","decl":"@[to_additive (attr := simp) zero_zsmul] theorem zpow_zero (a : G) : a ^ (0 : ℤ) = 1 :=\n  DivInvMonoid.zpow_zero' a\n\n"}
{"name":"natCast_zsmul","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : SubNegMonoid G\na : G\nn : Nat\n⊢ Eq (HSMul.hSMul (↑n) a) (HSMul.hSMul n a)","decl":"@[to_additive (attr := simp, norm_cast) natCast_zsmul]\ntheorem zpow_natCast (a : G) : ∀ n : ℕ, a ^ (n : ℤ) = a ^ n\n  | 0 => (zpow_zero _).trans (pow_zero _).symm\n  | n + 1 => calc\n    a ^ (↑(n + 1) : ℤ) = a ^ (n : ℤ) * a := DivInvMonoid.zpow_succ' _ _\n    _ = a ^ n * a := congrArg (· * a) (zpow_natCast a n)\n    _ = a ^ (n + 1) := (pow_succ _ _).symm\n\n\n"}
{"name":"zpow_natCast","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : DivInvMonoid G\na : G\nn : Nat\n⊢ Eq (HPow.hPow a ↑n) (HPow.hPow a n)","decl":"@[to_additive (attr := simp, norm_cast) natCast_zsmul]\ntheorem zpow_natCast (a : G) : ∀ n : ℕ, a ^ (n : ℤ) = a ^ n\n  | 0 => (zpow_zero _).trans (pow_zero _).symm\n  | n + 1 => calc\n    a ^ (↑(n + 1) : ℤ) = a ^ (n : ℤ) * a := DivInvMonoid.zpow_succ' _ _\n    _ = a ^ n * a := congrArg (· * a) (zpow_natCast a n)\n    _ = a ^ (n + 1) := (pow_succ _ _).symm\n\n\n"}
{"name":"zpow_ofNat","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : DivInvMonoid G\na : G\nn : Nat\n⊢ Eq (HPow.hPow a (OfNat.ofNat n)) (HPow.hPow a (OfNat.ofNat n))","decl":"@[to_additive ofNat_zsmul]\nlemma zpow_ofNat (a : G) (n : ℕ) : a ^ (ofNat(n) : ℤ) = a ^ OfNat.ofNat n :=\n  zpow_natCast ..\n\n"}
{"name":"ofNat_zsmul","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : SubNegMonoid G\na : G\nn : Nat\n⊢ Eq (HSMul.hSMul (OfNat.ofNat n) a) (HSMul.hSMul (OfNat.ofNat n) a)","decl":"@[to_additive ofNat_zsmul]\nlemma zpow_ofNat (a : G) (n : ℕ) : a ^ (ofNat(n) : ℤ) = a ^ OfNat.ofNat n :=\n  zpow_natCast ..\n\n"}
{"name":"zpow_negSucc","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : DivInvMonoid G\na : G\nn : Nat\n⊢ Eq (HPow.hPow a (Int.negSucc n)) (Inv.inv (HPow.hPow a (HAdd.hAdd n 1)))","decl":"theorem zpow_negSucc (a : G) (n : ℕ) : a ^ (Int.negSucc n) = (a ^ (n + 1))⁻¹ := by\n  rw [← zpow_natCast]\n  exact DivInvMonoid.zpow_neg' n a\n\n"}
{"name":"negSucc_zsmul","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_2\ninst✝ : SubNegMonoid G\na : G\nn : Nat\n⊢ Eq (HSMul.hSMul (Int.negSucc n) a) (Neg.neg (HSMul.hSMul (HAdd.hAdd n 1) a))","decl":"theorem negSucc_zsmul {G} [SubNegMonoid G] (a : G) (n : ℕ) :\n    Int.negSucc n • a = -((n + 1) • a) := by\n  rw [← natCast_zsmul]\n  exact SubNegMonoid.zsmul_neg' n a\n\n"}
{"name":"sub_eq_add_neg","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : SubNegMonoid G\na b : G\n⊢ Eq (HSub.hSub a b) (HAdd.hAdd a (Neg.neg b))","decl":"/-- Dividing by an element is the same as multiplying by its inverse.\n\nThis is a duplicate of `DivInvMonoid.div_eq_mul_inv` ensuring that the types unfold better.\n-/\n@[to_additive \"Subtracting an element is the same as adding by its negative.\nThis is a duplicate of `SubNegMonoid.sub_eq_mul_neg` ensuring that the types unfold better.\"]\ntheorem div_eq_mul_inv (a b : G) : a / b = a * b⁻¹ :=\n  DivInvMonoid.div_eq_mul_inv _ _\n\n"}
{"name":"div_eq_mul_inv","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : DivInvMonoid G\na b : G\n⊢ Eq (HDiv.hDiv a b) (HMul.hMul a (Inv.inv b))","decl":"/-- Dividing by an element is the same as multiplying by its inverse.\n\nThis is a duplicate of `DivInvMonoid.div_eq_mul_inv` ensuring that the types unfold better.\n-/\n@[to_additive \"Subtracting an element is the same as adding by its negative.\nThis is a duplicate of `SubNegMonoid.sub_eq_mul_neg` ensuring that the types unfold better.\"]\ntheorem div_eq_mul_inv (a b : G) : a / b = a * b⁻¹ :=\n  DivInvMonoid.div_eq_mul_inv _ _\n\n"}
{"name":"division_def","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : DivInvMonoid G\na b : G\n⊢ Eq (HDiv.hDiv a b) (HMul.hMul a (Inv.inv b))","decl":"alias division_def := div_eq_mul_inv\n\n"}
{"name":"one_zsmul","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : SubNegMonoid G\na : G\n⊢ Eq (HSMul.hSMul 1 a) a","decl":"@[to_additive (attr := simp) one_zsmul]\nlemma zpow_one (a : G) : a ^ (1 : ℤ) = a := by rw [zpow_ofNat, pow_one]\n\n"}
{"name":"zpow_one","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : DivInvMonoid G\na : G\n⊢ Eq (HPow.hPow a 1) a","decl":"@[to_additive (attr := simp) one_zsmul]\nlemma zpow_one (a : G) : a ^ (1 : ℤ) = a := by rw [zpow_ofNat, pow_one]\n\n"}
{"name":"zpow_two","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : DivInvMonoid G\na : G\n⊢ Eq (HPow.hPow a 2) (HMul.hMul a a)","decl":"@[to_additive two_zsmul] lemma zpow_two (a : G) : a ^ (2 : ℤ) = a * a := by rw [zpow_ofNat, pow_two]\n\n"}
{"name":"two_zsmul","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : SubNegMonoid G\na : G\n⊢ Eq (HSMul.hSMul 2 a) (HAdd.hAdd a a)","decl":"@[to_additive two_zsmul] lemma zpow_two (a : G) : a ^ (2 : ℤ) = a * a := by rw [zpow_ofNat, pow_two]\n\n"}
{"name":"zpow_neg_one","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : DivInvMonoid G\nx : G\n⊢ Eq (HPow.hPow x (-1)) (Inv.inv x)","decl":"@[to_additive neg_one_zsmul]\nlemma zpow_neg_one (x : G) : x ^ (-1 : ℤ) = x⁻¹ :=\n  (zpow_negSucc x 0).trans <| congr_arg Inv.inv (pow_one x)\n\n"}
{"name":"neg_one_zsmul","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : SubNegMonoid G\nx : G\n⊢ Eq (HSMul.hSMul (-1) x) (Neg.neg x)","decl":"@[to_additive neg_one_zsmul]\nlemma zpow_neg_one (x : G) : x ^ (-1 : ℤ) = x⁻¹ :=\n  (zpow_negSucc x 0).trans <| congr_arg Inv.inv (pow_one x)\n\n"}
{"name":"zsmul_neg_coe_of_pos","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : SubNegMonoid G\na : G\nn : Nat\na✝ : LT.lt 0 n\n⊢ Eq (HSMul.hSMul (Neg.neg ↑n) a) (Neg.neg (HSMul.hSMul n a))","decl":"@[to_additive]\nlemma zpow_neg_coe_of_pos (a : G) : ∀ {n : ℕ}, 0 < n → a ^ (-(n : ℤ)) = (a ^ n)⁻¹\n  | _ + 1, _ => zpow_negSucc _ _\n\n"}
{"name":"zpow_neg_coe_of_pos","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : DivInvMonoid G\na : G\nn : Nat\na✝ : LT.lt 0 n\n⊢ Eq (HPow.hPow a (Neg.neg ↑n)) (Inv.inv (HPow.hPow a n))","decl":"@[to_additive]\nlemma zpow_neg_coe_of_pos (a : G) : ∀ {n : ℕ}, 0 < n → a ^ (-(n : ℤ)) = (a ^ n)⁻¹\n  | _ + 1, _ => zpow_negSucc _ _\n\n"}
{"name":"NegZeroClass.neg_zero","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_2\nself : NegZeroClass G\n⊢ Eq (-0) 0","decl":"/-- Typeclass for expressing that `-0 = 0`. -/\nclass NegZeroClass (G : Type*) extends Zero G, Neg G where\n  protected neg_zero : -(0 : G) = 0\n\n"}
{"name":"SubNegZeroMonoid.neg_zero","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_2\nself : SubNegZeroMonoid G\n⊢ Eq (-0) 0","decl":"/-- A `SubNegMonoid` where `-0 = 0`. -/\nclass SubNegZeroMonoid (G : Type*) extends SubNegMonoid G, NegZeroClass G\n\n"}
{"name":"InvOneClass.inv_one","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_2\nself : InvOneClass G\n⊢ Eq (Inv.inv 1) 1","decl":"/-- Typeclass for expressing that `1⁻¹ = 1`. -/\n@[to_additive]\nclass InvOneClass (G : Type*) extends One G, Inv G where\n  protected inv_one : (1 : G)⁻¹ = 1\n\n"}
{"name":"DivInvOneMonoid.inv_one","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_2\nself : DivInvOneMonoid G\n⊢ Eq (Inv.inv 1) 1","decl":"/-- A `DivInvMonoid` where `1⁻¹ = 1`. -/\n@[to_additive]\nclass DivInvOneMonoid (G : Type*) extends DivInvMonoid G, InvOneClass G\n\n"}
{"name":"inv_one","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : InvOneClass G\n⊢ Eq (Inv.inv 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem inv_one : (1 : G)⁻¹ = 1 :=\n  InvOneClass.inv_one\n\n"}
{"name":"neg_zero","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : NegZeroClass G\n⊢ Eq (-0) 0","decl":"@[to_additive (attr := simp)]\ntheorem inv_one : (1 : G)⁻¹ = 1 :=\n  InvOneClass.inv_one\n\n"}
{"name":"SubtractionMonoid.neg_neg","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nself : SubtractionMonoid G\nx : G\n⊢ Eq (Neg.neg (Neg.neg x)) x","decl":"/-- A `SubtractionMonoid` is a `SubNegMonoid` with involutive negation and such that\n`-(a + b) = -b + -a` and `a + b = 0 → -a = b`. -/\nclass SubtractionMonoid (G : Type u) extends SubNegMonoid G, InvolutiveNeg G where\n  protected neg_add_rev (a b : G) : -(a + b) = -b + -a\n  /-- Despite the asymmetry of `neg_eq_of_add`, the symmetric version is true thanks to the\n  involutivity of negation. -/\n  protected neg_eq_of_add (a b : G) : a + b = 0 → -a = b\n\n"}
{"name":"SubtractionMonoid.neg_add_rev","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nself : SubtractionMonoid G\na b : G\n⊢ Eq (Neg.neg (HAdd.hAdd a b)) (HAdd.hAdd (Neg.neg b) (Neg.neg a))","decl":"/-- A `SubtractionMonoid` is a `SubNegMonoid` with involutive negation and such that\n`-(a + b) = -b + -a` and `a + b = 0 → -a = b`. -/\nclass SubtractionMonoid (G : Type u) extends SubNegMonoid G, InvolutiveNeg G where\n  protected neg_add_rev (a b : G) : -(a + b) = -b + -a\n  /-- Despite the asymmetry of `neg_eq_of_add`, the symmetric version is true thanks to the\n  involutivity of negation. -/\n  protected neg_eq_of_add (a b : G) : a + b = 0 → -a = b\n\n"}
{"name":"SubtractionMonoid.neg_eq_of_add","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nself : SubtractionMonoid G\na b : G\na✝ : Eq (HAdd.hAdd a b) 0\n⊢ Eq (Neg.neg a) b","decl":"/-- A `SubtractionMonoid` is a `SubNegMonoid` with involutive negation and such that\n`-(a + b) = -b + -a` and `a + b = 0 → -a = b`. -/\nclass SubtractionMonoid (G : Type u) extends SubNegMonoid G, InvolutiveNeg G where\n  protected neg_add_rev (a b : G) : -(a + b) = -b + -a\n  /-- Despite the asymmetry of `neg_eq_of_add`, the symmetric version is true thanks to the\n  involutivity of negation. -/\n  protected neg_eq_of_add (a b : G) : a + b = 0 → -a = b\n\n"}
{"name":"DivisionMonoid.mul_inv_rev","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nself : DivisionMonoid G\na b : G\n⊢ Eq (Inv.inv (HMul.hMul a b)) (HMul.hMul (Inv.inv b) (Inv.inv a))","decl":"/-- A `DivisionMonoid` is a `DivInvMonoid` with involutive inversion and such that\n`(a * b)⁻¹ = b⁻¹ * a⁻¹` and `a * b = 1 → a⁻¹ = b`.\n\nThis is the immediate common ancestor of `Group` and `GroupWithZero`. -/\n@[to_additive]\nclass DivisionMonoid (G : Type u) extends DivInvMonoid G, InvolutiveInv G where\n  protected mul_inv_rev (a b : G) : (a * b)⁻¹ = b⁻¹ * a⁻¹\n  /-- Despite the asymmetry of `inv_eq_of_mul`, the symmetric version is true thanks to the\n  involutivity of inversion. -/\n  protected inv_eq_of_mul (a b : G) : a * b = 1 → a⁻¹ = b\n\n"}
{"name":"DivisionMonoid.inv_eq_of_mul","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nself : DivisionMonoid G\na b : G\na✝ : Eq (HMul.hMul a b) 1\n⊢ Eq (Inv.inv a) b","decl":"/-- A `DivisionMonoid` is a `DivInvMonoid` with involutive inversion and such that\n`(a * b)⁻¹ = b⁻¹ * a⁻¹` and `a * b = 1 → a⁻¹ = b`.\n\nThis is the immediate common ancestor of `Group` and `GroupWithZero`. -/\n@[to_additive]\nclass DivisionMonoid (G : Type u) extends DivInvMonoid G, InvolutiveInv G where\n  protected mul_inv_rev (a b : G) : (a * b)⁻¹ = b⁻¹ * a⁻¹\n  /-- Despite the asymmetry of `inv_eq_of_mul`, the symmetric version is true thanks to the\n  involutivity of inversion. -/\n  protected inv_eq_of_mul (a b : G) : a * b = 1 → a⁻¹ = b\n\n"}
{"name":"DivisionMonoid.inv_inv","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nself : DivisionMonoid G\nx : G\n⊢ Eq (Inv.inv (Inv.inv x)) x","decl":"/-- A `DivisionMonoid` is a `DivInvMonoid` with involutive inversion and such that\n`(a * b)⁻¹ = b⁻¹ * a⁻¹` and `a * b = 1 → a⁻¹ = b`.\n\nThis is the immediate common ancestor of `Group` and `GroupWithZero`. -/\n@[to_additive]\nclass DivisionMonoid (G : Type u) extends DivInvMonoid G, InvolutiveInv G where\n  protected mul_inv_rev (a b : G) : (a * b)⁻¹ = b⁻¹ * a⁻¹\n  /-- Despite the asymmetry of `inv_eq_of_mul`, the symmetric version is true thanks to the\n  involutivity of inversion. -/\n  protected inv_eq_of_mul (a b : G) : a * b = 1 → a⁻¹ = b\n\n"}
{"name":"neg_add_rev","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : SubtractionMonoid G\na b : G\n⊢ Eq (Neg.neg (HAdd.hAdd a b)) (HAdd.hAdd (Neg.neg b) (Neg.neg a))","decl":"@[to_additive (attr := simp) neg_add_rev]\ntheorem mul_inv_rev (a b : G) : (a * b)⁻¹ = b⁻¹ * a⁻¹ :=\n  DivisionMonoid.mul_inv_rev _ _\n\n"}
{"name":"mul_inv_rev","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : DivisionMonoid G\na b : G\n⊢ Eq (Inv.inv (HMul.hMul a b)) (HMul.hMul (Inv.inv b) (Inv.inv a))","decl":"@[to_additive (attr := simp) neg_add_rev]\ntheorem mul_inv_rev (a b : G) : (a * b)⁻¹ = b⁻¹ * a⁻¹ :=\n  DivisionMonoid.mul_inv_rev _ _\n\n"}
{"name":"inv_eq_of_mul_eq_one_right","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : DivisionMonoid G\na b : G\na✝ : Eq (HMul.hMul a b) 1\n⊢ Eq (Inv.inv a) b","decl":"@[to_additive]\ntheorem inv_eq_of_mul_eq_one_right : a * b = 1 → a⁻¹ = b :=\n  DivisionMonoid.inv_eq_of_mul _ _\n\n"}
{"name":"neg_eq_of_add_eq_zero_right","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : SubtractionMonoid G\na b : G\na✝ : Eq (HAdd.hAdd a b) 0\n⊢ Eq (Neg.neg a) b","decl":"@[to_additive]\ntheorem inv_eq_of_mul_eq_one_right : a * b = 1 → a⁻¹ = b :=\n  DivisionMonoid.inv_eq_of_mul _ _\n\n"}
{"name":"neg_eq_of_add_eq_zero_left","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : SubtractionMonoid G\na b : G\nh : Eq (HAdd.hAdd a b) 0\n⊢ Eq (Neg.neg b) a","decl":"@[to_additive]\ntheorem inv_eq_of_mul_eq_one_left (h : a * b = 1) : b⁻¹ = a := by\n  rw [← inv_eq_of_mul_eq_one_right h, inv_inv]\n\n"}
{"name":"inv_eq_of_mul_eq_one_left","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : DivisionMonoid G\na b : G\nh : Eq (HMul.hMul a b) 1\n⊢ Eq (Inv.inv b) a","decl":"@[to_additive]\ntheorem inv_eq_of_mul_eq_one_left (h : a * b = 1) : b⁻¹ = a := by\n  rw [← inv_eq_of_mul_eq_one_right h, inv_inv]\n\n"}
{"name":"eq_neg_of_add_eq_zero_left","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : SubtractionMonoid G\na b : G\nh : Eq (HAdd.hAdd a b) 0\n⊢ Eq a (Neg.neg b)","decl":"@[to_additive]\ntheorem eq_inv_of_mul_eq_one_left (h : a * b = 1) : a = b⁻¹ :=\n  (inv_eq_of_mul_eq_one_left h).symm\n\n"}
{"name":"eq_inv_of_mul_eq_one_left","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : DivisionMonoid G\na b : G\nh : Eq (HMul.hMul a b) 1\n⊢ Eq a (Inv.inv b)","decl":"@[to_additive]\ntheorem eq_inv_of_mul_eq_one_left (h : a * b = 1) : a = b⁻¹ :=\n  (inv_eq_of_mul_eq_one_left h).symm\n\n"}
{"name":"SubtractionCommMonoid.add_comm","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nself : SubtractionCommMonoid G\na b : G\n⊢ Eq (HAdd.hAdd a b) (HAdd.hAdd b a)","decl":"/-- Commutative `SubtractionMonoid`. -/\nclass SubtractionCommMonoid (G : Type u) extends SubtractionMonoid G, AddCommMonoid G\n\n"}
{"name":"DivisionCommMonoid.mul_comm","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nself : DivisionCommMonoid G\na b : G\n⊢ Eq (HMul.hMul a b) (HMul.hMul b a)","decl":"/-- Commutative `DivisionMonoid`.\n\nThis is the immediate common ancestor of `CommGroup` and `CommGroupWithZero`. -/\n@[to_additive SubtractionCommMonoid]\nclass DivisionCommMonoid (G : Type u) extends DivisionMonoid G, CommMonoid G\n\n"}
{"name":"Group.inv_mul_cancel","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nself : Group G\na : G\n⊢ Eq (HMul.hMul (Inv.inv a) a) 1","decl":"/-- A `Group` is a `Monoid` with an operation `⁻¹` satisfying `a⁻¹ * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b⁻¹`,\nwith a default so that `a / b = a * b⁻¹` holds by definition.\n\nUse `Group.ofLeftAxioms` or `Group.ofRightAxioms` to define a group structure\non a type with the minimum proof obligations.\n-/\nclass Group (G : Type u) extends DivInvMonoid G where\n  protected inv_mul_cancel : ∀ a : G, a⁻¹ * a = 1\n\n"}
{"name":"AddGroup.neg_add_cancel","module":"Mathlib.Algebra.Group.Defs","initialProofState":"A : Type u\nself : AddGroup A\na : A\n⊢ Eq (HAdd.hAdd (Neg.neg a) a) 0","decl":"/-- An `AddGroup` is an `AddMonoid` with a unary `-` satisfying `-a + a = 0`.\n\nThere is also a binary operation `-` such that `a - b = a + -b`,\nwith a default so that `a - b = a + -b` holds by definition.\n\nUse `AddGroup.ofLeftAxioms` or `AddGroup.ofRightAxioms` to define an\nadditive group structure on a type with the minimum proof obligations.\n-/\nclass AddGroup (A : Type u) extends SubNegMonoid A where\n  protected neg_add_cancel : ∀ a : A, -a + a = 0\n\n"}
{"name":"inv_mul_cancel","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\na : G\n⊢ Eq (HMul.hMul (Inv.inv a) a) 1","decl":"@[to_additive (attr := simp)]\ntheorem inv_mul_cancel (a : G) : a⁻¹ * a = 1 :=\n  Group.inv_mul_cancel a\n\n"}
{"name":"neg_add_cancel","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\na : G\n⊢ Eq (HAdd.hAdd (Neg.neg a) a) 0","decl":"@[to_additive (attr := simp)]\ntheorem inv_mul_cancel (a : G) : a⁻¹ * a = 1 :=\n  Group.inv_mul_cancel a\n\n"}
{"name":"add_neg_cancel","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\na : G\n⊢ Eq (HAdd.hAdd a (Neg.neg a)) 0","decl":"@[to_additive (attr := simp)]\ntheorem mul_inv_cancel (a : G) : a * a⁻¹ = 1 := by\n  rw [← inv_mul_cancel a⁻¹, inv_eq_of_mul (inv_mul_cancel a)]\n\n"}
{"name":"mul_inv_cancel","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\na : G\n⊢ Eq (HMul.hMul a (Inv.inv a)) 1","decl":"@[to_additive (attr := simp)]\ntheorem mul_inv_cancel (a : G) : a * a⁻¹ = 1 := by\n  rw [← inv_mul_cancel a⁻¹, inv_eq_of_mul (inv_mul_cancel a)]\n\n"}
{"name":"mul_left_inv","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\na : G\n⊢ Eq (HMul.hMul (Inv.inv a) a) 1","decl":"@[deprecated (since := \"2024-08-12\")] alias mul_left_inv := inv_mul_cancel\n"}
{"name":"mul_right_inv","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\na : G\n⊢ Eq (HMul.hMul a (Inv.inv a)) 1","decl":"@[deprecated (since := \"2024-08-12\")] alias mul_right_inv := mul_inv_cancel\n"}
{"name":"add_left_neg","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\na : G\n⊢ Eq (HAdd.hAdd (Neg.neg a) a) 0","decl":"@[deprecated (since := \"2024-08-12\")] alias add_left_neg := neg_add_cancel\n"}
{"name":"add_right_neg","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\na : G\n⊢ Eq (HAdd.hAdd a (Neg.neg a)) 0","decl":"@[deprecated (since := \"2024-08-12\")] alias add_right_neg := add_neg_cancel\n"}
{"name":"inv_mul_self","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\na : G\n⊢ Eq (HMul.hMul (Inv.inv a) a) 1","decl":"@[deprecated (since := \"2024-08-12\")] alias inv_mul_self := inv_mul_cancel\n"}
{"name":"mul_inv_self","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\na : G\n⊢ Eq (HMul.hMul a (Inv.inv a)) 1","decl":"@[deprecated (since := \"2024-08-12\")] alias mul_inv_self := mul_inv_cancel\n"}
{"name":"neg_add_self","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\na : G\n⊢ Eq (HAdd.hAdd (Neg.neg a) a) 0","decl":"@[deprecated (since := \"2024-08-12\")] alias neg_add_self := neg_add_cancel\n"}
{"name":"add_right_self","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\na : G\n⊢ Eq (HAdd.hAdd a (Neg.neg a)) 0","decl":"@[deprecated (since := \"2024-08-12\")] alias add_right_self := add_neg_cancel\n\n"}
{"name":"neg_add_cancel_left","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\na b : G\n⊢ Eq (HAdd.hAdd (Neg.neg a) (HAdd.hAdd a b)) b","decl":"@[to_additive (attr := simp)]\ntheorem inv_mul_cancel_left (a b : G) : a⁻¹ * (a * b) = b := by\n  rw [← mul_assoc, inv_mul_cancel, one_mul]\n\n"}
{"name":"inv_mul_cancel_left","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\na b : G\n⊢ Eq (HMul.hMul (Inv.inv a) (HMul.hMul a b)) b","decl":"@[to_additive (attr := simp)]\ntheorem inv_mul_cancel_left (a b : G) : a⁻¹ * (a * b) = b := by\n  rw [← mul_assoc, inv_mul_cancel, one_mul]\n\n"}
{"name":"mul_inv_cancel_left","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\na b : G\n⊢ Eq (HMul.hMul a (HMul.hMul (Inv.inv a) b)) b","decl":"@[to_additive (attr := simp)]\ntheorem mul_inv_cancel_left (a b : G) : a * (a⁻¹ * b) = b := by\n  rw [← mul_assoc, mul_inv_cancel, one_mul]\n\n"}
{"name":"add_neg_cancel_left","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\na b : G\n⊢ Eq (HAdd.hAdd a (HAdd.hAdd (Neg.neg a) b)) b","decl":"@[to_additive (attr := simp)]\ntheorem mul_inv_cancel_left (a b : G) : a * (a⁻¹ * b) = b := by\n  rw [← mul_assoc, mul_inv_cancel, one_mul]\n\n"}
{"name":"mul_inv_cancel_right","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\na b : G\n⊢ Eq (HMul.hMul (HMul.hMul a b) (Inv.inv b)) a","decl":"@[to_additive (attr := simp)]\ntheorem mul_inv_cancel_right (a b : G) : a * b * b⁻¹ = a := by\n  rw [mul_assoc, mul_inv_cancel, mul_one]\n\n"}
{"name":"add_neg_cancel_right","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\na b : G\n⊢ Eq (HAdd.hAdd (HAdd.hAdd a b) (Neg.neg b)) a","decl":"@[to_additive (attr := simp)]\ntheorem mul_inv_cancel_right (a b : G) : a * b * b⁻¹ = a := by\n  rw [mul_assoc, mul_inv_cancel, mul_one]\n\n"}
{"name":"neg_add_cancel_right","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\na b : G\n⊢ Eq (HAdd.hAdd (HAdd.hAdd a (Neg.neg b)) b) a","decl":"@[to_additive (attr := simp)]\ntheorem inv_mul_cancel_right (a b : G) : a * b⁻¹ * b = a := by\n  rw [mul_assoc, inv_mul_cancel, mul_one]\n\n"}
{"name":"inv_mul_cancel_right","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\na b : G\n⊢ Eq (HMul.hMul (HMul.hMul a (Inv.inv b)) b) a","decl":"@[to_additive (attr := simp)]\ntheorem inv_mul_cancel_right (a b : G) : a * b⁻¹ * b = a := by\n  rw [mul_assoc, inv_mul_cancel, mul_one]\n\n"}
{"name":"AddCommGroup.add_comm","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nself : AddCommGroup G\na b : G\n⊢ Eq (HAdd.hAdd a b) (HAdd.hAdd b a)","decl":"/-- An additive commutative group is an additive group with commutative `(+)`. -/\nclass AddCommGroup (G : Type u) extends AddGroup G, AddCommMonoid G\n\n"}
{"name":"CommGroup.mul_comm","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u\nself : CommGroup G\na b : G\n⊢ Eq (HMul.hMul a b) (HMul.hMul b a)","decl":"/-- A commutative group is a group with commutative `(*)`. -/\n@[to_additive]\nclass CommGroup (G : Type u) extends Group G, CommMonoid G\n\n"}
{"name":"neg_add_cancel_comm","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : AddCommGroup G\na b : G\n⊢ Eq (HAdd.hAdd (HAdd.hAdd (Neg.neg a) b) a) b","decl":"@[to_additive (attr := simp)] lemma inv_mul_cancel_comm (a b : G) : a⁻¹ * b * a = b := by\n  rw [mul_comm, mul_inv_cancel_left]\n\n"}
{"name":"inv_mul_cancel_comm","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : CommGroup G\na b : G\n⊢ Eq (HMul.hMul (HMul.hMul (Inv.inv a) b) a) b","decl":"@[to_additive (attr := simp)] lemma inv_mul_cancel_comm (a b : G) : a⁻¹ * b * a = b := by\n  rw [mul_comm, mul_inv_cancel_left]\n\n"}
{"name":"mul_inv_cancel_comm","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : CommGroup G\na b : G\n⊢ Eq (HMul.hMul (HMul.hMul a b) (Inv.inv a)) b","decl":"@[to_additive (attr := simp)]\nlemma mul_inv_cancel_comm (a b : G) : a * b * a⁻¹ = b := by rw [mul_comm, inv_mul_cancel_left]\n\n"}
{"name":"add_neg_cancel_comm","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : AddCommGroup G\na b : G\n⊢ Eq (HAdd.hAdd (HAdd.hAdd a b) (Neg.neg a)) b","decl":"@[to_additive (attr := simp)]\nlemma mul_inv_cancel_comm (a b : G) : a * b * a⁻¹ = b := by rw [mul_comm, inv_mul_cancel_left]\n\n"}
{"name":"inv_mul_cancel_comm_assoc","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : CommGroup G\na b : G\n⊢ Eq (HMul.hMul (Inv.inv a) (HMul.hMul b a)) b","decl":"@[to_additive (attr := simp)] lemma inv_mul_cancel_comm_assoc (a b : G) : a⁻¹ * (b * a) = b := by\n  rw [mul_comm, mul_inv_cancel_right]\n\n"}
{"name":"neg_add_cancel_comm_assoc","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : AddCommGroup G\na b : G\n⊢ Eq (HAdd.hAdd (Neg.neg a) (HAdd.hAdd b a)) b","decl":"@[to_additive (attr := simp)] lemma inv_mul_cancel_comm_assoc (a b : G) : a⁻¹ * (b * a) = b := by\n  rw [mul_comm, mul_inv_cancel_right]\n\n"}
{"name":"mul_inv_cancel_comm_assoc","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : CommGroup G\na b : G\n⊢ Eq (HMul.hMul a (HMul.hMul b (Inv.inv a))) b","decl":"@[to_additive (attr := simp)] lemma mul_inv_cancel_comm_assoc (a b : G) : a * (b * a⁻¹) = b := by\n  rw [mul_comm, inv_mul_cancel_right]\n\n"}
{"name":"add_neg_cancel_comm_assoc","module":"Mathlib.Algebra.Group.Defs","initialProofState":"G : Type u_1\ninst✝ : AddCommGroup G\na b : G\n⊢ Eq (HAdd.hAdd a (HAdd.hAdd b (Neg.neg a))) b","decl":"@[to_additive (attr := simp)] lemma mul_inv_cancel_comm_assoc (a b : G) : a * (b * a⁻¹) = b := by\n  rw [mul_comm, inv_mul_cancel_right]\n\n"}
