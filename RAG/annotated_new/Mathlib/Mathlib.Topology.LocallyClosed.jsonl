{"name":"subset_coborder","module":"Mathlib.Topology.LocallyClosed","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ HasSubset.Subset s (coborder s)","decl":"lemma subset_coborder :\n    s ⊆ coborder s := by\n  rw [coborder, subset_compl_iff_disjoint_right]\n  exact disjoint_sdiff_self_right\n\n"}
{"name":"coborder_inter_closure","module":"Mathlib.Topology.LocallyClosed","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Eq (Inter.inter (coborder s) (closure s)) s","decl":"lemma coborder_inter_closure :\n    coborder s ∩ closure s = s := by\n  rw [coborder, ← diff_eq_compl_inter, diff_diff_right_self, inter_eq_right]\n  exact subset_closure\n\n"}
{"name":"closure_inter_coborder","module":"Mathlib.Topology.LocallyClosed","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Eq (Inter.inter (closure s) (coborder s)) s","decl":"lemma closure_inter_coborder :\n    closure s ∩ coborder s = s := by\n  rw [inter_comm, coborder_inter_closure]\n\n"}
{"name":"coborder_eq_union_frontier_compl","module":"Mathlib.Topology.LocallyClosed","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Eq (coborder s) (Union.union s (HasCompl.compl (frontier s)))","decl":"lemma coborder_eq_union_frontier_compl :\n    coborder s = s ∪ (frontier s)ᶜ := by\n  rw [coborder, compl_eq_comm, compl_union, compl_compl, ← diff_eq_compl_inter,\n    ← union_diff_right, union_comm, ← closure_eq_self_union_frontier]\n\n"}
{"name":"coborder_eq_univ_iff","module":"Mathlib.Topology.LocallyClosed","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (Eq (coborder s) Set.univ) (IsClosed s)","decl":"lemma coborder_eq_univ_iff :\n    coborder s = univ ↔ IsClosed s := by\n  simp [coborder, diff_eq_empty, closure_subset_iff_isClosed]\n\n"}
{"name":"IsClosed.coborder_eq","module":"Mathlib.Topology.LocallyClosed","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\na✝ : IsClosed s\n⊢ Eq (coborder s) Set.univ","decl":"alias ⟨_, IsClosed.coborder_eq⟩ := coborder_eq_univ_iff\n\n"}
{"name":"coborder_eq_compl_frontier_iff","module":"Mathlib.Topology.LocallyClosed","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (Eq (coborder s) (HasCompl.compl (frontier s))) (IsOpen s)","decl":"lemma coborder_eq_compl_frontier_iff :\n    coborder s = (frontier s)ᶜ ↔ IsOpen s := by\n  simp_rw [coborder_eq_union_frontier_compl, union_eq_right, subset_compl_iff_disjoint_left,\n    disjoint_frontier_iff_isOpen]\n\n"}
{"name":"coborder_eq_union_closure_compl","module":"Mathlib.Topology.LocallyClosed","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Eq (coborder s) (Union.union s (HasCompl.compl (closure s)))","decl":"theorem coborder_eq_union_closure_compl {s : Set X} : coborder s = s ∪ (closure s)ᶜ := by\n  rw [coborder, compl_eq_comm, compl_union, compl_compl, inter_comm]\n  rfl\n\n"}
{"name":"dense_coborder","module":"Mathlib.Topology.LocallyClosed","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Dense (coborder s)","decl":"/-- The coborder of any set is dense -/\ntheorem dense_coborder {s : Set X} :\n    Dense (coborder s) := by\n  rw [dense_iff_closure_eq, coborder_eq_union_closure_compl, closure_union, ← univ_subset_iff]\n  refine _root_.subset_trans ?_ (union_subset_union_right _ (subset_closure))\n  simp\n\n"}
{"name":"IsOpen.coborder_eq","module":"Mathlib.Topology.LocallyClosed","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\na✝ : IsOpen s\n⊢ Eq (coborder s) (HasCompl.compl (frontier s))","decl":"alias ⟨_, IsOpen.coborder_eq⟩ := coborder_eq_compl_frontier_iff\n\n"}
{"name":"IsOpenMap.coborder_preimage_subset","module":"Mathlib.Topology.LocallyClosed","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : IsOpenMap f\ns : Set Y\n⊢ HasSubset.Subset (coborder (Set.preimage f s)) (Set.preimage f (coborder s))","decl":"lemma IsOpenMap.coborder_preimage_subset (hf : IsOpenMap f) (s : Set Y) :\n    coborder (f ⁻¹' s) ⊆ f ⁻¹' (coborder s) := by\n  rw [coborder, coborder, preimage_compl, preimage_diff, compl_subset_compl]\n  apply diff_subset_diff_left\n  exact hf.preimage_closure_subset_closure_preimage\n\n"}
{"name":"Continuous.preimage_coborder_subset","module":"Mathlib.Topology.LocallyClosed","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Continuous f\ns : Set Y\n⊢ HasSubset.Subset (Set.preimage f (coborder s)) (coborder (Set.preimage f s))","decl":"lemma Continuous.preimage_coborder_subset (hf : Continuous f) (s : Set Y) :\n    f ⁻¹' (coborder s) ⊆ coborder (f ⁻¹' s) := by\n  rw [coborder, coborder, preimage_compl, preimage_diff, compl_subset_compl]\n  apply diff_subset_diff_left\n  exact hf.closure_preimage_subset s\n\n"}
{"name":"coborder_preimage","module":"Mathlib.Topology.LocallyClosed","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : IsOpenMap f\nhf' : Continuous f\ns : Set Y\n⊢ Eq (coborder (Set.preimage f s)) (Set.preimage f (coborder s))","decl":"lemma coborder_preimage (hf : IsOpenMap f) (hf' : Continuous f) (s : Set Y) :\n    coborder (f ⁻¹' s) = f ⁻¹' (coborder s) :=\n  (hf.coborder_preimage_subset s).antisymm (hf'.preimage_coborder_subset s)\n\n"}
{"name":"Topology.IsOpenEmbedding.coborder_preimage","module":"Mathlib.Topology.LocallyClosed","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Topology.IsOpenEmbedding f\ns : Set Y\n⊢ Eq (coborder (Set.preimage f s)) (Set.preimage f (coborder s))","decl":"protected\nlemma Topology.IsOpenEmbedding.coborder_preimage (hf : IsOpenEmbedding f) (s : Set Y) :\n    coborder (f ⁻¹' s) = f ⁻¹' coborder s :=\n  coborder_preimage hf.isOpenMap hf.continuous s\n\n"}
{"name":"OpenEmbedding.coborder_preimage","module":"Mathlib.Topology.LocallyClosed","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Topology.IsOpenEmbedding f\ns : Set Y\n⊢ Eq (coborder (Set.preimage f s)) (Set.preimage f (coborder s))","decl":"@[deprecated (since := \"2024-10-18\")]\nalias OpenEmbedding.coborder_preimage := IsOpenEmbedding.coborder_preimage\n\n"}
{"name":"isClosed_preimage_val_coborder","module":"Mathlib.Topology.LocallyClosed","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ IsClosed (Set.preimage Subtype.val s)","decl":"lemma isClosed_preimage_val_coborder :\n    IsClosed (coborder s ↓∩ s) := by\n  rw [isClosed_preimage_val, inter_eq_right.mpr subset_coborder, coborder_inter_closure]\n\n"}
{"name":"IsLocallyClosed.inter","module":"Mathlib.Topology.LocallyClosed","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns t : Set X\nhs : IsLocallyClosed s\nht : IsLocallyClosed t\n⊢ IsLocallyClosed (Inter.inter s t)","decl":"lemma IsLocallyClosed.inter (hs : IsLocallyClosed s) (ht : IsLocallyClosed t) :\n    IsLocallyClosed (s ∩ t) := by\n  obtain ⟨U₁, Z₁, hU₁, hZ₁, rfl⟩ := hs\n  obtain ⟨U₂, Z₂, hU₂, hZ₂, rfl⟩ := ht\n  refine ⟨_, _, hU₁.inter hU₂, hZ₁.inter hZ₂, inter_inter_inter_comm U₁ Z₁ U₂ Z₂⟩\n\n"}
{"name":"IsLocallyClosed.preimage","module":"Mathlib.Topology.LocallyClosed","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set Y\nhs : IsLocallyClosed s\nf : X → Y\nhf : Continuous f\n⊢ IsLocallyClosed (Set.preimage f s)","decl":"lemma IsLocallyClosed.preimage {s : Set Y} (hs : IsLocallyClosed s)\n    {f : X → Y} (hf : Continuous f) :\n    IsLocallyClosed (f ⁻¹' s) := by\n  obtain ⟨U, Z, hU, hZ, rfl⟩ := hs\n  exact ⟨_, _, hU.preimage hf, hZ.preimage hf, preimage_inter⟩\n\n"}
{"name":"Topology.IsInducing.isLocallyClosed_iff","module":"Mathlib.Topology.LocallyClosed","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nf : X → Y\nhf : Topology.IsInducing f\n⊢ Iff (IsLocallyClosed s) (Exists fun s' => And (IsLocallyClosed s') (Eq (Set.preimage f s') s))","decl":"nonrec\nlemma Topology.IsInducing.isLocallyClosed_iff {s : Set X}\n    {f : X → Y} (hf : IsInducing f) :\n    IsLocallyClosed s ↔ ∃ s' : Set Y, IsLocallyClosed s' ∧ f ⁻¹' s' = s := by\n  simp_rw [IsLocallyClosed, hf.isOpen_iff, hf.isClosed_iff]\n  constructor\n  · rintro ⟨_, _, ⟨U, hU, rfl⟩, ⟨Z, hZ, rfl⟩, rfl⟩\n    exact ⟨_, ⟨U, Z, hU, hZ, rfl⟩, rfl⟩\n  · rintro ⟨_, ⟨U, Z, hU, hZ, rfl⟩, rfl⟩\n    exact ⟨_, _, ⟨U, hU, rfl⟩, ⟨Z, hZ, rfl⟩, rfl⟩\n\n"}
{"name":"Inducing.isLocallyClosed_iff","module":"Mathlib.Topology.LocallyClosed","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nf : X → Y\nhf : Topology.IsInducing f\n⊢ Iff (IsLocallyClosed s) (Exists fun s' => And (IsLocallyClosed s') (Eq (Set.preimage f s') s))","decl":"@[deprecated (since := \"2024-10-28\")]\nalias Inducing.isLocallyClosed_iff := IsInducing.isLocallyClosed_iff\n\n"}
{"name":"Topology.IsEmbedding.isLocallyClosed_iff","module":"Mathlib.Topology.LocallyClosed","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nf : X → Y\nhf : Topology.IsEmbedding f\n⊢ Iff (IsLocallyClosed s) (Exists fun s' => And (IsLocallyClosed s') (Eq (Inter.inter s' (Set.range f)) (Set.image f s)))","decl":"lemma Topology.IsEmbedding.isLocallyClosed_iff {s : Set X}\n    {f : X → Y} (hf : IsEmbedding f) :\n    IsLocallyClosed s ↔ ∃ s' : Set Y, IsLocallyClosed s' ∧ s' ∩ range f = f '' s := by\n  simp_rw [hf.isInducing.isLocallyClosed_iff,\n    ← (image_injective.mpr hf.injective).eq_iff, image_preimage_eq_inter_range]\n\n"}
{"name":"Embedding.isLocallyClosed_iff","module":"Mathlib.Topology.LocallyClosed","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nf : X → Y\nhf : Topology.IsEmbedding f\n⊢ Iff (IsLocallyClosed s) (Exists fun s' => And (IsLocallyClosed s') (Eq (Inter.inter s' (Set.range f)) (Set.image f s)))","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Embedding.isLocallyClosed_iff := IsEmbedding.isLocallyClosed_iff\n\n"}
{"name":"IsLocallyClosed.image","module":"Mathlib.Topology.LocallyClosed","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nhs : IsLocallyClosed s\nf : X → Y\nhf : Topology.IsInducing f\nhf' : IsLocallyClosed (Set.range f)\n⊢ IsLocallyClosed (Set.image f s)","decl":"lemma IsLocallyClosed.image {s : Set X} (hs : IsLocallyClosed s)\n    {f : X → Y} (hf : IsInducing f) (hf' : IsLocallyClosed (range f)) :\n    IsLocallyClosed (f '' s) := by\n  obtain ⟨t, ht, rfl⟩ := hf.isLocallyClosed_iff.mp hs\n  rw [image_preimage_eq_inter_range]\n  exact ht.inter hf'\n\n"}
{"name":"isLocallyClosed_tfae","module":"Mathlib.Topology.LocallyClosed","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ (List.cons (IsLocallyClosed s) (List.cons (IsOpen (coborder s)) (List.cons (∀ (x : X), Membership.mem s x → Exists fun U => And (Membership.mem (nhds x) U) (IsClosed (Set.preimage Subtype.val s))) (List.cons (∀ (x : X), Membership.mem s x → Exists fun U => And (Membership.mem U x) (And (IsOpen U) (HasSubset.Subset (Inter.inter U (closure s)) s))) (List.cons (IsOpen (Set.preimage Subtype.val s)) List.nil))))).TFAE","decl":"/--\nA set `s` is locally closed if one of the equivalent conditions below hold\n1. It is the intersection of some open set and some closed set.\n2. The coborder `(closure s \\ s)ᶜ` is open.\n3. `s` is closed in some neighborhood of `x` for all `x ∈ s`.\n4. Every `x ∈ s` has some open neighborhood `U` such that `U ∩ closure s ⊆ s`.\n5. `s` is open in the closure of `s`.\n-/\nlemma isLocallyClosed_tfae (s : Set X) :\n    List.TFAE\n    [ IsLocallyClosed s,\n      IsOpen (coborder s),\n      ∀ x ∈ s, ∃ U ∈ 𝓝 x, IsClosed (U ↓∩ s),\n      ∀ x ∈ s, ∃ U, x ∈ U ∧ IsOpen U ∧ U ∩ closure s ⊆ s,\n      IsOpen (closure s ↓∩ s)] := by\n  tfae_have 1 → 2 := by\n    rintro ⟨U, Z, hU, hZ, rfl⟩\n    have : Z ∪ (frontier (U ∩ Z))ᶜ = univ := by\n      nth_rw 1 [← hZ.closure_eq]\n      rw [← compl_subset_iff_union, compl_subset_compl]\n      refine frontier_subset_closure.trans (closure_mono inter_subset_right)\n    rw [coborder_eq_union_frontier_compl, inter_union_distrib_right, this,\n      inter_univ]\n    exact hU.union isClosed_frontier.isOpen_compl\n  tfae_have 2 → 3\n  | h, x => (⟨coborder s, h.mem_nhds <| subset_coborder ·, isClosed_preimage_val_coborder⟩)\n  tfae_have 3 → 4\n  | h, x, hx => by\n    obtain ⟨t, ht, ht'⟩ := h x hx\n    obtain ⟨U, hUt, hU, hxU⟩ := mem_nhds_iff.mp ht\n    rw [isClosed_preimage_val] at ht'\n    exact ⟨U, hxU, hU, (subset_inter (inter_subset_left.trans hUt) (hU.inter_closure.trans\n      (closure_mono <| inter_subset_inter hUt subset_rfl))).trans ht'⟩\n  tfae_have 4 → 5\n  | H => by\n    choose U hxU hU e using H\n    refine ⟨⋃ x ∈ s, U x ‹_›, isOpen_iUnion (isOpen_iUnion <| hU ·), ext fun x ↦ ⟨?_, ?_⟩⟩\n    · rintro ⟨_, ⟨⟨y, rfl⟩, ⟨_, ⟨hy, rfl⟩, hxU⟩⟩⟩\n      exact e y hy ⟨hxU, x.2⟩\n    · exact (subset_iUnion₂ _ _ <| hxU x ·)\n  tfae_have 5 → 1\n  | H => by\n    convert H.isLocallyClosed.image IsInducing.subtypeVal\n      (by simpa using isClosed_closure.isLocallyClosed)\n    simpa using subset_closure\n  tfae_finish\n\n"}
{"name":"isLocallyClosed_iff_isOpen_coborder","module":"Mathlib.Topology.LocallyClosed","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (IsLocallyClosed s) (IsOpen (coborder s))","decl":"lemma isLocallyClosed_iff_isOpen_coborder : IsLocallyClosed s ↔ IsOpen (coborder s) :=\n  (isLocallyClosed_tfae s).out 0 1\n\n"}
{"name":"IsLocallyClosed.isOpen_coborder","module":"Mathlib.Topology.LocallyClosed","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\na✝ : IsLocallyClosed s\n⊢ IsOpen (coborder s)","decl":"alias ⟨IsLocallyClosed.isOpen_coborder, _⟩ := isLocallyClosed_iff_isOpen_coborder\n\n"}
{"name":"IsLocallyClosed.isOpen_preimage_val_closure","module":"Mathlib.Topology.LocallyClosed","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsLocallyClosed s\n⊢ IsOpen (Set.preimage Subtype.val s)","decl":"lemma IsLocallyClosed.isOpen_preimage_val_closure (hs : IsLocallyClosed s) :\n    IsOpen (closure s ↓∩ s) :=\n  ((isLocallyClosed_tfae s).out 0 4).mp hs\n"}
