{"name":"Localization.map_isUnit_of_le","module":"Mathlib.RingTheory.Localization.AsSubring","initialProofState":"A : Type u_1\nK : Type u_2\ninst✝³ : CommRing A\nS : Submonoid A\ninst✝² : CommRing K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\nhS : LE.le S (nonZeroDivisors A)\ns : Subtype fun x => Membership.mem S x\n⊢ IsUnit ((algebraMap A K) ↑s)","decl":"theorem map_isUnit_of_le (hS : S ≤ A⁰) (s : S) : IsUnit (algebraMap A K s) := by\n  apply IsLocalization.map_units K (⟨s.1, hS s.2⟩ : A⁰)\n\n"}
{"name":"Localization.mapToFractionRing_apply","module":"Mathlib.RingTheory.Localization.AsSubring","initialProofState":"A : Type u_1\nK : Type u_2\ninst✝⁶ : CommRing A\nS : Submonoid A\ninst✝⁵ : CommRing K\ninst✝⁴ : Algebra A K\ninst✝³ : IsFractionRing A K\nB : Type u_3\ninst✝² : CommRing B\ninst✝¹ : Algebra A B\ninst✝ : IsLocalization S B\nhS : LE.le S (nonZeroDivisors A)\nb : B\n⊢ Eq ((Localization.mapToFractionRing K S B hS) b) ((IsLocalization.lift ⋯) b)","decl":"@[simp]\ntheorem mapToFractionRing_apply {B : Type*} [CommRing B] [Algebra A B] [IsLocalization S B]\n    (hS : S ≤ A⁰) (b : B) :\n    mapToFractionRing K S B hS b = IsLocalization.lift (map_isUnit_of_le K S hS) b :=\n  rfl\n\n"}
{"name":"Localization.mem_range_mapToFractionRing_iff","module":"Mathlib.RingTheory.Localization.AsSubring","initialProofState":"A : Type u_1\nK : Type u_2\ninst✝⁶ : CommRing A\nS : Submonoid A\ninst✝⁵ : CommRing K\ninst✝⁴ : Algebra A K\ninst✝³ : IsFractionRing A K\nB : Type u_3\ninst✝² : CommRing B\ninst✝¹ : Algebra A B\ninst✝ : IsLocalization S B\nhS : LE.le S (nonZeroDivisors A)\nx : K\n⊢ Iff (Membership.mem (Localization.mapToFractionRing K S B hS).range x) (Exists fun a => Exists fun s => Exists fun hs => Eq x (IsLocalization.mk' K a ⟨s, ⋯⟩))","decl":"theorem mem_range_mapToFractionRing_iff (B : Type*) [CommRing B] [Algebra A B] [IsLocalization S B]\n    (hS : S ≤ A⁰) (x : K) :\n    x ∈ (mapToFractionRing K S B hS).range ↔\n      ∃ (a s : A) (hs : s ∈ S), x = IsLocalization.mk' K a ⟨s, hS hs⟩ :=\n  ⟨by\n    rintro ⟨x, rfl⟩\n    obtain ⟨a, s, rfl⟩ := IsLocalization.mk'_surjective S x\n    use a, s, s.2\n    apply IsLocalization.lift_mk', by\n    rintro ⟨a, s, hs, rfl⟩\n    use IsLocalization.mk' _ a ⟨s, hs⟩\n    apply IsLocalization.lift_mk'⟩\n\n"}
{"name":"Localization.isLocalization_range_mapToFractionRing","module":"Mathlib.RingTheory.Localization.AsSubring","initialProofState":"A : Type u_1\nK : Type u_2\ninst✝⁶ : CommRing A\nS : Submonoid A\ninst✝⁵ : CommRing K\ninst✝⁴ : Algebra A K\ninst✝³ : IsFractionRing A K\nB : Type u_3\ninst✝² : CommRing B\ninst✝¹ : Algebra A B\ninst✝ : IsLocalization S B\nhS : LE.le S (nonZeroDivisors A)\n⊢ IsLocalization S (Subtype fun x => Membership.mem (Localization.mapToFractionRing K S B hS).range x)","decl":"instance isLocalization_range_mapToFractionRing (B : Type*) [CommRing B] [Algebra A B]\n    [IsLocalization S B] (hS : S ≤ A⁰) : IsLocalization S (mapToFractionRing K S B hS).range :=\n  IsLocalization.isLocalization_of_algEquiv S <|\n    show B ≃ₐ[A] _ from AlgEquiv.ofBijective (mapToFractionRing K S B hS).rangeRestrict (by\n      refine ⟨fun a b h => ?_, Set.surjective_onto_range⟩\n      refine (IsLocalization.lift_injective_iff _).2 (fun a b => ?_) (Subtype.ext_iff.1 h)\n      exact ⟨fun h => congr_arg _ (IsLocalization.injective _ hS h),\n        fun h => congr_arg _ (IsFractionRing.injective A K h)⟩)\n\n"}
{"name":"Localization.isFractionRing_range_mapToFractionRing","module":"Mathlib.RingTheory.Localization.AsSubring","initialProofState":"A : Type u_1\nK : Type u_2\ninst✝⁶ : CommRing A\nS : Submonoid A\ninst✝⁵ : CommRing K\ninst✝⁴ : Algebra A K\ninst✝³ : IsFractionRing A K\nB : Type u_3\ninst✝² : CommRing B\ninst✝¹ : Algebra A B\ninst✝ : IsLocalization S B\nhS : LE.le S (nonZeroDivisors A)\n⊢ IsFractionRing (Subtype fun x => Membership.mem (Localization.mapToFractionRing K S B hS).range x) K","decl":"instance isFractionRing_range_mapToFractionRing (B : Type*) [CommRing B] [Algebra A B]\n    [IsLocalization S B] (hS : S ≤ A⁰) : IsFractionRing (mapToFractionRing K S B hS).range K :=\n  IsFractionRing.isFractionRing_of_isLocalization S _ _ hS\n\n"}
{"name":"Localization.subalgebra.isLocalization_subalgebra","module":"Mathlib.RingTheory.Localization.AsSubring","initialProofState":"A : Type u_1\nK : Type u_2\ninst✝³ : CommRing A\nS : Submonoid A\nhS : LE.le S (nonZeroDivisors A)\ninst✝² : CommRing K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\n⊢ IsLocalization S (Subtype fun x => Membership.mem (Localization.subalgebra K S hS) x)","decl":"instance isLocalization_subalgebra : IsLocalization S (subalgebra K S hS) := by\n  dsimp only [Localization.subalgebra]\n  rw [Subalgebra.copy_eq]\n  infer_instance\n\n"}
{"name":"Localization.subalgebra.isFractionRing","module":"Mathlib.RingTheory.Localization.AsSubring","initialProofState":"A : Type u_1\nK : Type u_2\ninst✝³ : CommRing A\nS : Submonoid A\nhS : LE.le S (nonZeroDivisors A)\ninst✝² : CommRing K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\n⊢ IsFractionRing (Subtype fun x => Membership.mem (Localization.subalgebra K S hS) x) K","decl":"instance isFractionRing : IsFractionRing (subalgebra K S hS) K :=\n  IsFractionRing.isFractionRing_of_isLocalization S _ _ hS\n\n"}
{"name":"Localization.subalgebra.mem_range_mapToFractionRing_iff_ofField","module":"Mathlib.RingTheory.Localization.AsSubring","initialProofState":"A : Type u_1\nK : Type u_2\ninst✝⁶ : CommRing A\nS : Submonoid A\nhS : LE.le S (nonZeroDivisors A)\ninst✝⁵ : Field K\ninst✝⁴ : Algebra A K\ninst✝³ : IsFractionRing A K\nB : Type u_3\ninst✝² : CommRing B\ninst✝¹ : Algebra A B\ninst✝ : IsLocalization S B\nx : K\n⊢ Iff (Membership.mem (Localization.mapToFractionRing K S B hS).range x) (Exists fun a => Exists fun s => Exists fun x_1 => Eq x (HMul.hMul ((algebraMap A K) a) (Inv.inv ((algebraMap A K) s))))","decl":"theorem mem_range_mapToFractionRing_iff_ofField (B : Type*) [CommRing B] [Algebra A B]\n    [IsLocalization S B] (x : K) :\n    x ∈ (mapToFractionRing K S B hS).range ↔\n      ∃ (a s : A) (_ : s ∈ S), x = algebraMap A K a * (algebraMap A K s)⁻¹ := by\n  rw [mem_range_mapToFractionRing_iff]\n  convert Iff.rfl\n  congr\n  rw [Units.val_inv_eq_inv_val]\n  rfl\n\n"}
{"name":"Localization.subalgebra.isLocalization_ofField","module":"Mathlib.RingTheory.Localization.AsSubring","initialProofState":"A : Type u_1\nK : Type u_2\ninst✝³ : CommRing A\nS : Submonoid A\nhS : LE.le S (nonZeroDivisors A)\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\n⊢ IsLocalization S (Subtype fun x => Membership.mem (Localization.subalgebra.ofField K S hS) x)","decl":"instance isLocalization_ofField : IsLocalization S (subalgebra.ofField K S hS) := by\n  dsimp only [Localization.subalgebra.ofField]\n  rw [Subalgebra.copy_eq]\n  infer_instance\n\n"}
{"name":"Localization.subalgebra.isFractionRing_ofField","module":"Mathlib.RingTheory.Localization.AsSubring","initialProofState":"A : Type u_1\nK : Type u_2\ninst✝³ : CommRing A\nS : Submonoid A\nhS : LE.le S (nonZeroDivisors A)\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\n⊢ IsFractionRing (Subtype fun x => Membership.mem (Localization.subalgebra.ofField K S hS) x) K","decl":"instance isFractionRing_ofField : IsFractionRing (subalgebra.ofField K S hS) K :=\n  IsFractionRing.isFractionRing_of_isLocalization S _ _ hS\n\n"}
