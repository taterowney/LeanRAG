{"name":"jacobiTheta_eq_jacobiTheta₂","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.OneVariable","initialProofState":"τ : Complex\n⊢ Eq (jacobiTheta τ) (jacobiTheta₂ 0 τ)","decl":"lemma jacobiTheta_eq_jacobiTheta₂ (τ : ℂ) : jacobiTheta τ = jacobiTheta₂ 0 τ :=\n  tsum_congr (by simp [jacobiTheta₂_term])\n\n"}
{"name":"jacobiTheta_two_add","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.OneVariable","initialProofState":"τ : Complex\n⊢ Eq (jacobiTheta (HAdd.hAdd 2 τ)) (jacobiTheta τ)","decl":"theorem jacobiTheta_two_add (τ : ℂ) : jacobiTheta (2 + τ) = jacobiTheta τ := by\n  simp_rw [jacobiTheta_eq_jacobiTheta₂, add_comm, jacobiTheta₂_add_right]\n\n"}
{"name":"jacobiTheta_T_sq_smul","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.OneVariable","initialProofState":"τ : UpperHalfPlane\n⊢ Eq (jacobiTheta ↑(HSMul.hSMul (HPow.hPow ModularGroup.T 2) τ)) (jacobiTheta ↑τ)","decl":"theorem jacobiTheta_T_sq_smul (τ : ℍ) : jacobiTheta (ModularGroup.T ^ 2 • τ :) = jacobiTheta τ := by\n  suffices (ModularGroup.T ^ 2 • τ :) = (2 : ℂ) + ↑τ by simp_rw [this, jacobiTheta_two_add]\n  have : ModularGroup.T ^ (2 : ℕ) = ModularGroup.T ^ (2 : ℤ) := rfl\n  simp_rw [this, UpperHalfPlane.modular_T_zpow_smul, UpperHalfPlane.coe_vadd]\n  norm_cast\n\n"}
{"name":"jacobiTheta_S_smul","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.OneVariable","initialProofState":"τ : UpperHalfPlane\n⊢ Eq (jacobiTheta ↑(HSMul.hSMul ModularGroup.S τ)) (HMul.hMul (HPow.hPow (HMul.hMul (Neg.neg Complex.I) ↑τ) (1 / 2)) (jacobiTheta ↑τ))","decl":"theorem jacobiTheta_S_smul (τ : ℍ) :\n    jacobiTheta ↑(ModularGroup.S • τ) = (-I * τ) ^ (1 / 2 : ℂ) * jacobiTheta τ := by\n  have h0 : (τ : ℂ) ≠ 0 := ne_of_apply_ne im (zero_im.symm ▸ ne_of_gt τ.2)\n  have h1 : (-I * τ) ^ (1 / 2 : ℂ) ≠ 0 := by\n    rw [Ne, cpow_eq_zero_iff, not_and_or]\n    exact Or.inl <| mul_ne_zero (neg_ne_zero.mpr I_ne_zero) h0\n  simp_rw [UpperHalfPlane.modular_S_smul, jacobiTheta_eq_jacobiTheta₂]\n  conv_rhs => erw [← ofReal_zero, jacobiTheta₂_functional_equation 0 τ]\n  rw [zero_pow two_ne_zero, mul_zero, zero_div, Complex.exp_zero, mul_one, ← mul_assoc, mul_one_div,\n    div_self h1, one_mul, UpperHalfPlane.coe_mk, inv_neg, neg_div, one_div]\n\n"}
{"name":"norm_exp_mul_sq_le","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.OneVariable","initialProofState":"τ : Complex\nhτ : LT.lt 0 τ.im\nn : Int\n⊢ LE.le (Norm.norm (Complex.exp (HMul.hMul (HMul.hMul (HMul.hMul (↑Real.pi) Complex.I) (HPow.hPow (↑n) 2)) τ))) (HPow.hPow (Real.exp (HMul.hMul (Neg.neg Real.pi) τ.im)) n.natAbs)","decl":"theorem norm_exp_mul_sq_le {τ : ℂ} (hτ : 0 < τ.im) (n : ℤ) :\n    ‖cexp (π * I * (n : ℂ) ^ 2 * τ)‖ ≤ rexp (-π * τ.im) ^ n.natAbs := by\n  let y := rexp (-π * τ.im)\n  have h : y < 1 := exp_lt_one_iff.mpr (mul_neg_of_neg_of_pos (neg_lt_zero.mpr pi_pos) hτ)\n  refine (le_of_eq ?_).trans (?_ : y ^ n ^ 2 ≤ _)\n  · rw [Complex.norm_eq_abs, Complex.abs_exp]\n    have : (π * I * n ^ 2 * τ : ℂ).re = -π * τ.im * (n : ℝ) ^ 2 := by\n      rw [(by push_cast; ring : (π * I * n ^ 2 * τ : ℂ) = (π * n ^ 2 : ℝ) * (τ * I)),\n        re_ofReal_mul, mul_I_re]\n      ring\n    obtain ⟨m, hm⟩ := Int.eq_ofNat_of_zero_le (sq_nonneg n)\n    rw [this, exp_mul, ← Int.cast_pow, rpow_intCast, hm, zpow_natCast]\n  · have : n ^ 2 = (n.natAbs ^ 2 :) := by rw [Nat.cast_pow, Int.natAbs_sq]\n    rw [this, zpow_natCast]\n    exact pow_le_pow_of_le_one (exp_pos _).le h.le ((sq n.natAbs).symm ▸ n.natAbs.le_mul_self)\n\n"}
{"name":"hasSum_nat_jacobiTheta","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.OneVariable","initialProofState":"τ : Complex\nhτ : LT.lt 0 τ.im\n⊢ HasSum (fun n => Complex.exp (HMul.hMul (HMul.hMul (HMul.hMul (↑Real.pi) Complex.I) (HPow.hPow (HAdd.hAdd (↑n) 1) 2)) τ)) (HDiv.hDiv (HSub.hSub (jacobiTheta τ) 1) 2)","decl":"theorem hasSum_nat_jacobiTheta {τ : ℂ} (hτ : 0 < im τ) :\n    HasSum (fun n : ℕ => cexp (π * I * ((n : ℂ) + 1) ^ 2 * τ)) ((jacobiTheta τ - 1) / 2) := by\n  have := hasSum_jacobiTheta₂_term 0 hτ\n  simp_rw [jacobiTheta₂_term, mul_zero, zero_add, ← jacobiTheta_eq_jacobiTheta₂] at this\n  have := this.nat_add_neg\n  rw [← hasSum_nat_add_iff' 1] at this\n  simp_rw [Finset.sum_range_one, Int.cast_neg, Int.cast_natCast, Nat.cast_zero, neg_zero,\n    Int.cast_zero, sq (0 : ℂ), mul_zero, zero_mul, neg_sq, ← mul_two,\n    Complex.exp_zero, add_sub_assoc, (by norm_num : (1 : ℂ) - 1 * 2 = -1), ← sub_eq_add_neg,\n    Nat.cast_add, Nat.cast_one] at this\n  convert this.div_const 2 using 1\n  simp_rw [mul_div_cancel_right₀ _ (two_ne_zero' ℂ)]\n\n"}
{"name":"jacobiTheta_eq_tsum_nat","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.OneVariable","initialProofState":"τ : Complex\nhτ : LT.lt 0 τ.im\n⊢ Eq (jacobiTheta τ) (HAdd.hAdd 1 (HMul.hMul 2 (tsum fun n => Complex.exp (HMul.hMul (HMul.hMul (HMul.hMul (↑Real.pi) Complex.I) (HPow.hPow (HAdd.hAdd (↑n) 1) 2)) τ))))","decl":"theorem jacobiTheta_eq_tsum_nat {τ : ℂ} (hτ : 0 < im τ) :\n    jacobiTheta τ = ↑1 + ↑2 * ∑' n : ℕ, cexp (π * I * ((n : ℂ) + 1) ^ 2 * τ) := by\n  rw [(hasSum_nat_jacobiTheta hτ).tsum_eq, mul_div_cancel₀ _ (two_ne_zero' ℂ), ← add_sub_assoc,\n    add_sub_cancel_left]\n\n"}
{"name":"norm_jacobiTheta_sub_one_le","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.OneVariable","initialProofState":"τ : Complex\nhτ : LT.lt 0 τ.im\n⊢ LE.le (Norm.norm (HSub.hSub (jacobiTheta τ) 1)) (HMul.hMul (HDiv.hDiv 2 (HSub.hSub 1 (Real.exp (HMul.hMul (Neg.neg Real.pi) τ.im)))) (Real.exp (HMul.hMul (Neg.neg Real.pi) τ.im)))","decl":"/-- An explicit upper bound for `‖jacobiTheta τ - 1‖`. -/\ntheorem norm_jacobiTheta_sub_one_le {τ : ℂ} (hτ : 0 < im τ) :\n    ‖jacobiTheta τ - 1‖ ≤ 2 / (1 - rexp (-π * τ.im)) * rexp (-π * τ.im) := by\n  suffices ‖∑' n : ℕ, cexp (π * I * ((n : ℂ) + 1) ^ 2 * τ)‖ ≤\n      rexp (-π * τ.im) / (1 - rexp (-π * τ.im)) by\n    calc\n      ‖jacobiTheta τ - 1‖ = ↑2 * ‖∑' n : ℕ, cexp (π * I * ((n : ℂ) + 1) ^ 2 * τ)‖ := by\n        rw [sub_eq_iff_eq_add'.mpr (jacobiTheta_eq_tsum_nat hτ), norm_mul, Complex.norm_eq_abs,\n          Complex.abs_two]\n      _ ≤ 2 * (rexp (-π * τ.im) / (1 - rexp (-π * τ.im))) := by gcongr\n      _ = 2 / (1 - rexp (-π * τ.im)) * rexp (-π * τ.im) := by rw [div_mul_comm, mul_comm]\n  have : ∀ n : ℕ, ‖cexp (π * I * ((n : ℂ) + 1) ^ 2 * τ)‖ ≤ rexp (-π * τ.im) ^ (n + 1) := by\n    intro n\n    simpa only [Int.cast_add, Int.cast_one] using norm_exp_mul_sq_le hτ (n + 1)\n  have s : HasSum (fun n : ℕ =>\n      rexp (-π * τ.im) ^ (n + 1)) (rexp (-π * τ.im) / (1 - rexp (-π * τ.im))) := by\n    simp_rw [pow_succ', div_eq_mul_inv, hasSum_mul_left_iff (Real.exp_ne_zero _)]\n    exact hasSum_geometric_of_lt_one (exp_pos (-π * τ.im)).le\n      (exp_lt_one_iff.mpr <| mul_neg_of_neg_of_pos (neg_lt_zero.mpr pi_pos) hτ)\n  have aux : Summable fun n : ℕ => ‖cexp (π * I * ((n : ℂ) + 1) ^ 2 * τ)‖ :=\n    .of_nonneg_of_le (fun n => norm_nonneg _) this s.summable\n  exact (norm_tsum_le_tsum_norm aux).trans ((tsum_mono aux s.summable this).trans_eq s.tsum_eq)\n\n"}
{"name":"isBigO_at_im_infty_jacobiTheta_sub_one","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.OneVariable","initialProofState":"⊢ Asymptotics.IsBigO (Filter.comap Complex.im Filter.atTop) (fun τ => HSub.hSub (jacobiTheta τ) 1) fun τ => Real.exp (HMul.hMul (Neg.neg Real.pi) τ.im)","decl":"/-- The norm of `jacobiTheta τ - 1` decays exponentially as `im τ → ∞`. -/\ntheorem isBigO_at_im_infty_jacobiTheta_sub_one :\n    (fun τ => jacobiTheta τ - 1) =O[comap im atTop] fun τ => rexp (-π * τ.im) := by\n  simp_rw [IsBigO, IsBigOWith, Filter.eventually_comap, Filter.eventually_atTop]\n  refine ⟨2 / (1 - rexp (-(π * 1))), 1, fun y hy τ hτ =>\n    (norm_jacobiTheta_sub_one_le (hτ.symm ▸ zero_lt_one.trans_le hy : 0 < im τ)).trans ?_⟩\n  rw [Real.norm_eq_abs, Real.abs_exp, hτ, neg_mul]\n  gcongr\n  simp [pi_pos]\n\n"}
{"name":"differentiableAt_jacobiTheta","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.OneVariable","initialProofState":"τ : Complex\nhτ : LT.lt 0 τ.im\n⊢ DifferentiableAt Complex jacobiTheta τ","decl":"theorem differentiableAt_jacobiTheta {τ : ℂ} (hτ : 0 < im τ) :\n    DifferentiableAt ℂ jacobiTheta τ := by\n  simp_rw [funext jacobiTheta_eq_jacobiTheta₂]\n  exact differentiableAt_jacobiTheta₂_snd 0 hτ\n\n"}
{"name":"continuousAt_jacobiTheta","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.OneVariable","initialProofState":"τ : Complex\nhτ : LT.lt 0 τ.im\n⊢ ContinuousAt jacobiTheta τ","decl":"theorem continuousAt_jacobiTheta {τ : ℂ} (hτ : 0 < im τ) : ContinuousAt jacobiTheta τ :=\n  (differentiableAt_jacobiTheta hτ).continuousAt\n"}
