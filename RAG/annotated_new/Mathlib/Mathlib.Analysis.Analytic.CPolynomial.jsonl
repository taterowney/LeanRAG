{"name":"HasFiniteFPowerSeriesOnBall.toHasFPowerSeriesOnBall","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nn : Nat\nr : ENNReal\nself : HasFiniteFPowerSeriesOnBall f p x n r\n⊢ HasFPowerSeriesOnBall f p x r","decl":"/-- Given a function `f : E → F`, a formal multilinear series `p` and `n : ℕ`, we say that\n`f` has `p` as a finite power series on the ball of radius `r > 0` around `x` if\n`f (x + y) = ∑' pₘ yᵐ` for all `‖y‖ < r` and `pₙ = 0` for `n ≤ m`. -/\nstructure HasFiniteFPowerSeriesOnBall (f : E → F) (p : FormalMultilinearSeries 𝕜 E F) (x : E)\n    (n : ℕ) (r : ℝ≥0∞) extends HasFPowerSeriesOnBall f p x r : Prop where\n  finite : ∀ (m : ℕ), n ≤ m → p m = 0\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.finite","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nn : Nat\nr : ENNReal\nself : HasFiniteFPowerSeriesOnBall f p x n r\nm : Nat\na✝ : LE.le n m\n⊢ Eq (p m) 0","decl":"/-- Given a function `f : E → F`, a formal multilinear series `p` and `n : ℕ`, we say that\n`f` has `p` as a finite power series on the ball of radius `r > 0` around `x` if\n`f (x + y) = ∑' pₘ yᵐ` for all `‖y‖ < r` and `pₙ = 0` for `n ≤ m`. -/\nstructure HasFiniteFPowerSeriesOnBall (f : E → F) (p : FormalMultilinearSeries 𝕜 E F) (x : E)\n    (n : ℕ) (r : ℝ≥0∞) extends HasFPowerSeriesOnBall f p x r : Prop where\n  finite : ∀ (m : ℕ), n ≤ m → p m = 0\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.mk'","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nn : Nat\nr : ENNReal\nfinite : ∀ (m : Nat), LE.le n m → Eq (p m) 0\npos : LT.lt 0 r\nsum_eq : ∀ (y : E), Membership.mem (EMetric.ball 0 r) y → Eq ((Finset.range n).sum fun i => (p i) fun x => y) (f (HAdd.hAdd x y))\n⊢ HasFiniteFPowerSeriesOnBall f p x n r","decl":"theorem HasFiniteFPowerSeriesOnBall.mk' {f : E → F} {p : FormalMultilinearSeries 𝕜 E F} {x : E}\n    {n : ℕ} {r : ℝ≥0∞} (finite : ∀ (m : ℕ), n ≤ m → p m = 0) (pos : 0 < r)\n    (sum_eq : ∀ y ∈ EMetric.ball 0 r, (∑ i ∈ Finset.range n, p i fun _ ↦ y) = f (x + y)) :\n    HasFiniteFPowerSeriesOnBall f p x n r where\n  r_le := p.radius_eq_top_of_eventually_eq_zero (Filter.eventually_atTop.mpr ⟨n, finite⟩) ▸ le_top\n  r_pos := pos\n  hasSum hy := sum_eq _ hy ▸ hasSum_sum_of_ne_finset_zero fun m hm ↦ by\n    rw [Finset.mem_range, not_lt] at hm; rw [finite m hm]; rfl\n  finite := finite\n\n"}
{"name":"HasFiniteFPowerSeriesAt.toHasFPowerSeriesAt","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nn : Nat\nhf : HasFiniteFPowerSeriesAt f p x n\n⊢ HasFPowerSeriesAt f p x","decl":"theorem HasFiniteFPowerSeriesAt.toHasFPowerSeriesAt\n    (hf : HasFiniteFPowerSeriesAt f p x n) : HasFPowerSeriesAt f p x :=\n  let ⟨r, hf⟩ := hf\n  ⟨r, hf.toHasFPowerSeriesOnBall⟩\n\n"}
{"name":"HasFiniteFPowerSeriesAt.finite","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nn : Nat\nhf : HasFiniteFPowerSeriesAt f p x n\nm : Nat\na✝ : LE.le n m\n⊢ Eq (p m) 0","decl":"theorem HasFiniteFPowerSeriesAt.finite (hf : HasFiniteFPowerSeriesAt f p x n) :\n    ∀ m : ℕ, n ≤ m → p m = 0 := let ⟨_, hf⟩ := hf; hf.finite\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.hasFiniteFPowerSeriesAt","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nn : Nat\nhf : HasFiniteFPowerSeriesOnBall f p x n r\n⊢ HasFiniteFPowerSeriesAt f p x n","decl":"theorem HasFiniteFPowerSeriesOnBall.hasFiniteFPowerSeriesAt\n    (hf : HasFiniteFPowerSeriesOnBall f p x n r) :\n    HasFiniteFPowerSeriesAt f p x n :=\n  ⟨r, hf⟩\n\n"}
{"name":"HasFiniteFPowerSeriesAt.cPolynomialAt","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nn : Nat\nhf : HasFiniteFPowerSeriesAt f p x n\n⊢ CPolynomialAt 𝕜 f x","decl":"theorem HasFiniteFPowerSeriesAt.cPolynomialAt (hf : HasFiniteFPowerSeriesAt f p x n) :\n    CPolynomialAt 𝕜 f x :=\n  ⟨p, n, hf⟩\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.cPolynomialAt","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nn : Nat\nhf : HasFiniteFPowerSeriesOnBall f p x n r\n⊢ CPolynomialAt 𝕜 f x","decl":"theorem HasFiniteFPowerSeriesOnBall.cPolynomialAt (hf : HasFiniteFPowerSeriesOnBall f p x n r) :\n    CPolynomialAt 𝕜 f x :=\n  hf.hasFiniteFPowerSeriesAt.cPolynomialAt\n\n"}
{"name":"CPolynomialAt.analyticAt","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nhf : CPolynomialAt 𝕜 f x\n⊢ AnalyticAt 𝕜 f x","decl":"theorem CPolynomialAt.analyticAt (hf : CPolynomialAt 𝕜 f x) : AnalyticAt 𝕜 f x :=\n  let ⟨p, _, hp⟩ := hf\n  ⟨p, hp.toHasFPowerSeriesAt⟩\n\n"}
{"name":"CPolynomialAt.analyticWithinAt","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\ns : Set E\nhf : CPolynomialAt 𝕜 f x\n⊢ AnalyticWithinAt 𝕜 f s x","decl":"theorem CPolynomialAt.analyticWithinAt {s : Set E} (hf : CPolynomialAt 𝕜 f x) :\n    AnalyticWithinAt 𝕜 f s x :=\n  hf.analyticAt.analyticWithinAt\n\n"}
{"name":"CPolynomialOn.analyticOnNhd","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nhf : CPolynomialOn 𝕜 f s\n⊢ AnalyticOnNhd 𝕜 f s","decl":"theorem CPolynomialOn.analyticOnNhd {s : Set E} (hf : CPolynomialOn 𝕜 f s) : AnalyticOnNhd 𝕜 f s :=\n  fun x hx ↦ (hf x hx).analyticAt\n\n"}
{"name":"CPolynomialOn.analyticOn","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nhf : CPolynomialOn 𝕜 f s\n⊢ AnalyticOn 𝕜 f s","decl":"theorem CPolynomialOn.analyticOn {s : Set E} (hf : CPolynomialOn 𝕜 f s) : AnalyticOn 𝕜 f s :=\n  hf.analyticOnNhd.analyticOn\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.congr","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nn : Nat\nhf : HasFiniteFPowerSeriesOnBall f p x n r\nhg : Set.EqOn f g (EMetric.ball x r)\n⊢ HasFiniteFPowerSeriesOnBall g p x n r","decl":"theorem HasFiniteFPowerSeriesOnBall.congr (hf : HasFiniteFPowerSeriesOnBall f p x n r)\n    (hg : EqOn f g (EMetric.ball x r)) : HasFiniteFPowerSeriesOnBall g p x n r :=\n  ⟨hf.1.congr hg, hf.finite⟩\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.comp_sub","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nn : Nat\nhf : HasFiniteFPowerSeriesOnBall f p x n r\ny : E\n⊢ HasFiniteFPowerSeriesOnBall (fun z => f (HSub.hSub z y)) p (HAdd.hAdd x y) n r","decl":"/-- If a function `f` has a finite power series `p` around `x`, then the function\n`z ↦ f (z - y)` has the same finite power series around `x + y`. -/\ntheorem HasFiniteFPowerSeriesOnBall.comp_sub (hf : HasFiniteFPowerSeriesOnBall f p x n r) (y : E) :\n    HasFiniteFPowerSeriesOnBall (fun z => f (z - y)) p (x + y) n r :=\n  ⟨hf.1.comp_sub y, hf.finite⟩\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.mono","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr r' : ENNReal\nn : Nat\nhf : HasFiniteFPowerSeriesOnBall f p x n r\nr'_pos : LT.lt 0 r'\nhr : LE.le r' r\n⊢ HasFiniteFPowerSeriesOnBall f p x n r'","decl":"theorem HasFiniteFPowerSeriesOnBall.mono (hf : HasFiniteFPowerSeriesOnBall f p x n r)\n    (r'_pos : 0 < r') (hr : r' ≤ r) : HasFiniteFPowerSeriesOnBall f p x n r' :=\n  ⟨hf.1.mono r'_pos hr, hf.finite⟩\n\n"}
{"name":"HasFiniteFPowerSeriesAt.congr","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nn : Nat\nhf : HasFiniteFPowerSeriesAt f p x n\nhg : (nhds x).EventuallyEq f g\n⊢ HasFiniteFPowerSeriesAt g p x n","decl":"theorem HasFiniteFPowerSeriesAt.congr (hf : HasFiniteFPowerSeriesAt f p x n) (hg : f =ᶠ[𝓝 x] g) :\n    HasFiniteFPowerSeriesAt g p x n :=\n  Exists.imp (fun _ hg ↦ ⟨hg, hf.finite⟩) (hf.toHasFPowerSeriesAt.congr hg)\n\n"}
{"name":"HasFiniteFPowerSeriesAt.eventually","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nn : Nat\nhf : HasFiniteFPowerSeriesAt f p x n\n⊢ Filter.Eventually (fun r => HasFiniteFPowerSeriesOnBall f p x n r) (nhdsWithin 0 (Set.Ioi 0))","decl":"protected theorem HasFiniteFPowerSeriesAt.eventually (hf : HasFiniteFPowerSeriesAt f p x n) :\n    ∀ᶠ r : ℝ≥0∞ in 𝓝[>] 0, HasFiniteFPowerSeriesOnBall f p x n r :=\n  hf.toHasFPowerSeriesAt.eventually.mono fun _ h ↦ ⟨h, hf.finite⟩\n\n"}
{"name":"hasFiniteFPowerSeriesOnBall_const","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nc : F\ne : E\n⊢ HasFiniteFPowerSeriesOnBall (fun x => c) (constFormalMultilinearSeries 𝕜 E c) e 1 Top.top","decl":"theorem hasFiniteFPowerSeriesOnBall_const {c : F} {e : E} :\n    HasFiniteFPowerSeriesOnBall (fun _ => c) (constFormalMultilinearSeries 𝕜 E c) e 1 ⊤ :=\n  ⟨hasFPowerSeriesOnBall_const, fun n hn ↦ constFormalMultilinearSeries_apply (id hn : 0 < n).ne'⟩\n\n"}
{"name":"hasFiniteFPowerSeriesAt_const","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nc : F\ne : E\n⊢ HasFiniteFPowerSeriesAt (fun x => c) (constFormalMultilinearSeries 𝕜 E c) e 1","decl":"theorem hasFiniteFPowerSeriesAt_const {c : F} {e : E} :\n    HasFiniteFPowerSeriesAt (fun _ => c) (constFormalMultilinearSeries 𝕜 E c) e 1 :=\n  ⟨⊤, hasFiniteFPowerSeriesOnBall_const⟩\n\n"}
{"name":"CPolynomialAt_const","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\nv : F\n⊢ CPolynomialAt 𝕜 (fun x => v) x","decl":"theorem CPolynomialAt_const {v : F} : CPolynomialAt 𝕜 (fun _ => v) x :=\n  ⟨constFormalMultilinearSeries 𝕜 E v, 1, hasFiniteFPowerSeriesAt_const⟩\n\n"}
{"name":"CPolynomialOn_const","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nv : F\ns : Set E\n⊢ CPolynomialOn 𝕜 (fun x => v) s","decl":"theorem CPolynomialOn_const {v : F} {s : Set E} : CPolynomialOn 𝕜 (fun _ => v) s :=\n  fun _ _ => CPolynomialAt_const\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.add","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\npf pg : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nn m : Nat\nhf : HasFiniteFPowerSeriesOnBall f pf x n r\nhg : HasFiniteFPowerSeriesOnBall g pg x m r\n⊢ HasFiniteFPowerSeriesOnBall (HAdd.hAdd f g) (HAdd.hAdd pf pg) x (Max.max n m) r","decl":"theorem HasFiniteFPowerSeriesOnBall.add (hf : HasFiniteFPowerSeriesOnBall f pf x n r)\n    (hg : HasFiniteFPowerSeriesOnBall g pg x m r) :\n    HasFiniteFPowerSeriesOnBall (f + g) (pf + pg) x (max n m) r :=\n  ⟨hf.1.add hg.1, fun N hN ↦ by\n    rw [Pi.add_apply, hf.finite _ ((le_max_left n m).trans hN),\n        hg.finite _ ((le_max_right n m).trans hN), zero_add]⟩\n\n"}
{"name":"HasFiniteFPowerSeriesAt.add","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\npf pg : FormalMultilinearSeries 𝕜 E F\nx : E\nn m : Nat\nhf : HasFiniteFPowerSeriesAt f pf x n\nhg : HasFiniteFPowerSeriesAt g pg x m\n⊢ HasFiniteFPowerSeriesAt (HAdd.hAdd f g) (HAdd.hAdd pf pg) x (Max.max n m)","decl":"theorem HasFiniteFPowerSeriesAt.add (hf : HasFiniteFPowerSeriesAt f pf x n)\n    (hg : HasFiniteFPowerSeriesAt g pg x m) :\n    HasFiniteFPowerSeriesAt (f + g) (pf + pg) x (max n m) := by\n  rcases (hf.eventually.and hg.eventually).exists with ⟨r, hr⟩\n  exact ⟨r, hr.1.add hr.2⟩\n\n"}
{"name":"CPolynomialAt.congr","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\nx : E\nhf : CPolynomialAt 𝕜 f x\nhg : (nhds x).EventuallyEq f g\n⊢ CPolynomialAt 𝕜 g x","decl":"theorem CPolynomialAt.congr (hf : CPolynomialAt 𝕜 f x) (hg : f =ᶠ[𝓝 x] g) : CPolynomialAt 𝕜 g x :=\n  let ⟨_, _, hpf⟩ := hf\n  (hpf.congr hg).cPolynomialAt\n\n"}
{"name":"CPolynomialAt_congr","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\nx : E\nh : (nhds x).EventuallyEq f g\n⊢ Iff (CPolynomialAt 𝕜 f x) (CPolynomialAt 𝕜 g x)","decl":"theorem CPolynomialAt_congr (h : f =ᶠ[𝓝 x] g) : CPolynomialAt 𝕜 f x ↔ CPolynomialAt 𝕜 g x :=\n  ⟨fun hf ↦ hf.congr h, fun hg ↦ hg.congr h.symm⟩\n\n"}
{"name":"CPolynomialAt.add","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\nx : E\nhf : CPolynomialAt 𝕜 f x\nhg : CPolynomialAt 𝕜 g x\n⊢ CPolynomialAt 𝕜 (HAdd.hAdd f g) x","decl":"theorem CPolynomialAt.add (hf : CPolynomialAt 𝕜 f x) (hg : CPolynomialAt 𝕜 g x) :\n    CPolynomialAt 𝕜 (f + g) x :=\n  let ⟨_, _, hpf⟩ := hf\n  let ⟨_, _, hqf⟩ := hg\n  (hpf.add hqf).cPolynomialAt\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.neg","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\npf : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nn : Nat\nhf : HasFiniteFPowerSeriesOnBall f pf x n r\n⊢ HasFiniteFPowerSeriesOnBall (Neg.neg f) (Neg.neg pf) x n r","decl":"theorem HasFiniteFPowerSeriesOnBall.neg (hf : HasFiniteFPowerSeriesOnBall f pf x n r) :\n    HasFiniteFPowerSeriesOnBall (-f) (-pf) x n r :=\n  ⟨hf.1.neg, fun m hm ↦ by rw [Pi.neg_apply, hf.finite m hm, neg_zero]⟩\n\n"}
{"name":"HasFiniteFPowerSeriesAt.neg","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\npf : FormalMultilinearSeries 𝕜 E F\nx : E\nn : Nat\nhf : HasFiniteFPowerSeriesAt f pf x n\n⊢ HasFiniteFPowerSeriesAt (Neg.neg f) (Neg.neg pf) x n","decl":"theorem HasFiniteFPowerSeriesAt.neg (hf : HasFiniteFPowerSeriesAt f pf x n) :\n    HasFiniteFPowerSeriesAt (-f) (-pf) x n :=\n  let ⟨_, hrf⟩ := hf\n  hrf.neg.hasFiniteFPowerSeriesAt\n\n"}
{"name":"CPolynomialAt.neg","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nhf : CPolynomialAt 𝕜 f x\n⊢ CPolynomialAt 𝕜 (Neg.neg f) x","decl":"theorem CPolynomialAt.neg (hf : CPolynomialAt 𝕜 f x) : CPolynomialAt 𝕜 (-f) x :=\n  let ⟨_, _, hpf⟩ := hf\n  hpf.neg.cPolynomialAt\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.sub","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\npf pg : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nn m : Nat\nhf : HasFiniteFPowerSeriesOnBall f pf x n r\nhg : HasFiniteFPowerSeriesOnBall g pg x m r\n⊢ HasFiniteFPowerSeriesOnBall (HSub.hSub f g) (HSub.hSub pf pg) x (Max.max n m) r","decl":"theorem HasFiniteFPowerSeriesOnBall.sub (hf : HasFiniteFPowerSeriesOnBall f pf x n r)\n    (hg : HasFiniteFPowerSeriesOnBall g pg x m r) :\n    HasFiniteFPowerSeriesOnBall (f - g) (pf - pg) x (max n m) r := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"HasFiniteFPowerSeriesAt.sub","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\npf pg : FormalMultilinearSeries 𝕜 E F\nx : E\nn m : Nat\nhf : HasFiniteFPowerSeriesAt f pf x n\nhg : HasFiniteFPowerSeriesAt g pg x m\n⊢ HasFiniteFPowerSeriesAt (HSub.hSub f g) (HSub.hSub pf pg) x (Max.max n m)","decl":"theorem HasFiniteFPowerSeriesAt.sub (hf : HasFiniteFPowerSeriesAt f pf x n)\n    (hg : HasFiniteFPowerSeriesAt g pg x m) :\n    HasFiniteFPowerSeriesAt (f - g) (pf - pg) x (max n m) := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"CPolynomialAt.sub","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\nx : E\nhf : CPolynomialAt 𝕜 f x\nhg : CPolynomialAt 𝕜 g x\n⊢ CPolynomialAt 𝕜 (HSub.hSub f g) x","decl":"theorem CPolynomialAt.sub (hf : CPolynomialAt 𝕜 f x) (hg : CPolynomialAt 𝕜 g x) :\n    CPolynomialAt 𝕜 (f - g) x := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"CPolynomialOn.mono","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns t : Set E\nhf : CPolynomialOn 𝕜 f t\nhst : HasSubset.Subset s t\n⊢ CPolynomialOn 𝕜 f s","decl":"theorem CPolynomialOn.mono {s t : Set E} (hf : CPolynomialOn 𝕜 f t) (hst : s ⊆ t) :\n    CPolynomialOn 𝕜 f s :=\n  fun z hz => hf z (hst hz)\n\n"}
{"name":"CPolynomialOn.congr'","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\ns : Set E\nhf : CPolynomialOn 𝕜 f s\nhg : (nhdsSet s).EventuallyEq f g\n⊢ CPolynomialOn 𝕜 g s","decl":"theorem CPolynomialOn.congr' {s : Set E} (hf : CPolynomialOn 𝕜 f s) (hg : f =ᶠ[𝓝ˢ s] g) :\n    CPolynomialOn 𝕜 g s :=\n  fun z hz => (hf z hz).congr (mem_nhdsSet_iff_forall.mp hg z hz)\n\n"}
{"name":"CPolynomialOn_congr'","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\ns : Set E\nh : (nhdsSet s).EventuallyEq f g\n⊢ Iff (CPolynomialOn 𝕜 f s) (CPolynomialOn 𝕜 g s)","decl":"theorem CPolynomialOn_congr' {s : Set E} (h : f =ᶠ[𝓝ˢ s] g) :\n    CPolynomialOn 𝕜 f s ↔ CPolynomialOn 𝕜 g s :=\n  ⟨fun hf => hf.congr' h, fun hg => hg.congr' h.symm⟩\n\n"}
{"name":"CPolynomialOn.congr","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\ns : Set E\nhs : IsOpen s\nhf : CPolynomialOn 𝕜 f s\nhg : Set.EqOn f g s\n⊢ CPolynomialOn 𝕜 g s","decl":"theorem CPolynomialOn.congr {s : Set E} (hs : IsOpen s) (hf : CPolynomialOn 𝕜 f s)\n    (hg : s.EqOn f g) : CPolynomialOn 𝕜 g s :=\n  hf.congr' <| mem_nhdsSet_iff_forall.mpr\n    (fun _ hz => eventuallyEq_iff_exists_mem.mpr ⟨s, hs.mem_nhds hz, hg⟩)\n\n"}
{"name":"CPolynomialOn_congr","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\ns : Set E\nhs : IsOpen s\nh : Set.EqOn f g s\n⊢ Iff (CPolynomialOn 𝕜 f s) (CPolynomialOn 𝕜 g s)","decl":"theorem CPolynomialOn_congr {s : Set E} (hs : IsOpen s) (h : s.EqOn f g) :\n    CPolynomialOn 𝕜 f s ↔ CPolynomialOn 𝕜 g s :=\n  ⟨fun hf => hf.congr hs h, fun hg => hg.congr hs h.symm⟩\n\n"}
{"name":"CPolynomialOn.add","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\ns : Set E\nhf : CPolynomialOn 𝕜 f s\nhg : CPolynomialOn 𝕜 g s\n⊢ CPolynomialOn 𝕜 (HAdd.hAdd f g) s","decl":"theorem CPolynomialOn.add {s : Set E} (hf : CPolynomialOn 𝕜 f s) (hg : CPolynomialOn 𝕜 g s) :\n    CPolynomialOn 𝕜 (f + g) s :=\n  fun z hz => (hf z hz).add (hg z hz)\n\n"}
{"name":"CPolynomialOn.sub","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\ns : Set E\nhf : CPolynomialOn 𝕜 f s\nhg : CPolynomialOn 𝕜 g s\n⊢ CPolynomialOn 𝕜 (HSub.hSub f g) s","decl":"theorem CPolynomialOn.sub {s : Set E} (hf : CPolynomialOn 𝕜 f s) (hg : CPolynomialOn 𝕜 g s) :\n    CPolynomialOn 𝕜 (f - g) s :=\n  fun z hz => (hf z hz).sub (hg z hz)\n\n"}
{"name":"ContinuousLinearMap.comp_hasFiniteFPowerSeriesOnBall","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nn : Nat\ng : ContinuousLinearMap (RingHom.id 𝕜) F G\nh : HasFiniteFPowerSeriesOnBall f p x n r\n⊢ HasFiniteFPowerSeriesOnBall (Function.comp (⇑g) f) (g.compFormalMultilinearSeries p) x n r","decl":"/-- If a function `f` has a finite power series `p` on a ball and `g` is a continuous linear map,\nthen `g ∘ f` has the finite power series `g ∘ p` on the same ball. -/\ntheorem ContinuousLinearMap.comp_hasFiniteFPowerSeriesOnBall (g : F →L[𝕜] G)\n    (h : HasFiniteFPowerSeriesOnBall f p x n r) :\n    HasFiniteFPowerSeriesOnBall (g ∘ f) (g.compFormalMultilinearSeries p) x n r :=\n  ⟨g.comp_hasFPowerSeriesOnBall h.1, fun m hm ↦ by\n    rw [compFormalMultilinearSeries_apply, h.finite m hm]\n    ext; exact map_zero g⟩\n\n"}
{"name":"ContinuousLinearMap.comp_cPolynomialOn","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : E → F\ns : Set E\ng : ContinuousLinearMap (RingHom.id 𝕜) F G\nh : CPolynomialOn 𝕜 f s\n⊢ CPolynomialOn 𝕜 (Function.comp (⇑g) f) s","decl":"/-- If a function `f` is continuously polynomial on a set `s` and `g` is a continuous linear map,\nthen `g ∘ f` is continuously polynomial on `s`. -/\ntheorem ContinuousLinearMap.comp_cPolynomialOn {s : Set E} (g : F →L[𝕜] G)\n    (h : CPolynomialOn 𝕜 f s) : CPolynomialOn 𝕜 (g ∘ f) s := by\n  rintro x hx\n  rcases h x hx with ⟨p, n, r, hp⟩\n  exact ⟨g.compFormalMultilinearSeries p, n, r, g.comp_hasFiniteFPowerSeriesOnBall hp⟩\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.eq_partialSum","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nn : Nat\nhf : HasFiniteFPowerSeriesOnBall f p x n r\ny : E\na✝¹ : Membership.mem (EMetric.ball 0 r) y\nm : Nat\na✝ : LE.le n m\n⊢ Eq (f (HAdd.hAdd x y)) (p.partialSum m y)","decl":"/-- If a function admits a finite power series expansion bounded by `n`, then it is equal to\nthe `m`th partial sums of this power series at every point of the disk for `n ≤ m`. -/\ntheorem HasFiniteFPowerSeriesOnBall.eq_partialSum\n    (hf : HasFiniteFPowerSeriesOnBall f p x n r) :\n    ∀ y ∈ EMetric.ball (0 : E) r, ∀ m, n ≤ m →\n    f (x + y) = p.partialSum m y :=\n  fun y hy m hm ↦ (hf.hasSum hy).unique (hasSum_sum_of_ne_finset_zero\n    (f := fun m => p m (fun _ => y)) (s := Finset.range m)\n    (fun N hN => by simp only; simp only [Finset.mem_range, not_lt] at hN\n                    rw [hf.finite _ (le_trans hm hN), ContinuousMultilinearMap.zero_apply]))\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.eq_partialSum'","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nn : Nat\nhf : HasFiniteFPowerSeriesOnBall f p x n r\ny : E\na✝¹ : Membership.mem (EMetric.ball x r) y\nm : Nat\na✝ : LE.le n m\n⊢ Eq (f y) (p.partialSum m (HSub.hSub y x))","decl":"/-- Variant of the previous result with the variable expressed as `y` instead of `x + y`. -/\ntheorem HasFiniteFPowerSeriesOnBall.eq_partialSum'\n    (hf : HasFiniteFPowerSeriesOnBall f p x n r) :\n    ∀ y ∈ EMetric.ball x r, ∀ m, n ≤ m →\n    f y = p.partialSum m (y - x) := by\n  intro y hy m hm\n  rw [EMetric.mem_ball, edist_eq_enorm_sub, ← mem_emetric_ball_zero_iff] at hy\n  rw [← (HasFiniteFPowerSeriesOnBall.eq_partialSum hf _ hy m hm), add_sub_cancel]\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.eq_zero_of_bound_zero","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\npf : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nhf : HasFiniteFPowerSeriesOnBall f pf x 0 r\ny : E\na✝ : Membership.mem (EMetric.ball x r) y\n⊢ Eq (f y) 0","decl":"/-- If `f` has a formal power series on a ball bounded by `0`, then `f` is equal to `0` on\nthe ball. -/\ntheorem HasFiniteFPowerSeriesOnBall.eq_zero_of_bound_zero\n    (hf : HasFiniteFPowerSeriesOnBall f pf x 0 r) : ∀ y ∈ EMetric.ball x r, f y = 0 := by\n  intro y hy\n  rw [hf.eq_partialSum' y hy 0 le_rfl, FormalMultilinearSeries.partialSum]\n  simp only [Finset.range_zero, Finset.sum_empty]\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.bound_zero_of_eq_zero","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nhf : ∀ (y : E), Membership.mem (EMetric.ball x r) y → Eq (f y) 0\nr_pos : LT.lt 0 r\nhp : ∀ (n : Nat), Eq (p n) 0\n⊢ HasFiniteFPowerSeriesOnBall f p x 0 r","decl":"theorem HasFiniteFPowerSeriesOnBall.bound_zero_of_eq_zero (hf : ∀ y ∈ EMetric.ball x r, f y = 0)\n    (r_pos : 0 < r) (hp : ∀ n, p n = 0) : HasFiniteFPowerSeriesOnBall f p x 0 r := by\n  refine ⟨⟨?_, r_pos, ?_⟩, fun n _ ↦ hp n⟩\n  · rw [p.radius_eq_top_of_forall_image_add_eq_zero 0 (fun n ↦ by rw [add_zero]; exact hp n)]\n    exact le_top\n  · intro y hy\n    rw [hf (x + y)]\n    · convert hasSum_zero\n      rw [hp, ContinuousMultilinearMap.zero_apply]\n    · rwa [EMetric.mem_ball, edist_eq_enorm_sub, add_comm, add_sub_cancel_right,\n        ← edist_zero_eq_enorm, ← EMetric.mem_ball]\n\n"}
{"name":"HasFiniteFPowerSeriesAt.eventually_zero_of_bound_zero","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\npf : FormalMultilinearSeries 𝕜 E F\nx : E\nhf : HasFiniteFPowerSeriesAt f pf x 0\n⊢ (nhds x).EventuallyEq f 0","decl":"/-- If `f` has a formal power series at `x` bounded by `0`, then `f` is equal to `0` in a\nneighborhood of `x`. -/\ntheorem HasFiniteFPowerSeriesAt.eventually_zero_of_bound_zero\n    (hf : HasFiniteFPowerSeriesAt f pf x 0) : f =ᶠ[𝓝 x] 0 :=\n  Filter.eventuallyEq_iff_exists_mem.mpr (let ⟨r, hf⟩ := hf; ⟨EMetric.ball x r,\n    EMetric.ball_mem_nhds x hf.r_pos, fun y hy ↦ hf.eq_zero_of_bound_zero y hy⟩)\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.eq_const_of_bound_one","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\npf : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nhf : HasFiniteFPowerSeriesOnBall f pf x 1 r\ny : E\na✝ : Membership.mem (EMetric.ball x r) y\n⊢ Eq (f y) (f x)","decl":"/-- If `f` has a formal power series on a ball bounded by `1`, then `f` is constant equal\nto `f x` on the ball. -/\ntheorem HasFiniteFPowerSeriesOnBall.eq_const_of_bound_one\n    (hf : HasFiniteFPowerSeriesOnBall f pf x 1 r) : ∀ y ∈ EMetric.ball x r, f y = f x := by\n  intro y hy\n  rw [hf.eq_partialSum' y hy 1 le_rfl, hf.eq_partialSum' x\n    (by rw [EMetric.mem_ball, edist_self]; exact hf.r_pos) 1 le_rfl]\n  simp only [FormalMultilinearSeries.partialSum, Finset.range_one, Finset.sum_singleton]\n  congr\n  apply funext\n  simp only [IsEmpty.forall_iff]\n\n"}
{"name":"HasFiniteFPowerSeriesAt.eventually_const_of_bound_one","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\npf : FormalMultilinearSeries 𝕜 E F\nx : E\nhf : HasFiniteFPowerSeriesAt f pf x 1\n⊢ (nhds x).EventuallyEq f fun x_1 => f x","decl":"/-- If `f` has a formal power series at x bounded by `1`, then `f` is constant equal\nto `f x` in a neighborhood of `x`. -/\ntheorem HasFiniteFPowerSeriesAt.eventually_const_of_bound_one\n    (hf : HasFiniteFPowerSeriesAt f pf x 1) : f =ᶠ[𝓝 x] (fun _ => f x) :=\n  Filter.eventuallyEq_iff_exists_mem.mpr (let ⟨r, hf⟩ := hf; ⟨EMetric.ball x r,\n    EMetric.ball_mem_nhds x hf.r_pos, fun y hy ↦ hf.eq_const_of_bound_one y hy⟩)\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.continuousOn","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nn : Nat\nhf : HasFiniteFPowerSeriesOnBall f p x n r\n⊢ ContinuousOn f (EMetric.ball x r)","decl":"/-- If a function admits a finite power series expansion on a disk, then it is continuous there. -/\nprotected theorem HasFiniteFPowerSeriesOnBall.continuousOn\n    (hf : HasFiniteFPowerSeriesOnBall f p x n r) :\n    ContinuousOn f (EMetric.ball x r) := hf.1.continuousOn\n\n"}
{"name":"HasFiniteFPowerSeriesAt.continuousAt","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nn : Nat\nhf : HasFiniteFPowerSeriesAt f p x n\n⊢ ContinuousAt f x","decl":"protected theorem HasFiniteFPowerSeriesAt.continuousAt (hf : HasFiniteFPowerSeriesAt f p x n) :\n    ContinuousAt f x := hf.toHasFPowerSeriesAt.continuousAt\n\n"}
{"name":"CPolynomialAt.continuousAt","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nhf : CPolynomialAt 𝕜 f x\n⊢ ContinuousAt f x","decl":"protected theorem CPolynomialAt.continuousAt (hf : CPolynomialAt 𝕜 f x) : ContinuousAt f x :=\n  hf.analyticAt.continuousAt\n\n"}
{"name":"CPolynomialOn.continuousOn","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nhf : CPolynomialOn 𝕜 f s\n⊢ ContinuousOn f s","decl":"protected theorem CPolynomialOn.continuousOn {s : Set E} (hf : CPolynomialOn 𝕜 f s) :\n    ContinuousOn f s :=\n  hf.analyticOnNhd.continuousOn\n\n"}
{"name":"CPolynomialOn.continuous","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nfa : CPolynomialOn 𝕜 f Set.univ\n⊢ Continuous f","decl":"/-- Continuously polynomial everywhere implies continuous -/\ntheorem CPolynomialOn.continuous {f : E → F} (fa : CPolynomialOn 𝕜 f univ) : Continuous f := by\n  rw [continuous_iff_continuousOn_univ]; exact fa.continuousOn\n\n"}
{"name":"FormalMultilinearSeries.sum_of_finite","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nn : Nat\nhn : ∀ (m : Nat), LE.le n m → Eq (p m) 0\nx : E\n⊢ Eq (p.sum x) (p.partialSum n x)","decl":"protected theorem FormalMultilinearSeries.sum_of_finite (p : FormalMultilinearSeries 𝕜 E F)\n    {n : ℕ} (hn : ∀ m, n ≤ m → p m = 0) (x : E) :\n    p.sum x = p.partialSum n x :=\n  tsum_eq_sum fun m hm ↦ by rw [Finset.mem_range, not_lt] at hm; rw [hn m hm]; rfl\n\n"}
{"name":"FormalMultilinearSeries.hasSum_of_finite","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nn : Nat\nhn : ∀ (m : Nat), LE.le n m → Eq (p m) 0\nx : E\n⊢ HasSum (fun n => (p n) fun x_1 => x) (p.sum x)","decl":"/-- A finite formal multilinear series sums to its sum at every point. -/\nprotected theorem FormalMultilinearSeries.hasSum_of_finite (p : FormalMultilinearSeries 𝕜 E F)\n    {n : ℕ} (hn : ∀ m, n ≤ m → p m = 0) (x : E) :\n    HasSum (fun n : ℕ => p n fun _ => x) (p.sum x) :=\n  summable_of_ne_finset_zero (s := .range n)\n    (fun m hm ↦ by rw [Finset.mem_range, not_lt] at hm; rw [hn m hm]; rfl)\n    |>.hasSum\n\n"}
{"name":"FormalMultilinearSeries.hasFiniteFPowerSeriesOnBall_of_finite","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nn : Nat\nhn : ∀ (m : Nat), LE.le n m → Eq (p m) 0\n⊢ HasFiniteFPowerSeriesOnBall p.sum p 0 n Top.top","decl":"/-- The sum of a finite power series `p` admits `p` as a power series. -/\nprotected theorem FormalMultilinearSeries.hasFiniteFPowerSeriesOnBall_of_finite\n    (p : FormalMultilinearSeries 𝕜 E F) {n : ℕ} (hn : ∀ m, n ≤ m → p m = 0) :\n    HasFiniteFPowerSeriesOnBall p.sum p 0 n ⊤ where\n  r_le := by rw [radius_eq_top_of_forall_image_add_eq_zero p n fun _ => hn _ (Nat.le_add_left _ _)]\n  r_pos := zero_lt_top\n  finite := hn\n  hasSum {y} _ := by rw [zero_add]; exact p.hasSum_of_finite hn y\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.sum","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nn : Nat\nh : HasFiniteFPowerSeriesOnBall f p x n r\ny : E\nhy : Membership.mem (EMetric.ball 0 r) y\n⊢ Eq (f (HAdd.hAdd x y)) (p.sum y)","decl":"theorem HasFiniteFPowerSeriesOnBall.sum (h : HasFiniteFPowerSeriesOnBall f p x n r) {y : E}\n    (hy : y ∈ EMetric.ball (0 : E) r) : f (x + y) = p.sum y :=\n  (h.hasSum hy).tsum_eq.symm\n\n"}
{"name":"FormalMultilinearSeries.continuousOn_of_finite","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nn : Nat\nhn : ∀ (m : Nat), LE.le n m → Eq (p m) 0\n⊢ Continuous p.sum","decl":"/-- The sum of a finite power series is continuous. -/\nprotected theorem FormalMultilinearSeries.continuousOn_of_finite\n    (p : FormalMultilinearSeries 𝕜 E F) {n : ℕ} (hn : ∀ m, n ≤ m → p m = 0) :\n    Continuous p.sum := by\n  rw [continuous_iff_continuousOn_univ, ← Metric.emetric_ball_top]\n  exact (p.hasFiniteFPowerSeriesOnBall_of_finite hn).continuousOn\n\n"}
{"name":"FormalMultilinearSeries.changeOriginSeriesTerm_bound","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nn : Nat\nhn : ∀ (m : Nat), LE.le n m → Eq (p m) 0\nk l : Nat\ns : Finset (Fin (HAdd.hAdd k l))\nhs : Eq s.card l\nhkl : LE.le n (HAdd.hAdd k l)\n⊢ Eq (p.changeOriginSeriesTerm k l s hs) 0","decl":"/-- If `p` is a formal multilinear series such that `p m = 0` for `n ≤ m`, then\n`p.changeOriginSeriesTerm k l = 0` for `n ≤ k + l`. -/\nlemma changeOriginSeriesTerm_bound (p : FormalMultilinearSeries 𝕜 E F) {n : ℕ}\n    (hn : ∀ (m : ℕ), n ≤ m → p m = 0) (k l : ℕ) {s : Finset (Fin (k + l))}\n    (hs : s.card = l) (hkl : n ≤ k + l) :\n    p.changeOriginSeriesTerm k l s hs = 0 := by\n  #adaptation_note /-- https://github.com/leanprover/lean4/pull/4119\n  `set_option maxSynthPendingDepth 2` required after https://github.com/leanprover/lean4/pull/4119 -/\n  set_option maxSynthPendingDepth 2 in\n  rw [changeOriginSeriesTerm, hn _ hkl, map_zero]\n\n"}
{"name":"FormalMultilinearSeries.changeOriginSeries_finite_of_finite","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nn : Nat\nhn : ∀ (m : Nat), LE.le n m → Eq (p m) 0\nk m : Nat\na✝ : LE.le n (HAdd.hAdd k m)\n⊢ Eq (p.changeOriginSeries k m) 0","decl":"/-- If `p` is a finite formal multilinear series, then so is `p.changeOriginSeries k` for every\n`k` in `ℕ`. More precisely, if `p m = 0` for `n ≤ m`, then `p.changeOriginSeries k m = 0` for\n`n ≤ k + m`. -/\nlemma changeOriginSeries_finite_of_finite (p : FormalMultilinearSeries 𝕜 E F) {n : ℕ}\n    (hn : ∀ (m : ℕ), n ≤ m → p m = 0) (k : ℕ) : ∀ {m : ℕ}, n ≤ k + m →\n    p.changeOriginSeries k m = 0 := by\n  intro m hm\n  rw [changeOriginSeries]\n  exact Finset.sum_eq_zero (fun _ _ => p.changeOriginSeriesTerm_bound hn _ _ _ hm)\n\n"}
{"name":"FormalMultilinearSeries.changeOriginSeries_sum_eq_partialSum_of_finite","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nn : Nat\nhn : ∀ (m : Nat), LE.le n m → Eq (p m) 0\nk : Nat\n⊢ Eq (p.changeOriginSeries k).sum ((p.changeOriginSeries k).partialSum (HSub.hSub n k))","decl":"lemma changeOriginSeries_sum_eq_partialSum_of_finite (p : FormalMultilinearSeries 𝕜 E F) {n : ℕ}\n    (hn : ∀ (m : ℕ), n ≤ m → p m = 0) (k : ℕ) :\n    (p.changeOriginSeries k).sum = (p.changeOriginSeries k).partialSum (n - k) := by\n  ext x\n  rw [partialSum, FormalMultilinearSeries.sum,\n    tsum_eq_sum (f := fun m => p.changeOriginSeries k m (fun _ => x)) (s := Finset.range (n - k))]\n  intro m hm\n  rw [Finset.mem_range, not_lt] at hm\n  rw [p.changeOriginSeries_finite_of_finite hn k (by rw [add_comm]; exact Nat.le_add_of_sub_le hm),\n    ContinuousMultilinearMap.zero_apply]\n\n"}
{"name":"FormalMultilinearSeries.changeOrigin_finite_of_finite","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\np : FormalMultilinearSeries 𝕜 E F\nn : Nat\nhn : ∀ (m : Nat), LE.le n m → Eq (p m) 0\nk : Nat\nhk : LE.le n k\n⊢ Eq (p.changeOrigin x k) 0","decl":"/-- If `p` is a formal multilinear series such that `p m = 0` for `n ≤ m`, then\n`p.changeOrigin x k = 0` for `n ≤ k`. -/\nlemma changeOrigin_finite_of_finite (p : FormalMultilinearSeries 𝕜 E F) {n : ℕ}\n    (hn : ∀ (m : ℕ), n ≤ m → p m = 0) {k : ℕ} (hk : n ≤ k) :\n    p.changeOrigin x k = 0 := by\n  rw [changeOrigin, p.changeOriginSeries_sum_eq_partialSum_of_finite hn]\n  apply Finset.sum_eq_zero\n  intro m hm\n  rw [Finset.mem_range] at hm\n  rw [p.changeOriginSeries_finite_of_finite hn k (le_add_of_le_left hk),\n    ContinuousMultilinearMap.zero_apply]\n\n"}
{"name":"FormalMultilinearSeries.hasFiniteFPowerSeriesOnBall_changeOrigin","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nn k : Nat\nhn : ∀ (m : Nat), LE.le (HAdd.hAdd n k) m → Eq (p m) 0\n⊢ HasFiniteFPowerSeriesOnBall (fun x => p.changeOrigin x k) (p.changeOriginSeries k) 0 n Top.top","decl":"theorem hasFiniteFPowerSeriesOnBall_changeOrigin (p : FormalMultilinearSeries 𝕜 E F) {n : ℕ}\n    (k : ℕ) (hn : ∀ (m : ℕ), n + k ≤ m → p m = 0) :\n    HasFiniteFPowerSeriesOnBall (p.changeOrigin · k) (p.changeOriginSeries k) 0 n ⊤ :=\n  (p.changeOriginSeries k).hasFiniteFPowerSeriesOnBall_of_finite\n    (fun _ hm => p.changeOriginSeries_finite_of_finite hn k\n    (by rw [add_comm n k]; apply add_le_add_left hm))\n\n"}
{"name":"FormalMultilinearSeries.changeOrigin_eval_of_finite","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nn : Nat\nhn : ∀ (m : Nat), LE.le n m → Eq (p m) 0\nx y : E\n⊢ Eq ((p.changeOrigin x).sum y) (p.sum (HAdd.hAdd x y))","decl":"theorem changeOrigin_eval_of_finite (p : FormalMultilinearSeries 𝕜 E F) {n : ℕ}\n    (hn : ∀ (m : ℕ), n ≤ m → p m = 0) (x y : E) :\n    (p.changeOrigin x).sum y = p.sum (x + y) := by\n  let f (s : Σ k l : ℕ, { s : Finset (Fin (k + l)) // s.card = l }) : F :=\n    p.changeOriginSeriesTerm s.1 s.2.1 s.2.2 s.2.2.2 (fun _ ↦ x) fun _ ↦ y\n  have finsupp : f.support.Finite := by\n    apply Set.Finite.subset (s := changeOriginIndexEquiv ⁻¹' (Sigma.fst ⁻¹' {m | m < n}))\n    · apply Set.Finite.preimage (Equiv.injective _).injOn\n      simp_rw [← {m | m < n}.iUnion_of_singleton_coe, preimage_iUnion, ← range_sigmaMk]\n      exact finite_iUnion fun _ ↦ finite_range _\n    · refine fun s ↦ Not.imp_symm fun hs ↦ ?_\n      simp only [preimage_setOf_eq, changeOriginIndexEquiv_apply_fst, mem_setOf, not_lt] at hs\n      dsimp only [f]\n      rw [changeOriginSeriesTerm_bound p hn _ _ _ hs, ContinuousMultilinearMap.zero_apply,\n        ContinuousMultilinearMap.zero_apply]\n  have hfkl k l : HasSum (f ⟨k, l, ·⟩) (changeOriginSeries p k l (fun _ ↦ x) fun _ ↦ y) := by\n    simp_rw [changeOriginSeries, ContinuousMultilinearMap.sum_apply]; apply hasSum_fintype\n  have hfk k : HasSum (f ⟨k, ·⟩) (changeOrigin p x k fun _ ↦ y) := by\n    have (m) (hm : m ∉ Finset.range n) : changeOriginSeries p k m (fun _ ↦ x) = 0 := by\n      rw [Finset.mem_range, not_lt] at hm\n      rw [changeOriginSeries_finite_of_finite _ hn _ (le_add_of_le_right hm),\n        ContinuousMultilinearMap.zero_apply]\n    rw [changeOrigin, FormalMultilinearSeries.sum,\n      ContinuousMultilinearMap.tsum_eval (summable_of_ne_finset_zero this)]\n    refine (summable_of_ne_finset_zero (s := Finset.range n) fun m hm ↦ ?_).hasSum.sigma_of_hasSum\n      (hfkl k) (summable_of_finite_support <| finsupp.preimage sigma_mk_injective.injOn)\n    rw [this m hm, ContinuousMultilinearMap.zero_apply]\n  have hf : HasSum f ((p.changeOrigin x).sum y) :=\n    ((p.changeOrigin x).hasSum_of_finite (fun _ ↦ changeOrigin_finite_of_finite p hn) _)\n      |>.sigma_of_hasSum hfk (summable_of_finite_support finsupp)\n  refine hf.unique (changeOriginIndexEquiv.symm.hasSum_iff.1 ?_)\n  refine (p.hasSum_of_finite hn (x + y)).sigma_of_hasSum (fun n ↦ ?_)\n    (changeOriginIndexEquiv.symm.summable_iff.2 hf.summable)\n  rw [← Pi.add_def, (p n).map_add_univ (fun _ ↦ x) fun _ ↦ y]\n  simp_rw [← changeOriginSeriesTerm_changeOriginIndexEquiv_symm]\n  exact hasSum_fintype fun c ↦ f (changeOriginIndexEquiv.symm ⟨n, c⟩)\n\n"}
{"name":"FormalMultilinearSeries.cPolynomialAt_changeOrigin_of_finite","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nn : Nat\nhn : ∀ (m : Nat), LE.le n m → Eq (p m) 0\nk : Nat\n⊢ CPolynomialAt 𝕜 (fun x => p.changeOrigin x k) 0","decl":"/-- The terms of the formal multilinear series `p.changeOrigin` are continuously polynomial\nas we vary the origin -/\ntheorem cPolynomialAt_changeOrigin_of_finite (p : FormalMultilinearSeries 𝕜 E F)\n    {n : ℕ} (hn : ∀ (m : ℕ), n ≤ m → p m = 0) (k : ℕ) :\n    CPolynomialAt 𝕜 (p.changeOrigin · k) 0 :=\n  (p.hasFiniteFPowerSeriesOnBall_changeOrigin k fun _ h ↦ hn _ (le_self_add.trans h)).cPolynomialAt\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.changeOrigin","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nr : ENNReal\nn : Nat\nx y : E\nhf : HasFiniteFPowerSeriesOnBall f p x n r\nh : LT.lt (↑(NNNorm.nnnorm y)) r\n⊢ HasFiniteFPowerSeriesOnBall f (p.changeOrigin y) (HAdd.hAdd x y) n (HSub.hSub r ↑(NNNorm.nnnorm y))","decl":"theorem HasFiniteFPowerSeriesOnBall.changeOrigin (hf : HasFiniteFPowerSeriesOnBall f p x n r)\n    (h : (‖y‖₊ : ℝ≥0∞) < r) :\n    HasFiniteFPowerSeriesOnBall f (p.changeOrigin y) (x + y) n (r - ‖y‖₊) where\n  r_le := (tsub_le_tsub_right hf.r_le _).trans p.changeOrigin_radius\n  r_pos := by simp [h]\n  finite _ hm := p.changeOrigin_finite_of_finite hf.finite hm\n  hasSum {z} hz := by\n    have : f (x + y + z) =\n        FormalMultilinearSeries.sum (FormalMultilinearSeries.changeOrigin p y) z := by\n      rw [mem_emetric_ball_zero_iff, lt_tsub_iff_right, add_comm] at hz\n      rw [p.changeOrigin_eval_of_finite hf.finite, add_assoc, hf.sum]\n      exact mem_emetric_ball_zero_iff.2 ((enorm_add_le _ _).trans_lt hz)\n    rw [this]\n    apply (p.changeOrigin y).hasSum_of_finite fun _ => p.changeOrigin_finite_of_finite hf.finite\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.cPolynomialAt_of_mem","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nr : ENNReal\nn : Nat\nx y : E\nhf : HasFiniteFPowerSeriesOnBall f p x n r\nh : Membership.mem (EMetric.ball x r) y\n⊢ CPolynomialAt 𝕜 f y","decl":"/-- If a function admits a finite power series expansion `p` on an open ball `B (x, r)`, then\nit is continuously polynomial at every point of this ball. -/\ntheorem HasFiniteFPowerSeriesOnBall.cPolynomialAt_of_mem\n    (hf : HasFiniteFPowerSeriesOnBall f p x n r) (h : y ∈ EMetric.ball x r) :\n    CPolynomialAt 𝕜 f y := by\n  have : (‖y - x‖₊ : ℝ≥0∞) < r := by simpa [edist_eq_enorm_sub] using h\n  have := hf.changeOrigin this\n  rw [add_sub_cancel] at this\n  exact this.cPolynomialAt\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.cPolynomialOn","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nr : ENNReal\nn : Nat\nx : E\nhf : HasFiniteFPowerSeriesOnBall f p x n r\n⊢ CPolynomialOn 𝕜 f (EMetric.ball x r)","decl":"theorem HasFiniteFPowerSeriesOnBall.cPolynomialOn (hf : HasFiniteFPowerSeriesOnBall f p x n r) :\n    CPolynomialOn 𝕜 f (EMetric.ball x r) :=\n  fun _y hy => hf.cPolynomialAt_of_mem hy\n\n"}
{"name":"isOpen_cPolynomialAt","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\n⊢ IsOpen (setOf fun x => CPolynomialAt 𝕜 f x)","decl":"/-- For any function `f` from a normed vector space to a normed vector space, the set of points\n`x` such that `f` is continuously polynomial at `x` is open. -/\ntheorem isOpen_cPolynomialAt : IsOpen { x | CPolynomialAt 𝕜 f x } := by\n  rw [isOpen_iff_mem_nhds]\n  rintro x ⟨p, n, r, hr⟩\n  exact mem_of_superset (EMetric.ball_mem_nhds _ hr.r_pos) fun y hy => hr.cPolynomialAt_of_mem hy\n\n"}
{"name":"CPolynomialAt.eventually_cPolynomialAt","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nh : CPolynomialAt 𝕜 f x\n⊢ Filter.Eventually (fun y => CPolynomialAt 𝕜 f y) (nhds x)","decl":"theorem CPolynomialAt.eventually_cPolynomialAt {f : E → F} {x : E} (h : CPolynomialAt 𝕜 f x) :\n    ∀ᶠ y in 𝓝 x, CPolynomialAt 𝕜 f y :=\n  (isOpen_cPolynomialAt 𝕜 f).mem_nhds h\n\n"}
{"name":"CPolynomialAt.exists_mem_nhds_cPolynomialOn","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nh : CPolynomialAt 𝕜 f x\n⊢ Exists fun s => And (Membership.mem (nhds x) s) (CPolynomialOn 𝕜 f s)","decl":"theorem CPolynomialAt.exists_mem_nhds_cPolynomialOn {f : E → F} {x : E} (h : CPolynomialAt 𝕜 f x) :\n    ∃ s ∈ 𝓝 x, CPolynomialOn 𝕜 f s :=\n  h.eventually_cPolynomialAt.exists_mem\n\n"}
{"name":"CPolynomialAt.exists_ball_cPolynomialOn","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nh : CPolynomialAt 𝕜 f x\n⊢ Exists fun r => And (LT.lt 0 r) (CPolynomialOn 𝕜 f (Metric.ball x r))","decl":"/-- If `f` is continuously polynomial at a point, then it is continuously polynomial in a\nnonempty ball around that point. -/\ntheorem CPolynomialAt.exists_ball_cPolynomialOn {f : E → F} {x : E} (h : CPolynomialAt 𝕜 f x) :\n    ∃ r : ℝ, 0 < r ∧ CPolynomialOn 𝕜 f (Metric.ball x r) :=\n  Metric.isOpen_iff.mp (isOpen_cPolynomialAt _ _) _ h\n\n"}
{"name":"ContinuousMultilinearMap.hasFiniteFPowerSeriesOnBall","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace 𝕜 F\nι : Type u_5\nEm : ι → Type u_6\ninst✝² : (i : ι) → NormedAddCommGroup (Em i)\ninst✝¹ : (i : ι) → NormedSpace 𝕜 (Em i)\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 Em F\n⊢ HasFiniteFPowerSeriesOnBall (⇑f) f.toFormalMultilinearSeries 0 (HAdd.hAdd (Fintype.card ι) 1) Top.top","decl":"protected theorem hasFiniteFPowerSeriesOnBall :\n    HasFiniteFPowerSeriesOnBall f f.toFormalMultilinearSeries 0 (Fintype.card ι + 1) ⊤ :=\n  .mk' (fun _ hm ↦ dif_neg (Nat.succ_le_iff.mp hm).ne) ENNReal.zero_lt_top fun y _ ↦ by\n    rw [Finset.sum_eq_single_of_mem _ (Finset.self_mem_range_succ _), zero_add]\n    · rw [toFormalMultilinearSeries, dif_pos rfl]; rfl\n    · intro m _ ne; rw [toFormalMultilinearSeries, dif_neg ne.symm]; rfl\n\n"}
{"name":"ContinuousMultilinearMap.cpolynomialAt","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace 𝕜 F\nι : Type u_5\nEm : ι → Type u_6\ninst✝² : (i : ι) → NormedAddCommGroup (Em i)\ninst✝¹ : (i : ι) → NormedSpace 𝕜 (Em i)\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 Em F\nx : (i : ι) → Em i\n⊢ CPolynomialAt 𝕜 (⇑f) x","decl":"lemma cpolynomialAt  : CPolynomialAt 𝕜 f x :=\n  f.hasFiniteFPowerSeriesOnBall.cPolynomialAt_of_mem\n    (by simp only [Metric.emetric_ball_top, Set.mem_univ])\n\n"}
{"name":"ContinuousMultilinearMap.cpolyomialOn","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace 𝕜 F\nι : Type u_5\nEm : ι → Type u_6\ninst✝² : (i : ι) → NormedAddCommGroup (Em i)\ninst✝¹ : (i : ι) → NormedSpace 𝕜 (Em i)\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 Em F\ns : Set ((i : ι) → Em i)\n⊢ CPolynomialOn 𝕜 (⇑f) s","decl":"lemma cpolyomialOn : CPolynomialOn 𝕜 f s := fun _ _ ↦ f.cpolynomialAt\n\n"}
{"name":"ContinuousMultilinearMap.analyticOnNhd","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace 𝕜 F\nι : Type u_5\nEm : ι → Type u_6\ninst✝² : (i : ι) → NormedAddCommGroup (Em i)\ninst✝¹ : (i : ι) → NormedSpace 𝕜 (Em i)\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 Em F\ns : Set ((i : ι) → Em i)\n⊢ AnalyticOnNhd 𝕜 (⇑f) s","decl":"lemma analyticOnNhd : AnalyticOnNhd 𝕜 f s := f.cpolyomialOn.analyticOnNhd\n\n"}
{"name":"ContinuousMultilinearMap.analyticOn","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace 𝕜 F\nι : Type u_5\nEm : ι → Type u_6\ninst✝² : (i : ι) → NormedAddCommGroup (Em i)\ninst✝¹ : (i : ι) → NormedSpace 𝕜 (Em i)\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 Em F\ns : Set ((i : ι) → Em i)\n⊢ AnalyticOn 𝕜 (⇑f) s","decl":"lemma analyticOn : AnalyticOn 𝕜 f s := f.analyticOnNhd.analyticOn\n\n"}
{"name":"ContinuousMultilinearMap.analyticWithinOn","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace 𝕜 F\nι : Type u_5\nEm : ι → Type u_6\ninst✝² : (i : ι) → NormedAddCommGroup (Em i)\ninst✝¹ : (i : ι) → NormedSpace 𝕜 (Em i)\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 Em F\ns : Set ((i : ι) → Em i)\n⊢ AnalyticOn 𝕜 (⇑f) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias analyticWithinOn := analyticOn\n\n"}
{"name":"ContinuousMultilinearMap.analyticAt","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace 𝕜 F\nι : Type u_5\nEm : ι → Type u_6\ninst✝² : (i : ι) → NormedAddCommGroup (Em i)\ninst✝¹ : (i : ι) → NormedSpace 𝕜 (Em i)\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 Em F\nx : (i : ι) → Em i\n⊢ AnalyticAt 𝕜 (⇑f) x","decl":"lemma analyticAt : AnalyticAt 𝕜 f x := f.cpolynomialAt.analyticAt\n\n"}
{"name":"ContinuousMultilinearMap.analyticWithinAt","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nF : Type u_3\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace 𝕜 F\nι : Type u_5\nEm : ι → Type u_6\ninst✝² : (i : ι) → NormedAddCommGroup (Em i)\ninst✝¹ : (i : ι) → NormedSpace 𝕜 (Em i)\ninst✝ : Fintype ι\nf : ContinuousMultilinearMap 𝕜 Em F\nx : (i : ι) → Em i\ns : Set ((i : ι) → Em i)\n⊢ AnalyticWithinAt 𝕜 (⇑f) s x","decl":"lemma analyticWithinAt : AnalyticWithinAt 𝕜 f s x := f.analyticAt.analyticWithinAt\n\n"}
{"name":"ContinuousLinearMap.hasFiniteFPowerSeriesOnBall_uncurry_of_multilinear","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nF : Type u_3\nG : Type u_4\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NormedSpace 𝕜 F\ninst✝⁴ : NormedAddCommGroup G\ninst✝³ : NormedSpace 𝕜 G\nι : Type u_5\nEm : ι → Type u_6\ninst✝² : (i : ι) → NormedAddCommGroup (Em i)\ninst✝¹ : (i : ι) → NormedSpace 𝕜 (Em i)\ninst✝ : Fintype ι\nf : ContinuousLinearMap (RingHom.id 𝕜) G (ContinuousMultilinearMap 𝕜 Em F)\n⊢ HasFiniteFPowerSeriesOnBall (fun p => (f p.1) p.2) f.toFormalMultilinearSeriesOfMultilinear 0 (HAdd.hAdd (Fintype.card (Option ι)) 1) Top.top","decl":"protected theorem hasFiniteFPowerSeriesOnBall_uncurry_of_multilinear :\n    HasFiniteFPowerSeriesOnBall (fun (p : G × (Π i, Em i)) ↦ f p.1 p.2)\n      f.toFormalMultilinearSeriesOfMultilinear 0 (Fintype.card (Option ι) + 1) ⊤ := by\n  apply HasFiniteFPowerSeriesOnBall.mk' ?_ ENNReal.zero_lt_top  ?_\n  · intro m hm\n    apply dif_neg\n    exact Nat.ne_of_lt hm\n  · intro y _\n    rw [Finset.sum_eq_single_of_mem _ (Finset.self_mem_range_succ _), zero_add]\n    · rw [toFormalMultilinearSeriesOfMultilinear, dif_pos rfl]; rfl\n    · intro m _ ne; rw [toFormalMultilinearSeriesOfMultilinear, dif_neg ne.symm]; rfl\n\n"}
{"name":"ContinuousLinearMap.cpolynomialAt_uncurry_of_multilinear","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nF : Type u_3\nG : Type u_4\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NormedSpace 𝕜 F\ninst✝⁴ : NormedAddCommGroup G\ninst✝³ : NormedSpace 𝕜 G\nι : Type u_5\nEm : ι → Type u_6\ninst✝² : (i : ι) → NormedAddCommGroup (Em i)\ninst✝¹ : (i : ι) → NormedSpace 𝕜 (Em i)\ninst✝ : Fintype ι\nf : ContinuousLinearMap (RingHom.id 𝕜) G (ContinuousMultilinearMap 𝕜 Em F)\nx : Prod G ((i : ι) → Em i)\n⊢ CPolynomialAt 𝕜 (fun p => (f p.1) p.2) x","decl":"lemma cpolynomialAt_uncurry_of_multilinear :\n    CPolynomialAt 𝕜 (fun (p : G × (Π i, Em i)) ↦ f p.1 p.2) x :=\n  f.hasFiniteFPowerSeriesOnBall_uncurry_of_multilinear.cPolynomialAt_of_mem\n    (by simp only [Metric.emetric_ball_top, Set.mem_univ])\n\n"}
{"name":"ContinuousLinearMap.cpolyomialOn_uncurry_of_multilinear","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nF : Type u_3\nG : Type u_4\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NormedSpace 𝕜 F\ninst✝⁴ : NormedAddCommGroup G\ninst✝³ : NormedSpace 𝕜 G\nι : Type u_5\nEm : ι → Type u_6\ninst✝² : (i : ι) → NormedAddCommGroup (Em i)\ninst✝¹ : (i : ι) → NormedSpace 𝕜 (Em i)\ninst✝ : Fintype ι\nf : ContinuousLinearMap (RingHom.id 𝕜) G (ContinuousMultilinearMap 𝕜 Em F)\ns : Set (Prod G ((i : ι) → Em i))\n⊢ CPolynomialOn 𝕜 (fun p => (f p.1) p.2) s","decl":"lemma cpolyomialOn_uncurry_of_multilinear :\n    CPolynomialOn 𝕜 (fun (p : G × (Π i, Em i)) ↦ f p.1 p.2) s :=\n  fun _ _ ↦ f.cpolynomialAt_uncurry_of_multilinear\n\n"}
{"name":"ContinuousLinearMap.analyticOnNhd_uncurry_of_multilinear","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nF : Type u_3\nG : Type u_4\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NormedSpace 𝕜 F\ninst✝⁴ : NormedAddCommGroup G\ninst✝³ : NormedSpace 𝕜 G\nι : Type u_5\nEm : ι → Type u_6\ninst✝² : (i : ι) → NormedAddCommGroup (Em i)\ninst✝¹ : (i : ι) → NormedSpace 𝕜 (Em i)\ninst✝ : Fintype ι\nf : ContinuousLinearMap (RingHom.id 𝕜) G (ContinuousMultilinearMap 𝕜 Em F)\ns : Set (Prod G ((i : ι) → Em i))\n⊢ AnalyticOnNhd 𝕜 (fun p => (f p.1) p.2) s","decl":"lemma analyticOnNhd_uncurry_of_multilinear :\n    AnalyticOnNhd 𝕜 (fun (p : G × (Π i, Em i)) ↦ f p.1 p.2) s :=\n  f.cpolyomialOn_uncurry_of_multilinear.analyticOnNhd\n\n"}
{"name":"ContinuousLinearMap.analyticOn_uncurry_of_multilinear","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nF : Type u_3\nG : Type u_4\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NormedSpace 𝕜 F\ninst✝⁴ : NormedAddCommGroup G\ninst✝³ : NormedSpace 𝕜 G\nι : Type u_5\nEm : ι → Type u_6\ninst✝² : (i : ι) → NormedAddCommGroup (Em i)\ninst✝¹ : (i : ι) → NormedSpace 𝕜 (Em i)\ninst✝ : Fintype ι\nf : ContinuousLinearMap (RingHom.id 𝕜) G (ContinuousMultilinearMap 𝕜 Em F)\ns : Set (Prod G ((i : ι) → Em i))\n⊢ AnalyticOn 𝕜 (fun p => (f p.1) p.2) s","decl":"lemma analyticOn_uncurry_of_multilinear :\n    AnalyticOn 𝕜 (fun (p : G × (Π i, Em i)) ↦ f p.1 p.2) s :=\n  f.analyticOnNhd_uncurry_of_multilinear.analyticOn\n\n"}
{"name":"ContinuousLinearMap.analyticWithinOn_uncurry_of_multilinear","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nF : Type u_3\nG : Type u_4\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NormedSpace 𝕜 F\ninst✝⁴ : NormedAddCommGroup G\ninst✝³ : NormedSpace 𝕜 G\nι : Type u_5\nEm : ι → Type u_6\ninst✝² : (i : ι) → NormedAddCommGroup (Em i)\ninst✝¹ : (i : ι) → NormedSpace 𝕜 (Em i)\ninst✝ : Fintype ι\nf : ContinuousLinearMap (RingHom.id 𝕜) G (ContinuousMultilinearMap 𝕜 Em F)\ns : Set (Prod G ((i : ι) → Em i))\n⊢ AnalyticOn 𝕜 (fun p => (f p.1) p.2) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias analyticWithinOn_uncurry_of_multilinear := analyticOn_uncurry_of_multilinear\n\n"}
{"name":"ContinuousLinearMap.analyticAt_uncurry_of_multilinear","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nF : Type u_3\nG : Type u_4\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NormedSpace 𝕜 F\ninst✝⁴ : NormedAddCommGroup G\ninst✝³ : NormedSpace 𝕜 G\nι : Type u_5\nEm : ι → Type u_6\ninst✝² : (i : ι) → NormedAddCommGroup (Em i)\ninst✝¹ : (i : ι) → NormedSpace 𝕜 (Em i)\ninst✝ : Fintype ι\nf : ContinuousLinearMap (RingHom.id 𝕜) G (ContinuousMultilinearMap 𝕜 Em F)\nx : Prod G ((i : ι) → Em i)\n⊢ AnalyticAt 𝕜 (fun p => (f p.1) p.2) x","decl":"lemma analyticAt_uncurry_of_multilinear : AnalyticAt 𝕜 (fun (p : G × (Π i, Em i)) ↦ f p.1 p.2) x :=\n  f.cpolynomialAt_uncurry_of_multilinear.analyticAt\n\n"}
{"name":"ContinuousLinearMap.analyticWithinAt_uncurry_of_multilinear","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"𝕜 : Type u_1\nF : Type u_3\nG : Type u_4\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NormedSpace 𝕜 F\ninst✝⁴ : NormedAddCommGroup G\ninst✝³ : NormedSpace 𝕜 G\nι : Type u_5\nEm : ι → Type u_6\ninst✝² : (i : ι) → NormedAddCommGroup (Em i)\ninst✝¹ : (i : ι) → NormedSpace 𝕜 (Em i)\ninst✝ : Fintype ι\nf : ContinuousLinearMap (RingHom.id 𝕜) G (ContinuousMultilinearMap 𝕜 Em F)\ns : Set (Prod G ((i : ι) → Em i))\nx : Prod G ((i : ι) → Em i)\n⊢ AnalyticWithinAt 𝕜 (fun p => (f p.1) p.2) s x","decl":"lemma analyticWithinAt_uncurry_of_multilinear :\n    AnalyticWithinAt 𝕜 (fun (p : G × (Π i, Em i)) ↦ f p.1 p.2) s x :=\n  f.analyticAt_uncurry_of_multilinear.analyticWithinAt\n\n"}
