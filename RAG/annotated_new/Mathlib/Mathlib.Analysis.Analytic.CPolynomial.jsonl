{"name":"HasFiniteFPowerSeriesOnBall.toHasFPowerSeriesOnBall","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nn : Nat\nr : ENNReal\nself : HasFiniteFPowerSeriesOnBall f p x n r\nâŠ¢ HasFPowerSeriesOnBall f p x r","decl":"/-- Given a function `f : E â†’ F`, a formal multilinear series `p` and `n : â„•`, we say that\n`f` has `p` as a finite power series on the ball of radius `r > 0` around `x` if\n`f (x + y) = âˆ‘' pâ‚˜ yáµ` for all `â€–yâ€– < r` and `pâ‚™ = 0` for `n â‰¤ m`. -/\nstructure HasFiniteFPowerSeriesOnBall (f : E â†’ F) (p : FormalMultilinearSeries ğ•œ E F) (x : E)\n    (n : â„•) (r : â„â‰¥0âˆ) extends HasFPowerSeriesOnBall f p x r : Prop where\n  finite : âˆ€ (m : â„•), n â‰¤ m â†’ p m = 0\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.finite","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nn : Nat\nr : ENNReal\nself : HasFiniteFPowerSeriesOnBall f p x n r\nm : Nat\naâœ : LE.le n m\nâŠ¢ Eq (p m) 0","decl":"/-- Given a function `f : E â†’ F`, a formal multilinear series `p` and `n : â„•`, we say that\n`f` has `p` as a finite power series on the ball of radius `r > 0` around `x` if\n`f (x + y) = âˆ‘' pâ‚˜ yáµ` for all `â€–yâ€– < r` and `pâ‚™ = 0` for `n â‰¤ m`. -/\nstructure HasFiniteFPowerSeriesOnBall (f : E â†’ F) (p : FormalMultilinearSeries ğ•œ E F) (x : E)\n    (n : â„•) (r : â„â‰¥0âˆ) extends HasFPowerSeriesOnBall f p x r : Prop where\n  finite : âˆ€ (m : â„•), n â‰¤ m â†’ p m = 0\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.mk'","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nn : Nat\nr : ENNReal\nfinite : âˆ€ (m : Nat), LE.le n m â†’ Eq (p m) 0\npos : LT.lt 0 r\nsum_eq : âˆ€ (y : E), Membership.mem (EMetric.ball 0 r) y â†’ Eq ((Finset.range n).sum fun i => (p i) fun x => y) (f (HAdd.hAdd x y))\nâŠ¢ HasFiniteFPowerSeriesOnBall f p x n r","decl":"theorem HasFiniteFPowerSeriesOnBall.mk' {f : E â†’ F} {p : FormalMultilinearSeries ğ•œ E F} {x : E}\n    {n : â„•} {r : â„â‰¥0âˆ} (finite : âˆ€ (m : â„•), n â‰¤ m â†’ p m = 0) (pos : 0 < r)\n    (sum_eq : âˆ€ y âˆˆ EMetric.ball 0 r, (âˆ‘ i âˆˆ Finset.range n, p i fun _ â†¦ y) = f (x + y)) :\n    HasFiniteFPowerSeriesOnBall f p x n r where\n  r_le := p.radius_eq_top_of_eventually_eq_zero (Filter.eventually_atTop.mpr âŸ¨n, finiteâŸ©) â–¸ le_top\n  r_pos := pos\n  hasSum hy := sum_eq _ hy â–¸ hasSum_sum_of_ne_finset_zero fun m hm â†¦ by\n    rw [Finset.mem_range, not_lt] at hm; rw [finite m hm]; rfl\n  finite := finite\n\n"}
{"name":"HasFiniteFPowerSeriesAt.toHasFPowerSeriesAt","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nn : Nat\nhf : HasFiniteFPowerSeriesAt f p x n\nâŠ¢ HasFPowerSeriesAt f p x","decl":"theorem HasFiniteFPowerSeriesAt.toHasFPowerSeriesAt\n    (hf : HasFiniteFPowerSeriesAt f p x n) : HasFPowerSeriesAt f p x :=\n  let âŸ¨r, hfâŸ© := hf\n  âŸ¨r, hf.toHasFPowerSeriesOnBallâŸ©\n\n"}
{"name":"HasFiniteFPowerSeriesAt.finite","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nn : Nat\nhf : HasFiniteFPowerSeriesAt f p x n\nm : Nat\naâœ : LE.le n m\nâŠ¢ Eq (p m) 0","decl":"theorem HasFiniteFPowerSeriesAt.finite (hf : HasFiniteFPowerSeriesAt f p x n) :\n    âˆ€ m : â„•, n â‰¤ m â†’ p m = 0 := let âŸ¨_, hfâŸ© := hf; hf.finite\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.hasFiniteFPowerSeriesAt","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nn : Nat\nhf : HasFiniteFPowerSeriesOnBall f p x n r\nâŠ¢ HasFiniteFPowerSeriesAt f p x n","decl":"theorem HasFiniteFPowerSeriesOnBall.hasFiniteFPowerSeriesAt\n    (hf : HasFiniteFPowerSeriesOnBall f p x n r) :\n    HasFiniteFPowerSeriesAt f p x n :=\n  âŸ¨r, hfâŸ©\n\n"}
{"name":"HasFiniteFPowerSeriesAt.cPolynomialAt","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nn : Nat\nhf : HasFiniteFPowerSeriesAt f p x n\nâŠ¢ CPolynomialAt ğ•œ f x","decl":"theorem HasFiniteFPowerSeriesAt.cPolynomialAt (hf : HasFiniteFPowerSeriesAt f p x n) :\n    CPolynomialAt ğ•œ f x :=\n  âŸ¨p, n, hfâŸ©\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.cPolynomialAt","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nn : Nat\nhf : HasFiniteFPowerSeriesOnBall f p x n r\nâŠ¢ CPolynomialAt ğ•œ f x","decl":"theorem HasFiniteFPowerSeriesOnBall.cPolynomialAt (hf : HasFiniteFPowerSeriesOnBall f p x n r) :\n    CPolynomialAt ğ•œ f x :=\n  hf.hasFiniteFPowerSeriesAt.cPolynomialAt\n\n"}
{"name":"CPolynomialAt.analyticAt","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nhf : CPolynomialAt ğ•œ f x\nâŠ¢ AnalyticAt ğ•œ f x","decl":"theorem CPolynomialAt.analyticAt (hf : CPolynomialAt ğ•œ f x) : AnalyticAt ğ•œ f x :=\n  let âŸ¨p, _, hpâŸ© := hf\n  âŸ¨p, hp.toHasFPowerSeriesAtâŸ©\n\n"}
{"name":"CPolynomialAt.analyticWithinAt","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\ns : Set E\nhf : CPolynomialAt ğ•œ f x\nâŠ¢ AnalyticWithinAt ğ•œ f s x","decl":"theorem CPolynomialAt.analyticWithinAt {s : Set E} (hf : CPolynomialAt ğ•œ f x) :\n    AnalyticWithinAt ğ•œ f s x :=\n  hf.analyticAt.analyticWithinAt\n\n"}
{"name":"CPolynomialOn.analyticOnNhd","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nhf : CPolynomialOn ğ•œ f s\nâŠ¢ AnalyticOnNhd ğ•œ f s","decl":"theorem CPolynomialOn.analyticOnNhd {s : Set E} (hf : CPolynomialOn ğ•œ f s) : AnalyticOnNhd ğ•œ f s :=\n  fun x hx â†¦ (hf x hx).analyticAt\n\n"}
{"name":"CPolynomialOn.analyticOn","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nhf : CPolynomialOn ğ•œ f s\nâŠ¢ AnalyticOn ğ•œ f s","decl":"theorem CPolynomialOn.analyticOn {s : Set E} (hf : CPolynomialOn ğ•œ f s) : AnalyticOn ğ•œ f s :=\n  hf.analyticOnNhd.analyticOn\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.congr","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nn : Nat\nhf : HasFiniteFPowerSeriesOnBall f p x n r\nhg : Set.EqOn f g (EMetric.ball x r)\nâŠ¢ HasFiniteFPowerSeriesOnBall g p x n r","decl":"theorem HasFiniteFPowerSeriesOnBall.congr (hf : HasFiniteFPowerSeriesOnBall f p x n r)\n    (hg : EqOn f g (EMetric.ball x r)) : HasFiniteFPowerSeriesOnBall g p x n r :=\n  âŸ¨hf.1.congr hg, hf.finiteâŸ©\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.comp_sub","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nn : Nat\nhf : HasFiniteFPowerSeriesOnBall f p x n r\ny : E\nâŠ¢ HasFiniteFPowerSeriesOnBall (fun z => f (HSub.hSub z y)) p (HAdd.hAdd x y) n r","decl":"/-- If a function `f` has a finite power series `p` around `x`, then the function\n`z â†¦ f (z - y)` has the same finite power series around `x + y`. -/\ntheorem HasFiniteFPowerSeriesOnBall.comp_sub (hf : HasFiniteFPowerSeriesOnBall f p x n r) (y : E) :\n    HasFiniteFPowerSeriesOnBall (fun z => f (z - y)) p (x + y) n r :=\n  âŸ¨hf.1.comp_sub y, hf.finiteâŸ©\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.mono","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr r' : ENNReal\nn : Nat\nhf : HasFiniteFPowerSeriesOnBall f p x n r\nr'_pos : LT.lt 0 r'\nhr : LE.le r' r\nâŠ¢ HasFiniteFPowerSeriesOnBall f p x n r'","decl":"theorem HasFiniteFPowerSeriesOnBall.mono (hf : HasFiniteFPowerSeriesOnBall f p x n r)\n    (r'_pos : 0 < r') (hr : r' â‰¤ r) : HasFiniteFPowerSeriesOnBall f p x n r' :=\n  âŸ¨hf.1.mono r'_pos hr, hf.finiteâŸ©\n\n"}
{"name":"HasFiniteFPowerSeriesAt.congr","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nn : Nat\nhf : HasFiniteFPowerSeriesAt f p x n\nhg : (nhds x).EventuallyEq f g\nâŠ¢ HasFiniteFPowerSeriesAt g p x n","decl":"theorem HasFiniteFPowerSeriesAt.congr (hf : HasFiniteFPowerSeriesAt f p x n) (hg : f =á¶ [ğ“ x] g) :\n    HasFiniteFPowerSeriesAt g p x n :=\n  Exists.imp (fun _ hg â†¦ âŸ¨hg, hf.finiteâŸ©) (hf.toHasFPowerSeriesAt.congr hg)\n\n"}
{"name":"HasFiniteFPowerSeriesAt.eventually","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nn : Nat\nhf : HasFiniteFPowerSeriesAt f p x n\nâŠ¢ Filter.Eventually (fun r => HasFiniteFPowerSeriesOnBall f p x n r) (nhdsWithin 0 (Set.Ioi 0))","decl":"protected theorem HasFiniteFPowerSeriesAt.eventually (hf : HasFiniteFPowerSeriesAt f p x n) :\n    âˆ€á¶  r : â„â‰¥0âˆ in ğ“[>] 0, HasFiniteFPowerSeriesOnBall f p x n r :=\n  hf.toHasFPowerSeriesAt.eventually.mono fun _ h â†¦ âŸ¨h, hf.finiteâŸ©\n\n"}
{"name":"hasFiniteFPowerSeriesOnBall_const","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nc : F\ne : E\nâŠ¢ HasFiniteFPowerSeriesOnBall (fun x => c) (constFormalMultilinearSeries ğ•œ E c) e 1 Top.top","decl":"theorem hasFiniteFPowerSeriesOnBall_const {c : F} {e : E} :\n    HasFiniteFPowerSeriesOnBall (fun _ => c) (constFormalMultilinearSeries ğ•œ E c) e 1 âŠ¤ :=\n  âŸ¨hasFPowerSeriesOnBall_const, fun n hn â†¦ constFormalMultilinearSeries_apply (id hn : 0 < n).ne'âŸ©\n\n"}
{"name":"hasFiniteFPowerSeriesAt_const","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nc : F\ne : E\nâŠ¢ HasFiniteFPowerSeriesAt (fun x => c) (constFormalMultilinearSeries ğ•œ E c) e 1","decl":"theorem hasFiniteFPowerSeriesAt_const {c : F} {e : E} :\n    HasFiniteFPowerSeriesAt (fun _ => c) (constFormalMultilinearSeries ğ•œ E c) e 1 :=\n  âŸ¨âŠ¤, hasFiniteFPowerSeriesOnBall_constâŸ©\n\n"}
{"name":"CPolynomialAt_const","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\nv : F\nâŠ¢ CPolynomialAt ğ•œ (fun x => v) x","decl":"theorem CPolynomialAt_const {v : F} : CPolynomialAt ğ•œ (fun _ => v) x :=\n  âŸ¨constFormalMultilinearSeries ğ•œ E v, 1, hasFiniteFPowerSeriesAt_constâŸ©\n\n"}
{"name":"CPolynomialOn_const","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nv : F\ns : Set E\nâŠ¢ CPolynomialOn ğ•œ (fun x => v) s","decl":"theorem CPolynomialOn_const {v : F} {s : Set E} : CPolynomialOn ğ•œ (fun _ => v) s :=\n  fun _ _ => CPolynomialAt_const\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.add","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\npf pg : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nn m : Nat\nhf : HasFiniteFPowerSeriesOnBall f pf x n r\nhg : HasFiniteFPowerSeriesOnBall g pg x m r\nâŠ¢ HasFiniteFPowerSeriesOnBall (HAdd.hAdd f g) (HAdd.hAdd pf pg) x (Max.max n m) r","decl":"theorem HasFiniteFPowerSeriesOnBall.add (hf : HasFiniteFPowerSeriesOnBall f pf x n r)\n    (hg : HasFiniteFPowerSeriesOnBall g pg x m r) :\n    HasFiniteFPowerSeriesOnBall (f + g) (pf + pg) x (max n m) r :=\n  âŸ¨hf.1.add hg.1, fun N hN â†¦ by\n    rw [Pi.add_apply, hf.finite _ ((le_max_left n m).trans hN),\n        hg.finite _ ((le_max_right n m).trans hN), zero_add]âŸ©\n\n"}
{"name":"HasFiniteFPowerSeriesAt.add","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\npf pg : FormalMultilinearSeries ğ•œ E F\nx : E\nn m : Nat\nhf : HasFiniteFPowerSeriesAt f pf x n\nhg : HasFiniteFPowerSeriesAt g pg x m\nâŠ¢ HasFiniteFPowerSeriesAt (HAdd.hAdd f g) (HAdd.hAdd pf pg) x (Max.max n m)","decl":"theorem HasFiniteFPowerSeriesAt.add (hf : HasFiniteFPowerSeriesAt f pf x n)\n    (hg : HasFiniteFPowerSeriesAt g pg x m) :\n    HasFiniteFPowerSeriesAt (f + g) (pf + pg) x (max n m) := by\n  rcases (hf.eventually.and hg.eventually).exists with âŸ¨r, hrâŸ©\n  exact âŸ¨r, hr.1.add hr.2âŸ©\n\n"}
{"name":"CPolynomialAt.congr","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\nx : E\nhf : CPolynomialAt ğ•œ f x\nhg : (nhds x).EventuallyEq f g\nâŠ¢ CPolynomialAt ğ•œ g x","decl":"theorem CPolynomialAt.congr (hf : CPolynomialAt ğ•œ f x) (hg : f =á¶ [ğ“ x] g) : CPolynomialAt ğ•œ g x :=\n  let âŸ¨_, _, hpfâŸ© := hf\n  (hpf.congr hg).cPolynomialAt\n\n"}
{"name":"CPolynomialAt_congr","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\nx : E\nh : (nhds x).EventuallyEq f g\nâŠ¢ Iff (CPolynomialAt ğ•œ f x) (CPolynomialAt ğ•œ g x)","decl":"theorem CPolynomialAt_congr (h : f =á¶ [ğ“ x] g) : CPolynomialAt ğ•œ f x â†” CPolynomialAt ğ•œ g x :=\n  âŸ¨fun hf â†¦ hf.congr h, fun hg â†¦ hg.congr h.symmâŸ©\n\n"}
{"name":"CPolynomialAt.add","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\nx : E\nhf : CPolynomialAt ğ•œ f x\nhg : CPolynomialAt ğ•œ g x\nâŠ¢ CPolynomialAt ğ•œ (HAdd.hAdd f g) x","decl":"theorem CPolynomialAt.add (hf : CPolynomialAt ğ•œ f x) (hg : CPolynomialAt ğ•œ g x) :\n    CPolynomialAt ğ•œ (f + g) x :=\n  let âŸ¨_, _, hpfâŸ© := hf\n  let âŸ¨_, _, hqfâŸ© := hg\n  (hpf.add hqf).cPolynomialAt\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.neg","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\npf : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nn : Nat\nhf : HasFiniteFPowerSeriesOnBall f pf x n r\nâŠ¢ HasFiniteFPowerSeriesOnBall (Neg.neg f) (Neg.neg pf) x n r","decl":"theorem HasFiniteFPowerSeriesOnBall.neg (hf : HasFiniteFPowerSeriesOnBall f pf x n r) :\n    HasFiniteFPowerSeriesOnBall (-f) (-pf) x n r :=\n  âŸ¨hf.1.neg, fun m hm â†¦ by rw [Pi.neg_apply, hf.finite m hm, neg_zero]âŸ©\n\n"}
{"name":"HasFiniteFPowerSeriesAt.neg","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\npf : FormalMultilinearSeries ğ•œ E F\nx : E\nn : Nat\nhf : HasFiniteFPowerSeriesAt f pf x n\nâŠ¢ HasFiniteFPowerSeriesAt (Neg.neg f) (Neg.neg pf) x n","decl":"theorem HasFiniteFPowerSeriesAt.neg (hf : HasFiniteFPowerSeriesAt f pf x n) :\n    HasFiniteFPowerSeriesAt (-f) (-pf) x n :=\n  let âŸ¨_, hrfâŸ© := hf\n  hrf.neg.hasFiniteFPowerSeriesAt\n\n"}
{"name":"CPolynomialAt.neg","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nhf : CPolynomialAt ğ•œ f x\nâŠ¢ CPolynomialAt ğ•œ (Neg.neg f) x","decl":"theorem CPolynomialAt.neg (hf : CPolynomialAt ğ•œ f x) : CPolynomialAt ğ•œ (-f) x :=\n  let âŸ¨_, _, hpfâŸ© := hf\n  hpf.neg.cPolynomialAt\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.sub","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\npf pg : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nn m : Nat\nhf : HasFiniteFPowerSeriesOnBall f pf x n r\nhg : HasFiniteFPowerSeriesOnBall g pg x m r\nâŠ¢ HasFiniteFPowerSeriesOnBall (HSub.hSub f g) (HSub.hSub pf pg) x (Max.max n m) r","decl":"theorem HasFiniteFPowerSeriesOnBall.sub (hf : HasFiniteFPowerSeriesOnBall f pf x n r)\n    (hg : HasFiniteFPowerSeriesOnBall g pg x m r) :\n    HasFiniteFPowerSeriesOnBall (f - g) (pf - pg) x (max n m) r := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"HasFiniteFPowerSeriesAt.sub","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\npf pg : FormalMultilinearSeries ğ•œ E F\nx : E\nn m : Nat\nhf : HasFiniteFPowerSeriesAt f pf x n\nhg : HasFiniteFPowerSeriesAt g pg x m\nâŠ¢ HasFiniteFPowerSeriesAt (HSub.hSub f g) (HSub.hSub pf pg) x (Max.max n m)","decl":"theorem HasFiniteFPowerSeriesAt.sub (hf : HasFiniteFPowerSeriesAt f pf x n)\n    (hg : HasFiniteFPowerSeriesAt g pg x m) :\n    HasFiniteFPowerSeriesAt (f - g) (pf - pg) x (max n m) := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"CPolynomialAt.sub","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\nx : E\nhf : CPolynomialAt ğ•œ f x\nhg : CPolynomialAt ğ•œ g x\nâŠ¢ CPolynomialAt ğ•œ (HSub.hSub f g) x","decl":"theorem CPolynomialAt.sub (hf : CPolynomialAt ğ•œ f x) (hg : CPolynomialAt ğ•œ g x) :\n    CPolynomialAt ğ•œ (f - g) x := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"CPolynomialOn.mono","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns t : Set E\nhf : CPolynomialOn ğ•œ f t\nhst : HasSubset.Subset s t\nâŠ¢ CPolynomialOn ğ•œ f s","decl":"theorem CPolynomialOn.mono {s t : Set E} (hf : CPolynomialOn ğ•œ f t) (hst : s âŠ† t) :\n    CPolynomialOn ğ•œ f s :=\n  fun z hz => hf z (hst hz)\n\n"}
{"name":"CPolynomialOn.congr'","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\ns : Set E\nhf : CPolynomialOn ğ•œ f s\nhg : (nhdsSet s).EventuallyEq f g\nâŠ¢ CPolynomialOn ğ•œ g s","decl":"theorem CPolynomialOn.congr' {s : Set E} (hf : CPolynomialOn ğ•œ f s) (hg : f =á¶ [ğ“Ë¢ s] g) :\n    CPolynomialOn ğ•œ g s :=\n  fun z hz => (hf z hz).congr (mem_nhdsSet_iff_forall.mp hg z hz)\n\n"}
{"name":"CPolynomialOn_congr'","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\ns : Set E\nh : (nhdsSet s).EventuallyEq f g\nâŠ¢ Iff (CPolynomialOn ğ•œ f s) (CPolynomialOn ğ•œ g s)","decl":"theorem CPolynomialOn_congr' {s : Set E} (h : f =á¶ [ğ“Ë¢ s] g) :\n    CPolynomialOn ğ•œ f s â†” CPolynomialOn ğ•œ g s :=\n  âŸ¨fun hf => hf.congr' h, fun hg => hg.congr' h.symmâŸ©\n\n"}
{"name":"CPolynomialOn.congr","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\ns : Set E\nhs : IsOpen s\nhf : CPolynomialOn ğ•œ f s\nhg : Set.EqOn f g s\nâŠ¢ CPolynomialOn ğ•œ g s","decl":"theorem CPolynomialOn.congr {s : Set E} (hs : IsOpen s) (hf : CPolynomialOn ğ•œ f s)\n    (hg : s.EqOn f g) : CPolynomialOn ğ•œ g s :=\n  hf.congr' <| mem_nhdsSet_iff_forall.mpr\n    (fun _ hz => eventuallyEq_iff_exists_mem.mpr âŸ¨s, hs.mem_nhds hz, hgâŸ©)\n\n"}
{"name":"CPolynomialOn_congr","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\ns : Set E\nhs : IsOpen s\nh : Set.EqOn f g s\nâŠ¢ Iff (CPolynomialOn ğ•œ f s) (CPolynomialOn ğ•œ g s)","decl":"theorem CPolynomialOn_congr {s : Set E} (hs : IsOpen s) (h : s.EqOn f g) :\n    CPolynomialOn ğ•œ f s â†” CPolynomialOn ğ•œ g s :=\n  âŸ¨fun hf => hf.congr hs h, fun hg => hg.congr hs h.symmâŸ©\n\n"}
{"name":"CPolynomialOn.add","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\ns : Set E\nhf : CPolynomialOn ğ•œ f s\nhg : CPolynomialOn ğ•œ g s\nâŠ¢ CPolynomialOn ğ•œ (HAdd.hAdd f g) s","decl":"theorem CPolynomialOn.add {s : Set E} (hf : CPolynomialOn ğ•œ f s) (hg : CPolynomialOn ğ•œ g s) :\n    CPolynomialOn ğ•œ (f + g) s :=\n  fun z hz => (hf z hz).add (hg z hz)\n\n"}
{"name":"CPolynomialOn.sub","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\ns : Set E\nhf : CPolynomialOn ğ•œ f s\nhg : CPolynomialOn ğ•œ g s\nâŠ¢ CPolynomialOn ğ•œ (HSub.hSub f g) s","decl":"theorem CPolynomialOn.sub {s : Set E} (hf : CPolynomialOn ğ•œ f s) (hg : CPolynomialOn ğ•œ g s) :\n    CPolynomialOn ğ•œ (f - g) s :=\n  fun z hz => (hf z hz).sub (hg z hz)\n\n"}
{"name":"ContinuousLinearMap.comp_hasFiniteFPowerSeriesOnBall","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nn : Nat\ng : ContinuousLinearMap (RingHom.id ğ•œ) F G\nh : HasFiniteFPowerSeriesOnBall f p x n r\nâŠ¢ HasFiniteFPowerSeriesOnBall (Function.comp (â‡‘g) f) (g.compFormalMultilinearSeries p) x n r","decl":"/-- If a function `f` has a finite power series `p` on a ball and `g` is a continuous linear map,\nthen `g âˆ˜ f` has the finite power series `g âˆ˜ p` on the same ball. -/\ntheorem ContinuousLinearMap.comp_hasFiniteFPowerSeriesOnBall (g : F â†’L[ğ•œ] G)\n    (h : HasFiniteFPowerSeriesOnBall f p x n r) :\n    HasFiniteFPowerSeriesOnBall (g âˆ˜ f) (g.compFormalMultilinearSeries p) x n r :=\n  âŸ¨g.comp_hasFPowerSeriesOnBall h.1, fun m hm â†¦ by\n    rw [compFormalMultilinearSeries_apply, h.finite m hm]\n    ext; exact map_zero gâŸ©\n\n"}
{"name":"ContinuousLinearMap.comp_cPolynomialOn","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\ns : Set E\ng : ContinuousLinearMap (RingHom.id ğ•œ) F G\nh : CPolynomialOn ğ•œ f s\nâŠ¢ CPolynomialOn ğ•œ (Function.comp (â‡‘g) f) s","decl":"/-- If a function `f` is continuously polynomial on a set `s` and `g` is a continuous linear map,\nthen `g âˆ˜ f` is continuously polynomial on `s`. -/\ntheorem ContinuousLinearMap.comp_cPolynomialOn {s : Set E} (g : F â†’L[ğ•œ] G)\n    (h : CPolynomialOn ğ•œ f s) : CPolynomialOn ğ•œ (g âˆ˜ f) s := by\n  rintro x hx\n  rcases h x hx with âŸ¨p, n, r, hpâŸ©\n  exact âŸ¨g.compFormalMultilinearSeries p, n, r, g.comp_hasFiniteFPowerSeriesOnBall hpâŸ©\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.eq_partialSum","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nn : Nat\nhf : HasFiniteFPowerSeriesOnBall f p x n r\ny : E\naâœÂ¹ : Membership.mem (EMetric.ball 0 r) y\nm : Nat\naâœ : LE.le n m\nâŠ¢ Eq (f (HAdd.hAdd x y)) (p.partialSum m y)","decl":"/-- If a function admits a finite power series expansion bounded by `n`, then it is equal to\nthe `m`th partial sums of this power series at every point of the disk for `n â‰¤ m`. -/\ntheorem HasFiniteFPowerSeriesOnBall.eq_partialSum\n    (hf : HasFiniteFPowerSeriesOnBall f p x n r) :\n    âˆ€ y âˆˆ EMetric.ball (0 : E) r, âˆ€ m, n â‰¤ m â†’\n    f (x + y) = p.partialSum m y :=\n  fun y hy m hm â†¦ (hf.hasSum hy).unique (hasSum_sum_of_ne_finset_zero\n    (f := fun m => p m (fun _ => y)) (s := Finset.range m)\n    (fun N hN => by simp only; simp only [Finset.mem_range, not_lt] at hN\n                    rw [hf.finite _ (le_trans hm hN), ContinuousMultilinearMap.zero_apply]))\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.eq_partialSum'","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nn : Nat\nhf : HasFiniteFPowerSeriesOnBall f p x n r\ny : E\naâœÂ¹ : Membership.mem (EMetric.ball x r) y\nm : Nat\naâœ : LE.le n m\nâŠ¢ Eq (f y) (p.partialSum m (HSub.hSub y x))","decl":"/-- Variant of the previous result with the variable expressed as `y` instead of `x + y`. -/\ntheorem HasFiniteFPowerSeriesOnBall.eq_partialSum'\n    (hf : HasFiniteFPowerSeriesOnBall f p x n r) :\n    âˆ€ y âˆˆ EMetric.ball x r, âˆ€ m, n â‰¤ m â†’\n    f y = p.partialSum m (y - x) := by\n  intro y hy m hm\n  rw [EMetric.mem_ball, edist_eq_enorm_sub, â† mem_emetric_ball_zero_iff] at hy\n  rw [â† (HasFiniteFPowerSeriesOnBall.eq_partialSum hf _ hy m hm), add_sub_cancel]\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.eq_zero_of_bound_zero","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\npf : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nhf : HasFiniteFPowerSeriesOnBall f pf x 0 r\ny : E\naâœ : Membership.mem (EMetric.ball x r) y\nâŠ¢ Eq (f y) 0","decl":"/-- If `f` has a formal power series on a ball bounded by `0`, then `f` is equal to `0` on\nthe ball. -/\ntheorem HasFiniteFPowerSeriesOnBall.eq_zero_of_bound_zero\n    (hf : HasFiniteFPowerSeriesOnBall f pf x 0 r) : âˆ€ y âˆˆ EMetric.ball x r, f y = 0 := by\n  intro y hy\n  rw [hf.eq_partialSum' y hy 0 le_rfl, FormalMultilinearSeries.partialSum]\n  simp only [Finset.range_zero, Finset.sum_empty]\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.bound_zero_of_eq_zero","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nhf : âˆ€ (y : E), Membership.mem (EMetric.ball x r) y â†’ Eq (f y) 0\nr_pos : LT.lt 0 r\nhp : âˆ€ (n : Nat), Eq (p n) 0\nâŠ¢ HasFiniteFPowerSeriesOnBall f p x 0 r","decl":"theorem HasFiniteFPowerSeriesOnBall.bound_zero_of_eq_zero (hf : âˆ€ y âˆˆ EMetric.ball x r, f y = 0)\n    (r_pos : 0 < r) (hp : âˆ€ n, p n = 0) : HasFiniteFPowerSeriesOnBall f p x 0 r := by\n  refine âŸ¨âŸ¨?_, r_pos, ?_âŸ©, fun n _ â†¦ hp nâŸ©\n  Â· rw [p.radius_eq_top_of_forall_image_add_eq_zero 0 (fun n â†¦ by rw [add_zero]; exact hp n)]\n    exact le_top\n  Â· intro y hy\n    rw [hf (x + y)]\n    Â· convert hasSum_zero\n      rw [hp, ContinuousMultilinearMap.zero_apply]\n    Â· rwa [EMetric.mem_ball, edist_eq_enorm_sub, add_comm, add_sub_cancel_right,\n        â† edist_zero_eq_enorm, â† EMetric.mem_ball]\n\n"}
{"name":"HasFiniteFPowerSeriesAt.eventually_zero_of_bound_zero","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\npf : FormalMultilinearSeries ğ•œ E F\nx : E\nhf : HasFiniteFPowerSeriesAt f pf x 0\nâŠ¢ (nhds x).EventuallyEq f 0","decl":"/-- If `f` has a formal power series at `x` bounded by `0`, then `f` is equal to `0` in a\nneighborhood of `x`. -/\ntheorem HasFiniteFPowerSeriesAt.eventually_zero_of_bound_zero\n    (hf : HasFiniteFPowerSeriesAt f pf x 0) : f =á¶ [ğ“ x] 0 :=\n  Filter.eventuallyEq_iff_exists_mem.mpr (let âŸ¨r, hfâŸ© := hf; âŸ¨EMetric.ball x r,\n    EMetric.ball_mem_nhds x hf.r_pos, fun y hy â†¦ hf.eq_zero_of_bound_zero y hyâŸ©)\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.eq_const_of_bound_one","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\npf : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nhf : HasFiniteFPowerSeriesOnBall f pf x 1 r\ny : E\naâœ : Membership.mem (EMetric.ball x r) y\nâŠ¢ Eq (f y) (f x)","decl":"/-- If `f` has a formal power series on a ball bounded by `1`, then `f` is constant equal\nto `f x` on the ball. -/\ntheorem HasFiniteFPowerSeriesOnBall.eq_const_of_bound_one\n    (hf : HasFiniteFPowerSeriesOnBall f pf x 1 r) : âˆ€ y âˆˆ EMetric.ball x r, f y = f x := by\n  intro y hy\n  rw [hf.eq_partialSum' y hy 1 le_rfl, hf.eq_partialSum' x\n    (by rw [EMetric.mem_ball, edist_self]; exact hf.r_pos) 1 le_rfl]\n  simp only [FormalMultilinearSeries.partialSum, Finset.range_one, Finset.sum_singleton]\n  congr\n  apply funext\n  simp only [IsEmpty.forall_iff]\n\n"}
{"name":"HasFiniteFPowerSeriesAt.eventually_const_of_bound_one","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\npf : FormalMultilinearSeries ğ•œ E F\nx : E\nhf : HasFiniteFPowerSeriesAt f pf x 1\nâŠ¢ (nhds x).EventuallyEq f fun x_1 => f x","decl":"/-- If `f` has a formal power series at x bounded by `1`, then `f` is constant equal\nto `f x` in a neighborhood of `x`. -/\ntheorem HasFiniteFPowerSeriesAt.eventually_const_of_bound_one\n    (hf : HasFiniteFPowerSeriesAt f pf x 1) : f =á¶ [ğ“ x] (fun _ => f x) :=\n  Filter.eventuallyEq_iff_exists_mem.mpr (let âŸ¨r, hfâŸ© := hf; âŸ¨EMetric.ball x r,\n    EMetric.ball_mem_nhds x hf.r_pos, fun y hy â†¦ hf.eq_const_of_bound_one y hyâŸ©)\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.continuousOn","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nn : Nat\nhf : HasFiniteFPowerSeriesOnBall f p x n r\nâŠ¢ ContinuousOn f (EMetric.ball x r)","decl":"/-- If a function admits a finite power series expansion on a disk, then it is continuous there. -/\nprotected theorem HasFiniteFPowerSeriesOnBall.continuousOn\n    (hf : HasFiniteFPowerSeriesOnBall f p x n r) :\n    ContinuousOn f (EMetric.ball x r) := hf.1.continuousOn\n\n"}
{"name":"HasFiniteFPowerSeriesAt.continuousAt","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nn : Nat\nhf : HasFiniteFPowerSeriesAt f p x n\nâŠ¢ ContinuousAt f x","decl":"protected theorem HasFiniteFPowerSeriesAt.continuousAt (hf : HasFiniteFPowerSeriesAt f p x n) :\n    ContinuousAt f x := hf.toHasFPowerSeriesAt.continuousAt\n\n"}
{"name":"CPolynomialAt.continuousAt","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nhf : CPolynomialAt ğ•œ f x\nâŠ¢ ContinuousAt f x","decl":"protected theorem CPolynomialAt.continuousAt (hf : CPolynomialAt ğ•œ f x) : ContinuousAt f x :=\n  hf.analyticAt.continuousAt\n\n"}
{"name":"CPolynomialOn.continuousOn","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nhf : CPolynomialOn ğ•œ f s\nâŠ¢ ContinuousOn f s","decl":"protected theorem CPolynomialOn.continuousOn {s : Set E} (hf : CPolynomialOn ğ•œ f s) :\n    ContinuousOn f s :=\n  hf.analyticOnNhd.continuousOn\n\n"}
{"name":"CPolynomialOn.continuous","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nfa : CPolynomialOn ğ•œ f Set.univ\nâŠ¢ Continuous f","decl":"/-- Continuously polynomial everywhere implies continuous -/\ntheorem CPolynomialOn.continuous {f : E â†’ F} (fa : CPolynomialOn ğ•œ f univ) : Continuous f := by\n  rw [continuous_iff_continuousOn_univ]; exact fa.continuousOn\n\n"}
{"name":"FormalMultilinearSeries.sum_of_finite","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nn : Nat\nhn : âˆ€ (m : Nat), LE.le n m â†’ Eq (p m) 0\nx : E\nâŠ¢ Eq (p.sum x) (p.partialSum n x)","decl":"protected theorem FormalMultilinearSeries.sum_of_finite (p : FormalMultilinearSeries ğ•œ E F)\n    {n : â„•} (hn : âˆ€ m, n â‰¤ m â†’ p m = 0) (x : E) :\n    p.sum x = p.partialSum n x :=\n  tsum_eq_sum fun m hm â†¦ by rw [Finset.mem_range, not_lt] at hm; rw [hn m hm]; rfl\n\n"}
{"name":"FormalMultilinearSeries.hasSum_of_finite","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nn : Nat\nhn : âˆ€ (m : Nat), LE.le n m â†’ Eq (p m) 0\nx : E\nâŠ¢ HasSum (fun n => (p n) fun x_1 => x) (p.sum x)","decl":"/-- A finite formal multilinear series sums to its sum at every point. -/\nprotected theorem FormalMultilinearSeries.hasSum_of_finite (p : FormalMultilinearSeries ğ•œ E F)\n    {n : â„•} (hn : âˆ€ m, n â‰¤ m â†’ p m = 0) (x : E) :\n    HasSum (fun n : â„• => p n fun _ => x) (p.sum x) :=\n  summable_of_ne_finset_zero (s := .range n)\n    (fun m hm â†¦ by rw [Finset.mem_range, not_lt] at hm; rw [hn m hm]; rfl)\n    |>.hasSum\n\n"}
{"name":"FormalMultilinearSeries.hasFiniteFPowerSeriesOnBall_of_finite","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nn : Nat\nhn : âˆ€ (m : Nat), LE.le n m â†’ Eq (p m) 0\nâŠ¢ HasFiniteFPowerSeriesOnBall p.sum p 0 n Top.top","decl":"/-- The sum of a finite power series `p` admits `p` as a power series. -/\nprotected theorem FormalMultilinearSeries.hasFiniteFPowerSeriesOnBall_of_finite\n    (p : FormalMultilinearSeries ğ•œ E F) {n : â„•} (hn : âˆ€ m, n â‰¤ m â†’ p m = 0) :\n    HasFiniteFPowerSeriesOnBall p.sum p 0 n âŠ¤ where\n  r_le := by rw [radius_eq_top_of_forall_image_add_eq_zero p n fun _ => hn _ (Nat.le_add_left _ _)]\n  r_pos := zero_lt_top\n  finite := hn\n  hasSum {y} _ := by rw [zero_add]; exact p.hasSum_of_finite hn y\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.sum","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nn : Nat\nh : HasFiniteFPowerSeriesOnBall f p x n r\ny : E\nhy : Membership.mem (EMetric.ball 0 r) y\nâŠ¢ Eq (f (HAdd.hAdd x y)) (p.sum y)","decl":"theorem HasFiniteFPowerSeriesOnBall.sum (h : HasFiniteFPowerSeriesOnBall f p x n r) {y : E}\n    (hy : y âˆˆ EMetric.ball (0 : E) r) : f (x + y) = p.sum y :=\n  (h.hasSum hy).tsum_eq.symm\n\n"}
{"name":"FormalMultilinearSeries.continuousOn_of_finite","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nn : Nat\nhn : âˆ€ (m : Nat), LE.le n m â†’ Eq (p m) 0\nâŠ¢ Continuous p.sum","decl":"/-- The sum of a finite power series is continuous. -/\nprotected theorem FormalMultilinearSeries.continuousOn_of_finite\n    (p : FormalMultilinearSeries ğ•œ E F) {n : â„•} (hn : âˆ€ m, n â‰¤ m â†’ p m = 0) :\n    Continuous p.sum := by\n  rw [continuous_iff_continuousOn_univ, â† Metric.emetric_ball_top]\n  exact (p.hasFiniteFPowerSeriesOnBall_of_finite hn).continuousOn\n\n"}
{"name":"FormalMultilinearSeries.changeOriginSeriesTerm_bound","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nn : Nat\nhn : âˆ€ (m : Nat), LE.le n m â†’ Eq (p m) 0\nk l : Nat\ns : Finset (Fin (HAdd.hAdd k l))\nhs : Eq s.card l\nhkl : LE.le n (HAdd.hAdd k l)\nâŠ¢ Eq (p.changeOriginSeriesTerm k l s hs) 0","decl":"/-- If `p` is a formal multilinear series such that `p m = 0` for `n â‰¤ m`, then\n`p.changeOriginSeriesTerm k l = 0` for `n â‰¤ k + l`. -/\nlemma changeOriginSeriesTerm_bound (p : FormalMultilinearSeries ğ•œ E F) {n : â„•}\n    (hn : âˆ€ (m : â„•), n â‰¤ m â†’ p m = 0) (k l : â„•) {s : Finset (Fin (k + l))}\n    (hs : s.card = l) (hkl : n â‰¤ k + l) :\n    p.changeOriginSeriesTerm k l s hs = 0 := by\n  #adaptation_note /-- https://github.com/leanprover/lean4/pull/4119\n  `set_option maxSynthPendingDepth 2` required after https://github.com/leanprover/lean4/pull/4119 -/\n  set_option maxSynthPendingDepth 2 in\n  rw [changeOriginSeriesTerm, hn _ hkl, map_zero]\n\n"}
{"name":"FormalMultilinearSeries.changeOriginSeries_finite_of_finite","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nn : Nat\nhn : âˆ€ (m : Nat), LE.le n m â†’ Eq (p m) 0\nk m : Nat\naâœ : LE.le n (HAdd.hAdd k m)\nâŠ¢ Eq (p.changeOriginSeries k m) 0","decl":"/-- If `p` is a finite formal multilinear series, then so is `p.changeOriginSeries k` for every\n`k` in `â„•`. More precisely, if `p m = 0` for `n â‰¤ m`, then `p.changeOriginSeries k m = 0` for\n`n â‰¤ k + m`. -/\nlemma changeOriginSeries_finite_of_finite (p : FormalMultilinearSeries ğ•œ E F) {n : â„•}\n    (hn : âˆ€ (m : â„•), n â‰¤ m â†’ p m = 0) (k : â„•) : âˆ€ {m : â„•}, n â‰¤ k + m â†’\n    p.changeOriginSeries k m = 0 := by\n  intro m hm\n  rw [changeOriginSeries]\n  exact Finset.sum_eq_zero (fun _ _ => p.changeOriginSeriesTerm_bound hn _ _ _ hm)\n\n"}
{"name":"FormalMultilinearSeries.changeOriginSeries_sum_eq_partialSum_of_finite","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nn : Nat\nhn : âˆ€ (m : Nat), LE.le n m â†’ Eq (p m) 0\nk : Nat\nâŠ¢ Eq (p.changeOriginSeries k).sum ((p.changeOriginSeries k).partialSum (HSub.hSub n k))","decl":"lemma changeOriginSeries_sum_eq_partialSum_of_finite (p : FormalMultilinearSeries ğ•œ E F) {n : â„•}\n    (hn : âˆ€ (m : â„•), n â‰¤ m â†’ p m = 0) (k : â„•) :\n    (p.changeOriginSeries k).sum = (p.changeOriginSeries k).partialSum (n - k) := by\n  ext x\n  rw [partialSum, FormalMultilinearSeries.sum,\n    tsum_eq_sum (f := fun m => p.changeOriginSeries k m (fun _ => x)) (s := Finset.range (n - k))]\n  intro m hm\n  rw [Finset.mem_range, not_lt] at hm\n  rw [p.changeOriginSeries_finite_of_finite hn k (by rw [add_comm]; exact Nat.le_add_of_sub_le hm),\n    ContinuousMultilinearMap.zero_apply]\n\n"}
{"name":"FormalMultilinearSeries.changeOrigin_finite_of_finite","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\np : FormalMultilinearSeries ğ•œ E F\nn : Nat\nhn : âˆ€ (m : Nat), LE.le n m â†’ Eq (p m) 0\nk : Nat\nhk : LE.le n k\nâŠ¢ Eq (p.changeOrigin x k) 0","decl":"/-- If `p` is a formal multilinear series such that `p m = 0` for `n â‰¤ m`, then\n`p.changeOrigin x k = 0` for `n â‰¤ k`. -/\nlemma changeOrigin_finite_of_finite (p : FormalMultilinearSeries ğ•œ E F) {n : â„•}\n    (hn : âˆ€ (m : â„•), n â‰¤ m â†’ p m = 0) {k : â„•} (hk : n â‰¤ k) :\n    p.changeOrigin x k = 0 := by\n  rw [changeOrigin, p.changeOriginSeries_sum_eq_partialSum_of_finite hn]\n  apply Finset.sum_eq_zero\n  intro m hm\n  rw [Finset.mem_range] at hm\n  rw [p.changeOriginSeries_finite_of_finite hn k (le_add_of_le_left hk),\n    ContinuousMultilinearMap.zero_apply]\n\n"}
{"name":"FormalMultilinearSeries.hasFiniteFPowerSeriesOnBall_changeOrigin","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nn k : Nat\nhn : âˆ€ (m : Nat), LE.le (HAdd.hAdd n k) m â†’ Eq (p m) 0\nâŠ¢ HasFiniteFPowerSeriesOnBall (fun x => p.changeOrigin x k) (p.changeOriginSeries k) 0 n Top.top","decl":"theorem hasFiniteFPowerSeriesOnBall_changeOrigin (p : FormalMultilinearSeries ğ•œ E F) {n : â„•}\n    (k : â„•) (hn : âˆ€ (m : â„•), n + k â‰¤ m â†’ p m = 0) :\n    HasFiniteFPowerSeriesOnBall (p.changeOrigin Â· k) (p.changeOriginSeries k) 0 n âŠ¤ :=\n  (p.changeOriginSeries k).hasFiniteFPowerSeriesOnBall_of_finite\n    (fun _ hm => p.changeOriginSeries_finite_of_finite hn k\n    (by rw [add_comm n k]; apply add_le_add_left hm))\n\n"}
{"name":"FormalMultilinearSeries.changeOrigin_eval_of_finite","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nn : Nat\nhn : âˆ€ (m : Nat), LE.le n m â†’ Eq (p m) 0\nx y : E\nâŠ¢ Eq ((p.changeOrigin x).sum y) (p.sum (HAdd.hAdd x y))","decl":"theorem changeOrigin_eval_of_finite (p : FormalMultilinearSeries ğ•œ E F) {n : â„•}\n    (hn : âˆ€ (m : â„•), n â‰¤ m â†’ p m = 0) (x y : E) :\n    (p.changeOrigin x).sum y = p.sum (x + y) := by\n  let f (s : Î£ k l : â„•, { s : Finset (Fin (k + l)) // s.card = l }) : F :=\n    p.changeOriginSeriesTerm s.1 s.2.1 s.2.2 s.2.2.2 (fun _ â†¦ x) fun _ â†¦ y\n  have finsupp : f.support.Finite := by\n    apply Set.Finite.subset (s := changeOriginIndexEquiv â»Â¹' (Sigma.fst â»Â¹' {m | m < n}))\n    Â· apply Set.Finite.preimage (Equiv.injective _).injOn\n      simp_rw [â† {m | m < n}.iUnion_of_singleton_coe, preimage_iUnion, â† range_sigmaMk]\n      exact finite_iUnion fun _ â†¦ finite_range _\n    Â· refine fun s â†¦ Not.imp_symm fun hs â†¦ ?_\n      simp only [preimage_setOf_eq, changeOriginIndexEquiv_apply_fst, mem_setOf, not_lt] at hs\n      dsimp only [f]\n      rw [changeOriginSeriesTerm_bound p hn _ _ _ hs, ContinuousMultilinearMap.zero_apply,\n        ContinuousMultilinearMap.zero_apply]\n  have hfkl k l : HasSum (f âŸ¨k, l, Â·âŸ©) (changeOriginSeries p k l (fun _ â†¦ x) fun _ â†¦ y) := by\n    simp_rw [changeOriginSeries, ContinuousMultilinearMap.sum_apply]; apply hasSum_fintype\n  have hfk k : HasSum (f âŸ¨k, Â·âŸ©) (changeOrigin p x k fun _ â†¦ y) := by\n    have (m) (hm : m âˆ‰ Finset.range n) : changeOriginSeries p k m (fun _ â†¦ x) = 0 := by\n      rw [Finset.mem_range, not_lt] at hm\n      rw [changeOriginSeries_finite_of_finite _ hn _ (le_add_of_le_right hm),\n        ContinuousMultilinearMap.zero_apply]\n    rw [changeOrigin, FormalMultilinearSeries.sum,\n      ContinuousMultilinearMap.tsum_eval (summable_of_ne_finset_zero this)]\n    refine (summable_of_ne_finset_zero (s := Finset.range n) fun m hm â†¦ ?_).hasSum.sigma_of_hasSum\n      (hfkl k) (summable_of_finite_support <| finsupp.preimage sigma_mk_injective.injOn)\n    rw [this m hm, ContinuousMultilinearMap.zero_apply]\n  have hf : HasSum f ((p.changeOrigin x).sum y) :=\n    ((p.changeOrigin x).hasSum_of_finite (fun _ â†¦ changeOrigin_finite_of_finite p hn) _)\n      |>.sigma_of_hasSum hfk (summable_of_finite_support finsupp)\n  refine hf.unique (changeOriginIndexEquiv.symm.hasSum_iff.1 ?_)\n  refine (p.hasSum_of_finite hn (x + y)).sigma_of_hasSum (fun n â†¦ ?_)\n    (changeOriginIndexEquiv.symm.summable_iff.2 hf.summable)\n  rw [â† Pi.add_def, (p n).map_add_univ (fun _ â†¦ x) fun _ â†¦ y]\n  simp_rw [â† changeOriginSeriesTerm_changeOriginIndexEquiv_symm]\n  exact hasSum_fintype fun c â†¦ f (changeOriginIndexEquiv.symm âŸ¨n, câŸ©)\n\n"}
{"name":"FormalMultilinearSeries.cPolynomialAt_changeOrigin_of_finite","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nn : Nat\nhn : âˆ€ (m : Nat), LE.le n m â†’ Eq (p m) 0\nk : Nat\nâŠ¢ CPolynomialAt ğ•œ (fun x => p.changeOrigin x k) 0","decl":"/-- The terms of the formal multilinear series `p.changeOrigin` are continuously polynomial\nas we vary the origin -/\ntheorem cPolynomialAt_changeOrigin_of_finite (p : FormalMultilinearSeries ğ•œ E F)\n    {n : â„•} (hn : âˆ€ (m : â„•), n â‰¤ m â†’ p m = 0) (k : â„•) :\n    CPolynomialAt ğ•œ (p.changeOrigin Â· k) 0 :=\n  (p.hasFiniteFPowerSeriesOnBall_changeOrigin k fun _ h â†¦ hn _ (le_self_add.trans h)).cPolynomialAt\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.changeOrigin","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nr : ENNReal\nn : Nat\nx y : E\nhf : HasFiniteFPowerSeriesOnBall f p x n r\nh : LT.lt (â†‘(NNNorm.nnnorm y)) r\nâŠ¢ HasFiniteFPowerSeriesOnBall f (p.changeOrigin y) (HAdd.hAdd x y) n (HSub.hSub r â†‘(NNNorm.nnnorm y))","decl":"theorem HasFiniteFPowerSeriesOnBall.changeOrigin (hf : HasFiniteFPowerSeriesOnBall f p x n r)\n    (h : (â€–yâ€–â‚Š : â„â‰¥0âˆ) < r) :\n    HasFiniteFPowerSeriesOnBall f (p.changeOrigin y) (x + y) n (r - â€–yâ€–â‚Š) where\n  r_le := (tsub_le_tsub_right hf.r_le _).trans p.changeOrigin_radius\n  r_pos := by simp [h]\n  finite _ hm := p.changeOrigin_finite_of_finite hf.finite hm\n  hasSum {z} hz := by\n    have : f (x + y + z) =\n        FormalMultilinearSeries.sum (FormalMultilinearSeries.changeOrigin p y) z := by\n      rw [mem_emetric_ball_zero_iff, lt_tsub_iff_right, add_comm] at hz\n      rw [p.changeOrigin_eval_of_finite hf.finite, add_assoc, hf.sum]\n      exact mem_emetric_ball_zero_iff.2 ((enorm_add_le _ _).trans_lt hz)\n    rw [this]\n    apply (p.changeOrigin y).hasSum_of_finite fun _ => p.changeOrigin_finite_of_finite hf.finite\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.cPolynomialAt_of_mem","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nr : ENNReal\nn : Nat\nx y : E\nhf : HasFiniteFPowerSeriesOnBall f p x n r\nh : Membership.mem (EMetric.ball x r) y\nâŠ¢ CPolynomialAt ğ•œ f y","decl":"/-- If a function admits a finite power series expansion `p` on an open ball `B (x, r)`, then\nit is continuously polynomial at every point of this ball. -/\ntheorem HasFiniteFPowerSeriesOnBall.cPolynomialAt_of_mem\n    (hf : HasFiniteFPowerSeriesOnBall f p x n r) (h : y âˆˆ EMetric.ball x r) :\n    CPolynomialAt ğ•œ f y := by\n  have : (â€–y - xâ€–â‚Š : â„â‰¥0âˆ) < r := by simpa [edist_eq_enorm_sub] using h\n  have := hf.changeOrigin this\n  rw [add_sub_cancel] at this\n  exact this.cPolynomialAt\n\n"}
{"name":"HasFiniteFPowerSeriesOnBall.cPolynomialOn","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nr : ENNReal\nn : Nat\nx : E\nhf : HasFiniteFPowerSeriesOnBall f p x n r\nâŠ¢ CPolynomialOn ğ•œ f (EMetric.ball x r)","decl":"theorem HasFiniteFPowerSeriesOnBall.cPolynomialOn (hf : HasFiniteFPowerSeriesOnBall f p x n r) :\n    CPolynomialOn ğ•œ f (EMetric.ball x r) :=\n  fun _y hy => hf.cPolynomialAt_of_mem hy\n\n"}
{"name":"isOpen_cPolynomialAt","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nâŠ¢ IsOpen (setOf fun x => CPolynomialAt ğ•œ f x)","decl":"/-- For any function `f` from a normed vector space to a normed vector space, the set of points\n`x` such that `f` is continuously polynomial at `x` is open. -/\ntheorem isOpen_cPolynomialAt : IsOpen { x | CPolynomialAt ğ•œ f x } := by\n  rw [isOpen_iff_mem_nhds]\n  rintro x âŸ¨p, n, r, hrâŸ©\n  exact mem_of_superset (EMetric.ball_mem_nhds _ hr.r_pos) fun y hy => hr.cPolynomialAt_of_mem hy\n\n"}
{"name":"CPolynomialAt.eventually_cPolynomialAt","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nh : CPolynomialAt ğ•œ f x\nâŠ¢ Filter.Eventually (fun y => CPolynomialAt ğ•œ f y) (nhds x)","decl":"theorem CPolynomialAt.eventually_cPolynomialAt {f : E â†’ F} {x : E} (h : CPolynomialAt ğ•œ f x) :\n    âˆ€á¶  y in ğ“ x, CPolynomialAt ğ•œ f y :=\n  (isOpen_cPolynomialAt ğ•œ f).mem_nhds h\n\n"}
{"name":"CPolynomialAt.exists_mem_nhds_cPolynomialOn","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nh : CPolynomialAt ğ•œ f x\nâŠ¢ Exists fun s => And (Membership.mem (nhds x) s) (CPolynomialOn ğ•œ f s)","decl":"theorem CPolynomialAt.exists_mem_nhds_cPolynomialOn {f : E â†’ F} {x : E} (h : CPolynomialAt ğ•œ f x) :\n    âˆƒ s âˆˆ ğ“ x, CPolynomialOn ğ•œ f s :=\n  h.eventually_cPolynomialAt.exists_mem\n\n"}
{"name":"CPolynomialAt.exists_ball_cPolynomialOn","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nh : CPolynomialAt ğ•œ f x\nâŠ¢ Exists fun r => And (LT.lt 0 r) (CPolynomialOn ğ•œ f (Metric.ball x r))","decl":"/-- If `f` is continuously polynomial at a point, then it is continuously polynomial in a\nnonempty ball around that point. -/\ntheorem CPolynomialAt.exists_ball_cPolynomialOn {f : E â†’ F} {x : E} (h : CPolynomialAt ğ•œ f x) :\n    âˆƒ r : â„, 0 < r âˆ§ CPolynomialOn ğ•œ f (Metric.ball x r) :=\n  Metric.isOpen_iff.mp (isOpen_cPolynomialAt _ _) _ h\n\n"}
{"name":"ContinuousMultilinearMap.hasFiniteFPowerSeriesOnBall","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace ğ•œ F\nÎ¹ : Type u_5\nEm : Î¹ â†’ Type u_6\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (Em i)\ninstâœÂ¹ : (i : Î¹) â†’ NormedSpace ğ•œ (Em i)\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ Em F\nâŠ¢ HasFiniteFPowerSeriesOnBall (â‡‘f) f.toFormalMultilinearSeries 0 (HAdd.hAdd (Fintype.card Î¹) 1) Top.top","decl":"protected theorem hasFiniteFPowerSeriesOnBall :\n    HasFiniteFPowerSeriesOnBall f f.toFormalMultilinearSeries 0 (Fintype.card Î¹ + 1) âŠ¤ :=\n  .mk' (fun _ hm â†¦ dif_neg (Nat.succ_le_iff.mp hm).ne) ENNReal.zero_lt_top fun y _ â†¦ by\n    rw [Finset.sum_eq_single_of_mem _ (Finset.self_mem_range_succ _), zero_add]\n    Â· rw [toFormalMultilinearSeries, dif_pos rfl]; rfl\n    Â· intro m _ ne; rw [toFormalMultilinearSeries, dif_neg ne.symm]; rfl\n\n"}
{"name":"ContinuousMultilinearMap.cpolynomialAt","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace ğ•œ F\nÎ¹ : Type u_5\nEm : Î¹ â†’ Type u_6\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (Em i)\ninstâœÂ¹ : (i : Î¹) â†’ NormedSpace ğ•œ (Em i)\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ Em F\nx : (i : Î¹) â†’ Em i\nâŠ¢ CPolynomialAt ğ•œ (â‡‘f) x","decl":"lemma cpolynomialAt  : CPolynomialAt ğ•œ f x :=\n  f.hasFiniteFPowerSeriesOnBall.cPolynomialAt_of_mem\n    (by simp only [Metric.emetric_ball_top, Set.mem_univ])\n\n"}
{"name":"ContinuousMultilinearMap.cpolyomialOn","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace ğ•œ F\nÎ¹ : Type u_5\nEm : Î¹ â†’ Type u_6\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (Em i)\ninstâœÂ¹ : (i : Î¹) â†’ NormedSpace ğ•œ (Em i)\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ Em F\ns : Set ((i : Î¹) â†’ Em i)\nâŠ¢ CPolynomialOn ğ•œ (â‡‘f) s","decl":"lemma cpolyomialOn : CPolynomialOn ğ•œ f s := fun _ _ â†¦ f.cpolynomialAt\n\n"}
{"name":"ContinuousMultilinearMap.analyticOnNhd","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace ğ•œ F\nÎ¹ : Type u_5\nEm : Î¹ â†’ Type u_6\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (Em i)\ninstâœÂ¹ : (i : Î¹) â†’ NormedSpace ğ•œ (Em i)\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ Em F\ns : Set ((i : Î¹) â†’ Em i)\nâŠ¢ AnalyticOnNhd ğ•œ (â‡‘f) s","decl":"lemma analyticOnNhd : AnalyticOnNhd ğ•œ f s := f.cpolyomialOn.analyticOnNhd\n\n"}
{"name":"ContinuousMultilinearMap.analyticOn","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace ğ•œ F\nÎ¹ : Type u_5\nEm : Î¹ â†’ Type u_6\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (Em i)\ninstâœÂ¹ : (i : Î¹) â†’ NormedSpace ğ•œ (Em i)\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ Em F\ns : Set ((i : Î¹) â†’ Em i)\nâŠ¢ AnalyticOn ğ•œ (â‡‘f) s","decl":"lemma analyticOn : AnalyticOn ğ•œ f s := f.analyticOnNhd.analyticOn\n\n"}
{"name":"ContinuousMultilinearMap.analyticWithinOn","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace ğ•œ F\nÎ¹ : Type u_5\nEm : Î¹ â†’ Type u_6\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (Em i)\ninstâœÂ¹ : (i : Î¹) â†’ NormedSpace ğ•œ (Em i)\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ Em F\ns : Set ((i : Î¹) â†’ Em i)\nâŠ¢ AnalyticOn ğ•œ (â‡‘f) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias analyticWithinOn := analyticOn\n\n"}
{"name":"ContinuousMultilinearMap.analyticAt","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace ğ•œ F\nÎ¹ : Type u_5\nEm : Î¹ â†’ Type u_6\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (Em i)\ninstâœÂ¹ : (i : Î¹) â†’ NormedSpace ğ•œ (Em i)\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ Em F\nx : (i : Î¹) â†’ Em i\nâŠ¢ AnalyticAt ğ•œ (â‡‘f) x","decl":"lemma analyticAt : AnalyticAt ğ•œ f x := f.cpolynomialAt.analyticAt\n\n"}
{"name":"ContinuousMultilinearMap.analyticWithinAt","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace ğ•œ F\nÎ¹ : Type u_5\nEm : Î¹ â†’ Type u_6\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (Em i)\ninstâœÂ¹ : (i : Î¹) â†’ NormedSpace ğ•œ (Em i)\ninstâœ : Fintype Î¹\nf : ContinuousMultilinearMap ğ•œ Em F\nx : (i : Î¹) â†’ Em i\ns : Set ((i : Î¹) â†’ Em i)\nâŠ¢ AnalyticWithinAt ğ•œ (â‡‘f) s x","decl":"lemma analyticWithinAt : AnalyticWithinAt ğ•œ f s x := f.analyticAt.analyticWithinAt\n\n"}
{"name":"ContinuousLinearMap.hasFiniteFPowerSeriesOnBall_uncurry_of_multilinear","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\nG : Type u_4\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NormedSpace ğ•œ F\ninstâœâ´ : NormedAddCommGroup G\ninstâœÂ³ : NormedSpace ğ•œ G\nÎ¹ : Type u_5\nEm : Î¹ â†’ Type u_6\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (Em i)\ninstâœÂ¹ : (i : Î¹) â†’ NormedSpace ğ•œ (Em i)\ninstâœ : Fintype Î¹\nf : ContinuousLinearMap (RingHom.id ğ•œ) G (ContinuousMultilinearMap ğ•œ Em F)\nâŠ¢ HasFiniteFPowerSeriesOnBall (fun p => (f p.1) p.2) f.toFormalMultilinearSeriesOfMultilinear 0 (HAdd.hAdd (Fintype.card (Option Î¹)) 1) Top.top","decl":"protected theorem hasFiniteFPowerSeriesOnBall_uncurry_of_multilinear :\n    HasFiniteFPowerSeriesOnBall (fun (p : G Ã— (Î  i, Em i)) â†¦ f p.1 p.2)\n      f.toFormalMultilinearSeriesOfMultilinear 0 (Fintype.card (Option Î¹) + 1) âŠ¤ := by\n  apply HasFiniteFPowerSeriesOnBall.mk' ?_ ENNReal.zero_lt_top  ?_\n  Â· intro m hm\n    apply dif_neg\n    exact Nat.ne_of_lt hm\n  Â· intro y _\n    rw [Finset.sum_eq_single_of_mem _ (Finset.self_mem_range_succ _), zero_add]\n    Â· rw [toFormalMultilinearSeriesOfMultilinear, dif_pos rfl]; rfl\n    Â· intro m _ ne; rw [toFormalMultilinearSeriesOfMultilinear, dif_neg ne.symm]; rfl\n\n"}
{"name":"ContinuousLinearMap.cpolynomialAt_uncurry_of_multilinear","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\nG : Type u_4\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NormedSpace ğ•œ F\ninstâœâ´ : NormedAddCommGroup G\ninstâœÂ³ : NormedSpace ğ•œ G\nÎ¹ : Type u_5\nEm : Î¹ â†’ Type u_6\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (Em i)\ninstâœÂ¹ : (i : Î¹) â†’ NormedSpace ğ•œ (Em i)\ninstâœ : Fintype Î¹\nf : ContinuousLinearMap (RingHom.id ğ•œ) G (ContinuousMultilinearMap ğ•œ Em F)\nx : Prod G ((i : Î¹) â†’ Em i)\nâŠ¢ CPolynomialAt ğ•œ (fun p => (f p.1) p.2) x","decl":"lemma cpolynomialAt_uncurry_of_multilinear :\n    CPolynomialAt ğ•œ (fun (p : G Ã— (Î  i, Em i)) â†¦ f p.1 p.2) x :=\n  f.hasFiniteFPowerSeriesOnBall_uncurry_of_multilinear.cPolynomialAt_of_mem\n    (by simp only [Metric.emetric_ball_top, Set.mem_univ])\n\n"}
{"name":"ContinuousLinearMap.cpolyomialOn_uncurry_of_multilinear","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\nG : Type u_4\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NormedSpace ğ•œ F\ninstâœâ´ : NormedAddCommGroup G\ninstâœÂ³ : NormedSpace ğ•œ G\nÎ¹ : Type u_5\nEm : Î¹ â†’ Type u_6\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (Em i)\ninstâœÂ¹ : (i : Î¹) â†’ NormedSpace ğ•œ (Em i)\ninstâœ : Fintype Î¹\nf : ContinuousLinearMap (RingHom.id ğ•œ) G (ContinuousMultilinearMap ğ•œ Em F)\ns : Set (Prod G ((i : Î¹) â†’ Em i))\nâŠ¢ CPolynomialOn ğ•œ (fun p => (f p.1) p.2) s","decl":"lemma cpolyomialOn_uncurry_of_multilinear :\n    CPolynomialOn ğ•œ (fun (p : G Ã— (Î  i, Em i)) â†¦ f p.1 p.2) s :=\n  fun _ _ â†¦ f.cpolynomialAt_uncurry_of_multilinear\n\n"}
{"name":"ContinuousLinearMap.analyticOnNhd_uncurry_of_multilinear","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\nG : Type u_4\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NormedSpace ğ•œ F\ninstâœâ´ : NormedAddCommGroup G\ninstâœÂ³ : NormedSpace ğ•œ G\nÎ¹ : Type u_5\nEm : Î¹ â†’ Type u_6\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (Em i)\ninstâœÂ¹ : (i : Î¹) â†’ NormedSpace ğ•œ (Em i)\ninstâœ : Fintype Î¹\nf : ContinuousLinearMap (RingHom.id ğ•œ) G (ContinuousMultilinearMap ğ•œ Em F)\ns : Set (Prod G ((i : Î¹) â†’ Em i))\nâŠ¢ AnalyticOnNhd ğ•œ (fun p => (f p.1) p.2) s","decl":"lemma analyticOnNhd_uncurry_of_multilinear :\n    AnalyticOnNhd ğ•œ (fun (p : G Ã— (Î  i, Em i)) â†¦ f p.1 p.2) s :=\n  f.cpolyomialOn_uncurry_of_multilinear.analyticOnNhd\n\n"}
{"name":"ContinuousLinearMap.analyticOn_uncurry_of_multilinear","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\nG : Type u_4\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NormedSpace ğ•œ F\ninstâœâ´ : NormedAddCommGroup G\ninstâœÂ³ : NormedSpace ğ•œ G\nÎ¹ : Type u_5\nEm : Î¹ â†’ Type u_6\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (Em i)\ninstâœÂ¹ : (i : Î¹) â†’ NormedSpace ğ•œ (Em i)\ninstâœ : Fintype Î¹\nf : ContinuousLinearMap (RingHom.id ğ•œ) G (ContinuousMultilinearMap ğ•œ Em F)\ns : Set (Prod G ((i : Î¹) â†’ Em i))\nâŠ¢ AnalyticOn ğ•œ (fun p => (f p.1) p.2) s","decl":"lemma analyticOn_uncurry_of_multilinear :\n    AnalyticOn ğ•œ (fun (p : G Ã— (Î  i, Em i)) â†¦ f p.1 p.2) s :=\n  f.analyticOnNhd_uncurry_of_multilinear.analyticOn\n\n"}
{"name":"ContinuousLinearMap.analyticWithinOn_uncurry_of_multilinear","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\nG : Type u_4\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NormedSpace ğ•œ F\ninstâœâ´ : NormedAddCommGroup G\ninstâœÂ³ : NormedSpace ğ•œ G\nÎ¹ : Type u_5\nEm : Î¹ â†’ Type u_6\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (Em i)\ninstâœÂ¹ : (i : Î¹) â†’ NormedSpace ğ•œ (Em i)\ninstâœ : Fintype Î¹\nf : ContinuousLinearMap (RingHom.id ğ•œ) G (ContinuousMultilinearMap ğ•œ Em F)\ns : Set (Prod G ((i : Î¹) â†’ Em i))\nâŠ¢ AnalyticOn ğ•œ (fun p => (f p.1) p.2) s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias analyticWithinOn_uncurry_of_multilinear := analyticOn_uncurry_of_multilinear\n\n"}
{"name":"ContinuousLinearMap.analyticAt_uncurry_of_multilinear","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\nG : Type u_4\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NormedSpace ğ•œ F\ninstâœâ´ : NormedAddCommGroup G\ninstâœÂ³ : NormedSpace ğ•œ G\nÎ¹ : Type u_5\nEm : Î¹ â†’ Type u_6\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (Em i)\ninstâœÂ¹ : (i : Î¹) â†’ NormedSpace ğ•œ (Em i)\ninstâœ : Fintype Î¹\nf : ContinuousLinearMap (RingHom.id ğ•œ) G (ContinuousMultilinearMap ğ•œ Em F)\nx : Prod G ((i : Î¹) â†’ Em i)\nâŠ¢ AnalyticAt ğ•œ (fun p => (f p.1) p.2) x","decl":"lemma analyticAt_uncurry_of_multilinear : AnalyticAt ğ•œ (fun (p : G Ã— (Î  i, Em i)) â†¦ f p.1 p.2) x :=\n  f.cpolynomialAt_uncurry_of_multilinear.analyticAt\n\n"}
{"name":"ContinuousLinearMap.analyticWithinAt_uncurry_of_multilinear","module":"Mathlib.Analysis.Analytic.CPolynomial","initialProofState":"ğ•œ : Type u_1\nF : Type u_3\nG : Type u_4\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NormedSpace ğ•œ F\ninstâœâ´ : NormedAddCommGroup G\ninstâœÂ³ : NormedSpace ğ•œ G\nÎ¹ : Type u_5\nEm : Î¹ â†’ Type u_6\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (Em i)\ninstâœÂ¹ : (i : Î¹) â†’ NormedSpace ğ•œ (Em i)\ninstâœ : Fintype Î¹\nf : ContinuousLinearMap (RingHom.id ğ•œ) G (ContinuousMultilinearMap ğ•œ Em F)\ns : Set (Prod G ((i : Î¹) â†’ Em i))\nx : Prod G ((i : Î¹) â†’ Em i)\nâŠ¢ AnalyticWithinAt ğ•œ (fun p => (f p.1) p.2) s x","decl":"lemma analyticWithinAt_uncurry_of_multilinear :\n    AnalyticWithinAt ğ•œ (fun (p : G Ã— (Î  i, Em i)) â†¦ f p.1 p.2) s x :=\n  f.analyticAt_uncurry_of_multilinear.analyticWithinAt\n\n"}
