{"name":"Finset.univ_fin2","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"⊢ Eq Finset.univ (Insert.insert 0 (Singleton.singleton 1))","decl":"theorem univ_fin2 : (univ : Finset (Fin 2)) = {0, 1} := by\n  ext x\n  fin_cases x <;> simp\n\n"}
{"name":"Finset.weightedVSubOfPoint_apply","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw : ι → k\np : ι → P\nb : P\n⊢ Eq ((s.weightedVSubOfPoint p b) w) (s.sum fun i => HSMul.hSMul (w i) (VSub.vsub (p i) b))","decl":"@[simp]\ntheorem weightedVSubOfPoint_apply (w : ι → k) (p : ι → P) (b : P) :\n    s.weightedVSubOfPoint p b w = ∑ i ∈ s, w i • (p i -ᵥ b) := by\n  simp [weightedVSubOfPoint, LinearMap.sum_apply]\n\n"}
{"name":"Finset.weightedVSubOfPoint_apply_const","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw : ι → k\np b : P\n⊢ Eq ((s.weightedVSubOfPoint (fun x => p) b) w) (HSMul.hSMul (s.sum fun i => w i) (VSub.vsub p b))","decl":"/-- The value of `weightedVSubOfPoint`, where the given points are equal. -/\n@[simp (high)]\ntheorem weightedVSubOfPoint_apply_const (w : ι → k) (p : P) (b : P) :\n    s.weightedVSubOfPoint (fun _ => p) b w = (∑ i ∈ s, w i) • (p -ᵥ b) := by\n  rw [weightedVSubOfPoint_apply, sum_smul]\n\n"}
{"name":"Finset.weightedVSubOfPoint_vadd","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw : ι → k\np : ι → P\nb : P\nv : V\n⊢ Eq ((s.weightedVSubOfPoint (HVAdd.hVAdd v p) b) w) ((s.weightedVSubOfPoint p (HVAdd.hVAdd (Neg.neg v) b)) w)","decl":"lemma weightedVSubOfPoint_vadd (s : Finset ι) (w : ι → k) (p : ι → P) (b : P) (v : V) :\n    s.weightedVSubOfPoint (v +ᵥ p) b w = s.weightedVSubOfPoint p (-v +ᵥ b) w := by\n  simp [vadd_vsub_assoc, vsub_vadd_eq_vsub_sub, add_comm]\n\n"}
{"name":"Finset.weightedVSubOfPoint_smul","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\ninst✝⁵ : Ring k\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module k V\nι : Type u_4\nG : Type u_6\ninst✝² : Group G\ninst✝¹ : DistribMulAction G V\ninst✝ : SMulCommClass G k V\ns : Finset ι\nw : ι → k\np : ι → V\nb : V\na : G\n⊢ Eq ((s.weightedVSubOfPoint (HSMul.hSMul a p) b) w) (HSMul.hSMul a ((s.weightedVSubOfPoint p (HSMul.hSMul (Inv.inv a) b)) w))","decl":"lemma weightedVSubOfPoint_smul {G : Type*} [Group G] [DistribMulAction G V] [SMulCommClass G k V]\n    (s : Finset ι) (w : ι → k) (p : ι → V) (b : V) (a : G) :\n    s.weightedVSubOfPoint (a • p) b w = a • s.weightedVSubOfPoint p (a⁻¹ • b) w := by\n  simp [smul_sum, smul_sub, smul_comm a (w _)]\n\n"}
{"name":"Finset.weightedVSubOfPoint_congr","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw₁ w₂ : ι → k\nhw : ∀ (i : ι), Membership.mem s i → Eq (w₁ i) (w₂ i)\np₁ p₂ : ι → P\nhp : ∀ (i : ι), Membership.mem s i → Eq (p₁ i) (p₂ i)\nb : P\n⊢ Eq ((s.weightedVSubOfPoint p₁ b) w₁) ((s.weightedVSubOfPoint p₂ b) w₂)","decl":"/-- `weightedVSubOfPoint` gives equal results for two families of weights and two families of\npoints that are equal on `s`. -/\ntheorem weightedVSubOfPoint_congr {w₁ w₂ : ι → k} (hw : ∀ i ∈ s, w₁ i = w₂ i) {p₁ p₂ : ι → P}\n    (hp : ∀ i ∈ s, p₁ i = p₂ i) (b : P) :\n    s.weightedVSubOfPoint p₁ b w₁ = s.weightedVSubOfPoint p₂ b w₂ := by\n  simp_rw [weightedVSubOfPoint_apply]\n  refine sum_congr rfl fun i hi => ?_\n  rw [hw i hi, hp i hi]\n\n"}
{"name":"Finset.weightedVSubOfPoint_eq_of_weights_eq","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\np : ι → P\nj : ι\nw₁ w₂ : ι → k\nhw : ∀ (i : ι), Ne i j → Eq (w₁ i) (w₂ i)\n⊢ Eq ((s.weightedVSubOfPoint p (p j)) w₁) ((s.weightedVSubOfPoint p (p j)) w₂)","decl":"/-- Given a family of points, if we use a member of the family as a base point, the\n`weightedVSubOfPoint` does not depend on the value of the weights at this point. -/\ntheorem weightedVSubOfPoint_eq_of_weights_eq (p : ι → P) (j : ι) (w₁ w₂ : ι → k)\n    (hw : ∀ i, i ≠ j → w₁ i = w₂ i) :\n    s.weightedVSubOfPoint p (p j) w₁ = s.weightedVSubOfPoint p (p j) w₂ := by\n  simp only [Finset.weightedVSubOfPoint_apply]\n  congr\n  ext i\n  rcases eq_or_ne i j with h | h\n  · simp [h]\n  · simp [hw i h]\n\n"}
{"name":"Finset.weightedVSubOfPoint_eq_of_sum_eq_zero","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw : ι → k\np : ι → P\nh : Eq (s.sum fun i => w i) 0\nb₁ b₂ : P\n⊢ Eq ((s.weightedVSubOfPoint p b₁) w) ((s.weightedVSubOfPoint p b₂) w)","decl":"/-- The weighted sum is independent of the base point when the sum of\nthe weights is 0. -/\ntheorem weightedVSubOfPoint_eq_of_sum_eq_zero (w : ι → k) (p : ι → P) (h : ∑ i ∈ s, w i = 0)\n    (b₁ b₂ : P) : s.weightedVSubOfPoint p b₁ w = s.weightedVSubOfPoint p b₂ w := by\n  apply eq_of_sub_eq_zero\n  rw [weightedVSubOfPoint_apply, weightedVSubOfPoint_apply, ← sum_sub_distrib]\n  conv_lhs =>\n    congr\n    · skip\n    · ext\n      rw [← smul_sub, vsub_sub_vsub_cancel_left]\n  rw [← sum_smul, h, zero_smul]\n\n"}
{"name":"Finset.weightedVSubOfPoint_vadd_eq_of_sum_eq_one","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw : ι → k\np : ι → P\nh : Eq (s.sum fun i => w i) 1\nb₁ b₂ : P\n⊢ Eq (HVAdd.hVAdd ((s.weightedVSubOfPoint p b₁) w) b₁) (HVAdd.hVAdd ((s.weightedVSubOfPoint p b₂) w) b₂)","decl":"/-- The weighted sum, added to the base point, is independent of the\nbase point when the sum of the weights is 1. -/\ntheorem weightedVSubOfPoint_vadd_eq_of_sum_eq_one (w : ι → k) (p : ι → P) (h : ∑ i ∈ s, w i = 1)\n    (b₁ b₂ : P) : s.weightedVSubOfPoint p b₁ w +ᵥ b₁ = s.weightedVSubOfPoint p b₂ w +ᵥ b₂ := by\n  rw [weightedVSubOfPoint_apply, weightedVSubOfPoint_apply, ← @vsub_eq_zero_iff_eq V,\n    vadd_vsub_assoc, vsub_vadd_eq_vsub_sub, ← add_sub_assoc, add_comm, add_sub_assoc, ←\n    sum_sub_distrib]\n  conv_lhs =>\n    congr\n    · skip\n    · congr\n      · skip\n      · ext\n        rw [← smul_sub, vsub_sub_vsub_cancel_left]\n  rw [← sum_smul, h, one_smul, vsub_add_vsub_cancel, vsub_self]\n\n"}
{"name":"Finset.weightedVSubOfPoint_erase","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\ninst✝ : DecidableEq ι\nw : ι → k\np : ι → P\ni : ι\n⊢ Eq (((s.erase i).weightedVSubOfPoint p (p i)) w) ((s.weightedVSubOfPoint p (p i)) w)","decl":"/-- The weighted sum is unaffected by removing the base point, if\npresent, from the set of points. -/\n@[simp (high)]\ntheorem weightedVSubOfPoint_erase [DecidableEq ι] (w : ι → k) (p : ι → P) (i : ι) :\n    (s.erase i).weightedVSubOfPoint p (p i) w = s.weightedVSubOfPoint p (p i) w := by\n  rw [weightedVSubOfPoint_apply, weightedVSubOfPoint_apply]\n  apply sum_erase\n  rw [vsub_self, smul_zero]\n\n"}
{"name":"Finset.weightedVSubOfPoint_insert","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\ninst✝ : DecidableEq ι\nw : ι → k\np : ι → P\ni : ι\n⊢ Eq (((Insert.insert i s).weightedVSubOfPoint p (p i)) w) ((s.weightedVSubOfPoint p (p i)) w)","decl":"/-- The weighted sum is unaffected by adding the base point, whether\nor not present, to the set of points. -/\n@[simp (high)]\ntheorem weightedVSubOfPoint_insert [DecidableEq ι] (w : ι → k) (p : ι → P) (i : ι) :\n    (insert i s).weightedVSubOfPoint p (p i) w = s.weightedVSubOfPoint p (p i) w := by\n  rw [weightedVSubOfPoint_apply, weightedVSubOfPoint_apply]\n  apply sum_insert_zero\n  rw [vsub_self, smul_zero]\n\n"}
{"name":"Finset.weightedVSubOfPoint_indicator_subset","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\nw : ι → k\np : ι → P\nb : P\ns₁ s₂ : Finset ι\nh : HasSubset.Subset s₁ s₂\n⊢ Eq ((s₁.weightedVSubOfPoint p b) w) ((s₂.weightedVSubOfPoint p b) ((↑s₁).indicator w))","decl":"/-- The weighted sum is unaffected by changing the weights to the\ncorresponding indicator function and adding points to the set. -/\ntheorem weightedVSubOfPoint_indicator_subset (w : ι → k) (p : ι → P) (b : P) {s₁ s₂ : Finset ι}\n    (h : s₁ ⊆ s₂) :\n    s₁.weightedVSubOfPoint p b w = s₂.weightedVSubOfPoint p b (Set.indicator (↑s₁) w) := by\n  rw [weightedVSubOfPoint_apply, weightedVSubOfPoint_apply]\n  exact Eq.symm <|\n    sum_indicator_subset_of_eq_zero w (fun i wi => wi • (p i -ᵥ b : V)) h fun i => zero_smul k _\n\n"}
{"name":"Finset.weightedVSubOfPoint_map","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\nι₂ : Type u_5\ns₂ : Finset ι₂\ne : Function.Embedding ι₂ ι\nw : ι → k\np : ι → P\nb : P\n⊢ Eq (((Finset.map e s₂).weightedVSubOfPoint p b) w) ((s₂.weightedVSubOfPoint (Function.comp p ⇑e) b) (Function.comp w ⇑e))","decl":"/-- A weighted sum, over the image of an embedding, equals a weighted\nsum with the same points and weights over the original\n`Finset`. -/\ntheorem weightedVSubOfPoint_map (e : ι₂ ↪ ι) (w : ι → k) (p : ι → P) (b : P) :\n    (s₂.map e).weightedVSubOfPoint p b w = s₂.weightedVSubOfPoint (p ∘ e) b (w ∘ e) := by\n  simp_rw [weightedVSubOfPoint_apply]\n  exact Finset.sum_map _ _ _\n\n"}
{"name":"Finset.sum_smul_vsub_eq_weightedVSubOfPoint_sub","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw : ι → k\np₁ p₂ : ι → P\nb : P\n⊢ Eq (s.sum fun i => HSMul.hSMul (w i) (VSub.vsub (p₁ i) (p₂ i))) (HSub.hSub ((s.weightedVSubOfPoint p₁ b) w) ((s.weightedVSubOfPoint p₂ b) w))","decl":"/-- A weighted sum of pairwise subtractions, expressed as a subtraction of two\n`weightedVSubOfPoint` expressions. -/\ntheorem sum_smul_vsub_eq_weightedVSubOfPoint_sub (w : ι → k) (p₁ p₂ : ι → P) (b : P) :\n    (∑ i ∈ s, w i • (p₁ i -ᵥ p₂ i)) =\n      s.weightedVSubOfPoint p₁ b w - s.weightedVSubOfPoint p₂ b w := by\n  simp_rw [weightedVSubOfPoint_apply, ← sum_sub_distrib, ← smul_sub, vsub_sub_vsub_cancel_right]\n\n"}
{"name":"Finset.sum_smul_vsub_const_eq_weightedVSubOfPoint_sub","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw : ι → k\np₁ : ι → P\np₂ b : P\n⊢ Eq (s.sum fun i => HSMul.hSMul (w i) (VSub.vsub (p₁ i) p₂)) (HSub.hSub ((s.weightedVSubOfPoint p₁ b) w) (HSMul.hSMul (s.sum fun i => w i) (VSub.vsub p₂ b)))","decl":"/-- A weighted sum of pairwise subtractions, where the point on the right is constant,\nexpressed as a subtraction involving a `weightedVSubOfPoint` expression. -/\ntheorem sum_smul_vsub_const_eq_weightedVSubOfPoint_sub (w : ι → k) (p₁ : ι → P) (p₂ b : P) :\n    (∑ i ∈ s, w i • (p₁ i -ᵥ p₂)) = s.weightedVSubOfPoint p₁ b w - (∑ i ∈ s, w i) • (p₂ -ᵥ b) := by\n  rw [sum_smul_vsub_eq_weightedVSubOfPoint_sub, weightedVSubOfPoint_apply_const]\n\n"}
{"name":"Finset.sum_smul_const_vsub_eq_sub_weightedVSubOfPoint","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw : ι → k\np₂ : ι → P\np₁ b : P\n⊢ Eq (s.sum fun i => HSMul.hSMul (w i) (VSub.vsub p₁ (p₂ i))) (HSub.hSub (HSMul.hSMul (s.sum fun i => w i) (VSub.vsub p₁ b)) ((s.weightedVSubOfPoint p₂ b) w))","decl":"/-- A weighted sum of pairwise subtractions, where the point on the left is constant,\nexpressed as a subtraction involving a `weightedVSubOfPoint` expression. -/\ntheorem sum_smul_const_vsub_eq_sub_weightedVSubOfPoint (w : ι → k) (p₂ : ι → P) (p₁ b : P) :\n    (∑ i ∈ s, w i • (p₁ -ᵥ p₂ i)) = (∑ i ∈ s, w i) • (p₁ -ᵥ b) - s.weightedVSubOfPoint p₂ b w := by\n  rw [sum_smul_vsub_eq_weightedVSubOfPoint_sub, weightedVSubOfPoint_apply_const]\n\n"}
{"name":"Finset.weightedVSubOfPoint_sdiff","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\ninst✝ : DecidableEq ι\ns₂ : Finset ι\nh : HasSubset.Subset s₂ s\nw : ι → k\np : ι → P\nb : P\n⊢ Eq (HAdd.hAdd (((SDiff.sdiff s s₂).weightedVSubOfPoint p b) w) ((s₂.weightedVSubOfPoint p b) w)) ((s.weightedVSubOfPoint p b) w)","decl":"/-- A weighted sum may be split into such sums over two subsets. -/\ntheorem weightedVSubOfPoint_sdiff [DecidableEq ι] {s₂ : Finset ι} (h : s₂ ⊆ s) (w : ι → k)\n    (p : ι → P) (b : P) :\n    (s \\ s₂).weightedVSubOfPoint p b w + s₂.weightedVSubOfPoint p b w =\n      s.weightedVSubOfPoint p b w := by\n  simp_rw [weightedVSubOfPoint_apply, sum_sdiff h]\n\n"}
{"name":"Finset.weightedVSubOfPoint_sdiff_sub","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\ninst✝ : DecidableEq ι\ns₂ : Finset ι\nh : HasSubset.Subset s₂ s\nw : ι → k\np : ι → P\nb : P\n⊢ Eq (HSub.hSub (((SDiff.sdiff s s₂).weightedVSubOfPoint p b) w) ((s₂.weightedVSubOfPoint p b) (Neg.neg w))) ((s.weightedVSubOfPoint p b) w)","decl":"/-- A weighted sum may be split into a subtraction of such sums over two subsets. -/\ntheorem weightedVSubOfPoint_sdiff_sub [DecidableEq ι] {s₂ : Finset ι} (h : s₂ ⊆ s) (w : ι → k)\n    (p : ι → P) (b : P) :\n    (s \\ s₂).weightedVSubOfPoint p b w - s₂.weightedVSubOfPoint p b (-w) =\n      s.weightedVSubOfPoint p b w := by\n  rw [map_neg, sub_neg_eq_add, s.weightedVSubOfPoint_sdiff h]\n\n"}
{"name":"Finset.weightedVSubOfPoint_subtype_eq_filter","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw : ι → k\np : ι → P\nb : P\npred : ι → Prop\ninst✝ : DecidablePred pred\n⊢ Eq (((Finset.subtype pred s).weightedVSubOfPoint (fun i => p ↑i) b) fun i => w ↑i) (((Finset.filter (fun x => pred x) s).weightedVSubOfPoint p b) w)","decl":"/-- A weighted sum over `s.subtype pred` equals one over `{x ∈ s | pred x}`. -/\ntheorem weightedVSubOfPoint_subtype_eq_filter (w : ι → k) (p : ι → P) (b : P) (pred : ι → Prop)\n    [DecidablePred pred] :\n    ((s.subtype pred).weightedVSubOfPoint (fun i => p i) b fun i => w i) =\n      {x ∈ s | pred x}.weightedVSubOfPoint p b w := by\n  rw [weightedVSubOfPoint_apply, weightedVSubOfPoint_apply, ← sum_subtype_eq_sum_filter]\n\n"}
{"name":"Finset.weightedVSubOfPoint_filter_of_ne","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw : ι → k\np : ι → P\nb : P\npred : ι → Prop\ninst✝ : DecidablePred pred\nh : ∀ (i : ι), Membership.mem s i → Ne (w i) 0 → pred i\n⊢ Eq (((Finset.filter (fun x => pred x) s).weightedVSubOfPoint p b) w) ((s.weightedVSubOfPoint p b) w)","decl":"/-- A weighted sum over `{x ∈ s | pred x}` equals one over `s` if all the weights at indices in `s`\nnot satisfying `pred` are zero. -/\ntheorem weightedVSubOfPoint_filter_of_ne (w : ι → k) (p : ι → P) (b : P) {pred : ι → Prop}\n    [DecidablePred pred] (h : ∀ i ∈ s, w i ≠ 0 → pred i) :\n    {x ∈ s | pred x}.weightedVSubOfPoint p b w = s.weightedVSubOfPoint p b w := by\n  rw [weightedVSubOfPoint_apply, weightedVSubOfPoint_apply, sum_filter_of_ne]\n  intro i hi hne\n  refine h i hi ?_\n  intro hw\n  simp [hw] at hne\n\n"}
{"name":"Finset.weightedVSubOfPoint_const_smul","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw : ι → k\np : ι → P\nb : P\nc : k\n⊢ Eq ((s.weightedVSubOfPoint p b) (HSMul.hSMul c w)) (HSMul.hSMul c ((s.weightedVSubOfPoint p b) w))","decl":"/-- A constant multiplier of the weights in `weightedVSubOfPoint` may be moved outside the\nsum. -/\ntheorem weightedVSubOfPoint_const_smul (w : ι → k) (p : ι → P) (b : P) (c : k) :\n    s.weightedVSubOfPoint p b (c • w) = c • s.weightedVSubOfPoint p b w := by\n  simp_rw [weightedVSubOfPoint_apply, smul_sum, Pi.smul_apply, smul_smul, smul_eq_mul]\n\n"}
{"name":"Finset.weightedVSub_apply","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw : ι → k\np : ι → P\n⊢ Eq ((s.weightedVSub p) w) (s.sum fun i => HSMul.hSMul (w i) (VSub.vsub (p i) (Classical.choice ⋯)))","decl":"/-- Applying `weightedVSub` with given weights.  This is for the case\nwhere a result involving a default base point is OK (for example, when\nthat base point will cancel out later); a more typical use case for\n`weightedVSub` would involve selecting a preferred base point with\n`weightedVSub_eq_weightedVSubOfPoint_of_sum_eq_zero` and then\nusing `weightedVSubOfPoint_apply`. -/\ntheorem weightedVSub_apply (w : ι → k) (p : ι → P) :\n    s.weightedVSub p w = ∑ i ∈ s, w i • (p i -ᵥ Classical.choice S.nonempty) := by\n  simp [weightedVSub, LinearMap.sum_apply]\n\n"}
{"name":"Finset.weightedVSub_eq_weightedVSubOfPoint_of_sum_eq_zero","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw : ι → k\np : ι → P\nh : Eq (s.sum fun i => w i) 0\nb : P\n⊢ Eq ((s.weightedVSub p) w) ((s.weightedVSubOfPoint p b) w)","decl":"/-- `weightedVSub` gives the sum of the results of subtracting any\nbase point, when the sum of the weights is 0. -/\ntheorem weightedVSub_eq_weightedVSubOfPoint_of_sum_eq_zero (w : ι → k) (p : ι → P)\n    (h : ∑ i ∈ s, w i = 0) (b : P) : s.weightedVSub p w = s.weightedVSubOfPoint p b w :=\n  s.weightedVSubOfPoint_eq_of_sum_eq_zero w p h _ _\n\n"}
{"name":"Finset.weightedVSub_apply_const","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw : ι → k\np : P\nh : Eq (s.sum fun i => w i) 0\n⊢ Eq ((s.weightedVSub fun x => p) w) 0","decl":"/-- The value of `weightedVSub`, where the given points are equal and the sum of the weights\nis 0. -/\n@[simp]\ntheorem weightedVSub_apply_const (w : ι → k) (p : P) (h : ∑ i ∈ s, w i = 0) :\n    s.weightedVSub (fun _ => p) w = 0 := by\n  rw [weightedVSub, weightedVSubOfPoint_apply_const, h, zero_smul]\n\n"}
{"name":"Finset.weightedVSub_empty","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\nw : ι → k\np : ι → P\n⊢ Eq ((EmptyCollection.emptyCollection.weightedVSub p) w) 0","decl":"/-- The `weightedVSub` for an empty set is 0. -/\n@[simp]\ntheorem weightedVSub_empty (w : ι → k) (p : ι → P) : (∅ : Finset ι).weightedVSub p w = (0 : V) := by\n  simp [weightedVSub_apply]\n\n"}
{"name":"Finset.weightedVSub_vadd","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw : ι → k\nh : Eq (s.sum fun i => w i) 0\np : ι → P\nv : V\n⊢ Eq ((s.weightedVSub (HVAdd.hVAdd v p)) w) ((s.weightedVSub p) w)","decl":"lemma weightedVSub_vadd {s : Finset ι} {w : ι → k} (h : ∑ i ∈ s, w i = 0) (p : ι → P) (v : V) :\n    s.weightedVSub (v +ᵥ p) w = s.weightedVSub p w := by\n  rw [weightedVSub, weightedVSubOfPoint_vadd,\n    weightedVSub_eq_weightedVSubOfPoint_of_sum_eq_zero _ _ _ h]\n\n"}
{"name":"Finset.weightedVSub_smul","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\ninst✝⁵ : Ring k\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module k V\nι : Type u_4\nG : Type u_6\ninst✝² : Group G\ninst✝¹ : DistribMulAction G V\ninst✝ : SMulCommClass G k V\ns : Finset ι\nw : ι → k\nh : Eq (s.sum fun i => w i) 0\np : ι → V\na : G\n⊢ Eq ((s.weightedVSub (HSMul.hSMul a p)) w) (HSMul.hSMul a ((s.weightedVSub p) w))","decl":"lemma weightedVSub_smul {G : Type*} [Group G] [DistribMulAction G V] [SMulCommClass G k V]\n    {s : Finset ι} {w : ι → k} (h : ∑ i ∈ s, w i = 0) (p : ι → V) (a : G) :\n    s.weightedVSub (a • p) w = a • s.weightedVSub p w := by\n  rw [weightedVSub, weightedVSubOfPoint_smul,\n    weightedVSub_eq_weightedVSubOfPoint_of_sum_eq_zero _ _ _ h]\n\n"}
{"name":"Finset.weightedVSub_congr","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw₁ w₂ : ι → k\nhw : ∀ (i : ι), Membership.mem s i → Eq (w₁ i) (w₂ i)\np₁ p₂ : ι → P\nhp : ∀ (i : ι), Membership.mem s i → Eq (p₁ i) (p₂ i)\n⊢ Eq ((s.weightedVSub p₁) w₁) ((s.weightedVSub p₂) w₂)","decl":"/-- `weightedVSub` gives equal results for two families of weights and two families of points\nthat are equal on `s`. -/\ntheorem weightedVSub_congr {w₁ w₂ : ι → k} (hw : ∀ i ∈ s, w₁ i = w₂ i) {p₁ p₂ : ι → P}\n    (hp : ∀ i ∈ s, p₁ i = p₂ i) : s.weightedVSub p₁ w₁ = s.weightedVSub p₂ w₂ :=\n  s.weightedVSubOfPoint_congr hw hp _\n\n"}
{"name":"Finset.weightedVSub_indicator_subset","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\nw : ι → k\np : ι → P\ns₁ s₂ : Finset ι\nh : HasSubset.Subset s₁ s₂\n⊢ Eq ((s₁.weightedVSub p) w) ((s₂.weightedVSub p) ((↑s₁).indicator w))","decl":"/-- The weighted sum is unaffected by changing the weights to the\ncorresponding indicator function and adding points to the set. -/\ntheorem weightedVSub_indicator_subset (w : ι → k) (p : ι → P) {s₁ s₂ : Finset ι} (h : s₁ ⊆ s₂) :\n    s₁.weightedVSub p w = s₂.weightedVSub p (Set.indicator (↑s₁) w) :=\n  weightedVSubOfPoint_indicator_subset _ _ _ h\n\n"}
{"name":"Finset.weightedVSub_map","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\nι₂ : Type u_5\ns₂ : Finset ι₂\ne : Function.Embedding ι₂ ι\nw : ι → k\np : ι → P\n⊢ Eq (((Finset.map e s₂).weightedVSub p) w) ((s₂.weightedVSub (Function.comp p ⇑e)) (Function.comp w ⇑e))","decl":"/-- A weighted subtraction, over the image of an embedding, equals a\nweighted subtraction with the same points and weights over the\noriginal `Finset`. -/\ntheorem weightedVSub_map (e : ι₂ ↪ ι) (w : ι → k) (p : ι → P) :\n    (s₂.map e).weightedVSub p w = s₂.weightedVSub (p ∘ e) (w ∘ e) :=\n  s₂.weightedVSubOfPoint_map _ _ _ _\n\n"}
{"name":"Finset.sum_smul_vsub_eq_weightedVSub_sub","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw : ι → k\np₁ p₂ : ι → P\n⊢ Eq (s.sum fun i => HSMul.hSMul (w i) (VSub.vsub (p₁ i) (p₂ i))) (HSub.hSub ((s.weightedVSub p₁) w) ((s.weightedVSub p₂) w))","decl":"/-- A weighted sum of pairwise subtractions, expressed as a subtraction of two `weightedVSub`\nexpressions. -/\ntheorem sum_smul_vsub_eq_weightedVSub_sub (w : ι → k) (p₁ p₂ : ι → P) :\n    (∑ i ∈ s, w i • (p₁ i -ᵥ p₂ i)) = s.weightedVSub p₁ w - s.weightedVSub p₂ w :=\n  s.sum_smul_vsub_eq_weightedVSubOfPoint_sub _ _ _ _\n\n"}
{"name":"Finset.sum_smul_vsub_const_eq_weightedVSub","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw : ι → k\np₁ : ι → P\np₂ : P\nh : Eq (s.sum fun i => w i) 0\n⊢ Eq (s.sum fun i => HSMul.hSMul (w i) (VSub.vsub (p₁ i) p₂)) ((s.weightedVSub p₁) w)","decl":"/-- A weighted sum of pairwise subtractions, where the point on the right is constant and the\nsum of the weights is 0. -/\ntheorem sum_smul_vsub_const_eq_weightedVSub (w : ι → k) (p₁ : ι → P) (p₂ : P)\n    (h : ∑ i ∈ s, w i = 0) : (∑ i ∈ s, w i • (p₁ i -ᵥ p₂)) = s.weightedVSub p₁ w := by\n  rw [sum_smul_vsub_eq_weightedVSub_sub, s.weightedVSub_apply_const _ _ h, sub_zero]\n\n"}
{"name":"Finset.sum_smul_const_vsub_eq_neg_weightedVSub","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw : ι → k\np₂ : ι → P\np₁ : P\nh : Eq (s.sum fun i => w i) 0\n⊢ Eq (s.sum fun i => HSMul.hSMul (w i) (VSub.vsub p₁ (p₂ i))) (Neg.neg ((s.weightedVSub p₂) w))","decl":"/-- A weighted sum of pairwise subtractions, where the point on the left is constant and the\nsum of the weights is 0. -/\ntheorem sum_smul_const_vsub_eq_neg_weightedVSub (w : ι → k) (p₂ : ι → P) (p₁ : P)\n    (h : ∑ i ∈ s, w i = 0) : (∑ i ∈ s, w i • (p₁ -ᵥ p₂ i)) = -s.weightedVSub p₂ w := by\n  rw [sum_smul_vsub_eq_weightedVSub_sub, s.weightedVSub_apply_const _ _ h, zero_sub]\n\n"}
{"name":"Finset.weightedVSub_sdiff","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\ninst✝ : DecidableEq ι\ns₂ : Finset ι\nh : HasSubset.Subset s₂ s\nw : ι → k\np : ι → P\n⊢ Eq (HAdd.hAdd (((SDiff.sdiff s s₂).weightedVSub p) w) ((s₂.weightedVSub p) w)) ((s.weightedVSub p) w)","decl":"/-- A weighted sum may be split into such sums over two subsets. -/\ntheorem weightedVSub_sdiff [DecidableEq ι] {s₂ : Finset ι} (h : s₂ ⊆ s) (w : ι → k) (p : ι → P) :\n    (s \\ s₂).weightedVSub p w + s₂.weightedVSub p w = s.weightedVSub p w :=\n  s.weightedVSubOfPoint_sdiff h _ _ _\n\n"}
{"name":"Finset.weightedVSub_sdiff_sub","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\ninst✝ : DecidableEq ι\ns₂ : Finset ι\nh : HasSubset.Subset s₂ s\nw : ι → k\np : ι → P\n⊢ Eq (HSub.hSub (((SDiff.sdiff s s₂).weightedVSub p) w) ((s₂.weightedVSub p) (Neg.neg w))) ((s.weightedVSub p) w)","decl":"/-- A weighted sum may be split into a subtraction of such sums over two subsets. -/\ntheorem weightedVSub_sdiff_sub [DecidableEq ι] {s₂ : Finset ι} (h : s₂ ⊆ s) (w : ι → k)\n    (p : ι → P) : (s \\ s₂).weightedVSub p w - s₂.weightedVSub p (-w) = s.weightedVSub p w :=\n  s.weightedVSubOfPoint_sdiff_sub h _ _ _\n\n"}
{"name":"Finset.weightedVSub_subtype_eq_filter","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw : ι → k\np : ι → P\npred : ι → Prop\ninst✝ : DecidablePred pred\n⊢ Eq (((Finset.subtype pred s).weightedVSub fun i => p ↑i) fun i => w ↑i) (((Finset.filter (fun x => pred x) s).weightedVSub p) w)","decl":"/-- A weighted sum over `s.subtype pred` equals one over `{x ∈ s | pred x}`. -/\ntheorem weightedVSub_subtype_eq_filter (w : ι → k) (p : ι → P) (pred : ι → Prop)\n    [DecidablePred pred] :\n    ((s.subtype pred).weightedVSub (fun i => p i) fun i => w i) =\n      {x ∈ s | pred x}.weightedVSub p w :=\n  s.weightedVSubOfPoint_subtype_eq_filter _ _ _ _\n\n"}
{"name":"Finset.weightedVSub_filter_of_ne","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw : ι → k\np : ι → P\npred : ι → Prop\ninst✝ : DecidablePred pred\nh : ∀ (i : ι), Membership.mem s i → Ne (w i) 0 → pred i\n⊢ Eq (((Finset.filter (fun x => pred x) s).weightedVSub p) w) ((s.weightedVSub p) w)","decl":"/-- A weighted sum over `{x ∈ s | pred x}` equals one over `s` if all the weights at indices in `s`\nnot satisfying `pred` are zero. -/\ntheorem weightedVSub_filter_of_ne (w : ι → k) (p : ι → P) {pred : ι → Prop} [DecidablePred pred]\n    (h : ∀ i ∈ s, w i ≠ 0 → pred i) : {x ∈ s | pred x}.weightedVSub p w = s.weightedVSub p w :=\n  s.weightedVSubOfPoint_filter_of_ne _ _ _ h\n\n"}
{"name":"Finset.weightedVSub_const_smul","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw : ι → k\np : ι → P\nc : k\n⊢ Eq ((s.weightedVSub p) (HSMul.hSMul c w)) (HSMul.hSMul c ((s.weightedVSub p) w))","decl":"/-- A constant multiplier of the weights in `weightedVSub_of` may be moved outside the sum. -/\ntheorem weightedVSub_const_smul (w : ι → k) (p : ι → P) (c : k) :\n    s.weightedVSub p (c • w) = c • s.weightedVSub p w :=\n  s.weightedVSubOfPoint_const_smul _ _ _ _\n\n"}
{"name":"Finset.affineCombination_linear","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\np : ι → P\n⊢ Eq (Finset.affineCombination k s p).linear (s.weightedVSub p)","decl":"/-- The linear map corresponding to `affineCombination` is\n`weightedVSub`. -/\n@[simp]\ntheorem affineCombination_linear (p : ι → P) :\n    (s.affineCombination k p).linear = s.weightedVSub p :=\n  rfl\n\n"}
{"name":"Finset.affineCombination_apply","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw : ι → k\np : ι → P\n⊢ Eq ((Finset.affineCombination k s p) w) (HVAdd.hVAdd ((s.weightedVSubOfPoint p (Classical.choice ⋯)) w) (Classical.choice ⋯))","decl":"/-- Applying `affineCombination` with given weights.  This is for the\ncase where a result involving a default base point is OK (for example,\nwhen that base point will cancel out later); a more typical use case\nfor `affineCombination` would involve selecting a preferred base\npoint with\n`affineCombination_eq_weightedVSubOfPoint_vadd_of_sum_eq_one` and\nthen using `weightedVSubOfPoint_apply`. -/\ntheorem affineCombination_apply (w : ι → k) (p : ι → P) :\n    (s.affineCombination k p) w =\n      s.weightedVSubOfPoint p (Classical.choice S.nonempty) w +ᵥ Classical.choice S.nonempty :=\n  rfl\n\n"}
{"name":"Finset.affineCombination_apply_const","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw : ι → k\np : P\nh : Eq (s.sum fun i => w i) 1\n⊢ Eq ((Finset.affineCombination k s fun x => p) w) p","decl":"/-- The value of `affineCombination`, where the given points are equal. -/\n@[simp]\ntheorem affineCombination_apply_const (w : ι → k) (p : P) (h : ∑ i ∈ s, w i = 1) :\n    s.affineCombination k (fun _ => p) w = p := by\n  rw [affineCombination_apply, s.weightedVSubOfPoint_apply_const, h, one_smul, vsub_vadd]\n\n"}
{"name":"Finset.affineCombination_congr","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw₁ w₂ : ι → k\nhw : ∀ (i : ι), Membership.mem s i → Eq (w₁ i) (w₂ i)\np₁ p₂ : ι → P\nhp : ∀ (i : ι), Membership.mem s i → Eq (p₁ i) (p₂ i)\n⊢ Eq ((Finset.affineCombination k s p₁) w₁) ((Finset.affineCombination k s p₂) w₂)","decl":"/-- `affineCombination` gives equal results for two families of weights and two families of\npoints that are equal on `s`. -/\ntheorem affineCombination_congr {w₁ w₂ : ι → k} (hw : ∀ i ∈ s, w₁ i = w₂ i) {p₁ p₂ : ι → P}\n    (hp : ∀ i ∈ s, p₁ i = p₂ i) : s.affineCombination k p₁ w₁ = s.affineCombination k p₂ w₂ := by\n  simp_rw [affineCombination_apply, s.weightedVSubOfPoint_congr hw hp]\n\n"}
{"name":"Finset.affineCombination_eq_weightedVSubOfPoint_vadd_of_sum_eq_one","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw : ι → k\np : ι → P\nh : Eq (s.sum fun i => w i) 1\nb : P\n⊢ Eq ((Finset.affineCombination k s p) w) (HVAdd.hVAdd ((s.weightedVSubOfPoint p b) w) b)","decl":"/-- `affineCombination` gives the sum with any base point, when the\nsum of the weights is 1. -/\ntheorem affineCombination_eq_weightedVSubOfPoint_vadd_of_sum_eq_one (w : ι → k) (p : ι → P)\n    (h : ∑ i ∈ s, w i = 1) (b : P) :\n    s.affineCombination k p w = s.weightedVSubOfPoint p b w +ᵥ b :=\n  s.weightedVSubOfPoint_vadd_eq_of_sum_eq_one w p h _ _\n\n"}
{"name":"Finset.weightedVSub_vadd_affineCombination","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw₁ w₂ : ι → k\np : ι → P\n⊢ Eq (HVAdd.hVAdd ((s.weightedVSub p) w₁) ((Finset.affineCombination k s p) w₂)) ((Finset.affineCombination k s p) (HAdd.hAdd w₁ w₂))","decl":"/-- Adding a `weightedVSub` to an `affineCombination`. -/\ntheorem weightedVSub_vadd_affineCombination (w₁ w₂ : ι → k) (p : ι → P) :\n    s.weightedVSub p w₁ +ᵥ s.affineCombination k p w₂ = s.affineCombination k p (w₁ + w₂) := by\n  rw [← vadd_eq_add, AffineMap.map_vadd, affineCombination_linear]\n\n"}
{"name":"Finset.affineCombination_vsub","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw₁ w₂ : ι → k\np : ι → P\n⊢ Eq (VSub.vsub ((Finset.affineCombination k s p) w₁) ((Finset.affineCombination k s p) w₂)) ((s.weightedVSub p) (HSub.hSub w₁ w₂))","decl":"/-- Subtracting two `affineCombination`s. -/\ntheorem affineCombination_vsub (w₁ w₂ : ι → k) (p : ι → P) :\n    s.affineCombination k p w₁ -ᵥ s.affineCombination k p w₂ = s.weightedVSub p (w₁ - w₂) := by\n  rw [← AffineMap.linearMap_vsub, affineCombination_linear, vsub_eq_sub]\n\n"}
{"name":"Finset.attach_affineCombination_of_injective","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\nS : AddTorsor V P\ninst✝ : DecidableEq P\ns : Finset P\nw : P → k\nf : (Subtype fun x => Membership.mem s x) → P\nhf : Function.Injective f\n⊢ Eq ((Finset.affineCombination k s.attach f) (Function.comp w f)) ((Finset.affineCombination k (Finset.image f Finset.univ) id) w)","decl":"theorem attach_affineCombination_of_injective [DecidableEq P] (s : Finset P) (w : P → k) (f : s → P)\n    (hf : Function.Injective f) :\n    s.attach.affineCombination k f (w ∘ f) = (image f univ).affineCombination k id w := by\n  simp only [affineCombination, weightedVSubOfPoint_apply, id, vadd_right_cancel_iff,\n    Function.comp_apply, AffineMap.coe_mk]\n  let g₁ : s → V := fun i => w (f i) • (f i -ᵥ Classical.choice S.nonempty)\n  let g₂ : P → V := fun i => w i • (i -ᵥ Classical.choice S.nonempty)\n  change univ.sum g₁ = (image f univ).sum g₂\n  have hgf : g₁ = g₂ ∘ f := by\n    ext\n    simp [g₁, g₂]\n  rw [hgf, sum_image]\n  · simp only [g₁, g₂,Function.comp_apply]\n  · exact fun _ _ _ _ hxy => hf hxy\n\n"}
{"name":"Finset.attach_affineCombination_coe","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\ns : Finset P\nw : P → k\n⊢ Eq ((Finset.affineCombination k s.attach Subtype.val) (Function.comp w Subtype.val)) ((Finset.affineCombination k s id) w)","decl":"theorem attach_affineCombination_coe (s : Finset P) (w : P → k) :\n    s.attach.affineCombination k ((↑) : s → P) (w ∘ (↑)) = s.affineCombination k id w := by\n  classical rw [attach_affineCombination_of_injective s w ((↑) : s → P) Subtype.coe_injective,\n      univ_eq_attach, attach_image_val]\n\n"}
{"name":"Finset.weightedVSub_eq_linear_combination","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nι : Type u_6\ns : Finset ι\nw : ι → k\np : ι → V\nhw : Eq (s.sum w) 0\n⊢ Eq ((s.weightedVSub p) w) (s.sum fun i => HSMul.hSMul (w i) (p i))","decl":"/-- Viewing a module as an affine space modelled on itself, a `weightedVSub` is just a linear\ncombination. -/\n@[simp]\ntheorem weightedVSub_eq_linear_combination {ι} (s : Finset ι) {w : ι → k} {p : ι → V}\n    (hw : s.sum w = 0) : s.weightedVSub p w = ∑ i ∈ s, w i • p i := by\n  simp [s.weightedVSub_apply, vsub_eq_sub, smul_sub, ← Finset.sum_smul, hw]\n\n"}
{"name":"Finset.affineCombination_eq_linear_combination","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nι : Type u_4\ns : Finset ι\np : ι → V\nw : ι → k\nhw : Eq (s.sum fun i => w i) 1\n⊢ Eq ((Finset.affineCombination k s p) w) (s.sum fun i => HSMul.hSMul (w i) (p i))","decl":"/-- Viewing a module as an affine space modelled on itself, affine combinations are just linear\ncombinations. -/\n@[simp]\ntheorem affineCombination_eq_linear_combination (s : Finset ι) (p : ι → V) (w : ι → k)\n    (hw : ∑ i ∈ s, w i = 1) : s.affineCombination k p w = ∑ i ∈ s, w i • p i := by\n  simp [s.affineCombination_eq_weightedVSubOfPoint_vadd_of_sum_eq_one w p hw 0]\n\n"}
{"name":"Finset.affineCombination_of_eq_one_of_eq_zero","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw : ι → k\np : ι → P\ni : ι\nhis : Membership.mem s i\nhwi : Eq (w i) 1\nhw0 : ∀ (i2 : ι), Membership.mem s i2 → Ne i2 i → Eq (w i2) 0\n⊢ Eq ((Finset.affineCombination k s p) w) (p i)","decl":"/-- An `affineCombination` equals a point if that point is in the set\nand has weight 1 and the other points in the set have weight 0. -/\n@[simp]\ntheorem affineCombination_of_eq_one_of_eq_zero (w : ι → k) (p : ι → P) {i : ι} (his : i ∈ s)\n    (hwi : w i = 1) (hw0 : ∀ i2 ∈ s, i2 ≠ i → w i2 = 0) : s.affineCombination k p w = p i := by\n  have h1 : ∑ i ∈ s, w i = 1 := hwi ▸ sum_eq_single i hw0 fun h => False.elim (h his)\n  rw [s.affineCombination_eq_weightedVSubOfPoint_vadd_of_sum_eq_one w p h1 (p i),\n    weightedVSubOfPoint_apply]\n  convert zero_vadd V (p i)\n  refine sum_eq_zero ?_\n  intro i2 hi2\n  by_cases h : i2 = i\n  · simp [h]\n  · simp [hw0 i2 hi2 h]\n\n"}
{"name":"Finset.affineCombination_indicator_subset","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\nw : ι → k\np : ι → P\ns₁ s₂ : Finset ι\nh : HasSubset.Subset s₁ s₂\n⊢ Eq ((Finset.affineCombination k s₁ p) w) ((Finset.affineCombination k s₂ p) ((↑s₁).indicator w))","decl":"/-- An affine combination is unaffected by changing the weights to the\ncorresponding indicator function and adding points to the set. -/\ntheorem affineCombination_indicator_subset (w : ι → k) (p : ι → P) {s₁ s₂ : Finset ι}\n    (h : s₁ ⊆ s₂) :\n    s₁.affineCombination k p w = s₂.affineCombination k p (Set.indicator (↑s₁) w) := by\n  rw [affineCombination_apply, affineCombination_apply,\n    weightedVSubOfPoint_indicator_subset _ _ _ h]\n\n"}
{"name":"Finset.affineCombination_map","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\nι₂ : Type u_5\ns₂ : Finset ι₂\ne : Function.Embedding ι₂ ι\nw : ι → k\np : ι → P\n⊢ Eq ((Finset.affineCombination k (Finset.map e s₂) p) w) ((Finset.affineCombination k s₂ (Function.comp p ⇑e)) (Function.comp w ⇑e))","decl":"/-- An affine combination, over the image of an embedding, equals an\naffine combination with the same points and weights over the original\n`Finset`. -/\ntheorem affineCombination_map (e : ι₂ ↪ ι) (w : ι → k) (p : ι → P) :\n    (s₂.map e).affineCombination k p w = s₂.affineCombination k (p ∘ e) (w ∘ e) := by\n  simp_rw [affineCombination_apply, weightedVSubOfPoint_map]\n\n"}
{"name":"Finset.sum_smul_vsub_eq_affineCombination_vsub","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw : ι → k\np₁ p₂ : ι → P\n⊢ Eq (s.sum fun i => HSMul.hSMul (w i) (VSub.vsub (p₁ i) (p₂ i))) (VSub.vsub ((Finset.affineCombination k s p₁) w) ((Finset.affineCombination k s p₂) w))","decl":"/-- A weighted sum of pairwise subtractions, expressed as a subtraction of two `affineCombination`\nexpressions. -/\ntheorem sum_smul_vsub_eq_affineCombination_vsub (w : ι → k) (p₁ p₂ : ι → P) :\n    (∑ i ∈ s, w i • (p₁ i -ᵥ p₂ i)) =\n      s.affineCombination k p₁ w -ᵥ s.affineCombination k p₂ w := by\n  simp_rw [affineCombination_apply, vadd_vsub_vadd_cancel_right]\n  exact s.sum_smul_vsub_eq_weightedVSubOfPoint_sub _ _ _ _\n\n"}
{"name":"Finset.sum_smul_vsub_const_eq_affineCombination_vsub","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw : ι → k\np₁ : ι → P\np₂ : P\nh : Eq (s.sum fun i => w i) 1\n⊢ Eq (s.sum fun i => HSMul.hSMul (w i) (VSub.vsub (p₁ i) p₂)) (VSub.vsub ((Finset.affineCombination k s p₁) w) p₂)","decl":"/-- A weighted sum of pairwise subtractions, where the point on the right is constant and the\nsum of the weights is 1. -/\ntheorem sum_smul_vsub_const_eq_affineCombination_vsub (w : ι → k) (p₁ : ι → P) (p₂ : P)\n    (h : ∑ i ∈ s, w i = 1) : (∑ i ∈ s, w i • (p₁ i -ᵥ p₂)) = s.affineCombination k p₁ w -ᵥ p₂ := by\n  rw [sum_smul_vsub_eq_affineCombination_vsub, affineCombination_apply_const _ _ _ h]\n\n"}
{"name":"Finset.sum_smul_const_vsub_eq_vsub_affineCombination","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw : ι → k\np₂ : ι → P\np₁ : P\nh : Eq (s.sum fun i => w i) 1\n⊢ Eq (s.sum fun i => HSMul.hSMul (w i) (VSub.vsub p₁ (p₂ i))) (VSub.vsub p₁ ((Finset.affineCombination k s p₂) w))","decl":"/-- A weighted sum of pairwise subtractions, where the point on the left is constant and the\nsum of the weights is 1. -/\ntheorem sum_smul_const_vsub_eq_vsub_affineCombination (w : ι → k) (p₂ : ι → P) (p₁ : P)\n    (h : ∑ i ∈ s, w i = 1) : (∑ i ∈ s, w i • (p₁ -ᵥ p₂ i)) = p₁ -ᵥ s.affineCombination k p₂ w := by\n  rw [sum_smul_vsub_eq_affineCombination_vsub, affineCombination_apply_const _ _ _ h]\n\n"}
{"name":"Finset.affineCombination_sdiff_sub","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\ninst✝ : DecidableEq ι\ns₂ : Finset ι\nh : HasSubset.Subset s₂ s\nw : ι → k\np : ι → P\n⊢ Eq (VSub.vsub ((Finset.affineCombination k (SDiff.sdiff s s₂) p) w) ((Finset.affineCombination k s₂ p) (Neg.neg w))) ((s.weightedVSub p) w)","decl":"/-- A weighted sum may be split into a subtraction of affine combinations over two subsets. -/\ntheorem affineCombination_sdiff_sub [DecidableEq ι] {s₂ : Finset ι} (h : s₂ ⊆ s) (w : ι → k)\n    (p : ι → P) :\n    (s \\ s₂).affineCombination k p w -ᵥ s₂.affineCombination k p (-w) = s.weightedVSub p w := by\n  simp_rw [affineCombination_apply, vadd_vsub_vadd_cancel_right]\n  exact s.weightedVSub_sdiff_sub h _ _\n\n"}
{"name":"Finset.affineCombination_eq_of_weightedVSub_eq_zero_of_eq_neg_one","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw : ι → k\np : ι → P\nhw : Eq ((s.weightedVSub p) w) 0\ni : ι\ninst✝ : DecidablePred fun x => Ne x i\nhis : Membership.mem s i\nhwi : Eq (w i) (-1)\n⊢ Eq ((Finset.affineCombination k (Finset.filter (fun x => Ne x i) s) p) w) (p i)","decl":"/-- If a weighted sum is zero and one of the weights is `-1`, the corresponding point is\nthe affine combination of the other points with the given weights. -/\ntheorem affineCombination_eq_of_weightedVSub_eq_zero_of_eq_neg_one {w : ι → k} {p : ι → P}\n    (hw : s.weightedVSub p w = (0 : V)) {i : ι} [DecidablePred (· ≠ i)] (his : i ∈ s)\n    (hwi : w i = -1) : {x ∈ s | x ≠ i}.affineCombination k p w = p i := by\n  classical\n    rw [← @vsub_eq_zero_iff_eq V, ← hw,\n      ← s.affineCombination_sdiff_sub (singleton_subset_iff.2 his), sdiff_singleton_eq_erase,\n      ← filter_ne']\n    congr\n    refine (affineCombination_of_eq_one_of_eq_zero _ _ _ (mem_singleton_self _) ?_ ?_).symm\n    · simp [hwi]\n    · simp\n\n"}
{"name":"Finset.affineCombination_subtype_eq_filter","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw : ι → k\np : ι → P\npred : ι → Prop\ninst✝ : DecidablePred pred\n⊢ Eq ((Finset.affineCombination k (Finset.subtype pred s) fun i => p ↑i) fun i => w ↑i) ((Finset.affineCombination k (Finset.filter (fun x => pred x) s) p) w)","decl":"/-- An affine combination over `s.subtype pred` equals one over `{x ∈ s | pred x}`. -/\ntheorem affineCombination_subtype_eq_filter (w : ι → k) (p : ι → P) (pred : ι → Prop)\n    [DecidablePred pred] :\n    ((s.subtype pred).affineCombination k (fun i => p i) fun i => w i) =\n      {x ∈ s | pred x}.affineCombination k p w := by\n  rw [affineCombination_apply, affineCombination_apply, weightedVSubOfPoint_subtype_eq_filter]\n\n"}
{"name":"Finset.affineCombination_filter_of_ne","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nw : ι → k\np : ι → P\npred : ι → Prop\ninst✝ : DecidablePred pred\nh : ∀ (i : ι), Membership.mem s i → Ne (w i) 0 → pred i\n⊢ Eq ((Finset.affineCombination k (Finset.filter (fun x => pred x) s) p) w) ((Finset.affineCombination k s p) w)","decl":"/-- An affine combination over `{x ∈ s | pred x}` equals one over `s` if all the weights at indices\nin `s` not satisfying `pred` are zero. -/\ntheorem affineCombination_filter_of_ne (w : ι → k) (p : ι → P) {pred : ι → Prop}\n    [DecidablePred pred] (h : ∀ i ∈ s, w i ≠ 0 → pred i) :\n    {x ∈ s | pred x}.affineCombination k p w = s.affineCombination k p w := by\n  rw [affineCombination_apply, affineCombination_apply,\n    s.weightedVSubOfPoint_filter_of_ne _ _ _ h]\n\n"}
{"name":"Finset.eq_weightedVSubOfPoint_subset_iff_eq_weightedVSubOfPoint_subtype","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\nv : V\nx : k\ns : Set ι\np : ι → P\nb : P\n⊢ Iff (Exists fun fs => And (HasSubset.Subset (↑fs) s) (Exists fun w => And (Eq (fs.sum fun i => w i) x) (Eq v ((fs.weightedVSubOfPoint p b) w)))) (Exists fun fs => Exists fun w => And (Eq (fs.sum fun i => w i) x) (Eq v ((fs.weightedVSubOfPoint (fun i => p ↑i) b) w)))","decl":"/-- Suppose an indexed family of points is given, along with a subset\nof the index type.  A vector can be expressed as\n`weightedVSubOfPoint` using a `Finset` lying within that subset and\nwith a given sum of weights if and only if it can be expressed as\n`weightedVSubOfPoint` with that sum of weights for the\ncorresponding indexed family whose index type is the subtype\ncorresponding to that subset. -/\ntheorem eq_weightedVSubOfPoint_subset_iff_eq_weightedVSubOfPoint_subtype {v : V} {x : k} {s : Set ι}\n    {p : ι → P} {b : P} :\n    (∃ fs : Finset ι, ↑fs ⊆ s ∧ ∃ w : ι → k, ∑ i ∈ fs, w i = x ∧\n        v = fs.weightedVSubOfPoint p b w) ↔\n      ∃ (fs : Finset s) (w : s → k), ∑ i ∈ fs, w i = x ∧\n        v = fs.weightedVSubOfPoint (fun i : s => p i) b w := by\n  classical\n    simp_rw [weightedVSubOfPoint_apply]\n    constructor\n    · rintro ⟨fs, hfs, w, rfl, rfl⟩\n      exact ⟨fs.subtype s, fun i => w i, sum_subtype_of_mem _ hfs, (sum_subtype_of_mem _ hfs).symm⟩\n    · rintro ⟨fs, w, rfl, rfl⟩\n      refine\n          ⟨fs.map (Function.Embedding.subtype _), map_subtype_subset _, fun i =>\n            if h : i ∈ s then w ⟨i, h⟩ else 0, ?_, ?_⟩ <;>\n        simp\n\n"}
{"name":"Finset.eq_weightedVSub_subset_iff_eq_weightedVSub_subtype","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\nv : V\ns : Set ι\np : ι → P\n⊢ Iff (Exists fun fs => And (HasSubset.Subset (↑fs) s) (Exists fun w => And (Eq (fs.sum fun i => w i) 0) (Eq v ((fs.weightedVSub p) w)))) (Exists fun fs => Exists fun w => And (Eq (fs.sum fun i => w i) 0) (Eq v ((fs.weightedVSub fun i => p ↑i) w)))","decl":"/-- Suppose an indexed family of points is given, along with a subset\nof the index type.  A vector can be expressed as `weightedVSub` using\na `Finset` lying within that subset and with sum of weights 0 if and\nonly if it can be expressed as `weightedVSub` with sum of weights 0\nfor the corresponding indexed family whose index type is the subtype\ncorresponding to that subset. -/\ntheorem eq_weightedVSub_subset_iff_eq_weightedVSub_subtype {v : V} {s : Set ι} {p : ι → P} :\n    (∃ fs : Finset ι, ↑fs ⊆ s ∧ ∃ w : ι → k, ∑ i ∈ fs, w i = 0 ∧\n        v = fs.weightedVSub p w) ↔\n      ∃ (fs : Finset s) (w : s → k), ∑ i ∈ fs, w i = 0 ∧\n        v = fs.weightedVSub (fun i : s => p i) w :=\n  eq_weightedVSubOfPoint_subset_iff_eq_weightedVSubOfPoint_subtype\n\n"}
{"name":"Finset.eq_affineCombination_subset_iff_eq_affineCombination_subtype","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\np0 : P\ns : Set ι\np : ι → P\n⊢ Iff (Exists fun fs => And (HasSubset.Subset (↑fs) s) (Exists fun w => And (Eq (fs.sum fun i => w i) 1) (Eq p0 ((Finset.affineCombination k fs p) w)))) (Exists fun fs => Exists fun w => And (Eq (fs.sum fun i => w i) 1) (Eq p0 ((Finset.affineCombination k fs fun i => p ↑i) w)))","decl":"/-- Suppose an indexed family of points is given, along with a subset\nof the index type.  A point can be expressed as an\n`affineCombination` using a `Finset` lying within that subset and\nwith sum of weights 1 if and only if it can be expressed an\n`affineCombination` with sum of weights 1 for the corresponding\nindexed family whose index type is the subtype corresponding to that\nsubset. -/\ntheorem eq_affineCombination_subset_iff_eq_affineCombination_subtype {p0 : P} {s : Set ι}\n    {p : ι → P} :\n    (∃ fs : Finset ι, ↑fs ⊆ s ∧ ∃ w : ι → k, ∑ i ∈ fs, w i = 1 ∧\n        p0 = fs.affineCombination k p w) ↔\n      ∃ (fs : Finset s) (w : s → k), ∑ i ∈ fs, w i = 1 ∧\n        p0 = fs.affineCombination k (fun i : s => p i) w := by\n  simp_rw [affineCombination_apply, eq_vadd_iff_vsub_eq]\n  exact eq_weightedVSubOfPoint_subset_iff_eq_weightedVSubOfPoint_subtype\n\n"}
{"name":"Finset.map_affineCombination","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁵ : Ring k\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\nV₂ : Type u_6\nP₂ : Type u_7\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\np : ι → P\nw : ι → k\nhw : Eq (s.sum w) 1\nf : AffineMap k P P₂\n⊢ Eq (f ((Finset.affineCombination k s p) w)) ((Finset.affineCombination k s (Function.comp (⇑f) p)) w)","decl":"/-- Affine maps commute with affine combinations. -/\ntheorem map_affineCombination {V₂ P₂ : Type*} [AddCommGroup V₂] [Module k V₂] [AffineSpace V₂ P₂]\n    (p : ι → P) (w : ι → k) (hw : s.sum w = 1) (f : P →ᵃ[k] P₂) :\n    f (s.affineCombination k p w) = s.affineCombination k (f ∘ p) w := by\n  have b := Classical.choice (inferInstance : AffineSpace V P).nonempty\n  have b₂ := Classical.choice (inferInstance : AffineSpace V₂ P₂).nonempty\n  rw [s.affineCombination_eq_weightedVSubOfPoint_vadd_of_sum_eq_one w p hw b,\n    s.affineCombination_eq_weightedVSubOfPoint_vadd_of_sum_eq_one w (f ∘ p) hw b₂, ←\n    s.weightedVSubOfPoint_vadd_eq_of_sum_eq_one w (f ∘ p) hw (f b) b₂]\n  simp only [weightedVSubOfPoint_apply, RingHom.id_apply, AffineMap.map_vadd,\n    LinearMap.map_smulₛₗ, AffineMap.linearMap_vsub, map_sum, Function.comp_apply]\n\n"}
{"name":"Finset.affineCombinationSingleWeights_apply_self","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\ninst✝¹ : Ring k\nι : Type u_4\ninst✝ : DecidableEq ι\ni : ι\n⊢ Eq (Finset.affineCombinationSingleWeights k i i) 1","decl":"@[simp]\ntheorem affineCombinationSingleWeights_apply_self [DecidableEq ι] (i : ι) :\n    affineCombinationSingleWeights k i i = 1 := by simp [affineCombinationSingleWeights]\n\n"}
{"name":"Finset.affineCombinationSingleWeights_apply_of_ne","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\ninst✝¹ : Ring k\nι : Type u_4\ninst✝ : DecidableEq ι\ni j : ι\nh : Ne j i\n⊢ Eq (Finset.affineCombinationSingleWeights k i j) 0","decl":"@[simp]\ntheorem affineCombinationSingleWeights_apply_of_ne [DecidableEq ι] {i j : ι} (h : j ≠ i) :\n    affineCombinationSingleWeights k i j = 0 := by simp [affineCombinationSingleWeights, h]\n\n"}
{"name":"Finset.sum_affineCombinationSingleWeights","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\ninst✝¹ : Ring k\nι : Type u_4\ns : Finset ι\ninst✝ : DecidableEq ι\ni : ι\nh : Membership.mem s i\n⊢ Eq (s.sum fun j => Finset.affineCombinationSingleWeights k i j) 1","decl":"@[simp]\ntheorem sum_affineCombinationSingleWeights [DecidableEq ι] {i : ι} (h : i ∈ s) :\n    ∑ j ∈ s, affineCombinationSingleWeights k i j = 1 := by\n  rw [← affineCombinationSingleWeights_apply_self k i]\n  exact sum_eq_single_of_mem i h fun j _ hj => affineCombinationSingleWeights_apply_of_ne k hj\n\n"}
{"name":"Finset.weightedVSubVSubWeights_self","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\ninst✝¹ : Ring k\nι : Type u_4\ninst✝ : DecidableEq ι\ni : ι\n⊢ Eq (Finset.weightedVSubVSubWeights k i i) 0","decl":"@[simp]\ntheorem weightedVSubVSubWeights_self [DecidableEq ι] (i : ι) :\n    weightedVSubVSubWeights k i i = 0 := by simp [weightedVSubVSubWeights]\n\n"}
{"name":"Finset.weightedVSubVSubWeights_apply_left","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\ninst✝¹ : Ring k\nι : Type u_4\ninst✝ : DecidableEq ι\ni j : ι\nh : Ne i j\n⊢ Eq (Finset.weightedVSubVSubWeights k i j i) 1","decl":"@[simp]\ntheorem weightedVSubVSubWeights_apply_left [DecidableEq ι] {i j : ι} (h : i ≠ j) :\n    weightedVSubVSubWeights k i j i = 1 := by simp [weightedVSubVSubWeights, h]\n\n"}
{"name":"Finset.weightedVSubVSubWeights_apply_right","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\ninst✝¹ : Ring k\nι : Type u_4\ninst✝ : DecidableEq ι\ni j : ι\nh : Ne i j\n⊢ Eq (Finset.weightedVSubVSubWeights k i j j) (-1)","decl":"@[simp]\ntheorem weightedVSubVSubWeights_apply_right [DecidableEq ι] {i j : ι} (h : i ≠ j) :\n    weightedVSubVSubWeights k i j j = -1 := by simp [weightedVSubVSubWeights, h.symm]\n\n"}
{"name":"Finset.weightedVSubVSubWeights_apply_of_ne","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\ninst✝¹ : Ring k\nι : Type u_4\ninst✝ : DecidableEq ι\ni j t : ι\nhi : Ne t i\nhj : Ne t j\n⊢ Eq (Finset.weightedVSubVSubWeights k i j t) 0","decl":"@[simp]\ntheorem weightedVSubVSubWeights_apply_of_ne [DecidableEq ι] {i j t : ι} (hi : t ≠ i) (hj : t ≠ j) :\n    weightedVSubVSubWeights k i j t = 0 := by simp [weightedVSubVSubWeights, hi, hj]\n\n"}
{"name":"Finset.sum_weightedVSubVSubWeights","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\ninst✝¹ : Ring k\nι : Type u_4\ns : Finset ι\ninst✝ : DecidableEq ι\ni j : ι\nhi : Membership.mem s i\nhj : Membership.mem s j\n⊢ Eq (s.sum fun t => Finset.weightedVSubVSubWeights k i j t) 0","decl":"@[simp]\ntheorem sum_weightedVSubVSubWeights [DecidableEq ι] {i j : ι} (hi : i ∈ s) (hj : j ∈ s) :\n    ∑ t ∈ s, weightedVSubVSubWeights k i j t = 0 := by\n  simp_rw [weightedVSubVSubWeights, Pi.sub_apply, sum_sub_distrib]\n  simp [hi, hj]\n\n"}
{"name":"Finset.affineCombinationLineMapWeights_self","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\ninst✝¹ : Ring k\nι : Type u_4\ninst✝ : DecidableEq ι\ni : ι\nc : k\n⊢ Eq (Finset.affineCombinationLineMapWeights i i c) (Finset.affineCombinationSingleWeights k i)","decl":"@[simp]\ntheorem affineCombinationLineMapWeights_self [DecidableEq ι] (i : ι) (c : k) :\n    affineCombinationLineMapWeights i i c = affineCombinationSingleWeights k i := by\n  simp [affineCombinationLineMapWeights]\n\n"}
{"name":"Finset.affineCombinationLineMapWeights_apply_left","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\ninst✝¹ : Ring k\nι : Type u_4\ninst✝ : DecidableEq ι\ni j : ι\nh : Ne i j\nc : k\n⊢ Eq (Finset.affineCombinationLineMapWeights i j c i) (HSub.hSub 1 c)","decl":"@[simp]\ntheorem affineCombinationLineMapWeights_apply_left [DecidableEq ι] {i j : ι} (h : i ≠ j) (c : k) :\n    affineCombinationLineMapWeights i j c i = 1 - c := by\n  simp [affineCombinationLineMapWeights, h.symm, sub_eq_neg_add]\n\n"}
{"name":"Finset.affineCombinationLineMapWeights_apply_right","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\ninst✝¹ : Ring k\nι : Type u_4\ninst✝ : DecidableEq ι\ni j : ι\nh : Ne i j\nc : k\n⊢ Eq (Finset.affineCombinationLineMapWeights i j c j) c","decl":"@[simp]\ntheorem affineCombinationLineMapWeights_apply_right [DecidableEq ι] {i j : ι} (h : i ≠ j) (c : k) :\n    affineCombinationLineMapWeights i j c j = c := by\n  simp [affineCombinationLineMapWeights, h.symm]\n\n"}
{"name":"Finset.affineCombinationLineMapWeights_apply_of_ne","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\ninst✝¹ : Ring k\nι : Type u_4\ninst✝ : DecidableEq ι\ni j t : ι\nhi : Ne t i\nhj : Ne t j\nc : k\n⊢ Eq (Finset.affineCombinationLineMapWeights i j c t) 0","decl":"@[simp]\ntheorem affineCombinationLineMapWeights_apply_of_ne [DecidableEq ι] {i j t : ι} (hi : t ≠ i)\n    (hj : t ≠ j) (c : k) : affineCombinationLineMapWeights i j c t = 0 := by\n  simp [affineCombinationLineMapWeights, hi, hj]\n\n"}
{"name":"Finset.sum_affineCombinationLineMapWeights","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\ninst✝¹ : Ring k\nι : Type u_4\ns : Finset ι\ninst✝ : DecidableEq ι\ni j : ι\nhi : Membership.mem s i\nhj : Membership.mem s j\nc : k\n⊢ Eq (s.sum fun t => Finset.affineCombinationLineMapWeights i j c t) 1","decl":"@[simp]\ntheorem sum_affineCombinationLineMapWeights [DecidableEq ι] {i j : ι} (hi : i ∈ s) (hj : j ∈ s)\n    (c : k) : ∑ t ∈ s, affineCombinationLineMapWeights i j c t = 1 := by\n  simp_rw [affineCombinationLineMapWeights, Pi.add_apply, sum_add_distrib]\n  simp [hi, hj, ← mul_sum]\n\n"}
{"name":"Finset.affineCombination_affineCombinationSingleWeights","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\ninst✝ : DecidableEq ι\np : ι → P\ni : ι\nhi : Membership.mem s i\n⊢ Eq ((Finset.affineCombination k s p) (Finset.affineCombinationSingleWeights k i)) (p i)","decl":"/-- An affine combination with `affineCombinationSingleWeights` gives the specified point. -/\n@[simp]\ntheorem affineCombination_affineCombinationSingleWeights [DecidableEq ι] (p : ι → P) {i : ι}\n    (hi : i ∈ s) : s.affineCombination k p (affineCombinationSingleWeights k i) = p i := by\n  refine s.affineCombination_of_eq_one_of_eq_zero _ _ hi (by simp) ?_\n  rintro j - hj\n  simp [hj]\n\n"}
{"name":"Finset.weightedVSub_weightedVSubVSubWeights","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\ninst✝ : DecidableEq ι\np : ι → P\ni j : ι\nhi : Membership.mem s i\nhj : Membership.mem s j\n⊢ Eq ((s.weightedVSub p) (Finset.weightedVSubVSubWeights k i j)) (VSub.vsub (p i) (p j))","decl":"/-- A weighted subtraction with `weightedVSubVSubWeights` gives the result of subtracting the\nspecified points. -/\n@[simp]\ntheorem weightedVSub_weightedVSubVSubWeights [DecidableEq ι] (p : ι → P) {i j : ι} (hi : i ∈ s)\n    (hj : j ∈ s) : s.weightedVSub p (weightedVSubVSubWeights k i j) = p i -ᵥ p j := by\n  rw [weightedVSubVSubWeights, ← affineCombination_vsub,\n    s.affineCombination_affineCombinationSingleWeights k p hi,\n    s.affineCombination_affineCombinationSingleWeights k p hj]\n\n"}
{"name":"Finset.affineCombination_affineCombinationLineMapWeights","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : Finset ι\ninst✝ : DecidableEq ι\np : ι → P\ni j : ι\nhi : Membership.mem s i\nhj : Membership.mem s j\nc : k\n⊢ Eq ((Finset.affineCombination k s p) (Finset.affineCombinationLineMapWeights i j c)) ((AffineMap.lineMap (p i) (p j)) c)","decl":"/-- An affine combination with `affineCombinationLineMapWeights` gives the result of\n`line_map`. -/\n@[simp]\ntheorem affineCombination_affineCombinationLineMapWeights [DecidableEq ι] (p : ι → P) {i j : ι}\n    (hi : i ∈ s) (hj : j ∈ s) (c : k) :\n    s.affineCombination k p (affineCombinationLineMapWeights i j c) =\n      AffineMap.lineMap (p i) (p j) c := by\n  rw [affineCombinationLineMapWeights, ← weightedVSub_vadd_affineCombination,\n    weightedVSub_const_smul, s.affineCombination_affineCombinationSingleWeights k p hi,\n    s.weightedVSub_weightedVSubVSubWeights k p hj hi, AffineMap.lineMap_apply]\n\n"}
{"name":"Finset.centroidWeights_apply","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\ninst✝ : DivisionRing k\nι : Type u_4\ns : Finset ι\ni : ι\n⊢ Eq (Finset.centroidWeights k s i) (Inv.inv ↑s.card)","decl":"/-- `centroidWeights` at any point. -/\n@[simp]\ntheorem centroidWeights_apply (i : ι) : s.centroidWeights k i = (#s : k)⁻¹ :=\n  rfl\n\n"}
{"name":"Finset.centroidWeights_eq_const","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\ninst✝ : DivisionRing k\nι : Type u_4\ns : Finset ι\n⊢ Eq (Finset.centroidWeights k s) (Function.const ι (Inv.inv ↑s.card))","decl":"/-- `centroidWeights` equals a constant function. -/\ntheorem centroidWeights_eq_const : s.centroidWeights k = Function.const ι (#s : k)⁻¹ :=\n  rfl\n\n"}
{"name":"Finset.sum_centroidWeights_eq_one_of_cast_card_ne_zero","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\ninst✝ : DivisionRing k\nι : Type u_4\ns : Finset ι\nh : Ne (↑s.card) 0\n⊢ Eq (s.sum fun i => Finset.centroidWeights k s i) 1","decl":"/-- The weights in the centroid sum to 1, if the number of points,\nconverted to `k`, is not zero. -/\ntheorem sum_centroidWeights_eq_one_of_cast_card_ne_zero (h : (#s : k) ≠ 0) :\n    ∑ i ∈ s, s.centroidWeights k i = 1 := by simp [h]\n\n"}
{"name":"Finset.sum_centroidWeights_eq_one_of_card_ne_zero","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\ninst✝¹ : DivisionRing k\nι : Type u_4\ns : Finset ι\ninst✝ : CharZero k\nh : Ne s.card 0\n⊢ Eq (s.sum fun i => Finset.centroidWeights k s i) 1","decl":"/-- In the characteristic zero case, the weights in the centroid sum\nto 1 if the number of points is not zero. -/\ntheorem sum_centroidWeights_eq_one_of_card_ne_zero [CharZero k] (h : #s ≠ 0) :\n    ∑ i ∈ s, s.centroidWeights k i = 1 := by\n  -- Porting note: `simp` cannot find `mul_inv_cancel` and does not use `norm_cast`\n  simp only [centroidWeights_apply, sum_const, nsmul_eq_mul, ne_eq, Nat.cast_eq_zero, card_eq_zero]\n  refine mul_inv_cancel₀ ?_\n  norm_cast\n\n"}
{"name":"Finset.sum_centroidWeights_eq_one_of_nonempty","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\ninst✝¹ : DivisionRing k\nι : Type u_4\ns : Finset ι\ninst✝ : CharZero k\nh : s.Nonempty\n⊢ Eq (s.sum fun i => Finset.centroidWeights k s i) 1","decl":"/-- In the characteristic zero case, the weights in the centroid sum\nto 1 if the set is nonempty. -/\ntheorem sum_centroidWeights_eq_one_of_nonempty [CharZero k] (h : s.Nonempty) :\n    ∑ i ∈ s, s.centroidWeights k i = 1 :=\n  s.sum_centroidWeights_eq_one_of_card_ne_zero k (ne_of_gt (card_pos.2 h))\n\n"}
{"name":"Finset.sum_centroidWeights_eq_one_of_card_eq_add_one","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\ninst✝¹ : DivisionRing k\nι : Type u_4\ns : Finset ι\ninst✝ : CharZero k\nn : Nat\nh : Eq s.card (HAdd.hAdd n 1)\n⊢ Eq (s.sum fun i => Finset.centroidWeights k s i) 1","decl":"/-- In the characteristic zero case, the weights in the centroid sum\nto 1 if the number of points is `n + 1`. -/\ntheorem sum_centroidWeights_eq_one_of_card_eq_add_one [CharZero k] {n : ℕ} (h : #s = n + 1) :\n    ∑ i ∈ s, s.centroidWeights k i = 1 :=\n  s.sum_centroidWeights_eq_one_of_card_ne_zero k (h.symm ▸ Nat.succ_ne_zero n)\n\n"}
{"name":"Finset.centroid_def","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nι : Type u_4\ns : Finset ι\np : ι → P\n⊢ Eq (Finset.centroid k s p) ((Finset.affineCombination k s p) (Finset.centroidWeights k s))","decl":"/-- The definition of the centroid. -/\ntheorem centroid_def (p : ι → P) : s.centroid k p = s.affineCombination k p (s.centroidWeights k) :=\n  rfl\n\n"}
{"name":"Finset.centroid_univ","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Finset P\n⊢ Eq (Finset.centroid k Finset.univ Subtype.val) (Finset.centroid k s id)","decl":"theorem centroid_univ (s : Finset P) : univ.centroid k ((↑) : s → P) = s.centroid k id := by\n  rw [centroid, centroid, ← s.attach_affineCombination_coe]\n  congr\n  ext\n  simp\n\n"}
{"name":"Finset.centroid_singleton","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nι : Type u_4\np : ι → P\ni : ι\n⊢ Eq (Finset.centroid k (Singleton.singleton i) p) (p i)","decl":"/-- The centroid of a single point. -/\n@[simp]\ntheorem centroid_singleton (p : ι → P) (i : ι) : ({i} : Finset ι).centroid k p = p i := by\n  simp [centroid_def, affineCombination_apply]\n\n"}
{"name":"Finset.centroid_pair","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁵ : DivisionRing k\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module k V\ninst✝² : AddTorsor V P\nι : Type u_4\ninst✝¹ : DecidableEq ι\ninst✝ : Invertible 2\np : ι → P\ni₁ i₂ : ι\n⊢ Eq (Finset.centroid k (Insert.insert i₁ (Singleton.singleton i₂)) p) (HVAdd.hVAdd (HSMul.hSMul (Inv.inv 2) (VSub.vsub (p i₂) (p i₁))) (p i₁))","decl":"/-- The centroid of two points, expressed directly as adding a vector\nto a point. -/\ntheorem centroid_pair [DecidableEq ι] [Invertible (2 : k)] (p : ι → P) (i₁ i₂ : ι) :\n    ({i₁, i₂} : Finset ι).centroid k p = (2⁻¹ : k) • (p i₂ -ᵥ p i₁) +ᵥ p i₁ := by\n  by_cases h : i₁ = i₂\n  · simp [h]\n  · have hc : (#{i₁, i₂} : k) ≠ 0 := by\n      rw [card_insert_of_not_mem (not_mem_singleton.2 h), card_singleton]\n      norm_num\n      exact Invertible.ne_zero _\n    rw [centroid_def,\n      affineCombination_eq_weightedVSubOfPoint_vadd_of_sum_eq_one _ _ _\n        (sum_centroidWeights_eq_one_of_cast_card_ne_zero _ hc) (p i₁)]\n    simp [h, one_add_one_eq_two]\n\n"}
{"name":"Finset.centroid_pair_fin","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁴ : DivisionRing k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ninst✝ : Invertible 2\np : Fin 2 → P\n⊢ Eq (Finset.centroid k Finset.univ p) (HVAdd.hVAdd (HSMul.hSMul (Inv.inv 2) (VSub.vsub (p 1) (p 0))) (p 0))","decl":"/-- The centroid of two points indexed by `Fin 2`, expressed directly\nas adding a vector to the first point. -/\ntheorem centroid_pair_fin [Invertible (2 : k)] (p : Fin 2 → P) :\n    univ.centroid k p = (2⁻¹ : k) • (p 1 -ᵥ p 0) +ᵥ p 0 := by\n  rw [univ_fin2]\n  convert centroid_pair k p 0 1\n\n"}
{"name":"Finset.centroid_map","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nι : Type u_4\nι₂ : Type u_5\ns₂ : Finset ι₂\ne : Function.Embedding ι₂ ι\np : ι → P\n⊢ Eq (Finset.centroid k (Finset.map e s₂) p) (Finset.centroid k s₂ (Function.comp p ⇑e))","decl":"/-- A centroid, over the image of an embedding, equals a centroid with\nthe same points and weights over the original `Finset`. -/\ntheorem centroid_map (e : ι₂ ↪ ι) (p : ι → P) :\n    (s₂.map e).centroid k p = s₂.centroid k (p ∘ e) := by\n  simp [centroid_def, affineCombination_map, centroidWeights]\n\n"}
{"name":"Finset.centroidWeightsIndicator_def","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\ninst✝ : DivisionRing k\nι : Type u_4\ns : Finset ι\n⊢ Eq (Finset.centroidWeightsIndicator k s) ((↑s).indicator (Finset.centroidWeights k s))","decl":"/-- The definition of `centroidWeightsIndicator`. -/\ntheorem centroidWeightsIndicator_def :\n    s.centroidWeightsIndicator k = Set.indicator (↑s) (s.centroidWeights k) :=\n  rfl\n\n"}
{"name":"Finset.sum_centroidWeightsIndicator","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\ninst✝¹ : DivisionRing k\nι : Type u_4\ns : Finset ι\ninst✝ : Fintype ι\n⊢ Eq (Finset.univ.sum fun i => Finset.centroidWeightsIndicator k s i) (s.sum fun i => Finset.centroidWeights k s i)","decl":"/-- The sum of the weights for the centroid indexed by a `Fintype`. -/\ntheorem sum_centroidWeightsIndicator [Fintype ι] :\n    ∑ i, s.centroidWeightsIndicator k i = ∑ i ∈ s, s.centroidWeights k i :=\n  sum_indicator_subset _ (subset_univ _)\n\n"}
{"name":"Finset.sum_centroidWeightsIndicator_eq_one_of_card_ne_zero","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\ninst✝² : DivisionRing k\nι : Type u_4\ns : Finset ι\ninst✝¹ : CharZero k\ninst✝ : Fintype ι\nh : Ne s.card 0\n⊢ Eq (Finset.univ.sum fun i => Finset.centroidWeightsIndicator k s i) 1","decl":"/-- In the characteristic zero case, the weights in the centroid\nindexed by a `Fintype` sum to 1 if the number of points is not\nzero. -/\ntheorem sum_centroidWeightsIndicator_eq_one_of_card_ne_zero [CharZero k] [Fintype ι]\n    (h : #s ≠ 0) : ∑ i, s.centroidWeightsIndicator k i = 1 := by\n  rw [sum_centroidWeightsIndicator]\n  exact s.sum_centroidWeights_eq_one_of_card_ne_zero k h\n\n"}
{"name":"Finset.sum_centroidWeightsIndicator_eq_one_of_nonempty","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\ninst✝² : DivisionRing k\nι : Type u_4\ns : Finset ι\ninst✝¹ : CharZero k\ninst✝ : Fintype ι\nh : s.Nonempty\n⊢ Eq (Finset.univ.sum fun i => Finset.centroidWeightsIndicator k s i) 1","decl":"/-- In the characteristic zero case, the weights in the centroid\nindexed by a `Fintype` sum to 1 if the set is nonempty. -/\ntheorem sum_centroidWeightsIndicator_eq_one_of_nonempty [CharZero k] [Fintype ι] (h : s.Nonempty) :\n    ∑ i, s.centroidWeightsIndicator k i = 1 := by\n  rw [sum_centroidWeightsIndicator]\n  exact s.sum_centroidWeights_eq_one_of_nonempty k h\n\n"}
{"name":"Finset.sum_centroidWeightsIndicator_eq_one_of_card_eq_add_one","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\ninst✝² : DivisionRing k\nι : Type u_4\ns : Finset ι\ninst✝¹ : CharZero k\ninst✝ : Fintype ι\nn : Nat\nh : Eq s.card (HAdd.hAdd n 1)\n⊢ Eq (Finset.univ.sum fun i => Finset.centroidWeightsIndicator k s i) 1","decl":"/-- In the characteristic zero case, the weights in the centroid\nindexed by a `Fintype` sum to 1 if the number of points is `n + 1`. -/\ntheorem sum_centroidWeightsIndicator_eq_one_of_card_eq_add_one [CharZero k] [Fintype ι] {n : ℕ}\n    (h : #s = n + 1) : ∑ i, s.centroidWeightsIndicator k i = 1 := by\n  rw [sum_centroidWeightsIndicator]\n  exact s.sum_centroidWeights_eq_one_of_card_eq_add_one k h\n\n"}
{"name":"Finset.centroid_eq_affineCombination_fintype","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁴ : DivisionRing k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\nι : Type u_4\ns : Finset ι\ninst✝ : Fintype ι\np : ι → P\n⊢ Eq (Finset.centroid k s p) ((Finset.affineCombination k Finset.univ p) (Finset.centroidWeightsIndicator k s))","decl":"/-- The centroid as an affine combination over a `Fintype`. -/\ntheorem centroid_eq_affineCombination_fintype [Fintype ι] (p : ι → P) :\n    s.centroid k p = univ.affineCombination k p (s.centroidWeightsIndicator k) :=\n  affineCombination_indicator_subset _ _ (subset_univ _)\n\n"}
{"name":"Finset.centroid_eq_centroid_image_of_inj_on","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁴ : DivisionRing k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\nι : Type u_4\ns : Finset ι\np : ι → P\nhi : ∀ (i : ι), Membership.mem s i → ∀ (j : ι), Membership.mem s j → Eq (p i) (p j) → Eq i j\nps : Set P\ninst✝ : Fintype ↑ps\nhps : Eq ps (Set.image p ↑s)\n⊢ Eq (Finset.centroid k s p) (Finset.centroid k Finset.univ fun x => ↑x)","decl":"/-- An indexed family of points that is injective on the given\n`Finset` has the same centroid as the image of that `Finset`.  This is\nstated in terms of a set equal to the image to provide control of\ndefinitional equality for the index type used for the centroid of the\nimage. -/\ntheorem centroid_eq_centroid_image_of_inj_on {p : ι → P}\n    (hi : ∀ i ∈ s, ∀ j ∈ s, p i = p j → i = j) {ps : Set P} [Fintype ps]\n    (hps : ps = p '' ↑s) : s.centroid k p = (univ : Finset ps).centroid k fun x => (x : P) := by\n  let f : p '' ↑s → ι := fun x => x.property.choose\n  have hf : ∀ x, f x ∈ s ∧ p (f x) = x := fun x => x.property.choose_spec\n  let f' : ps → ι := fun x => f ⟨x, hps ▸ x.property⟩\n  have hf' : ∀ x, f' x ∈ s ∧ p (f' x) = x := fun x => hf ⟨x, hps ▸ x.property⟩\n  have hf'i : Function.Injective f' := by\n    intro x y h\n    rw [Subtype.ext_iff, ← (hf' x).2, ← (hf' y).2, h]\n  let f'e : ps ↪ ι := ⟨f', hf'i⟩\n  have hu : Finset.univ.map f'e = s := by\n    ext x\n    rw [mem_map]\n    constructor\n    · rintro ⟨i, _, rfl⟩\n      exact (hf' i).1\n    · intro hx\n      use ⟨p x, hps.symm ▸ Set.mem_image_of_mem _ hx⟩, mem_univ _\n      refine hi _ (hf' _).1 _ hx ?_\n      rw [(hf' _).2]\n  rw [← hu, centroid_map]\n  congr with x\n  change p (f' x) = ↑x\n  rw [(hf' x).2]\n\n"}
{"name":"Finset.centroid_eq_of_inj_on_of_image_eq","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nι : Type u_4\ns : Finset ι\nι₂ : Type u_5\ns₂ : Finset ι₂\np : ι → P\nhi : ∀ (i : ι), Membership.mem s i → ∀ (j : ι), Membership.mem s j → Eq (p i) (p j) → Eq i j\np₂ : ι₂ → P\nhi₂ : ∀ (i : ι₂), Membership.mem s₂ i → ∀ (j : ι₂), Membership.mem s₂ j → Eq (p₂ i) (p₂ j) → Eq i j\nhe : Eq (Set.image p ↑s) (Set.image p₂ ↑s₂)\n⊢ Eq (Finset.centroid k s p) (Finset.centroid k s₂ p₂)","decl":"/-- Two indexed families of points that are injective on the given\n`Finset`s and with the same points in the image of those `Finset`s\nhave the same centroid. -/\ntheorem centroid_eq_of_inj_on_of_image_eq {p : ι → P}\n    (hi : ∀ i ∈ s, ∀ j ∈ s, p i = p j → i = j) {p₂ : ι₂ → P}\n    (hi₂ : ∀ i ∈ s₂, ∀ j ∈ s₂, p₂ i = p₂ j → i = j) (he : p '' ↑s = p₂ '' ↑s₂) :\n    s.centroid k p = s₂.centroid k p₂ := by\n  classical rw [s.centroid_eq_centroid_image_of_inj_on k hi rfl,\n      s₂.centroid_eq_centroid_image_of_inj_on k hi₂ he]\n\n"}
{"name":"weightedVSub_mem_vectorSpan","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"ι : Type u_1\nk : Type u_2\nV : Type u_3\nP : Type u_4\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Finset ι\nw : ι → k\nh : Eq (s.sum fun i => w i) 0\np : ι → P\n⊢ Membership.mem (vectorSpan k (Set.range p)) ((s.weightedVSub p) w)","decl":"/-- A `weightedVSub` with sum of weights 0 is in the `vectorSpan` of\nan indexed family. -/\ntheorem weightedVSub_mem_vectorSpan {s : Finset ι} {w : ι → k} (h : ∑ i ∈ s, w i = 0)\n    (p : ι → P) : s.weightedVSub p w ∈ vectorSpan k (Set.range p) := by\n  classical\n    rcases isEmpty_or_nonempty ι with (hι | ⟨⟨i0⟩⟩)\n    · simp [Finset.eq_empty_of_isEmpty s]\n    · rw [vectorSpan_range_eq_span_range_vsub_right k p i0, ← Set.image_univ,\n        Finsupp.mem_span_image_iff_linearCombination,\n        Finset.weightedVSub_eq_weightedVSubOfPoint_of_sum_eq_zero s w p h (p i0),\n        Finset.weightedVSubOfPoint_apply]\n      let w' := Set.indicator (↑s) w\n      have hwx : ∀ i, w' i ≠ 0 → i ∈ s := fun i => Set.mem_of_indicator_ne_zero\n      use Finsupp.onFinset s w' hwx, Set.subset_univ _\n      rw [Finsupp.linearCombination_apply, Finsupp.onFinset_sum hwx]\n      · apply Finset.sum_congr rfl\n        intro i hi\n        simp [w', Set.indicator_apply, if_pos hi]\n      · exact fun _ => zero_smul k _\n\n"}
{"name":"affineCombination_mem_affineSpan","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"ι : Type u_1\nk : Type u_2\nV : Type u_3\nP : Type u_4\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ninst✝ : Nontrivial k\ns : Finset ι\nw : ι → k\nh : Eq (s.sum fun i => w i) 1\np : ι → P\n⊢ Membership.mem (affineSpan k (Set.range p)) ((Finset.affineCombination k s p) w)","decl":"/-- An `affineCombination` with sum of weights 1 is in the\n`affineSpan` of an indexed family, if the underlying ring is\nnontrivial. -/\ntheorem affineCombination_mem_affineSpan [Nontrivial k] {s : Finset ι} {w : ι → k}\n    (h : ∑ i ∈ s, w i = 1) (p : ι → P) :\n    s.affineCombination k p w ∈ affineSpan k (Set.range p) := by\n  classical\n    have hnz : ∑ i ∈ s, w i ≠ 0 := h.symm ▸ one_ne_zero\n    have hn : s.Nonempty := Finset.nonempty_of_sum_ne_zero hnz\n    cases' hn with i1 hi1\n    let w1 : ι → k := Function.update (Function.const ι 0) i1 1\n    have hw1 : ∑ i ∈ s, w1 i = 1 := by\n      simp only [w1, Function.const_zero, Finset.sum_update_of_mem hi1, Pi.zero_apply,\n          Finset.sum_const_zero, add_zero]\n    have hw1s : s.affineCombination k p w1 = p i1 :=\n      s.affineCombination_of_eq_one_of_eq_zero w1 p hi1 (Function.update_self ..) fun _ _ hne =>\n        Function.update_of_ne hne ..\n    have hv : s.affineCombination k p w -ᵥ p i1 ∈ (affineSpan k (Set.range p)).direction := by\n      rw [direction_affineSpan, ← hw1s, Finset.affineCombination_vsub]\n      apply weightedVSub_mem_vectorSpan\n      simp [Pi.sub_apply, h, hw1]\n    rw [← vsub_vadd (s.affineCombination k p w) (p i1)]\n    exact AffineSubspace.vadd_mem_of_mem_direction hv (mem_affineSpan k (Set.mem_range_self _))\n\n"}
{"name":"mem_vectorSpan_iff_eq_weightedVSub","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"ι : Type u_1\nk : Type u_2\nV : Type u_3\nP : Type u_4\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nv : V\np : ι → P\n⊢ Iff (Membership.mem (vectorSpan k (Set.range p)) v) (Exists fun s => Exists fun w => And (Eq (s.sum fun i => w i) 0) (Eq v ((s.weightedVSub p) w)))","decl":"/-- A vector is in the `vectorSpan` of an indexed family if and only\nif it is a `weightedVSub` with sum of weights 0. -/\ntheorem mem_vectorSpan_iff_eq_weightedVSub {v : V} {p : ι → P} :\n    v ∈ vectorSpan k (Set.range p) ↔\n      ∃ (s : Finset ι) (w : ι → k), ∑ i ∈ s, w i = 0 ∧ v = s.weightedVSub p w := by\n  classical\n    constructor\n    · rcases isEmpty_or_nonempty ι with (hι | ⟨⟨i0⟩⟩)\n      swap\n      · rw [vectorSpan_range_eq_span_range_vsub_right k p i0, ← Set.image_univ,\n          Finsupp.mem_span_image_iff_linearCombination]\n        rintro ⟨l, _, hv⟩\n        use insert i0 l.support\n        set w :=\n          (l : ι → k) - Function.update (Function.const ι 0 : ι → k) i0 (∑ i ∈ l.support, l i) with\n          hwdef\n        use w\n        have hw : ∑ i ∈ insert i0 l.support, w i = 0 := by\n          rw [hwdef]\n          simp_rw [Pi.sub_apply, Finset.sum_sub_distrib,\n            Finset.sum_update_of_mem (Finset.mem_insert_self _ _),\n            Finset.sum_insert_of_eq_zero_if_not_mem Finsupp.not_mem_support_iff.1]\n          simp only [Finsupp.mem_support_iff, ne_eq, Finset.mem_insert, true_or, not_true,\n            Function.const_apply, Finset.sum_const_zero, add_zero, sub_self]\n        use hw\n        have hz : w i0 • (p i0 -ᵥ p i0 : V) = 0 := (vsub_self (p i0)).symm ▸ smul_zero _\n        change (fun i => w i • (p i -ᵥ p i0 : V)) i0 = 0 at hz\n        rw [Finset.weightedVSub_eq_weightedVSubOfPoint_of_sum_eq_zero _ w p hw (p i0),\n          Finset.weightedVSubOfPoint_apply, ← hv, Finsupp.linearCombination_apply,\n          @Finset.sum_insert_zero _ _ l.support i0 _ _ _ hz]\n        change (∑ i ∈ l.support, l i • _) = _\n        congr with i\n        by_cases h : i = i0\n        · simp [h]\n        · simp [hwdef, h]\n      · rw [Set.range_eq_empty, vectorSpan_empty, Submodule.mem_bot]\n        rintro rfl\n        use ∅\n        simp\n    · rintro ⟨s, w, hw, rfl⟩\n      exact weightedVSub_mem_vectorSpan hw p\n\n"}
{"name":"eq_affineCombination_of_mem_affineSpan","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"ι : Type u_1\nk : Type u_2\nV : Type u_3\nP : Type u_4\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np1 : P\np : ι → P\nh : Membership.mem (affineSpan k (Set.range p)) p1\n⊢ Exists fun s => Exists fun w => And (Eq (s.sum fun i => w i) 1) (Eq p1 ((Finset.affineCombination k s p) w))","decl":"/-- A point in the `affineSpan` of an indexed family is an\n`affineCombination` with sum of weights 1. See also\n`eq_affineCombination_of_mem_affineSpan_of_fintype`. -/\ntheorem eq_affineCombination_of_mem_affineSpan {p1 : P} {p : ι → P}\n    (h : p1 ∈ affineSpan k (Set.range p)) :\n    ∃ (s : Finset ι) (w : ι → k), ∑ i ∈ s, w i = 1 ∧ p1 = s.affineCombination k p w := by\n  classical\n    have hn : (affineSpan k (Set.range p) : Set P).Nonempty := ⟨p1, h⟩\n    rw [affineSpan_nonempty, Set.range_nonempty_iff_nonempty] at hn\n    cases' hn with i0\n    have h0 : p i0 ∈ affineSpan k (Set.range p) := mem_affineSpan k (Set.mem_range_self i0)\n    have hd : p1 -ᵥ p i0 ∈ (affineSpan k (Set.range p)).direction :=\n      AffineSubspace.vsub_mem_direction h h0\n    rw [direction_affineSpan, mem_vectorSpan_iff_eq_weightedVSub] at hd\n    rcases hd with ⟨s, w, h, hs⟩\n    let s' := insert i0 s\n    let w' := Set.indicator (↑s) w\n    have h' : ∑ i ∈ s', w' i = 0 := by\n      rw [← h, Finset.sum_indicator_subset _ (Finset.subset_insert i0 s)]\n    have hs' : s'.weightedVSub p w' = p1 -ᵥ p i0 := by\n      rw [hs]\n      exact (Finset.weightedVSub_indicator_subset _ _ (Finset.subset_insert i0 s)).symm\n    let w0 : ι → k := Function.update (Function.const ι 0) i0 1\n    have hw0 : ∑ i ∈ s', w0 i = 1 := by\n      rw [Finset.sum_update_of_mem (Finset.mem_insert_self _ _)]\n      simp only [Finset.mem_insert, true_or, not_true, Function.const_apply, Finset.sum_const_zero,\n        add_zero]\n    have hw0s : s'.affineCombination k p w0 = p i0 :=\n      s'.affineCombination_of_eq_one_of_eq_zero w0 p (Finset.mem_insert_self _ _)\n        (Function.update_self ..) fun _ _ hne => Function.update_of_ne hne _ _\n    refine ⟨s', w0 + w', ?_, ?_⟩\n    · simp [Pi.add_apply, Finset.sum_add_distrib, hw0, h']\n    · rw [add_comm, ← Finset.weightedVSub_vadd_affineCombination, hw0s, hs', vsub_vadd]\n\n"}
{"name":"eq_affineCombination_of_mem_affineSpan_of_fintype","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"ι : Type u_1\nk : Type u_2\nV : Type u_3\nP : Type u_4\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ninst✝ : Fintype ι\np1 : P\np : ι → P\nh : Membership.mem (affineSpan k (Set.range p)) p1\n⊢ Exists fun w => And (Eq (Finset.univ.sum fun i => w i) 1) (Eq p1 ((Finset.affineCombination k Finset.univ p) w))","decl":"theorem eq_affineCombination_of_mem_affineSpan_of_fintype [Fintype ι] {p1 : P} {p : ι → P}\n    (h : p1 ∈ affineSpan k (Set.range p)) :\n    ∃ w : ι → k, ∑ i, w i = 1 ∧ p1 = Finset.univ.affineCombination k p w := by\n  classical\n    obtain ⟨s, w, hw, rfl⟩ := eq_affineCombination_of_mem_affineSpan h\n    refine\n      ⟨(s : Set ι).indicator w, ?_, Finset.affineCombination_indicator_subset w p s.subset_univ⟩\n    simp only [Finset.mem_coe, Set.indicator_apply, ← hw]\n    rw [Fintype.sum_extend_by_zero s w]\n\n"}
{"name":"mem_affineSpan_iff_eq_affineCombination","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"ι : Type u_1\nk : Type u_2\nV : Type u_3\nP : Type u_4\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ninst✝ : Nontrivial k\np1 : P\np : ι → P\n⊢ Iff (Membership.mem (affineSpan k (Set.range p)) p1) (Exists fun s => Exists fun w => And (Eq (s.sum fun i => w i) 1) (Eq p1 ((Finset.affineCombination k s p) w)))","decl":"/-- A point is in the `affineSpan` of an indexed family if and only\nif it is an `affineCombination` with sum of weights 1, provided the\nunderlying ring is nontrivial. -/\ntheorem mem_affineSpan_iff_eq_affineCombination [Nontrivial k] {p1 : P} {p : ι → P} :\n    p1 ∈ affineSpan k (Set.range p) ↔\n      ∃ (s : Finset ι) (w : ι → k), ∑ i ∈ s, w i = 1 ∧ p1 = s.affineCombination k p w := by\n  constructor\n  · exact eq_affineCombination_of_mem_affineSpan\n  · rintro ⟨s, w, hw, rfl⟩\n    exact affineCombination_mem_affineSpan hw p\n\n"}
{"name":"mem_affineSpan_iff_eq_weightedVSubOfPoint_vadd","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"ι : Type u_1\nk : Type u_2\nV : Type u_3\nP : Type u_4\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ninst✝ : Nontrivial k\np : ι → P\nj : ι\nq : P\n⊢ Iff (Membership.mem (affineSpan k (Set.range p)) q) (Exists fun s => Exists fun w => Eq q (HVAdd.hVAdd ((s.weightedVSubOfPoint p (p j)) w) (p j)))","decl":"/-- Given a family of points together with a chosen base point in that family, membership of the\naffine span of this family corresponds to an identity in terms of `weightedVSubOfPoint`, with\nweights that are not required to sum to 1. -/\ntheorem mem_affineSpan_iff_eq_weightedVSubOfPoint_vadd [Nontrivial k] (p : ι → P) (j : ι) (q : P) :\n    q ∈ affineSpan k (Set.range p) ↔\n      ∃ (s : Finset ι) (w : ι → k), q = s.weightedVSubOfPoint p (p j) w +ᵥ p j := by\n  constructor\n  · intro hq\n    obtain ⟨s, w, hw, rfl⟩ := eq_affineCombination_of_mem_affineSpan hq\n    exact ⟨s, w, s.affineCombination_eq_weightedVSubOfPoint_vadd_of_sum_eq_one w p hw (p j)⟩\n  · rintro ⟨s, w, rfl⟩\n    classical\n      let w' : ι → k := Function.update w j (1 - (s \\ {j}).sum w)\n      have h₁ : (insert j s).sum w' = 1 := by\n        by_cases hj : j ∈ s\n        · simp [w', Finset.sum_update_of_mem hj, Finset.insert_eq_of_mem hj]\n        · simp [w', Finset.sum_insert hj, Finset.sum_update_of_not_mem hj, hj]\n      have hww : ∀ i, i ≠ j → w i = w' i := by\n        intro i hij\n        simp [w', hij]\n      rw [s.weightedVSubOfPoint_eq_of_weights_eq p j w w' hww, ←\n        s.weightedVSubOfPoint_insert w' p j, ←\n        (insert j s).affineCombination_eq_weightedVSubOfPoint_vadd_of_sum_eq_one w' p h₁ (p j)]\n      exact affineCombination_mem_affineSpan h₁ p\n\n"}
{"name":"affineSpan_eq_affineSpan_lineMap_units","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_2\nV : Type u_3\nP : Type u_4\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ninst✝ : Nontrivial k\ns : Set P\np : P\nhp : Membership.mem s p\nw : ↑s → Units k\n⊢ Eq (affineSpan k (Set.range fun q => (AffineMap.lineMap p ↑q) ↑(w q))) (affineSpan k s)","decl":"/-- Given a set of points, together with a chosen base point in this set, if we affinely transport\nall other members of the set along the line joining them to this base point, the affine span is\nunchanged. -/\ntheorem affineSpan_eq_affineSpan_lineMap_units [Nontrivial k] {s : Set P} {p : P} (hp : p ∈ s)\n    (w : s → Units k) :\n    affineSpan k (Set.range fun q : s => AffineMap.lineMap p ↑q (w q : k)) = affineSpan k s := by\n  have : s = Set.range ((↑) : s → P) := by simp\n  conv_rhs =>\n    rw [this]\n\n  apply le_antisymm\n    <;> intro q hq\n    <;> erw [mem_affineSpan_iff_eq_weightedVSubOfPoint_vadd k V _ (⟨p, hp⟩ : s) q] at hq ⊢\n    <;> obtain ⟨t, μ, rfl⟩ := hq\n    <;> use t\n    <;> [use fun x => μ x * ↑(w x); use fun x => μ x * ↑(w x)⁻¹]\n    <;> simp [smul_smul]\n\n"}
{"name":"centroid_mem_affineSpan_of_cast_card_ne_zero","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nι : Type u_4\ns : Finset ι\np : ι → P\nh : Ne (↑s.card) 0\n⊢ Membership.mem (affineSpan k (Set.range p)) (Finset.centroid k s p)","decl":"/-- The centroid lies in the affine span if the number of points,\nconverted to `k`, is not zero. -/\ntheorem centroid_mem_affineSpan_of_cast_card_ne_zero {s : Finset ι} (p : ι → P)\n    (h : (#s : k) ≠ 0) : s.centroid k p ∈ affineSpan k (range p) :=\n  affineCombination_mem_affineSpan (s.sum_centroidWeights_eq_one_of_cast_card_ne_zero h) p\n\n"}
{"name":"centroid_mem_affineSpan_of_card_ne_zero","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁴ : DivisionRing k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\nι : Type u_4\ninst✝ : CharZero k\ns : Finset ι\np : ι → P\nh : Ne s.card 0\n⊢ Membership.mem (affineSpan k (Set.range p)) (Finset.centroid k s p)","decl":"/-- In the characteristic zero case, the centroid lies in the affine\nspan if the number of points is not zero. -/\ntheorem centroid_mem_affineSpan_of_card_ne_zero [CharZero k] {s : Finset ι} (p : ι → P)\n    (h : #s ≠ 0) : s.centroid k p ∈ affineSpan k (range p) :=\n  affineCombination_mem_affineSpan (s.sum_centroidWeights_eq_one_of_card_ne_zero k h) p\n\n"}
{"name":"centroid_mem_affineSpan_of_nonempty","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁴ : DivisionRing k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\nι : Type u_4\ninst✝ : CharZero k\ns : Finset ι\np : ι → P\nh : s.Nonempty\n⊢ Membership.mem (affineSpan k (Set.range p)) (Finset.centroid k s p)","decl":"/-- In the characteristic zero case, the centroid lies in the affine\nspan if the set is nonempty. -/\ntheorem centroid_mem_affineSpan_of_nonempty [CharZero k] {s : Finset ι} (p : ι → P)\n    (h : s.Nonempty) : s.centroid k p ∈ affineSpan k (range p) :=\n  affineCombination_mem_affineSpan (s.sum_centroidWeights_eq_one_of_nonempty k h) p\n\n"}
{"name":"centroid_mem_affineSpan_of_card_eq_add_one","module":"Mathlib.LinearAlgebra.AffineSpace.Combination","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁴ : DivisionRing k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\nι : Type u_4\ninst✝ : CharZero k\ns : Finset ι\np : ι → P\nn : Nat\nh : Eq s.card (HAdd.hAdd n 1)\n⊢ Membership.mem (affineSpan k (Set.range p)) (Finset.centroid k s p)","decl":"/-- In the characteristic zero case, the centroid lies in the affine\nspan if the number of points is `n + 1`. -/\ntheorem centroid_mem_affineSpan_of_card_eq_add_one [CharZero k] {s : Finset ι} (p : ι → P) {n : ℕ}\n    (h : #s = n + 1) : s.centroid k p ∈ affineSpan k (range p) :=\n  affineCombination_mem_affineSpan (s.sum_centroidWeights_eq_one_of_card_eq_add_one k h) p\n\n"}
