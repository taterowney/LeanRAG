{"name":"IsLocalization.flat","module":"Mathlib.RingTheory.Flat.Localization","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommSemiring R\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\np : Submonoid R\ninst✝ : IsLocalization p S\n⊢ Module.Flat R S","decl":"include p in\ntheorem IsLocalization.flat : Module.Flat R S := by\n  refine Module.Flat.iff_lTensor_injectiveₛ.mpr fun P _ _ N ↦ ?_\n  have h := ((range N.subtype).isLocalizedModule S p (TensorProduct.mk R S P 1)).isBaseChange _ S\n  let e := (LinearEquiv.ofInjective _ Subtype.val_injective).lTensor S ≪≫ₗ h.equiv.restrictScalars R\n  have : N.subtype.lTensor S = Submodule.subtype _ ∘ₗ e.toLinearMap := by\n    ext; show _ = (h.equiv _).1; simp [h.equiv_tmul, TensorProduct.smul_tmul']\n  simpa [this] using e.injective\n\n"}
{"name":"Localization.flat","module":"Mathlib.RingTheory.Flat.Localization","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\np : Submonoid R\n⊢ Module.Flat R (Localization p)","decl":"instance Localization.flat : Module.Flat R (Localization p) := IsLocalization.flat _ p\n\n"}
{"name":"Module.flat_iff_of_isLocalization","module":"Mathlib.RingTheory.Flat.Localization","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁷ : CommSemiring R\ninst✝⁶ : CommSemiring S\ninst✝⁵ : Algebra R S\np : Submonoid R\ninst✝⁴ : IsLocalization p S\nM : Type u_3\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module S M\ninst✝ : IsScalarTower R S M\n⊢ Iff (Module.Flat S M) (Module.Flat R M)","decl":"include p in\ntheorem flat_iff_of_isLocalization : Flat S M ↔ Flat R M :=\n  have := isLocalizedModule_id p M S\n  have := IsLocalization.flat S p\n  ⟨fun _ ↦ .trans R S M, fun _ ↦ .of_isLocalizedModule S p .id⟩\n\n"}
{"name":"Module.flat_of_isLocalized_maximal","module":"Mathlib.RingTheory.Flat.Localization","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹¹ : CommSemiring R\ninst✝¹⁰ : CommSemiring S\ninst✝⁹ : Algebra R S\nM : Type u_3\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : Module R M\ninst✝⁶ : Module S M\ninst✝⁵ : IsScalarTower R S M\nMₚ : (P : Ideal S) → [inst : P.IsMaximal] → Type u_4\ninst✝⁴ : (P : Ideal S) → [inst : P.IsMaximal] → AddCommMonoid (Mₚ P)\ninst✝³ : (P : Ideal S) → [inst : P.IsMaximal] → Module R (Mₚ P)\ninst✝² : (P : Ideal S) → [inst : P.IsMaximal] → Module S (Mₚ P)\ninst✝¹ : ∀ (P : Ideal S) [inst : P.IsMaximal], IsScalarTower R S (Mₚ P)\nf : (P : Ideal S) → [inst : P.IsMaximal] → LinearMap (RingHom.id S) M (Mₚ P)\ninst✝ : ∀ (P : Ideal S) [inst : P.IsMaximal], IsLocalizedModule P.primeCompl (f P)\nH : ∀ (P : Ideal S) [inst : P.IsMaximal], Module.Flat R (Mₚ P)\n⊢ Module.Flat R M","decl":"include f in\ntheorem flat_of_isLocalized_maximal (H : ∀ (P : Ideal S) [P.IsMaximal], Flat R (Mₚ P)) :\n    Module.Flat R M := by\n  simp_rw [Flat.iff_lTensor_injectiveₛ] at H ⊢\n  simp_rw [← AlgebraTensorModule.coe_lTensor (A := S)]\n  refine fun _ _ _ N ↦ injective_of_isLocalized_maximal _\n    (fun P ↦ AlgebraTensorModule.rTensor R _ (f P)) _\n    (fun P ↦ AlgebraTensorModule.rTensor R _ (f P)) _ fun P hP ↦ ?_\n  simpa [IsLocalizedModule.map_lTensor] using H P N\n\n"}
{"name":"Module.flat_of_localized_maximal","module":"Mathlib.RingTheory.Flat.Localization","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nh : ∀ (P : Ideal R) [inst : P.IsMaximal], Module.Flat R (LocalizedModule P.primeCompl M)\n⊢ Module.Flat R M","decl":"theorem flat_of_localized_maximal\n    (h : ∀ (P : Ideal R) [P.IsMaximal], Flat R (LocalizedModule P.primeCompl M)) :\n    Flat R M :=\n  flat_of_isLocalized_maximal _ _ _ (fun _ _ ↦ mkLinearMap _ _) h\n\n"}
{"name":"Module.flat_of_isLocalized_span","module":"Mathlib.RingTheory.Flat.Localization","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹¹ : CommSemiring R\ninst✝¹⁰ : CommSemiring S\ninst✝⁹ : Algebra R S\nM : Type u_3\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : Module R M\ninst✝⁶ : Module S M\ninst✝⁵ : IsScalarTower R S M\ns : Set S\nspn : Eq (Ideal.span s) Top.top\nMₛ : ↑s → Type u_5\ninst✝⁴ : (r : ↑s) → AddCommMonoid (Mₛ r)\ninst✝³ : (r : ↑s) → Module R (Mₛ r)\ninst✝² : (r : ↑s) → Module S (Mₛ r)\ninst✝¹ : ∀ (r : ↑s), IsScalarTower R S (Mₛ r)\ng : (r : ↑s) → LinearMap (RingHom.id S) M (Mₛ r)\ninst✝ : ∀ (r : ↑s), IsLocalizedModule (Submonoid.powers ↑r) (g r)\nH : ∀ (r : ↑s), Module.Flat R (Mₛ r)\n⊢ Module.Flat R M","decl":"include g in\ntheorem flat_of_isLocalized_span (H : ∀ r : s, Module.Flat R (Mₛ r)) :\n    Module.Flat R M := by\n  simp_rw [Flat.iff_lTensor_injectiveₛ] at H ⊢\n  simp_rw [← AlgebraTensorModule.coe_lTensor (A := S)]\n  refine fun _ _ _ N ↦ injective_of_isLocalized_span s spn _\n    (fun r ↦ AlgebraTensorModule.rTensor R _ (g r)) _\n    (fun r ↦ AlgebraTensorModule.rTensor R _ (g r)) _ fun r ↦ ?_\n  simpa [IsLocalizedModule.map_lTensor] using H r N\n\n"}
{"name":"Module.flat_of_localized_span","module":"Mathlib.RingTheory.Flat.Localization","initialProofState":"S : Type u_2\ninst✝² : CommSemiring S\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : Module S M\ns : Set S\nspn : Eq (Ideal.span s) Top.top\nh : ∀ (r : ↑s), Module.Flat S (LocalizedModule (Submonoid.powers ↑r) M)\n⊢ Module.Flat S M","decl":"theorem flat_of_localized_span\n    (h : ∀ r : s, Flat S (LocalizedModule (.powers r.1) M)) :\n    Flat S M :=\n  flat_of_isLocalized_span _ _ _ spn _ (fun _ ↦ mkLinearMap _ _) h\n\n"}
