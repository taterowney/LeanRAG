{"name":"RingSubgroupsBasis.inter","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"A : Type u_1\nŒπ : Type u_2\ninst‚úù : Ring A\nB : Œπ ‚Üí AddSubgroup A\nself : RingSubgroupsBasis B\ni j : Œπ\n‚ä¢ Exists fun k => LE.le (B k) (Min.min (B i) (B j))","decl":"/-- A family of additive subgroups on a ring `A` is a subgroups basis if it satisfies some\naxioms ensuring there is a topology on `A` which is compatible with the ring structure and\nadmits this family as a basis of neighborhoods of zero. -/\nstructure RingSubgroupsBasis {A Œπ : Type*} [Ring A] (B : Œπ ‚Üí AddSubgroup A) : Prop where\n  /-- Condition for `B` to be a filter basis on `A`. -/\n  inter : ‚àÄ i j, ‚àÉ k, B k ‚â§ B i ‚äì B j\n  /-- For each set `B` in the submodule basis on `A`, there is another basis element `B'` such\n   that the set-theoretic product `B' * B'` is in `B`. -/\n  mul : ‚àÄ i, ‚àÉ j, (B j : Set A) * B j ‚äÜ B i\n  /-- For any element `x : A` and any set `B` in the submodule basis on `A`,\n    there is another basis element `B'` such that `B' * x` is in `B`. -/\n  leftMul : ‚àÄ x : A, ‚àÄ i, ‚àÉ j, (B j : Set A) ‚äÜ (x * ¬∑) ‚Åª¬π' B i\n  /-- For any element `x : A` and any set `B` in the submodule basis on `A`,\n    there is another basis element `B'` such that `x * B'` is in `B`. -/\n  rightMul : ‚àÄ x : A, ‚àÄ i, ‚àÉ j, (B j : Set A) ‚äÜ (¬∑ * x) ‚Åª¬π' B i\n\n"}
{"name":"RingSubgroupsBasis.mul","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"A : Type u_1\nŒπ : Type u_2\ninst‚úù : Ring A\nB : Œπ ‚Üí AddSubgroup A\nself : RingSubgroupsBasis B\ni : Œπ\n‚ä¢ Exists fun j => HasSubset.Subset (HMul.hMul ‚Üë(B j) ‚Üë(B j)) ‚Üë(B i)","decl":"/-- A family of additive subgroups on a ring `A` is a subgroups basis if it satisfies some\naxioms ensuring there is a topology on `A` which is compatible with the ring structure and\nadmits this family as a basis of neighborhoods of zero. -/\nstructure RingSubgroupsBasis {A Œπ : Type*} [Ring A] (B : Œπ ‚Üí AddSubgroup A) : Prop where\n  /-- Condition for `B` to be a filter basis on `A`. -/\n  inter : ‚àÄ i j, ‚àÉ k, B k ‚â§ B i ‚äì B j\n  /-- For each set `B` in the submodule basis on `A`, there is another basis element `B'` such\n   that the set-theoretic product `B' * B'` is in `B`. -/\n  mul : ‚àÄ i, ‚àÉ j, (B j : Set A) * B j ‚äÜ B i\n  /-- For any element `x : A` and any set `B` in the submodule basis on `A`,\n    there is another basis element `B'` such that `B' * x` is in `B`. -/\n  leftMul : ‚àÄ x : A, ‚àÄ i, ‚àÉ j, (B j : Set A) ‚äÜ (x * ¬∑) ‚Åª¬π' B i\n  /-- For any element `x : A` and any set `B` in the submodule basis on `A`,\n    there is another basis element `B'` such that `x * B'` is in `B`. -/\n  rightMul : ‚àÄ x : A, ‚àÄ i, ‚àÉ j, (B j : Set A) ‚äÜ (¬∑ * x) ‚Åª¬π' B i\n\n"}
{"name":"RingSubgroupsBasis.rightMul","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"A : Type u_1\nŒπ : Type u_2\ninst‚úù : Ring A\nB : Œπ ‚Üí AddSubgroup A\nself : RingSubgroupsBasis B\nx : A\ni : Œπ\n‚ä¢ Exists fun j => HasSubset.Subset (‚Üë(B j)) (Set.preimage (fun x_1 => HMul.hMul x_1 x) ‚Üë(B i))","decl":"/-- A family of additive subgroups on a ring `A` is a subgroups basis if it satisfies some\naxioms ensuring there is a topology on `A` which is compatible with the ring structure and\nadmits this family as a basis of neighborhoods of zero. -/\nstructure RingSubgroupsBasis {A Œπ : Type*} [Ring A] (B : Œπ ‚Üí AddSubgroup A) : Prop where\n  /-- Condition for `B` to be a filter basis on `A`. -/\n  inter : ‚àÄ i j, ‚àÉ k, B k ‚â§ B i ‚äì B j\n  /-- For each set `B` in the submodule basis on `A`, there is another basis element `B'` such\n   that the set-theoretic product `B' * B'` is in `B`. -/\n  mul : ‚àÄ i, ‚àÉ j, (B j : Set A) * B j ‚äÜ B i\n  /-- For any element `x : A` and any set `B` in the submodule basis on `A`,\n    there is another basis element `B'` such that `B' * x` is in `B`. -/\n  leftMul : ‚àÄ x : A, ‚àÄ i, ‚àÉ j, (B j : Set A) ‚äÜ (x * ¬∑) ‚Åª¬π' B i\n  /-- For any element `x : A` and any set `B` in the submodule basis on `A`,\n    there is another basis element `B'` such that `x * B'` is in `B`. -/\n  rightMul : ‚àÄ x : A, ‚àÄ i, ‚àÉ j, (B j : Set A) ‚äÜ (¬∑ * x) ‚Åª¬π' B i\n\n"}
{"name":"RingSubgroupsBasis.leftMul","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"A : Type u_1\nŒπ : Type u_2\ninst‚úù : Ring A\nB : Œπ ‚Üí AddSubgroup A\nself : RingSubgroupsBasis B\nx : A\ni : Œπ\n‚ä¢ Exists fun j => HasSubset.Subset (‚Üë(B j)) (Set.preimage (fun x_1 => HMul.hMul x x_1) ‚Üë(B i))","decl":"/-- A family of additive subgroups on a ring `A` is a subgroups basis if it satisfies some\naxioms ensuring there is a topology on `A` which is compatible with the ring structure and\nadmits this family as a basis of neighborhoods of zero. -/\nstructure RingSubgroupsBasis {A Œπ : Type*} [Ring A] (B : Œπ ‚Üí AddSubgroup A) : Prop where\n  /-- Condition for `B` to be a filter basis on `A`. -/\n  inter : ‚àÄ i j, ‚àÉ k, B k ‚â§ B i ‚äì B j\n  /-- For each set `B` in the submodule basis on `A`, there is another basis element `B'` such\n   that the set-theoretic product `B' * B'` is in `B`. -/\n  mul : ‚àÄ i, ‚àÉ j, (B j : Set A) * B j ‚äÜ B i\n  /-- For any element `x : A` and any set `B` in the submodule basis on `A`,\n    there is another basis element `B'` such that `B' * x` is in `B`. -/\n  leftMul : ‚àÄ x : A, ‚àÄ i, ‚àÉ j, (B j : Set A) ‚äÜ (x * ¬∑) ‚Åª¬π' B i\n  /-- For any element `x : A` and any set `B` in the submodule basis on `A`,\n    there is another basis element `B'` such that `x * B'` is in `B`. -/\n  rightMul : ‚àÄ x : A, ‚àÄ i, ‚àÉ j, (B j : Set A) ‚äÜ (¬∑ * x) ‚Åª¬π' B i\n\n"}
{"name":"RingSubgroupsBasis.of_comm","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"A : Type u_3\nŒπ : Type u_4\ninst‚úù : CommRing A\nB : Œπ ‚Üí AddSubgroup A\ninter : ‚àÄ (i j : Œπ), Exists fun k => LE.le (B k) (Min.min (B i) (B j))\nmul : ‚àÄ (i : Œπ), Exists fun j => HasSubset.Subset (HMul.hMul ‚Üë(B j) ‚Üë(B j)) ‚Üë(B i)\nleftMul : ‚àÄ (x : A) (i : Œπ), Exists fun j => HasSubset.Subset (‚Üë(B j)) (Set.preimage (fun y => HMul.hMul x y) ‚Üë(B i))\n‚ä¢ RingSubgroupsBasis B","decl":"theorem of_comm {A Œπ : Type*} [CommRing A] (B : Œπ ‚Üí AddSubgroup A)\n    (inter : ‚àÄ i j, ‚àÉ k, B k ‚â§ B i ‚äì B j) (mul : ‚àÄ i, ‚àÉ j, (B j : Set A) * B j ‚äÜ B i)\n    (leftMul : ‚àÄ x : A, ‚àÄ i, ‚àÉ j, (B j : Set A) ‚äÜ (fun y : A => x * y) ‚Åª¬π' B i) :\n    RingSubgroupsBasis B :=\n  { inter\n    mul\n    leftMul\n    rightMul := fun x i ‚Ü¶ (leftMul x i).imp fun j hj ‚Ü¶ by simpa only [mul_comm] using hj }\n\n"}
{"name":"RingSubgroupsBasis.mem_addGroupFilterBasis_iff","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"A : Type u_1\nŒπ : Type u_2\ninst‚úù¬π : Ring A\ninst‚úù : Nonempty Œπ\nB : Œπ ‚Üí AddSubgroup A\nhB : RingSubgroupsBasis B\nV : Set A\n‚ä¢ Iff (Membership.mem RingFilterBasis.toAddGroupFilterBasis V) (Exists fun i => Eq V ‚Üë(B i))","decl":"theorem mem_addGroupFilterBasis_iff {V : Set A} :\n    V ‚àà hB.toRingFilterBasis.toAddGroupFilterBasis ‚Üî ‚àÉ i, V = B i :=\n  Iff.rfl\n\n"}
{"name":"RingSubgroupsBasis.mem_addGroupFilterBasis","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"A : Type u_1\nŒπ : Type u_2\ninst‚úù¬π : Ring A\ninst‚úù : Nonempty Œπ\nB : Œπ ‚Üí AddSubgroup A\nhB : RingSubgroupsBasis B\ni : Œπ\n‚ä¢ Membership.mem RingFilterBasis.toAddGroupFilterBasis ‚Üë(B i)","decl":"theorem mem_addGroupFilterBasis (i) : (B i : Set A) ‚àà hB.toRingFilterBasis.toAddGroupFilterBasis :=\n  ‚ü®i, rfl‚ü©\n\n"}
{"name":"RingSubgroupsBasis.hasBasis_nhds_zero","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"A : Type u_1\nŒπ : Type u_2\ninst‚úù¬π : Ring A\ninst‚úù : Nonempty Œπ\nB : Œπ ‚Üí AddSubgroup A\nhB : RingSubgroupsBasis B\n‚ä¢ (nhds 0).HasBasis (fun x => True) fun i => ‚Üë(B i)","decl":"theorem hasBasis_nhds_zero : HasBasis (@nhds A hB.topology 0) (fun _ => True) fun i => B i :=\n  ‚ü®by\n    intro s\n    rw [hB.toRingFilterBasis.toAddGroupFilterBasis.nhds_zero_hasBasis.mem_iff]\n    constructor\n    ¬∑ rintro ‚ü®-, ‚ü®i, rfl‚ü©, hi‚ü©\n      exact ‚ü®i, trivial, hi‚ü©\n    ¬∑ rintro ‚ü®i, -, hi‚ü©\n      exact ‚ü®B i, ‚ü®i, rfl‚ü©, hi‚ü©‚ü©\n\n"}
{"name":"RingSubgroupsBasis.hasBasis_nhds","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"A : Type u_1\nŒπ : Type u_2\ninst‚úù¬π : Ring A\ninst‚úù : Nonempty Œπ\nB : Œπ ‚Üí AddSubgroup A\nhB : RingSubgroupsBasis B\na : A\n‚ä¢ (nhds a).HasBasis (fun x => True) fun i => setOf fun b => Membership.mem (B i) (HSub.hSub b a)","decl":"theorem hasBasis_nhds (a : A) :\n    HasBasis (@nhds A hB.topology a) (fun _ => True) fun i => { b | b - a ‚àà B i } :=\n  ‚ü®by\n    intro s\n    rw [(hB.toRingFilterBasis.toAddGroupFilterBasis.nhds_hasBasis a).mem_iff]\n    simp only [true_and]\n    constructor\n    ¬∑ rintro ‚ü®-, ‚ü®i, rfl‚ü©, hi‚ü©\n      use i\n      suffices h : { b : A | b - a ‚àà B i } = (fun y => a + y) '' ‚Üë(B i) by\n        rw [h]\n        assumption\n      simp only [image_add_left, neg_add_eq_sub]\n      ext b\n      simp\n    ¬∑ rintro ‚ü®i, hi‚ü©\n      use B i\n      constructor\n      ¬∑ use i\n      ¬∑ rw [image_subset_iff]\n        rintro b b_in\n        apply hi\n        simpa using b_in‚ü©\n\n"}
{"name":"RingSubgroupsBasis.nonarchimedean","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"A : Type u_1\nŒπ : Type u_2\ninst‚úù¬π : Ring A\ninst‚úù : Nonempty Œπ\nB : Œπ ‚Üí AddSubgroup A\nhB : RingSubgroupsBasis B\n‚ä¢ NonarchimedeanRing A","decl":"theorem nonarchimedean : @NonarchimedeanRing A _ hB.topology := by\n  letI := hB.topology\n  constructor\n  intro U hU\n  obtain ‚ü®i, -, hi : (B i : Set A) ‚äÜ U‚ü© := hB.hasBasis_nhds_zero.mem_iff.mp hU\n  exact ‚ü®hB.openAddSubgroup i, hi‚ü©\n\n"}
{"name":"SubmodulesRingBasis.leftMul","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"Œπ : Type u_1\nR : Type u_2\nA : Type u_3\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : CommRing A\ninst‚úù : Algebra R A\nB : Œπ ‚Üí Submodule R A\nself : SubmodulesRingBasis B\na : A\ni : Œπ\n‚ä¢ Exists fun j => LE.le (HSMul.hSMul a (B j)) (B i)","decl":"/-- A family of submodules in a commutative `R`-algebra `A` is a submodules basis if it satisfies\nsome axioms ensuring there is a topology on `A` which is compatible with the ring structure and\nadmits this family as a basis of neighborhoods of zero. -/\nstructure SubmodulesRingBasis (B : Œπ ‚Üí Submodule R A) : Prop where\n  /-- Condition for `B` to be a filter basis on `A`. -/\n  inter : ‚àÄ i j, ‚àÉ k, B k ‚â§ B i ‚äì B j\n  /-- For any element `a : A` and any set `B` in the submodule basis on `A`,\n    there is another basis element `B'` such that `a ‚Ä¢ B'` is in `B`. -/\n  leftMul : ‚àÄ (a : A) (i), ‚àÉ j, a ‚Ä¢ B j ‚â§ B i\n  /-- For each set `B` in the submodule basis on `A`, there is another basis element `B'` such\n    that the set-theoretic product `B' * B'` is in `B`. -/\n  mul : ‚àÄ i, ‚àÉ j, (B j : Set A) * B j ‚äÜ B i\n\n"}
{"name":"SubmodulesRingBasis.inter","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"Œπ : Type u_1\nR : Type u_2\nA : Type u_3\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : CommRing A\ninst‚úù : Algebra R A\nB : Œπ ‚Üí Submodule R A\nself : SubmodulesRingBasis B\ni j : Œπ\n‚ä¢ Exists fun k => LE.le (B k) (Min.min (B i) (B j))","decl":"/-- A family of submodules in a commutative `R`-algebra `A` is a submodules basis if it satisfies\nsome axioms ensuring there is a topology on `A` which is compatible with the ring structure and\nadmits this family as a basis of neighborhoods of zero. -/\nstructure SubmodulesRingBasis (B : Œπ ‚Üí Submodule R A) : Prop where\n  /-- Condition for `B` to be a filter basis on `A`. -/\n  inter : ‚àÄ i j, ‚àÉ k, B k ‚â§ B i ‚äì B j\n  /-- For any element `a : A` and any set `B` in the submodule basis on `A`,\n    there is another basis element `B'` such that `a ‚Ä¢ B'` is in `B`. -/\n  leftMul : ‚àÄ (a : A) (i), ‚àÉ j, a ‚Ä¢ B j ‚â§ B i\n  /-- For each set `B` in the submodule basis on `A`, there is another basis element `B'` such\n    that the set-theoretic product `B' * B'` is in `B`. -/\n  mul : ‚àÄ i, ‚àÉ j, (B j : Set A) * B j ‚äÜ B i\n\n"}
{"name":"SubmodulesRingBasis.mul","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"Œπ : Type u_1\nR : Type u_2\nA : Type u_3\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : CommRing A\ninst‚úù : Algebra R A\nB : Œπ ‚Üí Submodule R A\nself : SubmodulesRingBasis B\ni : Œπ\n‚ä¢ Exists fun j => HasSubset.Subset (HMul.hMul ‚Üë(B j) ‚Üë(B j)) ‚Üë(B i)","decl":"/-- A family of submodules in a commutative `R`-algebra `A` is a submodules basis if it satisfies\nsome axioms ensuring there is a topology on `A` which is compatible with the ring structure and\nadmits this family as a basis of neighborhoods of zero. -/\nstructure SubmodulesRingBasis (B : Œπ ‚Üí Submodule R A) : Prop where\n  /-- Condition for `B` to be a filter basis on `A`. -/\n  inter : ‚àÄ i j, ‚àÉ k, B k ‚â§ B i ‚äì B j\n  /-- For any element `a : A` and any set `B` in the submodule basis on `A`,\n    there is another basis element `B'` such that `a ‚Ä¢ B'` is in `B`. -/\n  leftMul : ‚àÄ (a : A) (i), ‚àÉ j, a ‚Ä¢ B j ‚â§ B i\n  /-- For each set `B` in the submodule basis on `A`, there is another basis element `B'` such\n    that the set-theoretic product `B' * B'` is in `B`. -/\n  mul : ‚àÄ i, ‚àÉ j, (B j : Set A) * B j ‚äÜ B i\n\n"}
{"name":"SubmodulesRingBasis.toRing_subgroups_basis","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"Œπ : Type u_1\nR : Type u_2\nA : Type u_3\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : CommRing A\ninst‚úù : Algebra R A\nB : Œπ ‚Üí Submodule R A\nhB : SubmodulesRingBasis B\n‚ä¢ RingSubgroupsBasis fun i => (B i).toAddSubgroup","decl":"theorem toRing_subgroups_basis (hB : SubmodulesRingBasis B) :\n    RingSubgroupsBasis fun i => (B i).toAddSubgroup := by\n  apply RingSubgroupsBasis.of_comm (fun i => (B i).toAddSubgroup) hB.inter hB.mul\n  intro a i\n  rcases hB.leftMul a i with ‚ü®j, hj‚ü©\n  use j\n  rintro b (b_in : b ‚àà B j)\n  exact hj ‚ü®b, b_in, rfl‚ü©\n\n"}
{"name":"SubmodulesBasis.inter","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"Œπ : Type u_1\nR : Type u_2\ninst‚úù¬≥ : CommRing R\nM : Type u_4\ninst‚úù¬≤ : AddCommGroup M\ninst‚úù¬π : Module R M\ninst‚úù : TopologicalSpace R\nB : Œπ ‚Üí Submodule R M\nself : SubmodulesBasis B\ni j : Œπ\n‚ä¢ Exists fun k => LE.le (B k) (Min.min (B i) (B j))","decl":"/-- A family of submodules in an `R`-module `M` is a submodules basis if it satisfies\nsome axioms ensuring there is a topology on `M` which is compatible with the module structure and\nadmits this family as a basis of neighborhoods of zero. -/\nstructure SubmodulesBasis [TopologicalSpace R] (B : Œπ ‚Üí Submodule R M) : Prop where\n  /-- Condition for `B` to be a filter basis on `M`. -/\n  inter : ‚àÄ i j, ‚àÉ k, B k ‚â§ B i ‚äì B j\n  /-- For any element `m : M` and any set `B` in the basis, `a ‚Ä¢ m` lies in `B` for all\n    `a` sufficiently close to `0`. -/\n  smul : ‚àÄ (m : M) (i : Œπ), ‚àÄ·∂† a in ùìù (0 : R), a ‚Ä¢ m ‚àà B i\n\n"}
{"name":"SubmodulesBasis.smul","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"Œπ : Type u_1\nR : Type u_2\ninst‚úù¬≥ : CommRing R\nM : Type u_4\ninst‚úù¬≤ : AddCommGroup M\ninst‚úù¬π : Module R M\ninst‚úù : TopologicalSpace R\nB : Œπ ‚Üí Submodule R M\nself : SubmodulesBasis B\nm : M\ni : Œπ\n‚ä¢ Filter.Eventually (fun a => Membership.mem (B i) (HSMul.hSMul a m)) (nhds 0)","decl":"/-- A family of submodules in an `R`-module `M` is a submodules basis if it satisfies\nsome axioms ensuring there is a topology on `M` which is compatible with the module structure and\nadmits this family as a basis of neighborhoods of zero. -/\nstructure SubmodulesBasis [TopologicalSpace R] (B : Œπ ‚Üí Submodule R M) : Prop where\n  /-- Condition for `B` to be a filter basis on `M`. -/\n  inter : ‚àÄ i j, ‚àÉ k, B k ‚â§ B i ‚äì B j\n  /-- For any element `m : M` and any set `B` in the basis, `a ‚Ä¢ m` lies in `B` for all\n    `a` sufficiently close to `0`. -/\n  smul : ‚àÄ (m : M) (i : Œπ), ‚àÄ·∂† a in ùìù (0 : R), a ‚Ä¢ m ‚àà B i\n\n"}
{"name":"SubmodulesBasis.nonarchimedean","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"Œπ : Type u_1\nR : Type u_2\ninst‚úù‚Å¥ : CommRing R\nM : Type u_4\ninst‚úù¬≥ : AddCommGroup M\ninst‚úù¬≤ : Module R M\ninst‚úù¬π : TopologicalSpace R\ninst‚úù : Nonempty Œπ\nB : Œπ ‚Üí Submodule R M\nhB : SubmodulesBasis B\n‚ä¢ NonarchimedeanAddGroup M","decl":"theorem nonarchimedean (hB : SubmodulesBasis B) : @NonarchimedeanAddGroup M _ hB.topology := by\n  letI := hB.topology\n  constructor\n  intro U hU\n  obtain ‚ü®-, ‚ü®i, rfl‚ü©, hi : (B i : Set M) ‚äÜ U‚ü© :=\n    hB.toModuleFilterBasis.toAddGroupFilterBasis.nhds_zero_hasBasis.mem_iff.mp hU\n  exact ‚ü®hB.openAddSubgroup i, hi‚ü©\n\n"}
{"name":"SubmodulesRingBasis.toSubmodulesBasis","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"Œπ : Type u_1\nR : Type u_2\nA : Type u_3\ninst‚úù¬≥ : CommRing R\ninst‚úù¬≤ : CommRing A\ninst‚úù¬π : Algebra R A\ninst‚úù : TopologicalSpace R\nB : Œπ ‚Üí Submodule R A\nhB : SubmodulesRingBasis B\nhsmul : ‚àÄ (m : A) (i : Œπ), Filter.Eventually (fun a => Membership.mem (B i) (HSMul.hSMul a m)) (nhds 0)\n‚ä¢ SubmodulesBasis B","decl":"theorem SubmodulesRingBasis.toSubmodulesBasis : SubmodulesBasis B :=\n  { inter := hB.inter\n    smul := hsmul }\n\n"}
{"name":"RingFilterBasis.SubmodulesBasis.inter","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"Œπ : Type u_1\nR : Type u_2\ninst‚úù¬≤ : CommRing R\nM : Type u_4\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\nBR : RingFilterBasis R\nB : Œπ ‚Üí Submodule R M\nself : BR.SubmodulesBasis B\ni j : Œπ\n‚ä¢ Exists fun k => LE.le (B k) (Min.min (B i) (B j))","decl":"/-- Given a ring filter basis on a commutative ring `R`, define a compatibility condition\non a family of submodules of an `R`-module `M`. This compatibility condition allows to get\na topological module structure. -/\nstructure RingFilterBasis.SubmodulesBasis (BR : RingFilterBasis R) (B : Œπ ‚Üí Submodule R M) :\n    Prop where\n  /-- Condition for `B` to be a filter basis on `M`. -/\n  inter : ‚àÄ i j, ‚àÉ k, B k ‚â§ B i ‚äì B j\n  /-- For any element `m : M` and any set `B i` in the submodule basis on `M`,\n    there is a `U` in the ring filter basis on `R` such that `U * m` is in `B i`. -/\n  smul : ‚àÄ (m : M) (i : Œπ), ‚àÉ U ‚àà BR, U ‚äÜ (¬∑ ‚Ä¢ m) ‚Åª¬π' B i\n\n"}
{"name":"RingFilterBasis.SubmodulesBasis.smul","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"Œπ : Type u_1\nR : Type u_2\ninst‚úù¬≤ : CommRing R\nM : Type u_4\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\nBR : RingFilterBasis R\nB : Œπ ‚Üí Submodule R M\nself : BR.SubmodulesBasis B\nm : M\ni : Œπ\n‚ä¢ Exists fun U => And (Membership.mem BR U) (HasSubset.Subset U (Set.preimage (fun x => HSMul.hSMul x m) ‚Üë(B i)))","decl":"/-- Given a ring filter basis on a commutative ring `R`, define a compatibility condition\non a family of submodules of an `R`-module `M`. This compatibility condition allows to get\na topological module structure. -/\nstructure RingFilterBasis.SubmodulesBasis (BR : RingFilterBasis R) (B : Œπ ‚Üí Submodule R M) :\n    Prop where\n  /-- Condition for `B` to be a filter basis on `M`. -/\n  inter : ‚àÄ i j, ‚àÉ k, B k ‚â§ B i ‚äì B j\n  /-- For any element `m : M` and any set `B i` in the submodule basis on `M`,\n    there is a `U` in the ring filter basis on `R` such that `U * m` is in `B i`. -/\n  smul : ‚àÄ (m : M) (i : Œπ), ‚àÉ U ‚àà BR, U ‚äÜ (¬∑ ‚Ä¢ m) ‚Åª¬π' B i\n\n"}
{"name":"RingFilterBasis.submodulesBasisIsBasis","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"Œπ : Type u_1\nR : Type u_2\ninst‚úù¬≤ : CommRing R\nM : Type u_4\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\nBR : RingFilterBasis R\nB : Œπ ‚Üí Submodule R M\nhB : BR.SubmodulesBasis B\n‚ä¢ SubmodulesBasis B","decl":"theorem RingFilterBasis.submodulesBasisIsBasis (BR : RingFilterBasis R) {B : Œπ ‚Üí Submodule R M}\n    (hB : BR.SubmodulesBasis B) : @_root_.SubmodulesBasis Œπ R _ M _ _ BR.topology B :=\n  let _ := BR.topology -- Porting note: failed to synthesize instance `TopologicalSpace R`\n  { inter := hB.inter\n    smul := by\n      letI := BR.topology\n      intro m i\n      rcases hB.smul m i with ‚ü®V, V_in, hV‚ü©\n      exact mem_of_superset (BR.toAddGroupFilterBasis.mem_nhds_zero V_in) hV }\n\n"}
