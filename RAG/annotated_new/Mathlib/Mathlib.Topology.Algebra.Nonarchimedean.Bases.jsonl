{"name":"RingSubgroupsBasis.inter","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"A : Type u_1\nι : Type u_2\ninst✝ : Ring A\nB : ι → AddSubgroup A\nself : RingSubgroupsBasis B\ni j : ι\n⊢ Exists fun k => LE.le (B k) (Min.min (B i) (B j))","decl":"/-- A family of additive subgroups on a ring `A` is a subgroups basis if it satisfies some\naxioms ensuring there is a topology on `A` which is compatible with the ring structure and\nadmits this family as a basis of neighborhoods of zero. -/\nstructure RingSubgroupsBasis {A ι : Type*} [Ring A] (B : ι → AddSubgroup A) : Prop where\n  /-- Condition for `B` to be a filter basis on `A`. -/\n  inter : ∀ i j, ∃ k, B k ≤ B i ⊓ B j\n  /-- For each set `B` in the submodule basis on `A`, there is another basis element `B'` such\n   that the set-theoretic product `B' * B'` is in `B`. -/\n  mul : ∀ i, ∃ j, (B j : Set A) * B j ⊆ B i\n  /-- For any element `x : A` and any set `B` in the submodule basis on `A`,\n    there is another basis element `B'` such that `B' * x` is in `B`. -/\n  leftMul : ∀ x : A, ∀ i, ∃ j, (B j : Set A) ⊆ (x * ·) ⁻¹' B i\n  /-- For any element `x : A` and any set `B` in the submodule basis on `A`,\n    there is another basis element `B'` such that `x * B'` is in `B`. -/\n  rightMul : ∀ x : A, ∀ i, ∃ j, (B j : Set A) ⊆ (· * x) ⁻¹' B i\n\n"}
{"name":"RingSubgroupsBasis.mul","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"A : Type u_1\nι : Type u_2\ninst✝ : Ring A\nB : ι → AddSubgroup A\nself : RingSubgroupsBasis B\ni : ι\n⊢ Exists fun j => HasSubset.Subset (HMul.hMul ↑(B j) ↑(B j)) ↑(B i)","decl":"/-- A family of additive subgroups on a ring `A` is a subgroups basis if it satisfies some\naxioms ensuring there is a topology on `A` which is compatible with the ring structure and\nadmits this family as a basis of neighborhoods of zero. -/\nstructure RingSubgroupsBasis {A ι : Type*} [Ring A] (B : ι → AddSubgroup A) : Prop where\n  /-- Condition for `B` to be a filter basis on `A`. -/\n  inter : ∀ i j, ∃ k, B k ≤ B i ⊓ B j\n  /-- For each set `B` in the submodule basis on `A`, there is another basis element `B'` such\n   that the set-theoretic product `B' * B'` is in `B`. -/\n  mul : ∀ i, ∃ j, (B j : Set A) * B j ⊆ B i\n  /-- For any element `x : A` and any set `B` in the submodule basis on `A`,\n    there is another basis element `B'` such that `B' * x` is in `B`. -/\n  leftMul : ∀ x : A, ∀ i, ∃ j, (B j : Set A) ⊆ (x * ·) ⁻¹' B i\n  /-- For any element `x : A` and any set `B` in the submodule basis on `A`,\n    there is another basis element `B'` such that `x * B'` is in `B`. -/\n  rightMul : ∀ x : A, ∀ i, ∃ j, (B j : Set A) ⊆ (· * x) ⁻¹' B i\n\n"}
{"name":"RingSubgroupsBasis.rightMul","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"A : Type u_1\nι : Type u_2\ninst✝ : Ring A\nB : ι → AddSubgroup A\nself : RingSubgroupsBasis B\nx : A\ni : ι\n⊢ Exists fun j => HasSubset.Subset (↑(B j)) (Set.preimage (fun x_1 => HMul.hMul x_1 x) ↑(B i))","decl":"/-- A family of additive subgroups on a ring `A` is a subgroups basis if it satisfies some\naxioms ensuring there is a topology on `A` which is compatible with the ring structure and\nadmits this family as a basis of neighborhoods of zero. -/\nstructure RingSubgroupsBasis {A ι : Type*} [Ring A] (B : ι → AddSubgroup A) : Prop where\n  /-- Condition for `B` to be a filter basis on `A`. -/\n  inter : ∀ i j, ∃ k, B k ≤ B i ⊓ B j\n  /-- For each set `B` in the submodule basis on `A`, there is another basis element `B'` such\n   that the set-theoretic product `B' * B'` is in `B`. -/\n  mul : ∀ i, ∃ j, (B j : Set A) * B j ⊆ B i\n  /-- For any element `x : A` and any set `B` in the submodule basis on `A`,\n    there is another basis element `B'` such that `B' * x` is in `B`. -/\n  leftMul : ∀ x : A, ∀ i, ∃ j, (B j : Set A) ⊆ (x * ·) ⁻¹' B i\n  /-- For any element `x : A` and any set `B` in the submodule basis on `A`,\n    there is another basis element `B'` such that `x * B'` is in `B`. -/\n  rightMul : ∀ x : A, ∀ i, ∃ j, (B j : Set A) ⊆ (· * x) ⁻¹' B i\n\n"}
{"name":"RingSubgroupsBasis.leftMul","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"A : Type u_1\nι : Type u_2\ninst✝ : Ring A\nB : ι → AddSubgroup A\nself : RingSubgroupsBasis B\nx : A\ni : ι\n⊢ Exists fun j => HasSubset.Subset (↑(B j)) (Set.preimage (fun x_1 => HMul.hMul x x_1) ↑(B i))","decl":"/-- A family of additive subgroups on a ring `A` is a subgroups basis if it satisfies some\naxioms ensuring there is a topology on `A` which is compatible with the ring structure and\nadmits this family as a basis of neighborhoods of zero. -/\nstructure RingSubgroupsBasis {A ι : Type*} [Ring A] (B : ι → AddSubgroup A) : Prop where\n  /-- Condition for `B` to be a filter basis on `A`. -/\n  inter : ∀ i j, ∃ k, B k ≤ B i ⊓ B j\n  /-- For each set `B` in the submodule basis on `A`, there is another basis element `B'` such\n   that the set-theoretic product `B' * B'` is in `B`. -/\n  mul : ∀ i, ∃ j, (B j : Set A) * B j ⊆ B i\n  /-- For any element `x : A` and any set `B` in the submodule basis on `A`,\n    there is another basis element `B'` such that `B' * x` is in `B`. -/\n  leftMul : ∀ x : A, ∀ i, ∃ j, (B j : Set A) ⊆ (x * ·) ⁻¹' B i\n  /-- For any element `x : A` and any set `B` in the submodule basis on `A`,\n    there is another basis element `B'` such that `x * B'` is in `B`. -/\n  rightMul : ∀ x : A, ∀ i, ∃ j, (B j : Set A) ⊆ (· * x) ⁻¹' B i\n\n"}
{"name":"RingSubgroupsBasis.of_comm","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"A : Type u_3\nι : Type u_4\ninst✝ : CommRing A\nB : ι → AddSubgroup A\ninter : ∀ (i j : ι), Exists fun k => LE.le (B k) (Min.min (B i) (B j))\nmul : ∀ (i : ι), Exists fun j => HasSubset.Subset (HMul.hMul ↑(B j) ↑(B j)) ↑(B i)\nleftMul : ∀ (x : A) (i : ι), Exists fun j => HasSubset.Subset (↑(B j)) (Set.preimage (fun y => HMul.hMul x y) ↑(B i))\n⊢ RingSubgroupsBasis B","decl":"theorem of_comm {A ι : Type*} [CommRing A] (B : ι → AddSubgroup A)\n    (inter : ∀ i j, ∃ k, B k ≤ B i ⊓ B j) (mul : ∀ i, ∃ j, (B j : Set A) * B j ⊆ B i)\n    (leftMul : ∀ x : A, ∀ i, ∃ j, (B j : Set A) ⊆ (fun y : A => x * y) ⁻¹' B i) :\n    RingSubgroupsBasis B :=\n  { inter\n    mul\n    leftMul\n    rightMul := fun x i ↦ (leftMul x i).imp fun j hj ↦ by simpa only [mul_comm] using hj }\n\n"}
{"name":"RingSubgroupsBasis.mem_addGroupFilterBasis_iff","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"A : Type u_1\nι : Type u_2\ninst✝¹ : Ring A\ninst✝ : Nonempty ι\nB : ι → AddSubgroup A\nhB : RingSubgroupsBasis B\nV : Set A\n⊢ Iff (Membership.mem RingFilterBasis.toAddGroupFilterBasis V) (Exists fun i => Eq V ↑(B i))","decl":"theorem mem_addGroupFilterBasis_iff {V : Set A} :\n    V ∈ hB.toRingFilterBasis.toAddGroupFilterBasis ↔ ∃ i, V = B i :=\n  Iff.rfl\n\n"}
{"name":"RingSubgroupsBasis.mem_addGroupFilterBasis","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"A : Type u_1\nι : Type u_2\ninst✝¹ : Ring A\ninst✝ : Nonempty ι\nB : ι → AddSubgroup A\nhB : RingSubgroupsBasis B\ni : ι\n⊢ Membership.mem RingFilterBasis.toAddGroupFilterBasis ↑(B i)","decl":"theorem mem_addGroupFilterBasis (i) : (B i : Set A) ∈ hB.toRingFilterBasis.toAddGroupFilterBasis :=\n  ⟨i, rfl⟩\n\n"}
{"name":"RingSubgroupsBasis.hasBasis_nhds_zero","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"A : Type u_1\nι : Type u_2\ninst✝¹ : Ring A\ninst✝ : Nonempty ι\nB : ι → AddSubgroup A\nhB : RingSubgroupsBasis B\n⊢ (nhds 0).HasBasis (fun x => True) fun i => ↑(B i)","decl":"theorem hasBasis_nhds_zero : HasBasis (@nhds A hB.topology 0) (fun _ => True) fun i => B i :=\n  ⟨by\n    intro s\n    rw [hB.toRingFilterBasis.toAddGroupFilterBasis.nhds_zero_hasBasis.mem_iff]\n    constructor\n    · rintro ⟨-, ⟨i, rfl⟩, hi⟩\n      exact ⟨i, trivial, hi⟩\n    · rintro ⟨i, -, hi⟩\n      exact ⟨B i, ⟨i, rfl⟩, hi⟩⟩\n\n"}
{"name":"RingSubgroupsBasis.hasBasis_nhds","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"A : Type u_1\nι : Type u_2\ninst✝¹ : Ring A\ninst✝ : Nonempty ι\nB : ι → AddSubgroup A\nhB : RingSubgroupsBasis B\na : A\n⊢ (nhds a).HasBasis (fun x => True) fun i => setOf fun b => Membership.mem (B i) (HSub.hSub b a)","decl":"theorem hasBasis_nhds (a : A) :\n    HasBasis (@nhds A hB.topology a) (fun _ => True) fun i => { b | b - a ∈ B i } :=\n  ⟨by\n    intro s\n    rw [(hB.toRingFilterBasis.toAddGroupFilterBasis.nhds_hasBasis a).mem_iff]\n    simp only [true_and]\n    constructor\n    · rintro ⟨-, ⟨i, rfl⟩, hi⟩\n      use i\n      suffices h : { b : A | b - a ∈ B i } = (fun y => a + y) '' ↑(B i) by\n        rw [h]\n        assumption\n      simp only [image_add_left, neg_add_eq_sub]\n      ext b\n      simp\n    · rintro ⟨i, hi⟩\n      use B i\n      constructor\n      · use i\n      · rw [image_subset_iff]\n        rintro b b_in\n        apply hi\n        simpa using b_in⟩\n\n"}
{"name":"RingSubgroupsBasis.nonarchimedean","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"A : Type u_1\nι : Type u_2\ninst✝¹ : Ring A\ninst✝ : Nonempty ι\nB : ι → AddSubgroup A\nhB : RingSubgroupsBasis B\n⊢ NonarchimedeanRing A","decl":"theorem nonarchimedean : @NonarchimedeanRing A _ hB.topology := by\n  letI := hB.topology\n  constructor\n  intro U hU\n  obtain ⟨i, -, hi : (B i : Set A) ⊆ U⟩ := hB.hasBasis_nhds_zero.mem_iff.mp hU\n  exact ⟨hB.openAddSubgroup i, hi⟩\n\n"}
{"name":"SubmodulesRingBasis.leftMul","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"ι : Type u_1\nR : Type u_2\nA : Type u_3\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nB : ι → Submodule R A\nself : SubmodulesRingBasis B\na : A\ni : ι\n⊢ Exists fun j => LE.le (HSMul.hSMul a (B j)) (B i)","decl":"/-- A family of submodules in a commutative `R`-algebra `A` is a submodules basis if it satisfies\nsome axioms ensuring there is a topology on `A` which is compatible with the ring structure and\nadmits this family as a basis of neighborhoods of zero. -/\nstructure SubmodulesRingBasis (B : ι → Submodule R A) : Prop where\n  /-- Condition for `B` to be a filter basis on `A`. -/\n  inter : ∀ i j, ∃ k, B k ≤ B i ⊓ B j\n  /-- For any element `a : A` and any set `B` in the submodule basis on `A`,\n    there is another basis element `B'` such that `a • B'` is in `B`. -/\n  leftMul : ∀ (a : A) (i), ∃ j, a • B j ≤ B i\n  /-- For each set `B` in the submodule basis on `A`, there is another basis element `B'` such\n    that the set-theoretic product `B' * B'` is in `B`. -/\n  mul : ∀ i, ∃ j, (B j : Set A) * B j ⊆ B i\n\n"}
{"name":"SubmodulesRingBasis.inter","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"ι : Type u_1\nR : Type u_2\nA : Type u_3\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nB : ι → Submodule R A\nself : SubmodulesRingBasis B\ni j : ι\n⊢ Exists fun k => LE.le (B k) (Min.min (B i) (B j))","decl":"/-- A family of submodules in a commutative `R`-algebra `A` is a submodules basis if it satisfies\nsome axioms ensuring there is a topology on `A` which is compatible with the ring structure and\nadmits this family as a basis of neighborhoods of zero. -/\nstructure SubmodulesRingBasis (B : ι → Submodule R A) : Prop where\n  /-- Condition for `B` to be a filter basis on `A`. -/\n  inter : ∀ i j, ∃ k, B k ≤ B i ⊓ B j\n  /-- For any element `a : A` and any set `B` in the submodule basis on `A`,\n    there is another basis element `B'` such that `a • B'` is in `B`. -/\n  leftMul : ∀ (a : A) (i), ∃ j, a • B j ≤ B i\n  /-- For each set `B` in the submodule basis on `A`, there is another basis element `B'` such\n    that the set-theoretic product `B' * B'` is in `B`. -/\n  mul : ∀ i, ∃ j, (B j : Set A) * B j ⊆ B i\n\n"}
{"name":"SubmodulesRingBasis.mul","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"ι : Type u_1\nR : Type u_2\nA : Type u_3\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nB : ι → Submodule R A\nself : SubmodulesRingBasis B\ni : ι\n⊢ Exists fun j => HasSubset.Subset (HMul.hMul ↑(B j) ↑(B j)) ↑(B i)","decl":"/-- A family of submodules in a commutative `R`-algebra `A` is a submodules basis if it satisfies\nsome axioms ensuring there is a topology on `A` which is compatible with the ring structure and\nadmits this family as a basis of neighborhoods of zero. -/\nstructure SubmodulesRingBasis (B : ι → Submodule R A) : Prop where\n  /-- Condition for `B` to be a filter basis on `A`. -/\n  inter : ∀ i j, ∃ k, B k ≤ B i ⊓ B j\n  /-- For any element `a : A` and any set `B` in the submodule basis on `A`,\n    there is another basis element `B'` such that `a • B'` is in `B`. -/\n  leftMul : ∀ (a : A) (i), ∃ j, a • B j ≤ B i\n  /-- For each set `B` in the submodule basis on `A`, there is another basis element `B'` such\n    that the set-theoretic product `B' * B'` is in `B`. -/\n  mul : ∀ i, ∃ j, (B j : Set A) * B j ⊆ B i\n\n"}
{"name":"SubmodulesRingBasis.toRing_subgroups_basis","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"ι : Type u_1\nR : Type u_2\nA : Type u_3\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nB : ι → Submodule R A\nhB : SubmodulesRingBasis B\n⊢ RingSubgroupsBasis fun i => (B i).toAddSubgroup","decl":"theorem toRing_subgroups_basis (hB : SubmodulesRingBasis B) :\n    RingSubgroupsBasis fun i => (B i).toAddSubgroup := by\n  apply RingSubgroupsBasis.of_comm (fun i => (B i).toAddSubgroup) hB.inter hB.mul\n  intro a i\n  rcases hB.leftMul a i with ⟨j, hj⟩\n  use j\n  rintro b (b_in : b ∈ B j)\n  exact hj ⟨b, b_in, rfl⟩\n\n"}
{"name":"SubmodulesBasis.inter","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝³ : CommRing R\nM : Type u_4\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : TopologicalSpace R\nB : ι → Submodule R M\nself : SubmodulesBasis B\ni j : ι\n⊢ Exists fun k => LE.le (B k) (Min.min (B i) (B j))","decl":"/-- A family of submodules in an `R`-module `M` is a submodules basis if it satisfies\nsome axioms ensuring there is a topology on `M` which is compatible with the module structure and\nadmits this family as a basis of neighborhoods of zero. -/\nstructure SubmodulesBasis [TopologicalSpace R] (B : ι → Submodule R M) : Prop where\n  /-- Condition for `B` to be a filter basis on `M`. -/\n  inter : ∀ i j, ∃ k, B k ≤ B i ⊓ B j\n  /-- For any element `m : M` and any set `B` in the basis, `a • m` lies in `B` for all\n    `a` sufficiently close to `0`. -/\n  smul : ∀ (m : M) (i : ι), ∀ᶠ a in 𝓝 (0 : R), a • m ∈ B i\n\n"}
{"name":"SubmodulesBasis.smul","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝³ : CommRing R\nM : Type u_4\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : TopologicalSpace R\nB : ι → Submodule R M\nself : SubmodulesBasis B\nm : M\ni : ι\n⊢ Filter.Eventually (fun a => Membership.mem (B i) (HSMul.hSMul a m)) (nhds 0)","decl":"/-- A family of submodules in an `R`-module `M` is a submodules basis if it satisfies\nsome axioms ensuring there is a topology on `M` which is compatible with the module structure and\nadmits this family as a basis of neighborhoods of zero. -/\nstructure SubmodulesBasis [TopologicalSpace R] (B : ι → Submodule R M) : Prop where\n  /-- Condition for `B` to be a filter basis on `M`. -/\n  inter : ∀ i j, ∃ k, B k ≤ B i ⊓ B j\n  /-- For any element `m : M` and any set `B` in the basis, `a • m` lies in `B` for all\n    `a` sufficiently close to `0`. -/\n  smul : ∀ (m : M) (i : ι), ∀ᶠ a in 𝓝 (0 : R), a • m ∈ B i\n\n"}
{"name":"SubmodulesBasis.nonarchimedean","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝⁴ : CommRing R\nM : Type u_4\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : TopologicalSpace R\ninst✝ : Nonempty ι\nB : ι → Submodule R M\nhB : SubmodulesBasis B\n⊢ NonarchimedeanAddGroup M","decl":"theorem nonarchimedean (hB : SubmodulesBasis B) : @NonarchimedeanAddGroup M _ hB.topology := by\n  letI := hB.topology\n  constructor\n  intro U hU\n  obtain ⟨-, ⟨i, rfl⟩, hi : (B i : Set M) ⊆ U⟩ :=\n    hB.toModuleFilterBasis.toAddGroupFilterBasis.nhds_zero_hasBasis.mem_iff.mp hU\n  exact ⟨hB.openAddSubgroup i, hi⟩\n\n"}
{"name":"SubmodulesRingBasis.toSubmodulesBasis","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"ι : Type u_1\nR : Type u_2\nA : Type u_3\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\ninst✝ : TopologicalSpace R\nB : ι → Submodule R A\nhB : SubmodulesRingBasis B\nhsmul : ∀ (m : A) (i : ι), Filter.Eventually (fun a => Membership.mem (B i) (HSMul.hSMul a m)) (nhds 0)\n⊢ SubmodulesBasis B","decl":"theorem SubmodulesRingBasis.toSubmodulesBasis : SubmodulesBasis B :=\n  { inter := hB.inter\n    smul := hsmul }\n\n"}
{"name":"RingFilterBasis.SubmodulesBasis.inter","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝² : CommRing R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nBR : RingFilterBasis R\nB : ι → Submodule R M\nself : BR.SubmodulesBasis B\ni j : ι\n⊢ Exists fun k => LE.le (B k) (Min.min (B i) (B j))","decl":"/-- Given a ring filter basis on a commutative ring `R`, define a compatibility condition\non a family of submodules of an `R`-module `M`. This compatibility condition allows to get\na topological module structure. -/\nstructure RingFilterBasis.SubmodulesBasis (BR : RingFilterBasis R) (B : ι → Submodule R M) :\n    Prop where\n  /-- Condition for `B` to be a filter basis on `M`. -/\n  inter : ∀ i j, ∃ k, B k ≤ B i ⊓ B j\n  /-- For any element `m : M` and any set `B i` in the submodule basis on `M`,\n    there is a `U` in the ring filter basis on `R` such that `U * m` is in `B i`. -/\n  smul : ∀ (m : M) (i : ι), ∃ U ∈ BR, U ⊆ (· • m) ⁻¹' B i\n\n"}
{"name":"RingFilterBasis.SubmodulesBasis.smul","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝² : CommRing R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nBR : RingFilterBasis R\nB : ι → Submodule R M\nself : BR.SubmodulesBasis B\nm : M\ni : ι\n⊢ Exists fun U => And (Membership.mem BR U) (HasSubset.Subset U (Set.preimage (fun x => HSMul.hSMul x m) ↑(B i)))","decl":"/-- Given a ring filter basis on a commutative ring `R`, define a compatibility condition\non a family of submodules of an `R`-module `M`. This compatibility condition allows to get\na topological module structure. -/\nstructure RingFilterBasis.SubmodulesBasis (BR : RingFilterBasis R) (B : ι → Submodule R M) :\n    Prop where\n  /-- Condition for `B` to be a filter basis on `M`. -/\n  inter : ∀ i j, ∃ k, B k ≤ B i ⊓ B j\n  /-- For any element `m : M` and any set `B i` in the submodule basis on `M`,\n    there is a `U` in the ring filter basis on `R` such that `U * m` is in `B i`. -/\n  smul : ∀ (m : M) (i : ι), ∃ U ∈ BR, U ⊆ (· • m) ⁻¹' B i\n\n"}
{"name":"RingFilterBasis.submodulesBasisIsBasis","module":"Mathlib.Topology.Algebra.Nonarchimedean.Bases","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝² : CommRing R\nM : Type u_4\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nBR : RingFilterBasis R\nB : ι → Submodule R M\nhB : BR.SubmodulesBasis B\n⊢ SubmodulesBasis B","decl":"theorem RingFilterBasis.submodulesBasisIsBasis (BR : RingFilterBasis R) {B : ι → Submodule R M}\n    (hB : BR.SubmodulesBasis B) : @_root_.SubmodulesBasis ι R _ M _ _ BR.topology B :=\n  let _ := BR.topology -- Porting note: failed to synthesize instance `TopologicalSpace R`\n  { inter := hB.inter\n    smul := by\n      letI := BR.topology\n      intro m i\n      rcases hB.smul m i with ⟨V, V_in, hV⟩\n      exact mem_of_superset (BR.toAddGroupFilterBasis.mem_nhds_zero V_in) hV }\n\n"}
