{"name":"Filter.IsBoundedUnder.isLittleO_sub_self_inv","module":"Mathlib.Analysis.Asymptotics.SpecificAsymptotics","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ¹ : NormedField ğ•œ\ninstâœ : Norm E\na : ğ•œ\nf : ğ•œ â†’ E\nh : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) (nhdsWithin a (HasCompl.compl (Singleton.singleton a))) (Function.comp Norm.norm f)\nâŠ¢ Asymptotics.IsLittleO (nhdsWithin a (HasCompl.compl (Singleton.singleton a))) f fun x => Inv.inv (HSub.hSub x a)","decl":"/-- If `f : ğ•œ â†’ E` is bounded in a punctured neighborhood of `a`, then `f(x) = o((x - a)â»Â¹)` as\n`x â†’ a`, `x â‰  a`. -/\ntheorem Filter.IsBoundedUnder.isLittleO_sub_self_inv {ğ•œ E : Type*} [NormedField ğ•œ] [Norm E] {a : ğ•œ}\n    {f : ğ•œ â†’ E} (h : IsBoundedUnder (Â· â‰¤ Â·) (ğ“[â‰ ] a) (norm âˆ˜ f)) :\n    f =o[ğ“[â‰ ] a] fun x => (x - a)â»Â¹ := by\n  refine (h.isBigO_const (one_ne_zero' â„)).trans_isLittleO (isLittleO_const_left.2 <| Or.inr ?_)\n  simp only [Function.comp_def, norm_inv]\n  exact (tendsto_norm_sub_self_nhdsNE a).inv_tendsto_nhdsGT_zero\n\n"}
{"name":"pow_div_pow_eventuallyEq_atTop","module":"Mathlib.Analysis.Asymptotics.SpecificAsymptotics","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedField ğ•œ\np q : Nat\nâŠ¢ Filter.atTop.EventuallyEq (fun x => HDiv.hDiv (HPow.hPow x p) (HPow.hPow x q)) fun x => HPow.hPow x (HSub.hSub â†‘p â†‘q)","decl":"theorem pow_div_pow_eventuallyEq_atTop {p q : â„•} :\n    (fun x : ğ•œ => x ^ p / x ^ q) =á¶ [atTop] fun x => x ^ ((p : â„¤) - q) := by\n  apply (eventually_gt_atTop (0 : ğ•œ)).mono fun x hx => _\n  intro x hx\n  simp [zpow_subâ‚€ hx.ne']\n\n"}
{"name":"pow_div_pow_eventuallyEq_atBot","module":"Mathlib.Analysis.Asymptotics.SpecificAsymptotics","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedField ğ•œ\np q : Nat\nâŠ¢ Filter.atBot.EventuallyEq (fun x => HDiv.hDiv (HPow.hPow x p) (HPow.hPow x q)) fun x => HPow.hPow x (HSub.hSub â†‘p â†‘q)","decl":"theorem pow_div_pow_eventuallyEq_atBot {p q : â„•} :\n    (fun x : ğ•œ => x ^ p / x ^ q) =á¶ [atBot] fun x => x ^ ((p : â„¤) - q) := by\n  apply (eventually_lt_atBot (0 : ğ•œ)).mono fun x hx => _\n  intro x hx\n  simp [zpow_subâ‚€ hx.ne]\n\n"}
{"name":"tendsto_pow_div_pow_atTop_atTop","module":"Mathlib.Analysis.Asymptotics.SpecificAsymptotics","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedField ğ•œ\np q : Nat\nhpq : LT.lt q p\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv (HPow.hPow x p) (HPow.hPow x q)) Filter.atTop Filter.atTop","decl":"theorem tendsto_pow_div_pow_atTop_atTop {p q : â„•} (hpq : q < p) :\n    Tendsto (fun x : ğ•œ => x ^ p / x ^ q) atTop atTop := by\n  rw [tendsto_congr' pow_div_pow_eventuallyEq_atTop]\n  apply tendsto_zpow_atTop_atTop\n  omega\n\n"}
{"name":"tendsto_pow_div_pow_atTop_zero","module":"Mathlib.Analysis.Asymptotics.SpecificAsymptotics","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : TopologicalSpace ğ•œ\ninstâœ : OrderTopology ğ•œ\np q : Nat\nhpq : LT.lt p q\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv (HPow.hPow x p) (HPow.hPow x q)) Filter.atTop (nhds 0)","decl":"theorem tendsto_pow_div_pow_atTop_zero [TopologicalSpace ğ•œ] [OrderTopology ğ•œ] {p q : â„•}\n    (hpq : p < q) : Tendsto (fun x : ğ•œ => x ^ p / x ^ q) atTop (ğ“ 0) := by\n  rw [tendsto_congr' pow_div_pow_eventuallyEq_atTop]\n  apply tendsto_zpow_atTop_zero\n  omega\n\n"}
{"name":"Asymptotics.isLittleO_pow_pow_atTop_of_lt","module":"Mathlib.Analysis.Asymptotics.SpecificAsymptotics","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹ : NormedLinearOrderedField ğ•œ\ninstâœ : OrderTopology ğ•œ\np q : Nat\nhpq : LT.lt p q\nâŠ¢ Asymptotics.IsLittleO Filter.atTop (fun x => HPow.hPow x p) fun x => HPow.hPow x q","decl":"theorem Asymptotics.isLittleO_pow_pow_atTop_of_lt [OrderTopology ğ•œ] {p q : â„•} (hpq : p < q) :\n    (fun x : ğ•œ => x ^ p) =o[atTop] fun x => x ^ q := by\n  refine (isLittleO_iff_tendsto' ?_).mpr (tendsto_pow_div_pow_atTop_zero hpq)\n  exact (eventually_gt_atTop 0).mono fun x hx hxq => (pow_ne_zero q hx.ne' hxq).elim\n\n"}
{"name":"Asymptotics.IsBigO.trans_tendsto_norm_atTop","module":"Mathlib.Analysis.Asymptotics.SpecificAsymptotics","initialProofState":"ğ•œ : Type u_1\ninstâœ : NormedLinearOrderedField ğ•œ\nÎ± : Type u_2\nu v : Î± â†’ ğ•œ\nl : Filter Î±\nhuv : Asymptotics.IsBigO l u v\nhu : Filter.Tendsto (fun x => Norm.norm (u x)) l Filter.atTop\nâŠ¢ Filter.Tendsto (fun x => Norm.norm (v x)) l Filter.atTop","decl":"theorem Asymptotics.IsBigO.trans_tendsto_norm_atTop {Î± : Type*} {u v : Î± â†’ ğ•œ} {l : Filter Î±}\n    (huv : u =O[l] v) (hu : Tendsto (fun x => â€–u xâ€–) l atTop) :\n    Tendsto (fun x => â€–v xâ€–) l atTop := by\n  rcases huv.exists_pos with âŸ¨c, hc, hcuvâŸ©\n  rw [IsBigOWith] at hcuv\n  convert Tendsto.atTop_div_const hc (tendsto_atTop_mono' l hcuv hu)\n  rw [mul_div_cancel_leftâ‚€ _ hc.ne.symm]\n\n"}
{"name":"Asymptotics.IsLittleO.sum_range","module":"Mathlib.Analysis.Asymptotics.SpecificAsymptotics","initialProofState":"Î± : Type u_1\ninstâœ : NormedAddCommGroup Î±\nf : Nat â†’ Î±\ng : Nat â†’ Real\nh : Asymptotics.IsLittleO Filter.atTop f g\nhg : LE.le 0 g\nh'g : Filter.Tendsto (fun n => (Finset.range n).sum fun i => g i) Filter.atTop Filter.atTop\nâŠ¢ Asymptotics.IsLittleO Filter.atTop (fun n => (Finset.range n).sum fun i => f i) fun n => (Finset.range n).sum fun i => g i","decl":"theorem Asymptotics.IsLittleO.sum_range {Î± : Type*} [NormedAddCommGroup Î±] {f : â„• â†’ Î±} {g : â„• â†’ â„}\n    (h : f =o[atTop] g) (hg : 0 â‰¤ g) (h'g : Tendsto (fun n => âˆ‘ i âˆˆ range n, g i) atTop atTop) :\n    (fun n => âˆ‘ i âˆˆ range n, f i) =o[atTop] fun n => âˆ‘ i âˆˆ range n, g i := by\n  have A : âˆ€ i, â€–g iâ€– = g i := fun i => Real.norm_of_nonneg (hg i)\n  have B : âˆ€ n, â€–âˆ‘ i âˆˆ range n, g iâ€– = âˆ‘ i âˆˆ range n, g i := fun n => by\n    rwa [Real.norm_eq_abs, abs_sum_of_nonneg']\n  apply isLittleO_iff.2 fun Îµ Îµpos => _\n  intro Îµ Îµpos\n  obtain âŸ¨N, hNâŸ© : âˆƒ N : â„•, âˆ€ b : â„•, N â‰¤ b â†’ â€–f bâ€– â‰¤ Îµ / 2 * g b := by\n    simpa only [A, eventually_atTop] using isLittleO_iff.mp h (half_pos Îµpos)\n  have : (fun _ : â„• => âˆ‘ i âˆˆ range N, f i) =o[atTop] fun n : â„• => âˆ‘ i âˆˆ range n, g i := by\n    apply isLittleO_const_left.2\n    exact Or.inr (h'g.congr fun n => (B n).symm)\n  filter_upwards [isLittleO_iff.1 this (half_pos Îµpos), Ici_mem_atTop N] with n hn Nn\n  calc\n    â€–âˆ‘ i âˆˆ range n, f iâ€– = â€–(âˆ‘ i âˆˆ range N, f i) + âˆ‘ i âˆˆ Ico N n, f iâ€– := by\n      rw [sum_range_add_sum_Ico _ Nn]\n    _ â‰¤ â€–âˆ‘ i âˆˆ range N, f iâ€– + â€–âˆ‘ i âˆˆ Ico N n, f iâ€– := norm_add_le _ _\n    _ â‰¤ â€–âˆ‘ i âˆˆ range N, f iâ€– + âˆ‘ i âˆˆ Ico N n, Îµ / 2 * g i :=\n      (add_le_add le_rfl (norm_sum_le_of_le _ fun i hi => hN _ (mem_Ico.1 hi).1))\n    _ â‰¤ â€–âˆ‘ i âˆˆ range N, f iâ€– + âˆ‘ i âˆˆ range n, Îµ / 2 * g i := by\n      gcongr\n      Â· exact fun i _ _ â†¦ mul_nonneg (half_pos Îµpos).le (hg i)\n      Â· rw [range_eq_Ico]\n        exact Ico_subset_Ico (zero_le _) le_rfl\n    _ â‰¤ Îµ / 2 * â€–âˆ‘ i âˆˆ range n, g iâ€– + Îµ / 2 * âˆ‘ i âˆˆ range n, g i := by rw [â† mul_sum]; gcongr\n    _ = Îµ * â€–âˆ‘ i âˆˆ range n, g iâ€– := by\n      simp only [B]\n      ring\n\n"}
{"name":"Asymptotics.isLittleO_sum_range_of_tendsto_zero","module":"Mathlib.Analysis.Asymptotics.SpecificAsymptotics","initialProofState":"Î± : Type u_1\ninstâœ : NormedAddCommGroup Î±\nf : Nat â†’ Î±\nh : Filter.Tendsto f Filter.atTop (nhds 0)\nâŠ¢ Asymptotics.IsLittleO Filter.atTop (fun n => (Finset.range n).sum fun i => f i) fun n => â†‘n","decl":"theorem Asymptotics.isLittleO_sum_range_of_tendsto_zero {Î± : Type*} [NormedAddCommGroup Î±]\n    {f : â„• â†’ Î±} (h : Tendsto f atTop (ğ“ 0)) :\n    (fun n => âˆ‘ i âˆˆ range n, f i) =o[atTop] fun n => (n : â„) := by\n  have := ((isLittleO_one_iff â„).2 h).sum_range fun i => zero_le_one\n  simp only [sum_const, card_range, Nat.smul_one_eq_cast] at this\n  exact this tendsto_natCast_atTop_atTop\n\n"}
{"name":"Filter.Tendsto.cesaro_smul","module":"Mathlib.Analysis.Asymptotics.SpecificAsymptotics","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nu : Nat â†’ E\nl : E\nh : Filter.Tendsto u Filter.atTop (nhds l)\nâŠ¢ Filter.Tendsto (fun n => HSMul.hSMul (Inv.inv â†‘n) ((Finset.range n).sum fun i => u i)) Filter.atTop (nhds l)","decl":"/-- The Cesaro average of a converging sequence converges to the same limit. -/\ntheorem Filter.Tendsto.cesaro_smul {E : Type*} [NormedAddCommGroup E] [NormedSpace â„ E] {u : â„• â†’ E}\n    {l : E} (h : Tendsto u atTop (ğ“ l)) :\n    Tendsto (fun n : â„• => (nâ»Â¹ : â„) â€¢ âˆ‘ i âˆˆ range n, u i) atTop (ğ“ l) := by\n  rw [â† tendsto_sub_nhds_zero_iff, â† isLittleO_one_iff â„]\n  have := Asymptotics.isLittleO_sum_range_of_tendsto_zero (tendsto_sub_nhds_zero_iff.2 h)\n  apply ((isBigO_refl (fun n : â„• => (n : â„)â»Â¹) atTop).smul_isLittleO this).congr' _ _\n  Â· filter_upwards [Ici_mem_atTop 1] with n npos\n    have nposâ„ : (0 : â„) < n := Nat.cast_pos.2 npos\n    simp only [smul_sub, sum_sub_distrib, sum_const, card_range, sub_right_inj]\n    rw [â† Nat.cast_smul_eq_nsmul â„, smul_smul, inv_mul_cancelâ‚€ nposâ„.ne', one_smul]\n  Â· filter_upwards [Ici_mem_atTop 1] with n npos\n    have nposâ„ : (0 : â„) < n := Nat.cast_pos.2 npos\n    rw [Algebra.id.smul_eq_mul, inv_mul_cancelâ‚€ nposâ„.ne']\n\n"}
{"name":"Filter.Tendsto.cesaro","module":"Mathlib.Analysis.Asymptotics.SpecificAsymptotics","initialProofState":"u : Nat â†’ Real\nl : Real\nh : Filter.Tendsto u Filter.atTop (nhds l)\nâŠ¢ Filter.Tendsto (fun n => HMul.hMul (Inv.inv â†‘n) ((Finset.range n).sum fun i => u i)) Filter.atTop (nhds l)","decl":"/-- The Cesaro average of a converging sequence converges to the same limit. -/\ntheorem Filter.Tendsto.cesaro {u : â„• â†’ â„} {l : â„} (h : Tendsto u atTop (ğ“ l)) :\n    Tendsto (fun n : â„• => (nâ»Â¹ : â„) * âˆ‘ i âˆˆ range n, u i) atTop (ğ“ l) :=\n  h.cesaro_smul\n\n"}
{"name":"Asymptotics.isEquivalent_nat_floor","module":"Mathlib.Analysis.Asymptotics.SpecificAsymptotics","initialProofState":"R : Type u_1\ninstâœÂ² : NormedLinearOrderedField R\ninstâœÂ¹ : OrderTopology R\ninstâœ : FloorRing R\nâŠ¢ Asymptotics.IsEquivalent Filter.atTop (fun x => â†‘(Nat.floor x)) fun x => x","decl":"theorem Asymptotics.isEquivalent_nat_floor :\n    (fun (x : R) â†¦ â†‘âŒŠxâŒ‹â‚Š) ~[atTop] (fun x â†¦ x) := by\n  refine isEquivalent_of_tendsto_one ?_ tendsto_nat_floor_div_atTop\n  filter_upwards with x hx using by rw [hx, Nat.floor_zero, Nat.cast_eq_zero]\n\n"}
{"name":"Asymptotics.isEquivalent_nat_ceil","module":"Mathlib.Analysis.Asymptotics.SpecificAsymptotics","initialProofState":"R : Type u_1\ninstâœÂ² : NormedLinearOrderedField R\ninstâœÂ¹ : OrderTopology R\ninstâœ : FloorRing R\nâŠ¢ Asymptotics.IsEquivalent Filter.atTop (fun x => â†‘(Nat.ceil x)) fun x => x","decl":"theorem Asymptotics.isEquivalent_nat_ceil :\n    (fun (x : R) â†¦ â†‘âŒˆxâŒ‰â‚Š) ~[atTop] (fun x â†¦ x) := by\n  refine isEquivalent_of_tendsto_one ?_ tendsto_nat_ceil_div_atTop\n  filter_upwards with x hx using by rw [hx, Nat.ceil_zero, Nat.cast_eq_zero]\n\n"}
