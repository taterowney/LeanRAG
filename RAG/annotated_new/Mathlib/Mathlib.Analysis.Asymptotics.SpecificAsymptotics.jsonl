{"name":"Filter.IsBoundedUnder.isLittleO_sub_self_inv","module":"Mathlib.Analysis.Asymptotics.SpecificAsymptotics","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝¹ : NormedField 𝕜\ninst✝ : Norm E\na : 𝕜\nf : 𝕜 → E\nh : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) (nhdsWithin a (HasCompl.compl (Singleton.singleton a))) (Function.comp Norm.norm f)\n⊢ Asymptotics.IsLittleO (nhdsWithin a (HasCompl.compl (Singleton.singleton a))) f fun x => Inv.inv (HSub.hSub x a)","decl":"/-- If `f : 𝕜 → E` is bounded in a punctured neighborhood of `a`, then `f(x) = o((x - a)⁻¹)` as\n`x → a`, `x ≠ a`. -/\ntheorem Filter.IsBoundedUnder.isLittleO_sub_self_inv {𝕜 E : Type*} [NormedField 𝕜] [Norm E] {a : 𝕜}\n    {f : 𝕜 → E} (h : IsBoundedUnder (· ≤ ·) (𝓝[≠] a) (norm ∘ f)) :\n    f =o[𝓝[≠] a] fun x => (x - a)⁻¹ := by\n  refine (h.isBigO_const (one_ne_zero' ℝ)).trans_isLittleO (isLittleO_const_left.2 <| Or.inr ?_)\n  simp only [Function.comp_def, norm_inv]\n  exact (tendsto_norm_sub_self_nhdsNE a).inv_tendsto_nhdsGT_zero\n\n"}
{"name":"pow_div_pow_eventuallyEq_atTop","module":"Mathlib.Analysis.Asymptotics.SpecificAsymptotics","initialProofState":"𝕜 : Type u_1\ninst✝ : LinearOrderedField 𝕜\np q : Nat\n⊢ Filter.atTop.EventuallyEq (fun x => HDiv.hDiv (HPow.hPow x p) (HPow.hPow x q)) fun x => HPow.hPow x (HSub.hSub ↑p ↑q)","decl":"theorem pow_div_pow_eventuallyEq_atTop {p q : ℕ} :\n    (fun x : 𝕜 => x ^ p / x ^ q) =ᶠ[atTop] fun x => x ^ ((p : ℤ) - q) := by\n  apply (eventually_gt_atTop (0 : 𝕜)).mono fun x hx => _\n  intro x hx\n  simp [zpow_sub₀ hx.ne']\n\n"}
{"name":"pow_div_pow_eventuallyEq_atBot","module":"Mathlib.Analysis.Asymptotics.SpecificAsymptotics","initialProofState":"𝕜 : Type u_1\ninst✝ : LinearOrderedField 𝕜\np q : Nat\n⊢ Filter.atBot.EventuallyEq (fun x => HDiv.hDiv (HPow.hPow x p) (HPow.hPow x q)) fun x => HPow.hPow x (HSub.hSub ↑p ↑q)","decl":"theorem pow_div_pow_eventuallyEq_atBot {p q : ℕ} :\n    (fun x : 𝕜 => x ^ p / x ^ q) =ᶠ[atBot] fun x => x ^ ((p : ℤ) - q) := by\n  apply (eventually_lt_atBot (0 : 𝕜)).mono fun x hx => _\n  intro x hx\n  simp [zpow_sub₀ hx.ne]\n\n"}
{"name":"tendsto_pow_div_pow_atTop_atTop","module":"Mathlib.Analysis.Asymptotics.SpecificAsymptotics","initialProofState":"𝕜 : Type u_1\ninst✝ : LinearOrderedField 𝕜\np q : Nat\nhpq : LT.lt q p\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (HPow.hPow x p) (HPow.hPow x q)) Filter.atTop Filter.atTop","decl":"theorem tendsto_pow_div_pow_atTop_atTop {p q : ℕ} (hpq : q < p) :\n    Tendsto (fun x : 𝕜 => x ^ p / x ^ q) atTop atTop := by\n  rw [tendsto_congr' pow_div_pow_eventuallyEq_atTop]\n  apply tendsto_zpow_atTop_atTop\n  omega\n\n"}
{"name":"tendsto_pow_div_pow_atTop_zero","module":"Mathlib.Analysis.Asymptotics.SpecificAsymptotics","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\np q : Nat\nhpq : LT.lt p q\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (HPow.hPow x p) (HPow.hPow x q)) Filter.atTop (nhds 0)","decl":"theorem tendsto_pow_div_pow_atTop_zero [TopologicalSpace 𝕜] [OrderTopology 𝕜] {p q : ℕ}\n    (hpq : p < q) : Tendsto (fun x : 𝕜 => x ^ p / x ^ q) atTop (𝓝 0) := by\n  rw [tendsto_congr' pow_div_pow_eventuallyEq_atTop]\n  apply tendsto_zpow_atTop_zero\n  omega\n\n"}
{"name":"Asymptotics.isLittleO_pow_pow_atTop_of_lt","module":"Mathlib.Analysis.Asymptotics.SpecificAsymptotics","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NormedLinearOrderedField 𝕜\ninst✝ : OrderTopology 𝕜\np q : Nat\nhpq : LT.lt p q\n⊢ Asymptotics.IsLittleO Filter.atTop (fun x => HPow.hPow x p) fun x => HPow.hPow x q","decl":"theorem Asymptotics.isLittleO_pow_pow_atTop_of_lt [OrderTopology 𝕜] {p q : ℕ} (hpq : p < q) :\n    (fun x : 𝕜 => x ^ p) =o[atTop] fun x => x ^ q := by\n  refine (isLittleO_iff_tendsto' ?_).mpr (tendsto_pow_div_pow_atTop_zero hpq)\n  exact (eventually_gt_atTop 0).mono fun x hx hxq => (pow_ne_zero q hx.ne' hxq).elim\n\n"}
{"name":"Asymptotics.IsBigO.trans_tendsto_norm_atTop","module":"Mathlib.Analysis.Asymptotics.SpecificAsymptotics","initialProofState":"𝕜 : Type u_1\ninst✝ : NormedLinearOrderedField 𝕜\nα : Type u_2\nu v : α → 𝕜\nl : Filter α\nhuv : Asymptotics.IsBigO l u v\nhu : Filter.Tendsto (fun x => Norm.norm (u x)) l Filter.atTop\n⊢ Filter.Tendsto (fun x => Norm.norm (v x)) l Filter.atTop","decl":"theorem Asymptotics.IsBigO.trans_tendsto_norm_atTop {α : Type*} {u v : α → 𝕜} {l : Filter α}\n    (huv : u =O[l] v) (hu : Tendsto (fun x => ‖u x‖) l atTop) :\n    Tendsto (fun x => ‖v x‖) l atTop := by\n  rcases huv.exists_pos with ⟨c, hc, hcuv⟩\n  rw [IsBigOWith] at hcuv\n  convert Tendsto.atTop_div_const hc (tendsto_atTop_mono' l hcuv hu)\n  rw [mul_div_cancel_left₀ _ hc.ne.symm]\n\n"}
{"name":"Asymptotics.IsLittleO.sum_range","module":"Mathlib.Analysis.Asymptotics.SpecificAsymptotics","initialProofState":"α : Type u_1\ninst✝ : NormedAddCommGroup α\nf : Nat → α\ng : Nat → Real\nh : Asymptotics.IsLittleO Filter.atTop f g\nhg : LE.le 0 g\nh'g : Filter.Tendsto (fun n => (Finset.range n).sum fun i => g i) Filter.atTop Filter.atTop\n⊢ Asymptotics.IsLittleO Filter.atTop (fun n => (Finset.range n).sum fun i => f i) fun n => (Finset.range n).sum fun i => g i","decl":"theorem Asymptotics.IsLittleO.sum_range {α : Type*} [NormedAddCommGroup α] {f : ℕ → α} {g : ℕ → ℝ}\n    (h : f =o[atTop] g) (hg : 0 ≤ g) (h'g : Tendsto (fun n => ∑ i ∈ range n, g i) atTop atTop) :\n    (fun n => ∑ i ∈ range n, f i) =o[atTop] fun n => ∑ i ∈ range n, g i := by\n  have A : ∀ i, ‖g i‖ = g i := fun i => Real.norm_of_nonneg (hg i)\n  have B : ∀ n, ‖∑ i ∈ range n, g i‖ = ∑ i ∈ range n, g i := fun n => by\n    rwa [Real.norm_eq_abs, abs_sum_of_nonneg']\n  apply isLittleO_iff.2 fun ε εpos => _\n  intro ε εpos\n  obtain ⟨N, hN⟩ : ∃ N : ℕ, ∀ b : ℕ, N ≤ b → ‖f b‖ ≤ ε / 2 * g b := by\n    simpa only [A, eventually_atTop] using isLittleO_iff.mp h (half_pos εpos)\n  have : (fun _ : ℕ => ∑ i ∈ range N, f i) =o[atTop] fun n : ℕ => ∑ i ∈ range n, g i := by\n    apply isLittleO_const_left.2\n    exact Or.inr (h'g.congr fun n => (B n).symm)\n  filter_upwards [isLittleO_iff.1 this (half_pos εpos), Ici_mem_atTop N] with n hn Nn\n  calc\n    ‖∑ i ∈ range n, f i‖ = ‖(∑ i ∈ range N, f i) + ∑ i ∈ Ico N n, f i‖ := by\n      rw [sum_range_add_sum_Ico _ Nn]\n    _ ≤ ‖∑ i ∈ range N, f i‖ + ‖∑ i ∈ Ico N n, f i‖ := norm_add_le _ _\n    _ ≤ ‖∑ i ∈ range N, f i‖ + ∑ i ∈ Ico N n, ε / 2 * g i :=\n      (add_le_add le_rfl (norm_sum_le_of_le _ fun i hi => hN _ (mem_Ico.1 hi).1))\n    _ ≤ ‖∑ i ∈ range N, f i‖ + ∑ i ∈ range n, ε / 2 * g i := by\n      gcongr\n      · exact fun i _ _ ↦ mul_nonneg (half_pos εpos).le (hg i)\n      · rw [range_eq_Ico]\n        exact Ico_subset_Ico (zero_le _) le_rfl\n    _ ≤ ε / 2 * ‖∑ i ∈ range n, g i‖ + ε / 2 * ∑ i ∈ range n, g i := by rw [← mul_sum]; gcongr\n    _ = ε * ‖∑ i ∈ range n, g i‖ := by\n      simp only [B]\n      ring\n\n"}
{"name":"Asymptotics.isLittleO_sum_range_of_tendsto_zero","module":"Mathlib.Analysis.Asymptotics.SpecificAsymptotics","initialProofState":"α : Type u_1\ninst✝ : NormedAddCommGroup α\nf : Nat → α\nh : Filter.Tendsto f Filter.atTop (nhds 0)\n⊢ Asymptotics.IsLittleO Filter.atTop (fun n => (Finset.range n).sum fun i => f i) fun n => ↑n","decl":"theorem Asymptotics.isLittleO_sum_range_of_tendsto_zero {α : Type*} [NormedAddCommGroup α]\n    {f : ℕ → α} (h : Tendsto f atTop (𝓝 0)) :\n    (fun n => ∑ i ∈ range n, f i) =o[atTop] fun n => (n : ℝ) := by\n  have := ((isLittleO_one_iff ℝ).2 h).sum_range fun i => zero_le_one\n  simp only [sum_const, card_range, Nat.smul_one_eq_cast] at this\n  exact this tendsto_natCast_atTop_atTop\n\n"}
{"name":"Filter.Tendsto.cesaro_smul","module":"Mathlib.Analysis.Asymptotics.SpecificAsymptotics","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nu : Nat → E\nl : E\nh : Filter.Tendsto u Filter.atTop (nhds l)\n⊢ Filter.Tendsto (fun n => HSMul.hSMul (Inv.inv ↑n) ((Finset.range n).sum fun i => u i)) Filter.atTop (nhds l)","decl":"/-- The Cesaro average of a converging sequence converges to the same limit. -/\ntheorem Filter.Tendsto.cesaro_smul {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E] {u : ℕ → E}\n    {l : E} (h : Tendsto u atTop (𝓝 l)) :\n    Tendsto (fun n : ℕ => (n⁻¹ : ℝ) • ∑ i ∈ range n, u i) atTop (𝓝 l) := by\n  rw [← tendsto_sub_nhds_zero_iff, ← isLittleO_one_iff ℝ]\n  have := Asymptotics.isLittleO_sum_range_of_tendsto_zero (tendsto_sub_nhds_zero_iff.2 h)\n  apply ((isBigO_refl (fun n : ℕ => (n : ℝ)⁻¹) atTop).smul_isLittleO this).congr' _ _\n  · filter_upwards [Ici_mem_atTop 1] with n npos\n    have nposℝ : (0 : ℝ) < n := Nat.cast_pos.2 npos\n    simp only [smul_sub, sum_sub_distrib, sum_const, card_range, sub_right_inj]\n    rw [← Nat.cast_smul_eq_nsmul ℝ, smul_smul, inv_mul_cancel₀ nposℝ.ne', one_smul]\n  · filter_upwards [Ici_mem_atTop 1] with n npos\n    have nposℝ : (0 : ℝ) < n := Nat.cast_pos.2 npos\n    rw [Algebra.id.smul_eq_mul, inv_mul_cancel₀ nposℝ.ne']\n\n"}
{"name":"Filter.Tendsto.cesaro","module":"Mathlib.Analysis.Asymptotics.SpecificAsymptotics","initialProofState":"u : Nat → Real\nl : Real\nh : Filter.Tendsto u Filter.atTop (nhds l)\n⊢ Filter.Tendsto (fun n => HMul.hMul (Inv.inv ↑n) ((Finset.range n).sum fun i => u i)) Filter.atTop (nhds l)","decl":"/-- The Cesaro average of a converging sequence converges to the same limit. -/\ntheorem Filter.Tendsto.cesaro {u : ℕ → ℝ} {l : ℝ} (h : Tendsto u atTop (𝓝 l)) :\n    Tendsto (fun n : ℕ => (n⁻¹ : ℝ) * ∑ i ∈ range n, u i) atTop (𝓝 l) :=\n  h.cesaro_smul\n\n"}
{"name":"Asymptotics.isEquivalent_nat_floor","module":"Mathlib.Analysis.Asymptotics.SpecificAsymptotics","initialProofState":"R : Type u_1\ninst✝² : NormedLinearOrderedField R\ninst✝¹ : OrderTopology R\ninst✝ : FloorRing R\n⊢ Asymptotics.IsEquivalent Filter.atTop (fun x => ↑(Nat.floor x)) fun x => x","decl":"theorem Asymptotics.isEquivalent_nat_floor :\n    (fun (x : R) ↦ ↑⌊x⌋₊) ~[atTop] (fun x ↦ x) := by\n  refine isEquivalent_of_tendsto_one ?_ tendsto_nat_floor_div_atTop\n  filter_upwards with x hx using by rw [hx, Nat.floor_zero, Nat.cast_eq_zero]\n\n"}
{"name":"Asymptotics.isEquivalent_nat_ceil","module":"Mathlib.Analysis.Asymptotics.SpecificAsymptotics","initialProofState":"R : Type u_1\ninst✝² : NormedLinearOrderedField R\ninst✝¹ : OrderTopology R\ninst✝ : FloorRing R\n⊢ Asymptotics.IsEquivalent Filter.atTop (fun x => ↑(Nat.ceil x)) fun x => x","decl":"theorem Asymptotics.isEquivalent_nat_ceil :\n    (fun (x : R) ↦ ↑⌈x⌉₊) ~[atTop] (fun x ↦ x) := by\n  refine isEquivalent_of_tendsto_one ?_ tendsto_nat_ceil_div_atTop\n  filter_upwards with x hx using by rw [hx, Nat.ceil_zero, Nat.cast_eq_zero]\n\n"}
