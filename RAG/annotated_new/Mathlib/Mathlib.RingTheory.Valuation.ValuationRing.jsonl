{"name":"PreValuationRing.cond'","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"A : Type u\ninst✝ : Mul A\nself : PreValuationRing A\na b : A\n⊢ Exists fun c => Or (Eq (HMul.hMul a c) b) (Eq (HMul.hMul b c) a)","decl":"/-- A magma is called a `PreValuationRing` provided that for any pair\nof elements `a b : A`, either `a` divides `b` or vice versa. -/\nclass PreValuationRing (A : Type u) [Mul A] : Prop where\n  cond' : ∀ a b : A, ∃ c : A, a * c = b ∨ b * c = a\n\n"}
{"name":"PreValuationRing.cond","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"A : Type u\ninst✝¹ : Mul A\ninst✝ : PreValuationRing A\na b : A\n⊢ Exists fun c => Or (Eq (HMul.hMul a c) b) (Eq (HMul.hMul b c) a)","decl":"lemma PreValuationRing.cond {A : Type u} [Mul A] [PreValuationRing A] (a b : A) :\n    ∃ c : A, a * c = b ∨ b * c = a := @PreValuationRing.cond' A _ _ _ _\n\n"}
{"name":"ValuationRing.toPreValuationRing","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"A : Type u\ninst✝¹ : CommRing A\ninst✝ : IsDomain A\nself : ValuationRing A\n⊢ PreValuationRing A","decl":"/-- An integral domain is called a `ValuationRing` provided that for any pair\nof elements `a b : A`, either `a` divides `b` or vice versa. -/\nclass ValuationRing (A : Type u) [CommRing A] [IsDomain A] extends PreValuationRing A : Prop\n\n-- Porting note: this lemma is needed since infer kinds are unsupported in Lean 4\n"}
{"name":"ValuationRing.cond","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"A : Type u\ninst✝² : CommRing A\ninst✝¹ : IsDomain A\ninst✝ : ValuationRing A\na b : A\n⊢ Exists fun c => Or (Eq (HMul.hMul a c) b) (Eq (HMul.hMul b c) a)","decl":"lemma ValuationRing.cond {A : Type u} [CommRing A] [IsDomain A] [ValuationRing A] (a b : A) :\n    ∃ c : A, a * c = b ∨ b * c = a := PreValuationRing.cond _ _\n\n"}
{"name":"ValuationRing.le_total","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"A : Type u\ninst✝⁵ : CommRing A\nK : Type v\ninst✝⁴ : Field K\ninst✝³ : Algebra A K\ninst✝² : IsDomain A\ninst✝¹ : ValuationRing A\ninst✝ : IsFractionRing A K\na b : ValuationRing.ValueGroup A K\n⊢ Or (LE.le a b) (LE.le b a)","decl":"protected theorem le_total (a b : ValueGroup A K) : a ≤ b ∨ b ≤ a := by\n  rcases a with ⟨a⟩; rcases b with ⟨b⟩\n  obtain ⟨xa, ya, hya, rfl⟩ : ∃ a b : A, _ := IsFractionRing.div_surjective a\n  obtain ⟨xb, yb, hyb, rfl⟩ : ∃ a b : A, _ := IsFractionRing.div_surjective b\n  have : (algebraMap A K) ya ≠ 0 := IsFractionRing.to_map_ne_zero_of_mem_nonZeroDivisors hya\n  have : (algebraMap A K) yb ≠ 0 := IsFractionRing.to_map_ne_zero_of_mem_nonZeroDivisors hyb\n  obtain ⟨c, h | h⟩ := ValuationRing.cond (xa * yb) (xb * ya)\n  · right\n    use c\n    rw [Algebra.smul_def]\n    field_simp\n    simp only [← RingHom.map_mul, ← h]; congr 1; ring\n  · left\n    use c\n    rw [Algebra.smul_def]\n    field_simp\n    simp only [← RingHom.map_mul, ← h]; congr 1; ring\n\n-- Porting note: it is much faster to split the instance `LinearOrderedCommGroupWithZero`\n-- into two parts\n"}
{"name":"ValuationRing.mem_integer_iff","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"A : Type u\ninst✝⁵ : CommRing A\nK : Type v\ninst✝⁴ : Field K\ninst✝³ : Algebra A K\ninst✝² : IsDomain A\ninst✝¹ : ValuationRing A\ninst✝ : IsFractionRing A K\nx : K\n⊢ Iff (Membership.mem (ValuationRing.valuation A K).integer x) (Exists fun a => Eq ((algebraMap A K) a) x)","decl":"theorem mem_integer_iff (x : K) : x ∈ (valuation A K).integer ↔ ∃ a : A, algebraMap A K a = x := by\n  constructor\n  · rintro ⟨c, rfl⟩\n    use c\n    rw [Algebra.smul_def, mul_one]\n  · rintro ⟨c, rfl⟩\n    use c\n    rw [Algebra.smul_def, mul_one]\n\n"}
{"name":"ValuationRing.coe_equivInteger_apply","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"A : Type u\ninst✝⁵ : CommRing A\nK : Type v\ninst✝⁴ : Field K\ninst✝³ : Algebra A K\ninst✝² : IsDomain A\ninst✝¹ : ValuationRing A\ninst✝ : IsFractionRing A K\na : A\n⊢ Eq (↑((ValuationRing.equivInteger A K) a)) ((algebraMap A K) a)","decl":"@[simp]\ntheorem coe_equivInteger_apply (a : A) : (equivInteger A K a : K) = algebraMap A K a := rfl\n\n"}
{"name":"ValuationRing.range_algebraMap_eq","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"A : Type u\ninst✝⁵ : CommRing A\nK : Type v\ninst✝⁴ : Field K\ninst✝³ : Algebra A K\ninst✝² : IsDomain A\ninst✝¹ : ValuationRing A\ninst✝ : IsFractionRing A K\n⊢ Eq (ValuationRing.valuation A K).integer (algebraMap A K).range","decl":"theorem range_algebraMap_eq : (valuation A K).integer = (algebraMap A K).range := by\n  ext; exact mem_integer_iff _ _ _\n\n"}
{"name":"ValuationRing.isLocalRing","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"A : Type u\ninst✝¹ : CommRing A\ninst✝ : Nontrivial A\n⊢ IsLocalRing A","decl":"instance (priority := 100) isLocalRing : IsLocalRing A :=\n  IsLocalRing.of_isUnit_or_isUnit_one_sub_self\n    (by\n      intro a\n      obtain ⟨c, h | h⟩ := PreValuationRing.cond a (1 - a)\n      · left\n        apply isUnit_of_mul_eq_one _ (c + 1)\n        simp [mul_add, h]\n      · right\n        apply isUnit_of_mul_eq_one _ (c + 1)\n        simp [mul_add, h])\n\n"}
{"name":"ValuationRing.le_total_ideal","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"A : Type u\ninst✝ : CommRing A\n⊢ IsTotal (Ideal A) LE.le","decl":"instance le_total_ideal : IsTotal (Ideal A) LE.le := by\n  constructor; intro α β\n  by_cases h : α ≤ β; · exact Or.inl h\n  erw [not_forall] at h\n  push_neg at h\n  obtain ⟨a, h₁, h₂⟩ := h\n  right\n  intro b hb\n  obtain ⟨c, h | h⟩ := PreValuationRing.cond a b\n  · rw [← h]\n    exact Ideal.mul_mem_right _ _ h₁\n  · exfalso; apply h₂; rw [← h]\n    apply Ideal.mul_mem_right _ _ hb\n\n"}
{"name":"PreValuationRing.iff_dvd_total","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"R : Type u_1\ninst✝ : Monoid R\n⊢ Iff (PreValuationRing R) (IsTotal R fun x1 x2 => Dvd.dvd x1 x2)","decl":"theorem _root_.PreValuationRing.iff_dvd_total [Monoid R] :\n    PreValuationRing R ↔ IsTotal R (· ∣ ·) := by\n  classical\n  refine ⟨fun H => ⟨fun a b => ?_⟩, fun H => ⟨fun a b => ?_⟩⟩\n  · obtain ⟨c, rfl | rfl⟩ := PreValuationRing.cond a b <;> simp\n  · obtain ⟨c, rfl⟩ | ⟨c, rfl⟩ := @IsTotal.total _ _ H a b <;> use c <;> simp\n\n"}
{"name":"PreValuationRing.iff_ideal_total","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Iff (PreValuationRing R) (IsTotal (Ideal R) fun x1 x2 => LE.le x1 x2)","decl":"theorem _root_.PreValuationRing.iff_ideal_total [CommRing R] :\n    PreValuationRing R ↔ IsTotal (Ideal R) (· ≤ ·) := by\n  classical\n  refine ⟨fun _ => ⟨le_total⟩, fun H => PreValuationRing.iff_dvd_total.mpr ⟨fun a b => ?_⟩⟩\n  have := @IsTotal.total _ _ H (Ideal.span {a}) (Ideal.span {b})\n  simp_rw [Ideal.span_singleton_le_span_singleton] at this\n  exact this.symm\n\n"}
{"name":"ValuationRing.dvd_total","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"R : Type u_1\ninst✝ : Monoid R\nh : PreValuationRing R\nx y : R\n⊢ Or (Dvd.dvd x y) (Dvd.dvd y x)","decl":"theorem dvd_total [Monoid R] [h : PreValuationRing R] (x y : R) : x ∣ y ∨ y ∣ x :=\n  @IsTotal.total _ _ (PreValuationRing.iff_dvd_total.mp h) x y\n\n"}
{"name":"ValuationRing.iff_dvd_total","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ Iff (ValuationRing R) (IsTotal R fun x1 x2 => Dvd.dvd x1 x2)","decl":"theorem iff_dvd_total : ValuationRing R ↔ IsTotal R (· ∣ ·) :=\n  Iff.trans (⟨fun inst ↦ inst.toPreValuationRing, fun _ ↦ .mk⟩)\n    PreValuationRing.iff_dvd_total\n\n"}
{"name":"ValuationRing.iff_ideal_total","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ Iff (ValuationRing R) (IsTotal (Ideal R) fun x1 x2 => LE.le x1 x2)","decl":"theorem iff_ideal_total : ValuationRing R ↔ IsTotal (Ideal R) (· ≤ ·) :=\n  Iff.trans (⟨fun inst ↦ inst.toPreValuationRing, fun _ ↦ .mk⟩)\n    PreValuationRing.iff_ideal_total\n\n"}
{"name":"ValuationRing.unique_irreducible","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : ValuationRing R\np q : R\nhp : Irreducible p\nhq : Irreducible q\n⊢ Associated p q","decl":"theorem unique_irreducible [ValuationRing R] ⦃p q : R⦄ (hp : Irreducible p) (hq : Irreducible q) :\n    Associated p q := by\n  have := dvd_total p q\n  rw [Irreducible.dvd_comm hp hq, or_self_iff] at this\n  exact associated_of_dvd_dvd (Irreducible.dvd_symm hq hp this) this\n\n"}
{"name":"ValuationRing.iff_isInteger_or_isInteger","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDomain R\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\n⊢ Iff (ValuationRing R) (∀ (x : K), Or (IsLocalization.IsInteger R x) (IsLocalization.IsInteger R (Inv.inv x)))","decl":"theorem iff_isInteger_or_isInteger :\n    ValuationRing R ↔ ∀ x : K, IsLocalization.IsInteger R x ∨ IsLocalization.IsInteger R x⁻¹ := by\n  constructor\n  · intro H x\n    obtain ⟨x : R, y, hy, rfl⟩ := IsFractionRing.div_surjective (A := R) x\n    have := (map_ne_zero_iff _ (IsFractionRing.injective R K)).mpr (nonZeroDivisors.ne_zero hy)\n    obtain ⟨s, rfl | rfl⟩ := ValuationRing.cond x y\n    · exact Or.inr\n        ⟨s, eq_inv_of_mul_eq_one_left <| by rwa [mul_div, div_eq_one_iff_eq, map_mul, mul_comm]⟩\n    · exact Or.inl ⟨s, by rwa [eq_div_iff, map_mul, mul_comm]⟩\n  · intro H\n    suffices PreValuationRing R from mk\n    constructor\n    intro a b\n    by_cases ha : a = 0; · subst ha; exact ⟨0, Or.inr <| mul_zero b⟩\n    by_cases hb : b = 0; · subst hb; exact ⟨0, Or.inl <| mul_zero a⟩\n    replace ha := (map_ne_zero_iff _ (IsFractionRing.injective R K)).mpr ha\n    replace hb := (map_ne_zero_iff _ (IsFractionRing.injective R K)).mpr hb\n    obtain ⟨c, e⟩ | ⟨c, e⟩ := H (algebraMap R K a / algebraMap R K b)\n    · rw [eq_div_iff hb, ← map_mul, (IsFractionRing.injective R K).eq_iff, mul_comm] at e\n      exact ⟨c, Or.inr e⟩\n    · rw [inv_div, eq_div_iff ha, ← map_mul, (IsFractionRing.injective R K).eq_iff, mul_comm c] at e\n      exact ⟨c, Or.inl e⟩\n\n"}
{"name":"ValuationRing.isInteger_or_isInteger","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDomain R\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nh : ValuationRing R\nx : K\n⊢ Or (IsLocalization.IsInteger R x) (IsLocalization.IsInteger R (Inv.inv x))","decl":"theorem isInteger_or_isInteger [h : ValuationRing R] (x : K) :\n    IsLocalization.IsInteger R x ∨ IsLocalization.IsInteger R x⁻¹ :=\n  (iff_isInteger_or_isInteger R K).mp h x\n\n"}
{"name":"ValuationRing.instIsBezout","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : ValuationRing R\n⊢ IsBezout R","decl":"instance (priority := 100) [ValuationRing R] : IsBezout R := by\n  classical\n  rw [IsBezout.iff_span_pair_isPrincipal]\n  intro x y\n  rw [Ideal.span_insert]\n  rcases le_total (Ideal.span {x} : Ideal R) (Ideal.span {y}) with h | h\n  · rw [sup_eq_right.mpr h]; exact ⟨⟨_, rfl⟩⟩\n  · rw [sup_eq_left.mpr h]; exact ⟨⟨_, rfl⟩⟩\n\n"}
{"name":"ValuationRing.instOfIsLocalRingOfIsBezout","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\ninst✝² : IsDomain R\ninst✝¹ : IsLocalRing R\ninst✝ : IsBezout R\n⊢ ValuationRing R","decl":"instance (priority := 100) [IsLocalRing R] [IsBezout R] : ValuationRing R := by\n  classical\n  refine iff_dvd_total.mpr ⟨fun a b => ?_⟩\n  obtain ⟨g, e : _ = Ideal.span _⟩ := IsBezout.span_pair_isPrincipal a b\n  obtain ⟨a, rfl⟩ := Ideal.mem_span_singleton'.mp\n      (show a ∈ Ideal.span {g} by rw [← e]; exact Ideal.subset_span (by simp))\n  obtain ⟨b, rfl⟩ := Ideal.mem_span_singleton'.mp\n      (show b ∈ Ideal.span {g} by rw [← e]; exact Ideal.subset_span (by simp))\n  obtain ⟨x, y, e'⟩ := Ideal.mem_span_pair.mp\n      (show g ∈ Ideal.span {a * g, b * g} by rw [e]; exact Ideal.subset_span (by simp))\n  rcases eq_or_ne g 0 with h | h\n  · simp [h]\n  have : x * a + y * b = 1 := by\n    apply mul_left_injective₀ h; convert e' using 1 <;> ring\n  cases' IsLocalRing.isUnit_or_isUnit_of_add_one this with h' h' <;> [left; right]\n  all_goals exact mul_dvd_mul_right (isUnit_iff_forall_dvd.mp (isUnit_of_mul_isUnit_right h') _) _\n\n"}
{"name":"ValuationRing.iff_local_bezout_domain","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ Iff (ValuationRing R) (And (IsLocalRing R) (IsBezout R))","decl":"theorem iff_local_bezout_domain : ValuationRing R ↔ IsLocalRing R ∧ IsBezout R :=\n  ⟨fun _ ↦ ⟨inferInstance, inferInstance⟩, fun ⟨_, _⟩ ↦ inferInstance⟩\n\n"}
{"name":"ValuationRing.TFAE","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ (List.cons (ValuationRing R) (List.cons (∀ (x : FractionRing R), Or (IsLocalization.IsInteger R x) (IsLocalization.IsInteger R (Inv.inv x))) (List.cons (IsTotal R fun x1 x2 => Dvd.dvd x1 x2) (List.cons (IsTotal (Ideal R) fun x1 x2 => LE.le x1 x2) (List.cons (And (IsLocalRing R) (IsBezout R)) List.nil))))).TFAE","decl":"protected theorem TFAE (R : Type u) [CommRing R] [IsDomain R] :\n    List.TFAE\n      [ValuationRing R,\n        ∀ x : FractionRing R, IsLocalization.IsInteger R x ∨ IsLocalization.IsInteger R x⁻¹,\n        IsTotal R (· ∣ ·), IsTotal (Ideal R) (· ≤ ·), IsLocalRing R ∧ IsBezout R] := by\n  tfae_have 1 ↔ 2 := iff_isInteger_or_isInteger R _\n  tfae_have 1 ↔ 3 := iff_dvd_total\n  tfae_have 1 ↔ 4 := iff_ideal_total\n  tfae_have 1 ↔ 5 := iff_local_bezout_domain\n  tfae_finish\n\n"}
{"name":"Function.Surjective.preValuationRing","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : Mul R\ninst✝¹ : PreValuationRing R\ninst✝ : Mul S\nf : MulHom R S\nhf : Function.Surjective ⇑f\n⊢ PreValuationRing S","decl":"theorem _root_.Function.Surjective.preValuationRing {R S : Type*} [Mul R] [PreValuationRing R]\n    [Mul S] (f : R →ₙ* S) (hf : Function.Surjective f) :\n    PreValuationRing S :=\n  ⟨fun a b => by\n    obtain ⟨⟨a, rfl⟩, ⟨b, rfl⟩⟩ := hf a, hf b\n    obtain ⟨c, rfl | rfl⟩ := PreValuationRing.cond a b\n    exacts [⟨f c, Or.inl <| (map_mul _ _ _).symm⟩, ⟨f c, Or.inr <| (map_mul _ _ _).symm⟩]⟩\n\n"}
{"name":"Function.Surjective.valuationRing","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : IsDomain R\ninst✝² : ValuationRing R\ninst✝¹ : CommRing S\ninst✝ : IsDomain S\nf : RingHom R S\nhf : Function.Surjective ⇑f\n⊢ ValuationRing S","decl":"theorem _root_.Function.Surjective.valuationRing {R S : Type*} [CommRing R] [IsDomain R]\n    [ValuationRing R] [CommRing S] [IsDomain S] (f : R →+* S) (hf : Function.Surjective f) :\n    ValuationRing S :=\n  have : PreValuationRing S := Function.Surjective.preValuationRing (R := R) f hf\n  .mk\n\n"}
{"name":"ValuationRing.of_integers","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"𝒪 : Type u\nK : Type v\nΓ : Type w\ninst✝⁴ : CommRing 𝒪\ninst✝³ : IsDomain 𝒪\ninst✝² : Field K\ninst✝¹ : Algebra 𝒪 K\ninst✝ : LinearOrderedCommGroupWithZero Γ\nv : Valuation K Γ\nhh : v.Integers 𝒪\n⊢ ValuationRing 𝒪","decl":"/-- If `𝒪` satisfies `v.integers 𝒪` where `v` is a valuation on a field, then `𝒪`\nis a valuation ring. -/\ntheorem of_integers (v : Valuation K Γ) (hh : v.Integers 𝒪) : ValuationRing 𝒪 := by\n  suffices PreValuationRing 𝒪 from .mk\n  constructor\n  intro a b\n  rcases le_total (v (algebraMap 𝒪 K a)) (v (algebraMap 𝒪 K b)) with h | h\n  · obtain ⟨c, hc⟩ := Valuation.Integers.dvd_of_le hh h\n    use c; exact Or.inr hc.symm\n  · obtain ⟨c, hc⟩ := Valuation.Integers.dvd_of_le hh h\n    use c; exact Or.inl hc.symm\n\n"}
{"name":"ValuationRing.instValuationRingInteger","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"K : Type v\nΓ : Type w\ninst✝¹ : Field K\ninst✝ : LinearOrderedCommGroupWithZero Γ\nv : Valuation K Γ\n⊢ ValuationRing (Subtype fun x => Membership.mem v.integer x)","decl":"instance instValuationRingInteger (v : Valuation K Γ) : ValuationRing v.integer :=\n  of_integers (v := v) (Valuation.integer.integers v)\n\n"}
{"name":"ValuationRing.isFractionRing_iff","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"𝒪 : Type u\nK : Type v\ninst✝⁴ : CommRing 𝒪\ninst✝³ : IsDomain 𝒪\ninst✝² : Field K\ninst✝¹ : Algebra 𝒪 K\ninst✝ : ValuationRing 𝒪\n⊢ Iff (IsFractionRing 𝒪 K) (And (∀ (x : K), Exists fun a => Or (Eq x ((algebraMap 𝒪 K) a)) (Eq (Inv.inv x) ((algebraMap 𝒪 K) a))) (Function.Injective ⇑(algebraMap 𝒪 K)))","decl":"theorem isFractionRing_iff [ValuationRing 𝒪] :\n    IsFractionRing 𝒪 K ↔\n      (∀ (x : K), ∃ a : 𝒪, x = algebraMap 𝒪 K a ∨ x⁻¹ = algebraMap 𝒪 K a) ∧\n        Function.Injective (algebraMap 𝒪 K) := by\n  refine ⟨fun h ↦ ⟨fun x ↦ ?_, IsFractionRing.injective _ _⟩, fun h ↦ ?_⟩\n  · obtain (⟨a, e⟩ | ⟨a, e⟩) := isInteger_or_isInteger 𝒪 x\n    exacts [⟨a, .inl e.symm⟩, ⟨a, .inr e.symm⟩]\n  · constructor\n    · intro a\n      simpa using h.2.ne_iff.mpr (nonZeroDivisors.ne_zero a.2)\n    · intro x\n      obtain ⟨a, ha⟩ := h.1 x\n      by_cases h0 : a = 0\n      · exact ⟨⟨0, 1⟩, by simpa [h0] using ha⟩\n      · have : algebraMap 𝒪 K a ≠ 0 := by simpa using h.2.ne_iff.mpr h0\n        rw [inv_eq_iff_eq_inv, ← one_div, eq_div_iff this] at ha\n        cases ha with\n        | inl ha => exact ⟨⟨a, 1⟩, by simpa⟩\n        | inr ha => exact ⟨⟨1, ⟨a, mem_nonZeroDivisors_of_ne_zero h0⟩⟩, by simpa using ha⟩\n    · intro _ _ hab\n      exact ⟨1, by simp only [OneMemClass.coe_one, h.2 hab, one_mul]⟩\n\n"}
{"name":"ValuationRing.instIsFractionRingInteger","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"K : Type v\nΓ : Type w\ninst✝¹ : Field K\ninst✝ : LinearOrderedCommGroupWithZero Γ\nv : Valuation K Γ\n⊢ IsFractionRing (Subtype fun x => Membership.mem v.integer x) K","decl":"instance instIsFractionRingInteger (v : Valuation K Γ) : IsFractionRing v.integer K :=\n  ValuationRing.isFractionRing_iff.mpr\n    ⟨Valuation.Integers.eq_algebraMap_or_inv_eq_algebraMap (Valuation.integer.integers v),\n    Subtype.coe_injective⟩\n\n"}
{"name":"ValuationRing.of_field","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"K : Type u\ninst✝ : Field K\n⊢ ValuationRing K","decl":"/-- A field is a valuation ring. -/\ninstance (priority := 100) of_field : ValuationRing K := inferInstance\n\n"}
