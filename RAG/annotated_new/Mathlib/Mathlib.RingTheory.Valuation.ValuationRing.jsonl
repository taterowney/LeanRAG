{"name":"PreValuationRing.cond'","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"A : Type u\ninst‚úù : Mul A\nself : PreValuationRing A\na b : A\n‚ä¢ Exists fun c => Or (Eq (HMul.hMul a c) b) (Eq (HMul.hMul b c) a)","decl":"/-- A magma is called a `PreValuationRing` provided that for any pair\nof elements `a b : A`, either `a` divides `b` or vice versa. -/\nclass PreValuationRing (A : Type u) [Mul A] : Prop where\n  cond' : ‚àÄ a b : A, ‚àÉ c : A, a * c = b ‚à® b * c = a\n\n"}
{"name":"PreValuationRing.cond","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"A : Type u\ninst‚úù¬π : Mul A\ninst‚úù : PreValuationRing A\na b : A\n‚ä¢ Exists fun c => Or (Eq (HMul.hMul a c) b) (Eq (HMul.hMul b c) a)","decl":"lemma PreValuationRing.cond {A : Type u} [Mul A] [PreValuationRing A] (a b : A) :\n    ‚àÉ c : A, a * c = b ‚à® b * c = a := @PreValuationRing.cond' A _ _ _ _\n\n"}
{"name":"ValuationRing.toPreValuationRing","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"A : Type u\ninst‚úù¬π : CommRing A\ninst‚úù : IsDomain A\nself : ValuationRing A\n‚ä¢ PreValuationRing A","decl":"/-- An integral domain is called a `ValuationRing` provided that for any pair\nof elements `a b : A`, either `a` divides `b` or vice versa. -/\nclass ValuationRing (A : Type u) [CommRing A] [IsDomain A] extends PreValuationRing A : Prop\n\n-- Porting note: this lemma is needed since infer kinds are unsupported in Lean 4\n"}
{"name":"ValuationRing.cond","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"A : Type u\ninst‚úù¬≤ : CommRing A\ninst‚úù¬π : IsDomain A\ninst‚úù : ValuationRing A\na b : A\n‚ä¢ Exists fun c => Or (Eq (HMul.hMul a c) b) (Eq (HMul.hMul b c) a)","decl":"lemma ValuationRing.cond {A : Type u} [CommRing A] [IsDomain A] [ValuationRing A] (a b : A) :\n    ‚àÉ c : A, a * c = b ‚à® b * c = a := PreValuationRing.cond _ _\n\n"}
{"name":"ValuationRing.le_total","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"A : Type u\ninst‚úù‚Åµ : CommRing A\nK : Type v\ninst‚úù‚Å¥ : Field K\ninst‚úù¬≥ : Algebra A K\ninst‚úù¬≤ : IsDomain A\ninst‚úù¬π : ValuationRing A\ninst‚úù : IsFractionRing A K\na b : ValuationRing.ValueGroup A K\n‚ä¢ Or (LE.le a b) (LE.le b a)","decl":"protected theorem le_total (a b : ValueGroup A K) : a ‚â§ b ‚à® b ‚â§ a := by\n  rcases a with ‚ü®a‚ü©; rcases b with ‚ü®b‚ü©\n  obtain ‚ü®xa, ya, hya, rfl‚ü© : ‚àÉ a b : A, _ := IsFractionRing.div_surjective a\n  obtain ‚ü®xb, yb, hyb, rfl‚ü© : ‚àÉ a b : A, _ := IsFractionRing.div_surjective b\n  have : (algebraMap A K) ya ‚â† 0 := IsFractionRing.to_map_ne_zero_of_mem_nonZeroDivisors hya\n  have : (algebraMap A K) yb ‚â† 0 := IsFractionRing.to_map_ne_zero_of_mem_nonZeroDivisors hyb\n  obtain ‚ü®c, h | h‚ü© := ValuationRing.cond (xa * yb) (xb * ya)\n  ¬∑ right\n    use c\n    rw [Algebra.smul_def]\n    field_simp\n    simp only [‚Üê RingHom.map_mul, ‚Üê h]; congr 1; ring\n  ¬∑ left\n    use c\n    rw [Algebra.smul_def]\n    field_simp\n    simp only [‚Üê RingHom.map_mul, ‚Üê h]; congr 1; ring\n\n-- Porting note: it is much faster to split the instance `LinearOrderedCommGroupWithZero`\n-- into two parts\n"}
{"name":"ValuationRing.mem_integer_iff","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"A : Type u\ninst‚úù‚Åµ : CommRing A\nK : Type v\ninst‚úù‚Å¥ : Field K\ninst‚úù¬≥ : Algebra A K\ninst‚úù¬≤ : IsDomain A\ninst‚úù¬π : ValuationRing A\ninst‚úù : IsFractionRing A K\nx : K\n‚ä¢ Iff (Membership.mem (ValuationRing.valuation A K).integer x) (Exists fun a => Eq ((algebraMap A K) a) x)","decl":"theorem mem_integer_iff (x : K) : x ‚àà (valuation A K).integer ‚Üî ‚àÉ a : A, algebraMap A K a = x := by\n  constructor\n  ¬∑ rintro ‚ü®c, rfl‚ü©\n    use c\n    rw [Algebra.smul_def, mul_one]\n  ¬∑ rintro ‚ü®c, rfl‚ü©\n    use c\n    rw [Algebra.smul_def, mul_one]\n\n"}
{"name":"ValuationRing.coe_equivInteger_apply","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"A : Type u\ninst‚úù‚Åµ : CommRing A\nK : Type v\ninst‚úù‚Å¥ : Field K\ninst‚úù¬≥ : Algebra A K\ninst‚úù¬≤ : IsDomain A\ninst‚úù¬π : ValuationRing A\ninst‚úù : IsFractionRing A K\na : A\n‚ä¢ Eq (‚Üë((ValuationRing.equivInteger A K) a)) ((algebraMap A K) a)","decl":"@[simp]\ntheorem coe_equivInteger_apply (a : A) : (equivInteger A K a : K) = algebraMap A K a := rfl\n\n"}
{"name":"ValuationRing.range_algebraMap_eq","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"A : Type u\ninst‚úù‚Åµ : CommRing A\nK : Type v\ninst‚úù‚Å¥ : Field K\ninst‚úù¬≥ : Algebra A K\ninst‚úù¬≤ : IsDomain A\ninst‚úù¬π : ValuationRing A\ninst‚úù : IsFractionRing A K\n‚ä¢ Eq (ValuationRing.valuation A K).integer (algebraMap A K).range","decl":"theorem range_algebraMap_eq : (valuation A K).integer = (algebraMap A K).range := by\n  ext; exact mem_integer_iff _ _ _\n\n"}
{"name":"ValuationRing.isLocalRing","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"A : Type u\ninst‚úù¬π : CommRing A\ninst‚úù : Nontrivial A\n‚ä¢ IsLocalRing A","decl":"instance (priority := 100) isLocalRing : IsLocalRing A :=\n  IsLocalRing.of_isUnit_or_isUnit_one_sub_self\n    (by\n      intro a\n      obtain ‚ü®c, h | h‚ü© := PreValuationRing.cond a (1 - a)\n      ¬∑ left\n        apply isUnit_of_mul_eq_one _ (c + 1)\n        simp [mul_add, h]\n      ¬∑ right\n        apply isUnit_of_mul_eq_one _ (c + 1)\n        simp [mul_add, h])\n\n"}
{"name":"ValuationRing.le_total_ideal","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"A : Type u\ninst‚úù : CommRing A\n‚ä¢ IsTotal (Ideal A) LE.le","decl":"instance le_total_ideal : IsTotal (Ideal A) LE.le := by\n  constructor; intro Œ± Œ≤\n  by_cases h : Œ± ‚â§ Œ≤; ¬∑ exact Or.inl h\n  erw [not_forall] at h\n  push_neg at h\n  obtain ‚ü®a, h‚ÇÅ, h‚ÇÇ‚ü© := h\n  right\n  intro b hb\n  obtain ‚ü®c, h | h‚ü© := PreValuationRing.cond a b\n  ¬∑ rw [‚Üê h]\n    exact Ideal.mul_mem_right _ _ h‚ÇÅ\n  ¬∑ exfalso; apply h‚ÇÇ; rw [‚Üê h]\n    apply Ideal.mul_mem_right _ _ hb\n\n"}
{"name":"PreValuationRing.iff_dvd_total","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"R : Type u_1\ninst‚úù : Monoid R\n‚ä¢ Iff (PreValuationRing R) (IsTotal R fun x1 x2 => Dvd.dvd x1 x2)","decl":"theorem _root_.PreValuationRing.iff_dvd_total [Monoid R] :\n    PreValuationRing R ‚Üî IsTotal R (¬∑ ‚à£ ¬∑) := by\n  classical\n  refine ‚ü®fun H => ‚ü®fun a b => ?_‚ü©, fun H => ‚ü®fun a b => ?_‚ü©‚ü©\n  ¬∑ obtain ‚ü®c, rfl | rfl‚ü© := PreValuationRing.cond a b <;> simp\n  ¬∑ obtain ‚ü®c, rfl‚ü© | ‚ü®c, rfl‚ü© := @IsTotal.total _ _ H a b <;> use c <;> simp\n\n"}
{"name":"PreValuationRing.iff_ideal_total","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\n‚ä¢ Iff (PreValuationRing R) (IsTotal (Ideal R) fun x1 x2 => LE.le x1 x2)","decl":"theorem _root_.PreValuationRing.iff_ideal_total [CommRing R] :\n    PreValuationRing R ‚Üî IsTotal (Ideal R) (¬∑ ‚â§ ¬∑) := by\n  classical\n  refine ‚ü®fun _ => ‚ü®le_total‚ü©, fun H => PreValuationRing.iff_dvd_total.mpr ‚ü®fun a b => ?_‚ü©‚ü©\n  have := @IsTotal.total _ _ H (Ideal.span {a}) (Ideal.span {b})\n  simp_rw [Ideal.span_singleton_le_span_singleton] at this\n  exact this.symm\n\n"}
{"name":"ValuationRing.dvd_total","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"R : Type u_1\ninst‚úù : Monoid R\nh : PreValuationRing R\nx y : R\n‚ä¢ Or (Dvd.dvd x y) (Dvd.dvd y x)","decl":"theorem dvd_total [Monoid R] [h : PreValuationRing R] (x y : R) : x ‚à£ y ‚à® y ‚à£ x :=\n  @IsTotal.total _ _ (PreValuationRing.iff_dvd_total.mp h) x y\n\n"}
{"name":"ValuationRing.iff_dvd_total","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"R : Type u_1\ninst‚úù¬π : CommRing R\ninst‚úù : IsDomain R\n‚ä¢ Iff (ValuationRing R) (IsTotal R fun x1 x2 => Dvd.dvd x1 x2)","decl":"theorem iff_dvd_total : ValuationRing R ‚Üî IsTotal R (¬∑ ‚à£ ¬∑) :=\n  Iff.trans (‚ü®fun inst ‚Ü¶ inst.toPreValuationRing, fun _ ‚Ü¶ .mk‚ü©)\n    PreValuationRing.iff_dvd_total\n\n"}
{"name":"ValuationRing.iff_ideal_total","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"R : Type u_1\ninst‚úù¬π : CommRing R\ninst‚úù : IsDomain R\n‚ä¢ Iff (ValuationRing R) (IsTotal (Ideal R) fun x1 x2 => LE.le x1 x2)","decl":"theorem iff_ideal_total : ValuationRing R ‚Üî IsTotal (Ideal R) (¬∑ ‚â§ ¬∑) :=\n  Iff.trans (‚ü®fun inst ‚Ü¶ inst.toPreValuationRing, fun _ ‚Ü¶ .mk‚ü©)\n    PreValuationRing.iff_ideal_total\n\n"}
{"name":"ValuationRing.unique_irreducible","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"R : Type u_1\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : IsDomain R\ninst‚úù : ValuationRing R\np q : R\nhp : Irreducible p\nhq : Irreducible q\n‚ä¢ Associated p q","decl":"theorem unique_irreducible [ValuationRing R] ‚¶Ép q : R‚¶Ñ (hp : Irreducible p) (hq : Irreducible q) :\n    Associated p q := by\n  have := dvd_total p q\n  rw [Irreducible.dvd_comm hp hq, or_self_iff] at this\n  exact associated_of_dvd_dvd (Irreducible.dvd_symm hq hp this) this\n\n"}
{"name":"ValuationRing.iff_isInteger_or_isInteger","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"R : Type u_1\ninst‚úù‚Å¥ : CommRing R\ninst‚úù¬≥ : IsDomain R\nK : Type u_2\ninst‚úù¬≤ : Field K\ninst‚úù¬π : Algebra R K\ninst‚úù : IsFractionRing R K\n‚ä¢ Iff (ValuationRing R) (‚àÄ (x : K), Or (IsLocalization.IsInteger R x) (IsLocalization.IsInteger R (Inv.inv x)))","decl":"theorem iff_isInteger_or_isInteger :\n    ValuationRing R ‚Üî ‚àÄ x : K, IsLocalization.IsInteger R x ‚à® IsLocalization.IsInteger R x‚Åª¬π := by\n  constructor\n  ¬∑ intro H x\n    obtain ‚ü®x : R, y, hy, rfl‚ü© := IsFractionRing.div_surjective (A := R) x\n    have := (map_ne_zero_iff _ (IsFractionRing.injective R K)).mpr (nonZeroDivisors.ne_zero hy)\n    obtain ‚ü®s, rfl | rfl‚ü© := ValuationRing.cond x y\n    ¬∑ exact Or.inr\n        ‚ü®s, eq_inv_of_mul_eq_one_left <| by rwa [mul_div, div_eq_one_iff_eq, map_mul, mul_comm]‚ü©\n    ¬∑ exact Or.inl ‚ü®s, by rwa [eq_div_iff, map_mul, mul_comm]‚ü©\n  ¬∑ intro H\n    suffices PreValuationRing R from mk\n    constructor\n    intro a b\n    by_cases ha : a = 0; ¬∑ subst ha; exact ‚ü®0, Or.inr <| mul_zero b‚ü©\n    by_cases hb : b = 0; ¬∑ subst hb; exact ‚ü®0, Or.inl <| mul_zero a‚ü©\n    replace ha := (map_ne_zero_iff _ (IsFractionRing.injective R K)).mpr ha\n    replace hb := (map_ne_zero_iff _ (IsFractionRing.injective R K)).mpr hb\n    obtain ‚ü®c, e‚ü© | ‚ü®c, e‚ü© := H (algebraMap R K a / algebraMap R K b)\n    ¬∑ rw [eq_div_iff hb, ‚Üê map_mul, (IsFractionRing.injective R K).eq_iff, mul_comm] at e\n      exact ‚ü®c, Or.inr e‚ü©\n    ¬∑ rw [inv_div, eq_div_iff ha, ‚Üê map_mul, (IsFractionRing.injective R K).eq_iff, mul_comm c] at e\n      exact ‚ü®c, Or.inl e‚ü©\n\n"}
{"name":"ValuationRing.isInteger_or_isInteger","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"R : Type u_1\ninst‚úù‚Å¥ : CommRing R\ninst‚úù¬≥ : IsDomain R\nK : Type u_2\ninst‚úù¬≤ : Field K\ninst‚úù¬π : Algebra R K\ninst‚úù : IsFractionRing R K\nh : ValuationRing R\nx : K\n‚ä¢ Or (IsLocalization.IsInteger R x) (IsLocalization.IsInteger R (Inv.inv x))","decl":"theorem isInteger_or_isInteger [h : ValuationRing R] (x : K) :\n    IsLocalization.IsInteger R x ‚à® IsLocalization.IsInteger R x‚Åª¬π :=\n  (iff_isInteger_or_isInteger R K).mp h x\n\n"}
{"name":"ValuationRing.instIsBezout","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"R : Type u_1\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : IsDomain R\ninst‚úù : ValuationRing R\n‚ä¢ IsBezout R","decl":"instance (priority := 100) [ValuationRing R] : IsBezout R := by\n  classical\n  rw [IsBezout.iff_span_pair_isPrincipal]\n  intro x y\n  rw [Ideal.span_insert]\n  rcases le_total (Ideal.span {x} : Ideal R) (Ideal.span {y}) with h | h\n  ¬∑ rw [sup_eq_right.mpr h]; exact ‚ü®‚ü®_, rfl‚ü©‚ü©\n  ¬∑ rw [sup_eq_left.mpr h]; exact ‚ü®‚ü®_, rfl‚ü©‚ü©\n\n"}
{"name":"ValuationRing.instOfIsLocalRingOfIsBezout","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"R : Type u_1\ninst‚úù¬≥ : CommRing R\ninst‚úù¬≤ : IsDomain R\ninst‚úù¬π : IsLocalRing R\ninst‚úù : IsBezout R\n‚ä¢ ValuationRing R","decl":"instance (priority := 100) [IsLocalRing R] [IsBezout R] : ValuationRing R := by\n  classical\n  refine iff_dvd_total.mpr ‚ü®fun a b => ?_‚ü©\n  obtain ‚ü®g, e : _ = Ideal.span _‚ü© := IsBezout.span_pair_isPrincipal a b\n  obtain ‚ü®a, rfl‚ü© := Ideal.mem_span_singleton'.mp\n      (show a ‚àà Ideal.span {g} by rw [‚Üê e]; exact Ideal.subset_span (by simp))\n  obtain ‚ü®b, rfl‚ü© := Ideal.mem_span_singleton'.mp\n      (show b ‚àà Ideal.span {g} by rw [‚Üê e]; exact Ideal.subset_span (by simp))\n  obtain ‚ü®x, y, e'‚ü© := Ideal.mem_span_pair.mp\n      (show g ‚àà Ideal.span {a * g, b * g} by rw [e]; exact Ideal.subset_span (by simp))\n  rcases eq_or_ne g 0 with h | h\n  ¬∑ simp [h]\n  have : x * a + y * b = 1 := by\n    apply mul_left_injective‚ÇÄ h; convert e' using 1 <;> ring\n  cases' IsLocalRing.isUnit_or_isUnit_of_add_one this with h' h' <;> [left; right]\n  all_goals exact mul_dvd_mul_right (isUnit_iff_forall_dvd.mp (isUnit_of_mul_isUnit_right h') _) _\n\n"}
{"name":"ValuationRing.iff_local_bezout_domain","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"R : Type u_1\ninst‚úù¬π : CommRing R\ninst‚úù : IsDomain R\n‚ä¢ Iff (ValuationRing R) (And (IsLocalRing R) (IsBezout R))","decl":"theorem iff_local_bezout_domain : ValuationRing R ‚Üî IsLocalRing R ‚àß IsBezout R :=\n  ‚ü®fun _ ‚Ü¶ ‚ü®inferInstance, inferInstance‚ü©, fun ‚ü®_, _‚ü© ‚Ü¶ inferInstance‚ü©\n\n"}
{"name":"ValuationRing.TFAE","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"R : Type u\ninst‚úù¬π : CommRing R\ninst‚úù : IsDomain R\n‚ä¢ (List.cons (ValuationRing R) (List.cons (‚àÄ (x : FractionRing R), Or (IsLocalization.IsInteger R x) (IsLocalization.IsInteger R (Inv.inv x))) (List.cons (IsTotal R fun x1 x2 => Dvd.dvd x1 x2) (List.cons (IsTotal (Ideal R) fun x1 x2 => LE.le x1 x2) (List.cons (And (IsLocalRing R) (IsBezout R)) List.nil))))).TFAE","decl":"protected theorem TFAE (R : Type u) [CommRing R] [IsDomain R] :\n    List.TFAE\n      [ValuationRing R,\n        ‚àÄ x : FractionRing R, IsLocalization.IsInteger R x ‚à® IsLocalization.IsInteger R x‚Åª¬π,\n        IsTotal R (¬∑ ‚à£ ¬∑), IsTotal (Ideal R) (¬∑ ‚â§ ¬∑), IsLocalRing R ‚àß IsBezout R] := by\n  tfae_have 1 ‚Üî 2 := iff_isInteger_or_isInteger R _\n  tfae_have 1 ‚Üî 3 := iff_dvd_total\n  tfae_have 1 ‚Üî 4 := iff_ideal_total\n  tfae_have 1 ‚Üî 5 := iff_local_bezout_domain\n  tfae_finish\n\n"}
{"name":"Function.Surjective.preValuationRing","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"R : Type u_1\nS : Type u_2\ninst‚úù¬≤ : Mul R\ninst‚úù¬π : PreValuationRing R\ninst‚úù : Mul S\nf : MulHom R S\nhf : Function.Surjective ‚áëf\n‚ä¢ PreValuationRing S","decl":"theorem _root_.Function.Surjective.preValuationRing {R S : Type*} [Mul R] [PreValuationRing R]\n    [Mul S] (f : R ‚Üí‚Çô* S) (hf : Function.Surjective f) :\n    PreValuationRing S :=\n  ‚ü®fun a b => by\n    obtain ‚ü®‚ü®a, rfl‚ü©, ‚ü®b, rfl‚ü©‚ü© := hf a, hf b\n    obtain ‚ü®c, rfl | rfl‚ü© := PreValuationRing.cond a b\n    exacts [‚ü®f c, Or.inl <| (map_mul _ _ _).symm‚ü©, ‚ü®f c, Or.inr <| (map_mul _ _ _).symm‚ü©]‚ü©\n\n"}
{"name":"Function.Surjective.valuationRing","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"R : Type u_1\nS : Type u_2\ninst‚úù‚Å¥ : CommRing R\ninst‚úù¬≥ : IsDomain R\ninst‚úù¬≤ : ValuationRing R\ninst‚úù¬π : CommRing S\ninst‚úù : IsDomain S\nf : RingHom R S\nhf : Function.Surjective ‚áëf\n‚ä¢ ValuationRing S","decl":"theorem _root_.Function.Surjective.valuationRing {R S : Type*} [CommRing R] [IsDomain R]\n    [ValuationRing R] [CommRing S] [IsDomain S] (f : R ‚Üí+* S) (hf : Function.Surjective f) :\n    ValuationRing S :=\n  have : PreValuationRing S := Function.Surjective.preValuationRing (R := R) f hf\n  .mk\n\n"}
{"name":"ValuationRing.of_integers","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"ùí™ : Type u\nK : Type v\nŒì : Type w\ninst‚úù‚Å¥ : CommRing ùí™\ninst‚úù¬≥ : IsDomain ùí™\ninst‚úù¬≤ : Field K\ninst‚úù¬π : Algebra ùí™ K\ninst‚úù : LinearOrderedCommGroupWithZero Œì\nv : Valuation K Œì\nhh : v.Integers ùí™\n‚ä¢ ValuationRing ùí™","decl":"/-- If `ùí™` satisfies `v.integers ùí™` where `v` is a valuation on a field, then `ùí™`\nis a valuation ring. -/\ntheorem of_integers (v : Valuation K Œì) (hh : v.Integers ùí™) : ValuationRing ùí™ := by\n  suffices PreValuationRing ùí™ from .mk\n  constructor\n  intro a b\n  rcases le_total (v (algebraMap ùí™ K a)) (v (algebraMap ùí™ K b)) with h | h\n  ¬∑ obtain ‚ü®c, hc‚ü© := Valuation.Integers.dvd_of_le hh h\n    use c; exact Or.inr hc.symm\n  ¬∑ obtain ‚ü®c, hc‚ü© := Valuation.Integers.dvd_of_le hh h\n    use c; exact Or.inl hc.symm\n\n"}
{"name":"ValuationRing.instValuationRingInteger","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"K : Type v\nŒì : Type w\ninst‚úù¬π : Field K\ninst‚úù : LinearOrderedCommGroupWithZero Œì\nv : Valuation K Œì\n‚ä¢ ValuationRing (Subtype fun x => Membership.mem v.integer x)","decl":"instance instValuationRingInteger (v : Valuation K Œì) : ValuationRing v.integer :=\n  of_integers (v := v) (Valuation.integer.integers v)\n\n"}
{"name":"ValuationRing.isFractionRing_iff","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"ùí™ : Type u\nK : Type v\ninst‚úù‚Å¥ : CommRing ùí™\ninst‚úù¬≥ : IsDomain ùí™\ninst‚úù¬≤ : Field K\ninst‚úù¬π : Algebra ùí™ K\ninst‚úù : ValuationRing ùí™\n‚ä¢ Iff (IsFractionRing ùí™ K) (And (‚àÄ (x : K), Exists fun a => Or (Eq x ((algebraMap ùí™ K) a)) (Eq (Inv.inv x) ((algebraMap ùí™ K) a))) (Function.Injective ‚áë(algebraMap ùí™ K)))","decl":"theorem isFractionRing_iff [ValuationRing ùí™] :\n    IsFractionRing ùí™ K ‚Üî\n      (‚àÄ (x : K), ‚àÉ a : ùí™, x = algebraMap ùí™ K a ‚à® x‚Åª¬π = algebraMap ùí™ K a) ‚àß\n        Function.Injective (algebraMap ùí™ K) := by\n  refine ‚ü®fun h ‚Ü¶ ‚ü®fun x ‚Ü¶ ?_, IsFractionRing.injective _ _‚ü©, fun h ‚Ü¶ ?_‚ü©\n  ¬∑ obtain (‚ü®a, e‚ü© | ‚ü®a, e‚ü©) := isInteger_or_isInteger ùí™ x\n    exacts [‚ü®a, .inl e.symm‚ü©, ‚ü®a, .inr e.symm‚ü©]\n  ¬∑ constructor\n    ¬∑ intro a\n      simpa using h.2.ne_iff.mpr (nonZeroDivisors.ne_zero a.2)\n    ¬∑ intro x\n      obtain ‚ü®a, ha‚ü© := h.1 x\n      by_cases h0 : a = 0\n      ¬∑ exact ‚ü®‚ü®0, 1‚ü©, by simpa [h0] using ha‚ü©\n      ¬∑ have : algebraMap ùí™ K a ‚â† 0 := by simpa using h.2.ne_iff.mpr h0\n        rw [inv_eq_iff_eq_inv, ‚Üê one_div, eq_div_iff this] at ha\n        cases ha with\n        | inl ha => exact ‚ü®‚ü®a, 1‚ü©, by simpa‚ü©\n        | inr ha => exact ‚ü®‚ü®1, ‚ü®a, mem_nonZeroDivisors_of_ne_zero h0‚ü©‚ü©, by simpa using ha‚ü©\n    ¬∑ intro _ _ hab\n      exact ‚ü®1, by simp only [OneMemClass.coe_one, h.2 hab, one_mul]‚ü©\n\n"}
{"name":"ValuationRing.instIsFractionRingInteger","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"K : Type v\nŒì : Type w\ninst‚úù¬π : Field K\ninst‚úù : LinearOrderedCommGroupWithZero Œì\nv : Valuation K Œì\n‚ä¢ IsFractionRing (Subtype fun x => Membership.mem v.integer x) K","decl":"instance instIsFractionRingInteger (v : Valuation K Œì) : IsFractionRing v.integer K :=\n  ValuationRing.isFractionRing_iff.mpr\n    ‚ü®Valuation.Integers.eq_algebraMap_or_inv_eq_algebraMap (Valuation.integer.integers v),\n    Subtype.coe_injective‚ü©\n\n"}
{"name":"ValuationRing.of_field","module":"Mathlib.RingTheory.Valuation.ValuationRing","initialProofState":"K : Type u\ninst‚úù : Field K\n‚ä¢ ValuationRing K","decl":"/-- A field is a valuation ring. -/\ninstance (priority := 100) of_field : ValuationRing K := inferInstance\n\n"}
