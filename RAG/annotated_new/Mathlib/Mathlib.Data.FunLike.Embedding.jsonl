{"name":"EmbeddingLike.injective'","module":"Mathlib.Data.FunLike.Embedding","initialProofState":"F : Sort u_1\nα : outParam (Sort u_2)\nβ : outParam (Sort u_3)\ninst✝ : FunLike F α β\nself : EmbeddingLike F α β\nf : F\n⊢ Function.Injective ⇑f","decl":"/-- The class `EmbeddingLike F α β` expresses that terms of type `F` have an\ninjective coercion to injective functions `α ↪ β`.\n-/\nclass EmbeddingLike (F : Sort*) (α β : outParam (Sort*)) [FunLike F α β] : Prop where\n  /-- The coercion to functions must produce injective functions. -/\n  injective' : ∀ f : F, Function.Injective (DFunLike.coe f)\n\n"}
{"name":"EmbeddingLike.injective","module":"Mathlib.Data.FunLike.Embedding","initialProofState":"F : Sort u_1\nα : Sort u_2\nβ : Sort u_3\ninst✝ : FunLike F α β\ni : EmbeddingLike F α β\nf : F\n⊢ Function.Injective ⇑f","decl":"protected theorem injective (f : F) : Function.Injective f :=\n  injective' f\n\n"}
{"name":"EmbeddingLike.apply_eq_iff_eq","module":"Mathlib.Data.FunLike.Embedding","initialProofState":"F : Sort u_1\nα : Sort u_2\nβ : Sort u_3\ninst✝ : FunLike F α β\ni : EmbeddingLike F α β\nf : F\nx y : α\n⊢ Iff (Eq (f x) (f y)) (Eq x y)","decl":"@[simp]\ntheorem apply_eq_iff_eq (f : F) {x y : α} : f x = f y ↔ x = y :=\n  (EmbeddingLike.injective f).eq_iff\n\n"}
{"name":"EmbeddingLike.comp_injective","module":"Mathlib.Data.FunLike.Embedding","initialProofState":"α : Sort u_2\nβ : Sort u_3\nγ : Sort u_4\nF : Sort u_5\ninst✝¹ : FunLike F β γ\ninst✝ : EmbeddingLike F β γ\nf : α → β\ne : F\n⊢ Iff (Function.Injective (Function.comp (⇑e) f)) (Function.Injective f)","decl":"@[simp]\ntheorem comp_injective {F : Sort*} [FunLike F β γ] [EmbeddingLike F β γ] (f : α → β) (e : F) :\n    Function.Injective (e ∘ f) ↔ Function.Injective f :=\n  (EmbeddingLike.injective e).of_comp_iff f\n\n"}
