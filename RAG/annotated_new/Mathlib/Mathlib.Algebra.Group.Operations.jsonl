{"name":"VAdd.ext","module":"Mathlib.Algebra.Group.Operations","initialProofState":"G : Type u\nP : Type v\nx y : VAdd G P\nvadd : Eq VAdd.vadd VAdd.vadd\n⊢ Eq x y","decl":"/-- Typeclass for types with a scalar multiplication operation, denoted `•` (`\\bu`) -/\n@[to_additive (attr := ext)]\nclass SMul (M : Type u) (α : Type v) where\n  /-- `a • b` computes the product of `a` and `b`. The meaning of this notation is type-dependent,\n  but it is intended to be used for left actions. -/\n  smul : M → α → α\n\n"}
{"name":"SMul.ext_iff","module":"Mathlib.Algebra.Group.Operations","initialProofState":"M : Type u\nα : Type v\nx y : SMul M α\n⊢ Iff (Eq x y) (Eq SMul.smul SMul.smul)","decl":"/-- Typeclass for types with a scalar multiplication operation, denoted `•` (`\\bu`) -/\n@[to_additive (attr := ext)]\nclass SMul (M : Type u) (α : Type v) where\n  /-- `a • b` computes the product of `a` and `b`. The meaning of this notation is type-dependent,\n  but it is intended to be used for left actions. -/\n  smul : M → α → α\n\n"}
{"name":"VAdd.ext_iff","module":"Mathlib.Algebra.Group.Operations","initialProofState":"G : Type u\nP : Type v\nx y : VAdd G P\n⊢ Iff (Eq x y) (Eq VAdd.vadd VAdd.vadd)","decl":"/-- Typeclass for types with a scalar multiplication operation, denoted `•` (`\\bu`) -/\n@[to_additive (attr := ext)]\nclass SMul (M : Type u) (α : Type v) where\n  /-- `a • b` computes the product of `a` and `b`. The meaning of this notation is type-dependent,\n  but it is intended to be used for left actions. -/\n  smul : M → α → α\n\n"}
{"name":"SMul.ext","module":"Mathlib.Algebra.Group.Operations","initialProofState":"M : Type u\nα : Type v\nx y : SMul M α\nsmul : Eq SMul.smul SMul.smul\n⊢ Eq x y","decl":"/-- Typeclass for types with a scalar multiplication operation, denoted `•` (`\\bu`) -/\n@[to_additive (attr := ext)]\nclass SMul (M : Type u) (α : Type v) where\n  /-- `a • b` computes the product of `a` and `b`. The meaning of this notation is type-dependent,\n  but it is intended to be used for left actions. -/\n  smul : M → α → α\n\n"}
{"name":"VAdd.vadd_eq_hVAdd","module":"Mathlib.Algebra.Group.Operations","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : VAdd α β\n⊢ Eq VAdd.vadd HVAdd.hVAdd","decl":"@[to_additive]\ntheorem SMul.smul_eq_hSMul {α β} [SMul α β] : (SMul.smul : α → β → β) = HSMul.hSMul := rfl\n\n"}
{"name":"SMul.smul_eq_hSMul","module":"Mathlib.Algebra.Group.Operations","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : SMul α β\n⊢ Eq SMul.smul HSMul.hSMul","decl":"@[to_additive]\ntheorem SMul.smul_eq_hSMul {α β} [SMul α β] : (SMul.smul : α → β → β) = HSMul.hSMul := rfl\n\n"}
{"name":"add_dite","module":"Mathlib.Algebra.Group.Operations","initialProofState":"α : Type u_2\nP : Prop\ninst✝¹ : Decidable P\ninst✝ : Add α\na : α\nb : P → α\nc : Not P → α\n⊢ Eq (HAdd.hAdd a (dite P (fun h => b h) fun h => c h)) (dite P (fun h => HAdd.hAdd a (b h)) fun h => HAdd.hAdd a (c h))","decl":"@[to_additive]\nlemma mul_dite (a : α) (b : P → α) (c : ¬ P → α) :\n    (a * if h : P then b h else c h) = if h : P then a * b h else a * c h := by split <;> rfl\n\n"}
{"name":"mul_dite","module":"Mathlib.Algebra.Group.Operations","initialProofState":"α : Type u_2\nP : Prop\ninst✝¹ : Decidable P\ninst✝ : Mul α\na : α\nb : P → α\nc : Not P → α\n⊢ Eq (HMul.hMul a (dite P (fun h => b h) fun h => c h)) (dite P (fun h => HMul.hMul a (b h)) fun h => HMul.hMul a (c h))","decl":"@[to_additive]\nlemma mul_dite (a : α) (b : P → α) (c : ¬ P → α) :\n    (a * if h : P then b h else c h) = if h : P then a * b h else a * c h := by split <;> rfl\n\n"}
{"name":"mul_ite","module":"Mathlib.Algebra.Group.Operations","initialProofState":"α : Type u_2\nP : Prop\ninst✝¹ : Decidable P\ninst✝ : Mul α\na b c : α\n⊢ Eq (HMul.hMul a (ite P b c)) (ite P (HMul.hMul a b) (HMul.hMul a c))","decl":"@[to_additive]\nlemma mul_ite (a b c : α) : (a * if P then b else c) = if P then a * b else a * c := mul_dite ..\n\n"}
{"name":"add_ite","module":"Mathlib.Algebra.Group.Operations","initialProofState":"α : Type u_2\nP : Prop\ninst✝¹ : Decidable P\ninst✝ : Add α\na b c : α\n⊢ Eq (HAdd.hAdd a (ite P b c)) (ite P (HAdd.hAdd a b) (HAdd.hAdd a c))","decl":"@[to_additive]\nlemma mul_ite (a b c : α) : (a * if P then b else c) = if P then a * b else a * c := mul_dite ..\n\n"}
{"name":"dite_mul","module":"Mathlib.Algebra.Group.Operations","initialProofState":"α : Type u_2\nP : Prop\ninst✝¹ : Decidable P\ninst✝ : Mul α\na : P → α\nb : Not P → α\nc : α\n⊢ Eq (HMul.hMul (dite P (fun h => a h) fun h => b h) c) (dite P (fun h => HMul.hMul (a h) c) fun h => HMul.hMul (b h) c)","decl":"@[to_additive]\nlemma dite_mul (a : P → α) (b : ¬ P → α) (c : α) :\n    (if h : P then a h else b h) * c = if h : P then a h * c else b h * c := by split <;> rfl\n\n"}
{"name":"dite_add","module":"Mathlib.Algebra.Group.Operations","initialProofState":"α : Type u_2\nP : Prop\ninst✝¹ : Decidable P\ninst✝ : Add α\na : P → α\nb : Not P → α\nc : α\n⊢ Eq (HAdd.hAdd (dite P (fun h => a h) fun h => b h) c) (dite P (fun h => HAdd.hAdd (a h) c) fun h => HAdd.hAdd (b h) c)","decl":"@[to_additive]\nlemma dite_mul (a : P → α) (b : ¬ P → α) (c : α) :\n    (if h : P then a h else b h) * c = if h : P then a h * c else b h * c := by split <;> rfl\n\n"}
{"name":"ite_mul","module":"Mathlib.Algebra.Group.Operations","initialProofState":"α : Type u_2\nP : Prop\ninst✝¹ : Decidable P\ninst✝ : Mul α\na b c : α\n⊢ Eq (HMul.hMul (ite P a b) c) (ite P (HMul.hMul a c) (HMul.hMul b c))","decl":"@[to_additive]\nlemma ite_mul (a b c : α) : (if P then a else b) * c = if P then a * c else b * c := dite_mul ..\n\n-- We make `mul_ite` and `ite_mul` simp lemmas, but not `add_ite` or `ite_add`.\n-- The problem we're trying to avoid is dealing with sums of the form `∑ x ∈ s, (f x + ite P 1 0)`,\n-- in which `add_ite` followed by `sum_ite` would needlessly slice up\n-- the `f x` terms according to whether `P` holds at `x`.\n-- There doesn't appear to be a corresponding difficulty so far with `mul_ite` and `ite_mul`.\n"}
{"name":"ite_add","module":"Mathlib.Algebra.Group.Operations","initialProofState":"α : Type u_2\nP : Prop\ninst✝¹ : Decidable P\ninst✝ : Add α\na b c : α\n⊢ Eq (HAdd.hAdd (ite P a b) c) (ite P (HAdd.hAdd a c) (HAdd.hAdd b c))","decl":"@[to_additive]\nlemma ite_mul (a b c : α) : (if P then a else b) * c = if P then a * c else b * c := dite_mul ..\n\n-- We make `mul_ite` and `ite_mul` simp lemmas, but not `add_ite` or `ite_add`.\n-- The problem we're trying to avoid is dealing with sums of the form `∑ x ∈ s, (f x + ite P 1 0)`,\n-- in which `add_ite` followed by `sum_ite` would needlessly slice up\n-- the `f x` terms according to whether `P` holds at `x`.\n-- There doesn't appear to be a corresponding difficulty so far with `mul_ite` and `ite_mul`.\n"}
{"name":"dite_add_dite","module":"Mathlib.Algebra.Group.Operations","initialProofState":"α : Type u_2\nP : Prop\ninst✝¹ : Decidable P\ninst✝ : Add α\na : P → α\nb : Not P → α\nc : P → α\nd : Not P → α\n⊢ Eq (HAdd.hAdd (dite P (fun h => a h) fun h => b h) (dite P (fun h => c h) fun h => d h)) (dite P (fun h => HAdd.hAdd (a h) (c h)) fun h => HAdd.hAdd (b h) (d h))","decl":"@[to_additive]\nlemma dite_mul_dite (a : P → α) (b : ¬ P → α) (c : P → α) (d : ¬ P → α) :\n    ((if h : P then a h else b h) * if h : P then c h else d h) =\n      if h : P then a h * c h else b h * d h := by split <;> rfl\n\n"}
{"name":"dite_mul_dite","module":"Mathlib.Algebra.Group.Operations","initialProofState":"α : Type u_2\nP : Prop\ninst✝¹ : Decidable P\ninst✝ : Mul α\na : P → α\nb : Not P → α\nc : P → α\nd : Not P → α\n⊢ Eq (HMul.hMul (dite P (fun h => a h) fun h => b h) (dite P (fun h => c h) fun h => d h)) (dite P (fun h => HMul.hMul (a h) (c h)) fun h => HMul.hMul (b h) (d h))","decl":"@[to_additive]\nlemma dite_mul_dite (a : P → α) (b : ¬ P → α) (c : P → α) (d : ¬ P → α) :\n    ((if h : P then a h else b h) * if h : P then c h else d h) =\n      if h : P then a h * c h else b h * d h := by split <;> rfl\n\n"}
{"name":"ite_mul_ite","module":"Mathlib.Algebra.Group.Operations","initialProofState":"α : Type u_2\nP : Prop\ninst✝¹ : Decidable P\ninst✝ : Mul α\na b c d : α\n⊢ Eq (HMul.hMul (ite P a b) (ite P c d)) (ite P (HMul.hMul a c) (HMul.hMul b d))","decl":"@[to_additive]\nlemma ite_mul_ite (a b c d : α) :\n    ((if P then a else b) * if P then c else d) = if P then a * c else b * d := by split <;> rfl\n\n"}
{"name":"ite_add_ite","module":"Mathlib.Algebra.Group.Operations","initialProofState":"α : Type u_2\nP : Prop\ninst✝¹ : Decidable P\ninst✝ : Add α\na b c d : α\n⊢ Eq (HAdd.hAdd (ite P a b) (ite P c d)) (ite P (HAdd.hAdd a c) (HAdd.hAdd b d))","decl":"@[to_additive]\nlemma ite_mul_ite (a b c d : α) :\n    ((if P then a else b) * if P then c else d) = if P then a * c else b * d := by split <;> rfl\n\n"}
{"name":"sub_dite","module":"Mathlib.Algebra.Group.Operations","initialProofState":"α : Type u_2\nP : Prop\ninst✝¹ : Decidable P\ninst✝ : Sub α\na : α\nb : P → α\nc : Not P → α\n⊢ Eq (HSub.hSub a (dite P (fun h => b h) fun h => c h)) (dite P (fun h => HSub.hSub a (b h)) fun h => HSub.hSub a (c h))","decl":"@[to_additive]\nlemma div_dite (a : α) (b : P → α) (c : ¬ P → α) :\n    (a / if h : P then b h else c h) = if h : P then a / b h else a / c h := by split <;> rfl\n\n"}
{"name":"div_dite","module":"Mathlib.Algebra.Group.Operations","initialProofState":"α : Type u_2\nP : Prop\ninst✝¹ : Decidable P\ninst✝ : Div α\na : α\nb : P → α\nc : Not P → α\n⊢ Eq (HDiv.hDiv a (dite P (fun h => b h) fun h => c h)) (dite P (fun h => HDiv.hDiv a (b h)) fun h => HDiv.hDiv a (c h))","decl":"@[to_additive]\nlemma div_dite (a : α) (b : P → α) (c : ¬ P → α) :\n    (a / if h : P then b h else c h) = if h : P then a / b h else a / c h := by split <;> rfl\n\n"}
{"name":"div_ite","module":"Mathlib.Algebra.Group.Operations","initialProofState":"α : Type u_2\nP : Prop\ninst✝¹ : Decidable P\ninst✝ : Div α\na b c : α\n⊢ Eq (HDiv.hDiv a (ite P b c)) (ite P (HDiv.hDiv a b) (HDiv.hDiv a c))","decl":"@[to_additive]\nlemma div_ite (a b c : α) : (a / if P then b else c) = if P then a / b else a / c := div_dite ..\n\n"}
{"name":"sub_ite","module":"Mathlib.Algebra.Group.Operations","initialProofState":"α : Type u_2\nP : Prop\ninst✝¹ : Decidable P\ninst✝ : Sub α\na b c : α\n⊢ Eq (HSub.hSub a (ite P b c)) (ite P (HSub.hSub a b) (HSub.hSub a c))","decl":"@[to_additive]\nlemma div_ite (a b c : α) : (a / if P then b else c) = if P then a / b else a / c := div_dite ..\n\n"}
{"name":"dite_div","module":"Mathlib.Algebra.Group.Operations","initialProofState":"α : Type u_2\nP : Prop\ninst✝¹ : Decidable P\ninst✝ : Div α\na : P → α\nb : Not P → α\nc : α\n⊢ Eq (HDiv.hDiv (dite P (fun h => a h) fun h => b h) c) (dite P (fun h => HDiv.hDiv (a h) c) fun h => HDiv.hDiv (b h) c)","decl":"@[to_additive]\nlemma dite_div (a : P → α) (b : ¬ P → α) (c : α) :\n    (if h : P then a h else b h) / c = if h : P then a h / c else b h / c := by split <;> rfl\n\n"}
{"name":"dite_sub","module":"Mathlib.Algebra.Group.Operations","initialProofState":"α : Type u_2\nP : Prop\ninst✝¹ : Decidable P\ninst✝ : Sub α\na : P → α\nb : Not P → α\nc : α\n⊢ Eq (HSub.hSub (dite P (fun h => a h) fun h => b h) c) (dite P (fun h => HSub.hSub (a h) c) fun h => HSub.hSub (b h) c)","decl":"@[to_additive]\nlemma dite_div (a : P → α) (b : ¬ P → α) (c : α) :\n    (if h : P then a h else b h) / c = if h : P then a h / c else b h / c := by split <;> rfl\n\n"}
{"name":"ite_div","module":"Mathlib.Algebra.Group.Operations","initialProofState":"α : Type u_2\nP : Prop\ninst✝¹ : Decidable P\ninst✝ : Div α\na b c : α\n⊢ Eq (HDiv.hDiv (ite P a b) c) (ite P (HDiv.hDiv a c) (HDiv.hDiv b c))","decl":"@[to_additive]\nlemma ite_div (a b c : α) : (if P then a else b) / c = if P then a / c else b / c := dite_div ..\n\n"}
{"name":"ite_sub","module":"Mathlib.Algebra.Group.Operations","initialProofState":"α : Type u_2\nP : Prop\ninst✝¹ : Decidable P\ninst✝ : Sub α\na b c : α\n⊢ Eq (HSub.hSub (ite P a b) c) (ite P (HSub.hSub a c) (HSub.hSub b c))","decl":"@[to_additive]\nlemma ite_div (a b c : α) : (if P then a else b) / c = if P then a / c else b / c := dite_div ..\n\n"}
{"name":"dite_sub_dite","module":"Mathlib.Algebra.Group.Operations","initialProofState":"α : Type u_2\nP : Prop\ninst✝¹ : Decidable P\ninst✝ : Sub α\na : P → α\nb : Not P → α\nc : P → α\nd : Not P → α\n⊢ Eq (HSub.hSub (dite P (fun h => a h) fun h => b h) (dite P (fun h => c h) fun h => d h)) (dite P (fun h => HSub.hSub (a h) (c h)) fun h => HSub.hSub (b h) (d h))","decl":"@[to_additive]\nlemma dite_div_dite (a : P → α) (b : ¬ P → α) (c : P → α) (d : ¬ P → α) :\n    ((if h : P then a h else b h) / if h : P then c h else d h) =\n      if h : P then a h / c h else b h / d h := by split <;> rfl\n\n"}
{"name":"dite_div_dite","module":"Mathlib.Algebra.Group.Operations","initialProofState":"α : Type u_2\nP : Prop\ninst✝¹ : Decidable P\ninst✝ : Div α\na : P → α\nb : Not P → α\nc : P → α\nd : Not P → α\n⊢ Eq (HDiv.hDiv (dite P (fun h => a h) fun h => b h) (dite P (fun h => c h) fun h => d h)) (dite P (fun h => HDiv.hDiv (a h) (c h)) fun h => HDiv.hDiv (b h) (d h))","decl":"@[to_additive]\nlemma dite_div_dite (a : P → α) (b : ¬ P → α) (c : P → α) (d : ¬ P → α) :\n    ((if h : P then a h else b h) / if h : P then c h else d h) =\n      if h : P then a h / c h else b h / d h := by split <;> rfl\n\n"}
{"name":"ite_div_ite","module":"Mathlib.Algebra.Group.Operations","initialProofState":"α : Type u_2\nP : Prop\ninst✝¹ : Decidable P\ninst✝ : Div α\na b c d : α\n⊢ Eq (HDiv.hDiv (ite P a b) (ite P c d)) (ite P (HDiv.hDiv a c) (HDiv.hDiv b d))","decl":"@[to_additive]\nlemma ite_div_ite (a b c d : α) :\n    ((if P then a else b) / if P then c else d) = if P then a / c else b / d := dite_div_dite ..\n\n"}
{"name":"ite_sub_ite","module":"Mathlib.Algebra.Group.Operations","initialProofState":"α : Type u_2\nP : Prop\ninst✝¹ : Decidable P\ninst✝ : Sub α\na b c d : α\n⊢ Eq (HSub.hSub (ite P a b) (ite P c d)) (ite P (HSub.hSub a c) (HSub.hSub b d))","decl":"@[to_additive]\nlemma ite_div_ite (a b c d : α) :\n    ((if P then a else b) / if P then c else d) = if P then a / c else b / d := dite_div_dite ..\n\n"}
