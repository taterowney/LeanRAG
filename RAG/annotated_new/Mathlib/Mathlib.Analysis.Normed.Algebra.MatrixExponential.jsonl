{"name":"Matrix.exp_diagonal","module":"Mathlib.Analysis.Normed.Algebra.MatrixExponential","initialProofState":"ğ•‚ : Type u_1\nm : Type u_2\nğ”¸ : Type u_5\ninstâœâ· : Fintype m\ninstâœâ¶ : DecidableEq m\ninstâœâµ : Field ğ•‚\ninstâœâ´ : Ring ğ”¸\ninstâœÂ³ : TopologicalSpace ğ”¸\ninstâœÂ² : TopologicalRing ğ”¸\ninstâœÂ¹ : Algebra ğ•‚ ğ”¸\ninstâœ : T2Space ğ”¸\nv : m â†’ ğ”¸\nâŠ¢ Eq (NormedSpace.exp ğ•‚ (Matrix.diagonal v)) (Matrix.diagonal (NormedSpace.exp ğ•‚ v))","decl":"theorem exp_diagonal (v : m â†’ ğ”¸) : exp ğ•‚ (diagonal v) = diagonal (exp ğ•‚ v) := by\n  simp_rw [exp_eq_tsum, diagonal_pow, â† diagonal_smul, â† diagonal_tsum]\n\n"}
{"name":"Matrix.exp_blockDiagonal","module":"Mathlib.Analysis.Normed.Algebra.MatrixExponential","initialProofState":"ğ•‚ : Type u_1\nm : Type u_2\nn : Type u_3\nğ”¸ : Type u_5\ninstâœâ¹ : Fintype m\ninstâœâ¸ : DecidableEq m\ninstâœâ· : Fintype n\ninstâœâ¶ : DecidableEq n\ninstâœâµ : Field ğ•‚\ninstâœâ´ : Ring ğ”¸\ninstâœÂ³ : TopologicalSpace ğ”¸\ninstâœÂ² : TopologicalRing ğ”¸\ninstâœÂ¹ : Algebra ğ•‚ ğ”¸\ninstâœ : T2Space ğ”¸\nv : m â†’ Matrix n n ğ”¸\nâŠ¢ Eq (NormedSpace.exp ğ•‚ (Matrix.blockDiagonal v)) (Matrix.blockDiagonal (NormedSpace.exp ğ•‚ v))","decl":"theorem exp_blockDiagonal (v : m â†’ Matrix n n ğ”¸) :\n    exp ğ•‚ (blockDiagonal v) = blockDiagonal (exp ğ•‚ v) := by\n  simp_rw [exp_eq_tsum, â† blockDiagonal_pow, â† blockDiagonal_smul, â† blockDiagonal_tsum]\n\n"}
{"name":"Matrix.exp_blockDiagonal'","module":"Mathlib.Analysis.Normed.Algebra.MatrixExponential","initialProofState":"ğ•‚ : Type u_1\nm : Type u_2\nn' : m â†’ Type u_4\nğ”¸ : Type u_5\ninstâœâ¹ : Fintype m\ninstâœâ¸ : DecidableEq m\ninstâœâ· : (i : m) â†’ Fintype (n' i)\ninstâœâ¶ : (i : m) â†’ DecidableEq (n' i)\ninstâœâµ : Field ğ•‚\ninstâœâ´ : Ring ğ”¸\ninstâœÂ³ : TopologicalSpace ğ”¸\ninstâœÂ² : TopologicalRing ğ”¸\ninstâœÂ¹ : Algebra ğ•‚ ğ”¸\ninstâœ : T2Space ğ”¸\nv : (i : m) â†’ Matrix (n' i) (n' i) ğ”¸\nâŠ¢ Eq (NormedSpace.exp ğ•‚ (Matrix.blockDiagonal' v)) (Matrix.blockDiagonal' (NormedSpace.exp ğ•‚ v))","decl":"theorem exp_blockDiagonal' (v : âˆ€ i, Matrix (n' i) (n' i) ğ”¸) :\n    exp ğ•‚ (blockDiagonal' v) = blockDiagonal' (exp ğ•‚ v) := by\n  simp_rw [exp_eq_tsum, â† blockDiagonal'_pow, â† blockDiagonal'_smul, â† blockDiagonal'_tsum]\n\n"}
{"name":"Matrix.exp_conjTranspose","module":"Mathlib.Analysis.Normed.Algebra.MatrixExponential","initialProofState":"ğ•‚ : Type u_1\nm : Type u_2\nğ”¸ : Type u_5\ninstâœâ¹ : Fintype m\ninstâœâ¸ : DecidableEq m\ninstâœâ· : Field ğ•‚\ninstâœâ¶ : Ring ğ”¸\ninstâœâµ : TopologicalSpace ğ”¸\ninstâœâ´ : TopologicalRing ğ”¸\ninstâœÂ³ : Algebra ğ•‚ ğ”¸\ninstâœÂ² : T2Space ğ”¸\ninstâœÂ¹ : StarRing ğ”¸\ninstâœ : ContinuousStar ğ”¸\nA : Matrix m m ğ”¸\nâŠ¢ Eq (NormedSpace.exp ğ•‚ A.conjTranspose) (NormedSpace.exp ğ•‚ A).conjTranspose","decl":"theorem exp_conjTranspose [StarRing ğ”¸] [ContinuousStar ğ”¸] (A : Matrix m m ğ”¸) :\n    exp ğ•‚ Aá´´ = (exp ğ•‚ A)á´´ :=\n  (star_exp A).symm\n\n"}
{"name":"Matrix.IsHermitian.exp","module":"Mathlib.Analysis.Normed.Algebra.MatrixExponential","initialProofState":"ğ•‚ : Type u_1\nm : Type u_2\nğ”¸ : Type u_5\ninstâœâ¹ : Fintype m\ninstâœâ¸ : DecidableEq m\ninstâœâ· : Field ğ•‚\ninstâœâ¶ : Ring ğ”¸\ninstâœâµ : TopologicalSpace ğ”¸\ninstâœâ´ : TopologicalRing ğ”¸\ninstâœÂ³ : Algebra ğ•‚ ğ”¸\ninstâœÂ² : T2Space ğ”¸\ninstâœÂ¹ : StarRing ğ”¸\ninstâœ : ContinuousStar ğ”¸\nA : Matrix m m ğ”¸\nh : A.IsHermitian\nâŠ¢ (NormedSpace.exp ğ•‚ A).IsHermitian","decl":"theorem IsHermitian.exp [StarRing ğ”¸] [ContinuousStar ğ”¸] {A : Matrix m m ğ”¸} (h : A.IsHermitian) :\n    (exp ğ•‚ A).IsHermitian :=\n  (exp_conjTranspose _ _).symm.trans <| congr_arg _ h\n\n"}
{"name":"Matrix.exp_transpose","module":"Mathlib.Analysis.Normed.Algebra.MatrixExponential","initialProofState":"ğ•‚ : Type u_1\nm : Type u_2\nğ”¸ : Type u_5\ninstâœâ· : Fintype m\ninstâœâ¶ : DecidableEq m\ninstâœâµ : Field ğ•‚\ninstâœâ´ : CommRing ğ”¸\ninstâœÂ³ : TopologicalSpace ğ”¸\ninstâœÂ² : TopologicalRing ğ”¸\ninstâœÂ¹ : Algebra ğ•‚ ğ”¸\ninstâœ : T2Space ğ”¸\nA : Matrix m m ğ”¸\nâŠ¢ Eq (NormedSpace.exp ğ•‚ A.transpose) (NormedSpace.exp ğ•‚ A).transpose","decl":"theorem exp_transpose (A : Matrix m m ğ”¸) : exp ğ•‚ Aáµ€ = (exp ğ•‚ A)áµ€ := by\n  simp_rw [exp_eq_tsum, transpose_tsum, transpose_smul, transpose_pow]\n\n"}
{"name":"Matrix.IsSymm.exp","module":"Mathlib.Analysis.Normed.Algebra.MatrixExponential","initialProofState":"ğ•‚ : Type u_1\nm : Type u_2\nğ”¸ : Type u_5\ninstâœâ· : Fintype m\ninstâœâ¶ : DecidableEq m\ninstâœâµ : Field ğ•‚\ninstâœâ´ : CommRing ğ”¸\ninstâœÂ³ : TopologicalSpace ğ”¸\ninstâœÂ² : TopologicalRing ğ”¸\ninstâœÂ¹ : Algebra ğ•‚ ğ”¸\ninstâœ : T2Space ğ”¸\nA : Matrix m m ğ”¸\nh : A.IsSymm\nâŠ¢ (NormedSpace.exp ğ•‚ A).IsSymm","decl":"theorem IsSymm.exp {A : Matrix m m ğ”¸} (h : A.IsSymm) : (exp ğ•‚ A).IsSymm :=\n  (exp_transpose _ _).symm.trans <| congr_arg _ h\n\n"}
{"name":"Matrix.exp_add_of_commute","module":"Mathlib.Analysis.Normed.Algebra.MatrixExponential","initialProofState":"ğ•‚ : Type u_1\nm : Type u_2\nğ”¸ : Type u_5\ninstâœâµ : RCLike ğ•‚\ninstâœâ´ : Fintype m\ninstâœÂ³ : DecidableEq m\ninstâœÂ² : NormedRing ğ”¸\ninstâœÂ¹ : NormedAlgebra ğ•‚ ğ”¸\ninstâœ : CompleteSpace ğ”¸\nA B : Matrix m m ğ”¸\nh : Commute A B\nâŠ¢ Eq (NormedSpace.exp ğ•‚ (HAdd.hAdd A B)) (HMul.hMul (NormedSpace.exp ğ•‚ A) (NormedSpace.exp ğ•‚ B))","decl":"nonrec theorem exp_add_of_commute (A B : Matrix m m ğ”¸) (h : Commute A B) :\n    exp ğ•‚ (A + B) = exp ğ•‚ A * exp ğ•‚ B := by\n  letI : SeminormedRing (Matrix m m ğ”¸) := Matrix.linftyOpSemiNormedRing\n  letI : NormedRing (Matrix m m ğ”¸) := Matrix.linftyOpNormedRing\n  letI : NormedAlgebra ğ•‚ (Matrix m m ğ”¸) := Matrix.linftyOpNormedAlgebra\n  exact exp_add_of_commute h\n\n"}
{"name":"Matrix.exp_sum_of_commute","module":"Mathlib.Analysis.Normed.Algebra.MatrixExponential","initialProofState":"ğ•‚ : Type u_1\nm : Type u_2\nğ”¸ : Type u_5\ninstâœâµ : RCLike ğ•‚\ninstâœâ´ : Fintype m\ninstâœÂ³ : DecidableEq m\ninstâœÂ² : NormedRing ğ”¸\ninstâœÂ¹ : NormedAlgebra ğ•‚ ğ”¸\ninstâœ : CompleteSpace ğ”¸\nÎ¹ : Type u_6\ns : Finset Î¹\nf : Î¹ â†’ Matrix m m ğ”¸\nh : (â†‘s).Pairwise (Function.onFun Commute f)\nâŠ¢ Eq (NormedSpace.exp ğ•‚ (s.sum fun i => f i)) (s.noncommProd (fun i => NormedSpace.exp ğ•‚ (f i)) â‹¯)","decl":"open scoped Function in -- required for scoped `on` notation\nnonrec theorem exp_sum_of_commute {Î¹} (s : Finset Î¹) (f : Î¹ â†’ Matrix m m ğ”¸)\n    (h : (s : Set Î¹).Pairwise (Commute on f)) :\n    exp ğ•‚ (âˆ‘ i âˆˆ s, f i) =\n      s.noncommProd (fun i => exp ğ•‚ (f i)) fun _ hi _ hj _ => (h.of_refl hi hj).exp ğ•‚ := by\n  letI : SeminormedRing (Matrix m m ğ”¸) := Matrix.linftyOpSemiNormedRing\n  letI : NormedRing (Matrix m m ğ”¸) := Matrix.linftyOpNormedRing\n  letI : NormedAlgebra ğ•‚ (Matrix m m ğ”¸) := Matrix.linftyOpNormedAlgebra\n  exact exp_sum_of_commute s f h\n\n"}
{"name":"Matrix.exp_nsmul","module":"Mathlib.Analysis.Normed.Algebra.MatrixExponential","initialProofState":"ğ•‚ : Type u_1\nm : Type u_2\nğ”¸ : Type u_5\ninstâœâµ : RCLike ğ•‚\ninstâœâ´ : Fintype m\ninstâœÂ³ : DecidableEq m\ninstâœÂ² : NormedRing ğ”¸\ninstâœÂ¹ : NormedAlgebra ğ•‚ ğ”¸\ninstâœ : CompleteSpace ğ”¸\nn : Nat\nA : Matrix m m ğ”¸\nâŠ¢ Eq (NormedSpace.exp ğ•‚ (HSMul.hSMul n A)) (HPow.hPow (NormedSpace.exp ğ•‚ A) n)","decl":"nonrec theorem exp_nsmul (n : â„•) (A : Matrix m m ğ”¸) : exp ğ•‚ (n â€¢ A) = exp ğ•‚ A ^ n := by\n  letI : SeminormedRing (Matrix m m ğ”¸) := Matrix.linftyOpSemiNormedRing\n  letI : NormedRing (Matrix m m ğ”¸) := Matrix.linftyOpNormedRing\n  letI : NormedAlgebra ğ•‚ (Matrix m m ğ”¸) := Matrix.linftyOpNormedAlgebra\n  exact exp_nsmul n A\n\n"}
{"name":"Matrix.isUnit_exp","module":"Mathlib.Analysis.Normed.Algebra.MatrixExponential","initialProofState":"ğ•‚ : Type u_1\nm : Type u_2\nğ”¸ : Type u_5\ninstâœâµ : RCLike ğ•‚\ninstâœâ´ : Fintype m\ninstâœÂ³ : DecidableEq m\ninstâœÂ² : NormedRing ğ”¸\ninstâœÂ¹ : NormedAlgebra ğ•‚ ğ”¸\ninstâœ : CompleteSpace ğ”¸\nA : Matrix m m ğ”¸\nâŠ¢ IsUnit (NormedSpace.exp ğ•‚ A)","decl":"nonrec theorem isUnit_exp (A : Matrix m m ğ”¸) : IsUnit (exp ğ•‚ A) := by\n  letI : SeminormedRing (Matrix m m ğ”¸) := Matrix.linftyOpSemiNormedRing\n  letI : NormedRing (Matrix m m ğ”¸) := Matrix.linftyOpNormedRing\n  letI : NormedAlgebra ğ•‚ (Matrix m m ğ”¸) := Matrix.linftyOpNormedAlgebra\n  exact isUnit_exp _ A\n\n"}
{"name":"Matrix.exp_units_conj","module":"Mathlib.Analysis.Normed.Algebra.MatrixExponential","initialProofState":"ğ•‚ : Type u_1\nm : Type u_2\nğ”¸ : Type u_5\ninstâœâµ : RCLike ğ•‚\ninstâœâ´ : Fintype m\ninstâœÂ³ : DecidableEq m\ninstâœÂ² : NormedRing ğ”¸\ninstâœÂ¹ : NormedAlgebra ğ•‚ ğ”¸\ninstâœ : CompleteSpace ğ”¸\nU : Units (Matrix m m ğ”¸)\nA : Matrix m m ğ”¸\nâŠ¢ Eq (NormedSpace.exp ğ•‚ (HMul.hMul (HMul.hMul (â†‘U) A) â†‘(Inv.inv U))) (HMul.hMul (HMul.hMul (â†‘U) (NormedSpace.exp ğ•‚ A)) â†‘(Inv.inv U))","decl":"nonrec theorem exp_units_conj (U : (Matrix m m ğ”¸)Ë£) (A : Matrix m m ğ”¸) :\n    exp ğ•‚ (U * A * Uâ»Â¹) = U * exp ğ•‚ A * Uâ»Â¹ := by\n  letI : SeminormedRing (Matrix m m ğ”¸) := Matrix.linftyOpSemiNormedRing\n  letI : NormedRing (Matrix m m ğ”¸) := Matrix.linftyOpNormedRing\n  letI : NormedAlgebra ğ•‚ (Matrix m m ğ”¸) := Matrix.linftyOpNormedAlgebra\n  exact exp_units_conj _ U A\n\n"}
{"name":"Matrix.exp_units_conj'","module":"Mathlib.Analysis.Normed.Algebra.MatrixExponential","initialProofState":"ğ•‚ : Type u_1\nm : Type u_2\nğ”¸ : Type u_5\ninstâœâµ : RCLike ğ•‚\ninstâœâ´ : Fintype m\ninstâœÂ³ : DecidableEq m\ninstâœÂ² : NormedRing ğ”¸\ninstâœÂ¹ : NormedAlgebra ğ•‚ ğ”¸\ninstâœ : CompleteSpace ğ”¸\nU : Units (Matrix m m ğ”¸)\nA : Matrix m m ğ”¸\nâŠ¢ Eq (NormedSpace.exp ğ•‚ (HMul.hMul (HMul.hMul (â†‘(Inv.inv U)) A) â†‘U)) (HMul.hMul (HMul.hMul (â†‘(Inv.inv U)) (NormedSpace.exp ğ•‚ A)) â†‘U)","decl":"theorem exp_units_conj' (U : (Matrix m m ğ”¸)Ë£) (A : Matrix m m ğ”¸) :\n    exp ğ•‚ (Uâ»Â¹ * A * U) = Uâ»Â¹ * exp ğ•‚ A * U :=\n  exp_units_conj ğ•‚ Uâ»Â¹ A\n\n"}
{"name":"Matrix.exp_neg","module":"Mathlib.Analysis.Normed.Algebra.MatrixExponential","initialProofState":"ğ•‚ : Type u_1\nm : Type u_2\nğ”¸ : Type u_5\ninstâœâµ : RCLike ğ•‚\ninstâœâ´ : Fintype m\ninstâœÂ³ : DecidableEq m\ninstâœÂ² : NormedCommRing ğ”¸\ninstâœÂ¹ : NormedAlgebra ğ•‚ ğ”¸\ninstâœ : CompleteSpace ğ”¸\nA : Matrix m m ğ”¸\nâŠ¢ Eq (NormedSpace.exp ğ•‚ (Neg.neg A)) (Inv.inv (NormedSpace.exp ğ•‚ A))","decl":"theorem exp_neg (A : Matrix m m ğ”¸) : exp ğ•‚ (-A) = (exp ğ•‚ A)â»Â¹ := by\n  rw [nonsing_inv_eq_ring_inverse]\n  letI : SeminormedRing (Matrix m m ğ”¸) := Matrix.linftyOpSemiNormedRing\n  letI : NormedRing (Matrix m m ğ”¸) := Matrix.linftyOpNormedRing\n  letI : NormedAlgebra ğ•‚ (Matrix m m ğ”¸) := Matrix.linftyOpNormedAlgebra\n  exact (Ring.inverse_exp _ A).symm\n\n"}
{"name":"Matrix.exp_zsmul","module":"Mathlib.Analysis.Normed.Algebra.MatrixExponential","initialProofState":"ğ•‚ : Type u_1\nm : Type u_2\nğ”¸ : Type u_5\ninstâœâµ : RCLike ğ•‚\ninstâœâ´ : Fintype m\ninstâœÂ³ : DecidableEq m\ninstâœÂ² : NormedCommRing ğ”¸\ninstâœÂ¹ : NormedAlgebra ğ•‚ ğ”¸\ninstâœ : CompleteSpace ğ”¸\nz : Int\nA : Matrix m m ğ”¸\nâŠ¢ Eq (NormedSpace.exp ğ•‚ (HSMul.hSMul z A)) (HPow.hPow (NormedSpace.exp ğ•‚ A) z)","decl":"theorem exp_zsmul (z : â„¤) (A : Matrix m m ğ”¸) : exp ğ•‚ (z â€¢ A) = exp ğ•‚ A ^ z := by\n  obtain âŸ¨n, rfl | rflâŸ© := z.eq_nat_or_neg\n  Â· rw [zpow_natCast, natCast_zsmul, exp_nsmul]\n  Â· have : IsUnit (exp ğ•‚ A).det := (Matrix.isUnit_iff_isUnit_det _).mp (isUnit_exp _ _)\n    rw [Matrix.zpow_neg this, zpow_natCast, neg_smul, exp_neg, natCast_zsmul, exp_nsmul]\n\n"}
{"name":"Matrix.exp_conj","module":"Mathlib.Analysis.Normed.Algebra.MatrixExponential","initialProofState":"ğ•‚ : Type u_1\nm : Type u_2\nğ”¸ : Type u_5\ninstâœâµ : RCLike ğ•‚\ninstâœâ´ : Fintype m\ninstâœÂ³ : DecidableEq m\ninstâœÂ² : NormedCommRing ğ”¸\ninstâœÂ¹ : NormedAlgebra ğ•‚ ğ”¸\ninstâœ : CompleteSpace ğ”¸\nU A : Matrix m m ğ”¸\nhy : IsUnit U\nâŠ¢ Eq (NormedSpace.exp ğ•‚ (HMul.hMul (HMul.hMul U A) (Inv.inv U))) (HMul.hMul (HMul.hMul U (NormedSpace.exp ğ•‚ A)) (Inv.inv U))","decl":"theorem exp_conj (U : Matrix m m ğ”¸) (A : Matrix m m ğ”¸) (hy : IsUnit U) :\n    exp ğ•‚ (U * A * Uâ»Â¹) = U * exp ğ•‚ A * Uâ»Â¹ :=\n  let âŸ¨u, huâŸ© := hy\n  hu â–¸ by simpa only [Matrix.coe_units_inv] using exp_units_conj ğ•‚ u A\n\n"}
{"name":"Matrix.exp_conj'","module":"Mathlib.Analysis.Normed.Algebra.MatrixExponential","initialProofState":"ğ•‚ : Type u_1\nm : Type u_2\nğ”¸ : Type u_5\ninstâœâµ : RCLike ğ•‚\ninstâœâ´ : Fintype m\ninstâœÂ³ : DecidableEq m\ninstâœÂ² : NormedCommRing ğ”¸\ninstâœÂ¹ : NormedAlgebra ğ•‚ ğ”¸\ninstâœ : CompleteSpace ğ”¸\nU A : Matrix m m ğ”¸\nhy : IsUnit U\nâŠ¢ Eq (NormedSpace.exp ğ•‚ (HMul.hMul (HMul.hMul (Inv.inv U) A) U)) (HMul.hMul (HMul.hMul (Inv.inv U) (NormedSpace.exp ğ•‚ A)) U)","decl":"theorem exp_conj' (U : Matrix m m ğ”¸) (A : Matrix m m ğ”¸) (hy : IsUnit U) :\n    exp ğ•‚ (Uâ»Â¹ * A * U) = Uâ»Â¹ * exp ğ•‚ A * U :=\n  let âŸ¨u, huâŸ© := hy\n  hu â–¸ by simpa only [Matrix.coe_units_inv] using exp_units_conj' ğ•‚ u A\n\n"}
