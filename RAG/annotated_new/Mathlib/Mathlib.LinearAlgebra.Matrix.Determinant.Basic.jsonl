{"name":"Matrix.det_apply","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nM : Matrix n n R\n⊢ Eq M.det (Finset.univ.sum fun σ => HSMul.hSMul (Equiv.Perm.sign σ) (Finset.univ.prod fun i => M (σ i) i))","decl":"theorem det_apply (M : Matrix n n R) : M.det = ∑ σ : Perm n, Equiv.Perm.sign σ • ∏ i, M (σ i) i :=\n  MultilinearMap.alternatization_apply _ M\n\n-- This is what the old definition was. We use it to avoid having to change the old proofs below\n"}
{"name":"Matrix.det_apply'","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nM : Matrix n n R\n⊢ Eq M.det (Finset.univ.sum fun σ => HMul.hMul (↑↑(Equiv.Perm.sign σ)) (Finset.univ.prod fun i => M (σ i) i))","decl":"theorem det_apply' (M : Matrix n n R) : M.det = ∑ σ : Perm n, ε σ * ∏ i, M (σ i) i := by\n  simp [det_apply, Units.smul_def]\n\n"}
{"name":"Matrix.det_eq_detp_sub_detp","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nM : Matrix n n R\n⊢ Eq M.det (HSub.hSub (Matrix.detp 1 M) (Matrix.detp (-1) M))","decl":"theorem det_eq_detp_sub_detp (M : Matrix n n R) : M.det = M.detp 1 - M.detp (-1) := by\n  rw [det_apply, ← Equiv.sum_comp (Equiv.inv (Perm n)), ← ofSign_disjUnion, sum_disjUnion]\n  simp_rw [inv_apply, sign_inv, sub_eq_add_neg, detp, ← sum_neg_distrib]\n  refine congr_arg₂ (· + ·) (sum_congr rfl fun σ hσ ↦ ?_) (sum_congr rfl fun σ hσ ↦ ?_) <;>\n    rw [mem_ofSign.mp hσ, ← Equiv.prod_comp σ] <;> simp\n\n"}
{"name":"Matrix.det_diagonal","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nd : n → R\n⊢ Eq (Matrix.diagonal d).det (Finset.univ.prod fun i => d i)","decl":"@[simp]\ntheorem det_diagonal {d : n → R} : det (diagonal d) = ∏ i, d i := by\n  rw [det_apply']\n  refine (Finset.sum_eq_single 1 ?_ ?_).trans ?_\n  · rintro σ - h2\n    cases' not_forall.1 (mt Equiv.ext h2) with x h3\n    convert mul_zero (ε σ)\n    apply Finset.prod_eq_zero (mem_univ x)\n    exact if_neg h3\n  · simp\n  · simp\n\n"}
{"name":"Matrix.det_zero","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nx✝ : Nonempty n\n⊢ Eq (Matrix.det 0) 0","decl":"theorem det_zero (_ : Nonempty n) : det (0 : Matrix n n R) = 0 :=\n  (detRowAlternating : (n → R) [⋀^n]→ₗ[R] R).map_zero\n\n"}
{"name":"Matrix.det_one","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\n⊢ Eq (Matrix.det 1) 1","decl":"@[simp]\ntheorem det_one : det (1 : Matrix n n R) = 1 := by rw [← diagonal_one]; simp [-diagonal_one]\n\n"}
{"name":"Matrix.det_isEmpty","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\nR : Type v\ninst✝¹ : CommRing R\ninst✝ : IsEmpty n\nA : Matrix n n R\n⊢ Eq A.det 1","decl":"theorem det_isEmpty [IsEmpty n] {A : Matrix n n R} : det A = 1 := by simp [det_apply]\n\n"}
{"name":"Matrix.coe_det_isEmpty","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\nR : Type v\ninst✝¹ : CommRing R\ninst✝ : IsEmpty n\n⊢ Eq Matrix.det (Function.const (Matrix n n R) 1)","decl":"@[simp]\ntheorem coe_det_isEmpty [IsEmpty n] : (det : Matrix n n R → R) = Function.const _ 1 := by\n  ext\n  exact det_isEmpty\n\n"}
{"name":"Matrix.det_eq_one_of_card_eq_zero","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nA : Matrix n n R\nh : Eq (Fintype.card n) 0\n⊢ Eq A.det 1","decl":"theorem det_eq_one_of_card_eq_zero {A : Matrix n n R} (h : Fintype.card n = 0) : det A = 1 :=\n  haveI : IsEmpty n := Fintype.card_eq_zero_iff.mp h\n  det_isEmpty\n\n"}
{"name":"Matrix.det_unique","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"R : Type v\ninst✝³ : CommRing R\nn : Type u_3\ninst✝² : Unique n\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nA : Matrix n n R\n⊢ Eq A.det (A Inhabited.default Inhabited.default)","decl":"/-- If `n` has only one element, the determinant of an `n` by `n` matrix is just that element.\nAlthough `Unique` implies `DecidableEq` and `Fintype`, the instances might\nnot be syntactically equal. Thus, we need to fill in the args explicitly. -/\n@[simp]\ntheorem det_unique {n : Type*} [Unique n] [DecidableEq n] [Fintype n] (A : Matrix n n R) :\n    det A = A default default := by simp [det_apply, univ_unique]\n\n"}
{"name":"Matrix.det_eq_elem_of_subsingleton","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\nR : Type v\ninst✝¹ : CommRing R\ninst✝ : Subsingleton n\nA : Matrix n n R\nk : n\n⊢ Eq A.det (A k k)","decl":"theorem det_eq_elem_of_subsingleton [Subsingleton n] (A : Matrix n n R) (k : n) :\n    det A = A k k := by\n  have := uniqueOfSubsingleton k\n  convert det_unique A\n\n"}
{"name":"Matrix.det_eq_elem_of_card_eq_one","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nA : Matrix n n R\nh : Eq (Fintype.card n) 1\nk : n\n⊢ Eq A.det (A k k)","decl":"theorem det_eq_elem_of_card_eq_one {A : Matrix n n R} (h : Fintype.card n = 1) (k : n) :\n    det A = A k k :=\n  haveI : Subsingleton n := Fintype.card_le_one_iff_subsingleton.mp h.le\n  det_eq_elem_of_subsingleton _ _\n\n"}
{"name":"Matrix.det_mul_aux","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nM N : Matrix n n R\np : n → n\nH : Not (Function.Bijective p)\n⊢ Eq (Finset.univ.sum fun σ => HMul.hMul (↑↑(Equiv.Perm.sign σ)) (Finset.univ.prod fun x => HMul.hMul (M (σ x) (p x)) (N (p x) x))) 0","decl":"theorem det_mul_aux {M N : Matrix n n R} {p : n → n} (H : ¬Bijective p) :\n    (∑ σ : Perm n, ε σ * ∏ x, M (σ x) (p x) * N (p x) x) = 0 := by\n  obtain ⟨i, j, hpij, hij⟩ : ∃ i j, p i = p j ∧ i ≠ j := by\n    rw [← Finite.injective_iff_bijective, Injective] at H\n    push_neg at H\n    exact H\n  exact\n    sum_involution (fun σ _ => σ * Equiv.swap i j)\n      (fun σ _ => by\n        have : (∏ x, M (σ x) (p x)) = ∏ x, M ((σ * Equiv.swap i j) x) (p x) :=\n          Fintype.prod_equiv (swap i j) _ _ (by simp [apply_swap_eq_self hpij])\n        simp [this, sign_swap hij, -sign_swap', prod_mul_distrib])\n      (fun σ _ _ => (not_congr mul_swap_eq_iff).mpr hij) (fun _ _ => mem_univ _) fun σ _ =>\n      mul_swap_involutive i j σ\n\n"}
{"name":"Matrix.det_mul","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nM N : Matrix n n R\n⊢ Eq (HMul.hMul M N).det (HMul.hMul M.det N.det)","decl":"@[simp]\ntheorem det_mul (M N : Matrix n n R) : det (M * N) = det M * det N :=\n  calc\n    det (M * N) = ∑ p : n → n, ∑ σ : Perm n, ε σ * ∏ i, M (σ i) (p i) * N (p i) i := by\n      simp only [det_apply', mul_apply, prod_univ_sum, mul_sum, Fintype.piFinset_univ]\n      rw [Finset.sum_comm]\n    _ = ∑ p : n → n with Bijective p, ∑ σ : Perm n, ε σ * ∏ i, M (σ i) (p i) * N (p i) i := by\n      refine (sum_subset (filter_subset _ _) fun f _ hbij ↦ det_mul_aux ?_).symm\n      simpa only [true_and, mem_filter, mem_univ] using hbij\n    _ = ∑ τ : Perm n, ∑ σ : Perm n, ε σ * ∏ i, M (σ i) (τ i) * N (τ i) i :=\n      sum_bij (fun p h ↦ Equiv.ofBijective p (mem_filter.1 h).2) (fun _ _ ↦ mem_univ _)\n        (fun _ _ _ _ h ↦ by injection h)\n        (fun b _ ↦ ⟨b, mem_filter.2 ⟨mem_univ _, b.bijective⟩, coe_fn_injective rfl⟩) fun _ _ ↦ rfl\n    _ = ∑ σ : Perm n, ∑ τ : Perm n, (∏ i, N (σ i) i) * ε τ * ∏ j, M (τ j) (σ j) := by\n      simp only [mul_comm, mul_left_comm, prod_mul_distrib, mul_assoc]\n    _ = ∑ σ : Perm n, ∑ τ : Perm n, (∏ i, N (σ i) i) * (ε σ * ε τ) * ∏ i, M (τ i) i :=\n      (sum_congr rfl fun σ _ =>\n        Fintype.sum_equiv (Equiv.mulRight σ⁻¹) _ _ fun τ => by\n          have : (∏ j, M (τ j) (σ j)) = ∏ j, M ((τ * σ⁻¹) j) j := by\n            rw [← (σ⁻¹ : _ ≃ _).prod_comp]\n            simp only [Equiv.Perm.coe_mul, apply_inv_self, Function.comp_apply]\n          have h : ε σ * ε (τ * σ⁻¹) = ε τ :=\n            calc\n              ε σ * ε (τ * σ⁻¹) = ε (τ * σ⁻¹ * σ) := by\n                rw [mul_comm, sign_mul (τ * σ⁻¹)]\n                simp only [Int.cast_mul, Units.val_mul]\n              _ = ε τ := by simp only [inv_mul_cancel_right]\n\n          simp_rw [Equiv.coe_mulRight, h]\n          simp only [this])\n    _ = det M * det N := by\n      simp only [det_apply', Finset.mul_sum, mul_comm, mul_left_comm, mul_assoc]\n\n"}
{"name":"Matrix.coe_detMonoidHom","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\n⊢ Eq (⇑Matrix.detMonoidHom) Matrix.det","decl":"@[simp]\ntheorem coe_detMonoidHom : (detMonoidHom : Matrix n n R → R) = det :=\n  rfl\n\n"}
{"name":"Matrix.det_mul_comm","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"m : Type u_1\ninst✝² : DecidableEq m\ninst✝¹ : Fintype m\nR : Type v\ninst✝ : CommRing R\nM N : Matrix m m R\n⊢ Eq (HMul.hMul M N).det (HMul.hMul N M).det","decl":"/-- On square matrices, `mul_comm` applies under `det`. -/\ntheorem det_mul_comm (M N : Matrix m m R) : det (M * N) = det (N * M) := by\n  rw [det_mul, det_mul, mul_comm]\n\n"}
{"name":"Matrix.det_mul_left_comm","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"m : Type u_1\ninst✝² : DecidableEq m\ninst✝¹ : Fintype m\nR : Type v\ninst✝ : CommRing R\nM N P : Matrix m m R\n⊢ Eq (HMul.hMul M (HMul.hMul N P)).det (HMul.hMul N (HMul.hMul M P)).det","decl":"/-- On square matrices, `mul_left_comm` applies under `det`. -/\ntheorem det_mul_left_comm (M N P : Matrix m m R) : det (M * (N * P)) = det (N * (M * P)) := by\n  rw [← Matrix.mul_assoc, ← Matrix.mul_assoc, det_mul, det_mul_comm M N, ← det_mul]\n\n"}
{"name":"Matrix.det_mul_right_comm","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"m : Type u_1\ninst✝² : DecidableEq m\ninst✝¹ : Fintype m\nR : Type v\ninst✝ : CommRing R\nM N P : Matrix m m R\n⊢ Eq (HMul.hMul (HMul.hMul M N) P).det (HMul.hMul (HMul.hMul M P) N).det","decl":"/-- On square matrices, `mul_right_comm` applies under `det`. -/\ntheorem det_mul_right_comm (M N P : Matrix m m R) : det (M * N * P) = det (M * P * N) := by\n  rw [Matrix.mul_assoc, Matrix.mul_assoc, det_mul, det_mul_comm N P, ← det_mul]\n\n-- TODO(https://github.com/leanprover-community/mathlib4/issues/6607): fix elaboration so `val` isn't needed\n"}
{"name":"Matrix.det_units_conj","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"m : Type u_1\ninst✝² : DecidableEq m\ninst✝¹ : Fintype m\nR : Type v\ninst✝ : CommRing R\nM : Units (Matrix m m R)\nN : Matrix m m R\n⊢ Eq (HMul.hMul (HMul.hMul (↑M) N) ↑(Inv.inv M)).det N.det","decl":"theorem det_units_conj (M : (Matrix m m R)ˣ) (N : Matrix m m R) :\n    det (M.val * N * M⁻¹.val) = det N := by\n  rw [det_mul_right_comm, Units.mul_inv, one_mul]\n\n-- TODO(https://github.com/leanprover-community/mathlib4/issues/6607): fix elaboration so `val` isn't needed\n"}
{"name":"Matrix.det_units_conj'","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"m : Type u_1\ninst✝² : DecidableEq m\ninst✝¹ : Fintype m\nR : Type v\ninst✝ : CommRing R\nM : Units (Matrix m m R)\nN : Matrix m m R\n⊢ Eq (HMul.hMul (HMul.hMul (↑(Inv.inv M)) N) ↑M).det N.det","decl":"theorem det_units_conj' (M : (Matrix m m R)ˣ) (N : Matrix m m R) :\n    det (M⁻¹.val * N * ↑M.val) = det N :=\n  det_units_conj M⁻¹ N\n\n"}
{"name":"Matrix.det_transpose","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nM : Matrix n n R\n⊢ Eq M.transpose.det M.det","decl":"/-- Transposing a matrix preserves the determinant. -/\n@[simp]\ntheorem det_transpose (M : Matrix n n R) : Mᵀ.det = M.det := by\n  rw [det_apply', det_apply']\n  refine Fintype.sum_bijective _ inv_involutive.bijective _ _ ?_\n  intro σ\n  rw [sign_inv]\n  congr 1\n  apply Fintype.prod_equiv σ\n  simp\n\n"}
{"name":"Matrix.det_permute","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nσ : Equiv.Perm n\nM : Matrix n n R\n⊢ Eq (M.submatrix (⇑σ) id).det (HMul.hMul (↑↑(Equiv.Perm.sign σ)) M.det)","decl":"/-- Permuting the columns changes the sign of the determinant. -/\ntheorem det_permute (σ : Perm n) (M : Matrix n n R) :\n    (M.submatrix σ id).det = Perm.sign σ * M.det :=\n  ((detRowAlternating : (n → R) [⋀^n]→ₗ[R] R).map_perm M σ).trans (by simp [Units.smul_def])\n\n"}
{"name":"Matrix.det_permute'","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nσ : Equiv.Perm n\nM : Matrix n n R\n⊢ Eq (M.submatrix id ⇑σ).det (HMul.hMul (↑↑(Equiv.Perm.sign σ)) M.det)","decl":"/-- Permuting the rows changes the sign of the determinant. -/\ntheorem det_permute' (σ : Perm n) (M : Matrix n n R) :\n    (M.submatrix id σ).det = Perm.sign σ * M.det := by\n  rw [← det_transpose, transpose_submatrix, det_permute, det_transpose]\n\n"}
{"name":"Matrix.det_submatrix_equiv_self","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"m : Type u_1\nn : Type u_2\ninst✝⁴ : DecidableEq n\ninst✝³ : Fintype n\ninst✝² : DecidableEq m\ninst✝¹ : Fintype m\nR : Type v\ninst✝ : CommRing R\ne : Equiv n m\nA : Matrix m m R\n⊢ Eq (A.submatrix ⇑e ⇑e).det A.det","decl":"/-- Permuting rows and columns with the same equivalence does not change the determinant. -/\n@[simp]\ntheorem det_submatrix_equiv_self (e : n ≃ m) (A : Matrix m m R) :\n    det (A.submatrix e e) = det A := by\n  rw [det_apply', det_apply']\n  apply Fintype.sum_equiv (Equiv.permCongr e)\n  intro σ\n  rw [Equiv.Perm.sign_permCongr e σ]\n  congr 1\n  apply Fintype.prod_equiv e\n  intro i\n  rw [Equiv.permCongr_apply, Equiv.symm_apply_apply, submatrix_apply]\n\n"}
{"name":"Matrix.abs_det_submatrix_equiv_equiv","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"m : Type u_1\nn : Type u_2\ninst✝⁴ : DecidableEq n\ninst✝³ : Fintype n\ninst✝² : DecidableEq m\ninst✝¹ : Fintype m\nR : Type u_3\ninst✝ : LinearOrderedCommRing R\ne₁ e₂ : Equiv n m\nA : Matrix m m R\n⊢ Eq (abs (A.submatrix ⇑e₁ ⇑e₂).det) (abs A.det)","decl":"/-- Permuting rows and columns with two equivalences does not change the absolute value of the\ndeterminant. -/\n@[simp]\ntheorem abs_det_submatrix_equiv_equiv {R : Type*} [LinearOrderedCommRing R]\n    (e₁ e₂ : n ≃ m) (A : Matrix m m R) :\n    |(A.submatrix e₁ e₂).det| = |A.det| := by\n  have hee : e₂ = e₁.trans (e₁.symm.trans e₂) := by ext; simp\n  rw [hee]\n  show |((A.submatrix id (e₁.symm.trans e₂)).submatrix e₁ e₁).det| = |A.det|\n  rw [Matrix.det_submatrix_equiv_self, Matrix.det_permute', abs_mul, abs_unit_intCast, one_mul]\n\n"}
{"name":"Matrix.det_reindex_self","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"m : Type u_1\nn : Type u_2\ninst✝⁴ : DecidableEq n\ninst✝³ : Fintype n\ninst✝² : DecidableEq m\ninst✝¹ : Fintype m\nR : Type v\ninst✝ : CommRing R\ne : Equiv m n\nA : Matrix m m R\n⊢ Eq ((Matrix.reindex e e) A).det A.det","decl":"/-- Reindexing both indices along the same equivalence preserves the determinant.\n\nFor the `simp` version of this lemma, see `det_submatrix_equiv_self`; this one is unsuitable because\n`Matrix.reindex_apply` unfolds `reindex` first.\n-/\ntheorem det_reindex_self (e : m ≃ n) (A : Matrix m m R) : det (reindex e e A) = det A :=\n  det_submatrix_equiv_self e.symm A\n\n"}
{"name":"Matrix.det_smul","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nA : Matrix n n R\nc : R\n⊢ Eq (HSMul.hSMul c A).det (HMul.hMul (HPow.hPow c (Fintype.card n)) A.det)","decl":"theorem det_smul (A : Matrix n n R) (c : R) : det (c • A) = c ^ Fintype.card n * det A :=\n  calc\n    det (c • A) = det ((diagonal fun _ => c) * A) := by rw [smul_eq_diagonal_mul]\n    _ = det (diagonal fun _ => c) * det A := det_mul _ _\n    _ = c ^ Fintype.card n * det A := by simp [card_univ]\n\n"}
{"name":"Matrix.det_smul_of_tower","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝⁶ : DecidableEq n\ninst✝⁵ : Fintype n\nR : Type v\ninst✝⁴ : CommRing R\nα : Type u_3\ninst✝³ : Monoid α\ninst✝² : DistribMulAction α R\ninst✝¹ : IsScalarTower α R R\ninst✝ : SMulCommClass α R R\nc : α\nA : Matrix n n R\n⊢ Eq (HSMul.hSMul c A).det (HSMul.hSMul (HPow.hPow c (Fintype.card n)) A.det)","decl":"@[simp]\ntheorem det_smul_of_tower {α} [Monoid α] [DistribMulAction α R] [IsScalarTower α R R]\n    [SMulCommClass α R R] (c : α) (A : Matrix n n R) :\n    det (c • A) = c ^ Fintype.card n • det A := by\n  rw [← smul_one_smul R c A, det_smul, smul_pow, one_pow, smul_mul_assoc, one_mul]\n\n"}
{"name":"Matrix.det_neg","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nA : Matrix n n R\n⊢ Eq (Neg.neg A).det (HMul.hMul (HPow.hPow (-1) (Fintype.card n)) A.det)","decl":"theorem det_neg (A : Matrix n n R) : det (-A) = (-1) ^ Fintype.card n * det A := by\n  rw [← det_smul, neg_one_smul]\n\n"}
{"name":"Matrix.det_neg_eq_smul","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nA : Matrix n n R\n⊢ Eq (Neg.neg A).det (HSMul.hSMul (HPow.hPow (-1) (Fintype.card n)) A.det)","decl":"/-- A variant of `Matrix.det_neg` with scalar multiplication by `Units ℤ` instead of multiplication\nby `R`. -/\ntheorem det_neg_eq_smul (A : Matrix n n R) :\n    det (-A) = (-1 : Units ℤ) ^ Fintype.card n • det A := by\n  rw [← det_smul_of_tower, Units.neg_smul, one_smul]\n\n"}
{"name":"Matrix.det_mul_row","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nv : n → R\nA : Matrix n n R\n⊢ Eq (Matrix.of fun i j => HMul.hMul (v j) (A i j)).det (HMul.hMul (Finset.univ.prod fun i => v i) A.det)","decl":"/-- Multiplying each row by a fixed `v i` multiplies the determinant by\nthe product of the `v`s. -/\ntheorem det_mul_row (v : n → R) (A : Matrix n n R) :\n    det (of fun i j => v j * A i j) = (∏ i, v i) * det A :=\n  calc\n    det (of fun i j => v j * A i j) = det (A * diagonal v) :=\n      congr_arg det <| by\n        ext\n        simp [mul_comm]\n    _ = (∏ i, v i) * det A := by rw [det_mul, det_diagonal, mul_comm]\n\n"}
{"name":"Matrix.det_mul_column","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nv : n → R\nA : Matrix n n R\n⊢ Eq (Matrix.of fun i j => HMul.hMul (v i) (A i j)).det (HMul.hMul (Finset.univ.prod fun i => v i) A.det)","decl":"/-- Multiplying each column by a fixed `v j` multiplies the determinant by\nthe product of the `v`s. -/\ntheorem det_mul_column (v : n → R) (A : Matrix n n R) :\n    det (of fun i j => v i * A i j) = (∏ i, v i) * det A :=\n  MultilinearMap.map_smul_univ _ v A\n\n"}
{"name":"Matrix.det_pow","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"m : Type u_1\ninst✝² : DecidableEq m\ninst✝¹ : Fintype m\nR : Type v\ninst✝ : CommRing R\nM : Matrix m m R\nn : Nat\n⊢ Eq (HPow.hPow M n).det (HPow.hPow M.det n)","decl":"@[simp]\ntheorem det_pow (M : Matrix m m R) (n : ℕ) : det (M ^ n) = det M ^ n :=\n  (detMonoidHom : Matrix m m R →* R).map_pow M n\n\n"}
{"name":"RingHom.map_det","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\nR : Type v\ninst✝¹ : CommRing R\nS : Type w\ninst✝ : CommRing S\nf : RingHom R S\nM : Matrix n n R\n⊢ Eq (f M.det) (f.mapMatrix M).det","decl":"theorem _root_.RingHom.map_det (f : R →+* S) (M : Matrix n n R) :\n    f M.det = Matrix.det (f.mapMatrix M) := by\n  simp [Matrix.det_apply', map_sum f, map_prod f]\n\n"}
{"name":"RingEquiv.map_det","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\nR : Type v\ninst✝¹ : CommRing R\nS : Type w\ninst✝ : CommRing S\nf : RingEquiv R S\nM : Matrix n n R\n⊢ Eq (f M.det) (f.mapMatrix M).det","decl":"theorem _root_.RingEquiv.map_det (f : R ≃+* S) (M : Matrix n n R) :\n    f M.det = Matrix.det (f.mapMatrix M) :=\n  f.toRingHom.map_det _\n\n"}
{"name":"AlgHom.map_det","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝⁶ : DecidableEq n\ninst✝⁵ : Fintype n\nR : Type v\ninst✝⁴ : CommRing R\nS : Type w\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nT : Type z\ninst✝¹ : CommRing T\ninst✝ : Algebra R T\nf : AlgHom R S T\nM : Matrix n n S\n⊢ Eq (f M.det) (f.mapMatrix M).det","decl":"theorem _root_.AlgHom.map_det [Algebra R S] {T : Type z} [CommRing T] [Algebra R T] (f : S →ₐ[R] T)\n    (M : Matrix n n S) : f M.det = Matrix.det (f.mapMatrix M) :=\n  f.toRingHom.map_det _\n\n"}
{"name":"AlgEquiv.map_det","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝⁶ : DecidableEq n\ninst✝⁵ : Fintype n\nR : Type v\ninst✝⁴ : CommRing R\nS : Type w\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nT : Type z\ninst✝¹ : CommRing T\ninst✝ : Algebra R T\nf : AlgEquiv R S T\nM : Matrix n n S\n⊢ Eq (f M.det) (f.mapMatrix M).det","decl":"theorem _root_.AlgEquiv.map_det [Algebra R S] {T : Type z} [CommRing T] [Algebra R T]\n    (f : S ≃ₐ[R] T) (M : Matrix n n S) : f M.det = Matrix.det (f.mapMatrix M) :=\n  f.toAlgHom.map_det _\n\n"}
{"name":"Matrix.det_conjTranspose","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"m : Type u_1\ninst✝³ : DecidableEq m\ninst✝² : Fintype m\nR : Type v\ninst✝¹ : CommRing R\ninst✝ : StarRing R\nM : Matrix m m R\n⊢ Eq M.conjTranspose.det (Star.star M.det)","decl":"@[simp]\ntheorem det_conjTranspose [StarRing R] (M : Matrix m m R) : det Mᴴ = star (det M) :=\n  ((starRingEnd R).map_det _).symm.trans <| congr_arg star M.det_transpose\n\n"}
{"name":"Matrix.det_eq_zero_of_row_eq_zero","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nA : Matrix n n R\ni : n\nh : ∀ (j : n), Eq (A i j) 0\n⊢ Eq A.det 0","decl":"theorem det_eq_zero_of_row_eq_zero {A : Matrix n n R} (i : n) (h : ∀ j, A i j = 0) : det A = 0 :=\n  (detRowAlternating : (n → R) [⋀^n]→ₗ[R] R).map_coord_zero i (funext h)\n\n"}
{"name":"Matrix.det_eq_zero_of_column_eq_zero","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nA : Matrix n n R\nj : n\nh : ∀ (i : n), Eq (A i j) 0\n⊢ Eq A.det 0","decl":"theorem det_eq_zero_of_column_eq_zero {A : Matrix n n R} (j : n) (h : ∀ i, A i j = 0) :\n    det A = 0 := by\n  rw [← det_transpose]\n  exact det_eq_zero_of_row_eq_zero j h\n\n"}
{"name":"Matrix.det_zero_of_row_eq","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nM : Matrix n n R\ni j : n\ni_ne_j : Ne i j\nhij : Eq (M i) (M j)\n⊢ Eq M.det 0","decl":"/-- If a matrix has a repeated row, the determinant will be zero. -/\ntheorem det_zero_of_row_eq (i_ne_j : i ≠ j) (hij : M i = M j) : M.det = 0 :=\n  (detRowAlternating : (n → R) [⋀^n]→ₗ[R] R).map_eq_zero_of_eq M hij i_ne_j\n\n"}
{"name":"Matrix.det_zero_of_column_eq","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nM : Matrix n n R\ni j : n\ni_ne_j : Ne i j\nhij : ∀ (k : n), Eq (M k i) (M k j)\n⊢ Eq M.det 0","decl":"/-- If a matrix has a repeated column, the determinant will be zero. -/\ntheorem det_zero_of_column_eq (i_ne_j : i ≠ j) (hij : ∀ k, M k i = M k j) : M.det = 0 := by\n  rw [← det_transpose, det_zero_of_row_eq i_ne_j]\n  exact funext hij\n\n"}
{"name":"Matrix.det_updateRow_eq_zero","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nM : Matrix n n R\ni j : n\nh : Ne i j\n⊢ Eq (M.updateRow j (M i)).det 0","decl":"/-- If we repeat a row of a matrix, we get a matrix of determinant zero. -/\ntheorem det_updateRow_eq_zero (h : i ≠ j) :\n    (M.updateRow j (M i)).det = 0 := det_zero_of_row_eq h (by simp [h])\n\n"}
{"name":"Matrix.det_updateCol_eq_zero","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nM : Matrix n n R\ni j : n\nh : Ne i j\n⊢ Eq (M.updateCol j fun k => M k i).det 0","decl":"/-- If we repeat a column of a matrix, we get a matrix of determinant zero. -/\ntheorem det_updateCol_eq_zero (h : i ≠ j) :\n    (M.updateCol j (fun k ↦ M k i)).det = 0 := det_zero_of_column_eq h (by simp [h])\n\n"}
{"name":"Matrix.det_updateColumn_eq_zero","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nM : Matrix n n R\ni j : n\nh : Ne i j\n⊢ Eq (M.updateCol j fun k => M k i).det 0","decl":"@[deprecated (since := \"2024-12-11\")] alias det_updateColumn_eq_zero := det_updateCol_eq_zero\n\n"}
{"name":"Matrix.det_updateRow_add","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nM : Matrix n n R\nj : n\nu v : n → R\n⊢ Eq (M.updateRow j (HAdd.hAdd u v)).det (HAdd.hAdd (M.updateRow j u).det (M.updateRow j v).det)","decl":"theorem det_updateRow_add (M : Matrix n n R) (j : n) (u v : n → R) :\n    det (updateRow M j <| u + v) = det (updateRow M j u) + det (updateRow M j v) :=\n  (detRowAlternating : (n → R) [⋀^n]→ₗ[R] R).map_update_add M j u v\n\n"}
{"name":"Matrix.det_updateCol_add","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nM : Matrix n n R\nj : n\nu v : n → R\n⊢ Eq (M.updateCol j (HAdd.hAdd u v)).det (HAdd.hAdd (M.updateCol j u).det (M.updateCol j v).det)","decl":"theorem det_updateCol_add (M : Matrix n n R) (j : n) (u v : n → R) :\n    det (updateCol M j <| u + v) = det (updateCol M j u) + det (updateCol M j v) := by\n  rw [← det_transpose, ← updateRow_transpose, det_updateRow_add]\n  simp [updateRow_transpose, det_transpose]\n\n"}
{"name":"Matrix.det_updateColumn_add","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nM : Matrix n n R\nj : n\nu v : n → R\n⊢ Eq (M.updateCol j (HAdd.hAdd u v)).det (HAdd.hAdd (M.updateCol j u).det (M.updateCol j v).det)","decl":"@[deprecated (since := \"2024-12-11\")] alias det_updateColumn_add := det_updateCol_add\n\n"}
{"name":"Matrix.det_updateRow_smul","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nM : Matrix n n R\nj : n\ns : R\nu : n → R\n⊢ Eq (M.updateRow j (HSMul.hSMul s u)).det (HMul.hMul s (M.updateRow j u).det)","decl":"theorem det_updateRow_smul (M : Matrix n n R) (j : n) (s : R) (u : n → R) :\n    det (updateRow M j <| s • u) = s * det (updateRow M j u) :=\n  (detRowAlternating : (n → R) [⋀^n]→ₗ[R] R).map_update_smul M j s u\n\n"}
{"name":"Matrix.det_updateCol_smul","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nM : Matrix n n R\nj : n\ns : R\nu : n → R\n⊢ Eq (M.updateCol j (HSMul.hSMul s u)).det (HMul.hMul s (M.updateCol j u).det)","decl":"theorem det_updateCol_smul (M : Matrix n n R) (j : n) (s : R) (u : n → R) :\n    det (updateCol M j <| s • u) = s * det (updateCol M j u) := by\n  rw [← det_transpose, ← updateRow_transpose, det_updateRow_smul]\n  simp [updateRow_transpose, det_transpose]\n\n"}
{"name":"Matrix.det_updateColumn_smul","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nM : Matrix n n R\nj : n\ns : R\nu : n → R\n⊢ Eq (M.updateCol j (HSMul.hSMul s u)).det (HMul.hMul s (M.updateCol j u).det)","decl":"@[deprecated (since := \"2024-12-11\")] alias det_updateColumn_smul := det_updateCol_smul\n\n"}
{"name":"Matrix.det_updateRow_smul_left","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nM : Matrix n n R\nj : n\ns : R\nu : n → R\n⊢ Eq ((HSMul.hSMul s M).updateRow j u).det (HMul.hMul (HPow.hPow s (HSub.hSub (Fintype.card n) 1)) (M.updateRow j u).det)","decl":"theorem det_updateRow_smul_left (M : Matrix n n R) (j : n) (s : R) (u : n → R) :\n    det (updateRow (s • M) j u) = s ^ (Fintype.card n - 1) * det (updateRow M j u) :=\n  MultilinearMap.map_update_smul_left _ M j s u\n\n"}
{"name":"Matrix.det_updateRow_smul'","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nM : Matrix n n R\nj : n\ns : R\nu : n → R\n⊢ Eq ((HSMul.hSMul s M).updateRow j u).det (HMul.hMul (HPow.hPow s (HSub.hSub (Fintype.card n) 1)) (M.updateRow j u).det)","decl":"@[deprecated (since := \"2024-11-03\")] alias det_updateRow_smul' := det_updateRow_smul_left\n\n"}
{"name":"Matrix.det_updateCol_smul_left","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nM : Matrix n n R\nj : n\ns : R\nu : n → R\n⊢ Eq ((HSMul.hSMul s M).updateCol j u).det (HMul.hMul (HPow.hPow s (HSub.hSub (Fintype.card n) 1)) (M.updateCol j u).det)","decl":"theorem det_updateCol_smul_left (M : Matrix n n R) (j : n) (s : R) (u : n → R) :\n    det (updateCol (s • M) j u) = s ^ (Fintype.card n - 1) * det (updateCol M j u) := by\n  rw [← det_transpose, ← updateRow_transpose, transpose_smul, det_updateRow_smul_left]\n  simp [updateRow_transpose, det_transpose]\n\n"}
{"name":"Matrix.det_updateColumn_smul'","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nM : Matrix n n R\nj : n\ns : R\nu : n → R\n⊢ Eq ((HSMul.hSMul s M).updateCol j u).det (HMul.hMul (HPow.hPow s (HSub.hSub (Fintype.card n) 1)) (M.updateCol j u).det)","decl":"@[deprecated (since := \"2024-12-11\")] alias det_updateColumn_smul' := det_updateCol_smul_left\n"}
{"name":"Matrix.det_updateColumn_smul_left","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nM : Matrix n n R\nj : n\ns : R\nu : n → R\n⊢ Eq ((HSMul.hSMul s M).updateCol j u).det (HMul.hMul (HPow.hPow s (HSub.hSub (Fintype.card n) 1)) (M.updateCol j u).det)","decl":"@[deprecated (since := \"2024-12-11\")] alias det_updateColumn_smul_left := det_updateCol_smul_left\n\n"}
{"name":"Matrix.det_updateRow_sum_aux","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nM : Matrix n n R\nj : n\ns : Finset n\nhj : Not (Membership.mem s j)\nc : n → R\na : R\n⊢ Eq (M.updateRow j (HAdd.hAdd (HSMul.hSMul a (M j)) (s.sum fun k => HSMul.hSMul (c k) (M k)))).det (HSMul.hSMul a M.det)","decl":"theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)\n    (a : R) :\n    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by\n  induction s using Finset.induction_on with\n  | empty => rw [Finset.sum_empty, add_zero, smul_eq_mul, det_updateRow_smul, updateRow_eq_self]\n  | @insert k _ hk h_ind =>\n      have h : k ≠ j := fun h ↦ (h ▸ hj) (Finset.mem_insert_self _ _)\n      rw [Finset.sum_insert hk, add_comm ((c k) • M k), ← add_assoc, det_updateRow_add,\n        det_updateRow_smul, det_updateRow_eq_zero h, mul_zero, add_zero, h_ind]\n      exact fun h ↦ hj (Finset.mem_insert_of_mem h)\n\n"}
{"name":"Matrix.det_updateRow_sum","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nA : Matrix n n R\nj : n\nc : n → R\n⊢ Eq (A.updateRow j (Finset.univ.sum fun k => HSMul.hSMul (c k) (A k))).det (HSMul.hSMul (c j) A.det)","decl":"/-- If we replace a row of a matrix by a linear combination of its rows, then the determinant is\nmultiplied by the coefficient of that row. -/\ntheorem det_updateRow_sum (A : Matrix n n R) (j : n) (c : n → R) :\n    (A.updateRow j (∑ k, (c k) • A k)).det = (c j) • A.det := by\n  convert det_updateRow_sum_aux A (Finset.univ.erase j) (Finset.univ.not_mem_erase j) c (c j)\n  rw [← Finset.univ.add_sum_erase _ (Finset.mem_univ j)]\n\n"}
{"name":"Matrix.det_updateCol_sum","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nA : Matrix n n R\nj : n\nc : n → R\n⊢ Eq (A.updateCol j fun k => Finset.univ.sum fun i => HSMul.hSMul (c i) (A k i)).det (HSMul.hSMul (c j) A.det)","decl":"/-- If we replace a column of a matrix by a linear combination of its columns, then the determinant\nis multiplied by the coefficient of that column. -/\ntheorem det_updateCol_sum (A : Matrix n n R) (j : n) (c : n → R) :\n    (A.updateCol j (fun k ↦ ∑ i, (c i) • A k i)).det = (c j) • A.det := by\n  rw [← det_transpose, ← updateRow_transpose, ← det_transpose A]\n  convert det_updateRow_sum A.transpose j c\n  simp only [smul_eq_mul, Finset.sum_apply, Pi.smul_apply, transpose_apply]\n\n"}
{"name":"Matrix.det_updateColumn_sum","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nA : Matrix n n R\nj : n\nc : n → R\n⊢ Eq (A.updateCol j fun k => Finset.univ.sum fun i => HSMul.hSMul (c i) (A k i)).det (HSMul.hSMul (c j) A.det)","decl":"@[deprecated (since := \"2024-12-11\")] alias det_updateColumn_sum := det_updateCol_sum\n\n"}
{"name":"Matrix.det_eq_of_eq_mul_det_one","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nA B C : Matrix n n R\nhC : Eq C.det 1\nhA : Eq A (HMul.hMul B C)\n⊢ Eq A.det B.det","decl":"theorem det_eq_of_eq_mul_det_one {A B : Matrix n n R} (C : Matrix n n R) (hC : det C = 1)\n    (hA : A = B * C) : det A = det B :=\n  calc\n    det A = det (B * C) := congr_arg _ hA\n    _ = det B * det C := det_mul _ _\n    _ = det B := by rw [hC, mul_one]\n\n"}
{"name":"Matrix.det_eq_of_eq_det_one_mul","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nA B C : Matrix n n R\nhC : Eq C.det 1\nhA : Eq A (HMul.hMul C B)\n⊢ Eq A.det B.det","decl":"theorem det_eq_of_eq_det_one_mul {A B : Matrix n n R} (C : Matrix n n R) (hC : det C = 1)\n    (hA : A = C * B) : det A = det B :=\n  calc\n    det A = det (C * B) := congr_arg _ hA\n    _ = det C * det B := det_mul _ _\n    _ = det B := by rw [hC, one_mul]\n\n"}
{"name":"Matrix.det_updateRow_add_self","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nA : Matrix n n R\ni j : n\nhij : Ne i j\n⊢ Eq (A.updateRow i (HAdd.hAdd (A i) (A j))).det A.det","decl":"theorem det_updateRow_add_self (A : Matrix n n R) {i j : n} (hij : i ≠ j) :\n    det (updateRow A i (A i + A j)) = det A := by\n  simp [det_updateRow_add,\n    det_zero_of_row_eq hij (updateRow_self.trans (updateRow_ne hij.symm).symm)]\n\n"}
{"name":"Matrix.det_updateCol_add_self","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nA : Matrix n n R\ni j : n\nhij : Ne i j\n⊢ Eq (A.updateCol i fun k => HAdd.hAdd (A k i) (A k j)).det A.det","decl":"theorem det_updateCol_add_self (A : Matrix n n R) {i j : n} (hij : i ≠ j) :\n    det (updateCol A i fun k => A k i + A k j) = det A := by\n  rw [← det_transpose, ← updateRow_transpose, ← det_transpose A]\n  exact det_updateRow_add_self Aᵀ hij\n\n"}
{"name":"Matrix.det_updateColumn_add_self","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nA : Matrix n n R\ni j : n\nhij : Ne i j\n⊢ Eq (A.updateCol i fun k => HAdd.hAdd (A k i) (A k j)).det A.det","decl":"@[deprecated (since := \"2024-12-11\")] alias det_updateColumn_add_self := det_updateCol_add_self\n\n"}
{"name":"Matrix.det_updateRow_add_smul_self","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nA : Matrix n n R\ni j : n\nhij : Ne i j\nc : R\n⊢ Eq (A.updateRow i (HAdd.hAdd (A i) (HSMul.hSMul c (A j)))).det A.det","decl":"theorem det_updateRow_add_smul_self (A : Matrix n n R) {i j : n} (hij : i ≠ j) (c : R) :\n    det (updateRow A i (A i + c • A j)) = det A := by\n  simp [det_updateRow_add, det_updateRow_smul,\n    det_zero_of_row_eq hij (updateRow_self.trans (updateRow_ne hij.symm).symm)]\n\n"}
{"name":"Matrix.det_updateCol_add_smul_self","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nA : Matrix n n R\ni j : n\nhij : Ne i j\nc : R\n⊢ Eq (A.updateCol i fun k => HAdd.hAdd (A k i) (HSMul.hSMul c (A k j))).det A.det","decl":"theorem det_updateCol_add_smul_self (A : Matrix n n R) {i j : n} (hij : i ≠ j) (c : R) :\n    det (updateCol A i fun k => A k i + c • A k j) = det A := by\n  rw [← det_transpose, ← updateRow_transpose, ← det_transpose A]\n  exact det_updateRow_add_smul_self Aᵀ hij c\n\n"}
{"name":"Matrix.det_updateColumn_add_smul_self","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nA : Matrix n n R\ni j : n\nhij : Ne i j\nc : R\n⊢ Eq (A.updateCol i fun k => HAdd.hAdd (A k i) (HSMul.hSMul c (A k j))).det A.det","decl":"@[deprecated (since := \"2024-12-11\")]\nalias det_updateColumn_add_smul_self := det_updateCol_add_smul_self\n\n"}
{"name":"Matrix.det_eq_of_forall_row_eq_smul_add_const_aux","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nA B : Matrix n n R\ns : Finset n\nc : n → R\nx✝² : ∀ (i : n), Not (Membership.mem s i) → Eq (c i) 0\nk : n\nx✝¹ : Not (Membership.mem s k)\nx✝ : ∀ (i j : n), Eq (A i j) (HAdd.hAdd (B i j) (HMul.hMul (c i) (B k j)))\n⊢ Eq A.det B.det","decl":"theorem det_eq_of_forall_row_eq_smul_add_const_aux {A B : Matrix n n R} {s : Finset n} :\n    ∀ (c : n → R) (_ : ∀ i, i ∉ s → c i = 0) (k : n) (_ : k ∉ s)\n      (_ : ∀ i j, A i j = B i j + c i * B k j), det A = det B := by\n  induction s using Finset.induction_on generalizing B with\n  | empty =>\n    rintro c hs k - A_eq\n    have : ∀ i, c i = 0 := by\n      intro i\n      specialize hs i\n      contrapose! hs\n      simp [hs]\n    congr\n    ext i j\n    rw [A_eq, this, zero_mul, add_zero]\n  | @insert i s _hi ih =>\n    intro c hs k hk A_eq\n    have hAi : A i = B i + c i • B k := funext (A_eq i)\n    rw [@ih (updateRow B i (A i)) (Function.update c i 0), hAi, det_updateRow_add_smul_self]\n    · exact mt (fun h => show k ∈ insert i s from h ▸ Finset.mem_insert_self _ _) hk\n    · intro i' hi'\n      rw [Function.update_apply]\n      split_ifs with hi'i\n      · rfl\n      · exact hs i' fun h => hi' ((Finset.mem_insert.mp h).resolve_left hi'i)\n    · exact k\n    · exact fun h => hk (Finset.mem_insert_of_mem h)\n    · intro i' j'\n      rw [updateRow_apply, Function.update_apply]\n      split_ifs with hi'i\n      · simp [hi'i]\n      rw [A_eq, updateRow_ne fun h : k = i => hk <| h ▸ Finset.mem_insert_self k s]\n\n"}
{"name":"Matrix.det_eq_of_forall_row_eq_smul_add_const","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type v\ninst✝ : CommRing R\nA B : Matrix n n R\nc : n → R\nk : n\nhk : Eq (c k) 0\nA_eq : ∀ (i j : n), Eq (A i j) (HAdd.hAdd (B i j) (HMul.hMul (c i) (B k j)))\n⊢ Eq A.det B.det","decl":"/-- If you add multiples of row `B k` to other rows, the determinant doesn't change. -/\ntheorem det_eq_of_forall_row_eq_smul_add_const {A B : Matrix n n R} (c : n → R) (k : n)\n    (hk : c k = 0) (A_eq : ∀ i j, A i j = B i j + c i * B k j) : det A = det B :=\n  det_eq_of_forall_row_eq_smul_add_const_aux c\n    (fun i =>\n      not_imp_comm.mp fun hi =>\n        Finset.mem_erase.mpr\n          ⟨mt (fun h : i = k => show c i = 0 from h.symm ▸ hk) hi, Finset.mem_univ i⟩)\n    k (Finset.not_mem_erase k Finset.univ) A_eq\n\n"}
{"name":"Matrix.det_eq_of_forall_row_eq_smul_add_pred_aux","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"R : Type v\ninst✝ : CommRing R\nn : Nat\nk : Fin (HAdd.hAdd n 1)\nc : Fin n → R\n_hc : ∀ (i : Fin n), LT.lt k i.succ → Eq (c i) 0\nM N : Matrix (Fin n.succ) (Fin n.succ) R\n_h0 : ∀ (j : Fin n.succ), Eq (M 0 j) (N 0 j)\n_hsucc : ∀ (i : Fin n) (j : Fin n.succ), Eq (M i.succ j) (HAdd.hAdd (N i.succ j) (HMul.hMul (c i) (M i.castSucc j)))\n⊢ Eq M.det N.det","decl":"theorem det_eq_of_forall_row_eq_smul_add_pred_aux {n : ℕ} (k : Fin (n + 1)) :\n    ∀ (c : Fin n → R) (_hc : ∀ i : Fin n, k < i.succ → c i = 0)\n      {M N : Matrix (Fin n.succ) (Fin n.succ) R} (_h0 : ∀ j, M 0 j = N 0 j)\n      (_hsucc : ∀ (i : Fin n) (j), M i.succ j = N i.succ j + c i * M (Fin.castSucc i) j),\n      det M = det N := by\n  refine Fin.induction ?_ (fun k ih => ?_) k <;> intro c hc M N h0 hsucc\n  · congr\n    ext i j\n    refine Fin.cases (h0 j) (fun i => ?_) i\n    rw [hsucc, hc i (Fin.succ_pos _), zero_mul, add_zero]\n  set M' := updateRow M k.succ (N k.succ) with hM'\n  have hM : M = updateRow M' k.succ (M' k.succ + c k • M (Fin.castSucc k)) := by\n    ext i j\n    by_cases hi : i = k.succ\n    · simp [hi, hM', hsucc, updateRow_self]\n    rw [updateRow_ne hi, hM', updateRow_ne hi]\n  have k_ne_succ : (Fin.castSucc k) ≠ k.succ := (Fin.castSucc_lt_succ k).ne\n  have M_k : M (Fin.castSucc k) = M' (Fin.castSucc k) := (updateRow_ne k_ne_succ).symm\n  rw [hM, M_k, det_updateRow_add_smul_self M' k_ne_succ.symm, ih (Function.update c k 0)]\n  · intro i hi\n    rw [Fin.lt_iff_val_lt_val, Fin.coe_castSucc, Fin.val_succ, Nat.lt_succ_iff] at hi\n    rw [Function.update_apply]\n    split_ifs with hik\n    · rfl\n    exact hc _ (Fin.succ_lt_succ_iff.mpr (lt_of_le_of_ne hi (Ne.symm hik)))\n  · rwa [hM', updateRow_ne (Fin.succ_ne_zero _).symm]\n  intro i j\n  rw [Function.update_apply]\n  split_ifs with hik\n  · rw [zero_mul, add_zero, hM', hik, updateRow_self]\n  rw [hM', updateRow_ne ((Fin.succ_injective _).ne hik), hsucc]\n  by_cases hik2 : k < i\n  · simp [hc i (Fin.succ_lt_succ_iff.mpr hik2)]\n  rw [updateRow_ne]\n  apply ne_of_lt\n  rwa [Fin.lt_iff_val_lt_val, Fin.coe_castSucc, Fin.val_succ, Nat.lt_succ_iff, ← not_lt]\n\n"}
{"name":"Matrix.det_eq_of_forall_row_eq_smul_add_pred","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"R : Type v\ninst✝ : CommRing R\nn : Nat\nA B : Matrix (Fin (HAdd.hAdd n 1)) (Fin (HAdd.hAdd n 1)) R\nc : Fin n → R\nA_zero : ∀ (j : Fin (HAdd.hAdd n 1)), Eq (A 0 j) (B 0 j)\nA_succ : ∀ (i : Fin n) (j : Fin (HAdd.hAdd n 1)), Eq (A i.succ j) (HAdd.hAdd (B i.succ j) (HMul.hMul (c i) (A i.castSucc j)))\n⊢ Eq A.det B.det","decl":"/-- If you add multiples of previous rows to the next row, the determinant doesn't change. -/\ntheorem det_eq_of_forall_row_eq_smul_add_pred {n : ℕ} {A B : Matrix (Fin (n + 1)) (Fin (n + 1)) R}\n    (c : Fin n → R) (A_zero : ∀ j, A 0 j = B 0 j)\n    (A_succ : ∀ (i : Fin n) (j), A i.succ j = B i.succ j + c i * A (Fin.castSucc i) j) :\n    det A = det B :=\n  det_eq_of_forall_row_eq_smul_add_pred_aux (Fin.last _) c\n    (fun _ hi => absurd hi (not_lt_of_ge (Fin.le_last _))) A_zero A_succ\n\n"}
{"name":"Matrix.det_eq_of_forall_col_eq_smul_add_pred","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"R : Type v\ninst✝ : CommRing R\nn : Nat\nA B : Matrix (Fin (HAdd.hAdd n 1)) (Fin (HAdd.hAdd n 1)) R\nc : Fin n → R\nA_zero : ∀ (i : Fin (HAdd.hAdd n 1)), Eq (A i 0) (B i 0)\nA_succ : ∀ (i : Fin (HAdd.hAdd n 1)) (j : Fin n), Eq (A i j.succ) (HAdd.hAdd (B i j.succ) (HMul.hMul (c j) (A i j.castSucc)))\n⊢ Eq A.det B.det","decl":"/-- If you add multiples of previous columns to the next columns, the determinant doesn't change. -/\ntheorem det_eq_of_forall_col_eq_smul_add_pred {n : ℕ} {A B : Matrix (Fin (n + 1)) (Fin (n + 1)) R}\n    (c : Fin n → R) (A_zero : ∀ i, A i 0 = B i 0)\n    (A_succ : ∀ (i) (j : Fin n), A i j.succ = B i j.succ + c j * A i (Fin.castSucc j)) :\n    det A = det B := by\n  rw [← det_transpose A, ← det_transpose B]\n  exact det_eq_of_forall_row_eq_smul_add_pred c A_zero fun i j => A_succ j i\n\n"}
{"name":"Matrix.det_blockDiagonal","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"n : Type u_2\ninst✝⁴ : DecidableEq n\ninst✝³ : Fintype n\nR : Type v\ninst✝² : CommRing R\no : Type u_3\ninst✝¹ : Fintype o\ninst✝ : DecidableEq o\nM : o → Matrix n n R\n⊢ Eq (Matrix.blockDiagonal M).det (Finset.univ.prod fun k => (M k).det)","decl":"@[simp]\ntheorem det_blockDiagonal {o : Type*} [Fintype o] [DecidableEq o] (M : o → Matrix n n R) :\n    (blockDiagonal M).det = ∏ k, (M k).det := by\n  -- Rewrite the determinants as a sum over permutations.\n  simp_rw [det_apply']\n  -- The right hand side is a product of sums, rewrite it as a sum of products.\n  rw [Finset.prod_sum]\n  simp_rw [Finset.prod_attach_univ, Finset.univ_pi_univ]\n  -- We claim that the only permutations contributing to the sum are those that\n  -- preserve their second component.\n  let preserving_snd : Finset (Equiv.Perm (n × o)) := {σ | ∀ x, (σ x).snd = x.snd}\n  have mem_preserving_snd :\n    ∀ {σ : Equiv.Perm (n × o)}, σ ∈ preserving_snd ↔ ∀ x, (σ x).snd = x.snd := fun {σ} =>\n    Finset.mem_filter.trans ⟨fun h => h.2, fun h => ⟨Finset.mem_univ _, h⟩⟩\n  rw [← Finset.sum_subset (Finset.subset_univ preserving_snd) _]\n  -- And that these are in bijection with `o → Equiv.Perm m`.\n  · refine (Finset.sum_bij (fun σ _ => prodCongrLeft fun k ↦ σ k (mem_univ k)) ?_ ?_ ?_ ?_).symm\n    · intro σ _\n      rw [mem_preserving_snd]\n      rintro ⟨-, x⟩\n      simp only [prodCongrLeft_apply]\n    · intro σ _ σ' _ eq\n      ext x hx k\n      simp only at eq\n      have :\n        ∀ k x,\n          prodCongrLeft (fun k => σ k (Finset.mem_univ _)) (k, x) =\n            prodCongrLeft (fun k => σ' k (Finset.mem_univ _)) (k, x) :=\n        fun k x => by rw [eq]\n      simp only [prodCongrLeft_apply, Prod.mk.inj_iff] at this\n      exact (this k x).1\n    · intro σ hσ\n      rw [mem_preserving_snd] at hσ\n      have hσ' : ∀ x, (σ⁻¹ x).snd = x.snd := by\n        intro x\n        conv_rhs => rw [← Perm.apply_inv_self σ x, hσ]\n      have mk_apply_eq : ∀ k x, ((σ (x, k)).fst, k) = σ (x, k) := by\n        intro k x\n        ext\n        · simp only\n        · simp only [hσ]\n      have mk_inv_apply_eq : ∀ k x, ((σ⁻¹ (x, k)).fst, k) = σ⁻¹ (x, k) := by\n        intro k x\n        conv_lhs => rw [← Perm.apply_inv_self σ (x, k)]\n        ext\n        · simp only [apply_inv_self]\n        · simp only [hσ']\n      refine ⟨fun k _ => ⟨fun x => (σ (x, k)).fst, fun x => (σ⁻¹ (x, k)).fst, ?_, ?_⟩, ?_, ?_⟩\n      · intro x\n        simp only [mk_apply_eq, inv_apply_self]\n      · intro x\n        simp only [mk_inv_apply_eq, apply_inv_self]\n      · apply Finset.mem_univ\n      · ext ⟨k, x⟩\n        · simp only [coe_fn_mk, prodCongrLeft_apply]\n        · simp only [prodCongrLeft_apply, hσ]\n    · intro σ _\n      rw [Finset.prod_mul_distrib, ← Finset.univ_product_univ, Finset.prod_product_right]\n      simp only [sign_prodCongrLeft, Units.coe_prod, Int.cast_prod, blockDiagonal_apply_eq,\n        prodCongrLeft_apply]\n  · intro σ _ hσ\n    rw [mem_preserving_snd] at hσ\n    obtain ⟨⟨k, x⟩, hkx⟩ := not_forall.mp hσ\n    rw [Finset.prod_eq_zero (Finset.mem_univ (k, x)), mul_zero]\n    rw [blockDiagonal_apply_ne]\n    exact hkx\n\n"}
{"name":"Matrix.det_fromBlocks_zero₂₁","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"m : Type u_1\nn : Type u_2\ninst✝⁴ : DecidableEq n\ninst✝³ : Fintype n\ninst✝² : DecidableEq m\ninst✝¹ : Fintype m\nR : Type v\ninst✝ : CommRing R\nA : Matrix m m R\nB : Matrix m n R\nD : Matrix n n R\n⊢ Eq (Matrix.fromBlocks A B 0 D).det (HMul.hMul A.det D.det)","decl":"/-- The determinant of a 2×2 block matrix with the lower-left block equal to zero is the product of\nthe determinants of the diagonal blocks. For the generalization to any number of blocks, see\n`Matrix.det_of_upperTriangular`. -/\n@[simp]\ntheorem det_fromBlocks_zero₂₁ (A : Matrix m m R) (B : Matrix m n R) (D : Matrix n n R) :\n    (Matrix.fromBlocks A B 0 D).det = A.det * D.det := by\n  classical\n    simp_rw [det_apply']\n    convert Eq.symm <|\n      sum_subset (β := R) (subset_univ ((sumCongrHom m n).range : Set (Perm (m ⊕ n))).toFinset) ?_\n    · simp_rw [sum_mul_sum, ← sum_product', univ_product_univ]\n      refine sum_nbij (fun σ ↦ σ.fst.sumCongr σ.snd) ?_ ?_ ?_ ?_\n      · intro σ₁₂ _\n        simp\n      · intro σ₁ _ σ₂ _\n        dsimp only\n        intro h\n        have h2 : ∀ x, Perm.sumCongr σ₁.fst σ₁.snd x = Perm.sumCongr σ₂.fst σ₂.snd x :=\n          DFunLike.congr_fun h\n        simp only [Sum.map_inr, Sum.map_inl, Perm.sumCongr_apply, Sum.forall, Sum.inl.injEq,\n          Sum.inr.injEq] at h2\n        ext x\n        · exact h2.left x\n        · exact h2.right x\n      · intro σ hσ\n        erw [Set.mem_toFinset, MonoidHom.mem_range] at hσ\n        obtain ⟨σ₁₂, hσ₁₂⟩ := hσ\n        use σ₁₂\n        rw [← hσ₁₂]\n        simp\n      · simp only [forall_prop_of_true, Prod.forall, mem_univ]\n        intro σ₁ σ₂\n        rw [Fintype.prod_sum_type]\n        simp_rw [Equiv.sumCongr_apply, Sum.map_inr, Sum.map_inl, fromBlocks_apply₁₁,\n          fromBlocks_apply₂₂]\n        rw [mul_mul_mul_comm]\n        congr\n        rw [sign_sumCongr, Units.val_mul, Int.cast_mul]\n    · rintro σ - hσn\n      have h1 : ¬∀ x, ∃ y, Sum.inl y = σ (Sum.inl x) := by\n        rw [Set.mem_toFinset] at hσn\n        -- Porting note: golfed\n        simpa only [Set.MapsTo, Set.mem_range, forall_exists_index, forall_apply_eq_imp_iff] using\n          mt mem_sumCongrHom_range_of_perm_mapsTo_inl hσn\n      obtain ⟨a, ha⟩ := not_forall.mp h1\n      cases' hx : σ (Sum.inl a) with a2 b\n      · have hn := (not_exists.mp ha) a2\n        exact absurd hx.symm hn\n      · rw [Finset.prod_eq_zero (Finset.mem_univ (Sum.inl a)), mul_zero]\n        rw [hx, fromBlocks_apply₂₁, zero_apply]\n\n"}
{"name":"Matrix.det_fromBlocks_zero₁₂","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"m : Type u_1\nn : Type u_2\ninst✝⁴ : DecidableEq n\ninst✝³ : Fintype n\ninst✝² : DecidableEq m\ninst✝¹ : Fintype m\nR : Type v\ninst✝ : CommRing R\nA : Matrix m m R\nC : Matrix n m R\nD : Matrix n n R\n⊢ Eq (Matrix.fromBlocks A 0 C D).det (HMul.hMul A.det D.det)","decl":"/-- The determinant of a 2×2 block matrix with the upper-right block equal to zero is the product of\nthe determinants of the diagonal blocks. For the generalization to any number of blocks, see\n`Matrix.det_of_lowerTriangular`. -/\n@[simp]\ntheorem det_fromBlocks_zero₁₂ (A : Matrix m m R) (C : Matrix n m R) (D : Matrix n n R) :\n    (Matrix.fromBlocks A 0 C D).det = A.det * D.det := by\n  rw [← det_transpose, fromBlocks_transpose, transpose_zero, det_fromBlocks_zero₂₁, det_transpose,\n    det_transpose]\n\n"}
{"name":"Matrix.det_succ_column_zero","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"R : Type v\ninst✝ : CommRing R\nn : Nat\nA : Matrix (Fin n.succ) (Fin n.succ) R\n⊢ Eq A.det (Finset.univ.sum fun i => HMul.hMul (HMul.hMul (HPow.hPow (-1) ↑i) (A i 0)) (A.submatrix i.succAbove Fin.succ).det)","decl":"/-- Laplacian expansion of the determinant of an `n+1 × n+1` matrix along column 0. -/\ntheorem det_succ_column_zero {n : ℕ} (A : Matrix (Fin n.succ) (Fin n.succ) R) :\n    det A = ∑ i : Fin n.succ, (-1) ^ (i : ℕ) * A i 0 * det (A.submatrix i.succAbove Fin.succ) := by\n  rw [Matrix.det_apply, Finset.univ_perm_fin_succ, ← Finset.univ_product_univ]\n  simp only [Finset.sum_map, Equiv.toEmbedding_apply, Finset.sum_product, Matrix.submatrix]\n  refine Finset.sum_congr rfl fun i _ => Fin.cases ?_ (fun i => ?_) i\n  · simp only [Fin.prod_univ_succ, Matrix.det_apply, Finset.mul_sum,\n      Equiv.Perm.decomposeFin_symm_apply_zero, Fin.val_zero, one_mul,\n      Equiv.Perm.decomposeFin.symm_sign, Equiv.swap_self, if_true, id, eq_self_iff_true,\n      Equiv.Perm.decomposeFin_symm_apply_succ, Fin.succAbove_zero, Equiv.coe_refl, pow_zero,\n      mul_smul_comm, of_apply]\n  -- `univ_perm_fin_succ` gives a different embedding of `Perm (Fin n)` into\n  -- `Perm (Fin n.succ)` than the determinant of the submatrix we want,\n  -- permute `A` so that we get the correct one.\n  have : (-1 : R) ^ (i : ℕ) = (Perm.sign i.cycleRange) := by simp [Fin.sign_cycleRange]\n  rw [Fin.val_succ, pow_succ', this, mul_assoc, mul_assoc, mul_left_comm (ε _),\n    ← det_permute, Matrix.det_apply, Finset.mul_sum, Finset.mul_sum]\n  -- now we just need to move the corresponding parts to the same place\n  refine Finset.sum_congr rfl fun σ _ => ?_\n  rw [Equiv.Perm.decomposeFin.symm_sign, if_neg (Fin.succ_ne_zero i)]\n  calc\n    ((-1 * Perm.sign σ : ℤ) • ∏ i', A (Perm.decomposeFin.symm (Fin.succ i, σ) i') i') =\n        (-1 * Perm.sign σ : ℤ) • (A (Fin.succ i) 0 *\n          ∏ i', A ((Fin.succ i).succAbove (Fin.cycleRange i (σ i'))) i'.succ) := by\n      simp only [Fin.prod_univ_succ, Fin.succAbove_cycleRange,\n        Equiv.Perm.decomposeFin_symm_apply_zero, Equiv.Perm.decomposeFin_symm_apply_succ]\n    _ = -1 * (A (Fin.succ i) 0 * (Perm.sign σ : ℤ) •\n        ∏ i', A ((Fin.succ i).succAbove (Fin.cycleRange i (σ i'))) i'.succ) := by\n      simp [mul_assoc, mul_comm, _root_.neg_mul, one_mul, zsmul_eq_mul, neg_inj, neg_smul,\n        Fin.succAbove_cycleRange, mul_left_comm]\n\n"}
{"name":"Matrix.det_succ_row_zero","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"R : Type v\ninst✝ : CommRing R\nn : Nat\nA : Matrix (Fin n.succ) (Fin n.succ) R\n⊢ Eq A.det (Finset.univ.sum fun j => HMul.hMul (HMul.hMul (HPow.hPow (-1) ↑j) (A 0 j)) (A.submatrix Fin.succ j.succAbove).det)","decl":"/-- Laplacian expansion of the determinant of an `n+1 × n+1` matrix along row 0. -/\ntheorem det_succ_row_zero {n : ℕ} (A : Matrix (Fin n.succ) (Fin n.succ) R) :\n    det A = ∑ j : Fin n.succ, (-1) ^ (j : ℕ) * A 0 j * det (A.submatrix Fin.succ j.succAbove) := by\n  rw [← det_transpose A, det_succ_column_zero]\n  refine Finset.sum_congr rfl fun i _ => ?_\n  rw [← det_transpose]\n  simp only [transpose_apply, transpose_submatrix, transpose_transpose]\n\n"}
{"name":"Matrix.det_succ_row","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"R : Type v\ninst✝ : CommRing R\nn : Nat\nA : Matrix (Fin n.succ) (Fin n.succ) R\ni : Fin n.succ\n⊢ Eq A.det (Finset.univ.sum fun j => HMul.hMul (HMul.hMul (HPow.hPow (-1) (HAdd.hAdd ↑i ↑j)) (A i j)) (A.submatrix i.succAbove j.succAbove).det)","decl":"/-- Laplacian expansion of the determinant of an `n+1 × n+1` matrix along row `i`. -/\ntheorem det_succ_row {n : ℕ} (A : Matrix (Fin n.succ) (Fin n.succ) R) (i : Fin n.succ) :\n    det A =\n      ∑ j : Fin n.succ, (-1) ^ (i + j : ℕ) * A i j * det (A.submatrix i.succAbove j.succAbove) := by\n  simp_rw [pow_add, mul_assoc, ← mul_sum]\n  have : det A = (-1 : R) ^ (i : ℕ) * (Perm.sign i.cycleRange⁻¹) * det A := by\n    calc\n      det A = ↑((-1 : ℤˣ) ^ (i : ℕ) * (-1 : ℤˣ) ^ (i : ℕ) : ℤˣ) * det A := by simp\n      _ = (-1 : R) ^ (i : ℕ) * (Perm.sign i.cycleRange⁻¹) * det A := by simp [-Int.units_mul_self]\n  rw [this, mul_assoc]\n  congr\n  rw [← det_permute, det_succ_row_zero]\n  refine Finset.sum_congr rfl fun j _ => ?_\n  rw [mul_assoc, Matrix.submatrix_apply, submatrix_submatrix, id_comp, Function.comp_def, id]\n  congr\n  · rw [Equiv.Perm.inv_def, Fin.cycleRange_symm_zero]\n  · ext i' j'\n    rw [Equiv.Perm.inv_def, Matrix.submatrix_apply, Matrix.submatrix_apply,\n      Fin.cycleRange_symm_succ]\n\n"}
{"name":"Matrix.det_succ_column","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"R : Type v\ninst✝ : CommRing R\nn : Nat\nA : Matrix (Fin n.succ) (Fin n.succ) R\nj : Fin n.succ\n⊢ Eq A.det (Finset.univ.sum fun i => HMul.hMul (HMul.hMul (HPow.hPow (-1) (HAdd.hAdd ↑i ↑j)) (A i j)) (A.submatrix i.succAbove j.succAbove).det)","decl":"/-- Laplacian expansion of the determinant of an `n+1 × n+1` matrix along column `j`. -/\ntheorem det_succ_column {n : ℕ} (A : Matrix (Fin n.succ) (Fin n.succ) R) (j : Fin n.succ) :\n    det A =\n      ∑ i : Fin n.succ, (-1) ^ (i + j : ℕ) * A i j * det (A.submatrix i.succAbove j.succAbove) := by\n  rw [← det_transpose, det_succ_row _ j]\n  refine Finset.sum_congr rfl fun i _ => ?_\n  rw [add_comm, ← det_transpose, transpose_apply, transpose_submatrix, transpose_transpose]\n\n"}
{"name":"Matrix.det_fin_zero","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"R : Type v\ninst✝ : CommRing R\nA : Matrix (Fin 0) (Fin 0) R\n⊢ Eq A.det 1","decl":"/-- Determinant of 0x0 matrix -/\n@[simp]\ntheorem det_fin_zero {A : Matrix (Fin 0) (Fin 0) R} : det A = 1 :=\n  det_isEmpty\n\n"}
{"name":"Matrix.det_fin_one","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"R : Type v\ninst✝ : CommRing R\nA : Matrix (Fin 1) (Fin 1) R\n⊢ Eq A.det (A 0 0)","decl":"/-- Determinant of 1x1 matrix -/\ntheorem det_fin_one (A : Matrix (Fin 1) (Fin 1) R) : det A = A 0 0 :=\n  det_unique A\n\n"}
{"name":"Matrix.det_fin_one_of","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"R : Type v\ninst✝ : CommRing R\na : R\n⊢ Eq (Matrix.of (Matrix.vecCons (Matrix.vecCons a Matrix.vecEmpty) Matrix.vecEmpty)).det a","decl":"theorem det_fin_one_of (a : R) : det !![a] = a :=\n  det_fin_one _\n\n"}
{"name":"Matrix.det_fin_two","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"R : Type v\ninst✝ : CommRing R\nA : Matrix (Fin 2) (Fin 2) R\n⊢ Eq A.det (HSub.hSub (HMul.hMul (A 0 0) (A 1 1)) (HMul.hMul (A 0 1) (A 1 0)))","decl":"/-- Determinant of 2x2 matrix -/\ntheorem det_fin_two (A : Matrix (Fin 2) (Fin 2) R) : det A = A 0 0 * A 1 1 - A 0 1 * A 1 0 := by\n  simp only [det_succ_row_zero, det_unique, Fin.default_eq_zero, submatrix_apply,\n    Fin.succ_zero_eq_one, Fin.sum_univ_succ, Fin.val_zero, Fin.zero_succAbove, univ_unique,\n    Fin.val_succ, Fin.val_eq_zero, Fin.succ_succAbove_zero, sum_singleton]\n  ring\n\n"}
{"name":"Matrix.det_fin_two_of","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"R : Type v\ninst✝ : CommRing R\na b c d : R\n⊢ Eq (Matrix.of (Matrix.vecCons (Matrix.vecCons a (Matrix.vecCons b Matrix.vecEmpty)) (Matrix.vecCons (Matrix.vecCons c (Matrix.vecCons d Matrix.vecEmpty)) Matrix.vecEmpty))).det (HSub.hSub (HMul.hMul a d) (HMul.hMul b c))","decl":"@[simp]\ntheorem det_fin_two_of (a b c d : R) : Matrix.det !![a, b; c, d] = a * d - b * c :=\n  det_fin_two _\n\n"}
{"name":"Matrix.det_fin_three","module":"Mathlib.LinearAlgebra.Matrix.Determinant.Basic","initialProofState":"R : Type v\ninst✝ : CommRing R\nA : Matrix (Fin 3) (Fin 3) R\n⊢ Eq A.det (HSub.hSub (HAdd.hAdd (HAdd.hAdd (HSub.hSub (HSub.hSub (HMul.hMul (HMul.hMul (A 0 0) (A 1 1)) (A 2 2)) (HMul.hMul (HMul.hMul (A 0 0) (A 1 2)) (A 2 1))) (HMul.hMul (HMul.hMul (A 0 1) (A 1 0)) (A 2 2))) (HMul.hMul (HMul.hMul (A 0 1) (A 1 2)) (A 2 0))) (HMul.hMul (HMul.hMul (A 0 2) (A 1 0)) (A 2 1))) (HMul.hMul (HMul.hMul (A 0 2) (A 1 1)) (A 2 0)))","decl":"/-- Determinant of 3x3 matrix -/\ntheorem det_fin_three (A : Matrix (Fin 3) (Fin 3) R) :\n    det A =\n      A 0 0 * A 1 1 * A 2 2 - A 0 0 * A 1 2 * A 2 1\n      - A 0 1 * A 1 0 * A 2 2 + A 0 1 * A 1 2 * A 2 0\n      + A 0 2 * A 1 0 * A 2 1 - A 0 2 * A 1 1 * A 2 0 := by\n  simp only [det_succ_row_zero, submatrix_apply, Fin.succ_zero_eq_one, submatrix_submatrix,\n    det_unique, Fin.default_eq_zero, Function.comp_apply, Fin.succ_one_eq_two, Fin.sum_univ_succ,\n    Fin.val_zero, Fin.zero_succAbove, univ_unique, Fin.val_succ, Fin.val_eq_zero,\n    Fin.succ_succAbove_zero, sum_singleton, Fin.succ_succAbove_one]\n  ring\n\n"}
