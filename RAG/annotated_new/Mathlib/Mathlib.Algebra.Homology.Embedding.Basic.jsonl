{"name":"ComplexShape.Embedding.rel","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nself : c.Embedding c'\ni₁ i₂ : ι\nh : c.Rel i₁ i₂\n⊢ c'.Rel (self.f i₁) (self.f i₂)","decl":"/-- An embedding of a complex shape `c : ComplexShape ι` into a complex shape\n`c' : ComplexShape ι'` consists of a injective map `f : ι → ι'` which satisfies\na compatibility with respect to the relations `c.Rel` and `c'.Rel`. -/\nstructure Embedding where\n  /-- the map between the underlying types of indices -/\n  f : ι → ι'\n  injective_f : Function.Injective f\n  rel {i₁ i₂ : ι} (h : c.Rel i₁ i₂) : c'.Rel (f i₁) (f i₂)\n\n"}
{"name":"ComplexShape.Embedding.mk.injEq","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nf✝ : ι → ι'\ninjective_f✝ : Function.Injective f✝\nrel✝ : ∀ {i₁ i₂ : ι}, c.Rel i₁ i₂ → c'.Rel (f✝ i₁) (f✝ i₂)\nf : ι → ι'\ninjective_f : Function.Injective f\nrel : ∀ {i₁ i₂ : ι}, c.Rel i₁ i₂ → c'.Rel (f i₁) (f i₂)\n⊢ Eq (Eq { f := f✝, injective_f := injective_f✝, rel := rel✝ } { f := f, injective_f := injective_f, rel := rel }) (Eq f✝ f)","decl":"/-- An embedding of a complex shape `c : ComplexShape ι` into a complex shape\n`c' : ComplexShape ι'` consists of a injective map `f : ι → ι'` which satisfies\na compatibility with respect to the relations `c.Rel` and `c'.Rel`. -/\nstructure Embedding where\n  /-- the map between the underlying types of indices -/\n  f : ι → ι'\n  injective_f : Function.Injective f\n  rel {i₁ i₂ : ι} (h : c.Rel i₁ i₂) : c'.Rel (f i₁) (f i₂)\n\n"}
{"name":"ComplexShape.Embedding.mk.inj","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nf✝ : ι → ι'\ninjective_f✝ : Function.Injective f✝\nrel✝ : ∀ {i₁ i₂ : ι}, c.Rel i₁ i₂ → c'.Rel (f✝ i₁) (f✝ i₂)\nf : ι → ι'\ninjective_f : Function.Injective f\nrel : ∀ {i₁ i₂ : ι}, c.Rel i₁ i₂ → c'.Rel (f i₁) (f i₂)\nx✝ : Eq { f := f✝, injective_f := injective_f✝, rel := rel✝ } { f := f, injective_f := injective_f, rel := rel }\n⊢ Eq f✝ f","decl":"/-- An embedding of a complex shape `c : ComplexShape ι` into a complex shape\n`c' : ComplexShape ι'` consists of a injective map `f : ι → ι'` which satisfies\na compatibility with respect to the relations `c.Rel` and `c'.Rel`. -/\nstructure Embedding where\n  /-- the map between the underlying types of indices -/\n  f : ι → ι'\n  injective_f : Function.Injective f\n  rel {i₁ i₂ : ι} (h : c.Rel i₁ i₂) : c'.Rel (f i₁) (f i₂)\n\n"}
{"name":"ComplexShape.Embedding.mk.sizeOf_spec","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ninst✝¹ : SizeOf ι\ninst✝ : SizeOf ι'\nf : ι → ι'\ninjective_f : Function.Injective f\nrel : ∀ {i₁ i₂ : ι}, c.Rel i₁ i₂ → c'.Rel (f i₁) (f i₂)\n⊢ Eq (SizeOf.sizeOf { f := f, injective_f := injective_f, rel := rel }) 1","decl":"/-- An embedding of a complex shape `c : ComplexShape ι` into a complex shape\n`c' : ComplexShape ι'` consists of a injective map `f : ι → ι'` which satisfies\na compatibility with respect to the relations `c.Rel` and `c'.Rel`. -/\nstructure Embedding where\n  /-- the map between the underlying types of indices -/\n  f : ι → ι'\n  injective_f : Function.Injective f\n  rel {i₁ i₂ : ι} (h : c.Rel i₁ i₂) : c'.Rel (f i₁) (f i₂)\n\n"}
{"name":"ComplexShape.Embedding.injective_f","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nself : c.Embedding c'\n⊢ Function.Injective self.f","decl":"/-- An embedding of a complex shape `c : ComplexShape ι` into a complex shape\n`c' : ComplexShape ι'` consists of a injective map `f : ι → ι'` which satisfies\na compatibility with respect to the relations `c.Rel` and `c'.Rel`. -/\nstructure Embedding where\n  /-- the map between the underlying types of indices -/\n  f : ι → ι'\n  injective_f : Function.Injective f\n  rel {i₁ i₂ : ι} (h : c.Rel i₁ i₂) : c'.Rel (f i₁) (f i₂)\n\n"}
{"name":"ComplexShape.Embedding.op_f","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\na✝ : ι\n⊢ Eq (e.op.f a✝) (e.f a✝)","decl":"/-- The opposite embedding in `Embedding c.symm c'.symm` of `e : Embedding c c'`. -/\n@[simps]\ndef op : Embedding c.symm c'.symm where\n  f := e.f\n  injective_f := e.injective_f\n  rel h := e.rel h\n\n"}
{"name":"ComplexShape.Embedding.IsRelIff.rel'","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\nself : e.IsRelIff\ni₁ i₂ : ι\nh : c'.Rel (e.f i₁) (e.f i₂)\n⊢ c.Rel i₁ i₂","decl":"/-- An embedding of complex shapes `e` satisfies `e.IsRelIff` if the implication\n`e.rel` is an equivalence. -/\nclass IsRelIff : Prop where\n  rel' (i₁ i₂ : ι) (h : c'.Rel (e.f i₁) (e.f i₂)) : c.Rel i₁ i₂\n\n"}
{"name":"ComplexShape.Embedding.rel_iff","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\ninst✝ : e.IsRelIff\ni₁ i₂ : ι\n⊢ Iff (c'.Rel (e.f i₁) (e.f i₂)) (c.Rel i₁ i₂)","decl":"lemma rel_iff [e.IsRelIff] (i₁ i₂ : ι) : c'.Rel (e.f i₁) (e.f i₂) ↔ c.Rel i₁ i₂ := by\n  constructor\n  · apply IsRelIff.rel'\n  · exact e.rel\n\n"}
{"name":"ComplexShape.Embedding.instIsRelIffOp","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\ninst✝ : e.IsRelIff\n⊢ e.op.IsRelIff","decl":"instance [e.IsRelIff] : e.op.IsRelIff where\n  rel' i₁ i₂ h := (e.rel_iff i₂ i₁).1 h\n\n"}
{"name":"ComplexShape.Embedding.mk'_f","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nf : ι → ι'\nhf : Function.Injective f\niff : ∀ (i₁ i₂ : ι), Iff (c.Rel i₁ i₂) (c'.Rel (f i₁) (f i₂))\na✝ : ι\n⊢ Eq ((ComplexShape.Embedding.mk' c c' f hf iff).f a✝) (f a✝)","decl":"/-- Constructor for embeddings between complex shapes when we have an equivalence\n`∀ (i₁ i₂ : ι), c.Rel i₁ i₂ ↔ c'.Rel (f i₁) (f i₂)`. -/\n@[simps]\ndef mk' : Embedding c c' where\n  f := f\n  injective_f := hf\n  rel h := (iff _ _).1 h\n\n"}
{"name":"ComplexShape.Embedding.instIsRelIffMk'","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nf : ι → ι'\nhf : Function.Injective f\niff : ∀ (i₁ i₂ : ι), Iff (c.Rel i₁ i₂) (c'.Rel (f i₁) (f i₂))\n⊢ (ComplexShape.Embedding.mk' c c' f hf iff).IsRelIff","decl":"instance : (mk' c c' f hf iff).IsRelIff where\n  rel' _ _ h := (iff _ _).2 h\n\n"}
{"name":"ComplexShape.Embedding.IsTruncGE.toIsRelIff","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\nself : e.IsTruncGE\n⊢ e.IsRelIff","decl":"/-- The condition that the image of the map `e.f` of an embedding of\ncomplex shapes `e : Embedding c c'` is stable by `c'.next`. -/\nclass IsTruncGE extends e.IsRelIff : Prop where\n  mem_next {j : ι} {k' : ι'} (h : c'.Rel (e.f j) k') :\n    ∃ k, e.f k = k'\n\n"}
{"name":"ComplexShape.Embedding.IsTruncGE.mem_next","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\nself : e.IsTruncGE\nj : ι\nk' : ι'\nh : c'.Rel (e.f j) k'\n⊢ Exists fun k => Eq (e.f k) k'","decl":"/-- The condition that the image of the map `e.f` of an embedding of\ncomplex shapes `e : Embedding c c'` is stable by `c'.next`. -/\nclass IsTruncGE extends e.IsRelIff : Prop where\n  mem_next {j : ι} {k' : ι'} (h : c'.Rel (e.f j) k') :\n    ∃ k, e.f k = k'\n\n"}
{"name":"ComplexShape.Embedding.mem_next","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\ninst✝ : e.IsTruncGE\nj : ι\nk' : ι'\nh : c'.Rel (e.f j) k'\n⊢ Exists fun k => Eq (e.f k) k'","decl":"lemma mem_next [e.IsTruncGE] {j : ι} {k' : ι'} (h : c'.Rel (e.f j) k') : ∃ k, e.f k = k' :=\n  IsTruncGE.mem_next h\n\n"}
{"name":"ComplexShape.Embedding.IsTruncLE.toIsRelIff","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\nself : e.IsTruncLE\n⊢ e.IsRelIff","decl":"/-- The condition that the image of the map `e.f` of an embedding of\ncomplex shapes `e : Embedding c c'` is stable by `c'.prev`. -/\nclass IsTruncLE extends e.IsRelIff : Prop where\n  mem_prev {i' : ι'} {j : ι} (h : c'.Rel i' (e.f j)) :\n    ∃ i, e.f i = i'\n\n"}
{"name":"ComplexShape.Embedding.IsTruncLE.mem_prev","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\nself : e.IsTruncLE\ni' : ι'\nj : ι\nh : c'.Rel i' (e.f j)\n⊢ Exists fun i => Eq (e.f i) i'","decl":"/-- The condition that the image of the map `e.f` of an embedding of\ncomplex shapes `e : Embedding c c'` is stable by `c'.prev`. -/\nclass IsTruncLE extends e.IsRelIff : Prop where\n  mem_prev {i' : ι'} {j : ι} (h : c'.Rel i' (e.f j)) :\n    ∃ i, e.f i = i'\n\n"}
{"name":"ComplexShape.Embedding.mem_prev","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\ninst✝ : e.IsTruncLE\ni' : ι'\nj : ι\nh : c'.Rel i' (e.f j)\n⊢ Exists fun i => Eq (e.f i) i'","decl":"lemma mem_prev [e.IsTruncLE] {i' : ι'} {j : ι} (h : c'.Rel i' (e.f j)) : ∃ i, e.f i = i' :=\n  IsTruncLE.mem_prev h\n\n"}
{"name":"ComplexShape.Embedding.instIsTruncLEOpOfIsTruncGE","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\ninst✝ : e.IsTruncGE\n⊢ e.op.IsTruncLE","decl":"instance [e.IsTruncGE] : e.op.IsTruncLE where\n  mem_prev h := e.mem_next h\n\n"}
{"name":"ComplexShape.Embedding.instIsTruncGEOpOfIsTruncLE","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\ninst✝ : e.IsTruncLE\n⊢ e.op.IsTruncGE","decl":"instance [e.IsTruncLE] : e.op.IsTruncGE where\n  mem_next h := e.mem_prev h\n\n"}
{"name":"ComplexShape.Embedding.r_eq_some","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\ni : ι\ni' : ι'\nhi : Eq (e.f i) i'\n⊢ Eq (e.r i') (Option.some i)","decl":"lemma r_eq_some {i : ι} {i' : ι'} (hi : e.f i = i') :\n    e.r i' = some i := by\n  have h : ∃ (i : ι), e.f i = i' := ⟨i, hi⟩\n  have : h.choose = i := e.injective_f (h.choose_spec.trans (hi.symm))\n  dsimp [r]\n  rw [dif_pos ⟨i, hi⟩, this]\n\n"}
{"name":"ComplexShape.Embedding.r_eq_none","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\ni' : ι'\nhi : ∀ (i : ι), Ne (e.f i) i'\n⊢ Eq (e.r i') Option.none","decl":"lemma r_eq_none (i' : ι') (hi : ∀ i, e.f i ≠ i') :\n    e.r i' = none :=\n  dif_neg (by\n    rintro ⟨i, hi'⟩\n    exact hi i hi')\n\n"}
{"name":"ComplexShape.Embedding.r_f","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\ni : ι\n⊢ Eq (e.r (e.f i)) (Option.some i)","decl":"@[simp] lemma r_f (i : ι) : e.r (e.f i) = some i := r_eq_some _ rfl\n\n"}
{"name":"ComplexShape.Embedding.f_eq_of_r_eq_some","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\ni : ι\ni' : ι'\nhi : Eq (e.r i') (Option.some i)\n⊢ Eq (e.f i) i'","decl":"lemma f_eq_of_r_eq_some {i : ι} {i' : ι'} (hi : e.r i' = some i) :\n    e.f i = i' := by\n  by_cases h : ∃ (k : ι), e.f k = i'\n  · obtain ⟨k, rfl⟩ := h\n    rw [r_f] at hi\n    congr 1\n    simpa using hi.symm\n  · simp [e.r_eq_none i' (by simpa using h)] at hi\n\n"}
{"name":"ComplexShape.embeddingUpNat_f","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"n : Nat\n⊢ Eq (ComplexShape.embeddingUpNat.f n) ↑n","decl":"/-- The obvious embedding from `up ℕ` to `up ℤ`. -/\n@[simps!]\ndef embeddingUpNat : Embedding (up ℕ) (up ℤ) :=\n  Embedding.mk' _ _ (fun n => n)\n    (fun _ _ h => by simpa using h)\n    (by dsimp; omega)\n\n"}
{"name":"ComplexShape.instIsRelIffNatIntEmbeddingUpNat","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"⊢ ComplexShape.embeddingUpNat.IsRelIff","decl":"instance : embeddingUpNat.IsRelIff := by dsimp [embeddingUpNat]; infer_instance\n\n"}
{"name":"ComplexShape.instIsTruncGENatIntEmbeddingUpNat","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"⊢ ComplexShape.embeddingUpNat.IsTruncGE","decl":"instance : embeddingUpNat.IsTruncGE where\n  mem_next {j _} h := ⟨j + 1, h⟩\n\n"}
{"name":"ComplexShape.embeddingDownNat_f","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"n : Nat\n⊢ Eq (ComplexShape.embeddingDownNat.f n) (Neg.neg ↑n)","decl":"/-- The embedding from `down ℕ` to `up ℤ` with sends `n` to `-n`. -/\n@[simps!]\ndef embeddingDownNat : Embedding (down ℕ) (up ℤ) :=\n  Embedding.mk' _ _ (fun n => -n)\n    (fun _ _ h => by simpa using h)\n    (by dsimp; omega)\n\n"}
{"name":"ComplexShape.instIsRelIffNatIntEmbeddingDownNat","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"⊢ ComplexShape.embeddingDownNat.IsRelIff","decl":"instance : embeddingDownNat.IsRelIff := by dsimp [embeddingDownNat]; infer_instance\n\n"}
{"name":"ComplexShape.instIsTruncLENatIntEmbeddingDownNat","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"⊢ ComplexShape.embeddingDownNat.IsTruncLE","decl":"instance : embeddingDownNat.IsTruncLE where\n  mem_prev {i j} h := ⟨j + 1, by dsimp at h ⊢; omega⟩\n\n"}
{"name":"ComplexShape.embeddingUpIntGE_f","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"p : Int\nn : Nat\n⊢ Eq ((ComplexShape.embeddingUpIntGE p).f n) (HAdd.hAdd p ↑n)","decl":"/-- The embedding from `up ℕ` to `up ℤ` which sends `n : ℕ` to `p + n`. -/\n@[simps!]\ndef embeddingUpIntGE : Embedding (up ℕ) (up ℤ) :=\n  Embedding.mk' _ _ (fun n => p + n)\n    (fun _ _ h => by dsimp at h; omega)\n    (by dsimp; omega)\n\n"}
{"name":"ComplexShape.instIsRelIffNatIntEmbeddingUpIntGE","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"p : Int\n⊢ (ComplexShape.embeddingUpIntGE p).IsRelIff","decl":"instance : (embeddingUpIntGE p).IsRelIff := by dsimp [embeddingUpIntGE]; infer_instance\n\n"}
{"name":"ComplexShape.instIsTruncGENatIntEmbeddingUpIntGE","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"p : Int\n⊢ (ComplexShape.embeddingUpIntGE p).IsTruncGE","decl":"instance : (embeddingUpIntGE p).IsTruncGE where\n  mem_next {j _} h := ⟨j + 1, by dsimp at h ⊢; omega⟩\n\n"}
{"name":"ComplexShape.embeddingUpIntLE_f","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"p : Int\nn : Nat\n⊢ Eq ((ComplexShape.embeddingUpIntLE p).f n) (HSub.hSub p ↑n)","decl":"/-- The embedding from `down ℕ` to `up ℤ` which sends `n : ℕ` to `p - n`. -/\n@[simps!]\ndef embeddingUpIntLE : Embedding (down ℕ) (up ℤ) :=\n  Embedding.mk' _ _ (fun n => p - n)\n    (fun _ _ h => by dsimp at h; omega)\n    (by dsimp; omega)\n\n"}
{"name":"ComplexShape.instIsRelIffNatIntEmbeddingUpIntLE","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"p : Int\n⊢ (ComplexShape.embeddingUpIntLE p).IsRelIff","decl":"instance : (embeddingUpIntLE p).IsRelIff := by dsimp [embeddingUpIntLE]; infer_instance\n\n"}
{"name":"ComplexShape.instIsTruncLENatIntEmbeddingUpIntLE","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"p : Int\n⊢ (ComplexShape.embeddingUpIntLE p).IsTruncLE","decl":"instance : (embeddingUpIntLE p).IsTruncLE where\n  mem_prev {_ k} h := ⟨k + 1, by dsimp at h ⊢; omega⟩\n\n"}
{"name":"ComplexShape.not_mem_range_embeddingUpIntLE_iff","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"p n : Int\n⊢ Iff (∀ (i : Nat), Ne ((ComplexShape.embeddingUpIntLE p).f i) n) (LT.lt p n)","decl":"lemma not_mem_range_embeddingUpIntLE_iff (n : ℤ) :\n    (∀ (i : ℕ), (embeddingUpIntLE p).f i ≠ n) ↔ p < n := by\n  constructor\n  · intro h\n    by_contra!\n    simp only [Int.not_lt] at this\n    obtain ⟨k, rfl⟩ := Int.le.dest this\n    exact (h k) (by simp)\n  · intros\n    dsimp\n    omega\n\n"}
{"name":"ComplexShape.not_mem_range_embeddingUpIntGE_iff","module":"Mathlib.Algebra.Homology.Embedding.Basic","initialProofState":"p n : Int\n⊢ Iff (∀ (i : Nat), Ne ((ComplexShape.embeddingUpIntGE p).f i) n) (LT.lt n p)","decl":"lemma not_mem_range_embeddingUpIntGE_iff (n : ℤ) :\n    (∀ (i : ℕ), (embeddingUpIntGE p).f i ≠ n) ↔ n < p := by\n  constructor\n  · intro h\n    by_contra!\n    simp only [Int.not_lt] at this\n    obtain ⟨k, rfl⟩ := Int.le.dest this\n    exact (h k) (by simp)\n  · intros\n    dsimp\n    omega\n\n"}
