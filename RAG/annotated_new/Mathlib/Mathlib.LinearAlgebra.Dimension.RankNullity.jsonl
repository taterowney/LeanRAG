{"name":"HasRankNullity.exists_set_linearIndependent","module":"Mathlib.LinearAlgebra.Dimension.RankNullity","initialProofState":"R : Type v\ninst : Ring R\nself : HasRankNullity.{u, v} R\nM : Type u\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Exists fun s => And (Eq (Cardinal.mk ↑s) (Module.rank R M)) (LinearIndependent R Subtype.val)","decl":"/--\n`HasRankNullity.{u}` is a class of rings satisfying\n1. Every `R`-module `M : Type u` has a linear independent subset of cardinality `Module.rank R M`.\n2. `rank (M ⧸ N) + rank N = rank M` for every `R`-module `M : Type u` and every `N : Submodule R M`.\n\nUsually such a ring satisfies `HasRankNullity.{w}` for all universes `w`, and the universe\nargument is there because of technical limitations to universe polymorphism.\n\nSee `DivisionRing.hasRankNullity` and `IsDomain.hasRankNullity`.\n-/\n@[pp_with_univ]\nclass HasRankNullity (R : Type v) [inst : Ring R] : Prop where\n  exists_set_linearIndependent : ∀ (M : Type u) [AddCommGroup M] [Module R M],\n    ∃ s : Set M, #s = Module.rank R M ∧ LinearIndependent (ι := s) R Subtype.val\n  rank_quotient_add_rank : ∀ {M : Type u} [AddCommGroup M] [Module R M] (N : Submodule R M),\n    Module.rank R (M ⧸ N) + Module.rank R N = Module.rank R M\n\n"}
{"name":"HasRankNullity.rank_quotient_add_rank","module":"Mathlib.LinearAlgebra.Dimension.RankNullity","initialProofState":"R : Type v\ninst : Ring R\nself : HasRankNullity.{u, v} R\nM : Type u\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nN : Submodule R M\n⊢ Eq (HAdd.hAdd (Module.rank R (HasQuotient.Quotient M N)) (Module.rank R (Subtype fun x => Membership.mem N x))) (Module.rank R M)","decl":"/--\n`HasRankNullity.{u}` is a class of rings satisfying\n1. Every `R`-module `M : Type u` has a linear independent subset of cardinality `Module.rank R M`.\n2. `rank (M ⧸ N) + rank N = rank M` for every `R`-module `M : Type u` and every `N : Submodule R M`.\n\nUsually such a ring satisfies `HasRankNullity.{w}` for all universes `w`, and the universe\nargument is there because of technical limitations to universe polymorphism.\n\nSee `DivisionRing.hasRankNullity` and `IsDomain.hasRankNullity`.\n-/\n@[pp_with_univ]\nclass HasRankNullity (R : Type v) [inst : Ring R] : Prop where\n  exists_set_linearIndependent : ∀ (M : Type u) [AddCommGroup M] [Module R M],\n    ∃ s : Set M, #s = Module.rank R M ∧ LinearIndependent (ι := s) R Subtype.val\n  rank_quotient_add_rank : ∀ {M : Type u} [AddCommGroup M] [Module R M] (N : Submodule R M),\n    Module.rank R (M ⧸ N) + Module.rank R N = Module.rank R M\n\n"}
{"name":"Submodule.rank_quotient_add_rank","module":"Mathlib.LinearAlgebra.Dimension.RankNullity","initialProofState":"R : Type u_1\nM : Type u\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : HasRankNullity.{u, u_1} R\nN : Submodule R M\n⊢ Eq (HAdd.hAdd (Module.rank R (HasQuotient.Quotient M N)) (Module.rank R (Subtype fun x => Membership.mem N x))) (Module.rank R M)","decl":"lemma Submodule.rank_quotient_add_rank (N : Submodule R M) :\n    Module.rank R (M ⧸ N) + Module.rank R N = Module.rank R M :=\n  HasRankNullity.rank_quotient_add_rank N\n\n"}
{"name":"exists_set_linearIndependent","module":"Mathlib.LinearAlgebra.Dimension.RankNullity","initialProofState":"R : Type u_1\nM : Type u\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : HasRankNullity.{u, u_1} R\n⊢ Exists fun s => And (Eq (Cardinal.mk ↑s) (Module.rank R M)) (LinearIndependent R Subtype.val)","decl":"variable (R M) in\nlemma exists_set_linearIndependent :\n    ∃ s : Set M, #s = Module.rank R M ∧ LinearIndependent (ι := s) R Subtype.val :=\n  HasRankNullity.exists_set_linearIndependent M\n\n"}
{"name":"nontrivial_of_hasRankNullity","module":"Mathlib.LinearAlgebra.Dimension.RankNullity","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : HasRankNullity.{u, u_1} R\n⊢ Nontrivial R","decl":"variable (R) in\ntheorem nontrivial_of_hasRankNullity : Nontrivial R := by\n  refine (subsingleton_or_nontrivial R).resolve_left fun H ↦ ?_\n  have := rank_quotient_add_rank (R := R) (M := PUnit) ⊥\n  simp [one_add_one_eq_two] at this\n\n"}
{"name":"LinearMap.lift_rank_range_add_rank_ker","module":"Mathlib.LinearAlgebra.Dimension.RankNullity","initialProofState":"R : Type u_1\nM : Type u\nM' : Type v\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\ninst✝ : HasRankNullity.{u, u_1} R\nf : LinearMap (RingHom.id R) M M'\n⊢ Eq (HAdd.hAdd (Cardinal.lift.{u, v} (Module.rank R (Subtype fun x => Membership.mem (LinearMap.range f) x))) (Cardinal.lift.{v, u} (Module.rank R (Subtype fun x => Membership.mem (LinearMap.ker f) x)))) (Cardinal.lift.{v, u} (Module.rank R M))","decl":"theorem LinearMap.lift_rank_range_add_rank_ker (f : M →ₗ[R] M') :\n    lift.{u} (Module.rank R (LinearMap.range f)) + lift.{v} (Module.rank R (LinearMap.ker f)) =\n      lift.{v} (Module.rank R M) := by\n  haveI := fun p : Submodule R M => Classical.decEq (M ⧸ p)\n  rw [← f.quotKerEquivRange.lift_rank_eq, ← lift_add, rank_quotient_add_rank]\n\n"}
{"name":"LinearMap.rank_range_add_rank_ker","module":"Mathlib.LinearAlgebra.Dimension.RankNullity","initialProofState":"R : Type u_1\nM M₁ : Type u\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup M₁\ninst✝² : Module R M\ninst✝¹ : Module R M₁\ninst✝ : HasRankNullity.{u, u_1} R\nf : LinearMap (RingHom.id R) M M₁\n⊢ Eq (HAdd.hAdd (Module.rank R (Subtype fun x => Membership.mem (LinearMap.range f) x)) (Module.rank R (Subtype fun x => Membership.mem (LinearMap.ker f) x))) (Module.rank R M)","decl":"/-- The **rank-nullity theorem** -/\ntheorem LinearMap.rank_range_add_rank_ker (f : M →ₗ[R] M₁) :\n    Module.rank R (LinearMap.range f) + Module.rank R (LinearMap.ker f) = Module.rank R M := by\n  haveI := fun p : Submodule R M => Classical.decEq (M ⧸ p)\n  rw [← f.quotKerEquivRange.rank_eq, rank_quotient_add_rank]\n\n"}
{"name":"LinearMap.lift_rank_eq_of_surjective","module":"Mathlib.LinearAlgebra.Dimension.RankNullity","initialProofState":"R : Type u_1\nM : Type u\nM' : Type v\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\ninst✝ : HasRankNullity.{u, u_1} R\nf : LinearMap (RingHom.id R) M M'\nh : Function.Surjective ⇑f\n⊢ Eq (Cardinal.lift.{v, u} (Module.rank R M)) (HAdd.hAdd (Cardinal.lift.{u, v} (Module.rank R M')) (Cardinal.lift.{v, u} (Module.rank R (Subtype fun x => Membership.mem (LinearMap.ker f) x))))","decl":"theorem LinearMap.lift_rank_eq_of_surjective {f : M →ₗ[R] M'} (h : Surjective f) :\n    lift.{v} (Module.rank R M) =\n      lift.{u} (Module.rank R M') + lift.{v} (Module.rank R (LinearMap.ker f)) := by\n  rw [← lift_rank_range_add_rank_ker f, ← rank_range_of_surjective f h]\n\n"}
{"name":"LinearMap.rank_eq_of_surjective","module":"Mathlib.LinearAlgebra.Dimension.RankNullity","initialProofState":"R : Type u_1\nM M₁ : Type u\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup M₁\ninst✝² : Module R M\ninst✝¹ : Module R M₁\ninst✝ : HasRankNullity.{u, u_1} R\nf : LinearMap (RingHom.id R) M M₁\nh : Function.Surjective ⇑f\n⊢ Eq (Module.rank R M) (HAdd.hAdd (Module.rank R M₁) (Module.rank R (Subtype fun x => Membership.mem (LinearMap.ker f) x)))","decl":"theorem LinearMap.rank_eq_of_surjective {f : M →ₗ[R] M₁} (h : Surjective f) :\n    Module.rank R M = Module.rank R M₁ + Module.rank R (LinearMap.ker f) := by\n  rw [← rank_range_add_rank_ker f, ← rank_range_of_surjective f h]\n\n"}
{"name":"exists_linearIndependent_of_lt_rank","module":"Mathlib.LinearAlgebra.Dimension.RankNullity","initialProofState":"R : Type u_1\nM : Type u\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : HasRankNullity.{u, u_1} R\ninst✝ : StrongRankCondition R\ns : Set M\nhs : LinearIndependent R Subtype.val\n⊢ Exists fun t => And (HasSubset.Subset s t) (And (Eq (Cardinal.mk ↑t) (Module.rank R M)) (LinearIndependent R Subtype.val))","decl":"theorem exists_linearIndependent_of_lt_rank [StrongRankCondition R]\n    {s : Set M} (hs : LinearIndependent (ι := s) R Subtype.val) :\n    ∃ t, s ⊆ t ∧ #t = Module.rank R M ∧ LinearIndependent (ι := t) R Subtype.val := by\n  obtain ⟨t, ht, ht'⟩ := exists_set_linearIndependent R (M ⧸ Submodule.span R s)\n  choose sec hsec using Submodule.Quotient.mk_surjective (Submodule.span R s)\n  have hsec' : Submodule.Quotient.mk ∘ sec = _root_.id := funext hsec\n  have hst : Disjoint s (sec '' t) := by\n    rw [Set.disjoint_iff]\n    rintro _ ⟨hxs, ⟨x, hxt, rfl⟩⟩\n    apply ht'.ne_zero ⟨x, hxt⟩\n    rw [Subtype.coe_mk, ← hsec x, Submodule.Quotient.mk_eq_zero]\n    exact Submodule.subset_span hxs\n  refine ⟨s ∪ sec '' t, subset_union_left, ?_, ?_⟩\n  · rw [Cardinal.mk_union_of_disjoint hst, Cardinal.mk_image_eq, ht,\n      ← rank_quotient_add_rank (Submodule.span R s), add_comm, rank_span_set hs]\n    exact HasLeftInverse.injective ⟨Submodule.Quotient.mk, hsec⟩\n  · apply LinearIndependent.union_of_quotient Submodule.subset_span hs\n    rwa [Function.comp_def, linearIndependent_image (hsec'.symm ▸ injective_id).injOn.image_of_comp,\n      ← image_comp, hsec', image_id]\n\n"}
{"name":"exists_linearIndependent_cons_of_lt_rank","module":"Mathlib.LinearAlgebra.Dimension.RankNullity","initialProofState":"R : Type u_1\nM : Type u\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : HasRankNullity.{u, u_1} R\ninst✝ : StrongRankCondition R\nn : Nat\nv : Fin n → M\nhv : LinearIndependent R v\nh : LT.lt (↑n) (Module.rank R M)\n⊢ Exists fun x => LinearIndependent R (Fin.cons x v)","decl":"/-- Given a family of `n` linearly independent vectors in a space of dimension `> n`, one may extend\nthe family by another vector while retaining linear independence. -/\ntheorem exists_linearIndependent_cons_of_lt_rank [StrongRankCondition R] {n : ℕ} {v : Fin n → M}\n    (hv : LinearIndependent R v) (h : n < Module.rank R M) :\n    ∃ (x : M), LinearIndependent R (Fin.cons x v) := by\n  obtain ⟨t, h₁, h₂, h₃⟩ := exists_linearIndependent_of_lt_rank hv.to_subtype_range\n  have : range v ≠ t := by\n    refine fun e ↦ h.ne ?_\n    rw [← e, ← lift_injective.eq_iff, mk_range_eq_of_injective hv.injective] at h₂\n    simpa only [mk_fintype, Fintype.card_fin, lift_natCast, lift_id'] using h₂\n  obtain ⟨x, hx, hx'⟩ := nonempty_of_ssubset (h₁.ssubset_of_ne this)\n  exact ⟨x, (linearIndependent_subtype_range (Fin.cons_injective_iff.mpr ⟨hx', hv.injective⟩)).mp\n    (h₃.mono (Fin.range_cons x v ▸ insert_subset hx h₁))⟩\n\n"}
{"name":"exists_linearIndependent_snoc_of_lt_rank","module":"Mathlib.LinearAlgebra.Dimension.RankNullity","initialProofState":"R : Type u_1\nM : Type u\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : HasRankNullity.{u, u_1} R\ninst✝ : StrongRankCondition R\nn : Nat\nv : Fin n → M\nhv : LinearIndependent R v\nh : LT.lt (↑n) (Module.rank R M)\n⊢ Exists fun x => LinearIndependent R (Fin.snoc v x)","decl":"/-- Given a family of `n` linearly independent vectors in a space of dimension `> n`, one may extend\nthe family by another vector while retaining linear independence. -/\ntheorem exists_linearIndependent_snoc_of_lt_rank [StrongRankCondition R] {n : ℕ} {v : Fin n → M}\n    (hv : LinearIndependent R v) (h : n < Module.rank R M) :\n    ∃ (x : M), LinearIndependent R (Fin.snoc v x) := by\n  simp only [Fin.snoc_eq_cons_rotate]\n  have ⟨x, hx⟩ := exists_linearIndependent_cons_of_lt_rank hv h\n  exact ⟨x, hx.comp _ (finRotate _).injective⟩\n\n"}
{"name":"exists_linearIndependent_pair_of_one_lt_rank","module":"Mathlib.LinearAlgebra.Dimension.RankNullity","initialProofState":"R : Type u_1\nM : Type u\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : HasRankNullity.{u, u_1} R\ninst✝¹ : StrongRankCondition R\ninst✝ : NoZeroSMulDivisors R M\nh : LT.lt 1 (Module.rank R M)\nx : M\nhx : Ne x 0\n⊢ Exists fun y => LinearIndependent R (Matrix.vecCons x (Matrix.vecCons y Matrix.vecEmpty))","decl":"/-- Given a nonzero vector in a space of dimension `> 1`, one may find another vector linearly\nindependent of the first one. -/\ntheorem exists_linearIndependent_pair_of_one_lt_rank [StrongRankCondition R]\n    [NoZeroSMulDivisors R M] (h : 1 < Module.rank R M) {x : M} (hx : x ≠ 0) :\n    ∃ y, LinearIndependent R ![x, y] := by\n  obtain ⟨y, hy⟩ := exists_linearIndependent_snoc_of_lt_rank (linearIndependent_unique ![x] hx) h\n  have : Fin.snoc ![x] y = ![x, y] := by simp [Fin.snoc, ← List.ofFn_inj]\n  rw [this] at hy\n  exact ⟨y, hy⟩\n\n"}
{"name":"Submodule.exists_smul_not_mem_of_rank_lt","module":"Mathlib.LinearAlgebra.Dimension.RankNullity","initialProofState":"R : Type u_1\nM : Type u\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : HasRankNullity.{u, u_1} R\nN : Submodule R M\nh : LT.lt (Module.rank R (Subtype fun x => Membership.mem N x)) (Module.rank R M)\n⊢ Exists fun m => ∀ (r : R), Ne r 0 → Not (Membership.mem N (HSMul.hSMul r m))","decl":"theorem Submodule.exists_smul_not_mem_of_rank_lt {N : Submodule R M}\n    (h : Module.rank R N < Module.rank R M) : ∃ m : M, ∀ r : R, r ≠ 0 → r • m ∉ N := by\n  have : Module.rank R (M ⧸ N) ≠ 0 := by\n    intro e\n    rw [← rank_quotient_add_rank N, e, zero_add] at h\n    exact h.ne rfl\n  rw [ne_eq, rank_eq_zero_iff, (Submodule.Quotient.mk_surjective N).forall] at this\n  push_neg at this\n  simp_rw [← N.mkQ_apply, ← map_smul, N.mkQ_apply, ne_eq, Submodule.Quotient.mk_eq_zero] at this\n  exact this\n\n"}
{"name":"Submodule.rank_sup_add_rank_inf_eq","module":"Mathlib.LinearAlgebra.Dimension.RankNullity","initialProofState":"R : Type u_1\nM : Type u\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : HasRankNullity.{u, u_1} R\ns t : Submodule R M\n⊢ Eq (HAdd.hAdd (Module.rank R (Subtype fun x => Membership.mem (Max.max s t) x)) (Module.rank R (Subtype fun x => Membership.mem (Min.min s t) x))) (HAdd.hAdd (Module.rank R (Subtype fun x => Membership.mem s x)) (Module.rank R (Subtype fun x => Membership.mem t x)))","decl":"theorem Submodule.rank_sup_add_rank_inf_eq (s t : Submodule R M) :\n    Module.rank R (s ⊔ t : Submodule R M) + Module.rank R (s ⊓ t : Submodule R M) =\n    Module.rank R s + Module.rank R t := by\n  conv_rhs => enter [2]; rw [show t = (s ⊔ t) ⊓ t by simp]\n  rw [← rank_quotient_add_rank ((s ⊓ t).comap s.subtype),\n    ← rank_quotient_add_rank (t.comap (s ⊔ t).subtype),\n    (quotientInfEquivSupQuotient s t).rank_eq,\n    (equivSubtypeMap s (comap _ (s ⊓ t))).rank_eq, Submodule.map_comap_subtype,\n    (equivSubtypeMap (s ⊔ t) (comap _ t)).rank_eq, Submodule.map_comap_subtype,\n    ← inf_assoc, inf_idem, add_right_comm]\n\n"}
{"name":"Submodule.rank_add_le_rank_add_rank","module":"Mathlib.LinearAlgebra.Dimension.RankNullity","initialProofState":"R : Type u_1\nM : Type u\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : HasRankNullity.{u, u_1} R\ns t : Submodule R M\n⊢ LE.le (Module.rank R (Subtype fun x => Membership.mem (Max.max s t) x)) (HAdd.hAdd (Module.rank R (Subtype fun x => Membership.mem s x)) (Module.rank R (Subtype fun x => Membership.mem t x)))","decl":"theorem Submodule.rank_add_le_rank_add_rank (s t : Submodule R M) :\n    Module.rank R (s ⊔ t : Submodule R M) ≤ Module.rank R s + Module.rank R t := by\n  rw [← Submodule.rank_sup_add_rank_inf_eq]\n  exact self_le_add_right _ _\n\n"}
{"name":"exists_linearIndependent_snoc_of_lt_finrank","module":"Mathlib.LinearAlgebra.Dimension.RankNullity","initialProofState":"R : Type u_1\nM : Type u\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : HasRankNullity.{u, u_1} R\ninst✝ : StrongRankCondition R\nn : Nat\nv : Fin n → M\nhv : LinearIndependent R v\nh : LT.lt n (Module.finrank R M)\n⊢ Exists fun x => LinearIndependent R (Fin.snoc v x)","decl":"/-- Given a family of `n` linearly independent vectors in a finite-dimensional space of\ndimension `> n`, one may extend the family by another vector while retaining linear independence. -/\ntheorem exists_linearIndependent_snoc_of_lt_finrank {n : ℕ} {v : Fin n → M}\n    (hv : LinearIndependent R v) (h : n < finrank R M) :\n    ∃ (x : M), LinearIndependent R (Fin.snoc v x) :=\n  exists_linearIndependent_snoc_of_lt_rank hv (lt_rank_of_lt_finrank h)\n\n"}
{"name":"exists_linearIndependent_cons_of_lt_finrank","module":"Mathlib.LinearAlgebra.Dimension.RankNullity","initialProofState":"R : Type u_1\nM : Type u\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : HasRankNullity.{u, u_1} R\ninst✝ : StrongRankCondition R\nn : Nat\nv : Fin n → M\nhv : LinearIndependent R v\nh : LT.lt n (Module.finrank R M)\n⊢ Exists fun x => LinearIndependent R (Fin.cons x v)","decl":"/-- Given a family of `n` linearly independent vectors in a finite-dimensional space of\ndimension `> n`, one may extend the family by another vector while retaining linear independence. -/\ntheorem exists_linearIndependent_cons_of_lt_finrank {n : ℕ} {v : Fin n → M}\n    (hv : LinearIndependent R v) (h : n < finrank R M) :\n    ∃ (x : M), LinearIndependent R (Fin.cons x v) :=\n  exists_linearIndependent_cons_of_lt_rank hv (lt_rank_of_lt_finrank h)\n\n"}
{"name":"exists_linearIndependent_pair_of_one_lt_finrank","module":"Mathlib.LinearAlgebra.Dimension.RankNullity","initialProofState":"R : Type u_1\nM : Type u\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : HasRankNullity.{u, u_1} R\ninst✝¹ : StrongRankCondition R\ninst✝ : NoZeroSMulDivisors R M\nh : LT.lt 1 (Module.finrank R M)\nx : M\nhx : Ne x 0\n⊢ Exists fun y => LinearIndependent R (Matrix.vecCons x (Matrix.vecCons y Matrix.vecEmpty))","decl":"/-- Given a nonzero vector in a finite-dimensional space of dimension `> 1`, one may find another\nvector linearly independent of the first one. -/\ntheorem exists_linearIndependent_pair_of_one_lt_finrank [NoZeroSMulDivisors R M]\n    (h : 1 < finrank R M) {x : M} (hx : x ≠ 0) :\n    ∃ y, LinearIndependent R ![x, y] :=\n  exists_linearIndependent_pair_of_one_lt_rank (one_lt_rank_of_one_lt_finrank h) hx\n\n"}
{"name":"Submodule.finrank_quotient_add_finrank","module":"Mathlib.LinearAlgebra.Dimension.RankNullity","initialProofState":"R : Type u_1\nM : Type u\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : HasRankNullity.{u, u_1} R\ninst✝¹ : StrongRankCondition R\ninst✝ : Module.Finite R M\nN : Submodule R M\n⊢ Eq (HAdd.hAdd (Module.finrank R (HasQuotient.Quotient M N)) (Module.finrank R (Subtype fun x => Membership.mem N x))) (Module.finrank R M)","decl":"/-- Rank-nullity theorem using `finrank`. -/\nlemma Submodule.finrank_quotient_add_finrank [Module.Finite R M] (N : Submodule R M) :\n    finrank R (M ⧸ N) + finrank R N = finrank R M := by\n  rw [← Nat.cast_inj (R := Cardinal), Module.finrank_eq_rank, Nat.cast_add, Module.finrank_eq_rank,\n    Submodule.finrank_eq_rank]\n  exact HasRankNullity.rank_quotient_add_rank _\n\n"}
{"name":"Submodule.finrank_quotient","module":"Mathlib.LinearAlgebra.Dimension.RankNullity","initialProofState":"R : Type u_2\nM : Type u\ninst✝⁹ : Ring R\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : HasRankNullity.{u, u_2} R\ninst✝⁵ : StrongRankCondition R\ninst✝⁴ : Module.Finite R M\nS : Type u_1\ninst✝³ : Ring S\ninst✝² : SMul R S\ninst✝¹ : Module S M\ninst✝ : IsScalarTower R S M\nN : Submodule S M\n⊢ Eq (Module.finrank R (HasQuotient.Quotient M N)) (HSub.hSub (Module.finrank R M) (Module.finrank R (Subtype fun x => Membership.mem N x)))","decl":"/-- Rank-nullity theorem using `finrank` and subtraction. -/\nlemma Submodule.finrank_quotient [Module.Finite R M] {S : Type*} [Ring S] [SMul R S] [Module S M]\n    [IsScalarTower R S M] (N : Submodule S M) : finrank R (M ⧸ N) = finrank R M - finrank R N := by\n  rw [← (N.restrictScalars R).finrank_quotient_add_finrank]\n  exact Nat.eq_sub_of_add_eq rfl\n\n"}
{"name":"Submodule.disjoint_ker_of_finrank_le","module":"Mathlib.LinearAlgebra.Dimension.RankNullity","initialProofState":"R : Type u_2\nM : Type u\ninst✝⁸ : Ring R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : HasRankNullity.{u, u_2} R\ninst✝⁴ : StrongRankCondition R\ninst✝³ : NoZeroSMulDivisors R M\nN : Type u_1\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\nL : Submodule R M\ninst✝ : Module.Finite R (Subtype fun x => Membership.mem L x)\nf : LinearMap (RingHom.id R) M N\nh : LE.le (Module.finrank R (Subtype fun x => Membership.mem L x)) (Module.finrank R (Subtype fun x => Membership.mem (Submodule.map f L) x))\n⊢ Disjoint L (LinearMap.ker f)","decl":"lemma Submodule.disjoint_ker_of_finrank_le [NoZeroSMulDivisors R M] {N : Type*} [AddCommGroup N]\n    [Module R N] {L : Submodule R M} [Module.Finite R L] (f : M →ₗ[R] N)\n    (h : finrank R L ≤ finrank R (L.map f)) :\n    Disjoint L (LinearMap.ker f) := by\n  refine disjoint_iff.mpr <| LinearMap.injective_domRestrict_iff.mp <| LinearMap.ker_eq_bot.mp <|\n    Submodule.rank_eq_zero.mp ?_\n  rw [← Submodule.finrank_eq_rank, Nat.cast_eq_zero]\n  rw [← LinearMap.range_domRestrict] at h\n  have := (LinearMap.ker (f.domRestrict L)).finrank_quotient_add_finrank\n  rw [LinearEquiv.finrank_eq (f.domRestrict L).quotKerEquivRange] at this\n  omega\n\n"}
{"name":"Submodule.exists_of_finrank_lt","module":"Mathlib.LinearAlgebra.Dimension.RankNullity","initialProofState":"R : Type u_1\nM : Type u\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : HasRankNullity.{u, u_1} R\ninst✝¹ : StrongRankCondition R\ninst✝ : Module.Finite R M\nN : Submodule R M\nh : LT.lt (Module.finrank R (Subtype fun x => Membership.mem N x)) (Module.finrank R M)\n⊢ Exists fun m => ∀ (r : R), Ne r 0 → Not (Membership.mem N (HSMul.hSMul r m))","decl":"lemma Submodule.exists_of_finrank_lt (N : Submodule R M) (h : finrank R N < finrank R M) :\n    ∃ m : M, ∀ r : R, r ≠ 0 → r • m ∉ N := by\n  obtain ⟨s, hs, hs'⟩ :=\n    exists_finset_linearIndependent_of_le_finrank (R := R) (M := M ⧸ N) le_rfl\n  obtain ⟨v, hv⟩ : s.Nonempty := by rwa [Finset.nonempty_iff_ne_empty, ne_eq, ← Finset.card_eq_zero,\n    hs, finrank_quotient, tsub_eq_zero_iff_le, not_le]\n  obtain ⟨v, rfl⟩ := N.mkQ_surjective v\n  refine ⟨v, fun r hr ↦ mt ?_ hr⟩\n  have := linearIndependent_iff.mp hs' (Finsupp.single ⟨_, hv⟩ r)\n  rwa [Finsupp.linearCombination_single, Finsupp.single_eq_zero, ← LinearMap.map_smul,\n    Submodule.mkQ_apply, Submodule.Quotient.mk_eq_zero] at this\n\n"}
