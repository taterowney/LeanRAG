{"name":"CategoryTheory.eComp_op_eq","module":"Mathlib.CategoryTheory.Enriched.Opposite","initialProofState":"V : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} V\ninst✝² : CategoryTheory.MonoidalCategory V\ninst✝¹ : CategoryTheory.BraidedCategory V\nC : Type u\ninst✝ : CategoryTheory.EnrichedCategory V C\nx y z : Opposite C\n⊢ Eq (CategoryTheory.eComp V z y x) (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding (CategoryTheory.EnrichedCategory.Hom (Opposite.unop y) (Opposite.unop z)) (CategoryTheory.EnrichedCategory.Hom (Opposite.unop x) (Opposite.unop y))).hom (CategoryTheory.eComp V (Opposite.unop x) (Opposite.unop y) (Opposite.unop z)))","decl":"/-- Unfold the definition of composition in the enriched opposite category. -/\n@[reassoc]\nlemma eComp_op_eq {C : Type u} [EnrichedCategory V C] (x y z : Cᵒᵖ) :\n    eComp V z y x = (β_ _ _).hom ≫ eComp V x.unop y.unop z.unop :=\n  rfl\n\n"}
{"name":"CategoryTheory.eComp_op_eq_assoc","module":"Mathlib.CategoryTheory.Enriched.Opposite","initialProofState":"V : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} V\ninst✝² : CategoryTheory.MonoidalCategory V\ninst✝¹ : CategoryTheory.BraidedCategory V\nC : Type u\ninst✝ : CategoryTheory.EnrichedCategory V C\nx y z : Opposite C\nZ : V\nh : Quiver.Hom (CategoryTheory.EnrichedCategory.Hom z x) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V z y x) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding (CategoryTheory.EnrichedCategory.Hom (Opposite.unop y) (Opposite.unop z)) (CategoryTheory.EnrichedCategory.Hom (Opposite.unop x) (Opposite.unop y))).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V (Opposite.unop x) (Opposite.unop y) (Opposite.unop z)) h))","decl":"/-- Unfold the definition of composition in the enriched opposite category. -/\n@[reassoc]\nlemma eComp_op_eq {C : Type u} [EnrichedCategory V C] (x y z : Cᵒᵖ) :\n    eComp V z y x = (β_ _ _).hom ≫ eComp V x.unop y.unop z.unop :=\n  rfl\n\n"}
{"name":"CategoryTheory.tensorHom_eComp_op_eq","module":"Mathlib.CategoryTheory.Enriched.Opposite","initialProofState":"V : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} V\ninst✝² : CategoryTheory.MonoidalCategory V\ninst✝¹ : CategoryTheory.BraidedCategory V\nC : Type u\ninst✝ : CategoryTheory.EnrichedCategory V C\nx y z : Opposite C\nv w : V\nf : Quiver.Hom v (CategoryTheory.EnrichedCategory.Hom z y)\ng : Quiver.Hom w (CategoryTheory.EnrichedCategory.Hom y x)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f g) (CategoryTheory.eComp V z y x)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding v w).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom g f) (CategoryTheory.eComp V (Opposite.unop x) (Opposite.unop y) (Opposite.unop z))))","decl":"/-- When composing a tensor product of morphisms with the `V`-composition morphism in `Cᵒᵖ`,\nthis re-writes the `V`-composition to be in `C` and moves the braiding to the left. -/\n@[reassoc]\nlemma tensorHom_eComp_op_eq {C : Type u} [EnrichedCategory V C] {x y z : Cᵒᵖ} {v w : V}\n    (f : v ⟶ EnrichedCategory.Hom z y) (g : w ⟶ EnrichedCategory.Hom y x) :\n    (f ⊗ g) ≫ eComp V z y x = (β_ v w).hom ≫ (g ⊗ f) ≫ eComp V x.unop y.unop z.unop := by\n  rw [eComp_op_eq]\n  exact braiding_naturality_assoc f g _\n\n-- This section establishes the equivalence on underlying categories\n"}
{"name":"CategoryTheory.tensorHom_eComp_op_eq_assoc","module":"Mathlib.CategoryTheory.Enriched.Opposite","initialProofState":"V : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} V\ninst✝² : CategoryTheory.MonoidalCategory V\ninst✝¹ : CategoryTheory.BraidedCategory V\nC : Type u\ninst✝ : CategoryTheory.EnrichedCategory V C\nx y z : Opposite C\nv w : V\nf : Quiver.Hom v (CategoryTheory.EnrichedCategory.Hom z y)\ng : Quiver.Hom w (CategoryTheory.EnrichedCategory.Hom y x)\nZ : V\nh : Quiver.Hom (CategoryTheory.EnrichedCategory.Hom z x) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V z y x) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding v w).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom g f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V (Opposite.unop x) (Opposite.unop y) (Opposite.unop z)) h)))","decl":"/-- When composing a tensor product of morphisms with the `V`-composition morphism in `Cᵒᵖ`,\nthis re-writes the `V`-composition to be in `C` and moves the braiding to the left. -/\n@[reassoc]\nlemma tensorHom_eComp_op_eq {C : Type u} [EnrichedCategory V C] {x y z : Cᵒᵖ} {v w : V}\n    (f : v ⟶ EnrichedCategory.Hom z y) (g : w ⟶ EnrichedCategory.Hom y x) :\n    (f ⊗ g) ≫ eComp V z y x = (β_ v w).hom ≫ (g ⊗ f) ≫ eComp V x.unop y.unop z.unop := by\n  rw [eComp_op_eq]\n  exact braiding_naturality_assoc f g _\n\n-- This section establishes the equivalence on underlying categories\n"}
{"name":"CategoryTheory.forgetEnrichmentOppositeEquivalence_functor","module":"Mathlib.CategoryTheory.Enriched.Opposite","initialProofState":"V : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} V\ninst✝² : CategoryTheory.MonoidalCategory V\ninst✝¹ : CategoryTheory.BraidedCategory V\nC : Type u\ninst✝ : CategoryTheory.EnrichedCategory V C\n⊢ Eq (CategoryTheory.forgetEnrichmentOppositeEquivalence V C).functor (CategoryTheory.forgetEnrichmentOppositeEquivalence.functor V C)","decl":"/-- The equivalence between the underlying category of the enriched category `Cᵒᵖ` and\nthe opposite of the underlying category of the enriched category `C`. -/\n@[simps]\ndef forgetEnrichmentOppositeEquivalence : ForgetEnrichment V Cᵒᵖ ≌ (ForgetEnrichment V C)ᵒᵖ where\n  functor := forgetEnrichmentOppositeEquivalence.functor V C\n  inverse := forgetEnrichmentOppositeEquivalence.inverse V C\n  unitIso := NatIso.ofComponents (fun _ ↦ Iso.refl _)\n  counitIso := NatIso.ofComponents (fun _ ↦ Iso.refl _)\n\n"}
{"name":"CategoryTheory.forgetEnrichmentOppositeEquivalence_unitIso","module":"Mathlib.CategoryTheory.Enriched.Opposite","initialProofState":"V : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} V\ninst✝² : CategoryTheory.MonoidalCategory V\ninst✝¹ : CategoryTheory.BraidedCategory V\nC : Type u\ninst✝ : CategoryTheory.EnrichedCategory V C\n⊢ Eq (CategoryTheory.forgetEnrichmentOppositeEquivalence V C).unitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.ForgetEnrichment V (Opposite C))).obj x)) ⋯)","decl":"/-- The equivalence between the underlying category of the enriched category `Cᵒᵖ` and\nthe opposite of the underlying category of the enriched category `C`. -/\n@[simps]\ndef forgetEnrichmentOppositeEquivalence : ForgetEnrichment V Cᵒᵖ ≌ (ForgetEnrichment V C)ᵒᵖ where\n  functor := forgetEnrichmentOppositeEquivalence.functor V C\n  inverse := forgetEnrichmentOppositeEquivalence.inverse V C\n  unitIso := NatIso.ofComponents (fun _ ↦ Iso.refl _)\n  counitIso := NatIso.ofComponents (fun _ ↦ Iso.refl _)\n\n"}
{"name":"CategoryTheory.forgetEnrichmentOppositeEquivalence_counitIso","module":"Mathlib.CategoryTheory.Enriched.Opposite","initialProofState":"V : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} V\ninst✝² : CategoryTheory.MonoidalCategory V\ninst✝¹ : CategoryTheory.BraidedCategory V\nC : Type u\ninst✝ : CategoryTheory.EnrichedCategory V C\n⊢ Eq (CategoryTheory.forgetEnrichmentOppositeEquivalence V C).counitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.Iso.refl (((CategoryTheory.forgetEnrichmentOppositeEquivalence.inverse V C).comp (CategoryTheory.forgetEnrichmentOppositeEquivalence.functor V C)).obj x)) ⋯)","decl":"/-- The equivalence between the underlying category of the enriched category `Cᵒᵖ` and\nthe opposite of the underlying category of the enriched category `C`. -/\n@[simps]\ndef forgetEnrichmentOppositeEquivalence : ForgetEnrichment V Cᵒᵖ ≌ (ForgetEnrichment V C)ᵒᵖ where\n  functor := forgetEnrichmentOppositeEquivalence.functor V C\n  inverse := forgetEnrichmentOppositeEquivalence.inverse V C\n  unitIso := NatIso.ofComponents (fun _ ↦ Iso.refl _)\n  counitIso := NatIso.ofComponents (fun _ ↦ Iso.refl _)\n\n"}
{"name":"CategoryTheory.forgetEnrichmentOppositeEquivalence_inverse","module":"Mathlib.CategoryTheory.Enriched.Opposite","initialProofState":"V : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} V\ninst✝² : CategoryTheory.MonoidalCategory V\ninst✝¹ : CategoryTheory.BraidedCategory V\nC : Type u\ninst✝ : CategoryTheory.EnrichedCategory V C\n⊢ Eq (CategoryTheory.forgetEnrichmentOppositeEquivalence V C).inverse (CategoryTheory.forgetEnrichmentOppositeEquivalence.inverse V C)","decl":"/-- The equivalence between the underlying category of the enriched category `Cᵒᵖ` and\nthe opposite of the underlying category of the enriched category `C`. -/\n@[simps]\ndef forgetEnrichmentOppositeEquivalence : ForgetEnrichment V Cᵒᵖ ≌ (ForgetEnrichment V C)ᵒᵖ where\n  functor := forgetEnrichmentOppositeEquivalence.functor V C\n  inverse := forgetEnrichmentOppositeEquivalence.inverse V C\n  unitIso := NatIso.ofComponents (fun _ ↦ Iso.refl _)\n  counitIso := NatIso.ofComponents (fun _ ↦ Iso.refl _)\n\n"}
