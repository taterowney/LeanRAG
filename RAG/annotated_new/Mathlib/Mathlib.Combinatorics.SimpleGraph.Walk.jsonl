{"name":"SimpleGraph.Walk.nil.sizeOf_spec","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : SizeOf V\nu : V\n⊢ Eq (SizeOf.sizeOf SimpleGraph.Walk.nil) (HAdd.hAdd 1 (SizeOf.sizeOf u))","decl":"/-- A walk is a sequence of adjacent vertices.  For vertices `u v : V`,\nthe type `walk u v` consists of all walks starting at `u` and ending at `v`.\n\nWe say that a walk *visits* the vertices it contains.  The set of vertices a\nwalk visits is `SimpleGraph.Walk.support`.\n\nSee `SimpleGraph.Walk.nil'` and `SimpleGraph.Walk.cons'` for patterns that\ncan be useful in definitions since they make the vertices explicit. -/\ninductive Walk : V → V → Type u\n  | nil {u : V} : Walk u u\n  | cons {u v w : V} (h : G.Adj u v) (p : Walk v w) : Walk u w\n  deriving DecidableEq\n\n"}
{"name":"SimpleGraph.Walk.cons.inj","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v✝ w : V\nh✝ : G.Adj u v✝\np✝ : G.Walk v✝ w\nv : V\nh : G.Adj u v\np : G.Walk v w\nx✝ : Eq (SimpleGraph.Walk.cons h✝ p✝) (SimpleGraph.Walk.cons h p)\n⊢ And (Eq v✝ v) (HEq p✝ p)","decl":"/-- A walk is a sequence of adjacent vertices.  For vertices `u v : V`,\nthe type `walk u v` consists of all walks starting at `u` and ending at `v`.\n\nWe say that a walk *visits* the vertices it contains.  The set of vertices a\nwalk visits is `SimpleGraph.Walk.support`.\n\nSee `SimpleGraph.Walk.nil'` and `SimpleGraph.Walk.cons'` for patterns that\ncan be useful in definitions since they make the vertices explicit. -/\ninductive Walk : V → V → Type u\n  | nil {u : V} : Walk u u\n  | cons {u v w : V} (h : G.Adj u v) (p : Walk v w) : Walk u w\n  deriving DecidableEq\n\n"}
{"name":"SimpleGraph.Walk.cons.sizeOf_spec","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : SizeOf V\nu v w : V\nh : G.Adj u v\np : G.Walk v w\n⊢ Eq (SizeOf.sizeOf (SimpleGraph.Walk.cons h p)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf u)) (SizeOf.sizeOf v)) (SizeOf.sizeOf w)) (SizeOf.sizeOf h)) (SizeOf.sizeOf p))","decl":"/-- A walk is a sequence of adjacent vertices.  For vertices `u v : V`,\nthe type `walk u v` consists of all walks starting at `u` and ending at `v`.\n\nWe say that a walk *visits* the vertices it contains.  The set of vertices a\nwalk visits is `SimpleGraph.Walk.support`.\n\nSee `SimpleGraph.Walk.nil'` and `SimpleGraph.Walk.cons'` for patterns that\ncan be useful in definitions since they make the vertices explicit. -/\ninductive Walk : V → V → Type u\n  | nil {u : V} : Walk u u\n  | cons {u v w : V} (h : G.Adj u v) (p : Walk v w) : Walk u w\n  deriving DecidableEq\n\n"}
{"name":"SimpleGraph.Walk.cons.injEq","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v✝ w : V\nh✝ : G.Adj u v✝\np✝ : G.Walk v✝ w\nv : V\nh : G.Adj u v\np : G.Walk v w\n⊢ Eq (Eq (SimpleGraph.Walk.cons h✝ p✝) (SimpleGraph.Walk.cons h p)) (And (Eq v✝ v) (HEq p✝ p))","decl":"/-- A walk is a sequence of adjacent vertices.  For vertices `u v : V`,\nthe type `walk u v` consists of all walks starting at `u` and ending at `v`.\n\nWe say that a walk *visits* the vertices it contains.  The set of vertices a\nwalk visits is `SimpleGraph.Walk.support`.\n\nSee `SimpleGraph.Walk.nil'` and `SimpleGraph.Walk.cons'` for patterns that\ncan be useful in definitions since they make the vertices explicit. -/\ninductive Walk : V → V → Type u\n  | nil {u : V} : Walk u u\n  | cons {u v w : V} (h : G.Adj u v) (p : Walk v w) : Walk u w\n  deriving DecidableEq\n\n"}
{"name":"SimpleGraph.Walk.instInhabited_default","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nv : V\n⊢ Eq Inhabited.default SimpleGraph.Walk.nil","decl":"@[simps]\ninstance Walk.instInhabited (v : V) : Inhabited (G.Walk v v) := ⟨Walk.nil⟩\n\n"}
{"name":"SimpleGraph.Walk.copy_rfl_rfl","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ Eq (p.copy ⋯ ⋯) p","decl":"@[simp]\ntheorem copy_rfl_rfl {u v} (p : G.Walk u v) : p.copy rfl rfl = p := rfl\n\n"}
{"name":"SimpleGraph.Walk.copy_copy","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v u' v' u'' v'' : V\np : G.Walk u v\nhu : Eq u u'\nhv : Eq v v'\nhu' : Eq u' u''\nhv' : Eq v' v''\n⊢ Eq ((p.copy hu hv).copy hu' hv') (p.copy ⋯ ⋯)","decl":"@[simp]\ntheorem copy_copy {u v u' v' u'' v''} (p : G.Walk u v)\n    (hu : u = u') (hv : v = v') (hu' : u' = u'') (hv' : v' = v'') :\n    (p.copy hu hv).copy hu' hv' = p.copy (hu.trans hu') (hv.trans hv') := by\n  subst_vars\n  rfl\n\n"}
{"name":"SimpleGraph.Walk.copy_nil","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu u' : V\nhu : Eq u u'\n⊢ Eq (SimpleGraph.Walk.nil.copy hu hu) SimpleGraph.Walk.nil","decl":"@[simp]\ntheorem copy_nil {u u'} (hu : u = u') : (Walk.nil : G.Walk u u).copy hu hu = Walk.nil := by\n  subst_vars\n  rfl\n\n"}
{"name":"SimpleGraph.Walk.copy_cons","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w u' w' : V\nh : G.Adj u v\np : G.Walk v w\nhu : Eq u u'\nhw : Eq w w'\n⊢ Eq ((SimpleGraph.Walk.cons h p).copy hu hw) (SimpleGraph.Walk.cons ⋯ (p.copy ⋯ hw))","decl":"theorem copy_cons {u v w u' w'} (h : G.Adj u v) (p : G.Walk v w) (hu : u = u') (hw : w = w') :\n    (Walk.cons h p).copy hu hw = Walk.cons (hu ▸ h) (p.copy rfl hw) := by\n  subst_vars\n  rfl\n\n"}
{"name":"SimpleGraph.Walk.cons_copy","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w v' w' : V\nh : G.Adj u v\np : G.Walk v' w'\nhv : Eq v' v\nhw : Eq w' w\n⊢ Eq (SimpleGraph.Walk.cons h (p.copy hv hw)) ((SimpleGraph.Walk.cons ⋯ p).copy ⋯ hw)","decl":"@[simp]\ntheorem cons_copy {u v w v' w'} (h : G.Adj u v) (p : G.Walk v' w') (hv : v' = v) (hw : w' = w) :\n    Walk.cons h (p.copy hv hw) = (Walk.cons (hv ▸ h) p).copy rfl hw := by\n  subst_vars\n  rfl\n\n"}
{"name":"SimpleGraph.Walk.exists_eq_cons_of_ne","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\nhne : Ne u v\np : G.Walk u v\n⊢ Exists fun w => Exists fun h => Exists fun p' => Eq p (SimpleGraph.Walk.cons h p')","decl":"theorem exists_eq_cons_of_ne {u v : V} (hne : u ≠ v) :\n    ∀ (p : G.Walk u v), ∃ (w : V) (h : G.Adj u w) (p' : G.Walk w v), p = cons h p'\n  | nil => (hne rfl).elim\n  | cons h p' => ⟨_, h, p', rfl⟩\n\n"}
{"name":"SimpleGraph.Walk.concat_eq_append","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\nh : G.Adj v w\n⊢ Eq (p.concat h) (p.append (SimpleGraph.Walk.cons h SimpleGraph.Walk.nil))","decl":"theorem concat_eq_append {u v w : V} (p : G.Walk u v) (h : G.Adj v w) :\n    p.concat h = p.append (cons h nil) := rfl\n\n"}
{"name":"SimpleGraph.Walk.getVert_zero","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\nw : G.Walk u v\n⊢ Eq (w.getVert 0) u","decl":"@[simp]\ntheorem getVert_zero {u v} (w : G.Walk u v) : w.getVert 0 = u := by cases w <;> rfl\n\n"}
{"name":"SimpleGraph.Walk.getVert_nil","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\ni : Nat\n⊢ Eq (SimpleGraph.Walk.nil.getVert i) u","decl":"@[simp]\ntheorem getVert_nil (u : V) {i : ℕ} : (@nil _ G u).getVert i = u := rfl\n\n"}
{"name":"SimpleGraph.Walk.getVert_of_length_le","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\nw : G.Walk u v\ni : Nat\nhi : LE.le w.length i\n⊢ Eq (w.getVert i) v","decl":"theorem getVert_of_length_le {u v} (w : G.Walk u v) {i : ℕ} (hi : w.length ≤ i) :\n    w.getVert i = v := by\n  induction w generalizing i with\n  | nil => rfl\n  | cons _ _ ih =>\n    cases i\n    · cases hi\n    · exact ih (Nat.succ_le_succ_iff.1 hi)\n\n"}
{"name":"SimpleGraph.Walk.getVert_length","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\nw : G.Walk u v\n⊢ Eq (w.getVert w.length) v","decl":"@[simp]\ntheorem getVert_length {u v} (w : G.Walk u v) : w.getVert w.length = v :=\n  w.getVert_of_length_le rfl.le\n\n"}
{"name":"SimpleGraph.Walk.adj_getVert_succ","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\nw : G.Walk u v\ni : Nat\nhi : LT.lt i w.length\n⊢ G.Adj (w.getVert i) (w.getVert (HAdd.hAdd i 1))","decl":"theorem adj_getVert_succ {u v} (w : G.Walk u v) {i : ℕ} (hi : i < w.length) :\n    G.Adj (w.getVert i) (w.getVert (i + 1)) := by\n  induction w generalizing i with\n  | nil => cases hi\n  | cons hxy _ ih =>\n    cases i\n    · simp [getVert, hxy]\n    · exact ih (Nat.succ_lt_succ_iff.1 hi)\n\n"}
{"name":"SimpleGraph.Walk.getVert_cons_succ","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\nn : Nat\np : G.Walk v w\nh : G.Adj u v\n⊢ Eq ((SimpleGraph.Walk.cons h p).getVert (HAdd.hAdd n 1)) (p.getVert n)","decl":"@[simp]\nlemma getVert_cons_succ {u v w n} (p : G.Walk v w) (h : G.Adj u v) :\n    (p.cons h).getVert (n + 1) = p.getVert n := rfl\n\n"}
{"name":"SimpleGraph.Walk.getVert_cons","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\nn : Nat\np : G.Walk v w\nh : G.Adj u v\nhn : Ne n 0\n⊢ Eq ((SimpleGraph.Walk.cons h p).getVert n) (p.getVert (HSub.hSub n 1))","decl":"lemma getVert_cons {u v w n} (p : G.Walk v w) (h : G.Adj u v) (hn : n ≠ 0) :\n    (p.cons h).getVert n = p.getVert (n - 1) := by\n  obtain ⟨n, rfl⟩ := Nat.exists_eq_add_one_of_ne_zero hn\n  rw [getVert_cons_succ, Nat.add_sub_cancel]\n\n"}
{"name":"SimpleGraph.Walk.cons_append","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w x : V\nh : G.Adj u v\np : G.Walk v w\nq : G.Walk w x\n⊢ Eq ((SimpleGraph.Walk.cons h p).append q) (SimpleGraph.Walk.cons h (p.append q))","decl":"@[simp]\ntheorem cons_append {u v w x : V} (h : G.Adj u v) (p : G.Walk v w) (q : G.Walk w x) :\n    (cons h p).append q = cons h (p.append q) := rfl\n\n"}
{"name":"SimpleGraph.Walk.cons_nil_append","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\nh : G.Adj u v\np : G.Walk v w\n⊢ Eq ((SimpleGraph.Walk.cons h SimpleGraph.Walk.nil).append p) (SimpleGraph.Walk.cons h p)","decl":"@[simp]\ntheorem cons_nil_append {u v w : V} (h : G.Adj u v) (p : G.Walk v w) :\n    (cons h nil).append p = cons h p := rfl\n\n"}
{"name":"SimpleGraph.Walk.nil_append","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ Eq (SimpleGraph.Walk.nil.append p) p","decl":"@[simp]\ntheorem nil_append {u v : V} (p : G.Walk u v) : nil.append p = p :=\n  rfl\n\n"}
{"name":"SimpleGraph.Walk.append_nil","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ Eq (p.append SimpleGraph.Walk.nil) p","decl":"@[simp]\ntheorem append_nil {u v : V} (p : G.Walk u v) : p.append nil = p := by\n  induction p with\n  | nil => rw [nil_append]\n  | cons _ _ ih => rw [cons_append, ih]\n\n"}
{"name":"SimpleGraph.Walk.append_assoc","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w x : V\np : G.Walk u v\nq : G.Walk v w\nr : G.Walk w x\n⊢ Eq (p.append (q.append r)) ((p.append q).append r)","decl":"theorem append_assoc {u v w x : V} (p : G.Walk u v) (q : G.Walk v w) (r : G.Walk w x) :\n    p.append (q.append r) = (p.append q).append r := by\n  induction p with\n  | nil => rw [nil_append, nil_append]\n  | cons h p' ih => rw [cons_append, cons_append, cons_append, ih]\n\n"}
{"name":"SimpleGraph.Walk.append_copy_copy","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w u' v' w' : V\np : G.Walk u v\nq : G.Walk v w\nhu : Eq u u'\nhv : Eq v v'\nhw : Eq w w'\n⊢ Eq ((p.copy hu hv).append (q.copy hv hw)) ((p.append q).copy hu hw)","decl":"@[simp]\ntheorem append_copy_copy {u v w u' v' w'} (p : G.Walk u v) (q : G.Walk v w)\n    (hu : u = u') (hv : v = v') (hw : w = w') :\n    (p.copy hu hv).append (q.copy hv hw) = (p.append q).copy hu hw := by\n  subst_vars\n  rfl\n\n"}
{"name":"SimpleGraph.Walk.concat_nil","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\nh : G.Adj u v\n⊢ Eq (SimpleGraph.Walk.nil.concat h) (SimpleGraph.Walk.cons h SimpleGraph.Walk.nil)","decl":"theorem concat_nil {u v : V} (h : G.Adj u v) : nil.concat h = cons h nil := rfl\n\n"}
{"name":"SimpleGraph.Walk.concat_cons","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w x : V\nh : G.Adj u v\np : G.Walk v w\nh' : G.Adj w x\n⊢ Eq ((SimpleGraph.Walk.cons h p).concat h') (SimpleGraph.Walk.cons h (p.concat h'))","decl":"@[simp]\ntheorem concat_cons {u v w x : V} (h : G.Adj u v) (p : G.Walk v w) (h' : G.Adj w x) :\n    (cons h p).concat h' = cons h (p.concat h') := rfl\n\n"}
{"name":"SimpleGraph.Walk.append_concat","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w x : V\np : G.Walk u v\nq : G.Walk v w\nh : G.Adj w x\n⊢ Eq (p.append (q.concat h)) ((p.append q).concat h)","decl":"theorem append_concat {u v w x : V} (p : G.Walk u v) (q : G.Walk v w) (h : G.Adj w x) :\n    p.append (q.concat h) = (p.append q).concat h := append_assoc _ _ _\n\n"}
{"name":"SimpleGraph.Walk.concat_append","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w x : V\np : G.Walk u v\nh : G.Adj v w\nq : G.Walk w x\n⊢ Eq ((p.concat h).append q) (p.append (SimpleGraph.Walk.cons h q))","decl":"theorem concat_append {u v w x : V} (p : G.Walk u v) (h : G.Adj v w) (q : G.Walk w x) :\n    (p.concat h).append q = p.append (cons h q) := by\n  rw [concat_eq_append, ← append_assoc, cons_nil_append]\n\n"}
{"name":"SimpleGraph.Walk.exists_cons_eq_concat","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\nh : G.Adj u v\np : G.Walk v w\n⊢ Exists fun x => Exists fun q => Exists fun h' => Eq (SimpleGraph.Walk.cons h p) (q.concat h')","decl":"/-- A non-trivial `cons` walk is representable as a `concat` walk. -/\ntheorem exists_cons_eq_concat {u v w : V} (h : G.Adj u v) (p : G.Walk v w) :\n    ∃ (x : V) (q : G.Walk u x) (h' : G.Adj x w), cons h p = q.concat h' := by\n  induction p generalizing u with\n  | nil => exact ⟨_, nil, h, rfl⟩\n  | cons h' p ih =>\n    obtain ⟨y, q, h'', hc⟩ := ih h'\n    refine ⟨y, cons h q, h'', ?_⟩\n    rw [concat_cons, hc]\n\n"}
{"name":"SimpleGraph.Walk.exists_concat_eq_cons","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\nh : G.Adj v w\n⊢ Exists fun x => Exists fun h' => Exists fun q => Eq (p.concat h) (SimpleGraph.Walk.cons h' q)","decl":"/-- A non-trivial `concat` walk is representable as a `cons` walk. -/\ntheorem exists_concat_eq_cons {u v w : V} :\n    ∀ (p : G.Walk u v) (h : G.Adj v w),\n      ∃ (x : V) (h' : G.Adj u x) (q : G.Walk x w), p.concat h = cons h' q\n  | nil, h => ⟨_, h, nil, rfl⟩\n  | cons h' p, h => ⟨_, h', Walk.concat p h, concat_cons _ _ _⟩\n\n"}
{"name":"SimpleGraph.Walk.reverse_nil","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\n⊢ Eq SimpleGraph.Walk.nil.reverse SimpleGraph.Walk.nil","decl":"@[simp]\ntheorem reverse_nil {u : V} : (nil : G.Walk u u).reverse = nil := rfl\n\n"}
{"name":"SimpleGraph.Walk.reverse_singleton","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\nh : G.Adj u v\n⊢ Eq (SimpleGraph.Walk.cons h SimpleGraph.Walk.nil).reverse (SimpleGraph.Walk.cons ⋯ SimpleGraph.Walk.nil)","decl":"theorem reverse_singleton {u v : V} (h : G.Adj u v) : (cons h nil).reverse = cons (G.symm h) nil :=\n  rfl\n\n"}
{"name":"SimpleGraph.Walk.cons_reverseAux","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w x : V\np : G.Walk u v\nq : G.Walk w x\nh : G.Adj w u\n⊢ Eq ((SimpleGraph.Walk.cons h p).reverseAux q) (p.reverseAux (SimpleGraph.Walk.cons ⋯ q))","decl":"@[simp]\ntheorem cons_reverseAux {u v w x : V} (p : G.Walk u v) (q : G.Walk w x) (h : G.Adj w u) :\n    (cons h p).reverseAux q = p.reverseAux (cons (G.symm h) q) := rfl\n\n"}
{"name":"SimpleGraph.Walk.append_reverseAux","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w x : V\np : G.Walk u v\nq : G.Walk v w\nr : G.Walk u x\n⊢ Eq ((p.append q).reverseAux r) (q.reverseAux (p.reverseAux r))","decl":"@[simp]\nprotected theorem append_reverseAux {u v w x : V}\n    (p : G.Walk u v) (q : G.Walk v w) (r : G.Walk u x) :\n    (p.append q).reverseAux r = q.reverseAux (p.reverseAux r) := by\n  induction p with\n  | nil => rfl\n  | cons h _ ih => exact ih q (cons (G.symm h) r)\n\n"}
{"name":"SimpleGraph.Walk.reverseAux_append","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w x : V\np : G.Walk u v\nq : G.Walk u w\nr : G.Walk w x\n⊢ Eq ((p.reverseAux q).append r) (p.reverseAux (q.append r))","decl":"@[simp]\nprotected theorem reverseAux_append {u v w x : V}\n    (p : G.Walk u v) (q : G.Walk u w) (r : G.Walk w x) :\n    (p.reverseAux q).append r = p.reverseAux (q.append r) := by\n  induction p with\n  | nil => rfl\n  | cons h _ ih => simp [ih (cons (G.symm h) q)]\n\n"}
{"name":"SimpleGraph.Walk.reverseAux_eq_reverse_append","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\nq : G.Walk u w\n⊢ Eq (p.reverseAux q) (p.reverse.append q)","decl":"protected theorem reverseAux_eq_reverse_append {u v w : V} (p : G.Walk u v) (q : G.Walk u w) :\n    p.reverseAux q = p.reverse.append q := by simp [reverse]\n\n"}
{"name":"SimpleGraph.Walk.reverse_cons","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\nh : G.Adj u v\np : G.Walk v w\n⊢ Eq (SimpleGraph.Walk.cons h p).reverse (p.reverse.append (SimpleGraph.Walk.cons ⋯ SimpleGraph.Walk.nil))","decl":"@[simp]\ntheorem reverse_cons {u v w : V} (h : G.Adj u v) (p : G.Walk v w) :\n    (cons h p).reverse = p.reverse.append (cons (G.symm h) nil) := by simp [reverse]\n\n"}
{"name":"SimpleGraph.Walk.reverse_copy","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v u' v' : V\np : G.Walk u v\nhu : Eq u u'\nhv : Eq v v'\n⊢ Eq (p.copy hu hv).reverse (p.reverse.copy hv hu)","decl":"@[simp]\ntheorem reverse_copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).reverse = p.reverse.copy hv hu := by\n  subst_vars\n  rfl\n\n"}
{"name":"SimpleGraph.Walk.reverse_append","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\nq : G.Walk v w\n⊢ Eq (p.append q).reverse (q.reverse.append p.reverse)","decl":"@[simp]\ntheorem reverse_append {u v w : V} (p : G.Walk u v) (q : G.Walk v w) :\n    (p.append q).reverse = q.reverse.append p.reverse := by simp [reverse]\n\n"}
{"name":"SimpleGraph.Walk.reverse_concat","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\nh : G.Adj v w\n⊢ Eq (p.concat h).reverse (SimpleGraph.Walk.cons ⋯ p.reverse)","decl":"@[simp]\ntheorem reverse_concat {u v w : V} (p : G.Walk u v) (h : G.Adj v w) :\n    (p.concat h).reverse = cons (G.symm h) p.reverse := by simp [concat_eq_append]\n\n"}
{"name":"SimpleGraph.Walk.reverse_reverse","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ Eq p.reverse.reverse p","decl":"@[simp]\ntheorem reverse_reverse {u v : V} (p : G.Walk u v) : p.reverse.reverse = p := by\n  induction p with\n  | nil => rfl\n  | cons _ _ ih => simp [ih]\n\n"}
{"name":"SimpleGraph.Walk.reverse_surjective","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\n⊢ Function.Surjective SimpleGraph.Walk.reverse","decl":"theorem reverse_surjective {u v : V} : Function.Surjective (reverse : G.Walk u v → _) :=\n  RightInverse.surjective reverse_reverse\n\n"}
{"name":"SimpleGraph.Walk.reverse_injective","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\n⊢ Function.Injective SimpleGraph.Walk.reverse","decl":"theorem reverse_injective {u v : V} : Function.Injective (reverse : G.Walk u v → _) :=\n  RightInverse.injective reverse_reverse\n\n"}
{"name":"SimpleGraph.Walk.reverse_bijective","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\n⊢ Function.Bijective SimpleGraph.Walk.reverse","decl":"theorem reverse_bijective {u v : V} : Function.Bijective (reverse : G.Walk u v → _) :=\n  And.intro reverse_injective reverse_surjective\n\n"}
{"name":"SimpleGraph.Walk.length_nil","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\n⊢ Eq SimpleGraph.Walk.nil.length 0","decl":"@[simp]\ntheorem length_nil {u : V} : (nil : G.Walk u u).length = 0 := rfl\n\n"}
{"name":"SimpleGraph.Walk.length_cons","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\nh : G.Adj u v\np : G.Walk v w\n⊢ Eq (SimpleGraph.Walk.cons h p).length (HAdd.hAdd p.length 1)","decl":"@[simp]\ntheorem length_cons {u v w : V} (h : G.Adj u v) (p : G.Walk v w) :\n    (cons h p).length = p.length + 1 := rfl\n\n"}
{"name":"SimpleGraph.Walk.length_copy","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v u' v' : V\np : G.Walk u v\nhu : Eq u u'\nhv : Eq v v'\n⊢ Eq (p.copy hu hv).length p.length","decl":"@[simp]\ntheorem length_copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).length = p.length := by\n  subst_vars\n  rfl\n\n"}
{"name":"SimpleGraph.Walk.length_append","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\nq : G.Walk v w\n⊢ Eq (p.append q).length (HAdd.hAdd p.length q.length)","decl":"@[simp]\ntheorem length_append {u v w : V} (p : G.Walk u v) (q : G.Walk v w) :\n    (p.append q).length = p.length + q.length := by\n  induction p with\n  | nil => simp\n  | cons _ _ ih => simp [ih, add_comm, add_left_comm, add_assoc]\n\n"}
{"name":"SimpleGraph.Walk.length_concat","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\nh : G.Adj v w\n⊢ Eq (p.concat h).length (HAdd.hAdd p.length 1)","decl":"@[simp]\ntheorem length_concat {u v w : V} (p : G.Walk u v) (h : G.Adj v w) :\n    (p.concat h).length = p.length + 1 := length_append _ _\n\n"}
{"name":"SimpleGraph.Walk.length_reverseAux","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\nq : G.Walk u w\n⊢ Eq (p.reverseAux q).length (HAdd.hAdd p.length q.length)","decl":"@[simp]\nprotected theorem length_reverseAux {u v w : V} (p : G.Walk u v) (q : G.Walk u w) :\n    (p.reverseAux q).length = p.length + q.length := by\n  induction p with\n  | nil => simp!\n  | cons _ _ ih => simp [ih, Nat.succ_add, Nat.add_assoc]\n\n"}
{"name":"SimpleGraph.Walk.length_reverse","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ Eq p.reverse.length p.length","decl":"@[simp]\ntheorem length_reverse {u v : V} (p : G.Walk u v) : p.reverse.length = p.length := by simp [reverse]\n\n"}
{"name":"SimpleGraph.Walk.eq_of_length_eq_zero","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\na✝ : Eq p.length 0\n⊢ Eq u v","decl":"theorem eq_of_length_eq_zero {u v : V} : ∀ {p : G.Walk u v}, p.length = 0 → u = v\n  | nil, _ => rfl\n\n"}
{"name":"SimpleGraph.Walk.adj_of_length_eq_one","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\na✝ : Eq p.length 1\n⊢ G.Adj u v","decl":"theorem adj_of_length_eq_one {u v : V} : ∀ {p : G.Walk u v}, p.length = 1 → G.Adj u v\n  | cons h nil, _ => h\n\n"}
{"name":"SimpleGraph.Walk.exists_length_eq_zero_iff","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\n⊢ Iff (Exists fun p => Eq p.length 0) (Eq u v)","decl":"@[simp]\ntheorem exists_length_eq_zero_iff {u v : V} : (∃ p : G.Walk u v, p.length = 0) ↔ u = v := by\n  constructor\n  · rintro ⟨p, hp⟩\n    exact eq_of_length_eq_zero hp\n  · rintro rfl\n    exact ⟨nil, rfl⟩\n\n"}
{"name":"SimpleGraph.Walk.length_eq_zero_iff","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\np : G.Walk u u\n⊢ Iff (Eq p.length 0) (Eq p SimpleGraph.Walk.nil)","decl":"@[simp]\ntheorem length_eq_zero_iff {u : V} {p : G.Walk u u} : p.length = 0 ↔ p = nil := by cases p <;> simp\n\n"}
{"name":"SimpleGraph.Walk.getVert_append","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\nq : G.Walk v w\ni : Nat\n⊢ Eq ((p.append q).getVert i) (ite (LT.lt i p.length) (p.getVert i) (q.getVert (HSub.hSub i p.length)))","decl":"theorem getVert_append {u v w : V} (p : G.Walk u v) (q : G.Walk v w) (i : ℕ) :\n    (p.append q).getVert i = if i < p.length then p.getVert i else q.getVert (i - p.length) := by\n  induction p generalizing i with\n  | nil => simp\n  | cons h p ih => cases i <;> simp [getVert, ih, Nat.succ_lt_succ_iff]\n\n"}
{"name":"SimpleGraph.Walk.getVert_reverse","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\ni : Nat\n⊢ Eq (p.reverse.getVert i) (p.getVert (HSub.hSub p.length i))","decl":"theorem getVert_reverse {u v : V} (p : G.Walk u v) (i : ℕ) :\n    p.reverse.getVert i = p.getVert (p.length - i) := by\n  induction p with\n  | nil => rfl\n  | cons h p ih =>\n    simp only [reverse_cons, getVert_append, length_reverse, ih, length_cons]\n    split_ifs\n    next hi =>\n      rw [Nat.succ_sub hi.le]\n      simp [getVert]\n    next hi =>\n      obtain rfl | hi' := Nat.eq_or_lt_of_not_lt hi\n      · simp [getVert]\n      · rw [Nat.eq_add_of_sub_eq (Nat.sub_pos_of_lt hi') rfl, Nat.sub_eq_zero_of_le hi']\n        simp [getVert]\n\n"}
{"name":"SimpleGraph.Walk.concatRec_nil","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nmotive : (u v : V) → G.Walk u v → Sort u_1\nHnil : {u : V} → motive u u SimpleGraph.Walk.nil\nHconcat : {u v w : V} → (p : G.Walk u v) → (h : G.Adj v w) → motive u v p → motive u w (p.concat h)\nu : V\n⊢ Eq (SimpleGraph.Walk.concatRec Hnil Hconcat SimpleGraph.Walk.nil) Hnil","decl":"@[simp]\ntheorem concatRec_nil (u : V) :\n    @concatRec _ _ motive @Hnil @Hconcat _ _ (nil : G.Walk u u) = Hnil := rfl\n\n"}
{"name":"SimpleGraph.Walk.concatRec_concat","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nmotive : (u v : V) → G.Walk u v → Sort u_1\nHnil : {u : V} → motive u u SimpleGraph.Walk.nil\nHconcat : {u v w : V} → (p : G.Walk u v) → (h : G.Adj v w) → motive u v p → motive u w (p.concat h)\nu v w : V\np : G.Walk u v\nh : G.Adj v w\n⊢ Eq (SimpleGraph.Walk.concatRec Hnil Hconcat (p.concat h)) (Hconcat p h (SimpleGraph.Walk.concatRec Hnil Hconcat p))","decl":"@[simp]\ntheorem concatRec_concat {u v w : V} (p : G.Walk u v) (h : G.Adj v w) :\n    @concatRec _ _ motive @Hnil @Hconcat _ _ (p.concat h) =\n      Hconcat p h (concatRec @Hnil @Hconcat p) := by\n  simp only [concatRec]\n  apply eq_of_heq\n  apply rec_heq_of_heq\n  trans concatRecAux @Hnil @Hconcat (cons h.symm p.reverse)\n  · congr\n    simp\n  · rw [concatRecAux, rec_heq_iff_heq]\n    congr <;> simp [heq_rec_iff_heq]\n\n"}
{"name":"SimpleGraph.Walk.concat_ne_nil","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nh : G.Adj v u\n⊢ Ne (p.concat h) SimpleGraph.Walk.nil","decl":"theorem concat_ne_nil {u v : V} (p : G.Walk u v) (h : G.Adj v u) : p.concat h ≠ nil := by\n  cases p <;> simp [concat]\n\n"}
{"name":"SimpleGraph.Walk.concat_inj","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v v' w : V\np : G.Walk u v\nh : G.Adj v w\np' : G.Walk u v'\nh' : G.Adj v' w\nhe : Eq (p.concat h) (p'.concat h')\n⊢ Exists fun hv => Eq (p.copy ⋯ hv) p'","decl":"theorem concat_inj {u v v' w : V} {p : G.Walk u v} {h : G.Adj v w} {p' : G.Walk u v'}\n    {h' : G.Adj v' w} (he : p.concat h = p'.concat h') : ∃ hv : v = v', p.copy rfl hv = p' := by\n  induction p with\n  | nil =>\n    cases p'\n    · exact ⟨rfl, rfl⟩\n    · exfalso\n      simp only [concat_nil, concat_cons, cons.injEq] at he\n      obtain ⟨rfl, he⟩ := he\n      simp only [heq_iff_eq] at he\n      exact concat_ne_nil _ _ he.symm\n  | cons _ _ ih =>\n    rw [concat_cons] at he\n    cases p'\n    · exfalso\n      simp only [concat_nil, cons.injEq] at he\n      obtain ⟨rfl, he⟩ := he\n      rw [heq_iff_eq] at he\n      exact concat_ne_nil _ _ he\n    · rw [concat_cons, cons.injEq] at he\n      obtain ⟨rfl, he⟩ := he\n      rw [heq_iff_eq] at he\n      obtain ⟨rfl, rfl⟩ := ih he\n      exact ⟨rfl, rfl⟩\n\n"}
{"name":"SimpleGraph.Walk.support_nil","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\n⊢ Eq SimpleGraph.Walk.nil.support (List.cons u List.nil)","decl":"@[simp]\ntheorem support_nil {u : V} : (nil : G.Walk u u).support = [u] := rfl\n\n"}
{"name":"SimpleGraph.Walk.support_cons","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\nh : G.Adj u v\np : G.Walk v w\n⊢ Eq (SimpleGraph.Walk.cons h p).support (List.cons u p.support)","decl":"@[simp]\ntheorem support_cons {u v w : V} (h : G.Adj u v) (p : G.Walk v w) :\n    (cons h p).support = u :: p.support := rfl\n\n"}
{"name":"SimpleGraph.Walk.support_concat","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\nh : G.Adj v w\n⊢ Eq (p.concat h).support (p.support.concat w)","decl":"@[simp]\ntheorem support_concat {u v w : V} (p : G.Walk u v) (h : G.Adj v w) :\n    (p.concat h).support = p.support.concat w := by\n  induction p <;> simp [*, concat_nil]\n\n"}
{"name":"SimpleGraph.Walk.support_copy","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v u' v' : V\np : G.Walk u v\nhu : Eq u u'\nhv : Eq v v'\n⊢ Eq (p.copy hu hv).support p.support","decl":"@[simp]\ntheorem support_copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).support = p.support := by\n  subst_vars\n  rfl\n\n"}
{"name":"SimpleGraph.Walk.support_append","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\np' : G.Walk v w\n⊢ Eq (p.append p').support (HAppend.hAppend p.support p'.support.tail)","decl":"theorem support_append {u v w : V} (p : G.Walk u v) (p' : G.Walk v w) :\n    (p.append p').support = p.support ++ p'.support.tail := by\n  induction p <;> cases p' <;> simp [*]\n\n"}
{"name":"SimpleGraph.Walk.support_reverse","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ Eq p.reverse.support p.support.reverse","decl":"@[simp]\ntheorem support_reverse {u v : V} (p : G.Walk u v) : p.reverse.support = p.support.reverse := by\n  induction p <;> simp [support_append, *]\n\n"}
{"name":"SimpleGraph.Walk.support_ne_nil","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ Ne p.support List.nil","decl":"@[simp]\ntheorem support_ne_nil {u v : V} (p : G.Walk u v) : p.support ≠ [] := by cases p <;> simp\n\n"}
{"name":"SimpleGraph.Walk.head_support","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\na b : V\np : G.Walk a b\n⊢ Eq (p.support.head ⋯) a","decl":"@[simp]\ntheorem head_support {G : SimpleGraph V} {a b : V} (p : G.Walk a b) :\n    p.support.head (by simp) = a := by cases p <;> simp\n\n"}
{"name":"SimpleGraph.Walk.getLast_support","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\na b : V\np : G.Walk a b\n⊢ Eq (p.support.getLast ⋯) b","decl":"@[simp]\ntheorem getLast_support {G : SimpleGraph V} {a b : V} (p : G.Walk a b) :\n    p.support.getLast (by simp) = b := by\n  induction p\n  · simp\n  · simpa\n\n"}
{"name":"SimpleGraph.Walk.tail_support_append","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\np' : G.Walk v w\n⊢ Eq (p.append p').support.tail (HAppend.hAppend p.support.tail p'.support.tail)","decl":"theorem tail_support_append {u v w : V} (p : G.Walk u v) (p' : G.Walk v w) :\n    (p.append p').support.tail = p.support.tail ++ p'.support.tail := by\n  rw [support_append, List.tail_append_of_ne_nil (support_ne_nil _)]\n\n"}
{"name":"SimpleGraph.Walk.support_eq_cons","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ Eq p.support (List.cons u p.support.tail)","decl":"theorem support_eq_cons {u v : V} (p : G.Walk u v) : p.support = u :: p.support.tail := by\n  cases p <;> simp\n\n"}
{"name":"SimpleGraph.Walk.start_mem_support","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ Membership.mem p.support u","decl":"@[simp]\ntheorem start_mem_support {u v : V} (p : G.Walk u v) : u ∈ p.support := by cases p <;> simp\n\n"}
{"name":"SimpleGraph.Walk.end_mem_support","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ Membership.mem p.support v","decl":"@[simp]\ntheorem end_mem_support {u v : V} (p : G.Walk u v) : v ∈ p.support := by induction p <;> simp [*]\n\n"}
{"name":"SimpleGraph.Walk.support_nonempty","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ (setOf fun w => Membership.mem p.support w).Nonempty","decl":"@[simp]\ntheorem support_nonempty {u v : V} (p : G.Walk u v) : { w | w ∈ p.support }.Nonempty :=\n  ⟨u, by simp⟩\n\n"}
{"name":"SimpleGraph.Walk.mem_support_iff","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\n⊢ Iff (Membership.mem p.support w) (Or (Eq w u) (Membership.mem p.support.tail w))","decl":"theorem mem_support_iff {u v w : V} (p : G.Walk u v) :\n    w ∈ p.support ↔ w = u ∨ w ∈ p.support.tail := by cases p <;> simp\n\n"}
{"name":"SimpleGraph.Walk.mem_support_nil_iff","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\n⊢ Iff (Membership.mem SimpleGraph.Walk.nil.support u) (Eq u v)","decl":"theorem mem_support_nil_iff {u v : V} : u ∈ (nil : G.Walk v v).support ↔ u = v := by simp\n\n"}
{"name":"SimpleGraph.Walk.mem_tail_support_append_iff","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nt u v w : V\np : G.Walk u v\np' : G.Walk v w\n⊢ Iff (Membership.mem (p.append p').support.tail t) (Or (Membership.mem p.support.tail t) (Membership.mem p'.support.tail t))","decl":"@[simp]\ntheorem mem_tail_support_append_iff {t u v w : V} (p : G.Walk u v) (p' : G.Walk v w) :\n    t ∈ (p.append p').support.tail ↔ t ∈ p.support.tail ∨ t ∈ p'.support.tail := by\n  rw [tail_support_append, List.mem_append]\n\n"}
{"name":"SimpleGraph.Walk.end_mem_tail_support_of_ne","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\nh : Ne u v\np : G.Walk u v\n⊢ Membership.mem p.support.tail v","decl":"@[simp]\ntheorem end_mem_tail_support_of_ne {u v : V} (h : u ≠ v) (p : G.Walk u v) : v ∈ p.support.tail := by\n  obtain ⟨_, _, _, rfl⟩ := exists_eq_cons_of_ne h p\n  simp\n\n"}
{"name":"SimpleGraph.Walk.mem_support_append_iff","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nt u v w : V\np : G.Walk u v\np' : G.Walk v w\n⊢ Iff (Membership.mem (p.append p').support t) (Or (Membership.mem p.support t) (Membership.mem p'.support t))","decl":"@[simp, nolint unusedHavesSuffices]\ntheorem mem_support_append_iff {t u v w : V} (p : G.Walk u v) (p' : G.Walk v w) :\n    t ∈ (p.append p').support ↔ t ∈ p.support ∨ t ∈ p'.support := by\n  simp only [mem_support_iff, mem_tail_support_append_iff]\n  obtain rfl | h := eq_or_ne t v <;> obtain rfl | h' := eq_or_ne t u <;>\n    -- this `have` triggers the unusedHavesSuffices linter:\n    (try have := h'.symm) <;> simp [*]\n\n"}
{"name":"SimpleGraph.Walk.subset_support_append_left","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\nq : G.Walk v w\n⊢ HasSubset.Subset p.support (p.append q).support","decl":"@[simp]\ntheorem subset_support_append_left {V : Type u} {G : SimpleGraph V} {u v w : V}\n    (p : G.Walk u v) (q : G.Walk v w) : p.support ⊆ (p.append q).support := by\n  simp only [Walk.support_append, List.subset_append_left]\n\n"}
{"name":"SimpleGraph.Walk.subset_support_append_right","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\nq : G.Walk v w\n⊢ HasSubset.Subset q.support (p.append q).support","decl":"@[simp]\ntheorem subset_support_append_right {V : Type u} {G : SimpleGraph V} {u v w : V}\n    (p : G.Walk u v) (q : G.Walk v w) : q.support ⊆ (p.append q).support := by\n  intro h\n  simp +contextual only [mem_support_append_iff, or_true, imp_true_iff]\n\n"}
{"name":"SimpleGraph.Walk.getVert_eq_support_get?","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\nn : Nat\np : G.Walk u v\nh2 : LE.le n p.length\n⊢ Eq (Option.some (p.getVert n)) (GetElem?.getElem? p.support n)","decl":"lemma getVert_eq_support_get? {u v n} (p : G.Walk u v) (h2 : n ≤ p.length) :\n    p.getVert n = p.support[n]? := by\n  match p with\n  | .nil => simp_all\n  | .cons h q =>\n    simp only [Walk.support_cons]\n    by_cases hn : n = 0\n    · simp only [hn, getVert_zero, List.length_cons, Nat.zero_lt_succ, List.getElem?_eq_getElem,\n      List.getElem_cons_zero]\n    · push_neg at hn\n      nth_rewrite 2 [← Nat.sub_one_add_one hn]\n      rw [Walk.getVert_cons q h hn, List.getElem?_cons_succ]\n      exact getVert_eq_support_get? q (Nat.sub_le_of_le_add (Walk.length_cons _ _ ▸ h2))\n\n"}
{"name":"SimpleGraph.Walk.coe_support","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ Eq (↑p.support) (HAdd.hAdd (Singleton.singleton u) ↑p.support.tail)","decl":"theorem coe_support {u v : V} (p : G.Walk u v) :\n    (p.support : Multiset V) = {u} + p.support.tail := by cases p <;> rfl\n\n"}
{"name":"SimpleGraph.Walk.coe_support_append","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\np' : G.Walk v w\n⊢ Eq (↑(p.append p').support) (HAdd.hAdd (HAdd.hAdd (Singleton.singleton u) ↑p.support.tail) ↑p'.support.tail)","decl":"theorem coe_support_append {u v w : V} (p : G.Walk u v) (p' : G.Walk v w) :\n    ((p.append p').support : Multiset V) = {u} + p.support.tail + p'.support.tail := by\n  rw [support_append, ← Multiset.coe_add, coe_support]\n\n"}
{"name":"SimpleGraph.Walk.coe_support_append'","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v w : V\np : G.Walk u v\np' : G.Walk v w\n⊢ Eq (↑(p.append p').support) (HSub.hSub (HAdd.hAdd ↑p.support ↑p'.support) (Singleton.singleton v))","decl":"theorem coe_support_append' [DecidableEq V] {u v w : V} (p : G.Walk u v) (p' : G.Walk v w) :\n    ((p.append p').support : Multiset V) = p.support + p'.support - {v} := by\n  rw [support_append, ← Multiset.coe_add]\n  simp only [coe_support]\n  rw [add_comm ({v} : Multiset V)]\n  simp only [← add_assoc, add_tsub_cancel_right]\n\n"}
{"name":"SimpleGraph.Walk.chain_adj_support","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\nh : G.Adj u v\np : G.Walk v w\n⊢ List.Chain G.Adj u p.support","decl":"theorem chain_adj_support {u v w : V} (h : G.Adj u v) :\n    ∀ (p : G.Walk v w), List.Chain G.Adj u p.support\n  | nil => List.Chain.cons h List.Chain.nil\n  | cons h' p => List.Chain.cons h (chain_adj_support h' p)\n\n"}
{"name":"SimpleGraph.Walk.chain'_adj_support","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ List.Chain' G.Adj p.support","decl":"theorem chain'_adj_support {u v : V} : ∀ (p : G.Walk u v), List.Chain' G.Adj p.support\n  | nil => List.Chain.nil\n  | cons h p => chain_adj_support h p\n\n"}
{"name":"SimpleGraph.Walk.chain_dartAdj_darts","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nd : G.Dart\nv w : V\nh : Eq d.toProd.2 v\np : G.Walk v w\n⊢ List.Chain G.DartAdj d p.darts","decl":"theorem chain_dartAdj_darts {d : G.Dart} {v w : V} (h : d.snd = v) (p : G.Walk v w) :\n    List.Chain G.DartAdj d p.darts := by\n  induction p generalizing d with\n  | nil => exact List.Chain.nil\n  | cons h' p ih => exact List.Chain.cons h (ih rfl)\n\n"}
{"name":"SimpleGraph.Walk.chain'_dartAdj_darts","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ List.Chain' G.DartAdj p.darts","decl":"theorem chain'_dartAdj_darts {u v : V} : ∀ (p : G.Walk u v), List.Chain' G.DartAdj p.darts\n  | nil => trivial\n  -- Porting note: needed to defer `rfl` to help elaboration\n  | cons h p => chain_dartAdj_darts (by rfl) p\n\n"}
{"name":"SimpleGraph.Walk.edges_subset_edgeSet","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\ne : Sym2 V\na✝ : Membership.mem p.edges e\n⊢ Membership.mem G.edgeSet e","decl":"/-- Every edge in a walk's edge list is an edge of the graph.\nIt is written in this form (rather than using `⊆`) to avoid unsightly coercions. -/\ntheorem edges_subset_edgeSet {u v : V} :\n    ∀ (p : G.Walk u v) ⦃e : Sym2 V⦄, e ∈ p.edges → e ∈ G.edgeSet\n  | cons h' p', e, h => by\n    cases h\n    · exact h'\n    next h' => exact edges_subset_edgeSet p' h'\n\n"}
{"name":"SimpleGraph.Walk.adj_of_mem_edges","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v x y : V\np : G.Walk u v\nh : Membership.mem p.edges (Sym2.mk { fst := x, snd := y })\n⊢ G.Adj x y","decl":"theorem adj_of_mem_edges {u v x y : V} (p : G.Walk u v) (h : s(x, y) ∈ p.edges) : G.Adj x y :=\n  edges_subset_edgeSet p h\n\n"}
{"name":"SimpleGraph.Walk.darts_nil","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\n⊢ Eq SimpleGraph.Walk.nil.darts List.nil","decl":"@[simp]\ntheorem darts_nil {u : V} : (nil : G.Walk u u).darts = [] := rfl\n\n"}
{"name":"SimpleGraph.Walk.darts_cons","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\nh : G.Adj u v\np : G.Walk v w\n⊢ Eq (SimpleGraph.Walk.cons h p).darts (List.cons { fst := u, snd := v, adj := h } p.darts)","decl":"@[simp]\ntheorem darts_cons {u v w : V} (h : G.Adj u v) (p : G.Walk v w) :\n    (cons h p).darts = ⟨(u, v), h⟩ :: p.darts := rfl\n\n"}
{"name":"SimpleGraph.Walk.darts_concat","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\nh : G.Adj v w\n⊢ Eq (p.concat h).darts (p.darts.concat { fst := v, snd := w, adj := h })","decl":"@[simp]\ntheorem darts_concat {u v w : V} (p : G.Walk u v) (h : G.Adj v w) :\n    (p.concat h).darts = p.darts.concat ⟨(v, w), h⟩ := by\n  induction p <;> simp [*, concat_nil]\n\n"}
{"name":"SimpleGraph.Walk.darts_copy","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v u' v' : V\np : G.Walk u v\nhu : Eq u u'\nhv : Eq v v'\n⊢ Eq (p.copy hu hv).darts p.darts","decl":"@[simp]\ntheorem darts_copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).darts = p.darts := by\n  subst_vars\n  rfl\n\n"}
{"name":"SimpleGraph.Walk.darts_append","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\np' : G.Walk v w\n⊢ Eq (p.append p').darts (HAppend.hAppend p.darts p'.darts)","decl":"@[simp]\ntheorem darts_append {u v w : V} (p : G.Walk u v) (p' : G.Walk v w) :\n    (p.append p').darts = p.darts ++ p'.darts := by\n  induction p <;> simp [*]\n\n"}
{"name":"SimpleGraph.Walk.darts_reverse","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ Eq p.reverse.darts (List.map SimpleGraph.Dart.symm p.darts).reverse","decl":"@[simp]\ntheorem darts_reverse {u v : V} (p : G.Walk u v) :\n    p.reverse.darts = (p.darts.map Dart.symm).reverse := by\n  induction p <;> simp [*, Sym2.eq_swap]\n\n"}
{"name":"SimpleGraph.Walk.mem_darts_reverse","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\nd : G.Dart\np : G.Walk u v\n⊢ Iff (Membership.mem p.reverse.darts d) (Membership.mem p.darts d.symm)","decl":"theorem mem_darts_reverse {u v : V} {d : G.Dart} {p : G.Walk u v} :\n    d ∈ p.reverse.darts ↔ d.symm ∈ p.darts := by simp\n\n"}
{"name":"SimpleGraph.Walk.cons_map_snd_darts","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ Eq (List.cons u (List.map (fun x => x.toProd.2) p.darts)) p.support","decl":"theorem cons_map_snd_darts {u v : V} (p : G.Walk u v) : (u :: p.darts.map (·.snd)) = p.support := by\n  induction p <;> simp! [*]\n\n"}
{"name":"SimpleGraph.Walk.map_snd_darts","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ Eq (List.map (fun x => x.toProd.2) p.darts) p.support.tail","decl":"theorem map_snd_darts {u v : V} (p : G.Walk u v) : p.darts.map (·.snd) = p.support.tail := by\n  simpa using congr_arg List.tail (cons_map_snd_darts p)\n\n"}
{"name":"SimpleGraph.Walk.map_fst_darts_append","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ Eq (HAppend.hAppend (List.map (fun x => x.toProd.1) p.darts) (List.cons v List.nil)) p.support","decl":"theorem map_fst_darts_append {u v : V} (p : G.Walk u v) :\n    p.darts.map (·.fst) ++ [v] = p.support := by\n  induction p <;> simp! [*]\n\n"}
{"name":"SimpleGraph.Walk.map_fst_darts","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ Eq (List.map (fun x => x.toProd.1) p.darts) p.support.dropLast","decl":"theorem map_fst_darts {u v : V} (p : G.Walk u v) : p.darts.map (·.fst) = p.support.dropLast := by\n  simpa! using congr_arg List.dropLast (map_fst_darts_append p)\n\n"}
{"name":"SimpleGraph.Walk.head_darts_fst","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\na b : V\np : G.Walk a b\nhp : Ne p.darts List.nil\n⊢ Eq (p.darts.head hp).toProd.1 a","decl":"@[simp]\ntheorem head_darts_fst {G : SimpleGraph V} {a b : V} (p : G.Walk a b) (hp : p.darts ≠ []) :\n    (p.darts.head hp).fst = a := by\n  cases p\n  · contradiction\n  · simp\n\n"}
{"name":"SimpleGraph.Walk.getLast_darts_snd","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\na b : V\np : G.Walk a b\nhp : Ne p.darts List.nil\n⊢ Eq (p.darts.getLast hp).toProd.2 b","decl":"@[simp]\ntheorem getLast_darts_snd {G : SimpleGraph V} {a b : V} (p : G.Walk a b) (hp : p.darts ≠ []) :\n    (p.darts.getLast hp).snd = b := by\n  rw [← List.getLast_map (f := fun x : G.Dart ↦ x.snd)]\n  · simp_rw [p.map_snd_darts, List.getLast_tail, p.getLast_support]\n  · simpa\n\n"}
{"name":"SimpleGraph.Walk.edges_nil","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\n⊢ Eq SimpleGraph.Walk.nil.edges List.nil","decl":"@[simp]\ntheorem edges_nil {u : V} : (nil : G.Walk u u).edges = [] := rfl\n\n"}
{"name":"SimpleGraph.Walk.edges_cons","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\nh : G.Adj u v\np : G.Walk v w\n⊢ Eq (SimpleGraph.Walk.cons h p).edges (List.cons (Sym2.mk { fst := u, snd := v }) p.edges)","decl":"@[simp]\ntheorem edges_cons {u v w : V} (h : G.Adj u v) (p : G.Walk v w) :\n    (cons h p).edges = s(u, v) :: p.edges := rfl\n\n"}
{"name":"SimpleGraph.Walk.edges_concat","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\nh : G.Adj v w\n⊢ Eq (p.concat h).edges (p.edges.concat (Sym2.mk { fst := v, snd := w }))","decl":"@[simp]\ntheorem edges_concat {u v w : V} (p : G.Walk u v) (h : G.Adj v w) :\n    (p.concat h).edges = p.edges.concat s(v, w) := by simp [edges]\n\n"}
{"name":"SimpleGraph.Walk.edges_copy","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v u' v' : V\np : G.Walk u v\nhu : Eq u u'\nhv : Eq v v'\n⊢ Eq (p.copy hu hv).edges p.edges","decl":"@[simp]\ntheorem edges_copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).edges = p.edges := by\n  subst_vars\n  rfl\n\n"}
{"name":"SimpleGraph.Walk.edges_append","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\np' : G.Walk v w\n⊢ Eq (p.append p').edges (HAppend.hAppend p.edges p'.edges)","decl":"@[simp]\ntheorem edges_append {u v w : V} (p : G.Walk u v) (p' : G.Walk v w) :\n    (p.append p').edges = p.edges ++ p'.edges := by simp [edges]\n\n"}
{"name":"SimpleGraph.Walk.edges_reverse","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ Eq p.reverse.edges p.edges.reverse","decl":"@[simp]\ntheorem edges_reverse {u v : V} (p : G.Walk u v) : p.reverse.edges = p.edges.reverse := by\n  simp [edges, List.map_reverse]\n\n"}
{"name":"SimpleGraph.Walk.length_support","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ Eq p.support.length (HAdd.hAdd p.length 1)","decl":"@[simp]\ntheorem length_support {u v : V} (p : G.Walk u v) : p.support.length = p.length + 1 := by\n  induction p <;> simp [*]\n\n"}
{"name":"SimpleGraph.Walk.length_darts","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ Eq p.darts.length p.length","decl":"@[simp]\ntheorem length_darts {u v : V} (p : G.Walk u v) : p.darts.length = p.length := by\n  induction p <;> simp [*]\n\n"}
{"name":"SimpleGraph.Walk.length_edges","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ Eq p.edges.length p.length","decl":"@[simp]\ntheorem length_edges {u v : V} (p : G.Walk u v) : p.edges.length = p.length := by simp [edges]\n\n"}
{"name":"SimpleGraph.Walk.dart_fst_mem_support_of_mem_darts","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nd : G.Dart\na✝ : Membership.mem p.darts d\n⊢ Membership.mem p.support d.toProd.1","decl":"theorem dart_fst_mem_support_of_mem_darts {u v : V} :\n    ∀ (p : G.Walk u v) {d : G.Dart}, d ∈ p.darts → d.fst ∈ p.support\n  | cons h p', d, hd => by\n    simp only [support_cons, darts_cons, List.mem_cons] at hd ⊢\n    rcases hd with (rfl | hd)\n    · exact Or.inl rfl\n    · exact Or.inr (dart_fst_mem_support_of_mem_darts _ hd)\n\n"}
{"name":"SimpleGraph.Walk.dart_snd_mem_support_of_mem_darts","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nd : G.Dart\nh : Membership.mem p.darts d\n⊢ Membership.mem p.support d.toProd.2","decl":"theorem dart_snd_mem_support_of_mem_darts {u v : V} (p : G.Walk u v) {d : G.Dart}\n    (h : d ∈ p.darts) : d.snd ∈ p.support := by\n  simpa using p.reverse.dart_fst_mem_support_of_mem_darts (by simp [h] : d.symm ∈ p.reverse.darts)\n\n"}
{"name":"SimpleGraph.Walk.fst_mem_support_of_mem_edges","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nt u v w : V\np : G.Walk v w\nhe : Membership.mem p.edges (Sym2.mk { fst := t, snd := u })\n⊢ Membership.mem p.support t","decl":"theorem fst_mem_support_of_mem_edges {t u v w : V} (p : G.Walk v w) (he : s(t, u) ∈ p.edges) :\n    t ∈ p.support := by\n  obtain ⟨d, hd, he⟩ := List.mem_map.mp he\n  rw [dart_edge_eq_mk'_iff'] at he\n  rcases he with (⟨rfl, rfl⟩ | ⟨rfl, rfl⟩)\n  · exact dart_fst_mem_support_of_mem_darts _ hd\n  · exact dart_snd_mem_support_of_mem_darts _ hd\n\n"}
{"name":"SimpleGraph.Walk.snd_mem_support_of_mem_edges","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nt u v w : V\np : G.Walk v w\nhe : Membership.mem p.edges (Sym2.mk { fst := t, snd := u })\n⊢ Membership.mem p.support u","decl":"theorem snd_mem_support_of_mem_edges {t u v w : V} (p : G.Walk v w) (he : s(t, u) ∈ p.edges) :\n    u ∈ p.support := by\n  rw [Sym2.eq_swap] at he\n  exact p.fst_mem_support_of_mem_edges he\n\n"}
{"name":"SimpleGraph.Walk.darts_nodup_of_support_nodup","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nh : p.support.Nodup\n⊢ p.darts.Nodup","decl":"theorem darts_nodup_of_support_nodup {u v : V} {p : G.Walk u v} (h : p.support.Nodup) :\n    p.darts.Nodup := by\n  induction p with\n  | nil => simp\n  | cons _ p' ih =>\n    simp only [darts_cons, support_cons, List.nodup_cons] at h ⊢\n    exact ⟨fun h' => h.1 (dart_fst_mem_support_of_mem_darts p' h'), ih h.2⟩\n\n"}
{"name":"SimpleGraph.Walk.edges_nodup_of_support_nodup","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nh : p.support.Nodup\n⊢ p.edges.Nodup","decl":"theorem edges_nodup_of_support_nodup {u v : V} {p : G.Walk u v} (h : p.support.Nodup) :\n    p.edges.Nodup := by\n  induction p with\n  | nil => simp\n  | cons _ p' ih =>\n    simp only [edges_cons, support_cons, List.nodup_cons] at h ⊢\n    exact ⟨fun h' => h.1 (fst_mem_support_of_mem_edges p' h'), ih h.2⟩\n\n"}
{"name":"SimpleGraph.Walk.nodup_tail_support_reverse","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\np : G.Walk u u\n⊢ Iff p.reverse.support.tail.Nodup p.support.tail.Nodup","decl":"theorem nodup_tail_support_reverse {u : V} {p : G.Walk u u} :\n    p.reverse.support.tail.Nodup ↔ p.support.tail.Nodup := by\n  rw [Walk.support_reverse]\n  refine List.nodup_tail_reverse p.support ?h\n  rw [← getVert_eq_support_get? _ (by omega), List.getLast?_eq_getElem?,\n    ← getVert_eq_support_get? _ (by rw [Walk.length_support]; omega)]\n  aesop\n\n"}
{"name":"SimpleGraph.Walk.edges_injective","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\n⊢ Function.Injective SimpleGraph.Walk.edges","decl":"theorem edges_injective {u v : V} : Function.Injective (Walk.edges : G.Walk u v → List (Sym2 V))\n  | .nil, .nil, _ => rfl\n  | .nil, .cons _ _, h => by simp at h\n  | .cons _ _, .nil, h => by simp at h\n  | .cons' u v c h₁ w₁, .cons' _ v' _ h₂ w₂, h => by\n    have h₃ : u ≠ v' := by rintro rfl; exact G.loopless _ h₂\n    obtain ⟨rfl, h₃⟩ : v = v' ∧ w₁.edges = w₂.edges := by simpa [h₁, h₃] using h\n    obtain rfl := Walk.edges_injective h₃\n    rfl\n\n"}
{"name":"SimpleGraph.Walk.darts_injective","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\n⊢ Function.Injective SimpleGraph.Walk.darts","decl":"theorem darts_injective {u v : V} : Function.Injective (Walk.darts : G.Walk u v → List G.Dart) :=\n  edges_injective.of_comp\n\n"}
{"name":"SimpleGraph.Walk.nil_nil","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\n⊢ SimpleGraph.Walk.nil.Nil","decl":"@[simp] lemma nil_nil : (nil : G.Walk u u).Nil := Nil.nil\n\n"}
{"name":"SimpleGraph.Walk.not_nil_cons","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\nh : G.Adj u v\np : G.Walk v w\n⊢ Not (SimpleGraph.Walk.cons h p).Nil","decl":"@[simp] lemma not_nil_cons {h : G.Adj u v} {p : G.Walk v w} : ¬ (cons h p).Nil := nofun\n\n"}
{"name":"SimpleGraph.Walk.Nil.eq","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\np : G.Walk v w\na✝ : p.Nil\n⊢ Eq v w","decl":"protected lemma Nil.eq {p : G.Walk v w} : p.Nil → v = w | .nil => rfl\n\n"}
{"name":"SimpleGraph.Walk.not_nil_of_ne","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\np : G.Walk v w\na✝ : Ne v w\n⊢ Not p.Nil","decl":"lemma not_nil_of_ne {p : G.Walk v w} : v ≠ w → ¬ p.Nil := mt Nil.eq\n\n"}
{"name":"SimpleGraph.Walk.nil_iff_support_eq","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\np : G.Walk v w\n⊢ Iff p.Nil (Eq p.support (List.cons v List.nil))","decl":"lemma nil_iff_support_eq {p : G.Walk v w} : p.Nil ↔ p.support = [v] := by\n  cases p <;> simp\n\n"}
{"name":"SimpleGraph.Walk.nil_iff_length_eq","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\np : G.Walk v w\n⊢ Iff p.Nil (Eq p.length 0)","decl":"lemma nil_iff_length_eq {p : G.Walk v w} : p.Nil ↔ p.length = 0 := by\n  cases p <;> simp\n\n"}
{"name":"SimpleGraph.Walk.not_nil_iff_lt_length","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\np : G.Walk v w\n⊢ Iff (Not p.Nil) (LT.lt 0 p.length)","decl":"lemma not_nil_iff_lt_length {p : G.Walk v w} : ¬ p.Nil ↔ 0 < p.length := by\n  cases p <;> simp\n\n"}
{"name":"SimpleGraph.Walk.not_nil_iff","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\np : G.Walk v w\n⊢ Iff (Not p.Nil) (Exists fun u => Exists fun h => Exists fun q => Eq p (SimpleGraph.Walk.cons h q))","decl":"lemma not_nil_iff {p : G.Walk v w} :\n    ¬ p.Nil ↔ ∃ (u : V) (h : G.Adj v u) (q : G.Walk u w), p = cons h q := by\n  cases p <;> simp [*]\n\n"}
{"name":"SimpleGraph.Walk.nil_iff_eq_nil","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nv : V\np : G.Walk v v\n⊢ Iff p.Nil (Eq p SimpleGraph.Walk.nil)","decl":"/-- A walk with its endpoints defeq is `Nil` if and only if it is equal to `nil`. -/\nlemma nil_iff_eq_nil : ∀ {p : G.Walk v v}, p.Nil ↔ p = nil\n  | .nil | .cons _ _ => by simp\n\n"}
{"name":"SimpleGraph.Walk.Nil.eq_nil","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nv : V\np : G.Walk v v\na✝ : p.Nil\n⊢ Eq p SimpleGraph.Walk.nil","decl":"alias ⟨Nil.eq_nil, _⟩ := nil_iff_eq_nil\n\n"}
{"name":"SimpleGraph.Walk.notNilRec_cons","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\nmotive : {u w : V} → (p : G.Walk u w) → Not p.Nil → Sort u_1\ncons : {u v w : V} → (h : G.Adj u v) → (q : G.Walk v w) → motive (SimpleGraph.Walk.cons h q) ⋯\nh' : G.Adj u v\nq' : G.Walk v w\n⊢ Eq (SimpleGraph.Walk.notNilRec (fun {u v w} => cons) (SimpleGraph.Walk.cons h' q') ⋯) (cons h' q')","decl":"@[simp]\nlemma notNilRec_cons {motive : {u w : V} → (p : G.Walk u w) → ¬ p.Nil → Sort*}\n    (cons : {u v w : V} → (h : G.Adj u v) → (q : G.Walk v w) →\n    motive (q.cons h) Walk.not_nil_cons) (h' : G.Adj u v) (q' : G.Walk v w) :\n    @Walk.notNilRec _ _ _ _ _ cons _ _ = cons h' q' := by rfl\n\n"}
{"name":"SimpleGraph.Walk.adj_snd","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\np : G.Walk v w\nhp : Not p.Nil\n⊢ G.Adj v p.snd","decl":"@[simp] lemma adj_snd {p : G.Walk v w} (hp : ¬ p.Nil) :\n    G.Adj v p.snd := by\n  simpa using adj_getVert_succ p (by simpa [not_nil_iff_lt_length] using hp : 0 < p.length)\n\n"}
{"name":"SimpleGraph.Walk.snd_cons","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\nq : G.Walk v w\nhadj : G.Adj u v\n⊢ Eq (SimpleGraph.Walk.cons hadj q).snd v","decl":"lemma snd_cons {u v w} (q : G.Walk v w) (hadj : G.Adj u v) :\n    (q.cons hadj).snd = v := by simp\n\n"}
{"name":"SimpleGraph.Walk.penultimate_cons_nil","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\nh : G.Adj u v\n⊢ Eq (SimpleGraph.Walk.cons h SimpleGraph.Walk.nil).penultimate u","decl":"@[simp]\nlemma penultimate_cons_nil (h : G.Adj u v) : (cons h nil).penultimate = u := rfl\n\n"}
{"name":"SimpleGraph.Walk.penultimate_cons_cons","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w w' : V\nh : G.Adj u v\nh₂ : G.Adj v w\np : G.Walk w w'\n⊢ Eq (SimpleGraph.Walk.cons h (SimpleGraph.Walk.cons h₂ p)).penultimate (SimpleGraph.Walk.cons h₂ p).penultimate","decl":"@[simp]\nlemma penultimate_cons_cons {w'} (h : G.Adj u v) (h₂ : G.Adj v w) (p : G.Walk w w') :\n    (cons h (cons h₂ p)).penultimate = (cons h₂ p).penultimate := rfl\n\n"}
{"name":"SimpleGraph.Walk.penultimate_cons_of_not_nil","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\nh : G.Adj u v\np : G.Walk v w\nhp : Not p.Nil\n⊢ Eq (SimpleGraph.Walk.cons h p).penultimate p.penultimate","decl":"lemma penultimate_cons_of_not_nil (h : G.Adj u v) (p : G.Walk v w) (hp : ¬ p.Nil) :\n    (cons h p).penultimate = p.penultimate :=\n  p.notNilRec (by simp) hp h\n\n"}
{"name":"SimpleGraph.Walk.penultimate_concat","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nt u v : V\np : G.Walk u v\nh : G.Adj v t\n⊢ Eq (p.concat h).penultimate v","decl":"@[simp]\nlemma penultimate_concat {t u v} (p : G.Walk u v) (h : G.Adj v t) :\n    (p.concat h).penultimate = v := by simp [penultimate, concat_eq_append, getVert_append]\n\n"}
{"name":"SimpleGraph.Walk.adj_penultimate","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\np : G.Walk v w\nhp : Not p.Nil\n⊢ G.Adj p.penultimate w","decl":"@[simp]\nlemma adj_penultimate {p : G.Walk v w} (hp : ¬ p.Nil) :\n    G.Adj p.penultimate w := by\n  conv => rhs; rw [← getVert_length p]\n  rw [nil_iff_length_eq] at hp\n  convert adj_getVert_succ _ _ <;> omega\n\n"}
{"name":"SimpleGraph.Walk.tail_nil","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nv : V\n⊢ Eq SimpleGraph.Walk.nil.tail SimpleGraph.Walk.nil","decl":"@[simp]\nlemma tail_nil : (@nil _ G v).tail = .nil := rfl\n\n"}
{"name":"SimpleGraph.Walk.tail_cons_nil","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\nh : G.Adj u v\n⊢ Eq (SimpleGraph.Walk.cons h SimpleGraph.Walk.nil).tail SimpleGraph.Walk.nil","decl":"@[simp]\nlemma tail_cons_nil (h : G.Adj u v) : (Walk.cons h .nil).tail = .nil := rfl\n\n"}
{"name":"SimpleGraph.Walk.tail_cons_eq","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\nh : G.Adj u v\np : G.Walk v w\n⊢ Eq (SimpleGraph.Walk.cons h p).tail (p.copy ⋯ ⋯)","decl":"lemma tail_cons_eq (h : G.Adj u v) (p : G.Walk v w) :\n    (p.cons h).tail = p.copy (getVert_zero p).symm rfl := by\n  match p with\n  | .nil => rfl\n  | .cons h q => rfl\n\n"}
{"name":"SimpleGraph.Walk.firstDart_toProd","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\np : G.Walk v w\nhp : Not p.Nil\n⊢ Eq (p.firstDart hp).toProd { fst := v, snd := p.snd }","decl":"/-- The first dart of a walk. -/\n@[simps]\ndef firstDart (p : G.Walk v w) (hp : ¬ p.Nil) : G.Dart where\n  fst := v\n  snd := p.snd\n  adj := p.adj_snd hp\n\n"}
{"name":"SimpleGraph.Walk.lastDart_toProd","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\np : G.Walk v w\nhp : Not p.Nil\n⊢ Eq (p.lastDart hp).toProd { fst := p.penultimate, snd := w }","decl":"/-- The last dart of a walk. -/\n@[simps]\ndef lastDart (p : G.Walk v w) (hp : ¬ p.Nil) : G.Dart where\n  fst := p.penultimate\n  snd := w\n  adj := p.adj_penultimate hp\n\n"}
{"name":"SimpleGraph.Walk.edge_firstDart","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\np : G.Walk v w\nhp : Not p.Nil\n⊢ Eq (p.firstDart hp).edge (Sym2.mk { fst := v, snd := p.snd })","decl":"lemma edge_firstDart (p : G.Walk v w) (hp : ¬ p.Nil) :\n    (p.firstDart hp).edge = s(v, p.snd) := rfl\n\n"}
{"name":"SimpleGraph.Walk.edge_lastDart","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\np : G.Walk v w\nhp : Not p.Nil\n⊢ Eq (p.lastDart hp).edge (Sym2.mk { fst := p.penultimate, snd := w })","decl":"lemma edge_lastDart (p : G.Walk v w) (hp : ¬ p.Nil) :\n    (p.lastDart hp).edge = s(p.penultimate, w) := rfl\n\n"}
{"name":"SimpleGraph.Walk.cons_tail_eq","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nx y : V\np : G.Walk x y\nhp : Not p.Nil\n⊢ Eq (SimpleGraph.Walk.cons ⋯ p.tail) p","decl":"lemma cons_tail_eq (p : G.Walk x y) (hp : ¬ p.Nil) :\n    cons (p.adj_snd hp) p.tail = p := by\n  cases p with\n  | nil => simp only [nil_nil, not_true_eq_false] at hp\n  | cons h q =>\n    simp only [getVert_cons_succ, tail_cons_eq, cons_copy, copy_rfl_rfl]\n\n"}
{"name":"SimpleGraph.Walk.cons_support_tail","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nx y : V\np : G.Walk x y\nhp : Not p.Nil\n⊢ Eq (List.cons x p.tail.support) p.support","decl":"@[simp] lemma cons_support_tail (p : G.Walk x y) (hp : ¬p.Nil) :\n    x :: p.tail.support = p.support := by\n  rw [← support_cons, cons_tail_eq _ hp]\n\n"}
{"name":"SimpleGraph.Walk.length_tail_add_one","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nx y : V\np : G.Walk x y\nhp : Not p.Nil\n⊢ Eq (HAdd.hAdd p.tail.length 1) p.length","decl":"@[simp] lemma length_tail_add_one {p : G.Walk x y} (hp : ¬ p.Nil) :\n    p.tail.length + 1 = p.length := by\n  rw [← length_cons, cons_tail_eq _ hp]\n\n"}
{"name":"SimpleGraph.Walk.Nil.tail","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\np : G.Walk v w\nhp : p.Nil\n⊢ p.tail.Nil","decl":"protected lemma Nil.tail {p : G.Walk v w} (hp : p.Nil) : p.tail.Nil := by cases p <;> aesop\n\n"}
{"name":"SimpleGraph.Walk.not_nil_of_tail_not_nil","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\np : G.Walk v w\nhp : Not p.tail.Nil\n⊢ Not p.Nil","decl":"lemma not_nil_of_tail_not_nil {p : G.Walk v w} (hp : ¬ p.tail.Nil) : ¬ p.Nil := mt Nil.tail hp\n\n"}
{"name":"SimpleGraph.Walk.nil_copy","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nx y x' y' : V\np : G.Walk x y\nhx : Eq x x'\nhy : Eq y y'\n⊢ Eq (p.copy hx hy).Nil p.Nil","decl":"@[simp] lemma nil_copy {x' y' : V} {p : G.Walk x y} (hx : x = x') (hy : y = y') :\n    (p.copy hx hy).Nil = p.Nil := by\n  subst_vars; rfl\n\n"}
{"name":"SimpleGraph.Walk.support_tail","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nv : V\np : G.Walk v v\nhp : Not p.Nil\n⊢ Eq p.tail.support p.support.tail","decl":"@[simp] lemma support_tail (p : G.Walk v v) (hp : ¬ p.Nil) :\n    p.tail.support = p.support.tail := by\n  rw [← cons_support_tail p hp, List.tail_cons]\n\n"}
{"name":"SimpleGraph.Walk.tail_cons","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nt u v : V\np : G.Walk u v\nh : G.Adj t u\n⊢ Eq (SimpleGraph.Walk.cons h p).tail (p.copy ⋯ ⋯)","decl":"@[simp]\nlemma tail_cons {t u v} (p : G.Walk u v) (h : G.Adj t u) :\n    (p.cons h).tail = p.copy (getVert_zero p).symm rfl := by\n  match p with\n  | .nil => rfl\n  | .cons h q => rfl\n\n"}
{"name":"SimpleGraph.Walk.support_tail_of_not_nil","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nhnp : Not p.Nil\n⊢ Eq p.tail.support p.support.tail","decl":"lemma support_tail_of_not_nil (p : G.Walk u v) (hnp : ¬p.Nil) :\n    p.tail.support = p.support.tail := by\n  match p with\n  | .nil => simp only [nil_nil, not_true_eq_false] at hnp\n  | .cons h q =>\n    simp only [tail_cons, getVert_cons_succ, support_copy, support_cons, List.tail_cons]\n\n"}
{"name":"SimpleGraph.Walk.take_spec","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v w : V\np : G.Walk v w\nh : Membership.mem p.support u\n⊢ Eq ((p.takeUntil u h).append (p.dropUntil u h)) p","decl":"/-- The `takeUntil` and `dropUntil` functions split a walk into two pieces.\nThe lemma `SimpleGraph.Walk.count_support_takeUntil_eq_one` specifies where this split occurs. -/\n@[simp]\ntheorem take_spec {u v w : V} (p : G.Walk v w) (h : u ∈ p.support) :\n    (p.takeUntil u h).append (p.dropUntil u h) = p := by\n  induction p\n  · rw [mem_support_nil_iff] at h\n    subst u\n    rfl\n  · cases h\n    · simp!\n    · simp! only\n      split_ifs with h' <;> subst_vars <;> simp [*]\n\n"}
{"name":"SimpleGraph.Walk.mem_support_iff_exists_append","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\n⊢ Iff (Membership.mem p.support w) (Exists fun q => Exists fun r => Eq p (q.append r))","decl":"theorem mem_support_iff_exists_append {V : Type u} {G : SimpleGraph V} {u v w : V}\n    {p : G.Walk u v} : w ∈ p.support ↔ ∃ (q : G.Walk u w) (r : G.Walk w v), p = q.append r := by\n  classical\n  constructor\n  · exact fun h => ⟨_, _, (p.take_spec h).symm⟩\n  · rintro ⟨q, r, rfl⟩\n    simp only [mem_support_append_iff, end_mem_support, start_mem_support, or_self_iff]\n\n"}
{"name":"SimpleGraph.Walk.count_support_takeUntil_eq_one","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v w : V\np : G.Walk v w\nh : Membership.mem p.support u\n⊢ Eq (List.count u (p.takeUntil u h).support) 1","decl":"@[simp]\ntheorem count_support_takeUntil_eq_one {u v w : V} (p : G.Walk v w) (h : u ∈ p.support) :\n    (p.takeUntil u h).support.count u = 1 := by\n  induction p\n  · rw [mem_support_nil_iff] at h\n    subst u\n    simp!\n  · cases h\n    · simp!\n    · simp! only\n      split_ifs with h' <;> rw [eq_comm] at h' <;> subst_vars <;> simp! [*, List.count_cons]\n\n"}
{"name":"SimpleGraph.Walk.count_edges_takeUntil_le_one","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v w : V\np : G.Walk v w\nh : Membership.mem p.support u\nx : V\n⊢ LE.le (List.count (Sym2.mk { fst := u, snd := x }) (p.takeUntil u h).edges) 1","decl":"theorem count_edges_takeUntil_le_one {u v w : V} (p : G.Walk v w) (h : u ∈ p.support) (x : V) :\n    (p.takeUntil u h).edges.count s(u, x) ≤ 1 := by\n  induction' p with u' u' v' w' ha p' ih\n  · rw [mem_support_nil_iff] at h\n    subst u\n    simp!\n  · cases h\n    · simp!\n    · simp! only\n      split_ifs with h'\n      · subst h'\n        simp\n      · rw [edges_cons, List.count_cons]\n        split_ifs with h''\n        · simp only [beq_iff_eq, Sym2.eq, Sym2.rel_iff'] at h''\n          obtain ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩ := h''\n          · exact (h' rfl).elim\n          · cases p' <;> simp!\n        · apply ih\n\n"}
{"name":"SimpleGraph.Walk.takeUntil_copy","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v w v' w' : V\np : G.Walk v w\nhv : Eq v v'\nhw : Eq w w'\nh : Membership.mem (p.copy hv hw).support u\n⊢ Eq ((p.copy hv hw).takeUntil u h) ((p.takeUntil u ⋯).copy hv ⋯)","decl":"@[simp]\ntheorem takeUntil_copy {u v w v' w'} (p : G.Walk v w) (hv : v = v') (hw : w = w')\n    (h : u ∈ (p.copy hv hw).support) :\n    (p.copy hv hw).takeUntil u h = (p.takeUntil u (by subst_vars; exact h)).copy hv rfl := by\n  subst_vars\n  rfl\n\n"}
{"name":"SimpleGraph.Walk.dropUntil_copy","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v w v' w' : V\np : G.Walk v w\nhv : Eq v v'\nhw : Eq w w'\nh : Membership.mem (p.copy hv hw).support u\n⊢ Eq ((p.copy hv hw).dropUntil u h) ((p.dropUntil u ⋯).copy ⋯ hw)","decl":"@[simp]\ntheorem dropUntil_copy {u v w v' w'} (p : G.Walk v w) (hv : v = v') (hw : w = w')\n    (h : u ∈ (p.copy hv hw).support) :\n    (p.copy hv hw).dropUntil u h = (p.dropUntil u (by subst_vars; exact h)).copy rfl hw := by\n  subst_vars\n  rfl\n\n"}
{"name":"SimpleGraph.Walk.support_takeUntil_subset","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v w : V\np : G.Walk v w\nh : Membership.mem p.support u\n⊢ HasSubset.Subset (p.takeUntil u h).support p.support","decl":"theorem support_takeUntil_subset {u v w : V} (p : G.Walk v w) (h : u ∈ p.support) :\n    (p.takeUntil u h).support ⊆ p.support := fun x hx => by\n  rw [← take_spec p h, mem_support_append_iff]\n  exact Or.inl hx\n\n"}
{"name":"SimpleGraph.Walk.support_dropUntil_subset","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v w : V\np : G.Walk v w\nh : Membership.mem p.support u\n⊢ HasSubset.Subset (p.dropUntil u h).support p.support","decl":"theorem support_dropUntil_subset {u v w : V} (p : G.Walk v w) (h : u ∈ p.support) :\n    (p.dropUntil u h).support ⊆ p.support := fun x hx => by\n  rw [← take_spec p h, mem_support_append_iff]\n  exact Or.inr hx\n\n"}
{"name":"SimpleGraph.Walk.darts_takeUntil_subset","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v w : V\np : G.Walk v w\nh : Membership.mem p.support u\n⊢ HasSubset.Subset (p.takeUntil u h).darts p.darts","decl":"theorem darts_takeUntil_subset {u v w : V} (p : G.Walk v w) (h : u ∈ p.support) :\n    (p.takeUntil u h).darts ⊆ p.darts := fun x hx => by\n  rw [← take_spec p h, darts_append, List.mem_append]\n  exact Or.inl hx\n\n"}
{"name":"SimpleGraph.Walk.darts_dropUntil_subset","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v w : V\np : G.Walk v w\nh : Membership.mem p.support u\n⊢ HasSubset.Subset (p.dropUntil u h).darts p.darts","decl":"theorem darts_dropUntil_subset {u v w : V} (p : G.Walk v w) (h : u ∈ p.support) :\n    (p.dropUntil u h).darts ⊆ p.darts := fun x hx => by\n  rw [← take_spec p h, darts_append, List.mem_append]\n  exact Or.inr hx\n\n"}
{"name":"SimpleGraph.Walk.edges_takeUntil_subset","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v w : V\np : G.Walk v w\nh : Membership.mem p.support u\n⊢ HasSubset.Subset (p.takeUntil u h).edges p.edges","decl":"theorem edges_takeUntil_subset {u v w : V} (p : G.Walk v w) (h : u ∈ p.support) :\n    (p.takeUntil u h).edges ⊆ p.edges :=\n  List.map_subset _ (p.darts_takeUntil_subset h)\n\n"}
{"name":"SimpleGraph.Walk.edges_dropUntil_subset","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v w : V\np : G.Walk v w\nh : Membership.mem p.support u\n⊢ HasSubset.Subset (p.dropUntil u h).edges p.edges","decl":"theorem edges_dropUntil_subset {u v w : V} (p : G.Walk v w) (h : u ∈ p.support) :\n    (p.dropUntil u h).edges ⊆ p.edges :=\n  List.map_subset _ (p.darts_dropUntil_subset h)\n\n"}
{"name":"SimpleGraph.Walk.length_takeUntil_le","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v w : V\np : G.Walk v w\nh : Membership.mem p.support u\n⊢ LE.le (p.takeUntil u h).length p.length","decl":"theorem length_takeUntil_le {u v w : V} (p : G.Walk v w) (h : u ∈ p.support) :\n    (p.takeUntil u h).length ≤ p.length := by\n  have := congr_arg Walk.length (p.take_spec h)\n  rw [length_append] at this\n  exact Nat.le.intro this\n\n"}
{"name":"SimpleGraph.Walk.length_dropUntil_le","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v w : V\np : G.Walk v w\nh : Membership.mem p.support u\n⊢ LE.le (p.dropUntil u h).length p.length","decl":"theorem length_dropUntil_le {u v w : V} (p : G.Walk v w) (h : u ∈ p.support) :\n    (p.dropUntil u h).length ≤ p.length := by\n  have := congr_arg Walk.length (p.take_spec h)\n  rw [length_append, add_comm] at this\n  exact Nat.le.intro this\n\n"}
{"name":"SimpleGraph.Walk.support_rotate","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v : V\nc : G.Walk v v\nh : Membership.mem c.support u\n⊢ (c.rotate h).support.tail.IsRotated c.support.tail","decl":"@[simp]\ntheorem support_rotate {u v : V} (c : G.Walk v v) (h : u ∈ c.support) :\n    (c.rotate h).support.tail ~r c.support.tail := by\n  simp only [rotate, tail_support_append]\n  apply List.IsRotated.trans List.isRotated_append\n  rw [← tail_support_append, take_spec]\n\n"}
{"name":"SimpleGraph.Walk.rotate_darts","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v : V\nc : G.Walk v v\nh : Membership.mem c.support u\n⊢ (c.rotate h).darts.IsRotated c.darts","decl":"theorem rotate_darts {u v : V} (c : G.Walk v v) (h : u ∈ c.support) :\n    (c.rotate h).darts ~r c.darts := by\n  simp only [rotate, darts_append]\n  apply List.IsRotated.trans List.isRotated_append\n  rw [← darts_append, take_spec]\n\n"}
{"name":"SimpleGraph.Walk.rotate_edges","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v : V\nc : G.Walk v v\nh : Membership.mem c.support u\n⊢ (c.rotate h).edges.IsRotated c.edges","decl":"theorem rotate_edges {u v : V} (c : G.Walk v v) (h : u ∈ c.support) :\n    (c.rotate h).edges ~r c.edges :=\n  (rotate_darts c h).map _\n\n"}
{"name":"SimpleGraph.Walk.exists_boundary_dart","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nS : Set V\nuS : Membership.mem S u\nvS : Not (Membership.mem S v)\n⊢ Exists fun d => And (Membership.mem p.darts d) (And (Membership.mem S d.toProd.1) (Not (Membership.mem S d.toProd.2)))","decl":"/-- Given a set `S` and a walk `w` from `u` to `v` such that `u ∈ S` but `v ∉ S`,\nthere exists a dart in the walk whose start is in `S` but whose end is not. -/\ntheorem exists_boundary_dart {u v : V} (p : G.Walk u v) (S : Set V) (uS : u ∈ S) (vS : v ∉ S) :\n    ∃ d : G.Dart, d ∈ p.darts ∧ d.fst ∈ S ∧ d.snd ∉ S := by\n  induction' p with _ x y w a p' ih\n  · cases vS uS\n  · by_cases h : y ∈ S\n    · obtain ⟨d, hd, hcd⟩ := ih h vS\n      exact ⟨d, List.Mem.tail _ hd, hcd⟩\n    · exact ⟨⟨(x, y), a⟩, List.Mem.head _, uS, h⟩\n\n"}
{"name":"SimpleGraph.Walk.getVert_copy","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w x : V\np : G.Walk u v\ni : Nat\nh : Eq u w\nh' : Eq v x\n⊢ Eq ((p.copy h h').getVert i) (p.getVert i)","decl":"@[simp] lemma getVert_copy {u v w x : V} (p : G.Walk u v) (i : ℕ) (h : u = w) (h' : v = x) :\n    (p.copy h h').getVert i = p.getVert i := by\n  subst_vars\n  rfl\n\n"}
{"name":"SimpleGraph.Walk.getVert_tail","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\nn : Nat\np : G.Walk u v\n⊢ Eq (p.tail.getVert n) (p.getVert (HAdd.hAdd n 1))","decl":"@[simp] lemma getVert_tail {u v n} (p : G.Walk u v) :\n    p.tail.getVert n = p.getVert (n + 1) := by\n  match p with\n  | .nil => rfl\n  | .cons h q =>\n    simp only [getVert_cons_succ, tail_cons_eq, getVert_cons]\n    exact getVert_copy q n (getVert_zero q).symm rfl\n\n"}
{"name":"SimpleGraph.Walk.mem_support_iff_exists_getVert","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk v w\n⊢ Iff (Membership.mem p.support u) (Exists fun n => And (Eq (p.getVert n) u) (LE.le n p.length))","decl":"/-- Given a walk `w` and a node in the support, there exists a natural `n`, such that given node\nis the `n`-th node (zero-indexed) in the walk. In addition, `n` is at most the length of the path.\nDue to the definition of `getVert` it would otherwise be legal to return a larger `n` for the last\nnode. -/\ntheorem mem_support_iff_exists_getVert {u v w : V} {p : G.Walk v w} :\n    u ∈ p.support ↔ ∃ n, p.getVert n = u ∧ n ≤ p.length := by\n  constructor\n  · intro h\n    obtain ⟨q, r, hqr⟩ := SimpleGraph.Walk.mem_support_iff_exists_append.mp h\n    use q.length\n    rw [hqr]\n    rw [Walk.getVert_append]\n    simp only [lt_self_iff_false, ↓reduceIte, Nat.sub_self, getVert_zero, length_append,\n      Nat.le_add_right, and_self]\n  · rintro ⟨n, hn⟩\n    rw [SimpleGraph.Walk.mem_support_iff]\n    cases n with\n    | zero =>\n      rw [getVert_zero] at hn\n      left\n      exact hn.1.symm\n    | succ n =>\n      right\n      have hnp : ¬ p.Nil := by\n        rw [nil_iff_length_eq]\n        omega\n      rw [← support_tail_of_not_nil _ hnp, mem_support_iff_exists_getVert]\n      use n\n      rwa [getVert_tail, ← Nat.add_one_le_add_one_iff, length_tail_add_one hnp]\ntermination_by p.length\ndecreasing_by\n· simp_wf\n  rw [Nat.lt_iff_add_one_le]\n  rw [length_tail_add_one hnp]\n\n"}
{"name":"SimpleGraph.Walk.map_nil","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G.Hom G'\nu : V\n⊢ Eq (SimpleGraph.Walk.map f SimpleGraph.Walk.nil) SimpleGraph.Walk.nil","decl":"@[simp]\ntheorem map_nil : (nil : G.Walk u u).map f = nil := rfl\n\n"}
{"name":"SimpleGraph.Walk.map_cons","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G.Hom G'\nu v : V\np : G.Walk u v\nw : V\nh : G.Adj w u\n⊢ Eq (SimpleGraph.Walk.map f (SimpleGraph.Walk.cons h p)) (SimpleGraph.Walk.cons ⋯ (SimpleGraph.Walk.map f p))","decl":"@[simp]\ntheorem map_cons {w : V} (h : G.Adj w u) : (cons h p).map f = cons (f.map_adj h) (p.map f) := rfl\n\n"}
{"name":"SimpleGraph.Walk.map_copy","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G.Hom G'\nu v u' v' : V\np : G.Walk u v\nhu : Eq u u'\nhv : Eq v v'\n⊢ Eq (SimpleGraph.Walk.map f (p.copy hu hv)) ((SimpleGraph.Walk.map f p).copy ⋯ ⋯)","decl":"@[simp]\ntheorem map_copy (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).map f = (p.map f).copy (hu ▸ rfl) (hv ▸ rfl) := by\n  subst_vars\n  rfl\n\n"}
{"name":"SimpleGraph.Walk.map_id","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ Eq (SimpleGraph.Walk.map SimpleGraph.Hom.id p) p","decl":"@[simp]\ntheorem map_id (p : G.Walk u v) : p.map Hom.id = p := by\n  induction p with\n  | nil => rfl\n  | cons _ p' ih => simp [ih]\n\n"}
{"name":"SimpleGraph.Walk.map_map","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nV' : Type v\nV'' : Type w\nG : SimpleGraph V\nG' : SimpleGraph V'\nG'' : SimpleGraph V''\nf : G.Hom G'\nf' : G'.Hom G''\nu v : V\np : G.Walk u v\n⊢ Eq (SimpleGraph.Walk.map f' (SimpleGraph.Walk.map f p)) (SimpleGraph.Walk.map (f'.comp f) p)","decl":"@[simp]\ntheorem map_map : (p.map f).map f' = p.map (f'.comp f) := by\n  induction p with\n  | nil => rfl\n  | cons _ _ ih => simp [ih]\n\n"}
{"name":"SimpleGraph.Walk.map_eq_of_eq","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nu v : V\np : G.Walk u v\nf f' : G.Hom G'\nh : Eq f f'\n⊢ Eq (SimpleGraph.Walk.map f p) ((SimpleGraph.Walk.map f' p).copy ⋯ ⋯)","decl":"/-- Unlike categories, for graphs vertex equality is an important notion, so needing to be able to\nwork with equality of graph homomorphisms is a necessary evil. -/\ntheorem map_eq_of_eq {f : G →g G'} (f' : G →g G') (h : f = f') :\n    p.map f = (p.map f').copy (h ▸ rfl) (h ▸ rfl) := by\n  subst_vars\n  rfl\n\n"}
{"name":"SimpleGraph.Walk.map_eq_nil_iff","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G.Hom G'\nu : V\np : G.Walk u u\n⊢ Iff (Eq (SimpleGraph.Walk.map f p) SimpleGraph.Walk.nil) (Eq p SimpleGraph.Walk.nil)","decl":"@[simp]\ntheorem map_eq_nil_iff {p : G.Walk u u} : p.map f = nil ↔ p = nil := by cases p <;> simp\n\n"}
{"name":"SimpleGraph.Walk.length_map","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G.Hom G'\nu v : V\np : G.Walk u v\n⊢ Eq (SimpleGraph.Walk.map f p).length p.length","decl":"@[simp]\ntheorem length_map : (p.map f).length = p.length := by induction p <;> simp [*]\n\n"}
{"name":"SimpleGraph.Walk.map_append","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G.Hom G'\nu v w : V\np : G.Walk u v\nq : G.Walk v w\n⊢ Eq (SimpleGraph.Walk.map f (p.append q)) ((SimpleGraph.Walk.map f p).append (SimpleGraph.Walk.map f q))","decl":"theorem map_append {u v w : V} (p : G.Walk u v) (q : G.Walk v w) :\n    (p.append q).map f = (p.map f).append (q.map f) := by induction p <;> simp [*]\n\n"}
{"name":"SimpleGraph.Walk.reverse_map","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G.Hom G'\nu v : V\np : G.Walk u v\n⊢ Eq (SimpleGraph.Walk.map f p).reverse (SimpleGraph.Walk.map f p.reverse)","decl":"@[simp]\ntheorem reverse_map : (p.map f).reverse = p.reverse.map f := by induction p <;> simp [map_append, *]\n\n"}
{"name":"SimpleGraph.Walk.support_map","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G.Hom G'\nu v : V\np : G.Walk u v\n⊢ Eq (SimpleGraph.Walk.map f p).support (List.map (⇑f) p.support)","decl":"@[simp]\ntheorem support_map : (p.map f).support = p.support.map f := by induction p <;> simp [*]\n\n"}
{"name":"SimpleGraph.Walk.darts_map","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G.Hom G'\nu v : V\np : G.Walk u v\n⊢ Eq (SimpleGraph.Walk.map f p).darts (List.map f.mapDart p.darts)","decl":"@[simp]\ntheorem darts_map : (p.map f).darts = p.darts.map f.mapDart := by induction p <;> simp [*]\n\n"}
{"name":"SimpleGraph.Walk.edges_map","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G.Hom G'\nu v : V\np : G.Walk u v\n⊢ Eq (SimpleGraph.Walk.map f p).edges (List.map (Sym2.map ⇑f) p.edges)","decl":"@[simp]\ntheorem edges_map : (p.map f).edges = p.edges.map (Sym2.map f) := by\n  induction p with\n  | nil => rfl\n  | cons _ _ ih =>\n    simp only [Walk.map_cons, edges_cons, List.map_cons, Sym2.map_pair_eq, List.cons.injEq,\n      true_and, ih]\n\n"}
{"name":"SimpleGraph.Walk.map_injective_of_injective","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G.Hom G'\nhinj : Function.Injective ⇑f\nu v : V\n⊢ Function.Injective (SimpleGraph.Walk.map f)","decl":"theorem map_injective_of_injective {f : G →g G'} (hinj : Function.Injective f) (u v : V) :\n    Function.Injective (Walk.map f : G.Walk u v → G'.Walk (f u) (f v)) := by\n  intro p p' h\n  induction p with\n  | nil =>\n    cases p'\n    · rfl\n    · simp at h\n  | cons _ _ ih =>\n    cases p' with\n    | nil => simp at h\n    | cons _ _ =>\n      simp only [map_cons, cons.injEq] at h\n      cases hinj h.1\n      simp only [cons.injEq, heq_iff_eq, true_and]\n      apply ih\n      simpa using h.2\n\n"}
{"name":"SimpleGraph.Walk.transfer_self","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ Eq (p.transfer G ⋯) p","decl":"theorem transfer_self : p.transfer G p.edges_subset_edgeSet = p := by\n  induction p <;> simp [*]\n\n"}
{"name":"SimpleGraph.Walk.transfer_eq_map_of_le","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nH : SimpleGraph V\nhp : ∀ (e : Sym2 V), Membership.mem p.edges e → Membership.mem H.edgeSet e\nGH : LE.le G H\n⊢ Eq (p.transfer H hp) (SimpleGraph.Walk.map (SimpleGraph.Hom.mapSpanningSubgraphs GH) p)","decl":"theorem transfer_eq_map_of_le (hp) (GH : G ≤ H) :\n    p.transfer H hp = p.map (SimpleGraph.Hom.mapSpanningSubgraphs GH) := by\n  induction p <;> simp [*]\n\n"}
{"name":"SimpleGraph.Walk.edges_transfer","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nH : SimpleGraph V\nhp : ∀ (e : Sym2 V), Membership.mem p.edges e → Membership.mem H.edgeSet e\n⊢ Eq (p.transfer H hp).edges p.edges","decl":"@[simp]\ntheorem edges_transfer (hp) : (p.transfer H hp).edges = p.edges := by\n  induction p <;> simp [*]\n\n"}
{"name":"SimpleGraph.Walk.support_transfer","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nH : SimpleGraph V\nhp : ∀ (e : Sym2 V), Membership.mem p.edges e → Membership.mem H.edgeSet e\n⊢ Eq (p.transfer H hp).support p.support","decl":"@[simp]\ntheorem support_transfer (hp) : (p.transfer H hp).support = p.support := by\n  induction p <;> simp [*]\n\n"}
{"name":"SimpleGraph.Walk.length_transfer","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nH : SimpleGraph V\nhp : ∀ (e : Sym2 V), Membership.mem p.edges e → Membership.mem H.edgeSet e\n⊢ Eq (p.transfer H hp).length p.length","decl":"@[simp]\ntheorem length_transfer (hp) : (p.transfer H hp).length = p.length := by\n  induction p <;> simp [*]\n\n"}
{"name":"SimpleGraph.Walk.transfer_transfer","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nH : SimpleGraph V\nhp : ∀ (e : Sym2 V), Membership.mem p.edges e → Membership.mem H.edgeSet e\nK : SimpleGraph V\nhp' : ∀ (e : Sym2 V), Membership.mem (p.transfer H hp).edges e → Membership.mem K.edgeSet e\n⊢ Eq ((p.transfer H hp).transfer K hp') (p.transfer K ⋯)","decl":"@[simp]\ntheorem transfer_transfer (hp) {K : SimpleGraph V} (hp') :\n    (p.transfer H hp).transfer K hp' = p.transfer K (p.edges_transfer hp ▸ hp') := by\n  induction p with\n  | nil => simp\n  | cons _ _ ih =>\n    simp only [Walk.transfer, cons.injEq, heq_eq_eq, true_and]\n    apply ih\n\n"}
{"name":"SimpleGraph.Walk.transfer_append","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nH : SimpleGraph V\nw : V\nq : G.Walk v w\nhpq : ∀ (e : Sym2 V), Membership.mem (p.append q).edges e → Membership.mem H.edgeSet e\n⊢ Eq ((p.append q).transfer H hpq) ((p.transfer H ⋯).append (q.transfer H ⋯))","decl":"@[simp]\ntheorem transfer_append {w : V} (q : G.Walk v w) (hpq) :\n    (p.append q).transfer H hpq =\n      (p.transfer H fun e he => hpq _ (by simp [he])).append\n        (q.transfer H fun e he => hpq _ (by simp [he])) := by\n  induction p with\n  | nil => simp\n  | cons _ _ ih => simp only [Walk.transfer, cons_append, cons.injEq, heq_eq_eq, true_and, ih]\n\n"}
{"name":"SimpleGraph.Walk.reverse_transfer","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nH : SimpleGraph V\nhp : ∀ (e : Sym2 V), Membership.mem p.edges e → Membership.mem H.edgeSet e\n⊢ Eq (p.transfer H hp).reverse (p.reverse.transfer H ⋯)","decl":"@[simp]\ntheorem reverse_transfer (hp) :\n    (p.transfer H hp).reverse =\n      p.reverse.transfer H (by simp only [edges_reverse, List.mem_reverse]; exact hp) := by\n  induction p with\n  | nil => simp\n  | cons _ _ ih => simp only [transfer_append, Walk.transfer, reverse_nil, reverse_cons, ih]\n\n"}
{"name":"SimpleGraph.Walk.toDeleteEdges_nil","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\ns : Set (Sym2 V)\nv : V\nhp : ∀ (e : Sym2 V), Membership.mem SimpleGraph.Walk.nil.edges e → Not (Membership.mem s e)\n⊢ Eq (SimpleGraph.Walk.toDeleteEdges s SimpleGraph.Walk.nil hp) SimpleGraph.Walk.nil","decl":"@[simp]\ntheorem toDeleteEdges_nil (s : Set (Sym2 V)) {v : V} (hp) :\n    (Walk.nil : G.Walk v v).toDeleteEdges s hp = Walk.nil := rfl\n\n"}
{"name":"SimpleGraph.Walk.toDeleteEdges_cons","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\ns : Set (Sym2 V)\nu v w : V\nh : G.Adj u v\np : G.Walk v w\nhp : ∀ (e : Sym2 V), Membership.mem (SimpleGraph.Walk.cons h p).edges e → Not (Membership.mem s e)\n⊢ Eq (SimpleGraph.Walk.toDeleteEdges s (SimpleGraph.Walk.cons h p) hp) (SimpleGraph.Walk.cons ⋯ (SimpleGraph.Walk.toDeleteEdges s p ⋯))","decl":"@[simp]\ntheorem toDeleteEdges_cons (s : Set (Sym2 V)) {u v w : V} (h : G.Adj u v) (p : G.Walk v w) (hp) :\n    (Walk.cons h p).toDeleteEdges s hp =\n      Walk.cons (deleteEdges_adj.mpr ⟨h, hp _ (List.Mem.head _)⟩)\n        (p.toDeleteEdges s fun _ he => hp _ <| List.Mem.tail _ he) :=\n  rfl\n\n"}
{"name":"SimpleGraph.Walk.map_toDeleteEdges_eq","module":"Mathlib.Combinatorics.SimpleGraph.Walk","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\ns : Set (Sym2 V)\np : G.Walk v w\nhp : ∀ (e : Sym2 V), Membership.mem p.edges e → Not (Membership.mem s e)\n⊢ Eq (SimpleGraph.Walk.map (SimpleGraph.Hom.mapSpanningSubgraphs ⋯) (SimpleGraph.Walk.toDeleteEdges s p hp)) p","decl":"@[simp]\ntheorem map_toDeleteEdges_eq (s : Set (Sym2 V)) {p : G.Walk v w} (hp) :\n    Walk.map (Hom.mapSpanningSubgraphs (G.deleteEdges_le s)) (p.toDeleteEdges s hp) = p := by\n  rw [← transfer_eq_map_of_le, transfer_transfer, transfer_self]\n  intros e\n  rw [edges_transfer]\n  apply edges_subset_edgeSet p\n\n"}
