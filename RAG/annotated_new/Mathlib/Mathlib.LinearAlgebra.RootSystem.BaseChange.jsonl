{"name":"RootPairing.IsBalanced.isPerfectCompl","module":"Mathlib.LinearAlgebra.RootSystem.BaseChange","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup N\ninst✝² : CommRing R\ninst✝¹ : Module R M\ninst✝ : Module R N\nP : RootPairing ι R M N\nself : P.IsBalanced\n⊢ P.IsPerfectCompl P.rootSpan P.corootSpan","decl":"/-- We say a root pairing is balanced if the root span and coroot span are perfectly\ncomplementary.\n\nAll root systems are balanced and all finite root pairings over a field are balanced. -/\nclass IsBalanced {ι R M N : Type*} [AddCommGroup M] [AddCommGroup N]\n    [CommRing R] [Module R M] [Module R N] (P : RootPairing ι R M N) : Prop where\n  isPerfectCompl : P.toPerfectPairing.IsPerfectCompl P.rootSpan P.corootSpan\n\n"}
{"name":"RootPairing.instIsBalanced","module":"Mathlib.LinearAlgebra.RootSystem.BaseChange","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup N\ninst✝² : CommRing R\ninst✝¹ : Module R M\ninst✝ : Module R N\nP : RootSystem ι R M N\n⊢ P.IsBalanced","decl":"instance {ι R M N : Type*} [AddCommGroup M] [AddCommGroup N]\n    [CommRing R] [Module R M] [Module R N] (P : RootSystem ι R M N) :\n    P.IsBalanced where\n  isPerfectCompl := by simp\n\n"}
{"name":"RootPairing.restrictScalars_toPerfectPairing_apply_apply","module":"Mathlib.LinearAlgebra.RootSystem.BaseChange","initialProofState":"ι : Type u_1\nL : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹¹ : Field L\ninst✝¹⁰ : AddCommGroup M\ninst✝⁹ : AddCommGroup N\ninst✝⁸ : Module L M\ninst✝⁷ : Module L N\nP : RootPairing ι L M N\nK : Type u_5\ninst✝⁶ : Field K\ninst✝⁵ : Algebra K L\ninst✝⁴ : Module K M\ninst✝³ : Module K N\ninst✝² : IsScalarTower K L M\ninst✝¹ : IsScalarTower K L N\ninst✝ : P.IsBalanced\nx : Subtype fun x => Membership.mem (Submodule.span K (Set.range ⇑P.root)) x\ny : Subtype fun x => Membership.mem (Submodule.span K (Set.range ⇑P.coroot)) x\n⊢ Eq ((algebraMap K L) (sorryAx (Unit → K) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 97).num 20).num 97).num 66).num 20).num 66).str \"_sorry\").str \"_@\").str \"_hyg\").num 647)))) ((P.toPerfectPairing ↑x) ↑y)","decl":"@[simp] lemma restrictScalars_toPerfectPairing_apply_apply\n    (x : span K (range P.root)) (y : span K (range P.coroot)) :\n    algebraMap K L ((P.restrictScalars' K hP).toPerfectPairing x y) = P.toPerfectPairing x y := by\n  simp [restrictScalars']\n\n"}
{"name":"RootPairing.restrictScalars_coe_root","module":"Mathlib.LinearAlgebra.RootSystem.BaseChange","initialProofState":"ι : Type u_1\nL : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Field L\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup N\ninst✝² : Module L M\ninst✝¹ : Module L N\nP : RootPairing ι L M N\ninst✝ : P.IsBalanced\ni : ι\n⊢ Eq (sorryAx (Unit → M) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 101).num 4).num 101).num 36).num 4).num 36).str \"_sorry\").str \"_@\").str \"_hyg\").num 786))) (P.root i)","decl":"@[simp] lemma restrictScalars_coe_root (i : ι) :\n    (P.restrictScalars' K hP).root i = P.root i :=\n  rfl\n\n"}
{"name":"RootPairing.restrictScalars_coe_coroot","module":"Mathlib.LinearAlgebra.RootSystem.BaseChange","initialProofState":"ι : Type u_1\nL : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : Field L\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup N\ninst✝² : Module L M\ninst✝¹ : Module L N\nP : RootPairing ι L M N\ninst✝ : P.IsBalanced\ni : ι\n⊢ Eq (sorryAx (Unit → N) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 105).num 4).num 105).num 38).num 4).num 38).str \"_sorry\").str \"_@\").str \"_hyg\").num 925))) (P.coroot i)","decl":"@[simp] lemma restrictScalars_coe_coroot (i : ι) :\n    (P.restrictScalars' K hP).coroot i = P.coroot i :=\n  rfl\n\n"}
{"name":"RootPairing.restrictScalars_pairing","module":"Mathlib.LinearAlgebra.RootSystem.BaseChange","initialProofState":"ι : Type u_1\nL : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹¹ : Field L\ninst✝¹⁰ : AddCommGroup M\ninst✝⁹ : AddCommGroup N\ninst✝⁸ : Module L M\ninst✝⁷ : Module L N\nP : RootPairing ι L M N\nK : Type u_5\ninst✝⁶ : Field K\ninst✝⁵ : Algebra K L\ninst✝⁴ : Module K M\ninst✝³ : Module K N\ninst✝² : IsScalarTower K L M\ninst✝¹ : IsScalarTower K L N\ninst✝ : P.IsBalanced\ni j : ι\n⊢ Eq ((algebraMap K L) (sorryAx (Unit → K) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 109).num 20).num 109).num 57).num 20).num 57).str \"_sorry\").str \"_@\").str \"_hyg\").num 1064)))) (P.pairing i j)","decl":"@[simp] lemma restrictScalars_pairing (i j : ι) :\n    algebraMap K L ((P.restrictScalars' K hP).pairing i j) = P.pairing i j := by\n  simp only [pairing, restrictScalars_toPerfectPairing_apply_apply, restrictScalars_coe_root,\n    restrictScalars_coe_coroot]\n\n"}
