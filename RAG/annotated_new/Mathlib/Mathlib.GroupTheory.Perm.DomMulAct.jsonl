{"name":"DomMulAct.mem_stabilizer_iff","module":"Mathlib.GroupTheory.Perm.DomMulAct","initialProofState":"α : Type u_1\nι : Type u_2\nf : α → ι\ng : DomMulAct (Equiv.Perm α)\n⊢ Iff (Membership.mem (MulAction.stabilizer (DomMulAct (Equiv.Perm α)) f) g) (Eq (Function.comp f ⇑(DomMulAct.mk.symm g)) f)","decl":"lemma mem_stabilizer_iff {g : (Perm α)ᵈᵐᵃ} :\n    g ∈ stabilizer (Perm α)ᵈᵐᵃ f ↔ f ∘ (mk.symm g :) = f := by\n  simp only [MulAction.mem_stabilizer_iff]; rfl\n\n"}
{"name":"DomMulAct.stabilizerEquiv_invFun_eq","module":"Mathlib.GroupTheory.Perm.DomMulAct","initialProofState":"α : Type u_1\nι : Type u_2\nf : α → ι\ng : (i : ι) → Equiv.Perm (Subtype fun a => Eq (f a) i)\na : α\ni : ι\nh : Eq (f a) i\n⊢ Eq (DomMulAct.stabilizerEquiv_invFun g a) ↑((g i) ⟨a, h⟩)","decl":"lemma stabilizerEquiv_invFun_eq (g : ∀ i, Perm {a // f a = i}) {a : α} {i : ι} (h : f a = i) :\n    stabilizerEquiv_invFun g a = g i ⟨a, h⟩ := by subst h; rfl\n\n"}
{"name":"DomMulAct.comp_stabilizerEquiv_invFun","module":"Mathlib.GroupTheory.Perm.DomMulAct","initialProofState":"α : Type u_1\nι : Type u_2\nf : α → ι\ng : (i : ι) → Equiv.Perm (Subtype fun a => Eq (f a) i)\na : α\n⊢ Eq (f (DomMulAct.stabilizerEquiv_invFun g a)) (f a)","decl":"lemma comp_stabilizerEquiv_invFun (g : ∀ i, Perm {a // f a = i}) (a : α) :\n    f (stabilizerEquiv_invFun g a) = f a :=\n  (g (f a) ⟨a, rfl⟩).prop\n\n"}
{"name":"DomMulAct.stabilizerMulEquiv_apply","module":"Mathlib.GroupTheory.Perm.DomMulAct","initialProofState":"α : Type u_1\nι : Type u_2\nf : α → ι\ng : MulOpposite (Subtype fun x => Membership.mem (MulAction.stabilizer (DomMulAct (Equiv.Perm α)) f) x)\na : α\ni : ι\nh : Eq (f a) i\n⊢ Eq (↑(((DomMulAct.stabilizerMulEquiv f) g i) ⟨a, h⟩)) ((DomMulAct.mk.symm ↑(MulOpposite.unop g)) a)","decl":"lemma stabilizerMulEquiv_apply (g : (stabilizer (Perm α)ᵈᵐᵃ f)ᵐᵒᵖ) {a : α} {i : ι} (h : f a = i) :\n    ((stabilizerMulEquiv f)) g i ⟨a, h⟩ = (mk.symm g.unop : Equiv.Perm α) a := rfl\n\n"}
{"name":"DomMulAct.stabilizer_card","module":"Mathlib.GroupTheory.Perm.DomMulAct","initialProofState":"α : Type u_1\nι : Type u_2\nf : α → ι\ninst✝³ : Fintype α\ninst✝² : DecidableEq α\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\n⊢ Eq (Fintype.card (Subtype fun g => Eq (Function.comp f ⇑g) f)) (Finset.univ.prod fun i => (Fintype.card (Subtype fun a => Eq (f a) i)).factorial)","decl":"/-- The cardinality of the type of permutations preserving a function -/\ntheorem stabilizer_card [DecidableEq α] [DecidableEq ι] [Fintype ι] :\n    Fintype.card {g : Perm α // f ∘ g = f} = ∏ i, (Fintype.card {a // f a = i})! := by\n  -- rewriting via Nat.card because Fintype instance is not found\n  rw [← Nat.card_eq_fintype_card,\n    Nat.card_congr (subtypeEquiv mk fun _ ↦ ?_),\n    Nat.card_congr MulOpposite.opEquiv,\n    Nat.card_congr (DomMulAct.stabilizerMulEquiv f).toEquiv, Nat.card_pi]\n  · exact Finset.prod_congr rfl fun i _ ↦ by rw [Nat.card_eq_fintype_card, Fintype.card_perm]\n  · rfl\n\n"}
{"name":"DomMulAct.stabilizer_ncard","module":"Mathlib.GroupTheory.Perm.DomMulAct","initialProofState":"α : Type u_1\nι : Type u_2\nf : α → ι\ninst✝¹ : Finite α\ninst✝ : Fintype ι\n⊢ Eq (setOf fun g => Eq (Function.comp f ⇑g) f).ncard (Finset.univ.prod fun i => (setOf fun a => Eq (f a) i).ncard.factorial)","decl":"omit [Fintype α] in\n/-- The cardinality of the set of permutations preserving a function -/\ntheorem stabilizer_ncard [Finite α] [Fintype ι] :\n    Set.ncard {g : Perm α | f ∘ g = f} = ∏ i, (Set.ncard {a | f a = i})! := by\n  classical\n  cases nonempty_fintype α\n  simp only [← Set.Nat.card_coe_set_eq, Set.coe_setOf, card_eq_fintype_card]\n  exact stabilizer_card f\n\n"}
{"name":"DomMulAct.stabilizer_card'","module":"Mathlib.GroupTheory.Perm.DomMulAct","initialProofState":"α : Type u_1\nι : Type u_2\nf : α → ι\ninst✝² : Fintype α\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq ι\n⊢ Eq (Fintype.card (Subtype fun g => Eq (Function.comp f ⇑g) f)) ((Finset.image f Finset.univ).prod fun i => (Fintype.card (Subtype fun a => Eq (f a) i)).factorial)","decl":"/-- The cardinality of the type of permutations preserving a function\n  (without the finiteness assumption on target)-/\ntheorem stabilizer_card':\n    Fintype.card {g : Perm α // f ∘ g = f} =\n      ∏ i ∈ Finset.univ.image f, (Fintype.card ({a // f a = i}))! := by\n  set φ : α → Finset.univ.image f :=\n    Set.codRestrict f (Finset.univ.image f) (fun a => by simp)\n  suffices ∀ g : Perm α, f ∘ g = f ↔ φ ∘ g = φ by\n    simp only [this, stabilizer_card]\n    apply Finset.prod_bij (fun g _ => g.val)\n    · exact fun g _ => Finset.coe_mem g\n    · exact fun g _ g' _ =>  SetCoe.ext\n    · exact fun g hg => by\n        rw [Finset.mem_image] at hg\n        obtain ⟨a, _, rfl⟩ := hg\n        use ⟨f a, by simp only [Finset.mem_image, Finset.mem_univ, true_and, exists_apply_eq_apply]⟩\n        simp only [Finset.univ_eq_attach, Finset.mem_attach, exists_const]\n    · intro i _\n      apply congr_arg\n      apply Fintype.card_congr\n      apply Equiv.subtypeEquiv (Equiv.refl α)\n      intro a\n      rw [refl_apply, ← Subtype.coe_inj]\n      simp only [φ, Set.val_codRestrict_apply]\n  · intro g\n    simp only [funext_iff]\n    apply forall_congr'\n    intro a\n    simp only [Function.comp_apply, φ, ← Subtype.coe_inj, Set.val_codRestrict_apply]\n\n"}
