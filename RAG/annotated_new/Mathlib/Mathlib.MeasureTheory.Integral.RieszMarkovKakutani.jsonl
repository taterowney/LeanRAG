{"name":"rieszContentAux_image_nonempty","module":"Mathlib.MeasureTheory.Integral.RieszMarkovKakutani","initialProofState":"X : Type u_1\ninst✝² : TopologicalSpace X\nΛ : LinearMap (RingHom.id NNReal) (CompactlySupportedContinuousMap X NNReal) NNReal\ninst✝¹ : T2Space X\ninst✝ : LocallyCompactSpace X\nK : TopologicalSpace.Compacts X\n⊢ (Set.image (⇑Λ) (setOf fun f => ∀ (x : X), Membership.mem K x → LE.le 1 (f x))).Nonempty","decl":"/-- For any compact subset `K ⊆ X`, there exist some compactly supported continuous nonnegative\nfunctions `f` on `X` such that `f ≥ 1` on `K`. -/\ntheorem rieszContentAux_image_nonempty (K : Compacts X) :\n    (Λ '' { f : C_c(X, ℝ≥0) | ∀ x ∈ K, (1 : ℝ≥0) ≤ f x }).Nonempty := by\n  rw [image_nonempty]\n  obtain ⟨V, hVcp, hKsubintV⟩ := exists_compact_superset K.2\n  have hIsCompact_closure_interior : IsCompact (closure (interior V)) := by\n    apply IsCompact.of_isClosed_subset hVcp isClosed_closure\n    nth_rw 2 [← closure_eq_iff_isClosed.mpr (IsCompact.isClosed hVcp)]\n    exact closure_mono interior_subset\n  obtain ⟨f, hsuppfsubV, hfeq1onK, hfinicc⟩ :=\n    exists_tsupport_one_of_isOpen_isClosed isOpen_interior hIsCompact_closure_interior\n      (IsCompact.isClosed K.2) hKsubintV\n  have hfHasCompactSupport : HasCompactSupport f :=\n    IsCompact.of_isClosed_subset hVcp (isClosed_tsupport f)\n      (Set.Subset.trans hsuppfsubV interior_subset)\n  use nnrealPart ⟨f, hfHasCompactSupport⟩\n  intro x hx\n  apply le_of_eq\n  simp only [nnrealPart_apply, CompactlySupportedContinuousMap.coe_mk]\n  rw [← Real.toNNReal_one, Real.toNNReal_eq_toNNReal_iff (zero_le_one' ℝ) (hfinicc x).1]\n  exact hfeq1onK.symm hx\n\n"}
{"name":"rieszContentAux_mono","module":"Mathlib.MeasureTheory.Integral.RieszMarkovKakutani","initialProofState":"X : Type u_1\ninst✝² : TopologicalSpace X\nΛ : LinearMap (RingHom.id NNReal) (CompactlySupportedContinuousMap X NNReal) NNReal\ninst✝¹ : T2Space X\ninst✝ : LocallyCompactSpace X\nK₁ K₂ : TopologicalSpace.Compacts X\nh : LE.le K₁ K₂\n⊢ LE.le (rieszContentAux Λ K₁) (rieszContentAux Λ K₂)","decl":"/-- Riesz content `λ` (associated with a positive linear functional `Λ`) is\nmonotone: if `K₁ ⊆ K₂` are compact subsets in `X`, then `λ(K₁) ≤ λ(K₂)`. -/\ntheorem rieszContentAux_mono {K₁ K₂ : Compacts X} (h : K₁ ≤ K₂) :\n    rieszContentAux Λ K₁ ≤ rieszContentAux Λ K₂ :=\n  csInf_le_csInf (OrderBot.bddBelow _) (rieszContentAux_image_nonempty Λ K₂)\n    (image_subset Λ (setOf_subset_setOf.mpr fun _ f_hyp x x_in_K₁ => f_hyp x (h x_in_K₁)))\n\n"}
{"name":"rieszContentAux_le","module":"Mathlib.MeasureTheory.Integral.RieszMarkovKakutani","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nΛ : LinearMap (RingHom.id NNReal) (CompactlySupportedContinuousMap X NNReal) NNReal\nK : TopologicalSpace.Compacts X\nf : CompactlySupportedContinuousMap X NNReal\nh : ∀ (x : X), Membership.mem K x → LE.le 1 (f x)\n⊢ LE.le (rieszContentAux Λ K) (Λ f)","decl":"/-- Any compactly supported continuous nonnegative `f` such that `f ≥ 1` on `K` gives an upper bound\non the content of `K`; namely `λ(K) ≤ Λ f`. -/\ntheorem rieszContentAux_le {K : Compacts X} {f : C_c(X, ℝ≥0)} (h : ∀ x ∈ K, (1 : ℝ≥0) ≤ f x) :\n    rieszContentAux Λ K ≤ Λ f :=\n  csInf_le (OrderBot.bddBelow _) ⟨f, ⟨h, rfl⟩⟩\n\n"}
{"name":"exists_lt_rieszContentAux_add_pos","module":"Mathlib.MeasureTheory.Integral.RieszMarkovKakutani","initialProofState":"X : Type u_1\ninst✝² : TopologicalSpace X\nΛ : LinearMap (RingHom.id NNReal) (CompactlySupportedContinuousMap X NNReal) NNReal\ninst✝¹ : T2Space X\ninst✝ : LocallyCompactSpace X\nK : TopologicalSpace.Compacts X\nε : NNReal\nεpos : LT.lt 0 ε\n⊢ Exists fun f => And (∀ (x : X), Membership.mem K x → LE.le 1 (f x)) (LT.lt (Λ f) (HAdd.hAdd (rieszContentAux Λ K) ε))","decl":"/-- The Riesz content can be approximated arbitrarily well by evaluating the positive linear\nfunctional on test functions: for any `ε > 0`, there exists a compactly supported continuous\nnonnegative function `f` on `X` such that `f ≥ 1` on `K` and such that `λ(K) ≤ Λ f < λ(K) + ε`. -/\ntheorem exists_lt_rieszContentAux_add_pos (K : Compacts X) {ε : ℝ≥0} (εpos : 0 < ε) :\n    ∃ f : C_c(X, ℝ≥0), (∀ x ∈ K, (1 : ℝ≥0) ≤ f x) ∧ Λ f < rieszContentAux Λ K + ε := by\n  --choose a test function `f` s.t. `Λf = α < λ(K) + ε`\n  obtain ⟨α, ⟨⟨f, f_hyp⟩, α_hyp⟩⟩ :=\n    exists_lt_of_csInf_lt (rieszContentAux_image_nonempty Λ K)\n      (lt_add_of_pos_right (rieszContentAux Λ K) εpos)\n  refine ⟨f, f_hyp.left, ?_⟩\n  rw [f_hyp.right]\n  exact α_hyp\n\n"}
{"name":"rieszContentAux_sup_le","module":"Mathlib.MeasureTheory.Integral.RieszMarkovKakutani","initialProofState":"X : Type u_1\ninst✝² : TopologicalSpace X\nΛ : LinearMap (RingHom.id NNReal) (CompactlySupportedContinuousMap X NNReal) NNReal\ninst✝¹ : T2Space X\ninst✝ : LocallyCompactSpace X\nK1 K2 : TopologicalSpace.Compacts X\n⊢ LE.le (rieszContentAux Λ (Max.max K1 K2)) (HAdd.hAdd (rieszContentAux Λ K1) (rieszContentAux Λ K2))","decl":"/-- The Riesz content `λ` associated to a given positive linear functional `Λ` is\nfinitely subadditive: `λ(K₁ ∪ K₂) ≤ λ(K₁) + λ(K₂)` for any compact subsets `K₁, K₂ ⊆ X`. -/\ntheorem rieszContentAux_sup_le (K1 K2 : Compacts X) :\n    rieszContentAux Λ (K1 ⊔ K2) ≤ rieszContentAux Λ K1 + rieszContentAux Λ K2 := by\n  apply _root_.le_of_forall_pos_le_add\n  intro ε εpos\n  --get test functions s.t. `λ(Ki) ≤ Λfi ≤ λ(Ki) + ε/2, i=1,2`\n  obtain ⟨f1, f_test_function_K1⟩ := exists_lt_rieszContentAux_add_pos Λ K1 (half_pos εpos)\n  obtain ⟨f2, f_test_function_K2⟩ := exists_lt_rieszContentAux_add_pos Λ K2 (half_pos εpos)\n  --let `f := f1 + f2` test function for the content of `K`\n  have f_test_function_union : ∀ x ∈ K1 ⊔ K2, (1 : ℝ≥0) ≤ (f1 + f2) x := by\n    rintro x (x_in_K1 | x_in_K2)\n    · exact le_add_right (f_test_function_K1.left x x_in_K1)\n    · exact le_add_left (f_test_function_K2.left x x_in_K2)\n  --use that `Λf` is an upper bound for `λ(K1⊔K2)`\n  apply (rieszContentAux_le Λ f_test_function_union).trans (le_of_lt _)\n  rw [map_add]\n  --use that `Λfi` are lower bounds for `λ(Ki) + ε/2`\n  apply lt_of_lt_of_le (_root_.add_lt_add f_test_function_K1.right f_test_function_K2.right)\n    (le_of_eq _)\n  rw [add_assoc, add_comm (ε / 2), add_assoc, add_halves ε, add_assoc]\n\n"}
{"name":"exists_continuous_add_one_of_isCompact_nnreal","module":"Mathlib.MeasureTheory.Integral.RieszMarkovKakutani","initialProofState":"X : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : T2Space X\ninst✝ : LocallyCompactSpace X\ns₀ s₁ t : Set X\ns₀_compact : IsCompact s₀\ns₁_compact : IsCompact s₁\nt_compact : IsCompact t\ndisj : Disjoint s₀ s₁\nhst : HasSubset.Subset (Union.union s₀ s₁) t\n⊢ Exists fun f₀ => Exists fun f₁ => And (Set.EqOn (⇑f₀) 1 s₀) (And (Set.EqOn (⇑f₁) 1 s₁) (Set.EqOn (⇑(HAdd.hAdd f₀ f₁)) 1 t))","decl":"lemma exists_continuous_add_one_of_isCompact_nnreal\n    {s₀ s₁ : Set X} {t : Set X} (s₀_compact : IsCompact s₀) (s₁_compact : IsCompact s₁)\n    (t_compact : IsCompact t) (disj : Disjoint s₀ s₁) (hst : s₀ ∪ s₁ ⊆ t) :\n    ∃ (f₀ f₁ : C_c(X, ℝ≥0)), EqOn f₀ 1 s₀ ∧ EqOn f₁ 1 s₁ ∧ EqOn (f₀ + f₁) 1 t := by\n  set so : Fin 2 → Set X := fun j => if j = 0 then s₀ᶜ else s₁ᶜ with hso\n  have soopen (j : Fin 2) :  IsOpen (so j) := by\n    fin_cases j\n    · simp only [hso, Fin.zero_eta, Fin.isValue, ↓reduceIte, isOpen_compl_iff]\n      exact IsCompact.isClosed <| s₀_compact\n    · simp only [hso, Fin.isValue, Fin.mk_one, one_ne_zero, ↓reduceIte, isOpen_compl_iff]\n      exact IsCompact.isClosed <| s₁_compact\n  have hsot : t ⊆ ⋃ j, so j := by\n    rw [hso]\n    simp only [Fin.isValue]\n    intro x hx\n    rw [mem_iUnion]\n    rw [← subset_compl_iff_disjoint_right, ← compl_compl s₀, compl_subset_iff_union] at disj\n    have h : x ∈ s₀ᶜ ∨ x ∈ s₁ᶜ := by\n      rw [← mem_union, disj]\n      exact mem_univ _\n    apply Or.elim h\n    · intro h0\n      use 0\n      simp only [Fin.isValue, ↓reduceIte]\n      exact h0\n    · intro h1\n      use 1\n      simp only [Fin.isValue, one_ne_zero, ↓reduceIte]\n      exact h1\n  obtain ⟨f, f_supp_in_so, sum_f_one_on_t, f_in_icc, f_hcs⟩ :=\n    exists_continuous_sum_one_of_isOpen_isCompact soopen t_compact hsot\n  use (nnrealPart (⟨f 1, f_hcs 1⟩ : C_c(X, ℝ))),\n    (nnrealPart (⟨f 0, f_hcs 0⟩ : C_c(X, ℝ)))\n  simp only [Fin.isValue, CompactlySupportedContinuousMap.coe_add]\n  have sum_one_x (x : X) (hx : x ∈ t) : (f 0) x + (f 1) x = 1 := by\n    simpa only [Finset.sum_apply, Fin.sum_univ_two, Fin.isValue, Pi.one_apply]\n      using sum_f_one_on_t hx\n  refine ⟨?_, ?_, ?_⟩\n  · intro x hx\n    simp only [Fin.isValue, nnrealPart_apply,\n      CompactlySupportedContinuousMap.coe_mk, Pi.one_apply, Real.toNNReal_eq_one]\n    have : (f 0) x = 0 := by\n      rw [← nmem_support]\n      have : s₀ ⊆ (tsupport (f 0))ᶜ := by\n        apply subset_trans _ (compl_subset_compl.mpr (f_supp_in_so 0))\n        rw [hso]\n        simp only [Fin.isValue, ↓reduceIte, compl_compl, subset_refl]\n      apply not_mem_of_mem_compl\n      exact mem_of_subset_of_mem (subset_trans this (compl_subset_compl_of_subset subset_closure))\n        hx\n    rw [union_subset_iff] at hst\n    rw [← sum_one_x x (mem_of_subset_of_mem hst.1 hx), this]\n    exact Eq.symm (AddZeroClass.zero_add ((f 1) x))\n  · intro x hx\n    simp only [Fin.isValue, nnrealPart_apply,\n      CompactlySupportedContinuousMap.coe_mk, Pi.one_apply, Real.toNNReal_eq_one]\n    have : (f 1) x = 0 := by\n      rw [← nmem_support]\n      have : s₁ ⊆ (tsupport (f 1))ᶜ := by\n        apply subset_trans _ (compl_subset_compl.mpr (f_supp_in_so 1))\n        rw [hso]\n        simp only [Fin.isValue, one_ne_zero, ↓reduceIte, compl_compl, subset_refl]\n      apply not_mem_of_mem_compl\n      exact mem_of_subset_of_mem (subset_trans this (compl_subset_compl_of_subset subset_closure))\n        hx\n    rw [union_subset_iff] at hst\n    rw [← sum_one_x x (mem_of_subset_of_mem hst.2 hx), this]\n    exact Eq.symm (AddMonoid.add_zero ((f 0) x))\n  · intro x hx\n    simp only [Fin.isValue, Pi.add_apply, nnrealPart_apply,\n      CompactlySupportedContinuousMap.coe_mk, Pi.one_apply]\n    rw [Real.toNNReal_add_toNNReal (f_in_icc 1 x).1 (f_in_icc 0 x).1, add_comm]\n    simp only [Fin.isValue, Real.toNNReal_eq_one]\n    exact sum_one_x x hx\n\n"}
{"name":"rieszContentAux_union","module":"Mathlib.MeasureTheory.Integral.RieszMarkovKakutani","initialProofState":"X : Type u_1\ninst✝² : TopologicalSpace X\nΛ : LinearMap (RingHom.id NNReal) (CompactlySupportedContinuousMap X NNReal) NNReal\ninst✝¹ : T2Space X\ninst✝ : LocallyCompactSpace X\nK₁ K₂ : TopologicalSpace.Compacts X\ndisj : Disjoint ↑K₁ ↑K₂\n⊢ Eq (rieszContentAux Λ (Max.max K₁ K₂)) (HAdd.hAdd (rieszContentAux Λ K₁) (rieszContentAux Λ K₂))","decl":"lemma rieszContentAux_union {K₁ K₂ : TopologicalSpace.Compacts X}\n    (disj : Disjoint (K₁ : Set X) K₂) :\n    rieszContentAux Λ (K₁ ⊔ K₂) = rieszContentAux Λ K₁ + rieszContentAux Λ K₂ := by\n  refine le_antisymm (rieszContentAux_sup_le Λ K₁ K₂) ?_\n  refine le_csInf (rieszContentAux_image_nonempty Λ (K₁ ⊔ K₂)) ?_\n  intro b ⟨f, ⟨hf, Λf_eq_b⟩⟩\n  have hsuppf : ∀ x ∈ K₁ ⊔ K₂, x ∈ support f := by\n    intro x hx\n    rw [mem_support]\n    exact ne_of_gt <| lt_of_lt_of_le (zero_lt_one' ℝ≥0) (hf x hx)\n  have hsubsuppf : (K₁ : Set X) ∪ (K₂ : Set X) ⊆ tsupport f := subset_trans hsuppf subset_closure\n  obtain ⟨g₁, g₂, hg₁, hg₂, sum_g⟩ := exists_continuous_add_one_of_isCompact_nnreal K₁.isCompact'\n    K₂.isCompact' f.hasCompactSupport'.isCompact disj hsubsuppf\n  have f_eq_sum : f = g₁ * f + g₂ * f := by\n    ext x\n    simp only [CompactlySupportedContinuousMap.coe_add, CompactlySupportedContinuousMap.coe_mul,\n      Pi.add_apply, Pi.mul_apply, NNReal.coe_add, NNReal.coe_mul,\n      Eq.symm (RightDistribClass.right_distrib _ _ _), ← NNReal.coe_add, ← Pi.add_apply]\n    by_cases h : f x = 0\n    · rw [h]\n      simp only [NNReal.coe_zero, NNReal.coe_add, mul_zero]\n    · push_neg at h\n      simp only [CompactlySupportedContinuousMap.coe_add, ContinuousMap.toFun_eq_coe,\n        CompactlySupportedContinuousMap.coe_toContinuousMap] at sum_g\n      rw [sum_g (mem_of_subset_of_mem subset_closure (mem_support.mpr h))]\n      simp only [Pi.one_apply, NNReal.coe_one, one_mul]\n  rw [← Λf_eq_b, f_eq_sum, map_add]\n  have aux₁ : ∀ x ∈ K₁, 1 ≤ (g₁ * f) x := by\n    intro x x_in_K₁\n    simp [hg₁ x_in_K₁, hf x (mem_union_left _ x_in_K₁)]\n  have aux₂ : ∀ x ∈ K₂, 1 ≤ (g₂ * f) x := by\n    intro x x_in_K₂\n    simp [hg₂ x_in_K₂, hf x (mem_union_right _ x_in_K₂)]\n  exact add_le_add (rieszContentAux_le Λ aux₁) (rieszContentAux_le Λ aux₂)\n\n"}
