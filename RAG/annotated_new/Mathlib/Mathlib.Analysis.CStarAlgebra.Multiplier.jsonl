{"name":"DoubleCentralizer.central","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u\nA : Type v\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\nself : DoubleCentralizer ğ•œ A\nx y : A\nâŠ¢ Eq (HMul.hMul (self.toProd.2 x) y) (HMul.hMul x (self.toProd.1 y))","decl":"/-- The type of *double centralizers*, also known as the *multiplier algebra* and denoted by\n`ğ“œ(ğ•œ, A)`, of a non-unital normed algebra.\n\nIf `x : ğ“œ(ğ•œ, A)`, then `x.fst` and `x.snd` are what is usually referred to as $L$ and $R$. -/\nstructure DoubleCentralizer (ğ•œ : Type u) (A : Type v) [NontriviallyNormedField ğ•œ]\n    [NonUnitalNormedRing A] [NormedSpace ğ•œ A] [SMulCommClass ğ•œ A A] [IsScalarTower ğ•œ A A] extends\n    (A â†’L[ğ•œ] A) Ã— (A â†’L[ğ•œ] A) where\n  /-- The centrality condition that the maps linear maps intertwine one another. -/\n  central : âˆ€ x y : A, snd x * y = x * fst y\n\n"}
{"name":"DoubleCentralizer.mk.injEq","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u\nA : Type v\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\ntoProdâœ : Prod (ContinuousLinearMap (RingHom.id ğ•œ) A A) (ContinuousLinearMap (RingHom.id ğ•œ) A A)\ncentralâœ : âˆ€ (x y : A), Eq (HMul.hMul (toProdâœ.2 x) y) (HMul.hMul x (toProdâœ.1 y))\ntoProd : Prod (ContinuousLinearMap (RingHom.id ğ•œ) A A) (ContinuousLinearMap (RingHom.id ğ•œ) A A)\ncentral : âˆ€ (x y : A), Eq (HMul.hMul (toProd.2 x) y) (HMul.hMul x (toProd.1 y))\nâŠ¢ Eq (Eq { toProd := toProdâœ, central := centralâœ } { toProd := toProd, central := central }) (Eq toProdâœ toProd)","decl":"/-- The type of *double centralizers*, also known as the *multiplier algebra* and denoted by\n`ğ“œ(ğ•œ, A)`, of a non-unital normed algebra.\n\nIf `x : ğ“œ(ğ•œ, A)`, then `x.fst` and `x.snd` are what is usually referred to as $L$ and $R$. -/\nstructure DoubleCentralizer (ğ•œ : Type u) (A : Type v) [NontriviallyNormedField ğ•œ]\n    [NonUnitalNormedRing A] [NormedSpace ğ•œ A] [SMulCommClass ğ•œ A A] [IsScalarTower ğ•œ A A] extends\n    (A â†’L[ğ•œ] A) Ã— (A â†’L[ğ•œ] A) where\n  /-- The centrality condition that the maps linear maps intertwine one another. -/\n  central : âˆ€ x y : A, snd x * y = x * fst y\n\n"}
{"name":"DoubleCentralizer.mk.inj","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u\nA : Type v\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\ntoProdâœ : Prod (ContinuousLinearMap (RingHom.id ğ•œ) A A) (ContinuousLinearMap (RingHom.id ğ•œ) A A)\ncentralâœ : âˆ€ (x y : A), Eq (HMul.hMul (toProdâœ.2 x) y) (HMul.hMul x (toProdâœ.1 y))\ntoProd : Prod (ContinuousLinearMap (RingHom.id ğ•œ) A A) (ContinuousLinearMap (RingHom.id ğ•œ) A A)\ncentral : âˆ€ (x y : A), Eq (HMul.hMul (toProd.2 x) y) (HMul.hMul x (toProd.1 y))\nxâœ : Eq { toProd := toProdâœ, central := centralâœ } { toProd := toProd, central := central }\nâŠ¢ Eq toProdâœ toProd","decl":"/-- The type of *double centralizers*, also known as the *multiplier algebra* and denoted by\n`ğ“œ(ğ•œ, A)`, of a non-unital normed algebra.\n\nIf `x : ğ“œ(ğ•œ, A)`, then `x.fst` and `x.snd` are what is usually referred to as $L$ and $R$. -/\nstructure DoubleCentralizer (ğ•œ : Type u) (A : Type v) [NontriviallyNormedField ğ•œ]\n    [NonUnitalNormedRing A] [NormedSpace ğ•œ A] [SMulCommClass ğ•œ A A] [IsScalarTower ğ•œ A A] extends\n    (A â†’L[ğ•œ] A) Ã— (A â†’L[ğ•œ] A) where\n  /-- The centrality condition that the maps linear maps intertwine one another. -/\n  central : âˆ€ x y : A, snd x * y = x * fst y\n\n"}
{"name":"DoubleCentralizer.mk.sizeOf_spec","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u\nA : Type v\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NonUnitalNormedRing A\ninstâœâ´ : NormedSpace ğ•œ A\ninstâœÂ³ : SMulCommClass ğ•œ A A\ninstâœÂ² : IsScalarTower ğ•œ A A\ninstâœÂ¹ : SizeOf ğ•œ\ninstâœ : SizeOf A\ntoProd : Prod (ContinuousLinearMap (RingHom.id ğ•œ) A A) (ContinuousLinearMap (RingHom.id ğ•œ) A A)\ncentral : âˆ€ (x y : A), Eq (HMul.hMul (toProd.2 x) y) (HMul.hMul x (toProd.1 y))\nâŠ¢ Eq (SizeOf.sizeOf { toProd := toProd, central := central }) (HAdd.hAdd 1 (SizeOf.sizeOf toProd))","decl":"/-- The type of *double centralizers*, also known as the *multiplier algebra* and denoted by\n`ğ“œ(ğ•œ, A)`, of a non-unital normed algebra.\n\nIf `x : ğ“œ(ğ•œ, A)`, then `x.fst` and `x.snd` are what is usually referred to as $L$ and $R$. -/\nstructure DoubleCentralizer (ğ•œ : Type u) (A : Type v) [NontriviallyNormedField ğ•œ]\n    [NonUnitalNormedRing A] [NormedSpace ğ•œ A] [SMulCommClass ğ•œ A A] [IsScalarTower ğ•œ A A] extends\n    (A â†’L[ğ•œ] A) Ã— (A â†’L[ğ•œ] A) where\n  /-- The centrality condition that the maps linear maps intertwine one another. -/\n  central : âˆ€ x y : A, snd x * y = x * fst y\n\n"}
{"name":"DoubleCentralizer.ext","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u\nA : Type v\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\na b : DoubleCentralizer ğ•œ A\nh : Eq a.toProd b.toProd\nâŠ¢ Eq a b","decl":"@[ext]\nlemma DoubleCentralizer.ext (ğ•œ : Type u) (A : Type v) [NontriviallyNormedField ğ•œ]\n    [NonUnitalNormedRing A] [NormedSpace ğ•œ A] [SMulCommClass ğ•œ A A] [IsScalarTower ğ•œ A A]\n    (a b : ğ“œ(ğ•œ, A)) (h : a.toProd = b.toProd) : a = b := by\n  cases a\n  cases b\n  simpa using h\n\n"}
{"name":"DoubleCentralizer.ext_iff","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u\nA : Type v\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\na b : DoubleCentralizer ğ•œ A\nâŠ¢ Iff (Eq a b) (Eq a.toProd b.toProd)","decl":"@[ext]\nlemma DoubleCentralizer.ext (ğ•œ : Type u) (A : Type v) [NontriviallyNormedField ğ•œ]\n    [NonUnitalNormedRing A] [NormedSpace ğ•œ A] [SMulCommClass ğ•œ A A] [IsScalarTower ğ•œ A A]\n    (a b : ğ“œ(ğ•œ, A)) (h : a.toProd = b.toProd) : a = b := by\n  cases a\n  cases b\n  simpa using h\n\n"}
{"name":"DoubleCentralizer.range_toProd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\nâŠ¢ Eq (Set.range DoubleCentralizer.toProd) (setOf fun lr => âˆ€ (x y : A), Eq (HMul.hMul (lr.2 x) y) (HMul.hMul x (lr.1 y)))","decl":"theorem range_toProd :\n    Set.range toProd = { lr : (A â†’L[ğ•œ] A) Ã— (A â†’L[ğ•œ] A) | âˆ€ x y, lr.2 x * y = x * lr.1 y } :=\n  Set.ext fun x =>\n    âŸ¨by\n      rintro âŸ¨a, rflâŸ©\n      exact a.central, fun hx => âŸ¨âŸ¨x, hxâŸ©, rflâŸ©âŸ©\n\n"}
{"name":"DoubleCentralizer.smul_toProd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : NonUnitalNormedRing A\ninstâœâ¸ : NormedSpace ğ•œ A\ninstâœâ· : SMulCommClass ğ•œ A A\ninstâœâ¶ : IsScalarTower ğ•œ A A\nS : Type u_3\ninstâœâµ : Monoid S\ninstâœâ´ : DistribMulAction S A\ninstâœÂ³ : SMulCommClass ğ•œ S A\ninstâœÂ² : ContinuousConstSMul S A\ninstâœÂ¹ : IsScalarTower S A A\ninstâœ : SMulCommClass S A A\ns : S\na : DoubleCentralizer ğ•œ A\nâŠ¢ Eq (HSMul.hSMul s a).toProd (HSMul.hSMul s a.toProd)","decl":"@[simp]\ntheorem smul_toProd (s : S) (a : ğ“œ(ğ•œ, A)) : (s â€¢ a).toProd = s â€¢ a.toProd :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.smul_fst","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : NonUnitalNormedRing A\ninstâœâ¸ : NormedSpace ğ•œ A\ninstâœâ· : SMulCommClass ğ•œ A A\ninstâœâ¶ : IsScalarTower ğ•œ A A\nS : Type u_3\ninstâœâµ : Monoid S\ninstâœâ´ : DistribMulAction S A\ninstâœÂ³ : SMulCommClass ğ•œ S A\ninstâœÂ² : ContinuousConstSMul S A\ninstâœÂ¹ : IsScalarTower S A A\ninstâœ : SMulCommClass S A A\ns : S\na : DoubleCentralizer ğ•œ A\nâŠ¢ Eq (HSMul.hSMul s a).toProd.1 (HSMul.hSMul s a.toProd.1)","decl":"theorem smul_fst (s : S) (a : ğ“œ(ğ•œ, A)) : (s â€¢ a).fst = s â€¢ a.fst :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.smul_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : NonUnitalNormedRing A\ninstâœâ¸ : NormedSpace ğ•œ A\ninstâœâ· : SMulCommClass ğ•œ A A\ninstâœâ¶ : IsScalarTower ğ•œ A A\nS : Type u_3\ninstâœâµ : Monoid S\ninstâœâ´ : DistribMulAction S A\ninstâœÂ³ : SMulCommClass ğ•œ S A\ninstâœÂ² : ContinuousConstSMul S A\ninstâœÂ¹ : IsScalarTower S A A\ninstâœ : SMulCommClass S A A\ns : S\na : DoubleCentralizer ğ•œ A\nâŠ¢ Eq (HSMul.hSMul s a).toProd.2 (HSMul.hSMul s a.toProd.2)","decl":"theorem smul_snd (s : S) (a : ğ“œ(ğ•œ, A)) : (s â€¢ a).snd = s â€¢ a.snd :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.instIsScalarTower","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ¹â´ : NontriviallyNormedField ğ•œ\ninstâœÂ¹Â³ : NonUnitalNormedRing A\ninstâœÂ¹Â² : NormedSpace ğ•œ A\ninstâœÂ¹Â¹ : SMulCommClass ğ•œ A A\ninstâœÂ¹â° : IsScalarTower ğ•œ A A\nS : Type u_3\ninstâœâ¹ : Monoid S\ninstâœâ¸ : DistribMulAction S A\ninstâœâ· : SMulCommClass ğ•œ S A\ninstâœâ¶ : ContinuousConstSMul S A\nT : Type u_4\ninstâœâµ : Monoid T\ninstâœâ´ : DistribMulAction T A\ninstâœÂ³ : SMulCommClass ğ•œ T A\ninstâœÂ² : ContinuousConstSMul T A\ninstâœÂ¹ : SMul S T\ninstâœ : IsScalarTower S T A\nâŠ¢ IsScalarTower S T (DoubleCentralizer ğ•œ A)","decl":"instance instIsScalarTower [SMul S T] [IsScalarTower S T A] : IsScalarTower S T ğ“œ(ğ•œ, A) where\n  smul_assoc _ _ a := ext (ğ•œ := ğ•œ) (A := A) _ _ <| smul_assoc _ _ a.toProd\n\n"}
{"name":"DoubleCentralizer.instSMulCommClass","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ¹Â³ : NontriviallyNormedField ğ•œ\ninstâœÂ¹Â² : NonUnitalNormedRing A\ninstâœÂ¹Â¹ : NormedSpace ğ•œ A\ninstâœÂ¹â° : SMulCommClass ğ•œ A A\ninstâœâ¹ : IsScalarTower ğ•œ A A\nS : Type u_3\ninstâœâ¸ : Monoid S\ninstâœâ· : DistribMulAction S A\ninstâœâ¶ : SMulCommClass ğ•œ S A\ninstâœâµ : ContinuousConstSMul S A\nT : Type u_4\ninstâœâ´ : Monoid T\ninstâœÂ³ : DistribMulAction T A\ninstâœÂ² : SMulCommClass ğ•œ T A\ninstâœÂ¹ : ContinuousConstSMul T A\ninstâœ : SMulCommClass S T A\nâŠ¢ SMulCommClass S T (DoubleCentralizer ğ•œ A)","decl":"instance instSMulCommClass [SMulCommClass S T A] : SMulCommClass S T ğ“œ(ğ•œ, A) where\n  smul_comm _ _ a := ext (ğ•œ := ğ•œ) (A := A) _ _ <| smul_comm _ _ a.toProd\n\n"}
{"name":"DoubleCentralizer.instIsCentralScalar","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ¹Â² : NontriviallyNormedField ğ•œ\ninstâœÂ¹Â¹ : NonUnitalNormedRing A\ninstâœÂ¹â° : NormedSpace ğ•œ A\ninstâœâ¹ : SMulCommClass ğ•œ A A\ninstâœâ¸ : IsScalarTower ğ•œ A A\nR : Type u_5\ninstâœâ· : Semiring R\ninstâœâ¶ : Module R A\ninstâœâµ : SMulCommClass ğ•œ R A\ninstâœâ´ : ContinuousConstSMul R A\ninstâœÂ³ : IsScalarTower R A A\ninstâœÂ² : SMulCommClass R A A\ninstâœÂ¹ : Module (MulOpposite R) A\ninstâœ : IsCentralScalar R A\nâŠ¢ IsCentralScalar R (DoubleCentralizer ğ•œ A)","decl":"instance instIsCentralScalar {R : Type*} [Semiring R] [Module R A] [SMulCommClass ğ•œ R A]\n    [ContinuousConstSMul R A] [IsScalarTower R A A] [SMulCommClass R A A] [Module Ráµáµ’áµ– A]\n    [IsCentralScalar R A] : IsCentralScalar R ğ“œ(ğ•œ, A) where\n  op_smul_eq_smul _ a := ext (ğ•œ := ğ•œ) (A := A) _ _ <| op_smul_eq_smul _ a.toProd\n\n"}
{"name":"DoubleCentralizer.add_toProd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\na b : DoubleCentralizer ğ•œ A\nâŠ¢ Eq (HAdd.hAdd a b).toProd (HAdd.hAdd a.toProd b.toProd)","decl":"@[simp]\ntheorem add_toProd (a b : ğ“œ(ğ•œ, A)) : (a + b).toProd = a.toProd + b.toProd :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.zero_toProd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\nâŠ¢ Eq (DoubleCentralizer.toProd 0) 0","decl":"@[simp]\ntheorem zero_toProd : (0 : ğ“œ(ğ•œ, A)).toProd = 0 :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.neg_toProd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\na : DoubleCentralizer ğ•œ A\nâŠ¢ Eq (Neg.neg a).toProd (Neg.neg a.toProd)","decl":"@[simp]\ntheorem neg_toProd (a : ğ“œ(ğ•œ, A)) : (-a).toProd = -a.toProd :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.sub_toProd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\na b : DoubleCentralizer ğ•œ A\nâŠ¢ Eq (HSub.hSub a b).toProd (HSub.hSub a.toProd b.toProd)","decl":"@[simp]\ntheorem sub_toProd (a b : ğ“œ(ğ•œ, A)) : (a - b).toProd = a.toProd - b.toProd :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.one_toProd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\nâŠ¢ Eq (DoubleCentralizer.toProd 1) 1","decl":"@[simp]\ntheorem one_toProd : (1 : ğ“œ(ğ•œ, A)).toProd = 1 :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.natCast_toProd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\nn : Nat\nâŠ¢ Eq (â†‘n).toProd â†‘n","decl":"@[simp]\ntheorem natCast_toProd (n : â„•) : (n : ğ“œ(ğ•œ, A)).toProd = n :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.intCast_toProd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\nn : Int\nâŠ¢ Eq (â†‘n).toProd â†‘n","decl":"@[simp]\ntheorem intCast_toProd (n : â„¤) : (n : ğ“œ(ğ•œ, A)).toProd = n :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.pow_toProd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\nn : Nat\na : DoubleCentralizer ğ•œ A\nâŠ¢ Eq (HPow.hPow a n).toProd (HPow.hPow a.toProd n)","decl":"@[simp]\ntheorem pow_toProd (n : â„•) (a : ğ“œ(ğ•œ, A)) : (a ^ n).toProd = a.toProd ^ n :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.add_fst","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\na b : DoubleCentralizer ğ•œ A\nâŠ¢ Eq (HAdd.hAdd a b).toProd.1 (HAdd.hAdd a.toProd.1 b.toProd.1)","decl":"theorem add_fst (a b : ğ“œ(ğ•œ, A)) : (a + b).fst = a.fst + b.fst :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.add_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\na b : DoubleCentralizer ğ•œ A\nâŠ¢ Eq (HAdd.hAdd a b).toProd.2 (HAdd.hAdd a.toProd.2 b.toProd.2)","decl":"theorem add_snd (a b : ğ“œ(ğ•œ, A)) : (a + b).snd = a.snd + b.snd :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.zero_fst","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\nâŠ¢ Eq (DoubleCentralizer.toProd 0).1 0","decl":"theorem zero_fst : (0 : ğ“œ(ğ•œ, A)).fst = 0 :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.zero_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\nâŠ¢ Eq (DoubleCentralizer.toProd 0).2 0","decl":"theorem zero_snd : (0 : ğ“œ(ğ•œ, A)).snd = 0 :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.neg_fst","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\na : DoubleCentralizer ğ•œ A\nâŠ¢ Eq (Neg.neg a).toProd.1 (Neg.neg a.toProd.1)","decl":"theorem neg_fst (a : ğ“œ(ğ•œ, A)) : (-a).fst = -a.fst :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.neg_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\na : DoubleCentralizer ğ•œ A\nâŠ¢ Eq (Neg.neg a).toProd.2 (Neg.neg a.toProd.2)","decl":"theorem neg_snd (a : ğ“œ(ğ•œ, A)) : (-a).snd = -a.snd :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.sub_fst","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\na b : DoubleCentralizer ğ•œ A\nâŠ¢ Eq (HSub.hSub a b).toProd.1 (HSub.hSub a.toProd.1 b.toProd.1)","decl":"theorem sub_fst (a b : ğ“œ(ğ•œ, A)) : (a - b).fst = a.fst - b.fst :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.sub_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\na b : DoubleCentralizer ğ•œ A\nâŠ¢ Eq (HSub.hSub a b).toProd.2 (HSub.hSub a.toProd.2 b.toProd.2)","decl":"theorem sub_snd (a b : ğ“œ(ğ•œ, A)) : (a - b).snd = a.snd - b.snd :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.one_fst","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\nâŠ¢ Eq (DoubleCentralizer.toProd 1).1 1","decl":"theorem one_fst : (1 : ğ“œ(ğ•œ, A)).fst = 1 :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.one_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\nâŠ¢ Eq (DoubleCentralizer.toProd 1).2 1","decl":"theorem one_snd : (1 : ğ“œ(ğ•œ, A)).snd = 1 :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.mul_fst","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\na b : DoubleCentralizer ğ•œ A\nâŠ¢ Eq (HMul.hMul a b).toProd.1 (HMul.hMul a.toProd.1 b.toProd.1)","decl":"@[simp]\ntheorem mul_fst (a b : ğ“œ(ğ•œ, A)) : (a * b).fst = a.fst * b.fst :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.mul_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\na b : DoubleCentralizer ğ•œ A\nâŠ¢ Eq (HMul.hMul a b).toProd.2 (HMul.hMul b.toProd.2 a.toProd.2)","decl":"@[simp]\ntheorem mul_snd (a b : ğ“œ(ğ•œ, A)) : (a * b).snd = b.snd * a.snd :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.natCast_fst","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\nn : Nat\nâŠ¢ Eq (â†‘n).toProd.1 â†‘n","decl":"theorem natCast_fst (n : â„•) : (n : ğ“œ(ğ•œ, A)).fst = n :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.natCast_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\nn : Nat\nâŠ¢ Eq (â†‘n).toProd.2 â†‘n","decl":"theorem natCast_snd (n : â„•) : (n : ğ“œ(ğ•œ, A)).snd = n :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.intCast_fst","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\nn : Int\nâŠ¢ Eq (â†‘n).toProd.1 â†‘n","decl":"theorem intCast_fst (n : â„¤) : (n : ğ“œ(ğ•œ, A)).fst = n :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.intCast_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\nn : Int\nâŠ¢ Eq (â†‘n).toProd.2 â†‘n","decl":"theorem intCast_snd (n : â„¤) : (n : ğ“œ(ğ•œ, A)).snd = n :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.pow_fst","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\nn : Nat\na : DoubleCentralizer ğ•œ A\nâŠ¢ Eq (HPow.hPow a n).toProd.1 (HPow.hPow a.toProd.1 n)","decl":"theorem pow_fst (n : â„•) (a : ğ“œ(ğ•œ, A)) : (a ^ n).fst = a.fst ^ n :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.pow_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\nn : Nat\na : DoubleCentralizer ğ•œ A\nâŠ¢ Eq (HPow.hPow a n).toProd.2 (HPow.hPow a.toProd.2 n)","decl":"theorem pow_snd (n : â„•) (a : ğ“œ(ğ•œ, A)) : (a ^ n).snd = a.snd ^ n :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.toProdMulOpposite_injective","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\nâŠ¢ Function.Injective DoubleCentralizer.toProdMulOpposite","decl":"theorem toProdMulOpposite_injective :\n    Function.Injective (toProdMulOpposite : ğ“œ(ğ•œ, A) â†’ (A â†’L[ğ•œ] A) Ã— (A â†’L[ğ•œ] A)áµáµ’áµ–) :=\n  fun _a _b h =>\n    let h' := Prod.ext_iff.mp h\n    ext (ğ•œ := ğ•œ) (A := A) _ _ <| Prod.ext h'.1 <| MulOpposite.op_injective h'.2\n\n"}
{"name":"DoubleCentralizer.range_toProdMulOpposite","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\nâŠ¢ Eq (Set.range DoubleCentralizer.toProdMulOpposite) (setOf fun lr => âˆ€ (x y : A), Eq (HMul.hMul ((MulOpposite.unop lr.2) x) y) (HMul.hMul x (lr.1 y)))","decl":"theorem range_toProdMulOpposite :\n    Set.range toProdMulOpposite =\n      { lr : (A â†’L[ğ•œ] A) Ã— (A â†’L[ğ•œ] A)áµáµ’áµ– | âˆ€ x y, unop lr.2 x * y = x * lr.1 y } :=\n  Set.ext fun x =>\n    âŸ¨by\n      rintro âŸ¨a, rflâŸ©\n      exact a.central, fun hx => âŸ¨âŸ¨(x.1, unop x.2), hxâŸ©, Prod.ext rfl rflâŸ©âŸ©\n\n"}
{"name":"DoubleCentralizer.toProdHom_apply","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\nself : DoubleCentralizer ğ•œ A\nâŠ¢ Eq (DoubleCentralizer.toProdHom self) self.toProd","decl":"/-- The canonical map `DoubleCentralizer.toProd` as an additive group homomorphism. -/\n@[simps]\ndef toProdHom : ğ“œ(ğ•œ, A) â†’+ (A â†’L[ğ•œ] A) Ã— (A â†’L[ğ•œ] A) where\n  toFun := toProd\n  map_zero' := rfl\n  map_add' _x _y := rfl\n\n"}
{"name":"DoubleCentralizer.toProdMulOppositeHom_apply","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\naâœ : DoubleCentralizer ğ•œ A\nâŠ¢ Eq (DoubleCentralizer.toProdMulOppositeHom aâœ) aâœ.toProdMulOpposite","decl":"/-- The canonical map `DoubleCentralizer.toProdMulOpposite` as a ring homomorphism. -/\n@[simps]\ndef toProdMulOppositeHom : ğ“œ(ğ•œ, A) â†’+* (A â†’L[ğ•œ] A) Ã— (A â†’L[ğ•œ] A)áµáµ’áµ– where\n  toFun := toProdMulOpposite\n  map_zero' := rfl\n  map_one' := rfl\n  map_add' _x _y := rfl\n  map_mul' _x _y := rfl\n\n"}
{"name":"DoubleCentralizer.algebraMap_toProd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\nk : ğ•œ\nâŠ¢ Eq ((algebraMap ğ•œ (DoubleCentralizer ğ•œ A)) k).toProd ((algebraMap ğ•œ (Prod (ContinuousLinearMap (RingHom.id ğ•œ) A A) (ContinuousLinearMap (RingHom.id ğ•œ) A A))) k)","decl":"@[simp]\ntheorem algebraMap_toProd (k : ğ•œ) : (algebraMap ğ•œ ğ“œ(ğ•œ, A) k).toProd = algebraMap ğ•œ _ k :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.algebraMap_fst","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\nk : ğ•œ\nâŠ¢ Eq ((algebraMap ğ•œ (DoubleCentralizer ğ•œ A)) k).toProd.1 ((algebraMap ğ•œ (ContinuousLinearMap (RingHom.id ğ•œ) A A)) k)","decl":"theorem algebraMap_fst (k : ğ•œ) : (algebraMap ğ•œ ğ“œ(ğ•œ, A) k).fst = algebraMap ğ•œ _ k :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.algebraMap_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\nk : ğ•œ\nâŠ¢ Eq ((algebraMap ğ•œ (DoubleCentralizer ğ•œ A)) k).toProd.2 ((algebraMap ğ•œ (ContinuousLinearMap (RingHom.id ğ•œ) A A)) k)","decl":"theorem algebraMap_snd (k : ğ•œ) : (algebraMap ğ•œ ğ“œ(ğ•œ, A) k).snd = algebraMap ğ•œ _ k :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.star_fst","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ¸ : NontriviallyNormedField ğ•œ\ninstâœâ· : NonUnitalNormedRing A\ninstâœâ¶ : NormedSpace ğ•œ A\ninstâœâµ : SMulCommClass ğ•œ A A\ninstâœâ´ : IsScalarTower ğ•œ A A\ninstâœÂ³ : StarRing ğ•œ\ninstâœÂ² : StarRing A\ninstâœÂ¹ : StarModule ğ•œ A\ninstâœ : NormedStarGroup A\na : DoubleCentralizer ğ•œ A\nb : A\nâŠ¢ Eq ((Star.star a).toProd.1 b) (Star.star (a.toProd.2 (Star.star b)))","decl":"@[simp]\ntheorem star_fst (a : ğ“œ(ğ•œ, A)) (b : A) : (star a).fst b = star (a.snd (star b)) :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.star_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ¸ : NontriviallyNormedField ğ•œ\ninstâœâ· : NonUnitalNormedRing A\ninstâœâ¶ : NormedSpace ğ•œ A\ninstâœâµ : SMulCommClass ğ•œ A A\ninstâœâ´ : IsScalarTower ğ•œ A A\ninstâœÂ³ : StarRing ğ•œ\ninstâœÂ² : StarRing A\ninstâœÂ¹ : StarModule ğ•œ A\ninstâœ : NormedStarGroup A\na : DoubleCentralizer ğ•œ A\nb : A\nâŠ¢ Eq ((Star.star a).toProd.2 b) (Star.star (a.toProd.1 (Star.star b)))","decl":"@[simp]\ntheorem star_snd (a : ğ“œ(ğ•œ, A)) (b : A) : (star a).snd b = star (a.fst (star b)) :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.instStarModule","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ¸ : NontriviallyNormedField ğ•œ\ninstâœâ· : NonUnitalNormedRing A\ninstâœâ¶ : NormedSpace ğ•œ A\ninstâœâµ : SMulCommClass ğ•œ A A\ninstâœâ´ : IsScalarTower ğ•œ A A\ninstâœÂ³ : StarRing ğ•œ\ninstâœÂ² : StarRing A\ninstâœÂ¹ : StarModule ğ•œ A\ninstâœ : NormedStarGroup A\nâŠ¢ StarModule ğ•œ (DoubleCentralizer ğ•œ A)","decl":"instance instStarModule : StarModule ğ•œ ğ“œ(ğ•œ, A) :=\n  { DoubleCentralizer.instStarAddMonoid (ğ•œ := ğ•œ) (A := A) with\n    star_smul := fun k a => by ext <;> exact star_smul _ _ }\n\n"}
{"name":"DoubleCentralizer.coe_fst","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\na : A\nâŠ¢ Eq (â†‘ğ•œ a).toProd.1 ((ContinuousLinearMap.mul ğ•œ A) a)","decl":"@[simp, norm_cast]\ntheorem coe_fst (a : A) : (a : ğ“œ(ğ•œ, A)).fst = ContinuousLinearMap.mul ğ•œ A a :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.coe_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\na : A\nâŠ¢ Eq (â†‘ğ•œ a).toProd.2 ((ContinuousLinearMap.mul ğ•œ A).flip a)","decl":"@[simp, norm_cast]\ntheorem coe_snd (a : A) : (a : ğ“œ(ğ•œ, A)).snd = (ContinuousLinearMap.mul ğ•œ A).flip a :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.coe_eq_algebraMap","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\nâŠ¢ Eq â†‘ğ•œ â‡‘(algebraMap ğ•œ (DoubleCentralizer ğ•œ ğ•œ))","decl":"theorem coe_eq_algebraMap : (DoubleCentralizer.coe ğ•œ : ğ•œ â†’ ğ“œ(ğ•œ, ğ•œ)) = algebraMap ğ•œ ğ“œ(ğ•œ, ğ•œ) := by\n  ext x : 3\n  Â· rfl -- `fst` is defeq\n  Â· refine ContinuousLinearMap.ext fun y => ?_\n    exact mul_comm y x  -- `snd` multiplies on the wrong side\n\n"}
{"name":"DoubleCentralizer.coeHom_apply","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ¸ : NontriviallyNormedField ğ•œ\ninstâœâ· : NonUnitalNormedRing A\ninstâœâ¶ : NormedSpace ğ•œ A\ninstâœâµ : SMulCommClass ğ•œ A A\ninstâœâ´ : IsScalarTower ğ•œ A A\ninstâœÂ³ : StarRing ğ•œ\ninstâœÂ² : StarRing A\ninstâœÂ¹ : StarModule ğ•œ A\ninstâœ : NormedStarGroup A\na : A\nâŠ¢ Eq (DoubleCentralizer.coeHom a) (â†‘ğ•œ a)","decl":"/-- The coercion of an algebra into its multiplier algebra as a non-unital star algebra\nhomomorphism. -/\n@[simps]\nnoncomputable def coeHom [StarRing ğ•œ] [StarRing A] [StarModule ğ•œ A] [NormedStarGroup A] :\n    A â†’â‹†â‚™â‚[ğ•œ] ğ“œ(ğ•œ, A) where\n  toFun a := a\n  map_smul' _ _ := ext _ _ _ _ <| Prod.ext (map_smul _ _ _) (map_smul _ _ _)\n  map_zero' := ext _ _ _ _ <| Prod.ext (map_zero _) (map_zero _)\n  map_add' _ _ := ext _ _ _ _ <| Prod.ext (map_add _ _ _) (map_add _ _ _)\n  map_mul' _ _ := ext _ _ _ _ <| Prod.ext\n    (ContinuousLinearMap.ext fun _ => (mul_assoc _ _ _))\n    (ContinuousLinearMap.ext fun _ => (mul_assoc _ _ _).symm)\n  map_star' _ := ext _ _ _ _ <| Prod.ext\n    (ContinuousLinearMap.ext fun _ => (star_star_mul _ _).symm)\n    (ContinuousLinearMap.ext fun _ => (star_mul_star _ _).symm)\n\n"}
{"name":"DoubleCentralizer.norm_def","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\na : DoubleCentralizer ğ•œ A\nâŠ¢ Eq (Norm.norm a) (Norm.norm (DoubleCentralizer.toProdHom a))","decl":"theorem norm_def (a : ğ“œ(ğ•œ, A)) : â€–aâ€– = â€–toProdHom aâ€– :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.nnnorm_def","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\na : DoubleCentralizer ğ•œ A\nâŠ¢ Eq (NNNorm.nnnorm a) (NNNorm.nnnorm (DoubleCentralizer.toProdHom a))","decl":"theorem nnnorm_def (a : ğ“œ(ğ•œ, A)) : â€–aâ€–â‚Š = â€–toProdHom aâ€–â‚Š :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.norm_def'","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\na : DoubleCentralizer ğ•œ A\nâŠ¢ Eq (Norm.norm a) (Norm.norm (DoubleCentralizer.toProdMulOppositeHom a))","decl":"theorem norm_def' (a : ğ“œ(ğ•œ, A)) : â€–aâ€– = â€–toProdMulOppositeHom aâ€– :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.nnnorm_def'","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\na : DoubleCentralizer ğ•œ A\nâŠ¢ Eq (NNNorm.nnnorm a) (NNNorm.nnnorm (DoubleCentralizer.toProdMulOppositeHom a))","decl":"theorem nnnorm_def' (a : ğ“œ(ğ•œ, A)) : â€–aâ€–â‚Š = â€–toProdMulOppositeHom aâ€–â‚Š :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.isUniformEmbedding_toProdMulOpposite","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\nâŠ¢ IsUniformEmbedding DoubleCentralizer.toProdMulOpposite","decl":"theorem isUniformEmbedding_toProdMulOpposite :\n    IsUniformEmbedding (toProdMulOpposite (ğ•œ := ğ•œ) (A := A)) :=\n  isUniformEmbedding_comap toProdMulOpposite_injective\n\n"}
{"name":"DoubleCentralizer.uniformEmbedding_toProdMulOpposite","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing A\ninstâœÂ² : NormedSpace ğ•œ A\ninstâœÂ¹ : SMulCommClass ğ•œ A A\ninstâœ : IsScalarTower ğ•œ A A\nâŠ¢ IsUniformEmbedding DoubleCentralizer.toProdMulOpposite","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_toProdMulOpposite := isUniformEmbedding_toProdMulOpposite\n\n"}
{"name":"DoubleCentralizer.instCompleteSpace","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NonUnitalNormedRing A\ninstâœÂ³ : NormedSpace ğ•œ A\ninstâœÂ² : SMulCommClass ğ•œ A A\ninstâœÂ¹ : IsScalarTower ğ•œ A A\ninstâœ : CompleteSpace A\nâŠ¢ CompleteSpace (DoubleCentralizer ğ•œ A)","decl":"instance [CompleteSpace A] : CompleteSpace ğ“œ(ğ•œ, A) := by\n  rw [completeSpace_iff_isComplete_range isUniformEmbedding_toProdMulOpposite.isUniformInducing]\n  apply IsClosed.isComplete\n  simp only [range_toProdMulOpposite, Set.setOf_forall]\n  refine isClosed_iInter fun x => isClosed_iInter fun y => isClosed_eq ?_ ?_\n  Â· exact\n      ((ContinuousLinearMap.apply ğ•œ A _).continuous.comp <| continuous_unop.comp continuous_snd).mul\n        continuous_const\n  exact continuous_const.mul ((ContinuousLinearMap.apply ğ•œ A _).continuous.comp continuous_fst)\n\n"}
{"name":"DoubleCentralizer.norm_fst_eq_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NonUnitalNormedRing A\ninstâœâ´ : NormedSpace ğ•œ A\ninstâœÂ³ : SMulCommClass ğ•œ A A\ninstâœÂ² : IsScalarTower ğ•œ A A\ninstâœÂ¹ : StarRing A\ninstâœ : CStarRing A\na : DoubleCentralizer ğ•œ A\nâŠ¢ Eq (Norm.norm a.toProd.1) (Norm.norm a.toProd.2)","decl":"/-- For `a : ğ“œ(ğ•œ, A)`, the norms of `a.fst` and `a.snd` coincide, and hence these\nalso coincide with `â€–aâ€–` which is `max (â€–a.fstâ€–) (â€–a.sndâ€–)`. -/\ntheorem norm_fst_eq_snd (a : ğ“œ(ğ•œ, A)) : â€–a.fstâ€– = â€–a.sndâ€– := by\n  -- a handy lemma for this proof\n  have h0 : âˆ€ f : A â†’L[ğ•œ] A, âˆ€ C : â„â‰¥0, (âˆ€ b : A, â€–f bâ€–â‚Š ^ 2 â‰¤ C * â€–f bâ€–â‚Š * â€–bâ€–â‚Š) â†’ â€–fâ€–â‚Š â‰¤ C := by\n    intro f C h\n    have h1 : âˆ€ b, C * â€–f bâ€–â‚Š * â€–bâ€–â‚Š â‰¤ C * â€–fâ€–â‚Š * â€–bâ€–â‚Š ^ 2 := by\n      intro b\n      convert mul_le_mul_right' (mul_le_mul_left' (f.le_opNNNorm b) C) â€–bâ€–â‚Š using 1\n      ring\n    have := NNReal.div_le_of_le_mul <| f.opNNNorm_le_bound _ <| by\n      simpa only [sqrt_sq, sqrt_mul] using fun b â†¦ sqrt_le_sqrt.2 <| (h b).trans (h1 b)\n    convert NNReal.rpow_le_rpow this two_pos.le\n    Â· simp only [NNReal.rpow_two, div_pow, sq_sqrt]\n      simp only [sq, mul_self_div_self]\n    Â· simp only [NNReal.rpow_two, sq_sqrt]\n  have h1 : âˆ€ b, â€–a.fst bâ€–â‚Š ^ 2 â‰¤ â€–a.sndâ€–â‚Š * â€–a.fst bâ€–â‚Š * â€–bâ€–â‚Š := by\n    intro b\n    calc\n      â€–a.fst bâ€–â‚Š ^ 2 = â€–star (a.fst b) * a.fst bâ€–â‚Š := by\n        simpa only [â† sq] using CStarRing.nnnorm_star_mul_self.symm\n      _ â‰¤ â€–a.snd (star (a.fst b))â€–â‚Š * â€–bâ€–â‚Š := (a.central (star (a.fst b)) b â–¸ nnnorm_mul_le _ _)\n      _ â‰¤ â€–a.sndâ€–â‚Š * â€–a.fst bâ€–â‚Š * â€–bâ€–â‚Š :=\n        nnnorm_star (a.fst b) â–¸ mul_le_mul_right' (a.snd.le_opNNNorm _) _\n\n  have h2 : âˆ€ b, â€–a.snd bâ€–â‚Š ^ 2 â‰¤ â€–a.fstâ€–â‚Š * â€–a.snd bâ€–â‚Š * â€–bâ€–â‚Š := by\n    intro b\n    calc\n      â€–a.snd bâ€–â‚Š ^ 2 = â€–a.snd b * star (a.snd b)â€–â‚Š := by\n        simpa only [â† sq] using CStarRing.nnnorm_self_mul_star.symm\n      _ â‰¤ â€–bâ€–â‚Š * â€–a.fst (star (a.snd b))â€–â‚Š :=\n        ((a.central b (star (a.snd b))).symm â–¸ nnnorm_mul_le _ _)\n      _ = â€–a.fst (star (a.snd b))â€–â‚Š * â€–bâ€–â‚Š := mul_comm _ _\n      _ â‰¤ â€–a.fstâ€–â‚Š * â€–a.snd bâ€–â‚Š * â€–bâ€–â‚Š :=\n        nnnorm_star (a.snd b) â–¸ mul_le_mul_right' (a.fst.le_opNNNorm _) _\n\n  exact le_antisymm (h0 _ _ h1) (h0 _ _ h2)\n\n"}
{"name":"DoubleCentralizer.nnnorm_fst_eq_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NonUnitalNormedRing A\ninstâœâ´ : NormedSpace ğ•œ A\ninstâœÂ³ : SMulCommClass ğ•œ A A\ninstâœÂ² : IsScalarTower ğ•œ A A\ninstâœÂ¹ : StarRing A\ninstâœ : CStarRing A\na : DoubleCentralizer ğ•œ A\nâŠ¢ Eq (NNNorm.nnnorm a.toProd.1) (NNNorm.nnnorm a.toProd.2)","decl":"theorem nnnorm_fst_eq_snd (a : ğ“œ(ğ•œ, A)) : â€–a.fstâ€–â‚Š = â€–a.sndâ€–â‚Š :=\n  Subtype.ext <| norm_fst_eq_snd a\n\n"}
{"name":"DoubleCentralizer.norm_fst","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NonUnitalNormedRing A\ninstâœâ´ : NormedSpace ğ•œ A\ninstâœÂ³ : SMulCommClass ğ•œ A A\ninstâœÂ² : IsScalarTower ğ•œ A A\ninstâœÂ¹ : StarRing A\ninstâœ : CStarRing A\na : DoubleCentralizer ğ•œ A\nâŠ¢ Eq (Norm.norm a.toProd.1) (Norm.norm a)","decl":"@[simp]\ntheorem norm_fst (a : ğ“œ(ğ•œ, A)) : â€–a.fstâ€– = â€–aâ€– := by\n  simp only [norm_def, toProdHom_apply, Prod.norm_def, norm_fst_eq_snd, max_eq_right le_rfl]\n\n"}
{"name":"DoubleCentralizer.norm_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NonUnitalNormedRing A\ninstâœâ´ : NormedSpace ğ•œ A\ninstâœÂ³ : SMulCommClass ğ•œ A A\ninstâœÂ² : IsScalarTower ğ•œ A A\ninstâœÂ¹ : StarRing A\ninstâœ : CStarRing A\na : DoubleCentralizer ğ•œ A\nâŠ¢ Eq (Norm.norm a.toProd.2) (Norm.norm a)","decl":"@[simp]\ntheorem norm_snd (a : ğ“œ(ğ•œ, A)) : â€–a.sndâ€– = â€–aâ€– := by rw [â† norm_fst, norm_fst_eq_snd]\n\n"}
{"name":"DoubleCentralizer.nnnorm_fst","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NonUnitalNormedRing A\ninstâœâ´ : NormedSpace ğ•œ A\ninstâœÂ³ : SMulCommClass ğ•œ A A\ninstâœÂ² : IsScalarTower ğ•œ A A\ninstâœÂ¹ : StarRing A\ninstâœ : CStarRing A\na : DoubleCentralizer ğ•œ A\nâŠ¢ Eq (NNNorm.nnnorm a.toProd.1) (NNNorm.nnnorm a)","decl":"@[simp]\ntheorem nnnorm_fst (a : ğ“œ(ğ•œ, A)) : â€–a.fstâ€–â‚Š = â€–aâ€–â‚Š :=\n  Subtype.ext (norm_fst a)\n\n"}
{"name":"DoubleCentralizer.nnnorm_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NonUnitalNormedRing A\ninstâœâ´ : NormedSpace ğ•œ A\ninstâœÂ³ : SMulCommClass ğ•œ A A\ninstâœÂ² : IsScalarTower ğ•œ A A\ninstâœÂ¹ : StarRing A\ninstâœ : CStarRing A\na : DoubleCentralizer ğ•œ A\nâŠ¢ Eq (NNNorm.nnnorm a.toProd.2) (NNNorm.nnnorm a)","decl":"@[simp]\ntheorem nnnorm_snd (a : ğ“œ(ğ•œ, A)) : â€–a.sndâ€–â‚Š = â€–aâ€–â‚Š :=\n  Subtype.ext (norm_snd a)\n\n"}
{"name":"DoubleCentralizer.instCStarRing","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ¸ : DenselyNormedField ğ•œ\ninstâœâ· : StarRing ğ•œ\ninstâœâ¶ : NonUnitalNormedRing A\ninstâœâµ : StarRing A\ninstâœâ´ : CStarRing A\ninstâœÂ³ : NormedSpace ğ•œ A\ninstâœÂ² : SMulCommClass ğ•œ A A\ninstâœÂ¹ : IsScalarTower ğ•œ A A\ninstâœ : StarModule ğ•œ A\nâŠ¢ CStarRing (DoubleCentralizer ğ•œ A)","decl":"instance instCStarRing : CStarRing ğ“œ(ğ•œ, A) where\n  norm_mul_self_le := fun (a : ğ“œ(ğ•œ, A)) => le_of_eq <| Eq.symm <| congr_arg ((â†‘) : â„â‰¥0 â†’ â„) <|\n    show â€–star a * aâ€–â‚Š = â€–aâ€–â‚Š * â€–aâ€–â‚Š by\n    /- The essence of the argument is this: let `a = (L,R)` and recall `â€–aâ€– = â€–Lâ€–`.\n    `star a = (star âˆ˜ R âˆ˜ star, star âˆ˜ L âˆ˜ star)`. Then for any `x y : A`, we have\n    `â€–star a * aâ€– = â€–(star a * a).sndâ€– = â€–R (star (L (star x))) * yâ€– = â€–star (L (star x)) * L yâ€–`\n    Now, on the one hand,\n    `â€–star (L (star x)) * L yâ€– â‰¤ â€–star (L (star x))â€– * â€–L yâ€– = â€–L (star x)â€– * â€–L yâ€– â‰¤ â€–Lâ€– ^ 2`\n    whenever `â€–xâ€–, â€–yâ€– â‰¤ 1`, so the supremum over all such `x, y` is at most `â€–Lâ€– ^ 2`.\n    On the other hand, for any `â€–zâ€– â‰¤ 1`, we may choose `x := star z` and `y := z` to get:\n    `â€–star (L (star x)) * L yâ€– = â€–star (L z) * (L z)â€– = â€–L zâ€– ^ 2`, and taking the supremum over\n    all such `z` yields that the supremum is at least `â€–Lâ€– ^ 2`. It is the latter part of the\n    argument where `DenselyNormedField ğ•œ` is required (for `sSup_unitClosedBall_eq_nnnorm`). -/\n      have hball : (Metric.closedBall (0 : A) 1).Nonempty :=\n        Metric.nonempty_closedBall.2 zero_le_one\n      have key :\n        âˆ€ x y, â€–xâ€–â‚Š â‰¤ 1 â†’ â€–yâ€–â‚Š â‰¤ 1 â†’ â€–a.snd (star (a.fst (star x))) * yâ€–â‚Š â‰¤ â€–aâ€–â‚Š * â€–aâ€–â‚Š := by\n        intro x y hx hy\n        rw [a.central]\n        calc\n          â€–star (a.fst (star x)) * a.fst yâ€–â‚Š â‰¤ â€–a.fst (star x)â€–â‚Š * â€–a.fst yâ€–â‚Š :=\n            nnnorm_star (a.fst (star x)) â–¸ nnnorm_mul_le _ _\n          _ â‰¤ â€–a.fstâ€–â‚Š * 1 * (â€–a.fstâ€–â‚Š * 1) :=\n            (mul_le_mul' (a.fst.le_opNorm_of_le ((nnnorm_star x).trans_le hx))\n              (a.fst.le_opNorm_of_le hy))\n          _ â‰¤ â€–aâ€–â‚Š * â€–aâ€–â‚Š := by simp only [mul_one, nnnorm_fst, le_rfl]\n      rw [â† nnnorm_snd]\n      simp only [mul_snd, â† sSup_unitClosedBall_eq_nnnorm, star_snd, mul_apply]\n      simp only [â† @opNNNorm_mul_apply ğ•œ _ A]\n      simp only [â† sSup_unitClosedBall_eq_nnnorm, mul_apply']\n      refine csSup_eq_of_forall_le_of_forall_lt_exists_gt (hball.image _) ?_ fun r hr => ?_\n      Â· rintro - âŸ¨x, hx, rflâŸ©\n        refine csSup_le (hball.image _) ?_\n        rintro - âŸ¨y, hy, rflâŸ©\n        exact key x y (mem_closedBall_zero_iff.1 hx) (mem_closedBall_zero_iff.1 hy)\n      Â· simp only [Set.mem_image, Set.mem_setOf_eq, exists_prop, exists_exists_and_eq_and]\n        have hr' : NNReal.sqrt r < â€–aâ€–â‚Š := â€–aâ€–â‚Š.sqrt_mul_self â–¸ NNReal.sqrt_lt_sqrt.2 hr\n        simp_rw [â† nnnorm_fst, â† sSup_unitClosedBall_eq_nnnorm] at hr'\n        obtain âŸ¨_, âŸ¨x, hx, rflâŸ©, hxrâŸ© := exists_lt_of_lt_csSup (hball.image _) hr'\n        have hx' : â€–xâ€–â‚Š â‰¤ 1 := mem_closedBall_zero_iff.1 hx\n        refine âŸ¨star x, mem_closedBall_zero_iff.2 ((nnnorm_star x).trans_le hx'), ?_âŸ©\n        refine lt_csSup_of_lt ?_ âŸ¨x, hx, rflâŸ© ?_\n        Â· refine âŸ¨â€–aâ€–â‚Š * â€–aâ€–â‚Š, ?_âŸ©\n          rintro - âŸ¨y, hy, rflâŸ©\n          exact key (star x) y ((nnnorm_star x).trans_le hx') (mem_closedBall_zero_iff.1 hy)\n        Â· simpa only [a.central, star_star, CStarRing.nnnorm_star_mul_self, NNReal.sq_sqrt, â† sq]\n            using pow_lt_pow_leftâ‚€ hxr zero_le' two_ne_zero\n\n"}
