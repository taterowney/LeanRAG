{"name":"DoubleCentralizer.central","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u\nA : Type v\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\nself : DoubleCentralizer 𝕜 A\nx y : A\n⊢ Eq (HMul.hMul (self.toProd.2 x) y) (HMul.hMul x (self.toProd.1 y))","decl":"/-- The type of *double centralizers*, also known as the *multiplier algebra* and denoted by\n`𝓜(𝕜, A)`, of a non-unital normed algebra.\n\nIf `x : 𝓜(𝕜, A)`, then `x.fst` and `x.snd` are what is usually referred to as $L$ and $R$. -/\nstructure DoubleCentralizer (𝕜 : Type u) (A : Type v) [NontriviallyNormedField 𝕜]\n    [NonUnitalNormedRing A] [NormedSpace 𝕜 A] [SMulCommClass 𝕜 A A] [IsScalarTower 𝕜 A A] extends\n    (A →L[𝕜] A) × (A →L[𝕜] A) where\n  /-- The centrality condition that the maps linear maps intertwine one another. -/\n  central : ∀ x y : A, snd x * y = x * fst y\n\n"}
{"name":"DoubleCentralizer.mk.injEq","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u\nA : Type v\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\ntoProd✝ : Prod (ContinuousLinearMap (RingHom.id 𝕜) A A) (ContinuousLinearMap (RingHom.id 𝕜) A A)\ncentral✝ : ∀ (x y : A), Eq (HMul.hMul (toProd✝.2 x) y) (HMul.hMul x (toProd✝.1 y))\ntoProd : Prod (ContinuousLinearMap (RingHom.id 𝕜) A A) (ContinuousLinearMap (RingHom.id 𝕜) A A)\ncentral : ∀ (x y : A), Eq (HMul.hMul (toProd.2 x) y) (HMul.hMul x (toProd.1 y))\n⊢ Eq (Eq { toProd := toProd✝, central := central✝ } { toProd := toProd, central := central }) (Eq toProd✝ toProd)","decl":"/-- The type of *double centralizers*, also known as the *multiplier algebra* and denoted by\n`𝓜(𝕜, A)`, of a non-unital normed algebra.\n\nIf `x : 𝓜(𝕜, A)`, then `x.fst` and `x.snd` are what is usually referred to as $L$ and $R$. -/\nstructure DoubleCentralizer (𝕜 : Type u) (A : Type v) [NontriviallyNormedField 𝕜]\n    [NonUnitalNormedRing A] [NormedSpace 𝕜 A] [SMulCommClass 𝕜 A A] [IsScalarTower 𝕜 A A] extends\n    (A →L[𝕜] A) × (A →L[𝕜] A) where\n  /-- The centrality condition that the maps linear maps intertwine one another. -/\n  central : ∀ x y : A, snd x * y = x * fst y\n\n"}
{"name":"DoubleCentralizer.mk.inj","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u\nA : Type v\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\ntoProd✝ : Prod (ContinuousLinearMap (RingHom.id 𝕜) A A) (ContinuousLinearMap (RingHom.id 𝕜) A A)\ncentral✝ : ∀ (x y : A), Eq (HMul.hMul (toProd✝.2 x) y) (HMul.hMul x (toProd✝.1 y))\ntoProd : Prod (ContinuousLinearMap (RingHom.id 𝕜) A A) (ContinuousLinearMap (RingHom.id 𝕜) A A)\ncentral : ∀ (x y : A), Eq (HMul.hMul (toProd.2 x) y) (HMul.hMul x (toProd.1 y))\nx✝ : Eq { toProd := toProd✝, central := central✝ } { toProd := toProd, central := central }\n⊢ Eq toProd✝ toProd","decl":"/-- The type of *double centralizers*, also known as the *multiplier algebra* and denoted by\n`𝓜(𝕜, A)`, of a non-unital normed algebra.\n\nIf `x : 𝓜(𝕜, A)`, then `x.fst` and `x.snd` are what is usually referred to as $L$ and $R$. -/\nstructure DoubleCentralizer (𝕜 : Type u) (A : Type v) [NontriviallyNormedField 𝕜]\n    [NonUnitalNormedRing A] [NormedSpace 𝕜 A] [SMulCommClass 𝕜 A A] [IsScalarTower 𝕜 A A] extends\n    (A →L[𝕜] A) × (A →L[𝕜] A) where\n  /-- The centrality condition that the maps linear maps intertwine one another. -/\n  central : ∀ x y : A, snd x * y = x * fst y\n\n"}
{"name":"DoubleCentralizer.mk.sizeOf_spec","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u\nA : Type v\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NonUnitalNormedRing A\ninst✝⁴ : NormedSpace 𝕜 A\ninst✝³ : SMulCommClass 𝕜 A A\ninst✝² : IsScalarTower 𝕜 A A\ninst✝¹ : SizeOf 𝕜\ninst✝ : SizeOf A\ntoProd : Prod (ContinuousLinearMap (RingHom.id 𝕜) A A) (ContinuousLinearMap (RingHom.id 𝕜) A A)\ncentral : ∀ (x y : A), Eq (HMul.hMul (toProd.2 x) y) (HMul.hMul x (toProd.1 y))\n⊢ Eq (SizeOf.sizeOf { toProd := toProd, central := central }) (HAdd.hAdd 1 (SizeOf.sizeOf toProd))","decl":"/-- The type of *double centralizers*, also known as the *multiplier algebra* and denoted by\n`𝓜(𝕜, A)`, of a non-unital normed algebra.\n\nIf `x : 𝓜(𝕜, A)`, then `x.fst` and `x.snd` are what is usually referred to as $L$ and $R$. -/\nstructure DoubleCentralizer (𝕜 : Type u) (A : Type v) [NontriviallyNormedField 𝕜]\n    [NonUnitalNormedRing A] [NormedSpace 𝕜 A] [SMulCommClass 𝕜 A A] [IsScalarTower 𝕜 A A] extends\n    (A →L[𝕜] A) × (A →L[𝕜] A) where\n  /-- The centrality condition that the maps linear maps intertwine one another. -/\n  central : ∀ x y : A, snd x * y = x * fst y\n\n"}
{"name":"DoubleCentralizer.ext","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u\nA : Type v\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\na b : DoubleCentralizer 𝕜 A\nh : Eq a.toProd b.toProd\n⊢ Eq a b","decl":"@[ext]\nlemma DoubleCentralizer.ext (𝕜 : Type u) (A : Type v) [NontriviallyNormedField 𝕜]\n    [NonUnitalNormedRing A] [NormedSpace 𝕜 A] [SMulCommClass 𝕜 A A] [IsScalarTower 𝕜 A A]\n    (a b : 𝓜(𝕜, A)) (h : a.toProd = b.toProd) : a = b := by\n  cases a\n  cases b\n  simpa using h\n\n"}
{"name":"DoubleCentralizer.ext_iff","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u\nA : Type v\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\na b : DoubleCentralizer 𝕜 A\n⊢ Iff (Eq a b) (Eq a.toProd b.toProd)","decl":"@[ext]\nlemma DoubleCentralizer.ext (𝕜 : Type u) (A : Type v) [NontriviallyNormedField 𝕜]\n    [NonUnitalNormedRing A] [NormedSpace 𝕜 A] [SMulCommClass 𝕜 A A] [IsScalarTower 𝕜 A A]\n    (a b : 𝓜(𝕜, A)) (h : a.toProd = b.toProd) : a = b := by\n  cases a\n  cases b\n  simpa using h\n\n"}
{"name":"DoubleCentralizer.range_toProd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\n⊢ Eq (Set.range DoubleCentralizer.toProd) (setOf fun lr => ∀ (x y : A), Eq (HMul.hMul (lr.2 x) y) (HMul.hMul x (lr.1 y)))","decl":"theorem range_toProd :\n    Set.range toProd = { lr : (A →L[𝕜] A) × (A →L[𝕜] A) | ∀ x y, lr.2 x * y = x * lr.1 y } :=\n  Set.ext fun x =>\n    ⟨by\n      rintro ⟨a, rfl⟩\n      exact a.central, fun hx => ⟨⟨x, hx⟩, rfl⟩⟩\n\n"}
{"name":"DoubleCentralizer.smul_toProd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝¹⁰ : NontriviallyNormedField 𝕜\ninst✝⁹ : NonUnitalNormedRing A\ninst✝⁸ : NormedSpace 𝕜 A\ninst✝⁷ : SMulCommClass 𝕜 A A\ninst✝⁶ : IsScalarTower 𝕜 A A\nS : Type u_3\ninst✝⁵ : Monoid S\ninst✝⁴ : DistribMulAction S A\ninst✝³ : SMulCommClass 𝕜 S A\ninst✝² : ContinuousConstSMul S A\ninst✝¹ : IsScalarTower S A A\ninst✝ : SMulCommClass S A A\ns : S\na : DoubleCentralizer 𝕜 A\n⊢ Eq (HSMul.hSMul s a).toProd (HSMul.hSMul s a.toProd)","decl":"@[simp]\ntheorem smul_toProd (s : S) (a : 𝓜(𝕜, A)) : (s • a).toProd = s • a.toProd :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.smul_fst","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝¹⁰ : NontriviallyNormedField 𝕜\ninst✝⁹ : NonUnitalNormedRing A\ninst✝⁸ : NormedSpace 𝕜 A\ninst✝⁷ : SMulCommClass 𝕜 A A\ninst✝⁶ : IsScalarTower 𝕜 A A\nS : Type u_3\ninst✝⁵ : Monoid S\ninst✝⁴ : DistribMulAction S A\ninst✝³ : SMulCommClass 𝕜 S A\ninst✝² : ContinuousConstSMul S A\ninst✝¹ : IsScalarTower S A A\ninst✝ : SMulCommClass S A A\ns : S\na : DoubleCentralizer 𝕜 A\n⊢ Eq (HSMul.hSMul s a).toProd.1 (HSMul.hSMul s a.toProd.1)","decl":"theorem smul_fst (s : S) (a : 𝓜(𝕜, A)) : (s • a).fst = s • a.fst :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.smul_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝¹⁰ : NontriviallyNormedField 𝕜\ninst✝⁹ : NonUnitalNormedRing A\ninst✝⁸ : NormedSpace 𝕜 A\ninst✝⁷ : SMulCommClass 𝕜 A A\ninst✝⁶ : IsScalarTower 𝕜 A A\nS : Type u_3\ninst✝⁵ : Monoid S\ninst✝⁴ : DistribMulAction S A\ninst✝³ : SMulCommClass 𝕜 S A\ninst✝² : ContinuousConstSMul S A\ninst✝¹ : IsScalarTower S A A\ninst✝ : SMulCommClass S A A\ns : S\na : DoubleCentralizer 𝕜 A\n⊢ Eq (HSMul.hSMul s a).toProd.2 (HSMul.hSMul s a.toProd.2)","decl":"theorem smul_snd (s : S) (a : 𝓜(𝕜, A)) : (s • a).snd = s • a.snd :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.instIsScalarTower","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝¹⁴ : NontriviallyNormedField 𝕜\ninst✝¹³ : NonUnitalNormedRing A\ninst✝¹² : NormedSpace 𝕜 A\ninst✝¹¹ : SMulCommClass 𝕜 A A\ninst✝¹⁰ : IsScalarTower 𝕜 A A\nS : Type u_3\ninst✝⁹ : Monoid S\ninst✝⁸ : DistribMulAction S A\ninst✝⁷ : SMulCommClass 𝕜 S A\ninst✝⁶ : ContinuousConstSMul S A\nT : Type u_4\ninst✝⁵ : Monoid T\ninst✝⁴ : DistribMulAction T A\ninst✝³ : SMulCommClass 𝕜 T A\ninst✝² : ContinuousConstSMul T A\ninst✝¹ : SMul S T\ninst✝ : IsScalarTower S T A\n⊢ IsScalarTower S T (DoubleCentralizer 𝕜 A)","decl":"instance instIsScalarTower [SMul S T] [IsScalarTower S T A] : IsScalarTower S T 𝓜(𝕜, A) where\n  smul_assoc _ _ a := ext (𝕜 := 𝕜) (A := A) _ _ <| smul_assoc _ _ a.toProd\n\n"}
{"name":"DoubleCentralizer.instSMulCommClass","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝¹³ : NontriviallyNormedField 𝕜\ninst✝¹² : NonUnitalNormedRing A\ninst✝¹¹ : NormedSpace 𝕜 A\ninst✝¹⁰ : SMulCommClass 𝕜 A A\ninst✝⁹ : IsScalarTower 𝕜 A A\nS : Type u_3\ninst✝⁸ : Monoid S\ninst✝⁷ : DistribMulAction S A\ninst✝⁶ : SMulCommClass 𝕜 S A\ninst✝⁵ : ContinuousConstSMul S A\nT : Type u_4\ninst✝⁴ : Monoid T\ninst✝³ : DistribMulAction T A\ninst✝² : SMulCommClass 𝕜 T A\ninst✝¹ : ContinuousConstSMul T A\ninst✝ : SMulCommClass S T A\n⊢ SMulCommClass S T (DoubleCentralizer 𝕜 A)","decl":"instance instSMulCommClass [SMulCommClass S T A] : SMulCommClass S T 𝓜(𝕜, A) where\n  smul_comm _ _ a := ext (𝕜 := 𝕜) (A := A) _ _ <| smul_comm _ _ a.toProd\n\n"}
{"name":"DoubleCentralizer.instIsCentralScalar","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝¹² : NontriviallyNormedField 𝕜\ninst✝¹¹ : NonUnitalNormedRing A\ninst✝¹⁰ : NormedSpace 𝕜 A\ninst✝⁹ : SMulCommClass 𝕜 A A\ninst✝⁸ : IsScalarTower 𝕜 A A\nR : Type u_5\ninst✝⁷ : Semiring R\ninst✝⁶ : Module R A\ninst✝⁵ : SMulCommClass 𝕜 R A\ninst✝⁴ : ContinuousConstSMul R A\ninst✝³ : IsScalarTower R A A\ninst✝² : SMulCommClass R A A\ninst✝¹ : Module (MulOpposite R) A\ninst✝ : IsCentralScalar R A\n⊢ IsCentralScalar R (DoubleCentralizer 𝕜 A)","decl":"instance instIsCentralScalar {R : Type*} [Semiring R] [Module R A] [SMulCommClass 𝕜 R A]\n    [ContinuousConstSMul R A] [IsScalarTower R A A] [SMulCommClass R A A] [Module Rᵐᵒᵖ A]\n    [IsCentralScalar R A] : IsCentralScalar R 𝓜(𝕜, A) where\n  op_smul_eq_smul _ a := ext (𝕜 := 𝕜) (A := A) _ _ <| op_smul_eq_smul _ a.toProd\n\n"}
{"name":"DoubleCentralizer.add_toProd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\na b : DoubleCentralizer 𝕜 A\n⊢ Eq (HAdd.hAdd a b).toProd (HAdd.hAdd a.toProd b.toProd)","decl":"@[simp]\ntheorem add_toProd (a b : 𝓜(𝕜, A)) : (a + b).toProd = a.toProd + b.toProd :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.zero_toProd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\n⊢ Eq (DoubleCentralizer.toProd 0) 0","decl":"@[simp]\ntheorem zero_toProd : (0 : 𝓜(𝕜, A)).toProd = 0 :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.neg_toProd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\na : DoubleCentralizer 𝕜 A\n⊢ Eq (Neg.neg a).toProd (Neg.neg a.toProd)","decl":"@[simp]\ntheorem neg_toProd (a : 𝓜(𝕜, A)) : (-a).toProd = -a.toProd :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.sub_toProd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\na b : DoubleCentralizer 𝕜 A\n⊢ Eq (HSub.hSub a b).toProd (HSub.hSub a.toProd b.toProd)","decl":"@[simp]\ntheorem sub_toProd (a b : 𝓜(𝕜, A)) : (a - b).toProd = a.toProd - b.toProd :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.one_toProd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\n⊢ Eq (DoubleCentralizer.toProd 1) 1","decl":"@[simp]\ntheorem one_toProd : (1 : 𝓜(𝕜, A)).toProd = 1 :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.natCast_toProd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\nn : Nat\n⊢ Eq (↑n).toProd ↑n","decl":"@[simp]\ntheorem natCast_toProd (n : ℕ) : (n : 𝓜(𝕜, A)).toProd = n :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.intCast_toProd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\nn : Int\n⊢ Eq (↑n).toProd ↑n","decl":"@[simp]\ntheorem intCast_toProd (n : ℤ) : (n : 𝓜(𝕜, A)).toProd = n :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.pow_toProd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\nn : Nat\na : DoubleCentralizer 𝕜 A\n⊢ Eq (HPow.hPow a n).toProd (HPow.hPow a.toProd n)","decl":"@[simp]\ntheorem pow_toProd (n : ℕ) (a : 𝓜(𝕜, A)) : (a ^ n).toProd = a.toProd ^ n :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.add_fst","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\na b : DoubleCentralizer 𝕜 A\n⊢ Eq (HAdd.hAdd a b).toProd.1 (HAdd.hAdd a.toProd.1 b.toProd.1)","decl":"theorem add_fst (a b : 𝓜(𝕜, A)) : (a + b).fst = a.fst + b.fst :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.add_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\na b : DoubleCentralizer 𝕜 A\n⊢ Eq (HAdd.hAdd a b).toProd.2 (HAdd.hAdd a.toProd.2 b.toProd.2)","decl":"theorem add_snd (a b : 𝓜(𝕜, A)) : (a + b).snd = a.snd + b.snd :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.zero_fst","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\n⊢ Eq (DoubleCentralizer.toProd 0).1 0","decl":"theorem zero_fst : (0 : 𝓜(𝕜, A)).fst = 0 :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.zero_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\n⊢ Eq (DoubleCentralizer.toProd 0).2 0","decl":"theorem zero_snd : (0 : 𝓜(𝕜, A)).snd = 0 :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.neg_fst","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\na : DoubleCentralizer 𝕜 A\n⊢ Eq (Neg.neg a).toProd.1 (Neg.neg a.toProd.1)","decl":"theorem neg_fst (a : 𝓜(𝕜, A)) : (-a).fst = -a.fst :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.neg_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\na : DoubleCentralizer 𝕜 A\n⊢ Eq (Neg.neg a).toProd.2 (Neg.neg a.toProd.2)","decl":"theorem neg_snd (a : 𝓜(𝕜, A)) : (-a).snd = -a.snd :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.sub_fst","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\na b : DoubleCentralizer 𝕜 A\n⊢ Eq (HSub.hSub a b).toProd.1 (HSub.hSub a.toProd.1 b.toProd.1)","decl":"theorem sub_fst (a b : 𝓜(𝕜, A)) : (a - b).fst = a.fst - b.fst :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.sub_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\na b : DoubleCentralizer 𝕜 A\n⊢ Eq (HSub.hSub a b).toProd.2 (HSub.hSub a.toProd.2 b.toProd.2)","decl":"theorem sub_snd (a b : 𝓜(𝕜, A)) : (a - b).snd = a.snd - b.snd :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.one_fst","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\n⊢ Eq (DoubleCentralizer.toProd 1).1 1","decl":"theorem one_fst : (1 : 𝓜(𝕜, A)).fst = 1 :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.one_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\n⊢ Eq (DoubleCentralizer.toProd 1).2 1","decl":"theorem one_snd : (1 : 𝓜(𝕜, A)).snd = 1 :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.mul_fst","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\na b : DoubleCentralizer 𝕜 A\n⊢ Eq (HMul.hMul a b).toProd.1 (HMul.hMul a.toProd.1 b.toProd.1)","decl":"@[simp]\ntheorem mul_fst (a b : 𝓜(𝕜, A)) : (a * b).fst = a.fst * b.fst :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.mul_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\na b : DoubleCentralizer 𝕜 A\n⊢ Eq (HMul.hMul a b).toProd.2 (HMul.hMul b.toProd.2 a.toProd.2)","decl":"@[simp]\ntheorem mul_snd (a b : 𝓜(𝕜, A)) : (a * b).snd = b.snd * a.snd :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.natCast_fst","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\nn : Nat\n⊢ Eq (↑n).toProd.1 ↑n","decl":"theorem natCast_fst (n : ℕ) : (n : 𝓜(𝕜, A)).fst = n :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.natCast_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\nn : Nat\n⊢ Eq (↑n).toProd.2 ↑n","decl":"theorem natCast_snd (n : ℕ) : (n : 𝓜(𝕜, A)).snd = n :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.intCast_fst","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\nn : Int\n⊢ Eq (↑n).toProd.1 ↑n","decl":"theorem intCast_fst (n : ℤ) : (n : 𝓜(𝕜, A)).fst = n :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.intCast_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\nn : Int\n⊢ Eq (↑n).toProd.2 ↑n","decl":"theorem intCast_snd (n : ℤ) : (n : 𝓜(𝕜, A)).snd = n :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.pow_fst","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\nn : Nat\na : DoubleCentralizer 𝕜 A\n⊢ Eq (HPow.hPow a n).toProd.1 (HPow.hPow a.toProd.1 n)","decl":"theorem pow_fst (n : ℕ) (a : 𝓜(𝕜, A)) : (a ^ n).fst = a.fst ^ n :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.pow_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\nn : Nat\na : DoubleCentralizer 𝕜 A\n⊢ Eq (HPow.hPow a n).toProd.2 (HPow.hPow a.toProd.2 n)","decl":"theorem pow_snd (n : ℕ) (a : 𝓜(𝕜, A)) : (a ^ n).snd = a.snd ^ n :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.toProdMulOpposite_injective","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\n⊢ Function.Injective DoubleCentralizer.toProdMulOpposite","decl":"theorem toProdMulOpposite_injective :\n    Function.Injective (toProdMulOpposite : 𝓜(𝕜, A) → (A →L[𝕜] A) × (A →L[𝕜] A)ᵐᵒᵖ) :=\n  fun _a _b h =>\n    let h' := Prod.ext_iff.mp h\n    ext (𝕜 := 𝕜) (A := A) _ _ <| Prod.ext h'.1 <| MulOpposite.op_injective h'.2\n\n"}
{"name":"DoubleCentralizer.range_toProdMulOpposite","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\n⊢ Eq (Set.range DoubleCentralizer.toProdMulOpposite) (setOf fun lr => ∀ (x y : A), Eq (HMul.hMul ((MulOpposite.unop lr.2) x) y) (HMul.hMul x (lr.1 y)))","decl":"theorem range_toProdMulOpposite :\n    Set.range toProdMulOpposite =\n      { lr : (A →L[𝕜] A) × (A →L[𝕜] A)ᵐᵒᵖ | ∀ x y, unop lr.2 x * y = x * lr.1 y } :=\n  Set.ext fun x =>\n    ⟨by\n      rintro ⟨a, rfl⟩\n      exact a.central, fun hx => ⟨⟨(x.1, unop x.2), hx⟩, Prod.ext rfl rfl⟩⟩\n\n"}
{"name":"DoubleCentralizer.toProdHom_apply","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\nself : DoubleCentralizer 𝕜 A\n⊢ Eq (DoubleCentralizer.toProdHom self) self.toProd","decl":"/-- The canonical map `DoubleCentralizer.toProd` as an additive group homomorphism. -/\n@[simps]\ndef toProdHom : 𝓜(𝕜, A) →+ (A →L[𝕜] A) × (A →L[𝕜] A) where\n  toFun := toProd\n  map_zero' := rfl\n  map_add' _x _y := rfl\n\n"}
{"name":"DoubleCentralizer.toProdMulOppositeHom_apply","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\na✝ : DoubleCentralizer 𝕜 A\n⊢ Eq (DoubleCentralizer.toProdMulOppositeHom a✝) a✝.toProdMulOpposite","decl":"/-- The canonical map `DoubleCentralizer.toProdMulOpposite` as a ring homomorphism. -/\n@[simps]\ndef toProdMulOppositeHom : 𝓜(𝕜, A) →+* (A →L[𝕜] A) × (A →L[𝕜] A)ᵐᵒᵖ where\n  toFun := toProdMulOpposite\n  map_zero' := rfl\n  map_one' := rfl\n  map_add' _x _y := rfl\n  map_mul' _x _y := rfl\n\n"}
{"name":"DoubleCentralizer.algebraMap_toProd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\nk : 𝕜\n⊢ Eq ((algebraMap 𝕜 (DoubleCentralizer 𝕜 A)) k).toProd ((algebraMap 𝕜 (Prod (ContinuousLinearMap (RingHom.id 𝕜) A A) (ContinuousLinearMap (RingHom.id 𝕜) A A))) k)","decl":"@[simp]\ntheorem algebraMap_toProd (k : 𝕜) : (algebraMap 𝕜 𝓜(𝕜, A) k).toProd = algebraMap 𝕜 _ k :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.algebraMap_fst","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\nk : 𝕜\n⊢ Eq ((algebraMap 𝕜 (DoubleCentralizer 𝕜 A)) k).toProd.1 ((algebraMap 𝕜 (ContinuousLinearMap (RingHom.id 𝕜) A A)) k)","decl":"theorem algebraMap_fst (k : 𝕜) : (algebraMap 𝕜 𝓜(𝕜, A) k).fst = algebraMap 𝕜 _ k :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.algebraMap_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\nk : 𝕜\n⊢ Eq ((algebraMap 𝕜 (DoubleCentralizer 𝕜 A)) k).toProd.2 ((algebraMap 𝕜 (ContinuousLinearMap (RingHom.id 𝕜) A A)) k)","decl":"theorem algebraMap_snd (k : 𝕜) : (algebraMap 𝕜 𝓜(𝕜, A) k).snd = algebraMap 𝕜 _ k :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.star_fst","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁸ : NontriviallyNormedField 𝕜\ninst✝⁷ : NonUnitalNormedRing A\ninst✝⁶ : NormedSpace 𝕜 A\ninst✝⁵ : SMulCommClass 𝕜 A A\ninst✝⁴ : IsScalarTower 𝕜 A A\ninst✝³ : StarRing 𝕜\ninst✝² : StarRing A\ninst✝¹ : StarModule 𝕜 A\ninst✝ : NormedStarGroup A\na : DoubleCentralizer 𝕜 A\nb : A\n⊢ Eq ((Star.star a).toProd.1 b) (Star.star (a.toProd.2 (Star.star b)))","decl":"@[simp]\ntheorem star_fst (a : 𝓜(𝕜, A)) (b : A) : (star a).fst b = star (a.snd (star b)) :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.star_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁸ : NontriviallyNormedField 𝕜\ninst✝⁷ : NonUnitalNormedRing A\ninst✝⁶ : NormedSpace 𝕜 A\ninst✝⁵ : SMulCommClass 𝕜 A A\ninst✝⁴ : IsScalarTower 𝕜 A A\ninst✝³ : StarRing 𝕜\ninst✝² : StarRing A\ninst✝¹ : StarModule 𝕜 A\ninst✝ : NormedStarGroup A\na : DoubleCentralizer 𝕜 A\nb : A\n⊢ Eq ((Star.star a).toProd.2 b) (Star.star (a.toProd.1 (Star.star b)))","decl":"@[simp]\ntheorem star_snd (a : 𝓜(𝕜, A)) (b : A) : (star a).snd b = star (a.fst (star b)) :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.instStarModule","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁸ : NontriviallyNormedField 𝕜\ninst✝⁷ : NonUnitalNormedRing A\ninst✝⁶ : NormedSpace 𝕜 A\ninst✝⁵ : SMulCommClass 𝕜 A A\ninst✝⁴ : IsScalarTower 𝕜 A A\ninst✝³ : StarRing 𝕜\ninst✝² : StarRing A\ninst✝¹ : StarModule 𝕜 A\ninst✝ : NormedStarGroup A\n⊢ StarModule 𝕜 (DoubleCentralizer 𝕜 A)","decl":"instance instStarModule : StarModule 𝕜 𝓜(𝕜, A) :=\n  { DoubleCentralizer.instStarAddMonoid (𝕜 := 𝕜) (A := A) with\n    star_smul := fun k a => by ext <;> exact star_smul _ _ }\n\n"}
{"name":"DoubleCentralizer.coe_fst","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\na : A\n⊢ Eq (↑𝕜 a).toProd.1 ((ContinuousLinearMap.mul 𝕜 A) a)","decl":"@[simp, norm_cast]\ntheorem coe_fst (a : A) : (a : 𝓜(𝕜, A)).fst = ContinuousLinearMap.mul 𝕜 A a :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.coe_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\na : A\n⊢ Eq (↑𝕜 a).toProd.2 ((ContinuousLinearMap.mul 𝕜 A).flip a)","decl":"@[simp, norm_cast]\ntheorem coe_snd (a : A) : (a : 𝓜(𝕜, A)).snd = (ContinuousLinearMap.mul 𝕜 A).flip a :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.coe_eq_algebraMap","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\n⊢ Eq ↑𝕜 ⇑(algebraMap 𝕜 (DoubleCentralizer 𝕜 𝕜))","decl":"theorem coe_eq_algebraMap : (DoubleCentralizer.coe 𝕜 : 𝕜 → 𝓜(𝕜, 𝕜)) = algebraMap 𝕜 𝓜(𝕜, 𝕜) := by\n  ext x : 3\n  · rfl -- `fst` is defeq\n  · refine ContinuousLinearMap.ext fun y => ?_\n    exact mul_comm y x  -- `snd` multiplies on the wrong side\n\n"}
{"name":"DoubleCentralizer.coeHom_apply","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁸ : NontriviallyNormedField 𝕜\ninst✝⁷ : NonUnitalNormedRing A\ninst✝⁶ : NormedSpace 𝕜 A\ninst✝⁵ : SMulCommClass 𝕜 A A\ninst✝⁴ : IsScalarTower 𝕜 A A\ninst✝³ : StarRing 𝕜\ninst✝² : StarRing A\ninst✝¹ : StarModule 𝕜 A\ninst✝ : NormedStarGroup A\na : A\n⊢ Eq (DoubleCentralizer.coeHom a) (↑𝕜 a)","decl":"/-- The coercion of an algebra into its multiplier algebra as a non-unital star algebra\nhomomorphism. -/\n@[simps]\nnoncomputable def coeHom [StarRing 𝕜] [StarRing A] [StarModule 𝕜 A] [NormedStarGroup A] :\n    A →⋆ₙₐ[𝕜] 𝓜(𝕜, A) where\n  toFun a := a\n  map_smul' _ _ := ext _ _ _ _ <| Prod.ext (map_smul _ _ _) (map_smul _ _ _)\n  map_zero' := ext _ _ _ _ <| Prod.ext (map_zero _) (map_zero _)\n  map_add' _ _ := ext _ _ _ _ <| Prod.ext (map_add _ _ _) (map_add _ _ _)\n  map_mul' _ _ := ext _ _ _ _ <| Prod.ext\n    (ContinuousLinearMap.ext fun _ => (mul_assoc _ _ _))\n    (ContinuousLinearMap.ext fun _ => (mul_assoc _ _ _).symm)\n  map_star' _ := ext _ _ _ _ <| Prod.ext\n    (ContinuousLinearMap.ext fun _ => (star_star_mul _ _).symm)\n    (ContinuousLinearMap.ext fun _ => (star_mul_star _ _).symm)\n\n"}
{"name":"DoubleCentralizer.norm_def","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\na : DoubleCentralizer 𝕜 A\n⊢ Eq (Norm.norm a) (Norm.norm (DoubleCentralizer.toProdHom a))","decl":"theorem norm_def (a : 𝓜(𝕜, A)) : ‖a‖ = ‖toProdHom a‖ :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.nnnorm_def","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\na : DoubleCentralizer 𝕜 A\n⊢ Eq (NNNorm.nnnorm a) (NNNorm.nnnorm (DoubleCentralizer.toProdHom a))","decl":"theorem nnnorm_def (a : 𝓜(𝕜, A)) : ‖a‖₊ = ‖toProdHom a‖₊ :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.norm_def'","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\na : DoubleCentralizer 𝕜 A\n⊢ Eq (Norm.norm a) (Norm.norm (DoubleCentralizer.toProdMulOppositeHom a))","decl":"theorem norm_def' (a : 𝓜(𝕜, A)) : ‖a‖ = ‖toProdMulOppositeHom a‖ :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.nnnorm_def'","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\na : DoubleCentralizer 𝕜 A\n⊢ Eq (NNNorm.nnnorm a) (NNNorm.nnnorm (DoubleCentralizer.toProdMulOppositeHom a))","decl":"theorem nnnorm_def' (a : 𝓜(𝕜, A)) : ‖a‖₊ = ‖toProdMulOppositeHom a‖₊ :=\n  rfl\n\n"}
{"name":"DoubleCentralizer.isUniformEmbedding_toProdMulOpposite","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\n⊢ IsUniformEmbedding DoubleCentralizer.toProdMulOpposite","decl":"theorem isUniformEmbedding_toProdMulOpposite :\n    IsUniformEmbedding (toProdMulOpposite (𝕜 := 𝕜) (A := A)) :=\n  isUniformEmbedding_comap toProdMulOpposite_injective\n\n"}
{"name":"DoubleCentralizer.uniformEmbedding_toProdMulOpposite","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing A\ninst✝² : NormedSpace 𝕜 A\ninst✝¹ : SMulCommClass 𝕜 A A\ninst✝ : IsScalarTower 𝕜 A A\n⊢ IsUniformEmbedding DoubleCentralizer.toProdMulOpposite","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_toProdMulOpposite := isUniformEmbedding_toProdMulOpposite\n\n"}
{"name":"DoubleCentralizer.instCompleteSpace","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NonUnitalNormedRing A\ninst✝³ : NormedSpace 𝕜 A\ninst✝² : SMulCommClass 𝕜 A A\ninst✝¹ : IsScalarTower 𝕜 A A\ninst✝ : CompleteSpace A\n⊢ CompleteSpace (DoubleCentralizer 𝕜 A)","decl":"instance [CompleteSpace A] : CompleteSpace 𝓜(𝕜, A) := by\n  rw [completeSpace_iff_isComplete_range isUniformEmbedding_toProdMulOpposite.isUniformInducing]\n  apply IsClosed.isComplete\n  simp only [range_toProdMulOpposite, Set.setOf_forall]\n  refine isClosed_iInter fun x => isClosed_iInter fun y => isClosed_eq ?_ ?_\n  · exact\n      ((ContinuousLinearMap.apply 𝕜 A _).continuous.comp <| continuous_unop.comp continuous_snd).mul\n        continuous_const\n  exact continuous_const.mul ((ContinuousLinearMap.apply 𝕜 A _).continuous.comp continuous_fst)\n\n"}
{"name":"DoubleCentralizer.norm_fst_eq_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NonUnitalNormedRing A\ninst✝⁴ : NormedSpace 𝕜 A\ninst✝³ : SMulCommClass 𝕜 A A\ninst✝² : IsScalarTower 𝕜 A A\ninst✝¹ : StarRing A\ninst✝ : CStarRing A\na : DoubleCentralizer 𝕜 A\n⊢ Eq (Norm.norm a.toProd.1) (Norm.norm a.toProd.2)","decl":"/-- For `a : 𝓜(𝕜, A)`, the norms of `a.fst` and `a.snd` coincide, and hence these\nalso coincide with `‖a‖` which is `max (‖a.fst‖) (‖a.snd‖)`. -/\ntheorem norm_fst_eq_snd (a : 𝓜(𝕜, A)) : ‖a.fst‖ = ‖a.snd‖ := by\n  -- a handy lemma for this proof\n  have h0 : ∀ f : A →L[𝕜] A, ∀ C : ℝ≥0, (∀ b : A, ‖f b‖₊ ^ 2 ≤ C * ‖f b‖₊ * ‖b‖₊) → ‖f‖₊ ≤ C := by\n    intro f C h\n    have h1 : ∀ b, C * ‖f b‖₊ * ‖b‖₊ ≤ C * ‖f‖₊ * ‖b‖₊ ^ 2 := by\n      intro b\n      convert mul_le_mul_right' (mul_le_mul_left' (f.le_opNNNorm b) C) ‖b‖₊ using 1\n      ring\n    have := NNReal.div_le_of_le_mul <| f.opNNNorm_le_bound _ <| by\n      simpa only [sqrt_sq, sqrt_mul] using fun b ↦ sqrt_le_sqrt.2 <| (h b).trans (h1 b)\n    convert NNReal.rpow_le_rpow this two_pos.le\n    · simp only [NNReal.rpow_two, div_pow, sq_sqrt]\n      simp only [sq, mul_self_div_self]\n    · simp only [NNReal.rpow_two, sq_sqrt]\n  have h1 : ∀ b, ‖a.fst b‖₊ ^ 2 ≤ ‖a.snd‖₊ * ‖a.fst b‖₊ * ‖b‖₊ := by\n    intro b\n    calc\n      ‖a.fst b‖₊ ^ 2 = ‖star (a.fst b) * a.fst b‖₊ := by\n        simpa only [← sq] using CStarRing.nnnorm_star_mul_self.symm\n      _ ≤ ‖a.snd (star (a.fst b))‖₊ * ‖b‖₊ := (a.central (star (a.fst b)) b ▸ nnnorm_mul_le _ _)\n      _ ≤ ‖a.snd‖₊ * ‖a.fst b‖₊ * ‖b‖₊ :=\n        nnnorm_star (a.fst b) ▸ mul_le_mul_right' (a.snd.le_opNNNorm _) _\n\n  have h2 : ∀ b, ‖a.snd b‖₊ ^ 2 ≤ ‖a.fst‖₊ * ‖a.snd b‖₊ * ‖b‖₊ := by\n    intro b\n    calc\n      ‖a.snd b‖₊ ^ 2 = ‖a.snd b * star (a.snd b)‖₊ := by\n        simpa only [← sq] using CStarRing.nnnorm_self_mul_star.symm\n      _ ≤ ‖b‖₊ * ‖a.fst (star (a.snd b))‖₊ :=\n        ((a.central b (star (a.snd b))).symm ▸ nnnorm_mul_le _ _)\n      _ = ‖a.fst (star (a.snd b))‖₊ * ‖b‖₊ := mul_comm _ _\n      _ ≤ ‖a.fst‖₊ * ‖a.snd b‖₊ * ‖b‖₊ :=\n        nnnorm_star (a.snd b) ▸ mul_le_mul_right' (a.fst.le_opNNNorm _) _\n\n  exact le_antisymm (h0 _ _ h1) (h0 _ _ h2)\n\n"}
{"name":"DoubleCentralizer.nnnorm_fst_eq_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NonUnitalNormedRing A\ninst✝⁴ : NormedSpace 𝕜 A\ninst✝³ : SMulCommClass 𝕜 A A\ninst✝² : IsScalarTower 𝕜 A A\ninst✝¹ : StarRing A\ninst✝ : CStarRing A\na : DoubleCentralizer 𝕜 A\n⊢ Eq (NNNorm.nnnorm a.toProd.1) (NNNorm.nnnorm a.toProd.2)","decl":"theorem nnnorm_fst_eq_snd (a : 𝓜(𝕜, A)) : ‖a.fst‖₊ = ‖a.snd‖₊ :=\n  Subtype.ext <| norm_fst_eq_snd a\n\n"}
{"name":"DoubleCentralizer.norm_fst","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NonUnitalNormedRing A\ninst✝⁴ : NormedSpace 𝕜 A\ninst✝³ : SMulCommClass 𝕜 A A\ninst✝² : IsScalarTower 𝕜 A A\ninst✝¹ : StarRing A\ninst✝ : CStarRing A\na : DoubleCentralizer 𝕜 A\n⊢ Eq (Norm.norm a.toProd.1) (Norm.norm a)","decl":"@[simp]\ntheorem norm_fst (a : 𝓜(𝕜, A)) : ‖a.fst‖ = ‖a‖ := by\n  simp only [norm_def, toProdHom_apply, Prod.norm_def, norm_fst_eq_snd, max_eq_right le_rfl]\n\n"}
{"name":"DoubleCentralizer.norm_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NonUnitalNormedRing A\ninst✝⁴ : NormedSpace 𝕜 A\ninst✝³ : SMulCommClass 𝕜 A A\ninst✝² : IsScalarTower 𝕜 A A\ninst✝¹ : StarRing A\ninst✝ : CStarRing A\na : DoubleCentralizer 𝕜 A\n⊢ Eq (Norm.norm a.toProd.2) (Norm.norm a)","decl":"@[simp]\ntheorem norm_snd (a : 𝓜(𝕜, A)) : ‖a.snd‖ = ‖a‖ := by rw [← norm_fst, norm_fst_eq_snd]\n\n"}
{"name":"DoubleCentralizer.nnnorm_fst","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NonUnitalNormedRing A\ninst✝⁴ : NormedSpace 𝕜 A\ninst✝³ : SMulCommClass 𝕜 A A\ninst✝² : IsScalarTower 𝕜 A A\ninst✝¹ : StarRing A\ninst✝ : CStarRing A\na : DoubleCentralizer 𝕜 A\n⊢ Eq (NNNorm.nnnorm a.toProd.1) (NNNorm.nnnorm a)","decl":"@[simp]\ntheorem nnnorm_fst (a : 𝓜(𝕜, A)) : ‖a.fst‖₊ = ‖a‖₊ :=\n  Subtype.ext (norm_fst a)\n\n"}
{"name":"DoubleCentralizer.nnnorm_snd","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NonUnitalNormedRing A\ninst✝⁴ : NormedSpace 𝕜 A\ninst✝³ : SMulCommClass 𝕜 A A\ninst✝² : IsScalarTower 𝕜 A A\ninst✝¹ : StarRing A\ninst✝ : CStarRing A\na : DoubleCentralizer 𝕜 A\n⊢ Eq (NNNorm.nnnorm a.toProd.2) (NNNorm.nnnorm a)","decl":"@[simp]\ntheorem nnnorm_snd (a : 𝓜(𝕜, A)) : ‖a.snd‖₊ = ‖a‖₊ :=\n  Subtype.ext (norm_snd a)\n\n"}
{"name":"DoubleCentralizer.instCStarRing","module":"Mathlib.Analysis.CStarAlgebra.Multiplier","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁸ : DenselyNormedField 𝕜\ninst✝⁷ : StarRing 𝕜\ninst✝⁶ : NonUnitalNormedRing A\ninst✝⁵ : StarRing A\ninst✝⁴ : CStarRing A\ninst✝³ : NormedSpace 𝕜 A\ninst✝² : SMulCommClass 𝕜 A A\ninst✝¹ : IsScalarTower 𝕜 A A\ninst✝ : StarModule 𝕜 A\n⊢ CStarRing (DoubleCentralizer 𝕜 A)","decl":"instance instCStarRing : CStarRing 𝓜(𝕜, A) where\n  norm_mul_self_le := fun (a : 𝓜(𝕜, A)) => le_of_eq <| Eq.symm <| congr_arg ((↑) : ℝ≥0 → ℝ) <|\n    show ‖star a * a‖₊ = ‖a‖₊ * ‖a‖₊ by\n    /- The essence of the argument is this: let `a = (L,R)` and recall `‖a‖ = ‖L‖`.\n    `star a = (star ∘ R ∘ star, star ∘ L ∘ star)`. Then for any `x y : A`, we have\n    `‖star a * a‖ = ‖(star a * a).snd‖ = ‖R (star (L (star x))) * y‖ = ‖star (L (star x)) * L y‖`\n    Now, on the one hand,\n    `‖star (L (star x)) * L y‖ ≤ ‖star (L (star x))‖ * ‖L y‖ = ‖L (star x)‖ * ‖L y‖ ≤ ‖L‖ ^ 2`\n    whenever `‖x‖, ‖y‖ ≤ 1`, so the supremum over all such `x, y` is at most `‖L‖ ^ 2`.\n    On the other hand, for any `‖z‖ ≤ 1`, we may choose `x := star z` and `y := z` to get:\n    `‖star (L (star x)) * L y‖ = ‖star (L z) * (L z)‖ = ‖L z‖ ^ 2`, and taking the supremum over\n    all such `z` yields that the supremum is at least `‖L‖ ^ 2`. It is the latter part of the\n    argument where `DenselyNormedField 𝕜` is required (for `sSup_unitClosedBall_eq_nnnorm`). -/\n      have hball : (Metric.closedBall (0 : A) 1).Nonempty :=\n        Metric.nonempty_closedBall.2 zero_le_one\n      have key :\n        ∀ x y, ‖x‖₊ ≤ 1 → ‖y‖₊ ≤ 1 → ‖a.snd (star (a.fst (star x))) * y‖₊ ≤ ‖a‖₊ * ‖a‖₊ := by\n        intro x y hx hy\n        rw [a.central]\n        calc\n          ‖star (a.fst (star x)) * a.fst y‖₊ ≤ ‖a.fst (star x)‖₊ * ‖a.fst y‖₊ :=\n            nnnorm_star (a.fst (star x)) ▸ nnnorm_mul_le _ _\n          _ ≤ ‖a.fst‖₊ * 1 * (‖a.fst‖₊ * 1) :=\n            (mul_le_mul' (a.fst.le_opNorm_of_le ((nnnorm_star x).trans_le hx))\n              (a.fst.le_opNorm_of_le hy))\n          _ ≤ ‖a‖₊ * ‖a‖₊ := by simp only [mul_one, nnnorm_fst, le_rfl]\n      rw [← nnnorm_snd]\n      simp only [mul_snd, ← sSup_unitClosedBall_eq_nnnorm, star_snd, mul_apply]\n      simp only [← @opNNNorm_mul_apply 𝕜 _ A]\n      simp only [← sSup_unitClosedBall_eq_nnnorm, mul_apply']\n      refine csSup_eq_of_forall_le_of_forall_lt_exists_gt (hball.image _) ?_ fun r hr => ?_\n      · rintro - ⟨x, hx, rfl⟩\n        refine csSup_le (hball.image _) ?_\n        rintro - ⟨y, hy, rfl⟩\n        exact key x y (mem_closedBall_zero_iff.1 hx) (mem_closedBall_zero_iff.1 hy)\n      · simp only [Set.mem_image, Set.mem_setOf_eq, exists_prop, exists_exists_and_eq_and]\n        have hr' : NNReal.sqrt r < ‖a‖₊ := ‖a‖₊.sqrt_mul_self ▸ NNReal.sqrt_lt_sqrt.2 hr\n        simp_rw [← nnnorm_fst, ← sSup_unitClosedBall_eq_nnnorm] at hr'\n        obtain ⟨_, ⟨x, hx, rfl⟩, hxr⟩ := exists_lt_of_lt_csSup (hball.image _) hr'\n        have hx' : ‖x‖₊ ≤ 1 := mem_closedBall_zero_iff.1 hx\n        refine ⟨star x, mem_closedBall_zero_iff.2 ((nnnorm_star x).trans_le hx'), ?_⟩\n        refine lt_csSup_of_lt ?_ ⟨x, hx, rfl⟩ ?_\n        · refine ⟨‖a‖₊ * ‖a‖₊, ?_⟩\n          rintro - ⟨y, hy, rfl⟩\n          exact key (star x) y ((nnnorm_star x).trans_le hx') (mem_closedBall_zero_iff.1 hy)\n        · simpa only [a.central, star_star, CStarRing.nnnorm_star_mul_self, NNReal.sq_sqrt, ← sq]\n            using pow_lt_pow_left₀ hxr zero_le' two_ne_zero\n\n"}
