{"name":"Monoid.PushoutI.of_comp_eq_base","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝¹ : (i : ι) → Monoid (G i)\ninst✝ : Monoid H\nφ : (i : ι) → MonoidHom H (G i)\ni : ι\n⊢ Eq ((Monoid.PushoutI.of i).comp (φ i)) (Monoid.PushoutI.base φ)","decl":"theorem of_comp_eq_base (i : ι) : (of i).comp (φ i) = (base φ) := by\n  ext x\n  apply (Con.eq _).2\n  refine ConGen.Rel.of _ _ ?_\n  simp only [MonoidHom.comp_apply, Set.mem_iUnion, Set.mem_range]\n  exact ⟨_, _, rfl, rfl⟩\n\n"}
{"name":"Monoid.PushoutI.of_apply_eq_base","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝¹ : (i : ι) → Monoid (G i)\ninst✝ : Monoid H\nφ : (i : ι) → MonoidHom H (G i)\ni : ι\nx : H\n⊢ Eq ((Monoid.PushoutI.of i) ((φ i) x)) ((Monoid.PushoutI.base φ) x)","decl":"variable (φ) in\ntheorem of_apply_eq_base (i : ι) (x : H) : of i (φ i x) = base φ x := by\n  rw [← MonoidHom.comp_apply, of_comp_eq_base]\n\n"}
{"name":"Monoid.PushoutI.lift_of","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\nK : Type u_4\ninst✝² : Monoid K\ninst✝¹ : (i : ι) → Monoid (G i)\ninst✝ : Monoid H\nφ : (i : ι) → MonoidHom H (G i)\nf : (i : ι) → MonoidHom (G i) K\nk : MonoidHom H K\nhf : ∀ (i : ι), Eq ((f i).comp (φ i)) k\ni : ι\ng : G i\n⊢ Eq ((Monoid.PushoutI.lift f k hf) ((Monoid.PushoutI.of i) g)) ((f i) g)","decl":"@[simp]\ntheorem lift_of (f : ∀ i, G i →* K) (k : H →* K)\n    (hf : ∀ i, (f i).comp (φ i) = k)\n    {i : ι} (g : G i) : (lift f k hf) (of i g : PushoutI φ) = f i g := by\n  delta PushoutI lift of\n  simp only [MonoidHom.coe_comp, Con.coe_mk', comp_apply, Con.lift_coe,\n    lift_apply_inl, CoprodI.lift_of]\n\n"}
{"name":"Monoid.PushoutI.lift_base","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\nK : Type u_4\ninst✝² : Monoid K\ninst✝¹ : (i : ι) → Monoid (G i)\ninst✝ : Monoid H\nφ : (i : ι) → MonoidHom H (G i)\nf : (i : ι) → MonoidHom (G i) K\nk : MonoidHom H K\nhf : ∀ (i : ι), Eq ((f i).comp (φ i)) k\ng : H\n⊢ Eq ((Monoid.PushoutI.lift f k hf) ((Monoid.PushoutI.base φ) g)) (k g)","decl":"@[simp]\ntheorem lift_base (f : ∀ i, G i →* K) (k : H →* K)\n    (hf : ∀ i, (f i).comp (φ i) = k)\n    (g : H) : (lift f k hf) (base φ g : PushoutI φ) = k g := by\n  delta PushoutI lift base\n  simp only [MonoidHom.coe_comp, Con.coe_mk', comp_apply, Con.lift_coe, lift_apply_inr]\n\n-- `ext` attribute should be lower priority then `hom_ext_nonempty`\n"}
{"name":"Monoid.PushoutI.hom_ext_iff","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\nK : Type u_4\ninst✝² : Monoid K\ninst✝¹ : (i : ι) → Monoid (G i)\ninst✝ : Monoid H\nφ : (i : ι) → MonoidHom H (G i)\nf g : MonoidHom (Monoid.PushoutI φ) K\n⊢ Iff (Eq f g) (And (∀ (i : ι), Eq (f.comp (Monoid.PushoutI.of i)) (g.comp (Monoid.PushoutI.of i))) (Eq (f.comp (Monoid.PushoutI.base φ)) (g.comp (Monoid.PushoutI.base φ))))","decl":"@[ext 1199]\ntheorem hom_ext {f g : PushoutI φ →* K}\n    (h : ∀ i, f.comp (of i : G i →* _) = g.comp (of i : G i →* _))\n    (hbase : f.comp (base φ) = g.comp (base φ)) : f = g :=\n  (MonoidHom.cancel_right Con.mk'_surjective).mp <|\n    Coprod.hom_ext\n      (CoprodI.ext_hom _ _ h)\n      hbase\n\n"}
{"name":"Monoid.PushoutI.hom_ext","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\nK : Type u_4\ninst✝² : Monoid K\ninst✝¹ : (i : ι) → Monoid (G i)\ninst✝ : Monoid H\nφ : (i : ι) → MonoidHom H (G i)\nf g : MonoidHom (Monoid.PushoutI φ) K\nh : ∀ (i : ι), Eq (f.comp (Monoid.PushoutI.of i)) (g.comp (Monoid.PushoutI.of i))\nhbase : Eq (f.comp (Monoid.PushoutI.base φ)) (g.comp (Monoid.PushoutI.base φ))\n⊢ Eq f g","decl":"@[ext 1199]\ntheorem hom_ext {f g : PushoutI φ →* K}\n    (h : ∀ i, f.comp (of i : G i →* _) = g.comp (of i : G i →* _))\n    (hbase : f.comp (base φ) = g.comp (base φ)) : f = g :=\n  (MonoidHom.cancel_right Con.mk'_surjective).mp <|\n    Coprod.hom_ext\n      (CoprodI.ext_hom _ _ h)\n      hbase\n\n"}
{"name":"Monoid.PushoutI.hom_ext_nonempty","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\nK : Type u_4\ninst✝² : Monoid K\ninst✝¹ : (i : ι) → Monoid (G i)\ninst✝ : Monoid H\nφ : (i : ι) → MonoidHom H (G i)\nhn : Nonempty ι\nf g : MonoidHom (Monoid.PushoutI φ) K\nh : ∀ (i : ι), Eq (f.comp (Monoid.PushoutI.of i)) (g.comp (Monoid.PushoutI.of i))\n⊢ Eq f g","decl":"@[ext high]\ntheorem hom_ext_nonempty [hn : Nonempty ι]\n    {f g : PushoutI φ →* K}\n    (h : ∀ i, f.comp (of i : G i →* _) = g.comp (of i : G i →* _)) : f = g :=\n  hom_ext h <| by\n    cases hn with\n    | intro i =>\n      ext\n      rw [← of_comp_eq_base i, ← MonoidHom.comp_assoc, h, MonoidHom.comp_assoc]\n\n"}
{"name":"Monoid.PushoutI.hom_ext_nonempty_iff","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\nK : Type u_4\ninst✝² : Monoid K\ninst✝¹ : (i : ι) → Monoid (G i)\ninst✝ : Monoid H\nφ : (i : ι) → MonoidHom H (G i)\nhn : Nonempty ι\nf g : MonoidHom (Monoid.PushoutI φ) K\n⊢ Iff (Eq f g) (∀ (i : ι), Eq (f.comp (Monoid.PushoutI.of i)) (g.comp (Monoid.PushoutI.of i)))","decl":"@[ext high]\ntheorem hom_ext_nonempty [hn : Nonempty ι]\n    {f g : PushoutI φ →* K}\n    (h : ∀ i, f.comp (of i : G i →* _) = g.comp (of i : G i →* _)) : f = g :=\n  hom_ext h <| by\n    cases hn with\n    | intro i =>\n      ext\n      rw [← of_comp_eq_base i, ← MonoidHom.comp_assoc, h, MonoidHom.comp_assoc]\n\n"}
{"name":"Monoid.PushoutI.homEquiv_apply_coe","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\nK : Type u_4\ninst✝² : Monoid K\ninst✝¹ : (i : ι) → Monoid (G i)\ninst✝ : Monoid H\nφ : (i : ι) → MonoidHom H (G i)\nf : MonoidHom (Monoid.PushoutI φ) K\n⊢ Eq ↑(Monoid.PushoutI.homEquiv f) { fst := fun i => f.comp (Monoid.PushoutI.of i), snd := f.comp (Monoid.PushoutI.base φ) }","decl":"/-- The equivalence that is part of the universal property of the pushout. A hom out of\nthe pushout is just a morphism out of all groups in the pushout that satisfies a commutativity\ncondition. -/\n@[simps]\ndef homEquiv :\n    (PushoutI φ →* K) ≃ { f : (Π i, G i →* K) × (H →* K) // ∀ i, (f.1 i).comp (φ i) = f.2 } :=\n  { toFun := fun f => ⟨(fun i => f.comp (of i), f.comp (base φ)),\n      fun i => by rw [MonoidHom.comp_assoc, of_comp_eq_base]⟩\n    invFun := fun f => lift f.1.1 f.1.2 f.2,\n    left_inv := fun _ => hom_ext (by simp [DFunLike.ext_iff])\n      (by simp [DFunLike.ext_iff])\n    right_inv := fun ⟨⟨_, _⟩, _⟩ => by simp [DFunLike.ext_iff, funext_iff] }\n\n"}
{"name":"Monoid.PushoutI.homEquiv_symm_apply","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\nK : Type u_4\ninst✝² : Monoid K\ninst✝¹ : (i : ι) → Monoid (G i)\ninst✝ : Monoid H\nφ : (i : ι) → MonoidHom H (G i)\nf : Subtype fun f => ∀ (i : ι), Eq ((f.1 i).comp (φ i)) f.2\n⊢ Eq (Monoid.PushoutI.homEquiv.symm f) (Monoid.PushoutI.lift (↑f).1 (↑f).2 ⋯)","decl":"/-- The equivalence that is part of the universal property of the pushout. A hom out of\nthe pushout is just a morphism out of all groups in the pushout that satisfies a commutativity\ncondition. -/\n@[simps]\ndef homEquiv :\n    (PushoutI φ →* K) ≃ { f : (Π i, G i →* K) × (H →* K) // ∀ i, (f.1 i).comp (φ i) = f.2 } :=\n  { toFun := fun f => ⟨(fun i => f.comp (of i), f.comp (base φ)),\n      fun i => by rw [MonoidHom.comp_assoc, of_comp_eq_base]⟩\n    invFun := fun f => lift f.1.1 f.1.2 f.2,\n    left_inv := fun _ => hom_ext (by simp [DFunLike.ext_iff])\n      (by simp [DFunLike.ext_iff])\n    right_inv := fun ⟨⟨_, _⟩, _⟩ => by simp [DFunLike.ext_iff, funext_iff] }\n\n"}
{"name":"Monoid.PushoutI.ofCoprodI_of","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝¹ : (i : ι) → Monoid (G i)\ninst✝ : Monoid H\nφ : (i : ι) → MonoidHom H (G i)\ni : ι\ng : G i\n⊢ Eq (Monoid.PushoutI.ofCoprodI (Monoid.CoprodI.of g)) ((Monoid.PushoutI.of i) g)","decl":"@[simp]\ntheorem ofCoprodI_of (i : ι) (g : G i) :\n    (ofCoprodI (CoprodI.of g) : PushoutI φ) = of i g := by\n  simp [ofCoprodI]\n\n"}
{"name":"Monoid.PushoutI.induction_on","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝¹ : (i : ι) → Monoid (G i)\ninst✝ : Monoid H\nφ : (i : ι) → MonoidHom H (G i)\nmotive : Monoid.PushoutI φ → Prop\nx : Monoid.PushoutI φ\nof : ∀ (i : ι) (g : G i), motive ((Monoid.PushoutI.of i) g)\nbase : ∀ (h : H), motive ((Monoid.PushoutI.base φ) h)\nmul : ∀ (x y : Monoid.PushoutI φ), motive x → motive y → motive (HMul.hMul x y)\n⊢ motive x","decl":"theorem induction_on {motive : PushoutI φ → Prop}\n    (x : PushoutI φ)\n    (of : ∀ (i : ι) (g : G i), motive (of i g))\n    (base : ∀ h, motive (base φ h))\n    (mul : ∀ x y, motive x → motive y → motive (x * y)) : motive x := by\n  delta PushoutI PushoutI.of PushoutI.base at *\n  induction x using Con.induction_on with\n  | H x =>\n    induction x using Coprod.induction_on with\n    | inl g =>\n      induction g using CoprodI.induction_on with\n      | h_of i g => exact of i g\n      | h_mul x y ihx ihy =>\n        rw [map_mul]\n        exact mul _ _ ihx ihy\n      | h_one => simpa using base 1\n    | inr h => exact base h\n    | mul x y ihx ihy => exact mul _ _ ihx ihy\n\n"}
{"name":"Monoid.PushoutI.NormalWord.Transversal.mk.inj","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : Group H\nφ : (i : ι) → MonoidHom H (G i)\ninjective✝ : ∀ (i : ι), Function.Injective ⇑(φ i)\nset✝ : (i : ι) → Set (G i)\none_mem✝ : ∀ (i : ι), Membership.mem (set✝ i) 1\ncompl✝ : ∀ (i : ι), Subgroup.IsComplement (↑(φ i).range) (set✝ i)\ninjective : ∀ (i : ι), Function.Injective ⇑(φ i)\nset : (i : ι) → Set (G i)\none_mem : ∀ (i : ι), Membership.mem (set i) 1\ncompl : ∀ (i : ι), Subgroup.IsComplement (↑(φ i).range) (set i)\nx✝ : Eq { injective := injective✝, set := set✝, one_mem := one_mem✝, compl := compl✝ } { injective := injective, set := set, one_mem := one_mem, compl := compl }\n⊢ Eq set✝ set","decl":"/-- The data we need to pick a normal form for words in the pushout. We need to pick a\ncanonical element of each coset. We also need all the maps in the diagram to be injective  -/\nstructure Transversal : Type _ where\n  /-- All maps in the diagram are injective -/\n  injective : ∀ i, Injective (φ i)\n  /-- The underlying set, containing exactly one element of each coset of the base group -/\n  set : ∀ i, Set (G i)\n  /-- The chosen element of the base group itself is the identity -/\n  one_mem : ∀ i, 1 ∈ set i\n  /-- We have exactly one element of each coset of the base group -/\n  compl : ∀ i, IsComplement (φ i).range (set i)\n\n"}
{"name":"Monoid.PushoutI.NormalWord.Transversal.injective","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : Group H\nφ : (i : ι) → MonoidHom H (G i)\nself : Monoid.PushoutI.NormalWord.Transversal φ\ni : ι\n⊢ Function.Injective ⇑(φ i)","decl":"/-- The data we need to pick a normal form for words in the pushout. We need to pick a\ncanonical element of each coset. We also need all the maps in the diagram to be injective  -/\nstructure Transversal : Type _ where\n  /-- All maps in the diagram are injective -/\n  injective : ∀ i, Injective (φ i)\n  /-- The underlying set, containing exactly one element of each coset of the base group -/\n  set : ∀ i, Set (G i)\n  /-- The chosen element of the base group itself is the identity -/\n  one_mem : ∀ i, 1 ∈ set i\n  /-- We have exactly one element of each coset of the base group -/\n  compl : ∀ i, IsComplement (φ i).range (set i)\n\n"}
{"name":"Monoid.PushoutI.NormalWord.Transversal.compl","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : Group H\nφ : (i : ι) → MonoidHom H (G i)\nself : Monoid.PushoutI.NormalWord.Transversal φ\ni : ι\n⊢ Subgroup.IsComplement (↑(φ i).range) (self.set i)","decl":"/-- The data we need to pick a normal form for words in the pushout. We need to pick a\ncanonical element of each coset. We also need all the maps in the diagram to be injective  -/\nstructure Transversal : Type _ where\n  /-- All maps in the diagram are injective -/\n  injective : ∀ i, Injective (φ i)\n  /-- The underlying set, containing exactly one element of each coset of the base group -/\n  set : ∀ i, Set (G i)\n  /-- The chosen element of the base group itself is the identity -/\n  one_mem : ∀ i, 1 ∈ set i\n  /-- We have exactly one element of each coset of the base group -/\n  compl : ∀ i, IsComplement (φ i).range (set i)\n\n"}
{"name":"Monoid.PushoutI.NormalWord.Transversal.one_mem","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : Group H\nφ : (i : ι) → MonoidHom H (G i)\nself : Monoid.PushoutI.NormalWord.Transversal φ\ni : ι\n⊢ Membership.mem (self.set i) 1","decl":"/-- The data we need to pick a normal form for words in the pushout. We need to pick a\ncanonical element of each coset. We also need all the maps in the diagram to be injective  -/\nstructure Transversal : Type _ where\n  /-- All maps in the diagram are injective -/\n  injective : ∀ i, Injective (φ i)\n  /-- The underlying set, containing exactly one element of each coset of the base group -/\n  set : ∀ i, Set (G i)\n  /-- The chosen element of the base group itself is the identity -/\n  one_mem : ∀ i, 1 ∈ set i\n  /-- We have exactly one element of each coset of the base group -/\n  compl : ∀ i, IsComplement (φ i).range (set i)\n\n"}
{"name":"Monoid.PushoutI.NormalWord.Transversal.mk.injEq","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : Group H\nφ : (i : ι) → MonoidHom H (G i)\ninjective✝ : ∀ (i : ι), Function.Injective ⇑(φ i)\nset✝ : (i : ι) → Set (G i)\none_mem✝ : ∀ (i : ι), Membership.mem (set✝ i) 1\ncompl✝ : ∀ (i : ι), Subgroup.IsComplement (↑(φ i).range) (set✝ i)\ninjective : ∀ (i : ι), Function.Injective ⇑(φ i)\nset : (i : ι) → Set (G i)\none_mem : ∀ (i : ι), Membership.mem (set i) 1\ncompl : ∀ (i : ι), Subgroup.IsComplement (↑(φ i).range) (set i)\n⊢ Eq (Eq { injective := injective✝, set := set✝, one_mem := one_mem✝, compl := compl✝ } { injective := injective, set := set, one_mem := one_mem, compl := compl }) (Eq set✝ set)","decl":"/-- The data we need to pick a normal form for words in the pushout. We need to pick a\ncanonical element of each coset. We also need all the maps in the diagram to be injective  -/\nstructure Transversal : Type _ where\n  /-- All maps in the diagram are injective -/\n  injective : ∀ i, Injective (φ i)\n  /-- The underlying set, containing exactly one element of each coset of the base group -/\n  set : ∀ i, Set (G i)\n  /-- The chosen element of the base group itself is the identity -/\n  one_mem : ∀ i, 1 ∈ set i\n  /-- We have exactly one element of each coset of the base group -/\n  compl : ∀ i, IsComplement (φ i).range (set i)\n\n"}
{"name":"Monoid.PushoutI.NormalWord.Transversal.mk.sizeOf_spec","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝⁴ : (i : ι) → Group (G i)\ninst✝³ : Group H\nφ : (i : ι) → MonoidHom H (G i)\ninst✝² : SizeOf ι\ninst✝¹ : (a : ι) → SizeOf (G a)\ninst✝ : SizeOf H\ninjective : ∀ (i : ι), Function.Injective ⇑(φ i)\nset : (i : ι) → Set (G i)\none_mem : ∀ (i : ι), Membership.mem (set i) 1\ncompl : ∀ (i : ι), Subgroup.IsComplement (↑(φ i).range) (set i)\n⊢ Eq (SizeOf.sizeOf { injective := injective, set := set, one_mem := one_mem, compl := compl }) 1","decl":"/-- The data we need to pick a normal form for words in the pushout. We need to pick a\ncanonical element of each coset. We also need all the maps in the diagram to be injective  -/\nstructure Transversal : Type _ where\n  /-- All maps in the diagram are injective -/\n  injective : ∀ i, Injective (φ i)\n  /-- The underlying set, containing exactly one element of each coset of the base group -/\n  set : ∀ i, Set (G i)\n  /-- The chosen element of the base group itself is the identity -/\n  one_mem : ∀ i, 1 ∈ set i\n  /-- We have exactly one element of each coset of the base group -/\n  compl : ∀ i, IsComplement (φ i).range (set i)\n\n"}
{"name":"Monoid.PushoutI.NormalWord.transversal_nonempty","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : Group H\nφ : (i : ι) → MonoidHom H (G i)\nhφ : ∀ (i : ι), Function.Injective ⇑(φ i)\n⊢ Nonempty (Monoid.PushoutI.NormalWord.Transversal φ)","decl":"theorem transversal_nonempty (hφ : ∀ i, Injective (φ i)) : Nonempty (Transversal φ) := by\n  choose t ht using fun i => (φ i).range.exists_isComplement_right 1\n  apply Nonempty.intro\n  exact\n    { injective := hφ\n      set := t\n      one_mem := fun i => (ht i).2\n      compl := fun i => (ht i).1 }\n\n"}
{"name":"Monoid.PushoutI.NormalWord.mk.injEq","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\ntoWord✝ : Monoid.CoprodI.Word G\nhead✝ : H\nnormalized✝ : ∀ (i : ι) (g : G i), Membership.mem toWord✝.toList ⟨i, g⟩ → Membership.mem (d.set i) g\ntoWord : Monoid.CoprodI.Word G\nhead : H\nnormalized : ∀ (i : ι) (g : G i), Membership.mem toWord.toList ⟨i, g⟩ → Membership.mem (d.set i) g\n⊢ Eq (Eq { toWord := toWord✝, head := head✝, normalized := normalized✝ } { toWord := toWord, head := head, normalized := normalized }) (And (Eq toWord✝ toWord) (Eq head✝ head))","decl":"/-- The normal form for words in the pushout. Every element of the pushout is the product of an\nelement of the base group and a word made up of letters each of which is in the transversal. -/\nstructure _root_.Monoid.PushoutI.NormalWord (d : Transversal φ) extends CoprodI.Word G where\n  /-- Every `NormalWord` is the product of an element of the base group and a word made up\n  of letters each of which is in the transversal. `head` is that element of the base group. -/\n  head : H\n  /-- All letter in the word are in the transversal. -/\n  normalized : ∀ i g, ⟨i, g⟩ ∈ toList → g ∈ d.set i\n\n"}
{"name":"Monoid.PushoutI.NormalWord.mk.inj","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\ntoWord✝ : Monoid.CoprodI.Word G\nhead✝ : H\nnormalized✝ : ∀ (i : ι) (g : G i), Membership.mem toWord✝.toList ⟨i, g⟩ → Membership.mem (d.set i) g\ntoWord : Monoid.CoprodI.Word G\nhead : H\nnormalized : ∀ (i : ι) (g : G i), Membership.mem toWord.toList ⟨i, g⟩ → Membership.mem (d.set i) g\nx✝ : Eq { toWord := toWord✝, head := head✝, normalized := normalized✝ } { toWord := toWord, head := head, normalized := normalized }\n⊢ And (Eq toWord✝ toWord) (Eq head✝ head)","decl":"/-- The normal form for words in the pushout. Every element of the pushout is the product of an\nelement of the base group and a word made up of letters each of which is in the transversal. -/\nstructure _root_.Monoid.PushoutI.NormalWord (d : Transversal φ) extends CoprodI.Word G where\n  /-- Every `NormalWord` is the product of an element of the base group and a word made up\n  of letters each of which is in the transversal. `head` is that element of the base group. -/\n  head : H\n  /-- All letter in the word are in the transversal. -/\n  normalized : ∀ i g, ⟨i, g⟩ ∈ toList → g ∈ d.set i\n\n"}
{"name":"Monoid.PushoutI.NormalWord.mk.sizeOf_spec","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝⁴ : (i : ι) → Group (G i)\ninst✝³ : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\ninst✝² : SizeOf ι\ninst✝¹ : (a : ι) → SizeOf (G a)\ninst✝ : SizeOf H\ntoWord : Monoid.CoprodI.Word G\nhead : H\nnormalized : ∀ (i : ι) (g : G i), Membership.mem toWord.toList ⟨i, g⟩ → Membership.mem (d.set i) g\n⊢ Eq (SizeOf.sizeOf { toWord := toWord, head := head, normalized := normalized }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toWord)) (SizeOf.sizeOf head))","decl":"/-- The normal form for words in the pushout. Every element of the pushout is the product of an\nelement of the base group and a word made up of letters each of which is in the transversal. -/\nstructure _root_.Monoid.PushoutI.NormalWord (d : Transversal φ) extends CoprodI.Word G where\n  /-- Every `NormalWord` is the product of an element of the base group and a word made up\n  of letters each of which is in the transversal. `head` is that element of the base group. -/\n  head : H\n  /-- All letter in the word are in the transversal. -/\n  normalized : ∀ i g, ⟨i, g⟩ ∈ toList → g ∈ d.set i\n\n"}
{"name":"Monoid.PushoutI.NormalWord.normalized","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\nself : Monoid.PushoutI.NormalWord d\ni : ι\ng : G i\na✝ : Membership.mem self.toList ⟨i, g⟩\n⊢ Membership.mem (d.set i) g","decl":"/-- The normal form for words in the pushout. Every element of the pushout is the product of an\nelement of the base group and a word made up of letters each of which is in the transversal. -/\nstructure _root_.Monoid.PushoutI.NormalWord (d : Transversal φ) extends CoprodI.Word G where\n  /-- Every `NormalWord` is the product of an element of the base group and a word made up\n  of letters each of which is in the transversal. `head` is that element of the base group. -/\n  head : H\n  /-- All letter in the word are in the transversal. -/\n  normalized : ∀ i g, ⟨i, g⟩ ∈ toList → g ∈ d.set i\n\n"}
{"name":"Monoid.PushoutI.NormalWord.Pair.normalized","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\ni✝ : ι\nself : Monoid.PushoutI.NormalWord.Pair d i✝\ni : ι\ng : G i\na✝ : Membership.mem self.tail.toList ⟨i, g⟩\n⊢ Membership.mem (d.set i) g","decl":"/--\nA `Pair d i` is a word in the coproduct, `Coprod G`, the `tail`, and an element of the group `G i`,\nthe `head`. The first letter of the `tail` must not be an element of `G i`.\nNote that the `head` may be `1` Every letter in the `tail` must be in the transversal given by `d`.\nSimilar to `Monoid.CoprodI.Pair` except every letter must be in the transversal\n(not including the head letter). -/\nstructure Pair (d : Transversal φ) (i : ι) extends CoprodI.Word.Pair G i where\n  /-- All letters in the word are in the transversal. -/\n  normalized : ∀ i g, ⟨i, g⟩ ∈ tail.toList → g ∈ d.set i\n\n"}
{"name":"Monoid.PushoutI.NormalWord.Pair.mk.sizeOf_spec","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝⁴ : (i : ι) → Group (G i)\ninst✝³ : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\ni : ι\ninst✝² : SizeOf ι\ninst✝¹ : (a : ι) → SizeOf (G a)\ninst✝ : SizeOf H\ntoPair : Monoid.CoprodI.Word.Pair G i\nnormalized : ∀ (i_1 : ι) (g : G i_1), Membership.mem toPair.tail.toList ⟨i_1, g⟩ → Membership.mem (d.set i_1) g\n⊢ Eq (SizeOf.sizeOf { toPair := toPair, normalized := normalized }) (HAdd.hAdd 1 (SizeOf.sizeOf toPair))","decl":"/--\nA `Pair d i` is a word in the coproduct, `Coprod G`, the `tail`, and an element of the group `G i`,\nthe `head`. The first letter of the `tail` must not be an element of `G i`.\nNote that the `head` may be `1` Every letter in the `tail` must be in the transversal given by `d`.\nSimilar to `Monoid.CoprodI.Pair` except every letter must be in the transversal\n(not including the head letter). -/\nstructure Pair (d : Transversal φ) (i : ι) extends CoprodI.Word.Pair G i where\n  /-- All letters in the word are in the transversal. -/\n  normalized : ∀ i g, ⟨i, g⟩ ∈ tail.toList → g ∈ d.set i\n\n"}
{"name":"Monoid.PushoutI.NormalWord.Pair.mk.injEq","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\ni : ι\ntoPair✝ : Monoid.CoprodI.Word.Pair G i\nnormalized✝ : ∀ (i_1 : ι) (g : G i_1), Membership.mem toPair✝.tail.toList ⟨i_1, g⟩ → Membership.mem (d.set i_1) g\ntoPair : Monoid.CoprodI.Word.Pair G i\nnormalized : ∀ (i_1 : ι) (g : G i_1), Membership.mem toPair.tail.toList ⟨i_1, g⟩ → Membership.mem (d.set i_1) g\n⊢ Eq (Eq { toPair := toPair✝, normalized := normalized✝ } { toPair := toPair, normalized := normalized }) (Eq toPair✝ toPair)","decl":"/--\nA `Pair d i` is a word in the coproduct, `Coprod G`, the `tail`, and an element of the group `G i`,\nthe `head`. The first letter of the `tail` must not be an element of `G i`.\nNote that the `head` may be `1` Every letter in the `tail` must be in the transversal given by `d`.\nSimilar to `Monoid.CoprodI.Pair` except every letter must be in the transversal\n(not including the head letter). -/\nstructure Pair (d : Transversal φ) (i : ι) extends CoprodI.Word.Pair G i where\n  /-- All letters in the word are in the transversal. -/\n  normalized : ∀ i g, ⟨i, g⟩ ∈ tail.toList → g ∈ d.set i\n\n"}
{"name":"Monoid.PushoutI.NormalWord.Pair.mk.inj","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\ni : ι\ntoPair✝ : Monoid.CoprodI.Word.Pair G i\nnormalized✝ : ∀ (i_1 : ι) (g : G i_1), Membership.mem toPair✝.tail.toList ⟨i_1, g⟩ → Membership.mem (d.set i_1) g\ntoPair : Monoid.CoprodI.Word.Pair G i\nnormalized : ∀ (i_1 : ι) (g : G i_1), Membership.mem toPair.tail.toList ⟨i_1, g⟩ → Membership.mem (d.set i_1) g\nx✝ : Eq { toPair := toPair✝, normalized := normalized✝ } { toPair := toPair, normalized := normalized }\n⊢ Eq toPair✝ toPair","decl":"/--\nA `Pair d i` is a word in the coproduct, `Coprod G`, the `tail`, and an element of the group `G i`,\nthe `head`. The first letter of the `tail` must not be an element of `G i`.\nNote that the `head` may be `1` Every letter in the `tail` must be in the transversal given by `d`.\nSimilar to `Monoid.CoprodI.Pair` except every letter must be in the transversal\n(not including the head letter). -/\nstructure Pair (d : Transversal φ) (i : ι) extends CoprodI.Word.Pair G i where\n  /-- All letters in the word are in the transversal. -/\n  normalized : ∀ i g, ⟨i, g⟩ ∈ tail.toList → g ∈ d.set i\n\n"}
{"name":"Monoid.PushoutI.NormalWord.empty_head","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\n⊢ Eq Monoid.PushoutI.NormalWord.empty.head 1","decl":"/-- The empty normalized word, representing the identity element of the group. -/\n@[simps!]\ndef empty : NormalWord d := ⟨CoprodI.Word.empty, 1, fun i g => by simp [CoprodI.Word.empty]⟩\n\n"}
{"name":"Monoid.PushoutI.NormalWord.empty_toList","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\n⊢ Eq Monoid.PushoutI.NormalWord.empty.toList List.nil","decl":"/-- The empty normalized word, representing the identity element of the group. -/\n@[simps!]\ndef empty : NormalWord d := ⟨CoprodI.Word.empty, 1, fun i g => by simp [CoprodI.Word.empty]⟩\n\n"}
{"name":"Monoid.PushoutI.NormalWord.ext_iff","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\nw₁ w₂ : Monoid.PushoutI.NormalWord d\n⊢ Iff (Eq w₁ w₂) (And (Eq w₁.head w₂.head) (Eq w₁.toList w₂.toList))","decl":"@[ext]\ntheorem ext {w₁ w₂ : NormalWord d} (hhead : w₁.head = w₂.head)\n    (hlist : w₁.toList = w₂.toList) : w₁ = w₂ := by\n  rcases w₁ with ⟨⟨_, _, _⟩, _, _⟩\n  rcases w₂ with ⟨⟨_, _, _⟩, _, _⟩\n  simp_all\n\n"}
{"name":"Monoid.PushoutI.NormalWord.ext","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\nw₁ w₂ : Monoid.PushoutI.NormalWord d\nhhead : Eq w₁.head w₂.head\nhlist : Eq w₁.toList w₂.toList\n⊢ Eq w₁ w₂","decl":"@[ext]\ntheorem ext {w₁ w₂ : NormalWord d} (hhead : w₁.head = w₂.head)\n    (hlist : w₁.toList = w₂.toList) : w₁ = w₂ := by\n  rcases w₁ with ⟨⟨_, _, _⟩, _, _⟩\n  rcases w₂ with ⟨⟨_, _, _⟩, _, _⟩\n  simp_all\n\n"}
{"name":"Monoid.PushoutI.NormalWord.base_smul_def'","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\nh : H\nw : Monoid.PushoutI.NormalWord d\n⊢ Eq (HSMul.hSMul h w) { toWord := w.toWord, head := HMul.hMul h w.head, normalized := ⋯ }","decl":"theorem base_smul_def' (h : H) (w : NormalWord d) :\n    h • w = { w with head := h * w.head } := rfl\n"}
{"name":"Monoid.PushoutI.NormalWord.prod_base_smul","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\nh : H\nw : Monoid.PushoutI.NormalWord d\n⊢ Eq (HSMul.hSMul h w).prod (HMul.hMul ((Monoid.PushoutI.base φ) h) w.prod)","decl":"@[simp]\ntheorem prod_base_smul (h : H) (w : NormalWord d) :\n    (h • w).prod = base φ h * w.prod := by\n  simp only [base_smul_def', prod, map_mul, mul_assoc]\n\n"}
{"name":"Monoid.PushoutI.NormalWord.prod_empty","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\n⊢ Eq Monoid.PushoutI.NormalWord.empty.prod 1","decl":"@[simp]\ntheorem prod_empty : (empty : NormalWord d).prod = 1 := by\n  simp [prod, empty]\n\n"}
{"name":"Monoid.PushoutI.NormalWord.cons_head","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\ni : ι\ng : G i\nw : Monoid.PushoutI.NormalWord d\nhmw : Ne w.fstIdx (Option.some i)\nhgr : Not (Membership.mem (φ i).range g)\n⊢ Eq (Monoid.PushoutI.NormalWord.cons g w hmw hgr).head ((MonoidHom.ofInjective ⋯).symm (⋯.equiv (HMul.hMul g ((φ i) w.head))).1)","decl":"/-- A constructor that multiplies a `NormalWord` by an element, with condition to make\nsure the underlying list does get longer. -/\n@[simps!]\nnoncomputable def cons {i} (g : G i) (w : NormalWord d) (hmw : w.fstIdx ≠ some i)\n    (hgr : g ∉ (φ i).range) : NormalWord d :=\n  letI n := (d.compl i).equiv (g * (φ i w.head))\n  letI w' := Word.cons (n.2 : G i) w.toWord hmw\n    (mt (coe_equiv_snd_eq_one_iff_mem _ (d.one_mem _)).1\n      (mt (mul_mem_cancel_right (by simp)).1 hgr))\n  { toWord := w'\n    head := (MonoidHom.ofInjective (d.injective i)).symm n.1\n    normalized := fun i g hg => by\n      simp only [w', Word.cons, mem_cons, Sigma.mk.inj_iff] at hg\n      rcases hg with ⟨rfl, hg | hg⟩\n      · simp\n      · exact w.normalized _ _ (by assumption) }\n\n"}
{"name":"Monoid.PushoutI.NormalWord.cons_toList","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\ni : ι\ng : G i\nw : Monoid.PushoutI.NormalWord d\nhmw : Ne w.fstIdx (Option.some i)\nhgr : Not (Membership.mem (φ i).range g)\n⊢ Eq (Monoid.PushoutI.NormalWord.cons g w hmw hgr).toList (List.cons ⟨i, ↑(⋯.equiv (HMul.hMul g ((φ i) w.head))).2⟩ w.toList)","decl":"/-- A constructor that multiplies a `NormalWord` by an element, with condition to make\nsure the underlying list does get longer. -/\n@[simps!]\nnoncomputable def cons {i} (g : G i) (w : NormalWord d) (hmw : w.fstIdx ≠ some i)\n    (hgr : g ∉ (φ i).range) : NormalWord d :=\n  letI n := (d.compl i).equiv (g * (φ i w.head))\n  letI w' := Word.cons (n.2 : G i) w.toWord hmw\n    (mt (coe_equiv_snd_eq_one_iff_mem _ (d.one_mem _)).1\n      (mt (mul_mem_cancel_right (by simp)).1 hgr))\n  { toWord := w'\n    head := (MonoidHom.ofInjective (d.injective i)).symm n.1\n    normalized := fun i g hg => by\n      simp only [w', Word.cons, mem_cons, Sigma.mk.inj_iff] at hg\n      rcases hg with ⟨rfl, hg | hg⟩\n      · simp\n      · exact w.normalized _ _ (by assumption) }\n\n"}
{"name":"Monoid.PushoutI.NormalWord.prod_cons","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\ni : ι\ng : G i\nw : Monoid.PushoutI.NormalWord d\nhmw : Ne w.fstIdx (Option.some i)\nhgr : Not (Membership.mem (φ i).range g)\n⊢ Eq (Monoid.PushoutI.NormalWord.cons g w hmw hgr).prod (HMul.hMul ((Monoid.PushoutI.of i) g) w.prod)","decl":"@[simp]\ntheorem prod_cons {i} (g : G i) (w : NormalWord d) (hmw : w.fstIdx ≠ some i)\n    (hgr : g ∉ (φ i).range) : (cons g w hmw hgr).prod = of i g * w.prod := by\n  simp [prod, cons, ← of_apply_eq_base φ i, equiv_fst_eq_mul_inv, mul_assoc]\n\n"}
{"name":"Monoid.PushoutI.NormalWord.eq_one_of_smul_normalized","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝³ : (i : ι) → Group (G i)\ninst✝² : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (G i)\nw : Monoid.CoprodI.Word G\ni : ι\nh : H\nhw : ∀ (i : ι) (g : G i), Membership.mem w.toList ⟨i, g⟩ → Membership.mem (d.set i) g\nhφw : ∀ (j : ι) (g : G j), Membership.mem (HSMul.hSMul (Monoid.CoprodI.of ((φ i) h)) w).toList ⟨j, g⟩ → Membership.mem (d.set j) g\n⊢ Eq h 1","decl":"/-- Given a word in `CoprodI`, if every letter is in the transversal and when\nwe multiply by an element of the base group it still has this property,\nthen the element of the base group we multiplied by was one. -/\ntheorem eq_one_of_smul_normalized (w : CoprodI.Word G) {i : ι} (h : H)\n    (hw : ∀ i g, ⟨i, g⟩ ∈ w.toList → g ∈ d.set i)\n    (hφw : ∀ j g, ⟨j, g⟩ ∈ (CoprodI.of (φ i h) • w).toList → g ∈ d.set j) :\n    h = 1 := by\n  simp only [← (d.compl _).equiv_snd_eq_self_iff_mem (one_mem _)] at hw hφw\n  have hhead : ((d.compl i).equiv (Word.equivPair i w).head).2 =\n      (Word.equivPair i w).head := by\n    rw [Word.equivPair_head]\n    split_ifs with h\n    · rcases h with ⟨_, rfl⟩\n      exact hw _ _ (List.head_mem _)\n    · rw [equiv_one (d.compl i) (one_mem _) (d.one_mem _)]\n  by_contra hh1\n  have := hφw i (φ i h * (Word.equivPair i w).head) ?_\n  · apply hh1\n    rw [equiv_mul_left_of_mem (d.compl i) ⟨_, rfl⟩, hhead] at this\n    simpa [((injective_iff_map_eq_one' _).1 (d.injective i))] using this\n  · simp only [Word.mem_smul_iff, not_true, false_and, ne_eq, Option.mem_def, mul_right_inj,\n      exists_eq_right', mul_right_eq_self, exists_prop, true_and, false_or]\n    constructor\n    · intro h\n      apply_fun (d.compl i).equiv at h\n      simp only [Prod.ext_iff, equiv_one (d.compl i) (one_mem _) (d.one_mem _),\n        equiv_mul_left_of_mem (d.compl i) ⟨_, rfl⟩ , hhead, Subtype.ext_iff,\n        Prod.ext_iff, Subgroup.coe_mul] at h\n      rcases h with ⟨h₁, h₂⟩\n      rw [h₂, equiv_one (d.compl i) (one_mem _) (d.one_mem _)] at h₁\n      erw [mul_one] at h₁\n      simp only [((injective_iff_map_eq_one' _).1 (d.injective i))] at h₁\n      contradiction\n    · rw [Word.equivPair_head]\n      dsimp\n      split_ifs with hep\n      · rcases hep with ⟨hnil, rfl⟩\n        rw [head?_eq_head hnil]\n        simp_all\n      · push_neg at hep\n        by_cases hw : w.toList = []\n        · simp [hw, Word.fstIdx]\n        · simp [head?_eq_head hw, Word.fstIdx, hep hw]\n\n"}
{"name":"Monoid.PushoutI.NormalWord.ext_smul","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝³ : (i : ι) → Group (G i)\ninst✝² : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (G i)\nw₁ w₂ : Monoid.PushoutI.NormalWord d\ni : ι\nh : Eq (HSMul.hSMul (Monoid.CoprodI.of ((φ i) w₁.head)) w₁.toWord) (HSMul.hSMul (Monoid.CoprodI.of ((φ i) w₂.head)) w₂.toWord)\n⊢ Eq w₁ w₂","decl":"theorem ext_smul {w₁ w₂ : NormalWord d} (i : ι)\n    (h : CoprodI.of (φ i w₁.head) • w₁.toWord =\n         CoprodI.of (φ i w₂.head) • w₂.toWord) :\n    w₁ = w₂ := by\n  rcases w₁ with ⟨w₁, h₁, hw₁⟩\n  rcases w₂ with ⟨w₂, h₂, hw₂⟩\n  dsimp at *\n  rw [smul_eq_iff_eq_inv_smul, ← mul_smul] at h\n  subst h\n  simp only [← map_inv, ← map_mul] at hw₁\n  have : h₁⁻¹ * h₂ = 1 := eq_one_of_smul_normalized w₂ (h₁⁻¹ * h₂) hw₂ hw₁\n  rw [inv_mul_eq_one] at this; subst this\n  simp\n\n"}
{"name":"Monoid.PushoutI.NormalWord.rcons_injective","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝³ : (i : ι) → Group (G i)\ninst✝² : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (G i)\ni : ι\n⊢ Function.Injective (Monoid.PushoutI.NormalWord.rcons i)","decl":"theorem rcons_injective {i : ι} : Function.Injective (rcons (d := d) i) := by\n  rintro ⟨⟨head₁, tail₁⟩, _⟩ ⟨⟨head₂, tail₂⟩, _⟩\n  simp only [rcons, NormalWord.mk.injEq, EmbeddingLike.apply_eq_iff_eq,\n    Word.Pair.mk.injEq, Pair.mk.injEq, and_imp]\n  intro h₁ h₂ h₃\n  subst h₂\n  rw [← equiv_fst_mul_equiv_snd (d.compl i) head₁,\n      ← equiv_fst_mul_equiv_snd (d.compl i) head₂,\n    h₁, h₃]\n  simp\n\n"}
{"name":"Monoid.PushoutI.NormalWord.summand_smul_def'","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝³ : (i : ι) → Group (G i)\ninst✝² : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (G i)\ni : ι\ng : G i\nw : Monoid.PushoutI.NormalWord d\n⊢ Eq (HSMul.hSMul g w)\n    ((Monoid.PushoutI.NormalWord.equivPair i).symm\n      (let __src := (Monoid.PushoutI.NormalWord.equivPair i) w;\n      { head := HMul.hMul g ((Monoid.PushoutI.NormalWord.equivPair i) w).head, tail := __src.tail, fstIdx_ne := ⋯, normalized := ⋯ }))","decl":"theorem summand_smul_def' {i : ι} (g : G i) (w : NormalWord d) :\n    g • w = (equivPair i).symm\n      { equivPair i w with\n        head := g * (equivPair i w).head } := rfl\n\n"}
{"name":"Monoid.PushoutI.NormalWord.base_smul_def","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝³ : (i : ι) → Group (G i)\ninst✝² : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (G i)\nh : H\nw : Monoid.PushoutI.NormalWord d\n⊢ Eq (HSMul.hSMul ((Monoid.PushoutI.base φ) h) w) { toWord := w.toWord, head := HMul.hMul h w.head, normalized := ⋯ }","decl":"theorem base_smul_def (h : H) (w : NormalWord d) :\n    base φ h • w = { w with head := h * w.head } := by\n  dsimp [NormalWord.mulAction, instHSMul, SMul.smul]\n  rw [lift_base]\n  rfl\n\n"}
{"name":"Monoid.PushoutI.NormalWord.summand_smul_def","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝³ : (i : ι) → Group (G i)\ninst✝² : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (G i)\ni : ι\ng : G i\nw : Monoid.PushoutI.NormalWord d\n⊢ Eq (HSMul.hSMul ((Monoid.PushoutI.of i) g) w)\n    ((Monoid.PushoutI.NormalWord.equivPair i).symm\n      (let __src := (Monoid.PushoutI.NormalWord.equivPair i) w;\n      { head := HMul.hMul g ((Monoid.PushoutI.NormalWord.equivPair i) w).head, tail := __src.tail, fstIdx_ne := ⋯, normalized := ⋯ }))","decl":"theorem summand_smul_def {i : ι} (g : G i) (w : NormalWord d) :\n    of (φ := φ) i g • w = (equivPair i).symm\n      { equivPair i w with\n        head := g * (equivPair i w).head } := by\n  dsimp [NormalWord.mulAction, instHSMul, SMul.smul]\n  rw [lift_of]\n  rfl\n\n"}
{"name":"Monoid.PushoutI.NormalWord.of_smul_eq_smul","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝³ : (i : ι) → Group (G i)\ninst✝² : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (G i)\ni : ι\ng : G i\nw : Monoid.PushoutI.NormalWord d\n⊢ Eq (HSMul.hSMul ((Monoid.PushoutI.of i) g) w) (HSMul.hSMul g w)","decl":"theorem of_smul_eq_smul {i : ι} (g : G i) (w : NormalWord d) :\n    of (φ := φ) i g • w = g • w := by\n  rw [summand_smul_def, summand_smul_def']\n\n"}
{"name":"Monoid.PushoutI.NormalWord.base_smul_eq_smul","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝³ : (i : ι) → Group (G i)\ninst✝² : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (G i)\nh : H\nw : Monoid.PushoutI.NormalWord d\n⊢ Eq (HSMul.hSMul ((Monoid.PushoutI.base φ) h) w) (HSMul.hSMul h w)","decl":"theorem base_smul_eq_smul (h : H) (w : NormalWord d) :\n    base φ h • w = h • w := by\n  rw [base_smul_def, base_smul_def']\n\n"}
{"name":"Monoid.PushoutI.NormalWord.cons_eq_smul","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝³ : (i : ι) → Group (G i)\ninst✝² : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (G i)\ni : ι\ng : G i\nw : Monoid.PushoutI.NormalWord d\nhmw : Ne w.fstIdx (Option.some i)\nhgr : Not (Membership.mem (φ i).range g)\n⊢ Eq (Monoid.PushoutI.NormalWord.cons g w hmw hgr) (HSMul.hSMul ((Monoid.PushoutI.of i) g) w)","decl":"theorem cons_eq_smul {i : ι} (g : G i)\n    (w : NormalWord d) (hmw : w.fstIdx ≠ some i)\n    (hgr : g ∉ (φ i).range) : cons g w hmw hgr = of (φ := φ) i g  • w := by\n  apply ext_smul i\n  simp only [cons, ne_eq, Word.cons_eq_smul, MonoidHom.apply_ofInjective_symm,\n    equiv_fst_eq_mul_inv, mul_assoc, map_mul, map_inv, mul_smul, inv_smul_smul, summand_smul_def,\n    equivPair, rcons, Word.equivPair_symm, Word.rcons_eq_smul, Equiv.coe_fn_mk,\n    Word.equivPair_tail_eq_inv_smul, Equiv.coe_fn_symm_mk, smul_inv_smul]\n\n"}
{"name":"Monoid.PushoutI.NormalWord.prod_summand_smul","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝³ : (i : ι) → Group (G i)\ninst✝² : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (G i)\ni : ι\ng : G i\nw : Monoid.PushoutI.NormalWord d\n⊢ Eq (HSMul.hSMul g w).prod (HMul.hMul ((Monoid.PushoutI.of i) g) w.prod)","decl":"@[simp]\ntheorem prod_summand_smul {i : ι} (g : G i) (w : NormalWord d) :\n    (g • w).prod = of i g * w.prod := by\n  simp only [prod, summand_smul_def', equivPair, rcons, Word.equivPair_symm,\n    Equiv.coe_fn_mk, Equiv.coe_fn_symm_mk, Word.equivPair_smul_same,\n    Word.equivPair_tail_eq_inv_smul, Word.rcons_eq_smul, ← of_apply_eq_base φ i,\n    MonoidHom.apply_ofInjective_symm, equiv_fst_eq_mul_inv, mul_assoc, map_mul, map_inv,\n    Word.prod_smul, ofCoprodI_of, inv_mul_cancel_left, mul_inv_cancel_left]\n\n"}
{"name":"Monoid.PushoutI.NormalWord.prod_smul","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝³ : (i : ι) → Group (G i)\ninst✝² : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (G i)\ng : Monoid.PushoutI φ\nw : Monoid.PushoutI.NormalWord d\n⊢ Eq (HSMul.hSMul g w).prod (HMul.hMul g w.prod)","decl":"@[simp]\ntheorem prod_smul (g : PushoutI φ) (w : NormalWord d) :\n    (g • w).prod = g * w.prod := by\n  induction g using PushoutI.induction_on generalizing w with\n  | of i g => rw [of_smul_eq_smul, prod_summand_smul]\n  | base h => rw [base_smul_eq_smul, prod_base_smul]\n  | mul x y ihx ihy => rw [mul_smul, ihx, ihy, mul_assoc]\n\n"}
{"name":"Monoid.PushoutI.NormalWord.prod_smul_empty","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝³ : (i : ι) → Group (G i)\ninst✝² : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (G i)\nw : Monoid.PushoutI.NormalWord d\n⊢ Eq (HSMul.hSMul w.prod Monoid.PushoutI.NormalWord.empty) w","decl":"theorem prod_smul_empty (w : NormalWord d) : w.prod • empty = w := by\n  induction w using consRecOn with\n  | h_empty => simp\n  | h_cons i g w _ _ _ _ ih =>\n    rw [prod_cons, mul_smul, ih, cons_eq_smul]\n  | h_base h w _ ih =>\n    rw [prod_smul, mul_smul, ih]\n\n"}
{"name":"Monoid.PushoutI.NormalWord.prod_injective","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"H : Type u_3\ninst✝¹ : Group H\nι : Type u_5\nG : ι → Type u_6\ninst✝ : (i : ι) → Group (G i)\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\n⊢ Function.Injective Monoid.PushoutI.NormalWord.prod","decl":"theorem prod_injective {ι : Type*} {G : ι → Type*} [(i : ι) → Group (G i)] {φ : (i : ι) → H →* G i}\n    {d : Transversal φ} : Function.Injective (prod : NormalWord d → PushoutI φ) := by\n  letI := Classical.decEq ι\n  letI := fun i => Classical.decEq (G i)\n  classical exact equiv.symm.injective\n\n"}
{"name":"Monoid.PushoutI.NormalWord.instFaithfulSMul","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝³ : (i : ι) → Group (G i)\ninst✝² : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (G i)\n⊢ FaithfulSMul (Monoid.PushoutI φ) (Monoid.PushoutI.NormalWord d)","decl":"instance : FaithfulSMul (PushoutI φ) (NormalWord d) :=\n  ⟨fun h => by simpa using congr_arg prod (h empty)⟩\n\n"}
{"name":"Monoid.PushoutI.NormalWord.instFaithfulSMul_1","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝³ : (i : ι) → Group (G i)\ninst✝² : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (G i)\ni : ι\n⊢ FaithfulSMul (G i) (Monoid.PushoutI.NormalWord d)","decl":"instance (i : ι) : FaithfulSMul (G i) (NormalWord d) :=\n  ⟨by simp [summand_smul_def']⟩\n\n"}
{"name":"Monoid.PushoutI.NormalWord.instFaithfulSMul_2","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\n⊢ FaithfulSMul H (Monoid.PushoutI.NormalWord d)","decl":"instance : FaithfulSMul H (NormalWord d) :=\n  ⟨by simp [base_smul_def']⟩\n\n"}
{"name":"Monoid.PushoutI.of_injective","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : Group H\nφ : (i : ι) → MonoidHom H (G i)\nhφ : ∀ (i : ι), Function.Injective ⇑(φ i)\ni : ι\n⊢ Function.Injective ⇑(Monoid.PushoutI.of i)","decl":"/-- All maps into the `PushoutI`, or amalgamated product of groups are injective,\nprovided all maps in the diagram are injective.\n\nSee also `base_injective` -/\ntheorem of_injective (hφ : ∀ i, Function.Injective (φ i)) (i : ι) :\n    Function.Injective (of (φ := φ) i) := by\n  rcases transversal_nonempty φ hφ with ⟨d⟩\n  let _ := Classical.decEq ι\n  let _ := fun i => Classical.decEq (G i)\n  refine Function.Injective.of_comp\n    (f := ((· • ·) : PushoutI φ → NormalWord d → NormalWord d)) ?_\n  intros _ _ h\n  exact eq_of_smul_eq_smul (fun w : NormalWord d =>\n    by simp_all [funext_iff, of_smul_eq_smul])\n\n"}
{"name":"Monoid.PushoutI.base_injective","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : Group H\nφ : (i : ι) → MonoidHom H (G i)\nhφ : ∀ (i : ι), Function.Injective ⇑(φ i)\n⊢ Function.Injective ⇑(Monoid.PushoutI.base φ)","decl":"theorem base_injective (hφ : ∀ i, Function.Injective (φ i)) :\n    Function.Injective (base φ) := by\n  rcases transversal_nonempty φ hφ with ⟨d⟩\n  let _ := Classical.decEq ι\n  let _ := fun i => Classical.decEq (G i)\n  refine Function.Injective.of_comp\n    (f := ((· • ·) : PushoutI φ → NormalWord d → NormalWord d)) ?_\n  intros _ _ h\n  exact eq_of_smul_eq_smul (fun w : NormalWord d =>\n    by simp_all [funext_iff, base_smul_eq_smul])\n\n"}
{"name":"Monoid.PushoutI.Reduced.exists_normalWord_prod_eq","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : Group H\nφ : (i : ι) → MonoidHom H (G i)\nd : Monoid.PushoutI.NormalWord.Transversal φ\nw : Monoid.CoprodI.Word G\nhw : Monoid.PushoutI.Reduced φ w\n⊢ Exists fun w' => And (Eq w'.prod (Monoid.PushoutI.ofCoprodI w.prod)) (Eq (List.map Sigma.fst w'.toList) (List.map Sigma.fst w.toList))","decl":"theorem Reduced.exists_normalWord_prod_eq (d : Transversal φ) {w : Word G} (hw : Reduced φ w) :\n    ∃ w' : NormalWord d, w'.prod = ofCoprodI w.prod ∧\n      w'.toList.map Sigma.fst = w.toList.map Sigma.fst := by\n  classical\n  induction w using Word.consRecOn with\n  | h_empty => exact ⟨empty, by simp, rfl⟩\n  | h_cons i g w hIdx hg1 ih =>\n    rcases ih (fun _ hg => hw _ (List.mem_cons_of_mem _ hg)) with\n      ⟨w', hw'prod, hw'map⟩\n    refine ⟨cons g w' ?_ ?_, ?_⟩\n    · rwa [Word.fstIdx, ← List.head?_map, hw'map, List.head?_map]\n    · exact hw _ (List.mem_cons_self _ _)\n    · simp [hw'prod, hw'map]\n\n"}
{"name":"Monoid.PushoutI.Reduced.eq_empty_of_mem_range","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : Group H\nφ : (i : ι) → MonoidHom H (G i)\nhφ : ∀ (i : ι), Function.Injective ⇑(φ i)\nw : Monoid.CoprodI.Word G\nhw : Monoid.PushoutI.Reduced φ w\nh : Membership.mem (Monoid.PushoutI.base φ).range (Monoid.PushoutI.ofCoprodI w.prod)\n⊢ Eq w Monoid.CoprodI.Word.empty","decl":"/-- For any word `w` in the coproduct,\nif `w` is reduced (i.e none its letters are in the image of the base monoid), and nonempty, then\n`w` itself is not in the image of the base group. -/\ntheorem Reduced.eq_empty_of_mem_range\n    (hφ : ∀ i, Injective (φ i)) {w : Word G} (hw : Reduced φ w)\n    (h : ofCoprodI w.prod ∈ (base φ).range) : w = .empty := by\n  rcases transversal_nonempty φ hφ with ⟨d⟩\n  rcases hw.exists_normalWord_prod_eq d with ⟨w', hw'prod, hw'map⟩\n  rcases h with ⟨h, heq⟩\n  have : (NormalWord.prod (d := d) ⟨.empty, h, by simp⟩) = base φ h := by\n    simp [NormalWord.prod]\n  rw [← hw'prod, ← this] at heq\n  suffices w'.toWord = .empty by\n    simp [this, @eq_comm _ []] at hw'map\n    ext\n    simp [hw'map]\n  rw [← prod_injective heq]\n\n"}
{"name":"Monoid.PushoutI.inf_of_range_eq_base_range","module":"Mathlib.GroupTheory.PushoutI","initialProofState":"ι : Type u_1\nG : ι → Type u_2\nH : Type u_3\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : Group H\nφ : (i : ι) → MonoidHom H (G i)\nhφ : ∀ (i : ι), Function.Injective ⇑(φ i)\ni j : ι\nhij : Ne i j\n⊢ Eq (Min.min (Monoid.PushoutI.of i).range (Monoid.PushoutI.of j).range) (Monoid.PushoutI.base φ).range","decl":"/-- The intersection of the images of the maps from any two distinct groups in the diagram\ninto the amalgamated product is the image of the map from the base group in the diagram. -/\ntheorem inf_of_range_eq_base_range\n    (hφ : ∀ i, Injective (φ i)) {i j : ι} (hij : i ≠ j) :\n    (of i).range ⊓ (of j).range = (base φ).range :=\n  le_antisymm\n    (by\n      intro x ⟨⟨g₁, hg₁⟩, ⟨g₂, hg₂⟩⟩\n      by_contra hx\n      have hx1 : x ≠ 1 := by rintro rfl; simp_all only [ne_eq, one_mem, not_true_eq_false]\n      have hg₁1 : g₁ ≠ 1 :=\n        ne_of_apply_ne (of (φ := φ) i) (by simp_all)\n      have hg₂1 : g₂ ≠ 1 :=\n        ne_of_apply_ne (of (φ := φ) j) (by simp_all)\n      have hg₁r : g₁ ∉ (φ i).range := by\n        rintro ⟨y, rfl⟩\n        subst hg₁\n        exact hx (of_apply_eq_base φ i y ▸ MonoidHom.mem_range.2 ⟨y, rfl⟩)\n      have hg₂r : g₂ ∉ (φ j).range := by\n        rintro ⟨y, rfl⟩\n        subst hg₂\n        exact hx (of_apply_eq_base φ j y ▸ MonoidHom.mem_range.2 ⟨y, rfl⟩)\n      let w : Word G := ⟨[⟨_, g₁⟩, ⟨_, g₂⁻¹⟩], by simp_all, by simp_all⟩\n      have hw : Reduced φ w := by\n        simp only [w, not_exists, ne_eq, Reduced, List.find?, List.mem_cons,\n          List.mem_singleton, forall_eq_or_imp, not_false_eq_true, forall_const, forall_eq,\n          true_and, hg₁r, hg₂r, List.mem_nil_iff, false_imp_iff, imp_true_iff, and_true,\n          inv_mem_iff]\n      have := hw.eq_empty_of_mem_range hφ (by\n        simp only [w, Word.prod, List.map_cons, List.prod_cons, List.prod_nil,\n          List.map_nil, map_mul, ofCoprodI_of, hg₁, hg₂, map_inv, map_one, mul_one,\n          mul_inv_cancel, one_mem])\n      simp [w, Word.empty] at this)\n    (le_inf\n      (by rw [← of_comp_eq_base i]\n          rintro _ ⟨h, rfl⟩\n          exact MonoidHom.mem_range.2 ⟨φ i h, rfl⟩)\n      (by rw [← of_comp_eq_base j]\n          rintro _ ⟨h, rfl⟩\n          exact MonoidHom.mem_range.2 ⟨φ j h, rfl⟩))\n\n"}
