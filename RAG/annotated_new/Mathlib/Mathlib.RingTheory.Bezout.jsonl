{"name":"IsBezout.iff_span_pair_isPrincipal","module":"Mathlib.RingTheory.Bezout","initialProofState":"R : Type u\ninst✝ : CommRing R\n⊢ Iff (IsBezout R) (∀ (x y : R), Submodule.IsPrincipal (Ideal.span (Insert.insert x (Singleton.singleton y))))","decl":"theorem iff_span_pair_isPrincipal :\n    IsBezout R ↔ ∀ x y : R, (Ideal.span {x, y} : Ideal R).IsPrincipal := by\n  classical\n    constructor\n    · intro H x y; infer_instance\n    · intro H\n      constructor\n      apply Submodule.fg_induction\n      · exact fun _ => ⟨⟨_, rfl⟩⟩\n      · rintro _ _ ⟨⟨x, rfl⟩⟩ ⟨⟨y, rfl⟩⟩; rw [← Submodule.span_insert]; exact H _ _\n\n"}
{"name":"Function.Surjective.isBezout","module":"Mathlib.RingTheory.Bezout","initialProofState":"R : Type u\ninst✝² : CommRing R\nS : Type v\ninst✝¹ : CommRing S\nf : RingHom R S\nhf : Function.Surjective ⇑f\ninst✝ : IsBezout R\n⊢ IsBezout S","decl":"theorem _root_.Function.Surjective.isBezout {S : Type v} [CommRing S] (f : R →+* S)\n    (hf : Function.Surjective f) [IsBezout R] : IsBezout S := by\n  rw [iff_span_pair_isPrincipal]\n  intro x y\n  obtain ⟨⟨x, rfl⟩, ⟨y, rfl⟩⟩ := hf x, hf y\n  use f (gcd x y)\n  trans Ideal.map f (Ideal.span {gcd x y})\n  · rw [span_gcd, Ideal.map_span, Set.image_insert_eq, Set.image_singleton]\n  · rw [Ideal.map_span, Set.image_singleton]; rfl\n\n"}
{"name":"IsBezout.TFAE","module":"Mathlib.RingTheory.Bezout","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsBezout R\ninst✝ : IsDomain R\n⊢ (List.cons (IsNoetherianRing R) (List.cons (IsPrincipalIdealRing R) (List.cons (UniqueFactorizationMonoid R) (List.cons (WfDvdMonoid R) List.nil)))).TFAE","decl":"theorem TFAE [IsBezout R] [IsDomain R] :\n    List.TFAE\n    [IsNoetherianRing R, IsPrincipalIdealRing R, UniqueFactorizationMonoid R, WfDvdMonoid R] := by\n  classical\n    tfae_have 1 → 2\n    | _ => inferInstance\n    tfae_have 2 → 3\n    | _ => inferInstance\n    tfae_have 3 → 4\n    | _ => inferInstance\n    tfae_have 4 → 1\n    | ⟨h⟩ => by\n      rw [isNoetherianRing_iff, isNoetherian_iff_fg_wellFounded]\n      refine ⟨RelEmbedding.wellFounded ?_ h⟩\n      have : ∀ I : { J : Ideal R // J.FG }, ∃ x : R, (I : Ideal R) = Ideal.span {x} :=\n        fun ⟨I, hI⟩ => (IsBezout.isPrincipal_of_FG I hI).1\n      choose f hf using this\n      exact\n        { toFun := f\n          inj' := fun x y e => by ext1; rw [hf, hf, e]\n          map_rel_iff' := by\n            dsimp\n            intro a b\n            rw [← Ideal.span_singleton_lt_span_singleton, ← hf, ← hf]\n            rfl }\n    tfae_finish\n\n"}
