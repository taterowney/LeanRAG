{"name":"SetTheory.PGame.State.right_bound","module":"Mathlib.SetTheory.Game.State","initialProofState":"S : Type u\nself : SetTheory.PGame.State S\ns t : S\na✝ : Membership.mem (SetTheory.PGame.State.r s) t\n⊢ LT.lt (SetTheory.PGame.State.turnBound t) (SetTheory.PGame.State.turnBound s)","decl":"/-- `SetTheory.PGame.State S` describes how to interpret `s : S` as a state of a combinatorial game.\nUse `SetTheory.PGame.ofState s` or `SetTheory.Game.ofState s` to construct the game.\n\n`SetTheory.PGame.State.l : S → Finset S` and `SetTheory.PGame.State.r : S → Finset S` describe\nthe states reachable by a move by Left or Right. `SetTheory.PGame.State.turnBound : S → ℕ`\ngives an upper bound on the number of possible turns remaining from this state.\n-/\nclass State (S : Type u) where\n  turnBound : S → ℕ\n  l : S → Finset S\n  r : S → Finset S\n  left_bound : ∀ {s t : S}, t ∈ l s → turnBound t < turnBound s\n  right_bound : ∀ {s t : S}, t ∈ r s → turnBound t < turnBound s\n\n"}
{"name":"SetTheory.PGame.State.left_bound","module":"Mathlib.SetTheory.Game.State","initialProofState":"S : Type u\nself : SetTheory.PGame.State S\ns t : S\na✝ : Membership.mem (SetTheory.PGame.State.l s) t\n⊢ LT.lt (SetTheory.PGame.State.turnBound t) (SetTheory.PGame.State.turnBound s)","decl":"/-- `SetTheory.PGame.State S` describes how to interpret `s : S` as a state of a combinatorial game.\nUse `SetTheory.PGame.ofState s` or `SetTheory.Game.ofState s` to construct the game.\n\n`SetTheory.PGame.State.l : S → Finset S` and `SetTheory.PGame.State.r : S → Finset S` describe\nthe states reachable by a move by Left or Right. `SetTheory.PGame.State.turnBound : S → ℕ`\ngives an upper bound on the number of possible turns remaining from this state.\n-/\nclass State (S : Type u) where\n  turnBound : S → ℕ\n  l : S → Finset S\n  r : S → Finset S\n  left_bound : ∀ {s t : S}, t ∈ l s → turnBound t < turnBound s\n  right_bound : ∀ {s t : S}, t ∈ r s → turnBound t < turnBound s\n\n"}
{"name":"SetTheory.PGame.turnBound_ne_zero_of_left_move","module":"Mathlib.SetTheory.Game.State","initialProofState":"S : Type u\ninst✝ : SetTheory.PGame.State S\ns t : S\nm : Membership.mem (SetTheory.PGame.State.l s) t\n⊢ Ne (SetTheory.PGame.State.turnBound s) 0","decl":"theorem turnBound_ne_zero_of_left_move {s t : S} (m : t ∈ l s) : turnBound s ≠ 0 := by\n  intro h\n  have t := left_bound m\n  rw [h] at t\n  exact Nat.not_succ_le_zero _ t\n\n"}
{"name":"SetTheory.PGame.turnBound_ne_zero_of_right_move","module":"Mathlib.SetTheory.Game.State","initialProofState":"S : Type u\ninst✝ : SetTheory.PGame.State S\ns t : S\nm : Membership.mem (SetTheory.PGame.State.r s) t\n⊢ Ne (SetTheory.PGame.State.turnBound s) 0","decl":"theorem turnBound_ne_zero_of_right_move {s t : S} (m : t ∈ r s) : turnBound s ≠ 0 := by\n  intro h\n  have t := right_bound m\n  rw [h] at t\n  exact Nat.not_succ_le_zero _ t\n\n"}
{"name":"SetTheory.PGame.turnBound_of_left","module":"Mathlib.SetTheory.Game.State","initialProofState":"S : Type u\ninst✝ : SetTheory.PGame.State S\ns t : S\nm : Membership.mem (SetTheory.PGame.State.l s) t\nn : Nat\nh : LE.le (SetTheory.PGame.State.turnBound s) (HAdd.hAdd n 1)\n⊢ LE.le (SetTheory.PGame.State.turnBound t) n","decl":"theorem turnBound_of_left {s t : S} (m : t ∈ l s) (n : ℕ) (h : turnBound s ≤ n + 1) :\n    turnBound t ≤ n :=\n  Nat.le_of_lt_succ (Nat.lt_of_lt_of_le (left_bound m) h)\n\n"}
{"name":"SetTheory.PGame.turnBound_of_right","module":"Mathlib.SetTheory.Game.State","initialProofState":"S : Type u\ninst✝ : SetTheory.PGame.State S\ns t : S\nm : Membership.mem (SetTheory.PGame.State.r s) t\nn : Nat\nh : LE.le (SetTheory.PGame.State.turnBound s) (HAdd.hAdd n 1)\n⊢ LE.le (SetTheory.PGame.State.turnBound t) n","decl":"theorem turnBound_of_right {s t : S} (m : t ∈ r s) (n : ℕ) (h : turnBound s ≤ n + 1) :\n    turnBound t ≤ n :=\n  Nat.le_of_lt_succ (Nat.lt_of_lt_of_le (right_bound m) h)\n\n"}
