{"name":"CategoryTheory.MorphismProperty.ContainsIdentities.id_mem","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty C\nself : W.ContainsIdentities\nX : C\n‚ä¢ W (CategoryTheory.CategoryStruct.id X)","decl":"/-- Typeclass expressing that a morphism property contain identities. -/\nclass ContainsIdentities (W : MorphismProperty C) : Prop where\n  /-- for all `X : C`, the identity of `X` satisfies the morphism property -/\n  id_mem : ‚àÄ (X : C), W (ùüô X)\n\n"}
{"name":"CategoryTheory.MorphismProperty.id_mem","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty C\ninst‚úù : W.ContainsIdentities\nX : C\n‚ä¢ W (CategoryTheory.CategoryStruct.id X)","decl":"lemma id_mem (W : MorphismProperty C) [W.ContainsIdentities] (X : C) :\n    W (ùüô X) := ContainsIdentities.id_mem X\n\n"}
{"name":"CategoryTheory.MorphismProperty.ContainsIdentities.op","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty C\ninst‚úù : W.ContainsIdentities\n‚ä¢ W.op.ContainsIdentities","decl":"instance op (W : MorphismProperty C) [W.ContainsIdentities] :\n    W.op.ContainsIdentities := ‚ü®fun X => W.id_mem X.unop‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.ContainsIdentities.unop","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty (Opposite C)\ninst‚úù : W.ContainsIdentities\n‚ä¢ W.unop.ContainsIdentities","decl":"instance unop (W : MorphismProperty C·µí·µñ) [W.ContainsIdentities] :\n    W.unop.ContainsIdentities := ‚ü®fun X => W.id_mem (Opposite.op X)‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.ContainsIdentities.of_op","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty C\ninst‚úù : W.op.ContainsIdentities\n‚ä¢ W.ContainsIdentities","decl":"lemma of_op (W : MorphismProperty C) [W.op.ContainsIdentities] :\n    W.ContainsIdentities := (inferInstance : W.op.unop.ContainsIdentities)\n\n"}
{"name":"CategoryTheory.MorphismProperty.ContainsIdentities.of_unop","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty (Opposite C)\ninst‚úù : W.unop.ContainsIdentities\n‚ä¢ W.ContainsIdentities","decl":"lemma of_unop (W : MorphismProperty C·µí·µñ) [W.unop.ContainsIdentities] :\n    W.ContainsIdentities := (inferInstance : W.unop.op.ContainsIdentities)\n\n"}
{"name":"CategoryTheory.MorphismProperty.ContainsIdentities.inverseImage","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬π : CategoryTheory.Category.{v', u'} D\nP : CategoryTheory.MorphismProperty D\ninst‚úù : P.ContainsIdentities\nF : CategoryTheory.Functor C D\n‚ä¢ (P.inverseImage F).ContainsIdentities","decl":"instance inverseImage {P : MorphismProperty D} [P.ContainsIdentities] (F : C ‚•§ D) :\n    (P.inverseImage F).ContainsIdentities where\n  id_mem X := by simpa only [‚Üê F.map_id] using P.id_mem (F.obj X)\n\n"}
{"name":"CategoryTheory.MorphismProperty.ContainsIdentities.inf","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nP Q : CategoryTheory.MorphismProperty C\ninst‚úù¬π : P.ContainsIdentities\ninst‚úù : Q.ContainsIdentities\n‚ä¢ (Min.min P Q).ContainsIdentities","decl":"instance inf {P Q : MorphismProperty C} [P.ContainsIdentities] [Q.ContainsIdentities] :\n    (P ‚äì Q).ContainsIdentities where\n  id_mem X := ‚ü®P.id_mem X, Q.id_mem X‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.Prod.containsIdentities","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_3, u_1} C‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_2} C‚ÇÇ\nW‚ÇÅ : CategoryTheory.MorphismProperty C‚ÇÅ\nW‚ÇÇ : CategoryTheory.MorphismProperty C‚ÇÇ\ninst‚úù¬π : W‚ÇÅ.ContainsIdentities\ninst‚úù : W‚ÇÇ.ContainsIdentities\n‚ä¢ (W‚ÇÅ.prod W‚ÇÇ).ContainsIdentities","decl":"instance Prod.containsIdentities {C‚ÇÅ C‚ÇÇ : Type*} [Category C‚ÇÅ] [Category C‚ÇÇ]\n    (W‚ÇÅ : MorphismProperty C‚ÇÅ) (W‚ÇÇ : MorphismProperty C‚ÇÇ)\n    [W‚ÇÅ.ContainsIdentities] [W‚ÇÇ.ContainsIdentities] : (prod W‚ÇÅ W‚ÇÇ).ContainsIdentities :=\n  ‚ü®fun _ => ‚ü®W‚ÇÅ.id_mem _, W‚ÇÇ.id_mem _‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.Pi.containsIdentities","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"J : Type w\nC : J ‚Üí Type u\ninst‚úù¬π : (j : J) ‚Üí CategoryTheory.Category.{v, u} (C j)\nW : (j : J) ‚Üí CategoryTheory.MorphismProperty (C j)\ninst‚úù : ‚àÄ (j : J), (W j).ContainsIdentities\n‚ä¢ (CategoryTheory.MorphismProperty.pi W).ContainsIdentities","decl":"instance Pi.containsIdentities {J : Type w} {C : J ‚Üí Type u}\n  [‚àÄ j, Category.{v} (C j)] (W : ‚àÄ j, MorphismProperty (C j)) [‚àÄ j, (W j).ContainsIdentities] :\n    (pi W).ContainsIdentities :=\n  ‚ü®fun _ _ => MorphismProperty.id_mem _ _‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.of_isIso","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù¬≤ : P.ContainsIdentities\ninst‚úù¬π : P.RespectsIso\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\n‚ä¢ P f","decl":"lemma of_isIso (P : MorphismProperty C) [P.ContainsIdentities] [P.RespectsIso] {X Y : C} (f : X ‚ü∂ Y)\n    [IsIso f] : P f :=\n  Category.id_comp f ‚ñ∏ RespectsIso.postcomp P f (ùüô X) (P.id_mem X)\n\n"}
{"name":"CategoryTheory.MorphismProperty.isomorphisms_le_of_containsIdentities","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù¬π : P.ContainsIdentities\ninst‚úù : P.RespectsIso\n‚ä¢ LE.le (CategoryTheory.MorphismProperty.isomorphisms C) P","decl":"lemma isomorphisms_le_of_containsIdentities (P : MorphismProperty C) [P.ContainsIdentities]\n    [P.RespectsIso] :\n    isomorphisms C ‚â§ P := fun _ _ f (_ : IsIso f) ‚Ü¶ P.of_isIso f\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderComposition.comp_mem","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\nself : P.IsStableUnderComposition\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\na‚úù¬π : P f\na‚úù : P g\n‚ä¢ P (CategoryTheory.CategoryStruct.comp f g)","decl":"/-- A morphism property satisfies `IsStableUnderComposition` if the composition of\ntwo such morphisms still falls in the class. -/\nclass IsStableUnderComposition (P : MorphismProperty C) : Prop where\n  comp_mem {X Y Z} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : P f ‚Üí P g ‚Üí P (f ‚â´ g)\n\n"}
{"name":"CategoryTheory.MorphismProperty.comp_mem","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty C\ninst‚úù : W.IsStableUnderComposition\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nhf : W f\nhg : W g\n‚ä¢ W (CategoryTheory.CategoryStruct.comp f g)","decl":"lemma comp_mem (W : MorphismProperty C) [W.IsStableUnderComposition]\n    {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (hf : W f) (hg : W g) : W (f ‚â´ g) :=\n  IsStableUnderComposition.comp_mem f g hf hg\n\n"}
{"name":"CategoryTheory.MorphismProperty.instRespectsOfIsStableUnderComposition","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty C\ninst‚úù : W.IsStableUnderComposition\n‚ä¢ W.Respects W","decl":"instance (priority := 900) (W : MorphismProperty C) [W.IsStableUnderComposition] :\n    W.Respects W where\n  precomp _ hi _ hf := W.comp_mem _ _ hi hf\n  postcomp _ hi _ hf := W.comp_mem _ _ hf hi\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderComposition.op","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù : P.IsStableUnderComposition\n‚ä¢ P.op.IsStableUnderComposition","decl":"instance IsStableUnderComposition.op {P : MorphismProperty C} [P.IsStableUnderComposition] :\n    P.op.IsStableUnderComposition where\n  comp_mem f g hf hg := P.comp_mem g.unop f.unop hg hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderComposition.unop","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty (Opposite C)\ninst‚úù : P.IsStableUnderComposition\n‚ä¢ P.unop.IsStableUnderComposition","decl":"instance IsStableUnderComposition.unop {P : MorphismProperty C·µí·µñ} [P.IsStableUnderComposition] :\n    P.unop.IsStableUnderComposition where\n  comp_mem f g hf hg := P.comp_mem g.op f.op hg hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderComposition.inf","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nP Q : CategoryTheory.MorphismProperty C\ninst‚úù¬π : P.IsStableUnderComposition\ninst‚úù : Q.IsStableUnderComposition\n‚ä¢ (Min.min P Q).IsStableUnderComposition","decl":"instance IsStableUnderComposition.inf {P Q : MorphismProperty C} [P.IsStableUnderComposition]\n    [Q.IsStableUnderComposition] :\n    (P ‚äì Q).IsStableUnderComposition where\n  comp_mem f g hf hg := ‚ü®P.comp_mem f g hf.left hg.left, Q.comp_mem f g hf.right hg.right‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.StableUnderInverse.op","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\nh : P.StableUnderInverse\n‚ä¢ P.op.StableUnderInverse","decl":"theorem StableUnderInverse.op {P : MorphismProperty C} (h : StableUnderInverse P) :\n    StableUnderInverse P.op := fun _ _ e he => h e.unop he\n\n"}
{"name":"CategoryTheory.MorphismProperty.StableUnderInverse.unop","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty (Opposite C)\nh : P.StableUnderInverse\n‚ä¢ P.unop.StableUnderInverse","decl":"theorem StableUnderInverse.unop {P : MorphismProperty C·µí·µñ} (h : StableUnderInverse P) :\n    StableUnderInverse P.unop := fun _ _ e he => h e.op he\n\n"}
{"name":"CategoryTheory.MorphismProperty.respectsIso_of_isStableUnderComposition","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù : P.IsStableUnderComposition\nhP : LE.le (CategoryTheory.MorphismProperty.isomorphisms C) P\n‚ä¢ P.RespectsIso","decl":"theorem respectsIso_of_isStableUnderComposition {P : MorphismProperty C}\n    [P.IsStableUnderComposition] (hP : isomorphisms C ‚â§ P) :\n    RespectsIso P := RespectsIso.mk _\n  (fun _ _ hf => P.comp_mem _ _ (hP _ (isomorphisms.infer_property _)) hf)\n    (fun _ _ hf => P.comp_mem _ _ hf (hP _ (isomorphisms.infer_property _)))\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsStableUnderComposition.inverseImage","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬π : CategoryTheory.Category.{v', u'} D\nP : CategoryTheory.MorphismProperty D\ninst‚úù : P.IsStableUnderComposition\nF : CategoryTheory.Functor C D\n‚ä¢ (P.inverseImage F).IsStableUnderComposition","decl":"instance IsStableUnderComposition.inverseImage {P : MorphismProperty D} [P.IsStableUnderComposition]\n    (F : C ‚•§ D) : (P.inverseImage F).IsStableUnderComposition where\n  comp_mem f g hf hg := by simpa only [‚Üê F.map_comp] using P.comp_mem _ _ hf hg\n\n"}
{"name":"CategoryTheory.MorphismProperty.naturalityProperty.isStableUnderComposition","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor C D\napp : (X : C) ‚Üí Quiver.Hom (F‚ÇÅ.obj X) (F‚ÇÇ.obj X)\n‚ä¢ (CategoryTheory.MorphismProperty.naturalityProperty app).IsStableUnderComposition","decl":"instance isStableUnderComposition {F‚ÇÅ F‚ÇÇ : C ‚•§ D} (app : ‚àÄ X, F‚ÇÅ.obj X ‚ü∂ F‚ÇÇ.obj X) :\n    (naturalityProperty app).IsStableUnderComposition where\n  comp_mem f g hf hg := by\n    simp only [naturalityProperty] at hf hg ‚ä¢\n    simp only [Functor.map_comp, Category.assoc, hg]\n    slice_lhs 1 2 => rw [hf]\n    rw [Category.assoc]\n\n"}
{"name":"CategoryTheory.MorphismProperty.naturalityProperty.stableUnderInverse","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor C D\napp : (X : C) ‚Üí Quiver.Hom (F‚ÇÅ.obj X) (F‚ÇÇ.obj X)\n‚ä¢ (CategoryTheory.MorphismProperty.naturalityProperty app).StableUnderInverse","decl":"theorem stableUnderInverse {F‚ÇÅ F‚ÇÇ : C ‚•§ D} (app : ‚àÄ X, F‚ÇÅ.obj X ‚ü∂ F‚ÇÇ.obj X) :\n    (naturalityProperty app).StableUnderInverse := fun X Y e he => by\n  simp only [naturalityProperty] at he ‚ä¢\n  rw [‚Üê cancel_epi (F‚ÇÅ.map e.hom)]\n  slice_rhs 1 2 => rw [he]\n  simp only [Category.assoc, ‚Üê F‚ÇÅ.map_comp_assoc, ‚Üê F‚ÇÇ.map_comp, e.hom_inv_id, Functor.map_id,\n    Category.id_comp, Category.comp_id]\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsMultiplicative.toContainsIdentities","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty C\nself : W.IsMultiplicative\n‚ä¢ W.ContainsIdentities","decl":"/-- A morphism property is multiplicative if it contains identities and is stable by\ncomposition. -/\nclass IsMultiplicative (W : MorphismProperty C)\n    extends W.ContainsIdentities, W.IsStableUnderComposition : Prop\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsMultiplicative.toIsStableUnderComposition","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty C\nself : W.IsMultiplicative\n‚ä¢ W.IsStableUnderComposition","decl":"/-- A morphism property is multiplicative if it contains identities and is stable by\ncomposition. -/\nclass IsMultiplicative (W : MorphismProperty C)\n    extends W.ContainsIdentities, W.IsStableUnderComposition : Prop\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsMultiplicative.op","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty C\ninst‚úù : W.IsMultiplicative\n‚ä¢ W.op.IsMultiplicative","decl":"instance op (W : MorphismProperty C) [IsMultiplicative W] : IsMultiplicative W.op where\n  comp_mem f g hf hg := W.comp_mem g.unop f.unop hg hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsMultiplicative.unop","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty (Opposite C)\ninst‚úù : W.IsMultiplicative\n‚ä¢ W.unop.IsMultiplicative","decl":"instance unop (W : MorphismProperty C·µí·µñ) [IsMultiplicative W] : IsMultiplicative W.unop where\n  id_mem _ := W.id_mem _\n  comp_mem f g hf hg := W.comp_mem g.op f.op hg hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsMultiplicative.of_op","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty C\ninst‚úù : W.op.IsMultiplicative\n‚ä¢ W.IsMultiplicative","decl":"lemma of_op (W : MorphismProperty C) [IsMultiplicative W.op] : IsMultiplicative W :=\n  (inferInstance : IsMultiplicative W.op.unop)\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsMultiplicative.of_unop","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty (Opposite C)\ninst‚úù : W.unop.IsMultiplicative\n‚ä¢ W.IsMultiplicative","decl":"lemma of_unop (W : MorphismProperty C·µí·µñ) [IsMultiplicative W.unop] : IsMultiplicative W :=\n  (inferInstance : IsMultiplicative W.unop.op)\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsMultiplicative.instTop","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ Top.top.IsMultiplicative","decl":"instance : MorphismProperty.IsMultiplicative (‚ä§ : MorphismProperty C) where\n  comp_mem _ _ _ _ := trivial\n  id_mem _ := trivial\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsMultiplicative.instIsomorphisms","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ (CategoryTheory.MorphismProperty.isomorphisms C).IsMultiplicative","decl":"instance : (isomorphisms C).IsMultiplicative where\n  id_mem _ := isomorphisms.infer_property _\n  comp_mem f g hf hg := by\n    rw [isomorphisms.iff] at hf hg ‚ä¢\n    infer_instance\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsMultiplicative.instMonomorphisms","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ (CategoryTheory.MorphismProperty.monomorphisms C).IsMultiplicative","decl":"instance : (monomorphisms C).IsMultiplicative where\n  id_mem _ := monomorphisms.infer_property _\n  comp_mem f g hf hg := by\n    rw [monomorphisms.iff] at hf hg ‚ä¢\n    apply mono_comp\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsMultiplicative.instEpimorphisms","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ (CategoryTheory.MorphismProperty.epimorphisms C).IsMultiplicative","decl":"instance : (epimorphisms C).IsMultiplicative where\n  id_mem _ := epimorphisms.infer_property _\n  comp_mem f g hf hg := by\n    rw [epimorphisms.iff] at hf hg ‚ä¢\n    apply epi_comp\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsMultiplicative.instInverseImage","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬π : CategoryTheory.Category.{v', u'} D\nP : CategoryTheory.MorphismProperty D\ninst‚úù : P.IsMultiplicative\nF : CategoryTheory.Functor C D\n‚ä¢ (P.inverseImage F).IsMultiplicative","decl":"instance {P : MorphismProperty D} [P.IsMultiplicative] (F : C ‚•§ D) :\n    (P.inverseImage F).IsMultiplicative where\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsMultiplicative.inf","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nP Q : CategoryTheory.MorphismProperty C\ninst‚úù¬π : P.IsMultiplicative\ninst‚úù : Q.IsMultiplicative\n‚ä¢ (Min.min P Q).IsMultiplicative","decl":"instance inf {P Q : MorphismProperty C} [P.IsMultiplicative] [Q.IsMultiplicative] :\n    (P ‚äì Q).IsMultiplicative where\n\n"}
{"name":"CategoryTheory.MorphismProperty.HasOfPostcompProperty.of_postcomp","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nW W' : CategoryTheory.MorphismProperty C\nself : W.HasOfPostcompProperty W'\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\na‚úù¬π : W' g\na‚úù : W (CategoryTheory.CategoryStruct.comp f g)\n‚ä¢ W f","decl":"/-- A class of morphisms `W` has the of-postcomp property wrt. `W'` if whenever\n`g` is in `W'` and `f ‚â´ g` is in `W`, also `f` is in `W`. -/\nclass HasOfPostcompProperty (W W' : MorphismProperty C) : Prop where\n  of_postcomp {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : W' g ‚Üí W (f ‚â´ g) ‚Üí W f\n\n"}
{"name":"CategoryTheory.MorphismProperty.HasOfPrecompProperty.of_precomp","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nW W' : CategoryTheory.MorphismProperty C\nself : W.HasOfPrecompProperty W'\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\na‚úù¬π : W' f\na‚úù : W (CategoryTheory.CategoryStruct.comp f g)\n‚ä¢ W g","decl":"/-- A class of morphisms `W` has the of-precomp property wrt. `W'` if whenever\n`f` is in `W'` and `f ‚â´ g` is in `W`, also `g` is in `W`. -/\nclass HasOfPrecompProperty (W W' : MorphismProperty C) : Prop where\n  of_precomp {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : W' f ‚Üí W (f ‚â´ g) ‚Üí W g\n\n"}
{"name":"CategoryTheory.MorphismProperty.HasTwoOutOfThreeProperty.toHasOfPostcompProperty","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty C\nself : W.HasTwoOutOfThreeProperty\n‚ä¢ W.HasOfPostcompProperty W","decl":"/-- A class of morphisms `W` has the two-out-of-three property if whenever two out\nof three maps in `f`, `g`, `f ‚â´ g` are in `W`, then the third map is also in `W`. -/\nclass HasTwoOutOfThreeProperty (W : MorphismProperty C)\n    extends W.IsStableUnderComposition, W.HasOfPostcompProperty W,\n      W.HasOfPrecompProperty W : Prop where\n\n"}
{"name":"CategoryTheory.MorphismProperty.HasTwoOutOfThreeProperty.toHasOfPrecompProperty","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty C\nself : W.HasTwoOutOfThreeProperty\n‚ä¢ W.HasOfPrecompProperty W","decl":"/-- A class of morphisms `W` has the two-out-of-three property if whenever two out\nof three maps in `f`, `g`, `f ‚â´ g` are in `W`, then the third map is also in `W`. -/\nclass HasTwoOutOfThreeProperty (W : MorphismProperty C)\n    extends W.IsStableUnderComposition, W.HasOfPostcompProperty W,\n      W.HasOfPrecompProperty W : Prop where\n\n"}
{"name":"CategoryTheory.MorphismProperty.HasTwoOutOfThreeProperty.toIsStableUnderComposition","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nW : CategoryTheory.MorphismProperty C\nself : W.HasTwoOutOfThreeProperty\n‚ä¢ W.IsStableUnderComposition","decl":"/-- A class of morphisms `W` has the two-out-of-three property if whenever two out\nof three maps in `f`, `g`, `f ‚â´ g` are in `W`, then the third map is also in `W`. -/\nclass HasTwoOutOfThreeProperty (W : MorphismProperty C)\n    extends W.IsStableUnderComposition, W.HasOfPostcompProperty W,\n      W.HasOfPrecompProperty W : Prop where\n\n"}
{"name":"CategoryTheory.MorphismProperty.of_postcomp","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW W' : CategoryTheory.MorphismProperty C\ninst‚úù : W.HasOfPostcompProperty W'\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nhg : W' g\nhfg : W (CategoryTheory.CategoryStruct.comp f g)\n‚ä¢ W f","decl":"lemma of_postcomp [W.HasOfPostcompProperty W'] {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (hg : W' g)\n    (hfg : W (f ‚â´ g)) : W f :=\n  HasOfPostcompProperty.of_postcomp f g hg hfg\n\n"}
{"name":"CategoryTheory.MorphismProperty.of_precomp","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW W' : CategoryTheory.MorphismProperty C\ninst‚úù : W.HasOfPrecompProperty W'\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nhf : W' f\nhfg : W (CategoryTheory.CategoryStruct.comp f g)\n‚ä¢ W g","decl":"lemma of_precomp [W.HasOfPrecompProperty W'] {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (hf : W' f)\n    (hfg : W (f ‚â´ g)) : W g :=\n  HasOfPrecompProperty.of_precomp f g hf hfg\n\n"}
{"name":"CategoryTheory.MorphismProperty.postcomp_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nW W' : CategoryTheory.MorphismProperty C\ninst‚úù¬π : W.RespectsRight W'\ninst‚úù : W.HasOfPostcompProperty W'\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nhg : W' g\n‚ä¢ Iff (W (CategoryTheory.CategoryStruct.comp f g)) (W f)","decl":"lemma postcomp_iff [W.RespectsRight W'] [W.HasOfPostcompProperty W']\n    {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (hg : W' g) : W (f ‚â´ g) ‚Üî W f :=\n  ‚ü®W.of_postcomp f g hg, fun hf ‚Ü¶ RespectsRight.postcomp _ hg _ hf‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.precomp_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nW W' : CategoryTheory.MorphismProperty C\ninst‚úù¬π : W.RespectsLeft W'\ninst‚úù : W.HasOfPrecompProperty W'\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nhf : W' f\n‚ä¢ Iff (W (CategoryTheory.CategoryStruct.comp f g)) (W g)","decl":"lemma precomp_iff [W.RespectsLeft W'] [W.HasOfPrecompProperty W']\n    {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (hf : W' f) :\n    W (f ‚â´ g) ‚Üî W g :=\n  ‚ü®W.of_precomp f g hf, fun hg ‚Ü¶ RespectsLeft.precomp _ hf _ hg‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.instHasTwoOutOfThreePropertyIsomorphisms","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ (CategoryTheory.MorphismProperty.isomorphisms C).HasTwoOutOfThreeProperty","decl":"instance : (isomorphisms C).HasTwoOutOfThreeProperty where\n  of_postcomp f g := fun (hg : IsIso g) (hfg : IsIso (f ‚â´ g)) =>\n    by simpa using (inferInstance : IsIso ((f ‚â´ g) ‚â´ inv g))\n  of_precomp f g := fun (hf : IsIso f) (hfg : IsIso (f ‚â´ g)) =>\n    by simpa using (inferInstance : IsIso (inv f ‚â´ (f ‚â´ g)))\n\n"}
{"name":"CategoryTheory.MorphismProperty.instHasTwoOutOfThreePropertyInverseImage","module":"Mathlib.CategoryTheory.MorphismProperty.Composition","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬π : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty D\ninst‚úù : W.HasTwoOutOfThreeProperty\n‚ä¢ (W.inverseImage F).HasTwoOutOfThreeProperty","decl":"instance (F : C ‚•§ D) (W : MorphismProperty D) [W.HasTwoOutOfThreeProperty] :\n    (W.inverseImage F).HasTwoOutOfThreeProperty where\n  of_postcomp f g hg hfg := W.of_postcomp (F.map f) (F.map g) hg (by simpa using hfg)\n  of_precomp f g hf hfg := W.of_precomp (F.map f) (F.map g) hf (by simpa using hfg)\n\n"}
