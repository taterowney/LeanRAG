{"name":"AlgebraicGeometry.Scheme.OpenCover.IsOpen","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nself : AlgebraicGeometry.Scheme.Cover P X\nj : self.J\n⊢ P (self.map j)","decl":"@[deprecated (since := \"2024-11-06\")] alias OpenCover.IsOpen := Cover.map_prop\n\n"}
{"name":"AlgebraicGeometry.Scheme.instIsOpenImmersionMap","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\ni : 𝒰.J\n⊢ AlgebraicGeometry.IsOpenImmersion (𝒰.map i)","decl":"instance (i : 𝒰.J) : IsOpenImmersion (𝒰.map i) := 𝒰.map_prop i\n\n"}
{"name":"AlgebraicGeometry.Scheme.OpenCover.iSup_opensRange","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\n⊢ Eq (iSup fun i => AlgebraicGeometry.Scheme.Hom.opensRange (𝒰.map i)) Top.top","decl":"theorem OpenCover.iSup_opensRange {X : Scheme.{u}} (𝒰 : X.OpenCover) :\n    ⨆ i, (𝒰.map i).opensRange = ⊤ :=\n  Opens.ext <| by rw [Opens.coe_iSup]; exact 𝒰.iUnion_range\n\n"}
{"name":"AlgebraicGeometry.Scheme.OpenCover.finiteSubcover_map","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nH : CompactSpace ↑↑X.toPresheafedSpace\nx : Subtype fun x => Membership.mem ⋯.choose x\n⊢ Eq (𝒰.finiteSubcover.map x) (𝒰.map (𝒰.f ↑x))","decl":"/-- Every open cover of a quasi-compact scheme can be refined into a finite subcover.\n-/\n@[simps! obj map]\ndef OpenCover.finiteSubcover {X : Scheme.{u}} (𝒰 : OpenCover X) [H : CompactSpace X] :\n    OpenCover X := by\n  have :=\n    @CompactSpace.elim_nhds_subcover _ _ H (fun x : X => Set.range (𝒰.map (𝒰.f x)).base)\n      fun x => (IsOpenImmersion.isOpen_range (𝒰.map (𝒰.f x))).mem_nhds (𝒰.covers x)\n  let t := this.choose\n  have h : ∀ x : X, ∃ y : t, x ∈ Set.range (𝒰.map (𝒰.f y)).base := by\n    intro x\n    have h' : x ∈ (⊤ : Set X) := trivial\n    rw [← Classical.choose_spec this, Set.mem_iUnion] at h'\n    rcases h' with ⟨y, _, ⟨hy, rfl⟩, hy'⟩\n    exact ⟨⟨y, hy⟩, hy'⟩\n  exact\n    { J := t\n      obj := fun x => 𝒰.obj (𝒰.f x.1)\n      map := fun x => 𝒰.map (𝒰.f x.1)\n      f := fun x => (h x).choose\n      covers := fun x => (h x).choose_spec }\n\n"}
{"name":"AlgebraicGeometry.Scheme.OpenCover.finiteSubcover_obj","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nH : CompactSpace ↑↑X.toPresheafedSpace\nx : Subtype fun x => Membership.mem ⋯.choose x\n⊢ Eq (𝒰.finiteSubcover.obj x) (𝒰.obj (𝒰.f ↑x))","decl":"/-- Every open cover of a quasi-compact scheme can be refined into a finite subcover.\n-/\n@[simps! obj map]\ndef OpenCover.finiteSubcover {X : Scheme.{u}} (𝒰 : OpenCover X) [H : CompactSpace X] :\n    OpenCover X := by\n  have :=\n    @CompactSpace.elim_nhds_subcover _ _ H (fun x : X => Set.range (𝒰.map (𝒰.f x)).base)\n      fun x => (IsOpenImmersion.isOpen_range (𝒰.map (𝒰.f x))).mem_nhds (𝒰.covers x)\n  let t := this.choose\n  have h : ∀ x : X, ∃ y : t, x ∈ Set.range (𝒰.map (𝒰.f y)).base := by\n    intro x\n    have h' : x ∈ (⊤ : Set X) := trivial\n    rw [← Classical.choose_spec this, Set.mem_iUnion] at h'\n    rcases h' with ⟨y, _, ⟨hy, rfl⟩, hy'⟩\n    exact ⟨⟨y, hy⟩, hy'⟩\n  exact\n    { J := t\n      obj := fun x => 𝒰.obj (𝒰.f x.1)\n      map := fun x => 𝒰.map (𝒰.f x.1)\n      f := fun x => (h x).choose\n      covers := fun x => (h x).choose_spec }\n\n"}
{"name":"AlgebraicGeometry.Scheme.OpenCover.compactSpace","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\ninst✝ : Finite 𝒰.J\nH : ∀ (i : 𝒰.J), CompactSpace ↑↑(𝒰.obj i).toPresheafedSpace\n⊢ CompactSpace ↑↑X.toPresheafedSpace","decl":"theorem OpenCover.compactSpace {X : Scheme.{u}} (𝒰 : X.OpenCover) [Finite 𝒰.J]\n    [H : ∀ i, CompactSpace (𝒰.obj i)] : CompactSpace X := by\n  cases nonempty_fintype 𝒰.J\n  rw [← isCompact_univ_iff, ← 𝒰.iUnion_range]\n  apply isCompact_iUnion\n  intro i\n  rw [isCompact_iff_compactSpace]\n  exact\n    @Homeomorph.compactSpace _ _ _ _ (H i)\n      (TopCat.homeoOfIso\n        (asIso\n          (IsOpenImmersion.isoOfRangeEq (𝒰.map i)\n            (X.ofRestrict (Opens.isOpenEmbedding ⟨_, (𝒰.map_prop i).base_open.isOpen_range⟩))\n            Subtype.range_coe.symm).hom.base))\n"}
{"name":"AlgebraicGeometry.Scheme.AffineOpenCover.instIsOpenImmersionMap","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.AffineOpenCover\nj : 𝒰.J\n⊢ AlgebraicGeometry.IsOpenImmersion (𝒰.map j)","decl":"instance {X : Scheme.{u}} (𝒰 : X.AffineOpenCover) (j : 𝒰.J) : IsOpenImmersion (𝒰.map j) :=\n  𝒰.map_prop j\n\n"}
{"name":"AlgebraicGeometry.Scheme.AffineOpenCover.openCover_obj","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.AffineOpenCover\nj : 𝒰.J\n⊢ Eq (𝒰.openCover.obj j) (AlgebraicGeometry.Spec (𝒰.obj j))","decl":"/-- The open cover associated to an affine open cover. -/\n@[simps! J obj map f covers]\ndef openCover {X : Scheme.{u}} (𝒰 : X.AffineOpenCover) : X.OpenCover :=\n  AffineCover.cover 𝒰\n\n"}
{"name":"AlgebraicGeometry.Scheme.AffineOpenCover.openCover_J","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.AffineOpenCover\n⊢ Eq 𝒰.openCover.J 𝒰.J","decl":"/-- The open cover associated to an affine open cover. -/\n@[simps! J obj map f covers]\ndef openCover {X : Scheme.{u}} (𝒰 : X.AffineOpenCover) : X.OpenCover :=\n  AffineCover.cover 𝒰\n\n"}
{"name":"AlgebraicGeometry.Scheme.AffineOpenCover.openCover_map","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.AffineOpenCover\nj : 𝒰.J\n⊢ Eq (𝒰.openCover.map j) (𝒰.map j)","decl":"/-- The open cover associated to an affine open cover. -/\n@[simps! J obj map f covers]\ndef openCover {X : Scheme.{u}} (𝒰 : X.AffineOpenCover) : X.OpenCover :=\n  AffineCover.cover 𝒰\n\n"}
{"name":"AlgebraicGeometry.Scheme.AffineOpenCover.openCover_f","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.AffineOpenCover\nx : ↑↑X.toPresheafedSpace\n⊢ Eq (𝒰.openCover.f x) (𝒰.f x)","decl":"/-- The open cover associated to an affine open cover. -/\n@[simps! J obj map f covers]\ndef openCover {X : Scheme.{u}} (𝒰 : X.AffineOpenCover) : X.OpenCover :=\n  AffineCover.cover 𝒰\n\n"}
{"name":"AlgebraicGeometry.Scheme.AffineOpenCover.openCover_covers","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.AffineOpenCover\nx : ↑↑X.toPresheafedSpace\n⊢ Eq ⋯ ⋯","decl":"/-- The open cover associated to an affine open cover. -/\n@[simps! J obj map f covers]\ndef openCover {X : Scheme.{u}} (𝒰 : X.AffineOpenCover) : X.OpenCover :=\n  AffineCover.cover 𝒰\n\n"}
{"name":"AlgebraicGeometry.Scheme.affineOpenCover_J","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\n⊢ Eq X.affineOpenCover.J X.affineCover.J","decl":"/-- A choice of an affine open cover of a scheme. -/\n@[simps]\ndef affineOpenCover (X : Scheme.{u}) : X.AffineOpenCover where\n  J := X.affineCover.J\n  map := X.affineCover.map\n  f := X.affineCover.f\n  covers := X.affineCover.covers\n\n"}
{"name":"AlgebraicGeometry.Scheme.affineOpenCover_obj","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\nj : X.affineCover.J\n⊢ Eq (X.affineOpenCover.obj j) ⋯.choose","decl":"/-- A choice of an affine open cover of a scheme. -/\n@[simps]\ndef affineOpenCover (X : Scheme.{u}) : X.AffineOpenCover where\n  J := X.affineCover.J\n  map := X.affineCover.map\n  f := X.affineCover.f\n  covers := X.affineCover.covers\n\n"}
{"name":"AlgebraicGeometry.Scheme.affineOpenCover_map","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\nj : X.affineCover.J\n⊢ Eq (X.affineOpenCover.map j) (X.affineCover.map j)","decl":"/-- A choice of an affine open cover of a scheme. -/\n@[simps]\ndef affineOpenCover (X : Scheme.{u}) : X.AffineOpenCover where\n  J := X.affineCover.J\n  map := X.affineCover.map\n  f := X.affineCover.f\n  covers := X.affineCover.covers\n\n"}
{"name":"AlgebraicGeometry.Scheme.affineOpenCover_f","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\nx : ↑↑X.toPresheafedSpace\n⊢ Eq (X.affineOpenCover.f x) (X.affineCover.f x)","decl":"/-- A choice of an affine open cover of a scheme. -/\n@[simps]\ndef affineOpenCover (X : Scheme.{u}) : X.AffineOpenCover where\n  J := X.affineCover.J\n  map := X.affineCover.map\n  f := X.affineCover.f\n  covers := X.affineCover.covers\n\n"}
{"name":"AlgebraicGeometry.Scheme.openCover_affineOpenCover","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\n⊢ Eq X.affineOpenCover.openCover X.affineCover","decl":"@[simp]\nlemma openCover_affineOpenCover (X : Scheme.{u}) : X.affineOpenCover.openCover = X.affineCover :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.OpenCover.pullbackCoverAffineRefinementObjIso_inv_map","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n𝒰 : Y.OpenCover\ni : (AlgebraicGeometry.Scheme.Cover.pullbackCover 𝒰.affineRefinement.openCover f).J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.OpenCover.pullbackCoverAffineRefinementObjIso f 𝒰 i).inv ((AlgebraicGeometry.Scheme.Cover.pullbackCover 𝒰.affineRefinement.openCover f).map i)) (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Scheme.Cover.pullbackCover (𝒰.obj i.fst).affineCover (AlgebraicGeometry.Scheme.Cover.pullbackHom 𝒰 f i.fst)).map i.snd) ((AlgebraicGeometry.Scheme.Cover.pullbackCover 𝒰 f).map i.fst))","decl":"@[reassoc]\nlemma OpenCover.pullbackCoverAffineRefinementObjIso_inv_map (f : X ⟶ Y) (𝒰 : Y.OpenCover) (i) :\n    (𝒰.pullbackCoverAffineRefinementObjIso f i).inv ≫\n      (𝒰.affineRefinement.openCover.pullbackCover f).map i =\n      ((𝒰.obj i.1).affineCover.pullbackCover (𝒰.pullbackHom f i.1)).map i.2 ≫\n        (𝒰.pullbackCover f).map i.1 := by\n  simp only [Cover.pullbackCover_obj, AffineCover.cover_obj, AffineCover.cover_map,\n    pullbackCoverAffineRefinementObjIso, Iso.trans_inv, asIso_inv, Iso.symm_inv, Category.assoc,\n    Cover.pullbackCover_map, pullbackSymmetry_inv_comp_fst, IsIso.inv_comp_eq, limit.lift_π_assoc,\n    id_eq, PullbackCone.mk_pt, cospan_left, PullbackCone.mk_π_app, pullbackSymmetry_hom_comp_fst]\n  convert pullbackSymmetry_inv_comp_snd_assoc\n    ((𝒰.obj i.1).affineCover.map i.2) (pullback.fst _ _) _ using 2\n  exact pullbackRightPullbackFstIso_hom_snd _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.OpenCover.pullbackCoverAffineRefinementObjIso_inv_map_assoc","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n𝒰 : Y.OpenCover\ni : (AlgebraicGeometry.Scheme.Cover.pullbackCover 𝒰.affineRefinement.openCover f).J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.OpenCover.pullbackCoverAffineRefinementObjIso f 𝒰 i).inv (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Scheme.Cover.pullbackCover 𝒰.affineRefinement.openCover f).map i) h)) (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Scheme.Cover.pullbackCover (𝒰.obj i.fst).affineCover (AlgebraicGeometry.Scheme.Cover.pullbackHom 𝒰 f i.fst)).map i.snd) (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Scheme.Cover.pullbackCover 𝒰 f).map i.fst) h))","decl":"@[reassoc]\nlemma OpenCover.pullbackCoverAffineRefinementObjIso_inv_map (f : X ⟶ Y) (𝒰 : Y.OpenCover) (i) :\n    (𝒰.pullbackCoverAffineRefinementObjIso f i).inv ≫\n      (𝒰.affineRefinement.openCover.pullbackCover f).map i =\n      ((𝒰.obj i.1).affineCover.pullbackCover (𝒰.pullbackHom f i.1)).map i.2 ≫\n        (𝒰.pullbackCover f).map i.1 := by\n  simp only [Cover.pullbackCover_obj, AffineCover.cover_obj, AffineCover.cover_map,\n    pullbackCoverAffineRefinementObjIso, Iso.trans_inv, asIso_inv, Iso.symm_inv, Category.assoc,\n    Cover.pullbackCover_map, pullbackSymmetry_inv_comp_fst, IsIso.inv_comp_eq, limit.lift_π_assoc,\n    id_eq, PullbackCone.mk_pt, cospan_left, PullbackCone.mk_π_app, pullbackSymmetry_hom_comp_fst]\n  convert pullbackSymmetry_inv_comp_snd_assoc\n    ((𝒰.obj i.1).affineCover.map i.2) (pullback.fst _ _) _ using 2\n  exact pullbackRightPullbackFstIso_hom_snd _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.OpenCover.pullbackCoverAffineRefinementObjIso_inv_pullbackHom","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n𝒰 : Y.OpenCover\ni : (AlgebraicGeometry.Scheme.Cover.pullbackCover 𝒰.affineRefinement.openCover f).J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.OpenCover.pullbackCoverAffineRefinementObjIso f 𝒰 i).inv (AlgebraicGeometry.Scheme.Cover.pullbackHom 𝒰.affineRefinement.openCover f i)) (AlgebraicGeometry.Scheme.Cover.pullbackHom (𝒰.obj i.fst).affineCover (AlgebraicGeometry.Scheme.Cover.pullbackHom 𝒰 f i.fst) i.snd)","decl":"@[reassoc]\nlemma OpenCover.pullbackCoverAffineRefinementObjIso_inv_pullbackHom\n    (f : X ⟶ Y) (𝒰 : Y.OpenCover) (i) :\n    (𝒰.pullbackCoverAffineRefinementObjIso f i).inv ≫\n      𝒰.affineRefinement.openCover.pullbackHom f i =\n      (𝒰.obj i.1).affineCover.pullbackHom (𝒰.pullbackHom f i.1) i.2 := by\n  simp only [Cover.pullbackCover_obj, Cover.pullbackHom, AffineCover.cover_obj,\n    AffineOpenCover.openCover_map, pullbackCoverAffineRefinementObjIso, Iso.trans_inv, asIso_inv,\n    Iso.symm_inv, Category.assoc, pullbackSymmetry_inv_comp_snd, IsIso.inv_comp_eq, limit.lift_π,\n    id_eq, PullbackCone.mk_pt, PullbackCone.mk_π_app, Category.comp_id]\n  convert pullbackSymmetry_inv_comp_fst ((𝒰.obj i.1).affineCover.map i.2) (pullback.fst _ _)\n  exact pullbackRightPullbackFstIso_hom_fst _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.OpenCover.pullbackCoverAffineRefinementObjIso_inv_pullbackHom_assoc","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n𝒰 : Y.OpenCover\ni : (AlgebraicGeometry.Scheme.Cover.pullbackCover 𝒰.affineRefinement.openCover f).J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (𝒰.affineRefinement.openCover.obj i) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.OpenCover.pullbackCoverAffineRefinementObjIso f 𝒰 i).inv (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.pullbackHom 𝒰.affineRefinement.openCover f i) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.pullbackHom (𝒰.obj i.fst).affineCover (AlgebraicGeometry.Scheme.Cover.pullbackHom 𝒰 f i.fst) i.snd) h)","decl":"@[reassoc]\nlemma OpenCover.pullbackCoverAffineRefinementObjIso_inv_pullbackHom\n    (f : X ⟶ Y) (𝒰 : Y.OpenCover) (i) :\n    (𝒰.pullbackCoverAffineRefinementObjIso f i).inv ≫\n      𝒰.affineRefinement.openCover.pullbackHom f i =\n      (𝒰.obj i.1).affineCover.pullbackHom (𝒰.pullbackHom f i.1) i.2 := by\n  simp only [Cover.pullbackCover_obj, Cover.pullbackHom, AffineCover.cover_obj,\n    AffineOpenCover.openCover_map, pullbackCoverAffineRefinementObjIso, Iso.trans_inv, asIso_inv,\n    Iso.symm_inv, Category.assoc, pullbackSymmetry_inv_comp_snd, IsIso.inv_comp_eq, limit.lift_π,\n    id_eq, PullbackCone.mk_pt, PullbackCone.mk_π_app, Category.comp_id]\n  convert pullbackSymmetry_inv_comp_fst ((𝒰.obj i.1).affineCover.map i.2) (pullback.fst _ _)\n  exact pullbackRightPullbackFstIso_hom_fst _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.affineOpenCoverOfSpanRangeEqTop_map","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"R : CommRingCat\nι : Type u_1\ns : ι → ↑R\nhs : Eq (Ideal.span (Set.range s)) Top.top\ni : ι\n⊢ Eq ((AlgebraicGeometry.Scheme.affineOpenCoverOfSpanRangeEqTop s hs).map i) (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap (↑R) (Localization.Away (s i)))))","decl":"/-- A family of elements spanning the unit ideal of `R` gives a affine open cover of `Spec R`. -/\n@[simps]\nnoncomputable\ndef affineOpenCoverOfSpanRangeEqTop {R : CommRingCat} {ι : Type*} (s : ι → R)\n    (hs : Ideal.span (Set.range s) = ⊤) : (Spec R).AffineOpenCover where\n  J := ι\n  obj i := .of (Localization.Away (s i))\n  map i := Spec.map (CommRingCat.ofHom (algebraMap R (Localization.Away (s i))))\n  f x := by\n    have : ∃ i, s i ∉ x.asIdeal := by\n      by_contra! h; apply x.2.ne_top; rwa [← top_le_iff, ← hs, Ideal.span_le, Set.range_subset_iff]\n    exact this.choose\n  covers x := by\n    generalize_proofs H\n    let i := (H x).choose\n    have := PrimeSpectrum.localization_away_comap_range (Localization.Away (s i)) (s i)\n    exact (eq_iff_iff.mp congr(x ∈ $this)).mpr (H x).choose_spec\n\n"}
{"name":"AlgebraicGeometry.Scheme.affineOpenCoverOfSpanRangeEqTop_obj_carrier","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"R : CommRingCat\nι : Type u_1\ns : ι → ↑R\nhs : Eq (Ideal.span (Set.range s)) Top.top\ni : ι\n⊢ Eq (↑((AlgebraicGeometry.Scheme.affineOpenCoverOfSpanRangeEqTop s hs).obj i)) (Localization.Away (s i))","decl":"/-- A family of elements spanning the unit ideal of `R` gives a affine open cover of `Spec R`. -/\n@[simps]\nnoncomputable\ndef affineOpenCoverOfSpanRangeEqTop {R : CommRingCat} {ι : Type*} (s : ι → R)\n    (hs : Ideal.span (Set.range s) = ⊤) : (Spec R).AffineOpenCover where\n  J := ι\n  obj i := .of (Localization.Away (s i))\n  map i := Spec.map (CommRingCat.ofHom (algebraMap R (Localization.Away (s i))))\n  f x := by\n    have : ∃ i, s i ∉ x.asIdeal := by\n      by_contra! h; apply x.2.ne_top; rwa [← top_le_iff, ← hs, Ideal.span_le, Set.range_subset_iff]\n    exact this.choose\n  covers x := by\n    generalize_proofs H\n    let i := (H x).choose\n    have := PrimeSpectrum.localization_away_comap_range (Localization.Away (s i)) (s i)\n    exact (eq_iff_iff.mp congr(x ∈ $this)).mpr (H x).choose_spec\n\n"}
{"name":"AlgebraicGeometry.Scheme.affineOpenCoverOfSpanRangeEqTop_f","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"R : CommRingCat\nι : Type u_1\ns : ι → ↑R\nhs : Eq (Ideal.span (Set.range s)) Top.top\nx : ↑↑(AlgebraicGeometry.Spec R).toPresheafedSpace\n⊢ Eq ((AlgebraicGeometry.Scheme.affineOpenCoverOfSpanRangeEqTop s hs).f x) (letFun ⋯ fun this => this.choose)","decl":"/-- A family of elements spanning the unit ideal of `R` gives a affine open cover of `Spec R`. -/\n@[simps]\nnoncomputable\ndef affineOpenCoverOfSpanRangeEqTop {R : CommRingCat} {ι : Type*} (s : ι → R)\n    (hs : Ideal.span (Set.range s) = ⊤) : (Spec R).AffineOpenCover where\n  J := ι\n  obj i := .of (Localization.Away (s i))\n  map i := Spec.map (CommRingCat.ofHom (algebraMap R (Localization.Away (s i))))\n  f x := by\n    have : ∃ i, s i ∉ x.asIdeal := by\n      by_contra! h; apply x.2.ne_top; rwa [← top_le_iff, ← hs, Ideal.span_le, Set.range_subset_iff]\n    exact this.choose\n  covers x := by\n    generalize_proofs H\n    let i := (H x).choose\n    have := PrimeSpectrum.localization_away_comap_range (Localization.Away (s i)) (s i)\n    exact (eq_iff_iff.mp congr(x ∈ $this)).mpr (H x).choose_spec\n\n"}
{"name":"AlgebraicGeometry.Scheme.affineOpenCoverOfSpanRangeEqTop_J","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"R : CommRingCat\nι : Type u_1\ns : ι → ↑R\nhs : Eq (Ideal.span (Set.range s)) Top.top\n⊢ Eq (AlgebraicGeometry.Scheme.affineOpenCoverOfSpanRangeEqTop s hs).J ι","decl":"/-- A family of elements spanning the unit ideal of `R` gives a affine open cover of `Spec R`. -/\n@[simps]\nnoncomputable\ndef affineOpenCoverOfSpanRangeEqTop {R : CommRingCat} {ι : Type*} (s : ι → R)\n    (hs : Ideal.span (Set.range s) = ⊤) : (Spec R).AffineOpenCover where\n  J := ι\n  obj i := .of (Localization.Away (s i))\n  map i := Spec.map (CommRingCat.ofHom (algebraMap R (Localization.Away (s i))))\n  f x := by\n    have : ∃ i, s i ∉ x.asIdeal := by\n      by_contra! h; apply x.2.ne_top; rwa [← top_le_iff, ← hs, Ideal.span_le, Set.range_subset_iff]\n    exact this.choose\n  covers x := by\n    generalize_proofs H\n    let i := (H x).choose\n    have := PrimeSpectrum.localization_away_comap_range (Localization.Away (s i)) (s i)\n    exact (eq_iff_iff.mp congr(x ∈ $this)).mpr (H x).choose_spec\n\n"}
{"name":"AlgebraicGeometry.Scheme.OpenCover.ext_elem","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nf g : ↑(X.presheaf.obj { unop := U })\n𝒰 : X.OpenCover\nh : ∀ (i : 𝒰.J), Eq ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.app (𝒰.map i) U)) f) ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.app (𝒰.map i) U)) g)\n⊢ Eq f g","decl":"/-- If two global sections agree after restriction to each member of an open cover, then\nthey agree globally. -/\nlemma OpenCover.ext_elem {X : Scheme.{u}} {U : X.Opens} (f g : Γ(X, U)) (𝒰 : X.OpenCover)\n    (h : ∀ i : 𝒰.J, (𝒰.map i).app U f = (𝒰.map i).app U g) : f = g := by\n  fapply TopCat.Sheaf.eq_of_locally_eq' X.sheaf\n    (fun i ↦ (𝒰.map (𝒰.f i)).opensRange ⊓ U) _ (fun _ ↦ homOfLE inf_le_right)\n  · intro x hx\n    simp only [Opens.iSup_mk, Opens.carrier_eq_coe, Opens.coe_inf, Hom.coe_opensRange, Opens.coe_mk,\n      Set.mem_iUnion, Set.mem_inter_iff, Set.mem_range, SetLike.mem_coe, exists_and_right]\n    refine ⟨?_, hx⟩\n    simpa using ⟨_, 𝒰.covers x⟩\n  · intro x\n    replace h := h (𝒰.f x)\n    rw [← IsOpenImmersion.map_ΓIso_inv] at h\n    exact (IsOpenImmersion.ΓIso (𝒰.map (𝒰.f x)) U).commRingCatIsoToRingEquiv.symm.injective h\n\n"}
{"name":"AlgebraicGeometry.Scheme.zero_of_zero_cover","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\ns : ↑(X.presheaf.obj { unop := U })\n𝒰 : X.OpenCover\nh : ∀ (i : 𝒰.J), Eq ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.app (𝒰.map i) U)) s) 0\n⊢ Eq s 0","decl":"/-- If the restriction of a global section to each member of an open cover is zero, then it is\nglobally zero. -/\nlemma zero_of_zero_cover {X : Scheme.{u}} {U : X.Opens} (s : Γ(X, U)) (𝒰 : X.OpenCover)\n    (h : ∀ i : 𝒰.J, (𝒰.map i).app U s = 0) : s = 0 :=\n  𝒰.ext_elem s 0 (fun i ↦ by rw [map_zero]; exact h i)\n\n"}
{"name":"AlgebraicGeometry.Scheme.isNilpotent_of_isNilpotent_cover","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\ns : ↑(X.presheaf.obj { unop := U })\n𝒰 : X.OpenCover\ninst✝ : Finite 𝒰.J\nh : ∀ (i : 𝒰.J), IsNilpotent ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.app (𝒰.map i) U)) s)\n⊢ IsNilpotent s","decl":"/-- If a global section is nilpotent on each member of a finite open cover, then `f` is\nnilpotent. -/\nlemma isNilpotent_of_isNilpotent_cover {X : Scheme.{u}} {U : X.Opens} (s : Γ(X, U))\n    (𝒰 : X.OpenCover) [Finite 𝒰.J] (h : ∀ i : 𝒰.J, IsNilpotent ((𝒰.map i).app U s)) :\n    IsNilpotent s := by\n  choose fn hfn using h\n  have : Fintype 𝒰.J := Fintype.ofFinite 𝒰.J\n  /- the maximum of all `fn i` (exists, because `𝒰.J` is finite) -/\n  let N : ℕ := Finset.sup Finset.univ fn\n  have hfnleN (i : 𝒰.J) : fn i ≤ N := Finset.le_sup (Finset.mem_univ i)\n  use N\n  apply zero_of_zero_cover (𝒰 := 𝒰)\n  on_goal 1 => intro i; simp only [map_pow]\n  -- This closes both remaining goals at once.\n  exact pow_eq_zero_of_le (hfnleN i) (hfn i)\n\n"}
{"name":"AlgebraicGeometry.Scheme.affineBasisCover_obj","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\ni : X.affineBasisCover.J\n⊢ Eq (X.affineBasisCover.obj i) (AlgebraicGeometry.Spec (X.affineBasisCoverRing i))","decl":"theorem affineBasisCover_obj (X : Scheme.{u}) (i : X.affineBasisCover.J) :\n    X.affineBasisCover.obj i = Spec (X.affineBasisCoverRing i) :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.affineBasisCover_map_range","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\nx : ↑↑X.toPresheafedSpace\nr : ↑⋯.choose\n⊢ Eq (Set.range ⇑(X.affineBasisCover.map ⟨x, r⟩).base) (Set.image (⇑(X.affineCover.map x).base) (PrimeSpectrum.basicOpen r).carrier)","decl":"theorem affineBasisCover_map_range (X : Scheme.{u}) (x : X)\n    (r : (X.local_affine x).choose_spec.choose) :\n    Set.range (X.affineBasisCover.map ⟨x, r⟩).base =\n      (X.affineCover.map x).base '' (PrimeSpectrum.basicOpen r).1 := by\n  erw [coe_comp, Set.range_comp]\n  -- Porting note: `congr` fails to see the goal is comparing image of the same function\n  refine congr_arg (_ '' ·) ?_\n  exact (PrimeSpectrum.localization_away_comap_range (Localization.Away r) r :)\n\n"}
{"name":"AlgebraicGeometry.Scheme.affineBasisCover_is_basis","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\n⊢ TopologicalSpace.IsTopologicalBasis (setOf fun x => Exists fun a => Eq x (Set.range ⇑(X.affineBasisCover.map a).base))","decl":"theorem affineBasisCover_is_basis (X : Scheme.{u}) :\n    TopologicalSpace.IsTopologicalBasis\n      {x : Set X |\n        ∃ a : X.affineBasisCover.J, x = Set.range (X.affineBasisCover.map a).base} := by\n  apply TopologicalSpace.isTopologicalBasis_of_isOpen_of_nhds\n  · rintro _ ⟨a, rfl⟩\n    exact IsOpenImmersion.isOpen_range (X.affineBasisCover.map a)\n  · rintro a U haU hU\n    rcases X.affineCover.covers a with ⟨x, e⟩\n    let U' := (X.affineCover.map (X.affineCover.f a)).base ⁻¹' U\n    have hxU' : x ∈ U' := by rw [← e] at haU; exact haU\n    rcases PrimeSpectrum.isBasis_basic_opens.exists_subset_of_mem_open hxU'\n        ((X.affineCover.map (X.affineCover.f a)).base.continuous_toFun.isOpen_preimage _\n          hU) with\n      ⟨_, ⟨_, ⟨s, rfl⟩, rfl⟩, hxV, hVU⟩\n    refine ⟨_, ⟨⟨_, s⟩, rfl⟩, ?_, ?_⟩ <;> rw [affineBasisCover_map_range]\n    · exact ⟨x, hxV, e⟩\n    · rw [Set.image_subset_iff]; exact hVU\n\n"}
