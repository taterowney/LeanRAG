{"name":"AlgebraicGeometry.Scheme.OpenCover.IsOpen","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nself : AlgebraicGeometry.Scheme.Cover P X\nj : self.J\nâŠ¢ P (self.map j)","decl":"@[deprecated (since := \"2024-11-06\")] alias OpenCover.IsOpen := Cover.map_prop\n\n"}
{"name":"AlgebraicGeometry.Scheme.instIsOpenImmersionMap","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\ni : ğ’°.J\nâŠ¢ AlgebraicGeometry.IsOpenImmersion (ğ’°.map i)","decl":"instance (i : ğ’°.J) : IsOpenImmersion (ğ’°.map i) := ğ’°.map_prop i\n\n"}
{"name":"AlgebraicGeometry.Scheme.OpenCover.iSup_opensRange","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nâŠ¢ Eq (iSup fun i => AlgebraicGeometry.Scheme.Hom.opensRange (ğ’°.map i)) Top.top","decl":"theorem OpenCover.iSup_opensRange {X : Scheme.{u}} (ğ’° : X.OpenCover) :\n    â¨† i, (ğ’°.map i).opensRange = âŠ¤ :=\n  Opens.ext <| by rw [Opens.coe_iSup]; exact ğ’°.iUnion_range\n\n"}
{"name":"AlgebraicGeometry.Scheme.OpenCover.finiteSubcover_map","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nH : CompactSpace â†‘â†‘X.toPresheafedSpace\nx : Subtype fun x => Membership.mem â‹¯.choose x\nâŠ¢ Eq (ğ’°.finiteSubcover.map x) (ğ’°.map (ğ’°.f â†‘x))","decl":"/-- Every open cover of a quasi-compact scheme can be refined into a finite subcover.\n-/\n@[simps! obj map]\ndef OpenCover.finiteSubcover {X : Scheme.{u}} (ğ’° : OpenCover X) [H : CompactSpace X] :\n    OpenCover X := by\n  have :=\n    @CompactSpace.elim_nhds_subcover _ _ H (fun x : X => Set.range (ğ’°.map (ğ’°.f x)).base)\n      fun x => (IsOpenImmersion.isOpen_range (ğ’°.map (ğ’°.f x))).mem_nhds (ğ’°.covers x)\n  let t := this.choose\n  have h : âˆ€ x : X, âˆƒ y : t, x âˆˆ Set.range (ğ’°.map (ğ’°.f y)).base := by\n    intro x\n    have h' : x âˆˆ (âŠ¤ : Set X) := trivial\n    rw [â† Classical.choose_spec this, Set.mem_iUnion] at h'\n    rcases h' with âŸ¨y, _, âŸ¨hy, rflâŸ©, hy'âŸ©\n    exact âŸ¨âŸ¨y, hyâŸ©, hy'âŸ©\n  exact\n    { J := t\n      obj := fun x => ğ’°.obj (ğ’°.f x.1)\n      map := fun x => ğ’°.map (ğ’°.f x.1)\n      f := fun x => (h x).choose\n      covers := fun x => (h x).choose_spec }\n\n"}
{"name":"AlgebraicGeometry.Scheme.OpenCover.finiteSubcover_obj","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nH : CompactSpace â†‘â†‘X.toPresheafedSpace\nx : Subtype fun x => Membership.mem â‹¯.choose x\nâŠ¢ Eq (ğ’°.finiteSubcover.obj x) (ğ’°.obj (ğ’°.f â†‘x))","decl":"/-- Every open cover of a quasi-compact scheme can be refined into a finite subcover.\n-/\n@[simps! obj map]\ndef OpenCover.finiteSubcover {X : Scheme.{u}} (ğ’° : OpenCover X) [H : CompactSpace X] :\n    OpenCover X := by\n  have :=\n    @CompactSpace.elim_nhds_subcover _ _ H (fun x : X => Set.range (ğ’°.map (ğ’°.f x)).base)\n      fun x => (IsOpenImmersion.isOpen_range (ğ’°.map (ğ’°.f x))).mem_nhds (ğ’°.covers x)\n  let t := this.choose\n  have h : âˆ€ x : X, âˆƒ y : t, x âˆˆ Set.range (ğ’°.map (ğ’°.f y)).base := by\n    intro x\n    have h' : x âˆˆ (âŠ¤ : Set X) := trivial\n    rw [â† Classical.choose_spec this, Set.mem_iUnion] at h'\n    rcases h' with âŸ¨y, _, âŸ¨hy, rflâŸ©, hy'âŸ©\n    exact âŸ¨âŸ¨y, hyâŸ©, hy'âŸ©\n  exact\n    { J := t\n      obj := fun x => ğ’°.obj (ğ’°.f x.1)\n      map := fun x => ğ’°.map (ğ’°.f x.1)\n      f := fun x => (h x).choose\n      covers := fun x => (h x).choose_spec }\n\n"}
{"name":"AlgebraicGeometry.Scheme.OpenCover.compactSpace","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\ninstâœ : Finite ğ’°.J\nH : âˆ€ (i : ğ’°.J), CompactSpace â†‘â†‘(ğ’°.obj i).toPresheafedSpace\nâŠ¢ CompactSpace â†‘â†‘X.toPresheafedSpace","decl":"theorem OpenCover.compactSpace {X : Scheme.{u}} (ğ’° : X.OpenCover) [Finite ğ’°.J]\n    [H : âˆ€ i, CompactSpace (ğ’°.obj i)] : CompactSpace X := by\n  cases nonempty_fintype ğ’°.J\n  rw [â† isCompact_univ_iff, â† ğ’°.iUnion_range]\n  apply isCompact_iUnion\n  intro i\n  rw [isCompact_iff_compactSpace]\n  exact\n    @Homeomorph.compactSpace _ _ _ _ (H i)\n      (TopCat.homeoOfIso\n        (asIso\n          (IsOpenImmersion.isoOfRangeEq (ğ’°.map i)\n            (X.ofRestrict (Opens.isOpenEmbedding âŸ¨_, (ğ’°.map_prop i).base_open.isOpen_rangeâŸ©))\n            Subtype.range_coe.symm).hom.base))\n"}
{"name":"AlgebraicGeometry.Scheme.AffineOpenCover.instIsOpenImmersionMap","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.AffineOpenCover\nj : ğ’°.J\nâŠ¢ AlgebraicGeometry.IsOpenImmersion (ğ’°.map j)","decl":"instance {X : Scheme.{u}} (ğ’° : X.AffineOpenCover) (j : ğ’°.J) : IsOpenImmersion (ğ’°.map j) :=\n  ğ’°.map_prop j\n\n"}
{"name":"AlgebraicGeometry.Scheme.AffineOpenCover.openCover_obj","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.AffineOpenCover\nj : ğ’°.J\nâŠ¢ Eq (ğ’°.openCover.obj j) (AlgebraicGeometry.Spec (ğ’°.obj j))","decl":"/-- The open cover associated to an affine open cover. -/\n@[simps! J obj map f covers]\ndef openCover {X : Scheme.{u}} (ğ’° : X.AffineOpenCover) : X.OpenCover :=\n  AffineCover.cover ğ’°\n\n"}
{"name":"AlgebraicGeometry.Scheme.AffineOpenCover.openCover_J","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.AffineOpenCover\nâŠ¢ Eq ğ’°.openCover.J ğ’°.J","decl":"/-- The open cover associated to an affine open cover. -/\n@[simps! J obj map f covers]\ndef openCover {X : Scheme.{u}} (ğ’° : X.AffineOpenCover) : X.OpenCover :=\n  AffineCover.cover ğ’°\n\n"}
{"name":"AlgebraicGeometry.Scheme.AffineOpenCover.openCover_map","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.AffineOpenCover\nj : ğ’°.J\nâŠ¢ Eq (ğ’°.openCover.map j) (ğ’°.map j)","decl":"/-- The open cover associated to an affine open cover. -/\n@[simps! J obj map f covers]\ndef openCover {X : Scheme.{u}} (ğ’° : X.AffineOpenCover) : X.OpenCover :=\n  AffineCover.cover ğ’°\n\n"}
{"name":"AlgebraicGeometry.Scheme.AffineOpenCover.openCover_f","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.AffineOpenCover\nx : â†‘â†‘X.toPresheafedSpace\nâŠ¢ Eq (ğ’°.openCover.f x) (ğ’°.f x)","decl":"/-- The open cover associated to an affine open cover. -/\n@[simps! J obj map f covers]\ndef openCover {X : Scheme.{u}} (ğ’° : X.AffineOpenCover) : X.OpenCover :=\n  AffineCover.cover ğ’°\n\n"}
{"name":"AlgebraicGeometry.Scheme.AffineOpenCover.openCover_covers","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\nğ’° : X.AffineOpenCover\nx : â†‘â†‘X.toPresheafedSpace\nâŠ¢ Eq â‹¯ â‹¯","decl":"/-- The open cover associated to an affine open cover. -/\n@[simps! J obj map f covers]\ndef openCover {X : Scheme.{u}} (ğ’° : X.AffineOpenCover) : X.OpenCover :=\n  AffineCover.cover ğ’°\n\n"}
{"name":"AlgebraicGeometry.Scheme.affineOpenCover_J","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\nâŠ¢ Eq X.affineOpenCover.J X.affineCover.J","decl":"/-- A choice of an affine open cover of a scheme. -/\n@[simps]\ndef affineOpenCover (X : Scheme.{u}) : X.AffineOpenCover where\n  J := X.affineCover.J\n  map := X.affineCover.map\n  f := X.affineCover.f\n  covers := X.affineCover.covers\n\n"}
{"name":"AlgebraicGeometry.Scheme.affineOpenCover_obj","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\nj : X.affineCover.J\nâŠ¢ Eq (X.affineOpenCover.obj j) â‹¯.choose","decl":"/-- A choice of an affine open cover of a scheme. -/\n@[simps]\ndef affineOpenCover (X : Scheme.{u}) : X.AffineOpenCover where\n  J := X.affineCover.J\n  map := X.affineCover.map\n  f := X.affineCover.f\n  covers := X.affineCover.covers\n\n"}
{"name":"AlgebraicGeometry.Scheme.affineOpenCover_map","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\nj : X.affineCover.J\nâŠ¢ Eq (X.affineOpenCover.map j) (X.affineCover.map j)","decl":"/-- A choice of an affine open cover of a scheme. -/\n@[simps]\ndef affineOpenCover (X : Scheme.{u}) : X.AffineOpenCover where\n  J := X.affineCover.J\n  map := X.affineCover.map\n  f := X.affineCover.f\n  covers := X.affineCover.covers\n\n"}
{"name":"AlgebraicGeometry.Scheme.affineOpenCover_f","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\nx : â†‘â†‘X.toPresheafedSpace\nâŠ¢ Eq (X.affineOpenCover.f x) (X.affineCover.f x)","decl":"/-- A choice of an affine open cover of a scheme. -/\n@[simps]\ndef affineOpenCover (X : Scheme.{u}) : X.AffineOpenCover where\n  J := X.affineCover.J\n  map := X.affineCover.map\n  f := X.affineCover.f\n  covers := X.affineCover.covers\n\n"}
{"name":"AlgebraicGeometry.Scheme.openCover_affineOpenCover","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\nâŠ¢ Eq X.affineOpenCover.openCover X.affineCover","decl":"@[simp]\nlemma openCover_affineOpenCover (X : Scheme.{u}) : X.affineOpenCover.openCover = X.affineCover :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.OpenCover.pullbackCoverAffineRefinementObjIso_inv_map","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nğ’° : Y.OpenCover\ni : (AlgebraicGeometry.Scheme.Cover.pullbackCover ğ’°.affineRefinement.openCover f).J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.OpenCover.pullbackCoverAffineRefinementObjIso f ğ’° i).inv ((AlgebraicGeometry.Scheme.Cover.pullbackCover ğ’°.affineRefinement.openCover f).map i)) (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Scheme.Cover.pullbackCover (ğ’°.obj i.fst).affineCover (AlgebraicGeometry.Scheme.Cover.pullbackHom ğ’° f i.fst)).map i.snd) ((AlgebraicGeometry.Scheme.Cover.pullbackCover ğ’° f).map i.fst))","decl":"@[reassoc]\nlemma OpenCover.pullbackCoverAffineRefinementObjIso_inv_map (f : X âŸ¶ Y) (ğ’° : Y.OpenCover) (i) :\n    (ğ’°.pullbackCoverAffineRefinementObjIso f i).inv â‰«\n      (ğ’°.affineRefinement.openCover.pullbackCover f).map i =\n      ((ğ’°.obj i.1).affineCover.pullbackCover (ğ’°.pullbackHom f i.1)).map i.2 â‰«\n        (ğ’°.pullbackCover f).map i.1 := by\n  simp only [Cover.pullbackCover_obj, AffineCover.cover_obj, AffineCover.cover_map,\n    pullbackCoverAffineRefinementObjIso, Iso.trans_inv, asIso_inv, Iso.symm_inv, Category.assoc,\n    Cover.pullbackCover_map, pullbackSymmetry_inv_comp_fst, IsIso.inv_comp_eq, limit.lift_Ï€_assoc,\n    id_eq, PullbackCone.mk_pt, cospan_left, PullbackCone.mk_Ï€_app, pullbackSymmetry_hom_comp_fst]\n  convert pullbackSymmetry_inv_comp_snd_assoc\n    ((ğ’°.obj i.1).affineCover.map i.2) (pullback.fst _ _) _ using 2\n  exact pullbackRightPullbackFstIso_hom_snd _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.OpenCover.pullbackCoverAffineRefinementObjIso_inv_map_assoc","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nğ’° : Y.OpenCover\ni : (AlgebraicGeometry.Scheme.Cover.pullbackCover ğ’°.affineRefinement.openCover f).J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom X Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.OpenCover.pullbackCoverAffineRefinementObjIso f ğ’° i).inv (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Scheme.Cover.pullbackCover ğ’°.affineRefinement.openCover f).map i) h)) (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Scheme.Cover.pullbackCover (ğ’°.obj i.fst).affineCover (AlgebraicGeometry.Scheme.Cover.pullbackHom ğ’° f i.fst)).map i.snd) (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Scheme.Cover.pullbackCover ğ’° f).map i.fst) h))","decl":"@[reassoc]\nlemma OpenCover.pullbackCoverAffineRefinementObjIso_inv_map (f : X âŸ¶ Y) (ğ’° : Y.OpenCover) (i) :\n    (ğ’°.pullbackCoverAffineRefinementObjIso f i).inv â‰«\n      (ğ’°.affineRefinement.openCover.pullbackCover f).map i =\n      ((ğ’°.obj i.1).affineCover.pullbackCover (ğ’°.pullbackHom f i.1)).map i.2 â‰«\n        (ğ’°.pullbackCover f).map i.1 := by\n  simp only [Cover.pullbackCover_obj, AffineCover.cover_obj, AffineCover.cover_map,\n    pullbackCoverAffineRefinementObjIso, Iso.trans_inv, asIso_inv, Iso.symm_inv, Category.assoc,\n    Cover.pullbackCover_map, pullbackSymmetry_inv_comp_fst, IsIso.inv_comp_eq, limit.lift_Ï€_assoc,\n    id_eq, PullbackCone.mk_pt, cospan_left, PullbackCone.mk_Ï€_app, pullbackSymmetry_hom_comp_fst]\n  convert pullbackSymmetry_inv_comp_snd_assoc\n    ((ğ’°.obj i.1).affineCover.map i.2) (pullback.fst _ _) _ using 2\n  exact pullbackRightPullbackFstIso_hom_snd _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.OpenCover.pullbackCoverAffineRefinementObjIso_inv_pullbackHom","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nğ’° : Y.OpenCover\ni : (AlgebraicGeometry.Scheme.Cover.pullbackCover ğ’°.affineRefinement.openCover f).J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.OpenCover.pullbackCoverAffineRefinementObjIso f ğ’° i).inv (AlgebraicGeometry.Scheme.Cover.pullbackHom ğ’°.affineRefinement.openCover f i)) (AlgebraicGeometry.Scheme.Cover.pullbackHom (ğ’°.obj i.fst).affineCover (AlgebraicGeometry.Scheme.Cover.pullbackHom ğ’° f i.fst) i.snd)","decl":"@[reassoc]\nlemma OpenCover.pullbackCoverAffineRefinementObjIso_inv_pullbackHom\n    (f : X âŸ¶ Y) (ğ’° : Y.OpenCover) (i) :\n    (ğ’°.pullbackCoverAffineRefinementObjIso f i).inv â‰«\n      ğ’°.affineRefinement.openCover.pullbackHom f i =\n      (ğ’°.obj i.1).affineCover.pullbackHom (ğ’°.pullbackHom f i.1) i.2 := by\n  simp only [Cover.pullbackCover_obj, Cover.pullbackHom, AffineCover.cover_obj,\n    AffineOpenCover.openCover_map, pullbackCoverAffineRefinementObjIso, Iso.trans_inv, asIso_inv,\n    Iso.symm_inv, Category.assoc, pullbackSymmetry_inv_comp_snd, IsIso.inv_comp_eq, limit.lift_Ï€,\n    id_eq, PullbackCone.mk_pt, PullbackCone.mk_Ï€_app, Category.comp_id]\n  convert pullbackSymmetry_inv_comp_fst ((ğ’°.obj i.1).affineCover.map i.2) (pullback.fst _ _)\n  exact pullbackRightPullbackFstIso_hom_fst _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.OpenCover.pullbackCoverAffineRefinementObjIso_inv_pullbackHom_assoc","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nğ’° : Y.OpenCover\ni : (AlgebraicGeometry.Scheme.Cover.pullbackCover ğ’°.affineRefinement.openCover f).J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (ğ’°.affineRefinement.openCover.obj i) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.OpenCover.pullbackCoverAffineRefinementObjIso f ğ’° i).inv (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.pullbackHom ğ’°.affineRefinement.openCover f i) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Cover.pullbackHom (ğ’°.obj i.fst).affineCover (AlgebraicGeometry.Scheme.Cover.pullbackHom ğ’° f i.fst) i.snd) h)","decl":"@[reassoc]\nlemma OpenCover.pullbackCoverAffineRefinementObjIso_inv_pullbackHom\n    (f : X âŸ¶ Y) (ğ’° : Y.OpenCover) (i) :\n    (ğ’°.pullbackCoverAffineRefinementObjIso f i).inv â‰«\n      ğ’°.affineRefinement.openCover.pullbackHom f i =\n      (ğ’°.obj i.1).affineCover.pullbackHom (ğ’°.pullbackHom f i.1) i.2 := by\n  simp only [Cover.pullbackCover_obj, Cover.pullbackHom, AffineCover.cover_obj,\n    AffineOpenCover.openCover_map, pullbackCoverAffineRefinementObjIso, Iso.trans_inv, asIso_inv,\n    Iso.symm_inv, Category.assoc, pullbackSymmetry_inv_comp_snd, IsIso.inv_comp_eq, limit.lift_Ï€,\n    id_eq, PullbackCone.mk_pt, PullbackCone.mk_Ï€_app, Category.comp_id]\n  convert pullbackSymmetry_inv_comp_fst ((ğ’°.obj i.1).affineCover.map i.2) (pullback.fst _ _)\n  exact pullbackRightPullbackFstIso_hom_fst _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.affineOpenCoverOfSpanRangeEqTop_map","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"R : CommRingCat\nÎ¹ : Type u_1\ns : Î¹ â†’ â†‘R\nhs : Eq (Ideal.span (Set.range s)) Top.top\ni : Î¹\nâŠ¢ Eq ((AlgebraicGeometry.Scheme.affineOpenCoverOfSpanRangeEqTop s hs).map i) (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap (â†‘R) (Localization.Away (s i)))))","decl":"/-- A family of elements spanning the unit ideal of `R` gives a affine open cover of `Spec R`. -/\n@[simps]\nnoncomputable\ndef affineOpenCoverOfSpanRangeEqTop {R : CommRingCat} {Î¹ : Type*} (s : Î¹ â†’ R)\n    (hs : Ideal.span (Set.range s) = âŠ¤) : (Spec R).AffineOpenCover where\n  J := Î¹\n  obj i := .of (Localization.Away (s i))\n  map i := Spec.map (CommRingCat.ofHom (algebraMap R (Localization.Away (s i))))\n  f x := by\n    have : âˆƒ i, s i âˆ‰ x.asIdeal := by\n      by_contra! h; apply x.2.ne_top; rwa [â† top_le_iff, â† hs, Ideal.span_le, Set.range_subset_iff]\n    exact this.choose\n  covers x := by\n    generalize_proofs H\n    let i := (H x).choose\n    have := PrimeSpectrum.localization_away_comap_range (Localization.Away (s i)) (s i)\n    exact (eq_iff_iff.mp congr(x âˆˆ $this)).mpr (H x).choose_spec\n\n"}
{"name":"AlgebraicGeometry.Scheme.affineOpenCoverOfSpanRangeEqTop_obj_carrier","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"R : CommRingCat\nÎ¹ : Type u_1\ns : Î¹ â†’ â†‘R\nhs : Eq (Ideal.span (Set.range s)) Top.top\ni : Î¹\nâŠ¢ Eq (â†‘((AlgebraicGeometry.Scheme.affineOpenCoverOfSpanRangeEqTop s hs).obj i)) (Localization.Away (s i))","decl":"/-- A family of elements spanning the unit ideal of `R` gives a affine open cover of `Spec R`. -/\n@[simps]\nnoncomputable\ndef affineOpenCoverOfSpanRangeEqTop {R : CommRingCat} {Î¹ : Type*} (s : Î¹ â†’ R)\n    (hs : Ideal.span (Set.range s) = âŠ¤) : (Spec R).AffineOpenCover where\n  J := Î¹\n  obj i := .of (Localization.Away (s i))\n  map i := Spec.map (CommRingCat.ofHom (algebraMap R (Localization.Away (s i))))\n  f x := by\n    have : âˆƒ i, s i âˆ‰ x.asIdeal := by\n      by_contra! h; apply x.2.ne_top; rwa [â† top_le_iff, â† hs, Ideal.span_le, Set.range_subset_iff]\n    exact this.choose\n  covers x := by\n    generalize_proofs H\n    let i := (H x).choose\n    have := PrimeSpectrum.localization_away_comap_range (Localization.Away (s i)) (s i)\n    exact (eq_iff_iff.mp congr(x âˆˆ $this)).mpr (H x).choose_spec\n\n"}
{"name":"AlgebraicGeometry.Scheme.affineOpenCoverOfSpanRangeEqTop_f","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"R : CommRingCat\nÎ¹ : Type u_1\ns : Î¹ â†’ â†‘R\nhs : Eq (Ideal.span (Set.range s)) Top.top\nx : â†‘â†‘(AlgebraicGeometry.Spec R).toPresheafedSpace\nâŠ¢ Eq ((AlgebraicGeometry.Scheme.affineOpenCoverOfSpanRangeEqTop s hs).f x) (letFun â‹¯ fun this => this.choose)","decl":"/-- A family of elements spanning the unit ideal of `R` gives a affine open cover of `Spec R`. -/\n@[simps]\nnoncomputable\ndef affineOpenCoverOfSpanRangeEqTop {R : CommRingCat} {Î¹ : Type*} (s : Î¹ â†’ R)\n    (hs : Ideal.span (Set.range s) = âŠ¤) : (Spec R).AffineOpenCover where\n  J := Î¹\n  obj i := .of (Localization.Away (s i))\n  map i := Spec.map (CommRingCat.ofHom (algebraMap R (Localization.Away (s i))))\n  f x := by\n    have : âˆƒ i, s i âˆ‰ x.asIdeal := by\n      by_contra! h; apply x.2.ne_top; rwa [â† top_le_iff, â† hs, Ideal.span_le, Set.range_subset_iff]\n    exact this.choose\n  covers x := by\n    generalize_proofs H\n    let i := (H x).choose\n    have := PrimeSpectrum.localization_away_comap_range (Localization.Away (s i)) (s i)\n    exact (eq_iff_iff.mp congr(x âˆˆ $this)).mpr (H x).choose_spec\n\n"}
{"name":"AlgebraicGeometry.Scheme.affineOpenCoverOfSpanRangeEqTop_J","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"R : CommRingCat\nÎ¹ : Type u_1\ns : Î¹ â†’ â†‘R\nhs : Eq (Ideal.span (Set.range s)) Top.top\nâŠ¢ Eq (AlgebraicGeometry.Scheme.affineOpenCoverOfSpanRangeEqTop s hs).J Î¹","decl":"/-- A family of elements spanning the unit ideal of `R` gives a affine open cover of `Spec R`. -/\n@[simps]\nnoncomputable\ndef affineOpenCoverOfSpanRangeEqTop {R : CommRingCat} {Î¹ : Type*} (s : Î¹ â†’ R)\n    (hs : Ideal.span (Set.range s) = âŠ¤) : (Spec R).AffineOpenCover where\n  J := Î¹\n  obj i := .of (Localization.Away (s i))\n  map i := Spec.map (CommRingCat.ofHom (algebraMap R (Localization.Away (s i))))\n  f x := by\n    have : âˆƒ i, s i âˆ‰ x.asIdeal := by\n      by_contra! h; apply x.2.ne_top; rwa [â† top_le_iff, â† hs, Ideal.span_le, Set.range_subset_iff]\n    exact this.choose\n  covers x := by\n    generalize_proofs H\n    let i := (H x).choose\n    have := PrimeSpectrum.localization_away_comap_range (Localization.Away (s i)) (s i)\n    exact (eq_iff_iff.mp congr(x âˆˆ $this)).mpr (H x).choose_spec\n\n"}
{"name":"AlgebraicGeometry.Scheme.OpenCover.ext_elem","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nf g : â†‘(X.presheaf.obj { unop := U })\nğ’° : X.OpenCover\nh : âˆ€ (i : ğ’°.J), Eq ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.app (ğ’°.map i) U)) f) ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.app (ğ’°.map i) U)) g)\nâŠ¢ Eq f g","decl":"/-- If two global sections agree after restriction to each member of an open cover, then\nthey agree globally. -/\nlemma OpenCover.ext_elem {X : Scheme.{u}} {U : X.Opens} (f g : Î“(X, U)) (ğ’° : X.OpenCover)\n    (h : âˆ€ i : ğ’°.J, (ğ’°.map i).app U f = (ğ’°.map i).app U g) : f = g := by\n  fapply TopCat.Sheaf.eq_of_locally_eq' X.sheaf\n    (fun i â†¦ (ğ’°.map (ğ’°.f i)).opensRange âŠ“ U) _ (fun _ â†¦ homOfLE inf_le_right)\n  Â· intro x hx\n    simp only [Opens.iSup_mk, Opens.carrier_eq_coe, Opens.coe_inf, Hom.coe_opensRange, Opens.coe_mk,\n      Set.mem_iUnion, Set.mem_inter_iff, Set.mem_range, SetLike.mem_coe, exists_and_right]\n    refine âŸ¨?_, hxâŸ©\n    simpa using âŸ¨_, ğ’°.covers xâŸ©\n  Â· intro x\n    replace h := h (ğ’°.f x)\n    rw [â† IsOpenImmersion.map_Î“Iso_inv] at h\n    exact (IsOpenImmersion.Î“Iso (ğ’°.map (ğ’°.f x)) U).commRingCatIsoToRingEquiv.symm.injective h\n\n"}
{"name":"AlgebraicGeometry.Scheme.zero_of_zero_cover","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\ns : â†‘(X.presheaf.obj { unop := U })\nğ’° : X.OpenCover\nh : âˆ€ (i : ğ’°.J), Eq ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.app (ğ’°.map i) U)) s) 0\nâŠ¢ Eq s 0","decl":"/-- If the restriction of a global section to each member of an open cover is zero, then it is\nglobally zero. -/\nlemma zero_of_zero_cover {X : Scheme.{u}} {U : X.Opens} (s : Î“(X, U)) (ğ’° : X.OpenCover)\n    (h : âˆ€ i : ğ’°.J, (ğ’°.map i).app U s = 0) : s = 0 :=\n  ğ’°.ext_elem s 0 (fun i â†¦ by rw [map_zero]; exact h i)\n\n"}
{"name":"AlgebraicGeometry.Scheme.isNilpotent_of_isNilpotent_cover","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\ns : â†‘(X.presheaf.obj { unop := U })\nğ’° : X.OpenCover\ninstâœ : Finite ğ’°.J\nh : âˆ€ (i : ğ’°.J), IsNilpotent ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.app (ğ’°.map i) U)) s)\nâŠ¢ IsNilpotent s","decl":"/-- If a global section is nilpotent on each member of a finite open cover, then `f` is\nnilpotent. -/\nlemma isNilpotent_of_isNilpotent_cover {X : Scheme.{u}} {U : X.Opens} (s : Î“(X, U))\n    (ğ’° : X.OpenCover) [Finite ğ’°.J] (h : âˆ€ i : ğ’°.J, IsNilpotent ((ğ’°.map i).app U s)) :\n    IsNilpotent s := by\n  choose fn hfn using h\n  have : Fintype ğ’°.J := Fintype.ofFinite ğ’°.J\n  /- the maximum of all `fn i` (exists, because `ğ’°.J` is finite) -/\n  let N : â„• := Finset.sup Finset.univ fn\n  have hfnleN (i : ğ’°.J) : fn i â‰¤ N := Finset.le_sup (Finset.mem_univ i)\n  use N\n  apply zero_of_zero_cover (ğ’° := ğ’°)\n  on_goal 1 => intro i; simp only [map_pow]\n  -- This closes both remaining goals at once.\n  exact pow_eq_zero_of_le (hfnleN i) (hfn i)\n\n"}
{"name":"AlgebraicGeometry.Scheme.affineBasisCover_obj","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\ni : X.affineBasisCover.J\nâŠ¢ Eq (X.affineBasisCover.obj i) (AlgebraicGeometry.Spec (X.affineBasisCoverRing i))","decl":"theorem affineBasisCover_obj (X : Scheme.{u}) (i : X.affineBasisCover.J) :\n    X.affineBasisCover.obj i = Spec (X.affineBasisCoverRing i) :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.affineBasisCover_map_range","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\nx : â†‘â†‘X.toPresheafedSpace\nr : â†‘â‹¯.choose\nâŠ¢ Eq (Set.range â‡‘(X.affineBasisCover.map âŸ¨x, râŸ©).base) (Set.image (â‡‘(X.affineCover.map x).base) (PrimeSpectrum.basicOpen r).carrier)","decl":"theorem affineBasisCover_map_range (X : Scheme.{u}) (x : X)\n    (r : (X.local_affine x).choose_spec.choose) :\n    Set.range (X.affineBasisCover.map âŸ¨x, râŸ©).base =\n      (X.affineCover.map x).base '' (PrimeSpectrum.basicOpen r).1 := by\n  erw [coe_comp, Set.range_comp]\n  -- Porting note: `congr` fails to see the goal is comparing image of the same function\n  refine congr_arg (_ '' Â·) ?_\n  exact (PrimeSpectrum.localization_away_comap_range (Localization.Away r) r :)\n\n"}
{"name":"AlgebraicGeometry.Scheme.affineBasisCover_is_basis","module":"Mathlib.AlgebraicGeometry.Cover.Open","initialProofState":"X : AlgebraicGeometry.Scheme\nâŠ¢ TopologicalSpace.IsTopologicalBasis (setOf fun x => Exists fun a => Eq x (Set.range â‡‘(X.affineBasisCover.map a).base))","decl":"theorem affineBasisCover_is_basis (X : Scheme.{u}) :\n    TopologicalSpace.IsTopologicalBasis\n      {x : Set X |\n        âˆƒ a : X.affineBasisCover.J, x = Set.range (X.affineBasisCover.map a).base} := by\n  apply TopologicalSpace.isTopologicalBasis_of_isOpen_of_nhds\n  Â· rintro _ âŸ¨a, rflâŸ©\n    exact IsOpenImmersion.isOpen_range (X.affineBasisCover.map a)\n  Â· rintro a U haU hU\n    rcases X.affineCover.covers a with âŸ¨x, eâŸ©\n    let U' := (X.affineCover.map (X.affineCover.f a)).base â»Â¹' U\n    have hxU' : x âˆˆ U' := by rw [â† e] at haU; exact haU\n    rcases PrimeSpectrum.isBasis_basic_opens.exists_subset_of_mem_open hxU'\n        ((X.affineCover.map (X.affineCover.f a)).base.continuous_toFun.isOpen_preimage _\n          hU) with\n      âŸ¨_, âŸ¨_, âŸ¨s, rflâŸ©, rflâŸ©, hxV, hVUâŸ©\n    refine âŸ¨_, âŸ¨âŸ¨_, sâŸ©, rflâŸ©, ?_, ?_âŸ© <;> rw [affineBasisCover_map_range]\n    Â· exact âŸ¨x, hxV, eâŸ©\n    Â· rw [Set.image_subset_iff]; exact hVU\n\n"}
