{"name":"TwoSidedIdeal.subset_span","module":"Mathlib.RingTheory.TwoSidedIdeal.Operations","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\ns : Set R\n⊢ HasSubset.Subset s ↑(TwoSidedIdeal.span s)","decl":"lemma subset_span {s : Set R} : s ⊆ (span s : Set R) := by\n  intro x hx\n  rw [SetLike.mem_coe, mem_iff]\n  exact RingConGen.Rel.of _ _ (by simpa using hx)\n\n"}
{"name":"TwoSidedIdeal.mem_span_iff","module":"Mathlib.RingTheory.TwoSidedIdeal.Operations","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\ns : Set R\nx : R\n⊢ Iff (Membership.mem (TwoSidedIdeal.span s) x) (∀ (I : TwoSidedIdeal R), HasSubset.Subset s ↑I → Membership.mem I x)","decl":"lemma mem_span_iff {s : Set R} {x} :\n    x ∈ span s ↔ ∀ (I : TwoSidedIdeal R), s ⊆ I → x ∈ I := by\n  refine ⟨?_, fun h => h _ subset_span⟩\n  delta span\n  rw [RingCon.ringConGen_eq]\n  intro h I hI\n  refine sInf_le (α := RingCon R) ?_ h\n  intro x y hxy\n  specialize hI hxy\n  rwa [SetLike.mem_coe, ← rel_iff] at hI\n\n"}
{"name":"TwoSidedIdeal.span_mono","module":"Mathlib.RingTheory.TwoSidedIdeal.Operations","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\ns t : Set R\nh : HasSubset.Subset s t\n⊢ LE.le (TwoSidedIdeal.span s) (TwoSidedIdeal.span t)","decl":"lemma span_mono {s t : Set R} (h : s ⊆ t) : span s ≤ span t := by\n  intro x hx\n  rw [mem_span_iff] at hx ⊢\n  exact fun I hI => hx I <| h.trans hI\n\n"}
{"name":"TwoSidedIdeal.map_mono","module":"Mathlib.RingTheory.TwoSidedIdeal.Operations","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : NonUnitalNonAssocRing R\ninst✝¹ : NonUnitalNonAssocRing S\nF : Type u_3\ninst✝ : FunLike F R S\nf : F\nI J : TwoSidedIdeal R\nh : LE.le I J\n⊢ LE.le (TwoSidedIdeal.map f I) (TwoSidedIdeal.map f J)","decl":"lemma map_mono {I J : TwoSidedIdeal R} (h : I ≤ J) :\n    map f I ≤ map f J :=\n  span_mono <| Set.image_mono h\n\n"}
{"name":"TwoSidedIdeal.mem_comap","module":"Mathlib.RingTheory.TwoSidedIdeal.Operations","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : NonUnitalNonAssocRing R\ninst✝² : NonUnitalNonAssocRing S\nF : Type u_3\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : NonUnitalRingHomClass F R S\nI : TwoSidedIdeal S\nx : R\n⊢ Iff (Membership.mem (TwoSidedIdeal.comap f I) x) (Membership.mem I (f x))","decl":"lemma mem_comap {I : TwoSidedIdeal S} {x : R} :\n    x ∈ I.comap f ↔ f x ∈ I := by\n  simp [comap, RingCon.comap, mem_iff]\n\n\n"}
{"name":"TwoSidedIdeal.mem_span_iff_mem_addSubgroup_closure_absorbing","module":"Mathlib.RingTheory.TwoSidedIdeal.Operations","initialProofState":"R : Type u_1\ninst✝ : NonUnitalRing R\ns : Set R\nh_left : ∀ (x y : R), Membership.mem s y → Membership.mem s (HMul.hMul x y)\nh_right : ∀ (y x : R), Membership.mem s y → Membership.mem s (HMul.hMul y x)\nz : R\n⊢ Iff (Membership.mem (TwoSidedIdeal.span s) z) (Membership.mem (AddSubgroup.closure s) z)","decl":"open AddSubgroup in\n/-- If `s : Set R` is absorbing under multiplication, then its `TwoSidedIdeal.span` coincides with\nits `AddSubgroup.closure`, as sets. -/\nlemma mem_span_iff_mem_addSubgroup_closure_absorbing {s : Set R}\n    (h_left : ∀ x y, y ∈ s → x * y ∈ s) (h_right : ∀ y x, y ∈ s → y * x ∈ s) {z : R} :\n    z ∈ span s ↔ z ∈ closure s := by\n  have h_left' {x y} (hy : y ∈ closure s) : x * y ∈ closure s := by\n    have := (AddMonoidHom.mulLeft x).map_closure s ▸ mem_map_of_mem _ hy\n    refine closure_mono ?_ this\n    rintro - ⟨y, hy, rfl⟩\n    exact h_left x y hy\n  have h_right' {y x} (hy : y ∈ closure s) : y * x ∈ closure s := by\n    have := (AddMonoidHom.mulRight x).map_closure s ▸ mem_map_of_mem _ hy\n    refine closure_mono ?_ this\n    rintro - ⟨y, hy, rfl⟩\n    exact h_right y x hy\n  let I : TwoSidedIdeal R := .mk' (closure s) (AddSubgroup.zero_mem _)\n    (AddSubgroup.add_mem _) (AddSubgroup.neg_mem _) h_left' h_right'\n  suffices z ∈ span s ↔ z ∈ I by simpa only [I, mem_mk', SetLike.mem_coe]\n  rw [mem_span_iff]\n  -- Suppose that for every ideal `J` with `s ⊆ J`, then `z ∈ J`. Apply this to `I` to get `z ∈ I`.\n  refine ⟨fun h ↦ h I fun x hx ↦ ?mem_closure_of_forall, fun hz J hJ ↦ ?mem_ideal_of_subset⟩\n  case mem_closure_of_forall => simpa only [I, SetLike.mem_coe, mem_mk'] using subset_closure hx\n  /- Conversely, suppose that `z ∈ I` and that `J` is any ideal containing `s`. Then by the\n  induction principle for `AddSubgroup`, we must also have `z ∈ J`. -/\n  case mem_ideal_of_subset =>\n    simp only [I, SetLike.mem_coe, mem_mk'] at hz\n    induction hz using closure_induction with\n    | mem x hx => exact hJ hx\n    | one => exact zero_mem _\n    | mul x y _ _ hx hy => exact J.add_mem hx hy\n    | inv x _ hx => exact J.neg_mem hx\n\n"}
{"name":"TwoSidedIdeal.set_mul_subset","module":"Mathlib.RingTheory.TwoSidedIdeal.Operations","initialProofState":"R : Type u_1\ninst✝ : NonUnitalRing R\ns : Set R\nI : TwoSidedIdeal R\nh : HasSubset.Subset s ↑I\nt : Set R\n⊢ HasSubset.Subset (HMul.hMul t s) ↑I","decl":"lemma set_mul_subset {s : Set R} {I : TwoSidedIdeal R} (h : s ⊆ I) (t : Set R):\n    t * s ⊆ I := by\n  rintro - ⟨r, -, x, hx, rfl⟩\n  exact mul_mem_left _ _ _ (h hx)\n\n"}
{"name":"TwoSidedIdeal.subset_mul_set","module":"Mathlib.RingTheory.TwoSidedIdeal.Operations","initialProofState":"R : Type u_1\ninst✝ : NonUnitalRing R\ns : Set R\nI : TwoSidedIdeal R\nh : HasSubset.Subset s ↑I\nt : Set R\n⊢ HasSubset.Subset (HMul.hMul s t) ↑I","decl":"lemma subset_mul_set {s : Set R} {I : TwoSidedIdeal R} (h : s ⊆ I) (t : Set R):\n    s * t ⊆ I := by\n  rintro - ⟨x, hx, r, -, rfl⟩\n  exact mul_mem_right _ _ _ (h hx)\n\n"}
{"name":"TwoSidedIdeal.mem_span_iff_mem_addSubgroup_closure_nonunital","module":"Mathlib.RingTheory.TwoSidedIdeal.Operations","initialProofState":"R : Type u_1\ninst✝ : NonUnitalRing R\ns : Set R\nz : R\n⊢ Iff (Membership.mem (TwoSidedIdeal.span s) z) (Membership.mem (AddSubgroup.closure (Union.union (Union.union (Union.union s (HMul.hMul s Set.univ)) (HMul.hMul Set.univ s)) (HMul.hMul (HMul.hMul Set.univ s) Set.univ))) z)","decl":"lemma mem_span_iff_mem_addSubgroup_closure_nonunital {s : Set R} {z : R} :\n    z ∈ span s ↔ z ∈ AddSubgroup.closure (s ∪ s * univ ∪ univ * s ∪ univ * s * univ) := by\n  trans z ∈ span (s ∪ s * univ ∪ univ * s ∪ univ * s * univ)\n  · refine ⟨(span_mono (by simp only [Set.union_assoc, Set.subset_union_left]) ·), fun h ↦ ?_⟩\n    refine mem_span_iff.mp h (span s) ?_\n    simp only [union_subset_iff, union_assoc]\n    exact ⟨subset_span, subset_mul_set subset_span _, set_mul_subset subset_span _,\n      subset_mul_set (set_mul_subset subset_span _) _⟩\n  · refine mem_span_iff_mem_addSubgroup_closure_absorbing ?_ ?_\n    · rintro x y (((hy | ⟨y, hy, r, -, rfl⟩) | ⟨r, -, y, hy, rfl⟩) |\n        ⟨-, ⟨r', -, y, hy, rfl⟩, r, -, rfl⟩)\n      · exact .inl <| .inr <| ⟨x, mem_univ _, y, hy, rfl⟩\n      · exact .inr <| ⟨x * y, ⟨x, mem_univ _, y, hy, rfl⟩, r, mem_univ _, mul_assoc ..⟩\n      · exact .inl <| .inr <| ⟨x * r, mem_univ _, y, hy, mul_assoc ..⟩\n      · refine .inr <| ⟨x * r' * y, ⟨x * r', mem_univ _, y, hy, ?_⟩, ⟨r, mem_univ _, ?_⟩⟩\n        all_goals simp [mul_assoc]\n    · rintro y x (((hy | ⟨y, hy, r, -, rfl⟩) | ⟨r, -, y, hy, rfl⟩) |\n        ⟨-, ⟨r', -, y, hy, rfl⟩, r, -, rfl⟩)\n      · exact .inl <| .inl <| .inr ⟨y, hy, x, mem_univ _, rfl⟩\n      · exact .inl <| .inl <| .inr ⟨y, hy, r * x, mem_univ _, (mul_assoc ..).symm⟩\n      · exact .inr <| ⟨r * y, ⟨r, mem_univ _, y, hy, rfl⟩, x, mem_univ _, rfl⟩\n      · refine .inr <| ⟨r' * y, ⟨r', mem_univ _, y, hy, rfl⟩, r * x, mem_univ _, ?_⟩\n        simp [mul_assoc]\n\n"}
{"name":"TwoSidedIdeal.mem_span_iff_mem_addSubgroup_closure","module":"Mathlib.RingTheory.TwoSidedIdeal.Operations","initialProofState":"R : Type u_1\ninst✝ : Ring R\ns : Set R\nz : R\n⊢ Iff (Membership.mem (TwoSidedIdeal.span s) z) (Membership.mem (AddSubgroup.closure (HMul.hMul (HMul.hMul Set.univ s) Set.univ)) z)","decl":"open Pointwise Set in\nlemma mem_span_iff_mem_addSubgroup_closure {s : Set R} {z : R} :\n    z ∈ span s ↔ z ∈ AddSubgroup.closure (univ * s * univ) := by\n  trans z ∈ span (univ * s * univ)\n  · refine ⟨(span_mono (fun x hx ↦ ?_) ·), fun hz ↦ ?_⟩\n    · exact ⟨1 * x, ⟨1, mem_univ _, x, hx, rfl⟩, 1, mem_univ _, by simp⟩\n    · exact mem_span_iff.mp hz (span s) <| subset_mul_set (set_mul_subset subset_span _) _\n  · refine mem_span_iff_mem_addSubgroup_closure_absorbing ?_ ?_\n    · intro x y hy\n      rw [mul_assoc] at hy ⊢\n      obtain ⟨r, -, y, hy, rfl⟩ := hy\n      exact ⟨x * r, mem_univ _, y, hy, mul_assoc ..⟩\n    · rintro - x ⟨y, hy, r, -, rfl⟩\n      exact ⟨y, hy, r * x, mem_univ _, (mul_assoc ..).symm⟩\n\n"}
{"name":"TwoSidedIdeal.coe_smul","module":"Mathlib.RingTheory.TwoSidedIdeal.Operations","initialProofState":"R : Type u_1\ninst✝ : Ring R\nI : TwoSidedIdeal R\nr : R\nx : Subtype fun x => Membership.mem I x\n⊢ Eq (HSMul.hSMul r ↑x) (HMul.hMul r ↑x)","decl":"@[simp]\nlemma coe_smul {r : R} {x : I} : (r • x : R) = r * (x : R) := rfl\n\n"}
{"name":"TwoSidedIdeal.coe_mop_smul","module":"Mathlib.RingTheory.TwoSidedIdeal.Operations","initialProofState":"R : Type u_1\ninst✝ : Ring R\nI : TwoSidedIdeal R\nr : MulOpposite R\nx : Subtype fun x => Membership.mem I x\n⊢ Eq (HSMul.hSMul r ↑x) (HMul.hMul (↑x) (MulOpposite.unop r))","decl":"@[simp]\nlemma coe_mop_smul {r : Rᵐᵒᵖ} {x : I} : (r • x : R) = (x : R) * r.unop := rfl\n\n"}
{"name":"TwoSidedIdeal.instSMulCommClassMulOppositeSubtypeMem","module":"Mathlib.RingTheory.TwoSidedIdeal.Operations","initialProofState":"R : Type u_1\ninst✝ : Ring R\nI : TwoSidedIdeal R\n⊢ SMulCommClass R (MulOpposite R) (Subtype fun x => Membership.mem I x)","decl":"instance : SMulCommClass R Rᵐᵒᵖ I where\n  smul_comm r s x := Subtype.ext <| smul_comm r s x.1\n\n"}
{"name":"TwoSidedIdeal.subtype_apply","module":"Mathlib.RingTheory.TwoSidedIdeal.Operations","initialProofState":"R : Type u_1\ninst✝ : Ring R\nI : TwoSidedIdeal R\nx : Subtype fun x => Membership.mem I x\n⊢ Eq (I.subtype x) ↑x","decl":"/--\nFor any `I : RingCon R`, when we view it as an ideal, `I.subtype` is the injective `R`-linear map\n`I → R`.\n-/\n@[simps]\ndef subtype : I →ₗ[R] R where\n  toFun x := x.1\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n\n"}
{"name":"TwoSidedIdeal.subtypeMop_apply","module":"Mathlib.RingTheory.TwoSidedIdeal.Operations","initialProofState":"R : Type u_1\ninst✝ : Ring R\nI : TwoSidedIdeal R\nx : Subtype fun x => Membership.mem I x\n⊢ Eq (I.subtypeMop x) (MulOpposite.op ↑x)","decl":"/--\nFor any `RingCon R`, when we view it as an ideal in `Rᵒᵖ`, `subtype` is the injective `Rᵐᵒᵖ`-linear\nmap `I → Rᵐᵒᵖ`.\n-/\n@[simps]\ndef subtypeMop : I →ₗ[Rᵐᵒᵖ] Rᵐᵒᵖ where\n  toFun x := MulOpposite.op x.1\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n\n"}
{"name":"TwoSidedIdeal.mem_fromIdeal","module":"Mathlib.RingTheory.TwoSidedIdeal.Operations","initialProofState":"R : Type u_1\ninst✝ : Ring R\nI : Ideal R\nx : R\n⊢ Iff (Membership.mem (TwoSidedIdeal.fromIdeal I) x) (Membership.mem (TwoSidedIdeal.span ↑I) x)","decl":"lemma mem_fromIdeal {I : Ideal R} {x : R} :\n    x ∈ fromIdeal I ↔ x ∈ span I := by simp [fromIdeal]\n\n"}
{"name":"TwoSidedIdeal.mem_asIdeal","module":"Mathlib.RingTheory.TwoSidedIdeal.Operations","initialProofState":"R : Type u_1\ninst✝ : Ring R\nI : TwoSidedIdeal R\nx : R\n⊢ Iff (Membership.mem (TwoSidedIdeal.asIdeal I) x) (Membership.mem I x)","decl":"@[simp]\nlemma mem_asIdeal {I : TwoSidedIdeal R} {x : R} :\n    x ∈ asIdeal I ↔ x ∈ I := by simp [asIdeal]\n\n"}
{"name":"TwoSidedIdeal.gc","module":"Mathlib.RingTheory.TwoSidedIdeal.Operations","initialProofState":"R : Type u_1\ninst✝ : Ring R\n⊢ GaloisConnection ⇑TwoSidedIdeal.fromIdeal ⇑TwoSidedIdeal.asIdeal","decl":"lemma gc : GaloisConnection fromIdeal (asIdeal (R := R)) :=\n  fun I J => ⟨fun h x hx ↦ h <| mem_span_iff.2 fun _ H ↦ H hx, fun h x hx ↦ by\n    simp only [fromIdeal, OrderHom.coe_mk, mem_span_iff] at hx\n    exact hx _ h⟩\n\n"}
{"name":"TwoSidedIdeal.coe_asIdeal","module":"Mathlib.RingTheory.TwoSidedIdeal.Operations","initialProofState":"R : Type u_1\ninst✝ : Ring R\nI : TwoSidedIdeal R\n⊢ Eq ↑(TwoSidedIdeal.asIdeal I) ↑I","decl":"@[simp]\nlemma coe_asIdeal {I : TwoSidedIdeal R} : (asIdeal I : Set R) = I := rfl\n\n"}
{"name":"TwoSidedIdeal.mem_asIdealOpposite","module":"Mathlib.RingTheory.TwoSidedIdeal.Operations","initialProofState":"R : Type u_1\ninst✝ : Ring R\nI : TwoSidedIdeal R\nx : MulOpposite R\n⊢ Iff (Membership.mem (TwoSidedIdeal.asIdealOpposite I) x) (Membership.mem I (MulOpposite.unop x))","decl":"lemma mem_asIdealOpposite {I : TwoSidedIdeal R} {x : Rᵐᵒᵖ} :\n    x ∈ asIdealOpposite I ↔ x.unop ∈ I := by\n  simpa [asIdealOpposite, asIdeal, TwoSidedIdeal.mem_iff, RingCon.op_iff] using\n    ⟨I.ringCon.symm, I.ringCon.symm⟩\n\n"}
{"name":"Ideal.mem_toTwoSided","module":"Mathlib.RingTheory.TwoSidedIdeal.Operations","initialProofState":"R : Type u_1\ninst✝ : Ring R\nI : Ideal R\nh : ∀ {x y : R}, Membership.mem I x → Membership.mem I (HMul.hMul x y)\nx : R\n⊢ Iff (Membership.mem (I.toTwoSided h) x) (Membership.mem I x)","decl":"@[simp]\nlemma mem_toTwoSided {I : Ideal R} {h} {x : R} :\n    x ∈ I.toTwoSided h ↔ x ∈ I := by\n  simp [toTwoSided]\n\n"}
{"name":"Ideal.coe_toTwoSided","module":"Mathlib.RingTheory.TwoSidedIdeal.Operations","initialProofState":"R : Type u_1\ninst✝ : Ring R\nI : Ideal R\nh : ∀ {x y : R}, Membership.mem I x → Membership.mem I (HMul.hMul x y)\n⊢ Eq ↑(I.toTwoSided h) ↑I","decl":"@[simp]\nlemma coe_toTwoSided (I : Ideal R) (h) : (I.toTwoSided h : Set R) = I := by\n  simp [toTwoSided]\n\n"}
{"name":"Ideal.toTwoSided_asIdeal","module":"Mathlib.RingTheory.TwoSidedIdeal.Operations","initialProofState":"R : Type u_1\ninst✝ : Ring R\nI : TwoSidedIdeal R\nh : ∀ {x y : R}, Membership.mem (TwoSidedIdeal.asIdeal I) x → Membership.mem (TwoSidedIdeal.asIdeal I) (HMul.hMul x y)\n⊢ Eq ((TwoSidedIdeal.asIdeal I).toTwoSided h) I","decl":"@[simp]\nlemma toTwoSided_asIdeal (I : TwoSidedIdeal R) (h) : (TwoSidedIdeal.asIdeal I).toTwoSided h = I :=\n  by ext; simp\n\n"}
{"name":"Ideal.asIdeal_toTwoSided","module":"Mathlib.RingTheory.TwoSidedIdeal.Operations","initialProofState":"R : Type u_1\ninst✝ : Ring R\nI : Ideal R\nh : ∀ {x y : R}, Membership.mem I x → Membership.mem I (HMul.hMul x y)\n⊢ Eq (TwoSidedIdeal.asIdeal (I.toTwoSided h)) I","decl":"@[simp]\nlemma asIdeal_toTwoSided (I : Ideal R) (h) : TwoSidedIdeal.asIdeal (I.toTwoSided h) = I := by\n  ext\n  simp\n\n"}
{"name":"Ideal.instCanLiftTwoSidedIdealCoeOrderHomAsIdealForallForallForallMemHMul","module":"Mathlib.RingTheory.TwoSidedIdeal.Operations","initialProofState":"R : Type u_1\ninst✝ : Ring R\n⊢ CanLift (Ideal R) (TwoSidedIdeal R) ⇑TwoSidedIdeal.asIdeal fun I => ∀ {x y : R}, Membership.mem I x → Membership.mem I (HMul.hMul x y)","decl":"instance : CanLift (Ideal R) (TwoSidedIdeal R) TwoSidedIdeal.asIdeal\n    (fun I => ∀ {x y}, x ∈ I → x * y ∈ I) where\n  prf I mul_mem_right := ⟨I.toTwoSided mul_mem_right, asIdeal_toTwoSided ..⟩\n\n"}
