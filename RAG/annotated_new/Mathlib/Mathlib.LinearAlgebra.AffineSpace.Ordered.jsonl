{"name":"lineMap_mono_left","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : OrderedRing k\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module k E\ninst✝ : OrderedSMul k E\na a' b : E\nr : k\nha : LE.le a a'\nhr : LE.le r 1\n⊢ LE.le ((AffineMap.lineMap a b) r) ((AffineMap.lineMap a' b) r)","decl":"theorem lineMap_mono_left (ha : a ≤ a') (hr : r ≤ 1) : lineMap a b r ≤ lineMap a' b r := by\n  simp only [lineMap_apply_module]\n  exact add_le_add_right (smul_le_smul_of_nonneg_left ha (sub_nonneg.2 hr)) _\n\n"}
{"name":"lineMap_strict_mono_left","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : OrderedRing k\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module k E\ninst✝ : OrderedSMul k E\na a' b : E\nr : k\nha : LT.lt a a'\nhr : LT.lt r 1\n⊢ LT.lt ((AffineMap.lineMap a b) r) ((AffineMap.lineMap a' b) r)","decl":"theorem lineMap_strict_mono_left (ha : a < a') (hr : r < 1) : lineMap a b r < lineMap a' b r := by\n  simp only [lineMap_apply_module]\n  exact add_lt_add_right (smul_lt_smul_of_pos_left ha (sub_pos.2 hr)) _\n\n"}
{"name":"lineMap_mono_right","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : OrderedRing k\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module k E\ninst✝ : OrderedSMul k E\na b b' : E\nr : k\nhb : LE.le b b'\nhr : LE.le 0 r\n⊢ LE.le ((AffineMap.lineMap a b) r) ((AffineMap.lineMap a b') r)","decl":"theorem lineMap_mono_right (hb : b ≤ b') (hr : 0 ≤ r) : lineMap a b r ≤ lineMap a b' r := by\n  simp only [lineMap_apply_module]\n  exact add_le_add_left (smul_le_smul_of_nonneg_left hb hr) _\n\n"}
{"name":"lineMap_strict_mono_right","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : OrderedRing k\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module k E\ninst✝ : OrderedSMul k E\na b b' : E\nr : k\nhb : LT.lt b b'\nhr : LT.lt 0 r\n⊢ LT.lt ((AffineMap.lineMap a b) r) ((AffineMap.lineMap a b') r)","decl":"theorem lineMap_strict_mono_right (hb : b < b') (hr : 0 < r) : lineMap a b r < lineMap a b' r := by\n  simp only [lineMap_apply_module]\n  exact add_lt_add_left (smul_lt_smul_of_pos_left hb hr) _\n\n"}
{"name":"lineMap_mono_endpoints","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : OrderedRing k\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module k E\ninst✝ : OrderedSMul k E\na a' b b' : E\nr : k\nha : LE.le a a'\nhb : LE.le b b'\nh₀ : LE.le 0 r\nh₁ : LE.le r 1\n⊢ LE.le ((AffineMap.lineMap a b) r) ((AffineMap.lineMap a' b') r)","decl":"theorem lineMap_mono_endpoints (ha : a ≤ a') (hb : b ≤ b') (h₀ : 0 ≤ r) (h₁ : r ≤ 1) :\n    lineMap a b r ≤ lineMap a' b' r :=\n  (lineMap_mono_left ha h₁).trans (lineMap_mono_right hb h₀)\n\n"}
{"name":"lineMap_strict_mono_endpoints","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : OrderedRing k\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module k E\ninst✝ : OrderedSMul k E\na a' b b' : E\nr : k\nha : LT.lt a a'\nhb : LT.lt b b'\nh₀ : LE.le 0 r\nh₁ : LE.le r 1\n⊢ LT.lt ((AffineMap.lineMap a b) r) ((AffineMap.lineMap a' b') r)","decl":"theorem lineMap_strict_mono_endpoints (ha : a < a') (hb : b < b') (h₀ : 0 ≤ r) (h₁ : r ≤ 1) :\n    lineMap a b r < lineMap a' b' r := by\n  rcases h₀.eq_or_lt with (rfl | h₀); · simpa\n  exact (lineMap_mono_left ha.le h₁).trans_lt (lineMap_strict_mono_right hb h₀)\n\n"}
{"name":"lineMap_lt_lineMap_iff_of_lt","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : OrderedRing k\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module k E\ninst✝ : OrderedSMul k E\na b : E\nr r' : k\nh : LT.lt r r'\n⊢ Iff (LT.lt ((AffineMap.lineMap a b) r) ((AffineMap.lineMap a b) r')) (LT.lt a b)","decl":"theorem lineMap_lt_lineMap_iff_of_lt (h : r < r') : lineMap a b r < lineMap a b r' ↔ a < b := by\n  simp only [lineMap_apply_module]\n  rw [← lt_sub_iff_add_lt, add_sub_assoc, ← sub_lt_iff_lt_add', ← sub_smul, ← sub_smul,\n    sub_sub_sub_cancel_left, smul_lt_smul_iff_of_pos_left (sub_pos.2 h)]\n\n"}
{"name":"left_lt_lineMap_iff_lt","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : OrderedRing k\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module k E\ninst✝ : OrderedSMul k E\na b : E\nr : k\nh : LT.lt 0 r\n⊢ Iff (LT.lt a ((AffineMap.lineMap a b) r)) (LT.lt a b)","decl":"theorem left_lt_lineMap_iff_lt (h : 0 < r) : a < lineMap a b r ↔ a < b :=\n  Iff.trans (by rw [lineMap_apply_zero]) (lineMap_lt_lineMap_iff_of_lt h)\n\n"}
{"name":"lineMap_lt_left_iff_lt","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : OrderedRing k\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module k E\ninst✝ : OrderedSMul k E\na b : E\nr : k\nh : LT.lt 0 r\n⊢ Iff (LT.lt ((AffineMap.lineMap a b) r) a) (LT.lt b a)","decl":"theorem lineMap_lt_left_iff_lt (h : 0 < r) : lineMap a b r < a ↔ b < a :=\n  left_lt_lineMap_iff_lt (E := Eᵒᵈ) h\n\n"}
{"name":"lineMap_lt_right_iff_lt","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : OrderedRing k\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module k E\ninst✝ : OrderedSMul k E\na b : E\nr : k\nh : LT.lt r 1\n⊢ Iff (LT.lt ((AffineMap.lineMap a b) r) b) (LT.lt a b)","decl":"theorem lineMap_lt_right_iff_lt (h : r < 1) : lineMap a b r < b ↔ a < b :=\n  Iff.trans (by rw [lineMap_apply_one]) (lineMap_lt_lineMap_iff_of_lt h)\n\n"}
{"name":"right_lt_lineMap_iff_lt","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : OrderedRing k\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module k E\ninst✝ : OrderedSMul k E\na b : E\nr : k\nh : LT.lt r 1\n⊢ Iff (LT.lt b ((AffineMap.lineMap a b) r)) (LT.lt b a)","decl":"theorem right_lt_lineMap_iff_lt (h : r < 1) : b < lineMap a b r ↔ b < a :=\n  lineMap_lt_right_iff_lt (E := Eᵒᵈ) h\n\n"}
{"name":"midpoint_le_midpoint","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝⁴ : LinearOrderedRing k\ninst✝³ : OrderedAddCommGroup E\ninst✝² : Module k E\ninst✝¹ : OrderedSMul k E\ninst✝ : Invertible 2\na a' b b' : E\nha : LE.le a a'\nhb : LE.le b b'\n⊢ LE.le (midpoint k a b) (midpoint k a' b')","decl":"theorem midpoint_le_midpoint (ha : a ≤ a') (hb : b ≤ b') : midpoint k a b ≤ midpoint k a' b' :=\n  lineMap_mono_endpoints ha hb (invOf_nonneg.2 zero_le_two) <| invOf_le_one one_le_two\n\n"}
{"name":"lineMap_le_lineMap_iff_of_lt","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : LinearOrderedField k\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module k E\ninst✝ : OrderedSMul k E\na b : E\nr r' : k\nh : LT.lt r r'\n⊢ Iff (LE.le ((AffineMap.lineMap a b) r) ((AffineMap.lineMap a b) r')) (LE.le a b)","decl":"theorem lineMap_le_lineMap_iff_of_lt (h : r < r') : lineMap a b r ≤ lineMap a b r' ↔ a ≤ b := by\n  simp only [lineMap_apply_module]\n  rw [← le_sub_iff_add_le, add_sub_assoc, ← sub_le_iff_le_add', ← sub_smul, ← sub_smul,\n    sub_sub_sub_cancel_left, smul_le_smul_iff_of_pos_left (sub_pos.2 h)]\n\n"}
{"name":"left_le_lineMap_iff_le","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : LinearOrderedField k\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module k E\ninst✝ : OrderedSMul k E\na b : E\nr : k\nh : LT.lt 0 r\n⊢ Iff (LE.le a ((AffineMap.lineMap a b) r)) (LE.le a b)","decl":"theorem left_le_lineMap_iff_le (h : 0 < r) : a ≤ lineMap a b r ↔ a ≤ b :=\n  Iff.trans (by rw [lineMap_apply_zero]) (lineMap_le_lineMap_iff_of_lt h)\n\n"}
{"name":"left_le_midpoint","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : LinearOrderedField k\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module k E\ninst✝ : OrderedSMul k E\na b : E\n⊢ Iff (LE.le a (midpoint k a b)) (LE.le a b)","decl":"@[simp]\ntheorem left_le_midpoint : a ≤ midpoint k a b ↔ a ≤ b :=\n  left_le_lineMap_iff_le <| inv_pos.2 zero_lt_two\n\n"}
{"name":"lineMap_le_left_iff_le","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : LinearOrderedField k\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module k E\ninst✝ : OrderedSMul k E\na b : E\nr : k\nh : LT.lt 0 r\n⊢ Iff (LE.le ((AffineMap.lineMap a b) r) a) (LE.le b a)","decl":"theorem lineMap_le_left_iff_le (h : 0 < r) : lineMap a b r ≤ a ↔ b ≤ a :=\n  left_le_lineMap_iff_le (E := Eᵒᵈ) h\n\n"}
{"name":"midpoint_le_left","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : LinearOrderedField k\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module k E\ninst✝ : OrderedSMul k E\na b : E\n⊢ Iff (LE.le (midpoint k a b) a) (LE.le b a)","decl":"@[simp]\ntheorem midpoint_le_left : midpoint k a b ≤ a ↔ b ≤ a :=\n  lineMap_le_left_iff_le <| inv_pos.2 zero_lt_two\n\n"}
{"name":"lineMap_le_right_iff_le","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : LinearOrderedField k\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module k E\ninst✝ : OrderedSMul k E\na b : E\nr : k\nh : LT.lt r 1\n⊢ Iff (LE.le ((AffineMap.lineMap a b) r) b) (LE.le a b)","decl":"theorem lineMap_le_right_iff_le (h : r < 1) : lineMap a b r ≤ b ↔ a ≤ b :=\n  Iff.trans (by rw [lineMap_apply_one]) (lineMap_le_lineMap_iff_of_lt h)\n\n"}
{"name":"midpoint_le_right","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : LinearOrderedField k\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module k E\ninst✝ : OrderedSMul k E\na b : E\n⊢ Iff (LE.le (midpoint k a b) b) (LE.le a b)","decl":"@[simp]\ntheorem midpoint_le_right : midpoint k a b ≤ b ↔ a ≤ b := lineMap_le_right_iff_le two_inv_lt_one\n\n"}
{"name":"right_le_lineMap_iff_le","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : LinearOrderedField k\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module k E\ninst✝ : OrderedSMul k E\na b : E\nr : k\nh : LT.lt r 1\n⊢ Iff (LE.le b ((AffineMap.lineMap a b) r)) (LE.le b a)","decl":"theorem right_le_lineMap_iff_le (h : r < 1) : b ≤ lineMap a b r ↔ b ≤ a :=\n  lineMap_le_right_iff_le (E := Eᵒᵈ) h\n\n"}
{"name":"right_le_midpoint","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : LinearOrderedField k\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module k E\ninst✝ : OrderedSMul k E\na b : E\n⊢ Iff (LE.le b (midpoint k a b)) (LE.le b a)","decl":"@[simp]\ntheorem right_le_midpoint : b ≤ midpoint k a b ↔ b ≤ a := right_le_lineMap_iff_le two_inv_lt_one\n\n"}
{"name":"map_le_lineMap_iff_slope_le_slope_left","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : LinearOrderedField k\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module k E\ninst✝ : OrderedSMul k E\nf : k → E\na b r : k\nh : LT.lt 0 (HMul.hMul r (HSub.hSub b a))\n⊢ Iff (LE.le (f ((AffineMap.lineMap a b) r)) ((AffineMap.lineMap (f a) (f b)) r)) (LE.le (slope f a ((AffineMap.lineMap a b) r)) (slope f a b))","decl":"/-- Given `c = lineMap a b r`, `a < c`, the point `(c, f c)` is non-strictly below the\nsegment `[(a, f a), (b, f b)]` if and only if `slope f a c ≤ slope f a b`. -/\ntheorem map_le_lineMap_iff_slope_le_slope_left (h : 0 < r * (b - a)) :\n    f c ≤ lineMap (f a) (f b) r ↔ slope f a c ≤ slope f a b := by\n  rw [lineMap_apply, lineMap_apply, slope, slope, vsub_eq_sub, vsub_eq_sub, vsub_eq_sub,\n    vadd_eq_add, vadd_eq_add, smul_eq_mul, add_sub_cancel_right, smul_sub, smul_sub, smul_sub,\n    sub_le_iff_le_add, mul_inv_rev, mul_smul, mul_smul, ← smul_sub, ← smul_sub, ← smul_add,\n    smul_smul, ← mul_inv_rev, inv_smul_le_iff_of_pos h, smul_smul,\n    mul_inv_cancel_right₀ (right_ne_zero_of_mul h.ne'), smul_add,\n    smul_inv_smul₀ (left_ne_zero_of_mul h.ne')]\n\n"}
{"name":"lineMap_le_map_iff_slope_le_slope_left","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : LinearOrderedField k\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module k E\ninst✝ : OrderedSMul k E\nf : k → E\na b r : k\nh : LT.lt 0 (HMul.hMul r (HSub.hSub b a))\n⊢ Iff (LE.le ((AffineMap.lineMap (f a) (f b)) r) (f ((AffineMap.lineMap a b) r))) (LE.le (slope f a b) (slope f a ((AffineMap.lineMap a b) r)))","decl":"/-- Given `c = lineMap a b r`, `a < c`, the point `(c, f c)` is non-strictly above the\nsegment `[(a, f a), (b, f b)]` if and only if `slope f a b ≤ slope f a c`. -/\ntheorem lineMap_le_map_iff_slope_le_slope_left (h : 0 < r * (b - a)) :\n    lineMap (f a) (f b) r ≤ f c ↔ slope f a b ≤ slope f a c :=\n  map_le_lineMap_iff_slope_le_slope_left (E := Eᵒᵈ) (f := f) (a := a) (b := b) (r := r) h\n\n"}
{"name":"map_lt_lineMap_iff_slope_lt_slope_left","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : LinearOrderedField k\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module k E\ninst✝ : OrderedSMul k E\nf : k → E\na b r : k\nh : LT.lt 0 (HMul.hMul r (HSub.hSub b a))\n⊢ Iff (LT.lt (f ((AffineMap.lineMap a b) r)) ((AffineMap.lineMap (f a) (f b)) r)) (LT.lt (slope f a ((AffineMap.lineMap a b) r)) (slope f a b))","decl":"/-- Given `c = lineMap a b r`, `a < c`, the point `(c, f c)` is strictly below the\nsegment `[(a, f a), (b, f b)]` if and only if `slope f a c < slope f a b`. -/\ntheorem map_lt_lineMap_iff_slope_lt_slope_left (h : 0 < r * (b - a)) :\n    f c < lineMap (f a) (f b) r ↔ slope f a c < slope f a b :=\n  lt_iff_lt_of_le_iff_le' (lineMap_le_map_iff_slope_le_slope_left h)\n    (map_le_lineMap_iff_slope_le_slope_left h)\n\n"}
{"name":"lineMap_lt_map_iff_slope_lt_slope_left","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : LinearOrderedField k\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module k E\ninst✝ : OrderedSMul k E\nf : k → E\na b r : k\nh : LT.lt 0 (HMul.hMul r (HSub.hSub b a))\n⊢ Iff (LT.lt ((AffineMap.lineMap (f a) (f b)) r) (f ((AffineMap.lineMap a b) r))) (LT.lt (slope f a b) (slope f a ((AffineMap.lineMap a b) r)))","decl":"/-- Given `c = lineMap a b r`, `a < c`, the point `(c, f c)` is strictly above the\nsegment `[(a, f a), (b, f b)]` if and only if `slope f a b < slope f a c`. -/\ntheorem lineMap_lt_map_iff_slope_lt_slope_left (h : 0 < r * (b - a)) :\n    lineMap (f a) (f b) r < f c ↔ slope f a b < slope f a c :=\n  map_lt_lineMap_iff_slope_lt_slope_left (E := Eᵒᵈ) (f := f) (a := a) (b := b) (r := r) h\n\n"}
{"name":"map_le_lineMap_iff_slope_le_slope_right","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : LinearOrderedField k\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module k E\ninst✝ : OrderedSMul k E\nf : k → E\na b r : k\nh : LT.lt 0 (HMul.hMul (HSub.hSub 1 r) (HSub.hSub b a))\n⊢ Iff (LE.le (f ((AffineMap.lineMap a b) r)) ((AffineMap.lineMap (f a) (f b)) r)) (LE.le (slope f a b) (slope f ((AffineMap.lineMap a b) r) b))","decl":"/-- Given `c = lineMap a b r`, `c < b`, the point `(c, f c)` is non-strictly below the\nsegment `[(a, f a), (b, f b)]` if and only if `slope f a b ≤ slope f c b`. -/\ntheorem map_le_lineMap_iff_slope_le_slope_right (h : 0 < (1 - r) * (b - a)) :\n    f c ≤ lineMap (f a) (f b) r ↔ slope f a b ≤ slope f c b := by\n  rw [← lineMap_apply_one_sub, ← lineMap_apply_one_sub _ _ r]\n  revert h; generalize 1 - r = r'; clear! r; intro h\n  simp_rw [lineMap_apply, slope, vsub_eq_sub, vadd_eq_add, smul_eq_mul]\n  rw [sub_add_eq_sub_sub_swap, sub_self, zero_sub, neg_mul_eq_mul_neg, neg_sub,\n    le_inv_smul_iff_of_pos h, smul_smul, mul_inv_cancel_right₀, le_sub_comm, ← neg_sub (f b),\n    smul_neg, neg_add_eq_sub]\n  · exact right_ne_zero_of_mul h.ne'\n\n"}
{"name":"lineMap_le_map_iff_slope_le_slope_right","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : LinearOrderedField k\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module k E\ninst✝ : OrderedSMul k E\nf : k → E\na b r : k\nh : LT.lt 0 (HMul.hMul (HSub.hSub 1 r) (HSub.hSub b a))\n⊢ Iff (LE.le ((AffineMap.lineMap (f a) (f b)) r) (f ((AffineMap.lineMap a b) r))) (LE.le (slope f ((AffineMap.lineMap a b) r) b) (slope f a b))","decl":"/-- Given `c = lineMap a b r`, `c < b`, the point `(c, f c)` is non-strictly above the\nsegment `[(a, f a), (b, f b)]` if and only if `slope f c b ≤ slope f a b`. -/\ntheorem lineMap_le_map_iff_slope_le_slope_right (h : 0 < (1 - r) * (b - a)) :\n    lineMap (f a) (f b) r ≤ f c ↔ slope f c b ≤ slope f a b :=\n  map_le_lineMap_iff_slope_le_slope_right (E := Eᵒᵈ) (f := f) (a := a) (b := b) (r := r) h\n\n"}
{"name":"map_lt_lineMap_iff_slope_lt_slope_right","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : LinearOrderedField k\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module k E\ninst✝ : OrderedSMul k E\nf : k → E\na b r : k\nh : LT.lt 0 (HMul.hMul (HSub.hSub 1 r) (HSub.hSub b a))\n⊢ Iff (LT.lt (f ((AffineMap.lineMap a b) r)) ((AffineMap.lineMap (f a) (f b)) r)) (LT.lt (slope f a b) (slope f ((AffineMap.lineMap a b) r) b))","decl":"/-- Given `c = lineMap a b r`, `c < b`, the point `(c, f c)` is strictly below the\nsegment `[(a, f a), (b, f b)]` if and only if `slope f a b < slope f c b`. -/\ntheorem map_lt_lineMap_iff_slope_lt_slope_right (h : 0 < (1 - r) * (b - a)) :\n    f c < lineMap (f a) (f b) r ↔ slope f a b < slope f c b :=\n  lt_iff_lt_of_le_iff_le' (lineMap_le_map_iff_slope_le_slope_right h)\n    (map_le_lineMap_iff_slope_le_slope_right h)\n\n"}
{"name":"lineMap_lt_map_iff_slope_lt_slope_right","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : LinearOrderedField k\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module k E\ninst✝ : OrderedSMul k E\nf : k → E\na b r : k\nh : LT.lt 0 (HMul.hMul (HSub.hSub 1 r) (HSub.hSub b a))\n⊢ Iff (LT.lt ((AffineMap.lineMap (f a) (f b)) r) (f ((AffineMap.lineMap a b) r))) (LT.lt (slope f ((AffineMap.lineMap a b) r) b) (slope f a b))","decl":"/-- Given `c = lineMap a b r`, `c < b`, the point `(c, f c)` is strictly above the\nsegment `[(a, f a), (b, f b)]` if and only if `slope f c b < slope f a b`. -/\ntheorem lineMap_lt_map_iff_slope_lt_slope_right (h : 0 < (1 - r) * (b - a)) :\n    lineMap (f a) (f b) r < f c ↔ slope f c b < slope f a b :=\n  map_lt_lineMap_iff_slope_lt_slope_right (E := Eᵒᵈ) (f := f) (a := a) (b := b) (r := r) h\n\n"}
{"name":"map_le_lineMap_iff_slope_le_slope","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : LinearOrderedField k\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module k E\ninst✝ : OrderedSMul k E\nf : k → E\na b r : k\nhab : LT.lt a b\nh₀ : LT.lt 0 r\nh₁ : LT.lt r 1\n⊢ Iff (LE.le (f ((AffineMap.lineMap a b) r)) ((AffineMap.lineMap (f a) (f b)) r)) (LE.le (slope f a ((AffineMap.lineMap a b) r)) (slope f ((AffineMap.lineMap a b) r) b))","decl":"/-- Given `c = lineMap a b r`, `a < c < b`, the point `(c, f c)` is non-strictly below the\nsegment `[(a, f a), (b, f b)]` if and only if `slope f a c ≤ slope f c b`. -/\ntheorem map_le_lineMap_iff_slope_le_slope (hab : a < b) (h₀ : 0 < r) (h₁ : r < 1) :\n    f c ≤ lineMap (f a) (f b) r ↔ slope f a c ≤ slope f c b := by\n  rw [map_le_lineMap_iff_slope_le_slope_left (mul_pos h₀ (sub_pos.2 hab)), ←\n    lineMap_slope_lineMap_slope_lineMap f a b r, right_le_lineMap_iff_le h₁]\n\n"}
{"name":"lineMap_le_map_iff_slope_le_slope","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : LinearOrderedField k\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module k E\ninst✝ : OrderedSMul k E\nf : k → E\na b r : k\nhab : LT.lt a b\nh₀ : LT.lt 0 r\nh₁ : LT.lt r 1\n⊢ Iff (LE.le ((AffineMap.lineMap (f a) (f b)) r) (f ((AffineMap.lineMap a b) r))) (LE.le (slope f ((AffineMap.lineMap a b) r) b) (slope f a ((AffineMap.lineMap a b) r)))","decl":"/-- Given `c = lineMap a b r`, `a < c < b`, the point `(c, f c)` is non-strictly above the\nsegment `[(a, f a), (b, f b)]` if and only if `slope f c b ≤ slope f a c`. -/\ntheorem lineMap_le_map_iff_slope_le_slope (hab : a < b) (h₀ : 0 < r) (h₁ : r < 1) :\n    lineMap (f a) (f b) r ≤ f c ↔ slope f c b ≤ slope f a c :=\n  map_le_lineMap_iff_slope_le_slope (E := Eᵒᵈ) hab h₀ h₁\n\n"}
{"name":"map_lt_lineMap_iff_slope_lt_slope","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : LinearOrderedField k\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module k E\ninst✝ : OrderedSMul k E\nf : k → E\na b r : k\nhab : LT.lt a b\nh₀ : LT.lt 0 r\nh₁ : LT.lt r 1\n⊢ Iff (LT.lt (f ((AffineMap.lineMap a b) r)) ((AffineMap.lineMap (f a) (f b)) r)) (LT.lt (slope f a ((AffineMap.lineMap a b) r)) (slope f ((AffineMap.lineMap a b) r) b))","decl":"/-- Given `c = lineMap a b r`, `a < c < b`, the point `(c, f c)` is strictly below the\nsegment `[(a, f a), (b, f b)]` if and only if `slope f a c < slope f c b`. -/\ntheorem map_lt_lineMap_iff_slope_lt_slope (hab : a < b) (h₀ : 0 < r) (h₁ : r < 1) :\n    f c < lineMap (f a) (f b) r ↔ slope f a c < slope f c b :=\n  lt_iff_lt_of_le_iff_le' (lineMap_le_map_iff_slope_le_slope hab h₀ h₁)\n    (map_le_lineMap_iff_slope_le_slope hab h₀ h₁)\n\n"}
{"name":"lineMap_lt_map_iff_slope_lt_slope","module":"Mathlib.LinearAlgebra.AffineSpace.Ordered","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : LinearOrderedField k\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module k E\ninst✝ : OrderedSMul k E\nf : k → E\na b r : k\nhab : LT.lt a b\nh₀ : LT.lt 0 r\nh₁ : LT.lt r 1\n⊢ Iff (LT.lt ((AffineMap.lineMap (f a) (f b)) r) (f ((AffineMap.lineMap a b) r))) (LT.lt (slope f ((AffineMap.lineMap a b) r) b) (slope f a ((AffineMap.lineMap a b) r)))","decl":"/-- Given `c = lineMap a b r`, `a < c < b`, the point `(c, f c)` is strictly above the\nsegment `[(a, f a), (b, f b)]` if and only if `slope f c b < slope f a c`. -/\ntheorem lineMap_lt_map_iff_slope_lt_slope (hab : a < b) (h₀ : 0 < r) (h₁ : r < 1) :\n    lineMap (f a) (f b) r < f c ↔ slope f c b < slope f a c :=\n  map_lt_lineMap_iff_slope_lt_slope (E := Eᵒᵈ) hab h₀ h₁\n\n"}
