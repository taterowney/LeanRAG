{"name":"intervalIntegrable_iff","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nâŠ¢ Iff (IntervalIntegrable f Î¼ a b) (MeasureTheory.IntegrableOn f (Set.uIoc a b) Î¼)","decl":"/-- A function is interval integrable with respect to a given measure `Î¼` on `a..b` if and\n  only if it is integrable on `uIoc a b` with respect to `Î¼`. This is an equivalent\n  definition of `IntervalIntegrable`. -/\ntheorem intervalIntegrable_iff : IntervalIntegrable f Î¼ a b â†” IntegrableOn f (Î™ a b) Î¼ := by\n  rw [uIoc_eq_union, integrableOn_union, IntervalIntegrable]\n\n"}
{"name":"IntervalIntegrable.def'","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nh : IntervalIntegrable f Î¼ a b\nâŠ¢ MeasureTheory.IntegrableOn f (Set.uIoc a b) Î¼","decl":"/-- If a function is interval integrable with respect to a given measure `Î¼` on `a..b` then\n  it is integrable on `uIoc a b` with respect to `Î¼`. -/\ntheorem IntervalIntegrable.def' (h : IntervalIntegrable f Î¼ a b) : IntegrableOn f (Î™ a b) Î¼ :=\n  intervalIntegrable_iff.mp h\n\n"}
{"name":"IntervalIntegrable.congr","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\ng : Real â†’ E\nhf : IntervalIntegrable f Î¼ a b\nh : (MeasureTheory.ae (Î¼.restrict (Set.uIoc a b))).EventuallyEq f g\nâŠ¢ IntervalIntegrable g Î¼ a b","decl":"theorem IntervalIntegrable.congr {g : â„ â†’ E} (hf : IntervalIntegrable f Î¼ a b)\n    (h : f =áµ[Î¼.restrict (Î™ a b)] g) :\n    IntervalIntegrable g Î¼ a b := by\n  rwa [intervalIntegrable_iff, â† integrableOn_congr_fun_ae h, â† intervalIntegrable_iff]\n\n"}
{"name":"intervalIntegrable_iff_integrableOn_Ioc_of_le","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nhab : LE.le a b\nâŠ¢ Iff (IntervalIntegrable f Î¼ a b) (MeasureTheory.IntegrableOn f (Set.Ioc a b) Î¼)","decl":"theorem intervalIntegrable_iff_integrableOn_Ioc_of_le (hab : a â‰¤ b) :\n    IntervalIntegrable f Î¼ a b â†” IntegrableOn f (Ioc a b) Î¼ := by\n  rw [intervalIntegrable_iff, uIoc_of_le hab]\n\n"}
{"name":"intervalIntegrable_iff'","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\nf : Real â†’ E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\ninstâœ : MeasureTheory.NoAtoms Î¼\nâŠ¢ Iff (IntervalIntegrable f Î¼ a b) (MeasureTheory.IntegrableOn f (Set.uIcc a b) Î¼)","decl":"theorem intervalIntegrable_iff' [NoAtoms Î¼] :\n    IntervalIntegrable f Î¼ a b â†” IntegrableOn f (uIcc a b) Î¼ := by\n  rw [intervalIntegrable_iff, â† Icc_min_max, uIoc, integrableOn_Icc_iff_integrableOn_Ioc]\n\n"}
{"name":"intervalIntegrable_iff_integrableOn_Icc_of_le","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\nf : Real â†’ E\na b : Real\nhab : LE.le a b\nÎ¼ : MeasureTheory.Measure Real\ninstâœ : MeasureTheory.NoAtoms Î¼\nâŠ¢ Iff (IntervalIntegrable f Î¼ a b) (MeasureTheory.IntegrableOn f (Set.Icc a b) Î¼)","decl":"theorem intervalIntegrable_iff_integrableOn_Icc_of_le {f : â„ â†’ E} {a b : â„} (hab : a â‰¤ b)\n    {Î¼ : Measure â„} [NoAtoms Î¼] : IntervalIntegrable f Î¼ a b â†” IntegrableOn f (Icc a b) Î¼ := by\n  rw [intervalIntegrable_iff_integrableOn_Ioc_of_le hab, integrableOn_Icc_iff_integrableOn_Ioc]\n\n"}
{"name":"intervalIntegrable_iff_integrableOn_Ico_of_le","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\nf : Real â†’ E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\ninstâœ : MeasureTheory.NoAtoms Î¼\nhab : LE.le a b\nâŠ¢ Iff (IntervalIntegrable f Î¼ a b) (MeasureTheory.IntegrableOn f (Set.Ico a b) Î¼)","decl":"theorem intervalIntegrable_iff_integrableOn_Ico_of_le [NoAtoms Î¼] (hab : a â‰¤ b) :\n    IntervalIntegrable f Î¼ a b â†” IntegrableOn f (Ico a b) Î¼ := by\n  rw [intervalIntegrable_iff_integrableOn_Icc_of_le hab, integrableOn_Icc_iff_integrableOn_Ico]\n\n"}
{"name":"intervalIntegrable_iff_integrableOn_Ioo_of_le","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\nf : Real â†’ E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\ninstâœ : MeasureTheory.NoAtoms Î¼\nhab : LE.le a b\nâŠ¢ Iff (IntervalIntegrable f Î¼ a b) (MeasureTheory.IntegrableOn f (Set.Ioo a b) Î¼)","decl":"theorem intervalIntegrable_iff_integrableOn_Ioo_of_le [NoAtoms Î¼] (hab : a â‰¤ b) :\n    IntervalIntegrable f Î¼ a b â†” IntegrableOn f (Ioo a b) Î¼ := by\n  rw [intervalIntegrable_iff_integrableOn_Icc_of_le hab, integrableOn_Icc_iff_integrableOn_Ioo]\n\n"}
{"name":"MeasureTheory.Integrable.intervalIntegrable","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ IntervalIntegrable f Î¼ a b","decl":"/-- If a function is integrable with respect to a given measure `Î¼` then it is interval integrable\n  with respect to `Î¼` on `uIcc a b`. -/\ntheorem MeasureTheory.Integrable.intervalIntegrable (hf : Integrable f Î¼) :\n    IntervalIntegrable f Î¼ a b :=\n  âŸ¨hf.integrableOn, hf.integrableOnâŸ©\n\n"}
{"name":"MeasureTheory.IntegrableOn.intervalIntegrable","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nhf : MeasureTheory.IntegrableOn f (Set.uIcc a b) Î¼\nâŠ¢ IntervalIntegrable f Î¼ a b","decl":"theorem MeasureTheory.IntegrableOn.intervalIntegrable (hf : IntegrableOn f [[a, b]] Î¼) :\n    IntervalIntegrable f Î¼ a b :=\n  âŸ¨MeasureTheory.IntegrableOn.mono_set hf (Ioc_subset_Icc_self.trans Icc_subset_uIcc),\n    MeasureTheory.IntegrableOn.mono_set hf (Ioc_subset_Icc_self.trans Icc_subset_uIcc')âŸ©\n\n"}
{"name":"intervalIntegrable_const_iff","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nc : E\nâŠ¢ Iff (IntervalIntegrable (fun x => c) Î¼ a b) (Or (Eq c 0) (LT.lt (Î¼ (Set.uIoc a b)) Top.top))","decl":"theorem intervalIntegrable_const_iff {c : E} :\n    IntervalIntegrable (fun _ => c) Î¼ a b â†” c = 0 âˆ¨ Î¼ (Î™ a b) < âˆ := by\n  simp only [intervalIntegrable_iff, integrableOn_const]\n\n"}
{"name":"intervalIntegrable_const","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nc : E\nâŠ¢ IntervalIntegrable (fun x => c) Î¼ a b","decl":"@[simp]\ntheorem intervalIntegrable_const [IsLocallyFiniteMeasure Î¼] {c : E} :\n    IntervalIntegrable (fun _ => c) Î¼ a b :=\n  intervalIntegrable_const_iff.2 <| Or.inr measure_Ioc_lt_top\n\n"}
{"name":"IntervalIntegrable.symm","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nh : IntervalIntegrable f Î¼ a b\nâŠ¢ IntervalIntegrable f Î¼ b a","decl":"@[symm]\nnonrec theorem symm (h : IntervalIntegrable f Î¼ a b) : IntervalIntegrable f Î¼ b a :=\n  h.symm\n\n"}
{"name":"IntervalIntegrable.refl","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\na : Real\nÎ¼ : MeasureTheory.Measure Real\nâŠ¢ IntervalIntegrable f Î¼ a a","decl":"@[refl, simp] -- Porting note: added `simp`\ntheorem refl : IntervalIntegrable f Î¼ a a := by constructor <;> simp\n\n"}
{"name":"IntervalIntegrable.trans","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\na b c : Real\nhab : IntervalIntegrable f Î¼ a b\nhbc : IntervalIntegrable f Î¼ b c\nâŠ¢ IntervalIntegrable f Î¼ a c","decl":"@[trans]\ntheorem trans {a b c : â„} (hab : IntervalIntegrable f Î¼ a b) (hbc : IntervalIntegrable f Î¼ b c) :\n    IntervalIntegrable f Î¼ a c :=\n  âŸ¨(hab.1.union hbc.1).mono_set Ioc_subset_Ioc_union_Ioc,\n    (hbc.2.union hab.2).mono_set Ioc_subset_Ioc_union_IocâŸ©\n\n"}
{"name":"IntervalIntegrable.trans_iterate_Ico","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\na : Nat â†’ Real\nm n : Nat\nhmn : LE.le m n\nhint : âˆ€ (k : Nat), Membership.mem (Set.Ico m n) k â†’ IntervalIntegrable f Î¼ (a k) (a (HAdd.hAdd k 1))\nâŠ¢ IntervalIntegrable f Î¼ (a m) (a n)","decl":"theorem trans_iterate_Ico {a : â„• â†’ â„} {m n : â„•} (hmn : m â‰¤ n)\n    (hint : âˆ€ k âˆˆ Ico m n, IntervalIntegrable f Î¼ (a k) (a <| k + 1)) :\n    IntervalIntegrable f Î¼ (a m) (a n) := by\n  revert hint\n  refine Nat.le_induction ?_ ?_ n hmn\n  Â· simp\n  Â· intro p hp IH h\n    exact (IH fun k hk => h k (Ico_subset_Ico_right p.le_succ hk)).trans (h p (by simp [hp]))\n\n"}
{"name":"IntervalIntegrable.trans_iterate","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\na : Nat â†’ Real\nn : Nat\nhint : âˆ€ (k : Nat), LT.lt k n â†’ IntervalIntegrable f Î¼ (a k) (a (HAdd.hAdd k 1))\nâŠ¢ IntervalIntegrable f Î¼ (a 0) (a n)","decl":"theorem trans_iterate {a : â„• â†’ â„} {n : â„•}\n    (hint : âˆ€ k < n, IntervalIntegrable f Î¼ (a k) (a <| k + 1)) :\n    IntervalIntegrable f Î¼ (a 0) (a n) :=\n  trans_iterate_Ico bot_le fun k hk => hint k hk.2\n\n"}
{"name":"IntervalIntegrable.neg","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nh : IntervalIntegrable f Î¼ a b\nâŠ¢ IntervalIntegrable (Neg.neg f) Î¼ a b","decl":"theorem neg (h : IntervalIntegrable f Î¼ a b) : IntervalIntegrable (-f) Î¼ a b :=\n  âŸ¨h.1.neg, h.2.negâŸ©\n\n"}
{"name":"IntervalIntegrable.norm","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nh : IntervalIntegrable f Î¼ a b\nâŠ¢ IntervalIntegrable (fun x => Norm.norm (f x)) Î¼ a b","decl":"theorem norm (h : IntervalIntegrable f Î¼ a b) : IntervalIntegrable (fun x => â€–f xâ€–) Î¼ a b :=\n  âŸ¨h.1.norm, h.2.normâŸ©\n\n"}
{"name":"IntervalIntegrable.intervalIntegrable_norm_iff","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\na b : Real\nhf : MeasureTheory.AEStronglyMeasurable f (Î¼.restrict (Set.uIoc a b))\nâŠ¢ Iff (IntervalIntegrable (fun t => Norm.norm (f t)) Î¼ a b) (IntervalIntegrable f Î¼ a b)","decl":"theorem intervalIntegrable_norm_iff {f : â„ â†’ E} {Î¼ : Measure â„} {a b : â„}\n    (hf : AEStronglyMeasurable f (Î¼.restrict (Î™ a b))) :\n    IntervalIntegrable (fun t => â€–f tâ€–) Î¼ a b â†” IntervalIntegrable f Î¼ a b := by\n  simp_rw [intervalIntegrable_iff, IntegrableOn]; exact integrable_norm_iff hf\n\n"}
{"name":"IntervalIntegrable.abs","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"a b : Real\nÎ¼ : MeasureTheory.Measure Real\nf : Real â†’ Real\nh : IntervalIntegrable f Î¼ a b\nâŠ¢ IntervalIntegrable (fun x => abs (f x)) Î¼ a b","decl":"theorem abs {f : â„ â†’ â„} (h : IntervalIntegrable f Î¼ a b) :\n    IntervalIntegrable (fun x => |f x|) Î¼ a b :=\n  h.norm\n\n"}
{"name":"IntervalIntegrable.mono","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\na b c d : Real\nÎ¼ Î½ : MeasureTheory.Measure Real\nhf : IntervalIntegrable f Î½ a b\nh1 : HasSubset.Subset (Set.uIcc c d) (Set.uIcc a b)\nh2 : LE.le Î¼ Î½\nâŠ¢ IntervalIntegrable f Î¼ c d","decl":"theorem mono (hf : IntervalIntegrable f Î½ a b) (h1 : [[c, d]] âŠ† [[a, b]]) (h2 : Î¼ â‰¤ Î½) :\n    IntervalIntegrable f Î¼ c d :=\n  intervalIntegrable_iff.mpr <| hf.def'.mono (uIoc_subset_uIoc_of_uIcc_subset_uIcc h1) h2\n\n"}
{"name":"IntervalIntegrable.mono_measure","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\na b : Real\nÎ¼ Î½ : MeasureTheory.Measure Real\nhf : IntervalIntegrable f Î½ a b\nh : LE.le Î¼ Î½\nâŠ¢ IntervalIntegrable f Î¼ a b","decl":"theorem mono_measure (hf : IntervalIntegrable f Î½ a b) (h : Î¼ â‰¤ Î½) : IntervalIntegrable f Î¼ a b :=\n  hf.mono Subset.rfl h\n\n"}
{"name":"IntervalIntegrable.mono_set","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\na b c d : Real\nÎ¼ : MeasureTheory.Measure Real\nhf : IntervalIntegrable f Î¼ a b\nh : HasSubset.Subset (Set.uIcc c d) (Set.uIcc a b)\nâŠ¢ IntervalIntegrable f Î¼ c d","decl":"theorem mono_set (hf : IntervalIntegrable f Î¼ a b) (h : [[c, d]] âŠ† [[a, b]]) :\n    IntervalIntegrable f Î¼ c d :=\n  hf.mono h le_rfl\n\n"}
{"name":"IntervalIntegrable.mono_set_ae","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\na b c d : Real\nÎ¼ : MeasureTheory.Measure Real\nhf : IntervalIntegrable f Î¼ a b\nh : (MeasureTheory.ae Î¼).EventuallyLE (Set.uIoc c d) (Set.uIoc a b)\nâŠ¢ IntervalIntegrable f Î¼ c d","decl":"theorem mono_set_ae (hf : IntervalIntegrable f Î¼ a b) (h : Î™ c d â‰¤áµ[Î¼] Î™ a b) :\n    IntervalIntegrable f Î¼ c d :=\n  intervalIntegrable_iff.mpr <| hf.def'.mono_set_ae h\n\n"}
{"name":"IntervalIntegrable.mono_set'","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\na b c d : Real\nÎ¼ : MeasureTheory.Measure Real\nhf : IntervalIntegrable f Î¼ a b\nhsub : HasSubset.Subset (Set.uIoc c d) (Set.uIoc a b)\nâŠ¢ IntervalIntegrable f Î¼ c d","decl":"theorem mono_set' (hf : IntervalIntegrable f Î¼ a b) (hsub : Î™ c d âŠ† Î™ a b) :\n    IntervalIntegrable f Î¼ c d :=\n  hf.mono_set_ae <| Eventually.of_forall hsub\n\n"}
{"name":"IntervalIntegrable.mono_fun","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\nF : Type u_4\ninstâœÂ¹ : NormedAddCommGroup E\nf : Real â†’ E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\ninstâœ : NormedAddCommGroup F\ng : Real â†’ F\nhf : IntervalIntegrable f Î¼ a b\nhgm : MeasureTheory.AEStronglyMeasurable g (Î¼.restrict (Set.uIoc a b))\nhle : (MeasureTheory.ae (Î¼.restrict (Set.uIoc a b))).EventuallyLE (fun x => Norm.norm (g x)) fun x => Norm.norm (f x)\nâŠ¢ IntervalIntegrable g Î¼ a b","decl":"theorem mono_fun [NormedAddCommGroup F] {g : â„ â†’ F} (hf : IntervalIntegrable f Î¼ a b)\n    (hgm : AEStronglyMeasurable g (Î¼.restrict (Î™ a b)))\n    (hle : (fun x => â€–g xâ€–) â‰¤áµ[Î¼.restrict (Î™ a b)] fun x => â€–f xâ€–) : IntervalIntegrable g Î¼ a b :=\n  intervalIntegrable_iff.2 <| hf.def'.integrable.mono hgm hle\n\n"}
{"name":"IntervalIntegrable.mono_fun'","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\ng : Real â†’ Real\nhg : IntervalIntegrable g Î¼ a b\nhfm : MeasureTheory.AEStronglyMeasurable f (Î¼.restrict (Set.uIoc a b))\nhle : (MeasureTheory.ae (Î¼.restrict (Set.uIoc a b))).EventuallyLE (fun x => Norm.norm (f x)) g\nâŠ¢ IntervalIntegrable f Î¼ a b","decl":"theorem mono_fun' {g : â„ â†’ â„} (hg : IntervalIntegrable g Î¼ a b)\n    (hfm : AEStronglyMeasurable f (Î¼.restrict (Î™ a b)))\n    (hle : (fun x => â€–f xâ€–) â‰¤áµ[Î¼.restrict (Î™ a b)] g) : IntervalIntegrable f Î¼ a b :=\n  intervalIntegrable_iff.2 <| hg.def'.integrable.mono' hfm hle\n\n"}
{"name":"IntervalIntegrable.aestronglyMeasurable","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nh : IntervalIntegrable f Î¼ a b\nâŠ¢ MeasureTheory.AEStronglyMeasurable f (Î¼.restrict (Set.Ioc a b))","decl":"protected theorem aestronglyMeasurable (h : IntervalIntegrable f Î¼ a b) :\n    AEStronglyMeasurable f (Î¼.restrict (Ioc a b)) :=\n  h.1.aestronglyMeasurable\n\n"}
{"name":"IntervalIntegrable.aestronglyMeasurable'","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nh : IntervalIntegrable f Î¼ a b\nâŠ¢ MeasureTheory.AEStronglyMeasurable f (Î¼.restrict (Set.Ioc b a))","decl":"protected theorem aestronglyMeasurable' (h : IntervalIntegrable f Î¼ a b) :\n    AEStronglyMeasurable f (Î¼.restrict (Ioc b a)) :=\n  h.2.aestronglyMeasurable\n\n"}
{"name":"IntervalIntegrable.smul","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"ğ•œ : Type u_2\nE : Type u_3\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedField ğ•œ\ninstâœ : NormedSpace ğ•œ E\nf : Real â†’ E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nh : IntervalIntegrable f Î¼ a b\nr : ğ•œ\nâŠ¢ IntervalIntegrable (HSMul.hSMul r f) Î¼ a b","decl":"theorem smul [NormedField ğ•œ] [NormedSpace ğ•œ E] {f : â„ â†’ E} {a b : â„} {Î¼ : Measure â„}\n    (h : IntervalIntegrable f Î¼ a b) (r : ğ•œ) : IntervalIntegrable (r â€¢ f) Î¼ a b :=\n  âŸ¨h.1.smul r, h.2.smul râŸ©\n\n"}
{"name":"IntervalIntegrable.add","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf g : Real â†’ E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nhf : IntervalIntegrable f Î¼ a b\nhg : IntervalIntegrable g Î¼ a b\nâŠ¢ IntervalIntegrable (fun x => HAdd.hAdd (f x) (g x)) Î¼ a b","decl":"@[simp]\ntheorem add (hf : IntervalIntegrable f Î¼ a b) (hg : IntervalIntegrable g Î¼ a b) :\n    IntervalIntegrable (fun x => f x + g x) Î¼ a b :=\n  âŸ¨hf.1.add hg.1, hf.2.add hg.2âŸ©\n\n"}
{"name":"IntervalIntegrable.sub","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf g : Real â†’ E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nhf : IntervalIntegrable f Î¼ a b\nhg : IntervalIntegrable g Î¼ a b\nâŠ¢ IntervalIntegrable (fun x => HSub.hSub (f x) (g x)) Î¼ a b","decl":"@[simp]\ntheorem sub (hf : IntervalIntegrable f Î¼ a b) (hg : IntervalIntegrable g Î¼ a b) :\n    IntervalIntegrable (fun x => f x - g x) Î¼ a b :=\n  âŸ¨hf.1.sub hg.1, hf.2.sub hg.2âŸ©\n\n"}
{"name":"IntervalIntegrable.sum","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"Î¹ : Type u_1\nE : Type u_3\ninstâœ : NormedAddCommGroup E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\ns : Finset Î¹\nf : Î¹ â†’ Real â†’ E\nh : âˆ€ (i : Î¹), Membership.mem s i â†’ IntervalIntegrable (f i) Î¼ a b\nâŠ¢ IntervalIntegrable (s.sum fun i => f i) Î¼ a b","decl":"theorem sum (s : Finset Î¹) {f : Î¹ â†’ â„ â†’ E} (h : âˆ€ i âˆˆ s, IntervalIntegrable (f i) Î¼ a b) :\n    IntervalIntegrable (âˆ‘ i âˆˆ s, f i) Î¼ a b :=\n  âŸ¨integrable_finset_sum' s fun i hi => (h i hi).1, integrable_finset_sum' s fun i hi => (h i hi).2âŸ©\n\n"}
{"name":"IntervalIntegrable.mul_continuousOn","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"A : Type u_5\ninstâœ : NormedRing A\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nf g : Real â†’ A\nhf : IntervalIntegrable f Î¼ a b\nhg : ContinuousOn g (Set.uIcc a b)\nâŠ¢ IntervalIntegrable (fun x => HMul.hMul (f x) (g x)) Î¼ a b","decl":"theorem mul_continuousOn {f g : â„ â†’ A} (hf : IntervalIntegrable f Î¼ a b)\n    (hg : ContinuousOn g [[a, b]]) : IntervalIntegrable (fun x => f x * g x) Î¼ a b := by\n  rw [intervalIntegrable_iff] at hf âŠ¢\n  exact hf.mul_continuousOn_of_subset hg measurableSet_Ioc isCompact_uIcc Ioc_subset_Icc_self\n\n"}
{"name":"IntervalIntegrable.continuousOn_mul","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"A : Type u_5\ninstâœ : NormedRing A\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nf g : Real â†’ A\nhf : IntervalIntegrable f Î¼ a b\nhg : ContinuousOn g (Set.uIcc a b)\nâŠ¢ IntervalIntegrable (fun x => HMul.hMul (g x) (f x)) Î¼ a b","decl":"theorem continuousOn_mul {f g : â„ â†’ A} (hf : IntervalIntegrable f Î¼ a b)\n    (hg : ContinuousOn g [[a, b]]) : IntervalIntegrable (fun x => g x * f x) Î¼ a b := by\n  rw [intervalIntegrable_iff] at hf âŠ¢\n  exact hf.continuousOn_mul_of_subset hg isCompact_uIcc measurableSet_Ioc Ioc_subset_Icc_self\n\n"}
{"name":"IntervalIntegrable.const_mul","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"A : Type u_5\ninstâœ : NormedRing A\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nf : Real â†’ A\nhf : IntervalIntegrable f Î¼ a b\nc : A\nâŠ¢ IntervalIntegrable (fun x => HMul.hMul c (f x)) Î¼ a b","decl":"@[simp]\ntheorem const_mul {f : â„ â†’ A} (hf : IntervalIntegrable f Î¼ a b) (c : A) :\n    IntervalIntegrable (fun x => c * f x) Î¼ a b :=\n  hf.continuousOn_mul continuousOn_const\n\n"}
{"name":"IntervalIntegrable.mul_const","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"A : Type u_5\ninstâœ : NormedRing A\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nf : Real â†’ A\nhf : IntervalIntegrable f Î¼ a b\nc : A\nâŠ¢ IntervalIntegrable (fun x => HMul.hMul (f x) c) Î¼ a b","decl":"@[simp]\ntheorem mul_const {f : â„ â†’ A} (hf : IntervalIntegrable f Î¼ a b) (c : A) :\n    IntervalIntegrable (fun x => f x * c) Î¼ a b :=\n  hf.mul_continuousOn continuousOn_const\n\n"}
{"name":"IntervalIntegrable.div_const","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"a b : Real\nÎ¼ : MeasureTheory.Measure Real\nğ•œ : Type u_6\nf : Real â†’ ğ•œ\ninstâœ : NormedField ğ•œ\nh : IntervalIntegrable f Î¼ a b\nc : ğ•œ\nâŠ¢ IntervalIntegrable (fun x => HDiv.hDiv (f x) c) Î¼ a b","decl":"@[simp]\ntheorem div_const {ğ•œ : Type*} {f : â„ â†’ ğ•œ} [NormedField ğ•œ] (h : IntervalIntegrable f Î¼ a b)\n    (c : ğ•œ) : IntervalIntegrable (fun x => f x / c) Î¼ a b := by\n  simpa only [div_eq_mul_inv] using mul_const h câ»Â¹\n\n"}
{"name":"IntervalIntegrable.comp_mul_left","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\na b : Real\nhf : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b\nc : Real\nâŠ¢ IntervalIntegrable (fun x => f (HMul.hMul c x)) MeasureTheory.MeasureSpace.volume (HDiv.hDiv a c) (HDiv.hDiv b c)","decl":"theorem comp_mul_left (hf : IntervalIntegrable f volume a b) (c : â„) :\n    IntervalIntegrable (fun x => f (c * x)) volume (a / c) (b / c) := by\n  rcases eq_or_ne c 0 with (hc | hc); Â· rw [hc]; simp\n  rw [intervalIntegrable_iff'] at hf âŠ¢\n  have A : MeasurableEmbedding fun x => x * câ»Â¹ :=\n    (Homeomorph.mulRightâ‚€ _ (inv_ne_zero hc)).isClosedEmbedding.measurableEmbedding\n  rw [â† Real.smul_map_volume_mul_right (inv_ne_zero hc), IntegrableOn, Measure.restrict_smul,\n    integrable_smul_measure (by simpa : ENNReal.ofReal |câ»Â¹| â‰  0) ENNReal.ofReal_ne_top,\n    â† IntegrableOn, MeasurableEmbedding.integrableOn_map_iff A]\n  convert hf using 1\n  Â· ext; simp only [comp_apply]; congr 1; field_simp\n  Â· rw [preimage_mul_const_uIcc (inv_ne_zero hc)]; field_simp [hc]\n\n"}
{"name":"IntervalIntegrable.comp_mul_left_iff","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\na b c : Real\nhc : Ne c 0\nâŠ¢ Iff (IntervalIntegrable (fun x => f (HMul.hMul c x)) MeasureTheory.MeasureSpace.volume (HDiv.hDiv a c) (HDiv.hDiv b c)) (IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b)","decl":"theorem comp_mul_left_iff {c : â„} (hc : c â‰  0) :\n    IntervalIntegrable (fun x â†¦ f (c * x)) volume (a / c) (b / c) â†”\n      IntervalIntegrable f volume a b :=\n  âŸ¨fun h â†¦ by simpa [hc] using h.comp_mul_left câ»Â¹, (comp_mul_left Â· c)âŸ©\n\n"}
{"name":"IntervalIntegrable.comp_mul_right","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\na b : Real\nhf : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b\nc : Real\nâŠ¢ IntervalIntegrable (fun x => f (HMul.hMul x c)) MeasureTheory.MeasureSpace.volume (HDiv.hDiv a c) (HDiv.hDiv b c)","decl":"theorem comp_mul_right (hf : IntervalIntegrable f volume a b) (c : â„) :\n    IntervalIntegrable (fun x => f (x * c)) volume (a / c) (b / c) := by\n  simpa only [mul_comm] using comp_mul_left hf c\n\n"}
{"name":"IntervalIntegrable.comp_add_right","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\na b : Real\nhf : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b\nc : Real\nâŠ¢ IntervalIntegrable (fun x => f (HAdd.hAdd x c)) MeasureTheory.MeasureSpace.volume (HSub.hSub a c) (HSub.hSub b c)","decl":"theorem comp_add_right (hf : IntervalIntegrable f volume a b) (c : â„) :\n    IntervalIntegrable (fun x => f (x + c)) volume (a - c) (b - c) := by\n  wlog h : a â‰¤ b generalizing a b\n  Â· exact IntervalIntegrable.symm (this hf.symm (le_of_not_le h))\n  rw [intervalIntegrable_iff'] at hf âŠ¢\n  have A : MeasurableEmbedding fun x => x + c :=\n    (Homeomorph.addRight c).isClosedEmbedding.measurableEmbedding\n  rw [â† map_add_right_eq_self volume c] at hf\n  convert (MeasurableEmbedding.integrableOn_map_iff A).mp hf using 1\n  rw [preimage_add_const_uIcc]\n\n"}
{"name":"IntervalIntegrable.comp_add_left","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\na b : Real\nhf : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b\nc : Real\nâŠ¢ IntervalIntegrable (fun x => f (HAdd.hAdd c x)) MeasureTheory.MeasureSpace.volume (HSub.hSub a c) (HSub.hSub b c)","decl":"theorem comp_add_left (hf : IntervalIntegrable f volume a b) (c : â„) :\n    IntervalIntegrable (fun x => f (c + x)) volume (a - c) (b - c) := by\n  simpa only [add_comm] using IntervalIntegrable.comp_add_right hf c\n\n"}
{"name":"IntervalIntegrable.comp_sub_right","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\na b : Real\nhf : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b\nc : Real\nâŠ¢ IntervalIntegrable (fun x => f (HSub.hSub x c)) MeasureTheory.MeasureSpace.volume (HAdd.hAdd a c) (HAdd.hAdd b c)","decl":"theorem comp_sub_right (hf : IntervalIntegrable f volume a b) (c : â„) :\n    IntervalIntegrable (fun x => f (x - c)) volume (a + c) (b + c) := by\n  simpa only [sub_neg_eq_add] using IntervalIntegrable.comp_add_right hf (-c)\n\n"}
{"name":"IntervalIntegrable.iff_comp_neg","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\na b : Real\nâŠ¢ Iff (IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (IntervalIntegrable (fun x => f (Neg.neg x)) MeasureTheory.MeasureSpace.volume (Neg.neg a) (Neg.neg b))","decl":"theorem iff_comp_neg :\n    IntervalIntegrable f volume a b â†” IntervalIntegrable (fun x => f (-x)) volume (-a) (-b) := by\n  rw [â† comp_mul_left_iff (neg_ne_zero.2 one_ne_zero)]; simp [div_neg]\n\n"}
{"name":"IntervalIntegrable.comp_sub_left","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\na b : Real\nhf : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b\nc : Real\nâŠ¢ IntervalIntegrable (fun x => f (HSub.hSub c x)) MeasureTheory.MeasureSpace.volume (HSub.hSub c a) (HSub.hSub c b)","decl":"theorem comp_sub_left (hf : IntervalIntegrable f volume a b) (c : â„) :\n    IntervalIntegrable (fun x => f (c - x)) volume (c - a) (c - b) := by\n  simpa only [neg_sub, â† sub_eq_add_neg] using iff_comp_neg.mp (hf.comp_add_left c)\n\n"}
{"name":"ContinuousOn.intervalIntegrable","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\nÎ¼ : MeasureTheory.Measure Real\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nu : Real â†’ E\na b : Real\nhu : ContinuousOn u (Set.uIcc a b)\nâŠ¢ IntervalIntegrable u Î¼ a b","decl":"theorem ContinuousOn.intervalIntegrable {u : â„ â†’ E} {a b : â„} (hu : ContinuousOn u (uIcc a b)) :\n    IntervalIntegrable u Î¼ a b :=\n  (ContinuousOn.integrableOn_Icc hu).intervalIntegrable\n\n"}
{"name":"ContinuousOn.intervalIntegrable_of_Icc","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\nÎ¼ : MeasureTheory.Measure Real\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nu : Real â†’ E\na b : Real\nh : LE.le a b\nhu : ContinuousOn u (Set.Icc a b)\nâŠ¢ IntervalIntegrable u Î¼ a b","decl":"theorem ContinuousOn.intervalIntegrable_of_Icc {u : â„ â†’ E} {a b : â„} (h : a â‰¤ b)\n    (hu : ContinuousOn u (Icc a b)) : IntervalIntegrable u Î¼ a b :=\n  ContinuousOn.intervalIntegrable ((uIcc_of_le h).symm â–¸ hu)\n\n"}
{"name":"Continuous.intervalIntegrable","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\nÎ¼ : MeasureTheory.Measure Real\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nu : Real â†’ E\nhu : Continuous u\na b : Real\nâŠ¢ IntervalIntegrable u Î¼ a b","decl":"/-- A continuous function on `â„` is `IntervalIntegrable` with respect to any locally finite measure\n`Î½` on â„. -/\ntheorem Continuous.intervalIntegrable {u : â„ â†’ E} (hu : Continuous u) (a b : â„) :\n    IntervalIntegrable u Î¼ a b :=\n  hu.continuousOn.intervalIntegrable\n\n"}
{"name":"MonotoneOn.intervalIntegrable","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœâ´ : NormedAddCommGroup E\nÎ¼ : MeasureTheory.Measure Real\ninstâœÂ³ : MeasureTheory.IsLocallyFiniteMeasure Î¼\ninstâœÂ² : ConditionallyCompleteLinearOrder E\ninstâœÂ¹ : OrderTopology E\ninstâœ : SecondCountableTopology E\nu : Real â†’ E\na b : Real\nhu : MonotoneOn u (Set.uIcc a b)\nâŠ¢ IntervalIntegrable u Î¼ a b","decl":"theorem MonotoneOn.intervalIntegrable {u : â„ â†’ E} {a b : â„} (hu : MonotoneOn u (uIcc a b)) :\n    IntervalIntegrable u Î¼ a b := by\n  rw [intervalIntegrable_iff]\n  exact (hu.integrableOn_isCompact isCompact_uIcc).mono_set Ioc_subset_Icc_self\n\n"}
{"name":"AntitoneOn.intervalIntegrable","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœâ´ : NormedAddCommGroup E\nÎ¼ : MeasureTheory.Measure Real\ninstâœÂ³ : MeasureTheory.IsLocallyFiniteMeasure Î¼\ninstâœÂ² : ConditionallyCompleteLinearOrder E\ninstâœÂ¹ : OrderTopology E\ninstâœ : SecondCountableTopology E\nu : Real â†’ E\na b : Real\nhu : AntitoneOn u (Set.uIcc a b)\nâŠ¢ IntervalIntegrable u Î¼ a b","decl":"theorem AntitoneOn.intervalIntegrable {u : â„ â†’ E} {a b : â„} (hu : AntitoneOn u (uIcc a b)) :\n    IntervalIntegrable u Î¼ a b :=\n  hu.dual_right.intervalIntegrable\n\n"}
{"name":"Monotone.intervalIntegrable","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœâ´ : NormedAddCommGroup E\nÎ¼ : MeasureTheory.Measure Real\ninstâœÂ³ : MeasureTheory.IsLocallyFiniteMeasure Î¼\ninstâœÂ² : ConditionallyCompleteLinearOrder E\ninstâœÂ¹ : OrderTopology E\ninstâœ : SecondCountableTopology E\nu : Real â†’ E\na b : Real\nhu : Monotone u\nâŠ¢ IntervalIntegrable u Î¼ a b","decl":"theorem Monotone.intervalIntegrable {u : â„ â†’ E} {a b : â„} (hu : Monotone u) :\n    IntervalIntegrable u Î¼ a b :=\n  (hu.monotoneOn _).intervalIntegrable\n\n"}
{"name":"Antitone.intervalIntegrable","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœâ´ : NormedAddCommGroup E\nÎ¼ : MeasureTheory.Measure Real\ninstâœÂ³ : MeasureTheory.IsLocallyFiniteMeasure Î¼\ninstâœÂ² : ConditionallyCompleteLinearOrder E\ninstâœÂ¹ : OrderTopology E\ninstâœ : SecondCountableTopology E\nu : Real â†’ E\na b : Real\nhu : Antitone u\nâŠ¢ IntervalIntegrable u Î¼ a b","decl":"theorem Antitone.intervalIntegrable {u : â„ â†’ E} {a b : â„} (hu : Antitone u) :\n    IntervalIntegrable u Î¼ a b :=\n  (hu.antitoneOn _).intervalIntegrable\n\n"}
{"name":"intervalIntegrable_of_evenâ‚€","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\nhâ‚f : âˆ€ (x : Real), Eq (f x) (f (Neg.neg x))\nhâ‚‚f : âˆ€ (x : Real), LT.lt 0 x â†’ IntervalIntegrable f MeasureTheory.MeasureSpace.volume 0 x\nt : Real\nâŠ¢ IntervalIntegrable f MeasureTheory.MeasureSpace.volume 0 t","decl":"/-- An even function is interval integrable (with respect to the volume measure) on every interval\nof the form `0..x` if it is interval integrable (with respect to the volume measure) on every\ninterval of the form `0..x`, for positive `x`.\n\nSee `intervalIntegrable_of_even` for a stronger result.-/\nlemma intervalIntegrable_of_evenâ‚€ (hâ‚f : âˆ€ x, f x = f (-x))\n    (hâ‚‚f : âˆ€ x, 0 < x â†’ IntervalIntegrable f volume 0 x) (t : â„) :\n    IntervalIntegrable f volume 0 t := by\n  rcases lt_trichotomy t 0 with h | h | h\n  Â· rw [IntervalIntegrable.iff_comp_neg]\n    conv => arg 1; intro t; rw [â† hâ‚f]\n    simp [hâ‚‚f (-t) (by norm_num [h])]\n  Â· rw [h]\n  Â· exact hâ‚‚f t h\n\n"}
{"name":"intervalIntegrable_of_even","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\nhâ‚f : âˆ€ (x : Real), Eq (f x) (f (Neg.neg x))\nhâ‚‚f : âˆ€ (x : Real), LT.lt 0 x â†’ IntervalIntegrable f MeasureTheory.MeasureSpace.volume 0 x\na b : Real\nâŠ¢ IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b","decl":"/-- An even function is interval integrable (with respect to the volume measure) on every interval\nif it is interval integrable (with respect to the volume measure) on every interval of the form\n`0..x`, for positive `x`. -/\ntheorem intervalIntegrable_of_even\n  (hâ‚f : âˆ€ x, f x = f (-x)) (hâ‚‚f : âˆ€ x, 0 < x â†’ IntervalIntegrable f volume 0 x) (a b : â„) :\n  IntervalIntegrable f volume a b :=\n  -- Split integral and apply lemma\n  (intervalIntegrable_of_evenâ‚€ hâ‚f hâ‚‚f a).symm.trans (b := 0)\n    (intervalIntegrable_of_evenâ‚€ hâ‚f hâ‚‚f b)\n\n"}
{"name":"intervalIntegrable_of_oddâ‚€","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\nhâ‚f : âˆ€ (x : Real), Eq (Neg.neg (f x)) (f (Neg.neg x))\nhâ‚‚f : âˆ€ (x : Real), LT.lt 0 x â†’ IntervalIntegrable f MeasureTheory.MeasureSpace.volume 0 x\nt : Real\nâŠ¢ IntervalIntegrable f MeasureTheory.MeasureSpace.volume 0 t","decl":"/-- An odd function is interval integrable (with respect to the volume measure) on every interval\nof the form `0..x` if it is interval integrable (with respect to the volume measure) on every\ninterval of the form `0..x`, for positive `x`.\n\nSee `intervalIntegrable_of_odd` for a stronger result.-/\nlemma intervalIntegrable_of_oddâ‚€\n  (hâ‚f : âˆ€ x, -f x = f (-x)) (hâ‚‚f : âˆ€ x, 0 < x â†’ IntervalIntegrable f volume 0 x) (t : â„) :\n  IntervalIntegrable f volume 0 t := by\n  rcases lt_trichotomy t 0 with h | h | h\n  Â· rw [IntervalIntegrable.iff_comp_neg]\n    conv => arg 1; intro t; rw [â† hâ‚f]\n    apply IntervalIntegrable.neg\n    simp [hâ‚‚f (-t) (by norm_num [h])]\n  Â· rw [h]\n  Â· exact hâ‚‚f t h\n\n"}
{"name":"intervalIntegrable_of_odd","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\nhâ‚f : âˆ€ (x : Real), Eq (Neg.neg (f x)) (f (Neg.neg x))\nhâ‚‚f : âˆ€ (x : Real), LT.lt 0 x â†’ IntervalIntegrable f MeasureTheory.MeasureSpace.volume 0 x\na b : Real\nâŠ¢ IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b","decl":"/-- An odd function is interval integrable (with respect to the volume measure) on every interval\niff it is interval integrable (with respect to the volume measure) on every interval of the form\n`0..x`, for positive `x`. -/\ntheorem intervalIntegrable_of_odd\n  (hâ‚f : âˆ€ x, -f x = f (-x)) (hâ‚‚f : âˆ€ x, 0 < x â†’ IntervalIntegrable f volume 0 x) (a b : â„) :\n  IntervalIntegrable f volume a b :=\n  -- Split integral and apply lemma\n  (intervalIntegrable_of_oddâ‚€ hâ‚f hâ‚‚f a).symm.trans (b := 0) (intervalIntegrable_of_oddâ‚€ hâ‚f hâ‚‚f b)\n\n"}
{"name":"Filter.Tendsto.eventually_intervalIntegrable_ae","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"Î¹ : Type u_1\nE : Type u_3\ninstâœÂ² : NormedAddCommGroup E\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\nl l' : Filter Real\nhfm : StronglyMeasurableAtFilter f l' Î¼\ninstâœÂ¹ : Filter.TendstoIxxClass Set.Ioc l l'\ninstâœ : l'.IsMeasurablyGenerated\nhÎ¼ : Î¼.FiniteAtFilter l'\nc : E\nhf : Filter.Tendsto f (Min.min l' (MeasureTheory.ae Î¼)) (nhds c)\nu v : Î¹ â†’ Real\nlt : Filter Î¹\nhu : Filter.Tendsto u lt l\nhv : Filter.Tendsto v lt l\nâŠ¢ Filter.Eventually (fun t => IntervalIntegrable f Î¼ (u t) (v t)) lt","decl":"/-- Let `l'` be a measurably generated filter; let `l` be a of filter such that each `s âˆˆ l'`\neventually includes `Ioc u v` as both `u` and `v` tend to `l`. Let `Î¼` be a measure finite at `l'`.\n\nSuppose that `f : â„ â†’ E` has a finite limit at `l' âŠ“ ae Î¼`. Then `f` is interval integrable on\n`u..v` provided that both `u` and `v` tend to `l`.\n\nTypeclass instances allow Lean to find `l'` based on `l` but not vice versa, so\n`apply Tendsto.eventually_intervalIntegrable_ae` will generate goals `Filter â„` and\n`TendstoIxxClass Ioc ?m_1 l'`. -/\ntheorem Filter.Tendsto.eventually_intervalIntegrable_ae {f : â„ â†’ E} {Î¼ : Measure â„}\n    {l l' : Filter â„} (hfm : StronglyMeasurableAtFilter f l' Î¼) [TendstoIxxClass Ioc l l']\n    [IsMeasurablyGenerated l'] (hÎ¼ : Î¼.FiniteAtFilter l') {c : E} (hf : Tendsto f (l' âŠ“ ae Î¼) (ğ“ c))\n    {u v : Î¹ â†’ â„} {lt : Filter Î¹} (hu : Tendsto u lt l) (hv : Tendsto v lt l) :\n    âˆ€á¶  t in lt, IntervalIntegrable f Î¼ (u t) (v t) :=\n  have := (hf.integrableAtFilter_ae hfm hÎ¼).eventually\n  ((hu.Ioc hv).eventually this).and <| (hv.Ioc hu).eventually this\n\n"}
{"name":"Filter.Tendsto.eventually_intervalIntegrable","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"Î¹ : Type u_1\nE : Type u_3\ninstâœÂ² : NormedAddCommGroup E\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\nl l' : Filter Real\nhfm : StronglyMeasurableAtFilter f l' Î¼\ninstâœÂ¹ : Filter.TendstoIxxClass Set.Ioc l l'\ninstâœ : l'.IsMeasurablyGenerated\nhÎ¼ : Î¼.FiniteAtFilter l'\nc : E\nhf : Filter.Tendsto f l' (nhds c)\nu v : Î¹ â†’ Real\nlt : Filter Î¹\nhu : Filter.Tendsto u lt l\nhv : Filter.Tendsto v lt l\nâŠ¢ Filter.Eventually (fun t => IntervalIntegrable f Î¼ (u t) (v t)) lt","decl":"/-- Let `l'` be a measurably generated filter; let `l` be a of filter such that each `s âˆˆ l'`\neventually includes `Ioc u v` as both `u` and `v` tend to `l`. Let `Î¼` be a measure finite at `l'`.\n\nSuppose that `f : â„ â†’ E` has a finite limit at `l`. Then `f` is interval integrable on `u..v`\nprovided that both `u` and `v` tend to `l`.\n\nTypeclass instances allow Lean to find `l'` based on `l` but not vice versa, so\n`apply Tendsto.eventually_intervalIntegrable` will generate goals `Filter â„` and\n`TendstoIxxClass Ioc ?m_1 l'`. -/\ntheorem Filter.Tendsto.eventually_intervalIntegrable {f : â„ â†’ E} {Î¼ : Measure â„} {l l' : Filter â„}\n    (hfm : StronglyMeasurableAtFilter f l' Î¼) [TendstoIxxClass Ioc l l'] [IsMeasurablyGenerated l']\n    (hÎ¼ : Î¼.FiniteAtFilter l') {c : E} (hf : Tendsto f l' (ğ“ c)) {u v : Î¹ â†’ â„} {lt : Filter Î¹}\n    (hu : Tendsto u lt l) (hv : Tendsto v lt l) : âˆ€á¶  t in lt, IntervalIntegrable f Î¼ (u t) (v t) :=\n  (hf.mono_left inf_le_left).eventually_intervalIntegrable_ae hfm hÎ¼ hu hv\n\n"}
{"name":"intervalIntegral.integral_zero","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nâŠ¢ Eq (intervalIntegral (fun x => 0) a b Î¼) 0","decl":"@[simp]\ntheorem integral_zero : (âˆ« _ in a..b, (0 : E) âˆ‚Î¼) = 0 := by simp [intervalIntegral]\n\n"}
{"name":"intervalIntegral.integral_of_le","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\nh : LE.le a b\nâŠ¢ Eq (intervalIntegral (fun x => f x) a b Î¼) (MeasureTheory.integral (Î¼.restrict (Set.Ioc a b)) fun x => f x)","decl":"theorem integral_of_le (h : a â‰¤ b) : âˆ« x in a..b, f x âˆ‚Î¼ = âˆ« x in Ioc a b, f x âˆ‚Î¼ := by\n  simp [intervalIntegral, h]\n\n"}
{"name":"intervalIntegral.integral_same","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na : Real\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\nâŠ¢ Eq (intervalIntegral (fun x => f x) a a Î¼) 0","decl":"@[simp]\ntheorem integral_same : âˆ« x in a..a, f x âˆ‚Î¼ = 0 :=\n  sub_self _\n\n"}
{"name":"intervalIntegral.integral_symm","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\na b : Real\nâŠ¢ Eq (intervalIntegral (fun x => f x) b a Î¼) (Neg.neg (intervalIntegral (fun x => f x) a b Î¼))","decl":"theorem integral_symm (a b) : âˆ« x in b..a, f x âˆ‚Î¼ = -âˆ« x in a..b, f x âˆ‚Î¼ := by\n  simp only [intervalIntegral, neg_sub]\n\n"}
{"name":"intervalIntegral.integral_of_ge","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\nh : LE.le b a\nâŠ¢ Eq (intervalIntegral (fun x => f x) a b Î¼) (Neg.neg (MeasureTheory.integral (Î¼.restrict (Set.Ioc b a)) fun x => f x))","decl":"theorem integral_of_ge (h : b â‰¤ a) : âˆ« x in a..b, f x âˆ‚Î¼ = -âˆ« x in Ioc b a, f x âˆ‚Î¼ := by\n  simp only [integral_symm b, integral_of_le h]\n\n"}
{"name":"intervalIntegral.intervalIntegral_eq_integral_uIoc","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : Real â†’ E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nâŠ¢ Eq (intervalIntegral (fun x => f x) a b Î¼) (HSMul.hSMul (ite (LE.le a b) 1 (-1)) (MeasureTheory.integral (Î¼.restrict (Set.uIoc a b)) fun x => f x))","decl":"theorem intervalIntegral_eq_integral_uIoc (f : â„ â†’ E) (a b : â„) (Î¼ : Measure â„) :\n    âˆ« x in a..b, f x âˆ‚Î¼ = (if a â‰¤ b then 1 else -1 : â„) â€¢ âˆ« x in Î™ a b, f x âˆ‚Î¼ := by\n  split_ifs with h\n  Â· simp only [integral_of_le h, uIoc_of_le h, one_smul]\n  Â· simp only [integral_of_ge (not_le.1 h).le, uIoc_of_ge (not_le.1 h).le, neg_one_smul]\n\n"}
{"name":"intervalIntegral.norm_intervalIntegral_eq","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : Real â†’ E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nâŠ¢ Eq (Norm.norm (intervalIntegral (fun x => f x) a b Î¼)) (Norm.norm (MeasureTheory.integral (Î¼.restrict (Set.uIoc a b)) fun x => f x))","decl":"theorem norm_intervalIntegral_eq (f : â„ â†’ E) (a b : â„) (Î¼ : Measure â„) :\n    â€–âˆ« x in a..b, f x âˆ‚Î¼â€– = â€–âˆ« x in Î™ a b, f x âˆ‚Î¼â€– := by\n  simp_rw [intervalIntegral_eq_integral_uIoc, norm_smul]\n  split_ifs <;> simp only [norm_neg, norm_one, one_mul]\n\n"}
{"name":"intervalIntegral.abs_intervalIntegral_eq","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f : Real â†’ Real\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nâŠ¢ Eq (abs (intervalIntegral (fun x => f x) a b Î¼)) (abs (MeasureTheory.integral (Î¼.restrict (Set.uIoc a b)) fun x => f x))","decl":"theorem abs_intervalIntegral_eq (f : â„ â†’ â„) (a b : â„) (Î¼ : Measure â„) :\n    |âˆ« x in a..b, f x âˆ‚Î¼| = |âˆ« x in Î™ a b, f x âˆ‚Î¼| :=\n  norm_intervalIntegral_eq f a b Î¼\n\n"}
{"name":"intervalIntegral.integral_cases","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nÎ¼ : MeasureTheory.Measure Real\nf : Real â†’ E\na b : Real\nâŠ¢ Membership.mem (Insert.insert (MeasureTheory.integral (Î¼.restrict (Set.uIoc a b)) fun x => f x) (Singleton.singleton (Neg.neg (MeasureTheory.integral (Î¼.restrict (Set.uIoc a b)) fun x => f x)))) (intervalIntegral (fun x => f x) a b Î¼)","decl":"theorem integral_cases (f : â„ â†’ E) (a b) :\n    (âˆ« x in a..b, f x âˆ‚Î¼) âˆˆ ({âˆ« x in Î™ a b, f x âˆ‚Î¼, -âˆ« x in Î™ a b, f x âˆ‚Î¼} : Set E) := by\n  rw [intervalIntegral_eq_integral_uIoc]; split_ifs <;> simp\n\n"}
{"name":"intervalIntegral.integral_undef","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\nh : Not (IntervalIntegrable f Î¼ a b)\nâŠ¢ Eq (intervalIntegral (fun x => f x) a b Î¼) 0","decl":"nonrec theorem integral_undef (h : Â¬IntervalIntegrable f Î¼ a b) : âˆ« x in a..b, f x âˆ‚Î¼ = 0 := by\n  rw [intervalIntegrable_iff] at h\n  rw [intervalIntegral_eq_integral_uIoc, integral_undef h, smul_zero]\n\n"}
{"name":"intervalIntegral.intervalIntegrable_of_integral_ne_zero","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\nh : Ne (intervalIntegral (fun x => f x) a b Î¼) 0\nâŠ¢ IntervalIntegrable f Î¼ a b","decl":"theorem intervalIntegrable_of_integral_ne_zero {a b : â„} {f : â„ â†’ E} {Î¼ : Measure â„}\n    (h : (âˆ« x in a..b, f x âˆ‚Î¼) â‰  0) : IntervalIntegrable f Î¼ a b :=\n  not_imp_comm.1 integral_undef h\n\n"}
{"name":"intervalIntegral.integral_non_aestronglyMeasurable","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\nhf : Not (MeasureTheory.AEStronglyMeasurable f (Î¼.restrict (Set.uIoc a b)))\nâŠ¢ Eq (intervalIntegral (fun x => f x) a b Î¼) 0","decl":"nonrec theorem integral_non_aestronglyMeasurable\n    (hf : Â¬AEStronglyMeasurable f (Î¼.restrict (Î™ a b))) :\n    âˆ« x in a..b, f x âˆ‚Î¼ = 0 := by\n  rw [intervalIntegral_eq_integral_uIoc, integral_non_aestronglyMeasurable hf, smul_zero]\n\n"}
{"name":"intervalIntegral.integral_non_aestronglyMeasurable_of_le","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\nh : LE.le a b\nhf : Not (MeasureTheory.AEStronglyMeasurable f (Î¼.restrict (Set.Ioc a b)))\nâŠ¢ Eq (intervalIntegral (fun x => f x) a b Î¼) 0","decl":"theorem integral_non_aestronglyMeasurable_of_le (h : a â‰¤ b)\n    (hf : Â¬AEStronglyMeasurable f (Î¼.restrict (Ioc a b))) : âˆ« x in a..b, f x âˆ‚Î¼ = 0 :=\n  integral_non_aestronglyMeasurable <| by rwa [uIoc_of_le h]\n\n"}
{"name":"intervalIntegral.norm_integral_min_max","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nf : Real â†’ E\nâŠ¢ Eq (Norm.norm (intervalIntegral (fun x => f x) (Min.min a b) (Max.max a b) Î¼)) (Norm.norm (intervalIntegral (fun x => f x) a b Î¼))","decl":"theorem norm_integral_min_max (f : â„ â†’ E) :\n    â€–âˆ« x in min a b..max a b, f x âˆ‚Î¼â€– = â€–âˆ« x in a..b, f x âˆ‚Î¼â€– := by\n  cases le_total a b <;> simp [*, integral_symm a b]\n\n"}
{"name":"intervalIntegral.norm_integral_eq_norm_integral_Ioc","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nf : Real â†’ E\nâŠ¢ Eq (Norm.norm (intervalIntegral (fun x => f x) a b Î¼)) (Norm.norm (MeasureTheory.integral (Î¼.restrict (Set.uIoc a b)) fun x => f x))","decl":"theorem norm_integral_eq_norm_integral_Ioc (f : â„ â†’ E) :\n    â€–âˆ« x in a..b, f x âˆ‚Î¼â€– = â€–âˆ« x in Î™ a b, f x âˆ‚Î¼â€– := by\n  rw [â† norm_integral_min_max, integral_of_le min_le_max, uIoc]\n\n"}
{"name":"intervalIntegral.abs_integral_eq_abs_integral_uIoc","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"a b : Real\nÎ¼ : MeasureTheory.Measure Real\nf : Real â†’ Real\nâŠ¢ Eq (abs (intervalIntegral (fun x => f x) a b Î¼)) (abs (MeasureTheory.integral (Î¼.restrict (Set.uIoc a b)) fun x => f x))","decl":"theorem abs_integral_eq_abs_integral_uIoc (f : â„ â†’ â„) :\n    |âˆ« x in a..b, f x âˆ‚Î¼| = |âˆ« x in Î™ a b, f x âˆ‚Î¼| :=\n  norm_integral_eq_norm_integral_Ioc f\n\n"}
{"name":"intervalIntegral.norm_integral_le_integral_norm_Ioc","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\nâŠ¢ LE.le (Norm.norm (intervalIntegral (fun x => f x) a b Î¼)) (MeasureTheory.integral (Î¼.restrict (Set.uIoc a b)) fun x => Norm.norm (f x))","decl":"theorem norm_integral_le_integral_norm_Ioc : â€–âˆ« x in a..b, f x âˆ‚Î¼â€– â‰¤ âˆ« x in Î™ a b, â€–f xâ€– âˆ‚Î¼ :=\n  calc\n    â€–âˆ« x in a..b, f x âˆ‚Î¼â€– = â€–âˆ« x in Î™ a b, f x âˆ‚Î¼â€– := norm_integral_eq_norm_integral_Ioc f\n    _ â‰¤ âˆ« x in Î™ a b, â€–f xâ€– âˆ‚Î¼ := norm_integral_le_integral_norm f\n\n"}
{"name":"intervalIntegral.norm_integral_le_abs_integral_norm","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\nâŠ¢ LE.le (Norm.norm (intervalIntegral (fun x => f x) a b Î¼)) (abs (intervalIntegral (fun x => Norm.norm (f x)) a b Î¼))","decl":"theorem norm_integral_le_abs_integral_norm : â€–âˆ« x in a..b, f x âˆ‚Î¼â€– â‰¤ |âˆ« x in a..b, â€–f xâ€– âˆ‚Î¼| := by\n  simp only [â† Real.norm_eq_abs, norm_integral_eq_norm_integral_Ioc]\n  exact le_trans (norm_integral_le_integral_norm _) (le_abs_self _)\n\n"}
{"name":"intervalIntegral.norm_integral_le_integral_norm","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\nh : LE.le a b\nâŠ¢ LE.le (Norm.norm (intervalIntegral (fun x => f x) a b Î¼)) (intervalIntegral (fun x => Norm.norm (f x)) a b Î¼)","decl":"theorem norm_integral_le_integral_norm (h : a â‰¤ b) :\n    â€–âˆ« x in a..b, f x âˆ‚Î¼â€– â‰¤ âˆ« x in a..b, â€–f xâ€– âˆ‚Î¼ :=\n  norm_integral_le_integral_norm_Ioc.trans_eq <| by rw [uIoc_of_le h, integral_of_le h]\n\n"}
{"name":"intervalIntegral.norm_integral_le_of_norm_le","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\ng : Real â†’ Real\nh : Filter.Eventually (fun t => LE.le (Norm.norm (f t)) (g t)) (MeasureTheory.ae (Î¼.restrict (Set.uIoc a b)))\nhbound : IntervalIntegrable g Î¼ a b\nâŠ¢ LE.le (Norm.norm (intervalIntegral (fun t => f t) a b Î¼)) (abs (intervalIntegral (fun t => g t) a b Î¼))","decl":"nonrec theorem norm_integral_le_of_norm_le {g : â„ â†’ â„} (h : âˆ€áµ t âˆ‚Î¼.restrict <| Î™ a b, â€–f tâ€– â‰¤ g t)\n    (hbound : IntervalIntegrable g Î¼ a b) : â€–âˆ« t in a..b, f t âˆ‚Î¼â€– â‰¤ |âˆ« t in a..b, g t âˆ‚Î¼| := by\n  simp_rw [norm_intervalIntegral_eq, abs_intervalIntegral_eq,\n    abs_eq_self.mpr (integral_nonneg_of_ae <| h.mono fun _t ht => (norm_nonneg _).trans ht),\n    norm_integral_le_of_norm_le hbound.def' h]\n\n"}
{"name":"intervalIntegral.norm_integral_le_of_norm_le_const_ae","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b C : Real\nf : Real â†’ E\nh : Filter.Eventually (fun x => Membership.mem (Set.uIoc a b) x â†’ LE.le (Norm.norm (f x)) C) (MeasureTheory.ae MeasureTheory.MeasureSpace.volume)\nâŠ¢ LE.le (Norm.norm (intervalIntegral (fun x => f x) a b MeasureTheory.MeasureSpace.volume)) (HMul.hMul C (abs (HSub.hSub b a)))","decl":"theorem norm_integral_le_of_norm_le_const_ae {a b C : â„} {f : â„ â†’ E}\n    (h : âˆ€áµ x, x âˆˆ Î™ a b â†’ â€–f xâ€– â‰¤ C) : â€–âˆ« x in a..b, f xâ€– â‰¤ C * |b - a| := by\n  rw [norm_integral_eq_norm_integral_Ioc]\n  convert norm_setIntegral_le_of_norm_le_const_ae'' _ measurableSet_Ioc h using 1\n  Â· rw [Real.volume_Ioc, max_sub_min_eq_abs, ENNReal.toReal_ofReal (abs_nonneg _)]\n  Â· simp only [Real.volume_Ioc, ENNReal.ofReal_lt_top]\n\n"}
{"name":"intervalIntegral.norm_integral_le_of_norm_le_const","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b C : Real\nf : Real â†’ E\nh : âˆ€ (x : Real), Membership.mem (Set.uIoc a b) x â†’ LE.le (Norm.norm (f x)) C\nâŠ¢ LE.le (Norm.norm (intervalIntegral (fun x => f x) a b MeasureTheory.MeasureSpace.volume)) (HMul.hMul C (abs (HSub.hSub b a)))","decl":"theorem norm_integral_le_of_norm_le_const {a b C : â„} {f : â„ â†’ E} (h : âˆ€ x âˆˆ Î™ a b, â€–f xâ€– â‰¤ C) :\n    â€–âˆ« x in a..b, f xâ€– â‰¤ C * |b - a| :=\n  norm_integral_le_of_norm_le_const_ae <| Eventually.of_forall h\n\n"}
{"name":"intervalIntegral.integral_add","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf g : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\nhf : IntervalIntegrable f Î¼ a b\nhg : IntervalIntegrable g Î¼ a b\nâŠ¢ Eq (intervalIntegral (fun x => HAdd.hAdd (f x) (g x)) a b Î¼) (HAdd.hAdd (intervalIntegral (fun x => f x) a b Î¼) (intervalIntegral (fun x => g x) a b Î¼))","decl":"@[simp]\nnonrec theorem integral_add (hf : IntervalIntegrable f Î¼ a b) (hg : IntervalIntegrable g Î¼ a b) :\n    âˆ« x in a..b, f x + g x âˆ‚Î¼ = (âˆ« x in a..b, f x âˆ‚Î¼) + âˆ« x in a..b, g x âˆ‚Î¼ := by\n  simp only [intervalIntegral_eq_integral_uIoc, integral_add hf.def' hg.def', smul_add]\n\n"}
{"name":"intervalIntegral.integral_finset_sum","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nÎ¹ : Type u_6\ns : Finset Î¹\nf : Î¹ â†’ Real â†’ E\nh : âˆ€ (i : Î¹), Membership.mem s i â†’ IntervalIntegrable (f i) Î¼ a b\nâŠ¢ Eq (intervalIntegral (fun x => s.sum fun i => f i x) a b Î¼) (s.sum fun i => intervalIntegral (fun x => f i x) a b Î¼)","decl":"nonrec theorem integral_finset_sum {Î¹} {s : Finset Î¹} {f : Î¹ â†’ â„ â†’ E}\n    (h : âˆ€ i âˆˆ s, IntervalIntegrable (f i) Î¼ a b) :\n    âˆ« x in a..b, âˆ‘ i âˆˆ s, f i x âˆ‚Î¼ = âˆ‘ i âˆˆ s, âˆ« x in a..b, f i x âˆ‚Î¼ := by\n  simp only [intervalIntegral_eq_integral_uIoc, integral_finset_sum s fun i hi => (h i hi).def',\n    Finset.smul_sum]\n\n"}
{"name":"intervalIntegral.integral_neg","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\nâŠ¢ Eq (intervalIntegral (fun x => Neg.neg (f x)) a b Î¼) (Neg.neg (intervalIntegral (fun x => f x) a b Î¼))","decl":"@[simp]\nnonrec theorem integral_neg : âˆ« x in a..b, -f x âˆ‚Î¼ = -âˆ« x in a..b, f x âˆ‚Î¼ := by\n  simp only [intervalIntegral, integral_neg]; abel\n\n"}
{"name":"intervalIntegral.integral_sub","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf g : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\nhf : IntervalIntegrable f Î¼ a b\nhg : IntervalIntegrable g Î¼ a b\nâŠ¢ Eq (intervalIntegral (fun x => HSub.hSub (f x) (g x)) a b Î¼) (HSub.hSub (intervalIntegral (fun x => f x) a b Î¼) (intervalIntegral (fun x => g x) a b Î¼))","decl":"@[simp]\ntheorem integral_sub (hf : IntervalIntegrable f Î¼ a b) (hg : IntervalIntegrable g Î¼ a b) :\n    âˆ« x in a..b, f x - g x âˆ‚Î¼ = (âˆ« x in a..b, f x âˆ‚Î¼) - âˆ« x in a..b, g x âˆ‚Î¼ := by\n  simpa only [sub_eq_add_neg] using (integral_add hf hg.neg).trans (congr_arg _ integral_neg)\n\n"}
{"name":"intervalIntegral.integral_smul","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nğ•œ : Type u_6\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : SMulCommClass Real ğ•œ E\nr : ğ•œ\nf : Real â†’ E\nâŠ¢ Eq (intervalIntegral (fun x => HSMul.hSMul r (f x)) a b Î¼) (HSMul.hSMul r (intervalIntegral (fun x => f x) a b Î¼))","decl":"@[simp]\nnonrec theorem integral_smul {ğ•œ : Type*} [NontriviallyNormedField ğ•œ] [NormedSpace ğ•œ E]\n    [SMulCommClass â„ ğ•œ E] (r : ğ•œ) (f : â„ â†’ E) :\n    âˆ« x in a..b, r â€¢ f x âˆ‚Î¼ = r â€¢ âˆ« x in a..b, f x âˆ‚Î¼ := by\n  simp only [intervalIntegral, integral_smul, smul_sub]\n\n"}
{"name":"intervalIntegral.integral_smul_const","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\ninstâœÂ² : CompleteSpace E\nğ•œ : Type u_6\ninstâœÂ¹ : RCLike ğ•œ\ninstâœ : NormedSpace ğ•œ E\nf : Real â†’ ğ•œ\nc : E\nâŠ¢ Eq (intervalIntegral (fun x => HSMul.hSMul (f x) c) a b Î¼) (HSMul.hSMul (intervalIntegral (fun x => f x) a b Î¼) c)","decl":"@[simp]\nnonrec theorem integral_smul_const [CompleteSpace E]\n    {ğ•œ : Type*} [RCLike ğ•œ] [NormedSpace ğ•œ E] (f : â„ â†’ ğ•œ) (c : E) :\n    âˆ« x in a..b, f x â€¢ c âˆ‚Î¼ = (âˆ« x in a..b, f x âˆ‚Î¼) â€¢ c := by\n  simp only [intervalIntegral_eq_integral_uIoc, integral_smul_const, smul_assoc]\n\n"}
{"name":"intervalIntegral.integral_const_mul","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"a b : Real\nÎ¼ : MeasureTheory.Measure Real\nğ•œ : Type u_6\ninstâœ : RCLike ğ•œ\nr : ğ•œ\nf : Real â†’ ğ•œ\nâŠ¢ Eq (intervalIntegral (fun x => HMul.hMul r (f x)) a b Î¼) (HMul.hMul r (intervalIntegral (fun x => f x) a b Î¼))","decl":"@[simp]\ntheorem integral_const_mul {ğ•œ : Type*} [RCLike ğ•œ] (r : ğ•œ) (f : â„ â†’ ğ•œ) :\n    âˆ« x in a..b, r * f x âˆ‚Î¼ = r * âˆ« x in a..b, f x âˆ‚Î¼ :=\n  integral_smul r f\n\n"}
{"name":"intervalIntegral.integral_mul_const","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"a b : Real\nÎ¼ : MeasureTheory.Measure Real\nğ•œ : Type u_6\ninstâœ : RCLike ğ•œ\nr : ğ•œ\nf : Real â†’ ğ•œ\nâŠ¢ Eq (intervalIntegral (fun x => HMul.hMul (f x) r) a b Î¼) (HMul.hMul (intervalIntegral (fun x => f x) a b Î¼) r)","decl":"@[simp]\ntheorem integral_mul_const {ğ•œ : Type*} [RCLike ğ•œ] (r : ğ•œ) (f : â„ â†’ ğ•œ) :\n    âˆ« x in a..b, f x * r âˆ‚Î¼ = (âˆ« x in a..b, f x âˆ‚Î¼) * r := by\n  simpa only [mul_comm r] using integral_const_mul r f\n\n"}
{"name":"intervalIntegral.integral_div","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"a b : Real\nÎ¼ : MeasureTheory.Measure Real\nğ•œ : Type u_6\ninstâœ : RCLike ğ•œ\nr : ğ•œ\nf : Real â†’ ğ•œ\nâŠ¢ Eq (intervalIntegral (fun x => HDiv.hDiv (f x) r) a b Î¼) (HDiv.hDiv (intervalIntegral (fun x => f x) a b Î¼) r)","decl":"@[simp]\ntheorem integral_div {ğ•œ : Type*} [RCLike ğ•œ] (r : ğ•œ) (f : â„ â†’ ğ•œ) :\n    âˆ« x in a..b, f x / r âˆ‚Î¼ = (âˆ« x in a..b, f x âˆ‚Î¼) / r := by\n  simpa only [div_eq_mul_inv] using integral_mul_const râ»Â¹ f\n\n"}
{"name":"intervalIntegral.integral_const'","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\ninstâœ : CompleteSpace E\nc : E\nâŠ¢ Eq (intervalIntegral (fun x => c) a b Î¼) (HSMul.hSMul (HSub.hSub (Î¼ (Set.Ioc a b)).toReal (Î¼ (Set.Ioc b a)).toReal) c)","decl":"theorem integral_const' [CompleteSpace E] (c : E) :\n    âˆ« _ in a..b, c âˆ‚Î¼ = ((Î¼ <| Ioc a b).toReal - (Î¼ <| Ioc b a).toReal) â€¢ c := by\n  simp only [intervalIntegral, setIntegral_const, sub_smul]\n\n"}
{"name":"intervalIntegral.integral_const","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\na b : Real\ninstâœ : CompleteSpace E\nc : E\nâŠ¢ Eq (intervalIntegral (fun x => c) a b MeasureTheory.MeasureSpace.volume) (HSMul.hSMul (HSub.hSub b a) c)","decl":"@[simp]\ntheorem integral_const [CompleteSpace E] (c : E) : âˆ« _ in a..b, c = (b - a) â€¢ c := by\n  simp only [integral_const', Real.volume_Ioc, ENNReal.toReal_ofReal', â† neg_sub b,\n    max_zero_sub_eq_self]\n\n"}
{"name":"intervalIntegral.integral_smul_measure","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\nc : ENNReal\nâŠ¢ Eq (intervalIntegral (fun x => f x) a b (HSMul.hSMul c Î¼)) (HSMul.hSMul c.toReal (intervalIntegral (fun x => f x) a b Î¼))","decl":"nonrec theorem integral_smul_measure (c : â„â‰¥0âˆ) :\n    âˆ« x in a..b, f x âˆ‚c â€¢ Î¼ = c.toReal â€¢ âˆ« x in a..b, f x âˆ‚Î¼ := by\n  simp only [intervalIntegral, Measure.restrict_smul, integral_smul_measure, smul_sub]\n\n"}
{"name":"RCLike.intervalIntegral_ofReal","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"ğ•œ : Type u_6\ninstâœ : RCLike ğ•œ\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nf : Real â†’ Real\nâŠ¢ Eq (intervalIntegral (fun x => â†‘(f x)) a b Î¼) â†‘(intervalIntegral (fun x => f x) a b Î¼)","decl":"nonrec theorem _root_.RCLike.intervalIntegral_ofReal {ğ•œ : Type*} [RCLike ğ•œ] {a b : â„}\n    {Î¼ : Measure â„} {f : â„ â†’ â„} : (âˆ« x in a..b, (f x : ğ•œ) âˆ‚Î¼) = â†‘(âˆ« x in a..b, f x âˆ‚Î¼) := by\n  simp only [intervalIntegral, integral_ofReal, RCLike.ofReal_sub]\n\n"}
{"name":"intervalIntegral.integral_ofReal","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"a b : Real\nÎ¼ : MeasureTheory.Measure Real\nf : Real â†’ Real\nâŠ¢ Eq (intervalIntegral (fun x => â†‘(f x)) a b Î¼) â†‘(intervalIntegral (fun x => f x) a b Î¼)","decl":"nonrec theorem integral_ofReal {a b : â„} {Î¼ : Measure â„} {f : â„ â†’ â„} :\n    (âˆ« x in a..b, (f x : â„‚) âˆ‚Î¼) = â†‘(âˆ« x in a..b, f x âˆ‚Î¼) :=\n  RCLike.intervalIntegral_ofReal\n\n"}
{"name":"ContinuousLinearMap.intervalIntegral_apply","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"ğ•œ : Type u_2\nE : Type u_3\nF : Type u_4\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\nÎ¼ : MeasureTheory.Measure Real\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\na b : Real\nÏ† : Real â†’ ContinuousLinearMap (RingHom.id ğ•œ) F E\nhÏ† : IntervalIntegrable Ï† Î¼ a b\nv : F\nâŠ¢ Eq ((intervalIntegral (fun x => Ï† x) a b Î¼) v) (intervalIntegral (fun x => (Ï† x) v) a b Î¼)","decl":"theorem _root_.ContinuousLinearMap.intervalIntegral_apply {a b : â„} {Ï† : â„ â†’ F â†’L[ğ•œ] E}\n    (hÏ† : IntervalIntegrable Ï† Î¼ a b) (v : F) :\n    (âˆ« x in a..b, Ï† x âˆ‚Î¼) v = âˆ« x in a..b, Ï† x v âˆ‚Î¼ := by\n  simp_rw [intervalIntegral_eq_integral_uIoc, â† integral_apply hÏ†.def' v, coe_smul', Pi.smul_apply]\n\n"}
{"name":"ContinuousLinearMap.intervalIntegral_comp_comm","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"ğ•œ : Type u_2\nE : Type u_3\nF : Type u_4\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace Real E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nf : Real â†’ E\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : NormedSpace ğ•œ E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace ğ•œ F\ninstâœÂ² : NormedSpace Real F\ninstâœÂ¹ : CompleteSpace F\ninstâœ : CompleteSpace E\nL : ContinuousLinearMap (RingHom.id ğ•œ) E F\nhf : IntervalIntegrable f Î¼ a b\nâŠ¢ Eq (intervalIntegral (fun x => L (f x)) a b Î¼) (L (intervalIntegral (fun x => f x) a b Î¼))","decl":"theorem _root_.ContinuousLinearMap.intervalIntegral_comp_comm [CompleteSpace E] (L : E â†’L[ğ•œ] F)\n    (hf : IntervalIntegrable f Î¼ a b) : (âˆ« x in a..b, L (f x) âˆ‚Î¼) = L (âˆ« x in a..b, f x âˆ‚Î¼) := by\n  simp_rw [intervalIntegral, L.integral_comp_comm hf.1, L.integral_comp_comm hf.2, L.map_sub]\n\n"}
{"name":"intervalIntegral.integral_comp_mul_right","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b c : Real\nf : Real â†’ E\nhc : Ne c 0\nâŠ¢ Eq (intervalIntegral (fun x => f (HMul.hMul x c)) a b MeasureTheory.MeasureSpace.volume) (HSMul.hSMul (Inv.inv c) (intervalIntegral (fun x => f x) (HMul.hMul a c) (HMul.hMul b c) MeasureTheory.MeasureSpace.volume))","decl":"@[simp]\ntheorem integral_comp_mul_right (hc : c â‰  0) :\n    (âˆ« x in a..b, f (x * c)) = câ»Â¹ â€¢ âˆ« x in a * c..b * c, f x := by\n  have A : MeasurableEmbedding fun x => x * c :=\n    (Homeomorph.mulRightâ‚€ c hc).isClosedEmbedding.measurableEmbedding\n  conv_rhs => rw [â† Real.smul_map_volume_mul_right hc]\n  simp_rw [integral_smul_measure, intervalIntegral, A.setIntegral_map,\n    ENNReal.toReal_ofReal (abs_nonneg c)]\n  cases' hc.lt_or_lt with h h\n  Â· simp [h, mul_div_cancel_rightâ‚€, hc, abs_of_neg,\n      Measure.restrict_congr_set (Î± := â„) (Î¼ := volume) Ico_ae_eq_Ioc]\n  Â· simp [h, mul_div_cancel_rightâ‚€, hc, abs_of_pos]\n\n"}
{"name":"intervalIntegral.smul_integral_comp_mul_right","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf : Real â†’ E\nc : Real\nâŠ¢ Eq (HSMul.hSMul c (intervalIntegral (fun x => f (HMul.hMul x c)) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HMul.hMul a c) (HMul.hMul b c) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem smul_integral_comp_mul_right (c) :\n    (c â€¢ âˆ« x in a..b, f (x * c)) = âˆ« x in a * c..b * c, f x := by\n  by_cases hc : c = 0 <;> simp [hc, integral_comp_mul_right]\n\n"}
{"name":"intervalIntegral.integral_comp_mul_left","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b c : Real\nf : Real â†’ E\nhc : Ne c 0\nâŠ¢ Eq (intervalIntegral (fun x => f (HMul.hMul c x)) a b MeasureTheory.MeasureSpace.volume) (HSMul.hSMul (Inv.inv c) (intervalIntegral (fun x => f x) (HMul.hMul c a) (HMul.hMul c b) MeasureTheory.MeasureSpace.volume))","decl":"@[simp]\ntheorem integral_comp_mul_left (hc : c â‰  0) :\n    (âˆ« x in a..b, f (c * x)) = câ»Â¹ â€¢ âˆ« x in c * a..c * b, f x := by\n  simpa only [mul_comm c] using integral_comp_mul_right f hc\n\n"}
{"name":"intervalIntegral.smul_integral_comp_mul_left","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf : Real â†’ E\nc : Real\nâŠ¢ Eq (HSMul.hSMul c (intervalIntegral (fun x => f (HMul.hMul c x)) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HMul.hMul c a) (HMul.hMul c b) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem smul_integral_comp_mul_left (c) :\n    (c â€¢ âˆ« x in a..b, f (c * x)) = âˆ« x in c * a..c * b, f x := by\n  by_cases hc : c = 0 <;> simp [hc, integral_comp_mul_left]\n\n"}
{"name":"intervalIntegral.integral_comp_div","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b c : Real\nf : Real â†’ E\nhc : Ne c 0\nâŠ¢ Eq (intervalIntegral (fun x => f (HDiv.hDiv x c)) a b MeasureTheory.MeasureSpace.volume) (HSMul.hSMul c (intervalIntegral (fun x => f x) (HDiv.hDiv a c) (HDiv.hDiv b c) MeasureTheory.MeasureSpace.volume))","decl":"@[simp]\ntheorem integral_comp_div (hc : c â‰  0) :\n    (âˆ« x in a..b, f (x / c)) = c â€¢ âˆ« x in a / c..b / c, f x := by\n  simpa only [inv_inv] using integral_comp_mul_right f (inv_ne_zero hc)\n\n"}
{"name":"intervalIntegral.inv_smul_integral_comp_div","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf : Real â†’ E\nc : Real\nâŠ¢ Eq (HSMul.hSMul (Inv.inv c) (intervalIntegral (fun x => f (HDiv.hDiv x c)) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HDiv.hDiv a c) (HDiv.hDiv b c) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem inv_smul_integral_comp_div (c) :\n    (câ»Â¹ â€¢ âˆ« x in a..b, f (x / c)) = âˆ« x in a / c..b / c, f x := by\n  by_cases hc : c = 0 <;> simp [hc, integral_comp_div]\n\n"}
{"name":"intervalIntegral.integral_comp_add_right","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf : Real â†’ E\nd : Real\nâŠ¢ Eq (intervalIntegral (fun x => f (HAdd.hAdd x d)) a b MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => f x) (HAdd.hAdd a d) (HAdd.hAdd b d) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem integral_comp_add_right (d) : (âˆ« x in a..b, f (x + d)) = âˆ« x in a + d..b + d, f x :=\n  have A : MeasurableEmbedding fun x => x + d :=\n    (Homeomorph.addRight d).isClosedEmbedding.measurableEmbedding\n  calc\n    (âˆ« x in a..b, f (x + d)) = âˆ« x in a + d..b + d, f x âˆ‚Measure.map (fun x => x + d) volume := by\n      simp [intervalIntegral, A.setIntegral_map]\n    _ = âˆ« x in a + d..b + d, f x := by rw [map_add_right_eq_self]\n\n"}
{"name":"intervalIntegral.integral_comp_add_left","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf : Real â†’ E\nd : Real\nâŠ¢ Eq (intervalIntegral (fun x => f (HAdd.hAdd d x)) a b MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => f x) (HAdd.hAdd d a) (HAdd.hAdd d b) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\nnonrec theorem integral_comp_add_left (d) :\n    (âˆ« x in a..b, f (d + x)) = âˆ« x in d + a..d + b, f x := by\n  simpa only [add_comm d] using integral_comp_add_right f d\n\n"}
{"name":"intervalIntegral.integral_comp_mul_add","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b c : Real\nf : Real â†’ E\nhc : Ne c 0\nd : Real\nâŠ¢ Eq (intervalIntegral (fun x => f (HAdd.hAdd (HMul.hMul c x) d)) a b MeasureTheory.MeasureSpace.volume) (HSMul.hSMul (Inv.inv c) (intervalIntegral (fun x => f x) (HAdd.hAdd (HMul.hMul c a) d) (HAdd.hAdd (HMul.hMul c b) d) MeasureTheory.MeasureSpace.volume))","decl":"@[simp]\ntheorem integral_comp_mul_add (hc : c â‰  0) (d) :\n    (âˆ« x in a..b, f (c * x + d)) = câ»Â¹ â€¢ âˆ« x in c * a + d..c * b + d, f x := by\n  rw [â† integral_comp_add_right, â† integral_comp_mul_left _ hc]\n\n"}
{"name":"intervalIntegral.smul_integral_comp_mul_add","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf : Real â†’ E\nc d : Real\nâŠ¢ Eq (HSMul.hSMul c (intervalIntegral (fun x => f (HAdd.hAdd (HMul.hMul c x) d)) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HAdd.hAdd (HMul.hMul c a) d) (HAdd.hAdd (HMul.hMul c b) d) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem smul_integral_comp_mul_add (c d) :\n    (c â€¢ âˆ« x in a..b, f (c * x + d)) = âˆ« x in c * a + d..c * b + d, f x := by\n  by_cases hc : c = 0 <;> simp [hc, integral_comp_mul_add]\n\n"}
{"name":"intervalIntegral.integral_comp_add_mul","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b c : Real\nf : Real â†’ E\nhc : Ne c 0\nd : Real\nâŠ¢ Eq (intervalIntegral (fun x => f (HAdd.hAdd d (HMul.hMul c x))) a b MeasureTheory.MeasureSpace.volume) (HSMul.hSMul (Inv.inv c) (intervalIntegral (fun x => f x) (HAdd.hAdd d (HMul.hMul c a)) (HAdd.hAdd d (HMul.hMul c b)) MeasureTheory.MeasureSpace.volume))","decl":"@[simp]\ntheorem integral_comp_add_mul (hc : c â‰  0) (d) :\n    (âˆ« x in a..b, f (d + c * x)) = câ»Â¹ â€¢ âˆ« x in d + c * a..d + c * b, f x := by\n  rw [â† integral_comp_add_left, â† integral_comp_mul_left _ hc]\n\n"}
{"name":"intervalIntegral.smul_integral_comp_add_mul","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf : Real â†’ E\nc d : Real\nâŠ¢ Eq (HSMul.hSMul c (intervalIntegral (fun x => f (HAdd.hAdd d (HMul.hMul c x))) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HAdd.hAdd d (HMul.hMul c a)) (HAdd.hAdd d (HMul.hMul c b)) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem smul_integral_comp_add_mul (c d) :\n    (c â€¢ âˆ« x in a..b, f (d + c * x)) = âˆ« x in d + c * a..d + c * b, f x := by\n  by_cases hc : c = 0 <;> simp [hc, integral_comp_add_mul]\n\n"}
{"name":"intervalIntegral.integral_comp_div_add","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b c : Real\nf : Real â†’ E\nhc : Ne c 0\nd : Real\nâŠ¢ Eq (intervalIntegral (fun x => f (HAdd.hAdd (HDiv.hDiv x c) d)) a b MeasureTheory.MeasureSpace.volume) (HSMul.hSMul c (intervalIntegral (fun x => f x) (HAdd.hAdd (HDiv.hDiv a c) d) (HAdd.hAdd (HDiv.hDiv b c) d) MeasureTheory.MeasureSpace.volume))","decl":"@[simp]\ntheorem integral_comp_div_add (hc : c â‰  0) (d) :\n    (âˆ« x in a..b, f (x / c + d)) = c â€¢ âˆ« x in a / c + d..b / c + d, f x := by\n  simpa only [div_eq_inv_mul, inv_inv] using integral_comp_mul_add f (inv_ne_zero hc) d\n\n"}
{"name":"intervalIntegral.inv_smul_integral_comp_div_add","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf : Real â†’ E\nc d : Real\nâŠ¢ Eq (HSMul.hSMul (Inv.inv c) (intervalIntegral (fun x => f (HAdd.hAdd (HDiv.hDiv x c) d)) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HAdd.hAdd (HDiv.hDiv a c) d) (HAdd.hAdd (HDiv.hDiv b c) d) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem inv_smul_integral_comp_div_add (c d) :\n    (câ»Â¹ â€¢ âˆ« x in a..b, f (x / c + d)) = âˆ« x in a / c + d..b / c + d, f x := by\n  by_cases hc : c = 0 <;> simp [hc, integral_comp_div_add]\n\n"}
{"name":"intervalIntegral.integral_comp_add_div","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b c : Real\nf : Real â†’ E\nhc : Ne c 0\nd : Real\nâŠ¢ Eq (intervalIntegral (fun x => f (HAdd.hAdd d (HDiv.hDiv x c))) a b MeasureTheory.MeasureSpace.volume) (HSMul.hSMul c (intervalIntegral (fun x => f x) (HAdd.hAdd d (HDiv.hDiv a c)) (HAdd.hAdd d (HDiv.hDiv b c)) MeasureTheory.MeasureSpace.volume))","decl":"@[simp]\ntheorem integral_comp_add_div (hc : c â‰  0) (d) :\n    (âˆ« x in a..b, f (d + x / c)) = c â€¢ âˆ« x in d + a / c..d + b / c, f x := by\n  simpa only [div_eq_inv_mul, inv_inv] using integral_comp_add_mul f (inv_ne_zero hc) d\n\n"}
{"name":"intervalIntegral.inv_smul_integral_comp_add_div","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf : Real â†’ E\nc d : Real\nâŠ¢ Eq (HSMul.hSMul (Inv.inv c) (intervalIntegral (fun x => f (HAdd.hAdd d (HDiv.hDiv x c))) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HAdd.hAdd d (HDiv.hDiv a c)) (HAdd.hAdd d (HDiv.hDiv b c)) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem inv_smul_integral_comp_add_div (c d) :\n    (câ»Â¹ â€¢ âˆ« x in a..b, f (d + x / c)) = âˆ« x in d + a / c..d + b / c, f x := by\n  by_cases hc : c = 0 <;> simp [hc, integral_comp_add_div]\n\n"}
{"name":"intervalIntegral.integral_comp_mul_sub","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b c : Real\nf : Real â†’ E\nhc : Ne c 0\nd : Real\nâŠ¢ Eq (intervalIntegral (fun x => f (HSub.hSub (HMul.hMul c x) d)) a b MeasureTheory.MeasureSpace.volume) (HSMul.hSMul (Inv.inv c) (intervalIntegral (fun x => f x) (HSub.hSub (HMul.hMul c a) d) (HSub.hSub (HMul.hMul c b) d) MeasureTheory.MeasureSpace.volume))","decl":"@[simp]\ntheorem integral_comp_mul_sub (hc : c â‰  0) (d) :\n    (âˆ« x in a..b, f (c * x - d)) = câ»Â¹ â€¢ âˆ« x in c * a - d..c * b - d, f x := by\n  simpa only [sub_eq_add_neg] using integral_comp_mul_add f hc (-d)\n\n"}
{"name":"intervalIntegral.smul_integral_comp_mul_sub","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf : Real â†’ E\nc d : Real\nâŠ¢ Eq (HSMul.hSMul c (intervalIntegral (fun x => f (HSub.hSub (HMul.hMul c x) d)) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HSub.hSub (HMul.hMul c a) d) (HSub.hSub (HMul.hMul c b) d) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem smul_integral_comp_mul_sub (c d) :\n    (c â€¢ âˆ« x in a..b, f (c * x - d)) = âˆ« x in c * a - d..c * b - d, f x := by\n  by_cases hc : c = 0 <;> simp [hc, integral_comp_mul_sub]\n\n"}
{"name":"intervalIntegral.integral_comp_sub_mul","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b c : Real\nf : Real â†’ E\nhc : Ne c 0\nd : Real\nâŠ¢ Eq (intervalIntegral (fun x => f (HSub.hSub d (HMul.hMul c x))) a b MeasureTheory.MeasureSpace.volume) (HSMul.hSMul (Inv.inv c) (intervalIntegral (fun x => f x) (HSub.hSub d (HMul.hMul c b)) (HSub.hSub d (HMul.hMul c a)) MeasureTheory.MeasureSpace.volume))","decl":"@[simp]\ntheorem integral_comp_sub_mul (hc : c â‰  0) (d) :\n    (âˆ« x in a..b, f (d - c * x)) = câ»Â¹ â€¢ âˆ« x in d - c * b..d - c * a, f x := by\n  simp only [sub_eq_add_neg, neg_mul_eq_neg_mul]\n  rw [integral_comp_add_mul f (neg_ne_zero.mpr hc) d, integral_symm]\n  simp only [inv_neg, smul_neg, neg_neg, neg_smul]\n\n"}
{"name":"intervalIntegral.smul_integral_comp_sub_mul","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf : Real â†’ E\nc d : Real\nâŠ¢ Eq (HSMul.hSMul c (intervalIntegral (fun x => f (HSub.hSub d (HMul.hMul c x))) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HSub.hSub d (HMul.hMul c b)) (HSub.hSub d (HMul.hMul c a)) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem smul_integral_comp_sub_mul (c d) :\n    (c â€¢ âˆ« x in a..b, f (d - c * x)) = âˆ« x in d - c * b..d - c * a, f x := by\n  by_cases hc : c = 0 <;> simp [hc, integral_comp_sub_mul]\n\n"}
{"name":"intervalIntegral.integral_comp_div_sub","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b c : Real\nf : Real â†’ E\nhc : Ne c 0\nd : Real\nâŠ¢ Eq (intervalIntegral (fun x => f (HSub.hSub (HDiv.hDiv x c) d)) a b MeasureTheory.MeasureSpace.volume) (HSMul.hSMul c (intervalIntegral (fun x => f x) (HSub.hSub (HDiv.hDiv a c) d) (HSub.hSub (HDiv.hDiv b c) d) MeasureTheory.MeasureSpace.volume))","decl":"@[simp]\ntheorem integral_comp_div_sub (hc : c â‰  0) (d) :\n    (âˆ« x in a..b, f (x / c - d)) = c â€¢ âˆ« x in a / c - d..b / c - d, f x := by\n  simpa only [div_eq_inv_mul, inv_inv] using integral_comp_mul_sub f (inv_ne_zero hc) d\n\n"}
{"name":"intervalIntegral.inv_smul_integral_comp_div_sub","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf : Real â†’ E\nc d : Real\nâŠ¢ Eq (HSMul.hSMul (Inv.inv c) (intervalIntegral (fun x => f (HSub.hSub (HDiv.hDiv x c) d)) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HSub.hSub (HDiv.hDiv a c) d) (HSub.hSub (HDiv.hDiv b c) d) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem inv_smul_integral_comp_div_sub (c d) :\n    (câ»Â¹ â€¢ âˆ« x in a..b, f (x / c - d)) = âˆ« x in a / c - d..b / c - d, f x := by\n  by_cases hc : c = 0 <;> simp [hc, integral_comp_div_sub]\n\n"}
{"name":"intervalIntegral.integral_comp_sub_div","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b c : Real\nf : Real â†’ E\nhc : Ne c 0\nd : Real\nâŠ¢ Eq (intervalIntegral (fun x => f (HSub.hSub d (HDiv.hDiv x c))) a b MeasureTheory.MeasureSpace.volume) (HSMul.hSMul c (intervalIntegral (fun x => f x) (HSub.hSub d (HDiv.hDiv b c)) (HSub.hSub d (HDiv.hDiv a c)) MeasureTheory.MeasureSpace.volume))","decl":"@[simp]\ntheorem integral_comp_sub_div (hc : c â‰  0) (d) :\n    (âˆ« x in a..b, f (d - x / c)) = c â€¢ âˆ« x in d - b / c..d - a / c, f x := by\n  simpa only [div_eq_inv_mul, inv_inv] using integral_comp_sub_mul f (inv_ne_zero hc) d\n\n"}
{"name":"intervalIntegral.inv_smul_integral_comp_sub_div","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf : Real â†’ E\nc d : Real\nâŠ¢ Eq (HSMul.hSMul (Inv.inv c) (intervalIntegral (fun x => f (HSub.hSub d (HDiv.hDiv x c))) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HSub.hSub d (HDiv.hDiv b c)) (HSub.hSub d (HDiv.hDiv a c)) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem inv_smul_integral_comp_sub_div (c d) :\n    (câ»Â¹ â€¢ âˆ« x in a..b, f (d - x / c)) = âˆ« x in d - b / c..d - a / c, f x := by\n  by_cases hc : c = 0 <;> simp [hc, integral_comp_sub_div]\n\n"}
{"name":"intervalIntegral.integral_comp_sub_right","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf : Real â†’ E\nd : Real\nâŠ¢ Eq (intervalIntegral (fun x => f (HSub.hSub x d)) a b MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => f x) (HSub.hSub a d) (HSub.hSub b d) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem integral_comp_sub_right (d) : (âˆ« x in a..b, f (x - d)) = âˆ« x in a - d..b - d, f x := by\n  simpa only [sub_eq_add_neg] using integral_comp_add_right f (-d)\n\n"}
{"name":"intervalIntegral.integral_comp_sub_left","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf : Real â†’ E\nd : Real\nâŠ¢ Eq (intervalIntegral (fun x => f (HSub.hSub d x)) a b MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => f x) (HSub.hSub d b) (HSub.hSub d a) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem integral_comp_sub_left (d) : (âˆ« x in a..b, f (d - x)) = âˆ« x in d - b..d - a, f x := by\n  simpa only [one_mul, one_smul, inv_one] using integral_comp_sub_mul f one_ne_zero d\n\n"}
{"name":"intervalIntegral.integral_comp_neg","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf : Real â†’ E\nâŠ¢ Eq (intervalIntegral (fun x => f (Neg.neg x)) a b MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => f x) (Neg.neg b) (Neg.neg a) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem integral_comp_neg : (âˆ« x in a..b, f (-x)) = âˆ« x in -b..-a, f x := by\n  simpa only [zero_sub] using integral_comp_sub_left f 0\n\n"}
{"name":"intervalIntegral.integral_congr","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf g : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\na b : Real\nh : Set.EqOn f g (Set.uIcc a b)\nâŠ¢ Eq (intervalIntegral (fun x => f x) a b Î¼) (intervalIntegral (fun x => g x) a b Î¼)","decl":"/-- If two functions are equal in the relevant interval, their interval integrals are also equal. -/\ntheorem integral_congr {a b : â„} (h : EqOn f g [[a, b]]) :\n    âˆ« x in a..b, f x âˆ‚Î¼ = âˆ« x in a..b, g x âˆ‚Î¼ := by\n  rcases le_total a b with hab | hab <;>\n    simpa [hab, integral_of_le, integral_of_ge] using\n      setIntegral_congr_fun measurableSet_Ioc (h.mono Ioc_subset_Icc_self)\n\n"}
{"name":"intervalIntegral.integral_add_adjacent_intervals_cancel","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b c : Real\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\nhab : IntervalIntegrable f Î¼ a b\nhbc : IntervalIntegrable f Î¼ b c\nâŠ¢ Eq (HAdd.hAdd (HAdd.hAdd (intervalIntegral (fun x => f x) a b Î¼) (intervalIntegral (fun x => f x) b c Î¼)) (intervalIntegral (fun x => f x) c a Î¼)) 0","decl":"theorem integral_add_adjacent_intervals_cancel (hab : IntervalIntegrable f Î¼ a b)\n    (hbc : IntervalIntegrable f Î¼ b c) :\n    (((âˆ« x in a..b, f x âˆ‚Î¼) + âˆ« x in b..c, f x âˆ‚Î¼) + âˆ« x in c..a, f x âˆ‚Î¼) = 0 := by\n  have hac := hab.trans hbc\n  simp only [intervalIntegral, sub_add_sub_comm, sub_eq_zero]\n  iterate 4 rw [â† setIntegral_union]\n  Â· suffices Ioc a b âˆª Ioc b c âˆª Ioc c a = Ioc b a âˆª Ioc c b âˆª Ioc a c by rw [this]\n    rw [Ioc_union_Ioc_union_Ioc_cycle, union_right_comm, Ioc_union_Ioc_union_Ioc_cycle,\n      min_left_comm, max_left_comm]\n  all_goals\n    simp [*, MeasurableSet.union, measurableSet_Ioc, Ioc_disjoint_Ioc_same,\n      Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]\n\n"}
{"name":"intervalIntegral.integral_add_adjacent_intervals","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b c : Real\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\nhab : IntervalIntegrable f Î¼ a b\nhbc : IntervalIntegrable f Î¼ b c\nâŠ¢ Eq (HAdd.hAdd (intervalIntegral (fun x => f x) a b Î¼) (intervalIntegral (fun x => f x) b c Î¼)) (intervalIntegral (fun x => f x) a c Î¼)","decl":"theorem integral_add_adjacent_intervals (hab : IntervalIntegrable f Î¼ a b)\n    (hbc : IntervalIntegrable f Î¼ b c) :\n    ((âˆ« x in a..b, f x âˆ‚Î¼) + âˆ« x in b..c, f x âˆ‚Î¼) = âˆ« x in a..c, f x âˆ‚Î¼ := by\n  rw [â† add_neg_eq_zero, â† integral_symm, integral_add_adjacent_intervals_cancel hab hbc]\n\n"}
{"name":"intervalIntegral.sum_integral_adjacent_intervals_Ico","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\na : Nat â†’ Real\nm n : Nat\nhmn : LE.le m n\nhint : âˆ€ (k : Nat), Membership.mem (Set.Ico m n) k â†’ IntervalIntegrable f Î¼ (a k) (a (HAdd.hAdd k 1))\nâŠ¢ Eq ((Finset.Ico m n).sum fun k => intervalIntegral (fun x => f x) (a k) (a (HAdd.hAdd k 1)) Î¼) (intervalIntegral (fun x => f x) (a m) (a n) Î¼)","decl":"theorem sum_integral_adjacent_intervals_Ico {a : â„• â†’ â„} {m n : â„•} (hmn : m â‰¤ n)\n    (hint : âˆ€ k âˆˆ Ico m n, IntervalIntegrable f Î¼ (a k) (a <| k + 1)) :\n    âˆ‘ k âˆˆ Finset.Ico m n, âˆ« x in a k..a <| k + 1, f x âˆ‚Î¼ = âˆ« x in a m..a n, f x âˆ‚Î¼ := by\n  revert hint\n  refine Nat.le_induction ?_ ?_ n hmn\n  Â· simp\n  Â· intro p hmp IH h\n    rw [Finset.sum_Ico_succ_top hmp, IH, integral_add_adjacent_intervals]\n    Â· refine IntervalIntegrable.trans_iterate_Ico hmp fun k hk => h k ?_\n      exact (Ico_subset_Ico le_rfl (Nat.le_succ _)) hk\n    Â· apply h\n      simp [hmp]\n    Â· intro k hk\n      exact h _ (Ico_subset_Ico_right p.le_succ hk)\n\n"}
{"name":"intervalIntegral.sum_integral_adjacent_intervals","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\na : Nat â†’ Real\nn : Nat\nhint : âˆ€ (k : Nat), LT.lt k n â†’ IntervalIntegrable f Î¼ (a k) (a (HAdd.hAdd k 1))\nâŠ¢ Eq ((Finset.range n).sum fun k => intervalIntegral (fun x => f x) (a k) (a (HAdd.hAdd k 1)) Î¼) (intervalIntegral (fun x => f x) (a 0) (a n) Î¼)","decl":"theorem sum_integral_adjacent_intervals {a : â„• â†’ â„} {n : â„•}\n    (hint : âˆ€ k < n, IntervalIntegrable f Î¼ (a k) (a <| k + 1)) :\n    âˆ‘ k âˆˆ Finset.range n, âˆ« x in a k..a <| k + 1, f x âˆ‚Î¼ = âˆ« x in (a 0)..(a n), f x âˆ‚Î¼ := by\n  rw [â† Nat.Ico_zero_eq_range]\n  exact sum_integral_adjacent_intervals_Ico (zero_le n) fun k hk => hint k hk.2\n\n"}
{"name":"intervalIntegral.integral_interval_sub_left","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b c : Real\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\nhab : IntervalIntegrable f Î¼ a b\nhac : IntervalIntegrable f Î¼ a c\nâŠ¢ Eq (HSub.hSub (intervalIntegral (fun x => f x) a b Î¼) (intervalIntegral (fun x => f x) a c Î¼)) (intervalIntegral (fun x => f x) c b Î¼)","decl":"theorem integral_interval_sub_left (hab : IntervalIntegrable f Î¼ a b)\n    (hac : IntervalIntegrable f Î¼ a c) :\n    ((âˆ« x in a..b, f x âˆ‚Î¼) - âˆ« x in a..c, f x âˆ‚Î¼) = âˆ« x in c..b, f x âˆ‚Î¼ :=\n  sub_eq_of_eq_add' <| Eq.symm <| integral_add_adjacent_intervals hac (hac.symm.trans hab)\n\n"}
{"name":"intervalIntegral.integral_interval_add_interval_comm","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b c d : Real\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\nhab : IntervalIntegrable f Î¼ a b\nhcd : IntervalIntegrable f Î¼ c d\nhac : IntervalIntegrable f Î¼ a c\nâŠ¢ Eq (HAdd.hAdd (intervalIntegral (fun x => f x) a b Î¼) (intervalIntegral (fun x => f x) c d Î¼)) (HAdd.hAdd (intervalIntegral (fun x => f x) a d Î¼) (intervalIntegral (fun x => f x) c b Î¼))","decl":"theorem integral_interval_add_interval_comm (hab : IntervalIntegrable f Î¼ a b)\n    (hcd : IntervalIntegrable f Î¼ c d) (hac : IntervalIntegrable f Î¼ a c) :\n    ((âˆ« x in a..b, f x âˆ‚Î¼) + âˆ« x in c..d, f x âˆ‚Î¼) =\n      (âˆ« x in a..d, f x âˆ‚Î¼) + âˆ« x in c..b, f x âˆ‚Î¼ := by\n  rw [â† integral_add_adjacent_intervals hac hcd, add_assoc, add_left_comm,\n    integral_add_adjacent_intervals hac (hac.symm.trans hab), add_comm]\n\n"}
{"name":"intervalIntegral.integral_interval_sub_interval_comm","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b c d : Real\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\nhab : IntervalIntegrable f Î¼ a b\nhcd : IntervalIntegrable f Î¼ c d\nhac : IntervalIntegrable f Î¼ a c\nâŠ¢ Eq (HSub.hSub (intervalIntegral (fun x => f x) a b Î¼) (intervalIntegral (fun x => f x) c d Î¼)) (HSub.hSub (intervalIntegral (fun x => f x) a c Î¼) (intervalIntegral (fun x => f x) b d Î¼))","decl":"theorem integral_interval_sub_interval_comm (hab : IntervalIntegrable f Î¼ a b)\n    (hcd : IntervalIntegrable f Î¼ c d) (hac : IntervalIntegrable f Î¼ a c) :\n    ((âˆ« x in a..b, f x âˆ‚Î¼) - âˆ« x in c..d, f x âˆ‚Î¼) =\n      (âˆ« x in a..c, f x âˆ‚Î¼) - âˆ« x in b..d, f x âˆ‚Î¼ := by\n  simp only [sub_eq_add_neg, â† integral_symm,\n    integral_interval_add_interval_comm hab hcd.symm (hac.trans hcd)]\n\n"}
{"name":"intervalIntegral.integral_interval_sub_interval_comm'","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b c d : Real\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\nhab : IntervalIntegrable f Î¼ a b\nhcd : IntervalIntegrable f Î¼ c d\nhac : IntervalIntegrable f Î¼ a c\nâŠ¢ Eq (HSub.hSub (intervalIntegral (fun x => f x) a b Î¼) (intervalIntegral (fun x => f x) c d Î¼)) (HSub.hSub (intervalIntegral (fun x => f x) d b Î¼) (intervalIntegral (fun x => f x) c a Î¼))","decl":"theorem integral_interval_sub_interval_comm' (hab : IntervalIntegrable f Î¼ a b)\n    (hcd : IntervalIntegrable f Î¼ c d) (hac : IntervalIntegrable f Î¼ a c) :\n    ((âˆ« x in a..b, f x âˆ‚Î¼) - âˆ« x in c..d, f x âˆ‚Î¼) =\n      (âˆ« x in d..b, f x âˆ‚Î¼) - âˆ« x in c..a, f x âˆ‚Î¼ := by\n  rw [integral_interval_sub_interval_comm hab hcd hac, integral_symm b d, integral_symm a c,\n    sub_neg_eq_add, sub_eq_neg_add]\n\n"}
{"name":"intervalIntegral.integral_Iic_sub_Iic","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\nha : MeasureTheory.IntegrableOn f (Set.Iic a) Î¼\nhb : MeasureTheory.IntegrableOn f (Set.Iic b) Î¼\nâŠ¢ Eq (HSub.hSub (MeasureTheory.integral (Î¼.restrict (Set.Iic b)) fun x => f x) (MeasureTheory.integral (Î¼.restrict (Set.Iic a)) fun x => f x)) (intervalIntegral (fun x => f x) a b Î¼)","decl":"theorem integral_Iic_sub_Iic (ha : IntegrableOn f (Iic a) Î¼) (hb : IntegrableOn f (Iic b) Î¼) :\n    ((âˆ« x in Iic b, f x âˆ‚Î¼) - âˆ« x in Iic a, f x âˆ‚Î¼) = âˆ« x in a..b, f x âˆ‚Î¼ := by\n  wlog hab : a â‰¤ b generalizing a b\n  Â· rw [integral_symm, â† this hb ha (le_of_not_le hab), neg_sub]\n  rw [sub_eq_iff_eq_add', integral_of_le hab, â† setIntegral_union (Iic_disjoint_Ioc le_rfl),\n    Iic_union_Ioc_eq_Iic hab]\n  exacts [measurableSet_Ioc, ha, hb.mono_set fun _ => And.right]\n\n"}
{"name":"intervalIntegral.integral_Iic_add_Ioi","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nb : Real\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\nh_left : MeasureTheory.IntegrableOn f (Set.Iic b) Î¼\nh_right : MeasureTheory.IntegrableOn f (Set.Ioi b) Î¼\nâŠ¢ Eq (HAdd.hAdd (MeasureTheory.integral (Î¼.restrict (Set.Iic b)) fun x => f x) (MeasureTheory.integral (Î¼.restrict (Set.Ioi b)) fun x => f x)) (MeasureTheory.integral Î¼ fun x => f x)","decl":"theorem integral_Iic_add_Ioi (h_left : IntegrableOn f (Iic b) Î¼)\n    (h_right : IntegrableOn f (Ioi b) Î¼) :\n    (âˆ« x in Iic b, f x âˆ‚Î¼) + (âˆ« x in Ioi b, f x âˆ‚Î¼) = âˆ« (x : â„), f x âˆ‚Î¼ := by\n  convert (setIntegral_union (Iic_disjoint_Ioi <| Eq.le rfl) measurableSet_Ioi h_left h_right).symm\n  rw [Iic_union_Ioi, Measure.restrict_univ]\n\n"}
{"name":"intervalIntegral.integral_Iio_add_Ici","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nb : Real\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\nh_left : MeasureTheory.IntegrableOn f (Set.Iio b) Î¼\nh_right : MeasureTheory.IntegrableOn f (Set.Ici b) Î¼\nâŠ¢ Eq (HAdd.hAdd (MeasureTheory.integral (Î¼.restrict (Set.Iio b)) fun x => f x) (MeasureTheory.integral (Î¼.restrict (Set.Ici b)) fun x => f x)) (MeasureTheory.integral Î¼ fun x => f x)","decl":"theorem integral_Iio_add_Ici (h_left : IntegrableOn f (Iio b) Î¼)\n    (h_right : IntegrableOn f (Ici b) Î¼) :\n    (âˆ« x in Iio b, f x âˆ‚Î¼) + (âˆ« x in Ici b, f x âˆ‚Î¼) = âˆ« (x : â„), f x âˆ‚Î¼ := by\n  convert (setIntegral_union (Iio_disjoint_Ici <| Eq.le rfl) measurableSet_Ici h_left h_right).symm\n  rw [Iio_union_Ici, Measure.restrict_univ]\n\n"}
{"name":"intervalIntegral.integral_const_of_cdf","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\ninstâœÂ¹ : CompleteSpace E\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nc : E\nâŠ¢ Eq (intervalIntegral (fun x => c) a b Î¼) (HSMul.hSMul (HSub.hSub (Î¼ (Set.Iic b)).toReal (Î¼ (Set.Iic a)).toReal) c)","decl":"/-- If `Î¼` is a finite measure then `âˆ« x in a..b, c âˆ‚Î¼ = (Î¼ (Iic b) - Î¼ (Iic a)) â€¢ c`. -/\ntheorem integral_const_of_cdf [CompleteSpace E] [IsFiniteMeasure Î¼] (c : E) :\n    âˆ« _ in a..b, c âˆ‚Î¼ = ((Î¼ (Iic b)).toReal - (Î¼ (Iic a)).toReal) â€¢ c := by\n  simp only [sub_smul, â† setIntegral_const]\n  refine (integral_Iic_sub_Iic ?_ ?_).symm <;>\n    simp only [integrableOn_const, measure_lt_top, or_true]\n\n"}
{"name":"intervalIntegral.integral_eq_integral_of_support_subset","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\na b : Real\nh : HasSubset.Subset (Function.support f) (Set.Ioc a b)\nâŠ¢ Eq (intervalIntegral (fun x => f x) a b Î¼) (MeasureTheory.integral Î¼ fun x => f x)","decl":"theorem integral_eq_integral_of_support_subset {a b} (h : support f âŠ† Ioc a b) :\n    âˆ« x in a..b, f x âˆ‚Î¼ = âˆ« x, f x âˆ‚Î¼ := by\n  rcases le_total a b with hab | hab\n  Â· rw [integral_of_le hab, â† integral_indicator measurableSet_Ioc, indicator_eq_self.2 h]\n  Â· rw [Ioc_eq_empty hab.not_lt, subset_empty_iff, support_eq_empty_iff] at h\n    simp [h]\n\n"}
{"name":"intervalIntegral.integral_congr_ae'","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf g : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\nh : Filter.Eventually (fun x => Membership.mem (Set.Ioc a b) x â†’ Eq (f x) (g x)) (MeasureTheory.ae Î¼)\nh' : Filter.Eventually (fun x => Membership.mem (Set.Ioc b a) x â†’ Eq (f x) (g x)) (MeasureTheory.ae Î¼)\nâŠ¢ Eq (intervalIntegral (fun x => f x) a b Î¼) (intervalIntegral (fun x => g x) a b Î¼)","decl":"theorem integral_congr_ae' (h : âˆ€áµ x âˆ‚Î¼, x âˆˆ Ioc a b â†’ f x = g x)\n    (h' : âˆ€áµ x âˆ‚Î¼, x âˆˆ Ioc b a â†’ f x = g x) : âˆ« x in a..b, f x âˆ‚Î¼ = âˆ« x in a..b, g x âˆ‚Î¼ := by\n  simp only [intervalIntegral, setIntegral_congr_ae measurableSet_Ioc h,\n    setIntegral_congr_ae measurableSet_Ioc h']\n\n"}
{"name":"intervalIntegral.integral_congr_ae","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf g : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\nh : Filter.Eventually (fun x => Membership.mem (Set.uIoc a b) x â†’ Eq (f x) (g x)) (MeasureTheory.ae Î¼)\nâŠ¢ Eq (intervalIntegral (fun x => f x) a b Î¼) (intervalIntegral (fun x => g x) a b Î¼)","decl":"theorem integral_congr_ae (h : âˆ€áµ x âˆ‚Î¼, x âˆˆ Î™ a b â†’ f x = g x) :\n    âˆ« x in a..b, f x âˆ‚Î¼ = âˆ« x in a..b, g x âˆ‚Î¼ :=\n  integral_congr_ae' (ae_uIoc_iff.mp h).1 (ae_uIoc_iff.mp h).2\n\n"}
{"name":"intervalIntegral.integral_zero_ae","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Real\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\nh : Filter.Eventually (fun x => Membership.mem (Set.uIoc a b) x â†’ Eq (f x) 0) (MeasureTheory.ae Î¼)\nâŠ¢ Eq (intervalIntegral (fun x => f x) a b Î¼) 0","decl":"theorem integral_zero_ae (h : âˆ€áµ x âˆ‚Î¼, x âˆˆ Î™ a b â†’ f x = 0) : âˆ« x in a..b, f x âˆ‚Î¼ = 0 :=\n  calc\n    âˆ« x in a..b, f x âˆ‚Î¼ = âˆ« _ in a..b, 0 âˆ‚Î¼ := integral_congr_ae h\n    _ = 0 := integral_zero\n\n"}
{"name":"intervalIntegral.integral_indicator","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\naâ‚ aâ‚‚ aâ‚ƒ : Real\nh : Membership.mem (Set.Icc aâ‚ aâ‚ƒ) aâ‚‚\nâŠ¢ Eq (intervalIntegral (fun x => (setOf fun x => LE.le x aâ‚‚).indicator f x) aâ‚ aâ‚ƒ Î¼) (intervalIntegral (fun x => f x) aâ‚ aâ‚‚ Î¼)","decl":"nonrec theorem integral_indicator {aâ‚ aâ‚‚ aâ‚ƒ : â„} (h : aâ‚‚ âˆˆ Icc aâ‚ aâ‚ƒ) :\n    âˆ« x in aâ‚..aâ‚ƒ, indicator {x | x â‰¤ aâ‚‚} f x âˆ‚Î¼ = âˆ« x in aâ‚..aâ‚‚, f x âˆ‚Î¼ := by\n  have : {x | x â‰¤ aâ‚‚} âˆ© Ioc aâ‚ aâ‚ƒ = Ioc aâ‚ aâ‚‚ := Iic_inter_Ioc_of_le h.2\n  rw [integral_of_le h.1, integral_of_le (h.1.trans h.2), integral_indicator,\n    Measure.restrict_restrict, this]\n  Â· exact measurableSet_Iic\n  all_goals apply measurableSet_Iic\n\n"}
{"name":"intervalIntegral.integral_eq_zero_iff_of_le_of_nonneg_ae","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f : Real â†’ Real\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nhab : LE.le a b\nhf : (MeasureTheory.ae (Î¼.restrict (Set.Ioc a b))).EventuallyLE 0 f\nhfi : IntervalIntegrable f Î¼ a b\nâŠ¢ Iff (Eq (intervalIntegral (fun x => f x) a b Î¼) 0) ((MeasureTheory.ae (Î¼.restrict (Set.Ioc a b))).EventuallyEq f 0)","decl":"theorem integral_eq_zero_iff_of_le_of_nonneg_ae (hab : a â‰¤ b) (hf : 0 â‰¤áµ[Î¼.restrict (Ioc a b)] f)\n    (hfi : IntervalIntegrable f Î¼ a b) :\n    âˆ« x in a..b, f x âˆ‚Î¼ = 0 â†” f =áµ[Î¼.restrict (Ioc a b)] 0 := by\n  rw [integral_of_le hab, integral_eq_zero_iff_of_nonneg_ae hf hfi.1]\n\n"}
{"name":"intervalIntegral.integral_eq_zero_iff_of_nonneg_ae","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f : Real â†’ Real\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nhf : (MeasureTheory.ae (Î¼.restrict (Union.union (Set.Ioc a b) (Set.Ioc b a)))).EventuallyLE 0 f\nhfi : IntervalIntegrable f Î¼ a b\nâŠ¢ Iff (Eq (intervalIntegral (fun x => f x) a b Î¼) 0) ((MeasureTheory.ae (Î¼.restrict (Union.union (Set.Ioc a b) (Set.Ioc b a)))).EventuallyEq f 0)","decl":"theorem integral_eq_zero_iff_of_nonneg_ae (hf : 0 â‰¤áµ[Î¼.restrict (Ioc a b âˆª Ioc b a)] f)\n    (hfi : IntervalIntegrable f Î¼ a b) :\n    âˆ« x in a..b, f x âˆ‚Î¼ = 0 â†” f =áµ[Î¼.restrict (Ioc a b âˆª Ioc b a)] 0 := by\n  rcases le_total a b with hab | hab <;>\n    simp only [Ioc_eq_empty hab.not_lt, empty_union, union_empty] at hf âŠ¢\n  Â· exact integral_eq_zero_iff_of_le_of_nonneg_ae hab hf hfi\n  Â· rw [integral_symm, neg_eq_zero, integral_eq_zero_iff_of_le_of_nonneg_ae hab hf hfi.symm]\n\n"}
{"name":"intervalIntegral.integral_pos_iff_support_of_nonneg_ae'","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f : Real â†’ Real\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nhf : (MeasureTheory.ae (Î¼.restrict (Set.uIoc a b))).EventuallyLE 0 f\nhfi : IntervalIntegrable f Î¼ a b\nâŠ¢ Iff (LT.lt 0 (intervalIntegral (fun x => f x) a b Î¼)) (And (LT.lt a b) (LT.lt 0 (Î¼ (Inter.inter (Function.support f) (Set.Ioc a b)))))","decl":"/-- If `f` is nonnegative and integrable on the unordered interval `Set.uIoc a b`, then its\nintegral over `a..b` is positive if and only if `a < b` and the measure of\n`Function.support f âˆ© Set.Ioc a b` is positive. -/\ntheorem integral_pos_iff_support_of_nonneg_ae' (hf : 0 â‰¤áµ[Î¼.restrict (Î™ a b)] f)\n    (hfi : IntervalIntegrable f Î¼ a b) :\n    (0 < âˆ« x in a..b, f x âˆ‚Î¼) â†” a < b âˆ§ 0 < Î¼ (support f âˆ© Ioc a b) := by\n  cases' lt_or_le a b with hab hba\n  Â· rw [uIoc_of_le hab.le] at hf\n    simp only [hab, true_and, integral_of_le hab.le,\n      setIntegral_pos_iff_support_of_nonneg_ae hf hfi.1]\n  Â· suffices (âˆ« x in a..b, f x âˆ‚Î¼) â‰¤ 0 by simp only [this.not_lt, hba.not_lt, false_and]\n    rw [integral_of_ge hba, neg_nonpos]\n    rw [uIoc_comm, uIoc_of_le hba] at hf\n    exact integral_nonneg_of_ae hf\n\n"}
{"name":"intervalIntegral.integral_pos_iff_support_of_nonneg_ae","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f : Real â†’ Real\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nhf : (MeasureTheory.ae Î¼).EventuallyLE 0 f\nhfi : IntervalIntegrable f Î¼ a b\nâŠ¢ Iff (LT.lt 0 (intervalIntegral (fun x => f x) a b Î¼)) (And (LT.lt a b) (LT.lt 0 (Î¼ (Inter.inter (Function.support f) (Set.Ioc a b)))))","decl":"/-- If `f` is nonnegative a.e.-everywhere and it is integrable on the unordered interval\n`Set.uIoc a b`, then its integral over `a..b` is positive if and only if `a < b` and the\nmeasure of `Function.support f âˆ© Set.Ioc a b` is positive. -/\ntheorem integral_pos_iff_support_of_nonneg_ae (hf : 0 â‰¤áµ[Î¼] f) (hfi : IntervalIntegrable f Î¼ a b) :\n    (0 < âˆ« x in a..b, f x âˆ‚Î¼) â†” a < b âˆ§ 0 < Î¼ (support f âˆ© Ioc a b) :=\n  integral_pos_iff_support_of_nonneg_ae' (ae_mono Measure.restrict_le_self hf) hfi\n\n"}
{"name":"intervalIntegral.intervalIntegral_pos_of_pos_on","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f : Real â†’ Real\na b : Real\nhfi : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b\nhpos : âˆ€ (x : Real), Membership.mem (Set.Ioo a b) x â†’ LT.lt 0 (f x)\nhab : LT.lt a b\nâŠ¢ LT.lt 0 (intervalIntegral (fun x => f x) a b MeasureTheory.MeasureSpace.volume)","decl":"/-- If `f : â„ â†’ â„` is integrable on `(a, b]` for real numbers `a < b`, and positive on the interior\nof the interval, then its integral over `a..b` is strictly positive. -/\ntheorem intervalIntegral_pos_of_pos_on {f : â„ â†’ â„} {a b : â„} (hfi : IntervalIntegrable f volume a b)\n    (hpos : âˆ€ x : â„, x âˆˆ Ioo a b â†’ 0 < f x) (hab : a < b) : 0 < âˆ« x : â„ in a..b, f x := by\n  have hsupp : Ioo a b âŠ† support f âˆ© Ioc a b := fun x hx =>\n    âŸ¨mem_support.mpr (hpos x hx).ne', Ioo_subset_Ioc_self hxâŸ©\n  have hâ‚€ : 0 â‰¤áµ[volume.restrict (uIoc a b)] f := by\n    rw [EventuallyLE, uIoc_of_le hab.le]\n    refine ae_restrict_of_ae_eq_of_ae_restrict Ioo_ae_eq_Ioc ?_\n    rw [ae_restrict_iff' measurableSet_Ioo]\n    filter_upwards with x hx using (hpos x hx).le\n  rw [integral_pos_iff_support_of_nonneg_ae' hâ‚€ hfi]\n  exact âŸ¨hab, ((Measure.measure_Ioo_pos _).mpr hab).trans_le (measure_mono hsupp)âŸ©\n\n"}
{"name":"intervalIntegral.intervalIntegral_pos_of_pos","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f : Real â†’ Real\na b : Real\nhfi : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b\nhpos : âˆ€ (x : Real), LT.lt 0 (f x)\nhab : LT.lt a b\nâŠ¢ LT.lt 0 (intervalIntegral (fun x => f x) a b MeasureTheory.MeasureSpace.volume)","decl":"/-- If `f : â„ â†’ â„` is strictly positive everywhere, and integrable on `(a, b]` for real numbers\n`a < b`, then its integral over `a..b` is strictly positive. (See `intervalIntegral_pos_of_pos_on`\nfor a version only assuming positivity of `f` on `(a, b)` rather than everywhere.) -/\ntheorem intervalIntegral_pos_of_pos {f : â„ â†’ â„} {a b : â„}\n    (hfi : IntervalIntegrable f MeasureSpace.volume a b) (hpos : âˆ€ x, 0 < f x) (hab : a < b) :\n    0 < âˆ« x in a..b, f x :=\n  intervalIntegral_pos_of_pos_on hfi (fun x _ => hpos x) hab\n\n"}
{"name":"intervalIntegral.integral_lt_integral_of_ae_le_of_measure_setOf_lt_ne_zero","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f g : Real â†’ Real\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nhab : LE.le a b\nhfi : IntervalIntegrable f Î¼ a b\nhgi : IntervalIntegrable g Î¼ a b\nhle : (MeasureTheory.ae (Î¼.restrict (Set.Ioc a b))).EventuallyLE f g\nhlt : Ne ((Î¼.restrict (Set.Ioc a b)) (setOf fun x => LT.lt (f x) (g x))) 0\nâŠ¢ LT.lt (intervalIntegral (fun x => f x) a b Î¼) (intervalIntegral (fun x => g x) a b Î¼)","decl":"/-- If `f` and `g` are two functions that are interval integrable on `a..b`, `a â‰¤ b`,\n`f x â‰¤ g x` for a.e. `x âˆˆ Set.Ioc a b`, and `f x < g x` on a subset of `Set.Ioc a b`\nof nonzero measure, then `âˆ« x in a..b, f x âˆ‚Î¼ < âˆ« x in a..b, g x âˆ‚Î¼`. -/\ntheorem integral_lt_integral_of_ae_le_of_measure_setOf_lt_ne_zero (hab : a â‰¤ b)\n    (hfi : IntervalIntegrable f Î¼ a b) (hgi : IntervalIntegrable g Î¼ a b)\n    (hle : f â‰¤áµ[Î¼.restrict (Ioc a b)] g) (hlt : Î¼.restrict (Ioc a b) {x | f x < g x} â‰  0) :\n    (âˆ« x in a..b, f x âˆ‚Î¼) < âˆ« x in a..b, g x âˆ‚Î¼ := by\n  rw [â† sub_pos, â† integral_sub hgi hfi, integral_of_le hab,\n    MeasureTheory.integral_pos_iff_support_of_nonneg_ae]\n  Â· refine pos_iff_ne_zero.2 (mt (measure_mono_null ?_) hlt)\n    exact fun x hx => (sub_pos.2 hx.out).ne'\n  exacts [hle.mono fun x => sub_nonneg.2, hgi.1.sub hfi.1]\n\n"}
{"name":"intervalIntegral.integral_lt_integral_of_continuousOn_of_le_of_exists_lt","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f g : Real â†’ Real\na b : Real\nhab : LT.lt a b\nhfc : ContinuousOn f (Set.Icc a b)\nhgc : ContinuousOn g (Set.Icc a b)\nhle : âˆ€ (x : Real), Membership.mem (Set.Ioc a b) x â†’ LE.le (f x) (g x)\nhlt : Exists fun c => And (Membership.mem (Set.Icc a b) c) (LT.lt (f c) (g c))\nâŠ¢ LT.lt (intervalIntegral (fun x => f x) a b MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => g x) a b MeasureTheory.MeasureSpace.volume)","decl":"/-- If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x â‰¤ g x` on this interval, and\n`f c < g c` at some point `c âˆˆ [a, b]`, then `âˆ« x in a..b, f x < âˆ« x in a..b, g x`. -/\ntheorem integral_lt_integral_of_continuousOn_of_le_of_exists_lt {f g : â„ â†’ â„} {a b : â„}\n    (hab : a < b) (hfc : ContinuousOn f (Icc a b)) (hgc : ContinuousOn g (Icc a b))\n    (hle : âˆ€ x âˆˆ Ioc a b, f x â‰¤ g x) (hlt : âˆƒ c âˆˆ Icc a b, f c < g c) :\n    (âˆ« x in a..b, f x) < âˆ« x in a..b, g x := by\n  apply integral_lt_integral_of_ae_le_of_measure_setOf_lt_ne_zero hab.le\n    (hfc.intervalIntegrable_of_Icc hab.le) (hgc.intervalIntegrable_of_Icc hab.le)\n  Â· simpa only [measurableSet_Ioc, ae_restrict_eq]\n      using (ae_restrict_mem measurableSet_Ioc).mono hle\n  contrapose! hlt\n  have h_eq : f =áµ[volume.restrict (Ioc a b)] g := by\n    simp only [â† not_le, â† ae_iff] at hlt\n    exact EventuallyLE.antisymm ((ae_restrict_iff' measurableSet_Ioc).2 <|\n      Eventually.of_forall hle) hlt\n  rw [Measure.restrict_congr_set Ioc_ae_eq_Icc] at h_eq\n  exact fun c hc â†¦ (Measure.eqOn_Icc_of_ae_eq volume hab.ne h_eq hfc hgc hc).ge\n\n"}
{"name":"intervalIntegral.integral_nonneg_of_ae_restrict","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f : Real â†’ Real\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nhab : LE.le a b\nhf : (MeasureTheory.ae (Î¼.restrict (Set.Icc a b))).EventuallyLE 0 f\nâŠ¢ LE.le 0 (intervalIntegral (fun u => f u) a b Î¼)","decl":"theorem integral_nonneg_of_ae_restrict (hab : a â‰¤ b) (hf : 0 â‰¤áµ[Î¼.restrict (Icc a b)] f) :\n    0 â‰¤ âˆ« u in a..b, f u âˆ‚Î¼ := by\n  let H := ae_restrict_of_ae_restrict_of_subset Ioc_subset_Icc_self hf\n  simpa only [integral_of_le hab] using setIntegral_nonneg_of_ae_restrict H\n\n"}
{"name":"intervalIntegral.integral_nonneg_of_ae","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f : Real â†’ Real\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nhab : LE.le a b\nhf : (MeasureTheory.ae Î¼).EventuallyLE 0 f\nâŠ¢ LE.le 0 (intervalIntegral (fun u => f u) a b Î¼)","decl":"theorem integral_nonneg_of_ae (hab : a â‰¤ b) (hf : 0 â‰¤áµ[Î¼] f) : 0 â‰¤ âˆ« u in a..b, f u âˆ‚Î¼ :=\n  integral_nonneg_of_ae_restrict hab <| ae_restrict_of_ae hf\n\n"}
{"name":"intervalIntegral.integral_nonneg_of_forall","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f : Real â†’ Real\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nhab : LE.le a b\nhf : âˆ€ (u : Real), LE.le 0 (f u)\nâŠ¢ LE.le 0 (intervalIntegral (fun u => f u) a b Î¼)","decl":"theorem integral_nonneg_of_forall (hab : a â‰¤ b) (hf : âˆ€ u, 0 â‰¤ f u) : 0 â‰¤ âˆ« u in a..b, f u âˆ‚Î¼ :=\n  integral_nonneg_of_ae hab <| Eventually.of_forall hf\n\n"}
{"name":"intervalIntegral.integral_nonneg","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f : Real â†’ Real\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nhab : LE.le a b\nhf : âˆ€ (u : Real), Membership.mem (Set.Icc a b) u â†’ LE.le 0 (f u)\nâŠ¢ LE.le 0 (intervalIntegral (fun u => f u) a b Î¼)","decl":"theorem integral_nonneg (hab : a â‰¤ b) (hf : âˆ€ u, u âˆˆ Icc a b â†’ 0 â‰¤ f u) : 0 â‰¤ âˆ« u in a..b, f u âˆ‚Î¼ :=\n  integral_nonneg_of_ae_restrict hab <| (ae_restrict_iff' measurableSet_Icc).mpr <| ae_of_all Î¼ hf\n\n"}
{"name":"intervalIntegral.abs_integral_le_integral_abs","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f : Real â†’ Real\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nhab : LE.le a b\nâŠ¢ LE.le (abs (intervalIntegral (fun x => f x) a b Î¼)) (intervalIntegral (fun x => abs (f x)) a b Î¼)","decl":"theorem abs_integral_le_integral_abs (hab : a â‰¤ b) :\n    |âˆ« x in a..b, f x âˆ‚Î¼| â‰¤ âˆ« x in a..b, |f x| âˆ‚Î¼ := by\n  simpa only [â† Real.norm_eq_abs] using norm_integral_le_integral_norm hab\n\n"}
{"name":"intervalIntegral.integral_pos","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f : Real â†’ Real\na b : Real\nhab : LT.lt a b\nhfc : ContinuousOn f (Set.Icc a b)\nhle : âˆ€ (x : Real), Membership.mem (Set.Ioc a b) x â†’ LE.le 0 (f x)\nhlt : Exists fun c => And (Membership.mem (Set.Icc a b) c) (LT.lt 0 (f c))\nâŠ¢ LT.lt 0 (intervalIntegral (fun x => f x) a b MeasureTheory.MeasureSpace.volume)","decl":"lemma integral_pos (hab : a < b)\n    (hfc : ContinuousOn f (Icc a b)) (hle : âˆ€ x âˆˆ Ioc a b, 0 â‰¤ f x) (hlt : âˆƒ c âˆˆ Icc a b, 0 < f c) :\n    0 < âˆ« x in a..b, f x :=\n  (integral_lt_integral_of_continuousOn_of_le_of_exists_lt hab\n    continuousOn_const hfc hle hlt).trans_eq' (by simp)\n\n"}
{"name":"intervalIntegral.integral_mono_interval","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f : Real â†’ Real\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nc d : Real\nhca : LE.le c a\nhab : LE.le a b\nhbd : LE.le b d\nhf : (MeasureTheory.ae (Î¼.restrict (Set.Ioc c d))).EventuallyLE 0 f\nhfi : IntervalIntegrable f Î¼ c d\nâŠ¢ LE.le (intervalIntegral (fun x => f x) a b Î¼) (intervalIntegral (fun x => f x) c d Î¼)","decl":"theorem integral_mono_interval {c d} (hca : c â‰¤ a) (hab : a â‰¤ b) (hbd : b â‰¤ d)\n    (hf : 0 â‰¤áµ[Î¼.restrict (Ioc c d)] f) (hfi : IntervalIntegrable f Î¼ c d) :\n    (âˆ« x in a..b, f x âˆ‚Î¼) â‰¤ âˆ« x in c..d, f x âˆ‚Î¼ := by\n  rw [integral_of_le hab, integral_of_le (hca.trans (hab.trans hbd))]\n  exact setIntegral_mono_set hfi.1 hf (Ioc_subset_Ioc hca hbd).eventuallyLE\n\n"}
{"name":"intervalIntegral.abs_integral_mono_interval","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f : Real â†’ Real\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nc d : Real\nh : HasSubset.Subset (Set.uIoc a b) (Set.uIoc c d)\nhf : (MeasureTheory.ae (Î¼.restrict (Set.uIoc c d))).EventuallyLE 0 f\nhfi : IntervalIntegrable f Î¼ c d\nâŠ¢ LE.le (abs (intervalIntegral (fun x => f x) a b Î¼)) (abs (intervalIntegral (fun x => f x) c d Î¼))","decl":"theorem abs_integral_mono_interval {c d} (h : Î™ a b âŠ† Î™ c d) (hf : 0 â‰¤áµ[Î¼.restrict (Î™ c d)] f)\n    (hfi : IntervalIntegrable f Î¼ c d) : |âˆ« x in a..b, f x âˆ‚Î¼| â‰¤ |âˆ« x in c..d, f x âˆ‚Î¼| :=\n  have hf' : 0 â‰¤áµ[Î¼.restrict (Î™ a b)] f := ae_mono (Measure.restrict_mono h le_rfl) hf\n  calc\n    |âˆ« x in a..b, f x âˆ‚Î¼| = |âˆ« x in Î™ a b, f x âˆ‚Î¼| := abs_integral_eq_abs_integral_uIoc f\n    _ = âˆ« x in Î™ a b, f x âˆ‚Î¼ := abs_of_nonneg (MeasureTheory.integral_nonneg_of_ae hf')\n    _ â‰¤ âˆ« x in Î™ c d, f x âˆ‚Î¼ := setIntegral_mono_set hfi.def' hf h.eventuallyLE\n    _ â‰¤ |âˆ« x in Î™ c d, f x âˆ‚Î¼| := le_abs_self _\n    _ = |âˆ« x in c..d, f x âˆ‚Î¼| := (abs_integral_eq_abs_integral_uIoc f).symm\n\n"}
{"name":"intervalIntegral.integral_mono_ae_restrict","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f g : Real â†’ Real\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nhab : LE.le a b\nhf : IntervalIntegrable f Î¼ a b\nhg : IntervalIntegrable g Î¼ a b\nh : (MeasureTheory.ae (Î¼.restrict (Set.Icc a b))).EventuallyLE f g\nâŠ¢ LE.le (intervalIntegral (fun u => f u) a b Î¼) (intervalIntegral (fun u => g u) a b Î¼)","decl":"theorem integral_mono_ae_restrict (h : f â‰¤áµ[Î¼.restrict (Icc a b)] g) :\n    (âˆ« u in a..b, f u âˆ‚Î¼) â‰¤ âˆ« u in a..b, g u âˆ‚Î¼ := by\n  let H := h.filter_mono <| ae_mono <| Measure.restrict_mono Ioc_subset_Icc_self <| le_refl Î¼\n  simpa only [integral_of_le hab] using setIntegral_mono_ae_restrict hf.1 hg.1 H\n\n"}
{"name":"intervalIntegral.integral_mono_ae","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f g : Real â†’ Real\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nhab : LE.le a b\nhf : IntervalIntegrable f Î¼ a b\nhg : IntervalIntegrable g Î¼ a b\nh : (MeasureTheory.ae Î¼).EventuallyLE f g\nâŠ¢ LE.le (intervalIntegral (fun u => f u) a b Î¼) (intervalIntegral (fun u => g u) a b Î¼)","decl":"theorem integral_mono_ae (h : f â‰¤áµ[Î¼] g) : (âˆ« u in a..b, f u âˆ‚Î¼) â‰¤ âˆ« u in a..b, g u âˆ‚Î¼ := by\n  simpa only [integral_of_le hab] using setIntegral_mono_ae hf.1 hg.1 h\n\n"}
{"name":"intervalIntegral.integral_mono_on","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f g : Real â†’ Real\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nhab : LE.le a b\nhf : IntervalIntegrable f Î¼ a b\nhg : IntervalIntegrable g Î¼ a b\nh : âˆ€ (x : Real), Membership.mem (Set.Icc a b) x â†’ LE.le (f x) (g x)\nâŠ¢ LE.le (intervalIntegral (fun u => f u) a b Î¼) (intervalIntegral (fun u => g u) a b Î¼)","decl":"theorem integral_mono_on (h : âˆ€ x âˆˆ Icc a b, f x â‰¤ g x) :\n    (âˆ« u in a..b, f u âˆ‚Î¼) â‰¤ âˆ« u in a..b, g u âˆ‚Î¼ := by\n  let H x hx := h x <| Ioc_subset_Icc_self hx\n  simpa only [integral_of_le hab] using setIntegral_mono_on hf.1 hg.1 measurableSet_Ioc H\n\n"}
{"name":"intervalIntegral.integral_mono_on_of_le_Ioo","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f g : Real â†’ Real\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nhab : LE.le a b\nhf : IntervalIntegrable f Î¼ a b\nhg : IntervalIntegrable g Î¼ a b\ninstâœ : MeasureTheory.NoAtoms Î¼\nh : âˆ€ (x : Real), Membership.mem (Set.Ioo a b) x â†’ LE.le (f x) (g x)\nâŠ¢ LE.le (intervalIntegral (fun u => f u) a b Î¼) (intervalIntegral (fun u => g u) a b Î¼)","decl":"theorem integral_mono_on_of_le_Ioo [NoAtoms Î¼] (h : âˆ€ x âˆˆ Ioo a b, f x â‰¤ g x) :\n    (âˆ« u in a..b, f u âˆ‚Î¼) â‰¤ âˆ« u in a..b, g u âˆ‚Î¼ := by\n  simp only [integral_of_le hab, integral_Ioc_eq_integral_Ioo]\n  apply setIntegral_mono_on\n  Â· apply hf.1.mono Ioo_subset_Ioc_self le_rfl\n  Â· apply hg.1.mono Ioo_subset_Ioc_self le_rfl\n  Â· exact measurableSet_Ioo\n  Â· exact h\n\n"}
{"name":"intervalIntegral.integral_mono","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f g : Real â†’ Real\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nhab : LE.le a b\nhf : IntervalIntegrable f Î¼ a b\nhg : IntervalIntegrable g Î¼ a b\nh : LE.le f g\nâŠ¢ LE.le (intervalIntegral (fun u => f u) a b Î¼) (intervalIntegral (fun u => g u) a b Î¼)","decl":"theorem integral_mono (h : f â‰¤ g) : (âˆ« u in a..b, f u âˆ‚Î¼) â‰¤ âˆ« u in a..b, g u âˆ‚Î¼ :=\n  integral_mono_ae hab hf hg <| ae_of_all _ h\n\n"}
{"name":"MeasureTheory.Integrable.hasSum_intervalIntegral","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nÎ¼ : MeasureTheory.Measure Real\nf : Real â†’ E\nhfi : MeasureTheory.Integrable f Î¼\ny : Real\nâŠ¢ HasSum (fun n => intervalIntegral (fun x => f x) (HAdd.hAdd y â†‘n) (HAdd.hAdd (HAdd.hAdd y â†‘n) 1) Î¼) (MeasureTheory.integral Î¼ fun x => f x)","decl":"theorem _root_.MeasureTheory.Integrable.hasSum_intervalIntegral (hfi : Integrable f Î¼) (y : â„) :\n    HasSum (fun n : â„¤ => âˆ« x in y + n..y + n + 1, f x âˆ‚Î¼) (âˆ« x, f x âˆ‚Î¼) := by\n  simp_rw [integral_of_le (le_add_of_nonneg_right zero_le_one)]\n  rw [â† setIntegral_univ, â† iUnion_Ioc_add_intCast y]\n  exact\n    hasSum_integral_iUnion (fun i => measurableSet_Ioc) (pairwise_disjoint_Ioc_add_intCast y)\n      hfi.integrableOn\n\n"}
{"name":"MeasureTheory.Integrable.hasSum_intervalIntegral_comp_add_int","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : Real â†’ E\nhfi : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\nâŠ¢ HasSum (fun n => intervalIntegral (fun x => f (HAdd.hAdd x â†‘n)) 0 1 MeasureTheory.MeasureSpace.volume) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => f x)","decl":"theorem _root_.MeasureTheory.Integrable.hasSum_intervalIntegral_comp_add_int (hfi : Integrable f) :\n    HasSum (fun n : â„¤ => âˆ« x in (0 : â„)..(1 : â„), f (x + n)) (âˆ« x, f x) := by\n  simpa only [integral_comp_add_right, zero_add, add_comm (1 : â„)] using\n    hfi.hasSum_intervalIntegral 0\n\n"}
