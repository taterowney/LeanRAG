{"name":"intervalIntegrable_iff","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\na b : Real\nμ : MeasureTheory.Measure Real\n⊢ Iff (IntervalIntegrable f μ a b) (MeasureTheory.IntegrableOn f (Set.uIoc a b) μ)","decl":"/-- A function is interval integrable with respect to a given measure `μ` on `a..b` if and\n  only if it is integrable on `uIoc a b` with respect to `μ`. This is an equivalent\n  definition of `IntervalIntegrable`. -/\ntheorem intervalIntegrable_iff : IntervalIntegrable f μ a b ↔ IntegrableOn f (Ι a b) μ := by\n  rw [uIoc_eq_union, integrableOn_union, IntervalIntegrable]\n\n"}
{"name":"IntervalIntegrable.def'","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\na b : Real\nμ : MeasureTheory.Measure Real\nh : IntervalIntegrable f μ a b\n⊢ MeasureTheory.IntegrableOn f (Set.uIoc a b) μ","decl":"/-- If a function is interval integrable with respect to a given measure `μ` on `a..b` then\n  it is integrable on `uIoc a b` with respect to `μ`. -/\ntheorem IntervalIntegrable.def' (h : IntervalIntegrable f μ a b) : IntegrableOn f (Ι a b) μ :=\n  intervalIntegrable_iff.mp h\n\n"}
{"name":"IntervalIntegrable.congr","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\na b : Real\nμ : MeasureTheory.Measure Real\ng : Real → E\nhf : IntervalIntegrable f μ a b\nh : (MeasureTheory.ae (μ.restrict (Set.uIoc a b))).EventuallyEq f g\n⊢ IntervalIntegrable g μ a b","decl":"theorem IntervalIntegrable.congr {g : ℝ → E} (hf : IntervalIntegrable f μ a b)\n    (h : f =ᵐ[μ.restrict (Ι a b)] g) :\n    IntervalIntegrable g μ a b := by\n  rwa [intervalIntegrable_iff, ← integrableOn_congr_fun_ae h, ← intervalIntegrable_iff]\n\n"}
{"name":"intervalIntegrable_iff_integrableOn_Ioc_of_le","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\na b : Real\nμ : MeasureTheory.Measure Real\nhab : LE.le a b\n⊢ Iff (IntervalIntegrable f μ a b) (MeasureTheory.IntegrableOn f (Set.Ioc a b) μ)","decl":"theorem intervalIntegrable_iff_integrableOn_Ioc_of_le (hab : a ≤ b) :\n    IntervalIntegrable f μ a b ↔ IntegrableOn f (Ioc a b) μ := by\n  rw [intervalIntegrable_iff, uIoc_of_le hab]\n\n"}
{"name":"intervalIntegrable_iff'","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\nf : Real → E\na b : Real\nμ : MeasureTheory.Measure Real\ninst✝ : MeasureTheory.NoAtoms μ\n⊢ Iff (IntervalIntegrable f μ a b) (MeasureTheory.IntegrableOn f (Set.uIcc a b) μ)","decl":"theorem intervalIntegrable_iff' [NoAtoms μ] :\n    IntervalIntegrable f μ a b ↔ IntegrableOn f (uIcc a b) μ := by\n  rw [intervalIntegrable_iff, ← Icc_min_max, uIoc, integrableOn_Icc_iff_integrableOn_Ioc]\n\n"}
{"name":"intervalIntegrable_iff_integrableOn_Icc_of_le","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\nf : Real → E\na b : Real\nhab : LE.le a b\nμ : MeasureTheory.Measure Real\ninst✝ : MeasureTheory.NoAtoms μ\n⊢ Iff (IntervalIntegrable f μ a b) (MeasureTheory.IntegrableOn f (Set.Icc a b) μ)","decl":"theorem intervalIntegrable_iff_integrableOn_Icc_of_le {f : ℝ → E} {a b : ℝ} (hab : a ≤ b)\n    {μ : Measure ℝ} [NoAtoms μ] : IntervalIntegrable f μ a b ↔ IntegrableOn f (Icc a b) μ := by\n  rw [intervalIntegrable_iff_integrableOn_Ioc_of_le hab, integrableOn_Icc_iff_integrableOn_Ioc]\n\n"}
{"name":"intervalIntegrable_iff_integrableOn_Ico_of_le","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\nf : Real → E\na b : Real\nμ : MeasureTheory.Measure Real\ninst✝ : MeasureTheory.NoAtoms μ\nhab : LE.le a b\n⊢ Iff (IntervalIntegrable f μ a b) (MeasureTheory.IntegrableOn f (Set.Ico a b) μ)","decl":"theorem intervalIntegrable_iff_integrableOn_Ico_of_le [NoAtoms μ] (hab : a ≤ b) :\n    IntervalIntegrable f μ a b ↔ IntegrableOn f (Ico a b) μ := by\n  rw [intervalIntegrable_iff_integrableOn_Icc_of_le hab, integrableOn_Icc_iff_integrableOn_Ico]\n\n"}
{"name":"intervalIntegrable_iff_integrableOn_Ioo_of_le","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\nf : Real → E\na b : Real\nμ : MeasureTheory.Measure Real\ninst✝ : MeasureTheory.NoAtoms μ\nhab : LE.le a b\n⊢ Iff (IntervalIntegrable f μ a b) (MeasureTheory.IntegrableOn f (Set.Ioo a b) μ)","decl":"theorem intervalIntegrable_iff_integrableOn_Ioo_of_le [NoAtoms μ] (hab : a ≤ b) :\n    IntervalIntegrable f μ a b ↔ IntegrableOn f (Ioo a b) μ := by\n  rw [intervalIntegrable_iff_integrableOn_Icc_of_le hab, integrableOn_Icc_iff_integrableOn_Ioo]\n\n"}
{"name":"MeasureTheory.Integrable.intervalIntegrable","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\na b : Real\nμ : MeasureTheory.Measure Real\nhf : MeasureTheory.Integrable f μ\n⊢ IntervalIntegrable f μ a b","decl":"/-- If a function is integrable with respect to a given measure `μ` then it is interval integrable\n  with respect to `μ` on `uIcc a b`. -/\ntheorem MeasureTheory.Integrable.intervalIntegrable (hf : Integrable f μ) :\n    IntervalIntegrable f μ a b :=\n  ⟨hf.integrableOn, hf.integrableOn⟩\n\n"}
{"name":"MeasureTheory.IntegrableOn.intervalIntegrable","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\na b : Real\nμ : MeasureTheory.Measure Real\nhf : MeasureTheory.IntegrableOn f (Set.uIcc a b) μ\n⊢ IntervalIntegrable f μ a b","decl":"theorem MeasureTheory.IntegrableOn.intervalIntegrable (hf : IntegrableOn f [[a, b]] μ) :\n    IntervalIntegrable f μ a b :=\n  ⟨MeasureTheory.IntegrableOn.mono_set hf (Ioc_subset_Icc_self.trans Icc_subset_uIcc),\n    MeasureTheory.IntegrableOn.mono_set hf (Ioc_subset_Icc_self.trans Icc_subset_uIcc')⟩\n\n"}
{"name":"intervalIntegrable_const_iff","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\na b : Real\nμ : MeasureTheory.Measure Real\nc : E\n⊢ Iff (IntervalIntegrable (fun x => c) μ a b) (Or (Eq c 0) (LT.lt (μ (Set.uIoc a b)) Top.top))","decl":"theorem intervalIntegrable_const_iff {c : E} :\n    IntervalIntegrable (fun _ => c) μ a b ↔ c = 0 ∨ μ (Ι a b) < ∞ := by\n  simp only [intervalIntegrable_iff, integrableOn_const]\n\n"}
{"name":"intervalIntegrable_const","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\na b : Real\nμ : MeasureTheory.Measure Real\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nc : E\n⊢ IntervalIntegrable (fun x => c) μ a b","decl":"@[simp]\ntheorem intervalIntegrable_const [IsLocallyFiniteMeasure μ] {c : E} :\n    IntervalIntegrable (fun _ => c) μ a b :=\n  intervalIntegrable_const_iff.2 <| Or.inr measure_Ioc_lt_top\n\n"}
{"name":"IntervalIntegrable.symm","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\na b : Real\nμ : MeasureTheory.Measure Real\nh : IntervalIntegrable f μ a b\n⊢ IntervalIntegrable f μ b a","decl":"@[symm]\nnonrec theorem symm (h : IntervalIntegrable f μ a b) : IntervalIntegrable f μ b a :=\n  h.symm\n\n"}
{"name":"IntervalIntegrable.refl","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\na : Real\nμ : MeasureTheory.Measure Real\n⊢ IntervalIntegrable f μ a a","decl":"@[refl, simp] -- Porting note: added `simp`\ntheorem refl : IntervalIntegrable f μ a a := by constructor <;> simp\n\n"}
{"name":"IntervalIntegrable.trans","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\nμ : MeasureTheory.Measure Real\na b c : Real\nhab : IntervalIntegrable f μ a b\nhbc : IntervalIntegrable f μ b c\n⊢ IntervalIntegrable f μ a c","decl":"@[trans]\ntheorem trans {a b c : ℝ} (hab : IntervalIntegrable f μ a b) (hbc : IntervalIntegrable f μ b c) :\n    IntervalIntegrable f μ a c :=\n  ⟨(hab.1.union hbc.1).mono_set Ioc_subset_Ioc_union_Ioc,\n    (hbc.2.union hab.2).mono_set Ioc_subset_Ioc_union_Ioc⟩\n\n"}
{"name":"IntervalIntegrable.trans_iterate_Ico","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\nμ : MeasureTheory.Measure Real\na : Nat → Real\nm n : Nat\nhmn : LE.le m n\nhint : ∀ (k : Nat), Membership.mem (Set.Ico m n) k → IntervalIntegrable f μ (a k) (a (HAdd.hAdd k 1))\n⊢ IntervalIntegrable f μ (a m) (a n)","decl":"theorem trans_iterate_Ico {a : ℕ → ℝ} {m n : ℕ} (hmn : m ≤ n)\n    (hint : ∀ k ∈ Ico m n, IntervalIntegrable f μ (a k) (a <| k + 1)) :\n    IntervalIntegrable f μ (a m) (a n) := by\n  revert hint\n  refine Nat.le_induction ?_ ?_ n hmn\n  · simp\n  · intro p hp IH h\n    exact (IH fun k hk => h k (Ico_subset_Ico_right p.le_succ hk)).trans (h p (by simp [hp]))\n\n"}
{"name":"IntervalIntegrable.trans_iterate","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\nμ : MeasureTheory.Measure Real\na : Nat → Real\nn : Nat\nhint : ∀ (k : Nat), LT.lt k n → IntervalIntegrable f μ (a k) (a (HAdd.hAdd k 1))\n⊢ IntervalIntegrable f μ (a 0) (a n)","decl":"theorem trans_iterate {a : ℕ → ℝ} {n : ℕ}\n    (hint : ∀ k < n, IntervalIntegrable f μ (a k) (a <| k + 1)) :\n    IntervalIntegrable f μ (a 0) (a n) :=\n  trans_iterate_Ico bot_le fun k hk => hint k hk.2\n\n"}
{"name":"IntervalIntegrable.neg","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\na b : Real\nμ : MeasureTheory.Measure Real\nh : IntervalIntegrable f μ a b\n⊢ IntervalIntegrable (Neg.neg f) μ a b","decl":"theorem neg (h : IntervalIntegrable f μ a b) : IntervalIntegrable (-f) μ a b :=\n  ⟨h.1.neg, h.2.neg⟩\n\n"}
{"name":"IntervalIntegrable.norm","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\na b : Real\nμ : MeasureTheory.Measure Real\nh : IntervalIntegrable f μ a b\n⊢ IntervalIntegrable (fun x => Norm.norm (f x)) μ a b","decl":"theorem norm (h : IntervalIntegrable f μ a b) : IntervalIntegrable (fun x => ‖f x‖) μ a b :=\n  ⟨h.1.norm, h.2.norm⟩\n\n"}
{"name":"IntervalIntegrable.intervalIntegrable_norm_iff","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\nμ : MeasureTheory.Measure Real\na b : Real\nhf : MeasureTheory.AEStronglyMeasurable f (μ.restrict (Set.uIoc a b))\n⊢ Iff (IntervalIntegrable (fun t => Norm.norm (f t)) μ a b) (IntervalIntegrable f μ a b)","decl":"theorem intervalIntegrable_norm_iff {f : ℝ → E} {μ : Measure ℝ} {a b : ℝ}\n    (hf : AEStronglyMeasurable f (μ.restrict (Ι a b))) :\n    IntervalIntegrable (fun t => ‖f t‖) μ a b ↔ IntervalIntegrable f μ a b := by\n  simp_rw [intervalIntegrable_iff, IntegrableOn]; exact integrable_norm_iff hf\n\n"}
{"name":"IntervalIntegrable.abs","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"a b : Real\nμ : MeasureTheory.Measure Real\nf : Real → Real\nh : IntervalIntegrable f μ a b\n⊢ IntervalIntegrable (fun x => abs (f x)) μ a b","decl":"theorem abs {f : ℝ → ℝ} (h : IntervalIntegrable f μ a b) :\n    IntervalIntegrable (fun x => |f x|) μ a b :=\n  h.norm\n\n"}
{"name":"IntervalIntegrable.mono","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\na b c d : Real\nμ ν : MeasureTheory.Measure Real\nhf : IntervalIntegrable f ν a b\nh1 : HasSubset.Subset (Set.uIcc c d) (Set.uIcc a b)\nh2 : LE.le μ ν\n⊢ IntervalIntegrable f μ c d","decl":"theorem mono (hf : IntervalIntegrable f ν a b) (h1 : [[c, d]] ⊆ [[a, b]]) (h2 : μ ≤ ν) :\n    IntervalIntegrable f μ c d :=\n  intervalIntegrable_iff.mpr <| hf.def'.mono (uIoc_subset_uIoc_of_uIcc_subset_uIcc h1) h2\n\n"}
{"name":"IntervalIntegrable.mono_measure","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\na b : Real\nμ ν : MeasureTheory.Measure Real\nhf : IntervalIntegrable f ν a b\nh : LE.le μ ν\n⊢ IntervalIntegrable f μ a b","decl":"theorem mono_measure (hf : IntervalIntegrable f ν a b) (h : μ ≤ ν) : IntervalIntegrable f μ a b :=\n  hf.mono Subset.rfl h\n\n"}
{"name":"IntervalIntegrable.mono_set","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\na b c d : Real\nμ : MeasureTheory.Measure Real\nhf : IntervalIntegrable f μ a b\nh : HasSubset.Subset (Set.uIcc c d) (Set.uIcc a b)\n⊢ IntervalIntegrable f μ c d","decl":"theorem mono_set (hf : IntervalIntegrable f μ a b) (h : [[c, d]] ⊆ [[a, b]]) :\n    IntervalIntegrable f μ c d :=\n  hf.mono h le_rfl\n\n"}
{"name":"IntervalIntegrable.mono_set_ae","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\na b c d : Real\nμ : MeasureTheory.Measure Real\nhf : IntervalIntegrable f μ a b\nh : (MeasureTheory.ae μ).EventuallyLE (Set.uIoc c d) (Set.uIoc a b)\n⊢ IntervalIntegrable f μ c d","decl":"theorem mono_set_ae (hf : IntervalIntegrable f μ a b) (h : Ι c d ≤ᵐ[μ] Ι a b) :\n    IntervalIntegrable f μ c d :=\n  intervalIntegrable_iff.mpr <| hf.def'.mono_set_ae h\n\n"}
{"name":"IntervalIntegrable.mono_set'","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\na b c d : Real\nμ : MeasureTheory.Measure Real\nhf : IntervalIntegrable f μ a b\nhsub : HasSubset.Subset (Set.uIoc c d) (Set.uIoc a b)\n⊢ IntervalIntegrable f μ c d","decl":"theorem mono_set' (hf : IntervalIntegrable f μ a b) (hsub : Ι c d ⊆ Ι a b) :\n    IntervalIntegrable f μ c d :=\n  hf.mono_set_ae <| Eventually.of_forall hsub\n\n"}
{"name":"IntervalIntegrable.mono_fun","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\nF : Type u_4\ninst✝¹ : NormedAddCommGroup E\nf : Real → E\na b : Real\nμ : MeasureTheory.Measure Real\ninst✝ : NormedAddCommGroup F\ng : Real → F\nhf : IntervalIntegrable f μ a b\nhgm : MeasureTheory.AEStronglyMeasurable g (μ.restrict (Set.uIoc a b))\nhle : (MeasureTheory.ae (μ.restrict (Set.uIoc a b))).EventuallyLE (fun x => Norm.norm (g x)) fun x => Norm.norm (f x)\n⊢ IntervalIntegrable g μ a b","decl":"theorem mono_fun [NormedAddCommGroup F] {g : ℝ → F} (hf : IntervalIntegrable f μ a b)\n    (hgm : AEStronglyMeasurable g (μ.restrict (Ι a b)))\n    (hle : (fun x => ‖g x‖) ≤ᵐ[μ.restrict (Ι a b)] fun x => ‖f x‖) : IntervalIntegrable g μ a b :=\n  intervalIntegrable_iff.2 <| hf.def'.integrable.mono hgm hle\n\n"}
{"name":"IntervalIntegrable.mono_fun'","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\na b : Real\nμ : MeasureTheory.Measure Real\ng : Real → Real\nhg : IntervalIntegrable g μ a b\nhfm : MeasureTheory.AEStronglyMeasurable f (μ.restrict (Set.uIoc a b))\nhle : (MeasureTheory.ae (μ.restrict (Set.uIoc a b))).EventuallyLE (fun x => Norm.norm (f x)) g\n⊢ IntervalIntegrable f μ a b","decl":"theorem mono_fun' {g : ℝ → ℝ} (hg : IntervalIntegrable g μ a b)\n    (hfm : AEStronglyMeasurable f (μ.restrict (Ι a b)))\n    (hle : (fun x => ‖f x‖) ≤ᵐ[μ.restrict (Ι a b)] g) : IntervalIntegrable f μ a b :=\n  intervalIntegrable_iff.2 <| hg.def'.integrable.mono' hfm hle\n\n"}
{"name":"IntervalIntegrable.aestronglyMeasurable","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\na b : Real\nμ : MeasureTheory.Measure Real\nh : IntervalIntegrable f μ a b\n⊢ MeasureTheory.AEStronglyMeasurable f (μ.restrict (Set.Ioc a b))","decl":"protected theorem aestronglyMeasurable (h : IntervalIntegrable f μ a b) :\n    AEStronglyMeasurable f (μ.restrict (Ioc a b)) :=\n  h.1.aestronglyMeasurable\n\n"}
{"name":"IntervalIntegrable.aestronglyMeasurable'","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\na b : Real\nμ : MeasureTheory.Measure Real\nh : IntervalIntegrable f μ a b\n⊢ MeasureTheory.AEStronglyMeasurable f (μ.restrict (Set.Ioc b a))","decl":"protected theorem aestronglyMeasurable' (h : IntervalIntegrable f μ a b) :\n    AEStronglyMeasurable f (μ.restrict (Ioc b a)) :=\n  h.2.aestronglyMeasurable\n\n"}
{"name":"IntervalIntegrable.smul","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"𝕜 : Type u_2\nE : Type u_3\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedField 𝕜\ninst✝ : NormedSpace 𝕜 E\nf : Real → E\na b : Real\nμ : MeasureTheory.Measure Real\nh : IntervalIntegrable f μ a b\nr : 𝕜\n⊢ IntervalIntegrable (HSMul.hSMul r f) μ a b","decl":"theorem smul [NormedField 𝕜] [NormedSpace 𝕜 E] {f : ℝ → E} {a b : ℝ} {μ : Measure ℝ}\n    (h : IntervalIntegrable f μ a b) (r : 𝕜) : IntervalIntegrable (r • f) μ a b :=\n  ⟨h.1.smul r, h.2.smul r⟩\n\n"}
{"name":"IntervalIntegrable.add","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf g : Real → E\na b : Real\nμ : MeasureTheory.Measure Real\nhf : IntervalIntegrable f μ a b\nhg : IntervalIntegrable g μ a b\n⊢ IntervalIntegrable (fun x => HAdd.hAdd (f x) (g x)) μ a b","decl":"@[simp]\ntheorem add (hf : IntervalIntegrable f μ a b) (hg : IntervalIntegrable g μ a b) :\n    IntervalIntegrable (fun x => f x + g x) μ a b :=\n  ⟨hf.1.add hg.1, hf.2.add hg.2⟩\n\n"}
{"name":"IntervalIntegrable.sub","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf g : Real → E\na b : Real\nμ : MeasureTheory.Measure Real\nhf : IntervalIntegrable f μ a b\nhg : IntervalIntegrable g μ a b\n⊢ IntervalIntegrable (fun x => HSub.hSub (f x) (g x)) μ a b","decl":"@[simp]\ntheorem sub (hf : IntervalIntegrable f μ a b) (hg : IntervalIntegrable g μ a b) :\n    IntervalIntegrable (fun x => f x - g x) μ a b :=\n  ⟨hf.1.sub hg.1, hf.2.sub hg.2⟩\n\n"}
{"name":"IntervalIntegrable.sum","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"ι : Type u_1\nE : Type u_3\ninst✝ : NormedAddCommGroup E\na b : Real\nμ : MeasureTheory.Measure Real\ns : Finset ι\nf : ι → Real → E\nh : ∀ (i : ι), Membership.mem s i → IntervalIntegrable (f i) μ a b\n⊢ IntervalIntegrable (s.sum fun i => f i) μ a b","decl":"theorem sum (s : Finset ι) {f : ι → ℝ → E} (h : ∀ i ∈ s, IntervalIntegrable (f i) μ a b) :\n    IntervalIntegrable (∑ i ∈ s, f i) μ a b :=\n  ⟨integrable_finset_sum' s fun i hi => (h i hi).1, integrable_finset_sum' s fun i hi => (h i hi).2⟩\n\n"}
{"name":"IntervalIntegrable.mul_continuousOn","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"A : Type u_5\ninst✝ : NormedRing A\na b : Real\nμ : MeasureTheory.Measure Real\nf g : Real → A\nhf : IntervalIntegrable f μ a b\nhg : ContinuousOn g (Set.uIcc a b)\n⊢ IntervalIntegrable (fun x => HMul.hMul (f x) (g x)) μ a b","decl":"theorem mul_continuousOn {f g : ℝ → A} (hf : IntervalIntegrable f μ a b)\n    (hg : ContinuousOn g [[a, b]]) : IntervalIntegrable (fun x => f x * g x) μ a b := by\n  rw [intervalIntegrable_iff] at hf ⊢\n  exact hf.mul_continuousOn_of_subset hg measurableSet_Ioc isCompact_uIcc Ioc_subset_Icc_self\n\n"}
{"name":"IntervalIntegrable.continuousOn_mul","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"A : Type u_5\ninst✝ : NormedRing A\na b : Real\nμ : MeasureTheory.Measure Real\nf g : Real → A\nhf : IntervalIntegrable f μ a b\nhg : ContinuousOn g (Set.uIcc a b)\n⊢ IntervalIntegrable (fun x => HMul.hMul (g x) (f x)) μ a b","decl":"theorem continuousOn_mul {f g : ℝ → A} (hf : IntervalIntegrable f μ a b)\n    (hg : ContinuousOn g [[a, b]]) : IntervalIntegrable (fun x => g x * f x) μ a b := by\n  rw [intervalIntegrable_iff] at hf ⊢\n  exact hf.continuousOn_mul_of_subset hg isCompact_uIcc measurableSet_Ioc Ioc_subset_Icc_self\n\n"}
{"name":"IntervalIntegrable.const_mul","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"A : Type u_5\ninst✝ : NormedRing A\na b : Real\nμ : MeasureTheory.Measure Real\nf : Real → A\nhf : IntervalIntegrable f μ a b\nc : A\n⊢ IntervalIntegrable (fun x => HMul.hMul c (f x)) μ a b","decl":"@[simp]\ntheorem const_mul {f : ℝ → A} (hf : IntervalIntegrable f μ a b) (c : A) :\n    IntervalIntegrable (fun x => c * f x) μ a b :=\n  hf.continuousOn_mul continuousOn_const\n\n"}
{"name":"IntervalIntegrable.mul_const","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"A : Type u_5\ninst✝ : NormedRing A\na b : Real\nμ : MeasureTheory.Measure Real\nf : Real → A\nhf : IntervalIntegrable f μ a b\nc : A\n⊢ IntervalIntegrable (fun x => HMul.hMul (f x) c) μ a b","decl":"@[simp]\ntheorem mul_const {f : ℝ → A} (hf : IntervalIntegrable f μ a b) (c : A) :\n    IntervalIntegrable (fun x => f x * c) μ a b :=\n  hf.mul_continuousOn continuousOn_const\n\n"}
{"name":"IntervalIntegrable.div_const","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"a b : Real\nμ : MeasureTheory.Measure Real\n𝕜 : Type u_6\nf : Real → 𝕜\ninst✝ : NormedField 𝕜\nh : IntervalIntegrable f μ a b\nc : 𝕜\n⊢ IntervalIntegrable (fun x => HDiv.hDiv (f x) c) μ a b","decl":"@[simp]\ntheorem div_const {𝕜 : Type*} {f : ℝ → 𝕜} [NormedField 𝕜] (h : IntervalIntegrable f μ a b)\n    (c : 𝕜) : IntervalIntegrable (fun x => f x / c) μ a b := by\n  simpa only [div_eq_mul_inv] using mul_const h c⁻¹\n\n"}
{"name":"IntervalIntegrable.comp_mul_left","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\na b : Real\nhf : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b\nc : Real\n⊢ IntervalIntegrable (fun x => f (HMul.hMul c x)) MeasureTheory.MeasureSpace.volume (HDiv.hDiv a c) (HDiv.hDiv b c)","decl":"theorem comp_mul_left (hf : IntervalIntegrable f volume a b) (c : ℝ) :\n    IntervalIntegrable (fun x => f (c * x)) volume (a / c) (b / c) := by\n  rcases eq_or_ne c 0 with (hc | hc); · rw [hc]; simp\n  rw [intervalIntegrable_iff'] at hf ⊢\n  have A : MeasurableEmbedding fun x => x * c⁻¹ :=\n    (Homeomorph.mulRight₀ _ (inv_ne_zero hc)).isClosedEmbedding.measurableEmbedding\n  rw [← Real.smul_map_volume_mul_right (inv_ne_zero hc), IntegrableOn, Measure.restrict_smul,\n    integrable_smul_measure (by simpa : ENNReal.ofReal |c⁻¹| ≠ 0) ENNReal.ofReal_ne_top,\n    ← IntegrableOn, MeasurableEmbedding.integrableOn_map_iff A]\n  convert hf using 1\n  · ext; simp only [comp_apply]; congr 1; field_simp\n  · rw [preimage_mul_const_uIcc (inv_ne_zero hc)]; field_simp [hc]\n\n"}
{"name":"IntervalIntegrable.comp_mul_left_iff","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\na b c : Real\nhc : Ne c 0\n⊢ Iff (IntervalIntegrable (fun x => f (HMul.hMul c x)) MeasureTheory.MeasureSpace.volume (HDiv.hDiv a c) (HDiv.hDiv b c)) (IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b)","decl":"theorem comp_mul_left_iff {c : ℝ} (hc : c ≠ 0) :\n    IntervalIntegrable (fun x ↦ f (c * x)) volume (a / c) (b / c) ↔\n      IntervalIntegrable f volume a b :=\n  ⟨fun h ↦ by simpa [hc] using h.comp_mul_left c⁻¹, (comp_mul_left · c)⟩\n\n"}
{"name":"IntervalIntegrable.comp_mul_right","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\na b : Real\nhf : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b\nc : Real\n⊢ IntervalIntegrable (fun x => f (HMul.hMul x c)) MeasureTheory.MeasureSpace.volume (HDiv.hDiv a c) (HDiv.hDiv b c)","decl":"theorem comp_mul_right (hf : IntervalIntegrable f volume a b) (c : ℝ) :\n    IntervalIntegrable (fun x => f (x * c)) volume (a / c) (b / c) := by\n  simpa only [mul_comm] using comp_mul_left hf c\n\n"}
{"name":"IntervalIntegrable.comp_add_right","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\na b : Real\nhf : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b\nc : Real\n⊢ IntervalIntegrable (fun x => f (HAdd.hAdd x c)) MeasureTheory.MeasureSpace.volume (HSub.hSub a c) (HSub.hSub b c)","decl":"theorem comp_add_right (hf : IntervalIntegrable f volume a b) (c : ℝ) :\n    IntervalIntegrable (fun x => f (x + c)) volume (a - c) (b - c) := by\n  wlog h : a ≤ b generalizing a b\n  · exact IntervalIntegrable.symm (this hf.symm (le_of_not_le h))\n  rw [intervalIntegrable_iff'] at hf ⊢\n  have A : MeasurableEmbedding fun x => x + c :=\n    (Homeomorph.addRight c).isClosedEmbedding.measurableEmbedding\n  rw [← map_add_right_eq_self volume c] at hf\n  convert (MeasurableEmbedding.integrableOn_map_iff A).mp hf using 1\n  rw [preimage_add_const_uIcc]\n\n"}
{"name":"IntervalIntegrable.comp_add_left","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\na b : Real\nhf : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b\nc : Real\n⊢ IntervalIntegrable (fun x => f (HAdd.hAdd c x)) MeasureTheory.MeasureSpace.volume (HSub.hSub a c) (HSub.hSub b c)","decl":"theorem comp_add_left (hf : IntervalIntegrable f volume a b) (c : ℝ) :\n    IntervalIntegrable (fun x => f (c + x)) volume (a - c) (b - c) := by\n  simpa only [add_comm] using IntervalIntegrable.comp_add_right hf c\n\n"}
{"name":"IntervalIntegrable.comp_sub_right","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\na b : Real\nhf : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b\nc : Real\n⊢ IntervalIntegrable (fun x => f (HSub.hSub x c)) MeasureTheory.MeasureSpace.volume (HAdd.hAdd a c) (HAdd.hAdd b c)","decl":"theorem comp_sub_right (hf : IntervalIntegrable f volume a b) (c : ℝ) :\n    IntervalIntegrable (fun x => f (x - c)) volume (a + c) (b + c) := by\n  simpa only [sub_neg_eq_add] using IntervalIntegrable.comp_add_right hf (-c)\n\n"}
{"name":"IntervalIntegrable.iff_comp_neg","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\na b : Real\n⊢ Iff (IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b) (IntervalIntegrable (fun x => f (Neg.neg x)) MeasureTheory.MeasureSpace.volume (Neg.neg a) (Neg.neg b))","decl":"theorem iff_comp_neg :\n    IntervalIntegrable f volume a b ↔ IntervalIntegrable (fun x => f (-x)) volume (-a) (-b) := by\n  rw [← comp_mul_left_iff (neg_ne_zero.2 one_ne_zero)]; simp [div_neg]\n\n"}
{"name":"IntervalIntegrable.comp_sub_left","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\na b : Real\nhf : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b\nc : Real\n⊢ IntervalIntegrable (fun x => f (HSub.hSub c x)) MeasureTheory.MeasureSpace.volume (HSub.hSub c a) (HSub.hSub c b)","decl":"theorem comp_sub_left (hf : IntervalIntegrable f volume a b) (c : ℝ) :\n    IntervalIntegrable (fun x => f (c - x)) volume (c - a) (c - b) := by\n  simpa only [neg_sub, ← sub_eq_add_neg] using iff_comp_neg.mp (hf.comp_add_left c)\n\n"}
{"name":"ContinuousOn.intervalIntegrable","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\nμ : MeasureTheory.Measure Real\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nu : Real → E\na b : Real\nhu : ContinuousOn u (Set.uIcc a b)\n⊢ IntervalIntegrable u μ a b","decl":"theorem ContinuousOn.intervalIntegrable {u : ℝ → E} {a b : ℝ} (hu : ContinuousOn u (uIcc a b)) :\n    IntervalIntegrable u μ a b :=\n  (ContinuousOn.integrableOn_Icc hu).intervalIntegrable\n\n"}
{"name":"ContinuousOn.intervalIntegrable_of_Icc","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\nμ : MeasureTheory.Measure Real\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nu : Real → E\na b : Real\nh : LE.le a b\nhu : ContinuousOn u (Set.Icc a b)\n⊢ IntervalIntegrable u μ a b","decl":"theorem ContinuousOn.intervalIntegrable_of_Icc {u : ℝ → E} {a b : ℝ} (h : a ≤ b)\n    (hu : ContinuousOn u (Icc a b)) : IntervalIntegrable u μ a b :=\n  ContinuousOn.intervalIntegrable ((uIcc_of_le h).symm ▸ hu)\n\n"}
{"name":"Continuous.intervalIntegrable","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\nμ : MeasureTheory.Measure Real\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nu : Real → E\nhu : Continuous u\na b : Real\n⊢ IntervalIntegrable u μ a b","decl":"/-- A continuous function on `ℝ` is `IntervalIntegrable` with respect to any locally finite measure\n`ν` on ℝ. -/\ntheorem Continuous.intervalIntegrable {u : ℝ → E} (hu : Continuous u) (a b : ℝ) :\n    IntervalIntegrable u μ a b :=\n  hu.continuousOn.intervalIntegrable\n\n"}
{"name":"MonotoneOn.intervalIntegrable","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝⁴ : NormedAddCommGroup E\nμ : MeasureTheory.Measure Real\ninst✝³ : MeasureTheory.IsLocallyFiniteMeasure μ\ninst✝² : ConditionallyCompleteLinearOrder E\ninst✝¹ : OrderTopology E\ninst✝ : SecondCountableTopology E\nu : Real → E\na b : Real\nhu : MonotoneOn u (Set.uIcc a b)\n⊢ IntervalIntegrable u μ a b","decl":"theorem MonotoneOn.intervalIntegrable {u : ℝ → E} {a b : ℝ} (hu : MonotoneOn u (uIcc a b)) :\n    IntervalIntegrable u μ a b := by\n  rw [intervalIntegrable_iff]\n  exact (hu.integrableOn_isCompact isCompact_uIcc).mono_set Ioc_subset_Icc_self\n\n"}
{"name":"AntitoneOn.intervalIntegrable","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝⁴ : NormedAddCommGroup E\nμ : MeasureTheory.Measure Real\ninst✝³ : MeasureTheory.IsLocallyFiniteMeasure μ\ninst✝² : ConditionallyCompleteLinearOrder E\ninst✝¹ : OrderTopology E\ninst✝ : SecondCountableTopology E\nu : Real → E\na b : Real\nhu : AntitoneOn u (Set.uIcc a b)\n⊢ IntervalIntegrable u μ a b","decl":"theorem AntitoneOn.intervalIntegrable {u : ℝ → E} {a b : ℝ} (hu : AntitoneOn u (uIcc a b)) :\n    IntervalIntegrable u μ a b :=\n  hu.dual_right.intervalIntegrable\n\n"}
{"name":"Monotone.intervalIntegrable","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝⁴ : NormedAddCommGroup E\nμ : MeasureTheory.Measure Real\ninst✝³ : MeasureTheory.IsLocallyFiniteMeasure μ\ninst✝² : ConditionallyCompleteLinearOrder E\ninst✝¹ : OrderTopology E\ninst✝ : SecondCountableTopology E\nu : Real → E\na b : Real\nhu : Monotone u\n⊢ IntervalIntegrable u μ a b","decl":"theorem Monotone.intervalIntegrable {u : ℝ → E} {a b : ℝ} (hu : Monotone u) :\n    IntervalIntegrable u μ a b :=\n  (hu.monotoneOn _).intervalIntegrable\n\n"}
{"name":"Antitone.intervalIntegrable","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝⁴ : NormedAddCommGroup E\nμ : MeasureTheory.Measure Real\ninst✝³ : MeasureTheory.IsLocallyFiniteMeasure μ\ninst✝² : ConditionallyCompleteLinearOrder E\ninst✝¹ : OrderTopology E\ninst✝ : SecondCountableTopology E\nu : Real → E\na b : Real\nhu : Antitone u\n⊢ IntervalIntegrable u μ a b","decl":"theorem Antitone.intervalIntegrable {u : ℝ → E} {a b : ℝ} (hu : Antitone u) :\n    IntervalIntegrable u μ a b :=\n  (hu.antitoneOn _).intervalIntegrable\n\n"}
{"name":"intervalIntegrable_of_even₀","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\nh₁f : ∀ (x : Real), Eq (f x) (f (Neg.neg x))\nh₂f : ∀ (x : Real), LT.lt 0 x → IntervalIntegrable f MeasureTheory.MeasureSpace.volume 0 x\nt : Real\n⊢ IntervalIntegrable f MeasureTheory.MeasureSpace.volume 0 t","decl":"/-- An even function is interval integrable (with respect to the volume measure) on every interval\nof the form `0..x` if it is interval integrable (with respect to the volume measure) on every\ninterval of the form `0..x`, for positive `x`.\n\nSee `intervalIntegrable_of_even` for a stronger result.-/\nlemma intervalIntegrable_of_even₀ (h₁f : ∀ x, f x = f (-x))\n    (h₂f : ∀ x, 0 < x → IntervalIntegrable f volume 0 x) (t : ℝ) :\n    IntervalIntegrable f volume 0 t := by\n  rcases lt_trichotomy t 0 with h | h | h\n  · rw [IntervalIntegrable.iff_comp_neg]\n    conv => arg 1; intro t; rw [← h₁f]\n    simp [h₂f (-t) (by norm_num [h])]\n  · rw [h]\n  · exact h₂f t h\n\n"}
{"name":"intervalIntegrable_of_even","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\nh₁f : ∀ (x : Real), Eq (f x) (f (Neg.neg x))\nh₂f : ∀ (x : Real), LT.lt 0 x → IntervalIntegrable f MeasureTheory.MeasureSpace.volume 0 x\na b : Real\n⊢ IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b","decl":"/-- An even function is interval integrable (with respect to the volume measure) on every interval\nif it is interval integrable (with respect to the volume measure) on every interval of the form\n`0..x`, for positive `x`. -/\ntheorem intervalIntegrable_of_even\n  (h₁f : ∀ x, f x = f (-x)) (h₂f : ∀ x, 0 < x → IntervalIntegrable f volume 0 x) (a b : ℝ) :\n  IntervalIntegrable f volume a b :=\n  -- Split integral and apply lemma\n  (intervalIntegrable_of_even₀ h₁f h₂f a).symm.trans (b := 0)\n    (intervalIntegrable_of_even₀ h₁f h₂f b)\n\n"}
{"name":"intervalIntegrable_of_odd₀","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\nh₁f : ∀ (x : Real), Eq (Neg.neg (f x)) (f (Neg.neg x))\nh₂f : ∀ (x : Real), LT.lt 0 x → IntervalIntegrable f MeasureTheory.MeasureSpace.volume 0 x\nt : Real\n⊢ IntervalIntegrable f MeasureTheory.MeasureSpace.volume 0 t","decl":"/-- An odd function is interval integrable (with respect to the volume measure) on every interval\nof the form `0..x` if it is interval integrable (with respect to the volume measure) on every\ninterval of the form `0..x`, for positive `x`.\n\nSee `intervalIntegrable_of_odd` for a stronger result.-/\nlemma intervalIntegrable_of_odd₀\n  (h₁f : ∀ x, -f x = f (-x)) (h₂f : ∀ x, 0 < x → IntervalIntegrable f volume 0 x) (t : ℝ) :\n  IntervalIntegrable f volume 0 t := by\n  rcases lt_trichotomy t 0 with h | h | h\n  · rw [IntervalIntegrable.iff_comp_neg]\n    conv => arg 1; intro t; rw [← h₁f]\n    apply IntervalIntegrable.neg\n    simp [h₂f (-t) (by norm_num [h])]\n  · rw [h]\n  · exact h₂f t h\n\n"}
{"name":"intervalIntegrable_of_odd","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝ : NormedAddCommGroup E\nf : Real → E\nh₁f : ∀ (x : Real), Eq (Neg.neg (f x)) (f (Neg.neg x))\nh₂f : ∀ (x : Real), LT.lt 0 x → IntervalIntegrable f MeasureTheory.MeasureSpace.volume 0 x\na b : Real\n⊢ IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b","decl":"/-- An odd function is interval integrable (with respect to the volume measure) on every interval\niff it is interval integrable (with respect to the volume measure) on every interval of the form\n`0..x`, for positive `x`. -/\ntheorem intervalIntegrable_of_odd\n  (h₁f : ∀ x, -f x = f (-x)) (h₂f : ∀ x, 0 < x → IntervalIntegrable f volume 0 x) (a b : ℝ) :\n  IntervalIntegrable f volume a b :=\n  -- Split integral and apply lemma\n  (intervalIntegrable_of_odd₀ h₁f h₂f a).symm.trans (b := 0) (intervalIntegrable_of_odd₀ h₁f h₂f b)\n\n"}
{"name":"Filter.Tendsto.eventually_intervalIntegrable_ae","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"ι : Type u_1\nE : Type u_3\ninst✝² : NormedAddCommGroup E\nf : Real → E\nμ : MeasureTheory.Measure Real\nl l' : Filter Real\nhfm : StronglyMeasurableAtFilter f l' μ\ninst✝¹ : Filter.TendstoIxxClass Set.Ioc l l'\ninst✝ : l'.IsMeasurablyGenerated\nhμ : μ.FiniteAtFilter l'\nc : E\nhf : Filter.Tendsto f (Min.min l' (MeasureTheory.ae μ)) (nhds c)\nu v : ι → Real\nlt : Filter ι\nhu : Filter.Tendsto u lt l\nhv : Filter.Tendsto v lt l\n⊢ Filter.Eventually (fun t => IntervalIntegrable f μ (u t) (v t)) lt","decl":"/-- Let `l'` be a measurably generated filter; let `l` be a of filter such that each `s ∈ l'`\neventually includes `Ioc u v` as both `u` and `v` tend to `l`. Let `μ` be a measure finite at `l'`.\n\nSuppose that `f : ℝ → E` has a finite limit at `l' ⊓ ae μ`. Then `f` is interval integrable on\n`u..v` provided that both `u` and `v` tend to `l`.\n\nTypeclass instances allow Lean to find `l'` based on `l` but not vice versa, so\n`apply Tendsto.eventually_intervalIntegrable_ae` will generate goals `Filter ℝ` and\n`TendstoIxxClass Ioc ?m_1 l'`. -/\ntheorem Filter.Tendsto.eventually_intervalIntegrable_ae {f : ℝ → E} {μ : Measure ℝ}\n    {l l' : Filter ℝ} (hfm : StronglyMeasurableAtFilter f l' μ) [TendstoIxxClass Ioc l l']\n    [IsMeasurablyGenerated l'] (hμ : μ.FiniteAtFilter l') {c : E} (hf : Tendsto f (l' ⊓ ae μ) (𝓝 c))\n    {u v : ι → ℝ} {lt : Filter ι} (hu : Tendsto u lt l) (hv : Tendsto v lt l) :\n    ∀ᶠ t in lt, IntervalIntegrable f μ (u t) (v t) :=\n  have := (hf.integrableAtFilter_ae hfm hμ).eventually\n  ((hu.Ioc hv).eventually this).and <| (hv.Ioc hu).eventually this\n\n"}
{"name":"Filter.Tendsto.eventually_intervalIntegrable","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"ι : Type u_1\nE : Type u_3\ninst✝² : NormedAddCommGroup E\nf : Real → E\nμ : MeasureTheory.Measure Real\nl l' : Filter Real\nhfm : StronglyMeasurableAtFilter f l' μ\ninst✝¹ : Filter.TendstoIxxClass Set.Ioc l l'\ninst✝ : l'.IsMeasurablyGenerated\nhμ : μ.FiniteAtFilter l'\nc : E\nhf : Filter.Tendsto f l' (nhds c)\nu v : ι → Real\nlt : Filter ι\nhu : Filter.Tendsto u lt l\nhv : Filter.Tendsto v lt l\n⊢ Filter.Eventually (fun t => IntervalIntegrable f μ (u t) (v t)) lt","decl":"/-- Let `l'` be a measurably generated filter; let `l` be a of filter such that each `s ∈ l'`\neventually includes `Ioc u v` as both `u` and `v` tend to `l`. Let `μ` be a measure finite at `l'`.\n\nSuppose that `f : ℝ → E` has a finite limit at `l`. Then `f` is interval integrable on `u..v`\nprovided that both `u` and `v` tend to `l`.\n\nTypeclass instances allow Lean to find `l'` based on `l` but not vice versa, so\n`apply Tendsto.eventually_intervalIntegrable` will generate goals `Filter ℝ` and\n`TendstoIxxClass Ioc ?m_1 l'`. -/\ntheorem Filter.Tendsto.eventually_intervalIntegrable {f : ℝ → E} {μ : Measure ℝ} {l l' : Filter ℝ}\n    (hfm : StronglyMeasurableAtFilter f l' μ) [TendstoIxxClass Ioc l l'] [IsMeasurablyGenerated l']\n    (hμ : μ.FiniteAtFilter l') {c : E} (hf : Tendsto f l' (𝓝 c)) {u v : ι → ℝ} {lt : Filter ι}\n    (hu : Tendsto u lt l) (hv : Tendsto v lt l) : ∀ᶠ t in lt, IntervalIntegrable f μ (u t) (v t) :=\n  (hf.mono_left inf_le_left).eventually_intervalIntegrable_ae hfm hμ hu hv\n\n"}
{"name":"intervalIntegral.integral_zero","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nμ : MeasureTheory.Measure Real\n⊢ Eq (intervalIntegral (fun x => 0) a b μ) 0","decl":"@[simp]\ntheorem integral_zero : (∫ _ in a..b, (0 : E) ∂μ) = 0 := by simp [intervalIntegral]\n\n"}
{"name":"intervalIntegral.integral_of_le","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf : Real → E\nμ : MeasureTheory.Measure Real\nh : LE.le a b\n⊢ Eq (intervalIntegral (fun x => f x) a b μ) (MeasureTheory.integral (μ.restrict (Set.Ioc a b)) fun x => f x)","decl":"theorem integral_of_le (h : a ≤ b) : ∫ x in a..b, f x ∂μ = ∫ x in Ioc a b, f x ∂μ := by\n  simp [intervalIntegral, h]\n\n"}
{"name":"intervalIntegral.integral_same","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na : Real\nf : Real → E\nμ : MeasureTheory.Measure Real\n⊢ Eq (intervalIntegral (fun x => f x) a a μ) 0","decl":"@[simp]\ntheorem integral_same : ∫ x in a..a, f x ∂μ = 0 :=\n  sub_self _\n\n"}
{"name":"intervalIntegral.integral_symm","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : Real → E\nμ : MeasureTheory.Measure Real\na b : Real\n⊢ Eq (intervalIntegral (fun x => f x) b a μ) (Neg.neg (intervalIntegral (fun x => f x) a b μ))","decl":"theorem integral_symm (a b) : ∫ x in b..a, f x ∂μ = -∫ x in a..b, f x ∂μ := by\n  simp only [intervalIntegral, neg_sub]\n\n"}
{"name":"intervalIntegral.integral_of_ge","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf : Real → E\nμ : MeasureTheory.Measure Real\nh : LE.le b a\n⊢ Eq (intervalIntegral (fun x => f x) a b μ) (Neg.neg (MeasureTheory.integral (μ.restrict (Set.Ioc b a)) fun x => f x))","decl":"theorem integral_of_ge (h : b ≤ a) : ∫ x in a..b, f x ∂μ = -∫ x in Ioc b a, f x ∂μ := by\n  simp only [integral_symm b, integral_of_le h]\n\n"}
{"name":"intervalIntegral.intervalIntegral_eq_integral_uIoc","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : Real → E\na b : Real\nμ : MeasureTheory.Measure Real\n⊢ Eq (intervalIntegral (fun x => f x) a b μ) (HSMul.hSMul (ite (LE.le a b) 1 (-1)) (MeasureTheory.integral (μ.restrict (Set.uIoc a b)) fun x => f x))","decl":"theorem intervalIntegral_eq_integral_uIoc (f : ℝ → E) (a b : ℝ) (μ : Measure ℝ) :\n    ∫ x in a..b, f x ∂μ = (if a ≤ b then 1 else -1 : ℝ) • ∫ x in Ι a b, f x ∂μ := by\n  split_ifs with h\n  · simp only [integral_of_le h, uIoc_of_le h, one_smul]\n  · simp only [integral_of_ge (not_le.1 h).le, uIoc_of_ge (not_le.1 h).le, neg_one_smul]\n\n"}
{"name":"intervalIntegral.norm_intervalIntegral_eq","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : Real → E\na b : Real\nμ : MeasureTheory.Measure Real\n⊢ Eq (Norm.norm (intervalIntegral (fun x => f x) a b μ)) (Norm.norm (MeasureTheory.integral (μ.restrict (Set.uIoc a b)) fun x => f x))","decl":"theorem norm_intervalIntegral_eq (f : ℝ → E) (a b : ℝ) (μ : Measure ℝ) :\n    ‖∫ x in a..b, f x ∂μ‖ = ‖∫ x in Ι a b, f x ∂μ‖ := by\n  simp_rw [intervalIntegral_eq_integral_uIoc, norm_smul]\n  split_ifs <;> simp only [norm_neg, norm_one, one_mul]\n\n"}
{"name":"intervalIntegral.abs_intervalIntegral_eq","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f : Real → Real\na b : Real\nμ : MeasureTheory.Measure Real\n⊢ Eq (abs (intervalIntegral (fun x => f x) a b μ)) (abs (MeasureTheory.integral (μ.restrict (Set.uIoc a b)) fun x => f x))","decl":"theorem abs_intervalIntegral_eq (f : ℝ → ℝ) (a b : ℝ) (μ : Measure ℝ) :\n    |∫ x in a..b, f x ∂μ| = |∫ x in Ι a b, f x ∂μ| :=\n  norm_intervalIntegral_eq f a b μ\n\n"}
{"name":"intervalIntegral.integral_cases","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nμ : MeasureTheory.Measure Real\nf : Real → E\na b : Real\n⊢ Membership.mem (Insert.insert (MeasureTheory.integral (μ.restrict (Set.uIoc a b)) fun x => f x) (Singleton.singleton (Neg.neg (MeasureTheory.integral (μ.restrict (Set.uIoc a b)) fun x => f x)))) (intervalIntegral (fun x => f x) a b μ)","decl":"theorem integral_cases (f : ℝ → E) (a b) :\n    (∫ x in a..b, f x ∂μ) ∈ ({∫ x in Ι a b, f x ∂μ, -∫ x in Ι a b, f x ∂μ} : Set E) := by\n  rw [intervalIntegral_eq_integral_uIoc]; split_ifs <;> simp\n\n"}
{"name":"intervalIntegral.integral_undef","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf : Real → E\nμ : MeasureTheory.Measure Real\nh : Not (IntervalIntegrable f μ a b)\n⊢ Eq (intervalIntegral (fun x => f x) a b μ) 0","decl":"nonrec theorem integral_undef (h : ¬IntervalIntegrable f μ a b) : ∫ x in a..b, f x ∂μ = 0 := by\n  rw [intervalIntegrable_iff] at h\n  rw [intervalIntegral_eq_integral_uIoc, integral_undef h, smul_zero]\n\n"}
{"name":"intervalIntegral.intervalIntegrable_of_integral_ne_zero","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf : Real → E\nμ : MeasureTheory.Measure Real\nh : Ne (intervalIntegral (fun x => f x) a b μ) 0\n⊢ IntervalIntegrable f μ a b","decl":"theorem intervalIntegrable_of_integral_ne_zero {a b : ℝ} {f : ℝ → E} {μ : Measure ℝ}\n    (h : (∫ x in a..b, f x ∂μ) ≠ 0) : IntervalIntegrable f μ a b :=\n  not_imp_comm.1 integral_undef h\n\n"}
{"name":"intervalIntegral.integral_non_aestronglyMeasurable","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf : Real → E\nμ : MeasureTheory.Measure Real\nhf : Not (MeasureTheory.AEStronglyMeasurable f (μ.restrict (Set.uIoc a b)))\n⊢ Eq (intervalIntegral (fun x => f x) a b μ) 0","decl":"nonrec theorem integral_non_aestronglyMeasurable\n    (hf : ¬AEStronglyMeasurable f (μ.restrict (Ι a b))) :\n    ∫ x in a..b, f x ∂μ = 0 := by\n  rw [intervalIntegral_eq_integral_uIoc, integral_non_aestronglyMeasurable hf, smul_zero]\n\n"}
{"name":"intervalIntegral.integral_non_aestronglyMeasurable_of_le","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf : Real → E\nμ : MeasureTheory.Measure Real\nh : LE.le a b\nhf : Not (MeasureTheory.AEStronglyMeasurable f (μ.restrict (Set.Ioc a b)))\n⊢ Eq (intervalIntegral (fun x => f x) a b μ) 0","decl":"theorem integral_non_aestronglyMeasurable_of_le (h : a ≤ b)\n    (hf : ¬AEStronglyMeasurable f (μ.restrict (Ioc a b))) : ∫ x in a..b, f x ∂μ = 0 :=\n  integral_non_aestronglyMeasurable <| by rwa [uIoc_of_le h]\n\n"}
{"name":"intervalIntegral.norm_integral_min_max","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nμ : MeasureTheory.Measure Real\nf : Real → E\n⊢ Eq (Norm.norm (intervalIntegral (fun x => f x) (Min.min a b) (Max.max a b) μ)) (Norm.norm (intervalIntegral (fun x => f x) a b μ))","decl":"theorem norm_integral_min_max (f : ℝ → E) :\n    ‖∫ x in min a b..max a b, f x ∂μ‖ = ‖∫ x in a..b, f x ∂μ‖ := by\n  cases le_total a b <;> simp [*, integral_symm a b]\n\n"}
{"name":"intervalIntegral.norm_integral_eq_norm_integral_Ioc","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nμ : MeasureTheory.Measure Real\nf : Real → E\n⊢ Eq (Norm.norm (intervalIntegral (fun x => f x) a b μ)) (Norm.norm (MeasureTheory.integral (μ.restrict (Set.uIoc a b)) fun x => f x))","decl":"theorem norm_integral_eq_norm_integral_Ioc (f : ℝ → E) :\n    ‖∫ x in a..b, f x ∂μ‖ = ‖∫ x in Ι a b, f x ∂μ‖ := by\n  rw [← norm_integral_min_max, integral_of_le min_le_max, uIoc]\n\n"}
{"name":"intervalIntegral.abs_integral_eq_abs_integral_uIoc","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"a b : Real\nμ : MeasureTheory.Measure Real\nf : Real → Real\n⊢ Eq (abs (intervalIntegral (fun x => f x) a b μ)) (abs (MeasureTheory.integral (μ.restrict (Set.uIoc a b)) fun x => f x))","decl":"theorem abs_integral_eq_abs_integral_uIoc (f : ℝ → ℝ) :\n    |∫ x in a..b, f x ∂μ| = |∫ x in Ι a b, f x ∂μ| :=\n  norm_integral_eq_norm_integral_Ioc f\n\n"}
{"name":"intervalIntegral.norm_integral_le_integral_norm_Ioc","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf : Real → E\nμ : MeasureTheory.Measure Real\n⊢ LE.le (Norm.norm (intervalIntegral (fun x => f x) a b μ)) (MeasureTheory.integral (μ.restrict (Set.uIoc a b)) fun x => Norm.norm (f x))","decl":"theorem norm_integral_le_integral_norm_Ioc : ‖∫ x in a..b, f x ∂μ‖ ≤ ∫ x in Ι a b, ‖f x‖ ∂μ :=\n  calc\n    ‖∫ x in a..b, f x ∂μ‖ = ‖∫ x in Ι a b, f x ∂μ‖ := norm_integral_eq_norm_integral_Ioc f\n    _ ≤ ∫ x in Ι a b, ‖f x‖ ∂μ := norm_integral_le_integral_norm f\n\n"}
{"name":"intervalIntegral.norm_integral_le_abs_integral_norm","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf : Real → E\nμ : MeasureTheory.Measure Real\n⊢ LE.le (Norm.norm (intervalIntegral (fun x => f x) a b μ)) (abs (intervalIntegral (fun x => Norm.norm (f x)) a b μ))","decl":"theorem norm_integral_le_abs_integral_norm : ‖∫ x in a..b, f x ∂μ‖ ≤ |∫ x in a..b, ‖f x‖ ∂μ| := by\n  simp only [← Real.norm_eq_abs, norm_integral_eq_norm_integral_Ioc]\n  exact le_trans (norm_integral_le_integral_norm _) (le_abs_self _)\n\n"}
{"name":"intervalIntegral.norm_integral_le_integral_norm","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf : Real → E\nμ : MeasureTheory.Measure Real\nh : LE.le a b\n⊢ LE.le (Norm.norm (intervalIntegral (fun x => f x) a b μ)) (intervalIntegral (fun x => Norm.norm (f x)) a b μ)","decl":"theorem norm_integral_le_integral_norm (h : a ≤ b) :\n    ‖∫ x in a..b, f x ∂μ‖ ≤ ∫ x in a..b, ‖f x‖ ∂μ :=\n  norm_integral_le_integral_norm_Ioc.trans_eq <| by rw [uIoc_of_le h, integral_of_le h]\n\n"}
{"name":"intervalIntegral.norm_integral_le_of_norm_le","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf : Real → E\nμ : MeasureTheory.Measure Real\ng : Real → Real\nh : Filter.Eventually (fun t => LE.le (Norm.norm (f t)) (g t)) (MeasureTheory.ae (μ.restrict (Set.uIoc a b)))\nhbound : IntervalIntegrable g μ a b\n⊢ LE.le (Norm.norm (intervalIntegral (fun t => f t) a b μ)) (abs (intervalIntegral (fun t => g t) a b μ))","decl":"nonrec theorem norm_integral_le_of_norm_le {g : ℝ → ℝ} (h : ∀ᵐ t ∂μ.restrict <| Ι a b, ‖f t‖ ≤ g t)\n    (hbound : IntervalIntegrable g μ a b) : ‖∫ t in a..b, f t ∂μ‖ ≤ |∫ t in a..b, g t ∂μ| := by\n  simp_rw [norm_intervalIntegral_eq, abs_intervalIntegral_eq,\n    abs_eq_self.mpr (integral_nonneg_of_ae <| h.mono fun _t ht => (norm_nonneg _).trans ht),\n    norm_integral_le_of_norm_le hbound.def' h]\n\n"}
{"name":"intervalIntegral.norm_integral_le_of_norm_le_const_ae","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b C : Real\nf : Real → E\nh : Filter.Eventually (fun x => Membership.mem (Set.uIoc a b) x → LE.le (Norm.norm (f x)) C) (MeasureTheory.ae MeasureTheory.MeasureSpace.volume)\n⊢ LE.le (Norm.norm (intervalIntegral (fun x => f x) a b MeasureTheory.MeasureSpace.volume)) (HMul.hMul C (abs (HSub.hSub b a)))","decl":"theorem norm_integral_le_of_norm_le_const_ae {a b C : ℝ} {f : ℝ → E}\n    (h : ∀ᵐ x, x ∈ Ι a b → ‖f x‖ ≤ C) : ‖∫ x in a..b, f x‖ ≤ C * |b - a| := by\n  rw [norm_integral_eq_norm_integral_Ioc]\n  convert norm_setIntegral_le_of_norm_le_const_ae'' _ measurableSet_Ioc h using 1\n  · rw [Real.volume_Ioc, max_sub_min_eq_abs, ENNReal.toReal_ofReal (abs_nonneg _)]\n  · simp only [Real.volume_Ioc, ENNReal.ofReal_lt_top]\n\n"}
{"name":"intervalIntegral.norm_integral_le_of_norm_le_const","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b C : Real\nf : Real → E\nh : ∀ (x : Real), Membership.mem (Set.uIoc a b) x → LE.le (Norm.norm (f x)) C\n⊢ LE.le (Norm.norm (intervalIntegral (fun x => f x) a b MeasureTheory.MeasureSpace.volume)) (HMul.hMul C (abs (HSub.hSub b a)))","decl":"theorem norm_integral_le_of_norm_le_const {a b C : ℝ} {f : ℝ → E} (h : ∀ x ∈ Ι a b, ‖f x‖ ≤ C) :\n    ‖∫ x in a..b, f x‖ ≤ C * |b - a| :=\n  norm_integral_le_of_norm_le_const_ae <| Eventually.of_forall h\n\n"}
{"name":"intervalIntegral.integral_add","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf g : Real → E\nμ : MeasureTheory.Measure Real\nhf : IntervalIntegrable f μ a b\nhg : IntervalIntegrable g μ a b\n⊢ Eq (intervalIntegral (fun x => HAdd.hAdd (f x) (g x)) a b μ) (HAdd.hAdd (intervalIntegral (fun x => f x) a b μ) (intervalIntegral (fun x => g x) a b μ))","decl":"@[simp]\nnonrec theorem integral_add (hf : IntervalIntegrable f μ a b) (hg : IntervalIntegrable g μ a b) :\n    ∫ x in a..b, f x + g x ∂μ = (∫ x in a..b, f x ∂μ) + ∫ x in a..b, g x ∂μ := by\n  simp only [intervalIntegral_eq_integral_uIoc, integral_add hf.def' hg.def', smul_add]\n\n"}
{"name":"intervalIntegral.integral_finset_sum","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nμ : MeasureTheory.Measure Real\nι : Type u_6\ns : Finset ι\nf : ι → Real → E\nh : ∀ (i : ι), Membership.mem s i → IntervalIntegrable (f i) μ a b\n⊢ Eq (intervalIntegral (fun x => s.sum fun i => f i x) a b μ) (s.sum fun i => intervalIntegral (fun x => f i x) a b μ)","decl":"nonrec theorem integral_finset_sum {ι} {s : Finset ι} {f : ι → ℝ → E}\n    (h : ∀ i ∈ s, IntervalIntegrable (f i) μ a b) :\n    ∫ x in a..b, ∑ i ∈ s, f i x ∂μ = ∑ i ∈ s, ∫ x in a..b, f i x ∂μ := by\n  simp only [intervalIntegral_eq_integral_uIoc, integral_finset_sum s fun i hi => (h i hi).def',\n    Finset.smul_sum]\n\n"}
{"name":"intervalIntegral.integral_neg","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf : Real → E\nμ : MeasureTheory.Measure Real\n⊢ Eq (intervalIntegral (fun x => Neg.neg (f x)) a b μ) (Neg.neg (intervalIntegral (fun x => f x) a b μ))","decl":"@[simp]\nnonrec theorem integral_neg : ∫ x in a..b, -f x ∂μ = -∫ x in a..b, f x ∂μ := by\n  simp only [intervalIntegral, integral_neg]; abel\n\n"}
{"name":"intervalIntegral.integral_sub","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf g : Real → E\nμ : MeasureTheory.Measure Real\nhf : IntervalIntegrable f μ a b\nhg : IntervalIntegrable g μ a b\n⊢ Eq (intervalIntegral (fun x => HSub.hSub (f x) (g x)) a b μ) (HSub.hSub (intervalIntegral (fun x => f x) a b μ) (intervalIntegral (fun x => g x) a b μ))","decl":"@[simp]\ntheorem integral_sub (hf : IntervalIntegrable f μ a b) (hg : IntervalIntegrable g μ a b) :\n    ∫ x in a..b, f x - g x ∂μ = (∫ x in a..b, f x ∂μ) - ∫ x in a..b, g x ∂μ := by\n  simpa only [sub_eq_add_neg] using (integral_add hf hg.neg).trans (congr_arg _ integral_neg)\n\n"}
{"name":"intervalIntegral.integral_smul","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\na b : Real\nμ : MeasureTheory.Measure Real\n𝕜 : Type u_6\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : SMulCommClass Real 𝕜 E\nr : 𝕜\nf : Real → E\n⊢ Eq (intervalIntegral (fun x => HSMul.hSMul r (f x)) a b μ) (HSMul.hSMul r (intervalIntegral (fun x => f x) a b μ))","decl":"@[simp]\nnonrec theorem integral_smul {𝕜 : Type*} [NontriviallyNormedField 𝕜] [NormedSpace 𝕜 E]\n    [SMulCommClass ℝ 𝕜 E] (r : 𝕜) (f : ℝ → E) :\n    ∫ x in a..b, r • f x ∂μ = r • ∫ x in a..b, f x ∂μ := by\n  simp only [intervalIntegral, integral_smul, smul_sub]\n\n"}
{"name":"intervalIntegral.integral_smul_const","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\na b : Real\nμ : MeasureTheory.Measure Real\ninst✝² : CompleteSpace E\n𝕜 : Type u_6\ninst✝¹ : RCLike 𝕜\ninst✝ : NormedSpace 𝕜 E\nf : Real → 𝕜\nc : E\n⊢ Eq (intervalIntegral (fun x => HSMul.hSMul (f x) c) a b μ) (HSMul.hSMul (intervalIntegral (fun x => f x) a b μ) c)","decl":"@[simp]\nnonrec theorem integral_smul_const [CompleteSpace E]\n    {𝕜 : Type*} [RCLike 𝕜] [NormedSpace 𝕜 E] (f : ℝ → 𝕜) (c : E) :\n    ∫ x in a..b, f x • c ∂μ = (∫ x in a..b, f x ∂μ) • c := by\n  simp only [intervalIntegral_eq_integral_uIoc, integral_smul_const, smul_assoc]\n\n"}
{"name":"intervalIntegral.integral_const_mul","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"a b : Real\nμ : MeasureTheory.Measure Real\n𝕜 : Type u_6\ninst✝ : RCLike 𝕜\nr : 𝕜\nf : Real → 𝕜\n⊢ Eq (intervalIntegral (fun x => HMul.hMul r (f x)) a b μ) (HMul.hMul r (intervalIntegral (fun x => f x) a b μ))","decl":"@[simp]\ntheorem integral_const_mul {𝕜 : Type*} [RCLike 𝕜] (r : 𝕜) (f : ℝ → 𝕜) :\n    ∫ x in a..b, r * f x ∂μ = r * ∫ x in a..b, f x ∂μ :=\n  integral_smul r f\n\n"}
{"name":"intervalIntegral.integral_mul_const","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"a b : Real\nμ : MeasureTheory.Measure Real\n𝕜 : Type u_6\ninst✝ : RCLike 𝕜\nr : 𝕜\nf : Real → 𝕜\n⊢ Eq (intervalIntegral (fun x => HMul.hMul (f x) r) a b μ) (HMul.hMul (intervalIntegral (fun x => f x) a b μ) r)","decl":"@[simp]\ntheorem integral_mul_const {𝕜 : Type*} [RCLike 𝕜] (r : 𝕜) (f : ℝ → 𝕜) :\n    ∫ x in a..b, f x * r ∂μ = (∫ x in a..b, f x ∂μ) * r := by\n  simpa only [mul_comm r] using integral_const_mul r f\n\n"}
{"name":"intervalIntegral.integral_div","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"a b : Real\nμ : MeasureTheory.Measure Real\n𝕜 : Type u_6\ninst✝ : RCLike 𝕜\nr : 𝕜\nf : Real → 𝕜\n⊢ Eq (intervalIntegral (fun x => HDiv.hDiv (f x) r) a b μ) (HDiv.hDiv (intervalIntegral (fun x => f x) a b μ) r)","decl":"@[simp]\ntheorem integral_div {𝕜 : Type*} [RCLike 𝕜] (r : 𝕜) (f : ℝ → 𝕜) :\n    ∫ x in a..b, f x / r ∂μ = (∫ x in a..b, f x ∂μ) / r := by\n  simpa only [div_eq_mul_inv] using integral_mul_const r⁻¹ f\n\n"}
{"name":"intervalIntegral.integral_const'","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\na b : Real\nμ : MeasureTheory.Measure Real\ninst✝ : CompleteSpace E\nc : E\n⊢ Eq (intervalIntegral (fun x => c) a b μ) (HSMul.hSMul (HSub.hSub (μ (Set.Ioc a b)).toReal (μ (Set.Ioc b a)).toReal) c)","decl":"theorem integral_const' [CompleteSpace E] (c : E) :\n    ∫ _ in a..b, c ∂μ = ((μ <| Ioc a b).toReal - (μ <| Ioc b a).toReal) • c := by\n  simp only [intervalIntegral, setIntegral_const, sub_smul]\n\n"}
{"name":"intervalIntegral.integral_const","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\na b : Real\ninst✝ : CompleteSpace E\nc : E\n⊢ Eq (intervalIntegral (fun x => c) a b MeasureTheory.MeasureSpace.volume) (HSMul.hSMul (HSub.hSub b a) c)","decl":"@[simp]\ntheorem integral_const [CompleteSpace E] (c : E) : ∫ _ in a..b, c = (b - a) • c := by\n  simp only [integral_const', Real.volume_Ioc, ENNReal.toReal_ofReal', ← neg_sub b,\n    max_zero_sub_eq_self]\n\n"}
{"name":"intervalIntegral.integral_smul_measure","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf : Real → E\nμ : MeasureTheory.Measure Real\nc : ENNReal\n⊢ Eq (intervalIntegral (fun x => f x) a b (HSMul.hSMul c μ)) (HSMul.hSMul c.toReal (intervalIntegral (fun x => f x) a b μ))","decl":"nonrec theorem integral_smul_measure (c : ℝ≥0∞) :\n    ∫ x in a..b, f x ∂c • μ = c.toReal • ∫ x in a..b, f x ∂μ := by\n  simp only [intervalIntegral, Measure.restrict_smul, integral_smul_measure, smul_sub]\n\n"}
{"name":"RCLike.intervalIntegral_ofReal","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"𝕜 : Type u_6\ninst✝ : RCLike 𝕜\na b : Real\nμ : MeasureTheory.Measure Real\nf : Real → Real\n⊢ Eq (intervalIntegral (fun x => ↑(f x)) a b μ) ↑(intervalIntegral (fun x => f x) a b μ)","decl":"nonrec theorem _root_.RCLike.intervalIntegral_ofReal {𝕜 : Type*} [RCLike 𝕜] {a b : ℝ}\n    {μ : Measure ℝ} {f : ℝ → ℝ} : (∫ x in a..b, (f x : 𝕜) ∂μ) = ↑(∫ x in a..b, f x ∂μ) := by\n  simp only [intervalIntegral, integral_ofReal, RCLike.ofReal_sub]\n\n"}
{"name":"intervalIntegral.integral_ofReal","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"a b : Real\nμ : MeasureTheory.Measure Real\nf : Real → Real\n⊢ Eq (intervalIntegral (fun x => ↑(f x)) a b μ) ↑(intervalIntegral (fun x => f x) a b μ)","decl":"nonrec theorem integral_ofReal {a b : ℝ} {μ : Measure ℝ} {f : ℝ → ℝ} :\n    (∫ x in a..b, (f x : ℂ) ∂μ) = ↑(∫ x in a..b, f x ∂μ) :=\n  RCLike.intervalIntegral_ofReal\n\n"}
{"name":"ContinuousLinearMap.intervalIntegral_apply","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"𝕜 : Type u_2\nE : Type u_3\nF : Type u_4\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\nμ : MeasureTheory.Measure Real\ninst✝³ : RCLike 𝕜\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\na b : Real\nφ : Real → ContinuousLinearMap (RingHom.id 𝕜) F E\nhφ : IntervalIntegrable φ μ a b\nv : F\n⊢ Eq ((intervalIntegral (fun x => φ x) a b μ) v) (intervalIntegral (fun x => (φ x) v) a b μ)","decl":"theorem _root_.ContinuousLinearMap.intervalIntegral_apply {a b : ℝ} {φ : ℝ → F →L[𝕜] E}\n    (hφ : IntervalIntegrable φ μ a b) (v : F) :\n    (∫ x in a..b, φ x ∂μ) v = ∫ x in a..b, φ x v ∂μ := by\n  simp_rw [intervalIntegral_eq_integral_uIoc, ← integral_apply hφ.def' v, coe_smul', Pi.smul_apply]\n\n"}
{"name":"ContinuousLinearMap.intervalIntegral_comp_comm","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"𝕜 : Type u_2\nE : Type u_3\nF : Type u_4\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace Real E\na b : Real\nμ : MeasureTheory.Measure Real\nf : Real → E\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedSpace 𝕜 E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace 𝕜 F\ninst✝² : NormedSpace Real F\ninst✝¹ : CompleteSpace F\ninst✝ : CompleteSpace E\nL : ContinuousLinearMap (RingHom.id 𝕜) E F\nhf : IntervalIntegrable f μ a b\n⊢ Eq (intervalIntegral (fun x => L (f x)) a b μ) (L (intervalIntegral (fun x => f x) a b μ))","decl":"theorem _root_.ContinuousLinearMap.intervalIntegral_comp_comm [CompleteSpace E] (L : E →L[𝕜] F)\n    (hf : IntervalIntegrable f μ a b) : (∫ x in a..b, L (f x) ∂μ) = L (∫ x in a..b, f x ∂μ) := by\n  simp_rw [intervalIntegral, L.integral_comp_comm hf.1, L.integral_comp_comm hf.2, L.map_sub]\n\n"}
{"name":"intervalIntegral.integral_comp_mul_right","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b c : Real\nf : Real → E\nhc : Ne c 0\n⊢ Eq (intervalIntegral (fun x => f (HMul.hMul x c)) a b MeasureTheory.MeasureSpace.volume) (HSMul.hSMul (Inv.inv c) (intervalIntegral (fun x => f x) (HMul.hMul a c) (HMul.hMul b c) MeasureTheory.MeasureSpace.volume))","decl":"@[simp]\ntheorem integral_comp_mul_right (hc : c ≠ 0) :\n    (∫ x in a..b, f (x * c)) = c⁻¹ • ∫ x in a * c..b * c, f x := by\n  have A : MeasurableEmbedding fun x => x * c :=\n    (Homeomorph.mulRight₀ c hc).isClosedEmbedding.measurableEmbedding\n  conv_rhs => rw [← Real.smul_map_volume_mul_right hc]\n  simp_rw [integral_smul_measure, intervalIntegral, A.setIntegral_map,\n    ENNReal.toReal_ofReal (abs_nonneg c)]\n  cases' hc.lt_or_lt with h h\n  · simp [h, mul_div_cancel_right₀, hc, abs_of_neg,\n      Measure.restrict_congr_set (α := ℝ) (μ := volume) Ico_ae_eq_Ioc]\n  · simp [h, mul_div_cancel_right₀, hc, abs_of_pos]\n\n"}
{"name":"intervalIntegral.smul_integral_comp_mul_right","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf : Real → E\nc : Real\n⊢ Eq (HSMul.hSMul c (intervalIntegral (fun x => f (HMul.hMul x c)) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HMul.hMul a c) (HMul.hMul b c) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem smul_integral_comp_mul_right (c) :\n    (c • ∫ x in a..b, f (x * c)) = ∫ x in a * c..b * c, f x := by\n  by_cases hc : c = 0 <;> simp [hc, integral_comp_mul_right]\n\n"}
{"name":"intervalIntegral.integral_comp_mul_left","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b c : Real\nf : Real → E\nhc : Ne c 0\n⊢ Eq (intervalIntegral (fun x => f (HMul.hMul c x)) a b MeasureTheory.MeasureSpace.volume) (HSMul.hSMul (Inv.inv c) (intervalIntegral (fun x => f x) (HMul.hMul c a) (HMul.hMul c b) MeasureTheory.MeasureSpace.volume))","decl":"@[simp]\ntheorem integral_comp_mul_left (hc : c ≠ 0) :\n    (∫ x in a..b, f (c * x)) = c⁻¹ • ∫ x in c * a..c * b, f x := by\n  simpa only [mul_comm c] using integral_comp_mul_right f hc\n\n"}
{"name":"intervalIntegral.smul_integral_comp_mul_left","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf : Real → E\nc : Real\n⊢ Eq (HSMul.hSMul c (intervalIntegral (fun x => f (HMul.hMul c x)) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HMul.hMul c a) (HMul.hMul c b) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem smul_integral_comp_mul_left (c) :\n    (c • ∫ x in a..b, f (c * x)) = ∫ x in c * a..c * b, f x := by\n  by_cases hc : c = 0 <;> simp [hc, integral_comp_mul_left]\n\n"}
{"name":"intervalIntegral.integral_comp_div","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b c : Real\nf : Real → E\nhc : Ne c 0\n⊢ Eq (intervalIntegral (fun x => f (HDiv.hDiv x c)) a b MeasureTheory.MeasureSpace.volume) (HSMul.hSMul c (intervalIntegral (fun x => f x) (HDiv.hDiv a c) (HDiv.hDiv b c) MeasureTheory.MeasureSpace.volume))","decl":"@[simp]\ntheorem integral_comp_div (hc : c ≠ 0) :\n    (∫ x in a..b, f (x / c)) = c • ∫ x in a / c..b / c, f x := by\n  simpa only [inv_inv] using integral_comp_mul_right f (inv_ne_zero hc)\n\n"}
{"name":"intervalIntegral.inv_smul_integral_comp_div","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf : Real → E\nc : Real\n⊢ Eq (HSMul.hSMul (Inv.inv c) (intervalIntegral (fun x => f (HDiv.hDiv x c)) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HDiv.hDiv a c) (HDiv.hDiv b c) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem inv_smul_integral_comp_div (c) :\n    (c⁻¹ • ∫ x in a..b, f (x / c)) = ∫ x in a / c..b / c, f x := by\n  by_cases hc : c = 0 <;> simp [hc, integral_comp_div]\n\n"}
{"name":"intervalIntegral.integral_comp_add_right","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf : Real → E\nd : Real\n⊢ Eq (intervalIntegral (fun x => f (HAdd.hAdd x d)) a b MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => f x) (HAdd.hAdd a d) (HAdd.hAdd b d) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem integral_comp_add_right (d) : (∫ x in a..b, f (x + d)) = ∫ x in a + d..b + d, f x :=\n  have A : MeasurableEmbedding fun x => x + d :=\n    (Homeomorph.addRight d).isClosedEmbedding.measurableEmbedding\n  calc\n    (∫ x in a..b, f (x + d)) = ∫ x in a + d..b + d, f x ∂Measure.map (fun x => x + d) volume := by\n      simp [intervalIntegral, A.setIntegral_map]\n    _ = ∫ x in a + d..b + d, f x := by rw [map_add_right_eq_self]\n\n"}
{"name":"intervalIntegral.integral_comp_add_left","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf : Real → E\nd : Real\n⊢ Eq (intervalIntegral (fun x => f (HAdd.hAdd d x)) a b MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => f x) (HAdd.hAdd d a) (HAdd.hAdd d b) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\nnonrec theorem integral_comp_add_left (d) :\n    (∫ x in a..b, f (d + x)) = ∫ x in d + a..d + b, f x := by\n  simpa only [add_comm d] using integral_comp_add_right f d\n\n"}
{"name":"intervalIntegral.integral_comp_mul_add","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b c : Real\nf : Real → E\nhc : Ne c 0\nd : Real\n⊢ Eq (intervalIntegral (fun x => f (HAdd.hAdd (HMul.hMul c x) d)) a b MeasureTheory.MeasureSpace.volume) (HSMul.hSMul (Inv.inv c) (intervalIntegral (fun x => f x) (HAdd.hAdd (HMul.hMul c a) d) (HAdd.hAdd (HMul.hMul c b) d) MeasureTheory.MeasureSpace.volume))","decl":"@[simp]\ntheorem integral_comp_mul_add (hc : c ≠ 0) (d) :\n    (∫ x in a..b, f (c * x + d)) = c⁻¹ • ∫ x in c * a + d..c * b + d, f x := by\n  rw [← integral_comp_add_right, ← integral_comp_mul_left _ hc]\n\n"}
{"name":"intervalIntegral.smul_integral_comp_mul_add","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf : Real → E\nc d : Real\n⊢ Eq (HSMul.hSMul c (intervalIntegral (fun x => f (HAdd.hAdd (HMul.hMul c x) d)) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HAdd.hAdd (HMul.hMul c a) d) (HAdd.hAdd (HMul.hMul c b) d) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem smul_integral_comp_mul_add (c d) :\n    (c • ∫ x in a..b, f (c * x + d)) = ∫ x in c * a + d..c * b + d, f x := by\n  by_cases hc : c = 0 <;> simp [hc, integral_comp_mul_add]\n\n"}
{"name":"intervalIntegral.integral_comp_add_mul","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b c : Real\nf : Real → E\nhc : Ne c 0\nd : Real\n⊢ Eq (intervalIntegral (fun x => f (HAdd.hAdd d (HMul.hMul c x))) a b MeasureTheory.MeasureSpace.volume) (HSMul.hSMul (Inv.inv c) (intervalIntegral (fun x => f x) (HAdd.hAdd d (HMul.hMul c a)) (HAdd.hAdd d (HMul.hMul c b)) MeasureTheory.MeasureSpace.volume))","decl":"@[simp]\ntheorem integral_comp_add_mul (hc : c ≠ 0) (d) :\n    (∫ x in a..b, f (d + c * x)) = c⁻¹ • ∫ x in d + c * a..d + c * b, f x := by\n  rw [← integral_comp_add_left, ← integral_comp_mul_left _ hc]\n\n"}
{"name":"intervalIntegral.smul_integral_comp_add_mul","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf : Real → E\nc d : Real\n⊢ Eq (HSMul.hSMul c (intervalIntegral (fun x => f (HAdd.hAdd d (HMul.hMul c x))) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HAdd.hAdd d (HMul.hMul c a)) (HAdd.hAdd d (HMul.hMul c b)) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem smul_integral_comp_add_mul (c d) :\n    (c • ∫ x in a..b, f (d + c * x)) = ∫ x in d + c * a..d + c * b, f x := by\n  by_cases hc : c = 0 <;> simp [hc, integral_comp_add_mul]\n\n"}
{"name":"intervalIntegral.integral_comp_div_add","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b c : Real\nf : Real → E\nhc : Ne c 0\nd : Real\n⊢ Eq (intervalIntegral (fun x => f (HAdd.hAdd (HDiv.hDiv x c) d)) a b MeasureTheory.MeasureSpace.volume) (HSMul.hSMul c (intervalIntegral (fun x => f x) (HAdd.hAdd (HDiv.hDiv a c) d) (HAdd.hAdd (HDiv.hDiv b c) d) MeasureTheory.MeasureSpace.volume))","decl":"@[simp]\ntheorem integral_comp_div_add (hc : c ≠ 0) (d) :\n    (∫ x in a..b, f (x / c + d)) = c • ∫ x in a / c + d..b / c + d, f x := by\n  simpa only [div_eq_inv_mul, inv_inv] using integral_comp_mul_add f (inv_ne_zero hc) d\n\n"}
{"name":"intervalIntegral.inv_smul_integral_comp_div_add","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf : Real → E\nc d : Real\n⊢ Eq (HSMul.hSMul (Inv.inv c) (intervalIntegral (fun x => f (HAdd.hAdd (HDiv.hDiv x c) d)) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HAdd.hAdd (HDiv.hDiv a c) d) (HAdd.hAdd (HDiv.hDiv b c) d) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem inv_smul_integral_comp_div_add (c d) :\n    (c⁻¹ • ∫ x in a..b, f (x / c + d)) = ∫ x in a / c + d..b / c + d, f x := by\n  by_cases hc : c = 0 <;> simp [hc, integral_comp_div_add]\n\n"}
{"name":"intervalIntegral.integral_comp_add_div","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b c : Real\nf : Real → E\nhc : Ne c 0\nd : Real\n⊢ Eq (intervalIntegral (fun x => f (HAdd.hAdd d (HDiv.hDiv x c))) a b MeasureTheory.MeasureSpace.volume) (HSMul.hSMul c (intervalIntegral (fun x => f x) (HAdd.hAdd d (HDiv.hDiv a c)) (HAdd.hAdd d (HDiv.hDiv b c)) MeasureTheory.MeasureSpace.volume))","decl":"@[simp]\ntheorem integral_comp_add_div (hc : c ≠ 0) (d) :\n    (∫ x in a..b, f (d + x / c)) = c • ∫ x in d + a / c..d + b / c, f x := by\n  simpa only [div_eq_inv_mul, inv_inv] using integral_comp_add_mul f (inv_ne_zero hc) d\n\n"}
{"name":"intervalIntegral.inv_smul_integral_comp_add_div","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf : Real → E\nc d : Real\n⊢ Eq (HSMul.hSMul (Inv.inv c) (intervalIntegral (fun x => f (HAdd.hAdd d (HDiv.hDiv x c))) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HAdd.hAdd d (HDiv.hDiv a c)) (HAdd.hAdd d (HDiv.hDiv b c)) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem inv_smul_integral_comp_add_div (c d) :\n    (c⁻¹ • ∫ x in a..b, f (d + x / c)) = ∫ x in d + a / c..d + b / c, f x := by\n  by_cases hc : c = 0 <;> simp [hc, integral_comp_add_div]\n\n"}
{"name":"intervalIntegral.integral_comp_mul_sub","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b c : Real\nf : Real → E\nhc : Ne c 0\nd : Real\n⊢ Eq (intervalIntegral (fun x => f (HSub.hSub (HMul.hMul c x) d)) a b MeasureTheory.MeasureSpace.volume) (HSMul.hSMul (Inv.inv c) (intervalIntegral (fun x => f x) (HSub.hSub (HMul.hMul c a) d) (HSub.hSub (HMul.hMul c b) d) MeasureTheory.MeasureSpace.volume))","decl":"@[simp]\ntheorem integral_comp_mul_sub (hc : c ≠ 0) (d) :\n    (∫ x in a..b, f (c * x - d)) = c⁻¹ • ∫ x in c * a - d..c * b - d, f x := by\n  simpa only [sub_eq_add_neg] using integral_comp_mul_add f hc (-d)\n\n"}
{"name":"intervalIntegral.smul_integral_comp_mul_sub","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf : Real → E\nc d : Real\n⊢ Eq (HSMul.hSMul c (intervalIntegral (fun x => f (HSub.hSub (HMul.hMul c x) d)) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HSub.hSub (HMul.hMul c a) d) (HSub.hSub (HMul.hMul c b) d) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem smul_integral_comp_mul_sub (c d) :\n    (c • ∫ x in a..b, f (c * x - d)) = ∫ x in c * a - d..c * b - d, f x := by\n  by_cases hc : c = 0 <;> simp [hc, integral_comp_mul_sub]\n\n"}
{"name":"intervalIntegral.integral_comp_sub_mul","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b c : Real\nf : Real → E\nhc : Ne c 0\nd : Real\n⊢ Eq (intervalIntegral (fun x => f (HSub.hSub d (HMul.hMul c x))) a b MeasureTheory.MeasureSpace.volume) (HSMul.hSMul (Inv.inv c) (intervalIntegral (fun x => f x) (HSub.hSub d (HMul.hMul c b)) (HSub.hSub d (HMul.hMul c a)) MeasureTheory.MeasureSpace.volume))","decl":"@[simp]\ntheorem integral_comp_sub_mul (hc : c ≠ 0) (d) :\n    (∫ x in a..b, f (d - c * x)) = c⁻¹ • ∫ x in d - c * b..d - c * a, f x := by\n  simp only [sub_eq_add_neg, neg_mul_eq_neg_mul]\n  rw [integral_comp_add_mul f (neg_ne_zero.mpr hc) d, integral_symm]\n  simp only [inv_neg, smul_neg, neg_neg, neg_smul]\n\n"}
{"name":"intervalIntegral.smul_integral_comp_sub_mul","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf : Real → E\nc d : Real\n⊢ Eq (HSMul.hSMul c (intervalIntegral (fun x => f (HSub.hSub d (HMul.hMul c x))) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HSub.hSub d (HMul.hMul c b)) (HSub.hSub d (HMul.hMul c a)) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem smul_integral_comp_sub_mul (c d) :\n    (c • ∫ x in a..b, f (d - c * x)) = ∫ x in d - c * b..d - c * a, f x := by\n  by_cases hc : c = 0 <;> simp [hc, integral_comp_sub_mul]\n\n"}
{"name":"intervalIntegral.integral_comp_div_sub","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b c : Real\nf : Real → E\nhc : Ne c 0\nd : Real\n⊢ Eq (intervalIntegral (fun x => f (HSub.hSub (HDiv.hDiv x c) d)) a b MeasureTheory.MeasureSpace.volume) (HSMul.hSMul c (intervalIntegral (fun x => f x) (HSub.hSub (HDiv.hDiv a c) d) (HSub.hSub (HDiv.hDiv b c) d) MeasureTheory.MeasureSpace.volume))","decl":"@[simp]\ntheorem integral_comp_div_sub (hc : c ≠ 0) (d) :\n    (∫ x in a..b, f (x / c - d)) = c • ∫ x in a / c - d..b / c - d, f x := by\n  simpa only [div_eq_inv_mul, inv_inv] using integral_comp_mul_sub f (inv_ne_zero hc) d\n\n"}
{"name":"intervalIntegral.inv_smul_integral_comp_div_sub","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf : Real → E\nc d : Real\n⊢ Eq (HSMul.hSMul (Inv.inv c) (intervalIntegral (fun x => f (HSub.hSub (HDiv.hDiv x c) d)) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HSub.hSub (HDiv.hDiv a c) d) (HSub.hSub (HDiv.hDiv b c) d) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem inv_smul_integral_comp_div_sub (c d) :\n    (c⁻¹ • ∫ x in a..b, f (x / c - d)) = ∫ x in a / c - d..b / c - d, f x := by\n  by_cases hc : c = 0 <;> simp [hc, integral_comp_div_sub]\n\n"}
{"name":"intervalIntegral.integral_comp_sub_div","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b c : Real\nf : Real → E\nhc : Ne c 0\nd : Real\n⊢ Eq (intervalIntegral (fun x => f (HSub.hSub d (HDiv.hDiv x c))) a b MeasureTheory.MeasureSpace.volume) (HSMul.hSMul c (intervalIntegral (fun x => f x) (HSub.hSub d (HDiv.hDiv b c)) (HSub.hSub d (HDiv.hDiv a c)) MeasureTheory.MeasureSpace.volume))","decl":"@[simp]\ntheorem integral_comp_sub_div (hc : c ≠ 0) (d) :\n    (∫ x in a..b, f (d - x / c)) = c • ∫ x in d - b / c..d - a / c, f x := by\n  simpa only [div_eq_inv_mul, inv_inv] using integral_comp_sub_mul f (inv_ne_zero hc) d\n\n"}
{"name":"intervalIntegral.inv_smul_integral_comp_sub_div","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf : Real → E\nc d : Real\n⊢ Eq (HSMul.hSMul (Inv.inv c) (intervalIntegral (fun x => f (HSub.hSub d (HDiv.hDiv x c))) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HSub.hSub d (HDiv.hDiv b c)) (HSub.hSub d (HDiv.hDiv a c)) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem inv_smul_integral_comp_sub_div (c d) :\n    (c⁻¹ • ∫ x in a..b, f (d - x / c)) = ∫ x in d - b / c..d - a / c, f x := by\n  by_cases hc : c = 0 <;> simp [hc, integral_comp_sub_div]\n\n"}
{"name":"intervalIntegral.integral_comp_sub_right","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf : Real → E\nd : Real\n⊢ Eq (intervalIntegral (fun x => f (HSub.hSub x d)) a b MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => f x) (HSub.hSub a d) (HSub.hSub b d) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem integral_comp_sub_right (d) : (∫ x in a..b, f (x - d)) = ∫ x in a - d..b - d, f x := by\n  simpa only [sub_eq_add_neg] using integral_comp_add_right f (-d)\n\n"}
{"name":"intervalIntegral.integral_comp_sub_left","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf : Real → E\nd : Real\n⊢ Eq (intervalIntegral (fun x => f (HSub.hSub d x)) a b MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => f x) (HSub.hSub d b) (HSub.hSub d a) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem integral_comp_sub_left (d) : (∫ x in a..b, f (d - x)) = ∫ x in d - b..d - a, f x := by\n  simpa only [one_mul, one_smul, inv_one] using integral_comp_sub_mul f one_ne_zero d\n\n"}
{"name":"intervalIntegral.integral_comp_neg","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf : Real → E\n⊢ Eq (intervalIntegral (fun x => f (Neg.neg x)) a b MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => f x) (Neg.neg b) (Neg.neg a) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem integral_comp_neg : (∫ x in a..b, f (-x)) = ∫ x in -b..-a, f x := by\n  simpa only [zero_sub] using integral_comp_sub_left f 0\n\n"}
{"name":"intervalIntegral.integral_congr","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf g : Real → E\nμ : MeasureTheory.Measure Real\na b : Real\nh : Set.EqOn f g (Set.uIcc a b)\n⊢ Eq (intervalIntegral (fun x => f x) a b μ) (intervalIntegral (fun x => g x) a b μ)","decl":"/-- If two functions are equal in the relevant interval, their interval integrals are also equal. -/\ntheorem integral_congr {a b : ℝ} (h : EqOn f g [[a, b]]) :\n    ∫ x in a..b, f x ∂μ = ∫ x in a..b, g x ∂μ := by\n  rcases le_total a b with hab | hab <;>\n    simpa [hab, integral_of_le, integral_of_ge] using\n      setIntegral_congr_fun measurableSet_Ioc (h.mono Ioc_subset_Icc_self)\n\n"}
{"name":"intervalIntegral.integral_add_adjacent_intervals_cancel","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b c : Real\nf : Real → E\nμ : MeasureTheory.Measure Real\nhab : IntervalIntegrable f μ a b\nhbc : IntervalIntegrable f μ b c\n⊢ Eq (HAdd.hAdd (HAdd.hAdd (intervalIntegral (fun x => f x) a b μ) (intervalIntegral (fun x => f x) b c μ)) (intervalIntegral (fun x => f x) c a μ)) 0","decl":"theorem integral_add_adjacent_intervals_cancel (hab : IntervalIntegrable f μ a b)\n    (hbc : IntervalIntegrable f μ b c) :\n    (((∫ x in a..b, f x ∂μ) + ∫ x in b..c, f x ∂μ) + ∫ x in c..a, f x ∂μ) = 0 := by\n  have hac := hab.trans hbc\n  simp only [intervalIntegral, sub_add_sub_comm, sub_eq_zero]\n  iterate 4 rw [← setIntegral_union]\n  · suffices Ioc a b ∪ Ioc b c ∪ Ioc c a = Ioc b a ∪ Ioc c b ∪ Ioc a c by rw [this]\n    rw [Ioc_union_Ioc_union_Ioc_cycle, union_right_comm, Ioc_union_Ioc_union_Ioc_cycle,\n      min_left_comm, max_left_comm]\n  all_goals\n    simp [*, MeasurableSet.union, measurableSet_Ioc, Ioc_disjoint_Ioc_same,\n      Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]\n\n"}
{"name":"intervalIntegral.integral_add_adjacent_intervals","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b c : Real\nf : Real → E\nμ : MeasureTheory.Measure Real\nhab : IntervalIntegrable f μ a b\nhbc : IntervalIntegrable f μ b c\n⊢ Eq (HAdd.hAdd (intervalIntegral (fun x => f x) a b μ) (intervalIntegral (fun x => f x) b c μ)) (intervalIntegral (fun x => f x) a c μ)","decl":"theorem integral_add_adjacent_intervals (hab : IntervalIntegrable f μ a b)\n    (hbc : IntervalIntegrable f μ b c) :\n    ((∫ x in a..b, f x ∂μ) + ∫ x in b..c, f x ∂μ) = ∫ x in a..c, f x ∂μ := by\n  rw [← add_neg_eq_zero, ← integral_symm, integral_add_adjacent_intervals_cancel hab hbc]\n\n"}
{"name":"intervalIntegral.sum_integral_adjacent_intervals_Ico","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : Real → E\nμ : MeasureTheory.Measure Real\na : Nat → Real\nm n : Nat\nhmn : LE.le m n\nhint : ∀ (k : Nat), Membership.mem (Set.Ico m n) k → IntervalIntegrable f μ (a k) (a (HAdd.hAdd k 1))\n⊢ Eq ((Finset.Ico m n).sum fun k => intervalIntegral (fun x => f x) (a k) (a (HAdd.hAdd k 1)) μ) (intervalIntegral (fun x => f x) (a m) (a n) μ)","decl":"theorem sum_integral_adjacent_intervals_Ico {a : ℕ → ℝ} {m n : ℕ} (hmn : m ≤ n)\n    (hint : ∀ k ∈ Ico m n, IntervalIntegrable f μ (a k) (a <| k + 1)) :\n    ∑ k ∈ Finset.Ico m n, ∫ x in a k..a <| k + 1, f x ∂μ = ∫ x in a m..a n, f x ∂μ := by\n  revert hint\n  refine Nat.le_induction ?_ ?_ n hmn\n  · simp\n  · intro p hmp IH h\n    rw [Finset.sum_Ico_succ_top hmp, IH, integral_add_adjacent_intervals]\n    · refine IntervalIntegrable.trans_iterate_Ico hmp fun k hk => h k ?_\n      exact (Ico_subset_Ico le_rfl (Nat.le_succ _)) hk\n    · apply h\n      simp [hmp]\n    · intro k hk\n      exact h _ (Ico_subset_Ico_right p.le_succ hk)\n\n"}
{"name":"intervalIntegral.sum_integral_adjacent_intervals","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : Real → E\nμ : MeasureTheory.Measure Real\na : Nat → Real\nn : Nat\nhint : ∀ (k : Nat), LT.lt k n → IntervalIntegrable f μ (a k) (a (HAdd.hAdd k 1))\n⊢ Eq ((Finset.range n).sum fun k => intervalIntegral (fun x => f x) (a k) (a (HAdd.hAdd k 1)) μ) (intervalIntegral (fun x => f x) (a 0) (a n) μ)","decl":"theorem sum_integral_adjacent_intervals {a : ℕ → ℝ} {n : ℕ}\n    (hint : ∀ k < n, IntervalIntegrable f μ (a k) (a <| k + 1)) :\n    ∑ k ∈ Finset.range n, ∫ x in a k..a <| k + 1, f x ∂μ = ∫ x in (a 0)..(a n), f x ∂μ := by\n  rw [← Nat.Ico_zero_eq_range]\n  exact sum_integral_adjacent_intervals_Ico (zero_le n) fun k hk => hint k hk.2\n\n"}
{"name":"intervalIntegral.integral_interval_sub_left","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b c : Real\nf : Real → E\nμ : MeasureTheory.Measure Real\nhab : IntervalIntegrable f μ a b\nhac : IntervalIntegrable f μ a c\n⊢ Eq (HSub.hSub (intervalIntegral (fun x => f x) a b μ) (intervalIntegral (fun x => f x) a c μ)) (intervalIntegral (fun x => f x) c b μ)","decl":"theorem integral_interval_sub_left (hab : IntervalIntegrable f μ a b)\n    (hac : IntervalIntegrable f μ a c) :\n    ((∫ x in a..b, f x ∂μ) - ∫ x in a..c, f x ∂μ) = ∫ x in c..b, f x ∂μ :=\n  sub_eq_of_eq_add' <| Eq.symm <| integral_add_adjacent_intervals hac (hac.symm.trans hab)\n\n"}
{"name":"intervalIntegral.integral_interval_add_interval_comm","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b c d : Real\nf : Real → E\nμ : MeasureTheory.Measure Real\nhab : IntervalIntegrable f μ a b\nhcd : IntervalIntegrable f μ c d\nhac : IntervalIntegrable f μ a c\n⊢ Eq (HAdd.hAdd (intervalIntegral (fun x => f x) a b μ) (intervalIntegral (fun x => f x) c d μ)) (HAdd.hAdd (intervalIntegral (fun x => f x) a d μ) (intervalIntegral (fun x => f x) c b μ))","decl":"theorem integral_interval_add_interval_comm (hab : IntervalIntegrable f μ a b)\n    (hcd : IntervalIntegrable f μ c d) (hac : IntervalIntegrable f μ a c) :\n    ((∫ x in a..b, f x ∂μ) + ∫ x in c..d, f x ∂μ) =\n      (∫ x in a..d, f x ∂μ) + ∫ x in c..b, f x ∂μ := by\n  rw [← integral_add_adjacent_intervals hac hcd, add_assoc, add_left_comm,\n    integral_add_adjacent_intervals hac (hac.symm.trans hab), add_comm]\n\n"}
{"name":"intervalIntegral.integral_interval_sub_interval_comm","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b c d : Real\nf : Real → E\nμ : MeasureTheory.Measure Real\nhab : IntervalIntegrable f μ a b\nhcd : IntervalIntegrable f μ c d\nhac : IntervalIntegrable f μ a c\n⊢ Eq (HSub.hSub (intervalIntegral (fun x => f x) a b μ) (intervalIntegral (fun x => f x) c d μ)) (HSub.hSub (intervalIntegral (fun x => f x) a c μ) (intervalIntegral (fun x => f x) b d μ))","decl":"theorem integral_interval_sub_interval_comm (hab : IntervalIntegrable f μ a b)\n    (hcd : IntervalIntegrable f μ c d) (hac : IntervalIntegrable f μ a c) :\n    ((∫ x in a..b, f x ∂μ) - ∫ x in c..d, f x ∂μ) =\n      (∫ x in a..c, f x ∂μ) - ∫ x in b..d, f x ∂μ := by\n  simp only [sub_eq_add_neg, ← integral_symm,\n    integral_interval_add_interval_comm hab hcd.symm (hac.trans hcd)]\n\n"}
{"name":"intervalIntegral.integral_interval_sub_interval_comm'","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b c d : Real\nf : Real → E\nμ : MeasureTheory.Measure Real\nhab : IntervalIntegrable f μ a b\nhcd : IntervalIntegrable f μ c d\nhac : IntervalIntegrable f μ a c\n⊢ Eq (HSub.hSub (intervalIntegral (fun x => f x) a b μ) (intervalIntegral (fun x => f x) c d μ)) (HSub.hSub (intervalIntegral (fun x => f x) d b μ) (intervalIntegral (fun x => f x) c a μ))","decl":"theorem integral_interval_sub_interval_comm' (hab : IntervalIntegrable f μ a b)\n    (hcd : IntervalIntegrable f μ c d) (hac : IntervalIntegrable f μ a c) :\n    ((∫ x in a..b, f x ∂μ) - ∫ x in c..d, f x ∂μ) =\n      (∫ x in d..b, f x ∂μ) - ∫ x in c..a, f x ∂μ := by\n  rw [integral_interval_sub_interval_comm hab hcd hac, integral_symm b d, integral_symm a c,\n    sub_neg_eq_add, sub_eq_neg_add]\n\n"}
{"name":"intervalIntegral.integral_Iic_sub_Iic","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf : Real → E\nμ : MeasureTheory.Measure Real\nha : MeasureTheory.IntegrableOn f (Set.Iic a) μ\nhb : MeasureTheory.IntegrableOn f (Set.Iic b) μ\n⊢ Eq (HSub.hSub (MeasureTheory.integral (μ.restrict (Set.Iic b)) fun x => f x) (MeasureTheory.integral (μ.restrict (Set.Iic a)) fun x => f x)) (intervalIntegral (fun x => f x) a b μ)","decl":"theorem integral_Iic_sub_Iic (ha : IntegrableOn f (Iic a) μ) (hb : IntegrableOn f (Iic b) μ) :\n    ((∫ x in Iic b, f x ∂μ) - ∫ x in Iic a, f x ∂μ) = ∫ x in a..b, f x ∂μ := by\n  wlog hab : a ≤ b generalizing a b\n  · rw [integral_symm, ← this hb ha (le_of_not_le hab), neg_sub]\n  rw [sub_eq_iff_eq_add', integral_of_le hab, ← setIntegral_union (Iic_disjoint_Ioc le_rfl),\n    Iic_union_Ioc_eq_Iic hab]\n  exacts [measurableSet_Ioc, ha, hb.mono_set fun _ => And.right]\n\n"}
{"name":"intervalIntegral.integral_Iic_add_Ioi","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nb : Real\nf : Real → E\nμ : MeasureTheory.Measure Real\nh_left : MeasureTheory.IntegrableOn f (Set.Iic b) μ\nh_right : MeasureTheory.IntegrableOn f (Set.Ioi b) μ\n⊢ Eq (HAdd.hAdd (MeasureTheory.integral (μ.restrict (Set.Iic b)) fun x => f x) (MeasureTheory.integral (μ.restrict (Set.Ioi b)) fun x => f x)) (MeasureTheory.integral μ fun x => f x)","decl":"theorem integral_Iic_add_Ioi (h_left : IntegrableOn f (Iic b) μ)\n    (h_right : IntegrableOn f (Ioi b) μ) :\n    (∫ x in Iic b, f x ∂μ) + (∫ x in Ioi b, f x ∂μ) = ∫ (x : ℝ), f x ∂μ := by\n  convert (setIntegral_union (Iic_disjoint_Ioi <| Eq.le rfl) measurableSet_Ioi h_left h_right).symm\n  rw [Iic_union_Ioi, Measure.restrict_univ]\n\n"}
{"name":"intervalIntegral.integral_Iio_add_Ici","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nb : Real\nf : Real → E\nμ : MeasureTheory.Measure Real\nh_left : MeasureTheory.IntegrableOn f (Set.Iio b) μ\nh_right : MeasureTheory.IntegrableOn f (Set.Ici b) μ\n⊢ Eq (HAdd.hAdd (MeasureTheory.integral (μ.restrict (Set.Iio b)) fun x => f x) (MeasureTheory.integral (μ.restrict (Set.Ici b)) fun x => f x)) (MeasureTheory.integral μ fun x => f x)","decl":"theorem integral_Iio_add_Ici (h_left : IntegrableOn f (Iio b) μ)\n    (h_right : IntegrableOn f (Ici b) μ) :\n    (∫ x in Iio b, f x ∂μ) + (∫ x in Ici b, f x ∂μ) = ∫ (x : ℝ), f x ∂μ := by\n  convert (setIntegral_union (Iio_disjoint_Ici <| Eq.le rfl) measurableSet_Ici h_left h_right).symm\n  rw [Iio_union_Ici, Measure.restrict_univ]\n\n"}
{"name":"intervalIntegral.integral_const_of_cdf","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\na b : Real\nμ : MeasureTheory.Measure Real\ninst✝¹ : CompleteSpace E\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nc : E\n⊢ Eq (intervalIntegral (fun x => c) a b μ) (HSMul.hSMul (HSub.hSub (μ (Set.Iic b)).toReal (μ (Set.Iic a)).toReal) c)","decl":"/-- If `μ` is a finite measure then `∫ x in a..b, c ∂μ = (μ (Iic b) - μ (Iic a)) • c`. -/\ntheorem integral_const_of_cdf [CompleteSpace E] [IsFiniteMeasure μ] (c : E) :\n    ∫ _ in a..b, c ∂μ = ((μ (Iic b)).toReal - (μ (Iic a)).toReal) • c := by\n  simp only [sub_smul, ← setIntegral_const]\n  refine (integral_Iic_sub_Iic ?_ ?_).symm <;>\n    simp only [integrableOn_const, measure_lt_top, or_true]\n\n"}
{"name":"intervalIntegral.integral_eq_integral_of_support_subset","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : Real → E\nμ : MeasureTheory.Measure Real\na b : Real\nh : HasSubset.Subset (Function.support f) (Set.Ioc a b)\n⊢ Eq (intervalIntegral (fun x => f x) a b μ) (MeasureTheory.integral μ fun x => f x)","decl":"theorem integral_eq_integral_of_support_subset {a b} (h : support f ⊆ Ioc a b) :\n    ∫ x in a..b, f x ∂μ = ∫ x, f x ∂μ := by\n  rcases le_total a b with hab | hab\n  · rw [integral_of_le hab, ← integral_indicator measurableSet_Ioc, indicator_eq_self.2 h]\n  · rw [Ioc_eq_empty hab.not_lt, subset_empty_iff, support_eq_empty_iff] at h\n    simp [h]\n\n"}
{"name":"intervalIntegral.integral_congr_ae'","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf g : Real → E\nμ : MeasureTheory.Measure Real\nh : Filter.Eventually (fun x => Membership.mem (Set.Ioc a b) x → Eq (f x) (g x)) (MeasureTheory.ae μ)\nh' : Filter.Eventually (fun x => Membership.mem (Set.Ioc b a) x → Eq (f x) (g x)) (MeasureTheory.ae μ)\n⊢ Eq (intervalIntegral (fun x => f x) a b μ) (intervalIntegral (fun x => g x) a b μ)","decl":"theorem integral_congr_ae' (h : ∀ᵐ x ∂μ, x ∈ Ioc a b → f x = g x)\n    (h' : ∀ᵐ x ∂μ, x ∈ Ioc b a → f x = g x) : ∫ x in a..b, f x ∂μ = ∫ x in a..b, g x ∂μ := by\n  simp only [intervalIntegral, setIntegral_congr_ae measurableSet_Ioc h,\n    setIntegral_congr_ae measurableSet_Ioc h']\n\n"}
{"name":"intervalIntegral.integral_congr_ae","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf g : Real → E\nμ : MeasureTheory.Measure Real\nh : Filter.Eventually (fun x => Membership.mem (Set.uIoc a b) x → Eq (f x) (g x)) (MeasureTheory.ae μ)\n⊢ Eq (intervalIntegral (fun x => f x) a b μ) (intervalIntegral (fun x => g x) a b μ)","decl":"theorem integral_congr_ae (h : ∀ᵐ x ∂μ, x ∈ Ι a b → f x = g x) :\n    ∫ x in a..b, f x ∂μ = ∫ x in a..b, g x ∂μ :=\n  integral_congr_ae' (ae_uIoc_iff.mp h).1 (ae_uIoc_iff.mp h).2\n\n"}
{"name":"intervalIntegral.integral_zero_ae","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : Real\nf : Real → E\nμ : MeasureTheory.Measure Real\nh : Filter.Eventually (fun x => Membership.mem (Set.uIoc a b) x → Eq (f x) 0) (MeasureTheory.ae μ)\n⊢ Eq (intervalIntegral (fun x => f x) a b μ) 0","decl":"theorem integral_zero_ae (h : ∀ᵐ x ∂μ, x ∈ Ι a b → f x = 0) : ∫ x in a..b, f x ∂μ = 0 :=\n  calc\n    ∫ x in a..b, f x ∂μ = ∫ _ in a..b, 0 ∂μ := integral_congr_ae h\n    _ = 0 := integral_zero\n\n"}
{"name":"intervalIntegral.integral_indicator","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : Real → E\nμ : MeasureTheory.Measure Real\na₁ a₂ a₃ : Real\nh : Membership.mem (Set.Icc a₁ a₃) a₂\n⊢ Eq (intervalIntegral (fun x => (setOf fun x => LE.le x a₂).indicator f x) a₁ a₃ μ) (intervalIntegral (fun x => f x) a₁ a₂ μ)","decl":"nonrec theorem integral_indicator {a₁ a₂ a₃ : ℝ} (h : a₂ ∈ Icc a₁ a₃) :\n    ∫ x in a₁..a₃, indicator {x | x ≤ a₂} f x ∂μ = ∫ x in a₁..a₂, f x ∂μ := by\n  have : {x | x ≤ a₂} ∩ Ioc a₁ a₃ = Ioc a₁ a₂ := Iic_inter_Ioc_of_le h.2\n  rw [integral_of_le h.1, integral_of_le (h.1.trans h.2), integral_indicator,\n    Measure.restrict_restrict, this]\n  · exact measurableSet_Iic\n  all_goals apply measurableSet_Iic\n\n"}
{"name":"intervalIntegral.integral_eq_zero_iff_of_le_of_nonneg_ae","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f : Real → Real\na b : Real\nμ : MeasureTheory.Measure Real\nhab : LE.le a b\nhf : (MeasureTheory.ae (μ.restrict (Set.Ioc a b))).EventuallyLE 0 f\nhfi : IntervalIntegrable f μ a b\n⊢ Iff (Eq (intervalIntegral (fun x => f x) a b μ) 0) ((MeasureTheory.ae (μ.restrict (Set.Ioc a b))).EventuallyEq f 0)","decl":"theorem integral_eq_zero_iff_of_le_of_nonneg_ae (hab : a ≤ b) (hf : 0 ≤ᵐ[μ.restrict (Ioc a b)] f)\n    (hfi : IntervalIntegrable f μ a b) :\n    ∫ x in a..b, f x ∂μ = 0 ↔ f =ᵐ[μ.restrict (Ioc a b)] 0 := by\n  rw [integral_of_le hab, integral_eq_zero_iff_of_nonneg_ae hf hfi.1]\n\n"}
{"name":"intervalIntegral.integral_eq_zero_iff_of_nonneg_ae","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f : Real → Real\na b : Real\nμ : MeasureTheory.Measure Real\nhf : (MeasureTheory.ae (μ.restrict (Union.union (Set.Ioc a b) (Set.Ioc b a)))).EventuallyLE 0 f\nhfi : IntervalIntegrable f μ a b\n⊢ Iff (Eq (intervalIntegral (fun x => f x) a b μ) 0) ((MeasureTheory.ae (μ.restrict (Union.union (Set.Ioc a b) (Set.Ioc b a)))).EventuallyEq f 0)","decl":"theorem integral_eq_zero_iff_of_nonneg_ae (hf : 0 ≤ᵐ[μ.restrict (Ioc a b ∪ Ioc b a)] f)\n    (hfi : IntervalIntegrable f μ a b) :\n    ∫ x in a..b, f x ∂μ = 0 ↔ f =ᵐ[μ.restrict (Ioc a b ∪ Ioc b a)] 0 := by\n  rcases le_total a b with hab | hab <;>\n    simp only [Ioc_eq_empty hab.not_lt, empty_union, union_empty] at hf ⊢\n  · exact integral_eq_zero_iff_of_le_of_nonneg_ae hab hf hfi\n  · rw [integral_symm, neg_eq_zero, integral_eq_zero_iff_of_le_of_nonneg_ae hab hf hfi.symm]\n\n"}
{"name":"intervalIntegral.integral_pos_iff_support_of_nonneg_ae'","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f : Real → Real\na b : Real\nμ : MeasureTheory.Measure Real\nhf : (MeasureTheory.ae (μ.restrict (Set.uIoc a b))).EventuallyLE 0 f\nhfi : IntervalIntegrable f μ a b\n⊢ Iff (LT.lt 0 (intervalIntegral (fun x => f x) a b μ)) (And (LT.lt a b) (LT.lt 0 (μ (Inter.inter (Function.support f) (Set.Ioc a b)))))","decl":"/-- If `f` is nonnegative and integrable on the unordered interval `Set.uIoc a b`, then its\nintegral over `a..b` is positive if and only if `a < b` and the measure of\n`Function.support f ∩ Set.Ioc a b` is positive. -/\ntheorem integral_pos_iff_support_of_nonneg_ae' (hf : 0 ≤ᵐ[μ.restrict (Ι a b)] f)\n    (hfi : IntervalIntegrable f μ a b) :\n    (0 < ∫ x in a..b, f x ∂μ) ↔ a < b ∧ 0 < μ (support f ∩ Ioc a b) := by\n  cases' lt_or_le a b with hab hba\n  · rw [uIoc_of_le hab.le] at hf\n    simp only [hab, true_and, integral_of_le hab.le,\n      setIntegral_pos_iff_support_of_nonneg_ae hf hfi.1]\n  · suffices (∫ x in a..b, f x ∂μ) ≤ 0 by simp only [this.not_lt, hba.not_lt, false_and]\n    rw [integral_of_ge hba, neg_nonpos]\n    rw [uIoc_comm, uIoc_of_le hba] at hf\n    exact integral_nonneg_of_ae hf\n\n"}
{"name":"intervalIntegral.integral_pos_iff_support_of_nonneg_ae","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f : Real → Real\na b : Real\nμ : MeasureTheory.Measure Real\nhf : (MeasureTheory.ae μ).EventuallyLE 0 f\nhfi : IntervalIntegrable f μ a b\n⊢ Iff (LT.lt 0 (intervalIntegral (fun x => f x) a b μ)) (And (LT.lt a b) (LT.lt 0 (μ (Inter.inter (Function.support f) (Set.Ioc a b)))))","decl":"/-- If `f` is nonnegative a.e.-everywhere and it is integrable on the unordered interval\n`Set.uIoc a b`, then its integral over `a..b` is positive if and only if `a < b` and the\nmeasure of `Function.support f ∩ Set.Ioc a b` is positive. -/\ntheorem integral_pos_iff_support_of_nonneg_ae (hf : 0 ≤ᵐ[μ] f) (hfi : IntervalIntegrable f μ a b) :\n    (0 < ∫ x in a..b, f x ∂μ) ↔ a < b ∧ 0 < μ (support f ∩ Ioc a b) :=\n  integral_pos_iff_support_of_nonneg_ae' (ae_mono Measure.restrict_le_self hf) hfi\n\n"}
{"name":"intervalIntegral.intervalIntegral_pos_of_pos_on","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f : Real → Real\na b : Real\nhfi : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b\nhpos : ∀ (x : Real), Membership.mem (Set.Ioo a b) x → LT.lt 0 (f x)\nhab : LT.lt a b\n⊢ LT.lt 0 (intervalIntegral (fun x => f x) a b MeasureTheory.MeasureSpace.volume)","decl":"/-- If `f : ℝ → ℝ` is integrable on `(a, b]` for real numbers `a < b`, and positive on the interior\nof the interval, then its integral over `a..b` is strictly positive. -/\ntheorem intervalIntegral_pos_of_pos_on {f : ℝ → ℝ} {a b : ℝ} (hfi : IntervalIntegrable f volume a b)\n    (hpos : ∀ x : ℝ, x ∈ Ioo a b → 0 < f x) (hab : a < b) : 0 < ∫ x : ℝ in a..b, f x := by\n  have hsupp : Ioo a b ⊆ support f ∩ Ioc a b := fun x hx =>\n    ⟨mem_support.mpr (hpos x hx).ne', Ioo_subset_Ioc_self hx⟩\n  have h₀ : 0 ≤ᵐ[volume.restrict (uIoc a b)] f := by\n    rw [EventuallyLE, uIoc_of_le hab.le]\n    refine ae_restrict_of_ae_eq_of_ae_restrict Ioo_ae_eq_Ioc ?_\n    rw [ae_restrict_iff' measurableSet_Ioo]\n    filter_upwards with x hx using (hpos x hx).le\n  rw [integral_pos_iff_support_of_nonneg_ae' h₀ hfi]\n  exact ⟨hab, ((Measure.measure_Ioo_pos _).mpr hab).trans_le (measure_mono hsupp)⟩\n\n"}
{"name":"intervalIntegral.intervalIntegral_pos_of_pos","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f : Real → Real\na b : Real\nhfi : IntervalIntegrable f MeasureTheory.MeasureSpace.volume a b\nhpos : ∀ (x : Real), LT.lt 0 (f x)\nhab : LT.lt a b\n⊢ LT.lt 0 (intervalIntegral (fun x => f x) a b MeasureTheory.MeasureSpace.volume)","decl":"/-- If `f : ℝ → ℝ` is strictly positive everywhere, and integrable on `(a, b]` for real numbers\n`a < b`, then its integral over `a..b` is strictly positive. (See `intervalIntegral_pos_of_pos_on`\nfor a version only assuming positivity of `f` on `(a, b)` rather than everywhere.) -/\ntheorem intervalIntegral_pos_of_pos {f : ℝ → ℝ} {a b : ℝ}\n    (hfi : IntervalIntegrable f MeasureSpace.volume a b) (hpos : ∀ x, 0 < f x) (hab : a < b) :\n    0 < ∫ x in a..b, f x :=\n  intervalIntegral_pos_of_pos_on hfi (fun x _ => hpos x) hab\n\n"}
{"name":"intervalIntegral.integral_lt_integral_of_ae_le_of_measure_setOf_lt_ne_zero","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f g : Real → Real\na b : Real\nμ : MeasureTheory.Measure Real\nhab : LE.le a b\nhfi : IntervalIntegrable f μ a b\nhgi : IntervalIntegrable g μ a b\nhle : (MeasureTheory.ae (μ.restrict (Set.Ioc a b))).EventuallyLE f g\nhlt : Ne ((μ.restrict (Set.Ioc a b)) (setOf fun x => LT.lt (f x) (g x))) 0\n⊢ LT.lt (intervalIntegral (fun x => f x) a b μ) (intervalIntegral (fun x => g x) a b μ)","decl":"/-- If `f` and `g` are two functions that are interval integrable on `a..b`, `a ≤ b`,\n`f x ≤ g x` for a.e. `x ∈ Set.Ioc a b`, and `f x < g x` on a subset of `Set.Ioc a b`\nof nonzero measure, then `∫ x in a..b, f x ∂μ < ∫ x in a..b, g x ∂μ`. -/\ntheorem integral_lt_integral_of_ae_le_of_measure_setOf_lt_ne_zero (hab : a ≤ b)\n    (hfi : IntervalIntegrable f μ a b) (hgi : IntervalIntegrable g μ a b)\n    (hle : f ≤ᵐ[μ.restrict (Ioc a b)] g) (hlt : μ.restrict (Ioc a b) {x | f x < g x} ≠ 0) :\n    (∫ x in a..b, f x ∂μ) < ∫ x in a..b, g x ∂μ := by\n  rw [← sub_pos, ← integral_sub hgi hfi, integral_of_le hab,\n    MeasureTheory.integral_pos_iff_support_of_nonneg_ae]\n  · refine pos_iff_ne_zero.2 (mt (measure_mono_null ?_) hlt)\n    exact fun x hx => (sub_pos.2 hx.out).ne'\n  exacts [hle.mono fun x => sub_nonneg.2, hgi.1.sub hfi.1]\n\n"}
{"name":"intervalIntegral.integral_lt_integral_of_continuousOn_of_le_of_exists_lt","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f g : Real → Real\na b : Real\nhab : LT.lt a b\nhfc : ContinuousOn f (Set.Icc a b)\nhgc : ContinuousOn g (Set.Icc a b)\nhle : ∀ (x : Real), Membership.mem (Set.Ioc a b) x → LE.le (f x) (g x)\nhlt : Exists fun c => And (Membership.mem (Set.Icc a b) c) (LT.lt (f c) (g c))\n⊢ LT.lt (intervalIntegral (fun x => f x) a b MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => g x) a b MeasureTheory.MeasureSpace.volume)","decl":"/-- If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x ≤ g x` on this interval, and\n`f c < g c` at some point `c ∈ [a, b]`, then `∫ x in a..b, f x < ∫ x in a..b, g x`. -/\ntheorem integral_lt_integral_of_continuousOn_of_le_of_exists_lt {f g : ℝ → ℝ} {a b : ℝ}\n    (hab : a < b) (hfc : ContinuousOn f (Icc a b)) (hgc : ContinuousOn g (Icc a b))\n    (hle : ∀ x ∈ Ioc a b, f x ≤ g x) (hlt : ∃ c ∈ Icc a b, f c < g c) :\n    (∫ x in a..b, f x) < ∫ x in a..b, g x := by\n  apply integral_lt_integral_of_ae_le_of_measure_setOf_lt_ne_zero hab.le\n    (hfc.intervalIntegrable_of_Icc hab.le) (hgc.intervalIntegrable_of_Icc hab.le)\n  · simpa only [measurableSet_Ioc, ae_restrict_eq]\n      using (ae_restrict_mem measurableSet_Ioc).mono hle\n  contrapose! hlt\n  have h_eq : f =ᵐ[volume.restrict (Ioc a b)] g := by\n    simp only [← not_le, ← ae_iff] at hlt\n    exact EventuallyLE.antisymm ((ae_restrict_iff' measurableSet_Ioc).2 <|\n      Eventually.of_forall hle) hlt\n  rw [Measure.restrict_congr_set Ioc_ae_eq_Icc] at h_eq\n  exact fun c hc ↦ (Measure.eqOn_Icc_of_ae_eq volume hab.ne h_eq hfc hgc hc).ge\n\n"}
{"name":"intervalIntegral.integral_nonneg_of_ae_restrict","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f : Real → Real\na b : Real\nμ : MeasureTheory.Measure Real\nhab : LE.le a b\nhf : (MeasureTheory.ae (μ.restrict (Set.Icc a b))).EventuallyLE 0 f\n⊢ LE.le 0 (intervalIntegral (fun u => f u) a b μ)","decl":"theorem integral_nonneg_of_ae_restrict (hab : a ≤ b) (hf : 0 ≤ᵐ[μ.restrict (Icc a b)] f) :\n    0 ≤ ∫ u in a..b, f u ∂μ := by\n  let H := ae_restrict_of_ae_restrict_of_subset Ioc_subset_Icc_self hf\n  simpa only [integral_of_le hab] using setIntegral_nonneg_of_ae_restrict H\n\n"}
{"name":"intervalIntegral.integral_nonneg_of_ae","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f : Real → Real\na b : Real\nμ : MeasureTheory.Measure Real\nhab : LE.le a b\nhf : (MeasureTheory.ae μ).EventuallyLE 0 f\n⊢ LE.le 0 (intervalIntegral (fun u => f u) a b μ)","decl":"theorem integral_nonneg_of_ae (hab : a ≤ b) (hf : 0 ≤ᵐ[μ] f) : 0 ≤ ∫ u in a..b, f u ∂μ :=\n  integral_nonneg_of_ae_restrict hab <| ae_restrict_of_ae hf\n\n"}
{"name":"intervalIntegral.integral_nonneg_of_forall","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f : Real → Real\na b : Real\nμ : MeasureTheory.Measure Real\nhab : LE.le a b\nhf : ∀ (u : Real), LE.le 0 (f u)\n⊢ LE.le 0 (intervalIntegral (fun u => f u) a b μ)","decl":"theorem integral_nonneg_of_forall (hab : a ≤ b) (hf : ∀ u, 0 ≤ f u) : 0 ≤ ∫ u in a..b, f u ∂μ :=\n  integral_nonneg_of_ae hab <| Eventually.of_forall hf\n\n"}
{"name":"intervalIntegral.integral_nonneg","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f : Real → Real\na b : Real\nμ : MeasureTheory.Measure Real\nhab : LE.le a b\nhf : ∀ (u : Real), Membership.mem (Set.Icc a b) u → LE.le 0 (f u)\n⊢ LE.le 0 (intervalIntegral (fun u => f u) a b μ)","decl":"theorem integral_nonneg (hab : a ≤ b) (hf : ∀ u, u ∈ Icc a b → 0 ≤ f u) : 0 ≤ ∫ u in a..b, f u ∂μ :=\n  integral_nonneg_of_ae_restrict hab <| (ae_restrict_iff' measurableSet_Icc).mpr <| ae_of_all μ hf\n\n"}
{"name":"intervalIntegral.abs_integral_le_integral_abs","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f : Real → Real\na b : Real\nμ : MeasureTheory.Measure Real\nhab : LE.le a b\n⊢ LE.le (abs (intervalIntegral (fun x => f x) a b μ)) (intervalIntegral (fun x => abs (f x)) a b μ)","decl":"theorem abs_integral_le_integral_abs (hab : a ≤ b) :\n    |∫ x in a..b, f x ∂μ| ≤ ∫ x in a..b, |f x| ∂μ := by\n  simpa only [← Real.norm_eq_abs] using norm_integral_le_integral_norm hab\n\n"}
{"name":"intervalIntegral.integral_pos","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f : Real → Real\na b : Real\nhab : LT.lt a b\nhfc : ContinuousOn f (Set.Icc a b)\nhle : ∀ (x : Real), Membership.mem (Set.Ioc a b) x → LE.le 0 (f x)\nhlt : Exists fun c => And (Membership.mem (Set.Icc a b) c) (LT.lt 0 (f c))\n⊢ LT.lt 0 (intervalIntegral (fun x => f x) a b MeasureTheory.MeasureSpace.volume)","decl":"lemma integral_pos (hab : a < b)\n    (hfc : ContinuousOn f (Icc a b)) (hle : ∀ x ∈ Ioc a b, 0 ≤ f x) (hlt : ∃ c ∈ Icc a b, 0 < f c) :\n    0 < ∫ x in a..b, f x :=\n  (integral_lt_integral_of_continuousOn_of_le_of_exists_lt hab\n    continuousOn_const hfc hle hlt).trans_eq' (by simp)\n\n"}
{"name":"intervalIntegral.integral_mono_interval","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f : Real → Real\na b : Real\nμ : MeasureTheory.Measure Real\nc d : Real\nhca : LE.le c a\nhab : LE.le a b\nhbd : LE.le b d\nhf : (MeasureTheory.ae (μ.restrict (Set.Ioc c d))).EventuallyLE 0 f\nhfi : IntervalIntegrable f μ c d\n⊢ LE.le (intervalIntegral (fun x => f x) a b μ) (intervalIntegral (fun x => f x) c d μ)","decl":"theorem integral_mono_interval {c d} (hca : c ≤ a) (hab : a ≤ b) (hbd : b ≤ d)\n    (hf : 0 ≤ᵐ[μ.restrict (Ioc c d)] f) (hfi : IntervalIntegrable f μ c d) :\n    (∫ x in a..b, f x ∂μ) ≤ ∫ x in c..d, f x ∂μ := by\n  rw [integral_of_le hab, integral_of_le (hca.trans (hab.trans hbd))]\n  exact setIntegral_mono_set hfi.1 hf (Ioc_subset_Ioc hca hbd).eventuallyLE\n\n"}
{"name":"intervalIntegral.abs_integral_mono_interval","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f : Real → Real\na b : Real\nμ : MeasureTheory.Measure Real\nc d : Real\nh : HasSubset.Subset (Set.uIoc a b) (Set.uIoc c d)\nhf : (MeasureTheory.ae (μ.restrict (Set.uIoc c d))).EventuallyLE 0 f\nhfi : IntervalIntegrable f μ c d\n⊢ LE.le (abs (intervalIntegral (fun x => f x) a b μ)) (abs (intervalIntegral (fun x => f x) c d μ))","decl":"theorem abs_integral_mono_interval {c d} (h : Ι a b ⊆ Ι c d) (hf : 0 ≤ᵐ[μ.restrict (Ι c d)] f)\n    (hfi : IntervalIntegrable f μ c d) : |∫ x in a..b, f x ∂μ| ≤ |∫ x in c..d, f x ∂μ| :=\n  have hf' : 0 ≤ᵐ[μ.restrict (Ι a b)] f := ae_mono (Measure.restrict_mono h le_rfl) hf\n  calc\n    |∫ x in a..b, f x ∂μ| = |∫ x in Ι a b, f x ∂μ| := abs_integral_eq_abs_integral_uIoc f\n    _ = ∫ x in Ι a b, f x ∂μ := abs_of_nonneg (MeasureTheory.integral_nonneg_of_ae hf')\n    _ ≤ ∫ x in Ι c d, f x ∂μ := setIntegral_mono_set hfi.def' hf h.eventuallyLE\n    _ ≤ |∫ x in Ι c d, f x ∂μ| := le_abs_self _\n    _ = |∫ x in c..d, f x ∂μ| := (abs_integral_eq_abs_integral_uIoc f).symm\n\n"}
{"name":"intervalIntegral.integral_mono_ae_restrict","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f g : Real → Real\na b : Real\nμ : MeasureTheory.Measure Real\nhab : LE.le a b\nhf : IntervalIntegrable f μ a b\nhg : IntervalIntegrable g μ a b\nh : (MeasureTheory.ae (μ.restrict (Set.Icc a b))).EventuallyLE f g\n⊢ LE.le (intervalIntegral (fun u => f u) a b μ) (intervalIntegral (fun u => g u) a b μ)","decl":"theorem integral_mono_ae_restrict (h : f ≤ᵐ[μ.restrict (Icc a b)] g) :\n    (∫ u in a..b, f u ∂μ) ≤ ∫ u in a..b, g u ∂μ := by\n  let H := h.filter_mono <| ae_mono <| Measure.restrict_mono Ioc_subset_Icc_self <| le_refl μ\n  simpa only [integral_of_le hab] using setIntegral_mono_ae_restrict hf.1 hg.1 H\n\n"}
{"name":"intervalIntegral.integral_mono_ae","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f g : Real → Real\na b : Real\nμ : MeasureTheory.Measure Real\nhab : LE.le a b\nhf : IntervalIntegrable f μ a b\nhg : IntervalIntegrable g μ a b\nh : (MeasureTheory.ae μ).EventuallyLE f g\n⊢ LE.le (intervalIntegral (fun u => f u) a b μ) (intervalIntegral (fun u => g u) a b μ)","decl":"theorem integral_mono_ae (h : f ≤ᵐ[μ] g) : (∫ u in a..b, f u ∂μ) ≤ ∫ u in a..b, g u ∂μ := by\n  simpa only [integral_of_le hab] using setIntegral_mono_ae hf.1 hg.1 h\n\n"}
{"name":"intervalIntegral.integral_mono_on","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f g : Real → Real\na b : Real\nμ : MeasureTheory.Measure Real\nhab : LE.le a b\nhf : IntervalIntegrable f μ a b\nhg : IntervalIntegrable g μ a b\nh : ∀ (x : Real), Membership.mem (Set.Icc a b) x → LE.le (f x) (g x)\n⊢ LE.le (intervalIntegral (fun u => f u) a b μ) (intervalIntegral (fun u => g u) a b μ)","decl":"theorem integral_mono_on (h : ∀ x ∈ Icc a b, f x ≤ g x) :\n    (∫ u in a..b, f u ∂μ) ≤ ∫ u in a..b, g u ∂μ := by\n  let H x hx := h x <| Ioc_subset_Icc_self hx\n  simpa only [integral_of_le hab] using setIntegral_mono_on hf.1 hg.1 measurableSet_Ioc H\n\n"}
{"name":"intervalIntegral.integral_mono_on_of_le_Ioo","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f g : Real → Real\na b : Real\nμ : MeasureTheory.Measure Real\nhab : LE.le a b\nhf : IntervalIntegrable f μ a b\nhg : IntervalIntegrable g μ a b\ninst✝ : MeasureTheory.NoAtoms μ\nh : ∀ (x : Real), Membership.mem (Set.Ioo a b) x → LE.le (f x) (g x)\n⊢ LE.le (intervalIntegral (fun u => f u) a b μ) (intervalIntegral (fun u => g u) a b μ)","decl":"theorem integral_mono_on_of_le_Ioo [NoAtoms μ] (h : ∀ x ∈ Ioo a b, f x ≤ g x) :\n    (∫ u in a..b, f u ∂μ) ≤ ∫ u in a..b, g u ∂μ := by\n  simp only [integral_of_le hab, integral_Ioc_eq_integral_Ioo]\n  apply setIntegral_mono_on\n  · apply hf.1.mono Ioo_subset_Ioc_self le_rfl\n  · apply hg.1.mono Ioo_subset_Ioc_self le_rfl\n  · exact measurableSet_Ioo\n  · exact h\n\n"}
{"name":"intervalIntegral.integral_mono","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"f g : Real → Real\na b : Real\nμ : MeasureTheory.Measure Real\nhab : LE.le a b\nhf : IntervalIntegrable f μ a b\nhg : IntervalIntegrable g μ a b\nh : LE.le f g\n⊢ LE.le (intervalIntegral (fun u => f u) a b μ) (intervalIntegral (fun u => g u) a b μ)","decl":"theorem integral_mono (h : f ≤ g) : (∫ u in a..b, f u ∂μ) ≤ ∫ u in a..b, g u ∂μ :=\n  integral_mono_ae hab hf hg <| ae_of_all _ h\n\n"}
{"name":"MeasureTheory.Integrable.hasSum_intervalIntegral","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nμ : MeasureTheory.Measure Real\nf : Real → E\nhfi : MeasureTheory.Integrable f μ\ny : Real\n⊢ HasSum (fun n => intervalIntegral (fun x => f x) (HAdd.hAdd y ↑n) (HAdd.hAdd (HAdd.hAdd y ↑n) 1) μ) (MeasureTheory.integral μ fun x => f x)","decl":"theorem _root_.MeasureTheory.Integrable.hasSum_intervalIntegral (hfi : Integrable f μ) (y : ℝ) :\n    HasSum (fun n : ℤ => ∫ x in y + n..y + n + 1, f x ∂μ) (∫ x, f x ∂μ) := by\n  simp_rw [integral_of_le (le_add_of_nonneg_right zero_le_one)]\n  rw [← setIntegral_univ, ← iUnion_Ioc_add_intCast y]\n  exact\n    hasSum_integral_iUnion (fun i => measurableSet_Ioc) (pairwise_disjoint_Ioc_add_intCast y)\n      hfi.integrableOn\n\n"}
{"name":"MeasureTheory.Integrable.hasSum_intervalIntegral_comp_add_int","module":"Mathlib.MeasureTheory.Integral.IntervalIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : Real → E\nhfi : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\n⊢ HasSum (fun n => intervalIntegral (fun x => f (HAdd.hAdd x ↑n)) 0 1 MeasureTheory.MeasureSpace.volume) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => f x)","decl":"theorem _root_.MeasureTheory.Integrable.hasSum_intervalIntegral_comp_add_int (hfi : Integrable f) :\n    HasSum (fun n : ℤ => ∫ x in (0 : ℝ)..(1 : ℝ), f (x + n)) (∫ x, f x) := by\n  simpa only [integral_comp_add_right, zero_add, add_comm (1 : ℝ)] using\n    hfi.hasSum_intervalIntegral 0\n\n"}
