{"name":"RatFunc.intDegree_zero","module":"Mathlib.FieldTheory.RatFunc.Degree","initialProofState":"K : Type u\ninst✝ : Field K\n⊢ Eq (RatFunc.intDegree 0) 0","decl":"@[simp]\ntheorem intDegree_zero : intDegree (0 : RatFunc K) = 0 := by\n  rw [intDegree, num_zero, natDegree_zero, denom_zero, natDegree_one, sub_self]\n\n"}
{"name":"RatFunc.intDegree_one","module":"Mathlib.FieldTheory.RatFunc.Degree","initialProofState":"K : Type u\ninst✝ : Field K\n⊢ Eq (RatFunc.intDegree 1) 0","decl":"@[simp]\ntheorem intDegree_one : intDegree (1 : RatFunc K) = 0 := by\n  rw [intDegree, num_one, denom_one, sub_self]\n\n"}
{"name":"RatFunc.intDegree_C","module":"Mathlib.FieldTheory.RatFunc.Degree","initialProofState":"K : Type u\ninst✝ : Field K\nk : K\n⊢ Eq (RatFunc.C k).intDegree 0","decl":"@[simp]\ntheorem intDegree_C (k : K) : intDegree (C k) = 0 := by\n  rw [intDegree, num_C, natDegree_C, denom_C, natDegree_one, sub_self]\n\n"}
{"name":"RatFunc.intDegree_X","module":"Mathlib.FieldTheory.RatFunc.Degree","initialProofState":"K : Type u\ninst✝ : Field K\n⊢ Eq RatFunc.X.intDegree 1","decl":"@[simp]\ntheorem intDegree_X : intDegree (X : RatFunc K) = 1 := by\n  rw [intDegree, num_X, Polynomial.natDegree_X, denom_X, Polynomial.natDegree_one,\n    Int.ofNat_one, Int.ofNat_zero, sub_zero]\n\n"}
{"name":"RatFunc.intDegree_polynomial","module":"Mathlib.FieldTheory.RatFunc.Degree","initialProofState":"K : Type u\ninst✝ : Field K\np : Polynomial K\n⊢ Eq ((algebraMap (Polynomial K) (RatFunc K)) p).intDegree ↑p.natDegree","decl":"@[simp]\ntheorem intDegree_polynomial {p : K[X]} :\n    intDegree (algebraMap K[X] (RatFunc K) p) = natDegree p := by\n  rw [intDegree, RatFunc.num_algebraMap, RatFunc.denom_algebraMap, Polynomial.natDegree_one,\n    Int.ofNat_zero, sub_zero]\n\n"}
{"name":"RatFunc.intDegree_mul","module":"Mathlib.FieldTheory.RatFunc.Degree","initialProofState":"K : Type u\ninst✝ : Field K\nx y : RatFunc K\nhx : Ne x 0\nhy : Ne y 0\n⊢ Eq (HMul.hMul x y).intDegree (HAdd.hAdd x.intDegree y.intDegree)","decl":"theorem intDegree_mul {x y : RatFunc K} (hx : x ≠ 0) (hy : y ≠ 0) :\n    intDegree (x * y) = intDegree x + intDegree y := by\n  simp only [intDegree, add_sub, sub_add, sub_sub_eq_add_sub, sub_sub, sub_eq_sub_iff_add_eq_add]\n  norm_cast\n  rw [← Polynomial.natDegree_mul x.denom_ne_zero y.denom_ne_zero, ←\n    Polynomial.natDegree_mul (RatFunc.num_ne_zero (mul_ne_zero hx hy))\n      (mul_ne_zero x.denom_ne_zero y.denom_ne_zero),\n    ← Polynomial.natDegree_mul (RatFunc.num_ne_zero hx) (RatFunc.num_ne_zero hy), ←\n    Polynomial.natDegree_mul (mul_ne_zero (RatFunc.num_ne_zero hx) (RatFunc.num_ne_zero hy))\n      (x * y).denom_ne_zero,\n    RatFunc.num_denom_mul]\n\n"}
{"name":"RatFunc.intDegree_neg","module":"Mathlib.FieldTheory.RatFunc.Degree","initialProofState":"K : Type u\ninst✝ : Field K\nx : RatFunc K\n⊢ Eq (Neg.neg x).intDegree x.intDegree","decl":"@[simp]\ntheorem intDegree_neg (x : RatFunc K) : intDegree (-x) = intDegree x := by\n  by_cases hx : x = 0\n  · rw [hx, neg_zero]\n  · rw [intDegree, intDegree, ← natDegree_neg x.num]\n    exact\n      natDegree_sub_eq_of_prod_eq (num_ne_zero (neg_ne_zero.mpr hx)) (denom_ne_zero (-x))\n        (neg_ne_zero.mpr (num_ne_zero hx)) (denom_ne_zero x) (num_denom_neg x)\n\n"}
{"name":"RatFunc.intDegree_add","module":"Mathlib.FieldTheory.RatFunc.Degree","initialProofState":"K : Type u\ninst✝ : Field K\nx y : RatFunc K\nhxy : Ne (HAdd.hAdd x y) 0\n⊢ Eq (HAdd.hAdd x y).intDegree (HSub.hSub ↑(HAdd.hAdd (HMul.hMul x.num y.denom) (HMul.hMul x.denom y.num)).natDegree ↑(HMul.hMul x.denom y.denom).natDegree)","decl":"theorem intDegree_add {x y : RatFunc K} (hxy : x + y ≠ 0) :\n    (x + y).intDegree =\n      (x.num * y.denom + x.denom * y.num).natDegree - (x.denom * y.denom).natDegree :=\n  natDegree_sub_eq_of_prod_eq (num_ne_zero hxy) (x + y).denom_ne_zero\n    (num_mul_denom_add_denom_mul_num_ne_zero hxy) (mul_ne_zero x.denom_ne_zero y.denom_ne_zero)\n    (num_denom_add x y)\n\n"}
{"name":"RatFunc.natDegree_num_mul_right_sub_natDegree_denom_mul_left_eq_intDegree","module":"Mathlib.FieldTheory.RatFunc.Degree","initialProofState":"K : Type u\ninst✝ : Field K\nx : RatFunc K\nhx : Ne x 0\ns : Polynomial K\nhs : Ne s 0\n⊢ Eq (HSub.hSub ↑(HMul.hMul x.num s).natDegree ↑(HMul.hMul s x.denom).natDegree) x.intDegree","decl":"theorem natDegree_num_mul_right_sub_natDegree_denom_mul_left_eq_intDegree {x : RatFunc K}\n    (hx : x ≠ 0) {s : K[X]} (hs : s ≠ 0) :\n    ((x.num * s).natDegree : ℤ) - (s * x.denom).natDegree = x.intDegree := by\n  apply natDegree_sub_eq_of_prod_eq (mul_ne_zero (num_ne_zero hx) hs)\n    (mul_ne_zero hs x.denom_ne_zero) (num_ne_zero hx) x.denom_ne_zero\n  rw [mul_assoc]\n\n"}
{"name":"RatFunc.intDegree_add_le","module":"Mathlib.FieldTheory.RatFunc.Degree","initialProofState":"K : Type u\ninst✝ : Field K\nx y : RatFunc K\nhy : Ne y 0\nhxy : Ne (HAdd.hAdd x y) 0\n⊢ LE.le (HAdd.hAdd x y).intDegree (Max.max x.intDegree y.intDegree)","decl":"theorem intDegree_add_le {x y : RatFunc K} (hy : y ≠ 0) (hxy : x + y ≠ 0) :\n    intDegree (x + y) ≤ max (intDegree x) (intDegree y) := by\n  by_cases hx : x = 0\n  · simp only [hx, zero_add, ne_eq] at hxy\n    simp [hx, hxy]\n  rw [intDegree_add hxy, ←\n    natDegree_num_mul_right_sub_natDegree_denom_mul_left_eq_intDegree hx y.denom_ne_zero,\n    mul_comm y.denom, ←\n    natDegree_num_mul_right_sub_natDegree_denom_mul_left_eq_intDegree hy x.denom_ne_zero,\n    le_max_iff, sub_le_sub_iff_right, Int.ofNat_le, sub_le_sub_iff_right, Int.ofNat_le, ←\n    le_max_iff, mul_comm y.num]\n  exact natDegree_add_le _ _\n\n"}
