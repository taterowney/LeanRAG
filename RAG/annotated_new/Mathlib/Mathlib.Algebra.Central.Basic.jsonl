{"name":"Algebra.IsCentral.center_eq_bot","module":"Mathlib.Algebra.Central.Basic","initialProofState":"K : Type u\ninst✝² : CommSemiring K\nD : Type v\ninst✝¹ : Semiring D\ninst✝ : Algebra K D\nh : Algebra.IsCentral K D\n⊢ Eq (Subalgebra.center K D) Bot.bot","decl":"@[simp]\nlemma center_eq_bot : Subalgebra.center K D = ⊥ := eq_bot_iff.2 IsCentral.out\n\n"}
{"name":"Algebra.IsCentral.mem_center_iff","module":"Mathlib.Algebra.Central.Basic","initialProofState":"K : Type u\ninst✝² : CommSemiring K\nD : Type v\ninst✝¹ : Semiring D\ninst✝ : Algebra K D\nh : Algebra.IsCentral K D\nx : D\n⊢ Iff (Membership.mem (Subalgebra.center K D) x) (Exists fun a => Eq x ((algebraMap K D) a))","decl":"variable {D} in\nlemma mem_center_iff {x : D} : x ∈ Subalgebra.center K D ↔ ∃ (a : K), x = algebraMap K D a := by\n  rw [center_eq_bot, Algebra.mem_bot]\n  simp [eq_comm]\n\n"}
{"name":"Algebra.IsCentral.self","module":"Mathlib.Algebra.Central.Basic","initialProofState":"K : Type u\ninst✝ : CommSemiring K\n⊢ Algebra.IsCentral K K","decl":"instance self : IsCentral K K where\n  out x := by simp [Algebra.mem_bot]\n\n"}
{"name":"Algebra.IsCentral.baseField_essentially_unique","module":"Mathlib.Algebra.Central.Basic","initialProofState":"k : Type u_1\nK : Type u_2\nD : Type u_3\ninst✝⁸ : Field k\ninst✝⁷ : Field K\ninst✝⁶ : Ring D\ninst✝⁵ : Nontrivial D\ninst✝⁴ : Algebra k K\ninst✝³ : Algebra K D\ninst✝² : Algebra k D\ninst✝¹ : IsScalarTower k K D\ninst✝ : Algebra.IsCentral k D\n⊢ Function.Bijective ⇑(algebraMap k K)","decl":"lemma baseField_essentially_unique\n    (k K D : Type*) [Field k] [Field K] [Ring D] [Nontrivial D]\n    [Algebra k K] [Algebra K D] [Algebra k D] [IsScalarTower k K D]\n    [IsCentral k D] :\n    Function.Bijective (algebraMap k K) := by\n  haveI : IsCentral K D :=\n  { out := fun x ↦ show x ∈ Subalgebra.center k D → _ by\n      simp only [center_eq_bot, mem_bot, Set.mem_range, forall_exists_index]\n      rintro x rfl\n      exact  ⟨algebraMap k K x, by simp [algebraMap_eq_smul_one, smul_assoc]⟩ }\n  refine ⟨NoZeroSMulDivisors.algebraMap_injective k K, fun x => ?_⟩\n  have H : algebraMap K D x ∈ (Subalgebra.center K D : Set D) := Subalgebra.algebraMap_mem _ _\n  rw [show (Subalgebra.center K D : Set D) = Subalgebra.center k D by rfl] at H\n  simp only [center_eq_bot, coe_bot, Set.mem_range] at H\n  obtain ⟨x', H⟩ := H\n  exact ⟨x', (algebraMap K D).injective <| by simp [← H, algebraMap_eq_smul_one]⟩\n\n"}
{"name":"Algebra.IsCentral.of_algEquiv","module":"Mathlib.Algebra.Central.Basic","initialProofState":"K : Type u\ninst✝⁴ : CommSemiring K\nD D' : Type v\ninst✝³ : Semiring D\ninst✝² : Algebra K D\nh : Algebra.IsCentral K D\ninst✝¹ : Semiring D'\ninst✝ : Algebra K D'\ne : AlgEquiv K D D'\n⊢ Algebra.IsCentral K D'","decl":"lemma of_algEquiv (e : D ≃ₐ[K] D') : IsCentral K D' where\n  out x hx :=\n    have ⟨k, hk⟩ := h.1 ((MulEquivClass.apply_mem_center_iff e.symm).mpr hx)\n    ⟨k, by simpa [ofId] using congr(e $hk)⟩\n\n"}
{"name":"Algebra.IsCentral.instMulOpposite","module":"Mathlib.Algebra.Central.Basic","initialProofState":"K : Type u\ninst✝² : CommSemiring K\nD : Type v\ninst✝¹ : Semiring D\ninst✝ : Algebra K D\nh : Algebra.IsCentral K D\n⊢ Algebra.IsCentral K (MulOpposite D)","decl":"open MulOpposite in\n/-- Opposite algebra of a central algebra is central. This instance combined with the coming\n  `IsSimpleRing` instance for the opposite of central simple algebra will be an\n  inverse for an element in `BrauerGroup`, find out more about this in\n  `Mathlib.Algebra.BrauerGroup.Basic`. -/\ninstance : IsCentral K Dᵐᵒᵖ where\n  out z hz :=\n    have ⟨k, hk⟩ := h.1 (MulOpposite.unop_mem_center_iff.mpr hz)\n    ⟨k, by simpa using congr(op $hk)⟩\n\n"}
