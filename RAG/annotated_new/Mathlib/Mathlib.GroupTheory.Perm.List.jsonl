{"name":"List.formPerm_nil","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n⊢ Eq List.nil.formPerm 1","decl":"@[simp]\ntheorem formPerm_nil : formPerm ([] : List α) = 1 :=\n  rfl\n\n"}
{"name":"List.formPerm_singleton","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx : α\n⊢ Eq (List.cons x List.nil).formPerm 1","decl":"@[simp]\ntheorem formPerm_singleton (x : α) : formPerm [x] = 1 :=\n  rfl\n\n"}
{"name":"List.formPerm_cons_cons","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx y : α\nl : List α\n⊢ Eq (List.cons x (List.cons y l)).formPerm (HMul.hMul (Equiv.swap x y) (List.cons y l).formPerm)","decl":"@[simp]\ntheorem formPerm_cons_cons (x y : α) (l : List α) :\n    formPerm (x :: y :: l) = swap x y * formPerm (y :: l) :=\n  prod_cons\n\n"}
{"name":"List.formPerm_pair","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx y : α\n⊢ Eq (List.cons x (List.cons y List.nil)).formPerm (Equiv.swap x y)","decl":"theorem formPerm_pair (x y : α) : formPerm [x, y] = swap x y :=\n  rfl\n\n"}
{"name":"List.mem_or_mem_of_zipWith_swap_prod_ne","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl l' : List α\nx : α\na✝ : Ne ((List.zipWith Equiv.swap l l').prod x) x\n⊢ Or (Membership.mem l x) (Membership.mem l' x)","decl":"theorem mem_or_mem_of_zipWith_swap_prod_ne : ∀ {l l' : List α} {x : α},\n    (zipWith swap l l').prod x ≠ x → x ∈ l ∨ x ∈ l'\n  | [], _, _ => by simp\n  | _, [], _ => by simp\n  | a::l, b::l', x => fun hx ↦\n    if h : (zipWith swap l l').prod x = x then\n      (eq_or_eq_of_swap_apply_ne_self (a := a) (b := b) (x := x) (by simpa [h] using hx)).imp\n        (by rintro rfl; exact .head _) (by rintro rfl; exact .head _)\n    else\n     (mem_or_mem_of_zipWith_swap_prod_ne h).imp (.tail _) (.tail _)\n\n"}
{"name":"List.zipWith_swap_prod_support'","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl l' : List α\n⊢ LE.le (setOf fun x => Ne ((List.zipWith Equiv.swap l l').prod x) x) ↑(Max.max l.toFinset l'.toFinset)","decl":"theorem zipWith_swap_prod_support' (l l' : List α) :\n    { x | (zipWith swap l l').prod x ≠ x } ≤ l.toFinset ⊔ l'.toFinset := fun _ h ↦ by\n  simpa using mem_or_mem_of_zipWith_swap_prod_ne h\n\n"}
{"name":"List.zipWith_swap_prod_support","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nl l' : List α\n⊢ LE.le (List.zipWith Equiv.swap l l').prod.support (Max.max l.toFinset l'.toFinset)","decl":"theorem zipWith_swap_prod_support [Fintype α] (l l' : List α) :\n    (zipWith swap l l').prod.support ≤ l.toFinset ⊔ l'.toFinset := by\n  intro x hx\n  have hx' : x ∈ { x | (zipWith swap l l').prod x ≠ x } := by simpa using hx\n  simpa using zipWith_swap_prod_support' _ _ hx'\n\n"}
{"name":"List.support_formPerm_le'","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\n⊢ LE.le (setOf fun x => Ne (l.formPerm x) x) ↑l.toFinset","decl":"theorem support_formPerm_le' : { x | formPerm l x ≠ x } ≤ l.toFinset := by\n  refine (zipWith_swap_prod_support' l l.tail).trans ?_\n  simpa [Finset.subset_iff] using tail_subset l\n\n"}
{"name":"List.support_formPerm_le","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\nl : List α\ninst✝ : Fintype α\n⊢ LE.le l.formPerm.support l.toFinset","decl":"theorem support_formPerm_le [Fintype α] : support (formPerm l) ≤ l.toFinset := by\n  intro x hx\n  have hx' : x ∈ { x | formPerm l x ≠ x } := by simpa using hx\n  simpa using support_formPerm_le' _ hx'\n\n"}
{"name":"List.mem_of_formPerm_apply_ne","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nx : α\nh : Ne (l.formPerm x) x\n⊢ Membership.mem l x","decl":"theorem mem_of_formPerm_apply_ne (h : l.formPerm x ≠ x) : x ∈ l := by\n  simpa [or_iff_left_of_imp mem_of_mem_tail] using mem_or_mem_of_zipWith_swap_prod_ne h\n\n"}
{"name":"List.formPerm_apply_of_not_mem","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nx : α\nh : Not (Membership.mem l x)\n⊢ Eq (l.formPerm x) x","decl":"theorem formPerm_apply_of_not_mem (h : x ∉ l) : formPerm l x = x :=\n  not_imp_comm.1 mem_of_formPerm_apply_ne h\n\n"}
{"name":"List.formPerm_apply_mem_of_mem","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nx : α\nh : Membership.mem l x\n⊢ Membership.mem l (l.formPerm x)","decl":"theorem formPerm_apply_mem_of_mem (h : x ∈ l) : formPerm l x ∈ l := by\n  cases' l with y l\n  · simp at h\n  induction' l with z l IH generalizing x y\n  · simpa using h\n  · by_cases hx : x ∈ z :: l\n    · rw [formPerm_cons_cons, mul_apply, swap_apply_def]\n      split_ifs\n      · simp [IH _ hx]\n      · simp\n      · simp [*]\n    · replace h : x = y := Or.resolve_right (mem_cons.1 h) hx\n      simp [formPerm_apply_of_not_mem hx, ← h]\n\n"}
{"name":"List.mem_of_formPerm_apply_mem","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nx : α\nh : Membership.mem l (l.formPerm x)\n⊢ Membership.mem l x","decl":"theorem mem_of_formPerm_apply_mem (h : l.formPerm x ∈ l) : x ∈ l := by\n  contrapose h\n  rwa [formPerm_apply_of_not_mem h]\n\n"}
{"name":"List.formPerm_mem_iff_mem","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nx : α\n⊢ Iff (Membership.mem l (l.formPerm x)) (Membership.mem l x)","decl":"@[simp]\ntheorem formPerm_mem_iff_mem : l.formPerm x ∈ l ↔ x ∈ l :=\n  ⟨l.mem_of_formPerm_apply_mem, l.formPerm_apply_mem_of_mem⟩\n\n"}
{"name":"List.formPerm_cons_concat_apply_last","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx y : α\nxs : List α\n⊢ Eq ((List.cons x (HAppend.hAppend xs (List.cons y List.nil))).formPerm y) x","decl":"@[simp]\ntheorem formPerm_cons_concat_apply_last (x y : α) (xs : List α) :\n    formPerm (x :: (xs ++ [y])) y = x := by\n  induction' xs with z xs IH generalizing x y\n  · simp\n  · simp [IH]\n\n"}
{"name":"List.formPerm_apply_getLast","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx : α\nxs : List α\n⊢ Eq ((List.cons x xs).formPerm ((List.cons x xs).getLast ⋯)) x","decl":"@[simp]\ntheorem formPerm_apply_getLast (x : α) (xs : List α) :\n    formPerm (x :: xs) ((x :: xs).getLast (cons_ne_nil x xs)) = x := by\n  induction' xs using List.reverseRecOn with xs y _ generalizing x <;> simp\n\n"}
{"name":"List.formPerm_apply_getElem_length","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx : α\nxs : List α\n⊢ Eq ((List.cons x xs).formPerm (GetElem.getElem (List.cons x xs) xs.length ⋯)) x","decl":"@[simp]\ntheorem formPerm_apply_getElem_length (x : α) (xs : List α) :\n    formPerm (x :: xs) (x :: xs)[xs.length] = x := by\n  rw [getElem_cons_length _ _ _ rfl, formPerm_apply_getLast]\n\n"}
{"name":"List.formPerm_apply_get_length","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx : α\nxs : List α\n⊢ Eq ((List.cons x xs).formPerm ((List.cons x xs).get ⟨xs.length, ⋯⟩)) x","decl":"@[deprecated formPerm_apply_getElem_length (since := \"2024-08-03\")]\ntheorem formPerm_apply_get_length (x : α) (xs : List α) :\n    formPerm (x :: xs) ((x :: xs).get (Fin.mk xs.length (by simp))) = x :=\n  formPerm_apply_getElem_length ..\n\n"}
{"name":"List.formPerm_apply_head","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx y : α\nxs : List α\nh : (List.cons x (List.cons y xs)).Nodup\n⊢ Eq ((List.cons x (List.cons y xs)).formPerm x) y","decl":"theorem formPerm_apply_head (x y : α) (xs : List α) (h : Nodup (x :: y :: xs)) :\n    formPerm (x :: y :: xs) x = y := by simp [formPerm_apply_of_not_mem h.not_mem]\n\n"}
{"name":"List.formPerm_apply_getElem_zero","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nh : l.Nodup\nhl : LT.lt 1 l.length\n⊢ Eq (l.formPerm (GetElem.getElem l 0 ⋯)) (GetElem.getElem l 1 ⋯)","decl":"theorem formPerm_apply_getElem_zero (l : List α) (h : Nodup l) (hl : 1 < l.length) :\n    formPerm l l[0] = l[1] := by\n  rcases l with (_ | ⟨x, _ | ⟨y, tl⟩⟩)\n  · simp at hl\n  · simp at hl\n  · rw [getElem_cons_zero, formPerm_apply_head _ _ _ h, getElem_cons_succ, getElem_cons_zero]\n\n"}
{"name":"List.formPerm_apply_get_zero","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nh : l.Nodup\nhl : LT.lt 1 l.length\n⊢ Eq (l.formPerm (l.get ⟨0, ⋯⟩)) (l.get ⟨1, hl⟩)","decl":"@[deprecated formPerm_apply_getElem_zero (since := \"2024-08-03\")]\ntheorem formPerm_apply_get_zero (l : List α) (h : Nodup l) (hl : 1 < l.length) :\n    formPerm l (l.get (Fin.mk 0 (by omega))) = l.get (Fin.mk 1 hl) :=\n  formPerm_apply_getElem_zero l h hl\n\n"}
{"name":"List.formPerm_eq_head_iff_eq_getLast","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nx y : α\n⊢ Iff (Eq ((List.cons y l).formPerm x) y) (Eq x ((List.cons y l).getLast ⋯))","decl":"theorem formPerm_eq_head_iff_eq_getLast (x y : α) :\n    formPerm (y :: l) x = y ↔ x = getLast (y :: l) (cons_ne_nil _ _) :=\n  Iff.trans (by rw [formPerm_apply_getLast]) (formPerm (y :: l)).injective.eq_iff\n\n"}
{"name":"List.formPerm_apply_lt_getElem","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nxs : List α\nh : xs.Nodup\nn : Nat\nhn : LT.lt (HAdd.hAdd n 1) xs.length\n⊢ Eq (xs.formPerm (GetElem.getElem xs n ⋯)) (GetElem.getElem xs (HAdd.hAdd n 1) ⋯)","decl":"theorem formPerm_apply_lt_getElem (xs : List α) (h : Nodup xs) (n : ℕ) (hn : n + 1 < xs.length) :\n    formPerm xs xs[n] = xs[n + 1] := by\n  induction' n with n IH generalizing xs\n  · simpa using formPerm_apply_getElem_zero _ h _\n  · rcases xs with (_ | ⟨x, _ | ⟨y, l⟩⟩)\n    · simp at hn\n    · rw [formPerm_singleton, getElem_singleton, getElem_singleton, one_apply]\n    · specialize IH (y :: l) h.of_cons _\n      · simpa [Nat.succ_lt_succ_iff] using hn\n      simp only [swap_apply_eq_iff, coe_mul, formPerm_cons_cons, Function.comp]\n      simp only [getElem_cons_succ] at *\n      rw [← IH, swap_apply_of_ne_of_ne] <;>\n      · intro hx\n        rw [← hx, IH] at h\n        simp [getElem_mem] at h\n\n"}
{"name":"List.formPerm_apply_lt_get","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nxs : List α\nh : xs.Nodup\nn : Nat\nhn : LT.lt (HAdd.hAdd n 1) xs.length\n⊢ Eq (xs.formPerm (xs.get ⟨n, ⋯⟩)) (xs.get ⟨HAdd.hAdd n 1, hn⟩)","decl":"@[deprecated formPerm_apply_lt_getElem (since := \"2024-08-03\")]\ntheorem formPerm_apply_lt_get (xs : List α) (h : Nodup xs) (n : ℕ) (hn : n + 1 < xs.length) :\n    formPerm xs (xs.get (Fin.mk n ((Nat.lt_succ_self n).trans hn))) =\n      xs.get (Fin.mk (n + 1) hn) := by\n  simp_all [formPerm_apply_lt_getElem]\n\n"}
{"name":"List.formPerm_apply_getElem","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nxs : List α\nw : xs.Nodup\ni : Nat\nh : LT.lt i xs.length\n⊢ Eq (xs.formPerm (GetElem.getElem xs i ⋯)) (GetElem.getElem xs (HMod.hMod (HAdd.hAdd i 1) xs.length) ⋯)","decl":"theorem formPerm_apply_getElem (xs : List α) (w : Nodup xs) (i : ℕ) (h : i < xs.length) :\n    formPerm xs xs[i] =\n      xs[(i + 1) % xs.length]'(Nat.mod_lt _ (i.zero_le.trans_lt h)) := by\n  cases' xs with x xs\n  · simp at h\n  · have : i ≤ xs.length := by\n      refine Nat.le_of_lt_succ ?_\n      simpa using h\n    rcases this.eq_or_lt with (rfl | hn')\n    · simp\n    · rw [formPerm_apply_lt_getElem (x :: xs) w _ (Nat.succ_lt_succ hn')]\n      congr\n      rw [Nat.mod_eq_of_lt]; simpa [Nat.succ_eq_add_one]\n\n"}
{"name":"List.formPerm_apply_get","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nxs : List α\nh : xs.Nodup\ni : Fin xs.length\n⊢ Eq (xs.formPerm (xs.get i)) (xs.get ⟨HMod.hMod (HAdd.hAdd (↑i) 1) xs.length, ⋯⟩)","decl":"@[deprecated formPerm_apply_getElem (since := \"2024-08-03\")]\ntheorem formPerm_apply_get (xs : List α) (h : Nodup xs) (i : Fin xs.length) :\n    formPerm xs (xs.get i) =\n      xs.get ⟨((i.val + 1) % xs.length), (Nat.mod_lt _ (i.val.zero_le.trans_lt i.isLt))⟩ := by\n  simp [formPerm_apply_getElem, h]\n\n"}
{"name":"List.support_formPerm_of_nodup'","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nh : l.Nodup\nh' : ∀ (x : α), Ne l (List.cons x List.nil)\n⊢ Eq (setOf fun x => Ne (l.formPerm x) x) ↑l.toFinset","decl":"theorem support_formPerm_of_nodup' (l : List α) (h : Nodup l) (h' : ∀ x : α, l ≠ [x]) :\n    { x | formPerm l x ≠ x } = l.toFinset := by\n  apply _root_.le_antisymm\n  · exact support_formPerm_le' l\n  · intro x hx\n    simp only [Finset.mem_coe, mem_toFinset] at hx\n    obtain ⟨n, hn, rfl⟩ := getElem_of_mem hx\n    rw [Set.mem_setOf_eq, formPerm_apply_getElem _ h]\n    intro H\n    rw [nodup_iff_injective_get, Function.Injective] at h\n    specialize h H\n    rcases (Nat.succ_le_of_lt hn).eq_or_lt with hn' | hn'\n    · simp only [← hn', Nat.mod_self] at h\n      refine not_exists.mpr h' ?_\n      rw [← length_eq_one, ← hn', (Fin.mk.inj_iff.mp h).symm]\n    · simp [Nat.mod_eq_of_lt hn'] at h\n\n"}
{"name":"List.support_formPerm_of_nodup","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nl : List α\nh : l.Nodup\nh' : ∀ (x : α), Ne l (List.cons x List.nil)\n⊢ Eq l.formPerm.support l.toFinset","decl":"theorem support_formPerm_of_nodup [Fintype α] (l : List α) (h : Nodup l) (h' : ∀ x : α, l ≠ [x]) :\n    support (formPerm l) = l.toFinset := by\n  rw [← Finset.coe_inj]\n  convert support_formPerm_of_nodup' _ h h'\n  simp [Set.ext_iff]\n\n"}
{"name":"List.formPerm_rotate_one","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nh : l.Nodup\n⊢ Eq (l.rotate 1).formPerm l.formPerm","decl":"theorem formPerm_rotate_one (l : List α) (h : Nodup l) : formPerm (l.rotate 1) = formPerm l := by\n  have h' : Nodup (l.rotate 1) := by simpa using h\n  ext x\n  by_cases hx : x ∈ l.rotate 1\n  · obtain ⟨k, hk, rfl⟩ := getElem_of_mem hx\n    rw [formPerm_apply_getElem _ h', getElem_rotate l, getElem_rotate l, formPerm_apply_getElem _ h]\n    simp\n  · rw [formPerm_apply_of_not_mem hx, formPerm_apply_of_not_mem]\n    simpa using hx\n\n"}
{"name":"List.formPerm_rotate","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nh : l.Nodup\nn : Nat\n⊢ Eq (l.rotate n).formPerm l.formPerm","decl":"theorem formPerm_rotate (l : List α) (h : Nodup l) (n : ℕ) :\n    formPerm (l.rotate n) = formPerm l := by\n  induction n with\n  | zero => simp\n  | succ n hn =>\n    rw [← rotate_rotate, formPerm_rotate_one, hn]\n    rwa [IsRotated.nodup_iff]\n    exact IsRotated.forall l n\n\n"}
{"name":"List.formPerm_eq_of_isRotated","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl l' : List α\nhd : l.Nodup\nh : l.IsRotated l'\n⊢ Eq l.formPerm l'.formPerm","decl":"theorem formPerm_eq_of_isRotated {l l' : List α} (hd : Nodup l) (h : l ~r l') :\n    formPerm l = formPerm l' := by\n  obtain ⟨n, rfl⟩ := h\n  exact (formPerm_rotate l hd n).symm\n\n"}
{"name":"List.formPerm_append_pair","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\na b : α\n⊢ Eq (HAppend.hAppend l (List.cons a (List.cons b List.nil))).formPerm (HMul.hMul (HAppend.hAppend l (List.cons a List.nil)).formPerm (Equiv.swap a b))","decl":"theorem formPerm_append_pair : ∀ (l : List α) (a b : α),\n    formPerm (l ++ [a, b]) = formPerm (l ++ [a]) * swap a b\n  | [], _, _ => rfl\n  | [_], _, _ => rfl\n  | x::y::l, a, b => by\n    simpa [mul_assoc] using formPerm_append_pair (y::l) a b\n\n"}
{"name":"List.formPerm_reverse","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\n⊢ Eq l.reverse.formPerm (Inv.inv l.formPerm)","decl":"theorem formPerm_reverse : ∀ l : List α, formPerm l.reverse = (formPerm l)⁻¹\n  | [] => rfl\n  | [_] => rfl\n  | a::b::l => by\n    simp [formPerm_append_pair, swap_comm, ← formPerm_reverse (b::l)]\n\n"}
{"name":"List.formPerm_pow_apply_getElem","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nw : l.Nodup\nn i : Nat\nh : LT.lt i l.length\n⊢ Eq ((HPow.hPow l.formPerm n) (GetElem.getElem l i ⋯)) (GetElem.getElem l (HMod.hMod (HAdd.hAdd i n) l.length) ⋯)","decl":"theorem formPerm_pow_apply_getElem (l : List α) (w : Nodup l) (n : ℕ) (i : ℕ) (h : i < l.length) :\n    (formPerm l ^ n) l[i] =\n      l[(i + n) % l.length]'(Nat.mod_lt _ (i.zero_le.trans_lt h)) := by\n  induction n with\n  | zero => simp [Nat.mod_eq_of_lt h]\n  | succ n hn =>\n    simp [pow_succ', mul_apply, hn, formPerm_apply_getElem _ w, Nat.succ_eq_add_one,\n      ← Nat.add_assoc]\n\n"}
{"name":"List.formPerm_pow_apply_get","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nh : l.Nodup\nn : Nat\ni : Fin l.length\n⊢ Eq ((HPow.hPow l.formPerm n) (l.get i)) (l.get ⟨HMod.hMod (HAdd.hAdd (↑i) n) l.length, ⋯⟩)","decl":"@[deprecated formPerm_pow_apply_getElem (since := \"2024-08-03\")]\ntheorem formPerm_pow_apply_get (l : List α) (h : Nodup l) (n : ℕ) (i : Fin l.length) :\n    (formPerm l ^ n) (l.get i) =\n      l.get ⟨((i.val + n) % l.length), (Nat.mod_lt _ (i.val.zero_le.trans_lt i.isLt))⟩ := by\n  simp [formPerm_pow_apply_getElem, h]\n\n"}
{"name":"List.formPerm_pow_apply_head","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx : α\nl : List α\nh : (List.cons x l).Nodup\nn : Nat\n⊢ Eq ((HPow.hPow (List.cons x l).formPerm n) x) (GetElem.getElem (List.cons x l) (HMod.hMod n (List.cons x l).length) ⋯)","decl":"theorem formPerm_pow_apply_head (x : α) (l : List α) (h : Nodup (x :: l)) (n : ℕ) :\n    (formPerm (x :: l) ^ n) x =\n      (x :: l)[(n % (x :: l).length)]'(Nat.mod_lt _ (Nat.zero_lt_succ _)) := by\n  convert formPerm_pow_apply_getElem _ h n 0 (Nat.succ_pos _)\n  simp\n\n"}
{"name":"List.formPerm_ext_iff","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx y x' y' : α\nl l' : List α\nhd : (List.cons x (List.cons y l)).Nodup\nhd' : (List.cons x' (List.cons y' l')).Nodup\n⊢ Iff (Eq (List.cons x (List.cons y l)).formPerm (List.cons x' (List.cons y' l')).formPerm) ((List.cons x (List.cons y l)).IsRotated (List.cons x' (List.cons y' l')))","decl":"theorem formPerm_ext_iff {x y x' y' : α} {l l' : List α} (hd : Nodup (x :: y :: l))\n    (hd' : Nodup (x' :: y' :: l')) :\n    formPerm (x :: y :: l) = formPerm (x' :: y' :: l') ↔ (x :: y :: l) ~r (x' :: y' :: l') := by\n  refine ⟨fun h => ?_, fun hr => formPerm_eq_of_isRotated hd hr⟩\n  rw [Equiv.Perm.ext_iff] at h\n  have hx : x' ∈ x :: y :: l := by\n    have : x' ∈ { z | formPerm (x :: y :: l) z ≠ z } := by\n      rw [Set.mem_setOf_eq, h x', formPerm_apply_head _ _ _ hd']\n      simp only [mem_cons, nodup_cons] at hd'\n      push_neg at hd'\n      exact hd'.left.left.symm\n    simpa using support_formPerm_le' _ this\n  obtain ⟨⟨n, hn⟩, hx'⟩ := get_of_mem hx\n  have hl : (x :: y :: l).length = (x' :: y' :: l').length := by\n    rw [← dedup_eq_self.mpr hd, ← dedup_eq_self.mpr hd', ← card_toFinset, ← card_toFinset]\n    refine congr_arg Finset.card ?_\n    rw [← Finset.coe_inj, ← support_formPerm_of_nodup' _ hd (by simp), ←\n      support_formPerm_of_nodup' _ hd' (by simp)]\n    simp only [h]\n  use n\n  apply List.ext_getElem\n  · rw [length_rotate, hl]\n  · intro k hk hk'\n    rw [getElem_rotate]\n    induction' k with k IH\n    · refine Eq.trans ?_ hx'\n      congr\n      simpa using hn\n    · conv => congr <;> · arg 2; (rw [← Nat.mod_eq_of_lt hk'])\n      rw [← formPerm_apply_getElem _ hd' k (k.lt_succ_self.trans hk'),\n        ← IH (k.lt_succ_self.trans hk), ← h, formPerm_apply_getElem _ hd]\n      congr 1\n      rw [hl, Nat.mod_eq_of_lt hk', add_right_comm]\n      apply Nat.add_mod\n\n"}
{"name":"List.formPerm_apply_mem_eq_self_iff","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nhl : l.Nodup\nx : α\nhx : Membership.mem l x\n⊢ Iff (Eq (l.formPerm x) x) (LE.le l.length 1)","decl":"theorem formPerm_apply_mem_eq_self_iff (hl : Nodup l) (x : α) (hx : x ∈ l) :\n    formPerm l x = x ↔ length l ≤ 1 := by\n  obtain ⟨k, hk, rfl⟩ := getElem_of_mem hx\n  rw [formPerm_apply_getElem _ hl k hk, hl.getElem_inj_iff]\n  cases hn : l.length\n  · exact absurd k.zero_le (hk.trans_le hn.le).not_le\n  · rw [hn] at hk\n    rcases (Nat.le_of_lt_succ hk).eq_or_lt with hk' | hk'\n    · simp [← hk', Nat.succ_le_succ_iff, eq_comm]\n    · simpa [Nat.mod_eq_of_lt (Nat.succ_lt_succ hk'), Nat.succ_lt_succ_iff] using\n        (k.zero_le.trans_lt hk').ne.symm\n\n"}
{"name":"List.formPerm_apply_mem_ne_self_iff","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nhl : l.Nodup\nx : α\nhx : Membership.mem l x\n⊢ Iff (Ne (l.formPerm x) x) (LE.le 2 l.length)","decl":"theorem formPerm_apply_mem_ne_self_iff (hl : Nodup l) (x : α) (hx : x ∈ l) :\n    formPerm l x ≠ x ↔ 2 ≤ l.length := by\n  rw [Ne, formPerm_apply_mem_eq_self_iff _ hl x hx, not_le]\n  exact ⟨Nat.succ_le_of_lt, Nat.lt_of_succ_le⟩\n\n"}
{"name":"List.mem_of_formPerm_ne_self","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nx : α\nh : Ne (l.formPerm x) x\n⊢ Membership.mem l x","decl":"theorem mem_of_formPerm_ne_self (l : List α) (x : α) (h : formPerm l x ≠ x) : x ∈ l := by\n  suffices x ∈ { y | formPerm l y ≠ y } by\n    rw [← mem_toFinset]\n    exact support_formPerm_le' _ this\n  simpa using h\n\n"}
{"name":"List.formPerm_eq_self_of_not_mem","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nx : α\nh : Not (Membership.mem l x)\n⊢ Eq (l.formPerm x) x","decl":"theorem formPerm_eq_self_of_not_mem (l : List α) (x : α) (h : x ∉ l) : formPerm l x = x :=\n  by_contra fun H => h <| mem_of_formPerm_ne_self _ _ H\n\n"}
{"name":"List.formPerm_eq_one_iff","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nhl : l.Nodup\n⊢ Iff (Eq l.formPerm 1) (LE.le l.length 1)","decl":"theorem formPerm_eq_one_iff (hl : Nodup l) : formPerm l = 1 ↔ l.length ≤ 1 := by\n  cases' l with hd tl\n  · simp\n  · rw [← formPerm_apply_mem_eq_self_iff _ hl hd (mem_cons_self _ _)]\n    constructor\n    · simp +contextual\n    · intro h\n      simp only [(hd :: tl).formPerm_apply_mem_eq_self_iff hl hd (mem_cons_self hd tl),\n        add_le_iff_nonpos_left, length, nonpos_iff_eq_zero, length_eq_zero] at h\n      simp [h]\n\n"}
{"name":"List.formPerm_eq_formPerm_iff","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl l' : List α\nhl : l.Nodup\nhl' : l'.Nodup\n⊢ Iff (Eq l.formPerm l'.formPerm) (Or (l.IsRotated l') (And (LE.le l.length 1) (LE.le l'.length 1)))","decl":"theorem formPerm_eq_formPerm_iff {l l' : List α} (hl : l.Nodup) (hl' : l'.Nodup) :\n    l.formPerm = l'.formPerm ↔ l ~r l' ∨ l.length ≤ 1 ∧ l'.length ≤ 1 := by\n  rcases l with (_ | ⟨x, _ | ⟨y, l⟩⟩)\n  · suffices l'.length ≤ 1 ↔ l' = nil ∨ l'.length ≤ 1 by\n      simpa [eq_comm, formPerm_eq_one_iff, hl, hl', length_eq_zero]\n    refine ⟨fun h => Or.inr h, ?_⟩\n    rintro (rfl | h)\n    · simp\n    · exact h\n  · suffices l'.length ≤ 1 ↔ [x] ~r l' ∨ l'.length ≤ 1 by\n      simpa [eq_comm, formPerm_eq_one_iff, hl, hl', length_eq_zero, le_rfl]\n    refine ⟨fun h => Or.inr h, ?_⟩\n    rintro (h | h)\n    · simp [← h.perm.length_eq]\n    · exact h\n  · rcases l' with (_ | ⟨x', _ | ⟨y', l'⟩⟩)\n    · simp [formPerm_eq_one_iff _ hl, -formPerm_cons_cons]\n    · simp [formPerm_eq_one_iff _ hl, -formPerm_cons_cons]\n    · simp [-formPerm_cons_cons, formPerm_ext_iff hl hl', Nat.succ_le_succ_iff]\n\n"}
{"name":"List.form_perm_zpow_apply_mem_imp_mem","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nx : α\nhx : Membership.mem l x\nn : Int\n⊢ Membership.mem l ((HPow.hPow l.formPerm n) x)","decl":"theorem form_perm_zpow_apply_mem_imp_mem (l : List α) (x : α) (hx : x ∈ l) (n : ℤ) :\n    (formPerm l ^ n) x ∈ l := by\n  by_cases h : (l.formPerm ^ n) x = x\n  · simpa [h] using hx\n  · have h : x ∈ { x | (l.formPerm ^ n) x ≠ x } := h\n    rw [← set_support_apply_mem] at h\n    replace h := set_support_zpow_subset _ _ h\n    simpa using support_formPerm_le' _ h\n\n"}
{"name":"List.formPerm_pow_length_eq_one_of_nodup","module":"Mathlib.GroupTheory.Perm.List","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nhl : l.Nodup\n⊢ Eq (HPow.hPow l.formPerm l.length) 1","decl":"theorem formPerm_pow_length_eq_one_of_nodup (hl : Nodup l) : formPerm l ^ length l = 1 := by\n  ext x\n  by_cases hx : x ∈ l\n  · obtain ⟨k, hk, rfl⟩ := getElem_of_mem hx\n    simp [formPerm_pow_apply_getElem _ hl, Nat.mod_eq_of_lt hk]\n  · have : x ∉ { x | (l.formPerm ^ l.length) x ≠ x } := by\n      intro H\n      refine hx ?_\n      replace H := set_support_zpow_subset l.formPerm l.length H\n      simpa using support_formPerm_le' _ H\n    simpa using this\n\n"}
