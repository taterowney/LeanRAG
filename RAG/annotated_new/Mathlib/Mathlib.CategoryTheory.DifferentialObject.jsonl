{"name":"CategoryTheory.DifferentialObject.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœâµ : AddMonoidWithOne S\nC : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœÂ² : CategoryTheory.HasShift C S\ninstâœÂ¹ : SizeOf S\ninstâœ : SizeOf C\nobj : C\nd : Quiver.Hom obj ((CategoryTheory.shiftFunctor C 1).obj obj)\nd_squared : autoParam (Eq (CategoryTheory.CategoryStruct.comp d ((CategoryTheory.shiftFunctor C 1).map d)) 0) _autoâœ\nâŠ¢ Eq (SizeOf.sizeOf { obj := obj, d := d, d_squared := d_squared }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf obj)) (SizeOf.sizeOf d)) (SizeOf.sizeOf d_squared))","decl":"/-- A differential object in a category with zero morphisms and a shift is\nan object `obj` equipped with\na morphism `d : obj âŸ¶ objâŸ¦1âŸ§`, such that `d^2 = 0`. -/\nstructure DifferentialObject where\n  /-- The underlying object of a differential object. -/\n  obj : C\n  /-- The differential of a differential object. -/\n  d : obj âŸ¶ objâŸ¦(1 : S)âŸ§\n  /-- The differential `d` satisfies that `dÂ² = 0`. -/\n  d_squared : d â‰« dâŸ¦(1 : S)âŸ§' = 0 := by aesop_cat\n\n"}
{"name":"CategoryTheory.DifferentialObject.d_squared","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœÂ³ : AddMonoidWithOne S\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nself : CategoryTheory.DifferentialObject S C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp self.d ((CategoryTheory.shiftFunctor C 1).map self.d)) 0","decl":"/-- A differential object in a category with zero morphisms and a shift is\nan object `obj` equipped with\na morphism `d : obj âŸ¶ objâŸ¦1âŸ§`, such that `d^2 = 0`. -/\nstructure DifferentialObject where\n  /-- The underlying object of a differential object. -/\n  obj : C\n  /-- The differential of a differential object. -/\n  d : obj âŸ¶ objâŸ¦(1 : S)âŸ§\n  /-- The differential `d` satisfies that `dÂ² = 0`. -/\n  d_squared : d â‰« dâŸ¦(1 : S)âŸ§' = 0 := by aesop_cat\n\n"}
{"name":"CategoryTheory.DifferentialObject.mk.inj","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœÂ³ : AddMonoidWithOne S\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nobjâœ : C\ndâœ : Quiver.Hom objâœ ((CategoryTheory.shiftFunctor C 1).obj objâœ)\nd_squaredâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp dâœ ((CategoryTheory.shiftFunctor C 1).map dâœ)) 0) _autoâœ\nobj : C\nd : Quiver.Hom obj ((CategoryTheory.shiftFunctor C 1).obj obj)\nd_squared : autoParam (Eq (CategoryTheory.CategoryStruct.comp d ((CategoryTheory.shiftFunctor C 1).map d)) 0) _autoâœ\nxâœ : Eq { obj := objâœ, d := dâœ, d_squared := d_squaredâœ } { obj := obj, d := d, d_squared := d_squared }\nâŠ¢ And (Eq objâœ obj) (HEq dâœ d)","decl":"/-- A differential object in a category with zero morphisms and a shift is\nan object `obj` equipped with\na morphism `d : obj âŸ¶ objâŸ¦1âŸ§`, such that `d^2 = 0`. -/\nstructure DifferentialObject where\n  /-- The underlying object of a differential object. -/\n  obj : C\n  /-- The differential of a differential object. -/\n  d : obj âŸ¶ objâŸ¦(1 : S)âŸ§\n  /-- The differential `d` satisfies that `dÂ² = 0`. -/\n  d_squared : d â‰« dâŸ¦(1 : S)âŸ§' = 0 := by aesop_cat\n\n"}
{"name":"CategoryTheory.DifferentialObject.mk.injEq","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœÂ³ : AddMonoidWithOne S\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nobjâœ : C\ndâœ : Quiver.Hom objâœ ((CategoryTheory.shiftFunctor C 1).obj objâœ)\nd_squaredâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp dâœ ((CategoryTheory.shiftFunctor C 1).map dâœ)) 0) _autoâœ\nobj : C\nd : Quiver.Hom obj ((CategoryTheory.shiftFunctor C 1).obj obj)\nd_squared : autoParam (Eq (CategoryTheory.CategoryStruct.comp d ((CategoryTheory.shiftFunctor C 1).map d)) 0) _autoâœ\nâŠ¢ Eq (Eq { obj := objâœ, d := dâœ, d_squared := d_squaredâœ } { obj := obj, d := d, d_squared := d_squared }) (And (Eq objâœ obj) (HEq dâœ d))","decl":"/-- A differential object in a category with zero morphisms and a shift is\nan object `obj` equipped with\na morphism `d : obj âŸ¶ objâŸ¦1âŸ§`, such that `d^2 = 0`. -/\nstructure DifferentialObject where\n  /-- The underlying object of a differential object. -/\n  obj : C\n  /-- The differential of a differential object. -/\n  d : obj âŸ¶ objâŸ¦(1 : S)âŸ§\n  /-- The differential `d` satisfies that `dÂ² = 0`. -/\n  d_squared : d â‰« dâŸ¦(1 : S)âŸ§' = 0 := by aesop_cat\n\n"}
{"name":"CategoryTheory.DifferentialObject.d_squared_assoc","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœÂ³ : AddMonoidWithOne S\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nself : CategoryTheory.DifferentialObject S C\nZ : C\nh : Quiver.Hom ((CategoryTheory.shiftFunctor C 1).obj ((CategoryTheory.shiftFunctor C 1).obj self.obj)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp self.d (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C 1).map self.d) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"attribute [reassoc (attr := simp)] DifferentialObject.d_squared\n\n"}
{"name":"CategoryTheory.DifferentialObject.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœâµ : AddMonoidWithOne S\nC : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœÂ² : CategoryTheory.HasShift C S\nX Y : CategoryTheory.DifferentialObject S C\ninstâœÂ¹ : SizeOf S\ninstâœ : SizeOf C\nf : Quiver.Hom X.obj Y.obj\ncomm : autoParam (Eq (CategoryTheory.CategoryStruct.comp X.d ((CategoryTheory.shiftFunctor C 1).map f)) (CategoryTheory.CategoryStruct.comp f Y.d)) _autoâœ\nâŠ¢ Eq (SizeOf.sizeOf { f := f, comm := comm }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf f)) (SizeOf.sizeOf comm))","decl":"/-- A morphism of differential objects is a morphism commuting with the differentials. -/\n@[ext]\nstructure Hom (X Y : DifferentialObject S C) where\n  /-- The morphism between underlying objects of the two differentiable objects. -/\n  f : X.obj âŸ¶ Y.obj\n  comm : X.d â‰« fâŸ¦1âŸ§' = f â‰« Y.d := by aesop_cat\n\n"}
{"name":"CategoryTheory.DifferentialObject.Hom.ext_iff","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœÂ³ : AddMonoidWithOne S\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nX Y : CategoryTheory.DifferentialObject S C\nx y : X.Hom Y\nâŠ¢ Iff (Eq x y) (Eq x.f y.f)","decl":"/-- A morphism of differential objects is a morphism commuting with the differentials. -/\n@[ext]\nstructure Hom (X Y : DifferentialObject S C) where\n  /-- The morphism between underlying objects of the two differentiable objects. -/\n  f : X.obj âŸ¶ Y.obj\n  comm : X.d â‰« fâŸ¦1âŸ§' = f â‰« Y.d := by aesop_cat\n\n"}
{"name":"CategoryTheory.DifferentialObject.Hom.mk.inj","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœÂ³ : AddMonoidWithOne S\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nX Y : CategoryTheory.DifferentialObject S C\nfâœ : Quiver.Hom X.obj Y.obj\ncommâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp X.d ((CategoryTheory.shiftFunctor C 1).map fâœ)) (CategoryTheory.CategoryStruct.comp fâœ Y.d)) _autoâœ\nf : Quiver.Hom X.obj Y.obj\ncomm : autoParam (Eq (CategoryTheory.CategoryStruct.comp X.d ((CategoryTheory.shiftFunctor C 1).map f)) (CategoryTheory.CategoryStruct.comp f Y.d)) _autoâœ\nxâœ : Eq { f := fâœ, comm := commâœ } { f := f, comm := comm }\nâŠ¢ Eq fâœ f","decl":"/-- A morphism of differential objects is a morphism commuting with the differentials. -/\n@[ext]\nstructure Hom (X Y : DifferentialObject S C) where\n  /-- The morphism between underlying objects of the two differentiable objects. -/\n  f : X.obj âŸ¶ Y.obj\n  comm : X.d â‰« fâŸ¦1âŸ§' = f â‰« Y.d := by aesop_cat\n\n"}
{"name":"CategoryTheory.DifferentialObject.Hom.mk.injEq","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœÂ³ : AddMonoidWithOne S\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nX Y : CategoryTheory.DifferentialObject S C\nfâœ : Quiver.Hom X.obj Y.obj\ncommâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp X.d ((CategoryTheory.shiftFunctor C 1).map fâœ)) (CategoryTheory.CategoryStruct.comp fâœ Y.d)) _autoâœ\nf : Quiver.Hom X.obj Y.obj\ncomm : autoParam (Eq (CategoryTheory.CategoryStruct.comp X.d ((CategoryTheory.shiftFunctor C 1).map f)) (CategoryTheory.CategoryStruct.comp f Y.d)) _autoâœ\nâŠ¢ Eq (Eq { f := fâœ, comm := commâœ } { f := f, comm := comm }) (Eq fâœ f)","decl":"/-- A morphism of differential objects is a morphism commuting with the differentials. -/\n@[ext]\nstructure Hom (X Y : DifferentialObject S C) where\n  /-- The morphism between underlying objects of the two differentiable objects. -/\n  f : X.obj âŸ¶ Y.obj\n  comm : X.d â‰« fâŸ¦1âŸ§' = f â‰« Y.d := by aesop_cat\n\n"}
{"name":"CategoryTheory.DifferentialObject.Hom.comm","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœÂ³ : AddMonoidWithOne S\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nX Y : CategoryTheory.DifferentialObject S C\nself : X.Hom Y\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp X.d ((CategoryTheory.shiftFunctor C 1).map self.f)) (CategoryTheory.CategoryStruct.comp self.f Y.d)","decl":"/-- A morphism of differential objects is a morphism commuting with the differentials. -/\n@[ext]\nstructure Hom (X Y : DifferentialObject S C) where\n  /-- The morphism between underlying objects of the two differentiable objects. -/\n  f : X.obj âŸ¶ Y.obj\n  comm : X.d â‰« fâŸ¦1âŸ§' = f â‰« Y.d := by aesop_cat\n\n"}
{"name":"CategoryTheory.DifferentialObject.Hom.ext","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœÂ³ : AddMonoidWithOne S\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nX Y : CategoryTheory.DifferentialObject S C\nx y : X.Hom Y\nf : Eq x.f y.f\nâŠ¢ Eq x y","decl":"/-- A morphism of differential objects is a morphism commuting with the differentials. -/\n@[ext]\nstructure Hom (X Y : DifferentialObject S C) where\n  /-- The morphism between underlying objects of the two differentiable objects. -/\n  f : X.obj âŸ¶ Y.obj\n  comm : X.d â‰« fâŸ¦1âŸ§' = f â‰« Y.d := by aesop_cat\n\n"}
{"name":"CategoryTheory.DifferentialObject.Hom.comm_assoc","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœÂ³ : AddMonoidWithOne S\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nX Y : CategoryTheory.DifferentialObject S C\nself : X.Hom Y\nZ : C\nh : Quiver.Hom ((CategoryTheory.shiftFunctor C 1).obj Y.obj) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp X.d (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C 1).map self.f) h)) (CategoryTheory.CategoryStruct.comp self.f (CategoryTheory.CategoryStruct.comp Y.d h))","decl":"attribute [reassoc (attr := simp)] Hom.comm\n\n"}
{"name":"CategoryTheory.DifferentialObject.Hom.id_f","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœÂ³ : AddMonoidWithOne S\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nX : CategoryTheory.DifferentialObject S C\nâŠ¢ Eq (CategoryTheory.DifferentialObject.Hom.id X).f (CategoryTheory.CategoryStruct.id X.obj)","decl":"/-- The identity morphism of a differential object. -/\n@[simps]\ndef id (X : DifferentialObject S C) : Hom X X where\n  f := ğŸ™ X.obj\n\n"}
{"name":"CategoryTheory.DifferentialObject.Hom.comp_f","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœÂ³ : AddMonoidWithOne S\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nX Y Z : CategoryTheory.DifferentialObject S C\nf : X.Hom Y\ng : Y.Hom Z\nâŠ¢ Eq (f.comp g).f (CategoryTheory.CategoryStruct.comp f.f g.f)","decl":"/-- The composition of morphisms of differential objects. -/\n@[simps]\ndef comp {X Y Z : DifferentialObject S C} (f : Hom X Y) (g : Hom Y Z) : Hom X Z where\n  f := f.f â‰« g.f\n\n"}
{"name":"CategoryTheory.DifferentialObject.ext_iff","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœÂ³ : AddMonoidWithOne S\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nA B : CategoryTheory.DifferentialObject S C\nf g : Quiver.Hom A B\nâŠ¢ Iff (Eq f g) (autoParam (Eq f.f g.f) _autoâœ)","decl":"@[ext]\ntheorem ext {A B : DifferentialObject S C} {f g : A âŸ¶ B} (w : f.f = g.f := by aesop_cat) : f = g :=\n  Hom.ext w\n\n"}
{"name":"CategoryTheory.DifferentialObject.ext","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœÂ³ : AddMonoidWithOne S\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nA B : CategoryTheory.DifferentialObject S C\nf g : Quiver.Hom A B\nw : autoParam (Eq f.f g.f) _autoâœ\nâŠ¢ Eq f g","decl":"@[ext]\ntheorem ext {A B : DifferentialObject S C} {f g : A âŸ¶ B} (w : f.f = g.f := by aesop_cat) : f = g :=\n  Hom.ext w\n\n"}
{"name":"CategoryTheory.DifferentialObject.id_f","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœÂ³ : AddMonoidWithOne S\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nX : CategoryTheory.DifferentialObject S C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.id X).f (CategoryTheory.CategoryStruct.id X.obj)","decl":"@[simp]\ntheorem id_f (X : DifferentialObject S C) : (ğŸ™ X : X âŸ¶ X).f = ğŸ™ X.obj := rfl\n\n"}
{"name":"CategoryTheory.DifferentialObject.comp_f","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœÂ³ : AddMonoidWithOne S\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nX Y Z : CategoryTheory.DifferentialObject S C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f g).f (CategoryTheory.CategoryStruct.comp f.f g.f)","decl":"@[simp]\ntheorem comp_f {X Y Z : DifferentialObject S C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) :\n    (f â‰« g).f = f.f â‰« g.f :=\n  rfl\n\n"}
{"name":"CategoryTheory.DifferentialObject.eqToHom_f","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœÂ³ : AddMonoidWithOne S\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nX Y : CategoryTheory.DifferentialObject S C\nh : Eq X Y\nâŠ¢ Eq (CategoryTheory.eqToHom h).f (CategoryTheory.eqToHom â‹¯)","decl":"@[simp]\ntheorem eqToHom_f {X Y : DifferentialObject S C} (h : X = Y) :\n    Hom.f (eqToHom h) = eqToHom (congr_arg _ h) := by\n  subst h\n  rw [eqToHom_refl, eqToHom_refl]\n  rfl\n\n"}
{"name":"CategoryTheory.DifferentialObject.forget_faithful","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœÂ³ : AddMonoidWithOne S\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nâŠ¢ (CategoryTheory.DifferentialObject.forget S C).Faithful","decl":"instance forget_faithful : (forget S C).Faithful where\n\n"}
{"name":"CategoryTheory.DifferentialObject.zero_f","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœâ´ : AddMonoidWithOne S\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœÂ¹ : CategoryTheory.HasShift C S\ninstâœ : (CategoryTheory.shiftFunctor C 1).PreservesZeroMorphisms\nP Q : CategoryTheory.DifferentialObject S C\nâŠ¢ Eq (CategoryTheory.DifferentialObject.Hom.f 0) 0","decl":"@[simp]\ntheorem zero_f (P Q : DifferentialObject S C) : (0 : P âŸ¶ Q).f = 0 := rfl\n\n"}
{"name":"CategoryTheory.DifferentialObject.isoApp_hom","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœÂ³ : AddMonoidWithOne S\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nX Y : CategoryTheory.DifferentialObject S C\nf : CategoryTheory.Iso X Y\nâŠ¢ Eq (CategoryTheory.DifferentialObject.isoApp f).hom f.hom.f","decl":"/-- An isomorphism of differential objects gives an isomorphism of the underlying objects. -/\n@[simps]\ndef isoApp {X Y : DifferentialObject S C} (f : X â‰… Y) : X.obj â‰… Y.obj where\n  hom := f.hom.f\n  inv := f.inv.f\n  hom_inv_id := by rw [â† comp_f, Iso.hom_inv_id, id_f]\n  inv_hom_id := by rw [â† comp_f, Iso.inv_hom_id, id_f]\n\n"}
{"name":"CategoryTheory.DifferentialObject.isoApp_inv","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœÂ³ : AddMonoidWithOne S\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nX Y : CategoryTheory.DifferentialObject S C\nf : CategoryTheory.Iso X Y\nâŠ¢ Eq (CategoryTheory.DifferentialObject.isoApp f).inv f.inv.f","decl":"/-- An isomorphism of differential objects gives an isomorphism of the underlying objects. -/\n@[simps]\ndef isoApp {X Y : DifferentialObject S C} (f : X â‰… Y) : X.obj â‰… Y.obj where\n  hom := f.hom.f\n  inv := f.inv.f\n  hom_inv_id := by rw [â† comp_f, Iso.hom_inv_id, id_f]\n  inv_hom_id := by rw [â† comp_f, Iso.inv_hom_id, id_f]\n\n"}
{"name":"CategoryTheory.DifferentialObject.isoApp_refl","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœÂ³ : AddMonoidWithOne S\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nX : CategoryTheory.DifferentialObject S C\nâŠ¢ Eq (CategoryTheory.DifferentialObject.isoApp (CategoryTheory.Iso.refl X)) (CategoryTheory.Iso.refl X.obj)","decl":"@[simp]\ntheorem isoApp_refl (X : DifferentialObject S C) : isoApp (Iso.refl X) = Iso.refl X.obj := rfl\n\n"}
{"name":"CategoryTheory.DifferentialObject.isoApp_symm","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœÂ³ : AddMonoidWithOne S\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nX Y : CategoryTheory.DifferentialObject S C\nf : CategoryTheory.Iso X Y\nâŠ¢ Eq (CategoryTheory.DifferentialObject.isoApp f.symm) (CategoryTheory.DifferentialObject.isoApp f).symm","decl":"@[simp]\ntheorem isoApp_symm {X Y : DifferentialObject S C} (f : X â‰… Y) : isoApp f.symm = (isoApp f).symm :=\n  rfl\n\n"}
{"name":"CategoryTheory.DifferentialObject.isoApp_trans","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœÂ³ : AddMonoidWithOne S\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nX Y Z : CategoryTheory.DifferentialObject S C\nf : CategoryTheory.Iso X Y\ng : CategoryTheory.Iso Y Z\nâŠ¢ Eq (CategoryTheory.DifferentialObject.isoApp (f.trans g)) ((CategoryTheory.DifferentialObject.isoApp f).trans (CategoryTheory.DifferentialObject.isoApp g))","decl":"@[simp]\ntheorem isoApp_trans {X Y Z : DifferentialObject S C} (f : X â‰… Y) (g : Y â‰… Z) :\n    isoApp (f â‰ªâ‰« g) = isoApp f â‰ªâ‰« isoApp g := rfl\n\n"}
{"name":"CategoryTheory.DifferentialObject.mkIso_hom_f","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœÂ³ : AddMonoidWithOne S\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nX Y : CategoryTheory.DifferentialObject S C\nf : CategoryTheory.Iso X.obj Y.obj\nhf : Eq (CategoryTheory.CategoryStruct.comp X.d ((CategoryTheory.shiftFunctor C 1).map f.hom)) (CategoryTheory.CategoryStruct.comp f.hom Y.d)\nâŠ¢ Eq (CategoryTheory.DifferentialObject.mkIso f hf).hom.f f.hom","decl":"/-- An isomorphism of differential objects can be constructed\nfrom an isomorphism of the underlying objects that commutes with the differentials. -/\n@[simps]\ndef mkIso {X Y : DifferentialObject S C} (f : X.obj â‰… Y.obj) (hf : X.d â‰« f.homâŸ¦1âŸ§' = f.hom â‰« Y.d) :\n    X â‰… Y where\n  hom := âŸ¨f.hom, hfâŸ©\n  inv := âŸ¨f.inv, by\n    rw [â† Functor.mapIso_inv, Iso.comp_inv_eq, Category.assoc, Iso.eq_inv_comp, Functor.mapIso_hom,\n      hf]âŸ©\n  hom_inv_id := by ext1; dsimp; exact f.hom_inv_id\n  inv_hom_id := by ext1; dsimp; exact f.inv_hom_id\n\n"}
{"name":"CategoryTheory.DifferentialObject.mkIso_inv_f","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœÂ³ : AddMonoidWithOne S\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nX Y : CategoryTheory.DifferentialObject S C\nf : CategoryTheory.Iso X.obj Y.obj\nhf : Eq (CategoryTheory.CategoryStruct.comp X.d ((CategoryTheory.shiftFunctor C 1).map f.hom)) (CategoryTheory.CategoryStruct.comp f.hom Y.d)\nâŠ¢ Eq (CategoryTheory.DifferentialObject.mkIso f hf).inv.f f.inv","decl":"/-- An isomorphism of differential objects can be constructed\nfrom an isomorphism of the underlying objects that commutes with the differentials. -/\n@[simps]\ndef mkIso {X Y : DifferentialObject S C} (f : X.obj â‰… Y.obj) (hf : X.d â‰« f.homâŸ¦1âŸ§' = f.hom â‰« Y.d) :\n    X â‰… Y where\n  hom := âŸ¨f.hom, hfâŸ©\n  inv := âŸ¨f.inv, by\n    rw [â† Functor.mapIso_inv, Iso.comp_inv_eq, Category.assoc, Iso.eq_inv_comp, Functor.mapIso_hom,\n      hf]âŸ©\n  hom_inv_id := by ext1; dsimp; exact f.hom_inv_id\n  inv_hom_id := by ext1; dsimp; exact f.inv_hom_id\n\n"}
{"name":"CategoryTheory.Functor.mapDifferentialObject_obj_obj","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœâ¶ : AddMonoidWithOne S\nC : Type u\ninstâœâµ : CategoryTheory.Category.{v, u} C\ninstâœâ´ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœÂ³ : CategoryTheory.HasShift C S\nD : Type u'\ninstâœÂ² : CategoryTheory.Category.{v', u'} D\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms D\ninstâœ : CategoryTheory.HasShift D S\nF : CategoryTheory.Functor C D\nÎ· : Quiver.Hom ((CategoryTheory.shiftFunctor C 1).comp F) (F.comp (CategoryTheory.shiftFunctor D 1))\nhF : âˆ€ (c c' : C), Eq (F.map 0) 0\nX : CategoryTheory.DifferentialObject S C\nâŠ¢ Eq ((CategoryTheory.Functor.mapDifferentialObject D F Î· hF).obj X).obj (F.obj X.obj)","decl":"/-- A functor `F : C â¥¤ D` which commutes with shift functors on `C` and `D` and preserves zero\nmorphisms can be lifted to a functor `DifferentialObject S C â¥¤ DifferentialObject S D`. -/\n@[simps]\ndef mapDifferentialObject (F : C â¥¤ D)\n    (Î· : (shiftFunctor C (1 : S)).comp F âŸ¶ F.comp (shiftFunctor D (1 : S)))\n    (hF : âˆ€ c c', F.map (0 : c âŸ¶ c') = 0) : DifferentialObject S C â¥¤ DifferentialObject S D where\n  obj X :=\n    { obj := F.obj X.obj\n      d := F.map X.d â‰« Î·.app X.obj\n      d_squared := by\n        rw [Functor.map_comp, â† Functor.comp_map F (shiftFunctor D (1 : S))]\n        slice_lhs 2 3 => rw [â† Î·.naturality X.d]\n        rw [Functor.comp_map]\n        slice_lhs 1 2 => rw [â† F.map_comp, X.d_squared, hF]\n        rw [zero_comp, zero_comp] }\n  map f :=\n    { f := F.map f.f\n      comm := by\n        dsimp\n        slice_lhs 2 3 => rw [â† Functor.comp_map F (shiftFunctor D (1 : S)), â† Î·.naturality f.f]\n        slice_lhs 1 2 => rw [Functor.comp_map, â† F.map_comp, f.comm, F.map_comp]\n        rw [Category.assoc] }\n  map_id := by intros; ext; simp\n  map_comp := by intros; ext; simp\n\n"}
{"name":"CategoryTheory.Functor.mapDifferentialObject_obj_d","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœâ¶ : AddMonoidWithOne S\nC : Type u\ninstâœâµ : CategoryTheory.Category.{v, u} C\ninstâœâ´ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœÂ³ : CategoryTheory.HasShift C S\nD : Type u'\ninstâœÂ² : CategoryTheory.Category.{v', u'} D\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms D\ninstâœ : CategoryTheory.HasShift D S\nF : CategoryTheory.Functor C D\nÎ· : Quiver.Hom ((CategoryTheory.shiftFunctor C 1).comp F) (F.comp (CategoryTheory.shiftFunctor D 1))\nhF : âˆ€ (c c' : C), Eq (F.map 0) 0\nX : CategoryTheory.DifferentialObject S C\nâŠ¢ Eq ((CategoryTheory.Functor.mapDifferentialObject D F Î· hF).obj X).d (CategoryTheory.CategoryStruct.comp (F.map X.d) (Î·.app X.obj))","decl":"/-- A functor `F : C â¥¤ D` which commutes with shift functors on `C` and `D` and preserves zero\nmorphisms can be lifted to a functor `DifferentialObject S C â¥¤ DifferentialObject S D`. -/\n@[simps]\ndef mapDifferentialObject (F : C â¥¤ D)\n    (Î· : (shiftFunctor C (1 : S)).comp F âŸ¶ F.comp (shiftFunctor D (1 : S)))\n    (hF : âˆ€ c c', F.map (0 : c âŸ¶ c') = 0) : DifferentialObject S C â¥¤ DifferentialObject S D where\n  obj X :=\n    { obj := F.obj X.obj\n      d := F.map X.d â‰« Î·.app X.obj\n      d_squared := by\n        rw [Functor.map_comp, â† Functor.comp_map F (shiftFunctor D (1 : S))]\n        slice_lhs 2 3 => rw [â† Î·.naturality X.d]\n        rw [Functor.comp_map]\n        slice_lhs 1 2 => rw [â† F.map_comp, X.d_squared, hF]\n        rw [zero_comp, zero_comp] }\n  map f :=\n    { f := F.map f.f\n      comm := by\n        dsimp\n        slice_lhs 2 3 => rw [â† Functor.comp_map F (shiftFunctor D (1 : S)), â† Î·.naturality f.f]\n        slice_lhs 1 2 => rw [Functor.comp_map, â† F.map_comp, f.comm, F.map_comp]\n        rw [Category.assoc] }\n  map_id := by intros; ext; simp\n  map_comp := by intros; ext; simp\n\n"}
{"name":"CategoryTheory.Functor.mapDifferentialObject_map_f","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœâ¶ : AddMonoidWithOne S\nC : Type u\ninstâœâµ : CategoryTheory.Category.{v, u} C\ninstâœâ´ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœÂ³ : CategoryTheory.HasShift C S\nD : Type u'\ninstâœÂ² : CategoryTheory.Category.{v', u'} D\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms D\ninstâœ : CategoryTheory.HasShift D S\nF : CategoryTheory.Functor C D\nÎ· : Quiver.Hom ((CategoryTheory.shiftFunctor C 1).comp F) (F.comp (CategoryTheory.shiftFunctor D 1))\nhF : âˆ€ (c c' : C), Eq (F.map 0) 0\nXâœ Yâœ : CategoryTheory.DifferentialObject S C\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Functor.mapDifferentialObject D F Î· hF).map f).f (F.map f.f)","decl":"/-- A functor `F : C â¥¤ D` which commutes with shift functors on `C` and `D` and preserves zero\nmorphisms can be lifted to a functor `DifferentialObject S C â¥¤ DifferentialObject S D`. -/\n@[simps]\ndef mapDifferentialObject (F : C â¥¤ D)\n    (Î· : (shiftFunctor C (1 : S)).comp F âŸ¶ F.comp (shiftFunctor D (1 : S)))\n    (hF : âˆ€ c c', F.map (0 : c âŸ¶ c') = 0) : DifferentialObject S C â¥¤ DifferentialObject S D where\n  obj X :=\n    { obj := F.obj X.obj\n      d := F.map X.d â‰« Î·.app X.obj\n      d_squared := by\n        rw [Functor.map_comp, â† Functor.comp_map F (shiftFunctor D (1 : S))]\n        slice_lhs 2 3 => rw [â† Î·.naturality X.d]\n        rw [Functor.comp_map]\n        slice_lhs 1 2 => rw [â† F.map_comp, X.d_squared, hF]\n        rw [zero_comp, zero_comp] }\n  map f :=\n    { f := F.map f.f\n      comm := by\n        dsimp\n        slice_lhs 2 3 => rw [â† Functor.comp_map F (shiftFunctor D (1 : S)), â† Î·.naturality f.f]\n        slice_lhs 1 2 => rw [Functor.comp_map, â† F.map_comp, f.comm, F.map_comp]\n        rw [Category.assoc] }\n  map_id := by intros; ext; simp\n  map_comp := by intros; ext; simp\n\n"}
{"name":"CategoryTheory.DifferentialObject.hasZeroObject","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœâ´ : AddMonoidWithOne S\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nâŠ¢ CategoryTheory.Limits.HasZeroObject (CategoryTheory.DifferentialObject S C)","decl":"instance hasZeroObject : HasZeroObject (DifferentialObject S C) where\n  zero := âŸ¨{ obj := 0, d := 0 },\n    { unique_to := fun X => âŸ¨âŸ¨âŸ¨{ f := 0 }âŸ©, fun f => by extâŸ©âŸ©,\n      unique_from := fun X => âŸ¨âŸ¨âŸ¨{ f := 0 }âŸ©, fun f => by extâŸ©âŸ© }âŸ©\n\n"}
{"name":"CategoryTheory.DifferentialObject.shiftFunctor_map_f","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœÂ³ : AddCommGroupWithOne S\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nn : S\nXâœ Yâœ : CategoryTheory.DifferentialObject S C\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.DifferentialObject.shiftFunctor C n).map f).f ((CategoryTheory.shiftFunctor C n).map f.f)","decl":"/-- The shift functor on `DifferentialObject S C`. -/\n@[simps]\ndef shiftFunctor (n : S) : DifferentialObject S C â¥¤ DifferentialObject S C where\n  obj X :=\n    { obj := X.objâŸ¦nâŸ§\n      d := X.dâŸ¦nâŸ§' â‰« (shiftComm _ _ _).hom\n      d_squared := by\n        rw [Functor.map_comp, Category.assoc, shiftComm_hom_comp_assoc, â† Functor.map_comp_assoc,\n          X.d_squared, Functor.map_zero, zero_comp] }\n  map f :=\n    { f := f.fâŸ¦nâŸ§'\n      comm := by\n        dsimp\n        erw [Category.assoc, shiftComm_hom_comp, â† Functor.map_comp_assoc, f.comm,\n          Functor.map_comp_assoc]\n        rfl }\n  map_id X := by ext1; dsimp; rw [Functor.map_id]\n  map_comp f g := by ext1; dsimp; rw [Functor.map_comp]\n\n"}
{"name":"CategoryTheory.DifferentialObject.shiftFunctor_obj_obj","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœÂ³ : AddCommGroupWithOne S\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nn : S\nX : CategoryTheory.DifferentialObject S C\nâŠ¢ Eq ((CategoryTheory.DifferentialObject.shiftFunctor C n).obj X).obj ((CategoryTheory.shiftFunctor C n).obj X.obj)","decl":"/-- The shift functor on `DifferentialObject S C`. -/\n@[simps]\ndef shiftFunctor (n : S) : DifferentialObject S C â¥¤ DifferentialObject S C where\n  obj X :=\n    { obj := X.objâŸ¦nâŸ§\n      d := X.dâŸ¦nâŸ§' â‰« (shiftComm _ _ _).hom\n      d_squared := by\n        rw [Functor.map_comp, Category.assoc, shiftComm_hom_comp_assoc, â† Functor.map_comp_assoc,\n          X.d_squared, Functor.map_zero, zero_comp] }\n  map f :=\n    { f := f.fâŸ¦nâŸ§'\n      comm := by\n        dsimp\n        erw [Category.assoc, shiftComm_hom_comp, â† Functor.map_comp_assoc, f.comm,\n          Functor.map_comp_assoc]\n        rfl }\n  map_id X := by ext1; dsimp; rw [Functor.map_id]\n  map_comp f g := by ext1; dsimp; rw [Functor.map_comp]\n\n"}
{"name":"CategoryTheory.DifferentialObject.shiftFunctor_obj_d","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœÂ³ : AddCommGroupWithOne S\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nn : S\nX : CategoryTheory.DifferentialObject S C\nâŠ¢ Eq ((CategoryTheory.DifferentialObject.shiftFunctor C n).obj X).d (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C n).map X.d) (CategoryTheory.shiftComm X.obj 1 n).hom)","decl":"/-- The shift functor on `DifferentialObject S C`. -/\n@[simps]\ndef shiftFunctor (n : S) : DifferentialObject S C â¥¤ DifferentialObject S C where\n  obj X :=\n    { obj := X.objâŸ¦nâŸ§\n      d := X.dâŸ¦nâŸ§' â‰« (shiftComm _ _ _).hom\n      d_squared := by\n        rw [Functor.map_comp, Category.assoc, shiftComm_hom_comp_assoc, â† Functor.map_comp_assoc,\n          X.d_squared, Functor.map_zero, zero_comp] }\n  map f :=\n    { f := f.fâŸ¦nâŸ§'\n      comm := by\n        dsimp\n        erw [Category.assoc, shiftComm_hom_comp, â† Functor.map_comp_assoc, f.comm,\n          Functor.map_comp_assoc]\n        rfl }\n  map_id X := by ext1; dsimp; rw [Functor.map_id]\n  map_comp f g := by ext1; dsimp; rw [Functor.map_comp]\n\n"}
{"name":"CategoryTheory.DifferentialObject.shiftFunctorAdd_hom_app_f","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœÂ³ : AddCommGroupWithOne S\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nm n : S\nX : CategoryTheory.DifferentialObject S C\nâŠ¢ Eq ((CategoryTheory.DifferentialObject.shiftFunctorAdd C m n).hom.app X).f ((CategoryTheory.shiftFunctorAdd C m n).hom.app X.obj)","decl":"/-- The shift functor on `DifferentialObject S C` is additive. -/\n@[simps!]\nnonrec def shiftFunctorAdd (m n : S) :\n    shiftFunctor C (m + n) â‰… shiftFunctor C m â‹™ shiftFunctor C n := by\n  refine NatIso.ofComponents (fun X => mkIso (shiftAdd X.obj _ _) ?_) (fun f => ?_)\n  Â· dsimp\n    rw [â† cancel_epi ((shiftFunctorAdd C m n).inv.app X.obj)]\n    simp only [Category.assoc, Iso.inv_hom_id_app_assoc]\n    rw [â† NatTrans.naturality_assoc]\n    dsimp\n    simp only [Functor.map_comp, Category.assoc,\n      shiftFunctorComm_hom_app_comp_shift_shiftFunctorAdd_hom_app 1 m n X.obj,\n      Iso.inv_hom_id_app_assoc]\n  Â· ext; dsimp; exact NatTrans.naturality _ _\n\n"}
{"name":"CategoryTheory.DifferentialObject.shiftFunctorAdd_inv_app_f","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœÂ³ : AddCommGroupWithOne S\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nm n : S\nX : CategoryTheory.DifferentialObject S C\nâŠ¢ Eq ((CategoryTheory.DifferentialObject.shiftFunctorAdd C m n).inv.app X).f ((CategoryTheory.shiftFunctorAdd C m n).inv.app X.obj)","decl":"/-- The shift functor on `DifferentialObject S C` is additive. -/\n@[simps!]\nnonrec def shiftFunctorAdd (m n : S) :\n    shiftFunctor C (m + n) â‰… shiftFunctor C m â‹™ shiftFunctor C n := by\n  refine NatIso.ofComponents (fun X => mkIso (shiftAdd X.obj _ _) ?_) (fun f => ?_)\n  Â· dsimp\n    rw [â† cancel_epi ((shiftFunctorAdd C m n).inv.app X.obj)]\n    simp only [Category.assoc, Iso.inv_hom_id_app_assoc]\n    rw [â† NatTrans.naturality_assoc]\n    dsimp\n    simp only [Functor.map_comp, Category.assoc,\n      shiftFunctorComm_hom_app_comp_shift_shiftFunctorAdd_hom_app 1 m n X.obj,\n      Iso.inv_hom_id_app_assoc]\n  Â· ext; dsimp; exact NatTrans.naturality _ _\n\n"}
{"name":"CategoryTheory.DifferentialObject.shiftZero_inv_app_f","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœÂ³ : AddCommGroupWithOne S\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nX : CategoryTheory.DifferentialObject S C\nâŠ¢ Eq ((CategoryTheory.DifferentialObject.shiftZero C).inv.app X).f ((CategoryTheory.shiftFunctorZero C S).inv.app X.obj)","decl":"/-- The shift by zero is naturally isomorphic to the identity. -/\n@[simps!]\ndef shiftZero : shiftFunctor C (0 : S) â‰… ğŸ­ (DifferentialObject S C) := by\n  refine NatIso.ofComponents (fun X => mkIso ((shiftFunctorZero C S).app X.obj) ?_) (fun f => ?_)\n  Â· erw [â† NatTrans.naturality]\n    dsimp\n    simp only [shiftFunctorZero_hom_app_shift, Category.assoc]\n  Â· aesop_cat\n\n"}
{"name":"CategoryTheory.DifferentialObject.shiftZero_hom_app_f","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninstâœÂ³ : AddCommGroupWithOne S\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.HasShift C S\nX : CategoryTheory.DifferentialObject S C\nâŠ¢ Eq ((CategoryTheory.DifferentialObject.shiftZero C).hom.app X).f ((CategoryTheory.shiftFunctorZero C S).hom.app X.obj)","decl":"/-- The shift by zero is naturally isomorphic to the identity. -/\n@[simps!]\ndef shiftZero : shiftFunctor C (0 : S) â‰… ğŸ­ (DifferentialObject S C) := by\n  refine NatIso.ofComponents (fun X => mkIso ((shiftFunctorZero C S).app X.obj) ?_) (fun f => ?_)\n  Â· erw [â† NatTrans.naturality]\n    dsimp\n    simp only [shiftFunctorZero_hom_app_shift, Category.assoc]\n  Â· aesop_cat\n\n"}
