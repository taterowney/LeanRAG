{"name":"CategoryTheory.DifferentialObject.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝⁵ : AddMonoidWithOne S\nC : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.HasShift C S\ninst✝¹ : SizeOf S\ninst✝ : SizeOf C\nobj : C\nd : Quiver.Hom obj ((CategoryTheory.shiftFunctor C 1).obj obj)\nd_squared : autoParam (Eq (CategoryTheory.CategoryStruct.comp d ((CategoryTheory.shiftFunctor C 1).map d)) 0) _auto✝\n⊢ Eq (SizeOf.sizeOf { obj := obj, d := d, d_squared := d_squared }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf obj)) (SizeOf.sizeOf d)) (SizeOf.sizeOf d_squared))","decl":"/-- A differential object in a category with zero morphisms and a shift is\nan object `obj` equipped with\na morphism `d : obj ⟶ obj⟦1⟧`, such that `d^2 = 0`. -/\nstructure DifferentialObject where\n  /-- The underlying object of a differential object. -/\n  obj : C\n  /-- The differential of a differential object. -/\n  d : obj ⟶ obj⟦(1 : S)⟧\n  /-- The differential `d` satisfies that `d² = 0`. -/\n  d_squared : d ≫ d⟦(1 : S)⟧' = 0 := by aesop_cat\n\n"}
{"name":"CategoryTheory.DifferentialObject.d_squared","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝³ : AddMonoidWithOne S\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\nself : CategoryTheory.DifferentialObject S C\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.d ((CategoryTheory.shiftFunctor C 1).map self.d)) 0","decl":"/-- A differential object in a category with zero morphisms and a shift is\nan object `obj` equipped with\na morphism `d : obj ⟶ obj⟦1⟧`, such that `d^2 = 0`. -/\nstructure DifferentialObject where\n  /-- The underlying object of a differential object. -/\n  obj : C\n  /-- The differential of a differential object. -/\n  d : obj ⟶ obj⟦(1 : S)⟧\n  /-- The differential `d` satisfies that `d² = 0`. -/\n  d_squared : d ≫ d⟦(1 : S)⟧' = 0 := by aesop_cat\n\n"}
{"name":"CategoryTheory.DifferentialObject.mk.inj","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝³ : AddMonoidWithOne S\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\nobj✝ : C\nd✝ : Quiver.Hom obj✝ ((CategoryTheory.shiftFunctor C 1).obj obj✝)\nd_squared✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp d✝ ((CategoryTheory.shiftFunctor C 1).map d✝)) 0) _auto✝\nobj : C\nd : Quiver.Hom obj ((CategoryTheory.shiftFunctor C 1).obj obj)\nd_squared : autoParam (Eq (CategoryTheory.CategoryStruct.comp d ((CategoryTheory.shiftFunctor C 1).map d)) 0) _auto✝\nx✝ : Eq { obj := obj✝, d := d✝, d_squared := d_squared✝ } { obj := obj, d := d, d_squared := d_squared }\n⊢ And (Eq obj✝ obj) (HEq d✝ d)","decl":"/-- A differential object in a category with zero morphisms and a shift is\nan object `obj` equipped with\na morphism `d : obj ⟶ obj⟦1⟧`, such that `d^2 = 0`. -/\nstructure DifferentialObject where\n  /-- The underlying object of a differential object. -/\n  obj : C\n  /-- The differential of a differential object. -/\n  d : obj ⟶ obj⟦(1 : S)⟧\n  /-- The differential `d` satisfies that `d² = 0`. -/\n  d_squared : d ≫ d⟦(1 : S)⟧' = 0 := by aesop_cat\n\n"}
{"name":"CategoryTheory.DifferentialObject.mk.injEq","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝³ : AddMonoidWithOne S\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\nobj✝ : C\nd✝ : Quiver.Hom obj✝ ((CategoryTheory.shiftFunctor C 1).obj obj✝)\nd_squared✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp d✝ ((CategoryTheory.shiftFunctor C 1).map d✝)) 0) _auto✝\nobj : C\nd : Quiver.Hom obj ((CategoryTheory.shiftFunctor C 1).obj obj)\nd_squared : autoParam (Eq (CategoryTheory.CategoryStruct.comp d ((CategoryTheory.shiftFunctor C 1).map d)) 0) _auto✝\n⊢ Eq (Eq { obj := obj✝, d := d✝, d_squared := d_squared✝ } { obj := obj, d := d, d_squared := d_squared }) (And (Eq obj✝ obj) (HEq d✝ d))","decl":"/-- A differential object in a category with zero morphisms and a shift is\nan object `obj` equipped with\na morphism `d : obj ⟶ obj⟦1⟧`, such that `d^2 = 0`. -/\nstructure DifferentialObject where\n  /-- The underlying object of a differential object. -/\n  obj : C\n  /-- The differential of a differential object. -/\n  d : obj ⟶ obj⟦(1 : S)⟧\n  /-- The differential `d` satisfies that `d² = 0`. -/\n  d_squared : d ≫ d⟦(1 : S)⟧' = 0 := by aesop_cat\n\n"}
{"name":"CategoryTheory.DifferentialObject.d_squared_assoc","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝³ : AddMonoidWithOne S\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\nself : CategoryTheory.DifferentialObject S C\nZ : C\nh : Quiver.Hom ((CategoryTheory.shiftFunctor C 1).obj ((CategoryTheory.shiftFunctor C 1).obj self.obj)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.d (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C 1).map self.d) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"attribute [reassoc (attr := simp)] DifferentialObject.d_squared\n\n"}
{"name":"CategoryTheory.DifferentialObject.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝⁵ : AddMonoidWithOne S\nC : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.HasShift C S\nX Y : CategoryTheory.DifferentialObject S C\ninst✝¹ : SizeOf S\ninst✝ : SizeOf C\nf : Quiver.Hom X.obj Y.obj\ncomm : autoParam (Eq (CategoryTheory.CategoryStruct.comp X.d ((CategoryTheory.shiftFunctor C 1).map f)) (CategoryTheory.CategoryStruct.comp f Y.d)) _auto✝\n⊢ Eq (SizeOf.sizeOf { f := f, comm := comm }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf f)) (SizeOf.sizeOf comm))","decl":"/-- A morphism of differential objects is a morphism commuting with the differentials. -/\n@[ext]\nstructure Hom (X Y : DifferentialObject S C) where\n  /-- The morphism between underlying objects of the two differentiable objects. -/\n  f : X.obj ⟶ Y.obj\n  comm : X.d ≫ f⟦1⟧' = f ≫ Y.d := by aesop_cat\n\n"}
{"name":"CategoryTheory.DifferentialObject.Hom.ext_iff","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝³ : AddMonoidWithOne S\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\nX Y : CategoryTheory.DifferentialObject S C\nx y : X.Hom Y\n⊢ Iff (Eq x y) (Eq x.f y.f)","decl":"/-- A morphism of differential objects is a morphism commuting with the differentials. -/\n@[ext]\nstructure Hom (X Y : DifferentialObject S C) where\n  /-- The morphism between underlying objects of the two differentiable objects. -/\n  f : X.obj ⟶ Y.obj\n  comm : X.d ≫ f⟦1⟧' = f ≫ Y.d := by aesop_cat\n\n"}
{"name":"CategoryTheory.DifferentialObject.Hom.mk.inj","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝³ : AddMonoidWithOne S\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\nX Y : CategoryTheory.DifferentialObject S C\nf✝ : Quiver.Hom X.obj Y.obj\ncomm✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp X.d ((CategoryTheory.shiftFunctor C 1).map f✝)) (CategoryTheory.CategoryStruct.comp f✝ Y.d)) _auto✝\nf : Quiver.Hom X.obj Y.obj\ncomm : autoParam (Eq (CategoryTheory.CategoryStruct.comp X.d ((CategoryTheory.shiftFunctor C 1).map f)) (CategoryTheory.CategoryStruct.comp f Y.d)) _auto✝\nx✝ : Eq { f := f✝, comm := comm✝ } { f := f, comm := comm }\n⊢ Eq f✝ f","decl":"/-- A morphism of differential objects is a morphism commuting with the differentials. -/\n@[ext]\nstructure Hom (X Y : DifferentialObject S C) where\n  /-- The morphism between underlying objects of the two differentiable objects. -/\n  f : X.obj ⟶ Y.obj\n  comm : X.d ≫ f⟦1⟧' = f ≫ Y.d := by aesop_cat\n\n"}
{"name":"CategoryTheory.DifferentialObject.Hom.mk.injEq","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝³ : AddMonoidWithOne S\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\nX Y : CategoryTheory.DifferentialObject S C\nf✝ : Quiver.Hom X.obj Y.obj\ncomm✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp X.d ((CategoryTheory.shiftFunctor C 1).map f✝)) (CategoryTheory.CategoryStruct.comp f✝ Y.d)) _auto✝\nf : Quiver.Hom X.obj Y.obj\ncomm : autoParam (Eq (CategoryTheory.CategoryStruct.comp X.d ((CategoryTheory.shiftFunctor C 1).map f)) (CategoryTheory.CategoryStruct.comp f Y.d)) _auto✝\n⊢ Eq (Eq { f := f✝, comm := comm✝ } { f := f, comm := comm }) (Eq f✝ f)","decl":"/-- A morphism of differential objects is a morphism commuting with the differentials. -/\n@[ext]\nstructure Hom (X Y : DifferentialObject S C) where\n  /-- The morphism between underlying objects of the two differentiable objects. -/\n  f : X.obj ⟶ Y.obj\n  comm : X.d ≫ f⟦1⟧' = f ≫ Y.d := by aesop_cat\n\n"}
{"name":"CategoryTheory.DifferentialObject.Hom.comm","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝³ : AddMonoidWithOne S\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\nX Y : CategoryTheory.DifferentialObject S C\nself : X.Hom Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp X.d ((CategoryTheory.shiftFunctor C 1).map self.f)) (CategoryTheory.CategoryStruct.comp self.f Y.d)","decl":"/-- A morphism of differential objects is a morphism commuting with the differentials. -/\n@[ext]\nstructure Hom (X Y : DifferentialObject S C) where\n  /-- The morphism between underlying objects of the two differentiable objects. -/\n  f : X.obj ⟶ Y.obj\n  comm : X.d ≫ f⟦1⟧' = f ≫ Y.d := by aesop_cat\n\n"}
{"name":"CategoryTheory.DifferentialObject.Hom.ext","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝³ : AddMonoidWithOne S\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\nX Y : CategoryTheory.DifferentialObject S C\nx y : X.Hom Y\nf : Eq x.f y.f\n⊢ Eq x y","decl":"/-- A morphism of differential objects is a morphism commuting with the differentials. -/\n@[ext]\nstructure Hom (X Y : DifferentialObject S C) where\n  /-- The morphism between underlying objects of the two differentiable objects. -/\n  f : X.obj ⟶ Y.obj\n  comm : X.d ≫ f⟦1⟧' = f ≫ Y.d := by aesop_cat\n\n"}
{"name":"CategoryTheory.DifferentialObject.Hom.comm_assoc","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝³ : AddMonoidWithOne S\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\nX Y : CategoryTheory.DifferentialObject S C\nself : X.Hom Y\nZ : C\nh : Quiver.Hom ((CategoryTheory.shiftFunctor C 1).obj Y.obj) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp X.d (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C 1).map self.f) h)) (CategoryTheory.CategoryStruct.comp self.f (CategoryTheory.CategoryStruct.comp Y.d h))","decl":"attribute [reassoc (attr := simp)] Hom.comm\n\n"}
{"name":"CategoryTheory.DifferentialObject.Hom.id_f","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝³ : AddMonoidWithOne S\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\nX : CategoryTheory.DifferentialObject S C\n⊢ Eq (CategoryTheory.DifferentialObject.Hom.id X).f (CategoryTheory.CategoryStruct.id X.obj)","decl":"/-- The identity morphism of a differential object. -/\n@[simps]\ndef id (X : DifferentialObject S C) : Hom X X where\n  f := 𝟙 X.obj\n\n"}
{"name":"CategoryTheory.DifferentialObject.Hom.comp_f","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝³ : AddMonoidWithOne S\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\nX Y Z : CategoryTheory.DifferentialObject S C\nf : X.Hom Y\ng : Y.Hom Z\n⊢ Eq (f.comp g).f (CategoryTheory.CategoryStruct.comp f.f g.f)","decl":"/-- The composition of morphisms of differential objects. -/\n@[simps]\ndef comp {X Y Z : DifferentialObject S C} (f : Hom X Y) (g : Hom Y Z) : Hom X Z where\n  f := f.f ≫ g.f\n\n"}
{"name":"CategoryTheory.DifferentialObject.ext_iff","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝³ : AddMonoidWithOne S\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\nA B : CategoryTheory.DifferentialObject S C\nf g : Quiver.Hom A B\n⊢ Iff (Eq f g) (autoParam (Eq f.f g.f) _auto✝)","decl":"@[ext]\ntheorem ext {A B : DifferentialObject S C} {f g : A ⟶ B} (w : f.f = g.f := by aesop_cat) : f = g :=\n  Hom.ext w\n\n"}
{"name":"CategoryTheory.DifferentialObject.ext","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝³ : AddMonoidWithOne S\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\nA B : CategoryTheory.DifferentialObject S C\nf g : Quiver.Hom A B\nw : autoParam (Eq f.f g.f) _auto✝\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {A B : DifferentialObject S C} {f g : A ⟶ B} (w : f.f = g.f := by aesop_cat) : f = g :=\n  Hom.ext w\n\n"}
{"name":"CategoryTheory.DifferentialObject.id_f","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝³ : AddMonoidWithOne S\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\nX : CategoryTheory.DifferentialObject S C\n⊢ Eq (CategoryTheory.CategoryStruct.id X).f (CategoryTheory.CategoryStruct.id X.obj)","decl":"@[simp]\ntheorem id_f (X : DifferentialObject S C) : (𝟙 X : X ⟶ X).f = 𝟙 X.obj := rfl\n\n"}
{"name":"CategoryTheory.DifferentialObject.comp_f","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝³ : AddMonoidWithOne S\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\nX Y Z : CategoryTheory.DifferentialObject S C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).f (CategoryTheory.CategoryStruct.comp f.f g.f)","decl":"@[simp]\ntheorem comp_f {X Y Z : DifferentialObject S C} (f : X ⟶ Y) (g : Y ⟶ Z) :\n    (f ≫ g).f = f.f ≫ g.f :=\n  rfl\n\n"}
{"name":"CategoryTheory.DifferentialObject.eqToHom_f","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝³ : AddMonoidWithOne S\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\nX Y : CategoryTheory.DifferentialObject S C\nh : Eq X Y\n⊢ Eq (CategoryTheory.eqToHom h).f (CategoryTheory.eqToHom ⋯)","decl":"@[simp]\ntheorem eqToHom_f {X Y : DifferentialObject S C} (h : X = Y) :\n    Hom.f (eqToHom h) = eqToHom (congr_arg _ h) := by\n  subst h\n  rw [eqToHom_refl, eqToHom_refl]\n  rfl\n\n"}
{"name":"CategoryTheory.DifferentialObject.forget_faithful","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝³ : AddMonoidWithOne S\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\n⊢ (CategoryTheory.DifferentialObject.forget S C).Faithful","decl":"instance forget_faithful : (forget S C).Faithful where\n\n"}
{"name":"CategoryTheory.DifferentialObject.zero_f","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝⁴ : AddMonoidWithOne S\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.HasShift C S\ninst✝ : (CategoryTheory.shiftFunctor C 1).PreservesZeroMorphisms\nP Q : CategoryTheory.DifferentialObject S C\n⊢ Eq (CategoryTheory.DifferentialObject.Hom.f 0) 0","decl":"@[simp]\ntheorem zero_f (P Q : DifferentialObject S C) : (0 : P ⟶ Q).f = 0 := rfl\n\n"}
{"name":"CategoryTheory.DifferentialObject.isoApp_hom","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝³ : AddMonoidWithOne S\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\nX Y : CategoryTheory.DifferentialObject S C\nf : CategoryTheory.Iso X Y\n⊢ Eq (CategoryTheory.DifferentialObject.isoApp f).hom f.hom.f","decl":"/-- An isomorphism of differential objects gives an isomorphism of the underlying objects. -/\n@[simps]\ndef isoApp {X Y : DifferentialObject S C} (f : X ≅ Y) : X.obj ≅ Y.obj where\n  hom := f.hom.f\n  inv := f.inv.f\n  hom_inv_id := by rw [← comp_f, Iso.hom_inv_id, id_f]\n  inv_hom_id := by rw [← comp_f, Iso.inv_hom_id, id_f]\n\n"}
{"name":"CategoryTheory.DifferentialObject.isoApp_inv","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝³ : AddMonoidWithOne S\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\nX Y : CategoryTheory.DifferentialObject S C\nf : CategoryTheory.Iso X Y\n⊢ Eq (CategoryTheory.DifferentialObject.isoApp f).inv f.inv.f","decl":"/-- An isomorphism of differential objects gives an isomorphism of the underlying objects. -/\n@[simps]\ndef isoApp {X Y : DifferentialObject S C} (f : X ≅ Y) : X.obj ≅ Y.obj where\n  hom := f.hom.f\n  inv := f.inv.f\n  hom_inv_id := by rw [← comp_f, Iso.hom_inv_id, id_f]\n  inv_hom_id := by rw [← comp_f, Iso.inv_hom_id, id_f]\n\n"}
{"name":"CategoryTheory.DifferentialObject.isoApp_refl","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝³ : AddMonoidWithOne S\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\nX : CategoryTheory.DifferentialObject S C\n⊢ Eq (CategoryTheory.DifferentialObject.isoApp (CategoryTheory.Iso.refl X)) (CategoryTheory.Iso.refl X.obj)","decl":"@[simp]\ntheorem isoApp_refl (X : DifferentialObject S C) : isoApp (Iso.refl X) = Iso.refl X.obj := rfl\n\n"}
{"name":"CategoryTheory.DifferentialObject.isoApp_symm","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝³ : AddMonoidWithOne S\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\nX Y : CategoryTheory.DifferentialObject S C\nf : CategoryTheory.Iso X Y\n⊢ Eq (CategoryTheory.DifferentialObject.isoApp f.symm) (CategoryTheory.DifferentialObject.isoApp f).symm","decl":"@[simp]\ntheorem isoApp_symm {X Y : DifferentialObject S C} (f : X ≅ Y) : isoApp f.symm = (isoApp f).symm :=\n  rfl\n\n"}
{"name":"CategoryTheory.DifferentialObject.isoApp_trans","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝³ : AddMonoidWithOne S\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\nX Y Z : CategoryTheory.DifferentialObject S C\nf : CategoryTheory.Iso X Y\ng : CategoryTheory.Iso Y Z\n⊢ Eq (CategoryTheory.DifferentialObject.isoApp (f.trans g)) ((CategoryTheory.DifferentialObject.isoApp f).trans (CategoryTheory.DifferentialObject.isoApp g))","decl":"@[simp]\ntheorem isoApp_trans {X Y Z : DifferentialObject S C} (f : X ≅ Y) (g : Y ≅ Z) :\n    isoApp (f ≪≫ g) = isoApp f ≪≫ isoApp g := rfl\n\n"}
{"name":"CategoryTheory.DifferentialObject.mkIso_hom_f","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝³ : AddMonoidWithOne S\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\nX Y : CategoryTheory.DifferentialObject S C\nf : CategoryTheory.Iso X.obj Y.obj\nhf : Eq (CategoryTheory.CategoryStruct.comp X.d ((CategoryTheory.shiftFunctor C 1).map f.hom)) (CategoryTheory.CategoryStruct.comp f.hom Y.d)\n⊢ Eq (CategoryTheory.DifferentialObject.mkIso f hf).hom.f f.hom","decl":"/-- An isomorphism of differential objects can be constructed\nfrom an isomorphism of the underlying objects that commutes with the differentials. -/\n@[simps]\ndef mkIso {X Y : DifferentialObject S C} (f : X.obj ≅ Y.obj) (hf : X.d ≫ f.hom⟦1⟧' = f.hom ≫ Y.d) :\n    X ≅ Y where\n  hom := ⟨f.hom, hf⟩\n  inv := ⟨f.inv, by\n    rw [← Functor.mapIso_inv, Iso.comp_inv_eq, Category.assoc, Iso.eq_inv_comp, Functor.mapIso_hom,\n      hf]⟩\n  hom_inv_id := by ext1; dsimp; exact f.hom_inv_id\n  inv_hom_id := by ext1; dsimp; exact f.inv_hom_id\n\n"}
{"name":"CategoryTheory.DifferentialObject.mkIso_inv_f","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝³ : AddMonoidWithOne S\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\nX Y : CategoryTheory.DifferentialObject S C\nf : CategoryTheory.Iso X.obj Y.obj\nhf : Eq (CategoryTheory.CategoryStruct.comp X.d ((CategoryTheory.shiftFunctor C 1).map f.hom)) (CategoryTheory.CategoryStruct.comp f.hom Y.d)\n⊢ Eq (CategoryTheory.DifferentialObject.mkIso f hf).inv.f f.inv","decl":"/-- An isomorphism of differential objects can be constructed\nfrom an isomorphism of the underlying objects that commutes with the differentials. -/\n@[simps]\ndef mkIso {X Y : DifferentialObject S C} (f : X.obj ≅ Y.obj) (hf : X.d ≫ f.hom⟦1⟧' = f.hom ≫ Y.d) :\n    X ≅ Y where\n  hom := ⟨f.hom, hf⟩\n  inv := ⟨f.inv, by\n    rw [← Functor.mapIso_inv, Iso.comp_inv_eq, Category.assoc, Iso.eq_inv_comp, Functor.mapIso_hom,\n      hf]⟩\n  hom_inv_id := by ext1; dsimp; exact f.hom_inv_id\n  inv_hom_id := by ext1; dsimp; exact f.inv_hom_id\n\n"}
{"name":"CategoryTheory.Functor.mapDifferentialObject_obj_obj","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝⁶ : AddMonoidWithOne S\nC : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.HasShift C S\nD : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} D\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\ninst✝ : CategoryTheory.HasShift D S\nF : CategoryTheory.Functor C D\nη : Quiver.Hom ((CategoryTheory.shiftFunctor C 1).comp F) (F.comp (CategoryTheory.shiftFunctor D 1))\nhF : ∀ (c c' : C), Eq (F.map 0) 0\nX : CategoryTheory.DifferentialObject S C\n⊢ Eq ((CategoryTheory.Functor.mapDifferentialObject D F η hF).obj X).obj (F.obj X.obj)","decl":"/-- A functor `F : C ⥤ D` which commutes with shift functors on `C` and `D` and preserves zero\nmorphisms can be lifted to a functor `DifferentialObject S C ⥤ DifferentialObject S D`. -/\n@[simps]\ndef mapDifferentialObject (F : C ⥤ D)\n    (η : (shiftFunctor C (1 : S)).comp F ⟶ F.comp (shiftFunctor D (1 : S)))\n    (hF : ∀ c c', F.map (0 : c ⟶ c') = 0) : DifferentialObject S C ⥤ DifferentialObject S D where\n  obj X :=\n    { obj := F.obj X.obj\n      d := F.map X.d ≫ η.app X.obj\n      d_squared := by\n        rw [Functor.map_comp, ← Functor.comp_map F (shiftFunctor D (1 : S))]\n        slice_lhs 2 3 => rw [← η.naturality X.d]\n        rw [Functor.comp_map]\n        slice_lhs 1 2 => rw [← F.map_comp, X.d_squared, hF]\n        rw [zero_comp, zero_comp] }\n  map f :=\n    { f := F.map f.f\n      comm := by\n        dsimp\n        slice_lhs 2 3 => rw [← Functor.comp_map F (shiftFunctor D (1 : S)), ← η.naturality f.f]\n        slice_lhs 1 2 => rw [Functor.comp_map, ← F.map_comp, f.comm, F.map_comp]\n        rw [Category.assoc] }\n  map_id := by intros; ext; simp\n  map_comp := by intros; ext; simp\n\n"}
{"name":"CategoryTheory.Functor.mapDifferentialObject_obj_d","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝⁶ : AddMonoidWithOne S\nC : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.HasShift C S\nD : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} D\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\ninst✝ : CategoryTheory.HasShift D S\nF : CategoryTheory.Functor C D\nη : Quiver.Hom ((CategoryTheory.shiftFunctor C 1).comp F) (F.comp (CategoryTheory.shiftFunctor D 1))\nhF : ∀ (c c' : C), Eq (F.map 0) 0\nX : CategoryTheory.DifferentialObject S C\n⊢ Eq ((CategoryTheory.Functor.mapDifferentialObject D F η hF).obj X).d (CategoryTheory.CategoryStruct.comp (F.map X.d) (η.app X.obj))","decl":"/-- A functor `F : C ⥤ D` which commutes with shift functors on `C` and `D` and preserves zero\nmorphisms can be lifted to a functor `DifferentialObject S C ⥤ DifferentialObject S D`. -/\n@[simps]\ndef mapDifferentialObject (F : C ⥤ D)\n    (η : (shiftFunctor C (1 : S)).comp F ⟶ F.comp (shiftFunctor D (1 : S)))\n    (hF : ∀ c c', F.map (0 : c ⟶ c') = 0) : DifferentialObject S C ⥤ DifferentialObject S D where\n  obj X :=\n    { obj := F.obj X.obj\n      d := F.map X.d ≫ η.app X.obj\n      d_squared := by\n        rw [Functor.map_comp, ← Functor.comp_map F (shiftFunctor D (1 : S))]\n        slice_lhs 2 3 => rw [← η.naturality X.d]\n        rw [Functor.comp_map]\n        slice_lhs 1 2 => rw [← F.map_comp, X.d_squared, hF]\n        rw [zero_comp, zero_comp] }\n  map f :=\n    { f := F.map f.f\n      comm := by\n        dsimp\n        slice_lhs 2 3 => rw [← Functor.comp_map F (shiftFunctor D (1 : S)), ← η.naturality f.f]\n        slice_lhs 1 2 => rw [Functor.comp_map, ← F.map_comp, f.comm, F.map_comp]\n        rw [Category.assoc] }\n  map_id := by intros; ext; simp\n  map_comp := by intros; ext; simp\n\n"}
{"name":"CategoryTheory.Functor.mapDifferentialObject_map_f","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝⁶ : AddMonoidWithOne S\nC : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.HasShift C S\nD : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} D\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\ninst✝ : CategoryTheory.HasShift D S\nF : CategoryTheory.Functor C D\nη : Quiver.Hom ((CategoryTheory.shiftFunctor C 1).comp F) (F.comp (CategoryTheory.shiftFunctor D 1))\nhF : ∀ (c c' : C), Eq (F.map 0) 0\nX✝ Y✝ : CategoryTheory.DifferentialObject S C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Functor.mapDifferentialObject D F η hF).map f).f (F.map f.f)","decl":"/-- A functor `F : C ⥤ D` which commutes with shift functors on `C` and `D` and preserves zero\nmorphisms can be lifted to a functor `DifferentialObject S C ⥤ DifferentialObject S D`. -/\n@[simps]\ndef mapDifferentialObject (F : C ⥤ D)\n    (η : (shiftFunctor C (1 : S)).comp F ⟶ F.comp (shiftFunctor D (1 : S)))\n    (hF : ∀ c c', F.map (0 : c ⟶ c') = 0) : DifferentialObject S C ⥤ DifferentialObject S D where\n  obj X :=\n    { obj := F.obj X.obj\n      d := F.map X.d ≫ η.app X.obj\n      d_squared := by\n        rw [Functor.map_comp, ← Functor.comp_map F (shiftFunctor D (1 : S))]\n        slice_lhs 2 3 => rw [← η.naturality X.d]\n        rw [Functor.comp_map]\n        slice_lhs 1 2 => rw [← F.map_comp, X.d_squared, hF]\n        rw [zero_comp, zero_comp] }\n  map f :=\n    { f := F.map f.f\n      comm := by\n        dsimp\n        slice_lhs 2 3 => rw [← Functor.comp_map F (shiftFunctor D (1 : S)), ← η.naturality f.f]\n        slice_lhs 1 2 => rw [Functor.comp_map, ← F.map_comp, f.comm, F.map_comp]\n        rw [Category.assoc] }\n  map_id := by intros; ext; simp\n  map_comp := by intros; ext; simp\n\n"}
{"name":"CategoryTheory.DifferentialObject.hasZeroObject","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝⁴ : AddMonoidWithOne S\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\n⊢ CategoryTheory.Limits.HasZeroObject (CategoryTheory.DifferentialObject S C)","decl":"instance hasZeroObject : HasZeroObject (DifferentialObject S C) where\n  zero := ⟨{ obj := 0, d := 0 },\n    { unique_to := fun X => ⟨⟨⟨{ f := 0 }⟩, fun f => by ext⟩⟩,\n      unique_from := fun X => ⟨⟨⟨{ f := 0 }⟩, fun f => by ext⟩⟩ }⟩\n\n"}
{"name":"CategoryTheory.DifferentialObject.shiftFunctor_map_f","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝³ : AddCommGroupWithOne S\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\nn : S\nX✝ Y✝ : CategoryTheory.DifferentialObject S C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.DifferentialObject.shiftFunctor C n).map f).f ((CategoryTheory.shiftFunctor C n).map f.f)","decl":"/-- The shift functor on `DifferentialObject S C`. -/\n@[simps]\ndef shiftFunctor (n : S) : DifferentialObject S C ⥤ DifferentialObject S C where\n  obj X :=\n    { obj := X.obj⟦n⟧\n      d := X.d⟦n⟧' ≫ (shiftComm _ _ _).hom\n      d_squared := by\n        rw [Functor.map_comp, Category.assoc, shiftComm_hom_comp_assoc, ← Functor.map_comp_assoc,\n          X.d_squared, Functor.map_zero, zero_comp] }\n  map f :=\n    { f := f.f⟦n⟧'\n      comm := by\n        dsimp\n        erw [Category.assoc, shiftComm_hom_comp, ← Functor.map_comp_assoc, f.comm,\n          Functor.map_comp_assoc]\n        rfl }\n  map_id X := by ext1; dsimp; rw [Functor.map_id]\n  map_comp f g := by ext1; dsimp; rw [Functor.map_comp]\n\n"}
{"name":"CategoryTheory.DifferentialObject.shiftFunctor_obj_obj","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝³ : AddCommGroupWithOne S\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\nn : S\nX : CategoryTheory.DifferentialObject S C\n⊢ Eq ((CategoryTheory.DifferentialObject.shiftFunctor C n).obj X).obj ((CategoryTheory.shiftFunctor C n).obj X.obj)","decl":"/-- The shift functor on `DifferentialObject S C`. -/\n@[simps]\ndef shiftFunctor (n : S) : DifferentialObject S C ⥤ DifferentialObject S C where\n  obj X :=\n    { obj := X.obj⟦n⟧\n      d := X.d⟦n⟧' ≫ (shiftComm _ _ _).hom\n      d_squared := by\n        rw [Functor.map_comp, Category.assoc, shiftComm_hom_comp_assoc, ← Functor.map_comp_assoc,\n          X.d_squared, Functor.map_zero, zero_comp] }\n  map f :=\n    { f := f.f⟦n⟧'\n      comm := by\n        dsimp\n        erw [Category.assoc, shiftComm_hom_comp, ← Functor.map_comp_assoc, f.comm,\n          Functor.map_comp_assoc]\n        rfl }\n  map_id X := by ext1; dsimp; rw [Functor.map_id]\n  map_comp f g := by ext1; dsimp; rw [Functor.map_comp]\n\n"}
{"name":"CategoryTheory.DifferentialObject.shiftFunctor_obj_d","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝³ : AddCommGroupWithOne S\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\nn : S\nX : CategoryTheory.DifferentialObject S C\n⊢ Eq ((CategoryTheory.DifferentialObject.shiftFunctor C n).obj X).d (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C n).map X.d) (CategoryTheory.shiftComm X.obj 1 n).hom)","decl":"/-- The shift functor on `DifferentialObject S C`. -/\n@[simps]\ndef shiftFunctor (n : S) : DifferentialObject S C ⥤ DifferentialObject S C where\n  obj X :=\n    { obj := X.obj⟦n⟧\n      d := X.d⟦n⟧' ≫ (shiftComm _ _ _).hom\n      d_squared := by\n        rw [Functor.map_comp, Category.assoc, shiftComm_hom_comp_assoc, ← Functor.map_comp_assoc,\n          X.d_squared, Functor.map_zero, zero_comp] }\n  map f :=\n    { f := f.f⟦n⟧'\n      comm := by\n        dsimp\n        erw [Category.assoc, shiftComm_hom_comp, ← Functor.map_comp_assoc, f.comm,\n          Functor.map_comp_assoc]\n        rfl }\n  map_id X := by ext1; dsimp; rw [Functor.map_id]\n  map_comp f g := by ext1; dsimp; rw [Functor.map_comp]\n\n"}
{"name":"CategoryTheory.DifferentialObject.shiftFunctorAdd_hom_app_f","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝³ : AddCommGroupWithOne S\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\nm n : S\nX : CategoryTheory.DifferentialObject S C\n⊢ Eq ((CategoryTheory.DifferentialObject.shiftFunctorAdd C m n).hom.app X).f ((CategoryTheory.shiftFunctorAdd C m n).hom.app X.obj)","decl":"/-- The shift functor on `DifferentialObject S C` is additive. -/\n@[simps!]\nnonrec def shiftFunctorAdd (m n : S) :\n    shiftFunctor C (m + n) ≅ shiftFunctor C m ⋙ shiftFunctor C n := by\n  refine NatIso.ofComponents (fun X => mkIso (shiftAdd X.obj _ _) ?_) (fun f => ?_)\n  · dsimp\n    rw [← cancel_epi ((shiftFunctorAdd C m n).inv.app X.obj)]\n    simp only [Category.assoc, Iso.inv_hom_id_app_assoc]\n    rw [← NatTrans.naturality_assoc]\n    dsimp\n    simp only [Functor.map_comp, Category.assoc,\n      shiftFunctorComm_hom_app_comp_shift_shiftFunctorAdd_hom_app 1 m n X.obj,\n      Iso.inv_hom_id_app_assoc]\n  · ext; dsimp; exact NatTrans.naturality _ _\n\n"}
{"name":"CategoryTheory.DifferentialObject.shiftFunctorAdd_inv_app_f","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝³ : AddCommGroupWithOne S\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\nm n : S\nX : CategoryTheory.DifferentialObject S C\n⊢ Eq ((CategoryTheory.DifferentialObject.shiftFunctorAdd C m n).inv.app X).f ((CategoryTheory.shiftFunctorAdd C m n).inv.app X.obj)","decl":"/-- The shift functor on `DifferentialObject S C` is additive. -/\n@[simps!]\nnonrec def shiftFunctorAdd (m n : S) :\n    shiftFunctor C (m + n) ≅ shiftFunctor C m ⋙ shiftFunctor C n := by\n  refine NatIso.ofComponents (fun X => mkIso (shiftAdd X.obj _ _) ?_) (fun f => ?_)\n  · dsimp\n    rw [← cancel_epi ((shiftFunctorAdd C m n).inv.app X.obj)]\n    simp only [Category.assoc, Iso.inv_hom_id_app_assoc]\n    rw [← NatTrans.naturality_assoc]\n    dsimp\n    simp only [Functor.map_comp, Category.assoc,\n      shiftFunctorComm_hom_app_comp_shift_shiftFunctorAdd_hom_app 1 m n X.obj,\n      Iso.inv_hom_id_app_assoc]\n  · ext; dsimp; exact NatTrans.naturality _ _\n\n"}
{"name":"CategoryTheory.DifferentialObject.shiftZero_inv_app_f","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝³ : AddCommGroupWithOne S\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\nX : CategoryTheory.DifferentialObject S C\n⊢ Eq ((CategoryTheory.DifferentialObject.shiftZero C).inv.app X).f ((CategoryTheory.shiftFunctorZero C S).inv.app X.obj)","decl":"/-- The shift by zero is naturally isomorphic to the identity. -/\n@[simps!]\ndef shiftZero : shiftFunctor C (0 : S) ≅ 𝟭 (DifferentialObject S C) := by\n  refine NatIso.ofComponents (fun X => mkIso ((shiftFunctorZero C S).app X.obj) ?_) (fun f => ?_)\n  · erw [← NatTrans.naturality]\n    dsimp\n    simp only [shiftFunctorZero_hom_app_shift, Category.assoc]\n  · aesop_cat\n\n"}
{"name":"CategoryTheory.DifferentialObject.shiftZero_hom_app_f","module":"Mathlib.CategoryTheory.DifferentialObject","initialProofState":"S : Type u_1\ninst✝³ : AddCommGroupWithOne S\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.HasShift C S\nX : CategoryTheory.DifferentialObject S C\n⊢ Eq ((CategoryTheory.DifferentialObject.shiftZero C).hom.app X).f ((CategoryTheory.shiftFunctorZero C S).hom.app X.obj)","decl":"/-- The shift by zero is naturally isomorphic to the identity. -/\n@[simps!]\ndef shiftZero : shiftFunctor C (0 : S) ≅ 𝟭 (DifferentialObject S C) := by\n  refine NatIso.ofComponents (fun X => mkIso ((shiftFunctorZero C S).app X.obj) ?_) (fun f => ?_)\n  · erw [← NatTrans.naturality]\n    dsimp\n    simp only [shiftFunctorZero_hom_app_shift, Category.assoc]\n  · aesop_cat\n\n"}
