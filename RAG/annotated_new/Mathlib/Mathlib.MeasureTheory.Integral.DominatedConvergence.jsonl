{"name":"MeasureTheory.tendsto_integral_of_dominated_convergence","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"Î± : Type u_1\nG : Type u_3\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nF : Nat â†’ Î± â†’ G\nf : Î± â†’ G\nbound : Î± â†’ Real\nF_measurable : âˆ€ (n : Nat), MeasureTheory.AEStronglyMeasurable (F n) Î¼\nbound_integrable : MeasureTheory.Integrable bound Î¼\nh_bound : âˆ€ (n : Nat), Filter.Eventually (fun a => LE.le (Norm.norm (F n a)) (bound a)) (MeasureTheory.ae Î¼)\nh_lim : Filter.Eventually (fun a => Filter.Tendsto (fun n => F n a) Filter.atTop (nhds (f a))) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Tendsto (fun n => MeasureTheory.integral Î¼ fun a => F n a) Filter.atTop (nhds (MeasureTheory.integral Î¼ fun a => f a))","decl":"/-- **Lebesgue dominated convergence theorem** provides sufficient conditions under which almost\n  everywhere convergence of a sequence of functions implies the convergence of their integrals.\n  We could weaken the condition `bound_integrable` to require `HasFiniteIntegral bound Î¼` instead\n  (i.e. not requiring that `bound` is measurable), but in all applications proving integrability\n  is easier. -/\ntheorem tendsto_integral_of_dominated_convergence {F : â„• â†’ Î± â†’ G} {f : Î± â†’ G} (bound : Î± â†’ â„)\n    (F_measurable : âˆ€ n, AEStronglyMeasurable (F n) Î¼) (bound_integrable : Integrable bound Î¼)\n    (h_bound : âˆ€ n, âˆ€áµ a âˆ‚Î¼, â€–F n aâ€– â‰¤ bound a)\n    (h_lim : âˆ€áµ a âˆ‚Î¼, Tendsto (fun n => F n a) atTop (ğ“ (f a))) :\n    Tendsto (fun n => âˆ« a, F n a âˆ‚Î¼) atTop (ğ“ <| âˆ« a, f a âˆ‚Î¼) := by\n  by_cases hG : CompleteSpace G\n  Â· simp only [integral, hG, L1.integral]\n    exact tendsto_setToFun_of_dominated_convergence (dominatedFinMeasAdditive_weightedSMul Î¼)\n      bound F_measurable bound_integrable h_bound h_lim\n  Â· simp [integral, hG]\n\n"}
{"name":"MeasureTheory.tendsto_integral_filter_of_dominated_convergence","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"Î± : Type u_1\nG : Type u_3\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ¹ : Type u_4\nl : Filter Î¹\ninstâœ : l.IsCountablyGenerated\nF : Î¹ â†’ Î± â†’ G\nf : Î± â†’ G\nbound : Î± â†’ Real\nhF_meas : Filter.Eventually (fun n => MeasureTheory.AEStronglyMeasurable (F n) Î¼) l\nh_bound : Filter.Eventually (fun n => Filter.Eventually (fun a => LE.le (Norm.norm (F n a)) (bound a)) (MeasureTheory.ae Î¼)) l\nbound_integrable : MeasureTheory.Integrable bound Î¼\nh_lim : Filter.Eventually (fun a => Filter.Tendsto (fun n => F n a) l (nhds (f a))) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Tendsto (fun n => MeasureTheory.integral Î¼ fun a => F n a) l (nhds (MeasureTheory.integral Î¼ fun a => f a))","decl":"/-- Lebesgue dominated convergence theorem for filters with a countable basis -/\ntheorem tendsto_integral_filter_of_dominated_convergence {Î¹} {l : Filter Î¹} [l.IsCountablyGenerated]\n    {F : Î¹ â†’ Î± â†’ G} {f : Î± â†’ G} (bound : Î± â†’ â„) (hF_meas : âˆ€á¶  n in l, AEStronglyMeasurable (F n) Î¼)\n    (h_bound : âˆ€á¶  n in l, âˆ€áµ a âˆ‚Î¼, â€–F n aâ€– â‰¤ bound a) (bound_integrable : Integrable bound Î¼)\n    (h_lim : âˆ€áµ a âˆ‚Î¼, Tendsto (fun n => F n a) l (ğ“ (f a))) :\n    Tendsto (fun n => âˆ« a, F n a âˆ‚Î¼) l (ğ“ <| âˆ« a, f a âˆ‚Î¼) := by\n  by_cases hG : CompleteSpace G\n  Â· simp only [integral, hG, L1.integral]\n    exact tendsto_setToFun_filter_of_dominated_convergence (dominatedFinMeasAdditive_weightedSMul Î¼)\n      bound hF_meas h_bound bound_integrable h_lim\n  Â· simp [integral, hG, tendsto_const_nhds]\n\n"}
{"name":"MeasureTheory.hasSum_integral_of_dominated_convergence","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"Î± : Type u_1\nG : Type u_3\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ¹ : Type u_4\ninstâœ : Countable Î¹\nF : Î¹ â†’ Î± â†’ G\nf : Î± â†’ G\nbound : Î¹ â†’ Î± â†’ Real\nhF_meas : âˆ€ (n : Î¹), MeasureTheory.AEStronglyMeasurable (F n) Î¼\nh_bound : âˆ€ (n : Î¹), Filter.Eventually (fun a => LE.le (Norm.norm (F n a)) (bound n a)) (MeasureTheory.ae Î¼)\nbound_summable : Filter.Eventually (fun a => Summable fun n => bound n a) (MeasureTheory.ae Î¼)\nbound_integrable : MeasureTheory.Integrable (fun a => tsum fun n => bound n a) Î¼\nh_lim : Filter.Eventually (fun a => HasSum (fun n => F n a) (f a)) (MeasureTheory.ae Î¼)\nâŠ¢ HasSum (fun n => MeasureTheory.integral Î¼ fun a => F n a) (MeasureTheory.integral Î¼ fun a => f a)","decl":"/-- Lebesgue dominated convergence theorem for series. -/\ntheorem hasSum_integral_of_dominated_convergence {Î¹} [Countable Î¹] {F : Î¹ â†’ Î± â†’ G} {f : Î± â†’ G}\n    (bound : Î¹ â†’ Î± â†’ â„) (hF_meas : âˆ€ n, AEStronglyMeasurable (F n) Î¼)\n    (h_bound : âˆ€ n, âˆ€áµ a âˆ‚Î¼, â€–F n aâ€– â‰¤ bound n a)\n    (bound_summable : âˆ€áµ a âˆ‚Î¼, Summable fun n => bound n a)\n    (bound_integrable : Integrable (fun a => âˆ‘' n, bound n a) Î¼)\n    (h_lim : âˆ€áµ a âˆ‚Î¼, HasSum (fun n => F n a) (f a)) :\n    HasSum (fun n => âˆ« a, F n a âˆ‚Î¼) (âˆ« a, f a âˆ‚Î¼) := by\n  have hb_nonneg : âˆ€áµ a âˆ‚Î¼, âˆ€ n, 0 â‰¤ bound n a :=\n    eventually_countable_forall.2 fun n => (h_bound n).mono fun a => (norm_nonneg _).trans\n  have hb_le_tsum : âˆ€ n, bound n â‰¤áµ[Î¼] fun a => âˆ‘' n, bound n a := by\n    intro n\n    filter_upwards [hb_nonneg, bound_summable]\n      with _ ha0 ha_sum using le_tsum ha_sum _ fun i _ => ha0 i\n  have hF_integrable : âˆ€ n, Integrable (F n) Î¼ := by\n    refine fun n => bound_integrable.mono' (hF_meas n) ?_\n    exact EventuallyLE.trans (h_bound n) (hb_le_tsum n)\n  simp only [HasSum, â† integral_finset_sum _ fun n _ => hF_integrable n]\n  refine tendsto_integral_filter_of_dominated_convergence\n      (fun a => âˆ‘' n, bound n a) ?_ ?_ bound_integrable h_lim\n  Â· exact Eventually.of_forall fun s => s.aestronglyMeasurable_sum fun n _ => hF_meas n\n  Â· filter_upwards with s\n    filter_upwards [eventually_countable_forall.2 h_bound, hb_nonneg, bound_summable]\n      with a hFa ha0 has\n    calc\n      â€–âˆ‘ n âˆˆ s, F n aâ€– â‰¤ âˆ‘ n âˆˆ s, bound n a := norm_sum_le_of_le _ fun n _ => hFa n\n      _ â‰¤ âˆ‘' n, bound n a := sum_le_tsum _ (fun n _ => ha0 n) has\n\n"}
{"name":"MeasureTheory.integral_tsum","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"Î± : Type u_1\nG : Type u_3\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ¹ : Type u_4\ninstâœ : Countable Î¹\nf : Î¹ â†’ Î± â†’ G\nhf : âˆ€ (i : Î¹), MeasureTheory.AEStronglyMeasurable (f i) Î¼\nhf' : Ne (tsum fun i => MeasureTheory.lintegral Î¼ fun a => ENorm.enorm (f i a)) Top.top\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun a => tsum fun i => f i a) (tsum fun i => MeasureTheory.integral Î¼ fun a => f i a)","decl":"theorem integral_tsum {Î¹} [Countable Î¹] {f : Î¹ â†’ Î± â†’ G} (hf : âˆ€ i, AEStronglyMeasurable (f i) Î¼)\n    (hf' : âˆ‘' i, âˆ«â» a : Î±, â€–f i aâ€–â‚‘ âˆ‚Î¼ â‰  âˆ) :\n    âˆ« a : Î±, âˆ‘' i, f i a âˆ‚Î¼ = âˆ‘' i, âˆ« a : Î±, f i a âˆ‚Î¼ := by\n  by_cases hG : CompleteSpace G; swap\n  Â· simp [integral, hG]\n  have hf'' i : AEMeasurable (â€–f i Â·â€–â‚‘) Î¼ := (hf i).enorm\n  have hhh : âˆ€áµ a : Î± âˆ‚Î¼, Summable fun n => (â€–f n aâ€–â‚Š : â„) := by\n    rw [â† lintegral_tsum hf''] at hf'\n    refine (ae_lt_top' (AEMeasurable.ennreal_tsum hf'') hf').mono ?_\n    intro x hx\n    rw [â† ENNReal.tsum_coe_ne_top_iff_summable_coe]\n    exact hx.ne\n  convert (MeasureTheory.hasSum_integral_of_dominated_convergence (fun i a => â€–f i aâ€–â‚Š) hf _ hhh\n          âŸ¨_, _âŸ© _).tsum_eq.symm\n  Â· intro n\n    filter_upwards with x\n    rfl\n  Â· simp_rw [â† NNReal.coe_tsum]\n    rw [aestronglyMeasurable_iff_aemeasurable]\n    apply AEMeasurable.coe_nnreal_real\n    apply AEMeasurable.nnreal_tsum\n    exact fun i => (hf i).nnnorm.aemeasurable\n  Â· dsimp [HasFiniteIntegral]\n    have : âˆ«â» a, âˆ‘' n, â€–f n aâ€–â‚‘ âˆ‚Î¼ < âŠ¤ := by rwa [lintegral_tsum hf'', lt_top_iff_ne_top]\n    convert this using 1\n    apply lintegral_congr_ae\n    simp_rw [â† coe_nnnorm, â† NNReal.coe_tsum, enorm_eq_nnnorm, NNReal.nnnorm_eq]\n    filter_upwards [hhh] with a ha\n    exact ENNReal.coe_tsum (NNReal.summable_coe.mp ha)\n  Â· filter_upwards [hhh] with x hx\n    exact hx.of_norm.hasSum\n\n"}
{"name":"MeasureTheory.hasSum_integral_of_summable_integral_norm","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ¹ : Type u_4\ninstâœ : Countable Î¹\nF : Î¹ â†’ Î± â†’ E\nhF_int : âˆ€ (i : Î¹), MeasureTheory.Integrable (F i) Î¼\nhF_sum : Summable fun i => MeasureTheory.integral Î¼ fun a => Norm.norm (F i a)\nâŠ¢ HasSum (fun x => MeasureTheory.integral Î¼ fun a => F x a) (MeasureTheory.integral Î¼ fun a => tsum fun i => F i a)","decl":"lemma hasSum_integral_of_summable_integral_norm {Î¹} [Countable Î¹] {F : Î¹ â†’ Î± â†’ E}\n    (hF_int : âˆ€ i : Î¹, Integrable (F i) Î¼) (hF_sum : Summable fun i â†¦ âˆ« a, â€–F i aâ€– âˆ‚Î¼) :\n    HasSum (âˆ« a, F Â· a âˆ‚Î¼) (âˆ« a, (âˆ‘' i, F i a) âˆ‚Î¼) := by\n  by_cases hE : CompleteSpace E; swap\n  Â· simp [integral, hE, hasSum_zero]\n  rw [integral_tsum (fun i â†¦ (hF_int i).1)]\n  Â· exact (hF_sum.of_norm_bounded _ fun i â†¦ norm_integral_le_integral_norm _).hasSum\n  have (i : Î¹) : âˆ«â» a, â€–F i aâ€–â‚‘ âˆ‚Î¼ = â€–âˆ« a, â€–F i aâ€– âˆ‚Î¼â€–â‚‘ := by\n    dsimp [enorm]\n    rw [lintegral_coe_eq_integral _ (hF_int i).norm, coe_nnreal_eq, coe_nnnorm,\n      Real.norm_of_nonneg (integral_nonneg (fun a â†¦ norm_nonneg (F i a)))]\n    simp only [coe_nnnorm]\n  rw [funext this]\n  exact ENNReal.tsum_coe_ne_top_iff_summable.2 <| NNReal.summable_coe.1 hF_sum.abs\n\n"}
{"name":"MeasureTheory.integral_tsum_of_summable_integral_norm","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ¹ : Type u_4\ninstâœ : Countable Î¹\nF : Î¹ â†’ Î± â†’ E\nhF_int : âˆ€ (i : Î¹), MeasureTheory.Integrable (F i) Î¼\nhF_sum : Summable fun i => MeasureTheory.integral Î¼ fun a => Norm.norm (F i a)\nâŠ¢ Eq (tsum fun i => MeasureTheory.integral Î¼ fun a => F i a) (MeasureTheory.integral Î¼ fun a => tsum fun i => F i a)","decl":"lemma integral_tsum_of_summable_integral_norm {Î¹} [Countable Î¹] {F : Î¹ â†’ Î± â†’ E}\n    (hF_int : âˆ€ i : Î¹, Integrable (F i) Î¼) (hF_sum : Summable fun i â†¦ âˆ« a, â€–F i aâ€– âˆ‚Î¼) :\n    âˆ‘' i, (âˆ« a, F i a âˆ‚Î¼) = âˆ« a, (âˆ‘' i, F i a) âˆ‚Î¼ :=\n  (hasSum_integral_of_summable_integral_norm hF_int hF_sum).tsum_eq\n\n"}
{"name":"Antitone.tendsto_setIntegral","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ² : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\ns : Nat â†’ Set Î±\nf : Î± â†’ E\nhsm : âˆ€ (i : Nat), MeasurableSet (s i)\nh_anti : Antitone s\nhfi : MeasureTheory.IntegrableOn f (s 0) Î¼\nâŠ¢ Filter.Tendsto (fun i => MeasureTheory.integral (Î¼.restrict (s i)) fun a => f a) Filter.atTop (nhds (MeasureTheory.integral (Î¼.restrict (Set.iInter fun n => s n)) fun a => f a))","decl":"theorem _root_.Antitone.tendsto_setIntegral (hsm : âˆ€ i, MeasurableSet (s i)) (h_anti : Antitone s)\n    (hfi : IntegrableOn f (s 0) Î¼) :\n    Tendsto (fun i => âˆ« a in s i, f a âˆ‚Î¼) atTop (ğ“ (âˆ« a in â‹‚ n, s n, f a âˆ‚Î¼)) := by\n  let bound : Î± â†’ â„ := indicator (s 0) fun a => â€–f aâ€–\n  have h_int_eq : (fun i => âˆ« a in s i, f a âˆ‚Î¼) = fun i => âˆ« a, (s i).indicator f a âˆ‚Î¼ :=\n    funext fun i => (integral_indicator (hsm i)).symm\n  rw [h_int_eq]\n  rw [â† integral_indicator (MeasurableSet.iInter hsm)]\n  refine tendsto_integral_of_dominated_convergence bound ?_ ?_ ?_ ?_\n  Â· intro n\n    rw [aestronglyMeasurable_indicator_iff (hsm n)]\n    exact (IntegrableOn.mono_set hfi (h_anti (zero_le n))).1\n  Â· rw [integrable_indicator_iff (hsm 0)]\n    exact hfi.norm\n  Â· simp_rw [norm_indicator_eq_indicator_norm]\n    refine fun n => Eventually.of_forall fun x => ?_\n    exact indicator_le_indicator_of_subset (h_anti (zero_le n)) (fun a => norm_nonneg _) _\n  Â· filter_upwards [] with a using le_trans (h_anti.tendsto_indicator _ _ _) (pure_le_nhds _)\n\n"}
{"name":"intervalIntegral.tendsto_integral_filter_of_dominated_convergence","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\na b : Real\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\nÎ¹ : Type u_3\nl : Filter Î¹\ninstâœ : l.IsCountablyGenerated\nF : Î¹ â†’ Real â†’ E\nbound : Real â†’ Real\nhF_meas : Filter.Eventually (fun n => MeasureTheory.AEStronglyMeasurable (F n) (Î¼.restrict (Set.uIoc a b))) l\nh_bound : Filter.Eventually (fun n => Filter.Eventually (fun x => Membership.mem (Set.uIoc a b) x â†’ LE.le (Norm.norm (F n x)) (bound x)) (MeasureTheory.ae Î¼)) l\nbound_integrable : IntervalIntegrable bound Î¼ a b\nh_lim : Filter.Eventually (fun x => Membership.mem (Set.uIoc a b) x â†’ Filter.Tendsto (fun n => F n x) l (nhds (f x))) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Tendsto (fun n => intervalIntegral (fun x => F n x) a b Î¼) l (nhds (intervalIntegral (fun x => f x) a b Î¼))","decl":"/-- Lebesgue dominated convergence theorem for filters with a countable basis -/\nnonrec theorem tendsto_integral_filter_of_dominated_convergence {Î¹} {l : Filter Î¹}\n    [l.IsCountablyGenerated] {F : Î¹ â†’ â„ â†’ E} (bound : â„ â†’ â„)\n    (hF_meas : âˆ€á¶  n in l, AEStronglyMeasurable (F n) (Î¼.restrict (Î™ a b)))\n    (h_bound : âˆ€á¶  n in l, âˆ€áµ x âˆ‚Î¼, x âˆˆ Î™ a b â†’ â€–F n xâ€– â‰¤ bound x)\n    (bound_integrable : IntervalIntegrable bound Î¼ a b)\n    (h_lim : âˆ€áµ x âˆ‚Î¼, x âˆˆ Î™ a b â†’ Tendsto (fun n => F n x) l (ğ“ (f x))) :\n    Tendsto (fun n => âˆ« x in a..b, F n x âˆ‚Î¼) l (ğ“ <| âˆ« x in a..b, f x âˆ‚Î¼) := by\n  simp only [intervalIntegrable_iff, intervalIntegral_eq_integral_uIoc,\n    â† ae_restrict_iff' (Î± := â„) (Î¼ := Î¼) measurableSet_uIoc] at *\n  exact tendsto_const_nhds.smul <|\n    tendsto_integral_filter_of_dominated_convergence bound hF_meas h_bound bound_integrable h_lim\n\n"}
{"name":"intervalIntegral.hasSum_integral_of_dominated_convergence","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\na b : Real\nf : Real â†’ E\nÎ¼ : MeasureTheory.Measure Real\nÎ¹ : Type u_3\ninstâœ : Countable Î¹\nF : Î¹ â†’ Real â†’ E\nbound : Î¹ â†’ Real â†’ Real\nhF_meas : âˆ€ (n : Î¹), MeasureTheory.AEStronglyMeasurable (F n) (Î¼.restrict (Set.uIoc a b))\nh_bound : âˆ€ (n : Î¹), Filter.Eventually (fun t => Membership.mem (Set.uIoc a b) t â†’ LE.le (Norm.norm (F n t)) (bound n t)) (MeasureTheory.ae Î¼)\nbound_summable : Filter.Eventually (fun t => Membership.mem (Set.uIoc a b) t â†’ Summable fun n => bound n t) (MeasureTheory.ae Î¼)\nbound_integrable : IntervalIntegrable (fun t => tsum fun n => bound n t) Î¼ a b\nh_lim : Filter.Eventually (fun t => Membership.mem (Set.uIoc a b) t â†’ HasSum (fun n => F n t) (f t)) (MeasureTheory.ae Î¼)\nâŠ¢ HasSum (fun n => intervalIntegral (fun t => F n t) a b Î¼) (intervalIntegral (fun t => f t) a b Î¼)","decl":"/-- Lebesgue dominated convergence theorem for parametric interval integrals. -/\nnonrec theorem hasSum_integral_of_dominated_convergence {Î¹} [Countable Î¹] {F : Î¹ â†’ â„ â†’ E}\n    (bound : Î¹ â†’ â„ â†’ â„) (hF_meas : âˆ€ n, AEStronglyMeasurable (F n) (Î¼.restrict (Î™ a b)))\n    (h_bound : âˆ€ n, âˆ€áµ t âˆ‚Î¼, t âˆˆ Î™ a b â†’ â€–F n tâ€– â‰¤ bound n t)\n    (bound_summable : âˆ€áµ t âˆ‚Î¼, t âˆˆ Î™ a b â†’ Summable fun n => bound n t)\n    (bound_integrable : IntervalIntegrable (fun t => âˆ‘' n, bound n t) Î¼ a b)\n    (h_lim : âˆ€áµ t âˆ‚Î¼, t âˆˆ Î™ a b â†’ HasSum (fun n => F n t) (f t)) :\n    HasSum (fun n => âˆ« t in a..b, F n t âˆ‚Î¼) (âˆ« t in a..b, f t âˆ‚Î¼) := by\n  simp only [intervalIntegrable_iff, intervalIntegral_eq_integral_uIoc, â†\n    ae_restrict_iff' (Î± := â„) (Î¼ := Î¼) measurableSet_uIoc] at *\n  exact\n    (hasSum_integral_of_dominated_convergence bound hF_meas h_bound bound_summable bound_integrable\n          h_lim).const_smul\n      _\n\n"}
{"name":"intervalIntegral.hasSum_intervalIntegral_of_summable_norm","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"Î¹ : Type u_1\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\na b : Real\ninstâœ : Countable Î¹\nf : Î¹ â†’ ContinuousMap Real E\nhf_sum : Summable fun i => Norm.norm (ContinuousMap.restrict (â†‘{ carrier := Set.uIcc a b, isCompact' := â‹¯ }) (f i))\nâŠ¢ HasSum (fun i => intervalIntegral (fun x => (f i) x) a b MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => tsum fun i => (f i) x) a b MeasureTheory.MeasureSpace.volume)","decl":"/-- Interval integrals commute with countable sums, when the supremum norms are summable (a\nspecial case of the dominated convergence theorem). -/\ntheorem hasSum_intervalIntegral_of_summable_norm [Countable Î¹] {f : Î¹ â†’ C(â„, E)}\n    (hf_sum : Summable fun i : Î¹ => â€–(f i).restrict (âŸ¨uIcc a b, isCompact_uIccâŸ© : Compacts â„)â€–) :\n    HasSum (fun i : Î¹ => âˆ« x in a..b, f i x) (âˆ« x in a..b, âˆ‘' i : Î¹, f i x) := by\n  by_cases hE : CompleteSpace E; swap\n  Â· simp [intervalIntegral, integral, hE, hasSum_zero]\n  apply hasSum_integral_of_dominated_convergence\n    (fun i (x : â„) => â€–(f i).restrict â†‘(âŸ¨uIcc a b, isCompact_uIccâŸ© : Compacts â„)â€–)\n    (fun i => (map_continuous <| f i).aestronglyMeasurable)\n  Â· intro i; filter_upwards with x hx\n    apply ContinuousMap.norm_coe_le_norm ((f i).restrict _) âŸ¨x, _âŸ©\n    exact âŸ¨hx.1.le, hx.2âŸ©\n  Â· exact ae_of_all _ fun x _ => hf_sum\n  Â· exact intervalIntegrable_const\n  Â· refine ae_of_all _ fun x hx => Summable.hasSum ?_\n    let x : (âŸ¨uIcc a b, isCompact_uIccâŸ© : Compacts â„) := âŸ¨x, âŸ¨hx.1.le, hx.2âŸ©âŸ©\n    have := hf_sum.of_norm\n    simpa only [Compacts.coe_mk, ContinuousMap.restrict_apply]\n      using ContinuousMap.summable_apply this x\n\n"}
{"name":"intervalIntegral.tsum_intervalIntegral_eq_of_summable_norm","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"Î¹ : Type u_1\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\na b : Real\ninstâœ : Countable Î¹\nf : Î¹ â†’ ContinuousMap Real E\nhf_sum : Summable fun i => Norm.norm (ContinuousMap.restrict (â†‘{ carrier := Set.uIcc a b, isCompact' := â‹¯ }) (f i))\nâŠ¢ Eq (tsum fun i => intervalIntegral (fun x => (f i) x) a b MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => tsum fun i => (f i) x) a b MeasureTheory.MeasureSpace.volume)","decl":"theorem tsum_intervalIntegral_eq_of_summable_norm [Countable Î¹] {f : Î¹ â†’ C(â„, E)}\n    (hf_sum : Summable fun i : Î¹ => â€–(f i).restrict (âŸ¨uIcc a b, isCompact_uIccâŸ© : Compacts â„)â€–) :\n    âˆ‘' i : Î¹, âˆ« x in a..b, f i x = âˆ« x in a..b, âˆ‘' i : Î¹, f i x :=\n  (hasSum_intervalIntegral_of_summable_norm hf_sum).tsum_eq\n\n"}
{"name":"intervalIntegral.continuousWithinAt_of_dominated_interval","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\nÎ¼ : MeasureTheory.Measure Real\nX : Type u_3\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : FirstCountableTopology X\nF : X â†’ Real â†’ E\nxâ‚€ : X\nbound : Real â†’ Real\na b : Real\ns : Set X\nhF_meas : Filter.Eventually (fun x => MeasureTheory.AEStronglyMeasurable (F x) (Î¼.restrict (Set.uIoc a b))) (nhdsWithin xâ‚€ s)\nh_bound : Filter.Eventually (fun x => Filter.Eventually (fun t => Membership.mem (Set.uIoc a b) t â†’ LE.le (Norm.norm (F x t)) (bound t)) (MeasureTheory.ae Î¼)) (nhdsWithin xâ‚€ s)\nbound_integrable : IntervalIntegrable bound Î¼ a b\nh_cont : Filter.Eventually (fun t => Membership.mem (Set.uIoc a b) t â†’ ContinuousWithinAt (fun x => F x t) s xâ‚€) (MeasureTheory.ae Î¼)\nâŠ¢ ContinuousWithinAt (fun x => intervalIntegral (fun t => F x t) a b Î¼) s xâ‚€","decl":"/-- Continuity of interval integral with respect to a parameter, at a point within a set.\n  Given `F : X â†’ â„ â†’ E`, assume `F x` is ae-measurable on `[a, b]` for `x` in a\n  neighborhood of `xâ‚€` within `s` and at `xâ‚€`, and assume it is bounded by a function integrable\n  on `[a, b]` independent of `x` in a neighborhood of `xâ‚€` within `s`. If `(fun x â†¦ F x t)`\n  is continuous at `xâ‚€` within `s` for almost every `t` in `[a, b]`\n  then the same holds for `(fun x â†¦ âˆ« t in a..b, F x t âˆ‚Î¼) s xâ‚€`. -/\ntheorem continuousWithinAt_of_dominated_interval {F : X â†’ â„ â†’ E} {xâ‚€ : X} {bound : â„ â†’ â„} {a b : â„}\n    {s : Set X} (hF_meas : âˆ€á¶  x in ğ“[s] xâ‚€, AEStronglyMeasurable (F x) (Î¼.restrict <| Î™ a b))\n    (h_bound : âˆ€á¶  x in ğ“[s] xâ‚€, âˆ€áµ t âˆ‚Î¼, t âˆˆ Î™ a b â†’ â€–F x tâ€– â‰¤ bound t)\n    (bound_integrable : IntervalIntegrable bound Î¼ a b)\n    (h_cont : âˆ€áµ t âˆ‚Î¼, t âˆˆ Î™ a b â†’ ContinuousWithinAt (fun x => F x t) s xâ‚€) :\n    ContinuousWithinAt (fun x => âˆ« t in a..b, F x t âˆ‚Î¼) s xâ‚€ :=\n  tendsto_integral_filter_of_dominated_convergence bound hF_meas h_bound bound_integrable h_cont\n\n"}
{"name":"intervalIntegral.continuousAt_of_dominated_interval","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\nÎ¼ : MeasureTheory.Measure Real\nX : Type u_3\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : FirstCountableTopology X\nF : X â†’ Real â†’ E\nxâ‚€ : X\nbound : Real â†’ Real\na b : Real\nhF_meas : Filter.Eventually (fun x => MeasureTheory.AEStronglyMeasurable (F x) (Î¼.restrict (Set.uIoc a b))) (nhds xâ‚€)\nh_bound : Filter.Eventually (fun x => Filter.Eventually (fun t => Membership.mem (Set.uIoc a b) t â†’ LE.le (Norm.norm (F x t)) (bound t)) (MeasureTheory.ae Î¼)) (nhds xâ‚€)\nbound_integrable : IntervalIntegrable bound Î¼ a b\nh_cont : Filter.Eventually (fun t => Membership.mem (Set.uIoc a b) t â†’ ContinuousAt (fun x => F x t) xâ‚€) (MeasureTheory.ae Î¼)\nâŠ¢ ContinuousAt (fun x => intervalIntegral (fun t => F x t) a b Î¼) xâ‚€","decl":"/-- Continuity of interval integral with respect to a parameter at a point.\n  Given `F : X â†’ â„ â†’ E`, assume `F x` is ae-measurable on `[a, b]` for `x` in a\n  neighborhood of `xâ‚€`, and assume it is bounded by a function integrable on\n  `[a, b]` independent of `x` in a neighborhood of `xâ‚€`. If `(fun x â†¦ F x t)`\n  is continuous at `xâ‚€` for almost every `t` in `[a, b]`\n  then the same holds for `(fun x â†¦ âˆ« t in a..b, F x t âˆ‚Î¼) s xâ‚€`. -/\ntheorem continuousAt_of_dominated_interval {F : X â†’ â„ â†’ E} {xâ‚€ : X} {bound : â„ â†’ â„} {a b : â„}\n    (hF_meas : âˆ€á¶  x in ğ“ xâ‚€, AEStronglyMeasurable (F x) (Î¼.restrict <| Î™ a b))\n    (h_bound : âˆ€á¶  x in ğ“ xâ‚€, âˆ€áµ t âˆ‚Î¼, t âˆˆ Î™ a b â†’ â€–F x tâ€– â‰¤ bound t)\n    (bound_integrable : IntervalIntegrable bound Î¼ a b)\n    (h_cont : âˆ€áµ t âˆ‚Î¼, t âˆˆ Î™ a b â†’ ContinuousAt (fun x => F x t) xâ‚€) :\n    ContinuousAt (fun x => âˆ« t in a..b, F x t âˆ‚Î¼) xâ‚€ :=\n  tendsto_integral_filter_of_dominated_convergence bound hF_meas h_bound bound_integrable h_cont\n\n"}
{"name":"intervalIntegral.continuous_of_dominated_interval","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\nÎ¼ : MeasureTheory.Measure Real\nX : Type u_3\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : FirstCountableTopology X\nF : X â†’ Real â†’ E\nbound : Real â†’ Real\na b : Real\nhF_meas : âˆ€ (x : X), MeasureTheory.AEStronglyMeasurable (F x) (Î¼.restrict (Set.uIoc a b))\nh_bound : âˆ€ (x : X), Filter.Eventually (fun t => Membership.mem (Set.uIoc a b) t â†’ LE.le (Norm.norm (F x t)) (bound t)) (MeasureTheory.ae Î¼)\nbound_integrable : IntervalIntegrable bound Î¼ a b\nh_cont : Filter.Eventually (fun t => Membership.mem (Set.uIoc a b) t â†’ Continuous fun x => F x t) (MeasureTheory.ae Î¼)\nâŠ¢ Continuous fun x => intervalIntegral (fun t => F x t) a b Î¼","decl":"/-- Continuity of interval integral with respect to a parameter.\n  Given `F : X â†’ â„ â†’ E`, assume each `F x` is ae-measurable on `[a, b]`,\n  and assume it is bounded by a function integrable on `[a, b]` independent of `x`.\n  If `(fun x â†¦ F x t)` is continuous for almost every `t` in `[a, b]`\n  then the same holds for `(fun x â†¦ âˆ« t in a..b, F x t âˆ‚Î¼) s xâ‚€`. -/\ntheorem continuous_of_dominated_interval {F : X â†’ â„ â†’ E} {bound : â„ â†’ â„} {a b : â„}\n    (hF_meas : âˆ€ x, AEStronglyMeasurable (F x) <| Î¼.restrict <| Î™ a b)\n    (h_bound : âˆ€ x, âˆ€áµ t âˆ‚Î¼, t âˆˆ Î™ a b â†’ â€–F x tâ€– â‰¤ bound t)\n    (bound_integrable : IntervalIntegrable bound Î¼ a b)\n    (h_cont : âˆ€áµ t âˆ‚Î¼, t âˆˆ Î™ a b â†’ Continuous fun x => F x t) :\n    Continuous fun x => âˆ« t in a..b, F x t âˆ‚Î¼ :=\n  continuous_iff_continuousAt.mpr fun _ =>\n    continuousAt_of_dominated_interval (Eventually.of_forall hF_meas) (Eventually.of_forall h_bound)\n        bound_integrable <|\n      h_cont.mono fun _ himp hx => (himp hx).continuousAt\n\n"}
{"name":"intervalIntegral.continuousWithinAt_primitive","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na bâ‚€ bâ‚ bâ‚‚ : Real\nÎ¼ : MeasureTheory.Measure Real\nf : Real â†’ E\nhbâ‚€ : Eq (Î¼ (Singleton.singleton bâ‚€)) 0\nh_int : IntervalIntegrable f Î¼ (Min.min a bâ‚) (Max.max a bâ‚‚)\nâŠ¢ ContinuousWithinAt (fun b => intervalIntegral (fun x => f x) a b Î¼) (Set.Icc bâ‚ bâ‚‚) bâ‚€","decl":"theorem continuousWithinAt_primitive (hbâ‚€ : Î¼ {bâ‚€} = 0)\n    (h_int : IntervalIntegrable f Î¼ (min a bâ‚) (max a bâ‚‚)) :\n    ContinuousWithinAt (fun b => âˆ« x in a..b, f x âˆ‚Î¼) (Icc bâ‚ bâ‚‚) bâ‚€ := by\n  by_cases hâ‚€ : bâ‚€ âˆˆ Icc bâ‚ bâ‚‚\n  Â· have hâ‚â‚‚ : bâ‚ â‰¤ bâ‚‚ := hâ‚€.1.trans hâ‚€.2\n    have minâ‚â‚‚ : min bâ‚ bâ‚‚ = bâ‚ := min_eq_left hâ‚â‚‚\n    have h_int' : âˆ€ {x}, x âˆˆ Icc bâ‚ bâ‚‚ â†’ IntervalIntegrable f Î¼ bâ‚ x := by\n      rintro x âŸ¨hâ‚, hâ‚‚âŸ©\n      apply h_int.mono_set\n      apply uIcc_subset_uIcc\n      Â· exact âŸ¨min_le_of_left_le (min_le_right a bâ‚),\n          hâ‚.trans (hâ‚‚.trans <| le_max_of_le_right <| le_max_right _ _)âŸ©\n      Â· exact âŸ¨min_le_of_left_le <| (min_le_right _ _).trans hâ‚,\n          le_max_of_le_right <| hâ‚‚.trans <| le_max_right _ _âŸ©\n    have : âˆ€ b âˆˆ Icc bâ‚ bâ‚‚,\n        âˆ« x in a..b, f x âˆ‚Î¼ = (âˆ« x in a..bâ‚, f x âˆ‚Î¼) + âˆ« x in bâ‚..b, f x âˆ‚Î¼ := by\n      rintro b âŸ¨hâ‚, hâ‚‚âŸ©\n      rw [â† integral_add_adjacent_intervals _ (h_int' âŸ¨hâ‚, hâ‚‚âŸ©)]\n      apply h_int.mono_set\n      apply uIcc_subset_uIcc\n      Â· exact âŸ¨min_le_of_left_le (min_le_left a bâ‚), le_max_of_le_right (le_max_left _ _)âŸ©\n      Â· exact âŸ¨min_le_of_left_le (min_le_right _ _),\n          le_max_of_le_right (hâ‚.trans <| hâ‚‚.trans (le_max_right a bâ‚‚))âŸ©\n    apply ContinuousWithinAt.congr _ this (this _ hâ‚€); clear this\n    refine continuousWithinAt_const.add ?_\n    have :\n      (fun b => âˆ« x in bâ‚..b, f x âˆ‚Î¼) =á¶ [ğ“[Icc bâ‚ bâ‚‚] bâ‚€] fun b =>\n        âˆ« x in bâ‚..bâ‚‚, indicator {x | x â‰¤ b} f x âˆ‚Î¼ := by\n      apply eventuallyEq_of_mem self_mem_nhdsWithin\n      exact fun b b_in => (integral_indicator b_in).symm\n    apply ContinuousWithinAt.congr_of_eventuallyEq _ this (integral_indicator hâ‚€).symm\n    have : IntervalIntegrable (fun x => â€–f xâ€–) Î¼ bâ‚ bâ‚‚ :=\n      IntervalIntegrable.norm (h_int' <| right_mem_Icc.mpr hâ‚â‚‚)\n    refine continuousWithinAt_of_dominated_interval ?_ ?_ this ?_ <;> clear this\n    Â· filter_upwards [self_mem_nhdsWithin]\n      intro x hx\n      erw [aestronglyMeasurable_indicator_iff, Measure.restrict_restrict, Iic_inter_Ioc_of_le]\n      Â· rw [minâ‚â‚‚]\n        exact (h_int' hx).1.aestronglyMeasurable\n      Â· exact le_max_of_le_right hx.2\n      exacts [measurableSet_Iic, measurableSet_Iic]\n    Â· filter_upwards with x; filter_upwards with t\n      dsimp [indicator]\n      split_ifs <;> simp\n    Â· have : âˆ€áµ t âˆ‚Î¼, t < bâ‚€ âˆ¨ bâ‚€ < t := by\n        filter_upwards [compl_mem_ae_iff.mpr hbâ‚€] with x hx using Ne.lt_or_lt hx\n      apply this.mono\n      rintro xâ‚€ (hxâ‚€ | hxâ‚€) -\n      Â· have : âˆ€á¶  x in ğ“[Icc bâ‚ bâ‚‚] bâ‚€, {t : â„ | t â‰¤ x}.indicator f xâ‚€ = f xâ‚€ := by\n          apply mem_nhdsWithin_of_mem_nhds\n          apply Eventually.mono (Ioi_mem_nhds hxâ‚€)\n          intro x hx\n          simp [hx.le]\n        apply continuousWithinAt_const.congr_of_eventuallyEq this\n        simp [hxâ‚€.le]\n      Â· have : âˆ€á¶  x in ğ“[Icc bâ‚ bâ‚‚] bâ‚€, {t : â„ | t â‰¤ x}.indicator f xâ‚€ = 0 := by\n          apply mem_nhdsWithin_of_mem_nhds\n          apply Eventually.mono (Iio_mem_nhds hxâ‚€)\n          intro x hx\n          simp [hx]\n        apply continuousWithinAt_const.congr_of_eventuallyEq this\n        simp [hxâ‚€]\n  Â· apply continuousWithinAt_of_not_mem_closure\n    rwa [closure_Icc]\n\n"}
{"name":"intervalIntegral.continuousAt_parametric_primitive_of_dominated","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_1\nX : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : TopologicalSpace X\nÎ¼ : MeasureTheory.Measure Real\ninstâœ : FirstCountableTopology X\nF : X â†’ Real â†’ E\nbound : Real â†’ Real\na b aâ‚€ bâ‚€ : Real\nxâ‚€ : X\nhF_meas : âˆ€ (x : X), MeasureTheory.AEStronglyMeasurable (F x) (Î¼.restrict (Set.uIoc a b))\nh_bound : Filter.Eventually (fun x => Filter.Eventually (fun t => LE.le (Norm.norm (F x t)) (bound t)) (MeasureTheory.ae (Î¼.restrict (Set.uIoc a b)))) (nhds xâ‚€)\nbound_integrable : IntervalIntegrable bound Î¼ a b\nh_cont : Filter.Eventually (fun t => ContinuousAt (fun x => F x t) xâ‚€) (MeasureTheory.ae (Î¼.restrict (Set.uIoc a b)))\nhaâ‚€ : Membership.mem (Set.Ioo a b) aâ‚€\nhbâ‚€ : Membership.mem (Set.Ioo a b) bâ‚€\nhÎ¼bâ‚€ : Eq (Î¼ (Singleton.singleton bâ‚€)) 0\nâŠ¢ ContinuousAt (fun p => intervalIntegral (fun t => F p.1 t) aâ‚€ p.2 Î¼) { fst := xâ‚€, snd := bâ‚€ }","decl":"theorem continuousAt_parametric_primitive_of_dominated [FirstCountableTopology X]\n    {F : X â†’ â„ â†’ E} (bound : â„ â†’ â„) (a b : â„)\n    {aâ‚€ bâ‚€ : â„} {xâ‚€ : X} (hF_meas : âˆ€ x, AEStronglyMeasurable (F x) (Î¼.restrict <| Î™ a b))\n    (h_bound : âˆ€á¶  x in ğ“ xâ‚€, âˆ€áµ t âˆ‚Î¼.restrict <| Î™ a b, â€–F x tâ€– â‰¤ bound t)\n    (bound_integrable : IntervalIntegrable bound Î¼ a b)\n    (h_cont : âˆ€áµ t âˆ‚Î¼.restrict <| Î™ a b, ContinuousAt (fun x â†¦ F x t) xâ‚€) (haâ‚€ : aâ‚€ âˆˆ Ioo a b)\n    (hbâ‚€ : bâ‚€ âˆˆ Ioo a b) (hÎ¼bâ‚€ : Î¼ {bâ‚€} = 0) :\n    ContinuousAt (fun p : X Ã— â„ â†¦ âˆ« t : â„ in aâ‚€..p.2, F p.1 t âˆ‚Î¼) (xâ‚€, bâ‚€) := by\n  have hsub : âˆ€ {aâ‚€ bâ‚€}, aâ‚€ âˆˆ Ioo a b â†’ bâ‚€ âˆˆ Ioo a b â†’ Î™ aâ‚€ bâ‚€ âŠ† Î™ a b := fun haâ‚€ hbâ‚€ â†¦\n    (ordConnected_Ioo.uIoc_subset haâ‚€ hbâ‚€).trans (Ioo_subset_Ioc_self.trans Ioc_subset_uIoc)\n  have Ioo_nhds : Ioo a b âˆˆ ğ“ bâ‚€ := Ioo_mem_nhds hbâ‚€.1 hbâ‚€.2\n  have Icc_nhds : Icc a b âˆˆ ğ“ bâ‚€ := Icc_mem_nhds hbâ‚€.1 hbâ‚€.2\n  have hxâ‚€ : âˆ€áµ t : â„ âˆ‚Î¼.restrict (Î™ a b), â€–F xâ‚€ tâ€– â‰¤ bound t := h_bound.self_of_nhds\n  have : âˆ€á¶  p : X Ã— â„ in ğ“ (xâ‚€, bâ‚€),\n      âˆ« s in aâ‚€..p.2, F p.1 s âˆ‚Î¼ =\n        âˆ« s in aâ‚€..bâ‚€, F p.1 s âˆ‚Î¼ + âˆ« s in bâ‚€..p.2, F xâ‚€ s âˆ‚Î¼ +\n          âˆ« s in bâ‚€..p.2, F p.1 s - F xâ‚€ s âˆ‚Î¼ := by\n    rw [nhds_prod_eq]\n    refine (h_bound.prod_mk Ioo_nhds).mono ?_\n    rintro âŸ¨x, tâŸ© âŸ¨hx : âˆ€áµ t : â„ âˆ‚Î¼.restrict (Î™ a b), â€–F x tâ€– â‰¤ bound t, ht : t âˆˆ Ioo a bâŸ©\n    dsimp\n    have hiF : âˆ€ {x aâ‚€ bâ‚€},\n        (âˆ€áµ t : â„ âˆ‚Î¼.restrict (Î™ a b), â€–F x tâ€– â‰¤ bound t) â†’ aâ‚€ âˆˆ Ioo a b â†’ bâ‚€ âˆˆ Ioo a b â†’\n          IntervalIntegrable (F x) Î¼ aâ‚€ bâ‚€ := fun {x aâ‚€ bâ‚€} hx haâ‚€ hbâ‚€ â†¦\n      (bound_integrable.mono_set_ae <| Eventually.of_forall <| hsub haâ‚€ hbâ‚€).mono_fun'\n        ((hF_meas x).mono_set <| hsub haâ‚€ hbâ‚€)\n        (ae_restrict_of_ae_restrict_of_subset (hsub haâ‚€ hbâ‚€) hx)\n    rw [intervalIntegral.integral_sub, add_assoc, add_sub_cancel,\n      intervalIntegral.integral_add_adjacent_intervals]\n    Â· exact hiF hx haâ‚€ hbâ‚€\n    Â· exact hiF hx hbâ‚€ ht\n    Â· exact hiF hx hbâ‚€ ht\n    Â· exact hiF hxâ‚€ hbâ‚€ ht\n  rw [continuousAt_congr this]; clear this\n  refine (ContinuousAt.add ?_ ?_).add ?_\n  Â· exact (intervalIntegral.continuousAt_of_dominated_interval\n        (Eventually.of_forall fun x â†¦ (hF_meas x).mono_set <| hsub haâ‚€ hbâ‚€)\n          (h_bound.mono fun x hx â†¦\n            ae_imp_of_ae_restrict <| ae_restrict_of_ae_restrict_of_subset (hsub haâ‚€ hbâ‚€) hx)\n          (bound_integrable.mono_set_ae <| Eventually.of_forall <| hsub haâ‚€ hbâ‚€) <|\n          ae_imp_of_ae_restrict <| ae_restrict_of_ae_restrict_of_subset (hsub haâ‚€ hbâ‚€) h_cont).fst'\n  Â· refine (?_ : ContinuousAt (fun t â†¦ âˆ« s in bâ‚€..t, F xâ‚€ s âˆ‚Î¼) bâ‚€).snd'\n    apply ContinuousWithinAt.continuousAt _ (Icc_mem_nhds hbâ‚€.1 hbâ‚€.2)\n    apply intervalIntegral.continuousWithinAt_primitive hÎ¼bâ‚€\n    rw [min_eq_right hbâ‚€.1.le, max_eq_right hbâ‚€.2.le]\n    exact bound_integrable.mono_fun' (hF_meas xâ‚€) hxâ‚€\n  Â· suffices Tendsto (fun x : X Ã— â„ â†¦ âˆ« s in bâ‚€..x.2, F x.1 s - F xâ‚€ s âˆ‚Î¼) (ğ“ (xâ‚€, bâ‚€)) (ğ“ 0) by\n      simpa [ContinuousAt]\n    have : âˆ€á¶  p : X Ã— â„ in ğ“ (xâ‚€, bâ‚€),\n        â€–âˆ« s in bâ‚€..p.2, F p.1 s - F xâ‚€ s âˆ‚Î¼â€– â‰¤ |âˆ« s in bâ‚€..p.2, 2 * bound s âˆ‚Î¼| := by\n      rw [nhds_prod_eq]\n      refine (h_bound.prod_mk Ioo_nhds).mono ?_\n      rintro âŸ¨x, tâŸ© âŸ¨hx : âˆ€áµ t âˆ‚Î¼.restrict (Î™ a b), â€–F x tâ€– â‰¤ bound t, ht : t âˆˆ Ioo a bâŸ©\n      have H : âˆ€áµ t : â„ âˆ‚Î¼.restrict (Î™ bâ‚€ t), â€–F x t - F xâ‚€ tâ€– â‰¤ 2 * bound t := by\n        apply (ae_restrict_of_ae_restrict_of_subset (hsub hbâ‚€ ht) (hx.and hxâ‚€)).mono\n        rintro s âŸ¨hsâ‚, hsâ‚‚âŸ©\n        calc\n          â€–F x s - F xâ‚€ sâ€– â‰¤ â€–F x sâ€– + â€–F xâ‚€ sâ€– := norm_sub_le _ _\n          _ â‰¤ 2 * bound s := by linarith only [hsâ‚, hsâ‚‚]\n      exact intervalIntegral.norm_integral_le_of_norm_le H\n        ((bound_integrable.mono_set' <| hsub hbâ‚€ ht).const_mul 2)\n    apply squeeze_zero_norm' this\n    have : Tendsto (fun t â†¦ âˆ« s in bâ‚€..t, 2 * bound s âˆ‚Î¼) (ğ“ bâ‚€) (ğ“ 0) := by\n      suffices ContinuousAt (fun t â†¦ âˆ« s in bâ‚€..t, 2 * bound s âˆ‚Î¼) bâ‚€ by\n        simpa [ContinuousAt] using this\n      apply ContinuousWithinAt.continuousAt _ Icc_nhds\n      apply intervalIntegral.continuousWithinAt_primitive hÎ¼bâ‚€\n      apply IntervalIntegrable.const_mul\n      apply bound_integrable.mono_set'\n      rw [min_eq_right hbâ‚€.1.le, max_eq_right hbâ‚€.2.le]\n    rw [nhds_prod_eq]\n    exact (continuous_abs.tendsto' _ _ abs_zero).comp (this.comp tendsto_snd)\n\n"}
{"name":"intervalIntegral.continuousOn_primitive","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nf : Real â†’ E\ninstâœ : MeasureTheory.NoAtoms Î¼\nh_int : MeasureTheory.IntegrableOn f (Set.Icc a b) Î¼\nâŠ¢ ContinuousOn (fun x => MeasureTheory.integral (Î¼.restrict (Set.Ioc a x)) fun t => f t) (Set.Icc a b)","decl":"theorem continuousOn_primitive (h_int : IntegrableOn f (Icc a b) Î¼) :\n    ContinuousOn (fun x => âˆ« t in Ioc a x, f t âˆ‚Î¼) (Icc a b) := by\n  by_cases h : a â‰¤ b\n  Â· have : âˆ€ x âˆˆ Icc a b, âˆ« t in Ioc a x, f t âˆ‚Î¼ = âˆ« t in a..x, f t âˆ‚Î¼ := by\n      intro x x_in\n      simp_rw [integral_of_le x_in.1]\n    rw [continuousOn_congr this]\n    intro xâ‚€ _\n    refine continuousWithinAt_primitive (measure_singleton xâ‚€) ?_\n    simp only [intervalIntegrable_iff_integrableOn_Ioc_of_le, min_eq_left, max_eq_right, h,\n      min_self]\n    exact h_int.mono Ioc_subset_Icc_self le_rfl\n  Â· rw [Icc_eq_empty h]\n    exact continuousOn_empty _\n\n"}
{"name":"intervalIntegral.continuousOn_primitive_Icc","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nf : Real â†’ E\ninstâœ : MeasureTheory.NoAtoms Î¼\nh_int : MeasureTheory.IntegrableOn f (Set.Icc a b) Î¼\nâŠ¢ ContinuousOn (fun x => MeasureTheory.integral (Î¼.restrict (Set.Icc a x)) fun t => f t) (Set.Icc a b)","decl":"theorem continuousOn_primitive_Icc (h_int : IntegrableOn f (Icc a b) Î¼) :\n    ContinuousOn (fun x => âˆ« t in Icc a x, f t âˆ‚Î¼) (Icc a b) := by\n  have aux : (fun x => âˆ« t in Icc a x, f t âˆ‚Î¼) = fun x => âˆ« t in Ioc a x, f t âˆ‚Î¼ := by\n    ext x\n    exact integral_Icc_eq_integral_Ioc\n  rw [aux]\n  exact continuousOn_primitive h_int\n\n"}
{"name":"intervalIntegral.continuousOn_primitive_interval'","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\na bâ‚ bâ‚‚ : Real\nÎ¼ : MeasureTheory.Measure Real\nf : Real â†’ E\ninstâœ : MeasureTheory.NoAtoms Î¼\nh_int : IntervalIntegrable f Î¼ bâ‚ bâ‚‚\nha : Membership.mem (Set.uIcc bâ‚ bâ‚‚) a\nâŠ¢ ContinuousOn (fun b => intervalIntegral (fun x => f x) a b Î¼) (Set.uIcc bâ‚ bâ‚‚)","decl":"/-- Note: this assumes that `f` is `IntervalIntegrable`, in contrast to some other lemmas here. -/\ntheorem continuousOn_primitive_interval' (h_int : IntervalIntegrable f Î¼ bâ‚ bâ‚‚)\n    (ha : a âˆˆ [[bâ‚, bâ‚‚]]) : ContinuousOn (fun b => âˆ« x in a..b, f x âˆ‚Î¼) [[bâ‚, bâ‚‚]] := fun _ _ â†¦ by\n  refine continuousWithinAt_primitive (measure_singleton _) ?_\n  rw [min_eq_right ha.1, max_eq_right ha.2]\n  simpa [intervalIntegrable_iff, uIoc] using h_int\n\n"}
{"name":"intervalIntegral.continuousOn_primitive_interval","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nf : Real â†’ E\ninstâœ : MeasureTheory.NoAtoms Î¼\nh_int : MeasureTheory.IntegrableOn f (Set.uIcc a b) Î¼\nâŠ¢ ContinuousOn (fun x => intervalIntegral (fun t => f t) a x Î¼) (Set.uIcc a b)","decl":"theorem continuousOn_primitive_interval (h_int : IntegrableOn f (uIcc a b) Î¼) :\n    ContinuousOn (fun x => âˆ« t in a..x, f t âˆ‚Î¼) (uIcc a b) :=\n  continuousOn_primitive_interval' h_int.intervalIntegrable left_mem_uIcc\n\n"}
{"name":"intervalIntegral.continuousOn_primitive_interval_left","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\na b : Real\nÎ¼ : MeasureTheory.Measure Real\nf : Real â†’ E\ninstâœ : MeasureTheory.NoAtoms Î¼\nh_int : MeasureTheory.IntegrableOn f (Set.uIcc a b) Î¼\nâŠ¢ ContinuousOn (fun x => intervalIntegral (fun t => f t) x b Î¼) (Set.uIcc a b)","decl":"theorem continuousOn_primitive_interval_left (h_int : IntegrableOn f (uIcc a b) Î¼) :\n    ContinuousOn (fun x => âˆ« t in x..b, f t âˆ‚Î¼) (uIcc a b) := by\n  rw [uIcc_comm a b] at h_int âŠ¢\n  simp only [integral_symm b]\n  exact (continuousOn_primitive_interval h_int).neg\n\n"}
{"name":"intervalIntegral.continuous_primitive","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nÎ¼ : MeasureTheory.Measure Real\nf : Real â†’ E\ninstâœ : MeasureTheory.NoAtoms Î¼\nh_int : âˆ€ (a b : Real), IntervalIntegrable f Î¼ a b\na : Real\nâŠ¢ Continuous fun b => intervalIntegral (fun x => f x) a b Î¼","decl":"theorem continuous_primitive (h_int : âˆ€ a b, IntervalIntegrable f Î¼ a b) (a : â„) :\n    Continuous fun b => âˆ« x in a..b, f x âˆ‚Î¼ := by\n  rw [continuous_iff_continuousAt]\n  intro bâ‚€\n  cases' exists_lt bâ‚€ with bâ‚ hbâ‚\n  cases' exists_gt bâ‚€ with bâ‚‚ hbâ‚‚\n  apply ContinuousWithinAt.continuousAt _ (Icc_mem_nhds hbâ‚ hbâ‚‚)\n  exact continuousWithinAt_primitive (measure_singleton bâ‚€) (h_int _ _)\n\n"}
{"name":"MeasureTheory.Integrable.continuous_primitive","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nÎ¼ : MeasureTheory.Measure Real\nf : Real â†’ E\ninstâœ : MeasureTheory.NoAtoms Î¼\nh_int : MeasureTheory.Integrable f Î¼\na : Real\nâŠ¢ Continuous fun b => intervalIntegral (fun x => f x) a b Î¼","decl":"nonrec theorem _root_.MeasureTheory.Integrable.continuous_primitive (h_int : Integrable f Î¼)\n    (a : â„) : Continuous fun b => âˆ« x in a..b, f x âˆ‚Î¼ :=\n  continuous_primitive (fun _ _ => h_int.intervalIntegrable) a\n\n"}
{"name":"intervalIntegral.continuous_parametric_primitive_of_continuous","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_1\nX : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : TopologicalSpace X\nÎ¼ : MeasureTheory.Measure Real\ninstâœÂ¹ : MeasureTheory.NoAtoms Î¼\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nf : X â†’ Real â†’ E\naâ‚€ : Real\nhf : Continuous (Function.uncurry f)\nâŠ¢ Continuous fun p => intervalIntegral (fun t => f p.1 t) aâ‚€ p.2 Î¼","decl":"theorem continuous_parametric_primitive_of_continuous\n    {aâ‚€ : â„} (hf : Continuous f.uncurry) :\n    Continuous fun p : X Ã— â„ â†¦ âˆ« t in aâ‚€..p.2, f p.1 t âˆ‚Î¼ := by\n  -- We will prove continuity at a point `(q, bâ‚€)`.\n  rw [continuous_iff_continuousAt]\n  rintro âŸ¨q, bâ‚€âŸ©\n  apply Metric.continuousAt_iff'.2 (fun Îµ Îµpos â†¦ ?_)\n  -- choose `a` and `b` such that `(a, b)` contains both `aâ‚€` and `bâ‚€`. We will use uniform\n  -- estimates on a neighborhood of the compact set `{q} Ã— [a, b]`.\n  cases' exists_lt (min aâ‚€ bâ‚€) with a a_lt\n  cases' exists_gt (max aâ‚€ bâ‚€) with b lt_b\n  rw [lt_min_iff] at a_lt\n  rw [max_lt_iff] at lt_b\n  have : IsCompact ({q} Ã—Ë¢ (Icc a b)) := isCompact_singleton.prod isCompact_Icc\n  -- let `M` be a bound for `f` on the compact set `{q} Ã— [a, b]`.\n  obtain âŸ¨M, hMâŸ© := this.bddAbove_image hf.norm.continuousOn\n  -- let `Î´` be small enough to satisfy several properties that will show up later.\n  obtain âŸ¨Î´, Î´pos, hÎ´, h'Î´, h''Î´âŸ© : âˆƒ (Î´ : â„), 0 < Î´ âˆ§ Î´ < 1 âˆ§ Icc (bâ‚€ - Î´) (bâ‚€ + Î´) âŠ† Icc a b âˆ§\n      (M + 1) * (Î¼ (Icc (bâ‚€ - Î´) (bâ‚€ + Î´))).toReal + Î´ * (Î¼ (Icc a b)).toReal < Îµ := by\n    have A : âˆ€á¶  Î´ in ğ“[>] (0 : â„), Î´ âˆˆ Ioo 0 1 := Ioo_mem_nhdsGT zero_lt_one\n    have B : âˆ€á¶  Î´ in ğ“ 0, Icc (bâ‚€ - Î´) (bâ‚€ + Î´) âŠ† Icc a b := by\n      have I : Tendsto (fun Î´ â†¦ bâ‚€ - Î´) (ğ“ 0) (ğ“ (bâ‚€ - 0)) := tendsto_const_nhds.sub tendsto_id\n      have J : Tendsto (fun Î´ â†¦ bâ‚€ + Î´) (ğ“ 0) (ğ“ (bâ‚€ + 0)) := tendsto_const_nhds.add tendsto_id\n      simp only [sub_zero, add_zero] at I J\n      filter_upwards [(tendsto_order.1 I).1 _ a_lt.2, (tendsto_order.1 J).2 _ lt_b.2] with Î´ hÎ´ h'Î´\n      exact Icc_subset_Icc hÎ´.le h'Î´.le\n    have C : âˆ€á¶  Î´ in ğ“ 0,\n        (M + 1) * (Î¼ (Icc (bâ‚€ - Î´) (bâ‚€ + Î´))).toReal + Î´ * (Î¼ (Icc a b)).toReal < Îµ := by\n      suffices Tendsto\n        (fun Î´ â†¦ (M + 1) * (Î¼ (Icc (bâ‚€ - Î´) (bâ‚€ + Î´))).toReal + Î´ * (Î¼ (Icc a b)).toReal)\n          (ğ“ 0) (ğ“ ((M + 1) * (0 : â„â‰¥0âˆ).toReal + 0 * (Î¼ (Icc a b)).toReal)) by\n        simp only [zero_toReal, mul_zero, zero_mul, add_zero] at this\n        exact (tendsto_order.1 this).2 _ Îµpos\n      apply Tendsto.add (Tendsto.mul tendsto_const_nhds _)\n        (Tendsto.mul tendsto_id tendsto_const_nhds)\n      exact (tendsto_toReal zero_ne_top).comp (tendsto_measure_Icc _ _)\n    rcases (A.and ((B.and C).filter_mono nhdsWithin_le_nhds)).exists with âŸ¨Î´, hÎ´, h'Î´, h''Î´âŸ©\n    exact âŸ¨Î´, hÎ´.1, hÎ´.2, h'Î´, h''Î´âŸ©\n  -- By compactness of `[a, b]` and continuity of `f` there, if `p` is close enough to `q`\n  -- then `f p x` is `Î´`-close to `f q x`, uniformly in `x âˆˆ [a, b]`.\n  -- (Note in particular that this implies a bound `M + Î´ â‰¤ M + 1` for `f p x`).\n  obtain âŸ¨v, v_mem, hvâŸ© : âˆƒ v âˆˆ ğ“[univ] q, âˆ€ p âˆˆ v, âˆ€ x âˆˆ Icc a b, dist (f p x) (f q x) < Î´ :=\n    IsCompact.mem_uniformity_of_prod isCompact_Icc hf.continuousOn (mem_univ _)\n      (dist_mem_uniformity Î´pos)\n  -- for `p` in this neighborhood and `s` which is `Î´`-close to `bâ‚€`, we will show that the\n  -- integrals are `Îµ`-close.\n  have : v Ã—Ë¢ (Ioo (bâ‚€ - Î´) (bâ‚€ + Î´)) âˆˆ ğ“ (q, bâ‚€) := by\n    rw [nhdsWithin_univ] at v_mem\n    simp only [prod_mem_nhds_iff, v_mem, true_and]\n    apply Ioo_mem_nhds <;> linarith\n  filter_upwards [this]\n  rintro âŸ¨p, sâŸ© âŸ¨hp : p âˆˆ v, hs : s âˆˆ Ioo (bâ‚€ - Î´) (bâ‚€ + Î´)âŸ©\n  simp only [dist_eq_norm] at hv âŠ¢\n  have J r u v : IntervalIntegrable (f r) Î¼ u v := (hf.uncurry_left _).intervalIntegrable _ _\n  /- we compute the difference between the integrals by splitting the contribution of the change\n  from `bâ‚€` to `s` (which gives a contribution controlled by the measure of `(bâ‚€ - Î´, bâ‚€ + Î´)`,\n  small enough thanks to our choice of `Î´`) and the change from `q` to `p`, which is small as\n  `f p x` and `f q x` are uniformly close by design. -/\n  calc\n  â€–âˆ« t in aâ‚€..s, f p t âˆ‚Î¼ - âˆ« t in aâ‚€..bâ‚€, f q t âˆ‚Î¼â€–\n    = â€–(âˆ« t in aâ‚€..s, f p t âˆ‚Î¼ - âˆ« t in aâ‚€..bâ‚€, f p t âˆ‚Î¼)\n        + (âˆ« t in aâ‚€..bâ‚€, f p t âˆ‚Î¼ - âˆ« t in aâ‚€..bâ‚€, f q t âˆ‚Î¼)â€– := by congr 1; abel\n  _ â‰¤ â€–âˆ« t in aâ‚€..s, f p t âˆ‚Î¼ - âˆ« t in aâ‚€..bâ‚€, f p t âˆ‚Î¼â€–\n        + â€–âˆ« t in aâ‚€..bâ‚€, f p t âˆ‚Î¼ - âˆ« t in aâ‚€..bâ‚€, f q t âˆ‚Î¼â€– := norm_add_le _ _\n  _ = â€–âˆ« t in bâ‚€..s, f p t âˆ‚Î¼â€– + â€–âˆ« t in aâ‚€..bâ‚€, (f p t - f q t) âˆ‚Î¼â€– := by\n      congr 2\n      Â· rw [integral_interval_sub_left (J _ _ _) (J _ _ _)]\n      Â· rw [integral_sub (J _ _ _) (J _ _ _)]\n  _ â‰¤ âˆ« t in Î™ bâ‚€ s, â€–f p tâ€– âˆ‚Î¼ + âˆ« t in Î™ aâ‚€ bâ‚€, â€–f p t - f q tâ€– âˆ‚Î¼ := by\n      gcongr\n      Â· exact norm_integral_le_integral_norm_Ioc\n      Â· exact norm_integral_le_integral_norm_Ioc\n  _ â‰¤ âˆ« t in Icc (bâ‚€ - Î´) (bâ‚€ + Î´), â€–f p tâ€– âˆ‚Î¼ + âˆ« t in Icc a b, â€–f p t - f q tâ€– âˆ‚Î¼ := by\n      gcongr\n      Â· apply setIntegral_mono_set\n        Â· exact (hf.uncurry_left _).norm.integrableOn_Icc\n        Â· exact Eventually.of_forall (fun x â†¦ norm_nonneg _)\n        Â· have : Î™ bâ‚€ s âŠ† Icc (bâ‚€ - Î´) (bâ‚€ + Î´) := by\n            apply uIoc_subset_uIcc.trans (uIcc_subset_Icc ?_ âŸ¨hs.1.le, hs.2.leâŸ© )\n            simp [Î´pos.le]\n          exact Eventually.of_forall this\n      Â· apply setIntegral_mono_set\n        Â· exact ((hf.uncurry_left _).sub (hf.uncurry_left _)).norm.integrableOn_Icc\n        Â· exact Eventually.of_forall (fun x â†¦ norm_nonneg _)\n        Â· have : Î™ aâ‚€ bâ‚€ âŠ† Icc a b := uIoc_subset_uIcc.trans\n            (uIcc_subset_Icc âŸ¨a_lt.1.le, lt_b.1.leâŸ© âŸ¨a_lt.2.le, lt_b.2.leâŸ©)\n          exact Eventually.of_forall this\n  _ â‰¤ âˆ« t in Icc (bâ‚€ - Î´) (bâ‚€ + Î´), M + 1 âˆ‚Î¼ + âˆ« _t in Icc a b, Î´ âˆ‚Î¼ := by\n      gcongr ?_ + ?_\n      Â· apply setIntegral_mono_on\n        Â· exact (hf.uncurry_left _).norm.integrableOn_Icc\n        Â· exact continuous_const.integrableOn_Icc\n        Â· exact measurableSet_Icc\n        Â· intro x hx\n          calc â€–f p xâ€– = â€–f q x + (f p x - f q x)â€– := by congr; abel\n          _ â‰¤ â€–f q xâ€– + â€–f p x - f q xâ€– := norm_add_le _ _\n          _ â‰¤ M + Î´ := by\n              gcongr\n              Â· apply hM\n                change (fun x â†¦ â€–Function.uncurry f xâ€–) (q, x) âˆˆ _\n                apply mem_image_of_mem\n                simp only [singleton_prod, mem_image, Prod.mk.injEq, true_and, exists_eq_right]\n                exact h'Î´ hx\n              Â· exact le_of_lt (hv _ hp _ (h'Î´ hx))\n          _ â‰¤ M + 1 := by linarith\n      Â· apply setIntegral_mono_on\n        Â· exact ((hf.uncurry_left _).sub (hf.uncurry_left _)).norm.integrableOn_Icc\n        Â· exact continuous_const.integrableOn_Icc\n        Â· exact measurableSet_Icc\n        Â· intro x hx\n          exact le_of_lt (hv _ hp _ hx)\n  _ = (M + 1) * (Î¼ (Icc (bâ‚€ - Î´) (bâ‚€ + Î´))).toReal + Î´ * (Î¼ (Icc a b)).toReal := by simp [mul_comm]\n  _ < Îµ := h''Î´\n\n"}
{"name":"intervalIntegral.continuous_parametric_intervalIntegral_of_continuous","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_1\nX : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : TopologicalSpace X\nÎ¼ : MeasureTheory.Measure Real\ninstâœÂ¹ : MeasureTheory.NoAtoms Î¼\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nf : X â†’ Real â†’ E\naâ‚€ : Real\nhf : Continuous (Function.uncurry f)\ns : X â†’ Real\nhs : Continuous s\nâŠ¢ Continuous fun x => intervalIntegral (fun t => f x t) aâ‚€ (s x) Î¼","decl":"@[fun_prop]\ntheorem continuous_parametric_intervalIntegral_of_continuous {aâ‚€ : â„}\n    (hf : Continuous f.uncurry) {s : X â†’ â„} (hs : Continuous s) :\n    Continuous fun x â†¦ âˆ« t in aâ‚€..s x, f x t âˆ‚Î¼ :=\n  show Continuous ((fun p : X Ã— â„ â†¦ âˆ« t in aâ‚€..p.2, f p.1 t âˆ‚Î¼) âˆ˜ fun x â†¦ (x, s x)) from\n    (continuous_parametric_primitive_of_continuous hf).compâ‚‚ continuous_id hs\n\n"}
{"name":"intervalIntegral.continuous_parametric_intervalIntegral_of_continuous'","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_1\nX : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : TopologicalSpace X\nÎ¼ : MeasureTheory.Measure Real\ninstâœÂ¹ : MeasureTheory.NoAtoms Î¼\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nf : X â†’ Real â†’ E\nhf : Continuous (Function.uncurry f)\naâ‚€ bâ‚€ : Real\nâŠ¢ Continuous fun x => intervalIntegral (fun t => f x t) aâ‚€ bâ‚€ Î¼","decl":"theorem continuous_parametric_intervalIntegral_of_continuous'\n    (hf : Continuous f.uncurry) (aâ‚€ bâ‚€ : â„) :\n    Continuous fun x â†¦ âˆ« t in aâ‚€..bâ‚€, f x t âˆ‚Î¼ := by fun_prop\n\n"}
