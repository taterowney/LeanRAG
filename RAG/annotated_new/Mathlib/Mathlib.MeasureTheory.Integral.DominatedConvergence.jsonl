{"name":"MeasureTheory.tendsto_integral_of_dominated_convergence","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"α : Type u_1\nG : Type u_3\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace Real G\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nF : Nat → α → G\nf : α → G\nbound : α → Real\nF_measurable : ∀ (n : Nat), MeasureTheory.AEStronglyMeasurable (F n) μ\nbound_integrable : MeasureTheory.Integrable bound μ\nh_bound : ∀ (n : Nat), Filter.Eventually (fun a => LE.le (Norm.norm (F n a)) (bound a)) (MeasureTheory.ae μ)\nh_lim : Filter.Eventually (fun a => Filter.Tendsto (fun n => F n a) Filter.atTop (nhds (f a))) (MeasureTheory.ae μ)\n⊢ Filter.Tendsto (fun n => MeasureTheory.integral μ fun a => F n a) Filter.atTop (nhds (MeasureTheory.integral μ fun a => f a))","decl":"/-- **Lebesgue dominated convergence theorem** provides sufficient conditions under which almost\n  everywhere convergence of a sequence of functions implies the convergence of their integrals.\n  We could weaken the condition `bound_integrable` to require `HasFiniteIntegral bound μ` instead\n  (i.e. not requiring that `bound` is measurable), but in all applications proving integrability\n  is easier. -/\ntheorem tendsto_integral_of_dominated_convergence {F : ℕ → α → G} {f : α → G} (bound : α → ℝ)\n    (F_measurable : ∀ n, AEStronglyMeasurable (F n) μ) (bound_integrable : Integrable bound μ)\n    (h_bound : ∀ n, ∀ᵐ a ∂μ, ‖F n a‖ ≤ bound a)\n    (h_lim : ∀ᵐ a ∂μ, Tendsto (fun n => F n a) atTop (𝓝 (f a))) :\n    Tendsto (fun n => ∫ a, F n a ∂μ) atTop (𝓝 <| ∫ a, f a ∂μ) := by\n  by_cases hG : CompleteSpace G\n  · simp only [integral, hG, L1.integral]\n    exact tendsto_setToFun_of_dominated_convergence (dominatedFinMeasAdditive_weightedSMul μ)\n      bound F_measurable bound_integrable h_bound h_lim\n  · simp [integral, hG]\n\n"}
{"name":"MeasureTheory.tendsto_integral_filter_of_dominated_convergence","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"α : Type u_1\nG : Type u_3\ninst✝² : NormedAddCommGroup G\ninst✝¹ : NormedSpace Real G\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nι : Type u_4\nl : Filter ι\ninst✝ : l.IsCountablyGenerated\nF : ι → α → G\nf : α → G\nbound : α → Real\nhF_meas : Filter.Eventually (fun n => MeasureTheory.AEStronglyMeasurable (F n) μ) l\nh_bound : Filter.Eventually (fun n => Filter.Eventually (fun a => LE.le (Norm.norm (F n a)) (bound a)) (MeasureTheory.ae μ)) l\nbound_integrable : MeasureTheory.Integrable bound μ\nh_lim : Filter.Eventually (fun a => Filter.Tendsto (fun n => F n a) l (nhds (f a))) (MeasureTheory.ae μ)\n⊢ Filter.Tendsto (fun n => MeasureTheory.integral μ fun a => F n a) l (nhds (MeasureTheory.integral μ fun a => f a))","decl":"/-- Lebesgue dominated convergence theorem for filters with a countable basis -/\ntheorem tendsto_integral_filter_of_dominated_convergence {ι} {l : Filter ι} [l.IsCountablyGenerated]\n    {F : ι → α → G} {f : α → G} (bound : α → ℝ) (hF_meas : ∀ᶠ n in l, AEStronglyMeasurable (F n) μ)\n    (h_bound : ∀ᶠ n in l, ∀ᵐ a ∂μ, ‖F n a‖ ≤ bound a) (bound_integrable : Integrable bound μ)\n    (h_lim : ∀ᵐ a ∂μ, Tendsto (fun n => F n a) l (𝓝 (f a))) :\n    Tendsto (fun n => ∫ a, F n a ∂μ) l (𝓝 <| ∫ a, f a ∂μ) := by\n  by_cases hG : CompleteSpace G\n  · simp only [integral, hG, L1.integral]\n    exact tendsto_setToFun_filter_of_dominated_convergence (dominatedFinMeasAdditive_weightedSMul μ)\n      bound hF_meas h_bound bound_integrable h_lim\n  · simp [integral, hG, tendsto_const_nhds]\n\n"}
{"name":"MeasureTheory.hasSum_integral_of_dominated_convergence","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"α : Type u_1\nG : Type u_3\ninst✝² : NormedAddCommGroup G\ninst✝¹ : NormedSpace Real G\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nι : Type u_4\ninst✝ : Countable ι\nF : ι → α → G\nf : α → G\nbound : ι → α → Real\nhF_meas : ∀ (n : ι), MeasureTheory.AEStronglyMeasurable (F n) μ\nh_bound : ∀ (n : ι), Filter.Eventually (fun a => LE.le (Norm.norm (F n a)) (bound n a)) (MeasureTheory.ae μ)\nbound_summable : Filter.Eventually (fun a => Summable fun n => bound n a) (MeasureTheory.ae μ)\nbound_integrable : MeasureTheory.Integrable (fun a => tsum fun n => bound n a) μ\nh_lim : Filter.Eventually (fun a => HasSum (fun n => F n a) (f a)) (MeasureTheory.ae μ)\n⊢ HasSum (fun n => MeasureTheory.integral μ fun a => F n a) (MeasureTheory.integral μ fun a => f a)","decl":"/-- Lebesgue dominated convergence theorem for series. -/\ntheorem hasSum_integral_of_dominated_convergence {ι} [Countable ι] {F : ι → α → G} {f : α → G}\n    (bound : ι → α → ℝ) (hF_meas : ∀ n, AEStronglyMeasurable (F n) μ)\n    (h_bound : ∀ n, ∀ᵐ a ∂μ, ‖F n a‖ ≤ bound n a)\n    (bound_summable : ∀ᵐ a ∂μ, Summable fun n => bound n a)\n    (bound_integrable : Integrable (fun a => ∑' n, bound n a) μ)\n    (h_lim : ∀ᵐ a ∂μ, HasSum (fun n => F n a) (f a)) :\n    HasSum (fun n => ∫ a, F n a ∂μ) (∫ a, f a ∂μ) := by\n  have hb_nonneg : ∀ᵐ a ∂μ, ∀ n, 0 ≤ bound n a :=\n    eventually_countable_forall.2 fun n => (h_bound n).mono fun a => (norm_nonneg _).trans\n  have hb_le_tsum : ∀ n, bound n ≤ᵐ[μ] fun a => ∑' n, bound n a := by\n    intro n\n    filter_upwards [hb_nonneg, bound_summable]\n      with _ ha0 ha_sum using le_tsum ha_sum _ fun i _ => ha0 i\n  have hF_integrable : ∀ n, Integrable (F n) μ := by\n    refine fun n => bound_integrable.mono' (hF_meas n) ?_\n    exact EventuallyLE.trans (h_bound n) (hb_le_tsum n)\n  simp only [HasSum, ← integral_finset_sum _ fun n _ => hF_integrable n]\n  refine tendsto_integral_filter_of_dominated_convergence\n      (fun a => ∑' n, bound n a) ?_ ?_ bound_integrable h_lim\n  · exact Eventually.of_forall fun s => s.aestronglyMeasurable_sum fun n _ => hF_meas n\n  · filter_upwards with s\n    filter_upwards [eventually_countable_forall.2 h_bound, hb_nonneg, bound_summable]\n      with a hFa ha0 has\n    calc\n      ‖∑ n ∈ s, F n a‖ ≤ ∑ n ∈ s, bound n a := norm_sum_le_of_le _ fun n _ => hFa n\n      _ ≤ ∑' n, bound n a := sum_le_tsum _ (fun n _ => ha0 n) has\n\n"}
{"name":"MeasureTheory.integral_tsum","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"α : Type u_1\nG : Type u_3\ninst✝² : NormedAddCommGroup G\ninst✝¹ : NormedSpace Real G\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nι : Type u_4\ninst✝ : Countable ι\nf : ι → α → G\nhf : ∀ (i : ι), MeasureTheory.AEStronglyMeasurable (f i) μ\nhf' : Ne (tsum fun i => MeasureTheory.lintegral μ fun a => ENorm.enorm (f i a)) Top.top\n⊢ Eq (MeasureTheory.integral μ fun a => tsum fun i => f i a) (tsum fun i => MeasureTheory.integral μ fun a => f i a)","decl":"theorem integral_tsum {ι} [Countable ι] {f : ι → α → G} (hf : ∀ i, AEStronglyMeasurable (f i) μ)\n    (hf' : ∑' i, ∫⁻ a : α, ‖f i a‖ₑ ∂μ ≠ ∞) :\n    ∫ a : α, ∑' i, f i a ∂μ = ∑' i, ∫ a : α, f i a ∂μ := by\n  by_cases hG : CompleteSpace G; swap\n  · simp [integral, hG]\n  have hf'' i : AEMeasurable (‖f i ·‖ₑ) μ := (hf i).enorm\n  have hhh : ∀ᵐ a : α ∂μ, Summable fun n => (‖f n a‖₊ : ℝ) := by\n    rw [← lintegral_tsum hf''] at hf'\n    refine (ae_lt_top' (AEMeasurable.ennreal_tsum hf'') hf').mono ?_\n    intro x hx\n    rw [← ENNReal.tsum_coe_ne_top_iff_summable_coe]\n    exact hx.ne\n  convert (MeasureTheory.hasSum_integral_of_dominated_convergence (fun i a => ‖f i a‖₊) hf _ hhh\n          ⟨_, _⟩ _).tsum_eq.symm\n  · intro n\n    filter_upwards with x\n    rfl\n  · simp_rw [← NNReal.coe_tsum]\n    rw [aestronglyMeasurable_iff_aemeasurable]\n    apply AEMeasurable.coe_nnreal_real\n    apply AEMeasurable.nnreal_tsum\n    exact fun i => (hf i).nnnorm.aemeasurable\n  · dsimp [HasFiniteIntegral]\n    have : ∫⁻ a, ∑' n, ‖f n a‖ₑ ∂μ < ⊤ := by rwa [lintegral_tsum hf'', lt_top_iff_ne_top]\n    convert this using 1\n    apply lintegral_congr_ae\n    simp_rw [← coe_nnnorm, ← NNReal.coe_tsum, enorm_eq_nnnorm, NNReal.nnnorm_eq]\n    filter_upwards [hhh] with a ha\n    exact ENNReal.coe_tsum (NNReal.summable_coe.mp ha)\n  · filter_upwards [hhh] with x hx\n    exact hx.of_norm.hasSum\n\n"}
{"name":"MeasureTheory.hasSum_integral_of_summable_integral_norm","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"α : Type u_1\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nι : Type u_4\ninst✝ : Countable ι\nF : ι → α → E\nhF_int : ∀ (i : ι), MeasureTheory.Integrable (F i) μ\nhF_sum : Summable fun i => MeasureTheory.integral μ fun a => Norm.norm (F i a)\n⊢ HasSum (fun x => MeasureTheory.integral μ fun a => F x a) (MeasureTheory.integral μ fun a => tsum fun i => F i a)","decl":"lemma hasSum_integral_of_summable_integral_norm {ι} [Countable ι] {F : ι → α → E}\n    (hF_int : ∀ i : ι, Integrable (F i) μ) (hF_sum : Summable fun i ↦ ∫ a, ‖F i a‖ ∂μ) :\n    HasSum (∫ a, F · a ∂μ) (∫ a, (∑' i, F i a) ∂μ) := by\n  by_cases hE : CompleteSpace E; swap\n  · simp [integral, hE, hasSum_zero]\n  rw [integral_tsum (fun i ↦ (hF_int i).1)]\n  · exact (hF_sum.of_norm_bounded _ fun i ↦ norm_integral_le_integral_norm _).hasSum\n  have (i : ι) : ∫⁻ a, ‖F i a‖ₑ ∂μ = ‖∫ a, ‖F i a‖ ∂μ‖ₑ := by\n    dsimp [enorm]\n    rw [lintegral_coe_eq_integral _ (hF_int i).norm, coe_nnreal_eq, coe_nnnorm,\n      Real.norm_of_nonneg (integral_nonneg (fun a ↦ norm_nonneg (F i a)))]\n    simp only [coe_nnnorm]\n  rw [funext this]\n  exact ENNReal.tsum_coe_ne_top_iff_summable.2 <| NNReal.summable_coe.1 hF_sum.abs\n\n"}
{"name":"MeasureTheory.integral_tsum_of_summable_integral_norm","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"α : Type u_1\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nι : Type u_4\ninst✝ : Countable ι\nF : ι → α → E\nhF_int : ∀ (i : ι), MeasureTheory.Integrable (F i) μ\nhF_sum : Summable fun i => MeasureTheory.integral μ fun a => Norm.norm (F i a)\n⊢ Eq (tsum fun i => MeasureTheory.integral μ fun a => F i a) (MeasureTheory.integral μ fun a => tsum fun i => F i a)","decl":"lemma integral_tsum_of_summable_integral_norm {ι} [Countable ι] {F : ι → α → E}\n    (hF_int : ∀ i : ι, Integrable (F i) μ) (hF_sum : Summable fun i ↦ ∫ a, ‖F i a‖ ∂μ) :\n    ∑' i, (∫ a, F i a ∂μ) = ∫ a, (∑' i, F i a) ∂μ :=\n  (hasSum_integral_of_summable_integral_norm hF_int hF_sum).tsum_eq\n\n"}
{"name":"Antitone.tendsto_setIntegral","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"α : Type u_1\nE : Type u_2\ninst✝² : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\ns : Nat → Set α\nf : α → E\nhsm : ∀ (i : Nat), MeasurableSet (s i)\nh_anti : Antitone s\nhfi : MeasureTheory.IntegrableOn f (s 0) μ\n⊢ Filter.Tendsto (fun i => MeasureTheory.integral (μ.restrict (s i)) fun a => f a) Filter.atTop (nhds (MeasureTheory.integral (μ.restrict (Set.iInter fun n => s n)) fun a => f a))","decl":"theorem _root_.Antitone.tendsto_setIntegral (hsm : ∀ i, MeasurableSet (s i)) (h_anti : Antitone s)\n    (hfi : IntegrableOn f (s 0) μ) :\n    Tendsto (fun i => ∫ a in s i, f a ∂μ) atTop (𝓝 (∫ a in ⋂ n, s n, f a ∂μ)) := by\n  let bound : α → ℝ := indicator (s 0) fun a => ‖f a‖\n  have h_int_eq : (fun i => ∫ a in s i, f a ∂μ) = fun i => ∫ a, (s i).indicator f a ∂μ :=\n    funext fun i => (integral_indicator (hsm i)).symm\n  rw [h_int_eq]\n  rw [← integral_indicator (MeasurableSet.iInter hsm)]\n  refine tendsto_integral_of_dominated_convergence bound ?_ ?_ ?_ ?_\n  · intro n\n    rw [aestronglyMeasurable_indicator_iff (hsm n)]\n    exact (IntegrableOn.mono_set hfi (h_anti (zero_le n))).1\n  · rw [integrable_indicator_iff (hsm 0)]\n    exact hfi.norm\n  · simp_rw [norm_indicator_eq_indicator_norm]\n    refine fun n => Eventually.of_forall fun x => ?_\n    exact indicator_le_indicator_of_subset (h_anti (zero_le n)) (fun a => norm_nonneg _) _\n  · filter_upwards [] with a using le_trans (h_anti.tendsto_indicator _ _ _) (pure_le_nhds _)\n\n"}
{"name":"intervalIntegral.tendsto_integral_filter_of_dominated_convergence","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\na b : Real\nf : Real → E\nμ : MeasureTheory.Measure Real\nι : Type u_3\nl : Filter ι\ninst✝ : l.IsCountablyGenerated\nF : ι → Real → E\nbound : Real → Real\nhF_meas : Filter.Eventually (fun n => MeasureTheory.AEStronglyMeasurable (F n) (μ.restrict (Set.uIoc a b))) l\nh_bound : Filter.Eventually (fun n => Filter.Eventually (fun x => Membership.mem (Set.uIoc a b) x → LE.le (Norm.norm (F n x)) (bound x)) (MeasureTheory.ae μ)) l\nbound_integrable : IntervalIntegrable bound μ a b\nh_lim : Filter.Eventually (fun x => Membership.mem (Set.uIoc a b) x → Filter.Tendsto (fun n => F n x) l (nhds (f x))) (MeasureTheory.ae μ)\n⊢ Filter.Tendsto (fun n => intervalIntegral (fun x => F n x) a b μ) l (nhds (intervalIntegral (fun x => f x) a b μ))","decl":"/-- Lebesgue dominated convergence theorem for filters with a countable basis -/\nnonrec theorem tendsto_integral_filter_of_dominated_convergence {ι} {l : Filter ι}\n    [l.IsCountablyGenerated] {F : ι → ℝ → E} (bound : ℝ → ℝ)\n    (hF_meas : ∀ᶠ n in l, AEStronglyMeasurable (F n) (μ.restrict (Ι a b)))\n    (h_bound : ∀ᶠ n in l, ∀ᵐ x ∂μ, x ∈ Ι a b → ‖F n x‖ ≤ bound x)\n    (bound_integrable : IntervalIntegrable bound μ a b)\n    (h_lim : ∀ᵐ x ∂μ, x ∈ Ι a b → Tendsto (fun n => F n x) l (𝓝 (f x))) :\n    Tendsto (fun n => ∫ x in a..b, F n x ∂μ) l (𝓝 <| ∫ x in a..b, f x ∂μ) := by\n  simp only [intervalIntegrable_iff, intervalIntegral_eq_integral_uIoc,\n    ← ae_restrict_iff' (α := ℝ) (μ := μ) measurableSet_uIoc] at *\n  exact tendsto_const_nhds.smul <|\n    tendsto_integral_filter_of_dominated_convergence bound hF_meas h_bound bound_integrable h_lim\n\n"}
{"name":"intervalIntegral.hasSum_integral_of_dominated_convergence","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\na b : Real\nf : Real → E\nμ : MeasureTheory.Measure Real\nι : Type u_3\ninst✝ : Countable ι\nF : ι → Real → E\nbound : ι → Real → Real\nhF_meas : ∀ (n : ι), MeasureTheory.AEStronglyMeasurable (F n) (μ.restrict (Set.uIoc a b))\nh_bound : ∀ (n : ι), Filter.Eventually (fun t => Membership.mem (Set.uIoc a b) t → LE.le (Norm.norm (F n t)) (bound n t)) (MeasureTheory.ae μ)\nbound_summable : Filter.Eventually (fun t => Membership.mem (Set.uIoc a b) t → Summable fun n => bound n t) (MeasureTheory.ae μ)\nbound_integrable : IntervalIntegrable (fun t => tsum fun n => bound n t) μ a b\nh_lim : Filter.Eventually (fun t => Membership.mem (Set.uIoc a b) t → HasSum (fun n => F n t) (f t)) (MeasureTheory.ae μ)\n⊢ HasSum (fun n => intervalIntegral (fun t => F n t) a b μ) (intervalIntegral (fun t => f t) a b μ)","decl":"/-- Lebesgue dominated convergence theorem for parametric interval integrals. -/\nnonrec theorem hasSum_integral_of_dominated_convergence {ι} [Countable ι] {F : ι → ℝ → E}\n    (bound : ι → ℝ → ℝ) (hF_meas : ∀ n, AEStronglyMeasurable (F n) (μ.restrict (Ι a b)))\n    (h_bound : ∀ n, ∀ᵐ t ∂μ, t ∈ Ι a b → ‖F n t‖ ≤ bound n t)\n    (bound_summable : ∀ᵐ t ∂μ, t ∈ Ι a b → Summable fun n => bound n t)\n    (bound_integrable : IntervalIntegrable (fun t => ∑' n, bound n t) μ a b)\n    (h_lim : ∀ᵐ t ∂μ, t ∈ Ι a b → HasSum (fun n => F n t) (f t)) :\n    HasSum (fun n => ∫ t in a..b, F n t ∂μ) (∫ t in a..b, f t ∂μ) := by\n  simp only [intervalIntegrable_iff, intervalIntegral_eq_integral_uIoc, ←\n    ae_restrict_iff' (α := ℝ) (μ := μ) measurableSet_uIoc] at *\n  exact\n    (hasSum_integral_of_dominated_convergence bound hF_meas h_bound bound_summable bound_integrable\n          h_lim).const_smul\n      _\n\n"}
{"name":"intervalIntegral.hasSum_intervalIntegral_of_summable_norm","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"ι : Type u_1\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\na b : Real\ninst✝ : Countable ι\nf : ι → ContinuousMap Real E\nhf_sum : Summable fun i => Norm.norm (ContinuousMap.restrict (↑{ carrier := Set.uIcc a b, isCompact' := ⋯ }) (f i))\n⊢ HasSum (fun i => intervalIntegral (fun x => (f i) x) a b MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => tsum fun i => (f i) x) a b MeasureTheory.MeasureSpace.volume)","decl":"/-- Interval integrals commute with countable sums, when the supremum norms are summable (a\nspecial case of the dominated convergence theorem). -/\ntheorem hasSum_intervalIntegral_of_summable_norm [Countable ι] {f : ι → C(ℝ, E)}\n    (hf_sum : Summable fun i : ι => ‖(f i).restrict (⟨uIcc a b, isCompact_uIcc⟩ : Compacts ℝ)‖) :\n    HasSum (fun i : ι => ∫ x in a..b, f i x) (∫ x in a..b, ∑' i : ι, f i x) := by\n  by_cases hE : CompleteSpace E; swap\n  · simp [intervalIntegral, integral, hE, hasSum_zero]\n  apply hasSum_integral_of_dominated_convergence\n    (fun i (x : ℝ) => ‖(f i).restrict ↑(⟨uIcc a b, isCompact_uIcc⟩ : Compacts ℝ)‖)\n    (fun i => (map_continuous <| f i).aestronglyMeasurable)\n  · intro i; filter_upwards with x hx\n    apply ContinuousMap.norm_coe_le_norm ((f i).restrict _) ⟨x, _⟩\n    exact ⟨hx.1.le, hx.2⟩\n  · exact ae_of_all _ fun x _ => hf_sum\n  · exact intervalIntegrable_const\n  · refine ae_of_all _ fun x hx => Summable.hasSum ?_\n    let x : (⟨uIcc a b, isCompact_uIcc⟩ : Compacts ℝ) := ⟨x, ⟨hx.1.le, hx.2⟩⟩\n    have := hf_sum.of_norm\n    simpa only [Compacts.coe_mk, ContinuousMap.restrict_apply]\n      using ContinuousMap.summable_apply this x\n\n"}
{"name":"intervalIntegral.tsum_intervalIntegral_eq_of_summable_norm","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"ι : Type u_1\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\na b : Real\ninst✝ : Countable ι\nf : ι → ContinuousMap Real E\nhf_sum : Summable fun i => Norm.norm (ContinuousMap.restrict (↑{ carrier := Set.uIcc a b, isCompact' := ⋯ }) (f i))\n⊢ Eq (tsum fun i => intervalIntegral (fun x => (f i) x) a b MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => tsum fun i => (f i) x) a b MeasureTheory.MeasureSpace.volume)","decl":"theorem tsum_intervalIntegral_eq_of_summable_norm [Countable ι] {f : ι → C(ℝ, E)}\n    (hf_sum : Summable fun i : ι => ‖(f i).restrict (⟨uIcc a b, isCompact_uIcc⟩ : Compacts ℝ)‖) :\n    ∑' i : ι, ∫ x in a..b, f i x = ∫ x in a..b, ∑' i : ι, f i x :=\n  (hasSum_intervalIntegral_of_summable_norm hf_sum).tsum_eq\n\n"}
{"name":"intervalIntegral.continuousWithinAt_of_dominated_interval","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\nμ : MeasureTheory.Measure Real\nX : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : FirstCountableTopology X\nF : X → Real → E\nx₀ : X\nbound : Real → Real\na b : Real\ns : Set X\nhF_meas : Filter.Eventually (fun x => MeasureTheory.AEStronglyMeasurable (F x) (μ.restrict (Set.uIoc a b))) (nhdsWithin x₀ s)\nh_bound : Filter.Eventually (fun x => Filter.Eventually (fun t => Membership.mem (Set.uIoc a b) t → LE.le (Norm.norm (F x t)) (bound t)) (MeasureTheory.ae μ)) (nhdsWithin x₀ s)\nbound_integrable : IntervalIntegrable bound μ a b\nh_cont : Filter.Eventually (fun t => Membership.mem (Set.uIoc a b) t → ContinuousWithinAt (fun x => F x t) s x₀) (MeasureTheory.ae μ)\n⊢ ContinuousWithinAt (fun x => intervalIntegral (fun t => F x t) a b μ) s x₀","decl":"/-- Continuity of interval integral with respect to a parameter, at a point within a set.\n  Given `F : X → ℝ → E`, assume `F x` is ae-measurable on `[a, b]` for `x` in a\n  neighborhood of `x₀` within `s` and at `x₀`, and assume it is bounded by a function integrable\n  on `[a, b]` independent of `x` in a neighborhood of `x₀` within `s`. If `(fun x ↦ F x t)`\n  is continuous at `x₀` within `s` for almost every `t` in `[a, b]`\n  then the same holds for `(fun x ↦ ∫ t in a..b, F x t ∂μ) s x₀`. -/\ntheorem continuousWithinAt_of_dominated_interval {F : X → ℝ → E} {x₀ : X} {bound : ℝ → ℝ} {a b : ℝ}\n    {s : Set X} (hF_meas : ∀ᶠ x in 𝓝[s] x₀, AEStronglyMeasurable (F x) (μ.restrict <| Ι a b))\n    (h_bound : ∀ᶠ x in 𝓝[s] x₀, ∀ᵐ t ∂μ, t ∈ Ι a b → ‖F x t‖ ≤ bound t)\n    (bound_integrable : IntervalIntegrable bound μ a b)\n    (h_cont : ∀ᵐ t ∂μ, t ∈ Ι a b → ContinuousWithinAt (fun x => F x t) s x₀) :\n    ContinuousWithinAt (fun x => ∫ t in a..b, F x t ∂μ) s x₀ :=\n  tendsto_integral_filter_of_dominated_convergence bound hF_meas h_bound bound_integrable h_cont\n\n"}
{"name":"intervalIntegral.continuousAt_of_dominated_interval","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\nμ : MeasureTheory.Measure Real\nX : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : FirstCountableTopology X\nF : X → Real → E\nx₀ : X\nbound : Real → Real\na b : Real\nhF_meas : Filter.Eventually (fun x => MeasureTheory.AEStronglyMeasurable (F x) (μ.restrict (Set.uIoc a b))) (nhds x₀)\nh_bound : Filter.Eventually (fun x => Filter.Eventually (fun t => Membership.mem (Set.uIoc a b) t → LE.le (Norm.norm (F x t)) (bound t)) (MeasureTheory.ae μ)) (nhds x₀)\nbound_integrable : IntervalIntegrable bound μ a b\nh_cont : Filter.Eventually (fun t => Membership.mem (Set.uIoc a b) t → ContinuousAt (fun x => F x t) x₀) (MeasureTheory.ae μ)\n⊢ ContinuousAt (fun x => intervalIntegral (fun t => F x t) a b μ) x₀","decl":"/-- Continuity of interval integral with respect to a parameter at a point.\n  Given `F : X → ℝ → E`, assume `F x` is ae-measurable on `[a, b]` for `x` in a\n  neighborhood of `x₀`, and assume it is bounded by a function integrable on\n  `[a, b]` independent of `x` in a neighborhood of `x₀`. If `(fun x ↦ F x t)`\n  is continuous at `x₀` for almost every `t` in `[a, b]`\n  then the same holds for `(fun x ↦ ∫ t in a..b, F x t ∂μ) s x₀`. -/\ntheorem continuousAt_of_dominated_interval {F : X → ℝ → E} {x₀ : X} {bound : ℝ → ℝ} {a b : ℝ}\n    (hF_meas : ∀ᶠ x in 𝓝 x₀, AEStronglyMeasurable (F x) (μ.restrict <| Ι a b))\n    (h_bound : ∀ᶠ x in 𝓝 x₀, ∀ᵐ t ∂μ, t ∈ Ι a b → ‖F x t‖ ≤ bound t)\n    (bound_integrable : IntervalIntegrable bound μ a b)\n    (h_cont : ∀ᵐ t ∂μ, t ∈ Ι a b → ContinuousAt (fun x => F x t) x₀) :\n    ContinuousAt (fun x => ∫ t in a..b, F x t ∂μ) x₀ :=\n  tendsto_integral_filter_of_dominated_convergence bound hF_meas h_bound bound_integrable h_cont\n\n"}
{"name":"intervalIntegral.continuous_of_dominated_interval","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\nμ : MeasureTheory.Measure Real\nX : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : FirstCountableTopology X\nF : X → Real → E\nbound : Real → Real\na b : Real\nhF_meas : ∀ (x : X), MeasureTheory.AEStronglyMeasurable (F x) (μ.restrict (Set.uIoc a b))\nh_bound : ∀ (x : X), Filter.Eventually (fun t => Membership.mem (Set.uIoc a b) t → LE.le (Norm.norm (F x t)) (bound t)) (MeasureTheory.ae μ)\nbound_integrable : IntervalIntegrable bound μ a b\nh_cont : Filter.Eventually (fun t => Membership.mem (Set.uIoc a b) t → Continuous fun x => F x t) (MeasureTheory.ae μ)\n⊢ Continuous fun x => intervalIntegral (fun t => F x t) a b μ","decl":"/-- Continuity of interval integral with respect to a parameter.\n  Given `F : X → ℝ → E`, assume each `F x` is ae-measurable on `[a, b]`,\n  and assume it is bounded by a function integrable on `[a, b]` independent of `x`.\n  If `(fun x ↦ F x t)` is continuous for almost every `t` in `[a, b]`\n  then the same holds for `(fun x ↦ ∫ t in a..b, F x t ∂μ) s x₀`. -/\ntheorem continuous_of_dominated_interval {F : X → ℝ → E} {bound : ℝ → ℝ} {a b : ℝ}\n    (hF_meas : ∀ x, AEStronglyMeasurable (F x) <| μ.restrict <| Ι a b)\n    (h_bound : ∀ x, ∀ᵐ t ∂μ, t ∈ Ι a b → ‖F x t‖ ≤ bound t)\n    (bound_integrable : IntervalIntegrable bound μ a b)\n    (h_cont : ∀ᵐ t ∂μ, t ∈ Ι a b → Continuous fun x => F x t) :\n    Continuous fun x => ∫ t in a..b, F x t ∂μ :=\n  continuous_iff_continuousAt.mpr fun _ =>\n    continuousAt_of_dominated_interval (Eventually.of_forall hF_meas) (Eventually.of_forall h_bound)\n        bound_integrable <|\n      h_cont.mono fun _ himp hx => (himp hx).continuousAt\n\n"}
{"name":"intervalIntegral.continuousWithinAt_primitive","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b₀ b₁ b₂ : Real\nμ : MeasureTheory.Measure Real\nf : Real → E\nhb₀ : Eq (μ (Singleton.singleton b₀)) 0\nh_int : IntervalIntegrable f μ (Min.min a b₁) (Max.max a b₂)\n⊢ ContinuousWithinAt (fun b => intervalIntegral (fun x => f x) a b μ) (Set.Icc b₁ b₂) b₀","decl":"theorem continuousWithinAt_primitive (hb₀ : μ {b₀} = 0)\n    (h_int : IntervalIntegrable f μ (min a b₁) (max a b₂)) :\n    ContinuousWithinAt (fun b => ∫ x in a..b, f x ∂μ) (Icc b₁ b₂) b₀ := by\n  by_cases h₀ : b₀ ∈ Icc b₁ b₂\n  · have h₁₂ : b₁ ≤ b₂ := h₀.1.trans h₀.2\n    have min₁₂ : min b₁ b₂ = b₁ := min_eq_left h₁₂\n    have h_int' : ∀ {x}, x ∈ Icc b₁ b₂ → IntervalIntegrable f μ b₁ x := by\n      rintro x ⟨h₁, h₂⟩\n      apply h_int.mono_set\n      apply uIcc_subset_uIcc\n      · exact ⟨min_le_of_left_le (min_le_right a b₁),\n          h₁.trans (h₂.trans <| le_max_of_le_right <| le_max_right _ _)⟩\n      · exact ⟨min_le_of_left_le <| (min_le_right _ _).trans h₁,\n          le_max_of_le_right <| h₂.trans <| le_max_right _ _⟩\n    have : ∀ b ∈ Icc b₁ b₂,\n        ∫ x in a..b, f x ∂μ = (∫ x in a..b₁, f x ∂μ) + ∫ x in b₁..b, f x ∂μ := by\n      rintro b ⟨h₁, h₂⟩\n      rw [← integral_add_adjacent_intervals _ (h_int' ⟨h₁, h₂⟩)]\n      apply h_int.mono_set\n      apply uIcc_subset_uIcc\n      · exact ⟨min_le_of_left_le (min_le_left a b₁), le_max_of_le_right (le_max_left _ _)⟩\n      · exact ⟨min_le_of_left_le (min_le_right _ _),\n          le_max_of_le_right (h₁.trans <| h₂.trans (le_max_right a b₂))⟩\n    apply ContinuousWithinAt.congr _ this (this _ h₀); clear this\n    refine continuousWithinAt_const.add ?_\n    have :\n      (fun b => ∫ x in b₁..b, f x ∂μ) =ᶠ[𝓝[Icc b₁ b₂] b₀] fun b =>\n        ∫ x in b₁..b₂, indicator {x | x ≤ b} f x ∂μ := by\n      apply eventuallyEq_of_mem self_mem_nhdsWithin\n      exact fun b b_in => (integral_indicator b_in).symm\n    apply ContinuousWithinAt.congr_of_eventuallyEq _ this (integral_indicator h₀).symm\n    have : IntervalIntegrable (fun x => ‖f x‖) μ b₁ b₂ :=\n      IntervalIntegrable.norm (h_int' <| right_mem_Icc.mpr h₁₂)\n    refine continuousWithinAt_of_dominated_interval ?_ ?_ this ?_ <;> clear this\n    · filter_upwards [self_mem_nhdsWithin]\n      intro x hx\n      erw [aestronglyMeasurable_indicator_iff, Measure.restrict_restrict, Iic_inter_Ioc_of_le]\n      · rw [min₁₂]\n        exact (h_int' hx).1.aestronglyMeasurable\n      · exact le_max_of_le_right hx.2\n      exacts [measurableSet_Iic, measurableSet_Iic]\n    · filter_upwards with x; filter_upwards with t\n      dsimp [indicator]\n      split_ifs <;> simp\n    · have : ∀ᵐ t ∂μ, t < b₀ ∨ b₀ < t := by\n        filter_upwards [compl_mem_ae_iff.mpr hb₀] with x hx using Ne.lt_or_lt hx\n      apply this.mono\n      rintro x₀ (hx₀ | hx₀) -\n      · have : ∀ᶠ x in 𝓝[Icc b₁ b₂] b₀, {t : ℝ | t ≤ x}.indicator f x₀ = f x₀ := by\n          apply mem_nhdsWithin_of_mem_nhds\n          apply Eventually.mono (Ioi_mem_nhds hx₀)\n          intro x hx\n          simp [hx.le]\n        apply continuousWithinAt_const.congr_of_eventuallyEq this\n        simp [hx₀.le]\n      · have : ∀ᶠ x in 𝓝[Icc b₁ b₂] b₀, {t : ℝ | t ≤ x}.indicator f x₀ = 0 := by\n          apply mem_nhdsWithin_of_mem_nhds\n          apply Eventually.mono (Iio_mem_nhds hx₀)\n          intro x hx\n          simp [hx]\n        apply continuousWithinAt_const.congr_of_eventuallyEq this\n        simp [hx₀]\n  · apply continuousWithinAt_of_not_mem_closure\n    rwa [closure_Icc]\n\n"}
{"name":"intervalIntegral.continuousAt_parametric_primitive_of_dominated","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_1\nX : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : TopologicalSpace X\nμ : MeasureTheory.Measure Real\ninst✝ : FirstCountableTopology X\nF : X → Real → E\nbound : Real → Real\na b a₀ b₀ : Real\nx₀ : X\nhF_meas : ∀ (x : X), MeasureTheory.AEStronglyMeasurable (F x) (μ.restrict (Set.uIoc a b))\nh_bound : Filter.Eventually (fun x => Filter.Eventually (fun t => LE.le (Norm.norm (F x t)) (bound t)) (MeasureTheory.ae (μ.restrict (Set.uIoc a b)))) (nhds x₀)\nbound_integrable : IntervalIntegrable bound μ a b\nh_cont : Filter.Eventually (fun t => ContinuousAt (fun x => F x t) x₀) (MeasureTheory.ae (μ.restrict (Set.uIoc a b)))\nha₀ : Membership.mem (Set.Ioo a b) a₀\nhb₀ : Membership.mem (Set.Ioo a b) b₀\nhμb₀ : Eq (μ (Singleton.singleton b₀)) 0\n⊢ ContinuousAt (fun p => intervalIntegral (fun t => F p.1 t) a₀ p.2 μ) { fst := x₀, snd := b₀ }","decl":"theorem continuousAt_parametric_primitive_of_dominated [FirstCountableTopology X]\n    {F : X → ℝ → E} (bound : ℝ → ℝ) (a b : ℝ)\n    {a₀ b₀ : ℝ} {x₀ : X} (hF_meas : ∀ x, AEStronglyMeasurable (F x) (μ.restrict <| Ι a b))\n    (h_bound : ∀ᶠ x in 𝓝 x₀, ∀ᵐ t ∂μ.restrict <| Ι a b, ‖F x t‖ ≤ bound t)\n    (bound_integrable : IntervalIntegrable bound μ a b)\n    (h_cont : ∀ᵐ t ∂μ.restrict <| Ι a b, ContinuousAt (fun x ↦ F x t) x₀) (ha₀ : a₀ ∈ Ioo a b)\n    (hb₀ : b₀ ∈ Ioo a b) (hμb₀ : μ {b₀} = 0) :\n    ContinuousAt (fun p : X × ℝ ↦ ∫ t : ℝ in a₀..p.2, F p.1 t ∂μ) (x₀, b₀) := by\n  have hsub : ∀ {a₀ b₀}, a₀ ∈ Ioo a b → b₀ ∈ Ioo a b → Ι a₀ b₀ ⊆ Ι a b := fun ha₀ hb₀ ↦\n    (ordConnected_Ioo.uIoc_subset ha₀ hb₀).trans (Ioo_subset_Ioc_self.trans Ioc_subset_uIoc)\n  have Ioo_nhds : Ioo a b ∈ 𝓝 b₀ := Ioo_mem_nhds hb₀.1 hb₀.2\n  have Icc_nhds : Icc a b ∈ 𝓝 b₀ := Icc_mem_nhds hb₀.1 hb₀.2\n  have hx₀ : ∀ᵐ t : ℝ ∂μ.restrict (Ι a b), ‖F x₀ t‖ ≤ bound t := h_bound.self_of_nhds\n  have : ∀ᶠ p : X × ℝ in 𝓝 (x₀, b₀),\n      ∫ s in a₀..p.2, F p.1 s ∂μ =\n        ∫ s in a₀..b₀, F p.1 s ∂μ + ∫ s in b₀..p.2, F x₀ s ∂μ +\n          ∫ s in b₀..p.2, F p.1 s - F x₀ s ∂μ := by\n    rw [nhds_prod_eq]\n    refine (h_bound.prod_mk Ioo_nhds).mono ?_\n    rintro ⟨x, t⟩ ⟨hx : ∀ᵐ t : ℝ ∂μ.restrict (Ι a b), ‖F x t‖ ≤ bound t, ht : t ∈ Ioo a b⟩\n    dsimp\n    have hiF : ∀ {x a₀ b₀},\n        (∀ᵐ t : ℝ ∂μ.restrict (Ι a b), ‖F x t‖ ≤ bound t) → a₀ ∈ Ioo a b → b₀ ∈ Ioo a b →\n          IntervalIntegrable (F x) μ a₀ b₀ := fun {x a₀ b₀} hx ha₀ hb₀ ↦\n      (bound_integrable.mono_set_ae <| Eventually.of_forall <| hsub ha₀ hb₀).mono_fun'\n        ((hF_meas x).mono_set <| hsub ha₀ hb₀)\n        (ae_restrict_of_ae_restrict_of_subset (hsub ha₀ hb₀) hx)\n    rw [intervalIntegral.integral_sub, add_assoc, add_sub_cancel,\n      intervalIntegral.integral_add_adjacent_intervals]\n    · exact hiF hx ha₀ hb₀\n    · exact hiF hx hb₀ ht\n    · exact hiF hx hb₀ ht\n    · exact hiF hx₀ hb₀ ht\n  rw [continuousAt_congr this]; clear this\n  refine (ContinuousAt.add ?_ ?_).add ?_\n  · exact (intervalIntegral.continuousAt_of_dominated_interval\n        (Eventually.of_forall fun x ↦ (hF_meas x).mono_set <| hsub ha₀ hb₀)\n          (h_bound.mono fun x hx ↦\n            ae_imp_of_ae_restrict <| ae_restrict_of_ae_restrict_of_subset (hsub ha₀ hb₀) hx)\n          (bound_integrable.mono_set_ae <| Eventually.of_forall <| hsub ha₀ hb₀) <|\n          ae_imp_of_ae_restrict <| ae_restrict_of_ae_restrict_of_subset (hsub ha₀ hb₀) h_cont).fst'\n  · refine (?_ : ContinuousAt (fun t ↦ ∫ s in b₀..t, F x₀ s ∂μ) b₀).snd'\n    apply ContinuousWithinAt.continuousAt _ (Icc_mem_nhds hb₀.1 hb₀.2)\n    apply intervalIntegral.continuousWithinAt_primitive hμb₀\n    rw [min_eq_right hb₀.1.le, max_eq_right hb₀.2.le]\n    exact bound_integrable.mono_fun' (hF_meas x₀) hx₀\n  · suffices Tendsto (fun x : X × ℝ ↦ ∫ s in b₀..x.2, F x.1 s - F x₀ s ∂μ) (𝓝 (x₀, b₀)) (𝓝 0) by\n      simpa [ContinuousAt]\n    have : ∀ᶠ p : X × ℝ in 𝓝 (x₀, b₀),\n        ‖∫ s in b₀..p.2, F p.1 s - F x₀ s ∂μ‖ ≤ |∫ s in b₀..p.2, 2 * bound s ∂μ| := by\n      rw [nhds_prod_eq]\n      refine (h_bound.prod_mk Ioo_nhds).mono ?_\n      rintro ⟨x, t⟩ ⟨hx : ∀ᵐ t ∂μ.restrict (Ι a b), ‖F x t‖ ≤ bound t, ht : t ∈ Ioo a b⟩\n      have H : ∀ᵐ t : ℝ ∂μ.restrict (Ι b₀ t), ‖F x t - F x₀ t‖ ≤ 2 * bound t := by\n        apply (ae_restrict_of_ae_restrict_of_subset (hsub hb₀ ht) (hx.and hx₀)).mono\n        rintro s ⟨hs₁, hs₂⟩\n        calc\n          ‖F x s - F x₀ s‖ ≤ ‖F x s‖ + ‖F x₀ s‖ := norm_sub_le _ _\n          _ ≤ 2 * bound s := by linarith only [hs₁, hs₂]\n      exact intervalIntegral.norm_integral_le_of_norm_le H\n        ((bound_integrable.mono_set' <| hsub hb₀ ht).const_mul 2)\n    apply squeeze_zero_norm' this\n    have : Tendsto (fun t ↦ ∫ s in b₀..t, 2 * bound s ∂μ) (𝓝 b₀) (𝓝 0) := by\n      suffices ContinuousAt (fun t ↦ ∫ s in b₀..t, 2 * bound s ∂μ) b₀ by\n        simpa [ContinuousAt] using this\n      apply ContinuousWithinAt.continuousAt _ Icc_nhds\n      apply intervalIntegral.continuousWithinAt_primitive hμb₀\n      apply IntervalIntegrable.const_mul\n      apply bound_integrable.mono_set'\n      rw [min_eq_right hb₀.1.le, max_eq_right hb₀.2.le]\n    rw [nhds_prod_eq]\n    exact (continuous_abs.tendsto' _ _ abs_zero).comp (this.comp tendsto_snd)\n\n"}
{"name":"intervalIntegral.continuousOn_primitive","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\na b : Real\nμ : MeasureTheory.Measure Real\nf : Real → E\ninst✝ : MeasureTheory.NoAtoms μ\nh_int : MeasureTheory.IntegrableOn f (Set.Icc a b) μ\n⊢ ContinuousOn (fun x => MeasureTheory.integral (μ.restrict (Set.Ioc a x)) fun t => f t) (Set.Icc a b)","decl":"theorem continuousOn_primitive (h_int : IntegrableOn f (Icc a b) μ) :\n    ContinuousOn (fun x => ∫ t in Ioc a x, f t ∂μ) (Icc a b) := by\n  by_cases h : a ≤ b\n  · have : ∀ x ∈ Icc a b, ∫ t in Ioc a x, f t ∂μ = ∫ t in a..x, f t ∂μ := by\n      intro x x_in\n      simp_rw [integral_of_le x_in.1]\n    rw [continuousOn_congr this]\n    intro x₀ _\n    refine continuousWithinAt_primitive (measure_singleton x₀) ?_\n    simp only [intervalIntegrable_iff_integrableOn_Ioc_of_le, min_eq_left, max_eq_right, h,\n      min_self]\n    exact h_int.mono Ioc_subset_Icc_self le_rfl\n  · rw [Icc_eq_empty h]\n    exact continuousOn_empty _\n\n"}
{"name":"intervalIntegral.continuousOn_primitive_Icc","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\na b : Real\nμ : MeasureTheory.Measure Real\nf : Real → E\ninst✝ : MeasureTheory.NoAtoms μ\nh_int : MeasureTheory.IntegrableOn f (Set.Icc a b) μ\n⊢ ContinuousOn (fun x => MeasureTheory.integral (μ.restrict (Set.Icc a x)) fun t => f t) (Set.Icc a b)","decl":"theorem continuousOn_primitive_Icc (h_int : IntegrableOn f (Icc a b) μ) :\n    ContinuousOn (fun x => ∫ t in Icc a x, f t ∂μ) (Icc a b) := by\n  have aux : (fun x => ∫ t in Icc a x, f t ∂μ) = fun x => ∫ t in Ioc a x, f t ∂μ := by\n    ext x\n    exact integral_Icc_eq_integral_Ioc\n  rw [aux]\n  exact continuousOn_primitive h_int\n\n"}
{"name":"intervalIntegral.continuousOn_primitive_interval'","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\na b₁ b₂ : Real\nμ : MeasureTheory.Measure Real\nf : Real → E\ninst✝ : MeasureTheory.NoAtoms μ\nh_int : IntervalIntegrable f μ b₁ b₂\nha : Membership.mem (Set.uIcc b₁ b₂) a\n⊢ ContinuousOn (fun b => intervalIntegral (fun x => f x) a b μ) (Set.uIcc b₁ b₂)","decl":"/-- Note: this assumes that `f` is `IntervalIntegrable`, in contrast to some other lemmas here. -/\ntheorem continuousOn_primitive_interval' (h_int : IntervalIntegrable f μ b₁ b₂)\n    (ha : a ∈ [[b₁, b₂]]) : ContinuousOn (fun b => ∫ x in a..b, f x ∂μ) [[b₁, b₂]] := fun _ _ ↦ by\n  refine continuousWithinAt_primitive (measure_singleton _) ?_\n  rw [min_eq_right ha.1, max_eq_right ha.2]\n  simpa [intervalIntegrable_iff, uIoc] using h_int\n\n"}
{"name":"intervalIntegral.continuousOn_primitive_interval","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\na b : Real\nμ : MeasureTheory.Measure Real\nf : Real → E\ninst✝ : MeasureTheory.NoAtoms μ\nh_int : MeasureTheory.IntegrableOn f (Set.uIcc a b) μ\n⊢ ContinuousOn (fun x => intervalIntegral (fun t => f t) a x μ) (Set.uIcc a b)","decl":"theorem continuousOn_primitive_interval (h_int : IntegrableOn f (uIcc a b) μ) :\n    ContinuousOn (fun x => ∫ t in a..x, f t ∂μ) (uIcc a b) :=\n  continuousOn_primitive_interval' h_int.intervalIntegrable left_mem_uIcc\n\n"}
{"name":"intervalIntegral.continuousOn_primitive_interval_left","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\na b : Real\nμ : MeasureTheory.Measure Real\nf : Real → E\ninst✝ : MeasureTheory.NoAtoms μ\nh_int : MeasureTheory.IntegrableOn f (Set.uIcc a b) μ\n⊢ ContinuousOn (fun x => intervalIntegral (fun t => f t) x b μ) (Set.uIcc a b)","decl":"theorem continuousOn_primitive_interval_left (h_int : IntegrableOn f (uIcc a b) μ) :\n    ContinuousOn (fun x => ∫ t in x..b, f t ∂μ) (uIcc a b) := by\n  rw [uIcc_comm a b] at h_int ⊢\n  simp only [integral_symm b]\n  exact (continuousOn_primitive_interval h_int).neg\n\n"}
{"name":"intervalIntegral.continuous_primitive","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nμ : MeasureTheory.Measure Real\nf : Real → E\ninst✝ : MeasureTheory.NoAtoms μ\nh_int : ∀ (a b : Real), IntervalIntegrable f μ a b\na : Real\n⊢ Continuous fun b => intervalIntegral (fun x => f x) a b μ","decl":"theorem continuous_primitive (h_int : ∀ a b, IntervalIntegrable f μ a b) (a : ℝ) :\n    Continuous fun b => ∫ x in a..b, f x ∂μ := by\n  rw [continuous_iff_continuousAt]\n  intro b₀\n  cases' exists_lt b₀ with b₁ hb₁\n  cases' exists_gt b₀ with b₂ hb₂\n  apply ContinuousWithinAt.continuousAt _ (Icc_mem_nhds hb₁ hb₂)\n  exact continuousWithinAt_primitive (measure_singleton b₀) (h_int _ _)\n\n"}
{"name":"MeasureTheory.Integrable.continuous_primitive","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nμ : MeasureTheory.Measure Real\nf : Real → E\ninst✝ : MeasureTheory.NoAtoms μ\nh_int : MeasureTheory.Integrable f μ\na : Real\n⊢ Continuous fun b => intervalIntegral (fun x => f x) a b μ","decl":"nonrec theorem _root_.MeasureTheory.Integrable.continuous_primitive (h_int : Integrable f μ)\n    (a : ℝ) : Continuous fun b => ∫ x in a..b, f x ∂μ :=\n  continuous_primitive (fun _ _ => h_int.intervalIntegrable) a\n\n"}
{"name":"intervalIntegral.continuous_parametric_primitive_of_continuous","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_1\nX : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : TopologicalSpace X\nμ : MeasureTheory.Measure Real\ninst✝¹ : MeasureTheory.NoAtoms μ\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nf : X → Real → E\na₀ : Real\nhf : Continuous (Function.uncurry f)\n⊢ Continuous fun p => intervalIntegral (fun t => f p.1 t) a₀ p.2 μ","decl":"theorem continuous_parametric_primitive_of_continuous\n    {a₀ : ℝ} (hf : Continuous f.uncurry) :\n    Continuous fun p : X × ℝ ↦ ∫ t in a₀..p.2, f p.1 t ∂μ := by\n  -- We will prove continuity at a point `(q, b₀)`.\n  rw [continuous_iff_continuousAt]\n  rintro ⟨q, b₀⟩\n  apply Metric.continuousAt_iff'.2 (fun ε εpos ↦ ?_)\n  -- choose `a` and `b` such that `(a, b)` contains both `a₀` and `b₀`. We will use uniform\n  -- estimates on a neighborhood of the compact set `{q} × [a, b]`.\n  cases' exists_lt (min a₀ b₀) with a a_lt\n  cases' exists_gt (max a₀ b₀) with b lt_b\n  rw [lt_min_iff] at a_lt\n  rw [max_lt_iff] at lt_b\n  have : IsCompact ({q} ×ˢ (Icc a b)) := isCompact_singleton.prod isCompact_Icc\n  -- let `M` be a bound for `f` on the compact set `{q} × [a, b]`.\n  obtain ⟨M, hM⟩ := this.bddAbove_image hf.norm.continuousOn\n  -- let `δ` be small enough to satisfy several properties that will show up later.\n  obtain ⟨δ, δpos, hδ, h'δ, h''δ⟩ : ∃ (δ : ℝ), 0 < δ ∧ δ < 1 ∧ Icc (b₀ - δ) (b₀ + δ) ⊆ Icc a b ∧\n      (M + 1) * (μ (Icc (b₀ - δ) (b₀ + δ))).toReal + δ * (μ (Icc a b)).toReal < ε := by\n    have A : ∀ᶠ δ in 𝓝[>] (0 : ℝ), δ ∈ Ioo 0 1 := Ioo_mem_nhdsGT zero_lt_one\n    have B : ∀ᶠ δ in 𝓝 0, Icc (b₀ - δ) (b₀ + δ) ⊆ Icc a b := by\n      have I : Tendsto (fun δ ↦ b₀ - δ) (𝓝 0) (𝓝 (b₀ - 0)) := tendsto_const_nhds.sub tendsto_id\n      have J : Tendsto (fun δ ↦ b₀ + δ) (𝓝 0) (𝓝 (b₀ + 0)) := tendsto_const_nhds.add tendsto_id\n      simp only [sub_zero, add_zero] at I J\n      filter_upwards [(tendsto_order.1 I).1 _ a_lt.2, (tendsto_order.1 J).2 _ lt_b.2] with δ hδ h'δ\n      exact Icc_subset_Icc hδ.le h'δ.le\n    have C : ∀ᶠ δ in 𝓝 0,\n        (M + 1) * (μ (Icc (b₀ - δ) (b₀ + δ))).toReal + δ * (μ (Icc a b)).toReal < ε := by\n      suffices Tendsto\n        (fun δ ↦ (M + 1) * (μ (Icc (b₀ - δ) (b₀ + δ))).toReal + δ * (μ (Icc a b)).toReal)\n          (𝓝 0) (𝓝 ((M + 1) * (0 : ℝ≥0∞).toReal + 0 * (μ (Icc a b)).toReal)) by\n        simp only [zero_toReal, mul_zero, zero_mul, add_zero] at this\n        exact (tendsto_order.1 this).2 _ εpos\n      apply Tendsto.add (Tendsto.mul tendsto_const_nhds _)\n        (Tendsto.mul tendsto_id tendsto_const_nhds)\n      exact (tendsto_toReal zero_ne_top).comp (tendsto_measure_Icc _ _)\n    rcases (A.and ((B.and C).filter_mono nhdsWithin_le_nhds)).exists with ⟨δ, hδ, h'δ, h''δ⟩\n    exact ⟨δ, hδ.1, hδ.2, h'δ, h''δ⟩\n  -- By compactness of `[a, b]` and continuity of `f` there, if `p` is close enough to `q`\n  -- then `f p x` is `δ`-close to `f q x`, uniformly in `x ∈ [a, b]`.\n  -- (Note in particular that this implies a bound `M + δ ≤ M + 1` for `f p x`).\n  obtain ⟨v, v_mem, hv⟩ : ∃ v ∈ 𝓝[univ] q, ∀ p ∈ v, ∀ x ∈ Icc a b, dist (f p x) (f q x) < δ :=\n    IsCompact.mem_uniformity_of_prod isCompact_Icc hf.continuousOn (mem_univ _)\n      (dist_mem_uniformity δpos)\n  -- for `p` in this neighborhood and `s` which is `δ`-close to `b₀`, we will show that the\n  -- integrals are `ε`-close.\n  have : v ×ˢ (Ioo (b₀ - δ) (b₀ + δ)) ∈ 𝓝 (q, b₀) := by\n    rw [nhdsWithin_univ] at v_mem\n    simp only [prod_mem_nhds_iff, v_mem, true_and]\n    apply Ioo_mem_nhds <;> linarith\n  filter_upwards [this]\n  rintro ⟨p, s⟩ ⟨hp : p ∈ v, hs : s ∈ Ioo (b₀ - δ) (b₀ + δ)⟩\n  simp only [dist_eq_norm] at hv ⊢\n  have J r u v : IntervalIntegrable (f r) μ u v := (hf.uncurry_left _).intervalIntegrable _ _\n  /- we compute the difference between the integrals by splitting the contribution of the change\n  from `b₀` to `s` (which gives a contribution controlled by the measure of `(b₀ - δ, b₀ + δ)`,\n  small enough thanks to our choice of `δ`) and the change from `q` to `p`, which is small as\n  `f p x` and `f q x` are uniformly close by design. -/\n  calc\n  ‖∫ t in a₀..s, f p t ∂μ - ∫ t in a₀..b₀, f q t ∂μ‖\n    = ‖(∫ t in a₀..s, f p t ∂μ - ∫ t in a₀..b₀, f p t ∂μ)\n        + (∫ t in a₀..b₀, f p t ∂μ - ∫ t in a₀..b₀, f q t ∂μ)‖ := by congr 1; abel\n  _ ≤ ‖∫ t in a₀..s, f p t ∂μ - ∫ t in a₀..b₀, f p t ∂μ‖\n        + ‖∫ t in a₀..b₀, f p t ∂μ - ∫ t in a₀..b₀, f q t ∂μ‖ := norm_add_le _ _\n  _ = ‖∫ t in b₀..s, f p t ∂μ‖ + ‖∫ t in a₀..b₀, (f p t - f q t) ∂μ‖ := by\n      congr 2\n      · rw [integral_interval_sub_left (J _ _ _) (J _ _ _)]\n      · rw [integral_sub (J _ _ _) (J _ _ _)]\n  _ ≤ ∫ t in Ι b₀ s, ‖f p t‖ ∂μ + ∫ t in Ι a₀ b₀, ‖f p t - f q t‖ ∂μ := by\n      gcongr\n      · exact norm_integral_le_integral_norm_Ioc\n      · exact norm_integral_le_integral_norm_Ioc\n  _ ≤ ∫ t in Icc (b₀ - δ) (b₀ + δ), ‖f p t‖ ∂μ + ∫ t in Icc a b, ‖f p t - f q t‖ ∂μ := by\n      gcongr\n      · apply setIntegral_mono_set\n        · exact (hf.uncurry_left _).norm.integrableOn_Icc\n        · exact Eventually.of_forall (fun x ↦ norm_nonneg _)\n        · have : Ι b₀ s ⊆ Icc (b₀ - δ) (b₀ + δ) := by\n            apply uIoc_subset_uIcc.trans (uIcc_subset_Icc ?_ ⟨hs.1.le, hs.2.le⟩ )\n            simp [δpos.le]\n          exact Eventually.of_forall this\n      · apply setIntegral_mono_set\n        · exact ((hf.uncurry_left _).sub (hf.uncurry_left _)).norm.integrableOn_Icc\n        · exact Eventually.of_forall (fun x ↦ norm_nonneg _)\n        · have : Ι a₀ b₀ ⊆ Icc a b := uIoc_subset_uIcc.trans\n            (uIcc_subset_Icc ⟨a_lt.1.le, lt_b.1.le⟩ ⟨a_lt.2.le, lt_b.2.le⟩)\n          exact Eventually.of_forall this\n  _ ≤ ∫ t in Icc (b₀ - δ) (b₀ + δ), M + 1 ∂μ + ∫ _t in Icc a b, δ ∂μ := by\n      gcongr ?_ + ?_\n      · apply setIntegral_mono_on\n        · exact (hf.uncurry_left _).norm.integrableOn_Icc\n        · exact continuous_const.integrableOn_Icc\n        · exact measurableSet_Icc\n        · intro x hx\n          calc ‖f p x‖ = ‖f q x + (f p x - f q x)‖ := by congr; abel\n          _ ≤ ‖f q x‖ + ‖f p x - f q x‖ := norm_add_le _ _\n          _ ≤ M + δ := by\n              gcongr\n              · apply hM\n                change (fun x ↦ ‖Function.uncurry f x‖) (q, x) ∈ _\n                apply mem_image_of_mem\n                simp only [singleton_prod, mem_image, Prod.mk.injEq, true_and, exists_eq_right]\n                exact h'δ hx\n              · exact le_of_lt (hv _ hp _ (h'δ hx))\n          _ ≤ M + 1 := by linarith\n      · apply setIntegral_mono_on\n        · exact ((hf.uncurry_left _).sub (hf.uncurry_left _)).norm.integrableOn_Icc\n        · exact continuous_const.integrableOn_Icc\n        · exact measurableSet_Icc\n        · intro x hx\n          exact le_of_lt (hv _ hp _ hx)\n  _ = (M + 1) * (μ (Icc (b₀ - δ) (b₀ + δ))).toReal + δ * (μ (Icc a b)).toReal := by simp [mul_comm]\n  _ < ε := h''δ\n\n"}
{"name":"intervalIntegral.continuous_parametric_intervalIntegral_of_continuous","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_1\nX : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : TopologicalSpace X\nμ : MeasureTheory.Measure Real\ninst✝¹ : MeasureTheory.NoAtoms μ\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nf : X → Real → E\na₀ : Real\nhf : Continuous (Function.uncurry f)\ns : X → Real\nhs : Continuous s\n⊢ Continuous fun x => intervalIntegral (fun t => f x t) a₀ (s x) μ","decl":"@[fun_prop]\ntheorem continuous_parametric_intervalIntegral_of_continuous {a₀ : ℝ}\n    (hf : Continuous f.uncurry) {s : X → ℝ} (hs : Continuous s) :\n    Continuous fun x ↦ ∫ t in a₀..s x, f x t ∂μ :=\n  show Continuous ((fun p : X × ℝ ↦ ∫ t in a₀..p.2, f p.1 t ∂μ) ∘ fun x ↦ (x, s x)) from\n    (continuous_parametric_primitive_of_continuous hf).comp₂ continuous_id hs\n\n"}
{"name":"intervalIntegral.continuous_parametric_intervalIntegral_of_continuous'","module":"Mathlib.MeasureTheory.Integral.DominatedConvergence","initialProofState":"E : Type u_1\nX : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : TopologicalSpace X\nμ : MeasureTheory.Measure Real\ninst✝¹ : MeasureTheory.NoAtoms μ\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nf : X → Real → E\nhf : Continuous (Function.uncurry f)\na₀ b₀ : Real\n⊢ Continuous fun x => intervalIntegral (fun t => f x t) a₀ b₀ μ","decl":"theorem continuous_parametric_intervalIntegral_of_continuous'\n    (hf : Continuous f.uncurry) (a₀ b₀ : ℝ) :\n    Continuous fun x ↦ ∫ t in a₀..b₀, f x t ∂μ := by fun_prop\n\n"}
