{"name":"AddCircle.measurable_mk'","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"a : Real\n‚ä¢ Measurable QuotientAddGroup.mk","decl":"@[measurability]\nprotected theorem AddCircle.measurable_mk' {a : ‚Ñù} :\n    Measurable (Œ≤ := AddCircle a) ((‚Üë) : ‚Ñù ‚Üí AddCircle a) :=\n  Continuous.measurable <| AddCircle.continuous_mk' a\n\n"}
{"name":"isAddFundamentalDomain_Ioc","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\nhT : LT.lt 0 T\nt : Real\nŒº : autoParam (MeasureTheory.Measure Real) _auto‚úù\n‚ä¢ MeasureTheory.IsAddFundamentalDomain (Subtype fun x => Membership.mem (AddSubgroup.zmultiples T) x) (Set.Ioc t (HAdd.hAdd t T)) Œº","decl":"theorem isAddFundamentalDomain_Ioc {T : ‚Ñù} (hT : 0 < T) (t : ‚Ñù)\n    (Œº : Measure ‚Ñù := by volume_tac) :\n    IsAddFundamentalDomain (AddSubgroup.zmultiples T) (Ioc t (t + T)) Œº := by\n  refine IsAddFundamentalDomain.mk' nullMeasurableSet_Ioc fun x => ?_\n  have : Bijective (codRestrict (fun n : ‚Ñ§ => n ‚Ä¢ T) (AddSubgroup.zmultiples T) _) :=\n    (Equiv.ofInjective (fun n : ‚Ñ§ => n ‚Ä¢ T) (zsmul_left_strictMono hT).injective).bijective\n  refine this.existsUnique_iff.2 ?_\n  simpa only [add_comm x] using existsUnique_add_zsmul_mem_Ioc hT x t\n\n"}
{"name":"isAddFundamentalDomain_Ioc'","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\nhT : LT.lt 0 T\nt : Real\nŒº : autoParam (MeasureTheory.Measure Real) _auto‚úù\n‚ä¢ MeasureTheory.IsAddFundamentalDomain (Subtype fun x => Membership.mem (AddSubgroup.zmultiples T).op x) (Set.Ioc t (HAdd.hAdd t T)) Œº","decl":"theorem isAddFundamentalDomain_Ioc' {T : ‚Ñù} (hT : 0 < T) (t : ‚Ñù) (Œº : Measure ‚Ñù := by volume_tac) :\n    IsAddFundamentalDomain (AddSubgroup.op <| .zmultiples T) (Ioc t (t + T)) Œº := by\n  refine IsAddFundamentalDomain.mk' nullMeasurableSet_Ioc fun x => ?_\n  have : Bijective (codRestrict (fun n : ‚Ñ§ => n ‚Ä¢ T) (AddSubgroup.zmultiples T) _) :=\n    (Equiv.ofInjective (fun n : ‚Ñ§ => n ‚Ä¢ T) (zsmul_left_strictMono hT).injective).bijective\n  refine (AddSubgroup.equivOp _).bijective.comp this |>.existsUnique_iff.2 ?_\n  simpa using existsUnique_add_zsmul_mem_Ioc hT x t\n\n"}
{"name":"AddCircle.measure_univ","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume Set.univ) (ENNReal.ofReal T)","decl":"@[simp]\nprotected theorem measure_univ : volume (Set.univ : Set (AddCircle T)) = ENNReal.ofReal T := by\n  dsimp [volume]\n  rw [‚Üê PositiveCompacts.coe_top]\n  simp [addHaarMeasure_self (G := AddCircle T), -PositiveCompacts.coe_top]\n\n"}
{"name":"AddCircle.instIsAddHaarMeasureRealVolume","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\n‚ä¢ MeasureTheory.MeasureSpace.volume.IsAddHaarMeasure","decl":"instance : IsAddHaarMeasure (volume : Measure (AddCircle T)) :=\n  IsAddHaarMeasure.smul _ (by simp [hT.out]) ENNReal.ofReal_ne_top\n\n"}
{"name":"AddCircle.isFiniteMeasure","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\n‚ä¢ MeasureTheory.IsFiniteMeasure MeasureTheory.MeasureSpace.volume","decl":"instance isFiniteMeasure : IsFiniteMeasure (volume : Measure (AddCircle T)) where\n  measure_univ_lt_top := by simp\n\n"}
{"name":"AddCircle.instHasAddFundamentalDomainSubtypeAddOppositeRealMemAddSubgroupOpZmultiples","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\n‚ä¢ MeasureTheory.HasAddFundamentalDomain (Subtype fun x => Membership.mem (AddSubgroup.zmultiples T).op x) Real MeasureTheory.MeasureSpace.volume","decl":"instance : HasAddFundamentalDomain (AddSubgroup.op <| .zmultiples T) ‚Ñù where\n  ExistsIsAddFundamentalDomain := ‚ü®Ioc 0 (0 + T), isAddFundamentalDomain_Ioc' Fact.out 0‚ü©\n\n"}
{"name":"AddCircle.instAddQuotientMeasureEqMeasurePreimageSubtypeAddOppositeRealMemAddSubgroupOpZmultiplesVolume","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\n‚ä¢ MeasureTheory.AddQuotientMeasureEqMeasurePreimage MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume","decl":"instance : AddQuotientMeasureEqMeasurePreimage volume (volume : Measure (AddCircle T)) := by\n  apply MeasureTheory.leftInvariantIsAddQuotientMeasureEqMeasurePreimage\n  simp [(isAddFundamentalDomain_Ioc' hT.out 0).covolume_eq_volume, AddCircle.measure_univ]\n\n"}
{"name":"AddCircle.measurePreserving_mk","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\nt : Real\n‚ä¢ MeasureTheory.MeasurePreserving QuotientAddGroup.mk (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc t (HAdd.hAdd t T))) MeasureTheory.MeasureSpace.volume","decl":"/-- The covering map from `‚Ñù` to the \"additive circle\" `‚Ñù ‚ß∏ (‚Ñ§ ‚àô T)` is measure-preserving,\nconsidered with respect to the standard measure (defined to be the Haar measure of total mass `T`)\non the additive circle, and with respect to the restriction of Lebsegue measure on `‚Ñù` to an\ninterval (t, t + T]. -/\nprotected theorem measurePreserving_mk (t : ‚Ñù) :\n    MeasurePreserving (Œ≤ := AddCircle T) ((‚Üë) : ‚Ñù ‚Üí AddCircle T)\n      (volume.restrict (Ioc t (t + T))) :=\n  measurePreserving_quotientAddGroup_mk_of_AddQuotientMeasureEqMeasurePreimage\n    volume (ùìï := Ioc t (t+T)) (isAddFundamentalDomain_Ioc' hT.out _) _\n\n"}
{"name":"AddCircle.add_projection_respects_measure","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\nt : Real\nU : Set (AddCircle T)\nmeas_U : MeasurableSet U\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume U) (MeasureTheory.MeasureSpace.volume (Inter.inter (Set.preimage QuotientAddGroup.mk U) (Set.Ioc t (HAdd.hAdd t T))))","decl":"lemma add_projection_respects_measure (t : ‚Ñù) {U : Set (AddCircle T)} (meas_U : MeasurableSet U) :\n    volume U = volume (QuotientAddGroup.mk ‚Åª¬π' U ‚à© (Ioc t (t + T))) :=\n  (isAddFundamentalDomain_Ioc' hT.out _).addProjection_respects_measure_apply\n    (volume : Measure (AddCircle T)) meas_U\n\n"}
{"name":"AddCircle.volume_closedBall","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\nx : AddCircle T\nŒµ : Real\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (Metric.closedBall x Œµ)) (ENNReal.ofReal (Min.min T (HMul.hMul 2 Œµ)))","decl":"theorem volume_closedBall {x : AddCircle T} (Œµ : ‚Ñù) :\n    volume (Metric.closedBall x Œµ) = ENNReal.ofReal (min T (2 * Œµ)) := by\n  have hT' : |T| = T := abs_eq_self.mpr hT.out.le\n  let I := Ioc (-(T / 2)) (T / 2)\n  have h‚ÇÅ : Œµ < T / 2 ‚Üí Metric.closedBall (0 : ‚Ñù) Œµ ‚à© I = Metric.closedBall (0 : ‚Ñù) Œµ := by\n    intro hŒµ\n    rw [inter_eq_left, Real.closedBall_eq_Icc, zero_sub, zero_add]\n    rintro y ‚ü®hy‚ÇÅ, hy‚ÇÇ‚ü©; constructor <;> linarith\n  have h‚ÇÇ : (‚Üë) ‚Åª¬π' Metric.closedBall (0 : AddCircle T) Œµ ‚à© I =\n      if Œµ < T / 2 then Metric.closedBall (0 : ‚Ñù) Œµ else I := by\n    conv_rhs => rw [‚Üê if_ctx_congr (Iff.rfl : Œµ < T / 2 ‚Üî Œµ < T / 2) h‚ÇÅ fun _ => rfl, ‚Üê hT']\n    apply coe_real_preimage_closedBall_inter_eq\n    simpa only [hT', Real.closedBall_eq_Icc, zero_add, zero_sub] using Ioc_subset_Icc_self\n  rw [addHaar_closedBall_center, add_projection_respects_measure T (-(T/2))\n    measurableSet_closedBall, (by linarith : -(T / 2) + T = T / 2), h‚ÇÇ]\n  by_cases hŒµ : Œµ < T / 2\n  ¬∑ simp [hŒµ, min_eq_right (by linarith : 2 * Œµ ‚â§ T)]\n  ¬∑ simp [I, hŒµ, min_eq_left (by linarith : T ‚â§ 2 * Œµ)]\n\n"}
{"name":"AddCircle.instIsUnifLocDoublingMeasureRealVolume","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\n‚ä¢ IsUnifLocDoublingMeasure MeasureTheory.MeasureSpace.volume","decl":"instance : IsUnifLocDoublingMeasure (volume : Measure (AddCircle T)) := by\n  refine ‚ü®‚ü®Real.toNNReal 2, Filter.Eventually.of_forall fun Œµ x => ?_‚ü©‚ü©\n  simp only [volume_closedBall]\n  erw [‚Üê ENNReal.ofReal_mul zero_le_two]\n  apply ENNReal.ofReal_le_ofReal\n  rw [mul_min_of_nonneg _ _ (zero_le_two : (0 : ‚Ñù) ‚â§ 2)]\n  exact min_le_min (by linarith [hT.out]) (le_refl _)\n\n"}
{"name":"AddCircle.lintegral_preimage","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\nt : Real\nf : AddCircle T ‚Üí ENNReal\n‚ä¢ Eq (MeasureTheory.lintegral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc t (HAdd.hAdd t T))) fun a => f ‚Üëa) (MeasureTheory.lintegral MeasureTheory.MeasureSpace.volume fun b => f b)","decl":"attribute [local instance] Subtype.measureSpace in\n/-- The lower integral of a function over `AddCircle T` is equal to the lower integral over an\ninterval (t, t + T] in `‚Ñù` of its lift to `‚Ñù`. -/\nprotected theorem lintegral_preimage (t : ‚Ñù) (f : AddCircle T ‚Üí ‚Ñù‚â•0‚àû) :\n    (‚à´‚Åª a in Ioc t (t + T), f a) = ‚à´‚Åª b : AddCircle T, f b := by\n  have m : MeasurableSet (Ioc t (t + T)) := measurableSet_Ioc\n  have := lintegral_map_equiv (Œº := volume) f (measurableEquivIoc T t).symm\n  simp only [measurableEquivIoc, equivIoc, QuotientAddGroup.equivIocMod, MeasurableEquiv.symm_mk,\n    MeasurableEquiv.coe_mk, Equiv.coe_fn_symm_mk] at this\n  rw [‚Üê (AddCircle.measurePreserving_mk T t).map_eq]\n  convert this.symm using 1\n  ¬∑ rw [‚Üê map_comap_subtype_coe m _]\n    exact MeasurableEmbedding.lintegral_map (MeasurableEmbedding.subtype_coe m) _\n  ¬∑ congr 1\n    have : ((‚Üë) : Ioc t (t + T) ‚Üí AddCircle T) = ((‚Üë) : ‚Ñù ‚Üí AddCircle T) ‚àò ((‚Üë) : _ ‚Üí ‚Ñù) := by\n      ext1 x; rfl\n    simp_rw [this]\n    rw [‚Üê map_map AddCircle.measurable_mk' measurable_subtype_coe, ‚Üê map_comap_subtype_coe m]\n    rfl\n\n"}
{"name":"AddCircle.integral_preimage","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\nE : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nt : Real\nf : AddCircle T ‚Üí E\n‚ä¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc t (HAdd.hAdd t T))) fun a => f ‚Üëa) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun b => f b)","decl":"attribute [local instance] Subtype.measureSpace in\n/-- The integral of an almost-everywhere strongly measurable function over `AddCircle T` is equal\nto the integral over an interval (t, t + T] in `‚Ñù` of its lift to `‚Ñù`. -/\nprotected theorem integral_preimage (t : ‚Ñù) (f : AddCircle T ‚Üí E) :\n    (‚à´ a in Ioc t (t + T), f a) = ‚à´ b : AddCircle T, f b := by\n  have m : MeasurableSet (Ioc t (t + T)) := measurableSet_Ioc\n  have := integral_map_equiv (Œº := volume) (measurableEquivIoc T t).symm f\n  simp only [measurableEquivIoc, equivIoc, QuotientAddGroup.equivIocMod, MeasurableEquiv.symm_mk,\n    MeasurableEquiv.coe_mk, Equiv.coe_fn_symm_mk] at this\n  rw [‚Üê (AddCircle.measurePreserving_mk T t).map_eq, ‚Üê integral_subtype m, ‚Üê this]\n  have : ((‚Üë) : Ioc t (t + T) ‚Üí AddCircle T) = ((‚Üë) : ‚Ñù ‚Üí AddCircle T) ‚àò ((‚Üë) : _ ‚Üí ‚Ñù) := by\n    ext1 x; rfl\n  simp_rw [this]\n  rw [‚Üê map_map AddCircle.measurable_mk' measurable_subtype_coe, ‚Üê map_comap_subtype_coe m]\n  rfl\n\n"}
{"name":"AddCircle.intervalIntegral_preimage","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\nE : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nt : Real\nf : AddCircle T ‚Üí E\n‚ä¢ Eq (intervalIntegral (fun a => f ‚Üëa) t (HAdd.hAdd t T) MeasureTheory.MeasureSpace.volume) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun b => f b)","decl":"/-- The integral of an almost-everywhere strongly measurable function over `AddCircle T` is equal\nto the integral over an interval (t, t + T] in `‚Ñù` of its lift to `‚Ñù`. -/\nprotected theorem intervalIntegral_preimage (t : ‚Ñù) (f : AddCircle T ‚Üí E) :\n    ‚à´ a in t..t + T, f a = ‚à´ b : AddCircle T, f b := by\n  rw [integral_of_le, AddCircle.integral_preimage T t f]\n  linarith [hT.out]\n\n"}
{"name":"UnitAddCircle.measure_univ","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"‚ä¢ Eq (MeasureTheory.MeasureSpace.volume Set.univ) 1","decl":"protected theorem measure_univ : volume (Set.univ : Set UnitAddCircle) = 1 := by simp\n\n"}
{"name":"UnitAddCircle.measurePreserving_mk","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"t : Real\n‚ä¢ MeasureTheory.MeasurePreserving QuotientAddGroup.mk (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc t (HAdd.hAdd t 1))) MeasureTheory.MeasureSpace.volume","decl":"/-- The covering map from `‚Ñù` to the \"unit additive circle\" `‚Ñù ‚ß∏ ‚Ñ§` is measure-preserving,\nconsidered with respect to the standard measure (defined to be the Haar measure of total mass 1)\non the additive circle, and with respect to the restriction of Lebsegue measure on `‚Ñù` to an\ninterval (t, t + 1]. -/\nprotected theorem measurePreserving_mk (t : ‚Ñù) :\n    MeasurePreserving (Œ≤ := UnitAddCircle) ((‚Üë) : ‚Ñù ‚Üí UnitAddCircle)\n      (volume.restrict (Ioc t (t + 1))) :=\n  AddCircle.measurePreserving_mk 1 t\n\n"}
{"name":"UnitAddCircle.lintegral_preimage","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"t : Real\nf : UnitAddCircle ‚Üí ENNReal\n‚ä¢ Eq (MeasureTheory.lintegral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc t (HAdd.hAdd t 1))) fun a => f ‚Üëa) (MeasureTheory.lintegral MeasureTheory.MeasureSpace.volume fun b => f b)","decl":"/-- The integral of a measurable function over `UnitAddCircle` is equal to the integral over an\ninterval (t, t + 1] in `‚Ñù` of its lift to `‚Ñù`. -/\nprotected theorem lintegral_preimage (t : ‚Ñù) (f : UnitAddCircle ‚Üí ‚Ñù‚â•0‚àû) :\n    (‚à´‚Åª a in Ioc t (t + 1), f a) = ‚à´‚Åª b : UnitAddCircle, f b :=\n  AddCircle.lintegral_preimage 1 t f\n\n"}
{"name":"UnitAddCircle.integral_preimage","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nt : Real\nf : UnitAddCircle ‚Üí E\n‚ä¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc t (HAdd.hAdd t 1))) fun a => f ‚Üëa) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun b => f b)","decl":"/-- The integral of an almost-everywhere strongly measurable function over `UnitAddCircle` is\nequal to the integral over an interval (t, t + 1] in `‚Ñù` of its lift to `‚Ñù`. -/\nprotected theorem integral_preimage (t : ‚Ñù) (f : UnitAddCircle ‚Üí E) :\n    (‚à´ a in Ioc t (t + 1), f a) = ‚à´ b : UnitAddCircle, f b :=\n  AddCircle.integral_preimage 1 t f\n\n"}
{"name":"UnitAddCircle.intervalIntegral_preimage","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nt : Real\nf : UnitAddCircle ‚Üí E\n‚ä¢ Eq (intervalIntegral (fun a => f ‚Üëa) t (HAdd.hAdd t 1) MeasureTheory.MeasureSpace.volume) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun b => f b)","decl":"/-- The integral of an almost-everywhere strongly measurable function over `UnitAddCircle` is\nequal to the integral over an interval (t, t + 1] in `‚Ñù` of its lift to `‚Ñù`. -/\nprotected theorem intervalIntegral_preimage (t : ‚Ñù) (f : UnitAddCircle ‚Üí E) :\n    ‚à´ a in t..t + 1, f a = ‚à´ b : UnitAddCircle, f b :=\n  AddCircle.intervalIntegral_preimage 1 t f\n\n"}
{"name":"Function.Periodic.intervalIntegrable","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"E : Type u_1\ninst‚úù : NormedAddCommGroup E\nf : Real ‚Üí E\nT t : Real\nh‚ÇÅf : Function.Periodic f T\nhT : LT.lt 0 T\nh‚ÇÇf : IntervalIntegrable f MeasureTheory.MeasureSpace.volume t (HAdd.hAdd t T)\na‚ÇÅ a‚ÇÇ : Real\n‚ä¢ IntervalIntegrable f MeasureTheory.MeasureSpace.volume a‚ÇÅ a‚ÇÇ","decl":"/-- A periodic function is interval integrable over every interval if it is interval integrable\nover one period. -/\ntheorem intervalIntegrable {t : ‚Ñù} (h‚ÇÅf : Function.Periodic f T) (hT : 0 < T)\n    (h‚ÇÇf : IntervalIntegrable f MeasureTheory.volume t (t + T)) (a‚ÇÅ a‚ÇÇ : ‚Ñù) :\n    IntervalIntegrable f MeasureTheory.volume a‚ÇÅ a‚ÇÇ := by\n  -- Replace [a‚ÇÅ, a‚ÇÇ] by [t - n‚ÇÅ * T, t + n‚ÇÇ * T], where n‚ÇÅ and n‚ÇÇ are natural numbers\n  obtain ‚ü®n‚ÇÅ, hn‚ÇÅ‚ü© := exists_nat_ge ((t - min a‚ÇÅ a‚ÇÇ) / T)\n  obtain ‚ü®n‚ÇÇ, hn‚ÇÇ‚ü© := exists_nat_ge ((max a‚ÇÅ a‚ÇÇ - t) / T)\n  have : Set.uIcc a‚ÇÅ a‚ÇÇ ‚äÜ Set.uIcc (t - n‚ÇÅ * T) (t + n‚ÇÇ * T) := by\n    rw [Set.uIcc_subset_uIcc_iff_le]\n    constructor\n    ¬∑ calc min (t - n‚ÇÅ * T) (t + n‚ÇÇ * T)\n      _ ‚â§ (t - n‚ÇÅ * T) := by apply min_le_left\n      _ ‚â§ min a‚ÇÅ a‚ÇÇ := by linarith [(div_le_iff‚ÇÄ hT).1 hn‚ÇÅ]\n    ¬∑ calc max a‚ÇÅ a‚ÇÇ\n      _ ‚â§ t + n‚ÇÇ * T := by linarith [(div_le_iff‚ÇÄ hT).1 hn‚ÇÇ]\n      _ ‚â§ max (t - n‚ÇÅ * T) (t + n‚ÇÇ * T) := by apply le_max_right\n  apply IntervalIntegrable.mono_set _ this\n  -- Suffices to show integrability over shifted periods\n  let a : ‚Ñï ‚Üí ‚Ñù := fun n ‚Ü¶ t + (n - n‚ÇÅ) * T\n  rw [(by ring : t - n‚ÇÅ * T = a 0), (by simp [a] : t + n‚ÇÇ * T = a (n‚ÇÅ + n‚ÇÇ))]\n  apply IntervalIntegrable.trans_iterate\n  -- Show integrability over a shifted period\n  intro k hk\n  convert (IntervalIntegrable.comp_sub_right h‚ÇÇf ((k - n‚ÇÅ) * T)) using 1\n  ¬∑ funext x\n    simpa using (h‚ÇÅf.sub_int_mul_eq (k - n‚ÇÅ)).symm\n  ¬∑ simp [a, Nat.cast_add]\n    ring\n\n"}
{"name":"Function.Periodic.intervalIntegrable‚ÇÄ","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"E : Type u_1\ninst‚úù : NormedAddCommGroup E\nf : Real ‚Üí E\nT : Real\nh‚ÇÅf : Function.Periodic f T\nhT : LT.lt 0 T\nh‚ÇÇf : IntervalIntegrable f MeasureTheory.MeasureSpace.volume 0 T\na‚ÇÅ a‚ÇÇ : Real\n‚ä¢ IntervalIntegrable f MeasureTheory.MeasureSpace.volume a‚ÇÅ a‚ÇÇ","decl":"/-- Special case of Function.Periodic.intervalIntegrable: A periodic function is interval integrable\nover every interval if it is interval integrable over the period starting from zero. -/\ntheorem intervalIntegrable‚ÇÄ (h‚ÇÅf : Function.Periodic f T) (hT : 0 < T)\n    (h‚ÇÇf : IntervalIntegrable f MeasureTheory.volume 0 T) (a‚ÇÅ a‚ÇÇ : ‚Ñù) :\n    IntervalIntegrable f MeasureTheory.volume a‚ÇÅ a‚ÇÇ := by\n  apply h‚ÇÅf.intervalIntegrable hT (t := 0)\n  simpa\n\n"}
{"name":"Function.Periodic.intervalIntegral_add_eq_of_pos","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\nf : Real ‚Üí E\nT : Real\ninst‚úù : NormedSpace Real E\nhf : Function.Periodic f T\nhT : LT.lt 0 T\nt s : Real\n‚ä¢ Eq (intervalIntegral (fun x => f x) t (HAdd.hAdd t T) MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => f x) s (HAdd.hAdd s T) MeasureTheory.MeasureSpace.volume)","decl":"/-- An auxiliary lemma for a more general `Function.Periodic.intervalIntegral_add_eq`. -/\ntheorem intervalIntegral_add_eq_of_pos (hf : Periodic f T) (hT : 0 < T) (t s : ‚Ñù) :\n    ‚à´ x in t..t + T, f x = ‚à´ x in s..s + T, f x := by\n  simp only [integral_of_le, hT.le, le_add_iff_nonneg_right]\n  haveI : VAddInvariantMeasure (AddSubgroup.zmultiples T) ‚Ñù volume :=\n    ‚ü®fun c s _ => measure_preimage_add _ _ _‚ü©\n  apply IsAddFundamentalDomain.setIntegral_eq (G := AddSubgroup.zmultiples T)\n  exacts [isAddFundamentalDomain_Ioc hT t, isAddFundamentalDomain_Ioc hT s, hf.map_vadd_zmultiples]\n\n"}
{"name":"Function.Periodic.intervalIntegral_add_eq","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\nf : Real ‚Üí E\nT : Real\ninst‚úù : NormedSpace Real E\nhf : Function.Periodic f T\nt s : Real\n‚ä¢ Eq (intervalIntegral (fun x => f x) t (HAdd.hAdd t T) MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => f x) s (HAdd.hAdd s T) MeasureTheory.MeasureSpace.volume)","decl":"/-- If `f` is a periodic function with period `T`, then its integral over `[t, t + T]` does not\ndepend on `t`. -/\ntheorem intervalIntegral_add_eq (hf : Periodic f T) (t s : ‚Ñù) :\n    ‚à´ x in t..t + T, f x = ‚à´ x in s..s + T, f x := by\n  rcases lt_trichotomy (0 : ‚Ñù) T with (hT | rfl | hT)\n  ¬∑ exact hf.intervalIntegral_add_eq_of_pos hT t s\n  ¬∑ simp\n  ¬∑ rw [‚Üê neg_inj, ‚Üê integral_symm, ‚Üê integral_symm]\n    simpa only [‚Üê sub_eq_add_neg, add_sub_cancel_right] using\n      hf.neg.intervalIntegral_add_eq_of_pos (neg_pos.2 hT) (t + T) (s + T)\n\n"}
{"name":"Function.Periodic.intervalIntegral_add_eq_add","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\nf : Real ‚Üí E\nT : Real\ninst‚úù : NormedSpace Real E\nhf : Function.Periodic f T\nt s : Real\nh_int : ‚àÄ (t‚ÇÅ t‚ÇÇ : Real), IntervalIntegrable f MeasureTheory.MeasureSpace.volume t‚ÇÅ t‚ÇÇ\n‚ä¢ Eq (intervalIntegral (fun x => f x) t (HAdd.hAdd s T) MeasureTheory.MeasureSpace.volume) (HAdd.hAdd (intervalIntegral (fun x => f x) t s MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => f x) t (HAdd.hAdd t T) MeasureTheory.MeasureSpace.volume))","decl":"/-- If `f` is an integrable periodic function with period `T`, then its integral over `[t, s + T]`\nis the sum of its integrals over the intervals `[t, s]` and `[t, t + T]`. -/\ntheorem intervalIntegral_add_eq_add (hf : Periodic f T) (t s : ‚Ñù)\n    (h_int : ‚àÄ t‚ÇÅ t‚ÇÇ, IntervalIntegrable f MeasureSpace.volume t‚ÇÅ t‚ÇÇ) :\n    ‚à´ x in t..s + T, f x = (‚à´ x in t..s, f x) + ‚à´ x in t..t + T, f x := by\n  rw [hf.intervalIntegral_add_eq t s, integral_add_adjacent_intervals (h_int t s) (h_int s _)]\n\n"}
{"name":"Function.Periodic.intervalIntegral_add_zsmul_eq","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\nf : Real ‚Üí E\nT : Real\ninst‚úù : NormedSpace Real E\nhf : Function.Periodic f T\nn : Int\nt : Real\nh_int : ‚àÄ (t‚ÇÅ t‚ÇÇ : Real), IntervalIntegrable f MeasureTheory.MeasureSpace.volume t‚ÇÅ t‚ÇÇ\n‚ä¢ Eq (intervalIntegral (fun x => f x) t (HAdd.hAdd t (HSMul.hSMul n T)) MeasureTheory.MeasureSpace.volume) (HSMul.hSMul n (intervalIntegral (fun x => f x) t (HAdd.hAdd t T) MeasureTheory.MeasureSpace.volume))","decl":"/-- If `f` is an integrable periodic function with period `T`, and `n` is an integer, then its\nintegral over `[t, t + n ‚Ä¢ T]` is `n` times its integral over `[t, t + T]`. -/\ntheorem intervalIntegral_add_zsmul_eq (hf : Periodic f T) (n : ‚Ñ§) (t : ‚Ñù)\n    (h_int : ‚àÄ t‚ÇÅ t‚ÇÇ, IntervalIntegrable f MeasureSpace.volume t‚ÇÅ t‚ÇÇ) :\n    ‚à´ x in t..t + n ‚Ä¢ T, f x = n ‚Ä¢ ‚à´ x in t..t + T, f x := by\n  -- Reduce to the case `b = 0`\n  suffices (‚à´ x in (0)..(n ‚Ä¢ T), f x) = n ‚Ä¢ ‚à´ x in (0)..T, f x by\n    simp only [hf.intervalIntegral_add_eq t 0, (hf.zsmul n).intervalIntegral_add_eq t 0, zero_add,\n      this]\n  -- First prove it for natural numbers\n  have : ‚àÄ m : ‚Ñï, (‚à´ x in (0)..m ‚Ä¢ T, f x) = m ‚Ä¢ ‚à´ x in (0)..T, f x := fun m ‚Ü¶ by\n    induction' m with m ih\n    ¬∑ simp\n    ¬∑ simp only [succ_nsmul, hf.intervalIntegral_add_eq_add 0 (m ‚Ä¢ T) h_int, ih, zero_add]\n  -- Then prove it for all integers\n  cases' n with n n\n  ¬∑ simp [‚Üê this n]\n  ¬∑ conv_rhs => rw [negSucc_zsmul]\n    have h‚ÇÄ : Int.negSucc n ‚Ä¢ T + (n + 1) ‚Ä¢ T = 0 := by simp; linarith\n    rw [integral_symm, ‚Üê (hf.nsmul (n + 1)).funext, neg_inj]\n    simp_rw [integral_comp_add_right, h‚ÇÄ, zero_add, this (n + 1), add_comm T,\n      hf.intervalIntegral_add_eq ((n + 1) ‚Ä¢ T) 0, zero_add]\n\n"}
{"name":"Function.Periodic.sInf_add_zsmul_le_integral_of_pos","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\ng : Real ‚Üí Real\nhg : Function.Periodic g T\nh_int : IntervalIntegrable g MeasureTheory.MeasureSpace.volume 0 T\nhT : LT.lt 0 T\nt : Real\n‚ä¢ LE.le (HAdd.hAdd (InfSet.sInf (Set.image (fun t => intervalIntegral (fun x => g x) 0 t MeasureTheory.MeasureSpace.volume) (Set.Icc 0 T))) (HSMul.hSMul (Int.floor (HDiv.hDiv t T)) (intervalIntegral (fun x => g x) 0 T MeasureTheory.MeasureSpace.volume))) (intervalIntegral (fun x => g x) 0 t MeasureTheory.MeasureSpace.volume)","decl":"/-- If `g : ‚Ñù ‚Üí ‚Ñù` is periodic with period `T > 0`, then for any `t : ‚Ñù`, the function\n`t ‚Ü¶ ‚à´ x in 0..t, g x` is bounded below by `t ‚Ü¶ X + ‚åät/T‚åã ‚Ä¢ Y` for appropriate constants `X` and\n`Y`. -/\ntheorem sInf_add_zsmul_le_integral_of_pos (h_int : IntervalIntegrable g MeasureSpace.volume 0 T)\n    (hT : 0 < T) (t : ‚Ñù) :\n    (sInf ((fun t => ‚à´ x in (0)..t, g x) '' Icc 0 T) + ‚åät / T‚åã ‚Ä¢ ‚à´ x in (0)..T, g x) ‚â§\n      ‚à´ x in (0)..t, g x := by\n  let h'_int := hg.intervalIntegrable‚ÇÄ hT h_int\n  let Œµ := Int.fract (t / T) * T\n  conv_rhs =>\n    rw [‚Üê Int.fract_div_mul_self_add_zsmul_eq T t (by linarith),\n      ‚Üê integral_add_adjacent_intervals (h'_int 0 Œµ) (h'_int _ _)]\n  rw [hg.intervalIntegral_add_zsmul_eq ‚åät / T‚åã Œµ (hg.intervalIntegrable‚ÇÄ hT h_int),\n    hg.intervalIntegral_add_eq Œµ 0, zero_add, add_le_add_iff_right]\n  exact (continuous_primitive h'_int 0).continuousOn.sInf_image_Icc_le <|\n    mem_Icc_of_Ico (Int.fract_div_mul_self_mem_Ico T t hT)\n\n"}
{"name":"Function.Periodic.integral_le_sSup_add_zsmul_of_pos","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\ng : Real ‚Üí Real\nhg : Function.Periodic g T\nh_int : IntervalIntegrable g MeasureTheory.MeasureSpace.volume 0 T\nhT : LT.lt 0 T\nt : Real\n‚ä¢ LE.le (intervalIntegral (fun x => g x) 0 t MeasureTheory.MeasureSpace.volume) (HAdd.hAdd (SupSet.sSup (Set.image (fun t => intervalIntegral (fun x => g x) 0 t MeasureTheory.MeasureSpace.volume) (Set.Icc 0 T))) (HSMul.hSMul (Int.floor (HDiv.hDiv t T)) (intervalIntegral (fun x => g x) 0 T MeasureTheory.MeasureSpace.volume)))","decl":"/-- If `g : ‚Ñù ‚Üí ‚Ñù` is periodic with period `T > 0`, then for any `t : ‚Ñù`, the function\n`t ‚Ü¶ ‚à´ x in 0..t, g x` is bounded above by `t ‚Ü¶ X + ‚åät/T‚åã ‚Ä¢ Y` for appropriate constants `X` and\n`Y`. -/\ntheorem integral_le_sSup_add_zsmul_of_pos (h_int : IntervalIntegrable g MeasureSpace.volume 0 T)\n    (hT : 0 < T) (t : ‚Ñù) :\n    (‚à´ x in (0)..t, g x) ‚â§\n      sSup ((fun t => ‚à´ x in (0)..t, g x) '' Icc 0 T) + ‚åät / T‚åã ‚Ä¢ ‚à´ x in (0)..T, g x := by\n  let h'_int := hg.intervalIntegrable‚ÇÄ hT h_int\n  let Œµ := Int.fract (t / T) * T\n  conv_lhs =>\n    rw [‚Üê Int.fract_div_mul_self_add_zsmul_eq T t (by linarith), ‚Üê\n      integral_add_adjacent_intervals (h'_int 0 Œµ) (h'_int _ _)]\n  rw [hg.intervalIntegral_add_zsmul_eq ‚åät / T‚åã Œµ h'_int, hg.intervalIntegral_add_eq Œµ 0, zero_add,\n    add_le_add_iff_right]\n  exact (continuous_primitive h'_int 0).continuousOn.le_sSup_image_Icc\n    (mem_Icc_of_Ico (Int.fract_div_mul_self_mem_Ico T t hT))\n\n"}
{"name":"Function.Periodic.tendsto_atTop_intervalIntegral_of_pos","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\ng : Real ‚Üí Real\nhg : Function.Periodic g T\nh‚ÇÄ : LT.lt 0 (intervalIntegral (fun x => g x) 0 T MeasureTheory.MeasureSpace.volume)\nhT : LT.lt 0 T\n‚ä¢ Filter.Tendsto (fun t => intervalIntegral (fun x => g x) 0 t MeasureTheory.MeasureSpace.volume) Filter.atTop Filter.atTop","decl":"/-- If `g : ‚Ñù ‚Üí ‚Ñù` is periodic with period `T > 0` and `0 < ‚à´ x in 0..T, g x`, then\n`t ‚Ü¶ ‚à´ x in 0..t, g x` tends to `‚àû` as `t` tends to `‚àû`. -/\ntheorem tendsto_atTop_intervalIntegral_of_pos (h‚ÇÄ : 0 < ‚à´ x in (0)..T, g x) (hT : 0 < T) :\n    Tendsto (fun t => ‚à´ x in (0)..t, g x) atTop atTop := by\n  have h_int := intervalIntegrable_of_integral_ne_zero h‚ÇÄ.ne'\n  apply tendsto_atTop_mono (hg.sInf_add_zsmul_le_integral_of_pos h_int hT)\n  apply atTop.tendsto_atTop_add_const_left (sInf <| (fun t => ‚à´ x in (0)..t, g x) '' Icc 0 T)\n  apply Tendsto.atTop_zsmul_const h‚ÇÄ\n  exact tendsto_floor_atTop.comp (tendsto_id.atTop_mul_const (inv_pos.mpr hT))\n\n"}
{"name":"Function.Periodic.tendsto_atBot_intervalIntegral_of_pos","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\ng : Real ‚Üí Real\nhg : Function.Periodic g T\nh‚ÇÄ : LT.lt 0 (intervalIntegral (fun x => g x) 0 T MeasureTheory.MeasureSpace.volume)\nhT : LT.lt 0 T\n‚ä¢ Filter.Tendsto (fun t => intervalIntegral (fun x => g x) 0 t MeasureTheory.MeasureSpace.volume) Filter.atBot Filter.atBot","decl":"/-- If `g : ‚Ñù ‚Üí ‚Ñù` is periodic with period `T > 0` and `0 < ‚à´ x in 0..T, g x`, then\n`t ‚Ü¶ ‚à´ x in 0..t, g x` tends to `-‚àû` as `t` tends to `-‚àû`. -/\ntheorem tendsto_atBot_intervalIntegral_of_pos (h‚ÇÄ : 0 < ‚à´ x in (0)..T, g x) (hT : 0 < T) :\n    Tendsto (fun t => ‚à´ x in (0)..t, g x) atBot atBot := by\n  have h_int := intervalIntegrable_of_integral_ne_zero h‚ÇÄ.ne'\n  apply tendsto_atBot_mono (hg.integral_le_sSup_add_zsmul_of_pos h_int hT)\n  apply atBot.tendsto_atBot_add_const_left (sSup <| (fun t => ‚à´ x in (0)..t, g x) '' Icc 0 T)\n  apply Tendsto.atBot_zsmul_const h‚ÇÄ\n  exact tendsto_floor_atBot.comp (tendsto_id.atBot_mul_const (inv_pos.mpr hT))\n\n"}
{"name":"Function.Periodic.tendsto_atTop_intervalIntegral_of_pos'","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\ng : Real ‚Üí Real\nhg : Function.Periodic g T\nh_int : IntervalIntegrable g MeasureTheory.MeasureSpace.volume 0 T\nh‚ÇÄ : ‚àÄ (x : Real), LT.lt 0 (g x)\nhT : LT.lt 0 T\n‚ä¢ Filter.Tendsto (fun t => intervalIntegral (fun x => g x) 0 t MeasureTheory.MeasureSpace.volume) Filter.atTop Filter.atTop","decl":"/-- If `g : ‚Ñù ‚Üí ‚Ñù` is periodic with period `T > 0` and `‚àÄ x, 0 < g x`, then `t ‚Ü¶ ‚à´ x in 0..t, g x`\ntends to `‚àû` as `t` tends to `‚àû`. -/\ntheorem tendsto_atTop_intervalIntegral_of_pos'\n    (h_int : IntervalIntegrable g MeasureSpace.volume 0 T) (h‚ÇÄ : ‚àÄ x, 0 < g x) (hT : 0 < T) :\n    Tendsto (fun t => ‚à´ x in (0)..t, g x) atTop atTop :=\n  hg.tendsto_atTop_intervalIntegral_of_pos (intervalIntegral_pos_of_pos h_int h‚ÇÄ hT) hT\n\n"}
{"name":"Function.Periodic.tendsto_atBot_intervalIntegral_of_pos'","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\ng : Real ‚Üí Real\nhg : Function.Periodic g T\nh_int : IntervalIntegrable g MeasureTheory.MeasureSpace.volume 0 T\nh‚ÇÄ : ‚àÄ (x : Real), LT.lt 0 (g x)\nhT : LT.lt 0 T\n‚ä¢ Filter.Tendsto (fun t => intervalIntegral (fun x => g x) 0 t MeasureTheory.MeasureSpace.volume) Filter.atBot Filter.atBot","decl":"/-- If `g : ‚Ñù ‚Üí ‚Ñù` is periodic with period `T > 0` and `‚àÄ x, 0 < g x`, then `t ‚Ü¶ ‚à´ x in 0..t, g x`\ntends to `-‚àû` as `t` tends to `-‚àû`. -/\ntheorem tendsto_atBot_intervalIntegral_of_pos'\n    (h_int : IntervalIntegrable g MeasureSpace.volume 0 T) (h‚ÇÄ : ‚àÄ x, 0 < g x) (hT : 0 < T) :\n    Tendsto (fun t => ‚à´ x in (0)..t, g x) atBot atBot := by\n  exact hg.tendsto_atBot_intervalIntegral_of_pos (intervalIntegral_pos_of_pos h_int h‚ÇÄ hT) hT\n\n"}
