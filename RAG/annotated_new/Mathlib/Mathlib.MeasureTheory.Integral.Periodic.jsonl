{"name":"AddCircle.measurable_mk'","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"a : Real\n⊢ Measurable QuotientAddGroup.mk","decl":"@[measurability]\nprotected theorem AddCircle.measurable_mk' {a : ℝ} :\n    Measurable (β := AddCircle a) ((↑) : ℝ → AddCircle a) :=\n  Continuous.measurable <| AddCircle.continuous_mk' a\n\n"}
{"name":"isAddFundamentalDomain_Ioc","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\nhT : LT.lt 0 T\nt : Real\nμ : autoParam (MeasureTheory.Measure Real) _auto✝\n⊢ MeasureTheory.IsAddFundamentalDomain (Subtype fun x => Membership.mem (AddSubgroup.zmultiples T) x) (Set.Ioc t (HAdd.hAdd t T)) μ","decl":"theorem isAddFundamentalDomain_Ioc {T : ℝ} (hT : 0 < T) (t : ℝ)\n    (μ : Measure ℝ := by volume_tac) :\n    IsAddFundamentalDomain (AddSubgroup.zmultiples T) (Ioc t (t + T)) μ := by\n  refine IsAddFundamentalDomain.mk' nullMeasurableSet_Ioc fun x => ?_\n  have : Bijective (codRestrict (fun n : ℤ => n • T) (AddSubgroup.zmultiples T) _) :=\n    (Equiv.ofInjective (fun n : ℤ => n • T) (zsmul_left_strictMono hT).injective).bijective\n  refine this.existsUnique_iff.2 ?_\n  simpa only [add_comm x] using existsUnique_add_zsmul_mem_Ioc hT x t\n\n"}
{"name":"isAddFundamentalDomain_Ioc'","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\nhT : LT.lt 0 T\nt : Real\nμ : autoParam (MeasureTheory.Measure Real) _auto✝\n⊢ MeasureTheory.IsAddFundamentalDomain (Subtype fun x => Membership.mem (AddSubgroup.zmultiples T).op x) (Set.Ioc t (HAdd.hAdd t T)) μ","decl":"theorem isAddFundamentalDomain_Ioc' {T : ℝ} (hT : 0 < T) (t : ℝ) (μ : Measure ℝ := by volume_tac) :\n    IsAddFundamentalDomain (AddSubgroup.op <| .zmultiples T) (Ioc t (t + T)) μ := by\n  refine IsAddFundamentalDomain.mk' nullMeasurableSet_Ioc fun x => ?_\n  have : Bijective (codRestrict (fun n : ℤ => n • T) (AddSubgroup.zmultiples T) _) :=\n    (Equiv.ofInjective (fun n : ℤ => n • T) (zsmul_left_strictMono hT).injective).bijective\n  refine (AddSubgroup.equivOp _).bijective.comp this |>.existsUnique_iff.2 ?_\n  simpa using existsUnique_add_zsmul_mem_Ioc hT x t\n\n"}
{"name":"AddCircle.measure_univ","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\n⊢ Eq (MeasureTheory.MeasureSpace.volume Set.univ) (ENNReal.ofReal T)","decl":"@[simp]\nprotected theorem measure_univ : volume (Set.univ : Set (AddCircle T)) = ENNReal.ofReal T := by\n  dsimp [volume]\n  rw [← PositiveCompacts.coe_top]\n  simp [addHaarMeasure_self (G := AddCircle T), -PositiveCompacts.coe_top]\n\n"}
{"name":"AddCircle.instIsAddHaarMeasureRealVolume","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\n⊢ MeasureTheory.MeasureSpace.volume.IsAddHaarMeasure","decl":"instance : IsAddHaarMeasure (volume : Measure (AddCircle T)) :=\n  IsAddHaarMeasure.smul _ (by simp [hT.out]) ENNReal.ofReal_ne_top\n\n"}
{"name":"AddCircle.isFiniteMeasure","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\n⊢ MeasureTheory.IsFiniteMeasure MeasureTheory.MeasureSpace.volume","decl":"instance isFiniteMeasure : IsFiniteMeasure (volume : Measure (AddCircle T)) where\n  measure_univ_lt_top := by simp\n\n"}
{"name":"AddCircle.instHasAddFundamentalDomainSubtypeAddOppositeRealMemAddSubgroupOpZmultiples","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\n⊢ MeasureTheory.HasAddFundamentalDomain (Subtype fun x => Membership.mem (AddSubgroup.zmultiples T).op x) Real MeasureTheory.MeasureSpace.volume","decl":"instance : HasAddFundamentalDomain (AddSubgroup.op <| .zmultiples T) ℝ where\n  ExistsIsAddFundamentalDomain := ⟨Ioc 0 (0 + T), isAddFundamentalDomain_Ioc' Fact.out 0⟩\n\n"}
{"name":"AddCircle.instAddQuotientMeasureEqMeasurePreimageSubtypeAddOppositeRealMemAddSubgroupOpZmultiplesVolume","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\n⊢ MeasureTheory.AddQuotientMeasureEqMeasurePreimage MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume","decl":"instance : AddQuotientMeasureEqMeasurePreimage volume (volume : Measure (AddCircle T)) := by\n  apply MeasureTheory.leftInvariantIsAddQuotientMeasureEqMeasurePreimage\n  simp [(isAddFundamentalDomain_Ioc' hT.out 0).covolume_eq_volume, AddCircle.measure_univ]\n\n"}
{"name":"AddCircle.measurePreserving_mk","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\nt : Real\n⊢ MeasureTheory.MeasurePreserving QuotientAddGroup.mk (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc t (HAdd.hAdd t T))) MeasureTheory.MeasureSpace.volume","decl":"/-- The covering map from `ℝ` to the \"additive circle\" `ℝ ⧸ (ℤ ∙ T)` is measure-preserving,\nconsidered with respect to the standard measure (defined to be the Haar measure of total mass `T`)\non the additive circle, and with respect to the restriction of Lebsegue measure on `ℝ` to an\ninterval (t, t + T]. -/\nprotected theorem measurePreserving_mk (t : ℝ) :\n    MeasurePreserving (β := AddCircle T) ((↑) : ℝ → AddCircle T)\n      (volume.restrict (Ioc t (t + T))) :=\n  measurePreserving_quotientAddGroup_mk_of_AddQuotientMeasureEqMeasurePreimage\n    volume (𝓕 := Ioc t (t+T)) (isAddFundamentalDomain_Ioc' hT.out _) _\n\n"}
{"name":"AddCircle.add_projection_respects_measure","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\nt : Real\nU : Set (AddCircle T)\nmeas_U : MeasurableSet U\n⊢ Eq (MeasureTheory.MeasureSpace.volume U) (MeasureTheory.MeasureSpace.volume (Inter.inter (Set.preimage QuotientAddGroup.mk U) (Set.Ioc t (HAdd.hAdd t T))))","decl":"lemma add_projection_respects_measure (t : ℝ) {U : Set (AddCircle T)} (meas_U : MeasurableSet U) :\n    volume U = volume (QuotientAddGroup.mk ⁻¹' U ∩ (Ioc t (t + T))) :=\n  (isAddFundamentalDomain_Ioc' hT.out _).addProjection_respects_measure_apply\n    (volume : Measure (AddCircle T)) meas_U\n\n"}
{"name":"AddCircle.volume_closedBall","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\nx : AddCircle T\nε : Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Metric.closedBall x ε)) (ENNReal.ofReal (Min.min T (HMul.hMul 2 ε)))","decl":"theorem volume_closedBall {x : AddCircle T} (ε : ℝ) :\n    volume (Metric.closedBall x ε) = ENNReal.ofReal (min T (2 * ε)) := by\n  have hT' : |T| = T := abs_eq_self.mpr hT.out.le\n  let I := Ioc (-(T / 2)) (T / 2)\n  have h₁ : ε < T / 2 → Metric.closedBall (0 : ℝ) ε ∩ I = Metric.closedBall (0 : ℝ) ε := by\n    intro hε\n    rw [inter_eq_left, Real.closedBall_eq_Icc, zero_sub, zero_add]\n    rintro y ⟨hy₁, hy₂⟩; constructor <;> linarith\n  have h₂ : (↑) ⁻¹' Metric.closedBall (0 : AddCircle T) ε ∩ I =\n      if ε < T / 2 then Metric.closedBall (0 : ℝ) ε else I := by\n    conv_rhs => rw [← if_ctx_congr (Iff.rfl : ε < T / 2 ↔ ε < T / 2) h₁ fun _ => rfl, ← hT']\n    apply coe_real_preimage_closedBall_inter_eq\n    simpa only [hT', Real.closedBall_eq_Icc, zero_add, zero_sub] using Ioc_subset_Icc_self\n  rw [addHaar_closedBall_center, add_projection_respects_measure T (-(T/2))\n    measurableSet_closedBall, (by linarith : -(T / 2) + T = T / 2), h₂]\n  by_cases hε : ε < T / 2\n  · simp [hε, min_eq_right (by linarith : 2 * ε ≤ T)]\n  · simp [I, hε, min_eq_left (by linarith : T ≤ 2 * ε)]\n\n"}
{"name":"AddCircle.instIsUnifLocDoublingMeasureRealVolume","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\n⊢ IsUnifLocDoublingMeasure MeasureTheory.MeasureSpace.volume","decl":"instance : IsUnifLocDoublingMeasure (volume : Measure (AddCircle T)) := by\n  refine ⟨⟨Real.toNNReal 2, Filter.Eventually.of_forall fun ε x => ?_⟩⟩\n  simp only [volume_closedBall]\n  erw [← ENNReal.ofReal_mul zero_le_two]\n  apply ENNReal.ofReal_le_ofReal\n  rw [mul_min_of_nonneg _ _ (zero_le_two : (0 : ℝ) ≤ 2)]\n  exact min_le_min (by linarith [hT.out]) (le_refl _)\n\n"}
{"name":"AddCircle.lintegral_preimage","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\nt : Real\nf : AddCircle T → ENNReal\n⊢ Eq (MeasureTheory.lintegral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc t (HAdd.hAdd t T))) fun a => f ↑a) (MeasureTheory.lintegral MeasureTheory.MeasureSpace.volume fun b => f b)","decl":"attribute [local instance] Subtype.measureSpace in\n/-- The lower integral of a function over `AddCircle T` is equal to the lower integral over an\ninterval (t, t + T] in `ℝ` of its lift to `ℝ`. -/\nprotected theorem lintegral_preimage (t : ℝ) (f : AddCircle T → ℝ≥0∞) :\n    (∫⁻ a in Ioc t (t + T), f a) = ∫⁻ b : AddCircle T, f b := by\n  have m : MeasurableSet (Ioc t (t + T)) := measurableSet_Ioc\n  have := lintegral_map_equiv (μ := volume) f (measurableEquivIoc T t).symm\n  simp only [measurableEquivIoc, equivIoc, QuotientAddGroup.equivIocMod, MeasurableEquiv.symm_mk,\n    MeasurableEquiv.coe_mk, Equiv.coe_fn_symm_mk] at this\n  rw [← (AddCircle.measurePreserving_mk T t).map_eq]\n  convert this.symm using 1\n  · rw [← map_comap_subtype_coe m _]\n    exact MeasurableEmbedding.lintegral_map (MeasurableEmbedding.subtype_coe m) _\n  · congr 1\n    have : ((↑) : Ioc t (t + T) → AddCircle T) = ((↑) : ℝ → AddCircle T) ∘ ((↑) : _ → ℝ) := by\n      ext1 x; rfl\n    simp_rw [this]\n    rw [← map_map AddCircle.measurable_mk' measurable_subtype_coe, ← map_comap_subtype_coe m]\n    rfl\n\n"}
{"name":"AddCircle.integral_preimage","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\nE : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nt : Real\nf : AddCircle T → E\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc t (HAdd.hAdd t T))) fun a => f ↑a) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun b => f b)","decl":"attribute [local instance] Subtype.measureSpace in\n/-- The integral of an almost-everywhere strongly measurable function over `AddCircle T` is equal\nto the integral over an interval (t, t + T] in `ℝ` of its lift to `ℝ`. -/\nprotected theorem integral_preimage (t : ℝ) (f : AddCircle T → E) :\n    (∫ a in Ioc t (t + T), f a) = ∫ b : AddCircle T, f b := by\n  have m : MeasurableSet (Ioc t (t + T)) := measurableSet_Ioc\n  have := integral_map_equiv (μ := volume) (measurableEquivIoc T t).symm f\n  simp only [measurableEquivIoc, equivIoc, QuotientAddGroup.equivIocMod, MeasurableEquiv.symm_mk,\n    MeasurableEquiv.coe_mk, Equiv.coe_fn_symm_mk] at this\n  rw [← (AddCircle.measurePreserving_mk T t).map_eq, ← integral_subtype m, ← this]\n  have : ((↑) : Ioc t (t + T) → AddCircle T) = ((↑) : ℝ → AddCircle T) ∘ ((↑) : _ → ℝ) := by\n    ext1 x; rfl\n  simp_rw [this]\n  rw [← map_map AddCircle.measurable_mk' measurable_subtype_coe, ← map_comap_subtype_coe m]\n  rfl\n\n"}
{"name":"AddCircle.intervalIntegral_preimage","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\nE : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nt : Real\nf : AddCircle T → E\n⊢ Eq (intervalIntegral (fun a => f ↑a) t (HAdd.hAdd t T) MeasureTheory.MeasureSpace.volume) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun b => f b)","decl":"/-- The integral of an almost-everywhere strongly measurable function over `AddCircle T` is equal\nto the integral over an interval (t, t + T] in `ℝ` of its lift to `ℝ`. -/\nprotected theorem intervalIntegral_preimage (t : ℝ) (f : AddCircle T → E) :\n    ∫ a in t..t + T, f a = ∫ b : AddCircle T, f b := by\n  rw [integral_of_le, AddCircle.integral_preimage T t f]\n  linarith [hT.out]\n\n"}
{"name":"UnitAddCircle.measure_univ","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"⊢ Eq (MeasureTheory.MeasureSpace.volume Set.univ) 1","decl":"protected theorem measure_univ : volume (Set.univ : Set UnitAddCircle) = 1 := by simp\n\n"}
{"name":"UnitAddCircle.measurePreserving_mk","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"t : Real\n⊢ MeasureTheory.MeasurePreserving QuotientAddGroup.mk (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc t (HAdd.hAdd t 1))) MeasureTheory.MeasureSpace.volume","decl":"/-- The covering map from `ℝ` to the \"unit additive circle\" `ℝ ⧸ ℤ` is measure-preserving,\nconsidered with respect to the standard measure (defined to be the Haar measure of total mass 1)\non the additive circle, and with respect to the restriction of Lebsegue measure on `ℝ` to an\ninterval (t, t + 1]. -/\nprotected theorem measurePreserving_mk (t : ℝ) :\n    MeasurePreserving (β := UnitAddCircle) ((↑) : ℝ → UnitAddCircle)\n      (volume.restrict (Ioc t (t + 1))) :=\n  AddCircle.measurePreserving_mk 1 t\n\n"}
{"name":"UnitAddCircle.lintegral_preimage","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"t : Real\nf : UnitAddCircle → ENNReal\n⊢ Eq (MeasureTheory.lintegral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc t (HAdd.hAdd t 1))) fun a => f ↑a) (MeasureTheory.lintegral MeasureTheory.MeasureSpace.volume fun b => f b)","decl":"/-- The integral of a measurable function over `UnitAddCircle` is equal to the integral over an\ninterval (t, t + 1] in `ℝ` of its lift to `ℝ`. -/\nprotected theorem lintegral_preimage (t : ℝ) (f : UnitAddCircle → ℝ≥0∞) :\n    (∫⁻ a in Ioc t (t + 1), f a) = ∫⁻ b : UnitAddCircle, f b :=\n  AddCircle.lintegral_preimage 1 t f\n\n"}
{"name":"UnitAddCircle.integral_preimage","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nt : Real\nf : UnitAddCircle → E\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc t (HAdd.hAdd t 1))) fun a => f ↑a) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun b => f b)","decl":"/-- The integral of an almost-everywhere strongly measurable function over `UnitAddCircle` is\nequal to the integral over an interval (t, t + 1] in `ℝ` of its lift to `ℝ`. -/\nprotected theorem integral_preimage (t : ℝ) (f : UnitAddCircle → E) :\n    (∫ a in Ioc t (t + 1), f a) = ∫ b : UnitAddCircle, f b :=\n  AddCircle.integral_preimage 1 t f\n\n"}
{"name":"UnitAddCircle.intervalIntegral_preimage","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nt : Real\nf : UnitAddCircle → E\n⊢ Eq (intervalIntegral (fun a => f ↑a) t (HAdd.hAdd t 1) MeasureTheory.MeasureSpace.volume) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun b => f b)","decl":"/-- The integral of an almost-everywhere strongly measurable function over `UnitAddCircle` is\nequal to the integral over an interval (t, t + 1] in `ℝ` of its lift to `ℝ`. -/\nprotected theorem intervalIntegral_preimage (t : ℝ) (f : UnitAddCircle → E) :\n    ∫ a in t..t + 1, f a = ∫ b : UnitAddCircle, f b :=\n  AddCircle.intervalIntegral_preimage 1 t f\n\n"}
{"name":"Function.Periodic.intervalIntegrable","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\nf : Real → E\nT t : Real\nh₁f : Function.Periodic f T\nhT : LT.lt 0 T\nh₂f : IntervalIntegrable f MeasureTheory.MeasureSpace.volume t (HAdd.hAdd t T)\na₁ a₂ : Real\n⊢ IntervalIntegrable f MeasureTheory.MeasureSpace.volume a₁ a₂","decl":"/-- A periodic function is interval integrable over every interval if it is interval integrable\nover one period. -/\ntheorem intervalIntegrable {t : ℝ} (h₁f : Function.Periodic f T) (hT : 0 < T)\n    (h₂f : IntervalIntegrable f MeasureTheory.volume t (t + T)) (a₁ a₂ : ℝ) :\n    IntervalIntegrable f MeasureTheory.volume a₁ a₂ := by\n  -- Replace [a₁, a₂] by [t - n₁ * T, t + n₂ * T], where n₁ and n₂ are natural numbers\n  obtain ⟨n₁, hn₁⟩ := exists_nat_ge ((t - min a₁ a₂) / T)\n  obtain ⟨n₂, hn₂⟩ := exists_nat_ge ((max a₁ a₂ - t) / T)\n  have : Set.uIcc a₁ a₂ ⊆ Set.uIcc (t - n₁ * T) (t + n₂ * T) := by\n    rw [Set.uIcc_subset_uIcc_iff_le]\n    constructor\n    · calc min (t - n₁ * T) (t + n₂ * T)\n      _ ≤ (t - n₁ * T) := by apply min_le_left\n      _ ≤ min a₁ a₂ := by linarith [(div_le_iff₀ hT).1 hn₁]\n    · calc max a₁ a₂\n      _ ≤ t + n₂ * T := by linarith [(div_le_iff₀ hT).1 hn₂]\n      _ ≤ max (t - n₁ * T) (t + n₂ * T) := by apply le_max_right\n  apply IntervalIntegrable.mono_set _ this\n  -- Suffices to show integrability over shifted periods\n  let a : ℕ → ℝ := fun n ↦ t + (n - n₁) * T\n  rw [(by ring : t - n₁ * T = a 0), (by simp [a] : t + n₂ * T = a (n₁ + n₂))]\n  apply IntervalIntegrable.trans_iterate\n  -- Show integrability over a shifted period\n  intro k hk\n  convert (IntervalIntegrable.comp_sub_right h₂f ((k - n₁) * T)) using 1\n  · funext x\n    simpa using (h₁f.sub_int_mul_eq (k - n₁)).symm\n  · simp [a, Nat.cast_add]\n    ring\n\n"}
{"name":"Function.Periodic.intervalIntegrable₀","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\nf : Real → E\nT : Real\nh₁f : Function.Periodic f T\nhT : LT.lt 0 T\nh₂f : IntervalIntegrable f MeasureTheory.MeasureSpace.volume 0 T\na₁ a₂ : Real\n⊢ IntervalIntegrable f MeasureTheory.MeasureSpace.volume a₁ a₂","decl":"/-- Special case of Function.Periodic.intervalIntegrable: A periodic function is interval integrable\nover every interval if it is interval integrable over the period starting from zero. -/\ntheorem intervalIntegrable₀ (h₁f : Function.Periodic f T) (hT : 0 < T)\n    (h₂f : IntervalIntegrable f MeasureTheory.volume 0 T) (a₁ a₂ : ℝ) :\n    IntervalIntegrable f MeasureTheory.volume a₁ a₂ := by\n  apply h₁f.intervalIntegrable hT (t := 0)\n  simpa\n\n"}
{"name":"Function.Periodic.intervalIntegral_add_eq_of_pos","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\nf : Real → E\nT : Real\ninst✝ : NormedSpace Real E\nhf : Function.Periodic f T\nhT : LT.lt 0 T\nt s : Real\n⊢ Eq (intervalIntegral (fun x => f x) t (HAdd.hAdd t T) MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => f x) s (HAdd.hAdd s T) MeasureTheory.MeasureSpace.volume)","decl":"/-- An auxiliary lemma for a more general `Function.Periodic.intervalIntegral_add_eq`. -/\ntheorem intervalIntegral_add_eq_of_pos (hf : Periodic f T) (hT : 0 < T) (t s : ℝ) :\n    ∫ x in t..t + T, f x = ∫ x in s..s + T, f x := by\n  simp only [integral_of_le, hT.le, le_add_iff_nonneg_right]\n  haveI : VAddInvariantMeasure (AddSubgroup.zmultiples T) ℝ volume :=\n    ⟨fun c s _ => measure_preimage_add _ _ _⟩\n  apply IsAddFundamentalDomain.setIntegral_eq (G := AddSubgroup.zmultiples T)\n  exacts [isAddFundamentalDomain_Ioc hT t, isAddFundamentalDomain_Ioc hT s, hf.map_vadd_zmultiples]\n\n"}
{"name":"Function.Periodic.intervalIntegral_add_eq","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\nf : Real → E\nT : Real\ninst✝ : NormedSpace Real E\nhf : Function.Periodic f T\nt s : Real\n⊢ Eq (intervalIntegral (fun x => f x) t (HAdd.hAdd t T) MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => f x) s (HAdd.hAdd s T) MeasureTheory.MeasureSpace.volume)","decl":"/-- If `f` is a periodic function with period `T`, then its integral over `[t, t + T]` does not\ndepend on `t`. -/\ntheorem intervalIntegral_add_eq (hf : Periodic f T) (t s : ℝ) :\n    ∫ x in t..t + T, f x = ∫ x in s..s + T, f x := by\n  rcases lt_trichotomy (0 : ℝ) T with (hT | rfl | hT)\n  · exact hf.intervalIntegral_add_eq_of_pos hT t s\n  · simp\n  · rw [← neg_inj, ← integral_symm, ← integral_symm]\n    simpa only [← sub_eq_add_neg, add_sub_cancel_right] using\n      hf.neg.intervalIntegral_add_eq_of_pos (neg_pos.2 hT) (t + T) (s + T)\n\n"}
{"name":"Function.Periodic.intervalIntegral_add_eq_add","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\nf : Real → E\nT : Real\ninst✝ : NormedSpace Real E\nhf : Function.Periodic f T\nt s : Real\nh_int : ∀ (t₁ t₂ : Real), IntervalIntegrable f MeasureTheory.MeasureSpace.volume t₁ t₂\n⊢ Eq (intervalIntegral (fun x => f x) t (HAdd.hAdd s T) MeasureTheory.MeasureSpace.volume) (HAdd.hAdd (intervalIntegral (fun x => f x) t s MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => f x) t (HAdd.hAdd t T) MeasureTheory.MeasureSpace.volume))","decl":"/-- If `f` is an integrable periodic function with period `T`, then its integral over `[t, s + T]`\nis the sum of its integrals over the intervals `[t, s]` and `[t, t + T]`. -/\ntheorem intervalIntegral_add_eq_add (hf : Periodic f T) (t s : ℝ)\n    (h_int : ∀ t₁ t₂, IntervalIntegrable f MeasureSpace.volume t₁ t₂) :\n    ∫ x in t..s + T, f x = (∫ x in t..s, f x) + ∫ x in t..t + T, f x := by\n  rw [hf.intervalIntegral_add_eq t s, integral_add_adjacent_intervals (h_int t s) (h_int s _)]\n\n"}
{"name":"Function.Periodic.intervalIntegral_add_zsmul_eq","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\nf : Real → E\nT : Real\ninst✝ : NormedSpace Real E\nhf : Function.Periodic f T\nn : Int\nt : Real\nh_int : ∀ (t₁ t₂ : Real), IntervalIntegrable f MeasureTheory.MeasureSpace.volume t₁ t₂\n⊢ Eq (intervalIntegral (fun x => f x) t (HAdd.hAdd t (HSMul.hSMul n T)) MeasureTheory.MeasureSpace.volume) (HSMul.hSMul n (intervalIntegral (fun x => f x) t (HAdd.hAdd t T) MeasureTheory.MeasureSpace.volume))","decl":"/-- If `f` is an integrable periodic function with period `T`, and `n` is an integer, then its\nintegral over `[t, t + n • T]` is `n` times its integral over `[t, t + T]`. -/\ntheorem intervalIntegral_add_zsmul_eq (hf : Periodic f T) (n : ℤ) (t : ℝ)\n    (h_int : ∀ t₁ t₂, IntervalIntegrable f MeasureSpace.volume t₁ t₂) :\n    ∫ x in t..t + n • T, f x = n • ∫ x in t..t + T, f x := by\n  -- Reduce to the case `b = 0`\n  suffices (∫ x in (0)..(n • T), f x) = n • ∫ x in (0)..T, f x by\n    simp only [hf.intervalIntegral_add_eq t 0, (hf.zsmul n).intervalIntegral_add_eq t 0, zero_add,\n      this]\n  -- First prove it for natural numbers\n  have : ∀ m : ℕ, (∫ x in (0)..m • T, f x) = m • ∫ x in (0)..T, f x := fun m ↦ by\n    induction' m with m ih\n    · simp\n    · simp only [succ_nsmul, hf.intervalIntegral_add_eq_add 0 (m • T) h_int, ih, zero_add]\n  -- Then prove it for all integers\n  cases' n with n n\n  · simp [← this n]\n  · conv_rhs => rw [negSucc_zsmul]\n    have h₀ : Int.negSucc n • T + (n + 1) • T = 0 := by simp; linarith\n    rw [integral_symm, ← (hf.nsmul (n + 1)).funext, neg_inj]\n    simp_rw [integral_comp_add_right, h₀, zero_add, this (n + 1), add_comm T,\n      hf.intervalIntegral_add_eq ((n + 1) • T) 0, zero_add]\n\n"}
{"name":"Function.Periodic.sInf_add_zsmul_le_integral_of_pos","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\ng : Real → Real\nhg : Function.Periodic g T\nh_int : IntervalIntegrable g MeasureTheory.MeasureSpace.volume 0 T\nhT : LT.lt 0 T\nt : Real\n⊢ LE.le (HAdd.hAdd (InfSet.sInf (Set.image (fun t => intervalIntegral (fun x => g x) 0 t MeasureTheory.MeasureSpace.volume) (Set.Icc 0 T))) (HSMul.hSMul (Int.floor (HDiv.hDiv t T)) (intervalIntegral (fun x => g x) 0 T MeasureTheory.MeasureSpace.volume))) (intervalIntegral (fun x => g x) 0 t MeasureTheory.MeasureSpace.volume)","decl":"/-- If `g : ℝ → ℝ` is periodic with period `T > 0`, then for any `t : ℝ`, the function\n`t ↦ ∫ x in 0..t, g x` is bounded below by `t ↦ X + ⌊t/T⌋ • Y` for appropriate constants `X` and\n`Y`. -/\ntheorem sInf_add_zsmul_le_integral_of_pos (h_int : IntervalIntegrable g MeasureSpace.volume 0 T)\n    (hT : 0 < T) (t : ℝ) :\n    (sInf ((fun t => ∫ x in (0)..t, g x) '' Icc 0 T) + ⌊t / T⌋ • ∫ x in (0)..T, g x) ≤\n      ∫ x in (0)..t, g x := by\n  let h'_int := hg.intervalIntegrable₀ hT h_int\n  let ε := Int.fract (t / T) * T\n  conv_rhs =>\n    rw [← Int.fract_div_mul_self_add_zsmul_eq T t (by linarith),\n      ← integral_add_adjacent_intervals (h'_int 0 ε) (h'_int _ _)]\n  rw [hg.intervalIntegral_add_zsmul_eq ⌊t / T⌋ ε (hg.intervalIntegrable₀ hT h_int),\n    hg.intervalIntegral_add_eq ε 0, zero_add, add_le_add_iff_right]\n  exact (continuous_primitive h'_int 0).continuousOn.sInf_image_Icc_le <|\n    mem_Icc_of_Ico (Int.fract_div_mul_self_mem_Ico T t hT)\n\n"}
{"name":"Function.Periodic.integral_le_sSup_add_zsmul_of_pos","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\ng : Real → Real\nhg : Function.Periodic g T\nh_int : IntervalIntegrable g MeasureTheory.MeasureSpace.volume 0 T\nhT : LT.lt 0 T\nt : Real\n⊢ LE.le (intervalIntegral (fun x => g x) 0 t MeasureTheory.MeasureSpace.volume) (HAdd.hAdd (SupSet.sSup (Set.image (fun t => intervalIntegral (fun x => g x) 0 t MeasureTheory.MeasureSpace.volume) (Set.Icc 0 T))) (HSMul.hSMul (Int.floor (HDiv.hDiv t T)) (intervalIntegral (fun x => g x) 0 T MeasureTheory.MeasureSpace.volume)))","decl":"/-- If `g : ℝ → ℝ` is periodic with period `T > 0`, then for any `t : ℝ`, the function\n`t ↦ ∫ x in 0..t, g x` is bounded above by `t ↦ X + ⌊t/T⌋ • Y` for appropriate constants `X` and\n`Y`. -/\ntheorem integral_le_sSup_add_zsmul_of_pos (h_int : IntervalIntegrable g MeasureSpace.volume 0 T)\n    (hT : 0 < T) (t : ℝ) :\n    (∫ x in (0)..t, g x) ≤\n      sSup ((fun t => ∫ x in (0)..t, g x) '' Icc 0 T) + ⌊t / T⌋ • ∫ x in (0)..T, g x := by\n  let h'_int := hg.intervalIntegrable₀ hT h_int\n  let ε := Int.fract (t / T) * T\n  conv_lhs =>\n    rw [← Int.fract_div_mul_self_add_zsmul_eq T t (by linarith), ←\n      integral_add_adjacent_intervals (h'_int 0 ε) (h'_int _ _)]\n  rw [hg.intervalIntegral_add_zsmul_eq ⌊t / T⌋ ε h'_int, hg.intervalIntegral_add_eq ε 0, zero_add,\n    add_le_add_iff_right]\n  exact (continuous_primitive h'_int 0).continuousOn.le_sSup_image_Icc\n    (mem_Icc_of_Ico (Int.fract_div_mul_self_mem_Ico T t hT))\n\n"}
{"name":"Function.Periodic.tendsto_atTop_intervalIntegral_of_pos","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\ng : Real → Real\nhg : Function.Periodic g T\nh₀ : LT.lt 0 (intervalIntegral (fun x => g x) 0 T MeasureTheory.MeasureSpace.volume)\nhT : LT.lt 0 T\n⊢ Filter.Tendsto (fun t => intervalIntegral (fun x => g x) 0 t MeasureTheory.MeasureSpace.volume) Filter.atTop Filter.atTop","decl":"/-- If `g : ℝ → ℝ` is periodic with period `T > 0` and `0 < ∫ x in 0..T, g x`, then\n`t ↦ ∫ x in 0..t, g x` tends to `∞` as `t` tends to `∞`. -/\ntheorem tendsto_atTop_intervalIntegral_of_pos (h₀ : 0 < ∫ x in (0)..T, g x) (hT : 0 < T) :\n    Tendsto (fun t => ∫ x in (0)..t, g x) atTop atTop := by\n  have h_int := intervalIntegrable_of_integral_ne_zero h₀.ne'\n  apply tendsto_atTop_mono (hg.sInf_add_zsmul_le_integral_of_pos h_int hT)\n  apply atTop.tendsto_atTop_add_const_left (sInf <| (fun t => ∫ x in (0)..t, g x) '' Icc 0 T)\n  apply Tendsto.atTop_zsmul_const h₀\n  exact tendsto_floor_atTop.comp (tendsto_id.atTop_mul_const (inv_pos.mpr hT))\n\n"}
{"name":"Function.Periodic.tendsto_atBot_intervalIntegral_of_pos","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\ng : Real → Real\nhg : Function.Periodic g T\nh₀ : LT.lt 0 (intervalIntegral (fun x => g x) 0 T MeasureTheory.MeasureSpace.volume)\nhT : LT.lt 0 T\n⊢ Filter.Tendsto (fun t => intervalIntegral (fun x => g x) 0 t MeasureTheory.MeasureSpace.volume) Filter.atBot Filter.atBot","decl":"/-- If `g : ℝ → ℝ` is periodic with period `T > 0` and `0 < ∫ x in 0..T, g x`, then\n`t ↦ ∫ x in 0..t, g x` tends to `-∞` as `t` tends to `-∞`. -/\ntheorem tendsto_atBot_intervalIntegral_of_pos (h₀ : 0 < ∫ x in (0)..T, g x) (hT : 0 < T) :\n    Tendsto (fun t => ∫ x in (0)..t, g x) atBot atBot := by\n  have h_int := intervalIntegrable_of_integral_ne_zero h₀.ne'\n  apply tendsto_atBot_mono (hg.integral_le_sSup_add_zsmul_of_pos h_int hT)\n  apply atBot.tendsto_atBot_add_const_left (sSup <| (fun t => ∫ x in (0)..t, g x) '' Icc 0 T)\n  apply Tendsto.atBot_zsmul_const h₀\n  exact tendsto_floor_atBot.comp (tendsto_id.atBot_mul_const (inv_pos.mpr hT))\n\n"}
{"name":"Function.Periodic.tendsto_atTop_intervalIntegral_of_pos'","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\ng : Real → Real\nhg : Function.Periodic g T\nh_int : IntervalIntegrable g MeasureTheory.MeasureSpace.volume 0 T\nh₀ : ∀ (x : Real), LT.lt 0 (g x)\nhT : LT.lt 0 T\n⊢ Filter.Tendsto (fun t => intervalIntegral (fun x => g x) 0 t MeasureTheory.MeasureSpace.volume) Filter.atTop Filter.atTop","decl":"/-- If `g : ℝ → ℝ` is periodic with period `T > 0` and `∀ x, 0 < g x`, then `t ↦ ∫ x in 0..t, g x`\ntends to `∞` as `t` tends to `∞`. -/\ntheorem tendsto_atTop_intervalIntegral_of_pos'\n    (h_int : IntervalIntegrable g MeasureSpace.volume 0 T) (h₀ : ∀ x, 0 < g x) (hT : 0 < T) :\n    Tendsto (fun t => ∫ x in (0)..t, g x) atTop atTop :=\n  hg.tendsto_atTop_intervalIntegral_of_pos (intervalIntegral_pos_of_pos h_int h₀ hT) hT\n\n"}
{"name":"Function.Periodic.tendsto_atBot_intervalIntegral_of_pos'","module":"Mathlib.MeasureTheory.Integral.Periodic","initialProofState":"T : Real\ng : Real → Real\nhg : Function.Periodic g T\nh_int : IntervalIntegrable g MeasureTheory.MeasureSpace.volume 0 T\nh₀ : ∀ (x : Real), LT.lt 0 (g x)\nhT : LT.lt 0 T\n⊢ Filter.Tendsto (fun t => intervalIntegral (fun x => g x) 0 t MeasureTheory.MeasureSpace.volume) Filter.atBot Filter.atBot","decl":"/-- If `g : ℝ → ℝ` is periodic with period `T > 0` and `∀ x, 0 < g x`, then `t ↦ ∫ x in 0..t, g x`\ntends to `-∞` as `t` tends to `-∞`. -/\ntheorem tendsto_atBot_intervalIntegral_of_pos'\n    (h_int : IntervalIntegrable g MeasureSpace.volume 0 T) (h₀ : ∀ x, 0 < g x) (hT : 0 < T) :\n    Tendsto (fun t => ∫ x in (0)..t, g x) atBot atBot := by\n  exact hg.tendsto_atBot_intervalIntegral_of_pos (intervalIntegral_pos_of_pos h_int h₀ hT) hT\n\n"}
