{"name":"PartOrd.instParentProjectionPreorderPartialOrderToPreorder","module":"Mathlib.Order.Category.PartOrd","initialProofState":"⊢ CategoryTheory.BundledHom.ParentProjection @PartialOrder.toPreorder","decl":"instance : BundledHom.ParentProjection @PartialOrder.toPreorder :=\n  ⟨⟩\n\n"}
{"name":"PartOrd.coe_of","module":"Mathlib.Order.Category.PartOrd","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\n⊢ Eq (↑(PartOrd.of α)) α","decl":"@[simp]\ntheorem coe_of (α : Type*) [PartialOrder α] : ↥(of α) = α :=\n  rfl\n\n"}
{"name":"PartOrd.Iso.mk_inv","module":"Mathlib.Order.Category.PartOrd","initialProofState":"α β : PartOrd\ne : OrderIso ↑α ↑β\n⊢ Eq (PartOrd.Iso.mk e).inv ↑e.symm","decl":"/-- Constructs an equivalence between partial orders from an order isomorphism between them. -/\n@[simps]\ndef Iso.mk {α β : PartOrd.{u}} (e : α ≃o β) : α ≅ β where\n  hom := (e : OrderHom α β)\n  inv := (e.symm : OrderHom β α)\n  hom_inv_id := by\n    ext x\n    exact e.symm_apply_apply x\n  inv_hom_id := by\n    ext x\n    exact e.apply_symm_apply x\n\n"}
{"name":"PartOrd.Iso.mk_hom","module":"Mathlib.Order.Category.PartOrd","initialProofState":"α β : PartOrd\ne : OrderIso ↑α ↑β\n⊢ Eq (PartOrd.Iso.mk e).hom ↑e","decl":"/-- Constructs an equivalence between partial orders from an order isomorphism between them. -/\n@[simps]\ndef Iso.mk {α β : PartOrd.{u}} (e : α ≃o β) : α ≅ β where\n  hom := (e : OrderHom α β)\n  inv := (e.symm : OrderHom β α)\n  hom_inv_id := by\n    ext x\n    exact e.symm_apply_apply x\n  inv_hom_id := by\n    ext x\n    exact e.apply_symm_apply x\n\n"}
{"name":"PartOrd.dual_obj","module":"Mathlib.Order.Category.PartOrd","initialProofState":"X : PartOrd\n⊢ Eq (PartOrd.dual.obj X) (PartOrd.of (OrderDual ↑X))","decl":"/-- `OrderDual` as a functor. -/\n@[simps]\ndef dual : PartOrd ⥤ PartOrd where\n  obj X := of Xᵒᵈ\n  map := OrderHom.dual\n\n"}
{"name":"PartOrd.dual_map","module":"Mathlib.Order.Category.PartOrd","initialProofState":"X✝ Y✝ : PartOrd\na : OrderHom ↑X✝ ↑Y✝\n⊢ Eq (PartOrd.dual.map a) (OrderHom.dual a)","decl":"/-- `OrderDual` as a functor. -/\n@[simps]\ndef dual : PartOrd ⥤ PartOrd where\n  obj X := of Xᵒᵈ\n  map := OrderHom.dual\n\n"}
{"name":"PartOrd.dualEquiv_functor","module":"Mathlib.Order.Category.PartOrd","initialProofState":"⊢ Eq PartOrd.dualEquiv.functor PartOrd.dual","decl":"/-- The equivalence between `PartOrd` and itself induced by `OrderDual` both ways. -/\n@[simps functor inverse]\ndef dualEquiv : PartOrd ≌ PartOrd where\n  functor := dual\n  inverse := dual\n  unitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n  counitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n\n"}
{"name":"PartOrd.dualEquiv_inverse","module":"Mathlib.Order.Category.PartOrd","initialProofState":"⊢ Eq PartOrd.dualEquiv.inverse PartOrd.dual","decl":"/-- The equivalence between `PartOrd` and itself induced by `OrderDual` both ways. -/\n@[simps functor inverse]\ndef dualEquiv : PartOrd ≌ PartOrd where\n  functor := dual\n  inverse := dual\n  unitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n  counitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n\n"}
{"name":"partOrd_dual_comp_forget_to_preord","module":"Mathlib.Order.Category.PartOrd","initialProofState":"⊢ Eq (PartOrd.dual.comp (CategoryTheory.forget₂ PartOrd Preord)) ((CategoryTheory.forget₂ PartOrd Preord).comp Preord.dual)","decl":"theorem partOrd_dual_comp_forget_to_preord :\n    PartOrd.dual ⋙ forget₂ PartOrd Preord =\n      forget₂ PartOrd Preord ⋙ Preord.dual :=\n  rfl\n\n"}
{"name":"preordToPartOrdCompToDualIsoToDualCompPreordToPartOrd_hom_app_coe","module":"Mathlib.Order.Category.PartOrd","initialProofState":"X : Preord\na : ↑((preordToPartOrd.comp PartOrd.dual).obj X)\n⊢ Eq ((preordToPartOrdCompToDualIsoToDualCompPreordToPartOrd.hom.app X) a) ((OrderIso.dualAntisymmetrization ↑X) a)","decl":"/-- `PreordToPartOrd` and `OrderDual` commute. -/\n@[simps! inv_app_coe, simps! (config := .lemmasOnly) hom_app_coe]\ndef preordToPartOrdCompToDualIsoToDualCompPreordToPartOrd :\n    preordToPartOrd.{u} ⋙ PartOrd.dual ≅ Preord.dual ⋙ preordToPartOrd :=\n  NatIso.ofComponents (fun _ => PartOrd.Iso.mk <| OrderIso.dualAntisymmetrization _)\n    (fun _ => OrderHom.ext _ _ <| funext fun x => Quotient.inductionOn' x fun _ => rfl)\n\n-- This lemma was always bad, but the linter only noticed after https://github.com/leanprover/lean4/pull/2644\n"}
{"name":"preordToPartOrdCompToDualIsoToDualCompPreordToPartOrd_inv_app_coe","module":"Mathlib.Order.Category.PartOrd","initialProofState":"X : Preord\na : ↑((Preord.dual.comp preordToPartOrd).obj X)\n⊢ Eq ((preordToPartOrdCompToDualIsoToDualCompPreordToPartOrd.inv.app X) a) ((OrderIso.dualAntisymmetrization ↑X).symm a)","decl":"/-- `PreordToPartOrd` and `OrderDual` commute. -/\n@[simps! inv_app_coe, simps! (config := .lemmasOnly) hom_app_coe]\ndef preordToPartOrdCompToDualIsoToDualCompPreordToPartOrd :\n    preordToPartOrd.{u} ⋙ PartOrd.dual ≅ Preord.dual ⋙ preordToPartOrd :=\n  NatIso.ofComponents (fun _ => PartOrd.Iso.mk <| OrderIso.dualAntisymmetrization _)\n    (fun _ => OrderHom.ext _ _ <| funext fun x => Quotient.inductionOn' x fun _ => rfl)\n\n-- This lemma was always bad, but the linter only noticed after https://github.com/leanprover/lean4/pull/2644\n"}
