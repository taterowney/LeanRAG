{"name":"MulZeroClass.mul_zero","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u\nself : MulZeroClass M₀\na : M₀\n⊢ Eq (HMul.hMul a 0) 0","decl":"/-- Typeclass for expressing that a type `M₀` with multiplication and a zero satisfies\n`0 * a = 0` and `a * 0 = 0` for all `a : M₀`. -/\nclass MulZeroClass (M₀ : Type u) extends Mul M₀, Zero M₀ where\n  /-- Zero is a left absorbing element for multiplication -/\n  zero_mul : ∀ a : M₀, 0 * a = 0\n  /-- Zero is a right absorbing element for multiplication -/\n  mul_zero : ∀ a : M₀, a * 0 = 0\n\n"}
{"name":"MulZeroClass.zero_mul","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u\nself : MulZeroClass M₀\na : M₀\n⊢ Eq (HMul.hMul 0 a) 0","decl":"/-- Typeclass for expressing that a type `M₀` with multiplication and a zero satisfies\n`0 * a = 0` and `a * 0 = 0` for all `a : M₀`. -/\nclass MulZeroClass (M₀ : Type u) extends Mul M₀, Zero M₀ where\n  /-- Zero is a left absorbing element for multiplication -/\n  zero_mul : ∀ a : M₀, 0 * a = 0\n  /-- Zero is a right absorbing element for multiplication -/\n  mul_zero : ∀ a : M₀, a * 0 = 0\n\n"}
{"name":"IsLeftCancelMulZero.mul_left_cancel_of_ne_zero","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u\ninst✝¹ : Mul M₀\ninst✝ : Zero M₀\nself : IsLeftCancelMulZero M₀\na b c : M₀\na✝¹ : Ne a 0\na✝ : Eq (HMul.hMul a b) (HMul.hMul a c)\n⊢ Eq b c","decl":"/-- A mixin for left cancellative multiplication by nonzero elements. -/\nclass IsLeftCancelMulZero (M₀ : Type u) [Mul M₀] [Zero M₀] : Prop where\n  /-- Multiplication by a nonzero element is left cancellative. -/\n  protected mul_left_cancel_of_ne_zero : ∀ {a b c : M₀}, a ≠ 0 → a * b = a * c → b = c\n\n"}
{"name":"mul_left_cancel₀","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_1\ninst✝² : Mul M₀\ninst✝¹ : Zero M₀\ninst✝ : IsLeftCancelMulZero M₀\na b c : M₀\nha : Ne a 0\nh : Eq (HMul.hMul a b) (HMul.hMul a c)\n⊢ Eq b c","decl":"theorem mul_left_cancel₀ (ha : a ≠ 0) (h : a * b = a * c) : b = c :=\n  IsLeftCancelMulZero.mul_left_cancel_of_ne_zero ha h\n\n"}
{"name":"mul_right_injective₀","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_1\ninst✝² : Mul M₀\ninst✝¹ : Zero M₀\ninst✝ : IsLeftCancelMulZero M₀\na : M₀\nha : Ne a 0\n⊢ Function.Injective fun x => HMul.hMul a x","decl":"theorem mul_right_injective₀ (ha : a ≠ 0) : Function.Injective (a * ·) :=\n  fun _ _ => mul_left_cancel₀ ha\n\n"}
{"name":"IsRightCancelMulZero.mul_right_cancel_of_ne_zero","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u\ninst✝¹ : Mul M₀\ninst✝ : Zero M₀\nself : IsRightCancelMulZero M₀\na b c : M₀\na✝¹ : Ne b 0\na✝ : Eq (HMul.hMul a b) (HMul.hMul c b)\n⊢ Eq a c","decl":"/-- A mixin for right cancellative multiplication by nonzero elements. -/\nclass IsRightCancelMulZero (M₀ : Type u) [Mul M₀] [Zero M₀] : Prop where\n  /-- Multiplicatin by a nonzero element is right cancellative. -/\n  protected mul_right_cancel_of_ne_zero : ∀ {a b c : M₀}, b ≠ 0 → a * b = c * b → a = c\n\n"}
{"name":"mul_right_cancel₀","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_1\ninst✝² : Mul M₀\ninst✝¹ : Zero M₀\ninst✝ : IsRightCancelMulZero M₀\na b c : M₀\nhb : Ne b 0\nh : Eq (HMul.hMul a b) (HMul.hMul c b)\n⊢ Eq a c","decl":"theorem mul_right_cancel₀ (hb : b ≠ 0) (h : a * b = c * b) : a = c :=\n  IsRightCancelMulZero.mul_right_cancel_of_ne_zero hb h\n\n"}
{"name":"mul_left_injective₀","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_1\ninst✝² : Mul M₀\ninst✝¹ : Zero M₀\ninst✝ : IsRightCancelMulZero M₀\nb : M₀\nhb : Ne b 0\n⊢ Function.Injective fun a => HMul.hMul a b","decl":"theorem mul_left_injective₀ (hb : b ≠ 0) : Function.Injective fun a => a * b :=\n  fun _ _ => mul_right_cancel₀ hb\n\n"}
{"name":"IsCancelMulZero.toIsLeftCancelMulZero","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u\ninst✝¹ : Mul M₀\ninst✝ : Zero M₀\nself : IsCancelMulZero M₀\n⊢ IsLeftCancelMulZero M₀","decl":"/-- A mixin for cancellative multiplication by nonzero elements. -/\nclass IsCancelMulZero (M₀ : Type u) [Mul M₀] [Zero M₀]\n  extends IsLeftCancelMulZero M₀, IsRightCancelMulZero M₀ : Prop\n\n"}
{"name":"IsCancelMulZero.toIsRightCancelMulZero","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u\ninst✝¹ : Mul M₀\ninst✝ : Zero M₀\nself : IsCancelMulZero M₀\n⊢ IsRightCancelMulZero M₀","decl":"/-- A mixin for cancellative multiplication by nonzero elements. -/\nclass IsCancelMulZero (M₀ : Type u) [Mul M₀] [Zero M₀]\n  extends IsLeftCancelMulZero M₀, IsRightCancelMulZero M₀ : Prop\n\n"}
{"name":"NoZeroDivisors.eq_zero_or_eq_zero_of_mul_eq_zero","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_2\ninst✝¹ : Mul M₀\ninst✝ : Zero M₀\nself : NoZeroDivisors M₀\na b : M₀\na✝ : Eq (HMul.hMul a b) 0\n⊢ Or (Eq a 0) (Eq b 0)","decl":"/-- Predicate typeclass for expressing that `a * b = 0` implies `a = 0` or `b = 0`\nfor all `a` and `b` of type `G₀`. -/\nclass NoZeroDivisors (M₀ : Type*) [Mul M₀] [Zero M₀] : Prop where\n  /-- For all `a` and `b` of `G₀`, `a * b = 0` implies `a = 0` or `b = 0`. -/\n  eq_zero_or_eq_zero_of_mul_eq_zero : ∀ {a b : M₀}, a * b = 0 → a = 0 ∨ b = 0\n\n"}
{"name":"SemigroupWithZero.zero_mul","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"S₀ : Type u\nself : SemigroupWithZero S₀\na : S₀\n⊢ Eq (HMul.hMul 0 a) 0","decl":"/-- A type `S₀` is a \"semigroup with zero” if it is a semigroup with zero element, and `0` is left\nand right absorbing. -/\nclass SemigroupWithZero (S₀ : Type u) extends Semigroup S₀, MulZeroClass S₀\n\n"}
{"name":"SemigroupWithZero.mul_zero","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"S₀ : Type u\nself : SemigroupWithZero S₀\na : S₀\n⊢ Eq (HMul.hMul a 0) 0","decl":"/-- A type `S₀` is a \"semigroup with zero” if it is a semigroup with zero element, and `0` is left\nand right absorbing. -/\nclass SemigroupWithZero (S₀ : Type u) extends Semigroup S₀, MulZeroClass S₀\n\n"}
{"name":"MulZeroOneClass.zero_mul","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u\nself : MulZeroOneClass M₀\na : M₀\n⊢ Eq (HMul.hMul 0 a) 0","decl":"/-- A typeclass for non-associative monoids with zero elements. -/\nclass MulZeroOneClass (M₀ : Type u) extends MulOneClass M₀, MulZeroClass M₀\n\n"}
{"name":"MulZeroOneClass.mul_zero","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u\nself : MulZeroOneClass M₀\na : M₀\n⊢ Eq (HMul.hMul a 0) 0","decl":"/-- A typeclass for non-associative monoids with zero elements. -/\nclass MulZeroOneClass (M₀ : Type u) extends MulOneClass M₀, MulZeroClass M₀\n\n"}
{"name":"MonoidWithZero.mul_zero","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u\nself : MonoidWithZero M₀\na : M₀\n⊢ Eq (HMul.hMul a 0) 0","decl":"/-- A type `M₀` is a “monoid with zero” if it is a monoid with zero element, and `0` is left\nand right absorbing. -/\nclass MonoidWithZero (M₀ : Type u) extends Monoid M₀, MulZeroOneClass M₀, SemigroupWithZero M₀\n\n"}
{"name":"MonoidWithZero.zero_mul","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u\nself : MonoidWithZero M₀\na : M₀\n⊢ Eq (HMul.hMul 0 a) 0","decl":"/-- A type `M₀` is a “monoid with zero” if it is a monoid with zero element, and `0` is left\nand right absorbing. -/\nclass MonoidWithZero (M₀ : Type u) extends Monoid M₀, MulZeroOneClass M₀, SemigroupWithZero M₀\n\n"}
{"name":"CancelMonoidWithZero.toIsCancelMulZero","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_2\nself : CancelMonoidWithZero M₀\n⊢ IsCancelMulZero M₀","decl":"/-- A type `M` is a `CancelMonoidWithZero` if it is a monoid with zero element, `0` is left\nand right absorbing, and left/right multiplication by a non-zero element is injective. -/\nclass CancelMonoidWithZero (M₀ : Type*) extends MonoidWithZero M₀, IsCancelMulZero M₀\n\n"}
{"name":"CommMonoidWithZero.zero_mul","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_2\nself : CommMonoidWithZero M₀\na : M₀\n⊢ Eq (HMul.hMul 0 a) 0","decl":"/-- A type `M` is a commutative “monoid with zero” if it is a commutative monoid with zero\nelement, and `0` is left and right absorbing. -/\nclass CommMonoidWithZero (M₀ : Type*) extends CommMonoid M₀, MonoidWithZero M₀\n\n"}
{"name":"CommMonoidWithZero.mul_zero","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_2\nself : CommMonoidWithZero M₀\na : M₀\n⊢ Eq (HMul.hMul a 0) 0","decl":"/-- A type `M` is a commutative “monoid with zero” if it is a commutative monoid with zero\nelement, and `0` is left and right absorbing. -/\nclass CommMonoidWithZero (M₀ : Type*) extends CommMonoid M₀, MonoidWithZero M₀\n\n"}
{"name":"mul_left_inj'","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_1\ninst✝ : CancelMonoidWithZero M₀\na b c : M₀\nhc : Ne c 0\n⊢ Iff (Eq (HMul.hMul a c) (HMul.hMul b c)) (Eq a b)","decl":"theorem mul_left_inj' (hc : c ≠ 0) : a * c = b * c ↔ a = b :=\n  (mul_left_injective₀ hc).eq_iff\n\n"}
{"name":"mul_right_inj'","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_1\ninst✝ : CancelMonoidWithZero M₀\na b c : M₀\nha : Ne a 0\n⊢ Iff (Eq (HMul.hMul a b) (HMul.hMul a c)) (Eq b c)","decl":"theorem mul_right_inj' (ha : a ≠ 0) : a * b = a * c ↔ b = c :=\n  (mul_right_injective₀ ha).eq_iff\n\n"}
{"name":"IsLeftCancelMulZero.to_isRightCancelMulZero","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_1\ninst✝² : CommSemigroup M₀\ninst✝¹ : Zero M₀\ninst✝ : IsLeftCancelMulZero M₀\n⊢ IsRightCancelMulZero M₀","decl":"lemma IsLeftCancelMulZero.to_isRightCancelMulZero [IsLeftCancelMulZero M₀] :\n    IsRightCancelMulZero M₀ :=\n{ mul_right_cancel_of_ne_zero :=\n    fun hb h => mul_left_cancel₀ hb <| (mul_comm _ _).trans (h.trans (mul_comm _ _)) }\n\n"}
{"name":"IsRightCancelMulZero.to_isLeftCancelMulZero","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_1\ninst✝² : CommSemigroup M₀\ninst✝¹ : Zero M₀\ninst✝ : IsRightCancelMulZero M₀\n⊢ IsLeftCancelMulZero M₀","decl":"lemma IsRightCancelMulZero.to_isLeftCancelMulZero [IsRightCancelMulZero M₀] :\n    IsLeftCancelMulZero M₀ :=\n{ mul_left_cancel_of_ne_zero :=\n    fun hb h => mul_right_cancel₀ hb <| (mul_comm _ _).trans (h.trans (mul_comm _ _)) }\n\n"}
{"name":"IsLeftCancelMulZero.to_isCancelMulZero","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_1\ninst✝² : CommSemigroup M₀\ninst✝¹ : Zero M₀\ninst✝ : IsLeftCancelMulZero M₀\n⊢ IsCancelMulZero M₀","decl":"lemma IsLeftCancelMulZero.to_isCancelMulZero [IsLeftCancelMulZero M₀] :\n    IsCancelMulZero M₀ :=\n{ IsLeftCancelMulZero.to_isRightCancelMulZero with }\n\n"}
{"name":"IsRightCancelMulZero.to_isCancelMulZero","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_1\ninst✝² : CommSemigroup M₀\ninst✝¹ : Zero M₀\ninst✝ : IsRightCancelMulZero M₀\n⊢ IsCancelMulZero M₀","decl":"lemma IsRightCancelMulZero.to_isCancelMulZero [IsRightCancelMulZero M₀] :\n    IsCancelMulZero M₀ :=\n{ IsRightCancelMulZero.to_isLeftCancelMulZero with }\n\n"}
{"name":"CancelCommMonoidWithZero.toIsLeftCancelMulZero","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_2\nself : CancelCommMonoidWithZero M₀\n⊢ IsLeftCancelMulZero M₀","decl":"/-- A type `M` is a `CancelCommMonoidWithZero` if it is a commutative monoid with zero element,\n `0` is left and right absorbing,\n  and left/right multiplication by a non-zero element is injective. -/\nclass CancelCommMonoidWithZero (M₀ : Type*) extends CommMonoidWithZero M₀, IsLeftCancelMulZero M₀\n\n-- See note [lower cancel priority]\n"}
{"name":"MulDivCancelClass.mul_div_cancel","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_2\ninst✝¹ : MonoidWithZero M₀\ninst✝ : Div M₀\nself : MulDivCancelClass M₀\na b : M₀\na✝ : Ne b 0\n⊢ Eq (HDiv.hDiv (HMul.hMul a b) b) a","decl":"/-- Prop-valued mixin for a monoid with zero to be equipped with a cancelling division.\n\nThe obvious use case is groups with zero, but this condition is also satisfied by `ℕ`, `ℤ` and, more\ngenerally, any euclidean domain. -/\nclass MulDivCancelClass (M₀ : Type*) [MonoidWithZero M₀] [Div M₀] : Prop where\n  protected mul_div_cancel (a b : M₀) : b ≠ 0 → a * b / b = a\n\n"}
{"name":"mul_div_cancel_right₀","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_1\ninst✝² : MonoidWithZero M₀\ninst✝¹ : Div M₀\ninst✝ : MulDivCancelClass M₀\na b : M₀\nhb : Ne b 0\n⊢ Eq (HDiv.hDiv (HMul.hMul a b) b) a","decl":"@[simp] lemma mul_div_cancel_right₀ (a : M₀) {b : M₀} (hb : b ≠ 0) : a * b / b = a :=\n  MulDivCancelClass.mul_div_cancel _ _ hb\n\n"}
{"name":"mul_div_cancel_left₀","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_1\ninst✝² : CommMonoidWithZero M₀\ninst✝¹ : Div M₀\ninst✝ : MulDivCancelClass M₀\nb a : M₀\nha : Ne a 0\n⊢ Eq (HDiv.hDiv (HMul.hMul a b) a) b","decl":"@[simp] lemma mul_div_cancel_left₀ (b : M₀) {a : M₀} (ha : a ≠ 0) : a * b / a = b := by\n  rw [mul_comm, mul_div_cancel_right₀ _ ha]\n\n"}
{"name":"GroupWithZero.zpow_neg'","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"G₀ : Type u\nself : GroupWithZero G₀\nn : Nat\na : G₀\n⊢ Eq (GroupWithZero.zpow (Int.negSucc n) a) (Inv.inv (GroupWithZero.zpow (↑n.succ) a))","decl":"/-- A type `G₀` is a “group with zero” if it is a monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an “inverse” function, and the inverse of `0` must be `0`.\n\nExamples include division rings and the ordered monoids that are the\ntarget of valuations in general valuation theory. -/\nclass GroupWithZero (G₀ : Type u) extends MonoidWithZero G₀, DivInvMonoid G₀, Nontrivial G₀ where\n  /-- The inverse of `0` in a group with zero is `0`. -/\n  protected inv_zero : (0 : G₀)⁻¹ = 0\n  /-- Every nonzero element of a group with zero is invertible. -/\n  protected mul_inv_cancel (a : G₀) : a ≠ 0 → a * a⁻¹ = 1\n\n"}
{"name":"GroupWithZero.zpow_zero'","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"G₀ : Type u\nself : GroupWithZero G₀\na : G₀\n⊢ Eq (GroupWithZero.zpow 0 a) 1","decl":"/-- A type `G₀` is a “group with zero” if it is a monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an “inverse” function, and the inverse of `0` must be `0`.\n\nExamples include division rings and the ordered monoids that are the\ntarget of valuations in general valuation theory. -/\nclass GroupWithZero (G₀ : Type u) extends MonoidWithZero G₀, DivInvMonoid G₀, Nontrivial G₀ where\n  /-- The inverse of `0` in a group with zero is `0`. -/\n  protected inv_zero : (0 : G₀)⁻¹ = 0\n  /-- Every nonzero element of a group with zero is invertible. -/\n  protected mul_inv_cancel (a : G₀) : a ≠ 0 → a * a⁻¹ = 1\n\n"}
{"name":"GroupWithZero.zpow_succ'","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"G₀ : Type u\nself : GroupWithZero G₀\nn : Nat\na : G₀\n⊢ Eq (GroupWithZero.zpow (↑n.succ) a) (HMul.hMul (GroupWithZero.zpow (↑n) a) a)","decl":"/-- A type `G₀` is a “group with zero” if it is a monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an “inverse” function, and the inverse of `0` must be `0`.\n\nExamples include division rings and the ordered monoids that are the\ntarget of valuations in general valuation theory. -/\nclass GroupWithZero (G₀ : Type u) extends MonoidWithZero G₀, DivInvMonoid G₀, Nontrivial G₀ where\n  /-- The inverse of `0` in a group with zero is `0`. -/\n  protected inv_zero : (0 : G₀)⁻¹ = 0\n  /-- Every nonzero element of a group with zero is invertible. -/\n  protected mul_inv_cancel (a : G₀) : a ≠ 0 → a * a⁻¹ = 1\n\n"}
{"name":"GroupWithZero.toNontrivial","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"G₀ : Type u\nself : GroupWithZero G₀\n⊢ Nontrivial G₀","decl":"/-- A type `G₀` is a “group with zero” if it is a monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an “inverse” function, and the inverse of `0` must be `0`.\n\nExamples include division rings and the ordered monoids that are the\ntarget of valuations in general valuation theory. -/\nclass GroupWithZero (G₀ : Type u) extends MonoidWithZero G₀, DivInvMonoid G₀, Nontrivial G₀ where\n  /-- The inverse of `0` in a group with zero is `0`. -/\n  protected inv_zero : (0 : G₀)⁻¹ = 0\n  /-- Every nonzero element of a group with zero is invertible. -/\n  protected mul_inv_cancel (a : G₀) : a ≠ 0 → a * a⁻¹ = 1\n\n"}
{"name":"GroupWithZero.inv_zero","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"G₀ : Type u\nself : GroupWithZero G₀\n⊢ Eq (Inv.inv 0) 0","decl":"/-- A type `G₀` is a “group with zero” if it is a monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an “inverse” function, and the inverse of `0` must be `0`.\n\nExamples include division rings and the ordered monoids that are the\ntarget of valuations in general valuation theory. -/\nclass GroupWithZero (G₀ : Type u) extends MonoidWithZero G₀, DivInvMonoid G₀, Nontrivial G₀ where\n  /-- The inverse of `0` in a group with zero is `0`. -/\n  protected inv_zero : (0 : G₀)⁻¹ = 0\n  /-- Every nonzero element of a group with zero is invertible. -/\n  protected mul_inv_cancel (a : G₀) : a ≠ 0 → a * a⁻¹ = 1\n\n"}
{"name":"GroupWithZero.div_eq_mul_inv","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"G₀ : Type u\nself : GroupWithZero G₀\na b : G₀\n⊢ Eq (HDiv.hDiv a b) (HMul.hMul a (Inv.inv b))","decl":"/-- A type `G₀` is a “group with zero” if it is a monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an “inverse” function, and the inverse of `0` must be `0`.\n\nExamples include division rings and the ordered monoids that are the\ntarget of valuations in general valuation theory. -/\nclass GroupWithZero (G₀ : Type u) extends MonoidWithZero G₀, DivInvMonoid G₀, Nontrivial G₀ where\n  /-- The inverse of `0` in a group with zero is `0`. -/\n  protected inv_zero : (0 : G₀)⁻¹ = 0\n  /-- Every nonzero element of a group with zero is invertible. -/\n  protected mul_inv_cancel (a : G₀) : a ≠ 0 → a * a⁻¹ = 1\n\n"}
{"name":"GroupWithZero.mul_inv_cancel","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"G₀ : Type u\nself : GroupWithZero G₀\na : G₀\na✝ : Ne a 0\n⊢ Eq (HMul.hMul a (Inv.inv a)) 1","decl":"/-- A type `G₀` is a “group with zero” if it is a monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an “inverse” function, and the inverse of `0` must be `0`.\n\nExamples include division rings and the ordered monoids that are the\ntarget of valuations in general valuation theory. -/\nclass GroupWithZero (G₀ : Type u) extends MonoidWithZero G₀, DivInvMonoid G₀, Nontrivial G₀ where\n  /-- The inverse of `0` in a group with zero is `0`. -/\n  protected inv_zero : (0 : G₀)⁻¹ = 0\n  /-- Every nonzero element of a group with zero is invertible. -/\n  protected mul_inv_cancel (a : G₀) : a ≠ 0 → a * a⁻¹ = 1\n\n"}
{"name":"inv_zero","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"G₀ : Type u\ninst✝ : GroupWithZero G₀\n⊢ Eq (Inv.inv 0) 0","decl":"@[simp] lemma inv_zero : (0 : G₀)⁻¹ = 0 := GroupWithZero.inv_zero\n\n"}
{"name":"mul_inv_cancel₀","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"G₀ : Type u\ninst✝ : GroupWithZero G₀\na : G₀\nh : Ne a 0\n⊢ Eq (HMul.hMul a (Inv.inv a)) 1","decl":"@[simp] lemma mul_inv_cancel₀ (h : a ≠ 0) : a * a⁻¹ = 1 := GroupWithZero.mul_inv_cancel a h\n\n-- See note [lower instance priority]\n"}
{"name":"GroupWithZero.toMulDivCancelClass","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"G₀ : Type u\ninst✝ : GroupWithZero G₀\n⊢ MulDivCancelClass G₀","decl":"instance (priority := 100) GroupWithZero.toMulDivCancelClass : MulDivCancelClass G₀ where\n  mul_div_cancel a b hb := by rw [div_eq_mul_inv, mul_assoc, mul_inv_cancel₀ hb, mul_one]\n\n"}
{"name":"CommGroupWithZero.zpow_zero'","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"G₀ : Type u_2\nself : CommGroupWithZero G₀\na : G₀\n⊢ Eq (CommGroupWithZero.zpow 0 a) 1","decl":"/-- A type `G₀` is a commutative “group with zero”\nif it is a commutative monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an “inverse” function, and the inverse of `0` must be `0`. -/\nclass CommGroupWithZero (G₀ : Type*) extends CommMonoidWithZero G₀, GroupWithZero G₀\n\n"}
{"name":"CommGroupWithZero.div_eq_mul_inv","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"G₀ : Type u_2\nself : CommGroupWithZero G₀\na b : G₀\n⊢ Eq (HDiv.hDiv a b) (HMul.hMul a (Inv.inv b))","decl":"/-- A type `G₀` is a commutative “group with zero”\nif it is a commutative monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an “inverse” function, and the inverse of `0` must be `0`. -/\nclass CommGroupWithZero (G₀ : Type*) extends CommMonoidWithZero G₀, GroupWithZero G₀\n\n"}
{"name":"CommGroupWithZero.zpow_succ'","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"G₀ : Type u_2\nself : CommGroupWithZero G₀\nn : Nat\na : G₀\n⊢ Eq (CommGroupWithZero.zpow (↑n.succ) a) (HMul.hMul (CommGroupWithZero.zpow (↑n) a) a)","decl":"/-- A type `G₀` is a commutative “group with zero”\nif it is a commutative monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an “inverse” function, and the inverse of `0` must be `0`. -/\nclass CommGroupWithZero (G₀ : Type*) extends CommMonoidWithZero G₀, GroupWithZero G₀\n\n"}
{"name":"CommGroupWithZero.toNontrivial","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"G₀ : Type u_2\nself : CommGroupWithZero G₀\n⊢ Nontrivial G₀","decl":"/-- A type `G₀` is a commutative “group with zero”\nif it is a commutative monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an “inverse” function, and the inverse of `0` must be `0`. -/\nclass CommGroupWithZero (G₀ : Type*) extends CommMonoidWithZero G₀, GroupWithZero G₀\n\n"}
{"name":"CommGroupWithZero.inv_zero","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"G₀ : Type u_2\nself : CommGroupWithZero G₀\n⊢ Eq (Inv.inv 0) 0","decl":"/-- A type `G₀` is a commutative “group with zero”\nif it is a commutative monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an “inverse” function, and the inverse of `0` must be `0`. -/\nclass CommGroupWithZero (G₀ : Type*) extends CommMonoidWithZero G₀, GroupWithZero G₀\n\n"}
{"name":"CommGroupWithZero.zpow_neg'","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"G₀ : Type u_2\nself : CommGroupWithZero G₀\nn : Nat\na : G₀\n⊢ Eq (CommGroupWithZero.zpow (Int.negSucc n) a) (Inv.inv (CommGroupWithZero.zpow (↑n.succ) a))","decl":"/-- A type `G₀` is a commutative “group with zero”\nif it is a commutative monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an “inverse” function, and the inverse of `0` must be `0`. -/\nclass CommGroupWithZero (G₀ : Type*) extends CommMonoidWithZero G₀, GroupWithZero G₀\n\n"}
{"name":"CommGroupWithZero.mul_inv_cancel","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"G₀ : Type u_2\nself : CommGroupWithZero G₀\na : G₀\na✝ : Ne a 0\n⊢ Eq (HMul.hMul a (Inv.inv a)) 1","decl":"/-- A type `G₀` is a commutative “group with zero”\nif it is a commutative monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an “inverse” function, and the inverse of `0` must be `0`. -/\nclass CommGroupWithZero (G₀ : Type*) extends CommMonoidWithZero G₀, GroupWithZero G₀\n\n"}
{"name":"eq_zero_or_one_of_sq_eq_self","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_1\ninst✝ : CancelMonoidWithZero M₀\nx : M₀\nhx : Eq (HPow.hPow x 2) x\n⊢ Or (Eq x 0) (Eq x 1)","decl":"lemma eq_zero_or_one_of_sq_eq_self (hx : x ^ 2 = x) : x = 0 ∨ x = 1 :=\n  or_iff_not_imp_left.mpr (mul_left_injective₀ · <| by simpa [sq] using hx)\n\n"}
{"name":"mul_inv_cancel_right₀","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"G₀ : Type u\ninst✝ : GroupWithZero G₀\nb : G₀\nh : Ne b 0\na : G₀\n⊢ Eq (HMul.hMul (HMul.hMul a b) (Inv.inv b)) a","decl":"@[simp]\ntheorem mul_inv_cancel_right₀ (h : b ≠ 0) (a : G₀) : a * b * b⁻¹ = a :=\n  calc\n    a * b * b⁻¹ = a * (b * b⁻¹) := mul_assoc _ _ _\n    _ = a := by simp [h]\n\n"}
{"name":"mul_inv_cancel_left₀","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"G₀ : Type u\ninst✝ : GroupWithZero G₀\na : G₀\nh : Ne a 0\nb : G₀\n⊢ Eq (HMul.hMul a (HMul.hMul (Inv.inv a) b)) b","decl":"@[simp]\ntheorem mul_inv_cancel_left₀ (h : a ≠ 0) (b : G₀) : a * (a⁻¹ * b) = b :=\n  calc\n    a * (a⁻¹ * b) = a * a⁻¹ * b := (mul_assoc _ _ _).symm\n    _ = b := by simp [h]\n\n"}
{"name":"mul_eq_zero_of_left","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_1\ninst✝ : MulZeroClass M₀\na : M₀\nh : Eq a 0\nb : M₀\n⊢ Eq (HMul.hMul a b) 0","decl":"theorem mul_eq_zero_of_left {a : M₀} (h : a = 0) (b : M₀) : a * b = 0 := h.symm ▸ zero_mul b\n\n"}
{"name":"mul_eq_zero_of_right","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_1\ninst✝ : MulZeroClass M₀\na b : M₀\nh : Eq b 0\n⊢ Eq (HMul.hMul a b) 0","decl":"theorem mul_eq_zero_of_right (a : M₀) {b : M₀} (h : b = 0) : a * b = 0 := h.symm ▸ mul_zero a\n\n"}
{"name":"mul_eq_zero","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_1\ninst✝¹ : MulZeroClass M₀\ninst✝ : NoZeroDivisors M₀\na b : M₀\n⊢ Iff (Eq (HMul.hMul a b) 0) (Or (Eq a 0) (Eq b 0))","decl":"/-- If `α` has no zero divisors, then the product of two elements equals zero iff one of them\nequals zero. -/\n@[simp]\ntheorem mul_eq_zero : a * b = 0 ↔ a = 0 ∨ b = 0 :=\n  ⟨eq_zero_or_eq_zero_of_mul_eq_zero,\n    fun o => o.elim (fun h => mul_eq_zero_of_left h b) (mul_eq_zero_of_right a)⟩\n\n"}
{"name":"zero_eq_mul","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_1\ninst✝¹ : MulZeroClass M₀\ninst✝ : NoZeroDivisors M₀\na b : M₀\n⊢ Iff (Eq 0 (HMul.hMul a b)) (Or (Eq a 0) (Eq b 0))","decl":"/-- If `α` has no zero divisors, then the product of two elements equals zero iff one of them\nequals zero. -/\n@[simp]\ntheorem zero_eq_mul : 0 = a * b ↔ a = 0 ∨ b = 0 := by rw [eq_comm, mul_eq_zero]\n\n"}
{"name":"mul_ne_zero_iff","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_1\ninst✝¹ : MulZeroClass M₀\ninst✝ : NoZeroDivisors M₀\na b : M₀\n⊢ Iff (Ne (HMul.hMul a b) 0) (And (Ne a 0) (Ne b 0))","decl":"/-- If `α` has no zero divisors, then the product of two elements is nonzero iff both of them\nare nonzero. -/\ntheorem mul_ne_zero_iff : a * b ≠ 0 ↔ a ≠ 0 ∧ b ≠ 0 := mul_eq_zero.not.trans not_or\n\n"}
{"name":"mul_eq_zero_comm","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_1\ninst✝¹ : MulZeroClass M₀\ninst✝ : NoZeroDivisors M₀\na b : M₀\n⊢ Iff (Eq (HMul.hMul a b) 0) (Eq (HMul.hMul b a) 0)","decl":"/-- If `α` has no zero divisors, then for elements `a, b : α`, `a * b` equals zero iff so is\n`b * a`. -/\ntheorem mul_eq_zero_comm : a * b = 0 ↔ b * a = 0 :=\n  mul_eq_zero.trans <| or_comm.trans mul_eq_zero.symm\n\n"}
{"name":"mul_ne_zero_comm","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_1\ninst✝¹ : MulZeroClass M₀\ninst✝ : NoZeroDivisors M₀\na b : M₀\n⊢ Iff (Ne (HMul.hMul a b) 0) (Ne (HMul.hMul b a) 0)","decl":"/-- If `α` has no zero divisors, then for elements `a, b : α`, `a * b` is nonzero iff so is\n`b * a`. -/\ntheorem mul_ne_zero_comm : a * b ≠ 0 ↔ b * a ≠ 0 := mul_eq_zero_comm.not\n\n"}
{"name":"mul_self_eq_zero","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_1\ninst✝¹ : MulZeroClass M₀\ninst✝ : NoZeroDivisors M₀\na : M₀\n⊢ Iff (Eq (HMul.hMul a a) 0) (Eq a 0)","decl":"theorem mul_self_eq_zero : a * a = 0 ↔ a = 0 := by simp\n\n"}
{"name":"zero_eq_mul_self","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_1\ninst✝¹ : MulZeroClass M₀\ninst✝ : NoZeroDivisors M₀\na : M₀\n⊢ Iff (Eq 0 (HMul.hMul a a)) (Eq a 0)","decl":"theorem zero_eq_mul_self : 0 = a * a ↔ a = 0 := by simp\n\n"}
{"name":"mul_self_ne_zero","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_1\ninst✝¹ : MulZeroClass M₀\ninst✝ : NoZeroDivisors M₀\na : M₀\n⊢ Iff (Ne (HMul.hMul a a) 0) (Ne a 0)","decl":"theorem mul_self_ne_zero : a * a ≠ 0 ↔ a ≠ 0 := mul_self_eq_zero.not\n\n"}
{"name":"zero_ne_mul_self","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_1\ninst✝¹ : MulZeroClass M₀\ninst✝ : NoZeroDivisors M₀\na : M₀\n⊢ Iff (Ne 0 (HMul.hMul a a)) (Ne a 0)","decl":"theorem zero_ne_mul_self : 0 ≠ a * a ↔ a ≠ 0 := zero_eq_mul_self.not\n\n"}
{"name":"mul_eq_zero_iff_left","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_1\ninst✝¹ : MulZeroClass M₀\ninst✝ : NoZeroDivisors M₀\na b : M₀\nha : Ne a 0\n⊢ Iff (Eq (HMul.hMul a b) 0) (Eq b 0)","decl":"theorem mul_eq_zero_iff_left (ha : a ≠ 0) : a * b = 0 ↔ b = 0 := by simp [ha]\n\n"}
{"name":"mul_eq_zero_iff_right","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_1\ninst✝¹ : MulZeroClass M₀\ninst✝ : NoZeroDivisors M₀\na b : M₀\nhb : Ne b 0\n⊢ Iff (Eq (HMul.hMul a b) 0) (Eq a 0)","decl":"theorem mul_eq_zero_iff_right (hb : b ≠ 0) : a * b = 0 ↔ a = 0 := by simp [hb]\n\n"}
{"name":"mul_ne_zero_iff_left","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_1\ninst✝¹ : MulZeroClass M₀\ninst✝ : NoZeroDivisors M₀\na b : M₀\nha : Ne a 0\n⊢ Iff (Ne (HMul.hMul a b) 0) (Ne b 0)","decl":"theorem mul_ne_zero_iff_left (ha : a ≠ 0) : a * b ≠ 0 ↔ b ≠ 0 := by simp [ha]\n\n"}
{"name":"mul_ne_zero_iff_right","module":"Mathlib.Algebra.GroupWithZero.Defs","initialProofState":"M₀ : Type u_1\ninst✝¹ : MulZeroClass M₀\ninst✝ : NoZeroDivisors M₀\na b : M₀\nhb : Ne b 0\n⊢ Iff (Ne (HMul.hMul a b) 0) (Ne a 0)","decl":"theorem mul_ne_zero_iff_right (hb : b ≠ 0) : a * b ≠ 0 ↔ a ≠ 0 := by simp [hb]\n\n"}
