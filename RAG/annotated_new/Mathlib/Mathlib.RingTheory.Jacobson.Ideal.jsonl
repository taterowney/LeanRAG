{"name":"Ideal.le_jacobson","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst‚úù : Ring R\nI : Ideal R\n‚ä¢ LE.le I I.jacobson","decl":"theorem le_jacobson : I ‚â§ jacobson I := fun _ hx => mem_sInf.mpr fun _ hJ => hJ.left hx\n\n"}
{"name":"Ideal.jacobson_idem","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst‚úù : Ring R\nI : Ideal R\n‚ä¢ Eq I.jacobson.jacobson I.jacobson","decl":"@[simp]\ntheorem jacobson_idem : jacobson (jacobson I) = jacobson I :=\n  le_antisymm (sInf_le_sInf fun _ hJ => ‚ü®sInf_le hJ, hJ.2‚ü©) le_jacobson\n\n"}
{"name":"Ideal.jacobson_top","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst‚úù : Ring R\n‚ä¢ Eq Top.top.jacobson Top.top","decl":"@[simp]\ntheorem jacobson_top : jacobson (‚ä§ : Ideal R) = ‚ä§ :=\n  eq_top_iff.2 le_jacobson\n\n"}
{"name":"Ideal.jacobson_eq_top_iff","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst‚úù : Ring R\nI : Ideal R\n‚ä¢ Iff (Eq I.jacobson Top.top) (Eq I Top.top)","decl":"@[simp]\ntheorem jacobson_eq_top_iff : jacobson I = ‚ä§ ‚Üî I = ‚ä§ :=\n  ‚ü®fun H =>\n    by_contradiction fun hi => let ‚ü®M, hm, him‚ü© := exists_le_maximal I hi\n      lt_top_iff_ne_top.1\n        (lt_of_le_of_lt (show jacobson I ‚â§ M from sInf_le ‚ü®him, hm‚ü©) <|\n          lt_top_iff_ne_top.2 hm.ne_top) H,\n    fun H => eq_top_iff.2 <| le_sInf fun _ ‚ü®hij, _‚ü© => H ‚ñ∏ hij‚ü©\n\n"}
{"name":"Ideal.jacobson_eq_bot","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst‚úù : Ring R\nI : Ideal R\na‚úù : Eq I.jacobson Bot.bot\n‚ä¢ Eq I Bot.bot","decl":"theorem jacobson_eq_bot : jacobson I = ‚ä• ‚Üí I = ‚ä• := fun h => eq_bot_iff.mpr (h ‚ñ∏ le_jacobson)\n\n"}
{"name":"Ideal.jacobson_eq_self_of_isMaximal","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst‚úù : Ring R\nI : Ideal R\nH : I.IsMaximal\n‚ä¢ Eq I.jacobson I","decl":"theorem jacobson_eq_self_of_isMaximal [H : IsMaximal I] : I.jacobson = I :=\n  le_antisymm (sInf_le ‚ü®le_of_eq rfl, H‚ü©) le_jacobson\n\n"}
{"name":"Ideal.jacobson.isMaximal","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst‚úù : Ring R\nI : Ideal R\nH : I.IsMaximal\n‚ä¢ I.jacobson.IsMaximal","decl":"instance (priority := 100) jacobson.isMaximal [H : IsMaximal I] : IsMaximal (jacobson I) :=\n  ‚ü®‚ü®fun htop => H.1.1 (jacobson_eq_top_iff.1 htop), fun _ hJ =>\n    H.1.2 _ (lt_of_le_of_lt le_jacobson hJ)‚ü©‚ü©\n\n"}
{"name":"Ideal.mem_jacobson_iff","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst‚úù : Ring R\nI : Ideal R\nx : R\n‚ä¢ Iff (Membership.mem I.jacobson x) (‚àÄ (y : R), Exists fun z => Membership.mem I (HSub.hSub (HAdd.hAdd (HMul.hMul (HMul.hMul z y) x) z) 1))","decl":"theorem mem_jacobson_iff {x : R} : x ‚àà jacobson I ‚Üî ‚àÄ y, ‚àÉ z, z * y * x + z - 1 ‚àà I :=\n  ‚ü®fun hx y =>\n    by_cases\n      (fun hxy : I ‚äî span {y * x + 1} = ‚ä§ =>\n        let ‚ü®p, hpi, q, hq, hpq‚ü© := Submodule.mem_sup.1 ((eq_top_iff_one _).1 hxy)\n        let ‚ü®r, hr‚ü© := mem_span_singleton'.1 hq\n        ‚ü®r, by\n          rw [mul_assoc, ‚Üê mul_add_one, hr, ‚Üê hpq, ‚Üê neg_sub, add_sub_cancel_right]\n          exact I.neg_mem hpi‚ü©)\n      fun hxy : I ‚äî span {y * x + 1} ‚â† ‚ä§ => let ‚ü®M, hm1, hm2‚ü© := exists_le_maximal _ hxy\n      suffices x ‚àâ M from (this <| mem_sInf.1 hx ‚ü®le_trans le_sup_left hm2, hm1‚ü©).elim\n      fun hxm => hm1.1.1 <| (eq_top_iff_one _).2 <| add_sub_cancel_left (y * x) 1 ‚ñ∏\n        M.sub_mem (le_sup_right.trans hm2 <| subset_span rfl) (M.mul_mem_left _ hxm),\n    fun hx => mem_sInf.2 fun M ‚ü®him, hm‚ü© => by_contradiction fun hxm =>\n      let ‚ü®y, i, hi, df‚ü© := hm.exists_inv hxm\n      let ‚ü®z, hz‚ü© := hx (-y)\n      hm.1.1 <| (eq_top_iff_one _).2 <| sub_sub_cancel (z * -y * x + z) 1 ‚ñ∏\n        M.sub_mem (by\n          rw [mul_assoc, ‚Üê mul_add_one, neg_mul, ‚Üê sub_eq_iff_eq_add.mpr df.symm, neg_sub,\n            sub_add_cancel]\n          exact M.mul_mem_left _ hi) <| him hz‚ü©\n\n"}
{"name":"Ideal.exists_mul_add_sub_mem_of_mem_jacobson","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst‚úù : Ring R\nI : Ideal R\nr : R\nh : Membership.mem I.jacobson r\n‚ä¢ Exists fun s => Membership.mem I (HSub.hSub (HMul.hMul s (HAdd.hAdd r 1)) 1)","decl":"theorem exists_mul_add_sub_mem_of_mem_jacobson {I : Ideal R} (r : R) (h : r ‚àà jacobson I) :\n    ‚àÉ s, s * (r + 1) - 1 ‚àà I := by\n  cases' mem_jacobson_iff.1 h 1 with s hs\n  use s\n  rw [mul_add, mul_one]\n  simpa using hs\n\n"}
{"name":"Ideal.exists_mul_sub_mem_of_sub_one_mem_jacobson","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst‚úù : Ring R\nI : Ideal R\nr : R\nh : Membership.mem I.jacobson (HSub.hSub r 1)\n‚ä¢ Exists fun s => Membership.mem I (HSub.hSub (HMul.hMul s r) 1)","decl":"theorem exists_mul_sub_mem_of_sub_one_mem_jacobson {I : Ideal R} (r : R) (h : r - 1 ‚àà jacobson I) :\n    ‚àÉ s, s * r - 1 ‚àà I := by\n  convert exists_mul_add_sub_mem_of_mem_jacobson _ h\n  simp\n\n"}
{"name":"Ideal.eq_jacobson_iff_sInf_maximal","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst‚úù : Ring R\nI : Ideal R\n‚ä¢ Iff (Eq I.jacobson I) (Exists fun M => And (‚àÄ (J : Ideal R), Membership.mem M J ‚Üí Or J.IsMaximal (Eq J Top.top)) (Eq I (InfSet.sInf M)))","decl":"/-- An ideal equals its Jacobson radical iff it is the intersection of a set of maximal ideals.\nAllowing the set to include ‚ä§ is equivalent, and is included only to simplify some proofs. -/\ntheorem eq_jacobson_iff_sInf_maximal :\n    I.jacobson = I ‚Üî ‚àÉ M : Set (Ideal R), (‚àÄ J ‚àà M, IsMaximal J ‚à® J = ‚ä§) ‚àß I = sInf M := by\n  use fun hI => ‚ü®{ J : Ideal R | I ‚â§ J ‚àß J.IsMaximal }, ‚ü®fun _ hJ => Or.inl hJ.right, hI.symm‚ü©‚ü©\n  rintro ‚ü®M, hM, hInf‚ü©\n  refine le_antisymm (fun x hx => ?_) le_jacobson\n  rw [hInf, mem_sInf]\n  intro I hI\n  cases' hM I hI with is_max is_top\n  ¬∑ exact (mem_sInf.1 hx) ‚ü®le_sInf_iff.1 (le_of_eq hInf) I hI, is_max‚ü©\n  ¬∑ exact is_top.symm ‚ñ∏ Submodule.mem_top\n\n"}
{"name":"Ideal.eq_jacobson_iff_sInf_maximal'","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst‚úù : Ring R\nI : Ideal R\n‚ä¢ Iff (Eq I.jacobson I) (Exists fun M => And (‚àÄ (J : Ideal R), Membership.mem M J ‚Üí ‚àÄ (K : Ideal R), LT.lt J K ‚Üí Eq K Top.top) (Eq I (InfSet.sInf M)))","decl":"theorem eq_jacobson_iff_sInf_maximal' :\n    I.jacobson = I ‚Üî ‚àÉ M : Set (Ideal R), (‚àÄ J ‚àà M, ‚àÄ (K : Ideal R), J < K ‚Üí K = ‚ä§) ‚àß I = sInf M :=\n  eq_jacobson_iff_sInf_maximal.trans\n    ‚ü®fun h =>\n      let ‚ü®M, hM‚ü© := h\n      ‚ü®M,\n        ‚ü®fun J hJ K hK =>\n          Or.recOn (hM.1 J hJ) (fun h => h.1.2 K hK) fun h => eq_top_iff.2 (le_of_lt (h ‚ñ∏ hK)),\n          hM.2‚ü©‚ü©,\n      fun h =>\n      let ‚ü®M, hM‚ü© := h\n      ‚ü®M,\n        ‚ü®fun J hJ =>\n          Or.recOn (Classical.em (J = ‚ä§)) (fun h => Or.inr h) fun h => Or.inl ‚ü®‚ü®h, hM.1 J hJ‚ü©‚ü©,\n          hM.2‚ü©‚ü©‚ü©\n\n"}
{"name":"Ideal.eq_jacobson_iff_not_mem","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst‚úù : Ring R\nI : Ideal R\n‚ä¢ Iff (Eq I.jacobson I) (‚àÄ (x : R), Not (Membership.mem I x) ‚Üí Exists fun M => And (And (LE.le I M) M.IsMaximal) (Not (Membership.mem M x)))","decl":"/-- An ideal `I` equals its Jacobson radical if and only if every element outside `I`\nalso lies outside of a maximal ideal containing `I`. -/\ntheorem eq_jacobson_iff_not_mem :\n    I.jacobson = I ‚Üî ‚àÄ x ‚àâ I, ‚àÉ M : Ideal R, (I ‚â§ M ‚àß M.IsMaximal) ‚àß x ‚àâ M := by\n  constructor\n  ¬∑ intro h x hx\n    rw [‚Üê h, Ideal.jacobson, mem_sInf] at hx\n    push_neg at hx\n    exact hx\n  ¬∑ refine fun h => le_antisymm (fun x hx => ?_) le_jacobson\n    contrapose hx\n    rw [Ideal.jacobson, mem_sInf]\n    push_neg\n    exact h x hx\n\n"}
{"name":"Ideal.map_jacobson_of_surjective","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\nS : Type v\ninst‚úù¬π : Ring R\ninst‚úù : Ring S\nI : Ideal R\nf : RingHom R S\nhf : Function.Surjective ‚áëf\na‚úù : LE.le (RingHom.ker f) I\n‚ä¢ Eq (Ideal.map f I.jacobson) (Ideal.map f I).jacobson","decl":"theorem map_jacobson_of_surjective {f : R ‚Üí+* S} (hf : Function.Surjective f) :\n    RingHom.ker f ‚â§ I ‚Üí map f I.jacobson = (map f I).jacobson := by\n  intro h\n  unfold Ideal.jacobson\n  -- Porting note: dot notation for `RingHom.ker` does not work\n  have : ‚àÄ J ‚àà { J : Ideal R | I ‚â§ J ‚àß J.IsMaximal }, RingHom.ker f ‚â§ J :=\n    fun J hJ => le_trans h hJ.left\n  refine Trans.trans (map_sInf hf this) (le_antisymm ?_ ?_)\n  ¬∑ refine\n      sInf_le_sInf fun J hJ =>\n        ‚ü®comap f J, ‚ü®‚ü®le_comap_of_map_le hJ.1, ?_‚ü©, map_comap_of_surjective f hf J‚ü©‚ü©\n    haveI : J.IsMaximal := hJ.right\n    exact comap_isMaximal_of_surjective f hf\n  ¬∑ refine sInf_le_sInf_of_subset_insert_top fun j hj => hj.recOn fun J hJ => ?_\n    rw [‚Üê hJ.2]\n    cases' map_eq_top_or_isMaximal_of_surjective f hf hJ.left.right with htop hmax\n    ¬∑ exact htop.symm ‚ñ∏ Set.mem_insert ‚ä§ _\n    ¬∑ exact Set.mem_insert_of_mem ‚ä§ ‚ü®map_mono hJ.1.1, hmax‚ü©\n\n"}
{"name":"Ideal.map_jacobson_of_bijective","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\nS : Type v\ninst‚úù¬π : Ring R\ninst‚úù : Ring S\nI : Ideal R\nf : RingHom R S\nhf : Function.Bijective ‚áëf\n‚ä¢ Eq (Ideal.map f I.jacobson) (Ideal.map f I).jacobson","decl":"theorem map_jacobson_of_bijective {f : R ‚Üí+* S} (hf : Function.Bijective f) :\n    map f I.jacobson = (map f I).jacobson :=\n  map_jacobson_of_surjective hf.right\n    (le_trans (le_of_eq (f.injective_iff_ker_eq_bot.1 hf.left)) bot_le)\n\n"}
{"name":"Ideal.comap_jacobson","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\nS : Type v\ninst‚úù¬π : Ring R\ninst‚úù : Ring S\nf : RingHom R S\nK : Ideal S\n‚ä¢ Eq (Ideal.comap f K.jacobson) (InfSet.sInf (Set.image (Ideal.comap f) (setOf fun J => And (LE.le K J) J.IsMaximal)))","decl":"theorem comap_jacobson {f : R ‚Üí+* S} {K : Ideal S} :\n    comap f K.jacobson = sInf (comap f '' { J : Ideal S | K ‚â§ J ‚àß J.IsMaximal }) :=\n  Trans.trans (comap_sInf' f _) sInf_eq_iInf.symm\n\n"}
{"name":"Ideal.comap_jacobson_of_surjective","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\nS : Type v\ninst‚úù¬π : Ring R\ninst‚úù : Ring S\nf : RingHom R S\nhf : Function.Surjective ‚áëf\nK : Ideal S\n‚ä¢ Eq (Ideal.comap f K.jacobson) (Ideal.comap f K).jacobson","decl":"theorem comap_jacobson_of_surjective {f : R ‚Üí+* S} (hf : Function.Surjective f) {K : Ideal S} :\n    comap f K.jacobson = (comap f K).jacobson := by\n  unfold Ideal.jacobson\n  refine le_antisymm ?_ ?_\n  ¬∑ rw [‚Üê top_inf_eq (sInf _), ‚Üê sInf_insert, comap_sInf', sInf_eq_iInf]\n    refine iInf_le_iInf_of_subset fun J hJ => ?_\n    have : comap f (map f J) = J :=\n      Trans.trans (comap_map_of_surjective f hf J)\n        (le_antisymm (sup_le_iff.2 ‚ü®le_of_eq rfl, le_trans (comap_mono bot_le) hJ.left‚ü©)\n          le_sup_left)\n    cases' map_eq_top_or_isMaximal_of_surjective _ hf hJ.right with htop hmax\n    ¬∑ exact ‚ü®‚ä§, Set.mem_insert ‚ä§ _, htop ‚ñ∏ this‚ü©\n    ¬∑ exact ‚ü®map f J, Set.mem_insert_of_mem _ ‚ü®le_map_of_comap_le_of_surjective f hf hJ.1, hmax‚ü©,\n        this‚ü©\n  ¬∑ simp_rw [comap_sInf, le_iInf_iff]\n    intros J hJ\n    haveI : J.IsMaximal := hJ.right\n    exact sInf_le ‚ü®comap_mono hJ.left, comap_isMaximal_of_surjective _ hf‚ü©\n\n"}
{"name":"Ideal.jacobson_mono","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst‚úù : Ring R\nI J : Ideal R\na‚úù : LE.le I J\n‚ä¢ LE.le I.jacobson J.jacobson","decl":"@[mono]\ntheorem jacobson_mono {I J : Ideal R} : I ‚â§ J ‚Üí I.jacobson ‚â§ J.jacobson := by\n  intro h x hx\n  erw [mem_sInf] at hx ‚ä¢\n  exact fun K ‚ü®hK, hK_max‚ü© => hx ‚ü®Trans.trans h hK, hK_max‚ü©\n\n"}
{"name":"Ideal.jacobson_mul_mem_right","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst‚úù : Ring R\nI : Ideal R\nmul_mem_right : ‚àÄ {x y : R}, Membership.mem I x ‚Üí Membership.mem I (HMul.hMul x y)\nx y : R\na‚úù : Membership.mem I.jacobson x\n‚ä¢ Membership.mem I.jacobson (HMul.hMul x y)","decl":"/-- The Jacobson radical of a two-sided ideal is two-sided.\n\nIt is preferable to use `TwoSidedIdeal.jacobson` instead of this lemma. -/\ntheorem jacobson_mul_mem_right {I : Ideal R}\n    (mul_mem_right : ‚àÄ {x y}, x ‚àà I ‚Üí x * y ‚àà I) :\n    ‚àÄ {x y}, x ‚àà I.jacobson ‚Üí x * y ‚àà I.jacobson := by\n  -- Proof generalized from\n  -- https://ysharifi.wordpress.com/2022/08/16/the-jacobson-radical-definition-and-basic-results/\n  intro x r xJ\n  apply mem_sInf.mpr\n  intro ùî™ ùî™_mem\n  by_cases rùî™ : r ‚àà ùî™\n  ¬∑ apply ùî™.smul_mem _ rùî™\n  -- ùî™‚ÇÄ := { a : R | a*r ‚àà ùî™ }\n  let ùî™‚ÇÄ : Ideal R := Submodule.comap (DistribMulAction.toLinearMap R (S := R·µê·µí·µñ) R (.op r)) ùî™\n  suffices x ‚àà ùî™‚ÇÄ by simpa [ùî™‚ÇÄ] using this\n  have Iùî™‚ÇÄ : I ‚â§ ùî™‚ÇÄ := fun i iI =>\n    ùî™_mem.left (mul_mem_right iI)\n  have ùî™‚ÇÄ_maximal : IsMaximal ùî™‚ÇÄ := by\n    refine isMaximal_iff.mpr ‚ü®\n      fun h => rùî™ (by simpa [ùî™‚ÇÄ] using h),\n      fun J b ùî™‚ÇÄJ bùî™‚ÇÄ bJ => ?_‚ü©\n    let K : Ideal R := Ideal.span {b*r} ‚äî ùî™\n    have ‚ü®s, y, yùî™, sbyr‚ü© :=\n      mem_span_singleton_sup.mp <|\n        mul_mem_left _ r <|\n          (isMaximal_iff.mp ùî™_mem.right).right K (b*r)\n          le_sup_right bùî™‚ÇÄ\n          (mem_sup_left <| mem_span_singleton_self _)\n    have : 1 - s*b ‚àà ùî™‚ÇÄ := by\n      rw [mul_one, add_comm, ‚Üê eq_sub_iff_add_eq] at sbyr\n      rw [sbyr, ‚Üê mul_assoc] at yùî™\n      simp [ùî™‚ÇÄ, sub_mul, yùî™]\n    have : 1 - s*b + s*b ‚àà J := by\n      apply add_mem (ùî™‚ÇÄJ this) (J.mul_mem_left _ bJ)\n    simpa using this\n  exact mem_sInf.mp xJ ‚ü®Iùî™‚ÇÄ, ùî™‚ÇÄ_maximal‚ü©\n\n"}
{"name":"Ideal.radical_le_jacobson","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst‚úù : CommRing R\nI : Ideal R\n‚ä¢ LE.le I.radical I.jacobson","decl":"theorem radical_le_jacobson : radical I ‚â§ jacobson I :=\n  le_sInf fun _ hJ => (radical_eq_sInf I).symm ‚ñ∏ sInf_le ‚ü®hJ.left, IsMaximal.isPrime hJ.right‚ü©\n\n"}
{"name":"Ideal.isRadical_of_eq_jacobson","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst‚úù : CommRing R\nI : Ideal R\nh : Eq I.jacobson I\n‚ä¢ I.IsRadical","decl":"theorem isRadical_of_eq_jacobson (h : jacobson I = I) : I.IsRadical :=\n  radical_le_jacobson.trans h.le\n\n"}
{"name":"Ideal.isRadical_jacobson","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst‚úù : CommRing R\nI : Ideal R\n‚ä¢ I.jacobson.IsRadical","decl":"lemma isRadical_jacobson (I : Ideal R) : I.jacobson.IsRadical :=\n  isRadical_of_eq_jacobson jacobson_idem\n\n"}
{"name":"Ideal.isUnit_of_sub_one_mem_jacobson_bot","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst‚úù : CommRing R\nr : R\nh : Membership.mem Bot.bot.jacobson (HSub.hSub r 1)\n‚ä¢ IsUnit r","decl":"theorem isUnit_of_sub_one_mem_jacobson_bot (r : R) (h : r - 1 ‚àà jacobson (‚ä• : Ideal R)) :\n    IsUnit r := by\n  cases' exists_mul_sub_mem_of_sub_one_mem_jacobson r h with s hs\n  rw [mem_bot, sub_eq_zero, mul_comm] at hs\n  exact isUnit_of_mul_eq_one _ _ hs\n\n"}
{"name":"Ideal.mem_jacobson_bot","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst‚úù : CommRing R\nx : R\n‚ä¢ Iff (Membership.mem Bot.bot.jacobson x) (‚àÄ (y : R), IsUnit (HAdd.hAdd (HMul.hMul x y) 1))","decl":"theorem mem_jacobson_bot {x : R} : x ‚àà jacobson (‚ä• : Ideal R) ‚Üî ‚àÄ y, IsUnit (x * y + 1) :=\n  ‚ü®fun hx y =>\n    let ‚ü®z, hz‚ü© := (mem_jacobson_iff.1 hx) y\n    isUnit_iff_exists_inv.2\n      ‚ü®z, by rwa [add_mul, one_mul, ‚Üê sub_eq_zero, mul_right_comm, mul_comm _ z, mul_right_comm]‚ü©,\n    fun h =>\n    mem_jacobson_iff.mpr fun y =>\n      let ‚ü®b, hb‚ü© := isUnit_iff_exists_inv.1 (h y)\n      ‚ü®b, (Submodule.mem_bot R).2 (hb ‚ñ∏ by ring)‚ü©‚ü©\n\n"}
{"name":"Ideal.jacobson_eq_iff_jacobson_quotient_eq_bot","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst‚úù : CommRing R\nI : Ideal R\n‚ä¢ Iff (Eq I.jacobson I) (Eq Bot.bot.jacobson Bot.bot)","decl":"/-- An ideal `I` of `R` is equal to its Jacobson radical if and only if\nthe Jacobson radical of the quotient ring `R/I` is the zero ideal -/\n-- Porting note: changed `Quotient.mk'` to ``\ntheorem jacobson_eq_iff_jacobson_quotient_eq_bot :\n    I.jacobson = I ‚Üî jacobson (‚ä• : Ideal (R ‚ß∏ I)) = ‚ä• := by\n  have hf : Function.Surjective (Ideal.Quotient.mk I) := Submodule.Quotient.mk_surjective I\n  constructor\n  ¬∑ intro h\n    replace h := congr_arg (Ideal.map (Ideal.Quotient.mk I)) h\n    rw [map_jacobson_of_surjective hf (le_of_eq mk_ker)] at h\n    simpa using h\n  ¬∑ intro h\n    replace h := congr_arg (comap (Ideal.Quotient.mk I)) h\n    rw [comap_jacobson_of_surjective hf, ‚Üê RingHom.ker_eq_comap_bot (Ideal.Quotient.mk I)] at h\n    simpa using h\n\n"}
{"name":"Ideal.radical_eq_jacobson_iff_radical_quotient_eq_jacobson_bot","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst‚úù : CommRing R\nI : Ideal R\n‚ä¢ Iff (Eq I.radical I.jacobson) (Eq Bot.bot.radical Bot.bot.jacobson)","decl":"/-- The standard radical and Jacobson radical of an ideal `I` of `R` are equal if and only if\nthe nilradical and Jacobson radical of the quotient ring `R/I` coincide -/\n-- Porting note: changed `Quotient.mk'` to ``\ntheorem radical_eq_jacobson_iff_radical_quotient_eq_jacobson_bot :\n    I.radical = I.jacobson ‚Üî radical (‚ä• : Ideal (R ‚ß∏ I)) = jacobson ‚ä• := by\n  have hf : Function.Surjective (Ideal.Quotient.mk I) := Submodule.Quotient.mk_surjective I\n  constructor\n  ¬∑ intro h\n    have := congr_arg (map (Ideal.Quotient.mk I)) h\n    rw [map_radical_of_surjective hf (le_of_eq mk_ker),\n      map_jacobson_of_surjective hf (le_of_eq mk_ker)] at this\n    simpa using this\n  ¬∑ intro h\n    have := congr_arg (comap (Ideal.Quotient.mk I)) h\n    rw [comap_radical, comap_jacobson_of_surjective hf,\n      ‚Üê RingHom.ker_eq_comap_bot (Ideal.Quotient.mk I)] at this\n    simpa using this\n\n"}
{"name":"Ideal.jacobson_radical_eq_jacobson","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst‚úù : CommRing R\nI : Ideal R\n‚ä¢ Eq I.radical.jacobson I.jacobson","decl":"theorem jacobson_radical_eq_jacobson : I.radical.jacobson = I.jacobson :=\n  le_antisymm\n    (le_trans (le_of_eq (congr_arg jacobson (radical_eq_sInf I)))\n      (sInf_le_sInf fun _ hJ => ‚ü®sInf_le ‚ü®hJ.1, hJ.2.isPrime‚ü©, hJ.2‚ü©))\n    (jacobson_mono le_radical)\n\n"}
{"name":"Ideal.IsLocal.out","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst‚úù : CommRing R\nI : Ideal R\nself : I.IsLocal\n‚ä¢ I.jacobson.IsMaximal","decl":"/-- An ideal `I` is local iff its Jacobson radical is maximal. -/\nclass IsLocal (I : Ideal R) : Prop where\n  /-- A ring `R` is local if and only if its jacobson radical is maximal -/\n  out : IsMaximal (jacobson I)\n\n"}
{"name":"Ideal.isLocal_iff","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst‚úù : CommRing R\nI : Ideal R\n‚ä¢ Iff I.IsLocal I.jacobson.IsMaximal","decl":"theorem isLocal_iff {I : Ideal R} : IsLocal I ‚Üî IsMaximal (jacobson I) :=\n  ‚ü®fun h => h.1, fun h => ‚ü®h‚ü©‚ü©\n\n"}
{"name":"Ideal.isLocal_of_isMaximal_radical","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst‚úù : CommRing R\nI : Ideal R\nhi : I.radical.IsMaximal\n‚ä¢ I.IsLocal","decl":"theorem isLocal_of_isMaximal_radical {I : Ideal R} (hi : IsMaximal (radical I)) : IsLocal I :=\n  ‚ü®have : radical I = jacobson I :=\n      le_antisymm (le_sInf fun _ ‚ü®him, hm‚ü© => hm.isPrime.radical_le_iff.2 him)\n        (sInf_le ‚ü®le_radical, hi‚ü©)\n    show IsMaximal (jacobson I) from this ‚ñ∏ hi‚ü©\n\n"}
{"name":"Ideal.IsLocal.le_jacobson","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst‚úù : CommRing R\nI J : Ideal R\nhi : I.IsLocal\nhij : LE.le I J\nhj : Ne J Top.top\n‚ä¢ LE.le J I.jacobson","decl":"theorem IsLocal.le_jacobson {I J : Ideal R} (hi : IsLocal I) (hij : I ‚â§ J) (hj : J ‚â† ‚ä§) :\n    J ‚â§ jacobson I :=\n  let ‚ü®_, hm, hjm‚ü© := exists_le_maximal J hj\n  le_trans hjm <| le_of_eq <| Eq.symm <| hi.1.eq_of_le hm.1.1 <| sInf_le ‚ü®le_trans hij hjm, hm‚ü©\n\n"}
{"name":"Ideal.IsLocal.mem_jacobson_or_exists_inv","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst‚úù : CommRing R\nI : Ideal R\nhi : I.IsLocal\nx : R\n‚ä¢ Or (Membership.mem I.jacobson x) (Exists fun y => Membership.mem I (HSub.hSub (HMul.hMul y x) 1))","decl":"theorem IsLocal.mem_jacobson_or_exists_inv {I : Ideal R} (hi : IsLocal I) (x : R) :\n    x ‚àà jacobson I ‚à® ‚àÉ y, y * x - 1 ‚àà I :=\n  by_cases\n    (fun h : I ‚äî span {x} = ‚ä§ =>\n      let ‚ü®p, hpi, q, hq, hpq‚ü© := Submodule.mem_sup.1 ((eq_top_iff_one _).1 h)\n      let ‚ü®r, hr‚ü© := mem_span_singleton.1 hq\n      Or.inr ‚ü®r, by\n        rw [‚Üê hpq, mul_comm, ‚Üê hr, ‚Üê neg_sub, add_sub_cancel_right]; exact I.neg_mem hpi‚ü©)\n    fun h : I ‚äî span {x} ‚â† ‚ä§ =>\n    Or.inl <|\n      le_trans le_sup_right (hi.le_jacobson le_sup_left h) <| mem_span_singleton.2 <| dvd_refl x\n\n"}
{"name":"Ideal.isPrimary_of_isMaximal_radical","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst‚úù : CommRing R\nI : Ideal R\nhi : I.radical.IsMaximal\n‚ä¢ I.IsPrimary","decl":"theorem isPrimary_of_isMaximal_radical [CommRing R] {I : Ideal R} (hi : IsMaximal (radical I)) :\n    I.IsPrimary :=\n  have : radical I = jacobson I :=\n    le_antisymm (le_sInf fun _ ‚ü®him, hm‚ü© => hm.isPrime.radical_le_iff.2 him)\n      (sInf_le ‚ü®le_radical, hi‚ü©)\n  isPrimary_iff.mpr\n  ‚ü®ne_top_of_lt <| lt_of_le_of_lt le_radical (lt_top_iff_ne_top.2 hi.1.1), fun {x y} hxy =>\n    ((isLocal_of_isMaximal_radical hi).mem_jacobson_or_exists_inv y).symm.imp\n      (fun ‚ü®z, hz‚ü© => by\n        rw [‚Üê mul_one x, ‚Üê sub_sub_cancel (z * y) 1, mul_sub, mul_left_comm]\n        exact I.sub_mem (I.mul_mem_left _ hxy) (I.mul_mem_left _ hz))\n      (this ‚ñ∏ id)‚ü©\n\n"}
{"name":"TwoSidedIdeal.asIdeal_jacobson","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst‚úù : Ring R\nI : TwoSidedIdeal R\n‚ä¢ Eq (TwoSidedIdeal.asIdeal I.jacobson) (TwoSidedIdeal.asIdeal I).jacobson","decl":"lemma asIdeal_jacobson (I : TwoSidedIdeal R) : asIdeal I.jacobson = (asIdeal I).jacobson := by\n  ext; simp [jacobson]\n\n"}
{"name":"TwoSidedIdeal.mem_jacobson_iff","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst‚úù : Ring R\nx : R\nI : TwoSidedIdeal R\n‚ä¢ Iff (Membership.mem I.jacobson x) (‚àÄ (y : R), Exists fun z => Membership.mem I (HSub.hSub (HAdd.hAdd (HMul.hMul (HMul.hMul z y) x) z) 1))","decl":"theorem mem_jacobson_iff {x : R} {I : TwoSidedIdeal R} :\n    x ‚àà jacobson I ‚Üî ‚àÄ y, ‚àÉ z, z * y * x + z - 1 ‚àà I := by\n  simp [jacobson, Ideal.mem_jacobson_iff]\n\n"}
