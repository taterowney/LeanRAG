{"name":"Ideal.le_jacobson","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst✝ : Ring R\nI : Ideal R\n⊢ LE.le I I.jacobson","decl":"theorem le_jacobson : I ≤ jacobson I := fun _ hx => mem_sInf.mpr fun _ hJ => hJ.left hx\n\n"}
{"name":"Ideal.jacobson_idem","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst✝ : Ring R\nI : Ideal R\n⊢ Eq I.jacobson.jacobson I.jacobson","decl":"@[simp]\ntheorem jacobson_idem : jacobson (jacobson I) = jacobson I :=\n  le_antisymm (sInf_le_sInf fun _ hJ => ⟨sInf_le hJ, hJ.2⟩) le_jacobson\n\n"}
{"name":"Ideal.jacobson_top","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ Eq Top.top.jacobson Top.top","decl":"@[simp]\ntheorem jacobson_top : jacobson (⊤ : Ideal R) = ⊤ :=\n  eq_top_iff.2 le_jacobson\n\n"}
{"name":"Ideal.jacobson_eq_top_iff","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst✝ : Ring R\nI : Ideal R\n⊢ Iff (Eq I.jacobson Top.top) (Eq I Top.top)","decl":"@[simp]\ntheorem jacobson_eq_top_iff : jacobson I = ⊤ ↔ I = ⊤ :=\n  ⟨fun H =>\n    by_contradiction fun hi => let ⟨M, hm, him⟩ := exists_le_maximal I hi\n      lt_top_iff_ne_top.1\n        (lt_of_le_of_lt (show jacobson I ≤ M from sInf_le ⟨him, hm⟩) <|\n          lt_top_iff_ne_top.2 hm.ne_top) H,\n    fun H => eq_top_iff.2 <| le_sInf fun _ ⟨hij, _⟩ => H ▸ hij⟩\n\n"}
{"name":"Ideal.jacobson_eq_bot","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst✝ : Ring R\nI : Ideal R\na✝ : Eq I.jacobson Bot.bot\n⊢ Eq I Bot.bot","decl":"theorem jacobson_eq_bot : jacobson I = ⊥ → I = ⊥ := fun h => eq_bot_iff.mpr (h ▸ le_jacobson)\n\n"}
{"name":"Ideal.jacobson_eq_self_of_isMaximal","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst✝ : Ring R\nI : Ideal R\nH : I.IsMaximal\n⊢ Eq I.jacobson I","decl":"theorem jacobson_eq_self_of_isMaximal [H : IsMaximal I] : I.jacobson = I :=\n  le_antisymm (sInf_le ⟨le_of_eq rfl, H⟩) le_jacobson\n\n"}
{"name":"Ideal.jacobson.isMaximal","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst✝ : Ring R\nI : Ideal R\nH : I.IsMaximal\n⊢ I.jacobson.IsMaximal","decl":"instance (priority := 100) jacobson.isMaximal [H : IsMaximal I] : IsMaximal (jacobson I) :=\n  ⟨⟨fun htop => H.1.1 (jacobson_eq_top_iff.1 htop), fun _ hJ =>\n    H.1.2 _ (lt_of_le_of_lt le_jacobson hJ)⟩⟩\n\n"}
{"name":"Ideal.mem_jacobson_iff","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst✝ : Ring R\nI : Ideal R\nx : R\n⊢ Iff (Membership.mem I.jacobson x) (∀ (y : R), Exists fun z => Membership.mem I (HSub.hSub (HAdd.hAdd (HMul.hMul (HMul.hMul z y) x) z) 1))","decl":"theorem mem_jacobson_iff {x : R} : x ∈ jacobson I ↔ ∀ y, ∃ z, z * y * x + z - 1 ∈ I :=\n  ⟨fun hx y =>\n    by_cases\n      (fun hxy : I ⊔ span {y * x + 1} = ⊤ =>\n        let ⟨p, hpi, q, hq, hpq⟩ := Submodule.mem_sup.1 ((eq_top_iff_one _).1 hxy)\n        let ⟨r, hr⟩ := mem_span_singleton'.1 hq\n        ⟨r, by\n          rw [mul_assoc, ← mul_add_one, hr, ← hpq, ← neg_sub, add_sub_cancel_right]\n          exact I.neg_mem hpi⟩)\n      fun hxy : I ⊔ span {y * x + 1} ≠ ⊤ => let ⟨M, hm1, hm2⟩ := exists_le_maximal _ hxy\n      suffices x ∉ M from (this <| mem_sInf.1 hx ⟨le_trans le_sup_left hm2, hm1⟩).elim\n      fun hxm => hm1.1.1 <| (eq_top_iff_one _).2 <| add_sub_cancel_left (y * x) 1 ▸\n        M.sub_mem (le_sup_right.trans hm2 <| subset_span rfl) (M.mul_mem_left _ hxm),\n    fun hx => mem_sInf.2 fun M ⟨him, hm⟩ => by_contradiction fun hxm =>\n      let ⟨y, i, hi, df⟩ := hm.exists_inv hxm\n      let ⟨z, hz⟩ := hx (-y)\n      hm.1.1 <| (eq_top_iff_one _).2 <| sub_sub_cancel (z * -y * x + z) 1 ▸\n        M.sub_mem (by\n          rw [mul_assoc, ← mul_add_one, neg_mul, ← sub_eq_iff_eq_add.mpr df.symm, neg_sub,\n            sub_add_cancel]\n          exact M.mul_mem_left _ hi) <| him hz⟩\n\n"}
{"name":"Ideal.exists_mul_add_sub_mem_of_mem_jacobson","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst✝ : Ring R\nI : Ideal R\nr : R\nh : Membership.mem I.jacobson r\n⊢ Exists fun s => Membership.mem I (HSub.hSub (HMul.hMul s (HAdd.hAdd r 1)) 1)","decl":"theorem exists_mul_add_sub_mem_of_mem_jacobson {I : Ideal R} (r : R) (h : r ∈ jacobson I) :\n    ∃ s, s * (r + 1) - 1 ∈ I := by\n  cases' mem_jacobson_iff.1 h 1 with s hs\n  use s\n  rw [mul_add, mul_one]\n  simpa using hs\n\n"}
{"name":"Ideal.exists_mul_sub_mem_of_sub_one_mem_jacobson","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst✝ : Ring R\nI : Ideal R\nr : R\nh : Membership.mem I.jacobson (HSub.hSub r 1)\n⊢ Exists fun s => Membership.mem I (HSub.hSub (HMul.hMul s r) 1)","decl":"theorem exists_mul_sub_mem_of_sub_one_mem_jacobson {I : Ideal R} (r : R) (h : r - 1 ∈ jacobson I) :\n    ∃ s, s * r - 1 ∈ I := by\n  convert exists_mul_add_sub_mem_of_mem_jacobson _ h\n  simp\n\n"}
{"name":"Ideal.eq_jacobson_iff_sInf_maximal","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst✝ : Ring R\nI : Ideal R\n⊢ Iff (Eq I.jacobson I) (Exists fun M => And (∀ (J : Ideal R), Membership.mem M J → Or J.IsMaximal (Eq J Top.top)) (Eq I (InfSet.sInf M)))","decl":"/-- An ideal equals its Jacobson radical iff it is the intersection of a set of maximal ideals.\nAllowing the set to include ⊤ is equivalent, and is included only to simplify some proofs. -/\ntheorem eq_jacobson_iff_sInf_maximal :\n    I.jacobson = I ↔ ∃ M : Set (Ideal R), (∀ J ∈ M, IsMaximal J ∨ J = ⊤) ∧ I = sInf M := by\n  use fun hI => ⟨{ J : Ideal R | I ≤ J ∧ J.IsMaximal }, ⟨fun _ hJ => Or.inl hJ.right, hI.symm⟩⟩\n  rintro ⟨M, hM, hInf⟩\n  refine le_antisymm (fun x hx => ?_) le_jacobson\n  rw [hInf, mem_sInf]\n  intro I hI\n  cases' hM I hI with is_max is_top\n  · exact (mem_sInf.1 hx) ⟨le_sInf_iff.1 (le_of_eq hInf) I hI, is_max⟩\n  · exact is_top.symm ▸ Submodule.mem_top\n\n"}
{"name":"Ideal.eq_jacobson_iff_sInf_maximal'","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst✝ : Ring R\nI : Ideal R\n⊢ Iff (Eq I.jacobson I) (Exists fun M => And (∀ (J : Ideal R), Membership.mem M J → ∀ (K : Ideal R), LT.lt J K → Eq K Top.top) (Eq I (InfSet.sInf M)))","decl":"theorem eq_jacobson_iff_sInf_maximal' :\n    I.jacobson = I ↔ ∃ M : Set (Ideal R), (∀ J ∈ M, ∀ (K : Ideal R), J < K → K = ⊤) ∧ I = sInf M :=\n  eq_jacobson_iff_sInf_maximal.trans\n    ⟨fun h =>\n      let ⟨M, hM⟩ := h\n      ⟨M,\n        ⟨fun J hJ K hK =>\n          Or.recOn (hM.1 J hJ) (fun h => h.1.2 K hK) fun h => eq_top_iff.2 (le_of_lt (h ▸ hK)),\n          hM.2⟩⟩,\n      fun h =>\n      let ⟨M, hM⟩ := h\n      ⟨M,\n        ⟨fun J hJ =>\n          Or.recOn (Classical.em (J = ⊤)) (fun h => Or.inr h) fun h => Or.inl ⟨⟨h, hM.1 J hJ⟩⟩,\n          hM.2⟩⟩⟩\n\n"}
{"name":"Ideal.eq_jacobson_iff_not_mem","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst✝ : Ring R\nI : Ideal R\n⊢ Iff (Eq I.jacobson I) (∀ (x : R), Not (Membership.mem I x) → Exists fun M => And (And (LE.le I M) M.IsMaximal) (Not (Membership.mem M x)))","decl":"/-- An ideal `I` equals its Jacobson radical if and only if every element outside `I`\nalso lies outside of a maximal ideal containing `I`. -/\ntheorem eq_jacobson_iff_not_mem :\n    I.jacobson = I ↔ ∀ x ∉ I, ∃ M : Ideal R, (I ≤ M ∧ M.IsMaximal) ∧ x ∉ M := by\n  constructor\n  · intro h x hx\n    rw [← h, Ideal.jacobson, mem_sInf] at hx\n    push_neg at hx\n    exact hx\n  · refine fun h => le_antisymm (fun x hx => ?_) le_jacobson\n    contrapose hx\n    rw [Ideal.jacobson, mem_sInf]\n    push_neg\n    exact h x hx\n\n"}
{"name":"Ideal.map_jacobson_of_surjective","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nI : Ideal R\nf : RingHom R S\nhf : Function.Surjective ⇑f\na✝ : LE.le (RingHom.ker f) I\n⊢ Eq (Ideal.map f I.jacobson) (Ideal.map f I).jacobson","decl":"theorem map_jacobson_of_surjective {f : R →+* S} (hf : Function.Surjective f) :\n    RingHom.ker f ≤ I → map f I.jacobson = (map f I).jacobson := by\n  intro h\n  unfold Ideal.jacobson\n  -- Porting note: dot notation for `RingHom.ker` does not work\n  have : ∀ J ∈ { J : Ideal R | I ≤ J ∧ J.IsMaximal }, RingHom.ker f ≤ J :=\n    fun J hJ => le_trans h hJ.left\n  refine Trans.trans (map_sInf hf this) (le_antisymm ?_ ?_)\n  · refine\n      sInf_le_sInf fun J hJ =>\n        ⟨comap f J, ⟨⟨le_comap_of_map_le hJ.1, ?_⟩, map_comap_of_surjective f hf J⟩⟩\n    haveI : J.IsMaximal := hJ.right\n    exact comap_isMaximal_of_surjective f hf\n  · refine sInf_le_sInf_of_subset_insert_top fun j hj => hj.recOn fun J hJ => ?_\n    rw [← hJ.2]\n    cases' map_eq_top_or_isMaximal_of_surjective f hf hJ.left.right with htop hmax\n    · exact htop.symm ▸ Set.mem_insert ⊤ _\n    · exact Set.mem_insert_of_mem ⊤ ⟨map_mono hJ.1.1, hmax⟩\n\n"}
{"name":"Ideal.map_jacobson_of_bijective","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nI : Ideal R\nf : RingHom R S\nhf : Function.Bijective ⇑f\n⊢ Eq (Ideal.map f I.jacobson) (Ideal.map f I).jacobson","decl":"theorem map_jacobson_of_bijective {f : R →+* S} (hf : Function.Bijective f) :\n    map f I.jacobson = (map f I).jacobson :=\n  map_jacobson_of_surjective hf.right\n    (le_trans (le_of_eq (f.injective_iff_ker_eq_bot.1 hf.left)) bot_le)\n\n"}
{"name":"Ideal.comap_jacobson","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\nK : Ideal S\n⊢ Eq (Ideal.comap f K.jacobson) (InfSet.sInf (Set.image (Ideal.comap f) (setOf fun J => And (LE.le K J) J.IsMaximal)))","decl":"theorem comap_jacobson {f : R →+* S} {K : Ideal S} :\n    comap f K.jacobson = sInf (comap f '' { J : Ideal S | K ≤ J ∧ J.IsMaximal }) :=\n  Trans.trans (comap_sInf' f _) sInf_eq_iInf.symm\n\n"}
{"name":"Ideal.comap_jacobson_of_surjective","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\nhf : Function.Surjective ⇑f\nK : Ideal S\n⊢ Eq (Ideal.comap f K.jacobson) (Ideal.comap f K).jacobson","decl":"theorem comap_jacobson_of_surjective {f : R →+* S} (hf : Function.Surjective f) {K : Ideal S} :\n    comap f K.jacobson = (comap f K).jacobson := by\n  unfold Ideal.jacobson\n  refine le_antisymm ?_ ?_\n  · rw [← top_inf_eq (sInf _), ← sInf_insert, comap_sInf', sInf_eq_iInf]\n    refine iInf_le_iInf_of_subset fun J hJ => ?_\n    have : comap f (map f J) = J :=\n      Trans.trans (comap_map_of_surjective f hf J)\n        (le_antisymm (sup_le_iff.2 ⟨le_of_eq rfl, le_trans (comap_mono bot_le) hJ.left⟩)\n          le_sup_left)\n    cases' map_eq_top_or_isMaximal_of_surjective _ hf hJ.right with htop hmax\n    · exact ⟨⊤, Set.mem_insert ⊤ _, htop ▸ this⟩\n    · exact ⟨map f J, Set.mem_insert_of_mem _ ⟨le_map_of_comap_le_of_surjective f hf hJ.1, hmax⟩,\n        this⟩\n  · simp_rw [comap_sInf, le_iInf_iff]\n    intros J hJ\n    haveI : J.IsMaximal := hJ.right\n    exact sInf_le ⟨comap_mono hJ.left, comap_isMaximal_of_surjective _ hf⟩\n\n"}
{"name":"Ideal.jacobson_mono","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst✝ : Ring R\nI J : Ideal R\na✝ : LE.le I J\n⊢ LE.le I.jacobson J.jacobson","decl":"@[mono]\ntheorem jacobson_mono {I J : Ideal R} : I ≤ J → I.jacobson ≤ J.jacobson := by\n  intro h x hx\n  erw [mem_sInf] at hx ⊢\n  exact fun K ⟨hK, hK_max⟩ => hx ⟨Trans.trans h hK, hK_max⟩\n\n"}
{"name":"Ideal.jacobson_mul_mem_right","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst✝ : Ring R\nI : Ideal R\nmul_mem_right : ∀ {x y : R}, Membership.mem I x → Membership.mem I (HMul.hMul x y)\nx y : R\na✝ : Membership.mem I.jacobson x\n⊢ Membership.mem I.jacobson (HMul.hMul x y)","decl":"/-- The Jacobson radical of a two-sided ideal is two-sided.\n\nIt is preferable to use `TwoSidedIdeal.jacobson` instead of this lemma. -/\ntheorem jacobson_mul_mem_right {I : Ideal R}\n    (mul_mem_right : ∀ {x y}, x ∈ I → x * y ∈ I) :\n    ∀ {x y}, x ∈ I.jacobson → x * y ∈ I.jacobson := by\n  -- Proof generalized from\n  -- https://ysharifi.wordpress.com/2022/08/16/the-jacobson-radical-definition-and-basic-results/\n  intro x r xJ\n  apply mem_sInf.mpr\n  intro 𝔪 𝔪_mem\n  by_cases r𝔪 : r ∈ 𝔪\n  · apply 𝔪.smul_mem _ r𝔪\n  -- 𝔪₀ := { a : R | a*r ∈ 𝔪 }\n  let 𝔪₀ : Ideal R := Submodule.comap (DistribMulAction.toLinearMap R (S := Rᵐᵒᵖ) R (.op r)) 𝔪\n  suffices x ∈ 𝔪₀ by simpa [𝔪₀] using this\n  have I𝔪₀ : I ≤ 𝔪₀ := fun i iI =>\n    𝔪_mem.left (mul_mem_right iI)\n  have 𝔪₀_maximal : IsMaximal 𝔪₀ := by\n    refine isMaximal_iff.mpr ⟨\n      fun h => r𝔪 (by simpa [𝔪₀] using h),\n      fun J b 𝔪₀J b𝔪₀ bJ => ?_⟩\n    let K : Ideal R := Ideal.span {b*r} ⊔ 𝔪\n    have ⟨s, y, y𝔪, sbyr⟩ :=\n      mem_span_singleton_sup.mp <|\n        mul_mem_left _ r <|\n          (isMaximal_iff.mp 𝔪_mem.right).right K (b*r)\n          le_sup_right b𝔪₀\n          (mem_sup_left <| mem_span_singleton_self _)\n    have : 1 - s*b ∈ 𝔪₀ := by\n      rw [mul_one, add_comm, ← eq_sub_iff_add_eq] at sbyr\n      rw [sbyr, ← mul_assoc] at y𝔪\n      simp [𝔪₀, sub_mul, y𝔪]\n    have : 1 - s*b + s*b ∈ J := by\n      apply add_mem (𝔪₀J this) (J.mul_mem_left _ bJ)\n    simpa using this\n  exact mem_sInf.mp xJ ⟨I𝔪₀, 𝔪₀_maximal⟩\n\n"}
{"name":"Ideal.radical_le_jacobson","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\n⊢ LE.le I.radical I.jacobson","decl":"theorem radical_le_jacobson : radical I ≤ jacobson I :=\n  le_sInf fun _ hJ => (radical_eq_sInf I).symm ▸ sInf_le ⟨hJ.left, IsMaximal.isPrime hJ.right⟩\n\n"}
{"name":"Ideal.isRadical_of_eq_jacobson","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\nh : Eq I.jacobson I\n⊢ I.IsRadical","decl":"theorem isRadical_of_eq_jacobson (h : jacobson I = I) : I.IsRadical :=\n  radical_le_jacobson.trans h.le\n\n"}
{"name":"Ideal.isRadical_jacobson","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\n⊢ I.jacobson.IsRadical","decl":"lemma isRadical_jacobson (I : Ideal R) : I.jacobson.IsRadical :=\n  isRadical_of_eq_jacobson jacobson_idem\n\n"}
{"name":"Ideal.isUnit_of_sub_one_mem_jacobson_bot","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst✝ : CommRing R\nr : R\nh : Membership.mem Bot.bot.jacobson (HSub.hSub r 1)\n⊢ IsUnit r","decl":"theorem isUnit_of_sub_one_mem_jacobson_bot (r : R) (h : r - 1 ∈ jacobson (⊥ : Ideal R)) :\n    IsUnit r := by\n  cases' exists_mul_sub_mem_of_sub_one_mem_jacobson r h with s hs\n  rw [mem_bot, sub_eq_zero, mul_comm] at hs\n  exact isUnit_of_mul_eq_one _ _ hs\n\n"}
{"name":"Ideal.mem_jacobson_bot","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst✝ : CommRing R\nx : R\n⊢ Iff (Membership.mem Bot.bot.jacobson x) (∀ (y : R), IsUnit (HAdd.hAdd (HMul.hMul x y) 1))","decl":"theorem mem_jacobson_bot {x : R} : x ∈ jacobson (⊥ : Ideal R) ↔ ∀ y, IsUnit (x * y + 1) :=\n  ⟨fun hx y =>\n    let ⟨z, hz⟩ := (mem_jacobson_iff.1 hx) y\n    isUnit_iff_exists_inv.2\n      ⟨z, by rwa [add_mul, one_mul, ← sub_eq_zero, mul_right_comm, mul_comm _ z, mul_right_comm]⟩,\n    fun h =>\n    mem_jacobson_iff.mpr fun y =>\n      let ⟨b, hb⟩ := isUnit_iff_exists_inv.1 (h y)\n      ⟨b, (Submodule.mem_bot R).2 (hb ▸ by ring)⟩⟩\n\n"}
{"name":"Ideal.jacobson_eq_iff_jacobson_quotient_eq_bot","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\n⊢ Iff (Eq I.jacobson I) (Eq Bot.bot.jacobson Bot.bot)","decl":"/-- An ideal `I` of `R` is equal to its Jacobson radical if and only if\nthe Jacobson radical of the quotient ring `R/I` is the zero ideal -/\n-- Porting note: changed `Quotient.mk'` to ``\ntheorem jacobson_eq_iff_jacobson_quotient_eq_bot :\n    I.jacobson = I ↔ jacobson (⊥ : Ideal (R ⧸ I)) = ⊥ := by\n  have hf : Function.Surjective (Ideal.Quotient.mk I) := Submodule.Quotient.mk_surjective I\n  constructor\n  · intro h\n    replace h := congr_arg (Ideal.map (Ideal.Quotient.mk I)) h\n    rw [map_jacobson_of_surjective hf (le_of_eq mk_ker)] at h\n    simpa using h\n  · intro h\n    replace h := congr_arg (comap (Ideal.Quotient.mk I)) h\n    rw [comap_jacobson_of_surjective hf, ← RingHom.ker_eq_comap_bot (Ideal.Quotient.mk I)] at h\n    simpa using h\n\n"}
{"name":"Ideal.radical_eq_jacobson_iff_radical_quotient_eq_jacobson_bot","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\n⊢ Iff (Eq I.radical I.jacobson) (Eq Bot.bot.radical Bot.bot.jacobson)","decl":"/-- The standard radical and Jacobson radical of an ideal `I` of `R` are equal if and only if\nthe nilradical and Jacobson radical of the quotient ring `R/I` coincide -/\n-- Porting note: changed `Quotient.mk'` to ``\ntheorem radical_eq_jacobson_iff_radical_quotient_eq_jacobson_bot :\n    I.radical = I.jacobson ↔ radical (⊥ : Ideal (R ⧸ I)) = jacobson ⊥ := by\n  have hf : Function.Surjective (Ideal.Quotient.mk I) := Submodule.Quotient.mk_surjective I\n  constructor\n  · intro h\n    have := congr_arg (map (Ideal.Quotient.mk I)) h\n    rw [map_radical_of_surjective hf (le_of_eq mk_ker),\n      map_jacobson_of_surjective hf (le_of_eq mk_ker)] at this\n    simpa using this\n  · intro h\n    have := congr_arg (comap (Ideal.Quotient.mk I)) h\n    rw [comap_radical, comap_jacobson_of_surjective hf,\n      ← RingHom.ker_eq_comap_bot (Ideal.Quotient.mk I)] at this\n    simpa using this\n\n"}
{"name":"Ideal.jacobson_radical_eq_jacobson","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\n⊢ Eq I.radical.jacobson I.jacobson","decl":"theorem jacobson_radical_eq_jacobson : I.radical.jacobson = I.jacobson :=\n  le_antisymm\n    (le_trans (le_of_eq (congr_arg jacobson (radical_eq_sInf I)))\n      (sInf_le_sInf fun _ hJ => ⟨sInf_le ⟨hJ.1, hJ.2.isPrime⟩, hJ.2⟩))\n    (jacobson_mono le_radical)\n\n"}
{"name":"Ideal.IsLocal.out","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\nself : I.IsLocal\n⊢ I.jacobson.IsMaximal","decl":"/-- An ideal `I` is local iff its Jacobson radical is maximal. -/\nclass IsLocal (I : Ideal R) : Prop where\n  /-- A ring `R` is local if and only if its jacobson radical is maximal -/\n  out : IsMaximal (jacobson I)\n\n"}
{"name":"Ideal.isLocal_iff","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\n⊢ Iff I.IsLocal I.jacobson.IsMaximal","decl":"theorem isLocal_iff {I : Ideal R} : IsLocal I ↔ IsMaximal (jacobson I) :=\n  ⟨fun h => h.1, fun h => ⟨h⟩⟩\n\n"}
{"name":"Ideal.isLocal_of_isMaximal_radical","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\nhi : I.radical.IsMaximal\n⊢ I.IsLocal","decl":"theorem isLocal_of_isMaximal_radical {I : Ideal R} (hi : IsMaximal (radical I)) : IsLocal I :=\n  ⟨have : radical I = jacobson I :=\n      le_antisymm (le_sInf fun _ ⟨him, hm⟩ => hm.isPrime.radical_le_iff.2 him)\n        (sInf_le ⟨le_radical, hi⟩)\n    show IsMaximal (jacobson I) from this ▸ hi⟩\n\n"}
{"name":"Ideal.IsLocal.le_jacobson","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst✝ : CommRing R\nI J : Ideal R\nhi : I.IsLocal\nhij : LE.le I J\nhj : Ne J Top.top\n⊢ LE.le J I.jacobson","decl":"theorem IsLocal.le_jacobson {I J : Ideal R} (hi : IsLocal I) (hij : I ≤ J) (hj : J ≠ ⊤) :\n    J ≤ jacobson I :=\n  let ⟨_, hm, hjm⟩ := exists_le_maximal J hj\n  le_trans hjm <| le_of_eq <| Eq.symm <| hi.1.eq_of_le hm.1.1 <| sInf_le ⟨le_trans hij hjm, hm⟩\n\n"}
{"name":"Ideal.IsLocal.mem_jacobson_or_exists_inv","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\nhi : I.IsLocal\nx : R\n⊢ Or (Membership.mem I.jacobson x) (Exists fun y => Membership.mem I (HSub.hSub (HMul.hMul y x) 1))","decl":"theorem IsLocal.mem_jacobson_or_exists_inv {I : Ideal R} (hi : IsLocal I) (x : R) :\n    x ∈ jacobson I ∨ ∃ y, y * x - 1 ∈ I :=\n  by_cases\n    (fun h : I ⊔ span {x} = ⊤ =>\n      let ⟨p, hpi, q, hq, hpq⟩ := Submodule.mem_sup.1 ((eq_top_iff_one _).1 h)\n      let ⟨r, hr⟩ := mem_span_singleton.1 hq\n      Or.inr ⟨r, by\n        rw [← hpq, mul_comm, ← hr, ← neg_sub, add_sub_cancel_right]; exact I.neg_mem hpi⟩)\n    fun h : I ⊔ span {x} ≠ ⊤ =>\n    Or.inl <|\n      le_trans le_sup_right (hi.le_jacobson le_sup_left h) <| mem_span_singleton.2 <| dvd_refl x\n\n"}
{"name":"Ideal.isPrimary_of_isMaximal_radical","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\nhi : I.radical.IsMaximal\n⊢ I.IsPrimary","decl":"theorem isPrimary_of_isMaximal_radical [CommRing R] {I : Ideal R} (hi : IsMaximal (radical I)) :\n    I.IsPrimary :=\n  have : radical I = jacobson I :=\n    le_antisymm (le_sInf fun _ ⟨him, hm⟩ => hm.isPrime.radical_le_iff.2 him)\n      (sInf_le ⟨le_radical, hi⟩)\n  isPrimary_iff.mpr\n  ⟨ne_top_of_lt <| lt_of_le_of_lt le_radical (lt_top_iff_ne_top.2 hi.1.1), fun {x y} hxy =>\n    ((isLocal_of_isMaximal_radical hi).mem_jacobson_or_exists_inv y).symm.imp\n      (fun ⟨z, hz⟩ => by\n        rw [← mul_one x, ← sub_sub_cancel (z * y) 1, mul_sub, mul_left_comm]\n        exact I.sub_mem (I.mul_mem_left _ hxy) (I.mul_mem_left _ hz))\n      (this ▸ id)⟩\n\n"}
{"name":"TwoSidedIdeal.asIdeal_jacobson","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst✝ : Ring R\nI : TwoSidedIdeal R\n⊢ Eq (TwoSidedIdeal.asIdeal I.jacobson) (TwoSidedIdeal.asIdeal I).jacobson","decl":"lemma asIdeal_jacobson (I : TwoSidedIdeal R) : asIdeal I.jacobson = (asIdeal I).jacobson := by\n  ext; simp [jacobson]\n\n"}
{"name":"TwoSidedIdeal.mem_jacobson_iff","module":"Mathlib.RingTheory.Jacobson.Ideal","initialProofState":"R : Type u\ninst✝ : Ring R\nx : R\nI : TwoSidedIdeal R\n⊢ Iff (Membership.mem I.jacobson x) (∀ (y : R), Exists fun z => Membership.mem I (HSub.hSub (HAdd.hAdd (HMul.hMul (HMul.hMul z y) x) z) 1))","decl":"theorem mem_jacobson_iff {x : R} {I : TwoSidedIdeal R} :\n    x ∈ jacobson I ↔ ∀ y, ∃ z, z * y * x + z - 1 ∈ I := by\n  simp [jacobson, Ideal.mem_jacobson_iff]\n\n"}
