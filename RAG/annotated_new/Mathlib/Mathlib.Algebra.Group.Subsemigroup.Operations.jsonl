{"name":"Subsemigroup.coe_toAddSubsemigroup_apply","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\ninst✝ : Mul M\nS : Subsemigroup M\n⊢ Eq (↑(Subsemigroup.toAddSubsemigroup S)) (Set.preimage ⇑Additive.toMul ↑S)","decl":"/-- Subsemigroups of semigroup `M` are isomorphic to additive subsemigroups of `Additive M`. -/\n@[simps]\ndef Subsemigroup.toAddSubsemigroup : Subsemigroup M ≃o AddSubsemigroup (Additive M) where\n  toFun S :=\n    { carrier := Additive.toMul ⁻¹' S\n      add_mem' := S.mul_mem' }\n  invFun S :=\n    { carrier := Additive.ofMul ⁻¹' S\n      mul_mem' := S.add_mem' }\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_rel_iff' := Iff.rfl\n\n"}
{"name":"Subsemigroup.coe_toAddSubsemigroup_symm_apply","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\ninst✝ : Mul M\nS : AddSubsemigroup (Additive M)\n⊢ Eq (↑((RelIso.symm Subsemigroup.toAddSubsemigroup) S)) (Set.preimage ⇑Additive.ofMul ↑S)","decl":"/-- Subsemigroups of semigroup `M` are isomorphic to additive subsemigroups of `Additive M`. -/\n@[simps]\ndef Subsemigroup.toAddSubsemigroup : Subsemigroup M ≃o AddSubsemigroup (Additive M) where\n  toFun S :=\n    { carrier := Additive.toMul ⁻¹' S\n      add_mem' := S.mul_mem' }\n  invFun S :=\n    { carrier := Additive.ofMul ⁻¹' S\n      mul_mem' := S.add_mem' }\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_rel_iff' := Iff.rfl\n\n"}
{"name":"Subsemigroup.toAddSubsemigroup_closure","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\ninst✝ : Mul M\nS : Set M\n⊢ Eq (Subsemigroup.toAddSubsemigroup (Subsemigroup.closure S)) (AddSubsemigroup.closure (Set.preimage (⇑Additive.toMul) S))","decl":"theorem Subsemigroup.toAddSubsemigroup_closure (S : Set M) :\n    Subsemigroup.toAddSubsemigroup (Subsemigroup.closure S) =\n    AddSubsemigroup.closure (Additive.toMul ⁻¹' S) :=\n  le_antisymm\n    (Subsemigroup.toAddSubsemigroup.le_symm_apply.1 <|\n      Subsemigroup.closure_le.2 (AddSubsemigroup.subset_closure (M := Additive M)))\n    (AddSubsemigroup.closure_le.2 (Subsemigroup.subset_closure (M := M)))\n\n"}
{"name":"AddSubsemigroup.toSubsemigroup'_closure","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\ninst✝ : Mul M\nS : Set (Additive M)\n⊢ Eq (AddSubsemigroup.toSubsemigroup' (AddSubsemigroup.closure S)) (Subsemigroup.closure (Set.preimage (⇑Additive.ofMul) S))","decl":"theorem AddSubsemigroup.toSubsemigroup'_closure (S : Set (Additive M)) :\n    AddSubsemigroup.toSubsemigroup' (AddSubsemigroup.closure S) =\n      Subsemigroup.closure (Additive.ofMul ⁻¹' S) :=\n  le_antisymm\n    (AddSubsemigroup.toSubsemigroup'.le_symm_apply.1 <|\n      AddSubsemigroup.closure_le.2 (Subsemigroup.subset_closure (M := M)))\n    (Subsemigroup.closure_le.2 <| AddSubsemigroup.subset_closure (M := Additive M))\n\n"}
{"name":"AddSubsemigroup.coe_toSubsemigroup_apply","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"A : Type u_5\ninst✝ : Add A\nS : AddSubsemigroup A\n⊢ Eq (↑(AddSubsemigroup.toSubsemigroup S)) (Set.preimage ⇑Multiplicative.toAdd ↑S)","decl":"/-- Additive subsemigroups of an additive semigroup `A` are isomorphic to\nmultiplicative subsemigroups of `Multiplicative A`. -/\n@[simps]\ndef AddSubsemigroup.toSubsemigroup : AddSubsemigroup A ≃o Subsemigroup (Multiplicative A) where\n  toFun S :=\n    { carrier := Multiplicative.toAdd ⁻¹' S\n      mul_mem' := S.add_mem' }\n  invFun S :=\n    { carrier := Multiplicative.ofAdd ⁻¹' S\n      add_mem' := S.mul_mem' }\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_rel_iff' := Iff.rfl\n\n"}
{"name":"AddSubsemigroup.coe_toSubsemigroup_symm_apply","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"A : Type u_5\ninst✝ : Add A\nS : Subsemigroup (Multiplicative A)\n⊢ Eq (↑((RelIso.symm AddSubsemigroup.toSubsemigroup) S)) (Set.preimage ⇑Multiplicative.ofAdd ↑S)","decl":"/-- Additive subsemigroups of an additive semigroup `A` are isomorphic to\nmultiplicative subsemigroups of `Multiplicative A`. -/\n@[simps]\ndef AddSubsemigroup.toSubsemigroup : AddSubsemigroup A ≃o Subsemigroup (Multiplicative A) where\n  toFun S :=\n    { carrier := Multiplicative.toAdd ⁻¹' S\n      mul_mem' := S.add_mem' }\n  invFun S :=\n    { carrier := Multiplicative.ofAdd ⁻¹' S\n      add_mem' := S.mul_mem' }\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_rel_iff' := Iff.rfl\n\n"}
{"name":"AddSubsemigroup.toSubsemigroup_closure","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"A : Type u_5\ninst✝ : Add A\nS : Set A\n⊢ Eq (AddSubsemigroup.toSubsemigroup (AddSubsemigroup.closure S)) (Subsemigroup.closure (Set.preimage (⇑Multiplicative.toAdd) S))","decl":"theorem AddSubsemigroup.toSubsemigroup_closure (S : Set A) :\n    AddSubsemigroup.toSubsemigroup (AddSubsemigroup.closure S) =\n      Subsemigroup.closure (Multiplicative.toAdd ⁻¹' S) :=\n  le_antisymm\n    (AddSubsemigroup.toSubsemigroup.to_galoisConnection.l_le <|\n      AddSubsemigroup.closure_le.2 <| Subsemigroup.subset_closure (M := Multiplicative A))\n    (Subsemigroup.closure_le.2 <| AddSubsemigroup.subset_closure (M := A))\n\n"}
{"name":"Subsemigroup.toAddSubsemigroup'_closure","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"A : Type u_5\ninst✝ : Add A\nS : Set (Multiplicative A)\n⊢ Eq (Subsemigroup.toAddSubsemigroup' (Subsemigroup.closure S)) (AddSubsemigroup.closure (Set.preimage (⇑Multiplicative.ofAdd) S))","decl":"theorem Subsemigroup.toAddSubsemigroup'_closure (S : Set (Multiplicative A)) :\n    Subsemigroup.toAddSubsemigroup' (Subsemigroup.closure S) =\n      AddSubsemigroup.closure (Multiplicative.ofAdd ⁻¹' S) :=\n  le_antisymm\n    (Subsemigroup.toAddSubsemigroup'.to_galoisConnection.l_le <|\n      Subsemigroup.closure_le.2 <| AddSubsemigroup.subset_closure (M := A))\n    (AddSubsemigroup.closure_le.2 <| Subsemigroup.subset_closure (M := Multiplicative A))\n\n"}
{"name":"AddSubsemigroup.coe_comap","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nS : AddSubsemigroup N\nf : AddHom M N\n⊢ Eq (↑(AddSubsemigroup.comap f S)) (Set.preimage ⇑f ↑S)","decl":"@[to_additive (attr := simp)]\ntheorem coe_comap (S : Subsemigroup N) (f : M →ₙ* N) : (S.comap f : Set M) = f ⁻¹' S :=\n  rfl\n\n"}
{"name":"Subsemigroup.coe_comap","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nS : Subsemigroup N\nf : MulHom M N\n⊢ Eq (↑(Subsemigroup.comap f S)) (Set.preimage ⇑f ↑S)","decl":"@[to_additive (attr := simp)]\ntheorem coe_comap (S : Subsemigroup N) (f : M →ₙ* N) : (S.comap f : Set M) = f ⁻¹' S :=\n  rfl\n\n"}
{"name":"Subsemigroup.mem_comap","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nS : Subsemigroup N\nf : MulHom M N\nx : M\n⊢ Iff (Membership.mem (Subsemigroup.comap f S) x) (Membership.mem S (f x))","decl":"@[to_additive (attr := simp)]\ntheorem mem_comap {S : Subsemigroup N} {f : M →ₙ* N} {x : M} : x ∈ S.comap f ↔ f x ∈ S :=\n  Iff.rfl\n\n"}
{"name":"AddSubsemigroup.mem_comap","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nS : AddSubsemigroup N\nf : AddHom M N\nx : M\n⊢ Iff (Membership.mem (AddSubsemigroup.comap f S) x) (Membership.mem S (f x))","decl":"@[to_additive (attr := simp)]\ntheorem mem_comap {S : Subsemigroup N} {f : M →ₙ* N} {x : M} : x ∈ S.comap f ↔ f x ∈ S :=\n  Iff.rfl\n\n"}
{"name":"Subsemigroup.comap_comap","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : Mul M\ninst✝¹ : Mul N\ninst✝ : Mul P\nS : Subsemigroup P\ng : MulHom N P\nf : MulHom M N\n⊢ Eq (Subsemigroup.comap f (Subsemigroup.comap g S)) (Subsemigroup.comap (g.comp f) S)","decl":"@[to_additive]\ntheorem comap_comap (S : Subsemigroup P) (g : N →ₙ* P) (f : M →ₙ* N) :\n    (S.comap g).comap f = S.comap (g.comp f) :=\n  rfl\n\n"}
{"name":"AddSubsemigroup.comap_comap","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : Add M\ninst✝¹ : Add N\ninst✝ : Add P\nS : AddSubsemigroup P\ng : AddHom N P\nf : AddHom M N\n⊢ Eq (AddSubsemigroup.comap f (AddSubsemigroup.comap g S)) (AddSubsemigroup.comap (g.comp f) S)","decl":"@[to_additive]\ntheorem comap_comap (S : Subsemigroup P) (g : N →ₙ* P) (f : M →ₙ* N) :\n    (S.comap g).comap f = S.comap (g.comp f) :=\n  rfl\n\n"}
{"name":"AddSubsemigroup.comap_id","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"P : Type u_3\ninst✝ : Add P\nS : AddSubsemigroup P\n⊢ Eq (AddSubsemigroup.comap (AddHom.id P) S) S","decl":"@[to_additive (attr := simp)]\ntheorem comap_id (S : Subsemigroup P) : S.comap (MulHom.id _) = S :=\n  ext (by simp)\n\n"}
{"name":"Subsemigroup.comap_id","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"P : Type u_3\ninst✝ : Mul P\nS : Subsemigroup P\n⊢ Eq (Subsemigroup.comap (MulHom.id P) S) S","decl":"@[to_additive (attr := simp)]\ntheorem comap_id (S : Subsemigroup P) : S.comap (MulHom.id _) = S :=\n  ext (by simp)\n\n"}
{"name":"AddSubsemigroup.coe_map","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\nS : AddSubsemigroup M\n⊢ Eq (↑(AddSubsemigroup.map f S)) (Set.image ⇑f ↑S)","decl":"@[to_additive (attr := simp)]\ntheorem coe_map (f : M →ₙ* N) (S : Subsemigroup M) : (S.map f : Set N) = f '' S :=\n  rfl\n\n"}
{"name":"Subsemigroup.coe_map","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\nS : Subsemigroup M\n⊢ Eq (↑(Subsemigroup.map f S)) (Set.image ⇑f ↑S)","decl":"@[to_additive (attr := simp)]\ntheorem coe_map (f : M →ₙ* N) (S : Subsemigroup M) : (S.map f : Set N) = f '' S :=\n  rfl\n\n"}
{"name":"Subsemigroup.mem_map","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\nS : Subsemigroup M\ny : N\n⊢ Iff (Membership.mem (Subsemigroup.map f S) y) (Exists fun x => And (Membership.mem S x) (Eq (f x) y))","decl":"@[to_additive (attr := simp)]\ntheorem mem_map {f : M →ₙ* N} {S : Subsemigroup M} {y : N} : y ∈ S.map f ↔ ∃ x ∈ S, f x = y :=\n  mem_image _ _ _\n\n"}
{"name":"AddSubsemigroup.mem_map","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\nS : AddSubsemigroup M\ny : N\n⊢ Iff (Membership.mem (AddSubsemigroup.map f S) y) (Exists fun x => And (Membership.mem S x) (Eq (f x) y))","decl":"@[to_additive (attr := simp)]\ntheorem mem_map {f : M →ₙ* N} {S : Subsemigroup M} {y : N} : y ∈ S.map f ↔ ∃ x ∈ S, f x = y :=\n  mem_image _ _ _\n\n"}
{"name":"Subsemigroup.mem_map_of_mem","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\nS : Subsemigroup M\nx : M\nhx : Membership.mem S x\n⊢ Membership.mem (Subsemigroup.map f S) (f x)","decl":"@[to_additive]\ntheorem mem_map_of_mem (f : M →ₙ* N) {S : Subsemigroup M} {x : M} (hx : x ∈ S) : f x ∈ S.map f :=\n  mem_image_of_mem f hx\n\n"}
{"name":"AddSubsemigroup.mem_map_of_mem","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\nS : AddSubsemigroup M\nx : M\nhx : Membership.mem S x\n⊢ Membership.mem (AddSubsemigroup.map f S) (f x)","decl":"@[to_additive]\ntheorem mem_map_of_mem (f : M →ₙ* N) {S : Subsemigroup M} {x : M} (hx : x ∈ S) : f x ∈ S.map f :=\n  mem_image_of_mem f hx\n\n"}
{"name":"Subsemigroup.apply_coe_mem_map","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\nS : Subsemigroup M\nx : Subtype fun x => Membership.mem S x\n⊢ Membership.mem (Subsemigroup.map f S) (f ↑x)","decl":"@[to_additive]\ntheorem apply_coe_mem_map (f : M →ₙ* N) (S : Subsemigroup M) (x : S) : f x ∈ S.map f :=\n  mem_map_of_mem f x.prop\n\n"}
{"name":"AddSubsemigroup.apply_coe_mem_map","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\nS : AddSubsemigroup M\nx : Subtype fun x => Membership.mem S x\n⊢ Membership.mem (AddSubsemigroup.map f S) (f ↑x)","decl":"@[to_additive]\ntheorem apply_coe_mem_map (f : M →ₙ* N) (S : Subsemigroup M) (x : S) : f x ∈ S.map f :=\n  mem_map_of_mem f x.prop\n\n"}
{"name":"AddSubsemigroup.map_map","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : Add M\ninst✝¹ : Add N\ninst✝ : Add P\nS : AddSubsemigroup M\ng : AddHom N P\nf : AddHom M N\n⊢ Eq (AddSubsemigroup.map g (AddSubsemigroup.map f S)) (AddSubsemigroup.map (g.comp f) S)","decl":"@[to_additive]\ntheorem map_map (g : N →ₙ* P) (f : M →ₙ* N) : (S.map f).map g = S.map (g.comp f) :=\n  SetLike.coe_injective <| image_image _ _ _\n\n-- The simpNF linter says that the LHS can be simplified via `Subsemigroup.mem_map`.\n-- However this is a higher priority lemma.\n-- https://github.com/leanprover/std4/issues/207\n"}
{"name":"Subsemigroup.map_map","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : Mul M\ninst✝¹ : Mul N\ninst✝ : Mul P\nS : Subsemigroup M\ng : MulHom N P\nf : MulHom M N\n⊢ Eq (Subsemigroup.map g (Subsemigroup.map f S)) (Subsemigroup.map (g.comp f) S)","decl":"@[to_additive]\ntheorem map_map (g : N →ₙ* P) (f : M →ₙ* N) : (S.map f).map g = S.map (g.comp f) :=\n  SetLike.coe_injective <| image_image _ _ _\n\n-- The simpNF linter says that the LHS can be simplified via `Subsemigroup.mem_map`.\n-- However this is a higher priority lemma.\n-- https://github.com/leanprover/std4/issues/207\n"}
{"name":"AddSubsemigroup.mem_map_iff_mem","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\nhf : Function.Injective ⇑f\nS : AddSubsemigroup M\nx : M\n⊢ Iff (Membership.mem (AddSubsemigroup.map f S) (f x)) (Membership.mem S x)","decl":"@[to_additive (attr := simp, nolint simpNF)]\ntheorem mem_map_iff_mem {f : M →ₙ* N} (hf : Function.Injective f) {S : Subsemigroup M} {x : M} :\n    f x ∈ S.map f ↔ x ∈ S :=\n  hf.mem_set_image\n\n"}
{"name":"Subsemigroup.mem_map_iff_mem","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\nhf : Function.Injective ⇑f\nS : Subsemigroup M\nx : M\n⊢ Iff (Membership.mem (Subsemigroup.map f S) (f x)) (Membership.mem S x)","decl":"@[to_additive (attr := simp, nolint simpNF)]\ntheorem mem_map_iff_mem {f : M →ₙ* N} (hf : Function.Injective f) {S : Subsemigroup M} {x : M} :\n    f x ∈ S.map f ↔ x ∈ S :=\n  hf.mem_set_image\n\n"}
{"name":"AddSubsemigroup.map_le_iff_le_comap","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\nS : AddSubsemigroup M\nT : AddSubsemigroup N\n⊢ Iff (LE.le (AddSubsemigroup.map f S) T) (LE.le S (AddSubsemigroup.comap f T))","decl":"@[to_additive]\ntheorem map_le_iff_le_comap {f : M →ₙ* N} {S : Subsemigroup M} {T : Subsemigroup N} :\n    S.map f ≤ T ↔ S ≤ T.comap f :=\n  image_subset_iff\n\n"}
{"name":"Subsemigroup.map_le_iff_le_comap","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\nS : Subsemigroup M\nT : Subsemigroup N\n⊢ Iff (LE.le (Subsemigroup.map f S) T) (LE.le S (Subsemigroup.comap f T))","decl":"@[to_additive]\ntheorem map_le_iff_le_comap {f : M →ₙ* N} {S : Subsemigroup M} {T : Subsemigroup N} :\n    S.map f ≤ T ↔ S ≤ T.comap f :=\n  image_subset_iff\n\n"}
{"name":"AddSubsemigroup.gc_map_comap","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\n⊢ GaloisConnection (AddSubsemigroup.map f) (AddSubsemigroup.comap f)","decl":"@[to_additive]\ntheorem gc_map_comap (f : M →ₙ* N) : GaloisConnection (map f) (comap f) := fun _ _ =>\n  map_le_iff_le_comap\n\n"}
{"name":"Subsemigroup.gc_map_comap","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\n⊢ GaloisConnection (Subsemigroup.map f) (Subsemigroup.comap f)","decl":"@[to_additive]\ntheorem gc_map_comap (f : M →ₙ* N) : GaloisConnection (map f) (comap f) := fun _ _ =>\n  map_le_iff_le_comap\n\n"}
{"name":"AddSubsemigroup.map_le_of_le_comap","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nS : AddSubsemigroup M\nT : AddSubsemigroup N\nf : AddHom M N\na✝ : LE.le S (AddSubsemigroup.comap f T)\n⊢ LE.le (AddSubsemigroup.map f S) T","decl":"@[to_additive]\ntheorem map_le_of_le_comap {T : Subsemigroup N} {f : M →ₙ* N} : S ≤ T.comap f → S.map f ≤ T :=\n  (gc_map_comap f).l_le\n\n"}
{"name":"Subsemigroup.map_le_of_le_comap","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nS : Subsemigroup M\nT : Subsemigroup N\nf : MulHom M N\na✝ : LE.le S (Subsemigroup.comap f T)\n⊢ LE.le (Subsemigroup.map f S) T","decl":"@[to_additive]\ntheorem map_le_of_le_comap {T : Subsemigroup N} {f : M →ₙ* N} : S ≤ T.comap f → S.map f ≤ T :=\n  (gc_map_comap f).l_le\n\n"}
{"name":"Subsemigroup.le_comap_of_map_le","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nS : Subsemigroup M\nT : Subsemigroup N\nf : MulHom M N\na✝ : LE.le (Subsemigroup.map f S) T\n⊢ LE.le S (Subsemigroup.comap f T)","decl":"@[to_additive]\ntheorem le_comap_of_map_le {T : Subsemigroup N} {f : M →ₙ* N} : S.map f ≤ T → S ≤ T.comap f :=\n  (gc_map_comap f).le_u\n\n"}
{"name":"AddSubsemigroup.le_comap_of_map_le","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nS : AddSubsemigroup M\nT : AddSubsemigroup N\nf : AddHom M N\na✝ : LE.le (AddSubsemigroup.map f S) T\n⊢ LE.le S (AddSubsemigroup.comap f T)","decl":"@[to_additive]\ntheorem le_comap_of_map_le {T : Subsemigroup N} {f : M →ₙ* N} : S.map f ≤ T → S ≤ T.comap f :=\n  (gc_map_comap f).le_u\n\n"}
{"name":"AddSubsemigroup.le_comap_map","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nS : AddSubsemigroup M\nf : AddHom M N\n⊢ LE.le S (AddSubsemigroup.comap f (AddSubsemigroup.map f S))","decl":"@[to_additive]\ntheorem le_comap_map {f : M →ₙ* N} : S ≤ (S.map f).comap f :=\n  (gc_map_comap f).le_u_l _\n\n"}
{"name":"Subsemigroup.le_comap_map","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nS : Subsemigroup M\nf : MulHom M N\n⊢ LE.le S (Subsemigroup.comap f (Subsemigroup.map f S))","decl":"@[to_additive]\ntheorem le_comap_map {f : M →ₙ* N} : S ≤ (S.map f).comap f :=\n  (gc_map_comap f).le_u_l _\n\n"}
{"name":"Subsemigroup.map_comap_le","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nS : Subsemigroup N\nf : MulHom M N\n⊢ LE.le (Subsemigroup.map f (Subsemigroup.comap f S)) S","decl":"@[to_additive]\ntheorem map_comap_le {S : Subsemigroup N} {f : M →ₙ* N} : (S.comap f).map f ≤ S :=\n  (gc_map_comap f).l_u_le _\n\n"}
{"name":"AddSubsemigroup.map_comap_le","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nS : AddSubsemigroup N\nf : AddHom M N\n⊢ LE.le (AddSubsemigroup.map f (AddSubsemigroup.comap f S)) S","decl":"@[to_additive]\ntheorem map_comap_le {S : Subsemigroup N} {f : M →ₙ* N} : (S.comap f).map f ≤ S :=\n  (gc_map_comap f).l_u_le _\n\n"}
{"name":"Subsemigroup.monotone_map","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\n⊢ Monotone (Subsemigroup.map f)","decl":"@[to_additive]\ntheorem monotone_map {f : M →ₙ* N} : Monotone (map f) :=\n  (gc_map_comap f).monotone_l\n\n"}
{"name":"AddSubsemigroup.monotone_map","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\n⊢ Monotone (AddSubsemigroup.map f)","decl":"@[to_additive]\ntheorem monotone_map {f : M →ₙ* N} : Monotone (map f) :=\n  (gc_map_comap f).monotone_l\n\n"}
{"name":"Subsemigroup.monotone_comap","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\n⊢ Monotone (Subsemigroup.comap f)","decl":"@[to_additive]\ntheorem monotone_comap {f : M →ₙ* N} : Monotone (comap f) :=\n  (gc_map_comap f).monotone_u\n\n"}
{"name":"AddSubsemigroup.monotone_comap","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\n⊢ Monotone (AddSubsemigroup.comap f)","decl":"@[to_additive]\ntheorem monotone_comap {f : M →ₙ* N} : Monotone (comap f) :=\n  (gc_map_comap f).monotone_u\n\n"}
{"name":"AddSubsemigroup.map_comap_map","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nS : AddSubsemigroup M\nf : AddHom M N\n⊢ Eq (AddSubsemigroup.map f (AddSubsemigroup.comap f (AddSubsemigroup.map f S))) (AddSubsemigroup.map f S)","decl":"@[to_additive (attr := simp)]\ntheorem map_comap_map {f : M →ₙ* N} : ((S.map f).comap f).map f = S.map f :=\n  (gc_map_comap f).l_u_l_eq_l _\n\n"}
{"name":"Subsemigroup.map_comap_map","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nS : Subsemigroup M\nf : MulHom M N\n⊢ Eq (Subsemigroup.map f (Subsemigroup.comap f (Subsemigroup.map f S))) (Subsemigroup.map f S)","decl":"@[to_additive (attr := simp)]\ntheorem map_comap_map {f : M →ₙ* N} : ((S.map f).comap f).map f = S.map f :=\n  (gc_map_comap f).l_u_l_eq_l _\n\n"}
{"name":"AddSubsemigroup.comap_map_comap","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nS : AddSubsemigroup N\nf : AddHom M N\n⊢ Eq (AddSubsemigroup.comap f (AddSubsemigroup.map f (AddSubsemigroup.comap f S))) (AddSubsemigroup.comap f S)","decl":"@[to_additive (attr := simp)]\ntheorem comap_map_comap {S : Subsemigroup N} {f : M →ₙ* N} :\n    ((S.comap f).map f).comap f = S.comap f :=\n  (gc_map_comap f).u_l_u_eq_u _\n\n"}
{"name":"Subsemigroup.comap_map_comap","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nS : Subsemigroup N\nf : MulHom M N\n⊢ Eq (Subsemigroup.comap f (Subsemigroup.map f (Subsemigroup.comap f S))) (Subsemigroup.comap f S)","decl":"@[to_additive (attr := simp)]\ntheorem comap_map_comap {S : Subsemigroup N} {f : M →ₙ* N} :\n    ((S.comap f).map f).comap f = S.comap f :=\n  (gc_map_comap f).u_l_u_eq_u _\n\n"}
{"name":"AddSubsemigroup.map_sup","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nS T : AddSubsemigroup M\nf : AddHom M N\n⊢ Eq (AddSubsemigroup.map f (Max.max S T)) (Max.max (AddSubsemigroup.map f S) (AddSubsemigroup.map f T))","decl":"@[to_additive]\ntheorem map_sup (S T : Subsemigroup M) (f : M →ₙ* N) : (S ⊔ T).map f = S.map f ⊔ T.map f :=\n  (gc_map_comap f).l_sup\n\n"}
{"name":"Subsemigroup.map_sup","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nS T : Subsemigroup M\nf : MulHom M N\n⊢ Eq (Subsemigroup.map f (Max.max S T)) (Max.max (Subsemigroup.map f S) (Subsemigroup.map f T))","decl":"@[to_additive]\ntheorem map_sup (S T : Subsemigroup M) (f : M →ₙ* N) : (S ⊔ T).map f = S.map f ⊔ T.map f :=\n  (gc_map_comap f).l_sup\n\n"}
{"name":"Subsemigroup.map_iSup","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nι : Sort u_5\nf : MulHom M N\ns : ι → Subsemigroup M\n⊢ Eq (Subsemigroup.map f (iSup s)) (iSup fun i => Subsemigroup.map f (s i))","decl":"@[to_additive]\ntheorem map_iSup {ι : Sort*} (f : M →ₙ* N) (s : ι → Subsemigroup M) :\n    (iSup s).map f = ⨆ i, (s i).map f :=\n  (gc_map_comap f).l_iSup\n\n"}
{"name":"AddSubsemigroup.map_iSup","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nι : Sort u_5\nf : AddHom M N\ns : ι → AddSubsemigroup M\n⊢ Eq (AddSubsemigroup.map f (iSup s)) (iSup fun i => AddSubsemigroup.map f (s i))","decl":"@[to_additive]\ntheorem map_iSup {ι : Sort*} (f : M →ₙ* N) (s : ι → Subsemigroup M) :\n    (iSup s).map f = ⨆ i, (s i).map f :=\n  (gc_map_comap f).l_iSup\n\n"}
{"name":"Subsemigroup.map_inf","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nS T : Subsemigroup M\nf : MulHom M N\nhf : Function.Injective ⇑f\n⊢ Eq (Subsemigroup.map f (Min.min S T)) (Min.min (Subsemigroup.map f S) (Subsemigroup.map f T))","decl":"@[to_additive]\ntheorem map_inf (S T : Subsemigroup M) (f : M →ₙ* N) (hf : Function.Injective f) :\n    (S ⊓ T).map f = S.map f ⊓ T.map f := SetLike.coe_injective (Set.image_inter hf)\n\n"}
{"name":"AddSubsemigroup.map_inf","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nS T : AddSubsemigroup M\nf : AddHom M N\nhf : Function.Injective ⇑f\n⊢ Eq (AddSubsemigroup.map f (Min.min S T)) (Min.min (AddSubsemigroup.map f S) (AddSubsemigroup.map f T))","decl":"@[to_additive]\ntheorem map_inf (S T : Subsemigroup M) (f : M →ₙ* N) (hf : Function.Injective f) :\n    (S ⊓ T).map f = S.map f ⊓ T.map f := SetLike.coe_injective (Set.image_inter hf)\n\n"}
{"name":"AddSubsemigroup.map_iInf","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : Add M\ninst✝¹ : Add N\nι : Sort u_5\ninst✝ : Nonempty ι\nf : AddHom M N\nhf : Function.Injective ⇑f\ns : ι → AddSubsemigroup M\n⊢ Eq (AddSubsemigroup.map f (iInf s)) (iInf fun i => AddSubsemigroup.map f (s i))","decl":"@[to_additive]\ntheorem map_iInf {ι : Sort*} [Nonempty ι] (f : M →ₙ* N) (hf : Function.Injective f)\n    (s : ι → Subsemigroup M) : (iInf s).map f = ⨅ i, (s i).map f := by\n  apply SetLike.coe_injective\n  simpa using (Set.injOn_of_injective hf).image_iInter_eq (s := SetLike.coe ∘ s)\n\n"}
{"name":"Subsemigroup.map_iInf","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : Mul M\ninst✝¹ : Mul N\nι : Sort u_5\ninst✝ : Nonempty ι\nf : MulHom M N\nhf : Function.Injective ⇑f\ns : ι → Subsemigroup M\n⊢ Eq (Subsemigroup.map f (iInf s)) (iInf fun i => Subsemigroup.map f (s i))","decl":"@[to_additive]\ntheorem map_iInf {ι : Sort*} [Nonempty ι] (f : M →ₙ* N) (hf : Function.Injective f)\n    (s : ι → Subsemigroup M) : (iInf s).map f = ⨅ i, (s i).map f := by\n  apply SetLike.coe_injective\n  simpa using (Set.injOn_of_injective hf).image_iInter_eq (s := SetLike.coe ∘ s)\n\n"}
{"name":"Subsemigroup.comap_inf","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nS T : Subsemigroup N\nf : MulHom M N\n⊢ Eq (Subsemigroup.comap f (Min.min S T)) (Min.min (Subsemigroup.comap f S) (Subsemigroup.comap f T))","decl":"@[to_additive]\ntheorem comap_inf (S T : Subsemigroup N) (f : M →ₙ* N) : (S ⊓ T).comap f = S.comap f ⊓ T.comap f :=\n  (gc_map_comap f).u_inf\n\n"}
{"name":"AddSubsemigroup.comap_inf","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nS T : AddSubsemigroup N\nf : AddHom M N\n⊢ Eq (AddSubsemigroup.comap f (Min.min S T)) (Min.min (AddSubsemigroup.comap f S) (AddSubsemigroup.comap f T))","decl":"@[to_additive]\ntheorem comap_inf (S T : Subsemigroup N) (f : M →ₙ* N) : (S ⊓ T).comap f = S.comap f ⊓ T.comap f :=\n  (gc_map_comap f).u_inf\n\n"}
{"name":"Subsemigroup.comap_iInf","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nι : Sort u_5\nf : MulHom M N\ns : ι → Subsemigroup N\n⊢ Eq (Subsemigroup.comap f (iInf s)) (iInf fun i => Subsemigroup.comap f (s i))","decl":"@[to_additive]\ntheorem comap_iInf {ι : Sort*} (f : M →ₙ* N) (s : ι → Subsemigroup N) :\n    (iInf s).comap f = ⨅ i, (s i).comap f :=\n  (gc_map_comap f).u_iInf\n\n"}
{"name":"AddSubsemigroup.comap_iInf","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nι : Sort u_5\nf : AddHom M N\ns : ι → AddSubsemigroup N\n⊢ Eq (AddSubsemigroup.comap f (iInf s)) (iInf fun i => AddSubsemigroup.comap f (s i))","decl":"@[to_additive]\ntheorem comap_iInf {ι : Sort*} (f : M →ₙ* N) (s : ι → Subsemigroup N) :\n    (iInf s).comap f = ⨅ i, (s i).comap f :=\n  (gc_map_comap f).u_iInf\n\n"}
{"name":"AddSubsemigroup.map_bot","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\n⊢ Eq (AddSubsemigroup.map f Bot.bot) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem map_bot (f : M →ₙ* N) : (⊥ : Subsemigroup M).map f = ⊥ :=\n  (gc_map_comap f).l_bot\n\n"}
{"name":"Subsemigroup.map_bot","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\n⊢ Eq (Subsemigroup.map f Bot.bot) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem map_bot (f : M →ₙ* N) : (⊥ : Subsemigroup M).map f = ⊥ :=\n  (gc_map_comap f).l_bot\n\n"}
{"name":"AddSubsemigroup.comap_top","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\n⊢ Eq (AddSubsemigroup.comap f Top.top) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem comap_top (f : M →ₙ* N) : (⊤ : Subsemigroup N).comap f = ⊤ :=\n  (gc_map_comap f).u_top\n\n"}
{"name":"Subsemigroup.comap_top","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\n⊢ Eq (Subsemigroup.comap f Top.top) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem comap_top (f : M →ₙ* N) : (⊤ : Subsemigroup N).comap f = ⊤ :=\n  (gc_map_comap f).u_top\n\n"}
{"name":"AddSubsemigroup.map_id","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\ninst✝ : Add M\nS : AddSubsemigroup M\n⊢ Eq (AddSubsemigroup.map (AddHom.id M) S) S","decl":"@[to_additive (attr := simp)]\ntheorem map_id (S : Subsemigroup M) : S.map (MulHom.id M) = S :=\n  ext fun _ => ⟨fun ⟨_, h, rfl⟩ => h, fun h => ⟨_, h, rfl⟩⟩\n\n"}
{"name":"Subsemigroup.map_id","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\ninst✝ : Mul M\nS : Subsemigroup M\n⊢ Eq (Subsemigroup.map (MulHom.id M) S) S","decl":"@[to_additive (attr := simp)]\ntheorem map_id (S : Subsemigroup M) : S.map (MulHom.id M) = S :=\n  ext fun _ => ⟨fun ⟨_, h, rfl⟩ => h, fun h => ⟨_, h, rfl⟩⟩\n\n"}
{"name":"Subsemigroup.comap_map_eq_of_injective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\nhf : Function.Injective ⇑f\nS : Subsemigroup M\n⊢ Eq (Subsemigroup.comap f (Subsemigroup.map f S)) S","decl":"@[to_additive]\ntheorem comap_map_eq_of_injective (S : Subsemigroup M) : (S.map f).comap f = S :=\n  (gciMapComap hf).u_l_eq _\n\n"}
{"name":"AddSubsemigroup.comap_map_eq_of_injective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\nhf : Function.Injective ⇑f\nS : AddSubsemigroup M\n⊢ Eq (AddSubsemigroup.comap f (AddSubsemigroup.map f S)) S","decl":"@[to_additive]\ntheorem comap_map_eq_of_injective (S : Subsemigroup M) : (S.map f).comap f = S :=\n  (gciMapComap hf).u_l_eq _\n\n"}
{"name":"AddSubsemigroup.comap_surjective_of_injective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\nhf : Function.Injective ⇑f\n⊢ Function.Surjective (AddSubsemigroup.comap f)","decl":"@[to_additive]\ntheorem comap_surjective_of_injective : Function.Surjective (comap f) :=\n  (gciMapComap hf).u_surjective\n\n"}
{"name":"Subsemigroup.comap_surjective_of_injective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\nhf : Function.Injective ⇑f\n⊢ Function.Surjective (Subsemigroup.comap f)","decl":"@[to_additive]\ntheorem comap_surjective_of_injective : Function.Surjective (comap f) :=\n  (gciMapComap hf).u_surjective\n\n"}
{"name":"AddSubsemigroup.map_injective_of_injective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\nhf : Function.Injective ⇑f\n⊢ Function.Injective (AddSubsemigroup.map f)","decl":"@[to_additive]\ntheorem map_injective_of_injective : Function.Injective (map f) :=\n  (gciMapComap hf).l_injective\n\n"}
{"name":"Subsemigroup.map_injective_of_injective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\nhf : Function.Injective ⇑f\n⊢ Function.Injective (Subsemigroup.map f)","decl":"@[to_additive]\ntheorem map_injective_of_injective : Function.Injective (map f) :=\n  (gciMapComap hf).l_injective\n\n"}
{"name":"Subsemigroup.comap_inf_map_of_injective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\nhf : Function.Injective ⇑f\nS T : Subsemigroup M\n⊢ Eq (Subsemigroup.comap f (Min.min (Subsemigroup.map f S) (Subsemigroup.map f T))) (Min.min S T)","decl":"@[to_additive]\ntheorem comap_inf_map_of_injective (S T : Subsemigroup M) : (S.map f ⊓ T.map f).comap f = S ⊓ T :=\n  (gciMapComap hf).u_inf_l _ _\n\n"}
{"name":"AddSubsemigroup.comap_inf_map_of_injective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\nhf : Function.Injective ⇑f\nS T : AddSubsemigroup M\n⊢ Eq (AddSubsemigroup.comap f (Min.min (AddSubsemigroup.map f S) (AddSubsemigroup.map f T))) (Min.min S T)","decl":"@[to_additive]\ntheorem comap_inf_map_of_injective (S T : Subsemigroup M) : (S.map f ⊓ T.map f).comap f = S ⊓ T :=\n  (gciMapComap hf).u_inf_l _ _\n\n"}
{"name":"Subsemigroup.comap_iInf_map_of_injective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nι : Type u_5\nf : MulHom M N\nhf : Function.Injective ⇑f\nS : ι → Subsemigroup M\n⊢ Eq (Subsemigroup.comap f (iInf fun i => Subsemigroup.map f (S i))) (iInf S)","decl":"@[to_additive]\ntheorem comap_iInf_map_of_injective (S : ι → Subsemigroup M) :\n    (⨅ i, (S i).map f).comap f = iInf S :=\n  (gciMapComap hf).u_iInf_l _\n\n"}
{"name":"AddSubsemigroup.comap_iInf_map_of_injective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nι : Type u_5\nf : AddHom M N\nhf : Function.Injective ⇑f\nS : ι → AddSubsemigroup M\n⊢ Eq (AddSubsemigroup.comap f (iInf fun i => AddSubsemigroup.map f (S i))) (iInf S)","decl":"@[to_additive]\ntheorem comap_iInf_map_of_injective (S : ι → Subsemigroup M) :\n    (⨅ i, (S i).map f).comap f = iInf S :=\n  (gciMapComap hf).u_iInf_l _\n\n"}
{"name":"AddSubsemigroup.comap_sup_map_of_injective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\nhf : Function.Injective ⇑f\nS T : AddSubsemigroup M\n⊢ Eq (AddSubsemigroup.comap f (Max.max (AddSubsemigroup.map f S) (AddSubsemigroup.map f T))) (Max.max S T)","decl":"@[to_additive]\ntheorem comap_sup_map_of_injective (S T : Subsemigroup M) : (S.map f ⊔ T.map f).comap f = S ⊔ T :=\n  (gciMapComap hf).u_sup_l _ _\n\n"}
{"name":"Subsemigroup.comap_sup_map_of_injective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\nhf : Function.Injective ⇑f\nS T : Subsemigroup M\n⊢ Eq (Subsemigroup.comap f (Max.max (Subsemigroup.map f S) (Subsemigroup.map f T))) (Max.max S T)","decl":"@[to_additive]\ntheorem comap_sup_map_of_injective (S T : Subsemigroup M) : (S.map f ⊔ T.map f).comap f = S ⊔ T :=\n  (gciMapComap hf).u_sup_l _ _\n\n"}
{"name":"Subsemigroup.comap_iSup_map_of_injective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nι : Type u_5\nf : MulHom M N\nhf : Function.Injective ⇑f\nS : ι → Subsemigroup M\n⊢ Eq (Subsemigroup.comap f (iSup fun i => Subsemigroup.map f (S i))) (iSup S)","decl":"@[to_additive]\ntheorem comap_iSup_map_of_injective (S : ι → Subsemigroup M) :\n    (⨆ i, (S i).map f).comap f = iSup S :=\n  (gciMapComap hf).u_iSup_l _\n\n"}
{"name":"AddSubsemigroup.comap_iSup_map_of_injective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nι : Type u_5\nf : AddHom M N\nhf : Function.Injective ⇑f\nS : ι → AddSubsemigroup M\n⊢ Eq (AddSubsemigroup.comap f (iSup fun i => AddSubsemigroup.map f (S i))) (iSup S)","decl":"@[to_additive]\ntheorem comap_iSup_map_of_injective (S : ι → Subsemigroup M) :\n    (⨆ i, (S i).map f).comap f = iSup S :=\n  (gciMapComap hf).u_iSup_l _\n\n"}
{"name":"AddSubsemigroup.map_le_map_iff_of_injective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\nhf : Function.Injective ⇑f\nS T : AddSubsemigroup M\n⊢ Iff (LE.le (AddSubsemigroup.map f S) (AddSubsemigroup.map f T)) (LE.le S T)","decl":"@[to_additive]\ntheorem map_le_map_iff_of_injective {S T : Subsemigroup M} : S.map f ≤ T.map f ↔ S ≤ T :=\n  (gciMapComap hf).l_le_l_iff\n\n"}
{"name":"Subsemigroup.map_le_map_iff_of_injective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\nhf : Function.Injective ⇑f\nS T : Subsemigroup M\n⊢ Iff (LE.le (Subsemigroup.map f S) (Subsemigroup.map f T)) (LE.le S T)","decl":"@[to_additive]\ntheorem map_le_map_iff_of_injective {S T : Subsemigroup M} : S.map f ≤ T.map f ↔ S ≤ T :=\n  (gciMapComap hf).l_le_l_iff\n\n"}
{"name":"Subsemigroup.map_strictMono_of_injective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\nhf : Function.Injective ⇑f\n⊢ StrictMono (Subsemigroup.map f)","decl":"@[to_additive]\ntheorem map_strictMono_of_injective : StrictMono (map f) :=\n  (gciMapComap hf).strictMono_l\n\n"}
{"name":"AddSubsemigroup.map_strictMono_of_injective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\nhf : Function.Injective ⇑f\n⊢ StrictMono (AddSubsemigroup.map f)","decl":"@[to_additive]\ntheorem map_strictMono_of_injective : StrictMono (map f) :=\n  (gciMapComap hf).strictMono_l\n\n"}
{"name":"Subsemigroup.map_comap_eq_of_surjective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\nhf : Function.Surjective ⇑f\nS : Subsemigroup N\n⊢ Eq (Subsemigroup.map f (Subsemigroup.comap f S)) S","decl":"@[to_additive]\ntheorem map_comap_eq_of_surjective (S : Subsemigroup N) : (S.comap f).map f = S :=\n  (giMapComap hf).l_u_eq _\n\n"}
{"name":"AddSubsemigroup.map_comap_eq_of_surjective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\nhf : Function.Surjective ⇑f\nS : AddSubsemigroup N\n⊢ Eq (AddSubsemigroup.map f (AddSubsemigroup.comap f S)) S","decl":"@[to_additive]\ntheorem map_comap_eq_of_surjective (S : Subsemigroup N) : (S.comap f).map f = S :=\n  (giMapComap hf).l_u_eq _\n\n"}
{"name":"Subsemigroup.map_surjective_of_surjective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\nhf : Function.Surjective ⇑f\n⊢ Function.Surjective (Subsemigroup.map f)","decl":"@[to_additive]\ntheorem map_surjective_of_surjective : Function.Surjective (map f) :=\n  (giMapComap hf).l_surjective\n\n"}
{"name":"AddSubsemigroup.map_surjective_of_surjective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\nhf : Function.Surjective ⇑f\n⊢ Function.Surjective (AddSubsemigroup.map f)","decl":"@[to_additive]\ntheorem map_surjective_of_surjective : Function.Surjective (map f) :=\n  (giMapComap hf).l_surjective\n\n"}
{"name":"AddSubsemigroup.comap_injective_of_surjective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\nhf : Function.Surjective ⇑f\n⊢ Function.Injective (AddSubsemigroup.comap f)","decl":"@[to_additive]\ntheorem comap_injective_of_surjective : Function.Injective (comap f) :=\n  (giMapComap hf).u_injective\n\n"}
{"name":"Subsemigroup.comap_injective_of_surjective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\nhf : Function.Surjective ⇑f\n⊢ Function.Injective (Subsemigroup.comap f)","decl":"@[to_additive]\ntheorem comap_injective_of_surjective : Function.Injective (comap f) :=\n  (giMapComap hf).u_injective\n\n"}
{"name":"Subsemigroup.map_inf_comap_of_surjective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\nhf : Function.Surjective ⇑f\nS T : Subsemigroup N\n⊢ Eq (Subsemigroup.map f (Min.min (Subsemigroup.comap f S) (Subsemigroup.comap f T))) (Min.min S T)","decl":"@[to_additive]\ntheorem map_inf_comap_of_surjective (S T : Subsemigroup N) :\n    (S.comap f ⊓ T.comap f).map f = S ⊓ T :=\n  (giMapComap hf).l_inf_u _ _\n\n"}
{"name":"AddSubsemigroup.map_inf_comap_of_surjective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\nhf : Function.Surjective ⇑f\nS T : AddSubsemigroup N\n⊢ Eq (AddSubsemigroup.map f (Min.min (AddSubsemigroup.comap f S) (AddSubsemigroup.comap f T))) (Min.min S T)","decl":"@[to_additive]\ntheorem map_inf_comap_of_surjective (S T : Subsemigroup N) :\n    (S.comap f ⊓ T.comap f).map f = S ⊓ T :=\n  (giMapComap hf).l_inf_u _ _\n\n"}
{"name":"AddSubsemigroup.map_iInf_comap_of_surjective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nι : Type u_5\nf : AddHom M N\nhf : Function.Surjective ⇑f\nS : ι → AddSubsemigroup N\n⊢ Eq (AddSubsemigroup.map f (iInf fun i => AddSubsemigroup.comap f (S i))) (iInf S)","decl":"@[to_additive]\ntheorem map_iInf_comap_of_surjective (S : ι → Subsemigroup N) :\n    (⨅ i, (S i).comap f).map f = iInf S :=\n  (giMapComap hf).l_iInf_u _\n\n"}
{"name":"Subsemigroup.map_iInf_comap_of_surjective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nι : Type u_5\nf : MulHom M N\nhf : Function.Surjective ⇑f\nS : ι → Subsemigroup N\n⊢ Eq (Subsemigroup.map f (iInf fun i => Subsemigroup.comap f (S i))) (iInf S)","decl":"@[to_additive]\ntheorem map_iInf_comap_of_surjective (S : ι → Subsemigroup N) :\n    (⨅ i, (S i).comap f).map f = iInf S :=\n  (giMapComap hf).l_iInf_u _\n\n"}
{"name":"AddSubsemigroup.map_sup_comap_of_surjective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\nhf : Function.Surjective ⇑f\nS T : AddSubsemigroup N\n⊢ Eq (AddSubsemigroup.map f (Max.max (AddSubsemigroup.comap f S) (AddSubsemigroup.comap f T))) (Max.max S T)","decl":"@[to_additive]\ntheorem map_sup_comap_of_surjective (S T : Subsemigroup N) :\n    (S.comap f ⊔ T.comap f).map f = S ⊔ T :=\n  (giMapComap hf).l_sup_u _ _\n\n"}
{"name":"Subsemigroup.map_sup_comap_of_surjective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\nhf : Function.Surjective ⇑f\nS T : Subsemigroup N\n⊢ Eq (Subsemigroup.map f (Max.max (Subsemigroup.comap f S) (Subsemigroup.comap f T))) (Max.max S T)","decl":"@[to_additive]\ntheorem map_sup_comap_of_surjective (S T : Subsemigroup N) :\n    (S.comap f ⊔ T.comap f).map f = S ⊔ T :=\n  (giMapComap hf).l_sup_u _ _\n\n"}
{"name":"Subsemigroup.map_iSup_comap_of_surjective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nι : Type u_5\nf : MulHom M N\nhf : Function.Surjective ⇑f\nS : ι → Subsemigroup N\n⊢ Eq (Subsemigroup.map f (iSup fun i => Subsemigroup.comap f (S i))) (iSup S)","decl":"@[to_additive]\ntheorem map_iSup_comap_of_surjective (S : ι → Subsemigroup N) :\n    (⨆ i, (S i).comap f).map f = iSup S :=\n  (giMapComap hf).l_iSup_u _\n\n"}
{"name":"AddSubsemigroup.map_iSup_comap_of_surjective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nι : Type u_5\nf : AddHom M N\nhf : Function.Surjective ⇑f\nS : ι → AddSubsemigroup N\n⊢ Eq (AddSubsemigroup.map f (iSup fun i => AddSubsemigroup.comap f (S i))) (iSup S)","decl":"@[to_additive]\ntheorem map_iSup_comap_of_surjective (S : ι → Subsemigroup N) :\n    (⨆ i, (S i).comap f).map f = iSup S :=\n  (giMapComap hf).l_iSup_u _\n\n"}
{"name":"Subsemigroup.comap_le_comap_iff_of_surjective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\nhf : Function.Surjective ⇑f\nS T : Subsemigroup N\n⊢ Iff (LE.le (Subsemigroup.comap f S) (Subsemigroup.comap f T)) (LE.le S T)","decl":"@[to_additive]\ntheorem comap_le_comap_iff_of_surjective {S T : Subsemigroup N} : S.comap f ≤ T.comap f ↔ S ≤ T :=\n  (giMapComap hf).u_le_u_iff\n\n"}
{"name":"AddSubsemigroup.comap_le_comap_iff_of_surjective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\nhf : Function.Surjective ⇑f\nS T : AddSubsemigroup N\n⊢ Iff (LE.le (AddSubsemigroup.comap f S) (AddSubsemigroup.comap f T)) (LE.le S T)","decl":"@[to_additive]\ntheorem comap_le_comap_iff_of_surjective {S T : Subsemigroup N} : S.comap f ≤ T.comap f ↔ S ≤ T :=\n  (giMapComap hf).u_le_u_iff\n\n"}
{"name":"Subsemigroup.comap_strictMono_of_surjective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\nhf : Function.Surjective ⇑f\n⊢ StrictMono (Subsemigroup.comap f)","decl":"@[to_additive]\ntheorem comap_strictMono_of_surjective : StrictMono (comap f) :=\n  (giMapComap hf).strictMono_u\n\n"}
{"name":"AddSubsemigroup.comap_strictMono_of_surjective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\nhf : Function.Surjective ⇑f\n⊢ StrictMono (AddSubsemigroup.comap f)","decl":"@[to_additive]\ntheorem comap_strictMono_of_surjective : StrictMono (comap f) :=\n  (giMapComap hf).strictMono_u\n\n"}
{"name":"AddSubsemigroup.topEquiv_symm_apply_coe","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\ninst✝ : Add M\nx : M\n⊢ Eq (↑(AddSubsemigroup.topEquiv.symm x)) x","decl":"/-- The top subsemigroup is isomorphic to the semigroup. -/\n@[to_additive (attr := simps)\n  \"The top additive subsemigroup is isomorphic to the additive semigroup.\"]\ndef topEquiv : (⊤ : Subsemigroup M) ≃* M where\n  toFun x := x\n  invFun x := ⟨x, mem_top x⟩\n  left_inv x := x.eta _\n  right_inv _ := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"Subsemigroup.topEquiv_apply","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\ninst✝ : Mul M\nx : Subtype fun x => Membership.mem Top.top x\n⊢ Eq (Subsemigroup.topEquiv x) ↑x","decl":"/-- The top subsemigroup is isomorphic to the semigroup. -/\n@[to_additive (attr := simps)\n  \"The top additive subsemigroup is isomorphic to the additive semigroup.\"]\ndef topEquiv : (⊤ : Subsemigroup M) ≃* M where\n  toFun x := x\n  invFun x := ⟨x, mem_top x⟩\n  left_inv x := x.eta _\n  right_inv _ := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"Subsemigroup.topEquiv_symm_apply_coe","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\ninst✝ : Mul M\nx : M\n⊢ Eq (↑(Subsemigroup.topEquiv.symm x)) x","decl":"/-- The top subsemigroup is isomorphic to the semigroup. -/\n@[to_additive (attr := simps)\n  \"The top additive subsemigroup is isomorphic to the additive semigroup.\"]\ndef topEquiv : (⊤ : Subsemigroup M) ≃* M where\n  toFun x := x\n  invFun x := ⟨x, mem_top x⟩\n  left_inv x := x.eta _\n  right_inv _ := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"AddSubsemigroup.topEquiv_apply","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\ninst✝ : Add M\nx : Subtype fun x => Membership.mem Top.top x\n⊢ Eq (AddSubsemigroup.topEquiv x) ↑x","decl":"/-- The top subsemigroup is isomorphic to the semigroup. -/\n@[to_additive (attr := simps)\n  \"The top additive subsemigroup is isomorphic to the additive semigroup.\"]\ndef topEquiv : (⊤ : Subsemigroup M) ≃* M where\n  toFun x := x\n  invFun x := ⟨x, mem_top x⟩\n  left_inv x := x.eta _\n  right_inv _ := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"AddSubsemigroup.topEquiv_toAddHom","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\ninst✝ : Add M\n⊢ Eq (↑AddSubsemigroup.topEquiv) (AddMemClass.subtype Top.top)","decl":"@[to_additive (attr := simp)]\ntheorem topEquiv_toMulHom :\n    ((topEquiv : _ ≃* M) : _ →ₙ* M) = MulMemClass.subtype (⊤ : Subsemigroup M) :=\n  rfl\n\n"}
{"name":"Subsemigroup.topEquiv_toMulHom","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\ninst✝ : Mul M\n⊢ Eq (↑Subsemigroup.topEquiv) (MulMemClass.subtype Top.top)","decl":"@[to_additive (attr := simp)]\ntheorem topEquiv_toMulHom :\n    ((topEquiv : _ ≃* M) : _ →ₙ* M) = MulMemClass.subtype (⊤ : Subsemigroup M) :=\n  rfl\n\n"}
{"name":"AddSubsemigroup.coe_equivMapOfInjective_apply","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nS : AddSubsemigroup M\nf : AddHom M N\nhf : Function.Injective ⇑f\nx : Subtype fun x => Membership.mem S x\n⊢ Eq (↑((S.equivMapOfInjective f hf) x)) (f ↑x)","decl":"@[to_additive (attr := simp)]\ntheorem coe_equivMapOfInjective_apply (f : M →ₙ* N) (hf : Function.Injective f) (x : S) :\n    (equivMapOfInjective S f hf x : N) = f x :=\n  rfl\n\n"}
{"name":"Subsemigroup.coe_equivMapOfInjective_apply","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nS : Subsemigroup M\nf : MulHom M N\nhf : Function.Injective ⇑f\nx : Subtype fun x => Membership.mem S x\n⊢ Eq (↑((S.equivMapOfInjective f hf) x)) (f ↑x)","decl":"@[to_additive (attr := simp)]\ntheorem coe_equivMapOfInjective_apply (f : M →ₙ* N) (hf : Function.Injective f) (x : S) :\n    (equivMapOfInjective S f hf x : N) = f x :=\n  rfl\n\n"}
{"name":"Subsemigroup.closure_closure_coe_preimage","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\ninst✝ : Mul M\ns : Set M\n⊢ Eq (Subsemigroup.closure (Set.preimage Subtype.val s)) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem closure_closure_coe_preimage {s : Set M} :\n    closure ((Subtype.val : closure s → M) ⁻¹' s) = ⊤ :=\n  eq_top_iff.2 fun x _ ↦ Subtype.recOn x fun _ hx' ↦\n    closure_induction (fun _ h ↦ subset_closure h) (fun _ _ _ _ ↦ mul_mem) hx'\n\n"}
{"name":"AddSubsemigroup.closure_closure_coe_preimage","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\ninst✝ : Add M\ns : Set M\n⊢ Eq (AddSubsemigroup.closure (Set.preimage Subtype.val s)) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem closure_closure_coe_preimage {s : Set M} :\n    closure ((Subtype.val : closure s → M) ⁻¹' s) = ⊤ :=\n  eq_top_iff.2 fun x _ ↦ Subtype.recOn x fun _ hx' ↦\n    closure_induction (fun _ h ↦ subset_closure h) (fun _ _ _ _ ↦ mul_mem) hx'\n\n"}
{"name":"AddSubsemigroup.coe_prod","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\ns : AddSubsemigroup M\nt : AddSubsemigroup N\n⊢ Eq (↑(s.prod t)) (SProd.sprod ↑s ↑t)","decl":"@[to_additive coe_prod]\ntheorem coe_prod (s : Subsemigroup M) (t : Subsemigroup N) :\n    (s.prod t : Set (M × N)) = (s : Set M) ×ˢ (t : Set N) :=\n  rfl\n\n"}
{"name":"Subsemigroup.coe_prod","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\ns : Subsemigroup M\nt : Subsemigroup N\n⊢ Eq (↑(s.prod t)) (SProd.sprod ↑s ↑t)","decl":"@[to_additive coe_prod]\ntheorem coe_prod (s : Subsemigroup M) (t : Subsemigroup N) :\n    (s.prod t : Set (M × N)) = (s : Set M) ×ˢ (t : Set N) :=\n  rfl\n\n"}
{"name":"AddSubsemigroup.mem_prod","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\ns : AddSubsemigroup M\nt : AddSubsemigroup N\np : Prod M N\n⊢ Iff (Membership.mem (s.prod t) p) (And (Membership.mem s p.1) (Membership.mem t p.2))","decl":"@[to_additive mem_prod]\ntheorem mem_prod {s : Subsemigroup M} {t : Subsemigroup N} {p : M × N} :\n    p ∈ s.prod t ↔ p.1 ∈ s ∧ p.2 ∈ t :=\n  Iff.rfl\n\n"}
{"name":"Subsemigroup.mem_prod","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\ns : Subsemigroup M\nt : Subsemigroup N\np : Prod M N\n⊢ Iff (Membership.mem (s.prod t) p) (And (Membership.mem s p.1) (Membership.mem t p.2))","decl":"@[to_additive mem_prod]\ntheorem mem_prod {s : Subsemigroup M} {t : Subsemigroup N} {p : M × N} :\n    p ∈ s.prod t ↔ p.1 ∈ s ∧ p.2 ∈ t :=\n  Iff.rfl\n\n"}
{"name":"AddSubsemigroup.prod_mono","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\ns₁ s₂ : AddSubsemigroup M\nt₁ t₂ : AddSubsemigroup N\nhs : LE.le s₁ s₂\nht : LE.le t₁ t₂\n⊢ LE.le (s₁.prod t₁) (s₂.prod t₂)","decl":"@[to_additive prod_mono]\ntheorem prod_mono {s₁ s₂ : Subsemigroup M} {t₁ t₂ : Subsemigroup N} (hs : s₁ ≤ s₂) (ht : t₁ ≤ t₂) :\n    s₁.prod t₁ ≤ s₂.prod t₂ :=\n  Set.prod_mono hs ht\n\n"}
{"name":"Subsemigroup.prod_mono","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\ns₁ s₂ : Subsemigroup M\nt₁ t₂ : Subsemigroup N\nhs : LE.le s₁ s₂\nht : LE.le t₁ t₂\n⊢ LE.le (s₁.prod t₁) (s₂.prod t₂)","decl":"@[to_additive prod_mono]\ntheorem prod_mono {s₁ s₂ : Subsemigroup M} {t₁ t₂ : Subsemigroup N} (hs : s₁ ≤ s₂) (ht : t₁ ≤ t₂) :\n    s₁.prod t₁ ≤ s₂.prod t₂ :=\n  Set.prod_mono hs ht\n\n"}
{"name":"Subsemigroup.prod_top","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\ns : Subsemigroup M\n⊢ Eq (s.prod Top.top) (Subsemigroup.comap (MulHom.fst M N) s)","decl":"@[to_additive prod_top]\ntheorem prod_top (s : Subsemigroup M) : s.prod (⊤ : Subsemigroup N) = s.comap (MulHom.fst M N) :=\n  ext fun x => by simp [mem_prod, MulHom.coe_fst]\n\n"}
{"name":"AddSubsemigroup.prod_top","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\ns : AddSubsemigroup M\n⊢ Eq (s.prod Top.top) (AddSubsemigroup.comap (AddHom.fst M N) s)","decl":"@[to_additive prod_top]\ntheorem prod_top (s : Subsemigroup M) : s.prod (⊤ : Subsemigroup N) = s.comap (MulHom.fst M N) :=\n  ext fun x => by simp [mem_prod, MulHom.coe_fst]\n\n"}
{"name":"AddSubsemigroup.top_prod","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\ns : AddSubsemigroup N\n⊢ Eq (Top.top.prod s) (AddSubsemigroup.comap (AddHom.snd M N) s)","decl":"@[to_additive top_prod]\ntheorem top_prod (s : Subsemigroup N) : (⊤ : Subsemigroup M).prod s = s.comap (MulHom.snd M N) :=\n  ext fun x => by simp [mem_prod, MulHom.coe_snd]\n\n"}
{"name":"Subsemigroup.top_prod","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\ns : Subsemigroup N\n⊢ Eq (Top.top.prod s) (Subsemigroup.comap (MulHom.snd M N) s)","decl":"@[to_additive top_prod]\ntheorem top_prod (s : Subsemigroup N) : (⊤ : Subsemigroup M).prod s = s.comap (MulHom.snd M N) :=\n  ext fun x => by simp [mem_prod, MulHom.coe_snd]\n\n"}
{"name":"Subsemigroup.top_prod_top","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\n⊢ Eq (Top.top.prod Top.top) Top.top","decl":"@[to_additive (attr := simp) top_prod_top]\ntheorem top_prod_top : (⊤ : Subsemigroup M).prod (⊤ : Subsemigroup N) = ⊤ :=\n  (top_prod _).trans <| comap_top _\n\n"}
{"name":"AddSubsemigroup.top_prod_top","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\n⊢ Eq (Top.top.prod Top.top) Top.top","decl":"@[to_additive (attr := simp) top_prod_top]\ntheorem top_prod_top : (⊤ : Subsemigroup M).prod (⊤ : Subsemigroup N) = ⊤ :=\n  (top_prod _).trans <| comap_top _\n\n"}
{"name":"Subsemigroup.bot_prod_bot","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\n⊢ Eq (Bot.bot.prod Bot.bot) Bot.bot","decl":"@[to_additive bot_prod_bot]\ntheorem bot_prod_bot : (⊥ : Subsemigroup M).prod (⊥ : Subsemigroup N) = ⊥ :=\n  SetLike.coe_injective <| by simp [coe_prod]\n\n"}
{"name":"AddSubsemigroup.bot_prod_bot","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\n⊢ Eq (Bot.bot.prod Bot.bot) Bot.bot","decl":"@[to_additive bot_prod_bot]\ntheorem bot_prod_bot : (⊥ : Subsemigroup M).prod (⊥ : Subsemigroup N) = ⊥ :=\n  SetLike.coe_injective <| by simp [coe_prod]\n\n"}
{"name":"Subsemigroup.mem_map_equiv","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulEquiv M N\nK : Subsemigroup M\nx : N\n⊢ Iff (Membership.mem (Subsemigroup.map (↑f) K) x) (Membership.mem K (f.symm x))","decl":"@[to_additive]\ntheorem mem_map_equiv {f : M ≃* N} {K : Subsemigroup M} {x : N} :\n    x ∈ K.map (f : M →ₙ* N) ↔ f.symm x ∈ K :=\n  @Set.mem_image_equiv _ _ (K : Set M) f.toEquiv x\n\n"}
{"name":"AddSubsemigroup.mem_map_equiv","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddEquiv M N\nK : AddSubsemigroup M\nx : N\n⊢ Iff (Membership.mem (AddSubsemigroup.map (↑f) K) x) (Membership.mem K (f.symm x))","decl":"@[to_additive]\ntheorem mem_map_equiv {f : M ≃* N} {K : Subsemigroup M} {x : N} :\n    x ∈ K.map (f : M →ₙ* N) ↔ f.symm x ∈ K :=\n  @Set.mem_image_equiv _ _ (K : Set M) f.toEquiv x\n\n"}
{"name":"Subsemigroup.map_equiv_eq_comap_symm","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulEquiv M N\nK : Subsemigroup M\n⊢ Eq (Subsemigroup.map (↑f) K) (Subsemigroup.comap (↑f.symm) K)","decl":"@[to_additive]\ntheorem map_equiv_eq_comap_symm (f : M ≃* N) (K : Subsemigroup M) :\n    K.map (f : M →ₙ* N) = K.comap (f.symm : N →ₙ* M) :=\n  SetLike.coe_injective (f.toEquiv.image_eq_preimage K)\n\n"}
{"name":"AddSubsemigroup.map_equiv_eq_comap_symm","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddEquiv M N\nK : AddSubsemigroup M\n⊢ Eq (AddSubsemigroup.map (↑f) K) (AddSubsemigroup.comap (↑f.symm) K)","decl":"@[to_additive]\ntheorem map_equiv_eq_comap_symm (f : M ≃* N) (K : Subsemigroup M) :\n    K.map (f : M →ₙ* N) = K.comap (f.symm : N →ₙ* M) :=\n  SetLike.coe_injective (f.toEquiv.image_eq_preimage K)\n\n"}
{"name":"Subsemigroup.comap_equiv_eq_map_symm","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulEquiv N M\nK : Subsemigroup M\n⊢ Eq (Subsemigroup.comap (↑f) K) (Subsemigroup.map (↑f.symm) K)","decl":"@[to_additive]\ntheorem comap_equiv_eq_map_symm (f : N ≃* M) (K : Subsemigroup M) :\n    K.comap (f : N →ₙ* M) = K.map (f.symm : M →ₙ* N) :=\n  (map_equiv_eq_comap_symm f.symm K).symm\n\n"}
{"name":"AddSubsemigroup.comap_equiv_eq_map_symm","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddEquiv N M\nK : AddSubsemigroup M\n⊢ Eq (AddSubsemigroup.comap (↑f) K) (AddSubsemigroup.map (↑f.symm) K)","decl":"@[to_additive]\ntheorem comap_equiv_eq_map_symm (f : N ≃* M) (K : Subsemigroup M) :\n    K.comap (f : N →ₙ* M) = K.map (f.symm : M →ₙ* N) :=\n  (map_equiv_eq_comap_symm f.symm K).symm\n\n"}
{"name":"AddSubsemigroup.map_equiv_top","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddEquiv M N\n⊢ Eq (AddSubsemigroup.map (↑f) Top.top) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem map_equiv_top (f : M ≃* N) : (⊤ : Subsemigroup M).map (f : M →ₙ* N) = ⊤ :=\n  SetLike.coe_injective <| Set.image_univ.trans f.surjective.range_eq\n\n"}
{"name":"Subsemigroup.map_equiv_top","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulEquiv M N\n⊢ Eq (Subsemigroup.map (↑f) Top.top) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem map_equiv_top (f : M ≃* N) : (⊤ : Subsemigroup M).map (f : M →ₙ* N) = ⊤ :=\n  SetLike.coe_injective <| Set.image_univ.trans f.surjective.range_eq\n\n"}
{"name":"Subsemigroup.le_prod_iff","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\ns : Subsemigroup M\nt : Subsemigroup N\nu : Subsemigroup (Prod M N)\n⊢ Iff (LE.le u (s.prod t)) (And (LE.le (Subsemigroup.map (MulHom.fst M N) u) s) (LE.le (Subsemigroup.map (MulHom.snd M N) u) t))","decl":"@[to_additive le_prod_iff]\ntheorem le_prod_iff {s : Subsemigroup M} {t : Subsemigroup N} {u : Subsemigroup (M × N)} :\n    u ≤ s.prod t ↔ u.map (fst M N) ≤ s ∧ u.map (snd M N) ≤ t := by\n  constructor\n  · intro h\n    constructor\n    · rintro x ⟨⟨y1, y2⟩, ⟨hy1, rfl⟩⟩\n      exact (h hy1).1\n    · rintro x ⟨⟨y1, y2⟩, ⟨hy1, rfl⟩⟩\n      exact (h hy1).2\n  · rintro ⟨hH, hK⟩ ⟨x1, x2⟩ h\n    exact ⟨hH ⟨_, h, rfl⟩, hK ⟨_, h, rfl⟩⟩\n\n"}
{"name":"AddSubsemigroup.le_prod_iff","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\ns : AddSubsemigroup M\nt : AddSubsemigroup N\nu : AddSubsemigroup (Prod M N)\n⊢ Iff (LE.le u (s.prod t)) (And (LE.le (AddSubsemigroup.map (AddHom.fst M N) u) s) (LE.le (AddSubsemigroup.map (AddHom.snd M N) u) t))","decl":"@[to_additive le_prod_iff]\ntheorem le_prod_iff {s : Subsemigroup M} {t : Subsemigroup N} {u : Subsemigroup (M × N)} :\n    u ≤ s.prod t ↔ u.map (fst M N) ≤ s ∧ u.map (snd M N) ≤ t := by\n  constructor\n  · intro h\n    constructor\n    · rintro x ⟨⟨y1, y2⟩, ⟨hy1, rfl⟩⟩\n      exact (h hy1).1\n    · rintro x ⟨⟨y1, y2⟩, ⟨hy1, rfl⟩⟩\n      exact (h hy1).2\n  · rintro ⟨hH, hK⟩ ⟨x1, x2⟩ h\n    exact ⟨hH ⟨_, h, rfl⟩, hK ⟨_, h, rfl⟩⟩\n\n"}
{"name":"MulHom.coe_srange","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\n⊢ Eq (↑f.srange) (Set.range ⇑f)","decl":"@[to_additive (attr := simp)]\ntheorem coe_srange (f : M →ₙ* N) : (f.srange : Set N) = Set.range f :=\n  rfl\n\n"}
{"name":"AddHom.coe_srange","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\n⊢ Eq (↑f.srange) (Set.range ⇑f)","decl":"@[to_additive (attr := simp)]\ntheorem coe_srange (f : M →ₙ* N) : (f.srange : Set N) = Set.range f :=\n  rfl\n\n"}
{"name":"MulHom.mem_srange","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\ny : N\n⊢ Iff (Membership.mem f.srange y) (Exists fun x => Eq (f x) y)","decl":"@[to_additive (attr := simp)]\ntheorem mem_srange {f : M →ₙ* N} {y : N} : y ∈ f.srange ↔ ∃ x, f x = y :=\n  Iff.rfl\n\n"}
{"name":"AddHom.mem_srange","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\ny : N\n⊢ Iff (Membership.mem f.srange y) (Exists fun x => Eq (f x) y)","decl":"@[to_additive (attr := simp)]\ntheorem mem_srange {f : M →ₙ* N} {y : N} : y ∈ f.srange ↔ ∃ x, f x = y :=\n  Iff.rfl\n\n"}
{"name":"AddHom.srange_mk","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : M → N\nhf : ∀ (x y : M), Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))\n⊢ Eq { toFun := f, map_add' := hf }.srange { carrier := Set.range f, add_mem' := ⋯ }","decl":"@[to_additive (attr := simp)] theorem srange_mk (f : M → N) (hf) :\n    srange ⟨f, hf⟩ = ⟨Set.range f, srange_mk_aux_mul hf⟩ := rfl\n\n"}
{"name":"MulHom.srange_mk","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : M → N\nhf : ∀ (x y : M), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\n⊢ Eq { toFun := f, map_mul' := hf }.srange { carrier := Set.range f, mul_mem' := ⋯ }","decl":"@[to_additive (attr := simp)] theorem srange_mk (f : M → N) (hf) :\n    srange ⟨f, hf⟩ = ⟨Set.range f, srange_mk_aux_mul hf⟩ := rfl\n\n"}
{"name":"MulHom.srange_eq_map","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\n⊢ Eq f.srange (Subsemigroup.map f Top.top)","decl":"@[to_additive]\ntheorem srange_eq_map (f : M →ₙ* N) : f.srange = (⊤ : Subsemigroup M).map f :=\n  copy_eq _\n\n"}
{"name":"AddHom.srange_eq_map","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\n⊢ Eq f.srange (AddSubsemigroup.map f Top.top)","decl":"@[to_additive]\ntheorem srange_eq_map (f : M →ₙ* N) : f.srange = (⊤ : Subsemigroup M).map f :=\n  copy_eq _\n\n"}
{"name":"AddHom.map_srange","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : Add M\ninst✝¹ : Add N\ninst✝ : Add P\ng : AddHom N P\nf : AddHom M N\n⊢ Eq (AddSubsemigroup.map g f.srange) (g.comp f).srange","decl":"@[to_additive]\ntheorem map_srange (g : N →ₙ* P) (f : M →ₙ* N) : f.srange.map g = (g.comp f).srange := by\n  simpa only [srange_eq_map] using (⊤ : Subsemigroup M).map_map g f\n\n"}
{"name":"MulHom.map_srange","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : Mul M\ninst✝¹ : Mul N\ninst✝ : Mul P\ng : MulHom N P\nf : MulHom M N\n⊢ Eq (Subsemigroup.map g f.srange) (g.comp f).srange","decl":"@[to_additive]\ntheorem map_srange (g : N →ₙ* P) (f : M →ₙ* N) : f.srange.map g = (g.comp f).srange := by\n  simpa only [srange_eq_map] using (⊤ : Subsemigroup M).map_map g f\n\n"}
{"name":"AddHom.srange_eq_top_iff_surjective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\ninst✝¹ : Add M\nN : Type u_5\ninst✝ : Add N\nf : AddHom M N\n⊢ Iff (Eq f.srange Top.top) (Function.Surjective ⇑f)","decl":"@[to_additive]\ntheorem srange_eq_top_iff_surjective {N} [Mul N] {f : M →ₙ* N} :\n    f.srange = (⊤ : Subsemigroup N) ↔ Function.Surjective f :=\n  SetLike.ext'_iff.trans <| Iff.trans (by rw [coe_srange, coe_top]) Set.range_eq_univ\n\n"}
{"name":"MulHom.srange_eq_top_iff_surjective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\ninst✝¹ : Mul M\nN : Type u_5\ninst✝ : Mul N\nf : MulHom M N\n⊢ Iff (Eq f.srange Top.top) (Function.Surjective ⇑f)","decl":"@[to_additive]\ntheorem srange_eq_top_iff_surjective {N} [Mul N] {f : M →ₙ* N} :\n    f.srange = (⊤ : Subsemigroup N) ↔ Function.Surjective f :=\n  SetLike.ext'_iff.trans <| Iff.trans (by rw [coe_srange, coe_top]) Set.range_eq_univ\n\n"}
{"name":"MulHom.srange_top_iff_surjective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\ninst✝¹ : Mul M\nN : Type u_5\ninst✝ : Mul N\nf : MulHom M N\n⊢ Iff (Eq f.srange Top.top) (Function.Surjective ⇑f)","decl":"@[deprecated (since := \"2024-11-11\")]\nalias srange_top_iff_surjective := srange_eq_top_iff_surjective\n\n"}
{"name":"AddHom.srange_eq_top_of_surjective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\ninst✝¹ : Add M\nN : Type u_5\ninst✝ : Add N\nf : AddHom M N\nhf : Function.Surjective ⇑f\n⊢ Eq f.srange Top.top","decl":"/-- The range of a surjective semigroup hom is the whole of the codomain. -/\n@[to_additive (attr := simp)\n  \"The range of a surjective `AddSemigroup` hom is the whole of the codomain.\"]\ntheorem srange_eq_top_of_surjective {N} [Mul N] (f : M →ₙ* N) (hf : Function.Surjective f) :\n    f.srange = (⊤ : Subsemigroup N) :=\n  srange_eq_top_iff_surjective.2 hf\n\n"}
{"name":"MulHom.srange_eq_top_of_surjective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\ninst✝¹ : Mul M\nN : Type u_5\ninst✝ : Mul N\nf : MulHom M N\nhf : Function.Surjective ⇑f\n⊢ Eq f.srange Top.top","decl":"/-- The range of a surjective semigroup hom is the whole of the codomain. -/\n@[to_additive (attr := simp)\n  \"The range of a surjective `AddSemigroup` hom is the whole of the codomain.\"]\ntheorem srange_eq_top_of_surjective {N} [Mul N] (f : M →ₙ* N) (hf : Function.Surjective f) :\n    f.srange = (⊤ : Subsemigroup N) :=\n  srange_eq_top_iff_surjective.2 hf\n\n"}
{"name":"MulHom.srange_top_of_surjective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\ninst✝¹ : Mul M\nN : Type u_5\ninst✝ : Mul N\nf : MulHom M N\nhf : Function.Surjective ⇑f\n⊢ Eq f.srange Top.top","decl":"@[deprecated (since := \"2024-11-11\")] alias srange_top_of_surjective := srange_eq_top_of_surjective\n\n"}
{"name":"MulHom.mclosure_preimage_le","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\ns : Set N\n⊢ LE.le (Subsemigroup.closure (Set.preimage (⇑f) s)) (Subsemigroup.comap f (Subsemigroup.closure s))","decl":"@[to_additive]\ntheorem mclosure_preimage_le (f : M →ₙ* N) (s : Set N) : closure (f ⁻¹' s) ≤ (closure s).comap f :=\n  closure_le.2 fun _ hx => SetLike.mem_coe.2 <| mem_comap.2 <| subset_closure hx\n\n"}
{"name":"AddHom.mclosure_preimage_le","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\ns : Set N\n⊢ LE.le (AddSubsemigroup.closure (Set.preimage (⇑f) s)) (AddSubsemigroup.comap f (AddSubsemigroup.closure s))","decl":"@[to_additive]\ntheorem mclosure_preimage_le (f : M →ₙ* N) (s : Set N) : closure (f ⁻¹' s) ≤ (closure s).comap f :=\n  closure_le.2 fun _ hx => SetLike.mem_coe.2 <| mem_comap.2 <| subset_closure hx\n\n"}
{"name":"AddHom.map_mclosure","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\ns : Set M\n⊢ Eq (AddSubsemigroup.map f (AddSubsemigroup.closure s)) (AddSubsemigroup.closure (Set.image (⇑f) s))","decl":"/-- The image under a semigroup hom of the subsemigroup generated by a set equals the subsemigroup\ngenerated by the image of the set. -/\n@[to_additive\n      \"The image under an `AddSemigroup` hom of the `AddSubsemigroup` generated by a set\n      equals the `AddSubsemigroup` generated by the image of the set.\"]\ntheorem map_mclosure (f : M →ₙ* N) (s : Set M) : (closure s).map f = closure (f '' s) :=\n  Set.image_preimage.l_comm_of_u_comm (gc_map_comap f) (Subsemigroup.gi N).gc (Subsemigroup.gi M).gc\n    fun _ ↦ rfl\n\n"}
{"name":"MulHom.map_mclosure","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\ns : Set M\n⊢ Eq (Subsemigroup.map f (Subsemigroup.closure s)) (Subsemigroup.closure (Set.image (⇑f) s))","decl":"/-- The image under a semigroup hom of the subsemigroup generated by a set equals the subsemigroup\ngenerated by the image of the set. -/\n@[to_additive\n      \"The image under an `AddSemigroup` hom of the `AddSubsemigroup` generated by a set\n      equals the `AddSubsemigroup` generated by the image of the set.\"]\ntheorem map_mclosure (f : M →ₙ* N) (s : Set M) : (closure s).map f = closure (f '' s) :=\n  Set.image_preimage.l_comm_of_u_comm (gc_map_comap f) (Subsemigroup.gi N).gc (Subsemigroup.gi M).gc\n    fun _ ↦ rfl\n\n"}
{"name":"MulHom.restrict_apply","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nσ : Type u_4\ninst✝³ : Mul M\nN : Type u_5\ninst✝² : Mul N\ninst✝¹ : SetLike σ M\ninst✝ : MulMemClass σ M\nf : MulHom M N\nS : σ\nx : Subtype fun x => Membership.mem S x\n⊢ Eq ((f.restrict S) x) (f ↑x)","decl":"@[to_additive (attr := simp)]\ntheorem restrict_apply {N : Type*} [Mul N] [SetLike σ M] [MulMemClass σ M] (f : M →ₙ* N) {S : σ}\n    (x : S) : f.restrict S x = f x :=\n  rfl\n\n"}
{"name":"AddHom.restrict_apply","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nσ : Type u_4\ninst✝³ : Add M\nN : Type u_5\ninst✝² : Add N\ninst✝¹ : SetLike σ M\ninst✝ : AddMemClass σ M\nf : AddHom M N\nS : σ\nx : Subtype fun x => Membership.mem S x\n⊢ Eq ((f.restrict S) x) (f ↑x)","decl":"@[to_additive (attr := simp)]\ntheorem restrict_apply {N : Type*} [Mul N] [SetLike σ M] [MulMemClass σ M] (f : M →ₙ* N) {S : σ}\n    (x : S) : f.restrict S x = f x :=\n  rfl\n\n"}
{"name":"MulHom.codRestrict_apply_coe","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\nσ : Type u_4\ninst✝³ : Mul M\ninst✝² : Mul N\ninst✝¹ : SetLike σ N\ninst✝ : MulMemClass σ N\nf : MulHom M N\nS : σ\nh : ∀ (x : M), Membership.mem S (f x)\nn : M\n⊢ Eq (↑((f.codRestrict S h) n)) (f n)","decl":"/-- Restriction of a semigroup hom to a subsemigroup of the codomain. -/\n@[to_additive (attr := simps)\n  \"Restriction of an `AddSemigroup` hom to an `AddSubsemigroup` of the codomain.\"]\ndef codRestrict [SetLike σ N] [MulMemClass σ N] (f : M →ₙ* N) (S : σ) (h : ∀ x, f x ∈ S) :\n    M →ₙ* S where\n  toFun n := ⟨f n, h n⟩\n  map_mul' x y := Subtype.eq (map_mul f x y)\n\n"}
{"name":"AddHom.codRestrict_apply_coe","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\nσ : Type u_4\ninst✝³ : Add M\ninst✝² : Add N\ninst✝¹ : SetLike σ N\ninst✝ : AddMemClass σ N\nf : AddHom M N\nS : σ\nh : ∀ (x : M), Membership.mem S (f x)\nn : M\n⊢ Eq (↑((f.codRestrict S h) n)) (f n)","decl":"/-- Restriction of a semigroup hom to a subsemigroup of the codomain. -/\n@[to_additive (attr := simps)\n  \"Restriction of an `AddSemigroup` hom to an `AddSubsemigroup` of the codomain.\"]\ndef codRestrict [SetLike σ N] [MulMemClass σ N] (f : M →ₙ* N) (S : σ) (h : ∀ x, f x ∈ S) :\n    M →ₙ* S where\n  toFun n := ⟨f n, h n⟩\n  map_mul' x y := Subtype.eq (map_mul f x y)\n\n"}
{"name":"MulHom.coe_srangeRestrict","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\ninst✝¹ : Mul M\nN : Type u_5\ninst✝ : Mul N\nf : MulHom M N\nx : M\n⊢ Eq (↑(f.srangeRestrict x)) (f x)","decl":"@[to_additive (attr := simp)]\ntheorem coe_srangeRestrict {N} [Mul N] (f : M →ₙ* N) (x : M) : (f.srangeRestrict x : N) = f x :=\n  rfl\n\n"}
{"name":"AddHom.coe_srangeRestrict","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\ninst✝¹ : Add M\nN : Type u_5\ninst✝ : Add N\nf : AddHom M N\nx : M\n⊢ Eq (↑(f.srangeRestrict x)) (f x)","decl":"@[to_additive (attr := simp)]\ntheorem coe_srangeRestrict {N} [Mul N] (f : M →ₙ* N) (x : M) : (f.srangeRestrict x : N) = f x :=\n  rfl\n\n"}
{"name":"MulHom.srangeRestrict_surjective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\n⊢ Function.Surjective ⇑f.srangeRestrict","decl":"@[to_additive]\ntheorem srangeRestrict_surjective (f : M →ₙ* N) : Function.Surjective f.srangeRestrict :=\n  fun ⟨_, ⟨x, rfl⟩⟩ => ⟨x, rfl⟩\n\n"}
{"name":"AddHom.srangeRestrict_surjective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\n⊢ Function.Surjective ⇑f.srangeRestrict","decl":"@[to_additive]\ntheorem srangeRestrict_surjective (f : M →ₙ* N) : Function.Surjective f.srangeRestrict :=\n  fun ⟨_, ⟨x, rfl⟩⟩ => ⟨x, rfl⟩\n\n"}
{"name":"AddHom.prod_map_comap_prod'","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : Add M\ninst✝² : Add N\nM' : Type u_5\nN' : Type u_6\ninst✝¹ : Add M'\ninst✝ : Add N'\nf : AddHom M N\ng : AddHom M' N'\nS : AddSubsemigroup N\nS' : AddSubsemigroup N'\n⊢ Eq (AddSubsemigroup.comap (f.prodMap g) (S.prod S')) ((AddSubsemigroup.comap f S).prod (AddSubsemigroup.comap g S'))","decl":"@[to_additive prod_map_comap_prod']\ntheorem prod_map_comap_prod' {M' : Type*} {N' : Type*} [Mul M'] [Mul N'] (f : M →ₙ* N)\n    (g : M' →ₙ* N') (S : Subsemigroup N) (S' : Subsemigroup N') :\n    (S.prod S').comap (prodMap f g) = (S.comap f).prod (S'.comap g) :=\n  SetLike.coe_injective <| Set.preimage_prod_map_prod f g _ _\n\n"}
{"name":"MulHom.prod_map_comap_prod'","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : Mul M\ninst✝² : Mul N\nM' : Type u_5\nN' : Type u_6\ninst✝¹ : Mul M'\ninst✝ : Mul N'\nf : MulHom M N\ng : MulHom M' N'\nS : Subsemigroup N\nS' : Subsemigroup N'\n⊢ Eq (Subsemigroup.comap (f.prodMap g) (S.prod S')) ((Subsemigroup.comap f S).prod (Subsemigroup.comap g S'))","decl":"@[to_additive prod_map_comap_prod']\ntheorem prod_map_comap_prod' {M' : Type*} {N' : Type*} [Mul M'] [Mul N'] (f : M →ₙ* N)\n    (g : M' →ₙ* N') (S : Subsemigroup N) (S' : Subsemigroup N') :\n    (S.prod S').comap (prodMap f g) = (S.comap f).prod (S'.comap g) :=\n  SetLike.coe_injective <| Set.preimage_prod_map_prod f g _ _\n\n"}
{"name":"MulHom.subsemigroupComap_apply_coe","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\nN' : Subsemigroup N\nx : Subtype fun x => Membership.mem (Subsemigroup.comap f N') x\n⊢ Eq (↑((f.subsemigroupComap N') x)) (f ↑x)","decl":"/-- The `MulHom` from the preimage of a subsemigroup to itself. -/\n@[to_additive (attr := simps)\n  \"The `AddHom` from the preimage of an additive subsemigroup to itself.\"]\ndef subsemigroupComap (f : M →ₙ* N) (N' : Subsemigroup N) :\n    N'.comap f →ₙ* N' where\n  toFun x := ⟨f x, x.prop⟩\n  map_mul' x y := Subtype.eq <| map_mul (M := M) (N := N) f x y\n\n"}
{"name":"AddHom.subsemigroupComap_apply_coe","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\nN' : AddSubsemigroup N\nx : Subtype fun x => Membership.mem (AddSubsemigroup.comap f N') x\n⊢ Eq (↑((f.subsemigroupComap N') x)) (f ↑x)","decl":"/-- The `MulHom` from the preimage of a subsemigroup to itself. -/\n@[to_additive (attr := simps)\n  \"The `AddHom` from the preimage of an additive subsemigroup to itself.\"]\ndef subsemigroupComap (f : M →ₙ* N) (N' : Subsemigroup N) :\n    N'.comap f →ₙ* N' where\n  toFun x := ⟨f x, x.prop⟩\n  map_mul' x y := Subtype.eq <| map_mul (M := M) (N := N) f x y\n\n"}
{"name":"MulHom.subsemigroupMap_apply_coe","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\nM' : Subsemigroup M\nx : Subtype fun x => Membership.mem M' x\n⊢ Eq (↑((f.subsemigroupMap M') x)) (f ↑x)","decl":"/-- The `MulHom` from a subsemigroup to its image.\nSee `MulEquiv.subsemigroupMap` for a variant for `MulEquiv`s. -/\n@[to_additive (attr := simps)\n      \"the `AddHom` from an additive subsemigroup to its image. See\n      `AddEquiv.addSubsemigroupMap` for a variant for `AddEquiv`s.\"]\ndef subsemigroupMap (f : M →ₙ* N) (M' : Subsemigroup M) :\n    M' →ₙ* M'.map f where\n  toFun x := ⟨f x, ⟨x, x.prop, rfl⟩⟩\n  map_mul' x y := Subtype.eq <| map_mul (M := M) (N := N) f x y\n\n"}
{"name":"AddHom.subsemigroupMap_apply_coe","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\nM' : AddSubsemigroup M\nx : Subtype fun x => Membership.mem M' x\n⊢ Eq (↑((f.subsemigroupMap M') x)) (f ↑x)","decl":"/-- The `MulHom` from a subsemigroup to its image.\nSee `MulEquiv.subsemigroupMap` for a variant for `MulEquiv`s. -/\n@[to_additive (attr := simps)\n      \"the `AddHom` from an additive subsemigroup to its image. See\n      `AddEquiv.addSubsemigroupMap` for a variant for `AddEquiv`s.\"]\ndef subsemigroupMap (f : M →ₙ* N) (M' : Subsemigroup M) :\n    M' →ₙ* M'.map f where\n  toFun x := ⟨f x, ⟨x, x.prop, rfl⟩⟩\n  map_mul' x y := Subtype.eq <| map_mul (M := M) (N := N) f x y\n\n"}
{"name":"MulHom.subsemigroupMap_surjective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\nM' : Subsemigroup M\n⊢ Function.Surjective ⇑(f.subsemigroupMap M')","decl":"@[to_additive]\ntheorem subsemigroupMap_surjective (f : M →ₙ* N) (M' : Subsemigroup M) :\n    Function.Surjective (f.subsemigroupMap M') := by\n  rintro ⟨_, x, hx, rfl⟩\n  exact ⟨⟨x, hx⟩, rfl⟩\n\n"}
{"name":"AddHom.subsemigroupMap_surjective","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\nM' : AddSubsemigroup M\n⊢ Function.Surjective ⇑(f.subsemigroupMap M')","decl":"@[to_additive]\ntheorem subsemigroupMap_surjective (f : M →ₙ* N) (M' : Subsemigroup M) :\n    Function.Surjective (f.subsemigroupMap M') := by\n  rintro ⟨_, x, hx, rfl⟩\n  exact ⟨⟨x, hx⟩, rfl⟩\n\n"}
{"name":"AddSubsemigroup.srange_fst","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : Add M\ninst✝¹ : Add N\ninst✝ : Nonempty N\n⊢ Eq (AddHom.fst M N).srange Top.top","decl":"@[to_additive (attr := simp)]\ntheorem srange_fst [Nonempty N] : (fst M N).srange = ⊤ :=\n  (fst M N).srange_eq_top_of_surjective <| Prod.fst_surjective\n\n"}
{"name":"Subsemigroup.srange_fst","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : Mul M\ninst✝¹ : Mul N\ninst✝ : Nonempty N\n⊢ Eq (MulHom.fst M N).srange Top.top","decl":"@[to_additive (attr := simp)]\ntheorem srange_fst [Nonempty N] : (fst M N).srange = ⊤ :=\n  (fst M N).srange_eq_top_of_surjective <| Prod.fst_surjective\n\n"}
{"name":"AddSubsemigroup.srange_snd","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : Add M\ninst✝¹ : Add N\ninst✝ : Nonempty M\n⊢ Eq (AddHom.snd M N).srange Top.top","decl":"@[to_additive (attr := simp)]\ntheorem srange_snd [Nonempty M] : (snd M N).srange = ⊤ :=\n  (snd M N).srange_eq_top_of_surjective <| Prod.snd_surjective\n\n"}
{"name":"Subsemigroup.srange_snd","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : Mul M\ninst✝¹ : Mul N\ninst✝ : Nonempty M\n⊢ Eq (MulHom.snd M N).srange Top.top","decl":"@[to_additive (attr := simp)]\ntheorem srange_snd [Nonempty M] : (snd M N).srange = ⊤ :=\n  (snd M N).srange_eq_top_of_surjective <| Prod.snd_surjective\n\n"}
{"name":"AddSubsemigroup.prod_eq_top_iff","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : Add M\ninst✝² : Add N\ninst✝¹ : Nonempty M\ninst✝ : Nonempty N\ns : AddSubsemigroup M\nt : AddSubsemigroup N\n⊢ Iff (Eq (s.prod t) Top.top) (And (Eq s Top.top) (Eq t Top.top))","decl":"@[to_additive prod_eq_top_iff]\ntheorem prod_eq_top_iff [Nonempty M] [Nonempty N] {s : Subsemigroup M} {t : Subsemigroup N} :\n    s.prod t = ⊤ ↔ s = ⊤ ∧ t = ⊤ := by\n  simp only [eq_top_iff, le_prod_iff, ← (gc_map_comap _).le_iff_le, ← srange_eq_map, srange_fst,\n    srange_snd]\n\n"}
{"name":"Subsemigroup.prod_eq_top_iff","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : Mul M\ninst✝² : Mul N\ninst✝¹ : Nonempty M\ninst✝ : Nonempty N\ns : Subsemigroup M\nt : Subsemigroup N\n⊢ Iff (Eq (s.prod t) Top.top) (And (Eq s Top.top) (Eq t Top.top))","decl":"@[to_additive prod_eq_top_iff]\ntheorem prod_eq_top_iff [Nonempty M] [Nonempty N] {s : Subsemigroup M} {t : Subsemigroup N} :\n    s.prod t = ⊤ ↔ s = ⊤ ∧ t = ⊤ := by\n  simp only [eq_top_iff, le_prod_iff, ← (gc_map_comap _).le_iff_le, ← srange_eq_map, srange_fst,\n    srange_snd]\n\n"}
{"name":"AddSubsemigroup.range_subtype","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\ninst✝ : Add M\ns : AddSubsemigroup M\n⊢ Eq (AddMemClass.subtype s).srange s","decl":"@[to_additive (attr := simp)]\ntheorem range_subtype (s : Subsemigroup M) : (MulMemClass.subtype s).srange = s :=\n  SetLike.coe_injective <| (coe_srange _).trans <| Subtype.range_coe\n\n"}
{"name":"Subsemigroup.range_subtype","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\ninst✝ : Mul M\ns : Subsemigroup M\n⊢ Eq (MulMemClass.subtype s).srange s","decl":"@[to_additive (attr := simp)]\ntheorem range_subtype (s : Subsemigroup M) : (MulMemClass.subtype s).srange = s :=\n  SetLike.coe_injective <| (coe_srange _).trans <| Subtype.range_coe\n\n"}
{"name":"Subsemigroup.eq_top_iff'","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\ninst✝ : Mul M\nS : Subsemigroup M\n⊢ Iff (Eq S Top.top) (∀ (x : M), Membership.mem S x)","decl":"@[to_additive]\ntheorem eq_top_iff' : S = ⊤ ↔ ∀ x : M, x ∈ S :=\n  eq_top_iff.trans ⟨fun h m => h <| mem_top m, fun h m _ => h m⟩\n\n"}
{"name":"AddSubsemigroup.eq_top_iff'","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\ninst✝ : Add M\nS : AddSubsemigroup M\n⊢ Iff (Eq S Top.top) (∀ (x : M), Membership.mem S x)","decl":"@[to_additive]\ntheorem eq_top_iff' : S = ⊤ ↔ ∀ x : M, x ∈ S :=\n  eq_top_iff.trans ⟨fun h m => h <| mem_top m, fun h m _ => h m⟩\n\n"}
{"name":"MulEquiv.ofLeftInverse_symm_apply","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\ng : N → M\nh : Function.LeftInverse g ⇑f\na✝ : Subtype fun x => Membership.mem f.srange x\n⊢ Eq ((MulEquiv.ofLeftInverse f h).symm a✝) (g ↑a✝)","decl":"/-- A semigroup homomorphism `f : M →ₙ* N` with a left-inverse `g : N → M` defines a multiplicative\nequivalence between `M` and `f.srange`.\n\nThis is a bidirectional version of `MulHom.srangeRestrict`. -/\n@[to_additive (attr := simps (config := { simpRhs := true }))\n      \"An additive semigroup homomorphism `f : M →+ N` with a left-inverse\n      `g : N → M` defines an additive equivalence between `M` and `f.srange`.\n      This is a bidirectional version of `AddHom.srangeRestrict`. \"]\ndef ofLeftInverse (f : M →ₙ* N) {g : N → M} (h : Function.LeftInverse g f) : M ≃* f.srange :=\n  { f.srangeRestrict with\n    toFun := f.srangeRestrict\n    invFun := g ∘ MulMemClass.subtype f.srange\n    left_inv := h\n    right_inv := fun x =>\n      Subtype.ext <|\n        let ⟨x', hx'⟩ := MulHom.mem_srange.mp x.prop\n        show f (g x) = x by rw [← hx', h x'] }\n\n"}
{"name":"MulEquiv.ofLeftInverse_apply","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\ng : N → M\nh : Function.LeftInverse g ⇑f\na : M\n⊢ Eq ((MulEquiv.ofLeftInverse f h) a) (f.srangeRestrict a)","decl":"/-- A semigroup homomorphism `f : M →ₙ* N` with a left-inverse `g : N → M` defines a multiplicative\nequivalence between `M` and `f.srange`.\n\nThis is a bidirectional version of `MulHom.srangeRestrict`. -/\n@[to_additive (attr := simps (config := { simpRhs := true }))\n      \"An additive semigroup homomorphism `f : M →+ N` with a left-inverse\n      `g : N → M` defines an additive equivalence between `M` and `f.srange`.\n      This is a bidirectional version of `AddHom.srangeRestrict`. \"]\ndef ofLeftInverse (f : M →ₙ* N) {g : N → M} (h : Function.LeftInverse g f) : M ≃* f.srange :=\n  { f.srangeRestrict with\n    toFun := f.srangeRestrict\n    invFun := g ∘ MulMemClass.subtype f.srange\n    left_inv := h\n    right_inv := fun x =>\n      Subtype.ext <|\n        let ⟨x', hx'⟩ := MulHom.mem_srange.mp x.prop\n        show f (g x) = x by rw [← hx', h x'] }\n\n"}
{"name":"AddEquiv.ofLeftInverse_apply","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\ng : N → M\nh : Function.LeftInverse g ⇑f\na : M\n⊢ Eq ((AddEquiv.ofLeftInverse f h) a) (f.srangeRestrict a)","decl":"/-- A semigroup homomorphism `f : M →ₙ* N` with a left-inverse `g : N → M` defines a multiplicative\nequivalence between `M` and `f.srange`.\n\nThis is a bidirectional version of `MulHom.srangeRestrict`. -/\n@[to_additive (attr := simps (config := { simpRhs := true }))\n      \"An additive semigroup homomorphism `f : M →+ N` with a left-inverse\n      `g : N → M` defines an additive equivalence between `M` and `f.srange`.\n      This is a bidirectional version of `AddHom.srangeRestrict`. \"]\ndef ofLeftInverse (f : M →ₙ* N) {g : N → M} (h : Function.LeftInverse g f) : M ≃* f.srange :=\n  { f.srangeRestrict with\n    toFun := f.srangeRestrict\n    invFun := g ∘ MulMemClass.subtype f.srange\n    left_inv := h\n    right_inv := fun x =>\n      Subtype.ext <|\n        let ⟨x', hx'⟩ := MulHom.mem_srange.mp x.prop\n        show f (g x) = x by rw [← hx', h x'] }\n\n"}
{"name":"AddEquiv.ofLeftInverse_symm_apply","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\ng : N → M\nh : Function.LeftInverse g ⇑f\na✝ : Subtype fun x => Membership.mem f.srange x\n⊢ Eq ((AddEquiv.ofLeftInverse f h).symm a✝) (g ↑a✝)","decl":"/-- A semigroup homomorphism `f : M →ₙ* N` with a left-inverse `g : N → M` defines a multiplicative\nequivalence between `M` and `f.srange`.\n\nThis is a bidirectional version of `MulHom.srangeRestrict`. -/\n@[to_additive (attr := simps (config := { simpRhs := true }))\n      \"An additive semigroup homomorphism `f : M →+ N` with a left-inverse\n      `g : N → M` defines an additive equivalence between `M` and `f.srange`.\n      This is a bidirectional version of `AddHom.srangeRestrict`. \"]\ndef ofLeftInverse (f : M →ₙ* N) {g : N → M} (h : Function.LeftInverse g f) : M ≃* f.srange :=\n  { f.srangeRestrict with\n    toFun := f.srangeRestrict\n    invFun := g ∘ MulMemClass.subtype f.srange\n    left_inv := h\n    right_inv := fun x =>\n      Subtype.ext <|\n        let ⟨x', hx'⟩ := MulHom.mem_srange.mp x.prop\n        show f (g x) = x by rw [← hx', h x'] }\n\n"}
{"name":"MulEquiv.subsemigroupMap_symm_apply_coe","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\ne : MulEquiv M N\nS : Subsemigroup M\nx : Subtype fun x => Membership.mem (Subsemigroup.map (↑e) S) x\n⊢ Eq (↑((e.subsemigroupMap S).symm x)) (e.symm ↑x)","decl":"/-- A `MulEquiv` `φ` between two semigroups `M` and `N` induces a `MulEquiv` between\na subsemigroup `S ≤ M` and the subsemigroup `φ(S) ≤ N`.\nSee `MulHom.subsemigroupMap` for a variant for `MulHom`s. -/\n@[to_additive (attr := simps)\n      \"An `AddEquiv` `φ` between two additive semigroups `M` and `N` induces an `AddEquiv`\n      between a subsemigroup `S ≤ M` and the subsemigroup `φ(S) ≤ N`.\n      See `AddHom.addSubsemigroupMap` for a variant for `AddHom`s.\"]\ndef subsemigroupMap (e : M ≃* N) (S : Subsemigroup M) : S ≃* S.map (e : M →ₙ* N) :=\n  { -- we restate this for `simps` to avoid `⇑e.symm.toEquiv x`\n    (e : M →ₙ* N).subsemigroupMap S,\n    (e : M ≃ N).image S with\n    toFun := fun x => ⟨e x, _⟩\n    invFun := fun x => ⟨e.symm x, _⟩ }\n\n"}
{"name":"MulEquiv.subsemigroupMap_apply_coe","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\ne : MulEquiv M N\nS : Subsemigroup M\nx : Subtype fun x => Membership.mem S x\n⊢ Eq (↑((e.subsemigroupMap S) x)) (e ↑x)","decl":"/-- A `MulEquiv` `φ` between two semigroups `M` and `N` induces a `MulEquiv` between\na subsemigroup `S ≤ M` and the subsemigroup `φ(S) ≤ N`.\nSee `MulHom.subsemigroupMap` for a variant for `MulHom`s. -/\n@[to_additive (attr := simps)\n      \"An `AddEquiv` `φ` between two additive semigroups `M` and `N` induces an `AddEquiv`\n      between a subsemigroup `S ≤ M` and the subsemigroup `φ(S) ≤ N`.\n      See `AddHom.addSubsemigroupMap` for a variant for `AddHom`s.\"]\ndef subsemigroupMap (e : M ≃* N) (S : Subsemigroup M) : S ≃* S.map (e : M →ₙ* N) :=\n  { -- we restate this for `simps` to avoid `⇑e.symm.toEquiv x`\n    (e : M →ₙ* N).subsemigroupMap S,\n    (e : M ≃ N).image S with\n    toFun := fun x => ⟨e x, _⟩\n    invFun := fun x => ⟨e.symm x, _⟩ }\n\n"}
{"name":"AddEquiv.subsemigroupMap_apply_coe","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\ne : AddEquiv M N\nS : AddSubsemigroup M\nx : Subtype fun x => Membership.mem S x\n⊢ Eq (↑((e.subsemigroupMap S) x)) (e ↑x)","decl":"/-- A `MulEquiv` `φ` between two semigroups `M` and `N` induces a `MulEquiv` between\na subsemigroup `S ≤ M` and the subsemigroup `φ(S) ≤ N`.\nSee `MulHom.subsemigroupMap` for a variant for `MulHom`s. -/\n@[to_additive (attr := simps)\n      \"An `AddEquiv` `φ` between two additive semigroups `M` and `N` induces an `AddEquiv`\n      between a subsemigroup `S ≤ M` and the subsemigroup `φ(S) ≤ N`.\n      See `AddHom.addSubsemigroupMap` for a variant for `AddHom`s.\"]\ndef subsemigroupMap (e : M ≃* N) (S : Subsemigroup M) : S ≃* S.map (e : M →ₙ* N) :=\n  { -- we restate this for `simps` to avoid `⇑e.symm.toEquiv x`\n    (e : M →ₙ* N).subsemigroupMap S,\n    (e : M ≃ N).image S with\n    toFun := fun x => ⟨e x, _⟩\n    invFun := fun x => ⟨e.symm x, _⟩ }\n\n"}
{"name":"AddEquiv.subsemigroupMap_symm_apply_coe","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\ne : AddEquiv M N\nS : AddSubsemigroup M\nx : Subtype fun x => Membership.mem (AddSubsemigroup.map (↑e) S) x\n⊢ Eq (↑((e.subsemigroupMap S).symm x)) (e.symm ↑x)","decl":"/-- A `MulEquiv` `φ` between two semigroups `M` and `N` induces a `MulEquiv` between\na subsemigroup `S ≤ M` and the subsemigroup `φ(S) ≤ N`.\nSee `MulHom.subsemigroupMap` for a variant for `MulHom`s. -/\n@[to_additive (attr := simps)\n      \"An `AddEquiv` `φ` between two additive semigroups `M` and `N` induces an `AddEquiv`\n      between a subsemigroup `S ≤ M` and the subsemigroup `φ(S) ≤ N`.\n      See `AddHom.addSubsemigroupMap` for a variant for `AddHom`s.\"]\ndef subsemigroupMap (e : M ≃* N) (S : Subsemigroup M) : S ≃* S.map (e : M →ₙ* N) :=\n  { -- we restate this for `simps` to avoid `⇑e.symm.toEquiv x`\n    (e : M →ₙ* N).subsemigroupMap S,\n    (e : M ≃ N).image S with\n    toFun := fun x => ⟨e x, _⟩\n    invFun := fun x => ⟨e.symm x, _⟩ }\n\n"}
{"name":"Subsemigroup.map_comap_eq","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\nS : Subsemigroup N\n⊢ Eq (Subsemigroup.map f (Subsemigroup.comap f S)) (Min.min S f.srange)","decl":"@[to_additive]\ntheorem map_comap_eq (f : M →ₙ* N) (S : Subsemigroup N) : (S.comap f).map f = S ⊓ f.srange :=\n  SetLike.coe_injective Set.image_preimage_eq_inter_range\n\n"}
{"name":"AddSubsemigroup.map_comap_eq","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\nS : AddSubsemigroup N\n⊢ Eq (AddSubsemigroup.map f (AddSubsemigroup.comap f S)) (Min.min S f.srange)","decl":"@[to_additive]\ntheorem map_comap_eq (f : M →ₙ* N) (S : Subsemigroup N) : (S.comap f).map f = S ⊓ f.srange :=\n  SetLike.coe_injective Set.image_preimage_eq_inter_range\n\n"}
{"name":"Subsemigroup.map_comap_eq_self","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\nS : Subsemigroup N\nh : LE.le S f.srange\n⊢ Eq (Subsemigroup.map f (Subsemigroup.comap f S)) S","decl":"@[to_additive]\ntheorem map_comap_eq_self {f : M →ₙ* N} {S : Subsemigroup N} (h : S ≤ f.srange) :\n    (S.comap f).map f = S := by\n  simpa only [inf_of_le_left h] using map_comap_eq f S\n\n"}
{"name":"AddSubsemigroup.map_comap_eq_self","module":"Mathlib.Algebra.Group.Subsemigroup.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\nS : AddSubsemigroup N\nh : LE.le S f.srange\n⊢ Eq (AddSubsemigroup.map f (AddSubsemigroup.comap f S)) S","decl":"@[to_additive]\ntheorem map_comap_eq_self {f : M →ₙ* N} {S : Subsemigroup N} (h : S ≤ f.srange) :\n    (S.comap f).map f = S := by\n  simpa only [inf_of_le_left h] using map_comap_eq f S\n\n"}
