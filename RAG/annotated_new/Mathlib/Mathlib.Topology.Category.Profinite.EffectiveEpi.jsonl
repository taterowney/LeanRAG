{"name":"Profinite.effectiveEpi_tfae","module":"Mathlib.Topology.Category.Profinite.EffectiveEpi","initialProofState":"B X : Profinite\nπ : Quiver.Hom X B\n⊢ (List.cons (CategoryTheory.EffectiveEpi π) (List.cons (CategoryTheory.Epi π) (List.cons (Function.Surjective ⇑π) List.nil))).TFAE","decl":"open List in\ntheorem effectiveEpi_tfae\n    {B X : Profinite.{u}} (π : X ⟶ B) :\n    TFAE\n    [ EffectiveEpi π\n    , Epi π\n    , Function.Surjective π\n    ] := by\n  tfae_have 1 → 2 := fun _ ↦ inferInstance\n  tfae_have 2 ↔ 3 := epi_iff_surjective π\n  tfae_have 3 → 1 := fun hπ ↦ ⟨⟨CompHausLike.effectiveEpiStruct π hπ⟩⟩\n  tfae_finish\n\n"}
{"name":"Profinite.instPreservesEffectiveEpisCompHausProfiniteToCompHaus","module":"Mathlib.Topology.Category.Profinite.EffectiveEpi","initialProofState":"⊢ profiniteToCompHaus.PreservesEffectiveEpis","decl":"instance : profiniteToCompHaus.PreservesEffectiveEpis where\n  preserves f h :=\n    ((CompHaus.effectiveEpi_tfae _).out 0 2).mpr (((Profinite.effectiveEpi_tfae _).out 0 2).mp h)\n\n"}
{"name":"Profinite.instReflectsEffectiveEpisCompHausProfiniteToCompHaus","module":"Mathlib.Topology.Category.Profinite.EffectiveEpi","initialProofState":"⊢ profiniteToCompHaus.ReflectsEffectiveEpis","decl":"instance : profiniteToCompHaus.ReflectsEffectiveEpis where\n  reflects f h :=\n    ((Profinite.effectiveEpi_tfae f).out 0 2).mpr (((CompHaus.effectiveEpi_tfae _).out 0 2).mp h)\n\n"}
{"name":"Profinite.instEffectivelyEnoughCompHausProfiniteToCompHaus","module":"Mathlib.Topology.Category.Profinite.EffectiveEpi","initialProofState":"⊢ profiniteToCompHaus.EffectivelyEnough","decl":"instance : profiniteToCompHaus.EffectivelyEnough where\n  presentation X := ⟨profiniteToCompHausEffectivePresentation X⟩\n\n"}
{"name":"Profinite.instPreregular","module":"Mathlib.Topology.Category.Profinite.EffectiveEpi","initialProofState":"⊢ CategoryTheory.Preregular Profinite","decl":"instance : Preregular Profinite.{u} := profiniteToCompHaus.reflects_preregular\n\n"}
{"name":"Profinite.effectiveEpiFamily_tfae","module":"Mathlib.Topology.Category.Profinite.EffectiveEpi","initialProofState":"α : Type\ninst✝ : Finite α\nB : Profinite\nX : α → Profinite\nπ : (a : α) → Quiver.Hom (X a) B\n⊢ (List.cons (CategoryTheory.EffectiveEpiFamily X π) (List.cons (CategoryTheory.Epi (CategoryTheory.Limits.Sigma.desc π)) (List.cons (∀ (b : ↑B.toTop), Exists fun a => Exists fun x => Eq ((π a) x) b) List.nil))).TFAE","decl":"open List in\ntheorem effectiveEpiFamily_tfae\n    {α : Type} [Finite α] {B : Profinite.{u}}\n    (X : α → Profinite.{u}) (π : (a : α) → (X a ⟶ B)) :\n    TFAE\n    [ EffectiveEpiFamily X π\n    , Epi (Sigma.desc π)\n    , ∀ b : B, ∃ (a : α) (x : X a), π a x = b\n    ] := by\n  tfae_have 2 → 1\n  | _ => by\n    simpa [← effectiveEpi_desc_iff_effectiveEpiFamily, (effectiveEpi_tfae (Sigma.desc π)).out 0 1]\n  tfae_have 1 → 2 := fun _ ↦ inferInstance\n  tfae_have 3 ↔ 1 := by\n    erw [((CompHaus.effectiveEpiFamily_tfae\n      (fun a ↦ profiniteToCompHaus.obj (X a)) (fun a ↦ profiniteToCompHaus.map (π a))).out 2 0 : )]\n    exact ⟨fun h ↦ profiniteToCompHaus.finite_effectiveEpiFamily_of_map _ _ h,\n      fun _ ↦ inferInstance⟩\n  tfae_finish\n\n"}
{"name":"Profinite.effectiveEpiFamily_of_jointly_surjective","module":"Mathlib.Topology.Category.Profinite.EffectiveEpi","initialProofState":"α : Type\ninst✝ : Finite α\nB : Profinite\nX : α → Profinite\nπ : (a : α) → Quiver.Hom (X a) B\nsurj : ∀ (b : ↑B.toTop), Exists fun a => Exists fun x => Eq ((π a) x) b\n⊢ CategoryTheory.EffectiveEpiFamily X π","decl":"theorem effectiveEpiFamily_of_jointly_surjective\n    {α : Type} [Finite α] {B : Profinite.{u}}\n    (X : α → Profinite.{u}) (π : (a : α) → (X a ⟶ B))\n    (surj : ∀ b : B, ∃ (a : α) (x : X a), π a x = b) :\n    EffectiveEpiFamily X π :=\n  ((effectiveEpiFamily_tfae X π).out 2 0).mp surj\n\n"}
