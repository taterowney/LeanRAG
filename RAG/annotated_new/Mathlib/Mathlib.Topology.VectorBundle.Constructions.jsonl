{"name":"Bundle.Trivial.trivialization.isLinear","module":"Mathlib.Topology.VectorBundle.Constructions","initialProofState":"𝕜 : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : TopologicalSpace B\n⊢ Trivialization.IsLinear 𝕜 (Bundle.Trivial.trivialization B F)","decl":"instance trivialization.isLinear : (trivialization B F).IsLinear 𝕜 where\n  linear _ _ := ⟨fun _ _ => rfl, fun _ _ => rfl⟩\n\n"}
{"name":"Bundle.Trivial.trivialization.coordChangeL","module":"Mathlib.Topology.VectorBundle.Constructions","initialProofState":"𝕜 : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : TopologicalSpace B\nb : B\n⊢ Eq (Trivialization.coordChangeL 𝕜 (Bundle.Trivial.trivialization B F) (Bundle.Trivial.trivialization B F) b) (ContinuousLinearEquiv.refl 𝕜 F)","decl":"theorem trivialization.coordChangeL (b : B) :\n    (trivialization B F).coordChangeL 𝕜 (trivialization B F) b =\n      ContinuousLinearEquiv.refl 𝕜 F := by\n  ext v\n  rw [Trivialization.coordChangeL_apply']\n  exacts [rfl, ⟨mem_univ _, mem_univ _⟩]\n\n"}
{"name":"Bundle.Trivial.vectorBundle","module":"Mathlib.Topology.VectorBundle.Constructions","initialProofState":"𝕜 : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : TopologicalSpace B\n⊢ VectorBundle 𝕜 F (Bundle.Trivial B F)","decl":"instance vectorBundle : VectorBundle 𝕜 F (Bundle.Trivial B F) where\n  trivialization_linear' e he := by\n    rw [eq_trivialization B F e]\n    infer_instance\n  continuousOn_coordChange' e e' he he' := by\n    obtain rfl := eq_trivialization B F e\n    obtain rfl := eq_trivialization B F e'\n    simp only [trivialization.coordChangeL]\n    exact continuous_const.continuousOn\n\n"}
{"name":"Trivialization.prod.isLinear","module":"Mathlib.Topology.VectorBundle.Constructions","initialProofState":"𝕜 : Type u_1\nB : Type u_2\ninst✝¹³ : NontriviallyNormedField 𝕜\ninst✝¹² : TopologicalSpace B\nF₁ : Type u_3\ninst✝¹¹ : NormedAddCommGroup F₁\ninst✝¹⁰ : NormedSpace 𝕜 F₁\nE₁ : B → Type u_4\ninst✝⁹ : TopologicalSpace (Bundle.TotalSpace F₁ E₁)\nF₂ : Type u_5\ninst✝⁸ : NormedAddCommGroup F₂\ninst✝⁷ : NormedSpace 𝕜 F₂\nE₂ : B → Type u_6\ninst✝⁶ : TopologicalSpace (Bundle.TotalSpace F₂ E₂)\ninst✝⁵ : (x : B) → AddCommMonoid (E₁ x)\ninst✝⁴ : (x : B) → Module 𝕜 (E₁ x)\ninst✝³ : (x : B) → AddCommMonoid (E₂ x)\ninst✝² : (x : B) → Module 𝕜 (E₂ x)\ne₁ : Trivialization F₁ Bundle.TotalSpace.proj\ne₂ : Trivialization F₂ Bundle.TotalSpace.proj\ninst✝¹ : Trivialization.IsLinear 𝕜 e₁\ninst✝ : Trivialization.IsLinear 𝕜 e₂\n⊢ Trivialization.IsLinear 𝕜 (e₁.prod e₂)","decl":"instance prod.isLinear [e₁.IsLinear 𝕜] [e₂.IsLinear 𝕜] : (e₁.prod e₂).IsLinear 𝕜 where\n  linear := fun _ ⟨h₁, h₂⟩ =>\n    (((e₁.linear 𝕜 h₁).mk' _).prodMap ((e₂.linear 𝕜 h₂).mk' _)).isLinear\n\n"}
{"name":"Trivialization.coordChangeL_prod","module":"Mathlib.Topology.VectorBundle.Constructions","initialProofState":"𝕜 : Type u_1\nB : Type u_2\ninst✝¹⁵ : NontriviallyNormedField 𝕜\ninst✝¹⁴ : TopologicalSpace B\nF₁ : Type u_3\ninst✝¹³ : NormedAddCommGroup F₁\ninst✝¹² : NormedSpace 𝕜 F₁\nE₁ : B → Type u_4\ninst✝¹¹ : TopologicalSpace (Bundle.TotalSpace F₁ E₁)\nF₂ : Type u_5\ninst✝¹⁰ : NormedAddCommGroup F₂\ninst✝⁹ : NormedSpace 𝕜 F₂\nE₂ : B → Type u_6\ninst✝⁸ : TopologicalSpace (Bundle.TotalSpace F₂ E₂)\ninst✝⁷ : (x : B) → AddCommMonoid (E₁ x)\ninst✝⁶ : (x : B) → Module 𝕜 (E₁ x)\ninst✝⁵ : (x : B) → AddCommMonoid (E₂ x)\ninst✝⁴ : (x : B) → Module 𝕜 (E₂ x)\ne₁ e₁' : Trivialization F₁ Bundle.TotalSpace.proj\ne₂ e₂' : Trivialization F₂ Bundle.TotalSpace.proj\ninst✝³ : Trivialization.IsLinear 𝕜 e₁\ninst✝² : Trivialization.IsLinear 𝕜 e₁'\ninst✝¹ : Trivialization.IsLinear 𝕜 e₂\ninst✝ : Trivialization.IsLinear 𝕜 e₂'\nb : B\nhb : Membership.mem (Inter.inter (e₁.prod e₂).baseSet (e₁'.prod e₂').baseSet) b\n⊢ Eq (↑(Trivialization.coordChangeL 𝕜 (e₁.prod e₂) (e₁'.prod e₂') b)) ((↑(Trivialization.coordChangeL 𝕜 e₁ e₁' b)).prodMap ↑(Trivialization.coordChangeL 𝕜 e₂ e₂' b))","decl":"@[simp]\ntheorem coordChangeL_prod [e₁.IsLinear 𝕜] [e₁'.IsLinear 𝕜] [e₂.IsLinear 𝕜] [e₂'.IsLinear 𝕜] ⦃b⦄\n    (hb : b ∈ (e₁.prod e₂).baseSet ∩ (e₁'.prod e₂').baseSet) :\n    ((e₁.prod e₂).coordChangeL 𝕜 (e₁'.prod e₂') b : F₁ × F₂ →L[𝕜] F₁ × F₂) =\n      (e₁.coordChangeL 𝕜 e₁' b : F₁ →L[𝕜] F₁).prodMap (e₂.coordChangeL 𝕜 e₂' b) := by\n  rw [ContinuousLinearMap.ext_iff, ContinuousLinearMap.coe_prodMap']\n  rintro ⟨v₁, v₂⟩\n  show\n    (e₁.prod e₂).coordChangeL 𝕜 (e₁'.prod e₂') b (v₁, v₂) =\n      (e₁.coordChangeL 𝕜 e₁' b v₁, e₂.coordChangeL 𝕜 e₂' b v₂)\n  rw [e₁.coordChangeL_apply e₁', e₂.coordChangeL_apply e₂', (e₁.prod e₂).coordChangeL_apply']\n  exacts [rfl, hb, ⟨hb.1.2, hb.2.2⟩, ⟨hb.1.1, hb.2.1⟩]\n\n"}
{"name":"Trivialization.prod_apply","module":"Mathlib.Topology.VectorBundle.Constructions","initialProofState":"𝕜 : Type u_1\nB : Type u_2\ninst✝¹⁷ : NontriviallyNormedField 𝕜\ninst✝¹⁶ : TopologicalSpace B\nF₁ : Type u_3\ninst✝¹⁵ : NormedAddCommGroup F₁\ninst✝¹⁴ : NormedSpace 𝕜 F₁\nE₁ : B → Type u_4\ninst✝¹³ : TopologicalSpace (Bundle.TotalSpace F₁ E₁)\nF₂ : Type u_5\ninst✝¹² : NormedAddCommGroup F₂\ninst✝¹¹ : NormedSpace 𝕜 F₂\nE₂ : B → Type u_6\ninst✝¹⁰ : TopologicalSpace (Bundle.TotalSpace F₂ E₂)\ninst✝⁹ : (x : B) → AddCommMonoid (E₁ x)\ninst✝⁸ : (x : B) → Module 𝕜 (E₁ x)\ninst✝⁷ : (x : B) → AddCommMonoid (E₂ x)\ninst✝⁶ : (x : B) → Module 𝕜 (E₂ x)\ne₁ : Trivialization F₁ Bundle.TotalSpace.proj\ne₂ : Trivialization F₂ Bundle.TotalSpace.proj\ninst✝⁵ : (x : B) → TopologicalSpace (E₁ x)\ninst✝⁴ : (x : B) → TopologicalSpace (E₂ x)\ninst✝³ : FiberBundle F₁ E₁\ninst✝² : FiberBundle F₂ E₂\ninst✝¹ : Trivialization.IsLinear 𝕜 e₁\ninst✝ : Trivialization.IsLinear 𝕜 e₂\nx : B\nhx₁ : Membership.mem e₁.baseSet x\nhx₂ : Membership.mem e₂.baseSet x\nv₁ : E₁ x\nv₂ : E₂ x\n⊢ Eq (↑(e₁.prod e₂) { proj := x, snd := { fst := v₁, snd := v₂ } }) { fst := x, snd := { fst := (Trivialization.continuousLinearEquivAt 𝕜 e₁ x hx₁) v₁, snd := (Trivialization.continuousLinearEquivAt 𝕜 e₂ x hx₂) v₂ } }","decl":"theorem prod_apply [e₁.IsLinear 𝕜] [e₂.IsLinear 𝕜] {x : B} (hx₁ : x ∈ e₁.baseSet)\n    (hx₂ : x ∈ e₂.baseSet) (v₁ : E₁ x) (v₂ : E₂ x) :\n    prod e₁ e₂ ⟨x, (v₁, v₂)⟩ =\n      ⟨x, e₁.continuousLinearEquivAt 𝕜 x hx₁ v₁, e₂.continuousLinearEquivAt 𝕜 x hx₂ v₂⟩ :=\n  rfl\n\n"}
{"name":"VectorBundle.prod","module":"Mathlib.Topology.VectorBundle.Constructions","initialProofState":"𝕜 : Type u_1\nB : Type u_2\ninst✝¹⁷ : NontriviallyNormedField 𝕜\ninst✝¹⁶ : TopologicalSpace B\nF₁ : Type u_3\ninst✝¹⁵ : NormedAddCommGroup F₁\ninst✝¹⁴ : NormedSpace 𝕜 F₁\nE₁ : B → Type u_4\ninst✝¹³ : TopologicalSpace (Bundle.TotalSpace F₁ E₁)\nF₂ : Type u_5\ninst✝¹² : NormedAddCommGroup F₂\ninst✝¹¹ : NormedSpace 𝕜 F₂\nE₂ : B → Type u_6\ninst✝¹⁰ : TopologicalSpace (Bundle.TotalSpace F₂ E₂)\ninst✝⁹ : (x : B) → AddCommMonoid (E₁ x)\ninst✝⁸ : (x : B) → Module 𝕜 (E₁ x)\ninst✝⁷ : (x : B) → AddCommMonoid (E₂ x)\ninst✝⁶ : (x : B) → Module 𝕜 (E₂ x)\ninst✝⁵ : (x : B) → TopologicalSpace (E₁ x)\ninst✝⁴ : (x : B) → TopologicalSpace (E₂ x)\ninst✝³ : FiberBundle F₁ E₁\ninst✝² : FiberBundle F₂ E₂\ninst✝¹ : VectorBundle 𝕜 F₁ E₁\ninst✝ : VectorBundle 𝕜 F₂ E₂\n⊢ VectorBundle 𝕜 (Prod F₁ F₂) fun x => Prod (E₁ x) (E₂ x)","decl":"/-- The product of two vector bundles is a vector bundle. -/\ninstance VectorBundle.prod [VectorBundle 𝕜 F₁ E₁] [VectorBundle 𝕜 F₂ E₂] :\n    VectorBundle 𝕜 (F₁ × F₂) (E₁ ×ᵇ E₂) where\n  trivialization_linear' := by\n    rintro _ ⟨e₁, e₂, he₁, he₂, rfl⟩\n    infer_instance\n  continuousOn_coordChange' := by\n    rintro _ _ ⟨e₁, e₂, he₁, he₂, rfl⟩ ⟨e₁', e₂', he₁', he₂', rfl⟩\n    refine (((continuousOn_coordChange 𝕜 e₁ e₁').mono ?_).prod_mapL 𝕜\n      ((continuousOn_coordChange 𝕜 e₂ e₂').mono ?_)).congr ?_ <;>\n      dsimp only [baseSet_prod, mfld_simps]\n    · mfld_set_tac\n    · mfld_set_tac\n    · rintro b hb\n      rw [ContinuousLinearMap.ext_iff]\n      rintro ⟨v₁, v₂⟩\n      show (e₁.prod e₂).coordChangeL 𝕜 (e₁'.prod e₂') b (v₁, v₂) =\n        (e₁.coordChangeL 𝕜 e₁' b v₁, e₂.coordChangeL 𝕜 e₂' b v₂)\n      rw [e₁.coordChangeL_apply e₁', e₂.coordChangeL_apply e₂', (e₁.prod e₂).coordChangeL_apply']\n      exacts [rfl, hb, ⟨hb.1.2, hb.2.2⟩, ⟨hb.1.1, hb.2.1⟩]\n\n"}
{"name":"Trivialization.continuousLinearEquivAt_prod","module":"Mathlib.Topology.VectorBundle.Constructions","initialProofState":"𝕜 : Type u_1\nB : Type u_2\ninst✝¹⁷ : NontriviallyNormedField 𝕜\ninst✝¹⁶ : TopologicalSpace B\nF₁ : Type u_3\ninst✝¹⁵ : NormedAddCommGroup F₁\ninst✝¹⁴ : NormedSpace 𝕜 F₁\nE₁ : B → Type u_4\ninst✝¹³ : TopologicalSpace (Bundle.TotalSpace F₁ E₁)\nF₂ : Type u_5\ninst✝¹² : NormedAddCommGroup F₂\ninst✝¹¹ : NormedSpace 𝕜 F₂\nE₂ : B → Type u_6\ninst✝¹⁰ : TopologicalSpace (Bundle.TotalSpace F₂ E₂)\ninst✝⁹ : (x : B) → AddCommMonoid (E₁ x)\ninst✝⁸ : (x : B) → Module 𝕜 (E₁ x)\ninst✝⁷ : (x : B) → AddCommMonoid (E₂ x)\ninst✝⁶ : (x : B) → Module 𝕜 (E₂ x)\ninst✝⁵ : (x : B) → TopologicalSpace (E₁ x)\ninst✝⁴ : (x : B) → TopologicalSpace (E₂ x)\ninst✝³ : FiberBundle F₁ E₁\ninst✝² : FiberBundle F₂ E₂\ne₁ : Trivialization F₁ Bundle.TotalSpace.proj\ne₂ : Trivialization F₂ Bundle.TotalSpace.proj\ninst✝¹ : Trivialization.IsLinear 𝕜 e₁\ninst✝ : Trivialization.IsLinear 𝕜 e₂\nx : B\nhx : Membership.mem (e₁.prod e₂).baseSet x\n⊢ Eq (Trivialization.continuousLinearEquivAt 𝕜 (e₁.prod e₂) x hx) ((Trivialization.continuousLinearEquivAt 𝕜 e₁ x ⋯).prod (Trivialization.continuousLinearEquivAt 𝕜 e₂ x ⋯))","decl":"@[simp]\ntheorem Trivialization.continuousLinearEquivAt_prod {e₁ : Trivialization F₁ (π F₁ E₁)}\n    {e₂ : Trivialization F₂ (π F₂ E₂)} [e₁.IsLinear 𝕜] [e₂.IsLinear 𝕜] {x : B}\n    (hx : x ∈ (e₁.prod e₂).baseSet) :\n    (e₁.prod e₂).continuousLinearEquivAt 𝕜 x hx =\n      (e₁.continuousLinearEquivAt 𝕜 x hx.1).prod (e₂.continuousLinearEquivAt 𝕜 x hx.2) := by\n  ext v : 2\n  obtain ⟨v₁, v₂⟩ := v\n  rw [(e₁.prod e₂).continuousLinearEquivAt_apply 𝕜, Trivialization.prod]\n  exact (congr_arg Prod.snd (prod_apply 𝕜 hx.1 hx.2 v₁ v₂) :)\n\n"}
{"name":"Trivialization.pullback_linear","module":"Mathlib.Topology.VectorBundle.Constructions","initialProofState":"𝕜 : Type u_2\nB : Type u_3\nF : Type u_4\nE : B → Type u_5\nB' : Type u_6\ninst✝¹⁰ : TopologicalSpace B'\ninst✝⁹ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝⁸ : NontriviallyNormedField 𝕜\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\ninst✝⁵ : TopologicalSpace B\ninst✝⁴ : (x : B) → AddCommMonoid (E x)\ninst✝³ : (x : B) → Module 𝕜 (E x)\nK : Type u_7\ninst✝² : FunLike K B' B\ninst✝¹ : ContinuousMapClass K B' B\ne : Trivialization F Bundle.TotalSpace.proj\ninst✝ : Trivialization.IsLinear 𝕜 e\nf : K\n⊢ Trivialization.IsLinear 𝕜 (e.pullback f)","decl":"instance Trivialization.pullback_linear (e : Trivialization F (π F E)) [e.IsLinear 𝕜] (f : K) :\n    (Trivialization.pullback (B' := B') e f).IsLinear 𝕜 where\n  linear _ h := e.linear 𝕜 h\n\n"}
{"name":"VectorBundle.pullback","module":"Mathlib.Topology.VectorBundle.Constructions","initialProofState":"𝕜 : Type u_2\nB : Type u_3\nF : Type u_4\nE : B → Type u_5\nB' : Type u_6\ninst✝¹² : TopologicalSpace B'\ninst✝¹¹ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝¹⁰ : NontriviallyNormedField 𝕜\ninst✝⁹ : NormedAddCommGroup F\ninst✝⁸ : NormedSpace 𝕜 F\ninst✝⁷ : TopologicalSpace B\ninst✝⁶ : (x : B) → AddCommMonoid (E x)\ninst✝⁵ : (x : B) → Module 𝕜 (E x)\nK : Type u_7\ninst✝⁴ : FunLike K B' B\ninst✝³ : ContinuousMapClass K B' B\ninst✝² : (x : B) → TopologicalSpace (E x)\ninst✝¹ : FiberBundle F E\ninst✝ : VectorBundle 𝕜 F E\nf : K\n⊢ VectorBundle 𝕜 F (Bundle.Pullback (⇑f) E)","decl":"instance VectorBundle.pullback [∀ x, TopologicalSpace (E x)] [FiberBundle F E] [VectorBundle 𝕜 F E]\n    (f : K) : VectorBundle 𝕜 F ((f : B' → B) *ᵖ E) where\n  trivialization_linear' := by\n    rintro _ ⟨e, he, rfl⟩\n    infer_instance\n  continuousOn_coordChange' := by\n    rintro _ _ ⟨e, he, rfl⟩ ⟨e', he', rfl⟩\n    refine ((continuousOn_coordChange 𝕜 e e').comp\n      (map_continuous f).continuousOn fun b hb => hb).congr ?_\n    rintro b (hb : f b ∈ e.baseSet ∩ e'.baseSet); ext v\n    show ((e.pullback f).coordChangeL 𝕜 (e'.pullback f) b) v = (e.coordChangeL 𝕜 e' (f b)) v\n    rw [e.coordChangeL_apply e' hb, (e.pullback f).coordChangeL_apply' _]\n    exacts [rfl, hb]\n\n"}
