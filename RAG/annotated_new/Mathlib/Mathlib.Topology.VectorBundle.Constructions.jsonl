{"name":"Bundle.Trivial.trivialization.isLinear","module":"Mathlib.Topology.VectorBundle.Constructions","initialProofState":"ğ•œ : Type u_1\nB : Type u_2\nF : Type u_3\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : TopologicalSpace B\nâŠ¢ Trivialization.IsLinear ğ•œ (Bundle.Trivial.trivialization B F)","decl":"instance trivialization.isLinear : (trivialization B F).IsLinear ğ•œ where\n  linear _ _ := âŸ¨fun _ _ => rfl, fun _ _ => rflâŸ©\n\n"}
{"name":"Bundle.Trivial.trivialization.coordChangeL","module":"Mathlib.Topology.VectorBundle.Constructions","initialProofState":"ğ•œ : Type u_1\nB : Type u_2\nF : Type u_3\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : TopologicalSpace B\nb : B\nâŠ¢ Eq (Trivialization.coordChangeL ğ•œ (Bundle.Trivial.trivialization B F) (Bundle.Trivial.trivialization B F) b) (ContinuousLinearEquiv.refl ğ•œ F)","decl":"theorem trivialization.coordChangeL (b : B) :\n    (trivialization B F).coordChangeL ğ•œ (trivialization B F) b =\n      ContinuousLinearEquiv.refl ğ•œ F := by\n  ext v\n  rw [Trivialization.coordChangeL_apply']\n  exacts [rfl, âŸ¨mem_univ _, mem_univ _âŸ©]\n\n"}
{"name":"Bundle.Trivial.vectorBundle","module":"Mathlib.Topology.VectorBundle.Constructions","initialProofState":"ğ•œ : Type u_1\nB : Type u_2\nF : Type u_3\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : TopologicalSpace B\nâŠ¢ VectorBundle ğ•œ F (Bundle.Trivial B F)","decl":"instance vectorBundle : VectorBundle ğ•œ F (Bundle.Trivial B F) where\n  trivialization_linear' e he := by\n    rw [eq_trivialization B F e]\n    infer_instance\n  continuousOn_coordChange' e e' he he' := by\n    obtain rfl := eq_trivialization B F e\n    obtain rfl := eq_trivialization B F e'\n    simp only [trivialization.coordChangeL]\n    exact continuous_const.continuousOn\n\n"}
{"name":"Trivialization.prod.isLinear","module":"Mathlib.Topology.VectorBundle.Constructions","initialProofState":"ğ•œ : Type u_1\nB : Type u_2\ninstâœÂ¹Â³ : NontriviallyNormedField ğ•œ\ninstâœÂ¹Â² : TopologicalSpace B\nFâ‚ : Type u_3\ninstâœÂ¹Â¹ : NormedAddCommGroup Fâ‚\ninstâœÂ¹â° : NormedSpace ğ•œ Fâ‚\nEâ‚ : B â†’ Type u_4\ninstâœâ¹ : TopologicalSpace (Bundle.TotalSpace Fâ‚ Eâ‚)\nFâ‚‚ : Type u_5\ninstâœâ¸ : NormedAddCommGroup Fâ‚‚\ninstâœâ· : NormedSpace ğ•œ Fâ‚‚\nEâ‚‚ : B â†’ Type u_6\ninstâœâ¶ : TopologicalSpace (Bundle.TotalSpace Fâ‚‚ Eâ‚‚)\ninstâœâµ : (x : B) â†’ AddCommMonoid (Eâ‚ x)\ninstâœâ´ : (x : B) â†’ Module ğ•œ (Eâ‚ x)\ninstâœÂ³ : (x : B) â†’ AddCommMonoid (Eâ‚‚ x)\ninstâœÂ² : (x : B) â†’ Module ğ•œ (Eâ‚‚ x)\neâ‚ : Trivialization Fâ‚ Bundle.TotalSpace.proj\neâ‚‚ : Trivialization Fâ‚‚ Bundle.TotalSpace.proj\ninstâœÂ¹ : Trivialization.IsLinear ğ•œ eâ‚\ninstâœ : Trivialization.IsLinear ğ•œ eâ‚‚\nâŠ¢ Trivialization.IsLinear ğ•œ (eâ‚.prod eâ‚‚)","decl":"instance prod.isLinear [eâ‚.IsLinear ğ•œ] [eâ‚‚.IsLinear ğ•œ] : (eâ‚.prod eâ‚‚).IsLinear ğ•œ where\n  linear := fun _ âŸ¨hâ‚, hâ‚‚âŸ© =>\n    (((eâ‚.linear ğ•œ hâ‚).mk' _).prodMap ((eâ‚‚.linear ğ•œ hâ‚‚).mk' _)).isLinear\n\n"}
{"name":"Trivialization.coordChangeL_prod","module":"Mathlib.Topology.VectorBundle.Constructions","initialProofState":"ğ•œ : Type u_1\nB : Type u_2\ninstâœÂ¹âµ : NontriviallyNormedField ğ•œ\ninstâœÂ¹â´ : TopologicalSpace B\nFâ‚ : Type u_3\ninstâœÂ¹Â³ : NormedAddCommGroup Fâ‚\ninstâœÂ¹Â² : NormedSpace ğ•œ Fâ‚\nEâ‚ : B â†’ Type u_4\ninstâœÂ¹Â¹ : TopologicalSpace (Bundle.TotalSpace Fâ‚ Eâ‚)\nFâ‚‚ : Type u_5\ninstâœÂ¹â° : NormedAddCommGroup Fâ‚‚\ninstâœâ¹ : NormedSpace ğ•œ Fâ‚‚\nEâ‚‚ : B â†’ Type u_6\ninstâœâ¸ : TopologicalSpace (Bundle.TotalSpace Fâ‚‚ Eâ‚‚)\ninstâœâ· : (x : B) â†’ AddCommMonoid (Eâ‚ x)\ninstâœâ¶ : (x : B) â†’ Module ğ•œ (Eâ‚ x)\ninstâœâµ : (x : B) â†’ AddCommMonoid (Eâ‚‚ x)\ninstâœâ´ : (x : B) â†’ Module ğ•œ (Eâ‚‚ x)\neâ‚ eâ‚' : Trivialization Fâ‚ Bundle.TotalSpace.proj\neâ‚‚ eâ‚‚' : Trivialization Fâ‚‚ Bundle.TotalSpace.proj\ninstâœÂ³ : Trivialization.IsLinear ğ•œ eâ‚\ninstâœÂ² : Trivialization.IsLinear ğ•œ eâ‚'\ninstâœÂ¹ : Trivialization.IsLinear ğ•œ eâ‚‚\ninstâœ : Trivialization.IsLinear ğ•œ eâ‚‚'\nb : B\nhb : Membership.mem (Inter.inter (eâ‚.prod eâ‚‚).baseSet (eâ‚'.prod eâ‚‚').baseSet) b\nâŠ¢ Eq (â†‘(Trivialization.coordChangeL ğ•œ (eâ‚.prod eâ‚‚) (eâ‚'.prod eâ‚‚') b)) ((â†‘(Trivialization.coordChangeL ğ•œ eâ‚ eâ‚' b)).prodMap â†‘(Trivialization.coordChangeL ğ•œ eâ‚‚ eâ‚‚' b))","decl":"@[simp]\ntheorem coordChangeL_prod [eâ‚.IsLinear ğ•œ] [eâ‚'.IsLinear ğ•œ] [eâ‚‚.IsLinear ğ•œ] [eâ‚‚'.IsLinear ğ•œ] â¦ƒbâ¦„\n    (hb : b âˆˆ (eâ‚.prod eâ‚‚).baseSet âˆ© (eâ‚'.prod eâ‚‚').baseSet) :\n    ((eâ‚.prod eâ‚‚).coordChangeL ğ•œ (eâ‚'.prod eâ‚‚') b : Fâ‚ Ã— Fâ‚‚ â†’L[ğ•œ] Fâ‚ Ã— Fâ‚‚) =\n      (eâ‚.coordChangeL ğ•œ eâ‚' b : Fâ‚ â†’L[ğ•œ] Fâ‚).prodMap (eâ‚‚.coordChangeL ğ•œ eâ‚‚' b) := by\n  rw [ContinuousLinearMap.ext_iff, ContinuousLinearMap.coe_prodMap']\n  rintro âŸ¨vâ‚, vâ‚‚âŸ©\n  show\n    (eâ‚.prod eâ‚‚).coordChangeL ğ•œ (eâ‚'.prod eâ‚‚') b (vâ‚, vâ‚‚) =\n      (eâ‚.coordChangeL ğ•œ eâ‚' b vâ‚, eâ‚‚.coordChangeL ğ•œ eâ‚‚' b vâ‚‚)\n  rw [eâ‚.coordChangeL_apply eâ‚', eâ‚‚.coordChangeL_apply eâ‚‚', (eâ‚.prod eâ‚‚).coordChangeL_apply']\n  exacts [rfl, hb, âŸ¨hb.1.2, hb.2.2âŸ©, âŸ¨hb.1.1, hb.2.1âŸ©]\n\n"}
{"name":"Trivialization.prod_apply","module":"Mathlib.Topology.VectorBundle.Constructions","initialProofState":"ğ•œ : Type u_1\nB : Type u_2\ninstâœÂ¹â· : NontriviallyNormedField ğ•œ\ninstâœÂ¹â¶ : TopologicalSpace B\nFâ‚ : Type u_3\ninstâœÂ¹âµ : NormedAddCommGroup Fâ‚\ninstâœÂ¹â´ : NormedSpace ğ•œ Fâ‚\nEâ‚ : B â†’ Type u_4\ninstâœÂ¹Â³ : TopologicalSpace (Bundle.TotalSpace Fâ‚ Eâ‚)\nFâ‚‚ : Type u_5\ninstâœÂ¹Â² : NormedAddCommGroup Fâ‚‚\ninstâœÂ¹Â¹ : NormedSpace ğ•œ Fâ‚‚\nEâ‚‚ : B â†’ Type u_6\ninstâœÂ¹â° : TopologicalSpace (Bundle.TotalSpace Fâ‚‚ Eâ‚‚)\ninstâœâ¹ : (x : B) â†’ AddCommMonoid (Eâ‚ x)\ninstâœâ¸ : (x : B) â†’ Module ğ•œ (Eâ‚ x)\ninstâœâ· : (x : B) â†’ AddCommMonoid (Eâ‚‚ x)\ninstâœâ¶ : (x : B) â†’ Module ğ•œ (Eâ‚‚ x)\neâ‚ : Trivialization Fâ‚ Bundle.TotalSpace.proj\neâ‚‚ : Trivialization Fâ‚‚ Bundle.TotalSpace.proj\ninstâœâµ : (x : B) â†’ TopologicalSpace (Eâ‚ x)\ninstâœâ´ : (x : B) â†’ TopologicalSpace (Eâ‚‚ x)\ninstâœÂ³ : FiberBundle Fâ‚ Eâ‚\ninstâœÂ² : FiberBundle Fâ‚‚ Eâ‚‚\ninstâœÂ¹ : Trivialization.IsLinear ğ•œ eâ‚\ninstâœ : Trivialization.IsLinear ğ•œ eâ‚‚\nx : B\nhxâ‚ : Membership.mem eâ‚.baseSet x\nhxâ‚‚ : Membership.mem eâ‚‚.baseSet x\nvâ‚ : Eâ‚ x\nvâ‚‚ : Eâ‚‚ x\nâŠ¢ Eq (â†‘(eâ‚.prod eâ‚‚) { proj := x, snd := { fst := vâ‚, snd := vâ‚‚ } }) { fst := x, snd := { fst := (Trivialization.continuousLinearEquivAt ğ•œ eâ‚ x hxâ‚) vâ‚, snd := (Trivialization.continuousLinearEquivAt ğ•œ eâ‚‚ x hxâ‚‚) vâ‚‚ } }","decl":"theorem prod_apply [eâ‚.IsLinear ğ•œ] [eâ‚‚.IsLinear ğ•œ] {x : B} (hxâ‚ : x âˆˆ eâ‚.baseSet)\n    (hxâ‚‚ : x âˆˆ eâ‚‚.baseSet) (vâ‚ : Eâ‚ x) (vâ‚‚ : Eâ‚‚ x) :\n    prod eâ‚ eâ‚‚ âŸ¨x, (vâ‚, vâ‚‚)âŸ© =\n      âŸ¨x, eâ‚.continuousLinearEquivAt ğ•œ x hxâ‚ vâ‚, eâ‚‚.continuousLinearEquivAt ğ•œ x hxâ‚‚ vâ‚‚âŸ© :=\n  rfl\n\n"}
{"name":"VectorBundle.prod","module":"Mathlib.Topology.VectorBundle.Constructions","initialProofState":"ğ•œ : Type u_1\nB : Type u_2\ninstâœÂ¹â· : NontriviallyNormedField ğ•œ\ninstâœÂ¹â¶ : TopologicalSpace B\nFâ‚ : Type u_3\ninstâœÂ¹âµ : NormedAddCommGroup Fâ‚\ninstâœÂ¹â´ : NormedSpace ğ•œ Fâ‚\nEâ‚ : B â†’ Type u_4\ninstâœÂ¹Â³ : TopologicalSpace (Bundle.TotalSpace Fâ‚ Eâ‚)\nFâ‚‚ : Type u_5\ninstâœÂ¹Â² : NormedAddCommGroup Fâ‚‚\ninstâœÂ¹Â¹ : NormedSpace ğ•œ Fâ‚‚\nEâ‚‚ : B â†’ Type u_6\ninstâœÂ¹â° : TopologicalSpace (Bundle.TotalSpace Fâ‚‚ Eâ‚‚)\ninstâœâ¹ : (x : B) â†’ AddCommMonoid (Eâ‚ x)\ninstâœâ¸ : (x : B) â†’ Module ğ•œ (Eâ‚ x)\ninstâœâ· : (x : B) â†’ AddCommMonoid (Eâ‚‚ x)\ninstâœâ¶ : (x : B) â†’ Module ğ•œ (Eâ‚‚ x)\ninstâœâµ : (x : B) â†’ TopologicalSpace (Eâ‚ x)\ninstâœâ´ : (x : B) â†’ TopologicalSpace (Eâ‚‚ x)\ninstâœÂ³ : FiberBundle Fâ‚ Eâ‚\ninstâœÂ² : FiberBundle Fâ‚‚ Eâ‚‚\ninstâœÂ¹ : VectorBundle ğ•œ Fâ‚ Eâ‚\ninstâœ : VectorBundle ğ•œ Fâ‚‚ Eâ‚‚\nâŠ¢ VectorBundle ğ•œ (Prod Fâ‚ Fâ‚‚) fun x => Prod (Eâ‚ x) (Eâ‚‚ x)","decl":"/-- The product of two vector bundles is a vector bundle. -/\ninstance VectorBundle.prod [VectorBundle ğ•œ Fâ‚ Eâ‚] [VectorBundle ğ•œ Fâ‚‚ Eâ‚‚] :\n    VectorBundle ğ•œ (Fâ‚ Ã— Fâ‚‚) (Eâ‚ Ã—áµ‡ Eâ‚‚) where\n  trivialization_linear' := by\n    rintro _ âŸ¨eâ‚, eâ‚‚, heâ‚, heâ‚‚, rflâŸ©\n    infer_instance\n  continuousOn_coordChange' := by\n    rintro _ _ âŸ¨eâ‚, eâ‚‚, heâ‚, heâ‚‚, rflâŸ© âŸ¨eâ‚', eâ‚‚', heâ‚', heâ‚‚', rflâŸ©\n    refine (((continuousOn_coordChange ğ•œ eâ‚ eâ‚').mono ?_).prod_mapL ğ•œ\n      ((continuousOn_coordChange ğ•œ eâ‚‚ eâ‚‚').mono ?_)).congr ?_ <;>\n      dsimp only [baseSet_prod, mfld_simps]\n    Â· mfld_set_tac\n    Â· mfld_set_tac\n    Â· rintro b hb\n      rw [ContinuousLinearMap.ext_iff]\n      rintro âŸ¨vâ‚, vâ‚‚âŸ©\n      show (eâ‚.prod eâ‚‚).coordChangeL ğ•œ (eâ‚'.prod eâ‚‚') b (vâ‚, vâ‚‚) =\n        (eâ‚.coordChangeL ğ•œ eâ‚' b vâ‚, eâ‚‚.coordChangeL ğ•œ eâ‚‚' b vâ‚‚)\n      rw [eâ‚.coordChangeL_apply eâ‚', eâ‚‚.coordChangeL_apply eâ‚‚', (eâ‚.prod eâ‚‚).coordChangeL_apply']\n      exacts [rfl, hb, âŸ¨hb.1.2, hb.2.2âŸ©, âŸ¨hb.1.1, hb.2.1âŸ©]\n\n"}
{"name":"Trivialization.continuousLinearEquivAt_prod","module":"Mathlib.Topology.VectorBundle.Constructions","initialProofState":"ğ•œ : Type u_1\nB : Type u_2\ninstâœÂ¹â· : NontriviallyNormedField ğ•œ\ninstâœÂ¹â¶ : TopologicalSpace B\nFâ‚ : Type u_3\ninstâœÂ¹âµ : NormedAddCommGroup Fâ‚\ninstâœÂ¹â´ : NormedSpace ğ•œ Fâ‚\nEâ‚ : B â†’ Type u_4\ninstâœÂ¹Â³ : TopologicalSpace (Bundle.TotalSpace Fâ‚ Eâ‚)\nFâ‚‚ : Type u_5\ninstâœÂ¹Â² : NormedAddCommGroup Fâ‚‚\ninstâœÂ¹Â¹ : NormedSpace ğ•œ Fâ‚‚\nEâ‚‚ : B â†’ Type u_6\ninstâœÂ¹â° : TopologicalSpace (Bundle.TotalSpace Fâ‚‚ Eâ‚‚)\ninstâœâ¹ : (x : B) â†’ AddCommMonoid (Eâ‚ x)\ninstâœâ¸ : (x : B) â†’ Module ğ•œ (Eâ‚ x)\ninstâœâ· : (x : B) â†’ AddCommMonoid (Eâ‚‚ x)\ninstâœâ¶ : (x : B) â†’ Module ğ•œ (Eâ‚‚ x)\ninstâœâµ : (x : B) â†’ TopologicalSpace (Eâ‚ x)\ninstâœâ´ : (x : B) â†’ TopologicalSpace (Eâ‚‚ x)\ninstâœÂ³ : FiberBundle Fâ‚ Eâ‚\ninstâœÂ² : FiberBundle Fâ‚‚ Eâ‚‚\neâ‚ : Trivialization Fâ‚ Bundle.TotalSpace.proj\neâ‚‚ : Trivialization Fâ‚‚ Bundle.TotalSpace.proj\ninstâœÂ¹ : Trivialization.IsLinear ğ•œ eâ‚\ninstâœ : Trivialization.IsLinear ğ•œ eâ‚‚\nx : B\nhx : Membership.mem (eâ‚.prod eâ‚‚).baseSet x\nâŠ¢ Eq (Trivialization.continuousLinearEquivAt ğ•œ (eâ‚.prod eâ‚‚) x hx) ((Trivialization.continuousLinearEquivAt ğ•œ eâ‚ x â‹¯).prod (Trivialization.continuousLinearEquivAt ğ•œ eâ‚‚ x â‹¯))","decl":"@[simp]\ntheorem Trivialization.continuousLinearEquivAt_prod {eâ‚ : Trivialization Fâ‚ (Ï€ Fâ‚ Eâ‚)}\n    {eâ‚‚ : Trivialization Fâ‚‚ (Ï€ Fâ‚‚ Eâ‚‚)} [eâ‚.IsLinear ğ•œ] [eâ‚‚.IsLinear ğ•œ] {x : B}\n    (hx : x âˆˆ (eâ‚.prod eâ‚‚).baseSet) :\n    (eâ‚.prod eâ‚‚).continuousLinearEquivAt ğ•œ x hx =\n      (eâ‚.continuousLinearEquivAt ğ•œ x hx.1).prod (eâ‚‚.continuousLinearEquivAt ğ•œ x hx.2) := by\n  ext v : 2\n  obtain âŸ¨vâ‚, vâ‚‚âŸ© := v\n  rw [(eâ‚.prod eâ‚‚).continuousLinearEquivAt_apply ğ•œ, Trivialization.prod]\n  exact (congr_arg Prod.snd (prod_apply ğ•œ hx.1 hx.2 vâ‚ vâ‚‚) :)\n\n"}
{"name":"Trivialization.pullback_linear","module":"Mathlib.Topology.VectorBundle.Constructions","initialProofState":"ğ•œ : Type u_2\nB : Type u_3\nF : Type u_4\nE : B â†’ Type u_5\nB' : Type u_6\ninstâœÂ¹â° : TopologicalSpace B'\ninstâœâ¹ : TopologicalSpace (Bundle.TotalSpace F E)\ninstâœâ¸ : NontriviallyNormedField ğ•œ\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\ninstâœâµ : TopologicalSpace B\ninstâœâ´ : (x : B) â†’ AddCommMonoid (E x)\ninstâœÂ³ : (x : B) â†’ Module ğ•œ (E x)\nK : Type u_7\ninstâœÂ² : FunLike K B' B\ninstâœÂ¹ : ContinuousMapClass K B' B\ne : Trivialization F Bundle.TotalSpace.proj\ninstâœ : Trivialization.IsLinear ğ•œ e\nf : K\nâŠ¢ Trivialization.IsLinear ğ•œ (e.pullback f)","decl":"instance Trivialization.pullback_linear (e : Trivialization F (Ï€ F E)) [e.IsLinear ğ•œ] (f : K) :\n    (Trivialization.pullback (B' := B') e f).IsLinear ğ•œ where\n  linear _ h := e.linear ğ•œ h\n\n"}
{"name":"VectorBundle.pullback","module":"Mathlib.Topology.VectorBundle.Constructions","initialProofState":"ğ•œ : Type u_2\nB : Type u_3\nF : Type u_4\nE : B â†’ Type u_5\nB' : Type u_6\ninstâœÂ¹Â² : TopologicalSpace B'\ninstâœÂ¹Â¹ : TopologicalSpace (Bundle.TotalSpace F E)\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : NormedAddCommGroup F\ninstâœâ¸ : NormedSpace ğ•œ F\ninstâœâ· : TopologicalSpace B\ninstâœâ¶ : (x : B) â†’ AddCommMonoid (E x)\ninstâœâµ : (x : B) â†’ Module ğ•œ (E x)\nK : Type u_7\ninstâœâ´ : FunLike K B' B\ninstâœÂ³ : ContinuousMapClass K B' B\ninstâœÂ² : (x : B) â†’ TopologicalSpace (E x)\ninstâœÂ¹ : FiberBundle F E\ninstâœ : VectorBundle ğ•œ F E\nf : K\nâŠ¢ VectorBundle ğ•œ F (Bundle.Pullback (â‡‘f) E)","decl":"instance VectorBundle.pullback [âˆ€ x, TopologicalSpace (E x)] [FiberBundle F E] [VectorBundle ğ•œ F E]\n    (f : K) : VectorBundle ğ•œ F ((f : B' â†’ B) *áµ– E) where\n  trivialization_linear' := by\n    rintro _ âŸ¨e, he, rflâŸ©\n    infer_instance\n  continuousOn_coordChange' := by\n    rintro _ _ âŸ¨e, he, rflâŸ© âŸ¨e', he', rflâŸ©\n    refine ((continuousOn_coordChange ğ•œ e e').comp\n      (map_continuous f).continuousOn fun b hb => hb).congr ?_\n    rintro b (hb : f b âˆˆ e.baseSet âˆ© e'.baseSet); ext v\n    show ((e.pullback f).coordChangeL ğ•œ (e'.pullback f) b) v = (e.coordChangeL ğ•œ e' (f b)) v\n    rw [e.coordChangeL_apply e' hb, (e.pullback f).coordChangeL_apply' _]\n    exacts [rfl, hb]\n\n"}
