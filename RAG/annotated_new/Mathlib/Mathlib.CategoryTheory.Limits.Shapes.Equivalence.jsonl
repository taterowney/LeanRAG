{"name":"CategoryTheory.hasInitial_of_equivalence","module":"Mathlib.CategoryTheory.Limits.Shapes.Equivalence","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ne : CategoryTheory.Functor D C\ninst✝¹ : e.IsEquivalence\ninst✝ : CategoryTheory.Limits.HasInitial C\n⊢ CategoryTheory.Limits.HasInitial D","decl":"theorem hasInitial_of_equivalence (e : D ⥤ C) [e.IsEquivalence] [HasInitial C] : HasInitial D :=\n  Adjunction.hasColimitsOfShape_of_equivalence e\n\n"}
{"name":"CategoryTheory.Equivalence.hasInitial_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Equivalence","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\ne : CategoryTheory.Equivalence C D\n⊢ Iff (CategoryTheory.Limits.HasInitial C) (CategoryTheory.Limits.HasInitial D)","decl":"theorem Equivalence.hasInitial_iff (e : C ≌ D) : HasInitial C ↔ HasInitial D :=\n  ⟨fun (_ : HasInitial C) => hasInitial_of_equivalence e.inverse,\n    fun (_ : HasInitial D) => hasInitial_of_equivalence e.functor⟩\n\n"}
{"name":"CategoryTheory.hasTerminal_of_equivalence","module":"Mathlib.CategoryTheory.Limits.Shapes.Equivalence","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ne : CategoryTheory.Functor D C\ninst✝¹ : e.IsEquivalence\ninst✝ : CategoryTheory.Limits.HasTerminal C\n⊢ CategoryTheory.Limits.HasTerminal D","decl":"theorem hasTerminal_of_equivalence (e : D ⥤ C) [e.IsEquivalence] [HasTerminal C] : HasTerminal D :=\n  Adjunction.hasLimitsOfShape_of_equivalence e\n\n"}
{"name":"CategoryTheory.Equivalence.hasTerminal_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Equivalence","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\ne : CategoryTheory.Equivalence C D\n⊢ Iff (CategoryTheory.Limits.HasTerminal C) (CategoryTheory.Limits.HasTerminal D)","decl":"theorem Equivalence.hasTerminal_iff (e : C ≌ D) : HasTerminal C ↔ HasTerminal D :=\n  ⟨fun (_ : HasTerminal C) => hasTerminal_of_equivalence e.inverse,\n    fun (_ : HasTerminal D) => hasTerminal_of_equivalence e.functor⟩\n\n"}
