{"name":"mellin_eq_fourierIntegral","module":"Mathlib.Analysis.MellinInversion","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Real → E\ns : Complex\n⊢ Eq (mellin f s) (Real.fourierIntegral (fun u => HSMul.hSMul (Real.exp (HMul.hMul (Neg.neg s.re) u)) (f (Real.exp (Neg.neg u)))) (HDiv.hDiv s.im (HMul.hMul 2 Real.pi)))","decl":"theorem mellin_eq_fourierIntegral (f : ℝ → E) {s : ℂ} :\n    mellin f s = 𝓕 (fun (u : ℝ) ↦ (Real.exp (-s.re * u) • f (Real.exp (-u)))) (s.im / (2 * π)) :=\n  calc\n    mellin f s\n      = ∫ (u : ℝ), Complex.exp (-s * u) • f (Real.exp (-u)) := by\n      rw [mellin, ← rexp_neg_image_aux, integral_image_eq_integral_abs_deriv_smul\n        MeasurableSet.univ rexp_neg_deriv_aux rexp_neg_injOn_aux]\n      simp [rexp_cexp_aux]\n    _ = ∫ (u : ℝ), Complex.exp (↑(-2 * π * (u * (s.im / (2 * π)))) * I) •\n        (Real.exp (-s.re * u) • f (Real.exp (-u))) := by\n      congr\n      ext u\n      trans Complex.exp (-s.im * u * I) • (Real.exp (-s.re * u) • f (Real.exp (-u)))\n      · conv => lhs; rw [← re_add_im s]\n        rw [neg_add, add_mul, Complex.exp_add, mul_comm, ← smul_eq_mul, smul_assoc]\n        norm_cast\n        push_cast\n        ring_nf\n      congr\n      rw [mul_comm (-s.im : ℂ) (u : ℂ), mul_comm (-2 * π)]\n      have : 2 * (π : ℂ) ≠ 0 := by norm_num; exact pi_ne_zero\n      field_simp\n    _ = 𝓕 (fun (u : ℝ) ↦ (Real.exp (-s.re * u) • f (Real.exp (-u)))) (s.im / (2 * π)) := by\n      simp [fourierIntegral_eq']\n\n"}
{"name":"mellinInv_eq_fourierIntegralInv","module":"Mathlib.Analysis.MellinInversion","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nσ : Real\nf : Complex → E\nx : Real\nhx : LT.lt 0 x\n⊢ Eq (mellinInv σ f x) (HSMul.hSMul (HPow.hPow (↑x) (Neg.neg ↑σ)) (Real.fourierIntegralInv (fun y => f (HAdd.hAdd (↑σ) (HMul.hMul (HMul.hMul (HMul.hMul 2 ↑Real.pi) ↑y) Complex.I))) (Neg.neg (Real.log x))))","decl":"theorem mellinInv_eq_fourierIntegralInv (σ : ℝ) (f : ℂ → E) {x : ℝ} (hx : 0 < x) :\n    mellinInv σ f x =\n    (x : ℂ) ^ (-σ : ℂ) • 𝓕⁻ (fun (y : ℝ) ↦ f (σ + 2 * π * y * I)) (-Real.log x) := calc\n  mellinInv σ f x\n    = (x : ℂ) ^ (-σ : ℂ) •\n      (∫ (y : ℝ), Complex.exp (2 * π * (y * (-Real.log x)) * I) • f (σ + 2 * π * y * I)) := by\n    rw [mellinInv, one_div, ← abs_of_pos (show 0 < (2 * π)⁻¹ by norm_num; exact pi_pos)]\n    have hx0 : (x : ℂ) ≠ 0 := ofReal_ne_zero.mpr (ne_of_gt hx)\n    simp_rw [neg_add, cpow_add _ _ hx0, mul_smul, integral_smul]\n    rw [smul_comm, ← Measure.integral_comp_mul_left]\n    congr! 3\n    rw [cpow_def_of_ne_zero hx0, ← Complex.ofReal_log hx.le]\n    push_cast\n    ring_nf\n  _ = (x : ℂ) ^ (-σ : ℂ) • 𝓕⁻ (fun (y : ℝ) ↦ f (σ + 2 * π * y * I)) (-Real.log x) := by\n    simp [fourierIntegralInv_eq']\n\n"}
{"name":"mellin_inversion","module":"Mathlib.Analysis.MellinInversion","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nσ : Real\nf : Real → E\nx : Real\nhx : LT.lt 0 x\nhf : MellinConvergent f ↑σ\nhFf : Complex.VerticalIntegrable (mellin f) σ MeasureTheory.MeasureSpace.volume\nhfx : ContinuousAt f x\n⊢ Eq (mellinInv σ (mellin f) x) (f x)","decl":"/-- The inverse Mellin transform of the Mellin transform applied to `x > 0` is x. -/\ntheorem mellin_inversion (σ : ℝ) (f : ℝ → E) {x : ℝ} (hx : 0 < x) (hf : MellinConvergent f σ)\n    (hFf : VerticalIntegrable (mellin f) σ) (hfx : ContinuousAt f x) :\n    mellinInv σ (mellin f) x = f x := by\n  let g := fun (u : ℝ) => Real.exp (-σ * u) • f (Real.exp (-u))\n  replace hf : Integrable g := by\n    rw [MellinConvergent, ← rexp_neg_image_aux, integrableOn_image_iff_integrableOn_abs_deriv_smul\n      MeasurableSet.univ rexp_neg_deriv_aux rexp_neg_injOn_aux] at hf\n    replace hf : Integrable fun (x : ℝ) ↦ cexp (-↑σ * ↑x) • f (rexp (-x)) := by\n      simpa [rexp_cexp_aux] using hf\n    norm_cast at hf\n  replace hFf : Integrable (𝓕 g) := by\n    have h2π : 2 * π ≠ 0 := by norm_num; exact pi_ne_zero\n    have : Integrable (𝓕 (fun u ↦ rexp (-(σ * u)) • f (rexp (-u)))) := by\n      simpa [mellin_eq_fourierIntegral, mul_div_cancel_right₀ _ h2π] using hFf.comp_mul_right' h2π\n    simp_rw [neg_mul_eq_neg_mul] at this\n    exact this\n  replace hfx : ContinuousAt g (-Real.log x) := by\n    refine ContinuousAt.smul (by fun_prop) (ContinuousAt.comp ?_ (by fun_prop))\n    simpa [Real.exp_log hx] using hfx\n  calc\n    mellinInv σ (mellin f) x\n      = mellinInv σ (fun s ↦ 𝓕 g (s.im / (2 * π))) x := by\n      simp [g, mellinInv, mellin_eq_fourierIntegral]\n    _ = (x : ℂ) ^ (-σ : ℂ) • g (-Real.log x) := by\n      rw [mellinInv_eq_fourierIntegralInv _ _ hx, ← hf.fourier_inversion hFf hfx]\n      simp [mul_div_cancel_left₀ _ (show 2 * π ≠ 0 by norm_num; exact pi_ne_zero)]\n    _ = (x : ℂ) ^ (-σ : ℂ) • rexp (σ * Real.log x) • f (rexp (Real.log x)) := by simp [g]\n    _ = f x := by\n      norm_cast\n      rw [mul_comm σ, ← rpow_def_of_pos hx, Real.exp_log hx, ← Complex.ofReal_cpow hx.le]\n      norm_cast\n      rw [← smul_assoc, smul_eq_mul, Real.rpow_neg hx.le,\n        inv_mul_cancel₀ (ne_of_gt (rpow_pos_of_pos hx σ)), one_smul]\n"}
