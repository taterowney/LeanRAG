{"name":"mellin_eq_fourierIntegral","module":"Mathlib.Analysis.MellinInversion","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : Real â†’ E\ns : Complex\nâŠ¢ Eq (mellin f s) (Real.fourierIntegral (fun u => HSMul.hSMul (Real.exp (HMul.hMul (Neg.neg s.re) u)) (f (Real.exp (Neg.neg u)))) (HDiv.hDiv s.im (HMul.hMul 2 Real.pi)))","decl":"theorem mellin_eq_fourierIntegral (f : â„ â†’ E) {s : â„‚} :\n    mellin f s = ğ“• (fun (u : â„) â†¦ (Real.exp (-s.re * u) â€¢ f (Real.exp (-u)))) (s.im / (2 * Ï€)) :=\n  calc\n    mellin f s\n      = âˆ« (u : â„), Complex.exp (-s * u) â€¢ f (Real.exp (-u)) := by\n      rw [mellin, â† rexp_neg_image_aux, integral_image_eq_integral_abs_deriv_smul\n        MeasurableSet.univ rexp_neg_deriv_aux rexp_neg_injOn_aux]\n      simp [rexp_cexp_aux]\n    _ = âˆ« (u : â„), Complex.exp (â†‘(-2 * Ï€ * (u * (s.im / (2 * Ï€)))) * I) â€¢\n        (Real.exp (-s.re * u) â€¢ f (Real.exp (-u))) := by\n      congr\n      ext u\n      trans Complex.exp (-s.im * u * I) â€¢ (Real.exp (-s.re * u) â€¢ f (Real.exp (-u)))\n      Â· conv => lhs; rw [â† re_add_im s]\n        rw [neg_add, add_mul, Complex.exp_add, mul_comm, â† smul_eq_mul, smul_assoc]\n        norm_cast\n        push_cast\n        ring_nf\n      congr\n      rw [mul_comm (-s.im : â„‚) (u : â„‚), mul_comm (-2 * Ï€)]\n      have : 2 * (Ï€ : â„‚) â‰  0 := by norm_num; exact pi_ne_zero\n      field_simp\n    _ = ğ“• (fun (u : â„) â†¦ (Real.exp (-s.re * u) â€¢ f (Real.exp (-u)))) (s.im / (2 * Ï€)) := by\n      simp [fourierIntegral_eq']\n\n"}
{"name":"mellinInv_eq_fourierIntegralInv","module":"Mathlib.Analysis.MellinInversion","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nÏƒ : Real\nf : Complex â†’ E\nx : Real\nhx : LT.lt 0 x\nâŠ¢ Eq (mellinInv Ïƒ f x) (HSMul.hSMul (HPow.hPow (â†‘x) (Neg.neg â†‘Ïƒ)) (Real.fourierIntegralInv (fun y => f (HAdd.hAdd (â†‘Ïƒ) (HMul.hMul (HMul.hMul (HMul.hMul 2 â†‘Real.pi) â†‘y) Complex.I))) (Neg.neg (Real.log x))))","decl":"theorem mellinInv_eq_fourierIntegralInv (Ïƒ : â„) (f : â„‚ â†’ E) {x : â„} (hx : 0 < x) :\n    mellinInv Ïƒ f x =\n    (x : â„‚) ^ (-Ïƒ : â„‚) â€¢ ğ“•â» (fun (y : â„) â†¦ f (Ïƒ + 2 * Ï€ * y * I)) (-Real.log x) := calc\n  mellinInv Ïƒ f x\n    = (x : â„‚) ^ (-Ïƒ : â„‚) â€¢\n      (âˆ« (y : â„), Complex.exp (2 * Ï€ * (y * (-Real.log x)) * I) â€¢ f (Ïƒ + 2 * Ï€ * y * I)) := by\n    rw [mellinInv, one_div, â† abs_of_pos (show 0 < (2 * Ï€)â»Â¹ by norm_num; exact pi_pos)]\n    have hx0 : (x : â„‚) â‰  0 := ofReal_ne_zero.mpr (ne_of_gt hx)\n    simp_rw [neg_add, cpow_add _ _ hx0, mul_smul, integral_smul]\n    rw [smul_comm, â† Measure.integral_comp_mul_left]\n    congr! 3\n    rw [cpow_def_of_ne_zero hx0, â† Complex.ofReal_log hx.le]\n    push_cast\n    ring_nf\n  _ = (x : â„‚) ^ (-Ïƒ : â„‚) â€¢ ğ“•â» (fun (y : â„) â†¦ f (Ïƒ + 2 * Ï€ * y * I)) (-Real.log x) := by\n    simp [fourierIntegralInv_eq']\n\n"}
{"name":"mellin_inversion","module":"Mathlib.Analysis.MellinInversion","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Complex E\ninstâœ : CompleteSpace E\nÏƒ : Real\nf : Real â†’ E\nx : Real\nhx : LT.lt 0 x\nhf : MellinConvergent f â†‘Ïƒ\nhFf : Complex.VerticalIntegrable (mellin f) Ïƒ MeasureTheory.MeasureSpace.volume\nhfx : ContinuousAt f x\nâŠ¢ Eq (mellinInv Ïƒ (mellin f) x) (f x)","decl":"/-- The inverse Mellin transform of the Mellin transform applied to `x > 0` is x. -/\ntheorem mellin_inversion (Ïƒ : â„) (f : â„ â†’ E) {x : â„} (hx : 0 < x) (hf : MellinConvergent f Ïƒ)\n    (hFf : VerticalIntegrable (mellin f) Ïƒ) (hfx : ContinuousAt f x) :\n    mellinInv Ïƒ (mellin f) x = f x := by\n  let g := fun (u : â„) => Real.exp (-Ïƒ * u) â€¢ f (Real.exp (-u))\n  replace hf : Integrable g := by\n    rw [MellinConvergent, â† rexp_neg_image_aux, integrableOn_image_iff_integrableOn_abs_deriv_smul\n      MeasurableSet.univ rexp_neg_deriv_aux rexp_neg_injOn_aux] at hf\n    replace hf : Integrable fun (x : â„) â†¦ cexp (-â†‘Ïƒ * â†‘x) â€¢ f (rexp (-x)) := by\n      simpa [rexp_cexp_aux] using hf\n    norm_cast at hf\n  replace hFf : Integrable (ğ“• g) := by\n    have h2Ï€ : 2 * Ï€ â‰  0 := by norm_num; exact pi_ne_zero\n    have : Integrable (ğ“• (fun u â†¦ rexp (-(Ïƒ * u)) â€¢ f (rexp (-u)))) := by\n      simpa [mellin_eq_fourierIntegral, mul_div_cancel_rightâ‚€ _ h2Ï€] using hFf.comp_mul_right' h2Ï€\n    simp_rw [neg_mul_eq_neg_mul] at this\n    exact this\n  replace hfx : ContinuousAt g (-Real.log x) := by\n    refine ContinuousAt.smul (by fun_prop) (ContinuousAt.comp ?_ (by fun_prop))\n    simpa [Real.exp_log hx] using hfx\n  calc\n    mellinInv Ïƒ (mellin f) x\n      = mellinInv Ïƒ (fun s â†¦ ğ“• g (s.im / (2 * Ï€))) x := by\n      simp [g, mellinInv, mellin_eq_fourierIntegral]\n    _ = (x : â„‚) ^ (-Ïƒ : â„‚) â€¢ g (-Real.log x) := by\n      rw [mellinInv_eq_fourierIntegralInv _ _ hx, â† hf.fourier_inversion hFf hfx]\n      simp [mul_div_cancel_leftâ‚€ _ (show 2 * Ï€ â‰  0 by norm_num; exact pi_ne_zero)]\n    _ = (x : â„‚) ^ (-Ïƒ : â„‚) â€¢ rexp (Ïƒ * Real.log x) â€¢ f (rexp (Real.log x)) := by simp [g]\n    _ = f x := by\n      norm_cast\n      rw [mul_comm Ïƒ, â† rpow_def_of_pos hx, Real.exp_log hx, â† Complex.ofReal_cpow hx.le]\n      norm_cast\n      rw [â† smul_assoc, smul_eq_mul, Real.rpow_neg hx.le,\n        inv_mul_cancelâ‚€ (ne_of_gt (rpow_pos_of_pos hx Ïƒ)), one_smul]\n"}
