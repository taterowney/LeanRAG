{"name":"LieSubmodule.exists_smul_add_of_span_sup_eq_top","module":"Mathlib.Algebra.Lie.Engel","initialProofState":"R : Type u₁\nL : Type u₂\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\nx : L\nhxI : Eq (Max.max (Submodule.span R (Singleton.singleton x)) (LieIdeal.toLieSubalgebra R L I).toSubmodule) Top.top\ny : L\n⊢ Exists fun t => Exists fun z => And (Membership.mem I z) (Eq y (HAdd.hAdd (HSMul.hSMul t x) z))","decl":"theorem exists_smul_add_of_span_sup_eq_top (y : L) : ∃ t : R, ∃ z ∈ I, y = t • x + z := by\n  have hy : y ∈ (⊤ : Submodule R L) := Submodule.mem_top\n  simp only [← hxI, Submodule.mem_sup, Submodule.mem_span_singleton] at hy\n  obtain ⟨-, ⟨t, rfl⟩, z, hz, rfl⟩ := hy\n  exact ⟨t, z, hz, rfl⟩\n\n"}
{"name":"LieSubmodule.lie_top_eq_of_span_sup_eq_top","module":"Mathlib.Algebra.Lie.Engel","initialProofState":"R : Type u₁\nL : Type u₂\nM : Type u₄\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nI : LieIdeal R L\nx : L\nhxI : Eq (Max.max (Submodule.span R (Singleton.singleton x)) (LieIdeal.toLieSubalgebra R L I).toSubmodule) Top.top\nN : LieSubmodule R L M\n⊢ Eq (↑(Bracket.bracket Top.top N)) (Max.max (Submodule.map ((LieModule.toEnd R L M) x) ↑N) ↑(Bracket.bracket I N))","decl":"theorem lie_top_eq_of_span_sup_eq_top (N : LieSubmodule R L M) :\n    (↑⁅(⊤ : LieIdeal R L), N⁆ : Submodule R M) =\n      (N : Submodule R M).map (toEnd R L M x) ⊔ (↑⁅I, N⁆ : Submodule R M) := by\n  simp only [lieIdeal_oper_eq_linear_span', Submodule.sup_span, mem_top, exists_prop,\n    true_and, Submodule.map_coe, toEnd_apply_apply]\n  refine le_antisymm (Submodule.span_le.mpr ?_) (Submodule.span_mono fun z hz => ?_)\n  · rintro z ⟨y, n, hn : n ∈ N, rfl⟩\n    obtain ⟨t, z, hz, rfl⟩ := exists_smul_add_of_span_sup_eq_top hxI y\n    simp only [SetLike.mem_coe, Submodule.span_union, Submodule.mem_sup]\n    exact\n      ⟨t • ⁅x, n⁆, Submodule.subset_span ⟨t • n, N.smul_mem' t hn, lie_smul t x n⟩, ⁅z, n⁆,\n        Submodule.subset_span ⟨z, hz, n, hn, rfl⟩, by simp⟩\n  · rcases hz with (⟨m, hm, rfl⟩ | ⟨y, -, m, hm, rfl⟩)\n    exacts [⟨x, m, hm, rfl⟩, ⟨y, m, hm, rfl⟩]\n\n"}
{"name":"LieSubmodule.lcs_le_lcs_of_is_nilpotent_span_sup_eq_top","module":"Mathlib.Algebra.Lie.Engel","initialProofState":"R : Type u₁\nL : Type u₂\nM : Type u₄\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nI : LieIdeal R L\nx : L\nhxI : Eq (Max.max (Submodule.span R (Singleton.singleton x)) (LieIdeal.toLieSubalgebra R L I).toSubmodule) Top.top\nn i j : Nat\nhxn : Eq (HPow.hPow ((LieModule.toEnd R L M) x) n) 0\nhIM : LE.le (LieModule.lowerCentralSeries R L M i) (I.lcs M j)\n⊢ LE.le (LieModule.lowerCentralSeries R L M (HAdd.hAdd i n)) (I.lcs M (HAdd.hAdd j 1))","decl":"theorem lcs_le_lcs_of_is_nilpotent_span_sup_eq_top {n i j : ℕ}\n    (hxn : toEnd R L M x ^ n = 0) (hIM : lowerCentralSeries R L M i ≤ I.lcs M j) :\n    lowerCentralSeries R L M (i + n) ≤ I.lcs M (j + 1) := by\n  suffices\n    ∀ l,\n      ((⊤ : LieIdeal R L).lcs M (i + l) : Submodule R M) ≤\n        (I.lcs M j : Submodule R M).map (toEnd R L M x ^ l) ⊔\n          (I.lcs M (j + 1) : Submodule R M)\n    by simpa only [bot_sup_eq, LieIdeal.incl_coe, Submodule.map_zero, hxn] using this n\n  intro l\n  induction l with\n  | zero =>\n    simp only [add_zero, LieIdeal.lcs_succ, pow_zero, LinearMap.one_eq_id,\n      Submodule.map_id]\n    exact le_sup_of_le_left hIM\n  | succ l ih =>\n    simp only [LieIdeal.lcs_succ, i.add_succ l, lie_top_eq_of_span_sup_eq_top hxI, sup_le_iff]\n    refine ⟨(Submodule.map_mono ih).trans ?_, le_sup_of_le_right ?_⟩\n    · rw [Submodule.map_sup, ← Submodule.map_comp, ← LinearMap.mul_eq_comp, ← pow_succ', ←\n        I.lcs_succ]\n      exact sup_le_sup_left coe_map_toEnd_le _\n    · refine le_trans (mono_lie_right I ?_) (mono_lie_right I hIM)\n      exact antitone_lowerCentralSeries R L M le_self_add\n\n"}
{"name":"LieSubmodule.isNilpotentOfIsNilpotentSpanSupEqTop","module":"Mathlib.Algebra.Lie.Engel","initialProofState":"R : Type u₁\nL : Type u₂\nM : Type u₄\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nI : LieIdeal R L\nx : L\nhxI : Eq (Max.max (Submodule.span R (Singleton.singleton x)) (LieIdeal.toLieSubalgebra R L I).toSubmodule) Top.top\nhnp : IsNilpotent ((LieModule.toEnd R L M) x)\nhIM : LieModule.IsNilpotent (Subtype fun x => Membership.mem I x) M\n⊢ LieModule.IsNilpotent L M","decl":"theorem isNilpotentOfIsNilpotentSpanSupEqTop (hnp : IsNilpotent <| toEnd R L M x)\n    (hIM : IsNilpotent I M) : IsNilpotent L M := by\n  obtain ⟨n, hn⟩ := hnp\n  obtain ⟨k, hk⟩ := IsNilpotent.nilpotent R I M\n  have hk' : I.lcs M k = ⊥ := by\n    simp only [← toSubmodule_inj, I.coe_lcs_eq, hk, bot_toSubmodule]\n  suffices ∀ l, lowerCentralSeries R L M (l * n) ≤ I.lcs M l by\n    rw [isNilpotent_iff R]\n    use k * n\n    simpa [hk'] using this k\n  intro l\n  induction l with\n  | zero => simp\n  | succ l ih => exact (l.succ_mul n).symm ▸ lcs_le_lcs_of_is_nilpotent_span_sup_eq_top hxI hn ih\n\n"}
{"name":"LieAlgebra.isEngelian_of_subsingleton","module":"Mathlib.Algebra.Lie.Engel","initialProofState":"R : Type u₁\nL : Type u₂\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\ninst✝ : Subsingleton L\n⊢ LieAlgebra.IsEngelian R L","decl":"theorem LieAlgebra.isEngelian_of_subsingleton [Subsingleton L] : LieAlgebra.IsEngelian R L := by\n  intro M _i1 _i2 _i3 _i4 _h\n  use 1\n  simp\n\n"}
{"name":"Function.Surjective.isEngelian","module":"Mathlib.Algebra.Lie.Engel","initialProofState":"R : Type u₁\nL : Type u₂\nL₂ : Type u₃\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\nf : LieHom R L L₂\nhf : Function.Surjective ⇑f\nh : LieAlgebra.IsEngelian R L\n⊢ LieAlgebra.IsEngelian R L₂","decl":"theorem Function.Surjective.isEngelian {f : L →ₗ⁅R⁆ L₂} (hf : Function.Surjective f)\n    (h : LieAlgebra.IsEngelian.{u₁, u₂, u₄} R L) : LieAlgebra.IsEngelian.{u₁, u₃, u₄} R L₂ := by\n  intro M _i1 _i2 _i3 _i4 h'\n  letI : LieRingModule L M := LieRingModule.compLieHom M f\n  letI : LieModule R L M := compLieHom M f\n  have hnp : ∀ x, IsNilpotent (toEnd R L M x) := fun x => h' (f x)\n  have surj_id : Function.Surjective (LinearMap.id : M →ₗ[R] M) := Function.surjective_id\n  haveI : LieModule.IsNilpotent L M := h M hnp\n  apply hf.lieModuleIsNilpotent surj_id\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10745): was `simp`\n  intros; simp only [LinearMap.id_coe, id_eq]; rfl\n\n"}
{"name":"LieEquiv.isEngelian_iff","module":"Mathlib.Algebra.Lie.Engel","initialProofState":"R : Type u₁\nL : Type u₂\nL₂ : Type u₃\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\ne : LieEquiv R L L₂\n⊢ Iff (LieAlgebra.IsEngelian R L) (LieAlgebra.IsEngelian R L₂)","decl":"theorem LieEquiv.isEngelian_iff (e : L ≃ₗ⁅R⁆ L₂) :\n    LieAlgebra.IsEngelian.{u₁, u₂, u₄} R L ↔ LieAlgebra.IsEngelian.{u₁, u₃, u₄} R L₂ :=\n  ⟨e.surjective.isEngelian, e.symm.surjective.isEngelian⟩\n\n-- Porting note: changed statement from `∃ ∃ ..` to `∃ .. ∧ ..`\n"}
{"name":"LieAlgebra.exists_engelian_lieSubalgebra_of_lt_normalizer","module":"Mathlib.Algebra.Lie.Engel","initialProofState":"R : Type u₁\nL : Type u₂\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nK : LieSubalgebra R L\nhK₁ : LieAlgebra.IsEngelian R (Subtype fun x => Membership.mem K x)\nhK₂ : LT.lt K K.normalizer\n⊢ Exists fun K' => And (LieAlgebra.IsEngelian R (Subtype fun x => Membership.mem K' x)) (LT.lt K K')","decl":"theorem LieAlgebra.exists_engelian_lieSubalgebra_of_lt_normalizer {K : LieSubalgebra R L}\n    (hK₁ : LieAlgebra.IsEngelian.{u₁, u₂, u₄} R K) (hK₂ : K < K.normalizer) :\n    ∃ (K' : LieSubalgebra R L), LieAlgebra.IsEngelian.{u₁, u₂, u₄} R K' ∧ K < K' := by\n  obtain ⟨x, hx₁, hx₂⟩ := SetLike.exists_of_lt hK₂\n  let K' : LieSubalgebra R L :=\n    { (R ∙ x) ⊔ (K : Submodule R L) with\n      lie_mem' := fun {y z} => LieSubalgebra.lie_mem_sup_of_mem_normalizer hx₁ }\n  have hxK' : x ∈ K' := Submodule.mem_sup_left (Submodule.subset_span (Set.mem_singleton _))\n  have hKK' : K ≤ K' := (LieSubalgebra.toSubmodule_le_toSubmodule K K').mp le_sup_right\n  have hK' : K' ≤ K.normalizer := by\n    rw [← LieSubalgebra.toSubmodule_le_toSubmodule]\n    exact sup_le ((Submodule.span_singleton_le_iff_mem _ _).mpr hx₁) hK₂.le\n  refine ⟨K', ?_, lt_iff_le_and_ne.mpr ⟨hKK', fun contra => hx₂ (contra.symm ▸ hxK')⟩⟩\n  intro M _i1 _i2 _i3 _i4 h\n  obtain ⟨I, hI₁ : (I : LieSubalgebra R K') = LieSubalgebra.ofLe hKK'⟩ :=\n    LieSubalgebra.exists_nested_lieIdeal_ofLe_normalizer hKK' hK'\n  have hI₂ : (R ∙ (⟨x, hxK'⟩ : K')) ⊔ (LieSubmodule.toSubmodule I) = ⊤ := by\n    rw [← LieIdeal.toLieSubalgebra_toSubmodule R K' I, hI₁]\n    apply Submodule.map_injective_of_injective (K' : Submodule R L).injective_subtype\n    simp only [LieSubalgebra.coe_ofLe, Submodule.map_sup, Submodule.map_subtype_range_inclusion,\n      Submodule.map_top, Submodule.range_subtype]\n    rw [Submodule.map_subtype_span_singleton]\n  have e : K ≃ₗ⁅R⁆ I :=\n    (LieSubalgebra.equivOfLe hKK').trans\n      (LieEquiv.ofEq _ _ ((LieSubalgebra.coe_set_eq _ _).mpr hI₁.symm))\n  have hI₃ : LieAlgebra.IsEngelian R I := e.isEngelian_iff.mp hK₁\n  exact LieSubmodule.isNilpotentOfIsNilpotentSpanSupEqTop hI₂ (h _) (hI₃ _ fun x => h x)\n\n"}
{"name":"LieAlgebra.isEngelian_of_isNoetherian","module":"Mathlib.Algebra.Lie.Engel","initialProofState":"R : Type u₁\nL : Type u₂\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\ninst✝ : IsNoetherian R L\n⊢ LieAlgebra.IsEngelian R L","decl":"/-- *Engel's theorem*.\n\nNote that this implies all traditional forms of Engel's theorem via\n`LieModule.nontrivial_max_triv_of_isNilpotent`, `LieModule.isNilpotent_iff_forall`,\n`LieAlgebra.isNilpotent_iff_forall`. -/\ntheorem LieAlgebra.isEngelian_of_isNoetherian [IsNoetherian R L] : LieAlgebra.IsEngelian R L := by\n  intro M _i1 _i2 _i3 _i4 h\n  rw [← isNilpotent_range_toEnd_iff R]\n  let L' := (toEnd R L M).range\n  replace h : ∀ y : L', _root_.IsNilpotent (y : Module.End R M) := by\n    rintro ⟨-, ⟨y, rfl⟩⟩\n    simp [h]\n  change LieModule.IsNilpotent L' M\n  let s := {K : LieSubalgebra R L' | LieAlgebra.IsEngelian R K}\n  have hs : s.Nonempty := ⟨⊥, LieAlgebra.isEngelian_of_subsingleton⟩\n  suffices ⊤ ∈ s by\n    rw [← isNilpotent_of_top_iff (R := R)]\n    apply this M\n    simp [LieSubalgebra.toEnd_eq, h]\n  have : ∀ K ∈ s, K ≠ ⊤ → ∃ K' ∈ s, K < K' := by\n    rintro K (hK₁ : LieAlgebra.IsEngelian R K) hK₂\n    apply LieAlgebra.exists_engelian_lieSubalgebra_of_lt_normalizer hK₁\n    apply lt_of_le_of_ne K.le_normalizer\n    rw [Ne, eq_comm, K.normalizer_eq_self_iff, ← Ne, ←\n      LieSubmodule.nontrivial_iff_ne_bot R K]\n    have : Nontrivial (L' ⧸ K.toLieSubmodule) := by\n      replace hK₂ : K.toLieSubmodule ≠ ⊤ := by\n        rwa [Ne, ← LieSubmodule.toSubmodule_inj, K.coe_toLieSubmodule,\n          LieSubmodule.top_toSubmodule, ← LieSubalgebra.top_toSubmodule,\n          K.toSubmodule_inj]\n      exact Submodule.Quotient.nontrivial_of_lt_top _ hK₂.lt_top\n    have : LieModule.IsNilpotent K (L' ⧸ K.toLieSubmodule) := by\n      -- Porting note: was refine' hK₁ _ fun x => _\n      apply hK₁\n      intro x\n      have hx := LieAlgebra.isNilpotent_ad_of_isNilpotent (h x)\n      apply Module.End.IsNilpotent.mapQ ?_ hx\n      -- Porting note: mathlib3 solved this on its own with `submodule.mapq_linear._proof_5`\n      intro X HX\n      simp only [LieSubalgebra.coe_toLieSubmodule, LieSubalgebra.mem_toSubmodule] at HX\n      simp only [LieSubalgebra.coe_toLieSubmodule, Submodule.mem_comap, ad_apply,\n        LieSubalgebra.mem_toSubmodule]\n      exact LieSubalgebra.lie_mem K x.prop HX\n    exact nontrivial_max_triv_of_isNilpotent R K (L' ⧸ K.toLieSubmodule)\n  haveI _i5 : IsNoetherian R L' := by\n    -- Porting note: was\n    -- isNoetherian_of_surjective L _ (LinearMap.range_rangeRestrict (toEnd R L M))\n    -- abusing the relation between `LieHom.rangeRestrict` and `LinearMap.rangeRestrict`\n    refine isNoetherian_of_surjective L (LieHom.rangeRestrict (toEnd R L M)) ?_\n    simp only [LieHom.range_toSubmodule, LieHom.coe_toLinearMap,\n      LinearMap.range_eq_top]\n    exact LieHom.surjective_rangeRestrict (toEnd R L M)\n  obtain ⟨K, hK₁, hK₂⟩ := (LieSubalgebra.wellFoundedGT_of_noetherian R L').wf.has_min s hs\n  have hK₃ : K = ⊤ := by\n    by_contra contra\n    obtain ⟨K', hK'₁, hK'₂⟩ := this K hK₁ contra\n    exact hK₂ K' hK'₁ hK'₂\n  exact hK₃ ▸ hK₁\n\n"}
{"name":"LieModule.isNilpotent_iff_forall","module":"Mathlib.Algebra.Lie.Engel","initialProofState":"R : Type u₁\nL : Type u₂\nM : Type u₄\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : IsNoetherian R L\n⊢ Iff (LieModule.IsNilpotent L M) (∀ (x : L), IsNilpotent ((LieModule.toEnd R L M) x))","decl":"/-- Engel's theorem.\n\nSee also `LieModule.isNilpotent_iff_forall'` which assumes that `M` is Noetherian instead of `L`. -/\ntheorem LieModule.isNilpotent_iff_forall [IsNoetherian R L] :\n    LieModule.IsNilpotent L M ↔ ∀ x, _root_.IsNilpotent <| toEnd R L M x :=\n  ⟨fun _ ↦ isNilpotent_toEnd_of_isNilpotent R L M,\n   fun h => LieAlgebra.isEngelian_of_isNoetherian M h⟩\n\n"}
{"name":"LieModule.isNilpotent_iff_forall'","module":"Mathlib.Algebra.Lie.Engel","initialProofState":"R : Type u₁\nL : Type u₂\nM : Type u₄\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : IsNoetherian R M\n⊢ Iff (LieModule.IsNilpotent L M) (∀ (x : L), IsNilpotent ((LieModule.toEnd R L M) x))","decl":"/-- Engel's theorem. -/\ntheorem LieModule.isNilpotent_iff_forall' [IsNoetherian R M] :\n    LieModule.IsNilpotent L M ↔ ∀ x, _root_.IsNilpotent <| toEnd R L M x := by\n  rw [← isNilpotent_range_toEnd_iff (R := R), LieModule.isNilpotent_iff_forall (R := R)]; simp\n\n"}
{"name":"LieAlgebra.isNilpotent_iff_forall","module":"Mathlib.Algebra.Lie.Engel","initialProofState":"R : Type u₁\nL : Type u₂\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\ninst✝ : IsNoetherian R L\n⊢ Iff (LieRing.IsNilpotent L) (∀ (x : L), IsNilpotent ((LieAlgebra.ad R L) x))","decl":"/-- Engel's theorem. -/\ntheorem LieAlgebra.isNilpotent_iff_forall [IsNoetherian R L] :\n    LieRing.IsNilpotent L ↔ ∀ x, _root_.IsNilpotent <| LieAlgebra.ad R L x :=\n  LieModule.isNilpotent_iff_forall\n\n"}
