{"name":"PowerSeries.coeff_derivativeFun","module":"Mathlib.RingTheory.PowerSeries.Derivative","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nf : PowerSeries R\nn : Nat\n⊢ Eq ((PowerSeries.coeff R n) f.derivativeFun) (HMul.hMul ((PowerSeries.coeff R (HAdd.hAdd n 1)) f) (HAdd.hAdd (↑n) 1))","decl":"theorem coeff_derivativeFun (f : R⟦X⟧) (n : ℕ) :\n    coeff R n f.derivativeFun = coeff R (n + 1) f * (n + 1) := by\n  rw [derivativeFun, coeff_mk]\n\n"}
{"name":"PowerSeries.derivativeFun_coe","module":"Mathlib.RingTheory.PowerSeries.Derivative","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nf : Polynomial R\n⊢ Eq (↑f).derivativeFun ↑(Polynomial.derivative f)","decl":"theorem derivativeFun_coe (f : R[X]) : (f : R⟦X⟧).derivativeFun = derivative f := by\n  ext\n  rw [coeff_derivativeFun, coeff_coe, coeff_coe, coeff_derivative]\n\n"}
{"name":"PowerSeries.derivativeFun_add","module":"Mathlib.RingTheory.PowerSeries.Derivative","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nf g : PowerSeries R\n⊢ Eq (HAdd.hAdd f g).derivativeFun (HAdd.hAdd f.derivativeFun g.derivativeFun)","decl":"theorem derivativeFun_add (f g : R⟦X⟧) :\n    derivativeFun (f + g) = derivativeFun f + derivativeFun g := by\n  ext\n  rw [coeff_derivativeFun, map_add, map_add, coeff_derivativeFun,\n    coeff_derivativeFun, add_mul]\n\n"}
{"name":"PowerSeries.derivativeFun_C","module":"Mathlib.RingTheory.PowerSeries.Derivative","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nr : R\n⊢ Eq ((PowerSeries.C R) r).derivativeFun 0","decl":"theorem derivativeFun_C (r : R) : derivativeFun (C R r) = 0 := by\n  ext n\n  -- Note that `map_zero` didn't get picked up, apparently due to a missing `FunLike.coe`\n  rw [coeff_derivativeFun, coeff_succ_C, zero_mul, (coeff R n).map_zero]\n\n"}
{"name":"PowerSeries.trunc_derivativeFun","module":"Mathlib.RingTheory.PowerSeries.Derivative","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nf : PowerSeries R\nn : Nat\n⊢ Eq (PowerSeries.trunc n f.derivativeFun) (Polynomial.derivative (PowerSeries.trunc (HAdd.hAdd n 1) f))","decl":"theorem trunc_derivativeFun (f : R⟦X⟧) (n : ℕ) :\n    trunc n f.derivativeFun = derivative (trunc (n + 1) f) := by\n  ext d\n  rw [coeff_trunc]\n  split_ifs with h\n  · have : d + 1 < n + 1 := succ_lt_succ_iff.2 h\n    rw [coeff_derivativeFun, coeff_derivative, coeff_trunc, if_pos this]\n  · have : ¬d + 1 < n + 1 := by rwa [succ_lt_succ_iff]\n    rw [coeff_derivative, coeff_trunc, if_neg this, zero_mul]\n\n--A special case of `derivativeFun_mul`, used in its proof.\n"}
{"name":"PowerSeries.derivativeFun_mul","module":"Mathlib.RingTheory.PowerSeries.Derivative","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nf g : PowerSeries R\n⊢ Eq (HMul.hMul f g).derivativeFun (HAdd.hAdd (HSMul.hSMul f g.derivativeFun) (HSMul.hSMul g f.derivativeFun))","decl":"/-- **Leibniz rule for formal power series**. -/\ntheorem derivativeFun_mul (f g : R⟦X⟧) :\n    derivativeFun (f * g) = f • g.derivativeFun + g • f.derivativeFun := by\n  ext n\n  have h₁ : n < n + 1 := lt_succ_self n\n  have h₂ : n < n + 1 + 1 := Nat.lt_add_right _ h₁\n  rw [coeff_derivativeFun, map_add, coeff_mul_eq_coeff_trunc_mul_trunc _ _ (lt_succ_self _),\n    smul_eq_mul, smul_eq_mul, coeff_mul_eq_coeff_trunc_mul_trunc₂ g f.derivativeFun h₂ h₁,\n    coeff_mul_eq_coeff_trunc_mul_trunc₂ f g.derivativeFun h₂ h₁, trunc_derivativeFun,\n    trunc_derivativeFun, ← map_add, ← derivativeFun_coe_mul_coe, coeff_derivativeFun]\n\n"}
{"name":"PowerSeries.derivativeFun_one","module":"Mathlib.RingTheory.PowerSeries.Derivative","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (PowerSeries.derivativeFun 1) 0","decl":"theorem derivativeFun_one : derivativeFun (1 : R⟦X⟧) = 0 := by\n  rw [← map_one (C R), derivativeFun_C (1 : R)]\n\n"}
{"name":"PowerSeries.derivativeFun_smul","module":"Mathlib.RingTheory.PowerSeries.Derivative","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nr : R\nf : PowerSeries R\n⊢ Eq (HSMul.hSMul r f).derivativeFun (HSMul.hSMul r f.derivativeFun)","decl":"theorem derivativeFun_smul (r : R) (f : R⟦X⟧) : derivativeFun (r • f) = r • derivativeFun f := by\n  rw [smul_eq_C_mul, smul_eq_C_mul, derivativeFun_mul, derivativeFun_C, smul_zero, add_zero,\n    smul_eq_mul]\n\n"}
{"name":"PowerSeries.derivative_C","module":"Mathlib.RingTheory.PowerSeries.Derivative","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nr : R\n⊢ Eq ((PowerSeries.derivative R) ((PowerSeries.C R) r)) 0","decl":"@[simp] theorem derivative_C (r : R) : d⁄dX R (C R r) = 0 := derivativeFun_C r\n\n"}
{"name":"PowerSeries.coeff_derivative","module":"Mathlib.RingTheory.PowerSeries.Derivative","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nf : PowerSeries R\nn : Nat\n⊢ Eq ((PowerSeries.coeff R n) ((PowerSeries.derivative R) f)) (HMul.hMul ((PowerSeries.coeff R (HAdd.hAdd n 1)) f) (HAdd.hAdd (↑n) 1))","decl":"theorem coeff_derivative (f : R⟦X⟧) (n : ℕ) :\n    coeff R n (d⁄dX R f) = coeff R (n + 1) f * (n + 1) := coeff_derivativeFun f n\n\n"}
{"name":"PowerSeries.derivative_coe","module":"Mathlib.RingTheory.PowerSeries.Derivative","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nf : Polynomial R\n⊢ Eq ((PowerSeries.derivative R) ↑f) ↑(Polynomial.derivative f)","decl":"theorem derivative_coe (f : R[X]) : d⁄dX R f = Polynomial.derivative f := derivativeFun_coe f\n\n"}
{"name":"PowerSeries.derivative_X","module":"Mathlib.RingTheory.PowerSeries.Derivative","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq ((PowerSeries.derivative R) PowerSeries.X) 1","decl":"@[simp] theorem derivative_X : d⁄dX R (X : R⟦X⟧) = 1 := by\n  ext\n  rw [coeff_derivative, coeff_one, coeff_X, boole_mul]\n  simp_rw [add_left_eq_self]\n  split_ifs with h\n  · rw [h, cast_zero, zero_add]\n  · rfl\n\n"}
{"name":"PowerSeries.trunc_derivative","module":"Mathlib.RingTheory.PowerSeries.Derivative","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nf : PowerSeries R\nn : Nat\n⊢ Eq (PowerSeries.trunc n ((PowerSeries.derivative R) f)) (Polynomial.derivative (PowerSeries.trunc (HAdd.hAdd n 1) f))","decl":"theorem trunc_derivative (f : R⟦X⟧) (n : ℕ) :\n    trunc n (d⁄dX R f) = Polynomial.derivative (trunc (n + 1) f) :=\n  trunc_derivativeFun ..\n\n"}
{"name":"PowerSeries.trunc_derivative'","module":"Mathlib.RingTheory.PowerSeries.Derivative","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nf : PowerSeries R\nn : Nat\n⊢ Eq (PowerSeries.trunc (HSub.hSub n 1) ((PowerSeries.derivative R) f)) (Polynomial.derivative (PowerSeries.trunc n f))","decl":"theorem trunc_derivative' (f : R⟦X⟧) (n : ℕ) :\n    trunc (n-1) (d⁄dX R f) = Polynomial.derivative (trunc n f) := by\n  cases n with\n  | zero =>\n    simp\n  | succ n =>\n    rw [succ_sub_one, trunc_derivative]\n\n"}
{"name":"PowerSeries.derivative.ext","module":"Mathlib.RingTheory.PowerSeries.Derivative","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : NoZeroSMulDivisors Nat R\nf g : PowerSeries R\nhD : Eq ((PowerSeries.derivative R) f) ((PowerSeries.derivative R) g)\nhc : Eq ((PowerSeries.constantCoeff R) f) ((PowerSeries.constantCoeff R) g)\n⊢ Eq f g","decl":"/-- If `f` and `g` have the same constant term and derivative, then they are equal. -/\ntheorem derivative.ext {R} [CommRing R] [NoZeroSMulDivisors ℕ R] {f g} (hD : d⁄dX R f = d⁄dX R g)\n    (hc : constantCoeff R f = constantCoeff R g) : f = g := by\n  ext n\n  cases n with\n  | zero =>\n    rw [coeff_zero_eq_constantCoeff, hc]\n  | succ n =>\n    have equ : coeff R n (d⁄dX R f) = coeff R n (d⁄dX R g) := by rw [hD]\n    rwa [coeff_derivative, coeff_derivative, ← cast_succ, mul_comm, ← nsmul_eq_mul,\n      mul_comm, ← nsmul_eq_mul, smul_right_inj n.succ_ne_zero] at equ\n\n"}
{"name":"PowerSeries.derivative_inv","module":"Mathlib.RingTheory.PowerSeries.Derivative","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nf : Units (PowerSeries R)\n⊢ Eq ((PowerSeries.derivative R) ↑(Inv.inv f)) (HMul.hMul (Neg.neg (HPow.hPow (↑(Inv.inv f)) 2)) ((PowerSeries.derivative R) ↑f))","decl":"@[simp] theorem derivative_inv {R} [CommRing R] (f : R⟦X⟧ˣ) :\n    d⁄dX R ↑f⁻¹ = -(↑f⁻¹ : R⟦X⟧) ^ 2 * d⁄dX R f := by\n  apply Derivation.leibniz_of_mul_eq_one\n  simp\n\n"}
{"name":"PowerSeries.derivative_invOf","module":"Mathlib.RingTheory.PowerSeries.Derivative","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nf : PowerSeries R\ninst✝ : Invertible f\n⊢ Eq ((PowerSeries.derivative R) (Invertible.invOf f)) (HMul.hMul (Neg.neg (HPow.hPow (Invertible.invOf f) 2)) ((PowerSeries.derivative R) f))","decl":"@[simp] theorem derivative_invOf {R} [CommRing R] (f : R⟦X⟧) [Invertible f] :\n    d⁄dX R ⅟f = - ⅟f ^ 2 * d⁄dX R f := by\n  rw [Derivation.leibniz_invOf, smul_eq_mul]\n\n/-\nThe following theorem is stated only in the case that `R` is a field. This is because\nthere is currently no instance of `Inv R⟦X⟧` for more general base rings `R`.\n-/\n"}
{"name":"PowerSeries.derivative_inv'","module":"Mathlib.RingTheory.PowerSeries.Derivative","initialProofState":"R : Type u_1\ninst✝ : Field R\nf : PowerSeries R\n⊢ Eq ((PowerSeries.derivative R) (Inv.inv f)) (HMul.hMul (Neg.neg (HPow.hPow (Inv.inv f) 2)) ((PowerSeries.derivative R) f))","decl":"@[simp] theorem derivative_inv' {R} [Field R] (f : R⟦X⟧) : d⁄dX R f⁻¹ = -f⁻¹ ^ 2 * d⁄dX R f := by\n  by_cases h : constantCoeff R f = 0\n  · suffices f⁻¹ = 0 by\n      rw [this, pow_two, zero_mul, neg_zero, zero_mul, map_zero]\n    rwa [MvPowerSeries.inv_eq_zero]\n  apply Derivation.leibniz_of_mul_eq_one\n  exact PowerSeries.inv_mul_cancel (h := h)\n\n"}
