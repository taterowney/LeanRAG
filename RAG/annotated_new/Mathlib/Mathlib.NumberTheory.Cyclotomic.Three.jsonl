{"name":"IsCyclotomicExtension.Rat.Three.coe_eta","module":"Mathlib.NumberTheory.Cyclotomic.Three","initialProofState":"K : Type u_1\ninstâœ : Field K\nÎ¶ : K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘3\nâŠ¢ Eq (â†‘â‹¯.unit) hÎ¶.toInteger","decl":"lemma coe_eta : (Î· : ğ“ K) = hÎ¶.toInteger := rfl\n\n"}
{"name":"IsPrimitiveRoot.toInteger_cube_eq_one","module":"Mathlib.NumberTheory.Cyclotomic.Three","initialProofState":"K : Type u_1\ninstâœ : Field K\nÎ¶ : K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘3\nâŠ¢ Eq (HPow.hPow hÎ¶.toInteger 3) 1","decl":"lemma _root_.IsPrimitiveRoot.toInteger_cube_eq_one : hÎ¶.toInteger ^ 3 = 1 :=\n  hÎ¶.toInteger_isPrimitiveRoot.pow_eq_one\n\n"}
{"name":"IsCyclotomicExtension.Rat.Three.Units.mem","module":"Mathlib.NumberTheory.Cyclotomic.Three","initialProofState":"K : Type u_1\ninstâœÂ² : Field K\nÎ¶ : K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘3\nu : Units (NumberField.RingOfIntegers K)\ninstâœÂ¹ : NumberField K\ninstâœ : IsCyclotomicExtension (Singleton.singleton 3) Rat K\nâŠ¢ Membership.mem (List.cons 1 (List.cons (-1) (List.cons â‹¯.unit (List.cons (Neg.neg â‹¯.unit) (List.cons (HPow.hPow â‹¯.unit 2) (List.cons (Neg.neg (HPow.hPow â‹¯.unit 2)) List.nil)))))) u","decl":"/-- Let `u` be a unit in `(ğ“ K)Ë£`, then `u âˆˆ [1, -1, Î·, -Î·, Î·^2, -Î·^2]`. -/\n-- Here `List` is more convenient than `Finset`, even if further from the informal statement.\n-- For example, `fin_cases` below does not work with a `Finset`.\ntheorem Units.mem [NumberField K] [IsCyclotomicExtension {3} â„š K] :\n    u âˆˆ [1, -1, Î·, -Î·, Î· ^ 2, -Î· ^ 2] := by\n  have hrank : rank K = 0 := by\n    dsimp only [rank]\n    rw [card_eq_nrRealPlaces_add_nrComplexPlaces, nrRealPlaces_eq_zero (n := 3) K (by decide),\n      zero_add, nrComplexPlaces_eq_totient_div_two (n := 3)]\n    rfl\n  obtain âŸ¨âŸ¨x, eâŸ©, hxu, -âŸ© := exist_unique_eq_mul_prod _ u\n  replace hxu : u = x := by\n    rw [â† mul_one x.1, hxu]\n    apply congr_arg\n    rw [â† Finset.prod_empty]\n    congr\n    rw [Finset.univ_eq_empty_iff, hrank]\n    infer_instance\n  obtain âŸ¨n, hnpos, hnâŸ© := isOfFinOrder_iff_pow_eq_one.1 <| (CommGroup.mem_torsion _ _).1 x.2\n  replace hn : (â†‘u : K) ^ ((âŸ¨n, hnposâŸ© : â„•+) : â„•) = 1 := by\n    rw [â† map_pow]\n    convert map_one (algebraMap (ğ“ K) K)\n    rw_mod_cast [hxu, hn]\n    simp\n  obtain âŸ¨r, hr3, hruâŸ© := hÎ¶.exists_pow_or_neg_mul_pow_of_isOfFinOrder (by decide)\n    (isOfFinOrder_iff_pow_eq_one.2 âŸ¨n, hnpos, hnâŸ©)\n  replace hr : r âˆˆ Finset.Ico 0 3 := Finset.mem_Ico.2 âŸ¨by simp, hr3âŸ©\n  replace hru : â†‘u = Î· ^ r âˆ¨ â†‘u = -Î· ^ r := by\n    rcases hru with h | h\n    Â· left; ext; exact h\n    Â· right; ext; exact h\n  fin_cases hr <;> rcases hru with h | h <;> simp [h]\n\n"}
{"name":"IsCyclotomicExtension.Rat.Three.eta_sq","module":"Mathlib.NumberTheory.Cyclotomic.Three","initialProofState":"K : Type u_1\ninstâœ : Field K\nÎ¶ : K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘3\nâŠ¢ Eq (HPow.hPow (â†‘â‹¯.unit) 2) (HSub.hSub (Neg.neg â†‘â‹¯.unit) 1)","decl":"/-- We have that `Î· ^ 2 = -Î· - 1`. -/\nlemma eta_sq : (Î· ^ 2 : ğ“ K) = - Î· - 1 := by\n  rw [â† neg_add', â† add_eq_zero_iff_eq_neg, â† add_assoc]\n  ext; simpa using hÎ¶.isRoot_cyclotomic (by decide)\n\n"}
{"name":"IsCyclotomicExtension.Rat.Three.eq_one_or_neg_one_of_unit_of_congruent","module":"Mathlib.NumberTheory.Cyclotomic.Three","initialProofState":"K : Type u_1\ninstâœÂ² : Field K\nÎ¶ : K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘3\nu : Units (NumberField.RingOfIntegers K)\ninstâœÂ¹ : NumberField K\ninstâœ : IsCyclotomicExtension (Singleton.singleton 3) Rat K\nhcong : Exists fun n => Dvd.dvd (HPow.hPow (HSub.hSub hÎ¶.toInteger 1) 2) (HSub.hSub â†‘u â†‘n)\nâŠ¢ Or (Eq u 1) (Eq u (-1))","decl":"/-- If a unit `u` is congruent to an integer modulo `Î» ^ 2`, then `u = 1` or `u = -1`.\n\nThis is a special case of the so-called *Kummer's lemma*. -/\ntheorem eq_one_or_neg_one_of_unit_of_congruent\n    [NumberField K] [IsCyclotomicExtension {3} â„š K] (hcong : âˆƒ n : â„¤, Î» ^ 2 âˆ£ (u - n : ğ“ K)) :\n    u = 1 âˆ¨ u = -1 := by\n  replace hcong : âˆƒ n : â„¤, (3 : ğ“ K) âˆ£ (â†‘u - n : ğ“ K) := by\n    obtain âŸ¨n, x, hxâŸ© := hcong\n    exact âŸ¨n, -Î· * x, by rw [â† mul_assoc, mul_neg, â† neg_mul, â† lambda_sq, hx]âŸ©\n  have hÎ¶ := IsCyclotomicExtension.zeta_spec 3 â„š K\n  have := Units.mem hÎ¶ u\n  fin_cases this\n  Â· left; rfl\n  Â· right; rfl\n  all_goals exfalso\n  Â· exact hÎ¶.not_exists_int_prime_dvd_sub_of_prime_ne_two' (by decide) hcong\n  Â· apply hÎ¶.not_exists_int_prime_dvd_sub_of_prime_ne_two' (by decide)\n    obtain âŸ¨n, x, hxâŸ© := hcong\n    rw [sub_eq_iff_eq_add] at hx\n    refine âŸ¨-n, -x, sub_eq_iff_eq_add.2 ?_âŸ©\n    simp only [PNat.val_ofNat, Nat.cast_ofNat, mul_neg, Int.cast_neg, â† neg_add, â† hx,\n      Units.val_neg, IsUnit.unit_spec, RingOfIntegers.neg_mk, neg_neg]\n  Â· exact (hÎ¶.pow_of_coprime 2 (by decide)).not_exists_int_prime_dvd_sub_of_prime_ne_two'\n      (by decide) hcong\n  Â· apply (hÎ¶.pow_of_coprime 2 (by decide)).not_exists_int_prime_dvd_sub_of_prime_ne_two'\n      (by decide)\n    obtain âŸ¨n, x, hxâŸ© := hcong\n    refine âŸ¨-n, -x, sub_eq_iff_eq_add.2 ?_âŸ©\n    have : (hÎ¶.pow_of_coprime 2 (by decide)).toInteger = hÎ¶.toInteger ^ 2 := by ext; simp\n    simp only [this, PNat.val_ofNat, Nat.cast_ofNat, mul_neg, Int.cast_neg, â† neg_add, â†\n      sub_eq_iff_eq_add.1 hx, Units.val_neg, val_pow_eq_pow_val, IsUnit.unit_spec, neg_neg]\n\n"}
{"name":"IsCyclotomicExtension.Rat.Three.lambda_dvd_or_dvd_sub_one_or_dvd_add_one","module":"Mathlib.NumberTheory.Cyclotomic.Three","initialProofState":"K : Type u_1\ninstâœÂ² : Field K\nÎ¶ : K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘3\nx : NumberField.RingOfIntegers K\ninstâœÂ¹ : NumberField K\ninstâœ : IsCyclotomicExtension (Singleton.singleton 3) Rat K\nâŠ¢ Or (Dvd.dvd (HSub.hSub hÎ¶.toInteger 1) x) (Or (Dvd.dvd (HSub.hSub hÎ¶.toInteger 1) (HSub.hSub x 1)) (Dvd.dvd (HSub.hSub hÎ¶.toInteger 1) (HAdd.hAdd x 1)))","decl":"/-- Let `(x : ğ“ K)`. Then we have that `Î»` divides one amongst `x`, `x - 1` and `x + 1`. -/\nlemma lambda_dvd_or_dvd_sub_one_or_dvd_add_one [NumberField K] [IsCyclotomicExtension {3} â„š K] :\n    Î» âˆ£ x âˆ¨ Î» âˆ£ x - 1 âˆ¨ Î» âˆ£ x + 1 := by\n  classical\n  have := hÎ¶.finite_quotient_toInteger_sub_one (by decide)\n  let _ := Fintype.ofFinite (ğ“ K â§¸ Ideal.span {Î»})\n  let _ : Ring (ğ“ K â§¸ Ideal.span {Î»}) := CommRing.toRing -- to speed up instance synthesis\n  let _ : AddGroup (ğ“ K â§¸ Ideal.span {Î»}) := AddGroupWithOne.toAddGroup -- ditto\n  have := Finset.mem_univ (Ideal.Quotient.mk (Ideal.span {Î»}) x)\n  have h3 : Fintype.card (ğ“ K â§¸ Ideal.span {Î»}) = 3 := by\n    rw [â† Nat.card_eq_fintype_card, hÎ¶.card_quotient_toInteger_sub_one (by decide),\n      hÎ¶.norm_toInteger_sub_one_of_prime_ne_two' (by decide)]\n    simp only [PNat.val_ofNat, Nat.cast_ofNat, Int.reduceAbs]\n  rw [Finset.univ_of_card_le_three h3.le] at this\n  simp only [Finset.mem_insert, Finset.mem_singleton] at this\n  rcases this with h | h | h\n  Â· left\n    exact Ideal.mem_span_singleton.1 <| Ideal.Quotient.eq_zero_iff_mem.1 h\n  Â· right; left\n    refine Ideal.mem_span_singleton.1 <| Ideal.Quotient.eq_zero_iff_mem.1 ?_\n    rw [RingHom.map_sub, h, RingHom.map_one, sub_self]\n  Â· right; right\n    refine Ideal.mem_span_singleton.1 <| Ideal.Quotient.eq_zero_iff_mem.1 ?_\n    rw [RingHom.map_add, h, RingHom.map_one, neg_add_cancel]\n\n"}
{"name":"IsCyclotomicExtension.Rat.Three.eta_sq_add_eta_add_one","module":"Mathlib.NumberTheory.Cyclotomic.Three","initialProofState":"K : Type u_1\ninstâœ : Field K\nÎ¶ : K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘3\nâŠ¢ Eq (HAdd.hAdd (HAdd.hAdd (HPow.hPow (â†‘â‹¯.unit) 2) â†‘â‹¯.unit) 1) 0","decl":"/-- We have that `Î· ^ 2 + Î· + 1 = 0`. -/\nlemma eta_sq_add_eta_add_one : (Î· : ğ“ K) ^ 2 + Î· + 1 = 0 := by\n  rw [eta_sq]\n  ring\n\n"}
{"name":"IsCyclotomicExtension.Rat.Three.cube_sub_one_eq_mul","module":"Mathlib.NumberTheory.Cyclotomic.Three","initialProofState":"K : Type u_1\ninstâœ : Field K\nÎ¶ : K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘3\nx : NumberField.RingOfIntegers K\nâŠ¢ Eq (HSub.hSub (HPow.hPow x 3) 1) (HMul.hMul (HMul.hMul (HSub.hSub x 1) (HSub.hSub x â†‘â‹¯.unit)) (HSub.hSub x (HPow.hPow (â†‘â‹¯.unit) 2)))","decl":"/-- We have that `x ^ 3 - 1 = (x - 1) * (x - Î·) * (x - Î· ^ 2)`. -/\nlemma cube_sub_one_eq_mul : x ^ 3 - 1 = (x - 1) * (x - Î·) * (x - Î· ^ 2) := by\n  symm\n  calc _ = x ^ 3 - x ^ 2 * (Î· ^ 2 + Î· + 1) + x * (Î· ^ 2 + Î· + Î· ^ 3) - Î· ^ 3 := by ring\n  _ = x ^ 3 - x ^ 2 * (Î· ^ 2 + Î· + 1) + x * (Î· ^ 2 + Î· + 1) - 1 := by\n    simp [hÎ¶.toInteger_cube_eq_one]\n  _ = x ^ 3 - 1 := by rw [eta_sq_add_eta_add_one hÎ¶]; ring\n\n"}
{"name":"IsCyclotomicExtension.Rat.Three.lambda_dvd_mul_sub_one_mul_sub_eta_add_one","module":"Mathlib.NumberTheory.Cyclotomic.Three","initialProofState":"K : Type u_1\ninstâœÂ² : Field K\nÎ¶ : K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘3\nx : NumberField.RingOfIntegers K\ninstâœÂ¹ : NumberField K\ninstâœ : IsCyclotomicExtension (Singleton.singleton 3) Rat K\nâŠ¢ Dvd.dvd (HSub.hSub hÎ¶.toInteger 1) (HMul.hMul (HMul.hMul x (HSub.hSub x 1)) (HSub.hSub x (HAdd.hAdd (â†‘â‹¯.unit) 1)))","decl":"/-- We have that `Î»` divides `x * (x - 1) * (x - (Î· + 1))`. -/\nlemma lambda_dvd_mul_sub_one_mul_sub_eta_add_one : Î» âˆ£ x * (x - 1) * (x - (Î· + 1)) := by\n  rcases lambda_dvd_or_dvd_sub_one_or_dvd_add_one hÎ¶ x with h | h | h\n  Â· exact dvd_mul_of_dvd_left (dvd_mul_of_dvd_left h _) _\n  Â· exact dvd_mul_of_dvd_left (dvd_mul_of_dvd_right h _) _\n  Â· refine dvd_mul_of_dvd_right ?_ _\n    rw [show x - (Î· + 1) = x + 1 - (Î· - 1 + 3) by ring]\n    exact dvd_sub h <| dvd_add dvd_rfl hÎ¶.toInteger_sub_one_dvd_prime'\n\n"}
{"name":"IsCyclotomicExtension.Rat.Three.lambda_pow_four_dvd_cube_sub_one_of_dvd_sub_one","module":"Mathlib.NumberTheory.Cyclotomic.Three","initialProofState":"K : Type u_1\ninstâœÂ² : Field K\nÎ¶ : K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘3\ninstâœÂ¹ : NumberField K\ninstâœ : IsCyclotomicExtension (Singleton.singleton 3) Rat K\nx : NumberField.RingOfIntegers K\nh : Dvd.dvd (HSub.hSub hÎ¶.toInteger 1) (HSub.hSub x 1)\nâŠ¢ Dvd.dvd (HPow.hPow (HSub.hSub hÎ¶.toInteger 1) 4) (HSub.hSub (HPow.hPow x 3) 1)","decl":"/-- If `Î»` divides `x - 1`, then `Î» ^ 4` divides `x ^ 3 - 1`. -/\nlemma lambda_pow_four_dvd_cube_sub_one_of_dvd_sub_one {x : ğ“ K} (h : Î» âˆ£ x - 1) :\n    Î» ^ 4 âˆ£ x ^ 3 - 1 := by\n  obtain âŸ¨y, hyâŸ© := h\n  have : x ^ 3 - 1 = Î» ^ 3 * (y * (y - 1) * (y - (Î· + 1))) := by\n    calc _ =  (x - 1) * (x - 1 - Î») * (x - 1 - Î» * (Î· + 1)) := by\n          simp only [coe_eta, cube_sub_one_eq_mul hÎ¶ x]; ring\n    _ = _ := by rw [hy]; ring\n  rw [this, pow_succ]\n  exact mul_dvd_mul_left _ (lambda_dvd_mul_sub_one_mul_sub_eta_add_one hÎ¶ y)\n\n"}
{"name":"IsCyclotomicExtension.Rat.Three.lambda_pow_four_dvd_cube_add_one_of_dvd_add_one","module":"Mathlib.NumberTheory.Cyclotomic.Three","initialProofState":"K : Type u_1\ninstâœÂ² : Field K\nÎ¶ : K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘3\ninstâœÂ¹ : NumberField K\ninstâœ : IsCyclotomicExtension (Singleton.singleton 3) Rat K\nx : NumberField.RingOfIntegers K\nh : Dvd.dvd (HSub.hSub hÎ¶.toInteger 1) (HAdd.hAdd x 1)\nâŠ¢ Dvd.dvd (HPow.hPow (HSub.hSub hÎ¶.toInteger 1) 4) (HAdd.hAdd (HPow.hPow x 3) 1)","decl":"/-- If `Î»` divides `x + 1`, then `Î» ^ 4` divides `x ^ 3 + 1`. -/\nlemma lambda_pow_four_dvd_cube_add_one_of_dvd_add_one {x : ğ“ K} (h : Î» âˆ£ x + 1) :\n    Î» ^ 4 âˆ£ x ^ 3 + 1 := by\n  replace h : Î» âˆ£ -x - 1 := by\n    convert h.neg_right using 1\n    exact (neg_add' x 1).symm\n  convert (lambda_pow_four_dvd_cube_sub_one_of_dvd_sub_one hÎ¶ h).neg_right using 1\n  ring\n\n"}
{"name":"IsCyclotomicExtension.Rat.Three.lambda_pow_four_dvd_cube_sub_one_or_add_one_of_lambda_not_dvd","module":"Mathlib.NumberTheory.Cyclotomic.Three","initialProofState":"K : Type u_1\ninstâœÂ² : Field K\nÎ¶ : K\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘3\ninstâœÂ¹ : NumberField K\ninstâœ : IsCyclotomicExtension (Singleton.singleton 3) Rat K\nx : NumberField.RingOfIntegers K\nh : Not (Dvd.dvd (HSub.hSub hÎ¶.toInteger 1) x)\nâŠ¢ Or (Dvd.dvd (HPow.hPow (HSub.hSub hÎ¶.toInteger 1) 4) (HSub.hSub (HPow.hPow x 3) 1)) (Dvd.dvd (HPow.hPow (HSub.hSub hÎ¶.toInteger 1) 4) (HAdd.hAdd (HPow.hPow x 3) 1))","decl":"/-- If `Î»` does not divide `x`, then `Î» ^ 4` divides `x ^ 3 - 1` or `x ^ 3 + 1`. -/\nlemma lambda_pow_four_dvd_cube_sub_one_or_add_one_of_lambda_not_dvd {x : ğ“ K} (h : Â¬ Î» âˆ£ x) :\n    Î» ^ 4 âˆ£ x ^ 3 - 1 âˆ¨ Î» ^ 4 âˆ£ x ^ 3 + 1 := by\n  rcases lambda_dvd_or_dvd_sub_one_or_dvd_add_one hÎ¶ x with H | H | H\n  Â· contradiction\n  Â· left\n    exact lambda_pow_four_dvd_cube_sub_one_of_dvd_sub_one hÎ¶ H\n  Â· right\n    exact lambda_pow_four_dvd_cube_add_one_of_dvd_add_one hÎ¶ H\n\n"}
