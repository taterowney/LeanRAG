{"name":"IsCyclotomicExtension.Rat.Three.coe_eta","module":"Mathlib.NumberTheory.Cyclotomic.Three","initialProofState":"K : Type u_1\ninst✝ : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\n⊢ Eq (↑⋯.unit) hζ.toInteger","decl":"lemma coe_eta : (η : 𝓞 K) = hζ.toInteger := rfl\n\n"}
{"name":"IsPrimitiveRoot.toInteger_cube_eq_one","module":"Mathlib.NumberTheory.Cyclotomic.Three","initialProofState":"K : Type u_1\ninst✝ : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\n⊢ Eq (HPow.hPow hζ.toInteger 3) 1","decl":"lemma _root_.IsPrimitiveRoot.toInteger_cube_eq_one : hζ.toInteger ^ 3 = 1 :=\n  hζ.toInteger_isPrimitiveRoot.pow_eq_one\n\n"}
{"name":"IsCyclotomicExtension.Rat.Three.Units.mem","module":"Mathlib.NumberTheory.Cyclotomic.Three","initialProofState":"K : Type u_1\ninst✝² : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nu : Units (NumberField.RingOfIntegers K)\ninst✝¹ : NumberField K\ninst✝ : IsCyclotomicExtension (Singleton.singleton 3) Rat K\n⊢ Membership.mem (List.cons 1 (List.cons (-1) (List.cons ⋯.unit (List.cons (Neg.neg ⋯.unit) (List.cons (HPow.hPow ⋯.unit 2) (List.cons (Neg.neg (HPow.hPow ⋯.unit 2)) List.nil)))))) u","decl":"/-- Let `u` be a unit in `(𝓞 K)ˣ`, then `u ∈ [1, -1, η, -η, η^2, -η^2]`. -/\n-- Here `List` is more convenient than `Finset`, even if further from the informal statement.\n-- For example, `fin_cases` below does not work with a `Finset`.\ntheorem Units.mem [NumberField K] [IsCyclotomicExtension {3} ℚ K] :\n    u ∈ [1, -1, η, -η, η ^ 2, -η ^ 2] := by\n  have hrank : rank K = 0 := by\n    dsimp only [rank]\n    rw [card_eq_nrRealPlaces_add_nrComplexPlaces, nrRealPlaces_eq_zero (n := 3) K (by decide),\n      zero_add, nrComplexPlaces_eq_totient_div_two (n := 3)]\n    rfl\n  obtain ⟨⟨x, e⟩, hxu, -⟩ := exist_unique_eq_mul_prod _ u\n  replace hxu : u = x := by\n    rw [← mul_one x.1, hxu]\n    apply congr_arg\n    rw [← Finset.prod_empty]\n    congr\n    rw [Finset.univ_eq_empty_iff, hrank]\n    infer_instance\n  obtain ⟨n, hnpos, hn⟩ := isOfFinOrder_iff_pow_eq_one.1 <| (CommGroup.mem_torsion _ _).1 x.2\n  replace hn : (↑u : K) ^ ((⟨n, hnpos⟩ : ℕ+) : ℕ) = 1 := by\n    rw [← map_pow]\n    convert map_one (algebraMap (𝓞 K) K)\n    rw_mod_cast [hxu, hn]\n    simp\n  obtain ⟨r, hr3, hru⟩ := hζ.exists_pow_or_neg_mul_pow_of_isOfFinOrder (by decide)\n    (isOfFinOrder_iff_pow_eq_one.2 ⟨n, hnpos, hn⟩)\n  replace hr : r ∈ Finset.Ico 0 3 := Finset.mem_Ico.2 ⟨by simp, hr3⟩\n  replace hru : ↑u = η ^ r ∨ ↑u = -η ^ r := by\n    rcases hru with h | h\n    · left; ext; exact h\n    · right; ext; exact h\n  fin_cases hr <;> rcases hru with h | h <;> simp [h]\n\n"}
{"name":"IsCyclotomicExtension.Rat.Three.eta_sq","module":"Mathlib.NumberTheory.Cyclotomic.Three","initialProofState":"K : Type u_1\ninst✝ : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\n⊢ Eq (HPow.hPow (↑⋯.unit) 2) (HSub.hSub (Neg.neg ↑⋯.unit) 1)","decl":"/-- We have that `η ^ 2 = -η - 1`. -/\nlemma eta_sq : (η ^ 2 : 𝓞 K) = - η - 1 := by\n  rw [← neg_add', ← add_eq_zero_iff_eq_neg, ← add_assoc]\n  ext; simpa using hζ.isRoot_cyclotomic (by decide)\n\n"}
{"name":"IsCyclotomicExtension.Rat.Three.eq_one_or_neg_one_of_unit_of_congruent","module":"Mathlib.NumberTheory.Cyclotomic.Three","initialProofState":"K : Type u_1\ninst✝² : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nu : Units (NumberField.RingOfIntegers K)\ninst✝¹ : NumberField K\ninst✝ : IsCyclotomicExtension (Singleton.singleton 3) Rat K\nhcong : Exists fun n => Dvd.dvd (HPow.hPow (HSub.hSub hζ.toInteger 1) 2) (HSub.hSub ↑u ↑n)\n⊢ Or (Eq u 1) (Eq u (-1))","decl":"/-- If a unit `u` is congruent to an integer modulo `λ ^ 2`, then `u = 1` or `u = -1`.\n\nThis is a special case of the so-called *Kummer's lemma*. -/\ntheorem eq_one_or_neg_one_of_unit_of_congruent\n    [NumberField K] [IsCyclotomicExtension {3} ℚ K] (hcong : ∃ n : ℤ, λ ^ 2 ∣ (u - n : 𝓞 K)) :\n    u = 1 ∨ u = -1 := by\n  replace hcong : ∃ n : ℤ, (3 : 𝓞 K) ∣ (↑u - n : 𝓞 K) := by\n    obtain ⟨n, x, hx⟩ := hcong\n    exact ⟨n, -η * x, by rw [← mul_assoc, mul_neg, ← neg_mul, ← lambda_sq, hx]⟩\n  have hζ := IsCyclotomicExtension.zeta_spec 3 ℚ K\n  have := Units.mem hζ u\n  fin_cases this\n  · left; rfl\n  · right; rfl\n  all_goals exfalso\n  · exact hζ.not_exists_int_prime_dvd_sub_of_prime_ne_two' (by decide) hcong\n  · apply hζ.not_exists_int_prime_dvd_sub_of_prime_ne_two' (by decide)\n    obtain ⟨n, x, hx⟩ := hcong\n    rw [sub_eq_iff_eq_add] at hx\n    refine ⟨-n, -x, sub_eq_iff_eq_add.2 ?_⟩\n    simp only [PNat.val_ofNat, Nat.cast_ofNat, mul_neg, Int.cast_neg, ← neg_add, ← hx,\n      Units.val_neg, IsUnit.unit_spec, RingOfIntegers.neg_mk, neg_neg]\n  · exact (hζ.pow_of_coprime 2 (by decide)).not_exists_int_prime_dvd_sub_of_prime_ne_two'\n      (by decide) hcong\n  · apply (hζ.pow_of_coprime 2 (by decide)).not_exists_int_prime_dvd_sub_of_prime_ne_two'\n      (by decide)\n    obtain ⟨n, x, hx⟩ := hcong\n    refine ⟨-n, -x, sub_eq_iff_eq_add.2 ?_⟩\n    have : (hζ.pow_of_coprime 2 (by decide)).toInteger = hζ.toInteger ^ 2 := by ext; simp\n    simp only [this, PNat.val_ofNat, Nat.cast_ofNat, mul_neg, Int.cast_neg, ← neg_add, ←\n      sub_eq_iff_eq_add.1 hx, Units.val_neg, val_pow_eq_pow_val, IsUnit.unit_spec, neg_neg]\n\n"}
{"name":"IsCyclotomicExtension.Rat.Three.lambda_dvd_or_dvd_sub_one_or_dvd_add_one","module":"Mathlib.NumberTheory.Cyclotomic.Three","initialProofState":"K : Type u_1\ninst✝² : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nx : NumberField.RingOfIntegers K\ninst✝¹ : NumberField K\ninst✝ : IsCyclotomicExtension (Singleton.singleton 3) Rat K\n⊢ Or (Dvd.dvd (HSub.hSub hζ.toInteger 1) x) (Or (Dvd.dvd (HSub.hSub hζ.toInteger 1) (HSub.hSub x 1)) (Dvd.dvd (HSub.hSub hζ.toInteger 1) (HAdd.hAdd x 1)))","decl":"/-- Let `(x : 𝓞 K)`. Then we have that `λ` divides one amongst `x`, `x - 1` and `x + 1`. -/\nlemma lambda_dvd_or_dvd_sub_one_or_dvd_add_one [NumberField K] [IsCyclotomicExtension {3} ℚ K] :\n    λ ∣ x ∨ λ ∣ x - 1 ∨ λ ∣ x + 1 := by\n  classical\n  have := hζ.finite_quotient_toInteger_sub_one (by decide)\n  let _ := Fintype.ofFinite (𝓞 K ⧸ Ideal.span {λ})\n  let _ : Ring (𝓞 K ⧸ Ideal.span {λ}) := CommRing.toRing -- to speed up instance synthesis\n  let _ : AddGroup (𝓞 K ⧸ Ideal.span {λ}) := AddGroupWithOne.toAddGroup -- ditto\n  have := Finset.mem_univ (Ideal.Quotient.mk (Ideal.span {λ}) x)\n  have h3 : Fintype.card (𝓞 K ⧸ Ideal.span {λ}) = 3 := by\n    rw [← Nat.card_eq_fintype_card, hζ.card_quotient_toInteger_sub_one (by decide),\n      hζ.norm_toInteger_sub_one_of_prime_ne_two' (by decide)]\n    simp only [PNat.val_ofNat, Nat.cast_ofNat, Int.reduceAbs]\n  rw [Finset.univ_of_card_le_three h3.le] at this\n  simp only [Finset.mem_insert, Finset.mem_singleton] at this\n  rcases this with h | h | h\n  · left\n    exact Ideal.mem_span_singleton.1 <| Ideal.Quotient.eq_zero_iff_mem.1 h\n  · right; left\n    refine Ideal.mem_span_singleton.1 <| Ideal.Quotient.eq_zero_iff_mem.1 ?_\n    rw [RingHom.map_sub, h, RingHom.map_one, sub_self]\n  · right; right\n    refine Ideal.mem_span_singleton.1 <| Ideal.Quotient.eq_zero_iff_mem.1 ?_\n    rw [RingHom.map_add, h, RingHom.map_one, neg_add_cancel]\n\n"}
{"name":"IsCyclotomicExtension.Rat.Three.eta_sq_add_eta_add_one","module":"Mathlib.NumberTheory.Cyclotomic.Three","initialProofState":"K : Type u_1\ninst✝ : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\n⊢ Eq (HAdd.hAdd (HAdd.hAdd (HPow.hPow (↑⋯.unit) 2) ↑⋯.unit) 1) 0","decl":"/-- We have that `η ^ 2 + η + 1 = 0`. -/\nlemma eta_sq_add_eta_add_one : (η : 𝓞 K) ^ 2 + η + 1 = 0 := by\n  rw [eta_sq]\n  ring\n\n"}
{"name":"IsCyclotomicExtension.Rat.Three.cube_sub_one_eq_mul","module":"Mathlib.NumberTheory.Cyclotomic.Three","initialProofState":"K : Type u_1\ninst✝ : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nx : NumberField.RingOfIntegers K\n⊢ Eq (HSub.hSub (HPow.hPow x 3) 1) (HMul.hMul (HMul.hMul (HSub.hSub x 1) (HSub.hSub x ↑⋯.unit)) (HSub.hSub x (HPow.hPow (↑⋯.unit) 2)))","decl":"/-- We have that `x ^ 3 - 1 = (x - 1) * (x - η) * (x - η ^ 2)`. -/\nlemma cube_sub_one_eq_mul : x ^ 3 - 1 = (x - 1) * (x - η) * (x - η ^ 2) := by\n  symm\n  calc _ = x ^ 3 - x ^ 2 * (η ^ 2 + η + 1) + x * (η ^ 2 + η + η ^ 3) - η ^ 3 := by ring\n  _ = x ^ 3 - x ^ 2 * (η ^ 2 + η + 1) + x * (η ^ 2 + η + 1) - 1 := by\n    simp [hζ.toInteger_cube_eq_one]\n  _ = x ^ 3 - 1 := by rw [eta_sq_add_eta_add_one hζ]; ring\n\n"}
{"name":"IsCyclotomicExtension.Rat.Three.lambda_dvd_mul_sub_one_mul_sub_eta_add_one","module":"Mathlib.NumberTheory.Cyclotomic.Three","initialProofState":"K : Type u_1\ninst✝² : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\nx : NumberField.RingOfIntegers K\ninst✝¹ : NumberField K\ninst✝ : IsCyclotomicExtension (Singleton.singleton 3) Rat K\n⊢ Dvd.dvd (HSub.hSub hζ.toInteger 1) (HMul.hMul (HMul.hMul x (HSub.hSub x 1)) (HSub.hSub x (HAdd.hAdd (↑⋯.unit) 1)))","decl":"/-- We have that `λ` divides `x * (x - 1) * (x - (η + 1))`. -/\nlemma lambda_dvd_mul_sub_one_mul_sub_eta_add_one : λ ∣ x * (x - 1) * (x - (η + 1)) := by\n  rcases lambda_dvd_or_dvd_sub_one_or_dvd_add_one hζ x with h | h | h\n  · exact dvd_mul_of_dvd_left (dvd_mul_of_dvd_left h _) _\n  · exact dvd_mul_of_dvd_left (dvd_mul_of_dvd_right h _) _\n  · refine dvd_mul_of_dvd_right ?_ _\n    rw [show x - (η + 1) = x + 1 - (η - 1 + 3) by ring]\n    exact dvd_sub h <| dvd_add dvd_rfl hζ.toInteger_sub_one_dvd_prime'\n\n"}
{"name":"IsCyclotomicExtension.Rat.Three.lambda_pow_four_dvd_cube_sub_one_of_dvd_sub_one","module":"Mathlib.NumberTheory.Cyclotomic.Three","initialProofState":"K : Type u_1\ninst✝² : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\ninst✝¹ : NumberField K\ninst✝ : IsCyclotomicExtension (Singleton.singleton 3) Rat K\nx : NumberField.RingOfIntegers K\nh : Dvd.dvd (HSub.hSub hζ.toInteger 1) (HSub.hSub x 1)\n⊢ Dvd.dvd (HPow.hPow (HSub.hSub hζ.toInteger 1) 4) (HSub.hSub (HPow.hPow x 3) 1)","decl":"/-- If `λ` divides `x - 1`, then `λ ^ 4` divides `x ^ 3 - 1`. -/\nlemma lambda_pow_four_dvd_cube_sub_one_of_dvd_sub_one {x : 𝓞 K} (h : λ ∣ x - 1) :\n    λ ^ 4 ∣ x ^ 3 - 1 := by\n  obtain ⟨y, hy⟩ := h\n  have : x ^ 3 - 1 = λ ^ 3 * (y * (y - 1) * (y - (η + 1))) := by\n    calc _ =  (x - 1) * (x - 1 - λ) * (x - 1 - λ * (η + 1)) := by\n          simp only [coe_eta, cube_sub_one_eq_mul hζ x]; ring\n    _ = _ := by rw [hy]; ring\n  rw [this, pow_succ]\n  exact mul_dvd_mul_left _ (lambda_dvd_mul_sub_one_mul_sub_eta_add_one hζ y)\n\n"}
{"name":"IsCyclotomicExtension.Rat.Three.lambda_pow_four_dvd_cube_add_one_of_dvd_add_one","module":"Mathlib.NumberTheory.Cyclotomic.Three","initialProofState":"K : Type u_1\ninst✝² : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\ninst✝¹ : NumberField K\ninst✝ : IsCyclotomicExtension (Singleton.singleton 3) Rat K\nx : NumberField.RingOfIntegers K\nh : Dvd.dvd (HSub.hSub hζ.toInteger 1) (HAdd.hAdd x 1)\n⊢ Dvd.dvd (HPow.hPow (HSub.hSub hζ.toInteger 1) 4) (HAdd.hAdd (HPow.hPow x 3) 1)","decl":"/-- If `λ` divides `x + 1`, then `λ ^ 4` divides `x ^ 3 + 1`. -/\nlemma lambda_pow_four_dvd_cube_add_one_of_dvd_add_one {x : 𝓞 K} (h : λ ∣ x + 1) :\n    λ ^ 4 ∣ x ^ 3 + 1 := by\n  replace h : λ ∣ -x - 1 := by\n    convert h.neg_right using 1\n    exact (neg_add' x 1).symm\n  convert (lambda_pow_four_dvd_cube_sub_one_of_dvd_sub_one hζ h).neg_right using 1\n  ring\n\n"}
{"name":"IsCyclotomicExtension.Rat.Three.lambda_pow_four_dvd_cube_sub_one_or_add_one_of_lambda_not_dvd","module":"Mathlib.NumberTheory.Cyclotomic.Three","initialProofState":"K : Type u_1\ninst✝² : Field K\nζ : K\nhζ : IsPrimitiveRoot ζ ↑3\ninst✝¹ : NumberField K\ninst✝ : IsCyclotomicExtension (Singleton.singleton 3) Rat K\nx : NumberField.RingOfIntegers K\nh : Not (Dvd.dvd (HSub.hSub hζ.toInteger 1) x)\n⊢ Or (Dvd.dvd (HPow.hPow (HSub.hSub hζ.toInteger 1) 4) (HSub.hSub (HPow.hPow x 3) 1)) (Dvd.dvd (HPow.hPow (HSub.hSub hζ.toInteger 1) 4) (HAdd.hAdd (HPow.hPow x 3) 1))","decl":"/-- If `λ` does not divide `x`, then `λ ^ 4` divides `x ^ 3 - 1` or `x ^ 3 + 1`. -/\nlemma lambda_pow_four_dvd_cube_sub_one_or_add_one_of_lambda_not_dvd {x : 𝓞 K} (h : ¬ λ ∣ x) :\n    λ ^ 4 ∣ x ^ 3 - 1 ∨ λ ^ 4 ∣ x ^ 3 + 1 := by\n  rcases lambda_dvd_or_dvd_sub_one_or_dvd_add_one hζ x with H | H | H\n  · contradiction\n  · left\n    exact lambda_pow_four_dvd_cube_sub_one_of_dvd_sub_one hζ H\n  · right\n    exact lambda_pow_four_dvd_cube_add_one_of_dvd_add_one hζ H\n\n"}
