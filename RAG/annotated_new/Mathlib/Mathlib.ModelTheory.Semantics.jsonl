{"name":"FirstOrder.Language.Term.realize_var","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nv : α → M\nk : α\n⊢ Eq (FirstOrder.Language.Term.realize v (FirstOrder.Language.Term.var k)) (v k)","decl":"@[simp]\ntheorem realize_var (v : α → M) (k) : realize v (var k : L.Term α) = v k := rfl\n\n"}
{"name":"FirstOrder.Language.Term.realize_func","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nv : α → M\nn : Nat\nf : L.Functions n\nts : Fin n → L.Term α\n⊢ Eq (FirstOrder.Language.Term.realize v (FirstOrder.Language.Term.func f ts)) (FirstOrder.Language.Structure.funMap f fun i => FirstOrder.Language.Term.realize v (ts i))","decl":"@[simp]\ntheorem realize_func (v : α → M) {n} (f : L.Functions n) (ts) :\n    realize v (func f ts : L.Term α) = funMap f fun i => (ts i).realize v := rfl\n\n"}
{"name":"FirstOrder.Language.Term.realize_relabel","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nβ : Type v'\nt : L.Term α\ng : α → β\nv : β → M\n⊢ Eq (FirstOrder.Language.Term.realize v (FirstOrder.Language.Term.relabel g t)) (FirstOrder.Language.Term.realize (Function.comp v g) t)","decl":"@[simp]\ntheorem realize_relabel {t : L.Term α} {g : α → β} {v : β → M} :\n    (t.relabel g).realize v = t.realize (v ∘ g) := by\n  induction' t with _ n f ts ih\n  · rfl\n  · simp [ih]\n\n"}
{"name":"FirstOrder.Language.Term.realize_liftAt","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nn n' m : Nat\nt : L.Term (Sum α (Fin n))\nv : Sum α (Fin (HAdd.hAdd n n')) → M\n⊢ Eq (FirstOrder.Language.Term.realize v (FirstOrder.Language.Term.liftAt n' m t)) (FirstOrder.Language.Term.realize (Function.comp v (Sum.map id fun i => ite (LT.lt (↑i) m) (Fin.castAdd n' i) (i.addNat n'))) t)","decl":"@[simp]\ntheorem realize_liftAt {n n' m : ℕ} {t : L.Term (α ⊕ (Fin n))} {v : α ⊕ (Fin (n + n')) → M} :\n    (t.liftAt n' m).realize v =\n      t.realize (v ∘ Sum.map id fun i : Fin _ =>\n        if ↑i < m then Fin.castAdd n' i else Fin.addNat i n') :=\n  realize_relabel\n\n"}
{"name":"FirstOrder.Language.Term.realize_constants","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nc : L.Constants\nv : α → M\n⊢ Eq (FirstOrder.Language.Term.realize v c.term) ↑c","decl":"@[simp]\ntheorem realize_constants {c : L.Constants} {v : α → M} : c.term.realize v = c :=\n  funMap_eq_coe_constants\n\n"}
{"name":"FirstOrder.Language.Term.realize_functions_apply₁","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nf : L.Functions 1\nt : L.Term α\nv : α → M\n⊢ Eq (FirstOrder.Language.Term.realize v (f.apply₁ t)) (FirstOrder.Language.Structure.funMap f (Matrix.vecCons (FirstOrder.Language.Term.realize v t) Matrix.vecEmpty))","decl":"@[simp]\ntheorem realize_functions_apply₁ {f : L.Functions 1} {t : L.Term α} {v : α → M} :\n    (f.apply₁ t).realize v = funMap f ![t.realize v] := by\n  rw [Functions.apply₁, Term.realize]\n  refine congr rfl (funext fun i => ?_)\n  simp only [Matrix.cons_val_fin_one]\n\n"}
{"name":"FirstOrder.Language.Term.realize_functions_apply₂","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nf : L.Functions 2\nt₁ t₂ : L.Term α\nv : α → M\n⊢ Eq (FirstOrder.Language.Term.realize v (f.apply₂ t₁ t₂)) (FirstOrder.Language.Structure.funMap f (Matrix.vecCons (FirstOrder.Language.Term.realize v t₁) (Matrix.vecCons (FirstOrder.Language.Term.realize v t₂) Matrix.vecEmpty)))","decl":"@[simp]\ntheorem realize_functions_apply₂ {f : L.Functions 2} {t₁ t₂ : L.Term α} {v : α → M} :\n    (f.apply₂ t₁ t₂).realize v = funMap f ![t₁.realize v, t₂.realize v] := by\n  rw [Functions.apply₂, Term.realize]\n  refine congr rfl (funext (Fin.cases ?_ ?_))\n  · simp only [Matrix.cons_val_zero]\n  · simp only [Matrix.cons_val_succ, Matrix.cons_val_fin_one, forall_const]\n\n"}
{"name":"FirstOrder.Language.Term.realize_con","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nA : Set M\na : ↑A\nv : α → M\n⊢ Eq (FirstOrder.Language.Term.realize v (L.con a).term) ↑a","decl":"theorem realize_con {A : Set M} {a : A} {v : α → M} : (L.con a).term.realize v = a :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Term.realize_subst","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nβ : Type v'\nt : L.Term α\ntf : α → L.Term β\nv : β → M\n⊢ Eq (FirstOrder.Language.Term.realize v (t.subst tf)) (FirstOrder.Language.Term.realize (fun a => FirstOrder.Language.Term.realize v (tf a)) t)","decl":"@[simp]\ntheorem realize_subst {t : L.Term α} {tf : α → L.Term β} {v : β → M} :\n    (t.subst tf).realize v = t.realize fun a => (tf a).realize v := by\n  induction t with\n  | var => rfl\n  | func _ _ ih => simp [ih]\n\n"}
{"name":"FirstOrder.Language.Term.realize_restrictVar","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\nα : Type u'\nβ : Type v'\ninst✝ : DecidableEq α\nt : L.Term α\nf : (Subtype fun x => Membership.mem t.varFinset x) → β\nv : β → M\nv' : α → M\nhv' : ∀ (a : Subtype fun x => Membership.mem t.varFinset x), Eq (v (f a)) (v' ↑a)\n⊢ Eq (FirstOrder.Language.Term.realize v (t.restrictVar f)) (FirstOrder.Language.Term.realize v' t)","decl":"theorem realize_restrictVar [DecidableEq α] {t : L.Term α} {f : t.varFinset → β}\n    {v : β → M} (v' : α → M) (hv' : ∀ a, v (f a) = v' a) :\n     (t.restrictVar f).realize v = t.realize v' := by\n  induction t with\n  | var => simp [restrictVar, hv']\n  | func _ _ ih =>\n    exact congr rfl (funext fun i => ih i ((by simp [Function.comp_apply, hv'])))\n\n"}
{"name":"FirstOrder.Language.Term.realize_restrictVar'","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\nα : Type u'\ninst✝ : DecidableEq α\nt : L.Term α\ns : Set α\nh : HasSubset.Subset (↑t.varFinset) s\nv : α → M\n⊢ Eq (FirstOrder.Language.Term.realize (Function.comp v Subtype.val) (t.restrictVar (Set.inclusion h))) (FirstOrder.Language.Term.realize v t)","decl":"/-- A special case of `realize_restrictVar`, included because we can add the `simp` attribute\nto it -/\n@[simp]\ntheorem realize_restrictVar' [DecidableEq α] {t : L.Term α} {s : Set α} (h : ↑t.varFinset ⊆ s)\n    {v : α → M} : (t.restrictVar (Set.inclusion h)).realize (v ∘ (↑)) = t.realize v :=\n  realize_restrictVar _ (by simp)\n\n"}
{"name":"FirstOrder.Language.Term.realize_restrictVarLeft","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\nα : Type u'\nβ : Type v'\ninst✝ : DecidableEq α\nγ : Type u_4\nt : L.Term (Sum α γ)\nf : (Subtype fun x => Membership.mem t.varFinsetLeft x) → β\nxs : Sum β γ → M\nxs' : α → M\nhxs' : ∀ (a : Subtype fun x => Membership.mem t.varFinsetLeft x), Eq (xs (Sum.inl (f a))) (xs' ↑a)\n⊢ Eq (FirstOrder.Language.Term.realize xs (t.restrictVarLeft f)) (FirstOrder.Language.Term.realize (Sum.elim xs' (Function.comp xs Sum.inr)) t)","decl":"theorem realize_restrictVarLeft [DecidableEq α] {γ : Type*} {t : L.Term (α ⊕ γ)}\n    {f : t.varFinsetLeft → β}\n    {xs : β ⊕ γ → M} (xs' : α → M) (hxs' : ∀ a, xs (Sum.inl (f a)) = xs' a) :\n    (t.restrictVarLeft f).realize xs = t.realize (Sum.elim xs' (xs ∘ Sum.inr)) := by\n  induction t with\n  | var a => cases a <;> simp [restrictVarLeft, hxs']\n  | func _ _ ih =>\n    exact congr rfl (funext fun i => ih i (by simp [hxs']))\n\n"}
{"name":"FirstOrder.Language.Term.realize_restrictVarLeft'","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\nα : Type u'\ninst✝ : DecidableEq α\nγ : Type u_4\nt : L.Term (Sum α γ)\ns : Set α\nh : HasSubset.Subset (↑t.varFinsetLeft) s\nv : α → M\nxs : γ → M\n⊢ Eq (FirstOrder.Language.Term.realize (Sum.elim (Function.comp v Subtype.val) xs) (t.restrictVarLeft (Set.inclusion h))) (FirstOrder.Language.Term.realize (Sum.elim v xs) t)","decl":"/-- A special case of `realize_restrictVarLeft`, included because we can add the `simp` attribute\nto it -/\n@[simp]\ntheorem realize_restrictVarLeft' [DecidableEq α] {γ : Type*} {t : L.Term (α ⊕ γ)} {s : Set α}\n    (h : ↑t.varFinsetLeft ⊆ s) {v : α → M} {xs : γ → M} :\n    (t.restrictVarLeft (Set.inclusion h)).realize (Sum.elim (v ∘ (↑)) xs) =\n      t.realize (Sum.elim v xs) :=\n  realize_restrictVarLeft _ (by simp)\n\n"}
{"name":"FirstOrder.Language.Term.realize_constantsToVars","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝² : L.Structure M\nα : Type u'\nβ : Type v'\ninst✝¹ : (L.withConstants α).Structure M\ninst✝ : (L.lhomWithConstants α).IsExpansionOn M\nt : (L.withConstants α).Term β\nv : β → M\n⊢ Eq (FirstOrder.Language.Term.realize (Sum.elim (fun a => ↑(L.con a)) v) t.constantsToVars) (FirstOrder.Language.Term.realize v t)","decl":"@[simp]\ntheorem realize_constantsToVars [L[[α]].Structure M] [(lhomWithConstants L α).IsExpansionOn M]\n    {t : L[[α]].Term β} {v : β → M} :\n    t.constantsToVars.realize (Sum.elim (fun a => ↑(L.con a)) v) = t.realize v := by\n  induction' t with _ n f ts ih\n  · simp\n  · cases n\n    · cases f\n      · simp only [realize, ih, constantsOn, constantsOnFunc, constantsToVars]\n        -- Porting note: below lemma does not work with simp for some reason\n        rw [withConstants_funMap_sum_inl]\n      · simp only [realize, constantsToVars, Sum.elim_inl, funMap_eq_coe_constants]\n        rfl\n    · cases' f with _ f\n      · simp only [realize, ih, constantsOn, constantsOnFunc, constantsToVars]\n        -- Porting note: below lemma does not work with simp for some reason\n        rw [withConstants_funMap_sum_inl]\n      · exact isEmptyElim f\n\n"}
{"name":"FirstOrder.Language.Term.realize_varsToConstants","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝² : L.Structure M\nα : Type u'\nβ : Type v'\ninst✝¹ : (L.withConstants α).Structure M\ninst✝ : (L.lhomWithConstants α).IsExpansionOn M\nt : L.Term (Sum α β)\nv : β → M\n⊢ Eq (FirstOrder.Language.Term.realize v t.varsToConstants) (FirstOrder.Language.Term.realize (Sum.elim (fun a => ↑(L.con a)) v) t)","decl":"@[simp]\ntheorem realize_varsToConstants [L[[α]].Structure M] [(lhomWithConstants L α).IsExpansionOn M]\n    {t : L.Term (α ⊕ β)} {v : β → M} :\n    t.varsToConstants.realize v = t.realize (Sum.elim (fun a => ↑(L.con a)) v) := by\n  induction' t with ab n f ts ih\n  · cases' ab with a b\n    -- Porting note: both cases were `simp [Language.con]`\n    · simp [Language.con, realize, funMap_eq_coe_constants]\n    · simp [realize, constantMap]\n  · simp only [realize, constantsOn, constantsOnFunc, ih, varsToConstants]\n    -- Porting note: below lemma does not work with simp for some reason\n    rw [withConstants_funMap_sum_inl]\n\n"}
{"name":"FirstOrder.Language.Term.realize_constantsVarsEquivLeft","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝² : L.Structure M\nα : Type u'\nβ : Type v'\ninst✝¹ : (L.withConstants α).Structure M\ninst✝ : (L.lhomWithConstants α).IsExpansionOn M\nn : Nat\nt : (L.withConstants α).Term (Sum β (Fin n))\nv : β → M\nxs : Fin n → M\n⊢ Eq (FirstOrder.Language.Term.realize (Sum.elim (Sum.elim (fun a => ↑(L.con a)) v) xs) (FirstOrder.Language.Term.constantsVarsEquivLeft t)) (FirstOrder.Language.Term.realize (Sum.elim v xs) t)","decl":"theorem realize_constantsVarsEquivLeft [L[[α]].Structure M]\n    [(lhomWithConstants L α).IsExpansionOn M] {n} {t : L[[α]].Term (β ⊕ (Fin n))} {v : β → M}\n    {xs : Fin n → M} :\n    (constantsVarsEquivLeft t).realize (Sum.elim (Sum.elim (fun a => ↑(L.con a)) v) xs) =\n      t.realize (Sum.elim v xs) := by\n  simp only [constantsVarsEquivLeft, realize_relabel, Equiv.coe_trans, Function.comp_apply,\n    constantsVarsEquiv_apply, relabelEquiv_symm_apply]\n  refine _root_.trans ?_ realize_constantsToVars\n  rcongr x\n  rcases x with (a | (b | i)) <;> simp\n\n"}
{"name":"FirstOrder.Language.LHom.realize_onTerm","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nM : Type w\ninst✝² : L.Structure M\nα : Type u'\ninst✝¹ : L'.Structure M\nφ : L.LHom L'\ninst✝ : φ.IsExpansionOn M\nt : L.Term α\nv : α → M\n⊢ Eq (FirstOrder.Language.Term.realize v (φ.onTerm t)) (FirstOrder.Language.Term.realize v t)","decl":"@[simp]\ntheorem realize_onTerm [L'.Structure M] (φ : L →ᴸ L') [φ.IsExpansionOn M] (t : L.Term α)\n    (v : α → M) : (φ.onTerm t).realize v = t.realize v := by\n  induction' t with _ n f ts ih\n  · rfl\n  · simp only [Term.realize, LHom.onTerm, LHom.map_onFunction, ih]\n\n"}
{"name":"FirstOrder.Language.HomClass.realize_term","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝³ : L.Structure M\ninst✝² : L.Structure N\nα : Type u'\nF : Type u_4\ninst✝¹ : FunLike F M N\ninst✝ : L.HomClass F M N\ng : F\nt : L.Term α\nv : α → M\n⊢ Eq (FirstOrder.Language.Term.realize (Function.comp (⇑g) v) t) (g (FirstOrder.Language.Term.realize v t))","decl":"@[simp]\ntheorem HomClass.realize_term {F : Type*} [FunLike F M N] [HomClass L F M N]\n    (g : F) {t : L.Term α} {v : α → M} :\n    t.realize (g ∘ v) = g (t.realize v) := by\n  induction t\n  · rfl\n  · rw [Term.realize, Term.realize, HomClass.map_fun]\n    refine congr rfl ?_\n    ext x\n    simp [*]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_bot","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nl : Nat\nv : α → M\nxs : Fin l → M\n⊢ Iff (Bot.bot.Realize v xs) False","decl":"@[simp]\ntheorem realize_bot : (⊥ : L.BoundedFormula α l).Realize v xs ↔ False :=\n  Iff.rfl\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_not","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nl : Nat\nφ : L.BoundedFormula α l\nv : α → M\nxs : Fin l → M\n⊢ Iff (φ.not.Realize v xs) (Not (φ.Realize v xs))","decl":"@[simp]\ntheorem realize_not : φ.not.Realize v xs ↔ ¬φ.Realize v xs :=\n  Iff.rfl\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_bdEqual","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nl : Nat\nv : α → M\nxs : Fin l → M\nt₁ t₂ : L.Term (Sum α (Fin l))\n⊢ Iff ((t₁.bdEqual t₂).Realize v xs) (Eq (FirstOrder.Language.Term.realize (Sum.elim v xs) t₁) (FirstOrder.Language.Term.realize (Sum.elim v xs) t₂))","decl":"@[simp]\ntheorem realize_bdEqual (t₁ t₂ : L.Term (α ⊕ (Fin l))) :\n    (t₁.bdEqual t₂).Realize v xs ↔ t₁.realize (Sum.elim v xs) = t₂.realize (Sum.elim v xs) :=\n  Iff.rfl\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_top","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nl : Nat\nv : α → M\nxs : Fin l → M\n⊢ Iff (Top.top.Realize v xs) True","decl":"@[simp]\ntheorem realize_top : (⊤ : L.BoundedFormula α l).Realize v xs ↔ True := by simp [Top.top]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_inf","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nl : Nat\nφ ψ : L.BoundedFormula α l\nv : α → M\nxs : Fin l → M\n⊢ Iff ((Min.min φ ψ).Realize v xs) (And (φ.Realize v xs) (ψ.Realize v xs))","decl":"@[simp]\ntheorem realize_inf : (φ ⊓ ψ).Realize v xs ↔ φ.Realize v xs ∧ ψ.Realize v xs := by\n  simp [Inf.inf, Realize]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_foldr_inf","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nn : Nat\nl : List (L.BoundedFormula α n)\nv : α → M\nxs : Fin n → M\n⊢ Iff ((List.foldr (fun x1 x2 => Min.min x1 x2) Top.top l).Realize v xs) (∀ (φ : L.BoundedFormula α n), Membership.mem l φ → φ.Realize v xs)","decl":"@[simp]\ntheorem realize_foldr_inf (l : List (L.BoundedFormula α n)) (v : α → M) (xs : Fin n → M) :\n    (l.foldr (· ⊓ ·) ⊤).Realize v xs ↔ ∀ φ ∈ l, BoundedFormula.Realize φ v xs := by\n  induction' l with φ l ih\n  · simp\n  · simp [ih]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_imp","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nl : Nat\nφ ψ : L.BoundedFormula α l\nv : α → M\nxs : Fin l → M\n⊢ Iff ((φ.imp ψ).Realize v xs) (φ.Realize v xs → ψ.Realize v xs)","decl":"@[simp]\ntheorem realize_imp : (φ.imp ψ).Realize v xs ↔ φ.Realize v xs → ψ.Realize v xs := by\n  simp only [Realize]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_rel","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nl : Nat\nv : α → M\nxs : Fin l → M\nk : Nat\nR : L.Relations k\nts : Fin k → L.Term (Sum α (Fin l))\n⊢ Iff ((R.boundedFormula ts).Realize v xs) (FirstOrder.Language.Structure.RelMap R fun i => FirstOrder.Language.Term.realize (Sum.elim v xs) (ts i))","decl":"@[simp]\ntheorem realize_rel {k : ℕ} {R : L.Relations k} {ts : Fin k → L.Term _} :\n    (R.boundedFormula ts).Realize v xs ↔ RelMap R fun i => (ts i).realize (Sum.elim v xs) :=\n  Iff.rfl\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_rel₁","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nl : Nat\nv : α → M\nxs : Fin l → M\nR : L.Relations 1\nt : L.Term (Sum α (Fin l))\n⊢ Iff ((R.boundedFormula₁ t).Realize v xs) (FirstOrder.Language.Structure.RelMap R (Matrix.vecCons (FirstOrder.Language.Term.realize (Sum.elim v xs) t) Matrix.vecEmpty))","decl":"@[simp]\ntheorem realize_rel₁ {R : L.Relations 1} {t : L.Term _} :\n    (R.boundedFormula₁ t).Realize v xs ↔ RelMap R ![t.realize (Sum.elim v xs)] := by\n  rw [Relations.boundedFormula₁, realize_rel, iff_eq_eq]\n  refine congr rfl (funext fun _ => ?_)\n  simp only [Matrix.cons_val_fin_one]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_rel₂","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nl : Nat\nv : α → M\nxs : Fin l → M\nR : L.Relations 2\nt₁ t₂ : L.Term (Sum α (Fin l))\n⊢ Iff ((R.boundedFormula₂ t₁ t₂).Realize v xs) (FirstOrder.Language.Structure.RelMap R (Matrix.vecCons (FirstOrder.Language.Term.realize (Sum.elim v xs) t₁) (Matrix.vecCons (FirstOrder.Language.Term.realize (Sum.elim v xs) t₂) Matrix.vecEmpty)))","decl":"@[simp]\ntheorem realize_rel₂ {R : L.Relations 2} {t₁ t₂ : L.Term _} :\n    (R.boundedFormula₂ t₁ t₂).Realize v xs ↔\n      RelMap R ![t₁.realize (Sum.elim v xs), t₂.realize (Sum.elim v xs)] := by\n  rw [Relations.boundedFormula₂, realize_rel, iff_eq_eq]\n  refine congr rfl (funext (Fin.cases ?_ ?_))\n  · simp only [Matrix.cons_val_zero]\n  · simp only [Matrix.cons_val_succ, Matrix.cons_val_fin_one, forall_const]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_sup","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nl : Nat\nφ ψ : L.BoundedFormula α l\nv : α → M\nxs : Fin l → M\n⊢ Iff ((Max.max φ ψ).Realize v xs) (Or (φ.Realize v xs) (ψ.Realize v xs))","decl":"@[simp]\ntheorem realize_sup : (φ ⊔ ψ).Realize v xs ↔ φ.Realize v xs ∨ ψ.Realize v xs := by\n  simp only [realize, max, realize_not, eq_iff_iff]\n  tauto\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_foldr_sup","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nn : Nat\nl : List (L.BoundedFormula α n)\nv : α → M\nxs : Fin n → M\n⊢ Iff ((List.foldr (fun x1 x2 => Max.max x1 x2) Bot.bot l).Realize v xs) (Exists fun φ => And (Membership.mem l φ) (φ.Realize v xs))","decl":"@[simp]\ntheorem realize_foldr_sup (l : List (L.BoundedFormula α n)) (v : α → M) (xs : Fin n → M) :\n    (l.foldr (· ⊔ ·) ⊥).Realize v xs ↔ ∃ φ ∈ l, BoundedFormula.Realize φ v xs := by\n  induction' l with φ l ih\n  · simp\n  · simp_rw [List.foldr_cons, realize_sup, ih, List.mem_cons, or_and_right, exists_or,\n      exists_eq_left]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_all","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nl : Nat\nθ : L.BoundedFormula α l.succ\nv : α → M\nxs : Fin l → M\n⊢ Iff (θ.all.Realize v xs) (∀ (a : M), θ.Realize v (Fin.snoc xs a))","decl":"@[simp]\ntheorem realize_all : (all θ).Realize v xs ↔ ∀ a : M, θ.Realize v (Fin.snoc xs a) :=\n  Iff.rfl\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_ex","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nl : Nat\nθ : L.BoundedFormula α l.succ\nv : α → M\nxs : Fin l → M\n⊢ Iff (θ.ex.Realize v xs) (Exists fun a => θ.Realize v (Fin.snoc xs a))","decl":"@[simp]\ntheorem realize_ex : θ.ex.Realize v xs ↔ ∃ a : M, θ.Realize v (Fin.snoc xs a) := by\n  rw [BoundedFormula.ex, realize_not, realize_all, not_forall]\n  simp_rw [realize_not, Classical.not_not]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_iff","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nl : Nat\nφ ψ : L.BoundedFormula α l\nv : α → M\nxs : Fin l → M\n⊢ Iff ((φ.iff ψ).Realize v xs) (Iff (φ.Realize v xs) (ψ.Realize v xs))","decl":"@[simp]\ntheorem realize_iff : (φ.iff ψ).Realize v xs ↔ (φ.Realize v xs ↔ ψ.Realize v xs) := by\n  simp only [BoundedFormula.iff, realize_inf, realize_imp, and_imp, ← iff_def]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_castLE_of_eq","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nm n : Nat\nh : Eq m n\nh' : LE.le m n\nφ : L.BoundedFormula α m\nv : α → M\nxs : Fin n → M\n⊢ Iff ((FirstOrder.Language.BoundedFormula.castLE h' φ).Realize v xs) (φ.Realize v (Function.comp xs (Fin.cast h)))","decl":"theorem realize_castLE_of_eq {m n : ℕ} (h : m = n) {h' : m ≤ n} {φ : L.BoundedFormula α m}\n    {v : α → M} {xs : Fin n → M} : (φ.castLE h').Realize v xs ↔ φ.Realize v (xs ∘ Fin.cast h) := by\n  subst h\n  simp only [castLE_rfl, cast_refl, OrderIso.coe_refl, Function.comp_id]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_mapTermRel_id","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\nα : Type u'\nβ : Type v'\ninst✝ : L'.Structure M\nft : (n : Nat) → L.Term (Sum α (Fin n)) → L'.Term (Sum β (Fin n))\nfr : (n : Nat) → L.Relations n → L'.Relations n\nn : Nat\nφ : L.BoundedFormula α n\nv : α → M\nv' : β → M\nxs : Fin n → M\nh1 : ∀ (n : Nat) (t : L.Term (Sum α (Fin n))) (xs : Fin n → M), Eq (FirstOrder.Language.Term.realize (Sum.elim v' xs) (ft n t)) (FirstOrder.Language.Term.realize (Sum.elim v xs) t)\nh2 : ∀ (n : Nat) (R : L.Relations n) (x : Fin n → M), Eq (FirstOrder.Language.Structure.RelMap (fr n R) x) (FirstOrder.Language.Structure.RelMap R x)\n⊢ Iff ((FirstOrder.Language.BoundedFormula.mapTermRel ft fr (fun x => id) φ).Realize v' xs) (φ.Realize v xs)","decl":"theorem realize_mapTermRel_id [L'.Structure M]\n    {ft : ∀ n, L.Term (α ⊕ (Fin n)) → L'.Term (β ⊕ (Fin n))}\n    {fr : ∀ n, L.Relations n → L'.Relations n} {n} {φ : L.BoundedFormula α n} {v : α → M}\n    {v' : β → M} {xs : Fin n → M}\n    (h1 :\n      ∀ (n) (t : L.Term (α ⊕ (Fin n))) (xs : Fin n → M),\n        (ft n t).realize (Sum.elim v' xs) = t.realize (Sum.elim v xs))\n    (h2 : ∀ (n) (R : L.Relations n) (x : Fin n → M), RelMap (fr n R) x = RelMap R x) :\n    (φ.mapTermRel ft fr fun _ => id).Realize v' xs ↔ φ.Realize v xs := by\n  induction φ with\n  | falsum => rfl\n  | equal => simp [mapTermRel, Realize, h1]\n  | rel => simp [mapTermRel, Realize, h1, h2]\n  | imp _ _ ih1 ih2 => simp [mapTermRel, Realize, ih1, ih2]\n  | all _ ih => simp only [mapTermRel, Realize, ih, id]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_mapTermRel_add_castLe","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\nα : Type u'\nβ : Type v'\ninst✝ : L'.Structure M\nk : Nat\nft : (n : Nat) → L.Term (Sum α (Fin n)) → L'.Term (Sum β (Fin (HAdd.hAdd k n)))\nfr : (n : Nat) → L.Relations n → L'.Relations n\nn : Nat\nφ : L.BoundedFormula α n\nv : {n : Nat} → (Fin (HAdd.hAdd k n) → M) → α → M\nv' : β → M\nxs : Fin (HAdd.hAdd k n) → M\nh1 : ∀ (n : Nat) (t : L.Term (Sum α (Fin n))) (xs' : Fin (HAdd.hAdd k n) → M), Eq (FirstOrder.Language.Term.realize (Sum.elim v' xs') (ft n t)) (FirstOrder.Language.Term.realize (Sum.elim (v xs') (Function.comp xs' (Fin.natAdd k))) t)\nh2 : ∀ (n : Nat) (R : L.Relations n) (x : Fin n → M), Eq (FirstOrder.Language.Structure.RelMap (fr n R) x) (FirstOrder.Language.Structure.RelMap R x)\nhv : ∀ (n : Nat) (xs : Fin (HAdd.hAdd k n) → M) (x : M), Eq (v (Fin.snoc xs x)) (v xs)\n⊢ Iff ((FirstOrder.Language.BoundedFormula.mapTermRel ft fr (fun x => FirstOrder.Language.BoundedFormula.castLE ⋯) φ).Realize v' xs) (φ.Realize (v xs) (Function.comp xs (Fin.natAdd k)))","decl":"theorem realize_mapTermRel_add_castLe [L'.Structure M] {k : ℕ}\n    {ft : ∀ n, L.Term (α ⊕ (Fin n)) → L'.Term (β ⊕ (Fin (k + n)))}\n    {fr : ∀ n, L.Relations n → L'.Relations n} {n} {φ : L.BoundedFormula α n}\n    (v : ∀ {n}, (Fin (k + n) → M) → α → M) {v' : β → M} (xs : Fin (k + n) → M)\n    (h1 :\n      ∀ (n) (t : L.Term (α ⊕ (Fin n))) (xs' : Fin (k + n) → M),\n        (ft n t).realize (Sum.elim v' xs') = t.realize (Sum.elim (v xs') (xs' ∘ Fin.natAdd _)))\n    (h2 : ∀ (n) (R : L.Relations n) (x : Fin n → M), RelMap (fr n R) x = RelMap R x)\n    (hv : ∀ (n) (xs : Fin (k + n) → M) (x : M), @v (n + 1) (snoc xs x : Fin _ → M) = v xs) :\n    (φ.mapTermRel ft fr fun _ => castLE (add_assoc _ _ _).symm.le).Realize v' xs ↔\n      φ.Realize (v xs) (xs ∘ Fin.natAdd _) := by\n  induction φ with\n  | falsum => rfl\n  | equal => simp [mapTermRel, Realize, h1]\n  | rel => simp [mapTermRel, Realize, h1, h2]\n  | imp _ _ ih1 ih2 => simp [mapTermRel, Realize, ih1, ih2]\n  | all _ ih => simp [mapTermRel, Realize, ih, hv]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_relabel","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nβ : Type v'\nm n : Nat\nφ : L.BoundedFormula α n\ng : α → Sum β (Fin m)\nv : β → M\nxs : Fin (HAdd.hAdd m n) → M\n⊢ Iff ((FirstOrder.Language.BoundedFormula.relabel g φ).Realize v xs) (φ.Realize (Function.comp (Sum.elim v (Function.comp xs (Fin.castAdd n))) g) (Function.comp xs (Fin.natAdd m)))","decl":"@[simp]\ntheorem realize_relabel {m n : ℕ} {φ : L.BoundedFormula α n} {g : α → β ⊕ (Fin m)} {v : β → M}\n    {xs : Fin (m + n) → M} :\n    (φ.relabel g).Realize v xs ↔\n      φ.Realize (Sum.elim v (xs ∘ Fin.castAdd n) ∘ g) (xs ∘ Fin.natAdd m) := by\n  apply realize_mapTermRel_add_castLe <;> simp\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_liftAt","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nn n' m : Nat\nφ : L.BoundedFormula α n\nv : α → M\nxs : Fin (HAdd.hAdd n n') → M\nhmn : LE.le (HAdd.hAdd m n') (HAdd.hAdd n 1)\n⊢ Iff ((FirstOrder.Language.BoundedFormula.liftAt n' m φ).Realize v xs) (φ.Realize v (Function.comp xs fun i => ite (LT.lt (↑i) m) (Fin.castAdd n' i) (i.addNat n')))","decl":"theorem realize_liftAt {n n' m : ℕ} {φ : L.BoundedFormula α n} {v : α → M} {xs : Fin (n + n') → M}\n    (hmn : m + n' ≤ n + 1) :\n    (φ.liftAt n' m).Realize v xs ↔\n      φ.Realize v (xs ∘ fun i => if ↑i < m then Fin.castAdd n' i else Fin.addNat i n') := by\n  rw [liftAt]\n  induction φ with\n  | falsum => simp [mapTermRel, Realize]\n  | equal => simp [mapTermRel, Realize, realize_rel, realize_liftAt, Sum.elim_comp_map]\n  | rel => simp [mapTermRel, Realize, realize_rel, realize_liftAt, Sum.elim_comp_map]\n  | imp _ _ ih1 ih2 => simp only [mapTermRel, Realize, ih1 hmn, ih2 hmn]\n  | @all k _ ih3 =>\n    have h : k + 1 + n' = k + n' + 1 := by rw [add_assoc, add_comm 1 n', ← add_assoc]\n    simp only [mapTermRel, Realize, realize_castLE_of_eq h, ih3 (hmn.trans k.succ.le_succ)]\n    refine forall_congr' fun x => iff_eq_eq.mpr (congr rfl (funext (Fin.lastCases ?_ fun i => ?_)))\n    · simp only [Function.comp_apply, val_last, snoc_last]\n      refine (congr rfl (Fin.ext ?_)).trans (snoc_last _ _)\n      split_ifs <;> dsimp; omega\n    · simp only [Function.comp_apply, Fin.snoc_castSucc]\n      refine (congr rfl (Fin.ext ?_)).trans (snoc_castSucc _ _ _)\n      simp only [coe_castSucc, coe_cast]\n      split_ifs <;> simp\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_liftAt_one","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nn m : Nat\nφ : L.BoundedFormula α n\nv : α → M\nxs : Fin (HAdd.hAdd n 1) → M\nhmn : LE.le m n\n⊢ Iff ((FirstOrder.Language.BoundedFormula.liftAt 1 m φ).Realize v xs) (φ.Realize v (Function.comp xs fun i => ite (LT.lt (↑i) m) i.castSucc i.succ))","decl":"theorem realize_liftAt_one {n m : ℕ} {φ : L.BoundedFormula α n} {v : α → M} {xs : Fin (n + 1) → M}\n    (hmn : m ≤ n) :\n    (φ.liftAt 1 m).Realize v xs ↔\n      φ.Realize v (xs ∘ fun i => if ↑i < m then castSucc i else i.succ) := by\n  simp [realize_liftAt (add_le_add_right hmn 1), castSucc]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_liftAt_one_self","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nn : Nat\nφ : L.BoundedFormula α n\nv : α → M\nxs : Fin (HAdd.hAdd n 1) → M\n⊢ Iff ((FirstOrder.Language.BoundedFormula.liftAt 1 n φ).Realize v xs) (φ.Realize v (Function.comp xs Fin.castSucc))","decl":"@[simp]\ntheorem realize_liftAt_one_self {n : ℕ} {φ : L.BoundedFormula α n} {v : α → M}\n    {xs : Fin (n + 1) → M} : (φ.liftAt 1 n).Realize v xs ↔ φ.Realize v (xs ∘ castSucc) := by\n  rw [realize_liftAt_one (refl n), iff_eq_eq]\n  refine congr rfl (congr rfl (funext fun i => ?_))\n  rw [if_pos i.is_lt]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_subst","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nβ : Type v'\nn : Nat\nφ : L.BoundedFormula α n\ntf : α → L.Term β\nv : β → M\nxs : Fin n → M\n⊢ Iff ((φ.subst tf).Realize v xs) (φ.Realize (fun a => FirstOrder.Language.Term.realize v (tf a)) xs)","decl":"@[simp]\ntheorem realize_subst {φ : L.BoundedFormula α n} {tf : α → L.Term β} {v : β → M} {xs : Fin n → M} :\n    (φ.subst tf).Realize v xs ↔ φ.Realize (fun a => (tf a).realize v) xs :=\n  realize_mapTermRel_id\n    (fun n t x => by\n      rw [Term.realize_subst]\n      rcongr a\n      cases a\n      · simp only [Sum.elim_inl, Function.comp_apply, Term.realize_relabel, Sum.elim_comp_inl]\n      · rfl)\n    (by simp)\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_restrictFreeVar","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\nα : Type u'\nβ : Type v'\ninst✝ : DecidableEq α\nn : Nat\nφ : L.BoundedFormula α n\nf : (Subtype fun x => Membership.mem φ.freeVarFinset x) → β\nv : β → M\nxs : Fin n → M\nv' : α → M\nhv' : ∀ (a : Subtype fun x => Membership.mem φ.freeVarFinset x), Eq (v (f a)) (v' ↑a)\n⊢ Iff ((φ.restrictFreeVar f).Realize v xs) (φ.Realize v' xs)","decl":"theorem realize_restrictFreeVar [DecidableEq α] {n : ℕ} {φ : L.BoundedFormula α n}\n    {f : φ.freeVarFinset → β} {v : β → M} {xs : Fin n → M}\n    (v' : α → M) (hv' : ∀ a, v (f a) = v' a) :\n    (φ.restrictFreeVar f).Realize v xs ↔ φ.Realize v' xs := by\n  induction φ with\n  | falsum => rfl\n  | equal =>\n    simp only [Realize, restrictFreeVar, freeVarFinset.eq_2]\n    rw [realize_restrictVarLeft v' (by simp [hv']), realize_restrictVarLeft v' (by simp [hv'])]\n    simp [Function.comp_apply]\n  | rel =>\n    simp only [Realize, freeVarFinset.eq_3, Finset.biUnion_val, restrictFreeVar]\n    congr!\n    rw [realize_restrictVarLeft v' (by simp [hv'])]\n    simp [Function.comp_apply]\n  | imp _ _ ih1 ih2 =>\n    simp only [Realize, restrictFreeVar, freeVarFinset.eq_4]\n    rw [ih1, ih2] <;> simp [hv']\n  | all _ ih3 =>\n    simp only [restrictFreeVar, Realize]\n    refine forall_congr' (fun _ => ?_)\n    rw [ih3]; simp [hv']\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_restrictFreeVar'","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\nα : Type u'\ninst✝ : DecidableEq α\nn : Nat\nφ : L.BoundedFormula α n\ns : Set α\nh : HasSubset.Subset (↑φ.freeVarFinset) s\nv : α → M\nxs : Fin n → M\n⊢ Iff ((φ.restrictFreeVar (Set.inclusion h)).Realize (Function.comp v Subtype.val) xs) (φ.Realize v xs)","decl":"/-- A special case of `realize_restrictFreeVar`, included because we can add the `simp` attribute\nto it -/\n@[simp]\ntheorem realize_restrictFreeVar' [DecidableEq α] {n : ℕ} {φ : L.BoundedFormula α n} {s : Set α}\n    (h : ↑φ.freeVarFinset ⊆ s) {v : α → M} {xs : Fin n → M} :\n    (φ.restrictFreeVar (Set.inclusion h)).Realize (v ∘ (↑)) xs ↔ φ.Realize v xs :=\n  realize_restrictFreeVar _ (by simp)\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_constantsVarsEquiv","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝² : L.Structure M\nα : Type u'\nβ : Type v'\ninst✝¹ : (L.withConstants α).Structure M\ninst✝ : (L.lhomWithConstants α).IsExpansionOn M\nn : Nat\nφ : (L.withConstants α).BoundedFormula β n\nv : β → M\nxs : Fin n → M\n⊢ Iff ((FirstOrder.Language.BoundedFormula.constantsVarsEquiv φ).Realize (Sum.elim (fun a => ↑(L.con a)) v) xs) (φ.Realize v xs)","decl":"theorem realize_constantsVarsEquiv [L[[α]].Structure M] [(lhomWithConstants L α).IsExpansionOn M]\n    {n} {φ : L[[α]].BoundedFormula β n} {v : β → M} {xs : Fin n → M} :\n    (constantsVarsEquiv φ).Realize (Sum.elim (fun a => ↑(L.con a)) v) xs ↔ φ.Realize v xs := by\n  refine realize_mapTermRel_id (fun n t xs => realize_constantsVarsEquivLeft) fun n R xs => ?_\n  -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n  erw [← (lhomWithConstants L α).map_onRelation\n      (Equiv.sumEmpty (L.Relations n) ((constantsOn α).Relations n) R) xs]\n  rcongr\n  cases' R with R R\n  · simp\n  · exact isEmptyElim R\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_relabelEquiv","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nβ : Type v'\ng : Equiv α β\nk : Nat\nφ : L.BoundedFormula α k\nv : β → M\nxs : Fin k → M\n⊢ Iff (((FirstOrder.Language.BoundedFormula.relabelEquiv g) φ).Realize v xs) (φ.Realize (Function.comp v ⇑g) xs)","decl":"@[simp]\ntheorem realize_relabelEquiv {g : α ≃ β} {k} {φ : L.BoundedFormula α k} {v : β → M}\n    {xs : Fin k → M} : (relabelEquiv g φ).Realize v xs ↔ φ.Realize (v ∘ g) xs := by\n  simp only [relabelEquiv, mapTermRelEquiv_apply, Equiv.coe_refl]\n  refine realize_mapTermRel_id (fun n t xs => ?_) fun _ _ _ => rfl\n  simp only [relabelEquiv_apply, Term.realize_relabel]\n  refine congr (congr rfl ?_) rfl\n  ext (i | i) <;> rfl\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_all_liftAt_one_self","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\nα : Type u'\ninst✝ : Nonempty M\nn : Nat\nφ : L.BoundedFormula α n\nv : α → M\nxs : Fin n → M\n⊢ Iff ((FirstOrder.Language.BoundedFormula.liftAt 1 n φ).all.Realize v xs) (φ.Realize v xs)","decl":"theorem realize_all_liftAt_one_self {n : ℕ} {φ : L.BoundedFormula α n} {v : α → M}\n    {xs : Fin n → M} : (φ.liftAt 1 n).all.Realize v xs ↔ φ.Realize v xs := by\n  inhabit M\n  simp only [realize_all, realize_liftAt_one_self]\n  refine ⟨fun h => ?_, fun h a => ?_⟩\n  · refine (congr rfl (funext fun i => ?_)).mp (h default)\n    simp\n  · refine (congr rfl (funext fun i => ?_)).mp h\n    simp\n\n"}
{"name":"FirstOrder.Language.LHom.realize_onBoundedFormula","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nM : Type w\ninst✝² : L.Structure M\nα : Type u'\ninst✝¹ : L'.Structure M\nφ : L.LHom L'\ninst✝ : φ.IsExpansionOn M\nn : Nat\nψ : L.BoundedFormula α n\nv : α → M\nxs : Fin n → M\n⊢ Iff ((φ.onBoundedFormula ψ).Realize v xs) (ψ.Realize v xs)","decl":"@[simp]\ntheorem realize_onBoundedFormula [L'.Structure M] (φ : L →ᴸ L') [φ.IsExpansionOn M] {n : ℕ}\n    (ψ : L.BoundedFormula α n) {v : α → M} {xs : Fin n → M} :\n    (φ.onBoundedFormula ψ).Realize v xs ↔ ψ.Realize v xs := by\n  induction ψ with\n  | falsum => rfl\n  | equal => simp only [onBoundedFormula, realize_bdEqual, realize_onTerm]; rfl\n  | rel =>\n    simp only [onBoundedFormula, realize_rel, LHom.map_onRelation,\n      Function.comp_apply, realize_onTerm]\n    rfl\n  | imp _ _ ih1 ih2 => simp only [onBoundedFormula, ih1, ih2, realize_imp]\n  | all _ ih3 => simp only [onBoundedFormula, ih3, realize_all]\n\n"}
{"name":"FirstOrder.Language.Formula.realize_not","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nφ : L.Formula α\nv : α → M\n⊢ Iff (φ.not.Realize v) (Not (φ.Realize v))","decl":"@[simp]\ntheorem realize_not : φ.not.Realize v ↔ ¬φ.Realize v :=\n  Iff.rfl\n\n"}
{"name":"FirstOrder.Language.Formula.realize_bot","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nv : α → M\n⊢ Iff (Bot.bot.Realize v) False","decl":"@[simp]\ntheorem realize_bot : (⊥ : L.Formula α).Realize v ↔ False :=\n  Iff.rfl\n\n"}
{"name":"FirstOrder.Language.Formula.realize_top","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nv : α → M\n⊢ Iff (Top.top.Realize v) True","decl":"@[simp]\ntheorem realize_top : (⊤ : L.Formula α).Realize v ↔ True :=\n  BoundedFormula.realize_top\n\n"}
{"name":"FirstOrder.Language.Formula.realize_inf","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nφ ψ : L.Formula α\nv : α → M\n⊢ Iff ((Min.min φ ψ).Realize v) (And (φ.Realize v) (ψ.Realize v))","decl":"@[simp]\ntheorem realize_inf : (φ ⊓ ψ).Realize v ↔ φ.Realize v ∧ ψ.Realize v :=\n  BoundedFormula.realize_inf\n\n"}
{"name":"FirstOrder.Language.Formula.realize_imp","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nφ ψ : L.Formula α\nv : α → M\n⊢ Iff ((φ.imp ψ).Realize v) (φ.Realize v → ψ.Realize v)","decl":"@[simp]\ntheorem realize_imp : (φ.imp ψ).Realize v ↔ φ.Realize v → ψ.Realize v :=\n  BoundedFormula.realize_imp\n\n"}
{"name":"FirstOrder.Language.Formula.realize_rel","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nv : α → M\nk : Nat\nR : L.Relations k\nts : Fin k → L.Term α\n⊢ Iff ((R.formula ts).Realize v) (FirstOrder.Language.Structure.RelMap R fun i => FirstOrder.Language.Term.realize v (ts i))","decl":"@[simp]\ntheorem realize_rel {k : ℕ} {R : L.Relations k} {ts : Fin k → L.Term α} :\n    (R.formula ts).Realize v ↔ RelMap R fun i => (ts i).realize v :=\n  BoundedFormula.realize_rel.trans (by simp)\n\n"}
{"name":"FirstOrder.Language.Formula.realize_rel₁","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nv : α → M\nR : L.Relations 1\nt : L.Term α\n⊢ Iff ((R.formula₁ t).Realize v) (FirstOrder.Language.Structure.RelMap R (Matrix.vecCons (FirstOrder.Language.Term.realize v t) Matrix.vecEmpty))","decl":"@[simp]\ntheorem realize_rel₁ {R : L.Relations 1} {t : L.Term _} :\n    (R.formula₁ t).Realize v ↔ RelMap R ![t.realize v] := by\n  rw [Relations.formula₁, realize_rel, iff_eq_eq]\n  refine congr rfl (funext fun _ => ?_)\n  simp only [Matrix.cons_val_fin_one]\n\n"}
{"name":"FirstOrder.Language.Formula.realize_rel₂","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nv : α → M\nR : L.Relations 2\nt₁ t₂ : L.Term α\n⊢ Iff ((R.formula₂ t₁ t₂).Realize v) (FirstOrder.Language.Structure.RelMap R (Matrix.vecCons (FirstOrder.Language.Term.realize v t₁) (Matrix.vecCons (FirstOrder.Language.Term.realize v t₂) Matrix.vecEmpty)))","decl":"@[simp]\ntheorem realize_rel₂ {R : L.Relations 2} {t₁ t₂ : L.Term _} :\n    (R.formula₂ t₁ t₂).Realize v ↔ RelMap R ![t₁.realize v, t₂.realize v] := by\n  rw [Relations.formula₂, realize_rel, iff_eq_eq]\n  refine congr rfl (funext (Fin.cases ?_ ?_))\n  · simp only [Matrix.cons_val_zero]\n  · simp only [Matrix.cons_val_succ, Matrix.cons_val_fin_one, forall_const]\n\n"}
{"name":"FirstOrder.Language.Formula.realize_sup","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nφ ψ : L.Formula α\nv : α → M\n⊢ Iff ((Max.max φ ψ).Realize v) (Or (φ.Realize v) (ψ.Realize v))","decl":"@[simp]\ntheorem realize_sup : (φ ⊔ ψ).Realize v ↔ φ.Realize v ∨ ψ.Realize v :=\n  BoundedFormula.realize_sup\n\n"}
{"name":"FirstOrder.Language.Formula.realize_iff","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nφ ψ : L.Formula α\nv : α → M\n⊢ Iff ((φ.iff ψ).Realize v) (Iff (φ.Realize v) (ψ.Realize v))","decl":"@[simp]\ntheorem realize_iff : (φ.iff ψ).Realize v ↔ (φ.Realize v ↔ ψ.Realize v) :=\n  BoundedFormula.realize_iff\n\n"}
{"name":"FirstOrder.Language.Formula.realize_relabel","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nβ : Type v'\nφ : L.Formula α\ng : α → β\nv : β → M\n⊢ Iff ((FirstOrder.Language.Formula.relabel g φ).Realize v) (φ.Realize (Function.comp v g))","decl":"@[simp]\ntheorem realize_relabel {φ : L.Formula α} {g : α → β} {v : β → M} :\n    (φ.relabel g).Realize v ↔ φ.Realize (v ∘ g) := by\n  rw [Realize, Realize, relabel, BoundedFormula.realize_relabel, iff_eq_eq, Fin.castAdd_zero]\n  exact congr rfl (funext finZeroElim)\n\n"}
{"name":"FirstOrder.Language.Formula.realize_relabel_sum_inr","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nn : Nat\nφ : L.Formula (Fin n)\nv : Empty → M\nx : Fin n → M\n⊢ Iff ((FirstOrder.Language.BoundedFormula.relabel Sum.inr φ).Realize v x) (φ.Realize x)","decl":"theorem realize_relabel_sum_inr (φ : L.Formula (Fin n)) {v : Empty → M} {x : Fin n → M} :\n    (BoundedFormula.relabel Sum.inr φ).Realize v x ↔ φ.Realize x := by\n  rw [BoundedFormula.realize_relabel, Formula.Realize, Sum.elim_comp_inr, Fin.castAdd_zero,\n    cast_refl, Function.comp_id,\n    Subsingleton.elim (x ∘ (natAdd n : Fin 0 → Fin n)) default]\n\n"}
{"name":"FirstOrder.Language.Formula.realize_equal","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nt₁ t₂ : L.Term α\nx : α → M\n⊢ Iff ((t₁.equal t₂).Realize x) (Eq (FirstOrder.Language.Term.realize x t₁) (FirstOrder.Language.Term.realize x t₂))","decl":"@[simp]\ntheorem realize_equal {t₁ t₂ : L.Term α} {x : α → M} :\n    (t₁.equal t₂).Realize x ↔ t₁.realize x = t₂.realize x := by simp [Term.equal, Realize]\n\n"}
{"name":"FirstOrder.Language.Formula.realize_graph","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nn : Nat\nf : L.Functions n\nx : Fin n → M\ny : M\n⊢ Iff ((FirstOrder.Language.Formula.graph f).Realize (Fin.cons y x)) (Eq (FirstOrder.Language.Structure.funMap f x) y)","decl":"@[simp]\ntheorem realize_graph {f : L.Functions n} {x : Fin n → M} {y : M} :\n    (Formula.graph f).Realize (Fin.cons y x : _ → M) ↔ funMap f x = y := by\n  simp only [Formula.graph, Term.realize, realize_equal, Fin.cons_zero, Fin.cons_succ]\n  rw [eq_comm]\n\n"}
{"name":"FirstOrder.Language.Formula.boundedFormula_realize_eq_realize","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nφ : L.Formula α\nx : α → M\ny : Fin 0 → M\n⊢ Iff (FirstOrder.Language.BoundedFormula.Realize φ x y) (φ.Realize x)","decl":"theorem boundedFormula_realize_eq_realize (φ : L.Formula α) (x : α → M) (y : Fin 0 → M) :\n    BoundedFormula.Realize φ x y ↔ φ.Realize x := by\n  rw [Formula.Realize, iff_iff_eq]\n  congr\n  ext i; exact Fin.elim0 i\n\n"}
{"name":"FirstOrder.Language.LHom.realize_onFormula","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nM : Type w\ninst✝² : L.Structure M\nα : Type u'\ninst✝¹ : L'.Structure M\nφ : L.LHom L'\ninst✝ : φ.IsExpansionOn M\nψ : L.Formula α\nv : α → M\n⊢ Iff ((φ.onFormula ψ).Realize v) (ψ.Realize v)","decl":"@[simp]\ntheorem LHom.realize_onFormula [L'.Structure M] (φ : L →ᴸ L') [φ.IsExpansionOn M] (ψ : L.Formula α)\n    {v : α → M} : (φ.onFormula ψ).Realize v ↔ ψ.Realize v :=\n  φ.realize_onBoundedFormula ψ\n\n"}
{"name":"FirstOrder.Language.LHom.setOf_realize_onFormula","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nM : Type w\ninst✝² : L.Structure M\nα : Type u'\ninst✝¹ : L'.Structure M\nφ : L.LHom L'\ninst✝ : φ.IsExpansionOn M\nψ : L.Formula α\n⊢ Eq (setOf (φ.onFormula ψ).Realize) (setOf ψ.Realize)","decl":"@[simp]\ntheorem LHom.setOf_realize_onFormula [L'.Structure M] (φ : L →ᴸ L') [φ.IsExpansionOn M]\n    (ψ : L.Formula α) : (setOf (φ.onFormula ψ).Realize : Set (α → M)) = setOf ψ.Realize := by\n  ext\n  simp\n\n"}
{"name":"FirstOrder.Language.Sentence.realize_not","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nφ : L.Sentence\n⊢ Iff (FirstOrder.Language.Sentence.Realize M (FirstOrder.Language.Formula.not φ)) (Not (FirstOrder.Language.Sentence.Realize M φ))","decl":"@[simp]\ntheorem Sentence.realize_not {φ : L.Sentence} : M ⊨ φ.not ↔ ¬M ⊨ φ :=\n  Iff.rfl\n\n"}
{"name":"FirstOrder.Language.Formula.realize_equivSentence_symm_con","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝² : L.Structure M\nα : Type u'\ninst✝¹ : (L.withConstants α).Structure M\ninst✝ : (L.lhomWithConstants α).IsExpansionOn M\nφ : (L.withConstants α).Sentence\n⊢ Iff ((FirstOrder.Language.Formula.equivSentence.symm φ).Realize fun a => ↑(L.con a)) (FirstOrder.Language.Sentence.Realize M φ)","decl":"@[simp]\ntheorem realize_equivSentence_symm_con [L[[α]].Structure M]\n    [(L.lhomWithConstants α).IsExpansionOn M] (φ : L[[α]].Sentence) :\n    ((equivSentence.symm φ).Realize fun a => (L.con a : M)) ↔ φ.Realize M := by\n  simp only [equivSentence, _root_.Equiv.symm_symm, Equiv.coe_trans, Realize,\n    BoundedFormula.realize_relabelEquiv, Function.comp]\n  refine _root_.trans ?_ BoundedFormula.realize_constantsVarsEquiv\n  rw [iff_iff_eq]\n  congr with (_ | a)\n  · simp\n  · cases a\n\n"}
{"name":"FirstOrder.Language.Formula.realize_equivSentence","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝² : L.Structure M\nα : Type u'\ninst✝¹ : (L.withConstants α).Structure M\ninst✝ : (L.lhomWithConstants α).IsExpansionOn M\nφ : L.Formula α\n⊢ Iff (FirstOrder.Language.Sentence.Realize M (FirstOrder.Language.Formula.equivSentence φ)) (φ.Realize fun a => ↑(L.con a))","decl":"@[simp]\ntheorem realize_equivSentence [L[[α]].Structure M] [(L.lhomWithConstants α).IsExpansionOn M]\n    (φ : L.Formula α) : (equivSentence φ).Realize M ↔ φ.Realize fun a => (L.con a : M) := by\n  rw [← realize_equivSentence_symm_con M (equivSentence φ), _root_.Equiv.symm_apply_apply]\n\n"}
{"name":"FirstOrder.Language.Formula.realize_equivSentence_symm","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nφ : (L.withConstants α).Sentence\nv : α → M\n⊢ Iff ((FirstOrder.Language.Formula.equivSentence.symm φ).Realize v) (FirstOrder.Language.Sentence.Realize M φ)","decl":"theorem realize_equivSentence_symm (φ : L[[α]].Sentence) (v : α → M) :\n    (equivSentence.symm φ).Realize v ↔\n      @Sentence.Realize _ M (@Language.withConstantsStructure L M _ α (constantsOn.structure v))\n        φ :=\n  letI := constantsOn.structure v\n  realize_equivSentence_symm_con M φ\n\n"}
{"name":"FirstOrder.Language.LHom.realize_onSentence","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nM : Type w\ninst✝² : L.Structure M\ninst✝¹ : L'.Structure M\nφ : L.LHom L'\ninst✝ : φ.IsExpansionOn M\nψ : L.Sentence\n⊢ Iff (FirstOrder.Language.Sentence.Realize M (φ.onSentence ψ)) (FirstOrder.Language.Sentence.Realize M ψ)","decl":"@[simp]\ntheorem LHom.realize_onSentence [L'.Structure M] (φ : L →ᴸ L') [φ.IsExpansionOn M]\n    (ψ : L.Sentence) : M ⊨ φ.onSentence ψ ↔ M ⊨ ψ :=\n  φ.realize_onFormula ψ\n\n"}
{"name":"FirstOrder.Language.mem_completeTheory","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nφ : L.Sentence\n⊢ Iff (Membership.mem (L.completeTheory M) φ) (FirstOrder.Language.Sentence.Realize M φ)","decl":"@[simp]\ntheorem mem_completeTheory {φ : Sentence L} : φ ∈ L.completeTheory M ↔ M ⊨ φ :=\n  Iff.rfl\n\n"}
{"name":"FirstOrder.Language.elementarilyEquivalent_iff","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\n⊢ Iff (L.ElementarilyEquivalent M N) (∀ (φ : L.Sentence), Iff (FirstOrder.Language.Sentence.Realize M φ) (FirstOrder.Language.Sentence.Realize N φ))","decl":"theorem elementarilyEquivalent_iff : M ≅[L] N ↔ ∀ φ : L.Sentence, M ⊨ φ ↔ N ⊨ φ := by\n  simp only [ElementarilyEquivalent, Set.ext_iff, completeTheory, Set.mem_setOf_eq]\n\n"}
{"name":"FirstOrder.Language.Theory.Model.realize_of_mem","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nT : L.Theory\nself : FirstOrder.Language.Theory.Model M T\nφ : L.Sentence\na✝ : Membership.mem T φ\n⊢ FirstOrder.Language.Sentence.Realize M φ","decl":"/-- A model of a theory is a structure in which every sentence is realized as true. -/\nclass Theory.Model (T : L.Theory) : Prop where\n  realize_of_mem : ∀ φ ∈ T, M ⊨ φ\n\n-- input using \\|= or \\vDash, but not using \\models\n"}
{"name":"FirstOrder.Language.Theory.model_iff","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nT : L.Theory\n⊢ Iff (FirstOrder.Language.Theory.Model M T) (∀ (φ : L.Sentence), Membership.mem T φ → FirstOrder.Language.Sentence.Realize M φ)","decl":"@[simp default-10]\ntheorem Theory.model_iff : M ⊨ T ↔ ∀ φ ∈ T, M ⊨ φ :=\n  ⟨fun h => h.realize_of_mem, fun h => ⟨h⟩⟩\n\n"}
{"name":"FirstOrder.Language.Theory.realize_sentence_of_mem","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\nT : L.Theory\ninst✝ : FirstOrder.Language.Theory.Model M T\nφ : L.Sentence\nh : Membership.mem T φ\n⊢ FirstOrder.Language.Sentence.Realize M φ","decl":"theorem Theory.realize_sentence_of_mem [M ⊨ T] {φ : L.Sentence} (h : φ ∈ T) : M ⊨ φ :=\n  Theory.Model.realize_of_mem φ h\n\n"}
{"name":"FirstOrder.Language.LHom.onTheory_model","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nM : Type w\ninst✝² : L.Structure M\ninst✝¹ : L'.Structure M\nφ : L.LHom L'\ninst✝ : φ.IsExpansionOn M\nT : L.Theory\n⊢ Iff (FirstOrder.Language.Theory.Model M (φ.onTheory T)) (FirstOrder.Language.Theory.Model M T)","decl":"@[simp]\ntheorem LHom.onTheory_model [L'.Structure M] (φ : L →ᴸ L') [φ.IsExpansionOn M] (T : L.Theory) :\n    M ⊨ φ.onTheory T ↔ M ⊨ T := by simp [Theory.model_iff, LHom.onTheory]\n\n"}
{"name":"FirstOrder.Language.model_empty","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\n⊢ FirstOrder.Language.Theory.Model M EmptyCollection.emptyCollection","decl":"instance model_empty : M ⊨ (∅ : L.Theory) :=\n  ⟨fun φ hφ => (Set.not_mem_empty φ hφ).elim⟩\n\n"}
{"name":"FirstOrder.Language.Theory.Model.mono","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nT T' : L.Theory\n_h : FirstOrder.Language.Theory.Model M T'\nhs : HasSubset.Subset T T'\n⊢ FirstOrder.Language.Theory.Model M T","decl":"theorem Model.mono {T' : L.Theory} (_h : M ⊨ T') (hs : T ⊆ T') : M ⊨ T :=\n  ⟨fun _φ hφ => T'.realize_sentence_of_mem (hs hφ)⟩\n\n"}
{"name":"FirstOrder.Language.Theory.Model.union","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nT T' : L.Theory\nh : FirstOrder.Language.Theory.Model M T\nh' : FirstOrder.Language.Theory.Model M T'\n⊢ FirstOrder.Language.Theory.Model M (Union.union T T')","decl":"theorem Model.union {T' : L.Theory} (h : M ⊨ T) (h' : M ⊨ T') : M ⊨ T ∪ T' := by\n  simp only [model_iff, Set.mem_union] at *\n  exact fun φ hφ => hφ.elim (h _) (h' _)\n\n"}
{"name":"FirstOrder.Language.Theory.model_union_iff","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nT T' : L.Theory\n⊢ Iff (FirstOrder.Language.Theory.Model M (Union.union T T')) (And (FirstOrder.Language.Theory.Model M T) (FirstOrder.Language.Theory.Model M T'))","decl":"@[simp]\ntheorem model_union_iff {T' : L.Theory} : M ⊨ T ∪ T' ↔ M ⊨ T ∧ M ⊨ T' :=\n  ⟨fun h => ⟨h.mono Set.subset_union_left, h.mono Set.subset_union_right⟩, fun h =>\n    h.1.union h.2⟩\n\n"}
{"name":"FirstOrder.Language.Theory.model_singleton_iff","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nφ : L.Sentence\n⊢ Iff (FirstOrder.Language.Theory.Model M (Singleton.singleton φ)) (FirstOrder.Language.Sentence.Realize M φ)","decl":"@[simp]\ntheorem model_singleton_iff {φ : L.Sentence} : M ⊨ ({φ} : L.Theory) ↔ M ⊨ φ := by simp\n\n"}
{"name":"FirstOrder.Language.Theory.model_insert_iff","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nT : L.Theory\nφ : L.Sentence\n⊢ Iff (FirstOrder.Language.Theory.Model M (Insert.insert φ T)) (And (FirstOrder.Language.Sentence.Realize M φ) (FirstOrder.Language.Theory.Model M T))","decl":"theorem model_insert_iff {φ : L.Sentence} : M ⊨ insert φ T ↔ M ⊨ φ ∧ M ⊨ T := by\n  rw [Set.insert_eq, model_union_iff, model_singleton_iff]\n\n"}
{"name":"FirstOrder.Language.Theory.model_iff_subset_completeTheory","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nT : L.Theory\n⊢ Iff (FirstOrder.Language.Theory.Model M T) (HasSubset.Subset T (L.completeTheory M))","decl":"theorem model_iff_subset_completeTheory : M ⊨ T ↔ T ⊆ L.completeTheory M :=\n  T.model_iff\n\n"}
{"name":"FirstOrder.Language.Theory.completeTheory.subset","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nT : L.Theory\nMT : FirstOrder.Language.Theory.Model M T\n⊢ HasSubset.Subset T (L.completeTheory M)","decl":"theorem completeTheory.subset [MT : M ⊨ T] : T ⊆ L.completeTheory M :=\n  model_iff_subset_completeTheory.1 MT\n\n"}
{"name":"FirstOrder.Language.model_completeTheory","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\n⊢ FirstOrder.Language.Theory.Model M (L.completeTheory M)","decl":"instance model_completeTheory : M ⊨ L.completeTheory M :=\n  Theory.model_iff_subset_completeTheory.2 (subset_refl _)\n\n"}
{"name":"FirstOrder.Language.realize_iff_of_model_completeTheory","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝² : L.Structure M\ninst✝¹ : L.Structure N\ninst✝ : FirstOrder.Language.Theory.Model N (L.completeTheory M)\nφ : L.Sentence\n⊢ Iff (FirstOrder.Language.Sentence.Realize N φ) (FirstOrder.Language.Sentence.Realize M φ)","decl":"theorem realize_iff_of_model_completeTheory [N ⊨ L.completeTheory M] (φ : L.Sentence) :\n    N ⊨ φ ↔ M ⊨ φ := by\n  refine ⟨fun h => ?_, (L.completeTheory M).realize_sentence_of_mem⟩\n  contrapose! h\n  rw [← Sentence.realize_not] at *\n  exact (L.completeTheory M).realize_sentence_of_mem (mem_completeTheory.2 h)\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_alls","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nn : Nat\nφ : L.BoundedFormula α n\nv : α → M\n⊢ Iff (φ.alls.Realize v) (∀ (xs : Fin n → M), φ.Realize v xs)","decl":"@[simp]\ntheorem realize_alls {φ : L.BoundedFormula α n} {v : α → M} :\n    φ.alls.Realize v ↔ ∀ xs : Fin n → M, φ.Realize v xs := by\n  induction' n with n ih\n  · exact Unique.forall_iff.symm\n  · simp only [alls, ih, Realize]\n    exact ⟨fun h xs => Fin.snoc_init_self xs ▸ h _ _, fun h xs x => h (Fin.snoc xs x)⟩\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_exs","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nn : Nat\nφ : L.BoundedFormula α n\nv : α → M\n⊢ Iff (φ.exs.Realize v) (Exists fun xs => φ.Realize v xs)","decl":"@[simp]\ntheorem realize_exs {φ : L.BoundedFormula α n} {v : α → M} :\n    φ.exs.Realize v ↔ ∃ xs : Fin n → M, φ.Realize v xs := by\n  induction' n with n ih\n  · exact Unique.exists_iff.symm\n  · simp only [BoundedFormula.exs, ih, realize_ex]\n    constructor\n    · rintro ⟨xs, x, h⟩\n      exact ⟨_, h⟩\n    · rintro ⟨xs, h⟩\n      rw [← Fin.snoc_init_self xs] at h\n      exact ⟨_, _, h⟩\n\n"}
{"name":"FirstOrder.Language.Formula.realize_iAlls","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\nα : Type u'\nβ : Type v'\ninst✝ : Finite β\nφ : L.Formula (Sum α β)\nv : α → M\n⊢ Iff ((FirstOrder.Language.Formula.iAlls β φ).Realize v) (∀ (i : β → M), φ.Realize fun a => Sum.elim v i a)","decl":"@[simp]\ntheorem _root_.FirstOrder.Language.Formula.realize_iAlls\n    [Finite β] {φ : L.Formula (α ⊕ β)} {v : α → M} : (φ.iAlls β).Realize v ↔\n      ∀ (i : β → M), φ.Realize (fun a => Sum.elim v i a) := by\n  let e := Classical.choice (Classical.choose_spec (Finite.exists_equiv_fin β))\n  rw [Formula.iAlls]\n  simp only [Nat.add_zero, realize_alls, realize_relabel, Function.comp_def,\n    castAdd_zero, finCongr_refl, OrderIso.refl_apply, Sum.elim_map, id_eq]\n  refine Equiv.forall_congr ?_ ?_\n  · exact ⟨fun v => v ∘ e, fun v => v ∘ e.symm,\n      fun _ => by simp [Function.comp_def],\n      fun _ => by simp [Function.comp_def]⟩\n  · intro x\n    rw [Formula.Realize, iff_iff_eq]\n    congr\n    funext i\n    exact i.elim0\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_iAlls","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\nα : Type u'\nβ : Type v'\ninst✝ : Finite β\nφ : L.Formula (Sum α β)\nv : α → M\nv' : Fin 0 → M\n⊢ Iff (FirstOrder.Language.BoundedFormula.Realize (FirstOrder.Language.Formula.iAlls β φ) v v') (∀ (i : β → M), φ.Realize fun a => Sum.elim v i a)","decl":"@[simp]\ntheorem realize_iAlls [Finite β] {φ : L.Formula (α ⊕ β)} {v : α → M} {v' : Fin 0 → M} :\n    BoundedFormula.Realize (φ.iAlls β) v v' ↔\n      ∀ (i : β → M), φ.Realize (fun a => Sum.elim v i a) := by\n  rw [← Formula.realize_iAlls, iff_iff_eq]; congr; simp [eq_iff_true_of_subsingleton]\n\n"}
{"name":"FirstOrder.Language.Formula.realize_iExs","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\nα : Type u'\nγ : Type u_3\ninst✝ : Finite γ\nφ : L.Formula (Sum α γ)\nv : α → M\n⊢ Iff ((FirstOrder.Language.Formula.iExs γ φ).Realize v) (Exists fun i => φ.Realize (Sum.elim v i))","decl":"@[simp]\ntheorem _root_.FirstOrder.Language.Formula.realize_iExs\n    [Finite γ] {φ : L.Formula (α ⊕ γ)} {v : α → M} : (φ.iExs γ).Realize v ↔\n      ∃ (i : γ → M), φ.Realize (Sum.elim v i) := by\n  let e := Classical.choice (Classical.choose_spec (Finite.exists_equiv_fin γ))\n  rw [Formula.iExs]\n  simp only [Nat.add_zero, realize_exs, realize_relabel, Function.comp_def,\n    castAdd_zero, finCongr_refl, OrderIso.refl_apply, Sum.elim_map, id_eq]\n  refine Equiv.exists_congr ?_ ?_\n  · exact ⟨fun v => v ∘ e, fun v => v ∘ e.symm,\n      fun _ => by simp [Function.comp_def],\n      fun _ => by simp [Function.comp_def]⟩\n  · intro x\n    rw [Formula.Realize, iff_iff_eq]\n    congr\n    funext i\n    exact i.elim0\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_iExs","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\nα : Type u'\nγ : Type u_3\ninst✝ : Finite γ\nφ : L.Formula (Sum α γ)\nv : α → M\nv' : Fin 0 → M\n⊢ Iff (FirstOrder.Language.BoundedFormula.Realize (FirstOrder.Language.Formula.iExs γ φ) v v') (Exists fun i => φ.Realize (Sum.elim v i))","decl":"@[simp]\ntheorem realize_iExs [Finite γ] {φ : L.Formula (α ⊕ γ)} {v : α → M} {v' : Fin 0 → M} :\n    BoundedFormula.Realize (φ.iExs γ) v v' ↔\n      ∃ (i : γ → M), φ.Realize (Sum.elim v i) := by\n  rw [← Formula.realize_iExs, iff_iff_eq]; congr; simp [eq_iff_true_of_subsingleton]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_toFormula","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nα : Type u'\nn : Nat\nφ : L.BoundedFormula α n\nv : Sum α (Fin n) → M\n⊢ Iff (φ.toFormula.Realize v) (φ.Realize (Function.comp v Sum.inl) (Function.comp v Sum.inr))","decl":"@[simp]\ntheorem realize_toFormula (φ : L.BoundedFormula α n) (v : α ⊕ (Fin n) → M) :\n    φ.toFormula.Realize v ↔ φ.Realize (v ∘ Sum.inl) (v ∘ Sum.inr) := by\n  induction φ with\n  | falsum => rfl\n  | equal => simp [BoundedFormula.Realize]\n  | rel => simp [BoundedFormula.Realize]\n  | imp _ _ ih1 ih2 =>\n    rw [toFormula, Formula.Realize, realize_imp, ← Formula.Realize, ih1, ← Formula.Realize, ih2,\n      realize_imp]\n  | all _ ih3 =>\n    rw [toFormula, Formula.Realize, realize_all, realize_all]\n    refine forall_congr' fun a => ?_\n    have h := ih3 (Sum.elim (v ∘ Sum.inl) (snoc (v ∘ Sum.inr) a))\n    simp only [Sum.elim_comp_inl, Sum.elim_comp_inr] at h\n    rw [← h, realize_relabel, Formula.Realize, iff_iff_eq]\n    simp only [Function.comp_def]\n    congr with x\n    · cases' x with _ x\n      · simp\n      · refine Fin.lastCases ?_ ?_ x\n        · rw [Sum.elim_inr, Sum.elim_inr,\n            finSumFinEquiv_symm_last, Sum.map_inr, Sum.elim_inr]\n          simp [Fin.snoc]\n        · simp only [castSucc, Function.comp_apply, Sum.elim_inr,\n            finSumFinEquiv_symm_apply_castAdd, Sum.map_inl, Sum.elim_inl]\n          rw [← castSucc]\n          simp\n    · exact Fin.elim0 x\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_iSup","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\nα : Type u'\nβ : Type v'\nn : Nat\ninst✝ : Finite β\nf : β → L.BoundedFormula α n\nv : α → M\nv' : Fin n → M\n⊢ Iff ((FirstOrder.Language.BoundedFormula.iSup f).Realize v v') (Exists fun b => (f b).Realize v v')","decl":"@[simp]\ntheorem realize_iSup [Finite β] (f : β → L.BoundedFormula α n)\n    (v : α → M) (v' : Fin n → M) :\n    (iSup f).Realize v v' ↔ ∃ b, (f b).Realize v v' := by\n  simp only [iSup, realize_foldr_sup, List.mem_map, Finset.mem_toList, Finset.mem_univ, true_and,\n    exists_exists_eq_and]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_iInf","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\nα : Type u'\nβ : Type v'\nn : Nat\ninst✝ : Finite β\nf : β → L.BoundedFormula α n\nv : α → M\nv' : Fin n → M\n⊢ Iff ((FirstOrder.Language.BoundedFormula.iInf f).Realize v v') (∀ (b : β), (f b).Realize v v')","decl":"@[simp]\ntheorem realize_iInf [Finite β] (f : β → L.BoundedFormula α n)\n    (v : α → M) (v' : Fin n → M) :\n    (iInf f).Realize v v' ↔ ∀ b, (f b).Realize v v' := by\n  simp only [iInf, realize_foldr_inf, List.mem_map, Finset.mem_toList, Finset.mem_univ, true_and,\n    forall_exists_index, forall_apply_eq_imp_iff]\n\n"}
{"name":"FirstOrder.Language.StrongHomClass.realize_boundedFormula","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝³ : L.Structure M\ninst✝² : L.Structure N\nα : Type u'\nn : Nat\nF : Type u_4\ninst✝¹ : EquivLike F M N\ninst✝ : L.StrongHomClass F M N\ng : F\nφ : L.BoundedFormula α n\nv : α → M\nxs : Fin n → M\n⊢ Iff (φ.Realize (Function.comp (⇑g) v) (Function.comp (⇑g) xs)) (φ.Realize v xs)","decl":"@[simp]\ntheorem realize_boundedFormula (φ : L.BoundedFormula α n) {v : α → M}\n    {xs : Fin n → M} : φ.Realize (g ∘ v) (g ∘ xs) ↔ φ.Realize v xs := by\n  induction φ with\n  | falsum => rfl\n  | equal =>\n    simp only [BoundedFormula.Realize, ← Sum.comp_elim, HomClass.realize_term,\n      EmbeddingLike.apply_eq_iff_eq g]\n  | rel =>\n    simp only [BoundedFormula.Realize, ← Sum.comp_elim, HomClass.realize_term]\n    exact StrongHomClass.map_rel g _ _\n  | imp _ _ ih1 ih2 => rw [BoundedFormula.Realize, ih1, ih2, BoundedFormula.Realize]\n  | all _ ih3 =>\n    rw [BoundedFormula.Realize, BoundedFormula.Realize]\n    constructor\n    · intro h a\n      have h' := h (g a)\n      rw [← Fin.comp_snoc, ih3] at h'\n      exact h'\n    · intro h a\n      have h' := h (EquivLike.inv g a)\n      rw [← ih3, Fin.comp_snoc, EquivLike.apply_inv_apply g] at h'\n      exact h'\n\n"}
{"name":"FirstOrder.Language.StrongHomClass.realize_formula","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝³ : L.Structure M\ninst✝² : L.Structure N\nα : Type u'\nF : Type u_4\ninst✝¹ : EquivLike F M N\ninst✝ : L.StrongHomClass F M N\ng : F\nφ : L.Formula α\nv : α → M\n⊢ Iff (φ.Realize (Function.comp (⇑g) v)) (φ.Realize v)","decl":"@[simp]\ntheorem realize_formula (φ : L.Formula α) {v : α → M} :\n    φ.Realize (g ∘ v) ↔ φ.Realize v := by\n  rw [Formula.Realize, Formula.Realize, ← realize_boundedFormula g φ, iff_eq_eq,\n    Unique.eq_default (g ∘ default)]\n\n"}
{"name":"FirstOrder.Language.StrongHomClass.realize_sentence","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝³ : L.Structure M\ninst✝² : L.Structure N\nF : Type u_4\ninst✝¹ : EquivLike F M N\ninst✝ : L.StrongHomClass F M N\ng : F\nφ : L.Sentence\n⊢ Iff (FirstOrder.Language.Sentence.Realize M φ) (FirstOrder.Language.Sentence.Realize N φ)","decl":"theorem realize_sentence (φ : L.Sentence) : M ⊨ φ ↔ N ⊨ φ := by\n  rw [Sentence.Realize, Sentence.Realize, ← realize_formula g,\n    Unique.eq_default (g ∘ default)]\n\n"}
{"name":"FirstOrder.Language.StrongHomClass.theory_model","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝⁴ : L.Structure M\ninst✝³ : L.Structure N\nT : L.Theory\nF : Type u_4\ninst✝² : EquivLike F M N\ninst✝¹ : L.StrongHomClass F M N\ng : F\ninst✝ : FirstOrder.Language.Theory.Model M T\n⊢ FirstOrder.Language.Theory.Model N T","decl":"theorem theory_model [M ⊨ T] : N ⊨ T :=\n  ⟨fun φ hφ => (realize_sentence g φ).1 (Theory.realize_sentence_of_mem T hφ)⟩\n\n"}
{"name":"FirstOrder.Language.StrongHomClass.elementarilyEquivalent","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝³ : L.Structure M\ninst✝² : L.Structure N\nF : Type u_4\ninst✝¹ : EquivLike F M N\ninst✝ : L.StrongHomClass F M N\ng : F\n⊢ L.ElementarilyEquivalent M N","decl":"theorem elementarilyEquivalent : M ≅[L] N :=\n  elementarilyEquivalent_iff.2 (realize_sentence g)\n\n"}
{"name":"FirstOrder.Language.Relations.realize_reflexive","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nr : L.Relations 2\n⊢ Iff (FirstOrder.Language.Sentence.Realize M r.reflexive) (Reflexive fun x y => FirstOrder.Language.Structure.RelMap r (Matrix.vecCons x (Matrix.vecCons y Matrix.vecEmpty)))","decl":"@[simp]\ntheorem realize_reflexive : M ⊨ r.reflexive ↔ Reflexive fun x y : M => RelMap r ![x, y] :=\n  forall_congr' fun _ => realize_rel₂\n\n"}
{"name":"FirstOrder.Language.Relations.realize_irreflexive","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nr : L.Relations 2\n⊢ Iff (FirstOrder.Language.Sentence.Realize M r.irreflexive) (Irreflexive fun x y => FirstOrder.Language.Structure.RelMap r (Matrix.vecCons x (Matrix.vecCons y Matrix.vecEmpty)))","decl":"@[simp]\ntheorem realize_irreflexive : M ⊨ r.irreflexive ↔ Irreflexive fun x y : M => RelMap r ![x, y] :=\n  forall_congr' fun _ => not_congr realize_rel₂\n\n"}
{"name":"FirstOrder.Language.Relations.realize_symmetric","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nr : L.Relations 2\n⊢ Iff (FirstOrder.Language.Sentence.Realize M r.symmetric) (Symmetric fun x y => FirstOrder.Language.Structure.RelMap r (Matrix.vecCons x (Matrix.vecCons y Matrix.vecEmpty)))","decl":"@[simp]\ntheorem realize_symmetric : M ⊨ r.symmetric ↔ Symmetric fun x y : M => RelMap r ![x, y] :=\n  forall_congr' fun _ => forall_congr' fun _ => imp_congr realize_rel₂ realize_rel₂\n\n"}
{"name":"FirstOrder.Language.Relations.realize_antisymmetric","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nr : L.Relations 2\n⊢ Iff (FirstOrder.Language.Sentence.Realize M r.antisymmetric) (AntiSymmetric fun x y => FirstOrder.Language.Structure.RelMap r (Matrix.vecCons x (Matrix.vecCons y Matrix.vecEmpty)))","decl":"@[simp]\ntheorem realize_antisymmetric :\n    M ⊨ r.antisymmetric ↔ AntiSymmetric fun x y : M => RelMap r ![x, y] :=\n  forall_congr' fun _ =>\n    forall_congr' fun _ => imp_congr realize_rel₂ (imp_congr realize_rel₂ Iff.rfl)\n\n"}
{"name":"FirstOrder.Language.Relations.realize_transitive","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nr : L.Relations 2\n⊢ Iff (FirstOrder.Language.Sentence.Realize M r.transitive) (Transitive fun x y => FirstOrder.Language.Structure.RelMap r (Matrix.vecCons x (Matrix.vecCons y Matrix.vecEmpty)))","decl":"@[simp]\ntheorem realize_transitive : M ⊨ r.transitive ↔ Transitive fun x y : M => RelMap r ![x, y] :=\n  forall_congr' fun _ =>\n    forall_congr' fun _ =>\n      forall_congr' fun _ => imp_congr realize_rel₂ (imp_congr realize_rel₂ realize_rel₂)\n\n"}
{"name":"FirstOrder.Language.Relations.realize_total","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nr : L.Relations 2\n⊢ Iff (FirstOrder.Language.Sentence.Realize M r.total) (Total fun x y => FirstOrder.Language.Structure.RelMap r (Matrix.vecCons x (Matrix.vecCons y Matrix.vecEmpty)))","decl":"@[simp]\ntheorem realize_total : M ⊨ r.total ↔ Total fun x y : M => RelMap r ![x, y] :=\n  forall_congr' fun _ =>\n    forall_congr' fun _ => realize_sup.trans (or_congr realize_rel₂ realize_rel₂)\n\n"}
{"name":"FirstOrder.Language.Sentence.realize_cardGe","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nn : Nat\n⊢ Iff (FirstOrder.Language.Sentence.Realize M (FirstOrder.Language.Sentence.cardGe L n)) (LE.le (↑n) (Cardinal.mk M))","decl":"@[simp]\ntheorem Sentence.realize_cardGe (n) : M ⊨ Sentence.cardGe L n ↔ ↑n ≤ #M := by\n  rw [← lift_mk_fin, ← lift_le.{0}, lift_lift, lift_mk_le, Sentence.cardGe, Sentence.Realize,\n    BoundedFormula.realize_exs]\n  simp_rw [BoundedFormula.realize_foldr_inf]\n  simp only [Function.comp_apply, List.mem_map, Prod.exists, Ne, List.mem_product,\n    List.mem_finRange, forall_exists_index, and_imp, List.mem_filter, true_and]\n  refine ⟨?_, fun xs => ⟨xs.some, ?_⟩⟩\n  · rintro ⟨xs, h⟩\n    refine ⟨⟨xs, fun i j ij => ?_⟩⟩\n    contrapose! ij\n    have hij := h _ i j (by simpa using ij) rfl\n    simp only [BoundedFormula.realize_not, Term.realize, BoundedFormula.realize_bdEqual,\n      Sum.elim_inr] at hij\n    exact hij\n  · rintro _ i j ij rfl\n    simpa using ij\n\n"}
{"name":"FirstOrder.Language.model_infiniteTheory_iff","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\n⊢ Iff (FirstOrder.Language.Theory.Model M L.infiniteTheory) (Infinite M)","decl":"@[simp]\ntheorem model_infiniteTheory_iff : M ⊨ L.infiniteTheory ↔ Infinite M := by\n  simp [infiniteTheory, infinite_iff, aleph0_le]\n\n"}
{"name":"FirstOrder.Language.model_infiniteTheory","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nh : Infinite M\n⊢ FirstOrder.Language.Theory.Model M L.infiniteTheory","decl":"instance model_infiniteTheory [h : Infinite M] : M ⊨ L.infiniteTheory :=\n  L.model_infiniteTheory_iff.2 h\n\n"}
{"name":"FirstOrder.Language.model_nonemptyTheory_iff","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\n⊢ Iff (FirstOrder.Language.Theory.Model M L.nonemptyTheory) (Nonempty M)","decl":"@[simp]\ntheorem model_nonemptyTheory_iff : M ⊨ L.nonemptyTheory ↔ Nonempty M := by\n  simp only [nonemptyTheory, Theory.model_iff, Set.mem_singleton_iff, forall_eq,\n    Sentence.realize_cardGe, Nat.cast_one, one_le_iff_ne_zero, mk_ne_zero_iff]\n\n"}
{"name":"FirstOrder.Language.model_nonempty","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nh : Nonempty M\n⊢ FirstOrder.Language.Theory.Model M L.nonemptyTheory","decl":"instance model_nonempty [h : Nonempty M] : M ⊨ L.nonemptyTheory :=\n  L.model_nonemptyTheory_iff.2 h\n\n"}
{"name":"FirstOrder.Language.model_distinctConstantsTheory","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nα : Type u'\nM : Type w\ninst✝ : (L.withConstants α).Structure M\ns : Set α\n⊢ Iff (FirstOrder.Language.Theory.Model M (L.distinctConstantsTheory s)) (Set.InjOn (fun i => ↑(L.con i)) s)","decl":"theorem model_distinctConstantsTheory {M : Type w} [L[[α]].Structure M] (s : Set α) :\n    M ⊨ L.distinctConstantsTheory s ↔ Set.InjOn (fun i : α => (L.con i : M)) s := by\n  simp only [distinctConstantsTheory, Theory.model_iff, Set.mem_image, Set.mem_inter,\n    Set.mem_prod, Set.mem_compl, Prod.exists, forall_exists_index, and_imp]\n  refine ⟨fun h a as b bs ab => ?_, ?_⟩\n  · contrapose! ab\n    have h' := h _ a b ⟨⟨as, bs⟩, ab⟩ rfl\n    simp only [Sentence.Realize, Formula.realize_not, Formula.realize_equal,\n      Term.realize_constants] at h'\n    exact h'\n  · rintro h φ a b ⟨⟨as, bs⟩, ab⟩ rfl\n    simp only [Sentence.Realize, Formula.realize_not, Formula.realize_equal, Term.realize_constants]\n    exact fun contra => ab (h as bs contra)\n\n"}
{"name":"FirstOrder.Language.card_le_of_model_distinctConstantsTheory","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nα : Type u'\ns : Set α\nM : Type w\ninst✝ : (L.withConstants α).Structure M\nh : FirstOrder.Language.Theory.Model M (L.distinctConstantsTheory s)\n⊢ LE.le (Cardinal.lift.{w, u'} (Cardinal.mk ↑s)) (Cardinal.lift.{u', w} (Cardinal.mk M))","decl":"theorem card_le_of_model_distinctConstantsTheory (s : Set α) (M : Type w) [L[[α]].Structure M]\n    [h : M ⊨ L.distinctConstantsTheory s] : Cardinal.lift.{w} #s ≤ Cardinal.lift.{u'} #M :=\n  lift_mk_le'.2 ⟨⟨_, Set.injOn_iff_injective.1 ((L.model_distinctConstantsTheory s).1 h)⟩⟩\n\n"}
{"name":"FirstOrder.Language.ElementarilyEquivalent.symm","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nh : L.ElementarilyEquivalent M N\n⊢ L.ElementarilyEquivalent N M","decl":"@[symm]\nnonrec theorem symm (h : M ≅[L] N) : N ≅[L] M :=\n  h.symm\n\n"}
{"name":"FirstOrder.Language.ElementarilyEquivalent.trans","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\nP : Type u_2\ninst✝² : L.Structure M\ninst✝¹ : L.Structure N\ninst✝ : L.Structure P\nMN : L.ElementarilyEquivalent M N\nNP : L.ElementarilyEquivalent N P\n⊢ L.ElementarilyEquivalent M P","decl":"@[trans]\nnonrec theorem trans (MN : M ≅[L] N) (NP : N ≅[L] P) : M ≅[L] P :=\n  MN.trans NP\n\n"}
{"name":"FirstOrder.Language.ElementarilyEquivalent.completeTheory_eq","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nh : L.ElementarilyEquivalent M N\n⊢ Eq (L.completeTheory M) (L.completeTheory N)","decl":"theorem completeTheory_eq (h : M ≅[L] N) : L.completeTheory M = L.completeTheory N :=\n  h\n\n"}
{"name":"FirstOrder.Language.ElementarilyEquivalent.realize_sentence","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nh : L.ElementarilyEquivalent M N\nφ : L.Sentence\n⊢ Iff (FirstOrder.Language.Sentence.Realize M φ) (FirstOrder.Language.Sentence.Realize N φ)","decl":"theorem realize_sentence (h : M ≅[L] N) (φ : L.Sentence) : M ⊨ φ ↔ N ⊨ φ :=\n  (elementarilyEquivalent_iff.1 h) φ\n\n"}
{"name":"FirstOrder.Language.ElementarilyEquivalent.theory_model_iff","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nT : L.Theory\nh : L.ElementarilyEquivalent M N\n⊢ Iff (FirstOrder.Language.Theory.Model M T) (FirstOrder.Language.Theory.Model N T)","decl":"theorem theory_model_iff (h : M ≅[L] N) : M ⊨ T ↔ N ⊨ T := by\n  rw [Theory.model_iff_subset_completeTheory, Theory.model_iff_subset_completeTheory,\n    h.completeTheory_eq]\n\n"}
{"name":"FirstOrder.Language.ElementarilyEquivalent.theory_model","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nT : L.Theory\nMT : FirstOrder.Language.Theory.Model M T\nh : L.ElementarilyEquivalent M N\n⊢ FirstOrder.Language.Theory.Model N T","decl":"theorem theory_model [MT : M ⊨ T] (h : M ≅[L] N) : N ⊨ T :=\n  h.theory_model_iff.1 MT\n\n"}
{"name":"FirstOrder.Language.ElementarilyEquivalent.nonempty_iff","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nh : L.ElementarilyEquivalent M N\n⊢ Iff (Nonempty M) (Nonempty N)","decl":"theorem nonempty_iff (h : M ≅[L] N) : Nonempty M ↔ Nonempty N :=\n  (model_nonemptyTheory_iff L).symm.trans (h.theory_model_iff.trans (model_nonemptyTheory_iff L))\n\n"}
{"name":"FirstOrder.Language.ElementarilyEquivalent.nonempty","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nMn : Nonempty M\nh : L.ElementarilyEquivalent M N\n⊢ Nonempty N","decl":"theorem nonempty [Mn : Nonempty M] (h : M ≅[L] N) : Nonempty N :=\n  h.nonempty_iff.1 Mn\n\n"}
{"name":"FirstOrder.Language.ElementarilyEquivalent.infinite_iff","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nh : L.ElementarilyEquivalent M N\n⊢ Iff (Infinite M) (Infinite N)","decl":"theorem infinite_iff (h : M ≅[L] N) : Infinite M ↔ Infinite N :=\n  (model_infiniteTheory_iff L).symm.trans (h.theory_model_iff.trans (model_infiniteTheory_iff L))\n\n"}
{"name":"FirstOrder.Language.ElementarilyEquivalent.infinite","module":"Mathlib.ModelTheory.Semantics","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nMi : Infinite M\nh : L.ElementarilyEquivalent M N\n⊢ Infinite N","decl":"theorem infinite [Mi : Infinite M] (h : M ≅[L] N) : Infinite N :=\n  h.infinite_iff.1 Mi\n\n"}
