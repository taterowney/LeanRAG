{"name":"ConvexCone.mk.sizeOf_spec","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : OrderedSemiring ğ•œ\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : SMul ğ•œ E\ninstâœÂ¹ : SizeOf ğ•œ\ninstâœ : SizeOf E\ncarrier : Set E\nsmul_mem' : âˆ€ â¦ƒc : ğ•œâ¦„, LT.lt 0 c â†’ âˆ€ â¦ƒx : Eâ¦„, Membership.mem carrier x â†’ Membership.mem carrier (HSMul.hSMul c x)\nadd_mem' : âˆ€ â¦ƒx : Eâ¦„, Membership.mem carrier x â†’ âˆ€ â¦ƒy : Eâ¦„, Membership.mem carrier y â†’ Membership.mem carrier (HAdd.hAdd x y)\nâŠ¢ Eq (SizeOf.sizeOf { carrier := carrier, smul_mem' := smul_mem', add_mem' := add_mem' }) 1","decl":"/-- A convex cone is a subset `s` of a `ğ•œ`-module such that `a â€¢ x + b â€¢ y âˆˆ s` whenever `a, b > 0`\nand `x, y âˆˆ s`. -/\nstructure ConvexCone [AddCommMonoid E] [SMul ğ•œ E] where\n  /-- The **carrier set** underlying this cone: the set of points contained in it -/\n  carrier : Set E\n  smul_mem' : âˆ€ â¦ƒc : ğ•œâ¦„, 0 < c â†’ âˆ€ â¦ƒx : Eâ¦„, x âˆˆ carrier â†’ c â€¢ x âˆˆ carrier\n  add_mem' : âˆ€ â¦ƒxâ¦„ (_ : x âˆˆ carrier) â¦ƒyâ¦„ (_ : y âˆˆ carrier), x + y âˆˆ carrier\n\n"}
{"name":"ConvexCone.add_mem'","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nself : ConvexCone ğ•œ E\nx : E\nxâœÂ¹ : Membership.mem self.carrier x\ny : E\nxâœ : Membership.mem self.carrier y\nâŠ¢ Membership.mem self.carrier (HAdd.hAdd x y)","decl":"/-- A convex cone is a subset `s` of a `ğ•œ`-module such that `a â€¢ x + b â€¢ y âˆˆ s` whenever `a, b > 0`\nand `x, y âˆˆ s`. -/\nstructure ConvexCone [AddCommMonoid E] [SMul ğ•œ E] where\n  /-- The **carrier set** underlying this cone: the set of points contained in it -/\n  carrier : Set E\n  smul_mem' : âˆ€ â¦ƒc : ğ•œâ¦„, 0 < c â†’ âˆ€ â¦ƒx : Eâ¦„, x âˆˆ carrier â†’ c â€¢ x âˆˆ carrier\n  add_mem' : âˆ€ â¦ƒxâ¦„ (_ : x âˆˆ carrier) â¦ƒyâ¦„ (_ : y âˆˆ carrier), x + y âˆˆ carrier\n\n"}
{"name":"ConvexCone.mk.inj","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\ncarrierâœ : Set E\nsmul_mem'âœ : âˆ€ â¦ƒc : ğ•œâ¦„, LT.lt 0 c â†’ âˆ€ â¦ƒx : Eâ¦„, Membership.mem carrierâœ x â†’ Membership.mem carrierâœ (HSMul.hSMul c x)\nadd_mem'âœ : âˆ€ â¦ƒx : Eâ¦„, Membership.mem carrierâœ x â†’ âˆ€ â¦ƒy : Eâ¦„, Membership.mem carrierâœ y â†’ Membership.mem carrierâœ (HAdd.hAdd x y)\ncarrier : Set E\nsmul_mem' : âˆ€ â¦ƒc : ğ•œâ¦„, LT.lt 0 c â†’ âˆ€ â¦ƒx : Eâ¦„, Membership.mem carrier x â†’ Membership.mem carrier (HSMul.hSMul c x)\nadd_mem' : âˆ€ â¦ƒx : Eâ¦„, Membership.mem carrier x â†’ âˆ€ â¦ƒy : Eâ¦„, Membership.mem carrier y â†’ Membership.mem carrier (HAdd.hAdd x y)\nxâœ : Eq { carrier := carrierâœ, smul_mem' := smul_mem'âœ, add_mem' := add_mem'âœ } { carrier := carrier, smul_mem' := smul_mem', add_mem' := add_mem' }\nâŠ¢ Eq carrierâœ carrier","decl":"/-- A convex cone is a subset `s` of a `ğ•œ`-module such that `a â€¢ x + b â€¢ y âˆˆ s` whenever `a, b > 0`\nand `x, y âˆˆ s`. -/\nstructure ConvexCone [AddCommMonoid E] [SMul ğ•œ E] where\n  /-- The **carrier set** underlying this cone: the set of points contained in it -/\n  carrier : Set E\n  smul_mem' : âˆ€ â¦ƒc : ğ•œâ¦„, 0 < c â†’ âˆ€ â¦ƒx : Eâ¦„, x âˆˆ carrier â†’ c â€¢ x âˆˆ carrier\n  add_mem' : âˆ€ â¦ƒxâ¦„ (_ : x âˆˆ carrier) â¦ƒyâ¦„ (_ : y âˆˆ carrier), x + y âˆˆ carrier\n\n"}
{"name":"ConvexCone.smul_mem'","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nself : ConvexCone ğ•œ E\nc : ğ•œ\naâœÂ¹ : LT.lt 0 c\nx : E\naâœ : Membership.mem self.carrier x\nâŠ¢ Membership.mem self.carrier (HSMul.hSMul c x)","decl":"/-- A convex cone is a subset `s` of a `ğ•œ`-module such that `a â€¢ x + b â€¢ y âˆˆ s` whenever `a, b > 0`\nand `x, y âˆˆ s`. -/\nstructure ConvexCone [AddCommMonoid E] [SMul ğ•œ E] where\n  /-- The **carrier set** underlying this cone: the set of points contained in it -/\n  carrier : Set E\n  smul_mem' : âˆ€ â¦ƒc : ğ•œâ¦„, 0 < c â†’ âˆ€ â¦ƒx : Eâ¦„, x âˆˆ carrier â†’ c â€¢ x âˆˆ carrier\n  add_mem' : âˆ€ â¦ƒxâ¦„ (_ : x âˆˆ carrier) â¦ƒyâ¦„ (_ : y âˆˆ carrier), x + y âˆˆ carrier\n\n"}
{"name":"ConvexCone.mk.injEq","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\ncarrierâœ : Set E\nsmul_mem'âœ : âˆ€ â¦ƒc : ğ•œâ¦„, LT.lt 0 c â†’ âˆ€ â¦ƒx : Eâ¦„, Membership.mem carrierâœ x â†’ Membership.mem carrierâœ (HSMul.hSMul c x)\nadd_mem'âœ : âˆ€ â¦ƒx : Eâ¦„, Membership.mem carrierâœ x â†’ âˆ€ â¦ƒy : Eâ¦„, Membership.mem carrierâœ y â†’ Membership.mem carrierâœ (HAdd.hAdd x y)\ncarrier : Set E\nsmul_mem' : âˆ€ â¦ƒc : ğ•œâ¦„, LT.lt 0 c â†’ âˆ€ â¦ƒx : Eâ¦„, Membership.mem carrier x â†’ Membership.mem carrier (HSMul.hSMul c x)\nadd_mem' : âˆ€ â¦ƒx : Eâ¦„, Membership.mem carrier x â†’ âˆ€ â¦ƒy : Eâ¦„, Membership.mem carrier y â†’ Membership.mem carrier (HAdd.hAdd x y)\nâŠ¢ Eq (Eq { carrier := carrierâœ, smul_mem' := smul_mem'âœ, add_mem' := add_mem'âœ } { carrier := carrier, smul_mem' := smul_mem', add_mem' := add_mem' }) (Eq carrierâœ carrier)","decl":"/-- A convex cone is a subset `s` of a `ğ•œ`-module such that `a â€¢ x + b â€¢ y âˆˆ s` whenever `a, b > 0`\nand `x, y âˆˆ s`. -/\nstructure ConvexCone [AddCommMonoid E] [SMul ğ•œ E] where\n  /-- The **carrier set** underlying this cone: the set of points contained in it -/\n  carrier : Set E\n  smul_mem' : âˆ€ â¦ƒc : ğ•œâ¦„, 0 < c â†’ âˆ€ â¦ƒx : Eâ¦„, x âˆˆ carrier â†’ c â€¢ x âˆˆ carrier\n  add_mem' : âˆ€ â¦ƒxâ¦„ (_ : x âˆˆ carrier) â¦ƒyâ¦„ (_ : y âˆˆ carrier), x + y âˆˆ carrier\n\n"}
{"name":"ConvexCone.coe_mk","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\ns : Set E\nhâ‚ : âˆ€ â¦ƒc : ğ•œâ¦„, LT.lt 0 c â†’ âˆ€ â¦ƒx : Eâ¦„, Membership.mem s x â†’ Membership.mem s (HSMul.hSMul c x)\nhâ‚‚ : âˆ€ â¦ƒx : Eâ¦„, Membership.mem s x â†’ âˆ€ â¦ƒy : Eâ¦„, Membership.mem s y â†’ Membership.mem s (HAdd.hAdd x y)\nâŠ¢ Eq (â†‘{ carrier := s, smul_mem' := hâ‚, add_mem' := hâ‚‚ }) s","decl":"@[simp]\ntheorem coe_mk {s : Set E} {hâ‚ hâ‚‚} : â†‘(@mk ğ•œ _ _ _ _ s hâ‚ hâ‚‚) = s :=\n  rfl\n\n"}
{"name":"ConvexCone.mem_mk","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\ns : Set E\nhâ‚ : âˆ€ â¦ƒc : ğ•œâ¦„, LT.lt 0 c â†’ âˆ€ â¦ƒx : Eâ¦„, Membership.mem s x â†’ Membership.mem s (HSMul.hSMul c x)\nhâ‚‚ : âˆ€ â¦ƒx : Eâ¦„, Membership.mem s x â†’ âˆ€ â¦ƒy : Eâ¦„, Membership.mem s y â†’ Membership.mem s (HAdd.hAdd x y)\nx : E\nâŠ¢ Iff (Membership.mem { carrier := s, smul_mem' := hâ‚, add_mem' := hâ‚‚ } x) (Membership.mem s x)","decl":"@[simp]\ntheorem mem_mk {s : Set E} {hâ‚ hâ‚‚ x} : x âˆˆ @mk ğ•œ _ _ _ _ s hâ‚ hâ‚‚ â†” x âˆˆ s :=\n  Iff.rfl\n\n"}
{"name":"ConvexCone.ext","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nS T : ConvexCone ğ•œ E\nh : âˆ€ (x : E), Iff (Membership.mem S x) (Membership.mem T x)\nâŠ¢ Eq S T","decl":"/-- Two `ConvexCone`s are equal if they have the same elements. -/\n@[ext]\ntheorem ext {S T : ConvexCone ğ•œ E} (h : âˆ€ x, x âˆˆ S â†” x âˆˆ T) : S = T :=\n  SetLike.ext h\n\n"}
{"name":"ConvexCone.ext_iff","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nS T : ConvexCone ğ•œ E\nâŠ¢ Iff (Eq S T) (âˆ€ (x : E), Iff (Membership.mem S x) (Membership.mem T x))","decl":"/-- Two `ConvexCone`s are equal if they have the same elements. -/\n@[ext]\ntheorem ext {S T : ConvexCone ğ•œ E} (h : âˆ€ x, x âˆˆ S â†” x âˆˆ T) : S = T :=\n  SetLike.ext h\n\n"}
{"name":"ConvexCone.smul_mem","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nS : ConvexCone ğ•œ E\nc : ğ•œ\nx : E\nhc : LT.lt 0 c\nhx : Membership.mem S x\nâŠ¢ Membership.mem S (HSMul.hSMul c x)","decl":"@[aesop safe apply (rule_sets := [SetLike])]\ntheorem smul_mem {c : ğ•œ} {x : E} (hc : 0 < c) (hx : x âˆˆ S) : c â€¢ x âˆˆ S :=\n  S.smul_mem' hc hx\n\n"}
{"name":"ConvexCone.add_mem","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nS : ConvexCone ğ•œ E\nx : E\nhx : Membership.mem S x\ny : E\nhy : Membership.mem S y\nâŠ¢ Membership.mem S (HAdd.hAdd x y)","decl":"theorem add_mem â¦ƒxâ¦„ (hx : x âˆˆ S) â¦ƒyâ¦„ (hy : y âˆˆ S) : x + y âˆˆ S :=\n  S.add_mem' hx hy\n\n"}
{"name":"ConvexCone.instAddMemClass","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nâŠ¢ AddMemClass (ConvexCone ğ•œ E) E","decl":"instance : AddMemClass (ConvexCone ğ•œ E) E where add_mem ha hb := add_mem _ ha hb\n\n"}
{"name":"ConvexCone.coe_inf","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nS T : ConvexCone ğ•œ E\nâŠ¢ Eq (â†‘(Min.min S T)) (Inter.inter â†‘S â†‘T)","decl":"@[simp]\ntheorem coe_inf : ((S âŠ“ T : ConvexCone ğ•œ E) : Set E) = â†‘S âˆ© â†‘T :=\n  rfl\n\n"}
{"name":"ConvexCone.mem_inf","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nS T : ConvexCone ğ•œ E\nx : E\nâŠ¢ Iff (Membership.mem (Min.min S T) x) (And (Membership.mem S x) (Membership.mem T x))","decl":"theorem mem_inf {x} : x âˆˆ S âŠ“ T â†” x âˆˆ S âˆ§ x âˆˆ T :=\n  Iff.rfl\n\n"}
{"name":"ConvexCone.coe_sInf","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nS : Set (ConvexCone ğ•œ E)\nâŠ¢ Eq (â†‘(InfSet.sInf S)) (Set.iInter fun s => Set.iInter fun h => â†‘s)","decl":"@[simp]\ntheorem coe_sInf (S : Set (ConvexCone ğ•œ E)) : â†‘(sInf S) = â‹‚ s âˆˆ S, (s : Set E) :=\n  rfl\n\n"}
{"name":"ConvexCone.mem_sInf","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nx : E\nS : Set (ConvexCone ğ•œ E)\nâŠ¢ Iff (Membership.mem (InfSet.sInf S) x) (âˆ€ (s : ConvexCone ğ•œ E), Membership.mem S s â†’ Membership.mem s x)","decl":"theorem mem_sInf {x : E} {S : Set (ConvexCone ğ•œ E)} : x âˆˆ sInf S â†” âˆ€ s âˆˆ S, x âˆˆ s :=\n  mem_iInterâ‚‚\n\n"}
{"name":"ConvexCone.coe_iInf","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nÎ¹ : Sort u_5\nf : Î¹ â†’ ConvexCone ğ•œ E\nâŠ¢ Eq (â†‘(iInf f)) (Set.iInter fun i => â†‘(f i))","decl":"@[simp]\ntheorem coe_iInf {Î¹ : Sort*} (f : Î¹ â†’ ConvexCone ğ•œ E) : â†‘(iInf f) = â‹‚ i, (f i : Set E) := by\n  simp [iInf]\n\n"}
{"name":"ConvexCone.mem_iInf","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nÎ¹ : Sort u_5\nx : E\nf : Î¹ â†’ ConvexCone ğ•œ E\nâŠ¢ Iff (Membership.mem (iInf f) x) (âˆ€ (i : Î¹), Membership.mem (f i) x)","decl":"theorem mem_iInf {Î¹ : Sort*} {x : E} {f : Î¹ â†’ ConvexCone ğ•œ E} : x âˆˆ iInf f â†” âˆ€ i, x âˆˆ f i :=\n  mem_iInterâ‚‚.trans <| by simp\n\n"}
{"name":"ConvexCone.mem_bot","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nx : E\nâŠ¢ Eq (Membership.mem Bot.bot x) False","decl":"theorem mem_bot (x : E) : (x âˆˆ (âŠ¥ : ConvexCone ğ•œ E)) = False :=\n  rfl\n\n"}
{"name":"ConvexCone.coe_bot","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nâŠ¢ Eq (â†‘Bot.bot) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem coe_bot : â†‘(âŠ¥ : ConvexCone ğ•œ E) = (âˆ… : Set E) :=\n  rfl\n\n"}
{"name":"ConvexCone.mem_top","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nx : E\nâŠ¢ Membership.mem Top.top x","decl":"theorem mem_top (x : E) : x âˆˆ (âŠ¤ : ConvexCone ğ•œ E) :=\n  mem_univ x\n\n"}
{"name":"ConvexCone.coe_top","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nâŠ¢ Eq (â†‘Top.top) Set.univ","decl":"@[simp]\ntheorem coe_top : â†‘(âŠ¤ : ConvexCone ğ•œ E) = (univ : Set E) :=\n  rfl\n\n"}
{"name":"ConvexCone.convex","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : Module ğ•œ E\nS : ConvexCone ğ•œ E\nâŠ¢ Convex ğ•œ â†‘S","decl":"protected theorem convex : Convex ğ•œ (S : Set E) :=\n  convex_iff_forall_pos.2 fun _ hx _ hy _ _ ha hb _ =>\n    S.add_mem (S.smul_mem ha hx) (S.smul_mem hb hy)\n\n"}
{"name":"ConvexCone.coe_map","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : OrderedSemiring ğ•œ\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : AddCommMonoid F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\nS : ConvexCone ğ•œ E\nf : LinearMap (RingHom.id ğ•œ) E F\nâŠ¢ Eq (â†‘(ConvexCone.map f S)) (Set.image â‡‘f â†‘S)","decl":"@[simp, norm_cast]\ntheorem coe_map (S : ConvexCone ğ•œ E) (f : E â†’â‚—[ğ•œ] F) : (S.map f : Set F) = f '' S :=\n  rfl\n\n"}
{"name":"ConvexCone.mem_map","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : OrderedSemiring ğ•œ\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : AddCommMonoid F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\nf : LinearMap (RingHom.id ğ•œ) E F\nS : ConvexCone ğ•œ E\ny : F\nâŠ¢ Iff (Membership.mem (ConvexCone.map f S) y) (Exists fun x => And (Membership.mem S x) (Eq (f x) y))","decl":"@[simp]\ntheorem mem_map {f : E â†’â‚—[ğ•œ] F} {S : ConvexCone ğ•œ E} {y : F} : y âˆˆ S.map f â†” âˆƒ x âˆˆ S, f x = y :=\n  Set.mem_image f S y\n\n"}
{"name":"ConvexCone.map_map","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : OrderedSemiring ğ•œ\ninstâœâµ : AddCommMonoid E\ninstâœâ´ : AddCommMonoid F\ninstâœÂ³ : AddCommMonoid G\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module ğ•œ F\ninstâœ : Module ğ•œ G\ng : LinearMap (RingHom.id ğ•œ) F G\nf : LinearMap (RingHom.id ğ•œ) E F\nS : ConvexCone ğ•œ E\nâŠ¢ Eq (ConvexCone.map g (ConvexCone.map f S)) (ConvexCone.map (g.comp f) S)","decl":"theorem map_map (g : F â†’â‚—[ğ•œ] G) (f : E â†’â‚—[ğ•œ] F) (S : ConvexCone ğ•œ E) :\n    (S.map f).map g = S.map (g.comp f) :=\n  SetLike.coe_injective <| image_image g f S\n\n"}
{"name":"ConvexCone.map_id","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : Module ğ•œ E\nS : ConvexCone ğ•œ E\nâŠ¢ Eq (ConvexCone.map LinearMap.id S) S","decl":"@[simp]\ntheorem map_id (S : ConvexCone ğ•œ E) : S.map LinearMap.id = S :=\n  SetLike.coe_injective <| image_id _\n\n"}
{"name":"ConvexCone.coe_comap","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : OrderedSemiring ğ•œ\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : AddCommMonoid F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\nf : LinearMap (RingHom.id ğ•œ) E F\nS : ConvexCone ğ•œ F\nâŠ¢ Eq (â†‘(ConvexCone.comap f S)) (Set.preimage â‡‘f â†‘S)","decl":"@[simp]\ntheorem coe_comap (f : E â†’â‚—[ğ•œ] F) (S : ConvexCone ğ•œ F) : (S.comap f : Set E) = f â»Â¹' S :=\n  rfl\n\n"}
{"name":"ConvexCone.comap_id","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : Module ğ•œ E\nS : ConvexCone ğ•œ E\nâŠ¢ Eq (ConvexCone.comap LinearMap.id S) S","decl":"@[simp] -- Porting note: was not a `dsimp` lemma\ntheorem comap_id (S : ConvexCone ğ•œ E) : S.comap LinearMap.id = S :=\n  rfl\n\n"}
{"name":"ConvexCone.comap_comap","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : OrderedSemiring ğ•œ\ninstâœâµ : AddCommMonoid E\ninstâœâ´ : AddCommMonoid F\ninstâœÂ³ : AddCommMonoid G\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module ğ•œ F\ninstâœ : Module ğ•œ G\ng : LinearMap (RingHom.id ğ•œ) F G\nf : LinearMap (RingHom.id ğ•œ) E F\nS : ConvexCone ğ•œ G\nâŠ¢ Eq (ConvexCone.comap f (ConvexCone.comap g S)) (ConvexCone.comap (g.comp f) S)","decl":"theorem comap_comap (g : F â†’â‚—[ğ•œ] G) (f : E â†’â‚—[ğ•œ] F) (S : ConvexCone ğ•œ G) :\n    (S.comap g).comap f = S.comap (g.comp f) :=\n  rfl\n\n"}
{"name":"ConvexCone.mem_comap","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : OrderedSemiring ğ•œ\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : AddCommMonoid F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\nf : LinearMap (RingHom.id ğ•œ) E F\nS : ConvexCone ğ•œ F\nx : E\nâŠ¢ Iff (Membership.mem (ConvexCone.comap f S) x) (Membership.mem S (f x))","decl":"@[simp]\ntheorem mem_comap {f : E â†’â‚—[ğ•œ] F} {S : ConvexCone ğ•œ F} {x : E} : x âˆˆ S.comap f â†” f x âˆˆ S :=\n  Iff.rfl\n\n"}
{"name":"ConvexCone.smul_mem_iff","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : MulAction ğ•œ E\nS : ConvexCone ğ•œ E\nc : ğ•œ\nhc : LT.lt 0 c\nx : E\nâŠ¢ Iff (Membership.mem S (HSMul.hSMul c x)) (Membership.mem S x)","decl":"theorem smul_mem_iff {c : ğ•œ} (hc : 0 < c) {x : E} : c â€¢ x âˆˆ S â†” x âˆˆ S :=\n  âŸ¨fun h => inv_smul_smulâ‚€ hc.ne' x â–¸ S.smul_mem (inv_pos.2 hc) h, S.smul_mem hcâŸ©\n\n"}
{"name":"ConvexCone.to_orderedSMul","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : OrderedAddCommGroup E\ninstâœ : Module ğ•œ E\nS : ConvexCone ğ•œ E\nh : âˆ€ (x y : E), Iff (LE.le x y) (Membership.mem S (HSub.hSub y x))\nâŠ¢ OrderedSMul ğ•œ E","decl":"/-- Constructs an ordered module given an `OrderedAddCommGroup`, a cone, and a proof that\nthe order relation is the one defined by the cone.\n-/\ntheorem to_orderedSMul (S : ConvexCone ğ•œ E) (h : âˆ€ x y : E, x â‰¤ y â†” y - x âˆˆ S) : OrderedSMul ğ•œ E :=\n  OrderedSMul.mk'\n    (by\n      intro x y z xy hz\n      rw [h (z â€¢ x) (z â€¢ y), â† smul_sub z y x]\n      exact smul_mem S hz ((h x y).mp xy.le))\n\n"}
{"name":"ConvexCone.pointed_iff_not_blunt","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nS : ConvexCone ğ•œ E\nâŠ¢ Iff S.Pointed (Not S.Blunt)","decl":"theorem pointed_iff_not_blunt (S : ConvexCone ğ•œ E) : S.Pointed â†” Â¬S.Blunt :=\n  âŸ¨fun hâ‚ hâ‚‚ => hâ‚‚ hâ‚, Classical.not_not.mpâŸ©\n\n"}
{"name":"ConvexCone.blunt_iff_not_pointed","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nS : ConvexCone ğ•œ E\nâŠ¢ Iff S.Blunt (Not S.Pointed)","decl":"theorem blunt_iff_not_pointed (S : ConvexCone ğ•œ E) : S.Blunt â†” Â¬S.Pointed := by\n  rw [pointed_iff_not_blunt, Classical.not_not]\n\n"}
{"name":"ConvexCone.Pointed.mono","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nS T : ConvexCone ğ•œ E\nh : LE.le S T\naâœ : S.Pointed\nâŠ¢ T.Pointed","decl":"theorem Pointed.mono {S T : ConvexCone ğ•œ E} (h : S â‰¤ T) : S.Pointed â†’ T.Pointed :=\n  @h _\n\n"}
{"name":"ConvexCone.Blunt.anti","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nS T : ConvexCone ğ•œ E\nh : LE.le T S\naâœ : S.Blunt\nâŠ¢ T.Blunt","decl":"theorem Blunt.anti {S T : ConvexCone ğ•œ E} (h : T â‰¤ S) : S.Blunt â†’ T.Blunt :=\n  (Â· âˆ˜ @h 0)\n\n"}
{"name":"ConvexCone.salient_iff_not_flat","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : SMul ğ•œ E\nS : ConvexCone ğ•œ E\nâŠ¢ Iff S.Salient (Not S.Flat)","decl":"theorem salient_iff_not_flat (S : ConvexCone ğ•œ E) : S.Salient â†” Â¬S.Flat := by\n  simp [Salient, Flat]\n\n"}
{"name":"ConvexCone.Flat.mono","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : SMul ğ•œ E\nS T : ConvexCone ğ•œ E\nh : LE.le S T\naâœ : S.Flat\nâŠ¢ T.Flat","decl":"theorem Flat.mono {S T : ConvexCone ğ•œ E} (h : S â‰¤ T) : S.Flat â†’ T.Flat\n  | âŸ¨x, hxS, hx, hnxSâŸ© => âŸ¨x, h hxS, hx, h hnxSâŸ©\n\n"}
{"name":"ConvexCone.Salient.anti","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : SMul ğ•œ E\nS T : ConvexCone ğ•œ E\nh : LE.le T S\naâœ : S.Salient\nâŠ¢ T.Salient","decl":"theorem Salient.anti {S T : ConvexCone ğ•œ E} (h : T â‰¤ S) : S.Salient â†’ T.Salient :=\n  fun hS x hxT hx hnT => hS x (h hxT) hx (h hnT)\n\n"}
{"name":"ConvexCone.Flat.pointed","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : SMul ğ•œ E\nS : ConvexCone ğ•œ E\nhS : S.Flat\nâŠ¢ S.Pointed","decl":"/-- A flat cone is always pointed (contains `0`). -/\ntheorem Flat.pointed {S : ConvexCone ğ•œ E} (hS : S.Flat) : S.Pointed := by\n  obtain âŸ¨x, hx, _, hxnegâŸ© := hS\n  rw [Pointed, â† add_neg_cancel x]\n  exact add_mem S hx hxneg\n\n"}
{"name":"ConvexCone.Blunt.salient","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : SMul ğ•œ E\nS : ConvexCone ğ•œ E\naâœ : S.Blunt\nâŠ¢ S.Salient","decl":"/-- A blunt cone (one not containing `0`) is always salient. -/\ntheorem Blunt.salient {S : ConvexCone ğ•œ E} : S.Blunt â†’ S.Salient := by\n  rw [salient_iff_not_flat, blunt_iff_not_pointed]\n  exact mt Flat.pointed\n\n"}
{"name":"ConvexCone.mem_zero","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : Module ğ•œ E\nx : E\nâŠ¢ Iff (Membership.mem 0 x) (Eq x 0)","decl":"@[simp]\ntheorem mem_zero (x : E) : x âˆˆ (0 : ConvexCone ğ•œ E) â†” x = 0 :=\n  Iff.rfl\n\n"}
{"name":"ConvexCone.coe_zero","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : Module ğ•œ E\nâŠ¢ Eq (â†‘0) 0","decl":"@[simp]\ntheorem coe_zero : ((0 : ConvexCone ğ•œ E) : Set E) = 0 :=\n  rfl\n\n"}
{"name":"ConvexCone.pointed_zero","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : Module ğ•œ E\nâŠ¢ ConvexCone.Pointed 0","decl":"theorem pointed_zero : (0 : ConvexCone ğ•œ E).Pointed := by rw [Pointed, mem_zero]\n\n"}
{"name":"ConvexCone.mem_add","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : Module ğ•œ E\nKâ‚ Kâ‚‚ : ConvexCone ğ•œ E\na : E\nâŠ¢ Iff (Membership.mem (HAdd.hAdd Kâ‚ Kâ‚‚) a) (Exists fun x => And (Membership.mem Kâ‚ x) (Exists fun y => And (Membership.mem Kâ‚‚ y) (Eq (HAdd.hAdd x y) a)))","decl":"@[simp]\ntheorem mem_add {Kâ‚ Kâ‚‚ : ConvexCone ğ•œ E} {a : E} :\n    a âˆˆ Kâ‚ + Kâ‚‚ â†” âˆƒ x âˆˆ Kâ‚, âˆƒ y âˆˆ Kâ‚‚, x + y = a :=\n  Iff.rfl\n\n"}
{"name":"Submodule.coe_toConvexCone","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : Module ğ•œ E\nS : Submodule ğ•œ E\nâŠ¢ Eq â†‘S.toConvexCone â†‘S","decl":"@[simp]\ntheorem coe_toConvexCone (S : Submodule ğ•œ E) : â†‘S.toConvexCone = (S : Set E) :=\n  rfl\n\n"}
{"name":"Submodule.mem_toConvexCone","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : Module ğ•œ E\nx : E\nS : Submodule ğ•œ E\nâŠ¢ Iff (Membership.mem S.toConvexCone x) (Membership.mem S x)","decl":"@[simp]\ntheorem mem_toConvexCone {x : E} {S : Submodule ğ•œ E} : x âˆˆ S.toConvexCone â†” x âˆˆ S :=\n  Iff.rfl\n\n"}
{"name":"Submodule.toConvexCone_le_iff","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : Module ğ•œ E\nS T : Submodule ğ•œ E\nâŠ¢ Iff (LE.le S.toConvexCone T.toConvexCone) (LE.le S T)","decl":"@[simp]\ntheorem toConvexCone_le_iff {S T : Submodule ğ•œ E} : S.toConvexCone â‰¤ T.toConvexCone â†” S â‰¤ T :=\n  Iff.rfl\n\n"}
{"name":"Submodule.toConvexCone_bot","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : Module ğ•œ E\nâŠ¢ Eq Bot.bot.toConvexCone 0","decl":"@[simp]\ntheorem toConvexCone_bot : (âŠ¥ : Submodule ğ•œ E).toConvexCone = 0 :=\n  rfl\n\n"}
{"name":"Submodule.toConvexCone_top","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : Module ğ•œ E\nâŠ¢ Eq Top.top.toConvexCone Top.top","decl":"@[simp]\ntheorem toConvexCone_top : (âŠ¤ : Submodule ğ•œ E).toConvexCone = âŠ¤ :=\n  rfl\n\n"}
{"name":"Submodule.toConvexCone_inf","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : Module ğ•œ E\nS T : Submodule ğ•œ E\nâŠ¢ Eq (Min.min S T).toConvexCone (Min.min S.toConvexCone T.toConvexCone)","decl":"@[simp]\ntheorem toConvexCone_inf (S T : Submodule ğ•œ E) :\n    (S âŠ“ T).toConvexCone = S.toConvexCone âŠ“ T.toConvexCone :=\n  rfl\n\n"}
{"name":"Submodule.pointed_toConvexCone","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : Module ğ•œ E\nS : Submodule ğ•œ E\nâŠ¢ S.toConvexCone.Pointed","decl":"@[simp]\ntheorem pointed_toConvexCone (S : Submodule ğ•œ E) : S.toConvexCone.Pointed :=\n  S.zero_mem\n\n"}
{"name":"ConvexCone.mem_positive","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : OrderedSemiring ğ•œ\ninstâœÂ² : OrderedAddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : OrderedSMul ğ•œ E\nx : E\nâŠ¢ Iff (Membership.mem (ConvexCone.positive ğ•œ E) x) (LE.le 0 x)","decl":"@[simp]\ntheorem mem_positive {x : E} : x âˆˆ positive ğ•œ E â†” 0 â‰¤ x :=\n  Iff.rfl\n\n"}
{"name":"ConvexCone.coe_positive","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : OrderedSemiring ğ•œ\ninstâœÂ² : OrderedAddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : OrderedSMul ğ•œ E\nâŠ¢ Eq (â†‘(ConvexCone.positive ğ•œ E)) (Set.Ici 0)","decl":"@[simp]\ntheorem coe_positive : â†‘(positive ğ•œ E) = Set.Ici (0 : E) :=\n  rfl\n\n"}
{"name":"ConvexCone.salient_positive","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : OrderedSemiring ğ•œ\ninstâœÂ² : OrderedAddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : OrderedSMul ğ•œ E\nâŠ¢ (ConvexCone.positive ğ•œ E).Salient","decl":"/-- The positive cone of an ordered module is always salient. -/\ntheorem salient_positive : Salient (positive ğ•œ E) := fun x xs hx hx' =>\n  lt_irrefl (0 : E)\n    (calc\n      0 < x := lt_of_le_of_ne xs hx.symm\n      _ â‰¤ x + -x := le_add_of_nonneg_right hx'\n      _ = 0 := add_neg_cancel x\n      )\n\n"}
{"name":"ConvexCone.pointed_positive","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : OrderedSemiring ğ•œ\ninstâœÂ² : OrderedAddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : OrderedSMul ğ•œ E\nâŠ¢ (ConvexCone.positive ğ•œ E).Pointed","decl":"/-- The positive cone of an ordered module is always pointed. -/\ntheorem pointed_positive : Pointed (positive ğ•œ E) :=\n  le_refl 0\n\n"}
{"name":"ConvexCone.mem_strictlyPositive","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : OrderedSemiring ğ•œ\ninstâœÂ² : OrderedAddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : OrderedSMul ğ•œ E\nx : E\nâŠ¢ Iff (Membership.mem (ConvexCone.strictlyPositive ğ•œ E) x) (LT.lt 0 x)","decl":"@[simp]\ntheorem mem_strictlyPositive {x : E} : x âˆˆ strictlyPositive ğ•œ E â†” 0 < x :=\n  Iff.rfl\n\n"}
{"name":"ConvexCone.coe_strictlyPositive","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : OrderedSemiring ğ•œ\ninstâœÂ² : OrderedAddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : OrderedSMul ğ•œ E\nâŠ¢ Eq (â†‘(ConvexCone.strictlyPositive ğ•œ E)) (Set.Ioi 0)","decl":"@[simp]\ntheorem coe_strictlyPositive : â†‘(strictlyPositive ğ•œ E) = Set.Ioi (0 : E) :=\n  rfl\n\n"}
{"name":"ConvexCone.positive_le_strictlyPositive","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : OrderedSemiring ğ•œ\ninstâœÂ² : OrderedAddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : OrderedSMul ğ•œ E\nâŠ¢ LE.le (ConvexCone.strictlyPositive ğ•œ E) (ConvexCone.positive ğ•œ E)","decl":"theorem positive_le_strictlyPositive : strictlyPositive ğ•œ E â‰¤ positive ğ•œ E := fun _ => le_of_lt\n\n"}
{"name":"ConvexCone.salient_strictlyPositive","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : OrderedSemiring ğ•œ\ninstâœÂ² : OrderedAddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : OrderedSMul ğ•œ E\nâŠ¢ (ConvexCone.strictlyPositive ğ•œ E).Salient","decl":"/-- The strictly positive cone of an ordered module is always salient. -/\ntheorem salient_strictlyPositive : Salient (strictlyPositive ğ•œ E) :=\n  (salient_positive ğ•œ E).anti <| positive_le_strictlyPositive ğ•œ E\n\n"}
{"name":"ConvexCone.blunt_strictlyPositive","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : OrderedSemiring ğ•œ\ninstâœÂ² : OrderedAddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : OrderedSMul ğ•œ E\nâŠ¢ (ConvexCone.strictlyPositive ğ•œ E).Blunt","decl":"/-- The strictly positive cone of an ordered module is always blunt. -/\ntheorem blunt_strictlyPositive : Blunt (strictlyPositive ğ•œ E) :=\n  lt_irrefl 0\n\n"}
{"name":"Convex.mem_toCone","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns : Set E\nhs : Convex ğ•œ s\nx : E\nâŠ¢ Iff (Membership.mem (Convex.toCone s hs) x) (Exists fun c => And (LT.lt 0 c) (Exists fun y => And (Membership.mem s y) (Eq (HSMul.hSMul c y) x)))","decl":"theorem mem_toCone : x âˆˆ hs.toCone s â†” âˆƒ c : ğ•œ, 0 < c âˆ§ âˆƒ y âˆˆ s, c â€¢ y = x := by\n  simp only [toCone, ConvexCone.mem_mk, mem_iUnion, mem_smul_set, eq_comm, exists_prop]\n\n"}
{"name":"Convex.mem_toCone'","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns : Set E\nhs : Convex ğ•œ s\nx : E\nâŠ¢ Iff (Membership.mem (Convex.toCone s hs) x) (Exists fun c => And (LT.lt 0 c) (Membership.mem s (HSMul.hSMul c x)))","decl":"theorem mem_toCone' : x âˆˆ hs.toCone s â†” âˆƒ c : ğ•œ, 0 < c âˆ§ c â€¢ x âˆˆ s := by\n  refine hs.mem_toCone.trans âŸ¨?_, ?_âŸ©\n  Â· rintro âŸ¨c, hc, y, hy, rflâŸ©\n    exact âŸ¨câ»Â¹, inv_pos.2 hc, by rwa [smul_smul, inv_mul_cancelâ‚€ hc.ne', one_smul]âŸ©\n  Â· rintro âŸ¨c, hc, hcxâŸ©\n    exact âŸ¨câ»Â¹, inv_pos.2 hc, _, hcx, by rw [smul_smul, inv_mul_cancelâ‚€ hc.ne', one_smul]âŸ©\n\n"}
{"name":"Convex.subset_toCone","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns : Set E\nhs : Convex ğ•œ s\nâŠ¢ HasSubset.Subset s â†‘(Convex.toCone s hs)","decl":"theorem subset_toCone : s âŠ† hs.toCone s := fun x hx =>\n  hs.mem_toCone'.2 âŸ¨1, zero_lt_one, by rwa [one_smul]âŸ©\n\n"}
{"name":"Convex.toCone_isLeast","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns : Set E\nhs : Convex ğ•œ s\nâŠ¢ IsLeast (setOf fun t => HasSubset.Subset s â†‘t) (Convex.toCone s hs)","decl":"/-- `hs.toCone s` is the least cone that includes `s`. -/\ntheorem toCone_isLeast : IsLeast { t : ConvexCone ğ•œ E | s âŠ† t } (hs.toCone s) := by\n  refine âŸ¨hs.subset_toCone, fun t ht x hx => ?_âŸ©\n  rcases hs.mem_toCone.1 hx with âŸ¨c, hc, y, hy, rflâŸ©\n  exact t.smul_mem hc (ht hy)\n\n"}
{"name":"Convex.toCone_eq_sInf","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns : Set E\nhs : Convex ğ•œ s\nâŠ¢ Eq (Convex.toCone s hs) (InfSet.sInf (setOf fun t => HasSubset.Subset s â†‘t))","decl":"theorem toCone_eq_sInf : hs.toCone s = sInf { t : ConvexCone ğ•œ E | s âŠ† t } :=\n  hs.toCone_isLeast.isGLB.sInf_eq.symm\n\n"}
{"name":"convexHull_toCone_isLeast","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns : Set E\nâŠ¢ IsLeast (setOf fun t => HasSubset.Subset s â†‘t) (Convex.toCone ((convexHull ğ•œ) s) â‹¯)","decl":"theorem convexHull_toCone_isLeast (s : Set E) :\n    IsLeast { t : ConvexCone ğ•œ E | s âŠ† t } ((convex_convexHull ğ•œ s).toCone _) := by\n  convert (convex_convexHull ğ•œ s).toCone_isLeast using 1\n  ext t\n  exact âŸ¨fun h => convexHull_min h t.convex, (subset_convexHull ğ•œ s).transâŸ©\n\n"}
{"name":"convexHull_toCone_eq_sInf","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns : Set E\nâŠ¢ Eq (Convex.toCone ((convexHull ğ•œ) s) â‹¯) (InfSet.sInf (setOf fun t => HasSubset.Subset s â†‘t))","decl":"theorem convexHull_toCone_eq_sInf (s : Set E) :\n    (convex_convexHull ğ•œ s).toCone _ = sInf { t : ConvexCone ğ•œ E | s âŠ† t } :=\n  Eq.symm <| IsGLB.sInf_eq <| IsLeast.isGLB <| convexHull_toCone_isLeast s\n\n"}
