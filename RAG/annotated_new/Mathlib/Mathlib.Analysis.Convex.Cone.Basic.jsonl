{"name":"ConvexCone.mk.sizeOf_spec","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : OrderedSemiring 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : SMul 𝕜 E\ninst✝¹ : SizeOf 𝕜\ninst✝ : SizeOf E\ncarrier : Set E\nsmul_mem' : ∀ ⦃c : 𝕜⦄, LT.lt 0 c → ∀ ⦃x : E⦄, Membership.mem carrier x → Membership.mem carrier (HSMul.hSMul c x)\nadd_mem' : ∀ ⦃x : E⦄, Membership.mem carrier x → ∀ ⦃y : E⦄, Membership.mem carrier y → Membership.mem carrier (HAdd.hAdd x y)\n⊢ Eq (SizeOf.sizeOf { carrier := carrier, smul_mem' := smul_mem', add_mem' := add_mem' }) 1","decl":"/-- A convex cone is a subset `s` of a `𝕜`-module such that `a • x + b • y ∈ s` whenever `a, b > 0`\nand `x, y ∈ s`. -/\nstructure ConvexCone [AddCommMonoid E] [SMul 𝕜 E] where\n  /-- The **carrier set** underlying this cone: the set of points contained in it -/\n  carrier : Set E\n  smul_mem' : ∀ ⦃c : 𝕜⦄, 0 < c → ∀ ⦃x : E⦄, x ∈ carrier → c • x ∈ carrier\n  add_mem' : ∀ ⦃x⦄ (_ : x ∈ carrier) ⦃y⦄ (_ : y ∈ carrier), x + y ∈ carrier\n\n"}
{"name":"ConvexCone.add_mem'","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nself : ConvexCone 𝕜 E\nx : E\nx✝¹ : Membership.mem self.carrier x\ny : E\nx✝ : Membership.mem self.carrier y\n⊢ Membership.mem self.carrier (HAdd.hAdd x y)","decl":"/-- A convex cone is a subset `s` of a `𝕜`-module such that `a • x + b • y ∈ s` whenever `a, b > 0`\nand `x, y ∈ s`. -/\nstructure ConvexCone [AddCommMonoid E] [SMul 𝕜 E] where\n  /-- The **carrier set** underlying this cone: the set of points contained in it -/\n  carrier : Set E\n  smul_mem' : ∀ ⦃c : 𝕜⦄, 0 < c → ∀ ⦃x : E⦄, x ∈ carrier → c • x ∈ carrier\n  add_mem' : ∀ ⦃x⦄ (_ : x ∈ carrier) ⦃y⦄ (_ : y ∈ carrier), x + y ∈ carrier\n\n"}
{"name":"ConvexCone.mk.inj","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\ncarrier✝ : Set E\nsmul_mem'✝ : ∀ ⦃c : 𝕜⦄, LT.lt 0 c → ∀ ⦃x : E⦄, Membership.mem carrier✝ x → Membership.mem carrier✝ (HSMul.hSMul c x)\nadd_mem'✝ : ∀ ⦃x : E⦄, Membership.mem carrier✝ x → ∀ ⦃y : E⦄, Membership.mem carrier✝ y → Membership.mem carrier✝ (HAdd.hAdd x y)\ncarrier : Set E\nsmul_mem' : ∀ ⦃c : 𝕜⦄, LT.lt 0 c → ∀ ⦃x : E⦄, Membership.mem carrier x → Membership.mem carrier (HSMul.hSMul c x)\nadd_mem' : ∀ ⦃x : E⦄, Membership.mem carrier x → ∀ ⦃y : E⦄, Membership.mem carrier y → Membership.mem carrier (HAdd.hAdd x y)\nx✝ : Eq { carrier := carrier✝, smul_mem' := smul_mem'✝, add_mem' := add_mem'✝ } { carrier := carrier, smul_mem' := smul_mem', add_mem' := add_mem' }\n⊢ Eq carrier✝ carrier","decl":"/-- A convex cone is a subset `s` of a `𝕜`-module such that `a • x + b • y ∈ s` whenever `a, b > 0`\nand `x, y ∈ s`. -/\nstructure ConvexCone [AddCommMonoid E] [SMul 𝕜 E] where\n  /-- The **carrier set** underlying this cone: the set of points contained in it -/\n  carrier : Set E\n  smul_mem' : ∀ ⦃c : 𝕜⦄, 0 < c → ∀ ⦃x : E⦄, x ∈ carrier → c • x ∈ carrier\n  add_mem' : ∀ ⦃x⦄ (_ : x ∈ carrier) ⦃y⦄ (_ : y ∈ carrier), x + y ∈ carrier\n\n"}
{"name":"ConvexCone.smul_mem'","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nself : ConvexCone 𝕜 E\nc : 𝕜\na✝¹ : LT.lt 0 c\nx : E\na✝ : Membership.mem self.carrier x\n⊢ Membership.mem self.carrier (HSMul.hSMul c x)","decl":"/-- A convex cone is a subset `s` of a `𝕜`-module such that `a • x + b • y ∈ s` whenever `a, b > 0`\nand `x, y ∈ s`. -/\nstructure ConvexCone [AddCommMonoid E] [SMul 𝕜 E] where\n  /-- The **carrier set** underlying this cone: the set of points contained in it -/\n  carrier : Set E\n  smul_mem' : ∀ ⦃c : 𝕜⦄, 0 < c → ∀ ⦃x : E⦄, x ∈ carrier → c • x ∈ carrier\n  add_mem' : ∀ ⦃x⦄ (_ : x ∈ carrier) ⦃y⦄ (_ : y ∈ carrier), x + y ∈ carrier\n\n"}
{"name":"ConvexCone.mk.injEq","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\ncarrier✝ : Set E\nsmul_mem'✝ : ∀ ⦃c : 𝕜⦄, LT.lt 0 c → ∀ ⦃x : E⦄, Membership.mem carrier✝ x → Membership.mem carrier✝ (HSMul.hSMul c x)\nadd_mem'✝ : ∀ ⦃x : E⦄, Membership.mem carrier✝ x → ∀ ⦃y : E⦄, Membership.mem carrier✝ y → Membership.mem carrier✝ (HAdd.hAdd x y)\ncarrier : Set E\nsmul_mem' : ∀ ⦃c : 𝕜⦄, LT.lt 0 c → ∀ ⦃x : E⦄, Membership.mem carrier x → Membership.mem carrier (HSMul.hSMul c x)\nadd_mem' : ∀ ⦃x : E⦄, Membership.mem carrier x → ∀ ⦃y : E⦄, Membership.mem carrier y → Membership.mem carrier (HAdd.hAdd x y)\n⊢ Eq (Eq { carrier := carrier✝, smul_mem' := smul_mem'✝, add_mem' := add_mem'✝ } { carrier := carrier, smul_mem' := smul_mem', add_mem' := add_mem' }) (Eq carrier✝ carrier)","decl":"/-- A convex cone is a subset `s` of a `𝕜`-module such that `a • x + b • y ∈ s` whenever `a, b > 0`\nand `x, y ∈ s`. -/\nstructure ConvexCone [AddCommMonoid E] [SMul 𝕜 E] where\n  /-- The **carrier set** underlying this cone: the set of points contained in it -/\n  carrier : Set E\n  smul_mem' : ∀ ⦃c : 𝕜⦄, 0 < c → ∀ ⦃x : E⦄, x ∈ carrier → c • x ∈ carrier\n  add_mem' : ∀ ⦃x⦄ (_ : x ∈ carrier) ⦃y⦄ (_ : y ∈ carrier), x + y ∈ carrier\n\n"}
{"name":"ConvexCone.coe_mk","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\ns : Set E\nh₁ : ∀ ⦃c : 𝕜⦄, LT.lt 0 c → ∀ ⦃x : E⦄, Membership.mem s x → Membership.mem s (HSMul.hSMul c x)\nh₂ : ∀ ⦃x : E⦄, Membership.mem s x → ∀ ⦃y : E⦄, Membership.mem s y → Membership.mem s (HAdd.hAdd x y)\n⊢ Eq (↑{ carrier := s, smul_mem' := h₁, add_mem' := h₂ }) s","decl":"@[simp]\ntheorem coe_mk {s : Set E} {h₁ h₂} : ↑(@mk 𝕜 _ _ _ _ s h₁ h₂) = s :=\n  rfl\n\n"}
{"name":"ConvexCone.mem_mk","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\ns : Set E\nh₁ : ∀ ⦃c : 𝕜⦄, LT.lt 0 c → ∀ ⦃x : E⦄, Membership.mem s x → Membership.mem s (HSMul.hSMul c x)\nh₂ : ∀ ⦃x : E⦄, Membership.mem s x → ∀ ⦃y : E⦄, Membership.mem s y → Membership.mem s (HAdd.hAdd x y)\nx : E\n⊢ Iff (Membership.mem { carrier := s, smul_mem' := h₁, add_mem' := h₂ } x) (Membership.mem s x)","decl":"@[simp]\ntheorem mem_mk {s : Set E} {h₁ h₂ x} : x ∈ @mk 𝕜 _ _ _ _ s h₁ h₂ ↔ x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"ConvexCone.ext","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nS T : ConvexCone 𝕜 E\nh : ∀ (x : E), Iff (Membership.mem S x) (Membership.mem T x)\n⊢ Eq S T","decl":"/-- Two `ConvexCone`s are equal if they have the same elements. -/\n@[ext]\ntheorem ext {S T : ConvexCone 𝕜 E} (h : ∀ x, x ∈ S ↔ x ∈ T) : S = T :=\n  SetLike.ext h\n\n"}
{"name":"ConvexCone.ext_iff","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nS T : ConvexCone 𝕜 E\n⊢ Iff (Eq S T) (∀ (x : E), Iff (Membership.mem S x) (Membership.mem T x))","decl":"/-- Two `ConvexCone`s are equal if they have the same elements. -/\n@[ext]\ntheorem ext {S T : ConvexCone 𝕜 E} (h : ∀ x, x ∈ S ↔ x ∈ T) : S = T :=\n  SetLike.ext h\n\n"}
{"name":"ConvexCone.smul_mem","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nS : ConvexCone 𝕜 E\nc : 𝕜\nx : E\nhc : LT.lt 0 c\nhx : Membership.mem S x\n⊢ Membership.mem S (HSMul.hSMul c x)","decl":"@[aesop safe apply (rule_sets := [SetLike])]\ntheorem smul_mem {c : 𝕜} {x : E} (hc : 0 < c) (hx : x ∈ S) : c • x ∈ S :=\n  S.smul_mem' hc hx\n\n"}
{"name":"ConvexCone.add_mem","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nS : ConvexCone 𝕜 E\nx : E\nhx : Membership.mem S x\ny : E\nhy : Membership.mem S y\n⊢ Membership.mem S (HAdd.hAdd x y)","decl":"theorem add_mem ⦃x⦄ (hx : x ∈ S) ⦃y⦄ (hy : y ∈ S) : x + y ∈ S :=\n  S.add_mem' hx hy\n\n"}
{"name":"ConvexCone.instAddMemClass","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\n⊢ AddMemClass (ConvexCone 𝕜 E) E","decl":"instance : AddMemClass (ConvexCone 𝕜 E) E where add_mem ha hb := add_mem _ ha hb\n\n"}
{"name":"ConvexCone.coe_inf","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nS T : ConvexCone 𝕜 E\n⊢ Eq (↑(Min.min S T)) (Inter.inter ↑S ↑T)","decl":"@[simp]\ntheorem coe_inf : ((S ⊓ T : ConvexCone 𝕜 E) : Set E) = ↑S ∩ ↑T :=\n  rfl\n\n"}
{"name":"ConvexCone.mem_inf","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nS T : ConvexCone 𝕜 E\nx : E\n⊢ Iff (Membership.mem (Min.min S T) x) (And (Membership.mem S x) (Membership.mem T x))","decl":"theorem mem_inf {x} : x ∈ S ⊓ T ↔ x ∈ S ∧ x ∈ T :=\n  Iff.rfl\n\n"}
{"name":"ConvexCone.coe_sInf","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nS : Set (ConvexCone 𝕜 E)\n⊢ Eq (↑(InfSet.sInf S)) (Set.iInter fun s => Set.iInter fun h => ↑s)","decl":"@[simp]\ntheorem coe_sInf (S : Set (ConvexCone 𝕜 E)) : ↑(sInf S) = ⋂ s ∈ S, (s : Set E) :=\n  rfl\n\n"}
{"name":"ConvexCone.mem_sInf","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nx : E\nS : Set (ConvexCone 𝕜 E)\n⊢ Iff (Membership.mem (InfSet.sInf S) x) (∀ (s : ConvexCone 𝕜 E), Membership.mem S s → Membership.mem s x)","decl":"theorem mem_sInf {x : E} {S : Set (ConvexCone 𝕜 E)} : x ∈ sInf S ↔ ∀ s ∈ S, x ∈ s :=\n  mem_iInter₂\n\n"}
{"name":"ConvexCone.coe_iInf","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nι : Sort u_5\nf : ι → ConvexCone 𝕜 E\n⊢ Eq (↑(iInf f)) (Set.iInter fun i => ↑(f i))","decl":"@[simp]\ntheorem coe_iInf {ι : Sort*} (f : ι → ConvexCone 𝕜 E) : ↑(iInf f) = ⋂ i, (f i : Set E) := by\n  simp [iInf]\n\n"}
{"name":"ConvexCone.mem_iInf","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nι : Sort u_5\nx : E\nf : ι → ConvexCone 𝕜 E\n⊢ Iff (Membership.mem (iInf f) x) (∀ (i : ι), Membership.mem (f i) x)","decl":"theorem mem_iInf {ι : Sort*} {x : E} {f : ι → ConvexCone 𝕜 E} : x ∈ iInf f ↔ ∀ i, x ∈ f i :=\n  mem_iInter₂.trans <| by simp\n\n"}
{"name":"ConvexCone.mem_bot","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nx : E\n⊢ Eq (Membership.mem Bot.bot x) False","decl":"theorem mem_bot (x : E) : (x ∈ (⊥ : ConvexCone 𝕜 E)) = False :=\n  rfl\n\n"}
{"name":"ConvexCone.coe_bot","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\n⊢ Eq (↑Bot.bot) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem coe_bot : ↑(⊥ : ConvexCone 𝕜 E) = (∅ : Set E) :=\n  rfl\n\n"}
{"name":"ConvexCone.mem_top","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nx : E\n⊢ Membership.mem Top.top x","decl":"theorem mem_top (x : E) : x ∈ (⊤ : ConvexCone 𝕜 E) :=\n  mem_univ x\n\n"}
{"name":"ConvexCone.coe_top","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\n⊢ Eq (↑Top.top) Set.univ","decl":"@[simp]\ntheorem coe_top : ↑(⊤ : ConvexCone 𝕜 E) = (univ : Set E) :=\n  rfl\n\n"}
{"name":"ConvexCone.convex","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : Module 𝕜 E\nS : ConvexCone 𝕜 E\n⊢ Convex 𝕜 ↑S","decl":"protected theorem convex : Convex 𝕜 (S : Set E) :=\n  convex_iff_forall_pos.2 fun _ hx _ hy _ _ ha hb _ =>\n    S.add_mem (S.smul_mem ha hx) (S.smul_mem hb hy)\n\n"}
{"name":"ConvexCone.coe_map","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : OrderedSemiring 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : AddCommMonoid F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜 F\nS : ConvexCone 𝕜 E\nf : LinearMap (RingHom.id 𝕜) E F\n⊢ Eq (↑(ConvexCone.map f S)) (Set.image ⇑f ↑S)","decl":"@[simp, norm_cast]\ntheorem coe_map (S : ConvexCone 𝕜 E) (f : E →ₗ[𝕜] F) : (S.map f : Set F) = f '' S :=\n  rfl\n\n"}
{"name":"ConvexCone.mem_map","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : OrderedSemiring 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : AddCommMonoid F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜 F\nf : LinearMap (RingHom.id 𝕜) E F\nS : ConvexCone 𝕜 E\ny : F\n⊢ Iff (Membership.mem (ConvexCone.map f S) y) (Exists fun x => And (Membership.mem S x) (Eq (f x) y))","decl":"@[simp]\ntheorem mem_map {f : E →ₗ[𝕜] F} {S : ConvexCone 𝕜 E} {y : F} : y ∈ S.map f ↔ ∃ x ∈ S, f x = y :=\n  Set.mem_image f S y\n\n"}
{"name":"ConvexCone.map_map","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : OrderedSemiring 𝕜\ninst✝⁵ : AddCommMonoid E\ninst✝⁴ : AddCommMonoid F\ninst✝³ : AddCommMonoid G\ninst✝² : Module 𝕜 E\ninst✝¹ : Module 𝕜 F\ninst✝ : Module 𝕜 G\ng : LinearMap (RingHom.id 𝕜) F G\nf : LinearMap (RingHom.id 𝕜) E F\nS : ConvexCone 𝕜 E\n⊢ Eq (ConvexCone.map g (ConvexCone.map f S)) (ConvexCone.map (g.comp f) S)","decl":"theorem map_map (g : F →ₗ[𝕜] G) (f : E →ₗ[𝕜] F) (S : ConvexCone 𝕜 E) :\n    (S.map f).map g = S.map (g.comp f) :=\n  SetLike.coe_injective <| image_image g f S\n\n"}
{"name":"ConvexCone.map_id","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : Module 𝕜 E\nS : ConvexCone 𝕜 E\n⊢ Eq (ConvexCone.map LinearMap.id S) S","decl":"@[simp]\ntheorem map_id (S : ConvexCone 𝕜 E) : S.map LinearMap.id = S :=\n  SetLike.coe_injective <| image_id _\n\n"}
{"name":"ConvexCone.coe_comap","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : OrderedSemiring 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : AddCommMonoid F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜 F\nf : LinearMap (RingHom.id 𝕜) E F\nS : ConvexCone 𝕜 F\n⊢ Eq (↑(ConvexCone.comap f S)) (Set.preimage ⇑f ↑S)","decl":"@[simp]\ntheorem coe_comap (f : E →ₗ[𝕜] F) (S : ConvexCone 𝕜 F) : (S.comap f : Set E) = f ⁻¹' S :=\n  rfl\n\n"}
{"name":"ConvexCone.comap_id","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : Module 𝕜 E\nS : ConvexCone 𝕜 E\n⊢ Eq (ConvexCone.comap LinearMap.id S) S","decl":"@[simp] -- Porting note: was not a `dsimp` lemma\ntheorem comap_id (S : ConvexCone 𝕜 E) : S.comap LinearMap.id = S :=\n  rfl\n\n"}
{"name":"ConvexCone.comap_comap","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : OrderedSemiring 𝕜\ninst✝⁵ : AddCommMonoid E\ninst✝⁴ : AddCommMonoid F\ninst✝³ : AddCommMonoid G\ninst✝² : Module 𝕜 E\ninst✝¹ : Module 𝕜 F\ninst✝ : Module 𝕜 G\ng : LinearMap (RingHom.id 𝕜) F G\nf : LinearMap (RingHom.id 𝕜) E F\nS : ConvexCone 𝕜 G\n⊢ Eq (ConvexCone.comap f (ConvexCone.comap g S)) (ConvexCone.comap (g.comp f) S)","decl":"theorem comap_comap (g : F →ₗ[𝕜] G) (f : E →ₗ[𝕜] F) (S : ConvexCone 𝕜 G) :\n    (S.comap g).comap f = S.comap (g.comp f) :=\n  rfl\n\n"}
{"name":"ConvexCone.mem_comap","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : OrderedSemiring 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : AddCommMonoid F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜 F\nf : LinearMap (RingHom.id 𝕜) E F\nS : ConvexCone 𝕜 F\nx : E\n⊢ Iff (Membership.mem (ConvexCone.comap f S) x) (Membership.mem S (f x))","decl":"@[simp]\ntheorem mem_comap {f : E →ₗ[𝕜] F} {S : ConvexCone 𝕜 F} {x : E} : x ∈ S.comap f ↔ f x ∈ S :=\n  Iff.rfl\n\n"}
{"name":"ConvexCone.smul_mem_iff","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : MulAction 𝕜 E\nS : ConvexCone 𝕜 E\nc : 𝕜\nhc : LT.lt 0 c\nx : E\n⊢ Iff (Membership.mem S (HSMul.hSMul c x)) (Membership.mem S x)","decl":"theorem smul_mem_iff {c : 𝕜} (hc : 0 < c) {x : E} : c • x ∈ S ↔ x ∈ S :=\n  ⟨fun h => inv_smul_smul₀ hc.ne' x ▸ S.smul_mem (inv_pos.2 hc) h, S.smul_mem hc⟩\n\n"}
{"name":"ConvexCone.to_orderedSMul","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : OrderedAddCommGroup E\ninst✝ : Module 𝕜 E\nS : ConvexCone 𝕜 E\nh : ∀ (x y : E), Iff (LE.le x y) (Membership.mem S (HSub.hSub y x))\n⊢ OrderedSMul 𝕜 E","decl":"/-- Constructs an ordered module given an `OrderedAddCommGroup`, a cone, and a proof that\nthe order relation is the one defined by the cone.\n-/\ntheorem to_orderedSMul (S : ConvexCone 𝕜 E) (h : ∀ x y : E, x ≤ y ↔ y - x ∈ S) : OrderedSMul 𝕜 E :=\n  OrderedSMul.mk'\n    (by\n      intro x y z xy hz\n      rw [h (z • x) (z • y), ← smul_sub z y x]\n      exact smul_mem S hz ((h x y).mp xy.le))\n\n"}
{"name":"ConvexCone.pointed_iff_not_blunt","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nS : ConvexCone 𝕜 E\n⊢ Iff S.Pointed (Not S.Blunt)","decl":"theorem pointed_iff_not_blunt (S : ConvexCone 𝕜 E) : S.Pointed ↔ ¬S.Blunt :=\n  ⟨fun h₁ h₂ => h₂ h₁, Classical.not_not.mp⟩\n\n"}
{"name":"ConvexCone.blunt_iff_not_pointed","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nS : ConvexCone 𝕜 E\n⊢ Iff S.Blunt (Not S.Pointed)","decl":"theorem blunt_iff_not_pointed (S : ConvexCone 𝕜 E) : S.Blunt ↔ ¬S.Pointed := by\n  rw [pointed_iff_not_blunt, Classical.not_not]\n\n"}
{"name":"ConvexCone.Pointed.mono","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nS T : ConvexCone 𝕜 E\nh : LE.le S T\na✝ : S.Pointed\n⊢ T.Pointed","decl":"theorem Pointed.mono {S T : ConvexCone 𝕜 E} (h : S ≤ T) : S.Pointed → T.Pointed :=\n  @h _\n\n"}
{"name":"ConvexCone.Blunt.anti","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : SMul 𝕜 E\nS T : ConvexCone 𝕜 E\nh : LE.le T S\na✝ : S.Blunt\n⊢ T.Blunt","decl":"theorem Blunt.anti {S T : ConvexCone 𝕜 E} (h : T ≤ S) : S.Blunt → T.Blunt :=\n  (· ∘ @h 0)\n\n"}
{"name":"ConvexCone.salient_iff_not_flat","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : SMul 𝕜 E\nS : ConvexCone 𝕜 E\n⊢ Iff S.Salient (Not S.Flat)","decl":"theorem salient_iff_not_flat (S : ConvexCone 𝕜 E) : S.Salient ↔ ¬S.Flat := by\n  simp [Salient, Flat]\n\n"}
{"name":"ConvexCone.Flat.mono","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : SMul 𝕜 E\nS T : ConvexCone 𝕜 E\nh : LE.le S T\na✝ : S.Flat\n⊢ T.Flat","decl":"theorem Flat.mono {S T : ConvexCone 𝕜 E} (h : S ≤ T) : S.Flat → T.Flat\n  | ⟨x, hxS, hx, hnxS⟩ => ⟨x, h hxS, hx, h hnxS⟩\n\n"}
{"name":"ConvexCone.Salient.anti","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : SMul 𝕜 E\nS T : ConvexCone 𝕜 E\nh : LE.le T S\na✝ : S.Salient\n⊢ T.Salient","decl":"theorem Salient.anti {S T : ConvexCone 𝕜 E} (h : T ≤ S) : S.Salient → T.Salient :=\n  fun hS x hxT hx hnT => hS x (h hxT) hx (h hnT)\n\n"}
{"name":"ConvexCone.Flat.pointed","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : SMul 𝕜 E\nS : ConvexCone 𝕜 E\nhS : S.Flat\n⊢ S.Pointed","decl":"/-- A flat cone is always pointed (contains `0`). -/\ntheorem Flat.pointed {S : ConvexCone 𝕜 E} (hS : S.Flat) : S.Pointed := by\n  obtain ⟨x, hx, _, hxneg⟩ := hS\n  rw [Pointed, ← add_neg_cancel x]\n  exact add_mem S hx hxneg\n\n"}
{"name":"ConvexCone.Blunt.salient","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : SMul 𝕜 E\nS : ConvexCone 𝕜 E\na✝ : S.Blunt\n⊢ S.Salient","decl":"/-- A blunt cone (one not containing `0`) is always salient. -/\ntheorem Blunt.salient {S : ConvexCone 𝕜 E} : S.Blunt → S.Salient := by\n  rw [salient_iff_not_flat, blunt_iff_not_pointed]\n  exact mt Flat.pointed\n\n"}
{"name":"ConvexCone.mem_zero","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : Module 𝕜 E\nx : E\n⊢ Iff (Membership.mem 0 x) (Eq x 0)","decl":"@[simp]\ntheorem mem_zero (x : E) : x ∈ (0 : ConvexCone 𝕜 E) ↔ x = 0 :=\n  Iff.rfl\n\n"}
{"name":"ConvexCone.coe_zero","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : Module 𝕜 E\n⊢ Eq (↑0) 0","decl":"@[simp]\ntheorem coe_zero : ((0 : ConvexCone 𝕜 E) : Set E) = 0 :=\n  rfl\n\n"}
{"name":"ConvexCone.pointed_zero","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : Module 𝕜 E\n⊢ ConvexCone.Pointed 0","decl":"theorem pointed_zero : (0 : ConvexCone 𝕜 E).Pointed := by rw [Pointed, mem_zero]\n\n"}
{"name":"ConvexCone.mem_add","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : Module 𝕜 E\nK₁ K₂ : ConvexCone 𝕜 E\na : E\n⊢ Iff (Membership.mem (HAdd.hAdd K₁ K₂) a) (Exists fun x => And (Membership.mem K₁ x) (Exists fun y => And (Membership.mem K₂ y) (Eq (HAdd.hAdd x y) a)))","decl":"@[simp]\ntheorem mem_add {K₁ K₂ : ConvexCone 𝕜 E} {a : E} :\n    a ∈ K₁ + K₂ ↔ ∃ x ∈ K₁, ∃ y ∈ K₂, x + y = a :=\n  Iff.rfl\n\n"}
{"name":"Submodule.coe_toConvexCone","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : Module 𝕜 E\nS : Submodule 𝕜 E\n⊢ Eq ↑S.toConvexCone ↑S","decl":"@[simp]\ntheorem coe_toConvexCone (S : Submodule 𝕜 E) : ↑S.toConvexCone = (S : Set E) :=\n  rfl\n\n"}
{"name":"Submodule.mem_toConvexCone","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : Module 𝕜 E\nx : E\nS : Submodule 𝕜 E\n⊢ Iff (Membership.mem S.toConvexCone x) (Membership.mem S x)","decl":"@[simp]\ntheorem mem_toConvexCone {x : E} {S : Submodule 𝕜 E} : x ∈ S.toConvexCone ↔ x ∈ S :=\n  Iff.rfl\n\n"}
{"name":"Submodule.toConvexCone_le_iff","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : Module 𝕜 E\nS T : Submodule 𝕜 E\n⊢ Iff (LE.le S.toConvexCone T.toConvexCone) (LE.le S T)","decl":"@[simp]\ntheorem toConvexCone_le_iff {S T : Submodule 𝕜 E} : S.toConvexCone ≤ T.toConvexCone ↔ S ≤ T :=\n  Iff.rfl\n\n"}
{"name":"Submodule.toConvexCone_bot","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : Module 𝕜 E\n⊢ Eq Bot.bot.toConvexCone 0","decl":"@[simp]\ntheorem toConvexCone_bot : (⊥ : Submodule 𝕜 E).toConvexCone = 0 :=\n  rfl\n\n"}
{"name":"Submodule.toConvexCone_top","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : Module 𝕜 E\n⊢ Eq Top.top.toConvexCone Top.top","decl":"@[simp]\ntheorem toConvexCone_top : (⊤ : Submodule 𝕜 E).toConvexCone = ⊤ :=\n  rfl\n\n"}
{"name":"Submodule.toConvexCone_inf","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : Module 𝕜 E\nS T : Submodule 𝕜 E\n⊢ Eq (Min.min S T).toConvexCone (Min.min S.toConvexCone T.toConvexCone)","decl":"@[simp]\ntheorem toConvexCone_inf (S T : Submodule 𝕜 E) :\n    (S ⊓ T).toConvexCone = S.toConvexCone ⊓ T.toConvexCone :=\n  rfl\n\n"}
{"name":"Submodule.pointed_toConvexCone","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : OrderedSemiring 𝕜\ninst✝¹ : AddCommMonoid E\ninst✝ : Module 𝕜 E\nS : Submodule 𝕜 E\n⊢ S.toConvexCone.Pointed","decl":"@[simp]\ntheorem pointed_toConvexCone (S : Submodule 𝕜 E) : S.toConvexCone.Pointed :=\n  S.zero_mem\n\n"}
{"name":"ConvexCone.mem_positive","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : OrderedSemiring 𝕜\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module 𝕜 E\ninst✝ : OrderedSMul 𝕜 E\nx : E\n⊢ Iff (Membership.mem (ConvexCone.positive 𝕜 E) x) (LE.le 0 x)","decl":"@[simp]\ntheorem mem_positive {x : E} : x ∈ positive 𝕜 E ↔ 0 ≤ x :=\n  Iff.rfl\n\n"}
{"name":"ConvexCone.coe_positive","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : OrderedSemiring 𝕜\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module 𝕜 E\ninst✝ : OrderedSMul 𝕜 E\n⊢ Eq (↑(ConvexCone.positive 𝕜 E)) (Set.Ici 0)","decl":"@[simp]\ntheorem coe_positive : ↑(positive 𝕜 E) = Set.Ici (0 : E) :=\n  rfl\n\n"}
{"name":"ConvexCone.salient_positive","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : OrderedSemiring 𝕜\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module 𝕜 E\ninst✝ : OrderedSMul 𝕜 E\n⊢ (ConvexCone.positive 𝕜 E).Salient","decl":"/-- The positive cone of an ordered module is always salient. -/\ntheorem salient_positive : Salient (positive 𝕜 E) := fun x xs hx hx' =>\n  lt_irrefl (0 : E)\n    (calc\n      0 < x := lt_of_le_of_ne xs hx.symm\n      _ ≤ x + -x := le_add_of_nonneg_right hx'\n      _ = 0 := add_neg_cancel x\n      )\n\n"}
{"name":"ConvexCone.pointed_positive","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : OrderedSemiring 𝕜\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module 𝕜 E\ninst✝ : OrderedSMul 𝕜 E\n⊢ (ConvexCone.positive 𝕜 E).Pointed","decl":"/-- The positive cone of an ordered module is always pointed. -/\ntheorem pointed_positive : Pointed (positive 𝕜 E) :=\n  le_refl 0\n\n"}
{"name":"ConvexCone.mem_strictlyPositive","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : OrderedSemiring 𝕜\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module 𝕜 E\ninst✝ : OrderedSMul 𝕜 E\nx : E\n⊢ Iff (Membership.mem (ConvexCone.strictlyPositive 𝕜 E) x) (LT.lt 0 x)","decl":"@[simp]\ntheorem mem_strictlyPositive {x : E} : x ∈ strictlyPositive 𝕜 E ↔ 0 < x :=\n  Iff.rfl\n\n"}
{"name":"ConvexCone.coe_strictlyPositive","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : OrderedSemiring 𝕜\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module 𝕜 E\ninst✝ : OrderedSMul 𝕜 E\n⊢ Eq (↑(ConvexCone.strictlyPositive 𝕜 E)) (Set.Ioi 0)","decl":"@[simp]\ntheorem coe_strictlyPositive : ↑(strictlyPositive 𝕜 E) = Set.Ioi (0 : E) :=\n  rfl\n\n"}
{"name":"ConvexCone.positive_le_strictlyPositive","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : OrderedSemiring 𝕜\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module 𝕜 E\ninst✝ : OrderedSMul 𝕜 E\n⊢ LE.le (ConvexCone.strictlyPositive 𝕜 E) (ConvexCone.positive 𝕜 E)","decl":"theorem positive_le_strictlyPositive : strictlyPositive 𝕜 E ≤ positive 𝕜 E := fun _ => le_of_lt\n\n"}
{"name":"ConvexCone.salient_strictlyPositive","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : OrderedSemiring 𝕜\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module 𝕜 E\ninst✝ : OrderedSMul 𝕜 E\n⊢ (ConvexCone.strictlyPositive 𝕜 E).Salient","decl":"/-- The strictly positive cone of an ordered module is always salient. -/\ntheorem salient_strictlyPositive : Salient (strictlyPositive 𝕜 E) :=\n  (salient_positive 𝕜 E).anti <| positive_le_strictlyPositive 𝕜 E\n\n"}
{"name":"ConvexCone.blunt_strictlyPositive","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : OrderedSemiring 𝕜\ninst✝² : OrderedAddCommGroup E\ninst✝¹ : Module 𝕜 E\ninst✝ : OrderedSMul 𝕜 E\n⊢ (ConvexCone.strictlyPositive 𝕜 E).Blunt","decl":"/-- The strictly positive cone of an ordered module is always blunt. -/\ntheorem blunt_strictlyPositive : Blunt (strictlyPositive 𝕜 E) :=\n  lt_irrefl 0\n\n"}
{"name":"Convex.mem_toCone","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set E\nhs : Convex 𝕜 s\nx : E\n⊢ Iff (Membership.mem (Convex.toCone s hs) x) (Exists fun c => And (LT.lt 0 c) (Exists fun y => And (Membership.mem s y) (Eq (HSMul.hSMul c y) x)))","decl":"theorem mem_toCone : x ∈ hs.toCone s ↔ ∃ c : 𝕜, 0 < c ∧ ∃ y ∈ s, c • y = x := by\n  simp only [toCone, ConvexCone.mem_mk, mem_iUnion, mem_smul_set, eq_comm, exists_prop]\n\n"}
{"name":"Convex.mem_toCone'","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set E\nhs : Convex 𝕜 s\nx : E\n⊢ Iff (Membership.mem (Convex.toCone s hs) x) (Exists fun c => And (LT.lt 0 c) (Membership.mem s (HSMul.hSMul c x)))","decl":"theorem mem_toCone' : x ∈ hs.toCone s ↔ ∃ c : 𝕜, 0 < c ∧ c • x ∈ s := by\n  refine hs.mem_toCone.trans ⟨?_, ?_⟩\n  · rintro ⟨c, hc, y, hy, rfl⟩\n    exact ⟨c⁻¹, inv_pos.2 hc, by rwa [smul_smul, inv_mul_cancel₀ hc.ne', one_smul]⟩\n  · rintro ⟨c, hc, hcx⟩\n    exact ⟨c⁻¹, inv_pos.2 hc, _, hcx, by rw [smul_smul, inv_mul_cancel₀ hc.ne', one_smul]⟩\n\n"}
{"name":"Convex.subset_toCone","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set E\nhs : Convex 𝕜 s\n⊢ HasSubset.Subset s ↑(Convex.toCone s hs)","decl":"theorem subset_toCone : s ⊆ hs.toCone s := fun x hx =>\n  hs.mem_toCone'.2 ⟨1, zero_lt_one, by rwa [one_smul]⟩\n\n"}
{"name":"Convex.toCone_isLeast","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set E\nhs : Convex 𝕜 s\n⊢ IsLeast (setOf fun t => HasSubset.Subset s ↑t) (Convex.toCone s hs)","decl":"/-- `hs.toCone s` is the least cone that includes `s`. -/\ntheorem toCone_isLeast : IsLeast { t : ConvexCone 𝕜 E | s ⊆ t } (hs.toCone s) := by\n  refine ⟨hs.subset_toCone, fun t ht x hx => ?_⟩\n  rcases hs.mem_toCone.1 hx with ⟨c, hc, y, hy, rfl⟩\n  exact t.smul_mem hc (ht hy)\n\n"}
{"name":"Convex.toCone_eq_sInf","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set E\nhs : Convex 𝕜 s\n⊢ Eq (Convex.toCone s hs) (InfSet.sInf (setOf fun t => HasSubset.Subset s ↑t))","decl":"theorem toCone_eq_sInf : hs.toCone s = sInf { t : ConvexCone 𝕜 E | s ⊆ t } :=\n  hs.toCone_isLeast.isGLB.sInf_eq.symm\n\n"}
{"name":"convexHull_toCone_isLeast","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set E\n⊢ IsLeast (setOf fun t => HasSubset.Subset s ↑t) (Convex.toCone ((convexHull 𝕜) s) ⋯)","decl":"theorem convexHull_toCone_isLeast (s : Set E) :\n    IsLeast { t : ConvexCone 𝕜 E | s ⊆ t } ((convex_convexHull 𝕜 s).toCone _) := by\n  convert (convex_convexHull 𝕜 s).toCone_isLeast using 1\n  ext t\n  exact ⟨fun h => convexHull_min h t.convex, (subset_convexHull 𝕜 s).trans⟩\n\n"}
{"name":"convexHull_toCone_eq_sInf","module":"Mathlib.Analysis.Convex.Cone.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set E\n⊢ Eq (Convex.toCone ((convexHull 𝕜) s) ⋯) (InfSet.sInf (setOf fun t => HasSubset.Subset s ↑t))","decl":"theorem convexHull_toCone_eq_sInf (s : Set E) :\n    (convex_convexHull 𝕜 s).toCone _ = sInf { t : ConvexCone 𝕜 E | s ⊆ t } :=\n  Eq.symm <| IsGLB.sInf_eq <| IsLeast.isGLB <| convexHull_toCone_isLeast s\n\n"}
