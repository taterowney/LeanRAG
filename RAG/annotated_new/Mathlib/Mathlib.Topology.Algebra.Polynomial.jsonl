{"name":"Polynomial.continuous_eval₂","module":"Mathlib.Topology.Algebra.Polynomial","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : Semiring R\ninst✝² : TopologicalSpace R\ninst✝¹ : TopologicalSemiring R\ninst✝ : Semiring S\np : Polynomial S\nf : RingHom S R\n⊢ Continuous fun x => Polynomial.eval₂ f x p","decl":"@[continuity, fun_prop]\nprotected theorem continuous_eval₂ [Semiring S] (p : S[X]) (f : S →+* R) :\n    Continuous fun x => p.eval₂ f x := by\n  simp only [eval₂_eq_sum, Finsupp.sum]\n  exact continuous_finset_sum _ fun c _ => continuous_const.mul (continuous_pow _)\n\n"}
{"name":"Polynomial.continuous","module":"Mathlib.Topology.Algebra.Polynomial","initialProofState":"R : Type u_1\ninst✝² : Semiring R\ninst✝¹ : TopologicalSpace R\ninst✝ : TopologicalSemiring R\np : Polynomial R\n⊢ Continuous fun x => Polynomial.eval x p","decl":"@[continuity, fun_prop]\nprotected theorem continuous : Continuous fun x => p.eval x :=\n  p.continuous_eval₂ _\n\n"}
{"name":"Polynomial.continuousAt","module":"Mathlib.Topology.Algebra.Polynomial","initialProofState":"R : Type u_1\ninst✝² : Semiring R\ninst✝¹ : TopologicalSpace R\ninst✝ : TopologicalSemiring R\np : Polynomial R\na : R\n⊢ ContinuousAt (fun x => Polynomial.eval x p) a","decl":"@[fun_prop]\nprotected theorem continuousAt {a : R} : ContinuousAt (fun x => p.eval x) a :=\n  p.continuous.continuousAt\n\n"}
{"name":"Polynomial.continuousWithinAt","module":"Mathlib.Topology.Algebra.Polynomial","initialProofState":"R : Type u_1\ninst✝² : Semiring R\ninst✝¹ : TopologicalSpace R\ninst✝ : TopologicalSemiring R\np : Polynomial R\ns : Set R\na : R\n⊢ ContinuousWithinAt (fun x => Polynomial.eval x p) s a","decl":"@[fun_prop]\nprotected theorem continuousWithinAt {s a} : ContinuousWithinAt (fun x => p.eval x) s a :=\n  p.continuous.continuousWithinAt\n\n"}
{"name":"Polynomial.continuousOn","module":"Mathlib.Topology.Algebra.Polynomial","initialProofState":"R : Type u_1\ninst✝² : Semiring R\ninst✝¹ : TopologicalSpace R\ninst✝ : TopologicalSemiring R\np : Polynomial R\ns : Set R\n⊢ ContinuousOn (fun x => Polynomial.eval x p) s","decl":"@[fun_prop]\nprotected theorem continuousOn {s} : ContinuousOn (fun x => p.eval x) s :=\n  p.continuous.continuousOn\n\n"}
{"name":"Polynomial.continuous_aeval","module":"Mathlib.Topology.Algebra.Polynomial","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSemiring A\np : Polynomial R\n⊢ Continuous fun x => (Polynomial.aeval x) p","decl":"@[continuity, fun_prop]\nprotected theorem continuous_aeval : Continuous fun x : A => aeval x p :=\n  p.continuous_eval₂ _\n\n"}
{"name":"Polynomial.continuousAt_aeval","module":"Mathlib.Topology.Algebra.Polynomial","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSemiring A\np : Polynomial R\na : A\n⊢ ContinuousAt (fun x => (Polynomial.aeval x) p) a","decl":"@[fun_prop]\nprotected theorem continuousAt_aeval {a : A} : ContinuousAt (fun x : A => aeval x p) a :=\n  p.continuous_aeval.continuousAt\n\n"}
{"name":"Polynomial.continuousWithinAt_aeval","module":"Mathlib.Topology.Algebra.Polynomial","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSemiring A\np : Polynomial R\ns : Set A\na : A\n⊢ ContinuousWithinAt (fun x => (Polynomial.aeval x) p) s a","decl":"@[fun_prop]\nprotected theorem continuousWithinAt_aeval {s a} :\n    ContinuousWithinAt (fun x : A => aeval x p) s a :=\n  p.continuous_aeval.continuousWithinAt\n\n"}
{"name":"Polynomial.continuousOn_aeval","module":"Mathlib.Topology.Algebra.Polynomial","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSemiring A\np : Polynomial R\ns : Set A\n⊢ ContinuousOn (fun x => (Polynomial.aeval x) p) s","decl":"@[fun_prop]\nprotected theorem continuousOn_aeval {s} : ContinuousOn (fun x : A => aeval x p) s :=\n  p.continuous_aeval.continuousOn\n\n"}
{"name":"Polynomial.tendsto_abv_eval₂_atTop","module":"Mathlib.Topology.Algebra.Polynomial","initialProofState":"R : Type u_1\nS : Type u_2\nk : Type u_3\nα : Type u_4\ninst✝³ : Semiring R\ninst✝² : Ring S\ninst✝¹ : LinearOrderedField k\nf : RingHom R S\nabv : S → k\ninst✝ : IsAbsoluteValue abv\np : Polynomial R\nhd : LT.lt 0 p.degree\nhf : Ne (f p.leadingCoeff) 0\nl : Filter α\nz : α → S\nhz : Filter.Tendsto (Function.comp abv z) l Filter.atTop\n⊢ Filter.Tendsto (fun x => abv (Polynomial.eval₂ f (z x) p)) l Filter.atTop","decl":"theorem tendsto_abv_eval₂_atTop {R S k α : Type*} [Semiring R] [Ring S] [LinearOrderedField k]\n    (f : R →+* S) (abv : S → k) [IsAbsoluteValue abv] (p : R[X]) (hd : 0 < degree p)\n    (hf : f p.leadingCoeff ≠ 0) {l : Filter α} {z : α → S} (hz : Tendsto (abv ∘ z) l atTop) :\n    Tendsto (fun x => abv (p.eval₂ f (z x))) l atTop := by\n  revert hf; refine degree_pos_induction_on p hd ?_ ?_ ?_ <;> clear hd p\n  · rintro _ - hc\n    rw [leadingCoeff_mul_X, leadingCoeff_C] at hc\n    simpa [abv_mul abv] using hz.const_mul_atTop ((abv_pos abv).2 hc)\n  · intro _ _ ihp hf\n    rw [leadingCoeff_mul_X] at hf\n    simpa [abv_mul abv] using (ihp hf).atTop_mul_atTop hz\n  · intro _ a hd ihp hf\n    rw [add_comm, leadingCoeff_add_of_degree_lt (degree_C_le.trans_lt hd)] at hf\n    refine tendsto_atTop_of_add_const_right (abv (-f a)) ?_\n    refine tendsto_atTop_mono (fun _ => abv_add abv _ _) ?_\n    simpa using ihp hf\n\n"}
{"name":"Polynomial.tendsto_abv_atTop","module":"Mathlib.Topology.Algebra.Polynomial","initialProofState":"R : Type u_1\nk : Type u_2\nα : Type u_3\ninst✝² : Ring R\ninst✝¹ : LinearOrderedField k\nabv : R → k\ninst✝ : IsAbsoluteValue abv\np : Polynomial R\nh : LT.lt 0 p.degree\nl : Filter α\nz : α → R\nhz : Filter.Tendsto (Function.comp abv z) l Filter.atTop\n⊢ Filter.Tendsto (fun x => abv (Polynomial.eval (z x) p)) l Filter.atTop","decl":"theorem tendsto_abv_atTop {R k α : Type*} [Ring R] [LinearOrderedField k] (abv : R → k)\n    [IsAbsoluteValue abv] (p : R[X]) (h : 0 < degree p) {l : Filter α} {z : α → R}\n    (hz : Tendsto (abv ∘ z) l atTop) : Tendsto (fun x => abv (p.eval (z x))) l atTop := by\n  apply tendsto_abv_eval₂_atTop _ _ _ h _ hz\n  exact mt leadingCoeff_eq_zero.1 (ne_zero_of_degree_gt h)\n\n"}
{"name":"Polynomial.tendsto_abv_aeval_atTop","module":"Mathlib.Topology.Algebra.Polynomial","initialProofState":"R : Type u_1\nA : Type u_2\nk : Type u_3\nα : Type u_4\ninst✝⁴ : CommSemiring R\ninst✝³ : Ring A\ninst✝² : Algebra R A\ninst✝¹ : LinearOrderedField k\nabv : A → k\ninst✝ : IsAbsoluteValue abv\np : Polynomial R\nhd : LT.lt 0 p.degree\nh₀ : Ne ((algebraMap R A) p.leadingCoeff) 0\nl : Filter α\nz : α → A\nhz : Filter.Tendsto (Function.comp abv z) l Filter.atTop\n⊢ Filter.Tendsto (fun x => abv ((Polynomial.aeval (z x)) p)) l Filter.atTop","decl":"theorem tendsto_abv_aeval_atTop {R A k α : Type*} [CommSemiring R] [Ring A] [Algebra R A]\n    [LinearOrderedField k] (abv : A → k) [IsAbsoluteValue abv] (p : R[X]) (hd : 0 < degree p)\n    (h₀ : algebraMap R A p.leadingCoeff ≠ 0) {l : Filter α} {z : α → A}\n    (hz : Tendsto (abv ∘ z) l atTop) : Tendsto (fun x => abv (aeval (z x) p)) l atTop :=\n  tendsto_abv_eval₂_atTop _ abv p hd h₀ hz\n\n"}
{"name":"Polynomial.tendsto_norm_atTop","module":"Mathlib.Topology.Algebra.Polynomial","initialProofState":"α : Type u_1\nR : Type u_2\ninst✝¹ : NormedRing R\ninst✝ : IsAbsoluteValue Norm.norm\np : Polynomial R\nh : LT.lt 0 p.degree\nl : Filter α\nz : α → R\nhz : Filter.Tendsto (fun x => Norm.norm (z x)) l Filter.atTop\n⊢ Filter.Tendsto (fun x => Norm.norm (Polynomial.eval (z x) p)) l Filter.atTop","decl":"theorem tendsto_norm_atTop (p : R[X]) (h : 0 < degree p) {l : Filter α} {z : α → R}\n    (hz : Tendsto (fun x => ‖z x‖) l atTop) : Tendsto (fun x => ‖p.eval (z x)‖) l atTop :=\n  p.tendsto_abv_atTop norm h hz\n\n"}
{"name":"Polynomial.exists_forall_norm_le","module":"Mathlib.Topology.Algebra.Polynomial","initialProofState":"R : Type u_2\ninst✝² : NormedRing R\ninst✝¹ : IsAbsoluteValue Norm.norm\ninst✝ : ProperSpace R\np : Polynomial R\n⊢ Exists fun x => ∀ (y : R), LE.le (Norm.norm (Polynomial.eval x p)) (Norm.norm (Polynomial.eval y p))","decl":"theorem exists_forall_norm_le [ProperSpace R] (p : R[X]) : ∃ x, ∀ y, ‖p.eval x‖ ≤ ‖p.eval y‖ :=\n  if hp0 : 0 < degree p then\n    p.continuous.norm.exists_forall_le <| p.tendsto_norm_atTop hp0 tendsto_norm_cocompact_atTop\n  else\n    ⟨p.coeff 0, by rw [eq_C_of_degree_le_zero (le_of_not_gt hp0)]; simp⟩\n\n"}
{"name":"Polynomial.eq_one_of_roots_le","module":"Mathlib.Topology.Algebra.Polynomial","initialProofState":"F : Type u_3\nK : Type u_4\ninst✝¹ : CommRing F\ninst✝ : NormedField K\np : Polynomial F\nf : RingHom F K\nB : Real\nhB : LT.lt B 0\nh1 : p.Monic\nh2 : Polynomial.Splits f p\nh3 : ∀ (z : K), Membership.mem (Polynomial.map f p).roots z → LE.le (Norm.norm z) B\n⊢ Eq p 1","decl":"theorem eq_one_of_roots_le {p : F[X]} {f : F →+* K} {B : ℝ} (hB : B < 0) (h1 : p.Monic)\n    (h2 : Splits f p) (h3 : ∀ z ∈ (map f p).roots, ‖z‖ ≤ B) : p = 1 :=\n  h1.natDegree_eq_zero_iff_eq_one.mp (by\n    contrapose! hB\n    rw [← h1.natDegree_map f, natDegree_eq_card_roots' h2] at hB\n    obtain ⟨z, hz⟩ := card_pos_iff_exists_mem.mp (zero_lt_iff.mpr hB)\n    exact le_trans (norm_nonneg _) (h3 z hz))\n\n"}
{"name":"Polynomial.coeff_le_of_roots_le","module":"Mathlib.Topology.Algebra.Polynomial","initialProofState":"F : Type u_3\nK : Type u_4\ninst✝¹ : CommRing F\ninst✝ : NormedField K\np : Polynomial F\nf : RingHom F K\nB : Real\ni : Nat\nh1 : p.Monic\nh2 : Polynomial.Splits f p\nh3 : ∀ (z : K), Membership.mem (Polynomial.map f p).roots z → LE.le (Norm.norm z) B\n⊢ LE.le (Norm.norm ((Polynomial.map f p).coeff i)) (HMul.hMul (HPow.hPow B (HSub.hSub p.natDegree i)) ↑(p.natDegree.choose i))","decl":"theorem coeff_le_of_roots_le {p : F[X]} {f : F →+* K} {B : ℝ} (i : ℕ) (h1 : p.Monic)\n    (h2 : Splits f p) (h3 : ∀ z ∈ (map f p).roots, ‖z‖ ≤ B) :\n    ‖(map f p).coeff i‖ ≤ B ^ (p.natDegree - i) * p.natDegree.choose i := by\n  obtain hB | hB := lt_or_le B 0\n  · rw [eq_one_of_roots_le hB h1 h2 h3, Polynomial.map_one, natDegree_one, zero_tsub, pow_zero,\n      one_mul, coeff_one]\n    split_ifs with h <;> simp [h]\n  rw [← h1.natDegree_map f]\n  obtain hi | hi := lt_or_le (map f p).natDegree i\n  · rw [coeff_eq_zero_of_natDegree_lt hi, norm_zero]\n    positivity\n  rw [coeff_eq_esymm_roots_of_splits ((splits_id_iff_splits f).2 h2) hi, (h1.map _).leadingCoeff,\n    one_mul, norm_mul, norm_pow, norm_neg, norm_one, one_pow, one_mul]\n  apply ((norm_multiset_sum_le _).trans <| sum_le_card_nsmul _ _ fun r hr => _).trans\n  · rw [Multiset.map_map, card_map, card_powersetCard, ← natDegree_eq_card_roots' h2,\n      Nat.choose_symm hi, mul_comm, nsmul_eq_mul]\n  intro r hr\n  simp_rw [Multiset.mem_map] at hr\n  obtain ⟨_, ⟨s, hs, rfl⟩, rfl⟩ := hr\n  rw [mem_powersetCard] at hs\n  lift B to ℝ≥0 using hB\n  rw [← coe_nnnorm, ← NNReal.coe_pow, NNReal.coe_le_coe, ← nnnormHom_apply, ← MonoidHom.coe_coe,\n    MonoidHom.map_multiset_prod]\n  refine (prod_le_pow_card _ B fun x hx => ?_).trans_eq (by rw [card_map, hs.2])\n  obtain ⟨z, hz, rfl⟩ := Multiset.mem_map.1 hx\n  exact h3 z (mem_of_le hs.1 hz)\n\n"}
{"name":"Polynomial.coeff_bdd_of_roots_le","module":"Mathlib.Topology.Algebra.Polynomial","initialProofState":"F : Type u_3\nK : Type u_4\ninst✝¹ : CommRing F\ninst✝ : NormedField K\nB : Real\nd : Nat\nf : RingHom F K\np : Polynomial F\nh1 : p.Monic\nh2 : Polynomial.Splits f p\nh3 : LE.le p.natDegree d\nh4 : ∀ (z : K), Membership.mem (Polynomial.map f p).roots z → LE.le (Norm.norm z) B\ni : Nat\n⊢ LE.le (Norm.norm ((Polynomial.map f p).coeff i)) (HMul.hMul (HPow.hPow (Max.max B 1) d) ↑(d.choose (HDiv.hDiv d 2)))","decl":"/-- The coefficients of the monic polynomials of bounded degree with bounded roots are\nuniformly bounded. -/\ntheorem coeff_bdd_of_roots_le {B : ℝ} {d : ℕ} (f : F →+* K) {p : F[X]} (h1 : p.Monic)\n    (h2 : Splits f p) (h3 : p.natDegree ≤ d) (h4 : ∀ z ∈ (map f p).roots, ‖z‖ ≤ B) (i : ℕ) :\n    ‖(map f p).coeff i‖ ≤ max B 1 ^ d * d.choose (d / 2) := by\n  obtain hB | hB := le_or_lt 0 B\n  · apply (coeff_le_of_roots_le i h1 h2 h4).trans\n    calc\n      _ ≤ max B 1 ^ (p.natDegree - i) * p.natDegree.choose i := by gcongr; apply le_max_left\n      _ ≤ max B 1 ^ d * p.natDegree.choose i := by\n        gcongr\n        · apply le_max_right\n        · exact le_trans (Nat.sub_le _ _) h3\n      _ ≤ max B 1 ^ d * d.choose (d / 2) := by\n        gcongr; exact (i.choose_mono h3).trans (i.choose_le_middle d)\n  · rw [eq_one_of_roots_le hB h1 h2 h4, Polynomial.map_one, coeff_one]\n    refine le_trans ?_ (one_le_mul_of_one_le_of_one_le (one_le_pow₀ (le_max_right B 1)) ?_)\n    · split_ifs <;> norm_num\n    · exact mod_cast Nat.succ_le_iff.mpr (Nat.choose_pos (d.div_le_self 2))\n\n"}
