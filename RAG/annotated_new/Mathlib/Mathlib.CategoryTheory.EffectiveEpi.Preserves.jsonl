{"name":"CategoryTheory.effectiveEpiFamilyStructOfEquivalence_aux","module":"Mathlib.CategoryTheory.EffectiveEpi.Preserves","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst✝ : CategoryTheory.Category.{u_4, u_2} D\ne : CategoryTheory.Equivalence C D\nB : C\nα : Type u_3\nX : α → C\nπ : (a : α) → Quiver.Hom (X a) B\nW : D\nε : (a : α) → Quiver.Hom (e.functor.obj (X a)) W\nh : ∀ {Z : D} (a₁ a₂ : α) (g₁ : Quiver.Hom Z (e.functor.obj (X a₁))) (g₂ : Quiver.Hom Z (e.functor.obj (X a₂))), Eq (CategoryTheory.CategoryStruct.comp g₁ (e.functor.map (π a₁))) (CategoryTheory.CategoryStruct.comp g₂ (e.functor.map (π a₂))) → Eq (CategoryTheory.CategoryStruct.comp g₁ (ε a₁)) (CategoryTheory.CategoryStruct.comp g₂ (ε a₂))\nZ : C\na₁ a₂ : α\ng₁ : Quiver.Hom Z (X a₁)\ng₂ : Quiver.Hom Z (X a₂)\nhg : Eq (CategoryTheory.CategoryStruct.comp g₁ (π a₁)) (CategoryTheory.CategoryStruct.comp g₂ (π a₂))\n⊢ Eq (CategoryTheory.CategoryStruct.comp g₁ ((fun a => CategoryTheory.CategoryStruct.comp (e.unit.app (X a)) (e.inverse.map (ε a))) a₁)) (CategoryTheory.CategoryStruct.comp g₂ ((fun a => CategoryTheory.CategoryStruct.comp (e.unit.app (X a)) (e.inverse.map (ε a))) a₂))","decl":"theorem effectiveEpiFamilyStructOfEquivalence_aux {W : D} (ε : (a : α) → e.functor.obj (X a) ⟶ W)\n    (h : ∀ {Z : D} (a₁ a₂ : α) (g₁ : Z ⟶ e.functor.obj (X a₁)) (g₂ : Z ⟶ e.functor.obj (X a₂)),\n      g₁ ≫ e.functor.map (π a₁) = g₂ ≫ e.functor.map (π a₂) → g₁ ≫ ε a₁ = g₂ ≫ ε a₂)\n    {Z : C} (a₁ a₂ : α) (g₁ : Z ⟶ X a₁) (g₂ : Z ⟶ X a₂) (hg : g₁ ≫ π a₁ = g₂ ≫ π a₂) :\n    g₁ ≫ (fun a ↦ e.unit.app (X a) ≫ e.inverse.map (ε a)) a₁ =\n    g₂ ≫ (fun a ↦ e.unit.app (X a) ≫ e.inverse.map (ε a)) a₂ := by\n  have := h a₁ a₂ (e.functor.map g₁) (e.functor.map g₂)\n  simp only [← Functor.map_comp, hg] at this\n  simpa using congrArg e.inverse.map (this (by trivial))\n\n"}
{"name":"CategoryTheory.instEffectiveEpiFamilyObjMapOfIsEquivalence","module":"Mathlib.CategoryTheory.EffectiveEpi.Preserves","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\nB : C\nα : Type u_3\nX : α → C\nπ : (a : α) → Quiver.Hom (X a) B\ninst✝¹ : CategoryTheory.EffectiveEpiFamily X π\nF : CategoryTheory.Functor C D\ninst✝ : F.IsEquivalence\n⊢ CategoryTheory.EffectiveEpiFamily (fun a => F.obj (X a)) fun a => F.map (π a)","decl":"instance (F : C ⥤ D) [F.IsEquivalence] :\n    EffectiveEpiFamily (fun a ↦ F.obj (X a)) (fun a ↦ F.map (π a)) :=\n  ⟨⟨effectiveEpiFamilyStructOfEquivalence F.asEquivalence _ _⟩⟩\n\n"}
{"name":"CategoryTheory.Functor.PreservesEffectiveEpis.preserves","module":"Mathlib.CategoryTheory.EffectiveEpi.Preserves","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\nself : F.PreservesEffectiveEpis\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.EffectiveEpi f\n⊢ CategoryTheory.EffectiveEpi (F.map f)","decl":"/--\nA class describing the property of preserving effective epimorphisms.\n-/\nclass PreservesEffectiveEpis (F : C ⥤ D) : Prop where\n  /--\n  A functor preserves effective epimorphisms if it maps effective\n  epimorphisms to effective epimorphisms.\n  -/\n  preserves : ∀ {X Y : C} (f : X ⟶ Y) [EffectiveEpi f], EffectiveEpi (F.map f)\n\n"}
{"name":"CategoryTheory.Functor.map_effectiveEpi","module":"Mathlib.CategoryTheory.EffectiveEpi.Preserves","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesEffectiveEpis\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.EffectiveEpi f\n⊢ CategoryTheory.EffectiveEpi (F.map f)","decl":"instance map_effectiveEpi (F : C ⥤ D) [F.PreservesEffectiveEpis] {X Y : C} (f : X ⟶ Y)\n    [EffectiveEpi f] : EffectiveEpi (F.map f) :=\n  PreservesEffectiveEpis.preserves f\n\n"}
{"name":"CategoryTheory.Functor.PreservesEffectiveEpiFamilies.preserves","module":"Mathlib.CategoryTheory.EffectiveEpi.Preserves","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\nself : F.PreservesEffectiveEpiFamilies\nα : Type u\nB : C\nX : α → C\nπ : (a : α) → Quiver.Hom (X a) B\ninst✝ : CategoryTheory.EffectiveEpiFamily X π\n⊢ CategoryTheory.EffectiveEpiFamily (fun a => F.obj (X a)) fun a => F.map (π a)","decl":"/--\nA class describing the property of preserving effective epimorphic families.\n-/\nclass PreservesEffectiveEpiFamilies (F : C ⥤ D) : Prop where\n  /--\n  A functor preserves effective epimorphic families if it maps effective epimorphic families to\n  effective epimorphic families.\n  -/\n  preserves : ∀ {α : Type u} {B : C} (X : α → C) (π : (a : α) → (X a ⟶ B)) [EffectiveEpiFamily X π],\n    EffectiveEpiFamily (fun a ↦ F.obj (X a)) (fun a  ↦ F.map (π a))\n\n"}
{"name":"CategoryTheory.Functor.map_effectiveEpiFamily","module":"Mathlib.CategoryTheory.EffectiveEpi.Preserves","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesEffectiveEpiFamilies\nα : Type u\nB : C\nX : α → C\nπ : (a : α) → Quiver.Hom (X a) B\ninst✝ : CategoryTheory.EffectiveEpiFamily X π\n⊢ CategoryTheory.EffectiveEpiFamily (fun a => F.obj (X a)) fun a => F.map (π a)","decl":"instance map_effectiveEpiFamily (F : C ⥤ D) [PreservesEffectiveEpiFamilies.{u} F]\n    {α : Type u} {B : C} (X : α → C) (π : (a : α) → (X a ⟶ B)) [EffectiveEpiFamily X π] :\n    EffectiveEpiFamily (fun a ↦ F.obj (X a)) (fun a  ↦ F.map (π a)) :=\n  PreservesEffectiveEpiFamilies.preserves X π\n\n"}
{"name":"CategoryTheory.Functor.PreservesFiniteEffectiveEpiFamilies.preserves","module":"Mathlib.CategoryTheory.EffectiveEpi.Preserves","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\nself : F.PreservesFiniteEffectiveEpiFamilies\nα : Type\ninst✝¹ : Finite α\nB : C\nX : α → C\nπ : (a : α) → Quiver.Hom (X a) B\ninst✝ : CategoryTheory.EffectiveEpiFamily X π\n⊢ CategoryTheory.EffectiveEpiFamily (fun a => F.obj (X a)) fun a => F.map (π a)","decl":"/--\nA class describing the property of preserving finite effective epimorphic families.\n-/\nclass PreservesFiniteEffectiveEpiFamilies (F : C ⥤ D) : Prop where\n  /--\n  A functor preserves finite effective epimorphic families if it maps finite effective epimorphic\n  families to effective epimorphic families.\n  -/\n  preserves : ∀ {α : Type} [Finite α] {B : C} (X : α → C) (π : (a : α) → (X a ⟶ B))\n    [EffectiveEpiFamily X π],\n    EffectiveEpiFamily (fun a ↦ F.obj (X a)) (fun a  ↦ F.map (π a))\n\n"}
{"name":"CategoryTheory.Functor.map_finite_effectiveEpiFamily","module":"Mathlib.CategoryTheory.EffectiveEpi.Preserves","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesFiniteEffectiveEpiFamilies\nα : Type\ninst✝¹ : Finite α\nB : C\nX : α → C\nπ : (a : α) → Quiver.Hom (X a) B\ninst✝ : CategoryTheory.EffectiveEpiFamily X π\n⊢ CategoryTheory.EffectiveEpiFamily (fun a => F.obj (X a)) fun a => F.map (π a)","decl":"instance map_finite_effectiveEpiFamily (F : C ⥤ D) [F.PreservesFiniteEffectiveEpiFamilies]\n    {α : Type} [Finite α] {B : C} (X : α → C) (π : (a : α) → (X a ⟶ B)) [EffectiveEpiFamily X π] :\n    EffectiveEpiFamily (fun a ↦ F.obj (X a)) (fun a  ↦ F.map (π a)) :=\n  PreservesFiniteEffectiveEpiFamilies.preserves X π\n\n"}
{"name":"CategoryTheory.Functor.instPreservesFiniteEffectiveEpiFamiliesOfPreservesEffectiveEpiFamilies","module":"Mathlib.CategoryTheory.EffectiveEpi.Preserves","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\ninst✝ : F.PreservesEffectiveEpiFamilies\n⊢ F.PreservesFiniteEffectiveEpiFamilies","decl":"instance (F : C ⥤ D) [PreservesEffectiveEpiFamilies.{0} F] :\n    PreservesFiniteEffectiveEpiFamilies F where\n  preserves _ _ := inferInstance\n\n"}
{"name":"CategoryTheory.Functor.instPreservesEffectiveEpisOfPreservesFiniteEffectiveEpiFamilies","module":"Mathlib.CategoryTheory.EffectiveEpi.Preserves","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\ninst✝ : F.PreservesFiniteEffectiveEpiFamilies\n⊢ F.PreservesEffectiveEpis","decl":"instance (F : C ⥤ D) [PreservesFiniteEffectiveEpiFamilies F] : PreservesEffectiveEpis F where\n  preserves _ := inferInstance\n\n"}
{"name":"CategoryTheory.Functor.instPreservesEffectiveEpiFamiliesOfIsEquivalence","module":"Mathlib.CategoryTheory.EffectiveEpi.Preserves","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\ninst✝ : F.IsEquivalence\n⊢ F.PreservesEffectiveEpiFamilies","decl":"instance (F : C ⥤ D) [IsEquivalence F] : F.PreservesEffectiveEpiFamilies where\n  preserves _ _ := inferInstance\n\n"}
{"name":"CategoryTheory.Functor.ReflectsEffectiveEpis.reflects","module":"Mathlib.CategoryTheory.EffectiveEpi.Preserves","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst✝ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\nself : F.ReflectsEffectiveEpis\nX Y : C\nf : Quiver.Hom X Y\na✝ : CategoryTheory.EffectiveEpi (F.map f)\n⊢ CategoryTheory.EffectiveEpi f","decl":"/--\nA class describing the property of reflecting effective epimorphisms.\n-/\nclass ReflectsEffectiveEpis (F : C ⥤ D) : Prop where\n  /--\n  A functor reflects effective epimorphisms if morphisms that are mapped to epimorphisms are\n  themselves effective epimorphisms.\n  -/\n  reflects : ∀ {X Y : C} (f : X ⟶ Y), EffectiveEpi (F.map f) → EffectiveEpi f\n\n"}
{"name":"CategoryTheory.Functor.effectiveEpi_of_map","module":"Mathlib.CategoryTheory.EffectiveEpi.Preserves","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\ninst✝ : F.ReflectsEffectiveEpis\nX Y : C\nf : Quiver.Hom X Y\nh : CategoryTheory.EffectiveEpi (F.map f)\n⊢ CategoryTheory.EffectiveEpi f","decl":"lemma effectiveEpi_of_map (F : C ⥤ D) [F.ReflectsEffectiveEpis] {X Y : C} (f : X ⟶ Y)\n    (h : EffectiveEpi (F.map f)) : EffectiveEpi f :=\n  ReflectsEffectiveEpis.reflects f h\n\n"}
{"name":"CategoryTheory.Functor.ReflectsEffectiveEpiFamilies.reflects","module":"Mathlib.CategoryTheory.EffectiveEpi.Preserves","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst✝ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\nself : F.ReflectsEffectiveEpiFamilies\nα : Type u\nB : C\nX : α → C\nπ : (a : α) → Quiver.Hom (X a) B\na✝ : CategoryTheory.EffectiveEpiFamily (fun a => F.obj (X a)) fun a => F.map (π a)\n⊢ CategoryTheory.EffectiveEpiFamily X π","decl":"/--\nA class describing the property of reflecting effective epimorphic families.\n-/\nclass ReflectsEffectiveEpiFamilies (F : C ⥤ D) : Prop where\n  /--\n  A functor reflects effective epimorphic families if families that are mapped to effective\n  epimorphic families are themselves effective epimorphic families.\n  -/\n  reflects : ∀ {α : Type u} {B : C} (X : α → C) (π : (a : α) → (X a ⟶ B)),\n    EffectiveEpiFamily (fun a ↦ F.obj (X a)) (fun a  ↦ F.map (π a)) →\n    EffectiveEpiFamily X π\n\n"}
{"name":"CategoryTheory.Functor.effectiveEpiFamily_of_map","module":"Mathlib.CategoryTheory.EffectiveEpi.Preserves","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\ninst✝ : F.ReflectsEffectiveEpiFamilies\nα : Type u\nB : C\nX : α → C\nπ : (a : α) → Quiver.Hom (X a) B\nh : CategoryTheory.EffectiveEpiFamily (fun a => F.obj (X a)) fun a => F.map (π a)\n⊢ CategoryTheory.EffectiveEpiFamily X π","decl":"lemma effectiveEpiFamily_of_map (F : C ⥤ D) [ReflectsEffectiveEpiFamilies.{u} F]\n    {α : Type u} {B : C} (X : α → C) (π : (a : α) → (X a ⟶ B))\n    (h : EffectiveEpiFamily (fun a ↦ F.obj (X a)) (fun a  ↦ F.map (π a))) :\n    EffectiveEpiFamily X π :=\n  ReflectsEffectiveEpiFamilies.reflects X π h\n\n"}
{"name":"CategoryTheory.Functor.ReflectsFiniteEffectiveEpiFamilies.reflects","module":"Mathlib.CategoryTheory.EffectiveEpi.Preserves","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\nself : F.ReflectsFiniteEffectiveEpiFamilies\nα : Type\ninst✝ : Finite α\nB : C\nX : α → C\nπ : (a : α) → Quiver.Hom (X a) B\na✝ : CategoryTheory.EffectiveEpiFamily (fun a => F.obj (X a)) fun a => F.map (π a)\n⊢ CategoryTheory.EffectiveEpiFamily X π","decl":"/--\nA class describing the property of reflecting finite effective epimorphic families.\n-/\nclass ReflectsFiniteEffectiveEpiFamilies (F : C ⥤ D) : Prop where\n  /--\n  A functor reflects finite effective epimorphic families if finite families that are\n  mapped to effective epimorphic families are themselves effective epimorphic families.\n  -/\n  reflects : ∀ {α : Type} [Finite α] {B : C} (X : α → C) (π : (a : α) → (X a ⟶ B)),\n    EffectiveEpiFamily (fun a ↦ F.obj (X a)) (fun a  ↦ F.map (π a)) →\n    EffectiveEpiFamily X π\n\n"}
{"name":"CategoryTheory.Functor.finite_effectiveEpiFamily_of_map","module":"Mathlib.CategoryTheory.EffectiveEpi.Preserves","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.ReflectsFiniteEffectiveEpiFamilies\nα : Type\ninst✝ : Finite α\nB : C\nX : α → C\nπ : (a : α) → Quiver.Hom (X a) B\nh : CategoryTheory.EffectiveEpiFamily (fun a => F.obj (X a)) fun a => F.map (π a)\n⊢ CategoryTheory.EffectiveEpiFamily X π","decl":"lemma finite_effectiveEpiFamily_of_map (F : C ⥤ D) [ReflectsFiniteEffectiveEpiFamilies F]\n    {α : Type} [Finite α] {B : C} (X : α → C) (π : (a : α) → (X a ⟶ B))\n    (h : EffectiveEpiFamily (fun a ↦ F.obj (X a)) (fun a  ↦ F.map (π a))) :\n    EffectiveEpiFamily X π :=\n  ReflectsFiniteEffectiveEpiFamilies.reflects X π h\n\n"}
{"name":"CategoryTheory.Functor.instReflectsFiniteEffectiveEpiFamiliesOfReflectsEffectiveEpiFamilies","module":"Mathlib.CategoryTheory.EffectiveEpi.Preserves","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\ninst✝ : F.ReflectsEffectiveEpiFamilies\n⊢ F.ReflectsFiniteEffectiveEpiFamilies","decl":"instance (F : C ⥤ D) [ReflectsEffectiveEpiFamilies.{0} F] :\n    ReflectsFiniteEffectiveEpiFamilies F where\n  reflects _ _ h := by\n    have := F.effectiveEpiFamily_of_map _ _ h\n    infer_instance\n\n"}
{"name":"CategoryTheory.Functor.instReflectsEffectiveEpisOfReflectsFiniteEffectiveEpiFamilies","module":"Mathlib.CategoryTheory.EffectiveEpi.Preserves","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\ninst✝ : F.ReflectsFiniteEffectiveEpiFamilies\n⊢ F.ReflectsEffectiveEpis","decl":"instance (F : C ⥤ D) [ReflectsFiniteEffectiveEpiFamilies F] : ReflectsEffectiveEpis F where\n  reflects _ h := by\n    rw [effectiveEpi_iff_effectiveEpiFamily] at h\n    have := F.finite_effectiveEpiFamily_of_map _ _ h\n    infer_instance\n\n"}
{"name":"CategoryTheory.Functor.instPreservesEffectiveEpiFamiliesOfIsEquivalence_1","module":"Mathlib.CategoryTheory.EffectiveEpi.Preserves","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\ninst✝ : F.IsEquivalence\n⊢ F.PreservesEffectiveEpiFamilies","decl":"instance (F : C ⥤ D) [IsEquivalence F] : F.PreservesEffectiveEpiFamilies where\n  preserves _ _ := inferInstance\n\n"}
{"name":"CategoryTheory.Functor.instReflectsEffectiveEpiFamiliesOfIsEquivalence","module":"Mathlib.CategoryTheory.EffectiveEpi.Preserves","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\ninst✝ : F.IsEquivalence\n⊢ F.ReflectsEffectiveEpiFamilies","decl":"instance (F : C ⥤ D) [IsEquivalence F] : F.ReflectsEffectiveEpiFamilies where\n  reflects {α B} X π _ := by\n    let i : (a : α) → X a ⟶ (inv F).obj (F.obj (X a)) := fun a ↦ (asEquivalence F).unit.app _\n    have : EffectiveEpiFamily X (fun a ↦ (i a) ≫ (inv F).map (F.map (π a))) := inferInstance\n    simp only [inv_fun_map, Iso.hom_inv_id_app_assoc, i] at this\n    have : EffectiveEpiFamily X (fun a ↦ (π a ≫ (asEquivalence F).unit.app B) ≫\n        (asEquivalence F).unitInv.app _) := inferInstance\n    simpa\n\n"}
