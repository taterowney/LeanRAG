{"name":"CategoryTheory.Adjunction.right_adjoint_additive","module":"Mathlib.CategoryTheory.Adjunction.Additive","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝ : F.Additive\n⊢ G.Additive","decl":"lemma right_adjoint_additive [F.Additive] : G.Additive where\n  map_add {X Y} f g := (adj.homEquiv _ _).symm.injective (by simp [homEquiv_counit])\n\n"}
{"name":"CategoryTheory.Adjunction.left_adjoint_additive","module":"Mathlib.CategoryTheory.Adjunction.Additive","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝ : G.Additive\n⊢ F.Additive","decl":"lemma left_adjoint_additive [G.Additive] : F.Additive where\n  map_add {X Y} f g := (adj.homEquiv _ _).injective (by simp [homEquiv_unit])\n\n"}
{"name":"CategoryTheory.Adjunction.homAddEquiv_apply","module":"Mathlib.CategoryTheory.Adjunction.Additive","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝ : F.Additive\nX : C\nY : D\nf : Quiver.Hom (F.obj X) Y\n⊢ Eq ((adj.homAddEquiv X Y) f) ((adj.homEquiv X Y) f)","decl":"@[simp]\nlemma homAddEquiv_apply (X : C) (Y : D) (f : F.obj X ⟶ Y) :\n    adj.homAddEquiv X Y f = adj.homEquiv X Y f := rfl\n\n"}
{"name":"CategoryTheory.Adjunction.homAddEquiv_symm_apply","module":"Mathlib.CategoryTheory.Adjunction.Additive","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝ : F.Additive\nX : C\nY : D\nf : Quiver.Hom X (G.obj Y)\n⊢ Eq ((adj.homAddEquiv X Y).symm f) ((adj.homEquiv X Y).symm f)","decl":"@[simp]\nlemma homAddEquiv_symm_apply (X : C) (Y : D) (f : X ⟶ G.obj Y) :\n    (adj.homAddEquiv X Y).symm f = (adj.homEquiv X Y).symm f := rfl\n\n"}
{"name":"CategoryTheory.Adjunction.homAddEquiv_zero","module":"Mathlib.CategoryTheory.Adjunction.Additive","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝ : F.Additive\nX : C\nY : D\n⊢ Eq ((adj.homEquiv X Y) 0) 0","decl":"@[simp]\nlemma homAddEquiv_zero (X : C) (Y : D) : adj.homEquiv X Y 0 = 0 := map_zero (adj.homAddEquiv X Y)\n\n"}
{"name":"CategoryTheory.Adjunction.homAddEquiv_add","module":"Mathlib.CategoryTheory.Adjunction.Additive","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝ : F.Additive\nX : C\nY : D\nf f' : Quiver.Hom (F.obj X) Y\n⊢ Eq ((adj.homEquiv X Y) (HAdd.hAdd f f')) (HAdd.hAdd ((adj.homEquiv X Y) f) ((adj.homEquiv X Y) f'))","decl":"@[simp]\nlemma homAddEquiv_add (X : C) (Y : D) (f f' : F.obj X ⟶ Y) :\n    adj.homEquiv X Y (f + f') = adj.homEquiv X Y f + adj.homEquiv X Y f' :=\n  map_add (adj.homAddEquiv X Y) _ _\n\n"}
{"name":"CategoryTheory.Adjunction.homAddEquiv_sub","module":"Mathlib.CategoryTheory.Adjunction.Additive","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝ : F.Additive\nX : C\nY : D\nf f' : Quiver.Hom (F.obj X) Y\n⊢ Eq ((adj.homEquiv X Y) (HSub.hSub f f')) (HSub.hSub ((adj.homEquiv X Y) f) ((adj.homEquiv X Y) f'))","decl":"@[simp]\nlemma homAddEquiv_sub (X : C) (Y : D) (f f' : F.obj X ⟶ Y) :\n    adj.homEquiv X Y (f - f') = adj.homEquiv X Y f - adj.homEquiv X Y f' :=\n  map_sub (adj.homAddEquiv X Y) _ _\n\n"}
{"name":"CategoryTheory.Adjunction.homAddEquiv_neg","module":"Mathlib.CategoryTheory.Adjunction.Additive","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝ : F.Additive\nX : C\nY : D\nf : Quiver.Hom (F.obj X) Y\n⊢ Eq ((adj.homEquiv X Y) (Neg.neg f)) (Neg.neg ((adj.homEquiv X Y) f))","decl":"@[simp]\nlemma homAddEquiv_neg (X : C) (Y : D) (f : F.obj X ⟶ Y) :\n    adj.homEquiv X Y (- f) = - adj.homEquiv X Y f := map_neg (adj.homAddEquiv X Y) _\n\n"}
{"name":"CategoryTheory.Adjunction.homAddEquiv_symm_zero","module":"Mathlib.CategoryTheory.Adjunction.Additive","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝ : F.Additive\nX : C\nY : D\n⊢ Eq ((adj.homEquiv X Y).symm 0) 0","decl":"@[simp]\nlemma homAddEquiv_symm_zero (X : C) (Y : D) :\n    (adj.homEquiv X Y).symm 0 = 0 := map_zero (adj.homAddEquiv X Y).symm\n\n"}
{"name":"CategoryTheory.Adjunction.homAddEquiv_symm_add","module":"Mathlib.CategoryTheory.Adjunction.Additive","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝ : F.Additive\nX : C\nY : D\nf f' : Quiver.Hom X (G.obj Y)\n⊢ Eq ((adj.homEquiv X Y).symm (HAdd.hAdd f f')) (HAdd.hAdd ((adj.homEquiv X Y).symm f) ((adj.homEquiv X Y).symm f'))","decl":"@[simp]\nlemma homAddEquiv_symm_add (X : C) (Y : D) (f f' : X ⟶ G.obj Y) :\n    (adj.homEquiv X Y).symm (f + f') = (adj.homEquiv X Y).symm f + (adj.homEquiv X Y).symm f' :=\n  map_add (adj.homAddEquiv X Y).symm _ _\n\n"}
{"name":"CategoryTheory.Adjunction.homAddEquiv_symm_sub","module":"Mathlib.CategoryTheory.Adjunction.Additive","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝ : F.Additive\nX : C\nY : D\nf f' : Quiver.Hom X (G.obj Y)\n⊢ Eq ((adj.homEquiv X Y).symm (HSub.hSub f f')) (HSub.hSub ((adj.homEquiv X Y).symm f) ((adj.homEquiv X Y).symm f'))","decl":"@[simp]\nlemma homAddEquiv_symm_sub (X : C) (Y : D) (f f' : X ⟶ G.obj Y) :\n    (adj.homEquiv X Y).symm (f - f') = (adj.homEquiv X Y).symm f - (adj.homEquiv X Y).symm f' :=\n  map_sub (adj.homAddEquiv X Y).symm _ _\n\n"}
{"name":"CategoryTheory.Adjunction.homAddEquiv_symm_neg","module":"Mathlib.CategoryTheory.Adjunction.Additive","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝ : F.Additive\nX : C\nY : D\nf : Quiver.Hom X (G.obj Y)\n⊢ Eq ((adj.homEquiv X Y).symm (Neg.neg f)) (Neg.neg ((adj.homEquiv X Y).symm f))","decl":"@[simp]\nlemma homAddEquiv_symm_neg (X : C) (Y : D) (f : X ⟶ G.obj Y) :\n    (adj.homEquiv X Y).symm (- f) = - (adj.homEquiv X Y).symm f :=\n  map_neg (adj.homAddEquiv X Y).symm _\n\n"}
{"name":"CategoryTheory.Adjunction.compPreadditiveYonedaIso_hom_app_app_apply","module":"Mathlib.CategoryTheory.Adjunction.Additive","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝ : F.Additive\nX : Opposite C\nY : D\na : ULift.{max v₁ v₂, v₁} (Quiver.Hom (Opposite.unop X) (G.obj Y))\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom ((adj.compPreadditiveYonedaIso.hom.app Y).app X)) a) { down := (adj.homEquiv (Opposite.unop X) Y).symm (AddEquiv.ulift a) }","decl":"lemma compPreadditiveYonedaIso_hom_app_app_apply (X : Cᵒᵖ) (Y : D)\n    (a : ULift.{max v₁ v₂, v₁} (Opposite.unop X ⟶ G.obj Y)) :\n      ((adj.compPreadditiveYonedaIso.hom.app Y).app X) a =\n        ULift.up ((adj.homEquiv (Opposite.unop X) Y).symm (AddEquiv.ulift a)) := rfl\n\n"}
{"name":"CategoryTheory.Adjunction.compPreadditiveYonedaIso_inv_app_app_apply","module":"Mathlib.CategoryTheory.Adjunction.Additive","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝ : F.Additive\nX : Opposite C\nY : D\na : ULift.{max v₁ v₂, v₂} (Quiver.Hom (F.obj (Opposite.unop X)) Y)\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom ((adj.compPreadditiveYonedaIso.inv.app Y).app X)) a) { down := (adj.homEquiv (Opposite.unop X) Y) (AddEquiv.ulift a) }","decl":"lemma compPreadditiveYonedaIso_inv_app_app_apply (X : Cᵒᵖ) (Y : D)\n    (a : ULift.{max v₁ v₂, v₂} (F.obj (Opposite.unop X) ⟶ Y)) :\n      ((adj.compPreadditiveYonedaIso.inv.app Y).app X) a =\n        ULift.up ((adj.homEquiv (Opposite.unop X) Y) (AddEquiv.ulift a)) := rfl\n\n"}
