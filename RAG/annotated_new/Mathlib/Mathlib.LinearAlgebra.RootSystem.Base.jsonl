{"name":"RootPairing.Base.linInd_coroot","module":"Mathlib.LinearAlgebra.RootSystem.Base","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nself : P.Base\n⊢ LinearIndependent R fun i => P.coroot ↑i","decl":"/-- A base of a root pairing.\n\nFor reduced root pairings this definition is equivalent to the usual definition appearing in the\ninformal literature but not for non-reduced root pairings it is more restrictive. See the module\ndoc string for further remarks.  -/\nstructure Base (P : RootPairing ι R M N) where\n  /-- The set of roots / coroots belonging to the base. -/\n  support : Set ι\n  linInd_root : LinearIndependent R fun i : support ↦ P.root i\n  linInd_coroot : LinearIndependent R fun i : support ↦ P.coroot i\n  root_mem_or_neg_mem (i : ι) : P.root i ∈ AddSubmonoid.closure (P.root '' support) ∨\n                              - P.root i ∈ AddSubmonoid.closure (P.root '' support)\n  coroot_mem_or_neg_mem (i : ι) : P.coroot i ∈ AddSubmonoid.closure (P.coroot '' support) ∨\n                                - P.coroot i ∈ AddSubmonoid.closure (P.coroot '' support)\n\n"}
{"name":"RootPairing.Base.linInd_root","module":"Mathlib.LinearAlgebra.RootSystem.Base","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nself : P.Base\n⊢ LinearIndependent R fun i => P.root ↑i","decl":"/-- A base of a root pairing.\n\nFor reduced root pairings this definition is equivalent to the usual definition appearing in the\ninformal literature but not for non-reduced root pairings it is more restrictive. See the module\ndoc string for further remarks.  -/\nstructure Base (P : RootPairing ι R M N) where\n  /-- The set of roots / coroots belonging to the base. -/\n  support : Set ι\n  linInd_root : LinearIndependent R fun i : support ↦ P.root i\n  linInd_coroot : LinearIndependent R fun i : support ↦ P.coroot i\n  root_mem_or_neg_mem (i : ι) : P.root i ∈ AddSubmonoid.closure (P.root '' support) ∨\n                              - P.root i ∈ AddSubmonoid.closure (P.root '' support)\n  coroot_mem_or_neg_mem (i : ι) : P.coroot i ∈ AddSubmonoid.closure (P.coroot '' support) ∨\n                                - P.coroot i ∈ AddSubmonoid.closure (P.coroot '' support)\n\n"}
{"name":"RootPairing.Base.coroot_mem_or_neg_mem","module":"Mathlib.LinearAlgebra.RootSystem.Base","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nself : P.Base\ni : ι\n⊢ Or (Membership.mem (AddSubmonoid.closure (Set.image (⇑P.coroot) self.support)) (P.coroot i)) (Membership.mem (AddSubmonoid.closure (Set.image (⇑P.coroot) self.support)) (Neg.neg (P.coroot i)))","decl":"/-- A base of a root pairing.\n\nFor reduced root pairings this definition is equivalent to the usual definition appearing in the\ninformal literature but not for non-reduced root pairings it is more restrictive. See the module\ndoc string for further remarks.  -/\nstructure Base (P : RootPairing ι R M N) where\n  /-- The set of roots / coroots belonging to the base. -/\n  support : Set ι\n  linInd_root : LinearIndependent R fun i : support ↦ P.root i\n  linInd_coroot : LinearIndependent R fun i : support ↦ P.coroot i\n  root_mem_or_neg_mem (i : ι) : P.root i ∈ AddSubmonoid.closure (P.root '' support) ∨\n                              - P.root i ∈ AddSubmonoid.closure (P.root '' support)\n  coroot_mem_or_neg_mem (i : ι) : P.coroot i ∈ AddSubmonoid.closure (P.coroot '' support) ∨\n                                - P.coroot i ∈ AddSubmonoid.closure (P.coroot '' support)\n\n"}
{"name":"RootPairing.Base.mk.injEq","module":"Mathlib.LinearAlgebra.RootSystem.Base","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nsupport✝ : Set ι\nlinInd_root✝ : LinearIndependent R fun i => P.root ↑i\nlinInd_coroot✝ : LinearIndependent R fun i => P.coroot ↑i\nroot_mem_or_neg_mem✝ : ∀ (i : ι), Or (Membership.mem (AddSubmonoid.closure (Set.image (⇑P.root) support✝)) (P.root i)) (Membership.mem (AddSubmonoid.closure (Set.image (⇑P.root) support✝)) (Neg.neg (P.root i)))\ncoroot_mem_or_neg_mem✝ : ∀ (i : ι), Or (Membership.mem (AddSubmonoid.closure (Set.image (⇑P.coroot) support✝)) (P.coroot i)) (Membership.mem (AddSubmonoid.closure (Set.image (⇑P.coroot) support✝)) (Neg.neg (P.coroot i)))\nsupport : Set ι\nlinInd_root : LinearIndependent R fun i => P.root ↑i\nlinInd_coroot : LinearIndependent R fun i => P.coroot ↑i\nroot_mem_or_neg_mem : ∀ (i : ι), Or (Membership.mem (AddSubmonoid.closure (Set.image (⇑P.root) support)) (P.root i)) (Membership.mem (AddSubmonoid.closure (Set.image (⇑P.root) support)) (Neg.neg (P.root i)))\ncoroot_mem_or_neg_mem : ∀ (i : ι), Or (Membership.mem (AddSubmonoid.closure (Set.image (⇑P.coroot) support)) (P.coroot i)) (Membership.mem (AddSubmonoid.closure (Set.image (⇑P.coroot) support)) (Neg.neg (P.coroot i)))\n⊢ Eq (Eq { support := support✝, linInd_root := linInd_root✝, linInd_coroot := linInd_coroot✝, root_mem_or_neg_mem := root_mem_or_neg_mem✝, coroot_mem_or_neg_mem := coroot_mem_or_neg_mem✝ } { support := support, linInd_root := linInd_root, linInd_coroot := linInd_coroot, root_mem_or_neg_mem := root_mem_or_neg_mem, coroot_mem_or_neg_mem := coroot_mem_or_neg_mem }) (Eq support✝ support)","decl":"/-- A base of a root pairing.\n\nFor reduced root pairings this definition is equivalent to the usual definition appearing in the\ninformal literature but not for non-reduced root pairings it is more restrictive. See the module\ndoc string for further remarks.  -/\nstructure Base (P : RootPairing ι R M N) where\n  /-- The set of roots / coroots belonging to the base. -/\n  support : Set ι\n  linInd_root : LinearIndependent R fun i : support ↦ P.root i\n  linInd_coroot : LinearIndependent R fun i : support ↦ P.coroot i\n  root_mem_or_neg_mem (i : ι) : P.root i ∈ AddSubmonoid.closure (P.root '' support) ∨\n                              - P.root i ∈ AddSubmonoid.closure (P.root '' support)\n  coroot_mem_or_neg_mem (i : ι) : P.coroot i ∈ AddSubmonoid.closure (P.coroot '' support) ∨\n                                - P.coroot i ∈ AddSubmonoid.closure (P.coroot '' support)\n\n"}
{"name":"RootPairing.Base.mk.sizeOf_spec","module":"Mathlib.LinearAlgebra.RootSystem.Base","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nP : RootPairing ι R M N\ninst✝³ : SizeOf ι\ninst✝² : SizeOf R\ninst✝¹ : SizeOf M\ninst✝ : SizeOf N\nsupport : Set ι\nlinInd_root : LinearIndependent R fun i => P.root ↑i\nlinInd_coroot : LinearIndependent R fun i => P.coroot ↑i\nroot_mem_or_neg_mem : ∀ (i : ι), Or (Membership.mem (AddSubmonoid.closure (Set.image (⇑P.root) support)) (P.root i)) (Membership.mem (AddSubmonoid.closure (Set.image (⇑P.root) support)) (Neg.neg (P.root i)))\ncoroot_mem_or_neg_mem : ∀ (i : ι), Or (Membership.mem (AddSubmonoid.closure (Set.image (⇑P.coroot) support)) (P.coroot i)) (Membership.mem (AddSubmonoid.closure (Set.image (⇑P.coroot) support)) (Neg.neg (P.coroot i)))\n⊢ Eq (SizeOf.sizeOf { support := support, linInd_root := linInd_root, linInd_coroot := linInd_coroot, root_mem_or_neg_mem := root_mem_or_neg_mem, coroot_mem_or_neg_mem := coroot_mem_or_neg_mem }) 1","decl":"/-- A base of a root pairing.\n\nFor reduced root pairings this definition is equivalent to the usual definition appearing in the\ninformal literature but not for non-reduced root pairings it is more restrictive. See the module\ndoc string for further remarks.  -/\nstructure Base (P : RootPairing ι R M N) where\n  /-- The set of roots / coroots belonging to the base. -/\n  support : Set ι\n  linInd_root : LinearIndependent R fun i : support ↦ P.root i\n  linInd_coroot : LinearIndependent R fun i : support ↦ P.coroot i\n  root_mem_or_neg_mem (i : ι) : P.root i ∈ AddSubmonoid.closure (P.root '' support) ∨\n                              - P.root i ∈ AddSubmonoid.closure (P.root '' support)\n  coroot_mem_or_neg_mem (i : ι) : P.coroot i ∈ AddSubmonoid.closure (P.coroot '' support) ∨\n                                - P.coroot i ∈ AddSubmonoid.closure (P.coroot '' support)\n\n"}
{"name":"RootPairing.Base.root_mem_or_neg_mem","module":"Mathlib.LinearAlgebra.RootSystem.Base","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nself : P.Base\ni : ι\n⊢ Or (Membership.mem (AddSubmonoid.closure (Set.image (⇑P.root) self.support)) (P.root i)) (Membership.mem (AddSubmonoid.closure (Set.image (⇑P.root) self.support)) (Neg.neg (P.root i)))","decl":"/-- A base of a root pairing.\n\nFor reduced root pairings this definition is equivalent to the usual definition appearing in the\ninformal literature but not for non-reduced root pairings it is more restrictive. See the module\ndoc string for further remarks.  -/\nstructure Base (P : RootPairing ι R M N) where\n  /-- The set of roots / coroots belonging to the base. -/\n  support : Set ι\n  linInd_root : LinearIndependent R fun i : support ↦ P.root i\n  linInd_coroot : LinearIndependent R fun i : support ↦ P.coroot i\n  root_mem_or_neg_mem (i : ι) : P.root i ∈ AddSubmonoid.closure (P.root '' support) ∨\n                              - P.root i ∈ AddSubmonoid.closure (P.root '' support)\n  coroot_mem_or_neg_mem (i : ι) : P.coroot i ∈ AddSubmonoid.closure (P.coroot '' support) ∨\n                                - P.coroot i ∈ AddSubmonoid.closure (P.coroot '' support)\n\n"}
{"name":"RootPairing.Base.mk.inj","module":"Mathlib.LinearAlgebra.RootSystem.Base","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nsupport✝ : Set ι\nlinInd_root✝ : LinearIndependent R fun i => P.root ↑i\nlinInd_coroot✝ : LinearIndependent R fun i => P.coroot ↑i\nroot_mem_or_neg_mem✝ : ∀ (i : ι), Or (Membership.mem (AddSubmonoid.closure (Set.image (⇑P.root) support✝)) (P.root i)) (Membership.mem (AddSubmonoid.closure (Set.image (⇑P.root) support✝)) (Neg.neg (P.root i)))\ncoroot_mem_or_neg_mem✝ : ∀ (i : ι), Or (Membership.mem (AddSubmonoid.closure (Set.image (⇑P.coroot) support✝)) (P.coroot i)) (Membership.mem (AddSubmonoid.closure (Set.image (⇑P.coroot) support✝)) (Neg.neg (P.coroot i)))\nsupport : Set ι\nlinInd_root : LinearIndependent R fun i => P.root ↑i\nlinInd_coroot : LinearIndependent R fun i => P.coroot ↑i\nroot_mem_or_neg_mem : ∀ (i : ι), Or (Membership.mem (AddSubmonoid.closure (Set.image (⇑P.root) support)) (P.root i)) (Membership.mem (AddSubmonoid.closure (Set.image (⇑P.root) support)) (Neg.neg (P.root i)))\ncoroot_mem_or_neg_mem : ∀ (i : ι), Or (Membership.mem (AddSubmonoid.closure (Set.image (⇑P.coroot) support)) (P.coroot i)) (Membership.mem (AddSubmonoid.closure (Set.image (⇑P.coroot) support)) (Neg.neg (P.coroot i)))\nx✝ : Eq { support := support✝, linInd_root := linInd_root✝, linInd_coroot := linInd_coroot✝, root_mem_or_neg_mem := root_mem_or_neg_mem✝, coroot_mem_or_neg_mem := coroot_mem_or_neg_mem✝ } { support := support, linInd_root := linInd_root, linInd_coroot := linInd_coroot, root_mem_or_neg_mem := root_mem_or_neg_mem, coroot_mem_or_neg_mem := coroot_mem_or_neg_mem }\n⊢ Eq support✝ support","decl":"/-- A base of a root pairing.\n\nFor reduced root pairings this definition is equivalent to the usual definition appearing in the\ninformal literature but not for non-reduced root pairings it is more restrictive. See the module\ndoc string for further remarks.  -/\nstructure Base (P : RootPairing ι R M N) where\n  /-- The set of roots / coroots belonging to the base. -/\n  support : Set ι\n  linInd_root : LinearIndependent R fun i : support ↦ P.root i\n  linInd_coroot : LinearIndependent R fun i : support ↦ P.coroot i\n  root_mem_or_neg_mem (i : ι) : P.root i ∈ AddSubmonoid.closure (P.root '' support) ∨\n                              - P.root i ∈ AddSubmonoid.closure (P.root '' support)\n  coroot_mem_or_neg_mem (i : ι) : P.coroot i ∈ AddSubmonoid.closure (P.coroot '' support) ∨\n                                - P.coroot i ∈ AddSubmonoid.closure (P.coroot '' support)\n\n"}
{"name":"RootPairing.Base.flip_support","module":"Mathlib.LinearAlgebra.RootSystem.Base","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nb : P.Base\n⊢ Eq b.flip.support b.support","decl":"/-- Interchanging roots and coroots, one still has a base of a root pairing. -/\n@[simps] protected def flip :\n    P.flip.Base where\n  support := b.support\n  linInd_root := b.linInd_coroot\n  linInd_coroot := b.linInd_root\n  root_mem_or_neg_mem := b.coroot_mem_or_neg_mem\n  coroot_mem_or_neg_mem := b.root_mem_or_neg_mem\n\n"}
{"name":"RootPairing.Base.root_mem_span_int","module":"Mathlib.LinearAlgebra.RootSystem.Base","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nb : P.Base\ni : ι\n⊢ Membership.mem (Submodule.span Int (Set.image (⇑P.root) b.support)) (P.root i)","decl":"lemma root_mem_span_int (i : ι) :\n    P.root i ∈ span ℤ (P.root '' b.support) := by\n  have := b.root_mem_or_neg_mem i\n  simp only [← span_nat_eq_addSubmonoid_closure, mem_toAddSubmonoid] at this\n  rw [← span_span_of_tower (R := ℕ)]\n  rcases this with hi | hi\n  · exact subset_span hi\n  · rw [← neg_mem_iff]\n    exact subset_span hi\n\n"}
{"name":"RootPairing.Base.coroot_mem_span_int","module":"Mathlib.LinearAlgebra.RootSystem.Base","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nb : P.Base\ni : ι\n⊢ Membership.mem (Submodule.span Int (Set.image (⇑P.coroot) b.support)) (P.coroot i)","decl":"lemma coroot_mem_span_int (i : ι) :\n    P.coroot i ∈ span ℤ (P.coroot '' b.support) :=\n  b.flip.root_mem_span_int i\n\n"}
{"name":"RootPairing.Base.span_int_root_support","module":"Mathlib.LinearAlgebra.RootSystem.Base","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nb : P.Base\n⊢ Eq (Submodule.span Int (Set.image (⇑P.root) b.support)) (Submodule.span Int (Set.range ⇑P.root))","decl":"@[simp]\nlemma span_int_root_support :\n    span ℤ (P.root '' b.support) = span ℤ (range P.root) := by\n  refine le_antisymm (span_mono <| image_subset_range _ _) (span_le.mpr ?_)\n  rintro - ⟨i, rfl⟩\n  exact b.root_mem_span_int i\n\n"}
{"name":"RootPairing.Base.span_int_coroot_support","module":"Mathlib.LinearAlgebra.RootSystem.Base","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nb : P.Base\n⊢ Eq (Submodule.span Int (Set.image (⇑P.coroot) b.support)) (Submodule.span Int (Set.range ⇑P.coroot))","decl":"@[simp]\nlemma span_int_coroot_support :\n    span ℤ (P.coroot '' b.support) = span ℤ (range P.coroot) :=\n  b.flip.span_int_root_support\n\n"}
{"name":"RootPairing.Base.span_root_support","module":"Mathlib.LinearAlgebra.RootSystem.Base","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nb : P.Base\n⊢ Eq (Submodule.span R (Set.image (⇑P.root) b.support)) P.rootSpan","decl":"@[simp]\nlemma span_root_support :\n    span R (P.root '' b.support) = P.rootSpan := by\n  rw [← span_span_of_tower (R := ℤ), span_int_root_support, span_span_of_tower]\n\n"}
{"name":"RootPairing.Base.span_coroot_support","module":"Mathlib.LinearAlgebra.RootSystem.Base","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootPairing ι R M N\nb : P.Base\n⊢ Eq (Submodule.span R (Set.image (⇑P.coroot) b.support)) P.corootSpan","decl":"@[simp]\nlemma span_coroot_support :\n    span R (P.coroot '' b.support) = P.corootSpan :=\n  b.flip.span_root_support\n\n"}
{"name":"RootPairing.Base.eq_one_or_neg_one_of_mem_support_of_smul_mem_aux","module":"Mathlib.LinearAlgebra.RootSystem.Base","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R N\nP : RootPairing ι R M N\nb : P.Base\ninst✝² : Finite ι\ninst✝¹ : NoZeroSMulDivisors Int M\ninst✝ : NoZeroSMulDivisors Int N\ni : ι\nh : Membership.mem b.support i\nt : R\nht : Membership.mem (Set.range ⇑P.root) (HSMul.hSMul t (P.root i))\n⊢ Exists fun z => Eq (HMul.hMul (↑z) t) 1","decl":"open Finsupp in\nlemma eq_one_or_neg_one_of_mem_support_of_smul_mem_aux [Finite ι]\n    [NoZeroSMulDivisors ℤ M] [NoZeroSMulDivisors ℤ N]\n    (i : ι) (h : i ∈ b.support) (t : R) (ht : t • P.root i ∈ range P.root) :\n    ∃ z : ℤ, z * t = 1 := by\n  classical\n  have : Fintype ι := Fintype.ofFinite ι\n  obtain ⟨j, hj⟩ := ht\n  obtain ⟨f, hf⟩ : ∃ f : b.support → ℤ, P.coroot i = ∑ i, (t * f i) • P.coroot i := by\n    have : P.coroot j ∈ span ℤ (P.coroot '' b.support) := b.coroot_mem_span_int j\n    rw [image_eq_range, mem_span_range_iff_exists_fun] at this\n    refine this.imp fun f hf ↦ ?_\n    simp_rw [mul_smul, ← Finset.smul_sum, Int.cast_smul_eq_zsmul, hf,\n      coroot_eq_smul_coroot_iff.mpr hj]\n  use f ⟨i, h⟩\n  replace hf : P.coroot i = linearCombination R (fun k : b.support ↦ P.coroot k)\n      (t • (linearEquivFunOnFinite R _ _).symm (fun x ↦ (f x : R))) := by\n    rw [map_smul, linearCombination_eq_fintype_linearCombination_apply R R,\n      Fintype.linearCombination_apply, hf]\n    simp_rw [mul_smul, ← Finset.smul_sum]\n  let g : b.support →₀ R := single ⟨i, h⟩ 1\n  have hg : P.coroot i = linearCombination R (fun k : b.support ↦ P.coroot k) g := by simp [g]\n  rw [hg] at hf\n  have : Injective (linearCombination R fun k : b.support ↦ P.coroot k) := b.linInd_coroot\n  simpa [g, linearEquivFunOnFinite, mul_comm t] using (DFunLike.congr_fun (this hf) ⟨i, h⟩).symm\n\n"}
{"name":"RootPairing.Base.eq_one_or_neg_one_of_mem_support_of_smul_mem","module":"Mathlib.LinearAlgebra.RootSystem.Base","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nP : RootPairing ι R M N\nb : P.Base\ninst✝³ : Finite ι\ninst✝² : CharZero R\ninst✝¹ : NoZeroSMulDivisors Int M\ninst✝ : NoZeroSMulDivisors Int N\ni : ι\nh : Membership.mem b.support i\nt : R\nht : Membership.mem (Set.range ⇑P.root) (HSMul.hSMul t (P.root i))\n⊢ Or (Eq t 1) (Eq t (-1))","decl":"lemma eq_one_or_neg_one_of_mem_support_of_smul_mem [Finite ι] [CharZero R]\n    [NoZeroSMulDivisors ℤ M] [NoZeroSMulDivisors ℤ N]\n    (i : ι) (h : i ∈ b.support) (t : R) (ht : t • P.root i ∈ range P.root) :\n    t = 1 ∨ t = - 1 := by\n  obtain ⟨z, hz⟩ := b.eq_one_or_neg_one_of_mem_support_of_smul_mem_aux i h t ht\n  obtain ⟨s, hs⟩ := IsUnit.exists_left_inv <| isUnit_of_mul_eq_one_right _ t hz\n  replace ht : s • P.coroot i ∈ range P.coroot := by\n    obtain ⟨j, hj⟩ := ht\n    simpa only [coroot_eq_smul_coroot_iff.mpr hj, smul_smul, hs, one_smul] using mem_range_self j\n  obtain ⟨w, hw⟩ := b.flip.eq_one_or_neg_one_of_mem_support_of_smul_mem_aux i h s ht\n  have : (z : R) * w = 1 := by\n    simpa [mul_mul_mul_comm _ t _ s, mul_comm t s, hs] using congr_arg₂ (· * ·) hz hw\n  suffices z = 1 ∨ z = - 1 by\n    rcases this with rfl | rfl\n    · left; simpa using hz\n    · right; simpa [neg_eq_iff_eq_neg] using hz\n  norm_cast at this\n  rw [Int.mul_eq_one_iff_eq_one_or_neg_one] at this\n  tauto\n\n"}
{"name":"RootPairing.Base.toWeightBasis_repr_apply","module":"Mathlib.LinearAlgebra.RootSystem.Base","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootSystem ι R M N\nb : P.Base\na✝ : M\n⊢ Eq (b.toWeightBasis.repr a✝) (⋯.repr ((LinearMap.codRestrict (Submodule.span R (Set.range fun i => P.root ↑i)) LinearMap.id ⋯) a✝))","decl":"/-- A base of a root system yields a basis of the root space. -/\n@[simps!] def toWeightBasis :\n    Basis b.support R M :=\n  Basis.mk b.linInd_root <| by\n    change ⊤ ≤ span R (range <| P.root ∘ ((↑) : b.support → ι))\n    rw [top_le_iff, range_comp, Subtype.range_coe_subtype, setOf_mem_eq, b.span_root_support]\n    exact P.span_root_eq_top\n\n"}
{"name":"RootPairing.Base.toWeightBasis_repr_symm_apply","module":"Mathlib.LinearAlgebra.RootSystem.Base","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : RootSystem ι R M N\nb : P.Base\na : Finsupp (↑b.support) R\n⊢ Eq (b.toWeightBasis.repr.symm a) ((Finsupp.linearCombination R fun i => P.root ↑i) a)","decl":"/-- A base of a root system yields a basis of the root space. -/\n@[simps!] def toWeightBasis :\n    Basis b.support R M :=\n  Basis.mk b.linInd_root <| by\n    change ⊤ ≤ span R (range <| P.root ∘ ((↑) : b.support → ι))\n    rw [top_le_iff, range_comp, Subtype.range_coe_subtype, setOf_mem_eq, b.span_root_support]\n    exact P.span_root_eq_top\n\n"}
{"name":"RootPairing.Base.exists_root_eq_sum_nat_or_neg","module":"Mathlib.LinearAlgebra.RootSystem.Base","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\nP : RootSystem ι R M N\nb : P.Base\ninst✝ : Fintype ι\ni : ι\n⊢ Exists fun f => Or (Eq (P.root i) (Finset.univ.sum fun j => HSMul.hSMul (f j) (P.root j))) (Eq (P.root i) (Neg.neg (Finset.univ.sum fun j => HSMul.hSMul (f j) (P.root j))))","decl":"lemma exists_root_eq_sum_nat_or_neg (i : ι) :\n    ∃ f : ι → ℕ, P.root i = ∑ j, f j • P.root j ∨ P.root i = - ∑ j, f j • P.root j := by\n  classical\n  simp_rw [← neg_eq_iff_eq_neg]\n  suffices ∀ m ∈ AddSubmonoid.closure (P.root '' b.support), ∃ f : ι → ℕ, m = ∑ j, f j • P.root j by\n    rcases b.root_mem_or_neg_mem i with hi | hi\n    · obtain ⟨f, hf⟩ := this _ hi\n      exact ⟨f, Or.inl hf⟩\n    · obtain ⟨f, hf⟩ := this _ hi\n      exact ⟨f, Or.inr hf⟩\n  intro m hm\n  refine AddSubmonoid.closure_induction ?_ ⟨0, by simp⟩ ?_ hm\n  · rintro - ⟨j, hj, rfl⟩\n    exact ⟨Pi.single j 1, by simp [Pi.single_apply]⟩\n  · intro _ _ _ _ ⟨f, hf⟩ ⟨g, hg⟩\n    exact ⟨f + g, by simp [hf, hg, add_smul, Finset.sum_add_distrib]⟩\n\n"}
{"name":"RootPairing.Base.exists_root_eq_sum_int","module":"Mathlib.LinearAlgebra.RootSystem.Base","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\nP : RootSystem ι R M N\nb : P.Base\ninst✝ : Fintype ι\ni : ι\n⊢ Exists fun f => And (Or (LE.le 0 f) (LE.le f 0)) (Eq (P.root i) (Finset.univ.sum fun j => HSMul.hSMul (f j) (P.root j)))","decl":"lemma exists_root_eq_sum_int (i : ι) :\n    ∃ f : ι → ℤ, (0 ≤ f ∨ f ≤ 0) ∧ P.root i = ∑ j, f j • P.root j := by\n  obtain ⟨f, hf | hf⟩ := b.exists_root_eq_sum_nat_or_neg i\n  · exact ⟨  Nat.cast ∘ f, Or.inl fun _ ↦ by simp, by simp [hf]⟩\n  · exact ⟨- Nat.cast ∘ f, Or.inr fun _ ↦ by simp, by simp [hf]⟩\n\n"}
{"name":"RootPairing.Base.exists_coroot_eq_sum_int","module":"Mathlib.LinearAlgebra.RootSystem.Base","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\nP : RootSystem ι R M N\nb : P.Base\ninst✝ : Fintype ι\ni : ι\n⊢ Exists fun f => And (Or (LE.le 0 f) (LE.le f 0)) (Eq (P.coroot i) (Finset.univ.sum fun j => HSMul.hSMul (f j) (P.coroot j)))","decl":"lemma exists_coroot_eq_sum_int (i : ι) :\n    ∃ f : ι → ℤ, (0 ≤ f ∨ f ≤ 0) ∧ P.coroot i = ∑ j, f j • P.coroot j :=\n  b.flip.exists_root_eq_sum_int i (P := P.flip)\n\n"}
