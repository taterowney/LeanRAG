{"name":"CategoryTheory.Limits.WalkingMulticospan.right.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"L : Type w\nR : Type w'\nfst snd : R → L\na✝¹ a✝ : R\n⊢ Eq (Eq (CategoryTheory.Limits.WalkingMulticospan.right a✝¹) (CategoryTheory.Limits.WalkingMulticospan.right a✝)) (Eq a✝¹ a✝)","decl":"/-- The type underlying the multiequalizer diagram. -/\n--@[nolint unused_arguments]\ninductive WalkingMulticospan {L : Type w} {R : Type w'} (fst snd : R → L) : Type max w w'\n  | left : L → WalkingMulticospan fst snd\n  | right : R → WalkingMulticospan fst snd\n\n"}
{"name":"CategoryTheory.Limits.WalkingMulticospan.left.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"L : Type w\nR : Type w'\nfst snd : R → L\ninst✝¹ : SizeOf L\ninst✝ : SizeOf R\na✝ : L\n⊢ Eq (SizeOf.sizeOf (CategoryTheory.Limits.WalkingMulticospan.left a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- The type underlying the multiequalizer diagram. -/\n--@[nolint unused_arguments]\ninductive WalkingMulticospan {L : Type w} {R : Type w'} (fst snd : R → L) : Type max w w'\n  | left : L → WalkingMulticospan fst snd\n  | right : R → WalkingMulticospan fst snd\n\n"}
{"name":"CategoryTheory.Limits.WalkingMulticospan.right.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"L : Type w\nR : Type w'\nfst snd : R → L\na✝¹ a✝ : R\nx✝ : Eq (CategoryTheory.Limits.WalkingMulticospan.right a✝¹) (CategoryTheory.Limits.WalkingMulticospan.right a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- The type underlying the multiequalizer diagram. -/\n--@[nolint unused_arguments]\ninductive WalkingMulticospan {L : Type w} {R : Type w'} (fst snd : R → L) : Type max w w'\n  | left : L → WalkingMulticospan fst snd\n  | right : R → WalkingMulticospan fst snd\n\n"}
{"name":"CategoryTheory.Limits.WalkingMulticospan.right.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"L : Type w\nR : Type w'\nfst snd : R → L\ninst✝¹ : SizeOf L\ninst✝ : SizeOf R\na✝ : R\n⊢ Eq (SizeOf.sizeOf (CategoryTheory.Limits.WalkingMulticospan.right a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- The type underlying the multiequalizer diagram. -/\n--@[nolint unused_arguments]\ninductive WalkingMulticospan {L : Type w} {R : Type w'} (fst snd : R → L) : Type max w w'\n  | left : L → WalkingMulticospan fst snd\n  | right : R → WalkingMulticospan fst snd\n\n"}
{"name":"CategoryTheory.Limits.WalkingMulticospan.left.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"L : Type w\nR : Type w'\nfst snd : R → L\na✝¹ a✝ : L\n⊢ Eq (Eq (CategoryTheory.Limits.WalkingMulticospan.left a✝¹) (CategoryTheory.Limits.WalkingMulticospan.left a✝)) (Eq a✝¹ a✝)","decl":"/-- The type underlying the multiequalizer diagram. -/\n--@[nolint unused_arguments]\ninductive WalkingMulticospan {L : Type w} {R : Type w'} (fst snd : R → L) : Type max w w'\n  | left : L → WalkingMulticospan fst snd\n  | right : R → WalkingMulticospan fst snd\n\n"}
{"name":"CategoryTheory.Limits.WalkingMulticospan.left.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"L : Type w\nR : Type w'\nfst snd : R → L\na✝¹ a✝ : L\nx✝ : Eq (CategoryTheory.Limits.WalkingMulticospan.left a✝¹) (CategoryTheory.Limits.WalkingMulticospan.left a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- The type underlying the multiequalizer diagram. -/\n--@[nolint unused_arguments]\ninductive WalkingMulticospan {L : Type w} {R : Type w'} (fst snd : R → L) : Type max w w'\n  | left : L → WalkingMulticospan fst snd\n  | right : R → WalkingMulticospan fst snd\n\n"}
{"name":"CategoryTheory.Limits.WalkingMultispan.right.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"L : Type w\nR : Type w'\nfst snd : L → R\ninst✝¹ : SizeOf L\ninst✝ : SizeOf R\na✝ : R\n⊢ Eq (SizeOf.sizeOf (CategoryTheory.Limits.WalkingMultispan.right a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- The type underlying the multiecoqualizer diagram. -/\n--@[nolint unused_arguments]\ninductive WalkingMultispan {L : Type w} {R : Type w'} (fst snd : L → R) : Type max w w'\n  | left : L → WalkingMultispan fst snd\n  | right : R → WalkingMultispan fst snd\n\n"}
{"name":"CategoryTheory.Limits.WalkingMultispan.right.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"L : Type w\nR : Type w'\nfst snd : L → R\na✝¹ a✝ : R\nx✝ : Eq (CategoryTheory.Limits.WalkingMultispan.right a✝¹) (CategoryTheory.Limits.WalkingMultispan.right a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- The type underlying the multiecoqualizer diagram. -/\n--@[nolint unused_arguments]\ninductive WalkingMultispan {L : Type w} {R : Type w'} (fst snd : L → R) : Type max w w'\n  | left : L → WalkingMultispan fst snd\n  | right : R → WalkingMultispan fst snd\n\n"}
{"name":"CategoryTheory.Limits.WalkingMultispan.left.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"L : Type w\nR : Type w'\nfst snd : L → R\na✝¹ a✝ : L\nx✝ : Eq (CategoryTheory.Limits.WalkingMultispan.left a✝¹) (CategoryTheory.Limits.WalkingMultispan.left a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- The type underlying the multiecoqualizer diagram. -/\n--@[nolint unused_arguments]\ninductive WalkingMultispan {L : Type w} {R : Type w'} (fst snd : L → R) : Type max w w'\n  | left : L → WalkingMultispan fst snd\n  | right : R → WalkingMultispan fst snd\n\n"}
{"name":"CategoryTheory.Limits.WalkingMultispan.right.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"L : Type w\nR : Type w'\nfst snd : L → R\na✝¹ a✝ : R\n⊢ Eq (Eq (CategoryTheory.Limits.WalkingMultispan.right a✝¹) (CategoryTheory.Limits.WalkingMultispan.right a✝)) (Eq a✝¹ a✝)","decl":"/-- The type underlying the multiecoqualizer diagram. -/\n--@[nolint unused_arguments]\ninductive WalkingMultispan {L : Type w} {R : Type w'} (fst snd : L → R) : Type max w w'\n  | left : L → WalkingMultispan fst snd\n  | right : R → WalkingMultispan fst snd\n\n"}
{"name":"CategoryTheory.Limits.WalkingMultispan.left.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"L : Type w\nR : Type w'\nfst snd : L → R\ninst✝¹ : SizeOf L\ninst✝ : SizeOf R\na✝ : L\n⊢ Eq (SizeOf.sizeOf (CategoryTheory.Limits.WalkingMultispan.left a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- The type underlying the multiecoqualizer diagram. -/\n--@[nolint unused_arguments]\ninductive WalkingMultispan {L : Type w} {R : Type w'} (fst snd : L → R) : Type max w w'\n  | left : L → WalkingMultispan fst snd\n  | right : R → WalkingMultispan fst snd\n\n"}
{"name":"CategoryTheory.Limits.WalkingMultispan.left.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"L : Type w\nR : Type w'\nfst snd : L → R\na✝¹ a✝ : L\n⊢ Eq (Eq (CategoryTheory.Limits.WalkingMultispan.left a✝¹) (CategoryTheory.Limits.WalkingMultispan.left a✝)) (Eq a✝¹ a✝)","decl":"/-- The type underlying the multiecoqualizer diagram. -/\n--@[nolint unused_arguments]\ninductive WalkingMultispan {L : Type w} {R : Type w'} (fst snd : L → R) : Type max w w'\n  | left : L → WalkingMultispan fst snd\n  | right : R → WalkingMultispan fst snd\n\n"}
{"name":"CategoryTheory.Limits.WalkingMulticospan.Hom.id_eq_id","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"L : Type w\nR : Type w'\nfst snd : R → L\nX : CategoryTheory.Limits.WalkingMulticospan fst snd\n⊢ Eq (CategoryTheory.Limits.WalkingMulticospan.Hom.id X) (CategoryTheory.CategoryStruct.id X)","decl":"@[simp]\nlemma Hom.id_eq_id (X : WalkingMulticospan fst snd) :\n    Hom.id X = 𝟙 X := rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingMulticospan.Hom.comp_eq_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"L : Type w\nR : Type w'\nfst snd : R → L\nX Y Z : CategoryTheory.Limits.WalkingMulticospan fst snd\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.Limits.WalkingMulticospan.Hom.comp f g) (CategoryTheory.CategoryStruct.comp f g)","decl":"@[simp]\nlemma Hom.comp_eq_comp {X Y Z : WalkingMulticospan fst snd}\n    (f : X ⟶ Y) (g : Y ⟶ Z) : Hom.comp f g = f ≫ g := rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingMultispan.Hom.id_eq_id","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"L : Type w\nR : Type w'\nfst snd : L → R\nX : CategoryTheory.Limits.WalkingMultispan fst snd\n⊢ Eq (CategoryTheory.Limits.WalkingMultispan.Hom.id X) (CategoryTheory.CategoryStruct.id X)","decl":"@[simp]\nlemma Hom.id_eq_id (X : WalkingMultispan fst snd) : Hom.id X = 𝟙 X := rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingMultispan.Hom.comp_eq_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"L : Type w\nR : Type w'\nfst snd : L → R\nX Y Z : CategoryTheory.Limits.WalkingMultispan fst snd\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.Limits.WalkingMultispan.Hom.comp f g) (CategoryTheory.CategoryStruct.comp f g)","decl":"@[simp]\nlemma Hom.comp_eq_comp {X Y Z : WalkingMultispan fst snd}\n    (f : X ⟶ Y) (g : Y ⟶ Z) : Hom.comp f g = f ≫ g := rfl\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nL✝ : Type w\nR✝ : Type w'\nfstTo✝ sndTo✝ : R✝ → L✝\nleft✝ : L✝ → C\nright✝ : R✝ → C\nfst✝ : (b : R✝) → Quiver.Hom (left✝ (fstTo✝ b)) (right✝ b)\nsnd✝ : (b : R✝) → Quiver.Hom (left✝ (sndTo✝ b)) (right✝ b)\nL : Type w\nR : Type w'\nfstTo sndTo : R → L\nleft : L → C\nright : R → C\nfst : (b : R) → Quiver.Hom (left (fstTo b)) (right b)\nsnd : (b : R) → Quiver.Hom (left (sndTo b)) (right b)\n⊢ Eq (Eq { L := L✝, R := R✝, fstTo := fstTo✝, sndTo := sndTo✝, left := left✝, right := right✝, fst := fst✝, snd := snd✝ } { L := L, R := R, fstTo := fstTo, sndTo := sndTo, left := left, right := right, fst := fst, snd := snd }) (And (Eq L✝ L) (And (Eq R✝ R) (And (HEq fstTo✝ fstTo) (And (HEq sndTo✝ sndTo) (And (HEq left✝ left) (And (HEq right✝ right) (And (HEq fst✝ fst) (HEq snd✝ snd))))))))","decl":"/-- This is a structure encapsulating the data necessary to define a `Multicospan`. -/\n@[nolint checkUnivs]\nstructure MulticospanIndex (C : Type u) [Category.{v} C] where\n  (L : Type w)\n  (R : Type w')\n  (fstTo sndTo : R → L)\n  left : L → C\n  right : R → C\n  fst : ∀ b, left (fstTo b) ⟶ right b\n  snd : ∀ b, left (sndTo b) ⟶ right b\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : SizeOf C\nL : Type w\nR : Type w'\nfstTo sndTo : R → L\nleft : L → C\nright : R → C\nfst : (b : R) → Quiver.Hom (left (fstTo b)) (right b)\nsnd : (b : R) → Quiver.Hom (left (sndTo b)) (right b)\n⊢ Eq (SizeOf.sizeOf { L := L, R := R, fstTo := fstTo, sndTo := sndTo, left := left, right := right, fst := fst, snd := snd }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf L)) (SizeOf.sizeOf R))","decl":"/-- This is a structure encapsulating the data necessary to define a `Multicospan`. -/\n@[nolint checkUnivs]\nstructure MulticospanIndex (C : Type u) [Category.{v} C] where\n  (L : Type w)\n  (R : Type w')\n  (fstTo sndTo : R → L)\n  left : L → C\n  right : R → C\n  fst : ∀ b, left (fstTo b) ⟶ right b\n  snd : ∀ b, left (sndTo b) ⟶ right b\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nL✝ : Type w\nR✝ : Type w'\nfstTo✝ sndTo✝ : R✝ → L✝\nleft✝ : L✝ → C\nright✝ : R✝ → C\nfst✝ : (b : R✝) → Quiver.Hom (left✝ (fstTo✝ b)) (right✝ b)\nsnd✝ : (b : R✝) → Quiver.Hom (left✝ (sndTo✝ b)) (right✝ b)\nL : Type w\nR : Type w'\nfstTo sndTo : R → L\nleft : L → C\nright : R → C\nfst : (b : R) → Quiver.Hom (left (fstTo b)) (right b)\nsnd : (b : R) → Quiver.Hom (left (sndTo b)) (right b)\nx✝ : Eq { L := L✝, R := R✝, fstTo := fstTo✝, sndTo := sndTo✝, left := left✝, right := right✝, fst := fst✝, snd := snd✝ } { L := L, R := R, fstTo := fstTo, sndTo := sndTo, left := left, right := right, fst := fst, snd := snd }\n⊢ And (Eq L✝ L) (And (Eq R✝ R) (And (HEq fstTo✝ fstTo) (And (HEq sndTo✝ sndTo) (And (HEq left✝ left) (And (HEq right✝ right) (And (HEq fst✝ fst) (HEq snd✝ snd)))))))","decl":"/-- This is a structure encapsulating the data necessary to define a `Multicospan`. -/\n@[nolint checkUnivs]\nstructure MulticospanIndex (C : Type u) [Category.{v} C] where\n  (L : Type w)\n  (R : Type w')\n  (fstTo sndTo : R → L)\n  left : L → C\n  right : R → C\n  fst : ∀ b, left (fstTo b) ⟶ right b\n  snd : ∀ b, left (sndTo b) ⟶ right b\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nL✝ : Type w\nR✝ : Type w'\nfstFrom✝ sndFrom✝ : L✝ → R✝\nleft✝ : L✝ → C\nright✝ : R✝ → C\nfst✝ : (a : L✝) → Quiver.Hom (left✝ a) (right✝ (fstFrom✝ a))\nsnd✝ : (a : L✝) → Quiver.Hom (left✝ a) (right✝ (sndFrom✝ a))\nL : Type w\nR : Type w'\nfstFrom sndFrom : L → R\nleft : L → C\nright : R → C\nfst : (a : L) → Quiver.Hom (left a) (right (fstFrom a))\nsnd : (a : L) → Quiver.Hom (left a) (right (sndFrom a))\n⊢ Eq (Eq { L := L✝, R := R✝, fstFrom := fstFrom✝, sndFrom := sndFrom✝, left := left✝, right := right✝, fst := fst✝, snd := snd✝ } { L := L, R := R, fstFrom := fstFrom, sndFrom := sndFrom, left := left, right := right, fst := fst, snd := snd }) (And (Eq L✝ L) (And (Eq R✝ R) (And (HEq fstFrom✝ fstFrom) (And (HEq sndFrom✝ sndFrom) (And (HEq left✝ left) (And (HEq right✝ right) (And (HEq fst✝ fst) (HEq snd✝ snd))))))))","decl":"/-- This is a structure encapsulating the data necessary to define a `Multispan`. -/\n@[nolint checkUnivs]\nstructure MultispanIndex (C : Type u) [Category.{v} C] where\n  (L : Type w)\n  (R : Type w')\n  (fstFrom sndFrom : L → R)\n  left : L → C\n  right : R → C\n  fst : ∀ a, left a ⟶ right (fstFrom a)\n  snd : ∀ a, left a ⟶ right (sndFrom a)\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : SizeOf C\nL : Type w\nR : Type w'\nfstFrom sndFrom : L → R\nleft : L → C\nright : R → C\nfst : (a : L) → Quiver.Hom (left a) (right (fstFrom a))\nsnd : (a : L) → Quiver.Hom (left a) (right (sndFrom a))\n⊢ Eq (SizeOf.sizeOf { L := L, R := R, fstFrom := fstFrom, sndFrom := sndFrom, left := left, right := right, fst := fst, snd := snd }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf L)) (SizeOf.sizeOf R))","decl":"/-- This is a structure encapsulating the data necessary to define a `Multispan`. -/\n@[nolint checkUnivs]\nstructure MultispanIndex (C : Type u) [Category.{v} C] where\n  (L : Type w)\n  (R : Type w')\n  (fstFrom sndFrom : L → R)\n  left : L → C\n  right : R → C\n  fst : ∀ a, left a ⟶ right (fstFrom a)\n  snd : ∀ a, left a ⟶ right (sndFrom a)\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nL✝ : Type w\nR✝ : Type w'\nfstFrom✝ sndFrom✝ : L✝ → R✝\nleft✝ : L✝ → C\nright✝ : R✝ → C\nfst✝ : (a : L✝) → Quiver.Hom (left✝ a) (right✝ (fstFrom✝ a))\nsnd✝ : (a : L✝) → Quiver.Hom (left✝ a) (right✝ (sndFrom✝ a))\nL : Type w\nR : Type w'\nfstFrom sndFrom : L → R\nleft : L → C\nright : R → C\nfst : (a : L) → Quiver.Hom (left a) (right (fstFrom a))\nsnd : (a : L) → Quiver.Hom (left a) (right (sndFrom a))\nx✝ : Eq { L := L✝, R := R✝, fstFrom := fstFrom✝, sndFrom := sndFrom✝, left := left✝, right := right✝, fst := fst✝, snd := snd✝ } { L := L, R := R, fstFrom := fstFrom, sndFrom := sndFrom, left := left, right := right, fst := fst, snd := snd }\n⊢ And (Eq L✝ L) (And (Eq R✝ R) (And (HEq fstFrom✝ fstFrom) (And (HEq sndFrom✝ sndFrom) (And (HEq left✝ left) (And (HEq right✝ right) (And (HEq fst✝ fst) (HEq snd✝ snd)))))))","decl":"/-- This is a structure encapsulating the data necessary to define a `Multispan`. -/\n@[nolint checkUnivs]\nstructure MultispanIndex (C : Type u) [Category.{v} C] where\n  (L : Type w)\n  (R : Type w')\n  (fstFrom sndFrom : L → R)\n  left : L → C\n  right : R → C\n  fst : ∀ a, left a ⟶ right (fstFrom a)\n  snd : ∀ a, left a ⟶ right (sndFrom a)\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.multicospan_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nx y : CategoryTheory.Limits.WalkingMulticospan I.fstTo I.sndTo\nf : Quiver.Hom x y\n⊢ Eq (I.multicospan.map f) (CategoryTheory.Limits.MulticospanIndex.multicospan.match_2 I (fun x y f => Quiver.Hom ((fun x => CategoryTheory.Limits.MulticospanIndex.multicospan.match_1 I (fun x => C) x (fun a => I.left a) fun b => I.right b) x) ((fun x => CategoryTheory.Limits.MulticospanIndex.multicospan.match_1 I (fun x => C) x (fun a => I.left a) fun b => I.right b) y)) x y f (fun x => CategoryTheory.CategoryStruct.id ((fun x => CategoryTheory.Limits.MulticospanIndex.multicospan.match_1 I (fun x => C) x (fun a => I.left a) fun b => I.right b) x)) (fun b => I.fst b) fun b => I.snd b)","decl":"/-- The multicospan associated to `I : MulticospanIndex`. -/\n@[simps]\ndef multicospan : WalkingMulticospan I.fstTo I.sndTo ⥤ C where\n  obj x :=\n    match x with\n    | WalkingMulticospan.left a => I.left a\n    | WalkingMulticospan.right b => I.right b\n  map {x y} f :=\n    match x, y, f with\n    | _, _, WalkingMulticospan.Hom.id x => 𝟙 _\n    | _, _, WalkingMulticospan.Hom.fst b => I.fst _\n    | _, _, WalkingMulticospan.Hom.snd b => I.snd _\n  map_id := by\n    rintro (_ | _) <;> rfl\n  map_comp := by\n    rintro (_ | _) (_ | _) (_ | _) (_ | _ | _) (_ | _ | _) <;> aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.multicospan_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nx : CategoryTheory.Limits.WalkingMulticospan I.fstTo I.sndTo\n⊢ Eq (I.multicospan.obj x) (CategoryTheory.Limits.MulticospanIndex.multicospan.match_1 I (fun x => C) x (fun a => I.left a) fun b => I.right b)","decl":"/-- The multicospan associated to `I : MulticospanIndex`. -/\n@[simps]\ndef multicospan : WalkingMulticospan I.fstTo I.sndTo ⥤ C where\n  obj x :=\n    match x with\n    | WalkingMulticospan.left a => I.left a\n    | WalkingMulticospan.right b => I.right b\n  map {x y} f :=\n    match x, y, f with\n    | _, _, WalkingMulticospan.Hom.id x => 𝟙 _\n    | _, _, WalkingMulticospan.Hom.fst b => I.fst _\n    | _, _, WalkingMulticospan.Hom.snd b => I.snd _\n  map_id := by\n    rintro (_ | _) <;> rfl\n  map_comp := by\n    rintro (_ | _) (_ | _) (_ | _) (_ | _ | _) (_ | _ | _) <;> aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.fstPiMap_π_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninst✝¹ : CategoryTheory.Limits.HasProduct I.left\ninst✝ : CategoryTheory.Limits.HasProduct I.right\nb : I.R\nZ : C\nh : Quiver.Hom (I.right b) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp I.fstPiMap (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π I.right b) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π I.left (I.fstTo b)) (CategoryTheory.CategoryStruct.comp (I.fst b) h))","decl":"@[reassoc (attr := simp)]\ntheorem fstPiMap_π (b) : I.fstPiMap ≫ Pi.π I.right b = Pi.π I.left _ ≫ I.fst b := by\n  simp [fstPiMap]\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.fstPiMap_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninst✝¹ : CategoryTheory.Limits.HasProduct I.left\ninst✝ : CategoryTheory.Limits.HasProduct I.right\nb : I.R\n⊢ Eq (CategoryTheory.CategoryStruct.comp I.fstPiMap (CategoryTheory.Limits.Pi.π I.right b)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π I.left (I.fstTo b)) (I.fst b))","decl":"@[reassoc (attr := simp)]\ntheorem fstPiMap_π (b) : I.fstPiMap ≫ Pi.π I.right b = Pi.π I.left _ ≫ I.fst b := by\n  simp [fstPiMap]\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.sndPiMap_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninst✝¹ : CategoryTheory.Limits.HasProduct I.left\ninst✝ : CategoryTheory.Limits.HasProduct I.right\nb : I.R\n⊢ Eq (CategoryTheory.CategoryStruct.comp I.sndPiMap (CategoryTheory.Limits.Pi.π I.right b)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π I.left (I.sndTo b)) (I.snd b))","decl":"@[reassoc (attr := simp)]\ntheorem sndPiMap_π (b) : I.sndPiMap ≫ Pi.π I.right b = Pi.π I.left _ ≫ I.snd b := by\n  simp [sndPiMap]\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.sndPiMap_π_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninst✝¹ : CategoryTheory.Limits.HasProduct I.left\ninst✝ : CategoryTheory.Limits.HasProduct I.right\nb : I.R\nZ : C\nh : Quiver.Hom (I.right b) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp I.sndPiMap (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π I.right b) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π I.left (I.sndTo b)) (CategoryTheory.CategoryStruct.comp (I.snd b) h))","decl":"@[reassoc (attr := simp)]\ntheorem sndPiMap_π (b) : I.sndPiMap ≫ Pi.π I.right b = Pi.π I.left _ ≫ I.snd b := by\n  simp [sndPiMap]\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.parallelPairDiagram_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninst✝¹ : CategoryTheory.Limits.HasProduct I.left\ninst✝ : CategoryTheory.Limits.HasProduct I.right\nX✝ Y✝ : CategoryTheory.Limits.WalkingParallelPair\nh : Quiver.Hom X✝ Y✝\n⊢ Eq (I.parallelPairDiagram.map h) (CategoryTheory.Limits.parallelPair.match_2 (fun X Y h => Quiver.Hom (CategoryTheory.Limits.parallelPair.match_1 (fun x => C) X (fun _ => CategoryTheory.Limits.piObj I.left) fun _ => CategoryTheory.Limits.piObj I.right) (CategoryTheory.Limits.parallelPair.match_1 (fun x => C) Y (fun _ => CategoryTheory.Limits.piObj I.left) fun _ => CategoryTheory.Limits.piObj I.right)) X✝ Y✝ h (fun x => CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.parallelPair.match_1 (fun x => C) x (fun _ => CategoryTheory.Limits.piObj I.left) fun _ => CategoryTheory.Limits.piObj I.right)) (fun _ => I.fstPiMap) fun _ => I.sndPiMap)","decl":"/-- Taking the multiequalizer over the multicospan index is equivalent to taking the equalizer over\nthe two morphisms `∏ᶜ I.left ⇉ ∏ᶜ I.right`. This is the diagram of the latter.\n-/\n@[simps!]\nprotected noncomputable def parallelPairDiagram :=\n  parallelPair I.fstPiMap I.sndPiMap\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.parallelPairDiagram_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninst✝¹ : CategoryTheory.Limits.HasProduct I.left\ninst✝ : CategoryTheory.Limits.HasProduct I.right\nx : CategoryTheory.Limits.WalkingParallelPair\n⊢ Eq (I.parallelPairDiagram.obj x) (CategoryTheory.Limits.parallelPair.match_1 (fun x => C) x (fun _ => CategoryTheory.Limits.piObj I.left) fun _ => CategoryTheory.Limits.piObj I.right)","decl":"/-- Taking the multiequalizer over the multicospan index is equivalent to taking the equalizer over\nthe two morphisms `∏ᶜ I.left ⇉ ∏ᶜ I.right`. This is the diagram of the latter.\n-/\n@[simps!]\nprotected noncomputable def parallelPairDiagram :=\n  parallelPair I.fstPiMap I.sndPiMap\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.multispan_obj_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\na : I.L\n⊢ Eq (I.multispan.obj (CategoryTheory.Limits.WalkingMultispan.left a)) (I.left a)","decl":"@[simp]\ntheorem multispan_obj_left (a) : I.multispan.obj (WalkingMultispan.left a) = I.left a :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.multispan_obj_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\nb : I.R\n⊢ Eq (I.multispan.obj (CategoryTheory.Limits.WalkingMultispan.right b)) (I.right b)","decl":"@[simp]\ntheorem multispan_obj_right (b) : I.multispan.obj (WalkingMultispan.right b) = I.right b :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.multispan_map_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\na : I.L\n⊢ Eq (I.multispan.map (CategoryTheory.Limits.WalkingMultispan.Hom.fst a)) (I.fst a)","decl":"@[simp]\ntheorem multispan_map_fst (a) : I.multispan.map (WalkingMultispan.Hom.fst a) = I.fst a :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.multispan_map_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\na : I.L\n⊢ Eq (I.multispan.map (CategoryTheory.Limits.WalkingMultispan.Hom.snd a)) (I.snd a)","decl":"@[simp]\ntheorem multispan_map_snd (a) : I.multispan.map (WalkingMultispan.Hom.snd a) = I.snd a :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.ι_fstSigmaMap_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct I.left\ninst✝ : CategoryTheory.Limits.HasCoproduct I.right\nb : I.L\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.sigmaObj I.right) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι I.left b) (CategoryTheory.CategoryStruct.comp I.fstSigmaMap h)) (CategoryTheory.CategoryStruct.comp (I.fst b) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι I.right (I.fstFrom b)) h))","decl":"@[reassoc (attr := simp)]\ntheorem ι_fstSigmaMap (b) : Sigma.ι I.left b ≫ I.fstSigmaMap = I.fst b ≫ Sigma.ι I.right _ := by\n  simp [fstSigmaMap]\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.ι_fstSigmaMap","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct I.left\ninst✝ : CategoryTheory.Limits.HasCoproduct I.right\nb : I.L\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι I.left b) I.fstSigmaMap) (CategoryTheory.CategoryStruct.comp (I.fst b) (CategoryTheory.Limits.Sigma.ι I.right (I.fstFrom b)))","decl":"@[reassoc (attr := simp)]\ntheorem ι_fstSigmaMap (b) : Sigma.ι I.left b ≫ I.fstSigmaMap = I.fst b ≫ Sigma.ι I.right _ := by\n  simp [fstSigmaMap]\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.ι_sndSigmaMap","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct I.left\ninst✝ : CategoryTheory.Limits.HasCoproduct I.right\nb : I.L\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι I.left b) I.sndSigmaMap) (CategoryTheory.CategoryStruct.comp (I.snd b) (CategoryTheory.Limits.Sigma.ι I.right (I.sndFrom b)))","decl":"@[reassoc (attr := simp)]\ntheorem ι_sndSigmaMap (b) : Sigma.ι I.left b ≫ I.sndSigmaMap = I.snd b ≫ Sigma.ι I.right _ := by\n  simp [sndSigmaMap]\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.ι_sndSigmaMap_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct I.left\ninst✝ : CategoryTheory.Limits.HasCoproduct I.right\nb : I.L\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.sigmaObj I.right) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι I.left b) (CategoryTheory.CategoryStruct.comp I.sndSigmaMap h)) (CategoryTheory.CategoryStruct.comp (I.snd b) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι I.right (I.sndFrom b)) h))","decl":"@[reassoc (attr := simp)]\ntheorem ι_sndSigmaMap (b) : Sigma.ι I.left b ≫ I.sndSigmaMap = I.snd b ≫ Sigma.ι I.right _ := by\n  simp [sndSigmaMap]\n\n"}
{"name":"CategoryTheory.Limits.Multifork.app_left_eq_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nK : CategoryTheory.Limits.Multifork I\na : I.L\n⊢ Eq (K.π.app (CategoryTheory.Limits.WalkingMulticospan.left a)) (K.ι a)","decl":"@[simp]\ntheorem app_left_eq_ι (a) : K.π.app (WalkingMulticospan.left a) = K.ι a :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multifork.app_right_eq_ι_comp_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nK : CategoryTheory.Limits.Multifork I\nb : I.R\n⊢ Eq (K.π.app (CategoryTheory.Limits.WalkingMulticospan.right b)) (CategoryTheory.CategoryStruct.comp (K.ι (I.fstTo b)) (I.fst b))","decl":"@[simp]\ntheorem app_right_eq_ι_comp_fst (b) :\n    K.π.app (WalkingMulticospan.right b) = K.ι (I.fstTo b) ≫ I.fst b := by\n  rw [← K.w (WalkingMulticospan.Hom.fst b)]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multifork.app_right_eq_ι_comp_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nK : CategoryTheory.Limits.Multifork I\nb : I.R\n⊢ Eq (K.π.app (CategoryTheory.Limits.WalkingMulticospan.right b)) (CategoryTheory.CategoryStruct.comp (K.ι (I.sndTo b)) (I.snd b))","decl":"@[reassoc]\ntheorem app_right_eq_ι_comp_snd (b) :\n    K.π.app (WalkingMulticospan.right b) = K.ι (I.sndTo b) ≫ I.snd b := by\n  rw [← K.w (WalkingMulticospan.Hom.snd b)]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multifork.app_right_eq_ι_comp_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nK : CategoryTheory.Limits.Multifork I\nb : I.R\nZ : C\nh : Quiver.Hom (I.multicospan.obj (CategoryTheory.Limits.WalkingMulticospan.right b)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.π.app (CategoryTheory.Limits.WalkingMulticospan.right b)) h) (CategoryTheory.CategoryStruct.comp (K.ι (I.sndTo b)) (CategoryTheory.CategoryStruct.comp (I.snd b) h))","decl":"@[reassoc]\ntheorem app_right_eq_ι_comp_snd (b) :\n    K.π.app (WalkingMulticospan.right b) = K.ι (I.sndTo b) ≫ I.snd b := by\n  rw [← K.w (WalkingMulticospan.Hom.snd b)]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multifork.hom_comp_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nK₁ K₂ : CategoryTheory.Limits.Multifork I\nf : Quiver.Hom K₁ K₂\nj : I.L\n⊢ Eq (CategoryTheory.CategoryStruct.comp f.hom (K₂.ι j)) (K₁.ι j)","decl":"@[reassoc (attr := simp)]\ntheorem hom_comp_ι (K₁ K₂ : Multifork I) (f : K₁ ⟶ K₂) (j : I.L) : f.hom ≫ K₂.ι j = K₁.ι j :=\n  f.w _\n\n"}
{"name":"CategoryTheory.Limits.Multifork.hom_comp_ι_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nK₁ K₂ : CategoryTheory.Limits.Multifork I\nf : Quiver.Hom K₁ K₂\nj : I.L\nZ : C\nh : Quiver.Hom (I.left j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f.hom (CategoryTheory.CategoryStruct.comp (K₂.ι j) h)) (CategoryTheory.CategoryStruct.comp (K₁.ι j) h)","decl":"@[reassoc (attr := simp)]\ntheorem hom_comp_ι (K₁ K₂ : Multifork I) (f : K₁ ⟶ K₂) (j : I.L) : f.hom ≫ K₂.ι j = K₁.ι j :=\n  f.w _\n\n"}
{"name":"CategoryTheory.Limits.Multifork.ofι_π_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nP : C\nι : (a : I.L) → Quiver.Hom P (I.left a)\nw : ∀ (b : I.R), Eq (CategoryTheory.CategoryStruct.comp (ι (I.fstTo b)) (I.fst b)) (CategoryTheory.CategoryStruct.comp (ι (I.sndTo b)) (I.snd b))\nx : CategoryTheory.Limits.WalkingMulticospan I.fstTo I.sndTo\n⊢ Eq ((CategoryTheory.Limits.Multifork.ofι I P ι w).π.app x) (CategoryTheory.Limits.MulticospanIndex.multicospan.match_1 I (fun x => Quiver.Hom (((CategoryTheory.Functor.const (CategoryTheory.Limits.WalkingMulticospan I.fstTo I.sndTo)).obj P).obj x) (I.multicospan.obj x)) x (fun a => ι a) fun b => CategoryTheory.CategoryStruct.comp (ι (I.fstTo b)) (I.fst b))","decl":"/-- Construct a multifork using a collection `ι` of morphisms. -/\n@[simps]\ndef ofι (I : MulticospanIndex.{w, w'} C) (P : C) (ι : ∀ a, P ⟶ I.left a)\n    (w : ∀ b, ι (I.fstTo b) ≫ I.fst b = ι (I.sndTo b) ≫ I.snd b) : Multifork I where\n  pt := P\n  π :=\n    { app := fun x =>\n        match x with\n        | WalkingMulticospan.left _ => ι _\n        | WalkingMulticospan.right b => ι (I.fstTo b) ≫ I.fst b\n      naturality := by\n        rintro (_ | _) (_ | _) (_ | _ | _) <;>\n          dsimp <;> simp only [Category.id_comp, Category.comp_id]\n        apply w }\n\n"}
{"name":"CategoryTheory.Limits.Multifork.ofι_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nP : C\nι : (a : I.L) → Quiver.Hom P (I.left a)\nw : ∀ (b : I.R), Eq (CategoryTheory.CategoryStruct.comp (ι (I.fstTo b)) (I.fst b)) (CategoryTheory.CategoryStruct.comp (ι (I.sndTo b)) (I.snd b))\n⊢ Eq (CategoryTheory.Limits.Multifork.ofι I P ι w).pt P","decl":"/-- Construct a multifork using a collection `ι` of morphisms. -/\n@[simps]\ndef ofι (I : MulticospanIndex.{w, w'} C) (P : C) (ι : ∀ a, P ⟶ I.left a)\n    (w : ∀ b, ι (I.fstTo b) ≫ I.fst b = ι (I.sndTo b) ≫ I.snd b) : Multifork I where\n  pt := P\n  π :=\n    { app := fun x =>\n        match x with\n        | WalkingMulticospan.left _ => ι _\n        | WalkingMulticospan.right b => ι (I.fstTo b) ≫ I.fst b\n      naturality := by\n        rintro (_ | _) (_ | _) (_ | _ | _) <;>\n          dsimp <;> simp only [Category.id_comp, Category.comp_id]\n        apply w }\n\n"}
{"name":"CategoryTheory.Limits.Multifork.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nK : CategoryTheory.Limits.Multifork I\nb : I.R\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.ι (I.fstTo b)) (I.fst b)) (CategoryTheory.CategoryStruct.comp (K.ι (I.sndTo b)) (I.snd b))","decl":"@[reassoc (attr := simp)]\ntheorem condition (b) : K.ι (I.fstTo b) ≫ I.fst b = K.ι (I.sndTo b) ≫ I.snd b := by\n  rw [← app_right_eq_ι_comp_fst, ← app_right_eq_ι_comp_snd]\n\n"}
{"name":"CategoryTheory.Limits.Multifork.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nK : CategoryTheory.Limits.Multifork I\nb : I.R\nZ : C\nh : Quiver.Hom (I.right b) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.ι (I.fstTo b)) (CategoryTheory.CategoryStruct.comp (I.fst b) h)) (CategoryTheory.CategoryStruct.comp (K.ι (I.sndTo b)) (CategoryTheory.CategoryStruct.comp (I.snd b) h))","decl":"@[reassoc (attr := simp)]\ntheorem condition (b) : K.ι (I.fstTo b) ≫ I.fst b = K.ι (I.sndTo b) ≫ I.snd b := by\n  rw [← app_right_eq_ι_comp_fst, ← app_right_eq_ι_comp_snd]\n\n"}
{"name":"CategoryTheory.Limits.Multifork.IsLimit.mk_lift","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nK : CategoryTheory.Limits.Multifork I\nlift : (E : CategoryTheory.Limits.Multifork I) → Quiver.Hom E.pt K.pt\nfac : ∀ (E : CategoryTheory.Limits.Multifork I) (i : I.L), Eq (CategoryTheory.CategoryStruct.comp (lift E) (K.ι i)) (E.ι i)\nuniq : ∀ (E : CategoryTheory.Limits.Multifork I) (m : Quiver.Hom E.pt K.pt), (∀ (i : I.L), Eq (CategoryTheory.CategoryStruct.comp m (K.ι i)) (E.ι i)) → Eq m (lift E)\nE : CategoryTheory.Limits.Multifork I\n⊢ Eq ((CategoryTheory.Limits.Multifork.IsLimit.mk K lift fac uniq).lift E) (lift E)","decl":"/-- This definition provides a convenient way to show that a multifork is a limit. -/\n@[simps]\ndef IsLimit.mk (lift : ∀ E : Multifork I, E.pt ⟶ K.pt)\n    (fac : ∀ (E : Multifork I) (i : I.L), lift E ≫ K.ι i = E.ι i)\n    (uniq : ∀ (E : Multifork I) (m : E.pt ⟶ K.pt), (∀ i : I.L, m ≫ K.ι i = E.ι i) → m = lift E) :\n    IsLimit K :=\n  { lift\n    fac := by\n      rintro E (a | b)\n      · apply fac\n      · rw [← E.w (WalkingMulticospan.Hom.fst b), ← K.w (WalkingMulticospan.Hom.fst b), ←\n          Category.assoc]\n        congr 1\n        apply fac\n    uniq := by\n      rintro E m hm\n      apply uniq\n      intro i\n      apply hm }\n\n"}
{"name":"CategoryTheory.Limits.Multifork.IsLimit.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nK : CategoryTheory.Limits.Multifork I\nhK : CategoryTheory.Limits.IsLimit K\nT : C\nf g : Quiver.Hom T K.pt\nh : ∀ (a : I.L), Eq (CategoryTheory.CategoryStruct.comp f (K.ι a)) (CategoryTheory.CategoryStruct.comp g (K.ι a))\n⊢ Eq f g","decl":"lemma IsLimit.hom_ext (hK : IsLimit K) {T : C} {f g : T ⟶ K.pt}\n    (h : ∀ a, f ≫ K.ι a = g ≫ K.ι a) : f = g := by\n  apply hK.hom_ext\n  rintro (_|b)\n  · apply h\n  · dsimp\n    rw [app_right_eq_ι_comp_fst, reassoc_of% h]\n\n"}
{"name":"CategoryTheory.Limits.Multifork.IsLimit.fac","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nK : CategoryTheory.Limits.Multifork I\nhK : CategoryTheory.Limits.IsLimit K\nT : C\nk : (a : I.L) → Quiver.Hom T (I.left a)\nhk : ∀ (b : I.R), Eq (CategoryTheory.CategoryStruct.comp (k (I.fstTo b)) (I.fst b)) (CategoryTheory.CategoryStruct.comp (k (I.sndTo b)) (I.snd b))\na : I.L\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multifork.IsLimit.lift hK k hk) (K.ι a)) (k a)","decl":"@[reassoc (attr := simp)]\nlemma IsLimit.fac (hK : IsLimit K) {T : C} (k : ∀ a, T ⟶ I.left a)\n    (hk : ∀ b, k (I.fstTo b) ≫ I.fst b = k (I.sndTo b) ≫ I.snd b) (a : I.L) :\n    IsLimit.lift hK k hk ≫ K.ι a = k a :=\n  hK.fac _ _\n\n"}
{"name":"CategoryTheory.Limits.Multifork.IsLimit.fac_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nK : CategoryTheory.Limits.Multifork I\nhK : CategoryTheory.Limits.IsLimit K\nT : C\nk : (a : I.L) → Quiver.Hom T (I.left a)\nhk : ∀ (b : I.R), Eq (CategoryTheory.CategoryStruct.comp (k (I.fstTo b)) (I.fst b)) (CategoryTheory.CategoryStruct.comp (k (I.sndTo b)) (I.snd b))\na : I.L\nZ : C\nh : Quiver.Hom (I.left a) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multifork.IsLimit.lift hK k hk) (CategoryTheory.CategoryStruct.comp (K.ι a) h)) (CategoryTheory.CategoryStruct.comp (k a) h)","decl":"@[reassoc (attr := simp)]\nlemma IsLimit.fac (hK : IsLimit K) {T : C} (k : ∀ a, T ⟶ I.left a)\n    (hk : ∀ b, k (I.fstTo b) ≫ I.fst b = k (I.sndTo b) ≫ I.snd b) (a : I.L) :\n    IsLimit.lift hK k hk ≫ K.ι a = k a :=\n  hK.fac _ _\n\n"}
{"name":"CategoryTheory.Limits.Multifork.pi_condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nK : CategoryTheory.Limits.Multifork I\ninst✝¹ : CategoryTheory.Limits.HasProduct I.left\ninst✝ : CategoryTheory.Limits.HasProduct I.right\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.piObj I.right) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.lift K.ι) (CategoryTheory.CategoryStruct.comp I.fstPiMap h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.lift K.ι) (CategoryTheory.CategoryStruct.comp I.sndPiMap h))","decl":"@[reassoc (attr := simp)]\ntheorem pi_condition : Pi.lift K.ι ≫ I.fstPiMap = Pi.lift K.ι ≫ I.sndPiMap := by\n  ext\n  simp\n\n"}
{"name":"CategoryTheory.Limits.Multifork.pi_condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nK : CategoryTheory.Limits.Multifork I\ninst✝¹ : CategoryTheory.Limits.HasProduct I.left\ninst✝ : CategoryTheory.Limits.HasProduct I.right\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.lift K.ι) I.fstPiMap) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.lift K.ι) I.sndPiMap)","decl":"@[reassoc (attr := simp)]\ntheorem pi_condition : Pi.lift K.ι ≫ I.fstPiMap = Pi.lift K.ι ≫ I.sndPiMap := by\n  ext\n  simp\n\n"}
{"name":"CategoryTheory.Limits.Multifork.toPiFork_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninst✝¹ : CategoryTheory.Limits.HasProduct I.left\ninst✝ : CategoryTheory.Limits.HasProduct I.right\nK : CategoryTheory.Limits.Multifork I\n⊢ Eq K.toPiFork.pt K.pt","decl":"/-- Given a multifork, we may obtain a fork over `∏ᶜ I.left ⇉ ∏ᶜ I.right`. -/\n@[simps pt]\nnoncomputable def toPiFork (K : Multifork I) : Fork I.fstPiMap I.sndPiMap where\n  pt := K.pt\n  π :=\n    { app := fun x =>\n        match x with\n        | WalkingParallelPair.zero => Pi.lift K.ι\n        | WalkingParallelPair.one => Pi.lift K.ι ≫ I.fstPiMap\n      naturality := by\n        rintro (_ | _) (_ | _) (_ | _ | _) <;>\n          dsimp <;>\n          simp only [Category.id_comp, Functor.map_id, parallelPair_obj_zero, Category.comp_id,\n            pi_condition, parallelPair_obj_one] }\n\n"}
{"name":"CategoryTheory.Limits.Multifork.toPiFork_π_app_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nK : CategoryTheory.Limits.Multifork I\ninst✝¹ : CategoryTheory.Limits.HasProduct I.left\ninst✝ : CategoryTheory.Limits.HasProduct I.right\n⊢ Eq K.toPiFork.ι (CategoryTheory.Limits.Pi.lift K.ι)","decl":"@[simp]\ntheorem toPiFork_π_app_zero : K.toPiFork.ι = Pi.lift K.ι :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multifork.toPiFork_π_app_one","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nK : CategoryTheory.Limits.Multifork I\ninst✝¹ : CategoryTheory.Limits.HasProduct I.left\ninst✝ : CategoryTheory.Limits.HasProduct I.right\n⊢ Eq (K.toPiFork.π.app CategoryTheory.Limits.WalkingParallelPair.one) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.lift K.ι) I.fstPiMap)","decl":"@[simp]\ntheorem toPiFork_π_app_one : K.toPiFork.π.app WalkingParallelPair.one = Pi.lift K.ι ≫ I.fstPiMap :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multifork.ofPiFork_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninst✝¹ : CategoryTheory.Limits.HasProduct I.left\ninst✝ : CategoryTheory.Limits.HasProduct I.right\nc : CategoryTheory.Limits.Fork I.fstPiMap I.sndPiMap\n⊢ Eq (CategoryTheory.Limits.Multifork.ofPiFork I c).pt c.pt","decl":"/-- Given a fork over `∏ᶜ I.left ⇉ ∏ᶜ I.right`, we may obtain a multifork. -/\n@[simps pt]\nnoncomputable def ofPiFork (c : Fork I.fstPiMap I.sndPiMap) : Multifork I where\n  pt := c.pt\n  π :=\n    { app := fun x =>\n        match x with\n        | WalkingMulticospan.left _ => c.ι ≫ Pi.π _ _\n        | WalkingMulticospan.right _ => c.ι ≫ I.fstPiMap ≫ Pi.π _ _\n      naturality := by\n        rintro (_ | _) (_ | _) (_ | _ | _)\n        · simp\n        · simp\n        · dsimp; rw [c.condition_assoc]; simp\n        · simp }\n\n"}
{"name":"CategoryTheory.Limits.Multifork.ofPiFork_π_app_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninst✝¹ : CategoryTheory.Limits.HasProduct I.left\ninst✝ : CategoryTheory.Limits.HasProduct I.right\nc : CategoryTheory.Limits.Fork I.fstPiMap I.sndPiMap\na : I.L\n⊢ Eq ((CategoryTheory.Limits.Multifork.ofPiFork I c).ι a) (CategoryTheory.CategoryStruct.comp c.ι (CategoryTheory.Limits.Pi.π I.left a))","decl":"@[simp]\ntheorem ofPiFork_π_app_left (c : Fork I.fstPiMap I.sndPiMap) (a) :\n    (ofPiFork I c).ι a = c.ι ≫ Pi.π _ _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multifork.ofPiFork_π_app_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninst✝¹ : CategoryTheory.Limits.HasProduct I.left\ninst✝ : CategoryTheory.Limits.HasProduct I.right\nc : CategoryTheory.Limits.Fork I.fstPiMap I.sndPiMap\na : I.R\n⊢ Eq ((CategoryTheory.Limits.Multifork.ofPiFork I c).π.app (CategoryTheory.Limits.WalkingMulticospan.right a)) (CategoryTheory.CategoryStruct.comp c.ι (CategoryTheory.CategoryStruct.comp I.fstPiMap (CategoryTheory.Limits.Pi.π I.right a)))","decl":"@[simp]\ntheorem ofPiFork_π_app_right (c : Fork I.fstPiMap I.sndPiMap) (a) :\n    (ofPiFork I c).π.app (WalkingMulticospan.right a) = c.ι ≫ I.fstPiMap ≫ Pi.π _ _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.toPiForkFunctor_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninst✝¹ : CategoryTheory.Limits.HasProduct I.left\ninst✝ : CategoryTheory.Limits.HasProduct I.right\nK : CategoryTheory.Limits.Multifork I\n⊢ Eq (I.toPiForkFunctor.obj K) K.toPiFork","decl":"/-- `Multifork.toPiFork` as a functor. -/\n@[simps]\nnoncomputable def toPiForkFunctor : Multifork I ⥤ Fork I.fstPiMap I.sndPiMap where\n  obj := Multifork.toPiFork\n  map {K₁ K₂} f :=\n    { hom := f.hom\n      w := by\n        rintro (_ | _)\n        · apply limit.hom_ext\n          simp\n        · apply limit.hom_ext\n          intros j\n          simp only [Multifork.toPiFork_π_app_one, Multifork.pi_condition, Category.assoc]\n          dsimp [sndPiMap]\n          simp }\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.toPiForkFunctor_map_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninst✝¹ : CategoryTheory.Limits.HasProduct I.left\ninst✝ : CategoryTheory.Limits.HasProduct I.right\nK₁ K₂ : CategoryTheory.Limits.Multifork I\nf : Quiver.Hom K₁ K₂\n⊢ Eq (I.toPiForkFunctor.map f).hom f.hom","decl":"/-- `Multifork.toPiFork` as a functor. -/\n@[simps]\nnoncomputable def toPiForkFunctor : Multifork I ⥤ Fork I.fstPiMap I.sndPiMap where\n  obj := Multifork.toPiFork\n  map {K₁ K₂} f :=\n    { hom := f.hom\n      w := by\n        rintro (_ | _)\n        · apply limit.hom_ext\n          simp\n        · apply limit.hom_ext\n          intros j\n          simp only [Multifork.toPiFork_π_app_one, Multifork.pi_condition, Category.assoc]\n          dsimp [sndPiMap]\n          simp }\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.ofPiForkFunctor_map_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninst✝¹ : CategoryTheory.Limits.HasProduct I.left\ninst✝ : CategoryTheory.Limits.HasProduct I.right\nK₁ K₂ : CategoryTheory.Limits.Fork I.fstPiMap I.sndPiMap\nf : Quiver.Hom K₁ K₂\n⊢ Eq (I.ofPiForkFunctor.map f).hom f.hom","decl":"/-- `Multifork.ofPiFork` as a functor. -/\n@[simps]\nnoncomputable def ofPiForkFunctor : Fork I.fstPiMap I.sndPiMap ⥤ Multifork I where\n  obj := Multifork.ofPiFork I\n  map {K₁ K₂} f :=\n    { hom := f.hom\n      w := by rintro (_ | _) <;> simp }\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.ofPiForkFunctor_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninst✝¹ : CategoryTheory.Limits.HasProduct I.left\ninst✝ : CategoryTheory.Limits.HasProduct I.right\nc : CategoryTheory.Limits.Fork I.fstPiMap I.sndPiMap\n⊢ Eq (I.ofPiForkFunctor.obj c) (CategoryTheory.Limits.Multifork.ofPiFork I c)","decl":"/-- `Multifork.ofPiFork` as a functor. -/\n@[simps]\nnoncomputable def ofPiForkFunctor : Fork I.fstPiMap I.sndPiMap ⥤ Multifork I where\n  obj := Multifork.ofPiFork I\n  map {K₁ K₂} f :=\n    { hom := f.hom\n      w := by rintro (_ | _) <;> simp }\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.multiforkEquivPiFork_unitIso","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninst✝¹ : CategoryTheory.Limits.HasProduct I.left\ninst✝ : CategoryTheory.Limits.HasProduct I.right\n⊢ Eq I.multiforkEquivPiFork.unitIso (CategoryTheory.NatIso.ofComponents (fun K => CategoryTheory.Limits.Cones.ext (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.Limits.Multifork I)).obj K).pt) ⋯) ⋯)","decl":"/-- The category of multiforks is equivalent to the category of forks over `∏ᶜ I.left ⇉ ∏ᶜ I.right`.\nIt then follows from `CategoryTheory.IsLimit.ofPreservesConeTerminal` (or `reflects`) that it\npreserves and reflects limit cones.\n-/\n@[simps]\nnoncomputable def multiforkEquivPiFork : Multifork I ≌ Fork I.fstPiMap I.sndPiMap where\n  functor := toPiForkFunctor I\n  inverse := ofPiForkFunctor I\n  unitIso :=\n    NatIso.ofComponents fun K =>\n      Cones.ext (Iso.refl _) (by\n        rintro (_ | _) <;> simp [← Fork.app_one_eq_ι_comp_left])\n  counitIso :=\n    NatIso.ofComponents fun K => Fork.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.multiforkEquivPiFork_inverse","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninst✝¹ : CategoryTheory.Limits.HasProduct I.left\ninst✝ : CategoryTheory.Limits.HasProduct I.right\n⊢ Eq I.multiforkEquivPiFork.inverse I.ofPiForkFunctor","decl":"/-- The category of multiforks is equivalent to the category of forks over `∏ᶜ I.left ⇉ ∏ᶜ I.right`.\nIt then follows from `CategoryTheory.IsLimit.ofPreservesConeTerminal` (or `reflects`) that it\npreserves and reflects limit cones.\n-/\n@[simps]\nnoncomputable def multiforkEquivPiFork : Multifork I ≌ Fork I.fstPiMap I.sndPiMap where\n  functor := toPiForkFunctor I\n  inverse := ofPiForkFunctor I\n  unitIso :=\n    NatIso.ofComponents fun K =>\n      Cones.ext (Iso.refl _) (by\n        rintro (_ | _) <;> simp [← Fork.app_one_eq_ι_comp_left])\n  counitIso :=\n    NatIso.ofComponents fun K => Fork.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.multiforkEquivPiFork_counitIso","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninst✝¹ : CategoryTheory.Limits.HasProduct I.left\ninst✝ : CategoryTheory.Limits.HasProduct I.right\n⊢ Eq I.multiforkEquivPiFork.counitIso (CategoryTheory.NatIso.ofComponents (fun K => CategoryTheory.Limits.Fork.ext (CategoryTheory.Iso.refl ((I.ofPiForkFunctor.comp I.toPiForkFunctor).obj K).pt) ⋯) ⋯)","decl":"/-- The category of multiforks is equivalent to the category of forks over `∏ᶜ I.left ⇉ ∏ᶜ I.right`.\nIt then follows from `CategoryTheory.IsLimit.ofPreservesConeTerminal` (or `reflects`) that it\npreserves and reflects limit cones.\n-/\n@[simps]\nnoncomputable def multiforkEquivPiFork : Multifork I ≌ Fork I.fstPiMap I.sndPiMap where\n  functor := toPiForkFunctor I\n  inverse := ofPiForkFunctor I\n  unitIso :=\n    NatIso.ofComponents fun K =>\n      Cones.ext (Iso.refl _) (by\n        rintro (_ | _) <;> simp [← Fork.app_one_eq_ι_comp_left])\n  counitIso :=\n    NatIso.ofComponents fun K => Fork.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.multiforkEquivPiFork_functor","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninst✝¹ : CategoryTheory.Limits.HasProduct I.left\ninst✝ : CategoryTheory.Limits.HasProduct I.right\n⊢ Eq I.multiforkEquivPiFork.functor I.toPiForkFunctor","decl":"/-- The category of multiforks is equivalent to the category of forks over `∏ᶜ I.left ⇉ ∏ᶜ I.right`.\nIt then follows from `CategoryTheory.IsLimit.ofPreservesConeTerminal` (or `reflects`) that it\npreserves and reflects limit cones.\n-/\n@[simps]\nnoncomputable def multiforkEquivPiFork : Multifork I ≌ Fork I.fstPiMap I.sndPiMap where\n  functor := toPiForkFunctor I\n  inverse := ofPiForkFunctor I\n  unitIso :=\n    NatIso.ofComponents fun K =>\n      Cones.ext (Iso.refl _) (by\n        rintro (_ | _) <;> simp [← Fork.app_one_eq_ι_comp_left])\n  counitIso :=\n    NatIso.ofComponents fun K => Fork.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.π_eq_app_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\nK : CategoryTheory.Limits.Multicofork I\nb : I.R\n⊢ Eq (K.ι.app (CategoryTheory.Limits.WalkingMultispan.right b)) (K.π b)","decl":"@[simp]\ntheorem π_eq_app_right (b) : K.ι.app (WalkingMultispan.right _) = K.π b :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.fst_app_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\nK : CategoryTheory.Limits.Multicofork I\na : I.L\n⊢ Eq (K.ι.app (CategoryTheory.Limits.WalkingMultispan.left a)) (CategoryTheory.CategoryStruct.comp (I.fst a) (K.π (I.fstFrom a)))","decl":"@[simp]\ntheorem fst_app_right (a) : K.ι.app (WalkingMultispan.left a) = I.fst a ≫ K.π _ := by\n  rw [← K.w (WalkingMultispan.Hom.fst a)]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.snd_app_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\nK : CategoryTheory.Limits.Multicofork I\na : I.L\n⊢ Eq (K.ι.app (CategoryTheory.Limits.WalkingMultispan.left a)) (CategoryTheory.CategoryStruct.comp (I.snd a) (K.π (I.sndFrom a)))","decl":"@[reassoc]\ntheorem snd_app_right (a) : K.ι.app (WalkingMultispan.left a) = I.snd a ≫ K.π _ := by\n  rw [← K.w (WalkingMultispan.Hom.snd a)]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.snd_app_right_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\nK : CategoryTheory.Limits.Multicofork I\na : I.L\nZ : C\nh : Quiver.Hom (((CategoryTheory.Functor.const (CategoryTheory.Limits.WalkingMultispan I.fstFrom I.sndFrom)).obj K.pt).obj (CategoryTheory.Limits.WalkingMultispan.left a)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.ι.app (CategoryTheory.Limits.WalkingMultispan.left a)) h) (CategoryTheory.CategoryStruct.comp (I.snd a) (CategoryTheory.CategoryStruct.comp (K.π (I.sndFrom a)) h))","decl":"@[reassoc]\ntheorem snd_app_right (a) : K.ι.app (WalkingMultispan.left a) = I.snd a ≫ K.π _ := by\n  rw [← K.w (WalkingMultispan.Hom.snd a)]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.π_comp_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\nK₁ K₂ : CategoryTheory.Limits.Multicofork I\nf : Quiver.Hom K₁ K₂\nb : I.R\nZ : C\nh : Quiver.Hom K₂.pt Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K₁.π b) (CategoryTheory.CategoryStruct.comp f.hom h)) (CategoryTheory.CategoryStruct.comp (K₂.π b) h)","decl":"@[reassoc (attr := simp)]\nlemma π_comp_hom (K₁ K₂ : Multicofork I) (f : K₁ ⟶ K₂) (b : I.R) : K₁.π b ≫ f.hom = K₂.π b :=\n  f.w _\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.π_comp_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\nK₁ K₂ : CategoryTheory.Limits.Multicofork I\nf : Quiver.Hom K₁ K₂\nb : I.R\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K₁.π b) f.hom) (K₂.π b)","decl":"@[reassoc (attr := simp)]\nlemma π_comp_hom (K₁ K₂ : Multicofork I) (f : K₁ ⟶ K₂) (b : I.R) : K₁.π b ≫ f.hom = K₂.π b :=\n  f.w _\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.ofπ_ι_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\nP : C\nπ : (b : I.R) → Quiver.Hom (I.right b) P\nw : ∀ (a : I.L), Eq (CategoryTheory.CategoryStruct.comp (I.fst a) (π (I.fstFrom a))) (CategoryTheory.CategoryStruct.comp (I.snd a) (π (I.sndFrom a)))\nx : CategoryTheory.Limits.WalkingMultispan I.fstFrom I.sndFrom\n⊢ Eq ((CategoryTheory.Limits.Multicofork.ofπ I P π w).ι.app x) (CategoryTheory.Limits.MultispanIndex.multispan.match_1 I (fun x => Quiver.Hom (I.multispan.obj x) (((CategoryTheory.Functor.const (CategoryTheory.Limits.WalkingMultispan I.fstFrom I.sndFrom)).obj P).obj x)) x (fun a => CategoryTheory.CategoryStruct.comp (I.fst a) (π (I.fstFrom a))) fun a => π a)","decl":"/-- Construct a multicofork using a collection `π` of morphisms. -/\n@[simps]\ndef ofπ (I : MultispanIndex.{w, w'} C) (P : C) (π : ∀ b, I.right b ⟶ P)\n    (w : ∀ a, I.fst a ≫ π (I.fstFrom a) = I.snd a ≫ π (I.sndFrom a)) : Multicofork I where\n  pt := P\n  ι :=\n    { app := fun x =>\n        match x with\n        | WalkingMultispan.left a => I.fst a ≫ π _\n        | WalkingMultispan.right _ => π _\n      naturality := by\n        rintro (_ | _) (_ | _) (_ | _ | _) <;> dsimp <;>\n          simp only [Functor.map_id, MultispanIndex.multispan_obj_left,\n            Category.id_comp, Category.comp_id, MultispanIndex.multispan_obj_right]\n        symm\n        apply w }\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.ofπ_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\nP : C\nπ : (b : I.R) → Quiver.Hom (I.right b) P\nw : ∀ (a : I.L), Eq (CategoryTheory.CategoryStruct.comp (I.fst a) (π (I.fstFrom a))) (CategoryTheory.CategoryStruct.comp (I.snd a) (π (I.sndFrom a)))\n⊢ Eq (CategoryTheory.Limits.Multicofork.ofπ I P π w).pt P","decl":"/-- Construct a multicofork using a collection `π` of morphisms. -/\n@[simps]\ndef ofπ (I : MultispanIndex.{w, w'} C) (P : C) (π : ∀ b, I.right b ⟶ P)\n    (w : ∀ a, I.fst a ≫ π (I.fstFrom a) = I.snd a ≫ π (I.sndFrom a)) : Multicofork I where\n  pt := P\n  ι :=\n    { app := fun x =>\n        match x with\n        | WalkingMultispan.left a => I.fst a ≫ π _\n        | WalkingMultispan.right _ => π _\n      naturality := by\n        rintro (_ | _) (_ | _) (_ | _ | _) <;> dsimp <;>\n          simp only [Functor.map_id, MultispanIndex.multispan_obj_left,\n            Category.id_comp, Category.comp_id, MultispanIndex.multispan_obj_right]\n        symm\n        apply w }\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\nK : CategoryTheory.Limits.Multicofork I\na : I.L\nZ : C\nh : Quiver.Hom K.pt Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (I.fst a) (CategoryTheory.CategoryStruct.comp (K.π (I.fstFrom a)) h)) (CategoryTheory.CategoryStruct.comp (I.snd a) (CategoryTheory.CategoryStruct.comp (K.π (I.sndFrom a)) h))","decl":"@[reassoc (attr := simp)]\ntheorem condition (a) : I.fst a ≫ K.π (I.fstFrom a) = I.snd a ≫ K.π (I.sndFrom a) := by\n  rw [← K.snd_app_right, ← K.fst_app_right]\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\nK : CategoryTheory.Limits.Multicofork I\na : I.L\n⊢ Eq (CategoryTheory.CategoryStruct.comp (I.fst a) (K.π (I.fstFrom a))) (CategoryTheory.CategoryStruct.comp (I.snd a) (K.π (I.sndFrom a)))","decl":"@[reassoc (attr := simp)]\ntheorem condition (a) : I.fst a ≫ K.π (I.fstFrom a) = I.snd a ≫ K.π (I.sndFrom a) := by\n  rw [← K.snd_app_right, ← K.fst_app_right]\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.IsColimit.mk_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\nK : CategoryTheory.Limits.Multicofork I\ndesc : (E : CategoryTheory.Limits.Multicofork I) → Quiver.Hom K.pt E.pt\nfac : ∀ (E : CategoryTheory.Limits.Multicofork I) (i : I.R), Eq (CategoryTheory.CategoryStruct.comp (K.π i) (desc E)) (E.π i)\nuniq : ∀ (E : CategoryTheory.Limits.Multicofork I) (m : Quiver.Hom K.pt E.pt), (∀ (i : I.R), Eq (CategoryTheory.CategoryStruct.comp (K.π i) m) (E.π i)) → Eq m (desc E)\nE : CategoryTheory.Limits.Multicofork I\n⊢ Eq ((CategoryTheory.Limits.Multicofork.IsColimit.mk K desc fac uniq).desc E) (desc E)","decl":"/-- This definition provides a convenient way to show that a multicofork is a colimit. -/\n@[simps]\ndef IsColimit.mk (desc : ∀ E : Multicofork I, K.pt ⟶ E.pt)\n    (fac : ∀ (E : Multicofork I) (i : I.R), K.π i ≫ desc E = E.π i)\n    (uniq : ∀ (E : Multicofork I) (m : K.pt ⟶ E.pt), (∀ i : I.R, K.π i ≫ m = E.π i) → m = desc E) :\n    IsColimit K :=\n  { desc\n    fac := by\n      rintro S (a | b)\n      · rw [← K.w (WalkingMultispan.Hom.fst a), ← S.w (WalkingMultispan.Hom.fst a),\n          Category.assoc]\n        congr 1\n        apply fac\n      · apply fac\n    uniq := by\n      intro S m hm\n      apply uniq\n      intro i\n      apply hm }\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.sigma_condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\nK : CategoryTheory.Limits.Multicofork I\ninst✝¹ : CategoryTheory.Limits.HasCoproduct I.left\ninst✝ : CategoryTheory.Limits.HasCoproduct I.right\n⊢ Eq (CategoryTheory.CategoryStruct.comp I.fstSigmaMap (CategoryTheory.Limits.Sigma.desc K.π)) (CategoryTheory.CategoryStruct.comp I.sndSigmaMap (CategoryTheory.Limits.Sigma.desc K.π))","decl":"@[reassoc (attr := simp)]\ntheorem sigma_condition : I.fstSigmaMap ≫ Sigma.desc K.π = I.sndSigmaMap ≫ Sigma.desc K.π := by\n  ext\n  simp\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.sigma_condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\nK : CategoryTheory.Limits.Multicofork I\ninst✝¹ : CategoryTheory.Limits.HasCoproduct I.left\ninst✝ : CategoryTheory.Limits.HasCoproduct I.right\nZ : C\nh : Quiver.Hom K.pt Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp I.fstSigmaMap (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.desc K.π) h)) (CategoryTheory.CategoryStruct.comp I.sndSigmaMap (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.desc K.π) h))","decl":"@[reassoc (attr := simp)]\ntheorem sigma_condition : I.fstSigmaMap ≫ Sigma.desc K.π = I.sndSigmaMap ≫ Sigma.desc K.π := by\n  ext\n  simp\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.toSigmaCofork_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct I.left\ninst✝ : CategoryTheory.Limits.HasCoproduct I.right\nK : CategoryTheory.Limits.Multicofork I\n⊢ Eq K.toSigmaCofork.pt K.pt","decl":"/-- Given a multicofork, we may obtain a cofork over `∐ I.left ⇉ ∐ I.right`. -/\n@[simps pt]\nnoncomputable def toSigmaCofork (K : Multicofork I) : Cofork I.fstSigmaMap I.sndSigmaMap where\n  pt := K.pt\n  ι :=\n    { app := fun x =>\n        match x with\n        | WalkingParallelPair.zero => I.fstSigmaMap ≫ Sigma.desc K.π\n        | WalkingParallelPair.one => Sigma.desc K.π\n      naturality := by\n        rintro (_ | _) (_ | _) (_ | _ | _) <;> dsimp <;>\n          simp only [Functor.map_id, parallelPair_obj_zero,\n            parallelPair_obj_one, sigma_condition, Category.id_comp, Category.comp_id] }\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.toSigmaCofork_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\nK : CategoryTheory.Limits.Multicofork I\ninst✝¹ : CategoryTheory.Limits.HasCoproduct I.left\ninst✝ : CategoryTheory.Limits.HasCoproduct I.right\n⊢ Eq K.toSigmaCofork.π (CategoryTheory.Limits.Sigma.desc K.π)","decl":"@[simp]\ntheorem toSigmaCofork_π : K.toSigmaCofork.π = Sigma.desc K.π :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.ofSigmaCofork_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct I.left\ninst✝ : CategoryTheory.Limits.HasCoproduct I.right\nc : CategoryTheory.Limits.Cofork I.fstSigmaMap I.sndSigmaMap\n⊢ Eq (CategoryTheory.Limits.Multicofork.ofSigmaCofork I c).pt c.pt","decl":"/-- Given a cofork over `∐ I.left ⇉ ∐ I.right`, we may obtain a multicofork. -/\n@[simps pt]\nnoncomputable def ofSigmaCofork (c : Cofork I.fstSigmaMap I.sndSigmaMap) : Multicofork I where\n  pt := c.pt\n  ι :=\n    { app := fun x =>\n        match x with\n        | WalkingMultispan.left a => (Sigma.ι I.left a :) ≫ I.fstSigmaMap ≫ c.π\n        | WalkingMultispan.right b => (Sigma.ι I.right b :) ≫ c.π\n      naturality := by\n        rintro (_ | _) (_ | _) (_ | _ | _)\n        · simp\n        · simp\n        · simp [c.condition]\n        · simp }\n\n-- Porting note: https://github.com/leanprover-community/mathlib4/issues/10675\n-- dsimp cannot prove this, once ofSigmaCofork_ι_app_right' is defined\n"}
{"name":"CategoryTheory.Limits.Multicofork.ofSigmaCofork_ι_app_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct I.left\ninst✝ : CategoryTheory.Limits.HasCoproduct I.right\nc : CategoryTheory.Limits.Cofork I.fstSigmaMap I.sndSigmaMap\na : I.L\n⊢ Eq ((CategoryTheory.Limits.Multicofork.ofSigmaCofork I c).ι.app (CategoryTheory.Limits.WalkingMultispan.left a)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι I.left a) (CategoryTheory.CategoryStruct.comp I.fstSigmaMap c.π))","decl":"@[simp]\ntheorem ofSigmaCofork_ι_app_left (c : Cofork I.fstSigmaMap I.sndSigmaMap) (a) :\n    (ofSigmaCofork I c).ι.app (WalkingMultispan.left a) =\n      (Sigma.ι I.left a :) ≫ I.fstSigmaMap ≫ c.π :=\n  rfl\n\n-- @[simp] -- Porting note: LHS simplifies to obtain the normal form below\n"}
{"name":"CategoryTheory.Limits.Multicofork.ofSigmaCofork_ι_app_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct I.left\ninst✝ : CategoryTheory.Limits.HasCoproduct I.right\nc : CategoryTheory.Limits.Cofork I.fstSigmaMap I.sndSigmaMap\nb : I.R\n⊢ Eq ((CategoryTheory.Limits.Multicofork.ofSigmaCofork I c).ι.app (CategoryTheory.Limits.WalkingMultispan.right b)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι I.right b) c.π)","decl":"theorem ofSigmaCofork_ι_app_right (c : Cofork I.fstSigmaMap I.sndSigmaMap) (b) :\n    (ofSigmaCofork I c).ι.app (WalkingMultispan.right b) = (Sigma.ι I.right b :) ≫ c.π :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.ofSigmaCofork_ι_app_right'","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct I.left\ninst✝ : CategoryTheory.Limits.HasCoproduct I.right\nc : CategoryTheory.Limits.Cofork I.fstSigmaMap I.sndSigmaMap\nb : I.R\n⊢ Eq ((CategoryTheory.Limits.Multicofork.ofSigmaCofork I c).π b) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι I.right b) c.π)","decl":"@[simp]\ntheorem ofSigmaCofork_ι_app_right' (c : Cofork I.fstSigmaMap I.sndSigmaMap) (b) :\n    π (ofSigmaCofork I c) b = (Sigma.ι I.right b :) ≫ c.π :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.toSigmaCoforkFunctor_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct I.left\ninst✝ : CategoryTheory.Limits.HasCoproduct I.right\nK : CategoryTheory.Limits.Multicofork I\n⊢ Eq (I.toSigmaCoforkFunctor.obj K) K.toSigmaCofork","decl":"/-- `Multicofork.toSigmaCofork` as a functor. -/\n@[simps]\nnoncomputable def toSigmaCoforkFunctor : Multicofork I ⥤ Cofork I.fstSigmaMap I.sndSigmaMap where\n  obj := Multicofork.toSigmaCofork\n  map {K₁ K₂} f :=\n  { hom := f.hom\n    w := by\n      rintro (_|_)\n      all_goals {\n        apply colimit.hom_ext\n        rintro ⟨j⟩\n        simp } }\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.toSigmaCoforkFunctor_map_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct I.left\ninst✝ : CategoryTheory.Limits.HasCoproduct I.right\nK₁ K₂ : CategoryTheory.Limits.Multicofork I\nf : Quiver.Hom K₁ K₂\n⊢ Eq (I.toSigmaCoforkFunctor.map f).hom f.hom","decl":"/-- `Multicofork.toSigmaCofork` as a functor. -/\n@[simps]\nnoncomputable def toSigmaCoforkFunctor : Multicofork I ⥤ Cofork I.fstSigmaMap I.sndSigmaMap where\n  obj := Multicofork.toSigmaCofork\n  map {K₁ K₂} f :=\n  { hom := f.hom\n    w := by\n      rintro (_|_)\n      all_goals {\n        apply colimit.hom_ext\n        rintro ⟨j⟩\n        simp } }\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.ofSigmaCoforkFunctor_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct I.left\ninst✝ : CategoryTheory.Limits.HasCoproduct I.right\nc : CategoryTheory.Limits.Cofork I.fstSigmaMap I.sndSigmaMap\n⊢ Eq (I.ofSigmaCoforkFunctor.obj c) (CategoryTheory.Limits.Multicofork.ofSigmaCofork I c)","decl":"/-- `Multicofork.ofSigmaCofork` as a functor. -/\n@[simps]\nnoncomputable def ofSigmaCoforkFunctor : Cofork I.fstSigmaMap I.sndSigmaMap ⥤ Multicofork I where\n  obj := Multicofork.ofSigmaCofork I\n  map {K₁ K₂} f :=\n    { hom := f.hom\n      w := by --sorry --by rintro (_ | _) <;> simp\n        rintro (_ | _)\n        -- porting note; in mathlib3, `simp` worked. What seems to be happening is that\n        -- the `simp` set is not confluent, and mathlib3 found\n        -- `Multicofork.ofSigmaCofork_ι_app_left` before `Multicofork.fst_app_right`,\n        -- but mathlib4 finds `Multicofork.fst_app_right` first.\n        { simp [-Multicofork.fst_app_right] }\n        -- Porting note: similarly here, the `simp` set seems to be non-confluent\n        { simp [-Multicofork.ofSigmaCofork_pt] } }\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.ofSigmaCoforkFunctor_map_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct I.left\ninst✝ : CategoryTheory.Limits.HasCoproduct I.right\nK₁ K₂ : CategoryTheory.Limits.Cofork I.fstSigmaMap I.sndSigmaMap\nf : Quiver.Hom K₁ K₂\n⊢ Eq (I.ofSigmaCoforkFunctor.map f).hom f.hom","decl":"/-- `Multicofork.ofSigmaCofork` as a functor. -/\n@[simps]\nnoncomputable def ofSigmaCoforkFunctor : Cofork I.fstSigmaMap I.sndSigmaMap ⥤ Multicofork I where\n  obj := Multicofork.ofSigmaCofork I\n  map {K₁ K₂} f :=\n    { hom := f.hom\n      w := by --sorry --by rintro (_ | _) <;> simp\n        rintro (_ | _)\n        -- porting note; in mathlib3, `simp` worked. What seems to be happening is that\n        -- the `simp` set is not confluent, and mathlib3 found\n        -- `Multicofork.ofSigmaCofork_ι_app_left` before `Multicofork.fst_app_right`,\n        -- but mathlib4 finds `Multicofork.fst_app_right` first.\n        { simp [-Multicofork.fst_app_right] }\n        -- Porting note: similarly here, the `simp` set seems to be non-confluent\n        { simp [-Multicofork.ofSigmaCofork_pt] } }\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.multicoforkEquivSigmaCofork_counitIso","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct I.left\ninst✝ : CategoryTheory.Limits.HasCoproduct I.right\n⊢ Eq I.multicoforkEquivSigmaCofork.counitIso (CategoryTheory.NatIso.ofComponents (fun K => CategoryTheory.Limits.Cofork.ext (CategoryTheory.Iso.refl ((I.ofSigmaCoforkFunctor.comp I.toSigmaCoforkFunctor).obj K).pt) ⋯) ⋯)","decl":"/--\nThe category of multicoforks is equivalent to the category of coforks over `∐ I.left ⇉ ∐ I.right`.\nIt then follows from `CategoryTheory.IsColimit.ofPreservesCoconeInitial` (or `reflects`) that\nit preserves and reflects colimit cocones.\n-/\n@[simps]\nnoncomputable def multicoforkEquivSigmaCofork :\n    Multicofork I ≌ Cofork I.fstSigmaMap I.sndSigmaMap where\n  functor := toSigmaCoforkFunctor I\n  inverse := ofSigmaCoforkFunctor I\n  unitIso := NatIso.ofComponents fun K => Cocones.ext (Iso.refl _) (by\n      rintro (_ | _) <;> simp)\n  counitIso := NatIso.ofComponents fun K =>\n    Cofork.ext (Iso.refl _)\n      (by\n        -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): in mathlib3 this was just `ext` and I don't know why it's not here\n        apply Limits.colimit.hom_ext\n        rintro ⟨j⟩\n        dsimp\n        simp only [Category.comp_id, colimit.ι_desc, Cofan.mk_ι_app]\n        rfl)\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.multicoforkEquivSigmaCofork_inverse","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct I.left\ninst✝ : CategoryTheory.Limits.HasCoproduct I.right\n⊢ Eq I.multicoforkEquivSigmaCofork.inverse I.ofSigmaCoforkFunctor","decl":"/--\nThe category of multicoforks is equivalent to the category of coforks over `∐ I.left ⇉ ∐ I.right`.\nIt then follows from `CategoryTheory.IsColimit.ofPreservesCoconeInitial` (or `reflects`) that\nit preserves and reflects colimit cocones.\n-/\n@[simps]\nnoncomputable def multicoforkEquivSigmaCofork :\n    Multicofork I ≌ Cofork I.fstSigmaMap I.sndSigmaMap where\n  functor := toSigmaCoforkFunctor I\n  inverse := ofSigmaCoforkFunctor I\n  unitIso := NatIso.ofComponents fun K => Cocones.ext (Iso.refl _) (by\n      rintro (_ | _) <;> simp)\n  counitIso := NatIso.ofComponents fun K =>\n    Cofork.ext (Iso.refl _)\n      (by\n        -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): in mathlib3 this was just `ext` and I don't know why it's not here\n        apply Limits.colimit.hom_ext\n        rintro ⟨j⟩\n        dsimp\n        simp only [Category.comp_id, colimit.ι_desc, Cofan.mk_ι_app]\n        rfl)\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.multicoforkEquivSigmaCofork_unitIso","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct I.left\ninst✝ : CategoryTheory.Limits.HasCoproduct I.right\n⊢ Eq I.multicoforkEquivSigmaCofork.unitIso (CategoryTheory.NatIso.ofComponents (fun K => CategoryTheory.Limits.Cocones.ext (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.Limits.Multicofork I)).obj K).pt) ⋯) ⋯)","decl":"/--\nThe category of multicoforks is equivalent to the category of coforks over `∐ I.left ⇉ ∐ I.right`.\nIt then follows from `CategoryTheory.IsColimit.ofPreservesCoconeInitial` (or `reflects`) that\nit preserves and reflects colimit cocones.\n-/\n@[simps]\nnoncomputable def multicoforkEquivSigmaCofork :\n    Multicofork I ≌ Cofork I.fstSigmaMap I.sndSigmaMap where\n  functor := toSigmaCoforkFunctor I\n  inverse := ofSigmaCoforkFunctor I\n  unitIso := NatIso.ofComponents fun K => Cocones.ext (Iso.refl _) (by\n      rintro (_ | _) <;> simp)\n  counitIso := NatIso.ofComponents fun K =>\n    Cofork.ext (Iso.refl _)\n      (by\n        -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): in mathlib3 this was just `ext` and I don't know why it's not here\n        apply Limits.colimit.hom_ext\n        rintro ⟨j⟩\n        dsimp\n        simp only [Category.comp_id, colimit.ι_desc, Cofan.mk_ι_app]\n        rfl)\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.multicoforkEquivSigmaCofork_functor","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct I.left\ninst✝ : CategoryTheory.Limits.HasCoproduct I.right\n⊢ Eq I.multicoforkEquivSigmaCofork.functor I.toSigmaCoforkFunctor","decl":"/--\nThe category of multicoforks is equivalent to the category of coforks over `∐ I.left ⇉ ∐ I.right`.\nIt then follows from `CategoryTheory.IsColimit.ofPreservesCoconeInitial` (or `reflects`) that\nit preserves and reflects colimit cocones.\n-/\n@[simps]\nnoncomputable def multicoforkEquivSigmaCofork :\n    Multicofork I ≌ Cofork I.fstSigmaMap I.sndSigmaMap where\n  functor := toSigmaCoforkFunctor I\n  inverse := ofSigmaCoforkFunctor I\n  unitIso := NatIso.ofComponents fun K => Cocones.ext (Iso.refl _) (by\n      rintro (_ | _) <;> simp)\n  counitIso := NatIso.ofComponents fun K =>\n    Cofork.ext (Iso.refl _)\n      (by\n        -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): in mathlib3 this was just `ext` and I don't know why it's not here\n        apply Limits.colimit.hom_ext\n        rintro ⟨j⟩\n        dsimp\n        simp only [Category.comp_id, colimit.ι_desc, Cofan.mk_ι_app]\n        rfl)\n\n"}
{"name":"CategoryTheory.Limits.Multiequalizer.multifork_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninst✝ : CategoryTheory.Limits.HasMultiequalizer I\na : I.L\n⊢ Eq ((CategoryTheory.Limits.Multiequalizer.multifork I).ι a) (CategoryTheory.Limits.Multiequalizer.ι I a)","decl":"@[simp]\ntheorem multifork_ι (a) : (Multiequalizer.multifork I).ι a = Multiequalizer.ι I a :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multiequalizer.multifork_π_app_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninst✝ : CategoryTheory.Limits.HasMultiequalizer I\na : I.L\n⊢ Eq ((CategoryTheory.Limits.Multiequalizer.multifork I).π.app (CategoryTheory.Limits.WalkingMulticospan.left a)) (CategoryTheory.Limits.Multiequalizer.ι I a)","decl":"@[simp]\ntheorem multifork_π_app_left (a) :\n    (Multiequalizer.multifork I).π.app (WalkingMulticospan.left a) = Multiequalizer.ι I a :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multiequalizer.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninst✝ : CategoryTheory.Limits.HasMultiequalizer I\nb : I.R\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multiequalizer.ι I (I.fstTo b)) (I.fst b)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multiequalizer.ι I (I.sndTo b)) (I.snd b))","decl":"@[reassoc]\ntheorem condition (b) :\n    Multiequalizer.ι I (I.fstTo b) ≫ I.fst b = Multiequalizer.ι I (I.sndTo b) ≫ I.snd b :=\n  Multifork.condition _ _\n\n"}
{"name":"CategoryTheory.Limits.Multiequalizer.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninst✝ : CategoryTheory.Limits.HasMultiequalizer I\nb : I.R\nZ : C\nh : Quiver.Hom (I.right b) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multiequalizer.ι I (I.fstTo b)) (CategoryTheory.CategoryStruct.comp (I.fst b) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multiequalizer.ι I (I.sndTo b)) (CategoryTheory.CategoryStruct.comp (I.snd b) h))","decl":"@[reassoc]\ntheorem condition (b) :\n    Multiequalizer.ι I (I.fstTo b) ≫ I.fst b = Multiequalizer.ι I (I.sndTo b) ≫ I.snd b :=\n  Multifork.condition _ _\n\n"}
{"name":"CategoryTheory.Limits.Multiequalizer.lift_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninst✝ : CategoryTheory.Limits.HasMultiequalizer I\nW : C\nk : (a : I.L) → Quiver.Hom W (I.left a)\nh : ∀ (b : I.R), Eq (CategoryTheory.CategoryStruct.comp (k (I.fstTo b)) (I.fst b)) (CategoryTheory.CategoryStruct.comp (k (I.sndTo b)) (I.snd b))\na : I.L\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multiequalizer.lift I W k h) (CategoryTheory.Limits.Multiequalizer.ι I a)) (k a)","decl":"@[reassoc]\ntheorem lift_ι (W : C) (k : ∀ a, W ⟶ I.left a)\n    (h : ∀ b, k (I.fstTo b) ≫ I.fst b = k (I.sndTo b) ≫ I.snd b) (a) :\n    Multiequalizer.lift I _ k h ≫ Multiequalizer.ι I a = k _ :=\n  limit.lift_π _ _\n\n"}
{"name":"CategoryTheory.Limits.Multiequalizer.lift_ι_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninst✝ : CategoryTheory.Limits.HasMultiequalizer I\nW : C\nk : (a : I.L) → Quiver.Hom W (I.left a)\nh✝ : ∀ (b : I.R), Eq (CategoryTheory.CategoryStruct.comp (k (I.fstTo b)) (I.fst b)) (CategoryTheory.CategoryStruct.comp (k (I.sndTo b)) (I.snd b))\na : I.L\nZ : C\nh : Quiver.Hom (I.left a) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multiequalizer.lift I W k h✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multiequalizer.ι I a) h)) (CategoryTheory.CategoryStruct.comp (k a) h)","decl":"@[reassoc]\ntheorem lift_ι (W : C) (k : ∀ a, W ⟶ I.left a)\n    (h : ∀ b, k (I.fstTo b) ≫ I.fst b = k (I.sndTo b) ≫ I.snd b) (a) :\n    Multiequalizer.lift I _ k h ≫ Multiequalizer.ι I a = k _ :=\n  limit.lift_π _ _\n\n"}
{"name":"CategoryTheory.Limits.Multiequalizer.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninst✝ : CategoryTheory.Limits.HasMultiequalizer I\nW : C\ni j : Quiver.Hom W (CategoryTheory.Limits.multiequalizer I)\nh : ∀ (a : I.L), Eq (CategoryTheory.CategoryStruct.comp i (CategoryTheory.Limits.Multiequalizer.ι I a)) (CategoryTheory.CategoryStruct.comp j (CategoryTheory.Limits.Multiequalizer.ι I a))\n⊢ Eq i j","decl":"@[ext]\ntheorem hom_ext {W : C} (i j : W ⟶ multiequalizer I)\n    (h : ∀ a, i ≫ Multiequalizer.ι I a = j ≫ Multiequalizer.ι I a) : i = j :=\n  Multifork.IsLimit.hom_ext (limit.isLimit _) h\n\n"}
{"name":"CategoryTheory.Limits.Multiequalizer.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninst✝ : CategoryTheory.Limits.HasMultiequalizer I\nW : C\ni j : Quiver.Hom W (CategoryTheory.Limits.multiequalizer I)\n⊢ Iff (Eq i j) (∀ (a : I.L), Eq (CategoryTheory.CategoryStruct.comp i (CategoryTheory.Limits.Multiequalizer.ι I a)) (CategoryTheory.CategoryStruct.comp j (CategoryTheory.Limits.Multiequalizer.ι I a)))","decl":"@[ext]\ntheorem hom_ext {W : C} (i j : W ⟶ multiequalizer I)\n    (h : ∀ a, i ≫ Multiequalizer.ι I a = j ≫ Multiequalizer.ι I a) : i = j :=\n  Multifork.IsLimit.hom_ext (limit.isLimit _) h\n\n"}
{"name":"CategoryTheory.Limits.Multiequalizer.instHasEqualizerFstPiMapSndPiMap","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninst✝² : CategoryTheory.Limits.HasMultiequalizer I\ninst✝¹ : CategoryTheory.Limits.HasProduct I.left\ninst✝ : CategoryTheory.Limits.HasProduct I.right\n⊢ CategoryTheory.Limits.HasEqualizer I.fstPiMap I.sndPiMap","decl":"instance : HasEqualizer I.fstPiMap I.sndPiMap :=\n  ⟨⟨⟨_, IsLimit.ofPreservesConeTerminal I.multiforkEquivPiFork.functor (limit.isLimit _)⟩⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.Multiequalizer.ιPi_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninst✝² : CategoryTheory.Limits.HasMultiequalizer I\ninst✝¹ : CategoryTheory.Limits.HasProduct I.left\ninst✝ : CategoryTheory.Limits.HasProduct I.right\na : I.L\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multiequalizer.ιPi I) (CategoryTheory.Limits.Pi.π I.left a)) (CategoryTheory.Limits.Multiequalizer.ι I a)","decl":"@[reassoc (attr := simp)]\ntheorem ιPi_π (a) : ιPi I ≫ Pi.π I.left a = ι I a := by\n  rw [ιPi, Category.assoc, ← Iso.eq_inv_comp, isoEqualizer]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.Multiequalizer.ιPi_π_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninst✝² : CategoryTheory.Limits.HasMultiequalizer I\ninst✝¹ : CategoryTheory.Limits.HasProduct I.left\ninst✝ : CategoryTheory.Limits.HasProduct I.right\na : I.L\nZ : C\nh : Quiver.Hom (I.left a) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multiequalizer.ιPi I) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π I.left a) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multiequalizer.ι I a) h)","decl":"@[reassoc (attr := simp)]\ntheorem ιPi_π (a) : ιPi I ≫ Pi.π I.left a = ι I a := by\n  rw [ιPi, Category.assoc, ← Iso.eq_inv_comp, isoEqualizer]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.Multiequalizer.instMonoιPi","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninst✝² : CategoryTheory.Limits.HasMultiequalizer I\ninst✝¹ : CategoryTheory.Limits.HasProduct I.left\ninst✝ : CategoryTheory.Limits.HasProduct I.right\n⊢ CategoryTheory.Mono (CategoryTheory.Limits.Multiequalizer.ιPi I)","decl":"instance : Mono (ιPi I) := mono_comp _ _\n\n"}
{"name":"CategoryTheory.Limits.Multicoequalizer.multicofork_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninst✝ : CategoryTheory.Limits.HasMulticoequalizer I\nb : I.R\n⊢ Eq ((CategoryTheory.Limits.Multicoequalizer.multicofork I).π b) (CategoryTheory.Limits.Multicoequalizer.π I b)","decl":"@[simp]\ntheorem multicofork_π (b) : (Multicoequalizer.multicofork I).π b = Multicoequalizer.π I b :=\n  rfl\n\n-- @[simp] -- Porting note: LHS simplifies to obtain the normal form below\n"}
{"name":"CategoryTheory.Limits.Multicoequalizer.multicofork_ι_app_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninst✝ : CategoryTheory.Limits.HasMulticoequalizer I\nb : I.R\n⊢ Eq ((CategoryTheory.Limits.Multicoequalizer.multicofork I).ι.app (CategoryTheory.Limits.WalkingMultispan.right b)) (CategoryTheory.Limits.Multicoequalizer.π I b)","decl":"theorem multicofork_ι_app_right (b) :\n    (Multicoequalizer.multicofork I).ι.app (WalkingMultispan.right b) = Multicoequalizer.π I b :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multicoequalizer.multicofork_ι_app_right'","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninst✝ : CategoryTheory.Limits.HasMulticoequalizer I\nb : I.R\n⊢ Eq (CategoryTheory.Limits.colimit.ι I.multispan (CategoryTheory.Limits.WalkingMultispan.right b)) (CategoryTheory.Limits.Multicoequalizer.π I b)","decl":"@[simp]\ntheorem multicofork_ι_app_right' (b) :\n    colimit.ι (MultispanIndex.multispan I) (WalkingMultispan.right b) = π I b :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multicoequalizer.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninst✝ : CategoryTheory.Limits.HasMulticoequalizer I\na : I.L\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.multicoequalizer I) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (I.fst a) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multicoequalizer.π I (I.fstFrom a)) h)) (CategoryTheory.CategoryStruct.comp (I.snd a) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multicoequalizer.π I (I.sndFrom a)) h))","decl":"@[reassoc]\ntheorem condition (a) :\n    I.fst a ≫ Multicoequalizer.π I (I.fstFrom a) = I.snd a ≫ Multicoequalizer.π I (I.sndFrom a) :=\n  Multicofork.condition _ _\n\n"}
{"name":"CategoryTheory.Limits.Multicoequalizer.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninst✝ : CategoryTheory.Limits.HasMulticoequalizer I\na : I.L\n⊢ Eq (CategoryTheory.CategoryStruct.comp (I.fst a) (CategoryTheory.Limits.Multicoequalizer.π I (I.fstFrom a))) (CategoryTheory.CategoryStruct.comp (I.snd a) (CategoryTheory.Limits.Multicoequalizer.π I (I.sndFrom a)))","decl":"@[reassoc]\ntheorem condition (a) :\n    I.fst a ≫ Multicoequalizer.π I (I.fstFrom a) = I.snd a ≫ Multicoequalizer.π I (I.sndFrom a) :=\n  Multicofork.condition _ _\n\n"}
{"name":"CategoryTheory.Limits.Multicoequalizer.π_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninst✝ : CategoryTheory.Limits.HasMulticoequalizer I\nW : C\nk : (b : I.R) → Quiver.Hom (I.right b) W\nh : ∀ (a : I.L), Eq (CategoryTheory.CategoryStruct.comp (I.fst a) (k (I.fstFrom a))) (CategoryTheory.CategoryStruct.comp (I.snd a) (k (I.sndFrom a)))\nb : I.R\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multicoequalizer.π I b) (CategoryTheory.Limits.Multicoequalizer.desc I W k h)) (k b)","decl":"@[reassoc]\ntheorem π_desc (W : C) (k : ∀ b, I.right b ⟶ W)\n    (h : ∀ a, I.fst a ≫ k (I.fstFrom a) = I.snd a ≫ k (I.sndFrom a)) (b) :\n    Multicoequalizer.π I b ≫ Multicoequalizer.desc I _ k h = k _ :=\n  colimit.ι_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.Multicoequalizer.π_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninst✝ : CategoryTheory.Limits.HasMulticoequalizer I\nW : C\nk : (b : I.R) → Quiver.Hom (I.right b) W\nh✝ : ∀ (a : I.L), Eq (CategoryTheory.CategoryStruct.comp (I.fst a) (k (I.fstFrom a))) (CategoryTheory.CategoryStruct.comp (I.snd a) (k (I.sndFrom a)))\nb : I.R\nZ : C\nh : Quiver.Hom W Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multicoequalizer.π I b) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multicoequalizer.desc I W k h✝) h)) (CategoryTheory.CategoryStruct.comp (k b) h)","decl":"@[reassoc]\ntheorem π_desc (W : C) (k : ∀ b, I.right b ⟶ W)\n    (h : ∀ a, I.fst a ≫ k (I.fstFrom a) = I.snd a ≫ k (I.sndFrom a)) (b) :\n    Multicoequalizer.π I b ≫ Multicoequalizer.desc I _ k h = k _ :=\n  colimit.ι_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.Multicoequalizer.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninst✝ : CategoryTheory.Limits.HasMulticoequalizer I\nW : C\ni j : Quiver.Hom (CategoryTheory.Limits.multicoequalizer I) W\n⊢ Iff (Eq i j) (∀ (b : I.R), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multicoequalizer.π I b) i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multicoequalizer.π I b) j))","decl":"@[ext]\ntheorem hom_ext {W : C} (i j : multicoequalizer I ⟶ W)\n    (h : ∀ b, Multicoequalizer.π I b ≫ i = Multicoequalizer.π I b ≫ j) : i = j :=\n  colimit.hom_ext\n    (by\n      rintro (a | b)\n      · simp_rw [← colimit.w I.multispan (WalkingMultispan.Hom.fst a), Category.assoc, h]\n      · apply h)\n\n"}
{"name":"CategoryTheory.Limits.Multicoequalizer.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninst✝ : CategoryTheory.Limits.HasMulticoequalizer I\nW : C\ni j : Quiver.Hom (CategoryTheory.Limits.multicoequalizer I) W\nh : ∀ (b : I.R), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multicoequalizer.π I b) i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multicoequalizer.π I b) j)\n⊢ Eq i j","decl":"@[ext]\ntheorem hom_ext {W : C} (i j : multicoequalizer I ⟶ W)\n    (h : ∀ b, Multicoequalizer.π I b ≫ i = Multicoequalizer.π I b ≫ j) : i = j :=\n  colimit.hom_ext\n    (by\n      rintro (a | b)\n      · simp_rw [← colimit.w I.multispan (WalkingMultispan.Hom.fst a), Category.assoc, h]\n      · apply h)\n\n"}
{"name":"CategoryTheory.Limits.Multicoequalizer.instHasCoequalizerFstSigmaMapSndSigmaMap","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninst✝² : CategoryTheory.Limits.HasMulticoequalizer I\ninst✝¹ : CategoryTheory.Limits.HasCoproduct I.left\ninst✝ : CategoryTheory.Limits.HasCoproduct I.right\n⊢ CategoryTheory.Limits.HasCoequalizer I.fstSigmaMap I.sndSigmaMap","decl":"instance : HasCoequalizer I.fstSigmaMap I.sndSigmaMap :=\n  ⟨⟨⟨_,\n      IsColimit.ofPreservesCoconeInitial\n        I.multicoforkEquivSigmaCofork.functor (colimit.isColimit _)⟩⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.Multicoequalizer.ι_sigmaπ_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninst✝² : CategoryTheory.Limits.HasMulticoequalizer I\ninst✝¹ : CategoryTheory.Limits.HasCoproduct I.left\ninst✝ : CategoryTheory.Limits.HasCoproduct I.right\nb : I.R\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.multicoequalizer I) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι I.right b) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multicoequalizer.sigmaπ I) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multicoequalizer.π I b) h)","decl":"@[reassoc (attr := simp)]\ntheorem ι_sigmaπ (b) : Sigma.ι I.right b ≫ sigmaπ I = π I b := by\n  rw [sigmaπ, ← Category.assoc, Iso.comp_inv_eq, isoCoequalizer]\n  simp only [MultispanIndex.multicoforkEquivSigmaCofork_inverse,\n    MultispanIndex.ofSigmaCoforkFunctor_obj, colimit.isoColimitCocone_ι_hom,\n    Multicofork.ofSigmaCofork_pt, colimit.cocone_x, Multicofork.π_eq_app_right]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multicoequalizer.ι_sigmaπ","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninst✝² : CategoryTheory.Limits.HasMulticoequalizer I\ninst✝¹ : CategoryTheory.Limits.HasCoproduct I.left\ninst✝ : CategoryTheory.Limits.HasCoproduct I.right\nb : I.R\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι I.right b) (CategoryTheory.Limits.Multicoequalizer.sigmaπ I)) (CategoryTheory.Limits.Multicoequalizer.π I b)","decl":"@[reassoc (attr := simp)]\ntheorem ι_sigmaπ (b) : Sigma.ι I.right b ≫ sigmaπ I = π I b := by\n  rw [sigmaπ, ← Category.assoc, Iso.comp_inv_eq, isoCoequalizer]\n  simp only [MultispanIndex.multicoforkEquivSigmaCofork_inverse,\n    MultispanIndex.ofSigmaCoforkFunctor_obj, colimit.isoColimitCocone_ι_hom,\n    Multicofork.ofSigmaCofork_pt, colimit.cocone_x, Multicofork.π_eq_app_right]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multicoequalizer.instEpiSigmaπ","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninst✝² : CategoryTheory.Limits.HasMulticoequalizer I\ninst✝¹ : CategoryTheory.Limits.HasCoproduct I.left\ninst✝ : CategoryTheory.Limits.HasCoproduct I.right\n⊢ CategoryTheory.Epi (CategoryTheory.Limits.Multicoequalizer.sigmaπ I)","decl":"instance : Epi (sigmaπ I) := epi_comp _ _\n\n"}
