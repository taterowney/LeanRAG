{"name":"CategoryTheory.Limits.WalkingMulticospan.right.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"L : Type w\nR : Type w'\nfst snd : R â†’ L\naâœÂ¹ aâœ : R\nâŠ¢ Eq (Eq (CategoryTheory.Limits.WalkingMulticospan.right aâœÂ¹) (CategoryTheory.Limits.WalkingMulticospan.right aâœ)) (Eq aâœÂ¹ aâœ)","decl":"/-- The type underlying the multiequalizer diagram. -/\n--@[nolint unused_arguments]\ninductive WalkingMulticospan {L : Type w} {R : Type w'} (fst snd : R â†’ L) : Type max w w'\n  | left : L â†’ WalkingMulticospan fst snd\n  | right : R â†’ WalkingMulticospan fst snd\n\n"}
{"name":"CategoryTheory.Limits.WalkingMulticospan.left.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"L : Type w\nR : Type w'\nfst snd : R â†’ L\ninstâœÂ¹ : SizeOf L\ninstâœ : SizeOf R\naâœ : L\nâŠ¢ Eq (SizeOf.sizeOf (CategoryTheory.Limits.WalkingMulticospan.left aâœ)) (HAdd.hAdd 1 (SizeOf.sizeOf aâœ))","decl":"/-- The type underlying the multiequalizer diagram. -/\n--@[nolint unused_arguments]\ninductive WalkingMulticospan {L : Type w} {R : Type w'} (fst snd : R â†’ L) : Type max w w'\n  | left : L â†’ WalkingMulticospan fst snd\n  | right : R â†’ WalkingMulticospan fst snd\n\n"}
{"name":"CategoryTheory.Limits.WalkingMulticospan.right.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"L : Type w\nR : Type w'\nfst snd : R â†’ L\naâœÂ¹ aâœ : R\nxâœ : Eq (CategoryTheory.Limits.WalkingMulticospan.right aâœÂ¹) (CategoryTheory.Limits.WalkingMulticospan.right aâœ)\nâŠ¢ Eq aâœÂ¹ aâœ","decl":"/-- The type underlying the multiequalizer diagram. -/\n--@[nolint unused_arguments]\ninductive WalkingMulticospan {L : Type w} {R : Type w'} (fst snd : R â†’ L) : Type max w w'\n  | left : L â†’ WalkingMulticospan fst snd\n  | right : R â†’ WalkingMulticospan fst snd\n\n"}
{"name":"CategoryTheory.Limits.WalkingMulticospan.right.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"L : Type w\nR : Type w'\nfst snd : R â†’ L\ninstâœÂ¹ : SizeOf L\ninstâœ : SizeOf R\naâœ : R\nâŠ¢ Eq (SizeOf.sizeOf (CategoryTheory.Limits.WalkingMulticospan.right aâœ)) (HAdd.hAdd 1 (SizeOf.sizeOf aâœ))","decl":"/-- The type underlying the multiequalizer diagram. -/\n--@[nolint unused_arguments]\ninductive WalkingMulticospan {L : Type w} {R : Type w'} (fst snd : R â†’ L) : Type max w w'\n  | left : L â†’ WalkingMulticospan fst snd\n  | right : R â†’ WalkingMulticospan fst snd\n\n"}
{"name":"CategoryTheory.Limits.WalkingMulticospan.left.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"L : Type w\nR : Type w'\nfst snd : R â†’ L\naâœÂ¹ aâœ : L\nâŠ¢ Eq (Eq (CategoryTheory.Limits.WalkingMulticospan.left aâœÂ¹) (CategoryTheory.Limits.WalkingMulticospan.left aâœ)) (Eq aâœÂ¹ aâœ)","decl":"/-- The type underlying the multiequalizer diagram. -/\n--@[nolint unused_arguments]\ninductive WalkingMulticospan {L : Type w} {R : Type w'} (fst snd : R â†’ L) : Type max w w'\n  | left : L â†’ WalkingMulticospan fst snd\n  | right : R â†’ WalkingMulticospan fst snd\n\n"}
{"name":"CategoryTheory.Limits.WalkingMulticospan.left.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"L : Type w\nR : Type w'\nfst snd : R â†’ L\naâœÂ¹ aâœ : L\nxâœ : Eq (CategoryTheory.Limits.WalkingMulticospan.left aâœÂ¹) (CategoryTheory.Limits.WalkingMulticospan.left aâœ)\nâŠ¢ Eq aâœÂ¹ aâœ","decl":"/-- The type underlying the multiequalizer diagram. -/\n--@[nolint unused_arguments]\ninductive WalkingMulticospan {L : Type w} {R : Type w'} (fst snd : R â†’ L) : Type max w w'\n  | left : L â†’ WalkingMulticospan fst snd\n  | right : R â†’ WalkingMulticospan fst snd\n\n"}
{"name":"CategoryTheory.Limits.WalkingMultispan.right.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"L : Type w\nR : Type w'\nfst snd : L â†’ R\ninstâœÂ¹ : SizeOf L\ninstâœ : SizeOf R\naâœ : R\nâŠ¢ Eq (SizeOf.sizeOf (CategoryTheory.Limits.WalkingMultispan.right aâœ)) (HAdd.hAdd 1 (SizeOf.sizeOf aâœ))","decl":"/-- The type underlying the multiecoqualizer diagram. -/\n--@[nolint unused_arguments]\ninductive WalkingMultispan {L : Type w} {R : Type w'} (fst snd : L â†’ R) : Type max w w'\n  | left : L â†’ WalkingMultispan fst snd\n  | right : R â†’ WalkingMultispan fst snd\n\n"}
{"name":"CategoryTheory.Limits.WalkingMultispan.right.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"L : Type w\nR : Type w'\nfst snd : L â†’ R\naâœÂ¹ aâœ : R\nxâœ : Eq (CategoryTheory.Limits.WalkingMultispan.right aâœÂ¹) (CategoryTheory.Limits.WalkingMultispan.right aâœ)\nâŠ¢ Eq aâœÂ¹ aâœ","decl":"/-- The type underlying the multiecoqualizer diagram. -/\n--@[nolint unused_arguments]\ninductive WalkingMultispan {L : Type w} {R : Type w'} (fst snd : L â†’ R) : Type max w w'\n  | left : L â†’ WalkingMultispan fst snd\n  | right : R â†’ WalkingMultispan fst snd\n\n"}
{"name":"CategoryTheory.Limits.WalkingMultispan.left.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"L : Type w\nR : Type w'\nfst snd : L â†’ R\naâœÂ¹ aâœ : L\nxâœ : Eq (CategoryTheory.Limits.WalkingMultispan.left aâœÂ¹) (CategoryTheory.Limits.WalkingMultispan.left aâœ)\nâŠ¢ Eq aâœÂ¹ aâœ","decl":"/-- The type underlying the multiecoqualizer diagram. -/\n--@[nolint unused_arguments]\ninductive WalkingMultispan {L : Type w} {R : Type w'} (fst snd : L â†’ R) : Type max w w'\n  | left : L â†’ WalkingMultispan fst snd\n  | right : R â†’ WalkingMultispan fst snd\n\n"}
{"name":"CategoryTheory.Limits.WalkingMultispan.right.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"L : Type w\nR : Type w'\nfst snd : L â†’ R\naâœÂ¹ aâœ : R\nâŠ¢ Eq (Eq (CategoryTheory.Limits.WalkingMultispan.right aâœÂ¹) (CategoryTheory.Limits.WalkingMultispan.right aâœ)) (Eq aâœÂ¹ aâœ)","decl":"/-- The type underlying the multiecoqualizer diagram. -/\n--@[nolint unused_arguments]\ninductive WalkingMultispan {L : Type w} {R : Type w'} (fst snd : L â†’ R) : Type max w w'\n  | left : L â†’ WalkingMultispan fst snd\n  | right : R â†’ WalkingMultispan fst snd\n\n"}
{"name":"CategoryTheory.Limits.WalkingMultispan.left.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"L : Type w\nR : Type w'\nfst snd : L â†’ R\ninstâœÂ¹ : SizeOf L\ninstâœ : SizeOf R\naâœ : L\nâŠ¢ Eq (SizeOf.sizeOf (CategoryTheory.Limits.WalkingMultispan.left aâœ)) (HAdd.hAdd 1 (SizeOf.sizeOf aâœ))","decl":"/-- The type underlying the multiecoqualizer diagram. -/\n--@[nolint unused_arguments]\ninductive WalkingMultispan {L : Type w} {R : Type w'} (fst snd : L â†’ R) : Type max w w'\n  | left : L â†’ WalkingMultispan fst snd\n  | right : R â†’ WalkingMultispan fst snd\n\n"}
{"name":"CategoryTheory.Limits.WalkingMultispan.left.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"L : Type w\nR : Type w'\nfst snd : L â†’ R\naâœÂ¹ aâœ : L\nâŠ¢ Eq (Eq (CategoryTheory.Limits.WalkingMultispan.left aâœÂ¹) (CategoryTheory.Limits.WalkingMultispan.left aâœ)) (Eq aâœÂ¹ aâœ)","decl":"/-- The type underlying the multiecoqualizer diagram. -/\n--@[nolint unused_arguments]\ninductive WalkingMultispan {L : Type w} {R : Type w'} (fst snd : L â†’ R) : Type max w w'\n  | left : L â†’ WalkingMultispan fst snd\n  | right : R â†’ WalkingMultispan fst snd\n\n"}
{"name":"CategoryTheory.Limits.WalkingMulticospan.Hom.id_eq_id","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"L : Type w\nR : Type w'\nfst snd : R â†’ L\nX : CategoryTheory.Limits.WalkingMulticospan fst snd\nâŠ¢ Eq (CategoryTheory.Limits.WalkingMulticospan.Hom.id X) (CategoryTheory.CategoryStruct.id X)","decl":"@[simp]\nlemma Hom.id_eq_id (X : WalkingMulticospan fst snd) :\n    Hom.id X = ğŸ™ X := rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingMulticospan.Hom.comp_eq_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"L : Type w\nR : Type w'\nfst snd : R â†’ L\nX Y Z : CategoryTheory.Limits.WalkingMulticospan fst snd\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.Limits.WalkingMulticospan.Hom.comp f g) (CategoryTheory.CategoryStruct.comp f g)","decl":"@[simp]\nlemma Hom.comp_eq_comp {X Y Z : WalkingMulticospan fst snd}\n    (f : X âŸ¶ Y) (g : Y âŸ¶ Z) : Hom.comp f g = f â‰« g := rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingMultispan.Hom.id_eq_id","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"L : Type w\nR : Type w'\nfst snd : L â†’ R\nX : CategoryTheory.Limits.WalkingMultispan fst snd\nâŠ¢ Eq (CategoryTheory.Limits.WalkingMultispan.Hom.id X) (CategoryTheory.CategoryStruct.id X)","decl":"@[simp]\nlemma Hom.id_eq_id (X : WalkingMultispan fst snd) : Hom.id X = ğŸ™ X := rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingMultispan.Hom.comp_eq_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"L : Type w\nR : Type w'\nfst snd : L â†’ R\nX Y Z : CategoryTheory.Limits.WalkingMultispan fst snd\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.Limits.WalkingMultispan.Hom.comp f g) (CategoryTheory.CategoryStruct.comp f g)","decl":"@[simp]\nlemma Hom.comp_eq_comp {X Y Z : WalkingMultispan fst snd}\n    (f : X âŸ¶ Y) (g : Y âŸ¶ Z) : Hom.comp f g = f â‰« g := rfl\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nLâœ : Type w\nRâœ : Type w'\nfstToâœ sndToâœ : Râœ â†’ Lâœ\nleftâœ : Lâœ â†’ C\nrightâœ : Râœ â†’ C\nfstâœ : (b : Râœ) â†’ Quiver.Hom (leftâœ (fstToâœ b)) (rightâœ b)\nsndâœ : (b : Râœ) â†’ Quiver.Hom (leftâœ (sndToâœ b)) (rightâœ b)\nL : Type w\nR : Type w'\nfstTo sndTo : R â†’ L\nleft : L â†’ C\nright : R â†’ C\nfst : (b : R) â†’ Quiver.Hom (left (fstTo b)) (right b)\nsnd : (b : R) â†’ Quiver.Hom (left (sndTo b)) (right b)\nâŠ¢ Eq (Eq { L := Lâœ, R := Râœ, fstTo := fstToâœ, sndTo := sndToâœ, left := leftâœ, right := rightâœ, fst := fstâœ, snd := sndâœ } { L := L, R := R, fstTo := fstTo, sndTo := sndTo, left := left, right := right, fst := fst, snd := snd }) (And (Eq Lâœ L) (And (Eq Râœ R) (And (HEq fstToâœ fstTo) (And (HEq sndToâœ sndTo) (And (HEq leftâœ left) (And (HEq rightâœ right) (And (HEq fstâœ fst) (HEq sndâœ snd))))))))","decl":"/-- This is a structure encapsulating the data necessary to define a `Multicospan`. -/\n@[nolint checkUnivs]\nstructure MulticospanIndex (C : Type u) [Category.{v} C] where\n  (L : Type w)\n  (R : Type w')\n  (fstTo sndTo : R â†’ L)\n  left : L â†’ C\n  right : R â†’ C\n  fst : âˆ€ b, left (fstTo b) âŸ¶ right b\n  snd : âˆ€ b, left (sndTo b) âŸ¶ right b\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : SizeOf C\nL : Type w\nR : Type w'\nfstTo sndTo : R â†’ L\nleft : L â†’ C\nright : R â†’ C\nfst : (b : R) â†’ Quiver.Hom (left (fstTo b)) (right b)\nsnd : (b : R) â†’ Quiver.Hom (left (sndTo b)) (right b)\nâŠ¢ Eq (SizeOf.sizeOf { L := L, R := R, fstTo := fstTo, sndTo := sndTo, left := left, right := right, fst := fst, snd := snd }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf L)) (SizeOf.sizeOf R))","decl":"/-- This is a structure encapsulating the data necessary to define a `Multicospan`. -/\n@[nolint checkUnivs]\nstructure MulticospanIndex (C : Type u) [Category.{v} C] where\n  (L : Type w)\n  (R : Type w')\n  (fstTo sndTo : R â†’ L)\n  left : L â†’ C\n  right : R â†’ C\n  fst : âˆ€ b, left (fstTo b) âŸ¶ right b\n  snd : âˆ€ b, left (sndTo b) âŸ¶ right b\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nLâœ : Type w\nRâœ : Type w'\nfstToâœ sndToâœ : Râœ â†’ Lâœ\nleftâœ : Lâœ â†’ C\nrightâœ : Râœ â†’ C\nfstâœ : (b : Râœ) â†’ Quiver.Hom (leftâœ (fstToâœ b)) (rightâœ b)\nsndâœ : (b : Râœ) â†’ Quiver.Hom (leftâœ (sndToâœ b)) (rightâœ b)\nL : Type w\nR : Type w'\nfstTo sndTo : R â†’ L\nleft : L â†’ C\nright : R â†’ C\nfst : (b : R) â†’ Quiver.Hom (left (fstTo b)) (right b)\nsnd : (b : R) â†’ Quiver.Hom (left (sndTo b)) (right b)\nxâœ : Eq { L := Lâœ, R := Râœ, fstTo := fstToâœ, sndTo := sndToâœ, left := leftâœ, right := rightâœ, fst := fstâœ, snd := sndâœ } { L := L, R := R, fstTo := fstTo, sndTo := sndTo, left := left, right := right, fst := fst, snd := snd }\nâŠ¢ And (Eq Lâœ L) (And (Eq Râœ R) (And (HEq fstToâœ fstTo) (And (HEq sndToâœ sndTo) (And (HEq leftâœ left) (And (HEq rightâœ right) (And (HEq fstâœ fst) (HEq sndâœ snd)))))))","decl":"/-- This is a structure encapsulating the data necessary to define a `Multicospan`. -/\n@[nolint checkUnivs]\nstructure MulticospanIndex (C : Type u) [Category.{v} C] where\n  (L : Type w)\n  (R : Type w')\n  (fstTo sndTo : R â†’ L)\n  left : L â†’ C\n  right : R â†’ C\n  fst : âˆ€ b, left (fstTo b) âŸ¶ right b\n  snd : âˆ€ b, left (sndTo b) âŸ¶ right b\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nLâœ : Type w\nRâœ : Type w'\nfstFromâœ sndFromâœ : Lâœ â†’ Râœ\nleftâœ : Lâœ â†’ C\nrightâœ : Râœ â†’ C\nfstâœ : (a : Lâœ) â†’ Quiver.Hom (leftâœ a) (rightâœ (fstFromâœ a))\nsndâœ : (a : Lâœ) â†’ Quiver.Hom (leftâœ a) (rightâœ (sndFromâœ a))\nL : Type w\nR : Type w'\nfstFrom sndFrom : L â†’ R\nleft : L â†’ C\nright : R â†’ C\nfst : (a : L) â†’ Quiver.Hom (left a) (right (fstFrom a))\nsnd : (a : L) â†’ Quiver.Hom (left a) (right (sndFrom a))\nâŠ¢ Eq (Eq { L := Lâœ, R := Râœ, fstFrom := fstFromâœ, sndFrom := sndFromâœ, left := leftâœ, right := rightâœ, fst := fstâœ, snd := sndâœ } { L := L, R := R, fstFrom := fstFrom, sndFrom := sndFrom, left := left, right := right, fst := fst, snd := snd }) (And (Eq Lâœ L) (And (Eq Râœ R) (And (HEq fstFromâœ fstFrom) (And (HEq sndFromâœ sndFrom) (And (HEq leftâœ left) (And (HEq rightâœ right) (And (HEq fstâœ fst) (HEq sndâœ snd))))))))","decl":"/-- This is a structure encapsulating the data necessary to define a `Multispan`. -/\n@[nolint checkUnivs]\nstructure MultispanIndex (C : Type u) [Category.{v} C] where\n  (L : Type w)\n  (R : Type w')\n  (fstFrom sndFrom : L â†’ R)\n  left : L â†’ C\n  right : R â†’ C\n  fst : âˆ€ a, left a âŸ¶ right (fstFrom a)\n  snd : âˆ€ a, left a âŸ¶ right (sndFrom a)\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : SizeOf C\nL : Type w\nR : Type w'\nfstFrom sndFrom : L â†’ R\nleft : L â†’ C\nright : R â†’ C\nfst : (a : L) â†’ Quiver.Hom (left a) (right (fstFrom a))\nsnd : (a : L) â†’ Quiver.Hom (left a) (right (sndFrom a))\nâŠ¢ Eq (SizeOf.sizeOf { L := L, R := R, fstFrom := fstFrom, sndFrom := sndFrom, left := left, right := right, fst := fst, snd := snd }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf L)) (SizeOf.sizeOf R))","decl":"/-- This is a structure encapsulating the data necessary to define a `Multispan`. -/\n@[nolint checkUnivs]\nstructure MultispanIndex (C : Type u) [Category.{v} C] where\n  (L : Type w)\n  (R : Type w')\n  (fstFrom sndFrom : L â†’ R)\n  left : L â†’ C\n  right : R â†’ C\n  fst : âˆ€ a, left a âŸ¶ right (fstFrom a)\n  snd : âˆ€ a, left a âŸ¶ right (sndFrom a)\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nLâœ : Type w\nRâœ : Type w'\nfstFromâœ sndFromâœ : Lâœ â†’ Râœ\nleftâœ : Lâœ â†’ C\nrightâœ : Râœ â†’ C\nfstâœ : (a : Lâœ) â†’ Quiver.Hom (leftâœ a) (rightâœ (fstFromâœ a))\nsndâœ : (a : Lâœ) â†’ Quiver.Hom (leftâœ a) (rightâœ (sndFromâœ a))\nL : Type w\nR : Type w'\nfstFrom sndFrom : L â†’ R\nleft : L â†’ C\nright : R â†’ C\nfst : (a : L) â†’ Quiver.Hom (left a) (right (fstFrom a))\nsnd : (a : L) â†’ Quiver.Hom (left a) (right (sndFrom a))\nxâœ : Eq { L := Lâœ, R := Râœ, fstFrom := fstFromâœ, sndFrom := sndFromâœ, left := leftâœ, right := rightâœ, fst := fstâœ, snd := sndâœ } { L := L, R := R, fstFrom := fstFrom, sndFrom := sndFrom, left := left, right := right, fst := fst, snd := snd }\nâŠ¢ And (Eq Lâœ L) (And (Eq Râœ R) (And (HEq fstFromâœ fstFrom) (And (HEq sndFromâœ sndFrom) (And (HEq leftâœ left) (And (HEq rightâœ right) (And (HEq fstâœ fst) (HEq sndâœ snd)))))))","decl":"/-- This is a structure encapsulating the data necessary to define a `Multispan`. -/\n@[nolint checkUnivs]\nstructure MultispanIndex (C : Type u) [Category.{v} C] where\n  (L : Type w)\n  (R : Type w')\n  (fstFrom sndFrom : L â†’ R)\n  left : L â†’ C\n  right : R â†’ C\n  fst : âˆ€ a, left a âŸ¶ right (fstFrom a)\n  snd : âˆ€ a, left a âŸ¶ right (sndFrom a)\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.multicospan_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nx y : CategoryTheory.Limits.WalkingMulticospan I.fstTo I.sndTo\nf : Quiver.Hom x y\nâŠ¢ Eq (I.multicospan.map f) (CategoryTheory.Limits.MulticospanIndex.multicospan.match_2 I (fun x y f => Quiver.Hom ((fun x => CategoryTheory.Limits.MulticospanIndex.multicospan.match_1 I (fun x => C) x (fun a => I.left a) fun b => I.right b) x) ((fun x => CategoryTheory.Limits.MulticospanIndex.multicospan.match_1 I (fun x => C) x (fun a => I.left a) fun b => I.right b) y)) x y f (fun x => CategoryTheory.CategoryStruct.id ((fun x => CategoryTheory.Limits.MulticospanIndex.multicospan.match_1 I (fun x => C) x (fun a => I.left a) fun b => I.right b) x)) (fun b => I.fst b) fun b => I.snd b)","decl":"/-- The multicospan associated to `I : MulticospanIndex`. -/\n@[simps]\ndef multicospan : WalkingMulticospan I.fstTo I.sndTo â¥¤ C where\n  obj x :=\n    match x with\n    | WalkingMulticospan.left a => I.left a\n    | WalkingMulticospan.right b => I.right b\n  map {x y} f :=\n    match x, y, f with\n    | _, _, WalkingMulticospan.Hom.id x => ğŸ™ _\n    | _, _, WalkingMulticospan.Hom.fst b => I.fst _\n    | _, _, WalkingMulticospan.Hom.snd b => I.snd _\n  map_id := by\n    rintro (_ | _) <;> rfl\n  map_comp := by\n    rintro (_ | _) (_ | _) (_ | _) (_ | _ | _) (_ | _ | _) <;> aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.multicospan_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nx : CategoryTheory.Limits.WalkingMulticospan I.fstTo I.sndTo\nâŠ¢ Eq (I.multicospan.obj x) (CategoryTheory.Limits.MulticospanIndex.multicospan.match_1 I (fun x => C) x (fun a => I.left a) fun b => I.right b)","decl":"/-- The multicospan associated to `I : MulticospanIndex`. -/\n@[simps]\ndef multicospan : WalkingMulticospan I.fstTo I.sndTo â¥¤ C where\n  obj x :=\n    match x with\n    | WalkingMulticospan.left a => I.left a\n    | WalkingMulticospan.right b => I.right b\n  map {x y} f :=\n    match x, y, f with\n    | _, _, WalkingMulticospan.Hom.id x => ğŸ™ _\n    | _, _, WalkingMulticospan.Hom.fst b => I.fst _\n    | _, _, WalkingMulticospan.Hom.snd b => I.snd _\n  map_id := by\n    rintro (_ | _) <;> rfl\n  map_comp := by\n    rintro (_ | _) (_ | _) (_ | _) (_ | _ | _) (_ | _ | _) <;> aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.fstPiMap_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct I.left\ninstâœ : CategoryTheory.Limits.HasProduct I.right\nb : I.R\nZ : C\nh : Quiver.Hom (I.right b) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp I.fstPiMap (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.Ï€ I.right b) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.Ï€ I.left (I.fstTo b)) (CategoryTheory.CategoryStruct.comp (I.fst b) h))","decl":"@[reassoc (attr := simp)]\ntheorem fstPiMap_Ï€ (b) : I.fstPiMap â‰« Pi.Ï€ I.right b = Pi.Ï€ I.left _ â‰« I.fst b := by\n  simp [fstPiMap]\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.fstPiMap_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct I.left\ninstâœ : CategoryTheory.Limits.HasProduct I.right\nb : I.R\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp I.fstPiMap (CategoryTheory.Limits.Pi.Ï€ I.right b)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.Ï€ I.left (I.fstTo b)) (I.fst b))","decl":"@[reassoc (attr := simp)]\ntheorem fstPiMap_Ï€ (b) : I.fstPiMap â‰« Pi.Ï€ I.right b = Pi.Ï€ I.left _ â‰« I.fst b := by\n  simp [fstPiMap]\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.sndPiMap_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct I.left\ninstâœ : CategoryTheory.Limits.HasProduct I.right\nb : I.R\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp I.sndPiMap (CategoryTheory.Limits.Pi.Ï€ I.right b)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.Ï€ I.left (I.sndTo b)) (I.snd b))","decl":"@[reassoc (attr := simp)]\ntheorem sndPiMap_Ï€ (b) : I.sndPiMap â‰« Pi.Ï€ I.right b = Pi.Ï€ I.left _ â‰« I.snd b := by\n  simp [sndPiMap]\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.sndPiMap_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct I.left\ninstâœ : CategoryTheory.Limits.HasProduct I.right\nb : I.R\nZ : C\nh : Quiver.Hom (I.right b) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp I.sndPiMap (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.Ï€ I.right b) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.Ï€ I.left (I.sndTo b)) (CategoryTheory.CategoryStruct.comp (I.snd b) h))","decl":"@[reassoc (attr := simp)]\ntheorem sndPiMap_Ï€ (b) : I.sndPiMap â‰« Pi.Ï€ I.right b = Pi.Ï€ I.left _ â‰« I.snd b := by\n  simp [sndPiMap]\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.parallelPairDiagram_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct I.left\ninstâœ : CategoryTheory.Limits.HasProduct I.right\nXâœ Yâœ : CategoryTheory.Limits.WalkingParallelPair\nh : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq (I.parallelPairDiagram.map h) (CategoryTheory.Limits.parallelPair.match_2 (fun X Y h => Quiver.Hom (CategoryTheory.Limits.parallelPair.match_1 (fun x => C) X (fun _ => CategoryTheory.Limits.piObj I.left) fun _ => CategoryTheory.Limits.piObj I.right) (CategoryTheory.Limits.parallelPair.match_1 (fun x => C) Y (fun _ => CategoryTheory.Limits.piObj I.left) fun _ => CategoryTheory.Limits.piObj I.right)) Xâœ Yâœ h (fun x => CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.parallelPair.match_1 (fun x => C) x (fun _ => CategoryTheory.Limits.piObj I.left) fun _ => CategoryTheory.Limits.piObj I.right)) (fun _ => I.fstPiMap) fun _ => I.sndPiMap)","decl":"/-- Taking the multiequalizer over the multicospan index is equivalent to taking the equalizer over\nthe two morphisms `âˆá¶œ I.left â‡‰ âˆá¶œ I.right`. This is the diagram of the latter.\n-/\n@[simps!]\nprotected noncomputable def parallelPairDiagram :=\n  parallelPair I.fstPiMap I.sndPiMap\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.parallelPairDiagram_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct I.left\ninstâœ : CategoryTheory.Limits.HasProduct I.right\nx : CategoryTheory.Limits.WalkingParallelPair\nâŠ¢ Eq (I.parallelPairDiagram.obj x) (CategoryTheory.Limits.parallelPair.match_1 (fun x => C) x (fun _ => CategoryTheory.Limits.piObj I.left) fun _ => CategoryTheory.Limits.piObj I.right)","decl":"/-- Taking the multiequalizer over the multicospan index is equivalent to taking the equalizer over\nthe two morphisms `âˆá¶œ I.left â‡‰ âˆá¶œ I.right`. This is the diagram of the latter.\n-/\n@[simps!]\nprotected noncomputable def parallelPairDiagram :=\n  parallelPair I.fstPiMap I.sndPiMap\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.multispan_obj_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\na : I.L\nâŠ¢ Eq (I.multispan.obj (CategoryTheory.Limits.WalkingMultispan.left a)) (I.left a)","decl":"@[simp]\ntheorem multispan_obj_left (a) : I.multispan.obj (WalkingMultispan.left a) = I.left a :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.multispan_obj_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\nb : I.R\nâŠ¢ Eq (I.multispan.obj (CategoryTheory.Limits.WalkingMultispan.right b)) (I.right b)","decl":"@[simp]\ntheorem multispan_obj_right (b) : I.multispan.obj (WalkingMultispan.right b) = I.right b :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.multispan_map_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\na : I.L\nâŠ¢ Eq (I.multispan.map (CategoryTheory.Limits.WalkingMultispan.Hom.fst a)) (I.fst a)","decl":"@[simp]\ntheorem multispan_map_fst (a) : I.multispan.map (WalkingMultispan.Hom.fst a) = I.fst a :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.multispan_map_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\na : I.L\nâŠ¢ Eq (I.multispan.map (CategoryTheory.Limits.WalkingMultispan.Hom.snd a)) (I.snd a)","decl":"@[simp]\ntheorem multispan_map_snd (a) : I.multispan.map (WalkingMultispan.Hom.snd a) = I.snd a :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.Î¹_fstSigmaMap_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct I.left\ninstâœ : CategoryTheory.Limits.HasCoproduct I.right\nb : I.L\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.sigmaObj I.right) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ I.left b) (CategoryTheory.CategoryStruct.comp I.fstSigmaMap h)) (CategoryTheory.CategoryStruct.comp (I.fst b) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ I.right (I.fstFrom b)) h))","decl":"@[reassoc (attr := simp)]\ntheorem Î¹_fstSigmaMap (b) : Sigma.Î¹ I.left b â‰« I.fstSigmaMap = I.fst b â‰« Sigma.Î¹ I.right _ := by\n  simp [fstSigmaMap]\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.Î¹_fstSigmaMap","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct I.left\ninstâœ : CategoryTheory.Limits.HasCoproduct I.right\nb : I.L\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ I.left b) I.fstSigmaMap) (CategoryTheory.CategoryStruct.comp (I.fst b) (CategoryTheory.Limits.Sigma.Î¹ I.right (I.fstFrom b)))","decl":"@[reassoc (attr := simp)]\ntheorem Î¹_fstSigmaMap (b) : Sigma.Î¹ I.left b â‰« I.fstSigmaMap = I.fst b â‰« Sigma.Î¹ I.right _ := by\n  simp [fstSigmaMap]\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.Î¹_sndSigmaMap","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct I.left\ninstâœ : CategoryTheory.Limits.HasCoproduct I.right\nb : I.L\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ I.left b) I.sndSigmaMap) (CategoryTheory.CategoryStruct.comp (I.snd b) (CategoryTheory.Limits.Sigma.Î¹ I.right (I.sndFrom b)))","decl":"@[reassoc (attr := simp)]\ntheorem Î¹_sndSigmaMap (b) : Sigma.Î¹ I.left b â‰« I.sndSigmaMap = I.snd b â‰« Sigma.Î¹ I.right _ := by\n  simp [sndSigmaMap]\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.Î¹_sndSigmaMap_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct I.left\ninstâœ : CategoryTheory.Limits.HasCoproduct I.right\nb : I.L\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.sigmaObj I.right) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ I.left b) (CategoryTheory.CategoryStruct.comp I.sndSigmaMap h)) (CategoryTheory.CategoryStruct.comp (I.snd b) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ I.right (I.sndFrom b)) h))","decl":"@[reassoc (attr := simp)]\ntheorem Î¹_sndSigmaMap (b) : Sigma.Î¹ I.left b â‰« I.sndSigmaMap = I.snd b â‰« Sigma.Î¹ I.right _ := by\n  simp [sndSigmaMap]\n\n"}
{"name":"CategoryTheory.Limits.Multifork.app_left_eq_Î¹","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nK : CategoryTheory.Limits.Multifork I\na : I.L\nâŠ¢ Eq (K.Ï€.app (CategoryTheory.Limits.WalkingMulticospan.left a)) (K.Î¹ a)","decl":"@[simp]\ntheorem app_left_eq_Î¹ (a) : K.Ï€.app (WalkingMulticospan.left a) = K.Î¹ a :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multifork.app_right_eq_Î¹_comp_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nK : CategoryTheory.Limits.Multifork I\nb : I.R\nâŠ¢ Eq (K.Ï€.app (CategoryTheory.Limits.WalkingMulticospan.right b)) (CategoryTheory.CategoryStruct.comp (K.Î¹ (I.fstTo b)) (I.fst b))","decl":"@[simp]\ntheorem app_right_eq_Î¹_comp_fst (b) :\n    K.Ï€.app (WalkingMulticospan.right b) = K.Î¹ (I.fstTo b) â‰« I.fst b := by\n  rw [â† K.w (WalkingMulticospan.Hom.fst b)]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multifork.app_right_eq_Î¹_comp_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nK : CategoryTheory.Limits.Multifork I\nb : I.R\nâŠ¢ Eq (K.Ï€.app (CategoryTheory.Limits.WalkingMulticospan.right b)) (CategoryTheory.CategoryStruct.comp (K.Î¹ (I.sndTo b)) (I.snd b))","decl":"@[reassoc]\ntheorem app_right_eq_Î¹_comp_snd (b) :\n    K.Ï€.app (WalkingMulticospan.right b) = K.Î¹ (I.sndTo b) â‰« I.snd b := by\n  rw [â† K.w (WalkingMulticospan.Hom.snd b)]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multifork.app_right_eq_Î¹_comp_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nK : CategoryTheory.Limits.Multifork I\nb : I.R\nZ : C\nh : Quiver.Hom (I.multicospan.obj (CategoryTheory.Limits.WalkingMulticospan.right b)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (K.Ï€.app (CategoryTheory.Limits.WalkingMulticospan.right b)) h) (CategoryTheory.CategoryStruct.comp (K.Î¹ (I.sndTo b)) (CategoryTheory.CategoryStruct.comp (I.snd b) h))","decl":"@[reassoc]\ntheorem app_right_eq_Î¹_comp_snd (b) :\n    K.Ï€.app (WalkingMulticospan.right b) = K.Î¹ (I.sndTo b) â‰« I.snd b := by\n  rw [â† K.w (WalkingMulticospan.Hom.snd b)]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multifork.hom_comp_Î¹","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nKâ‚ Kâ‚‚ : CategoryTheory.Limits.Multifork I\nf : Quiver.Hom Kâ‚ Kâ‚‚\nj : I.L\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f.hom (Kâ‚‚.Î¹ j)) (Kâ‚.Î¹ j)","decl":"@[reassoc (attr := simp)]\ntheorem hom_comp_Î¹ (Kâ‚ Kâ‚‚ : Multifork I) (f : Kâ‚ âŸ¶ Kâ‚‚) (j : I.L) : f.hom â‰« Kâ‚‚.Î¹ j = Kâ‚.Î¹ j :=\n  f.w _\n\n"}
{"name":"CategoryTheory.Limits.Multifork.hom_comp_Î¹_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nKâ‚ Kâ‚‚ : CategoryTheory.Limits.Multifork I\nf : Quiver.Hom Kâ‚ Kâ‚‚\nj : I.L\nZ : C\nh : Quiver.Hom (I.left j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f.hom (CategoryTheory.CategoryStruct.comp (Kâ‚‚.Î¹ j) h)) (CategoryTheory.CategoryStruct.comp (Kâ‚.Î¹ j) h)","decl":"@[reassoc (attr := simp)]\ntheorem hom_comp_Î¹ (Kâ‚ Kâ‚‚ : Multifork I) (f : Kâ‚ âŸ¶ Kâ‚‚) (j : I.L) : f.hom â‰« Kâ‚‚.Î¹ j = Kâ‚.Î¹ j :=\n  f.w _\n\n"}
{"name":"CategoryTheory.Limits.Multifork.ofÎ¹_Ï€_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nP : C\nÎ¹ : (a : I.L) â†’ Quiver.Hom P (I.left a)\nw : âˆ€ (b : I.R), Eq (CategoryTheory.CategoryStruct.comp (Î¹ (I.fstTo b)) (I.fst b)) (CategoryTheory.CategoryStruct.comp (Î¹ (I.sndTo b)) (I.snd b))\nx : CategoryTheory.Limits.WalkingMulticospan I.fstTo I.sndTo\nâŠ¢ Eq ((CategoryTheory.Limits.Multifork.ofÎ¹ I P Î¹ w).Ï€.app x) (CategoryTheory.Limits.MulticospanIndex.multicospan.match_1 I (fun x => Quiver.Hom (((CategoryTheory.Functor.const (CategoryTheory.Limits.WalkingMulticospan I.fstTo I.sndTo)).obj P).obj x) (I.multicospan.obj x)) x (fun a => Î¹ a) fun b => CategoryTheory.CategoryStruct.comp (Î¹ (I.fstTo b)) (I.fst b))","decl":"/-- Construct a multifork using a collection `Î¹` of morphisms. -/\n@[simps]\ndef ofÎ¹ (I : MulticospanIndex.{w, w'} C) (P : C) (Î¹ : âˆ€ a, P âŸ¶ I.left a)\n    (w : âˆ€ b, Î¹ (I.fstTo b) â‰« I.fst b = Î¹ (I.sndTo b) â‰« I.snd b) : Multifork I where\n  pt := P\n  Ï€ :=\n    { app := fun x =>\n        match x with\n        | WalkingMulticospan.left _ => Î¹ _\n        | WalkingMulticospan.right b => Î¹ (I.fstTo b) â‰« I.fst b\n      naturality := by\n        rintro (_ | _) (_ | _) (_ | _ | _) <;>\n          dsimp <;> simp only [Category.id_comp, Category.comp_id]\n        apply w }\n\n"}
{"name":"CategoryTheory.Limits.Multifork.ofÎ¹_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nP : C\nÎ¹ : (a : I.L) â†’ Quiver.Hom P (I.left a)\nw : âˆ€ (b : I.R), Eq (CategoryTheory.CategoryStruct.comp (Î¹ (I.fstTo b)) (I.fst b)) (CategoryTheory.CategoryStruct.comp (Î¹ (I.sndTo b)) (I.snd b))\nâŠ¢ Eq (CategoryTheory.Limits.Multifork.ofÎ¹ I P Î¹ w).pt P","decl":"/-- Construct a multifork using a collection `Î¹` of morphisms. -/\n@[simps]\ndef ofÎ¹ (I : MulticospanIndex.{w, w'} C) (P : C) (Î¹ : âˆ€ a, P âŸ¶ I.left a)\n    (w : âˆ€ b, Î¹ (I.fstTo b) â‰« I.fst b = Î¹ (I.sndTo b) â‰« I.snd b) : Multifork I where\n  pt := P\n  Ï€ :=\n    { app := fun x =>\n        match x with\n        | WalkingMulticospan.left _ => Î¹ _\n        | WalkingMulticospan.right b => Î¹ (I.fstTo b) â‰« I.fst b\n      naturality := by\n        rintro (_ | _) (_ | _) (_ | _ | _) <;>\n          dsimp <;> simp only [Category.id_comp, Category.comp_id]\n        apply w }\n\n"}
{"name":"CategoryTheory.Limits.Multifork.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nK : CategoryTheory.Limits.Multifork I\nb : I.R\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (K.Î¹ (I.fstTo b)) (I.fst b)) (CategoryTheory.CategoryStruct.comp (K.Î¹ (I.sndTo b)) (I.snd b))","decl":"@[reassoc (attr := simp)]\ntheorem condition (b) : K.Î¹ (I.fstTo b) â‰« I.fst b = K.Î¹ (I.sndTo b) â‰« I.snd b := by\n  rw [â† app_right_eq_Î¹_comp_fst, â† app_right_eq_Î¹_comp_snd]\n\n"}
{"name":"CategoryTheory.Limits.Multifork.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nK : CategoryTheory.Limits.Multifork I\nb : I.R\nZ : C\nh : Quiver.Hom (I.right b) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (K.Î¹ (I.fstTo b)) (CategoryTheory.CategoryStruct.comp (I.fst b) h)) (CategoryTheory.CategoryStruct.comp (K.Î¹ (I.sndTo b)) (CategoryTheory.CategoryStruct.comp (I.snd b) h))","decl":"@[reassoc (attr := simp)]\ntheorem condition (b) : K.Î¹ (I.fstTo b) â‰« I.fst b = K.Î¹ (I.sndTo b) â‰« I.snd b := by\n  rw [â† app_right_eq_Î¹_comp_fst, â† app_right_eq_Î¹_comp_snd]\n\n"}
{"name":"CategoryTheory.Limits.Multifork.IsLimit.mk_lift","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nK : CategoryTheory.Limits.Multifork I\nlift : (E : CategoryTheory.Limits.Multifork I) â†’ Quiver.Hom E.pt K.pt\nfac : âˆ€ (E : CategoryTheory.Limits.Multifork I) (i : I.L), Eq (CategoryTheory.CategoryStruct.comp (lift E) (K.Î¹ i)) (E.Î¹ i)\nuniq : âˆ€ (E : CategoryTheory.Limits.Multifork I) (m : Quiver.Hom E.pt K.pt), (âˆ€ (i : I.L), Eq (CategoryTheory.CategoryStruct.comp m (K.Î¹ i)) (E.Î¹ i)) â†’ Eq m (lift E)\nE : CategoryTheory.Limits.Multifork I\nâŠ¢ Eq ((CategoryTheory.Limits.Multifork.IsLimit.mk K lift fac uniq).lift E) (lift E)","decl":"/-- This definition provides a convenient way to show that a multifork is a limit. -/\n@[simps]\ndef IsLimit.mk (lift : âˆ€ E : Multifork I, E.pt âŸ¶ K.pt)\n    (fac : âˆ€ (E : Multifork I) (i : I.L), lift E â‰« K.Î¹ i = E.Î¹ i)\n    (uniq : âˆ€ (E : Multifork I) (m : E.pt âŸ¶ K.pt), (âˆ€ i : I.L, m â‰« K.Î¹ i = E.Î¹ i) â†’ m = lift E) :\n    IsLimit K :=\n  { lift\n    fac := by\n      rintro E (a | b)\n      Â· apply fac\n      Â· rw [â† E.w (WalkingMulticospan.Hom.fst b), â† K.w (WalkingMulticospan.Hom.fst b), â†\n          Category.assoc]\n        congr 1\n        apply fac\n    uniq := by\n      rintro E m hm\n      apply uniq\n      intro i\n      apply hm }\n\n"}
{"name":"CategoryTheory.Limits.Multifork.IsLimit.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nK : CategoryTheory.Limits.Multifork I\nhK : CategoryTheory.Limits.IsLimit K\nT : C\nf g : Quiver.Hom T K.pt\nh : âˆ€ (a : I.L), Eq (CategoryTheory.CategoryStruct.comp f (K.Î¹ a)) (CategoryTheory.CategoryStruct.comp g (K.Î¹ a))\nâŠ¢ Eq f g","decl":"lemma IsLimit.hom_ext (hK : IsLimit K) {T : C} {f g : T âŸ¶ K.pt}\n    (h : âˆ€ a, f â‰« K.Î¹ a = g â‰« K.Î¹ a) : f = g := by\n  apply hK.hom_ext\n  rintro (_|b)\n  Â· apply h\n  Â· dsimp\n    rw [app_right_eq_Î¹_comp_fst, reassoc_of% h]\n\n"}
{"name":"CategoryTheory.Limits.Multifork.IsLimit.fac","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nK : CategoryTheory.Limits.Multifork I\nhK : CategoryTheory.Limits.IsLimit K\nT : C\nk : (a : I.L) â†’ Quiver.Hom T (I.left a)\nhk : âˆ€ (b : I.R), Eq (CategoryTheory.CategoryStruct.comp (k (I.fstTo b)) (I.fst b)) (CategoryTheory.CategoryStruct.comp (k (I.sndTo b)) (I.snd b))\na : I.L\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multifork.IsLimit.lift hK k hk) (K.Î¹ a)) (k a)","decl":"@[reassoc (attr := simp)]\nlemma IsLimit.fac (hK : IsLimit K) {T : C} (k : âˆ€ a, T âŸ¶ I.left a)\n    (hk : âˆ€ b, k (I.fstTo b) â‰« I.fst b = k (I.sndTo b) â‰« I.snd b) (a : I.L) :\n    IsLimit.lift hK k hk â‰« K.Î¹ a = k a :=\n  hK.fac _ _\n\n"}
{"name":"CategoryTheory.Limits.Multifork.IsLimit.fac_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nK : CategoryTheory.Limits.Multifork I\nhK : CategoryTheory.Limits.IsLimit K\nT : C\nk : (a : I.L) â†’ Quiver.Hom T (I.left a)\nhk : âˆ€ (b : I.R), Eq (CategoryTheory.CategoryStruct.comp (k (I.fstTo b)) (I.fst b)) (CategoryTheory.CategoryStruct.comp (k (I.sndTo b)) (I.snd b))\na : I.L\nZ : C\nh : Quiver.Hom (I.left a) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multifork.IsLimit.lift hK k hk) (CategoryTheory.CategoryStruct.comp (K.Î¹ a) h)) (CategoryTheory.CategoryStruct.comp (k a) h)","decl":"@[reassoc (attr := simp)]\nlemma IsLimit.fac (hK : IsLimit K) {T : C} (k : âˆ€ a, T âŸ¶ I.left a)\n    (hk : âˆ€ b, k (I.fstTo b) â‰« I.fst b = k (I.sndTo b) â‰« I.snd b) (a : I.L) :\n    IsLimit.lift hK k hk â‰« K.Î¹ a = k a :=\n  hK.fac _ _\n\n"}
{"name":"CategoryTheory.Limits.Multifork.pi_condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nK : CategoryTheory.Limits.Multifork I\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct I.left\ninstâœ : CategoryTheory.Limits.HasProduct I.right\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.piObj I.right) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.lift K.Î¹) (CategoryTheory.CategoryStruct.comp I.fstPiMap h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.lift K.Î¹) (CategoryTheory.CategoryStruct.comp I.sndPiMap h))","decl":"@[reassoc (attr := simp)]\ntheorem pi_condition : Pi.lift K.Î¹ â‰« I.fstPiMap = Pi.lift K.Î¹ â‰« I.sndPiMap := by\n  ext\n  simp\n\n"}
{"name":"CategoryTheory.Limits.Multifork.pi_condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nK : CategoryTheory.Limits.Multifork I\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct I.left\ninstâœ : CategoryTheory.Limits.HasProduct I.right\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.lift K.Î¹) I.fstPiMap) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.lift K.Î¹) I.sndPiMap)","decl":"@[reassoc (attr := simp)]\ntheorem pi_condition : Pi.lift K.Î¹ â‰« I.fstPiMap = Pi.lift K.Î¹ â‰« I.sndPiMap := by\n  ext\n  simp\n\n"}
{"name":"CategoryTheory.Limits.Multifork.toPiFork_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct I.left\ninstâœ : CategoryTheory.Limits.HasProduct I.right\nK : CategoryTheory.Limits.Multifork I\nâŠ¢ Eq K.toPiFork.pt K.pt","decl":"/-- Given a multifork, we may obtain a fork over `âˆá¶œ I.left â‡‰ âˆá¶œ I.right`. -/\n@[simps pt]\nnoncomputable def toPiFork (K : Multifork I) : Fork I.fstPiMap I.sndPiMap where\n  pt := K.pt\n  Ï€ :=\n    { app := fun x =>\n        match x with\n        | WalkingParallelPair.zero => Pi.lift K.Î¹\n        | WalkingParallelPair.one => Pi.lift K.Î¹ â‰« I.fstPiMap\n      naturality := by\n        rintro (_ | _) (_ | _) (_ | _ | _) <;>\n          dsimp <;>\n          simp only [Category.id_comp, Functor.map_id, parallelPair_obj_zero, Category.comp_id,\n            pi_condition, parallelPair_obj_one] }\n\n"}
{"name":"CategoryTheory.Limits.Multifork.toPiFork_Ï€_app_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nK : CategoryTheory.Limits.Multifork I\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct I.left\ninstâœ : CategoryTheory.Limits.HasProduct I.right\nâŠ¢ Eq K.toPiFork.Î¹ (CategoryTheory.Limits.Pi.lift K.Î¹)","decl":"@[simp]\ntheorem toPiFork_Ï€_app_zero : K.toPiFork.Î¹ = Pi.lift K.Î¹ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multifork.toPiFork_Ï€_app_one","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\nK : CategoryTheory.Limits.Multifork I\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct I.left\ninstâœ : CategoryTheory.Limits.HasProduct I.right\nâŠ¢ Eq (K.toPiFork.Ï€.app CategoryTheory.Limits.WalkingParallelPair.one) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.lift K.Î¹) I.fstPiMap)","decl":"@[simp]\ntheorem toPiFork_Ï€_app_one : K.toPiFork.Ï€.app WalkingParallelPair.one = Pi.lift K.Î¹ â‰« I.fstPiMap :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multifork.ofPiFork_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct I.left\ninstâœ : CategoryTheory.Limits.HasProduct I.right\nc : CategoryTheory.Limits.Fork I.fstPiMap I.sndPiMap\nâŠ¢ Eq (CategoryTheory.Limits.Multifork.ofPiFork I c).pt c.pt","decl":"/-- Given a fork over `âˆá¶œ I.left â‡‰ âˆá¶œ I.right`, we may obtain a multifork. -/\n@[simps pt]\nnoncomputable def ofPiFork (c : Fork I.fstPiMap I.sndPiMap) : Multifork I where\n  pt := c.pt\n  Ï€ :=\n    { app := fun x =>\n        match x with\n        | WalkingMulticospan.left _ => c.Î¹ â‰« Pi.Ï€ _ _\n        | WalkingMulticospan.right _ => c.Î¹ â‰« I.fstPiMap â‰« Pi.Ï€ _ _\n      naturality := by\n        rintro (_ | _) (_ | _) (_ | _ | _)\n        Â· simp\n        Â· simp\n        Â· dsimp; rw [c.condition_assoc]; simp\n        Â· simp }\n\n"}
{"name":"CategoryTheory.Limits.Multifork.ofPiFork_Ï€_app_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct I.left\ninstâœ : CategoryTheory.Limits.HasProduct I.right\nc : CategoryTheory.Limits.Fork I.fstPiMap I.sndPiMap\na : I.L\nâŠ¢ Eq ((CategoryTheory.Limits.Multifork.ofPiFork I c).Î¹ a) (CategoryTheory.CategoryStruct.comp c.Î¹ (CategoryTheory.Limits.Pi.Ï€ I.left a))","decl":"@[simp]\ntheorem ofPiFork_Ï€_app_left (c : Fork I.fstPiMap I.sndPiMap) (a) :\n    (ofPiFork I c).Î¹ a = c.Î¹ â‰« Pi.Ï€ _ _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multifork.ofPiFork_Ï€_app_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct I.left\ninstâœ : CategoryTheory.Limits.HasProduct I.right\nc : CategoryTheory.Limits.Fork I.fstPiMap I.sndPiMap\na : I.R\nâŠ¢ Eq ((CategoryTheory.Limits.Multifork.ofPiFork I c).Ï€.app (CategoryTheory.Limits.WalkingMulticospan.right a)) (CategoryTheory.CategoryStruct.comp c.Î¹ (CategoryTheory.CategoryStruct.comp I.fstPiMap (CategoryTheory.Limits.Pi.Ï€ I.right a)))","decl":"@[simp]\ntheorem ofPiFork_Ï€_app_right (c : Fork I.fstPiMap I.sndPiMap) (a) :\n    (ofPiFork I c).Ï€.app (WalkingMulticospan.right a) = c.Î¹ â‰« I.fstPiMap â‰« Pi.Ï€ _ _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.toPiForkFunctor_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct I.left\ninstâœ : CategoryTheory.Limits.HasProduct I.right\nK : CategoryTheory.Limits.Multifork I\nâŠ¢ Eq (I.toPiForkFunctor.obj K) K.toPiFork","decl":"/-- `Multifork.toPiFork` as a functor. -/\n@[simps]\nnoncomputable def toPiForkFunctor : Multifork I â¥¤ Fork I.fstPiMap I.sndPiMap where\n  obj := Multifork.toPiFork\n  map {Kâ‚ Kâ‚‚} f :=\n    { hom := f.hom\n      w := by\n        rintro (_ | _)\n        Â· apply limit.hom_ext\n          simp\n        Â· apply limit.hom_ext\n          intros j\n          simp only [Multifork.toPiFork_Ï€_app_one, Multifork.pi_condition, Category.assoc]\n          dsimp [sndPiMap]\n          simp }\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.toPiForkFunctor_map_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct I.left\ninstâœ : CategoryTheory.Limits.HasProduct I.right\nKâ‚ Kâ‚‚ : CategoryTheory.Limits.Multifork I\nf : Quiver.Hom Kâ‚ Kâ‚‚\nâŠ¢ Eq (I.toPiForkFunctor.map f).hom f.hom","decl":"/-- `Multifork.toPiFork` as a functor. -/\n@[simps]\nnoncomputable def toPiForkFunctor : Multifork I â¥¤ Fork I.fstPiMap I.sndPiMap where\n  obj := Multifork.toPiFork\n  map {Kâ‚ Kâ‚‚} f :=\n    { hom := f.hom\n      w := by\n        rintro (_ | _)\n        Â· apply limit.hom_ext\n          simp\n        Â· apply limit.hom_ext\n          intros j\n          simp only [Multifork.toPiFork_Ï€_app_one, Multifork.pi_condition, Category.assoc]\n          dsimp [sndPiMap]\n          simp }\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.ofPiForkFunctor_map_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct I.left\ninstâœ : CategoryTheory.Limits.HasProduct I.right\nKâ‚ Kâ‚‚ : CategoryTheory.Limits.Fork I.fstPiMap I.sndPiMap\nf : Quiver.Hom Kâ‚ Kâ‚‚\nâŠ¢ Eq (I.ofPiForkFunctor.map f).hom f.hom","decl":"/-- `Multifork.ofPiFork` as a functor. -/\n@[simps]\nnoncomputable def ofPiForkFunctor : Fork I.fstPiMap I.sndPiMap â¥¤ Multifork I where\n  obj := Multifork.ofPiFork I\n  map {Kâ‚ Kâ‚‚} f :=\n    { hom := f.hom\n      w := by rintro (_ | _) <;> simp }\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.ofPiForkFunctor_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct I.left\ninstâœ : CategoryTheory.Limits.HasProduct I.right\nc : CategoryTheory.Limits.Fork I.fstPiMap I.sndPiMap\nâŠ¢ Eq (I.ofPiForkFunctor.obj c) (CategoryTheory.Limits.Multifork.ofPiFork I c)","decl":"/-- `Multifork.ofPiFork` as a functor. -/\n@[simps]\nnoncomputable def ofPiForkFunctor : Fork I.fstPiMap I.sndPiMap â¥¤ Multifork I where\n  obj := Multifork.ofPiFork I\n  map {Kâ‚ Kâ‚‚} f :=\n    { hom := f.hom\n      w := by rintro (_ | _) <;> simp }\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.multiforkEquivPiFork_unitIso","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct I.left\ninstâœ : CategoryTheory.Limits.HasProduct I.right\nâŠ¢ Eq I.multiforkEquivPiFork.unitIso (CategoryTheory.NatIso.ofComponents (fun K => CategoryTheory.Limits.Cones.ext (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.Limits.Multifork I)).obj K).pt) â‹¯) â‹¯)","decl":"/-- The category of multiforks is equivalent to the category of forks over `âˆá¶œ I.left â‡‰ âˆá¶œ I.right`.\nIt then follows from `CategoryTheory.IsLimit.ofPreservesConeTerminal` (or `reflects`) that it\npreserves and reflects limit cones.\n-/\n@[simps]\nnoncomputable def multiforkEquivPiFork : Multifork I â‰Œ Fork I.fstPiMap I.sndPiMap where\n  functor := toPiForkFunctor I\n  inverse := ofPiForkFunctor I\n  unitIso :=\n    NatIso.ofComponents fun K =>\n      Cones.ext (Iso.refl _) (by\n        rintro (_ | _) <;> simp [â† Fork.app_one_eq_Î¹_comp_left])\n  counitIso :=\n    NatIso.ofComponents fun K => Fork.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.multiforkEquivPiFork_inverse","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct I.left\ninstâœ : CategoryTheory.Limits.HasProduct I.right\nâŠ¢ Eq I.multiforkEquivPiFork.inverse I.ofPiForkFunctor","decl":"/-- The category of multiforks is equivalent to the category of forks over `âˆá¶œ I.left â‡‰ âˆá¶œ I.right`.\nIt then follows from `CategoryTheory.IsLimit.ofPreservesConeTerminal` (or `reflects`) that it\npreserves and reflects limit cones.\n-/\n@[simps]\nnoncomputable def multiforkEquivPiFork : Multifork I â‰Œ Fork I.fstPiMap I.sndPiMap where\n  functor := toPiForkFunctor I\n  inverse := ofPiForkFunctor I\n  unitIso :=\n    NatIso.ofComponents fun K =>\n      Cones.ext (Iso.refl _) (by\n        rintro (_ | _) <;> simp [â† Fork.app_one_eq_Î¹_comp_left])\n  counitIso :=\n    NatIso.ofComponents fun K => Fork.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.multiforkEquivPiFork_counitIso","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct I.left\ninstâœ : CategoryTheory.Limits.HasProduct I.right\nâŠ¢ Eq I.multiforkEquivPiFork.counitIso (CategoryTheory.NatIso.ofComponents (fun K => CategoryTheory.Limits.Fork.ext (CategoryTheory.Iso.refl ((I.ofPiForkFunctor.comp I.toPiForkFunctor).obj K).pt) â‹¯) â‹¯)","decl":"/-- The category of multiforks is equivalent to the category of forks over `âˆá¶œ I.left â‡‰ âˆá¶œ I.right`.\nIt then follows from `CategoryTheory.IsLimit.ofPreservesConeTerminal` (or `reflects`) that it\npreserves and reflects limit cones.\n-/\n@[simps]\nnoncomputable def multiforkEquivPiFork : Multifork I â‰Œ Fork I.fstPiMap I.sndPiMap where\n  functor := toPiForkFunctor I\n  inverse := ofPiForkFunctor I\n  unitIso :=\n    NatIso.ofComponents fun K =>\n      Cones.ext (Iso.refl _) (by\n        rintro (_ | _) <;> simp [â† Fork.app_one_eq_Î¹_comp_left])\n  counitIso :=\n    NatIso.ofComponents fun K => Fork.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.multiforkEquivPiFork_functor","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct I.left\ninstâœ : CategoryTheory.Limits.HasProduct I.right\nâŠ¢ Eq I.multiforkEquivPiFork.functor I.toPiForkFunctor","decl":"/-- The category of multiforks is equivalent to the category of forks over `âˆá¶œ I.left â‡‰ âˆá¶œ I.right`.\nIt then follows from `CategoryTheory.IsLimit.ofPreservesConeTerminal` (or `reflects`) that it\npreserves and reflects limit cones.\n-/\n@[simps]\nnoncomputable def multiforkEquivPiFork : Multifork I â‰Œ Fork I.fstPiMap I.sndPiMap where\n  functor := toPiForkFunctor I\n  inverse := ofPiForkFunctor I\n  unitIso :=\n    NatIso.ofComponents fun K =>\n      Cones.ext (Iso.refl _) (by\n        rintro (_ | _) <;> simp [â† Fork.app_one_eq_Î¹_comp_left])\n  counitIso :=\n    NatIso.ofComponents fun K => Fork.ext (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.Ï€_eq_app_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\nK : CategoryTheory.Limits.Multicofork I\nb : I.R\nâŠ¢ Eq (K.Î¹.app (CategoryTheory.Limits.WalkingMultispan.right b)) (K.Ï€ b)","decl":"@[simp]\ntheorem Ï€_eq_app_right (b) : K.Î¹.app (WalkingMultispan.right _) = K.Ï€ b :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.fst_app_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\nK : CategoryTheory.Limits.Multicofork I\na : I.L\nâŠ¢ Eq (K.Î¹.app (CategoryTheory.Limits.WalkingMultispan.left a)) (CategoryTheory.CategoryStruct.comp (I.fst a) (K.Ï€ (I.fstFrom a)))","decl":"@[simp]\ntheorem fst_app_right (a) : K.Î¹.app (WalkingMultispan.left a) = I.fst a â‰« K.Ï€ _ := by\n  rw [â† K.w (WalkingMultispan.Hom.fst a)]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.snd_app_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\nK : CategoryTheory.Limits.Multicofork I\na : I.L\nâŠ¢ Eq (K.Î¹.app (CategoryTheory.Limits.WalkingMultispan.left a)) (CategoryTheory.CategoryStruct.comp (I.snd a) (K.Ï€ (I.sndFrom a)))","decl":"@[reassoc]\ntheorem snd_app_right (a) : K.Î¹.app (WalkingMultispan.left a) = I.snd a â‰« K.Ï€ _ := by\n  rw [â† K.w (WalkingMultispan.Hom.snd a)]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.snd_app_right_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\nK : CategoryTheory.Limits.Multicofork I\na : I.L\nZ : C\nh : Quiver.Hom (((CategoryTheory.Functor.const (CategoryTheory.Limits.WalkingMultispan I.fstFrom I.sndFrom)).obj K.pt).obj (CategoryTheory.Limits.WalkingMultispan.left a)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (K.Î¹.app (CategoryTheory.Limits.WalkingMultispan.left a)) h) (CategoryTheory.CategoryStruct.comp (I.snd a) (CategoryTheory.CategoryStruct.comp (K.Ï€ (I.sndFrom a)) h))","decl":"@[reassoc]\ntheorem snd_app_right (a) : K.Î¹.app (WalkingMultispan.left a) = I.snd a â‰« K.Ï€ _ := by\n  rw [â† K.w (WalkingMultispan.Hom.snd a)]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.Ï€_comp_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\nKâ‚ Kâ‚‚ : CategoryTheory.Limits.Multicofork I\nf : Quiver.Hom Kâ‚ Kâ‚‚\nb : I.R\nZ : C\nh : Quiver.Hom Kâ‚‚.pt Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (Kâ‚.Ï€ b) (CategoryTheory.CategoryStruct.comp f.hom h)) (CategoryTheory.CategoryStruct.comp (Kâ‚‚.Ï€ b) h)","decl":"@[reassoc (attr := simp)]\nlemma Ï€_comp_hom (Kâ‚ Kâ‚‚ : Multicofork I) (f : Kâ‚ âŸ¶ Kâ‚‚) (b : I.R) : Kâ‚.Ï€ b â‰« f.hom = Kâ‚‚.Ï€ b :=\n  f.w _\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.Ï€_comp_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\nKâ‚ Kâ‚‚ : CategoryTheory.Limits.Multicofork I\nf : Quiver.Hom Kâ‚ Kâ‚‚\nb : I.R\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (Kâ‚.Ï€ b) f.hom) (Kâ‚‚.Ï€ b)","decl":"@[reassoc (attr := simp)]\nlemma Ï€_comp_hom (Kâ‚ Kâ‚‚ : Multicofork I) (f : Kâ‚ âŸ¶ Kâ‚‚) (b : I.R) : Kâ‚.Ï€ b â‰« f.hom = Kâ‚‚.Ï€ b :=\n  f.w _\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.ofÏ€_Î¹_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\nP : C\nÏ€ : (b : I.R) â†’ Quiver.Hom (I.right b) P\nw : âˆ€ (a : I.L), Eq (CategoryTheory.CategoryStruct.comp (I.fst a) (Ï€ (I.fstFrom a))) (CategoryTheory.CategoryStruct.comp (I.snd a) (Ï€ (I.sndFrom a)))\nx : CategoryTheory.Limits.WalkingMultispan I.fstFrom I.sndFrom\nâŠ¢ Eq ((CategoryTheory.Limits.Multicofork.ofÏ€ I P Ï€ w).Î¹.app x) (CategoryTheory.Limits.MultispanIndex.multispan.match_1 I (fun x => Quiver.Hom (I.multispan.obj x) (((CategoryTheory.Functor.const (CategoryTheory.Limits.WalkingMultispan I.fstFrom I.sndFrom)).obj P).obj x)) x (fun a => CategoryTheory.CategoryStruct.comp (I.fst a) (Ï€ (I.fstFrom a))) fun a => Ï€ a)","decl":"/-- Construct a multicofork using a collection `Ï€` of morphisms. -/\n@[simps]\ndef ofÏ€ (I : MultispanIndex.{w, w'} C) (P : C) (Ï€ : âˆ€ b, I.right b âŸ¶ P)\n    (w : âˆ€ a, I.fst a â‰« Ï€ (I.fstFrom a) = I.snd a â‰« Ï€ (I.sndFrom a)) : Multicofork I where\n  pt := P\n  Î¹ :=\n    { app := fun x =>\n        match x with\n        | WalkingMultispan.left a => I.fst a â‰« Ï€ _\n        | WalkingMultispan.right _ => Ï€ _\n      naturality := by\n        rintro (_ | _) (_ | _) (_ | _ | _) <;> dsimp <;>\n          simp only [Functor.map_id, MultispanIndex.multispan_obj_left,\n            Category.id_comp, Category.comp_id, MultispanIndex.multispan_obj_right]\n        symm\n        apply w }\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.ofÏ€_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\nP : C\nÏ€ : (b : I.R) â†’ Quiver.Hom (I.right b) P\nw : âˆ€ (a : I.L), Eq (CategoryTheory.CategoryStruct.comp (I.fst a) (Ï€ (I.fstFrom a))) (CategoryTheory.CategoryStruct.comp (I.snd a) (Ï€ (I.sndFrom a)))\nâŠ¢ Eq (CategoryTheory.Limits.Multicofork.ofÏ€ I P Ï€ w).pt P","decl":"/-- Construct a multicofork using a collection `Ï€` of morphisms. -/\n@[simps]\ndef ofÏ€ (I : MultispanIndex.{w, w'} C) (P : C) (Ï€ : âˆ€ b, I.right b âŸ¶ P)\n    (w : âˆ€ a, I.fst a â‰« Ï€ (I.fstFrom a) = I.snd a â‰« Ï€ (I.sndFrom a)) : Multicofork I where\n  pt := P\n  Î¹ :=\n    { app := fun x =>\n        match x with\n        | WalkingMultispan.left a => I.fst a â‰« Ï€ _\n        | WalkingMultispan.right _ => Ï€ _\n      naturality := by\n        rintro (_ | _) (_ | _) (_ | _ | _) <;> dsimp <;>\n          simp only [Functor.map_id, MultispanIndex.multispan_obj_left,\n            Category.id_comp, Category.comp_id, MultispanIndex.multispan_obj_right]\n        symm\n        apply w }\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\nK : CategoryTheory.Limits.Multicofork I\na : I.L\nZ : C\nh : Quiver.Hom K.pt Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (I.fst a) (CategoryTheory.CategoryStruct.comp (K.Ï€ (I.fstFrom a)) h)) (CategoryTheory.CategoryStruct.comp (I.snd a) (CategoryTheory.CategoryStruct.comp (K.Ï€ (I.sndFrom a)) h))","decl":"@[reassoc (attr := simp)]\ntheorem condition (a) : I.fst a â‰« K.Ï€ (I.fstFrom a) = I.snd a â‰« K.Ï€ (I.sndFrom a) := by\n  rw [â† K.snd_app_right, â† K.fst_app_right]\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\nK : CategoryTheory.Limits.Multicofork I\na : I.L\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (I.fst a) (K.Ï€ (I.fstFrom a))) (CategoryTheory.CategoryStruct.comp (I.snd a) (K.Ï€ (I.sndFrom a)))","decl":"@[reassoc (attr := simp)]\ntheorem condition (a) : I.fst a â‰« K.Ï€ (I.fstFrom a) = I.snd a â‰« K.Ï€ (I.sndFrom a) := by\n  rw [â† K.snd_app_right, â† K.fst_app_right]\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.IsColimit.mk_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\nK : CategoryTheory.Limits.Multicofork I\ndesc : (E : CategoryTheory.Limits.Multicofork I) â†’ Quiver.Hom K.pt E.pt\nfac : âˆ€ (E : CategoryTheory.Limits.Multicofork I) (i : I.R), Eq (CategoryTheory.CategoryStruct.comp (K.Ï€ i) (desc E)) (E.Ï€ i)\nuniq : âˆ€ (E : CategoryTheory.Limits.Multicofork I) (m : Quiver.Hom K.pt E.pt), (âˆ€ (i : I.R), Eq (CategoryTheory.CategoryStruct.comp (K.Ï€ i) m) (E.Ï€ i)) â†’ Eq m (desc E)\nE : CategoryTheory.Limits.Multicofork I\nâŠ¢ Eq ((CategoryTheory.Limits.Multicofork.IsColimit.mk K desc fac uniq).desc E) (desc E)","decl":"/-- This definition provides a convenient way to show that a multicofork is a colimit. -/\n@[simps]\ndef IsColimit.mk (desc : âˆ€ E : Multicofork I, K.pt âŸ¶ E.pt)\n    (fac : âˆ€ (E : Multicofork I) (i : I.R), K.Ï€ i â‰« desc E = E.Ï€ i)\n    (uniq : âˆ€ (E : Multicofork I) (m : K.pt âŸ¶ E.pt), (âˆ€ i : I.R, K.Ï€ i â‰« m = E.Ï€ i) â†’ m = desc E) :\n    IsColimit K :=\n  { desc\n    fac := by\n      rintro S (a | b)\n      Â· rw [â† K.w (WalkingMultispan.Hom.fst a), â† S.w (WalkingMultispan.Hom.fst a),\n          Category.assoc]\n        congr 1\n        apply fac\n      Â· apply fac\n    uniq := by\n      intro S m hm\n      apply uniq\n      intro i\n      apply hm }\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.sigma_condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\nK : CategoryTheory.Limits.Multicofork I\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct I.left\ninstâœ : CategoryTheory.Limits.HasCoproduct I.right\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp I.fstSigmaMap (CategoryTheory.Limits.Sigma.desc K.Ï€)) (CategoryTheory.CategoryStruct.comp I.sndSigmaMap (CategoryTheory.Limits.Sigma.desc K.Ï€))","decl":"@[reassoc (attr := simp)]\ntheorem sigma_condition : I.fstSigmaMap â‰« Sigma.desc K.Ï€ = I.sndSigmaMap â‰« Sigma.desc K.Ï€ := by\n  ext\n  simp\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.sigma_condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\nK : CategoryTheory.Limits.Multicofork I\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct I.left\ninstâœ : CategoryTheory.Limits.HasCoproduct I.right\nZ : C\nh : Quiver.Hom K.pt Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp I.fstSigmaMap (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.desc K.Ï€) h)) (CategoryTheory.CategoryStruct.comp I.sndSigmaMap (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.desc K.Ï€) h))","decl":"@[reassoc (attr := simp)]\ntheorem sigma_condition : I.fstSigmaMap â‰« Sigma.desc K.Ï€ = I.sndSigmaMap â‰« Sigma.desc K.Ï€ := by\n  ext\n  simp\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.toSigmaCofork_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct I.left\ninstâœ : CategoryTheory.Limits.HasCoproduct I.right\nK : CategoryTheory.Limits.Multicofork I\nâŠ¢ Eq K.toSigmaCofork.pt K.pt","decl":"/-- Given a multicofork, we may obtain a cofork over `âˆ I.left â‡‰ âˆ I.right`. -/\n@[simps pt]\nnoncomputable def toSigmaCofork (K : Multicofork I) : Cofork I.fstSigmaMap I.sndSigmaMap where\n  pt := K.pt\n  Î¹ :=\n    { app := fun x =>\n        match x with\n        | WalkingParallelPair.zero => I.fstSigmaMap â‰« Sigma.desc K.Ï€\n        | WalkingParallelPair.one => Sigma.desc K.Ï€\n      naturality := by\n        rintro (_ | _) (_ | _) (_ | _ | _) <;> dsimp <;>\n          simp only [Functor.map_id, parallelPair_obj_zero,\n            parallelPair_obj_one, sigma_condition, Category.id_comp, Category.comp_id] }\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.toSigmaCofork_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\nK : CategoryTheory.Limits.Multicofork I\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct I.left\ninstâœ : CategoryTheory.Limits.HasCoproduct I.right\nâŠ¢ Eq K.toSigmaCofork.Ï€ (CategoryTheory.Limits.Sigma.desc K.Ï€)","decl":"@[simp]\ntheorem toSigmaCofork_Ï€ : K.toSigmaCofork.Ï€ = Sigma.desc K.Ï€ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.ofSigmaCofork_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct I.left\ninstâœ : CategoryTheory.Limits.HasCoproduct I.right\nc : CategoryTheory.Limits.Cofork I.fstSigmaMap I.sndSigmaMap\nâŠ¢ Eq (CategoryTheory.Limits.Multicofork.ofSigmaCofork I c).pt c.pt","decl":"/-- Given a cofork over `âˆ I.left â‡‰ âˆ I.right`, we may obtain a multicofork. -/\n@[simps pt]\nnoncomputable def ofSigmaCofork (c : Cofork I.fstSigmaMap I.sndSigmaMap) : Multicofork I where\n  pt := c.pt\n  Î¹ :=\n    { app := fun x =>\n        match x with\n        | WalkingMultispan.left a => (Sigma.Î¹ I.left a :) â‰« I.fstSigmaMap â‰« c.Ï€\n        | WalkingMultispan.right b => (Sigma.Î¹ I.right b :) â‰« c.Ï€\n      naturality := by\n        rintro (_ | _) (_ | _) (_ | _ | _)\n        Â· simp\n        Â· simp\n        Â· simp [c.condition]\n        Â· simp }\n\n-- Porting note: https://github.com/leanprover-community/mathlib4/issues/10675\n-- dsimp cannot prove this, once ofSigmaCofork_Î¹_app_right' is defined\n"}
{"name":"CategoryTheory.Limits.Multicofork.ofSigmaCofork_Î¹_app_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct I.left\ninstâœ : CategoryTheory.Limits.HasCoproduct I.right\nc : CategoryTheory.Limits.Cofork I.fstSigmaMap I.sndSigmaMap\na : I.L\nâŠ¢ Eq ((CategoryTheory.Limits.Multicofork.ofSigmaCofork I c).Î¹.app (CategoryTheory.Limits.WalkingMultispan.left a)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ I.left a) (CategoryTheory.CategoryStruct.comp I.fstSigmaMap c.Ï€))","decl":"@[simp]\ntheorem ofSigmaCofork_Î¹_app_left (c : Cofork I.fstSigmaMap I.sndSigmaMap) (a) :\n    (ofSigmaCofork I c).Î¹.app (WalkingMultispan.left a) =\n      (Sigma.Î¹ I.left a :) â‰« I.fstSigmaMap â‰« c.Ï€ :=\n  rfl\n\n-- @[simp] -- Porting note: LHS simplifies to obtain the normal form below\n"}
{"name":"CategoryTheory.Limits.Multicofork.ofSigmaCofork_Î¹_app_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct I.left\ninstâœ : CategoryTheory.Limits.HasCoproduct I.right\nc : CategoryTheory.Limits.Cofork I.fstSigmaMap I.sndSigmaMap\nb : I.R\nâŠ¢ Eq ((CategoryTheory.Limits.Multicofork.ofSigmaCofork I c).Î¹.app (CategoryTheory.Limits.WalkingMultispan.right b)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ I.right b) c.Ï€)","decl":"theorem ofSigmaCofork_Î¹_app_right (c : Cofork I.fstSigmaMap I.sndSigmaMap) (b) :\n    (ofSigmaCofork I c).Î¹.app (WalkingMultispan.right b) = (Sigma.Î¹ I.right b :) â‰« c.Ï€ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multicofork.ofSigmaCofork_Î¹_app_right'","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct I.left\ninstâœ : CategoryTheory.Limits.HasCoproduct I.right\nc : CategoryTheory.Limits.Cofork I.fstSigmaMap I.sndSigmaMap\nb : I.R\nâŠ¢ Eq ((CategoryTheory.Limits.Multicofork.ofSigmaCofork I c).Ï€ b) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ I.right b) c.Ï€)","decl":"@[simp]\ntheorem ofSigmaCofork_Î¹_app_right' (c : Cofork I.fstSigmaMap I.sndSigmaMap) (b) :\n    Ï€ (ofSigmaCofork I c) b = (Sigma.Î¹ I.right b :) â‰« c.Ï€ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.toSigmaCoforkFunctor_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct I.left\ninstâœ : CategoryTheory.Limits.HasCoproduct I.right\nK : CategoryTheory.Limits.Multicofork I\nâŠ¢ Eq (I.toSigmaCoforkFunctor.obj K) K.toSigmaCofork","decl":"/-- `Multicofork.toSigmaCofork` as a functor. -/\n@[simps]\nnoncomputable def toSigmaCoforkFunctor : Multicofork I â¥¤ Cofork I.fstSigmaMap I.sndSigmaMap where\n  obj := Multicofork.toSigmaCofork\n  map {Kâ‚ Kâ‚‚} f :=\n  { hom := f.hom\n    w := by\n      rintro (_|_)\n      all_goals {\n        apply colimit.hom_ext\n        rintro âŸ¨jâŸ©\n        simp } }\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.toSigmaCoforkFunctor_map_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct I.left\ninstâœ : CategoryTheory.Limits.HasCoproduct I.right\nKâ‚ Kâ‚‚ : CategoryTheory.Limits.Multicofork I\nf : Quiver.Hom Kâ‚ Kâ‚‚\nâŠ¢ Eq (I.toSigmaCoforkFunctor.map f).hom f.hom","decl":"/-- `Multicofork.toSigmaCofork` as a functor. -/\n@[simps]\nnoncomputable def toSigmaCoforkFunctor : Multicofork I â¥¤ Cofork I.fstSigmaMap I.sndSigmaMap where\n  obj := Multicofork.toSigmaCofork\n  map {Kâ‚ Kâ‚‚} f :=\n  { hom := f.hom\n    w := by\n      rintro (_|_)\n      all_goals {\n        apply colimit.hom_ext\n        rintro âŸ¨jâŸ©\n        simp } }\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.ofSigmaCoforkFunctor_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct I.left\ninstâœ : CategoryTheory.Limits.HasCoproduct I.right\nc : CategoryTheory.Limits.Cofork I.fstSigmaMap I.sndSigmaMap\nâŠ¢ Eq (I.ofSigmaCoforkFunctor.obj c) (CategoryTheory.Limits.Multicofork.ofSigmaCofork I c)","decl":"/-- `Multicofork.ofSigmaCofork` as a functor. -/\n@[simps]\nnoncomputable def ofSigmaCoforkFunctor : Cofork I.fstSigmaMap I.sndSigmaMap â¥¤ Multicofork I where\n  obj := Multicofork.ofSigmaCofork I\n  map {Kâ‚ Kâ‚‚} f :=\n    { hom := f.hom\n      w := by --sorry --by rintro (_ | _) <;> simp\n        rintro (_ | _)\n        -- porting note; in mathlib3, `simp` worked. What seems to be happening is that\n        -- the `simp` set is not confluent, and mathlib3 found\n        -- `Multicofork.ofSigmaCofork_Î¹_app_left` before `Multicofork.fst_app_right`,\n        -- but mathlib4 finds `Multicofork.fst_app_right` first.\n        { simp [-Multicofork.fst_app_right] }\n        -- Porting note: similarly here, the `simp` set seems to be non-confluent\n        { simp [-Multicofork.ofSigmaCofork_pt] } }\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.ofSigmaCoforkFunctor_map_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct I.left\ninstâœ : CategoryTheory.Limits.HasCoproduct I.right\nKâ‚ Kâ‚‚ : CategoryTheory.Limits.Cofork I.fstSigmaMap I.sndSigmaMap\nf : Quiver.Hom Kâ‚ Kâ‚‚\nâŠ¢ Eq (I.ofSigmaCoforkFunctor.map f).hom f.hom","decl":"/-- `Multicofork.ofSigmaCofork` as a functor. -/\n@[simps]\nnoncomputable def ofSigmaCoforkFunctor : Cofork I.fstSigmaMap I.sndSigmaMap â¥¤ Multicofork I where\n  obj := Multicofork.ofSigmaCofork I\n  map {Kâ‚ Kâ‚‚} f :=\n    { hom := f.hom\n      w := by --sorry --by rintro (_ | _) <;> simp\n        rintro (_ | _)\n        -- porting note; in mathlib3, `simp` worked. What seems to be happening is that\n        -- the `simp` set is not confluent, and mathlib3 found\n        -- `Multicofork.ofSigmaCofork_Î¹_app_left` before `Multicofork.fst_app_right`,\n        -- but mathlib4 finds `Multicofork.fst_app_right` first.\n        { simp [-Multicofork.fst_app_right] }\n        -- Porting note: similarly here, the `simp` set seems to be non-confluent\n        { simp [-Multicofork.ofSigmaCofork_pt] } }\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.multicoforkEquivSigmaCofork_counitIso","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct I.left\ninstâœ : CategoryTheory.Limits.HasCoproduct I.right\nâŠ¢ Eq I.multicoforkEquivSigmaCofork.counitIso (CategoryTheory.NatIso.ofComponents (fun K => CategoryTheory.Limits.Cofork.ext (CategoryTheory.Iso.refl ((I.ofSigmaCoforkFunctor.comp I.toSigmaCoforkFunctor).obj K).pt) â‹¯) â‹¯)","decl":"/--\nThe category of multicoforks is equivalent to the category of coforks over `âˆ I.left â‡‰ âˆ I.right`.\nIt then follows from `CategoryTheory.IsColimit.ofPreservesCoconeInitial` (or `reflects`) that\nit preserves and reflects colimit cocones.\n-/\n@[simps]\nnoncomputable def multicoforkEquivSigmaCofork :\n    Multicofork I â‰Œ Cofork I.fstSigmaMap I.sndSigmaMap where\n  functor := toSigmaCoforkFunctor I\n  inverse := ofSigmaCoforkFunctor I\n  unitIso := NatIso.ofComponents fun K => Cocones.ext (Iso.refl _) (by\n      rintro (_ | _) <;> simp)\n  counitIso := NatIso.ofComponents fun K =>\n    Cofork.ext (Iso.refl _)\n      (by\n        -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): in mathlib3 this was just `ext` and I don't know why it's not here\n        apply Limits.colimit.hom_ext\n        rintro âŸ¨jâŸ©\n        dsimp\n        simp only [Category.comp_id, colimit.Î¹_desc, Cofan.mk_Î¹_app]\n        rfl)\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.multicoforkEquivSigmaCofork_inverse","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct I.left\ninstâœ : CategoryTheory.Limits.HasCoproduct I.right\nâŠ¢ Eq I.multicoforkEquivSigmaCofork.inverse I.ofSigmaCoforkFunctor","decl":"/--\nThe category of multicoforks is equivalent to the category of coforks over `âˆ I.left â‡‰ âˆ I.right`.\nIt then follows from `CategoryTheory.IsColimit.ofPreservesCoconeInitial` (or `reflects`) that\nit preserves and reflects colimit cocones.\n-/\n@[simps]\nnoncomputable def multicoforkEquivSigmaCofork :\n    Multicofork I â‰Œ Cofork I.fstSigmaMap I.sndSigmaMap where\n  functor := toSigmaCoforkFunctor I\n  inverse := ofSigmaCoforkFunctor I\n  unitIso := NatIso.ofComponents fun K => Cocones.ext (Iso.refl _) (by\n      rintro (_ | _) <;> simp)\n  counitIso := NatIso.ofComponents fun K =>\n    Cofork.ext (Iso.refl _)\n      (by\n        -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): in mathlib3 this was just `ext` and I don't know why it's not here\n        apply Limits.colimit.hom_ext\n        rintro âŸ¨jâŸ©\n        dsimp\n        simp only [Category.comp_id, colimit.Î¹_desc, Cofan.mk_Î¹_app]\n        rfl)\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.multicoforkEquivSigmaCofork_unitIso","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct I.left\ninstâœ : CategoryTheory.Limits.HasCoproduct I.right\nâŠ¢ Eq I.multicoforkEquivSigmaCofork.unitIso (CategoryTheory.NatIso.ofComponents (fun K => CategoryTheory.Limits.Cocones.ext (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.Limits.Multicofork I)).obj K).pt) â‹¯) â‹¯)","decl":"/--\nThe category of multicoforks is equivalent to the category of coforks over `âˆ I.left â‡‰ âˆ I.right`.\nIt then follows from `CategoryTheory.IsColimit.ofPreservesCoconeInitial` (or `reflects`) that\nit preserves and reflects colimit cocones.\n-/\n@[simps]\nnoncomputable def multicoforkEquivSigmaCofork :\n    Multicofork I â‰Œ Cofork I.fstSigmaMap I.sndSigmaMap where\n  functor := toSigmaCoforkFunctor I\n  inverse := ofSigmaCoforkFunctor I\n  unitIso := NatIso.ofComponents fun K => Cocones.ext (Iso.refl _) (by\n      rintro (_ | _) <;> simp)\n  counitIso := NatIso.ofComponents fun K =>\n    Cofork.ext (Iso.refl _)\n      (by\n        -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): in mathlib3 this was just `ext` and I don't know why it's not here\n        apply Limits.colimit.hom_ext\n        rintro âŸ¨jâŸ©\n        dsimp\n        simp only [Category.comp_id, colimit.Î¹_desc, Cofan.mk_Î¹_app]\n        rfl)\n\n"}
{"name":"CategoryTheory.Limits.MultispanIndex.multicoforkEquivSigmaCofork_functor","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct I.left\ninstâœ : CategoryTheory.Limits.HasCoproduct I.right\nâŠ¢ Eq I.multicoforkEquivSigmaCofork.functor I.toSigmaCoforkFunctor","decl":"/--\nThe category of multicoforks is equivalent to the category of coforks over `âˆ I.left â‡‰ âˆ I.right`.\nIt then follows from `CategoryTheory.IsColimit.ofPreservesCoconeInitial` (or `reflects`) that\nit preserves and reflects colimit cocones.\n-/\n@[simps]\nnoncomputable def multicoforkEquivSigmaCofork :\n    Multicofork I â‰Œ Cofork I.fstSigmaMap I.sndSigmaMap where\n  functor := toSigmaCoforkFunctor I\n  inverse := ofSigmaCoforkFunctor I\n  unitIso := NatIso.ofComponents fun K => Cocones.ext (Iso.refl _) (by\n      rintro (_ | _) <;> simp)\n  counitIso := NatIso.ofComponents fun K =>\n    Cofork.ext (Iso.refl _)\n      (by\n        -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): in mathlib3 this was just `ext` and I don't know why it's not here\n        apply Limits.colimit.hom_ext\n        rintro âŸ¨jâŸ©\n        dsimp\n        simp only [Category.comp_id, colimit.Î¹_desc, Cofan.mk_Î¹_app]\n        rfl)\n\n"}
{"name":"CategoryTheory.Limits.Multiequalizer.multifork_Î¹","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninstâœ : CategoryTheory.Limits.HasMultiequalizer I\na : I.L\nâŠ¢ Eq ((CategoryTheory.Limits.Multiequalizer.multifork I).Î¹ a) (CategoryTheory.Limits.Multiequalizer.Î¹ I a)","decl":"@[simp]\ntheorem multifork_Î¹ (a) : (Multiequalizer.multifork I).Î¹ a = Multiequalizer.Î¹ I a :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multiequalizer.multifork_Ï€_app_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninstâœ : CategoryTheory.Limits.HasMultiequalizer I\na : I.L\nâŠ¢ Eq ((CategoryTheory.Limits.Multiequalizer.multifork I).Ï€.app (CategoryTheory.Limits.WalkingMulticospan.left a)) (CategoryTheory.Limits.Multiequalizer.Î¹ I a)","decl":"@[simp]\ntheorem multifork_Ï€_app_left (a) :\n    (Multiequalizer.multifork I).Ï€.app (WalkingMulticospan.left a) = Multiequalizer.Î¹ I a :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multiequalizer.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninstâœ : CategoryTheory.Limits.HasMultiequalizer I\nb : I.R\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multiequalizer.Î¹ I (I.fstTo b)) (I.fst b)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multiequalizer.Î¹ I (I.sndTo b)) (I.snd b))","decl":"@[reassoc]\ntheorem condition (b) :\n    Multiequalizer.Î¹ I (I.fstTo b) â‰« I.fst b = Multiequalizer.Î¹ I (I.sndTo b) â‰« I.snd b :=\n  Multifork.condition _ _\n\n"}
{"name":"CategoryTheory.Limits.Multiequalizer.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninstâœ : CategoryTheory.Limits.HasMultiequalizer I\nb : I.R\nZ : C\nh : Quiver.Hom (I.right b) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multiequalizer.Î¹ I (I.fstTo b)) (CategoryTheory.CategoryStruct.comp (I.fst b) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multiequalizer.Î¹ I (I.sndTo b)) (CategoryTheory.CategoryStruct.comp (I.snd b) h))","decl":"@[reassoc]\ntheorem condition (b) :\n    Multiequalizer.Î¹ I (I.fstTo b) â‰« I.fst b = Multiequalizer.Î¹ I (I.sndTo b) â‰« I.snd b :=\n  Multifork.condition _ _\n\n"}
{"name":"CategoryTheory.Limits.Multiequalizer.lift_Î¹","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninstâœ : CategoryTheory.Limits.HasMultiequalizer I\nW : C\nk : (a : I.L) â†’ Quiver.Hom W (I.left a)\nh : âˆ€ (b : I.R), Eq (CategoryTheory.CategoryStruct.comp (k (I.fstTo b)) (I.fst b)) (CategoryTheory.CategoryStruct.comp (k (I.sndTo b)) (I.snd b))\na : I.L\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multiequalizer.lift I W k h) (CategoryTheory.Limits.Multiequalizer.Î¹ I a)) (k a)","decl":"@[reassoc]\ntheorem lift_Î¹ (W : C) (k : âˆ€ a, W âŸ¶ I.left a)\n    (h : âˆ€ b, k (I.fstTo b) â‰« I.fst b = k (I.sndTo b) â‰« I.snd b) (a) :\n    Multiequalizer.lift I _ k h â‰« Multiequalizer.Î¹ I a = k _ :=\n  limit.lift_Ï€ _ _\n\n"}
{"name":"CategoryTheory.Limits.Multiequalizer.lift_Î¹_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninstâœ : CategoryTheory.Limits.HasMultiequalizer I\nW : C\nk : (a : I.L) â†’ Quiver.Hom W (I.left a)\nhâœ : âˆ€ (b : I.R), Eq (CategoryTheory.CategoryStruct.comp (k (I.fstTo b)) (I.fst b)) (CategoryTheory.CategoryStruct.comp (k (I.sndTo b)) (I.snd b))\na : I.L\nZ : C\nh : Quiver.Hom (I.left a) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multiequalizer.lift I W k hâœ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multiequalizer.Î¹ I a) h)) (CategoryTheory.CategoryStruct.comp (k a) h)","decl":"@[reassoc]\ntheorem lift_Î¹ (W : C) (k : âˆ€ a, W âŸ¶ I.left a)\n    (h : âˆ€ b, k (I.fstTo b) â‰« I.fst b = k (I.sndTo b) â‰« I.snd b) (a) :\n    Multiequalizer.lift I _ k h â‰« Multiequalizer.Î¹ I a = k _ :=\n  limit.lift_Ï€ _ _\n\n"}
{"name":"CategoryTheory.Limits.Multiequalizer.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninstâœ : CategoryTheory.Limits.HasMultiequalizer I\nW : C\ni j : Quiver.Hom W (CategoryTheory.Limits.multiequalizer I)\nh : âˆ€ (a : I.L), Eq (CategoryTheory.CategoryStruct.comp i (CategoryTheory.Limits.Multiequalizer.Î¹ I a)) (CategoryTheory.CategoryStruct.comp j (CategoryTheory.Limits.Multiequalizer.Î¹ I a))\nâŠ¢ Eq i j","decl":"@[ext]\ntheorem hom_ext {W : C} (i j : W âŸ¶ multiequalizer I)\n    (h : âˆ€ a, i â‰« Multiequalizer.Î¹ I a = j â‰« Multiequalizer.Î¹ I a) : i = j :=\n  Multifork.IsLimit.hom_ext (limit.isLimit _) h\n\n"}
{"name":"CategoryTheory.Limits.Multiequalizer.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninstâœ : CategoryTheory.Limits.HasMultiequalizer I\nW : C\ni j : Quiver.Hom W (CategoryTheory.Limits.multiequalizer I)\nâŠ¢ Iff (Eq i j) (âˆ€ (a : I.L), Eq (CategoryTheory.CategoryStruct.comp i (CategoryTheory.Limits.Multiequalizer.Î¹ I a)) (CategoryTheory.CategoryStruct.comp j (CategoryTheory.Limits.Multiequalizer.Î¹ I a)))","decl":"@[ext]\ntheorem hom_ext {W : C} (i j : W âŸ¶ multiequalizer I)\n    (h : âˆ€ a, i â‰« Multiequalizer.Î¹ I a = j â‰« Multiequalizer.Î¹ I a) : i = j :=\n  Multifork.IsLimit.hom_ext (limit.isLimit _) h\n\n"}
{"name":"CategoryTheory.Limits.Multiequalizer.instHasEqualizerFstPiMapSndPiMap","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninstâœÂ² : CategoryTheory.Limits.HasMultiequalizer I\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct I.left\ninstâœ : CategoryTheory.Limits.HasProduct I.right\nâŠ¢ CategoryTheory.Limits.HasEqualizer I.fstPiMap I.sndPiMap","decl":"instance : HasEqualizer I.fstPiMap I.sndPiMap :=\n  âŸ¨âŸ¨âŸ¨_, IsLimit.ofPreservesConeTerminal I.multiforkEquivPiFork.functor (limit.isLimit _)âŸ©âŸ©âŸ©\n\n"}
{"name":"CategoryTheory.Limits.Multiequalizer.Î¹Pi_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninstâœÂ² : CategoryTheory.Limits.HasMultiequalizer I\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct I.left\ninstâœ : CategoryTheory.Limits.HasProduct I.right\na : I.L\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multiequalizer.Î¹Pi I) (CategoryTheory.Limits.Pi.Ï€ I.left a)) (CategoryTheory.Limits.Multiequalizer.Î¹ I a)","decl":"@[reassoc (attr := simp)]\ntheorem Î¹Pi_Ï€ (a) : Î¹Pi I â‰« Pi.Ï€ I.left a = Î¹ I a := by\n  rw [Î¹Pi, Category.assoc, â† Iso.eq_inv_comp, isoEqualizer]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.Multiequalizer.Î¹Pi_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninstâœÂ² : CategoryTheory.Limits.HasMultiequalizer I\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct I.left\ninstâœ : CategoryTheory.Limits.HasProduct I.right\na : I.L\nZ : C\nh : Quiver.Hom (I.left a) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multiequalizer.Î¹Pi I) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.Ï€ I.left a) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multiequalizer.Î¹ I a) h)","decl":"@[reassoc (attr := simp)]\ntheorem Î¹Pi_Ï€ (a) : Î¹Pi I â‰« Pi.Ï€ I.left a = Î¹ I a := by\n  rw [Î¹Pi, Category.assoc, â† Iso.eq_inv_comp, isoEqualizer]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.Multiequalizer.instMonoÎ¹Pi","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MulticospanIndex C\ninstâœÂ² : CategoryTheory.Limits.HasMultiequalizer I\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct I.left\ninstâœ : CategoryTheory.Limits.HasProduct I.right\nâŠ¢ CategoryTheory.Mono (CategoryTheory.Limits.Multiequalizer.Î¹Pi I)","decl":"instance : Mono (Î¹Pi I) := mono_comp _ _\n\n"}
{"name":"CategoryTheory.Limits.Multicoequalizer.multicofork_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninstâœ : CategoryTheory.Limits.HasMulticoequalizer I\nb : I.R\nâŠ¢ Eq ((CategoryTheory.Limits.Multicoequalizer.multicofork I).Ï€ b) (CategoryTheory.Limits.Multicoequalizer.Ï€ I b)","decl":"@[simp]\ntheorem multicofork_Ï€ (b) : (Multicoequalizer.multicofork I).Ï€ b = Multicoequalizer.Ï€ I b :=\n  rfl\n\n-- @[simp] -- Porting note: LHS simplifies to obtain the normal form below\n"}
{"name":"CategoryTheory.Limits.Multicoequalizer.multicofork_Î¹_app_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninstâœ : CategoryTheory.Limits.HasMulticoequalizer I\nb : I.R\nâŠ¢ Eq ((CategoryTheory.Limits.Multicoequalizer.multicofork I).Î¹.app (CategoryTheory.Limits.WalkingMultispan.right b)) (CategoryTheory.Limits.Multicoequalizer.Ï€ I b)","decl":"theorem multicofork_Î¹_app_right (b) :\n    (Multicoequalizer.multicofork I).Î¹.app (WalkingMultispan.right b) = Multicoequalizer.Ï€ I b :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multicoequalizer.multicofork_Î¹_app_right'","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninstâœ : CategoryTheory.Limits.HasMulticoequalizer I\nb : I.R\nâŠ¢ Eq (CategoryTheory.Limits.colimit.Î¹ I.multispan (CategoryTheory.Limits.WalkingMultispan.right b)) (CategoryTheory.Limits.Multicoequalizer.Ï€ I b)","decl":"@[simp]\ntheorem multicofork_Î¹_app_right' (b) :\n    colimit.Î¹ (MultispanIndex.multispan I) (WalkingMultispan.right b) = Ï€ I b :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multicoequalizer.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninstâœ : CategoryTheory.Limits.HasMulticoequalizer I\na : I.L\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.multicoequalizer I) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (I.fst a) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multicoequalizer.Ï€ I (I.fstFrom a)) h)) (CategoryTheory.CategoryStruct.comp (I.snd a) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multicoequalizer.Ï€ I (I.sndFrom a)) h))","decl":"@[reassoc]\ntheorem condition (a) :\n    I.fst a â‰« Multicoequalizer.Ï€ I (I.fstFrom a) = I.snd a â‰« Multicoequalizer.Ï€ I (I.sndFrom a) :=\n  Multicofork.condition _ _\n\n"}
{"name":"CategoryTheory.Limits.Multicoequalizer.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninstâœ : CategoryTheory.Limits.HasMulticoequalizer I\na : I.L\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (I.fst a) (CategoryTheory.Limits.Multicoequalizer.Ï€ I (I.fstFrom a))) (CategoryTheory.CategoryStruct.comp (I.snd a) (CategoryTheory.Limits.Multicoequalizer.Ï€ I (I.sndFrom a)))","decl":"@[reassoc]\ntheorem condition (a) :\n    I.fst a â‰« Multicoequalizer.Ï€ I (I.fstFrom a) = I.snd a â‰« Multicoequalizer.Ï€ I (I.sndFrom a) :=\n  Multicofork.condition _ _\n\n"}
{"name":"CategoryTheory.Limits.Multicoequalizer.Ï€_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninstâœ : CategoryTheory.Limits.HasMulticoequalizer I\nW : C\nk : (b : I.R) â†’ Quiver.Hom (I.right b) W\nh : âˆ€ (a : I.L), Eq (CategoryTheory.CategoryStruct.comp (I.fst a) (k (I.fstFrom a))) (CategoryTheory.CategoryStruct.comp (I.snd a) (k (I.sndFrom a)))\nb : I.R\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multicoequalizer.Ï€ I b) (CategoryTheory.Limits.Multicoequalizer.desc I W k h)) (k b)","decl":"@[reassoc]\ntheorem Ï€_desc (W : C) (k : âˆ€ b, I.right b âŸ¶ W)\n    (h : âˆ€ a, I.fst a â‰« k (I.fstFrom a) = I.snd a â‰« k (I.sndFrom a)) (b) :\n    Multicoequalizer.Ï€ I b â‰« Multicoequalizer.desc I _ k h = k _ :=\n  colimit.Î¹_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.Multicoequalizer.Ï€_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninstâœ : CategoryTheory.Limits.HasMulticoequalizer I\nW : C\nk : (b : I.R) â†’ Quiver.Hom (I.right b) W\nhâœ : âˆ€ (a : I.L), Eq (CategoryTheory.CategoryStruct.comp (I.fst a) (k (I.fstFrom a))) (CategoryTheory.CategoryStruct.comp (I.snd a) (k (I.sndFrom a)))\nb : I.R\nZ : C\nh : Quiver.Hom W Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multicoequalizer.Ï€ I b) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multicoequalizer.desc I W k hâœ) h)) (CategoryTheory.CategoryStruct.comp (k b) h)","decl":"@[reassoc]\ntheorem Ï€_desc (W : C) (k : âˆ€ b, I.right b âŸ¶ W)\n    (h : âˆ€ a, I.fst a â‰« k (I.fstFrom a) = I.snd a â‰« k (I.sndFrom a)) (b) :\n    Multicoequalizer.Ï€ I b â‰« Multicoequalizer.desc I _ k h = k _ :=\n  colimit.Î¹_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.Multicoequalizer.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninstâœ : CategoryTheory.Limits.HasMulticoequalizer I\nW : C\ni j : Quiver.Hom (CategoryTheory.Limits.multicoequalizer I) W\nâŠ¢ Iff (Eq i j) (âˆ€ (b : I.R), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multicoequalizer.Ï€ I b) i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multicoequalizer.Ï€ I b) j))","decl":"@[ext]\ntheorem hom_ext {W : C} (i j : multicoequalizer I âŸ¶ W)\n    (h : âˆ€ b, Multicoequalizer.Ï€ I b â‰« i = Multicoequalizer.Ï€ I b â‰« j) : i = j :=\n  colimit.hom_ext\n    (by\n      rintro (a | b)\n      Â· simp_rw [â† colimit.w I.multispan (WalkingMultispan.Hom.fst a), Category.assoc, h]\n      Â· apply h)\n\n"}
{"name":"CategoryTheory.Limits.Multicoequalizer.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninstâœ : CategoryTheory.Limits.HasMulticoequalizer I\nW : C\ni j : Quiver.Hom (CategoryTheory.Limits.multicoequalizer I) W\nh : âˆ€ (b : I.R), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multicoequalizer.Ï€ I b) i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multicoequalizer.Ï€ I b) j)\nâŠ¢ Eq i j","decl":"@[ext]\ntheorem hom_ext {W : C} (i j : multicoequalizer I âŸ¶ W)\n    (h : âˆ€ b, Multicoequalizer.Ï€ I b â‰« i = Multicoequalizer.Ï€ I b â‰« j) : i = j :=\n  colimit.hom_ext\n    (by\n      rintro (a | b)\n      Â· simp_rw [â† colimit.w I.multispan (WalkingMultispan.Hom.fst a), Category.assoc, h]\n      Â· apply h)\n\n"}
{"name":"CategoryTheory.Limits.Multicoequalizer.instHasCoequalizerFstSigmaMapSndSigmaMap","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninstâœÂ² : CategoryTheory.Limits.HasMulticoequalizer I\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct I.left\ninstâœ : CategoryTheory.Limits.HasCoproduct I.right\nâŠ¢ CategoryTheory.Limits.HasCoequalizer I.fstSigmaMap I.sndSigmaMap","decl":"instance : HasCoequalizer I.fstSigmaMap I.sndSigmaMap :=\n  âŸ¨âŸ¨âŸ¨_,\n      IsColimit.ofPreservesCoconeInitial\n        I.multicoforkEquivSigmaCofork.functor (colimit.isColimit _)âŸ©âŸ©âŸ©\n\n"}
{"name":"CategoryTheory.Limits.Multicoequalizer.Î¹_sigmaÏ€_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninstâœÂ² : CategoryTheory.Limits.HasMulticoequalizer I\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct I.left\ninstâœ : CategoryTheory.Limits.HasCoproduct I.right\nb : I.R\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.multicoequalizer I) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ I.right b) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multicoequalizer.sigmaÏ€ I) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multicoequalizer.Ï€ I b) h)","decl":"@[reassoc (attr := simp)]\ntheorem Î¹_sigmaÏ€ (b) : Sigma.Î¹ I.right b â‰« sigmaÏ€ I = Ï€ I b := by\n  rw [sigmaÏ€, â† Category.assoc, Iso.comp_inv_eq, isoCoequalizer]\n  simp only [MultispanIndex.multicoforkEquivSigmaCofork_inverse,\n    MultispanIndex.ofSigmaCoforkFunctor_obj, colimit.isoColimitCocone_Î¹_hom,\n    Multicofork.ofSigmaCofork_pt, colimit.cocone_x, Multicofork.Ï€_eq_app_right]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multicoequalizer.Î¹_sigmaÏ€","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninstâœÂ² : CategoryTheory.Limits.HasMulticoequalizer I\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct I.left\ninstâœ : CategoryTheory.Limits.HasCoproduct I.right\nb : I.R\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ I.right b) (CategoryTheory.Limits.Multicoequalizer.sigmaÏ€ I)) (CategoryTheory.Limits.Multicoequalizer.Ï€ I b)","decl":"@[reassoc (attr := simp)]\ntheorem Î¹_sigmaÏ€ (b) : Sigma.Î¹ I.right b â‰« sigmaÏ€ I = Ï€ I b := by\n  rw [sigmaÏ€, â† Category.assoc, Iso.comp_inv_eq, isoCoequalizer]\n  simp only [MultispanIndex.multicoforkEquivSigmaCofork_inverse,\n    MultispanIndex.ofSigmaCoforkFunctor_obj, colimit.isoColimitCocone_Î¹_hom,\n    Multicofork.ofSigmaCofork_pt, colimit.cocone_x, Multicofork.Ï€_eq_app_right]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Multicoequalizer.instEpiSigmaÏ€","module":"Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nI : CategoryTheory.Limits.MultispanIndex C\ninstâœÂ² : CategoryTheory.Limits.HasMulticoequalizer I\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct I.left\ninstâœ : CategoryTheory.Limits.HasCoproduct I.right\nâŠ¢ CategoryTheory.Epi (CategoryTheory.Limits.Multicoequalizer.sigmaÏ€ I)","decl":"instance : Epi (sigmaÏ€ I) := epi_comp _ _\n\n"}
