{"name":"Algebra.Norm.Transitivity.auxMat_blockTriangular","module":"Mathlib.RingTheory.Norm.Transitivity","initialProofState":"S : Type u_2\nm : Type u_5\ninst✝¹ : CommRing S\nM : Matrix m m S\ninst✝ : DecidableEq m\nk : m\n⊢ (Algebra.Norm.Transitivity.auxMat M k).BlockTriangular fun x => Ne x k","decl":"/-- `aux M k` is lower triangular. -/\nlemma auxMat_blockTriangular : (auxMat M k).BlockTriangular (· ≠ k) :=\n  fun i j lt ↦ by\n    simp_rw [lt_iff_not_le, le_Prop_eq, Classical.not_imp, not_not] at lt\n    rw [auxMat, of_apply, if_pos lt.2, if_neg lt.1]\n\n"}
{"name":"Algebra.Norm.Transitivity.auxMat_toSquareBlock_ne","module":"Mathlib.RingTheory.Norm.Transitivity","initialProofState":"S : Type u_2\nm : Type u_5\ninst✝¹ : CommRing S\nM : Matrix m m S\ninst✝ : DecidableEq m\nk : m\n⊢ Eq ((Algebra.Norm.Transitivity.auxMat M k).toSquareBlock (fun x => Ne x k) True) (HSMul.hSMul (M k k) 1)","decl":"lemma auxMat_toSquareBlock_ne : (auxMat M k).toSquareBlock (· ≠ k) True = M k k • 1 := by\n  ext i j\n  simp [auxMat, toSquareBlock_def, if_neg (of_eq_true i.2), if_neg (of_eq_true j.2),\n    Matrix.one_apply, Subtype.ext_iff]\n\n"}
{"name":"Algebra.Norm.Transitivity.auxMat_toSquareBlock_eq","module":"Mathlib.RingTheory.Norm.Transitivity","initialProofState":"S : Type u_2\nm : Type u_5\ninst✝¹ : CommRing S\nM : Matrix m m S\ninst✝ : DecidableEq m\nk : m\n⊢ Eq ((Algebra.Norm.Transitivity.auxMat M k).toSquareBlock (fun x => Ne x k) False) 1","decl":"lemma auxMat_toSquareBlock_eq : (auxMat M k).toSquareBlock (· ≠ k) False = 1 := by\n  ext ⟨i, hi⟩ ⟨j, hj⟩\n  rw [eq_iff_iff, iff_false, not_not] at hi hj\n  simp [auxMat, toSquareBlock_def, if_pos hi, if_pos hj, Matrix.one_apply, if_pos (hj ▸ hi)]\n\n"}
{"name":"Algebra.Norm.Transitivity.mul_auxMat_blockTriangular","module":"Mathlib.RingTheory.Norm.Transitivity","initialProofState":"S : Type u_2\nm : Type u_5\ninst✝² : CommRing S\nM : Matrix m m S\ninst✝¹ : DecidableEq m\nk : m\ninst✝ : Fintype m\n⊢ (HMul.hMul M (Algebra.Norm.Transitivity.auxMat M k)).BlockTriangular fun x => Eq x k","decl":"/-- `M * aux M k` is upper triangular. -/\nlemma mul_auxMat_blockTriangular : (M * auxMat M k).BlockTriangular (· = k) :=\n  fun i j lt ↦ by\n    simp_rw [lt_iff_not_le, le_Prop_eq, Classical.not_imp] at lt\n    simp_rw [Matrix.mul_apply, auxMat, of_apply, if_neg lt.2, mul_ite, mul_neg, mul_zero]\n    rw [Finset.sum_ite, Finset.filter_eq', if_pos (Finset.mem_univ _), Finset.sum_singleton,\n      Finset.sum_ite_eq', if_pos, lt.1, mul_comm, neg_add_cancel]\n    exact Finset.mem_filter.mpr ⟨Finset.mem_univ _, lt.2⟩\n\n"}
{"name":"Algebra.Norm.Transitivity.mul_auxMat_corner","module":"Mathlib.RingTheory.Norm.Transitivity","initialProofState":"S : Type u_2\nm : Type u_5\ninst✝² : CommRing S\nM : Matrix m m S\ninst✝¹ : DecidableEq m\nk : m\ninst✝ : Fintype m\n⊢ Eq (HMul.hMul M (Algebra.Norm.Transitivity.auxMat M k) k k) (M k k)","decl":"/-- The lower-right corner of `M * aux M k` is the same as the corner of `M`. -/\nlemma mul_auxMat_corner : (M * auxMat M k) k k = M k k := by simp [Matrix.mul_apply, auxMat]\n\n"}
{"name":"Algebra.Norm.Transitivity.mul_auxMat_toSquareBlock_eq","module":"Mathlib.RingTheory.Norm.Transitivity","initialProofState":"S : Type u_2\nm : Type u_5\ninst✝² : CommRing S\nM : Matrix m m S\ninst✝¹ : DecidableEq m\nk : m\ninst✝ : Fintype m\n⊢ Eq ((HMul.hMul M (Algebra.Norm.Transitivity.auxMat M k)).toSquareBlock (fun x => Eq x k) True) (HSMul.hSMul (M k k) 1)","decl":"lemma mul_auxMat_toSquareBlock_eq :\n    (M * auxMat M k).toSquareBlock (· = k) True = M k k • 1 := by\n  ext ⟨i, hi⟩ ⟨j, hj⟩\n  rw [eq_iff_iff, iff_true] at hi hj\n  simp [toSquareBlock_def, hi, hj, mul_auxMat_corner]\n\n"}
{"name":"Algebra.Norm.Transitivity.det_mul_corner_pow","module":"Mathlib.RingTheory.Norm.Transitivity","initialProofState":"S : Type u_2\nm : Type u_5\ninst✝² : CommRing S\nM : Matrix m m S\ninst✝¹ : DecidableEq m\nk : m\ninst✝ : Fintype m\n⊢ Eq (HMul.hMul M.det (HPow.hPow (M k k) (HSub.hSub (Fintype.card m) 1))) (HMul.hMul (M k k) ((HMul.hMul M (Algebra.Norm.Transitivity.auxMat M k)).toSquareBlock (fun x => Eq x k) False).det)","decl":"lemma det_mul_corner_pow :\n    M.det * M k k ^ (Fintype.card m - 1) = M k k * (mulAuxMatBlock).det := by\n  trans (M * auxMat M k).det\n  · simp [det_mul, (auxMat_blockTriangular M k).det_fintype,\n      auxMat_toSquareBlock_ne, auxMat_toSquareBlock_eq]\n  rw [(mul_auxMat_blockTriangular M k).det_fintype, Fintype.prod_Prop, mul_auxMat_toSquareBlock_eq]\n  simp_rw [det_smul_of_tower, eq_iff_iff, iff_true, Fintype.card_unique,\n    pow_one, det_one, smul_eq_mul, mul_one]\n  -- `Decidable (P = Q)` diamond induced by `Prop.linearOrder`, which is classical, when `P` and `Q`\n  -- are themselves decidable.\n  convert rfl\n\n"}
{"name":"Algebra.Norm.Transitivity.polyToMatrix_cornerAddX","module":"Mathlib.RingTheory.Norm.Transitivity","initialProofState":"R : Type u_1\nS : Type u_2\nn : Type u_4\nm : Type u_5\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\nM : Matrix m m S\ninst✝² : DecidableEq m\ninst✝¹ : DecidableEq n\nk : m\ninst✝ : Fintype n\nf : RingHom S (Matrix n n R)\n⊢ Eq (f.polyToMatrix (Algebra.Norm.Transitivity.cornerAddX M k k k)) (Neg.neg (f (M k k))).charmatrix","decl":"omit [Fintype m] in\nlemma polyToMatrix_cornerAddX :\n    f.polyToMatrix (cornerAddX M k k k) = (-f (M k k)).charmatrix := by\n  simp [cornerAddX, Matrix.add_apply, charmatrix,\n    RingHom.polyToMatrix, ← AlgEquiv.symm_toRingEquiv, map_neg]\n\n"}
{"name":"Algebra.Norm.Transitivity.eval_zero_det_det","module":"Mathlib.RingTheory.Norm.Transitivity","initialProofState":"R : Type u_1\nS : Type u_2\nn : Type u_4\nm : Type u_5\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing S\nM : Matrix m m S\ninst✝³ : DecidableEq m\ninst✝² : DecidableEq n\nk : m\ninst✝¹ : Fintype m\ninst✝ : Fintype n\nf : RingHom S (Matrix n n R)\n⊢ Eq (Polynomial.eval 0 (f.polyToMatrix (Algebra.Norm.Transitivity.cornerAddX M k).det).det) (f M.det).det","decl":"lemma eval_zero_det_det : eval 0 (f.polyToMatrix (cornerAddX M k).det).det = (f M.det).det := by\n  rw [← coe_evalRingHom, RingHom.map_det, ← RingHom.comp_apply,\n    evalRingHom_mapMatrix_comp_polyToMatrix, f.comp_apply, RingHom.map_det]\n  congr; ext; simp [cornerAddX, diagonal, apply_ite]\n\n"}
{"name":"Algebra.Norm.Transitivity.eval_zero_comp_det","module":"Mathlib.RingTheory.Norm.Transitivity","initialProofState":"R : Type u_1\nS : Type u_2\nn : Type u_4\nm : Type u_5\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing S\nM : Matrix m m S\ninst✝³ : DecidableEq m\ninst✝² : DecidableEq n\nk : m\ninst✝¹ : Fintype m\ninst✝ : Fintype n\nf : RingHom S (Matrix n n R)\n⊢ Eq (Polynomial.eval 0 ((Matrix.comp m m n n (Polynomial R)) ((Algebra.Norm.Transitivity.cornerAddX M k).map ⇑f.polyToMatrix)).det) ((Matrix.comp m m n n R) (M.map ⇑f)).det","decl":"lemma eval_zero_comp_det :\n    eval 0 (comp m m n n R[X] <| (cornerAddX M k).map f.polyToMatrix).det =\n      (comp m m n n R <| M.map f).det := by\n  simp_rw [← coe_evalRingHom, RingHom.map_det, ← compRingEquiv_apply, ← RingEquiv.coe_toRingHom,\n    ← RingHom.mapMatrix_apply, ← RingHom.comp_apply, ← RingHom.comp_assoc,\n    evalRingHom_mapMatrix_comp_compRingEquiv, RingHom.comp_assoc, RingHom.mapMatrix_comp,\n    evalRingHom_mapMatrix_comp_polyToMatrix, ← RingHom.mapMatrix_comp, RingHom.comp_apply]\n  congr with i j\n  simp [cornerAddX, diagonal, apply_ite]\n\n"}
{"name":"Algebra.Norm.Transitivity.comp_det_mul_pow","module":"Mathlib.RingTheory.Norm.Transitivity","initialProofState":"R : Type u_1\nS : Type u_2\nn : Type u_4\nm : Type u_5\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing S\nM : Matrix m m S\ninst✝³ : DecidableEq m\ninst✝² : DecidableEq n\nk : m\ninst✝¹ : Fintype m\ninst✝ : Fintype n\nf : RingHom S (Matrix n n R)\n⊢ Eq (HMul.hMul ((Matrix.comp m m n n R) (M.map ⇑f)).det (HPow.hPow (f (M k k)).det (HSub.hSub (Fintype.card m) 1))) (HMul.hMul (f (M k k)).det ((Matrix.comp (Subtype fun a => Eq (Eq a k) False) (Subtype fun a => Eq (Eq a k) False) n n R) (((HMul.hMul M (Algebra.Norm.Transitivity.auxMat M k)).toSquareBlock (fun x => Eq x k) False).map ⇑f)).det)","decl":"theorem comp_det_mul_pow :\n    ((M.map f).comp m m n n R).det * (f (M k k)).det ^ (Fintype.card m - 1) =\n      (f (M k k)).det * (((mulAuxMatBlock).map f).comp _ _ n n R).det := by\n  trans (((M * auxMat M k).map f).comp m m n n R).det\n  · simp_rw [← f.mapMatrix_apply, ← compRingEquiv_apply, _root_.map_mul, det_mul, f.mapMatrix_apply,\n      compRingEquiv_apply, ((auxMat_blockTriangular M k).map f).comp.det_fintype, Fintype.prod_Prop,\n      comp_toSquareBlock (b := (· ≠ k)), det_reindex_self, map_toSquareBlock,\n      auxMat_toSquareBlock_eq, auxMat_toSquareBlock_ne, smul_one_eq_diagonal, ← diagonal_one,\n      diagonal_map (map_zero _), comp_diagonal, det_reindex_self]\n    simp\n  · simp_rw [((mul_auxMat_blockTriangular M k).map f).comp.det_fintype, Fintype.prod_Prop,\n      comp_toSquareBlock (b := (· = k)), det_reindex_self, map_toSquareBlock,\n      mul_auxMat_toSquareBlock_eq, smul_one_eq_diagonal,\n      diagonal_map (map_zero _), comp_diagonal, det_reindex_self]\n    simp\n\n"}
{"name":"Algebra.Norm.Transitivity.det_det_aux","module":"Mathlib.RingTheory.Norm.Transitivity","initialProofState":"R : Type u_1\nS : Type u_2\nn : Type u_4\nm : Type u_5\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing S\nM : Matrix m m S\ninst✝³ : DecidableEq m\ninst✝² : DecidableEq n\nk : m\ninst✝¹ : Fintype m\ninst✝ : Fintype n\nf : RingHom S (Matrix n n R)\nih : ∀ (M : Matrix (Subtype fun a => Eq (Eq a k) False) (Subtype fun a => Eq (Eq a k) False) S), Eq (f M.det).det ((Matrix.comp (Subtype fun a => Eq (Eq a k) False) (Subtype fun a => Eq (Eq a k) False) n n R) (M.map ⇑f)).det\n⊢ Eq (HMul.hMul (HSub.hSub (f M.det).det ((Matrix.comp m m n n R) (M.map ⇑f)).det) (HPow.hPow (f (M k k)).det (HSub.hSub (Fintype.card m) 1))) 0","decl":"variable {M f} in\nlemma det_det_aux\n    (ih : ∀ M, (f (det M)).det = ((M.map f).comp {a // (a = k) = False} _ n n R).det) :\n    ((f M.det).det - ((M.map f).comp m m n n R).det) *\n      (f (M k k)).det ^ (Fintype.card m - 1) = 0 := by\n  rw [sub_mul, comp_det_mul_pow, ← det_pow, ← map_pow, ← det_mul, ← _root_.map_mul,\n    det_mul_corner_pow, _root_.map_mul, det_mul, ih, sub_self]\n\n"}
{"name":"Matrix.det_det","module":"Mathlib.RingTheory.Norm.Transitivity","initialProofState":"R : Type u_1\nS : Type u_2\nn : Type u_4\nm : Type u_5\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing S\nM : Matrix m m S\ninst✝³ : DecidableEq m\ninst✝² : DecidableEq n\ninst✝¹ : Fintype m\ninst✝ : Fintype n\nf : RingHom S (Matrix n n R)\n⊢ Eq (f M.det).det ((Matrix.comp m m n n R) (M.map ⇑f)).det","decl":"/-- The main result in Silvester's paper *Determinants of Block Matrices*: the determinant of\na block matrix with commuting, equal-sized, square blocks can be computed by taking determinants\ntwice in a row: first take the determinant over the commutative ring generated by the\nblocks (`S` here), then take the determinant over the base ring. -/\ntheorem Matrix.det_det [Fintype m] [Fintype n] (f : S →+* Matrix n n R) :\n    (f M.det).det = ((M.map f).comp m m n n R).det := by\n  set l := Fintype.card m with hl\n  clear_value l; revert R S m\n  induction' l with l ih <;> intro R S m _ _ M _ _ f card\n  · rw [eq_comm, Fintype.card_eq_zero_iff] at card\n    simp_rw [Matrix.det_isEmpty, _root_.map_one, det_one]\n  have ⟨k⟩ := Fintype.card_pos_iff.mp (l.succ_pos.trans_eq card)\n  let f' := f.polyToMatrix\n  let M' := cornerAddX M k\n  have : (f' M'.det).det = ((M'.map f').comp m m n n R[X]).det := by\n    refine sub_eq_zero.mp <| mem_nonZeroDivisors_iff.mp\n      (pow_mem ?_ _) _ (det_det_aux k fun M ↦ ih _ _ <| by simp [← card])\n    rw [polyToMatrix_cornerAddX, ← charpoly]\n    exact (Matrix.charpoly_monic _).mem_nonZeroDivisors\n  rw [← eval_zero_det_det, congr_arg (eval 0) this, eval_zero_comp_det]\n\n"}
{"name":"LinearMap.det_restrictScalars","module":"Mathlib.RingTheory.Norm.Transitivity","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing S\ninst✝⁶ : Algebra R S\ninst✝⁵ : Module.Free R S\ninst✝⁴ : AddCommGroup A\ninst✝³ : Module R A\ninst✝² : Module S A\ninst✝¹ : IsScalarTower R S A\ninst✝ : Module.Free S A\nf : LinearMap (RingHom.id S) A A\n⊢ Eq (LinearMap.det (↑R f)) ((Algebra.norm R) (LinearMap.det f))","decl":"theorem LinearMap.det_restrictScalars [AddCommGroup A] [Module R A] [Module S A]\n    [IsScalarTower R S A] [Module.Free S A] {f : A →ₗ[S] A} :\n    (f.restrictScalars R).det = Algebra.norm R f.det := by\n  nontriviality R\n  cases subsingleton_or_nontrivial A\n  · simp_rw [det_eq_one_of_subsingleton, _root_.map_one]\n  have := Module.nontrivial S A\n  let ⟨ιS, bS⟩ := Module.Free.exists_basis (R := R) (M := S)\n  let ⟨ιA, bA⟩ := Module.Free.exists_basis (R := S) (M := A)\n  have := bS.index_nonempty\n  have := bA.index_nonempty\n  cases fintypeOrInfinite ιS; swap\n  · rw [Algebra.norm_eq_one_of_not_module_finite (Module.not_finite_of_infinite_basis bS),\n      det_eq_one_of_not_module_finite (Module.not_finite_of_infinite_basis (bS.smulTower bA))]\n  cases fintypeOrInfinite ιA; swap\n  · rw [det_eq_one_of_not_module_finite (Module.not_finite_of_infinite_basis bA), _root_.map_one,\n      det_eq_one_of_not_module_finite (Module.not_finite_of_infinite_basis (bS.smulTower bA))]\n  classical\n  rw [Algebra.norm_eq_matrix_det bS, ← AlgHom.coe_toRingHom, ← det_toMatrix bA, det_det,\n    ← det_toMatrix (bS.smulTower' bA), restrictScalars_toMatrix]\n  rfl\n\n"}
{"name":"Algebra.norm_norm","module":"Mathlib.RingTheory.Norm.Transitivity","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing S\ninst✝⁶ : Algebra R S\ninst✝⁵ : Module.Free R S\nA : Type u_6\ninst✝⁴ : Ring A\ninst✝³ : Algebra R A\ninst✝² : Algebra S A\ninst✝¹ : IsScalarTower R S A\ninst✝ : Module.Free S A\na : A\n⊢ Eq ((Algebra.norm R) ((Algebra.norm S) a)) ((Algebra.norm R) a)","decl":"/--Let A/S/R be a tower of finite free tower of rings (with R and S commutative).\nThen $\\text{Norm}_{A/R} = \\text{Norm}_{A/S} \\circ \\text{Norm}_{S/R}$.-/\ntheorem Algebra.norm_norm {A} [Ring A] [Algebra R A] [Algebra S A]\n    [IsScalarTower R S A] [Module.Free S A] {a : A} :\n    norm R (norm S a) = norm R a := by\n  rw [norm_apply S, norm_apply R a, ← LinearMap.det_restrictScalars]; rfl\n"}
