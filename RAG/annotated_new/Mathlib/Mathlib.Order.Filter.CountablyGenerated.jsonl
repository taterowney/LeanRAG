{"name":"Filter.IsCountablyGenerated.out","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_1\nf : Filter α\nself : f.IsCountablyGenerated\n⊢ Exists fun s => And s.Countable (Eq f (Filter.generate s))","decl":"/-- `IsCountablyGenerated f` means `f = generate s` for some countable `s`. -/\nclass IsCountablyGenerated (f : Filter α) : Prop where\n  /-- There exists a countable set that generates the filter. -/\n  out : ∃ s : Set (Set α), s.Countable ∧ f = generate s\n\n"}
{"name":"Filter.IsCountableBasis.countable","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_1\nι : Type u_4\np : ι → Prop\ns : ι → Set α\nself : Filter.IsCountableBasis p s\n⊢ (setOf p).Countable","decl":"/-- `IsCountableBasis p s` means the image of `s` bounded by `p` is a countable filter basis. -/\nstructure IsCountableBasis (p : ι → Prop) (s : ι → Set α) extends IsBasis p s : Prop where\n  /-- The set of `i` that satisfy the predicate `p` is countable. -/\n  countable : (setOf p).Countable\n\n"}
{"name":"Filter.IsCountableBasis.toIsBasis","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_1\nι : Type u_4\np : ι → Prop\ns : ι → Set α\nself : Filter.IsCountableBasis p s\n⊢ Filter.IsBasis p s","decl":"/-- `IsCountableBasis p s` means the image of `s` bounded by `p` is a countable filter basis. -/\nstructure IsCountableBasis (p : ι → Prop) (s : ι → Set α) extends IsBasis p s : Prop where\n  /-- The set of `i` that satisfy the predicate `p` is countable. -/\n  countable : (setOf p).Countable\n\n"}
{"name":"Filter.HasCountableBasis.toHasBasis","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_1\nι : Type u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nself : l.HasCountableBasis p s\n⊢ l.HasBasis p s","decl":"/-- We say that a filter `l` has a countable basis `s : ι → Set α` bounded by `p : ι → Prop`,\nif `t ∈ l` if and only if `t` includes `s i` for some `i` such that `p i`, and the set\ndefined by `p` is countable. -/\nstructure HasCountableBasis (l : Filter α) (p : ι → Prop) (s : ι → Set α)\n    extends HasBasis l p s : Prop where\n  /-- The set of `i` that satisfy the predicate `p` is countable. -/\n  countable : (setOf p).Countable\n\n"}
{"name":"Filter.HasCountableBasis.countable","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_1\nι : Type u_4\nl : Filter α\np : ι → Prop\ns : ι → Set α\nself : l.HasCountableBasis p s\n⊢ (setOf p).Countable","decl":"/-- We say that a filter `l` has a countable basis `s : ι → Set α` bounded by `p : ι → Prop`,\nif `t ∈ l` if and only if `t` includes `s i` for some `i` such that `p i`, and the set\ndefined by `p` is countable. -/\nstructure HasCountableBasis (l : Filter α) (p : ι → Prop) (s : ι → Set α)\n    extends HasBasis l p s : Prop where\n  /-- The set of `i` that satisfy the predicate `p` is countable. -/\n  countable : (setOf p).Countable\n\n"}
{"name":"Filter.CountableFilterBasis.mk.inj","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_6\ntoFilterBasis✝ : FilterBasis α\ncountable✝ : toFilterBasis✝.sets.Countable\ntoFilterBasis : FilterBasis α\ncountable : toFilterBasis.sets.Countable\nx✝ : Eq { toFilterBasis := toFilterBasis✝, countable := countable✝ } { toFilterBasis := toFilterBasis, countable := countable }\n⊢ Eq toFilterBasis✝ toFilterBasis","decl":"/-- A countable filter basis `B` on a type `α` is a nonempty countable collection of sets of `α`\nsuch that the intersection of two elements of this collection contains some element\nof the collection. -/\nstructure CountableFilterBasis (α : Type*) extends FilterBasis α where\n  /-- The set of sets of the filter basis is countable. -/\n  countable : sets.Countable\n\n-- For illustration purposes, the countable filter basis defining `(atTop : Filter ℕ)`\n"}
{"name":"Filter.CountableFilterBasis.countable","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_6\nself : Filter.CountableFilterBasis α\n⊢ self.sets.Countable","decl":"/-- A countable filter basis `B` on a type `α` is a nonempty countable collection of sets of `α`\nsuch that the intersection of two elements of this collection contains some element\nof the collection. -/\nstructure CountableFilterBasis (α : Type*) extends FilterBasis α where\n  /-- The set of sets of the filter basis is countable. -/\n  countable : sets.Countable\n\n-- For illustration purposes, the countable filter basis defining `(atTop : Filter ℕ)`\n"}
{"name":"Filter.CountableFilterBasis.mk.injEq","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_6\ntoFilterBasis✝ : FilterBasis α\ncountable✝ : toFilterBasis✝.sets.Countable\ntoFilterBasis : FilterBasis α\ncountable : toFilterBasis.sets.Countable\n⊢ Eq (Eq { toFilterBasis := toFilterBasis✝, countable := countable✝ } { toFilterBasis := toFilterBasis, countable := countable }) (Eq toFilterBasis✝ toFilterBasis)","decl":"/-- A countable filter basis `B` on a type `α` is a nonempty countable collection of sets of `α`\nsuch that the intersection of two elements of this collection contains some element\nof the collection. -/\nstructure CountableFilterBasis (α : Type*) extends FilterBasis α where\n  /-- The set of sets of the filter basis is countable. -/\n  countable : sets.Countable\n\n-- For illustration purposes, the countable filter basis defining `(atTop : Filter ℕ)`\n"}
{"name":"Filter.CountableFilterBasis.mk.sizeOf_spec","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_6\ninst✝ : SizeOf α\ntoFilterBasis : FilterBasis α\ncountable : toFilterBasis.sets.Countable\n⊢ Eq (SizeOf.sizeOf { toFilterBasis := toFilterBasis, countable := countable }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toFilterBasis)) (SizeOf.sizeOf countable))","decl":"/-- A countable filter basis `B` on a type `α` is a nonempty countable collection of sets of `α`\nsuch that the intersection of two elements of this collection contains some element\nof the collection. -/\nstructure CountableFilterBasis (α : Type*) extends FilterBasis α where\n  /-- The set of sets of the filter basis is countable. -/\n  countable : sets.Countable\n\n-- For illustration purposes, the countable filter basis defining `(atTop : Filter ℕ)`\n"}
{"name":"Filter.HasCountableBasis.isCountablyGenerated","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_1\nι : Type u_4\nf : Filter α\np : ι → Prop\ns : ι → Set α\nh : f.HasCountableBasis p s\n⊢ f.IsCountablyGenerated","decl":"theorem HasCountableBasis.isCountablyGenerated {f : Filter α} {p : ι → Prop} {s : ι → Set α}\n    (h : f.HasCountableBasis p s) : f.IsCountablyGenerated :=\n  ⟨⟨{ t | ∃ i, p i ∧ s i = t }, h.countable.image s, h.toHasBasis.eq_generate⟩⟩\n\n"}
{"name":"Filter.HasBasis.isCountablyGenerated","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝ : Countable ι\nf : Filter α\np : ι → Prop\ns : ι → Set α\nh : f.HasBasis p s\n⊢ f.IsCountablyGenerated","decl":"theorem HasBasis.isCountablyGenerated [Countable ι] {f : Filter α} {p : ι → Prop} {s : ι → Set α}\n    (h : f.HasBasis p s) : f.IsCountablyGenerated :=\n  HasCountableBasis.isCountablyGenerated ⟨h, to_countable _⟩\n\n"}
{"name":"Filter.antitone_seq_of_seq","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_1\ns : Nat → Set α\n⊢ Exists fun t => And (Antitone t) (Eq (iInf fun i => Filter.principal (s i)) (iInf fun i => Filter.principal (t i)))","decl":"theorem antitone_seq_of_seq (s : ℕ → Set α) :\n    ∃ t : ℕ → Set α, Antitone t ∧ ⨅ i, 𝓟 (s i) = ⨅ i, 𝓟 (t i) := by\n  use fun n => ⋂ m ≤ n, s m; constructor\n  · exact fun i j hij => biInter_mono (Iic_subset_Iic.2 hij) fun n _ => Subset.rfl\n  apply le_antisymm <;> rw [le_iInf_iff] <;> intro i\n  · rw [le_principal_iff]\n    refine (biInter_mem (finite_le_nat _)).2 fun j _ => ?_\n    exact mem_iInf_of_mem j (mem_principal_self _)\n  · refine iInf_le_of_le i (principal_mono.2 <| iInter₂_subset i ?_)\n    rfl\n\n"}
{"name":"Filter.countable_biInf_eq_iInf_seq","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝ : CompleteLattice α\nB : Set ι\nBcbl : B.Countable\nBne : B.Nonempty\nf : ι → α\n⊢ Exists fun x => Eq (iInf fun t => iInf fun h => f t) (iInf fun i => f (x i))","decl":"theorem countable_biInf_eq_iInf_seq [CompleteLattice α] {B : Set ι} (Bcbl : B.Countable)\n    (Bne : B.Nonempty) (f : ι → α) : ∃ x : ℕ → ι, ⨅ t ∈ B, f t = ⨅ i, f (x i) :=\n  let ⟨g, hg⟩ := Bcbl.exists_eq_range Bne\n  ⟨g, hg.symm ▸ iInf_range⟩\n\n"}
{"name":"Filter.countable_biInf_eq_iInf_seq'","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝ : CompleteLattice α\nB : Set ι\nBcbl : B.Countable\nf : ι → α\ni₀ : ι\nh : Eq (f i₀) Top.top\n⊢ Exists fun x => Eq (iInf fun t => iInf fun h => f t) (iInf fun i => f (x i))","decl":"theorem countable_biInf_eq_iInf_seq' [CompleteLattice α] {B : Set ι} (Bcbl : B.Countable)\n    (f : ι → α) {i₀ : ι} (h : f i₀ = ⊤) : ∃ x : ℕ → ι, ⨅ t ∈ B, f t = ⨅ i, f (x i) := by\n  rcases B.eq_empty_or_nonempty with hB | Bnonempty\n  · rw [hB, iInf_emptyset]\n    use fun _ => i₀\n    simp [h]\n  · exact countable_biInf_eq_iInf_seq Bcbl Bnonempty f\n\n"}
{"name":"Filter.countable_biInf_principal_eq_seq_iInf","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_1\nB : Set (Set α)\nBcbl : B.Countable\n⊢ Exists fun x => Eq (iInf fun t => iInf fun h => Filter.principal t) (iInf fun i => Filter.principal (x i))","decl":"theorem countable_biInf_principal_eq_seq_iInf {B : Set (Set α)} (Bcbl : B.Countable) :\n    ∃ x : ℕ → Set α, ⨅ t ∈ B, 𝓟 t = ⨅ i, 𝓟 (x i) :=\n  countable_biInf_eq_iInf_seq' Bcbl 𝓟 principal_univ\n\n"}
{"name":"Filter.HasAntitoneBasis.mem_iff","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝ : Preorder ι\nl : Filter α\ns : ι → Set α\nhs : l.HasAntitoneBasis s\nt : Set α\n⊢ Iff (Membership.mem l t) (Exists fun i => HasSubset.Subset (s i) t)","decl":"protected theorem HasAntitoneBasis.mem_iff [Preorder ι] {l : Filter α} {s : ι → Set α}\n    (hs : l.HasAntitoneBasis s) {t : Set α} : t ∈ l ↔ ∃ i, s i ⊆ t :=\n  hs.toHasBasis.mem_iff.trans <| by simp only [exists_prop, true_and]\n\n"}
{"name":"Filter.HasAntitoneBasis.mem","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝ : Preorder ι\nl : Filter α\ns : ι → Set α\nhs : l.HasAntitoneBasis s\ni : ι\n⊢ Membership.mem l (s i)","decl":"protected theorem HasAntitoneBasis.mem [Preorder ι] {l : Filter α} {s : ι → Set α}\n    (hs : l.HasAntitoneBasis s) (i : ι) : s i ∈ l :=\n  hs.toHasBasis.mem_of_mem trivial\n\n"}
{"name":"Filter.HasAntitoneBasis.hasBasis_ge","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝¹ : Preorder ι\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nl : Filter α\ns : ι → Set α\nhs : l.HasAntitoneBasis s\ni : ι\n⊢ l.HasBasis (fun j => LE.le i j) s","decl":"theorem HasAntitoneBasis.hasBasis_ge [Preorder ι] [IsDirected ι (· ≤ ·)] {l : Filter α}\n    {s : ι → Set α} (hs : l.HasAntitoneBasis s) (i : ι) : l.HasBasis (fun j => i ≤ j) s :=\n  hs.1.to_hasBasis (fun j _ => (exists_ge_ge i j).imp fun _k hk => ⟨hk.1, hs.2 hk.2⟩) fun j _ =>\n    ⟨j, trivial, Subset.rfl⟩\n\n"}
{"name":"Filter.HasBasis.exists_antitone_subbasis","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_1\nι' : Sort u_5\nf : Filter α\nh : f.IsCountablyGenerated\np : ι' → Prop\ns : ι' → Set α\nhs : f.HasBasis p s\n⊢ Exists fun x => And (∀ (i : Nat), p (x i)) (f.HasAntitoneBasis fun i => s (x i))","decl":"/-- If `f` is countably generated and `f.HasBasis p s`, then `f` admits a decreasing basis\nenumerated by natural numbers such that all sets have the form `s i`. More precisely, there is a\nsequence `i n` such that `p (i n)` for all `n` and `s (i n)` is a decreasing sequence of sets which\nforms a basis of `f`-/\ntheorem HasBasis.exists_antitone_subbasis {f : Filter α} [h : f.IsCountablyGenerated]\n    {p : ι' → Prop} {s : ι' → Set α} (hs : f.HasBasis p s) :\n    ∃ x : ℕ → ι', (∀ i, p (x i)) ∧ f.HasAntitoneBasis fun i => s (x i) := by\n  obtain ⟨x', hx'⟩ : ∃ x : ℕ → Set α, f = ⨅ i, 𝓟 (x i) := by\n    rcases h with ⟨s, hsc, rfl⟩\n    rw [generate_eq_biInf]\n    exact countable_biInf_principal_eq_seq_iInf hsc\n  have : ∀ i, x' i ∈ f := fun i => hx'.symm ▸ (iInf_le (fun i => 𝓟 (x' i)) i) (mem_principal_self _)\n  let x : ℕ → { i : ι' // p i } := fun n =>\n    Nat.recOn n (hs.index _ <| this 0) fun n xn =>\n      hs.index _ <| inter_mem (this <| n + 1) (hs.mem_of_mem xn.2)\n  have x_anti : Antitone fun i => s (x i).1 :=\n    antitone_nat_of_succ_le fun i => (hs.set_index_subset _).trans inter_subset_right\n  have x_subset : ∀ i, s (x i).1 ⊆ x' i := by\n    rintro (_ | i)\n    exacts [hs.set_index_subset _, (hs.set_index_subset _).trans inter_subset_left]\n  refine ⟨fun i => (x i).1, fun i => (x i).2, ?_⟩\n  have : (⨅ i, 𝓟 (s (x i).1)).HasAntitoneBasis fun i => s (x i).1 := .iInf_principal x_anti\n  convert this\n  exact\n    le_antisymm (le_iInf fun i => le_principal_iff.2 <| by cases i <;> apply hs.set_index_mem)\n      (hx'.symm ▸\n        le_iInf fun i => le_principal_iff.2 <| this.1.mem_iff.2 ⟨i, trivial, x_subset i⟩)\n\n"}
{"name":"Filter.exists_antitone_basis","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_1\nf : Filter α\ninst✝ : f.IsCountablyGenerated\n⊢ Exists fun x => f.HasAntitoneBasis x","decl":"/-- A countably generated filter admits a basis formed by an antitone sequence of sets. -/\ntheorem exists_antitone_basis (f : Filter α) [f.IsCountablyGenerated] :\n    ∃ x : ℕ → Set α, f.HasAntitoneBasis x :=\n  let ⟨x, _, hx⟩ := f.basis_sets.exists_antitone_subbasis\n  ⟨x, hx⟩\n\n"}
{"name":"Filter.exists_antitone_seq","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_1\nf : Filter α\ninst✝ : f.IsCountablyGenerated\n⊢ Exists fun x => And (Antitone x) (∀ {s : Set α}, Iff (Membership.mem f s) (Exists fun i => HasSubset.Subset (x i) s))","decl":"theorem exists_antitone_seq (f : Filter α) [f.IsCountablyGenerated] :\n    ∃ x : ℕ → Set α, Antitone x ∧ ∀ {s}, s ∈ f ↔ ∃ i, x i ⊆ s :=\n  let ⟨x, hx⟩ := f.exists_antitone_basis\n  ⟨x, hx.antitone, by simp [hx.1.mem_iff]⟩\n\n"}
{"name":"Filter.Inf.isCountablyGenerated","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_1\nf g : Filter α\ninst✝¹ : f.IsCountablyGenerated\ninst✝ : g.IsCountablyGenerated\n⊢ (Min.min f g).IsCountablyGenerated","decl":"instance Inf.isCountablyGenerated (f g : Filter α) [IsCountablyGenerated f]\n    [IsCountablyGenerated g] : IsCountablyGenerated (f ⊓ g) := by\n  rcases f.exists_antitone_basis with ⟨s, hs⟩\n  rcases g.exists_antitone_basis with ⟨t, ht⟩\n  exact HasCountableBasis.isCountablyGenerated ⟨hs.1.inf ht.1, Set.to_countable _⟩\n\n"}
{"name":"Filter.map.isCountablyGenerated","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\ninst✝ : l.IsCountablyGenerated\nf : α → β\n⊢ (Filter.map f l).IsCountablyGenerated","decl":"instance map.isCountablyGenerated (l : Filter α) [l.IsCountablyGenerated] (f : α → β) :\n    (map f l).IsCountablyGenerated :=\n  let ⟨_x, hxl⟩ := l.exists_antitone_basis\n  (hxl.map _).isCountablyGenerated\n\n"}
{"name":"Filter.comap.isCountablyGenerated","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter β\ninst✝ : l.IsCountablyGenerated\nf : α → β\n⊢ (Filter.comap f l).IsCountablyGenerated","decl":"instance comap.isCountablyGenerated (l : Filter β) [l.IsCountablyGenerated] (f : α → β) :\n    (comap f l).IsCountablyGenerated :=\n  let ⟨_x, hxl⟩ := l.exists_antitone_basis\n  (hxl.comap _).isCountablyGenerated\n\n"}
{"name":"Filter.Sup.isCountablyGenerated","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_1\nf g : Filter α\ninst✝¹ : f.IsCountablyGenerated\ninst✝ : g.IsCountablyGenerated\n⊢ (Max.max f g).IsCountablyGenerated","decl":"instance Sup.isCountablyGenerated (f g : Filter α) [IsCountablyGenerated f]\n    [IsCountablyGenerated g] : IsCountablyGenerated (f ⊔ g) := by\n  rcases f.exists_antitone_basis with ⟨s, hs⟩\n  rcases g.exists_antitone_basis with ⟨t, ht⟩\n  exact HasCountableBasis.isCountablyGenerated ⟨hs.1.sup ht.1, Set.to_countable _⟩\n\n"}
{"name":"Filter.prod.isCountablyGenerated","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_1\nβ : Type u_2\nla : Filter α\nlb : Filter β\ninst✝¹ : la.IsCountablyGenerated\ninst✝ : lb.IsCountablyGenerated\n⊢ (SProd.sprod la lb).IsCountablyGenerated","decl":"instance prod.isCountablyGenerated (la : Filter α) (lb : Filter β) [IsCountablyGenerated la]\n    [IsCountablyGenerated lb] : IsCountablyGenerated (la ×ˢ lb) :=\n  Filter.Inf.isCountablyGenerated _ _\n\n"}
{"name":"Filter.coprod.isCountablyGenerated","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_1\nβ : Type u_2\nla : Filter α\nlb : Filter β\ninst✝¹ : la.IsCountablyGenerated\ninst✝ : lb.IsCountablyGenerated\n⊢ (la.coprod lb).IsCountablyGenerated","decl":"instance coprod.isCountablyGenerated (la : Filter α) (lb : Filter β) [IsCountablyGenerated la]\n    [IsCountablyGenerated lb] : IsCountablyGenerated (la.coprod lb) :=\n  Filter.Sup.isCountablyGenerated _ _\n\n"}
{"name":"Filter.isCountablyGenerated_seq","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_1\nι' : Sort u_5\ninst✝ : Countable ι'\nx : ι' → Set α\n⊢ (iInf fun i => Filter.principal (x i)).IsCountablyGenerated","decl":"theorem isCountablyGenerated_seq [Countable ι'] (x : ι' → Set α) :\n    IsCountablyGenerated (⨅ i, 𝓟 (x i)) := by\n  use range x, countable_range x\n  rw [generate_eq_biInf, iInf_range]\n\n"}
{"name":"Filter.isCountablyGenerated_of_seq","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_1\nf : Filter α\nh : Exists fun x => Eq f (iInf fun i => Filter.principal (x i))\n⊢ f.IsCountablyGenerated","decl":"theorem isCountablyGenerated_of_seq {f : Filter α} (h : ∃ x : ℕ → Set α, f = ⨅ i, 𝓟 (x i)) :\n    f.IsCountablyGenerated := by\n  rcases h with ⟨x, rfl⟩\n  apply isCountablyGenerated_seq\n\n"}
{"name":"Filter.isCountablyGenerated_biInf_principal","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_1\nB : Set (Set α)\nh : B.Countable\n⊢ (iInf fun s => iInf fun h => Filter.principal s).IsCountablyGenerated","decl":"theorem isCountablyGenerated_biInf_principal {B : Set (Set α)} (h : B.Countable) :\n    IsCountablyGenerated (⨅ s ∈ B, 𝓟 s) :=\n  isCountablyGenerated_of_seq (countable_biInf_principal_eq_seq_iInf h)\n\n"}
{"name":"Filter.isCountablyGenerated_iff_exists_antitone_basis","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_1\nf : Filter α\n⊢ Iff f.IsCountablyGenerated (Exists fun x => f.HasAntitoneBasis x)","decl":"theorem isCountablyGenerated_iff_exists_antitone_basis {f : Filter α} :\n    IsCountablyGenerated f ↔ ∃ x : ℕ → Set α, f.HasAntitoneBasis x := by\n  constructor\n  · intro h\n    exact f.exists_antitone_basis\n  · rintro ⟨x, h⟩\n    rw [h.1.eq_iInf]\n    exact isCountablyGenerated_seq x\n\n"}
{"name":"Filter.isCountablyGenerated_principal","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_1\ns : Set α\n⊢ (Filter.principal s).IsCountablyGenerated","decl":"@[instance]\ntheorem isCountablyGenerated_principal (s : Set α) : IsCountablyGenerated (𝓟 s) :=\n  isCountablyGenerated_of_seq ⟨fun _ => s, iInf_const.symm⟩\n\n"}
{"name":"Filter.isCountablyGenerated_pure","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_1\na : α\n⊢ (Pure.pure a).IsCountablyGenerated","decl":"@[instance]\ntheorem isCountablyGenerated_pure (a : α) : IsCountablyGenerated (pure a) := by\n  rw [← principal_singleton]\n  exact isCountablyGenerated_principal _\n\n"}
{"name":"Filter.isCountablyGenerated_bot","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_1\n⊢ Bot.bot.IsCountablyGenerated","decl":"@[instance]\ntheorem isCountablyGenerated_bot : IsCountablyGenerated (⊥ : Filter α) :=\n  @principal_empty α ▸ isCountablyGenerated_principal _\n\n"}
{"name":"Filter.isCountablyGenerated_top","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"α : Type u_1\n⊢ Top.top.IsCountablyGenerated","decl":"@[instance]\ntheorem isCountablyGenerated_top : IsCountablyGenerated (⊤ : Filter α) :=\n  @principal_univ α ▸ isCountablyGenerated_principal _\n\n-- Porting note: without explicit `Sort u` and `Type v`, Lean 4 uses `ι : Prop`\n"}
{"name":"Filter.iInf.isCountablyGenerated","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"ι : Sort u\nα : Type v\ninst✝¹ : Countable ι\nf : ι → Filter α\ninst✝ : ∀ (i : ι), (f i).IsCountablyGenerated\n⊢ (iInf fun i => f i).IsCountablyGenerated","decl":"instance iInf.isCountablyGenerated {ι : Sort u} {α : Type v} [Countable ι] (f : ι → Filter α)\n    [∀ i, IsCountablyGenerated (f i)] : IsCountablyGenerated (⨅ i, f i) := by\n  choose s hs using fun i => exists_antitone_basis (f i)\n  rw [← PLift.down_surjective.iInf_comp]\n  refine HasCountableBasis.isCountablyGenerated ⟨hasBasis_iInf fun n => (hs _).1, ?_⟩\n  refine (countable_range <| Sigma.map ((↑) : Finset (PLift ι) → Set (PLift ι)) fun _ => id).mono ?_\n  rintro ⟨I, f⟩ ⟨hI, -⟩\n  lift I to Finset (PLift ι) using hI\n  exact ⟨⟨I, f⟩, rfl⟩\n\n"}
{"name":"Filter.pi.isCountablyGenerated","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"ι : Type u_6\nα : ι → Type u_7\ninst✝¹ : Countable ι\nf : (i : ι) → Filter (α i)\ninst✝ : ∀ (i : ι), (f i).IsCountablyGenerated\n⊢ (Filter.pi f).IsCountablyGenerated","decl":"instance pi.isCountablyGenerated {ι : Type*} {α : ι → Type*} [Countable ι]\n    (f : ∀ i, Filter (α i)) [∀ i, IsCountablyGenerated (f i)] : IsCountablyGenerated (pi f) :=\n  iInf.isCountablyGenerated _\n\n"}
