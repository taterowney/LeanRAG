{"name":"Filter.IsCountablyGenerated.out","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_1\nf : Filter Î±\nself : f.IsCountablyGenerated\nâŠ¢ Exists fun s => And s.Countable (Eq f (Filter.generate s))","decl":"/-- `IsCountablyGenerated f` means `f = generate s` for some countable `s`. -/\nclass IsCountablyGenerated (f : Filter Î±) : Prop where\n  /-- There exists a countable set that generates the filter. -/\n  out : âˆƒ s : Set (Set Î±), s.Countable âˆ§ f = generate s\n\n"}
{"name":"Filter.IsCountableBasis.countable","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_4\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nself : Filter.IsCountableBasis p s\nâŠ¢ (setOf p).Countable","decl":"/-- `IsCountableBasis p s` means the image of `s` bounded by `p` is a countable filter basis. -/\nstructure IsCountableBasis (p : Î¹ â†’ Prop) (s : Î¹ â†’ Set Î±) extends IsBasis p s : Prop where\n  /-- The set of `i` that satisfy the predicate `p` is countable. -/\n  countable : (setOf p).Countable\n\n"}
{"name":"Filter.IsCountableBasis.toIsBasis","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_4\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nself : Filter.IsCountableBasis p s\nâŠ¢ Filter.IsBasis p s","decl":"/-- `IsCountableBasis p s` means the image of `s` bounded by `p` is a countable filter basis. -/\nstructure IsCountableBasis (p : Î¹ â†’ Prop) (s : Î¹ â†’ Set Î±) extends IsBasis p s : Prop where\n  /-- The set of `i` that satisfy the predicate `p` is countable. -/\n  countable : (setOf p).Countable\n\n"}
{"name":"Filter.HasCountableBasis.toHasBasis","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nself : l.HasCountableBasis p s\nâŠ¢ l.HasBasis p s","decl":"/-- We say that a filter `l` has a countable basis `s : Î¹ â†’ Set Î±` bounded by `p : Î¹ â†’ Prop`,\nif `t âˆˆ l` if and only if `t` includes `s i` for some `i` such that `p i`, and the set\ndefined by `p` is countable. -/\nstructure HasCountableBasis (l : Filter Î±) (p : Î¹ â†’ Prop) (s : Î¹ â†’ Set Î±)\n    extends HasBasis l p s : Prop where\n  /-- The set of `i` that satisfy the predicate `p` is countable. -/\n  countable : (setOf p).Countable\n\n"}
{"name":"Filter.HasCountableBasis.countable","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_4\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nself : l.HasCountableBasis p s\nâŠ¢ (setOf p).Countable","decl":"/-- We say that a filter `l` has a countable basis `s : Î¹ â†’ Set Î±` bounded by `p : Î¹ â†’ Prop`,\nif `t âˆˆ l` if and only if `t` includes `s i` for some `i` such that `p i`, and the set\ndefined by `p` is countable. -/\nstructure HasCountableBasis (l : Filter Î±) (p : Î¹ â†’ Prop) (s : Î¹ â†’ Set Î±)\n    extends HasBasis l p s : Prop where\n  /-- The set of `i` that satisfy the predicate `p` is countable. -/\n  countable : (setOf p).Countable\n\n"}
{"name":"Filter.CountableFilterBasis.mk.inj","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_6\ntoFilterBasisâœ : FilterBasis Î±\ncountableâœ : toFilterBasisâœ.sets.Countable\ntoFilterBasis : FilterBasis Î±\ncountable : toFilterBasis.sets.Countable\nxâœ : Eq { toFilterBasis := toFilterBasisâœ, countable := countableâœ } { toFilterBasis := toFilterBasis, countable := countable }\nâŠ¢ Eq toFilterBasisâœ toFilterBasis","decl":"/-- A countable filter basis `B` on a type `Î±` is a nonempty countable collection of sets of `Î±`\nsuch that the intersection of two elements of this collection contains some element\nof the collection. -/\nstructure CountableFilterBasis (Î± : Type*) extends FilterBasis Î± where\n  /-- The set of sets of the filter basis is countable. -/\n  countable : sets.Countable\n\n-- For illustration purposes, the countable filter basis defining `(atTop : Filter â„•)`\n"}
{"name":"Filter.CountableFilterBasis.countable","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_6\nself : Filter.CountableFilterBasis Î±\nâŠ¢ self.sets.Countable","decl":"/-- A countable filter basis `B` on a type `Î±` is a nonempty countable collection of sets of `Î±`\nsuch that the intersection of two elements of this collection contains some element\nof the collection. -/\nstructure CountableFilterBasis (Î± : Type*) extends FilterBasis Î± where\n  /-- The set of sets of the filter basis is countable. -/\n  countable : sets.Countable\n\n-- For illustration purposes, the countable filter basis defining `(atTop : Filter â„•)`\n"}
{"name":"Filter.CountableFilterBasis.mk.injEq","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_6\ntoFilterBasisâœ : FilterBasis Î±\ncountableâœ : toFilterBasisâœ.sets.Countable\ntoFilterBasis : FilterBasis Î±\ncountable : toFilterBasis.sets.Countable\nâŠ¢ Eq (Eq { toFilterBasis := toFilterBasisâœ, countable := countableâœ } { toFilterBasis := toFilterBasis, countable := countable }) (Eq toFilterBasisâœ toFilterBasis)","decl":"/-- A countable filter basis `B` on a type `Î±` is a nonempty countable collection of sets of `Î±`\nsuch that the intersection of two elements of this collection contains some element\nof the collection. -/\nstructure CountableFilterBasis (Î± : Type*) extends FilterBasis Î± where\n  /-- The set of sets of the filter basis is countable. -/\n  countable : sets.Countable\n\n-- For illustration purposes, the countable filter basis defining `(atTop : Filter â„•)`\n"}
{"name":"Filter.CountableFilterBasis.mk.sizeOf_spec","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_6\ninstâœ : SizeOf Î±\ntoFilterBasis : FilterBasis Î±\ncountable : toFilterBasis.sets.Countable\nâŠ¢ Eq (SizeOf.sizeOf { toFilterBasis := toFilterBasis, countable := countable }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toFilterBasis)) (SizeOf.sizeOf countable))","decl":"/-- A countable filter basis `B` on a type `Î±` is a nonempty countable collection of sets of `Î±`\nsuch that the intersection of two elements of this collection contains some element\nof the collection. -/\nstructure CountableFilterBasis (Î± : Type*) extends FilterBasis Î± where\n  /-- The set of sets of the filter basis is countable. -/\n  countable : sets.Countable\n\n-- For illustration purposes, the countable filter basis defining `(atTop : Filter â„•)`\n"}
{"name":"Filter.HasCountableBasis.isCountablyGenerated","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_4\nf : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nh : f.HasCountableBasis p s\nâŠ¢ f.IsCountablyGenerated","decl":"theorem HasCountableBasis.isCountablyGenerated {f : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±}\n    (h : f.HasCountableBasis p s) : f.IsCountablyGenerated :=\n  âŸ¨âŸ¨{ t | âˆƒ i, p i âˆ§ s i = t }, h.countable.image s, h.toHasBasis.eq_generateâŸ©âŸ©\n\n"}
{"name":"Filter.HasBasis.isCountablyGenerated","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_4\ninstâœ : Countable Î¹\nf : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nh : f.HasBasis p s\nâŠ¢ f.IsCountablyGenerated","decl":"theorem HasBasis.isCountablyGenerated [Countable Î¹] {f : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±}\n    (h : f.HasBasis p s) : f.IsCountablyGenerated :=\n  HasCountableBasis.isCountablyGenerated âŸ¨h, to_countable _âŸ©\n\n"}
{"name":"Filter.antitone_seq_of_seq","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_1\ns : Nat â†’ Set Î±\nâŠ¢ Exists fun t => And (Antitone t) (Eq (iInf fun i => Filter.principal (s i)) (iInf fun i => Filter.principal (t i)))","decl":"theorem antitone_seq_of_seq (s : â„• â†’ Set Î±) :\n    âˆƒ t : â„• â†’ Set Î±, Antitone t âˆ§ â¨… i, ğ“Ÿ (s i) = â¨… i, ğ“Ÿ (t i) := by\n  use fun n => â‹‚ m â‰¤ n, s m; constructor\n  Â· exact fun i j hij => biInter_mono (Iic_subset_Iic.2 hij) fun n _ => Subset.rfl\n  apply le_antisymm <;> rw [le_iInf_iff] <;> intro i\n  Â· rw [le_principal_iff]\n    refine (biInter_mem (finite_le_nat _)).2 fun j _ => ?_\n    exact mem_iInf_of_mem j (mem_principal_self _)\n  Â· refine iInf_le_of_le i (principal_mono.2 <| iInterâ‚‚_subset i ?_)\n    rfl\n\n"}
{"name":"Filter.countable_biInf_eq_iInf_seq","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_4\ninstâœ : CompleteLattice Î±\nB : Set Î¹\nBcbl : B.Countable\nBne : B.Nonempty\nf : Î¹ â†’ Î±\nâŠ¢ Exists fun x => Eq (iInf fun t => iInf fun h => f t) (iInf fun i => f (x i))","decl":"theorem countable_biInf_eq_iInf_seq [CompleteLattice Î±] {B : Set Î¹} (Bcbl : B.Countable)\n    (Bne : B.Nonempty) (f : Î¹ â†’ Î±) : âˆƒ x : â„• â†’ Î¹, â¨… t âˆˆ B, f t = â¨… i, f (x i) :=\n  let âŸ¨g, hgâŸ© := Bcbl.exists_eq_range Bne\n  âŸ¨g, hg.symm â–¸ iInf_rangeâŸ©\n\n"}
{"name":"Filter.countable_biInf_eq_iInf_seq'","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_4\ninstâœ : CompleteLattice Î±\nB : Set Î¹\nBcbl : B.Countable\nf : Î¹ â†’ Î±\niâ‚€ : Î¹\nh : Eq (f iâ‚€) Top.top\nâŠ¢ Exists fun x => Eq (iInf fun t => iInf fun h => f t) (iInf fun i => f (x i))","decl":"theorem countable_biInf_eq_iInf_seq' [CompleteLattice Î±] {B : Set Î¹} (Bcbl : B.Countable)\n    (f : Î¹ â†’ Î±) {iâ‚€ : Î¹} (h : f iâ‚€ = âŠ¤) : âˆƒ x : â„• â†’ Î¹, â¨… t âˆˆ B, f t = â¨… i, f (x i) := by\n  rcases B.eq_empty_or_nonempty with hB | Bnonempty\n  Â· rw [hB, iInf_emptyset]\n    use fun _ => iâ‚€\n    simp [h]\n  Â· exact countable_biInf_eq_iInf_seq Bcbl Bnonempty f\n\n"}
{"name":"Filter.countable_biInf_principal_eq_seq_iInf","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_1\nB : Set (Set Î±)\nBcbl : B.Countable\nâŠ¢ Exists fun x => Eq (iInf fun t => iInf fun h => Filter.principal t) (iInf fun i => Filter.principal (x i))","decl":"theorem countable_biInf_principal_eq_seq_iInf {B : Set (Set Î±)} (Bcbl : B.Countable) :\n    âˆƒ x : â„• â†’ Set Î±, â¨… t âˆˆ B, ğ“Ÿ t = â¨… i, ğ“Ÿ (x i) :=\n  countable_biInf_eq_iInf_seq' Bcbl ğ“Ÿ principal_univ\n\n"}
{"name":"Filter.HasAntitoneBasis.mem_iff","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_4\ninstâœ : Preorder Î¹\nl : Filter Î±\ns : Î¹ â†’ Set Î±\nhs : l.HasAntitoneBasis s\nt : Set Î±\nâŠ¢ Iff (Membership.mem l t) (Exists fun i => HasSubset.Subset (s i) t)","decl":"protected theorem HasAntitoneBasis.mem_iff [Preorder Î¹] {l : Filter Î±} {s : Î¹ â†’ Set Î±}\n    (hs : l.HasAntitoneBasis s) {t : Set Î±} : t âˆˆ l â†” âˆƒ i, s i âŠ† t :=\n  hs.toHasBasis.mem_iff.trans <| by simp only [exists_prop, true_and]\n\n"}
{"name":"Filter.HasAntitoneBasis.mem","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_4\ninstâœ : Preorder Î¹\nl : Filter Î±\ns : Î¹ â†’ Set Î±\nhs : l.HasAntitoneBasis s\ni : Î¹\nâŠ¢ Membership.mem l (s i)","decl":"protected theorem HasAntitoneBasis.mem [Preorder Î¹] {l : Filter Î±} {s : Î¹ â†’ Set Î±}\n    (hs : l.HasAntitoneBasis s) (i : Î¹) : s i âˆˆ l :=\n  hs.toHasBasis.mem_of_mem trivial\n\n"}
{"name":"Filter.HasAntitoneBasis.hasBasis_ge","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_4\ninstâœÂ¹ : Preorder Î¹\ninstâœ : IsDirected Î¹ fun x1 x2 => LE.le x1 x2\nl : Filter Î±\ns : Î¹ â†’ Set Î±\nhs : l.HasAntitoneBasis s\ni : Î¹\nâŠ¢ l.HasBasis (fun j => LE.le i j) s","decl":"theorem HasAntitoneBasis.hasBasis_ge [Preorder Î¹] [IsDirected Î¹ (Â· â‰¤ Â·)] {l : Filter Î±}\n    {s : Î¹ â†’ Set Î±} (hs : l.HasAntitoneBasis s) (i : Î¹) : l.HasBasis (fun j => i â‰¤ j) s :=\n  hs.1.to_hasBasis (fun j _ => (exists_ge_ge i j).imp fun _k hk => âŸ¨hk.1, hs.2 hk.2âŸ©) fun j _ =>\n    âŸ¨j, trivial, Subset.rflâŸ©\n\n"}
{"name":"Filter.HasBasis.exists_antitone_subbasis","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_1\nÎ¹' : Sort u_5\nf : Filter Î±\nh : f.IsCountablyGenerated\np : Î¹' â†’ Prop\ns : Î¹' â†’ Set Î±\nhs : f.HasBasis p s\nâŠ¢ Exists fun x => And (âˆ€ (i : Nat), p (x i)) (f.HasAntitoneBasis fun i => s (x i))","decl":"/-- If `f` is countably generated and `f.HasBasis p s`, then `f` admits a decreasing basis\nenumerated by natural numbers such that all sets have the form `s i`. More precisely, there is a\nsequence `i n` such that `p (i n)` for all `n` and `s (i n)` is a decreasing sequence of sets which\nforms a basis of `f`-/\ntheorem HasBasis.exists_antitone_subbasis {f : Filter Î±} [h : f.IsCountablyGenerated]\n    {p : Î¹' â†’ Prop} {s : Î¹' â†’ Set Î±} (hs : f.HasBasis p s) :\n    âˆƒ x : â„• â†’ Î¹', (âˆ€ i, p (x i)) âˆ§ f.HasAntitoneBasis fun i => s (x i) := by\n  obtain âŸ¨x', hx'âŸ© : âˆƒ x : â„• â†’ Set Î±, f = â¨… i, ğ“Ÿ (x i) := by\n    rcases h with âŸ¨s, hsc, rflâŸ©\n    rw [generate_eq_biInf]\n    exact countable_biInf_principal_eq_seq_iInf hsc\n  have : âˆ€ i, x' i âˆˆ f := fun i => hx'.symm â–¸ (iInf_le (fun i => ğ“Ÿ (x' i)) i) (mem_principal_self _)\n  let x : â„• â†’ { i : Î¹' // p i } := fun n =>\n    Nat.recOn n (hs.index _ <| this 0) fun n xn =>\n      hs.index _ <| inter_mem (this <| n + 1) (hs.mem_of_mem xn.2)\n  have x_anti : Antitone fun i => s (x i).1 :=\n    antitone_nat_of_succ_le fun i => (hs.set_index_subset _).trans inter_subset_right\n  have x_subset : âˆ€ i, s (x i).1 âŠ† x' i := by\n    rintro (_ | i)\n    exacts [hs.set_index_subset _, (hs.set_index_subset _).trans inter_subset_left]\n  refine âŸ¨fun i => (x i).1, fun i => (x i).2, ?_âŸ©\n  have : (â¨… i, ğ“Ÿ (s (x i).1)).HasAntitoneBasis fun i => s (x i).1 := .iInf_principal x_anti\n  convert this\n  exact\n    le_antisymm (le_iInf fun i => le_principal_iff.2 <| by cases i <;> apply hs.set_index_mem)\n      (hx'.symm â–¸\n        le_iInf fun i => le_principal_iff.2 <| this.1.mem_iff.2 âŸ¨i, trivial, x_subset iâŸ©)\n\n"}
{"name":"Filter.exists_antitone_basis","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_1\nf : Filter Î±\ninstâœ : f.IsCountablyGenerated\nâŠ¢ Exists fun x => f.HasAntitoneBasis x","decl":"/-- A countably generated filter admits a basis formed by an antitone sequence of sets. -/\ntheorem exists_antitone_basis (f : Filter Î±) [f.IsCountablyGenerated] :\n    âˆƒ x : â„• â†’ Set Î±, f.HasAntitoneBasis x :=\n  let âŸ¨x, _, hxâŸ© := f.basis_sets.exists_antitone_subbasis\n  âŸ¨x, hxâŸ©\n\n"}
{"name":"Filter.exists_antitone_seq","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_1\nf : Filter Î±\ninstâœ : f.IsCountablyGenerated\nâŠ¢ Exists fun x => And (Antitone x) (âˆ€ {s : Set Î±}, Iff (Membership.mem f s) (Exists fun i => HasSubset.Subset (x i) s))","decl":"theorem exists_antitone_seq (f : Filter Î±) [f.IsCountablyGenerated] :\n    âˆƒ x : â„• â†’ Set Î±, Antitone x âˆ§ âˆ€ {s}, s âˆˆ f â†” âˆƒ i, x i âŠ† s :=\n  let âŸ¨x, hxâŸ© := f.exists_antitone_basis\n  âŸ¨x, hx.antitone, by simp [hx.1.mem_iff]âŸ©\n\n"}
{"name":"Filter.Inf.isCountablyGenerated","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_1\nf g : Filter Î±\ninstâœÂ¹ : f.IsCountablyGenerated\ninstâœ : g.IsCountablyGenerated\nâŠ¢ (Min.min f g).IsCountablyGenerated","decl":"instance Inf.isCountablyGenerated (f g : Filter Î±) [IsCountablyGenerated f]\n    [IsCountablyGenerated g] : IsCountablyGenerated (f âŠ“ g) := by\n  rcases f.exists_antitone_basis with âŸ¨s, hsâŸ©\n  rcases g.exists_antitone_basis with âŸ¨t, htâŸ©\n  exact HasCountableBasis.isCountablyGenerated âŸ¨hs.1.inf ht.1, Set.to_countable _âŸ©\n\n"}
{"name":"Filter.map.isCountablyGenerated","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nl : Filter Î±\ninstâœ : l.IsCountablyGenerated\nf : Î± â†’ Î²\nâŠ¢ (Filter.map f l).IsCountablyGenerated","decl":"instance map.isCountablyGenerated (l : Filter Î±) [l.IsCountablyGenerated] (f : Î± â†’ Î²) :\n    (map f l).IsCountablyGenerated :=\n  let âŸ¨_x, hxlâŸ© := l.exists_antitone_basis\n  (hxl.map _).isCountablyGenerated\n\n"}
{"name":"Filter.comap.isCountablyGenerated","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nl : Filter Î²\ninstâœ : l.IsCountablyGenerated\nf : Î± â†’ Î²\nâŠ¢ (Filter.comap f l).IsCountablyGenerated","decl":"instance comap.isCountablyGenerated (l : Filter Î²) [l.IsCountablyGenerated] (f : Î± â†’ Î²) :\n    (comap f l).IsCountablyGenerated :=\n  let âŸ¨_x, hxlâŸ© := l.exists_antitone_basis\n  (hxl.comap _).isCountablyGenerated\n\n"}
{"name":"Filter.Sup.isCountablyGenerated","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_1\nf g : Filter Î±\ninstâœÂ¹ : f.IsCountablyGenerated\ninstâœ : g.IsCountablyGenerated\nâŠ¢ (Max.max f g).IsCountablyGenerated","decl":"instance Sup.isCountablyGenerated (f g : Filter Î±) [IsCountablyGenerated f]\n    [IsCountablyGenerated g] : IsCountablyGenerated (f âŠ” g) := by\n  rcases f.exists_antitone_basis with âŸ¨s, hsâŸ©\n  rcases g.exists_antitone_basis with âŸ¨t, htâŸ©\n  exact HasCountableBasis.isCountablyGenerated âŸ¨hs.1.sup ht.1, Set.to_countable _âŸ©\n\n"}
{"name":"Filter.prod.isCountablyGenerated","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nla : Filter Î±\nlb : Filter Î²\ninstâœÂ¹ : la.IsCountablyGenerated\ninstâœ : lb.IsCountablyGenerated\nâŠ¢ (SProd.sprod la lb).IsCountablyGenerated","decl":"instance prod.isCountablyGenerated (la : Filter Î±) (lb : Filter Î²) [IsCountablyGenerated la]\n    [IsCountablyGenerated lb] : IsCountablyGenerated (la Ã—Ë¢ lb) :=\n  Filter.Inf.isCountablyGenerated _ _\n\n"}
{"name":"Filter.coprod.isCountablyGenerated","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nla : Filter Î±\nlb : Filter Î²\ninstâœÂ¹ : la.IsCountablyGenerated\ninstâœ : lb.IsCountablyGenerated\nâŠ¢ (la.coprod lb).IsCountablyGenerated","decl":"instance coprod.isCountablyGenerated (la : Filter Î±) (lb : Filter Î²) [IsCountablyGenerated la]\n    [IsCountablyGenerated lb] : IsCountablyGenerated (la.coprod lb) :=\n  Filter.Sup.isCountablyGenerated _ _\n\n"}
{"name":"Filter.isCountablyGenerated_seq","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_1\nÎ¹' : Sort u_5\ninstâœ : Countable Î¹'\nx : Î¹' â†’ Set Î±\nâŠ¢ (iInf fun i => Filter.principal (x i)).IsCountablyGenerated","decl":"theorem isCountablyGenerated_seq [Countable Î¹'] (x : Î¹' â†’ Set Î±) :\n    IsCountablyGenerated (â¨… i, ğ“Ÿ (x i)) := by\n  use range x, countable_range x\n  rw [generate_eq_biInf, iInf_range]\n\n"}
{"name":"Filter.isCountablyGenerated_of_seq","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_1\nf : Filter Î±\nh : Exists fun x => Eq f (iInf fun i => Filter.principal (x i))\nâŠ¢ f.IsCountablyGenerated","decl":"theorem isCountablyGenerated_of_seq {f : Filter Î±} (h : âˆƒ x : â„• â†’ Set Î±, f = â¨… i, ğ“Ÿ (x i)) :\n    f.IsCountablyGenerated := by\n  rcases h with âŸ¨x, rflâŸ©\n  apply isCountablyGenerated_seq\n\n"}
{"name":"Filter.isCountablyGenerated_biInf_principal","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_1\nB : Set (Set Î±)\nh : B.Countable\nâŠ¢ (iInf fun s => iInf fun h => Filter.principal s).IsCountablyGenerated","decl":"theorem isCountablyGenerated_biInf_principal {B : Set (Set Î±)} (h : B.Countable) :\n    IsCountablyGenerated (â¨… s âˆˆ B, ğ“Ÿ s) :=\n  isCountablyGenerated_of_seq (countable_biInf_principal_eq_seq_iInf h)\n\n"}
{"name":"Filter.isCountablyGenerated_iff_exists_antitone_basis","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_1\nf : Filter Î±\nâŠ¢ Iff f.IsCountablyGenerated (Exists fun x => f.HasAntitoneBasis x)","decl":"theorem isCountablyGenerated_iff_exists_antitone_basis {f : Filter Î±} :\n    IsCountablyGenerated f â†” âˆƒ x : â„• â†’ Set Î±, f.HasAntitoneBasis x := by\n  constructor\n  Â· intro h\n    exact f.exists_antitone_basis\n  Â· rintro âŸ¨x, hâŸ©\n    rw [h.1.eq_iInf]\n    exact isCountablyGenerated_seq x\n\n"}
{"name":"Filter.isCountablyGenerated_principal","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_1\ns : Set Î±\nâŠ¢ (Filter.principal s).IsCountablyGenerated","decl":"@[instance]\ntheorem isCountablyGenerated_principal (s : Set Î±) : IsCountablyGenerated (ğ“Ÿ s) :=\n  isCountablyGenerated_of_seq âŸ¨fun _ => s, iInf_const.symmâŸ©\n\n"}
{"name":"Filter.isCountablyGenerated_pure","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_1\na : Î±\nâŠ¢ (Pure.pure a).IsCountablyGenerated","decl":"@[instance]\ntheorem isCountablyGenerated_pure (a : Î±) : IsCountablyGenerated (pure a) := by\n  rw [â† principal_singleton]\n  exact isCountablyGenerated_principal _\n\n"}
{"name":"Filter.isCountablyGenerated_bot","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_1\nâŠ¢ Bot.bot.IsCountablyGenerated","decl":"@[instance]\ntheorem isCountablyGenerated_bot : IsCountablyGenerated (âŠ¥ : Filter Î±) :=\n  @principal_empty Î± â–¸ isCountablyGenerated_principal _\n\n"}
{"name":"Filter.isCountablyGenerated_top","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î± : Type u_1\nâŠ¢ Top.top.IsCountablyGenerated","decl":"@[instance]\ntheorem isCountablyGenerated_top : IsCountablyGenerated (âŠ¤ : Filter Î±) :=\n  @principal_univ Î± â–¸ isCountablyGenerated_principal _\n\n-- Porting note: without explicit `Sort u` and `Type v`, Lean 4 uses `Î¹ : Prop`\n"}
{"name":"Filter.iInf.isCountablyGenerated","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î¹ : Sort u\nÎ± : Type v\ninstâœÂ¹ : Countable Î¹\nf : Î¹ â†’ Filter Î±\ninstâœ : âˆ€ (i : Î¹), (f i).IsCountablyGenerated\nâŠ¢ (iInf fun i => f i).IsCountablyGenerated","decl":"instance iInf.isCountablyGenerated {Î¹ : Sort u} {Î± : Type v} [Countable Î¹] (f : Î¹ â†’ Filter Î±)\n    [âˆ€ i, IsCountablyGenerated (f i)] : IsCountablyGenerated (â¨… i, f i) := by\n  choose s hs using fun i => exists_antitone_basis (f i)\n  rw [â† PLift.down_surjective.iInf_comp]\n  refine HasCountableBasis.isCountablyGenerated âŸ¨hasBasis_iInf fun n => (hs _).1, ?_âŸ©\n  refine (countable_range <| Sigma.map ((â†‘) : Finset (PLift Î¹) â†’ Set (PLift Î¹)) fun _ => id).mono ?_\n  rintro âŸ¨I, fâŸ© âŸ¨hI, -âŸ©\n  lift I to Finset (PLift Î¹) using hI\n  exact âŸ¨âŸ¨I, fâŸ©, rflâŸ©\n\n"}
{"name":"Filter.pi.isCountablyGenerated","module":"Mathlib.Order.Filter.CountablyGenerated","initialProofState":"Î¹ : Type u_6\nÎ± : Î¹ â†’ Type u_7\ninstâœÂ¹ : Countable Î¹\nf : (i : Î¹) â†’ Filter (Î± i)\ninstâœ : âˆ€ (i : Î¹), (f i).IsCountablyGenerated\nâŠ¢ (Filter.pi f).IsCountablyGenerated","decl":"instance pi.isCountablyGenerated {Î¹ : Type*} {Î± : Î¹ â†’ Type*} [Countable Î¹]\n    (f : âˆ€ i, Filter (Î± i)) [âˆ€ i, IsCountablyGenerated (f i)] : IsCountablyGenerated (pi f) :=\n  iInf.isCountablyGenerated _\n\n"}
