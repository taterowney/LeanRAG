{"name":"pNilradical_le_nilradical","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\np : Nat\n⊢ LE.le (pNilradical R p) (nilradical R)","decl":"theorem pNilradical_le_nilradical {R : Type*} [CommSemiring R] {p : ℕ} :\n    pNilradical R p ≤ nilradical R := by\n  by_cases hp : 1 < p\n  · rw [pNilradical, if_pos hp]\n  simp_rw [pNilradical, if_neg hp, bot_le]\n\n"}
{"name":"pNilradical_eq_nilradical","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\np : Nat\nhp : LT.lt 1 p\n⊢ Eq (pNilradical R p) (nilradical R)","decl":"theorem pNilradical_eq_nilradical {R : Type*} [CommSemiring R] {p : ℕ} (hp : 1 < p) :\n    pNilradical R p = nilradical R := by rw [pNilradical, if_pos hp]\n\n"}
{"name":"pNilradical_eq_bot","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\np : Nat\nhp : Not (LT.lt 1 p)\n⊢ Eq (pNilradical R p) Bot.bot","decl":"theorem pNilradical_eq_bot {R : Type*} [CommSemiring R] {p : ℕ} (hp : ¬ 1 < p) :\n    pNilradical R p = ⊥ := by rw [pNilradical, if_neg hp]\n\n"}
{"name":"pNilradical_eq_bot'","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\np : Nat\nhp : LE.le p 1\n⊢ Eq (pNilradical R p) Bot.bot","decl":"theorem pNilradical_eq_bot' {R : Type*} [CommSemiring R] {p : ℕ} (hp : p ≤ 1) :\n    pNilradical R p = ⊥ := pNilradical_eq_bot (not_lt.2 hp)\n\n"}
{"name":"pNilradical_prime","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\np : Nat\nhp : Nat.Prime p\n⊢ Eq (pNilradical R p) (nilradical R)","decl":"theorem pNilradical_prime {R : Type*} [CommSemiring R] {p : ℕ} (hp : p.Prime) :\n    pNilradical R p = nilradical R := pNilradical_eq_nilradical hp.one_lt\n\n"}
{"name":"pNilradical_one","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (pNilradical R 1) Bot.bot","decl":"theorem pNilradical_one {R : Type*} [CommSemiring R] :\n    pNilradical R 1 = ⊥ := pNilradical_eq_bot' rfl.le\n\n"}
{"name":"mem_pNilradical","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\np : Nat\nx : R\n⊢ Iff (Membership.mem (pNilradical R p) x) (Exists fun n => Eq (HPow.hPow x (HPow.hPow p n)) 0)","decl":"theorem mem_pNilradical {R : Type*} [CommSemiring R] {p : ℕ} {x : R} :\n    x ∈ pNilradical R p ↔ ∃ n : ℕ, x ^ p ^ n = 0 := by\n  by_cases hp : 1 < p\n  · rw [pNilradical_eq_nilradical hp]\n    refine ⟨fun ⟨n, h⟩ ↦ ⟨n, ?_⟩, fun ⟨n, h⟩ ↦ ⟨p ^ n, h⟩⟩\n    rw [← Nat.sub_add_cancel ((n.lt_pow_self hp).le), pow_add, h, mul_zero]\n  rw [pNilradical_eq_bot hp, Ideal.mem_bot]\n  refine ⟨fun h ↦ ⟨0, by rw [pow_zero, pow_one, h]⟩, fun ⟨n, h⟩ ↦ ?_⟩\n  rcases Nat.le_one_iff_eq_zero_or_eq_one.1 (not_lt.1 hp) with hp | hp\n  · by_cases hn : n = 0\n    · rwa [hn, pow_zero, pow_one] at h\n    rw [hp, zero_pow hn, pow_zero] at h\n    subsingleton [subsingleton_of_zero_eq_one h.symm]\n  rwa [hp, one_pow, pow_one] at h\n\n"}
{"name":"sub_mem_pNilradical_iff_pow_expChar_pow_eq","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\np : Nat\ninst✝ : ExpChar R p\nx y : R\n⊢ Iff (Membership.mem (pNilradical R p) (HSub.hSub x y)) (Exists fun n => Eq (HPow.hPow x (HPow.hPow p n)) (HPow.hPow y (HPow.hPow p n)))","decl":"theorem sub_mem_pNilradical_iff_pow_expChar_pow_eq {R : Type*} [CommRing R] {p : ℕ} [ExpChar R p]\n    {x y : R} : x - y ∈ pNilradical R p ↔ ∃ n : ℕ, x ^ p ^ n = y ^ p ^ n := by\n  simp_rw [mem_pNilradical, sub_pow_expChar_pow, sub_eq_zero]\n\n"}
{"name":"pow_expChar_pow_inj_of_pNilradical_eq_bot","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\np : Nat\ninst✝ : ExpChar R p\nh : Eq (pNilradical R p) Bot.bot\nn : Nat\n⊢ Function.Injective fun x => HPow.hPow x (HPow.hPow p n)","decl":"theorem pow_expChar_pow_inj_of_pNilradical_eq_bot (R : Type*) [CommRing R] (p : ℕ) [ExpChar R p]\n    (h : pNilradical R p = ⊥) (n : ℕ) : Function.Injective fun x : R ↦ x ^ p ^ n := fun _ _ H ↦\n  sub_eq_zero.1 <| Ideal.mem_bot.1 <| h ▸ sub_mem_pNilradical_iff_pow_expChar_pow_eq.2 ⟨n, H⟩\n\n"}
{"name":"pNilradical_eq_bot_of_frobenius_inj","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\np : Nat\ninst✝ : ExpChar R p\nh : Function.Injective ⇑(frobenius R p)\n⊢ Eq (pNilradical R p) Bot.bot","decl":"theorem pNilradical_eq_bot_of_frobenius_inj (R : Type*) [CommRing R] (p : ℕ) [ExpChar R p]\n    (h : Function.Injective (frobenius R p)) : pNilradical R p = ⊥ := bot_unique fun x ↦ by\n  rw [mem_pNilradical, Ideal.mem_bot]\n  exact fun ⟨n, _⟩ ↦ h.iterate n (by rwa [← coe_iterateFrobenius, map_zero])\n\n"}
{"name":"PerfectRing.pNilradical_eq_bot","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"R : Type u_1\ninst✝² : CommRing R\np : Nat\ninst✝¹ : ExpChar R p\ninst✝ : PerfectRing R p\n⊢ Eq (pNilradical R p) Bot.bot","decl":"theorem PerfectRing.pNilradical_eq_bot (R : Type*) [CommRing R] (p : ℕ) [ExpChar R p]\n    [PerfectRing R p] : pNilradical R p = ⊥ :=\n  pNilradical_eq_bot_of_frobenius_inj R p (injective_frobenius R p)\n\n"}
{"name":"IsPRadical.pow_mem'","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝¹ : CommSemiring K\ninst✝ : CommSemiring L\ni : RingHom K L\np : Nat\nself : IsPRadical i p\nx : L\n⊢ Exists fun n => Exists fun y => Eq (i y) (HPow.hPow x (HPow.hPow p n))","decl":"/-- If `i : K →+* L` is a ring homomorphism of characteristic `p` rings, then it is called\n`p`-radical if the following conditions are satisfied:\n\n- For any element `x` of `L` there is `n : ℕ` such that `x ^ (p ^ n)` is contained in `K`.\n- The kernel of `i` is contained in the `p`-nilradical of `K`.\n\nIt is a generalization of purely inseparable extension for fields. -/\n@[mk_iff]\nclass IsPRadical : Prop where\n  pow_mem' : ∀ x : L, ∃ (n : ℕ) (y : K), i y = x ^ p ^ n\n  ker_le' : RingHom.ker i ≤ pNilradical K p\n\n"}
{"name":"IsPRadical.ker_le'","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝¹ : CommSemiring K\ninst✝ : CommSemiring L\ni : RingHom K L\np : Nat\nself : IsPRadical i p\n⊢ LE.le (RingHom.ker i) (pNilradical K p)","decl":"/-- If `i : K →+* L` is a ring homomorphism of characteristic `p` rings, then it is called\n`p`-radical if the following conditions are satisfied:\n\n- For any element `x` of `L` there is `n : ℕ` such that `x ^ (p ^ n)` is contained in `K`.\n- The kernel of `i` is contained in the `p`-nilradical of `K`.\n\nIt is a generalization of purely inseparable extension for fields. -/\n@[mk_iff]\nclass IsPRadical : Prop where\n  pow_mem' : ∀ x : L, ∃ (n : ℕ) (y : K), i y = x ^ p ^ n\n  ker_le' : RingHom.ker i ≤ pNilradical K p\n\n"}
{"name":"isPRadical_iff","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝¹ : CommSemiring K\ninst✝ : CommSemiring L\ni : RingHom K L\np : Nat\n⊢ Iff (IsPRadical i p) (And (∀ (x : L), Exists fun n => Exists fun y => Eq (i y) (HPow.hPow x (HPow.hPow p n))) (LE.le (RingHom.ker i) (pNilradical K p)))","decl":"/-- If `i : K →+* L` is a ring homomorphism of characteristic `p` rings, then it is called\n`p`-radical if the following conditions are satisfied:\n\n- For any element `x` of `L` there is `n : ℕ` such that `x ^ (p ^ n)` is contained in `K`.\n- The kernel of `i` is contained in the `p`-nilradical of `K`.\n\nIt is a generalization of purely inseparable extension for fields. -/\n@[mk_iff]\nclass IsPRadical : Prop where\n  pow_mem' : ∀ x : L, ∃ (n : ℕ) (y : K), i y = x ^ p ^ n\n  ker_le' : RingHom.ker i ≤ pNilradical K p\n\n"}
{"name":"IsPRadical.pow_mem","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : CommSemiring K\ninst✝¹ : CommSemiring L\ni : RingHom K L\np : Nat\ninst✝ : IsPRadical i p\nx : L\n⊢ Exists fun n => Exists fun y => Eq (i y) (HPow.hPow x (HPow.hPow p n))","decl":"theorem IsPRadical.pow_mem [IsPRadical i p] (x : L) :\n    ∃ (n : ℕ) (y : K), i y = x ^ p ^ n := pow_mem' x\n\n"}
{"name":"IsPRadical.ker_le","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : CommSemiring K\ninst✝¹ : CommSemiring L\ni : RingHom K L\np : Nat\ninst✝ : IsPRadical i p\n⊢ LE.le (RingHom.ker i) (pNilradical K p)","decl":"theorem IsPRadical.ker_le [IsPRadical i p] :\n    RingHom.ker i ≤ pNilradical K p := ker_le'\n\n"}
{"name":"IsPRadical.comap_pNilradical","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : CommSemiring K\ninst✝¹ : CommSemiring L\ni : RingHom K L\np : Nat\ninst✝ : IsPRadical i p\n⊢ Eq (Ideal.comap i (pNilradical L p)) (pNilradical K p)","decl":"theorem IsPRadical.comap_pNilradical [IsPRadical i p] :\n    (pNilradical L p).comap i = pNilradical K p := by\n  refine le_antisymm (fun x h ↦ mem_pNilradical.2 ?_) (fun x h ↦ ?_)\n  · obtain ⟨n, h⟩ := mem_pNilradical.1 <| Ideal.mem_comap.1 h\n    obtain ⟨m, h⟩ := mem_pNilradical.1 <| ker_le i p ((map_pow i x _).symm ▸ h)\n    exact ⟨n + m, by rwa [pow_add, pow_mul]⟩\n  simp only [Ideal.mem_comap, mem_pNilradical] at h ⊢\n  obtain ⟨n, h⟩ := h\n  exact ⟨n, by simpa only [map_pow, map_zero] using congr(i $h)⟩\n\n"}
{"name":"IsPRadical.of_id","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\ninst✝ : CommSemiring K\np : Nat\n⊢ IsPRadical (RingHom.id K) p","decl":"variable (K) in\ninstance IsPRadical.of_id : IsPRadical (RingHom.id K) p where\n  pow_mem' x := ⟨0, x, by simp⟩\n  ker_le' x h := by convert Ideal.zero_mem _\n\n"}
{"name":"IsPRadical.trans","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁴ : CommSemiring K\ninst✝³ : CommSemiring L\ninst✝² : CommSemiring M\ni : RingHom K L\nf : RingHom L M\np : Nat\ninst✝¹ : IsPRadical i p\ninst✝ : IsPRadical f p\n⊢ IsPRadical (f.comp i) p","decl":"/-- Composition of `p`-radical ring homomorphisms is also `p`-radical. -/\ntheorem IsPRadical.trans [IsPRadical i p] [IsPRadical f p] :\n    IsPRadical (f.comp i) p where\n  pow_mem' x := by\n    obtain ⟨n, y, hy⟩ := pow_mem f p x\n    obtain ⟨m, z, hz⟩ := pow_mem i p y\n    exact ⟨n + m, z, by rw [RingHom.comp_apply, hz, map_pow, hy, pow_add, pow_mul]⟩\n  ker_le' x h := by\n    rw [RingHom.mem_ker, RingHom.comp_apply, ← RingHom.mem_ker] at h\n    simpa only [← Ideal.mem_comap, comap_pNilradical] using ker_le f p h\n\n"}
{"name":"RingHom.pNilradical_le_ker_of_perfectRing","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝³ : CommSemiring K\ninst✝² : CommSemiring L\ni : RingHom K L\np : Nat\ninst✝¹ : ExpChar L p\ninst✝ : PerfectRing L p\n⊢ LE.le (pNilradical K p) (RingHom.ker i)","decl":"/-- If `i : K →+* L` is a ring homomorphism of exponential characteristic `p` rings, such that `L`\nis perfect, then the `p`-nilradical of `K` is contained in the kernel of `i`. -/\ntheorem RingHom.pNilradical_le_ker_of_perfectRing [ExpChar L p] [PerfectRing L p] :\n    pNilradical K p ≤ RingHom.ker i := fun x h ↦ by\n  obtain ⟨n, h⟩ := mem_pNilradical.1 h\n  replace h := congr((iterateFrobeniusEquiv L p n).symm (i $h))\n  rwa [map_pow, ← iterateFrobenius_def, ← iterateFrobeniusEquiv_apply, RingEquiv.symm_apply_apply,\n    map_zero, map_zero] at h\n\n"}
{"name":"IsPerfectClosure.ker_eq","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁴ : CommSemiring K\ninst✝³ : CommSemiring L\ni : RingHom K L\np : Nat\ninst✝² : ExpChar L p\ninst✝¹ : PerfectRing L p\ninst✝ : IsPerfectClosure i p\n⊢ Eq (RingHom.ker i) (pNilradical K p)","decl":"variable [ExpChar L p] in\ntheorem IsPerfectClosure.ker_eq [PerfectRing L p] [IsPerfectClosure i p] :\n    RingHom.ker i = pNilradical K p :=\n  IsPRadical.ker_le'.antisymm (i.pNilradical_le_ker_of_perfectRing p)\n\n"}
{"name":"PerfectRing.lift_aux","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : CommSemiring K\ninst✝¹ : CommSemiring L\ni : RingHom K L\np : Nat\ninst✝ : IsPRadical i p\nx : L\n⊢ Exists fun y => Eq (i y.2) (HPow.hPow x (HPow.hPow p y.1))","decl":"theorem lift_aux (x : L) : ∃ y : ℕ × K, i y.2 = x ^ p ^ y.1 := by\n  obtain ⟨n, y, h⟩ := IsPRadical.pow_mem i p x\n  exact ⟨(n, y), h⟩\n\n"}
{"name":"PerfectRing.liftAux_self_apply","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁴ : CommSemiring K\ninst✝³ : CommSemiring L\ni : RingHom K L\np : Nat\ninst✝² : IsPRadical i p\ninst✝¹ : ExpChar L p\ninst✝ : PerfectRing L p\nx : L\n⊢ Eq (PerfectRing.liftAux i i p x) x","decl":"@[simp]\ntheorem liftAux_self_apply [ExpChar L p] [PerfectRing L p] (x : L) : liftAux i i p x = x := by\n  rw [liftAux, Classical.choose_spec (lift_aux i p x), ← iterateFrobenius_def,\n    ← iterateFrobeniusEquiv_apply, RingEquiv.symm_apply_apply]\n\n"}
{"name":"PerfectRing.liftAux_self","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁴ : CommSemiring K\ninst✝³ : CommSemiring L\ni : RingHom K L\np : Nat\ninst✝² : IsPRadical i p\ninst✝¹ : ExpChar L p\ninst✝ : PerfectRing L p\n⊢ Eq (PerfectRing.liftAux i i p) id","decl":"@[simp]\ntheorem liftAux_self [ExpChar L p] [PerfectRing L p] : liftAux i i p = id :=\n  funext (liftAux_self_apply i p)\n\n"}
{"name":"PerfectRing.liftAux_id_apply","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nM : Type u_3\ninst✝³ : CommSemiring K\ninst✝² : CommSemiring M\nj : RingHom K M\np : Nat\ninst✝¹ : ExpChar M p\ninst✝ : PerfectRing M p\nx : K\n⊢ Eq (PerfectRing.liftAux (RingHom.id K) j p x) (j x)","decl":"@[simp]\ntheorem liftAux_id_apply (x : K) : liftAux (RingHom.id K) j p x = j x := by\n  have := RingHom.id_apply _ ▸ Classical.choose_spec (lift_aux (RingHom.id K) p x)\n  rw [liftAux, this, map_pow, ← iterateFrobenius_def, ← iterateFrobeniusEquiv_apply,\n    RingEquiv.symm_apply_apply]\n\n"}
{"name":"PerfectRing.liftAux_id","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nM : Type u_3\ninst✝³ : CommSemiring K\ninst✝² : CommSemiring M\nj : RingHom K M\np : Nat\ninst✝¹ : ExpChar M p\ninst✝ : PerfectRing M p\n⊢ Eq (PerfectRing.liftAux (RingHom.id K) j p) ⇑j","decl":"@[simp]\ntheorem liftAux_id : liftAux (RingHom.id K) j p = j := funext (liftAux_id_apply j p)\n\n"}
{"name":"IsPRadical.injective_comp_of_pNilradical_eq_bot","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁴ : CommRing K\ninst✝³ : CommRing L\ninst✝² : CommRing M\ni : RingHom K L\np : Nat\ninst✝¹ : ExpChar M p\ninst✝ : IsPRadical i p\nh : Eq (pNilradical M p) Bot.bot\n⊢ Function.Injective fun f => f.comp i","decl":"/-- If `i : K →+* L` is `p`-radical, then for any ring `M` of exponential charactistic `p` whose\n`p`-nilradical is zero, the map `(L →+* M) → (K →+* M)` induced by `i` is injective. -/\ntheorem injective_comp_of_pNilradical_eq_bot [IsPRadical i p] (h : pNilradical M p = ⊥) :\n    Function.Injective fun f : L →+* M ↦ f.comp i := fun f g heq ↦ by\n  ext x\n  obtain ⟨n, y, hx⟩ := IsPRadical.pow_mem i p x\n  apply_fun _ using pow_expChar_pow_inj_of_pNilradical_eq_bot M p h n\n  simpa only [← map_pow, ← hx] using congr($(heq) y)\n\n"}
{"name":"IsPRadical.injective_comp","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁵ : CommRing K\ninst✝⁴ : CommRing L\ninst✝³ : CommRing M\ni : RingHom K L\np : Nat\ninst✝² : ExpChar M p\ninst✝¹ : IsPRadical i p\ninst✝ : IsReduced M\n⊢ Function.Injective fun f => f.comp i","decl":"/-- If `i : K →+* L` is `p`-radical, then for any reduced ring `M` of exponential charactistic `p`,\nthe map `(L →+* M) → (K →+* M)` induced by `i` is injective.\nA special case of `IsPRadical.injective_comp_of_pNilradical_eq_bot`\nand a generalization of `IsPurelyInseparable.injective_comp_algebraMap`. -/\ntheorem injective_comp [IsPRadical i p] [IsReduced M] :\n    Function.Injective fun f : L →+* M ↦ f.comp i :=\n  injective_comp_of_pNilradical_eq_bot i p <| bot_unique <|\n    pNilradical_le_nilradical.trans (nilradical_eq_zero M).le\n\n"}
{"name":"IsPRadical.injective_comp_of_perfect","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁵ : CommRing K\ninst✝⁴ : CommRing L\ninst✝³ : CommRing M\ni : RingHom K L\np : Nat\ninst✝² : ExpChar M p\ninst✝¹ : IsPRadical i p\ninst✝ : PerfectRing M p\n⊢ Function.Injective fun f => f.comp i","decl":"/-- If `i : K →+* L` is `p`-radical, then for any perfect ring `M` of exponential charactistic `p`,\nthe map `(L →+* M) → (K →+* M)` induced by `i` is injective.\nA special case of `IsPRadical.injective_comp_of_pNilradical_eq_bot`. -/\ntheorem injective_comp_of_perfect [IsPRadical i p] [PerfectRing M p] :\n    Function.Injective fun f : L →+* M ↦ f.comp i :=\n  injective_comp_of_pNilradical_eq_bot i p (PerfectRing.pNilradical_eq_bot M p)\n\n"}
{"name":"PerfectRing.liftAux_apply","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing K\ninst✝⁵ : CommRing L\ninst✝⁴ : CommRing M\ni : RingHom K L\nj : RingHom K M\np : Nat\ninst✝³ : ExpChar M p\ninst✝² : ExpChar K p\ninst✝¹ : PerfectRing M p\ninst✝ : IsPRadical i p\nx : L\nn : Nat\ny : K\nh : Eq (i y) (HPow.hPow x (HPow.hPow p n))\n⊢ Eq (PerfectRing.liftAux i j p x) ((iterateFrobeniusEquiv M p n).symm (j y))","decl":"/-- If `i : K →+* L` and `j : K →+* M` are ring homomorphisms of characteristic `p` rings, such that\n`i` is `p`-radical, and `M` is a perfect ring, then `PerfectRing.liftAux` is well-defined. -/\ntheorem liftAux_apply (x : L) (n : ℕ) (y : K) (h : i y = x ^ p ^ n) :\n    liftAux i j p x = (iterateFrobeniusEquiv M p n).symm (j y) := by\n  rw [liftAux]\n  have h' := Classical.choose_spec (lift_aux i p x)\n  set n' := (Classical.choose (lift_aux i p x)).1\n  replace h := congr($(h.symm) ^ p ^ n')\n  rw [← pow_mul, mul_comm, pow_mul, ← h', ← map_pow, ← map_pow, ← sub_eq_zero, ← map_sub,\n    ← RingHom.mem_ker] at h\n  obtain ⟨m, h⟩ := mem_pNilradical.1 (IsPRadical.ker_le i p h)\n  refine (iterateFrobeniusEquiv M p (m + n + n')).injective ?_\n  conv_lhs => rw [iterateFrobeniusEquiv_add_apply, RingEquiv.apply_symm_apply]\n  rw [add_assoc, add_comm n n', ← add_assoc,\n    iterateFrobeniusEquiv_add_apply (m := m + n'), RingEquiv.apply_symm_apply,\n    iterateFrobeniusEquiv_def, iterateFrobeniusEquiv_def,\n    ← sub_eq_zero, ← map_pow, ← map_pow, ← map_sub,\n    add_comm m, add_comm m, pow_add, pow_mul, pow_add, pow_mul, ← sub_pow_expChar_pow, h, map_zero]\n\n"}
{"name":"PerfectRing.lift_apply","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁷ : CommRing K\ninst✝⁶ : CommRing L\ninst✝⁵ : CommRing M\ni : RingHom K L\nj : RingHom K M\np : Nat\ninst✝⁴ : ExpChar M p\ninst✝³ : ExpChar K p\ninst✝² : PerfectRing M p\ninst✝¹ : IsPRadical i p\ninst✝ : ExpChar L p\nx : L\nn : Nat\ny : K\nh : Eq (i y) (HPow.hPow x (HPow.hPow p n))\n⊢ Eq ((PerfectRing.lift i j p) x) ((iterateFrobeniusEquiv M p n).symm (j y))","decl":"theorem lift_apply (x : L) (n : ℕ) (y : K) (h : i y = x ^ p ^ n) :\n    lift i j p x = (iterateFrobeniusEquiv M p n).symm (j y) :=\n  liftAux_apply i j p _ _ _ h\n\n"}
{"name":"PerfectRing.lift_comp_apply","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁷ : CommRing K\ninst✝⁶ : CommRing L\ninst✝⁵ : CommRing M\ni : RingHom K L\nj : RingHom K M\np : Nat\ninst✝⁴ : ExpChar M p\ninst✝³ : ExpChar K p\ninst✝² : PerfectRing M p\ninst✝¹ : IsPRadical i p\ninst✝ : ExpChar L p\nx : K\n⊢ Eq ((PerfectRing.lift i j p) (i x)) (j x)","decl":"@[simp]\ntheorem lift_comp_apply (x : K) : lift i j p (i x) = j x := by\n  rw [lift_apply i j p _ 0 x (by rw [pow_zero, pow_one]), iterateFrobeniusEquiv_zero]; rfl\n\n"}
{"name":"PerfectRing.lift_comp","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁷ : CommRing K\ninst✝⁶ : CommRing L\ninst✝⁵ : CommRing M\ni : RingHom K L\nj : RingHom K M\np : Nat\ninst✝⁴ : ExpChar M p\ninst✝³ : ExpChar K p\ninst✝² : PerfectRing M p\ninst✝¹ : IsPRadical i p\ninst✝ : ExpChar L p\n⊢ Eq ((PerfectRing.lift i j p).comp i) j","decl":"@[simp]\ntheorem lift_comp : (lift i j p).comp i = j := RingHom.ext (lift_comp_apply i j p)\n\n"}
{"name":"PerfectRing.lift_self_apply","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁵ : CommRing K\ninst✝⁴ : CommRing L\ni : RingHom K L\np : Nat\ninst✝³ : ExpChar K p\ninst✝² : IsPRadical i p\ninst✝¹ : ExpChar L p\ninst✝ : PerfectRing L p\nx : L\n⊢ Eq ((PerfectRing.lift i i p) x) x","decl":"theorem lift_self_apply [PerfectRing L p] (x : L) : lift i i p x = x := liftAux_self_apply i p x\n\n"}
{"name":"PerfectRing.lift_self","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁵ : CommRing K\ninst✝⁴ : CommRing L\ni : RingHom K L\np : Nat\ninst✝³ : ExpChar K p\ninst✝² : IsPRadical i p\ninst✝¹ : ExpChar L p\ninst✝ : PerfectRing L p\n⊢ Eq (PerfectRing.lift i i p) (RingHom.id L)","decl":"@[simp]\ntheorem lift_self [PerfectRing L p] : lift i i p = RingHom.id L :=\n  RingHom.ext (liftAux_self_apply i p)\n\n"}
{"name":"PerfectRing.lift_id_apply","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nM : Type u_3\ninst✝⁴ : CommRing K\ninst✝³ : CommRing M\nj : RingHom K M\np : Nat\ninst✝² : ExpChar M p\ninst✝¹ : ExpChar K p\ninst✝ : PerfectRing M p\nx : K\n⊢ Eq ((PerfectRing.lift (RingHom.id K) j p) x) (j x)","decl":"theorem lift_id_apply (x : K) : lift (RingHom.id K) j p x = j x := liftAux_id_apply j p x\n\n"}
{"name":"PerfectRing.lift_id","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nM : Type u_3\ninst✝⁴ : CommRing K\ninst✝³ : CommRing M\nj : RingHom K M\np : Nat\ninst✝² : ExpChar M p\ninst✝¹ : ExpChar K p\ninst✝ : PerfectRing M p\n⊢ Eq (PerfectRing.lift (RingHom.id K) j p) j","decl":"@[simp]\ntheorem lift_id : lift (RingHom.id K) j p = j := RingHom.ext (liftAux_id_apply j p)\n\n"}
{"name":"PerfectRing.comp_lift","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁷ : CommRing K\ninst✝⁶ : CommRing L\ninst✝⁵ : CommRing M\ni : RingHom K L\nf : RingHom L M\np : Nat\ninst✝⁴ : ExpChar M p\ninst✝³ : ExpChar K p\ninst✝² : PerfectRing M p\ninst✝¹ : IsPRadical i p\ninst✝ : ExpChar L p\n⊢ Eq (PerfectRing.lift i (f.comp i) p) f","decl":"@[simp]\ntheorem comp_lift : lift i (f.comp i) p = f :=\n  IsPRadical.injective_comp_of_perfect _ i p (lift_comp i _ p)\n\n"}
{"name":"PerfectRing.comp_lift_apply","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁷ : CommRing K\ninst✝⁶ : CommRing L\ninst✝⁵ : CommRing M\ni : RingHom K L\nf : RingHom L M\np : Nat\ninst✝⁴ : ExpChar M p\ninst✝³ : ExpChar K p\ninst✝² : PerfectRing M p\ninst✝¹ : IsPRadical i p\ninst✝ : ExpChar L p\nx : L\n⊢ Eq ((PerfectRing.lift i (f.comp i) p) x) (f x)","decl":"theorem comp_lift_apply (x : L) : lift i (f.comp i) p x = f x := congr($(comp_lift i f p) x)\n\n"}
{"name":"PerfectRing.liftEquiv_apply","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁷ : CommRing K\ninst✝⁶ : CommRing L\ninst✝⁵ : CommRing M\ni : RingHom K L\nj : RingHom K M\np : Nat\ninst✝⁴ : ExpChar M p\ninst✝³ : ExpChar K p\ninst✝² : PerfectRing M p\ninst✝¹ : IsPRadical i p\ninst✝ : ExpChar L p\n⊢ Eq ((PerfectRing.liftEquiv M i p) j) (PerfectRing.lift i j p)","decl":"theorem liftEquiv_apply : liftEquiv M i p j = lift i j p := rfl\n\n"}
{"name":"PerfectRing.liftEquiv_symm_apply","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁷ : CommRing K\ninst✝⁶ : CommRing L\ninst✝⁵ : CommRing M\ni : RingHom K L\nf : RingHom L M\np : Nat\ninst✝⁴ : ExpChar M p\ninst✝³ : ExpChar K p\ninst✝² : PerfectRing M p\ninst✝¹ : IsPRadical i p\ninst✝ : ExpChar L p\n⊢ Eq ((PerfectRing.liftEquiv M i p).symm f) (f.comp i)","decl":"theorem liftEquiv_symm_apply : (liftEquiv M i p).symm f = f.comp i := rfl\n\n"}
{"name":"PerfectRing.liftEquiv_id_apply","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nM : Type u_3\ninst✝⁴ : CommRing K\ninst✝³ : CommRing M\nj : RingHom K M\np : Nat\ninst✝² : ExpChar M p\ninst✝¹ : ExpChar K p\ninst✝ : PerfectRing M p\n⊢ Eq ((PerfectRing.liftEquiv M (RingHom.id K) p) j) j","decl":"theorem liftEquiv_id_apply : liftEquiv M (RingHom.id K) p j = j :=\n  lift_id j p\n\n"}
{"name":"PerfectRing.liftEquiv_id","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nM : Type u_3\ninst✝⁴ : CommRing K\ninst✝³ : CommRing M\np : Nat\ninst✝² : ExpChar M p\ninst✝¹ : ExpChar K p\ninst✝ : PerfectRing M p\n⊢ Eq (PerfectRing.liftEquiv M (RingHom.id K) p) (Equiv.refl (RingHom K M))","decl":"@[simp]\ntheorem liftEquiv_id : liftEquiv M (RingHom.id K) p = Equiv.refl _ :=\n  Equiv.ext (liftEquiv_id_apply · p)\n\n"}
{"name":"PerfectRing.lift_comp_lift","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹¹ : CommRing K\ninst✝¹⁰ : CommRing L\ninst✝⁹ : CommRing M\ninst✝⁸ : CommRing N\ni : RingHom K L\nj : RingHom K M\nk : RingHom K N\np : Nat\ninst✝⁷ : ExpChar M p\ninst✝⁶ : ExpChar K p\ninst✝⁵ : PerfectRing M p\ninst✝⁴ : IsPRadical i p\ninst✝³ : ExpChar L p\ninst✝² : ExpChar N p\ninst✝¹ : PerfectRing N p\ninst✝ : IsPRadical j p\n⊢ Eq ((PerfectRing.lift j k p).comp (PerfectRing.lift i j p)) (PerfectRing.lift i k p)","decl":"@[simp]\ntheorem lift_comp_lift : (lift j k p).comp (lift i j p) = lift i k p :=\n  IsPRadical.injective_comp_of_perfect _ i p (by ext; simp)\n\n"}
{"name":"PerfectRing.lift_comp_lift_apply","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹¹ : CommRing K\ninst✝¹⁰ : CommRing L\ninst✝⁹ : CommRing M\ninst✝⁸ : CommRing N\ni : RingHom K L\nj : RingHom K M\nk : RingHom K N\np : Nat\ninst✝⁷ : ExpChar M p\ninst✝⁶ : ExpChar K p\ninst✝⁵ : PerfectRing M p\ninst✝⁴ : IsPRadical i p\ninst✝³ : ExpChar L p\ninst✝² : ExpChar N p\ninst✝¹ : PerfectRing N p\ninst✝ : IsPRadical j p\nx : L\n⊢ Eq ((PerfectRing.lift j k p) ((PerfectRing.lift i j p) x)) ((PerfectRing.lift i k p) x)","decl":"@[simp]\ntheorem lift_comp_lift_apply (x : L) : lift j k p (lift i j p x) = lift i k p x :=\n  congr($(lift_comp_lift i j k p) x)\n\n"}
{"name":"PerfectRing.lift_comp_lift_apply_eq_self","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁹ : CommRing K\ninst✝⁸ : CommRing L\ninst✝⁷ : CommRing M\ni : RingHom K L\nj : RingHom K M\np : Nat\ninst✝⁶ : ExpChar M p\ninst✝⁵ : ExpChar K p\ninst✝⁴ : PerfectRing M p\ninst✝³ : IsPRadical i p\ninst✝² : ExpChar L p\ninst✝¹ : IsPRadical j p\ninst✝ : PerfectRing L p\nx : L\n⊢ Eq ((PerfectRing.lift j i p) ((PerfectRing.lift i j p) x)) x","decl":"theorem lift_comp_lift_apply_eq_self [PerfectRing L p] (x : L) :\n    lift j i p (lift i j p x) = x := by\n  rw [lift_comp_lift_apply, lift_self_apply]\n\n"}
{"name":"PerfectRing.lift_comp_lift_eq_id","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁹ : CommRing K\ninst✝⁸ : CommRing L\ninst✝⁷ : CommRing M\ni : RingHom K L\nj : RingHom K M\np : Nat\ninst✝⁶ : ExpChar M p\ninst✝⁵ : ExpChar K p\ninst✝⁴ : PerfectRing M p\ninst✝³ : IsPRadical i p\ninst✝² : ExpChar L p\ninst✝¹ : IsPRadical j p\ninst✝ : PerfectRing L p\n⊢ Eq ((PerfectRing.lift j i p).comp (PerfectRing.lift i j p)) (RingHom.id L)","decl":"theorem lift_comp_lift_eq_id [PerfectRing L p] :\n    (lift j i p).comp (lift i j p) = RingHom.id L :=\n  RingHom.ext (lift_comp_lift_apply_eq_self i j p)\n\n"}
{"name":"PerfectRing.lift_lift","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹¹ : CommRing K\ninst✝¹⁰ : CommRing L\ninst✝⁹ : CommRing M\ninst✝⁸ : CommRing N\ni : RingHom K L\nj : RingHom K M\ng : RingHom L N\np : Nat\ninst✝⁷ : ExpChar M p\ninst✝⁶ : ExpChar K p\ninst✝⁵ : PerfectRing M p\ninst✝⁴ : IsPRadical i p\ninst✝³ : ExpChar L p\ninst✝² : ExpChar N p\ninst✝¹ : IsPRadical g p\ninst✝ : IsPRadical (g.comp i) p\n⊢ Eq (PerfectRing.lift g (PerfectRing.lift i j p) p) (PerfectRing.lift (g.comp i) j p)","decl":"@[simp]\ntheorem lift_lift : lift g (lift i j p) p = lift (g.comp i) j p := by\n  refine IsPRadical.injective_comp_of_perfect _ (g.comp i) p ?_\n  simp_rw [← RingHom.comp_assoc _ _ (lift g _ p), lift_comp]\n\n"}
{"name":"PerfectRing.lift_lift_apply","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹¹ : CommRing K\ninst✝¹⁰ : CommRing L\ninst✝⁹ : CommRing M\ninst✝⁸ : CommRing N\ni : RingHom K L\nj : RingHom K M\ng : RingHom L N\np : Nat\ninst✝⁷ : ExpChar M p\ninst✝⁶ : ExpChar K p\ninst✝⁵ : PerfectRing M p\ninst✝⁴ : IsPRadical i p\ninst✝³ : ExpChar L p\ninst✝² : ExpChar N p\ninst✝¹ : IsPRadical g p\ninst✝ : IsPRadical (g.comp i) p\nx : N\n⊢ Eq ((PerfectRing.lift g (PerfectRing.lift i j p) p) x) ((PerfectRing.lift (g.comp i) j p) x)","decl":"theorem lift_lift_apply (x : N) : lift g (lift i j p) p x = lift (g.comp i) j p x :=\n  congr($(lift_lift i j g p) x)\n\n"}
{"name":"PerfectRing.liftEquiv_comp_apply","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹¹ : CommRing K\ninst✝¹⁰ : CommRing L\ninst✝⁹ : CommRing M\ninst✝⁸ : CommRing N\ni : RingHom K L\nj : RingHom K M\ng : RingHom L N\np : Nat\ninst✝⁷ : ExpChar M p\ninst✝⁶ : ExpChar K p\ninst✝⁵ : PerfectRing M p\ninst✝⁴ : IsPRadical i p\ninst✝³ : ExpChar L p\ninst✝² : ExpChar N p\ninst✝¹ : IsPRadical g p\ninst✝ : IsPRadical (g.comp i) p\n⊢ Eq ((PerfectRing.liftEquiv M g p) ((PerfectRing.liftEquiv M i p) j)) ((PerfectRing.liftEquiv M (g.comp i) p) j)","decl":"@[simp]\ntheorem liftEquiv_comp_apply :\n    liftEquiv M g p (liftEquiv M i p j) = liftEquiv M (g.comp i) p j := lift_lift i j g p\n\n"}
{"name":"PerfectRing.liftEquiv_trans","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹¹ : CommRing K\ninst✝¹⁰ : CommRing L\ninst✝⁹ : CommRing M\ninst✝⁸ : CommRing N\ni : RingHom K L\ng : RingHom L N\np : Nat\ninst✝⁷ : ExpChar M p\ninst✝⁶ : ExpChar K p\ninst✝⁵ : PerfectRing M p\ninst✝⁴ : IsPRadical i p\ninst✝³ : ExpChar L p\ninst✝² : ExpChar N p\ninst✝¹ : IsPRadical g p\ninst✝ : IsPRadical (g.comp i) p\n⊢ Eq ((PerfectRing.liftEquiv M i p).trans (PerfectRing.liftEquiv M g p)) (PerfectRing.liftEquiv M (g.comp i) p)","decl":"@[simp]\ntheorem liftEquiv_trans :\n    (liftEquiv M i p).trans (liftEquiv M g p) = liftEquiv M (g.comp i) p :=\n  Equiv.ext (liftEquiv_comp_apply i · g p)\n\n"}
{"name":"IsPerfectClosure.equiv_toRingHom","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁹ : CommRing K\ninst✝⁸ : CommRing L\ninst✝⁷ : CommRing M\ni : RingHom K L\nj : RingHom K M\np : Nat\ninst✝⁶ : ExpChar M p\ninst✝⁵ : ExpChar K p\ninst✝⁴ : ExpChar L p\ninst✝³ : PerfectRing L p\ninst✝² : IsPerfectClosure i p\ninst✝¹ : PerfectRing M p\ninst✝ : IsPerfectClosure j p\n⊢ Eq (IsPerfectClosure.equiv i j p).toRingHom (PerfectRing.lift i j p)","decl":"theorem equiv_toRingHom : (equiv i j p).toRingHom = PerfectRing.lift i j p := rfl\n\n"}
{"name":"IsPerfectClosure.equiv_symm","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁹ : CommRing K\ninst✝⁸ : CommRing L\ninst✝⁷ : CommRing M\ni : RingHom K L\nj : RingHom K M\np : Nat\ninst✝⁶ : ExpChar M p\ninst✝⁵ : ExpChar K p\ninst✝⁴ : ExpChar L p\ninst✝³ : PerfectRing L p\ninst✝² : IsPerfectClosure i p\ninst✝¹ : PerfectRing M p\ninst✝ : IsPerfectClosure j p\n⊢ Eq (IsPerfectClosure.equiv i j p).symm (IsPerfectClosure.equiv j i p)","decl":"@[simp]\ntheorem equiv_symm : (equiv i j p).symm = equiv j i p := rfl\n\n"}
{"name":"IsPerfectClosure.equiv_symm_toRingHom","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁹ : CommRing K\ninst✝⁸ : CommRing L\ninst✝⁷ : CommRing M\ni : RingHom K L\nj : RingHom K M\np : Nat\ninst✝⁶ : ExpChar M p\ninst✝⁵ : ExpChar K p\ninst✝⁴ : ExpChar L p\ninst✝³ : PerfectRing L p\ninst✝² : IsPerfectClosure i p\ninst✝¹ : PerfectRing M p\ninst✝ : IsPerfectClosure j p\n⊢ Eq (IsPerfectClosure.equiv i j p).symm.toRingHom (PerfectRing.lift j i p)","decl":"theorem equiv_symm_toRingHom :\n    (equiv i j p).symm.toRingHom = PerfectRing.lift j i p := rfl\n\n"}
{"name":"IsPerfectClosure.equiv_apply","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁹ : CommRing K\ninst✝⁸ : CommRing L\ninst✝⁷ : CommRing M\ni : RingHom K L\nj : RingHom K M\np : Nat\ninst✝⁶ : ExpChar M p\ninst✝⁵ : ExpChar K p\ninst✝⁴ : ExpChar L p\ninst✝³ : PerfectRing L p\ninst✝² : IsPerfectClosure i p\ninst✝¹ : PerfectRing M p\ninst✝ : IsPerfectClosure j p\nx : L\nn : Nat\ny : K\nh : Eq (i y) (HPow.hPow x (HPow.hPow p n))\n⊢ Eq ((IsPerfectClosure.equiv i j p) x) ((iterateFrobeniusEquiv M p n).symm (j y))","decl":"theorem equiv_apply (x : L) (n : ℕ) (y : K) (h : i y = x ^ p ^ n) :\n    equiv i j p x = (iterateFrobeniusEquiv M p n).symm (j y) :=\n  PerfectRing.liftAux_apply i j p _ _ _ h\n\n"}
{"name":"IsPerfectClosure.equiv_symm_apply","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁹ : CommRing K\ninst✝⁸ : CommRing L\ninst✝⁷ : CommRing M\ni : RingHom K L\nj : RingHom K M\np : Nat\ninst✝⁶ : ExpChar M p\ninst✝⁵ : ExpChar K p\ninst✝⁴ : ExpChar L p\ninst✝³ : PerfectRing L p\ninst✝² : IsPerfectClosure i p\ninst✝¹ : PerfectRing M p\ninst✝ : IsPerfectClosure j p\nx : M\nn : Nat\ny : K\nh : Eq (j y) (HPow.hPow x (HPow.hPow p n))\n⊢ Eq ((IsPerfectClosure.equiv i j p).symm x) ((iterateFrobeniusEquiv L p n).symm (i y))","decl":"theorem equiv_symm_apply (x : M) (n : ℕ) (y : K) (h : j y = x ^ p ^ n) :\n    (equiv i j p).symm x = (iterateFrobeniusEquiv L p n).symm (i y) := by\n  rw [equiv_symm, equiv_apply j i p _ _ _ h]\n\n"}
{"name":"IsPerfectClosure.equiv_self_apply","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁵ : CommRing K\ninst✝⁴ : CommRing L\ni : RingHom K L\np : Nat\ninst✝³ : ExpChar K p\ninst✝² : ExpChar L p\ninst✝¹ : PerfectRing L p\ninst✝ : IsPerfectClosure i p\nx : L\n⊢ Eq ((IsPerfectClosure.equiv i i p) x) x","decl":"theorem equiv_self_apply (x : L) : equiv i i p x = x :=\n  PerfectRing.liftAux_self_apply i p x\n\n"}
{"name":"IsPerfectClosure.equiv_self","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁵ : CommRing K\ninst✝⁴ : CommRing L\ni : RingHom K L\np : Nat\ninst✝³ : ExpChar K p\ninst✝² : ExpChar L p\ninst✝¹ : PerfectRing L p\ninst✝ : IsPerfectClosure i p\n⊢ Eq (IsPerfectClosure.equiv i i p) (RingEquiv.refl L)","decl":"@[simp]\ntheorem equiv_self : equiv i i p = RingEquiv.refl L :=\n  RingEquiv.ext (equiv_self_apply i p)\n\n"}
{"name":"IsPerfectClosure.equiv_comp_apply","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁹ : CommRing K\ninst✝⁸ : CommRing L\ninst✝⁷ : CommRing M\ni : RingHom K L\nj : RingHom K M\np : Nat\ninst✝⁶ : ExpChar M p\ninst✝⁵ : ExpChar K p\ninst✝⁴ : ExpChar L p\ninst✝³ : PerfectRing L p\ninst✝² : IsPerfectClosure i p\ninst✝¹ : PerfectRing M p\ninst✝ : IsPerfectClosure j p\nx : K\n⊢ Eq ((IsPerfectClosure.equiv i j p) (i x)) (j x)","decl":"@[simp]\ntheorem equiv_comp_apply (x : K) : equiv i j p (i x) = j x :=\n  PerfectRing.lift_comp_apply i j p x\n\n"}
{"name":"IsPerfectClosure.equiv_comp","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁹ : CommRing K\ninst✝⁸ : CommRing L\ninst✝⁷ : CommRing M\ni : RingHom K L\nj : RingHom K M\np : Nat\ninst✝⁶ : ExpChar M p\ninst✝⁵ : ExpChar K p\ninst✝⁴ : ExpChar L p\ninst✝³ : PerfectRing L p\ninst✝² : IsPerfectClosure i p\ninst✝¹ : PerfectRing M p\ninst✝ : IsPerfectClosure j p\n⊢ Eq ((↑(IsPerfectClosure.equiv i j p)).comp i) j","decl":"@[simp]\ntheorem equiv_comp : RingHom.comp (equiv i j p) i = j :=\n  RingHom.ext (equiv_comp_apply i j p)\n\n"}
{"name":"IsPerfectClosure.equiv_comp_equiv_apply","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹³ : CommRing K\ninst✝¹² : CommRing L\ninst✝¹¹ : CommRing M\ninst✝¹⁰ : CommRing N\ni : RingHom K L\nj : RingHom K M\nk : RingHom K N\np : Nat\ninst✝⁹ : ExpChar M p\ninst✝⁸ : ExpChar K p\ninst✝⁷ : ExpChar L p\ninst✝⁶ : PerfectRing L p\ninst✝⁵ : IsPerfectClosure i p\ninst✝⁴ : PerfectRing M p\ninst✝³ : IsPerfectClosure j p\ninst✝² : ExpChar N p\ninst✝¹ : PerfectRing N p\ninst✝ : IsPerfectClosure k p\nx : L\n⊢ Eq ((IsPerfectClosure.equiv j k p) ((IsPerfectClosure.equiv i j p) x)) ((IsPerfectClosure.equiv i k p) x)","decl":"@[simp]\ntheorem equiv_comp_equiv_apply (x : L) :\n    equiv j k p (equiv i j p x) = equiv i k p x :=\n  PerfectRing.lift_comp_lift_apply i j k p x\n\n"}
{"name":"IsPerfectClosure.equiv_comp_equiv","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹³ : CommRing K\ninst✝¹² : CommRing L\ninst✝¹¹ : CommRing M\ninst✝¹⁰ : CommRing N\ni : RingHom K L\nj : RingHom K M\nk : RingHom K N\np : Nat\ninst✝⁹ : ExpChar M p\ninst✝⁸ : ExpChar K p\ninst✝⁷ : ExpChar L p\ninst✝⁶ : PerfectRing L p\ninst✝⁵ : IsPerfectClosure i p\ninst✝⁴ : PerfectRing M p\ninst✝³ : IsPerfectClosure j p\ninst✝² : ExpChar N p\ninst✝¹ : PerfectRing N p\ninst✝ : IsPerfectClosure k p\n⊢ Eq ((IsPerfectClosure.equiv i j p).trans (IsPerfectClosure.equiv j k p)) (IsPerfectClosure.equiv i k p)","decl":"@[simp]\ntheorem equiv_comp_equiv : (equiv i j p).trans (equiv j k p) = equiv i k p :=\n  RingEquiv.ext (equiv_comp_equiv_apply i j k p)\n\n"}
{"name":"IsPerfectClosure.equiv_comp_equiv_apply_eq_self","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁹ : CommRing K\ninst✝⁸ : CommRing L\ninst✝⁷ : CommRing M\ni : RingHom K L\nj : RingHom K M\np : Nat\ninst✝⁶ : ExpChar M p\ninst✝⁵ : ExpChar K p\ninst✝⁴ : ExpChar L p\ninst✝³ : PerfectRing L p\ninst✝² : IsPerfectClosure i p\ninst✝¹ : PerfectRing M p\ninst✝ : IsPerfectClosure j p\nx : L\n⊢ Eq ((IsPerfectClosure.equiv j i p) ((IsPerfectClosure.equiv i j p) x)) x","decl":"theorem equiv_comp_equiv_apply_eq_self (x : L) :\n    equiv j i p (equiv i j p x) = x := by\n  rw [equiv_comp_equiv_apply, equiv_self_apply]\n\n"}
{"name":"IsPerfectClosure.equiv_comp_equiv_eq_id","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁹ : CommRing K\ninst✝⁸ : CommRing L\ninst✝⁷ : CommRing M\ni : RingHom K L\nj : RingHom K M\np : Nat\ninst✝⁶ : ExpChar M p\ninst✝⁵ : ExpChar K p\ninst✝⁴ : ExpChar L p\ninst✝³ : PerfectRing L p\ninst✝² : IsPerfectClosure i p\ninst✝¹ : PerfectRing M p\ninst✝ : IsPerfectClosure j p\n⊢ Eq ((IsPerfectClosure.equiv i j p).trans (IsPerfectClosure.equiv j i p)) (RingEquiv.refl L)","decl":"theorem equiv_comp_equiv_eq_id :\n    (equiv i j p).trans (equiv j i p) = RingEquiv.refl L :=\n  RingEquiv.ext (equiv_comp_equiv_apply_eq_self i j p)\n\n"}
{"name":"PerfectClosure.isPRadical","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\ninst✝² : CommRing K\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : CharP K p\n⊢ IsPRadical (PerfectClosure.of K p) p","decl":"/-- The absolute perfect closure `PerfectClosure` is a `p`-radical extension over the base ring.\nIn particular, it is a perfect closure of the base ring, that is,\n`IsPerfectClosure (PerfectClosure.of K p) p`. -/\ninstance isPRadical : IsPRadical (PerfectClosure.of K p) p where\n  pow_mem' x := PerfectClosure.induction_on x fun x ↦ ⟨x.1, x.2, by\n    rw [← iterate_frobenius, iterate_frobenius_mk K p x.1 x.2]⟩\n  ker_le' x h := by\n    rw [RingHom.mem_ker, of_apply, zero_def, mk_eq_iff] at h\n    obtain ⟨n, h⟩ := h\n    simp_rw [zero_add, ← coe_iterateFrobenius, map_zero] at h\n    exact mem_pNilradical.2 ⟨n, h⟩\n\n"}
{"name":"IsPRadical.isPurelyInseparable","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra K L\np : Nat\ninst✝¹ : ExpChar K p\ninst✝ : IsPRadical (algebraMap K L) p\n⊢ IsPurelyInseparable K L","decl":"/-- If `L / K` is a `p`-radical field extension, then it is purely inseparable. -/\ntheorem IsPRadical.isPurelyInseparable [IsPRadical (algebraMap K L) p] :\n    IsPurelyInseparable K L :=\n  (isPurelyInseparable_iff_pow_mem K p).2 (IsPRadical.pow_mem (algebraMap K L) p)\n\n"}
{"name":"IsPurelyInseparable.isPRadical","module":"Mathlib.FieldTheory.IsPerfectClosure","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra K L\np : Nat\ninst✝¹ : ExpChar K p\ninst✝ : IsPurelyInseparable K L\n⊢ IsPRadical (algebraMap K L) p","decl":"/-- If `L / K` is a purely inseparable field extension, then it is `p`-radical. In particular, if\n`L` is perfect, then the (relative) perfect closure `perfectClosure K L` is a perfect closure\nof `K`, that is, `IsPerfectClosure (algebraMap K (perfectClosure K L)) p`. -/\ninstance IsPurelyInseparable.isPRadical [IsPurelyInseparable K L] :\n    IsPRadical (algebraMap K L) p where\n  pow_mem' := (isPurelyInseparable_iff_pow_mem K p).1 ‹_›\n  ker_le' := (RingHom.injective_iff_ker_eq_bot _).1 (algebraMap K L).injective ▸ bot_le\n\n"}
