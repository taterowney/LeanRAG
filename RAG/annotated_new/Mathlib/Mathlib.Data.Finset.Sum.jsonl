{"name":"Finset.val_disjSum","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\n⊢ Eq (s.disjSum t).val (s.val.disjSum t.val)","decl":"@[simp]\ntheorem val_disjSum : (s.disjSum t).1 = s.1.disjSum t.1 :=\n  rfl\n\n"}
{"name":"Finset.empty_disjSum","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\nt : Finset β\n⊢ Eq (EmptyCollection.emptyCollection.disjSum t) (Finset.map Function.Embedding.inr t)","decl":"@[simp]\ntheorem empty_disjSum : (∅ : Finset α).disjSum t = t.map Embedding.inr :=\n  val_inj.1 <| Multiset.zero_disjSum _\n\n"}
{"name":"Finset.disjSum_empty","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\n⊢ Eq (s.disjSum EmptyCollection.emptyCollection) (Finset.map Function.Embedding.inl s)","decl":"@[simp]\ntheorem disjSum_empty : s.disjSum (∅ : Finset β) = s.map Embedding.inl :=\n  val_inj.1 <| Multiset.disjSum_zero _\n\n"}
{"name":"Finset.card_disjSum","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\n⊢ Eq (s.disjSum t).card (HAdd.hAdd s.card t.card)","decl":"@[simp]\ntheorem card_disjSum : (s.disjSum t).card = s.card + t.card :=\n  Multiset.card_disjSum _ _\n\n"}
{"name":"Finset.disjoint_map_inl_map_inr","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\n⊢ Disjoint (Finset.map Function.Embedding.inl s) (Finset.map Function.Embedding.inr t)","decl":"theorem disjoint_map_inl_map_inr : Disjoint (s.map Embedding.inl) (t.map Embedding.inr) := by\n  simp_rw [disjoint_left, mem_map]\n  rintro x ⟨a, _, rfl⟩ ⟨b, _, ⟨⟩⟩\n\n"}
{"name":"Finset.map_inl_disjUnion_map_inr","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\n⊢ Eq ((Finset.map Function.Embedding.inl s).disjUnion (Finset.map Function.Embedding.inr t) ⋯) (s.disjSum t)","decl":"@[simp]\ntheorem map_inl_disjUnion_map_inr :\n    (s.map Embedding.inl).disjUnion (t.map Embedding.inr) (disjoint_map_inl_map_inr _ _) =\n      s.disjSum t :=\n  rfl\n\n"}
{"name":"Finset.mem_disjSum","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\nx : Sum α β\n⊢ Iff (Membership.mem (s.disjSum t) x) (Or (Exists fun a => And (Membership.mem s a) (Eq (Sum.inl a) x)) (Exists fun b => And (Membership.mem t b) (Eq (Sum.inr b) x)))","decl":"theorem mem_disjSum : x ∈ s.disjSum t ↔ (∃ a, a ∈ s ∧ inl a = x) ∨ ∃ b, b ∈ t ∧ inr b = x :=\n  Multiset.mem_disjSum\n\n"}
{"name":"Finset.inl_mem_disjSum","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\na : α\n⊢ Iff (Membership.mem (s.disjSum t) (Sum.inl a)) (Membership.mem s a)","decl":"@[simp]\ntheorem inl_mem_disjSum : inl a ∈ s.disjSum t ↔ a ∈ s :=\n  Multiset.inl_mem_disjSum\n\n"}
{"name":"Finset.inr_mem_disjSum","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\nb : β\n⊢ Iff (Membership.mem (s.disjSum t) (Sum.inr b)) (Membership.mem t b)","decl":"@[simp]\ntheorem inr_mem_disjSum : inr b ∈ s.disjSum t ↔ b ∈ t :=\n  Multiset.inr_mem_disjSum\n\n"}
{"name":"Finset.disjSum_eq_empty","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\n⊢ Iff (Eq (s.disjSum t) EmptyCollection.emptyCollection) (And (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection))","decl":"@[simp]\ntheorem disjSum_eq_empty : s.disjSum t = ∅ ↔ s = ∅ ∧ t = ∅ := by simp [Finset.ext_iff]\n\n"}
{"name":"Finset.disjSum_mono","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Finset α\nt₁ t₂ : Finset β\nhs : HasSubset.Subset s₁ s₂\nht : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (s₁.disjSum t₁) (s₂.disjSum t₂)","decl":"theorem disjSum_mono (hs : s₁ ⊆ s₂) (ht : t₁ ⊆ t₂) : s₁.disjSum t₁ ⊆ s₂.disjSum t₂ :=\n  val_le_iff.1 <| Multiset.disjSum_mono (val_le_iff.2 hs) (val_le_iff.2 ht)\n\n"}
{"name":"Finset.disjSum_mono_left","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\nt : Finset β\n⊢ Monotone fun s => s.disjSum t","decl":"theorem disjSum_mono_left (t : Finset β) : Monotone fun s : Finset α => s.disjSum t :=\n  fun _ _ hs => disjSum_mono hs Subset.rfl\n\n"}
{"name":"Finset.disjSum_mono_right","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\n⊢ Monotone s.disjSum","decl":"theorem disjSum_mono_right (s : Finset α) : Monotone (s.disjSum : Finset β → Finset (α ⊕ β)) :=\n  fun _ _ => disjSum_mono Subset.rfl\n\n"}
{"name":"Finset.disjSum_ssubset_disjSum_of_ssubset_of_subset","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Finset α\nt₁ t₂ : Finset β\nhs : HasSSubset.SSubset s₁ s₂\nht : HasSubset.Subset t₁ t₂\n⊢ HasSSubset.SSubset (s₁.disjSum t₁) (s₂.disjSum t₂)","decl":"theorem disjSum_ssubset_disjSum_of_ssubset_of_subset (hs : s₁ ⊂ s₂) (ht : t₁ ⊆ t₂) :\n    s₁.disjSum t₁ ⊂ s₂.disjSum t₂ :=\n  val_lt_iff.1 <| disjSum_lt_disjSum_of_lt_of_le (val_lt_iff.2 hs) (val_le_iff.2 ht)\n\n"}
{"name":"Finset.disjSum_ssubset_disjSum_of_subset_of_ssubset","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Finset α\nt₁ t₂ : Finset β\nhs : HasSubset.Subset s₁ s₂\nht : HasSSubset.SSubset t₁ t₂\n⊢ HasSSubset.SSubset (s₁.disjSum t₁) (s₂.disjSum t₂)","decl":"theorem disjSum_ssubset_disjSum_of_subset_of_ssubset (hs : s₁ ⊆ s₂) (ht : t₁ ⊂ t₂) :\n    s₁.disjSum t₁ ⊂ s₂.disjSum t₂ :=\n  val_lt_iff.1 <| disjSum_lt_disjSum_of_le_of_lt (val_le_iff.2 hs) (val_lt_iff.2 ht)\n\n"}
{"name":"Finset.disjSum_strictMono_left","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\nt : Finset β\n⊢ StrictMono fun s => s.disjSum t","decl":"theorem disjSum_strictMono_left (t : Finset β) : StrictMono fun s : Finset α => s.disjSum t :=\n  fun _ _ hs => disjSum_ssubset_disjSum_of_ssubset_of_subset hs Subset.rfl\n\n"}
{"name":"Finset.disj_sum_strictMono_right","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\n⊢ StrictMono s.disjSum","decl":"theorem disj_sum_strictMono_right (s : Finset α) :\n    StrictMono (s.disjSum : Finset β → Finset (α ⊕ β)) := fun _ _ =>\n  disjSum_ssubset_disjSum_of_subset_of_ssubset Subset.rfl\n\n"}
{"name":"Finset.disjSum_inj","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_3\nβ : Type u_4\ns₁ s₂ : Finset α\nt₁ t₂ : Finset β\n⊢ Iff (Eq (s₁.disjSum t₁) (s₂.disjSum t₂)) (And (Eq s₁ s₂) (Eq t₁ t₂))","decl":"@[simp] lemma disjSum_inj {α β : Type*} {s₁ s₂ : Finset α} {t₁ t₂ : Finset β} :\n    s₁.disjSum t₁ = s₂.disjSum t₂ ↔ s₁ = s₂ ∧ t₁ = t₂ := by\n  simp [Finset.ext_iff]\n\n"}
{"name":"Finset.Injective2_disjSum","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_3\nβ : Type u_4\n⊢ Function.Injective2 Finset.disjSum","decl":"lemma Injective2_disjSum {α β : Type*} : Function.Injective2 (@disjSum α β) :=\n  fun _ _ _ _ => by simp [Finset.ext_iff]\n\n"}
{"name":"Finset.mem_toLeft","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\nu : Finset (Sum α β)\nx : α\n⊢ Iff (Membership.mem u.toLeft x) (Membership.mem u (Sum.inl x))","decl":"@[simp] lemma mem_toLeft {x : α} : x ∈ u.toLeft ↔ inl x ∈ u := by\n  simp [toLeft]\n\n"}
{"name":"Finset.mem_toRight","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\nu : Finset (Sum α β)\nx : β\n⊢ Iff (Membership.mem u.toRight x) (Membership.mem u (Sum.inr x))","decl":"@[simp] lemma mem_toRight {x : β} : x ∈ u.toRight ↔ inr x ∈ u := by\n  simp [toRight]\n\n"}
{"name":"Finset.toLeft_subset_toLeft","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\nu v : Finset (Sum α β)\na✝ : HasSubset.Subset u v\n⊢ HasSubset.Subset u.toLeft v.toLeft","decl":"@[gcongr]\nlemma toLeft_subset_toLeft : u ⊆ v → u.toLeft ⊆ v.toLeft :=\n  fun h _ => by simpa only [mem_toLeft] using @h _\n\n"}
{"name":"Finset.toRight_subset_toRight","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\nu v : Finset (Sum α β)\na✝ : HasSubset.Subset u v\n⊢ HasSubset.Subset u.toRight v.toRight","decl":"@[gcongr]\nlemma toRight_subset_toRight : u ⊆ v → u.toRight ⊆ v.toRight :=\n  fun h _ => by simpa only [mem_toRight] using @h _\n\n"}
{"name":"Finset.toLeft_monotone","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Monotone Finset.toLeft","decl":"lemma toLeft_monotone : Monotone (@toLeft α β) := fun _ _ => toLeft_subset_toLeft\n"}
{"name":"Finset.toRight_monotone","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Monotone Finset.toRight","decl":"lemma toRight_monotone : Monotone (@toRight α β) := fun _ _ => toRight_subset_toRight\n\n"}
{"name":"Finset.toLeft_disjSum_toRight","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\nu : Finset (Sum α β)\n⊢ Eq (u.toLeft.disjSum u.toRight) u","decl":"lemma toLeft_disjSum_toRight : u.toLeft.disjSum u.toRight = u := by\n  ext (x | x) <;> simp\n\n"}
{"name":"Finset.card_toLeft_add_card_toRight","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\nu : Finset (Sum α β)\n⊢ Eq (HAdd.hAdd u.toLeft.card u.toRight.card) u.card","decl":"lemma card_toLeft_add_card_toRight : u.toLeft.card + u.toRight.card = u.card := by\n  rw [← card_disjSum, toLeft_disjSum_toRight]\n\n"}
{"name":"Finset.card_toLeft_le","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\nu : Finset (Sum α β)\n⊢ LE.le u.toLeft.card u.card","decl":"lemma card_toLeft_le : u.toLeft.card ≤ u.card :=\n  (Nat.le_add_right _ _).trans_eq card_toLeft_add_card_toRight\n\n"}
{"name":"Finset.card_toRight_le","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\nu : Finset (Sum α β)\n⊢ LE.le u.toRight.card u.card","decl":"lemma card_toRight_le : u.toRight.card ≤ u.card :=\n  (Nat.le_add_left _ _).trans_eq card_toLeft_add_card_toRight\n\n"}
{"name":"Finset.toLeft_disjSum","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\n⊢ Eq (s.disjSum t).toLeft s","decl":"@[simp] lemma toLeft_disjSum : (s.disjSum t).toLeft = s := by ext x; simp\n\n"}
{"name":"Finset.toRight_disjSum","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\n⊢ Eq (s.disjSum t).toRight t","decl":"@[simp] lemma toRight_disjSum : (s.disjSum t).toRight = t := by ext x; simp\n\n"}
{"name":"Finset.disjSum_eq_iff","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\nu : Finset (Sum α β)\n⊢ Iff (Eq (s.disjSum t) u) (And (Eq s u.toLeft) (Eq t u.toRight))","decl":"lemma disjSum_eq_iff : s.disjSum t = u ↔ s = u.toLeft ∧ t = u.toRight :=\n  ⟨fun h => by simp [← h], fun h => by simp [h, toLeft_disjSum_toRight]⟩\n\n"}
{"name":"Finset.eq_disjSum_iff","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\nu : Finset (Sum α β)\n⊢ Iff (Eq u (s.disjSum t)) (And (Eq u.toLeft s) (Eq u.toRight t))","decl":"lemma eq_disjSum_iff : u = s.disjSum t ↔ u.toLeft = s ∧ u.toRight = t :=\n  ⟨fun h => by simp [h], fun h => by simp [← h, toLeft_disjSum_toRight]⟩\n\n"}
{"name":"Finset.toLeft_map_sumComm","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\nu : Finset (Sum α β)\n⊢ Eq (Finset.map (Equiv.sumComm α β).toEmbedding u).toLeft u.toRight","decl":"@[simp] lemma toLeft_map_sumComm : (u.map (Equiv.sumComm _ _).toEmbedding).toLeft = u.toRight := by\n  ext x; simp\n\n"}
{"name":"Finset.toRight_map_sumComm","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\nu : Finset (Sum α β)\n⊢ Eq (Finset.map (Equiv.sumComm α β).toEmbedding u).toRight u.toLeft","decl":"@[simp] lemma toRight_map_sumComm : (u.map (Equiv.sumComm _ _).toEmbedding).toRight = u.toLeft := by\n  ext x; simp\n\n"}
{"name":"Finset.toLeft_cons_inl","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\na : α\nu : Finset (Sum α β)\nha : Not (Membership.mem u (Sum.inl a))\n⊢ Eq (Finset.cons (Sum.inl a) u ha).toLeft (Finset.cons a u.toLeft ⋯)","decl":"@[simp] lemma toLeft_cons_inl (ha) :\n    (cons (inl a) u ha).toLeft = cons a u.toLeft (by simpa) := by ext y; simp\n"}
{"name":"Finset.toLeft_cons_inr","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\nb : β\nu : Finset (Sum α β)\nhb : Not (Membership.mem u (Sum.inr b))\n⊢ Eq (Finset.cons (Sum.inr b) u hb).toLeft u.toLeft","decl":"@[simp] lemma toLeft_cons_inr (hb) :\n    (cons (inr b) u hb).toLeft = u.toLeft := by ext y; simp\n"}
{"name":"Finset.toRight_cons_inl","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\na : α\nu : Finset (Sum α β)\nha : Not (Membership.mem u (Sum.inl a))\n⊢ Eq (Finset.cons (Sum.inl a) u ha).toRight u.toRight","decl":"@[simp] lemma toRight_cons_inl (ha) :\n    (cons (inl a) u ha).toRight = u.toRight := by ext y; simp\n"}
{"name":"Finset.toRight_cons_inr","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\nb : β\nu : Finset (Sum α β)\nhb : Not (Membership.mem u (Sum.inr b))\n⊢ Eq (Finset.cons (Sum.inr b) u hb).toRight (Finset.cons b u.toRight ⋯)","decl":"@[simp] lemma toRight_cons_inr (hb) :\n    (cons (inr b) u hb).toRight = cons b u.toRight (by simpa) := by ext y; simp\n\n"}
{"name":"Finset.toLeft_image_swap","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\nu : Finset (Sum α β)\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\n⊢ Eq (Finset.image Sum.swap u).toLeft u.toRight","decl":"lemma toLeft_image_swap : (u.image Sum.swap).toLeft = u.toRight := by\n  ext x; simp\n\n"}
{"name":"Finset.toRight_image_swap","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\nu : Finset (Sum α β)\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\n⊢ Eq (Finset.image Sum.swap u).toRight u.toLeft","decl":"lemma toRight_image_swap : (u.image Sum.swap).toRight = u.toLeft := by\n  ext x; simp\n\n"}
{"name":"Finset.toLeft_insert_inl","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\na : α\nu : Finset (Sum α β)\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\n⊢ Eq (Insert.insert (Sum.inl a) u).toLeft (Insert.insert a u.toLeft)","decl":"@[simp] lemma toLeft_insert_inl : (insert (inl a) u).toLeft = insert a u.toLeft := by ext y; simp\n"}
{"name":"Finset.toLeft_insert_inr","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\nb : β\nu : Finset (Sum α β)\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\n⊢ Eq (Insert.insert (Sum.inr b) u).toLeft u.toLeft","decl":"@[simp] lemma toLeft_insert_inr : (insert (inr b) u).toLeft = u.toLeft := by ext y; simp\n"}
{"name":"Finset.toRight_insert_inl","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\na : α\nu : Finset (Sum α β)\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\n⊢ Eq (Insert.insert (Sum.inl a) u).toRight u.toRight","decl":"@[simp] lemma toRight_insert_inl : (insert (inl a) u).toRight = u.toRight := by ext y; simp\n"}
{"name":"Finset.toRight_insert_inr","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\nb : β\nu : Finset (Sum α β)\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\n⊢ Eq (Insert.insert (Sum.inr b) u).toRight (Insert.insert b u.toRight)","decl":"@[simp] lemma toRight_insert_inr : (insert (inr b) u).toRight = insert b u.toRight := by ext y; simp\n\n"}
{"name":"Finset.toLeft_inter","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\nu v : Finset (Sum α β)\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\n⊢ Eq (Inter.inter u v).toLeft (Inter.inter u.toLeft v.toLeft)","decl":"lemma toLeft_inter : (u ∩ v).toLeft = u.toLeft ∩ v.toLeft := by ext x; simp\n"}
{"name":"Finset.toRight_inter","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\nu v : Finset (Sum α β)\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\n⊢ Eq (Inter.inter u v).toRight (Inter.inter u.toRight v.toRight)","decl":"lemma toRight_inter : (u ∩ v).toRight = u.toRight ∩ v.toRight := by ext x; simp\n\n"}
{"name":"Finset.toLeft_union","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\nu v : Finset (Sum α β)\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\n⊢ Eq (Union.union u v).toLeft (Union.union u.toLeft v.toLeft)","decl":"lemma toLeft_union : (u ∪ v).toLeft = u.toLeft ∪ v.toLeft := by ext x; simp\n"}
{"name":"Finset.toRight_union","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\nu v : Finset (Sum α β)\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\n⊢ Eq (Union.union u v).toRight (Union.union u.toRight v.toRight)","decl":"lemma toRight_union : (u ∪ v).toRight = u.toRight ∪ v.toRight := by ext x; simp\n\n"}
{"name":"Finset.toLeft_sdiff","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\nu v : Finset (Sum α β)\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\n⊢ Eq (SDiff.sdiff u v).toLeft (SDiff.sdiff u.toLeft v.toLeft)","decl":"lemma toLeft_sdiff : (u \\ v).toLeft = u.toLeft \\ v.toLeft := by ext x; simp\n"}
{"name":"Finset.toRight_sdiff","module":"Mathlib.Data.Finset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\nu v : Finset (Sum α β)\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\n⊢ Eq (SDiff.sdiff u v).toRight (SDiff.sdiff u.toRight v.toRight)","decl":"lemma toRight_sdiff : (u \\ v).toRight = u.toRight \\ v.toRight := by ext x; simp\n\n"}
