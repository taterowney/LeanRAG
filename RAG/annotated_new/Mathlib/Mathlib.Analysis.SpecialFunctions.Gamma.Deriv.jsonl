{"name":"Complex.GammaIntegral_eq_mellin","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Deriv","initialProofState":"‚ä¢ Eq Complex.GammaIntegral (mellin fun x => ‚Üë(Real.exp (Neg.neg x)))","decl":"/-- Rewrite the Gamma integral as an example of a Mellin transform. -/\ntheorem GammaIntegral_eq_mellin : GammaIntegral = mellin fun x => ‚Üë(Real.exp (-x)) :=\n  funext fun s => by simp only [mellin, GammaIntegral, smul_eq_mul, mul_comm]\n\n"}
{"name":"Complex.hasDerivAt_GammaIntegral","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Deriv","initialProofState":"s : Complex\nhs : LT.lt 0 s.re\n‚ä¢ HasDerivAt Complex.GammaIntegral (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun t => HMul.hMul (HPow.hPow (‚Üët) (HSub.hSub s 1)) (HMul.hMul ‚Üë(Real.log t) ‚Üë(Real.exp (Neg.neg t)))) s","decl":"/-- The derivative of the `Œì` integral, at any `s ‚àà ‚ÑÇ` with `1 < re s`, is given by the Mellin\ntransform of `log t * exp (-t)`. -/\ntheorem hasDerivAt_GammaIntegral {s : ‚ÑÇ} (hs : 0 < s.re) :\n    HasDerivAt GammaIntegral (‚à´ t : ‚Ñù in Ioi 0, t ^ (s - 1) * (Real.log t * Real.exp (-t))) s := by\n  rw [GammaIntegral_eq_mellin]\n  convert (mellin_hasDerivAt_of_isBigO_rpow (E := ‚ÑÇ) _ _ (lt_add_one _) _ hs).2\n  ¬∑ refine (Continuous.continuousOn ?_).locallyIntegrableOn measurableSet_Ioi\n    exact continuous_ofReal.comp (Real.continuous_exp.comp continuous_neg)\n  ¬∑ rw [‚Üê isBigO_norm_left]\n    simp_rw [Complex.norm_eq_abs, abs_ofReal, ‚Üê Real.norm_eq_abs, isBigO_norm_left]\n    simpa only [neg_one_mul] using (isLittleO_exp_neg_mul_rpow_atTop zero_lt_one _).isBigO\n  ¬∑ simp_rw [neg_zero, rpow_zero]\n    refine isBigO_const_of_tendsto (?_ : Tendsto _ _ (ùìù (1 : ‚ÑÇ))) one_ne_zero\n    rw [(by simp : (1 : ‚ÑÇ) = Real.exp (-0))]\n    exact (continuous_ofReal.comp (Real.continuous_exp.comp continuous_neg)).continuousWithinAt\n\n"}
{"name":"Complex.differentiableAt_GammaAux","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Deriv","initialProofState":"s : Complex\nn : Nat\nh1 : LT.lt (HSub.hSub 1 s.re) ‚Üën\nh2 : ‚àÄ (m : Nat), Ne s (Neg.neg ‚Üëm)\n‚ä¢ DifferentiableAt Complex (Complex.GammaAux n) s","decl":"theorem differentiableAt_GammaAux (s : ‚ÑÇ) (n : ‚Ñï) (h1 : 1 - s.re < n) (h2 : ‚àÄ m : ‚Ñï, s ‚â† -m) :\n    DifferentiableAt ‚ÑÇ (GammaAux n) s := by\n  induction' n with n hn generalizing s\n  ¬∑ refine (hasDerivAt_GammaIntegral ?_).differentiableAt\n    rw [Nat.cast_zero] at h1; linarith\n  ¬∑ dsimp only [GammaAux]\n    specialize hn (s + 1)\n    have a : 1 - (s + 1).re < ‚Üën := by\n      rw [Nat.cast_succ] at h1; rw [Complex.add_re, Complex.one_re]; linarith\n    have b : ‚àÄ m : ‚Ñï, s + 1 ‚â† -m := by\n      intro m; have := h2 (1 + m)\n      contrapose! this\n      rw [‚Üê eq_sub_iff_add_eq] at this\n      simpa using this\n    refine DifferentiableAt.div (DifferentiableAt.comp _ (hn a b) ?_) ?_ ?_\n    ¬∑ rw [differentiableAt_add_const_iff (1 : ‚ÑÇ)]; exact differentiableAt_id\n    ¬∑ exact differentiableAt_id\n    ¬∑ simpa using h2 0\n\n"}
{"name":"Complex.differentiableAt_Gamma","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Deriv","initialProofState":"s : Complex\nhs : ‚àÄ (m : Nat), Ne s (Neg.neg ‚Üëm)\n‚ä¢ DifferentiableAt Complex Complex.Gamma s","decl":"theorem differentiableAt_Gamma (s : ‚ÑÇ) (hs : ‚àÄ m : ‚Ñï, s ‚â† -m) : DifferentiableAt ‚ÑÇ Gamma s := by\n  let n := ‚åä1 - s.re‚åã‚Çä + 1\n  have hn : 1 - s.re < n := mod_cast Nat.lt_floor_add_one (1 - s.re)\n  apply (differentiableAt_GammaAux s n hn hs).congr_of_eventuallyEq\n  let S := {t : ‚ÑÇ | 1 - t.re < n}\n  have : S ‚àà ùìù s := by\n    rw [mem_nhds_iff]; use S\n    refine ‚ü®Subset.rfl, ?_, hn‚ü©\n    have : S = re ‚Åª¬π' Ioi (1 - n : ‚Ñù) := by\n      ext; rw [preimage, Ioi, mem_setOf_eq, mem_setOf_eq, mem_setOf_eq]; exact sub_lt_comm\n    rw [this]\n    exact Continuous.isOpen_preimage continuous_re _ isOpen_Ioi\n  apply eventuallyEq_of_mem this\n  intro t ht; rw [mem_setOf_eq] at ht\n  apply Gamma_eq_GammaAux; linarith\n\n"}
{"name":"Complex.tendsto_self_mul_Gamma_nhds_zero","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Deriv","initialProofState":"‚ä¢ Filter.Tendsto (fun z => HMul.hMul z (Complex.Gamma z)) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))) (nhds 1)","decl":"/-- At `s = 0`, the Gamma function has a simple pole with residue 1. -/\ntheorem tendsto_self_mul_Gamma_nhds_zero : Tendsto (fun z : ‚ÑÇ => z * Gamma z) (ùìù[‚â†] 0) (ùìù 1) := by\n  rw [show ùìù (1 : ‚ÑÇ) = ùìù (Gamma (0 + 1)) by simp only [zero_add, Complex.Gamma_one]]\n  convert (Tendsto.mono_left _ nhdsWithin_le_nhds).congr'\n    (eventuallyEq_of_mem self_mem_nhdsWithin Complex.Gamma_add_one) using 1\n  refine ContinuousAt.comp (g := Gamma) ?_ (continuous_id.add continuous_const).continuousAt\n  refine (Complex.differentiableAt_Gamma _ fun m => ?_).continuousAt\n  rw [zero_add, ‚Üê ofReal_natCast, ‚Üê ofReal_neg, ‚Üê ofReal_one, Ne, ofReal_inj]\n  refine (lt_of_le_of_lt ?_ zero_lt_one).ne'\n  exact neg_nonpos.mpr (Nat.cast_nonneg _)\n\n"}
{"name":"Real.differentiableAt_Gamma","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Deriv","initialProofState":"s : Real\nhs : ‚àÄ (m : Nat), Ne s (Neg.neg ‚Üëm)\n‚ä¢ DifferentiableAt Real Real.Gamma s","decl":"theorem differentiableAt_Gamma {s : ‚Ñù} (hs : ‚àÄ m : ‚Ñï, s ‚â† -m) : DifferentiableAt ‚Ñù Gamma s := by\n  refine (Complex.differentiableAt_Gamma _ ?_).hasDerivAt.real_of_complex.differentiableAt\n  simp_rw [‚Üê Complex.ofReal_natCast, ‚Üê Complex.ofReal_neg, Ne, Complex.ofReal_inj]\n  exact hs\n\n"}
