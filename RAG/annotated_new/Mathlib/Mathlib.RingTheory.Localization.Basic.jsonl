{"name":"Localization.mapPiEvalRingHom_bijective","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"ι : Type u_1\nR : ι → Type u_2\ninst✝ : (i : ι) → CommSemiring (R i)\ni : ι\nS : Submonoid (R i)\n⊢ Function.Bijective ⇑(Localization.mapPiEvalRingHom S)","decl":"open Function in\ntheorem mapPiEvalRingHom_bijective : Bijective (mapPiEvalRingHom S) := by\n  let T := S.comap (Pi.evalRingHom R i)\n  classical\n  refine ⟨fun x₁ x₂ eq ↦ ?_, fun x ↦ ?_⟩\n  · obtain ⟨r₁, s₁, rfl⟩ := mk'_surjective T x₁\n    obtain ⟨r₂, s₂, rfl⟩ := mk'_surjective T x₂\n    simp_rw [map_mk'] at eq\n    rw [IsLocalization.eq] at eq ⊢\n    obtain ⟨s, hs⟩ := eq\n    refine ⟨⟨update 0 i s, by apply update_self i s.1 0 ▸ s.2⟩, funext fun j ↦ ?_⟩\n    obtain rfl | ne := eq_or_ne j i\n    · simpa using hs\n    · simp [update_of_ne ne]\n  · obtain ⟨r, s, rfl⟩ := mk'_surjective S x\n    exact ⟨mk' (M := T) _ (update 0 i r) ⟨update 0 i s, by apply update_self i s.1 0 ▸ s.2⟩,\n      by simp [map_mk']⟩\n\n"}
{"name":"IsLocalization.linearMap_compatibleSMul","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"R : Type u_1\ninst✝¹¹ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝¹⁰ : CommSemiring S\ninst✝⁹ : Algebra R S\ninst✝⁸ : IsLocalization M S\nN₁ : Type u_4\nN₂ : Type u_5\ninst✝⁷ : AddCommMonoid N₁\ninst✝⁶ : AddCommMonoid N₂\ninst✝⁵ : Module R N₁\ninst✝⁴ : Module S N₁\ninst✝³ : Module R N₂\ninst✝² : Module S N₂\ninst✝¹ : IsScalarTower R S N₁\ninst✝ : IsScalarTower R S N₂\n⊢ LinearMap.CompatibleSMul N₁ N₂ S R","decl":"variable (M S) in\ninclude M in\ntheorem linearMap_compatibleSMul (N₁ N₂) [AddCommMonoid N₁] [AddCommMonoid N₂] [Module R N₁]\n    [Module S N₁] [Module R N₂] [Module S N₂] [IsScalarTower R S N₁] [IsScalarTower R S N₂] :\n    LinearMap.CompatibleSMul N₁ N₂ S R where\n  map_smul f s s' := by\n    obtain ⟨r, m, rfl⟩ := mk'_surjective M s\n    rw [← (map_units S m).smul_left_cancel]\n    simp_rw [algebraMap_smul, ← map_smul, ← smul_assoc, smul_mk'_self, algebraMap_smul, map_smul]\n\n"}
{"name":"IsLocalization.algHom_subsingleton","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝⁴ : CommSemiring S\ninst✝³ : Algebra R S\nP : Type u_3\ninst✝² : CommSemiring P\ninst✝¹ : IsLocalization M S\ninst✝ : Algebra R P\n⊢ Subsingleton (AlgHom R S P)","decl":"variable (M) in\ninclude M in\n/- This is not an instance because the submonoid `M` would become a metavariable\n  in typeclass search. -/\ntheorem algHom_subsingleton [Algebra R P] : Subsingleton (S →ₐ[R] P) :=\n  ⟨fun f g =>\n    AlgHom.coe_ringHom_injective <|\n      IsLocalization.ringHom_ext M <| by rw [f.comp_algebraMap, g.comp_algebraMap]⟩\n\n"}
{"name":"IsLocalization.algEquiv_apply","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra R S\ninst✝³ : IsLocalization M S\nQ : Type u_4\ninst✝² : CommSemiring Q\ninst✝¹ : Algebra R Q\ninst✝ : IsLocalization M Q\na : S\n⊢ Eq ((IsLocalization.algEquiv M S Q) a) ((IsLocalization.map Q (RingHom.id R) ⋯) a)","decl":"/-- If `S`, `Q` are localizations of `R` at the submonoid `M` respectively,\nthere is an isomorphism of localizations `S ≃ₐ[R] Q`. -/\n@[simps!]\nnoncomputable def algEquiv : S ≃ₐ[R] Q :=\n  { ringEquivOfRingEquiv S Q (RingEquiv.refl R) M.map_id with\n    commutes' := ringEquivOfRingEquiv_eq _ }\n\n"}
{"name":"IsLocalization.algEquiv_symm_apply","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra R S\ninst✝³ : IsLocalization M S\nQ : Type u_4\ninst✝² : CommSemiring Q\ninst✝¹ : Algebra R Q\ninst✝ : IsLocalization M Q\na : Q\n⊢ Eq ((IsLocalization.algEquiv M S Q).symm a) ((IsLocalization.map S (RingHom.id R) ⋯) a)","decl":"/-- If `S`, `Q` are localizations of `R` at the submonoid `M` respectively,\nthere is an isomorphism of localizations `S ≃ₐ[R] Q`. -/\n@[simps!]\nnoncomputable def algEquiv : S ≃ₐ[R] Q :=\n  { ringEquivOfRingEquiv S Q (RingEquiv.refl R) M.map_id with\n    commutes' := ringEquivOfRingEquiv_eq _ }\n\n"}
{"name":"IsLocalization.algEquiv_mk'","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra R S\ninst✝³ : IsLocalization M S\nQ : Type u_4\ninst✝² : CommSemiring Q\ninst✝¹ : Algebra R Q\ninst✝ : IsLocalization M Q\nx : R\ny : Subtype fun x => Membership.mem M x\n⊢ Eq ((IsLocalization.algEquiv M S Q) (IsLocalization.mk' S x y)) (IsLocalization.mk' Q x y)","decl":"theorem algEquiv_mk' (x : R) (y : M) : algEquiv M S Q (mk' S x y) = mk' Q x y := by\n  simp\n\n"}
{"name":"IsLocalization.algEquiv_symm_mk'","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra R S\ninst✝³ : IsLocalization M S\nQ : Type u_4\ninst✝² : CommSemiring Q\ninst✝¹ : Algebra R Q\ninst✝ : IsLocalization M Q\nx : R\ny : Subtype fun x => Membership.mem M x\n⊢ Eq ((IsLocalization.algEquiv M S Q).symm (IsLocalization.mk' Q x y)) (IsLocalization.mk' S x y)","decl":"theorem algEquiv_symm_mk' (x : R) (y : M) : (algEquiv M S Q).symm (mk' Q x y) = mk' S x y := by simp\n\n"}
{"name":"IsLocalization.bijective","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra R S\ninst✝³ : IsLocalization M S\nQ : Type u_4\ninst✝² : CommSemiring Q\ninst✝¹ : Algebra R Q\ninst✝ : IsLocalization M Q\nf : RingHom S Q\nhf : Eq (f.comp (algebraMap R S)) (algebraMap R Q)\n⊢ Function.Bijective ⇑f","decl":"variable (M) in\ninclude M in\nprotected lemma bijective (f : S →+* Q) (hf : f.comp (algebraMap R S) = algebraMap R Q) :\n    Function.Bijective f :=\n  (show f = IsLocalization.algEquiv M S Q by\n    apply IsLocalization.ringHom_ext M; rw [hf]; ext; simp) ▸\n    (IsLocalization.algEquiv M S Q).toEquiv.bijective\n\n"}
{"name":"IsLocalization.liftAlgHom_toRingHom","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"A : Type u_4\ninst✝⁹ : CommSemiring A\nR : Type u_5\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Algebra A R\nM : Submonoid R\nS : Type u_6\ninst✝⁶ : CommSemiring S\ninst✝⁵ : Algebra A S\ninst✝⁴ : Algebra R S\ninst✝³ : IsScalarTower A R S\nP : Type u_7\ninst✝² : CommSemiring P\ninst✝¹ : Algebra A P\ninst✝ : IsLocalization M S\nf : AlgHom A R P\nhf : ∀ (y : Subtype fun x => Membership.mem M x), IsUnit (f ↑y)\n⊢ Eq (IsLocalization.liftAlgHom hf).toRingHom (IsLocalization.lift hf)","decl":"theorem liftAlgHom_toRingHom : (liftAlgHom hf : S →ₐ[A] P).toRingHom = lift hf := rfl\n\n"}
{"name":"IsLocalization.coe_liftAlgHom","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"A : Type u_4\ninst✝⁹ : CommSemiring A\nR : Type u_5\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Algebra A R\nM : Submonoid R\nS : Type u_6\ninst✝⁶ : CommSemiring S\ninst✝⁵ : Algebra A S\ninst✝⁴ : Algebra R S\ninst✝³ : IsScalarTower A R S\nP : Type u_7\ninst✝² : CommSemiring P\ninst✝¹ : Algebra A P\ninst✝ : IsLocalization M S\nf : AlgHom A R P\nhf : ∀ (y : Subtype fun x => Membership.mem M x), IsUnit (f ↑y)\n⊢ Eq ⇑(IsLocalization.liftAlgHom hf) ⇑(IsLocalization.lift hf)","decl":"@[simp]\ntheorem coe_liftAlgHom : ⇑(liftAlgHom hf : S →ₐ[A] P) = lift hf := rfl\n\n"}
{"name":"IsLocalization.liftAlgHom_apply","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"A : Type u_4\ninst✝⁹ : CommSemiring A\nR : Type u_5\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Algebra A R\nM : Submonoid R\nS : Type u_6\ninst✝⁶ : CommSemiring S\ninst✝⁵ : Algebra A S\ninst✝⁴ : Algebra R S\ninst✝³ : IsScalarTower A R S\nP : Type u_7\ninst✝² : CommSemiring P\ninst✝¹ : Algebra A P\ninst✝ : IsLocalization M S\nf : AlgHom A R P\nhf : ∀ (y : Subtype fun x => Membership.mem M x), IsUnit (f ↑y)\nx : S\n⊢ Eq ((IsLocalization.liftAlgHom hf) x) ((IsLocalization.lift hf) x)","decl":"theorem liftAlgHom_apply : liftAlgHom hf x = lift hf x := rfl\n\n"}
{"name":"IsLocalization.algEquivOfAlgEquiv_symm_apply","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"A : Type u_4\ninst✝¹² : CommSemiring A\nR : Type u_5\ninst✝¹¹ : CommSemiring R\ninst✝¹⁰ : Algebra A R\nM : Submonoid R\nS : Type u_6\ninst✝⁹ : CommSemiring S\ninst✝⁸ : Algebra A S\ninst✝⁷ : Algebra R S\ninst✝⁶ : IsLocalization M S\nP : Type u_7\ninst✝⁵ : CommSemiring P\ninst✝⁴ : Algebra A P\nT : Submonoid P\nQ : Type u_8\ninst✝³ : CommSemiring Q\ninst✝² : Algebra A Q\ninst✝¹ : Algebra P Q\ninst✝ : IsLocalization T Q\nh : AlgEquiv A R P\nH : Eq (Submonoid.map h M) T\na : Q\n⊢ Eq ((IsLocalization.algEquivOfAlgEquiv S Q h H).symm a) ((IsLocalization.map S ↑(↑h).symm ⋯) a)","decl":"/-- If `S`, `Q` are localizations of `R` and `P` at submonoids `M`, `T` respectively,\nan isomorphism `h : R ≃ₐ[A] P` such that `h(M) = T` induces an isomorphism of localizations\n`S ≃ₐ[A] Q`. -/\n@[simps!]\nnoncomputable def algEquivOfAlgEquiv : S ≃ₐ[A] Q where\n  __ := ringEquivOfRingEquiv S Q h.toRingEquiv H\n  commutes' _ := by dsimp; rw [IsScalarTower.algebraMap_apply A R S, map_eq,\n    RingHom.coe_coe, AlgEquiv.commutes, IsScalarTower.algebraMap_apply A P Q]\n\n"}
{"name":"IsLocalization.algEquivOfAlgEquiv_apply","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"A : Type u_4\ninst✝¹² : CommSemiring A\nR : Type u_5\ninst✝¹¹ : CommSemiring R\ninst✝¹⁰ : Algebra A R\nM : Submonoid R\nS : Type u_6\ninst✝⁹ : CommSemiring S\ninst✝⁸ : Algebra A S\ninst✝⁷ : Algebra R S\ninst✝⁶ : IsLocalization M S\nP : Type u_7\ninst✝⁵ : CommSemiring P\ninst✝⁴ : Algebra A P\nT : Submonoid P\nQ : Type u_8\ninst✝³ : CommSemiring Q\ninst✝² : Algebra A Q\ninst✝¹ : Algebra P Q\ninst✝ : IsLocalization T Q\nh : AlgEquiv A R P\nH : Eq (Submonoid.map h M) T\na : S\n⊢ Eq ((IsLocalization.algEquivOfAlgEquiv S Q h H) a) ((IsLocalization.map Q ↑h ⋯) a)","decl":"/-- If `S`, `Q` are localizations of `R` and `P` at submonoids `M`, `T` respectively,\nan isomorphism `h : R ≃ₐ[A] P` such that `h(M) = T` induces an isomorphism of localizations\n`S ≃ₐ[A] Q`. -/\n@[simps!]\nnoncomputable def algEquivOfAlgEquiv : S ≃ₐ[A] Q where\n  __ := ringEquivOfRingEquiv S Q h.toRingEquiv H\n  commutes' _ := by dsimp; rw [IsScalarTower.algebraMap_apply A R S, map_eq,\n    RingHom.coe_coe, AlgEquiv.commutes, IsScalarTower.algebraMap_apply A P Q]\n\n"}
{"name":"IsLocalization.algEquivOfAlgEquiv_eq_map","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"A : Type u_4\ninst✝¹⁴ : CommSemiring A\nR : Type u_5\ninst✝¹³ : CommSemiring R\ninst✝¹² : Algebra A R\nM : Submonoid R\nS : Type u_6\ninst✝¹¹ : CommSemiring S\ninst✝¹⁰ : Algebra A S\ninst✝⁹ : Algebra R S\ninst✝⁸ : IsScalarTower A R S\ninst✝⁷ : IsLocalization M S\nP : Type u_7\ninst✝⁶ : CommSemiring P\ninst✝⁵ : Algebra A P\nT : Submonoid P\nQ : Type u_8\ninst✝⁴ : CommSemiring Q\ninst✝³ : Algebra A Q\ninst✝² : Algebra P Q\ninst✝¹ : IsScalarTower A P Q\ninst✝ : IsLocalization T Q\nh : AlgEquiv A R P\nH : Eq (Submonoid.map h M) T\n⊢ Eq (↑(IsLocalization.algEquivOfAlgEquiv S Q h H)) (IsLocalization.map Q ↑h ⋯)","decl":"theorem algEquivOfAlgEquiv_eq_map :\n    (algEquivOfAlgEquiv S Q h H : S →+* Q) =\n      map Q (h : R →+* P) (M.le_comap_of_map_le (le_of_eq H)) :=\n  rfl\n\n"}
{"name":"IsLocalization.algEquivOfAlgEquiv_eq","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"A : Type u_4\ninst✝¹⁴ : CommSemiring A\nR : Type u_5\ninst✝¹³ : CommSemiring R\ninst✝¹² : Algebra A R\nM : Submonoid R\nS : Type u_6\ninst✝¹¹ : CommSemiring S\ninst✝¹⁰ : Algebra A S\ninst✝⁹ : Algebra R S\ninst✝⁸ : IsScalarTower A R S\ninst✝⁷ : IsLocalization M S\nP : Type u_7\ninst✝⁶ : CommSemiring P\ninst✝⁵ : Algebra A P\nT : Submonoid P\nQ : Type u_8\ninst✝⁴ : CommSemiring Q\ninst✝³ : Algebra A Q\ninst✝² : Algebra P Q\ninst✝¹ : IsScalarTower A P Q\ninst✝ : IsLocalization T Q\nh : AlgEquiv A R P\nH : Eq (Submonoid.map h M) T\nx : R\n⊢ Eq ((IsLocalization.algEquivOfAlgEquiv S Q h H) ((algebraMap R S) x)) ((algebraMap P Q) (h x))","decl":"theorem algEquivOfAlgEquiv_eq (x : R) :\n    algEquivOfAlgEquiv S Q h H ((algebraMap R S) x) = algebraMap P Q (h x) := by\n  simp\n\n"}
{"name":"IsLocalization.algEquivOfAlgEquiv_mk'","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"A : Type u_4\ninst✝¹⁴ : CommSemiring A\nR : Type u_5\ninst✝¹³ : CommSemiring R\ninst✝¹² : Algebra A R\nM : Submonoid R\nS : Type u_6\ninst✝¹¹ : CommSemiring S\ninst✝¹⁰ : Algebra A S\ninst✝⁹ : Algebra R S\ninst✝⁸ : IsScalarTower A R S\ninst✝⁷ : IsLocalization M S\nP : Type u_7\ninst✝⁶ : CommSemiring P\ninst✝⁵ : Algebra A P\nT : Submonoid P\nQ : Type u_8\ninst✝⁴ : CommSemiring Q\ninst✝³ : Algebra A Q\ninst✝² : Algebra P Q\ninst✝¹ : IsScalarTower A P Q\ninst✝ : IsLocalization T Q\nh : AlgEquiv A R P\nH : Eq (Submonoid.map h M) T\nx : R\ny : Subtype fun x => Membership.mem M x\n⊢ Eq ((IsLocalization.algEquivOfAlgEquiv S Q h H) (IsLocalization.mk' S x y)) (IsLocalization.mk' Q (h x) ⟨h ↑y, ⋯⟩)","decl":"set_option linter.docPrime false in\ntheorem algEquivOfAlgEquiv_mk' (x : R) (y : M) :\n    algEquivOfAlgEquiv S Q h H (mk' S x y) =\n      mk' Q (h x) ⟨h y, show h y ∈ T from H ▸ Set.mem_image_of_mem h y.2⟩ := by\n  simp [map_mk']\n\n"}
{"name":"IsLocalization.algEquivOfAlgEquiv_symm","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"A : Type u_4\ninst✝¹⁴ : CommSemiring A\nR : Type u_5\ninst✝¹³ : CommSemiring R\ninst✝¹² : Algebra A R\nM : Submonoid R\nS : Type u_6\ninst✝¹¹ : CommSemiring S\ninst✝¹⁰ : Algebra A S\ninst✝⁹ : Algebra R S\ninst✝⁸ : IsScalarTower A R S\ninst✝⁷ : IsLocalization M S\nP : Type u_7\ninst✝⁶ : CommSemiring P\ninst✝⁵ : Algebra A P\nT : Submonoid P\nQ : Type u_8\ninst✝⁴ : CommSemiring Q\ninst✝³ : Algebra A Q\ninst✝² : Algebra P Q\ninst✝¹ : IsScalarTower A P Q\ninst✝ : IsLocalization T Q\nh : AlgEquiv A R P\nH : Eq (Submonoid.map h M) T\n⊢ Eq (IsLocalization.algEquivOfAlgEquiv S Q h H).symm (IsLocalization.algEquivOfAlgEquiv Q S h.symm ⋯)","decl":"theorem algEquivOfAlgEquiv_symm : (algEquivOfAlgEquiv S Q h H).symm =\n    algEquivOfAlgEquiv Q S h.symm (show Submonoid.map h.symm T = M by\n      erw [← H, ← Submonoid.comap_equiv_eq_map_symm,\n        Submonoid.comap_map_eq_of_injective h.injective]) := rfl\n\n"}
{"name":"IsLocalization.isLocalization_of_algEquiv","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝⁴ : CommSemiring S\ninst✝³ : Algebra R S\nP : Type u_3\ninst✝² : CommSemiring P\ninst✝¹ : Algebra R P\ninst✝ : IsLocalization M S\nh : AlgEquiv R S P\n⊢ IsLocalization M P","decl":"theorem isLocalization_of_algEquiv [Algebra R P] [IsLocalization M S] (h : S ≃ₐ[R] P) :\n    IsLocalization M P := by\n  constructor\n  · intro y\n    convert (IsLocalization.map_units S y).map h.toAlgHom.toRingHom.toMonoidHom\n    exact (h.commutes y).symm\n  · intro y\n    obtain ⟨⟨x, s⟩, e⟩ := IsLocalization.surj M (h.symm y)\n    apply_fun (show S → P from h) at e\n    simp only [map_mul, h.apply_symm_apply, h.commutes] at e\n    exact ⟨⟨x, s⟩, e⟩\n  · intro x y\n    rw [← h.symm.toEquiv.injective.eq_iff, ← IsLocalization.eq_iff_exists M S, ← h.symm.commutes, ←\n      h.symm.commutes]\n    exact id\n\n"}
{"name":"IsLocalization.isLocalization_iff_of_algEquiv","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝³ : CommSemiring S\ninst✝² : Algebra R S\nP : Type u_3\ninst✝¹ : CommSemiring P\ninst✝ : Algebra R P\nh : AlgEquiv R S P\n⊢ Iff (IsLocalization M S) (IsLocalization M P)","decl":"theorem isLocalization_iff_of_algEquiv [Algebra R P] (h : S ≃ₐ[R] P) :\n    IsLocalization M S ↔ IsLocalization M P :=\n  ⟨fun _ => isLocalization_of_algEquiv M h, fun _ => isLocalization_of_algEquiv M h.symm⟩\n\n"}
{"name":"IsLocalization.isLocalization_iff_of_ringEquiv","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nP : Type u_3\ninst✝ : CommSemiring P\nh : RingEquiv S P\n⊢ Iff (IsLocalization M S) (IsLocalization M P)","decl":"theorem isLocalization_iff_of_ringEquiv (h : S ≃+* P) :\n    IsLocalization M S ↔\n      haveI := (h.toRingHom.comp <| algebraMap R S).toAlgebra; IsLocalization M P :=\n  letI := (h.toRingHom.comp <| algebraMap R S).toAlgebra\n  isLocalization_iff_of_algEquiv M { h with commutes' := fun _ => rfl }\n\n"}
{"name":"IsLocalization.isLocalization_iff_of_isLocalization","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM N : Submonoid R\nS : Type u_2\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra R S\nP : Type u_3\ninst✝³ : CommSemiring P\ninst✝² : IsLocalization M S\ninst✝¹ : IsLocalization N S\ninst✝ : Algebra R P\n⊢ Iff (IsLocalization M P) (IsLocalization N P)","decl":"variable (S) in\n/-- If an algebra is simultaneously localizations for two submonoids, then an arbitrary algebra\nis a localization of one submonoid iff it is a localization of the other. -/\ntheorem isLocalization_iff_of_isLocalization [IsLocalization M S] [IsLocalization N S]\n    [Algebra R P] : IsLocalization M P ↔ IsLocalization N P :=\n  ⟨fun _ ↦ isLocalization_of_algEquiv N (algEquiv M S P),\n    fun _ ↦ isLocalization_of_algEquiv M (algEquiv N S P)⟩\n\n"}
{"name":"IsLocalization.iff_of_le_of_exists_dvd","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\nN : Submonoid R\nh₁ : LE.le M N\nh₂ : ∀ (n : R), Membership.mem N n → Exists fun m => And (Membership.mem M m) (Dvd.dvd n m)\n⊢ Iff (IsLocalization M S) (IsLocalization N S)","decl":"theorem iff_of_le_of_exists_dvd (N : Submonoid R) (h₁ : M ≤ N) (h₂ : ∀ n ∈ N, ∃ m ∈ M, n ∣ m) :\n    IsLocalization M S ↔ IsLocalization N S :=\n  have : IsLocalization N (Localization M) := of_le_of_exists_dvd _ _ h₁ h₂\n  isLocalization_iff_of_isLocalization _ _ (Localization M)\n\n"}
{"name":"IsLocalization.commutes","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"R : Type u_1\ninst✝¹³ : CommSemiring R\nS₁ : Type u_4\nS₂ : Type u_5\nT : Type u_6\ninst✝¹² : CommSemiring S₁\ninst✝¹¹ : CommSemiring S₂\ninst✝¹⁰ : CommSemiring T\ninst✝⁹ : Algebra R S₁\ninst✝⁸ : Algebra R S₂\ninst✝⁷ : Algebra R T\ninst✝⁶ : Algebra S₁ T\ninst✝⁵ : Algebra S₂ T\ninst✝⁴ : IsScalarTower R S₁ T\ninst✝³ : IsScalarTower R S₂ T\nM₁ M₂ : Submonoid R\ninst✝² : IsLocalization M₁ S₁\ninst✝¹ : IsLocalization M₂ S₂\ninst✝ : IsLocalization (Algebra.algebraMapSubmonoid S₂ M₁) T\n⊢ IsLocalization (Algebra.algebraMapSubmonoid S₁ M₂) T","decl":"/-- If `S₁` is the localization of `R` at `M₁` and `S₂` is the localization of\n`R` at `M₂`, then every localization `T` of `S₂` at `M₁` is also a localization of\n`S₁` at `M₂`, in other words `M₁⁻¹M₂⁻¹R` can be identified with `M₂⁻¹M₁⁻¹R`. -/\nlemma commutes (S₁ S₂ T : Type*) [CommSemiring S₁]\n    [CommSemiring S₂] [CommSemiring T] [Algebra R S₁] [Algebra R S₂] [Algebra R T] [Algebra S₁ T]\n    [Algebra S₂ T] [IsScalarTower R S₁ T] [IsScalarTower R S₂ T] (M₁ M₂ : Submonoid R)\n    [IsLocalization M₁ S₁] [IsLocalization M₂ S₂]\n    [IsLocalization (Algebra.algebraMapSubmonoid S₂ M₁) T] :\n    IsLocalization (Algebra.algebraMapSubmonoid S₁ M₂) T where\n  map_units' := by\n    rintro ⟨m, ⟨a, ha, rfl⟩⟩\n    rw [← IsScalarTower.algebraMap_apply, IsScalarTower.algebraMap_apply R S₂ T]\n    exact IsUnit.map _ (IsLocalization.map_units' ⟨a, ha⟩)\n  surj' a := by\n    obtain ⟨⟨y, -, m, hm, rfl⟩, hy⟩ := surj (M := Algebra.algebraMapSubmonoid S₂ M₁) a\n    rw [← IsScalarTower.algebraMap_apply, IsScalarTower.algebraMap_apply R S₁ T] at hy\n    obtain ⟨⟨z, n, hn⟩, hz⟩ := IsLocalization.surj (M := M₂) y\n    have hunit : IsUnit (algebraMap R S₁ m) := map_units' ⟨m, hm⟩\n    use ⟨algebraMap R S₁ z * hunit.unit⁻¹, ⟨algebraMap R S₁ n, n, hn, rfl⟩⟩\n    rw [map_mul, ← IsScalarTower.algebraMap_apply, IsScalarTower.algebraMap_apply R S₂ T]\n    conv_rhs => rw [← IsScalarTower.algebraMap_apply]\n    rw [IsScalarTower.algebraMap_apply R S₂ T, ← hz, map_mul, ← hy]\n    convert_to _ = a * (algebraMap S₂ T) ((algebraMap R S₂) n) *\n        (algebraMap S₁ T) (((algebraMap R S₁) m) * hunit.unit⁻¹.val)\n    · rw [map_mul]\n      ring\n    simp\n  exists_of_eq {x y} hxy := by\n    obtain ⟨r, s, d, hr, hs⟩ := IsLocalization.surj₂ M₁ S₁ x y\n    apply_fun (· * algebraMap S₁ T (algebraMap R S₁ d)) at hxy\n    simp_rw [← map_mul, hr, hs, ← IsScalarTower.algebraMap_apply,\n      IsScalarTower.algebraMap_apply R S₂ T] at hxy\n    obtain ⟨⟨-, c, hmc, rfl⟩, hc⟩ := exists_of_eq (M := Algebra.algebraMapSubmonoid S₂ M₁) hxy\n    simp_rw [← map_mul] at hc\n    obtain ⟨a, ha⟩ := IsLocalization.exists_of_eq (M := M₂) hc\n    use ⟨algebraMap R S₁ a, a, a.property, rfl⟩\n    apply (map_units S₁ d).mul_right_cancel\n    rw [mul_assoc, hr, mul_assoc, hs]\n    apply (map_units S₁ ⟨c, hmc⟩).mul_right_cancel\n    rw [← map_mul, ← map_mul, mul_assoc, mul_comm _ c, ha, map_mul, map_mul]\n    ring\n\n"}
{"name":"Localization.mk_natCast","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nM : Submonoid R\nm : Nat\n⊢ Eq (Localization.mk (↑m) 1) ↑m","decl":"theorem mk_natCast (m : ℕ) : (mk m 1 : Localization M) = m := by\n  simpa using mk_algebraMap (R := R) (A := ℕ) _\n\n"}
{"name":"Localization.algEquiv_apply","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\na : Localization M\n⊢ Eq ((Localization.algEquiv M S) a) ((IsLocalization.map S (RingHom.id R) ⋯) a)","decl":"/-- The localization of `R` at `M` as a quotient type is isomorphic to any other localization. -/\n@[simps!]\nnoncomputable def algEquiv : Localization M ≃ₐ[R] S :=\n  IsLocalization.algEquiv M _ _\n\n"}
{"name":"Localization.algEquiv_symm_apply","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\na : S\n⊢ Eq ((Localization.algEquiv M S).symm a) ((IsLocalization.map (Localization M) (RingHom.id R) ⋯) a)","decl":"/-- The localization of `R` at `M` as a quotient type is isomorphic to any other localization. -/\n@[simps!]\nnoncomputable def algEquiv : Localization M ≃ₐ[R] S :=\n  IsLocalization.algEquiv M _ _\n\n"}
{"name":"Localization.algEquiv_mk'","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx : R\ny : Subtype fun x => Membership.mem M x\n⊢ Eq ((Localization.algEquiv M S) (IsLocalization.mk' (Localization M) x y)) (IsLocalization.mk' S x y)","decl":"nonrec theorem algEquiv_mk' (x : R) (y : M) : algEquiv M S (mk' (Localization M) x y) = mk' S x y :=\n  algEquiv_mk' _ _\n\n"}
{"name":"Localization.algEquiv_symm_mk'","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx : R\ny : Subtype fun x => Membership.mem M x\n⊢ Eq ((Localization.algEquiv M S).symm (IsLocalization.mk' S x y)) (IsLocalization.mk' (Localization M) x y)","decl":"nonrec theorem algEquiv_symm_mk' (x : R) (y : M) :\n    (algEquiv M S).symm (mk' S x y) = mk' (Localization M) x y :=\n  algEquiv_symm_mk' _ _\n\n"}
{"name":"Localization.algEquiv_mk","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx : R\ny : Subtype fun x => Membership.mem M x\n⊢ Eq ((Localization.algEquiv M S) (Localization.mk x y)) (IsLocalization.mk' S x y)","decl":"theorem algEquiv_mk (x y) : algEquiv M S (mk x y) = mk' S x y := by rw [mk_eq_mk', algEquiv_mk']\n\n"}
{"name":"Localization.algEquiv_symm_mk","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx : R\ny : Subtype fun x => Membership.mem M x\n⊢ Eq ((Localization.algEquiv M S).symm (IsLocalization.mk' S x y)) (Localization.mk x y)","decl":"theorem algEquiv_symm_mk (x : R) (y : M) : (algEquiv M S).symm (mk' S x y) = mk x y := by\n  rw [mk_eq_mk', algEquiv_symm_mk']\n\n"}
{"name":"Localization.coe_algEquiv","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\n⊢ Eq (↑(Localization.algEquiv M S)) (IsLocalization.map S (RingHom.id R) ⋯)","decl":"lemma coe_algEquiv :\n    (Localization.algEquiv M S : Localization M →+* S) =\n    IsLocalization.map (M := M) (T := M) _ (RingHom.id R) le_rfl := rfl\n\n"}
{"name":"Localization.coe_algEquiv_symm","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\n⊢ Eq (↑(Localization.algEquiv M S).symm) (IsLocalization.map (Localization M) (RingHom.id R) ⋯)","decl":"lemma coe_algEquiv_symm :\n    ((Localization.algEquiv M S).symm : S →+* Localization M) =\n    IsLocalization.map (M := M) (T := M) _ (RingHom.id R) le_rfl := rfl\n\n"}
{"name":"Localization.mk_intCast","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nM : Submonoid R\nm : Int\n⊢ Eq (Localization.mk (↑m) 1) ↑m","decl":"theorem mk_intCast (m : ℤ) : (mk m 1 : Localization M) = m := by\n  simpa using mk_algebraMap (R := R) (A := ℤ) _\n\n"}
{"name":"IsField.localization_map_bijective","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"R : Type u_4\nRₘ : Type u_5\ninst✝³ : CommRing R\ninst✝² : CommRing Rₘ\nM : Submonoid R\nhM : Not (Membership.mem M 0)\nhR : IsField R\ninst✝¹ : Algebra R Rₘ\ninst✝ : IsLocalization M Rₘ\n⊢ Function.Bijective ⇑(algebraMap R Rₘ)","decl":"/-- If `R` is a field, then localizing at a submonoid not containing `0` adds no new elements. -/\ntheorem IsField.localization_map_bijective {R Rₘ : Type*} [CommRing R] [CommRing Rₘ]\n    {M : Submonoid R} (hM : (0 : R) ∉ M) (hR : IsField R) [Algebra R Rₘ] [IsLocalization M Rₘ] :\n    Function.Bijective (algebraMap R Rₘ) := by\n  letI := hR.toField\n  replace hM := le_nonZeroDivisors_of_noZeroDivisors hM\n  refine ⟨IsLocalization.injective _ hM, fun x => ?_⟩\n  obtain ⟨r, ⟨m, hm⟩, rfl⟩ := mk'_surjective M x\n  obtain ⟨n, hn⟩ := hR.mul_inv_cancel (nonZeroDivisors.ne_zero <| hM hm)\n  exact ⟨r * n, by rw [eq_mk'_iff_mul_eq, ← map_mul, mul_assoc, _root_.mul_comm n, hn, mul_one]⟩\n\n"}
{"name":"Field.localization_map_bijective","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"K : Type u_4\nKₘ : Type u_5\ninst✝³ : Field K\ninst✝² : CommRing Kₘ\nM : Submonoid K\nhM : Not (Membership.mem M 0)\ninst✝¹ : Algebra K Kₘ\ninst✝ : IsLocalization M Kₘ\n⊢ Function.Bijective ⇑(algebraMap K Kₘ)","decl":"/-- If `R` is a field, then localizing at a submonoid not containing `0` adds no new elements. -/\ntheorem Field.localization_map_bijective {K Kₘ : Type*} [Field K] [CommRing Kₘ] {M : Submonoid K}\n    (hM : (0 : K) ∉ M) [Algebra K Kₘ] [IsLocalization M Kₘ] :\n    Function.Bijective (algebraMap K Kₘ) :=\n  (Field.toIsField K).localization_map_bijective hM\n\n-- this looks weird due to the `letI` inside the above lemma, but trying to do it the other\n-- way round causes issues with defeq of instances, so this is actually easier.\n"}
{"name":"IsLocalization.map_units_map_submonoid","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nSₘ : Type u_5\ninst✝³ : CommRing Sₘ\ninst✝² : Algebra S Sₘ\ni : IsLocalization (Algebra.algebraMapSubmonoid S M) Sₘ\ninst✝¹ : Algebra R Sₘ\ninst✝ : IsScalarTower R S Sₘ\ny : Subtype fun x => Membership.mem M x\n⊢ IsUnit ((algebraMap R Sₘ) ↑y)","decl":"theorem IsLocalization.map_units_map_submonoid (y : M) : IsUnit (algebraMap R Sₘ y) := by\n  rw [IsScalarTower.algebraMap_apply _ S]\n  exact IsLocalization.map_units Sₘ ⟨algebraMap R S y, Algebra.mem_algebraMapSubmonoid_of_mem y⟩\n\n-- can't be simp, as `S` only appears on the RHS\n"}
{"name":"IsLocalization.algebraMap_mk'","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"R : Type u_1\ninst✝¹¹ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝¹⁰ : CommRing S\ninst✝⁹ : Algebra R S\nRₘ : Type u_4\nSₘ : Type u_5\ninst✝⁸ : CommRing Rₘ\ninst✝⁷ : CommRing Sₘ\ninst✝⁶ : Algebra R Rₘ\ninst✝⁵ : IsLocalization M Rₘ\ninst✝⁴ : Algebra S Sₘ\ni : IsLocalization (Algebra.algebraMapSubmonoid S M) Sₘ\ninst✝³ : Algebra Rₘ Sₘ\ninst✝² : Algebra R Sₘ\ninst✝¹ : IsScalarTower R Rₘ Sₘ\ninst✝ : IsScalarTower R S Sₘ\nx : R\ny : Subtype fun x => Membership.mem M x\n⊢ Eq ((algebraMap Rₘ Sₘ) (IsLocalization.mk' Rₘ x y)) (IsLocalization.mk' Sₘ ((algebraMap R S) x) ⟨(algebraMap R S) ↑y, ⋯⟩)","decl":"theorem IsLocalization.algebraMap_mk' (x : R) (y : M) :\n    algebraMap Rₘ Sₘ (IsLocalization.mk' Rₘ x y) =\n      IsLocalization.mk' Sₘ (algebraMap R S x)\n        ⟨algebraMap R S y, Algebra.mem_algebraMapSubmonoid_of_mem y⟩ := by\n  rw [IsLocalization.eq_mk'_iff_mul_eq, Subtype.coe_mk, ← IsScalarTower.algebraMap_apply, ←\n    IsScalarTower.algebraMap_apply, IsScalarTower.algebraMap_apply R Rₘ Sₘ,\n    IsScalarTower.algebraMap_apply R Rₘ Sₘ, ← _root_.map_mul, mul_comm,\n    IsLocalization.mul_mk'_eq_mk'_of_mul]\n  exact congr_arg (algebraMap Rₘ Sₘ) (IsLocalization.mk'_mul_cancel_left x y)\n\n"}
{"name":"IsLocalization.algebraMap_eq_map_map_submonoid","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"R : Type u_1\ninst✝¹¹ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝¹⁰ : CommRing S\ninst✝⁹ : Algebra R S\nRₘ : Type u_4\nSₘ : Type u_5\ninst✝⁸ : CommRing Rₘ\ninst✝⁷ : CommRing Sₘ\ninst✝⁶ : Algebra R Rₘ\ninst✝⁵ : IsLocalization M Rₘ\ninst✝⁴ : Algebra S Sₘ\ni : IsLocalization (Algebra.algebraMapSubmonoid S M) Sₘ\ninst✝³ : Algebra Rₘ Sₘ\ninst✝² : Algebra R Sₘ\ninst✝¹ : IsScalarTower R Rₘ Sₘ\ninst✝ : IsScalarTower R S Sₘ\n⊢ Eq (algebraMap Rₘ Sₘ) (IsLocalization.map Sₘ (algebraMap R S) ⋯)","decl":"/-- If the square below commutes, the bottom map is uniquely specified:\n```\nR  →  S\n↓     ↓\nRₘ → Sₘ\n```\n-/\ntheorem IsLocalization.algebraMap_eq_map_map_submonoid :\n    algebraMap Rₘ Sₘ =\n      map Sₘ (algebraMap R S)\n        (show _ ≤ (Algebra.algebraMapSubmonoid S M).comap _ from M.le_comap_map) :=\n  Eq.symm <|\n    IsLocalization.map_unique _ (algebraMap Rₘ Sₘ) fun x => by\n      rw [← IsScalarTower.algebraMap_apply R S Sₘ, ← IsScalarTower.algebraMap_apply R Rₘ Sₘ]\n\n"}
{"name":"IsLocalization.algebraMap_apply_eq_map_map_submonoid","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"R : Type u_1\ninst✝¹¹ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝¹⁰ : CommRing S\ninst✝⁹ : Algebra R S\nRₘ : Type u_4\nSₘ : Type u_5\ninst✝⁸ : CommRing Rₘ\ninst✝⁷ : CommRing Sₘ\ninst✝⁶ : Algebra R Rₘ\ninst✝⁵ : IsLocalization M Rₘ\ninst✝⁴ : Algebra S Sₘ\ni : IsLocalization (Algebra.algebraMapSubmonoid S M) Sₘ\ninst✝³ : Algebra Rₘ Sₘ\ninst✝² : Algebra R Sₘ\ninst✝¹ : IsScalarTower R Rₘ Sₘ\ninst✝ : IsScalarTower R S Sₘ\nx : Rₘ\n⊢ Eq ((algebraMap Rₘ Sₘ) x) ((IsLocalization.map Sₘ (algebraMap R S) ⋯) x)","decl":"/-- If the square below commutes, the bottom map is uniquely specified:\n```\nR  →  S\n↓     ↓\nRₘ → Sₘ\n```\n-/\ntheorem IsLocalization.algebraMap_apply_eq_map_map_submonoid (x) :\n    algebraMap Rₘ Sₘ x =\n      map Sₘ (algebraMap R S)\n        (show _ ≤ (Algebra.algebraMapSubmonoid S M).comap _ from M.le_comap_map) x :=\n  DFunLike.congr_fun (IsLocalization.algebraMap_eq_map_map_submonoid _ _ _ _) x\n\n"}
{"name":"IsLocalization.lift_algebraMap_eq_algebraMap","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"R : Type u_1\ninst✝¹¹ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝¹⁰ : CommRing S\ninst✝⁹ : Algebra R S\nRₘ : Type u_4\nSₘ : Type u_5\ninst✝⁸ : CommRing Rₘ\ninst✝⁷ : CommRing Sₘ\ninst✝⁶ : Algebra R Rₘ\ninst✝⁵ : IsLocalization M Rₘ\ninst✝⁴ : Algebra S Sₘ\ni : IsLocalization (Algebra.algebraMapSubmonoid S M) Sₘ\ninst✝³ : Algebra Rₘ Sₘ\ninst✝² : Algebra R Sₘ\ninst✝¹ : IsScalarTower R Rₘ Sₘ\ninst✝ : IsScalarTower R S Sₘ\n⊢ Eq (IsLocalization.lift ⋯) (algebraMap Rₘ Sₘ)","decl":"theorem IsLocalization.lift_algebraMap_eq_algebraMap :\n    IsLocalization.lift (M := M) (IsLocalization.map_units_map_submonoid S Sₘ) =\n      algebraMap Rₘ Sₘ :=\n  IsLocalization.lift_unique _ fun _ => (IsScalarTower.algebraMap_apply _ _ _ _).symm\n\n"}
{"name":"localizationAlgebra_injective","module":"Mathlib.RingTheory.Localization.Basic","initialProofState":"R : Type u_1\ninst✝⁷ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝⁶ : CommRing S\ninst✝⁵ : Algebra R S\nRₘ : Type u_4\nSₘ : Type u_5\ninst✝⁴ : CommRing Rₘ\ninst✝³ : CommRing Sₘ\ninst✝² : Algebra R Rₘ\ninst✝¹ : IsLocalization M Rₘ\ninst✝ : Algebra S Sₘ\ni : IsLocalization (Algebra.algebraMapSubmonoid S M) Sₘ\nhRS : Function.Injective ⇑(algebraMap R S)\n⊢ Function.Injective ⇑(algebraMap Rₘ Sₘ)","decl":"/-- Injectivity of the underlying `algebraMap` descends to the algebra induced by localization. -/\ntheorem localizationAlgebra_injective (hRS : Function.Injective (algebraMap R S)) :\n    Function.Injective (@algebraMap Rₘ Sₘ _ _ (localizationAlgebra M S)) :=\n  have : IsLocalization (M.map (algebraMap R S)) Sₘ := i\n  IsLocalization.map_injective_of_injective _ _ _ hRS\n\n"}
