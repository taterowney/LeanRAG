{"name":"Summable.clog_one_sub","module":"Mathlib.NumberTheory.EulerProduct.ExpLog","initialProofState":"α : Type u_1\nf : α → Complex\nhsum : Summable f\n⊢ Summable fun n => Complex.log (HSub.hSub 1 (f n))","decl":"open Topology in\n/-- If `f : α → ℂ` is summable, then so is `n ↦ log (1 - f n)`. -/\nlemma Summable.clog_one_sub {α  : Type*} {f : α → ℂ} (hsum : Summable f) :\n    Summable fun n ↦ log (1 - f n) := by\n  have hg : DifferentiableAt ℂ (fun z ↦ log (1 - z)) 0 := by\n    have : 1 - 0 ∈ slitPlane := (sub_zero (1 : ℂ)).symm ▸ one_mem_slitPlane\n    fun_prop (disch := assumption)\n  have : (fun z ↦ log (1 - z)) =O[𝓝 0] id := by\n    simpa only [sub_zero, log_one] using hg.isBigO_sub\n  exact this.comp_summable hsum\n\n"}
{"name":"EulerProduct.exp_tsum_primes_log_eq_tsum","module":"Mathlib.NumberTheory.EulerProduct.ExpLog","initialProofState":"f : MonoidWithZeroHom Nat Complex\nhsum : Summable fun x => Norm.norm (f x)\n⊢ Eq (Complex.exp (tsum fun p => Neg.neg (Complex.log (HSub.hSub 1 (f ↑p))))) (tsum fun n => f n)","decl":"/-- A variant of the Euler Product formula in terms of the exponential of a sum of logarithms. -/\ntheorem exp_tsum_primes_log_eq_tsum {f : ℕ →*₀ ℂ} (hsum : Summable (‖f ·‖)) :\n    exp (∑' p : Nat.Primes, -log (1 - f p)) = ∑' n : ℕ, f n := by\n  have hs {p : ℕ} (hp : 1 < p) : ‖f p‖ < 1 := hsum.of_norm.norm_lt_one (f := f.toMonoidHom) hp\n  have hp (p : Nat.Primes) : 1 - f p ≠ 0 :=\n    fun h ↦ (norm_one (α := ℂ) ▸ (sub_eq_zero.mp h) ▸ hs p.prop.one_lt).false\n  have H := hsum.of_norm.clog_one_sub.neg.subtype {p | p.Prime} |>.hasSum.cexp.tprod_eq\n  simp only [Set.coe_setOf, Set.mem_setOf_eq, Function.comp_apply, exp_neg, exp_log (hp _)] at H\n  exact H.symm.trans <| eulerProduct_completely_multiplicative_tprod hsum\n\n"}
