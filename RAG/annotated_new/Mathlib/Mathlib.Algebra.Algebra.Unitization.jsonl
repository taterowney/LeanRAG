{"name":"Unitization.ext","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\nx y : Unitization R A\nh1 : Eq x.fst y.fst\nh2 : Eq x.snd y.snd\n‚ä¢ Eq x y","decl":"@[ext]\ntheorem ext {x y : Unitization R A} (h1 : x.fst = y.fst) (h2 : x.snd = y.snd) : x = y :=\n  Prod.ext h1 h2\n\n"}
{"name":"Unitization.ext_iff","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\nx y : Unitization R A\n‚ä¢ Iff (Eq x y) (And (Eq x.fst y.fst) (Eq x.snd y.snd))","decl":"@[ext]\ntheorem ext {x y : Unitization R A} (h1 : x.fst = y.fst) (h2 : x.snd = y.snd) : x = y :=\n  Prod.ext h1 h2\n\n"}
{"name":"Unitization.fst_inl","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù : Zero A\nr : R\n‚ä¢ Eq (Unitization.inl r).fst r","decl":"@[simp]\ntheorem fst_inl [Zero A] (r : R) : (inl r : Unitization R A).fst = r :=\n  rfl\n\n"}
{"name":"Unitization.snd_inl","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù : Zero A\nr : R\n‚ä¢ Eq (Unitization.inl r).snd 0","decl":"@[simp]\ntheorem snd_inl [Zero A] (r : R) : (inl r : Unitization R A).snd = 0 :=\n  rfl\n\n"}
{"name":"Unitization.fst_inr","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù : Zero R\na : A\n‚ä¢ Eq (‚Üëa).fst 0","decl":"@[simp]\ntheorem fst_inr [Zero R] (a : A) : (a : Unitization R A).fst = 0 :=\n  rfl\n\n"}
{"name":"Unitization.snd_inr","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù : Zero R\na : A\n‚ä¢ Eq (‚Üëa).snd a","decl":"@[simp]\ntheorem snd_inr [Zero R] (a : A) : (a : Unitization R A).snd = a :=\n  rfl\n\n"}
{"name":"Unitization.inl_injective","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù : Zero A\n‚ä¢ Function.Injective Unitization.inl","decl":"theorem inl_injective [Zero A] : Function.Injective (inl : R ‚Üí Unitization R A) :=\n  Function.LeftInverse.injective <| fst_inl _\n\n"}
{"name":"Unitization.inr_injective","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù : Zero R\n‚ä¢ Function.Injective Unitization.inr","decl":"theorem inr_injective [Zero R] : Function.Injective ((‚Üë) : A ‚Üí Unitization R A) :=\n  Function.LeftInverse.injective <| snd_inr _\n\n"}
{"name":"Unitization.instNontrivialLeft","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"ùïú : Type u_3\nA : Type u_4\ninst‚úù¬π : Nontrivial ùïú\ninst‚úù : Nonempty A\n‚ä¢ Nontrivial (Unitization ùïú A)","decl":"instance instNontrivialLeft {ùïú A} [Nontrivial ùïú] [Nonempty A] :\n    Nontrivial (Unitization ùïú A) :=\n  nontrivial_prod_left\n\n"}
{"name":"Unitization.instNontrivialRight","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"ùïú : Type u_3\nA : Type u_4\ninst‚úù¬π : Nonempty ùïú\ninst‚úù : Nontrivial A\n‚ä¢ Nontrivial (Unitization ùïú A)","decl":"instance instNontrivialRight {ùïú A} [Nonempty ùïú] [Nontrivial A] :\n    Nontrivial (Unitization ùïú A) :=\n  nontrivial_prod_right\n\n"}
{"name":"Unitization.instCanLift","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_3\nA : Type u_4\ninst‚úù : Zero R\n‚ä¢ CanLift (Unitization R A) A Unitization.inr fun x => Eq x.fst 0","decl":"instance instCanLift [Zero R] : CanLift (Unitization R A) A inr (fun x ‚Ü¶ x.fst = 0) where\n  prf x hx := ‚ü®x.snd, ext (hx ‚ñ∏ fst_inr R (snd x)) rfl‚ü©\n\n"}
{"name":"Unitization.instIsScalarTower","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"T : Type u_1\nS : Type u_2\nR : Type u_3\nA : Type u_4\ninst‚úù‚Å∂ : SMul T R\ninst‚úù‚Åµ : SMul T A\ninst‚úù‚Å¥ : SMul S R\ninst‚úù¬≥ : SMul S A\ninst‚úù¬≤ : SMul T S\ninst‚úù¬π : IsScalarTower T S R\ninst‚úù : IsScalarTower T S A\n‚ä¢ IsScalarTower T S (Unitization R A)","decl":"instance instIsScalarTower [SMul T R] [SMul T A] [SMul S R] [SMul S A] [SMul T S]\n    [IsScalarTower T S R] [IsScalarTower T S A] : IsScalarTower T S (Unitization R A) :=\n  Prod.isScalarTower\n\n"}
{"name":"Unitization.instSMulCommClass","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"T : Type u_1\nS : Type u_2\nR : Type u_3\nA : Type u_4\ninst‚úù‚Åµ : SMul T R\ninst‚úù‚Å¥ : SMul T A\ninst‚úù¬≥ : SMul S R\ninst‚úù¬≤ : SMul S A\ninst‚úù¬π : SMulCommClass T S R\ninst‚úù : SMulCommClass T S A\n‚ä¢ SMulCommClass T S (Unitization R A)","decl":"instance instSMulCommClass [SMul T R] [SMul T A] [SMul S R] [SMul S A] [SMulCommClass T S R]\n    [SMulCommClass T S A] : SMulCommClass T S (Unitization R A) :=\n  Prod.smulCommClass\n\n"}
{"name":"Unitization.instIsCentralScalar","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"S : Type u_2\nR : Type u_3\nA : Type u_4\ninst‚úù‚Åµ : SMul S R\ninst‚úù‚Å¥ : SMul S A\ninst‚úù¬≥ : SMul (MulOpposite S) R\ninst‚úù¬≤ : SMul (MulOpposite S) A\ninst‚úù¬π : IsCentralScalar S R\ninst‚úù : IsCentralScalar S A\n‚ä¢ IsCentralScalar S (Unitization R A)","decl":"instance instIsCentralScalar [SMul S R] [SMul S A] [SMul S·µê·µí·µñ R] [SMul S·µê·µí·µñ A] [IsCentralScalar S R]\n    [IsCentralScalar S A] : IsCentralScalar S (Unitization R A) :=\n  Prod.isCentralScalar\n\n"}
{"name":"Unitization.fst_zero","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_3\nA : Type u_4\ninst‚úù¬π : Zero R\ninst‚úù : Zero A\n‚ä¢ Eq (Unitization.fst 0) 0","decl":"@[simp]\ntheorem fst_zero [Zero R] [Zero A] : (0 : Unitization R A).fst = 0 :=\n  rfl\n\n"}
{"name":"Unitization.snd_zero","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_3\nA : Type u_4\ninst‚úù¬π : Zero R\ninst‚úù : Zero A\n‚ä¢ Eq (Unitization.snd 0) 0","decl":"@[simp]\ntheorem snd_zero [Zero R] [Zero A] : (0 : Unitization R A).snd = 0 :=\n  rfl\n\n"}
{"name":"Unitization.fst_add","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_3\nA : Type u_4\ninst‚úù¬π : Add R\ninst‚úù : Add A\nx‚ÇÅ x‚ÇÇ : Unitization R A\n‚ä¢ Eq (HAdd.hAdd x‚ÇÅ x‚ÇÇ).fst (HAdd.hAdd x‚ÇÅ.fst x‚ÇÇ.fst)","decl":"@[simp]\ntheorem fst_add [Add R] [Add A] (x‚ÇÅ x‚ÇÇ : Unitization R A) : (x‚ÇÅ + x‚ÇÇ).fst = x‚ÇÅ.fst + x‚ÇÇ.fst :=\n  rfl\n\n"}
{"name":"Unitization.snd_add","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_3\nA : Type u_4\ninst‚úù¬π : Add R\ninst‚úù : Add A\nx‚ÇÅ x‚ÇÇ : Unitization R A\n‚ä¢ Eq (HAdd.hAdd x‚ÇÅ x‚ÇÇ).snd (HAdd.hAdd x‚ÇÅ.snd x‚ÇÇ.snd)","decl":"@[simp]\ntheorem snd_add [Add R] [Add A] (x‚ÇÅ x‚ÇÇ : Unitization R A) : (x‚ÇÅ + x‚ÇÇ).snd = x‚ÇÅ.snd + x‚ÇÇ.snd :=\n  rfl\n\n"}
{"name":"Unitization.fst_neg","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_3\nA : Type u_4\ninst‚úù¬π : Neg R\ninst‚úù : Neg A\nx : Unitization R A\n‚ä¢ Eq (Neg.neg x).fst (Neg.neg x.fst)","decl":"@[simp]\ntheorem fst_neg [Neg R] [Neg A] (x : Unitization R A) : (-x).fst = -x.fst :=\n  rfl\n\n"}
{"name":"Unitization.snd_neg","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_3\nA : Type u_4\ninst‚úù¬π : Neg R\ninst‚úù : Neg A\nx : Unitization R A\n‚ä¢ Eq (Neg.neg x).snd (Neg.neg x.snd)","decl":"@[simp]\ntheorem snd_neg [Neg R] [Neg A] (x : Unitization R A) : (-x).snd = -x.snd :=\n  rfl\n\n"}
{"name":"Unitization.fst_smul","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"S : Type u_2\nR : Type u_3\nA : Type u_4\ninst‚úù¬π : SMul S R\ninst‚úù : SMul S A\ns : S\nx : Unitization R A\n‚ä¢ Eq (HSMul.hSMul s x).fst (HSMul.hSMul s x.fst)","decl":"@[simp]\ntheorem fst_smul [SMul S R] [SMul S A] (s : S) (x : Unitization R A) : (s ‚Ä¢ x).fst = s ‚Ä¢ x.fst :=\n  rfl\n\n"}
{"name":"Unitization.snd_smul","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"S : Type u_2\nR : Type u_3\nA : Type u_4\ninst‚úù¬π : SMul S R\ninst‚úù : SMul S A\ns : S\nx : Unitization R A\n‚ä¢ Eq (HSMul.hSMul s x).snd (HSMul.hSMul s x.snd)","decl":"@[simp]\ntheorem snd_smul [SMul S R] [SMul S A] (s : S) (x : Unitization R A) : (s ‚Ä¢ x).snd = s ‚Ä¢ x.snd :=\n  rfl\n\n"}
{"name":"Unitization.inl_zero","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_3\nA : Type u_4\ninst‚úù¬π : Zero R\ninst‚úù : Zero A\n‚ä¢ Eq (Unitization.inl 0) 0","decl":"@[simp]\ntheorem inl_zero [Zero R] [Zero A] : (inl 0 : Unitization R A) = 0 :=\n  rfl\n\n"}
{"name":"Unitization.inl_add","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_3\nA : Type u_4\ninst‚úù¬π : Add R\ninst‚úù : AddZeroClass A\nr‚ÇÅ r‚ÇÇ : R\n‚ä¢ Eq (Unitization.inl (HAdd.hAdd r‚ÇÅ r‚ÇÇ)) (HAdd.hAdd (Unitization.inl r‚ÇÅ) (Unitization.inl r‚ÇÇ))","decl":"@[simp]\ntheorem inl_add [Add R] [AddZeroClass A] (r‚ÇÅ r‚ÇÇ : R) :\n    (inl (r‚ÇÅ + r‚ÇÇ) : Unitization R A) = inl r‚ÇÅ + inl r‚ÇÇ :=\n  ext rfl (add_zero 0).symm\n\n"}
{"name":"Unitization.inl_neg","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_3\nA : Type u_4\ninst‚úù¬π : Neg R\ninst‚úù : AddGroup A\nr : R\n‚ä¢ Eq (Unitization.inl (Neg.neg r)) (Neg.neg (Unitization.inl r))","decl":"@[simp]\ntheorem inl_neg [Neg R] [AddGroup A] (r : R) : (inl (-r) : Unitization R A) = -inl r :=\n  ext rfl neg_zero.symm\n\n"}
{"name":"Unitization.inl_sub","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_3\nA : Type u_4\ninst‚úù¬π : AddGroup R\ninst‚úù : AddGroup A\nr‚ÇÅ r‚ÇÇ : R\n‚ä¢ Eq (Unitization.inl (HSub.hSub r‚ÇÅ r‚ÇÇ)) (HSub.hSub (Unitization.inl r‚ÇÅ) (Unitization.inl r‚ÇÇ))","decl":"@[simp]\ntheorem inl_sub [AddGroup R] [AddGroup A] (r‚ÇÅ r‚ÇÇ : R) :\n    (inl (r‚ÇÅ - r‚ÇÇ) : Unitization R A) = inl r‚ÇÅ - inl r‚ÇÇ :=\n  ext rfl (sub_zero 0).symm\n\n"}
{"name":"Unitization.inl_smul","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"S : Type u_2\nR : Type u_3\nA : Type u_4\ninst‚úù¬≥ : Monoid S\ninst‚úù¬≤ : AddMonoid A\ninst‚úù¬π : SMul S R\ninst‚úù : DistribMulAction S A\ns : S\nr : R\n‚ä¢ Eq (Unitization.inl (HSMul.hSMul s r)) (HSMul.hSMul s (Unitization.inl r))","decl":"@[simp]\ntheorem inl_smul [Monoid S] [AddMonoid A] [SMul S R] [DistribMulAction S A] (s : S) (r : R) :\n    (inl (s ‚Ä¢ r) : Unitization R A) = s ‚Ä¢ inl r :=\n  ext rfl (smul_zero s).symm\n\n"}
{"name":"Unitization.inr_zero","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_3\nA : Type u_4\ninst‚úù¬π : Zero R\ninst‚úù : Zero A\n‚ä¢ Eq (‚Üë0) 0","decl":"@[simp]\ntheorem inr_zero [Zero R] [Zero A] : ‚Üë(0 : A) = (0 : Unitization R A) :=\n  rfl\n\n"}
{"name":"Unitization.inr_add","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_3\nA : Type u_4\ninst‚úù¬π : AddZeroClass R\ninst‚úù : Add A\nm‚ÇÅ m‚ÇÇ : A\n‚ä¢ Eq (‚Üë(HAdd.hAdd m‚ÇÅ m‚ÇÇ)) (HAdd.hAdd ‚Üëm‚ÇÅ ‚Üëm‚ÇÇ)","decl":"@[simp]\ntheorem inr_add [AddZeroClass R] [Add A] (m‚ÇÅ m‚ÇÇ : A) : (‚Üë(m‚ÇÅ + m‚ÇÇ) : Unitization R A) = m‚ÇÅ + m‚ÇÇ :=\n  ext (add_zero 0).symm rfl\n\n"}
{"name":"Unitization.inr_neg","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_3\nA : Type u_4\ninst‚úù¬π : AddGroup R\ninst‚úù : Neg A\nm : A\n‚ä¢ Eq (‚Üë(Neg.neg m)) (Neg.neg ‚Üëm)","decl":"@[simp]\ntheorem inr_neg [AddGroup R] [Neg A] (m : A) : (‚Üë(-m) : Unitization R A) = -m :=\n  ext neg_zero.symm rfl\n\n"}
{"name":"Unitization.inr_sub","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_3\nA : Type u_4\ninst‚úù¬π : AddGroup R\ninst‚úù : AddGroup A\nm‚ÇÅ m‚ÇÇ : A\n‚ä¢ Eq (‚Üë(HSub.hSub m‚ÇÅ m‚ÇÇ)) (HSub.hSub ‚Üëm‚ÇÅ ‚Üëm‚ÇÇ)","decl":"@[simp]\ntheorem inr_sub [AddGroup R] [AddGroup A] (m‚ÇÅ m‚ÇÇ : A) : (‚Üë(m‚ÇÅ - m‚ÇÇ) : Unitization R A) = m‚ÇÅ - m‚ÇÇ :=\n  ext (sub_zero 0).symm rfl\n\n"}
{"name":"Unitization.inr_smul","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"S : Type u_2\nR : Type u_3\nA : Type u_4\ninst‚úù¬≥ : Zero R\ninst‚úù¬≤ : Zero S\ninst‚úù¬π : SMulWithZero S R\ninst‚úù : SMul S A\nr : S\nm : A\n‚ä¢ Eq (‚Üë(HSMul.hSMul r m)) (HSMul.hSMul r ‚Üëm)","decl":"@[simp]\ntheorem inr_smul [Zero R] [Zero S] [SMulWithZero S R] [SMul S A] (r : S) (m : A) :\n    (‚Üë(r ‚Ä¢ m) : Unitization R A) = r ‚Ä¢ (m : Unitization R A) :=\n  ext (smul_zero _).symm rfl\n\n"}
{"name":"Unitization.inl_fst_add_inr_snd_eq","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_3\nA : Type u_4\ninst‚úù¬π : AddZeroClass R\ninst‚úù : AddZeroClass A\nx : Unitization R A\n‚ä¢ Eq (HAdd.hAdd (Unitization.inl x.fst) ‚Üëx.snd) x","decl":"theorem inl_fst_add_inr_snd_eq [AddZeroClass R] [AddZeroClass A] (x : Unitization R A) :\n    inl x.fst + (x.snd : Unitization R A) = x :=\n  ext (add_zero x.1) (zero_add x.2)\n\n"}
{"name":"Unitization.ind","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_5\nA : Type u_6\ninst‚úù¬π : AddZeroClass R\ninst‚úù : AddZeroClass A\nP : Unitization R A ‚Üí Prop\ninl_add_inr : ‚àÄ (r : R) (a : A), P (HAdd.hAdd (Unitization.inl r) ‚Üëa)\nx : Unitization R A\n‚ä¢ P x","decl":"/-- To show a property hold on all `Unitization R A` it suffices to show it holds\non terms of the form `inl r + a`.\n\nThis can be used as `induction x`. -/\n@[elab_as_elim, induction_eliminator, cases_eliminator]\ntheorem ind {R A} [AddZeroClass R] [AddZeroClass A] {P : Unitization R A ‚Üí Prop}\n    (inl_add_inr : ‚àÄ (r : R) (a : A), P (inl r + (a : Unitization R A))) (x) : P x :=\n  inl_fst_add_inr_snd_eq x ‚ñ∏ inl_add_inr x.1 x.2\n\n"}
{"name":"Unitization.linearMap_ext","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"S : Type u_2\nR : Type u_3\nA : Type u_4\nN : Type u_5\ninst‚úù‚Å∂ : Semiring S\ninst‚úù‚Åµ : AddCommMonoid R\ninst‚úù‚Å¥ : AddCommMonoid A\ninst‚úù¬≥ : AddCommMonoid N\ninst‚úù¬≤ : Module S R\ninst‚úù¬π : Module S A\ninst‚úù : Module S N\nf g : LinearMap (RingHom.id S) (Unitization R A) N\nhl : ‚àÄ (r : R), Eq (f (Unitization.inl r)) (g (Unitization.inl r))\nhr : ‚àÄ (a : A), Eq (f ‚Üëa) (g ‚Üëa)\n‚ä¢ Eq f g","decl":"/-- This cannot be marked `@[ext]` as it ends up being used instead of `LinearMap.prod_ext` when\nworking with `R √ó A`. -/\ntheorem linearMap_ext {N} [Semiring S] [AddCommMonoid R] [AddCommMonoid A] [AddCommMonoid N]\n    [Module S R] [Module S A] [Module S N] ‚¶Éf g : Unitization R A ‚Üí‚Çó[S] N‚¶Ñ\n    (hl : ‚àÄ r, f (inl r) = g (inl r)) (hr : ‚àÄ a : A, f a = g a) : f = g :=\n  LinearMap.prod_ext (LinearMap.ext hl) (LinearMap.ext hr)\n\n"}
{"name":"Unitization.inrHom_apply","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_3\nA : Type u_4\ninst‚úù¬≤ : Semiring R\ninst‚úù¬π : AddCommMonoid A\ninst‚úù : Module R A\na : A\n‚ä¢ Eq ((Unitization.inrHom R A) a) ‚Üëa","decl":"/-- The canonical `R`-linear inclusion `A ‚Üí Unitization R A`. -/\n@[simps apply]\ndef inrHom [Semiring R] [AddCommMonoid A] [Module R A] : A ‚Üí‚Çó[R] Unitization R A :=\n  { LinearMap.inr R R A with toFun := (‚Üë) }\n\n"}
{"name":"Unitization.sndHom_apply","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_3\nA : Type u_4\ninst‚úù¬≤ : Semiring R\ninst‚úù¬π : AddCommMonoid A\ninst‚úù : Module R A\nx : Unitization R A\n‚ä¢ Eq ((Unitization.sndHom R A) x) x.snd","decl":"/-- The canonical `R`-linear projection `Unitization R A ‚Üí A`. -/\n@[simps apply]\ndef sndHom [Semiring R] [AddCommMonoid A] [Module R A] : Unitization R A ‚Üí‚Çó[R] A :=\n  { LinearMap.snd _ _ _ with toFun := snd }\n\n"}
{"name":"Unitization.fst_one","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù¬π : One R\ninst‚úù : Zero A\n‚ä¢ Eq (Unitization.fst 1) 1","decl":"@[simp]\ntheorem fst_one [One R] [Zero A] : (1 : Unitization R A).fst = 1 :=\n  rfl\n\n"}
{"name":"Unitization.snd_one","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù¬π : One R\ninst‚úù : Zero A\n‚ä¢ Eq (Unitization.snd 1) 0","decl":"@[simp]\ntheorem snd_one [One R] [Zero A] : (1 : Unitization R A).snd = 0 :=\n  rfl\n\n"}
{"name":"Unitization.fst_mul","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù¬≥ : Mul R\ninst‚úù¬≤ : Add A\ninst‚úù¬π : Mul A\ninst‚úù : SMul R A\nx‚ÇÅ x‚ÇÇ : Unitization R A\n‚ä¢ Eq (HMul.hMul x‚ÇÅ x‚ÇÇ).fst (HMul.hMul x‚ÇÅ.fst x‚ÇÇ.fst)","decl":"@[simp]\ntheorem fst_mul [Mul R] [Add A] [Mul A] [SMul R A] (x‚ÇÅ x‚ÇÇ : Unitization R A) :\n    (x‚ÇÅ * x‚ÇÇ).fst = x‚ÇÅ.fst * x‚ÇÇ.fst :=\n  rfl\n\n"}
{"name":"Unitization.snd_mul","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù¬≥ : Mul R\ninst‚úù¬≤ : Add A\ninst‚úù¬π : Mul A\ninst‚úù : SMul R A\nx‚ÇÅ x‚ÇÇ : Unitization R A\n‚ä¢ Eq (HMul.hMul x‚ÇÅ x‚ÇÇ).snd (HAdd.hAdd (HAdd.hAdd (HSMul.hSMul x‚ÇÅ.fst x‚ÇÇ.snd) (HSMul.hSMul x‚ÇÇ.fst x‚ÇÅ.snd)) (HMul.hMul x‚ÇÅ.snd x‚ÇÇ.snd))","decl":"@[simp]\ntheorem snd_mul [Mul R] [Add A] [Mul A] [SMul R A] (x‚ÇÅ x‚ÇÇ : Unitization R A) :\n    (x‚ÇÅ * x‚ÇÇ).snd = x‚ÇÅ.fst ‚Ä¢ x‚ÇÇ.snd + x‚ÇÇ.fst ‚Ä¢ x‚ÇÅ.snd + x‚ÇÅ.snd * x‚ÇÇ.snd :=\n  rfl\n\n"}
{"name":"Unitization.inl_one","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù¬π : One R\ninst‚úù : Zero A\n‚ä¢ Eq (Unitization.inl 1) 1","decl":"@[simp]\ntheorem inl_one [One R] [Zero A] : (inl 1 : Unitization R A) = 1 :=\n  rfl\n\n"}
{"name":"Unitization.inl_mul","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù¬≤ : Monoid R\ninst‚úù¬π : NonUnitalNonAssocSemiring A\ninst‚úù : DistribMulAction R A\nr‚ÇÅ r‚ÇÇ : R\n‚ä¢ Eq (Unitization.inl (HMul.hMul r‚ÇÅ r‚ÇÇ)) (HMul.hMul (Unitization.inl r‚ÇÅ) (Unitization.inl r‚ÇÇ))","decl":"@[simp]\ntheorem inl_mul [Monoid R] [NonUnitalNonAssocSemiring A] [DistribMulAction R A] (r‚ÇÅ r‚ÇÇ : R) :\n    (inl (r‚ÇÅ * r‚ÇÇ) : Unitization R A) = inl r‚ÇÅ * inl r‚ÇÇ :=\n  ext rfl <|\n    show (0 : A) = r‚ÇÅ ‚Ä¢ (0 : A) + r‚ÇÇ ‚Ä¢ (0 : A) + 0 * 0 by\n      simp only [smul_zero, add_zero, mul_zero]\n\n"}
{"name":"Unitization.inl_mul_inl","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù¬≤ : Monoid R\ninst‚úù¬π : NonUnitalNonAssocSemiring A\ninst‚úù : DistribMulAction R A\nr‚ÇÅ r‚ÇÇ : R\n‚ä¢ Eq (HMul.hMul (Unitization.inl r‚ÇÅ) (Unitization.inl r‚ÇÇ)) (Unitization.inl (HMul.hMul r‚ÇÅ r‚ÇÇ))","decl":"theorem inl_mul_inl [Monoid R] [NonUnitalNonAssocSemiring A] [DistribMulAction R A] (r‚ÇÅ r‚ÇÇ : R) :\n    (inl r‚ÇÅ * inl r‚ÇÇ : Unitization R A) = inl (r‚ÇÅ * r‚ÇÇ) :=\n  (inl_mul A r‚ÇÅ r‚ÇÇ).symm\n\n"}
{"name":"Unitization.inr_mul","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù¬≥ : Semiring R\ninst‚úù¬≤ : AddCommMonoid A\ninst‚úù¬π : Mul A\ninst‚úù : SMulWithZero R A\na‚ÇÅ a‚ÇÇ : A\n‚ä¢ Eq (‚Üë(HMul.hMul a‚ÇÅ a‚ÇÇ)) (HMul.hMul ‚Üëa‚ÇÅ ‚Üëa‚ÇÇ)","decl":"@[simp]\ntheorem inr_mul [Semiring R] [AddCommMonoid A] [Mul A] [SMulWithZero R A] (a‚ÇÅ a‚ÇÇ : A) :\n    (‚Üë(a‚ÇÅ * a‚ÇÇ) : Unitization R A) = a‚ÇÅ * a‚ÇÇ :=\n  ext (mul_zero _).symm <|\n    show a‚ÇÅ * a‚ÇÇ = (0 : R) ‚Ä¢ a‚ÇÇ + (0 : R) ‚Ä¢ a‚ÇÅ + a‚ÇÅ * a‚ÇÇ by simp only [zero_smul, zero_add]\n\n"}
{"name":"Unitization.inl_mul_inr","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù¬≤ : Semiring R\ninst‚úù¬π : NonUnitalNonAssocSemiring A\ninst‚úù : DistribMulAction R A\nr : R\na : A\n‚ä¢ Eq (HMul.hMul (Unitization.inl r) ‚Üëa) ‚Üë(HSMul.hSMul r a)","decl":"theorem inl_mul_inr [Semiring R] [NonUnitalNonAssocSemiring A] [DistribMulAction R A] (r : R)\n    (a : A) : ((inl r : Unitization R A) * a) = ‚Üë(r ‚Ä¢ a) :=\n  ext (mul_zero r) <|\n    show r ‚Ä¢ a + (0 : R) ‚Ä¢ (0 : A) + 0 * a = r ‚Ä¢ a by\n      rw [smul_zero, add_zero, zero_mul, add_zero]\n\n"}
{"name":"Unitization.inr_mul_inl","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù¬≤ : Semiring R\ninst‚úù¬π : NonUnitalNonAssocSemiring A\ninst‚úù : DistribMulAction R A\nr : R\na : A\n‚ä¢ Eq (HMul.hMul (‚Üëa) (Unitization.inl r)) ‚Üë(HSMul.hSMul r a)","decl":"theorem inr_mul_inl [Semiring R] [NonUnitalNonAssocSemiring A] [DistribMulAction R A] (r : R)\n    (a : A) : a * (inl r : Unitization R A) = ‚Üë(r ‚Ä¢ a) :=\n  ext (zero_mul r) <|\n    show (0 : R) ‚Ä¢ (0 : A) + r ‚Ä¢ a + a * 0 = r ‚Ä¢ a by\n      rw [smul_zero, zero_add, mul_zero, add_zero]\n\n"}
{"name":"Unitization.inlRingHom_apply","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù¬≤ : Semiring R\ninst‚úù¬π : NonUnitalSemiring A\ninst‚úù : Module R A\nr : R\n‚ä¢ Eq ((Unitization.inlRingHom R A) r) (Unitization.inl r)","decl":"/-- The canonical inclusion of rings `R ‚Üí+* Unitization R A`. -/\n@[simps apply]\ndef inlRingHom [Semiring R] [NonUnitalSemiring A] [Module R A] : R ‚Üí+* Unitization R A where\n  toFun := inl\n  map_one' := inl_one A\n  map_mul' := inl_mul A\n  map_zero' := inl_zero A\n  map_add' := inl_add A\n\n"}
{"name":"Unitization.fst_star","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù¬π : Star R\ninst‚úù : Star A\nx : Unitization R A\n‚ä¢ Eq (Star.star x).fst (Star.star x.fst)","decl":"@[simp]\ntheorem fst_star [Star R] [Star A] (x : Unitization R A) : (star x).fst = star x.fst :=\n  rfl\n\n"}
{"name":"Unitization.snd_star","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù¬π : Star R\ninst‚úù : Star A\nx : Unitization R A\n‚ä¢ Eq (Star.star x).snd (Star.star x.snd)","decl":"@[simp]\ntheorem snd_star [Star R] [Star A] (x : Unitization R A) : (star x).snd = star x.snd :=\n  rfl\n\n"}
{"name":"Unitization.inl_star","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù¬≤ : Star R\ninst‚úù¬π : AddMonoid A\ninst‚úù : StarAddMonoid A\nr : R\n‚ä¢ Eq (Unitization.inl (Star.star r)) (Star.star (Unitization.inl r))","decl":"@[simp]\ntheorem inl_star [Star R] [AddMonoid A] [StarAddMonoid A] (r : R) :\n    inl (star r) = star (inl r : Unitization R A) :=\n  ext rfl (by simp only [snd_star, star_zero, snd_inl])\n\n"}
{"name":"Unitization.inr_star","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù¬≤ : AddMonoid R\ninst‚úù¬π : StarAddMonoid R\ninst‚úù : Star A\na : A\n‚ä¢ Eq (‚Üë(Star.star a)) (Star.star ‚Üëa)","decl":"@[simp]\ntheorem inr_star [AddMonoid R] [StarAddMonoid R] [Star A] (a : A) :\n    ‚Üë(star a) = star (a : Unitization R A) :=\n  ext (by simp only [fst_star, star_zero, fst_inr]) rfl\n\n"}
{"name":"Unitization.instStarModule","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù‚Åµ : CommSemiring R\ninst‚úù‚Å¥ : StarRing R\ninst‚úù¬≥ : AddCommMonoid A\ninst‚úù¬≤ : StarAddMonoid A\ninst‚úù¬π : Module R A\ninst‚úù : StarModule R A\n‚ä¢ StarModule R (Unitization R A)","decl":"instance instStarModule [CommSemiring R] [StarRing R] [AddCommMonoid A] [StarAddMonoid A]\n    [Module R A] [StarModule R A] : StarModule R (Unitization R A) where\n  star_smul r x := ext (by simp) (by simp)\n\n"}
{"name":"Unitization.algebraMap_eq_inl_comp","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"S : Type u_1\nR : Type u_2\nA : Type u_3\ninst‚úù‚Å∏ : CommSemiring S\ninst‚úù‚Å∑ : CommSemiring R\ninst‚úù‚Å∂ : NonUnitalSemiring A\ninst‚úù‚Åµ : Module R A\ninst‚úù‚Å¥ : IsScalarTower R A A\ninst‚úù¬≥ : SMulCommClass R A A\ninst‚úù¬≤ : Algebra S R\ninst‚úù¬π : DistribMulAction S A\ninst‚úù : IsScalarTower S R A\n‚ä¢ Eq (‚áë(algebraMap S (Unitization R A))) (Function.comp Unitization.inl ‚áë(algebraMap S R))","decl":"theorem algebraMap_eq_inl_comp : ‚áë(algebraMap S (Unitization R A)) = inl ‚àò algebraMap S R :=\n  rfl\n\n"}
{"name":"Unitization.algebraMap_eq_inlRingHom_comp","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"S : Type u_1\nR : Type u_2\nA : Type u_3\ninst‚úù‚Å∏ : CommSemiring S\ninst‚úù‚Å∑ : CommSemiring R\ninst‚úù‚Å∂ : NonUnitalSemiring A\ninst‚úù‚Åµ : Module R A\ninst‚úù‚Å¥ : IsScalarTower R A A\ninst‚úù¬≥ : SMulCommClass R A A\ninst‚úù¬≤ : Algebra S R\ninst‚úù¬π : DistribMulAction S A\ninst‚úù : IsScalarTower S R A\n‚ä¢ Eq (algebraMap S (Unitization R A)) ((Unitization.inlRingHom R A).comp (algebraMap S R))","decl":"theorem algebraMap_eq_inlRingHom_comp :\n    algebraMap S (Unitization R A) = (inlRingHom R A).comp (algebraMap S R) :=\n  rfl\n\n"}
{"name":"Unitization.algebraMap_eq_inl","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_2\nA : Type u_3\ninst‚úù‚Å¥ : CommSemiring R\ninst‚úù¬≥ : NonUnitalSemiring A\ninst‚úù¬≤ : Module R A\ninst‚úù¬π : IsScalarTower R A A\ninst‚úù : SMulCommClass R A A\n‚ä¢ Eq (‚áë(algebraMap R (Unitization R A))) Unitization.inl","decl":"theorem algebraMap_eq_inl : ‚áë(algebraMap R (Unitization R A)) = inl :=\n  rfl\n\n"}
{"name":"Unitization.algebraMap_eq_inlRingHom","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_2\nA : Type u_3\ninst‚úù‚Å¥ : CommSemiring R\ninst‚úù¬≥ : NonUnitalSemiring A\ninst‚úù¬≤ : Module R A\ninst‚úù¬π : IsScalarTower R A A\ninst‚úù : SMulCommClass R A A\n‚ä¢ Eq (algebraMap R (Unitization R A)) (Unitization.inlRingHom R A)","decl":"theorem algebraMap_eq_inlRingHom : algebraMap R (Unitization R A) = inlRingHom R A :=\n  rfl\n\n"}
{"name":"Unitization.fstHom_apply","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_2\nA : Type u_3\ninst‚úù‚Å¥ : CommSemiring R\ninst‚úù¬≥ : NonUnitalSemiring A\ninst‚úù¬≤ : Module R A\ninst‚úù¬π : IsScalarTower R A A\ninst‚úù : SMulCommClass R A A\nx : Unitization R A\n‚ä¢ Eq ((Unitization.fstHom R A) x) x.fst","decl":"/-- The canonical `R`-algebra projection `Unitization R A ‚Üí R`. -/\n@[simps]\ndef fstHom : Unitization R A ‚Üí‚Çê[R] R where\n  toFun := fst\n  map_one' := fst_one\n  map_mul' := fst_mul\n  map_zero' := fst_zero (A := A)\n  map_add' := fst_add\n  commutes' := fst_inl A\n\n"}
{"name":"Unitization.inrNonUnitalAlgHom_toFun","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù¬≤ : CommSemiring R\ninst‚úù¬π : NonUnitalSemiring A\ninst‚úù : Module R A\na : A\n‚ä¢ Eq ((Unitization.inrNonUnitalAlgHom R A) a) ‚Üëa","decl":"/-- The coercion from a non-unital `R`-algebra `A` to its unitization `Unitization R A`\nrealized as a non-unital algebra homomorphism. -/\n@[simps]\ndef inrNonUnitalAlgHom (R A : Type*) [CommSemiring R] [NonUnitalSemiring A] [Module R A] :\n    A ‚Üí‚Çô‚Çê[R] Unitization R A where\n  toFun := (‚Üë)\n  map_smul' := inr_smul R\n  map_zero' := inr_zero R\n  map_add' := inr_add R\n  map_mul' := inr_mul R\n\n"}
{"name":"Unitization.inrNonUnitalAlgHom_apply","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù¬≤ : CommSemiring R\ninst‚úù¬π : NonUnitalSemiring A\ninst‚úù : Module R A\na : A\n‚ä¢ Eq ((Unitization.inrNonUnitalAlgHom R A) a) ‚Üëa","decl":"/-- The coercion from a non-unital `R`-algebra `A` to its unitization `Unitization R A`\nrealized as a non-unital algebra homomorphism. -/\n@[simps]\ndef inrNonUnitalAlgHom (R A : Type*) [CommSemiring R] [NonUnitalSemiring A] [Module R A] :\n    A ‚Üí‚Çô‚Çê[R] Unitization R A where\n  toFun := (‚Üë)\n  map_smul' := inr_smul R\n  map_zero' := inr_zero R\n  map_add' := inr_add R\n  map_mul' := inr_mul R\n\n"}
{"name":"Unitization.inrNonUnitalStarAlgHom_apply","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù‚Å¥ : CommSemiring R\ninst‚úù¬≥ : StarAddMonoid R\ninst‚úù¬≤ : NonUnitalSemiring A\ninst‚úù¬π : Star A\ninst‚úù : Module R A\na : A\n‚ä¢ Eq ((Unitization.inrNonUnitalStarAlgHom R A) a) ‚Üëa","decl":"/-- The coercion from a non-unital `R`-algebra `A` to its unitization `Unitization R A`\nrealized as a non-unital star algebra homomorphism. -/\n@[simps!]\ndef inrNonUnitalStarAlgHom (R A : Type*) [CommSemiring R] [StarAddMonoid R]\n    [NonUnitalSemiring A] [Star A] [Module R A] :\n    A ‚Üí‚ãÜ‚Çô‚Çê[R] Unitization R A where\n  toNonUnitalAlgHom := inrNonUnitalAlgHom R A\n  map_star' := inr_star\n\n"}
{"name":"Unitization.inrRangeEquiv_apply_coe","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù‚Å∂ : CommSemiring R\ninst‚úù‚Åµ : StarAddMonoid R\ninst‚úù‚Å¥ : NonUnitalSemiring A\ninst‚úù¬≥ : Star A\ninst‚úù¬≤ : Module R A\ninst‚úù¬π : IsScalarTower R A A\ninst‚úù : SMulCommClass R A A\na : A\n‚ä¢ Eq (‚Üë((Unitization.inrRangeEquiv R A) a)) (‚Üë(Unitization.inrNonUnitalStarAlgHom R A) a)","decl":"/-- The star algebra equivalence obtained by restricting `Unitization.inrNonUnitalStarAlgHom`\nto its range. -/\n@[simps!]\ndef inrRangeEquiv (R A : Type*) [CommSemiring R] [StarAddMonoid R] [NonUnitalSemiring A]\n    [Star A] [Module R A] [IsScalarTower R A A] [SMulCommClass R A A] :\n    A ‚âÉ‚ãÜ‚Çê[R] NonUnitalStarAlgHom.range (inrNonUnitalStarAlgHom R A) :=\n  StarAlgEquiv.ofLeftInverse' (snd_inr R)\n\n"}
{"name":"Unitization.inrRangeEquiv_symm_apply","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù‚Å∂ : CommSemiring R\ninst‚úù‚Åµ : StarAddMonoid R\ninst‚úù‚Å¥ : NonUnitalSemiring A\ninst‚úù¬≥ : Star A\ninst‚úù¬≤ : Module R A\ninst‚úù¬π : IsScalarTower R A A\ninst‚úù : SMulCommClass R A A\na‚úù : Subtype fun x => Membership.mem (NonUnitalStarAlgHom.range (Unitization.inrNonUnitalStarAlgHom R A)) x\n‚ä¢ Eq ((Unitization.inrRangeEquiv R A).symm a‚úù) (‚Üëa‚úù).snd","decl":"/-- The star algebra equivalence obtained by restricting `Unitization.inrNonUnitalStarAlgHom`\nto its range. -/\n@[simps!]\ndef inrRangeEquiv (R A : Type*) [CommSemiring R] [StarAddMonoid R] [NonUnitalSemiring A]\n    [Star A] [Module R A] [IsScalarTower R A A] [SMulCommClass R A A] :\n    A ‚âÉ‚ãÜ‚Çê[R] NonUnitalStarAlgHom.range (inrNonUnitalStarAlgHom R A) :=\n  StarAlgEquiv.ofLeftInverse' (snd_inr R)\n\n"}
{"name":"Unitization.algHom_ext","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"S : Type u_1\nR : Type u_2\nA : Type u_3\ninst‚úù¬π¬≤ : CommSemiring S\ninst‚úù¬π¬π : CommSemiring R\ninst‚úù¬π‚Å∞ : NonUnitalSemiring A\ninst‚úù‚Åπ : Module R A\ninst‚úù‚Å∏ : SMulCommClass R A A\ninst‚úù‚Å∑ : IsScalarTower R A A\nB : Type u_4\ninst‚úù‚Å∂ : Semiring B\ninst‚úù‚Åµ : Algebra S B\ninst‚úù‚Å¥ : Algebra S R\ninst‚úù¬≥ : DistribMulAction S A\ninst‚úù¬≤ : IsScalarTower S R A\nF : Type u_6\ninst‚úù¬π : FunLike F (Unitization R A) B\ninst‚úù : AlgHomClass F S (Unitization R A) B\nœÜ œà : F\nh : ‚àÄ (a : A), Eq (œÜ ‚Üëa) (œà ‚Üëa)\nh' : ‚àÄ (r : R), Eq (œÜ ((algebraMap R (Unitization R A)) r)) (œà ((algebraMap R (Unitization R A)) r))\n‚ä¢ Eq œÜ œà","decl":"theorem algHom_ext {F : Type*}\n    [FunLike F (Unitization R A) B] [AlgHomClass F S (Unitization R A) B] {œÜ œà : F}\n    (h : ‚àÄ a : A, œÜ a = œà a)\n    (h' : ‚àÄ r, œÜ (algebraMap R (Unitization R A) r) = œà (algebraMap R (Unitization R A) r)) :\n    œÜ = œà := by\n  refine DFunLike.ext œÜ œà (fun x ‚Ü¶ ?_)\n  induction x\n  simp only [map_add, ‚Üê algebraMap_eq_inl, h, h']\n\n"}
{"name":"Unitization.algHom_ext''","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_2\nA : Type u_3\ninst‚úù‚Å∏ : CommSemiring R\ninst‚úù‚Å∑ : NonUnitalSemiring A\ninst‚úù‚Å∂ : Module R A\ninst‚úù‚Åµ : SMulCommClass R A A\ninst‚úù‚Å¥ : IsScalarTower R A A\nC : Type u_5\ninst‚úù¬≥ : Semiring C\ninst‚úù¬≤ : Algebra R C\nF : Type u_6\ninst‚úù¬π : FunLike F (Unitization R A) C\ninst‚úù : AlgHomClass F R (Unitization R A) C\nœÜ œà : F\nh : ‚àÄ (a : A), Eq (œÜ ‚Üëa) (œà ‚Üëa)\n‚ä¢ Eq œÜ œà","decl":"lemma algHom_ext'' {F : Type*}\n    [FunLike F (Unitization R A) C] [AlgHomClass F R (Unitization R A) C] {œÜ œà : F}\n    (h : ‚àÄ a : A, œÜ a = œà a) : œÜ = œà :=\n  algHom_ext h (fun r => by simp only [AlgHomClass.commutes])\n\n"}
{"name":"Unitization.algHom_ext'_iff","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_2\nA : Type u_3\ninst‚úù‚Å∂ : CommSemiring R\ninst‚úù‚Åµ : NonUnitalSemiring A\ninst‚úù‚Å¥ : Module R A\ninst‚úù¬≥ : SMulCommClass R A A\ninst‚úù¬≤ : IsScalarTower R A A\nC : Type u_5\ninst‚úù¬π : Semiring C\ninst‚úù : Algebra R C\nœÜ œà : AlgHom R (Unitization R A) C\n‚ä¢ Iff (Eq œÜ œà) (Eq ((‚ÜëœÜ).comp (Unitization.inrNonUnitalAlgHom R A)) ((‚Üëœà).comp (Unitization.inrNonUnitalAlgHom R A)))","decl":"/-- See note [partially-applied ext lemmas] -/\n@[ext 1100]\ntheorem algHom_ext' {œÜ œà : Unitization R A ‚Üí‚Çê[R] C}\n    (h :\n      œÜ.toNonUnitalAlgHom.comp (inrNonUnitalAlgHom R A) =\n        œà.toNonUnitalAlgHom.comp (inrNonUnitalAlgHom R A)) :\n    œÜ = œà :=\n  algHom_ext'' (NonUnitalAlgHom.congr_fun h)\n\n/- porting note: this was extracted from `Unitization.lift` below, where it had previously\nbeen inlined. Unfortunately, `Unitization.lift` was relatively slow in Lean 3, but in Lean 4 it\njust times out. -/\n"}
{"name":"Unitization.algHom_ext'","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_2\nA : Type u_3\ninst‚úù‚Å∂ : CommSemiring R\ninst‚úù‚Åµ : NonUnitalSemiring A\ninst‚úù‚Å¥ : Module R A\ninst‚úù¬≥ : SMulCommClass R A A\ninst‚úù¬≤ : IsScalarTower R A A\nC : Type u_5\ninst‚úù¬π : Semiring C\ninst‚úù : Algebra R C\nœÜ œà : AlgHom R (Unitization R A) C\nh : Eq ((‚ÜëœÜ).comp (Unitization.inrNonUnitalAlgHom R A)) ((‚Üëœà).comp (Unitization.inrNonUnitalAlgHom R A))\n‚ä¢ Eq œÜ œà","decl":"/-- See note [partially-applied ext lemmas] -/\n@[ext 1100]\ntheorem algHom_ext' {œÜ œà : Unitization R A ‚Üí‚Çê[R] C}\n    (h :\n      œÜ.toNonUnitalAlgHom.comp (inrNonUnitalAlgHom R A) =\n        œà.toNonUnitalAlgHom.comp (inrNonUnitalAlgHom R A)) :\n    œÜ = œà :=\n  algHom_ext'' (NonUnitalAlgHom.congr_fun h)\n\n/- porting note: this was extracted from `Unitization.lift` below, where it had previously\nbeen inlined. Unfortunately, `Unitization.lift` was relatively slow in Lean 3, but in Lean 4 it\njust times out. -/\n"}
{"name":"NonUnitalAlgHom.toAlgHom_apply","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_2\nA : Type u_3\ninst‚úù‚Å∂ : CommSemiring R\ninst‚úù‚Åµ : NonUnitalSemiring A\ninst‚úù‚Å¥ : Module R A\ninst‚úù¬≥ : SMulCommClass R A A\ninst‚úù¬≤ : IsScalarTower R A A\nC : Type u_5\ninst‚úù¬π : Semiring C\ninst‚úù : Algebra R C\nœÜ : NonUnitalAlgHom (MonoidHom.id R) A C\nx : Unitization R A\n‚ä¢ Eq (œÜ.toAlgHom x) (HAdd.hAdd ((algebraMap R C) x.fst) (œÜ x.snd))","decl":"/-- A non-unital algebra homomorphism from `A` into a unital `R`-algebra `C` lifts to a unital\nalgebra homomorphism from the unitization into `C`. This is extended to an `Equiv` in\n`Unitization.lift` and that should be used instead. This declaration only exists for performance\nreasons. -/\n@[simps]\ndef _root_.NonUnitalAlgHom.toAlgHom (œÜ : A ‚Üí‚Çô‚Çê[R] C) : Unitization R A ‚Üí‚Çê[R] C where\n  toFun := fun x => algebraMap R C x.fst + œÜ x.snd\n  map_one' := by simp only [fst_one, map_one, snd_one, œÜ.map_zero, add_zero]\n  map_mul' := fun x y => by\n    induction x with\n    | inl_add_inr x_r x_a =>\n      induction y with\n      | inl_add_inr =>\n        simp only [fst_mul, fst_add, fst_inl, fst_inr, snd_mul, snd_add, snd_inl, snd_inr, add_zero,\n          map_mul, zero_add, map_add, map_smul œÜ]\n        rw [add_mul, mul_add, mul_add]\n        rw [‚Üê Algebra.commutes _ (œÜ x_a)]\n        simp only [Algebra.algebraMap_eq_smul_one, smul_one_mul, add_assoc]\n  map_zero' := by simp only [fst_zero, map_zero, snd_zero, œÜ.map_zero, add_zero]\n  map_add' := fun x y => by\n    induction x with\n    | inl_add_inr =>\n      induction y with\n      | inl_add_inr =>\n        simp only [fst_add, fst_inl, fst_inr, add_zero, map_add, snd_add, snd_inl, snd_inr,\n          zero_add, œÜ.map_add]\n        rw [add_add_add_comm]\n  commutes' := fun r => by\n    simp only [algebraMap_eq_inl, fst_inl, snd_inl, œÜ.map_zero, add_zero]\n\n\n"}
{"name":"Unitization.lift_symm_apply","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_2\nA : Type u_3\ninst‚úù‚Å∂ : CommSemiring R\ninst‚úù‚Åµ : NonUnitalSemiring A\ninst‚úù‚Å¥ : Module R A\ninst‚úù¬≥ : SMulCommClass R A A\ninst‚úù¬≤ : IsScalarTower R A A\nC : Type u_5\ninst‚úù¬π : Semiring C\ninst‚úù : Algebra R C\nœÜ : AlgHom R (Unitization R A) C\n‚ä¢ Eq (Unitization.lift.symm œÜ) ((NonUnitalAlgHomClass.toNonUnitalAlgHom œÜ).comp (Unitization.inrNonUnitalAlgHom R A))","decl":"/-- Non-unital algebra homomorphisms from `A` into a unital `R`-algebra `C` lift uniquely to\n`Unitization R A ‚Üí‚Çê[R] C`. This is the universal property of the unitization. -/\n@[simps! apply symm_apply apply_apply]\ndef lift : (A ‚Üí‚Çô‚Çê[R] C) ‚âÉ (Unitization R A ‚Üí‚Çê[R] C) where\n  toFun := NonUnitalAlgHom.toAlgHom\n  invFun œÜ := œÜ.toNonUnitalAlgHom.comp (inrNonUnitalAlgHom R A)\n  left_inv œÜ := by ext; simp [NonUnitalAlgHomClass.toNonUnitalAlgHom]\n  right_inv œÜ := by ext; simp [NonUnitalAlgHomClass.toNonUnitalAlgHom]\n\n"}
{"name":"Unitization.lift_apply","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_2\nA : Type u_3\ninst‚úù‚Å∂ : CommSemiring R\ninst‚úù‚Åµ : NonUnitalSemiring A\ninst‚úù‚Å¥ : Module R A\ninst‚úù¬≥ : SMulCommClass R A A\ninst‚úù¬≤ : IsScalarTower R A A\nC : Type u_5\ninst‚úù¬π : Semiring C\ninst‚úù : Algebra R C\nœÜ : NonUnitalAlgHom (MonoidHom.id R) A C\n‚ä¢ Eq (Unitization.lift œÜ) œÜ.toAlgHom","decl":"/-- Non-unital algebra homomorphisms from `A` into a unital `R`-algebra `C` lift uniquely to\n`Unitization R A ‚Üí‚Çê[R] C`. This is the universal property of the unitization. -/\n@[simps! apply symm_apply apply_apply]\ndef lift : (A ‚Üí‚Çô‚Çê[R] C) ‚âÉ (Unitization R A ‚Üí‚Çê[R] C) where\n  toFun := NonUnitalAlgHom.toAlgHom\n  invFun œÜ := œÜ.toNonUnitalAlgHom.comp (inrNonUnitalAlgHom R A)\n  left_inv œÜ := by ext; simp [NonUnitalAlgHomClass.toNonUnitalAlgHom]\n  right_inv œÜ := by ext; simp [NonUnitalAlgHomClass.toNonUnitalAlgHom]\n\n"}
{"name":"Unitization.lift_apply_apply","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_2\nA : Type u_3\ninst‚úù‚Å∂ : CommSemiring R\ninst‚úù‚Åµ : NonUnitalSemiring A\ninst‚úù‚Å¥ : Module R A\ninst‚úù¬≥ : SMulCommClass R A A\ninst‚úù¬≤ : IsScalarTower R A A\nC : Type u_5\ninst‚úù¬π : Semiring C\ninst‚úù : Algebra R C\nœÜ : NonUnitalAlgHom (MonoidHom.id R) A C\nx : Unitization R A\n‚ä¢ Eq ((Unitization.lift œÜ) x) (HAdd.hAdd ((algebraMap R C) x.fst) (œÜ x.snd))","decl":"/-- Non-unital algebra homomorphisms from `A` into a unital `R`-algebra `C` lift uniquely to\n`Unitization R A ‚Üí‚Çê[R] C`. This is the universal property of the unitization. -/\n@[simps! apply symm_apply apply_apply]\ndef lift : (A ‚Üí‚Çô‚Çê[R] C) ‚âÉ (Unitization R A ‚Üí‚Çê[R] C) where\n  toFun := NonUnitalAlgHom.toAlgHom\n  invFun œÜ := œÜ.toNonUnitalAlgHom.comp (inrNonUnitalAlgHom R A)\n  left_inv œÜ := by ext; simp [NonUnitalAlgHomClass.toNonUnitalAlgHom]\n  right_inv œÜ := by ext; simp [NonUnitalAlgHomClass.toNonUnitalAlgHom]\n\n"}
{"name":"Unitization.lift_symm_apply_apply","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_2\nA : Type u_3\ninst‚úù‚Å∂ : CommSemiring R\ninst‚úù‚Åµ : NonUnitalSemiring A\ninst‚úù‚Å¥ : Module R A\ninst‚úù¬≥ : SMulCommClass R A A\ninst‚úù¬≤ : IsScalarTower R A A\nC : Type u_5\ninst‚úù¬π : Semiring C\ninst‚úù : Algebra R C\nœÜ : AlgHom R (Unitization R A) C\na : A\n‚ä¢ Eq ((Unitization.lift.symm œÜ) a) (œÜ ‚Üëa)","decl":"theorem lift_symm_apply_apply (œÜ : Unitization R A ‚Üí‚Çê[R] C) (a : A) :\n    Unitization.lift.symm œÜ a = œÜ a :=\n  rfl\n\n"}
{"name":"NonUnitalAlgHom.toAlgHom_zero","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_2\nA : Type u_3\ninst‚úù‚Å¥ : CommSemiring R\ninst‚úù¬≥ : NonUnitalSemiring A\ninst‚úù¬≤ : Module R A\ninst‚úù¬π : SMulCommClass R A A\ninst‚úù : IsScalarTower R A A\n‚ä¢ Eq (‚áë(NonUnitalAlgHom.toAlgHom 0)) Unitization.fst","decl":"@[simp]\nlemma _root_.NonUnitalAlgHom.toAlgHom_zero :\n    ‚áë(0 : A ‚Üí‚Çô‚Çê[R] R).toAlgHom = Unitization.fst := by\n  ext\n  simp\n\n"}
{"name":"Unitization.starAlgHom_ext_iff","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\nC : Type u_3\ninst‚úù‚Åπ : CommSemiring R\ninst‚úù‚Å∏ : StarRing R\ninst‚úù‚Å∑ : NonUnitalSemiring A\ninst‚úù‚Å∂ : StarRing A\ninst‚úù‚Åµ : Module R A\ninst‚úù‚Å¥ : SMulCommClass R A A\ninst‚úù¬≥ : IsScalarTower R A A\ninst‚úù¬≤ : Semiring C\ninst‚úù¬π : Algebra R C\ninst‚úù : StarRing C\nœÜ œà : StarAlgHom R (Unitization R A) C\n‚ä¢ Iff (Eq œÜ œà) (Eq ((‚ÜëœÜ).comp (Unitization.inrNonUnitalStarAlgHom R A)) ((‚Üëœà).comp (Unitization.inrNonUnitalStarAlgHom R A)))","decl":"/-- See note [partially-applied ext lemmas] -/\n@[ext]\ntheorem starAlgHom_ext {œÜ œà : Unitization R A ‚Üí‚ãÜ‚Çê[R] C}\n    (h : (œÜ : Unitization R A ‚Üí‚ãÜ‚Çô‚Çê[R] C).comp (Unitization.inrNonUnitalStarAlgHom R A) =\n      (œà : Unitization R A ‚Üí‚ãÜ‚Çô‚Çê[R] C).comp (Unitization.inrNonUnitalStarAlgHom R A)) :\n    œÜ = œà :=\n  Unitization.algHom_ext'' <| DFunLike.congr_fun h\n\n"}
{"name":"Unitization.starAlgHom_ext","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\nC : Type u_3\ninst‚úù‚Åπ : CommSemiring R\ninst‚úù‚Å∏ : StarRing R\ninst‚úù‚Å∑ : NonUnitalSemiring A\ninst‚úù‚Å∂ : StarRing A\ninst‚úù‚Åµ : Module R A\ninst‚úù‚Å¥ : SMulCommClass R A A\ninst‚úù¬≥ : IsScalarTower R A A\ninst‚úù¬≤ : Semiring C\ninst‚úù¬π : Algebra R C\ninst‚úù : StarRing C\nœÜ œà : StarAlgHom R (Unitization R A) C\nh : Eq ((‚ÜëœÜ).comp (Unitization.inrNonUnitalStarAlgHom R A)) ((‚Üëœà).comp (Unitization.inrNonUnitalStarAlgHom R A))\n‚ä¢ Eq œÜ œà","decl":"/-- See note [partially-applied ext lemmas] -/\n@[ext]\ntheorem starAlgHom_ext {œÜ œà : Unitization R A ‚Üí‚ãÜ‚Çê[R] C}\n    (h : (œÜ : Unitization R A ‚Üí‚ãÜ‚Çô‚Çê[R] C).comp (Unitization.inrNonUnitalStarAlgHom R A) =\n      (œà : Unitization R A ‚Üí‚ãÜ‚Çô‚Çê[R] C).comp (Unitization.inrNonUnitalStarAlgHom R A)) :\n    œÜ = œà :=\n  Unitization.algHom_ext'' <| DFunLike.congr_fun h\n\n"}
{"name":"Unitization.starLift_symm_apply","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\nC : Type u_3\ninst‚úù‚Åπ : CommSemiring R\ninst‚úù‚Å∏ : StarRing R\ninst‚úù‚Å∑ : NonUnitalSemiring A\ninst‚úù‚Å∂ : StarRing A\ninst‚úù‚Åµ : Module R A\ninst‚úù‚Å¥ : SMulCommClass R A A\ninst‚úù¬≥ : IsScalarTower R A A\ninst‚úù¬≤ : Semiring C\ninst‚úù¬π : Algebra R C\ninst‚úù : StarRing C\nœÜ : StarAlgHom R (Unitization R A) C\n‚ä¢ Eq (Unitization.starLift.symm œÜ) (œÜ.toNonUnitalStarAlgHom.comp (Unitization.inrNonUnitalStarAlgHom R A))","decl":"/-- Non-unital star algebra homomorphisms from `A` into a unital star `R`-algebra `C` lift uniquely\nto `Unitization R A ‚Üí‚ãÜ‚Çê[R] C`. This is the universal property of the unitization. -/\n@[simps! apply symm_apply apply_apply]\ndef starLift : (A ‚Üí‚ãÜ‚Çô‚Çê[R] C) ‚âÉ (Unitization R A ‚Üí‚ãÜ‚Çê[R] C) :=\n{ toFun := fun œÜ ‚Ü¶\n  { toAlgHom := Unitization.lift œÜ.toNonUnitalAlgHom\n    map_star' := fun x => by\n      induction x\n      simp [map_star] }\n  invFun := fun œÜ ‚Ü¶ œÜ.toNonUnitalStarAlgHom.comp (inrNonUnitalStarAlgHom R A),\n  left_inv := fun œÜ => by ext; simp,\n  right_inv := fun œÜ => Unitization.algHom_ext'' <| by\n    simp }\n\n"}
{"name":"Unitization.starLift_apply","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\nC : Type u_3\ninst‚úù‚Åπ : CommSemiring R\ninst‚úù‚Å∏ : StarRing R\ninst‚úù‚Å∑ : NonUnitalSemiring A\ninst‚úù‚Å∂ : StarRing A\ninst‚úù‚Åµ : Module R A\ninst‚úù‚Å¥ : SMulCommClass R A A\ninst‚úù¬≥ : IsScalarTower R A A\ninst‚úù¬≤ : Semiring C\ninst‚úù¬π : Algebra R C\ninst‚úù : StarRing C\nœÜ : NonUnitalStarAlgHom R A C\n‚ä¢ Eq (Unitization.starLift œÜ) { toAlgHom := œÜ.toAlgHom, map_star' := ‚ãØ }","decl":"/-- Non-unital star algebra homomorphisms from `A` into a unital star `R`-algebra `C` lift uniquely\nto `Unitization R A ‚Üí‚ãÜ‚Çê[R] C`. This is the universal property of the unitization. -/\n@[simps! apply symm_apply apply_apply]\ndef starLift : (A ‚Üí‚ãÜ‚Çô‚Çê[R] C) ‚âÉ (Unitization R A ‚Üí‚ãÜ‚Çê[R] C) :=\n{ toFun := fun œÜ ‚Ü¶\n  { toAlgHom := Unitization.lift œÜ.toNonUnitalAlgHom\n    map_star' := fun x => by\n      induction x\n      simp [map_star] }\n  invFun := fun œÜ ‚Ü¶ œÜ.toNonUnitalStarAlgHom.comp (inrNonUnitalStarAlgHom R A),\n  left_inv := fun œÜ => by ext; simp,\n  right_inv := fun œÜ => Unitization.algHom_ext'' <| by\n    simp }\n\n"}
{"name":"Unitization.starLift_apply_apply","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\nC : Type u_3\ninst‚úù‚Åπ : CommSemiring R\ninst‚úù‚Å∏ : StarRing R\ninst‚úù‚Å∑ : NonUnitalSemiring A\ninst‚úù‚Å∂ : StarRing A\ninst‚úù‚Åµ : Module R A\ninst‚úù‚Å¥ : SMulCommClass R A A\ninst‚úù¬≥ : IsScalarTower R A A\ninst‚úù¬≤ : Semiring C\ninst‚úù¬π : Algebra R C\ninst‚úù : StarRing C\nœÜ : NonUnitalStarAlgHom R A C\nx : Unitization R A\n‚ä¢ Eq ((Unitization.starLift œÜ) x) (HAdd.hAdd ((algebraMap R C) x.fst) (œÜ x.snd))","decl":"/-- Non-unital star algebra homomorphisms from `A` into a unital star `R`-algebra `C` lift uniquely\nto `Unitization R A ‚Üí‚ãÜ‚Çê[R] C`. This is the universal property of the unitization. -/\n@[simps! apply symm_apply apply_apply]\ndef starLift : (A ‚Üí‚ãÜ‚Çô‚Çê[R] C) ‚âÉ (Unitization R A ‚Üí‚ãÜ‚Çê[R] C) :=\n{ toFun := fun œÜ ‚Ü¶\n  { toAlgHom := Unitization.lift œÜ.toNonUnitalAlgHom\n    map_star' := fun x => by\n      induction x\n      simp [map_star] }\n  invFun := fun œÜ ‚Ü¶ œÜ.toNonUnitalStarAlgHom.comp (inrNonUnitalStarAlgHom R A),\n  left_inv := fun œÜ => by ext; simp,\n  right_inv := fun œÜ => Unitization.algHom_ext'' <| by\n    simp }\n\n"}
{"name":"Unitization.starLift_symm_apply_apply","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\nC : Type u_3\ninst‚úù¬π‚Å∞ : CommSemiring R\ninst‚úù‚Åπ : StarRing R\ninst‚úù‚Å∏ : NonUnitalSemiring A\ninst‚úù‚Å∑ : StarRing A\ninst‚úù‚Å∂ : Module R A\ninst‚úù‚Åµ : SMulCommClass R A A\ninst‚úù‚Å¥ : IsScalarTower R A A\ninst‚úù¬≥ : Semiring C\ninst‚úù¬≤ : Algebra R C\ninst‚úù¬π : StarRing C\ninst‚úù : StarModule R C\nœÜ : StarAlgHom R (Unitization R A) C\na : A\n‚ä¢ Eq ((Unitization.starLift.symm œÜ) a) (œÜ ‚Üëa)","decl":"@[simp high]\ntheorem starLift_symm_apply_apply (œÜ : Unitization R A ‚Üí‚ãÜ‚Çê[R] C) (a : A) :\n    Unitization.starLift.symm œÜ a = œÜ a :=\n  rfl\n\n"}
{"name":"Unitization.starMap_apply","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst‚úù¬π¬≤ : CommSemiring R\ninst‚úù¬π¬π : StarRing R\ninst‚úù¬π‚Å∞ : NonUnitalSemiring A\ninst‚úù‚Åπ : StarRing A\ninst‚úù‚Å∏ : Module R A\ninst‚úù‚Å∑ : SMulCommClass R A A\ninst‚úù‚Å∂ : IsScalarTower R A A\ninst‚úù‚Åµ : NonUnitalSemiring B\ninst‚úù‚Å¥ : StarRing B\ninst‚úù¬≥ : Module R B\ninst‚úù¬≤ : SMulCommClass R B B\ninst‚úù¬π : IsScalarTower R B B\ninst‚úù : StarModule R B\nœÜ : NonUnitalStarAlgHom R A B\nx : Unitization R A\n‚ä¢ Eq ((Unitization.starMap œÜ) x) (HAdd.hAdd ((algebraMap R (Unitization R B)) x.fst) ‚Üë(œÜ x.snd))","decl":"/-- The functorial map on morphisms between the category of non-unital C‚ãÜ-algebras with non-unital\nstar homomorphisms and unital C‚ãÜ-algebras with unital star homomorphisms.\n\nThis sends `œÜ : A ‚Üí‚ãÜ‚Çô‚Çê[R] B` to a map `Unitization R A ‚Üí‚ãÜ‚Çê[R] Unitization R B` given by the formula\n`(r, a) ‚Ü¶ (r, œÜ a)` (or perhaps more precisely,\n`algebraMap R _ r + ‚Üëa ‚Ü¶ algebraMap R _ r + ‚Üë(œÜ a)`). -/\n@[simps!]\ndef starMap (œÜ : A ‚Üí‚ãÜ‚Çô‚Çê[R] B) : Unitization R A ‚Üí‚ãÜ‚Çê[R] Unitization R B :=\n  Unitization.starLift <| (Unitization.inrNonUnitalStarAlgHom R B).comp œÜ\n\n"}
{"name":"Unitization.starMap_inr","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst‚úù¬π¬≤ : CommSemiring R\ninst‚úù¬π¬π : StarRing R\ninst‚úù¬π‚Å∞ : NonUnitalSemiring A\ninst‚úù‚Åπ : StarRing A\ninst‚úù‚Å∏ : Module R A\ninst‚úù‚Å∑ : SMulCommClass R A A\ninst‚úù‚Å∂ : IsScalarTower R A A\ninst‚úù‚Åµ : NonUnitalSemiring B\ninst‚úù‚Å¥ : StarRing B\ninst‚úù¬≥ : Module R B\ninst‚úù¬≤ : SMulCommClass R B B\ninst‚úù¬π : IsScalarTower R B B\ninst‚úù : StarModule R B\nœÜ : NonUnitalStarAlgHom R A B\na : A\n‚ä¢ Eq ((Unitization.starMap œÜ) ‚Üëa) ‚Üë(œÜ a)","decl":"@[simp high]\nlemma starMap_inr (œÜ : A ‚Üí‚ãÜ‚Çô‚Çê[R] B) (a : A) :\n    starMap œÜ (inr a) = inr (œÜ a) := by\n  simp\n\n"}
{"name":"Unitization.starMap_inl","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst‚úù¬π¬≤ : CommSemiring R\ninst‚úù¬π¬π : StarRing R\ninst‚úù¬π‚Å∞ : NonUnitalSemiring A\ninst‚úù‚Åπ : StarRing A\ninst‚úù‚Å∏ : Module R A\ninst‚úù‚Å∑ : SMulCommClass R A A\ninst‚úù‚Å∂ : IsScalarTower R A A\ninst‚úù‚Åµ : NonUnitalSemiring B\ninst‚úù‚Å¥ : StarRing B\ninst‚úù¬≥ : Module R B\ninst‚úù¬≤ : SMulCommClass R B B\ninst‚úù¬π : IsScalarTower R B B\ninst‚úù : StarModule R B\nœÜ : NonUnitalStarAlgHom R A B\nr : R\n‚ä¢ Eq ((Unitization.starMap œÜ) (Unitization.inl r)) ((algebraMap R (Unitization R B)) r)","decl":"@[simp high]\nlemma starMap_inl (œÜ : A ‚Üí‚ãÜ‚Çô‚Çê[R] B) (r : R) :\n    starMap œÜ (inl r) = algebraMap R (Unitization R B) r := by\n  simp\n\n"}
{"name":"Unitization.starMap_injective","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst‚úù¬π¬≤ : CommSemiring R\ninst‚úù¬π¬π : StarRing R\ninst‚úù¬π‚Å∞ : NonUnitalSemiring A\ninst‚úù‚Åπ : StarRing A\ninst‚úù‚Å∏ : Module R A\ninst‚úù‚Å∑ : SMulCommClass R A A\ninst‚úù‚Å∂ : IsScalarTower R A A\ninst‚úù‚Åµ : NonUnitalSemiring B\ninst‚úù‚Å¥ : StarRing B\ninst‚úù¬≥ : Module R B\ninst‚úù¬≤ : SMulCommClass R B B\ninst‚úù¬π : IsScalarTower R B B\ninst‚úù : StarModule R B\nœÜ : NonUnitalStarAlgHom R A B\nhœÜ : Function.Injective ‚áëœÜ\n‚ä¢ Function.Injective ‚áë(Unitization.starMap œÜ)","decl":"/-- If `œÜ : A ‚Üí‚ãÜ‚Çô‚Çê[R] B` is injective, the lift `starMap œÜ : Unitization R A ‚Üí‚ãÜ‚Çê[R] Unitization R B`\nis also injective. -/\nlemma starMap_injective {œÜ : A ‚Üí‚ãÜ‚Çô‚Çê[R] B} (hœÜ : Function.Injective œÜ) :\n    Function.Injective (starMap œÜ) := by\n  intro x y h\n  ext\n  ¬∑ simpa using congr(fst $(h))\n  ¬∑ exact hœÜ <| by simpa [algebraMap_eq_inl] using congr(snd $(h))\n\n"}
{"name":"Unitization.starMap_surjective","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst‚úù¬π¬≤ : CommSemiring R\ninst‚úù¬π¬π : StarRing R\ninst‚úù¬π‚Å∞ : NonUnitalSemiring A\ninst‚úù‚Åπ : StarRing A\ninst‚úù‚Å∏ : Module R A\ninst‚úù‚Å∑ : SMulCommClass R A A\ninst‚úù‚Å∂ : IsScalarTower R A A\ninst‚úù‚Åµ : NonUnitalSemiring B\ninst‚úù‚Å¥ : StarRing B\ninst‚úù¬≥ : Module R B\ninst‚úù¬≤ : SMulCommClass R B B\ninst‚úù¬π : IsScalarTower R B B\ninst‚úù : StarModule R B\nœÜ : NonUnitalStarAlgHom R A B\nhœÜ : Function.Surjective ‚áëœÜ\n‚ä¢ Function.Surjective ‚áë(Unitization.starMap œÜ)","decl":"/-- If `œÜ : A ‚Üí‚ãÜ‚Çô‚Çê[R] B` is surjective, the lift\n`starMap œÜ : Unitization R A ‚Üí‚ãÜ‚Çê[R] Unitization R B` is also surjective. -/\nlemma starMap_surjective {œÜ : A ‚Üí‚ãÜ‚Çô‚Çê[R] B} (hœÜ : Function.Surjective œÜ) :\n    Function.Surjective (starMap œÜ) := by\n  intro x\n  induction x using Unitization.ind with\n  | inl_add_inr r b =>\n    obtain ‚ü®a, rfl‚ü© := hœÜ b\n    exact ‚ü®(r, a), by rfl‚ü©\n\n"}
{"name":"Unitization.starMap_comp","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nC : Type u_4\ninst‚úù¬π‚Å∏ : CommSemiring R\ninst‚úù¬π‚Å∑ : StarRing R\ninst‚úù¬π‚Å∂ : NonUnitalSemiring A\ninst‚úù¬π‚Åµ : StarRing A\ninst‚úù¬π‚Å¥ : Module R A\ninst‚úù¬π¬≥ : SMulCommClass R A A\ninst‚úù¬π¬≤ : IsScalarTower R A A\ninst‚úù¬π¬π : NonUnitalSemiring B\ninst‚úù¬π‚Å∞ : StarRing B\ninst‚úù‚Åπ : Module R B\ninst‚úù‚Å∏ : SMulCommClass R B B\ninst‚úù‚Å∑ : IsScalarTower R B B\ninst‚úù‚Å∂ : NonUnitalSemiring C\ninst‚úù‚Åµ : StarRing C\ninst‚úù‚Å¥ : Module R C\ninst‚úù¬≥ : SMulCommClass R C C\ninst‚úù¬≤ : IsScalarTower R C C\ninst‚úù¬π : StarModule R B\ninst‚úù : StarModule R C\nœÜ : NonUnitalStarAlgHom R A B\nœà : NonUnitalStarAlgHom R B C\n‚ä¢ Eq (Unitization.starMap (œà.comp œÜ)) ((Unitization.starMap œà).comp (Unitization.starMap œÜ))","decl":"/-- `starMap` is functorial: `starMap (œà.comp œÜ) = (starMap œà).comp (starMap œÜ)`. -/\nlemma starMap_comp {œÜ : A ‚Üí‚ãÜ‚Çô‚Çê[R] B} {œà : B ‚Üí‚ãÜ‚Çô‚Çê[R] C} :\n    starMap (œà.comp œÜ) = (starMap œà).comp (starMap œÜ) := by\n  ext; all_goals simp\n\n"}
{"name":"Unitization.starMap_id","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nB : Type u_3\ninst‚úù‚Å∑ : CommSemiring R\ninst‚úù‚Å∂ : StarRing R\ninst‚úù‚Åµ : NonUnitalSemiring B\ninst‚úù‚Å¥ : StarRing B\ninst‚úù¬≥ : Module R B\ninst‚úù¬≤ : SMulCommClass R B B\ninst‚úù¬π : IsScalarTower R B B\ninst‚úù : StarModule R B\n‚ä¢ Eq (Unitization.starMap (NonUnitalStarAlgHom.id R B)) (StarAlgHom.id R (Unitization R B))","decl":"/-- `starMap` is functorial:\n`starMap (NonUnitalStarAlgHom.id R B) = StarAlgHom.id R (Unitization R B)`. -/\n@[simp]\nlemma starMap_id : starMap (NonUnitalStarAlgHom.id R B) = StarAlgHom.id R (Unitization R B) := by\n  ext; all_goals simp\n\n"}
{"name":"Unitization.isSelfAdjoint_inr","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù¬≤ : Semiring R\ninst‚úù¬π : StarAddMonoid R\ninst‚úù : Star A\na : A\n‚ä¢ Iff (IsSelfAdjoint ‚Üëa) (IsSelfAdjoint a)","decl":"@[simp]\nlemma isSelfAdjoint_inr : IsSelfAdjoint (a : Unitization R A) ‚Üî IsSelfAdjoint a := by\n  simp only [isSelfAdjoint_iff, ‚Üê inr_star, ‚Üê inr_mul, inr_injective.eq_iff]\n\n"}
{"name":"IsSelfAdjoint.of_inr","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù¬≤ : Semiring R\ninst‚úù¬π : StarAddMonoid R\ninst‚úù : Star A\na : A\na‚úù : IsSelfAdjoint ‚Üëa\n‚ä¢ IsSelfAdjoint a","decl":"alias ‚ü®_root_.IsSelfAdjoint.of_inr, _‚ü© := isSelfAdjoint_inr\n\n"}
{"name":"IsSelfAdjoint.inr","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù¬≤ : Semiring R\ninst‚úù¬π : StarAddMonoid R\ninst‚úù : Star A\na : A\nha : IsSelfAdjoint a\n‚ä¢ IsSelfAdjoint ‚Üëa","decl":"variable (R) in\nlemma _root_.IsSelfAdjoint.inr (ha : IsSelfAdjoint a) : IsSelfAdjoint (a : Unitization R A) :=\n  isSelfAdjoint_inr.mpr ha\n\n"}
{"name":"Unitization.isStarNormal_inr","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù‚Åµ : Semiring R\ninst‚úù‚Å¥ : StarAddMonoid R\ninst‚úù¬≥ : Star A\na : A\ninst‚úù¬≤ : AddCommMonoid A\ninst‚úù¬π : Mul A\ninst‚úù : SMulWithZero R A\n‚ä¢ Iff (IsStarNormal ‚Üëa) (IsStarNormal a)","decl":"@[simp]\nlemma isStarNormal_inr : IsStarNormal (a : Unitization R A) ‚Üî IsStarNormal a := by\n  simp only [isStarNormal_iff, commute_iff_eq, ‚Üê inr_star, ‚Üê inr_mul, inr_injective.eq_iff]\n\n"}
{"name":"IsStarNormal.of_inr","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù‚Åµ : Semiring R\ninst‚úù‚Å¥ : StarAddMonoid R\ninst‚úù¬≥ : Star A\na : A\ninst‚úù¬≤ : AddCommMonoid A\ninst‚úù¬π : Mul A\ninst‚úù : SMulWithZero R A\na‚úù : IsStarNormal ‚Üëa\n‚ä¢ IsStarNormal a","decl":"alias ‚ü®_root_.IsStarNormal.of_inr, _‚ü© := isStarNormal_inr\n\n"}
{"name":"Unitization.instIsStarNormal","module":"Mathlib.Algebra.Algebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\ninst‚úù‚Å∂ : Semiring R\ninst‚úù‚Åµ : StarAddMonoid R\ninst‚úù‚Å¥ : Star A\ninst‚úù¬≥ : AddCommMonoid A\ninst‚úù¬≤ : Mul A\ninst‚úù¬π : SMulWithZero R A\na : A\ninst‚úù : IsStarNormal a\n‚ä¢ IsStarNormal ‚Üëa","decl":"variable (R a) in\ninstance instIsStarNormal (a : A) [IsStarNormal a] :\n    IsStarNormal (a : Unitization R A) :=\n  isStarNormal_inr.mpr ‚Äπ_‚Ä∫\n\n"}
