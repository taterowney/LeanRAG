{"name":"Orientation.map_apply","module":"Mathlib.LinearAlgebra.Orientation","initialProofState":"R : Type u_1\ninst✝⁴ : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_4\ne : LinearEquiv (RingHom.id R) M N\nv : AlternatingMap R M R ι\nhv : Ne v 0\n⊢ Eq ((Orientation.map ι e) (rayOfNeZero R v hv)) (rayOfNeZero R (v.compLinearMap ↑e.symm) ⋯)","decl":"@[simp]\ntheorem Orientation.map_apply (e : M ≃ₗ[R] N) (v : M [⋀^ι]→ₗ[R] R) (hv : v ≠ 0) :\n    Orientation.map ι e (rayOfNeZero _ v hv) =\n      rayOfNeZero _ (v.compLinearMap e.symm) (mt (v.compLinearEquiv_eq_zero_iff e.symm).mp hv) :=\n  rfl\n\n"}
{"name":"Orientation.map_refl","module":"Mathlib.LinearAlgebra.Orientation","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Type u_4\n⊢ Eq (Orientation.map ι (LinearEquiv.refl R M)) (Equiv.refl (Orientation R M ι))","decl":"@[simp]\ntheorem Orientation.map_refl : (Orientation.map ι <| LinearEquiv.refl R M) = Equiv.refl _ := by\n  rw [Orientation.map, AlternatingMap.domLCongr_refl, Module.Ray.map_refl]\n\n"}
{"name":"Orientation.map_symm","module":"Mathlib.LinearAlgebra.Orientation","initialProofState":"R : Type u_1\ninst✝⁴ : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nι : Type u_4\ne : LinearEquiv (RingHom.id R) M N\n⊢ Eq (Orientation.map ι e).symm (Orientation.map ι e.symm)","decl":"@[simp]\ntheorem Orientation.map_symm (e : M ≃ₗ[R] N) :\n    (Orientation.map ι e).symm = Orientation.map ι e.symm := rfl\n\n"}
{"name":"Orientation.reindex_apply","module":"Mathlib.LinearAlgebra.Orientation","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Type u_4\nι' : Type u_5\ne : Equiv ι ι'\nv : AlternatingMap R M R ι\nhv : Ne v 0\n⊢ Eq ((Orientation.reindex R M e) (rayOfNeZero R v hv)) (rayOfNeZero R (AlternatingMap.domDomCongr e v) ⋯)","decl":"@[simp]\ntheorem Orientation.reindex_apply (e : ι ≃ ι') (v : M [⋀^ι]→ₗ[R] R) (hv : v ≠ 0) :\n    Orientation.reindex R M e (rayOfNeZero _ v hv) =\n      rayOfNeZero _ (v.domDomCongr e) (mt (v.domDomCongr_eq_zero_iff e).mp hv) :=\n  rfl\n\n"}
{"name":"Orientation.reindex_refl","module":"Mathlib.LinearAlgebra.Orientation","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Type u_4\n⊢ Eq (Orientation.reindex R M (Equiv.refl ι)) (Equiv.refl (Orientation R M ι))","decl":"@[simp]\ntheorem Orientation.reindex_refl : (Orientation.reindex R M <| Equiv.refl ι) = Equiv.refl _ := by\n  rw [Orientation.reindex, AlternatingMap.domDomCongrₗ_refl, Module.Ray.map_refl]\n\n"}
{"name":"Orientation.reindex_symm","module":"Mathlib.LinearAlgebra.Orientation","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Type u_4\nι' : Type u_5\ne : Equiv ι ι'\n⊢ Eq (Orientation.reindex R M e).symm (Orientation.reindex R M e.symm)","decl":"@[simp]\ntheorem Orientation.reindex_symm (e : ι ≃ ι') :\n    (Orientation.reindex R M e).symm = Orientation.reindex R M e.symm :=\n  rfl\n\n"}
{"name":"Orientation.map_positiveOrientation_of_isEmpty","module":"Mathlib.LinearAlgebra.Orientation","initialProofState":"R : Type u_1\ninst✝⁵ : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nN : Type u_3\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\nι : Type u_4\ninst✝ : IsEmpty ι\nf : LinearEquiv (RingHom.id R) M N\n⊢ Eq ((Orientation.map ι f) Module.Oriented.positiveOrientation) Module.Oriented.positiveOrientation","decl":"@[simp]\ntheorem Orientation.map_positiveOrientation_of_isEmpty [IsEmpty ι] (f : M ≃ₗ[R] N) :\n    Orientation.map ι f positiveOrientation = positiveOrientation := rfl\n\n"}
{"name":"Orientation.map_of_isEmpty","module":"Mathlib.LinearAlgebra.Orientation","initialProofState":"R : Type u_1\ninst✝³ : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nι : Type u_4\ninst✝ : IsEmpty ι\nx : Orientation R M ι\nf : LinearEquiv (RingHom.id R) M M\n⊢ Eq ((Orientation.map ι f) x) x","decl":"@[simp]\ntheorem Orientation.map_of_isEmpty [IsEmpty ι] (x : Orientation R M ι) (f : M ≃ₗ[R] M) :\n    Orientation.map ι f x = x := by\n  induction' x using Module.Ray.ind with g hg\n  rw [Orientation.map_apply]\n  congr\n  ext i\n  rw [AlternatingMap.compLinearMap_apply]\n  congr\n  simp only [LinearEquiv.coe_coe, eq_iff_true_of_subsingleton]\n\n"}
{"name":"Orientation.map_neg","module":"Mathlib.LinearAlgebra.Orientation","initialProofState":"R : Type u_1\ninst✝⁴ : StrictOrderedCommRing R\nM : Type u_2\nN : Type u_3\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nι : Type u_4\nf : LinearEquiv (RingHom.id R) M N\nx : Orientation R M ι\n⊢ Eq ((Orientation.map ι f) (Neg.neg x)) (Neg.neg ((Orientation.map ι f) x))","decl":"@[simp]\nprotected theorem Orientation.map_neg {ι : Type*} (f : M ≃ₗ[R] N) (x : Orientation R M ι) :\n    Orientation.map ι f (-x) = -Orientation.map ι f x :=\n  Module.Ray.map_neg _ x\n\n"}
{"name":"Orientation.reindex_neg","module":"Mathlib.LinearAlgebra.Orientation","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nι : Type u_4\nι' : Type u_5\ne : Equiv ι ι'\nx : Orientation R M ι\n⊢ Eq ((Orientation.reindex R M e) (Neg.neg x)) (Neg.neg ((Orientation.reindex R M e) x))","decl":"@[simp]\nprotected theorem Orientation.reindex_neg {ι ι' : Type*} (e : ι ≃ ι') (x : Orientation R M ι) :\n    Orientation.reindex R M e (-x) = -Orientation.reindex R M e x :=\n  Module.Ray.map_neg _ x\n\n"}
{"name":"Basis.map_orientation_eq_det_inv_smul","module":"Mathlib.LinearAlgebra.Orientation","initialProofState":"R : Type u_1\ninst✝³ : StrictOrderedCommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nι : Type u_4\ninst✝ : Finite ι\ne : Basis ι R M\nx : Orientation R M ι\nf : LinearEquiv (RingHom.id R) M M\n⊢ Eq ((Orientation.map ι f) x) (HSMul.hSMul (Inv.inv (LinearEquiv.det f)) x)","decl":"/-- The value of `Orientation.map` when the index type has the cardinality of a basis, in terms\nof `f.det`. -/\ntheorem map_orientation_eq_det_inv_smul [Finite ι] (e : Basis ι R M) (x : Orientation R M ι)\n    (f : M ≃ₗ[R] M) : Orientation.map ι f x = (LinearEquiv.det f)⁻¹ • x := by\n  cases nonempty_fintype ι\n  letI := Classical.decEq ι\n  induction' x using Module.Ray.ind with g hg\n  rw [Orientation.map_apply, smul_rayOfNeZero, ray_eq_iff, Units.smul_def,\n    (g.compLinearMap f.symm).eq_smul_basis_det e, g.eq_smul_basis_det e,\n    AlternatingMap.compLinearMap_apply, AlternatingMap.smul_apply,\n    show (fun i ↦ (LinearEquiv.symm f).toLinearMap (e i)) = (LinearEquiv.symm f).toLinearMap ∘ e\n    by rfl, Basis.det_comp, Basis.det_self, mul_one, smul_eq_mul, mul_comm, mul_smul,\n    LinearEquiv.coe_inv_det]\n\n"}
{"name":"Basis.orientation_map","module":"Mathlib.LinearAlgebra.Orientation","initialProofState":"R : Type u_1\ninst✝⁶ : StrictOrderedCommRing R\nM : Type u_2\nN : Type u_3\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\nι : Type u_4\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\ne : Basis ι R M\nf : LinearEquiv (RingHom.id R) M N\n⊢ Eq (e.map f).orientation ((Orientation.map ι f) e.orientation)","decl":"theorem orientation_map (e : Basis ι R M) (f : M ≃ₗ[R] N) :\n    (e.map f).orientation = Orientation.map ι f e.orientation := by\n  simp_rw [Basis.orientation, Orientation.map_apply, Basis.det_map']\n\n"}
{"name":"Basis.orientation_reindex","module":"Mathlib.LinearAlgebra.Orientation","initialProofState":"R : Type u_1\ninst✝⁶ : StrictOrderedCommRing R\nM : Type u_2\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nι : Type u_4\nι' : Type u_5\ninst✝³ : Fintype ι\ninst✝² : DecidableEq ι\ninst✝¹ : Fintype ι'\ninst✝ : DecidableEq ι'\ne : Basis ι R M\neι : Equiv ι ι'\n⊢ Eq (e.reindex eι).orientation ((Orientation.reindex R M eι) e.orientation)","decl":"theorem orientation_reindex (e : Basis ι R M) (eι : ι ≃ ι') :\n    (e.reindex eι).orientation = Orientation.reindex R M eι e.orientation := by\n  simp_rw [Basis.orientation, Orientation.reindex_apply, Basis.det_reindex']\n\n"}
{"name":"Basis.orientation_unitsSMul","module":"Mathlib.LinearAlgebra.Orientation","initialProofState":"R : Type u_1\ninst✝⁴ : StrictOrderedCommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nι : Type u_4\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\ne : Basis ι R M\nw : ι → Units R\n⊢ Eq (e.unitsSMul w).orientation (HSMul.hSMul (Inv.inv (Finset.univ.prod fun i => w i)) e.orientation)","decl":"/-- The orientation given by a basis derived using `units_smul`, in terms of the product of those\nunits. -/\ntheorem orientation_unitsSMul (e : Basis ι R M) (w : ι → Units R) :\n    (e.unitsSMul w).orientation = (∏ i, w i)⁻¹ • e.orientation := by\n  rw [Basis.orientation, Basis.orientation, smul_rayOfNeZero, ray_eq_iff,\n    e.det.eq_smul_basis_det (e.unitsSMul w), det_unitsSMul_self, Units.smul_def, smul_smul]\n  norm_cast\n  simp only [inv_mul_cancel, Units.val_one, one_smul]\n  exact SameRay.rfl\n\n"}
{"name":"Basis.orientation_isEmpty","module":"Mathlib.LinearAlgebra.Orientation","initialProofState":"R : Type u_1\ninst✝⁵ : StrictOrderedCommRing R\nM : Type u_2\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nι : Type u_4\ninst✝² : Fintype ι\ninst✝¹ : DecidableEq ι\ninst✝ : IsEmpty ι\nb : Basis ι R M\n⊢ Eq b.orientation Module.Oriented.positiveOrientation","decl":"@[simp]\ntheorem orientation_isEmpty [IsEmpty ι] (b : Basis ι R M) :\n    b.orientation = positiveOrientation := by\n  rw [Basis.orientation]\n  congr\n  exact b.det_isEmpty\n\n"}
{"name":"Orientation.eq_or_eq_neg_of_isEmpty","module":"Mathlib.LinearAlgebra.Orientation","initialProofState":"R : Type u_1\ninst✝³ : LinearOrderedCommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nι : Type u_3\ninst✝ : IsEmpty ι\no : Orientation R M ι\n⊢ Or (Eq o Module.Oriented.positiveOrientation) (Eq o (Neg.neg Module.Oriented.positiveOrientation))","decl":"/-- A module `M` over a linearly ordered commutative ring has precisely two \"orientations\" with\nrespect to an empty index type. (Note that these are only orientations of `M` of in the conventional\nmathematical sense if `M` is zero-dimensional.) -/\ntheorem eq_or_eq_neg_of_isEmpty [IsEmpty ι] (o : Orientation R M ι) :\n    o = positiveOrientation ∨ o = -positiveOrientation := by\n  induction' o using Module.Ray.ind with x hx\n  dsimp [positiveOrientation]\n  simp only [ray_eq_iff, sameRay_neg_swap]\n  rw [sameRay_or_sameRay_neg_iff_not_linearIndependent]\n  intro h\n  set f : (M [⋀^ι]→ₗ[R] R) ≃ₗ[R] R := AlternatingMap.constLinearEquivOfIsEmpty.symm\n  have H : LinearIndependent R ![f x, 1] := by\n    convert h.map' f.toLinearMap f.ker\n    ext i\n    fin_cases i <;> simp [f]\n  rw [linearIndependent_iff'] at H\n  simpa using H Finset.univ ![1, -f x] (by simp [Fin.sum_univ_succ]) 0 (by simp)\n\n"}
{"name":"Basis.orientation_eq_iff_det_pos","module":"Mathlib.LinearAlgebra.Orientation","initialProofState":"R : Type u_1\ninst✝⁴ : LinearOrderedCommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nι : Type u_3\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\ne₁ e₂ : Basis ι R M\n⊢ Iff (Eq e₁.orientation e₂.orientation) (LT.lt 0 (e₁.det ⇑e₂))","decl":"/-- The orientations given by two bases are equal if and only if the determinant of one basis\nwith respect to the other is positive. -/\ntheorem orientation_eq_iff_det_pos (e₁ e₂ : Basis ι R M) :\n    e₁.orientation = e₂.orientation ↔ 0 < e₁.det e₂ :=\n  calc\n    e₁.orientation = e₂.orientation ↔ SameRay R e₁.det e₂.det := ray_eq_iff _ _\n    _ ↔ SameRay R (e₁.det e₂ • e₂.det) e₂.det := by rw [← e₁.det.eq_smul_basis_det e₂]\n    _ ↔ 0 < e₁.det e₂ := sameRay_smul_left_iff_of_ne e₂.det_ne_zero (e₁.isUnit_det e₂).ne_zero\n\n"}
{"name":"Basis.orientation_eq_or_eq_neg","module":"Mathlib.LinearAlgebra.Orientation","initialProofState":"R : Type u_1\ninst✝⁴ : LinearOrderedCommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nι : Type u_3\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\ne : Basis ι R M\nx : Orientation R M ι\n⊢ Or (Eq x e.orientation) (Eq x (Neg.neg e.orientation))","decl":"/-- Given a basis, any orientation equals the orientation given by that basis or its negation. -/\ntheorem orientation_eq_or_eq_neg (e : Basis ι R M) (x : Orientation R M ι) :\n    x = e.orientation ∨ x = -e.orientation := by\n  induction' x using Module.Ray.ind with x hx\n  rw [← x.map_basis_ne_zero_iff e] at hx\n  rwa [Basis.orientation, ray_eq_iff, neg_rayOfNeZero, ray_eq_iff, x.eq_smul_basis_det e,\n    sameRay_neg_smul_left_iff_of_ne e.det_ne_zero hx, sameRay_smul_left_iff_of_ne e.det_ne_zero hx,\n    lt_or_lt_iff_ne, ne_comm]\n\n"}
{"name":"Basis.orientation_ne_iff_eq_neg","module":"Mathlib.LinearAlgebra.Orientation","initialProofState":"R : Type u_1\ninst✝⁴ : LinearOrderedCommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nι : Type u_3\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\ne : Basis ι R M\nx : Orientation R M ι\n⊢ Iff (Ne x e.orientation) (Eq x (Neg.neg e.orientation))","decl":"/-- Given a basis, an orientation equals the negation of that given by that basis if and only\nif it does not equal that given by that basis. -/\ntheorem orientation_ne_iff_eq_neg (e : Basis ι R M) (x : Orientation R M ι) :\n    x ≠ e.orientation ↔ x = -e.orientation :=\n  ⟨fun h => (e.orientation_eq_or_eq_neg x).resolve_left h, fun h =>\n    h.symm ▸ (Module.Ray.ne_neg_self e.orientation).symm⟩\n\n"}
{"name":"Basis.orientation_comp_linearEquiv_eq_iff_det_pos","module":"Mathlib.LinearAlgebra.Orientation","initialProofState":"R : Type u_1\ninst✝⁴ : LinearOrderedCommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nι : Type u_3\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\ne : Basis ι R M\nf : LinearEquiv (RingHom.id R) M M\n⊢ Iff (Eq (e.map f).orientation e.orientation) (LT.lt 0 (LinearMap.det ↑f))","decl":"/-- Composing a basis with a linear equiv gives the same orientation if and only if the\ndeterminant is positive. -/\ntheorem orientation_comp_linearEquiv_eq_iff_det_pos (e : Basis ι R M) (f : M ≃ₗ[R] M) :\n    (e.map f).orientation = e.orientation ↔ 0 < LinearMap.det (f : M →ₗ[R] M) := by\n  rw [orientation_map, e.map_orientation_eq_det_inv_smul, units_inv_smul, units_smul_eq_self_iff,\n    LinearEquiv.coe_det]\n\n"}
{"name":"Basis.orientation_comp_linearEquiv_eq_neg_iff_det_neg","module":"Mathlib.LinearAlgebra.Orientation","initialProofState":"R : Type u_1\ninst✝⁴ : LinearOrderedCommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nι : Type u_3\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\ne : Basis ι R M\nf : LinearEquiv (RingHom.id R) M M\n⊢ Iff (Eq (e.map f).orientation (Neg.neg e.orientation)) (LT.lt (LinearMap.det ↑f) 0)","decl":"/-- Composing a basis with a linear equiv gives the negation of that orientation if and only if\nthe determinant is negative. -/\ntheorem orientation_comp_linearEquiv_eq_neg_iff_det_neg (e : Basis ι R M) (f : M ≃ₗ[R] M) :\n    (e.map f).orientation = -e.orientation ↔ LinearMap.det (f : M →ₗ[R] M) < 0 := by\n  rw [orientation_map, e.map_orientation_eq_det_inv_smul, units_inv_smul, units_smul_eq_neg_iff,\n    LinearEquiv.coe_det]\n\n"}
{"name":"Basis.orientation_neg_single","module":"Mathlib.LinearAlgebra.Orientation","initialProofState":"R : Type u_1\ninst✝⁴ : LinearOrderedCommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nι : Type u_3\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\ne : Basis ι R M\ni : ι\n⊢ Eq (e.unitsSMul (Function.update 1 i (-1))).orientation (Neg.neg e.orientation)","decl":"/-- Negating a single basis vector (represented using `units_smul`) negates the corresponding\norientation. -/\n@[simp]\ntheorem orientation_neg_single (e : Basis ι R M) (i : ι) :\n    (e.unitsSMul (Function.update 1 i (-1))).orientation = -e.orientation := by\n  rw [orientation_unitsSMul, Finset.prod_update_of_mem (Finset.mem_univ _)]\n  simp\n\n"}
{"name":"Basis.orientation_adjustToOrientation","module":"Mathlib.LinearAlgebra.Orientation","initialProofState":"R : Type u_1\ninst✝⁵ : LinearOrderedCommRing R\nM : Type u_2\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nι : Type u_3\ninst✝² : Fintype ι\ninst✝¹ : DecidableEq ι\ninst✝ : Nonempty ι\ne : Basis ι R M\nx : Orientation R M ι\n⊢ Eq (e.adjustToOrientation x).orientation x","decl":"/-- `adjust_to_orientation` gives a basis with the required orientation. -/\n@[simp]\ntheorem orientation_adjustToOrientation [Nonempty ι] (e : Basis ι R M)\n    (x : Orientation R M ι) : (e.adjustToOrientation x).orientation = x := by\n  rw [adjustToOrientation]\n  split_ifs with h\n  · exact h\n  · rw [orientation_neg_single, eq_comm, ← orientation_ne_iff_eq_neg, ne_comm]\n    exact h\n\n"}
{"name":"Basis.adjustToOrientation_apply_eq_or_eq_neg","module":"Mathlib.LinearAlgebra.Orientation","initialProofState":"R : Type u_1\ninst✝⁵ : LinearOrderedCommRing R\nM : Type u_2\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nι : Type u_3\ninst✝² : Fintype ι\ninst✝¹ : DecidableEq ι\ninst✝ : Nonempty ι\ne : Basis ι R M\nx : Orientation R M ι\ni : ι\n⊢ Or (Eq ((e.adjustToOrientation x) i) (e i)) (Eq ((e.adjustToOrientation x) i) (Neg.neg (e i)))","decl":"/-- Every basis vector from `adjust_to_orientation` is either that from the original basis or its\nnegation. -/\ntheorem adjustToOrientation_apply_eq_or_eq_neg [Nonempty ι] (e : Basis ι R M)\n    (x : Orientation R M ι) (i : ι) :\n    e.adjustToOrientation x i = e i ∨ e.adjustToOrientation x i = -e i := by\n  rw [adjustToOrientation]\n  split_ifs with h\n  · simp\n  · by_cases hi : i = Classical.arbitrary ι <;> simp [unitsSMul_apply, hi]\n\n"}
{"name":"Basis.det_adjustToOrientation","module":"Mathlib.LinearAlgebra.Orientation","initialProofState":"R : Type u_1\ninst✝⁵ : LinearOrderedCommRing R\nM : Type u_2\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nι : Type u_3\ninst✝² : Fintype ι\ninst✝¹ : DecidableEq ι\ninst✝ : Nonempty ι\ne : Basis ι R M\nx : Orientation R M ι\n⊢ Or (Eq (e.adjustToOrientation x).det e.det) (Eq (e.adjustToOrientation x).det (Neg.neg e.det))","decl":"theorem det_adjustToOrientation [Nonempty ι] (e : Basis ι R M)\n    (x : Orientation R M ι) :\n    (e.adjustToOrientation x).det = e.det ∨ (e.adjustToOrientation x).det = -e.det := by\n  dsimp [Basis.adjustToOrientation]\n  split_ifs\n  · left\n    rfl\n  · right\n    simp only [e.det_unitsSMul, ne_eq, Finset.mem_univ, Finset.prod_update_of_mem, not_true,\n      Pi.one_apply, Finset.prod_const_one, mul_one, inv_neg', inv_one, Units.val_neg, Units.val_one]\n    ext\n    simp\n\n"}
{"name":"Basis.abs_det_adjustToOrientation","module":"Mathlib.LinearAlgebra.Orientation","initialProofState":"R : Type u_1\ninst✝⁵ : LinearOrderedCommRing R\nM : Type u_2\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nι : Type u_3\ninst✝² : Fintype ι\ninst✝¹ : DecidableEq ι\ninst✝ : Nonempty ι\ne : Basis ι R M\nx : Orientation R M ι\nv : ι → M\n⊢ Eq (abs ((e.adjustToOrientation x).det v)) (abs (e.det v))","decl":"@[simp]\ntheorem abs_det_adjustToOrientation [Nonempty ι] (e : Basis ι R M)\n    (x : Orientation R M ι) (v : ι → M) : |(e.adjustToOrientation x).det v| = |e.det v| := by\n  cases' e.det_adjustToOrientation x with h h <;> simp [h]\n\n"}
{"name":"Orientation.eq_or_eq_neg","module":"Mathlib.LinearAlgebra.Orientation","initialProofState":"R : Type u_1\ninst✝⁴ : LinearOrderedField R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nι : Type u_3\ninst✝¹ : Fintype ι\ninst✝ : FiniteDimensional R M\nx₁ x₂ : Orientation R M ι\nh : Eq (Fintype.card ι) (Module.finrank R M)\n⊢ Or (Eq x₁ x₂) (Eq x₁ (Neg.neg x₂))","decl":"/-- If the index type has cardinality equal to the finite dimension, any two orientations are\nequal or negations. -/\ntheorem eq_or_eq_neg [FiniteDimensional R M] (x₁ x₂ : Orientation R M ι)\n    (h : Fintype.card ι = finrank R M) : x₁ = x₂ ∨ x₁ = -x₂ := by\n  have e := (finBasis R M).reindex (Fintype.equivFinOfCardEq h).symm\n  letI := Classical.decEq ι\n  -- Porting note: this needs to be made explicit for the simp below\n  have orientation_neg_neg :\n      ∀ f : Basis ι R M, - -Basis.orientation f = Basis.orientation f := by\n    #adaptation_note /-- https://github.com/leanprover/lean4/pull/4119\n    `set_option maxSynthPendingDepth 2` required -/\n    set_option maxSynthPendingDepth 2 in simp\n  rcases e.orientation_eq_or_eq_neg x₁ with (h₁ | h₁) <;>\n    rcases e.orientation_eq_or_eq_neg x₂ with (h₂ | h₂) <;> simp [h₁, h₂, orientation_neg_neg]\n\n"}
{"name":"Orientation.ne_iff_eq_neg","module":"Mathlib.LinearAlgebra.Orientation","initialProofState":"R : Type u_1\ninst✝⁴ : LinearOrderedField R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nι : Type u_3\ninst✝¹ : Fintype ι\ninst✝ : FiniteDimensional R M\nx₁ x₂ : Orientation R M ι\nh : Eq (Fintype.card ι) (Module.finrank R M)\n⊢ Iff (Ne x₁ x₂) (Eq x₁ (Neg.neg x₂))","decl":"/-- If the index type has cardinality equal to the finite dimension, an orientation equals the\nnegation of another orientation if and only if they are not equal. -/\ntheorem ne_iff_eq_neg [FiniteDimensional R M] (x₁ x₂ : Orientation R M ι)\n    (h : Fintype.card ι = finrank R M) : x₁ ≠ x₂ ↔ x₁ = -x₂ :=\n  ⟨fun hn => (eq_or_eq_neg x₁ x₂ h).resolve_left hn, fun he =>\n    he.symm ▸ (Module.Ray.ne_neg_self x₂).symm⟩\n\n"}
{"name":"Orientation.map_eq_det_inv_smul","module":"Mathlib.LinearAlgebra.Orientation","initialProofState":"R : Type u_1\ninst✝⁴ : LinearOrderedField R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nι : Type u_3\ninst✝¹ : Fintype ι\ninst✝ : FiniteDimensional R M\nx : Orientation R M ι\nf : LinearEquiv (RingHom.id R) M M\nh : Eq (Fintype.card ι) (Module.finrank R M)\n⊢ Eq ((Orientation.map ι f) x) (HSMul.hSMul (Inv.inv (LinearEquiv.det f)) x)","decl":"/-- The value of `Orientation.map` when the index type has cardinality equal to the finite\ndimension, in terms of `f.det`. -/\ntheorem map_eq_det_inv_smul [FiniteDimensional R M] (x : Orientation R M ι) (f : M ≃ₗ[R] M)\n    (h : Fintype.card ι = finrank R M) : Orientation.map ι f x = (LinearEquiv.det f)⁻¹ • x :=\n  haveI e := (finBasis R M).reindex (Fintype.equivFinOfCardEq h).symm\n  e.map_orientation_eq_det_inv_smul x f\n\n"}
{"name":"Orientation.map_eq_iff_det_pos","module":"Mathlib.LinearAlgebra.Orientation","initialProofState":"R : Type u_1\ninst✝⁴ : LinearOrderedField R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nι : Type u_3\ninst✝¹ : Fintype ι\ninst✝ : FiniteDimensional R M\nx : Orientation R M ι\nf : LinearEquiv (RingHom.id R) M M\nh : Eq (Fintype.card ι) (Module.finrank R M)\n⊢ Iff (Eq ((Orientation.map ι f) x) x) (LT.lt 0 (LinearMap.det ↑f))","decl":"/-- If the index type has cardinality equal to the finite dimension, composing an alternating\nmap with the same linear equiv on each argument gives the same orientation if and only if the\ndeterminant is positive. -/\ntheorem map_eq_iff_det_pos [FiniteDimensional R M] (x : Orientation R M ι) (f : M ≃ₗ[R] M)\n    (h : Fintype.card ι = finrank R M) :\n    Orientation.map ι f x = x ↔ 0 < LinearMap.det (f : M →ₗ[R] M) := by\n  cases isEmpty_or_nonempty ι\n  · have H : finrank R M = 0 := h.symm.trans Fintype.card_eq_zero\n    simp [LinearMap.det_eq_one_of_finrank_eq_zero H]\n  rw [map_eq_det_inv_smul _ _ h, units_inv_smul, units_smul_eq_self_iff, LinearEquiv.coe_det]\n\n"}
{"name":"Orientation.map_eq_neg_iff_det_neg","module":"Mathlib.LinearAlgebra.Orientation","initialProofState":"R : Type u_1\ninst✝³ : LinearOrderedField R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nι : Type u_3\ninst✝ : Fintype ι\nx : Orientation R M ι\nf : LinearEquiv (RingHom.id R) M M\nh : Eq (Fintype.card ι) (Module.finrank R M)\n⊢ Iff (Eq ((Orientation.map ι f) x) (Neg.neg x)) (LT.lt (LinearMap.det ↑f) 0)","decl":"/-- If the index type has cardinality equal to the finite dimension, composing an alternating\nmap with the same linear equiv on each argument gives the negation of that orientation if and\nonly if the determinant is negative. -/\ntheorem map_eq_neg_iff_det_neg (x : Orientation R M ι) (f : M ≃ₗ[R] M)\n    (h : Fintype.card ι = finrank R M) :\n    Orientation.map ι f x = -x ↔ LinearMap.det (f : M →ₗ[R] M) < 0 := by\n  cases isEmpty_or_nonempty ι\n  · have H : finrank R M = 0 := h.symm.trans Fintype.card_eq_zero\n    simp [LinearMap.det_eq_one_of_finrank_eq_zero H, Module.Ray.ne_neg_self x]\n  have H : 0 < finrank R M := by\n    rw [← h]\n    exact Fintype.card_pos\n  haveI : FiniteDimensional R M := of_finrank_pos H\n  rw [map_eq_det_inv_smul _ _ h, units_inv_smul, units_smul_eq_neg_iff, LinearEquiv.coe_det]\n\n"}
{"name":"Orientation.someBasis_orientation","module":"Mathlib.LinearAlgebra.Orientation","initialProofState":"R : Type u_1\ninst✝⁶ : LinearOrderedField R\nM : Type u_2\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nι : Type u_3\ninst✝³ : Fintype ι\ninst✝² : Nonempty ι\ninst✝¹ : DecidableEq ι\ninst✝ : FiniteDimensional R M\nx : Orientation R M ι\nh : Eq (Fintype.card ι) (Module.finrank R M)\n⊢ Eq (x.someBasis h).orientation x","decl":"/-- `some_basis` gives a basis with the required orientation. -/\n@[simp]\ntheorem someBasis_orientation [Nonempty ι] [DecidableEq ι] [FiniteDimensional R M]\n    (x : Orientation R M ι) (h : Fintype.card ι = finrank R M) : (x.someBasis h).orientation = x :=\n  Basis.orientation_adjustToOrientation _ _\n\n"}
