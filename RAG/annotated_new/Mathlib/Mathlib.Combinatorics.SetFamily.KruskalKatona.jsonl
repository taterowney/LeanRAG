{"name":"Finset.Colex.shadow_initSeg","module":"Mathlib.Combinatorics.SetFamily.KruskalKatona","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : LinearOrder Î±\ns : Finset Î±\ninstâœ : Fintype Î±\nhs : s.Nonempty\nâŠ¢ Eq (Finset.Colex.initSeg s).shadow (Finset.Colex.initSeg (s.erase (s.min' hs)))","decl":"/-- This is important for iterating Kruskal-Katona: the shadow of an initial segment is also an\ninitial segment. -/\nlemma shadow_initSeg [Fintype Î±] (hs : s.Nonempty) :\n    âˆ‚ (initSeg s) = initSeg (erase s <| min' s hs) := by\n  -- This is a pretty painful proof, with lots of cases.\n  ext t\n  simp only [mem_shadow_iff_insert_mem, mem_initSeg, exists_prop]\n  constructor\n  -- First show that if t âˆª a â‰¤ s, then t â‰¤ s - min s\n  Â· rintro âŸ¨a, ha, hst, htsâŸ©\n    constructor\n    Â· rw [card_erase_of_mem (min'_mem _ _), hst, card_insert_of_not_mem ha, add_tsub_cancel_right]\n    Â· simpa [ha] using erase_le_erase_min' hts hst.ge (mem_insert_self _ _)\n  -- Now show that if t â‰¤ s - min s, there is j such that t âˆª j â‰¤ s\n  -- We choose j as the smallest thing not in t\n  simp_rw [le_iff_eq_or_lt, lt_iff_exists_filter_lt, mem_sdiff, filter_inj, and_assoc]\n  simp only [toColex_inj, ofColex_toColex, ne_eq, and_imp]\n  rintro cards' (rfl | âŸ¨k, hks, hkt, zâŸ©)\n  -- If t = s - min s, then use j = min s so t âˆª j = s\n  Â· refine âŸ¨min' s hs, not_mem_erase _ _, ?_âŸ©\n    rw [insert_erase (min'_mem _ _)]\n    exact âŸ¨rfl, Or.inl rflâŸ©\n  set j := min' tá¶œ âŸ¨k, mem_compl.2 hktâŸ©\n  -- Assume first t < s - min s, and take k as the colex witness for this\n  have hjk : j â‰¤ k := min'_le _ _ (mem_compl.2 â€¹k âˆ‰ tâ€º)\n  have : j âˆ‰ t := mem_compl.1 (min'_mem _ _)\n  have hcard : #s = #(insert j t) := by\n    rw [card_insert_of_not_mem â€¹j âˆ‰ tâ€º, â† â€¹_ = #tâ€º, card_erase_add_one (min'_mem _ _)]\n  refine âŸ¨j, â€¹_â€º, hcard, ?_âŸ©\n  -- Cases on j < k or j = k\n  obtain hjk | râ‚ := hjk.lt_or_eq\n  -- if j < k, k is our colex witness for t âˆª {j} < s\n  Â· refine Or.inr âŸ¨k, mem_of_mem_erase â€¹_â€º, fun hk â†¦ hkt <| mem_of_mem_insert_of_ne hk hjk.ne',\n      fun x hx â†¦ ?_âŸ©\n    simpa only [mem_insert, z hx, (hjk.trans hx).ne', mem_erase, Ne, false_or,\n      and_iff_right_iff_imp] using fun _ â†¦ ((min'_le _ _ <| mem_of_mem_erase hks).trans_lt hx).ne'\n  -- if j = k, all of range k is in t so by sizes t âˆª {j} = s\n  refine Or.inl (eq_of_subset_of_card_le (fun a ha â†¦ ?_) hcard.ge).symm\n  rcases lt_trichotomy k a with (lt | rfl | gt)\n  Â· apply mem_insert_of_mem\n    rw [z lt]\n    refine mem_erase_of_ne_of_mem (lt_of_le_of_lt ?_ lt).ne' ha\n    apply min'_le _ _ (mem_of_mem_erase â€¹_â€º)\n  Â· rw [râ‚]; apply mem_insert_self\n  Â· apply mem_insert_of_mem\n    rw [â† râ‚] at gt\n    by_contra\n    apply (min'_le tá¶œ _ _).not_lt gt\n    rwa [mem_compl]\n\n"}
{"name":"Finset.Colex.IsInitSeg.shadow","module":"Mathlib.Combinatorics.SetFamily.KruskalKatona","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : LinearOrder Î±\nğ’œ : Finset (Finset Î±)\nr : Nat\ninstâœ : Finite Î±\nhâ‚ : Finset.Colex.IsInitSeg ğ’œ r\nâŠ¢ Finset.Colex.IsInitSeg ğ’œ.shadow (HSub.hSub r 1)","decl":"/-- The shadow of an initial segment is also an initial segment. -/\nprotected lemma IsInitSeg.shadow [Finite Î±] (hâ‚ : IsInitSeg ğ’œ r) : IsInitSeg (âˆ‚ ğ’œ) (r - 1) := by\n  cases nonempty_fintype Î±\n  obtain rfl | hr := Nat.eq_zero_or_pos r\n  Â· have : ğ’œ âŠ† {âˆ…} := fun s hs â†¦ by rw [mem_singleton, â† Finset.card_eq_zero]; exact hâ‚.1 hs\n    have := shadow_monotone this\n    simp only [subset_empty, le_eq_subset, shadow_singleton_empty] at this\n    simp [this]\n  obtain rfl | hğ’œ := ğ’œ.eq_empty_or_nonempty\n  Â· simp\n  obtain âŸ¨s, rfl, rflâŸ© := hâ‚.exists_initSeg hğ’œ\n  rw [shadow_initSeg (card_pos.1 hr), â† card_erase_of_mem (min'_mem _ _)]\n  exact isInitSeg_initSeg\n\n"}
{"name":"Finset.UV.toColex_compress_lt_toColex","module":"Mathlib.Combinatorics.SetFamily.KruskalKatona","initialProofState":"Î± : Type u_1\ninstâœ : LinearOrder Î±\ns U V : Finset Î±\nhU : U.Nonempty\nhV : V.Nonempty\nh : LT.lt (U.max' hU) (V.max' hV)\nhA : Ne (UV.compress U V s) s\nâŠ¢ LT.lt { ofColex := UV.compress U V s } { ofColex := s }","decl":"/-- Applying the compression makes the set smaller in colex. This is intuitive since a portion of\nthe set is being \"shifted down\" as `max U < max V`. -/\nlemma toColex_compress_lt_toColex {hU : U.Nonempty} {hV : V.Nonempty} (h : max' U hU < max' V hV)\n    (hA : compress U V s â‰  s) : toColex (compress U V s) < toColex s := by\n  rw [compress, ite_ne_right_iff] at hA\n  rw [compress, if_pos hA.1, lt_iff_exists_filter_lt]\n  simp_rw [mem_sdiff (s := s), filter_inj, and_assoc]\n  refine âŸ¨_, hA.1.2 <| max'_mem _ hV, not_mem_sdiff_of_mem_right <| max'_mem _ _, fun a ha â†¦ ?_âŸ©\n  have : a âˆ‰ V := fun H â†¦ ha.not_le (le_max' _ _ H)\n  have : a âˆ‰ U := fun H â†¦ ha.not_lt ((le_max' _ _ H).trans_lt h)\n  simp [â€¹a âˆ‰ Uâ€º, â€¹a âˆ‰ Vâ€º]\n\n"}
{"name":"Finset.UV.isInitSeg_of_compressed","module":"Mathlib.Combinatorics.SetFamily.KruskalKatona","initialProofState":"Î± : Type u_1\ninstâœ : LinearOrder Î±\nâ„¬ : Finset (Finset Î±)\nr : Nat\nhâ‚ : Set.Sized r â†‘â„¬\nhâ‚‚ : âˆ€ (U V : Finset Î±), Finset.UV.UsefulCompression U V â†’ UV.IsCompressed U V â„¬\nâŠ¢ Finset.Colex.IsInitSeg â„¬ r","decl":"/-- If we're compressed by all useful compressions, then we're an initial segment. This is the other\nkey Kruskal-Katona part. -/\nlemma isInitSeg_of_compressed {â„¬ : Finset (Finset Î±)} {r : â„•} (hâ‚ : (â„¬ : Set (Finset Î±)).Sized r)\n    (hâ‚‚ : âˆ€ U V, UsefulCompression U V â†’ IsCompressed U V â„¬) : IsInitSeg â„¬ r := by\n  refine âŸ¨hâ‚, ?_âŸ©\n  rintro A B hA âŸ¨hBA, sizeAâŸ©\n  by_contra hB\n  have hAB : A â‰  B := ne_of_mem_of_not_mem hA hB\n  have hAB' : #A = #B := (hâ‚ hA).trans sizeA.symm\n  have hU : (A \\ B).Nonempty := sdiff_nonempty.2 fun h â†¦ hAB <| eq_of_subset_of_card_le h hAB'.ge\n  have hV : (B \\ A).Nonempty :=\n    sdiff_nonempty.2 fun h â†¦ hAB.symm <| eq_of_subset_of_card_le h hAB'.le\n  have disj : Disjoint (B \\ A) (A \\ B) := disjoint_sdiff.mono_left sdiff_subset\n  have smaller : max' _ hV < max' _ hU := by\n    obtain hlt | heq | hgt := lt_trichotomy (max' _ hU) (max' _ hV)\n    Â· rw [â† compress_sdiff_sdiff A B] at hAB hBA\n      cases hBA.not_lt <| toColex_compress_lt_toColex hlt hAB\n    Â· exact (disjoint_right.1 disj (max'_mem _ hU) <| heq.symm â–¸ max'_mem _ _).elim\n    Â· assumption\n  refine hB ?_\n  rw [â† (hâ‚‚ _ _ âŸ¨disj, card_sdiff_comm hAB'.symm, hV, hU, smallerâŸ©).eq]\n  exact mem_compression.2 (Or.inr âŸ¨hB, A, hA, compress_sdiff_sdiff _ _âŸ©)\n\n"}
{"name":"Finset.kruskal_katona","module":"Mathlib.Combinatorics.SetFamily.KruskalKatona","initialProofState":"n r : Nat\nğ’œ ğ’ : Finset (Finset (Fin n))\nhğ’œr : Set.Sized r â†‘ğ’œ\nhğ’ğ’œ : LE.le ğ’.card ğ’œ.card\nhğ’ : Finset.Colex.IsInitSeg ğ’ r\nâŠ¢ LE.le ğ’.shadow.card ğ’œ.shadow.card","decl":"/-- The **Kruskal-Katona theorem**.\n\nGiven a set family `ğ’œ` consisting of `r`-sets, and `ğ’` an initial segment of the colex order of the\nsame size, the shadow of `ğ’` is smaller than the shadow of `ğ’œ`. In particular, this gives that the\nminimum shadow size is achieved by initial segments of colex. -/\ntheorem kruskal_katona (hğ’œr : (ğ’œ : Set (Finset (Fin n))).Sized r) (hğ’ğ’œ : #ğ’ â‰¤ #ğ’œ)\n    (hğ’ : IsInitSeg ğ’ r) : #(âˆ‚ ğ’) â‰¤ #(âˆ‚ ğ’œ) := by\n  -- WLOG `|ğ’œ| = |ğ’|`\n  obtain âŸ¨ğ’œ', hğ’œ, hğ’œğ’âŸ© := exists_subset_card_eq hğ’ğ’œ\n  -- By `kruskal_katona_helper`, we find a fully compressed family `â„¬` of the same size as `ğ’œ`\n  -- whose shadow is no bigger.\n  obtain âŸ¨â„¬, hâ„¬ğ’œ, hğ’œâ„¬, hâ„¬r, hâ„¬âŸ© := UV.kruskal_katona_helper ğ’œ' (hğ’œr.mono (by gcongr))\n  -- This means that `â„¬` is an initial segment of the same size as `ğ’`. Hence they are equal and\n  -- we are done.\n  suffices â„¬ = ğ’ by subst ğ’; exact hâ„¬ğ’œ.trans (by gcongr)\n  have hcard : #â„¬ = #ğ’ := hğ’œâ„¬.symm.trans hğ’œğ’\n  obtain hğ’â„¬ | hâ„¬ğ’ := hğ’.total (UV.isInitSeg_of_compressed hâ„¬r hâ„¬)\n  Â· exact (eq_of_subset_of_card_le hğ’â„¬ hcard.le).symm\n  Â· exact eq_of_subset_of_card_le hâ„¬ğ’ hcard.ge\n\n"}
{"name":"Finset.iterated_kk","module":"Mathlib.Combinatorics.SetFamily.KruskalKatona","initialProofState":"n r k : Nat\nğ’œ ğ’ : Finset (Finset (Fin n))\nhâ‚ : Set.Sized r â†‘ğ’œ\nhâ‚‚ : LE.le ğ’.card ğ’œ.card\nhâ‚ƒ : Finset.Colex.IsInitSeg ğ’ r\nâŠ¢ LE.le (Nat.iterate Finset.shadow k ğ’).card (Nat.iterate Finset.shadow k ğ’œ).card","decl":"/-- An iterated form of the Kruskal-Katona theorem. In particular, the minimum possible iterated\nshadow size is attained by initial segments. -/\ntheorem iterated_kk (hâ‚ : (ğ’œ : Set (Finset (Fin n))).Sized r) (hâ‚‚ : #ğ’ â‰¤ #ğ’œ) (hâ‚ƒ : IsInitSeg ğ’ r) :\n    #(âˆ‚^[k] ğ’) â‰¤ #(âˆ‚^[k] ğ’œ) := by\n  induction' k with _k ih generalizing r ğ’œ ğ’\n  Â· simpa\n  Â· refine ih hâ‚.shadow (kruskal_katona hâ‚ hâ‚‚ hâ‚ƒ) ?_\n    convert hâ‚ƒ.shadow\n\n"}
{"name":"Finset.kruskal_katona_lovasz_form","module":"Mathlib.Combinatorics.SetFamily.KruskalKatona","initialProofState":"n r k i : Nat\nğ’œ : Finset (Finset (Fin n))\nhir : LE.le i r\nhrk : LE.le r k\nhkn : LE.le k n\nhâ‚ : Set.Sized r â†‘ğ’œ\nhâ‚‚ : LE.le (k.choose r) ğ’œ.card\nâŠ¢ LE.le (k.choose (HSub.hSub r i)) (Nat.iterate Finset.shadow i ğ’œ).card","decl":"/-- The **Lovasz formulation of the Kruskal-Katona theorem**.\n\nIf `|ğ’œ| â‰¥ k choose r`, (and everything in `ğ’œ` has size `r`) then the initial segment we compare to\nis just all the subsets of `{0, ..., k - 1}` of size `r`. The `i`-th iterated shadow of this is all\nthe subsets of `{0, ..., k - 1}` of size `r - i`, so the `i`-th iterated shadow of `ğ’œ` has at least\n`k.choose (r - i)` elements. -/\ntheorem kruskal_katona_lovasz_form (hir : i â‰¤ r) (hrk : r â‰¤ k) (hkn : k â‰¤ n)\n    (hâ‚ : (ğ’œ : Set (Finset (Fin n))).Sized r) (hâ‚‚ : k.choose r â‰¤ #ğ’œ) :\n    k.choose (r - i) â‰¤ #(âˆ‚^[i] ğ’œ) := by\n  set range'k : Finset (Fin n) :=\n    attachFin (range k) fun m â†¦ by rw [mem_range]; apply forall_lt_iff_le.2 hkn\n  set ğ’ : Finset (Finset (Fin n)) := powersetCard r range'k\n  have : (ğ’ : Set (Finset (Fin n))).Sized r := Set.sized_powersetCard _ _\n  calc\n    k.choose (r - i)\n    _ = #(powersetCard (r - i) range'k) := by rw [card_powersetCard, card_attachFin, card_range]\n    _ = #(âˆ‚^[i] ğ’) := by\n      congr!\n      ext B\n      rw [mem_powersetCard, mem_shadow_iterate_iff_exists_sdiff]\n      constructor\n      Â· rintro âŸ¨hBk, hBâŸ©\n        have := exists_subsuperset_card_eq hBk (Nat.le_add_left _ i) <| by\n          rwa [hB, card_attachFin, card_range, â† Nat.add_sub_assoc hir, Nat.add_sub_cancel_left]\n        obtain âŸ¨C, BsubC, hCrange, hcardâŸ© := this\n        rw [hB, â† Nat.add_sub_assoc hir, Nat.add_sub_cancel_left] at hcard\n        refine âŸ¨C, mem_powersetCard.2 âŸ¨hCrange, hcardâŸ©, BsubC, ?_âŸ©\n        rw [card_sdiff BsubC, hcard, hB, Nat.sub_sub_self hir]\n      Â· rintro âŸ¨A, Ah, hBA, card_sdiff_iâŸ©\n        rw [mem_powersetCard] at Ah\n        refine âŸ¨hBA.trans Ah.1, eq_tsub_of_add_eq ?_âŸ©\n        rw [â† Ah.2, â† card_sdiff_i, add_comm, card_sdiff_add_card_eq_card hBA]\n    _ â‰¤ #(âˆ‚ ^[i] ğ’œ) := by\n      refine iterated_kk hâ‚ ?_ âŸ¨â€¹_â€º, ?_âŸ©\n      Â· rwa [card_powersetCard, card_attachFin, card_range]\n      simp_rw [ğ’, mem_powersetCard]\n      rintro A B hA âŸ¨HBâ‚, HBâ‚‚âŸ©\n      refine âŸ¨fun t ht â†¦ ?_, â€¹_â€ºâŸ©\n      rw [mem_attachFin, mem_range]\n      have : toColex (image Fin.val B) < toColex (image Fin.val A) := by\n        rwa [toColex_image_lt_toColex_image Fin.val_strictMono]\n      apply Colex.forall_lt_mono this.le _ t (mem_image.2 âŸ¨t, ht, rflâŸ©)\n      simp_rw [mem_image]\n      rintro _ âŸ¨a, ha, habâŸ©\n      simpa [range'k, hab] using hA.1 ha\n\n"}
{"name":"Finset.erdos_ko_rado","module":"Mathlib.Combinatorics.SetFamily.KruskalKatona","initialProofState":"n : Nat\nğ’œ : Finset (Finset (Fin n))\nr : Nat\nhğ’œ : (â†‘ğ’œ).Intersecting\nhâ‚‚ : Set.Sized r â†‘ğ’œ\nhâ‚ƒ : LE.le r (HDiv.hDiv n 2)\nâŠ¢ LE.le ğ’œ.card ((HSub.hSub n 1).choose (HSub.hSub r 1))","decl":"/-- The **ErdÅ‘sâ€“Koâ€“Rado theorem**.\n\nThe maximum size of an intersecting family in `Î±` where all sets have size `r` is bounded by\n`(card Î± - 1).choose (r - 1)`. This bound is sharp. -/\ntheorem erdos_ko_rado {ğ’œ : Finset (Finset (Fin n))} {r : â„•}\n    (hğ’œ : (ğ’œ : Set (Finset (Fin n))).Intersecting) (hâ‚‚ : (ğ’œ : Set (Finset (Fin n))).Sized r)\n    (hâ‚ƒ : r â‰¤ n / 2) :\n    #ğ’œ â‰¤ (n - 1).choose (r - 1) := by\n  -- Take care of the r=0 case first: it's not very interesting.\n  cases' Nat.eq_zero_or_pos r with b h1r\n  Â· convert Nat.zero_le _\n    rw [Finset.card_eq_zero, eq_empty_iff_forall_not_mem]\n    refine fun A HA â†¦ hğ’œ HA HA ?_\n    rw [disjoint_self_iff_empty, â† Finset.card_eq_zero, â† b]\n    exact hâ‚‚ HA\n  refine le_of_not_lt fun size â†¦ ?_\n  -- Consider ğ’œá¶œË¢ = {sá¶œ | s âˆˆ ğ’œ}\n  -- Its iterated shadow (âˆ‚^[n-2k] ğ’œá¶œË¢) is disjoint from ğ’œ by intersecting-ness\n  have : Disjoint ğ’œ (âˆ‚^[n - 2 * r] ğ’œá¶œË¢) := disjoint_right.2 fun A hAbar hA â†¦ by\n    simp [mem_shadow_iterate_iff_exists_sdiff, mem_compls] at hAbar\n    obtain âŸ¨C, hC, hAC, _âŸ© := hAbar\n    exact hğ’œ hA hC (disjoint_of_subset_left hAC disjoint_compl_right)\n  have : r â‰¤ n := hâ‚ƒ.trans (Nat.div_le_self n 2)\n  have : 1 â‰¤ n := â€¹1 â‰¤ râ€º.trans â€¹r â‰¤ nâ€º\n  -- We know the size of ğ’œá¶œË¢ since it's the same size as ğ’œ\n  have z : (n - 1).choose (n - r) < #ğ’œá¶œË¢ := by\n    rwa [card_compls, choose_symm_of_eq_add (tsub_add_tsub_cancel â€¹r â‰¤ nâ€º â€¹1 â‰¤ râ€º).symm]\n  -- and everything in ğ’œá¶œË¢ has size n-r.\n  have hğ’œbar : (ğ’œá¶œË¢ : Set (Finset (Fin n))).Sized (n - r) := by simpa using hâ‚‚.compls\n  have : n - 2 * r â‰¤ n - r := by\n    rw [tsub_le_tsub_iff_left â€¹r â‰¤ nâ€º]\n    exact Nat.le_mul_of_pos_left _ zero_lt_two\n  -- We can use the Lovasz form of Kruskal-Katona to get |âˆ‚^[n-2k] ğ’œá¶œË¢| â‰¥ (n-1) choose r\n  have kk := kruskal_katona_lovasz_form â€¹n - 2 * r â‰¤ n - râ€º ((tsub_le_tsub_iff_left â€¹1 â‰¤ nâ€º).2 h1r)\n      tsub_le_self hğ’œbar z.le\n  have : n - r - (n - 2 * r) = r := by omega\n  rw [this] at kk\n  -- But this gives a contradiction: `n choose r < |ğ’œ| + |âˆ‚^[n-2k] ğ’œá¶œË¢|`\n  have : n.choose r < #(ğ’œ âˆª âˆ‚^[n - 2 * r] ğ’œá¶œË¢) := by\n    rw [card_union_of_disjoint â€¹_â€º]\n    convert lt_of_le_of_lt (add_le_add_left kk _) (add_lt_add_right size _) using 1\n    convert Nat.choose_succ_succ _ _ using 3\n    all_goals rwa [Nat.sub_one, Nat.succ_pred_eq_of_pos]\n  apply this.not_le\n  convert Set.Sized.card_le _\n  Â· rw [Fintype.card_fin]\n  rw [coe_union, Set.sized_union]\n  refine âŸ¨â€¹_â€º, ?_âŸ©\n  convert hğ’œbar.shadow_iterate\n  omega\n\n"}
