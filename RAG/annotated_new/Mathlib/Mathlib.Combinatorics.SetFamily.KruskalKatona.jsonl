{"name":"Finset.Colex.shadow_initSeg","module":"Mathlib.Combinatorics.SetFamily.KruskalKatona","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ns : Finset α\ninst✝ : Fintype α\nhs : s.Nonempty\n⊢ Eq (Finset.Colex.initSeg s).shadow (Finset.Colex.initSeg (s.erase (s.min' hs)))","decl":"/-- This is important for iterating Kruskal-Katona: the shadow of an initial segment is also an\ninitial segment. -/\nlemma shadow_initSeg [Fintype α] (hs : s.Nonempty) :\n    ∂ (initSeg s) = initSeg (erase s <| min' s hs) := by\n  -- This is a pretty painful proof, with lots of cases.\n  ext t\n  simp only [mem_shadow_iff_insert_mem, mem_initSeg, exists_prop]\n  constructor\n  -- First show that if t ∪ a ≤ s, then t ≤ s - min s\n  · rintro ⟨a, ha, hst, hts⟩\n    constructor\n    · rw [card_erase_of_mem (min'_mem _ _), hst, card_insert_of_not_mem ha, add_tsub_cancel_right]\n    · simpa [ha] using erase_le_erase_min' hts hst.ge (mem_insert_self _ _)\n  -- Now show that if t ≤ s - min s, there is j such that t ∪ j ≤ s\n  -- We choose j as the smallest thing not in t\n  simp_rw [le_iff_eq_or_lt, lt_iff_exists_filter_lt, mem_sdiff, filter_inj, and_assoc]\n  simp only [toColex_inj, ofColex_toColex, ne_eq, and_imp]\n  rintro cards' (rfl | ⟨k, hks, hkt, z⟩)\n  -- If t = s - min s, then use j = min s so t ∪ j = s\n  · refine ⟨min' s hs, not_mem_erase _ _, ?_⟩\n    rw [insert_erase (min'_mem _ _)]\n    exact ⟨rfl, Or.inl rfl⟩\n  set j := min' tᶜ ⟨k, mem_compl.2 hkt⟩\n  -- Assume first t < s - min s, and take k as the colex witness for this\n  have hjk : j ≤ k := min'_le _ _ (mem_compl.2 ‹k ∉ t›)\n  have : j ∉ t := mem_compl.1 (min'_mem _ _)\n  have hcard : #s = #(insert j t) := by\n    rw [card_insert_of_not_mem ‹j ∉ t›, ← ‹_ = #t›, card_erase_add_one (min'_mem _ _)]\n  refine ⟨j, ‹_›, hcard, ?_⟩\n  -- Cases on j < k or j = k\n  obtain hjk | r₁ := hjk.lt_or_eq\n  -- if j < k, k is our colex witness for t ∪ {j} < s\n  · refine Or.inr ⟨k, mem_of_mem_erase ‹_›, fun hk ↦ hkt <| mem_of_mem_insert_of_ne hk hjk.ne',\n      fun x hx ↦ ?_⟩\n    simpa only [mem_insert, z hx, (hjk.trans hx).ne', mem_erase, Ne, false_or,\n      and_iff_right_iff_imp] using fun _ ↦ ((min'_le _ _ <| mem_of_mem_erase hks).trans_lt hx).ne'\n  -- if j = k, all of range k is in t so by sizes t ∪ {j} = s\n  refine Or.inl (eq_of_subset_of_card_le (fun a ha ↦ ?_) hcard.ge).symm\n  rcases lt_trichotomy k a with (lt | rfl | gt)\n  · apply mem_insert_of_mem\n    rw [z lt]\n    refine mem_erase_of_ne_of_mem (lt_of_le_of_lt ?_ lt).ne' ha\n    apply min'_le _ _ (mem_of_mem_erase ‹_›)\n  · rw [r₁]; apply mem_insert_self\n  · apply mem_insert_of_mem\n    rw [← r₁] at gt\n    by_contra\n    apply (min'_le tᶜ _ _).not_lt gt\n    rwa [mem_compl]\n\n"}
{"name":"Finset.Colex.IsInitSeg.shadow","module":"Mathlib.Combinatorics.SetFamily.KruskalKatona","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\n𝒜 : Finset (Finset α)\nr : Nat\ninst✝ : Finite α\nh₁ : Finset.Colex.IsInitSeg 𝒜 r\n⊢ Finset.Colex.IsInitSeg 𝒜.shadow (HSub.hSub r 1)","decl":"/-- The shadow of an initial segment is also an initial segment. -/\nprotected lemma IsInitSeg.shadow [Finite α] (h₁ : IsInitSeg 𝒜 r) : IsInitSeg (∂ 𝒜) (r - 1) := by\n  cases nonempty_fintype α\n  obtain rfl | hr := Nat.eq_zero_or_pos r\n  · have : 𝒜 ⊆ {∅} := fun s hs ↦ by rw [mem_singleton, ← Finset.card_eq_zero]; exact h₁.1 hs\n    have := shadow_monotone this\n    simp only [subset_empty, le_eq_subset, shadow_singleton_empty] at this\n    simp [this]\n  obtain rfl | h𝒜 := 𝒜.eq_empty_or_nonempty\n  · simp\n  obtain ⟨s, rfl, rfl⟩ := h₁.exists_initSeg h𝒜\n  rw [shadow_initSeg (card_pos.1 hr), ← card_erase_of_mem (min'_mem _ _)]\n  exact isInitSeg_initSeg\n\n"}
{"name":"Finset.UV.toColex_compress_lt_toColex","module":"Mathlib.Combinatorics.SetFamily.KruskalKatona","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns U V : Finset α\nhU : U.Nonempty\nhV : V.Nonempty\nh : LT.lt (U.max' hU) (V.max' hV)\nhA : Ne (UV.compress U V s) s\n⊢ LT.lt { ofColex := UV.compress U V s } { ofColex := s }","decl":"/-- Applying the compression makes the set smaller in colex. This is intuitive since a portion of\nthe set is being \"shifted down\" as `max U < max V`. -/\nlemma toColex_compress_lt_toColex {hU : U.Nonempty} {hV : V.Nonempty} (h : max' U hU < max' V hV)\n    (hA : compress U V s ≠ s) : toColex (compress U V s) < toColex s := by\n  rw [compress, ite_ne_right_iff] at hA\n  rw [compress, if_pos hA.1, lt_iff_exists_filter_lt]\n  simp_rw [mem_sdiff (s := s), filter_inj, and_assoc]\n  refine ⟨_, hA.1.2 <| max'_mem _ hV, not_mem_sdiff_of_mem_right <| max'_mem _ _, fun a ha ↦ ?_⟩\n  have : a ∉ V := fun H ↦ ha.not_le (le_max' _ _ H)\n  have : a ∉ U := fun H ↦ ha.not_lt ((le_max' _ _ H).trans_lt h)\n  simp [‹a ∉ U›, ‹a ∉ V›]\n\n"}
{"name":"Finset.UV.isInitSeg_of_compressed","module":"Mathlib.Combinatorics.SetFamily.KruskalKatona","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nℬ : Finset (Finset α)\nr : Nat\nh₁ : Set.Sized r ↑ℬ\nh₂ : ∀ (U V : Finset α), Finset.UV.UsefulCompression U V → UV.IsCompressed U V ℬ\n⊢ Finset.Colex.IsInitSeg ℬ r","decl":"/-- If we're compressed by all useful compressions, then we're an initial segment. This is the other\nkey Kruskal-Katona part. -/\nlemma isInitSeg_of_compressed {ℬ : Finset (Finset α)} {r : ℕ} (h₁ : (ℬ : Set (Finset α)).Sized r)\n    (h₂ : ∀ U V, UsefulCompression U V → IsCompressed U V ℬ) : IsInitSeg ℬ r := by\n  refine ⟨h₁, ?_⟩\n  rintro A B hA ⟨hBA, sizeA⟩\n  by_contra hB\n  have hAB : A ≠ B := ne_of_mem_of_not_mem hA hB\n  have hAB' : #A = #B := (h₁ hA).trans sizeA.symm\n  have hU : (A \\ B).Nonempty := sdiff_nonempty.2 fun h ↦ hAB <| eq_of_subset_of_card_le h hAB'.ge\n  have hV : (B \\ A).Nonempty :=\n    sdiff_nonempty.2 fun h ↦ hAB.symm <| eq_of_subset_of_card_le h hAB'.le\n  have disj : Disjoint (B \\ A) (A \\ B) := disjoint_sdiff.mono_left sdiff_subset\n  have smaller : max' _ hV < max' _ hU := by\n    obtain hlt | heq | hgt := lt_trichotomy (max' _ hU) (max' _ hV)\n    · rw [← compress_sdiff_sdiff A B] at hAB hBA\n      cases hBA.not_lt <| toColex_compress_lt_toColex hlt hAB\n    · exact (disjoint_right.1 disj (max'_mem _ hU) <| heq.symm ▸ max'_mem _ _).elim\n    · assumption\n  refine hB ?_\n  rw [← (h₂ _ _ ⟨disj, card_sdiff_comm hAB'.symm, hV, hU, smaller⟩).eq]\n  exact mem_compression.2 (Or.inr ⟨hB, A, hA, compress_sdiff_sdiff _ _⟩)\n\n"}
{"name":"Finset.kruskal_katona","module":"Mathlib.Combinatorics.SetFamily.KruskalKatona","initialProofState":"n r : Nat\n𝒜 𝒞 : Finset (Finset (Fin n))\nh𝒜r : Set.Sized r ↑𝒜\nh𝒞𝒜 : LE.le 𝒞.card 𝒜.card\nh𝒞 : Finset.Colex.IsInitSeg 𝒞 r\n⊢ LE.le 𝒞.shadow.card 𝒜.shadow.card","decl":"/-- The **Kruskal-Katona theorem**.\n\nGiven a set family `𝒜` consisting of `r`-sets, and `𝒞` an initial segment of the colex order of the\nsame size, the shadow of `𝒞` is smaller than the shadow of `𝒜`. In particular, this gives that the\nminimum shadow size is achieved by initial segments of colex. -/\ntheorem kruskal_katona (h𝒜r : (𝒜 : Set (Finset (Fin n))).Sized r) (h𝒞𝒜 : #𝒞 ≤ #𝒜)\n    (h𝒞 : IsInitSeg 𝒞 r) : #(∂ 𝒞) ≤ #(∂ 𝒜) := by\n  -- WLOG `|𝒜| = |𝒞|`\n  obtain ⟨𝒜', h𝒜, h𝒜𝒞⟩ := exists_subset_card_eq h𝒞𝒜\n  -- By `kruskal_katona_helper`, we find a fully compressed family `ℬ` of the same size as `𝒜`\n  -- whose shadow is no bigger.\n  obtain ⟨ℬ, hℬ𝒜, h𝒜ℬ, hℬr, hℬ⟩ := UV.kruskal_katona_helper 𝒜' (h𝒜r.mono (by gcongr))\n  -- This means that `ℬ` is an initial segment of the same size as `𝒞`. Hence they are equal and\n  -- we are done.\n  suffices ℬ = 𝒞 by subst 𝒞; exact hℬ𝒜.trans (by gcongr)\n  have hcard : #ℬ = #𝒞 := h𝒜ℬ.symm.trans h𝒜𝒞\n  obtain h𝒞ℬ | hℬ𝒞 := h𝒞.total (UV.isInitSeg_of_compressed hℬr hℬ)\n  · exact (eq_of_subset_of_card_le h𝒞ℬ hcard.le).symm\n  · exact eq_of_subset_of_card_le hℬ𝒞 hcard.ge\n\n"}
{"name":"Finset.iterated_kk","module":"Mathlib.Combinatorics.SetFamily.KruskalKatona","initialProofState":"n r k : Nat\n𝒜 𝒞 : Finset (Finset (Fin n))\nh₁ : Set.Sized r ↑𝒜\nh₂ : LE.le 𝒞.card 𝒜.card\nh₃ : Finset.Colex.IsInitSeg 𝒞 r\n⊢ LE.le (Nat.iterate Finset.shadow k 𝒞).card (Nat.iterate Finset.shadow k 𝒜).card","decl":"/-- An iterated form of the Kruskal-Katona theorem. In particular, the minimum possible iterated\nshadow size is attained by initial segments. -/\ntheorem iterated_kk (h₁ : (𝒜 : Set (Finset (Fin n))).Sized r) (h₂ : #𝒞 ≤ #𝒜) (h₃ : IsInitSeg 𝒞 r) :\n    #(∂^[k] 𝒞) ≤ #(∂^[k] 𝒜) := by\n  induction' k with _k ih generalizing r 𝒜 𝒞\n  · simpa\n  · refine ih h₁.shadow (kruskal_katona h₁ h₂ h₃) ?_\n    convert h₃.shadow\n\n"}
{"name":"Finset.kruskal_katona_lovasz_form","module":"Mathlib.Combinatorics.SetFamily.KruskalKatona","initialProofState":"n r k i : Nat\n𝒜 : Finset (Finset (Fin n))\nhir : LE.le i r\nhrk : LE.le r k\nhkn : LE.le k n\nh₁ : Set.Sized r ↑𝒜\nh₂ : LE.le (k.choose r) 𝒜.card\n⊢ LE.le (k.choose (HSub.hSub r i)) (Nat.iterate Finset.shadow i 𝒜).card","decl":"/-- The **Lovasz formulation of the Kruskal-Katona theorem**.\n\nIf `|𝒜| ≥ k choose r`, (and everything in `𝒜` has size `r`) then the initial segment we compare to\nis just all the subsets of `{0, ..., k - 1}` of size `r`. The `i`-th iterated shadow of this is all\nthe subsets of `{0, ..., k - 1}` of size `r - i`, so the `i`-th iterated shadow of `𝒜` has at least\n`k.choose (r - i)` elements. -/\ntheorem kruskal_katona_lovasz_form (hir : i ≤ r) (hrk : r ≤ k) (hkn : k ≤ n)\n    (h₁ : (𝒜 : Set (Finset (Fin n))).Sized r) (h₂ : k.choose r ≤ #𝒜) :\n    k.choose (r - i) ≤ #(∂^[i] 𝒜) := by\n  set range'k : Finset (Fin n) :=\n    attachFin (range k) fun m ↦ by rw [mem_range]; apply forall_lt_iff_le.2 hkn\n  set 𝒞 : Finset (Finset (Fin n)) := powersetCard r range'k\n  have : (𝒞 : Set (Finset (Fin n))).Sized r := Set.sized_powersetCard _ _\n  calc\n    k.choose (r - i)\n    _ = #(powersetCard (r - i) range'k) := by rw [card_powersetCard, card_attachFin, card_range]\n    _ = #(∂^[i] 𝒞) := by\n      congr!\n      ext B\n      rw [mem_powersetCard, mem_shadow_iterate_iff_exists_sdiff]\n      constructor\n      · rintro ⟨hBk, hB⟩\n        have := exists_subsuperset_card_eq hBk (Nat.le_add_left _ i) <| by\n          rwa [hB, card_attachFin, card_range, ← Nat.add_sub_assoc hir, Nat.add_sub_cancel_left]\n        obtain ⟨C, BsubC, hCrange, hcard⟩ := this\n        rw [hB, ← Nat.add_sub_assoc hir, Nat.add_sub_cancel_left] at hcard\n        refine ⟨C, mem_powersetCard.2 ⟨hCrange, hcard⟩, BsubC, ?_⟩\n        rw [card_sdiff BsubC, hcard, hB, Nat.sub_sub_self hir]\n      · rintro ⟨A, Ah, hBA, card_sdiff_i⟩\n        rw [mem_powersetCard] at Ah\n        refine ⟨hBA.trans Ah.1, eq_tsub_of_add_eq ?_⟩\n        rw [← Ah.2, ← card_sdiff_i, add_comm, card_sdiff_add_card_eq_card hBA]\n    _ ≤ #(∂ ^[i] 𝒜) := by\n      refine iterated_kk h₁ ?_ ⟨‹_›, ?_⟩\n      · rwa [card_powersetCard, card_attachFin, card_range]\n      simp_rw [𝒞, mem_powersetCard]\n      rintro A B hA ⟨HB₁, HB₂⟩\n      refine ⟨fun t ht ↦ ?_, ‹_›⟩\n      rw [mem_attachFin, mem_range]\n      have : toColex (image Fin.val B) < toColex (image Fin.val A) := by\n        rwa [toColex_image_lt_toColex_image Fin.val_strictMono]\n      apply Colex.forall_lt_mono this.le _ t (mem_image.2 ⟨t, ht, rfl⟩)\n      simp_rw [mem_image]\n      rintro _ ⟨a, ha, hab⟩\n      simpa [range'k, hab] using hA.1 ha\n\n"}
{"name":"Finset.erdos_ko_rado","module":"Mathlib.Combinatorics.SetFamily.KruskalKatona","initialProofState":"n : Nat\n𝒜 : Finset (Finset (Fin n))\nr : Nat\nh𝒜 : (↑𝒜).Intersecting\nh₂ : Set.Sized r ↑𝒜\nh₃ : LE.le r (HDiv.hDiv n 2)\n⊢ LE.le 𝒜.card ((HSub.hSub n 1).choose (HSub.hSub r 1))","decl":"/-- The **Erdős–Ko–Rado theorem**.\n\nThe maximum size of an intersecting family in `α` where all sets have size `r` is bounded by\n`(card α - 1).choose (r - 1)`. This bound is sharp. -/\ntheorem erdos_ko_rado {𝒜 : Finset (Finset (Fin n))} {r : ℕ}\n    (h𝒜 : (𝒜 : Set (Finset (Fin n))).Intersecting) (h₂ : (𝒜 : Set (Finset (Fin n))).Sized r)\n    (h₃ : r ≤ n / 2) :\n    #𝒜 ≤ (n - 1).choose (r - 1) := by\n  -- Take care of the r=0 case first: it's not very interesting.\n  cases' Nat.eq_zero_or_pos r with b h1r\n  · convert Nat.zero_le _\n    rw [Finset.card_eq_zero, eq_empty_iff_forall_not_mem]\n    refine fun A HA ↦ h𝒜 HA HA ?_\n    rw [disjoint_self_iff_empty, ← Finset.card_eq_zero, ← b]\n    exact h₂ HA\n  refine le_of_not_lt fun size ↦ ?_\n  -- Consider 𝒜ᶜˢ = {sᶜ | s ∈ 𝒜}\n  -- Its iterated shadow (∂^[n-2k] 𝒜ᶜˢ) is disjoint from 𝒜 by intersecting-ness\n  have : Disjoint 𝒜 (∂^[n - 2 * r] 𝒜ᶜˢ) := disjoint_right.2 fun A hAbar hA ↦ by\n    simp [mem_shadow_iterate_iff_exists_sdiff, mem_compls] at hAbar\n    obtain ⟨C, hC, hAC, _⟩ := hAbar\n    exact h𝒜 hA hC (disjoint_of_subset_left hAC disjoint_compl_right)\n  have : r ≤ n := h₃.trans (Nat.div_le_self n 2)\n  have : 1 ≤ n := ‹1 ≤ r›.trans ‹r ≤ n›\n  -- We know the size of 𝒜ᶜˢ since it's the same size as 𝒜\n  have z : (n - 1).choose (n - r) < #𝒜ᶜˢ := by\n    rwa [card_compls, choose_symm_of_eq_add (tsub_add_tsub_cancel ‹r ≤ n› ‹1 ≤ r›).symm]\n  -- and everything in 𝒜ᶜˢ has size n-r.\n  have h𝒜bar : (𝒜ᶜˢ : Set (Finset (Fin n))).Sized (n - r) := by simpa using h₂.compls\n  have : n - 2 * r ≤ n - r := by\n    rw [tsub_le_tsub_iff_left ‹r ≤ n›]\n    exact Nat.le_mul_of_pos_left _ zero_lt_two\n  -- We can use the Lovasz form of Kruskal-Katona to get |∂^[n-2k] 𝒜ᶜˢ| ≥ (n-1) choose r\n  have kk := kruskal_katona_lovasz_form ‹n - 2 * r ≤ n - r› ((tsub_le_tsub_iff_left ‹1 ≤ n›).2 h1r)\n      tsub_le_self h𝒜bar z.le\n  have : n - r - (n - 2 * r) = r := by omega\n  rw [this] at kk\n  -- But this gives a contradiction: `n choose r < |𝒜| + |∂^[n-2k] 𝒜ᶜˢ|`\n  have : n.choose r < #(𝒜 ∪ ∂^[n - 2 * r] 𝒜ᶜˢ) := by\n    rw [card_union_of_disjoint ‹_›]\n    convert lt_of_le_of_lt (add_le_add_left kk _) (add_lt_add_right size _) using 1\n    convert Nat.choose_succ_succ _ _ using 3\n    all_goals rwa [Nat.sub_one, Nat.succ_pred_eq_of_pos]\n  apply this.not_le\n  convert Set.Sized.card_le _\n  · rw [Fintype.card_fin]\n  rw [coe_union, Set.sized_union]\n  refine ⟨‹_›, ?_⟩\n  convert h𝒜bar.shadow_iterate\n  omega\n\n"}
