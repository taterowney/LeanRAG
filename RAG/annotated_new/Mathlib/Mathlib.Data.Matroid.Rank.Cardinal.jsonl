{"name":"Matroid.Base.cardinalMk_le_cRank","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\nB : Set α\nhB : M.Base B\n⊢ LE.le (Cardinal.mk ↑B) M.cRank","decl":"theorem Base.cardinalMk_le_cRank (hB : M.Base B) : #B ≤ M.cRank :=\n  le_ciSup (f := fun (B : {B // M.Base B}) ↦ #(B.1)) (bddAbove_range _) ⟨B, hB⟩\n\n"}
{"name":"Matroid.Basis'.cardinalMk_le_cRk","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\nI X : Set α\nhIX : M.Basis' I X\n⊢ LE.le (Cardinal.mk ↑I) (M.cRk X)","decl":"theorem Basis'.cardinalMk_le_cRk (hIX : M.Basis' I X) : #I ≤ M.cRk X :=\n  (base_restrict_iff'.2 hIX).cardinalMk_le_cRank\n\n"}
{"name":"Matroid.Basis.cardinalMk_le_cRk","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\nI X : Set α\nhIX : M.Basis I X\n⊢ LE.le (Cardinal.mk ↑I) (M.cRk X)","decl":"theorem Basis.cardinalMk_le_cRk (hIX : M.Basis I X) : #I ≤ M.cRk X :=\n  hIX.basis'.cardinalMk_le_cRk\n\n"}
{"name":"Matroid.cRank_le_iff","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\nκ : Cardinal.{u}\n⊢ Iff (LE.le M.cRank κ) (∀ ⦃B : Set α⦄, M.Base B → LE.le (Cardinal.mk ↑B) κ)","decl":"theorem cRank_le_iff : M.cRank ≤ κ ↔ ∀ ⦃B⦄, M.Base B → #B ≤ κ :=\n  ⟨fun h _ hB ↦ (hB.cardinalMk_le_cRank.trans h), fun h ↦ ciSup_le fun ⟨_, hB⟩ ↦ h hB⟩\n\n"}
{"name":"Matroid.cRk_le_iff","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\nX : Set α\nκ : Cardinal.{u}\n⊢ Iff (LE.le (M.cRk X) κ) (∀ ⦃I : Set α⦄, M.Basis' I X → LE.le (Cardinal.mk ↑I) κ)","decl":"theorem cRk_le_iff : M.cRk X ≤ κ ↔ ∀ ⦃I⦄, M.Basis' I X → #I ≤ κ := by\n  simp_rw [cRk, cRank_le_iff, base_restrict_iff']\n\n"}
{"name":"Matroid.Indep.cardinalMk_le_cRk_of_subset","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\nI X : Set α\nhI : M.Indep I\nhIX : HasSubset.Subset I X\n⊢ LE.le (Cardinal.mk ↑I) (M.cRk X)","decl":"theorem Indep.cardinalMk_le_cRk_of_subset (hI : M.Indep I) (hIX : I ⊆ X) : #I ≤ M.cRk X :=\n  let ⟨_, hJ, hIJ⟩ := hI.subset_basis'_of_subset hIX\n  (mk_le_mk_of_subset hIJ).trans hJ.cardinalMk_le_cRk\n\n"}
{"name":"Matroid.cRk_le_cardinalMk","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\nX : Set α\n⊢ LE.le (M.cRk X) (Cardinal.mk ↑X)","decl":"theorem cRk_le_cardinalMk (M : Matroid α) (X : Set α) : M.cRk X ≤ #X :=\n  ciSup_le fun ⟨_, hI⟩ ↦ mk_le_mk_of_subset hI.subset_ground\n\n"}
{"name":"Matroid.cRk_ground","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\n⊢ Eq (M.cRk M.E) M.cRank","decl":"@[simp] theorem cRk_ground (M : Matroid α) : M.cRk M.E = M.cRank := by\n  rw [cRk, restrict_ground_eq_self]\n\n"}
{"name":"Matroid.cRank_restrict","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\nX : Set α\n⊢ Eq (M.restrict X).cRank (M.cRk X)","decl":"@[simp] theorem cRank_restrict (M : Matroid α) (X : Set α) : (M ↾ X).cRank = M.cRk X := rfl\n\n"}
{"name":"Matroid.cRk_mono","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\n⊢ Monotone M.cRk","decl":"theorem cRk_mono (M : Matroid α) : Monotone M.cRk := by\n  simp only [Monotone, le_eq_subset, cRk_le_iff]\n  intro X Y hXY I hIX\n  obtain ⟨J, hJ, hIJ⟩ := hIX.indep.subset_basis'_of_subset (hIX.subset.trans hXY)\n  exact (mk_le_mk_of_subset hIJ).trans hJ.cardinalMk_le_cRk\n\n"}
{"name":"Matroid.cRk_le_of_subset","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nX Y : Set α\nM : Matroid α\nhXY : HasSubset.Subset X Y\n⊢ LE.le (M.cRk X) (M.cRk Y)","decl":"theorem cRk_le_of_subset (M : Matroid α) (hXY : X ⊆ Y) : M.cRk X ≤ M.cRk Y :=\n  M.cRk_mono hXY\n\n"}
{"name":"Matroid.cRk_inter_ground","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\nX : Set α\n⊢ Eq (M.cRk (Inter.inter X M.E)) (M.cRk X)","decl":"@[simp] theorem cRk_inter_ground (M : Matroid α) (X : Set α) : M.cRk (X ∩ M.E) = M.cRk X :=\n  (M.cRk_le_of_subset inter_subset_left).antisymm <| cRk_le_iff.2\n    fun _ h ↦ h.basis_inter_ground.cardinalMk_le_cRk\n\n"}
{"name":"Matroid.cRk_restrict_subset","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nX Y : Set α\nM : Matroid α\nhYX : HasSubset.Subset Y X\n⊢ Eq ((M.restrict X).cRk Y) (M.cRk Y)","decl":"theorem cRk_restrict_subset (M : Matroid α) (hYX : Y ⊆ X) : (M ↾ X).cRk Y = M.cRk Y := by\n  have aux : ∀ ⦃I⦄, M.Basis' I Y ↔ (M ↾ X).Basis' I Y := by\n    simp_rw [basis'_restrict_iff, inter_eq_self_of_subset_left hYX, iff_self_and]\n    exact fun I h ↦ h.subset.trans hYX\n  simp_rw [le_antisymm_iff, cRk_le_iff]\n  exact ⟨fun I hI ↦ (aux.2 hI).cardinalMk_le_cRk, fun I hI ↦ (aux.1 hI).cardinalMk_le_cRk⟩\n\n"}
{"name":"Matroid.cRk_restrict","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\nX Y : Set α\n⊢ Eq ((M.restrict X).cRk Y) (M.cRk (Inter.inter X Y))","decl":"theorem cRk_restrict (M : Matroid α) (X Y : Set α) : (M ↾ X).cRk Y = M.cRk (X ∩ Y) := by\n  rw [← cRk_inter_ground, restrict_ground_eq, cRk_restrict_subset _ inter_subset_right,\n    inter_comm]\n\n"}
{"name":"Matroid.Indep.cRk_eq_cardinalMk","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\nI : Set α\nhI : M.Indep I\n⊢ Eq (Cardinal.mk ↑I) (M.cRk I)","decl":"theorem Indep.cRk_eq_cardinalMk (hI : M.Indep I) : #I = M.cRk I :=\n  (M.cRk_le_cardinalMk I).antisymm' (hI.basis_self.cardinalMk_le_cRk)\n\n"}
{"name":"Matroid.cRk_map_image_lift","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nM : Matroid α\nhf : Set.InjOn f M.E\nX : Set α\nhX : autoParam (HasSubset.Subset X M.E) _auto✝\n⊢ Eq (Cardinal.lift.{u, v} ((M.map f hf).cRk (Set.image f X))) (Cardinal.lift.{v, u} (M.cRk X))","decl":"@[simp] theorem cRk_map_image_lift (M : Matroid α) (hf : InjOn f M.E) (X : Set α)\n    (hX : X ⊆ M.E := by aesop_mat) : lift.{u,v} ((M.map f hf).cRk (f '' X)) = lift (M.cRk X) := by\n  nth_rw 1 [cRk, cRank, le_antisymm_iff, lift_iSup (bddAbove_range _), cRk, cRank, cRk, cRank]\n  nth_rw 2 [lift_iSup (bddAbove_range _)]\n  simp only [ciSup_le_iff (bddAbove_range _), ge_iff_le, Subtype.forall, base_restrict_iff',\n    basis'_iff_basis hX, basis'_iff_basis (show f '' X ⊆ (M.map f hf).E from image_mono hX)]\n  refine ⟨fun I hI ↦ ?_, fun I hI ↦ ?_⟩\n  · obtain ⟨I, X', hIX, rfl, hXX'⟩ := map_basis_iff'.1 hI\n    rw [mk_image_eq_of_injOn_lift _ _ (hf.mono hIX.indep.subset_ground), lift_le]\n    obtain rfl : X = X' := by rwa [hf.image_eq_image_iff hX hIX.subset_ground] at hXX'\n    exact hIX.cardinalMk_le_cRk\n  rw [← mk_image_eq_of_injOn_lift _ _ (hf.mono hI.indep.subset_ground), lift_le]\n  exact (hI.map hf).cardinalMk_le_cRk\n\n"}
{"name":"Matroid.cRk_map_image","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α β : Type u\nf : α → β\nM : Matroid α\nhf : Set.InjOn f M.E\nX : Set α\nhX : autoParam (HasSubset.Subset X M.E) _auto✝\n⊢ Eq ((M.map f hf).cRk (Set.image f X)) (M.cRk X)","decl":"@[simp] theorem cRk_map_image {β : Type u} {f : α → β} (M : Matroid α) (hf : InjOn f M.E)\n    (X : Set α) (hX : X ⊆ M.E := by aesop_mat) : (M.map f hf).cRk (f '' X) = M.cRk X :=\n  lift_inj.1 <| M.cRk_map_image_lift ..\n\n"}
{"name":"Matroid.cRk_map_eq","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α β : Type u\nf : α → β\nX : Set β\nM : Matroid α\nhf : Set.InjOn f M.E\n⊢ Eq ((M.map f hf).cRk X) (M.cRk (Set.preimage f X))","decl":"theorem cRk_map_eq {β : Type u} {f : α → β} {X : Set β} (M : Matroid α) (hf : InjOn f M.E) :\n    (M.map f hf).cRk X = M.cRk (f ⁻¹' X) := by\n  rw [← M.cRk_inter_ground, ← M.cRk_map_image hf _, image_preimage_inter, ← map_ground _ _ hf,\n    cRk_inter_ground]\n\n"}
{"name":"Matroid.cRk_comap_lift","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nβ : Type v\nM : Matroid β\nf : α → β\nX : Set α\n⊢ Eq (Cardinal.lift.{v, u} ((M.comap f).cRk X)) (Cardinal.lift.{u, v} (M.cRk (Set.image f X)))","decl":"@[simp] theorem cRk_comap_lift (M : Matroid β) (f : α → β) (X : Set α) :\n    lift.{v,u} ((M.comap f).cRk X) = lift (M.cRk (f '' X)) := by\n  nth_rw 1 [cRk, cRank, le_antisymm_iff, lift_iSup (bddAbove_range _), cRk, cRank, cRk, cRank]\n  nth_rw 2 [lift_iSup (bddAbove_range _)]\n  simp only [ciSup_le_iff (bddAbove_range _), ge_iff_le, Subtype.forall, base_restrict_iff',\n    comap_basis'_iff, and_imp]\n  refine ⟨fun I hI hfI hIX ↦ ?_, fun I hIX ↦ ?_⟩\n  · rw [← mk_image_eq_of_injOn_lift _ _ hfI, lift_le]\n    exact hI.cardinalMk_le_cRk\n  obtain ⟨I₀, hI₀X, rfl, hfI₀⟩ := show ∃ I₀ ⊆ X, f '' I₀ = I ∧ InjOn f I₀ by\n    obtain ⟨I₀, hI₀ss, hbij⟩ := exists_subset_bijOn (f ⁻¹' I ∩ X) f\n    refine ⟨I₀, hI₀ss.trans inter_subset_right, ?_, hbij.injOn⟩\n    rw [hbij.image_eq, image_preimage_inter, inter_eq_self_of_subset_left hIX.subset]\n  rw [mk_image_eq_of_injOn_lift _ _ hfI₀, lift_le]\n  exact Basis'.cardinalMk_le_cRk <| comap_basis'_iff.2 ⟨hIX, hfI₀, hI₀X⟩\n\n"}
{"name":"Matroid.cRk_comap","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α β : Type u\nM : Matroid β\nf : α → β\nX : Set α\n⊢ Eq ((M.comap f).cRk X) (M.cRk (Set.image f X))","decl":"@[simp] theorem cRk_comap {β : Type u} (M : Matroid β) (f : α → β) (X : Set α) :\n    (M.comap f).cRk X = M.cRk (f '' X) :=\n  lift_inj.1 <| M.cRk_comap_lift ..\n\n"}
{"name":"Matroid.invariantCardinalRank_iff","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\n⊢ Iff M.InvariantCardinalRank (∀ ⦃I J X : Set α⦄, M.Basis I X → M.Basis J X → Eq (Cardinal.mk ↑(SDiff.sdiff I J)) (Cardinal.mk ↑(SDiff.sdiff J I)))","decl":"/-- A class stating that cardinality-valued rank is well-defined\n(i.e. all bases are equicardinal) for a matroid `M` and its minors.\nNotably, this holds for `Finitary` matroids; see `Matroid.invariantCardinalRank_of_finitary`.  -/\n@[mk_iff]\nclass InvariantCardinalRank (M : Matroid α) : Prop where\n  forall_card_basis_diff :\n    ∀ ⦃I J X⦄, M.Basis I X → M.Basis J X → #(I \\ J : Set α) = #(J \\ I : Set α)\n\n"}
{"name":"Matroid.InvariantCardinalRank.forall_card_basis_diff","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\nself : M.InvariantCardinalRank\nI J X : Set α\na✝¹ : M.Basis I X\na✝ : M.Basis J X\n⊢ Eq (Cardinal.mk ↑(SDiff.sdiff I J)) (Cardinal.mk ↑(SDiff.sdiff J I))","decl":"/-- A class stating that cardinality-valued rank is well-defined\n(i.e. all bases are equicardinal) for a matroid `M` and its minors.\nNotably, this holds for `Finitary` matroids; see `Matroid.invariantCardinalRank_of_finitary`.  -/\n@[mk_iff]\nclass InvariantCardinalRank (M : Matroid α) : Prop where\n  forall_card_basis_diff :\n    ∀ ⦃I J X⦄, M.Basis I X → M.Basis J X → #(I \\ J : Set α) = #(J \\ I : Set α)\n\n"}
{"name":"Matroid.Basis.cardinalMk_diff_comm","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\nI J X : Set α\ninst✝ : M.InvariantCardinalRank\nhIX : M.Basis I X\nhJX : M.Basis J X\n⊢ Eq (Cardinal.mk ↑(SDiff.sdiff I J)) (Cardinal.mk ↑(SDiff.sdiff J I))","decl":"theorem Basis.cardinalMk_diff_comm (hIX : M.Basis I X) (hJX : M.Basis J X) :\n    #(I \\ J : Set α) = #(J \\ I : Set α) :=\n  InvariantCardinalRank.forall_card_basis_diff hIX hJX\n\n"}
{"name":"Matroid.Basis'.cardinalMk_diff_comm","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\nI J X : Set α\ninst✝ : M.InvariantCardinalRank\nhIX : M.Basis' I X\nhJX : M.Basis' J X\n⊢ Eq (Cardinal.mk ↑(SDiff.sdiff I J)) (Cardinal.mk ↑(SDiff.sdiff J I))","decl":"theorem Basis'.cardinalMk_diff_comm (hIX : M.Basis' I X) (hJX : M.Basis' J X) :\n    #(I \\ J : Set α) = #(J \\ I : Set α) :=\n  hIX.basis_inter_ground.cardinalMk_diff_comm hJX.basis_inter_ground\n\n"}
{"name":"Matroid.Base.cardinalMk_diff_comm","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\nB B' : Set α\ninst✝ : M.InvariantCardinalRank\nhB : M.Base B\nhB' : M.Base B'\n⊢ Eq (Cardinal.mk ↑(SDiff.sdiff B B')) (Cardinal.mk ↑(SDiff.sdiff B' B))","decl":"theorem Base.cardinalMk_diff_comm (hB : M.Base B) (hB' : M.Base B') :\n    #(B \\ B' : Set α) = #(B' \\ B : Set α) :=\n  hB.basis_ground.cardinalMk_diff_comm hB'.basis_ground\n\n"}
{"name":"Matroid.Basis.cardinalMk_eq","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\nI J X : Set α\ninst✝ : M.InvariantCardinalRank\nhIX : M.Basis I X\nhJX : M.Basis J X\n⊢ Eq (Cardinal.mk ↑I) (Cardinal.mk ↑J)","decl":"theorem Basis.cardinalMk_eq (hIX : M.Basis I X) (hJX : M.Basis J X) : #I = #J := by\n  rw [← diff_union_inter I J,\n    mk_union_of_disjoint (disjoint_sdiff_left.mono_right inter_subset_right),\n    hIX.cardinalMk_diff_comm hJX,\n    ← mk_union_of_disjoint (disjoint_sdiff_left.mono_right inter_subset_left),\n    inter_comm, diff_union_inter]\n\n"}
{"name":"Matroid.Basis'.cardinalMk_eq","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\nI J X : Set α\ninst✝ : M.InvariantCardinalRank\nhIX : M.Basis' I X\nhJX : M.Basis' J X\n⊢ Eq (Cardinal.mk ↑I) (Cardinal.mk ↑J)","decl":"theorem Basis'.cardinalMk_eq (hIX : M.Basis' I X) (hJX : M.Basis' J X) : #I = #J :=\n  hIX.basis_inter_ground.cardinalMk_eq hJX.basis_inter_ground\n\n"}
{"name":"Matroid.Base.cardinalMk_eq","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\nB B' : Set α\ninst✝ : M.InvariantCardinalRank\nhB : M.Base B\nhB' : M.Base B'\n⊢ Eq (Cardinal.mk ↑B) (Cardinal.mk ↑B')","decl":"theorem Base.cardinalMk_eq (hB : M.Base B) (hB' : M.Base B') : #B = #B' :=\n  hB.basis_ground.cardinalMk_eq hB'.basis_ground\n\n"}
{"name":"Matroid.Indep.cardinalMk_le_base","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\nI B : Set α\ninst✝ : M.InvariantCardinalRank\nhI : M.Indep I\nhB : M.Base B\n⊢ LE.le (Cardinal.mk ↑I) (Cardinal.mk ↑B)","decl":"theorem Indep.cardinalMk_le_base (hI : M.Indep I) (hB : M.Base B) : #I ≤ #B :=\n  have ⟨_B', hB', hIB'⟩ := hI.exists_base_superset\n  hB'.cardinalMk_eq hB ▸ mk_le_mk_of_subset hIB'\n\n"}
{"name":"Matroid.Indep.cardinalMk_le_basis'","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\nI J X : Set α\ninst✝ : M.InvariantCardinalRank\nhI : M.Indep I\nhJ : M.Basis' J X\nhIX : HasSubset.Subset I X\n⊢ LE.le (Cardinal.mk ↑I) (Cardinal.mk ↑J)","decl":"theorem Indep.cardinalMk_le_basis' (hI : M.Indep I) (hJ : M.Basis' J X) (hIX : I ⊆ X) :\n    #I ≤ #J :=\n  have ⟨_J', hJ', hIJ'⟩ := hI.subset_basis'_of_subset hIX\n  hJ'.cardinalMk_eq hJ ▸ mk_le_mk_of_subset hIJ'\n\n"}
{"name":"Matroid.Indep.cardinalMk_le_basis","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\nI J X : Set α\ninst✝ : M.InvariantCardinalRank\nhI : M.Indep I\nhJ : M.Basis J X\nhIX : HasSubset.Subset I X\n⊢ LE.le (Cardinal.mk ↑I) (Cardinal.mk ↑J)","decl":"theorem Indep.cardinalMk_le_basis (hI : M.Indep I) (hJ : M.Basis J X) (hIX : I ⊆ X) :\n    #I ≤ #J :=\n  hI.cardinalMk_le_basis' hJ.basis' hIX\n\n"}
{"name":"Matroid.Base.cardinalMk_eq_cRank","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\nB : Set α\ninst✝ : M.InvariantCardinalRank\nhB : M.Base B\n⊢ Eq (Cardinal.mk ↑B) M.cRank","decl":"theorem Base.cardinalMk_eq_cRank (hB : M.Base B) : #B = M.cRank := by\n  have hrw : ∀ B' : {B : Set α // M.Base B}, #B' = #B := fun B' ↦ B'.2.cardinalMk_eq hB\n  simp [cRank, hrw]\n\n"}
{"name":"Matroid.invariantCardinalRank_restrict","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\nX : Set α\ninst✝ : M.InvariantCardinalRank\n⊢ (M.restrict X).InvariantCardinalRank","decl":"/-- Restrictions of matroids with cardinal rank functions have cardinal rank functions- -/\ninstance invariantCardinalRank_restrict [InvariantCardinalRank M] :\n    InvariantCardinalRank (M ↾ X) := by\n  refine ⟨fun I J Y hI hJ ↦ ?_⟩\n  rw [basis_restrict_iff'] at hI hJ\n  exact hI.1.cardinalMk_diff_comm hJ.1\n\n"}
{"name":"Matroid.Basis'.cardinalMk_eq_cRk","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\nI X : Set α\ninst✝ : M.InvariantCardinalRank\nhIX : M.Basis' I X\n⊢ Eq (Cardinal.mk ↑I) (M.cRk X)","decl":"theorem Basis'.cardinalMk_eq_cRk (hIX : M.Basis' I X) : #I = M.cRk X := by\n  rw [cRk, (base_restrict_iff'.2 hIX).cardinalMk_eq_cRank]\n\n"}
{"name":"Matroid.Basis.cardinalMk_eq_cRk","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\nI X : Set α\ninst✝ : M.InvariantCardinalRank\nhIX : M.Basis I X\n⊢ Eq (Cardinal.mk ↑I) (M.cRk X)","decl":"theorem Basis.cardinalMk_eq_cRk (hIX : M.Basis I X) : #I = M.cRk X :=\n  hIX.basis'.cardinalMk_eq_cRk\n\n"}
{"name":"Matroid.cRk_closure","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\ninst✝ : M.InvariantCardinalRank\nX : Set α\n⊢ Eq (M.cRk (M.closure X)) (M.cRk X)","decl":"@[simp] theorem cRk_closure (M : Matroid α) [InvariantCardinalRank M] (X : Set α) :\n    M.cRk (M.closure X) = M.cRk X := by\n  obtain ⟨I, hI⟩ := M.exists_basis' X\n  rw [← hI.basis_closure_right.cardinalMk_eq_cRk, ← hI.cardinalMk_eq_cRk]\n\n"}
{"name":"Matroid.cRk_closure_congr","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\nX Y : Set α\ninst✝ : M.InvariantCardinalRank\nhXY : Eq (M.closure X) (M.closure Y)\n⊢ Eq (M.cRk X) (M.cRk Y)","decl":"theorem cRk_closure_congr (hXY : M.closure X = M.closure Y) : M.cRk X = M.cRk Y := by\n  rw [← cRk_closure, hXY, cRk_closure]\n\n"}
{"name":"Matroid.cRk_union_closure_right_eq","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\ninst✝ : M.InvariantCardinalRank\nX Y : Set α\n⊢ Eq (M.cRk (Union.union X (M.closure Y))) (M.cRk (Union.union X Y))","decl":"@[simp] theorem cRk_union_closure_right_eq : M.cRk (X ∪ M.closure Y) = M.cRk (X ∪ Y) :=\n  M.cRk_closure_congr (M.closure_union_closure_right_eq _ _)\n\n"}
{"name":"Matroid.cRk_union_closure_left_eq","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\ninst✝ : M.InvariantCardinalRank\nX Y : Set α\n⊢ Eq (M.cRk (Union.union (M.closure X) Y)) (M.cRk (Union.union X Y))","decl":"@[simp] theorem cRk_union_closure_left_eq : M.cRk (M.closure X ∪ Y) = M.cRk (X ∪ Y) :=\n  M.cRk_closure_congr (M.closure_union_closure_left_eq _ _)\n\n"}
{"name":"Matroid.cRk_insert_closure_eq","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\ninst✝ : M.InvariantCardinalRank\ne : α\nX : Set α\n⊢ Eq (M.cRk (Insert.insert e (M.closure X))) (M.cRk (Insert.insert e X))","decl":"@[simp] theorem cRk_insert_closure_eq : M.cRk (insert e (M.closure X)) = M.cRk (insert e X) := by\n  rw [← union_singleton, cRk_union_closure_left_eq, union_singleton]\n\n"}
{"name":"Matroid.cRk_union_closure_eq","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\ninst✝ : M.InvariantCardinalRank\nX Y : Set α\n⊢ Eq (M.cRk (Union.union (M.closure X) (M.closure Y))) (M.cRk (Union.union X Y))","decl":"theorem cRk_union_closure_eq : M.cRk (M.closure X ∪ M.closure Y) = M.cRk (X ∪ Y) := by\n  simp\n\n"}
{"name":"Matroid.cRk_inter_add_cRk_union_le","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\ninst✝ : M.InvariantCardinalRank\nX Y : Set α\n⊢ LE.le (HAdd.hAdd (M.cRk (Inter.inter X Y)) (M.cRk (Union.union X Y))) (HAdd.hAdd (M.cRk X) (M.cRk Y))","decl":"/-- The `Cardinal` rank function is submodular. -/\ntheorem cRk_inter_add_cRk_union_le : M.cRk (X ∩ Y) + M.cRk (X ∪ Y) ≤ M.cRk X + M.cRk Y := by\n  obtain ⟨Ii, hIi⟩ := M.exists_basis' (X ∩ Y)\n  obtain ⟨IX, hIX, hIX'⟩ :=\n    hIi.indep.subset_basis'_of_subset (hIi.subset.trans inter_subset_left)\n  obtain ⟨IY, hIY, hIY'⟩ :=\n    hIi.indep.subset_basis'_of_subset (hIi.subset.trans inter_subset_right)\n  rw [← cRk_union_closure_eq, ← hIX.closure_eq_closure, ← hIY.closure_eq_closure,\n    cRk_union_closure_eq, ← hIi.cardinalMk_eq_cRk, ← hIX.cardinalMk_eq_cRk,\n    ← hIY.cardinalMk_eq_cRk, ← mk_union_add_mk_inter, add_comm]\n  exact add_le_add (M.cRk_le_cardinalMk _) (mk_le_mk_of_subset (subset_inter hIX' hIY'))\n\n"}
{"name":"Matroid.invariantCardinalRank_of_finitary","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nM : Matroid α\ninst✝ : M.Finitary\n⊢ M.InvariantCardinalRank","decl":"/-- `Finitary` matroids have a cardinality-valued rank function. -/\ninstance invariantCardinalRank_of_finitary [Finitary M] : InvariantCardinalRank M := by\n  suffices aux : ∀ ⦃B B'⦄ ⦃N : Matroid α⦄, Finitary N → N.Base B → N.Base B' →\n      #(B \\ B' : Set α) ≤ #(B' \\ B : Set α) from\n    ⟨fun I J X hI hJ ↦ (aux (restrict_finitary X) hI.base_restrict hJ.base_restrict).antisymm\n      (aux (restrict_finitary X) hJ.base_restrict hI.base_restrict)⟩\n  intro B B' N hfin hB hB'\n  by_cases h : (B' \\ B).Finite\n  · rw [← cast_ncard h, ← cast_ncard, hB.ncard_diff_comm hB']\n    exact (hB'.diff_finite_comm hB).mp h\n  rw [← Set.Infinite, ← infinite_coe_iff] at h\n  have (a : α) (ha : a ∈ B' \\ B) : ∃ S : Set α, Finite S ∧ S ⊆ B ∧ ¬ N.Indep (insert a S) := by\n    have := (hB.insert_dep ⟨hB'.subset_ground ha.1, ha.2⟩).1\n    contrapose! this\n    exact Finitary.indep_of_forall_finite _ fun J hJ fin ↦ (this (J \\ {a}) fin.diff.to_subtype <|\n      diff_singleton_subset_iff.mpr hJ).subset (subset_insert_diff_singleton ..)\n  choose S S_fin hSB dep using this\n  let U := ⋃ a : ↥(B' \\ B), S a a.2\n  suffices B \\ B' ⊆ U by\n    refine (mk_le_mk_of_subset this).trans <| (mk_iUnion_le ..).trans\n      <| (mul_le_max_of_aleph0_le_left (by simp)).trans ?_\n    simp only [sup_le_iff, le_refl, true_and]\n    exact ciSup_le' fun e ↦ (lt_aleph0_of_finite _).le.trans <| by simp\n  rw [← diff_inter_self_eq_diff, diff_subset_iff, inter_comm]\n  have hUB : (B ∩ B') ∪ U ⊆ B :=\n    union_subset inter_subset_left (iUnion_subset fun e ↦ (hSB e.1 e.2))\n  by_contra hBU\n  have ⟨a, ha, ind⟩ := hB.exists_insert_of_ssubset ⟨hUB, hBU⟩ hB'\n  have : a ∈ B' \\ B := ⟨ha.1, fun haB ↦ ha.2 (.inl ⟨haB, ha.1⟩)⟩\n  refine dep a this (ind.subset <| insert_subset_insert <| .trans ?_ subset_union_right)\n  exact subset_iUnion_of_subset ⟨a, this⟩ subset_rfl\n\n"}
{"name":"Matroid.invariantCardinalRank_map","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nM : Matroid α\ninst✝ : M.InvariantCardinalRank\nhf : Set.InjOn f M.E\n⊢ (M.map f hf).InvariantCardinalRank","decl":"instance invariantCardinalRank_map (M : Matroid α) [InvariantCardinalRank M] (hf : InjOn f M.E) :\n    InvariantCardinalRank (M.map f hf) := by\n  refine ⟨fun I J X hI hJ ↦ ?_⟩\n  obtain ⟨I, X, hIX, rfl, rfl⟩ := map_basis_iff'.1 hI\n  obtain ⟨J, X', hJX, rfl, h'⟩ := map_basis_iff'.1 hJ\n  obtain rfl : X = X' := by\n    rwa [InjOn.image_eq_image_iff hf hIX.subset_ground hJX.subset_ground] at h'\n  have hcard := hIX.cardinalMk_diff_comm hJX\n  rwa [← lift_inj.{u,v},\n    ← mk_image_eq_of_injOn_lift _ _ (hf.mono ((hIX.indep.diff _).subset_ground)),\n    ← mk_image_eq_of_injOn_lift _ _ (hf.mono ((hJX.indep.diff _).subset_ground)),\n    lift_inj, (hf.mono hIX.indep.subset_ground).image_diff,\n    (hf.mono hJX.indep.subset_ground).image_diff, inter_comm,\n    hf.image_inter hJX.indep.subset_ground hIX.indep.subset_ground,\n    diff_inter_self_eq_diff, diff_self_inter] at hcard\n\n"}
{"name":"Matroid.invariantCardinalRank_comap","module":"Mathlib.Data.Matroid.Rank.Cardinal","initialProofState":"α : Type u\nβ : Type v\nM : Matroid β\ninst✝ : M.InvariantCardinalRank\nf : α → β\n⊢ (M.comap f).InvariantCardinalRank","decl":"instance invariantCardinalRank_comap (M : Matroid β) [InvariantCardinalRank M] (f : α → β) :\n    InvariantCardinalRank (M.comap f) := by\n  refine ⟨fun I J X hI hJ ↦ ?_⟩\n  obtain ⟨hI, hfI, hIX⟩ := comap_basis_iff.1 hI\n  obtain ⟨hJ, hfJ, hJX⟩ := comap_basis_iff.1 hJ\n  rw [← lift_inj.{u,v}, ← mk_image_eq_of_injOn_lift _ _ (hfI.mono diff_subset),\n    ← mk_image_eq_of_injOn_lift _ _ (hfJ.mono diff_subset), lift_inj, hfI.image_diff,\n    hfJ.image_diff, ← diff_union_diff_cancel inter_subset_left (image_inter_subset f I J),\n    inter_comm, diff_inter_self_eq_diff, mk_union_of_disjoint, hI.cardinalMk_diff_comm hJ,\n    ← diff_union_diff_cancel inter_subset_left (image_inter_subset f J I), inter_comm,\n    diff_inter_self_eq_diff, mk_union_of_disjoint, inter_comm J I] <;>\n  exact disjoint_sdiff_left.mono_right (diff_subset.trans inter_subset_left)\n\n"}
