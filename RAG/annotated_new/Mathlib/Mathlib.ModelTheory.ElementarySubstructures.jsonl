{"name":"FirstOrder.Language.ElementarySubstructure.mk.inj","module":"Mathlib.ModelTheory.ElementarySubstructures","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\ntoSubstructure✝ : L.Substructure M\nisElementary'✝ : toSubstructure✝.IsElementary\ntoSubstructure : L.Substructure M\nisElementary' : toSubstructure.IsElementary\nx✝ : Eq { toSubstructure := toSubstructure✝, isElementary' := isElementary'✝ } { toSubstructure := toSubstructure, isElementary' := isElementary' }\n⊢ Eq toSubstructure✝ toSubstructure","decl":"/-- An elementary substructure is one in which every formula applied to a tuple in the substructure\n  agrees with its value in the overall structure. -/\nstructure ElementarySubstructure where\n  toSubstructure : L.Substructure M\n  isElementary' : toSubstructure.IsElementary\n\n"}
{"name":"FirstOrder.Language.ElementarySubstructure.mk.injEq","module":"Mathlib.ModelTheory.ElementarySubstructures","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\ntoSubstructure✝ : L.Substructure M\nisElementary'✝ : toSubstructure✝.IsElementary\ntoSubstructure : L.Substructure M\nisElementary' : toSubstructure.IsElementary\n⊢ Eq (Eq { toSubstructure := toSubstructure✝, isElementary' := isElementary'✝ } { toSubstructure := toSubstructure, isElementary' := isElementary' }) (Eq toSubstructure✝ toSubstructure)","decl":"/-- An elementary substructure is one in which every formula applied to a tuple in the substructure\n  agrees with its value in the overall structure. -/\nstructure ElementarySubstructure where\n  toSubstructure : L.Substructure M\n  isElementary' : toSubstructure.IsElementary\n\n"}
{"name":"FirstOrder.Language.ElementarySubstructure.isElementary'","module":"Mathlib.ModelTheory.ElementarySubstructures","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\nself : L.ElementarySubstructure M\n⊢ self.toSubstructure.IsElementary","decl":"/-- An elementary substructure is one in which every formula applied to a tuple in the substructure\n  agrees with its value in the overall structure. -/\nstructure ElementarySubstructure where\n  toSubstructure : L.Substructure M\n  isElementary' : toSubstructure.IsElementary\n\n"}
{"name":"FirstOrder.Language.ElementarySubstructure.mk.sizeOf_spec","module":"Mathlib.ModelTheory.ElementarySubstructures","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : SizeOf M\ntoSubstructure : L.Substructure M\nisElementary' : toSubstructure.IsElementary\n⊢ Eq (SizeOf.sizeOf { toSubstructure := toSubstructure, isElementary' := isElementary' }) (HAdd.hAdd 1 (SizeOf.sizeOf toSubstructure))","decl":"/-- An elementary substructure is one in which every formula applied to a tuple in the substructure\n  agrees with its value in the overall structure. -/\nstructure ElementarySubstructure where\n  toSubstructure : L.Substructure M\n  isElementary' : toSubstructure.IsElementary\n\n"}
{"name":"FirstOrder.Language.ElementarySubstructure.isElementary","module":"Mathlib.ModelTheory.ElementarySubstructures","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\nS : L.ElementarySubstructure M\n⊢ (↑S).IsElementary","decl":"@[simp]\ntheorem isElementary (S : L.ElementarySubstructure M) : (S : L.Substructure M).IsElementary :=\n  S.isElementary'\n\n"}
{"name":"FirstOrder.Language.ElementarySubstructure.coeSubtype","module":"Mathlib.ModelTheory.ElementarySubstructures","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\nS : L.ElementarySubstructure M\n⊢ Eq (⇑S.subtype) Subtype.val","decl":"@[simp]\ntheorem coeSubtype {S : L.ElementarySubstructure M} : ⇑S.subtype = ((↑) : S → M) :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.ElementarySubstructure.mem_top","module":"Mathlib.ModelTheory.ElementarySubstructures","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\nx : M\n⊢ Membership.mem Top.top x","decl":"@[simp]\ntheorem mem_top (x : M) : x ∈ (⊤ : L.ElementarySubstructure M) :=\n  Set.mem_univ x\n\n"}
{"name":"FirstOrder.Language.ElementarySubstructure.coe_top","module":"Mathlib.ModelTheory.ElementarySubstructures","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\n⊢ Eq (↑Top.top) Set.univ","decl":"@[simp]\ntheorem coe_top : ((⊤ : L.ElementarySubstructure M) : Set M) = Set.univ :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.ElementarySubstructure.realize_sentence","module":"Mathlib.ModelTheory.ElementarySubstructures","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\nS : L.ElementarySubstructure M\nφ : L.Sentence\n⊢ Iff (FirstOrder.Language.Sentence.Realize (Subtype fun x => Membership.mem S x) φ) (FirstOrder.Language.Sentence.Realize M φ)","decl":"@[simp]\ntheorem realize_sentence (S : L.ElementarySubstructure M) (φ : L.Sentence) : S ⊨ φ ↔ M ⊨ φ :=\n  S.subtype.map_sentence φ\n\n"}
{"name":"FirstOrder.Language.ElementarySubstructure.theory_model_iff","module":"Mathlib.ModelTheory.ElementarySubstructures","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\nS : L.ElementarySubstructure M\nT : L.Theory\n⊢ Iff (FirstOrder.Language.Theory.Model (Subtype fun x => Membership.mem S x) T) (FirstOrder.Language.Theory.Model M T)","decl":"@[simp]\ntheorem theory_model_iff (S : L.ElementarySubstructure M) (T : L.Theory) : S ⊨ T ↔ M ⊨ T := by\n  simp only [Theory.model_iff, realize_sentence]\n\n"}
{"name":"FirstOrder.Language.ElementarySubstructure.theory_model","module":"Mathlib.ModelTheory.ElementarySubstructures","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\nT : L.Theory\nh : FirstOrder.Language.Theory.Model M T\nS : L.ElementarySubstructure M\n⊢ FirstOrder.Language.Theory.Model (Subtype fun x => Membership.mem S x) T","decl":"instance theory_model {T : L.Theory} [h : M ⊨ T] {S : L.ElementarySubstructure M} : S ⊨ T :=\n  (theory_model_iff S T).2 h\n\n"}
{"name":"FirstOrder.Language.ElementarySubstructure.instNonempty","module":"Mathlib.ModelTheory.ElementarySubstructures","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝¹ : L.Structure M\ninst✝ : Nonempty M\nS : L.ElementarySubstructure M\n⊢ Nonempty (Subtype fun x => Membership.mem S x)","decl":"instance instNonempty [Nonempty M] {S : L.ElementarySubstructure M} : Nonempty S :=\n  (model_nonemptyTheory_iff L).1 inferInstance\n\n"}
{"name":"FirstOrder.Language.ElementarySubstructure.elementarilyEquivalent","module":"Mathlib.ModelTheory.ElementarySubstructures","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\nS : L.ElementarySubstructure M\n⊢ L.ElementarilyEquivalent (Subtype fun x => Membership.mem S x) M","decl":"theorem elementarilyEquivalent (S : L.ElementarySubstructure M) : S ≅[L] M :=\n  S.subtype.elementarilyEquivalent\n\n"}
{"name":"FirstOrder.Language.Substructure.isElementary_of_exists","module":"Mathlib.ModelTheory.ElementarySubstructures","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\nS : L.Substructure M\nhtv : ∀ (n : Nat) (φ : L.BoundedFormula Empty (HAdd.hAdd n 1)) (x : Fin n → Subtype fun x => Membership.mem S x) (a : M), φ.Realize Inhabited.default (Fin.snoc (Function.comp Subtype.val x) a) → Exists fun b => φ.Realize Inhabited.default (Fin.snoc (Function.comp Subtype.val x) ↑b)\n⊢ S.IsElementary","decl":"/-- The Tarski-Vaught test for elementarity of a substructure. -/\ntheorem isElementary_of_exists (S : L.Substructure M)\n    (htv :\n      ∀ (n : ℕ) (φ : L.BoundedFormula Empty (n + 1)) (x : Fin n → S) (a : M),\n        φ.Realize default (Fin.snoc ((↑) ∘ x) a : _ → M) →\n          ∃ b : S, φ.Realize default (Fin.snoc ((↑) ∘ x) b : _ → M)) :\n    S.IsElementary := fun _ => S.subtype.isElementary_of_exists htv\n\n"}
{"name":"FirstOrder.Language.Substructure.toElementarySubstructure_toSubstructure","module":"Mathlib.ModelTheory.ElementarySubstructures","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ninst✝ : L.Structure M\nS : L.Substructure M\nhtv : ∀ (n : Nat) (φ : L.BoundedFormula Empty (HAdd.hAdd n 1)) (x : Fin n → Subtype fun x => Membership.mem S x) (a : M), φ.Realize Inhabited.default (Fin.snoc (Function.comp Subtype.val x) a) → Exists fun b => φ.Realize Inhabited.default (Fin.snoc (Function.comp Subtype.val x) ↑b)\n⊢ Eq (↑(S.toElementarySubstructure htv)) S","decl":"/-- Bundles a substructure satisfying the Tarski-Vaught test as an elementary substructure. -/\n@[simps]\ndef toElementarySubstructure (S : L.Substructure M)\n    (htv :\n      ∀ (n : ℕ) (φ : L.BoundedFormula Empty (n + 1)) (x : Fin n → S) (a : M),\n        φ.Realize default (Fin.snoc ((↑) ∘ x) a : _ → M) →\n          ∃ b : S, φ.Realize default (Fin.snoc ((↑) ∘ x) b : _ → M)) :\n    L.ElementarySubstructure M :=\n  ⟨S, S.isElementary_of_exists htv⟩\n\n"}
