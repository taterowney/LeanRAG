{"name":"Multiset.coe_keys","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\nl : List (Sigma β)\n⊢ Eq (↑l).keys ↑l.keys","decl":"@[simp]\ntheorem coe_keys {l : List (Sigma β)} : keys (l : Multiset (Sigma β)) = (l.keys : Multiset α) :=\n  rfl\n\n-- Porting note: Fixed Nodupkeys -> NodupKeys\n"}
{"name":"Multiset.coe_nodupKeys","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\nl : List (Sigma β)\n⊢ Iff (↑l).NodupKeys l.NodupKeys","decl":"@[simp]\ntheorem coe_nodupKeys {l : List (Sigma β)} : @NodupKeys α β l ↔ l.NodupKeys :=\n  Iff.rfl\n\n"}
{"name":"Multiset.nodup_keys","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\nm : Multiset (Sigma fun a => β a)\n⊢ Iff m.keys.Nodup m.NodupKeys","decl":"lemma nodup_keys {m : Multiset (Σ a, β a)} : m.keys.Nodup ↔ m.NodupKeys := by\n  rcases m with ⟨l⟩; rfl\n\n"}
{"name":"Multiset.NodupKeys.nodup_keys","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\nm : Multiset (Sigma fun a => β a)\na✝ : m.NodupKeys\n⊢ m.keys.Nodup","decl":"alias ⟨_, NodupKeys.nodup_keys⟩ := nodup_keys\n\n"}
{"name":"Multiset.NodupKeys.nodup","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\nm : Multiset (Sigma fun a => β a)\nh : m.NodupKeys\n⊢ m.Nodup","decl":"protected lemma NodupKeys.nodup {m : Multiset (Σ a, β a)} (h : m.NodupKeys) : m.Nodup :=\n  h.nodup_keys.of_map _\n\n"}
{"name":"Finmap.mk.sizeOf_spec","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝¹ : SizeOf α\ninst✝ : (a : α) → SizeOf (β a)\nentries : Multiset (Sigma β)\nnodupKeys : entries.NodupKeys\n⊢ Eq (SizeOf.sizeOf { entries := entries, nodupKeys := nodupKeys }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf entries)) (SizeOf.sizeOf nodupKeys))","decl":"/-- `Finmap β` is the type of finite maps over a multiset. It is effectively\n  a quotient of `AList β` by permutation of the underlying list. -/\nstructure Finmap (β : α → Type v) : Type max u v where\n  /-- The underlying `Multiset` of a `Finmap` -/\n  entries : Multiset (Sigma β)\n  /-- There are no duplicate keys in `entries` -/\n  nodupKeys : entries.NodupKeys\n\n"}
{"name":"Finmap.mk.injEq","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\nentries✝ : Multiset (Sigma β)\nnodupKeys✝ : entries✝.NodupKeys\nentries : Multiset (Sigma β)\nnodupKeys : entries.NodupKeys\n⊢ Eq (Eq { entries := entries✝, nodupKeys := nodupKeys✝ } { entries := entries, nodupKeys := nodupKeys }) (Eq entries✝ entries)","decl":"/-- `Finmap β` is the type of finite maps over a multiset. It is effectively\n  a quotient of `AList β` by permutation of the underlying list. -/\nstructure Finmap (β : α → Type v) : Type max u v where\n  /-- The underlying `Multiset` of a `Finmap` -/\n  entries : Multiset (Sigma β)\n  /-- There are no duplicate keys in `entries` -/\n  nodupKeys : entries.NodupKeys\n\n"}
{"name":"Finmap.mk.inj","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\nentries✝ : Multiset (Sigma β)\nnodupKeys✝ : entries✝.NodupKeys\nentries : Multiset (Sigma β)\nnodupKeys : entries.NodupKeys\nx✝ : Eq { entries := entries✝, nodupKeys := nodupKeys✝ } { entries := entries, nodupKeys := nodupKeys }\n⊢ Eq entries✝ entries","decl":"/-- `Finmap β` is the type of finite maps over a multiset. It is effectively\n  a quotient of `AList β` by permutation of the underlying list. -/\nstructure Finmap (β : α → Type v) : Type max u v where\n  /-- The underlying `Multiset` of a `Finmap` -/\n  entries : Multiset (Sigma β)\n  /-- There are no duplicate keys in `entries` -/\n  nodupKeys : entries.NodupKeys\n\n"}
{"name":"Finmap.nodupKeys","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\nself : Finmap β\n⊢ self.entries.NodupKeys","decl":"/-- `Finmap β` is the type of finite maps over a multiset. It is effectively\n  a quotient of `AList β` by permutation of the underlying list. -/\nstructure Finmap (β : α → Type v) : Type max u v where\n  /-- The underlying `Multiset` of a `Finmap` -/\n  entries : Multiset (Sigma β)\n  /-- There are no duplicate keys in `entries` -/\n  nodupKeys : entries.NodupKeys\n\n"}
{"name":"AList.toFinmap_eq","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ns₁ s₂ : AList β\n⊢ Iff (Eq s₁.toFinmap s₂.toFinmap) (s₁.entries.Perm s₂.entries)","decl":"theorem AList.toFinmap_eq {s₁ s₂ : AList β} :\n    toFinmap s₁ = toFinmap s₂ ↔ s₁.entries ~ s₂.entries := by\n  cases s₁\n  cases s₂\n  simp [AList.toFinmap]\n\n"}
{"name":"AList.toFinmap_entries","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ns : AList β\n⊢ Eq s.toFinmap.entries ↑s.entries","decl":"@[simp]\ntheorem AList.toFinmap_entries (s : AList β) : ⟦s⟧.entries = s.entries :=\n  rfl\n\n"}
{"name":"Finmap.nodup_entries","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\nf : Finmap β\n⊢ f.entries.Nodup","decl":"lemma nodup_entries (f : Finmap β) : f.entries.Nodup := f.nodupKeys.nodup\n\n"}
{"name":"Finmap.liftOn_toFinmap","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\nγ : Type u_1\ns : AList β\nf : AList β → γ\nH : ∀ (a b : AList β), a.entries.Perm b.entries → Eq (f a) (f b)\n⊢ Eq (s.toFinmap.liftOn f H) (f s)","decl":"@[simp]\ntheorem liftOn_toFinmap {γ} (s : AList β) (f : AList β → γ) (H) : liftOn ⟦s⟧ f H = f s := by\n  cases s\n  rfl\n\n"}
{"name":"Finmap.liftOn₂_toFinmap","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\nγ : Type u_1\ns₁ s₂ : AList β\nf : AList β → AList β → γ\nH : ∀ (a₁ b₁ a₂ b₂ : AList β), a₁.entries.Perm a₂.entries → b₁.entries.Perm b₂.entries → Eq (f a₁ b₁) (f a₂ b₂)\n⊢ Eq (s₁.toFinmap.liftOn₂ s₂.toFinmap f H) (f s₁ s₂)","decl":"@[simp]\ntheorem liftOn₂_toFinmap {γ} (s₁ s₂ : AList β) (f : AList β → AList β → γ) (H) :\n    liftOn₂ ⟦s₁⟧ ⟦s₂⟧ f H = f s₁ s₂ := by\n      cases s₁; cases s₂; rfl\n\n"}
{"name":"Finmap.induction_on","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\nC : Finmap β → Prop\ns : Finmap β\nH : ∀ (a : AList β), C a.toFinmap\n⊢ C s","decl":"@[elab_as_elim]\ntheorem induction_on {C : Finmap β → Prop} (s : Finmap β) (H : ∀ a : AList β, C ⟦a⟧) : C s := by\n  rcases s with ⟨⟨a⟩, h⟩; exact H ⟨a, h⟩\n\n"}
{"name":"Finmap.induction_on₂","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\nC : Finmap β → Finmap β → Prop\ns₁ s₂ : Finmap β\nH : ∀ (a₁ a₂ : AList β), C a₁.toFinmap a₂.toFinmap\n⊢ C s₁ s₂","decl":"@[elab_as_elim]\ntheorem induction_on₂ {C : Finmap β → Finmap β → Prop} (s₁ s₂ : Finmap β)\n    (H : ∀ a₁ a₂ : AList β, C ⟦a₁⟧ ⟦a₂⟧) : C s₁ s₂ :=\n  induction_on s₁ fun l₁ => induction_on s₂ fun l₂ => H l₁ l₂\n\n"}
{"name":"Finmap.induction_on₃","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\nC : Finmap β → Finmap β → Finmap β → Prop\ns₁ s₂ s₃ : Finmap β\nH : ∀ (a₁ a₂ a₃ : AList β), C a₁.toFinmap a₂.toFinmap a₃.toFinmap\n⊢ C s₁ s₂ s₃","decl":"@[elab_as_elim]\ntheorem induction_on₃ {C : Finmap β → Finmap β → Finmap β → Prop} (s₁ s₂ s₃ : Finmap β)\n    (H : ∀ a₁ a₂ a₃ : AList β, C ⟦a₁⟧ ⟦a₂⟧ ⟦a₃⟧) : C s₁ s₂ s₃ :=\n  induction_on₂ s₁ s₂ fun l₁ l₂ => induction_on s₃ fun l₃ => H l₁ l₂ l₃\n\n"}
{"name":"Finmap.ext","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ns t : Finmap β\na✝ : Eq s.entries t.entries\n⊢ Eq s t","decl":"@[ext]\ntheorem ext : ∀ {s t : Finmap β}, s.entries = t.entries → s = t\n  | ⟨l₁, h₁⟩, ⟨l₂, _⟩, H => by congr\n\n"}
{"name":"Finmap.ext_iff","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ns t : Finmap β\n⊢ Iff (Eq s t) (Eq s.entries t.entries)","decl":"@[ext]\ntheorem ext : ∀ {s t : Finmap β}, s.entries = t.entries → s = t\n  | ⟨l₁, h₁⟩, ⟨l₂, _⟩, H => by congr\n\n"}
{"name":"Finmap.ext_iff'","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ns t : Finmap β\n⊢ Iff (Eq s.entries t.entries) (Eq s t)","decl":"@[simp]\ntheorem ext_iff' {s t : Finmap β} : s.entries = t.entries ↔ s = t :=\n  Finmap.ext_iff.symm\n\n"}
{"name":"Finmap.mem_def","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\na : α\ns : Finmap β\n⊢ Iff (Membership.mem s a) (Membership.mem s.entries.keys a)","decl":"theorem mem_def {a : α} {s : Finmap β} : a ∈ s ↔ a ∈ s.entries.keys :=\n  Iff.rfl\n\n"}
{"name":"Finmap.mem_toFinmap","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\na : α\ns : AList β\n⊢ Iff (Membership.mem s.toFinmap a) (Membership.mem s a)","decl":"@[simp]\ntheorem mem_toFinmap {a : α} {s : AList β} : a ∈ toFinmap s ↔ a ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Finmap.keys_val","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ns : AList β\n⊢ Eq s.toFinmap.keys.val ↑s.keys","decl":"@[simp]\ntheorem keys_val (s : AList β) : (keys ⟦s⟧).val = s.keys :=\n  rfl\n\n"}
{"name":"Finmap.keys_ext","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ns₁ s₂ : AList β\n⊢ Iff (Eq s₁.toFinmap.keys s₂.toFinmap.keys) (s₁.keys.Perm s₂.keys)","decl":"@[simp]\ntheorem keys_ext {s₁ s₂ : AList β} : keys ⟦s₁⟧ = keys ⟦s₂⟧ ↔ s₁.keys ~ s₂.keys := by\n  simp [keys, AList.keys]\n\n"}
{"name":"Finmap.mem_keys","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\na : α\ns : Finmap β\n⊢ Iff (Membership.mem s.keys a) (Membership.mem s a)","decl":"theorem mem_keys {a : α} {s : Finmap β} : a ∈ s.keys ↔ a ∈ s :=\n  induction_on s fun _ => AList.mem_keys\n\n"}
{"name":"Finmap.empty_toFinmap","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\n⊢ Eq EmptyCollection.emptyCollection.toFinmap EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem empty_toFinmap : (⟦∅⟧ : Finmap β) = ∅ :=\n  rfl\n\n"}
{"name":"Finmap.toFinmap_nil","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\n⊢ Eq List.nil.toFinmap EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem toFinmap_nil [DecidableEq α] : ([].toFinmap : Finmap β) = ∅ :=\n  rfl\n\n"}
{"name":"Finmap.not_mem_empty","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\na : α\n⊢ Not (Membership.mem EmptyCollection.emptyCollection a)","decl":"theorem not_mem_empty {a : α} : a ∉ (∅ : Finmap β) :=\n  Multiset.not_mem_zero a\n\n"}
{"name":"Finmap.keys_empty","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\n⊢ Eq EmptyCollection.emptyCollection.keys EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem keys_empty : (∅ : Finmap β).keys = ∅ :=\n  rfl\n\n"}
{"name":"Finmap.keys_singleton","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\na : α\nb : β a\n⊢ Eq (Finmap.singleton a b).keys (Singleton.singleton a)","decl":"@[simp]\ntheorem keys_singleton (a : α) (b : β a) : (singleton a b).keys = {a} :=\n  rfl\n\n"}
{"name":"Finmap.mem_singleton","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\nx y : α\nb : β y\n⊢ Iff (Membership.mem (Finmap.singleton y b) x) (Eq x y)","decl":"@[simp]\ntheorem mem_singleton (x y : α) (b : β y) : x ∈ singleton y b ↔ x = y := by\n  simp only [singleton]; erw [mem_cons, mem_nil_iff, or_false]\n\n"}
{"name":"Finmap.lookup_toFinmap","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\ns : AList β\n⊢ Eq (Finmap.lookup a s.toFinmap) (AList.lookup a s)","decl":"@[simp]\ntheorem lookup_toFinmap (a : α) (s : AList β) : lookup a ⟦s⟧ = s.lookup a :=\n  rfl\n\n-- Porting note: renaming to `List.dlookup` since `List.lookup` already exists\n"}
{"name":"Finmap.dlookup_list_toFinmap","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\ns : List (Sigma β)\n⊢ Eq (Finmap.lookup a s.toFinmap) (List.dlookup a s)","decl":"@[simp]\ntheorem dlookup_list_toFinmap (a : α) (s : List (Sigma β)) : lookup a s.toFinmap = s.dlookup a := by\n  rw [List.toFinmap, lookup_toFinmap, lookup_to_alist]\n\n"}
{"name":"Finmap.lookup_empty","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\n⊢ Eq (Finmap.lookup a EmptyCollection.emptyCollection) Option.none","decl":"@[simp]\ntheorem lookup_empty (a) : lookup a (∅ : Finmap β) = none :=\n  rfl\n\n"}
{"name":"Finmap.lookup_isSome","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\ns : Finmap β\n⊢ Iff (Eq (Finmap.lookup a s).isSome Bool.true) (Membership.mem s a)","decl":"theorem lookup_isSome {a : α} {s : Finmap β} : (s.lookup a).isSome ↔ a ∈ s :=\n  induction_on s fun _ => AList.lookup_isSome\n\n"}
{"name":"Finmap.lookup_eq_none","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\ns : Finmap β\n⊢ Iff (Eq (Finmap.lookup a s) Option.none) (Not (Membership.mem s a))","decl":"theorem lookup_eq_none {a} {s : Finmap β} : lookup a s = none ↔ a ∉ s :=\n  induction_on s fun _ => AList.lookup_eq_none\n\n"}
{"name":"Finmap.mem_lookup_iff","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\ns : Finmap β\na : α\nb : β a\n⊢ Iff (Membership.mem (Finmap.lookup a s) b) (Membership.mem s.entries ⟨a, b⟩)","decl":"lemma mem_lookup_iff {s : Finmap β} {a : α} {b : β a} :\n    b ∈ s.lookup a ↔ Sigma.mk a b ∈ s.entries := by\n  rcases s with ⟨⟨l⟩, hl⟩; exact List.mem_dlookup_iff hl\n\n"}
{"name":"Finmap.lookup_eq_some_iff","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\ns : Finmap β\na : α\nb : β a\n⊢ Iff (Eq (Finmap.lookup a s) (Option.some b)) (Membership.mem s.entries ⟨a, b⟩)","decl":"lemma lookup_eq_some_iff {s : Finmap β} {a : α} {b : β a} :\n    s.lookup a = b ↔ Sigma.mk a b ∈ s.entries := mem_lookup_iff\n\n"}
{"name":"Finmap.sigma_keys_lookup","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\ns : Finmap β\n⊢ Eq (s.keys.sigma fun i => (Finmap.lookup i s).toFinset) { val := s.entries, nodup := ⋯ }","decl":"@[simp] lemma sigma_keys_lookup (s : Finmap β) :\n    s.keys.sigma (fun i => (s.lookup i).toFinset) = ⟨s.entries, s.nodup_entries⟩ := by\n  ext x\n  have : x ∈ s.entries → x.1 ∈ s.keys := Multiset.mem_map_of_mem _\n  simpa [lookup_eq_some_iff]\n\n"}
{"name":"Finmap.lookup_singleton_eq","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\n⊢ Eq (Finmap.lookup a (Finmap.singleton a b)) (Option.some b)","decl":"@[simp]\ntheorem lookup_singleton_eq {a : α} {b : β a} : (singleton a b).lookup a = some b := by\n  rw [singleton, lookup_toFinmap, AList.singleton, AList.lookup, dlookup_cons_eq]\n\n"}
{"name":"Finmap.mem_iff","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\ns : Finmap β\n⊢ Iff (Membership.mem s a) (Exists fun b => Eq (Finmap.lookup a s) (Option.some b))","decl":"theorem mem_iff {a : α} {s : Finmap β} : a ∈ s ↔ ∃ b, s.lookup a = some b :=\n  induction_on s fun s =>\n    Iff.trans List.mem_keys <| exists_congr fun _ => (mem_dlookup_iff s.nodupKeys).symm\n\n"}
{"name":"Finmap.mem_of_lookup_eq_some","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\ns : Finmap β\nh : Eq (Finmap.lookup a s) (Option.some b)\n⊢ Membership.mem s a","decl":"theorem mem_of_lookup_eq_some {a : α} {b : β a} {s : Finmap β} (h : s.lookup a = some b) : a ∈ s :=\n  mem_iff.mpr ⟨_, h⟩\n\n"}
{"name":"Finmap.ext_lookup","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\ns₁ s₂ : Finmap β\na✝ : ∀ (x : α), Eq (Finmap.lookup x s₁) (Finmap.lookup x s₂)\n⊢ Eq s₁ s₂","decl":"theorem ext_lookup {s₁ s₂ : Finmap β} : (∀ x, s₁.lookup x = s₂.lookup x) → s₁ = s₂ :=\n  induction_on₂ s₁ s₂ fun s₁ s₂ h => by\n    simp only [AList.lookup, lookup_toFinmap] at h\n    rw [AList.toFinmap_eq]\n    apply lookup_ext s₁.nodupKeys s₂.nodupKeys\n    intro x y\n    rw [h]\n\n"}
{"name":"Finmap.keysLookupEquiv_apply_coe_fst","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\ns : Finmap β\n⊢ Eq (↑(Finmap.keysLookupEquiv s)).1 s.keys","decl":"/-- An equivalence between `Finmap β` and pairs `(keys : Finset α, lookup : ∀ a, Option (β a))` such\nthat `(lookup a).isSome ↔ a ∈ keys`. -/\n@[simps apply_coe_fst apply_coe_snd]\ndef keysLookupEquiv :\n    Finmap β ≃ { f : Finset α × (∀ a, Option (β a)) // ∀ i, (f.2 i).isSome ↔ i ∈ f.1 } where\n  toFun s := ⟨(s.keys, fun i => s.lookup i), fun _ => lookup_isSome⟩\n  invFun f := mk (f.1.1.sigma fun i => (f.1.2 i).toFinset).val <| by\n    refine Multiset.nodup_keys.1 ((Finset.nodup _).map_on ?_)\n    simp only [Finset.mem_val, Finset.mem_sigma, Option.mem_toFinset, Option.mem_def]\n    rintro ⟨i, x⟩ ⟨_, hx⟩ ⟨j, y⟩ ⟨_, hy⟩ (rfl : i = j)\n    simpa using hx.symm.trans hy\n  left_inv f := ext <| by simp\n  right_inv := fun ⟨(s, f), hf⟩ => by\n    dsimp only at hf\n    ext\n    · simp [keys, Multiset.keys, ← hf, Option.isSome_iff_exists]\n    · simp +contextual [lookup_eq_some_iff, ← hf]\n\n"}
{"name":"Finmap.keysLookupEquiv_apply_coe_snd","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\ns : Finmap β\ni : α\n⊢ Eq ((↑(Finmap.keysLookupEquiv s)).2 i) (Finmap.lookup i s)","decl":"/-- An equivalence between `Finmap β` and pairs `(keys : Finset α, lookup : ∀ a, Option (β a))` such\nthat `(lookup a).isSome ↔ a ∈ keys`. -/\n@[simps apply_coe_fst apply_coe_snd]\ndef keysLookupEquiv :\n    Finmap β ≃ { f : Finset α × (∀ a, Option (β a)) // ∀ i, (f.2 i).isSome ↔ i ∈ f.1 } where\n  toFun s := ⟨(s.keys, fun i => s.lookup i), fun _ => lookup_isSome⟩\n  invFun f := mk (f.1.1.sigma fun i => (f.1.2 i).toFinset).val <| by\n    refine Multiset.nodup_keys.1 ((Finset.nodup _).map_on ?_)\n    simp only [Finset.mem_val, Finset.mem_sigma, Option.mem_toFinset, Option.mem_def]\n    rintro ⟨i, x⟩ ⟨_, hx⟩ ⟨j, y⟩ ⟨_, hy⟩ (rfl : i = j)\n    simpa using hx.symm.trans hy\n  left_inv f := ext <| by simp\n  right_inv := fun ⟨(s, f), hf⟩ => by\n    dsimp only at hf\n    ext\n    · simp [keys, Multiset.keys, ← hf, Option.isSome_iff_exists]\n    · simp +contextual [lookup_eq_some_iff, ← hf]\n\n"}
{"name":"Finmap.keysLookupEquiv_symm_apply_keys","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\nf : Subtype fun f => ∀ (i : α), Iff (Eq (f.2 i).isSome Bool.true) (Membership.mem f.1 i)\n⊢ Eq (Finmap.keysLookupEquiv.symm f).keys (↑f).1","decl":"@[simp] lemma keysLookupEquiv_symm_apply_keys :\n    ∀ f : {f : Finset α × (∀ a, Option (β a)) // ∀ i, (f.2 i).isSome ↔ i ∈ f.1},\n      (keysLookupEquiv.symm f).keys = f.1.1 :=\n  keysLookupEquiv.surjective.forall.2 fun _ => by\n    simp only [Equiv.symm_apply_apply, keysLookupEquiv_apply_coe_fst]\n\n"}
{"name":"Finmap.keysLookupEquiv_symm_apply_lookup","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\nf : Subtype fun f => ∀ (i : α), Iff (Eq (f.2 i).isSome Bool.true) (Membership.mem f.1 i)\na : α\n⊢ Eq (Finmap.lookup a (Finmap.keysLookupEquiv.symm f)) ((↑f).2 a)","decl":"@[simp] lemma keysLookupEquiv_symm_apply_lookup :\n    ∀ (f : {f : Finset α × (∀ a, Option (β a)) // ∀ i, (f.2 i).isSome ↔ i ∈ f.1}) a,\n      (keysLookupEquiv.symm f).lookup a = f.1.2 a :=\n  keysLookupEquiv.surjective.forall.2 fun _ _ => by\n    simp only [Equiv.symm_apply_apply, keysLookupEquiv_apply_coe_snd]\n\n"}
{"name":"Finmap.replace_toFinmap","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\ns : AList β\n⊢ Eq (Finmap.replace a b s.toFinmap) (AList.replace a b s).toFinmap","decl":"@[simp]\ntheorem replace_toFinmap (a : α) (b : β a) (s : AList β) :\n    replace a b ⟦s⟧ = (⟦s.replace a b⟧ : Finmap β) := by\n  simp [replace]\n\n"}
{"name":"Finmap.keys_replace","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\ns : Finmap β\n⊢ Eq (Finmap.replace a b s).keys s.keys","decl":"@[simp]\ntheorem keys_replace (a : α) (b : β a) (s : Finmap β) : (replace a b s).keys = s.keys :=\n  induction_on s fun s => by simp\n\n"}
{"name":"Finmap.mem_replace","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na a' : α\nb : β a\ns : Finmap β\n⊢ Iff (Membership.mem (Finmap.replace a b s) a') (Membership.mem s a')","decl":"@[simp]\ntheorem mem_replace {a a' : α} {b : β a} {s : Finmap β} : a' ∈ replace a b s ↔ a' ∈ s :=\n  induction_on s fun s => by simp\n\n"}
{"name":"Finmap.erase_toFinmap","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\ns : AList β\n⊢ Eq (Finmap.erase a s.toFinmap) (AList.erase a s).toFinmap","decl":"@[simp]\ntheorem erase_toFinmap (a : α) (s : AList β) : erase a ⟦s⟧ = AList.toFinmap (s.erase a) := by\n  simp [erase]\n\n"}
{"name":"Finmap.keys_erase_toFinset","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\ns : AList β\n⊢ Eq (AList.erase a s).toFinmap.keys (s.toFinmap.keys.erase a)","decl":"@[simp]\ntheorem keys_erase_toFinset (a : α) (s : AList β) : keys ⟦s.erase a⟧ = (keys ⟦s⟧).erase a := by\n  simp [Finset.erase, keys, AList.erase, keys_kerase]\n\n"}
{"name":"Finmap.keys_erase","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\ns : Finmap β\n⊢ Eq (Finmap.erase a s).keys (s.keys.erase a)","decl":"@[simp]\ntheorem keys_erase (a : α) (s : Finmap β) : (erase a s).keys = s.keys.erase a :=\n  induction_on s fun s => by simp\n\n"}
{"name":"Finmap.mem_erase","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na a' : α\ns : Finmap β\n⊢ Iff (Membership.mem (Finmap.erase a s) a') (And (Ne a' a) (Membership.mem s a'))","decl":"@[simp]\ntheorem mem_erase {a a' : α} {s : Finmap β} : a' ∈ erase a s ↔ a' ≠ a ∧ a' ∈ s :=\n  induction_on s fun s => by simp\n\n"}
{"name":"Finmap.not_mem_erase_self","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\ns : Finmap β\n⊢ Not (Membership.mem (Finmap.erase a s) a)","decl":"theorem not_mem_erase_self {a : α} {s : Finmap β} : ¬a ∈ erase a s := by\n  rw [mem_erase, not_and_or, not_not]\n  left\n  rfl\n\n"}
{"name":"Finmap.lookup_erase","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\ns : Finmap β\n⊢ Eq (Finmap.lookup a (Finmap.erase a s)) Option.none","decl":"@[simp]\ntheorem lookup_erase (a) (s : Finmap β) : lookup a (erase a s) = none :=\n  induction_on s <| AList.lookup_erase a\n\n"}
{"name":"Finmap.lookup_erase_ne","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na a' : α\ns : Finmap β\nh : Ne a a'\n⊢ Eq (Finmap.lookup a (Finmap.erase a' s)) (Finmap.lookup a s)","decl":"@[simp]\ntheorem lookup_erase_ne {a a'} {s : Finmap β} (h : a ≠ a') : lookup a (erase a' s) = lookup a s :=\n  induction_on s fun _ => AList.lookup_erase_ne h\n\n"}
{"name":"Finmap.erase_erase","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na a' : α\ns : Finmap β\n⊢ Eq (Finmap.erase a (Finmap.erase a' s)) (Finmap.erase a' (Finmap.erase a s))","decl":"theorem erase_erase {a a' : α} {s : Finmap β} : erase a (erase a' s) = erase a' (erase a s) :=\n  induction_on s fun s => ext (by simp only [AList.erase_erase, erase_toFinmap])\n\n"}
{"name":"Finmap.insert_toFinmap","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\ns : AList β\n⊢ Eq (Finmap.insert a b s.toFinmap) (AList.insert a b s).toFinmap","decl":"@[simp]\ntheorem insert_toFinmap (a : α) (b : β a) (s : AList β) :\n    insert a b (AList.toFinmap s) = AList.toFinmap (s.insert a b) := by\n  simp [insert]\n\n"}
{"name":"Finmap.entries_insert_of_not_mem","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\ns : Finmap β\na✝ : Not (Membership.mem s a)\n⊢ Eq (Finmap.insert a b s).entries (Multiset.cons ⟨a, b⟩ s.entries)","decl":"theorem entries_insert_of_not_mem {a : α} {b : β a} {s : Finmap β} :\n    a ∉ s → (insert a b s).entries = ⟨a, b⟩ ::ₘ s.entries :=\n  induction_on s fun s h => by\n    -- Porting note: `-entries_insert` required\n    simp [AList.entries_insert_of_not_mem (mt mem_toFinmap.1 h), -entries_insert]\n\n"}
{"name":"Finmap.insert_entries_of_neg","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\ns : Finmap β\na✝ : Not (Membership.mem s a)\n⊢ Eq (Finmap.insert a b s).entries (Multiset.cons ⟨a, b⟩ s.entries)","decl":"@[deprecated (since := \"2024-12-14\")] alias insert_entries_of_neg := entries_insert_of_not_mem\n\n"}
{"name":"Finmap.mem_insert","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na a' : α\nb' : β a'\ns : Finmap β\n⊢ Iff (Membership.mem (Finmap.insert a' b' s) a) (Or (Eq a a') (Membership.mem s a))","decl":"@[simp]\ntheorem mem_insert {a a' : α} {b' : β a'} {s : Finmap β} : a ∈ insert a' b' s ↔ a = a' ∨ a ∈ s :=\n  induction_on s AList.mem_insert\n\n"}
{"name":"Finmap.lookup_insert","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\ns : Finmap β\n⊢ Eq (Finmap.lookup a (Finmap.insert a b s)) (Option.some b)","decl":"@[simp]\ntheorem lookup_insert {a} {b : β a} (s : Finmap β) : lookup a (insert a b s) = some b :=\n  induction_on s fun s => by simp only [insert_toFinmap, lookup_toFinmap, AList.lookup_insert]\n\n"}
{"name":"Finmap.lookup_insert_of_ne","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na a' : α\nb : β a\ns : Finmap β\nh : Ne a' a\n⊢ Eq (Finmap.lookup a' (Finmap.insert a b s)) (Finmap.lookup a' s)","decl":"@[simp]\ntheorem lookup_insert_of_ne {a a'} {b : β a} (s : Finmap β) (h : a' ≠ a) :\n    lookup a' (insert a b s) = lookup a' s :=\n  induction_on s fun s => by simp only [insert_toFinmap, lookup_toFinmap, lookup_insert_ne h]\n\n"}
{"name":"Finmap.insert_insert","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb b' : β a\ns : Finmap β\n⊢ Eq (Finmap.insert a b' (Finmap.insert a b s)) (Finmap.insert a b' s)","decl":"@[simp]\ntheorem insert_insert {a} {b b' : β a} (s : Finmap β) :\n    (s.insert a b).insert a b' = s.insert a b' :=\n  induction_on s fun s => by simp only [insert_toFinmap, AList.insert_insert]\n\n"}
{"name":"Finmap.insert_insert_of_ne","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na a' : α\nb : β a\nb' : β a'\ns : Finmap β\nh : Ne a a'\n⊢ Eq (Finmap.insert a' b' (Finmap.insert a b s)) (Finmap.insert a b (Finmap.insert a' b' s))","decl":"theorem insert_insert_of_ne {a a'} {b : β a} {b' : β a'} (s : Finmap β) (h : a ≠ a') :\n    (s.insert a b).insert a' b' = (s.insert a' b').insert a b :=\n  induction_on s fun s => by\n    simp only [insert_toFinmap, AList.toFinmap_eq, AList.insert_insert_of_ne _ h]\n\n"}
{"name":"Finmap.toFinmap_cons","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\nxs : List (Sigma β)\n⊢ Eq (List.cons ⟨a, b⟩ xs).toFinmap (Finmap.insert a b xs.toFinmap)","decl":"theorem toFinmap_cons (a : α) (b : β a) (xs : List (Sigma β)) :\n    List.toFinmap (⟨a, b⟩ :: xs) = insert a b xs.toFinmap :=\n  rfl\n\n"}
{"name":"Finmap.mem_list_toFinmap","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nxs : List (Sigma β)\n⊢ Iff (Membership.mem xs.toFinmap a) (Exists fun b => Membership.mem xs ⟨a, b⟩)","decl":"theorem mem_list_toFinmap (a : α) (xs : List (Sigma β)) :\n    a ∈ xs.toFinmap ↔ ∃ b : β a, Sigma.mk a b ∈ xs := by\n  -- Porting note: golfed\n  induction' xs with x xs\n  · simp only [toFinmap_nil, not_mem_empty, find?, not_mem_nil, exists_false]\n  cases' x with fst_i snd_i\n  -- Porting note: `Sigma.mk.inj_iff` required because `simp` behaves differently\n  simp only [toFinmap_cons, *, exists_or, mem_cons, mem_insert, exists_and_left, Sigma.mk.inj_iff]\n  refine (or_congr_left <| and_iff_left_of_imp ?_).symm\n  rintro rfl\n  simp only [exists_eq, heq_iff_eq]\n\n"}
{"name":"Finmap.insert_singleton_eq","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb b' : β a\n⊢ Eq (Finmap.insert a b (Finmap.singleton a b')) (Finmap.singleton a b)","decl":"@[simp]\ntheorem insert_singleton_eq {a : α} {b b' : β a} : insert a b (singleton a b') = singleton a b := by\n  simp only [singleton, Finmap.insert_toFinmap, AList.insert_singleton_eq]\n\n"}
{"name":"Finmap.extract_eq_lookup_erase","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\ns : Finmap β\n⊢ Eq (Finmap.extract a s) { fst := Finmap.lookup a s, snd := Finmap.erase a s }","decl":"@[simp]\ntheorem extract_eq_lookup_erase (a : α) (s : Finmap β) : extract a s = (lookup a s, erase a s) :=\n  induction_on s fun s => by simp [extract]\n\n"}
{"name":"Finmap.mem_union","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\ns₁ s₂ : Finmap β\n⊢ Iff (Membership.mem (Union.union s₁ s₂) a) (Or (Membership.mem s₁ a) (Membership.mem s₂ a))","decl":"@[simp]\ntheorem mem_union {a} {s₁ s₂ : Finmap β} : a ∈ s₁ ∪ s₂ ↔ a ∈ s₁ ∨ a ∈ s₂ :=\n  induction_on₂ s₁ s₂ fun _ _ => AList.mem_union\n\n"}
{"name":"Finmap.union_toFinmap","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\ns₁ s₂ : AList β\n⊢ Eq (Union.union s₁.toFinmap s₂.toFinmap) (Union.union s₁ s₂).toFinmap","decl":"@[simp]\ntheorem union_toFinmap (s₁ s₂ : AList β) : (toFinmap s₁) ∪ (toFinmap s₂) = toFinmap (s₁ ∪ s₂) := by\n  simp [(· ∪ ·), union]\n\n"}
{"name":"Finmap.keys_union","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\ns₁ s₂ : Finmap β\n⊢ Eq (Union.union s₁ s₂).keys (Union.union s₁.keys s₂.keys)","decl":"theorem keys_union {s₁ s₂ : Finmap β} : (s₁ ∪ s₂).keys = s₁.keys ∪ s₂.keys :=\n  induction_on₂ s₁ s₂ fun s₁ s₂ => Finset.ext <| by simp [keys]\n\n"}
{"name":"Finmap.lookup_union_left","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\ns₁ s₂ : Finmap β\na✝ : Membership.mem s₁ a\n⊢ Eq (Finmap.lookup a (Union.union s₁ s₂)) (Finmap.lookup a s₁)","decl":"@[simp]\ntheorem lookup_union_left {a} {s₁ s₂ : Finmap β} : a ∈ s₁ → lookup a (s₁ ∪ s₂) = lookup a s₁ :=\n  induction_on₂ s₁ s₂ fun _ _ => AList.lookup_union_left\n\n"}
{"name":"Finmap.lookup_union_right","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\ns₁ s₂ : Finmap β\na✝ : Not (Membership.mem s₁ a)\n⊢ Eq (Finmap.lookup a (Union.union s₁ s₂)) (Finmap.lookup a s₂)","decl":"@[simp]\ntheorem lookup_union_right {a} {s₁ s₂ : Finmap β} : a ∉ s₁ → lookup a (s₁ ∪ s₂) = lookup a s₂ :=\n  induction_on₂ s₁ s₂ fun _ _ => AList.lookup_union_right\n\n"}
{"name":"Finmap.lookup_union_left_of_not_in","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\ns₁ s₂ : Finmap β\nh : Not (Membership.mem s₂ a)\n⊢ Eq (Finmap.lookup a (Union.union s₁ s₂)) (Finmap.lookup a s₁)","decl":"theorem lookup_union_left_of_not_in {a} {s₁ s₂ : Finmap β} (h : a ∉ s₂) :\n    lookup a (s₁ ∪ s₂) = lookup a s₁ := by\n  by_cases h' : a ∈ s₁\n  · rw [lookup_union_left h']\n  · rw [lookup_union_right h', lookup_eq_none.mpr h, lookup_eq_none.mpr h']\n\n"}
{"name":"Finmap.mem_lookup_union'","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\ns₁ s₂ : Finmap β\n⊢ Iff (Eq (Finmap.lookup a (Union.union s₁ s₂)) (Option.some b)) (Or (Membership.mem (Finmap.lookup a s₁) b) (And (Not (Membership.mem s₁ a)) (Membership.mem (Finmap.lookup a s₂) b)))","decl":"/-- `simp`-normal form of `mem_lookup_union` -/\n@[simp]\ntheorem mem_lookup_union' {a} {b : β a} {s₁ s₂ : Finmap β} :\n    lookup a (s₁ ∪ s₂) = some b ↔ b ∈ lookup a s₁ ∨ a ∉ s₁ ∧ b ∈ lookup a s₂ :=\n  induction_on₂ s₁ s₂ fun _ _ => AList.mem_lookup_union\n\n"}
{"name":"Finmap.mem_lookup_union","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\ns₁ s₂ : Finmap β\n⊢ Iff (Membership.mem (Finmap.lookup a (Union.union s₁ s₂)) b) (Or (Membership.mem (Finmap.lookup a s₁) b) (And (Not (Membership.mem s₁ a)) (Membership.mem (Finmap.lookup a s₂) b)))","decl":"theorem mem_lookup_union {a} {b : β a} {s₁ s₂ : Finmap β} :\n    b ∈ lookup a (s₁ ∪ s₂) ↔ b ∈ lookup a s₁ ∨ a ∉ s₁ ∧ b ∈ lookup a s₂ :=\n  induction_on₂ s₁ s₂ fun _ _ => AList.mem_lookup_union\n\n"}
{"name":"Finmap.mem_lookup_union_middle","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\ns₁ s₂ s₃ : Finmap β\na✝¹ : Membership.mem (Finmap.lookup a (Union.union s₁ s₃)) b\na✝ : Not (Membership.mem s₂ a)\n⊢ Membership.mem (Finmap.lookup a (Union.union (Union.union s₁ s₂) s₃)) b","decl":"theorem mem_lookup_union_middle {a} {b : β a} {s₁ s₂ s₃ : Finmap β} :\n    b ∈ lookup a (s₁ ∪ s₃) → a ∉ s₂ → b ∈ lookup a (s₁ ∪ s₂ ∪ s₃) :=\n  induction_on₃ s₁ s₂ s₃ fun _ _ _ => AList.mem_lookup_union_middle\n\n"}
{"name":"Finmap.insert_union","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\ns₁ s₂ : Finmap β\n⊢ Eq (Finmap.insert a b (Union.union s₁ s₂)) (Union.union (Finmap.insert a b s₁) s₂)","decl":"theorem insert_union {a} {b : β a} {s₁ s₂ : Finmap β} : insert a b (s₁ ∪ s₂) = insert a b s₁ ∪ s₂ :=\n  induction_on₂ s₁ s₂ fun a₁ a₂ => by simp [AList.insert_union]\n\n"}
{"name":"Finmap.union_assoc","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\ns₁ s₂ s₃ : Finmap β\n⊢ Eq (Union.union (Union.union s₁ s₂) s₃) (Union.union s₁ (Union.union s₂ s₃))","decl":"theorem union_assoc {s₁ s₂ s₃ : Finmap β} : s₁ ∪ s₂ ∪ s₃ = s₁ ∪ (s₂ ∪ s₃) :=\n  induction_on₃ s₁ s₂ s₃ fun s₁ s₂ s₃ => by\n    simp only [AList.toFinmap_eq, union_toFinmap, AList.union_assoc]\n\n"}
{"name":"Finmap.empty_union","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\ns₁ : Finmap β\n⊢ Eq (Union.union EmptyCollection.emptyCollection s₁) s₁","decl":"@[simp]\ntheorem empty_union {s₁ : Finmap β} : ∅ ∪ s₁ = s₁ :=\n  induction_on s₁ fun s₁ => by\n    rw [← empty_toFinmap]\n    simp [-empty_toFinmap, AList.toFinmap_eq, union_toFinmap, AList.union_assoc]\n\n"}
{"name":"Finmap.union_empty","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\ns₁ : Finmap β\n⊢ Eq (Union.union s₁ EmptyCollection.emptyCollection) s₁","decl":"@[simp]\ntheorem union_empty {s₁ : Finmap β} : s₁ ∪ ∅ = s₁ :=\n  induction_on s₁ fun s₁ => by\n    rw [← empty_toFinmap]\n    simp [-empty_toFinmap, AList.toFinmap_eq, union_toFinmap, AList.union_assoc]\n\n"}
{"name":"Finmap.erase_union_singleton","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\ns : Finmap β\nh : Eq (Finmap.lookup a s) (Option.some b)\n⊢ Eq (Union.union (Finmap.erase a s) (Finmap.singleton a b)) s","decl":"theorem erase_union_singleton (a : α) (b : β a) (s : Finmap β) (h : s.lookup a = some b) :\n    s.erase a ∪ singleton a b = s :=\n  ext_lookup fun x => by\n    by_cases h' : x = a\n    · subst a\n      rw [lookup_union_right not_mem_erase_self, lookup_singleton_eq, h]\n    · have : x ∉ singleton a b := by rwa [mem_singleton]\n      rw [lookup_union_left_of_not_in this, lookup_erase_ne h']\n\n"}
{"name":"Finmap.disjoint_empty","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\nx : Finmap β\n⊢ EmptyCollection.emptyCollection.Disjoint x","decl":"theorem disjoint_empty (x : Finmap β) : Disjoint ∅ x :=\n  nofun\n\n"}
{"name":"Finmap.Disjoint.symm","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\nx y : Finmap β\nh : x.Disjoint y\n⊢ y.Disjoint x","decl":"@[symm]\ntheorem Disjoint.symm (x y : Finmap β) (h : Disjoint x y) : Disjoint y x := fun p hy hx => h p hx hy\n\n"}
{"name":"Finmap.Disjoint.symm_iff","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\nx y : Finmap β\n⊢ Iff (x.Disjoint y) (y.Disjoint x)","decl":"theorem Disjoint.symm_iff (x y : Finmap β) : Disjoint x y ↔ Disjoint y x :=\n  ⟨Disjoint.symm x y, Disjoint.symm y x⟩\n\n"}
{"name":"Finmap.disjoint_union_left","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\nx y z : Finmap β\n⊢ Iff ((Union.union x y).Disjoint z) (And (x.Disjoint z) (y.Disjoint z))","decl":"theorem disjoint_union_left (x y z : Finmap β) :\n    Disjoint (x ∪ y) z ↔ Disjoint x z ∧ Disjoint y z := by\n  simp [Disjoint, Finmap.mem_union, or_imp, forall_and]\n\n"}
{"name":"Finmap.disjoint_union_right","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\nx y z : Finmap β\n⊢ Iff (x.Disjoint (Union.union y z)) (And (x.Disjoint y) (x.Disjoint z))","decl":"theorem disjoint_union_right (x y z : Finmap β) :\n    Disjoint x (y ∪ z) ↔ Disjoint x y ∧ Disjoint x z := by\n  rw [Disjoint.symm_iff, disjoint_union_left, Disjoint.symm_iff _ x, Disjoint.symm_iff _ x]\n\n"}
{"name":"Finmap.union_comm_of_disjoint","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\ns₁ s₂ : Finmap β\na✝ : s₁.Disjoint s₂\n⊢ Eq (Union.union s₁ s₂) (Union.union s₂ s₁)","decl":"theorem union_comm_of_disjoint {s₁ s₂ : Finmap β} : Disjoint s₁ s₂ → s₁ ∪ s₂ = s₂ ∪ s₁ :=\n  induction_on₂ s₁ s₂ fun s₁ s₂ => by\n    intro h\n    simp only [AList.toFinmap_eq, union_toFinmap, AList.union_comm_of_disjoint h]\n\n"}
{"name":"Finmap.union_cancel","module":"Mathlib.Data.Finmap","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\ns₁ s₂ s₃ : Finmap β\nh : s₁.Disjoint s₃\nh' : s₂.Disjoint s₃\n⊢ Iff (Eq (Union.union s₁ s₃) (Union.union s₂ s₃)) (Eq s₁ s₂)","decl":"theorem union_cancel {s₁ s₂ s₃ : Finmap β} (h : Disjoint s₁ s₃) (h' : Disjoint s₂ s₃) :\n    s₁ ∪ s₃ = s₂ ∪ s₃ ↔ s₁ = s₂ :=\n  ⟨fun h'' => by\n    apply ext_lookup\n    intro x\n    have : (s₁ ∪ s₃).lookup x = (s₂ ∪ s₃).lookup x := h'' ▸ rfl\n    by_cases hs₁ : x ∈ s₁\n    · rwa [lookup_union_left hs₁, lookup_union_left_of_not_in (h _ hs₁)] at this\n    · by_cases hs₂ : x ∈ s₂\n      · rwa [lookup_union_left_of_not_in (h' _ hs₂), lookup_union_left hs₂] at this\n      · rw [lookup_eq_none.mpr hs₁, lookup_eq_none.mpr hs₂], fun h => h ▸ rfl⟩\n\n"}
