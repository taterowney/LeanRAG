{"name":"CategoryTheory.Limits.Concrete.colimit_rep_eq_zero","module":"Mathlib.CategoryTheory.Limits.ConcreteCategory.WithAlgebraicStructures","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nJ : Type w\ninst✝³ : CategoryTheory.Category.{r, w} J\nF : CategoryTheory.Functor J (ModuleCat R)\ninst✝² : CategoryTheory.Limits.PreservesColimit F (CategoryTheory.forget (ModuleCat R))\ninst✝¹ : CategoryTheory.IsFiltered J\ninst✝ : CategoryTheory.Limits.HasColimit F\nj : J\nx : ↑(F.obj j)\nhx : Eq ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.Limits.colimit.ι F j)) x) 0\n⊢ Exists fun j' => Exists fun i => Eq ((ModuleCat.Hom.hom (F.map i)) x) 0","decl":"theorem colimit_rep_eq_zero\n    (F : J ⥤ ModuleCat.{max t w} R) [PreservesColimit F (forget (ModuleCat R))] [IsFiltered J]\n    [HasColimit F] (j : J) (x : F.obj j) (hx : colimit.ι F j x = 0) :\n    ∃ (j' : J) (i : j ⟶ j'), (F.map i).hom x = 0 := by\n  -- Break the abstraction barrier between homs and functions for `colimit_rep_eq_iff_exists`.\n  have : ∀ (X Y : ModuleCat R) (f : X ⟶ Y),\n    DFunLike.coe f.hom = DFunLike.coe (self := HasForget.instFunLike) f := fun _ _ _ => rfl\n  rw [show 0 = colimit.ι F j 0 by simp, this, colimit_rep_eq_iff_exists] at hx\n  obtain ⟨j', i, y, g⟩ := hx\n  exact ⟨j', i, g ▸ by simp [← this]⟩\n\n"}
{"name":"CategoryTheory.Limits.Concrete.colimit_no_zero_smul_divisor","module":"Mathlib.CategoryTheory.Limits.ConcreteCategory.WithAlgebraicStructures","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nJ : Type w\ninst✝³ : CategoryTheory.Category.{r, w} J\nF : CategoryTheory.Functor J (ModuleCat R)\ninst✝² : CategoryTheory.Limits.PreservesColimit F (CategoryTheory.forget (ModuleCat R))\ninst✝¹ : CategoryTheory.IsFiltered J\ninst✝ : CategoryTheory.Limits.HasColimit F\nr : R\nH : Exists fun j' => ∀ (j : J), Quiver.Hom j' j → ∀ (c : ↑(F.obj j)), Eq (HSMul.hSMul r c) 0 → Eq c 0\nx : (CategoryTheory.forget (ModuleCat R)).obj (CategoryTheory.Limits.colimit F)\nhx : Eq (HSMul.hSMul r x) 0\n⊢ Eq x 0","decl":"/--\nif `r` has no zero smul divisors for all small-enough sections, then `r` has no zero smul divisors\nin the colimit.\n-/\nlemma colimit_no_zero_smul_divisor\n    (F : J ⥤ ModuleCat.{max t w} R) [PreservesColimit F (forget (ModuleCat R))]\n    [IsFiltered J] [HasColimit F]\n    (r : R) (H : ∃ (j' : J), ∀ (j : J) (_ : j' ⟶ j), ∀ (c : F.obj j), r • c = 0 → c = 0)\n    (x : (forget (ModuleCat R)).obj (colimit F)) (hx : r • x = 0) : x = 0 := by\n\n  -- Break the abstraction barrier between homs and functions for `Concrete.colimit_exists_rep`.\n  have : ∀ (X Y : ModuleCat R) (f : X ⟶ Y),\n    DFunLike.coe f.hom = DFunLike.coe (self := HasForget.instFunLike) f := fun _ _ _ => rfl\n  classical\n  obtain ⟨j, x, rfl⟩ := Concrete.colimit_exists_rep F x\n  rw [← this, ← map_smul (colimit.ι F j).hom] at hx\n  obtain ⟨j', i, h⟩ := Concrete.colimit_rep_eq_zero (hx := hx)\n  obtain ⟨j'', H⟩ := H\n  simpa [elementwise_of% (colimit.w F), ← this, map_zero] using congr(colimit.ι F _\n    $(H (IsFiltered.sup {j, j', j''} { ⟨j, j', by simp, by simp, i⟩ })\n      (IsFiltered.toSup _ _ <| by simp)\n      (F.map (IsFiltered.toSup _ _ <| by simp) x)\n      (by rw [← IsFiltered.toSup_commutes (f := i) (mY := by simp) (mf := by simp), F.map_comp,\n        ModuleCat.comp_apply, ← map_smul, ← map_smul, h, map_zero])))\n\n"}
