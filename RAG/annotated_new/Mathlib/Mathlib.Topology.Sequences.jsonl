{"name":"subset_seqClosure","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns : Set X\n‚ä¢ HasSubset.Subset s (seqClosure s)","decl":"theorem subset_seqClosure {s : Set X} : s ‚äÜ seqClosure s := fun p hp =>\n  ‚ü®const ‚Ñï p, fun _ => hp, tendsto_const_nhds‚ü©\n\n"}
{"name":"seqClosure_subset_closure","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns : Set X\n‚ä¢ HasSubset.Subset (seqClosure s) (closure s)","decl":"/-- The sequential closure of a set is contained in the closure of that set.\nThe converse is not true. -/\ntheorem seqClosure_subset_closure {s : Set X} : seqClosure s ‚äÜ closure s := fun _p ‚ü®_x, xM, xp‚ü© =>\n  mem_closure_of_tendsto xp (univ_mem' xM)\n\n"}
{"name":"IsSeqClosed.seqClosure_eq","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns : Set X\nhs : IsSeqClosed s\n‚ä¢ Eq (seqClosure s) s","decl":"/-- The sequential closure of a sequentially closed set is the set itself. -/\ntheorem IsSeqClosed.seqClosure_eq {s : Set X} (hs : IsSeqClosed s) : seqClosure s = s :=\n  Subset.antisymm (fun _p ‚ü®_x, hx, hp‚ü© => hs hx hp) subset_seqClosure\n\n"}
{"name":"isSeqClosed_of_seqClosure_eq","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns : Set X\nhs : Eq (seqClosure s) s\n‚ä¢ IsSeqClosed s","decl":"/-- If a set is equal to its sequential closure, then it is sequentially closed. -/\ntheorem isSeqClosed_of_seqClosure_eq {s : Set X} (hs : seqClosure s = s) : IsSeqClosed s :=\n  fun x _p hxs hxp => hs ‚ñ∏ ‚ü®x, hxs, hxp‚ü©\n\n"}
{"name":"isSeqClosed_iff","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns : Set X\n‚ä¢ Iff (IsSeqClosed s) (Eq (seqClosure s) s)","decl":"/-- A set is sequentially closed iff it is equal to its sequential closure. -/\ntheorem isSeqClosed_iff {s : Set X} : IsSeqClosed s ‚Üî seqClosure s = s :=\n  ‚ü®IsSeqClosed.seqClosure_eq, isSeqClosed_of_seqClosure_eq‚ü©\n\n"}
{"name":"IsClosed.isSeqClosed","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns : Set X\nhc : IsClosed s\n‚ä¢ IsSeqClosed s","decl":"/-- A set is sequentially closed if it is closed. -/\nprotected theorem IsClosed.isSeqClosed {s : Set X} (hc : IsClosed s) : IsSeqClosed s :=\n  fun _u _x hu hx => hc.mem_of_tendsto hx (Eventually.of_forall hu)\n\n"}
{"name":"seqClosure_eq_closure","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : FrechetUrysohnSpace X\ns : Set X\n‚ä¢ Eq (seqClosure s) (closure s)","decl":"theorem seqClosure_eq_closure [FrechetUrysohnSpace X] (s : Set X) : seqClosure s = closure s :=\n  seqClosure_subset_closure.antisymm <| FrechetUrysohnSpace.closure_subset_seqClosure s\n\n"}
{"name":"mem_closure_iff_seq_limit","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : FrechetUrysohnSpace X\ns : Set X\na : X\n‚ä¢ Iff (Membership.mem (closure s) a) (Exists fun x => And (‚àÄ (n : Nat), Membership.mem s (x n)) (Filter.Tendsto x Filter.atTop (nhds a)))","decl":"/-- In a Fr√©chet-Urysohn space, a point belongs to the closure of a set iff it is a limit\nof a sequence taking values in this set. -/\ntheorem mem_closure_iff_seq_limit [FrechetUrysohnSpace X] {s : Set X} {a : X} :\n    a ‚àà closure s ‚Üî ‚àÉ x : ‚Ñï ‚Üí X, (‚àÄ n : ‚Ñï, x n ‚àà s) ‚àß Tendsto x atTop (ùìù a) := by\n  rw [‚Üê seqClosure_eq_closure]\n  rfl\n\n"}
{"name":"tendsto_nhds_iff_seq_tendsto","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : FrechetUrysohnSpace X\nf : X ‚Üí Y\na : X\nb : Y\n‚ä¢ Iff (Filter.Tendsto f (nhds a) (nhds b)) (‚àÄ (u : Nat ‚Üí X), Filter.Tendsto u Filter.atTop (nhds a) ‚Üí Filter.Tendsto (Function.comp f u) Filter.atTop (nhds b))","decl":"/-- If the domain of a function `f : Œ± ‚Üí Œ≤` is a Fr√©chet-Urysohn space, then convergence\nis equivalent to sequential convergence. See also `Filter.tendsto_iff_seq_tendsto` for a version\nthat works for any pair of filters assuming that the filter in the domain is countably generated.\n\nThis property is equivalent to the definition of `FrechetUrysohnSpace`, see\n`FrechetUrysohnSpace.of_seq_tendsto_imp_tendsto`. -/\ntheorem tendsto_nhds_iff_seq_tendsto [FrechetUrysohnSpace X] {f : X ‚Üí Y} {a : X} {b : Y} :\n    Tendsto f (ùìù a) (ùìù b) ‚Üî ‚àÄ u : ‚Ñï ‚Üí X, Tendsto u atTop (ùìù a) ‚Üí Tendsto (f ‚àò u) atTop (ùìù b) := by\n  refine\n    ‚ü®fun hf u hu => hf.comp hu, fun h =>\n      ((nhds_basis_closeds _).tendsto_iff (nhds_basis_closeds _)).2 ?_‚ü©\n  rintro s ‚ü®hbs, hsc‚ü©\n  refine ‚ü®closure (f ‚Åª¬π' s), ‚ü®mt ?_ hbs, isClosed_closure‚ü©, fun x => mt fun hx => subset_closure hx‚ü©\n  rw [‚Üê seqClosure_eq_closure]\n  rintro ‚ü®u, hus, hu‚ü©\n  exact hsc.mem_of_tendsto (h u hu) (Eventually.of_forall hus)\n\n"}
{"name":"FrechetUrysohnSpace.of_seq_tendsto_imp_tendsto","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nh : ‚àÄ (f : X ‚Üí Prop) (a : X), (‚àÄ (u : Nat ‚Üí X), Filter.Tendsto u Filter.atTop (nhds a) ‚Üí Filter.Tendsto (Function.comp f u) Filter.atTop (nhds (f a))) ‚Üí ContinuousAt f a\n‚ä¢ FrechetUrysohnSpace X","decl":"/-- An alternative construction for `FrechetUrysohnSpace`: if sequential convergence implies\nconvergence, then the space is a Fr√©chet-Urysohn space. -/\ntheorem FrechetUrysohnSpace.of_seq_tendsto_imp_tendsto\n    (h : ‚àÄ (f : X ‚Üí Prop) (a : X),\n      (‚àÄ u : ‚Ñï ‚Üí X, Tendsto u atTop (ùìù a) ‚Üí Tendsto (f ‚àò u) atTop (ùìù (f a))) ‚Üí ContinuousAt f a) :\n    FrechetUrysohnSpace X := by\n  refine ‚ü®fun s x hcx => ?_‚ü©\n  by_cases hx : x ‚àà s\n  ¬∑ exact subset_seqClosure hx\n  ¬∑ obtain ‚ü®u, hux, hus‚ü© : ‚àÉ u : ‚Ñï ‚Üí X, Tendsto u atTop (ùìù x) ‚àß ‚àÉ·∂† x in atTop, u x ‚àà s := by\n      simpa only [ContinuousAt, hx, tendsto_nhds_true, (¬∑ ‚àò ¬∑), ‚Üê not_frequently, exists_prop,\n        ‚Üê mem_closure_iff_frequently, hcx, imp_false, not_forall, not_not, not_false_eq_true,\n        not_true_eq_false] using h (¬∑ ‚àâ s) x\n    rcases extraction_of_frequently_atTop hus with ‚ü®œÜ, œÜ_mono, hœÜ‚ü©\n    exact ‚ü®u ‚àò œÜ, hœÜ, hux.comp œÜ_mono.tendsto_atTop‚ü©\n\n-- see Note [lower instance priority]\n"}
{"name":"FirstCountableTopology.frechetUrysohnSpace","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : FirstCountableTopology X\n‚ä¢ FrechetUrysohnSpace X","decl":"/-- Every first-countable space is a Fr√©chet-Urysohn space. -/\ninstance (priority := 100) FirstCountableTopology.frechetUrysohnSpace\n    [FirstCountableTopology X] : FrechetUrysohnSpace X :=\n  FrechetUrysohnSpace.of_seq_tendsto_imp_tendsto fun _ _ => tendsto_iff_seq_tendsto.2\n\n-- see Note [lower instance priority]\n"}
{"name":"FrechetUrysohnSpace.to_sequentialSpace","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : FrechetUrysohnSpace X\n‚ä¢ SequentialSpace X","decl":"/-- Every Fr√©chet-Urysohn space is a sequential space. -/\ninstance (priority := 100) FrechetUrysohnSpace.to_sequentialSpace [FrechetUrysohnSpace X] :\n    SequentialSpace X :=\n  ‚ü®fun s hs => by rw [‚Üê closure_eq_iff_isClosed, ‚Üê seqClosure_eq_closure, hs.seqClosure_eq]‚ü©\n\n"}
{"name":"Topology.IsInducing.frechetUrysohnSpace","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : FrechetUrysohnSpace Y\nf : X ‚Üí Y\nhf : Topology.IsInducing f\n‚ä¢ FrechetUrysohnSpace X","decl":"theorem Topology.IsInducing.frechetUrysohnSpace [FrechetUrysohnSpace Y] {f : X ‚Üí Y}\n    (hf : IsInducing f) : FrechetUrysohnSpace X := by\n  refine ‚ü®fun s x hx ‚Ü¶ ?_‚ü©\n  rw [hf.closure_eq_preimage_closure_image, mem_preimage, mem_closure_iff_seq_limit] at hx\n  rcases hx with ‚ü®u, hus, hu‚ü©\n  choose v hv hvu using hus\n  refine ‚ü®v, hv, ?_‚ü©\n  simpa only [hf.tendsto_nhds_iff, Function.comp_def, hvu]\n\n"}
{"name":"Inducing.frechetUrysohnSpace","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : FrechetUrysohnSpace Y\nf : X ‚Üí Y\nhf : Topology.IsInducing f\n‚ä¢ FrechetUrysohnSpace X","decl":"@[deprecated (since := \"2024-10-28\")]\nalias Inducing.frechetUrysohnSpace := IsInducing.frechetUrysohnSpace\n\n"}
{"name":"Subtype.instFrechetUrysohnSpace","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : FrechetUrysohnSpace X\np : X ‚Üí Prop\n‚ä¢ FrechetUrysohnSpace (Subtype p)","decl":"/-- Subtype of a Fr√©chet-Urysohn space is a Fr√©chet-Urysohn space. -/\ninstance Subtype.instFrechetUrysohnSpace [FrechetUrysohnSpace X] {p : X ‚Üí Prop} :\n    FrechetUrysohnSpace (Subtype p) :=\n  IsInducing.subtypeVal.frechetUrysohnSpace\n\n"}
{"name":"isSeqClosed_iff_isClosed","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : SequentialSpace X\nM : Set X\n‚ä¢ Iff (IsSeqClosed M) (IsClosed M)","decl":"/-- In a sequential space, a set is closed iff it's sequentially closed. -/\ntheorem isSeqClosed_iff_isClosed [SequentialSpace X] {M : Set X} : IsSeqClosed M ‚Üî IsClosed M :=\n  ‚ü®IsSeqClosed.isClosed, IsClosed.isSeqClosed‚ü©\n\n"}
{"name":"IsSeqClosed.preimage","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\ns : Set Y\nhs : IsSeqClosed s\nhf : SeqContinuous f\n‚ä¢ IsSeqClosed (Set.preimage f s)","decl":"/-- The preimage of a sequentially closed set under a sequentially continuous map is sequentially\nclosed. -/\ntheorem IsSeqClosed.preimage {f : X ‚Üí Y} {s : Set Y} (hs : IsSeqClosed s) (hf : SeqContinuous f) :\n    IsSeqClosed (f ‚Åª¬π' s) := fun _x _p hx hp => hs hx (hf hp)\n\n-- A continuous function is sequentially continuous.\n"}
{"name":"Continuous.seqContinuous","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : Continuous f\n‚ä¢ SeqContinuous f","decl":"protected theorem Continuous.seqContinuous {f : X ‚Üí Y} (hf : Continuous f) : SeqContinuous f :=\n  fun _x p hx => (hf.tendsto p).comp hx\n\n"}
{"name":"SeqContinuous.continuous","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : SequentialSpace X\nf : X ‚Üí Y\nhf : SeqContinuous f\n‚ä¢ Continuous f","decl":"/-- A sequentially continuous function defined on a sequential space is continuous. -/\nprotected theorem SeqContinuous.continuous [SequentialSpace X] {f : X ‚Üí Y} (hf : SeqContinuous f) :\n    Continuous f :=\n  continuous_iff_isClosed.mpr fun _s hs => (hs.isSeqClosed.preimage hf).isClosed\n\n"}
{"name":"continuous_iff_seqContinuous","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : SequentialSpace X\nf : X ‚Üí Y\n‚ä¢ Iff (Continuous f) (SeqContinuous f)","decl":"/-- If the domain of a function is a sequential space, then continuity of this function is\nequivalent to its sequential continuity. -/\ntheorem continuous_iff_seqContinuous [SequentialSpace X] {f : X ‚Üí Y} :\n    Continuous f ‚Üî SeqContinuous f :=\n  ‚ü®Continuous.seqContinuous, SeqContinuous.continuous‚ü©\n\n"}
{"name":"SequentialSpace.coinduced","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : SequentialSpace X\nY : Type u_3\nf : X ‚Üí Y\n‚ä¢ SequentialSpace Y","decl":"theorem SequentialSpace.coinduced [SequentialSpace X] {Y} (f : X ‚Üí Y) :\n    @SequentialSpace Y (.coinduced f ‚Äπ_‚Ä∫) :=\n  letI : TopologicalSpace Y := .coinduced f ‚Äπ_‚Ä∫\n  ‚ü®fun _ hs ‚Ü¶ isClosed_coinduced.2 (hs.preimage continuous_coinduced_rng.seqContinuous).isClosed‚ü©\n\n"}
{"name":"SequentialSpace.iSup","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_4\nŒπ : Sort u_3\nt : Œπ ‚Üí TopologicalSpace X\nh : ‚àÄ (i : Œπ), SequentialSpace X\n‚ä¢ SequentialSpace X","decl":"protected theorem SequentialSpace.iSup {X} {Œπ : Sort*} {t : Œπ ‚Üí TopologicalSpace X}\n    (h : ‚àÄ i, @SequentialSpace X (t i)) : @SequentialSpace X (‚®Ü i, t i) := by\n  letI : TopologicalSpace X := ‚®Ü i, t i\n  refine ‚ü®fun s hs ‚Ü¶ isClosed_iSup_iff.2 fun i ‚Ü¶ ?_‚ü©\n  letI := t i\n  exact IsSeqClosed.isClosed fun u x hus hux ‚Ü¶ hs hus <| hux.mono_right <| nhds_mono <| le_iSup _ _\n\n"}
{"name":"SequentialSpace.sup","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_3\nt‚ÇÅ t‚ÇÇ : TopologicalSpace X\nh‚ÇÅ : SequentialSpace X\nh‚ÇÇ : SequentialSpace X\n‚ä¢ SequentialSpace X","decl":"protected theorem SequentialSpace.sup {X} {t‚ÇÅ t‚ÇÇ : TopologicalSpace X}\n    (h‚ÇÅ : @SequentialSpace X t‚ÇÅ) (h‚ÇÇ : @SequentialSpace X t‚ÇÇ) :\n    @SequentialSpace X (t‚ÇÅ ‚äî t‚ÇÇ) := by\n  rw [sup_eq_iSup]\n  exact .iSup <| Bool.forall_bool.2 ‚ü®h‚ÇÇ, h‚ÇÅ‚ü©\n\n"}
{"name":"Topology.IsQuotientMap.sequentialSpace","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : SequentialSpace X\nf : X ‚Üí Y\nhf : Topology.IsQuotientMap f\n‚ä¢ SequentialSpace Y","decl":"lemma Topology.IsQuotientMap.sequentialSpace [SequentialSpace X] {f : X ‚Üí Y}\n    (hf : IsQuotientMap f) : SequentialSpace Y := hf.2.symm ‚ñ∏ .coinduced f\n\n"}
{"name":"QuotientMap.sequentialSpace","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : SequentialSpace X\nf : X ‚Üí Y\nhf : Topology.IsQuotientMap f\n‚ä¢ SequentialSpace Y","decl":"@[deprecated (since := \"2024-10-22\")]\nalias QuotientMap.sequentialSpace := IsQuotientMap.sequentialSpace\n\n"}
{"name":"Quotient.instSequentialSpace","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : SequentialSpace X\ns : Setoid X\n‚ä¢ SequentialSpace (Quotient s)","decl":"/-- The quotient of a sequential space is a sequential space. -/\ninstance Quotient.instSequentialSpace [SequentialSpace X] {s : Setoid X} :\n    SequentialSpace (Quotient s) :=\n  isQuotientMap_quot_mk.sequentialSpace\n\n"}
{"name":"Sum.instSequentialSpace","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : SequentialSpace X\ninst‚úù : SequentialSpace Y\n‚ä¢ SequentialSpace (Sum X Y)","decl":"/-- The sum (disjoint union) of two sequential spaces is a sequential space. -/\ninstance Sum.instSequentialSpace [SequentialSpace X] [SequentialSpace Y] :\n    SequentialSpace (X ‚äï Y) :=\n  .sup (.coinduced Sum.inl) (.coinduced Sum.inr)\n\n"}
{"name":"Sigma.instSequentialSpace","module":"Mathlib.Topology.Sequences","initialProofState":"Œπ : Type u_3\nX : Œπ ‚Üí Type u_4\ninst‚úù¬π : (i : Œπ) ‚Üí TopologicalSpace (X i)\ninst‚úù : ‚àÄ (i : Œπ), SequentialSpace (X i)\n‚ä¢ SequentialSpace (Sigma fun i => X i)","decl":"/-- The disjoint union of an indexed family of sequential spaces is a sequential space. -/\ninstance Sigma.instSequentialSpace {Œπ : Type*} {X : Œπ ‚Üí Type*}\n    [‚àÄ i, TopologicalSpace (X i)] [‚àÄ i, SequentialSpace (X i)] : SequentialSpace (Œ£ i, X i) :=\n  .iSup fun _ ‚Ü¶ .coinduced _\n\n"}
{"name":"IsSeqCompact.subseq_of_frequently_in","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns : Set X\nhs : IsSeqCompact s\nx : Nat ‚Üí X\nhx : Filter.Frequently (fun n => Membership.mem s (x n)) Filter.atTop\n‚ä¢ Exists fun a => And (Membership.mem s a) (Exists fun œÜ => And (StrictMono œÜ) (Filter.Tendsto (Function.comp x œÜ) Filter.atTop (nhds a)))","decl":"theorem IsSeqCompact.subseq_of_frequently_in {s : Set X} (hs : IsSeqCompact s) {x : ‚Ñï ‚Üí X}\n    (hx : ‚àÉ·∂† n in atTop, x n ‚àà s) :\n    ‚àÉ a ‚àà s, ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß Tendsto (x ‚àò œÜ) atTop (ùìù a) :=\n  let ‚ü®œà, hœà, huœà‚ü© := extraction_of_frequently_atTop hx\n  let ‚ü®a, a_in, œÜ, hœÜ, h‚ü© := hs huœà\n  ‚ü®a, a_in, œà ‚àò œÜ, hœà.comp hœÜ, h‚ü©\n\n"}
{"name":"SeqCompactSpace.tendsto_subseq","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : SeqCompactSpace X\nx : Nat ‚Üí X\n‚ä¢ Exists fun a => Exists fun œÜ => And (StrictMono œÜ) (Filter.Tendsto (Function.comp x œÜ) Filter.atTop (nhds a))","decl":"theorem SeqCompactSpace.tendsto_subseq [SeqCompactSpace X] (x : ‚Ñï ‚Üí X) :\n    ‚àÉ (a : X) (œÜ : ‚Ñï ‚Üí ‚Ñï), StrictMono œÜ ‚àß Tendsto (x ‚àò œÜ) atTop (ùìù a) :=\n  let ‚ü®a, _, œÜ, mono, h‚ü© := isSeqCompact_univ fun n => mem_univ (x n)\n  ‚ü®a, œÜ, mono, h‚ü©\n\n"}
{"name":"IsCompact.isSeqCompact","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : FirstCountableTopology X\ns : Set X\nhs : IsCompact s\n‚ä¢ IsSeqCompact s","decl":"protected theorem IsCompact.isSeqCompact {s : Set X} (hs : IsCompact s) : IsSeqCompact s :=\n  fun _x x_in =>\n  let ‚ü®a, a_in, ha‚ü© := hs (tendsto_principal.mpr (Eventually.of_forall x_in))\n  ‚ü®a, a_in, tendsto_subseq ha‚ü©\n\n"}
{"name":"IsCompact.tendsto_subseq'","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : FirstCountableTopology X\ns : Set X\nx : Nat ‚Üí X\nhs : IsCompact s\nhx : Filter.Frequently (fun n => Membership.mem s (x n)) Filter.atTop\n‚ä¢ Exists fun a => And (Membership.mem s a) (Exists fun œÜ => And (StrictMono œÜ) (Filter.Tendsto (Function.comp x œÜ) Filter.atTop (nhds a)))","decl":"theorem IsCompact.tendsto_subseq' {s : Set X} {x : ‚Ñï ‚Üí X} (hs : IsCompact s)\n    (hx : ‚àÉ·∂† n in atTop, x n ‚àà s) :\n    ‚àÉ a ‚àà s, ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß Tendsto (x ‚àò œÜ) atTop (ùìù a) :=\n  hs.isSeqCompact.subseq_of_frequently_in hx\n\n"}
{"name":"IsCompact.tendsto_subseq","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : FirstCountableTopology X\ns : Set X\nx : Nat ‚Üí X\nhs : IsCompact s\nhx : ‚àÄ (n : Nat), Membership.mem s (x n)\n‚ä¢ Exists fun a => And (Membership.mem s a) (Exists fun œÜ => And (StrictMono œÜ) (Filter.Tendsto (Function.comp x œÜ) Filter.atTop (nhds a)))","decl":"theorem IsCompact.tendsto_subseq {s : Set X} {x : ‚Ñï ‚Üí X} (hs : IsCompact s) (hx : ‚àÄ n, x n ‚àà s) :\n    ‚àÉ a ‚àà s, ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß Tendsto (x ‚àò œÜ) atTop (ùìù a) :=\n  hs.isSeqCompact hx\n\n-- see Note [lower instance priority]\n"}
{"name":"FirstCountableTopology.seq_compact_of_compact","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : FirstCountableTopology X\ninst‚úù : CompactSpace X\n‚ä¢ SeqCompactSpace X","decl":"instance (priority := 100) FirstCountableTopology.seq_compact_of_compact [CompactSpace X] :\n    SeqCompactSpace X :=\n  ‚ü®isCompact_univ.isSeqCompact‚ü©\n\n"}
{"name":"CompactSpace.tendsto_subseq","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : FirstCountableTopology X\ninst‚úù : CompactSpace X\nx : Nat ‚Üí X\n‚ä¢ Exists fun a => Exists fun œÜ => And (StrictMono œÜ) (Filter.Tendsto (Function.comp x œÜ) Filter.atTop (nhds a))","decl":"theorem CompactSpace.tendsto_subseq [CompactSpace X] (x : ‚Ñï ‚Üí X) :\n    ‚àÉ (a : _) (œÜ : ‚Ñï ‚Üí ‚Ñï), StrictMono œÜ ‚àß Tendsto (x ‚àò œÜ) atTop (ùìù a) :=\n  SeqCompactSpace.tendsto_subseq x\n\n"}
{"name":"IsSeqCompact.image","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nf_cont : SeqContinuous f\nK : Set X\nK_cpt : IsSeqCompact K\n‚ä¢ IsSeqCompact (Set.image f K)","decl":"/-- Sequential compactness of sets is preserved under sequentially continuous functions. -/\ntheorem IsSeqCompact.image (f_cont : SeqContinuous f) {K : Set X} (K_cpt : IsSeqCompact K) :\n    IsSeqCompact (f '' K) := by\n  intro ys ys_in_fK\n  choose xs xs_in_K fxs_eq_ys using ys_in_fK\n  obtain ‚ü®a, a_in_K, phi, phi_mono, xs_phi_lim‚ü© := K_cpt xs_in_K\n  refine ‚ü®f a, mem_image_of_mem f a_in_K, phi, phi_mono, ?_‚ü©\n  exact (f_cont xs_phi_lim).congr fun x ‚Ü¶ fxs_eq_ys (phi x)\n\n"}
{"name":"IsSeqCompact.range","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\nf : X ‚Üí Y\ninst‚úù : SeqCompactSpace X\nf_cont : SeqContinuous f\n‚ä¢ IsSeqCompact (Set.range f)","decl":"/-- The range of sequentially continuous function on a sequentially compact space is sequentially\ncompact. -/\ntheorem IsSeqCompact.range [SeqCompactSpace X] (f_cont : SeqContinuous f) :\n    IsSeqCompact (Set.range f) := by\n  simpa using isSeqCompact_univ.image f_cont\n\n"}
{"name":"IsSeqCompact.exists_tendsto_of_frequently_mem","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\ninst‚úù : UniformSpace X\ns : Set X\nhs : IsSeqCompact s\nu : Nat ‚Üí X\nhu : Filter.Frequently (fun n => Membership.mem s (u n)) Filter.atTop\nhuc : CauchySeq u\n‚ä¢ Exists fun x => And (Membership.mem s x) (Filter.Tendsto u Filter.atTop (nhds x))","decl":"theorem IsSeqCompact.exists_tendsto_of_frequently_mem (hs : IsSeqCompact s) {u : ‚Ñï ‚Üí X}\n    (hu : ‚àÉ·∂† n in atTop, u n ‚àà s) (huc : CauchySeq u) : ‚àÉ x ‚àà s, Tendsto u atTop (ùìù x) :=\n  let ‚ü®x, hxs, _œÜ, œÜ_mono, hx‚ü© := hs.subseq_of_frequently_in hu\n  ‚ü®x, hxs, tendsto_nhds_of_cauchySeq_of_subseq huc œÜ_mono.tendsto_atTop hx‚ü©\n\n"}
{"name":"IsSeqCompact.exists_tendsto","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\ninst‚úù : UniformSpace X\ns : Set X\nhs : IsSeqCompact s\nu : Nat ‚Üí X\nhu : ‚àÄ (n : Nat), Membership.mem s (u n)\nhuc : CauchySeq u\n‚ä¢ Exists fun x => And (Membership.mem s x) (Filter.Tendsto u Filter.atTop (nhds x))","decl":"theorem IsSeqCompact.exists_tendsto (hs : IsSeqCompact s) {u : ‚Ñï ‚Üí X} (hu : ‚àÄ n, u n ‚àà s)\n    (huc : CauchySeq u) : ‚àÉ x ‚àà s, Tendsto u atTop (ùìù x) :=\n  hs.exists_tendsto_of_frequently_mem (Frequently.of_forall hu) huc\n\n"}
{"name":"IsSeqCompact.totallyBounded","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\ninst‚úù : UniformSpace X\ns : Set X\nh : IsSeqCompact s\n‚ä¢ TotallyBounded s","decl":"/-- A sequentially compact set in a uniform space is totally bounded. -/\nprotected theorem IsSeqCompact.totallyBounded (h : IsSeqCompact s) : TotallyBounded s := by\n  intro V V_in\n  unfold IsSeqCompact at h\n  contrapose! h\n  obtain ‚ü®u, u_in, hu‚ü© : ‚àÉ u : ‚Ñï ‚Üí X, (‚àÄ n, u n ‚àà s) ‚àß ‚àÄ n m, m < n ‚Üí u m ‚àâ ball (u n) V := by\n    simp only [not_subset, mem_iUnion‚ÇÇ, not_exists, exists_prop] at h\n    simpa only [forall_and, forall_mem_image, not_and] using seq_of_forall_finite_exists h\n  refine ‚ü®u, u_in, fun x _ œÜ hœÜ huœÜ => ?_‚ü©\n  obtain ‚ü®N, hN‚ü© : ‚àÉ N, ‚àÄ p q, p ‚â• N ‚Üí q ‚â• N ‚Üí (u (œÜ p), u (œÜ q)) ‚àà V :=\n    huœÜ.cauchySeq.mem_entourage V_in\n  exact hu (œÜ <| N + 1) (œÜ N) (hœÜ <| Nat.lt_add_one N) (hN (N + 1) N N.le_succ le_rfl)\n\n"}
{"name":"IsSeqCompact.isComplete","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\ninst‚úù¬π : UniformSpace X\ns : Set X\ninst‚úù : (uniformity X).IsCountablyGenerated\nhs : IsSeqCompact s\n‚ä¢ IsComplete s","decl":"/-- A sequentially compact set in a uniform set with countably generated uniformity filter\nis complete. -/\nprotected theorem IsSeqCompact.isComplete (hs : IsSeqCompact s) : IsComplete s := fun l hl hls => by\n  have := hl.1\n  rcases exists_antitone_basis (ùì§ X) with ‚ü®V, hV‚ü©\n  choose W hW hWV using fun n => comp_mem_uniformity_sets (hV.mem n)\n  have hWV' : ‚àÄ n, W n ‚äÜ V n := fun n ‚ü®x, y‚ü© hx =>\n    @hWV n (x, y) ‚ü®x, refl_mem_uniformity <| hW _, hx‚ü©\n  obtain ‚ü®t, ht_anti, htl, htW, hts‚ü© :\n      ‚àÉ t : ‚Ñï ‚Üí Set X, Antitone t ‚àß (‚àÄ n, t n ‚àà l) ‚àß (‚àÄ n, t n √óÀ¢ t n ‚äÜ W n) ‚àß ‚àÄ n, t n ‚äÜ s := by\n    have : ‚àÄ n, ‚àÉ t ‚àà l, t √óÀ¢ t ‚äÜ W n ‚àß t ‚äÜ s := by\n      rw [le_principal_iff] at hls\n      have : ‚àÄ n, W n ‚à© s √óÀ¢ s ‚àà l √óÀ¢ l := fun n => inter_mem (hl.2 (hW n)) (prod_mem_prod hls hls)\n      simpa only [l.basis_sets.prod_self.mem_iff, true_imp_iff, subset_inter_iff,\n        prod_self_subset_prod_self, and_assoc] using this\n    choose t htl htW hts using this\n    have : ‚àÄ n : ‚Ñï, ‚ãÇ k ‚â§ n, t k ‚äÜ t n := fun n => by apply iInter‚ÇÇ_subset; rfl\n    exact ‚ü®fun n => ‚ãÇ k ‚â§ n, t k, fun m n h =>\n      biInter_subset_biInter_left fun k (hk : k ‚â§ m) => hk.trans h, fun n =>\n      (biInter_mem (finite_le_nat n)).2 fun k _ => htl k, fun n =>\n      (prod_mono (this n) (this n)).trans (htW n), fun n => (this n).trans (hts n)‚ü©\n  choose u hu using fun n => Filter.nonempty_of_mem (htl n)\n  have huc : CauchySeq u := hV.toHasBasis.cauchySeq_iff.2 fun N _ =>\n      ‚ü®N, fun m hm n hn => hWV' _ <| @htW N (_, _) ‚ü®ht_anti hm (hu _), ht_anti hn (hu _)‚ü©‚ü©\n  rcases hs.exists_tendsto (fun n => hts n (hu n)) huc with ‚ü®x, hxs, hx‚ü©\n  refine ‚ü®x, hxs, (nhds_basis_uniformity' hV.toHasBasis).ge_iff.2 fun N _ => ?_‚ü©\n  obtain ‚ü®n, hNn, hn‚ü© : ‚àÉ n, N ‚â§ n ‚àß u n ‚àà ball x (W N) :=\n    ((eventually_ge_atTop N).and (hx <| ball_mem_nhds x (hW N))).exists\n  refine mem_of_superset (htl n) fun y hy => hWV N ‚ü®u n, hn, htW N ?_‚ü©\n  exact ‚ü®ht_anti hNn (hu n), ht_anti hNn hy‚ü©\n\n"}
{"name":"IsSeqCompact.isCompact","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\ninst‚úù¬π : UniformSpace X\ns : Set X\ninst‚úù : (uniformity X).IsCountablyGenerated\nhs : IsSeqCompact s\n‚ä¢ IsCompact s","decl":"/-- If `ùì§ Œ≤` is countably generated, then any sequentially compact set is compact. -/\nprotected theorem IsSeqCompact.isCompact (hs : IsSeqCompact s) : IsCompact s :=\n  isCompact_iff_totallyBounded_isComplete.2 ‚ü®hs.totallyBounded, hs.isComplete‚ü©\n\n"}
{"name":"UniformSpace.isCompact_iff_isSeqCompact","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\ninst‚úù¬π : UniformSpace X\ns : Set X\ninst‚úù : (uniformity X).IsCountablyGenerated\n‚ä¢ Iff (IsCompact s) (IsSeqCompact s)","decl":"/-- A version of Bolzano-Weierstrass: in a uniform space with countably generated uniformity filter\n(e.g., in a metric space), a set is compact if and only if it is sequentially compact. -/\nprotected theorem UniformSpace.isCompact_iff_isSeqCompact : IsCompact s ‚Üî IsSeqCompact s :=\n  ‚ü®fun H => H.isSeqCompact, fun H => H.isCompact‚ü©\n\n"}
{"name":"UniformSpace.compactSpace_iff_seqCompactSpace","module":"Mathlib.Topology.Sequences","initialProofState":"X : Type u_1\ninst‚úù¬π : UniformSpace X\ninst‚úù : (uniformity X).IsCountablyGenerated\n‚ä¢ Iff (CompactSpace X) (SeqCompactSpace X)","decl":"theorem UniformSpace.compactSpace_iff_seqCompactSpace : CompactSpace X ‚Üî SeqCompactSpace X := by\n  simp only [‚Üê isCompact_univ_iff, seqCompactSpace_iff, UniformSpace.isCompact_iff_isSeqCompact]\n\n"}
