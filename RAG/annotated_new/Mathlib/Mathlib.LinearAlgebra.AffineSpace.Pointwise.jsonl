{"name":"AffineSubspace.coe_pointwise_vadd","module":"Mathlib.LinearAlgebra.AffineSpace.Pointwise","initialProofState":"k : Type u_2\nV : Type u_3\nP : Type u_4\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nv : V\ns : AffineSubspace k P\n⊢ Eq (↑(HVAdd.hVAdd v s)) (HVAdd.hVAdd v ↑s)","decl":"@[simp, norm_cast] lemma coe_pointwise_vadd (v : V) (s : AffineSubspace k P) :\n    ((v +ᵥ s : AffineSubspace k P) : Set P) = v +ᵥ (s : Set P) := rfl\n\n"}
{"name":"AffineSubspace.pointwise_vadd_eq_map","module":"Mathlib.LinearAlgebra.AffineSpace.Pointwise","initialProofState":"k : Type u_2\nV : Type u_3\nP : Type u_4\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nv : V\ns : AffineSubspace k P\n⊢ Eq (HVAdd.hVAdd v s) (AffineSubspace.map (↑(AffineEquiv.constVAdd k P v)) s)","decl":"theorem pointwise_vadd_eq_map (v : V) (s : AffineSubspace k P) :\n    v +ᵥ s = s.map (AffineEquiv.constVAdd k P v) :=\n  rfl\n\n"}
{"name":"AffineSubspace.vadd_mem_pointwise_vadd_iff","module":"Mathlib.LinearAlgebra.AffineSpace.Pointwise","initialProofState":"k : Type u_2\nV : Type u_3\nP : Type u_4\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nv : V\ns : AffineSubspace k P\np : P\n⊢ Iff (Membership.mem (HVAdd.hVAdd v s) (HVAdd.hVAdd v p)) (Membership.mem s p)","decl":"theorem vadd_mem_pointwise_vadd_iff {v : V} {s : AffineSubspace k P} {p : P} :\n    v +ᵥ p ∈ v +ᵥ s ↔ p ∈ s :=\n  vadd_mem_vadd_set_iff\n\n"}
{"name":"AffineSubspace.pointwise_vadd_bot","module":"Mathlib.LinearAlgebra.AffineSpace.Pointwise","initialProofState":"k : Type u_2\nV : Type u_3\nP : Type u_4\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nv : V\n⊢ Eq (HVAdd.hVAdd v Bot.bot) Bot.bot","decl":"@[simp] theorem pointwise_vadd_bot (v : V) : v +ᵥ (⊥ : AffineSubspace k P) = ⊥ := by\n  ext; simp [pointwise_vadd_eq_map, map_bot]\n\n"}
{"name":"AffineSubspace.pointwise_vadd_top","module":"Mathlib.LinearAlgebra.AffineSpace.Pointwise","initialProofState":"k : Type u_2\nV : Type u_3\nP : Type u_4\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nv : V\n⊢ Eq (HVAdd.hVAdd v Top.top) Top.top","decl":"@[simp] lemma pointwise_vadd_top (v : V) : v +ᵥ (⊤ : AffineSubspace k P) = ⊤ := by\n  ext; simp [pointwise_vadd_eq_map, map_top, vadd_eq_iff_eq_neg_vadd]\n\n"}
{"name":"AffineSubspace.pointwise_vadd_direction","module":"Mathlib.LinearAlgebra.AffineSpace.Pointwise","initialProofState":"k : Type u_2\nV : Type u_3\nP : Type u_4\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nv : V\ns : AffineSubspace k P\n⊢ Eq (HVAdd.hVAdd v s).direction s.direction","decl":"theorem pointwise_vadd_direction (v : V) (s : AffineSubspace k P) :\n    (v +ᵥ s).direction = s.direction := by\n  rw [pointwise_vadd_eq_map, map_direction]\n  exact Submodule.map_id _\n\n"}
{"name":"AffineSubspace.pointwise_vadd_span","module":"Mathlib.LinearAlgebra.AffineSpace.Pointwise","initialProofState":"k : Type u_2\nV : Type u_3\nP : Type u_4\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nv : V\ns : Set P\n⊢ Eq (HVAdd.hVAdd v (affineSpan k s)) (affineSpan k (HVAdd.hVAdd v s))","decl":"theorem pointwise_vadd_span (v : V) (s : Set P) : v +ᵥ affineSpan k s = affineSpan k (v +ᵥ s) :=\n  map_span _ s\n\n"}
{"name":"AffineSubspace.map_pointwise_vadd","module":"Mathlib.LinearAlgebra.AffineSpace.Pointwise","initialProofState":"k : Type u_2\nV₁ : Type u_5\nP₁ : Type u_6\nV₂ : Type u_7\nP₂ : Type u_8\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\nf : AffineMap k P₁ P₂\nv : V₁\ns : AffineSubspace k P₁\n⊢ Eq (AffineSubspace.map f (HVAdd.hVAdd v s)) (HVAdd.hVAdd (f.linear v) (AffineSubspace.map f s))","decl":"theorem map_pointwise_vadd (f : P₁ →ᵃ[k] P₂) (v : V₁) (s : AffineSubspace k P₁) :\n    (v +ᵥ s).map f = f.linear v +ᵥ s.map f := by\n  rw [pointwise_vadd_eq_map, pointwise_vadd_eq_map, map_map, map_map]\n  congr 1\n  ext\n  exact f.map_vadd _ _\n\n"}
{"name":"AffineSubspace.coe_smul","module":"Mathlib.LinearAlgebra.AffineSpace.Pointwise","initialProofState":"M : Type u_1\nk : Type u_2\nV : Type u_3\ninst✝⁵ : Ring k\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module k V\ninst✝² : Monoid M\ninst✝¹ : DistribMulAction M V\ninst✝ : SMulCommClass M k V\na : M\ns : AffineSubspace k V\n⊢ Eq (↑(HSMul.hSMul a s)) (HSMul.hSMul a ↑s)","decl":"@[simp, norm_cast]\nlemma coe_smul (a : M) (s : AffineSubspace k V) : ↑(a • s) = a • (s : Set V) := rfl\n\n"}
{"name":"AffineSubspace.smul_eq_map","module":"Mathlib.LinearAlgebra.AffineSpace.Pointwise","initialProofState":"M : Type u_1\nk : Type u_2\nV : Type u_3\ninst✝⁵ : Ring k\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module k V\ninst✝² : Monoid M\ninst✝¹ : DistribMulAction M V\ninst✝ : SMulCommClass M k V\na : M\ns : AffineSubspace k V\n⊢ Eq (HSMul.hSMul a s) (AffineSubspace.map (DistribMulAction.toLinearMap k V a).toAffineMap s)","decl":"lemma smul_eq_map (a : M) (s : AffineSubspace k V) :\n    a • s = s.map (DistribMulAction.toLinearMap k _ a).toAffineMap := rfl\n\n"}
{"name":"AffineSubspace.smul_mem_smul_iff","module":"Mathlib.LinearAlgebra.AffineSpace.Pointwise","initialProofState":"k : Type u_2\nV : Type u_3\ninst✝⁵ : Ring k\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module k V\ns : AffineSubspace k V\np : V\nG : Type u_9\ninst✝² : Group G\ninst✝¹ : DistribMulAction G V\ninst✝ : SMulCommClass G k V\na : G\n⊢ Iff (Membership.mem (HSMul.hSMul a s) (HSMul.hSMul a p)) (Membership.mem s p)","decl":"lemma smul_mem_smul_iff {G : Type*} [Group G] [DistribMulAction G V] [SMulCommClass G k V] {a : G} :\n    a • p ∈ a • s ↔ p ∈ s := smul_mem_smul_set_iff\n\n"}
{"name":"AffineSubspace.smul_mem_smul_iff_of_isUnit","module":"Mathlib.LinearAlgebra.AffineSpace.Pointwise","initialProofState":"M : Type u_1\nk : Type u_2\nV : Type u_3\ninst✝⁵ : Ring k\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module k V\ninst✝² : Monoid M\ninst✝¹ : DistribMulAction M V\ninst✝ : SMulCommClass M k V\na : M\ns : AffineSubspace k V\np : V\nha : IsUnit a\n⊢ Iff (Membership.mem (HSMul.hSMul a s) (HSMul.hSMul a p)) (Membership.mem s p)","decl":"lemma smul_mem_smul_iff_of_isUnit (ha : IsUnit a) : a • p ∈ a • s ↔ p ∈ s :=\n  smul_mem_smul_iff (a := ha.unit)\n\n"}
{"name":"AffineSubspace.smul_mem_smul_iff₀","module":"Mathlib.LinearAlgebra.AffineSpace.Pointwise","initialProofState":"k : Type u_2\nV : Type u_3\ninst✝⁵ : Ring k\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module k V\ns : AffineSubspace k V\np : V\nG₀ : Type u_9\ninst✝² : GroupWithZero G₀\ninst✝¹ : DistribMulAction G₀ V\ninst✝ : SMulCommClass G₀ k V\na : G₀\nha : Ne a 0\n⊢ Iff (Membership.mem (HSMul.hSMul a s) (HSMul.hSMul a p)) (Membership.mem s p)","decl":"lemma smul_mem_smul_iff₀ {G₀ : Type*} [GroupWithZero G₀] [DistribMulAction G₀ V]\n    [SMulCommClass G₀ k V] {a : G₀} (ha : a ≠ 0) : a • p ∈ a • s ↔ p ∈ s :=\n  smul_mem_smul_iff_of_isUnit ha.isUnit\n\n"}
{"name":"AffineSubspace.smul_bot","module":"Mathlib.LinearAlgebra.AffineSpace.Pointwise","initialProofState":"M : Type u_1\nk : Type u_2\nV : Type u_3\ninst✝⁵ : Ring k\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module k V\ninst✝² : Monoid M\ninst✝¹ : DistribMulAction M V\ninst✝ : SMulCommClass M k V\na : M\n⊢ Eq (HSMul.hSMul a Bot.bot) Bot.bot","decl":"@[simp] lemma smul_bot (a : M) : a • (⊥ : AffineSubspace k V) = ⊥ := by\n  ext; simp [smul_eq_map, map_bot]\n\n"}
{"name":"AffineSubspace.smul_top","module":"Mathlib.LinearAlgebra.AffineSpace.Pointwise","initialProofState":"M : Type u_1\nk : Type u_2\nV : Type u_3\ninst✝⁵ : Ring k\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module k V\ninst✝² : Monoid M\ninst✝¹ : DistribMulAction M V\ninst✝ : SMulCommClass M k V\na : M\nha : IsUnit a\n⊢ Eq (HSMul.hSMul a Top.top) Top.top","decl":"@[simp] lemma smul_top (ha : IsUnit a) : a • (⊤ : AffineSubspace k V) = ⊤ := by\n  ext x; simpa [smul_eq_map, map_top] using ⟨ha.unit⁻¹ • x, smul_inv_smul ha.unit _⟩\n\n"}
{"name":"AffineSubspace.smul_span","module":"Mathlib.LinearAlgebra.AffineSpace.Pointwise","initialProofState":"M : Type u_1\nk : Type u_2\nV : Type u_3\ninst✝⁵ : Ring k\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module k V\ninst✝² : Monoid M\ninst✝¹ : DistribMulAction M V\ninst✝ : SMulCommClass M k V\na : M\ns : Set V\n⊢ Eq (HSMul.hSMul a (affineSpan k s)) (affineSpan k (HSMul.hSMul a s))","decl":"lemma smul_span (a : M) (s : Set V) : a • affineSpan k s = affineSpan k (a • s) := map_span _ s\n\n"}
{"name":"AffineSubspace.direction_smul","module":"Mathlib.LinearAlgebra.AffineSpace.Pointwise","initialProofState":"k : Type u_2\nV : Type u_3\ninst✝² : Field k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\na : k\nha : Ne a 0\ns : AffineSubspace k V\n⊢ Eq (HSMul.hSMul a s).direction s.direction","decl":"@[simp]\nlemma direction_smul (ha : a ≠ 0) (s : AffineSubspace k V) : (a • s).direction = s.direction := by\n  have : DistribMulAction.toLinearMap k V a = a • LinearMap.id := by\n    ext; simp\n  simp [smul_eq_map, map_direction, this, Submodule.map_smul, ha]\n\n"}
