{"name":"Ordinal.enumOrd_def","module":"Mathlib.SetTheory.Ordinal.Enum","initialProofState":"s : Set Ordinal.{u}\no : Ordinal.{u}\n⊢ Eq (Ordinal.enumOrd s o) (InfSet.sInf (Inter.inter s (setOf fun b => ∀ (c : Ordinal.{u}), LT.lt c o → LT.lt (Ordinal.enumOrd s c) b)))","decl":"@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-20\")]\ntheorem enumOrd_def (o : Ordinal.{u}) :\n    enumOrd s o = sInf (s ∩ { b | ∀ c, c < o → enumOrd s c < b }) := by\n  rw [enumOrd]\n\n"}
{"name":"Ordinal.enumOrd_le_of_forall_lt","module":"Mathlib.SetTheory.Ordinal.Enum","initialProofState":"o a : Ordinal.{u}\ns : Set Ordinal.{u}\nha : Membership.mem s a\nH : ∀ (b : Ordinal.{u}), LT.lt b o → LT.lt (Ordinal.enumOrd s b) a\n⊢ LE.le (Ordinal.enumOrd s o) a","decl":"theorem enumOrd_le_of_forall_lt (ha : a ∈ s) (H : ∀ b < o, enumOrd s b < a) : enumOrd s o ≤ a := by\n  rw [enumOrd]\n  exact csInf_le' ⟨ha, H⟩\n\n"}
{"name":"Ordinal.enumOrd_mem","module":"Mathlib.SetTheory.Ordinal.Enum","initialProofState":"s : Set Ordinal.{u}\nhs : Not (BddAbove s)\no : Ordinal.{u}\n⊢ Membership.mem s (Ordinal.enumOrd s o)","decl":"theorem enumOrd_mem (hs : ¬ BddAbove s) (o : Ordinal) : enumOrd s o ∈ s :=\n  (enumOrd_mem_aux hs o).1\n\n"}
{"name":"Ordinal.enumOrd_strictMono","module":"Mathlib.SetTheory.Ordinal.Enum","initialProofState":"s : Set Ordinal.{u}\nhs : Not (BddAbove s)\n⊢ StrictMono (Ordinal.enumOrd s)","decl":"theorem enumOrd_strictMono (hs : ¬ BddAbove s) : StrictMono (enumOrd s) :=\n  fun a b ↦ (enumOrd_mem_aux hs b).2 a\n\n"}
{"name":"Ordinal.enumOrd_injective","module":"Mathlib.SetTheory.Ordinal.Enum","initialProofState":"s : Set Ordinal.{u}\nhs : Not (BddAbove s)\n⊢ Function.Injective (Ordinal.enumOrd s)","decl":"theorem enumOrd_injective (hs : ¬ BddAbove s) : Function.Injective (enumOrd s) :=\n  (enumOrd_strictMono hs).injective\n\n"}
{"name":"Ordinal.enumOrd_inj","module":"Mathlib.SetTheory.Ordinal.Enum","initialProofState":"s : Set Ordinal.{u}\nhs : Not (BddAbove s)\na b : Ordinal.{u}\n⊢ Iff (Eq (Ordinal.enumOrd s a) (Ordinal.enumOrd s b)) (Eq a b)","decl":"theorem enumOrd_inj (hs : ¬ BddAbove s) {a b : Ordinal} : enumOrd s a = enumOrd s b ↔ a = b :=\n  (enumOrd_injective hs).eq_iff\n\n"}
{"name":"Ordinal.enumOrd_le_enumOrd","module":"Mathlib.SetTheory.Ordinal.Enum","initialProofState":"s : Set Ordinal.{u}\nhs : Not (BddAbove s)\na b : Ordinal.{u}\n⊢ Iff (LE.le (Ordinal.enumOrd s a) (Ordinal.enumOrd s b)) (LE.le a b)","decl":"theorem enumOrd_le_enumOrd (hs : ¬ BddAbove s) {a b : Ordinal} :\n    enumOrd s a ≤ enumOrd s b ↔ a ≤ b :=\n  (enumOrd_strictMono hs).le_iff_le\n\n"}
{"name":"Ordinal.enumOrd_lt_enumOrd","module":"Mathlib.SetTheory.Ordinal.Enum","initialProofState":"s : Set Ordinal.{u}\nhs : Not (BddAbove s)\na b : Ordinal.{u}\n⊢ Iff (LT.lt (Ordinal.enumOrd s a) (Ordinal.enumOrd s b)) (LT.lt a b)","decl":"theorem enumOrd_lt_enumOrd (hs : ¬ BddAbove s) {a b : Ordinal} :\n    enumOrd s a < enumOrd s b ↔ a < b :=\n  (enumOrd_strictMono hs).lt_iff_lt\n\n"}
{"name":"Ordinal.id_le_enumOrd","module":"Mathlib.SetTheory.Ordinal.Enum","initialProofState":"s : Set Ordinal.{u}\nhs : Not (BddAbove s)\n⊢ LE.le id (Ordinal.enumOrd s)","decl":"theorem id_le_enumOrd (hs : ¬ BddAbove s) : id ≤ enumOrd s :=\n  (enumOrd_strictMono hs).id_le\n\n"}
{"name":"Ordinal.le_enumOrd_self","module":"Mathlib.SetTheory.Ordinal.Enum","initialProofState":"s : Set Ordinal.{u}\nhs : Not (BddAbove s)\na : Ordinal.{u}\n⊢ LE.le a (Ordinal.enumOrd s a)","decl":"theorem le_enumOrd_self (hs : ¬ BddAbove s) {a} : a ≤ enumOrd s a :=\n  (enumOrd_strictMono hs).le_apply\n\n"}
{"name":"Ordinal.enumOrd_succ_le","module":"Mathlib.SetTheory.Ordinal.Enum","initialProofState":"a b : Ordinal.{u}\ns : Set Ordinal.{u}\nhs : Not (BddAbove s)\nha : Membership.mem s a\nhb : LT.lt (Ordinal.enumOrd s b) a\n⊢ LE.le (Ordinal.enumOrd s (Order.succ b)) a","decl":"theorem enumOrd_succ_le (hs : ¬ BddAbove s) (ha : a ∈ s) (hb : enumOrd s b < a) :\n    enumOrd s (succ b) ≤ a := by\n  apply enumOrd_le_of_forall_lt ha\n  intro c hc\n  rw [lt_succ_iff] at hc\n  exact ((enumOrd_strictMono hs).monotone hc).trans_lt hb\n\n"}
{"name":"Ordinal.range_enumOrd","module":"Mathlib.SetTheory.Ordinal.Enum","initialProofState":"s : Set Ordinal.{u}\nhs : Not (BddAbove s)\n⊢ Eq (Set.range (Ordinal.enumOrd s)) s","decl":"theorem range_enumOrd (hs : ¬ BddAbove s) : range (enumOrd s) = s := by\n  ext a\n  let t := { b | a ≤ enumOrd s b }\n  constructor\n  · rintro ⟨b, rfl⟩\n    exact enumOrd_mem hs b\n  · intro ha\n    refine ⟨sInf t, (enumOrd_le_of_forall_lt ha ?_).antisymm ?_⟩\n    · intro b hb\n      by_contra! hb'\n      exact hb.not_le (csInf_le' hb')\n    · exact csInf_mem (s := t) ⟨a, (enumOrd_strictMono hs).id_le a⟩\n\n"}
{"name":"Ordinal.enumOrd_surjective","module":"Mathlib.SetTheory.Ordinal.Enum","initialProofState":"s : Set Ordinal.{u}\nhs : Not (BddAbove s)\nb : Ordinal.{u}\nhb : Membership.mem s b\n⊢ Exists fun a => Eq (Ordinal.enumOrd s a) b","decl":"theorem enumOrd_surjective (hs : ¬ BddAbove s) {b : Ordinal} (hb : b ∈ s) :\n    ∃ a, enumOrd s a = b := by\n  rwa [← range_enumOrd hs] at hb\n\n"}
{"name":"Ordinal.enumOrd_le_of_subset","module":"Mathlib.SetTheory.Ordinal.Enum","initialProofState":"s t : Set Ordinal.{u}\nhs : Not (BddAbove s)\nhst : HasSubset.Subset s t\n⊢ LE.le (Ordinal.enumOrd t) (Ordinal.enumOrd s)","decl":"theorem enumOrd_le_of_subset {t : Set Ordinal} (hs : ¬ BddAbove s) (hst : s ⊆ t) :\n    enumOrd t ≤ enumOrd s := by\n  intro a\n  rw [enumOrd, enumOrd]\n  apply csInf_le_csInf' (enumOrd_nonempty hs a) (inter_subset_inter hst _)\n  intro b hb c hc\n  exact (enumOrd_le_of_subset hs hst c).trans_lt <| hb c hc\ntermination_by a => a\n\n"}
{"name":"Ordinal.eq_enumOrd","module":"Mathlib.SetTheory.Ordinal.Enum","initialProofState":"s : Set Ordinal.{u}\nf : Ordinal.{u} → Ordinal.{u}\nhs : Not (BddAbove s)\n⊢ Iff (Eq (Ordinal.enumOrd s) f) (And (StrictMono f) (Eq (Set.range f) s))","decl":"/-- A characterization of `enumOrd`: it is the unique strict monotonic function with range `s`. -/\ntheorem eq_enumOrd (f : Ordinal → Ordinal) (hs : ¬ BddAbove s) :\n    enumOrd s = f ↔ StrictMono f ∧ range f = s := by\n  constructor\n  · rintro rfl\n    exact ⟨enumOrd_strictMono hs, range_enumOrd hs⟩\n  · rintro ⟨h₁, h₂⟩\n    rwa [← (enumOrd_strictMono hs).range_inj h₁, range_enumOrd hs, eq_comm]\n\n"}
{"name":"Ordinal.enumOrd_range","module":"Mathlib.SetTheory.Ordinal.Enum","initialProofState":"f : Ordinal.{u_1} → Ordinal.{u_1}\nhf : StrictMono f\n⊢ Eq (Ordinal.enumOrd (Set.range f)) f","decl":"theorem enumOrd_range {f : Ordinal → Ordinal} (hf : StrictMono f) : enumOrd (range f) = f :=\n  (eq_enumOrd _ hf.not_bddAbove_range_of_wellFoundedLT).2 ⟨hf, rfl⟩\n\n"}
{"name":"Ordinal.enumOrd_univ","module":"Mathlib.SetTheory.Ordinal.Enum","initialProofState":"⊢ Eq (Ordinal.enumOrd Set.univ) id","decl":"@[simp]\ntheorem enumOrd_univ : enumOrd Set.univ = id := by\n  rw [← range_id]\n  exact enumOrd_range strictMono_id\n\n"}
{"name":"Ordinal.enumOrd_zero","module":"Mathlib.SetTheory.Ordinal.Enum","initialProofState":"s : Set Ordinal.{u}\n⊢ Eq (Ordinal.enumOrd s 0) (InfSet.sInf s)","decl":"@[simp]\ntheorem enumOrd_zero : enumOrd s 0 = sInf s := by\n  rw [enumOrd]\n  simp [Ordinal.not_lt_zero]\n\n"}
