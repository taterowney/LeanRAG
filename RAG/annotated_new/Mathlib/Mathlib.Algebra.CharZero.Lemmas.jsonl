{"name":"Nat.castEmbedding_apply","module":"Mathlib.Algebra.CharZero.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoidWithOne R\ninst✝ : CharZero R\na✝ : Nat\n⊢ Eq (Nat.castEmbedding a✝) ↑a✝","decl":"/-- `Nat.cast` as an embedding into monoids of characteristic `0`. -/\n@[simps]\ndef castEmbedding : ℕ ↪ R :=\n  ⟨Nat.cast, cast_injective⟩\n\n"}
{"name":"Nat.cast_pow_eq_one","module":"Mathlib.Algebra.CharZero.Lemmas","initialProofState":"R : Type u_2\ninst✝¹ : Semiring R\ninst✝ : CharZero R\nq n : Nat\nhn : Ne n 0\n⊢ Iff (Eq (HPow.hPow (↑q) n) 1) (Eq q 1)","decl":"@[simp]\ntheorem cast_pow_eq_one {R : Type*} [Semiring R] [CharZero R] (q : ℕ) (n : ℕ) (hn : n ≠ 0) :\n    (q : R) ^ n = 1 ↔ q = 1 := by\n  rw [← cast_pow, cast_eq_one]\n  exact pow_eq_one_iff hn\n\n"}
{"name":"Nat.cast_div_charZero","module":"Mathlib.Algebra.CharZero.Lemmas","initialProofState":"k : Type u_2\ninst✝¹ : DivisionSemiring k\ninst✝ : CharZero k\nm n : Nat\nn_dvd : Dvd.dvd n m\n⊢ Eq (↑(HDiv.hDiv m n)) (HDiv.hDiv ↑m ↑n)","decl":"@[simp, norm_cast]\ntheorem cast_div_charZero {k : Type*} [DivisionSemiring k] [CharZero k] {m n : ℕ} (n_dvd : n ∣ m) :\n    ((m / n : ℕ) : k) = m / n := by\n  rcases eq_or_ne n 0 with (rfl | hn)\n  · simp\n  · exact cast_div n_dvd (cast_ne_zero.2 hn)\n\n"}
{"name":"CharZero.NeZero.two","module":"Mathlib.Algebra.CharZero.Lemmas","initialProofState":"M : Type u_2\ninst✝ : AddMonoidWithOne M\n⊢ NeZero 2","decl":"instance CharZero.NeZero.two : NeZero (2 : M) :=\n  ⟨by\n    have : ((2 : ℕ) : M) ≠ 0 := Nat.cast_ne_zero.2 (by decide)\n    rwa [Nat.cast_two] at this⟩\n\n"}
{"name":"Function.support_natCast","module":"Mathlib.Algebra.CharZero.Lemmas","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝¹ : AddMonoidWithOne M\ninst✝ : CharZero M\nn : Nat\nhn : Ne n 0\n⊢ Eq (Function.support ↑n) Set.univ","decl":"lemma support_natCast (hn : n ≠ 0) : support (n : α → M) = univ :=\n  support_const <| Nat.cast_ne_zero.2 hn\n\n"}
{"name":"Function.mulSupport_natCast","module":"Mathlib.Algebra.CharZero.Lemmas","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝¹ : AddMonoidWithOne M\ninst✝ : CharZero M\nn : Nat\nhn : Ne n 1\n⊢ Eq (Function.mulSupport ↑n) Set.univ","decl":"lemma mulSupport_natCast (hn : n ≠ 1) : mulSupport (n : α → M) = univ :=\n  mulSupport_const <| Nat.cast_ne_one.2 hn\n\n"}
{"name":"add_self_eq_zero","module":"Mathlib.Algebra.CharZero.Lemmas","initialProofState":"R : Type u_1\ninst✝² : NonAssocSemiring R\ninst✝¹ : NoZeroDivisors R\ninst✝ : CharZero R\na : R\n⊢ Iff (Eq (HAdd.hAdd a a) 0) (Eq a 0)","decl":"@[simp]\ntheorem add_self_eq_zero {a : R} : a + a = 0 ↔ a = 0 := by\n  simp only [(two_mul a).symm, mul_eq_zero, two_ne_zero, false_or]\n\n"}
{"name":"CharZero.neg_eq_self_iff","module":"Mathlib.Algebra.CharZero.Lemmas","initialProofState":"R : Type u_1\ninst✝² : NonAssocRing R\ninst✝¹ : NoZeroDivisors R\ninst✝ : CharZero R\na : R\n⊢ Iff (Eq (Neg.neg a) a) (Eq a 0)","decl":"@[scoped simp] theorem CharZero.neg_eq_self_iff {a : R} : -a = a ↔ a = 0 :=\n  neg_eq_iff_add_eq_zero.trans add_self_eq_zero\n\n"}
{"name":"CharZero.eq_neg_self_iff","module":"Mathlib.Algebra.CharZero.Lemmas","initialProofState":"R : Type u_1\ninst✝² : NonAssocRing R\ninst✝¹ : NoZeroDivisors R\ninst✝ : CharZero R\na : R\n⊢ Iff (Eq a (Neg.neg a)) (Eq a 0)","decl":"@[scoped simp] theorem CharZero.eq_neg_self_iff {a : R} : a = -a ↔ a = 0 :=\n  eq_neg_iff_add_eq_zero.trans add_self_eq_zero\n\n"}
{"name":"nat_mul_inj","module":"Mathlib.Algebra.CharZero.Lemmas","initialProofState":"R : Type u_1\ninst✝² : NonAssocRing R\ninst✝¹ : NoZeroDivisors R\ninst✝ : CharZero R\nn : Nat\na b : R\nh : Eq (HMul.hMul (↑n) a) (HMul.hMul (↑n) b)\n⊢ Or (Eq n 0) (Eq a b)","decl":"theorem nat_mul_inj {n : ℕ} {a b : R} (h : (n : R) * a = (n : R) * b) : n = 0 ∨ a = b := by\n  rw [← sub_eq_zero, ← mul_sub, mul_eq_zero, sub_eq_zero] at h\n  exact mod_cast h\n\n"}
{"name":"nat_mul_inj'","module":"Mathlib.Algebra.CharZero.Lemmas","initialProofState":"R : Type u_1\ninst✝² : NonAssocRing R\ninst✝¹ : NoZeroDivisors R\ninst✝ : CharZero R\nn : Nat\na b : R\nh : Eq (HMul.hMul (↑n) a) (HMul.hMul (↑n) b)\nw : Ne n 0\n⊢ Eq a b","decl":"theorem nat_mul_inj' {n : ℕ} {a b : R} (h : (n : R) * a = (n : R) * b) (w : n ≠ 0) : a = b := by\n  simpa [w] using nat_mul_inj h\n\n"}
{"name":"add_self_div_two","module":"Mathlib.Algebra.CharZero.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : DivisionSemiring R\ninst✝ : NeZero 2\na : R\n⊢ Eq (HDiv.hDiv (HAdd.hAdd a a) 2) a","decl":"@[simp] lemma add_self_div_two (a : R) : (a + a) / 2 = a := by\n  rw [← mul_two, mul_div_cancel_right₀ a two_ne_zero]\n\n"}
{"name":"add_halves","module":"Mathlib.Algebra.CharZero.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : DivisionSemiring R\ninst✝ : NeZero 2\na : R\n⊢ Eq (HAdd.hAdd (HDiv.hDiv a 2) (HDiv.hDiv a 2)) a","decl":"@[simp]\ntheorem add_halves (a : R) : a / 2 + a / 2 = a := by rw [← add_div, add_self_div_two]\n"}
{"name":"sub_half","module":"Mathlib.Algebra.CharZero.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : DivisionRing R\ninst✝ : CharZero R\na : R\n⊢ Eq (HSub.hSub a (HDiv.hDiv a 2)) (HDiv.hDiv a 2)","decl":"theorem sub_half (a : R) : a - a / 2 = a / 2 := by rw [sub_eq_iff_eq_add, add_halves]\n\n"}
{"name":"half_sub","module":"Mathlib.Algebra.CharZero.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : DivisionRing R\ninst✝ : CharZero R\na : R\n⊢ Eq (HSub.hSub (HDiv.hDiv a 2) a) (Neg.neg (HDiv.hDiv a 2))","decl":"theorem half_sub (a : R) : a / 2 - a = -(a / 2) := by rw [← neg_sub, sub_half]\n\n"}
{"name":"WithTop.instCharZero","module":"Mathlib.Algebra.CharZero.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoidWithOne R\ninst✝ : CharZero R\n⊢ CharZero (WithTop R)","decl":"instance {R : Type*} [AddMonoidWithOne R] [CharZero R] :\n    CharZero (WithTop R) where\n  cast_injective m n h := by\n    rwa [← coe_natCast, ← coe_natCast n, coe_eq_coe, Nat.cast_inj] at h\n\n"}
{"name":"WithBot.instCharZero","module":"Mathlib.Algebra.CharZero.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoidWithOne R\ninst✝ : CharZero R\n⊢ CharZero (WithBot R)","decl":"instance {R : Type*} [AddMonoidWithOne R] [CharZero R] :\n    CharZero (WithBot R) where\n  cast_injective m n h := by\n    rwa [← coe_natCast, ← coe_natCast n, coe_eq_coe, Nat.cast_inj] at h\n\n"}
{"name":"RingHom.charZero","module":"Mathlib.Algebra.CharZero.Lemmas","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : NonAssocSemiring R\ninst✝¹ : NonAssocSemiring S\nϕ : RingHom R S\ninst✝ : CharZero S\n⊢ CharZero R","decl":"theorem RingHom.charZero (ϕ : R →+* S) [CharZero S] : CharZero R :=\n  ⟨fun a b h => CharZero.cast_injective (R := S) (by rw [← map_natCast ϕ, ← map_natCast ϕ, h])⟩\n\n"}
{"name":"RingHom.charZero_iff","module":"Mathlib.Algebra.CharZero.Lemmas","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nϕ : RingHom R S\nhϕ : Function.Injective ⇑ϕ\n⊢ Iff (CharZero R) (CharZero S)","decl":"theorem RingHom.charZero_iff {ϕ : R →+* S} (hϕ : Function.Injective ϕ) : CharZero R ↔ CharZero S :=\n  ⟨fun hR =>\n    ⟨by intro a b h; rwa [← @Nat.cast_inj R, ← hϕ.eq_iff, map_natCast ϕ, map_natCast ϕ]⟩,\n    fun _ => ϕ.charZero⟩\n\n"}
{"name":"RingHom.injective_nat","module":"Mathlib.Algebra.CharZero.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : NonAssocSemiring R\nf : RingHom Nat R\ninst✝ : CharZero R\n⊢ Function.Injective ⇑f","decl":"theorem RingHom.injective_nat (f : ℕ →+* R) [CharZero R] : Function.Injective f :=\n  Subsingleton.elim (Nat.castRingHom _) f ▸ Nat.cast_injective\n\n"}
{"name":"units_ne_neg_self","module":"Mathlib.Algebra.CharZero.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : CharZero R\nu : Units R\n⊢ Ne u (Neg.neg u)","decl":"@[simp]\ntheorem units_ne_neg_self (u : Rˣ) : u ≠ -u := by\n  simp_rw [ne_eq, Units.ext_iff, Units.val_neg, eq_neg_iff_add_eq_zero, ← two_mul,\n    Units.mul_left_eq_zero, two_ne_zero, not_false_iff]\n\n"}
{"name":"neg_units_ne_self","module":"Mathlib.Algebra.CharZero.Lemmas","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : CharZero R\nu : Units R\n⊢ Ne (Neg.neg u) u","decl":"@[simp]\ntheorem neg_units_ne_self (u : Rˣ) : -u ≠ u := (units_ne_neg_self u).symm\n\n"}
