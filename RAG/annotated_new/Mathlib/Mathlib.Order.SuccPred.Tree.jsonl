{"name":"IsPredArchimedean.findAtom_le","module":"Mathlib.Order.SuccPred.Tree","initialProofState":"α : Type u_1\ninst✝⁴ : PartialOrder α\ninst✝³ : PredOrder α\ninst✝² : IsPredArchimedean α\ninst✝¹ : OrderBot α\ninst✝ : DecidableEq α\nr : α\n⊢ LE.le (IsPredArchimedean.findAtom r) r","decl":"@[simp]\nlemma findAtom_le (r : α) : findAtom r ≤ r :=\n  Order.pred_iterate_le _ _\n\n"}
{"name":"IsPredArchimedean.findAtom_bot","module":"Mathlib.Order.SuccPred.Tree","initialProofState":"α : Type u_1\ninst✝⁴ : PartialOrder α\ninst✝³ : PredOrder α\ninst✝² : IsPredArchimedean α\ninst✝¹ : OrderBot α\ninst✝ : DecidableEq α\n⊢ Eq (IsPredArchimedean.findAtom Bot.bot) Bot.bot","decl":"@[simp]\nlemma findAtom_bot : findAtom (⊥ : α) = ⊥ := by\n  apply Function.iterate_fixed\n  simp\n\n"}
{"name":"IsPredArchimedean.pred_findAtom","module":"Mathlib.Order.SuccPred.Tree","initialProofState":"α : Type u_1\ninst✝⁴ : PartialOrder α\ninst✝³ : PredOrder α\ninst✝² : IsPredArchimedean α\ninst✝¹ : OrderBot α\ninst✝ : DecidableEq α\nr : α\n⊢ Eq (Order.pred (IsPredArchimedean.findAtom r)) Bot.bot","decl":"@[simp]\nlemma pred_findAtom (r : α) : Order.pred (findAtom r) = ⊥ := by\n  unfold findAtom\n  generalize h : Nat.find (bot_le (a := r)).exists_pred_iterate = n\n  cases n\n  · have : Order.pred^[0] r = ⊥ := by\n      rw [← h]\n      apply Nat.find_spec (bot_le (a := r)).exists_pred_iterate\n    simp only [Function.iterate_zero, id_eq] at this\n    simp [this]\n  · simp only [Nat.add_sub_cancel_right, ← Function.iterate_succ_apply', Nat.succ_eq_add_one]\n    rw [← h]\n    apply Nat.find_spec (bot_le (a := r)).exists_pred_iterate\n\n"}
{"name":"IsPredArchimedean.findAtom_eq_bot","module":"Mathlib.Order.SuccPred.Tree","initialProofState":"α : Type u_1\ninst✝⁴ : PartialOrder α\ninst✝³ : PredOrder α\ninst✝² : IsPredArchimedean α\ninst✝¹ : OrderBot α\ninst✝ : DecidableEq α\nr : α\n⊢ Iff (Eq (IsPredArchimedean.findAtom r) Bot.bot) (Eq r Bot.bot)","decl":"@[simp]\nlemma findAtom_eq_bot {r : α} :\n    findAtom r = ⊥ ↔ r = ⊥ where\n  mp h := by\n    unfold findAtom at h\n    have := Nat.find_min' (bot_le (a := r)).exists_pred_iterate h\n    replace : Nat.find (bot_le (a := r)).exists_pred_iterate = 0 := by omega\n    simpa [this] using h\n  mpr h := by simp [h]\n\n"}
{"name":"IsPredArchimedean.findAtom_ne_bot","module":"Mathlib.Order.SuccPred.Tree","initialProofState":"α : Type u_1\ninst✝⁴ : PartialOrder α\ninst✝³ : PredOrder α\ninst✝² : IsPredArchimedean α\ninst✝¹ : OrderBot α\ninst✝ : DecidableEq α\nr : α\n⊢ Iff (Ne (IsPredArchimedean.findAtom r) Bot.bot) (Ne r Bot.bot)","decl":"lemma findAtom_ne_bot {r : α} :\n    findAtom r ≠ ⊥ ↔ r ≠ ⊥ := findAtom_eq_bot.not\n\n"}
{"name":"IsPredArchimedean.isAtom_findAtom","module":"Mathlib.Order.SuccPred.Tree","initialProofState":"α : Type u_1\ninst✝⁴ : PartialOrder α\ninst✝³ : PredOrder α\ninst✝² : IsPredArchimedean α\ninst✝¹ : OrderBot α\ninst✝ : DecidableEq α\nr : α\nhr : Ne r Bot.bot\n⊢ IsAtom (IsPredArchimedean.findAtom r)","decl":"lemma isAtom_findAtom {r : α} (hr : r ≠ ⊥) :\n    IsAtom (findAtom r) := by\n  constructor\n  · simp [hr]\n  · intro b hb\n    apply Order.le_pred_of_lt at hb\n    simpa using hb\n\n"}
{"name":"IsPredArchimedean.isAtom_findAtom_iff","module":"Mathlib.Order.SuccPred.Tree","initialProofState":"α : Type u_1\ninst✝⁴ : PartialOrder α\ninst✝³ : PredOrder α\ninst✝² : IsPredArchimedean α\ninst✝¹ : OrderBot α\ninst✝ : DecidableEq α\nr : α\n⊢ Iff (IsAtom (IsPredArchimedean.findAtom r)) (Ne r Bot.bot)","decl":"@[simp]\nlemma isAtom_findAtom_iff {r : α} :\n    IsAtom (findAtom r) ↔ r ≠ ⊥ where\n  mpr := isAtom_findAtom\n  mp h nh := by simp only [nh, findAtom_bot] at h; exact h.1 rfl\n\n"}
{"name":"IsPredArchimedean.instIsAtomic","module":"Mathlib.Order.SuccPred.Tree","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\n⊢ IsAtomic α","decl":"instance instIsAtomic : IsAtomic α where\n  eq_bot_or_exists_atom_le b := by classical\n    rw [or_iff_not_imp_left]\n    intro hb\n    use findAtom b, isAtom_findAtom hb, findAtom_le b\n\n"}
{"name":"RootedTree.isPredArchimedean","module":"Mathlib.Order.SuccPred.Tree","initialProofState":"self : RootedTree\n⊢ IsPredArchimedean self.α","decl":"/--\nThe type of rooted trees.\n-/\nstructure RootedTree where\n  /-- The type representing the elements in the tree. -/\n  α : Type*\n  /-- The type should be a `SemilatticeInf`,\n    where `inf` is the least common ancestor in the tree. -/\n  [semilatticeInf : SemilatticeInf α]\n  /-- The type should have a bottom, the root. -/\n  [orderBot : OrderBot α]\n  /-- The type should have a predecessor for every element, its parent. -/\n  [predOrder : PredOrder α]\n  /-- The predecessor relationship should be archimedean. -/\n  [isPredArchimedean : IsPredArchimedean α]\n\n"}
{"name":"RootedTree.mk.injEq","module":"Mathlib.Order.SuccPred.Tree","initialProofState":"α✝ : Type u_2\nsemilatticeInf✝ : SemilatticeInf α✝\norderBot✝ : OrderBot α✝\npredOrder✝ : PredOrder α✝\nisPredArchimedean✝ : IsPredArchimedean α✝\nα : Type u_2\nsemilatticeInf : SemilatticeInf α\norderBot : OrderBot α\npredOrder : PredOrder α\nisPredArchimedean : IsPredArchimedean α\n⊢ Eq (Eq (RootedTree.mk α✝) (RootedTree.mk α)) (And (Eq α✝ α) (And (HEq semilatticeInf✝ semilatticeInf) (And (HEq orderBot✝ orderBot) (HEq predOrder✝ predOrder))))","decl":"/--\nThe type of rooted trees.\n-/\nstructure RootedTree where\n  /-- The type representing the elements in the tree. -/\n  α : Type*\n  /-- The type should be a `SemilatticeInf`,\n    where `inf` is the least common ancestor in the tree. -/\n  [semilatticeInf : SemilatticeInf α]\n  /-- The type should have a bottom, the root. -/\n  [orderBot : OrderBot α]\n  /-- The type should have a predecessor for every element, its parent. -/\n  [predOrder : PredOrder α]\n  /-- The predecessor relationship should be archimedean. -/\n  [isPredArchimedean : IsPredArchimedean α]\n\n"}
{"name":"RootedTree.mk.sizeOf_spec","module":"Mathlib.Order.SuccPred.Tree","initialProofState":"α : Type u_2\nsemilatticeInf : SemilatticeInf α\norderBot : OrderBot α\npredOrder : PredOrder α\nisPredArchimedean : IsPredArchimedean α\n⊢ Eq (SizeOf.sizeOf (RootedTree.mk α)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf α)) (SizeOf.sizeOf semilatticeInf)) (SizeOf.sizeOf orderBot)) (SizeOf.sizeOf predOrder)) (SizeOf.sizeOf isPredArchimedean))","decl":"/--\nThe type of rooted trees.\n-/\nstructure RootedTree where\n  /-- The type representing the elements in the tree. -/\n  α : Type*\n  /-- The type should be a `SemilatticeInf`,\n    where `inf` is the least common ancestor in the tree. -/\n  [semilatticeInf : SemilatticeInf α]\n  /-- The type should have a bottom, the root. -/\n  [orderBot : OrderBot α]\n  /-- The type should have a predecessor for every element, its parent. -/\n  [predOrder : PredOrder α]\n  /-- The predecessor relationship should be archimedean. -/\n  [isPredArchimedean : IsPredArchimedean α]\n\n"}
{"name":"RootedTree.mk.inj","module":"Mathlib.Order.SuccPred.Tree","initialProofState":"α✝ : Type u_2\nsemilatticeInf✝ : SemilatticeInf α✝\norderBot✝ : OrderBot α✝\npredOrder✝ : PredOrder α✝\nisPredArchimedean✝ : IsPredArchimedean α✝\nα : Type u_2\nsemilatticeInf : SemilatticeInf α\norderBot : OrderBot α\npredOrder : PredOrder α\nisPredArchimedean : IsPredArchimedean α\nx✝ : Eq (RootedTree.mk α✝) (RootedTree.mk α)\n⊢ And (Eq α✝ α) (And (HEq semilatticeInf✝ semilatticeInf) (And (HEq orderBot✝ orderBot) (HEq predOrder✝ predOrder)))","decl":"/--\nThe type of rooted trees.\n-/\nstructure RootedTree where\n  /-- The type representing the elements in the tree. -/\n  α : Type*\n  /-- The type should be a `SemilatticeInf`,\n    where `inf` is the least common ancestor in the tree. -/\n  [semilatticeInf : SemilatticeInf α]\n  /-- The type should have a bottom, the root. -/\n  [orderBot : OrderBot α]\n  /-- The type should have a predecessor for every element, its parent. -/\n  [predOrder : PredOrder α]\n  /-- The predecessor relationship should be archimedean. -/\n  [isPredArchimedean : IsPredArchimedean α]\n\n"}
{"name":"RootedTree.root_subtree","module":"Mathlib.Order.SuccPred.Tree","initialProofState":"t : RootedTree\nr : ↑t\n⊢ Eq (t.subtree r).root r","decl":"@[simp]\nlemma RootedTree.root_subtree (t : RootedTree) (r : t) : (t.subtree r).root = r := rfl\n\n"}
{"name":"RootedTree.subtree_root","module":"Mathlib.Order.SuccPred.Tree","initialProofState":"t : RootedTree\nv : SubRootedTree t\n⊢ Eq (t.subtree v.root) v","decl":"@[simp]\nlemma RootedTree.subtree_root (t : RootedTree) (v : SubRootedTree t) : t.subtree v.root = v := rfl\n\n"}
{"name":"SubRootedTree.ext","module":"Mathlib.Order.SuccPred.Tree","initialProofState":"t : RootedTree\nv₁ v₂ : SubRootedTree t\nh : Eq v₁.root v₂.root\n⊢ Eq v₁ v₂","decl":"@[ext]\nlemma SubRootedTree.ext {t : RootedTree} {v₁ v₂ : SubRootedTree t}\n    (h : v₁.root = v₂.root) : v₁ = v₂ := h\n\n"}
{"name":"SubRootedTree.ext_iff","module":"Mathlib.Order.SuccPred.Tree","initialProofState":"t : RootedTree\nv₁ v₂ : SubRootedTree t\n⊢ Iff (Eq v₁ v₂) (Eq v₁.root v₂.root)","decl":"@[ext]\nlemma SubRootedTree.ext {t : RootedTree} {v₁ v₂ : SubRootedTree t}\n    (h : v₁.root = v₂.root) : v₁ = v₂ := h\n\n"}
{"name":"SubRootedTree.mem_iff","module":"Mathlib.Order.SuccPred.Tree","initialProofState":"t : RootedTree\nr : SubRootedTree t\nv : ↑t\n⊢ Iff (Membership.mem r v) (LE.le r.root v)","decl":"lemma SubRootedTree.mem_iff {t : RootedTree} {r : SubRootedTree t} {v : t} :\n    v ∈ r ↔ r.root ≤ v := Iff.rfl\n\n"}
{"name":"SubRootedTree.bot_mem_iff","module":"Mathlib.Order.SuccPred.Tree","initialProofState":"t : RootedTree\nr : SubRootedTree t\n⊢ Iff (Membership.mem r Bot.bot) (Eq r.root Bot.bot)","decl":"@[simp]\nlemma SubRootedTree.bot_mem_iff {t : RootedTree} (r : SubRootedTree t) :\n    ⊥ ∈ r ↔ r.root = ⊥ := by\n  simp [mem_iff]\n\n"}
{"name":"SubRootedTree.root_ne_bot_of_mem_subtrees","module":"Mathlib.Order.SuccPred.Tree","initialProofState":"t : RootedTree\nr : SubRootedTree t\nhr : Membership.mem t.subtrees r\n⊢ Ne r.root Bot.bot","decl":"lemma SubRootedTree.root_ne_bot_of_mem_subtrees (r : SubRootedTree t) (hr : r ∈ t.subtrees) :\n    r.root ≠ ⊥ := by\n  simp only [RootedTree.subtrees, Set.mem_setOf_eq] at hr\n  exact hr.1\n\n"}
{"name":"RootedTree.mem_subtrees_disjoint_iff","module":"Mathlib.Order.SuccPred.Tree","initialProofState":"t : RootedTree\nt₁ t₂ : SubRootedTree t\nht₁ : Membership.mem t.subtrees t₁\nht₂ : Membership.mem t.subtrees t₂\nv₁ v₂ : ↑t\nh₁ : Membership.mem t₁ v₁\nh₂ : Membership.mem t₂ v₂\n⊢ Iff (Disjoint v₁ v₂) (Ne t₁ t₂)","decl":"lemma RootedTree.mem_subtrees_disjoint_iff {t₁ t₂ : SubRootedTree t}\n    (ht₁ : t₁ ∈ t.subtrees) (ht₂ : t₂ ∈ t.subtrees) (v₁ v₂ : t) (h₁ : v₁ ∈ t₁)\n    (h₂ : v₂ ∈ t₂) :\n    Disjoint v₁ v₂ ↔ t₁ ≠ t₂ where\n  mp h := by\n    intro nh\n    have : t₁.root ≤ (v₁ : t) ⊓ (v₂ : t) := by\n      simp only [le_inf_iff]\n      exact ⟨h₁, nh ▸ h₂⟩\n    rw [h.eq_bot] at this\n    simp only [le_bot_iff] at this\n    exact t₁.root_ne_bot_of_mem_subtrees ht₁ this\n  mpr h := by\n    rw [SubRootedTree.mem_iff] at h₁ h₂\n    contrapose! h\n    rw [disjoint_iff, ← ne_eq, ← bot_lt_iff_ne_bot] at h\n    rcases lt_or_le_of_directed (by simp : v₁ ⊓ v₂ ≤ v₁) h₁ with oh | oh\n    · simp_all [RootedTree.subtrees, IsAtom.lt_iff]\n    rw [le_inf_iff] at oh\n    ext\n    simpa only [ht₂.le_iff_eq ht₁.1, ht₁.le_iff_eq ht₂.1, eq_comm, or_self] using\n      le_total_of_directed oh.2 h₂\n\n"}
{"name":"RootedTree.subtrees_disjoint","module":"Mathlib.Order.SuccPred.Tree","initialProofState":"t : RootedTree\n⊢ t.subtrees.PairwiseDisjoint SetLike.coe","decl":"lemma RootedTree.subtrees_disjoint : t.subtrees.PairwiseDisjoint ((↑) : _ → Set t) := by\n  intro t₁ ht₁ t₂ ht₂ h\n  rw [Function.onFun_apply, Set.disjoint_left]\n  intro a ha hb\n  rw [← mem_subtrees_disjoint_iff ht₁ ht₂ a a ha hb, disjoint_self] at h\n  subst h\n  simp only [SetLike.mem_coe, SubRootedTree.bot_mem_iff] at ha\n  exact t₁.root_ne_bot_of_mem_subtrees ht₁ ha\n\n"}
{"name":"RootedTree.mem_subtreeOf","module":"Mathlib.Order.SuccPred.Tree","initialProofState":"t : RootedTree\ninst✝ : DecidableEq ↑t\nv : ↑t\n⊢ Membership.mem (t.subtreeOf v) v","decl":"@[simp]\nlemma RootedTree.mem_subtreeOf [DecidableEq t] {v : t} :\n    v ∈ t.subtreeOf v := by\n  simp [SubRootedTree.mem_iff, RootedTree.subtreeOf]\n\n"}
{"name":"RootedTree.subtreeOf_mem_subtrees","module":"Mathlib.Order.SuccPred.Tree","initialProofState":"t : RootedTree\ninst✝ : DecidableEq ↑t\nv : ↑t\nhr : Ne v Bot.bot\n⊢ Membership.mem t.subtrees (t.subtreeOf v)","decl":"lemma RootedTree.subtreeOf_mem_subtrees [DecidableEq t] {v : t} (hr : v ≠ ⊥) :\n    t.subtreeOf v ∈ t.subtrees := by\n  simpa [RootedTree.subtrees, RootedTree.subtreeOf]\n"}
