{"name":"IsCompact.exists_clusterPt","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ns : Set X\nhs : IsCompact s\nf : Filter X\ninst✝ : f.NeBot\nhf : LE.le f (Filter.principal s)\n⊢ Exists fun x => And (Membership.mem s x) (ClusterPt x f)","decl":"lemma IsCompact.exists_clusterPt (hs : IsCompact s) {f : Filter X} [NeBot f] (hf : f ≤ 𝓟 s) :\n    ∃ x ∈ s, ClusterPt x f := hs hf\n\n"}
{"name":"IsCompact.exists_mapClusterPt","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ns : Set X\nι : Type u_2\nhs : IsCompact s\nf : Filter ι\ninst✝ : f.NeBot\nu : ι → X\nhf : LE.le (Filter.map u f) (Filter.principal s)\n⊢ Exists fun x => And (Membership.mem s x) (MapClusterPt x f u)","decl":"lemma IsCompact.exists_mapClusterPt {ι : Type*} (hs : IsCompact s) {f : Filter ι} [NeBot f]\n    {u : ι → X} (hf : Filter.map u f ≤ 𝓟 s) :\n    ∃ x ∈ s, MapClusterPt x f u := hs hf\n\n"}
{"name":"IsCompact.compl_mem_sets","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsCompact s\nf : Filter X\nhf : ∀ (x : X), Membership.mem s x → Membership.mem (Min.min (nhds x) f) (HasCompl.compl s)\n⊢ Membership.mem f (HasCompl.compl s)","decl":"/-- The complement to a compact set belongs to a filter `f` if it belongs to each filter\n`𝓝 x ⊓ f`, `x ∈ s`. -/\ntheorem IsCompact.compl_mem_sets (hs : IsCompact s) {f : Filter X} (hf : ∀ x ∈ s, sᶜ ∈ 𝓝 x ⊓ f) :\n    sᶜ ∈ f := by\n  contrapose! hf\n  simp only [not_mem_iff_inf_principal_compl, compl_compl, inf_assoc] at hf ⊢\n  exact @hs _ hf inf_le_right\n\n"}
{"name":"IsCompact.compl_mem_sets_of_nhdsWithin","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsCompact s\nf : Filter X\nhf : ∀ (x : X), Membership.mem s x → Exists fun t => And (Membership.mem (nhdsWithin x s) t) (Membership.mem f (HasCompl.compl t))\n⊢ Membership.mem f (HasCompl.compl s)","decl":"/-- The complement to a compact set belongs to a filter `f` if each `x ∈ s` has a neighborhood `t`\nwithin `s` such that `tᶜ` belongs to `f`. -/\ntheorem IsCompact.compl_mem_sets_of_nhdsWithin (hs : IsCompact s) {f : Filter X}\n    (hf : ∀ x ∈ s, ∃ t ∈ 𝓝[s] x, tᶜ ∈ f) : sᶜ ∈ f := by\n  refine hs.compl_mem_sets fun x hx => ?_\n  rcases hf x hx with ⟨t, ht, hst⟩\n  replace ht := mem_inf_principal.1 ht\n  apply mem_inf_of_inter ht hst\n  rintro x ⟨h₁, h₂⟩ hs\n  exact h₂ (h₁ hs)\n\n"}
{"name":"IsCompact.induction_on","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsCompact s\np : Set X → Prop\nhe : p EmptyCollection.emptyCollection\nhmono : ∀ ⦃s t : Set X⦄, HasSubset.Subset s t → p t → p s\nhunion : ∀ ⦃s t : Set X⦄, p s → p t → p (Union.union s t)\nhnhds : ∀ (x : X), Membership.mem s x → Exists fun t => And (Membership.mem (nhdsWithin x s) t) (p t)\n⊢ p s","decl":"/-- If `p : Set X → Prop` is stable under restriction and union, and each point `x`\n  of a compact set `s` has a neighborhood `t` within `s` such that `p t`, then `p s` holds. -/\n@[elab_as_elim]\ntheorem IsCompact.induction_on (hs : IsCompact s) {p : Set X → Prop} (he : p ∅)\n    (hmono : ∀ ⦃s t⦄, s ⊆ t → p t → p s) (hunion : ∀ ⦃s t⦄, p s → p t → p (s ∪ t))\n    (hnhds : ∀ x ∈ s, ∃ t ∈ 𝓝[s] x, p t) : p s := by\n  let f : Filter X := comk p he (fun _t ht _s hsub ↦ hmono hsub ht) (fun _s hs _t ht ↦ hunion hs ht)\n  have : sᶜ ∈ f := hs.compl_mem_sets_of_nhdsWithin (by simpa [f] using hnhds)\n  rwa [← compl_compl s]\n\n"}
{"name":"IsCompact.inter_right","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns t : Set X\nhs : IsCompact s\nht : IsClosed t\n⊢ IsCompact (Inter.inter s t)","decl":"/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem IsCompact.inter_right (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s ∩ t) := by\n  intro f hnf hstf\n  obtain ⟨x, hsx, hx⟩ : ∃ x ∈ s, ClusterPt x f :=\n    hs (le_trans hstf (le_principal_iff.2 inter_subset_left))\n  have : x ∈ t := ht.mem_of_nhdsWithin_neBot <|\n    hx.mono <| le_trans hstf (le_principal_iff.2 inter_subset_right)\n  exact ⟨x, ⟨hsx, this⟩, hx⟩\n\n"}
{"name":"IsCompact.inter_left","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns t : Set X\nht : IsCompact t\nhs : IsClosed s\n⊢ IsCompact (Inter.inter s t)","decl":"/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem IsCompact.inter_left (ht : IsCompact t) (hs : IsClosed s) : IsCompact (s ∩ t) :=\n  inter_comm t s ▸ ht.inter_right hs\n\n"}
{"name":"IsCompact.diff","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns t : Set X\nhs : IsCompact s\nht : IsOpen t\n⊢ IsCompact (SDiff.sdiff s t)","decl":"/-- The set difference of a compact set and an open set is a compact set. -/\ntheorem IsCompact.diff (hs : IsCompact s) (ht : IsOpen t) : IsCompact (s \\ t) :=\n  hs.inter_right (isClosed_compl_iff.mpr ht)\n\n"}
{"name":"IsCompact.of_isClosed_subset","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns t : Set X\nhs : IsCompact s\nht : IsClosed t\nh : HasSubset.Subset t s\n⊢ IsCompact t","decl":"/-- A closed subset of a compact set is a compact set. -/\ntheorem IsCompact.of_isClosed_subset (hs : IsCompact s) (ht : IsClosed t) (h : t ⊆ s) :\n    IsCompact t :=\n  inter_eq_self_of_subset_right h ▸ hs.inter_right ht\n\n"}
{"name":"IsCompact.image_of_continuousOn","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nf : X → Y\nhs : IsCompact s\nhf : ContinuousOn f s\n⊢ IsCompact (Set.image f s)","decl":"theorem IsCompact.image_of_continuousOn {f : X → Y} (hs : IsCompact s) (hf : ContinuousOn f s) :\n    IsCompact (f '' s) := by\n  intro l lne ls\n  have : NeBot (l.comap f ⊓ 𝓟 s) :=\n    comap_inf_principal_neBot_of_image_mem lne (le_principal_iff.1 ls)\n  obtain ⟨x, hxs, hx⟩ : ∃ x ∈ s, ClusterPt x (l.comap f ⊓ 𝓟 s) := @hs _ this inf_le_right\n  haveI := hx.neBot\n  use f x, mem_image_of_mem f hxs\n  have : Tendsto f (𝓝 x ⊓ (comap f l ⊓ 𝓟 s)) (𝓝 (f x) ⊓ l) := by\n    convert (hf x hxs).inf (@tendsto_comap _ _ f l) using 1\n    rw [nhdsWithin]\n    ac_rfl\n  exact this.neBot\n\n"}
{"name":"IsCompact.image","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nf : X → Y\nhs : IsCompact s\nhf : Continuous f\n⊢ IsCompact (Set.image f s)","decl":"theorem IsCompact.image {f : X → Y} (hs : IsCompact s) (hf : Continuous f) : IsCompact (f '' s) :=\n  hs.image_of_continuousOn hf.continuousOn\n\n"}
{"name":"IsCompact.adherence_nhdset","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns t : Set X\nf : Filter X\nhs : IsCompact s\nhf₂ : LE.le f (Filter.principal s)\nht₁ : IsOpen t\nht₂ : ∀ (x : X), Membership.mem s x → ClusterPt x f → Membership.mem t x\n⊢ Membership.mem f t","decl":"theorem IsCompact.adherence_nhdset {f : Filter X} (hs : IsCompact s) (hf₂ : f ≤ 𝓟 s)\n    (ht₁ : IsOpen t) (ht₂ : ∀ x ∈ s, ClusterPt x f → x ∈ t) : t ∈ f :=\n  Classical.by_cases mem_of_eq_bot fun (this : f ⊓ 𝓟 tᶜ ≠ ⊥) =>\n    let ⟨x, hx, (hfx : ClusterPt x <| f ⊓ 𝓟 tᶜ)⟩ := @hs _ ⟨this⟩ <| inf_le_of_left_le hf₂\n    have : x ∈ t := ht₂ x hx hfx.of_inf_left\n    have : tᶜ ∩ t ∈ 𝓝[tᶜ] x := inter_mem_nhdsWithin _ (IsOpen.mem_nhds ht₁ this)\n    have A : 𝓝[tᶜ] x = ⊥ := empty_mem_iff_bot.1 <| compl_inter_self t ▸ this\n    have : 𝓝[tᶜ] x ≠ ⊥ := hfx.of_inf_right.ne\n    absurd A this\n\n"}
{"name":"isCompact_iff_ultrafilter_le_nhds","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (IsCompact s) (∀ (f : Ultrafilter X), LE.le (↑f) (Filter.principal s) → Exists fun x => And (Membership.mem s x) (LE.le (↑f) (nhds x)))","decl":"theorem isCompact_iff_ultrafilter_le_nhds :\n    IsCompact s ↔ ∀ f : Ultrafilter X, ↑f ≤ 𝓟 s → ∃ x ∈ s, ↑f ≤ 𝓝 x := by\n  refine (forall_neBot_le_iff ?_).trans ?_\n  · rintro f g hle ⟨x, hxs, hxf⟩\n    exact ⟨x, hxs, hxf.mono hle⟩\n  · simp only [Ultrafilter.clusterPt_iff]\n\n"}
{"name":"IsCompact.ultrafilter_le_nhds","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\na✝¹ : IsCompact s\nf : Ultrafilter X\na✝ : LE.le (↑f) (Filter.principal s)\n⊢ Exists fun x => And (Membership.mem s x) (LE.le (↑f) (nhds x))","decl":"alias ⟨IsCompact.ultrafilter_le_nhds, _⟩ := isCompact_iff_ultrafilter_le_nhds\n\n"}
{"name":"isCompact_iff_ultrafilter_le_nhds'","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (IsCompact s) (∀ (f : Ultrafilter X), Membership.mem f s → Exists fun x => And (Membership.mem s x) (LE.le (↑f) (nhds x)))","decl":"theorem isCompact_iff_ultrafilter_le_nhds' :\n    IsCompact s ↔ ∀ f : Ultrafilter X, s ∈ f → ∃ x ∈ s, ↑f ≤ 𝓝 x := by\n  simp only [isCompact_iff_ultrafilter_le_nhds, le_principal_iff, Ultrafilter.mem_coe]\n\n"}
{"name":"IsCompact.ultrafilter_le_nhds'","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\na✝¹ : IsCompact s\nf : Ultrafilter X\na✝ : Membership.mem f s\n⊢ Exists fun x => And (Membership.mem s x) (LE.le (↑f) (nhds x))","decl":"alias ⟨IsCompact.ultrafilter_le_nhds', _⟩ := isCompact_iff_ultrafilter_le_nhds'\n\n"}
{"name":"IsCompact.le_nhds_of_unique_clusterPt","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsCompact s\nl : Filter X\ny : X\nhmem : Membership.mem l s\nh : ∀ (x : X), Membership.mem s x → ClusterPt x l → Eq x y\n⊢ LE.le l (nhds y)","decl":"/-- If a compact set belongs to a filter and this filter has a unique cluster point `y` in this set,\nthen the filter is less than or equal to `𝓝 y`. -/\nlemma IsCompact.le_nhds_of_unique_clusterPt (hs : IsCompact s) {l : Filter X} {y : X}\n    (hmem : s ∈ l) (h : ∀ x ∈ s, ClusterPt x l → x = y) : l ≤ 𝓝 y := by\n  refine le_iff_ultrafilter.2 fun f hf ↦ ?_\n  rcases hs.ultrafilter_le_nhds' f (hf hmem) with ⟨x, hxs, hx⟩\n  convert ← hx\n  exact h x hxs (.mono (.of_le_nhds hx) hf)\n\n"}
{"name":"IsCompact.tendsto_nhds_of_unique_mapClusterPt","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nY : Type u_2\nl : Filter Y\ny : X\nf : Y → X\nhs : IsCompact s\nhmem : Filter.Eventually (fun x => Membership.mem s (f x)) l\nh : ∀ (x : X), Membership.mem s x → MapClusterPt x l f → Eq x y\n⊢ Filter.Tendsto f l (nhds y)","decl":"/-- If values of `f : Y → X` belong to a compact set `s` eventually along a filter `l`\nand `y` is a unique `MapClusterPt` for `f` along `l` in `s`,\nthen `f` tends to `𝓝 y` along `l`. -/\nlemma IsCompact.tendsto_nhds_of_unique_mapClusterPt {Y} {l : Filter Y} {y : X} {f : Y → X}\n    (hs : IsCompact s) (hmem : ∀ᶠ x in l, f x ∈ s) (h : ∀ x ∈ s, MapClusterPt x l f → x = y) :\n    Tendsto f l (𝓝 y) :=\n  hs.le_nhds_of_unique_clusterPt (mem_map.2 hmem) h\n\n"}
{"name":"IsCompact.elim_directed_cover","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nι : Type v\nhι : Nonempty ι\nhs : IsCompact s\nU : ι → Set X\nhUo : ∀ (i : ι), IsOpen (U i)\nhsU : HasSubset.Subset s (Set.iUnion fun i => U i)\nhdU : Directed (fun x1 x2 => HasSubset.Subset x1 x2) U\n⊢ Exists fun i => HasSubset.Subset s (U i)","decl":"/-- For every open directed cover of a compact set, there exists a single element of the\ncover which itself includes the set. -/\ntheorem IsCompact.elim_directed_cover {ι : Type v} [hι : Nonempty ι] (hs : IsCompact s)\n    (U : ι → Set X) (hUo : ∀ i, IsOpen (U i)) (hsU : s ⊆ ⋃ i, U i) (hdU : Directed (· ⊆ ·) U) :\n    ∃ i, s ⊆ U i :=\n  hι.elim fun i₀ =>\n    IsCompact.induction_on hs ⟨i₀, empty_subset _⟩ (fun _ _ hs ⟨i, hi⟩ => ⟨i, hs.trans hi⟩)\n      (fun _ _ ⟨i, hi⟩ ⟨j, hj⟩ =>\n        let ⟨k, hki, hkj⟩ := hdU i j\n        ⟨k, union_subset (Subset.trans hi hki) (Subset.trans hj hkj)⟩)\n      fun _x hx =>\n      let ⟨i, hi⟩ := mem_iUnion.1 (hsU hx)\n      ⟨U i, mem_nhdsWithin_of_mem_nhds (IsOpen.mem_nhds (hUo i) hi), i, Subset.refl _⟩\n\n"}
{"name":"IsCompact.elim_finite_subcover","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nι : Type v\nhs : IsCompact s\nU : ι → Set X\nhUo : ∀ (i : ι), IsOpen (U i)\nhsU : HasSubset.Subset s (Set.iUnion fun i => U i)\n⊢ Exists fun t => HasSubset.Subset s (Set.iUnion fun i => Set.iUnion fun h => U i)","decl":"/-- For every open cover of a compact set, there exists a finite subcover. -/\ntheorem IsCompact.elim_finite_subcover {ι : Type v} (hs : IsCompact s) (U : ι → Set X)\n    (hUo : ∀ i, IsOpen (U i)) (hsU : s ⊆ ⋃ i, U i) : ∃ t : Finset ι, s ⊆ ⋃ i ∈ t, U i :=\n  hs.elim_directed_cover _ (fun _ => isOpen_biUnion fun i _ => hUo i)\n    (iUnion_eq_iUnion_finset U ▸ hsU)\n    (directed_of_isDirected_le fun _ _ h => biUnion_subset_biUnion_left h)\n\n"}
{"name":"IsCompact.elim_nhds_subcover_nhdsSet'","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsCompact s\nU : (x : X) → Membership.mem s x → Set X\nhU : ∀ (x : X) (hx : Membership.mem s x), Membership.mem (nhds x) (U x hx)\n⊢ Exists fun t => Membership.mem (nhdsSet s) (Set.iUnion fun x => Set.iUnion fun h => U ↑x ⋯)","decl":"lemma IsCompact.elim_nhds_subcover_nhdsSet' (hs : IsCompact s) (U : ∀ x ∈ s, Set X)\n    (hU : ∀ x hx, U x hx ∈ 𝓝 x) : ∃ t : Finset s, (⋃ x ∈ t, U x.1 x.2) ∈ 𝓝ˢ s := by\n  rcases hs.elim_finite_subcover (fun x : s ↦ interior (U x x.2)) (fun _ ↦ isOpen_interior)\n    fun x hx ↦ mem_iUnion.2 ⟨⟨x, hx⟩, mem_interior_iff_mem_nhds.2 <| hU _ _⟩ with ⟨t, hst⟩\n  refine ⟨t, mem_nhdsSet_iff_forall.2 fun x hx ↦ ?_⟩\n  rcases mem_iUnion₂.1 (hst hx) with ⟨y, hyt, hy⟩\n  refine mem_of_superset ?_ (subset_biUnion_of_mem hyt)\n  exact mem_interior_iff_mem_nhds.1 hy\n\n"}
{"name":"IsCompact.elim_nhds_subcover_nhdsSet","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsCompact s\nU : X → Set X\nhU : ∀ (x : X), Membership.mem s x → Membership.mem (nhds x) (U x)\n⊢ Exists fun t => And (∀ (x : X), Membership.mem t x → Membership.mem s x) (Membership.mem (nhdsSet s) (Set.iUnion fun x => Set.iUnion fun h => U x))","decl":"lemma IsCompact.elim_nhds_subcover_nhdsSet (hs : IsCompact s) {U : X → Set X}\n    (hU : ∀ x ∈ s, U x ∈ 𝓝 x) : ∃ t : Finset X, (∀ x ∈ t, x ∈ s) ∧ (⋃ x ∈ t, U x) ∈ 𝓝ˢ s := by\n  let ⟨t, ht⟩ := hs.elim_nhds_subcover_nhdsSet' (fun x _ => U x) hU\n  classical\n  exact ⟨t.image (↑), fun x hx =>\n    let ⟨y, _, hyx⟩ := Finset.mem_image.1 hx\n    hyx ▸ y.2,\n    by rwa [Finset.set_biUnion_finset_image]⟩\n\n"}
{"name":"IsCompact.elim_nhds_subcover'","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsCompact s\nU : (x : X) → Membership.mem s x → Set X\nhU : ∀ (x : X), Membership.mem s x → Membership.mem (nhds x) (U x ⋯)\n⊢ Exists fun t => HasSubset.Subset s (Set.iUnion fun x => Set.iUnion fun h => U ↑x ⋯)","decl":"theorem IsCompact.elim_nhds_subcover' (hs : IsCompact s) (U : ∀ x ∈ s, Set X)\n    (hU : ∀ x (hx : x ∈ s), U x ‹x ∈ s› ∈ 𝓝 x) : ∃ t : Finset s, s ⊆ ⋃ x ∈ t, U (x : s) x.2 :=\n  (hs.elim_nhds_subcover_nhdsSet' U hU).imp fun _ ↦ subset_of_mem_nhdsSet\n\n"}
{"name":"IsCompact.elim_nhds_subcover","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsCompact s\nU : X → Set X\nhU : ∀ (x : X), Membership.mem s x → Membership.mem (nhds x) (U x)\n⊢ Exists fun t => And (∀ (x : X), Membership.mem t x → Membership.mem s x) (HasSubset.Subset s (Set.iUnion fun x => Set.iUnion fun h => U x))","decl":"theorem IsCompact.elim_nhds_subcover (hs : IsCompact s) (U : X → Set X) (hU : ∀ x ∈ s, U x ∈ 𝓝 x) :\n    ∃ t : Finset X, (∀ x ∈ t, x ∈ s) ∧ s ⊆ ⋃ x ∈ t, U x :=\n  (hs.elim_nhds_subcover_nhdsSet hU).imp fun _ h ↦ h.imp_right subset_of_mem_nhdsSet\n\n"}
{"name":"IsCompact.disjoint_nhdsSet_left","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nl : Filter X\nhs : IsCompact s\n⊢ Iff (Disjoint (nhdsSet s) l) (∀ (x : X), Membership.mem s x → Disjoint (nhds x) l)","decl":"/-- The neighborhood filter of a compact set is disjoint with a filter `l` if and only if the\nneighborhood filter of each point of this set is disjoint with `l`. -/\ntheorem IsCompact.disjoint_nhdsSet_left {l : Filter X} (hs : IsCompact s) :\n    Disjoint (𝓝ˢ s) l ↔ ∀ x ∈ s, Disjoint (𝓝 x) l := by\n  refine ⟨fun h x hx => h.mono_left <| nhds_le_nhdsSet hx, fun H => ?_⟩\n  choose! U hxU hUl using fun x hx => (nhds_basis_opens x).disjoint_iff_left.1 (H x hx)\n  choose hxU hUo using hxU\n  rcases hs.elim_nhds_subcover U fun x hx => (hUo x hx).mem_nhds (hxU x hx) with ⟨t, hts, hst⟩\n  refine (hasBasis_nhdsSet _).disjoint_iff_left.2\n    ⟨⋃ x ∈ t, U x, ⟨isOpen_biUnion fun x hx => hUo x (hts x hx), hst⟩, ?_⟩\n  rw [compl_iUnion₂, biInter_finset_mem]\n  exact fun x hx => hUl x (hts x hx)\n\n"}
{"name":"IsCompact.disjoint_nhdsSet_right","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nl : Filter X\nhs : IsCompact s\n⊢ Iff (Disjoint l (nhdsSet s)) (∀ (x : X), Membership.mem s x → Disjoint l (nhds x))","decl":"/-- A filter `l` is disjoint with the neighborhood filter of a compact set if and only if it is\ndisjoint with the neighborhood filter of each point of this set. -/\ntheorem IsCompact.disjoint_nhdsSet_right {l : Filter X} (hs : IsCompact s) :\n    Disjoint l (𝓝ˢ s) ↔ ∀ x ∈ s, Disjoint l (𝓝 x) := by\n  simpa only [disjoint_comm] using hs.disjoint_nhdsSet_left\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: reformulate using `Disjoint`\n"}
{"name":"IsCompact.elim_directed_family_closed","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ns : Set X\nι : Type v\ninst✝ : Nonempty ι\nhs : IsCompact s\nt : ι → Set X\nhtc : ∀ (i : ι), IsClosed (t i)\nhst : Eq (Inter.inter s (Set.iInter fun i => t i)) EmptyCollection.emptyCollection\nhdt : Directed (fun x1 x2 => Superset x1 x2) t\n⊢ Exists fun i => Eq (Inter.inter s (t i)) EmptyCollection.emptyCollection","decl":"/-- For every directed family of closed sets whose intersection avoids a compact set,\nthere exists a single element of the family which itself avoids this compact set. -/\ntheorem IsCompact.elim_directed_family_closed {ι : Type v} [Nonempty ι] (hs : IsCompact s)\n    (t : ι → Set X) (htc : ∀ i, IsClosed (t i)) (hst : (s ∩ ⋂ i, t i) = ∅)\n    (hdt : Directed (· ⊇ ·) t) : ∃ i : ι, s ∩ t i = ∅ :=\n  let ⟨t, ht⟩ :=\n    hs.elim_directed_cover (compl ∘ t) (fun i => (htc i).isOpen_compl)\n      (by\n        simpa only [subset_def, not_forall, eq_empty_iff_forall_not_mem, mem_iUnion, exists_prop,\n          mem_inter_iff, not_and, mem_iInter, mem_compl_iff] using hst)\n      (hdt.mono_comp _ fun _ _ => compl_subset_compl.mpr)\n  ⟨t, by\n    simpa only [subset_def, not_forall, eq_empty_iff_forall_not_mem, mem_iUnion, exists_prop,\n      mem_inter_iff, not_and, mem_iInter, mem_compl_iff] using ht⟩\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: reformulate using `Disjoint`\n"}
{"name":"IsCompact.elim_finite_subfamily_closed","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nι : Type v\nhs : IsCompact s\nt : ι → Set X\nhtc : ∀ (i : ι), IsClosed (t i)\nhst : Eq (Inter.inter s (Set.iInter fun i => t i)) EmptyCollection.emptyCollection\n⊢ Exists fun u => Eq (Inter.inter s (Set.iInter fun i => Set.iInter fun h => t i)) EmptyCollection.emptyCollection","decl":"/-- For every family of closed sets whose intersection avoids a compact set,\nthere exists a finite subfamily whose intersection avoids this compact set. -/\ntheorem IsCompact.elim_finite_subfamily_closed {ι : Type v} (hs : IsCompact s)\n    (t : ι → Set X) (htc : ∀ i, IsClosed (t i)) (hst : (s ∩ ⋂ i, t i) = ∅) :\n    ∃ u : Finset ι, (s ∩ ⋂ i ∈ u, t i) = ∅ :=\n  hs.elim_directed_family_closed _ (fun _ ↦ isClosed_biInter fun _ _ ↦ htc _)\n    (by rwa [← iInter_eq_iInter_finset])\n    (directed_of_isDirected_le fun _ _ h ↦ biInter_subset_biInter_left h)\n\n"}
{"name":"LocallyFinite.finite_nonempty_inter_compact","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nι : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\nf : ι → Set X\nhf : LocallyFinite f\nhs : IsCompact s\n⊢ (setOf fun i => (Inter.inter (f i) s).Nonempty).Finite","decl":"/-- If `s` is a compact set in a topological space `X` and `f : ι → Set X` is a locally finite\nfamily of sets, then `f i ∩ s` is nonempty only for a finitely many `i`. -/\ntheorem LocallyFinite.finite_nonempty_inter_compact {f : ι → Set X}\n    (hf : LocallyFinite f) (hs : IsCompact s) : { i | (f i ∩ s).Nonempty }.Finite := by\n  choose U hxU hUf using hf\n  rcases hs.elim_nhds_subcover U fun x _ => hxU x with ⟨t, -, hsU⟩\n  refine (t.finite_toSet.biUnion fun x _ => hUf x).subset ?_\n  rintro i ⟨x, hx⟩\n  rcases mem_iUnion₂.1 (hsU hx.2) with ⟨c, hct, hcx⟩\n  exact mem_biUnion hct ⟨x, hx.1, hcx⟩\n\n"}
{"name":"IsCompact.inter_iInter_nonempty","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nι : Type v\nhs : IsCompact s\nt : ι → Set X\nhtc : ∀ (i : ι), IsClosed (t i)\nhst : ∀ (u : Finset ι), (Inter.inter s (Set.iInter fun i => Set.iInter fun h => t i)).Nonempty\n⊢ (Inter.inter s (Set.iInter fun i => t i)).Nonempty","decl":"/-- To show that a compact set intersects the intersection of a family of closed sets,\n  it is sufficient to show that it intersects every finite subfamily. -/\ntheorem IsCompact.inter_iInter_nonempty {ι : Type v} (hs : IsCompact s) (t : ι → Set X)\n    (htc : ∀ i, IsClosed (t i)) (hst : ∀ u : Finset ι, (s ∩ ⋂ i ∈ u, t i).Nonempty) :\n    (s ∩ ⋂ i, t i).Nonempty := by\n  contrapose! hst\n  exact hs.elim_finite_subfamily_closed t htc hst\n\n"}
{"name":"IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nι : Type v\nhι : Nonempty ι\nt : ι → Set X\nhtd : Directed (fun x1 x2 => Superset x1 x2) t\nhtn : ∀ (i : ι), (t i).Nonempty\nhtc : ∀ (i : ι), IsCompact (t i)\nhtcl : ∀ (i : ι), IsClosed (t i)\n⊢ (Set.iInter fun i => t i).Nonempty","decl":"/-- Cantor's intersection theorem for `iInter`:\nthe intersection of a directed family of nonempty compact closed sets is nonempty. -/\ntheorem IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed\n    {ι : Type v} [hι : Nonempty ι] (t : ι → Set X) (htd : Directed (· ⊇ ·) t)\n    (htn : ∀ i, (t i).Nonempty) (htc : ∀ i, IsCompact (t i)) (htcl : ∀ i, IsClosed (t i)) :\n    (⋂ i, t i).Nonempty := by\n  let i₀ := hι.some\n  suffices (t i₀ ∩ ⋂ i, t i).Nonempty by\n    rwa [inter_eq_right.mpr (iInter_subset _ i₀)] at this\n  simp only [nonempty_iff_ne_empty] at htn ⊢\n  apply mt ((htc i₀).elim_directed_family_closed t htcl)\n  push_neg\n  simp only [← nonempty_iff_ne_empty] at htn ⊢\n  refine ⟨htd, fun i => ?_⟩\n  rcases htd i₀ i with ⟨j, hji₀, hji⟩\n  exact (htn j).mono (subset_inter hji₀ hji)\n\n"}
{"name":"IsCompact.nonempty_sInter_of_directed_nonempty_isCompact_isClosed","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nS : Set (Set X)\nhS : Nonempty ↑S\nhSd : DirectedOn (fun x1 x2 => Superset x1 x2) S\nhSn : ∀ (U : Set X), Membership.mem S U → U.Nonempty\nhSc : ∀ (U : Set X), Membership.mem S U → IsCompact U\nhScl : ∀ (U : Set X), Membership.mem S U → IsClosed U\n⊢ S.sInter.Nonempty","decl":"/-- Cantor's intersection theorem for `sInter`:\nthe intersection of a directed family of nonempty compact closed sets is nonempty. -/\ntheorem IsCompact.nonempty_sInter_of_directed_nonempty_isCompact_isClosed\n    {S : Set (Set X)} [hS : Nonempty S] (hSd : DirectedOn (· ⊇ ·) S) (hSn : ∀ U ∈ S, U.Nonempty)\n    (hSc : ∀ U ∈ S, IsCompact U) (hScl : ∀ U ∈ S, IsClosed U) : (⋂₀ S).Nonempty := by\n  rw [sInter_eq_iInter]\n  exact IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed _\n    (DirectedOn.directed_val hSd) (fun i ↦ hSn i i.2) (fun i ↦ hSc i i.2) (fun i ↦ hScl i i.2)\n\n"}
{"name":"IsCompact.nonempty_iInter_of_sequence_nonempty_isCompact_isClosed","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nt : Nat → Set X\nhtd : ∀ (i : Nat), HasSubset.Subset (t (HAdd.hAdd i 1)) (t i)\nhtn : ∀ (i : Nat), (t i).Nonempty\nht0 : IsCompact (t 0)\nhtcl : ∀ (i : Nat), IsClosed (t i)\n⊢ (Set.iInter fun i => t i).Nonempty","decl":"/-- Cantor's intersection theorem for sequences indexed by `ℕ`:\nthe intersection of a decreasing sequence of nonempty compact closed sets is nonempty. -/\ntheorem IsCompact.nonempty_iInter_of_sequence_nonempty_isCompact_isClosed (t : ℕ → Set X)\n    (htd : ∀ i, t (i + 1) ⊆ t i) (htn : ∀ i, (t i).Nonempty) (ht0 : IsCompact (t 0))\n    (htcl : ∀ i, IsClosed (t i)) : (⋂ i, t i).Nonempty :=\n  have tmono : Antitone t := antitone_nat_of_succ_le htd\n  have htd : Directed (· ⊇ ·) t := tmono.directed_ge\n  have : ∀ i, t i ⊆ t 0 := fun i => tmono <| Nat.zero_le i\n  have htc : ∀ i, IsCompact (t i) := fun i => ht0.of_isClosed_subset (htcl i) (this i)\n  IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed t htd htn htc htcl\n\n"}
{"name":"IsCompact.elim_finite_subcover_image","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nι : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\nb : Set ι\nc : ι → Set X\nhs : IsCompact s\nhc₁ : ∀ (i : ι), Membership.mem b i → IsOpen (c i)\nhc₂ : HasSubset.Subset s (Set.iUnion fun i => Set.iUnion fun h => c i)\n⊢ Exists fun b' => And (HasSubset.Subset b' b) (And b'.Finite (HasSubset.Subset s (Set.iUnion fun i => Set.iUnion fun h => c i)))","decl":"/-- For every open cover of a compact set, there exists a finite subcover. -/\ntheorem IsCompact.elim_finite_subcover_image {b : Set ι} {c : ι → Set X} (hs : IsCompact s)\n    (hc₁ : ∀ i ∈ b, IsOpen (c i)) (hc₂ : s ⊆ ⋃ i ∈ b, c i) :\n    ∃ b', b' ⊆ b ∧ Set.Finite b' ∧ s ⊆ ⋃ i ∈ b', c i := by\n  simp only [Subtype.forall', biUnion_eq_iUnion] at hc₁ hc₂\n  rcases hs.elim_finite_subcover (fun i => c i : b → Set X) hc₁ hc₂ with ⟨d, hd⟩\n  refine ⟨Subtype.val '' d.toSet, ?_, d.finite_toSet.image _, ?_⟩\n  · simp\n  · rwa [biUnion_image]\n\n"}
{"name":"isCompact_of_finite_subcover","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nh : ∀ {ι : Type u} (U : ι → Set X), (∀ (i : ι), IsOpen (U i)) → HasSubset.Subset s (Set.iUnion fun i => U i) → Exists fun t => HasSubset.Subset s (Set.iUnion fun i => Set.iUnion fun h => U i)\n⊢ IsCompact s","decl":"/-- A set `s` is compact if for every open cover of `s`, there exists a finite subcover. -/\ntheorem isCompact_of_finite_subcover\n    (h : ∀ {ι : Type u} (U : ι → Set X), (∀ i, IsOpen (U i)) → (s ⊆ ⋃ i, U i) →\n      ∃ t : Finset ι, s ⊆ ⋃ i ∈ t, U i) :\n    IsCompact s := fun f hf hfs => by\n  contrapose! h\n  simp only [ClusterPt, not_neBot, ← disjoint_iff, SetCoe.forall',\n    (nhds_basis_opens _).disjoint_iff_left] at h\n  choose U hU hUf using h\n  refine ⟨s, U, fun x => (hU x).2, fun x hx => mem_iUnion.2 ⟨⟨x, hx⟩, (hU _).1⟩, fun t ht => ?_⟩\n  refine compl_not_mem (le_principal_iff.1 hfs) ?_\n  refine mem_of_superset ((biInter_finset_mem t).2 fun x _ => hUf x) ?_\n  rw [subset_compl_comm, compl_iInter₂]\n  simpa only [compl_compl]\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: reformulate using `Disjoint`\n"}
{"name":"isCompact_of_finite_subfamily_closed","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nh : ∀ {ι : Type u} (t : ι → Set X), (∀ (i : ι), IsClosed (t i)) → Eq (Inter.inter s (Set.iInter fun i => t i)) EmptyCollection.emptyCollection → Exists fun u => Eq (Inter.inter s (Set.iInter fun i => Set.iInter fun h => t i)) EmptyCollection.emptyCollection\n⊢ IsCompact s","decl":"/-- A set `s` is compact if for every family of closed sets whose intersection avoids `s`,\nthere exists a finite subfamily whose intersection avoids `s`. -/\ntheorem isCompact_of_finite_subfamily_closed\n    (h : ∀ {ι : Type u} (t : ι → Set X), (∀ i, IsClosed (t i)) → (s ∩ ⋂ i, t i) = ∅ →\n      ∃ u : Finset ι, (s ∩ ⋂ i ∈ u, t i) = ∅) :\n    IsCompact s :=\n  isCompact_of_finite_subcover fun U hUo hsU => by\n    rw [← disjoint_compl_right_iff_subset, compl_iUnion, disjoint_iff] at hsU\n    rcases h (fun i => (U i)ᶜ) (fun i => (hUo _).isClosed_compl) hsU with ⟨t, ht⟩\n    refine ⟨t, ?_⟩\n    rwa [← disjoint_compl_right_iff_subset, compl_iUnion₂, disjoint_iff]\n\n"}
{"name":"isCompact_iff_finite_subcover","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (IsCompact s) (∀ {ι : Type u} (U : ι → Set X), (∀ (i : ι), IsOpen (U i)) → HasSubset.Subset s (Set.iUnion fun i => U i) → Exists fun t => HasSubset.Subset s (Set.iUnion fun i => Set.iUnion fun h => U i))","decl":"/-- A set `s` is compact if and only if\nfor every open cover of `s`, there exists a finite subcover. -/\ntheorem isCompact_iff_finite_subcover :\n    IsCompact s ↔ ∀ {ι : Type u} (U : ι → Set X),\n      (∀ i, IsOpen (U i)) → (s ⊆ ⋃ i, U i) → ∃ t : Finset ι, s ⊆ ⋃ i ∈ t, U i :=\n  ⟨fun hs => hs.elim_finite_subcover, isCompact_of_finite_subcover⟩\n\n"}
{"name":"isCompact_iff_finite_subfamily_closed","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (IsCompact s) (∀ {ι : Type u} (t : ι → Set X), (∀ (i : ι), IsClosed (t i)) → Eq (Inter.inter s (Set.iInter fun i => t i)) EmptyCollection.emptyCollection → Exists fun u => Eq (Inter.inter s (Set.iInter fun i => Set.iInter fun h => t i)) EmptyCollection.emptyCollection)","decl":"/-- A set `s` is compact if and only if\nfor every family of closed sets whose intersection avoids `s`,\nthere exists a finite subfamily whose intersection avoids `s`. -/\ntheorem isCompact_iff_finite_subfamily_closed :\n    IsCompact s ↔ ∀ {ι : Type u} (t : ι → Set X),\n      (∀ i, IsClosed (t i)) → (s ∩ ⋂ i, t i) = ∅ → ∃ u : Finset ι, (s ∩ ⋂ i ∈ u, t i) = ∅ :=\n  ⟨fun hs => hs.elim_finite_subfamily_closed, isCompact_of_finite_subfamily_closed⟩\n\n"}
{"name":"IsCompact.mem_nhdsSet_prod_of_forall","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nK : Set X\nY : Type u_2\nl : Filter Y\ns : Set (Prod X Y)\nhK : IsCompact K\nhs : ∀ (x : X), Membership.mem K x → Membership.mem (SProd.sprod (nhds x) l) s\n⊢ Membership.mem (SProd.sprod (nhdsSet K) l) s","decl":"/-- If `s : Set (X × Y)` belongs to `𝓝 x ×ˢ l` for all `x` from a compact set `K`,\nthen it belongs to `(𝓝ˢ K) ×ˢ l`,\ni.e., there exist an open `U ⊇ K` and `t ∈ l` such that `U ×ˢ t ⊆ s`. -/\ntheorem IsCompact.mem_nhdsSet_prod_of_forall {K : Set X} {Y} {l : Filter Y} {s : Set (X × Y)}\n    (hK : IsCompact K) (hs : ∀ x ∈ K, s ∈ 𝓝 x ×ˢ l) : s ∈ (𝓝ˢ K) ×ˢ l := by\n  refine hK.induction_on (by simp) (fun t t' ht hs ↦ ?_) (fun t t' ht ht' ↦ ?_) fun x hx ↦ ?_\n  · exact prod_mono (nhdsSet_mono ht) le_rfl hs\n  · simp [sup_prod, *]\n  · rcases ((nhds_basis_opens _).prod l.basis_sets).mem_iff.1 (hs x hx)\n      with ⟨⟨u, v⟩, ⟨⟨hx, huo⟩, hv⟩, hs⟩\n    refine ⟨u, nhdsWithin_le_nhds (huo.mem_nhds hx), mem_of_superset ?_ hs⟩\n    exact prod_mem_prod (huo.mem_nhdsSet.2 Subset.rfl) hv\n\n"}
{"name":"IsCompact.nhdsSet_prod_eq_biSup","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nK : Set X\nhK : IsCompact K\nY : Type u_2\nl : Filter Y\n⊢ Eq (SProd.sprod (nhdsSet K) l) (iSup fun x => iSup fun h => SProd.sprod (nhds x) l)","decl":"theorem IsCompact.nhdsSet_prod_eq_biSup {K : Set X} (hK : IsCompact K) {Y} (l : Filter Y) :\n    (𝓝ˢ K) ×ˢ l = ⨆ x ∈ K, 𝓝 x ×ˢ l :=\n  le_antisymm (fun s hs ↦ hK.mem_nhdsSet_prod_of_forall <| by simpa using hs)\n    (iSup₂_le fun _ hx ↦ prod_mono (nhds_le_nhdsSet hx) le_rfl)\n\n"}
{"name":"IsCompact.prod_nhdsSet_eq_biSup","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"Y : Type v\ninst✝ : TopologicalSpace Y\nK : Set Y\nhK : IsCompact K\nX : Type u_2\nl : Filter X\n⊢ Eq (SProd.sprod l (nhdsSet K)) (iSup fun y => iSup fun h => SProd.sprod l (nhds y))","decl":"theorem IsCompact.prod_nhdsSet_eq_biSup {K : Set Y} (hK : IsCompact K) {X} (l : Filter X) :\n    l ×ˢ (𝓝ˢ K) = ⨆ y ∈ K, l ×ˢ 𝓝 y := by\n  simp only [prod_comm (f := l), hK.nhdsSet_prod_eq_biSup, map_iSup]\n\n"}
{"name":"IsCompact.mem_prod_nhdsSet_of_forall","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"Y : Type v\ninst✝ : TopologicalSpace Y\nK : Set Y\nX : Type u_2\nl : Filter X\ns : Set (Prod X Y)\nhK : IsCompact K\nhs : ∀ (y : Y), Membership.mem K y → Membership.mem (SProd.sprod l (nhds y)) s\n⊢ Membership.mem (SProd.sprod l (nhdsSet K)) s","decl":"/-- If `s : Set (X × Y)` belongs to `l ×ˢ 𝓝 y` for all `y` from a compact set `K`,\nthen it belongs to `l ×ˢ (𝓝ˢ K)`,\ni.e., there exist `t ∈ l` and an open `U ⊇ K` such that `t ×ˢ U ⊆ s`. -/\ntheorem IsCompact.mem_prod_nhdsSet_of_forall {K : Set Y} {X} {l : Filter X} {s : Set (X × Y)}\n    (hK : IsCompact K) (hs : ∀ y ∈ K, s ∈ l ×ˢ 𝓝 y) : s ∈ l ×ˢ 𝓝ˢ K :=\n  (hK.prod_nhdsSet_eq_biSup l).symm ▸ by simpa using hs\n\n-- TODO: Is there a way to prove directly the `inf` version and then deduce the `Prod` one ?\n-- That would seem a bit more natural.\n"}
{"name":"IsCompact.nhdsSet_inf_eq_biSup","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nK : Set X\nhK : IsCompact K\nl : Filter X\n⊢ Eq (Min.min (nhdsSet K) l) (iSup fun x => iSup fun h => Min.min (nhds x) l)","decl":"theorem IsCompact.nhdsSet_inf_eq_biSup {K : Set X} (hK : IsCompact K) (l : Filter X) :\n    (𝓝ˢ K) ⊓ l = ⨆ x ∈ K, 𝓝 x ⊓ l := by\n  have : ∀ f : Filter X, f ⊓ l = comap (fun x ↦ (x, x)) (f ×ˢ l) := fun f ↦ by\n    simpa only [comap_prod] using congrArg₂ (· ⊓ ·) comap_id.symm comap_id.symm\n  simp_rw [this, ← comap_iSup, hK.nhdsSet_prod_eq_biSup]\n\n"}
{"name":"IsCompact.inf_nhdsSet_eq_biSup","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nK : Set X\nhK : IsCompact K\nl : Filter X\n⊢ Eq (Min.min l (nhdsSet K)) (iSup fun x => iSup fun h => Min.min l (nhds x))","decl":"theorem IsCompact.inf_nhdsSet_eq_biSup {K : Set X} (hK : IsCompact K) (l : Filter X) :\n    l ⊓ (𝓝ˢ K) = ⨆ x ∈ K, l ⊓ 𝓝 x := by\n  simp only [inf_comm l, hK.nhdsSet_inf_eq_biSup]\n\n"}
{"name":"IsCompact.mem_nhdsSet_inf_of_forall","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nK : Set X\nl : Filter X\ns : Set X\nhK : IsCompact K\nhs : ∀ (x : X), Membership.mem K x → Membership.mem (Min.min (nhds x) l) s\n⊢ Membership.mem (Min.min (nhdsSet K) l) s","decl":"/-- If `s : Set X` belongs to `𝓝 x ⊓ l` for all `x` from a compact set `K`,\nthen it belongs to `(𝓝ˢ K) ⊓ l`,\ni.e., there exist an open `U ⊇ K` and `T ∈ l` such that `U ∩ T ⊆ s`. -/\ntheorem IsCompact.mem_nhdsSet_inf_of_forall {K : Set X} {l : Filter X} {s : Set X}\n    (hK : IsCompact K) (hs : ∀ x ∈ K, s ∈ 𝓝 x ⊓ l) : s ∈ (𝓝ˢ K) ⊓ l :=\n  (hK.nhdsSet_inf_eq_biSup l).symm ▸ by simpa using hs\n\n"}
{"name":"IsCompact.mem_inf_nhdsSet_of_forall","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nK : Set X\nl : Filter X\ns : Set X\nhK : IsCompact K\nhs : ∀ (y : X), Membership.mem K y → Membership.mem (Min.min l (nhds y)) s\n⊢ Membership.mem (Min.min l (nhdsSet K)) s","decl":"/-- If `s : Set S` belongs to `l ⊓ 𝓝 x` for all `x` from a compact set `K`,\nthen it belongs to `l ⊓ (𝓝ˢ K)`,\ni.e., there exist `T ∈ l` and an open `U ⊇ K` such that `T ∩ U ⊆ s`. -/\ntheorem IsCompact.mem_inf_nhdsSet_of_forall {K : Set X} {l : Filter X} {s : Set X}\n    (hK : IsCompact K) (hs : ∀ y ∈ K, s ∈ l ⊓ 𝓝 y) : s ∈ l ⊓ 𝓝ˢ K :=\n  (hK.inf_nhdsSet_eq_biSup l).symm ▸ by simpa using hs\n\n"}
{"name":"IsCompact.eventually_forall_of_forall_eventually","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx₀ : X\nK : Set Y\nhK : IsCompact K\nP : X → Y → Prop\nhP : ∀ (y : Y), Membership.mem K y → Filter.Eventually (fun z => P z.1 z.2) (nhds { fst := x₀, snd := y })\n⊢ Filter.Eventually (fun x => ∀ (y : Y), Membership.mem K y → P x y) (nhds x₀)","decl":"/-- To show that `∀ y ∈ K, P x y` holds for `x` close enough to `x₀` when `K` is compact,\nit is sufficient to show that for all `y₀ ∈ K` there `P x y` holds for `(x, y)` close enough\nto `(x₀, y₀)`.\n\nProvided for backwards compatibility,\nsee `IsCompact.mem_prod_nhdsSet_of_forall` for a stronger statement.\n-/\ntheorem IsCompact.eventually_forall_of_forall_eventually {x₀ : X} {K : Set Y} (hK : IsCompact K)\n    {P : X → Y → Prop} (hP : ∀ y ∈ K, ∀ᶠ z : X × Y in 𝓝 (x₀, y), P z.1 z.2) :\n    ∀ᶠ x in 𝓝 x₀, ∀ y ∈ K, P x y := by\n  simp only [nhds_prod_eq, ← eventually_iSup, ← hK.prod_nhdsSet_eq_biSup] at hP\n  exact hP.curry.mono fun _ h ↦ h.self_of_nhdsSet\n\n"}
{"name":"isCompact_empty","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ IsCompact EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem isCompact_empty : IsCompact (∅ : Set X) := fun _f hnf hsf =>\n  Not.elim hnf.ne <| empty_mem_iff_bot.1 <| le_principal_iff.1 hsf\n\n"}
{"name":"isCompact_singleton","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx : X\n⊢ IsCompact (Singleton.singleton x)","decl":"@[simp]\ntheorem isCompact_singleton {x : X} : IsCompact ({x} : Set X) := fun _ hf hfa =>\n  ⟨x, rfl, ClusterPt.of_le_nhds'\n    (hfa.trans <| by simpa only [principal_singleton] using pure_le_nhds x) hf⟩\n\n"}
{"name":"Set.Subsingleton.isCompact","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : s.Subsingleton\n⊢ IsCompact s","decl":"theorem Set.Subsingleton.isCompact (hs : s.Subsingleton) : IsCompact s :=\n  Subsingleton.induction_on hs isCompact_empty fun _ => isCompact_singleton\n\n-- Porting note: golfed a proof instead of fixing it\n"}
{"name":"Set.Finite.isCompact_biUnion","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nι : Type u_1\ninst✝ : TopologicalSpace X\ns : Set ι\nf : ι → Set X\nhs : s.Finite\nhf : ∀ (i : ι), Membership.mem s i → IsCompact (f i)\n⊢ IsCompact (Set.iUnion fun i => Set.iUnion fun h => f i)","decl":"theorem Set.Finite.isCompact_biUnion {s : Set ι} {f : ι → Set X} (hs : s.Finite)\n    (hf : ∀ i ∈ s, IsCompact (f i)) : IsCompact (⋃ i ∈ s, f i) :=\n  isCompact_iff_ultrafilter_le_nhds'.2 fun l hl => by\n    rw [Ultrafilter.finite_biUnion_mem_iff hs] at hl\n    rcases hl with ⟨i, his, hi⟩\n    rcases (hf i his).ultrafilter_le_nhds _ (le_principal_iff.2 hi) with ⟨x, hxi, hlx⟩\n    exact ⟨x, mem_iUnion₂.2 ⟨i, his, hxi⟩, hlx⟩\n\n"}
{"name":"Finset.isCompact_biUnion","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nι : Type u_1\ninst✝ : TopologicalSpace X\ns : Finset ι\nf : ι → Set X\nhf : ∀ (i : ι), Membership.mem s i → IsCompact (f i)\n⊢ IsCompact (Set.iUnion fun i => Set.iUnion fun h => f i)","decl":"theorem Finset.isCompact_biUnion (s : Finset ι) {f : ι → Set X} (hf : ∀ i ∈ s, IsCompact (f i)) :\n    IsCompact (⋃ i ∈ s, f i) :=\n  s.finite_toSet.isCompact_biUnion hf\n\n"}
{"name":"isCompact_accumulate","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nK : Nat → Set X\nhK : ∀ (n : Nat), IsCompact (K n)\nn : Nat\n⊢ IsCompact (Set.Accumulate K n)","decl":"theorem isCompact_accumulate {K : ℕ → Set X} (hK : ∀ n, IsCompact (K n)) (n : ℕ) :\n    IsCompact (Accumulate K n) :=\n  (finite_le_nat n).isCompact_biUnion fun k _ => hK k\n\n"}
{"name":"Set.Finite.isCompact_sUnion","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nS : Set (Set X)\nhf : S.Finite\nhc : ∀ (s : Set X), Membership.mem S s → IsCompact s\n⊢ IsCompact S.sUnion","decl":"theorem Set.Finite.isCompact_sUnion {S : Set (Set X)} (hf : S.Finite) (hc : ∀ s ∈ S, IsCompact s) :\n    IsCompact (⋃₀ S) := by\n  rw [sUnion_eq_biUnion]; exact hf.isCompact_biUnion hc\n\n-- Porting note: generalized to `ι : Sort*`\n"}
{"name":"isCompact_iUnion","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\nι : Sort u_2\nf : ι → Set X\ninst✝ : Finite ι\nh : ∀ (i : ι), IsCompact (f i)\n⊢ IsCompact (Set.iUnion fun i => f i)","decl":"theorem isCompact_iUnion {ι : Sort*} {f : ι → Set X} [Finite ι] (h : ∀ i, IsCompact (f i)) :\n    IsCompact (⋃ i, f i) :=\n  (finite_range f).isCompact_sUnion <| forall_mem_range.2 h\n\n"}
{"name":"Set.Finite.isCompact","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : s.Finite\n⊢ IsCompact s","decl":"theorem Set.Finite.isCompact (hs : s.Finite) : IsCompact s :=\n  biUnion_of_singleton s ▸ hs.isCompact_biUnion fun _ _ => isCompact_singleton\n\n"}
{"name":"IsCompact.finite_of_discrete","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ns : Set X\ninst✝ : DiscreteTopology X\nhs : IsCompact s\n⊢ s.Finite","decl":"theorem IsCompact.finite_of_discrete [DiscreteTopology X] (hs : IsCompact s) : s.Finite := by\n  have : ∀ x : X, ({x} : Set X) ∈ 𝓝 x := by simp [nhds_discrete]\n  rcases hs.elim_nhds_subcover (fun x => {x}) fun x _ => this x with ⟨t, _, hst⟩\n  simp only [← t.set_biUnion_coe, biUnion_of_singleton] at hst\n  exact t.finite_toSet.subset hst\n\n"}
{"name":"isCompact_iff_finite","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ns : Set X\ninst✝ : DiscreteTopology X\n⊢ Iff (IsCompact s) s.Finite","decl":"theorem isCompact_iff_finite [DiscreteTopology X] : IsCompact s ↔ s.Finite :=\n  ⟨fun h => h.finite_of_discrete, fun h => h.isCompact⟩\n\n"}
{"name":"IsCompact.union","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns t : Set X\nhs : IsCompact s\nht : IsCompact t\n⊢ IsCompact (Union.union s t)","decl":"theorem IsCompact.union (hs : IsCompact s) (ht : IsCompact t) : IsCompact (s ∪ t) := by\n  rw [union_eq_iUnion]; exact isCompact_iUnion fun b => by cases b <;> assumption\n\n"}
{"name":"IsCompact.insert","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsCompact s\na : X\n⊢ IsCompact (Insert.insert a s)","decl":"protected theorem IsCompact.insert (hs : IsCompact s) (a) : IsCompact (insert a s) :=\n  isCompact_singleton.union hs\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: reformulate using `𝓝ˢ`\n"}
{"name":"exists_subset_nhds_of_isCompact'","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nι : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : Nonempty ι\nV : ι → Set X\nhV : Directed (fun x1 x2 => Superset x1 x2) V\nhV_cpct : ∀ (i : ι), IsCompact (V i)\nhV_closed : ∀ (i : ι), IsClosed (V i)\nU : Set X\nhU : ∀ (x : X), Membership.mem (Set.iInter fun i => V i) x → Membership.mem (nhds x) U\n⊢ Exists fun i => HasSubset.Subset (V i) U","decl":"/-- If `V : ι → Set X` is a decreasing family of closed compact sets then any neighborhood of\n`⋂ i, V i` contains some `V i`. We assume each `V i` is compact *and* closed because `X` is\nnot assumed to be Hausdorff. See `exists_subset_nhd_of_compact` for version assuming this. -/\ntheorem exists_subset_nhds_of_isCompact' [Nonempty ι] {V : ι → Set X}\n    (hV : Directed (· ⊇ ·) V) (hV_cpct : ∀ i, IsCompact (V i)) (hV_closed : ∀ i, IsClosed (V i))\n    {U : Set X} (hU : ∀ x ∈ ⋂ i, V i, U ∈ 𝓝 x) : ∃ i, V i ⊆ U := by\n  obtain ⟨W, hsubW, W_op, hWU⟩ := exists_open_set_nhds hU\n  suffices ∃ i, V i ⊆ W from this.imp fun i hi => hi.trans hWU\n  by_contra! H\n  replace H : ∀ i, (V i ∩ Wᶜ).Nonempty := fun i => Set.inter_compl_nonempty_iff.mpr (H i)\n  have : (⋂ i, V i ∩ Wᶜ).Nonempty := by\n    refine\n      IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed _ (fun i j => ?_) H\n        (fun i => (hV_cpct i).inter_right W_op.isClosed_compl) fun i =>\n        (hV_closed i).inter W_op.isClosed_compl\n    rcases hV i j with ⟨k, hki, hkj⟩\n    refine ⟨k, ⟨fun x => ?_, fun x => ?_⟩⟩ <;> simp only [and_imp, mem_inter_iff, mem_compl_iff] <;>\n      tauto\n  have : ¬⋂ i : ι, V i ⊆ W := by simpa [← iInter_inter, inter_compl_nonempty_iff]\n  contradiction\n\n"}
{"name":"eq_finite_iUnion_of_isTopologicalBasis_of_isCompact_open","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nι : Type u_1\ninst✝ : TopologicalSpace X\nb : ι → Set X\nhb : TopologicalSpace.IsTopologicalBasis (Set.range b)\nU : Set X\nhUc : IsCompact U\nhUo : IsOpen U\n⊢ Exists fun s => And s.Finite (Eq U (Set.iUnion fun i => Set.iUnion fun h => b i))","decl":"lemma eq_finite_iUnion_of_isTopologicalBasis_of_isCompact_open (b : ι → Set X)\n    (hb : IsTopologicalBasis (Set.range b)) (U : Set X) (hUc : IsCompact U) (hUo : IsOpen U) :\n    ∃ s : Set ι, s.Finite ∧ U = ⋃ i ∈ s, b i := by\n  obtain ⟨Y, f, e, hf⟩ := hb.open_eq_iUnion hUo\n  choose f' hf' using hf\n  have : b ∘ f' = f := funext hf'\n  subst this\n  obtain ⟨t, ht⟩ :=\n    hUc.elim_finite_subcover (b ∘ f') (fun i => hb.isOpen (Set.mem_range_self _)) (by rw [e])\n  classical\n  refine ⟨t.image f', Set.toFinite _, le_antisymm ?_ ?_⟩\n  · refine Set.Subset.trans ht ?_\n    simp only [Set.iUnion_subset_iff]\n    intro i hi\n    erw [← Set.iUnion_subtype (fun x : ι => x ∈ t.image f') fun i => b i.1]\n    exact Set.subset_iUnion (fun i : t.image f' => b i) ⟨_, Finset.mem_image_of_mem _ hi⟩\n  · apply Set.iUnion₂_subset\n    rintro i hi\n    obtain ⟨j, -, rfl⟩ := Finset.mem_image.mp hi\n    rw [e]\n    exact Set.subset_iUnion (b ∘ f') j\n\n"}
{"name":"eq_sUnion_finset_of_isTopologicalBasis_of_isCompact_open","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nb : Set (Set X)\nhb : TopologicalSpace.IsTopologicalBasis b\nU : Set X\nhUc : IsCompact U\nhUo : IsOpen U\n⊢ Exists fun s => Eq U (Set.image Subtype.val ↑s).sUnion","decl":"lemma eq_sUnion_finset_of_isTopologicalBasis_of_isCompact_open (b : Set (Set X))\n    (hb : IsTopologicalBasis b) (U : Set X) (hUc : IsCompact U) (hUo : IsOpen U) :\n    ∃ s : Finset b, U = s.toSet.sUnion := by\n  have hb' : b = range (fun i ↦ i : b → Set X) := by simp\n  rw [hb'] at hb\n  choose s hs hU using eq_finite_iUnion_of_isTopologicalBasis_of_isCompact_open _ hb U hUc hUo\n  have : Finite s := hs\n  let _ : Fintype s := Fintype.ofFinite _\n  use s.toFinset\n  simp [hU]\n\n"}
{"name":"isCompact_open_iff_eq_finite_iUnion_of_isTopologicalBasis","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nι : Type u_1\ninst✝ : TopologicalSpace X\nb : ι → Set X\nhb : TopologicalSpace.IsTopologicalBasis (Set.range b)\nhb' : ∀ (i : ι), IsCompact (b i)\nU : Set X\n⊢ Iff (And (IsCompact U) (IsOpen U)) (Exists fun s => And s.Finite (Eq U (Set.iUnion fun i => Set.iUnion fun h => b i)))","decl":"/-- If `X` has a basis consisting of compact opens, then an open set in `X` is compact open iff\n  it is a finite union of some elements in the basis -/\ntheorem isCompact_open_iff_eq_finite_iUnion_of_isTopologicalBasis (b : ι → Set X)\n    (hb : IsTopologicalBasis (Set.range b)) (hb' : ∀ i, IsCompact (b i)) (U : Set X) :\n    IsCompact U ∧ IsOpen U ↔ ∃ s : Set ι, s.Finite ∧ U = ⋃ i ∈ s, b i := by\n  constructor\n  · exact fun ⟨h₁, h₂⟩ ↦ eq_finite_iUnion_of_isTopologicalBasis_of_isCompact_open _ hb U h₁ h₂\n  · rintro ⟨s, hs, rfl⟩\n    constructor\n    · exact hs.isCompact_biUnion fun i _ => hb' i\n    · exact isOpen_biUnion fun i _ => hb.isOpen (Set.mem_range_self _)\n\n"}
{"name":"Filter.hasBasis_cocompact","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ (Filter.cocompact X).HasBasis IsCompact HasCompl.compl","decl":"theorem hasBasis_cocompact : (cocompact X).HasBasis IsCompact compl :=\n  hasBasis_biInf_principal'\n    (fun s hs t ht =>\n      ⟨s ∪ t, hs.union ht, compl_subset_compl.2 subset_union_left,\n        compl_subset_compl.2 subset_union_right⟩)\n    ⟨∅, isCompact_empty⟩\n\n"}
{"name":"Filter.mem_cocompact","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (Membership.mem (Filter.cocompact X) s) (Exists fun t => And (IsCompact t) (HasSubset.Subset (HasCompl.compl t) s))","decl":"theorem mem_cocompact : s ∈ cocompact X ↔ ∃ t, IsCompact t ∧ tᶜ ⊆ s :=\n  hasBasis_cocompact.mem_iff\n\n"}
{"name":"Filter.mem_cocompact'","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (Membership.mem (Filter.cocompact X) s) (Exists fun t => And (IsCompact t) (HasSubset.Subset (HasCompl.compl s) t))","decl":"theorem mem_cocompact' : s ∈ cocompact X ↔ ∃ t, IsCompact t ∧ sᶜ ⊆ t :=\n  mem_cocompact.trans <| exists_congr fun _ => and_congr_right fun _ => compl_subset_comm\n\n"}
{"name":"IsCompact.compl_mem_cocompact","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsCompact s\n⊢ Membership.mem (Filter.cocompact X) (HasCompl.compl s)","decl":"theorem _root_.IsCompact.compl_mem_cocompact (hs : IsCompact s) : sᶜ ∈ Filter.cocompact X :=\n  hasBasis_cocompact.mem_of_mem hs\n\n"}
{"name":"Filter.cocompact_le_cofinite","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ LE.le (Filter.cocompact X) Filter.cofinite","decl":"theorem cocompact_le_cofinite : cocompact X ≤ cofinite := fun s hs =>\n  compl_compl s ▸ hs.isCompact.compl_mem_cocompact\n\n"}
{"name":"Filter.cocompact_eq_cofinite","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : DiscreteTopology X\n⊢ Eq (Filter.cocompact X) Filter.cofinite","decl":"theorem cocompact_eq_cofinite (X : Type*) [TopologicalSpace X] [DiscreteTopology X] :\n    cocompact X = cofinite := by\n  simp only [cocompact, hasBasis_cofinite.eq_biInf, isCompact_iff_finite]\n\n"}
{"name":"Filter.disjoint_cocompact_left","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nf : Filter X\n⊢ Iff (Disjoint (Filter.cocompact X) f) (Exists fun K => And (Membership.mem f K) (IsCompact K))","decl":"/-- A filter is disjoint from the cocompact filter if and only if it contains a compact set. -/\ntheorem disjoint_cocompact_left (f : Filter X) :\n    Disjoint (Filter.cocompact X) f ↔ ∃ K ∈ f, IsCompact K := by\n  simp_rw [hasBasis_cocompact.disjoint_iff_left, compl_compl]\n  tauto\n\n"}
{"name":"Filter.disjoint_cocompact_right","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nf : Filter X\n⊢ Iff (Disjoint f (Filter.cocompact X)) (Exists fun K => And (Membership.mem f K) (IsCompact K))","decl":"/-- A filter is disjoint from the cocompact filter if and only if it contains a compact set. -/\ntheorem disjoint_cocompact_right (f : Filter X) :\n    Disjoint f (Filter.cocompact X) ↔ ∃ K ∈ f, IsCompact K := by\n  simp_rw [hasBasis_cocompact.disjoint_iff_right, compl_compl]\n  tauto\n\n"}
{"name":"Filter.Tendsto.isCompact_insert_range_of_cocompact","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\ny : Y\nhf : Filter.Tendsto f (Filter.cocompact X) (nhds y)\nhfc : Continuous f\n⊢ IsCompact (Insert.insert y (Set.range f))","decl":"theorem Tendsto.isCompact_insert_range_of_cocompact {f : X → Y} {y}\n    (hf : Tendsto f (cocompact X) (𝓝 y)) (hfc : Continuous f) : IsCompact (insert y (range f)) := by\n  intro l hne hle\n  by_cases hy : ClusterPt y l\n  · exact ⟨y, Or.inl rfl, hy⟩\n  simp only [clusterPt_iff, not_forall, ← not_disjoint_iff_nonempty_inter, not_not] at hy\n  rcases hy with ⟨s, hsy, t, htl, hd⟩\n  rcases mem_cocompact.1 (hf hsy) with ⟨K, hKc, hKs⟩\n  have : f '' K ∈ l := by\n    filter_upwards [htl, le_principal_iff.1 hle] with y hyt hyf\n    rcases hyf with (rfl | ⟨x, rfl⟩)\n    exacts [(hd.le_bot ⟨mem_of_mem_nhds hsy, hyt⟩).elim,\n      mem_image_of_mem _ (not_not.1 fun hxK => hd.le_bot ⟨hKs hxK, hyt⟩)]\n  rcases hKc.image hfc (le_principal_iff.2 this) with ⟨y, hy, hyl⟩\n  exact ⟨y, Or.inr <| image_subset_range _ _ hy, hyl⟩\n\n"}
{"name":"Filter.Tendsto.isCompact_insert_range_of_cofinite","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nι : Type u_1\ninst✝ : TopologicalSpace X\nf : ι → X\nx : X\nhf : Filter.Tendsto f Filter.cofinite (nhds x)\n⊢ IsCompact (Insert.insert x (Set.range f))","decl":"theorem Tendsto.isCompact_insert_range_of_cofinite {f : ι → X} {x} (hf : Tendsto f cofinite (𝓝 x)) :\n    IsCompact (insert x (range f)) := by\n  letI : TopologicalSpace ι := ⊥; haveI h : DiscreteTopology ι := ⟨rfl⟩\n  rw [← cocompact_eq_cofinite ι] at hf\n  exact hf.isCompact_insert_range_of_cocompact continuous_of_discreteTopology\n\n"}
{"name":"Filter.Tendsto.isCompact_insert_range","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nf : Nat → X\nx : X\nhf : Filter.Tendsto f Filter.atTop (nhds x)\n⊢ IsCompact (Insert.insert x (Set.range f))","decl":"theorem Tendsto.isCompact_insert_range {f : ℕ → X} {x} (hf : Tendsto f atTop (𝓝 x)) :\n    IsCompact (insert x (range f)) :=\n  Filter.Tendsto.isCompact_insert_range_of_cofinite <| Nat.cofinite_eq_atTop.symm ▸ hf\n\n"}
{"name":"Filter.hasBasis_coclosedCompact","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ (Filter.coclosedCompact X).HasBasis (fun s => And (IsClosed s) (IsCompact s)) HasCompl.compl","decl":"theorem hasBasis_coclosedCompact :\n    (Filter.coclosedCompact X).HasBasis (fun s => IsClosed s ∧ IsCompact s) compl := by\n  simp only [Filter.coclosedCompact, iInf_and']\n  refine hasBasis_biInf_principal' ?_ ⟨∅, isClosed_empty, isCompact_empty⟩\n  rintro s ⟨hs₁, hs₂⟩ t ⟨ht₁, ht₂⟩\n  exact ⟨s ∪ t, ⟨⟨hs₁.union ht₁, hs₂.union ht₂⟩, compl_subset_compl.2 subset_union_left,\n    compl_subset_compl.2 subset_union_right⟩⟩\n\n"}
{"name":"Filter.mem_coclosedCompact_iff","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (Membership.mem (Filter.coclosedCompact X) s) (IsCompact (closure (HasCompl.compl s)))","decl":"/-- A set belongs to `coclosedCompact` if and only if the closure of its complement is compact. -/\ntheorem mem_coclosedCompact_iff :\n    s ∈ coclosedCompact X ↔ IsCompact (closure sᶜ) := by\n  refine hasBasis_coclosedCompact.mem_iff.trans ⟨?_, fun h ↦ ?_⟩\n  · rintro ⟨t, ⟨htcl, htco⟩, hst⟩\n    exact htco.of_isClosed_subset isClosed_closure <|\n      closure_minimal (compl_subset_comm.2 hst) htcl\n  · exact ⟨closure sᶜ, ⟨isClosed_closure, h⟩, compl_subset_comm.2 subset_closure⟩\n\n"}
{"name":"Filter.compl_mem_coclosedCompact","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (Membership.mem (Filter.coclosedCompact X) (HasCompl.compl s)) (IsCompact (closure s))","decl":"/-- Complement of a set belongs to `coclosedCompact` if and only if its closure is compact. -/\ntheorem compl_mem_coclosedCompact : sᶜ ∈ coclosedCompact X ↔ IsCompact (closure s) := by\n  rw [mem_coclosedCompact_iff, compl_compl]\n\n"}
{"name":"Filter.cocompact_le_coclosedCompact","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ LE.le (Filter.cocompact X) (Filter.coclosedCompact X)","decl":"theorem cocompact_le_coclosedCompact : cocompact X ≤ coclosedCompact X :=\n  iInf_mono fun _ => le_iInf fun _ => le_rfl\n\n"}
{"name":"IsCompact.compl_mem_coclosedCompact_of_isClosed","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsCompact s\nhs' : IsClosed s\n⊢ Membership.mem (Filter.coclosedCompact X) (HasCompl.compl s)","decl":"theorem IsCompact.compl_mem_coclosedCompact_of_isClosed (hs : IsCompact s) (hs' : IsClosed s) :\n    sᶜ ∈ Filter.coclosedCompact X :=\n  hasBasis_coclosedCompact.mem_of_mem ⟨hs', hs⟩\n\n"}
{"name":"Bornology.inCompact.isBounded_iff","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (Bornology.IsBounded s) (Exists fun t => And (IsCompact t) (HasSubset.Subset s t))","decl":"theorem inCompact.isBounded_iff : @IsBounded _ (inCompact X) s ↔ ∃ t, IsCompact t ∧ s ⊆ t := by\n  change sᶜ ∈ Filter.cocompact X ↔ _\n  rw [Filter.mem_cocompact]\n  simp\n\n"}
{"name":"IsCompact.nhdsSet_prod_eq","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nt : Set Y\nhs : IsCompact s\nht : IsCompact t\n⊢ Eq (nhdsSet (SProd.sprod s t)) (SProd.sprod (nhdsSet s) (nhdsSet t))","decl":"/-- If `s` and `t` are compact sets, then the set neighborhoods filter of `s ×ˢ t`\nis the product of set neighborhoods filters for `s` and `t`.\n\nFor general sets, only the `≤` inequality holds, see `nhdsSet_prod_le`. -/\ntheorem IsCompact.nhdsSet_prod_eq {t : Set Y} (hs : IsCompact s) (ht : IsCompact t) :\n    𝓝ˢ (s ×ˢ t) = 𝓝ˢ s ×ˢ 𝓝ˢ t := by\n  simp_rw [hs.nhdsSet_prod_eq_biSup, ht.prod_nhdsSet_eq_biSup, nhdsSet, sSup_image, biSup_prod,\n    nhds_prod_eq]\n\n"}
{"name":"nhdsSet_prod_le_of_disjoint_cocompact","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nf : Filter Y\nhs : IsCompact s\nhf : Disjoint f (Filter.cocompact Y)\n⊢ LE.le (SProd.sprod (nhdsSet s) f) (nhdsSet (SProd.sprod s Set.univ))","decl":"theorem nhdsSet_prod_le_of_disjoint_cocompact {f : Filter Y} (hs : IsCompact s)\n    (hf : Disjoint f (Filter.cocompact Y)) :\n    𝓝ˢ s ×ˢ f ≤ 𝓝ˢ (s ×ˢ Set.univ) := by\n  obtain ⟨K, hKf, hK⟩ := (disjoint_cocompact_right f).mp hf\n  calc\n    𝓝ˢ s ×ˢ f\n    _ ≤ 𝓝ˢ s ×ˢ 𝓟 K        := Filter.prod_mono_right _ (Filter.le_principal_iff.mpr hKf)\n    _ ≤ 𝓝ˢ s ×ˢ 𝓝ˢ K       := Filter.prod_mono_right _ principal_le_nhdsSet\n    _ = 𝓝ˢ (s ×ˢ K)         := (hs.nhdsSet_prod_eq hK).symm\n    _ ≤ 𝓝ˢ (s ×ˢ Set.univ)  := nhdsSet_mono (prod_mono_right le_top)\n\n"}
{"name":"prod_nhdsSet_le_of_disjoint_cocompact","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nt : Set Y\nf : Filter X\nht : IsCompact t\nhf : Disjoint f (Filter.cocompact X)\n⊢ LE.le (SProd.sprod f (nhdsSet t)) (nhdsSet (SProd.sprod Set.univ t))","decl":"theorem prod_nhdsSet_le_of_disjoint_cocompact {t : Set Y} {f : Filter X} (ht : IsCompact t)\n    (hf : Disjoint f (Filter.cocompact X)) :\n    f ×ˢ 𝓝ˢ t ≤ 𝓝ˢ (Set.univ ×ˢ t) := by\n  obtain ⟨K, hKf, hK⟩ := (disjoint_cocompact_right f).mp hf\n  calc\n    f ×ˢ 𝓝ˢ t\n    _ ≤ (𝓟 K) ×ˢ 𝓝ˢ t      := Filter.prod_mono_left _ (Filter.le_principal_iff.mpr hKf)\n    _ ≤ 𝓝ˢ K ×ˢ 𝓝ˢ t       := Filter.prod_mono_left _ principal_le_nhdsSet\n    _ = 𝓝ˢ (K ×ˢ t)         := (hK.nhdsSet_prod_eq ht).symm\n    _ ≤ 𝓝ˢ (Set.univ ×ˢ t)  := nhdsSet_mono (prod_mono_left le_top)\n\n"}
{"name":"nhds_prod_le_of_disjoint_cocompact","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : Filter Y\nx : X\nhf : Disjoint f (Filter.cocompact Y)\n⊢ LE.le (SProd.sprod (nhds x) f) (nhdsSet (SProd.sprod (Singleton.singleton x) Set.univ))","decl":"theorem nhds_prod_le_of_disjoint_cocompact {f : Filter Y} (x : X)\n    (hf : Disjoint f (Filter.cocompact Y)) :\n    𝓝 x ×ˢ f ≤ 𝓝ˢ ({x} ×ˢ Set.univ) := by\n  simpa using nhdsSet_prod_le_of_disjoint_cocompact isCompact_singleton hf\n\n"}
{"name":"prod_nhds_le_of_disjoint_cocompact","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : Filter X\ny : Y\nhf : Disjoint f (Filter.cocompact X)\n⊢ LE.le (SProd.sprod f (nhds y)) (nhdsSet (SProd.sprod Set.univ (Singleton.singleton y)))","decl":"theorem prod_nhds_le_of_disjoint_cocompact {f : Filter X} (y : Y)\n    (hf : Disjoint f (Filter.cocompact X)) :\n    f ×ˢ 𝓝 y ≤ 𝓝ˢ (Set.univ ×ˢ {y}) := by\n  simpa using prod_nhdsSet_le_of_disjoint_cocompact isCompact_singleton hf\n\n"}
{"name":"generalized_tube_lemma","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nhs : IsCompact s\nt : Set Y\nht : IsCompact t\nn : Set (Prod X Y)\nhn : IsOpen n\nhp : HasSubset.Subset (SProd.sprod s t) n\n⊢ Exists fun u => Exists fun v => And (IsOpen u) (And (IsOpen v) (And (HasSubset.Subset s u) (And (HasSubset.Subset t v) (HasSubset.Subset (SProd.sprod u v) n))))","decl":"/-- If `s` and `t` are compact sets and `n` is an open neighborhood of `s × t`, then there exist\nopen neighborhoods `u ⊇ s` and `v ⊇ t` such that `u × v ⊆ n`.\n\nSee also `IsCompact.nhdsSet_prod_eq`. -/\ntheorem generalized_tube_lemma (hs : IsCompact s) {t : Set Y} (ht : IsCompact t)\n    {n : Set (X × Y)} (hn : IsOpen n) (hp : s ×ˢ t ⊆ n) :\n    ∃ (u : Set X) (v : Set Y), IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ u ×ˢ v ⊆ n := by\n  rw [← hn.mem_nhdsSet, hs.nhdsSet_prod_eq ht,\n    ((hasBasis_nhdsSet _).prod (hasBasis_nhdsSet _)).mem_iff] at hp\n  rcases hp with ⟨⟨u, v⟩, ⟨⟨huo, hsu⟩, hvo, htv⟩, hn⟩\n  exact ⟨u, v, huo, hvo, hsu, htv, hn⟩\n\n-- see Note [lower instance priority]\n"}
{"name":"Subsingleton.compactSpace","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : Subsingleton X\n⊢ CompactSpace X","decl":"instance (priority := 10) Subsingleton.compactSpace [Subsingleton X] : CompactSpace X :=\n  ⟨subsingleton_univ.isCompact⟩\n\n"}
{"name":"isCompact_univ_iff","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ Iff (IsCompact Set.univ) (CompactSpace X)","decl":"theorem isCompact_univ_iff : IsCompact (univ : Set X) ↔ CompactSpace X :=\n  ⟨fun h => ⟨h⟩, fun h => h.1⟩\n\n"}
{"name":"isCompact_univ","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nh : CompactSpace X\n⊢ IsCompact Set.univ","decl":"theorem isCompact_univ [h : CompactSpace X] : IsCompact (univ : Set X) :=\n  h.isCompact_univ\n\n"}
{"name":"exists_clusterPt_of_compactSpace","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝² : TopologicalSpace X\ninst✝¹ : CompactSpace X\nf : Filter X\ninst✝ : f.NeBot\n⊢ Exists fun x => ClusterPt x f","decl":"theorem exists_clusterPt_of_compactSpace [CompactSpace X] (f : Filter X) [NeBot f] :\n    ∃ x, ClusterPt x f := by\n  simpa using isCompact_univ (show f ≤ 𝓟 univ by simp)\n\n"}
{"name":"Ultrafilter.le_nhds_lim","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : CompactSpace X\nF : Ultrafilter X\n⊢ LE.le (↑F) (nhds F.lim)","decl":"nonrec theorem Ultrafilter.le_nhds_lim [CompactSpace X] (F : Ultrafilter X) : ↑F ≤ 𝓝 F.lim := by\n  rcases isCompact_univ.ultrafilter_le_nhds F (by simp) with ⟨x, -, h⟩\n  exact le_nhds_lim ⟨x, h⟩\n\n"}
{"name":"CompactSpace.elim_nhds_subcover","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : CompactSpace X\nU : X → Set X\nhU : ∀ (x : X), Membership.mem (nhds x) (U x)\n⊢ Exists fun t => Eq (Set.iUnion fun x => Set.iUnion fun h => U x) Top.top","decl":"theorem CompactSpace.elim_nhds_subcover [CompactSpace X] (U : X → Set X) (hU : ∀ x, U x ∈ 𝓝 x) :\n    ∃ t : Finset X, ⋃ x ∈ t, U x = ⊤ := by\n  obtain ⟨t, -, s⟩ := IsCompact.elim_nhds_subcover isCompact_univ U fun x _ => hU x\n  exact ⟨t, top_unique s⟩\n\n"}
{"name":"compactSpace_of_finite_subfamily_closed","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nh : ∀ {ι : Type u} (t : ι → Set X), (∀ (i : ι), IsClosed (t i)) → Eq (Set.iInter fun i => t i) EmptyCollection.emptyCollection → Exists fun u => Eq (Set.iInter fun i => Set.iInter fun h => t i) EmptyCollection.emptyCollection\n⊢ CompactSpace X","decl":"theorem compactSpace_of_finite_subfamily_closed\n    (h : ∀ {ι : Type u} (t : ι → Set X), (∀ i, IsClosed (t i)) → ⋂ i, t i = ∅ →\n      ∃ u : Finset ι, ⋂ i ∈ u, t i = ∅) :\n    CompactSpace X where\n  isCompact_univ := isCompact_of_finite_subfamily_closed fun t => by simpa using h t\n\n"}
{"name":"IsClosed.isCompact","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ns : Set X\ninst✝ : CompactSpace X\nh : IsClosed s\n⊢ IsCompact s","decl":"theorem IsClosed.isCompact [CompactSpace X] (h : IsClosed s) : IsCompact s :=\n  isCompact_univ.of_isClosed_subset h (subset_univ _)\n\n"}
{"name":"le_nhds_of_unique_clusterPt","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : CompactSpace X\nl : Filter X\ny : X\nh : ∀ (x : X), ClusterPt x l → Eq x y\n⊢ LE.le l (nhds y)","decl":"/-- If a filter has a unique cluster point `y` in a compact topological space,\nthen the filter is less than or equal to `𝓝 y`. -/\nlemma le_nhds_of_unique_clusterPt [CompactSpace X] {l : Filter X} {y : X}\n    (h : ∀ x, ClusterPt x l → x = y) : l ≤ 𝓝 y :=\n  isCompact_univ.le_nhds_of_unique_clusterPt univ_mem fun x _ ↦ h x\n\n"}
{"name":"tendsto_nhds_of_unique_mapClusterPt","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : CompactSpace X\nY : Type u_2\nl : Filter Y\ny : X\nf : Y → X\nh : ∀ (x : X), MapClusterPt x l f → Eq x y\n⊢ Filter.Tendsto f l (nhds y)","decl":"/-- If `y` is a unique `MapClusterPt` for `f` along `l`\nand the codomain of `f` is a compact space,\nthen `f` tends to `𝓝 y` along `l`. -/\nlemma tendsto_nhds_of_unique_mapClusterPt [CompactSpace X] {Y} {l : Filter Y} {y : X} {f : Y → X}\n    (h : ∀ x, MapClusterPt x l f → x = y) :\n    Tendsto f l (𝓝 y) :=\n  le_nhds_of_unique_clusterPt h\n\n-- Porting note: a lemma instead of `export` to make `X` explicit\n"}
{"name":"noncompact_univ","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : NoncompactSpace X\n⊢ Not (IsCompact Set.univ)","decl":"lemma noncompact_univ (X : Type*) [TopologicalSpace X] [NoncompactSpace X] :\n    ¬IsCompact (univ : Set X) :=\n  NoncompactSpace.noncompact_univ\n\n"}
{"name":"IsCompact.ne_univ","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ns : Set X\ninst✝ : NoncompactSpace X\nhs : IsCompact s\n⊢ Ne s Set.univ","decl":"theorem IsCompact.ne_univ [NoncompactSpace X] (hs : IsCompact s) : s ≠ univ := fun h =>\n  noncompact_univ X (h ▸ hs)\n\n"}
{"name":"instNeBotCocompactOfNoncompactSpace","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : NoncompactSpace X\n⊢ (Filter.cocompact X).NeBot","decl":"instance [NoncompactSpace X] : NeBot (Filter.cocompact X) := by\n  refine Filter.hasBasis_cocompact.neBot_iff.2 fun hs => ?_\n  contrapose hs; rw [not_nonempty_iff_eq_empty, compl_empty_iff] at hs\n  rw [hs]; exact noncompact_univ X\n\n"}
{"name":"Filter.cocompact_eq_bot","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : CompactSpace X\n⊢ Eq (Filter.cocompact X) Bot.bot","decl":"@[simp]\ntheorem Filter.cocompact_eq_bot [CompactSpace X] : Filter.cocompact X = ⊥ :=\n  Filter.hasBasis_cocompact.eq_bot_iff.mpr ⟨Set.univ, isCompact_univ, Set.compl_univ⟩\n\n"}
{"name":"instNeBotCoclosedCompactOfNoncompactSpace","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : NoncompactSpace X\n⊢ (Filter.coclosedCompact X).NeBot","decl":"instance [NoncompactSpace X] : NeBot (Filter.coclosedCompact X) :=\n  neBot_of_le Filter.cocompact_le_coclosedCompact\n\n"}
{"name":"noncompactSpace_of_neBot","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx✝ : (Filter.cocompact X).NeBot\n⊢ NoncompactSpace X","decl":"theorem noncompactSpace_of_neBot (_ : NeBot (Filter.cocompact X)) : NoncompactSpace X :=\n  ⟨fun h' => (Filter.nonempty_of_mem h'.compl_mem_cocompact).ne_empty compl_univ⟩\n\n"}
{"name":"Filter.cocompact_neBot_iff","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ Iff (Filter.cocompact X).NeBot (NoncompactSpace X)","decl":"theorem Filter.cocompact_neBot_iff : NeBot (Filter.cocompact X) ↔ NoncompactSpace X :=\n  ⟨noncompactSpace_of_neBot, fun _ => inferInstance⟩\n\n"}
{"name":"not_compactSpace_iff","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ Iff (Not (CompactSpace X)) (NoncompactSpace X)","decl":"theorem not_compactSpace_iff : ¬CompactSpace X ↔ NoncompactSpace X :=\n  ⟨fun h₁ => ⟨fun h₂ => h₁ ⟨h₂⟩⟩, fun ⟨h₁⟩ ⟨h₂⟩ => h₁ h₂⟩\n\n"}
{"name":"instNoncompactSpaceInt","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"⊢ NoncompactSpace Int","decl":"instance : NoncompactSpace ℤ :=\n  noncompactSpace_of_neBot <| by simp only [Filter.cocompact_eq_cofinite, Filter.cofinite_neBot]\n\n-- Note: We can't make this into an instance because it loops with `Finite.compactSpace`.\n"}
{"name":"finite_of_compact_of_discrete","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝² : TopologicalSpace X\ninst✝¹ : CompactSpace X\ninst✝ : DiscreteTopology X\n⊢ Finite X","decl":"/-- A compact discrete space is finite. -/\ntheorem finite_of_compact_of_discrete [CompactSpace X] [DiscreteTopology X] : Finite X :=\n  Finite.of_finite_univ <| isCompact_univ.finite_of_discrete\n\n"}
{"name":"Set.Infinite.exists_accPt_cofinite_inf_principal_of_subset_isCompact","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns K : Set X\nhs : s.Infinite\nhK : IsCompact K\nhsub : HasSubset.Subset s K\n⊢ Exists fun x => And (Membership.mem K x) (AccPt x (Min.min Filter.cofinite (Filter.principal s)))","decl":"lemma Set.Infinite.exists_accPt_cofinite_inf_principal_of_subset_isCompact\n    {K : Set X} (hs : s.Infinite) (hK : IsCompact K) (hsub : s ⊆ K) :\n    ∃ x ∈ K, AccPt x (cofinite ⊓ 𝓟 s) :=\n  (@hK _ hs.cofinite_inf_principal_neBot (inf_le_right.trans <| principal_mono.2 hsub)).imp\n    fun x hx ↦ by rwa [acc_iff_cluster, inf_comm, inf_right_comm,\n      (finite_singleton _).cofinite_inf_principal_compl]\n\n"}
{"name":"Set.Infinite.exists_accPt_of_subset_isCompact","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns K : Set X\nhs : s.Infinite\nhK : IsCompact K\nhsub : HasSubset.Subset s K\n⊢ Exists fun x => And (Membership.mem K x) (AccPt x (Filter.principal s))","decl":"lemma Set.Infinite.exists_accPt_of_subset_isCompact {K : Set X} (hs : s.Infinite)\n    (hK : IsCompact K) (hsub : s ⊆ K) : ∃ x ∈ K, AccPt x (𝓟 s) :=\n  let ⟨x, hxK, hx⟩ := hs.exists_accPt_cofinite_inf_principal_of_subset_isCompact hK hsub\n  ⟨x, hxK, hx.mono inf_le_right⟩\n\n"}
{"name":"Set.Infinite.exists_accPt_cofinite_inf_principal","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ns : Set X\ninst✝ : CompactSpace X\nhs : s.Infinite\n⊢ Exists fun x => AccPt x (Min.min Filter.cofinite (Filter.principal s))","decl":"lemma Set.Infinite.exists_accPt_cofinite_inf_principal [CompactSpace X] (hs : s.Infinite) :\n    ∃ x, AccPt x (cofinite ⊓ 𝓟 s) := by\n  simpa only [mem_univ, true_and]\n    using hs.exists_accPt_cofinite_inf_principal_of_subset_isCompact isCompact_univ s.subset_univ\n\n"}
{"name":"Set.Infinite.exists_accPt_principal","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ns : Set X\ninst✝ : CompactSpace X\nhs : s.Infinite\n⊢ Exists fun x => AccPt x (Filter.principal s)","decl":"lemma Set.Infinite.exists_accPt_principal [CompactSpace X] (hs : s.Infinite) : ∃ x, AccPt x (𝓟 s) :=\n  hs.exists_accPt_cofinite_inf_principal.imp fun _x hx ↦ hx.mono inf_le_right\n\n"}
{"name":"exists_nhds_ne_neBot","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : CompactSpace X\ninst✝ : Infinite X\n⊢ Exists fun z => (nhdsWithin z (HasCompl.compl (Singleton.singleton z))).NeBot","decl":"theorem exists_nhds_ne_neBot (X : Type*) [TopologicalSpace X] [CompactSpace X] [Infinite X] :\n    ∃ z : X, (𝓝[≠] z).NeBot := by\n  simpa [AccPt] using (@infinite_univ X _).exists_accPt_principal\n\n"}
{"name":"finite_cover_nhds_interior","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : CompactSpace X\nU : X → Set X\nhU : ∀ (x : X), Membership.mem (nhds x) (U x)\n⊢ Exists fun t => Eq (Set.iUnion fun x => Set.iUnion fun h => interior (U x)) Set.univ","decl":"theorem finite_cover_nhds_interior [CompactSpace X] {U : X → Set X} (hU : ∀ x, U x ∈ 𝓝 x) :\n    ∃ t : Finset X, ⋃ x ∈ t, interior (U x) = univ :=\n  let ⟨t, ht⟩ := isCompact_univ.elim_finite_subcover (fun x => interior (U x))\n    (fun _ => isOpen_interior) fun x _ => mem_iUnion.2 ⟨x, mem_interior_iff_mem_nhds.2 (hU x)⟩\n  ⟨t, univ_subset_iff.1 ht⟩\n\n"}
{"name":"finite_cover_nhds","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : CompactSpace X\nU : X → Set X\nhU : ∀ (x : X), Membership.mem (nhds x) (U x)\n⊢ Exists fun t => Eq (Set.iUnion fun x => Set.iUnion fun h => U x) Set.univ","decl":"theorem finite_cover_nhds [CompactSpace X] {U : X → Set X} (hU : ∀ x, U x ∈ 𝓝 x) :\n    ∃ t : Finset X, ⋃ x ∈ t, U x = univ :=\n  let ⟨t, ht⟩ := finite_cover_nhds_interior hU\n  ⟨t, univ_subset_iff.1 <| ht.symm.subset.trans <| iUnion₂_mono fun _ _ => interior_subset⟩\n\n"}
{"name":"LocallyFinite.finite_nonempty_of_compact","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nι : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : CompactSpace X\nf : ι → Set X\nhf : LocallyFinite f\n⊢ (setOf fun i => (f i).Nonempty).Finite","decl":"/-- If `X` is a compact space, then a locally finite family of sets of `X` can have only finitely\nmany nonempty elements. -/\ntheorem LocallyFinite.finite_nonempty_of_compact [CompactSpace X] {f : ι → Set X}\n    (hf : LocallyFinite f) : { i | (f i).Nonempty }.Finite := by\n  simpa only [inter_univ] using hf.finite_nonempty_inter_compact isCompact_univ\n\n"}
{"name":"LocallyFinite.finite_of_compact","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nι : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : CompactSpace X\nf : ι → Set X\nhf : LocallyFinite f\nhne : ∀ (i : ι), (f i).Nonempty\n⊢ Set.univ.Finite","decl":"/-- If `X` is a compact space, then a locally finite family of nonempty sets of `X` can have only\nfinitely many elements, `Set.Finite` version. -/\ntheorem LocallyFinite.finite_of_compact [CompactSpace X] {f : ι → Set X}\n    (hf : LocallyFinite f) (hne : ∀ i, (f i).Nonempty) : (univ : Set ι).Finite := by\n  simpa only [hne] using hf.finite_nonempty_of_compact\n\n"}
{"name":"Filter.comap_cocompact_le","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Continuous f\n⊢ LE.le (Filter.comap f (Filter.cocompact Y)) (Filter.cocompact X)","decl":"/-- The comap of the cocompact filter on `Y` by a continuous function `f : X → Y` is less than or\nequal to the cocompact filter on `X`.\nThis is a reformulation of the fact that images of compact sets are compact. -/\ntheorem Filter.comap_cocompact_le {f : X → Y} (hf : Continuous f) :\n    (Filter.cocompact Y).comap f ≤ Filter.cocompact X := by\n  rw [(Filter.hasBasis_cocompact.comap f).le_basis_iff Filter.hasBasis_cocompact]\n  intro t ht\n  refine ⟨f '' t, ht.image hf, ?_⟩\n  simpa using t.subset_preimage_image f\n\n"}
{"name":"disjoint_map_cocompact","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ng : X → Y\nf : Filter X\nhg : Continuous g\nhf : Disjoint f (Filter.cocompact X)\n⊢ Disjoint (Filter.map g f) (Filter.cocompact Y)","decl":"/-- If a filter is disjoint from the cocompact filter, so is its image under any continuous\nfunction. -/\ntheorem disjoint_map_cocompact {g : X → Y} {f : Filter X} (hg : Continuous g)\n    (hf : Disjoint f (Filter.cocompact X)) : Disjoint (map g f) (Filter.cocompact Y) := by\n  rw [← Filter.disjoint_comap_iff_map, disjoint_iff_inf_le]\n  calc\n    f ⊓ (comap g (cocompact Y))\n    _ ≤ f ⊓ Filter.cocompact X := inf_le_inf_left f (Filter.comap_cocompact_le hg)\n    _ = ⊥ := disjoint_iff.mp hf\n\n"}
{"name":"isCompact_range","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : CompactSpace X\nf : X → Y\nhf : Continuous f\n⊢ IsCompact (Set.range f)","decl":"theorem isCompact_range [CompactSpace X] {f : X → Y} (hf : Continuous f) : IsCompact (range f) := by\n  rw [← image_univ]; exact isCompact_univ.image hf\n\n"}
{"name":"isCompact_diagonal","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : CompactSpace X\n⊢ IsCompact (Set.diagonal X)","decl":"theorem isCompact_diagonal [CompactSpace X] : IsCompact (diagonal X) :=\n  @range_diag X ▸ isCompact_range (continuous_id.prod_mk continuous_id)\n\n-- Porting note: renamed, golfed\n"}
{"name":"isClosedMap_snd_of_compactSpace","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : CompactSpace X\n⊢ IsClosedMap Prod.snd","decl":"/-- If `X` is a compact topological space, then `Prod.snd : X × Y → Y` is a closed map. -/\ntheorem isClosedMap_snd_of_compactSpace [CompactSpace X] :\n    IsClosedMap (Prod.snd : X × Y → Y) := fun s hs => by\n  rw [← isOpen_compl_iff, isOpen_iff_mem_nhds]\n  intro y hy\n  have : univ ×ˢ {y} ⊆ sᶜ := by\n    exact fun (x, y') ⟨_, rfl⟩ hs => hy ⟨(x, y'), hs, rfl⟩\n  rcases generalized_tube_lemma isCompact_univ isCompact_singleton hs.isOpen_compl this\n    with ⟨U, V, -, hVo, hU, hV, hs⟩\n  refine mem_nhds_iff.2 ⟨V, ?_, hVo, hV rfl⟩\n  rintro _ hzV ⟨z, hzs, rfl⟩\n  exact hs ⟨hU trivial, hzV⟩ hzs\n\n"}
{"name":"isClosedMap_fst_of_compactSpace","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : CompactSpace Y\n⊢ IsClosedMap Prod.fst","decl":"/-- If `Y` is a compact topological space, then `Prod.fst : X × Y → X` is a closed map. -/\ntheorem isClosedMap_fst_of_compactSpace [CompactSpace Y] : IsClosedMap (Prod.fst : X × Y → X) :=\n  isClosedMap_snd_of_compactSpace.comp isClosedMap_swap\n\n"}
{"name":"exists_subset_nhds_of_compactSpace","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nι : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : CompactSpace X\ninst✝ : Nonempty ι\nV : ι → Set X\nhV : Directed (fun x1 x2 => Superset x1 x2) V\nhV_closed : ∀ (i : ι), IsClosed (V i)\nU : Set X\nhU : ∀ (x : X), Membership.mem (Set.iInter fun i => V i) x → Membership.mem (nhds x) U\n⊢ Exists fun i => HasSubset.Subset (V i) U","decl":"theorem exists_subset_nhds_of_compactSpace [CompactSpace X] [Nonempty ι]\n    {V : ι → Set X} (hV : Directed (· ⊇ ·) V) (hV_closed : ∀ i, IsClosed (V i)) {U : Set X}\n    (hU : ∀ x ∈ ⋂ i, V i, U ∈ 𝓝 x) : ∃ i, V i ⊆ U :=\n  exists_subset_nhds_of_isCompact' hV (fun i => (hV_closed i).isCompact) hV_closed hU\n\n"}
{"name":"Topology.IsInducing.isCompact_iff","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nf : X → Y\nhf : Topology.IsInducing f\n⊢ Iff (IsCompact s) (IsCompact (Set.image f s))","decl":"/-- If `f : X → Y` is an inducing map, the image `f '' s` of a set `s` is compact\n  if and only if `s` is compact. -/\ntheorem Topology.IsInducing.isCompact_iff {f : X → Y} (hf : IsInducing f) :\n    IsCompact s ↔ IsCompact (f '' s) := by\n  refine ⟨fun hs => hs.image hf.continuous, fun hs F F_ne_bot F_le => ?_⟩\n  obtain ⟨_, ⟨x, x_in : x ∈ s, rfl⟩, hx : ClusterPt (f x) (map f F)⟩ :=\n    hs ((map_mono F_le).trans_eq map_principal)\n  exact ⟨x, x_in, hf.mapClusterPt_iff.1 hx⟩\n\n"}
{"name":"Inducing.isCompact_iff","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nf : X → Y\nhf : Topology.IsInducing f\n⊢ Iff (IsCompact s) (IsCompact (Set.image f s))","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.isCompact_iff := IsInducing.isCompact_iff\n\n"}
{"name":"Topology.IsEmbedding.isCompact_iff","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nf : X → Y\nhf : Topology.IsEmbedding f\n⊢ Iff (IsCompact s) (IsCompact (Set.image f s))","decl":"/-- If `f : X → Y` is an embedding, the image `f '' s` of a set `s` is compact\nif and only if `s` is compact. -/\ntheorem Topology.IsEmbedding.isCompact_iff {f : X → Y} (hf : IsEmbedding f) :\n    IsCompact s ↔ IsCompact (f '' s) := hf.isInducing.isCompact_iff\n\n"}
{"name":"Embedding.isCompact_iff","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nf : X → Y\nhf : Topology.IsEmbedding f\n⊢ Iff (IsCompact s) (IsCompact (Set.image f s))","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Embedding.isCompact_iff := IsEmbedding.isCompact_iff\n\n"}
{"name":"Topology.IsInducing.isCompact_preimage","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Topology.IsInducing f\nhf' : IsClosed (Set.range f)\nK : Set Y\nhK : IsCompact K\n⊢ IsCompact (Set.preimage f K)","decl":"/-- The preimage of a compact set under an inducing map is a compact set. -/\ntheorem Topology.IsInducing.isCompact_preimage (hf : IsInducing f) (hf' : IsClosed (range f))\n    {K : Set Y} (hK : IsCompact K) : IsCompact (f ⁻¹' K) := by\n  replace hK := hK.inter_right hf'\n  rwa [hf.isCompact_iff, image_preimage_eq_inter_range]\n\n"}
{"name":"Inducing.isCompact_preimage","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Topology.IsInducing f\nhf' : IsClosed (Set.range f)\nK : Set Y\nhK : IsCompact K\n⊢ IsCompact (Set.preimage f K)","decl":"@[deprecated (since := \"2024-10-28\")]\nalias Inducing.isCompact_preimage := IsInducing.isCompact_preimage\n\n"}
{"name":"Topology.IsInducing.isCompact_preimage_iff","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Topology.IsInducing f\nK : Set Y\nKf : HasSubset.Subset K (Set.range f)\n⊢ Iff (IsCompact (Set.preimage f K)) (IsCompact K)","decl":"lemma Topology.IsInducing.isCompact_preimage_iff {f : X → Y} (hf : IsInducing f) {K : Set Y}\n    (Kf : K ⊆ range f) : IsCompact (f ⁻¹' K) ↔ IsCompact K := by\n  rw [hf.isCompact_iff, image_preimage_eq_of_subset Kf]\n\n"}
{"name":"Inducing.isCompact_preimage_iff","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Topology.IsInducing f\nK : Set Y\nKf : HasSubset.Subset K (Set.range f)\n⊢ Iff (IsCompact (Set.preimage f K)) (IsCompact K)","decl":"@[deprecated (since := \"2024-10-28\")]\nalias Inducing.isCompact_preimage_iff := IsInducing.isCompact_preimage_iff\n\n"}
{"name":"Topology.IsInducing.isCompact_preimage'","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Topology.IsInducing f\nK : Set Y\nhK : IsCompact K\nKf : HasSubset.Subset K (Set.range f)\n⊢ IsCompact (Set.preimage f K)","decl":"/-- The preimage of a compact set in the image of an inducing map is compact. -/\nlemma Topology.IsInducing.isCompact_preimage' (hf : IsInducing f) {K : Set Y}\n    (hK : IsCompact K) (Kf : K ⊆ range f) : IsCompact (f ⁻¹' K) :=\n  (hf.isCompact_preimage_iff Kf).2 hK\n\n"}
{"name":"Inducing.isCompact_preimage'","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Topology.IsInducing f\nK : Set Y\nhK : IsCompact K\nKf : HasSubset.Subset K (Set.range f)\n⊢ IsCompact (Set.preimage f K)","decl":"@[deprecated (since := \"2024-10-28\")]\nalias Inducing.isCompact_preimage' := IsInducing.isCompact_preimage'\n\n"}
{"name":"Topology.IsClosedEmbedding.isCompact_preimage","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Topology.IsClosedEmbedding f\nK : Set Y\nhK : IsCompact K\n⊢ IsCompact (Set.preimage f K)","decl":"/-- The preimage of a compact set under a closed embedding is a compact set. -/\ntheorem Topology.IsClosedEmbedding.isCompact_preimage (hf : IsClosedEmbedding f)\n    {K : Set Y} (hK : IsCompact K) : IsCompact (f ⁻¹' K) :=\n  hf.isInducing.isCompact_preimage (hf.isClosed_range) hK\n\n"}
{"name":"ClosedEmbedding.isCompact_preimage","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Topology.IsClosedEmbedding f\nK : Set Y\nhK : IsCompact K\n⊢ IsCompact (Set.preimage f K)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias ClosedEmbedding.isCompact_preimage := IsClosedEmbedding.isCompact_preimage\n\n"}
{"name":"Topology.IsClosedEmbedding.tendsto_cocompact","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Topology.IsClosedEmbedding f\n⊢ Filter.Tendsto f (Filter.cocompact X) (Filter.cocompact Y)","decl":"/-- A closed embedding is proper, ie, inverse images of compact sets are contained in compacts.\nMoreover, the preimage of a compact set is compact, see `IsClosedEmbedding.isCompact_preimage`. -/\ntheorem Topology.IsClosedEmbedding.tendsto_cocompact (hf : IsClosedEmbedding f) :\n    Tendsto f (Filter.cocompact X) (Filter.cocompact Y) :=\n  Filter.hasBasis_cocompact.tendsto_right_iff.mpr fun _K hK =>\n    (hf.isCompact_preimage hK).compl_mem_cocompact\n\n"}
{"name":"ClosedEmbedding.tendsto_cocompact","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Topology.IsClosedEmbedding f\n⊢ Filter.Tendsto f (Filter.cocompact X) (Filter.cocompact Y)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias ClosedEmbedding.tendsto_cocompact := IsClosedEmbedding.tendsto_cocompact\n\n"}
{"name":"Subtype.isCompact_iff","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\np : X → Prop\ns : Set (Subtype fun x => p x)\n⊢ Iff (IsCompact s) (IsCompact (Set.image Subtype.val s))","decl":"/-- Sets of subtype are compact iff the image under a coercion is. -/\ntheorem Subtype.isCompact_iff {p : X → Prop} {s : Set { x // p x }} :\n    IsCompact s ↔ IsCompact ((↑) '' s : Set X) :=\n  IsEmbedding.subtypeVal.isCompact_iff\n\n"}
{"name":"isCompact_iff_isCompact_univ","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (IsCompact s) (IsCompact Set.univ)","decl":"theorem isCompact_iff_isCompact_univ : IsCompact s ↔ IsCompact (univ : Set s) := by\n  rw [Subtype.isCompact_iff, image_univ, Subtype.range_coe]\n\n"}
{"name":"isCompact_iff_compactSpace","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (IsCompact s) (CompactSpace ↑s)","decl":"theorem isCompact_iff_compactSpace : IsCompact s ↔ CompactSpace s :=\n  isCompact_iff_isCompact_univ.trans isCompact_univ_iff\n\n"}
{"name":"IsCompact.finite","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsCompact s\nhs' : DiscreteTopology ↑s\n⊢ s.Finite","decl":"theorem IsCompact.finite (hs : IsCompact s) (hs' : DiscreteTopology s) : s.Finite :=\n  finite_coe_iff.mp (@finite_of_compact_of_discrete _ _ (isCompact_iff_compactSpace.mp hs) hs')\n\n"}
{"name":"exists_nhds_ne_inf_principal_neBot","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsCompact s\nhs' : s.Infinite\n⊢ Exists fun z => And (Membership.mem s z) (Min.min (nhdsWithin z (HasCompl.compl (Singleton.singleton z))) (Filter.principal s)).NeBot","decl":"theorem exists_nhds_ne_inf_principal_neBot (hs : IsCompact s) (hs' : s.Infinite) :\n    ∃ z ∈ s, (𝓝[≠] z ⊓ 𝓟 s).NeBot :=\n  hs'.exists_accPt_of_subset_isCompact hs Subset.rfl\n\n"}
{"name":"Topology.IsClosedEmbedding.noncompactSpace","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : NoncompactSpace X\nf : X → Y\nhf : Topology.IsClosedEmbedding f\n⊢ NoncompactSpace Y","decl":"protected theorem Topology.IsClosedEmbedding.noncompactSpace [NoncompactSpace X] {f : X → Y}\n    (hf : IsClosedEmbedding f) : NoncompactSpace Y :=\n  noncompactSpace_of_neBot hf.tendsto_cocompact.neBot\n\n"}
{"name":"ClosedEmbedding.noncompactSpace","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : NoncompactSpace X\nf : X → Y\nhf : Topology.IsClosedEmbedding f\n⊢ NoncompactSpace Y","decl":"@[deprecated (since := \"2024-10-20\")]\nalias ClosedEmbedding.noncompactSpace := IsClosedEmbedding.noncompactSpace\n\n"}
{"name":"Topology.IsClosedEmbedding.compactSpace","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nh : CompactSpace Y\nf : X → Y\nhf : Topology.IsClosedEmbedding f\n⊢ CompactSpace X","decl":"protected theorem Topology.IsClosedEmbedding.compactSpace [h : CompactSpace Y] {f : X → Y}\n    (hf : IsClosedEmbedding f) : CompactSpace X :=\n  ⟨by rw [hf.isInducing.isCompact_iff, image_univ]; exact hf.isClosed_range.isCompact⟩\n\n"}
{"name":"ClosedEmbedding.compactSpace","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nh : CompactSpace Y\nf : X → Y\nhf : Topology.IsClosedEmbedding f\n⊢ CompactSpace X","decl":"@[deprecated (since := \"2024-10-20\")]\nalias ClosedEmbedding.compactSpace := IsClosedEmbedding.compactSpace\n\n"}
{"name":"IsCompact.prod","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nt : Set Y\nhs : IsCompact s\nht : IsCompact t\n⊢ IsCompact (SProd.sprod s t)","decl":"theorem IsCompact.prod {t : Set Y} (hs : IsCompact s) (ht : IsCompact t) :\n    IsCompact (s ×ˢ t) := by\n  rw [isCompact_iff_ultrafilter_le_nhds'] at hs ht ⊢\n  intro f hfs\n  obtain ⟨x : X, sx : x ∈ s, hx : map Prod.fst f.1 ≤ 𝓝 x⟩ :=\n    hs (f.map Prod.fst) (mem_map.2 <| mem_of_superset hfs fun x => And.left)\n  obtain ⟨y : Y, ty : y ∈ t, hy : map Prod.snd f.1 ≤ 𝓝 y⟩ :=\n    ht (f.map Prod.snd) (mem_map.2 <| mem_of_superset hfs fun x => And.right)\n  rw [map_le_iff_le_comap] at hx hy\n  refine ⟨⟨x, y⟩, ⟨sx, ty⟩, ?_⟩\n  rw [nhds_prod_eq]; exact le_inf hx hy\n\n"}
{"name":"Finite.compactSpace","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : Finite X\n⊢ CompactSpace X","decl":"/-- Finite topological spaces are compact. -/\ninstance (priority := 100) Finite.compactSpace [Finite X] : CompactSpace X where\n  isCompact_univ := finite_univ.isCompact\n\n"}
{"name":"ULift.compactSpace","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : CompactSpace X\n⊢ CompactSpace (ULift.{v, u} X)","decl":"instance ULift.compactSpace [CompactSpace X] : CompactSpace (ULift.{v} X) :=\n  IsClosedEmbedding.uliftDown.compactSpace\n\n"}
{"name":"instCompactSpaceProd","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : CompactSpace X\ninst✝ : CompactSpace Y\n⊢ CompactSpace (Prod X Y)","decl":"/-- The product of two compact spaces is compact. -/\ninstance [CompactSpace X] [CompactSpace Y] : CompactSpace (X × Y) :=\n  ⟨by rw [← univ_prod_univ]; exact isCompact_univ.prod isCompact_univ⟩\n\n"}
{"name":"instCompactSpaceSum","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : CompactSpace X\ninst✝ : CompactSpace Y\n⊢ CompactSpace (Sum X Y)","decl":"/-- The disjoint union of two compact spaces is compact. -/\ninstance [CompactSpace X] [CompactSpace Y] : CompactSpace (X ⊕ Y) :=\n  ⟨by\n    rw [← range_inl_union_range_inr]\n    exact (isCompact_range continuous_inl).union (isCompact_range continuous_inr)⟩\n\n"}
{"name":"instCompactSpaceSigmaOfFinite","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"ι : Type u_1\nX : ι → Type u_2\ninst✝² : Finite ι\ninst✝¹ : (i : ι) → TopologicalSpace (X i)\ninst✝ : ∀ (i : ι), CompactSpace (X i)\n⊢ CompactSpace (Sigma fun i => X i)","decl":"instance {X : ι → Type*} [Finite ι] [∀ i, TopologicalSpace (X i)] [∀ i, CompactSpace (X i)] :\n    CompactSpace (Σi, X i) := by\n  refine ⟨?_⟩\n  rw [Sigma.univ]\n  exact isCompact_iUnion fun i => isCompact_range continuous_sigmaMk\n\n"}
{"name":"Filter.coprod_cocompact","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Eq ((Filter.cocompact X).coprod (Filter.cocompact Y)) (Filter.cocompact (Prod X Y))","decl":"/-- The coproduct of the cocompact filters on two topological spaces is the cocompact filter on\ntheir product. -/\ntheorem Filter.coprod_cocompact :\n    (Filter.cocompact X).coprod (Filter.cocompact Y) = Filter.cocompact (X × Y) := by\n  apply le_antisymm\n  · exact sup_le (comap_cocompact_le continuous_fst) (comap_cocompact_le continuous_snd)\n  · refine (hasBasis_cocompact.coprod hasBasis_cocompact).ge_iff.2 fun K hK ↦ ?_\n    rw [← univ_prod, ← prod_univ, ← compl_prod_eq_union]\n    exact (hK.1.prod hK.2).compl_mem_cocompact\n\n"}
{"name":"Prod.noncompactSpace_iff","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Iff (NoncompactSpace (Prod X Y)) (Or (And (NoncompactSpace X) (Nonempty Y)) (And (Nonempty X) (NoncompactSpace Y)))","decl":"theorem Prod.noncompactSpace_iff :\n    NoncompactSpace (X × Y) ↔ NoncompactSpace X ∧ Nonempty Y ∨ Nonempty X ∧ NoncompactSpace Y := by\n  simp [← Filter.cocompact_neBot_iff, ← Filter.coprod_cocompact, Filter.coprod_neBot_iff]\n\n-- See Note [lower instance priority]\n"}
{"name":"Prod.noncompactSpace_left","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : NoncompactSpace X\ninst✝ : Nonempty Y\n⊢ NoncompactSpace (Prod X Y)","decl":"instance (priority := 100) Prod.noncompactSpace_left [NoncompactSpace X] [Nonempty Y] :\n    NoncompactSpace (X × Y) :=\n  Prod.noncompactSpace_iff.2 (Or.inl ⟨‹_›, ‹_›⟩)\n\n-- See Note [lower instance priority]\n"}
{"name":"Prod.noncompactSpace_right","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\nY : Type v\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : Nonempty X\ninst✝ : NoncompactSpace Y\n⊢ NoncompactSpace (Prod X Y)","decl":"instance (priority := 100) Prod.noncompactSpace_right [Nonempty X] [NoncompactSpace Y] :\n    NoncompactSpace (X × Y) :=\n  Prod.noncompactSpace_iff.2 (Or.inr ⟨‹_›, ‹_›⟩)\n\n"}
{"name":"isCompact_pi_infinite","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"ι : Type u_1\nX : ι → Type u_2\ninst✝ : (i : ι) → TopologicalSpace (X i)\ns : (i : ι) → Set (X i)\na✝ : ∀ (i : ι), IsCompact (s i)\n⊢ IsCompact (setOf fun x => ∀ (i : ι), Membership.mem (s i) (x i))","decl":"/-- **Tychonoff's theorem**: product of compact sets is compact. -/\ntheorem isCompact_pi_infinite {s : ∀ i, Set (X i)} :\n    (∀ i, IsCompact (s i)) → IsCompact { x : ∀ i, X i | ∀ i, x i ∈ s i } := by\n  simp only [isCompact_iff_ultrafilter_le_nhds, nhds_pi, le_pi, le_principal_iff]\n  intro h f hfs\n  have : ∀ i : ι, ∃ x, x ∈ s i ∧ Tendsto (Function.eval i) f (𝓝 x) := by\n    refine fun i => h i (f.map _) (mem_map.2 ?_)\n    exact mem_of_superset hfs fun x hx => hx i\n  choose x hx using this\n  exact ⟨x, fun i => (hx i).left, fun i => (hx i).right⟩\n\n"}
{"name":"isCompact_univ_pi","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"ι : Type u_1\nX : ι → Type u_2\ninst✝ : (i : ι) → TopologicalSpace (X i)\ns : (i : ι) → Set (X i)\nh : ∀ (i : ι), IsCompact (s i)\n⊢ IsCompact (Set.univ.pi s)","decl":"/-- **Tychonoff's theorem** formulated using `Set.pi`: product of compact sets is compact. -/\ntheorem isCompact_univ_pi {s : ∀ i, Set (X i)} (h : ∀ i, IsCompact (s i)) :\n    IsCompact (pi univ s) := by\n  convert isCompact_pi_infinite h\n  simp only [← mem_univ_pi, setOf_mem_eq]\n\n"}
{"name":"Pi.compactSpace","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"ι : Type u_1\nX : ι → Type u_2\ninst✝¹ : (i : ι) → TopologicalSpace (X i)\ninst✝ : ∀ (i : ι), CompactSpace (X i)\n⊢ CompactSpace ((i : ι) → X i)","decl":"instance Pi.compactSpace [∀ i, CompactSpace (X i)] : CompactSpace (∀ i, X i) :=\n  ⟨by rw [← pi_univ univ]; exact isCompact_univ_pi fun i => isCompact_univ⟩\n\n"}
{"name":"Function.compactSpace","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"Y : Type v\nι : Type u_1\ninst✝¹ : TopologicalSpace Y\ninst✝ : CompactSpace Y\n⊢ CompactSpace (ι → Y)","decl":"instance Function.compactSpace [CompactSpace Y] : CompactSpace (ι → Y) :=\n  Pi.compactSpace\n\n"}
{"name":"Pi.isCompact_iff_of_isClosed","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"ι : Type u_1\nX : ι → Type u_2\ninst✝ : (i : ι) → TopologicalSpace (X i)\ns : Set ((i : ι) → X i)\nhs : IsClosed s\n⊢ Iff (IsCompact s) (∀ (i : ι), IsCompact (Set.image (Function.eval i) s))","decl":"lemma Pi.isCompact_iff_of_isClosed {s : Set (Π i, X i)} (hs : IsClosed s) :\n    IsCompact s ↔ ∀ i, IsCompact (eval i '' s) := by\n  constructor <;> intro H\n  · exact fun i ↦ H.image <| continuous_apply i\n  · exact IsCompact.of_isClosed_subset (isCompact_univ_pi H) hs (subset_pi_eval_image univ s)\n\n"}
{"name":"Pi.exists_compact_superset_iff","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"ι : Type u_1\nX : ι → Type u_2\ninst✝ : (i : ι) → TopologicalSpace (X i)\ns : Set ((i : ι) → X i)\n⊢ Iff (Exists fun K => And (IsCompact K) (HasSubset.Subset s K)) (∀ (i : ι), Exists fun Ki => And (IsCompact Ki) (HasSubset.Subset s (Set.preimage (Function.eval i) Ki)))","decl":"protected lemma Pi.exists_compact_superset_iff {s : Set (Π i, X i)} :\n    (∃ K, IsCompact K ∧ s ⊆ K) ↔ ∀ i, ∃ Ki, IsCompact Ki ∧ s ⊆ eval i ⁻¹' Ki := by\n  constructor\n  · intro ⟨K, hK, hsK⟩ i\n    exact ⟨eval i '' K, hK.image <| continuous_apply i, hsK.trans <| K.subset_preimage_image _⟩\n  · intro H\n    choose K hK hsK using H\n    exact ⟨pi univ K, isCompact_univ_pi hK, fun _ hx i _ ↦ hsK i hx⟩\n\n"}
{"name":"Filter.coprodᵢ_cocompact","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"ι : Type u_1\nX : ι → Type u_3\ninst✝ : (d : ι) → TopologicalSpace (X d)\n⊢ Eq (Filter.coprodᵢ fun d => Filter.cocompact (X d)) (Filter.cocompact ((d : ι) → X d))","decl":"/-- **Tychonoff's theorem** formulated in terms of filters: `Filter.cocompact` on an indexed product\ntype `Π d, X d` the `Filter.coprodᵢ` of filters `Filter.cocompact` on `X d`. -/\ntheorem Filter.coprodᵢ_cocompact {X : ι → Type*} [∀ d, TopologicalSpace (X d)] :\n    (Filter.coprodᵢ fun d => Filter.cocompact (X d)) = Filter.cocompact (∀ d, X d) := by\n  refine le_antisymm (iSup_le fun i => Filter.comap_cocompact_le (continuous_apply i)) ?_\n  refine compl_surjective.forall.2 fun s H => ?_\n  simp only [compl_mem_coprodᵢ, Filter.mem_cocompact, compl_subset_compl, image_subset_iff] at H ⊢\n  choose K hKc htK using H\n  exact ⟨Set.pi univ K, isCompact_univ_pi hKc, fun f hf i _ => htK i hf⟩\n\n"}
{"name":"Quot.compactSpace","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\nr : X → X → Prop\ninst✝ : CompactSpace X\n⊢ CompactSpace (Quot r)","decl":"instance Quot.compactSpace {r : X → X → Prop} [CompactSpace X] : CompactSpace (Quot r) :=\n  ⟨by\n    rw [← range_quot_mk]\n    exact isCompact_range continuous_quot_mk⟩\n\n"}
{"name":"Quotient.compactSpace","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ns : Setoid X\ninst✝ : CompactSpace X\n⊢ CompactSpace (Quotient s)","decl":"instance Quotient.compactSpace {s : Setoid X} [CompactSpace X] : CompactSpace (Quotient s) :=\n  Quot.compactSpace\n\n"}
{"name":"IsClosed.exists_minimal_nonempty_closed_subset","module":"Mathlib.Topology.Compactness.Compact","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : CompactSpace X\nS : Set X\nhS : IsClosed S\nhne : S.Nonempty\n⊢ Exists fun V => And (HasSubset.Subset V S) (And V.Nonempty (And (IsClosed V) (∀ (V' : Set X), HasSubset.Subset V' V → V'.Nonempty → IsClosed V' → Eq V' V)))","decl":"theorem IsClosed.exists_minimal_nonempty_closed_subset [CompactSpace X] {S : Set X}\n    (hS : IsClosed S) (hne : S.Nonempty) :\n    ∃ V : Set X, V ⊆ S ∧ V.Nonempty ∧ IsClosed V ∧\n      ∀ V' : Set X, V' ⊆ V → V'.Nonempty → IsClosed V' → V' = V := by\n  let opens := { U : Set X | Sᶜ ⊆ U ∧ IsOpen U ∧ Uᶜ.Nonempty }\n  obtain ⟨U, h⟩ :=\n    zorn_subset opens fun c hc hz => by\n      by_cases hcne : c.Nonempty\n      · obtain ⟨U₀, hU₀⟩ := hcne\n        haveI : Nonempty { U // U ∈ c } := ⟨⟨U₀, hU₀⟩⟩\n        obtain ⟨U₀compl, -, -⟩ := hc hU₀\n        use ⋃₀ c\n        refine ⟨⟨?_, ?_, ?_⟩, fun U hU _ hx => ⟨U, hU, hx⟩⟩\n        · exact fun _ hx => ⟨U₀, hU₀, U₀compl hx⟩\n        · exact isOpen_sUnion fun _ h => (hc h).2.1\n        · convert_to (⋂ U : { U // U ∈ c }, U.1ᶜ).Nonempty\n          · ext\n            simp only [not_exists, exists_prop, not_and, Set.mem_iInter, Subtype.forall,\n              mem_setOf_eq, mem_compl_iff, mem_sUnion]\n          apply IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed\n          · rintro ⟨U, hU⟩ ⟨U', hU'⟩\n            obtain ⟨V, hVc, hVU, hVU'⟩ := hz.directedOn U hU U' hU'\n            exact ⟨⟨V, hVc⟩, Set.compl_subset_compl.mpr hVU, Set.compl_subset_compl.mpr hVU'⟩\n          · exact fun U => (hc U.2).2.2\n          · exact fun U => (hc U.2).2.1.isClosed_compl.isCompact\n          · exact fun U => (hc U.2).2.1.isClosed_compl\n      · use Sᶜ\n        refine ⟨⟨Set.Subset.refl _, isOpen_compl_iff.mpr hS, ?_⟩, fun U Uc => (hcne ⟨U, Uc⟩).elim⟩\n        rw [compl_compl]\n        exact hne\n  obtain ⟨Uc, Uo, Ucne⟩ := h.prop\n  refine ⟨Uᶜ, Set.compl_subset_comm.mp Uc, Ucne, Uo.isClosed_compl, ?_⟩\n  intro V' V'sub V'ne V'cls\n  have : V'ᶜ = U := by\n    refine h.eq_of_ge ⟨?_, isOpen_compl_iff.mpr V'cls, ?_⟩ (subset_compl_comm.2 V'sub)\n    · exact Set.Subset.trans Uc (Set.subset_compl_comm.mp V'sub)\n    · simp only [compl_compl, V'ne]\n  rw [← this, compl_compl]\n\n"}
