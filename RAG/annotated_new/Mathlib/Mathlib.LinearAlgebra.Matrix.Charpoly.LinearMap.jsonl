{"name":"PiToModule.fromMatrix_apply","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.LinearMap","initialProofState":"ι : Type u_1\ninst✝⁴ : Fintype ι\nM : Type u_2\ninst✝³ : AddCommGroup M\nR : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Module R M\nb : ι → M\ninst✝ : DecidableEq ι\nA : Matrix ι ι R\nw : ι → R\n⊢ Eq (((PiToModule.fromMatrix R b) A) w) (((Fintype.linearCombination R R) b) (A.mulVec w))","decl":"theorem PiToModule.fromMatrix_apply [DecidableEq ι] (A : Matrix ι ι R) (w : ι → R) :\n    PiToModule.fromMatrix R b A w = Fintype.linearCombination R R b (A *ᵥ w) :=\n  rfl\n\n"}
{"name":"PiToModule.fromMatrix_apply_single_one","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.LinearMap","initialProofState":"ι : Type u_1\ninst✝⁴ : Fintype ι\nM : Type u_2\ninst✝³ : AddCommGroup M\nR : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Module R M\nb : ι → M\ninst✝ : DecidableEq ι\nA : Matrix ι ι R\nj : ι\n⊢ Eq (((PiToModule.fromMatrix R b) A) (Pi.single j 1)) (Finset.univ.sum fun i => HSMul.hSMul (A i j) (b i))","decl":"theorem PiToModule.fromMatrix_apply_single_one [DecidableEq ι] (A : Matrix ι ι R) (j : ι) :\n    PiToModule.fromMatrix R b A (Pi.single j 1) = ∑ i : ι, A i j • b i := by\n  rw [PiToModule.fromMatrix_apply, Fintype.linearCombination_apply, Matrix.mulVec_single]\n  simp_rw [MulOpposite.op_one, one_smul, transpose_apply]\n\n"}
{"name":"PiToModule.fromEnd_apply","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.LinearMap","initialProofState":"ι : Type u_1\ninst✝³ : Fintype ι\nM : Type u_2\ninst✝² : AddCommGroup M\nR : Type u_3\ninst✝¹ : CommRing R\ninst✝ : Module R M\nb : ι → M\nf : Module.End R M\nw : ι → R\n⊢ Eq (((PiToModule.fromEnd R b) f) w) (f (((Fintype.linearCombination R R) b) w))","decl":"theorem PiToModule.fromEnd_apply (f : Module.End R M) (w : ι → R) :\n    PiToModule.fromEnd R b f w = f (Fintype.linearCombination R R b w) :=\n  rfl\n\n"}
{"name":"PiToModule.fromEnd_apply_single_one","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.LinearMap","initialProofState":"ι : Type u_1\ninst✝⁴ : Fintype ι\nM : Type u_2\ninst✝³ : AddCommGroup M\nR : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Module R M\nb : ι → M\ninst✝ : DecidableEq ι\nf : Module.End R M\ni : ι\n⊢ Eq (((PiToModule.fromEnd R b) f) (Pi.single i 1)) (f (b i))","decl":"theorem PiToModule.fromEnd_apply_single_one [DecidableEq ι] (f : Module.End R M) (i : ι) :\n    PiToModule.fromEnd R b f (Pi.single i 1) = f (b i) := by\n  rw [PiToModule.fromEnd_apply]\n  congr\n  convert Fintype.linearCombination_apply_single (S := R) R b i (1 : R)\n  rw [one_smul]\n\n"}
{"name":"PiToModule.fromEnd_injective","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.LinearMap","initialProofState":"ι : Type u_1\ninst✝³ : Fintype ι\nM : Type u_2\ninst✝² : AddCommGroup M\nR : Type u_3\ninst✝¹ : CommRing R\ninst✝ : Module R M\nb : ι → M\nhb : Eq (Submodule.span R (Set.range b)) Top.top\n⊢ Function.Injective ⇑(PiToModule.fromEnd R b)","decl":"theorem PiToModule.fromEnd_injective (hb : Submodule.span R (Set.range b) = ⊤) :\n    Function.Injective (PiToModule.fromEnd R b) := by\n  intro x y e\n  ext m\n  obtain ⟨m, rfl⟩ : m ∈ LinearMap.range (Fintype.linearCombination R R b) := by\n    rw [(Fintype.range_linearCombination R b).trans hb]\n    exact Submodule.mem_top\n  exact (LinearMap.congr_fun e m :)\n\n"}
{"name":"Matrix.Represents.congr_fun","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.LinearMap","initialProofState":"ι : Type u_1\ninst✝⁴ : Fintype ι\nM : Type u_2\ninst✝³ : AddCommGroup M\nR : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Module R M\nb : ι → M\ninst✝ : DecidableEq ι\nA : Matrix ι ι R\nf : Module.End R M\nh : Matrix.Represents b A f\nx : ι → R\n⊢ Eq (((Fintype.linearCombination R R) b) (A.mulVec x)) (f (((Fintype.linearCombination R R) b) x))","decl":"theorem Matrix.Represents.congr_fun {A : Matrix ι ι R} {f : Module.End R M} (h : A.Represents b f)\n    (x) : Fintype.linearCombination R R b (A *ᵥ x) = f (Fintype.linearCombination R R b x) :=\n  LinearMap.congr_fun h x\n\n"}
{"name":"Matrix.represents_iff","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.LinearMap","initialProofState":"ι : Type u_1\ninst✝⁴ : Fintype ι\nM : Type u_2\ninst✝³ : AddCommGroup M\nR : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Module R M\nb : ι → M\ninst✝ : DecidableEq ι\nA : Matrix ι ι R\nf : Module.End R M\n⊢ Iff (Matrix.Represents b A f) (∀ (x : ι → R), Eq (((Fintype.linearCombination R R) b) (A.mulVec x)) (f (((Fintype.linearCombination R R) b) x)))","decl":"theorem Matrix.represents_iff {A : Matrix ι ι R} {f : Module.End R M} :\n    A.Represents b f ↔\n      ∀ x, Fintype.linearCombination R R b (A *ᵥ x) = f (Fintype.linearCombination R R b x) :=\n  ⟨fun e x => e.congr_fun x, fun H => LinearMap.ext fun x => H x⟩\n\n"}
{"name":"Matrix.represents_iff'","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.LinearMap","initialProofState":"ι : Type u_1\ninst✝⁴ : Fintype ι\nM : Type u_2\ninst✝³ : AddCommGroup M\nR : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Module R M\nb : ι → M\ninst✝ : DecidableEq ι\nA : Matrix ι ι R\nf : Module.End R M\n⊢ Iff (Matrix.Represents b A f) (∀ (j : ι), Eq (Finset.univ.sum fun i => HSMul.hSMul (A i j) (b i)) (f (b j)))","decl":"theorem Matrix.represents_iff' {A : Matrix ι ι R} {f : Module.End R M} :\n    A.Represents b f ↔ ∀ j, ∑ i : ι, A i j • b i = f (b j) := by\n  constructor\n  · intro h i\n    have := LinearMap.congr_fun h (Pi.single i 1)\n    rwa [PiToModule.fromEnd_apply_single_one, PiToModule.fromMatrix_apply_single_one] at this\n  · intro h\n    ext\n    simp_rw [LinearMap.comp_apply, LinearMap.coe_single, PiToModule.fromEnd_apply_single_one,\n      PiToModule.fromMatrix_apply_single_one]\n    apply h\n\n"}
{"name":"Matrix.Represents.mul","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.LinearMap","initialProofState":"ι : Type u_1\ninst✝⁴ : Fintype ι\nM : Type u_2\ninst✝³ : AddCommGroup M\nR : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Module R M\nb : ι → M\ninst✝ : DecidableEq ι\nA A' : Matrix ι ι R\nf f' : Module.End R M\nh : Matrix.Represents b A f\nh' : Matrix.Represents b A' f'\n⊢ Matrix.Represents b (HMul.hMul A A') (HMul.hMul f f')","decl":"theorem Matrix.Represents.mul {A A' : Matrix ι ι R} {f f' : Module.End R M} (h : A.Represents b f)\n    (h' : Matrix.Represents b A' f') : (A * A').Represents b (f * f') := by\n  delta Matrix.Represents PiToModule.fromMatrix\n  rw [LinearMap.comp_apply, AlgEquiv.toLinearMap_apply, _root_.map_mul]\n  ext\n  dsimp [PiToModule.fromEnd]\n  rw [← h'.congr_fun, ← h.congr_fun]\n  rfl\n\n"}
{"name":"Matrix.Represents.one","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.LinearMap","initialProofState":"ι : Type u_1\ninst✝⁴ : Fintype ι\nM : Type u_2\ninst✝³ : AddCommGroup M\nR : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Module R M\nb : ι → M\ninst✝ : DecidableEq ι\n⊢ Matrix.Represents b 1 1","decl":"theorem Matrix.Represents.one : (1 : Matrix ι ι R).Represents b 1 := by\n  delta Matrix.Represents PiToModule.fromMatrix\n  rw [LinearMap.comp_apply, AlgEquiv.toLinearMap_apply, _root_.map_one]\n  ext\n  rfl\n\n"}
{"name":"Matrix.Represents.add","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.LinearMap","initialProofState":"ι : Type u_1\ninst✝⁴ : Fintype ι\nM : Type u_2\ninst✝³ : AddCommGroup M\nR : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Module R M\nb : ι → M\ninst✝ : DecidableEq ι\nA A' : Matrix ι ι R\nf f' : Module.End R M\nh : Matrix.Represents b A f\nh' : Matrix.Represents b A' f'\n⊢ Matrix.Represents b (HAdd.hAdd A A') (HAdd.hAdd f f')","decl":"theorem Matrix.Represents.add {A A' : Matrix ι ι R} {f f' : Module.End R M} (h : A.Represents b f)\n    (h' : Matrix.Represents b A' f') : (A + A').Represents b (f + f') := by\n  delta Matrix.Represents at h h' ⊢; rw [map_add, map_add, h, h']\n\n"}
{"name":"Matrix.Represents.zero","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.LinearMap","initialProofState":"ι : Type u_1\ninst✝⁴ : Fintype ι\nM : Type u_2\ninst✝³ : AddCommGroup M\nR : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Module R M\nb : ι → M\ninst✝ : DecidableEq ι\n⊢ Matrix.Represents b 0 0","decl":"theorem Matrix.Represents.zero : (0 : Matrix ι ι R).Represents b 0 := by\n  delta Matrix.Represents\n  rw [map_zero, map_zero]\n\n"}
{"name":"Matrix.Represents.smul","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.LinearMap","initialProofState":"ι : Type u_1\ninst✝⁴ : Fintype ι\nM : Type u_2\ninst✝³ : AddCommGroup M\nR : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Module R M\nb : ι → M\ninst✝ : DecidableEq ι\nA : Matrix ι ι R\nf : Module.End R M\nh : Matrix.Represents b A f\nr : R\n⊢ Matrix.Represents b (HSMul.hSMul r A) (HSMul.hSMul r f)","decl":"theorem Matrix.Represents.smul {A : Matrix ι ι R} {f : Module.End R M} (h : A.Represents b f)\n    (r : R) : (r • A).Represents b (r • f) := by\n  delta Matrix.Represents at h ⊢\n  rw [_root_.map_smul, _root_.map_smul, h]\n\n"}
{"name":"Matrix.Represents.algebraMap","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.LinearMap","initialProofState":"ι : Type u_1\ninst✝⁴ : Fintype ι\nM : Type u_2\ninst✝³ : AddCommGroup M\nR : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Module R M\nb : ι → M\ninst✝ : DecidableEq ι\nr : R\n⊢ Matrix.Represents b ((algebraMap R (Matrix ι ι R)) r) ((algebraMap R (Module.End R M)) r)","decl":"theorem Matrix.Represents.algebraMap (r : R) :\n    (algebraMap _ (Matrix ι ι R) r).Represents b (algebraMap _ (Module.End R M) r) := by\n  simpa only [Algebra.algebraMap_eq_smul_one] using Matrix.Represents.one.smul r\n\n"}
{"name":"Matrix.Represents.eq","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.LinearMap","initialProofState":"ι : Type u_1\ninst✝⁴ : Fintype ι\nM : Type u_2\ninst✝³ : AddCommGroup M\nR : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Module R M\nb : ι → M\ninst✝ : DecidableEq ι\nhb : Eq (Submodule.span R (Set.range b)) Top.top\nA : Matrix ι ι R\nf f' : Module.End R M\nh : Matrix.Represents b A f\nh' : Matrix.Represents b A f'\n⊢ Eq f f'","decl":"theorem Matrix.Represents.eq (hb : Submodule.span R (Set.range b) = ⊤)\n    {A : Matrix ι ι R} {f f' : Module.End R M} (h : A.Represents b f)\n    (h' : A.Represents b f') : f = f' :=\n  PiToModule.fromEnd_injective R b hb (h.symm.trans h')\n\n"}
{"name":"Matrix.isRepresentation.toEnd_represents","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.LinearMap","initialProofState":"ι : Type u_1\ninst✝⁴ : Fintype ι\nM : Type u_2\ninst✝³ : AddCommGroup M\nR : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Module R M\nb : ι → M\ninst✝ : DecidableEq ι\nhb : Eq (Submodule.span R (Set.range b)) Top.top\nA : Subtype fun x => Membership.mem (Matrix.isRepresentation R b) x\n⊢ Matrix.Represents b (↑A) ((Matrix.isRepresentation.toEnd R b hb) A)","decl":"theorem Matrix.isRepresentation.toEnd_represents (A : Matrix.isRepresentation R b) :\n    (A : Matrix ι ι R).Represents b (Matrix.isRepresentation.toEnd R b hb A) :=\n  A.2.choose_spec\n\n"}
{"name":"Matrix.isRepresentation.eq_toEnd_of_represents","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.LinearMap","initialProofState":"ι : Type u_1\ninst✝⁴ : Fintype ι\nM : Type u_2\ninst✝³ : AddCommGroup M\nR : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Module R M\nb : ι → M\ninst✝ : DecidableEq ι\nhb : Eq (Submodule.span R (Set.range b)) Top.top\nA : Subtype fun x => Membership.mem (Matrix.isRepresentation R b) x\nf : Module.End R M\nh : Matrix.Represents b (↑A) f\n⊢ Eq ((Matrix.isRepresentation.toEnd R b hb) A) f","decl":"theorem Matrix.isRepresentation.eq_toEnd_of_represents (A : Matrix.isRepresentation R b)\n    {f : Module.End R M} (h : (A : Matrix ι ι R).Represents b f) :\n    Matrix.isRepresentation.toEnd R b hb A = f :=\n  A.2.choose_spec.eq hb h\n\n"}
{"name":"Matrix.isRepresentation.toEnd_exists_mem_ideal","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.LinearMap","initialProofState":"ι : Type u_1\ninst✝⁴ : Fintype ι\nM : Type u_2\ninst✝³ : AddCommGroup M\nR : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Module R M\nb : ι → M\ninst✝ : DecidableEq ι\nhb : Eq (Submodule.span R (Set.range b)) Top.top\nf : Module.End R M\nI : Ideal R\nhI : LE.le (LinearMap.range f) (HSMul.hSMul I Top.top)\n⊢ Exists fun M_1 => And (Eq ((Matrix.isRepresentation.toEnd R b hb) M_1) f) (∀ (i j : ι), Membership.mem I (↑M_1 i j))","decl":"theorem Matrix.isRepresentation.toEnd_exists_mem_ideal (f : Module.End R M) (I : Ideal R)\n    (hI : LinearMap.range f ≤ I • ⊤) :\n    ∃ M, Matrix.isRepresentation.toEnd R b hb M = f ∧ ∀ i j, M.1 i j ∈ I := by\n  have : ∀ x, f x ∈ LinearMap.range (Ideal.finsuppTotal ι M I b) := by\n    rw [Ideal.range_finsuppTotal, hb]\n    exact fun x => hI (LinearMap.mem_range_self f x)\n  choose bM' hbM' using this\n  let A : Matrix ι ι R := fun i j => bM' (b j) i\n  have : A.Represents b f := by\n    rw [Matrix.represents_iff']\n    dsimp [A]\n    intro j\n    specialize hbM' (b j)\n    rwa [Ideal.finsuppTotal_apply_eq_of_fintype] at hbM'\n  exact\n    ⟨⟨A, f, this⟩, Matrix.isRepresentation.eq_toEnd_of_represents R b hb ⟨A, f, this⟩ this,\n      fun i j => (bM' (b j) i).prop⟩\n\n"}
{"name":"Matrix.isRepresentation.toEnd_surjective","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.LinearMap","initialProofState":"ι : Type u_1\ninst✝⁴ : Fintype ι\nM : Type u_2\ninst✝³ : AddCommGroup M\nR : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Module R M\nb : ι → M\ninst✝ : DecidableEq ι\nhb : Eq (Submodule.span R (Set.range b)) Top.top\n⊢ Function.Surjective ⇑(Matrix.isRepresentation.toEnd R b hb)","decl":"theorem Matrix.isRepresentation.toEnd_surjective :\n    Function.Surjective (Matrix.isRepresentation.toEnd R b hb) := by\n  intro f\n  obtain ⟨M, e, -⟩ := Matrix.isRepresentation.toEnd_exists_mem_ideal R b hb f ⊤ (by simp)\n  exact ⟨M, e⟩\n\n"}
{"name":"LinearMap.exists_monic_and_coeff_mem_pow_and_aeval_eq_zero_of_range_le_smul","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.LinearMap","initialProofState":"M : Type u_2\ninst✝³ : AddCommGroup M\nR : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Module R M\ninst✝ : Module.Finite R M\nf : Module.End R M\nI : Ideal R\nhI : LE.le (LinearMap.range f) (HSMul.hSMul I Top.top)\n⊢ Exists fun p => And p.Monic (And (∀ (k : Nat), Membership.mem (HPow.hPow I (HSub.hSub p.natDegree k)) (p.coeff k)) (Eq ((Polynomial.aeval f) p) 0))","decl":"/-- The **Cayley-Hamilton Theorem** for f.g. modules over arbitrary rings states that for each\n`R`-endomorphism `φ` of an `R`-module `M` such that `φ(M) ≤ I • M` for some ideal `I`, there\nexists some `n` and some `aᵢ ∈ Iⁱ` such that `φⁿ + a₁ φⁿ⁻¹ + ⋯ + aₙ = 0`.\n\nThis is the version found in Eisenbud 4.3, which is slightly weaker than Matsumura 2.1\n(this lacks the constraint on `n`), and is slightly stronger than Atiyah-Macdonald 2.4.\n-/\ntheorem LinearMap.exists_monic_and_coeff_mem_pow_and_aeval_eq_zero_of_range_le_smul\n    [Module.Finite R M] (f : Module.End R M) (I : Ideal R) (hI : LinearMap.range f ≤ I • ⊤) :\n    ∃ p : R[X], p.Monic ∧ (∀ k, p.coeff k ∈ I ^ (p.natDegree - k)) ∧ Polynomial.aeval f p = 0 := by\n  classical\n    cases subsingleton_or_nontrivial R\n    · exact ⟨0, Polynomial.monic_of_subsingleton _, by simp⟩\n    obtain ⟨s : Finset M, hs : Submodule.span R (s : Set M) = ⊤⟩ :=\n      Module.Finite.fg_top (R := R) (M := M)\n    -- Porting note: `H` was `rfl`\n    obtain ⟨A, H, h⟩ :=\n      Matrix.isRepresentation.toEnd_exists_mem_ideal R ((↑) : s → M)\n        (by rw [Subtype.range_coe_subtype, Finset.setOf_mem, hs]) f I hI\n    rw [← H]\n    refine ⟨A.1.charpoly, A.1.charpoly_monic, ?_, ?_⟩\n    · rw [A.1.charpoly_natDegree_eq_dim]\n      exact coeff_charpoly_mem_ideal_pow h\n    · rw [Polynomial.aeval_algHom_apply,\n        ← map_zero (Matrix.isRepresentation.toEnd R ((↑) : s → M) _)]\n      congr 1\n      ext1\n      rw [Polynomial.aeval_subalgebra_coe, Matrix.aeval_self_charpoly, Subalgebra.coe_zero]\n\n"}
{"name":"LinearMap.exists_monic_and_aeval_eq_zero","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.LinearMap","initialProofState":"M : Type u_2\ninst✝³ : AddCommGroup M\nR : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Module R M\ninst✝ : Module.Finite R M\nf : Module.End R M\n⊢ Exists fun p => And p.Monic (Eq ((Polynomial.aeval f) p) 0)","decl":"theorem LinearMap.exists_monic_and_aeval_eq_zero [Module.Finite R M] (f : Module.End R M) :\n    ∃ p : R[X], p.Monic ∧ Polynomial.aeval f p = 0 :=\n  (LinearMap.exists_monic_and_coeff_mem_pow_and_aeval_eq_zero_of_range_le_smul R f ⊤ (by simp)).imp\n    fun _ h => h.imp_right And.right\n"}
