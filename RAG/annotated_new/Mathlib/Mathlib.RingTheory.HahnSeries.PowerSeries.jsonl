{"name":"HahnSeries.toPowerSeries_symm_apply_coeff","module":"Mathlib.RingTheory.HahnSeries.PowerSeries","initialProofState":"R : Type u_2\ninst✝ : Semiring R\nf : PowerSeries R\nn : Nat\n⊢ Eq ((HahnSeries.toPowerSeries.symm f).coeff n) ((PowerSeries.coeff R n) f)","decl":"/-- The ring `HahnSeries ℕ R` is isomorphic to `PowerSeries R`. -/\n@[simps]\ndef toPowerSeries : HahnSeries ℕ R ≃+* PowerSeries R where\n  toFun f := PowerSeries.mk f.coeff\n  invFun f := ⟨fun n => PowerSeries.coeff R n f, (Nat.lt_wfRel.wf.isWF _).isPWO⟩\n  left_inv f := by\n    ext\n    simp\n  right_inv f := by\n    ext\n    simp\n  map_add' f g := by\n    ext\n    simp\n  map_mul' f g := by\n    ext n\n    simp only [PowerSeries.coeff_mul, PowerSeries.coeff_mk, coeff_mul, isPWO_support]\n    classical\n    refine (sum_filter_ne_zero _).symm.trans <| (sum_congr ?_ fun _ _ ↦ rfl).trans <|\n      sum_filter_ne_zero _\n    ext m\n    simp only [mem_antidiagonal, mem_addAntidiagonal, and_congr_left_iff, mem_filter,\n      mem_support]\n    rintro h\n    rw [and_iff_right (left_ne_zero_of_mul h), and_iff_right (right_ne_zero_of_mul h)]\n\n"}
{"name":"HahnSeries.toPowerSeries_apply","module":"Mathlib.RingTheory.HahnSeries.PowerSeries","initialProofState":"R : Type u_2\ninst✝ : Semiring R\nf : HahnSeries Nat R\n⊢ Eq (HahnSeries.toPowerSeries f) (PowerSeries.mk f.coeff)","decl":"/-- The ring `HahnSeries ℕ R` is isomorphic to `PowerSeries R`. -/\n@[simps]\ndef toPowerSeries : HahnSeries ℕ R ≃+* PowerSeries R where\n  toFun f := PowerSeries.mk f.coeff\n  invFun f := ⟨fun n => PowerSeries.coeff R n f, (Nat.lt_wfRel.wf.isWF _).isPWO⟩\n  left_inv f := by\n    ext\n    simp\n  right_inv f := by\n    ext\n    simp\n  map_add' f g := by\n    ext\n    simp\n  map_mul' f g := by\n    ext n\n    simp only [PowerSeries.coeff_mul, PowerSeries.coeff_mk, coeff_mul, isPWO_support]\n    classical\n    refine (sum_filter_ne_zero _).symm.trans <| (sum_congr ?_ fun _ _ ↦ rfl).trans <|\n      sum_filter_ne_zero _\n    ext m\n    simp only [mem_antidiagonal, mem_addAntidiagonal, and_congr_left_iff, mem_filter,\n      mem_support]\n    rintro h\n    rw [and_iff_right (left_ne_zero_of_mul h), and_iff_right (right_ne_zero_of_mul h)]\n\n"}
{"name":"HahnSeries.coeff_toPowerSeries","module":"Mathlib.RingTheory.HahnSeries.PowerSeries","initialProofState":"R : Type u_2\ninst✝ : Semiring R\nf : HahnSeries Nat R\nn : Nat\n⊢ Eq ((PowerSeries.coeff R n) (HahnSeries.toPowerSeries f)) (f.coeff n)","decl":"theorem coeff_toPowerSeries {f : HahnSeries ℕ R} {n : ℕ} :\n    PowerSeries.coeff R n (toPowerSeries f) = f.coeff n :=\n  PowerSeries.coeff_mk _ _\n\n"}
{"name":"HahnSeries.coeff_toPowerSeries_symm","module":"Mathlib.RingTheory.HahnSeries.PowerSeries","initialProofState":"R : Type u_2\ninst✝ : Semiring R\nf : PowerSeries R\nn : Nat\n⊢ Eq ((HahnSeries.toPowerSeries.symm f).coeff n) ((PowerSeries.coeff R n) f)","decl":"theorem coeff_toPowerSeries_symm {f : PowerSeries R} {n : ℕ} :\n    (HahnSeries.toPowerSeries.symm f).coeff n = PowerSeries.coeff R n f :=\n  rfl\n\n"}
{"name":"HahnSeries.ofPowerSeries_injective","module":"Mathlib.RingTheory.HahnSeries.PowerSeries","initialProofState":"Γ : Type u_1\nR : Type u_2\ninst✝¹ : Semiring R\ninst✝ : StrictOrderedSemiring Γ\n⊢ Function.Injective ⇑(HahnSeries.ofPowerSeries Γ R)","decl":"theorem ofPowerSeries_injective : Function.Injective (ofPowerSeries Γ R) :=\n  embDomain_injective.comp toPowerSeries.symm.injective\n\n/-@[simp] Porting note: removing simp. RHS is more complicated and it makes linter\nfailures elsewhere -/\n"}
{"name":"HahnSeries.ofPowerSeries_apply","module":"Mathlib.RingTheory.HahnSeries.PowerSeries","initialProofState":"Γ : Type u_1\nR : Type u_2\ninst✝¹ : Semiring R\ninst✝ : StrictOrderedSemiring Γ\nx : PowerSeries R\n⊢ Eq ((HahnSeries.ofPowerSeries Γ R) x) (HahnSeries.embDomain { toFun := Nat.cast, inj' := ⋯, map_rel_iff' := ⋯ } (HahnSeries.toPowerSeries.symm x))","decl":"theorem ofPowerSeries_apply (x : PowerSeries R) :\n    ofPowerSeries Γ R x =\n      HahnSeries.embDomain\n        ⟨⟨((↑) : ℕ → Γ), Nat.strictMono_cast.injective⟩, by\n          simp only [Function.Embedding.coeFn_mk]\n          exact Nat.cast_le⟩\n        (toPowerSeries.symm x) :=\n  rfl\n\n"}
{"name":"HahnSeries.ofPowerSeries_apply_coeff","module":"Mathlib.RingTheory.HahnSeries.PowerSeries","initialProofState":"Γ : Type u_1\nR : Type u_2\ninst✝¹ : Semiring R\ninst✝ : StrictOrderedSemiring Γ\nx : PowerSeries R\nn : Nat\n⊢ Eq (((HahnSeries.ofPowerSeries Γ R) x).coeff ↑n) ((PowerSeries.coeff R n) x)","decl":"theorem ofPowerSeries_apply_coeff (x : PowerSeries R) (n : ℕ) :\n    (ofPowerSeries Γ R x).coeff n = PowerSeries.coeff R n x := by simp [ofPowerSeries_apply]\n\n"}
{"name":"HahnSeries.ofPowerSeries_C","module":"Mathlib.RingTheory.HahnSeries.PowerSeries","initialProofState":"Γ : Type u_1\nR : Type u_2\ninst✝¹ : Semiring R\ninst✝ : StrictOrderedSemiring Γ\nr : R\n⊢ Eq ((HahnSeries.ofPowerSeries Γ R) ((PowerSeries.C R) r)) (HahnSeries.C r)","decl":"@[simp]\ntheorem ofPowerSeries_C (r : R) : ofPowerSeries Γ R (PowerSeries.C R r) = HahnSeries.C r := by\n  ext n\n  simp only [ofPowerSeries_apply, C, RingHom.coe_mk, MonoidHom.coe_mk, OneHom.coe_mk, ne_eq,\n    coeff_single]\n  split_ifs with hn\n  · subst hn\n    convert embDomain_coeff (a := 0) <;> simp\n  · rw [embDomain_notin_image_support]\n    simp only [not_exists, Set.mem_image, toPowerSeries_symm_apply_coeff, mem_support,\n      PowerSeries.coeff_C]\n    intro\n    simp +contextual [Ne.symm hn]\n\n"}
{"name":"HahnSeries.ofPowerSeries_X","module":"Mathlib.RingTheory.HahnSeries.PowerSeries","initialProofState":"Γ : Type u_1\nR : Type u_2\ninst✝¹ : Semiring R\ninst✝ : StrictOrderedSemiring Γ\n⊢ Eq ((HahnSeries.ofPowerSeries Γ R) PowerSeries.X) ((HahnSeries.single 1) 1)","decl":"@[simp]\ntheorem ofPowerSeries_X : ofPowerSeries Γ R PowerSeries.X = single 1 1 := by\n  ext n\n  simp only [coeff_single, ofPowerSeries_apply, RingHom.coe_mk]\n  split_ifs with hn\n  · rw [hn]\n    convert embDomain_coeff (a := 1) <;> simp\n  · rw [embDomain_notin_image_support]\n    simp only [not_exists, Set.mem_image, toPowerSeries_symm_apply_coeff, mem_support,\n      PowerSeries.coeff_X]\n    intro\n    simp +contextual [Ne.symm hn]\n\n"}
{"name":"HahnSeries.ofPowerSeries_X_pow","module":"Mathlib.RingTheory.HahnSeries.PowerSeries","initialProofState":"Γ : Type u_1\ninst✝¹ : StrictOrderedSemiring Γ\nR : Type u_3\ninst✝ : Semiring R\nn : Nat\n⊢ Eq ((HahnSeries.ofPowerSeries Γ R) (HPow.hPow PowerSeries.X n)) ((HahnSeries.single ↑n) 1)","decl":"theorem ofPowerSeries_X_pow {R} [Semiring R] (n : ℕ) :\n    ofPowerSeries Γ R (PowerSeries.X ^ n) = single (n : Γ) 1 := by\n  simp\n\n-- Lemmas about converting hahn_series over fintype to and from mv_power_series\n"}
{"name":"HahnSeries.toMvPowerSeries_apply","module":"Mathlib.RingTheory.HahnSeries.PowerSeries","initialProofState":"R : Type u_2\ninst✝¹ : Semiring R\nσ : Type u_3\ninst✝ : Finite σ\nf : HahnSeries (Finsupp σ Nat) R\na✝ : Finsupp σ Nat\n⊢ Eq (HahnSeries.toMvPowerSeries f a✝) (f.coeff a✝)","decl":"/-- The ring `HahnSeries (σ →₀ ℕ) R` is isomorphic to `MvPowerSeries σ R` for a `Finite` `σ`.\nWe take the index set of the hahn series to be `Finsupp` rather than `pi`,\neven though we assume `Finite σ` as this is more natural for alignment with `MvPowerSeries`.\nAfter importing `Algebra.Order.Pi` the ring `HahnSeries (σ → ℕ) R` could be constructed instead.\n -/\n@[simps]\ndef toMvPowerSeries {σ : Type*} [Finite σ] : HahnSeries (σ →₀ ℕ) R ≃+* MvPowerSeries σ R where\n  toFun f := f.coeff\n  invFun f := ⟨(f : (σ →₀ ℕ) → R), Finsupp.isPWO _⟩\n  left_inv f := by\n    ext\n    simp\n  right_inv f := by\n    ext\n    simp\n  map_add' f g := by\n    ext\n    simp\n  map_mul' f g := by\n    ext n\n    simp only [MvPowerSeries.coeff_mul]\n    classical\n      change (f * g).coeff n = _\n      simp_rw [coeff_mul]\n      refine (sum_filter_ne_zero _).symm.trans <| (sum_congr ?_ fun _ _ ↦ rfl).trans <|\n        sum_filter_ne_zero _\n      ext m\n      simp only [and_congr_left_iff, mem_addAntidiagonal, mem_filter, mem_support,\n        Finset.mem_antidiagonal]\n      rintro h\n      rw [and_iff_right (left_ne_zero_of_mul h), and_iff_right (right_ne_zero_of_mul h)]\n\n"}
{"name":"HahnSeries.toMvPowerSeries_symm_apply_coeff","module":"Mathlib.RingTheory.HahnSeries.PowerSeries","initialProofState":"R : Type u_2\ninst✝¹ : Semiring R\nσ : Type u_3\ninst✝ : Finite σ\nf : MvPowerSeries σ R\n⊢ Eq (HahnSeries.toMvPowerSeries.symm f).coeff f","decl":"/-- The ring `HahnSeries (σ →₀ ℕ) R` is isomorphic to `MvPowerSeries σ R` for a `Finite` `σ`.\nWe take the index set of the hahn series to be `Finsupp` rather than `pi`,\neven though we assume `Finite σ` as this is more natural for alignment with `MvPowerSeries`.\nAfter importing `Algebra.Order.Pi` the ring `HahnSeries (σ → ℕ) R` could be constructed instead.\n -/\n@[simps]\ndef toMvPowerSeries {σ : Type*} [Finite σ] : HahnSeries (σ →₀ ℕ) R ≃+* MvPowerSeries σ R where\n  toFun f := f.coeff\n  invFun f := ⟨(f : (σ →₀ ℕ) → R), Finsupp.isPWO _⟩\n  left_inv f := by\n    ext\n    simp\n  right_inv f := by\n    ext\n    simp\n  map_add' f g := by\n    ext\n    simp\n  map_mul' f g := by\n    ext n\n    simp only [MvPowerSeries.coeff_mul]\n    classical\n      change (f * g).coeff n = _\n      simp_rw [coeff_mul]\n      refine (sum_filter_ne_zero _).symm.trans <| (sum_congr ?_ fun _ _ ↦ rfl).trans <|\n        sum_filter_ne_zero _\n      ext m\n      simp only [and_congr_left_iff, mem_addAntidiagonal, mem_filter, mem_support,\n        Finset.mem_antidiagonal]\n      rintro h\n      rw [and_iff_right (left_ne_zero_of_mul h), and_iff_right (right_ne_zero_of_mul h)]\n\n"}
{"name":"HahnSeries.instNoZeroDivisorsFinsuppNat","module":"Mathlib.RingTheory.HahnSeries.PowerSeries","initialProofState":"R : Type u_2\ninst✝² : Semiring R\nσ : Type u_3\ninst✝¹ : Finite σ\ninst✝ : NoZeroDivisors R\n⊢ NoZeroDivisors (HahnSeries (Finsupp σ Nat) R)","decl":"/-- If R has no zero divisors and `σ` is finite,\nthen `HahnSeries (σ →₀ ℕ) R` has no zero divisors -/\ninstance [NoZeroDivisors R] : NoZeroDivisors (HahnSeries (σ →₀ ℕ) R) :=\n  toMvPowerSeries.toMulEquiv.noZeroDivisors (A := HahnSeries (σ →₀ ℕ) R) (MvPowerSeries σ R)\n\n"}
{"name":"HahnSeries.coeff_toMvPowerSeries","module":"Mathlib.RingTheory.HahnSeries.PowerSeries","initialProofState":"R : Type u_2\ninst✝¹ : Semiring R\nσ : Type u_3\ninst✝ : Finite σ\nf : HahnSeries (Finsupp σ Nat) R\nn : Finsupp σ Nat\n⊢ Eq ((MvPowerSeries.coeff R n) (HahnSeries.toMvPowerSeries f)) (f.coeff n)","decl":"theorem coeff_toMvPowerSeries {f : HahnSeries (σ →₀ ℕ) R} {n : σ →₀ ℕ} :\n    MvPowerSeries.coeff R n (toMvPowerSeries f) = f.coeff n :=\n  rfl\n\n"}
{"name":"HahnSeries.coeff_toMvPowerSeries_symm","module":"Mathlib.RingTheory.HahnSeries.PowerSeries","initialProofState":"R : Type u_2\ninst✝¹ : Semiring R\nσ : Type u_3\ninst✝ : Finite σ\nf : MvPowerSeries σ R\nn : Finsupp σ Nat\n⊢ Eq ((HahnSeries.toMvPowerSeries.symm f).coeff n) ((MvPowerSeries.coeff R n) f)","decl":"theorem coeff_toMvPowerSeries_symm {f : MvPowerSeries σ R} {n : σ →₀ ℕ} :\n    (HahnSeries.toMvPowerSeries.symm f).coeff n = MvPowerSeries.coeff R n f :=\n  rfl\n\n"}
{"name":"HahnSeries.toPowerSeriesAlg_apply","module":"Mathlib.RingTheory.HahnSeries.PowerSeries","initialProofState":"R : Type u_2\ninst✝² : CommSemiring R\nA : Type u_3\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf : HahnSeries Nat A\n⊢ Eq ((HahnSeries.toPowerSeriesAlg R) f) (PowerSeries.mk f.coeff)","decl":"/-- The `R`-algebra `HahnSeries ℕ A` is isomorphic to `PowerSeries A`. -/\n@[simps!]\ndef toPowerSeriesAlg : HahnSeries ℕ A ≃ₐ[R] PowerSeries A :=\n  { toPowerSeries with\n    commutes' := fun r => by\n      ext n\n      cases n <;> simp [algebraMap_apply, PowerSeries.algebraMap_apply] }\n\n"}
{"name":"HahnSeries.toPowerSeriesAlg_symm_apply_coeff","module":"Mathlib.RingTheory.HahnSeries.PowerSeries","initialProofState":"R : Type u_2\ninst✝² : CommSemiring R\nA : Type u_3\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf : PowerSeries A\nn : Nat\n⊢ Eq (((HahnSeries.toPowerSeriesAlg R).symm f).coeff n) ((PowerSeries.coeff A n) f)","decl":"/-- The `R`-algebra `HahnSeries ℕ A` is isomorphic to `PowerSeries A`. -/\n@[simps!]\ndef toPowerSeriesAlg : HahnSeries ℕ A ≃ₐ[R] PowerSeries A :=\n  { toPowerSeries with\n    commutes' := fun r => by\n      ext n\n      cases n <;> simp [algebraMap_apply, PowerSeries.algebraMap_apply] }\n\n"}
{"name":"HahnSeries.ofPowerSeriesAlg_apply_coeff","module":"Mathlib.RingTheory.HahnSeries.PowerSeries","initialProofState":"Γ : Type u_1\nR : Type u_2\ninst✝³ : CommSemiring R\nA : Type u_3\ninst✝² : Semiring A\ninst✝¹ : Algebra R A\ninst✝ : StrictOrderedSemiring Γ\na✝ : PowerSeries A\nb : Γ\n⊢ Eq (((HahnSeries.ofPowerSeriesAlg Γ R) a✝).coeff b) (dite (Membership.mem (Set.image Nat.cast ((HahnSeries.toPowerSeriesAlg R).symm a✝).support) b) (fun h => (PowerSeries.coeff A (Classical.choose ⋯)) a✝) fun h => 0)","decl":"/-- Casting a power series as a Hahn series with coefficients from a `StrictOrderedSemiring`\n  is an algebra homomorphism. -/\n@[simps!]\ndef ofPowerSeriesAlg : PowerSeries A →ₐ[R] HahnSeries Γ A :=\n  (HahnSeries.embDomainAlgHom (Nat.castAddMonoidHom Γ) Nat.strictMono_cast.injective fun _ _ =>\n        Nat.cast_le).comp\n    (AlgEquiv.toAlgHom (toPowerSeriesAlg R).symm)\n\n"}
{"name":"HahnSeries.algebraMap_apply'","module":"Mathlib.RingTheory.HahnSeries.PowerSeries","initialProofState":"Γ : Type u_1\nR : Type u_2\ninst✝³ : CommSemiring R\ninst✝² : StrictOrderedSemiring Γ\nS : Type u_4\ninst✝¹ : CommSemiring S\ninst✝ : Algebra S (PowerSeries R)\nx : S\n⊢ Eq ((algebraMap S (HahnSeries Γ R)) x) ((HahnSeries.ofPowerSeries Γ R) ((algebraMap S (PowerSeries R)) x))","decl":"theorem algebraMap_apply' (x : S) :\n    algebraMap S (HahnSeries Γ R) x = ofPowerSeries Γ R (algebraMap S (PowerSeries R) x) :=\n  rfl\n\n"}
{"name":"Polynomial.algebraMap_hahnSeries_apply","module":"Mathlib.RingTheory.HahnSeries.PowerSeries","initialProofState":"Γ : Type u_1\nR : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : StrictOrderedSemiring Γ\nf : Polynomial R\n⊢ Eq ((algebraMap (Polynomial R) (HahnSeries Γ R)) f) ((HahnSeries.ofPowerSeries Γ R) ↑f)","decl":"@[simp]\ntheorem _root_.Polynomial.algebraMap_hahnSeries_apply (f : R[X]) :\n    algebraMap R[X] (HahnSeries Γ R) f = ofPowerSeries Γ R f :=\n  rfl\n\n"}
{"name":"Polynomial.algebraMap_hahnSeries_injective","module":"Mathlib.RingTheory.HahnSeries.PowerSeries","initialProofState":"Γ : Type u_1\nR : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : StrictOrderedSemiring Γ\n⊢ Function.Injective ⇑(algebraMap (Polynomial R) (HahnSeries Γ R))","decl":"theorem _root_.Polynomial.algebraMap_hahnSeries_injective :\n    Function.Injective (algebraMap R[X] (HahnSeries Γ R)) :=\n  ofPowerSeries_injective.comp (Polynomial.coe_injective R)\n\n"}
