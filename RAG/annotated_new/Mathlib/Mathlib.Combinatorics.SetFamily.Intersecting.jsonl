{"name":"Set.Intersecting.mono","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"α : Type u_1\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderBot α\ns t : Set α\nh : HasSubset.Subset t s\nhs : s.Intersecting\n⊢ t.Intersecting","decl":"@[mono]\ntheorem Intersecting.mono (h : t ⊆ s) (hs : s.Intersecting) : t.Intersecting := fun _a ha _b hb =>\n  hs (h ha) (h hb)\n\n"}
{"name":"Set.Intersecting.not_bot_mem","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"α : Type u_1\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderBot α\ns : Set α\nhs : s.Intersecting\n⊢ Not (Membership.mem s Bot.bot)","decl":"theorem Intersecting.not_bot_mem (hs : s.Intersecting) : ⊥ ∉ s := fun h => hs h h disjoint_bot_left\n\n"}
{"name":"Set.Intersecting.ne_bot","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"α : Type u_1\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderBot α\ns : Set α\na : α\nhs : s.Intersecting\nha : Membership.mem s a\n⊢ Ne a Bot.bot","decl":"theorem Intersecting.ne_bot (hs : s.Intersecting) (ha : a ∈ s) : a ≠ ⊥ :=\n  ne_of_mem_of_not_mem ha hs.not_bot_mem\n\n"}
{"name":"Set.intersecting_empty","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"α : Type u_1\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderBot α\n⊢ EmptyCollection.emptyCollection.Intersecting","decl":"theorem intersecting_empty : (∅ : Set α).Intersecting := fun _ => False.elim\n\n"}
{"name":"Set.intersecting_singleton","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"α : Type u_1\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderBot α\na : α\n⊢ Iff (Singleton.singleton a).Intersecting (Ne a Bot.bot)","decl":"@[simp]\ntheorem intersecting_singleton : ({a} : Set α).Intersecting ↔ a ≠ ⊥ := by simp [Intersecting]\n\n"}
{"name":"Set.Intersecting.insert","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"α : Type u_1\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderBot α\ns : Set α\na : α\nhs : s.Intersecting\nha : Ne a Bot.bot\nh : ∀ (b : α), Membership.mem s b → Not (Disjoint a b)\n⊢ (Insert.insert a s).Intersecting","decl":"protected theorem Intersecting.insert (hs : s.Intersecting) (ha : a ≠ ⊥)\n    (h : ∀ b ∈ s, ¬Disjoint a b) : (insert a s).Intersecting := by\n  rintro b (rfl | hb) c (rfl | hc)\n  · rwa [disjoint_self]\n  · exact h _ hc\n  · exact fun H => h _ hb H.symm\n  · exact hs hb hc\n\n"}
{"name":"Set.intersecting_insert","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"α : Type u_1\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderBot α\ns : Set α\na : α\n⊢ Iff (Insert.insert a s).Intersecting (And s.Intersecting (And (Ne a Bot.bot) (∀ (b : α), Membership.mem s b → Not (Disjoint a b))))","decl":"theorem intersecting_insert :\n    (insert a s).Intersecting ↔ s.Intersecting ∧ a ≠ ⊥ ∧ ∀ b ∈ s, ¬Disjoint a b :=\n  ⟨fun h =>\n    ⟨h.mono <| subset_insert _ _, h.ne_bot <| mem_insert _ _, fun _b hb =>\n      h (mem_insert _ _) <| mem_insert_of_mem _ hb⟩,\n    fun h => h.1.insert h.2.1 h.2.2⟩\n\n"}
{"name":"Set.intersecting_iff_pairwise_not_disjoint","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"α : Type u_1\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderBot α\ns : Set α\n⊢ Iff s.Intersecting (And (s.Pairwise fun a b => Not (Disjoint a b)) (Ne s (Singleton.singleton Bot.bot)))","decl":"theorem intersecting_iff_pairwise_not_disjoint :\n    s.Intersecting ↔ (s.Pairwise fun a b => ¬Disjoint a b) ∧ s ≠ {⊥} := by\n  refine ⟨fun h => ⟨fun a ha b hb _ => h ha hb, ?_⟩, fun h a ha b hb hab => ?_⟩\n  · rintro rfl\n    exact intersecting_singleton.1 h rfl\n  have := h.1.eq ha hb (Classical.not_not.2 hab)\n  rw [this, disjoint_self] at hab\n  rw [hab] at hb\n  exact\n    h.2\n      (eq_singleton_iff_unique_mem.2\n        ⟨hb, fun c hc => not_ne_iff.1 fun H => h.1 hb hc H.symm disjoint_bot_left⟩)\n\n"}
{"name":"Set.Subsingleton.intersecting","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"α : Type u_1\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderBot α\ns : Set α\nhs : s.Subsingleton\n⊢ Iff s.Intersecting (Ne s (Singleton.singleton Bot.bot))","decl":"protected theorem Subsingleton.intersecting (hs : s.Subsingleton) : s.Intersecting ↔ s ≠ {⊥} :=\n  intersecting_iff_pairwise_not_disjoint.trans <| and_iff_right <| hs.pairwise _\n\n"}
{"name":"Set.intersecting_iff_eq_empty_of_subsingleton","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"α : Type u_1\ninst✝² : SemilatticeInf α\ninst✝¹ : OrderBot α\ninst✝ : Subsingleton α\ns : Set α\n⊢ Iff s.Intersecting (Eq s EmptyCollection.emptyCollection)","decl":"theorem intersecting_iff_eq_empty_of_subsingleton [Subsingleton α] (s : Set α) :\n    s.Intersecting ↔ s = ∅ := by\n  refine\n    subsingleton_of_subsingleton.intersecting.trans\n      ⟨not_imp_comm.2 fun h => subsingleton_of_subsingleton.eq_singleton_of_mem ?_, ?_⟩\n  · obtain ⟨a, ha⟩ := nonempty_iff_ne_empty.2 h\n    rwa [Subsingleton.elim ⊥ a]\n  · rintro rfl\n    exact (Set.singleton_nonempty _).ne_empty.symm\n\n"}
{"name":"Set.Intersecting.isUpperSet","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"α : Type u_1\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderBot α\ns : Set α\nhs : s.Intersecting\nh : ∀ (t : Set α), t.Intersecting → HasSubset.Subset s t → Eq s t\n⊢ IsUpperSet s","decl":"/-- Maximal intersecting families are upper sets. -/\nprotected theorem Intersecting.isUpperSet (hs : s.Intersecting)\n    (h : ∀ t : Set α, t.Intersecting → s ⊆ t → s = t) : IsUpperSet s := by\n  classical\n    rintro a b hab ha\n    rw [h (Insert.insert b s) _ (subset_insert _ _)]\n    · exact mem_insert _ _\n    exact\n      hs.insert (mt (eq_bot_mono hab) <| hs.ne_bot ha) fun c hc hbc => hs ha hc <| hbc.mono_left hab\n\n"}
{"name":"Set.Intersecting.isUpperSet'","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"α : Type u_1\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderBot α\ns : Finset α\nhs : (↑s).Intersecting\nh : ∀ (t : Finset α), (↑t).Intersecting → HasSubset.Subset s t → Eq s t\n⊢ IsUpperSet ↑s","decl":"/-- Maximal intersecting families are upper sets. Finset version. -/\ntheorem Intersecting.isUpperSet' {s : Finset α} (hs : (s : Set α).Intersecting)\n    (h : ∀ t : Finset α, (t : Set α).Intersecting → s ⊆ t → s = t) : IsUpperSet (s : Set α) := by\n  classical\n    rintro a b hab ha\n    rw [h (Insert.insert b s) _ (Finset.subset_insert _ _)]\n    · exact mem_insert_self _ _\n    rw [coe_insert]\n    exact\n      hs.insert (mt (eq_bot_mono hab) <| hs.ne_bot ha) fun c hc hbc => hs ha hc <| hbc.mono_left hab\n\n"}
{"name":"Set.Intersecting.exists_mem_set","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"α : Type u_1\n𝒜 : Set (Set α)\nh𝒜 : 𝒜.Intersecting\ns t : Set α\nhs : Membership.mem 𝒜 s\nht : Membership.mem 𝒜 t\n⊢ Exists fun a => And (Membership.mem s a) (Membership.mem t a)","decl":"theorem Intersecting.exists_mem_set {𝒜 : Set (Set α)} (h𝒜 : 𝒜.Intersecting) {s t : Set α}\n    (hs : s ∈ 𝒜) (ht : t ∈ 𝒜) : ∃ a, a ∈ s ∧ a ∈ t :=\n  not_disjoint_iff.1 <| h𝒜 hs ht\n\n"}
{"name":"Set.Intersecting.exists_mem_finset","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Set (Finset α)\nh𝒜 : 𝒜.Intersecting\ns t : Finset α\nhs : Membership.mem 𝒜 s\nht : Membership.mem 𝒜 t\n⊢ Exists fun a => And (Membership.mem s a) (Membership.mem t a)","decl":"theorem Intersecting.exists_mem_finset [DecidableEq α] {𝒜 : Set (Finset α)} (h𝒜 : 𝒜.Intersecting)\n    {s t : Finset α} (hs : s ∈ 𝒜) (ht : t ∈ 𝒜) : ∃ a, a ∈ s ∧ a ∈ t :=\n  not_disjoint_iff.1 <| disjoint_coe.not.2 <| h𝒜 hs ht\n\n"}
{"name":"Set.Intersecting.not_compl_mem","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"α : Type u_1\ninst✝ : BooleanAlgebra α\ns : Set α\nhs : s.Intersecting\na : α\nha : Membership.mem s a\n⊢ Not (Membership.mem s (HasCompl.compl a))","decl":"theorem Intersecting.not_compl_mem {s : Set α} (hs : s.Intersecting) {a : α} (ha : a ∈ s) :\n    aᶜ ∉ s := fun h => hs ha h disjoint_compl_right\n\n"}
{"name":"Set.Intersecting.not_mem","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"α : Type u_1\ninst✝ : BooleanAlgebra α\ns : Set α\nhs : s.Intersecting\na : α\nha : Membership.mem s (HasCompl.compl a)\n⊢ Not (Membership.mem s a)","decl":"theorem Intersecting.not_mem {s : Set α} (hs : s.Intersecting) {a : α} (ha : aᶜ ∈ s) : a ∉ s :=\n  fun h => hs ha h disjoint_compl_left\n\n"}
{"name":"Set.Intersecting.disjoint_map_compl","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"α : Type u_1\ninst✝ : BooleanAlgebra α\ns : Finset α\nhs : (↑s).Intersecting\n⊢ Disjoint s (Finset.map { toFun := HasCompl.compl, inj' := ⋯ } s)","decl":"theorem Intersecting.disjoint_map_compl {s : Finset α} (hs : (s : Set α).Intersecting) :\n    Disjoint s (s.map ⟨compl, compl_injective⟩) := by\n  rw [Finset.disjoint_left]\n  rintro x hx hxc\n  obtain ⟨x, hx', rfl⟩ := mem_map.mp hxc\n  exact hs.not_compl_mem hx' hx\n\n"}
{"name":"Set.Intersecting.card_le","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"α : Type u_1\ninst✝¹ : BooleanAlgebra α\ninst✝ : Fintype α\ns : Finset α\nhs : (↑s).Intersecting\n⊢ LE.le (HMul.hMul 2 s.card) (Fintype.card α)","decl":"theorem Intersecting.card_le [Fintype α] {s : Finset α} (hs : (s : Set α).Intersecting) :\n    2 * #s ≤ Fintype.card α := by\n  classical\n    refine (s.disjUnion _ hs.disjoint_map_compl).card_le_univ.trans_eq' ?_\n    rw [Nat.two_mul, card_disjUnion, card_map]\n\n"}
{"name":"Set.Intersecting.is_max_iff_card_eq","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"α : Type u_1\ninst✝² : BooleanAlgebra α\ninst✝¹ : Nontrivial α\ninst✝ : Fintype α\ns : Finset α\nhs : (↑s).Intersecting\n⊢ Iff (∀ (t : Finset α), (↑t).Intersecting → HasSubset.Subset s t → Eq s t) (Eq (HMul.hMul 2 s.card) (Fintype.card α))","decl":"theorem Intersecting.is_max_iff_card_eq (hs : (s : Set α).Intersecting) :\n    (∀ t : Finset α, (t : Set α).Intersecting → s ⊆ t → s = t) ↔ 2 * #s = Fintype.card α := by\n  classical\n    refine ⟨fun h ↦ ?_, fun h t ht hst ↦ Finset.eq_of_subset_of_card_le hst <|\n      Nat.le_of_mul_le_mul_left (ht.card_le.trans_eq h.symm) Nat.two_pos⟩\n    suffices s.disjUnion (s.map ⟨compl, compl_injective⟩) hs.disjoint_map_compl = Finset.univ by\n      rw [Fintype.card, ← this, Nat.two_mul, card_disjUnion, card_map]\n    rw [← coe_eq_univ, disjUnion_eq_union, coe_union, coe_map, Function.Embedding.coeFn_mk,\n      image_eq_preimage_of_inverse compl_compl compl_compl]\n    refine eq_univ_of_forall fun a => ?_\n    simp_rw [mem_union, mem_preimage]\n    by_contra! ha\n    refine s.ne_insert_of_not_mem _ ha.1 (h _ ?_ <| s.subset_insert _)\n    rw [coe_insert]\n    refine hs.insert ?_ fun b hb hab => ha.2 <| (hs.isUpperSet' h) hab.le_compl_left hb\n    rintro rfl\n    have := h {⊤} (by rw [coe_singleton]; exact intersecting_singleton.2 top_ne_bot)\n    rw [compl_bot] at ha\n    rw [coe_eq_empty.1 ((hs.isUpperSet' h).not_top_mem.1 ha.2)] at this\n    exact Finset.singleton_ne_empty _ (this <| Finset.empty_subset _).symm\n\n"}
{"name":"Set.Intersecting.exists_card_eq","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"α : Type u_1\ninst✝² : BooleanAlgebra α\ninst✝¹ : Nontrivial α\ninst✝ : Fintype α\ns : Finset α\nhs : (↑s).Intersecting\n⊢ Exists fun t => And (HasSubset.Subset s t) (And (Eq (HMul.hMul 2 t.card) (Fintype.card α)) (↑t).Intersecting)","decl":"theorem Intersecting.exists_card_eq (hs : (s : Set α).Intersecting) :\n    ∃ t, s ⊆ t ∧ 2 * #t = Fintype.card α ∧ (t : Set α).Intersecting := by\n  have := hs.card_le\n  rw [mul_comm, ← Nat.le_div_iff_mul_le Nat.two_pos] at this\n  revert hs\n  refine s.strongDownwardInductionOn ?_ this\n  rintro s ih _hcard hs\n  by_cases h : ∀ t : Finset α, (t : Set α).Intersecting → s ⊆ t → s = t\n  · exact ⟨s, Subset.rfl, hs.is_max_iff_card_eq.1 h, hs⟩\n  push_neg at h\n  obtain ⟨t, ht, hst⟩ := h\n  refine (ih ?_ (_root_.ssubset_iff_subset_ne.2 hst) ht).imp fun u => And.imp_left hst.1.trans\n  rw [Nat.le_div_iff_mul_le Nat.two_pos, mul_comm]\n  exact ht.card_le\n\n"}
