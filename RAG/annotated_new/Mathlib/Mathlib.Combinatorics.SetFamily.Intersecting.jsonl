{"name":"Set.Intersecting.mono","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : SemilatticeInf Î±\ninstâœ : OrderBot Î±\ns t : Set Î±\nh : HasSubset.Subset t s\nhs : s.Intersecting\nâŠ¢ t.Intersecting","decl":"@[mono]\ntheorem Intersecting.mono (h : t âŠ† s) (hs : s.Intersecting) : t.Intersecting := fun _a ha _b hb =>\n  hs (h ha) (h hb)\n\n"}
{"name":"Set.Intersecting.not_bot_mem","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : SemilatticeInf Î±\ninstâœ : OrderBot Î±\ns : Set Î±\nhs : s.Intersecting\nâŠ¢ Not (Membership.mem s Bot.bot)","decl":"theorem Intersecting.not_bot_mem (hs : s.Intersecting) : âŠ¥ âˆ‰ s := fun h => hs h h disjoint_bot_left\n\n"}
{"name":"Set.Intersecting.ne_bot","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : SemilatticeInf Î±\ninstâœ : OrderBot Î±\ns : Set Î±\na : Î±\nhs : s.Intersecting\nha : Membership.mem s a\nâŠ¢ Ne a Bot.bot","decl":"theorem Intersecting.ne_bot (hs : s.Intersecting) (ha : a âˆˆ s) : a â‰  âŠ¥ :=\n  ne_of_mem_of_not_mem ha hs.not_bot_mem\n\n"}
{"name":"Set.intersecting_empty","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : SemilatticeInf Î±\ninstâœ : OrderBot Î±\nâŠ¢ EmptyCollection.emptyCollection.Intersecting","decl":"theorem intersecting_empty : (âˆ… : Set Î±).Intersecting := fun _ => False.elim\n\n"}
{"name":"Set.intersecting_singleton","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : SemilatticeInf Î±\ninstâœ : OrderBot Î±\na : Î±\nâŠ¢ Iff (Singleton.singleton a).Intersecting (Ne a Bot.bot)","decl":"@[simp]\ntheorem intersecting_singleton : ({a} : Set Î±).Intersecting â†” a â‰  âŠ¥ := by simp [Intersecting]\n\n"}
{"name":"Set.Intersecting.insert","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : SemilatticeInf Î±\ninstâœ : OrderBot Î±\ns : Set Î±\na : Î±\nhs : s.Intersecting\nha : Ne a Bot.bot\nh : âˆ€ (b : Î±), Membership.mem s b â†’ Not (Disjoint a b)\nâŠ¢ (Insert.insert a s).Intersecting","decl":"protected theorem Intersecting.insert (hs : s.Intersecting) (ha : a â‰  âŠ¥)\n    (h : âˆ€ b âˆˆ s, Â¬Disjoint a b) : (insert a s).Intersecting := by\n  rintro b (rfl | hb) c (rfl | hc)\n  Â· rwa [disjoint_self]\n  Â· exact h _ hc\n  Â· exact fun H => h _ hb H.symm\n  Â· exact hs hb hc\n\n"}
{"name":"Set.intersecting_insert","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : SemilatticeInf Î±\ninstâœ : OrderBot Î±\ns : Set Î±\na : Î±\nâŠ¢ Iff (Insert.insert a s).Intersecting (And s.Intersecting (And (Ne a Bot.bot) (âˆ€ (b : Î±), Membership.mem s b â†’ Not (Disjoint a b))))","decl":"theorem intersecting_insert :\n    (insert a s).Intersecting â†” s.Intersecting âˆ§ a â‰  âŠ¥ âˆ§ âˆ€ b âˆˆ s, Â¬Disjoint a b :=\n  âŸ¨fun h =>\n    âŸ¨h.mono <| subset_insert _ _, h.ne_bot <| mem_insert _ _, fun _b hb =>\n      h (mem_insert _ _) <| mem_insert_of_mem _ hbâŸ©,\n    fun h => h.1.insert h.2.1 h.2.2âŸ©\n\n"}
{"name":"Set.intersecting_iff_pairwise_not_disjoint","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : SemilatticeInf Î±\ninstâœ : OrderBot Î±\ns : Set Î±\nâŠ¢ Iff s.Intersecting (And (s.Pairwise fun a b => Not (Disjoint a b)) (Ne s (Singleton.singleton Bot.bot)))","decl":"theorem intersecting_iff_pairwise_not_disjoint :\n    s.Intersecting â†” (s.Pairwise fun a b => Â¬Disjoint a b) âˆ§ s â‰  {âŠ¥} := by\n  refine âŸ¨fun h => âŸ¨fun a ha b hb _ => h ha hb, ?_âŸ©, fun h a ha b hb hab => ?_âŸ©\n  Â· rintro rfl\n    exact intersecting_singleton.1 h rfl\n  have := h.1.eq ha hb (Classical.not_not.2 hab)\n  rw [this, disjoint_self] at hab\n  rw [hab] at hb\n  exact\n    h.2\n      (eq_singleton_iff_unique_mem.2\n        âŸ¨hb, fun c hc => not_ne_iff.1 fun H => h.1 hb hc H.symm disjoint_bot_leftâŸ©)\n\n"}
{"name":"Set.Subsingleton.intersecting","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : SemilatticeInf Î±\ninstâœ : OrderBot Î±\ns : Set Î±\nhs : s.Subsingleton\nâŠ¢ Iff s.Intersecting (Ne s (Singleton.singleton Bot.bot))","decl":"protected theorem Subsingleton.intersecting (hs : s.Subsingleton) : s.Intersecting â†” s â‰  {âŠ¥} :=\n  intersecting_iff_pairwise_not_disjoint.trans <| and_iff_right <| hs.pairwise _\n\n"}
{"name":"Set.intersecting_iff_eq_empty_of_subsingleton","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"Î± : Type u_1\ninstâœÂ² : SemilatticeInf Î±\ninstâœÂ¹ : OrderBot Î±\ninstâœ : Subsingleton Î±\ns : Set Î±\nâŠ¢ Iff s.Intersecting (Eq s EmptyCollection.emptyCollection)","decl":"theorem intersecting_iff_eq_empty_of_subsingleton [Subsingleton Î±] (s : Set Î±) :\n    s.Intersecting â†” s = âˆ… := by\n  refine\n    subsingleton_of_subsingleton.intersecting.trans\n      âŸ¨not_imp_comm.2 fun h => subsingleton_of_subsingleton.eq_singleton_of_mem ?_, ?_âŸ©\n  Â· obtain âŸ¨a, haâŸ© := nonempty_iff_ne_empty.2 h\n    rwa [Subsingleton.elim âŠ¥ a]\n  Â· rintro rfl\n    exact (Set.singleton_nonempty _).ne_empty.symm\n\n"}
{"name":"Set.Intersecting.isUpperSet","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : SemilatticeInf Î±\ninstâœ : OrderBot Î±\ns : Set Î±\nhs : s.Intersecting\nh : âˆ€ (t : Set Î±), t.Intersecting â†’ HasSubset.Subset s t â†’ Eq s t\nâŠ¢ IsUpperSet s","decl":"/-- Maximal intersecting families are upper sets. -/\nprotected theorem Intersecting.isUpperSet (hs : s.Intersecting)\n    (h : âˆ€ t : Set Î±, t.Intersecting â†’ s âŠ† t â†’ s = t) : IsUpperSet s := by\n  classical\n    rintro a b hab ha\n    rw [h (Insert.insert b s) _ (subset_insert _ _)]\n    Â· exact mem_insert _ _\n    exact\n      hs.insert (mt (eq_bot_mono hab) <| hs.ne_bot ha) fun c hc hbc => hs ha hc <| hbc.mono_left hab\n\n"}
{"name":"Set.Intersecting.isUpperSet'","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : SemilatticeInf Î±\ninstâœ : OrderBot Î±\ns : Finset Î±\nhs : (â†‘s).Intersecting\nh : âˆ€ (t : Finset Î±), (â†‘t).Intersecting â†’ HasSubset.Subset s t â†’ Eq s t\nâŠ¢ IsUpperSet â†‘s","decl":"/-- Maximal intersecting families are upper sets. Finset version. -/\ntheorem Intersecting.isUpperSet' {s : Finset Î±} (hs : (s : Set Î±).Intersecting)\n    (h : âˆ€ t : Finset Î±, (t : Set Î±).Intersecting â†’ s âŠ† t â†’ s = t) : IsUpperSet (s : Set Î±) := by\n  classical\n    rintro a b hab ha\n    rw [h (Insert.insert b s) _ (Finset.subset_insert _ _)]\n    Â· exact mem_insert_self _ _\n    rw [coe_insert]\n    exact\n      hs.insert (mt (eq_bot_mono hab) <| hs.ne_bot ha) fun c hc hbc => hs ha hc <| hbc.mono_left hab\n\n"}
{"name":"Set.Intersecting.exists_mem_set","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"Î± : Type u_1\nğ’œ : Set (Set Î±)\nhğ’œ : ğ’œ.Intersecting\ns t : Set Î±\nhs : Membership.mem ğ’œ s\nht : Membership.mem ğ’œ t\nâŠ¢ Exists fun a => And (Membership.mem s a) (Membership.mem t a)","decl":"theorem Intersecting.exists_mem_set {ğ’œ : Set (Set Î±)} (hğ’œ : ğ’œ.Intersecting) {s t : Set Î±}\n    (hs : s âˆˆ ğ’œ) (ht : t âˆˆ ğ’œ) : âˆƒ a, a âˆˆ s âˆ§ a âˆˆ t :=\n  not_disjoint_iff.1 <| hğ’œ hs ht\n\n"}
{"name":"Set.Intersecting.exists_mem_finset","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Set (Finset Î±)\nhğ’œ : ğ’œ.Intersecting\ns t : Finset Î±\nhs : Membership.mem ğ’œ s\nht : Membership.mem ğ’œ t\nâŠ¢ Exists fun a => And (Membership.mem s a) (Membership.mem t a)","decl":"theorem Intersecting.exists_mem_finset [DecidableEq Î±] {ğ’œ : Set (Finset Î±)} (hğ’œ : ğ’œ.Intersecting)\n    {s t : Finset Î±} (hs : s âˆˆ ğ’œ) (ht : t âˆˆ ğ’œ) : âˆƒ a, a âˆˆ s âˆ§ a âˆˆ t :=\n  not_disjoint_iff.1 <| disjoint_coe.not.2 <| hğ’œ hs ht\n\n"}
{"name":"Set.Intersecting.not_compl_mem","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"Î± : Type u_1\ninstâœ : BooleanAlgebra Î±\ns : Set Î±\nhs : s.Intersecting\na : Î±\nha : Membership.mem s a\nâŠ¢ Not (Membership.mem s (HasCompl.compl a))","decl":"theorem Intersecting.not_compl_mem {s : Set Î±} (hs : s.Intersecting) {a : Î±} (ha : a âˆˆ s) :\n    aá¶œ âˆ‰ s := fun h => hs ha h disjoint_compl_right\n\n"}
{"name":"Set.Intersecting.not_mem","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"Î± : Type u_1\ninstâœ : BooleanAlgebra Î±\ns : Set Î±\nhs : s.Intersecting\na : Î±\nha : Membership.mem s (HasCompl.compl a)\nâŠ¢ Not (Membership.mem s a)","decl":"theorem Intersecting.not_mem {s : Set Î±} (hs : s.Intersecting) {a : Î±} (ha : aá¶œ âˆˆ s) : a âˆ‰ s :=\n  fun h => hs ha h disjoint_compl_left\n\n"}
{"name":"Set.Intersecting.disjoint_map_compl","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"Î± : Type u_1\ninstâœ : BooleanAlgebra Î±\ns : Finset Î±\nhs : (â†‘s).Intersecting\nâŠ¢ Disjoint s (Finset.map { toFun := HasCompl.compl, inj' := â‹¯ } s)","decl":"theorem Intersecting.disjoint_map_compl {s : Finset Î±} (hs : (s : Set Î±).Intersecting) :\n    Disjoint s (s.map âŸ¨compl, compl_injectiveâŸ©) := by\n  rw [Finset.disjoint_left]\n  rintro x hx hxc\n  obtain âŸ¨x, hx', rflâŸ© := mem_map.mp hxc\n  exact hs.not_compl_mem hx' hx\n\n"}
{"name":"Set.Intersecting.card_le","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : BooleanAlgebra Î±\ninstâœ : Fintype Î±\ns : Finset Î±\nhs : (â†‘s).Intersecting\nâŠ¢ LE.le (HMul.hMul 2 s.card) (Fintype.card Î±)","decl":"theorem Intersecting.card_le [Fintype Î±] {s : Finset Î±} (hs : (s : Set Î±).Intersecting) :\n    2 * #s â‰¤ Fintype.card Î± := by\n  classical\n    refine (s.disjUnion _ hs.disjoint_map_compl).card_le_univ.trans_eq' ?_\n    rw [Nat.two_mul, card_disjUnion, card_map]\n\n"}
{"name":"Set.Intersecting.is_max_iff_card_eq","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"Î± : Type u_1\ninstâœÂ² : BooleanAlgebra Î±\ninstâœÂ¹ : Nontrivial Î±\ninstâœ : Fintype Î±\ns : Finset Î±\nhs : (â†‘s).Intersecting\nâŠ¢ Iff (âˆ€ (t : Finset Î±), (â†‘t).Intersecting â†’ HasSubset.Subset s t â†’ Eq s t) (Eq (HMul.hMul 2 s.card) (Fintype.card Î±))","decl":"theorem Intersecting.is_max_iff_card_eq (hs : (s : Set Î±).Intersecting) :\n    (âˆ€ t : Finset Î±, (t : Set Î±).Intersecting â†’ s âŠ† t â†’ s = t) â†” 2 * #s = Fintype.card Î± := by\n  classical\n    refine âŸ¨fun h â†¦ ?_, fun h t ht hst â†¦ Finset.eq_of_subset_of_card_le hst <|\n      Nat.le_of_mul_le_mul_left (ht.card_le.trans_eq h.symm) Nat.two_posâŸ©\n    suffices s.disjUnion (s.map âŸ¨compl, compl_injectiveâŸ©) hs.disjoint_map_compl = Finset.univ by\n      rw [Fintype.card, â† this, Nat.two_mul, card_disjUnion, card_map]\n    rw [â† coe_eq_univ, disjUnion_eq_union, coe_union, coe_map, Function.Embedding.coeFn_mk,\n      image_eq_preimage_of_inverse compl_compl compl_compl]\n    refine eq_univ_of_forall fun a => ?_\n    simp_rw [mem_union, mem_preimage]\n    by_contra! ha\n    refine s.ne_insert_of_not_mem _ ha.1 (h _ ?_ <| s.subset_insert _)\n    rw [coe_insert]\n    refine hs.insert ?_ fun b hb hab => ha.2 <| (hs.isUpperSet' h) hab.le_compl_left hb\n    rintro rfl\n    have := h {âŠ¤} (by rw [coe_singleton]; exact intersecting_singleton.2 top_ne_bot)\n    rw [compl_bot] at ha\n    rw [coe_eq_empty.1 ((hs.isUpperSet' h).not_top_mem.1 ha.2)] at this\n    exact Finset.singleton_ne_empty _ (this <| Finset.empty_subset _).symm\n\n"}
{"name":"Set.Intersecting.exists_card_eq","module":"Mathlib.Combinatorics.SetFamily.Intersecting","initialProofState":"Î± : Type u_1\ninstâœÂ² : BooleanAlgebra Î±\ninstâœÂ¹ : Nontrivial Î±\ninstâœ : Fintype Î±\ns : Finset Î±\nhs : (â†‘s).Intersecting\nâŠ¢ Exists fun t => And (HasSubset.Subset s t) (And (Eq (HMul.hMul 2 t.card) (Fintype.card Î±)) (â†‘t).Intersecting)","decl":"theorem Intersecting.exists_card_eq (hs : (s : Set Î±).Intersecting) :\n    âˆƒ t, s âŠ† t âˆ§ 2 * #t = Fintype.card Î± âˆ§ (t : Set Î±).Intersecting := by\n  have := hs.card_le\n  rw [mul_comm, â† Nat.le_div_iff_mul_le Nat.two_pos] at this\n  revert hs\n  refine s.strongDownwardInductionOn ?_ this\n  rintro s ih _hcard hs\n  by_cases h : âˆ€ t : Finset Î±, (t : Set Î±).Intersecting â†’ s âŠ† t â†’ s = t\n  Â· exact âŸ¨s, Subset.rfl, hs.is_max_iff_card_eq.1 h, hsâŸ©\n  push_neg at h\n  obtain âŸ¨t, ht, hstâŸ© := h\n  refine (ih ?_ (_root_.ssubset_iff_subset_ne.2 hst) ht).imp fun u => And.imp_left hst.1.trans\n  rw [Nat.le_div_iff_mul_le Nat.two_pos, mul_comm]\n  exact ht.card_le\n\n"}
