{"name":"Associates.isAtom_iff","module":"Mathlib.RingTheory.ChainOfDivisors","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\np : Associates M\nh₁ : Ne p 0\n⊢ Iff (IsAtom p) (Irreducible p)","decl":"theorem Associates.isAtom_iff {p : Associates M} (h₁ : p ≠ 0) : IsAtom p ↔ Irreducible p :=\n  ⟨fun hp =>\n    ⟨by simpa only [Associates.isUnit_iff_eq_one] using hp.1, fun a b h =>\n      (hp.le_iff.mp ⟨_, h⟩).casesOn (fun ha => Or.inl (a.isUnit_iff_eq_one.mpr ha)) fun ha =>\n        Or.inr\n          (show IsUnit b by\n            rw [ha] at h\n            apply isUnit_of_associated_mul (show Associated (p * b) p by conv_rhs => rw [h]) h₁)⟩,\n    fun hp =>\n    ⟨by simpa only [Associates.isUnit_iff_eq_one, Associates.bot_eq_one] using hp.1,\n      fun b ⟨⟨a, hab⟩, hb⟩ =>\n      (hp.isUnit_or_isUnit hab).casesOn\n        (fun hb => show b = ⊥ by rwa [Associates.isUnit_iff_eq_one, ← Associates.bot_eq_one] at hb)\n        fun ha =>\n        absurd\n          (show p ∣ b from\n            ⟨(ha.unit⁻¹ : Units _), by rw [hab, mul_assoc, IsUnit.mul_val_inv ha, mul_one]⟩)\n          hb⟩⟩\n\n"}
{"name":"DivisorChain.exists_chain_of_prime_pow","module":"Mathlib.RingTheory.ChainOfDivisors","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\np : Associates M\nn : Nat\nhn : Ne n 0\nhp : Prime p\n⊢ Exists fun c => And (Eq (c 1) p) (And (StrictMono c) (∀ {r : Associates M}, Iff (LE.le r (HPow.hPow p n)) (Exists fun i => Eq r (c i))))","decl":"theorem exists_chain_of_prime_pow {p : Associates M} {n : ℕ} (hn : n ≠ 0) (hp : Prime p) :\n    ∃ c : Fin (n + 1) → Associates M,\n      c 1 = p ∧ StrictMono c ∧ ∀ {r : Associates M}, r ≤ p ^ n ↔ ∃ i, r = c i := by\n  refine ⟨fun i => p ^ (i : ℕ), ?_, fun n m h => ?_, @fun y => ⟨fun h => ?_, ?_⟩⟩\n  · dsimp only\n    rw [Fin.val_one', Nat.mod_eq_of_lt, pow_one]\n    exact Nat.lt_succ_of_le (Nat.one_le_iff_ne_zero.mpr hn)\n  · exact Associates.dvdNotUnit_iff_lt.mp\n        ⟨pow_ne_zero n hp.ne_zero, p ^ (m - n : ℕ),\n          not_isUnit_of_not_isUnit_dvd hp.not_unit (dvd_pow dvd_rfl (Nat.sub_pos_of_lt h).ne'),\n          (pow_mul_pow_sub p h.le).symm⟩\n  · obtain ⟨i, i_le, hi⟩ := (dvd_prime_pow hp n).1 h\n    rw [associated_iff_eq] at hi\n    exact ⟨⟨i, Nat.lt_succ_of_le i_le⟩, hi⟩\n  · rintro ⟨i, rfl⟩\n    exact ⟨p ^ (n - i : ℕ), (pow_mul_pow_sub p (Nat.succ_le_succ_iff.mp i.2)).symm⟩\n\n"}
{"name":"DivisorChain.element_of_chain_not_isUnit_of_index_ne_zero","module":"Mathlib.RingTheory.ChainOfDivisors","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\nn : Nat\ni : Fin (HAdd.hAdd n 1)\ni_pos : Ne i 0\nc : Fin (HAdd.hAdd n 1) → Associates M\nh₁ : StrictMono c\n⊢ Not (IsUnit (c i))","decl":"theorem element_of_chain_not_isUnit_of_index_ne_zero {n : ℕ} {i : Fin (n + 1)} (i_pos : i ≠ 0)\n    {c : Fin (n + 1) → Associates M} (h₁ : StrictMono c) : ¬IsUnit (c i) :=\n  DvdNotUnit.not_unit\n    (Associates.dvdNotUnit_iff_lt.2\n      (h₁ <| show (0 : Fin (n + 1)) < i from Fin.pos_iff_ne_zero.mpr i_pos))\n\n"}
{"name":"DivisorChain.first_of_chain_isUnit","module":"Mathlib.RingTheory.ChainOfDivisors","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\nq : Associates M\nn : Nat\nc : Fin (HAdd.hAdd n 1) → Associates M\nh₁ : StrictMono c\nh₂ : ∀ {r : Associates M}, Iff (LE.le r q) (Exists fun i => Eq r (c i))\n⊢ IsUnit (c 0)","decl":"theorem first_of_chain_isUnit {q : Associates M} {n : ℕ} {c : Fin (n + 1) → Associates M}\n    (h₁ : StrictMono c) (h₂ : ∀ {r}, r ≤ q ↔ ∃ i, r = c i) : IsUnit (c 0) := by\n  obtain ⟨i, hr⟩ := h₂.mp Associates.one_le\n  rw [Associates.isUnit_iff_eq_one, ← Associates.le_one_iff, hr]\n  exact h₁.monotone (Fin.zero_le i)\n\n"}
{"name":"DivisorChain.second_of_chain_is_irreducible","module":"Mathlib.RingTheory.ChainOfDivisors","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\nq : Associates M\nn : Nat\nhn : Ne n 0\nc : Fin (HAdd.hAdd n 1) → Associates M\nh₁ : StrictMono c\nh₂ : ∀ {r : Associates M}, Iff (LE.le r q) (Exists fun i => Eq r (c i))\nhq : Ne q 0\n⊢ Irreducible (c 1)","decl":"/-- The second element of a chain is irreducible. -/\ntheorem second_of_chain_is_irreducible {q : Associates M} {n : ℕ} (hn : n ≠ 0)\n    {c : Fin (n + 1) → Associates M} (h₁ : StrictMono c) (h₂ : ∀ {r}, r ≤ q ↔ ∃ i, r = c i)\n    (hq : q ≠ 0) : Irreducible (c 1) := by\n  cases' n with n; · contradiction\n  refine (Associates.isAtom_iff (ne_zero_of_dvd_ne_zero hq (h₂.2 ⟨1, rfl⟩))).mp ⟨?_, fun b hb => ?_⟩\n  · exact ne_bot_of_gt (h₁ (show (0 : Fin (n + 2)) < 1 from Fin.one_pos))\n  obtain ⟨⟨i, hi⟩, rfl⟩ := h₂.1 (hb.le.trans (h₂.2 ⟨1, rfl⟩))\n  cases i\n  · exact (Associates.isUnit_iff_eq_one _).mp (first_of_chain_isUnit h₁ @h₂)\n  · simpa [Fin.lt_iff_val_lt_val] using h₁.lt_iff_lt.mp hb\n\n"}
{"name":"DivisorChain.eq_second_of_chain_of_prime_dvd","module":"Mathlib.RingTheory.ChainOfDivisors","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\np q r : Associates M\nn : Nat\nhn : Ne n 0\nc : Fin (HAdd.hAdd n 1) → Associates M\nh₁ : StrictMono c\nh₂ : ∀ {r : Associates M}, Iff (LE.le r q) (Exists fun i => Eq r (c i))\nhp : Prime p\nhr : Dvd.dvd r q\nhp' : Dvd.dvd p r\n⊢ Eq p (c 1)","decl":"theorem eq_second_of_chain_of_prime_dvd {p q r : Associates M} {n : ℕ} (hn : n ≠ 0)\n    {c : Fin (n + 1) → Associates M} (h₁ : StrictMono c)\n    (h₂ : ∀ {r : Associates M}, r ≤ q ↔ ∃ i, r = c i) (hp : Prime p) (hr : r ∣ q) (hp' : p ∣ r) :\n    p = c 1 := by\n  cases' n with n\n  · contradiction\n  obtain ⟨i, rfl⟩ := h₂.1 (dvd_trans hp' hr)\n  refine congr_arg c (eq_of_ge_of_not_gt ?_ fun hi => ?_)\n  · rw [Fin.le_iff_val_le_val, Fin.val_one, Nat.succ_le_iff, ← Fin.val_zero' (n.succ + 1), ←\n      Fin.lt_iff_val_lt_val, Fin.pos_iff_ne_zero]\n    rintro rfl\n    exact hp.not_unit (first_of_chain_isUnit h₁ @h₂)\n  obtain rfl | ⟨j, rfl⟩ := i.eq_zero_or_eq_succ\n  · cases hi\n  refine\n    not_irreducible_of_not_unit_dvdNotUnit\n      (DvdNotUnit.not_unit\n        (Associates.dvdNotUnit_iff_lt.2 (h₁ (show (0 : Fin (n + 2)) < j from ?_))))\n      ?_ hp.irreducible\n  · simpa [Fin.succ_lt_succ_iff, Fin.lt_iff_val_lt_val] using hi\n  · refine Associates.dvdNotUnit_iff_lt.2 (h₁ ?_)\n    simpa only [Fin.coe_eq_castSucc] using Fin.lt_succ\n\n"}
{"name":"DivisorChain.card_subset_divisors_le_length_of_chain","module":"Mathlib.RingTheory.ChainOfDivisors","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\nq : Associates M\nn : Nat\nc : Fin (HAdd.hAdd n 1) → Associates M\nh₂ : ∀ {r : Associates M}, Iff (LE.le r q) (Exists fun i => Eq r (c i))\nm : Finset (Associates M)\nhm : ∀ (r : Associates M), Membership.mem m r → LE.le r q\n⊢ LE.le m.card (HAdd.hAdd n 1)","decl":"theorem card_subset_divisors_le_length_of_chain {q : Associates M} {n : ℕ}\n    {c : Fin (n + 1) → Associates M} (h₂ : ∀ {r}, r ≤ q ↔ ∃ i, r = c i) {m : Finset (Associates M)}\n    (hm : ∀ r, r ∈ m → r ≤ q) : m.card ≤ n + 1 := by\n  classical\n    have mem_image : ∀ r : Associates M, r ≤ q → r ∈ Finset.univ.image c := by\n      intro r hr\n      obtain ⟨i, hi⟩ := h₂.1 hr\n      exact Finset.mem_image.2 ⟨i, Finset.mem_univ _, hi.symm⟩\n    rw [← Finset.card_fin (n + 1)]\n    exact (Finset.card_le_card fun x hx => mem_image x <| hm x hx).trans Finset.card_image_le\n\n"}
{"name":"DivisorChain.element_of_chain_eq_pow_second_of_chain","module":"Mathlib.RingTheory.ChainOfDivisors","initialProofState":"M : Type u_1\ninst✝¹ : CancelCommMonoidWithZero M\ninst✝ : UniqueFactorizationMonoid M\nq r : Associates M\nn : Nat\nhn : Ne n 0\nc : Fin (HAdd.hAdd n 1) → Associates M\nh₁ : StrictMono c\nh₂ : ∀ {r : Associates M}, Iff (LE.le r q) (Exists fun i => Eq r (c i))\nhr : Dvd.dvd r q\nhq : Ne q 0\n⊢ Exists fun i => Eq r (HPow.hPow (c 1) ↑i)","decl":"theorem element_of_chain_eq_pow_second_of_chain {q r : Associates M} {n : ℕ} (hn : n ≠ 0)\n    {c : Fin (n + 1) → Associates M} (h₁ : StrictMono c) (h₂ : ∀ {r}, r ≤ q ↔ ∃ i, r = c i)\n    (hr : r ∣ q) (hq : q ≠ 0) : ∃ i : Fin (n + 1), r = c 1 ^ (i : ℕ) := by\n  classical\n    let i := Multiset.card (normalizedFactors r)\n    have hi : normalizedFactors r = Multiset.replicate i (c 1) := by\n      apply Multiset.eq_replicate_of_mem\n      intro b hb\n      refine\n        eq_second_of_chain_of_prime_dvd hn h₁ (@fun r' => h₂) (prime_of_normalized_factor b hb) hr\n          (dvd_of_mem_normalizedFactors hb)\n    have H : r = c 1 ^ i := by\n      have := UniqueFactorizationMonoid.prod_normalizedFactors (ne_zero_of_dvd_ne_zero hq hr)\n      rw [associated_iff_eq, hi, Multiset.prod_replicate] at this\n      rw [this]\n    refine ⟨⟨i, ?_⟩, H⟩\n    have : (Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ℕ)).card = i + 1 := by\n      conv_rhs => rw [← Finset.card_fin (i + 1)]\n      cases n\n      · contradiction\n      rw [Finset.card_image_iff]\n      refine Set.injOn_of_injective (fun m m' h => Fin.ext ?_)\n      refine\n        pow_injective_of_not_isUnit (element_of_chain_not_isUnit_of_index_ne_zero (by simp) h₁) ?_ h\n      exact Irreducible.ne_zero (second_of_chain_is_irreducible hn h₁ (@h₂) hq)\n    suffices H' : ∀ r ∈ Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ℕ), r ≤ q by\n      simp only [← Nat.succ_le_iff, Nat.succ_eq_add_one, ← this]\n      apply card_subset_divisors_le_length_of_chain (@h₂) H'\n    simp only [Finset.mem_image]\n    rintro r ⟨a, _, rfl⟩\n    refine dvd_trans ?_ hr\n    use c 1 ^ (i - (a : ℕ))\n    rw [pow_mul_pow_sub (c 1)]\n    · exact H\n    · exact Nat.succ_le_succ_iff.mp a.2\n\n"}
{"name":"DivisorChain.eq_pow_second_of_chain_of_has_chain","module":"Mathlib.RingTheory.ChainOfDivisors","initialProofState":"M : Type u_1\ninst✝¹ : CancelCommMonoidWithZero M\ninst✝ : UniqueFactorizationMonoid M\nq : Associates M\nn : Nat\nhn : Ne n 0\nc : Fin (HAdd.hAdd n 1) → Associates M\nh₁ : StrictMono c\nh₂ : ∀ {r : Associates M}, Iff (LE.le r q) (Exists fun i => Eq r (c i))\nhq : Ne q 0\n⊢ Eq q (HPow.hPow (c 1) n)","decl":"theorem eq_pow_second_of_chain_of_has_chain {q : Associates M} {n : ℕ} (hn : n ≠ 0)\n    {c : Fin (n + 1) → Associates M} (h₁ : StrictMono c)\n    (h₂ : ∀ {r : Associates M}, r ≤ q ↔ ∃ i, r = c i) (hq : q ≠ 0) : q = c 1 ^ n := by\n  classical\n    obtain ⟨i, hi'⟩ := element_of_chain_eq_pow_second_of_chain hn h₁ (@fun r => h₂) (dvd_refl q) hq\n    convert hi'\n    refine (Nat.lt_succ_iff.1 i.prop).antisymm' (Nat.le_of_succ_le_succ ?_)\n    calc\n      n + 1 = (Finset.univ : Finset (Fin (n + 1))).card := (Finset.card_fin _).symm\n      _ = (Finset.univ.image c).card := (Finset.card_image_iff.mpr h₁.injective.injOn).symm\n      _ ≤ (Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ℕ)).card :=\n        (Finset.card_le_card ?_)\n      _ ≤ (Finset.univ : Finset (Fin (i + 1))).card := Finset.card_image_le\n      _ = i + 1 := Finset.card_fin _\n    intro r hr\n    obtain ⟨j, -, rfl⟩ := Finset.mem_image.1 hr\n    have := h₂.2 ⟨j, rfl⟩\n    rw [hi'] at this\n    have h := (dvd_prime_pow (show Prime (c 1) from ?_) i).1 this\n    · rcases h with ⟨u, hu, hu'⟩\n      refine Finset.mem_image.mpr ⟨u, Finset.mem_univ _, ?_⟩\n      rw [associated_iff_eq] at hu'\n      rw [Fin.val_cast_of_lt (Nat.lt_succ_of_le hu), hu']\n    · rw [← irreducible_iff_prime]\n      exact second_of_chain_is_irreducible hn h₁ (@h₂) hq\n\n"}
{"name":"DivisorChain.isPrimePow_of_has_chain","module":"Mathlib.RingTheory.ChainOfDivisors","initialProofState":"M : Type u_1\ninst✝¹ : CancelCommMonoidWithZero M\ninst✝ : UniqueFactorizationMonoid M\nq : Associates M\nn : Nat\nhn : Ne n 0\nc : Fin (HAdd.hAdd n 1) → Associates M\nh₁ : StrictMono c\nh₂ : ∀ {r : Associates M}, Iff (LE.le r q) (Exists fun i => Eq r (c i))\nhq : Ne q 0\n⊢ IsPrimePow q","decl":"theorem isPrimePow_of_has_chain {q : Associates M} {n : ℕ} (hn : n ≠ 0)\n    {c : Fin (n + 1) → Associates M} (h₁ : StrictMono c)\n    (h₂ : ∀ {r : Associates M}, r ≤ q ↔ ∃ i, r = c i) (hq : q ≠ 0) : IsPrimePow q :=\n  ⟨c 1, n, irreducible_iff_prime.mp (second_of_chain_is_irreducible hn h₁ (@h₂) hq),\n    zero_lt_iff.mpr hn, (eq_pow_second_of_chain_of_has_chain hn h₁ (@h₂) hq).symm⟩\n\n"}
{"name":"factor_orderIso_map_one_eq_bot","module":"Mathlib.RingTheory.ChainOfDivisors","initialProofState":"M : Type u_1\ninst✝¹ : CancelCommMonoidWithZero M\nN : Type u_2\ninst✝ : CancelCommMonoidWithZero N\nm : Associates M\nn : Associates N\nd : OrderIso (Subtype fun l => LE.le l m) (Subtype fun l => LE.le l n)\n⊢ Eq (↑(d ⟨1, ⋯⟩)) 1","decl":"theorem factor_orderIso_map_one_eq_bot {m : Associates M} {n : Associates N}\n    (d : { l : Associates M // l ≤ m } ≃o { l : Associates N // l ≤ n }) :\n    (d ⟨1, one_dvd m⟩ : Associates N) = 1 := by\n  letI : OrderBot { l : Associates M // l ≤ m } := Subtype.orderBot bot_le\n  letI : OrderBot { l : Associates N // l ≤ n } := Subtype.orderBot bot_le\n  simp only [← Associates.bot_eq_one, Subtype.mk_bot, bot_le, Subtype.coe_eq_bot_iff]\n  letI : BotHomClass ({ l // l ≤ m } ≃o { l // l ≤ n }) _ _ := OrderIsoClass.toBotHomClass\n  exact map_bot d\n\n"}
{"name":"coe_factor_orderIso_map_eq_one_iff","module":"Mathlib.RingTheory.ChainOfDivisors","initialProofState":"M : Type u_1\ninst✝¹ : CancelCommMonoidWithZero M\nN : Type u_2\ninst✝ : CancelCommMonoidWithZero N\nm u : Associates M\nn : Associates N\nhu' : LE.le u m\nd : OrderIso ↑(Set.Iic m) ↑(Set.Iic n)\n⊢ Iff (Eq (↑(d ⟨u, hu'⟩)) 1) (Eq u 1)","decl":"theorem coe_factor_orderIso_map_eq_one_iff {m u : Associates M} {n : Associates N} (hu' : u ≤ m)\n    (d : Set.Iic m ≃o Set.Iic n) : (d ⟨u, hu'⟩ : Associates N) = 1 ↔ u = 1 :=\n  ⟨fun hu => by\n    rw [show u = (d.symm ⟨d ⟨u, hu'⟩, (d ⟨u, hu'⟩).prop⟩) by\n        simp only [Subtype.coe_eta, OrderIso.symm_apply_apply, Subtype.coe_mk]]\n    conv_rhs => rw [← factor_orderIso_map_one_eq_bot d.symm]\n    congr, fun hu => by\n    simp_rw [hu]\n    conv_rhs => rw [← factor_orderIso_map_one_eq_bot d]\n    rfl⟩\n\n"}
{"name":"pow_image_of_prime_by_factor_orderIso_dvd","module":"Mathlib.RingTheory.ChainOfDivisors","initialProofState":"M : Type u_1\ninst✝³ : CancelCommMonoidWithZero M\nN : Type u_2\ninst✝² : CancelCommMonoidWithZero N\ninst✝¹ : UniqueFactorizationMonoid N\ninst✝ : UniqueFactorizationMonoid M\nm p : Associates M\nn : Associates N\nhn : Ne n 0\nhp : Membership.mem (UniqueFactorizationMonoid.normalizedFactors m) p\nd : OrderIso ↑(Set.Iic m) ↑(Set.Iic n)\ns : Nat\nhs' : LE.le (HPow.hPow p s) m\n⊢ LE.le (HPow.hPow (↑(d ⟨p, ⋯⟩)) s) n","decl":"theorem pow_image_of_prime_by_factor_orderIso_dvd\n    {m p : Associates M} {n : Associates N} (hn : n ≠ 0) (hp : p ∈ normalizedFactors m)\n    (d : Set.Iic m ≃o Set.Iic n) {s : ℕ} (hs' : p ^ s ≤ m) :\n    (d ⟨p, dvd_of_mem_normalizedFactors hp⟩ : Associates N) ^ s ≤ n := by\n  by_cases hs : s = 0\n  · simp [← Associates.bot_eq_one, hs]\n  suffices (d ⟨p, dvd_of_mem_normalizedFactors hp⟩ : Associates N) ^ s =\n      (d ⟨p ^ s, hs'⟩) by\n    rw [this]\n    apply Subtype.prop (d ⟨p ^ s, hs'⟩)\n  obtain ⟨c₁, rfl, hc₁', hc₁''⟩ := exists_chain_of_prime_pow hs (prime_of_normalized_factor p hp)\n  let c₂ : Fin (s + 1) → Associates N := fun t => d ⟨c₁ t, le_trans (hc₁''.2 ⟨t, by simp⟩) hs'⟩\n  have c₂_def : ∀ t, c₂ t = d ⟨c₁ t, _⟩ := fun t => rfl\n  rw [← c₂_def]\n  refine (eq_pow_second_of_chain_of_has_chain hs (fun t u h => ?_)\n    (@fun r => ⟨@fun hr => ?_, ?_⟩) ?_).symm\n  · rw [c₂_def, c₂_def, Subtype.coe_lt_coe, d.lt_iff_lt, Subtype.mk_lt_mk, hc₁'.lt_iff_lt]\n    exact h\n  · have : r ≤ n := hr.trans (d ⟨c₁ 1 ^ s, _⟩).2\n    suffices d.symm ⟨r, this⟩ ≤ ⟨c₁ 1 ^ s, hs'⟩ by\n      obtain ⟨i, hi⟩ := hc₁''.1 this\n      use i\n      simp only [c₂_def, ← hi, d.apply_symm_apply, Subtype.coe_eta, Subtype.coe_mk]\n    conv_rhs => rw [← d.symm_apply_apply ⟨c₁ 1 ^ s, hs'⟩]\n    rw [d.symm.le_iff_le]\n    simpa only [← Subtype.coe_le_coe, Subtype.coe_mk] using hr\n  · rintro ⟨i, hr⟩\n    rw [hr, c₂_def, Subtype.coe_le_coe, d.le_iff_le]\n    simpa [Subtype.mk_le_mk] using hc₁''.2 ⟨i, rfl⟩\n  exact ne_zero_of_dvd_ne_zero hn (Subtype.prop (d ⟨c₁ 1 ^ s, _⟩))\n\n"}
{"name":"map_prime_of_factor_orderIso","module":"Mathlib.RingTheory.ChainOfDivisors","initialProofState":"M : Type u_1\ninst✝³ : CancelCommMonoidWithZero M\nN : Type u_2\ninst✝² : CancelCommMonoidWithZero N\ninst✝¹ : UniqueFactorizationMonoid N\ninst✝ : UniqueFactorizationMonoid M\nm p : Associates M\nn : Associates N\nhn : Ne n 0\nhp : Membership.mem (UniqueFactorizationMonoid.normalizedFactors m) p\nd : OrderIso ↑(Set.Iic m) ↑(Set.Iic n)\n⊢ Prime ↑(d ⟨p, ⋯⟩)","decl":"theorem map_prime_of_factor_orderIso {m p : Associates M} {n : Associates N} (hn : n ≠ 0)\n    (hp : p ∈ normalizedFactors m) (d : Set.Iic m ≃o Set.Iic n) :\n    Prime (d ⟨p, dvd_of_mem_normalizedFactors hp⟩ : Associates N) := by\n  rw [← irreducible_iff_prime]\n  refine (Associates.isAtom_iff <|\n    ne_zero_of_dvd_ne_zero hn (d ⟨p, _⟩).prop).mp ⟨?_, fun b hb => ?_⟩\n  · rw [Ne, ← Associates.isUnit_iff_eq_bot, Associates.isUnit_iff_eq_one,\n      coe_factor_orderIso_map_eq_one_iff _ d]\n    rintro rfl\n    exact (prime_of_normalized_factor 1 hp).not_unit isUnit_one\n  · obtain ⟨x, hx⟩ :=\n      d.surjective ⟨b, le_trans (le_of_lt hb) (d ⟨p, dvd_of_mem_normalizedFactors hp⟩).prop⟩\n    rw [← Subtype.coe_mk b _, ← hx] at hb\n    letI : OrderBot { l : Associates M // l ≤ m } := Subtype.orderBot bot_le\n    letI : OrderBot { l : Associates N // l ≤ n } := Subtype.orderBot bot_le\n    suffices x = ⊥ by\n      rw [this, OrderIso.map_bot d] at hx\n      refine (Subtype.mk_eq_bot_iff ?_ _).mp hx.symm\n      simp\n    obtain ⟨a, ha⟩ := x\n    rw [Subtype.mk_eq_bot_iff]\n    · exact\n        ((Associates.isAtom_iff <| Prime.ne_zero <| prime_of_normalized_factor p hp).mpr <|\n              irreducible_of_normalized_factor p hp).right\n          a (Subtype.mk_lt_mk.mp <| d.lt_iff_lt.mp hb)\n    simp\n\n"}
{"name":"mem_normalizedFactors_factor_orderIso_of_mem_normalizedFactors","module":"Mathlib.RingTheory.ChainOfDivisors","initialProofState":"M : Type u_1\ninst✝³ : CancelCommMonoidWithZero M\nN : Type u_2\ninst✝² : CancelCommMonoidWithZero N\ninst✝¹ : UniqueFactorizationMonoid N\ninst✝ : UniqueFactorizationMonoid M\nm p : Associates M\nn : Associates N\nhn : Ne n 0\nhp : Membership.mem (UniqueFactorizationMonoid.normalizedFactors m) p\nd : OrderIso ↑(Set.Iic m) ↑(Set.Iic n)\n⊢ Membership.mem (UniqueFactorizationMonoid.normalizedFactors n) ↑(d ⟨p, ⋯⟩)","decl":"theorem mem_normalizedFactors_factor_orderIso_of_mem_normalizedFactors {m p : Associates M}\n    {n : Associates N} (hn : n ≠ 0) (hp : p ∈ normalizedFactors m) (d : Set.Iic m ≃o Set.Iic n) :\n    (d ⟨p, dvd_of_mem_normalizedFactors hp⟩ : Associates N) ∈ normalizedFactors n := by\n  obtain ⟨q, hq, hq'⟩ :=\n    exists_mem_normalizedFactors_of_dvd hn (map_prime_of_factor_orderIso hn hp d).irreducible\n      (d ⟨p, dvd_of_mem_normalizedFactors hp⟩).prop\n  rw [associated_iff_eq] at hq'\n  rwa [hq']\n\n"}
{"name":"emultiplicity_prime_le_emultiplicity_image_by_factor_orderIso","module":"Mathlib.RingTheory.ChainOfDivisors","initialProofState":"M : Type u_1\ninst✝³ : CancelCommMonoidWithZero M\nN : Type u_2\ninst✝² : CancelCommMonoidWithZero N\ninst✝¹ : UniqueFactorizationMonoid N\ninst✝ : UniqueFactorizationMonoid M\nm p : Associates M\nn : Associates N\nhp : Membership.mem (UniqueFactorizationMonoid.normalizedFactors m) p\nd : OrderIso ↑(Set.Iic m) ↑(Set.Iic n)\n⊢ LE.le (emultiplicity p m) (emultiplicity (↑(d ⟨p, ⋯⟩)) n)","decl":"theorem emultiplicity_prime_le_emultiplicity_image_by_factor_orderIso {m p : Associates M}\n    {n : Associates N} (hp : p ∈ normalizedFactors m) (d : Set.Iic m ≃o Set.Iic n) :\n    emultiplicity p m ≤ emultiplicity (↑(d ⟨p, dvd_of_mem_normalizedFactors hp⟩)) n := by\n  by_cases hn : n = 0\n  · simp [hn]\n  by_cases hm : m = 0\n  · simp [hm] at hp\n  rw [FiniteMultiplicity.of_prime_left (prime_of_normalized_factor p hp) hm\n    |>.emultiplicity_eq_multiplicity, ← pow_dvd_iff_le_emultiplicity]\n  apply pow_image_of_prime_by_factor_orderIso_dvd hn hp d (pow_multiplicity_dvd ..)\n\n"}
{"name":"emultiplicity_prime_eq_emultiplicity_image_by_factor_orderIso","module":"Mathlib.RingTheory.ChainOfDivisors","initialProofState":"M : Type u_1\ninst✝³ : CancelCommMonoidWithZero M\nN : Type u_2\ninst✝² : CancelCommMonoidWithZero N\ninst✝¹ : UniqueFactorizationMonoid N\ninst✝ : UniqueFactorizationMonoid M\nm p : Associates M\nn : Associates N\nhn : Ne n 0\nhp : Membership.mem (UniqueFactorizationMonoid.normalizedFactors m) p\nd : OrderIso ↑(Set.Iic m) ↑(Set.Iic n)\n⊢ Eq (emultiplicity p m) (emultiplicity (↑(d ⟨p, ⋯⟩)) n)","decl":"theorem emultiplicity_prime_eq_emultiplicity_image_by_factor_orderIso {m p : Associates M}\n    {n : Associates N} (hn : n ≠ 0) (hp : p ∈ normalizedFactors m) (d : Set.Iic m ≃o Set.Iic n) :\n    emultiplicity p m = emultiplicity (↑(d ⟨p, dvd_of_mem_normalizedFactors hp⟩)) n := by\n  refine le_antisymm (emultiplicity_prime_le_emultiplicity_image_by_factor_orderIso hp d) ?_\n  suffices emultiplicity (↑(d ⟨p, dvd_of_mem_normalizedFactors hp⟩)) n ≤\n      emultiplicity (↑(d.symm (d ⟨p, dvd_of_mem_normalizedFactors hp⟩))) m by\n    rw [d.symm_apply_apply ⟨p, dvd_of_mem_normalizedFactors hp⟩, Subtype.coe_mk] at this\n    exact this\n  letI := Classical.decEq (Associates N)\n  simpa only [Subtype.coe_eta] using\n    emultiplicity_prime_le_emultiplicity_image_by_factor_orderIso\n      (mem_normalizedFactors_factor_orderIso_of_mem_normalizedFactors hn hp d) d.symm\n\n"}
{"name":"mkFactorOrderIsoOfFactorDvdEquiv_symm_apply_coe","module":"Mathlib.RingTheory.ChainOfDivisors","initialProofState":"M : Type u_1\ninst✝³ : CancelCommMonoidWithZero M\nN : Type u_2\ninst✝² : CancelCommMonoidWithZero N\ninst✝¹ : Subsingleton (Units M)\ninst✝ : Subsingleton (Units N)\nm : M\nn : N\nd : Equiv (Subtype fun l => Dvd.dvd l m) (Subtype fun l => Dvd.dvd l n)\nhd : ∀ (l l' : Subtype fun l => Dvd.dvd l m), Iff (Dvd.dvd ↑(d l) ↑(d l')) (Dvd.dvd ↑l ↑l')\nl : ↑(Set.Iic (Associates.mk n))\n⊢ Eq (↑((RelIso.symm (mkFactorOrderIsoOfFactorDvdEquiv hd)) l)) (Associates.mk ↑(d.symm ⟨associatesEquivOfUniqueUnits ↑l, ⋯⟩))","decl":"/-- The order isomorphism between the factors of `mk m` and the factors of `mk n` induced by a\n  bijection between the factors of `m` and the factors of `n` that preserves `∣`. -/\n@[simps]\ndef mkFactorOrderIsoOfFactorDvdEquiv {m : M} {n : N} {d : { l : M // l ∣ m } ≃ { l : N // l ∣ n }}\n    (hd : ∀ l l', (d l : N) ∣ d l' ↔ (l : M) ∣ (l' : M)) :\n    Set.Iic (Associates.mk m) ≃o Set.Iic (Associates.mk n) where\n  toFun l :=\n    ⟨Associates.mk\n        (d\n          ⟨associatesEquivOfUniqueUnits ↑l, by\n            obtain ⟨x, hx⟩ := l\n            rw [Subtype.coe_mk, associatesEquivOfUniqueUnits_apply, out_dvd_iff]\n            exact hx⟩),\n      mk_le_mk_iff_dvd.mpr (Subtype.prop (d ⟨associatesEquivOfUniqueUnits ↑l, _⟩))⟩\n  invFun l :=\n    ⟨Associates.mk\n        (d.symm\n          ⟨associatesEquivOfUniqueUnits ↑l, by\n            obtain ⟨x, hx⟩ := l\n            rw [Subtype.coe_mk, associatesEquivOfUniqueUnits_apply, out_dvd_iff]\n            exact hx⟩),\n      mk_le_mk_iff_dvd.mpr (Subtype.prop (d.symm ⟨associatesEquivOfUniqueUnits ↑l, _⟩))⟩\n  left_inv := fun ⟨l, hl⟩ => by\n    simp only [Subtype.coe_eta, Equiv.symm_apply_apply, Subtype.coe_mk,\n      associatesEquivOfUniqueUnits_apply, mk_out, out_mk, normalize_eq]\n  right_inv := fun ⟨l, hl⟩ => by\n    simp only [Subtype.coe_eta, Equiv.apply_symm_apply, Subtype.coe_mk,\n      associatesEquivOfUniqueUnits_apply, out_mk, normalize_eq, mk_out]\n  map_rel_iff' := by\n    rintro ⟨a, ha⟩ ⟨b, hb⟩\n    simp only [Equiv.coe_fn_mk, Subtype.mk_le_mk, Associates.mk_le_mk_iff_dvd, hd,\n        Subtype.coe_mk, associatesEquivOfUniqueUnits_apply, out_dvd_iff, mk_out]\n\n"}
{"name":"mkFactorOrderIsoOfFactorDvdEquiv_apply_coe","module":"Mathlib.RingTheory.ChainOfDivisors","initialProofState":"M : Type u_1\ninst✝³ : CancelCommMonoidWithZero M\nN : Type u_2\ninst✝² : CancelCommMonoidWithZero N\ninst✝¹ : Subsingleton (Units M)\ninst✝ : Subsingleton (Units N)\nm : M\nn : N\nd : Equiv (Subtype fun l => Dvd.dvd l m) (Subtype fun l => Dvd.dvd l n)\nhd : ∀ (l l' : Subtype fun l => Dvd.dvd l m), Iff (Dvd.dvd ↑(d l) ↑(d l')) (Dvd.dvd ↑l ↑l')\nl : ↑(Set.Iic (Associates.mk m))\n⊢ Eq (↑((mkFactorOrderIsoOfFactorDvdEquiv hd) l)) (Associates.mk ↑(d ⟨associatesEquivOfUniqueUnits ↑l, ⋯⟩))","decl":"/-- The order isomorphism between the factors of `mk m` and the factors of `mk n` induced by a\n  bijection between the factors of `m` and the factors of `n` that preserves `∣`. -/\n@[simps]\ndef mkFactorOrderIsoOfFactorDvdEquiv {m : M} {n : N} {d : { l : M // l ∣ m } ≃ { l : N // l ∣ n }}\n    (hd : ∀ l l', (d l : N) ∣ d l' ↔ (l : M) ∣ (l' : M)) :\n    Set.Iic (Associates.mk m) ≃o Set.Iic (Associates.mk n) where\n  toFun l :=\n    ⟨Associates.mk\n        (d\n          ⟨associatesEquivOfUniqueUnits ↑l, by\n            obtain ⟨x, hx⟩ := l\n            rw [Subtype.coe_mk, associatesEquivOfUniqueUnits_apply, out_dvd_iff]\n            exact hx⟩),\n      mk_le_mk_iff_dvd.mpr (Subtype.prop (d ⟨associatesEquivOfUniqueUnits ↑l, _⟩))⟩\n  invFun l :=\n    ⟨Associates.mk\n        (d.symm\n          ⟨associatesEquivOfUniqueUnits ↑l, by\n            obtain ⟨x, hx⟩ := l\n            rw [Subtype.coe_mk, associatesEquivOfUniqueUnits_apply, out_dvd_iff]\n            exact hx⟩),\n      mk_le_mk_iff_dvd.mpr (Subtype.prop (d.symm ⟨associatesEquivOfUniqueUnits ↑l, _⟩))⟩\n  left_inv := fun ⟨l, hl⟩ => by\n    simp only [Subtype.coe_eta, Equiv.symm_apply_apply, Subtype.coe_mk,\n      associatesEquivOfUniqueUnits_apply, mk_out, out_mk, normalize_eq]\n  right_inv := fun ⟨l, hl⟩ => by\n    simp only [Subtype.coe_eta, Equiv.apply_symm_apply, Subtype.coe_mk,\n      associatesEquivOfUniqueUnits_apply, out_mk, normalize_eq, mk_out]\n  map_rel_iff' := by\n    rintro ⟨a, ha⟩ ⟨b, hb⟩\n    simp only [Equiv.coe_fn_mk, Subtype.mk_le_mk, Associates.mk_le_mk_iff_dvd, hd,\n        Subtype.coe_mk, associatesEquivOfUniqueUnits_apply, out_dvd_iff, mk_out]\n\n"}
{"name":"mem_normalizedFactors_factor_dvd_iso_of_mem_normalizedFactors","module":"Mathlib.RingTheory.ChainOfDivisors","initialProofState":"M : Type u_1\ninst✝⁵ : CancelCommMonoidWithZero M\nN : Type u_2\ninst✝⁴ : CancelCommMonoidWithZero N\ninst✝³ : Subsingleton (Units M)\ninst✝² : Subsingleton (Units N)\ninst✝¹ : UniqueFactorizationMonoid M\ninst✝ : UniqueFactorizationMonoid N\nm p : M\nn : N\nhm : Ne m 0\nhn : Ne n 0\nhp : Membership.mem (UniqueFactorizationMonoid.normalizedFactors m) p\nd : Equiv (Subtype fun l => Dvd.dvd l m) (Subtype fun l => Dvd.dvd l n)\nhd : ∀ (l l' : Subtype fun l => Dvd.dvd l m), Iff (Dvd.dvd ↑(d l) ↑(d l')) (Dvd.dvd ↑l ↑l')\n⊢ Membership.mem (UniqueFactorizationMonoid.normalizedFactors n) ↑(d ⟨p, ⋯⟩)","decl":"theorem mem_normalizedFactors_factor_dvd_iso_of_mem_normalizedFactors {m p : M} {n : N} (hm : m ≠ 0)\n    (hn : n ≠ 0) (hp : p ∈ normalizedFactors m) {d : { l : M // l ∣ m } ≃ { l : N // l ∣ n }}\n    (hd : ∀ l l', (d l : N) ∣ d l' ↔ (l : M) ∣ (l' : M)) :\n    ↑(d ⟨p, dvd_of_mem_normalizedFactors hp⟩) ∈ normalizedFactors n := by\n  suffices\n    Prime (d ⟨associatesEquivOfUniqueUnits (associatesEquivOfUniqueUnits.symm p), by\n            simp [dvd_of_mem_normalizedFactors hp]⟩ : N) by\n    simp only [associatesEquivOfUniqueUnits_apply, out_mk, normalize_eq,\n      associatesEquivOfUniqueUnits_symm_apply] at this\n    obtain ⟨q, hq, hq'⟩ :=\n      exists_mem_normalizedFactors_of_dvd hn this.irreducible\n        (d ⟨p, by apply dvd_of_mem_normalizedFactors; convert hp⟩).prop\n    rwa [associated_iff_eq.mp hq']\n  have :\n    Associates.mk\n        (d ⟨associatesEquivOfUniqueUnits (associatesEquivOfUniqueUnits.symm p), by\n              simp only [dvd_of_mem_normalizedFactors hp, associatesEquivOfUniqueUnits_apply,\n                out_mk, normalize_eq, associatesEquivOfUniqueUnits_symm_apply]⟩ : N) =\n      ↑(mkFactorOrderIsoOfFactorDvdEquiv hd\n          ⟨associatesEquivOfUniqueUnits.symm p, by\n            simp only [associatesEquivOfUniqueUnits_symm_apply]\n            exact mk_dvd_mk.mpr (dvd_of_mem_normalizedFactors hp)⟩) := by\n    rw [mkFactorOrderIsoOfFactorDvdEquiv_apply_coe]\n  rw [← Associates.prime_mk, this]\n  letI := Classical.decEq (Associates M)\n  refine map_prime_of_factor_orderIso (mk_ne_zero.mpr hn) ?_ _\n  obtain ⟨q, hq, hq'⟩ :=\n    exists_mem_normalizedFactors_of_dvd (mk_ne_zero.mpr hm)\n      (prime_mk.mpr (prime_of_normalized_factor p (by convert hp))).irreducible\n      (mk_le_mk_of_dvd (dvd_of_mem_normalizedFactors hp))\n  simpa only [associated_iff_eq.mp hq', associatesEquivOfUniqueUnits_symm_apply] using hq\n\n"}
{"name":"emultiplicity_factor_dvd_iso_eq_emultiplicity_of_mem_normalizedFactors","module":"Mathlib.RingTheory.ChainOfDivisors","initialProofState":"M : Type u_1\ninst✝⁵ : CancelCommMonoidWithZero M\nN : Type u_2\ninst✝⁴ : CancelCommMonoidWithZero N\ninst✝³ : Subsingleton (Units M)\ninst✝² : Subsingleton (Units N)\ninst✝¹ : UniqueFactorizationMonoid M\ninst✝ : UniqueFactorizationMonoid N\nm p : M\nn : N\nhm : Ne m 0\nhn : Ne n 0\nhp : Membership.mem (UniqueFactorizationMonoid.normalizedFactors m) p\nd : Equiv (Subtype fun l => Dvd.dvd l m) (Subtype fun l => Dvd.dvd l n)\nhd : ∀ (l l' : Subtype fun l => Dvd.dvd l m), Iff (Dvd.dvd ↑(d l) ↑(d l')) (Dvd.dvd ↑l ↑l')\n⊢ Eq (emultiplicity (↑(d ⟨p, ⋯⟩)) n) (emultiplicity p m)","decl":"theorem emultiplicity_factor_dvd_iso_eq_emultiplicity_of_mem_normalizedFactors {m p : M} {n : N}\n    (hm : m ≠ 0) (hn : n ≠ 0) (hp : p ∈ normalizedFactors m)\n    {d : { l : M // l ∣ m } ≃ { l : N // l ∣ n }} (hd : ∀ l l', (d l : N) ∣ d l' ↔ (l : M) ∣ l') :\n    emultiplicity (d ⟨p, dvd_of_mem_normalizedFactors hp⟩ : N) n = emultiplicity p m := by\n  apply Eq.symm\n  suffices emultiplicity (Associates.mk p) (Associates.mk m) = emultiplicity (Associates.mk\n    ↑(d ⟨associatesEquivOfUniqueUnits (associatesEquivOfUniqueUnits.symm p), by\n      simp [dvd_of_mem_normalizedFactors hp]⟩)) (Associates.mk n) by\n    simpa only [emultiplicity_mk_eq_emultiplicity, associatesEquivOfUniqueUnits_symm_apply,\n      associatesEquivOfUniqueUnits_apply, out_mk, normalize_eq] using this\n  have : Associates.mk (d ⟨associatesEquivOfUniqueUnits (associatesEquivOfUniqueUnits.symm p), by\n    simp only [dvd_of_mem_normalizedFactors hp, associatesEquivOfUniqueUnits_symm_apply,\n      associatesEquivOfUniqueUnits_apply, out_mk, normalize_eq]⟩ : N) =\n    ↑(mkFactorOrderIsoOfFactorDvdEquiv hd ⟨associatesEquivOfUniqueUnits.symm p, by\n      rw [associatesEquivOfUniqueUnits_symm_apply]\n      exact mk_le_mk_of_dvd (dvd_of_mem_normalizedFactors hp)⟩) := by\n    rw [mkFactorOrderIsoOfFactorDvdEquiv_apply_coe]\n  rw [this]\n  refine\n    emultiplicity_prime_eq_emultiplicity_image_by_factor_orderIso (mk_ne_zero.mpr hn) ?_\n      (mkFactorOrderIsoOfFactorDvdEquiv hd)\n  obtain ⟨q, hq, hq'⟩ :=\n    exists_mem_normalizedFactors_of_dvd (mk_ne_zero.mpr hm)\n      (prime_mk.mpr (prime_of_normalized_factor p hp)).irreducible\n      (mk_le_mk_of_dvd (dvd_of_mem_normalizedFactors hp))\n  rwa [associated_iff_eq.mp hq']\n"}
