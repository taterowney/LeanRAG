{"name":"SemistandardYoungTableau.mk.sizeOf_spec","module":"Mathlib.Combinatorics.Young.SemistandardTableau","initialProofState":"μ : YoungDiagram\nentry : Nat → Nat → Nat\nrow_weak' : ∀ {i j1 j2 : Nat}, LT.lt j1 j2 → Membership.mem μ { fst := i, snd := j2 } → LE.le (entry i j1) (entry i j2)\ncol_strict' : ∀ {i1 i2 j : Nat}, LT.lt i1 i2 → Membership.mem μ { fst := i2, snd := j } → LT.lt (entry i1 j) (entry i2 j)\nzeros' : ∀ {i j : Nat}, Not (Membership.mem μ { fst := i, snd := j }) → Eq (entry i j) 0\n⊢ Eq (SizeOf.sizeOf { entry := entry, row_weak' := row_weak', col_strict' := col_strict', zeros' := zeros' }) 1","decl":"/-- A semistandard Young tableau is a filling of the cells of a Young diagram by natural\nnumbers, such that the entries in each row are weakly increasing (left to right), and the entries\nin each column are strictly increasing (top to bottom).\n\nHere, a semistandard Young tableau is represented as an unrestricted function `ℕ → ℕ → ℕ` that, for\nreasons of extensionality, is required to vanish outside `μ`. -/\nstructure SemistandardYoungTableau (μ : YoungDiagram) where\n  /-- `entry i j` is value of the `(i, j)` entry of the SSYT `μ`. -/\n  entry : ℕ → ℕ → ℕ\n  /-- The entries in each row are weakly increasing (left to right). -/\n  row_weak' : ∀ {i j1 j2 : ℕ}, j1 < j2 → (i, j2) ∈ μ → entry i j1 ≤ entry i j2\n  /-- The entries in each column are strictly increasing (top to bottom). -/\n  col_strict' : ∀ {i1 i2 j : ℕ}, i1 < i2 → (i2, j) ∈ μ → entry i1 j < entry i2 j\n  /-- `entry` is required to be zero for all pairs `(i, j) ∉ μ`. -/\n  zeros' : ∀ {i j}, (i, j) ∉ μ → entry i j = 0\n\n"}
{"name":"SemistandardYoungTableau.zeros'","module":"Mathlib.Combinatorics.Young.SemistandardTableau","initialProofState":"μ : YoungDiagram\nself : SemistandardYoungTableau μ\ni j : Nat\na✝ : Not (Membership.mem μ { fst := i, snd := j })\n⊢ Eq (self.entry i j) 0","decl":"/-- A semistandard Young tableau is a filling of the cells of a Young diagram by natural\nnumbers, such that the entries in each row are weakly increasing (left to right), and the entries\nin each column are strictly increasing (top to bottom).\n\nHere, a semistandard Young tableau is represented as an unrestricted function `ℕ → ℕ → ℕ` that, for\nreasons of extensionality, is required to vanish outside `μ`. -/\nstructure SemistandardYoungTableau (μ : YoungDiagram) where\n  /-- `entry i j` is value of the `(i, j)` entry of the SSYT `μ`. -/\n  entry : ℕ → ℕ → ℕ\n  /-- The entries in each row are weakly increasing (left to right). -/\n  row_weak' : ∀ {i j1 j2 : ℕ}, j1 < j2 → (i, j2) ∈ μ → entry i j1 ≤ entry i j2\n  /-- The entries in each column are strictly increasing (top to bottom). -/\n  col_strict' : ∀ {i1 i2 j : ℕ}, i1 < i2 → (i2, j) ∈ μ → entry i1 j < entry i2 j\n  /-- `entry` is required to be zero for all pairs `(i, j) ∉ μ`. -/\n  zeros' : ∀ {i j}, (i, j) ∉ μ → entry i j = 0\n\n"}
{"name":"SemistandardYoungTableau.mk.injEq","module":"Mathlib.Combinatorics.Young.SemistandardTableau","initialProofState":"μ : YoungDiagram\nentry✝ : Nat → Nat → Nat\nrow_weak'✝ : ∀ {i j1 j2 : Nat}, LT.lt j1 j2 → Membership.mem μ { fst := i, snd := j2 } → LE.le (entry✝ i j1) (entry✝ i j2)\ncol_strict'✝ : ∀ {i1 i2 j : Nat}, LT.lt i1 i2 → Membership.mem μ { fst := i2, snd := j } → LT.lt (entry✝ i1 j) (entry✝ i2 j)\nzeros'✝ : ∀ {i j : Nat}, Not (Membership.mem μ { fst := i, snd := j }) → Eq (entry✝ i j) 0\nentry : Nat → Nat → Nat\nrow_weak' : ∀ {i j1 j2 : Nat}, LT.lt j1 j2 → Membership.mem μ { fst := i, snd := j2 } → LE.le (entry i j1) (entry i j2)\ncol_strict' : ∀ {i1 i2 j : Nat}, LT.lt i1 i2 → Membership.mem μ { fst := i2, snd := j } → LT.lt (entry i1 j) (entry i2 j)\nzeros' : ∀ {i j : Nat}, Not (Membership.mem μ { fst := i, snd := j }) → Eq (entry i j) 0\n⊢ Eq (Eq { entry := entry✝, row_weak' := row_weak'✝, col_strict' := col_strict'✝, zeros' := zeros'✝ } { entry := entry, row_weak' := row_weak', col_strict' := col_strict', zeros' := zeros' }) (Eq entry✝ entry)","decl":"/-- A semistandard Young tableau is a filling of the cells of a Young diagram by natural\nnumbers, such that the entries in each row are weakly increasing (left to right), and the entries\nin each column are strictly increasing (top to bottom).\n\nHere, a semistandard Young tableau is represented as an unrestricted function `ℕ → ℕ → ℕ` that, for\nreasons of extensionality, is required to vanish outside `μ`. -/\nstructure SemistandardYoungTableau (μ : YoungDiagram) where\n  /-- `entry i j` is value of the `(i, j)` entry of the SSYT `μ`. -/\n  entry : ℕ → ℕ → ℕ\n  /-- The entries in each row are weakly increasing (left to right). -/\n  row_weak' : ∀ {i j1 j2 : ℕ}, j1 < j2 → (i, j2) ∈ μ → entry i j1 ≤ entry i j2\n  /-- The entries in each column are strictly increasing (top to bottom). -/\n  col_strict' : ∀ {i1 i2 j : ℕ}, i1 < i2 → (i2, j) ∈ μ → entry i1 j < entry i2 j\n  /-- `entry` is required to be zero for all pairs `(i, j) ∉ μ`. -/\n  zeros' : ∀ {i j}, (i, j) ∉ μ → entry i j = 0\n\n"}
{"name":"SemistandardYoungTableau.mk.inj","module":"Mathlib.Combinatorics.Young.SemistandardTableau","initialProofState":"μ : YoungDiagram\nentry✝ : Nat → Nat → Nat\nrow_weak'✝ : ∀ {i j1 j2 : Nat}, LT.lt j1 j2 → Membership.mem μ { fst := i, snd := j2 } → LE.le (entry✝ i j1) (entry✝ i j2)\ncol_strict'✝ : ∀ {i1 i2 j : Nat}, LT.lt i1 i2 → Membership.mem μ { fst := i2, snd := j } → LT.lt (entry✝ i1 j) (entry✝ i2 j)\nzeros'✝ : ∀ {i j : Nat}, Not (Membership.mem μ { fst := i, snd := j }) → Eq (entry✝ i j) 0\nentry : Nat → Nat → Nat\nrow_weak' : ∀ {i j1 j2 : Nat}, LT.lt j1 j2 → Membership.mem μ { fst := i, snd := j2 } → LE.le (entry i j1) (entry i j2)\ncol_strict' : ∀ {i1 i2 j : Nat}, LT.lt i1 i2 → Membership.mem μ { fst := i2, snd := j } → LT.lt (entry i1 j) (entry i2 j)\nzeros' : ∀ {i j : Nat}, Not (Membership.mem μ { fst := i, snd := j }) → Eq (entry i j) 0\nx✝ : Eq { entry := entry✝, row_weak' := row_weak'✝, col_strict' := col_strict'✝, zeros' := zeros'✝ } { entry := entry, row_weak' := row_weak', col_strict' := col_strict', zeros' := zeros' }\n⊢ Eq entry✝ entry","decl":"/-- A semistandard Young tableau is a filling of the cells of a Young diagram by natural\nnumbers, such that the entries in each row are weakly increasing (left to right), and the entries\nin each column are strictly increasing (top to bottom).\n\nHere, a semistandard Young tableau is represented as an unrestricted function `ℕ → ℕ → ℕ` that, for\nreasons of extensionality, is required to vanish outside `μ`. -/\nstructure SemistandardYoungTableau (μ : YoungDiagram) where\n  /-- `entry i j` is value of the `(i, j)` entry of the SSYT `μ`. -/\n  entry : ℕ → ℕ → ℕ\n  /-- The entries in each row are weakly increasing (left to right). -/\n  row_weak' : ∀ {i j1 j2 : ℕ}, j1 < j2 → (i, j2) ∈ μ → entry i j1 ≤ entry i j2\n  /-- The entries in each column are strictly increasing (top to bottom). -/\n  col_strict' : ∀ {i1 i2 j : ℕ}, i1 < i2 → (i2, j) ∈ μ → entry i1 j < entry i2 j\n  /-- `entry` is required to be zero for all pairs `(i, j) ∉ μ`. -/\n  zeros' : ∀ {i j}, (i, j) ∉ μ → entry i j = 0\n\n"}
{"name":"SemistandardYoungTableau.col_strict'","module":"Mathlib.Combinatorics.Young.SemistandardTableau","initialProofState":"μ : YoungDiagram\nself : SemistandardYoungTableau μ\ni1 i2 j : Nat\na✝¹ : LT.lt i1 i2\na✝ : Membership.mem μ { fst := i2, snd := j }\n⊢ LT.lt (self.entry i1 j) (self.entry i2 j)","decl":"/-- A semistandard Young tableau is a filling of the cells of a Young diagram by natural\nnumbers, such that the entries in each row are weakly increasing (left to right), and the entries\nin each column are strictly increasing (top to bottom).\n\nHere, a semistandard Young tableau is represented as an unrestricted function `ℕ → ℕ → ℕ` that, for\nreasons of extensionality, is required to vanish outside `μ`. -/\nstructure SemistandardYoungTableau (μ : YoungDiagram) where\n  /-- `entry i j` is value of the `(i, j)` entry of the SSYT `μ`. -/\n  entry : ℕ → ℕ → ℕ\n  /-- The entries in each row are weakly increasing (left to right). -/\n  row_weak' : ∀ {i j1 j2 : ℕ}, j1 < j2 → (i, j2) ∈ μ → entry i j1 ≤ entry i j2\n  /-- The entries in each column are strictly increasing (top to bottom). -/\n  col_strict' : ∀ {i1 i2 j : ℕ}, i1 < i2 → (i2, j) ∈ μ → entry i1 j < entry i2 j\n  /-- `entry` is required to be zero for all pairs `(i, j) ∉ μ`. -/\n  zeros' : ∀ {i j}, (i, j) ∉ μ → entry i j = 0\n\n"}
{"name":"SemistandardYoungTableau.row_weak'","module":"Mathlib.Combinatorics.Young.SemistandardTableau","initialProofState":"μ : YoungDiagram\nself : SemistandardYoungTableau μ\ni j1 j2 : Nat\na✝¹ : LT.lt j1 j2\na✝ : Membership.mem μ { fst := i, snd := j2 }\n⊢ LE.le (self.entry i j1) (self.entry i j2)","decl":"/-- A semistandard Young tableau is a filling of the cells of a Young diagram by natural\nnumbers, such that the entries in each row are weakly increasing (left to right), and the entries\nin each column are strictly increasing (top to bottom).\n\nHere, a semistandard Young tableau is represented as an unrestricted function `ℕ → ℕ → ℕ` that, for\nreasons of extensionality, is required to vanish outside `μ`. -/\nstructure SemistandardYoungTableau (μ : YoungDiagram) where\n  /-- `entry i j` is value of the `(i, j)` entry of the SSYT `μ`. -/\n  entry : ℕ → ℕ → ℕ\n  /-- The entries in each row are weakly increasing (left to right). -/\n  row_weak' : ∀ {i j1 j2 : ℕ}, j1 < j2 → (i, j2) ∈ μ → entry i j1 ≤ entry i j2\n  /-- The entries in each column are strictly increasing (top to bottom). -/\n  col_strict' : ∀ {i1 i2 j : ℕ}, i1 < i2 → (i2, j) ∈ μ → entry i1 j < entry i2 j\n  /-- `entry` is required to be zero for all pairs `(i, j) ∉ μ`. -/\n  zeros' : ∀ {i j}, (i, j) ∉ μ → entry i j = 0\n\n"}
{"name":"SemistandardYoungTableau.to_fun_eq_coe","module":"Mathlib.Combinatorics.Young.SemistandardTableau","initialProofState":"μ : YoungDiagram\nT : SemistandardYoungTableau μ\n⊢ Eq T.entry ⇑T","decl":"@[simp]\ntheorem to_fun_eq_coe {μ : YoungDiagram} {T : SemistandardYoungTableau μ} :\n    T.entry = (T : ℕ → ℕ → ℕ) :=\n  rfl\n\n"}
{"name":"SemistandardYoungTableau.ext_iff","module":"Mathlib.Combinatorics.Young.SemistandardTableau","initialProofState":"μ : YoungDiagram\nT T' : SemistandardYoungTableau μ\n⊢ Iff (Eq T T') (∀ (i j : Nat), Eq (T i j) (T' i j))","decl":"@[ext]\ntheorem ext {μ : YoungDiagram} {T T' : SemistandardYoungTableau μ} (h : ∀ i j, T i j = T' i j) :\n    T = T' :=\n  DFunLike.ext T T' fun _ ↦ by\n    funext\n    apply h\n\n"}
{"name":"SemistandardYoungTableau.ext","module":"Mathlib.Combinatorics.Young.SemistandardTableau","initialProofState":"μ : YoungDiagram\nT T' : SemistandardYoungTableau μ\nh : ∀ (i j : Nat), Eq (T i j) (T' i j)\n⊢ Eq T T'","decl":"@[ext]\ntheorem ext {μ : YoungDiagram} {T T' : SemistandardYoungTableau μ} (h : ∀ i j, T i j = T' i j) :\n    T = T' :=\n  DFunLike.ext T T' fun _ ↦ by\n    funext\n    apply h\n\n"}
{"name":"SemistandardYoungTableau.coe_copy","module":"Mathlib.Combinatorics.Young.SemistandardTableau","initialProofState":"μ : YoungDiagram\nT : SemistandardYoungTableau μ\nentry' : Nat → Nat → Nat\nh : Eq entry' ⇑T\n⊢ Eq (⇑(T.copy entry' h)) entry'","decl":"@[simp]\ntheorem coe_copy {μ : YoungDiagram} (T : SemistandardYoungTableau μ) (entry' : ℕ → ℕ → ℕ)\n    (h : entry' = T) : ⇑(T.copy entry' h) = entry' :=\n  rfl\n\n"}
{"name":"SemistandardYoungTableau.copy_eq","module":"Mathlib.Combinatorics.Young.SemistandardTableau","initialProofState":"μ : YoungDiagram\nT : SemistandardYoungTableau μ\nentry' : Nat → Nat → Nat\nh : Eq entry' ⇑T\n⊢ Eq (T.copy entry' h) T","decl":"theorem copy_eq {μ : YoungDiagram} (T : SemistandardYoungTableau μ) (entry' : ℕ → ℕ → ℕ)\n    (h : entry' = T) : T.copy entry' h = T :=\n  DFunLike.ext' h\n\n"}
{"name":"SemistandardYoungTableau.row_weak","module":"Mathlib.Combinatorics.Young.SemistandardTableau","initialProofState":"μ : YoungDiagram\nT : SemistandardYoungTableau μ\ni j1 j2 : Nat\nhj : LT.lt j1 j2\nhcell : Membership.mem μ { fst := i, snd := j2 }\n⊢ LE.le (T i j1) (T i j2)","decl":"theorem row_weak {μ : YoungDiagram} (T : SemistandardYoungTableau μ) {i j1 j2 : ℕ} (hj : j1 < j2)\n    (hcell : (i, j2) ∈ μ) : T i j1 ≤ T i j2 :=\n  T.row_weak' hj hcell\n\n"}
{"name":"SemistandardYoungTableau.col_strict","module":"Mathlib.Combinatorics.Young.SemistandardTableau","initialProofState":"μ : YoungDiagram\nT : SemistandardYoungTableau μ\ni1 i2 j : Nat\nhi : LT.lt i1 i2\nhcell : Membership.mem μ { fst := i2, snd := j }\n⊢ LT.lt (T i1 j) (T i2 j)","decl":"theorem col_strict {μ : YoungDiagram} (T : SemistandardYoungTableau μ) {i1 i2 j : ℕ} (hi : i1 < i2)\n    (hcell : (i2, j) ∈ μ) : T i1 j < T i2 j :=\n  T.col_strict' hi hcell\n\n"}
{"name":"SemistandardYoungTableau.zeros","module":"Mathlib.Combinatorics.Young.SemistandardTableau","initialProofState":"μ : YoungDiagram\nT : SemistandardYoungTableau μ\ni j : Nat\nnot_cell : Not (Membership.mem μ { fst := i, snd := j })\n⊢ Eq (T i j) 0","decl":"theorem zeros {μ : YoungDiagram} (T : SemistandardYoungTableau μ) {i j : ℕ}\n    (not_cell : (i, j) ∉ μ) : T i j = 0 :=\n  T.zeros' not_cell\n\n"}
{"name":"SemistandardYoungTableau.row_weak_of_le","module":"Mathlib.Combinatorics.Young.SemistandardTableau","initialProofState":"μ : YoungDiagram\nT : SemistandardYoungTableau μ\ni j1 j2 : Nat\nhj : LE.le j1 j2\ncell : Membership.mem μ { fst := i, snd := j2 }\n⊢ LE.le (T i j1) (T i j2)","decl":"theorem row_weak_of_le {μ : YoungDiagram} (T : SemistandardYoungTableau μ) {i j1 j2 : ℕ}\n    (hj : j1 ≤ j2) (cell : (i, j2) ∈ μ) : T i j1 ≤ T i j2 := by\n  cases' eq_or_lt_of_le hj with h h\n  · rw [h]\n  · exact T.row_weak h cell\n\n"}
{"name":"SemistandardYoungTableau.col_weak","module":"Mathlib.Combinatorics.Young.SemistandardTableau","initialProofState":"μ : YoungDiagram\nT : SemistandardYoungTableau μ\ni1 i2 j : Nat\nhi : LE.le i1 i2\ncell : Membership.mem μ { fst := i2, snd := j }\n⊢ LE.le (T i1 j) (T i2 j)","decl":"theorem col_weak {μ : YoungDiagram} (T : SemistandardYoungTableau μ) {i1 i2 j : ℕ} (hi : i1 ≤ i2)\n    (cell : (i2, j) ∈ μ) : T i1 j ≤ T i2 j := by\n  cases' eq_or_lt_of_le hi with h h\n  · rw [h]\n  · exact le_of_lt (T.col_strict h cell)\n\n"}
{"name":"SemistandardYoungTableau.highestWeight_apply","module":"Mathlib.Combinatorics.Young.SemistandardTableau","initialProofState":"μ : YoungDiagram\ni j : Nat\n⊢ Eq ((SemistandardYoungTableau.highestWeight μ) i j) (ite (Membership.mem μ { fst := i, snd := j }) i 0)","decl":"@[simp]\ntheorem highestWeight_apply {μ : YoungDiagram} {i j : ℕ} :\n    highestWeight μ i j = if (i, j) ∈ μ then i else 0 :=\n  rfl\n\n"}
