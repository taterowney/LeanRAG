{"name":"numDerangements_tendsto_inv_e","module":"Mathlib.Combinatorics.Derangements.Exponential","initialProofState":"‚ä¢ Filter.Tendsto (fun n => HDiv.hDiv ‚Üë(numDerangements n) ‚Üën.factorial) Filter.atTop (nhds (Real.exp (-1)))","decl":"theorem numDerangements_tendsto_inv_e :\n    Tendsto (fun n => (numDerangements n : ‚Ñù) / n.factorial) atTop (ùìù (Real.exp (-1))) := by\n  -- we show that d(n)/n! is the partial sum of exp(-1), but offset by 1.\n  -- this isn't entirely obvious, since we have to ensure that asc_factorial and\n  -- factorial interact in the right way, e.g., that k ‚â§ n always\n  let s : ‚Ñï ‚Üí ‚Ñù := fun n => ‚àë k ‚àà Finset.range n, (-1 : ‚Ñù) ^ k / k.factorial\n  suffices ‚àÄ n : ‚Ñï, (numDerangements n : ‚Ñù) / n.factorial = s (n + 1) by\n    simp_rw [this]\n    -- shift the function by 1, and then use the fact that the partial sums\n    -- converge to the infinite sum\n    rw [tendsto_add_atTop_iff_nat\n      (f := fun n => ‚àë k ‚àà Finset.range n, (-1 : ‚Ñù) ^ k / k.factorial) 1]\n    apply HasSum.tendsto_sum_nat\n    -- there's no specific lemma for ‚Ñù that ‚àë x^k/k! sums to exp(x), but it's\n    -- true in more general fields, so use that lemma\n    rw [Real.exp_eq_exp_‚Ñù]\n    exact expSeries_div_hasSum_exp ‚Ñù (-1 : ‚Ñù)\n  intro n\n  rw [‚Üê Int.cast_natCast, numDerangements_sum]\n  push_cast\n  rw [Finset.sum_div]\n  -- get down to individual terms\n  refine Finset.sum_congr (refl _) ?_\n  intro k hk\n  have h_le : k ‚â§ n := Finset.mem_range_succ_iff.mp hk\n  rw [Nat.ascFactorial_eq_div, add_tsub_cancel_of_le h_le]\n  push_cast [Nat.factorial_dvd_factorial h_le]\n  field_simp [Nat.factorial_ne_zero]\n  ring\n"}
