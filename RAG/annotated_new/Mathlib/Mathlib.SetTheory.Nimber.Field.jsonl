{"name":"Nimber.instCharPOfNatNat","module":"Mathlib.SetTheory.Nimber.Field","initialProofState":"⊢ CharP Nimber 2","decl":"instance : CharP Nimber 2 := by\n  apply CharTwo.of_one_ne_zero_of_two_eq_zero one_ne_zero\n  rw [← one_add_one_eq_two, add_self]\n\n"}
{"name":"Nimber.mul_def","module":"Mathlib.SetTheory.Nimber.Field","initialProofState":"a b : Nimber\n⊢ Eq (HMul.hMul a b) (InfSet.sInf (HasCompl.compl (setOf fun x => Exists fun a' => And (LT.lt a' a) (Exists fun b' => And (LT.lt b' b) (Eq (HAdd.hAdd (HAdd.hAdd (HMul.hMul a' b) (HMul.hMul a b')) (HMul.hMul a' b')) x)))))","decl":"theorem mul_def (a b : Nimber) :\n    a * b = sInf {x | ∃ a' < a, ∃ b' < b, a' * b + a * b' + a' * b' = x}ᶜ := by\n  change Nimber.mul a b = _\n  rw [Nimber.mul]\n  simp_rw [exists_prop]\n  rfl\n\n"}
{"name":"Nimber.exists_of_lt_mul","module":"Mathlib.SetTheory.Nimber.Field","initialProofState":"a b c : Nimber\nh : LT.lt c (HMul.hMul a b)\n⊢ Exists fun a' => And (LT.lt a' a) (Exists fun b' => And (LT.lt b' b) (Eq (HAdd.hAdd (HAdd.hAdd (HMul.hMul a' b) (HMul.hMul a b')) (HMul.hMul a' b')) c))","decl":"theorem exists_of_lt_mul (h : c < a * b) : ∃ a' < a, ∃ b' < b, a' * b + a * b' + a' * b' = c := by\n  rw [mul_def] at h\n  have := not_mem_of_lt_csInf' h\n  rwa [Set.not_mem_compl_iff] at this\n\n"}
{"name":"Nimber.mul_le_of_forall_ne","module":"Mathlib.SetTheory.Nimber.Field","initialProofState":"a b c : Nimber\nh : ∀ (a' : Nimber), LT.lt a' a → ∀ (b' : Nimber), LT.lt b' b → Ne (HAdd.hAdd (HAdd.hAdd (HMul.hMul a' b) (HMul.hMul a b')) (HMul.hMul a' b')) c\n⊢ LE.le (HMul.hMul a b) c","decl":"theorem mul_le_of_forall_ne (h : ∀ a' < a, ∀ b' < b, a' * b + a * b' + a' * b' ≠ c) :\n    a * b ≤ c := by\n  by_contra! h'\n  have := exists_of_lt_mul h'\n  tauto\n\n"}
{"name":"Nimber.instNoZeroDivisors","module":"Mathlib.SetTheory.Nimber.Field","initialProofState":"⊢ NoZeroDivisors Nimber","decl":"instance : NoZeroDivisors Nimber where\n  eq_zero_or_eq_zero_of_mul_eq_zero {a b} h := by\n    by_contra! hab\n    iterate 2 rw [← Nimber.pos_iff_ne_zero] at hab\n    apply (mul_ne_of_lt _ hab.1 _ hab.2).symm\n    simpa only [zero_add, mul_zero, zero_mul]\n\n"}
{"name":"Nimber.mul_comm","module":"Mathlib.SetTheory.Nimber.Field","initialProofState":"a b : Nimber\n⊢ Eq (HMul.hMul a b) (HMul.hMul b a)","decl":"protected theorem mul_comm (a b : Nimber) : a * b = b * a := by\n  apply le_antisymm <;> refine mul_le_of_forall_ne fun x hx y hy ↦ ?_\n  on_goal 1 => rw [add_comm (x * _), Nimber.mul_comm a, Nimber.mul_comm x, Nimber.mul_comm x]\n  on_goal 2 => rw [add_comm (x * _), ← Nimber.mul_comm y, ← Nimber.mul_comm a, ← Nimber.mul_comm y]\n  all_goals exact mul_ne_of_lt y hy x hx\ntermination_by (a, b)\n\n"}
{"name":"Nimber.mul_add","module":"Mathlib.SetTheory.Nimber.Field","initialProofState":"a b c : Nimber\n⊢ Eq (HMul.hMul a (HAdd.hAdd b c)) (HAdd.hAdd (HMul.hMul a b) (HMul.hMul a c))","decl":"protected theorem mul_add (a b c : Nimber) : a * (b + c) = a * b + a * c := by\n  apply le_antisymm\n  · refine mul_le_of_forall_ne fun a' ha x hx ↦ ?_\n    obtain (⟨b', h, rfl⟩ | ⟨c', h, rfl⟩) := exists_of_lt_add hx <;>\n      rw [Nimber.mul_add a', Nimber.mul_add a, Nimber.mul_add a']\n    on_goal 1 => rw [← add_ne_add_left (a * c)]\n    on_goal 2 => rw [← add_ne_add_left (a * b)]\n    all_goals\n      abel_nf\n      simp only [two_zsmul, zero_add]\n      rw [← add_assoc]\n      exact mul_ne_of_lt _ ha _ h\n  · apply add_le_of_forall_ne <;>\n      (intro x' hx'; obtain ⟨x, hx, y, hy, rfl⟩ := exists_of_lt_mul hx')\n    · obtain h | h | h := lt_trichotomy (y + c) (b + c)\n      · have H := mul_ne_of_lt _ hx _ h\n        rw [Nimber.mul_add x, Nimber.mul_add a, Nimber.mul_add x] at H\n        abel_nf at H ⊢\n        simpa only [two_zsmul, zero_add] using H\n      · exact (hy.ne <| add_left_injective _ h).elim\n      · obtain ⟨z, hz, hz'⟩ | ⟨c', hc, hc'⟩ := exists_of_lt_add h\n        · exact ((hz.trans hy).ne <| add_left_injective _ hz').elim\n        · have := add_eq_iff_eq_add.1 hc'\n          have H := mul_ne_of_lt _ hx _ hc\n          rw [← hc', Nimber.mul_add a y c', ← add_ne_add_left (a * y), ← add_ne_add_left (a * c),\n            ← add_ne_add_left (a * c'), ← add_eq_iff_eq_add.2 hc', Nimber.mul_add x,\n            Nimber.mul_add x]\n          abel_nf at H ⊢\n          simpa only [two_zsmul, add_zero, zero_add] using H\n    · obtain h | h | h := lt_trichotomy (b + y) (b + c)\n      · have H := mul_ne_of_lt _ hx _ h\n        rw [Nimber.mul_add x, Nimber.mul_add a, Nimber.mul_add x] at H\n        abel_nf at H ⊢\n        simpa only [two_zsmul, zero_add] using H\n      · exact (hy.ne <| add_right_injective _ h).elim\n      · obtain ⟨b', hb, hb'⟩ | ⟨z, hz, hz'⟩ := exists_of_lt_add h\n        · have H := mul_ne_of_lt _ hx _ hb\n          have hb'' := add_eq_iff_eq_add.2 (add_comm b c ▸ hb')\n          rw [← hb', Nimber.mul_add a b', ← add_ne_add_left (a * y), ← add_ne_add_left (a * b),\n            ← add_ne_add_left (a * b'), ← hb'', Nimber.mul_add x, Nimber.mul_add x]\n          abel_nf at H ⊢\n          simpa only [two_zsmul, add_zero, zero_add] using H\n        · exact ((hz.trans hy).ne <| add_right_injective _ hz').elim\ntermination_by (a, b, c)\n\n"}
{"name":"Nimber.add_mul","module":"Mathlib.SetTheory.Nimber.Field","initialProofState":"a b c : Nimber\n⊢ Eq (HMul.hMul (HAdd.hAdd a b) c) (HAdd.hAdd (HMul.hMul a c) (HMul.hMul b c))","decl":"protected theorem add_mul (a b c : Nimber) : (a + b) * c = a * c + b * c := by\n  rw [Nimber.mul_comm, Nimber.mul_add, Nimber.mul_comm, Nimber.mul_comm b]\n\n"}
{"name":"Nimber.mul_assoc","module":"Mathlib.SetTheory.Nimber.Field","initialProofState":"a b c : Nimber\n⊢ Eq (HMul.hMul (HMul.hMul a b) c) (HMul.hMul a (HMul.hMul b c))","decl":"protected theorem mul_assoc (a b c : Nimber) : a * b * c = a * (b * c) := by\n  apply le_antisymm <;> refine mul_le_of_forall_ne fun x hx y hy ↦ ?_\n  · obtain ⟨a', ha, b', hb, rfl⟩ := exists_of_lt_mul hx\n    have H : (a + a') * ((b + b') * (c + y)) ≠ 0 := by\n      apply mul_ne_zero _ (mul_ne_zero _ _) <;> apply add_ne_zero_of_lt\n      assumption'\n    simp only [Nimber.add_mul, Nimber.mul_add] at H ⊢\n    iterate 7 rw [Nimber.mul_assoc]\n    rw [← add_ne_add_left (a * (b * c))]\n    abel_nf at H ⊢\n    simpa only [two_zsmul, zero_add] using H\n  · obtain ⟨b', hb, c', hc, rfl⟩ := exists_of_lt_mul hy\n    have H : (a + x) * (b + b') * (c + c') ≠ 0 := by\n      apply mul_ne_zero (mul_ne_zero _ _) <;> apply add_ne_zero_of_lt\n      assumption'\n    simp only [Nimber.add_mul, Nimber.mul_add] at H ⊢\n    iterate 7 rw [← Nimber.mul_assoc]\n    rw [← add_ne_add_left (a * b * c)]\n    abel_nf at H ⊢\n    simpa only [two_zsmul, zero_add] using H\ntermination_by (a, b, c)\n\n"}
{"name":"Nimber.instIsCancelMulZero","module":"Mathlib.SetTheory.Nimber.Field","initialProofState":"⊢ IsCancelMulZero Nimber","decl":"instance : IsCancelMulZero Nimber where\n  mul_left_cancel_of_ne_zero ha h := by\n    rw [← add_eq_zero, ← Nimber.mul_add, mul_eq_zero] at h\n    exact add_eq_zero.1 (h.resolve_left ha)\n  mul_right_cancel_of_ne_zero ha h := by\n    rw [← add_eq_zero, ← Nimber.add_mul, mul_eq_zero] at h\n    exact add_eq_zero.1 (h.resolve_right ha)\n\n"}
{"name":"Nimber.one_mul","module":"Mathlib.SetTheory.Nimber.Field","initialProofState":"a : Nimber\n⊢ Eq (HMul.hMul 1 a) a","decl":"protected theorem one_mul (a : Nimber) : 1 * a = a := by\n  apply le_antisymm\n  · refine mul_le_of_forall_ne fun x hx y hy ↦ ?_\n    rw [Nimber.lt_one_iff_zero] at hx\n    rw [hx, Nimber.one_mul, zero_mul, zero_mul, add_zero, zero_add]\n    exact hy.ne\n  · by_contra! h\n    replace h := h -- needed to remind `termination_by`\n    exact (mul_left_cancel₀ one_ne_zero <| Nimber.one_mul _).not_lt h\ntermination_by a\n\n"}
{"name":"Nimber.mul_one","module":"Mathlib.SetTheory.Nimber.Field","initialProofState":"a : Nimber\n⊢ Eq (HMul.hMul a 1) a","decl":"protected theorem mul_one (a : Nimber) : a * 1 = a := by\n  rw [Nimber.mul_comm, Nimber.one_mul]\n\n"}
{"name":"Nimber.instIsDomain","module":"Mathlib.SetTheory.Nimber.Field","initialProofState":"⊢ IsDomain Nimber","decl":"instance : IsDomain Nimber where\n"}
