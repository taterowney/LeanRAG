{"name":"Multiset.sym2_coe","module":"Mathlib.Data.Multiset.Sym","initialProofState":"α : Type u_1\nxs : List α\n⊢ Eq (↑xs).sym2 ↑xs.sym2","decl":"@[simp] theorem sym2_coe (xs : List α) : (xs : Multiset α).sym2 = xs.sym2 := rfl\n\n"}
{"name":"Multiset.sym2_eq_zero_iff","module":"Mathlib.Data.Multiset.Sym","initialProofState":"α : Type u_1\nm : Multiset α\n⊢ Iff (Eq m.sym2 0) (Eq m 0)","decl":"@[simp]\ntheorem sym2_eq_zero_iff {m : Multiset α} : m.sym2 = 0 ↔ m = 0 :=\n  m.inductionOn fun xs => by simp\n\n"}
{"name":"Multiset.sym2_zero","module":"Mathlib.Data.Multiset.Sym","initialProofState":"α : Type u_1\n⊢ Eq (Multiset.sym2 0) 0","decl":"@[simp]\ntheorem sym2_zero : (0 : Multiset α).sym2 = 0 := rfl\n\n"}
{"name":"Multiset.sym2_cons","module":"Mathlib.Data.Multiset.Sym","initialProofState":"α : Type u_1\na : α\nm : Multiset α\n⊢ Eq (Multiset.cons a m).sym2 (HAdd.hAdd (Multiset.map (fun b => Sym2.mk { fst := a, snd := b }) (Multiset.cons a m)) m.sym2)","decl":"theorem sym2_cons (a : α) (m : Multiset α) :\n    (m.cons a).sym2 = ((m.cons a).map <| fun b => s(a, b)) + m.sym2 :=\n  m.inductionOn fun _ => rfl\n\n"}
{"name":"Multiset.sym2_map","module":"Mathlib.Data.Multiset.Sym","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nm : Multiset α\n⊢ Eq (Multiset.map f m).sym2 (Multiset.map (Sym2.map f) m.sym2)","decl":"theorem sym2_map (f : α → β) (m : Multiset α) :\n    (m.map f).sym2 = m.sym2.map (Sym2.map f) :=\n  m.inductionOn fun xs => by simp [List.sym2_map]\n\n"}
{"name":"Multiset.mk_mem_sym2_iff","module":"Mathlib.Data.Multiset.Sym","initialProofState":"α : Type u_1\nm : Multiset α\na b : α\n⊢ Iff (Membership.mem m.sym2 (Sym2.mk { fst := a, snd := b })) (And (Membership.mem m a) (Membership.mem m b))","decl":"theorem mk_mem_sym2_iff {m : Multiset α} {a b : α} :\n    s(a, b) ∈ m.sym2 ↔ a ∈ m ∧ b ∈ m :=\n  m.inductionOn fun xs => by simp [List.mk_mem_sym2_iff]\n\n"}
{"name":"Multiset.mem_sym2_iff","module":"Mathlib.Data.Multiset.Sym","initialProofState":"α : Type u_1\nm : Multiset α\nz : Sym2 α\n⊢ Iff (Membership.mem m.sym2 z) (∀ (y : α), Membership.mem z y → Membership.mem m y)","decl":"theorem mem_sym2_iff {m : Multiset α} {z : Sym2 α} :\n    z ∈ m.sym2 ↔ ∀ y ∈ z, y ∈ m :=\n  m.inductionOn fun xs => by simp [List.mem_sym2_iff]\n\n"}
{"name":"Multiset.Nodup.sym2","module":"Mathlib.Data.Multiset.Sym","initialProofState":"α : Type u_1\nm : Multiset α\nh : m.Nodup\n⊢ m.sym2.Nodup","decl":"protected theorem Nodup.sym2 {m : Multiset α} (h : m.Nodup) : m.sym2.Nodup :=\n  m.inductionOn (fun _ h => List.Nodup.sym2 h) h\n\n"}
{"name":"Multiset.sym2_mono","module":"Mathlib.Data.Multiset.Sym","initialProofState":"α : Type u_1\nm m' : Multiset α\nh : LE.le m m'\n⊢ LE.le m.sym2 m'.sym2","decl":"open scoped List in\n@[simp, mono]\ntheorem sym2_mono {m m' : Multiset α} (h : m ≤ m') : m.sym2 ≤ m'.sym2 := by\n  refine Quotient.inductionOn₂ m m' (fun xs ys h => ?_) h\n  suffices xs <+~ ys from this.sym2\n  simpa only [quot_mk_to_coe, coe_le, sym2_coe] using h\n\n"}
{"name":"Multiset.monotone_sym2","module":"Mathlib.Data.Multiset.Sym","initialProofState":"α : Type u_1\n⊢ Monotone Multiset.sym2","decl":"theorem monotone_sym2 : Monotone (Multiset.sym2 : Multiset α → _) := fun _ _ => sym2_mono\n\n"}
{"name":"Multiset.card_sym2","module":"Mathlib.Data.Multiset.Sym","initialProofState":"α : Type u_1\nm : Multiset α\n⊢ Eq m.sym2.card ((HAdd.hAdd m.card 1).choose 2)","decl":"theorem card_sym2 {m : Multiset α} :\n    Multiset.card m.sym2 = Nat.choose (Multiset.card m + 1) 2 := by\n  refine m.inductionOn fun xs => ?_\n  simp [List.length_sym2]\n\n"}
{"name":"Multiset.dedup_sym2","module":"Mathlib.Data.Multiset.Sym","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\n⊢ Eq m.sym2.dedup m.dedup.sym2","decl":"theorem dedup_sym2 [DecidableEq α] (m : Multiset α) : m.sym2.dedup = m.dedup.sym2 :=\n  m.inductionOn fun xs => by simp [List.dedup_sym2]\n\n"}
