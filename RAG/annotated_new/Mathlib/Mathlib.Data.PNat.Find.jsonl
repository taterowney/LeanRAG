{"name":"PNat.find_spec","module":"Mathlib.Data.PNat.Find","initialProofState":"p : PNat → Prop\ninst✝ : DecidablePred p\nh : Exists fun n => p n\n⊢ p (PNat.find h)","decl":"protected theorem find_spec : p (PNat.find h) :=\n  (PNat.findX h).prop.left\n\n"}
{"name":"PNat.find_min","module":"Mathlib.Data.PNat.Find","initialProofState":"p : PNat → Prop\ninst✝ : DecidablePred p\nh : Exists fun n => p n\nm : PNat\na✝ : LT.lt m (PNat.find h)\n⊢ Not (p m)","decl":"protected theorem find_min : ∀ {m : ℕ+}, m < PNat.find h → ¬p m :=\n  @(PNat.findX h).prop.right\n\n"}
{"name":"PNat.find_min'","module":"Mathlib.Data.PNat.Find","initialProofState":"p : PNat → Prop\ninst✝ : DecidablePred p\nh : Exists fun n => p n\nm : PNat\nhm : p m\n⊢ LE.le (PNat.find h) m","decl":"protected theorem find_min' {m : ℕ+} (hm : p m) : PNat.find h ≤ m :=\n  le_of_not_lt fun l => PNat.find_min h l hm\n\n"}
{"name":"PNat.find_eq_iff","module":"Mathlib.Data.PNat.Find","initialProofState":"p : PNat → Prop\ninst✝ : DecidablePred p\nh : Exists fun n => p n\nm : PNat\n⊢ Iff (Eq (PNat.find h) m) (And (p m) (∀ (n : PNat), LT.lt n m → Not (p n)))","decl":"theorem find_eq_iff : PNat.find h = m ↔ p m ∧ ∀ n < m, ¬p n := by\n  constructor\n  · rintro rfl\n    exact ⟨PNat.find_spec h, fun _ => PNat.find_min h⟩\n  · rintro ⟨hm, hlt⟩\n    exact le_antisymm (PNat.find_min' h hm) (not_lt.1 <| imp_not_comm.1 (hlt _) <| PNat.find_spec h)\n\n"}
{"name":"PNat.find_lt_iff","module":"Mathlib.Data.PNat.Find","initialProofState":"p : PNat → Prop\ninst✝ : DecidablePred p\nh : Exists fun n => p n\nn : PNat\n⊢ Iff (LT.lt (PNat.find h) n) (Exists fun m => And (LT.lt m n) (p m))","decl":"@[simp]\ntheorem find_lt_iff (n : ℕ+) : PNat.find h < n ↔ ∃ m < n, p m :=\n  ⟨fun h2 => ⟨PNat.find h, h2, PNat.find_spec h⟩, fun ⟨_, hmn, hm⟩ =>\n    (PNat.find_min' h hm).trans_lt hmn⟩\n\n"}
{"name":"PNat.find_le_iff","module":"Mathlib.Data.PNat.Find","initialProofState":"p : PNat → Prop\ninst✝ : DecidablePred p\nh : Exists fun n => p n\nn : PNat\n⊢ Iff (LE.le (PNat.find h) n) (Exists fun m => And (LE.le m n) (p m))","decl":"@[simp]\ntheorem find_le_iff (n : ℕ+) : PNat.find h ≤ n ↔ ∃ m ≤ n, p m := by\n  simp only [exists_prop, ← lt_add_one_iff, find_lt_iff]\n\n"}
{"name":"PNat.le_find_iff","module":"Mathlib.Data.PNat.Find","initialProofState":"p : PNat → Prop\ninst✝ : DecidablePred p\nh : Exists fun n => p n\nn : PNat\n⊢ Iff (LE.le n (PNat.find h)) (∀ (m : PNat), LT.lt m n → Not (p m))","decl":"@[simp]\ntheorem le_find_iff (n : ℕ+) : n ≤ PNat.find h ↔ ∀ m < n, ¬p m := by\n  simp only [← not_lt, find_lt_iff, not_exists, not_and]\n\n"}
{"name":"PNat.lt_find_iff","module":"Mathlib.Data.PNat.Find","initialProofState":"p : PNat → Prop\ninst✝ : DecidablePred p\nh : Exists fun n => p n\nn : PNat\n⊢ Iff (LT.lt n (PNat.find h)) (∀ (m : PNat), LE.le m n → Not (p m))","decl":"@[simp]\ntheorem lt_find_iff (n : ℕ+) : n < PNat.find h ↔ ∀ m ≤ n, ¬p m := by\n  simp only [← add_one_le_iff, le_find_iff, add_le_add_iff_right]\n\n"}
{"name":"PNat.find_eq_one","module":"Mathlib.Data.PNat.Find","initialProofState":"p : PNat → Prop\ninst✝ : DecidablePred p\nh : Exists fun n => p n\n⊢ Iff (Eq (PNat.find h) 1) (p 1)","decl":"@[simp]\ntheorem find_eq_one : PNat.find h = 1 ↔ p 1 := by simp [find_eq_iff]\n\n-- Porting note: deleted `@[simp]` to satisfy the linter because `le_find_iff` is more general\n"}
{"name":"PNat.one_le_find","module":"Mathlib.Data.PNat.Find","initialProofState":"p : PNat → Prop\ninst✝ : DecidablePred p\nh : Exists fun n => p n\n⊢ Iff (LT.lt 1 (PNat.find h)) (Not (p 1))","decl":"theorem one_le_find : 1 < PNat.find h ↔ ¬p 1 :=\n  not_iff_not.mp <| by simp\n\n"}
{"name":"PNat.find_mono","module":"Mathlib.Data.PNat.Find","initialProofState":"p q : PNat → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidablePred q\nh : ∀ (n : PNat), q n → p n\nhp : Exists fun n => p n\nhq : Exists fun n => q n\n⊢ LE.le (PNat.find hp) (PNat.find hq)","decl":"theorem find_mono (h : ∀ n, q n → p n) {hp : ∃ n, p n} {hq : ∃ n, q n} :\n    PNat.find hp ≤ PNat.find hq :=\n  PNat.find_min' _ (h _ (PNat.find_spec hq))\n\n"}
{"name":"PNat.find_le","module":"Mathlib.Data.PNat.Find","initialProofState":"p : PNat → Prop\ninst✝ : DecidablePred p\nn : PNat\nh : Exists fun n => p n\nhn : p n\n⊢ LE.le (PNat.find h) n","decl":"theorem find_le {h : ∃ n, p n} (hn : p n) : PNat.find h ≤ n :=\n  (PNat.find_le_iff _ _).2 ⟨n, le_rfl, hn⟩\n\n"}
{"name":"PNat.find_comp_succ","module":"Mathlib.Data.PNat.Find","initialProofState":"p : PNat → Prop\ninst✝ : DecidablePred p\nh : Exists fun n => p n\nh₂ : Exists fun n => p (HAdd.hAdd n 1)\nh1 : Not (p 1)\n⊢ Eq (PNat.find h) (HAdd.hAdd (PNat.find h₂) 1)","decl":"theorem find_comp_succ (h : ∃ n, p n) (h₂ : ∃ n, p (n + 1)) (h1 : ¬p 1) :\n    PNat.find h = PNat.find h₂ + 1 := by\n  refine (find_eq_iff _).2 ⟨PNat.find_spec h₂, fun n ↦ ?_⟩\n  induction n with\n  | one => simp [h1]\n  | succ m _ =>\n    intro hm\n    simp only [add_lt_add_iff_right, lt_find_iff] at hm\n    exact hm _ le_rfl\n\n"}
